static inline char *tape_name(struct osst_tape *tape)\r\n{\r\nreturn tape->drive->disk_name;\r\n}\r\nstatic void osst_analyze_sense(struct osst_request *SRpnt, struct st_cmdstatus *s)\r\n{\r\nconst u8 *ucp;\r\nconst u8 *sense = SRpnt->sense;\r\ns->have_sense = scsi_normalize_sense(SRpnt->sense,\r\nSCSI_SENSE_BUFFERSIZE, &s->sense_hdr);\r\ns->flags = 0;\r\nif (s->have_sense) {\r\ns->deferred = 0;\r\ns->remainder_valid =\r\nscsi_get_sense_info_fld(sense, SCSI_SENSE_BUFFERSIZE, &s->uremainder64);\r\nswitch (sense[0] & 0x7f) {\r\ncase 0x71:\r\ns->deferred = 1;\r\ncase 0x70:\r\ns->fixed_format = 1;\r\ns->flags = sense[2] & 0xe0;\r\nbreak;\r\ncase 0x73:\r\ns->deferred = 1;\r\ncase 0x72:\r\ns->fixed_format = 0;\r\nucp = scsi_sense_desc_find(sense, SCSI_SENSE_BUFFERSIZE, 4);\r\ns->flags = ucp ? (ucp[3] & 0xe0) : 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int osst_chk_result(struct osst_tape * STp, struct osst_request * SRpnt)\r\n{\r\nchar *name = tape_name(STp);\r\nint result = SRpnt->result;\r\nu8 * sense = SRpnt->sense, scode;\r\n#if DEBUG\r\nconst char *stp;\r\n#endif\r\nstruct st_cmdstatus *cmdstatp;\r\nif (!result)\r\nreturn 0;\r\ncmdstatp = &STp->buffer->cmdstat;\r\nosst_analyze_sense(SRpnt, cmdstatp);\r\nif (cmdstatp->have_sense)\r\nscode = STp->buffer->cmdstat.sense_hdr.sense_key;\r\nelse\r\nscode = 0;\r\n#if DEBUG\r\nif (debugging) {\r\nprintk(OSST_DEB_MSG "%s:D: Error: %x, cmd: %x %x %x %x %x %x\n",\r\nname, result,\r\nSRpnt->cmd[0], SRpnt->cmd[1], SRpnt->cmd[2],\r\nSRpnt->cmd[3], SRpnt->cmd[4], SRpnt->cmd[5]);\r\nif (scode) printk(OSST_DEB_MSG "%s:D: Sense: %02x, ASC: %02x, ASCQ: %02x\n",\r\nname, scode, sense[12], sense[13]);\r\nif (cmdstatp->have_sense)\r\n__scsi_print_sense("osst ", SRpnt->sense, SCSI_SENSE_BUFFERSIZE);\r\n}\r\nelse\r\n#endif\r\nif (cmdstatp->have_sense && (\r\nscode != NO_SENSE &&\r\nscode != RECOVERED_ERROR &&\r\nscode != BLANK_CHECK &&\r\nscode != VOLUME_OVERFLOW &&\r\nSRpnt->cmd[0] != MODE_SENSE &&\r\nSRpnt->cmd[0] != TEST_UNIT_READY)) {\r\nif (cmdstatp->have_sense) {\r\nprintk(KERN_WARNING "%s:W: Command with sense data:\n", name);\r\n__scsi_print_sense("osst ", SRpnt->sense, SCSI_SENSE_BUFFERSIZE);\r\n}\r\nelse {\r\nstatic int notyetprinted = 1;\r\nprintk(KERN_WARNING\r\n"%s:W: Warning %x (driver bt 0x%x, host bt 0x%x).\n",\r\nname, result, driver_byte(result),\r\nhost_byte(result));\r\nif (notyetprinted) {\r\nnotyetprinted = 0;\r\nprintk(KERN_INFO\r\n"%s:I: This warning may be caused by your scsi controller,\n", name);\r\nprintk(KERN_INFO\r\n"%s:I: it has been reported with some Buslogic cards.\n", name);\r\n}\r\n}\r\n}\r\nSTp->pos_unknown |= STp->device->was_reset;\r\nif (cmdstatp->have_sense && scode == RECOVERED_ERROR) {\r\nSTp->recover_count++;\r\nSTp->recover_erreg++;\r\n#if DEBUG\r\nif (debugging) {\r\nif (SRpnt->cmd[0] == READ_6)\r\nstp = "read";\r\nelse if (SRpnt->cmd[0] == WRITE_6)\r\nstp = "write";\r\nelse\r\nstp = "ioctl";\r\nprintk(OSST_DEB_MSG "%s:D: Recovered %s error (%d).\n", name, stp,\r\nSTp->recover_count);\r\n}\r\n#endif\r\nif ((sense[2] & 0xe0) == 0)\r\nreturn 0;\r\n}\r\nreturn (-EIO);\r\n}\r\nstatic void osst_end_async(struct request *req, int update)\r\n{\r\nstruct osst_request *SRpnt = req->end_io_data;\r\nstruct osst_tape *STp = SRpnt->stp;\r\nstruct rq_map_data *mdata = &SRpnt->stp->buffer->map_data;\r\nSTp->buffer->cmdstat.midlevel_result = SRpnt->result = req->errors;\r\n#if DEBUG\r\nSTp->write_pending = 0;\r\n#endif\r\nif (SRpnt->waiting)\r\ncomplete(SRpnt->waiting);\r\nif (SRpnt->bio) {\r\nkfree(mdata->pages);\r\nblk_rq_unmap_user(SRpnt->bio);\r\n}\r\n__blk_put_request(req->q, req);\r\n}\r\nstatic struct osst_request *osst_allocate_request(void)\r\n{\r\nreturn kzalloc(sizeof(struct osst_request), GFP_KERNEL);\r\n}\r\nstatic void osst_release_request(struct osst_request *streq)\r\n{\r\nkfree(streq);\r\n}\r\nstatic int osst_execute(struct osst_request *SRpnt, const unsigned char *cmd,\r\nint cmd_len, int data_direction, void *buffer, unsigned bufflen,\r\nint use_sg, int timeout, int retries)\r\n{\r\nstruct request *req;\r\nstruct page **pages = NULL;\r\nstruct rq_map_data *mdata = &SRpnt->stp->buffer->map_data;\r\nint err = 0;\r\nint write = (data_direction == DMA_TO_DEVICE);\r\nreq = blk_get_request(SRpnt->stp->device->request_queue, write, GFP_KERNEL);\r\nif (!req)\r\nreturn DRIVER_ERROR << 24;\r\nreq->cmd_type = REQ_TYPE_BLOCK_PC;\r\nreq->cmd_flags |= REQ_QUIET;\r\nSRpnt->bio = NULL;\r\nif (use_sg) {\r\nstruct scatterlist *sg, *sgl = (struct scatterlist *)buffer;\r\nint i;\r\npages = kzalloc(use_sg * sizeof(struct page *), GFP_KERNEL);\r\nif (!pages)\r\ngoto free_req;\r\nfor_each_sg(sgl, sg, use_sg, i)\r\npages[i] = sg_page(sg);\r\nmdata->null_mapped = 1;\r\nmdata->page_order = get_order(sgl[0].length);\r\nmdata->nr_entries =\r\nDIV_ROUND_UP(bufflen, PAGE_SIZE << mdata->page_order);\r\nmdata->offset = 0;\r\nerr = blk_rq_map_user(req->q, req, mdata, NULL, bufflen, GFP_KERNEL);\r\nif (err) {\r\nkfree(pages);\r\ngoto free_req;\r\n}\r\nSRpnt->bio = req->bio;\r\nmdata->pages = pages;\r\n} else if (bufflen) {\r\nerr = blk_rq_map_kern(req->q, req, buffer, bufflen, GFP_KERNEL);\r\nif (err)\r\ngoto free_req;\r\n}\r\nreq->cmd_len = cmd_len;\r\nmemset(req->cmd, 0, BLK_MAX_CDB);\r\nmemcpy(req->cmd, cmd, req->cmd_len);\r\nreq->sense = SRpnt->sense;\r\nreq->sense_len = 0;\r\nreq->timeout = timeout;\r\nreq->retries = retries;\r\nreq->end_io_data = SRpnt;\r\nblk_execute_rq_nowait(req->q, NULL, req, 1, osst_end_async);\r\nreturn 0;\r\nfree_req:\r\nblk_put_request(req);\r\nreturn DRIVER_ERROR << 24;\r\n}\r\nstatic struct osst_request * osst_do_scsi(struct osst_request *SRpnt, struct osst_tape *STp,\r\nunsigned char *cmd, int bytes, int direction, int timeout, int retries, int do_wait)\r\n{\r\nunsigned char *bp;\r\nunsigned short use_sg;\r\n#ifdef OSST_INJECT_ERRORS\r\nstatic int inject = 0;\r\nstatic int repeat = 0;\r\n#endif\r\nstruct completion *waiting;\r\nif (!do_wait && ((STp->buffer)->last_SRpnt)) {\r\nprintk(KERN_ERR "%s: Async command already active.\n",\r\ntape_name(STp));\r\nif (signal_pending(current))\r\n(STp->buffer)->syscall_result = (-EINTR);\r\nelse\r\n(STp->buffer)->syscall_result = (-EBUSY);\r\nreturn NULL;\r\n}\r\nif (SRpnt == NULL) {\r\nSRpnt = osst_allocate_request();\r\nif (SRpnt == NULL) {\r\nprintk(KERN_ERR "%s: Can't allocate SCSI request.\n",\r\ntape_name(STp));\r\nif (signal_pending(current))\r\n(STp->buffer)->syscall_result = (-EINTR);\r\nelse\r\n(STp->buffer)->syscall_result = (-EBUSY);\r\nreturn NULL;\r\n}\r\nSRpnt->stp = STp;\r\n}\r\nif (!do_wait)\r\n(STp->buffer)->last_SRpnt = SRpnt;\r\nwaiting = &STp->wait;\r\ninit_completion(waiting);\r\nSRpnt->waiting = waiting;\r\nuse_sg = (bytes > STp->buffer->sg[0].length) ? STp->buffer->use_sg : 0;\r\nif (use_sg) {\r\nbp = (char *)&(STp->buffer->sg[0]);\r\nif (STp->buffer->sg_segs < use_sg)\r\nuse_sg = STp->buffer->sg_segs;\r\n}\r\nelse\r\nbp = (STp->buffer)->b_data;\r\nmemcpy(SRpnt->cmd, cmd, sizeof(SRpnt->cmd));\r\nSTp->buffer->cmdstat.have_sense = 0;\r\nSTp->buffer->syscall_result = 0;\r\nif (osst_execute(SRpnt, cmd, COMMAND_SIZE(cmd[0]), direction, bp, bytes,\r\nuse_sg, timeout, retries))\r\n(STp->buffer)->syscall_result = (-EBUSY);\r\nelse if (do_wait) {\r\nwait_for_completion(waiting);\r\nSRpnt->waiting = NULL;\r\nSTp->buffer->syscall_result = osst_chk_result(STp, SRpnt);\r\n#ifdef OSST_INJECT_ERRORS\r\nif (STp->buffer->syscall_result == 0 &&\r\ncmd[0] == READ_6 &&\r\ncmd[4] &&\r\n( (++ inject % 83) == 29 ||\r\n(STp->first_frame_position == 240\r\n&&\r\n++repeat < 3))) {\r\nprintk(OSST_DEB_MSG "%s:D: Injecting read error\n", tape_name(STp));\r\nSTp->buffer->last_result_fatal = 1;\r\n}\r\n#endif\r\n}\r\nreturn SRpnt;\r\n}\r\nstatic void osst_write_behind_check(struct osst_tape *STp)\r\n{\r\nstruct osst_buffer * STbuffer;\r\nSTbuffer = STp->buffer;\r\n#if DEBUG\r\nif (STp->write_pending)\r\nSTp->nbr_waits++;\r\nelse\r\nSTp->nbr_finished++;\r\n#endif\r\nwait_for_completion(&(STp->wait));\r\nSTp->buffer->last_SRpnt->waiting = NULL;\r\nSTp->buffer->syscall_result = osst_chk_result(STp, STp->buffer->last_SRpnt);\r\nif (STp->buffer->syscall_result)\r\nSTp->buffer->syscall_result =\r\nosst_write_error_recovery(STp, &(STp->buffer->last_SRpnt), 1);\r\nelse\r\nSTp->first_frame_position++;\r\nosst_release_request(STp->buffer->last_SRpnt);\r\nif (STbuffer->writing < STbuffer->buffer_bytes)\r\nprintk(KERN_WARNING "osst :A: write_behind_check: something left in buffer!\n");\r\nSTbuffer->last_SRpnt = NULL;\r\nSTbuffer->buffer_bytes -= STbuffer->writing;\r\nSTbuffer->writing = 0;\r\nreturn;\r\n}\r\nstatic void osst_init_aux(struct osst_tape * STp, int frame_type, int frame_seq_number,\r\nint logical_blk_num, int blk_sz, int blk_cnt)\r\n{\r\nos_aux_t *aux = STp->buffer->aux;\r\nos_partition_t *par = &aux->partition;\r\nos_dat_t *dat = &aux->dat;\r\nif (STp->raw) return;\r\nmemset(aux, 0, sizeof(*aux));\r\naux->format_id = htonl(0);\r\nmemcpy(aux->application_sig, "LIN4", 4);\r\naux->hdwr = htonl(0);\r\naux->frame_type = frame_type;\r\nswitch (frame_type) {\r\ncase OS_FRAME_TYPE_HEADER:\r\naux->update_frame_cntr = htonl(STp->update_frame_cntr);\r\npar->partition_num = OS_CONFIG_PARTITION;\r\npar->par_desc_ver = OS_PARTITION_VERSION;\r\npar->wrt_pass_cntr = htons(0xffff);\r\npar->first_frame_ppos = htonl(0);\r\npar->last_frame_ppos = htonl(0xbb7);\r\naux->frame_seq_num = htonl(0);\r\naux->logical_blk_num_high = htonl(0);\r\naux->logical_blk_num = htonl(0);\r\naux->next_mark_ppos = htonl(STp->first_mark_ppos);\r\nbreak;\r\ncase OS_FRAME_TYPE_DATA:\r\ncase OS_FRAME_TYPE_MARKER:\r\ndat->dat_sz = 8;\r\ndat->reserved1 = 0;\r\ndat->entry_cnt = 1;\r\ndat->reserved3 = 0;\r\ndat->dat_list[0].blk_sz = htonl(blk_sz);\r\ndat->dat_list[0].blk_cnt = htons(blk_cnt);\r\ndat->dat_list[0].flags = frame_type==OS_FRAME_TYPE_MARKER?\r\nOS_DAT_FLAGS_MARK:OS_DAT_FLAGS_DATA;\r\ndat->dat_list[0].reserved = 0;\r\ncase OS_FRAME_TYPE_EOD:\r\naux->update_frame_cntr = htonl(0);\r\npar->partition_num = OS_DATA_PARTITION;\r\npar->par_desc_ver = OS_PARTITION_VERSION;\r\npar->wrt_pass_cntr = htons(STp->wrt_pass_cntr);\r\npar->first_frame_ppos = htonl(STp->first_data_ppos);\r\npar->last_frame_ppos = htonl(STp->capacity);\r\naux->frame_seq_num = htonl(frame_seq_number);\r\naux->logical_blk_num_high = htonl(0);\r\naux->logical_blk_num = htonl(logical_blk_num);\r\nbreak;\r\ndefault: ;\r\n}\r\naux->filemark_cnt = htonl(STp->filemark_cnt);\r\naux->phys_fm = htonl(0xffffffff);\r\naux->last_mark_ppos = htonl(STp->last_mark_ppos);\r\naux->last_mark_lbn = htonl(STp->last_mark_lbn);\r\n}\r\nstatic int osst_verify_frame(struct osst_tape * STp, int frame_seq_number, int quiet)\r\n{\r\nchar * name = tape_name(STp);\r\nos_aux_t * aux = STp->buffer->aux;\r\nos_partition_t * par = &(aux->partition);\r\nstruct st_partstat * STps = &(STp->ps[STp->partition]);\r\nint blk_cnt, blk_sz, i;\r\nif (STp->raw) {\r\nif (STp->buffer->syscall_result) {\r\nfor (i=0; i < STp->buffer->sg_segs; i++)\r\nmemset(page_address(sg_page(&STp->buffer->sg[i])),\r\n0, STp->buffer->sg[i].length);\r\nstrcpy(STp->buffer->b_data, "READ ERROR ON FRAME");\r\n} else\r\nSTp->buffer->buffer_bytes = OS_FRAME_SIZE;\r\nreturn 1;\r\n}\r\nif (STp->buffer->syscall_result) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Skipping frame, read error\n", name);\r\n#endif\r\nreturn 0;\r\n}\r\nif (ntohl(aux->format_id) != 0) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Skipping frame, format_id %u\n", name, ntohl(aux->format_id));\r\n#endif\r\ngoto err_out;\r\n}\r\nif (memcmp(aux->application_sig, STp->application_sig, 4) != 0 &&\r\n(memcmp(aux->application_sig, "LIN3", 4) != 0 || STp->linux_media_version != 4)) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Skipping frame, incorrect application signature\n", name);\r\n#endif\r\ngoto err_out;\r\n}\r\nif (par->partition_num != OS_DATA_PARTITION) {\r\nif (!STp->linux_media || STp->linux_media_version != 2) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Skipping frame, partition num %d\n",\r\nname, par->partition_num);\r\n#endif\r\ngoto err_out;\r\n}\r\n}\r\nif (par->par_desc_ver != OS_PARTITION_VERSION) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Skipping frame, partition version %d\n", name, par->par_desc_ver);\r\n#endif\r\ngoto err_out;\r\n}\r\nif (ntohs(par->wrt_pass_cntr) != STp->wrt_pass_cntr) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Skipping frame, wrt_pass_cntr %d (expected %d)\n",\r\nname, ntohs(par->wrt_pass_cntr), STp->wrt_pass_cntr);\r\n#endif\r\ngoto err_out;\r\n}\r\nif (aux->frame_type != OS_FRAME_TYPE_DATA &&\r\naux->frame_type != OS_FRAME_TYPE_EOD &&\r\naux->frame_type != OS_FRAME_TYPE_MARKER) {\r\nif (!quiet) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Skipping frame, frame type %x\n", name, aux->frame_type);\r\n#endif\r\n}\r\ngoto err_out;\r\n}\r\nif (aux->frame_type == OS_FRAME_TYPE_EOD &&\r\nSTp->first_frame_position < STp->eod_frame_ppos) {\r\nprintk(KERN_INFO "%s:I: Skipping premature EOD frame %d\n", name,\r\nSTp->first_frame_position);\r\ngoto err_out;\r\n}\r\nif (frame_seq_number != -1 && ntohl(aux->frame_seq_num) != frame_seq_number) {\r\nif (!quiet) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Skipping frame, sequence number %u (expected %d)\n",\r\nname, ntohl(aux->frame_seq_num), frame_seq_number);\r\n#endif\r\n}\r\ngoto err_out;\r\n}\r\nif (aux->frame_type == OS_FRAME_TYPE_MARKER) {\r\nSTps->eof = ST_FM_HIT;\r\ni = ntohl(aux->filemark_cnt);\r\nif (STp->header_cache != NULL && i < OS_FM_TAB_MAX && (i > STp->filemark_cnt ||\r\nSTp->first_frame_position - 1 != ntohl(STp->header_cache->dat_fm_tab.fm_tab_ent[i]))) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: %s filemark %d at frame pos %d\n", name,\r\nSTp->header_cache->dat_fm_tab.fm_tab_ent[i] == 0?"Learned":"Corrected",\r\ni, STp->first_frame_position - 1);\r\n#endif\r\nSTp->header_cache->dat_fm_tab.fm_tab_ent[i] = htonl(STp->first_frame_position - 1);\r\nif (i >= STp->filemark_cnt)\r\nSTp->filemark_cnt = i+1;\r\n}\r\n}\r\nif (aux->frame_type == OS_FRAME_TYPE_EOD) {\r\nSTps->eof = ST_EOD_1;\r\nSTp->frame_in_buffer = 1;\r\n}\r\nif (aux->frame_type == OS_FRAME_TYPE_DATA) {\r\nblk_cnt = ntohs(aux->dat.dat_list[0].blk_cnt);\r\nblk_sz = ntohl(aux->dat.dat_list[0].blk_sz);\r\nSTp->buffer->buffer_bytes = blk_cnt * blk_sz;\r\nSTp->buffer->read_pointer = 0;\r\nSTp->frame_in_buffer = 1;\r\nif (STp->block_size != blk_sz && blk_sz > 0) {\r\nprintk(KERN_INFO\r\n"%s:I: File was written with block size %d%c, currently %d%c, adjusted to match.\n",\r\nname, blk_sz<1024?blk_sz:blk_sz/1024,blk_sz<1024?'b':'k',\r\nSTp->block_size<1024?STp->block_size:STp->block_size/1024,\r\nSTp->block_size<1024?'b':'k');\r\nSTp->block_size = blk_sz;\r\nSTp->buffer->buffer_blocks = OS_DATA_SIZE / blk_sz;\r\n}\r\nSTps->eof = ST_NOEOF;\r\n}\r\nSTp->frame_seq_number = ntohl(aux->frame_seq_num);\r\nSTp->logical_blk_num = ntohl(aux->logical_blk_num);\r\nreturn 1;\r\nerr_out:\r\nif (STp->read_error_frame == 0)\r\nSTp->read_error_frame = STp->first_frame_position - 1;\r\nreturn 0;\r\n}\r\nstatic int osst_wait_ready(struct osst_tape * STp, struct osst_request ** aSRpnt,\r\nunsigned timeout, int initial_delay)\r\n{\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nstruct osst_request * SRpnt;\r\nunsigned long startwait = jiffies;\r\n#if DEBUG\r\nint dbg = debugging;\r\nchar * name = tape_name(STp);\r\nprintk(OSST_DEB_MSG "%s:D: Reached onstream wait ready\n", name);\r\n#endif\r\nif (initial_delay > 0)\r\nmsleep(jiffies_to_msecs(initial_delay));\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = TEST_UNIT_READY;\r\nSRpnt = osst_do_scsi(*aSRpnt, STp, cmd, 0, DMA_NONE, STp->timeout, MAX_RETRIES, 1);\r\n*aSRpnt = SRpnt;\r\nif (!SRpnt) return (-EBUSY);\r\nwhile ( STp->buffer->syscall_result && time_before(jiffies, startwait + timeout*HZ) &&\r\n(( SRpnt->sense[2] == 2 && SRpnt->sense[12] == 4 &&\r\n(SRpnt->sense[13] == 1 || SRpnt->sense[13] == 8) ) ||\r\n( SRpnt->sense[2] == 6 && SRpnt->sense[12] == 0x28 &&\r\nSRpnt->sense[13] == 0 ) )) {\r\n#if DEBUG\r\nif (debugging) {\r\nprintk(OSST_DEB_MSG "%s:D: Sleeping in onstream wait ready\n", name);\r\nprintk(OSST_DEB_MSG "%s:D: Turning off debugging for a while\n", name);\r\ndebugging = 0;\r\n}\r\n#endif\r\nmsleep(100);\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = TEST_UNIT_READY;\r\nSRpnt = osst_do_scsi(SRpnt, STp, cmd, 0, DMA_NONE, STp->timeout, MAX_RETRIES, 1);\r\n}\r\n*aSRpnt = SRpnt;\r\n#if DEBUG\r\ndebugging = dbg;\r\n#endif\r\nif ( STp->buffer->syscall_result &&\r\nosst_write_error_recovery(STp, aSRpnt, 0) ) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Abnormal exit from onstream wait ready\n", name);\r\nprintk(OSST_DEB_MSG "%s:D: Result = %d, Sense: 0=%02x, 2=%02x, 12=%02x, 13=%02x\n", name,\r\nSTp->buffer->syscall_result, SRpnt->sense[0], SRpnt->sense[2],\r\nSRpnt->sense[12], SRpnt->sense[13]);\r\n#endif\r\nreturn (-EIO);\r\n}\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Normal exit from onstream wait ready\n", name);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int osst_wait_for_medium(struct osst_tape * STp, struct osst_request ** aSRpnt, unsigned timeout)\r\n{\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nstruct osst_request * SRpnt;\r\nunsigned long startwait = jiffies;\r\n#if DEBUG\r\nint dbg = debugging;\r\nchar * name = tape_name(STp);\r\nprintk(OSST_DEB_MSG "%s:D: Reached onstream wait for medium\n", name);\r\n#endif\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = TEST_UNIT_READY;\r\nSRpnt = osst_do_scsi(*aSRpnt, STp, cmd, 0, DMA_NONE, STp->timeout, MAX_RETRIES, 1);\r\n*aSRpnt = SRpnt;\r\nif (!SRpnt) return (-EBUSY);\r\nwhile ( STp->buffer->syscall_result && time_before(jiffies, startwait + timeout*HZ) &&\r\nSRpnt->sense[2] == 2 && SRpnt->sense[12] == 0x3a && SRpnt->sense[13] == 0 ) {\r\n#if DEBUG\r\nif (debugging) {\r\nprintk(OSST_DEB_MSG "%s:D: Sleeping in onstream wait medium\n", name);\r\nprintk(OSST_DEB_MSG "%s:D: Turning off debugging for a while\n", name);\r\ndebugging = 0;\r\n}\r\n#endif\r\nmsleep(100);\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = TEST_UNIT_READY;\r\nSRpnt = osst_do_scsi(SRpnt, STp, cmd, 0, DMA_NONE, STp->timeout, MAX_RETRIES, 1);\r\n}\r\n*aSRpnt = SRpnt;\r\n#if DEBUG\r\ndebugging = dbg;\r\n#endif\r\nif ( STp->buffer->syscall_result && SRpnt->sense[2] != 2 &&\r\nSRpnt->sense[12] != 4 && SRpnt->sense[13] == 1) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Abnormal exit from onstream wait medium\n", name);\r\nprintk(OSST_DEB_MSG "%s:D: Result = %d, Sense: 0=%02x, 2=%02x, 12=%02x, 13=%02x\n", name,\r\nSTp->buffer->syscall_result, SRpnt->sense[0], SRpnt->sense[2],\r\nSRpnt->sense[12], SRpnt->sense[13]);\r\n#endif\r\nreturn 0;\r\n}\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Normal exit from onstream wait medium\n", name);\r\n#endif\r\nreturn 1;\r\n}\r\nstatic int osst_position_tape_and_confirm(struct osst_tape * STp, struct osst_request ** aSRpnt, int frame)\r\n{\r\nint retval;\r\nosst_wait_ready(STp, aSRpnt, 15 * 60, 0);\r\nretval = osst_set_frame_position(STp, aSRpnt, frame, 0);\r\nif (retval) return (retval);\r\nosst_wait_ready(STp, aSRpnt, 15 * 60, OSST_WAIT_POSITION_COMPLETE);\r\nreturn (osst_get_frame_position(STp, aSRpnt));\r\n}\r\nstatic int osst_flush_drive_buffer(struct osst_tape * STp, struct osst_request ** aSRpnt)\r\n{\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nstruct osst_request * SRpnt;\r\nint result = 0;\r\nint delay = OSST_WAIT_WRITE_COMPLETE;\r\n#if DEBUG\r\nchar * name = tape_name(STp);\r\nprintk(OSST_DEB_MSG "%s:D: Reached onstream flush drive buffer (write filemark)\n", name);\r\n#endif\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = WRITE_FILEMARKS;\r\ncmd[1] = 1;\r\nSRpnt = osst_do_scsi(*aSRpnt, STp, cmd, 0, DMA_NONE, STp->timeout, MAX_RETRIES, 1);\r\n*aSRpnt = SRpnt;\r\nif (!SRpnt) return (-EBUSY);\r\nif (STp->buffer->syscall_result) {\r\nif ((SRpnt->sense[2] & 0x0f) == 2 && SRpnt->sense[12] == 4) {\r\nif (SRpnt->sense[13] == 8) {\r\ndelay = OSST_WAIT_LONG_WRITE_COMPLETE;\r\n}\r\n} else\r\nresult = osst_write_error_recovery(STp, aSRpnt, 0);\r\n}\r\nresult |= osst_wait_ready(STp, aSRpnt, 5 * 60, delay);\r\nSTp->ps[STp->partition].rw = OS_WRITING_COMPLETE;\r\nreturn (result);\r\n}\r\nstatic int osst_wait_frame(struct osst_tape * STp, struct osst_request ** aSRpnt, int curr, int minlast, int to)\r\n{\r\nunsigned long startwait = jiffies;\r\nchar * name = tape_name(STp);\r\n#if DEBUG\r\nchar notyetprinted = 1;\r\n#endif\r\nif (minlast >= 0 && STp->ps[STp->partition].rw != ST_READING)\r\nprintk(KERN_ERR "%s:A: Waiting for frame without having initialized read!\n", name);\r\nwhile (time_before (jiffies, startwait + to*HZ))\r\n{\r\nint result;\r\nresult = osst_get_frame_position(STp, aSRpnt);\r\nif (result == -EIO)\r\nif ((result = osst_write_error_recovery(STp, aSRpnt, 0)) == 0)\r\nreturn 0;\r\nif (result < 0) break;\r\nif (STp->first_frame_position == curr &&\r\n((minlast < 0 &&\r\n(signed)STp->last_frame_position > (signed)curr + minlast) ||\r\n(minlast >= 0 && STp->cur_frames > minlast)\r\n) && result >= 0)\r\n{\r\n#if DEBUG\r\nif (debugging || time_after_eq(jiffies, startwait + 2*HZ/OSST_POLL_PER_SEC))\r\nprintk (OSST_DEB_MSG\r\n"%s:D: Succ wait f fr %i (>%i): %i-%i %i (%i): %3li.%li s\n",\r\nname, curr, curr+minlast, STp->first_frame_position,\r\nSTp->last_frame_position, STp->cur_frames,\r\nresult, (jiffies-startwait)/HZ,\r\n(((jiffies-startwait)%HZ)*10)/HZ);\r\n#endif\r\nreturn 0;\r\n}\r\n#if DEBUG\r\nif (time_after_eq(jiffies, startwait + 2*HZ/OSST_POLL_PER_SEC) && notyetprinted)\r\n{\r\nprintk (OSST_DEB_MSG "%s:D: Wait for frame %i (>%i): %i-%i %i (%i)\n",\r\nname, curr, curr+minlast, STp->first_frame_position,\r\nSTp->last_frame_position, STp->cur_frames, result);\r\nnotyetprinted--;\r\n}\r\n#endif\r\nmsleep(1000 / OSST_POLL_PER_SEC);\r\n}\r\n#if DEBUG\r\nprintk (OSST_DEB_MSG "%s:D: Fail wait f fr %i (>%i): %i-%i %i: %3li.%li s\n",\r\nname, curr, curr+minlast, STp->first_frame_position,\r\nSTp->last_frame_position, STp->cur_frames,\r\n(jiffies-startwait)/HZ, (((jiffies-startwait)%HZ)*10)/HZ);\r\n#endif\r\nreturn -EBUSY;\r\n}\r\nstatic int osst_recover_wait_frame(struct osst_tape * STp, struct osst_request ** aSRpnt, int writing)\r\n{\r\nstruct osst_request * SRpnt;\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nunsigned long startwait = jiffies;\r\nint retval = 1;\r\nchar * name = tape_name(STp);\r\nif (writing) {\r\nchar mybuf[24];\r\nchar * olddata = STp->buffer->b_data;\r\nint oldsize = STp->buffer->buffer_size;\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = WRITE_FILEMARKS;\r\ncmd[1] = 1;\r\nSRpnt = osst_do_scsi(*aSRpnt, STp, cmd, 0, DMA_NONE, STp->timeout,\r\nMAX_RETRIES, 1);\r\nwhile (retval && time_before (jiffies, startwait + 5*60*HZ)) {\r\nif (STp->buffer->syscall_result && (SRpnt->sense[2] & 0x0f) != 2) {\r\nretval = osst_write_error_recovery(STp, aSRpnt, 0);\r\nbreak;\r\n}\r\nschedule_timeout_interruptible(HZ / OSST_POLL_PER_SEC);\r\nSTp->buffer->b_data = mybuf; STp->buffer->buffer_size = 24;\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = READ_POSITION;\r\nSRpnt = osst_do_scsi(SRpnt, STp, cmd, 20, DMA_FROM_DEVICE, STp->timeout,\r\nMAX_RETRIES, 1);\r\nretval = ( STp->buffer->syscall_result || (STp->buffer)->b_data[15] > 25 );\r\nSTp->buffer->b_data = olddata; STp->buffer->buffer_size = oldsize;\r\n}\r\nif (retval)\r\nprintk(KERN_ERR "%s:E: Device did not succeed to write buffered data\n", name);\r\n} else\r\nif (STp->buffer->syscall_result)\r\nprintk(KERN_WARNING\r\n"%s:W: Recover_wait_frame(read) cannot handle %02x:%02x:%02x\n", name,\r\n(*aSRpnt)->sense[ 2] & 0x0f,\r\n(*aSRpnt)->sense[12],\r\n(*aSRpnt)->sense[13]);\r\nreturn retval;\r\n}\r\nstatic int osst_read_frame(struct osst_tape * STp, struct osst_request ** aSRpnt, int timeout)\r\n{\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nstruct osst_request * SRpnt;\r\nint retval = 0;\r\n#if DEBUG\r\nos_aux_t * aux = STp->buffer->aux;\r\nchar * name = tape_name(STp);\r\n#endif\r\nif (STp->poll)\r\nif (osst_wait_frame (STp, aSRpnt, STp->first_frame_position, 0, timeout))\r\nretval = osst_recover_wait_frame(STp, aSRpnt, 0);\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = READ_6;\r\ncmd[1] = 1;\r\ncmd[4] = 1;\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Reading frame from OnStream tape\n", name);\r\n#endif\r\nSRpnt = osst_do_scsi(*aSRpnt, STp, cmd, OS_FRAME_SIZE, DMA_FROM_DEVICE,\r\nSTp->timeout, MAX_RETRIES, 1);\r\n*aSRpnt = SRpnt;\r\nif (!SRpnt)\r\nreturn (-EBUSY);\r\nif ((STp->buffer)->syscall_result) {\r\nretval = 1;\r\nif (STp->read_error_frame == 0) {\r\nSTp->read_error_frame = STp->first_frame_position;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Recording read error at %d\n", name, STp->read_error_frame);\r\n#endif\r\n}\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Sense: %2x %2x %2x %2x %2x %2x %2x %2x\n",\r\nname,\r\nSRpnt->sense[0], SRpnt->sense[1],\r\nSRpnt->sense[2], SRpnt->sense[3],\r\nSRpnt->sense[4], SRpnt->sense[5],\r\nSRpnt->sense[6], SRpnt->sense[7]);\r\n#endif\r\n}\r\nelse\r\nSTp->first_frame_position++;\r\n#if DEBUG\r\nif (debugging) {\r\nchar sig[8]; int i;\r\nfor (i=0;i<4;i++)\r\nsig[i] = aux->application_sig[i]<32?'^':aux->application_sig[i];\r\nsig[4] = '\0';\r\nprintk(OSST_DEB_MSG\r\n"%s:D: AUX: %s UpdFrCt#%d Wpass#%d %s FrSeq#%d LogBlk#%d Qty=%d Sz=%d\n", name, sig,\r\nntohl(aux->update_frame_cntr), ntohs(aux->partition.wrt_pass_cntr),\r\naux->frame_type==1?"EOD":aux->frame_type==2?"MARK":\r\naux->frame_type==8?"HEADR":aux->frame_type==0x80?"DATA":"FILL",\r\nntohl(aux->frame_seq_num), ntohl(aux->logical_blk_num),\r\nntohs(aux->dat.dat_list[0].blk_cnt), ntohl(aux->dat.dat_list[0].blk_sz) );\r\nif (aux->frame_type==2)\r\nprintk(OSST_DEB_MSG "%s:D: mark_cnt=%d, last_mark_ppos=%d, last_mark_lbn=%d\n", name,\r\nntohl(aux->filemark_cnt), ntohl(aux->last_mark_ppos), ntohl(aux->last_mark_lbn));\r\nprintk(OSST_DEB_MSG "%s:D: Exit read frame from OnStream tape with code %d\n", name, retval);\r\n}\r\n#endif\r\nreturn (retval);\r\n}\r\nstatic int osst_initiate_read(struct osst_tape * STp, struct osst_request ** aSRpnt)\r\n{\r\nstruct st_partstat * STps = &(STp->ps[STp->partition]);\r\nstruct osst_request * SRpnt ;\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nint retval = 0;\r\nchar * name = tape_name(STp);\r\nif (STps->rw != ST_READING) {\r\nif (STps->rw == ST_WRITING || STp->dirty) {\r\nSTp->write_type = OS_WRITE_DATA;\r\nosst_flush_write_buffer(STp, aSRpnt);\r\nosst_flush_drive_buffer(STp, aSRpnt);\r\n}\r\nSTps->rw = ST_READING;\r\nSTp->frame_in_buffer = 0;\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = READ_6;\r\ncmd[1] = 1;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Start Read Ahead on OnStream tape\n", name);\r\n#endif\r\nSRpnt = osst_do_scsi(*aSRpnt, STp, cmd, 0, DMA_NONE, STp->timeout, MAX_RETRIES, 1);\r\n*aSRpnt = SRpnt;\r\nif ((retval = STp->buffer->syscall_result))\r\nprintk(KERN_WARNING "%s:W: Error starting read ahead\n", name);\r\n}\r\nreturn retval;\r\n}\r\nstatic int osst_get_logical_frame(struct osst_tape * STp, struct osst_request ** aSRpnt,\r\nint frame_seq_number, int quiet)\r\n{\r\nstruct st_partstat * STps = &(STp->ps[STp->partition]);\r\nchar * name = tape_name(STp);\r\nint cnt = 0,\r\nbad = 0,\r\npast = 0,\r\nx,\r\nposition;\r\nif (frame_seq_number == -1 && STp->frame_in_buffer) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Frame %d still in buffer\n", name, STp->frame_seq_number);\r\n#endif\r\nreturn (STps->eof);\r\n}\r\nwhile (1) {\r\nif (cnt++ > 400) {\r\nprintk(KERN_ERR "%s:E: Couldn't find logical frame %d, aborting\n",\r\nname, frame_seq_number);\r\nif (STp->read_error_frame) {\r\nosst_set_frame_position(STp, aSRpnt, STp->read_error_frame, 0);\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Repositioning tape to bad frame %d\n",\r\nname, STp->read_error_frame);\r\n#endif\r\nSTp->read_error_frame = 0;\r\nSTp->abort_count++;\r\n}\r\nreturn (-EIO);\r\n}\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Looking for frame %d, attempt %d\n",\r\nname, frame_seq_number, cnt);\r\n#endif\r\nif ( osst_initiate_read(STp, aSRpnt)\r\n|| ( (!STp->frame_in_buffer) && osst_read_frame(STp, aSRpnt, 30) ) ) {\r\nif (STp->raw)\r\nreturn (-EIO);\r\nposition = osst_get_frame_position(STp, aSRpnt);\r\nif (position >= 0xbae && position < 0xbb8)\r\nposition = 0xbb8;\r\nelse if (position > STp->eod_frame_ppos || ++bad == 10) {\r\nposition = STp->read_error_frame - 1;\r\nbad = 0;\r\n}\r\nelse {\r\nposition += 29;\r\ncnt += 19;\r\n}\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Bad frame detected, positioning tape to block %d\n",\r\nname, position);\r\n#endif\r\nosst_set_frame_position(STp, aSRpnt, position, 0);\r\ncontinue;\r\n}\r\nif (osst_verify_frame(STp, frame_seq_number, quiet))\r\nbreak;\r\nif (osst_verify_frame(STp, -1, quiet)) {\r\nx = ntohl(STp->buffer->aux->frame_seq_num);\r\nif (STp->fast_open) {\r\nprintk(KERN_WARNING\r\n"%s:W: Found logical frame %d instead of %d after fast open\n",\r\nname, x, frame_seq_number);\r\nSTp->header_ok = 0;\r\nSTp->read_error_frame = 0;\r\nreturn (-EIO);\r\n}\r\nif (x > frame_seq_number) {\r\nif (++past > 3) {\r\nposition = STp->read_error_frame - 1;\r\n}\r\nelse {\r\nposition = osst_get_frame_position(STp, aSRpnt)\r\n+ frame_seq_number - x - 1;\r\nif (STp->first_frame_position >= 3000 && position < 3000)\r\nposition -= 10;\r\n}\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG\r\n"%s:D: Found logical frame %d while looking for %d: back up %d\n",\r\nname, x, frame_seq_number,\r\nSTp->first_frame_position - position);\r\n#endif\r\nosst_set_frame_position(STp, aSRpnt, position, 0);\r\ncnt += 10;\r\n}\r\nelse\r\npast = 0;\r\n}\r\nif (osst_get_frame_position(STp, aSRpnt) == 0xbaf) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Skipping config partition\n", name);\r\n#endif\r\nosst_set_frame_position(STp, aSRpnt, 0xbb8, 0);\r\ncnt--;\r\n}\r\nSTp->frame_in_buffer = 0;\r\n}\r\nif (cnt > 1) {\r\nSTp->recover_count++;\r\nSTp->recover_erreg++;\r\nprintk(KERN_WARNING "%s:I: Don't worry, Read error at position %d recovered\n",\r\nname, STp->read_error_frame);\r\n}\r\nSTp->read_count++;\r\n#if DEBUG\r\nif (debugging || STps->eof)\r\nprintk(OSST_DEB_MSG\r\n"%s:D: Exit get logical frame (%d=>%d) from OnStream tape with code %d\n",\r\nname, frame_seq_number, STp->frame_seq_number, STps->eof);\r\n#endif\r\nSTp->fast_open = 0;\r\nSTp->read_error_frame = 0;\r\nreturn (STps->eof);\r\n}\r\nstatic int osst_seek_logical_blk(struct osst_tape * STp, struct osst_request ** aSRpnt, int logical_blk_num)\r\n{\r\nstruct st_partstat * STps = &(STp->ps[STp->partition]);\r\nchar * name = tape_name(STp);\r\nint retries = 0;\r\nint frame_seq_estimate, ppos_estimate, move;\r\nif (logical_blk_num < 0) logical_blk_num = 0;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Seeking logical block %d (now at %d, size %d%c)\n",\r\nname, logical_blk_num, STp->logical_blk_num,\r\nSTp->block_size<1024?STp->block_size:STp->block_size/1024,\r\nSTp->block_size<1024?'b':'k');\r\n#endif\r\nif (STps->drv_block >= 0) {\r\nmove = logical_blk_num - STp->logical_blk_num;\r\nif (move < 0) move -= (OS_DATA_SIZE / STp->block_size) - 1;\r\nmove /= (OS_DATA_SIZE / STp->block_size);\r\nframe_seq_estimate = STp->frame_seq_number + move;\r\n} else\r\nframe_seq_estimate = logical_blk_num * STp->block_size / OS_DATA_SIZE;\r\nif (frame_seq_estimate < 2980) ppos_estimate = frame_seq_estimate + 10;\r\nelse ppos_estimate = frame_seq_estimate + 20;\r\nwhile (++retries < 10) {\r\nif (ppos_estimate > STp->eod_frame_ppos-2) {\r\nframe_seq_estimate += STp->eod_frame_ppos - 2 - ppos_estimate;\r\nppos_estimate = STp->eod_frame_ppos - 2;\r\n}\r\nif (frame_seq_estimate < 0) {\r\nframe_seq_estimate = 0;\r\nppos_estimate = 10;\r\n}\r\nosst_set_frame_position(STp, aSRpnt, ppos_estimate, 0);\r\nif (osst_get_logical_frame(STp, aSRpnt, frame_seq_estimate, 1) >= 0) {\r\nif (logical_blk_num < STp->logical_blk_num ||\r\nlogical_blk_num >= STp->logical_blk_num + ntohs(STp->buffer->aux->dat.dat_list[0].blk_cnt)) {\r\nif (STps->eof == ST_FM_HIT)\r\nmove = logical_blk_num < STp->logical_blk_num? -2 : 1;\r\nelse {\r\nmove = logical_blk_num - STp->logical_blk_num;\r\nif (move < 0) move -= (OS_DATA_SIZE / STp->block_size) - 1;\r\nmove /= (OS_DATA_SIZE / STp->block_size);\r\n}\r\nif (!move) move = logical_blk_num > STp->logical_blk_num ? 1 : -1;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG\r\n"%s:D: Seek retry %d at ppos %d fsq %d (est %d) lbn %d (need %d) move %d\n",\r\nname, retries, ppos_estimate, STp->frame_seq_number, frame_seq_estimate,\r\nSTp->logical_blk_num, logical_blk_num, move);\r\n#endif\r\nframe_seq_estimate += move;\r\nppos_estimate += move;\r\ncontinue;\r\n} else {\r\nSTp->buffer->read_pointer = (logical_blk_num - STp->logical_blk_num) * STp->block_size;\r\nSTp->buffer->buffer_bytes -= STp->buffer->read_pointer;\r\nSTp->logical_blk_num = logical_blk_num;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG\r\n"%s:D: Seek success at ppos %d fsq %d in_buf %d, bytes %d, ptr %d*%d\n",\r\nname, ppos_estimate, STp->frame_seq_number, STp->frame_in_buffer,\r\nSTp->buffer->buffer_bytes, STp->buffer->read_pointer / STp->block_size,\r\nSTp->block_size);\r\n#endif\r\nSTps->drv_file = ntohl(STp->buffer->aux->filemark_cnt);\r\nif (STps->eof == ST_FM_HIT) {\r\nSTps->drv_file++;\r\nSTps->drv_block = 0;\r\n} else {\r\nSTps->drv_block = ntohl(STp->buffer->aux->last_mark_lbn)?\r\nSTp->logical_blk_num -\r\n(STps->drv_file ? ntohl(STp->buffer->aux->last_mark_lbn) + 1 : 0):\r\n-1;\r\n}\r\nSTps->eof = (STp->first_frame_position >= STp->eod_frame_ppos)?ST_EOD:ST_NOEOF;\r\nreturn 0;\r\n}\r\n}\r\nif (osst_get_logical_frame(STp, aSRpnt, -1, 1) < 0)\r\ngoto error;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Seek retry %d at ppos %d fsq %d (est %d) lbn %d (need %d)\n",\r\nname, retries, ppos_estimate, STp->frame_seq_number, frame_seq_estimate,\r\nSTp->logical_blk_num, logical_blk_num);\r\n#endif\r\nif (frame_seq_estimate != STp->frame_seq_number)\r\nppos_estimate += frame_seq_estimate - STp->frame_seq_number;\r\nelse\r\nbreak;\r\n}\r\nerror:\r\nprintk(KERN_ERR "%s:E: Couldn't seek to logical block %d (at %d), %d retries\n",\r\nname, logical_blk_num, STp->logical_blk_num, retries);\r\nreturn (-EIO);\r\n}\r\nstatic int osst_get_sector(struct osst_tape * STp, struct osst_request ** aSRpnt)\r\n{\r\nint sector;\r\n#if DEBUG\r\nchar * name = tape_name(STp);\r\nprintk(OSST_DEB_MSG\r\n"%s:D: Positioned at ppos %d, frame %d, lbn %d, file %d, blk %d, %cptr %d, eof %d\n",\r\nname, STp->first_frame_position, STp->frame_seq_number, STp->logical_blk_num,\r\nSTp->ps[STp->partition].drv_file, STp->ps[STp->partition].drv_block,\r\nSTp->ps[STp->partition].rw == ST_WRITING?'w':'r',\r\nSTp->ps[STp->partition].rw == ST_WRITING?STp->buffer->buffer_bytes:\r\nSTp->buffer->read_pointer, STp->ps[STp->partition].eof);\r\n#endif\r\nif (STp->ps[STp->partition].drv_block >= 0) {\r\nsector = (STp->frame_in_buffer ? STp->first_frame_position-1 :\r\nSTp->first_frame_position) << OSST_FRAME_SHIFT;\r\nif (STp->ps[STp->partition].rw == ST_WRITING)\r\nsector |= (STp->buffer->buffer_bytes >> OSST_SECTOR_SHIFT) & OSST_SECTOR_MASK;\r\nelse\r\nsector |= (STp->buffer->read_pointer >> OSST_SECTOR_SHIFT) & OSST_SECTOR_MASK;\r\n} else {\r\nsector = osst_get_frame_position(STp, aSRpnt);\r\nif (sector > 0)\r\nsector <<= OSST_FRAME_SHIFT;\r\n}\r\nreturn sector;\r\n}\r\nstatic int osst_seek_sector(struct osst_tape * STp, struct osst_request ** aSRpnt, int sector)\r\n{\r\nstruct st_partstat * STps = &(STp->ps[STp->partition]);\r\nint frame = sector >> OSST_FRAME_SHIFT,\r\noffset = (sector & OSST_SECTOR_MASK) << OSST_SECTOR_SHIFT,\r\nr;\r\n#if DEBUG\r\nchar * name = tape_name(STp);\r\nprintk(OSST_DEB_MSG "%s:D: Seeking sector %d in frame %d at offset %d\n",\r\nname, sector, frame, offset);\r\n#endif\r\nif (frame < 0 || frame >= STp->capacity) return (-ENXIO);\r\nif (frame <= STp->first_data_ppos) {\r\nSTp->frame_seq_number = STp->logical_blk_num = STps->drv_file = STps->drv_block = 0;\r\nreturn (osst_set_frame_position(STp, aSRpnt, frame, 0));\r\n}\r\nr = osst_set_frame_position(STp, aSRpnt, offset?frame:frame-1, 0);\r\nif (r < 0) return r;\r\nr = osst_get_logical_frame(STp, aSRpnt, -1, 1);\r\nif (r < 0) return r;\r\nif (osst_get_frame_position(STp, aSRpnt) != (offset?frame+1:frame)) return (-EIO);\r\nif (offset) {\r\nSTp->logical_blk_num += offset / STp->block_size;\r\nSTp->buffer->read_pointer = offset;\r\nSTp->buffer->buffer_bytes -= offset;\r\n} else {\r\nSTp->frame_seq_number++;\r\nSTp->frame_in_buffer = 0;\r\nSTp->logical_blk_num += ntohs(STp->buffer->aux->dat.dat_list[0].blk_cnt);\r\nSTp->buffer->buffer_bytes = STp->buffer->read_pointer = 0;\r\n}\r\nSTps->drv_file = ntohl(STp->buffer->aux->filemark_cnt);\r\nif (STps->eof == ST_FM_HIT) {\r\nSTps->drv_file++;\r\nSTps->drv_block = 0;\r\n} else {\r\nSTps->drv_block = ntohl(STp->buffer->aux->last_mark_lbn)?\r\nSTp->logical_blk_num -\r\n(STps->drv_file ? ntohl(STp->buffer->aux->last_mark_lbn) + 1 : 0):\r\n-1;\r\n}\r\nSTps->eof = (STp->first_frame_position >= STp->eod_frame_ppos)?ST_EOD:ST_NOEOF;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG\r\n"%s:D: Now positioned at ppos %d, frame %d, lbn %d, file %d, blk %d, rptr %d, eof %d\n",\r\nname, STp->first_frame_position, STp->frame_seq_number, STp->logical_blk_num,\r\nSTps->drv_file, STps->drv_block, STp->buffer->read_pointer, STps->eof);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int osst_read_back_buffer_and_rewrite(struct osst_tape * STp, struct osst_request ** aSRpnt,\r\nunsigned int frame, unsigned int skip, int pending)\r\n{\r\nstruct osst_request * SRpnt = * aSRpnt;\r\nunsigned char * buffer, * p;\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nint flag, new_frame, i;\r\nint nframes = STp->cur_frames;\r\nint blks_per_frame = ntohs(STp->buffer->aux->dat.dat_list[0].blk_cnt);\r\nint frame_seq_number = ntohl(STp->buffer->aux->frame_seq_num)\r\n- (nframes + pending - 1);\r\nint logical_blk_num = ntohl(STp->buffer->aux->logical_blk_num)\r\n- (nframes + pending - 1) * blks_per_frame;\r\nchar * name = tape_name(STp);\r\nunsigned long startwait = jiffies;\r\n#if DEBUG\r\nint dbg = debugging;\r\n#endif\r\nif ((buffer = vmalloc((nframes + 1) * OS_DATA_SIZE)) == NULL)\r\nreturn (-EIO);\r\nprintk(KERN_INFO "%s:I: Reading back %d frames from drive buffer%s\n",\r\nname, nframes, pending?" and one that was pending":"");\r\nosst_copy_from_buffer(STp->buffer, (p = &buffer[nframes * OS_DATA_SIZE]));\r\n#if DEBUG\r\nif (pending && debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Pending frame %d (lblk %d), data %02x %02x %02x %02x\n",\r\nname, frame_seq_number + nframes,\r\nlogical_blk_num + nframes * blks_per_frame,\r\np[0], p[1], p[2], p[3]);\r\n#endif\r\nfor (i = 0, p = buffer; i < nframes; i++, p += OS_DATA_SIZE) {\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = 0x3C;\r\ncmd[1] = 6;\r\ncmd[7] = 32768 >> 8;\r\ncmd[8] = 32768 & 0xff;\r\nSRpnt = osst_do_scsi(SRpnt, STp, cmd, OS_FRAME_SIZE, DMA_FROM_DEVICE,\r\nSTp->timeout, MAX_RETRIES, 1);\r\nif ((STp->buffer)->syscall_result || !SRpnt) {\r\nprintk(KERN_ERR "%s:E: Failed to read frame back from OnStream buffer\n", name);\r\nvfree(buffer);\r\n*aSRpnt = SRpnt;\r\nreturn (-EIO);\r\n}\r\nosst_copy_from_buffer(STp->buffer, p);\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Read back logical frame %d, data %02x %02x %02x %02x\n",\r\nname, frame_seq_number + i, p[0], p[1], p[2], p[3]);\r\n#endif\r\n}\r\n*aSRpnt = SRpnt;\r\nosst_get_frame_position(STp, aSRpnt);\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Frames left in buffer: %d\n", name, STp->cur_frames);\r\n#endif\r\nfor (flag=1, new_frame=frame, p=buffer, i=0; i < nframes + pending; ) {\r\nif (flag) {\r\nif (STp->write_type == OS_WRITE_HEADER) {\r\ni += skip;\r\np += skip * OS_DATA_SIZE;\r\n}\r\nelse if (new_frame < 2990 && new_frame+skip+nframes+pending >= 2990)\r\nnew_frame = 3000-i;\r\nelse\r\nnew_frame += skip;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Position to frame %d, write fseq %d\n",\r\nname, new_frame+i, frame_seq_number+i);\r\n#endif\r\nosst_set_frame_position(STp, aSRpnt, new_frame + i, 0);\r\nosst_wait_ready(STp, aSRpnt, 60, OSST_WAIT_POSITION_COMPLETE);\r\nosst_get_frame_position(STp, aSRpnt);\r\nSRpnt = * aSRpnt;\r\nif (new_frame > frame + 1000) {\r\nprintk(KERN_ERR "%s:E: Failed to find writable tape media\n", name);\r\nvfree(buffer);\r\nreturn (-EIO);\r\n}\r\nif ( i >= nframes + pending ) break;\r\nflag = 0;\r\n}\r\nosst_copy_to_buffer(STp->buffer, p);\r\nosst_init_aux(STp, STp->buffer->aux->frame_type, frame_seq_number+i,\r\nlogical_blk_num + i*blks_per_frame,\r\nntohl(STp->buffer->aux->dat.dat_list[0].blk_sz), blks_per_frame);\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = WRITE_6;\r\ncmd[1] = 1;\r\ncmd[4] = 1;\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG\r\n"%s:D: About to write frame %d, seq %d, lbn %d, data %02x %02x %02x %02x\n",\r\nname, new_frame+i, frame_seq_number+i, logical_blk_num + i*blks_per_frame,\r\np[0], p[1], p[2], p[3]);\r\n#endif\r\nSRpnt = osst_do_scsi(SRpnt, STp, cmd, OS_FRAME_SIZE, DMA_TO_DEVICE,\r\nSTp->timeout, MAX_RETRIES, 1);\r\nif (STp->buffer->syscall_result)\r\nflag = 1;\r\nelse {\r\np += OS_DATA_SIZE; i++;\r\nif ( i == nframes + pending ) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Check re-write successful\n", name);\r\n#endif\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = WRITE_FILEMARKS;\r\ncmd[1] = 1;\r\nSRpnt = osst_do_scsi(SRpnt, STp, cmd, 0, DMA_NONE,\r\nSTp->timeout, MAX_RETRIES, 1);\r\n#if DEBUG\r\nif (debugging) {\r\nprintk(OSST_DEB_MSG "%s:D: Sleeping in re-write wait ready\n", name);\r\nprintk(OSST_DEB_MSG "%s:D: Turning off debugging for a while\n", name);\r\ndebugging = 0;\r\n}\r\n#endif\r\nflag = STp->buffer->syscall_result;\r\nwhile ( !flag && time_before(jiffies, startwait + 60*HZ) ) {\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = TEST_UNIT_READY;\r\nSRpnt = osst_do_scsi(SRpnt, STp, cmd, 0, DMA_NONE, STp->timeout,\r\nMAX_RETRIES, 1);\r\nif (SRpnt->sense[2] == 2 && SRpnt->sense[12] == 4 &&\r\n(SRpnt->sense[13] == 1 || SRpnt->sense[13] == 8)) {\r\nmsleep(100);\r\ncontinue;\r\n}\r\nif (STp->buffer->syscall_result)\r\nflag = 1;\r\nbreak;\r\n}\r\n#if DEBUG\r\ndebugging = dbg;\r\nprintk(OSST_DEB_MSG "%s:D: Wait re-write finished\n", name);\r\n#endif\r\n}\r\n}\r\n*aSRpnt = SRpnt;\r\nif (flag) {\r\nif ((SRpnt->sense[ 2] & 0x0f) == 13 &&\r\nSRpnt->sense[12] == 0 &&\r\nSRpnt->sense[13] == 2) {\r\nprintk(KERN_ERR "%s:E: Volume overflow in write error recovery\n", name);\r\nvfree(buffer);\r\nreturn (-EIO);\r\n}\r\ni = ((SRpnt->sense[3] << 24) |\r\n(SRpnt->sense[4] << 16) |\r\n(SRpnt->sense[5] << 8) |\r\nSRpnt->sense[6] ) - new_frame;\r\np = &buffer[i * OS_DATA_SIZE];\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Additional write error at %d\n", name, new_frame+i);\r\n#endif\r\nosst_get_frame_position(STp, aSRpnt);\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: reported frame positions: host = %d, tape = %d, buffer = %d\n",\r\nname, STp->first_frame_position, STp->last_frame_position, STp->cur_frames);\r\n#endif\r\n}\r\n}\r\nif (flag) {\r\nprintk(KERN_ERR "%s:D: Write error recovery failed in %s\n", name,\r\nSTp->write_type == OS_WRITE_HEADER?"header":"body");\r\n}\r\nif (!pending)\r\nosst_copy_to_buffer(STp->buffer, p);\r\nvfree(buffer);\r\nreturn 0;\r\n}\r\nstatic int osst_reposition_and_retry(struct osst_tape * STp, struct osst_request ** aSRpnt,\r\nunsigned int frame, unsigned int skip, int pending)\r\n{\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nstruct osst_request * SRpnt;\r\nchar * name = tape_name(STp);\r\nint expected = 0;\r\nint attempts = 1000 / skip;\r\nint flag = 1;\r\nunsigned long startwait = jiffies;\r\n#if DEBUG\r\nint dbg = debugging;\r\n#endif\r\nwhile (attempts && time_before(jiffies, startwait + 60*HZ)) {\r\nif (flag) {\r\n#if DEBUG\r\ndebugging = dbg;\r\n#endif\r\nif (frame < 2990 && frame+skip+STp->cur_frames+pending >= 2990)\r\nframe = 3000-skip;\r\nexpected = frame+skip+STp->cur_frames+pending;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Position to fppos %d, re-write from fseq %d\n",\r\nname, frame+skip, STp->frame_seq_number-STp->cur_frames-pending);\r\n#endif\r\nosst_set_frame_position(STp, aSRpnt, frame + skip, 1);\r\nflag = 0;\r\nattempts--;\r\nschedule_timeout_interruptible(msecs_to_jiffies(100));\r\n}\r\nif (osst_get_frame_position(STp, aSRpnt) < 0) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Addl error, host %d, tape %d, buffer %d\n",\r\nname, STp->first_frame_position,\r\nSTp->last_frame_position, STp->cur_frames);\r\n#endif\r\nframe = STp->last_frame_position;\r\nflag = 1;\r\ncontinue;\r\n}\r\nif (pending && STp->cur_frames < 50) {\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = WRITE_6;\r\ncmd[1] = 1;\r\ncmd[4] = 1;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: About to write pending fseq %d at fppos %d\n",\r\nname, STp->frame_seq_number-1, STp->first_frame_position);\r\n#endif\r\nSRpnt = osst_do_scsi(*aSRpnt, STp, cmd, OS_FRAME_SIZE, DMA_TO_DEVICE,\r\nSTp->timeout, MAX_RETRIES, 1);\r\n*aSRpnt = SRpnt;\r\nif (STp->buffer->syscall_result) {\r\nif ((SRpnt->sense[ 2] & 0x0f) == 13 &&\r\nSRpnt->sense[12] == 0 &&\r\nSRpnt->sense[13] == 2) {\r\nprintk(KERN_ERR\r\n"%s:E: Volume overflow in write error recovery\n",\r\nname);\r\nbreak;\r\n}\r\nflag = 1;\r\n}\r\nelse\r\npending = 0;\r\ncontinue;\r\n}\r\nif (STp->cur_frames == 0) {\r\n#if DEBUG\r\ndebugging = dbg;\r\nprintk(OSST_DEB_MSG "%s:D: Wait re-write finished\n", name);\r\n#endif\r\nif (STp->first_frame_position != expected) {\r\nprintk(KERN_ERR "%s:A: Actual position %d - expected %d\n",\r\nname, STp->first_frame_position, expected);\r\nreturn (-EIO);\r\n}\r\nreturn 0;\r\n}\r\n#if DEBUG\r\nif (debugging) {\r\nprintk(OSST_DEB_MSG "%s:D: Sleeping in re-write wait ready\n", name);\r\nprintk(OSST_DEB_MSG "%s:D: Turning off debugging for a while\n", name);\r\ndebugging = 0;\r\n}\r\n#endif\r\nschedule_timeout_interruptible(msecs_to_jiffies(100));\r\n}\r\nprintk(KERN_ERR "%s:E: Failed to find valid tape media\n", name);\r\n#if DEBUG\r\ndebugging = dbg;\r\n#endif\r\nreturn (-EIO);\r\n}\r\nstatic int osst_write_error_recovery(struct osst_tape * STp, struct osst_request ** aSRpnt, int pending)\r\n{\r\nstruct osst_request * SRpnt = * aSRpnt;\r\nstruct st_partstat * STps = & STp->ps[STp->partition];\r\nchar * name = tape_name(STp);\r\nint retval = 0;\r\nint rw_state;\r\nunsigned int frame, skip;\r\nrw_state = STps->rw;\r\nif ((SRpnt->sense[ 2] & 0x0f) != 3\r\n|| SRpnt->sense[12] != 12\r\n|| SRpnt->sense[13] != 0) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Write error recovery cannot handle %02x:%02x:%02x\n", name,\r\nSRpnt->sense[2], SRpnt->sense[12], SRpnt->sense[13]);\r\n#endif\r\nreturn (-EIO);\r\n}\r\nframe = (SRpnt->sense[3] << 24) |\r\n(SRpnt->sense[4] << 16) |\r\n(SRpnt->sense[5] << 8) |\r\nSRpnt->sense[6];\r\nskip = SRpnt->sense[9];\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Detected physical bad frame at %u, advised to skip %d\n", name, frame, skip);\r\n#endif\r\nosst_get_frame_position(STp, aSRpnt);\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: reported frame positions: host = %d, tape = %d\n",\r\nname, STp->first_frame_position, STp->last_frame_position);\r\n#endif\r\nswitch (STp->write_type) {\r\ncase OS_WRITE_DATA:\r\ncase OS_WRITE_EOD:\r\ncase OS_WRITE_NEW_MARK:\r\nprintk(KERN_WARNING\r\n"%s:I: Relocating %d buffered logical frames from position %u to %u\n",\r\nname, STp->cur_frames, frame, (frame + skip > 3000 && frame < 3000)?3000:frame + skip);\r\nif (STp->os_fw_rev >= 10600)\r\nretval = osst_reposition_and_retry(STp, aSRpnt, frame, skip, pending);\r\nelse\r\nretval = osst_read_back_buffer_and_rewrite(STp, aSRpnt, frame, skip, pending);\r\nprintk(KERN_WARNING "%s:%s: %sWrite error%srecovered\n", name,\r\nretval?"E" :"I",\r\nretval?"" :"Don't worry, ",\r\nretval?" not ":" ");\r\nbreak;\r\ncase OS_WRITE_LAST_MARK:\r\nprintk(KERN_ERR "%s:E: Bad frame in update last marker, fatal\n", name);\r\nosst_set_frame_position(STp, aSRpnt, frame + STp->cur_frames + pending, 0);\r\nretval = -EIO;\r\nbreak;\r\ncase OS_WRITE_HEADER:\r\nprintk(KERN_WARNING "%s:I: Bad frame in header partition, skipped\n", name);\r\nretval = osst_read_back_buffer_and_rewrite(STp, aSRpnt, frame, 1, pending);\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "%s:I: Bad frame in filler, ignored\n", name);\r\nosst_set_frame_position(STp, aSRpnt, frame + STp->cur_frames + pending, 0);\r\n}\r\nosst_get_frame_position(STp, aSRpnt);\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Positioning complete, cur_frames %d, pos %d, tape pos %d\n",\r\nname, STp->cur_frames, STp->first_frame_position, STp->last_frame_position);\r\nprintk(OSST_DEB_MSG "%s:D: next logical frame to write: %d\n", name, STp->logical_blk_num);\r\n#endif\r\nif (retval == 0) {\r\nSTp->recover_count++;\r\nSTp->recover_erreg++;\r\n} else\r\nSTp->abort_count++;\r\nSTps->rw = rw_state;\r\nreturn retval;\r\n}\r\nstatic int osst_space_over_filemarks_backward(struct osst_tape * STp, struct osst_request ** aSRpnt,\r\nint mt_op, int mt_count)\r\n{\r\nchar * name = tape_name(STp);\r\nint cnt;\r\nint last_mark_ppos = -1;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Reached space_over_filemarks_backwards %d %d\n", name, mt_op, mt_count);\r\n#endif\r\nif (osst_get_logical_frame(STp, aSRpnt, -1, 0) < 0) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Couldn't get logical blk num in space_filemarks_bwd\n", name);\r\n#endif\r\nreturn -EIO;\r\n}\r\nif (STp->linux_media_version >= 4) {\r\ncnt = ntohl(STp->buffer->aux->filemark_cnt);\r\nif (STp->header_ok &&\r\nSTp->header_cache != NULL &&\r\n(cnt - mt_count) >= 0 &&\r\n(cnt - mt_count) < OS_FM_TAB_MAX &&\r\n(cnt - mt_count) < STp->filemark_cnt &&\r\nSTp->header_cache->dat_fm_tab.fm_tab_ent[cnt-1] == STp->buffer->aux->last_mark_ppos)\r\nlast_mark_ppos = ntohl(STp->header_cache->dat_fm_tab.fm_tab_ent[cnt - mt_count]);\r\n#if DEBUG\r\nif (STp->header_cache == NULL || (cnt - mt_count) < 0 || (cnt - mt_count) >= OS_FM_TAB_MAX)\r\nprintk(OSST_DEB_MSG "%s:D: Filemark lookup fail due to %s\n", name,\r\nSTp->header_cache == NULL?"lack of header cache":"count out of range");\r\nelse\r\nprintk(OSST_DEB_MSG "%s:D: Filemark lookup: prev mark %d (%s), skip %d to %d\n",\r\nname, cnt,\r\n((cnt == -1 && ntohl(STp->buffer->aux->last_mark_ppos) == -1) ||\r\n(STp->header_cache->dat_fm_tab.fm_tab_ent[cnt-1] ==\r\nSTp->buffer->aux->last_mark_ppos))?"match":"error",\r\nmt_count, last_mark_ppos);\r\n#endif\r\nif (last_mark_ppos > 10 && last_mark_ppos < STp->eod_frame_ppos) {\r\nosst_position_tape_and_confirm(STp, aSRpnt, last_mark_ppos);\r\nif (osst_get_logical_frame(STp, aSRpnt, -1, 0) < 0) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG\r\n"%s:D: Couldn't get logical blk num in space_filemarks\n", name);\r\n#endif\r\nreturn (-EIO);\r\n}\r\nif (STp->buffer->aux->frame_type != OS_FRAME_TYPE_MARKER) {\r\nprintk(KERN_WARNING "%s:W: Expected to find marker at ppos %d, not found\n",\r\nname, last_mark_ppos);\r\nreturn (-EIO);\r\n}\r\ngoto found;\r\n}\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Reverting to scan filemark backwards\n", name);\r\n#endif\r\n}\r\ncnt = 0;\r\nwhile (cnt != mt_count) {\r\nlast_mark_ppos = ntohl(STp->buffer->aux->last_mark_ppos);\r\nif (last_mark_ppos == -1)\r\nreturn (-EIO);\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Positioning to last mark at %d\n", name, last_mark_ppos);\r\n#endif\r\nosst_position_tape_and_confirm(STp, aSRpnt, last_mark_ppos);\r\ncnt++;\r\nif (osst_get_logical_frame(STp, aSRpnt, -1, 0) < 0) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Couldn't get logical blk num in space_filemarks\n", name);\r\n#endif\r\nreturn (-EIO);\r\n}\r\nif (STp->buffer->aux->frame_type != OS_FRAME_TYPE_MARKER) {\r\nprintk(KERN_WARNING "%s:W: Expected to find marker at ppos %d, not found\n",\r\nname, last_mark_ppos);\r\nreturn (-EIO);\r\n}\r\n}\r\nfound:\r\nif (mt_op == MTBSFM) {\r\nSTp->frame_seq_number++;\r\nSTp->frame_in_buffer = 0;\r\nSTp->buffer->buffer_bytes = 0;\r\nSTp->buffer->read_pointer = 0;\r\nSTp->logical_blk_num += ntohs(STp->buffer->aux->dat.dat_list[0].blk_cnt);\r\n}\r\nreturn 0;\r\n}\r\nstatic int osst_space_over_filemarks_forward_slow(struct osst_tape * STp, struct osst_request ** aSRpnt,\r\nint mt_op, int mt_count)\r\n{\r\nint cnt = 0;\r\n#if DEBUG\r\nchar * name = tape_name(STp);\r\nprintk(OSST_DEB_MSG "%s:D: Reached space_over_filemarks_forward_slow %d %d\n", name, mt_op, mt_count);\r\n#endif\r\nif (osst_get_logical_frame(STp, aSRpnt, -1, 0) < 0) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Couldn't get logical blk num in space_filemarks_fwd\n", name);\r\n#endif\r\nreturn (-EIO);\r\n}\r\nwhile (1) {\r\nif (osst_get_logical_frame(STp, aSRpnt, -1, 0) < 0) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Couldn't get logical blk num in space_filemarks\n", name);\r\n#endif\r\nreturn (-EIO);\r\n}\r\nif (STp->buffer->aux->frame_type == OS_FRAME_TYPE_MARKER)\r\ncnt++;\r\nif (STp->buffer->aux->frame_type == OS_FRAME_TYPE_EOD) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: space_fwd: EOD reached\n", name);\r\n#endif\r\nif (STp->first_frame_position > STp->eod_frame_ppos+1) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: EOD position corrected (%d=>%d)\n",\r\nname, STp->eod_frame_ppos, STp->first_frame_position-1);\r\n#endif\r\nSTp->eod_frame_ppos = STp->first_frame_position-1;\r\n}\r\nreturn (-EIO);\r\n}\r\nif (cnt == mt_count)\r\nbreak;\r\nSTp->frame_in_buffer = 0;\r\n}\r\nif (mt_op == MTFSF) {\r\nSTp->frame_seq_number++;\r\nSTp->frame_in_buffer = 0;\r\nSTp->buffer->buffer_bytes = 0;\r\nSTp->buffer->read_pointer = 0;\r\nSTp->logical_blk_num += ntohs(STp->buffer->aux->dat.dat_list[0].blk_cnt);\r\n}\r\nreturn 0;\r\n}\r\nstatic int osst_space_over_filemarks_forward_fast(struct osst_tape * STp, struct osst_request ** aSRpnt,\r\nint mt_op, int mt_count)\r\n{\r\nchar * name = tape_name(STp);\r\nint cnt = 0,\r\nnext_mark_ppos = -1;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Reached space_over_filemarks_forward_fast %d %d\n", name, mt_op, mt_count);\r\n#endif\r\nif (osst_get_logical_frame(STp, aSRpnt, -1, 0) < 0) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Couldn't get logical blk num in space_filemarks_fwd\n", name);\r\n#endif\r\nreturn (-EIO);\r\n}\r\nif (STp->linux_media_version >= 4) {\r\ncnt = ntohl(STp->buffer->aux->filemark_cnt) - 1;\r\nif (STp->header_ok &&\r\nSTp->header_cache != NULL &&\r\n(cnt + mt_count) < OS_FM_TAB_MAX &&\r\n(cnt + mt_count) < STp->filemark_cnt &&\r\n((cnt == -1 && ntohl(STp->buffer->aux->last_mark_ppos) == -1) ||\r\n(STp->header_cache->dat_fm_tab.fm_tab_ent[cnt] == STp->buffer->aux->last_mark_ppos)))\r\nnext_mark_ppos = ntohl(STp->header_cache->dat_fm_tab.fm_tab_ent[cnt + mt_count]);\r\n#if DEBUG\r\nif (STp->header_cache == NULL || (cnt + mt_count) >= OS_FM_TAB_MAX)\r\nprintk(OSST_DEB_MSG "%s:D: Filemark lookup fail due to %s\n", name,\r\nSTp->header_cache == NULL?"lack of header cache":"count out of range");\r\nelse\r\nprintk(OSST_DEB_MSG "%s:D: Filemark lookup: prev mark %d (%s), skip %d to %d\n",\r\nname, cnt,\r\n((cnt == -1 && ntohl(STp->buffer->aux->last_mark_ppos) == -1) ||\r\n(STp->header_cache->dat_fm_tab.fm_tab_ent[cnt] ==\r\nSTp->buffer->aux->last_mark_ppos))?"match":"error",\r\nmt_count, next_mark_ppos);\r\n#endif\r\nif (next_mark_ppos <= 10 || next_mark_ppos > STp->eod_frame_ppos) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Reverting to slow filemark space\n", name);\r\n#endif\r\nreturn osst_space_over_filemarks_forward_slow(STp, aSRpnt, mt_op, mt_count);\r\n} else {\r\nosst_position_tape_and_confirm(STp, aSRpnt, next_mark_ppos);\r\nif (osst_get_logical_frame(STp, aSRpnt, -1, 0) < 0) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Couldn't get logical blk num in space_filemarks\n",\r\nname);\r\n#endif\r\nreturn (-EIO);\r\n}\r\nif (STp->buffer->aux->frame_type != OS_FRAME_TYPE_MARKER) {\r\nprintk(KERN_WARNING "%s:W: Expected to find marker at ppos %d, not found\n",\r\nname, next_mark_ppos);\r\nreturn (-EIO);\r\n}\r\nif (ntohl(STp->buffer->aux->filemark_cnt) != cnt + mt_count) {\r\nprintk(KERN_WARNING "%s:W: Expected to find marker %d at ppos %d, not %d\n",\r\nname, cnt+mt_count, next_mark_ppos,\r\nntohl(STp->buffer->aux->filemark_cnt));\r\nreturn (-EIO);\r\n}\r\n}\r\n} else {\r\nwhile (1) {\r\nif (STp->buffer->aux->frame_type == OS_FRAME_TYPE_MARKER)\r\nbreak;\r\nif (STp->buffer->aux->frame_type == OS_FRAME_TYPE_EOD) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: space_fwd: EOD reached\n", name);\r\n#endif\r\nreturn (-EIO);\r\n}\r\nif (ntohl(STp->buffer->aux->filemark_cnt) == 0) {\r\nif (STp->first_mark_ppos == -1) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Reverting to slow filemark space\n", name);\r\n#endif\r\nreturn osst_space_over_filemarks_forward_slow(STp, aSRpnt, mt_op, mt_count);\r\n}\r\nosst_position_tape_and_confirm(STp, aSRpnt, STp->first_mark_ppos);\r\nif (osst_get_logical_frame(STp, aSRpnt, -1, 0) < 0) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG\r\n"%s:D: Couldn't get logical blk num in space_filemarks_fwd_fast\n",\r\nname);\r\n#endif\r\nreturn (-EIO);\r\n}\r\nif (STp->buffer->aux->frame_type != OS_FRAME_TYPE_MARKER) {\r\nprintk(KERN_WARNING "%s:W: Expected to find filemark at %d\n",\r\nname, STp->first_mark_ppos);\r\nreturn (-EIO);\r\n}\r\n} else {\r\nif (osst_space_over_filemarks_backward(STp, aSRpnt, MTBSF, 1) < 0)\r\nreturn (-EIO);\r\nmt_count++;\r\n}\r\n}\r\ncnt++;\r\nwhile (cnt != mt_count) {\r\nnext_mark_ppos = ntohl(STp->buffer->aux->next_mark_ppos);\r\nif (!next_mark_ppos || next_mark_ppos > STp->eod_frame_ppos) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Reverting to slow filemark space\n", name);\r\n#endif\r\nreturn osst_space_over_filemarks_forward_slow(STp, aSRpnt, mt_op, mt_count - cnt);\r\n}\r\n#if DEBUG\r\nelse printk(OSST_DEB_MSG "%s:D: Positioning to next mark at %d\n", name, next_mark_ppos);\r\n#endif\r\nosst_position_tape_and_confirm(STp, aSRpnt, next_mark_ppos);\r\ncnt++;\r\nif (osst_get_logical_frame(STp, aSRpnt, -1, 0) < 0) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Couldn't get logical blk num in space_filemarks\n",\r\nname);\r\n#endif\r\nreturn (-EIO);\r\n}\r\nif (STp->buffer->aux->frame_type != OS_FRAME_TYPE_MARKER) {\r\nprintk(KERN_WARNING "%s:W: Expected to find marker at ppos %d, not found\n",\r\nname, next_mark_ppos);\r\nreturn (-EIO);\r\n}\r\n}\r\n}\r\nif (mt_op == MTFSF) {\r\nSTp->frame_seq_number++;\r\nSTp->frame_in_buffer = 0;\r\nSTp->buffer->buffer_bytes = 0;\r\nSTp->buffer->read_pointer = 0;\r\nSTp->logical_blk_num += ntohs(STp->buffer->aux->dat.dat_list[0].blk_cnt);\r\n}\r\nreturn 0;\r\n}\r\nstatic void osst_set_retries(struct osst_tape * STp, struct osst_request ** aSRpnt, int retries)\r\n{\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nstruct osst_request * SRpnt = * aSRpnt;\r\nchar * name = tape_name(STp);\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = MODE_SELECT;\r\ncmd[1] = 0x10;\r\ncmd[4] = NUMBER_RETRIES_PAGE_LENGTH + MODE_HEADER_LENGTH;\r\n(STp->buffer)->b_data[0] = cmd[4] - 1;\r\n(STp->buffer)->b_data[1] = 0;\r\n(STp->buffer)->b_data[2] = 0;\r\n(STp->buffer)->b_data[3] = 0;\r\n(STp->buffer)->b_data[MODE_HEADER_LENGTH + 0] = NUMBER_RETRIES_PAGE | (1 << 7);\r\n(STp->buffer)->b_data[MODE_HEADER_LENGTH + 1] = 2;\r\n(STp->buffer)->b_data[MODE_HEADER_LENGTH + 2] = 4;\r\n(STp->buffer)->b_data[MODE_HEADER_LENGTH + 3] = retries;\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Setting number of retries on OnStream tape to %d\n", name, retries);\r\nSRpnt = osst_do_scsi(SRpnt, STp, cmd, cmd[4], DMA_TO_DEVICE, STp->timeout, 0, 1);\r\n*aSRpnt = SRpnt;\r\nif ((STp->buffer)->syscall_result)\r\nprintk (KERN_ERR "%s:D: Couldn't set retries to %d\n", name, retries);\r\n}\r\nstatic int osst_write_filemark(struct osst_tape * STp, struct osst_request ** aSRpnt)\r\n{\r\nint result;\r\nint this_mark_ppos = STp->first_frame_position;\r\nint this_mark_lbn = STp->logical_blk_num;\r\n#if DEBUG\r\nchar * name = tape_name(STp);\r\n#endif\r\nif (STp->raw) return 0;\r\nSTp->write_type = OS_WRITE_NEW_MARK;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Writing Filemark %i at fppos %d (fseq %d, lblk %d)\n",\r\nname, STp->filemark_cnt, this_mark_ppos, STp->frame_seq_number, this_mark_lbn);\r\n#endif\r\nSTp->dirty = 1;\r\nresult = osst_flush_write_buffer(STp, aSRpnt);\r\nresult |= osst_flush_drive_buffer(STp, aSRpnt);\r\nSTp->last_mark_ppos = this_mark_ppos;\r\nSTp->last_mark_lbn = this_mark_lbn;\r\nif (STp->header_cache != NULL && STp->filemark_cnt < OS_FM_TAB_MAX)\r\nSTp->header_cache->dat_fm_tab.fm_tab_ent[STp->filemark_cnt] = htonl(this_mark_ppos);\r\nif (STp->filemark_cnt++ == 0)\r\nSTp->first_mark_ppos = this_mark_ppos;\r\nreturn result;\r\n}\r\nstatic int osst_write_eod(struct osst_tape * STp, struct osst_request ** aSRpnt)\r\n{\r\nint result;\r\n#if DEBUG\r\nchar * name = tape_name(STp);\r\n#endif\r\nif (STp->raw) return 0;\r\nSTp->write_type = OS_WRITE_EOD;\r\nSTp->eod_frame_ppos = STp->first_frame_position;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Writing EOD at fppos %d (fseq %d, lblk %d)\n", name,\r\nSTp->eod_frame_ppos, STp->frame_seq_number, STp->logical_blk_num);\r\n#endif\r\nSTp->dirty = 1;\r\nresult = osst_flush_write_buffer(STp, aSRpnt);\r\nresult |= osst_flush_drive_buffer(STp, aSRpnt);\r\nSTp->eod_frame_lfa = --(STp->frame_seq_number);\r\nreturn result;\r\n}\r\nstatic int osst_write_filler(struct osst_tape * STp, struct osst_request ** aSRpnt, int where, int count)\r\n{\r\nchar * name = tape_name(STp);\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Reached onstream write filler group %d\n", name, where);\r\n#endif\r\nosst_wait_ready(STp, aSRpnt, 60 * 5, 0);\r\nosst_set_frame_position(STp, aSRpnt, where, 0);\r\nSTp->write_type = OS_WRITE_FILLER;\r\nwhile (count--) {\r\nmemcpy(STp->buffer->b_data, "Filler", 6);\r\nSTp->buffer->buffer_bytes = 6;\r\nSTp->dirty = 1;\r\nif (osst_flush_write_buffer(STp, aSRpnt)) {\r\nprintk(KERN_INFO "%s:I: Couldn't write filler frame\n", name);\r\nreturn (-EIO);\r\n}\r\n}\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Exiting onstream write filler group\n", name);\r\n#endif\r\nreturn osst_flush_drive_buffer(STp, aSRpnt);\r\n}\r\nstatic int __osst_write_header(struct osst_tape * STp, struct osst_request ** aSRpnt, int where, int count)\r\n{\r\nchar * name = tape_name(STp);\r\nint result;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Reached onstream write header group %d\n", name, where);\r\n#endif\r\nosst_wait_ready(STp, aSRpnt, 60 * 5, 0);\r\nosst_set_frame_position(STp, aSRpnt, where, 0);\r\nSTp->write_type = OS_WRITE_HEADER;\r\nwhile (count--) {\r\nosst_copy_to_buffer(STp->buffer, (unsigned char *)STp->header_cache);\r\nSTp->buffer->buffer_bytes = sizeof(os_header_t);\r\nSTp->dirty = 1;\r\nif (osst_flush_write_buffer(STp, aSRpnt)) {\r\nprintk(KERN_INFO "%s:I: Couldn't write header frame\n", name);\r\nreturn (-EIO);\r\n}\r\n}\r\nresult = osst_flush_drive_buffer(STp, aSRpnt);\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Write onstream header group %s\n", name, result?"failed":"done");\r\n#endif\r\nreturn result;\r\n}\r\nstatic int osst_write_header(struct osst_tape * STp, struct osst_request ** aSRpnt, int locate_eod)\r\n{\r\nos_header_t * header;\r\nint result;\r\nchar * name = tape_name(STp);\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Writing tape header\n", name);\r\n#endif\r\nif (STp->raw) return 0;\r\nif (STp->header_cache == NULL) {\r\nif ((STp->header_cache = vmalloc(sizeof(os_header_t))) == NULL) {\r\nprintk(KERN_ERR "%s:E: Failed to allocate header cache\n", name);\r\nreturn (-ENOMEM);\r\n}\r\nmemset(STp->header_cache, 0, sizeof(os_header_t));\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Allocated and cleared memory for header cache\n", name);\r\n#endif\r\n}\r\nif (STp->header_ok) STp->update_frame_cntr++;\r\nelse STp->update_frame_cntr = 0;\r\nheader = STp->header_cache;\r\nstrcpy(header->ident_str, "ADR_SEQ");\r\nheader->major_rev = 1;\r\nheader->minor_rev = 4;\r\nheader->ext_trk_tb_off = htons(17192);\r\nheader->pt_par_num = 1;\r\nheader->partition[0].partition_num = OS_DATA_PARTITION;\r\nheader->partition[0].par_desc_ver = OS_PARTITION_VERSION;\r\nheader->partition[0].wrt_pass_cntr = htons(STp->wrt_pass_cntr);\r\nheader->partition[0].first_frame_ppos = htonl(STp->first_data_ppos);\r\nheader->partition[0].last_frame_ppos = htonl(STp->capacity);\r\nheader->partition[0].eod_frame_ppos = htonl(STp->eod_frame_ppos);\r\nheader->cfg_col_width = htonl(20);\r\nheader->dat_col_width = htonl(1500);\r\nheader->qfa_col_width = htonl(0);\r\nheader->ext_track_tb.nr_stream_part = 1;\r\nheader->ext_track_tb.et_ent_sz = 32;\r\nheader->ext_track_tb.dat_ext_trk_ey.et_part_num = 0;\r\nheader->ext_track_tb.dat_ext_trk_ey.fmt = 1;\r\nheader->ext_track_tb.dat_ext_trk_ey.fm_tab_off = htons(17736);\r\nheader->ext_track_tb.dat_ext_trk_ey.last_hlb_hi = 0;\r\nheader->ext_track_tb.dat_ext_trk_ey.last_hlb = htonl(STp->eod_frame_lfa);\r\nheader->ext_track_tb.dat_ext_trk_ey.last_pp = htonl(STp->eod_frame_ppos);\r\nheader->dat_fm_tab.fm_part_num = 0;\r\nheader->dat_fm_tab.fm_tab_ent_sz = 4;\r\nheader->dat_fm_tab.fm_tab_ent_cnt = htons(STp->filemark_cnt<OS_FM_TAB_MAX?\r\nSTp->filemark_cnt:OS_FM_TAB_MAX);\r\nresult = __osst_write_header(STp, aSRpnt, 0xbae, 5);\r\nif (STp->update_frame_cntr == 0)\r\nosst_write_filler(STp, aSRpnt, 0xbb3, 5);\r\nresult &= __osst_write_header(STp, aSRpnt, 5, 5);\r\nif (locate_eod) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Locating back to eod frame addr %d\n", name, STp->eod_frame_ppos);\r\n#endif\r\nosst_set_frame_position(STp, aSRpnt, STp->eod_frame_ppos, 0);\r\n}\r\nif (result)\r\nprintk(KERN_ERR "%s:E: Write header failed\n", name);\r\nelse {\r\nmemcpy(STp->application_sig, "LIN4", 4);\r\nSTp->linux_media = 1;\r\nSTp->linux_media_version = 4;\r\nSTp->header_ok = 1;\r\n}\r\nreturn result;\r\n}\r\nstatic int osst_reset_header(struct osst_tape * STp, struct osst_request ** aSRpnt)\r\n{\r\nif (STp->header_cache != NULL)\r\nmemset(STp->header_cache, 0, sizeof(os_header_t));\r\nSTp->logical_blk_num = STp->frame_seq_number = 0;\r\nSTp->frame_in_buffer = 0;\r\nSTp->eod_frame_ppos = STp->first_data_ppos = 0x0000000A;\r\nSTp->filemark_cnt = 0;\r\nSTp->first_mark_ppos = STp->last_mark_ppos = STp->last_mark_lbn = -1;\r\nreturn osst_write_header(STp, aSRpnt, 1);\r\n}\r\nstatic int __osst_analyze_headers(struct osst_tape * STp, struct osst_request ** aSRpnt, int ppos)\r\n{\r\nchar * name = tape_name(STp);\r\nos_header_t * header;\r\nos_aux_t * aux;\r\nchar id_string[8];\r\nint linux_media_version,\r\nupdate_frame_cntr;\r\nif (STp->raw)\r\nreturn 1;\r\nif (ppos == 5 || ppos == 0xbae || STp->buffer->syscall_result) {\r\nif (osst_set_frame_position(STp, aSRpnt, ppos, 0))\r\nprintk(KERN_WARNING "%s:W: Couldn't position tape\n", name);\r\nosst_wait_ready(STp, aSRpnt, 60 * 15, 0);\r\nif (osst_initiate_read (STp, aSRpnt)) {\r\nprintk(KERN_WARNING "%s:W: Couldn't initiate read\n", name);\r\nreturn 0;\r\n}\r\n}\r\nif (osst_read_frame(STp, aSRpnt, 180)) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Couldn't read header frame\n", name);\r\n#endif\r\nreturn 0;\r\n}\r\nheader = (os_header_t *) STp->buffer->b_data;\r\naux = STp->buffer->aux;\r\nif (aux->frame_type != OS_FRAME_TYPE_HEADER) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Skipping non-header frame (%d)\n", name, ppos);\r\n#endif\r\nreturn 0;\r\n}\r\nif (ntohl(aux->frame_seq_num) != 0 ||\r\nntohl(aux->logical_blk_num) != 0 ||\r\naux->partition.partition_num != OS_CONFIG_PARTITION ||\r\nntohl(aux->partition.first_frame_ppos) != 0 ||\r\nntohl(aux->partition.last_frame_ppos) != 0xbb7 ) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Invalid header frame (%d,%d,%d,%d,%d)\n", name,\r\nntohl(aux->frame_seq_num), ntohl(aux->logical_blk_num),\r\naux->partition.partition_num, ntohl(aux->partition.first_frame_ppos),\r\nntohl(aux->partition.last_frame_ppos));\r\n#endif\r\nreturn 0;\r\n}\r\nif (strncmp(header->ident_str, "ADR_SEQ", 7) != 0 &&\r\nstrncmp(header->ident_str, "ADR-SEQ", 7) != 0) {\r\nstrlcpy(id_string, header->ident_str, 8);\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Invalid header identification string %s\n", name, id_string);\r\n#endif\r\nreturn 0;\r\n}\r\nupdate_frame_cntr = ntohl(aux->update_frame_cntr);\r\nif (update_frame_cntr < STp->update_frame_cntr) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Skipping frame %d with update_frame_counter %d<%d\n",\r\nname, ppos, update_frame_cntr, STp->update_frame_cntr);\r\n#endif\r\nreturn 0;\r\n}\r\nif (header->major_rev != 1 || header->minor_rev != 4 ) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: %s revision %d.%d detected (1.4 supported)\n",\r\nname, (header->major_rev != 1 || header->minor_rev < 2 ||\r\nheader->minor_rev > 4 )? "Invalid" : "Warning:",\r\nheader->major_rev, header->minor_rev);\r\n#endif\r\nif (header->major_rev != 1 || header->minor_rev < 2 || header->minor_rev > 4)\r\nreturn 0;\r\n}\r\n#if DEBUG\r\nif (header->pt_par_num != 1)\r\nprintk(KERN_INFO "%s:W: %d partitions defined, only one supported\n",\r\nname, header->pt_par_num);\r\n#endif\r\nmemcpy(id_string, aux->application_sig, 4);\r\nid_string[4] = 0;\r\nif (memcmp(id_string, "LIN", 3) == 0) {\r\nSTp->linux_media = 1;\r\nlinux_media_version = id_string[3] - '0';\r\nif (linux_media_version != 4)\r\nprintk(KERN_INFO "%s:I: Linux media version %d detected (current 4)\n",\r\nname, linux_media_version);\r\n} else {\r\nprintk(KERN_WARNING "%s:W: Non Linux media detected (%s)\n", name, id_string);\r\nreturn 0;\r\n}\r\nif (linux_media_version < STp->linux_media_version) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Skipping frame %d with linux_media_version %d\n",\r\nname, ppos, linux_media_version);\r\n#endif\r\nreturn 0;\r\n}\r\nif (linux_media_version > STp->linux_media_version) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Frame %d sets linux_media_version to %d\n",\r\nname, ppos, linux_media_version);\r\n#endif\r\nmemcpy(STp->application_sig, id_string, 5);\r\nSTp->linux_media_version = linux_media_version;\r\nSTp->update_frame_cntr = -1;\r\n}\r\nif (update_frame_cntr > STp->update_frame_cntr) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Frame %d sets update_frame_counter to %d\n",\r\nname, ppos, update_frame_cntr);\r\n#endif\r\nif (STp->header_cache == NULL) {\r\nif ((STp->header_cache = vmalloc(sizeof(os_header_t))) == NULL) {\r\nprintk(KERN_ERR "%s:E: Failed to allocate header cache\n", name);\r\nreturn 0;\r\n}\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Allocated memory for header cache\n", name);\r\n#endif\r\n}\r\nosst_copy_from_buffer(STp->buffer, (unsigned char *)STp->header_cache);\r\nheader = STp->header_cache;\r\nSTp->wrt_pass_cntr = ntohs(header->partition[0].wrt_pass_cntr);\r\nSTp->first_data_ppos = ntohl(header->partition[0].first_frame_ppos);\r\nSTp->eod_frame_ppos = ntohl(header->partition[0].eod_frame_ppos);\r\nSTp->eod_frame_lfa = ntohl(header->ext_track_tb.dat_ext_trk_ey.last_hlb);\r\nSTp->filemark_cnt = ntohl(aux->filemark_cnt);\r\nSTp->first_mark_ppos = ntohl(aux->next_mark_ppos);\r\nSTp->last_mark_ppos = ntohl(aux->last_mark_ppos);\r\nSTp->last_mark_lbn = ntohl(aux->last_mark_lbn);\r\nSTp->update_frame_cntr = update_frame_cntr;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Detected write pass %d, update frame counter %d, filemark counter %d\n",\r\nname, STp->wrt_pass_cntr, STp->update_frame_cntr, STp->filemark_cnt);\r\nprintk(OSST_DEB_MSG "%s:D: first data frame on tape = %d, last = %d, eod frame = %d\n", name,\r\nSTp->first_data_ppos,\r\nntohl(header->partition[0].last_frame_ppos),\r\nntohl(header->partition[0].eod_frame_ppos));\r\nprintk(OSST_DEB_MSG "%s:D: first mark on tape = %d, last = %d, eod frame = %d\n",\r\nname, STp->first_mark_ppos, STp->last_mark_ppos, STp->eod_frame_ppos);\r\n#endif\r\nif (header->minor_rev < 4 && STp->linux_media_version == 4) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Moving filemark list to ADR 1.4 location\n", name);\r\n#endif\r\nmemcpy((void *)header->dat_fm_tab.fm_tab_ent,\r\n(void *)header->old_filemark_list, sizeof(header->dat_fm_tab.fm_tab_ent));\r\nmemset((void *)header->old_filemark_list, 0, sizeof(header->old_filemark_list));\r\n}\r\nif (header->minor_rev == 4 &&\r\n(header->ext_trk_tb_off != htons(17192) ||\r\nheader->partition[0].partition_num != OS_DATA_PARTITION ||\r\nheader->partition[0].par_desc_ver != OS_PARTITION_VERSION ||\r\nheader->partition[0].last_frame_ppos != htonl(STp->capacity) ||\r\nheader->cfg_col_width != htonl(20) ||\r\nheader->dat_col_width != htonl(1500) ||\r\nheader->qfa_col_width != htonl(0) ||\r\nheader->ext_track_tb.nr_stream_part != 1 ||\r\nheader->ext_track_tb.et_ent_sz != 32 ||\r\nheader->ext_track_tb.dat_ext_trk_ey.et_part_num != OS_DATA_PARTITION ||\r\nheader->ext_track_tb.dat_ext_trk_ey.fmt != 1 ||\r\nheader->ext_track_tb.dat_ext_trk_ey.fm_tab_off != htons(17736) ||\r\nheader->ext_track_tb.dat_ext_trk_ey.last_hlb_hi != 0 ||\r\nheader->ext_track_tb.dat_ext_trk_ey.last_pp != htonl(STp->eod_frame_ppos) ||\r\nheader->dat_fm_tab.fm_part_num != OS_DATA_PARTITION ||\r\nheader->dat_fm_tab.fm_tab_ent_sz != 4 ||\r\nheader->dat_fm_tab.fm_tab_ent_cnt !=\r\nhtons(STp->filemark_cnt<OS_FM_TAB_MAX?STp->filemark_cnt:OS_FM_TAB_MAX)))\r\nprintk(KERN_WARNING "%s:W: Failed consistency check ADR 1.4 format\n", name);\r\n}\r\nreturn 1;\r\n}\r\nstatic int osst_analyze_headers(struct osst_tape * STp, struct osst_request ** aSRpnt)\r\n{\r\nint position, ppos;\r\nint first, last;\r\nint valid = 0;\r\nchar * name = tape_name(STp);\r\nposition = osst_get_frame_position(STp, aSRpnt);\r\nif (STp->raw) {\r\nSTp->header_ok = STp->linux_media = 1;\r\nSTp->linux_media_version = 0;\r\nreturn 1;\r\n}\r\nSTp->header_ok = STp->linux_media = STp->linux_media_version = 0;\r\nSTp->wrt_pass_cntr = STp->update_frame_cntr = -1;\r\nSTp->eod_frame_ppos = STp->first_data_ppos = -1;\r\nSTp->first_mark_ppos = STp->last_mark_ppos = STp->last_mark_lbn = -1;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Reading header\n", name);\r\n#endif\r\nfirst = position==10?0xbae: 5;\r\nlast = position==10?0xbb3:10;\r\nfor (ppos = first; ppos < last; ppos++)\r\nif (__osst_analyze_headers(STp, aSRpnt, ppos))\r\nvalid = 1;\r\nfirst = position==10? 5:0xbae;\r\nlast = position==10?10:0xbb3;\r\nfor (ppos = first; ppos < last; ppos++)\r\nif (__osst_analyze_headers(STp, aSRpnt, ppos))\r\nvalid = 1;\r\nif (!valid) {\r\nprintk(KERN_ERR "%s:E: Failed to find valid ADRL header, new media?\n", name);\r\nSTp->eod_frame_ppos = STp->first_data_ppos = 0;\r\nosst_set_frame_position(STp, aSRpnt, 10, 0);\r\nreturn 0;\r\n}\r\nif (position <= STp->first_data_ppos) {\r\nposition = STp->first_data_ppos;\r\nSTp->ps[0].drv_file = STp->ps[0].drv_block = STp->frame_seq_number = STp->logical_blk_num = 0;\r\n}\r\nosst_set_frame_position(STp, aSRpnt, position, 0);\r\nSTp->header_ok = 1;\r\nreturn 1;\r\n}\r\nstatic int osst_verify_position(struct osst_tape * STp, struct osst_request ** aSRpnt)\r\n{\r\nint frame_position = STp->first_frame_position;\r\nint frame_seq_numbr = STp->frame_seq_number;\r\nint logical_blk_num = STp->logical_blk_num;\r\nint halfway_frame = STp->frame_in_buffer;\r\nint read_pointer = STp->buffer->read_pointer;\r\nint prev_mark_ppos = -1;\r\nint actual_mark_ppos, i, n;\r\n#if DEBUG\r\nchar * name = tape_name(STp);\r\nprintk(OSST_DEB_MSG "%s:D: Verify that the tape is really the one we think before writing\n", name);\r\n#endif\r\nosst_set_frame_position(STp, aSRpnt, frame_position - 1, 0);\r\nif (osst_get_logical_frame(STp, aSRpnt, -1, 0) < 0) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Couldn't get logical blk num in verify_position\n", name);\r\n#endif\r\nreturn (-EIO);\r\n}\r\nif (STp->linux_media_version >= 4) {\r\nfor (i=0; i<STp->filemark_cnt; i++)\r\nif ((n=ntohl(STp->header_cache->dat_fm_tab.fm_tab_ent[i])) < frame_position)\r\nprev_mark_ppos = n;\r\n} else\r\nprev_mark_ppos = frame_position - 1;\r\nactual_mark_ppos = STp->buffer->aux->frame_type == OS_FRAME_TYPE_MARKER ?\r\nframe_position - 1 : ntohl(STp->buffer->aux->last_mark_ppos);\r\nif (frame_position != STp->first_frame_position ||\r\nframe_seq_numbr != STp->frame_seq_number + (halfway_frame?0:1) ||\r\nprev_mark_ppos != actual_mark_ppos ) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Block mismatch: fppos %d-%d, fseq %d-%d, mark %d-%d\n", name,\r\nSTp->first_frame_position, frame_position,\r\nSTp->frame_seq_number + (halfway_frame?0:1),\r\nframe_seq_numbr, actual_mark_ppos, prev_mark_ppos);\r\n#endif\r\nreturn (-EIO);\r\n}\r\nif (halfway_frame) {\r\nosst_set_frame_position(STp, aSRpnt, frame_position - 1, 0);\r\nSTp->buffer->buffer_bytes = read_pointer;\r\nSTp->ps[STp->partition].rw = ST_WRITING;\r\nSTp->dirty = 1;\r\n}\r\nSTp->frame_in_buffer = halfway_frame;\r\nSTp->frame_seq_number = frame_seq_numbr;\r\nSTp->logical_blk_num = logical_blk_num;\r\nreturn 0;\r\n}\r\nstatic unsigned int osst_parse_firmware_rev (const char * str)\r\n{\r\nif (str[1] == '.') {\r\nreturn (str[0]-'0')*10000\r\n+(str[2]-'0')*1000\r\n+(str[3]-'0')*100;\r\n} else {\r\nreturn (str[0]-'0')*10000\r\n+(str[1]-'0')*1000\r\n+(str[2]-'0')*100 - 100\r\n+(str[3]-'@');\r\n}\r\n}\r\nstatic int osst_configure_onstream(struct osst_tape *STp, struct osst_request ** aSRpnt)\r\n{\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nchar * name = tape_name(STp);\r\nstruct osst_request * SRpnt = * aSRpnt;\r\nosst_mode_parameter_header_t * header;\r\nosst_block_size_page_t * bs;\r\nosst_capabilities_page_t * cp;\r\nosst_tape_paramtr_page_t * prm;\r\nint drive_buffer_size;\r\nif (STp->ready != ST_READY) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Not Ready\n", name);\r\n#endif\r\nreturn (-EIO);\r\n}\r\nif (STp->os_fw_rev < 10600) {\r\nprintk(KERN_INFO "%s:I: Old OnStream firmware revision detected (%s),\n", name, STp->device->rev);\r\nprintk(KERN_INFO "%s:I: an upgrade to version 1.06 or above is recommended\n", name);\r\n}\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = MODE_SENSE;\r\ncmd[1] = 8;\r\ncmd[2] = BLOCK_SIZE_PAGE;\r\ncmd[4] = BLOCK_SIZE_PAGE_LENGTH + MODE_HEADER_LENGTH;\r\nSRpnt = osst_do_scsi(SRpnt, STp, cmd, cmd[4], DMA_FROM_DEVICE, STp->timeout, 0, 1);\r\nif (SRpnt == NULL) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "osst :D: Busy\n");\r\n#endif\r\nreturn (-EBUSY);\r\n}\r\n*aSRpnt = SRpnt;\r\nif ((STp->buffer)->syscall_result != 0) {\r\nprintk (KERN_ERR "%s:E: Can't get tape block size mode page\n", name);\r\nreturn (-EIO);\r\n}\r\nheader = (osst_mode_parameter_header_t *) (STp->buffer)->b_data;\r\nbs = (osst_block_size_page_t *) ((STp->buffer)->b_data + sizeof(osst_mode_parameter_header_t) + header->bdl);\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: 32KB play back: %s\n", name, bs->play32 ? "Yes" : "No");\r\nprintk(OSST_DEB_MSG "%s:D: 32.5KB play back: %s\n", name, bs->play32_5 ? "Yes" : "No");\r\nprintk(OSST_DEB_MSG "%s:D: 32KB record: %s\n", name, bs->record32 ? "Yes" : "No");\r\nprintk(OSST_DEB_MSG "%s:D: 32.5KB record: %s\n", name, bs->record32_5 ? "Yes" : "No");\r\n#endif\r\nbs->one = 1;\r\nbs->play32 = 0;\r\nbs->play32_5 = 1;\r\nbs->record32 = 0;\r\nbs->record32_5 = 1;\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = MODE_SELECT;\r\ncmd[1] = 0x10;\r\ncmd[4] = BLOCK_SIZE_PAGE_LENGTH + MODE_HEADER_LENGTH;\r\nSRpnt = osst_do_scsi(SRpnt, STp, cmd, cmd[4], DMA_TO_DEVICE, STp->timeout, 0, 1);\r\n*aSRpnt = SRpnt;\r\nif ((STp->buffer)->syscall_result != 0) {\r\nprintk (KERN_ERR "%s:E: Couldn't set tape block size mode page\n", name);\r\nreturn (-EIO);\r\n}\r\n#if DEBUG\r\nprintk(KERN_INFO "%s:D: Drive Block Size changed to 32.5K\n", name);\r\nosst_set_retries(STp, aSRpnt, 0);\r\nSRpnt = * aSRpnt;\r\n#endif\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = MODE_SELECT;\r\ncmd[1] = 0x10;\r\ncmd[4] = VENDOR_IDENT_PAGE_LENGTH + MODE_HEADER_LENGTH;\r\nheader->mode_data_length = VENDOR_IDENT_PAGE_LENGTH + MODE_HEADER_LENGTH - 1;\r\nheader->medium_type = 0;\r\nheader->dsp = 0;\r\nheader->bdl = 0;\r\n(STp->buffer)->b_data[MODE_HEADER_LENGTH + 0] = VENDOR_IDENT_PAGE | (1 << 7);\r\n(STp->buffer)->b_data[MODE_HEADER_LENGTH + 1] = 6;\r\n(STp->buffer)->b_data[MODE_HEADER_LENGTH + 2] = 'L';\r\n(STp->buffer)->b_data[MODE_HEADER_LENGTH + 3] = 'I';\r\n(STp->buffer)->b_data[MODE_HEADER_LENGTH + 4] = 'N';\r\n(STp->buffer)->b_data[MODE_HEADER_LENGTH + 5] = '4';\r\n(STp->buffer)->b_data[MODE_HEADER_LENGTH + 6] = 0;\r\n(STp->buffer)->b_data[MODE_HEADER_LENGTH + 7] = 0;\r\nSRpnt = osst_do_scsi(SRpnt, STp, cmd, cmd[4], DMA_TO_DEVICE, STp->timeout, 0, 1);\r\n*aSRpnt = SRpnt;\r\nif ((STp->buffer)->syscall_result != 0) {\r\nprintk (KERN_ERR "%s:E: Couldn't set vendor name to %s\n", name,\r\n(char *) ((STp->buffer)->b_data + MODE_HEADER_LENGTH + 2));\r\nreturn (-EIO);\r\n}\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = MODE_SENSE;\r\ncmd[1] = 8;\r\ncmd[2] = CAPABILITIES_PAGE;\r\ncmd[4] = CAPABILITIES_PAGE_LENGTH + MODE_HEADER_LENGTH;\r\nSRpnt = osst_do_scsi(SRpnt, STp, cmd, cmd[4], DMA_FROM_DEVICE, STp->timeout, 0, 1);\r\n*aSRpnt = SRpnt;\r\nif ((STp->buffer)->syscall_result != 0) {\r\nprintk (KERN_ERR "%s:E: Can't get capabilities page\n", name);\r\nreturn (-EIO);\r\n}\r\nheader = (osst_mode_parameter_header_t *) (STp->buffer)->b_data;\r\ncp = (osst_capabilities_page_t *) ((STp->buffer)->b_data +\r\nsizeof(osst_mode_parameter_header_t) + header->bdl);\r\ndrive_buffer_size = ntohs(cp->buffer_size) / 2;\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = MODE_SENSE;\r\ncmd[1] = 8;\r\ncmd[2] = TAPE_PARAMTR_PAGE;\r\ncmd[4] = TAPE_PARAMTR_PAGE_LENGTH + MODE_HEADER_LENGTH;\r\nSRpnt = osst_do_scsi(SRpnt, STp, cmd, cmd[4], DMA_FROM_DEVICE, STp->timeout, 0, 1);\r\n*aSRpnt = SRpnt;\r\nif ((STp->buffer)->syscall_result != 0) {\r\nprintk (KERN_ERR "%s:E: Can't get tape parameter page\n", name);\r\nreturn (-EIO);\r\n}\r\nheader = (osst_mode_parameter_header_t *) (STp->buffer)->b_data;\r\nprm = (osst_tape_paramtr_page_t *) ((STp->buffer)->b_data +\r\nsizeof(osst_mode_parameter_header_t) + header->bdl);\r\nSTp->density = prm->density;\r\nSTp->capacity = ntohs(prm->segtrk) * ntohs(prm->trks);\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Density %d, tape length: %dMB, drive buffer size: %dKB\n",\r\nname, STp->density, STp->capacity / 32, drive_buffer_size);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int cross_eof(struct osst_tape *STp, struct osst_request ** aSRpnt, int forward)\r\n{\r\nint result;\r\nchar * name = tape_name(STp);\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Stepping over filemark %s.\n",\r\nname, forward ? "forward" : "backward");\r\n#endif\r\nif (forward) {\r\nresult = osst_space_over_filemarks_forward_slow(STp, aSRpnt, MTFSF, 1);\r\n}\r\nelse\r\nresult = osst_seek_logical_blk(STp, aSRpnt, STp->logical_blk_num - 1);\r\nif (result < 0)\r\nprintk(KERN_WARNING "%s:W: Stepping over filemark %s failed.\n",\r\nname, forward ? "forward" : "backward");\r\nreturn result;\r\n}\r\nstatic int osst_get_frame_position(struct osst_tape *STp, struct osst_request ** aSRpnt)\r\n{\r\nunsigned char scmd[MAX_COMMAND_SIZE];\r\nstruct osst_request * SRpnt;\r\nint result = 0;\r\nchar * name = tape_name(STp);\r\nchar mybuf[24];\r\nchar * olddata = STp->buffer->b_data;\r\nint oldsize = STp->buffer->buffer_size;\r\nif (STp->ready != ST_READY) return (-EIO);\r\nmemset (scmd, 0, MAX_COMMAND_SIZE);\r\nscmd[0] = READ_POSITION;\r\nSTp->buffer->b_data = mybuf; STp->buffer->buffer_size = 24;\r\nSRpnt = osst_do_scsi(*aSRpnt, STp, scmd, 20, DMA_FROM_DEVICE,\r\nSTp->timeout, MAX_RETRIES, 1);\r\nif (!SRpnt) {\r\nSTp->buffer->b_data = olddata; STp->buffer->buffer_size = oldsize;\r\nreturn (-EBUSY);\r\n}\r\n*aSRpnt = SRpnt;\r\nif (STp->buffer->syscall_result)\r\nresult = ((SRpnt->sense[2] & 0x0f) == 3) ? -EIO : -EINVAL;\r\nif (result == -EINVAL)\r\nprintk(KERN_ERR "%s:E: Can't read tape position.\n", name);\r\nelse {\r\nif (result == -EIO) {\r\nunsigned char mysense[16];\r\nmemcpy (mysense, SRpnt->sense, 16);\r\nmemset (scmd, 0, MAX_COMMAND_SIZE);\r\nscmd[0] = READ_POSITION;\r\nSTp->buffer->b_data = mybuf; STp->buffer->buffer_size = 24;\r\nSRpnt = osst_do_scsi(SRpnt, STp, scmd, 20, DMA_FROM_DEVICE,\r\nSTp->timeout, MAX_RETRIES, 1);\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Reread position, reason=[%02x:%02x:%02x], result=[%s%02x:%02x:%02x]\n",\r\nname, mysense[2], mysense[12], mysense[13], STp->buffer->syscall_result?"":"ok:",\r\nSRpnt->sense[2],SRpnt->sense[12],SRpnt->sense[13]);\r\n#endif\r\nif (!STp->buffer->syscall_result)\r\nmemcpy (SRpnt->sense, mysense, 16);\r\nelse\r\nprintk(KERN_WARNING "%s:W: Double error in get position\n", name);\r\n}\r\nSTp->first_frame_position = ((STp->buffer)->b_data[4] << 24)\r\n+ ((STp->buffer)->b_data[5] << 16)\r\n+ ((STp->buffer)->b_data[6] << 8)\r\n+ (STp->buffer)->b_data[7];\r\nSTp->last_frame_position = ((STp->buffer)->b_data[ 8] << 24)\r\n+ ((STp->buffer)->b_data[ 9] << 16)\r\n+ ((STp->buffer)->b_data[10] << 8)\r\n+ (STp->buffer)->b_data[11];\r\nSTp->cur_frames = (STp->buffer)->b_data[15];\r\n#if DEBUG\r\nif (debugging) {\r\nprintk(OSST_DEB_MSG "%s:D: Drive Positions: host %d, tape %d%s, buffer %d\n", name,\r\nSTp->first_frame_position, STp->last_frame_position,\r\n((STp->buffer)->b_data[0]&0x80)?" (BOP)":\r\n((STp->buffer)->b_data[0]&0x40)?" (EOP)":"",\r\nSTp->cur_frames);\r\n}\r\n#endif\r\nif (STp->cur_frames == 0 && STp->first_frame_position != STp->last_frame_position) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Correcting read position %d, %d, %d\n", name,\r\nSTp->first_frame_position, STp->last_frame_position, STp->cur_frames);\r\n#endif\r\nSTp->first_frame_position = STp->last_frame_position;\r\n}\r\n}\r\nSTp->buffer->b_data = olddata; STp->buffer->buffer_size = oldsize;\r\nreturn (result == 0 ? STp->first_frame_position : result);\r\n}\r\nstatic int osst_set_frame_position(struct osst_tape *STp, struct osst_request ** aSRpnt, int ppos, int skip)\r\n{\r\nunsigned char scmd[MAX_COMMAND_SIZE];\r\nstruct osst_request * SRpnt;\r\nstruct st_partstat * STps;\r\nint result = 0;\r\nint pp = (ppos == 3000 && !skip)? 0 : ppos;\r\nchar * name = tape_name(STp);\r\nif (STp->ready != ST_READY) return (-EIO);\r\nSTps = &(STp->ps[STp->partition]);\r\nif (ppos < 0 || ppos > STp->capacity) {\r\nprintk(KERN_WARNING "%s:W: Reposition request %d out of range\n", name, ppos);\r\npp = ppos = ppos < 0 ? 0 : (STp->capacity - 1);\r\nresult = (-EINVAL);\r\n}\r\ndo {\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Setting ppos to %d.\n", name, pp);\r\n#endif\r\nmemset (scmd, 0, MAX_COMMAND_SIZE);\r\nscmd[0] = SEEK_10;\r\nscmd[1] = 1;\r\nscmd[3] = (pp >> 24);\r\nscmd[4] = (pp >> 16);\r\nscmd[5] = (pp >> 8);\r\nscmd[6] = pp;\r\nif (skip)\r\nscmd[9] = 0x80;\r\nSRpnt = osst_do_scsi(*aSRpnt, STp, scmd, 0, DMA_NONE, STp->long_timeout,\r\nMAX_RETRIES, 1);\r\nif (!SRpnt)\r\nreturn (-EBUSY);\r\n*aSRpnt = SRpnt;\r\nif ((STp->buffer)->syscall_result != 0) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: SEEK command from %d to %d failed.\n",\r\nname, STp->first_frame_position, pp);\r\n#endif\r\nresult = (-EIO);\r\n}\r\nif (pp != ppos)\r\nosst_wait_ready(STp, aSRpnt, 5 * 60, OSST_WAIT_POSITION_COMPLETE);\r\n} while ((pp != ppos) && (pp = ppos));\r\nSTp->first_frame_position = STp->last_frame_position = ppos;\r\nSTps->eof = ST_NOEOF;\r\nSTps->at_sm = 0;\r\nSTps->rw = ST_IDLE;\r\nSTp->frame_in_buffer = 0;\r\nreturn result;\r\n}\r\nstatic int osst_write_trailer(struct osst_tape *STp, struct osst_request ** aSRpnt, int leave_at_EOT)\r\n{\r\nstruct st_partstat * STps = &(STp->ps[STp->partition]);\r\nint result = 0;\r\nif (STp->write_type != OS_WRITE_NEW_MARK) {\r\nresult = osst_flush_drive_buffer(STp, aSRpnt);\r\nif (result < 0) goto out;\r\nresult = osst_write_filemark(STp, aSRpnt);\r\nif (result < 0) goto out;\r\nif (STps->drv_file >= 0)\r\nSTps->drv_file++ ;\r\nSTps->drv_block = 0;\r\n}\r\nresult = osst_write_eod(STp, aSRpnt);\r\nosst_write_header(STp, aSRpnt, leave_at_EOT);\r\nSTps->eof = ST_FM;\r\nout:\r\nreturn result;\r\n}\r\nstatic int osst_flush_write_buffer(struct osst_tape *STp, struct osst_request ** aSRpnt)\r\n{\r\nint offset, transfer, blks = 0;\r\nint result = 0;\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nstruct osst_request * SRpnt = *aSRpnt;\r\nstruct st_partstat * STps;\r\nchar * name = tape_name(STp);\r\nif ((STp->buffer)->writing) {\r\nif (SRpnt == (STp->buffer)->last_SRpnt)\r\n#if DEBUG\r\n{ printk(OSST_DEB_MSG\r\n"%s:D: aSRpnt points to osst_request that write_behind_check will release -- cleared\n", name);\r\n#endif\r\n*aSRpnt = SRpnt = NULL;\r\n#if DEBUG\r\n} else if (SRpnt)\r\nprintk(OSST_DEB_MSG\r\n"%s:D: aSRpnt does not point to osst_request that write_behind_check will release -- strange\n", name);\r\n#endif\r\nosst_write_behind_check(STp);\r\nif ((STp->buffer)->syscall_result) {\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Async write error (flush) %x.\n",\r\nname, (STp->buffer)->midlevel_result);\r\n#endif\r\nif ((STp->buffer)->midlevel_result == INT_MAX)\r\nreturn (-ENOSPC);\r\nreturn (-EIO);\r\n}\r\n}\r\nresult = 0;\r\nif (STp->dirty == 1) {\r\nSTp->write_count++;\r\nSTps = &(STp->ps[STp->partition]);\r\nSTps->rw = ST_WRITING;\r\noffset = STp->buffer->buffer_bytes;\r\nblks = (offset + STp->block_size - 1) / STp->block_size;\r\ntransfer = OS_FRAME_SIZE;\r\nif (offset < OS_DATA_SIZE)\r\nosst_zero_buffer_tail(STp->buffer);\r\nif (STp->poll)\r\nif (osst_wait_frame (STp, aSRpnt, STp->first_frame_position, -50, 120))\r\nresult = osst_recover_wait_frame(STp, aSRpnt, 1);\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = WRITE_6;\r\ncmd[1] = 1;\r\ncmd[4] = 1;\r\nswitch (STp->write_type) {\r\ncase OS_WRITE_DATA:\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Writing %d blocks to frame %d, lblks %d-%d\n",\r\nname, blks, STp->frame_seq_number,\r\nSTp->logical_blk_num - blks, STp->logical_blk_num - 1);\r\n#endif\r\nosst_init_aux(STp, OS_FRAME_TYPE_DATA, STp->frame_seq_number++,\r\nSTp->logical_blk_num - blks, STp->block_size, blks);\r\nbreak;\r\ncase OS_WRITE_EOD:\r\nosst_init_aux(STp, OS_FRAME_TYPE_EOD, STp->frame_seq_number++,\r\nSTp->logical_blk_num, 0, 0);\r\nbreak;\r\ncase OS_WRITE_NEW_MARK:\r\nosst_init_aux(STp, OS_FRAME_TYPE_MARKER, STp->frame_seq_number++,\r\nSTp->logical_blk_num++, 0, blks=1);\r\nbreak;\r\ncase OS_WRITE_HEADER:\r\nosst_init_aux(STp, OS_FRAME_TYPE_HEADER, 0, 0, 0, blks=0);\r\nbreak;\r\ndefault:\r\nosst_init_aux(STp, OS_FRAME_TYPE_FILL, 0, 0, 0, 0);\r\n}\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Flushing %d bytes, Transferring %d bytes in %d lblocks.\n",\r\nname, offset, transfer, blks);\r\n#endif\r\nSRpnt = osst_do_scsi(*aSRpnt, STp, cmd, transfer, DMA_TO_DEVICE,\r\nSTp->timeout, MAX_RETRIES, 1);\r\n*aSRpnt = SRpnt;\r\nif (!SRpnt)\r\nreturn (-EBUSY);\r\nif ((STp->buffer)->syscall_result != 0) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG\r\n"%s:D: write sense [0]=0x%02x [2]=%02x [12]=%02x [13]=%02x\n",\r\nname, SRpnt->sense[0], SRpnt->sense[2],\r\nSRpnt->sense[12], SRpnt->sense[13]);\r\n#endif\r\nif ((SRpnt->sense[0] & 0x70) == 0x70 &&\r\n(SRpnt->sense[2] & 0x40) &&\r\n(SRpnt->sense[2] & 0x0f) == NO_SENSE) {\r\nSTp->dirty = 0;\r\n(STp->buffer)->buffer_bytes = 0;\r\nresult = (-ENOSPC);\r\n}\r\nelse {\r\nif (osst_write_error_recovery(STp, aSRpnt, 1)) {\r\nprintk(KERN_ERR "%s:E: Error on flush write.\n", name);\r\nresult = (-EIO);\r\n}\r\n}\r\nSTps->drv_block = (-1);\r\n}\r\nelse {\r\nSTp->first_frame_position++;\r\nSTp->dirty = 0;\r\n(STp->buffer)->buffer_bytes = 0;\r\n}\r\n}\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Exit flush write buffer with code %d\n", name, result);\r\n#endif\r\nreturn result;\r\n}\r\nstatic int osst_flush_buffer(struct osst_tape * STp, struct osst_request ** aSRpnt, int seek_next)\r\n{\r\nstruct st_partstat * STps;\r\nint backspace = 0, result = 0;\r\n#if DEBUG\r\nchar * name = tape_name(STp);\r\n#endif\r\nif( STp->pos_unknown)\r\nreturn (-EIO);\r\nif (STp->ready != ST_READY)\r\nreturn 0;\r\nSTps = &(STp->ps[STp->partition]);\r\nif (STps->rw == ST_WRITING || STp->dirty) {\r\nSTp->write_type = OS_WRITE_DATA;\r\nreturn osst_flush_write_buffer(STp, aSRpnt);\r\n}\r\nif (STp->block_size == 0)\r\nreturn 0;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Reached flush (read) buffer\n", name);\r\n#endif\r\nif (!STp->can_bsr) {\r\nbackspace = ((STp->buffer)->buffer_bytes + (STp->buffer)->read_pointer) / STp->block_size -\r\n((STp->buffer)->read_pointer + STp->block_size - 1 ) / STp->block_size ;\r\n(STp->buffer)->buffer_bytes = 0;\r\n(STp->buffer)->read_pointer = 0;\r\nSTp->frame_in_buffer = 0;\r\n}\r\nif (!seek_next) {\r\nif (STps->eof == ST_FM_HIT) {\r\nresult = cross_eof(STp, aSRpnt, 0);\r\nif (!result)\r\nSTps->eof = ST_NOEOF;\r\nelse {\r\nif (STps->drv_file >= 0)\r\nSTps->drv_file++;\r\nSTps->drv_block = 0;\r\n}\r\n}\r\nif (!result && backspace > 0)\r\nresult = osst_seek_logical_blk(STp, aSRpnt, STp->logical_blk_num - backspace);\r\n}\r\nelse if (STps->eof == ST_FM_HIT) {\r\nif (STps->drv_file >= 0)\r\nSTps->drv_file++;\r\nSTps->drv_block = 0;\r\nSTps->eof = ST_NOEOF;\r\n}\r\nreturn result;\r\n}\r\nstatic int osst_write_frame(struct osst_tape * STp, struct osst_request ** aSRpnt, int synchronous)\r\n{\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nstruct osst_request * SRpnt;\r\nint blks;\r\n#if DEBUG\r\nchar * name = tape_name(STp);\r\n#endif\r\nif ((!STp-> raw) && (STp->first_frame_position == 0xbae)) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Reaching config partition.\n", name);\r\n#endif\r\nif (osst_flush_drive_buffer(STp, aSRpnt) < 0) {\r\nreturn (-EIO);\r\n}\r\nif (osst_get_frame_position(STp, aSRpnt) < 0xbb8) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Skipping over config partition.\n", name);\r\n#endif\r\nosst_position_tape_and_confirm(STp, aSRpnt, 0xbb8);\r\n}\r\n}\r\nif (STp->poll)\r\nif (osst_wait_frame (STp, aSRpnt, STp->first_frame_position, -48, 120))\r\nif (osst_recover_wait_frame(STp, aSRpnt, 1))\r\nreturn (-EIO);\r\nSTp->ps[STp->partition].rw = ST_WRITING;\r\nSTp->write_type = OS_WRITE_DATA;\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = WRITE_6;\r\ncmd[1] = 1;\r\ncmd[4] = 1;\r\nblks = STp->buffer->buffer_bytes / STp->block_size;\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Writing %d blocks to frame %d, lblks %d-%d\n", name, blks,\r\nSTp->frame_seq_number, STp->logical_blk_num - blks, STp->logical_blk_num - 1);\r\n#endif\r\nosst_init_aux(STp, OS_FRAME_TYPE_DATA, STp->frame_seq_number++,\r\nSTp->logical_blk_num - blks, STp->block_size, blks);\r\n#if DEBUG\r\nif (!synchronous)\r\nSTp->write_pending = 1;\r\n#endif\r\nSRpnt = osst_do_scsi(*aSRpnt, STp, cmd, OS_FRAME_SIZE, DMA_TO_DEVICE, STp->timeout,\r\nMAX_RETRIES, synchronous);\r\nif (!SRpnt)\r\nreturn (-EBUSY);\r\n*aSRpnt = SRpnt;\r\nif (synchronous) {\r\nif (STp->buffer->syscall_result != 0) {\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Error on write:\n", name);\r\n#endif\r\nif ((SRpnt->sense[0] & 0x70) == 0x70 &&\r\n(SRpnt->sense[2] & 0x40)) {\r\nif ((SRpnt->sense[2] & 0x0f) == VOLUME_OVERFLOW)\r\nreturn (-ENOSPC);\r\n}\r\nelse {\r\nif (osst_write_error_recovery(STp, aSRpnt, 1))\r\nreturn (-EIO);\r\n}\r\n}\r\nelse\r\nSTp->first_frame_position++;\r\n}\r\nSTp->write_count++;\r\nreturn 0;\r\n}\r\nstatic int do_door_lock(struct osst_tape * STp, int do_lock)\r\n{\r\nint retval, cmd;\r\ncmd = do_lock ? SCSI_IOCTL_DOORLOCK : SCSI_IOCTL_DOORUNLOCK;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: %socking drive door.\n", tape_name(STp), do_lock ? "L" : "Unl");\r\n#endif\r\nretval = scsi_ioctl(STp->device, cmd, NULL);\r\nif (!retval) {\r\nSTp->door_locked = do_lock ? ST_LOCKED_EXPLICIT : ST_UNLOCKED;\r\n}\r\nelse {\r\nSTp->door_locked = ST_LOCK_FAILS;\r\n}\r\nreturn retval;\r\n}\r\nstatic void reset_state(struct osst_tape *STp)\r\n{\r\nint i;\r\nstruct st_partstat *STps;\r\nSTp->pos_unknown = 0;\r\nfor (i = 0; i < ST_NBR_PARTITIONS; i++) {\r\nSTps = &(STp->ps[i]);\r\nSTps->rw = ST_IDLE;\r\nSTps->eof = ST_NOEOF;\r\nSTps->at_sm = 0;\r\nSTps->last_block_valid = 0;\r\nSTps->drv_block = -1;\r\nSTps->drv_file = -1;\r\n}\r\n}\r\nstatic ssize_t osst_write(struct file * filp, const char __user * buf, size_t count, loff_t *ppos)\r\n{\r\nssize_t total, retval = 0;\r\nssize_t i, do_count, blks, transfer;\r\nint write_threshold;\r\nint doing_write = 0;\r\nconst char __user * b_point;\r\nstruct osst_request * SRpnt = NULL;\r\nstruct st_modedef * STm;\r\nstruct st_partstat * STps;\r\nstruct osst_tape * STp = filp->private_data;\r\nchar * name = tape_name(STp);\r\nif (mutex_lock_interruptible(&STp->lock))\r\nreturn (-ERESTARTSYS);\r\nif( !scsi_block_when_processing_errors(STp->device) ) {\r\nretval = (-ENXIO);\r\ngoto out;\r\n}\r\nif (STp->ready != ST_READY) {\r\nif (STp->ready == ST_NO_TAPE)\r\nretval = (-ENOMEDIUM);\r\nelse\r\nretval = (-EIO);\r\ngoto out;\r\n}\r\nSTm = &(STp->modes[STp->current_mode]);\r\nif (!STm->defined) {\r\nretval = (-ENXIO);\r\ngoto out;\r\n}\r\nif (count == 0)\r\ngoto out;\r\nif (STp->pos_unknown) {\r\nretval = (-EIO);\r\ngoto out;\r\n}\r\n#if DEBUG\r\nif (!STp->in_use) {\r\nprintk(OSST_DEB_MSG "%s:D: Incorrect device.\n", name);\r\nretval = (-EIO);\r\ngoto out;\r\n}\r\n#endif\r\nif (STp->write_prot) {\r\nretval = (-EACCES);\r\ngoto out;\r\n}\r\nif (STp->block_size != 0 && (count % STp->block_size) != 0) {\r\nprintk(KERN_ERR "%s:E: Write (%Zd bytes) not multiple of tape block size (%d%c).\n",\r\nname, count, STp->block_size<1024?\r\nSTp->block_size:STp->block_size/1024, STp->block_size<1024?'b':'k');\r\nretval = (-EINVAL);\r\ngoto out;\r\n}\r\nif (STp->first_frame_position >= STp->capacity - OSST_EOM_RESERVE) {\r\nprintk(KERN_ERR "%s:E: Write truncated at EOM early warning (frame %d).\n",\r\nname, STp->first_frame_position);\r\nretval = (-ENOSPC);\r\ngoto out;\r\n}\r\nif (STp->do_auto_lock && STp->door_locked == ST_UNLOCKED && !do_door_lock(STp, 1))\r\nSTp->door_locked = ST_LOCKED_AUTO;\r\nSTps = &(STp->ps[STp->partition]);\r\nif (STps->rw == ST_READING) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Switching from read to write at file %d, block %d\n", name,\r\nSTps->drv_file, STps->drv_block);\r\n#endif\r\nretval = osst_flush_buffer(STp, &SRpnt, 0);\r\nif (retval)\r\ngoto out;\r\nSTps->rw = ST_IDLE;\r\n}\r\nif (STps->rw != ST_WRITING) {\r\nif (!STp->header_ok ||\r\n(STp->first_frame_position == STp->first_data_ppos && STps->drv_block < 0) ||\r\n(STps->drv_file == 0 && STps->drv_block == 0)) {\r\nSTp->wrt_pass_cntr++;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Allocating next write pass counter: %d\n",\r\nname, STp->wrt_pass_cntr);\r\n#endif\r\nosst_reset_header(STp, &SRpnt);\r\nSTps->drv_file = STps->drv_block = 0;\r\n}\r\nelse {\r\nif ((STp->fast_open && osst_verify_position(STp, &SRpnt)) ||\r\nSTps->drv_file < 0 || STps->drv_block < 0) {\r\nif (STp->first_frame_position == STp->eod_frame_ppos) {\r\nSTps->drv_file = STp->filemark_cnt;\r\nSTps->drv_block = 0;\r\n}\r\nelse {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG\r\n"%s:D: Cannot write at indeterminate position.\n", name);\r\n#endif\r\nretval = (-EIO);\r\ngoto out;\r\n}\r\n}\r\nif ((STps->drv_file + STps->drv_block) > 0 && STps->drv_file < STp->filemark_cnt) {\r\nSTp->filemark_cnt = STps->drv_file;\r\nSTp->last_mark_ppos =\r\nntohl(STp->header_cache->dat_fm_tab.fm_tab_ent[STp->filemark_cnt-1]);\r\nprintk(KERN_WARNING\r\n"%s:W: Overwriting file %d with old write pass counter %d\n",\r\nname, STps->drv_file, STp->wrt_pass_cntr);\r\nprintk(KERN_WARNING\r\n"%s:W: may lead to stale data being accepted on reading back!\n",\r\nname);\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG\r\n"%s:D: resetting filemark count to %d and last mark ppos,lbn to %d,%d\n",\r\nname, STp->filemark_cnt, STp->last_mark_ppos, STp->last_mark_lbn);\r\n#endif\r\n}\r\n}\r\nSTp->fast_open = 0;\r\n}\r\nif (!STp->header_ok) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Write cannot proceed without valid headers\n", name);\r\n#endif\r\nretval = (-EIO);\r\ngoto out;\r\n}\r\nif ((STp->buffer)->writing) {\r\nif (SRpnt) printk(KERN_ERR "%s:A: Not supposed to have SRpnt at line %d\n", name, __LINE__);\r\nosst_write_behind_check(STp);\r\nif ((STp->buffer)->syscall_result) {\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Async write error (write) %x.\n", name,\r\n(STp->buffer)->midlevel_result);\r\n#endif\r\nif ((STp->buffer)->midlevel_result == INT_MAX)\r\nSTps->eof = ST_EOM_OK;\r\nelse\r\nSTps->eof = ST_EOM_ERROR;\r\n}\r\n}\r\nif (STps->eof == ST_EOM_OK) {\r\nretval = (-ENOSPC);\r\ngoto out;\r\n}\r\nelse if (STps->eof == ST_EOM_ERROR) {\r\nretval = (-EIO);\r\ngoto out;\r\n}\r\nif ((copy_from_user(&i, buf, 1) != 0 ||\r\ncopy_from_user(&i, buf + count - 1, 1) != 0)) {\r\nretval = (-EFAULT);\r\ngoto out;\r\n}\r\nif (!STm->do_buffer_writes) {\r\nwrite_threshold = 1;\r\n}\r\nelse\r\nwrite_threshold = (STp->buffer)->buffer_blocks * STp->block_size;\r\nif (!STm->do_async_writes)\r\nwrite_threshold--;\r\ntotal = count;\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Writing %d bytes to file %d block %d lblk %d fseq %d fppos %d\n",\r\nname, (int) count, STps->drv_file, STps->drv_block,\r\nSTp->logical_blk_num, STp->frame_seq_number, STp->first_frame_position);\r\n#endif\r\nb_point = buf;\r\nwhile ((STp->buffer)->buffer_bytes + count > write_threshold)\r\n{\r\ndoing_write = 1;\r\ndo_count = (STp->buffer)->buffer_blocks * STp->block_size -\r\n(STp->buffer)->buffer_bytes;\r\nif (do_count > count)\r\ndo_count = count;\r\ni = append_to_buffer(b_point, STp->buffer, do_count);\r\nif (i) {\r\nretval = i;\r\ngoto out;\r\n}\r\nblks = do_count / STp->block_size;\r\nSTp->logical_blk_num += blks;\r\ni = osst_write_frame(STp, &SRpnt, 1);\r\nif (i == (-ENOSPC)) {\r\ntransfer = STp->buffer->writing;\r\nif (transfer <= do_count) {\r\n*ppos += do_count - transfer;\r\ncount -= do_count - transfer;\r\nif (STps->drv_block >= 0) {\r\nSTps->drv_block += (do_count - transfer) / STp->block_size;\r\n}\r\nSTps->eof = ST_EOM_OK;\r\nretval = (-ENOSPC);\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: EOM with %d bytes unwritten.\n",\r\nname, (int) transfer);\r\n#endif\r\n}\r\nelse {\r\nSTps->eof = ST_EOM_ERROR;\r\nSTps->drv_block = (-1);\r\nretval = (-EIO);\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: EOM with lost data.\n", name);\r\n#endif\r\n}\r\n}\r\nelse\r\nretval = i;\r\nif (retval < 0) {\r\nif (SRpnt != NULL) {\r\nosst_release_request(SRpnt);\r\nSRpnt = NULL;\r\n}\r\nSTp->buffer->buffer_bytes = 0;\r\nSTp->dirty = 0;\r\nif (count < total)\r\nretval = total - count;\r\ngoto out;\r\n}\r\n*ppos += do_count;\r\nb_point += do_count;\r\ncount -= do_count;\r\nif (STps->drv_block >= 0) {\r\nSTps->drv_block += blks;\r\n}\r\nSTp->buffer->buffer_bytes = 0;\r\nSTp->dirty = 0;\r\n}\r\nif (count != 0) {\r\nSTp->dirty = 1;\r\ni = append_to_buffer(b_point, STp->buffer, count);\r\nif (i) {\r\nretval = i;\r\ngoto out;\r\n}\r\nblks = count / STp->block_size;\r\nSTp->logical_blk_num += blks;\r\nif (STps->drv_block >= 0) {\r\nSTps->drv_block += blks;\r\n}\r\n*ppos += count;\r\ncount = 0;\r\n}\r\nif (doing_write && (STp->buffer)->syscall_result != 0) {\r\nretval = (STp->buffer)->syscall_result;\r\ngoto out;\r\n}\r\nif (STm->do_async_writes && ((STp->buffer)->buffer_bytes >= STp->write_threshold)) {\r\n(STp->buffer)->writing = ((STp->buffer)->buffer_bytes /\r\nSTp->block_size) * STp->block_size;\r\nSTp->dirty = !((STp->buffer)->writing ==\r\n(STp->buffer)->buffer_bytes);\r\ni = osst_write_frame(STp, &SRpnt, 0);\r\nif (i < 0) {\r\nretval = (-EIO);\r\ngoto out;\r\n}\r\nSRpnt = NULL;\r\n}\r\nSTps->at_sm &= (total == 0);\r\nif (total > 0)\r\nSTps->eof = ST_NOEOF;\r\nretval = total;\r\nout:\r\nif (SRpnt != NULL) osst_release_request(SRpnt);\r\nmutex_unlock(&STp->lock);\r\nreturn retval;\r\n}\r\nstatic ssize_t osst_read(struct file * filp, char __user * buf, size_t count, loff_t *ppos)\r\n{\r\nssize_t total, retval = 0;\r\nssize_t i, transfer;\r\nint special;\r\nstruct st_modedef * STm;\r\nstruct st_partstat * STps;\r\nstruct osst_request * SRpnt = NULL;\r\nstruct osst_tape * STp = filp->private_data;\r\nchar * name = tape_name(STp);\r\nif (mutex_lock_interruptible(&STp->lock))\r\nreturn (-ERESTARTSYS);\r\nif( !scsi_block_when_processing_errors(STp->device) ) {\r\nretval = (-ENXIO);\r\ngoto out;\r\n}\r\nif (STp->ready != ST_READY) {\r\nif (STp->ready == ST_NO_TAPE)\r\nretval = (-ENOMEDIUM);\r\nelse\r\nretval = (-EIO);\r\ngoto out;\r\n}\r\nSTm = &(STp->modes[STp->current_mode]);\r\nif (!STm->defined) {\r\nretval = (-ENXIO);\r\ngoto out;\r\n}\r\n#if DEBUG\r\nif (!STp->in_use) {\r\nprintk(OSST_DEB_MSG "%s:D: Incorrect device.\n", name);\r\nretval = (-EIO);\r\ngoto out;\r\n}\r\n#endif\r\nif (!STp->header_ok) {\r\nretval = (-EIO);\r\ngoto out;\r\n}\r\nif (STp->do_auto_lock && STp->door_locked == ST_UNLOCKED && !do_door_lock(STp, 1))\r\nSTp->door_locked = ST_LOCKED_AUTO;\r\nSTps = &(STp->ps[STp->partition]);\r\nif (STps->rw == ST_WRITING) {\r\nretval = osst_flush_buffer(STp, &SRpnt, 0);\r\nif (retval)\r\ngoto out;\r\nSTps->rw = ST_IDLE;\r\n}\r\nif ((count % STp->block_size) != 0) {\r\nprintk(KERN_WARNING\r\n"%s:W: Read (%Zd bytes) not multiple of tape block size (%d%c).\n", name, count,\r\nSTp->block_size<1024?STp->block_size:STp->block_size/1024, STp->block_size<1024?'b':'k');\r\n}\r\n#if DEBUG\r\nif (debugging && STps->eof != ST_NOEOF)\r\nprintk(OSST_DEB_MSG "%s:D: EOF/EOM flag up (%d). Bytes %d\n", name,\r\nSTps->eof, (STp->buffer)->buffer_bytes);\r\n#endif\r\nif ((STp->buffer)->buffer_bytes == 0 &&\r\nSTps->eof >= ST_EOD_1) {\r\nif (STps->eof < ST_EOD) {\r\nSTps->eof += 1;\r\nretval = 0;\r\ngoto out;\r\n}\r\nretval = (-EIO);\r\ngoto out;\r\n}\r\nif (copy_from_user(&i, buf, 1) != 0 ||\r\ncopy_to_user (buf, &i, 1) != 0 ||\r\ncopy_from_user(&i, buf + count - 1, 1) != 0 ||\r\ncopy_to_user (buf + count - 1, &i, 1) != 0) {\r\nretval = (-EFAULT);\r\ngoto out;\r\n}\r\nfor (total = 0, special = 0; total < count - STp->block_size + 1 && !special; ) {\r\nif ((STp->buffer)->buffer_bytes == 0) {\r\nif (STps->eof == ST_FM_HIT)\r\nbreak;\r\nspecial = osst_get_logical_frame(STp, &SRpnt, STp->frame_seq_number, 0);\r\nif (special < 0) {\r\nSTp->frame_in_buffer = 0;\r\nretval = special;\r\ngoto out;\r\n}\r\n}\r\nif ((STp->buffer)->buffer_bytes > 0) {\r\n#if DEBUG\r\nif (debugging && STps->eof != ST_NOEOF)\r\nprintk(OSST_DEB_MSG "%s:D: EOF up (%d). Left %d, needed %d.\n", name,\r\nSTps->eof, (STp->buffer)->buffer_bytes, (int) (count - total));\r\n#endif\r\ntransfer = (((STp->buffer)->buffer_bytes < count - total ?\r\n(STp->buffer)->buffer_bytes : count - total)/\r\nSTp->block_size) * STp->block_size;\r\nif (transfer == 0) {\r\nprintk(KERN_WARNING\r\n"%s:W: Nothing can be transferred, requested %Zd, tape block size (%d%c).\n",\r\nname, count, STp->block_size < 1024?\r\nSTp->block_size:STp->block_size/1024,\r\nSTp->block_size<1024?'b':'k');\r\nbreak;\r\n}\r\ni = from_buffer(STp->buffer, buf, transfer);\r\nif (i) {\r\nretval = i;\r\ngoto out;\r\n}\r\nSTp->logical_blk_num += transfer / STp->block_size;\r\nSTps->drv_block += transfer / STp->block_size;\r\n*ppos += transfer;\r\nbuf += transfer;\r\ntotal += transfer;\r\n}\r\nif ((STp->buffer)->buffer_bytes == 0) {\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Finished with frame %d\n",\r\nname, STp->frame_seq_number);\r\n#endif\r\nSTp->frame_in_buffer = 0;\r\nSTp->frame_seq_number++;\r\n}\r\n}\r\nif (total == 0) {\r\nif (STps->eof == ST_FM_HIT) {\r\nSTps->eof = (STp->first_frame_position >= STp->eod_frame_ppos)?ST_EOD_2:ST_FM;\r\nSTps->drv_block = 0;\r\nif (STps->drv_file >= 0)\r\nSTps->drv_file++;\r\n}\r\nelse if (STps->eof == ST_EOD_1) {\r\nSTps->eof = ST_EOD_2;\r\nif (STps->drv_block > 0 && STps->drv_file >= 0)\r\nSTps->drv_file++;\r\nSTps->drv_block = 0;\r\n}\r\nelse if (STps->eof == ST_EOD_2)\r\nSTps->eof = ST_EOD;\r\n}\r\nelse if (STps->eof == ST_FM)\r\nSTps->eof = ST_NOEOF;\r\nretval = total;\r\nout:\r\nif (SRpnt != NULL) osst_release_request(SRpnt);\r\nmutex_unlock(&STp->lock);\r\nreturn retval;\r\n}\r\nstatic void osst_log_options(struct osst_tape *STp, struct st_modedef *STm, char *name)\r\n{\r\nprintk(KERN_INFO\r\n"%s:I: Mode %d options: buffer writes: %d, async writes: %d, read ahead: %d\n",\r\nname, STp->current_mode, STm->do_buffer_writes, STm->do_async_writes,\r\nSTm->do_read_ahead);\r\nprintk(KERN_INFO\r\n"%s:I: can bsr: %d, two FMs: %d, fast mteom: %d, auto lock: %d,\n",\r\nname, STp->can_bsr, STp->two_fm, STp->fast_mteom, STp->do_auto_lock);\r\nprintk(KERN_INFO\r\n"%s:I: defs for wr: %d, no block limits: %d, partitions: %d, s2 log: %d\n",\r\nname, STm->defaults_for_writes, STp->omit_blklims, STp->can_partitions,\r\nSTp->scsi2_logical);\r\nprintk(KERN_INFO\r\n"%s:I: sysv: %d\n", name, STm->sysv);\r\n#if DEBUG\r\nprintk(KERN_INFO\r\n"%s:D: debugging: %d\n",\r\nname, debugging);\r\n#endif\r\n}\r\nstatic int osst_set_options(struct osst_tape *STp, long options)\r\n{\r\nint value;\r\nlong code;\r\nstruct st_modedef * STm;\r\nchar * name = tape_name(STp);\r\nSTm = &(STp->modes[STp->current_mode]);\r\nif (!STm->defined) {\r\nmemcpy(STm, &(STp->modes[0]), sizeof(*STm));\r\nmodes_defined = 1;\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Initialized mode %d definition from mode 0\n",\r\nname, STp->current_mode);\r\n#endif\r\n}\r\ncode = options & MT_ST_OPTIONS;\r\nif (code == MT_ST_BOOLEANS) {\r\nSTm->do_buffer_writes = (options & MT_ST_BUFFER_WRITES) != 0;\r\nSTm->do_async_writes = (options & MT_ST_ASYNC_WRITES) != 0;\r\nSTm->defaults_for_writes = (options & MT_ST_DEF_WRITES) != 0;\r\nSTm->do_read_ahead = (options & MT_ST_READ_AHEAD) != 0;\r\nSTp->two_fm = (options & MT_ST_TWO_FM) != 0;\r\nSTp->fast_mteom = (options & MT_ST_FAST_MTEOM) != 0;\r\nSTp->do_auto_lock = (options & MT_ST_AUTO_LOCK) != 0;\r\nSTp->can_bsr = (options & MT_ST_CAN_BSR) != 0;\r\nSTp->omit_blklims = (options & MT_ST_NO_BLKLIMS) != 0;\r\nif ((STp->device)->scsi_level >= SCSI_2)\r\nSTp->can_partitions = (options & MT_ST_CAN_PARTITIONS) != 0;\r\nSTp->scsi2_logical = (options & MT_ST_SCSI2LOGICAL) != 0;\r\nSTm->sysv = (options & MT_ST_SYSV) != 0;\r\n#if DEBUG\r\ndebugging = (options & MT_ST_DEBUGGING) != 0;\r\n#endif\r\nosst_log_options(STp, STm, name);\r\n}\r\nelse if (code == MT_ST_SETBOOLEANS || code == MT_ST_CLEARBOOLEANS) {\r\nvalue = (code == MT_ST_SETBOOLEANS);\r\nif ((options & MT_ST_BUFFER_WRITES) != 0)\r\nSTm->do_buffer_writes = value;\r\nif ((options & MT_ST_ASYNC_WRITES) != 0)\r\nSTm->do_async_writes = value;\r\nif ((options & MT_ST_DEF_WRITES) != 0)\r\nSTm->defaults_for_writes = value;\r\nif ((options & MT_ST_READ_AHEAD) != 0)\r\nSTm->do_read_ahead = value;\r\nif ((options & MT_ST_TWO_FM) != 0)\r\nSTp->two_fm = value;\r\nif ((options & MT_ST_FAST_MTEOM) != 0)\r\nSTp->fast_mteom = value;\r\nif ((options & MT_ST_AUTO_LOCK) != 0)\r\nSTp->do_auto_lock = value;\r\nif ((options & MT_ST_CAN_BSR) != 0)\r\nSTp->can_bsr = value;\r\nif ((options & MT_ST_NO_BLKLIMS) != 0)\r\nSTp->omit_blklims = value;\r\nif ((STp->device)->scsi_level >= SCSI_2 &&\r\n(options & MT_ST_CAN_PARTITIONS) != 0)\r\nSTp->can_partitions = value;\r\nif ((options & MT_ST_SCSI2LOGICAL) != 0)\r\nSTp->scsi2_logical = value;\r\nif ((options & MT_ST_SYSV) != 0)\r\nSTm->sysv = value;\r\n#if DEBUG\r\nif ((options & MT_ST_DEBUGGING) != 0)\r\ndebugging = value;\r\n#endif\r\nosst_log_options(STp, STm, name);\r\n}\r\nelse if (code == MT_ST_WRITE_THRESHOLD) {\r\nvalue = (options & ~MT_ST_OPTIONS) * ST_KILOBYTE;\r\nif (value < 1 || value > osst_buffer_size) {\r\nprintk(KERN_WARNING "%s:W: Write threshold %d too small or too large.\n",\r\nname, value);\r\nreturn (-EIO);\r\n}\r\nSTp->write_threshold = value;\r\nprintk(KERN_INFO "%s:I: Write threshold set to %d bytes.\n",\r\nname, value);\r\n}\r\nelse if (code == MT_ST_DEF_BLKSIZE) {\r\nvalue = (options & ~MT_ST_OPTIONS);\r\nif (value == ~MT_ST_OPTIONS) {\r\nSTm->default_blksize = (-1);\r\nprintk(KERN_INFO "%s:I: Default block size disabled.\n", name);\r\n}\r\nelse {\r\nif (value < 512 || value > OS_DATA_SIZE || OS_DATA_SIZE % value) {\r\nprintk(KERN_WARNING "%s:W: Default block size cannot be set to %d.\n",\r\nname, value);\r\nreturn (-EINVAL);\r\n}\r\nSTm->default_blksize = value;\r\nprintk(KERN_INFO "%s:I: Default block size set to %d bytes.\n",\r\nname, STm->default_blksize);\r\n}\r\n}\r\nelse if (code == MT_ST_TIMEOUTS) {\r\nvalue = (options & ~MT_ST_OPTIONS);\r\nif ((value & MT_ST_SET_LONG_TIMEOUT) != 0) {\r\nSTp->long_timeout = (value & ~MT_ST_SET_LONG_TIMEOUT) * HZ;\r\nprintk(KERN_INFO "%s:I: Long timeout set to %d seconds.\n", name,\r\n(value & ~MT_ST_SET_LONG_TIMEOUT));\r\n}\r\nelse {\r\nSTp->timeout = value * HZ;\r\nprintk(KERN_INFO "%s:I: Normal timeout set to %d seconds.\n", name, value);\r\n}\r\n}\r\nelse if (code == MT_ST_DEF_OPTIONS) {\r\ncode = (options & ~MT_ST_CLEAR_DEFAULT);\r\nvalue = (options & MT_ST_CLEAR_DEFAULT);\r\nif (code == MT_ST_DEF_DENSITY) {\r\nif (value == MT_ST_CLEAR_DEFAULT) {\r\nSTm->default_density = (-1);\r\nprintk(KERN_INFO "%s:I: Density default disabled.\n", name);\r\n}\r\nelse {\r\nSTm->default_density = value & 0xff;\r\nprintk(KERN_INFO "%s:I: Density default set to %x\n",\r\nname, STm->default_density);\r\n}\r\n}\r\nelse if (code == MT_ST_DEF_DRVBUFFER) {\r\nif (value == MT_ST_CLEAR_DEFAULT) {\r\nSTp->default_drvbuffer = 0xff;\r\nprintk(KERN_INFO "%s:I: Drive buffer default disabled.\n", name);\r\n}\r\nelse {\r\nSTp->default_drvbuffer = value & 7;\r\nprintk(KERN_INFO "%s:I: Drive buffer default set to %x\n",\r\nname, STp->default_drvbuffer);\r\n}\r\n}\r\nelse if (code == MT_ST_DEF_COMPRESSION) {\r\nif (value == MT_ST_CLEAR_DEFAULT) {\r\nSTm->default_compression = ST_DONT_TOUCH;\r\nprintk(KERN_INFO "%s:I: Compression default disabled.\n", name);\r\n}\r\nelse {\r\nSTm->default_compression = (value & 1 ? ST_YES : ST_NO);\r\nprintk(KERN_INFO "%s:I: Compression default set to %x\n",\r\nname, (value & 1));\r\n}\r\n}\r\n}\r\nelse\r\nreturn (-EIO);\r\nreturn 0;\r\n}\r\nstatic int osst_int_ioctl(struct osst_tape * STp, struct osst_request ** aSRpnt,\r\nunsigned int cmd_in, unsigned long arg)\r\n{\r\nint timeout;\r\nlong ltmp;\r\nint i, ioctl_result;\r\nint chg_eof = 1;\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nstruct osst_request * SRpnt = * aSRpnt;\r\nstruct st_partstat * STps;\r\nint fileno, blkno, at_sm, frame_seq_numbr, logical_blk_num;\r\nint datalen = 0, direction = DMA_NONE;\r\nchar * name = tape_name(STp);\r\nif (STp->ready != ST_READY && cmd_in != MTLOAD) {\r\nif (STp->ready == ST_NO_TAPE)\r\nreturn (-ENOMEDIUM);\r\nelse\r\nreturn (-EIO);\r\n}\r\ntimeout = STp->long_timeout;\r\nSTps = &(STp->ps[STp->partition]);\r\nfileno = STps->drv_file;\r\nblkno = STps->drv_block;\r\nat_sm = STps->at_sm;\r\nframe_seq_numbr = STp->frame_seq_number;\r\nlogical_blk_num = STp->logical_blk_num;\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\nswitch (cmd_in) {\r\ncase MTFSFM:\r\nchg_eof = 0;\r\ncase MTFSF:\r\nif (STp->raw)\r\nreturn (-EIO);\r\nif (STp->linux_media)\r\nioctl_result = osst_space_over_filemarks_forward_fast(STp, &SRpnt, cmd_in, arg);\r\nelse\r\nioctl_result = osst_space_over_filemarks_forward_slow(STp, &SRpnt, cmd_in, arg);\r\nif (fileno >= 0)\r\nfileno += arg;\r\nblkno = 0;\r\nat_sm &= (arg == 0);\r\ngoto os_bypass;\r\ncase MTBSF:\r\nchg_eof = 0;\r\ncase MTBSFM:\r\nif (STp->raw)\r\nreturn (-EIO);\r\nioctl_result = osst_space_over_filemarks_backward(STp, &SRpnt, cmd_in, arg);\r\nif (fileno >= 0)\r\nfileno -= arg;\r\nblkno = (-1);\r\nat_sm &= (arg == 0);\r\ngoto os_bypass;\r\ncase MTFSR:\r\ncase MTBSR:\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Skipping %lu blocks %s from logical block %d\n",\r\nname, arg, cmd_in==MTFSR?"forward":"backward", logical_blk_num);\r\n#endif\r\nif (cmd_in == MTFSR) {\r\nlogical_blk_num += arg;\r\nif (blkno >= 0) blkno += arg;\r\n}\r\nelse {\r\nlogical_blk_num -= arg;\r\nif (blkno >= 0) blkno -= arg;\r\n}\r\nioctl_result = osst_seek_logical_blk(STp, &SRpnt, logical_blk_num);\r\nfileno = STps->drv_file;\r\nblkno = STps->drv_block;\r\nat_sm &= (arg == 0);\r\ngoto os_bypass;\r\ncase MTFSS:\r\ncmd[0] = SPACE;\r\ncmd[1] = 0x04;\r\ncmd[2] = (arg >> 16);\r\ncmd[3] = (arg >> 8);\r\ncmd[4] = arg;\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Spacing tape forward %d setmarks.\n", name,\r\ncmd[2] * 65536 + cmd[3] * 256 + cmd[4]);\r\n#endif\r\nif (arg != 0) {\r\nblkno = fileno = (-1);\r\nat_sm = 1;\r\n}\r\nbreak;\r\ncase MTBSS:\r\ncmd[0] = SPACE;\r\ncmd[1] = 0x04;\r\nltmp = (-arg);\r\ncmd[2] = (ltmp >> 16);\r\ncmd[3] = (ltmp >> 8);\r\ncmd[4] = ltmp;\r\n#if DEBUG\r\nif (debugging) {\r\nif (cmd[2] & 0x80)\r\nltmp = 0xff000000;\r\nltmp = ltmp | (cmd[2] << 16) | (cmd[3] << 8) | cmd[4];\r\nprintk(OSST_DEB_MSG "%s:D: Spacing tape backward %ld setmarks.\n",\r\nname, (-ltmp));\r\n}\r\n#endif\r\nif (arg != 0) {\r\nblkno = fileno = (-1);\r\nat_sm = 1;\r\n}\r\nbreak;\r\ncase MTWEOF:\r\nif ((STps->rw == ST_WRITING || STp->dirty) && !STp->pos_unknown) {\r\nSTp->write_type = OS_WRITE_DATA;\r\nioctl_result = osst_flush_write_buffer(STp, &SRpnt);\r\n} else\r\nioctl_result = 0;\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Writing %ld filemark(s).\n", name, arg);\r\n#endif\r\nfor (i=0; i<arg; i++)\r\nioctl_result |= osst_write_filemark(STp, &SRpnt);\r\nif (fileno >= 0) fileno += arg;\r\nif (blkno >= 0) blkno = 0;\r\ngoto os_bypass;\r\ncase MTWSM:\r\nif (STp->write_prot)\r\nreturn (-EACCES);\r\nif (!STp->raw)\r\nreturn 0;\r\ncmd[0] = WRITE_FILEMARKS;\r\nif (cmd_in == MTWSM)\r\ncmd[1] = 2;\r\ncmd[2] = (arg >> 16);\r\ncmd[3] = (arg >> 8);\r\ncmd[4] = arg;\r\ntimeout = STp->timeout;\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Writing %d setmark(s).\n", name,\r\ncmd[2] * 65536 + cmd[3] * 256 + cmd[4]);\r\n#endif\r\nif (fileno >= 0)\r\nfileno += arg;\r\nblkno = 0;\r\nat_sm = (cmd_in == MTWSM);\r\nbreak;\r\ncase MTOFFL:\r\ncase MTLOAD:\r\ncase MTUNLOAD:\r\ncase MTRETEN:\r\ncmd[0] = START_STOP;\r\ncmd[1] = 1;\r\nif (cmd_in == MTLOAD) {\r\nif (STp->ready == ST_NO_TAPE)\r\ncmd[4] = 4;\r\nelse\r\ncmd[4] = 1;\r\n}\r\nif (cmd_in == MTRETEN)\r\ncmd[4] = 3;\r\nif (cmd_in == MTOFFL)\r\ncmd[4] = 4;\r\ntimeout = STp->timeout;\r\n#if DEBUG\r\nif (debugging) {\r\nswitch (cmd_in) {\r\ncase MTUNLOAD:\r\nprintk(OSST_DEB_MSG "%s:D: Unloading tape.\n", name);\r\nbreak;\r\ncase MTLOAD:\r\nprintk(OSST_DEB_MSG "%s:D: Loading tape.\n", name);\r\nbreak;\r\ncase MTRETEN:\r\nprintk(OSST_DEB_MSG "%s:D: Retensioning tape.\n", name);\r\nbreak;\r\ncase MTOFFL:\r\nprintk(OSST_DEB_MSG "%s:D: Ejecting tape.\n", name);\r\nbreak;\r\n}\r\n}\r\n#endif\r\nfileno = blkno = at_sm = frame_seq_numbr = logical_blk_num = 0 ;\r\nbreak;\r\ncase MTNOP:\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: No-op on tape.\n", name);\r\n#endif\r\nreturn 0;\r\nbreak;\r\ncase MTEOM:\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Spacing to end of recorded medium.\n", name);\r\n#endif\r\nif ((osst_position_tape_and_confirm(STp, &SRpnt, STp->eod_frame_ppos) < 0) ||\r\n(osst_get_logical_frame(STp, &SRpnt, -1, 0) < 0)) {\r\nioctl_result = -EIO;\r\ngoto os_bypass;\r\n}\r\nif (STp->buffer->aux->frame_type != OS_FRAME_TYPE_EOD) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: No EOD frame found where expected.\n", name);\r\n#endif\r\nioctl_result = -EIO;\r\ngoto os_bypass;\r\n}\r\nioctl_result = osst_set_frame_position(STp, &SRpnt, STp->eod_frame_ppos, 0);\r\nfileno = STp->filemark_cnt;\r\nblkno = at_sm = 0;\r\ngoto os_bypass;\r\ncase MTERASE:\r\nif (STp->write_prot)\r\nreturn (-EACCES);\r\nioctl_result = osst_reset_header(STp, &SRpnt);\r\ni = osst_write_eod(STp, &SRpnt);\r\nif (i < ioctl_result) ioctl_result = i;\r\ni = osst_position_tape_and_confirm(STp, &SRpnt, STp->eod_frame_ppos);\r\nif (i < ioctl_result) ioctl_result = i;\r\nfileno = blkno = at_sm = 0 ;\r\ngoto os_bypass;\r\ncase MTREW:\r\ncmd[0] = REZERO_UNIT;\r\ncmd[1] = 1;\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Rewinding tape, Immed=%d.\n", name, cmd[1]);\r\n#endif\r\nfileno = blkno = at_sm = frame_seq_numbr = logical_blk_num = 0 ;\r\nbreak;\r\ncase MTSETBLK:\r\nif ((STps->drv_block == 0 ) &&\r\n!STp->dirty &&\r\n((STp->buffer)->buffer_bytes == 0) &&\r\n((arg & MT_ST_BLKSIZE_MASK) >= 512 ) &&\r\n((arg & MT_ST_BLKSIZE_MASK) <= OS_DATA_SIZE) &&\r\n!(OS_DATA_SIZE % (arg & MT_ST_BLKSIZE_MASK)) ) {\r\nSTp->block_size = (arg & MT_ST_BLKSIZE_MASK);\r\nprintk(KERN_INFO "%s:I: Block size set to %d bytes.\n",\r\nname, STp->block_size);\r\nreturn 0;\r\n}\r\ncase MTSETDENSITY:\r\ncase MTSETDRVBUFFER:\r\ncase SET_DENS_AND_BLK:\r\nchg_eof = 0;\r\nif (STp->dirty || (STp->buffer)->buffer_bytes != 0)\r\nreturn (-EIO);\r\nif ((cmd_in == MTSETBLK || cmd_in == SET_DENS_AND_BLK) &&\r\n(arg & MT_ST_BLKSIZE_MASK) != 0 &&\r\n(arg & MT_ST_BLKSIZE_MASK) != STp->block_size ) {\r\nprintk(KERN_WARNING "%s:W: Illegal to set block size to %d%s.\n",\r\nname, (int)(arg & MT_ST_BLKSIZE_MASK),\r\n(OS_DATA_SIZE % (arg & MT_ST_BLKSIZE_MASK))?"":" now");\r\nreturn (-EINVAL);\r\n}\r\nreturn 0;\r\ndefault:\r\nreturn (-ENOSYS);\r\n}\r\nSRpnt = osst_do_scsi(SRpnt, STp, cmd, datalen, direction, timeout, MAX_RETRIES, 1);\r\nioctl_result = (STp->buffer)->syscall_result;\r\nif (!SRpnt) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Couldn't exec scsi cmd for IOCTL\n", name);\r\n#endif\r\nreturn ioctl_result;\r\n}\r\nif (!ioctl_result) {\r\nSTp->frame_seq_number = frame_seq_numbr;\r\nSTp->logical_blk_num = logical_blk_num;\r\n}\r\nos_bypass:\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: IOCTL (%d) Result=%d\n", name, cmd_in, ioctl_result);\r\n#endif\r\nif (!ioctl_result) {\r\nif (cmd_in == MTFSFM) {\r\nfileno--;\r\nblkno--;\r\n}\r\nif (cmd_in == MTBSFM) {\r\nfileno++;\r\nblkno++;\r\n}\r\nSTps->drv_block = blkno;\r\nSTps->drv_file = fileno;\r\nSTps->at_sm = at_sm;\r\nif (cmd_in == MTEOM)\r\nSTps->eof = ST_EOD;\r\nelse if ((cmd_in == MTFSFM || cmd_in == MTBSF) && STps->eof == ST_FM_HIT) {\r\nioctl_result = osst_seek_logical_blk(STp, &SRpnt, STp->logical_blk_num-1);\r\nSTps->drv_block++;\r\nSTp->logical_blk_num++;\r\nSTp->frame_seq_number++;\r\nSTp->frame_in_buffer = 0;\r\nSTp->buffer->read_pointer = 0;\r\n}\r\nelse if (cmd_in == MTFSF)\r\nSTps->eof = (STp->first_frame_position >= STp->eod_frame_ppos)?ST_EOD:ST_FM;\r\nelse if (chg_eof)\r\nSTps->eof = ST_NOEOF;\r\nif (cmd_in == MTOFFL || cmd_in == MTUNLOAD)\r\nSTp->rew_at_close = 0;\r\nelse if (cmd_in == MTLOAD) {\r\nfor (i=0; i < ST_NBR_PARTITIONS; i++) {\r\nSTp->ps[i].rw = ST_IDLE;\r\nSTp->ps[i].last_block_valid = 0;\r\n}\r\nSTp->partition = 0;\r\n}\r\nif (cmd_in == MTREW) {\r\nioctl_result = osst_position_tape_and_confirm(STp, &SRpnt, STp->first_data_ppos);\r\nif (ioctl_result > 0)\r\nioctl_result = 0;\r\n}\r\n} else if (cmd_in == MTBSF || cmd_in == MTBSFM ) {\r\nif (osst_position_tape_and_confirm(STp, &SRpnt, STp->first_data_ppos) < 0)\r\nSTps->drv_file = STps->drv_block = -1;\r\nelse\r\nSTps->drv_file = STps->drv_block = 0;\r\nSTps->eof = ST_NOEOF;\r\n} else if (cmd_in == MTFSF || cmd_in == MTFSFM) {\r\nif (osst_position_tape_and_confirm(STp, &SRpnt, STp->eod_frame_ppos) < 0)\r\nSTps->drv_file = STps->drv_block = -1;\r\nelse {\r\nSTps->drv_file = STp->filemark_cnt;\r\nSTps->drv_block = 0;\r\n}\r\nSTps->eof = ST_EOD;\r\n} else if (cmd_in == MTBSR || cmd_in == MTFSR || cmd_in == MTWEOF || cmd_in == MTEOM) {\r\nSTps->drv_file = STps->drv_block = (-1);\r\nSTps->eof = ST_NOEOF;\r\nSTp->header_ok = 0;\r\n} else if (cmd_in == MTERASE) {\r\nSTp->header_ok = 0;\r\n} else if (SRpnt) {\r\nif (SRpnt->sense[2] & 0x40) {\r\nSTps->eof = ST_EOM_OK;\r\nSTps->drv_block = 0;\r\n}\r\nif (chg_eof)\r\nSTps->eof = ST_NOEOF;\r\nif ((SRpnt->sense[2] & 0x0f) == BLANK_CHECK)\r\nSTps->eof = ST_EOD;\r\nif (cmd_in == MTLOAD && osst_wait_for_medium(STp, &SRpnt, 60))\r\nioctl_result = osst_wait_ready(STp, &SRpnt, 5 * 60, OSST_WAIT_POSITION_COMPLETE);\r\n}\r\n*aSRpnt = SRpnt;\r\nreturn ioctl_result;\r\n}\r\nstatic int __os_scsi_tape_open(struct inode * inode, struct file * filp)\r\n{\r\nunsigned short flags;\r\nint i, b_size, new_session = 0, retval = 0;\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nstruct osst_request * SRpnt = NULL;\r\nstruct osst_tape * STp;\r\nstruct st_modedef * STm;\r\nstruct st_partstat * STps;\r\nchar * name;\r\nint dev = TAPE_NR(inode);\r\nint mode = TAPE_MODE(inode);\r\nfilp->f_mode &= ~(FMODE_PREAD | FMODE_PWRITE);\r\nwrite_lock(&os_scsi_tapes_lock);\r\nif (dev >= osst_max_dev || os_scsi_tapes == NULL ||\r\n(STp = os_scsi_tapes[dev]) == NULL || !STp->device) {\r\nwrite_unlock(&os_scsi_tapes_lock);\r\nreturn (-ENXIO);\r\n}\r\nname = tape_name(STp);\r\nif (STp->in_use) {\r\nwrite_unlock(&os_scsi_tapes_lock);\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Device already in use.\n", name);\r\n#endif\r\nreturn (-EBUSY);\r\n}\r\nif (scsi_device_get(STp->device)) {\r\nwrite_unlock(&os_scsi_tapes_lock);\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Failed scsi_device_get.\n", name);\r\n#endif\r\nreturn (-ENXIO);\r\n}\r\nfilp->private_data = STp;\r\nSTp->in_use = 1;\r\nwrite_unlock(&os_scsi_tapes_lock);\r\nSTp->rew_at_close = TAPE_REWIND(inode);\r\nif( !scsi_block_when_processing_errors(STp->device) ) {\r\nreturn -ENXIO;\r\n}\r\nif (mode != STp->current_mode) {\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Mode change from %d to %d.\n",\r\nname, STp->current_mode, mode);\r\n#endif\r\nnew_session = 1;\r\nSTp->current_mode = mode;\r\n}\r\nSTm = &(STp->modes[STp->current_mode]);\r\nflags = filp->f_flags;\r\nSTp->write_prot = ((flags & O_ACCMODE) == O_RDONLY);\r\nSTp->raw = TAPE_IS_RAW(inode);\r\nif (STp->raw)\r\nSTp->header_ok = 0;\r\nif (!enlarge_buffer(STp->buffer, STp->restr_dma)) {\r\nprintk(KERN_ERR "%s:E: Unable to allocate memory segments for tape buffer.\n", name);\r\nretval = (-EOVERFLOW);\r\ngoto err_out;\r\n}\r\nif (STp->buffer->buffer_size >= OS_FRAME_SIZE) {\r\nfor (i = 0, b_size = 0;\r\n(i < STp->buffer->sg_segs) && ((b_size + STp->buffer->sg[i].length) <= OS_DATA_SIZE);\r\nb_size += STp->buffer->sg[i++].length);\r\nSTp->buffer->aux = (os_aux_t *) (page_address(sg_page(&STp->buffer->sg[i])) + OS_DATA_SIZE - b_size);\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: b_data points to %p in segment 0 at %p\n", name,\r\nSTp->buffer->b_data, page_address(STp->buffer->sg[0].page));\r\nprintk(OSST_DEB_MSG "%s:D: AUX points to %p in segment %d at %p\n", name,\r\nSTp->buffer->aux, i, page_address(STp->buffer->sg[i].page));\r\n#endif\r\n} else {\r\nSTp->buffer->aux = NULL;\r\nprintk(KERN_NOTICE "%s:A: Framesize %d too large for buffer.\n", name, OS_FRAME_SIZE);\r\nretval = (-EIO);\r\ngoto err_out;\r\n}\r\nSTp->buffer->writing = 0;\r\nSTp->buffer->syscall_result = 0;\r\nSTp->dirty = 0;\r\nfor (i=0; i < ST_NBR_PARTITIONS; i++) {\r\nSTps = &(STp->ps[i]);\r\nSTps->rw = ST_IDLE;\r\n}\r\nSTp->ready = ST_READY;\r\n#if DEBUG\r\nSTp->nbr_waits = STp->nbr_finished = 0;\r\n#endif\r\nmemset (cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = TEST_UNIT_READY;\r\nSRpnt = osst_do_scsi(NULL, STp, cmd, 0, DMA_NONE, STp->timeout, MAX_RETRIES, 1);\r\nif (!SRpnt) {\r\nretval = (STp->buffer)->syscall_result;\r\ngoto err_out;\r\n}\r\nif ((SRpnt->sense[0] & 0x70) == 0x70 &&\r\n(SRpnt->sense[2] & 0x0f) == NOT_READY &&\r\nSRpnt->sense[12] == 4 ) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Unit not ready, cause %x\n", name, SRpnt->sense[13]);\r\n#endif\r\nif (filp->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\ngoto err_out;\r\n}\r\nif (SRpnt->sense[13] == 2) {\r\nmemset (cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = START_STOP;\r\ncmd[1] = 1;\r\ncmd[4] = 1;\r\nSRpnt = osst_do_scsi(SRpnt, STp, cmd, 0, DMA_NONE,\r\nSTp->timeout, MAX_RETRIES, 1);\r\n}\r\nosst_wait_ready(STp, &SRpnt, (SRpnt->sense[13]==1?15:3) * 60, 0);\r\n}\r\nif ((SRpnt->sense[0] & 0x70) == 0x70 &&\r\n(SRpnt->sense[2] & 0x0f) == UNIT_ATTENTION) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Unit wants attention\n", name);\r\n#endif\r\nSTp->header_ok = 0;\r\nfor (i=0; i < 10; i++) {\r\nmemset (cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = TEST_UNIT_READY;\r\nSRpnt = osst_do_scsi(SRpnt, STp, cmd, 0, DMA_NONE,\r\nSTp->timeout, MAX_RETRIES, 1);\r\nif ((SRpnt->sense[0] & 0x70) != 0x70 ||\r\n(SRpnt->sense[2] & 0x0f) != UNIT_ATTENTION)\r\nbreak;\r\n}\r\nSTp->pos_unknown = 0;\r\nSTp->partition = STp->new_partition = 0;\r\nif (STp->can_partitions)\r\nSTp->nbr_partitions = 1;\r\nfor (i=0; i < ST_NBR_PARTITIONS; i++) {\r\nSTps = &(STp->ps[i]);\r\nSTps->rw = ST_IDLE;\r\nSTps->eof = ST_NOEOF;\r\nSTps->at_sm = 0;\r\nSTps->last_block_valid = 0;\r\nSTps->drv_block = 0;\r\nSTps->drv_file = 0 ;\r\n}\r\nnew_session = 1;\r\nSTp->recover_count = 0;\r\nSTp->abort_count = 0;\r\n}\r\nif (!STp->buffer->syscall_result && STp->header_ok &&\r\n!SRpnt->result && SRpnt->sense[0] == 0) {\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = MODE_SENSE;\r\ncmd[1] = 8;\r\ncmd[2] = VENDOR_IDENT_PAGE;\r\ncmd[4] = VENDOR_IDENT_PAGE_LENGTH + MODE_HEADER_LENGTH;\r\nSRpnt = osst_do_scsi(SRpnt, STp, cmd, cmd[4], DMA_FROM_DEVICE, STp->timeout, 0, 1);\r\nif (STp->buffer->syscall_result ||\r\nSTp->buffer->b_data[MODE_HEADER_LENGTH + 2] != 'L' ||\r\nSTp->buffer->b_data[MODE_HEADER_LENGTH + 3] != 'I' ||\r\nSTp->buffer->b_data[MODE_HEADER_LENGTH + 4] != 'N' ||\r\nSTp->buffer->b_data[MODE_HEADER_LENGTH + 5] != '4' ) {\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Signature was changed to %c%c%c%c\n", name,\r\nSTp->buffer->b_data[MODE_HEADER_LENGTH + 2],\r\nSTp->buffer->b_data[MODE_HEADER_LENGTH + 3],\r\nSTp->buffer->b_data[MODE_HEADER_LENGTH + 4],\r\nSTp->buffer->b_data[MODE_HEADER_LENGTH + 5]);\r\n#endif\r\nSTp->header_ok = 0;\r\n}\r\ni = STp->first_frame_position;\r\nif (STp->header_ok && i == osst_get_frame_position(STp, &SRpnt)) {\r\nif (STp->door_locked == ST_UNLOCKED) {\r\nif (do_door_lock(STp, 1))\r\nprintk(KERN_INFO "%s:I: Can't lock drive door\n", name);\r\nelse\r\nSTp->door_locked = ST_LOCKED_AUTO;\r\n}\r\nif (!STp->frame_in_buffer) {\r\nSTp->block_size = (STm->default_blksize > 0) ?\r\nSTm->default_blksize : OS_DATA_SIZE;\r\nSTp->buffer->buffer_bytes = STp->buffer->read_pointer = 0;\r\n}\r\nSTp->buffer->buffer_blocks = OS_DATA_SIZE / STp->block_size;\r\nSTp->fast_open = 1;\r\nosst_release_request(SRpnt);\r\nreturn 0;\r\n}\r\n#if DEBUG\r\nif (i != STp->first_frame_position)\r\nprintk(OSST_DEB_MSG "%s:D: Tape position changed from %d to %d\n",\r\nname, i, STp->first_frame_position);\r\n#endif\r\nSTp->header_ok = 0;\r\n}\r\nSTp->fast_open = 0;\r\nif ((STp->buffer)->syscall_result != 0 &&\r\n(SRpnt->sense[2] != 2 || SRpnt->sense[12] != 0x3A) ) {\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = MODE_SELECT;\r\ncmd[1] = 0x10;\r\ncmd[4] = 4 + MODE_HEADER_LENGTH;\r\n(STp->buffer)->b_data[0] = cmd[4] - 1;\r\n(STp->buffer)->b_data[1] = 0;\r\n(STp->buffer)->b_data[2] = 0;\r\n(STp->buffer)->b_data[3] = 0;\r\n(STp->buffer)->b_data[MODE_HEADER_LENGTH + 0] = 0x3f;\r\n(STp->buffer)->b_data[MODE_HEADER_LENGTH + 1] = 1;\r\n(STp->buffer)->b_data[MODE_HEADER_LENGTH + 2] = 2;\r\n(STp->buffer)->b_data[MODE_HEADER_LENGTH + 3] = 3;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Applying soft reset\n", name);\r\n#endif\r\nSRpnt = osst_do_scsi(SRpnt, STp, cmd, cmd[4], DMA_TO_DEVICE, STp->timeout, 0, 1);\r\nSTp->header_ok = 0;\r\nfor (i=0; i < 10; i++) {\r\nmemset (cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = TEST_UNIT_READY;\r\nSRpnt = osst_do_scsi(SRpnt, STp, cmd, 0, DMA_NONE,\r\nSTp->timeout, MAX_RETRIES, 1);\r\nif ((SRpnt->sense[0] & 0x70) != 0x70 ||\r\n(SRpnt->sense[2] & 0x0f) == NOT_READY)\r\nbreak;\r\nif ((SRpnt->sense[2] & 0x0f) == UNIT_ATTENTION) {\r\nint j;\r\nSTp->pos_unknown = 0;\r\nSTp->partition = STp->new_partition = 0;\r\nif (STp->can_partitions)\r\nSTp->nbr_partitions = 1;\r\nfor (j = 0; j < ST_NBR_PARTITIONS; j++) {\r\nSTps = &(STp->ps[j]);\r\nSTps->rw = ST_IDLE;\r\nSTps->eof = ST_NOEOF;\r\nSTps->at_sm = 0;\r\nSTps->last_block_valid = 0;\r\nSTps->drv_block = 0;\r\nSTps->drv_file = 0 ;\r\n}\r\nnew_session = 1;\r\n}\r\n}\r\n}\r\nif (osst_wait_ready(STp, &SRpnt, 15 * 60, 0))\r\nprintk(KERN_INFO "%s:I: Device did not become Ready in open\n", name);\r\nif ((STp->buffer)->syscall_result != 0) {\r\nif ((STp->device)->scsi_level >= SCSI_2 &&\r\n(SRpnt->sense[0] & 0x70) == 0x70 &&\r\n(SRpnt->sense[2] & 0x0f) == NOT_READY &&\r\nSRpnt->sense[12] == 0x3a) {\r\nSTp->ready = ST_NO_TAPE;\r\n} else\r\nSTp->ready = ST_NOT_READY;\r\nosst_release_request(SRpnt);\r\nSRpnt = NULL;\r\nSTp->density = 0;\r\nSTp->write_prot = 0;\r\nSTp->block_size = 0;\r\nSTp->ps[0].drv_file = STp->ps[0].drv_block = (-1);\r\nSTp->partition = STp->new_partition = 0;\r\nSTp->door_locked = ST_UNLOCKED;\r\nreturn 0;\r\n}\r\nosst_configure_onstream(STp, &SRpnt);\r\nSTp->block_size = STp->raw ? OS_FRAME_SIZE : (\r\n(STm->default_blksize > 0) ? STm->default_blksize : OS_DATA_SIZE);\r\nSTp->buffer->buffer_blocks = STp->raw ? 1 : OS_DATA_SIZE / STp->block_size;\r\nSTp->buffer->buffer_bytes =\r\nSTp->buffer->read_pointer =\r\nSTp->frame_in_buffer = 0;\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Block size: %d, frame size: %d, buffer size: %d (%d blocks).\n",\r\nname, STp->block_size, OS_FRAME_SIZE, (STp->buffer)->buffer_size,\r\n(STp->buffer)->buffer_blocks);\r\n#endif\r\nif (STp->drv_write_prot) {\r\nSTp->write_prot = 1;\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Write protected\n", name);\r\n#endif\r\nif ((flags & O_ACCMODE) == O_WRONLY || (flags & O_ACCMODE) == O_RDWR) {\r\nretval = (-EROFS);\r\ngoto err_out;\r\n}\r\n}\r\nif (new_session) {\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: New Session\n", name);\r\n#endif\r\nSTp->density_changed = STp->blksize_changed = 0;\r\nSTp->compression_changed = 0;\r\n}\r\nif (STp->door_locked == ST_UNLOCKED) {\r\nif (do_door_lock(STp, 1))\r\nprintk(KERN_INFO "%s:I: Can't lock drive door\n", name);\r\nelse\r\nSTp->door_locked = ST_LOCKED_AUTO;\r\n}\r\nosst_analyze_headers(STp, &SRpnt);\r\nosst_release_request(SRpnt);\r\nSRpnt = NULL;\r\nreturn 0;\r\nerr_out:\r\nif (SRpnt != NULL)\r\nosst_release_request(SRpnt);\r\nnormalize_buffer(STp->buffer);\r\nSTp->header_ok = 0;\r\nSTp->in_use = 0;\r\nscsi_device_put(STp->device);\r\nreturn retval;\r\n}\r\nstatic int os_scsi_tape_open(struct inode * inode, struct file * filp)\r\n{\r\nint ret;\r\nmutex_lock(&osst_int_mutex);\r\nret = __os_scsi_tape_open(inode, filp);\r\nmutex_unlock(&osst_int_mutex);\r\nreturn ret;\r\n}\r\nstatic int os_scsi_tape_flush(struct file * filp, fl_owner_t id)\r\n{\r\nint result = 0, result2;\r\nstruct osst_tape * STp = filp->private_data;\r\nstruct st_modedef * STm = &(STp->modes[STp->current_mode]);\r\nstruct st_partstat * STps = &(STp->ps[STp->partition]);\r\nstruct osst_request * SRpnt = NULL;\r\nchar * name = tape_name(STp);\r\nif (file_count(filp) > 1)\r\nreturn 0;\r\nif ((STps->rw == ST_WRITING || STp->dirty) && !STp->pos_unknown) {\r\nSTp->write_type = OS_WRITE_DATA;\r\nresult = osst_flush_write_buffer(STp, &SRpnt);\r\nif (result != 0 && result != (-ENOSPC))\r\ngoto out;\r\n}\r\nif ( STps->rw >= ST_WRITING && !STp->pos_unknown) {\r\n#if DEBUG\r\nif (debugging) {\r\nprintk(OSST_DEB_MSG "%s:D: File length %ld bytes.\n",\r\nname, (long)(filp->f_pos));\r\nprintk(OSST_DEB_MSG "%s:D: Async write waits %d, finished %d.\n",\r\nname, STp->nbr_waits, STp->nbr_finished);\r\n}\r\n#endif\r\nresult = osst_write_trailer(STp, &SRpnt, !(STp->rew_at_close));\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG "%s:D: Buffer flushed, %d EOF(s) written\n",\r\nname, 1+STp->two_fm);\r\n#endif\r\n}\r\nelse if (!STp->rew_at_close) {\r\nSTps = &(STp->ps[STp->partition]);\r\nif (!STm->sysv || STps->rw != ST_READING) {\r\nif (STp->can_bsr)\r\nresult = osst_flush_buffer(STp, &SRpnt, 0);\r\nelse if (STps->eof == ST_FM_HIT) {\r\nresult = cross_eof(STp, &SRpnt, 0);\r\nif (result) {\r\nif (STps->drv_file >= 0)\r\nSTps->drv_file++;\r\nSTps->drv_block = 0;\r\nSTps->eof = ST_FM;\r\n}\r\nelse\r\nSTps->eof = ST_NOEOF;\r\n}\r\n}\r\nelse if ((STps->eof == ST_NOEOF &&\r\n!(result = cross_eof(STp, &SRpnt, 1))) ||\r\nSTps->eof == ST_FM_HIT) {\r\nif (STps->drv_file >= 0)\r\nSTps->drv_file++;\r\nSTps->drv_block = 0;\r\nSTps->eof = ST_FM;\r\n}\r\n}\r\nout:\r\nif (STp->rew_at_close) {\r\nresult2 = osst_position_tape_and_confirm(STp, &SRpnt, STp->first_data_ppos);\r\nSTps->drv_file = STps->drv_block = STp->frame_seq_number = STp->logical_blk_num = 0;\r\nif (result == 0 && result2 < 0)\r\nresult = result2;\r\n}\r\nif (SRpnt) osst_release_request(SRpnt);\r\nif (STp->abort_count || STp->recover_count) {\r\nprintk(KERN_INFO "%s:I:", name);\r\nif (STp->abort_count)\r\nprintk(" %d unrecovered errors", STp->abort_count);\r\nif (STp->recover_count)\r\nprintk(" %d recovered errors", STp->recover_count);\r\nif (STp->write_count)\r\nprintk(" in %d frames written", STp->write_count);\r\nif (STp->read_count)\r\nprintk(" in %d frames read", STp->read_count);\r\nprintk("\n");\r\nSTp->recover_count = 0;\r\nSTp->abort_count = 0;\r\n}\r\nSTp->write_count = 0;\r\nSTp->read_count = 0;\r\nreturn result;\r\n}\r\nstatic int os_scsi_tape_close(struct inode * inode, struct file * filp)\r\n{\r\nint result = 0;\r\nstruct osst_tape * STp = filp->private_data;\r\nif (STp->door_locked == ST_LOCKED_AUTO)\r\ndo_door_lock(STp, 0);\r\nif (STp->raw)\r\nSTp->header_ok = 0;\r\nnormalize_buffer(STp->buffer);\r\nwrite_lock(&os_scsi_tapes_lock);\r\nSTp->in_use = 0;\r\nwrite_unlock(&os_scsi_tapes_lock);\r\nscsi_device_put(STp->device);\r\nreturn result;\r\n}\r\nstatic long osst_ioctl(struct file * file,\r\nunsigned int cmd_in, unsigned long arg)\r\n{\r\nint i, cmd_nr, cmd_type, blk, retval = 0;\r\nstruct st_modedef * STm;\r\nstruct st_partstat * STps;\r\nstruct osst_request * SRpnt = NULL;\r\nstruct osst_tape * STp = file->private_data;\r\nchar * name = tape_name(STp);\r\nvoid __user * p = (void __user *)arg;\r\nmutex_lock(&osst_int_mutex);\r\nif (mutex_lock_interruptible(&STp->lock)) {\r\nmutex_unlock(&osst_int_mutex);\r\nreturn -ERESTARTSYS;\r\n}\r\n#if DEBUG\r\nif (debugging && !STp->in_use) {\r\nprintk(OSST_DEB_MSG "%s:D: Incorrect device.\n", name);\r\nretval = (-EIO);\r\ngoto out;\r\n}\r\n#endif\r\nSTm = &(STp->modes[STp->current_mode]);\r\nSTps = &(STp->ps[STp->partition]);\r\nif( !scsi_block_when_processing_errors(STp->device) ) {\r\nretval = (-ENXIO);\r\ngoto out;\r\n}\r\ncmd_type = _IOC_TYPE(cmd_in);\r\ncmd_nr = _IOC_NR(cmd_in);\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "%s:D: Ioctl %d,%d in %s mode\n", name,\r\ncmd_type, cmd_nr, STp->raw?"raw":"normal");\r\n#endif\r\nif (cmd_type == _IOC_TYPE(MTIOCTOP) && cmd_nr == _IOC_NR(MTIOCTOP)) {\r\nstruct mtop mtc;\r\nint auto_weof = 0;\r\nif (_IOC_SIZE(cmd_in) != sizeof(mtc)) {\r\nretval = (-EINVAL);\r\ngoto out;\r\n}\r\ni = copy_from_user((char *) &mtc, p, sizeof(struct mtop));\r\nif (i) {\r\nretval = (-EFAULT);\r\ngoto out;\r\n}\r\nif (mtc.mt_op == MTSETDRVBUFFER && !capable(CAP_SYS_ADMIN)) {\r\nprintk(KERN_WARNING "%s:W: MTSETDRVBUFFER only allowed for root.\n", name);\r\nretval = (-EPERM);\r\ngoto out;\r\n}\r\nif (!STm->defined && (mtc.mt_op != MTSETDRVBUFFER && (mtc.mt_count & MT_ST_OPTIONS) == 0)) {\r\nretval = (-ENXIO);\r\ngoto out;\r\n}\r\nif (!STp->pos_unknown) {\r\nif (STps->eof == ST_FM_HIT) {\r\nif (mtc.mt_op == MTFSF || mtc.mt_op == MTFSFM|| mtc.mt_op == MTEOM) {\r\nmtc.mt_count -= 1;\r\nif (STps->drv_file >= 0)\r\nSTps->drv_file += 1;\r\n}\r\nelse if (mtc.mt_op == MTBSF || mtc.mt_op == MTBSFM) {\r\nmtc.mt_count += 1;\r\nif (STps->drv_file >= 0)\r\nSTps->drv_file += 1;\r\n}\r\n}\r\nif (mtc.mt_op == MTSEEK) {\r\ni = !STp->can_partitions || (STp->new_partition != STp->partition);\r\n}\r\nelse {\r\ni = mtc.mt_op == MTREW || mtc.mt_op == MTOFFL ||\r\nmtc.mt_op == MTRETEN || mtc.mt_op == MTEOM ||\r\nmtc.mt_op == MTLOCK || mtc.mt_op == MTLOAD ||\r\nmtc.mt_op == MTFSF || mtc.mt_op == MTFSFM ||\r\nmtc.mt_op == MTBSF || mtc.mt_op == MTBSFM ||\r\nmtc.mt_op == MTCOMPRESSION;\r\n}\r\ni = osst_flush_buffer(STp, &SRpnt, i);\r\nif (i < 0) {\r\nretval = i;\r\ngoto out;\r\n}\r\n}\r\nelse {\r\nif(mtc.mt_op != MTREW &&\r\nmtc.mt_op != MTOFFL &&\r\nmtc.mt_op != MTRETEN &&\r\nmtc.mt_op != MTERASE &&\r\nmtc.mt_op != MTSEEK &&\r\nmtc.mt_op != MTEOM) {\r\nretval = (-EIO);\r\ngoto out;\r\n}\r\nreset_state(STp);\r\nSTp->device->was_reset = 0;\r\n}\r\nif (mtc.mt_op != MTCOMPRESSION && mtc.mt_op != MTLOCK &&\r\nmtc.mt_op != MTNOP && mtc.mt_op != MTSETBLK &&\r\nmtc.mt_op != MTSETDENSITY && mtc.mt_op != MTSETDRVBUFFER &&\r\nmtc.mt_op != MTMKPART && mtc.mt_op != MTSETPART &&\r\nmtc.mt_op != MTWEOF && mtc.mt_op != MTWSM ) {\r\n#if DEBUG\r\nprintk(KERN_WARNING "%s:D: auto_weod %s at ffp=%d,efp=%d,fsn=%d,lbn=%d,fn=%d,bn=%d\n", name,\r\nSTps->rw >= ST_WRITING ? "write" : STps->rw == ST_READING ? "read" : "idle",\r\nSTp->first_frame_position, STp->eod_frame_ppos, STp->frame_seq_number,\r\nSTp->logical_blk_num, STps->drv_file, STps->drv_block );\r\n#endif\r\nif (STps->rw >= ST_WRITING && STp->first_frame_position >= STp->eod_frame_ppos) {\r\nauto_weof = ((STp->write_type != OS_WRITE_NEW_MARK) &&\r\n!(mtc.mt_op == MTREW || mtc.mt_op == MTOFFL));\r\ni = osst_write_trailer(STp, &SRpnt,\r\n!(mtc.mt_op == MTREW || mtc.mt_op == MTOFFL));\r\n#if DEBUG\r\nprintk(KERN_WARNING "%s:D: post trailer xeof=%d,ffp=%d,efp=%d,fsn=%d,lbn=%d,fn=%d,bn=%d\n",\r\nname, auto_weof, STp->first_frame_position, STp->eod_frame_ppos,\r\nSTp->frame_seq_number, STp->logical_blk_num, STps->drv_file, STps->drv_block );\r\n#endif\r\nif (i < 0) {\r\nretval = i;\r\ngoto out;\r\n}\r\n}\r\nSTps->rw = ST_IDLE;\r\n}\r\nif (mtc.mt_op == MTOFFL && STp->door_locked != ST_UNLOCKED)\r\ndo_door_lock(STp, 0);\r\nif (mtc.mt_op == MTSETDRVBUFFER &&\r\n(mtc.mt_count & MT_ST_OPTIONS) != 0) {\r\nretval = osst_set_options(STp, mtc.mt_count);\r\ngoto out;\r\n}\r\nif (mtc.mt_op == MTSETPART) {\r\nif (mtc.mt_count >= STp->nbr_partitions)\r\nretval = -EINVAL;\r\nelse {\r\nSTp->new_partition = mtc.mt_count;\r\nretval = 0;\r\n}\r\ngoto out;\r\n}\r\nif (mtc.mt_op == MTMKPART) {\r\nif (!STp->can_partitions) {\r\nretval = (-EINVAL);\r\ngoto out;\r\n}\r\nif ((i = osst_int_ioctl(STp, &SRpnt, MTREW, 0)) < 0 ) {\r\nretval = i;\r\ngoto out;\r\n}\r\nfor (i=0; i < ST_NBR_PARTITIONS; i++) {\r\nSTp->ps[i].rw = ST_IDLE;\r\nSTp->ps[i].at_sm = 0;\r\nSTp->ps[i].last_block_valid = 0;\r\n}\r\nSTp->partition = STp->new_partition = 0;\r\nSTp->nbr_partitions = 1;\r\nSTps->drv_block = STps->drv_file = 0;\r\nretval = 0;\r\ngoto out;\r\n}\r\nif (mtc.mt_op == MTSEEK) {\r\nif (STp->raw)\r\ni = osst_set_frame_position(STp, &SRpnt, mtc.mt_count, 0);\r\nelse\r\ni = osst_seek_sector(STp, &SRpnt, mtc.mt_count);\r\nif (!STp->can_partitions)\r\nSTp->ps[0].rw = ST_IDLE;\r\nretval = i;\r\ngoto out;\r\n}\r\nif (mtc.mt_op == MTLOCK || mtc.mt_op == MTUNLOCK) {\r\nretval = do_door_lock(STp, (mtc.mt_op == MTLOCK));\r\ngoto out;\r\n}\r\nif (auto_weof)\r\ncross_eof(STp, &SRpnt, 0);\r\nif (mtc.mt_op == MTCOMPRESSION)\r\nretval = -EINVAL;\r\nelse\r\nretval = osst_int_ioctl(STp, &SRpnt, mtc.mt_op, mtc.mt_count);\r\ngoto out;\r\n}\r\nif (!STm->defined) {\r\nretval = (-ENXIO);\r\ngoto out;\r\n}\r\nif ((i = osst_flush_buffer(STp, &SRpnt, 0)) < 0) {\r\nretval = i;\r\ngoto out;\r\n}\r\nif (cmd_type == _IOC_TYPE(MTIOCGET) && cmd_nr == _IOC_NR(MTIOCGET)) {\r\nstruct mtget mt_status;\r\nif (_IOC_SIZE(cmd_in) != sizeof(struct mtget)) {\r\nretval = (-EINVAL);\r\ngoto out;\r\n}\r\nmt_status.mt_type = MT_ISONSTREAM_SC;\r\nmt_status.mt_erreg = STp->recover_erreg << MT_ST_SOFTERR_SHIFT;\r\nmt_status.mt_dsreg =\r\n((STp->block_size << MT_ST_BLKSIZE_SHIFT) & MT_ST_BLKSIZE_MASK) |\r\n((STp->density << MT_ST_DENSITY_SHIFT) & MT_ST_DENSITY_MASK);\r\nmt_status.mt_blkno = STps->drv_block;\r\nmt_status.mt_fileno = STps->drv_file;\r\nif (STp->block_size != 0) {\r\nif (STps->rw == ST_WRITING)\r\nmt_status.mt_blkno += (STp->buffer)->buffer_bytes / STp->block_size;\r\nelse if (STps->rw == ST_READING)\r\nmt_status.mt_blkno -= ((STp->buffer)->buffer_bytes +\r\nSTp->block_size - 1) / STp->block_size;\r\n}\r\nmt_status.mt_gstat = 0;\r\nif (STp->drv_write_prot)\r\nmt_status.mt_gstat |= GMT_WR_PROT(0xffffffff);\r\nif (mt_status.mt_blkno == 0) {\r\nif (mt_status.mt_fileno == 0)\r\nmt_status.mt_gstat |= GMT_BOT(0xffffffff);\r\nelse\r\nmt_status.mt_gstat |= GMT_EOF(0xffffffff);\r\n}\r\nmt_status.mt_resid = STp->partition;\r\nif (STps->eof == ST_EOM_OK || STps->eof == ST_EOM_ERROR)\r\nmt_status.mt_gstat |= GMT_EOT(0xffffffff);\r\nelse if (STps->eof >= ST_EOM_OK)\r\nmt_status.mt_gstat |= GMT_EOD(0xffffffff);\r\nif (STp->density == 1)\r\nmt_status.mt_gstat |= GMT_D_800(0xffffffff);\r\nelse if (STp->density == 2)\r\nmt_status.mt_gstat |= GMT_D_1600(0xffffffff);\r\nelse if (STp->density == 3)\r\nmt_status.mt_gstat |= GMT_D_6250(0xffffffff);\r\nif (STp->ready == ST_READY)\r\nmt_status.mt_gstat |= GMT_ONLINE(0xffffffff);\r\nif (STp->ready == ST_NO_TAPE)\r\nmt_status.mt_gstat |= GMT_DR_OPEN(0xffffffff);\r\nif (STps->at_sm)\r\nmt_status.mt_gstat |= GMT_SM(0xffffffff);\r\nif (STm->do_async_writes || (STm->do_buffer_writes && STp->block_size != 0) ||\r\nSTp->drv_buffer != 0)\r\nmt_status.mt_gstat |= GMT_IM_REP_EN(0xffffffff);\r\ni = copy_to_user(p, &mt_status, sizeof(struct mtget));\r\nif (i) {\r\nretval = (-EFAULT);\r\ngoto out;\r\n}\r\nSTp->recover_erreg = 0;\r\nretval = 0;\r\ngoto out;\r\n}\r\nif (cmd_type == _IOC_TYPE(MTIOCPOS) && cmd_nr == _IOC_NR(MTIOCPOS)) {\r\nstruct mtpos mt_pos;\r\nif (_IOC_SIZE(cmd_in) != sizeof(struct mtpos)) {\r\nretval = (-EINVAL);\r\ngoto out;\r\n}\r\nif (STp->raw)\r\nblk = osst_get_frame_position(STp, &SRpnt);\r\nelse\r\nblk = osst_get_sector(STp, &SRpnt);\r\nif (blk < 0) {\r\nretval = blk;\r\ngoto out;\r\n}\r\nmt_pos.mt_blkno = blk;\r\ni = copy_to_user(p, &mt_pos, sizeof(struct mtpos));\r\nif (i)\r\nretval = -EFAULT;\r\ngoto out;\r\n}\r\nif (SRpnt) osst_release_request(SRpnt);\r\nmutex_unlock(&STp->lock);\r\nretval = scsi_ioctl(STp->device, cmd_in, p);\r\nmutex_unlock(&osst_int_mutex);\r\nreturn retval;\r\nout:\r\nif (SRpnt) osst_release_request(SRpnt);\r\nmutex_unlock(&STp->lock);\r\nmutex_unlock(&osst_int_mutex);\r\nreturn retval;\r\n}\r\nstatic long osst_compat_ioctl(struct file * file, unsigned int cmd_in, unsigned long arg)\r\n{\r\nstruct osst_tape *STp = file->private_data;\r\nstruct scsi_device *sdev = STp->device;\r\nint ret = -ENOIOCTLCMD;\r\nif (sdev->host->hostt->compat_ioctl) {\r\nret = sdev->host->hostt->compat_ioctl(sdev, cmd_in, (void __user *)arg);\r\n}\r\nreturn ret;\r\n}\r\nstatic struct osst_buffer * new_tape_buffer( int from_initialization, int need_dma, int max_sg )\r\n{\r\nint i;\r\ngfp_t priority;\r\nstruct osst_buffer *tb;\r\nif (from_initialization)\r\npriority = GFP_ATOMIC;\r\nelse\r\npriority = GFP_KERNEL;\r\ni = sizeof(struct osst_buffer) + (osst_max_sg_segs - 1) * sizeof(struct scatterlist);\r\ntb = kzalloc(i, priority);\r\nif (!tb) {\r\nprintk(KERN_NOTICE "osst :I: Can't allocate new tape buffer.\n");\r\nreturn NULL;\r\n}\r\ntb->sg_segs = tb->orig_sg_segs = 0;\r\ntb->use_sg = max_sg;\r\ntb->in_use = 1;\r\ntb->dma = need_dma;\r\ntb->buffer_size = 0;\r\n#if DEBUG\r\nif (debugging)\r\nprintk(OSST_DEB_MSG\r\n"osst :D: Allocated tape buffer skeleton (%d bytes, %d segments, dma: %d).\n",\r\ni, max_sg, need_dma);\r\n#endif\r\nreturn tb;\r\n}\r\nstatic int enlarge_buffer(struct osst_buffer *STbuffer, int need_dma)\r\n{\r\nint segs, nbr, max_segs, b_size, order, got;\r\ngfp_t priority;\r\nif (STbuffer->buffer_size >= OS_FRAME_SIZE)\r\nreturn 1;\r\nif (STbuffer->sg_segs) {\r\nprintk(KERN_WARNING "osst :A: Buffer not previously normalized.\n");\r\nnormalize_buffer(STbuffer);\r\n}\r\nnbr = max_segs = STbuffer->use_sg;\r\nif (nbr <= 2)\r\nreturn 0;\r\npriority = GFP_KERNEL ;\r\nif (need_dma)\r\npriority |= GFP_DMA;\r\nfor (b_size = OS_DATA_SIZE, order = OSST_FIRST_ORDER; b_size >= PAGE_SIZE; order--, b_size /= 2) {\r\nstruct page *page = alloc_pages(priority, order);\r\nSTbuffer->sg[0].offset = 0;\r\nif (page != NULL) {\r\nsg_set_page(&STbuffer->sg[0], page, b_size, 0);\r\nSTbuffer->b_data = page_address(page);\r\nbreak;\r\n}\r\n}\r\nif (sg_page(&STbuffer->sg[0]) == NULL) {\r\nprintk(KERN_NOTICE "osst :I: Can't allocate tape buffer main segment.\n");\r\nreturn 0;\r\n}\r\nfor (segs=STbuffer->sg_segs=1, got=b_size;\r\nsegs < max_segs && got < OS_FRAME_SIZE; ) {\r\nstruct page *page = alloc_pages(priority, (OS_FRAME_SIZE - got <= PAGE_SIZE) ? 0 : order);\r\nSTbuffer->sg[segs].offset = 0;\r\nif (page == NULL) {\r\nprintk(KERN_WARNING "osst :W: Failed to enlarge buffer to %d bytes.\n",\r\nOS_FRAME_SIZE);\r\n#if DEBUG\r\nSTbuffer->buffer_size = got;\r\n#endif\r\nnormalize_buffer(STbuffer);\r\nreturn 0;\r\n}\r\nsg_set_page(&STbuffer->sg[segs], page, (OS_FRAME_SIZE - got <= PAGE_SIZE / 2) ? (OS_FRAME_SIZE - got) : b_size, 0);\r\ngot += STbuffer->sg[segs].length;\r\nSTbuffer->buffer_size = got;\r\nSTbuffer->sg_segs = ++segs;\r\n}\r\n#if DEBUG\r\nif (debugging) {\r\nprintk(OSST_DEB_MSG\r\n"osst :D: Expanded tape buffer (%d bytes, %d->%d segments, dma: %d, at: %p).\n",\r\ngot, STbuffer->orig_sg_segs, STbuffer->sg_segs, need_dma, STbuffer->b_data);\r\nprintk(OSST_DEB_MSG\r\n"osst :D: segment sizes: first %d at %p, last %d bytes at %p.\n",\r\nSTbuffer->sg[0].length, page_address(STbuffer->sg[0].page),\r\nSTbuffer->sg[segs-1].length, page_address(STbuffer->sg[segs-1].page));\r\n}\r\n#endif\r\nreturn 1;\r\n}\r\nstatic void normalize_buffer(struct osst_buffer *STbuffer)\r\n{\r\nint i, order, b_size;\r\nfor (i=0; i < STbuffer->sg_segs; i++) {\r\nfor (b_size = PAGE_SIZE, order = 0;\r\nb_size < STbuffer->sg[i].length;\r\nb_size *= 2, order++);\r\n__free_pages(sg_page(&STbuffer->sg[i]), order);\r\nSTbuffer->buffer_size -= STbuffer->sg[i].length;\r\n}\r\n#if DEBUG\r\nif (debugging && STbuffer->orig_sg_segs < STbuffer->sg_segs)\r\nprintk(OSST_DEB_MSG "osst :D: Buffer at %p normalized to %d bytes (segs %d).\n",\r\nSTbuffer->b_data, STbuffer->buffer_size, STbuffer->sg_segs);\r\n#endif\r\nSTbuffer->sg_segs = STbuffer->orig_sg_segs = 0;\r\n}\r\nstatic int append_to_buffer(const char __user *ubp, struct osst_buffer *st_bp, int do_count)\r\n{\r\nint i, cnt, res, offset;\r\nfor (i=0, offset=st_bp->buffer_bytes;\r\ni < st_bp->sg_segs && offset >= st_bp->sg[i].length; i++)\r\noffset -= st_bp->sg[i].length;\r\nif (i == st_bp->sg_segs) {\r\nprintk(KERN_WARNING "osst :A: Append_to_buffer offset overflow.\n");\r\nreturn (-EIO);\r\n}\r\nfor ( ; i < st_bp->sg_segs && do_count > 0; i++) {\r\ncnt = st_bp->sg[i].length - offset < do_count ?\r\nst_bp->sg[i].length - offset : do_count;\r\nres = copy_from_user(page_address(sg_page(&st_bp->sg[i])) + offset, ubp, cnt);\r\nif (res)\r\nreturn (-EFAULT);\r\ndo_count -= cnt;\r\nst_bp->buffer_bytes += cnt;\r\nubp += cnt;\r\noffset = 0;\r\n}\r\nif (do_count) {\r\nprintk(KERN_WARNING "osst :A: Append_to_buffer overflow (left %d).\n",\r\ndo_count);\r\nreturn (-EIO);\r\n}\r\nreturn 0;\r\n}\r\nstatic int from_buffer(struct osst_buffer *st_bp, char __user *ubp, int do_count)\r\n{\r\nint i, cnt, res, offset;\r\nfor (i=0, offset=st_bp->read_pointer;\r\ni < st_bp->sg_segs && offset >= st_bp->sg[i].length; i++)\r\noffset -= st_bp->sg[i].length;\r\nif (i == st_bp->sg_segs) {\r\nprintk(KERN_WARNING "osst :A: From_buffer offset overflow.\n");\r\nreturn (-EIO);\r\n}\r\nfor ( ; i < st_bp->sg_segs && do_count > 0; i++) {\r\ncnt = st_bp->sg[i].length - offset < do_count ?\r\nst_bp->sg[i].length - offset : do_count;\r\nres = copy_to_user(ubp, page_address(sg_page(&st_bp->sg[i])) + offset, cnt);\r\nif (res)\r\nreturn (-EFAULT);\r\ndo_count -= cnt;\r\nst_bp->buffer_bytes -= cnt;\r\nst_bp->read_pointer += cnt;\r\nubp += cnt;\r\noffset = 0;\r\n}\r\nif (do_count) {\r\nprintk(KERN_WARNING "osst :A: From_buffer overflow (left %d).\n", do_count);\r\nreturn (-EIO);\r\n}\r\nreturn 0;\r\n}\r\nstatic int osst_zero_buffer_tail(struct osst_buffer *st_bp)\r\n{\r\nint i, offset, do_count, cnt;\r\nfor (i = 0, offset = st_bp->buffer_bytes;\r\ni < st_bp->sg_segs && offset >= st_bp->sg[i].length; i++)\r\noffset -= st_bp->sg[i].length;\r\nif (i == st_bp->sg_segs) {\r\nprintk(KERN_WARNING "osst :A: Zero_buffer offset overflow.\n");\r\nreturn (-EIO);\r\n}\r\nfor (do_count = OS_DATA_SIZE - st_bp->buffer_bytes;\r\ni < st_bp->sg_segs && do_count > 0; i++) {\r\ncnt = st_bp->sg[i].length - offset < do_count ?\r\nst_bp->sg[i].length - offset : do_count ;\r\nmemset(page_address(sg_page(&st_bp->sg[i])) + offset, 0, cnt);\r\ndo_count -= cnt;\r\noffset = 0;\r\n}\r\nif (do_count) {\r\nprintk(KERN_WARNING "osst :A: Zero_buffer overflow (left %d).\n", do_count);\r\nreturn (-EIO);\r\n}\r\nreturn 0;\r\n}\r\nstatic int osst_copy_to_buffer(struct osst_buffer *st_bp, unsigned char *ptr)\r\n{\r\nint i, cnt, do_count = OS_DATA_SIZE;\r\nfor (i = 0; i < st_bp->sg_segs && do_count > 0; i++) {\r\ncnt = st_bp->sg[i].length < do_count ?\r\nst_bp->sg[i].length : do_count ;\r\nmemcpy(page_address(sg_page(&st_bp->sg[i])), ptr, cnt);\r\ndo_count -= cnt;\r\nptr += cnt;\r\n}\r\nif (do_count || i != st_bp->sg_segs-1) {\r\nprintk(KERN_WARNING "osst :A: Copy_to_buffer overflow (left %d at sg %d).\n",\r\ndo_count, i);\r\nreturn (-EIO);\r\n}\r\nreturn 0;\r\n}\r\nstatic int osst_copy_from_buffer(struct osst_buffer *st_bp, unsigned char *ptr)\r\n{\r\nint i, cnt, do_count = OS_DATA_SIZE;\r\nfor (i = 0; i < st_bp->sg_segs && do_count > 0; i++) {\r\ncnt = st_bp->sg[i].length < do_count ?\r\nst_bp->sg[i].length : do_count ;\r\nmemcpy(ptr, page_address(sg_page(&st_bp->sg[i])), cnt);\r\ndo_count -= cnt;\r\nptr += cnt;\r\n}\r\nif (do_count || i != st_bp->sg_segs-1) {\r\nprintk(KERN_WARNING "osst :A: Copy_from_buffer overflow (left %d at sg %d).\n",\r\ndo_count, i);\r\nreturn (-EIO);\r\n}\r\nreturn 0;\r\n}\r\nstatic void validate_options (void)\r\n{\r\nif (max_dev > 0)\r\nosst_max_dev = max_dev;\r\nif (write_threshold_kbs > 0)\r\nosst_write_threshold = write_threshold_kbs * ST_KILOBYTE;\r\nif (osst_write_threshold > osst_buffer_size)\r\nosst_write_threshold = osst_buffer_size;\r\nif (max_sg_segs >= OSST_FIRST_SG)\r\nosst_max_sg_segs = max_sg_segs;\r\n#if DEBUG\r\nprintk(OSST_DEB_MSG "osst :D: max tapes %d, write threshold %d, max s/g segs %d.\n",\r\nosst_max_dev, osst_write_threshold, osst_max_sg_segs);\r\n#endif\r\n}\r\nstatic int __init osst_setup (char *str)\r\n{\r\nint i, ints[5];\r\nchar *stp;\r\nstp = get_options(str, ARRAY_SIZE(ints), ints);\r\nif (ints[0] > 0) {\r\nfor (i = 0; i < ints[0] && i < ARRAY_SIZE(parms); i++)\r\n*parms[i].val = ints[i + 1];\r\n} else {\r\nwhile (stp != NULL) {\r\nfor (i = 0; i < ARRAY_SIZE(parms); i++) {\r\nint len = strlen(parms[i].name);\r\nif (!strncmp(stp, parms[i].name, len) &&\r\n(*(stp + len) == ':' || *(stp + len) == '=')) {\r\n*parms[i].val =\r\nsimple_strtoul(stp + len + 1, NULL, 0);\r\nbreak;\r\n}\r\n}\r\nif (i >= ARRAY_SIZE(parms))\r\nprintk(KERN_INFO "osst :I: Illegal parameter in '%s'\n",\r\nstp);\r\nstp = strchr(stp, ',');\r\nif (stp)\r\nstp++;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int osst_supports(struct scsi_device * SDp)\r\n{\r\nstruct osst_support_data {\r\nchar *vendor;\r\nchar *model;\r\nchar *rev;\r\nchar *driver_hint;\r\n};\r\nstatic struct osst_support_data support_list[] = {\r\nSIGS_FROM_OSST,\r\n{NULL, }};\r\nstruct osst_support_data *rp;\r\nfor (rp=&(support_list[0]); rp->vendor != NULL; rp++)\r\nif (!strncmp(rp->vendor, SDp->vendor, strlen(rp->vendor)) &&\r\n!strncmp(rp->model, SDp->model, strlen(rp->model)) &&\r\n!strncmp(rp->rev, SDp->rev, strlen(rp->rev)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic ssize_t osst_version_show(struct device_driver *ddd, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", osst_version);\r\n}\r\nstatic int osst_create_sysfs_files(struct device_driver *sysfs)\r\n{\r\nreturn driver_create_file(sysfs, &driver_attr_version);\r\n}\r\nstatic void osst_remove_sysfs_files(struct device_driver *sysfs)\r\n{\r\ndriver_remove_file(sysfs, &driver_attr_version);\r\n}\r\nstatic ssize_t osst_adr_rev_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct osst_tape * STp = (struct osst_tape *) dev_get_drvdata (dev);\r\nssize_t l = 0;\r\nif (STp && STp->header_ok && STp->linux_media)\r\nl = snprintf(buf, PAGE_SIZE, "%d.%d\n", STp->header_cache->major_rev, STp->header_cache->minor_rev);\r\nreturn l;\r\n}\r\nstatic ssize_t osst_linux_media_version_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct osst_tape * STp = (struct osst_tape *) dev_get_drvdata (dev);\r\nssize_t l = 0;\r\nif (STp && STp->header_ok && STp->linux_media)\r\nl = snprintf(buf, PAGE_SIZE, "LIN%d\n", STp->linux_media_version);\r\nreturn l;\r\n}\r\nstatic ssize_t osst_capacity_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct osst_tape * STp = (struct osst_tape *) dev_get_drvdata (dev);\r\nssize_t l = 0;\r\nif (STp && STp->header_ok && STp->linux_media)\r\nl = snprintf(buf, PAGE_SIZE, "%d\n", STp->capacity);\r\nreturn l;\r\n}\r\nstatic ssize_t osst_first_data_ppos_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct osst_tape * STp = (struct osst_tape *) dev_get_drvdata (dev);\r\nssize_t l = 0;\r\nif (STp && STp->header_ok && STp->linux_media)\r\nl = snprintf(buf, PAGE_SIZE, "%d\n", STp->first_data_ppos);\r\nreturn l;\r\n}\r\nstatic ssize_t osst_eod_frame_ppos_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct osst_tape * STp = (struct osst_tape *) dev_get_drvdata (dev);\r\nssize_t l = 0;\r\nif (STp && STp->header_ok && STp->linux_media)\r\nl = snprintf(buf, PAGE_SIZE, "%d\n", STp->eod_frame_ppos);\r\nreturn l;\r\n}\r\nstatic ssize_t osst_filemark_cnt_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct osst_tape * STp = (struct osst_tape *) dev_get_drvdata (dev);\r\nssize_t l = 0;\r\nif (STp && STp->header_ok && STp->linux_media)\r\nl = snprintf(buf, PAGE_SIZE, "%d\n", STp->filemark_cnt);\r\nreturn l;\r\n}\r\nstatic int osst_sysfs_init(void)\r\n{\r\nosst_sysfs_class = class_create(THIS_MODULE, "onstream_tape");\r\nif (IS_ERR(osst_sysfs_class)) {\r\nprintk(KERN_ERR "osst :W: Unable to register sysfs class\n");\r\nreturn PTR_ERR(osst_sysfs_class);\r\n}\r\nreturn 0;\r\n}\r\nstatic void osst_sysfs_destroy(dev_t dev)\r\n{\r\ndevice_destroy(osst_sysfs_class, dev);\r\n}\r\nstatic int osst_sysfs_add(dev_t dev, struct device *device, struct osst_tape * STp, char * name)\r\n{\r\nstruct device *osst_member;\r\nint err;\r\nosst_member = device_create(osst_sysfs_class, device, dev, STp,\r\n"%s", name);\r\nif (IS_ERR(osst_member)) {\r\nprintk(KERN_WARNING "osst :W: Unable to add sysfs class member %s\n", name);\r\nreturn PTR_ERR(osst_member);\r\n}\r\nerr = device_create_file(osst_member, &dev_attr_ADR_rev);\r\nif (err)\r\ngoto err_out;\r\nerr = device_create_file(osst_member, &dev_attr_media_version);\r\nif (err)\r\ngoto err_out;\r\nerr = device_create_file(osst_member, &dev_attr_capacity);\r\nif (err)\r\ngoto err_out;\r\nerr = device_create_file(osst_member, &dev_attr_BOT_frame);\r\nif (err)\r\ngoto err_out;\r\nerr = device_create_file(osst_member, &dev_attr_EOD_frame);\r\nif (err)\r\ngoto err_out;\r\nerr = device_create_file(osst_member, &dev_attr_file_count);\r\nif (err)\r\ngoto err_out;\r\nreturn 0;\r\nerr_out:\r\nosst_sysfs_destroy(dev);\r\nreturn err;\r\n}\r\nstatic void osst_sysfs_cleanup(void)\r\n{\r\nclass_destroy(osst_sysfs_class);\r\n}\r\nstatic int osst_probe(struct device *dev)\r\n{\r\nstruct scsi_device * SDp = to_scsi_device(dev);\r\nstruct osst_tape * tpnt;\r\nstruct st_modedef * STm;\r\nstruct st_partstat * STps;\r\nstruct osst_buffer * buffer;\r\nstruct gendisk * drive;\r\nint i, dev_num, err = -ENODEV;\r\nif (SDp->type != TYPE_TAPE || !osst_supports(SDp))\r\nreturn -ENODEV;\r\ndrive = alloc_disk(1);\r\nif (!drive) {\r\nprintk(KERN_ERR "osst :E: Out of memory. Device not attached.\n");\r\nreturn -ENODEV;\r\n}\r\nwrite_lock(&os_scsi_tapes_lock);\r\nif (os_scsi_tapes == NULL) {\r\nos_scsi_tapes = kmalloc(osst_max_dev * sizeof(struct osst_tape *), GFP_ATOMIC);\r\nif (os_scsi_tapes == NULL) {\r\nwrite_unlock(&os_scsi_tapes_lock);\r\nprintk(KERN_ERR "osst :E: Unable to allocate array for OnStream SCSI tapes.\n");\r\ngoto out_put_disk;\r\n}\r\nfor (i=0; i < osst_max_dev; ++i) os_scsi_tapes[i] = NULL;\r\n}\r\nif (osst_nr_dev >= osst_max_dev) {\r\nwrite_unlock(&os_scsi_tapes_lock);\r\nprintk(KERN_ERR "osst :E: Too many tape devices (max. %d).\n", osst_max_dev);\r\ngoto out_put_disk;\r\n}\r\nfor (i = 0; i < osst_max_dev && os_scsi_tapes[i]; i++)\r\n;\r\nif(i >= osst_max_dev) panic ("Scsi_devices corrupt (osst)");\r\ndev_num = i;\r\ntpnt = kzalloc(sizeof(struct osst_tape), GFP_ATOMIC);\r\nif (!tpnt) {\r\nwrite_unlock(&os_scsi_tapes_lock);\r\nprintk(KERN_ERR "osst :E: Can't allocate device descriptor, device not attached.\n");\r\ngoto out_put_disk;\r\n}\r\ni = SDp->host->sg_tablesize;\r\nif (osst_max_sg_segs < i)\r\ni = osst_max_sg_segs;\r\nbuffer = new_tape_buffer(1, SDp->host->unchecked_isa_dma, i);\r\nif (buffer == NULL) {\r\nwrite_unlock(&os_scsi_tapes_lock);\r\nprintk(KERN_ERR "osst :E: Unable to allocate a tape buffer, device not attached.\n");\r\nkfree(tpnt);\r\ngoto out_put_disk;\r\n}\r\nos_scsi_tapes[dev_num] = tpnt;\r\ntpnt->buffer = buffer;\r\ntpnt->device = SDp;\r\ndrive->private_data = &tpnt->driver;\r\nsprintf(drive->disk_name, "osst%d", dev_num);\r\ntpnt->driver = &osst_template;\r\ntpnt->drive = drive;\r\ntpnt->in_use = 0;\r\ntpnt->capacity = 0xfffff;\r\ntpnt->dirty = 0;\r\ntpnt->drv_buffer = 1;\r\ntpnt->restr_dma = (SDp->host)->unchecked_isa_dma;\r\ntpnt->density = 0;\r\ntpnt->do_auto_lock = OSST_AUTO_LOCK;\r\ntpnt->can_bsr = OSST_IN_FILE_POS;\r\ntpnt->can_partitions = 0;\r\ntpnt->two_fm = OSST_TWO_FM;\r\ntpnt->fast_mteom = OSST_FAST_MTEOM;\r\ntpnt->scsi2_logical = OSST_SCSI2LOGICAL;\r\ntpnt->write_threshold = osst_write_threshold;\r\ntpnt->default_drvbuffer = 0xff;\r\ntpnt->partition = 0;\r\ntpnt->new_partition = 0;\r\ntpnt->nbr_partitions = 0;\r\ntpnt->min_block = 512;\r\ntpnt->max_block = OS_DATA_SIZE;\r\ntpnt->timeout = OSST_TIMEOUT;\r\ntpnt->long_timeout = OSST_LONG_TIMEOUT;\r\ntpnt->os_fw_rev = osst_parse_firmware_rev (SDp->rev);\r\ntpnt->omit_blklims = 1;\r\ntpnt->poll = (strncmp(SDp->model, "DI-", 3) == 0) ||\r\n(strncmp(SDp->model, "FW-", 3) == 0) || OSST_FW_NEED_POLL(tpnt->os_fw_rev,SDp);\r\ntpnt->frame_in_buffer = 0;\r\ntpnt->header_ok = 0;\r\ntpnt->linux_media = 0;\r\ntpnt->header_cache = NULL;\r\nfor (i=0; i < ST_NBR_MODES; i++) {\r\nSTm = &(tpnt->modes[i]);\r\nSTm->defined = 0;\r\nSTm->sysv = OSST_SYSV;\r\nSTm->defaults_for_writes = 0;\r\nSTm->do_async_writes = OSST_ASYNC_WRITES;\r\nSTm->do_buffer_writes = OSST_BUFFER_WRITES;\r\nSTm->do_read_ahead = OSST_READ_AHEAD;\r\nSTm->default_compression = ST_DONT_TOUCH;\r\nSTm->default_blksize = 512;\r\nSTm->default_density = (-1);\r\n}\r\nfor (i=0; i < ST_NBR_PARTITIONS; i++) {\r\nSTps = &(tpnt->ps[i]);\r\nSTps->rw = ST_IDLE;\r\nSTps->eof = ST_NOEOF;\r\nSTps->at_sm = 0;\r\nSTps->last_block_valid = 0;\r\nSTps->drv_block = (-1);\r\nSTps->drv_file = (-1);\r\n}\r\ntpnt->current_mode = 0;\r\ntpnt->modes[0].defined = 1;\r\ntpnt->modes[2].defined = 1;\r\ntpnt->density_changed = tpnt->compression_changed = tpnt->blksize_changed = 0;\r\nmutex_init(&tpnt->lock);\r\nosst_nr_dev++;\r\nwrite_unlock(&os_scsi_tapes_lock);\r\n{\r\nchar name[8];\r\nerr = osst_sysfs_add(MKDEV(OSST_MAJOR, dev_num), dev, tpnt, tape_name(tpnt));\r\nif (err)\r\ngoto out_free_buffer;\r\nsnprintf(name, 8, "%s%s", "n", tape_name(tpnt));\r\nerr = osst_sysfs_add(MKDEV(OSST_MAJOR, dev_num + 128), dev, tpnt, name);\r\nif (err)\r\ngoto out_free_sysfs1;\r\n}\r\nsdev_printk(KERN_INFO, SDp,\r\n"osst :I: Attached OnStream %.5s tape as %s\n",\r\nSDp->model, tape_name(tpnt));\r\nreturn 0;\r\nout_free_sysfs1:\r\nosst_sysfs_destroy(MKDEV(OSST_MAJOR, dev_num));\r\nout_free_buffer:\r\nkfree(buffer);\r\nout_put_disk:\r\nput_disk(drive);\r\nreturn err;\r\n}\r\nstatic int osst_remove(struct device *dev)\r\n{\r\nstruct scsi_device * SDp = to_scsi_device(dev);\r\nstruct osst_tape * tpnt;\r\nint i;\r\nif ((SDp->type != TYPE_TAPE) || (osst_nr_dev <= 0))\r\nreturn 0;\r\nwrite_lock(&os_scsi_tapes_lock);\r\nfor(i=0; i < osst_max_dev; i++) {\r\nif((tpnt = os_scsi_tapes[i]) && (tpnt->device == SDp)) {\r\nosst_sysfs_destroy(MKDEV(OSST_MAJOR, i));\r\nosst_sysfs_destroy(MKDEV(OSST_MAJOR, i+128));\r\ntpnt->device = NULL;\r\nput_disk(tpnt->drive);\r\nos_scsi_tapes[i] = NULL;\r\nosst_nr_dev--;\r\nwrite_unlock(&os_scsi_tapes_lock);\r\nvfree(tpnt->header_cache);\r\nif (tpnt->buffer) {\r\nnormalize_buffer(tpnt->buffer);\r\nkfree(tpnt->buffer);\r\n}\r\nkfree(tpnt);\r\nreturn 0;\r\n}\r\n}\r\nwrite_unlock(&os_scsi_tapes_lock);\r\nreturn 0;\r\n}\r\nstatic int __init init_osst(void)\r\n{\r\nint err;\r\nprintk(KERN_INFO "osst :I: Tape driver with OnStream support version %s\nosst :I: %s\n", osst_version, cvsid);\r\nvalidate_options();\r\nerr = osst_sysfs_init();\r\nif (err)\r\nreturn err;\r\nerr = register_chrdev(OSST_MAJOR, "osst", &osst_fops);\r\nif (err < 0) {\r\nprintk(KERN_ERR "osst :E: Unable to register major %d for OnStream tapes\n", OSST_MAJOR);\r\ngoto err_out;\r\n}\r\nerr = scsi_register_driver(&osst_template.gendrv);\r\nif (err)\r\ngoto err_out_chrdev;\r\nerr = osst_create_sysfs_files(&osst_template.gendrv);\r\nif (err)\r\ngoto err_out_scsidrv;\r\nreturn 0;\r\nerr_out_scsidrv:\r\nscsi_unregister_driver(&osst_template.gendrv);\r\nerr_out_chrdev:\r\nunregister_chrdev(OSST_MAJOR, "osst");\r\nerr_out:\r\nosst_sysfs_cleanup();\r\nreturn err;\r\n}\r\nstatic void __exit exit_osst (void)\r\n{\r\nint i;\r\nstruct osst_tape * STp;\r\nosst_remove_sysfs_files(&osst_template.gendrv);\r\nscsi_unregister_driver(&osst_template.gendrv);\r\nunregister_chrdev(OSST_MAJOR, "osst");\r\nosst_sysfs_cleanup();\r\nif (os_scsi_tapes) {\r\nfor (i=0; i < osst_max_dev; ++i) {\r\nif (!(STp = os_scsi_tapes[i])) continue;\r\nvfree(STp->header_cache);\r\nif (STp->buffer) {\r\nnormalize_buffer(STp->buffer);\r\nkfree(STp->buffer);\r\n}\r\nput_disk(STp->drive);\r\nkfree(STp);\r\n}\r\nkfree(os_scsi_tapes);\r\n}\r\nprintk(KERN_INFO "osst :I: Unloaded.\n");\r\n}
