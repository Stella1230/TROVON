static u16 af9035_checksum(const u8 *buf, size_t len)\r\n{\r\nsize_t i;\r\nu16 checksum = 0;\r\nfor (i = 1; i < len; i++) {\r\nif (i % 2)\r\nchecksum += buf[i] << 8;\r\nelse\r\nchecksum += buf[i];\r\n}\r\nchecksum = ~checksum;\r\nreturn checksum;\r\n}\r\nstatic int af9035_ctrl_msg(struct dvb_usb_device *d, struct usb_req *req)\r\n{\r\n#define REQ_HDR_LEN 4\r\n#define ACK_HDR_LEN 3\r\n#define CHECKSUM_LEN 2\r\n#define USB_TIMEOUT 2000\r\nstruct state *state = d_to_priv(d);\r\nint ret, wlen, rlen;\r\nu16 checksum, tmp_checksum;\r\nmutex_lock(&d->usb_mutex);\r\nif (req->wlen > (BUF_LEN - REQ_HDR_LEN - CHECKSUM_LEN) ||\r\nreq->rlen > (BUF_LEN - ACK_HDR_LEN - CHECKSUM_LEN)) {\r\ndev_err(&d->udev->dev, "%s: too much data wlen=%d rlen=%d\n",\r\nKBUILD_MODNAME, req->wlen, req->rlen);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nstate->buf[0] = REQ_HDR_LEN + req->wlen + CHECKSUM_LEN - 1;\r\nstate->buf[1] = req->mbox;\r\nstate->buf[2] = req->cmd;\r\nstate->buf[3] = state->seq++;\r\nmemcpy(&state->buf[REQ_HDR_LEN], req->wbuf, req->wlen);\r\nwlen = REQ_HDR_LEN + req->wlen + CHECKSUM_LEN;\r\nrlen = ACK_HDR_LEN + req->rlen + CHECKSUM_LEN;\r\nchecksum = af9035_checksum(state->buf, state->buf[0] - 1);\r\nstate->buf[state->buf[0] - 1] = (checksum >> 8);\r\nstate->buf[state->buf[0] - 0] = (checksum & 0xff);\r\nif (req->cmd == CMD_FW_DL)\r\nrlen = 0;\r\nret = dvb_usbv2_generic_rw_locked(d,\r\nstate->buf, wlen, state->buf, rlen);\r\nif (ret)\r\ngoto exit;\r\nif (req->cmd == CMD_FW_DL)\r\ngoto exit;\r\nchecksum = af9035_checksum(state->buf, rlen - 2);\r\ntmp_checksum = (state->buf[rlen - 2] << 8) | state->buf[rlen - 1];\r\nif (tmp_checksum != checksum) {\r\ndev_err(&d->udev->dev,\r\n"%s: command=%02x checksum mismatch (%04x != %04x)\n",\r\nKBUILD_MODNAME, req->cmd, tmp_checksum,\r\nchecksum);\r\nret = -EIO;\r\ngoto exit;\r\n}\r\nif (state->buf[2]) {\r\nif (req->cmd == CMD_IR_GET || state->buf[2] == 1) {\r\nret = 1;\r\ngoto exit;\r\n}\r\ndev_dbg(&d->udev->dev, "%s: command=%02x failed fw error=%d\n",\r\n__func__, req->cmd, state->buf[2]);\r\nret = -EIO;\r\ngoto exit;\r\n}\r\nif (req->rlen)\r\nmemcpy(req->rbuf, &state->buf[ACK_HDR_LEN], req->rlen);\r\nexit:\r\nmutex_unlock(&d->usb_mutex);\r\nif (ret < 0)\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_wr_regs(struct dvb_usb_device *d, u32 reg, u8 *val, int len)\r\n{\r\nu8 wbuf[6 + len];\r\nu8 mbox = (reg >> 16) & 0xff;\r\nstruct usb_req req = { CMD_MEM_WR, mbox, sizeof(wbuf), wbuf, 0, NULL };\r\nwbuf[0] = len;\r\nwbuf[1] = 2;\r\nwbuf[2] = 0;\r\nwbuf[3] = 0;\r\nwbuf[4] = (reg >> 8) & 0xff;\r\nwbuf[5] = (reg >> 0) & 0xff;\r\nmemcpy(&wbuf[6], val, len);\r\nreturn af9035_ctrl_msg(d, &req);\r\n}\r\nstatic int af9035_rd_regs(struct dvb_usb_device *d, u32 reg, u8 *val, int len)\r\n{\r\nu8 wbuf[] = { len, 2, 0, 0, (reg >> 8) & 0xff, reg & 0xff };\r\nu8 mbox = (reg >> 16) & 0xff;\r\nstruct usb_req req = { CMD_MEM_RD, mbox, sizeof(wbuf), wbuf, len, val };\r\nreturn af9035_ctrl_msg(d, &req);\r\n}\r\nstatic int af9035_wr_reg(struct dvb_usb_device *d, u32 reg, u8 val)\r\n{\r\nreturn af9035_wr_regs(d, reg, &val, 1);\r\n}\r\nstatic int af9035_rd_reg(struct dvb_usb_device *d, u32 reg, u8 *val)\r\n{\r\nreturn af9035_rd_regs(d, reg, val, 1);\r\n}\r\nstatic int af9035_wr_reg_mask(struct dvb_usb_device *d, u32 reg, u8 val,\r\nu8 mask)\r\n{\r\nint ret;\r\nu8 tmp;\r\nif (mask != 0xff) {\r\nret = af9035_rd_regs(d, reg, &tmp, 1);\r\nif (ret)\r\nreturn ret;\r\nval &= mask;\r\ntmp &= ~mask;\r\nval |= tmp;\r\n}\r\nreturn af9035_wr_regs(d, reg, &val, 1);\r\n}\r\nstatic int af9035_i2c_master_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstruct state *state = d_to_priv(d);\r\nint ret;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nif (num == 2 && !(msg[0].flags & I2C_M_RD) &&\r\n(msg[1].flags & I2C_M_RD)) {\r\nif (msg[0].len > 40 || msg[1].len > 40) {\r\nret = -EOPNOTSUPP;\r\n} else if ((msg[0].addr == state->af9033_config[0].i2c_addr) ||\r\n(msg[0].addr == state->af9033_config[1].i2c_addr)) {\r\nu32 reg = msg[0].buf[0] << 16 | msg[0].buf[1] << 8 |\r\nmsg[0].buf[2];\r\nif (msg[0].addr == state->af9033_config[1].i2c_addr)\r\nreg |= 0x100000;\r\nret = af9035_rd_regs(d, reg, &msg[1].buf[0],\r\nmsg[1].len);\r\n} else {\r\nu8 buf[5 + msg[0].len];\r\nstruct usb_req req = { CMD_I2C_RD, 0, sizeof(buf),\r\nbuf, msg[1].len, msg[1].buf };\r\nreq.mbox |= ((msg[0].addr & 0x80) >> 3);\r\nbuf[0] = msg[1].len;\r\nbuf[1] = msg[0].addr << 1;\r\nbuf[2] = 0x00;\r\nbuf[3] = 0x00;\r\nbuf[4] = 0x00;\r\nmemcpy(&buf[5], msg[0].buf, msg[0].len);\r\nret = af9035_ctrl_msg(d, &req);\r\n}\r\n} else if (num == 1 && !(msg[0].flags & I2C_M_RD)) {\r\nif (msg[0].len > 40) {\r\nret = -EOPNOTSUPP;\r\n} else if ((msg[0].addr == state->af9033_config[0].i2c_addr) ||\r\n(msg[0].addr == state->af9033_config[1].i2c_addr)) {\r\nu32 reg = msg[0].buf[0] << 16 | msg[0].buf[1] << 8 |\r\nmsg[0].buf[2];\r\nif (msg[0].addr == state->af9033_config[1].i2c_addr)\r\nreg |= 0x100000;\r\nret = af9035_wr_regs(d, reg, &msg[0].buf[3],\r\nmsg[0].len - 3);\r\n} else {\r\nu8 buf[5 + msg[0].len];\r\nstruct usb_req req = { CMD_I2C_WR, 0, sizeof(buf), buf,\r\n0, NULL };\r\nreq.mbox |= ((msg[0].addr & 0x80) >> 3);\r\nbuf[0] = msg[0].len;\r\nbuf[1] = msg[0].addr << 1;\r\nbuf[2] = 0x00;\r\nbuf[3] = 0x00;\r\nbuf[4] = 0x00;\r\nmemcpy(&buf[5], msg[0].buf, msg[0].len);\r\nret = af9035_ctrl_msg(d, &req);\r\n}\r\n} else if (num == 1 && (msg[0].flags & I2C_M_RD)) {\r\nif (msg[0].len > 40) {\r\nret = -EOPNOTSUPP;\r\n} else {\r\nu8 buf[5];\r\nstruct usb_req req = { CMD_I2C_RD, 0, sizeof(buf),\r\nbuf, msg[0].len, msg[0].buf };\r\nreq.mbox |= ((msg[0].addr & 0x80) >> 3);\r\nbuf[0] = msg[0].len;\r\nbuf[1] = msg[0].addr << 1;\r\nbuf[2] = 0x00;\r\nbuf[3] = 0x00;\r\nbuf[4] = 0x00;\r\nret = af9035_ctrl_msg(d, &req);\r\n}\r\n} else {\r\nret = -EOPNOTSUPP;\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn num;\r\n}\r\nstatic u32 af9035_i2c_functionality(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int af9035_identify_state(struct dvb_usb_device *d, const char **name)\r\n{\r\nstruct state *state = d_to_priv(d);\r\nint ret;\r\nu8 wbuf[1] = { 1 };\r\nu8 rbuf[4];\r\nstruct usb_req req = { CMD_FW_QUERYINFO, 0, sizeof(wbuf), wbuf,\r\nsizeof(rbuf), rbuf };\r\nret = af9035_rd_regs(d, 0x1222, rbuf, 3);\r\nif (ret < 0)\r\ngoto err;\r\nstate->chip_version = rbuf[0];\r\nstate->chip_type = rbuf[2] << 8 | rbuf[1] << 0;\r\nret = af9035_rd_reg(d, 0x384f, &state->prechip_version);\r\nif (ret < 0)\r\ngoto err;\r\ndev_info(&d->udev->dev,\r\n"%s: prechip_version=%02x chip_version=%02x chip_type=%04x\n",\r\nKBUILD_MODNAME, state->prechip_version,\r\nstate->chip_version, state->chip_type);\r\nif (state->chip_type == 0x9135) {\r\nif (state->chip_version == 0x02)\r\n*name = AF9035_FIRMWARE_IT9135_V2;\r\nelse\r\n*name = AF9035_FIRMWARE_IT9135_V1;\r\nstate->eeprom_addr = EEPROM_BASE_IT9135;\r\n} else {\r\n*name = AF9035_FIRMWARE_AF9035;\r\nstate->eeprom_addr = EEPROM_BASE_AF9035;\r\n}\r\nret = af9035_ctrl_msg(d, &req);\r\nif (ret < 0)\r\ngoto err;\r\ndev_dbg(&d->udev->dev, "%s: reply=%*ph\n", __func__, 4, rbuf);\r\nif (rbuf[0] || rbuf[1] || rbuf[2] || rbuf[3])\r\nret = WARM;\r\nelse\r\nret = COLD;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_download_firmware_old(struct dvb_usb_device *d,\r\nconst struct firmware *fw)\r\n{\r\nint ret, i, j, len;\r\nu8 wbuf[1];\r\nstruct usb_req req = { 0, 0, 0, NULL, 0, NULL };\r\nstruct usb_req req_fw_dl = { CMD_FW_DL, 0, 0, wbuf, 0, NULL };\r\nu8 hdr_core;\r\nu16 hdr_addr, hdr_data_len, hdr_checksum;\r\n#define MAX_DATA 58\r\n#define HDR_SIZE 7\r\nfor (i = fw->size; i > HDR_SIZE;) {\r\nhdr_core = fw->data[fw->size - i + 0];\r\nhdr_addr = fw->data[fw->size - i + 1] << 8;\r\nhdr_addr |= fw->data[fw->size - i + 2] << 0;\r\nhdr_data_len = fw->data[fw->size - i + 3] << 8;\r\nhdr_data_len |= fw->data[fw->size - i + 4] << 0;\r\nhdr_checksum = fw->data[fw->size - i + 5] << 8;\r\nhdr_checksum |= fw->data[fw->size - i + 6] << 0;\r\ndev_dbg(&d->udev->dev,\r\n"%s: core=%d addr=%04x data_len=%d checksum=%04x\n",\r\n__func__, hdr_core, hdr_addr, hdr_data_len,\r\nhdr_checksum);\r\nif (((hdr_core != 1) && (hdr_core != 2)) ||\r\n(hdr_data_len > i)) {\r\ndev_dbg(&d->udev->dev, "%s: bad firmware\n", __func__);\r\nbreak;\r\n}\r\nreq.cmd = CMD_FW_DL_BEGIN;\r\nret = af9035_ctrl_msg(d, &req);\r\nif (ret < 0)\r\ngoto err;\r\nfor (j = HDR_SIZE + hdr_data_len; j > 0; j -= MAX_DATA) {\r\nlen = j;\r\nif (len > MAX_DATA)\r\nlen = MAX_DATA;\r\nreq_fw_dl.wlen = len;\r\nreq_fw_dl.wbuf = (u8 *) &fw->data[fw->size - i +\r\nHDR_SIZE + hdr_data_len - j];\r\nret = af9035_ctrl_msg(d, &req_fw_dl);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nreq.cmd = CMD_FW_DL_END;\r\nret = af9035_ctrl_msg(d, &req);\r\nif (ret < 0)\r\ngoto err;\r\ni -= hdr_data_len + HDR_SIZE;\r\ndev_dbg(&d->udev->dev, "%s: data uploaded=%zu\n",\r\n__func__, fw->size - i);\r\n}\r\nif (i)\r\ndev_warn(&d->udev->dev, "%s: bad firmware\n", KBUILD_MODNAME);\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_download_firmware_new(struct dvb_usb_device *d,\r\nconst struct firmware *fw)\r\n{\r\nint ret, i, i_prev;\r\nstruct usb_req req_fw_dl = { CMD_FW_SCATTER_WR, 0, 0, NULL, 0, NULL };\r\n#define HDR_SIZE 7\r\nfor (i = HDR_SIZE, i_prev = 0; i <= fw->size; i++) {\r\nif (i == fw->size ||\r\n(fw->data[i + 0] == 0x03 &&\r\n(fw->data[i + 1] == 0x00 ||\r\nfw->data[i + 1] == 0x01) &&\r\nfw->data[i + 2] == 0x00)) {\r\nreq_fw_dl.wlen = i - i_prev;\r\nreq_fw_dl.wbuf = (u8 *) &fw->data[i_prev];\r\ni_prev = i;\r\nret = af9035_ctrl_msg(d, &req_fw_dl);\r\nif (ret < 0)\r\ngoto err;\r\ndev_dbg(&d->udev->dev, "%s: data uploaded=%d\n",\r\n__func__, i);\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_download_firmware(struct dvb_usb_device *d,\r\nconst struct firmware *fw)\r\n{\r\nstruct state *state = d_to_priv(d);\r\nint ret;\r\nu8 wbuf[1];\r\nu8 rbuf[4];\r\nu8 tmp;\r\nstruct usb_req req = { 0, 0, 0, NULL, 0, NULL };\r\nstruct usb_req req_fw_ver = { CMD_FW_QUERYINFO, 0, 1, wbuf, 4, rbuf };\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nret = af9035_rd_reg(d, state->eeprom_addr + EEPROM_TS_MODE, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\nif (tmp == 1 || tmp == 3) {\r\nret = af9035_wr_reg_mask(d, 0x00d8b0, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0x00d8b1, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0x00d8af, 0x00, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nusleep_range(10000, 50000);\r\nret = af9035_wr_reg_mask(d, 0x00d8af, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_rd_reg(d,\r\nstate->eeprom_addr + EEPROM_2ND_DEMOD_ADDR,\r\n&tmp);\r\nif (ret < 0)\r\ngoto err;\r\nif (state->chip_type == 0x9135) {\r\nret = af9035_wr_reg(d, 0x004bfb, tmp);\r\nif (ret < 0)\r\ngoto err;\r\n} else {\r\nret = af9035_wr_reg(d, 0x00417f, tmp);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0x00d81a, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\n}\r\nif (fw->data[0] == 0x01)\r\nret = af9035_download_firmware_old(d, fw);\r\nelse\r\nret = af9035_download_firmware_new(d, fw);\r\nif (ret < 0)\r\ngoto err;\r\nreq.cmd = CMD_FW_BOOT;\r\nret = af9035_ctrl_msg(d, &req);\r\nif (ret < 0)\r\ngoto err;\r\nwbuf[0] = 1;\r\nret = af9035_ctrl_msg(d, &req_fw_ver);\r\nif (ret < 0)\r\ngoto err;\r\nif (!(rbuf[0] || rbuf[1] || rbuf[2] || rbuf[3])) {\r\ndev_err(&d->udev->dev, "%s: firmware did not run\n",\r\nKBUILD_MODNAME);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\ndev_info(&d->udev->dev, "%s: firmware version=%d.%d.%d.%d",\r\nKBUILD_MODNAME, rbuf[0], rbuf[1], rbuf[2], rbuf[3]);\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_read_config(struct dvb_usb_device *d)\r\n{\r\nstruct state *state = d_to_priv(d);\r\nint ret, i;\r\nu8 tmp;\r\nu16 tmp16, addr;\r\nstate->af9033_config[0].i2c_addr = 0x38;\r\nstate->af9033_config[0].adc_multiplier = AF9033_ADC_MULTIPLIER_2X;\r\nstate->af9033_config[1].adc_multiplier = AF9033_ADC_MULTIPLIER_2X;\r\nstate->af9033_config[0].ts_mode = AF9033_TS_MODE_USB;\r\nstate->af9033_config[1].ts_mode = AF9033_TS_MODE_SERIAL;\r\nif (state->chip_type == 0x9135) {\r\nif (state->chip_version == 0x02) {\r\nstate->af9033_config[0].tuner = AF9033_TUNER_IT9135_60;\r\nstate->af9033_config[1].tuner = AF9033_TUNER_IT9135_60;\r\ntmp16 = 0x00461d;\r\n} else {\r\nstate->af9033_config[0].tuner = AF9033_TUNER_IT9135_38;\r\nstate->af9033_config[1].tuner = AF9033_TUNER_IT9135_38;\r\ntmp16 = 0x00461b;\r\n}\r\nret = af9035_rd_reg(d, tmp16, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\nif (tmp == 0x00) {\r\ndev_dbg(&d->udev->dev, "%s: no eeprom\n", __func__);\r\ngoto skip_eeprom;\r\n}\r\n}\r\nret = af9035_rd_reg(d, state->eeprom_addr + EEPROM_TS_MODE, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\nif (tmp == 1 || tmp == 3)\r\nstate->dual_mode = true;\r\ndev_dbg(&d->udev->dev, "%s: ts mode=%d dual mode=%d\n", __func__,\r\ntmp, state->dual_mode);\r\nif (state->dual_mode) {\r\nret = af9035_rd_reg(d,\r\nstate->eeprom_addr + EEPROM_2ND_DEMOD_ADDR,\r\n&tmp);\r\nif (ret < 0)\r\ngoto err;\r\nstate->af9033_config[1].i2c_addr = tmp;\r\ndev_dbg(&d->udev->dev, "%s: 2nd demod I2C addr=%02x\n",\r\n__func__, tmp);\r\n}\r\naddr = state->eeprom_addr;\r\nfor (i = 0; i < state->dual_mode + 1; i++) {\r\nret = af9035_rd_reg(d, addr + EEPROM_1_TUNER_ID, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\nif (tmp == 0x00)\r\ndev_dbg(&d->udev->dev,\r\n"%s: [%d]tuner not set, using default\n",\r\n__func__, i);\r\nelse\r\nstate->af9033_config[i].tuner = tmp;\r\ndev_dbg(&d->udev->dev, "%s: [%d]tuner=%02x\n",\r\n__func__, i, state->af9033_config[i].tuner);\r\nswitch (state->af9033_config[i].tuner) {\r\ncase AF9033_TUNER_TUA9001:\r\ncase AF9033_TUNER_FC0011:\r\ncase AF9033_TUNER_MXL5007T:\r\ncase AF9033_TUNER_TDA18218:\r\ncase AF9033_TUNER_FC2580:\r\ncase AF9033_TUNER_FC0012:\r\nstate->af9033_config[i].spec_inv = 1;\r\nbreak;\r\ncase AF9033_TUNER_IT9135_38:\r\ncase AF9033_TUNER_IT9135_51:\r\ncase AF9033_TUNER_IT9135_52:\r\ncase AF9033_TUNER_IT9135_60:\r\ncase AF9033_TUNER_IT9135_61:\r\ncase AF9033_TUNER_IT9135_62:\r\nbreak;\r\ndefault:\r\ndev_warn(&d->udev->dev,\r\n"%s: tuner id=%02x not supported, please report!",\r\nKBUILD_MODNAME, tmp);\r\n}\r\nif (i == 1)\r\nswitch (state->af9033_config[i].tuner) {\r\ncase AF9033_TUNER_FC0012:\r\ncase AF9033_TUNER_IT9135_38:\r\ncase AF9033_TUNER_IT9135_51:\r\ncase AF9033_TUNER_IT9135_52:\r\ncase AF9033_TUNER_IT9135_60:\r\ncase AF9033_TUNER_IT9135_61:\r\ncase AF9033_TUNER_IT9135_62:\r\ncase AF9033_TUNER_MXL5007T:\r\nbreak;\r\ndefault:\r\nstate->dual_mode = false;\r\ndev_info(&d->udev->dev,\r\n"%s: driver does not support 2nd tuner and will disable it",\r\nKBUILD_MODNAME);\r\n}\r\nret = af9035_rd_reg(d, addr + EEPROM_1_IF_L, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\ntmp16 = tmp;\r\nret = af9035_rd_reg(d, addr + EEPROM_1_IF_H, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\ntmp16 |= tmp << 8;\r\ndev_dbg(&d->udev->dev, "%s: [%d]IF=%d\n", __func__, i, tmp16);\r\naddr += 0x10;\r\n}\r\nskip_eeprom:\r\nret = af9035_rd_reg(d, 0x00d800, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\ntmp = (tmp >> 0) & 0x0f;\r\nfor (i = 0; i < ARRAY_SIZE(state->af9033_config); i++) {\r\nif (state->chip_type == 0x9135)\r\nstate->af9033_config[i].clock = clock_lut_it9135[tmp];\r\nelse\r\nstate->af9033_config[i].clock = clock_lut_af9035[tmp];\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_tua9001_tuner_callback(struct dvb_usb_device *d,\r\nint cmd, int arg)\r\n{\r\nint ret;\r\nu8 val;\r\ndev_dbg(&d->udev->dev, "%s: cmd=%d arg=%d\n", __func__, cmd, arg);\r\nswitch (cmd) {\r\ncase TUA9001_CMD_RESETN:\r\nif (arg)\r\nval = 0x00;\r\nelse\r\nval = 0x01;\r\nret = af9035_wr_reg_mask(d, 0x00d8e7, val, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nbreak;\r\ncase TUA9001_CMD_RXEN:\r\nif (arg)\r\nval = 0x01;\r\nelse\r\nval = 0x00;\r\nret = af9035_wr_reg_mask(d, 0x00d8eb, val, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nbreak;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_fc0011_tuner_callback(struct dvb_usb_device *d,\r\nint cmd, int arg)\r\n{\r\nint ret;\r\nswitch (cmd) {\r\ncase FC0011_FE_CALLBACK_POWER:\r\nret = af9035_wr_reg_mask(d, 0xd8eb, 1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8ec, 1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8ed, 1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8d0, 1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8d1, 1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nusleep_range(10000, 50000);\r\nbreak;\r\ncase FC0011_FE_CALLBACK_RESET:\r\nret = af9035_wr_reg(d, 0xd8e9, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0xd8e8, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0xd8e7, 1);\r\nif (ret < 0)\r\ngoto err;\r\nusleep_range(10000, 20000);\r\nret = af9035_wr_reg(d, 0xd8e7, 0);\r\nif (ret < 0)\r\ngoto err;\r\nusleep_range(10000, 20000);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_tuner_callback(struct dvb_usb_device *d, int cmd, int arg)\r\n{\r\nstruct state *state = d_to_priv(d);\r\nswitch (state->af9033_config[0].tuner) {\r\ncase AF9033_TUNER_FC0011:\r\nreturn af9035_fc0011_tuner_callback(d, cmd, arg);\r\ncase AF9033_TUNER_TUA9001:\r\nreturn af9035_tua9001_tuner_callback(d, cmd, arg);\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9035_frontend_callback(void *adapter_priv, int component,\r\nint cmd, int arg)\r\n{\r\nstruct i2c_adapter *adap = adapter_priv;\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\ndev_dbg(&d->udev->dev, "%s: component=%d cmd=%d arg=%d\n",\r\n__func__, component, cmd, arg);\r\nswitch (component) {\r\ncase DVB_FRONTEND_COMPONENT_TUNER:\r\nreturn af9035_tuner_callback(d, cmd, arg);\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9035_get_adapter_count(struct dvb_usb_device *d)\r\n{\r\nstruct state *state = d_to_priv(d);\r\nif (d->udev->speed == USB_SPEED_FULL)\r\nreturn 1;\r\nelse\r\nreturn state->dual_mode + 1;\r\n}\r\nstatic int af9035_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct state *state = adap_to_priv(adap);\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nint ret;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nif (!state->af9033_config[adap->id].tuner) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nadap->fe[0] = dvb_attach(af9033_attach, &state->af9033_config[adap->id],\r\n&d->i2c_adap);\r\nif (adap->fe[0] == NULL) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nadap->fe[0]->ops.i2c_gate_ctrl = NULL;\r\nadap->fe[0]->callback = af9035_frontend_callback;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct state *state = adap_to_priv(adap);\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nint ret;\r\nstruct dvb_frontend *fe;\r\nstruct i2c_msg msg[1];\r\nu8 tuner_addr;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nswitch (state->af9033_config[adap->id].tuner) {\r\ncase AF9033_TUNER_TUA9001:\r\nret = af9035_wr_reg_mask(d, 0x00d8ec, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0x00d8ed, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0x00d8e8, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0x00d8e9, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nfe = dvb_attach(tua9001_attach, adap->fe[0],\r\n&d->i2c_adap, &af9035_tua9001_config);\r\nbreak;\r\ncase AF9033_TUNER_FC0011:\r\nfe = dvb_attach(fc0011_attach, adap->fe[0],\r\n&d->i2c_adap, &af9035_fc0011_config);\r\nbreak;\r\ncase AF9033_TUNER_MXL5007T:\r\nif (adap->id == 0) {\r\nret = af9035_wr_reg(d, 0x00d8e0, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0x00d8e1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0x00d8df, 0);\r\nif (ret < 0)\r\ngoto err;\r\nmsleep(30);\r\nret = af9035_wr_reg(d, 0x00d8df, 1);\r\nif (ret < 0)\r\ngoto err;\r\nmsleep(300);\r\nret = af9035_wr_reg(d, 0x00d8c0, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0x00d8c1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0x00d8bf, 0);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0x00d8b4, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0x00d8b5, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0x00d8b3, 1);\r\nif (ret < 0)\r\ngoto err;\r\ntuner_addr = 0x60;\r\n} else {\r\ntuner_addr = 0x60 | 0x80;\r\n}\r\nfe = dvb_attach(mxl5007t_attach, adap->fe[0], &d->i2c_adap,\r\ntuner_addr, &af9035_mxl5007t_config[adap->id]);\r\nbreak;\r\ncase AF9033_TUNER_TDA18218:\r\nfe = dvb_attach(tda18218_attach, adap->fe[0],\r\n&d->i2c_adap, &af9035_tda18218_config);\r\nbreak;\r\ncase AF9033_TUNER_FC2580:\r\nret = af9035_wr_reg_mask(d, 0xd8eb, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8ec, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8ed, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nusleep_range(10000, 50000);\r\nfe = dvb_attach(fc2580_attach, adap->fe[0],\r\n&d->i2c_adap, &af9035_fc2580_config);\r\nbreak;\r\ncase AF9033_TUNER_FC0012:\r\nif (adap->id == 0) {\r\nret = af9035_wr_reg_mask(d, 0xd8eb, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8ec, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8ed, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\n} else {\r\nmsg[0].addr = 0x63;\r\nmsg[0].flags = 0;\r\nmsg[0].len = 2;\r\nmsg[0].buf = "\x0d\x02";\r\nret = i2c_transfer(&d->i2c_adap, msg, 1);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nusleep_range(10000, 50000);\r\nfe = dvb_attach(fc0012_attach, adap->fe[0], &d->i2c_adap,\r\n&af9035_fc0012_config[adap->id]);\r\nbreak;\r\ncase AF9033_TUNER_IT9135_38:\r\ncase AF9033_TUNER_IT9135_51:\r\ncase AF9033_TUNER_IT9135_52:\r\ncase AF9033_TUNER_IT9135_60:\r\ncase AF9033_TUNER_IT9135_61:\r\ncase AF9033_TUNER_IT9135_62:\r\nfe = dvb_attach(it913x_attach, adap->fe[0], &d->i2c_adap,\r\nstate->af9033_config[adap->id].i2c_addr,\r\nstate->af9033_config[0].tuner);\r\nbreak;\r\ndefault:\r\nfe = NULL;\r\n}\r\nif (fe == NULL) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_init(struct dvb_usb_device *d)\r\n{\r\nstruct state *state = d_to_priv(d);\r\nint ret, i;\r\nu16 frame_size = (d->udev->speed == USB_SPEED_FULL ? 5 : 87) * 188 / 4;\r\nu8 packet_size = (d->udev->speed == USB_SPEED_FULL ? 64 : 512) / 4;\r\nstruct reg_val_mask tab[] = {\r\n{ 0x80f99d, 0x01, 0x01 },\r\n{ 0x80f9a4, 0x01, 0x01 },\r\n{ 0x00dd11, 0x00, 0x20 },\r\n{ 0x00dd11, 0x00, 0x40 },\r\n{ 0x00dd13, 0x00, 0x20 },\r\n{ 0x00dd13, 0x00, 0x40 },\r\n{ 0x00dd11, 0x20, 0x20 },\r\n{ 0x00dd88, (frame_size >> 0) & 0xff, 0xff},\r\n{ 0x00dd89, (frame_size >> 8) & 0xff, 0xff},\r\n{ 0x00dd0c, packet_size, 0xff},\r\n{ 0x00dd11, state->dual_mode << 6, 0x40 },\r\n{ 0x00dd8a, (frame_size >> 0) & 0xff, 0xff},\r\n{ 0x00dd8b, (frame_size >> 8) & 0xff, 0xff},\r\n{ 0x00dd0d, packet_size, 0xff },\r\n{ 0x80f9a3, state->dual_mode, 0x01 },\r\n{ 0x80f9cd, state->dual_mode, 0x01 },\r\n{ 0x80f99d, 0x00, 0x01 },\r\n{ 0x80f9a4, 0x00, 0x01 },\r\n};\r\ndev_dbg(&d->udev->dev,\r\n"%s: USB speed=%d frame_size=%04x packet_size=%02x\n",\r\n__func__, d->udev->speed, frame_size, packet_size);\r\nfor (i = 0; i < ARRAY_SIZE(tab); i++) {\r\nret = af9035_wr_reg_mask(d, tab[i].reg, tab[i].val,\r\ntab[i].mask);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_rc_query(struct dvb_usb_device *d)\r\n{\r\nint ret;\r\nu32 key;\r\nu8 buf[4];\r\nstruct usb_req req = { CMD_IR_GET, 0, 0, NULL, 4, buf };\r\nret = af9035_ctrl_msg(d, &req);\r\nif (ret == 1)\r\nreturn 0;\r\nelse if (ret < 0)\r\ngoto err;\r\nif ((buf[2] + buf[3]) == 0xff) {\r\nif ((buf[0] + buf[1]) == 0xff) {\r\nkey = buf[0] << 8 | buf[2];\r\n} else {\r\nkey = buf[0] << 16 | buf[1] << 8 | buf[2];\r\n}\r\n} else {\r\nkey = buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3];\r\n}\r\ndev_dbg(&d->udev->dev, "%s: %*ph\n", __func__, 4, buf);\r\nrc_keydown(d->rc_dev, key, 0);\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)\r\n{\r\nstruct state *state = d_to_priv(d);\r\nint ret;\r\nu8 tmp;\r\nret = af9035_rd_reg(d, state->eeprom_addr + EEPROM_IR_MODE, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\ndev_dbg(&d->udev->dev, "%s: ir_mode=%02x\n", __func__, tmp);\r\nif (tmp == 5) {\r\nret = af9035_rd_reg(d, state->eeprom_addr + EEPROM_IR_TYPE,\r\n&tmp);\r\nif (ret < 0)\r\ngoto err;\r\ndev_dbg(&d->udev->dev, "%s: ir_type=%02x\n", __func__, tmp);\r\nswitch (tmp) {\r\ncase 0:\r\ndefault:\r\nrc->allowed_protos = RC_BIT_NEC;\r\nbreak;\r\ncase 1:\r\nrc->allowed_protos = RC_BIT_RC6_MCE;\r\nbreak;\r\n}\r\nrc->query = af9035_rc_query;\r\nrc->interval = 500;\r\nif (!rc->map_name)\r\nrc->map_name = RC_MAP_EMPTY;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_get_stream_config(struct dvb_frontend *fe, u8 *ts_type,\r\nstruct usb_data_stream_properties *stream)\r\n{\r\nstruct dvb_usb_device *d = fe_to_d(fe);\r\ndev_dbg(&d->udev->dev, "%s: adap=%d\n", __func__, fe_to_adap(fe)->id);\r\nif (d->udev->speed == USB_SPEED_FULL)\r\nstream->u.bulk.buffersize = 5 * 188;\r\nreturn 0;\r\n}\r\nstatic int af9035_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nint ret;\r\ndev_dbg(&d->udev->dev, "%s: onoff=%d\n", __func__, onoff);\r\nret = af9035_wr_reg_mask(d, 0x80f993, onoff, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid,\r\nint onoff)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nint ret;\r\nu8 wbuf[2] = {(pid >> 0) & 0xff, (pid >> 8) & 0xff};\r\ndev_dbg(&d->udev->dev, "%s: index=%d pid=%04x onoff=%d\n",\r\n__func__, index, pid, onoff);\r\nret = af9035_wr_regs(d, 0x80f996, wbuf, 2);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0x80f994, onoff);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0x80f995, index);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nchar manufacturer[sizeof("Afatech")];\r\nmemset(manufacturer, 0, sizeof(manufacturer));\r\nusb_string(udev, udev->descriptor.iManufacturer,\r\nmanufacturer, sizeof(manufacturer));\r\nif ((le16_to_cpu(udev->descriptor.idVendor) == USB_VID_TERRATEC) &&\r\n(le16_to_cpu(udev->descriptor.idProduct) == 0x0099)) {\r\nif (!strcmp("Afatech", manufacturer)) {\r\ndev_dbg(&udev->dev, "%s: rejecting device\n", __func__);\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn dvb_usbv2_probe(intf, id);\r\n}
