int p54_parse_firmware(struct ieee80211_hw *dev, const struct firmware *fw)\r\n{\r\nstruct p54_common *priv = dev->priv;\r\nstruct exp_if *exp_if;\r\nstruct bootrec *bootrec;\r\nu32 *data = (u32 *)fw->data;\r\nu32 *end_data = (u32 *)fw->data + (fw->size >> 2);\r\nu8 *fw_version = NULL;\r\nsize_t len;\r\nint i;\r\nint maxlen;\r\nif (priv->rx_start)\r\nreturn 0;\r\nwhile (data < end_data && *data)\r\ndata++;\r\nwhile (data < end_data && !*data)\r\ndata++;\r\nbootrec = (struct bootrec *) data;\r\nwhile (bootrec->data <= end_data && (bootrec->data +\r\n(len = le32_to_cpu(bootrec->len))) <= end_data) {\r\nu32 code = le32_to_cpu(bootrec->code);\r\nswitch (code) {\r\ncase BR_CODE_COMPONENT_ID:\r\npriv->fw_interface = be32_to_cpup((__be32 *)\r\nbootrec->data);\r\nswitch (priv->fw_interface) {\r\ncase FW_LM86:\r\ncase FW_LM20:\r\ncase FW_LM87: {\r\nchar *iftype = (char *)bootrec->data;\r\nwiphy_info(priv->hw->wiphy,\r\n"p54 detected a LM%c%c firmware\n",\r\niftype[2], iftype[3]);\r\nbreak;\r\n}\r\ncase FW_FMAC:\r\ndefault:\r\nwiphy_err(priv->hw->wiphy,\r\n"unsupported firmware\n");\r\nreturn -ENODEV;\r\n}\r\nbreak;\r\ncase BR_CODE_COMPONENT_VERSION:\r\nif (strnlen((unsigned char *) bootrec->data, 24) < 24)\r\nfw_version = (unsigned char *) bootrec->data;\r\nbreak;\r\ncase BR_CODE_DESCR: {\r\nstruct bootrec_desc *desc =\r\n(struct bootrec_desc *)bootrec->data;\r\npriv->rx_start = le32_to_cpu(desc->rx_start);\r\npriv->rx_end = le32_to_cpu(desc->rx_end) - 0x3500;\r\npriv->headroom = desc->headroom;\r\npriv->tailroom = desc->tailroom;\r\npriv->privacy_caps = desc->privacy_caps;\r\npriv->rx_keycache_size = desc->rx_keycache_size;\r\nif (le32_to_cpu(bootrec->len) == 11)\r\npriv->rx_mtu = le16_to_cpu(desc->rx_mtu);\r\nelse\r\npriv->rx_mtu = (size_t)\r\n0x620 - priv->tx_hdr_len;\r\nmaxlen = priv->tx_hdr_len +\r\nsizeof(struct p54_rx_data) +\r\n4 +\r\nIEEE80211_MAX_FRAG_THRESHOLD;\r\nif (priv->rx_mtu > maxlen && PAGE_SIZE == 4096) {\r\nprintk(KERN_INFO "p54: rx_mtu reduced from %d "\r\n"to %d\n", priv->rx_mtu, maxlen);\r\npriv->rx_mtu = maxlen;\r\n}\r\nbreak;\r\n}\r\ncase BR_CODE_EXPOSED_IF:\r\nexp_if = (struct exp_if *) bootrec->data;\r\nfor (i = 0; i < (len * sizeof(*exp_if) / 4); i++)\r\nif (exp_if[i].if_id == cpu_to_le16(IF_ID_LMAC))\r\npriv->fw_var = le16_to_cpu(exp_if[i].variant);\r\nbreak;\r\ncase BR_CODE_DEPENDENT_IF:\r\nbreak;\r\ncase BR_CODE_END_OF_BRA:\r\ncase LEGACY_BR_CODE_END_OF_BRA:\r\nend_data = NULL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbootrec = (struct bootrec *)&bootrec->data[len];\r\n}\r\nif (fw_version) {\r\nwiphy_info(priv->hw->wiphy,\r\n"FW rev %s - Softmac protocol %x.%x\n",\r\nfw_version, priv->fw_var >> 8, priv->fw_var & 0xff);\r\nsnprintf(dev->wiphy->fw_version, sizeof(dev->wiphy->fw_version),\r\n"%s - %x.%x", fw_version,\r\npriv->fw_var >> 8, priv->fw_var & 0xff);\r\n}\r\nif (priv->fw_var < 0x500)\r\nwiphy_info(priv->hw->wiphy,\r\n"you are using an obsolete firmware. "\r\n"visit http://wireless.kernel.org/en/users/Drivers/p54 "\r\n"and grab one for \"kernel >= 2.6.28\"!\n");\r\nif (priv->fw_var >= 0x300) {\r\nif (priv->fw_var >= 0x500) {\r\npriv->tx_stats[P54_QUEUE_AC_VO].limit = 16;\r\npriv->tx_stats[P54_QUEUE_AC_VI].limit = 16;\r\npriv->tx_stats[P54_QUEUE_AC_BE].limit = 16;\r\npriv->tx_stats[P54_QUEUE_AC_BK].limit = 16;\r\n} else {\r\npriv->tx_stats[P54_QUEUE_AC_VO].limit = 3;\r\npriv->tx_stats[P54_QUEUE_AC_VI].limit = 4;\r\npriv->tx_stats[P54_QUEUE_AC_BE].limit = 3;\r\npriv->tx_stats[P54_QUEUE_AC_BK].limit = 2;\r\n}\r\npriv->hw->queues = P54_QUEUE_AC_NUM;\r\n}\r\nwiphy_info(priv->hw->wiphy,\r\n"cryptographic accelerator WEP:%s, TKIP:%s, CCMP:%s\n",\r\n(priv->privacy_caps & BR_DESC_PRIV_CAP_WEP) ? "YES" : "no",\r\n(priv->privacy_caps &\r\n(BR_DESC_PRIV_CAP_TKIP | BR_DESC_PRIV_CAP_MICHAEL))\r\n? "YES" : "no",\r\n(priv->privacy_caps & BR_DESC_PRIV_CAP_AESCCMP)\r\n? "YES" : "no");\r\nif (priv->rx_keycache_size) {\r\npriv->used_rxkeys = kzalloc(BITS_TO_LONGS(\r\npriv->rx_keycache_size), GFP_KERNEL);\r\nif (!priv->used_rxkeys)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *p54_alloc_skb(struct p54_common *priv, u16 hdr_flags,\r\nu16 payload_len, u16 type, gfp_t memflags)\r\n{\r\nstruct p54_hdr *hdr;\r\nstruct sk_buff *skb;\r\nsize_t frame_len = sizeof(*hdr) + payload_len;\r\nif (frame_len > P54_MAX_CTRL_FRAME_LEN)\r\nreturn NULL;\r\nif (unlikely(skb_queue_len(&priv->tx_pending) > 64))\r\nreturn NULL;\r\nskb = __dev_alloc_skb(priv->tx_hdr_len + frame_len, memflags);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, priv->tx_hdr_len);\r\nhdr = (struct p54_hdr *) skb_put(skb, sizeof(*hdr));\r\nhdr->flags = cpu_to_le16(hdr_flags);\r\nhdr->len = cpu_to_le16(payload_len);\r\nhdr->type = cpu_to_le16(type);\r\nhdr->tries = hdr->rts_tries = 0;\r\nreturn skb;\r\n}\r\nint p54_download_eeprom(struct p54_common *priv, void *buf,\r\nu16 offset, u16 len)\r\n{\r\nstruct p54_eeprom_lm86 *eeprom_hdr;\r\nstruct sk_buff *skb;\r\nsize_t eeprom_hdr_size;\r\nint ret = 0;\r\nif (priv->fw_var >= 0x509)\r\neeprom_hdr_size = sizeof(*eeprom_hdr);\r\nelse\r\neeprom_hdr_size = 0x4;\r\nskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL, eeprom_hdr_size +\r\nlen, P54_CONTROL_TYPE_EEPROM_READBACK,\r\nGFP_KERNEL);\r\nif (unlikely(!skb))\r\nreturn -ENOMEM;\r\nmutex_lock(&priv->eeprom_mutex);\r\npriv->eeprom = buf;\r\neeprom_hdr = (struct p54_eeprom_lm86 *) skb_put(skb,\r\neeprom_hdr_size + len);\r\nif (priv->fw_var < 0x509) {\r\neeprom_hdr->v1.offset = cpu_to_le16(offset);\r\neeprom_hdr->v1.len = cpu_to_le16(len);\r\n} else {\r\neeprom_hdr->v2.offset = cpu_to_le32(offset);\r\neeprom_hdr->v2.len = cpu_to_le16(len);\r\neeprom_hdr->v2.magic2 = 0xf;\r\nmemcpy(eeprom_hdr->v2.magic, (const char *)"LOCK", 4);\r\n}\r\np54_tx(priv, skb);\r\nif (!wait_for_completion_interruptible_timeout(\r\n&priv->eeprom_comp, HZ)) {\r\nwiphy_err(priv->hw->wiphy, "device does not respond!\n");\r\nret = -EBUSY;\r\n}\r\npriv->eeprom = NULL;\r\nmutex_unlock(&priv->eeprom_mutex);\r\nreturn ret;\r\n}\r\nint p54_update_beacon_tim(struct p54_common *priv, u16 aid, bool set)\r\n{\r\nstruct sk_buff *skb;\r\nstruct p54_tim *tim;\r\nskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*tim),\r\nP54_CONTROL_TYPE_TIM, GFP_ATOMIC);\r\nif (unlikely(!skb))\r\nreturn -ENOMEM;\r\ntim = (struct p54_tim *) skb_put(skb, sizeof(*tim));\r\ntim->count = 1;\r\ntim->entry[0] = cpu_to_le16(set ? (aid | 0x8000) : aid);\r\np54_tx(priv, skb);\r\nreturn 0;\r\n}\r\nint p54_sta_unlock(struct p54_common *priv, u8 *addr)\r\n{\r\nstruct sk_buff *skb;\r\nstruct p54_sta_unlock *sta;\r\nskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*sta),\r\nP54_CONTROL_TYPE_PSM_STA_UNLOCK, GFP_ATOMIC);\r\nif (unlikely(!skb))\r\nreturn -ENOMEM;\r\nsta = (struct p54_sta_unlock *)skb_put(skb, sizeof(*sta));\r\nmemcpy(sta->addr, addr, ETH_ALEN);\r\np54_tx(priv, skb);\r\nreturn 0;\r\n}\r\nint p54_tx_cancel(struct p54_common *priv, __le32 req_id)\r\n{\r\nstruct sk_buff *skb;\r\nstruct p54_txcancel *cancel;\r\nu32 _req_id = le32_to_cpu(req_id);\r\nif (unlikely(_req_id < priv->rx_start || _req_id > priv->rx_end))\r\nreturn -EINVAL;\r\nskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*cancel),\r\nP54_CONTROL_TYPE_TXCANCEL, GFP_ATOMIC);\r\nif (unlikely(!skb))\r\nreturn -ENOMEM;\r\ncancel = (struct p54_txcancel *)skb_put(skb, sizeof(*cancel));\r\ncancel->req_id = req_id;\r\np54_tx(priv, skb);\r\nreturn 0;\r\n}\r\nint p54_setup_mac(struct p54_common *priv)\r\n{\r\nstruct sk_buff *skb;\r\nstruct p54_setup_mac *setup;\r\nu16 mode;\r\nskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*setup),\r\nP54_CONTROL_TYPE_SETUP, GFP_ATOMIC);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nsetup = (struct p54_setup_mac *) skb_put(skb, sizeof(*setup));\r\nif (!(priv->hw->conf.flags & IEEE80211_CONF_IDLE)) {\r\nswitch (priv->mode) {\r\ncase NL80211_IFTYPE_STATION:\r\nmode = P54_FILTER_TYPE_STATION;\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\nmode = P54_FILTER_TYPE_AP;\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\ncase NL80211_IFTYPE_MESH_POINT:\r\nmode = P54_FILTER_TYPE_IBSS;\r\nbreak;\r\ncase NL80211_IFTYPE_MONITOR:\r\nmode = P54_FILTER_TYPE_PROMISCUOUS;\r\nbreak;\r\ndefault:\r\nmode = P54_FILTER_TYPE_HIBERNATE;\r\nbreak;\r\n}\r\nif (((priv->filter_flags & FIF_PROMISC_IN_BSS) ||\r\n(priv->filter_flags & FIF_OTHER_BSS)) &&\r\n(mode != P54_FILTER_TYPE_PROMISCUOUS))\r\nmode |= P54_FILTER_TYPE_TRANSPARENT;\r\n} else {\r\nmode = P54_FILTER_TYPE_HIBERNATE;\r\n}\r\nsetup->mac_mode = cpu_to_le16(mode);\r\nmemcpy(setup->mac_addr, priv->mac_addr, ETH_ALEN);\r\nmemcpy(setup->bssid, priv->bssid, ETH_ALEN);\r\nsetup->rx_antenna = 2 & priv->rx_diversity_mask;\r\nsetup->rx_align = 0;\r\nif (priv->fw_var < 0x500) {\r\nsetup->v1.basic_rate_mask = cpu_to_le32(priv->basic_rate_mask);\r\nmemset(setup->v1.rts_rates, 0, 8);\r\nsetup->v1.rx_addr = cpu_to_le32(priv->rx_end);\r\nsetup->v1.max_rx = cpu_to_le16(priv->rx_mtu);\r\nsetup->v1.rxhw = cpu_to_le16(priv->rxhw);\r\nsetup->v1.wakeup_timer = cpu_to_le16(priv->wakeup_timer);\r\nsetup->v1.unalloc0 = cpu_to_le16(0);\r\n} else {\r\nsetup->v2.rx_addr = cpu_to_le32(priv->rx_end);\r\nsetup->v2.max_rx = cpu_to_le16(priv->rx_mtu);\r\nsetup->v2.rxhw = cpu_to_le16(priv->rxhw);\r\nsetup->v2.timer = cpu_to_le16(priv->wakeup_timer);\r\nsetup->v2.truncate = cpu_to_le16(48896);\r\nsetup->v2.basic_rate_mask = cpu_to_le32(priv->basic_rate_mask);\r\nsetup->v2.sbss_offset = 0;\r\nsetup->v2.mcast_window = 0;\r\nsetup->v2.rx_rssi_threshold = 0;\r\nsetup->v2.rx_ed_threshold = 0;\r\nsetup->v2.ref_clock = cpu_to_le32(644245094);\r\nsetup->v2.lpf_bandwidth = cpu_to_le16(65535);\r\nsetup->v2.osc_start_delay = cpu_to_le16(65535);\r\n}\r\np54_tx(priv, skb);\r\npriv->phy_idle = mode == P54_FILTER_TYPE_HIBERNATE;\r\nreturn 0;\r\n}\r\nint p54_scan(struct p54_common *priv, u16 mode, u16 dwell)\r\n{\r\nstruct sk_buff *skb;\r\nstruct p54_hdr *hdr;\r\nstruct p54_scan_head *head;\r\nstruct p54_iq_autocal_entry *iq_autocal;\r\nunion p54_scan_body_union *body;\r\nstruct p54_scan_tail_rate *rate;\r\nstruct pda_rssi_cal_entry *rssi;\r\nstruct p54_rssi_db_entry *rssi_data;\r\nunsigned int i;\r\nvoid *entry;\r\n__le16 freq = cpu_to_le16(priv->hw->conf.chandef.chan->center_freq);\r\nskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*head) +\r\n2 + sizeof(*iq_autocal) + sizeof(*body) +\r\nsizeof(*rate) + 2 * sizeof(*rssi),\r\nP54_CONTROL_TYPE_SCAN, GFP_ATOMIC);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nhead = (struct p54_scan_head *) skb_put(skb, sizeof(*head));\r\nmemset(head->scan_params, 0, sizeof(head->scan_params));\r\nhead->mode = cpu_to_le16(mode);\r\nhead->dwell = cpu_to_le16(dwell);\r\nhead->freq = freq;\r\nif (priv->rxhw == PDR_SYNTH_FRONTEND_LONGBOW) {\r\n__le16 *pa_power_points = (__le16 *) skb_put(skb, 2);\r\n*pa_power_points = cpu_to_le16(0x0c);\r\n}\r\niq_autocal = (void *) skb_put(skb, sizeof(*iq_autocal));\r\nfor (i = 0; i < priv->iq_autocal_len; i++) {\r\nif (priv->iq_autocal[i].freq != freq)\r\ncontinue;\r\nmemcpy(iq_autocal, &priv->iq_autocal[i].params,\r\nsizeof(struct p54_iq_autocal_entry));\r\nbreak;\r\n}\r\nif (i == priv->iq_autocal_len)\r\ngoto err;\r\nif (priv->rxhw == PDR_SYNTH_FRONTEND_LONGBOW)\r\nbody = (void *) skb_put(skb, sizeof(body->longbow));\r\nelse\r\nbody = (void *) skb_put(skb, sizeof(body->normal));\r\nfor (i = 0; i < priv->output_limit->entries; i++) {\r\n__le16 *entry_freq = (void *) (priv->output_limit->data +\r\npriv->output_limit->entry_size * i);\r\nif (*entry_freq != freq)\r\ncontinue;\r\nif (priv->rxhw == PDR_SYNTH_FRONTEND_LONGBOW) {\r\nmemcpy(&body->longbow.power_limits,\r\n(void *) entry_freq + sizeof(__le16),\r\npriv->output_limit->entry_size);\r\n} else {\r\nstruct pda_channel_output_limit *limits =\r\n(void *) entry_freq;\r\nbody->normal.val_barker = 0x38;\r\nbody->normal.val_bpsk = body->normal.dup_bpsk =\r\nlimits->val_bpsk;\r\nbody->normal.val_qpsk = body->normal.dup_qpsk =\r\nlimits->val_qpsk;\r\nbody->normal.val_16qam = body->normal.dup_16qam =\r\nlimits->val_16qam;\r\nbody->normal.val_64qam = body->normal.dup_64qam =\r\nlimits->val_64qam;\r\n}\r\nbreak;\r\n}\r\nif (i == priv->output_limit->entries)\r\ngoto err;\r\nentry = (void *)(priv->curve_data->data + priv->curve_data->offset);\r\nfor (i = 0; i < priv->curve_data->entries; i++) {\r\nif (*((__le16 *)entry) != freq) {\r\nentry += priv->curve_data->entry_size;\r\ncontinue;\r\n}\r\nif (priv->rxhw == PDR_SYNTH_FRONTEND_LONGBOW) {\r\nmemcpy(&body->longbow.curve_data,\r\nentry + sizeof(__le16),\r\npriv->curve_data->entry_size);\r\n} else {\r\nstruct p54_scan_body *chan = &body->normal;\r\nstruct pda_pa_curve_data *curve_data =\r\n(void *) priv->curve_data->data;\r\nentry += sizeof(__le16);\r\nchan->pa_points_per_curve = 8;\r\nmemset(chan->curve_data, 0, sizeof(*chan->curve_data));\r\nmemcpy(chan->curve_data, entry,\r\nsizeof(struct p54_pa_curve_data_sample) *\r\nmin((u8)8, curve_data->points_per_channel));\r\n}\r\nbreak;\r\n}\r\nif (i == priv->curve_data->entries)\r\ngoto err;\r\nif ((priv->fw_var >= 0x500) && (priv->fw_var < 0x509)) {\r\nrate = (void *) skb_put(skb, sizeof(*rate));\r\nrate->basic_rate_mask = cpu_to_le32(priv->basic_rate_mask);\r\nfor (i = 0; i < sizeof(rate->rts_rates); i++)\r\nrate->rts_rates[i] = i;\r\n}\r\nrssi = (struct pda_rssi_cal_entry *) skb_put(skb, sizeof(*rssi));\r\nrssi_data = p54_rssi_find(priv, le16_to_cpu(freq));\r\nrssi->mul = cpu_to_le16(rssi_data->mul);\r\nrssi->add = cpu_to_le16(rssi_data->add);\r\nif (priv->rxhw == PDR_SYNTH_FRONTEND_LONGBOW) {\r\nrssi = (void *) skb_put(skb, sizeof(*rssi));\r\nrssi->mul = cpu_to_le16(rssi_data->longbow_unkn);\r\nrssi->add = cpu_to_le16(rssi_data->longbow_unk2);\r\n}\r\nif (priv->fw_var >= 0x509) {\r\nrate = (void *) skb_put(skb, sizeof(*rate));\r\nrate->basic_rate_mask = cpu_to_le32(priv->basic_rate_mask);\r\nfor (i = 0; i < sizeof(rate->rts_rates); i++)\r\nrate->rts_rates[i] = i;\r\n}\r\nhdr = (struct p54_hdr *) skb->data;\r\nhdr->len = cpu_to_le16(skb->len - sizeof(*hdr));\r\np54_tx(priv, skb);\r\npriv->cur_rssi = rssi_data;\r\nreturn 0;\r\nerr:\r\nwiphy_err(priv->hw->wiphy, "frequency change to channel %d failed.\n",\r\nieee80211_frequency_to_channel(\r\npriv->hw->conf.chandef.chan->center_freq));\r\ndev_kfree_skb_any(skb);\r\nreturn -EINVAL;\r\n}\r\nint p54_set_leds(struct p54_common *priv)\r\n{\r\nstruct sk_buff *skb;\r\nstruct p54_led *led;\r\nskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*led),\r\nP54_CONTROL_TYPE_LED, GFP_ATOMIC);\r\nif (unlikely(!skb))\r\nreturn -ENOMEM;\r\nled = (struct p54_led *) skb_put(skb, sizeof(*led));\r\nled->flags = cpu_to_le16(0x0003);\r\nled->mask[0] = led->mask[1] = cpu_to_le16(priv->softled_state);\r\nled->delay[0] = cpu_to_le16(1);\r\nled->delay[1] = cpu_to_le16(0);\r\np54_tx(priv, skb);\r\nreturn 0;\r\n}\r\nint p54_set_edcf(struct p54_common *priv)\r\n{\r\nstruct sk_buff *skb;\r\nstruct p54_edcf *edcf;\r\nu8 rtd;\r\nskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*edcf),\r\nP54_CONTROL_TYPE_DCFINIT, GFP_ATOMIC);\r\nif (unlikely(!skb))\r\nreturn -ENOMEM;\r\nedcf = (struct p54_edcf *)skb_put(skb, sizeof(*edcf));\r\nif (priv->use_short_slot) {\r\nedcf->slottime = 9;\r\nedcf->sifs = 0x10;\r\nedcf->eofpad = 0x00;\r\n} else {\r\nedcf->slottime = 20;\r\nedcf->sifs = 0x0a;\r\nedcf->eofpad = 0x06;\r\n}\r\nrtd = 3 * priv->coverage_class;\r\nedcf->slottime += rtd;\r\nedcf->round_trip_delay = cpu_to_le16(rtd);\r\nedcf->frameburst = cpu_to_le16(0);\r\nedcf->flags = 0;\r\nmemset(edcf->mapping, 0, sizeof(edcf->mapping));\r\nmemcpy(edcf->queue, priv->qos_params, sizeof(edcf->queue));\r\np54_tx(priv, skb);\r\nreturn 0;\r\n}\r\nint p54_set_ps(struct p54_common *priv)\r\n{\r\nstruct sk_buff *skb;\r\nstruct p54_psm *psm;\r\nunsigned int i;\r\nu16 mode;\r\nif (priv->hw->conf.flags & IEEE80211_CONF_PS &&\r\n!priv->powersave_override)\r\nmode = P54_PSM | P54_PSM_BEACON_TIMEOUT | P54_PSM_DTIM |\r\nP54_PSM_CHECKSUM | P54_PSM_MCBC;\r\nelse\r\nmode = P54_PSM_CAM;\r\nskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*psm),\r\nP54_CONTROL_TYPE_PSM, GFP_ATOMIC);\r\nif (!skb)\r\nreturn -ENOMEM;\r\npsm = (struct p54_psm *)skb_put(skb, sizeof(*psm));\r\npsm->mode = cpu_to_le16(mode);\r\npsm->aid = cpu_to_le16(priv->aid);\r\nfor (i = 0; i < ARRAY_SIZE(psm->intervals); i++) {\r\npsm->intervals[i].interval =\r\ncpu_to_le16(priv->hw->conf.listen_interval);\r\npsm->intervals[i].periods = cpu_to_le16(1);\r\n}\r\npsm->beacon_rssi_skip_max = 200;\r\npsm->rssi_delta_threshold = 0;\r\npsm->nr = 1;\r\npsm->exclude[0] = WLAN_EID_TIM;\r\np54_tx(priv, skb);\r\npriv->phy_ps = mode != P54_PSM_CAM;\r\nreturn 0;\r\n}\r\nint p54_init_xbow_synth(struct p54_common *priv)\r\n{\r\nstruct sk_buff *skb;\r\nstruct p54_xbow_synth *xbow;\r\nskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*xbow),\r\nP54_CONTROL_TYPE_XBOW_SYNTH_CFG, GFP_KERNEL);\r\nif (unlikely(!skb))\r\nreturn -ENOMEM;\r\nxbow = (struct p54_xbow_synth *)skb_put(skb, sizeof(*xbow));\r\nxbow->magic1 = cpu_to_le16(0x1);\r\nxbow->magic2 = cpu_to_le16(0x2);\r\nxbow->freq = cpu_to_le16(5390);\r\nmemset(xbow->padding, 0, sizeof(xbow->padding));\r\np54_tx(priv, skb);\r\nreturn 0;\r\n}\r\nint p54_upload_key(struct p54_common *priv, u8 algo, int slot, u8 idx, u8 len,\r\nu8 *addr, u8* key)\r\n{\r\nstruct sk_buff *skb;\r\nstruct p54_keycache *rxkey;\r\nskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*rxkey),\r\nP54_CONTROL_TYPE_RX_KEYCACHE, GFP_KERNEL);\r\nif (unlikely(!skb))\r\nreturn -ENOMEM;\r\nrxkey = (struct p54_keycache *)skb_put(skb, sizeof(*rxkey));\r\nrxkey->entry = slot;\r\nrxkey->key_id = idx;\r\nrxkey->key_type = algo;\r\nif (addr)\r\nmemcpy(rxkey->mac, addr, ETH_ALEN);\r\nelse\r\nmemset(rxkey->mac, ~0, ETH_ALEN);\r\nswitch (algo) {\r\ncase P54_CRYPTO_WEP:\r\ncase P54_CRYPTO_AESCCMP:\r\nrxkey->key_len = min_t(u8, 16, len);\r\nmemcpy(rxkey->key, key, rxkey->key_len);\r\nbreak;\r\ncase P54_CRYPTO_TKIPMICHAEL:\r\nrxkey->key_len = 24;\r\nmemcpy(rxkey->key, key, 16);\r\nmemcpy(&(rxkey->key[16]), &(key\r\n[NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY]), 8);\r\nbreak;\r\ncase P54_CRYPTO_NONE:\r\nrxkey->key_len = 0;\r\nmemset(rxkey->key, 0, sizeof(rxkey->key));\r\nbreak;\r\ndefault:\r\nwiphy_err(priv->hw->wiphy,\r\n"invalid cryptographic algorithm: %d\n", algo);\r\ndev_kfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\np54_tx(priv, skb);\r\nreturn 0;\r\n}\r\nint p54_fetch_statistics(struct p54_common *priv)\r\n{\r\nstruct ieee80211_tx_info *txinfo;\r\nstruct p54_tx_info *p54info;\r\nstruct sk_buff *skb;\r\nskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL,\r\nsizeof(struct p54_statistics),\r\nP54_CONTROL_TYPE_STAT_READBACK, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\ntxinfo = IEEE80211_SKB_CB(skb);\r\np54info = (void *) txinfo->rate_driver_data;\r\np54info->extra_len = sizeof(struct p54_statistics);\r\np54_tx(priv, skb);\r\nreturn 0;\r\n}\r\nint p54_set_groupfilter(struct p54_common *priv)\r\n{\r\nstruct p54_group_address_table *grp;\r\nstruct sk_buff *skb;\r\nbool on = false;\r\nskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*grp),\r\nP54_CONTROL_TYPE_GROUP_ADDRESS_TABLE, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\ngrp = (struct p54_group_address_table *)skb_put(skb, sizeof(*grp));\r\non = !(priv->filter_flags & FIF_ALLMULTI) &&\r\n(priv->mc_maclist_num > 0 &&\r\npriv->mc_maclist_num <= MC_FILTER_ADDRESS_NUM);\r\nif (on) {\r\ngrp->filter_enable = cpu_to_le16(1);\r\ngrp->num_address = cpu_to_le16(priv->mc_maclist_num);\r\nmemcpy(grp->mac_list, priv->mc_maclist, sizeof(grp->mac_list));\r\n} else {\r\ngrp->filter_enable = cpu_to_le16(0);\r\ngrp->num_address = cpu_to_le16(0);\r\nmemset(grp->mac_list, 0, sizeof(grp->mac_list));\r\n}\r\np54_tx(priv, skb);\r\nreturn 0;\r\n}
