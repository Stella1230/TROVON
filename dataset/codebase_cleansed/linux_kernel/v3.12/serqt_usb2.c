static int port_paranoia_check(struct usb_serial_port *port,\r\nconst char *function)\r\n{\r\nif (!port) {\r\npr_debug("%s - port == NULL", function);\r\nreturn -1;\r\n}\r\nif (!port->serial) {\r\npr_debug("%s - port->serial == NULL\n", function);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int serial_paranoia_check(struct usb_serial *serial,\r\nconst char *function)\r\n{\r\nif (!serial) {\r\npr_debug("%s - serial == NULL\n", function);\r\nreturn -1;\r\n}\r\nif (!serial->type) {\r\npr_debug("%s - serial->type == NULL!", function);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline struct quatech_port *qt_get_port_private(struct usb_serial_port\r\n*port)\r\n{\r\nreturn (struct quatech_port *)usb_get_serial_port_data(port);\r\n}\r\nstatic inline void qt_set_port_private(struct usb_serial_port *port,\r\nstruct quatech_port *data)\r\n{\r\nusb_set_serial_port_data(port, (void *)data);\r\n}\r\nstatic struct usb_serial *get_usb_serial(struct usb_serial_port *port,\r\nconst char *function)\r\n{\r\nif (!port ||\r\nport_paranoia_check(port, function) ||\r\nserial_paranoia_check(port->serial, function)) {\r\nreturn NULL;\r\n}\r\nreturn port->serial;\r\n}\r\nstatic void process_line_status(struct quatech_port *qt_port,\r\nunsigned char line_status)\r\n{\r\nqt_port->shadow_lsr =\r\nline_status & (SERIAL_LSR_OE | SERIAL_LSR_PE | SERIAL_LSR_FE |\r\nSERIAL_LSR_BI);\r\n}\r\nstatic void process_modem_status(struct quatech_port *qt_port,\r\nunsigned char modem_status)\r\n{\r\nqt_port->shadow_msr = modem_status;\r\nwake_up_interruptible(&qt_port->wait);\r\n}\r\nstatic void process_rx_char(struct usb_serial_port *port, unsigned char data)\r\n{\r\nstruct urb *urb = port->read_urb;\r\nif (urb->actual_length)\r\ntty_insert_flip_char(&port->port, data, TTY_NORMAL);\r\n}\r\nstatic void qt_write_bulk_callback(struct urb *urb)\r\n{\r\nint status;\r\nstruct quatech_port *quatech_port;\r\nstatus = urb->status;\r\nif (status) {\r\ndev_dbg(&urb->dev->dev,\r\n"nonzero write bulk status received:%d\n", status);\r\nreturn;\r\n}\r\nquatech_port = urb->context;\r\ntty_port_tty_wakeup(&quatech_port->port->port);\r\n}\r\nstatic void qt_interrupt_callback(struct urb *urb)\r\n{\r\n}\r\nstatic void qt_status_change_check(struct urb *urb,\r\nstruct quatech_port *qt_port,\r\nstruct usb_serial_port *port)\r\n{\r\nint flag, i;\r\nunsigned char *data = urb->transfer_buffer;\r\nunsigned int rx_count = urb->actual_length;\r\nfor (i = 0; i < rx_count; ++i) {\r\nif ((i <= (rx_count - 3)) && (data[i] == 0x1b)\r\n&& (data[i + 1] == 0x1b)) {\r\nflag = 0;\r\nswitch (data[i + 2]) {\r\ncase 0x00:\r\nif (i > (rx_count - 4)) {\r\ndev_dbg(&port->dev,\r\n"Illegal escape seuences in received data\n");\r\nbreak;\r\n}\r\nprocess_line_status(qt_port, data[i + 3]);\r\ni += 3;\r\nflag = 1;\r\nbreak;\r\ncase 0x01:\r\nif (i > (rx_count - 4)) {\r\ndev_dbg(&port->dev,\r\n"Illegal escape seuences in received data\n");\r\nbreak;\r\n}\r\nprocess_modem_status(qt_port, data[i + 3]);\r\ni += 3;\r\nflag = 1;\r\nbreak;\r\ncase 0xff:\r\ndev_dbg(&port->dev, "No status sequence.\n");\r\nprocess_rx_char(port, data[i]);\r\nprocess_rx_char(port, data[i + 1]);\r\ni += 2;\r\nbreak;\r\n}\r\nif (flag == 1)\r\ncontinue;\r\n}\r\nif (urb->actual_length)\r\ntty_insert_flip_char(&port->port, data[i], TTY_NORMAL);\r\n}\r\ntty_flip_buffer_push(&port->port);\r\n}\r\nstatic void qt_read_bulk_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct usb_serial *serial = get_usb_serial(port, __func__);\r\nstruct quatech_port *qt_port = qt_get_port_private(port);\r\nint result;\r\nif (urb->status) {\r\nqt_port->read_bulk_stopped = 1;\r\ndev_dbg(&urb->dev->dev,\r\n"%s - nonzero write bulk status received: %d\n",\r\n__func__, urb->status);\r\nreturn;\r\n}\r\ndev_dbg(&port->dev,\r\n"%s - port->rx_holding = %d\n", __func__, qt_port->rx_holding);\r\nif (port_paranoia_check(port, __func__) != 0) {\r\nqt_port->read_bulk_stopped = 1;\r\nreturn;\r\n}\r\nif (!serial)\r\nreturn;\r\nif (qt_port->close_pending == 1) {\r\ndev_dbg(&port->dev,\r\n"%s - (qt_port->close_pending == 1\n", __func__);\r\nqt_port->read_bulk_stopped = 1;\r\nreturn;\r\n}\r\nif (qt_port->rx_holding == 1) {\r\nqt_port->read_bulk_stopped = 1;\r\nreturn;\r\n}\r\nif (urb->status) {\r\nqt_port->read_bulk_stopped = 1;\r\ndev_dbg(&port->dev,\r\n"%s - nonzero read bulk status received: %d\n",\r\n__func__, urb->status);\r\nreturn;\r\n}\r\nif (urb->actual_length)\r\nqt_status_change_check(urb, qt_port, port);\r\nusb_fill_bulk_urb(port->read_urb, serial->dev,\r\nusb_rcvbulkpipe(serial->dev,\r\nport->bulk_in_endpointAddress),\r\nport->read_urb->transfer_buffer,\r\nport->read_urb->transfer_buffer_length,\r\nqt_read_bulk_callback, port);\r\nresult = usb_submit_urb(port->read_urb, GFP_ATOMIC);\r\nif (result)\r\ndev_dbg(&port->dev,\r\n"%s - failed resubmitting read urb, error %d",\r\n__func__, result);\r\nelse {\r\nif (urb->actual_length) {\r\ntty_flip_buffer_push(&port->port);\r\ntty_schedule_flip(&port->port);\r\n}\r\n}\r\nschedule_work(&port->work);\r\n}\r\nstatic int qt_get_device(struct usb_serial *serial,\r\nstruct qt_get_device_data *device_data)\r\n{\r\nint result;\r\nunsigned char *transfer_buffer;\r\ntransfer_buffer =\r\nkmalloc(sizeof(struct qt_get_device_data), GFP_KERNEL);\r\nif (!transfer_buffer)\r\nreturn -ENOMEM;\r\nresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nQT_SET_GET_DEVICE, 0xc0, 0, 0,\r\ntransfer_buffer,\r\nsizeof(struct qt_get_device_data), 300);\r\nif (result > 0)\r\nmemcpy(device_data, transfer_buffer,\r\nsizeof(struct qt_get_device_data));\r\nkfree(transfer_buffer);\r\nreturn result;\r\n}\r\nstatic int box_set_prebuffer_level(struct usb_serial *serial)\r\n{\r\nint result;\r\n__u16 buffer_length;\r\nbuffer_length = PREFUFF_LEVEL_CONSERVATIVE;\r\nresult = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT_GET_SET_PREBUF_TRIG_LVL, 0x40,\r\nbuffer_length, 0, NULL, 0, 300);\r\nreturn result;\r\n}\r\nstatic int box_set_atc(struct usb_serial *serial, __u16 n_mode)\r\n{\r\nint result;\r\n__u16 buffer_length;\r\nbuffer_length = PREFUFF_LEVEL_CONSERVATIVE;\r\nresult =\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT_SET_ATF, 0x40, n_mode, 0, NULL, 0, 300);\r\nreturn result;\r\n}\r\nstatic int qt_set_device(struct usb_serial *serial,\r\nstruct qt_get_device_data *device_data)\r\n{\r\nint result;\r\n__u16 length;\r\n__u16 port_settings;\r\nport_settings = ((__u16) (device_data->portb));\r\nport_settings = (port_settings << 8);\r\nport_settings += ((__u16) (device_data->porta));\r\nlength = sizeof(struct qt_get_device_data);\r\nresult = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT_SET_GET_DEVICE, 0x40, port_settings,\r\n0, NULL, 0, 300);\r\nreturn result;\r\n}\r\nstatic int qt_open_channel(struct usb_serial *serial, __u16 uart_num,\r\nstruct qt_open_channel_data *pdevice_data)\r\n{\r\nint result;\r\nresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nQT_OPEN_CLOSE_CHANNEL,\r\nUSBD_TRANSFER_DIRECTION_IN, 1, uart_num,\r\npdevice_data,\r\nsizeof(struct qt_open_channel_data), 300);\r\nreturn result;\r\n}\r\nstatic int qt_close_channel(struct usb_serial *serial, __u16 uart_num)\r\n{\r\nint result;\r\nresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nQT_OPEN_CLOSE_CHANNEL,\r\nUSBD_TRANSFER_DIRECTION_OUT, 0, uart_num,\r\nNULL, 0, 300);\r\nreturn result;\r\n}\r\nstatic int box_get_register(struct usb_serial *serial, unsigned short uart_num,\r\nunsigned short register_num, __u8 *p_value)\r\n{\r\nint result;\r\n__u16 current_length;\r\ncurrent_length = sizeof(struct qt_get_device_data);\r\nresult =\r\nusb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nQT_GET_SET_REGISTER, 0xC0, register_num,\r\nuart_num, (void *)p_value, sizeof(*p_value), 300);\r\nreturn result;\r\n}\r\nstatic int box_set_register(struct usb_serial *serial, unsigned short uart_num,\r\nunsigned short register_num, unsigned short value)\r\n{\r\nint result;\r\nunsigned short reg_and_byte;\r\nreg_and_byte = value;\r\nreg_and_byte = reg_and_byte << 8;\r\nreg_and_byte = reg_and_byte + register_num;\r\nresult =\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT_GET_SET_REGISTER, 0x40, reg_and_byte, uart_num,\r\nNULL, 0, 300);\r\nreturn result;\r\n}\r\nstatic int qt_setuart(struct usb_serial *serial, unsigned short uart_num,\r\nunsigned short default_divisor, unsigned char default_lcr)\r\n{\r\nint result;\r\nunsigned short uart_num_and_lcr;\r\nuart_num_and_lcr = (default_lcr << 8) + uart_num;\r\nresult =\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT_GET_SET_UART, 0x40, default_divisor,\r\nuart_num_and_lcr, NULL, 0, 300);\r\nreturn result;\r\n}\r\nstatic int box_set_hw_flow_ctrl(struct usb_serial *serial, unsigned int index,\r\nint b_set)\r\n{\r\n__u8 mcr = 0;\r\n__u8 msr = 0, mout_value = 0;\r\nunsigned int status;\r\nif (b_set == 1) {\r\nmcr = SERIAL_MCR_RTS;\r\n}\r\nelse {\r\nmcr = 0;\r\n}\r\nmout_value = mcr << 8;\r\nif (b_set == 1) {\r\nmsr = SERIAL_MSR_CTS;\r\n} else {\r\nmsr = 0;\r\n}\r\nmout_value |= msr;\r\nstatus =\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT_HW_FLOW_CONTROL_MASK, 0x40, mout_value,\r\nindex, NULL, 0, 300);\r\nreturn status;\r\n}\r\nstatic int box_set_sw_flow_ctrl(struct usb_serial *serial, __u16 index,\r\nunsigned char stop_char, unsigned char start_char)\r\n{\r\n__u16 n_sw_flow_out;\r\nint result;\r\nn_sw_flow_out = start_char << 8;\r\nn_sw_flow_out = (unsigned short)stop_char;\r\nresult =\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT_SW_FLOW_CONTROL_MASK, 0x40, n_sw_flow_out,\r\nindex, NULL, 0, 300);\r\nreturn result;\r\n}\r\nstatic int box_disable_sw_flow_ctrl(struct usb_serial *serial, __u16 index)\r\n{\r\nint result;\r\nresult =\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT_SW_FLOW_CONTROL_DISABLE, 0x40, 0, index,\r\nNULL, 0, 300);\r\nreturn result;\r\n}\r\nstatic int qt_startup(struct usb_serial *serial)\r\n{\r\nstruct device *dev = &serial->dev->dev;\r\nstruct usb_serial_port *port;\r\nstruct quatech_port *qt_port;\r\nstruct qt_get_device_data device_data;\r\nint i;\r\nint status;\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nqt_port = kzalloc(sizeof(*qt_port), GFP_KERNEL);\r\nif (!qt_port) {\r\nfor (--i; i >= 0; i--) {\r\nport = serial->port[i];\r\nkfree(usb_get_serial_port_data(port));\r\nusb_set_serial_port_data(port, NULL);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&qt_port->lock);\r\nusb_set_serial_port_data(port, qt_port);\r\n}\r\nstatus = qt_get_device(serial, &device_data);\r\nif (status < 0)\r\ngoto startup_error;\r\ndev_dbg(dev, "device_data.portb = 0x%x\n", device_data.portb);\r\ndevice_data.portb &= ~FULLPWRBIT;\r\ndev_dbg(dev, "Changing device_data.portb to 0x%x\n", device_data.portb);\r\nstatus = qt_set_device(serial, &device_data);\r\nif (status < 0) {\r\ndev_dbg(dev, "qt_set_device failed\n");\r\ngoto startup_error;\r\n}\r\nstatus = qt_get_device(serial, &device_data);\r\nif (status < 0) {\r\ndev_dbg(dev, "qt_get_device failed\n");\r\ngoto startup_error;\r\n}\r\nswitch (serial->dev->descriptor.idProduct) {\r\ncase QUATECH_DSU100:\r\ncase QUATECH_QSU100:\r\ncase QUATECH_ESU100A:\r\ncase QUATECH_ESU100B:\r\ncase QUATECH_HSU100A:\r\ncase QUATECH_HSU100B:\r\ncase QUATECH_HSU100C:\r\ncase QUATECH_HSU100D:\r\ndevice_data.porta &= ~(RR_BITS | DUPMODE_BITS);\r\ndevice_data.porta |= CLKS_X4;\r\ndevice_data.portb &= ~(LOOPMODE_BITS);\r\ndevice_data.portb |= RS232_MODE;\r\nbreak;\r\ncase QUATECH_SSU200:\r\ncase QUATECH_DSU200:\r\ncase QUATECH_QSU200:\r\ncase QUATECH_ESU200A:\r\ncase QUATECH_ESU200B:\r\ncase QUATECH_HSU200A:\r\ncase QUATECH_HSU200B:\r\ncase QUATECH_HSU200C:\r\ncase QUATECH_HSU200D:\r\ndevice_data.porta &= ~(RR_BITS | DUPMODE_BITS);\r\ndevice_data.porta |= CLKS_X4;\r\ndevice_data.portb &= ~(LOOPMODE_BITS);\r\ndevice_data.portb |= ALL_LOOPBACK;\r\nbreak;\r\ndefault:\r\ndevice_data.porta &= ~(RR_BITS | DUPMODE_BITS);\r\ndevice_data.porta |= CLKS_X4;\r\ndevice_data.portb &= ~(LOOPMODE_BITS);\r\ndevice_data.portb |= RS232_MODE;\r\nbreak;\r\n}\r\nstatus = box_set_prebuffer_level(serial);\r\nif (status < 0) {\r\ndev_dbg(dev, "box_set_prebuffer_level failed\n");\r\ngoto startup_error;\r\n}\r\nstatus = box_set_atc(serial, ATC_DISABLED);\r\nif (status < 0) {\r\ndev_dbg(dev, "box_set_atc failed\n");\r\ngoto startup_error;\r\n}\r\ndev_dbg(dev, "device_data.portb = 0x%x\n", device_data.portb);\r\ndevice_data.portb |= NEXT_BOARD_POWER_BIT;\r\ndev_dbg(dev, "Changing device_data.portb to 0x%x\n", device_data.portb);\r\nstatus = qt_set_device(serial, &device_data);\r\nif (status < 0) {\r\ndev_dbg(dev, "qt_set_device failed\n");\r\ngoto startup_error;\r\n}\r\nreturn 0;\r\nstartup_error:\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nqt_port = qt_get_port_private(port);\r\nkfree(qt_port);\r\nusb_set_serial_port_data(port, NULL);\r\n}\r\nreturn -EIO;\r\n}\r\nstatic void qt_release(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct quatech_port *qt_port;\r\nint i;\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nif (!port)\r\ncontinue;\r\nqt_port = usb_get_serial_port_data(port);\r\nkfree(qt_port);\r\nusb_set_serial_port_data(port, NULL);\r\n}\r\n}\r\nstatic void qt_submit_urb_from_open(struct usb_serial *serial,\r\nstruct usb_serial_port *port)\r\n{\r\nint result;\r\nstruct usb_serial_port *port0 = serial->port[0];\r\nusb_fill_int_urb(port0->interrupt_in_urb,\r\nserial->dev,\r\nusb_rcvintpipe(serial->dev,\r\nport0->interrupt_in_endpointAddress),\r\nport0->interrupt_in_buffer,\r\nport0->interrupt_in_urb->transfer_buffer_length,\r\nqt_interrupt_callback, serial,\r\nport0->interrupt_in_urb->interval);\r\nresult = usb_submit_urb(port0->interrupt_in_urb,\r\nGFP_KERNEL);\r\nif (result) {\r\ndev_err(&port->dev,\r\n"%s - Error %d submitting interrupt urb\n",\r\n__func__, result);\r\n}\r\n}\r\nstatic int qt_open(struct tty_struct *tty,\r\nstruct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial;\r\nstruct quatech_port *quatech_port;\r\nstruct quatech_port *port0;\r\nstruct qt_open_channel_data channel_data;\r\nint result;\r\nif (port_paranoia_check(port, __func__))\r\nreturn -ENODEV;\r\nserial = port->serial;\r\nif (serial_paranoia_check(serial, __func__))\r\nreturn -ENODEV;\r\nquatech_port = qt_get_port_private(port);\r\nport0 = qt_get_port_private(serial->port[0]);\r\nif (quatech_port == NULL || port0 == NULL)\r\nreturn -ENODEV;\r\nusb_clear_halt(serial->dev, port->write_urb->pipe);\r\nusb_clear_halt(serial->dev, port->read_urb->pipe);\r\nport0->open_ports++;\r\nresult = qt_get_device(serial, &port0->device_data);\r\nresult = qt_open_channel(serial, port->port_number, &channel_data);\r\nif (result < 0) {\r\ndev_dbg(&port->dev, "qt_open_channel failed\n");\r\nreturn result;\r\n}\r\ndev_dbg(&port->dev, "qt_open_channel completed.\n");\r\nquatech_port->shadow_lsr = channel_data.line_status &\r\n(SERIAL_LSR_OE | SERIAL_LSR_PE | SERIAL_LSR_FE | SERIAL_LSR_BI);\r\nquatech_port->shadow_msr = channel_data.modem_status &\r\n(SERIAL_MSR_CTS | SERIAL_MSR_DSR | SERIAL_MSR_RI | SERIAL_MSR_CD);\r\nresult = qt_setuart(serial, port->port_number, DEFAULT_DIVISOR, DEFAULT_LCR);\r\nif (result < 0) {\r\ndev_dbg(&port->dev, "qt_setuart failed\n");\r\nreturn result;\r\n}\r\ndev_dbg(&port->dev, "qt_setuart completed.\n");\r\nif (port0->open_ports == 1) {\r\nif (serial->port[0]->interrupt_in_buffer == NULL)\r\nqt_submit_urb_from_open(serial, port);\r\n}\r\ndev_dbg(&port->dev, "minor number is %d\n", port->minor);\r\ndev_dbg(&port->dev,\r\n"Bulkin endpoint is %d\n", port->bulk_in_endpointAddress);\r\ndev_dbg(&port->dev,\r\n"BulkOut endpoint is %d\n", port->bulk_out_endpointAddress);\r\ndev_dbg(&port->dev, "Interrupt endpoint is %d\n",\r\nport->interrupt_in_endpointAddress);\r\ndev_dbg(&port->dev, "port's number in the device is %d\n",\r\nquatech_port->port_num);\r\nquatech_port->read_urb = port->read_urb;\r\nusb_fill_bulk_urb(quatech_port->read_urb,\r\nserial->dev,\r\nusb_rcvbulkpipe(serial->dev,\r\nport->bulk_in_endpointAddress),\r\nport->bulk_in_buffer,\r\nquatech_port->read_urb->transfer_buffer_length,\r\nqt_read_bulk_callback, quatech_port);\r\ndev_dbg(&port->dev, "qt_open: bulkin endpoint is %d\n",\r\nport->bulk_in_endpointAddress);\r\nquatech_port->read_urb_busy = true;\r\nresult = usb_submit_urb(quatech_port->read_urb, GFP_KERNEL);\r\nif (result) {\r\ndev_err(&port->dev,\r\n"%s - Error %d submitting control urb\n",\r\n__func__, result);\r\nquatech_port->read_urb_busy = false;\r\n}\r\ninit_waitqueue_head(&quatech_port->wait);\r\ninit_waitqueue_head(&quatech_port->msr_wait);\r\nmemset(&(quatech_port->icount), 0x00, sizeof(quatech_port->icount));\r\nreturn 0;\r\n}\r\nstatic int qt_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial;\r\nint chars = 0;\r\nserial = get_usb_serial(port, __func__);\r\nif (serial->num_bulk_out) {\r\nif (port->write_urb->status == -EINPROGRESS)\r\nchars = port->write_urb->transfer_buffer_length;\r\n}\r\nreturn chars;\r\n}\r\nstatic void qt_block_until_empty(struct tty_struct *tty,\r\nstruct quatech_port *qt_port)\r\n{\r\nint timeout = HZ / 10;\r\nint wait = 30;\r\nint count;\r\nwhile (1) {\r\ncount = qt_chars_in_buffer(tty);\r\nif (count <= 0)\r\nreturn;\r\ninterruptible_sleep_on_timeout(&qt_port->wait, timeout);\r\nwait--;\r\nif (wait == 0) {\r\ndev_dbg(&qt_port->port->dev, "%s - TIMEOUT", __func__);\r\nreturn;\r\n} else {\r\nwait = 30;\r\n}\r\n}\r\n}\r\nstatic void qt_close(struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct quatech_port *qt_port;\r\nstruct quatech_port *port0;\r\nstruct tty_struct *tty;\r\nint status;\r\nunsigned int index;\r\nstatus = 0;\r\ntty = tty_port_tty_get(&port->port);\r\nindex = port->port_number;\r\nqt_port = qt_get_port_private(port);\r\nport0 = qt_get_port_private(serial->port[0]);\r\nif (serial->num_bulk_out)\r\nusb_unlink_urb(port->write_urb);\r\nif (serial->num_bulk_in)\r\nusb_unlink_urb(port->read_urb);\r\nif (serial->dev)\r\nqt_block_until_empty(tty, qt_port);\r\ntty_kref_put(tty);\r\nstatus = qt_close_channel(serial, index);\r\nif (status < 0)\r\ndev_dbg(&port->dev, "%s - qt_close_channel failed.\n", __func__);\r\nport0->open_ports--;\r\ndev_dbg(&port->dev, "qt_num_open_ports in close%d\n", port0->open_ports);\r\nif (port0->open_ports == 0) {\r\nif (serial->port[0]->interrupt_in_urb) {\r\ndev_dbg(&port->dev, "Shutdown interrupt_in_urb\n");\r\nusb_kill_urb(serial->port[0]->interrupt_in_urb);\r\n}\r\n}\r\nif (qt_port->write_urb) {\r\nkfree(qt_port->write_urb->transfer_buffer);\r\nusb_free_urb(qt_port->write_urb);\r\n}\r\n}\r\nstatic int qt_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst unsigned char *buf, int count)\r\n{\r\nint result;\r\nstruct usb_serial *serial = get_usb_serial(port, __func__);\r\nif (serial == NULL)\r\nreturn -ENODEV;\r\nif (count == 0) {\r\ndev_dbg(&port->dev,\r\n"%s - write request of 0 bytes\n", __func__);\r\nreturn 0;\r\n}\r\nif (serial->num_bulk_out) {\r\nif (port->write_urb->status == -EINPROGRESS) {\r\ndev_dbg(&port->dev, "%s - already writing\n", __func__);\r\nreturn 0;\r\n}\r\ncount =\r\n(count > port->bulk_out_size) ? port->bulk_out_size : count;\r\nmemcpy(port->write_urb->transfer_buffer, buf, count);\r\nusb_fill_bulk_urb(port->write_urb, serial->dev,\r\nusb_sndbulkpipe(serial->dev,\r\nport->\r\nbulk_out_endpointAddress),\r\nport->write_urb->transfer_buffer, count,\r\nqt_write_bulk_callback, port);\r\nresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\r\nif (result)\r\ndev_dbg(&port->dev,\r\n"%s - failed submitting write urb, error %d\n",\r\n__func__, result);\r\nelse\r\nresult = count;\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qt_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial;\r\nstruct quatech_port *qt_port;\r\nint retval = -EINVAL;\r\nif (port_paranoia_check(port, __func__))\r\nreturn -1;\r\nserial = get_usb_serial(port, __func__);\r\nif (!serial)\r\nreturn -ENODEV;\r\nqt_port = qt_get_port_private(port);\r\nmutex_lock(&qt_port->lock);\r\nif (serial->num_bulk_out) {\r\nif (port->write_urb->status != -EINPROGRESS)\r\nretval = port->bulk_out_size;\r\n}\r\nmutex_unlock(&qt_port->lock);\r\nreturn retval;\r\n}\r\nstatic int qt_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct quatech_port *qt_port = qt_get_port_private(port);\r\nunsigned int index;\r\ndev_dbg(&port->dev, "%s cmd 0x%04x\n", __func__, cmd);\r\nindex = port->port_number;\r\nif (cmd == TIOCMIWAIT) {\r\nwhile (qt_port != NULL) {\r\ninterruptible_sleep_on(&qt_port->msr_wait);\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nelse {\r\nchar diff = qt_port->diff_status;\r\nif (diff == 0)\r\nreturn -EIO;\r\nqt_port->diff_status = 0;\r\nif (((arg & TIOCM_RNG)\r\n&& (diff & SERIAL_MSR_RI))\r\n|| ((arg & TIOCM_DSR)\r\n&& (diff & SERIAL_MSR_DSR))\r\n|| ((arg & TIOCM_CD)\r\n&& (diff & SERIAL_MSR_CD))\r\n|| ((arg & TIOCM_CTS)\r\n&& (diff & SERIAL_MSR_CTS))) {\r\nreturn 0;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\ndev_dbg(&port->dev, "%s -No ioctl for that one.\n", __func__);\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void qt_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct ktermios *termios = &tty->termios;\r\nunsigned char new_lcr = 0;\r\nunsigned int cflag = termios->c_cflag;\r\nunsigned int index;\r\nint baud, divisor, remainder;\r\nint status;\r\nindex = port->port_number;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nnew_lcr |= SERIAL_5_DATA;\r\nbreak;\r\ncase CS6:\r\nnew_lcr |= SERIAL_6_DATA;\r\nbreak;\r\ncase CS7:\r\nnew_lcr |= SERIAL_7_DATA;\r\nbreak;\r\ndefault:\r\ntermios->c_cflag &= ~CSIZE;\r\ntermios->c_cflag |= CS8;\r\ncase CS8:\r\nnew_lcr |= SERIAL_8_DATA;\r\nbreak;\r\n}\r\nif (cflag & PARENB) {\r\nif (cflag & PARODD)\r\nnew_lcr |= SERIAL_ODD_PARITY;\r\nelse\r\nnew_lcr |= SERIAL_EVEN_PARITY;\r\n}\r\nif (cflag & CSTOPB)\r\nnew_lcr |= SERIAL_TWO_STOPB;\r\nelse\r\nnew_lcr |= SERIAL_ONE_STOPB;\r\ndev_dbg(&port->dev, "%s - 4\n", __func__);\r\nbaud = tty_get_baud_rate(tty);\r\nif (!baud)\r\nbaud = 9600;\r\ndev_dbg(&port->dev, "%s - got baud = %d\n", __func__, baud);\r\ndivisor = MAX_BAUD_RATE / baud;\r\nremainder = MAX_BAUD_RATE % baud;\r\nif (((remainder * 2) >= baud) && (baud != 110))\r\ndivisor++;\r\nstatus =\r\nqt_setuart(port->serial, index, (unsigned short)divisor, new_lcr);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "qt_setuart failed\n");\r\nreturn;\r\n}\r\nif (cflag & CRTSCTS) {\r\ndev_dbg(&port->dev, "%s - Enabling HW flow control\n", __func__);\r\nstatus = box_set_hw_flow_ctrl(port->serial, index, 1);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "box_set_hw_flow_ctrl failed\n");\r\nreturn;\r\n}\r\n} else {\r\ndev_dbg(&port->dev,\r\n"%s - disabling HW flow control\n", __func__);\r\nstatus = box_set_hw_flow_ctrl(port->serial, index, 0);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "box_set_hw_flow_ctrl failed\n");\r\nreturn;\r\n}\r\n}\r\nif (I_IXOFF(tty) || I_IXON(tty)) {\r\nunsigned char stop_char = STOP_CHAR(tty);\r\nunsigned char start_char = START_CHAR(tty);\r\nstatus =\r\nbox_set_sw_flow_ctrl(port->serial, index, stop_char,\r\nstart_char);\r\nif (status < 0)\r\ndev_dbg(&port->dev,\r\n"box_set_sw_flow_ctrl (enabled) failed\n");\r\n} else {\r\nstatus = box_disable_sw_flow_ctrl(port->serial, index);\r\nif (status < 0)\r\ndev_dbg(&port->dev,\r\n"box_set_sw_flow_ctrl (diabling) failed\n");\r\n}\r\ntermios->c_cflag &= ~CMSPAR;\r\n}\r\nstatic void qt_break(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = get_usb_serial(port, __func__);\r\nstruct quatech_port *qt_port;\r\nu16 index, onoff;\r\nunsigned int result;\r\nindex = port->port_number;\r\nqt_port = qt_get_port_private(port);\r\nif (break_state == -1)\r\nonoff = 1;\r\nelse\r\nonoff = 0;\r\nmutex_lock(&qt_port->lock);\r\nresult =\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT_BREAK_CONTROL, 0x40, onoff, index, NULL, 0, 300);\r\nmutex_unlock(&qt_port->lock);\r\n}\r\nstatic inline int qt_real_tiocmget(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nstruct usb_serial *serial)\r\n{\r\nu8 mcr;\r\nu8 msr;\r\nunsigned int result = 0;\r\nint status;\r\nunsigned int index;\r\nindex = port->port_number;\r\nstatus =\r\nbox_get_register(port->serial, index, MODEM_CONTROL_REGISTER, &mcr);\r\nif (status >= 0) {\r\nstatus =\r\nbox_get_register(port->serial, index,\r\nMODEM_STATUS_REGISTER, &msr);\r\n}\r\nif (status >= 0) {\r\nresult = ((mcr & SERIAL_MCR_DTR) ? TIOCM_DTR : 0)\r\n| ((mcr & SERIAL_MCR_RTS) ? TIOCM_RTS : 0)\r\n| ((msr & SERIAL_MSR_CTS) ? TIOCM_CTS : 0)\r\n| ((msr & SERIAL_MSR_CD) ? TIOCM_CAR : 0)\r\n| ((msr & SERIAL_MSR_RI) ? TIOCM_RI : 0)\r\n| ((msr & SERIAL_MSR_DSR) ? TIOCM_DSR : 0);\r\nreturn result;\r\n} else\r\nreturn -ESPIPE;\r\n}\r\nstatic inline int qt_real_tiocmset(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nstruct usb_serial *serial,\r\nunsigned int value)\r\n{\r\nu8 mcr;\r\nint status;\r\nunsigned int index;\r\nindex = port->port_number;\r\nstatus =\r\nbox_get_register(port->serial, index, MODEM_CONTROL_REGISTER, &mcr);\r\nif (status < 0)\r\nreturn -ESPIPE;\r\nmcr &= ~(SERIAL_MCR_RTS | SERIAL_MCR_DTR | SERIAL_MCR_LOOP);\r\nif (value & TIOCM_RTS)\r\nmcr |= SERIAL_MCR_RTS;\r\nif (value & TIOCM_DTR)\r\nmcr |= SERIAL_MCR_DTR;\r\nif (value & TIOCM_LOOP)\r\nmcr |= SERIAL_MCR_LOOP;\r\nstatus =\r\nbox_set_register(port->serial, index, MODEM_CONTROL_REGISTER, mcr);\r\nif (status < 0)\r\nreturn -ESPIPE;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int qt_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = get_usb_serial(port, __func__);\r\nstruct quatech_port *qt_port = qt_get_port_private(port);\r\nint retval;\r\nif (!serial)\r\nreturn -ENODEV;\r\nmutex_lock(&qt_port->lock);\r\nretval = qt_real_tiocmget(tty, port, serial);\r\nmutex_unlock(&qt_port->lock);\r\nreturn retval;\r\n}\r\nstatic int qt_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = get_usb_serial(port, __func__);\r\nstruct quatech_port *qt_port = qt_get_port_private(port);\r\nint retval;\r\nif (!serial)\r\nreturn -ENODEV;\r\nmutex_lock(&qt_port->lock);\r\nretval = qt_real_tiocmset(tty, port, serial, set);\r\nmutex_unlock(&qt_port->lock);\r\nreturn retval;\r\n}\r\nstatic void qt_throttle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = get_usb_serial(port, __func__);\r\nstruct quatech_port *qt_port;\r\nif (!serial)\r\nreturn;\r\nqt_port = qt_get_port_private(port);\r\nmutex_lock(&qt_port->lock);\r\nqt_port->rx_holding = 1;\r\nmutex_unlock(&qt_port->lock);\r\n}\r\nstatic void qt_submit_urb_from_unthrottle(struct usb_serial_port *port,\r\nstruct usb_serial *serial)\r\n{\r\nint result;\r\nusb_fill_bulk_urb(port->read_urb, serial->dev,\r\nusb_rcvbulkpipe(serial->dev,\r\nport->bulk_in_endpointAddress),\r\nport->read_urb->transfer_buffer,\r\nport->read_urb->transfer_buffer_length,\r\nqt_read_bulk_callback, port);\r\nresult = usb_submit_urb(port->read_urb, GFP_ATOMIC);\r\nif (result)\r\ndev_err(&port->dev,\r\n"%s - failed restarting read urb, error %d\n",\r\n__func__, result);\r\n}\r\nstatic void qt_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = get_usb_serial(port, __func__);\r\nstruct quatech_port *qt_port;\r\nif (!serial)\r\nreturn;\r\nqt_port = qt_get_port_private(port);\r\nmutex_lock(&qt_port->lock);\r\nif (qt_port->rx_holding == 1) {\r\ndev_dbg(&port->dev, "%s -qt_port->rx_holding == 1\n", __func__);\r\nqt_port->rx_holding = 0;\r\ndev_dbg(&port->dev, "%s - qt_port->rx_holding = 0\n", __func__);\r\nif ((serial->num_bulk_in) && (qt_port->read_bulk_stopped == 1))\r\nqt_submit_urb_from_unthrottle(port, serial);\r\n}\r\nmutex_unlock(&qt_port->lock);\r\n}\r\nstatic int qt_calc_num_ports(struct usb_serial *serial)\r\n{\r\nint num_ports;\r\nnum_ports =\r\n(serial->interface->cur_altsetting->desc.bNumEndpoints - 1) / 2;\r\nreturn num_ports;\r\n}
