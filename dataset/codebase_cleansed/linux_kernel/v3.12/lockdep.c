static int graph_lock(void)\r\n{\r\narch_spin_lock(&lockdep_lock);\r\nif (!debug_locks) {\r\narch_spin_unlock(&lockdep_lock);\r\nreturn 0;\r\n}\r\ncurrent->lockdep_recursion++;\r\nreturn 1;\r\n}\r\nstatic inline int graph_unlock(void)\r\n{\r\nif (debug_locks && !arch_spin_is_locked(&lockdep_lock)) {\r\nreturn DEBUG_LOCKS_WARN_ON(1);\r\n}\r\ncurrent->lockdep_recursion--;\r\narch_spin_unlock(&lockdep_lock);\r\nreturn 0;\r\n}\r\nstatic inline int debug_locks_off_graph_unlock(void)\r\n{\r\nint ret = debug_locks_off();\r\narch_spin_unlock(&lockdep_lock);\r\nreturn ret;\r\n}\r\nstatic inline struct lock_class *hlock_class(struct held_lock *hlock)\r\n{\r\nif (!hlock->class_idx) {\r\nDEBUG_LOCKS_WARN_ON(1);\r\nreturn NULL;\r\n}\r\nreturn lock_classes + hlock->class_idx - 1;\r\n}\r\nstatic inline u64 lockstat_clock(void)\r\n{\r\nreturn local_clock();\r\n}\r\nstatic int lock_point(unsigned long points[], unsigned long ip)\r\n{\r\nint i;\r\nfor (i = 0; i < LOCKSTAT_POINTS; i++) {\r\nif (points[i] == 0) {\r\npoints[i] = ip;\r\nbreak;\r\n}\r\nif (points[i] == ip)\r\nbreak;\r\n}\r\nreturn i;\r\n}\r\nstatic void lock_time_inc(struct lock_time *lt, u64 time)\r\n{\r\nif (time > lt->max)\r\nlt->max = time;\r\nif (time < lt->min || !lt->nr)\r\nlt->min = time;\r\nlt->total += time;\r\nlt->nr++;\r\n}\r\nstatic inline void lock_time_add(struct lock_time *src, struct lock_time *dst)\r\n{\r\nif (!src->nr)\r\nreturn;\r\nif (src->max > dst->max)\r\ndst->max = src->max;\r\nif (src->min < dst->min || !dst->nr)\r\ndst->min = src->min;\r\ndst->total += src->total;\r\ndst->nr += src->nr;\r\n}\r\nstruct lock_class_stats lock_stats(struct lock_class *class)\r\n{\r\nstruct lock_class_stats stats;\r\nint cpu, i;\r\nmemset(&stats, 0, sizeof(struct lock_class_stats));\r\nfor_each_possible_cpu(cpu) {\r\nstruct lock_class_stats *pcs =\r\n&per_cpu(cpu_lock_stats, cpu)[class - lock_classes];\r\nfor (i = 0; i < ARRAY_SIZE(stats.contention_point); i++)\r\nstats.contention_point[i] += pcs->contention_point[i];\r\nfor (i = 0; i < ARRAY_SIZE(stats.contending_point); i++)\r\nstats.contending_point[i] += pcs->contending_point[i];\r\nlock_time_add(&pcs->read_waittime, &stats.read_waittime);\r\nlock_time_add(&pcs->write_waittime, &stats.write_waittime);\r\nlock_time_add(&pcs->read_holdtime, &stats.read_holdtime);\r\nlock_time_add(&pcs->write_holdtime, &stats.write_holdtime);\r\nfor (i = 0; i < ARRAY_SIZE(stats.bounces); i++)\r\nstats.bounces[i] += pcs->bounces[i];\r\n}\r\nreturn stats;\r\n}\r\nvoid clear_lock_stats(struct lock_class *class)\r\n{\r\nint cpu;\r\nfor_each_possible_cpu(cpu) {\r\nstruct lock_class_stats *cpu_stats =\r\n&per_cpu(cpu_lock_stats, cpu)[class - lock_classes];\r\nmemset(cpu_stats, 0, sizeof(struct lock_class_stats));\r\n}\r\nmemset(class->contention_point, 0, sizeof(class->contention_point));\r\nmemset(class->contending_point, 0, sizeof(class->contending_point));\r\n}\r\nstatic struct lock_class_stats *get_lock_stats(struct lock_class *class)\r\n{\r\nreturn &get_cpu_var(cpu_lock_stats)[class - lock_classes];\r\n}\r\nstatic void put_lock_stats(struct lock_class_stats *stats)\r\n{\r\nput_cpu_var(cpu_lock_stats);\r\n}\r\nstatic void lock_release_holdtime(struct held_lock *hlock)\r\n{\r\nstruct lock_class_stats *stats;\r\nu64 holdtime;\r\nif (!lock_stat)\r\nreturn;\r\nholdtime = lockstat_clock() - hlock->holdtime_stamp;\r\nstats = get_lock_stats(hlock_class(hlock));\r\nif (hlock->read)\r\nlock_time_inc(&stats->read_holdtime, holdtime);\r\nelse\r\nlock_time_inc(&stats->write_holdtime, holdtime);\r\nput_lock_stats(stats);\r\n}\r\nstatic inline void lock_release_holdtime(struct held_lock *hlock)\r\n{\r\n}\r\nvoid lockdep_off(void)\r\n{\r\ncurrent->lockdep_recursion++;\r\n}\r\nvoid lockdep_on(void)\r\n{\r\ncurrent->lockdep_recursion--;\r\n}\r\nstatic int class_filter(struct lock_class *class)\r\n{\r\n#if 0\r\nif (class->name_version == 1 &&\r\n!strcmp(class->name, "lockname"))\r\nreturn 1;\r\nif (class->name_version == 1 &&\r\n!strcmp(class->name, "&struct->lockfield"))\r\nreturn 1;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int verbose(struct lock_class *class)\r\n{\r\n#if VERBOSE\r\nreturn class_filter(class);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void print_lockdep_off(const char *bug_msg)\r\n{\r\nprintk(KERN_DEBUG "%s\n", bug_msg);\r\nprintk(KERN_DEBUG "turning off the locking correctness validator.\n");\r\nprintk(KERN_DEBUG "Please attach the output of /proc/lock_stat to the bug report\n");\r\n}\r\nstatic int save_trace(struct stack_trace *trace)\r\n{\r\ntrace->nr_entries = 0;\r\ntrace->max_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries;\r\ntrace->entries = stack_trace + nr_stack_trace_entries;\r\ntrace->skip = 3;\r\nsave_stack_trace(trace);\r\nif (trace->nr_entries != 0 &&\r\ntrace->entries[trace->nr_entries-1] == ULONG_MAX)\r\ntrace->nr_entries--;\r\ntrace->max_entries = trace->nr_entries;\r\nnr_stack_trace_entries += trace->nr_entries;\r\nif (nr_stack_trace_entries >= MAX_STACK_TRACE_ENTRIES-1) {\r\nif (!debug_locks_off_graph_unlock())\r\nreturn 0;\r\nprint_lockdep_off("BUG: MAX_STACK_TRACE_ENTRIES too low!");\r\ndump_stack();\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nconst char * __get_key_name(struct lockdep_subclass_key *key, char *str)\r\n{\r\nreturn kallsyms_lookup((unsigned long)key, NULL, NULL, NULL, str);\r\n}\r\nstatic inline unsigned long lock_flag(enum lock_usage_bit bit)\r\n{\r\nreturn 1UL << bit;\r\n}\r\nstatic char get_usage_char(struct lock_class *class, enum lock_usage_bit bit)\r\n{\r\nchar c = '.';\r\nif (class->usage_mask & lock_flag(bit + 2))\r\nc = '+';\r\nif (class->usage_mask & lock_flag(bit)) {\r\nc = '-';\r\nif (class->usage_mask & lock_flag(bit + 2))\r\nc = '?';\r\n}\r\nreturn c;\r\n}\r\nvoid get_usage_chars(struct lock_class *class, char usage[LOCK_USAGE_CHARS])\r\n{\r\nint i = 0;\r\n#define LOCKDEP_STATE(__STATE) \\r\nusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE); \\r\nusage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE##_READ);\r\n#include "lockdep_states.h"\r\n#undef LOCKDEP_STATE\r\nusage[i] = '\0';\r\n}\r\nstatic void __print_lock_name(struct lock_class *class)\r\n{\r\nchar str[KSYM_NAME_LEN];\r\nconst char *name;\r\nname = class->name;\r\nif (!name) {\r\nname = __get_key_name(class->key, str);\r\nprintk("%s", name);\r\n} else {\r\nprintk("%s", name);\r\nif (class->name_version > 1)\r\nprintk("#%d", class->name_version);\r\nif (class->subclass)\r\nprintk("/%d", class->subclass);\r\n}\r\n}\r\nstatic void print_lock_name(struct lock_class *class)\r\n{\r\nchar usage[LOCK_USAGE_CHARS];\r\nget_usage_chars(class, usage);\r\nprintk(" (");\r\n__print_lock_name(class);\r\nprintk("){%s}", usage);\r\n}\r\nstatic void print_lockdep_cache(struct lockdep_map *lock)\r\n{\r\nconst char *name;\r\nchar str[KSYM_NAME_LEN];\r\nname = lock->name;\r\nif (!name)\r\nname = __get_key_name(lock->key->subkeys, str);\r\nprintk("%s", name);\r\n}\r\nstatic void print_lock(struct held_lock *hlock)\r\n{\r\nprint_lock_name(hlock_class(hlock));\r\nprintk(", at: ");\r\nprint_ip_sym(hlock->acquire_ip);\r\n}\r\nstatic void lockdep_print_held_locks(struct task_struct *curr)\r\n{\r\nint i, depth = curr->lockdep_depth;\r\nif (!depth) {\r\nprintk("no locks held by %s/%d.\n", curr->comm, task_pid_nr(curr));\r\nreturn;\r\n}\r\nprintk("%d lock%s held by %s/%d:\n",\r\ndepth, depth > 1 ? "s" : "", curr->comm, task_pid_nr(curr));\r\nfor (i = 0; i < depth; i++) {\r\nprintk(" #%d: ", i);\r\nprint_lock(curr->held_locks + i);\r\n}\r\n}\r\nstatic void print_kernel_ident(void)\r\n{\r\nprintk("%s %.*s %s\n", init_utsname()->release,\r\n(int)strcspn(init_utsname()->version, " "),\r\ninit_utsname()->version,\r\nprint_tainted());\r\n}\r\nstatic int very_verbose(struct lock_class *class)\r\n{\r\n#if VERY_VERBOSE\r\nreturn class_filter(class);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int static_obj(void *obj)\r\n{\r\nunsigned long start = (unsigned long) &_stext,\r\nend = (unsigned long) &_end,\r\naddr = (unsigned long) obj;\r\nif ((addr >= start) && (addr < end))\r\nreturn 1;\r\nif (arch_is_kernel_data(addr))\r\nreturn 1;\r\nif (is_kernel_percpu_address(addr))\r\nreturn 1;\r\nreturn is_module_address(addr) || is_module_percpu_address(addr);\r\n}\r\nstatic int count_matching_names(struct lock_class *new_class)\r\n{\r\nstruct lock_class *class;\r\nint count = 0;\r\nif (!new_class->name)\r\nreturn 0;\r\nlist_for_each_entry(class, &all_lock_classes, lock_entry) {\r\nif (new_class->key - new_class->subclass == class->key)\r\nreturn class->name_version;\r\nif (class->name && !strcmp(class->name, new_class->name))\r\ncount = max(count, class->name_version);\r\n}\r\nreturn count + 1;\r\n}\r\nstatic inline struct lock_class *\r\nlook_up_lock_class(struct lockdep_map *lock, unsigned int subclass)\r\n{\r\nstruct lockdep_subclass_key *key;\r\nstruct list_head *hash_head;\r\nstruct lock_class *class;\r\n#ifdef CONFIG_DEBUG_LOCKDEP\r\nif (unlikely(!lockdep_initialized)) {\r\nlockdep_init();\r\nlockdep_init_error = 1;\r\nlock_init_error = lock->name;\r\nsave_stack_trace(&lockdep_init_trace);\r\n}\r\n#endif\r\nif (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {\r\ndebug_locks_off();\r\nprintk(KERN_ERR\r\n"BUG: looking up invalid subclass: %u\n", subclass);\r\nprintk(KERN_ERR\r\n"turning off the locking correctness validator.\n");\r\ndump_stack();\r\nreturn NULL;\r\n}\r\nif (unlikely(!lock->key))\r\nlock->key = (void *)lock;\r\nBUILD_BUG_ON(sizeof(struct lock_class_key) >\r\nsizeof(struct lockdep_map));\r\nkey = lock->key->subkeys + subclass;\r\nhash_head = classhashentry(key);\r\nlist_for_each_entry(class, hash_head, hash_entry) {\r\nif (class->key == key) {\r\nWARN_ON_ONCE(class->name != lock->name);\r\nreturn class;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline struct lock_class *\r\nregister_lock_class(struct lockdep_map *lock, unsigned int subclass, int force)\r\n{\r\nstruct lockdep_subclass_key *key;\r\nstruct list_head *hash_head;\r\nstruct lock_class *class;\r\nunsigned long flags;\r\nclass = look_up_lock_class(lock, subclass);\r\nif (likely(class))\r\ngoto out_set_class_cache;\r\nif (!static_obj(lock->key)) {\r\ndebug_locks_off();\r\nprintk("INFO: trying to register non-static key.\n");\r\nprintk("the code is fine but needs lockdep annotation.\n");\r\nprintk("turning off the locking correctness validator.\n");\r\ndump_stack();\r\nreturn NULL;\r\n}\r\nkey = lock->key->subkeys + subclass;\r\nhash_head = classhashentry(key);\r\nraw_local_irq_save(flags);\r\nif (!graph_lock()) {\r\nraw_local_irq_restore(flags);\r\nreturn NULL;\r\n}\r\nlist_for_each_entry(class, hash_head, hash_entry)\r\nif (class->key == key)\r\ngoto out_unlock_set;\r\nif (nr_lock_classes >= MAX_LOCKDEP_KEYS) {\r\nif (!debug_locks_off_graph_unlock()) {\r\nraw_local_irq_restore(flags);\r\nreturn NULL;\r\n}\r\nraw_local_irq_restore(flags);\r\nprint_lockdep_off("BUG: MAX_LOCKDEP_KEYS too low!");\r\ndump_stack();\r\nreturn NULL;\r\n}\r\nclass = lock_classes + nr_lock_classes++;\r\ndebug_atomic_inc(nr_unused_locks);\r\nclass->key = key;\r\nclass->name = lock->name;\r\nclass->subclass = subclass;\r\nINIT_LIST_HEAD(&class->lock_entry);\r\nINIT_LIST_HEAD(&class->locks_before);\r\nINIT_LIST_HEAD(&class->locks_after);\r\nclass->name_version = count_matching_names(class);\r\nlist_add_tail_rcu(&class->hash_entry, hash_head);\r\nlist_add_tail_rcu(&class->lock_entry, &all_lock_classes);\r\nif (verbose(class)) {\r\ngraph_unlock();\r\nraw_local_irq_restore(flags);\r\nprintk("\nnew class %p: %s", class->key, class->name);\r\nif (class->name_version > 1)\r\nprintk("#%d", class->name_version);\r\nprintk("\n");\r\ndump_stack();\r\nraw_local_irq_save(flags);\r\nif (!graph_lock()) {\r\nraw_local_irq_restore(flags);\r\nreturn NULL;\r\n}\r\n}\r\nout_unlock_set:\r\ngraph_unlock();\r\nraw_local_irq_restore(flags);\r\nout_set_class_cache:\r\nif (!subclass || force)\r\nlock->class_cache[0] = class;\r\nelse if (subclass < NR_LOCKDEP_CACHING_CLASSES)\r\nlock->class_cache[subclass] = class;\r\nif (DEBUG_LOCKS_WARN_ON(class->subclass != subclass))\r\nreturn NULL;\r\nreturn class;\r\n}\r\nstatic struct lock_list *alloc_list_entry(void)\r\n{\r\nif (nr_list_entries >= MAX_LOCKDEP_ENTRIES) {\r\nif (!debug_locks_off_graph_unlock())\r\nreturn NULL;\r\nprint_lockdep_off("BUG: MAX_LOCKDEP_ENTRIES too low!");\r\ndump_stack();\r\nreturn NULL;\r\n}\r\nreturn list_entries + nr_list_entries++;\r\n}\r\nstatic int add_lock_to_list(struct lock_class *class, struct lock_class *this,\r\nstruct list_head *head, unsigned long ip,\r\nint distance, struct stack_trace *trace)\r\n{\r\nstruct lock_list *entry;\r\nentry = alloc_list_entry();\r\nif (!entry)\r\nreturn 0;\r\nentry->class = this;\r\nentry->distance = distance;\r\nentry->trace = *trace;\r\nlist_add_tail_rcu(&entry->entry, head);\r\nreturn 1;\r\n}\r\nstatic inline void __cq_init(struct circular_queue *cq)\r\n{\r\ncq->front = cq->rear = 0;\r\nlockdep_dependency_gen_id++;\r\n}\r\nstatic inline int __cq_empty(struct circular_queue *cq)\r\n{\r\nreturn (cq->front == cq->rear);\r\n}\r\nstatic inline int __cq_full(struct circular_queue *cq)\r\n{\r\nreturn ((cq->rear + 1) & CQ_MASK) == cq->front;\r\n}\r\nstatic inline int __cq_enqueue(struct circular_queue *cq, unsigned long elem)\r\n{\r\nif (__cq_full(cq))\r\nreturn -1;\r\ncq->element[cq->rear] = elem;\r\ncq->rear = (cq->rear + 1) & CQ_MASK;\r\nreturn 0;\r\n}\r\nstatic inline int __cq_dequeue(struct circular_queue *cq, unsigned long *elem)\r\n{\r\nif (__cq_empty(cq))\r\nreturn -1;\r\n*elem = cq->element[cq->front];\r\ncq->front = (cq->front + 1) & CQ_MASK;\r\nreturn 0;\r\n}\r\nstatic inline unsigned int __cq_get_elem_count(struct circular_queue *cq)\r\n{\r\nreturn (cq->rear - cq->front) & CQ_MASK;\r\n}\r\nstatic inline void mark_lock_accessed(struct lock_list *lock,\r\nstruct lock_list *parent)\r\n{\r\nunsigned long nr;\r\nnr = lock - list_entries;\r\nWARN_ON(nr >= nr_list_entries);\r\nlock->parent = parent;\r\nlock->class->dep_gen_id = lockdep_dependency_gen_id;\r\n}\r\nstatic inline unsigned long lock_accessed(struct lock_list *lock)\r\n{\r\nunsigned long nr;\r\nnr = lock - list_entries;\r\nWARN_ON(nr >= nr_list_entries);\r\nreturn lock->class->dep_gen_id == lockdep_dependency_gen_id;\r\n}\r\nstatic inline struct lock_list *get_lock_parent(struct lock_list *child)\r\n{\r\nreturn child->parent;\r\n}\r\nstatic inline int get_lock_depth(struct lock_list *child)\r\n{\r\nint depth = 0;\r\nstruct lock_list *parent;\r\nwhile ((parent = get_lock_parent(child))) {\r\nchild = parent;\r\ndepth++;\r\n}\r\nreturn depth;\r\n}\r\nstatic int __bfs(struct lock_list *source_entry,\r\nvoid *data,\r\nint (*match)(struct lock_list *entry, void *data),\r\nstruct lock_list **target_entry,\r\nint forward)\r\n{\r\nstruct lock_list *entry;\r\nstruct list_head *head;\r\nstruct circular_queue *cq = &lock_cq;\r\nint ret = 1;\r\nif (match(source_entry, data)) {\r\n*target_entry = source_entry;\r\nret = 0;\r\ngoto exit;\r\n}\r\nif (forward)\r\nhead = &source_entry->class->locks_after;\r\nelse\r\nhead = &source_entry->class->locks_before;\r\nif (list_empty(head))\r\ngoto exit;\r\n__cq_init(cq);\r\n__cq_enqueue(cq, (unsigned long)source_entry);\r\nwhile (!__cq_empty(cq)) {\r\nstruct lock_list *lock;\r\n__cq_dequeue(cq, (unsigned long *)&lock);\r\nif (!lock->class) {\r\nret = -2;\r\ngoto exit;\r\n}\r\nif (forward)\r\nhead = &lock->class->locks_after;\r\nelse\r\nhead = &lock->class->locks_before;\r\nlist_for_each_entry(entry, head, entry) {\r\nif (!lock_accessed(entry)) {\r\nunsigned int cq_depth;\r\nmark_lock_accessed(entry, lock);\r\nif (match(entry, data)) {\r\n*target_entry = entry;\r\nret = 0;\r\ngoto exit;\r\n}\r\nif (__cq_enqueue(cq, (unsigned long)entry)) {\r\nret = -1;\r\ngoto exit;\r\n}\r\ncq_depth = __cq_get_elem_count(cq);\r\nif (max_bfs_queue_depth < cq_depth)\r\nmax_bfs_queue_depth = cq_depth;\r\n}\r\n}\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic inline int __bfs_forwards(struct lock_list *src_entry,\r\nvoid *data,\r\nint (*match)(struct lock_list *entry, void *data),\r\nstruct lock_list **target_entry)\r\n{\r\nreturn __bfs(src_entry, data, match, target_entry, 1);\r\n}\r\nstatic inline int __bfs_backwards(struct lock_list *src_entry,\r\nvoid *data,\r\nint (*match)(struct lock_list *entry, void *data),\r\nstruct lock_list **target_entry)\r\n{\r\nreturn __bfs(src_entry, data, match, target_entry, 0);\r\n}\r\nstatic noinline int\r\nprint_circular_bug_entry(struct lock_list *target, int depth)\r\n{\r\nif (debug_locks_silent)\r\nreturn 0;\r\nprintk("\n-> #%u", depth);\r\nprint_lock_name(target->class);\r\nprintk(":\n");\r\nprint_stack_trace(&target->trace, 6);\r\nreturn 0;\r\n}\r\nstatic void\r\nprint_circular_lock_scenario(struct held_lock *src,\r\nstruct held_lock *tgt,\r\nstruct lock_list *prt)\r\n{\r\nstruct lock_class *source = hlock_class(src);\r\nstruct lock_class *target = hlock_class(tgt);\r\nstruct lock_class *parent = prt->class;\r\nif (parent != source) {\r\nprintk("Chain exists of:\n ");\r\n__print_lock_name(source);\r\nprintk(" --> ");\r\n__print_lock_name(parent);\r\nprintk(" --> ");\r\n__print_lock_name(target);\r\nprintk("\n\n");\r\n}\r\nprintk(" Possible unsafe locking scenario:\n\n");\r\nprintk(" CPU0 CPU1\n");\r\nprintk(" ---- ----\n");\r\nprintk(" lock(");\r\n__print_lock_name(target);\r\nprintk(");\n");\r\nprintk(" lock(");\r\n__print_lock_name(parent);\r\nprintk(");\n");\r\nprintk(" lock(");\r\n__print_lock_name(target);\r\nprintk(");\n");\r\nprintk(" lock(");\r\n__print_lock_name(source);\r\nprintk(");\n");\r\nprintk("\n *** DEADLOCK ***\n\n");\r\n}\r\nstatic noinline int\r\nprint_circular_bug_header(struct lock_list *entry, unsigned int depth,\r\nstruct held_lock *check_src,\r\nstruct held_lock *check_tgt)\r\n{\r\nstruct task_struct *curr = current;\r\nif (debug_locks_silent)\r\nreturn 0;\r\nprintk("\n");\r\nprintk("======================================================\n");\r\nprintk("[ INFO: possible circular locking dependency detected ]\n");\r\nprint_kernel_ident();\r\nprintk("-------------------------------------------------------\n");\r\nprintk("%s/%d is trying to acquire lock:\n",\r\ncurr->comm, task_pid_nr(curr));\r\nprint_lock(check_src);\r\nprintk("\nbut task is already holding lock:\n");\r\nprint_lock(check_tgt);\r\nprintk("\nwhich lock already depends on the new lock.\n\n");\r\nprintk("\nthe existing dependency chain (in reverse order) is:\n");\r\nprint_circular_bug_entry(entry, depth);\r\nreturn 0;\r\n}\r\nstatic inline int class_equal(struct lock_list *entry, void *data)\r\n{\r\nreturn entry->class == data;\r\n}\r\nstatic noinline int print_circular_bug(struct lock_list *this,\r\nstruct lock_list *target,\r\nstruct held_lock *check_src,\r\nstruct held_lock *check_tgt)\r\n{\r\nstruct task_struct *curr = current;\r\nstruct lock_list *parent;\r\nstruct lock_list *first_parent;\r\nint depth;\r\nif (!debug_locks_off_graph_unlock() || debug_locks_silent)\r\nreturn 0;\r\nif (!save_trace(&this->trace))\r\nreturn 0;\r\ndepth = get_lock_depth(target);\r\nprint_circular_bug_header(target, depth, check_src, check_tgt);\r\nparent = get_lock_parent(target);\r\nfirst_parent = parent;\r\nwhile (parent) {\r\nprint_circular_bug_entry(parent, --depth);\r\nparent = get_lock_parent(parent);\r\n}\r\nprintk("\nother info that might help us debug this:\n\n");\r\nprint_circular_lock_scenario(check_src, check_tgt,\r\nfirst_parent);\r\nlockdep_print_held_locks(curr);\r\nprintk("\nstack backtrace:\n");\r\ndump_stack();\r\nreturn 0;\r\n}\r\nstatic noinline int print_bfs_bug(int ret)\r\n{\r\nif (!debug_locks_off_graph_unlock())\r\nreturn 0;\r\nWARN(1, "lockdep bfs error:%d\n", ret);\r\nreturn 0;\r\n}\r\nstatic int noop_count(struct lock_list *entry, void *data)\r\n{\r\n(*(unsigned long *)data)++;\r\nreturn 0;\r\n}\r\nunsigned long __lockdep_count_forward_deps(struct lock_list *this)\r\n{\r\nunsigned long count = 0;\r\nstruct lock_list *uninitialized_var(target_entry);\r\n__bfs_forwards(this, (void *)&count, noop_count, &target_entry);\r\nreturn count;\r\n}\r\nunsigned long lockdep_count_forward_deps(struct lock_class *class)\r\n{\r\nunsigned long ret, flags;\r\nstruct lock_list this;\r\nthis.parent = NULL;\r\nthis.class = class;\r\nlocal_irq_save(flags);\r\narch_spin_lock(&lockdep_lock);\r\nret = __lockdep_count_forward_deps(&this);\r\narch_spin_unlock(&lockdep_lock);\r\nlocal_irq_restore(flags);\r\nreturn ret;\r\n}\r\nunsigned long __lockdep_count_backward_deps(struct lock_list *this)\r\n{\r\nunsigned long count = 0;\r\nstruct lock_list *uninitialized_var(target_entry);\r\n__bfs_backwards(this, (void *)&count, noop_count, &target_entry);\r\nreturn count;\r\n}\r\nunsigned long lockdep_count_backward_deps(struct lock_class *class)\r\n{\r\nunsigned long ret, flags;\r\nstruct lock_list this;\r\nthis.parent = NULL;\r\nthis.class = class;\r\nlocal_irq_save(flags);\r\narch_spin_lock(&lockdep_lock);\r\nret = __lockdep_count_backward_deps(&this);\r\narch_spin_unlock(&lockdep_lock);\r\nlocal_irq_restore(flags);\r\nreturn ret;\r\n}\r\nstatic noinline int\r\ncheck_noncircular(struct lock_list *root, struct lock_class *target,\r\nstruct lock_list **target_entry)\r\n{\r\nint result;\r\ndebug_atomic_inc(nr_cyclic_checks);\r\nresult = __bfs_forwards(root, target, class_equal, target_entry);\r\nreturn result;\r\n}\r\nstatic inline int usage_match(struct lock_list *entry, void *bit)\r\n{\r\nreturn entry->class->usage_mask & (1 << (enum lock_usage_bit)bit);\r\n}\r\nstatic int\r\nfind_usage_forwards(struct lock_list *root, enum lock_usage_bit bit,\r\nstruct lock_list **target_entry)\r\n{\r\nint result;\r\ndebug_atomic_inc(nr_find_usage_forwards_checks);\r\nresult = __bfs_forwards(root, (void *)bit, usage_match, target_entry);\r\nreturn result;\r\n}\r\nstatic int\r\nfind_usage_backwards(struct lock_list *root, enum lock_usage_bit bit,\r\nstruct lock_list **target_entry)\r\n{\r\nint result;\r\ndebug_atomic_inc(nr_find_usage_backwards_checks);\r\nresult = __bfs_backwards(root, (void *)bit, usage_match, target_entry);\r\nreturn result;\r\n}\r\nstatic void print_lock_class_header(struct lock_class *class, int depth)\r\n{\r\nint bit;\r\nprintk("%*s->", depth, "");\r\nprint_lock_name(class);\r\nprintk(" ops: %lu", class->ops);\r\nprintk(" {\n");\r\nfor (bit = 0; bit < LOCK_USAGE_STATES; bit++) {\r\nif (class->usage_mask & (1 << bit)) {\r\nint len = depth;\r\nlen += printk("%*s %s", depth, "", usage_str[bit]);\r\nlen += printk(" at:\n");\r\nprint_stack_trace(class->usage_traces + bit, len);\r\n}\r\n}\r\nprintk("%*s }\n", depth, "");\r\nprintk("%*s ... key at: ",depth,"");\r\nprint_ip_sym((unsigned long)class->key);\r\n}\r\nstatic void __used\r\nprint_shortest_lock_dependencies(struct lock_list *leaf,\r\nstruct lock_list *root)\r\n{\r\nstruct lock_list *entry = leaf;\r\nint depth;\r\ndepth = get_lock_depth(leaf);\r\ndo {\r\nprint_lock_class_header(entry->class, depth);\r\nprintk("%*s ... acquired at:\n", depth, "");\r\nprint_stack_trace(&entry->trace, 2);\r\nprintk("\n");\r\nif (depth == 0 && (entry != root)) {\r\nprintk("lockdep:%s bad path found in chain graph\n", __func__);\r\nbreak;\r\n}\r\nentry = get_lock_parent(entry);\r\ndepth--;\r\n} while (entry && (depth >= 0));\r\nreturn;\r\n}\r\nstatic void\r\nprint_irq_lock_scenario(struct lock_list *safe_entry,\r\nstruct lock_list *unsafe_entry,\r\nstruct lock_class *prev_class,\r\nstruct lock_class *next_class)\r\n{\r\nstruct lock_class *safe_class = safe_entry->class;\r\nstruct lock_class *unsafe_class = unsafe_entry->class;\r\nstruct lock_class *middle_class = prev_class;\r\nif (middle_class == safe_class)\r\nmiddle_class = next_class;\r\nif (middle_class != unsafe_class) {\r\nprintk("Chain exists of:\n ");\r\n__print_lock_name(safe_class);\r\nprintk(" --> ");\r\n__print_lock_name(middle_class);\r\nprintk(" --> ");\r\n__print_lock_name(unsafe_class);\r\nprintk("\n\n");\r\n}\r\nprintk(" Possible interrupt unsafe locking scenario:\n\n");\r\nprintk(" CPU0 CPU1\n");\r\nprintk(" ---- ----\n");\r\nprintk(" lock(");\r\n__print_lock_name(unsafe_class);\r\nprintk(");\n");\r\nprintk(" local_irq_disable();\n");\r\nprintk(" lock(");\r\n__print_lock_name(safe_class);\r\nprintk(");\n");\r\nprintk(" lock(");\r\n__print_lock_name(middle_class);\r\nprintk(");\n");\r\nprintk(" <Interrupt>\n");\r\nprintk(" lock(");\r\n__print_lock_name(safe_class);\r\nprintk(");\n");\r\nprintk("\n *** DEADLOCK ***\n\n");\r\n}\r\nstatic int\r\nprint_bad_irq_dependency(struct task_struct *curr,\r\nstruct lock_list *prev_root,\r\nstruct lock_list *next_root,\r\nstruct lock_list *backwards_entry,\r\nstruct lock_list *forwards_entry,\r\nstruct held_lock *prev,\r\nstruct held_lock *next,\r\nenum lock_usage_bit bit1,\r\nenum lock_usage_bit bit2,\r\nconst char *irqclass)\r\n{\r\nif (!debug_locks_off_graph_unlock() || debug_locks_silent)\r\nreturn 0;\r\nprintk("\n");\r\nprintk("======================================================\n");\r\nprintk("[ INFO: %s-safe -> %s-unsafe lock order detected ]\n",\r\nirqclass, irqclass);\r\nprint_kernel_ident();\r\nprintk("------------------------------------------------------\n");\r\nprintk("%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] is trying to acquire:\n",\r\ncurr->comm, task_pid_nr(curr),\r\ncurr->hardirq_context, hardirq_count() >> HARDIRQ_SHIFT,\r\ncurr->softirq_context, softirq_count() >> SOFTIRQ_SHIFT,\r\ncurr->hardirqs_enabled,\r\ncurr->softirqs_enabled);\r\nprint_lock(next);\r\nprintk("\nand this task is already holding:\n");\r\nprint_lock(prev);\r\nprintk("which would create a new lock dependency:\n");\r\nprint_lock_name(hlock_class(prev));\r\nprintk(" ->");\r\nprint_lock_name(hlock_class(next));\r\nprintk("\n");\r\nprintk("\nbut this new dependency connects a %s-irq-safe lock:\n",\r\nirqclass);\r\nprint_lock_name(backwards_entry->class);\r\nprintk("\n... which became %s-irq-safe at:\n", irqclass);\r\nprint_stack_trace(backwards_entry->class->usage_traces + bit1, 1);\r\nprintk("\nto a %s-irq-unsafe lock:\n", irqclass);\r\nprint_lock_name(forwards_entry->class);\r\nprintk("\n... which became %s-irq-unsafe at:\n", irqclass);\r\nprintk("...");\r\nprint_stack_trace(forwards_entry->class->usage_traces + bit2, 1);\r\nprintk("\nother info that might help us debug this:\n\n");\r\nprint_irq_lock_scenario(backwards_entry, forwards_entry,\r\nhlock_class(prev), hlock_class(next));\r\nlockdep_print_held_locks(curr);\r\nprintk("\nthe dependencies between %s-irq-safe lock", irqclass);\r\nprintk(" and the holding lock:\n");\r\nif (!save_trace(&prev_root->trace))\r\nreturn 0;\r\nprint_shortest_lock_dependencies(backwards_entry, prev_root);\r\nprintk("\nthe dependencies between the lock to be acquired");\r\nprintk(" and %s-irq-unsafe lock:\n", irqclass);\r\nif (!save_trace(&next_root->trace))\r\nreturn 0;\r\nprint_shortest_lock_dependencies(forwards_entry, next_root);\r\nprintk("\nstack backtrace:\n");\r\ndump_stack();\r\nreturn 0;\r\n}\r\nstatic int\r\ncheck_usage(struct task_struct *curr, struct held_lock *prev,\r\nstruct held_lock *next, enum lock_usage_bit bit_backwards,\r\nenum lock_usage_bit bit_forwards, const char *irqclass)\r\n{\r\nint ret;\r\nstruct lock_list this, that;\r\nstruct lock_list *uninitialized_var(target_entry);\r\nstruct lock_list *uninitialized_var(target_entry1);\r\nthis.parent = NULL;\r\nthis.class = hlock_class(prev);\r\nret = find_usage_backwards(&this, bit_backwards, &target_entry);\r\nif (ret < 0)\r\nreturn print_bfs_bug(ret);\r\nif (ret == 1)\r\nreturn ret;\r\nthat.parent = NULL;\r\nthat.class = hlock_class(next);\r\nret = find_usage_forwards(&that, bit_forwards, &target_entry1);\r\nif (ret < 0)\r\nreturn print_bfs_bug(ret);\r\nif (ret == 1)\r\nreturn ret;\r\nreturn print_bad_irq_dependency(curr, &this, &that,\r\ntarget_entry, target_entry1,\r\nprev, next,\r\nbit_backwards, bit_forwards, irqclass);\r\n}\r\nstatic inline const char *state_name(enum lock_usage_bit bit)\r\n{\r\nreturn (bit & 1) ? state_rnames[bit >> 2] : state_names[bit >> 2];\r\n}\r\nstatic int exclusive_bit(int new_bit)\r\n{\r\nint state = new_bit & ~3;\r\nint dir = new_bit & 2;\r\nreturn state | (dir ^ 2);\r\n}\r\nstatic int check_irq_usage(struct task_struct *curr, struct held_lock *prev,\r\nstruct held_lock *next, enum lock_usage_bit bit)\r\n{\r\nif (!check_usage(curr, prev, next, bit,\r\nexclusive_bit(bit), state_name(bit)))\r\nreturn 0;\r\nbit++;\r\nif (!check_usage(curr, prev, next, bit,\r\nexclusive_bit(bit), state_name(bit)))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int\r\ncheck_prev_add_irq(struct task_struct *curr, struct held_lock *prev,\r\nstruct held_lock *next)\r\n{\r\n#define LOCKDEP_STATE(__STATE) \\r\nif (!check_irq_usage(curr, prev, next, LOCK_USED_IN_##__STATE)) \\r\nreturn 0;\r\n#include "lockdep_states.h"\r\n#undef LOCKDEP_STATE\r\nreturn 1;\r\n}\r\nstatic void inc_chains(void)\r\n{\r\nif (current->hardirq_context)\r\nnr_hardirq_chains++;\r\nelse {\r\nif (current->softirq_context)\r\nnr_softirq_chains++;\r\nelse\r\nnr_process_chains++;\r\n}\r\n}\r\nstatic inline int\r\ncheck_prev_add_irq(struct task_struct *curr, struct held_lock *prev,\r\nstruct held_lock *next)\r\n{\r\nreturn 1;\r\n}\r\nstatic inline void inc_chains(void)\r\n{\r\nnr_process_chains++;\r\n}\r\nstatic void\r\nprint_deadlock_scenario(struct held_lock *nxt,\r\nstruct held_lock *prv)\r\n{\r\nstruct lock_class *next = hlock_class(nxt);\r\nstruct lock_class *prev = hlock_class(prv);\r\nprintk(" Possible unsafe locking scenario:\n\n");\r\nprintk(" CPU0\n");\r\nprintk(" ----\n");\r\nprintk(" lock(");\r\n__print_lock_name(prev);\r\nprintk(");\n");\r\nprintk(" lock(");\r\n__print_lock_name(next);\r\nprintk(");\n");\r\nprintk("\n *** DEADLOCK ***\n\n");\r\nprintk(" May be due to missing lock nesting notation\n\n");\r\n}\r\nstatic int\r\nprint_deadlock_bug(struct task_struct *curr, struct held_lock *prev,\r\nstruct held_lock *next)\r\n{\r\nif (!debug_locks_off_graph_unlock() || debug_locks_silent)\r\nreturn 0;\r\nprintk("\n");\r\nprintk("=============================================\n");\r\nprintk("[ INFO: possible recursive locking detected ]\n");\r\nprint_kernel_ident();\r\nprintk("---------------------------------------------\n");\r\nprintk("%s/%d is trying to acquire lock:\n",\r\ncurr->comm, task_pid_nr(curr));\r\nprint_lock(next);\r\nprintk("\nbut task is already holding lock:\n");\r\nprint_lock(prev);\r\nprintk("\nother info that might help us debug this:\n");\r\nprint_deadlock_scenario(next, prev);\r\nlockdep_print_held_locks(curr);\r\nprintk("\nstack backtrace:\n");\r\ndump_stack();\r\nreturn 0;\r\n}\r\nstatic int\r\ncheck_deadlock(struct task_struct *curr, struct held_lock *next,\r\nstruct lockdep_map *next_instance, int read)\r\n{\r\nstruct held_lock *prev;\r\nstruct held_lock *nest = NULL;\r\nint i;\r\nfor (i = 0; i < curr->lockdep_depth; i++) {\r\nprev = curr->held_locks + i;\r\nif (prev->instance == next->nest_lock)\r\nnest = prev;\r\nif (hlock_class(prev) != hlock_class(next))\r\ncontinue;\r\nif ((read == 2) && prev->read)\r\nreturn 2;\r\nif (nest)\r\nreturn 2;\r\nreturn print_deadlock_bug(curr, prev, next);\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\ncheck_prev_add(struct task_struct *curr, struct held_lock *prev,\r\nstruct held_lock *next, int distance, int trylock_loop)\r\n{\r\nstruct lock_list *entry;\r\nint ret;\r\nstruct lock_list this;\r\nstruct lock_list *uninitialized_var(target_entry);\r\nstatic struct stack_trace trace;\r\nthis.class = hlock_class(next);\r\nthis.parent = NULL;\r\nret = check_noncircular(&this, hlock_class(prev), &target_entry);\r\nif (unlikely(!ret))\r\nreturn print_circular_bug(&this, target_entry, next, prev);\r\nelse if (unlikely(ret < 0))\r\nreturn print_bfs_bug(ret);\r\nif (!check_prev_add_irq(curr, prev, next))\r\nreturn 0;\r\nif (next->read == 2 || prev->read == 2)\r\nreturn 1;\r\nlist_for_each_entry(entry, &hlock_class(prev)->locks_after, entry) {\r\nif (entry->class == hlock_class(next)) {\r\nif (distance == 1)\r\nentry->distance = 1;\r\nreturn 2;\r\n}\r\n}\r\nif (!trylock_loop && !save_trace(&trace))\r\nreturn 0;\r\nret = add_lock_to_list(hlock_class(prev), hlock_class(next),\r\n&hlock_class(prev)->locks_after,\r\nnext->acquire_ip, distance, &trace);\r\nif (!ret)\r\nreturn 0;\r\nret = add_lock_to_list(hlock_class(next), hlock_class(prev),\r\n&hlock_class(next)->locks_before,\r\nnext->acquire_ip, distance, &trace);\r\nif (!ret)\r\nreturn 0;\r\nif (verbose(hlock_class(prev)) || verbose(hlock_class(next))) {\r\ngraph_unlock();\r\nprintk("\n new dependency: ");\r\nprint_lock_name(hlock_class(prev));\r\nprintk(" => ");\r\nprint_lock_name(hlock_class(next));\r\nprintk("\n");\r\ndump_stack();\r\nreturn graph_lock();\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\ncheck_prevs_add(struct task_struct *curr, struct held_lock *next)\r\n{\r\nint depth = curr->lockdep_depth;\r\nint trylock_loop = 0;\r\nstruct held_lock *hlock;\r\nif (!depth)\r\ngoto out_bug;\r\nif (curr->held_locks[depth].irq_context !=\r\ncurr->held_locks[depth-1].irq_context)\r\ngoto out_bug;\r\nfor (;;) {\r\nint distance = curr->lockdep_depth - depth + 1;\r\nhlock = curr->held_locks + depth-1;\r\nif (hlock->read != 2) {\r\nif (!check_prev_add(curr, hlock, next,\r\ndistance, trylock_loop))\r\nreturn 0;\r\nif (!hlock->trylock)\r\nbreak;\r\n}\r\ndepth--;\r\nif (!depth)\r\nbreak;\r\nif (curr->held_locks[depth].irq_context !=\r\ncurr->held_locks[depth-1].irq_context)\r\nbreak;\r\ntrylock_loop = 1;\r\n}\r\nreturn 1;\r\nout_bug:\r\nif (!debug_locks_off_graph_unlock())\r\nreturn 0;\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nstruct lock_class *lock_chain_get_class(struct lock_chain *chain, int i)\r\n{\r\nreturn lock_classes + chain_hlocks[chain->base + i];\r\n}\r\nstatic inline int lookup_chain_cache(struct task_struct *curr,\r\nstruct held_lock *hlock,\r\nu64 chain_key)\r\n{\r\nstruct lock_class *class = hlock_class(hlock);\r\nstruct list_head *hash_head = chainhashentry(chain_key);\r\nstruct lock_chain *chain;\r\nstruct held_lock *hlock_curr;\r\nint i, j;\r\nif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\r\nreturn 0;\r\nlist_for_each_entry(chain, hash_head, entry) {\r\nif (chain->chain_key == chain_key) {\r\ncache_hit:\r\ndebug_atomic_inc(chain_lookup_hits);\r\nif (very_verbose(class))\r\nprintk("\nhash chain already cached, key: "\r\n"%016Lx tail class: [%p] %s\n",\r\n(unsigned long long)chain_key,\r\nclass->key, class->name);\r\nreturn 0;\r\n}\r\n}\r\nif (very_verbose(class))\r\nprintk("\nnew hash chain, key: %016Lx tail class: [%p] %s\n",\r\n(unsigned long long)chain_key, class->key, class->name);\r\nif (!graph_lock())\r\nreturn 0;\r\nlist_for_each_entry(chain, hash_head, entry) {\r\nif (chain->chain_key == chain_key) {\r\ngraph_unlock();\r\ngoto cache_hit;\r\n}\r\n}\r\nif (unlikely(nr_lock_chains >= MAX_LOCKDEP_CHAINS)) {\r\nif (!debug_locks_off_graph_unlock())\r\nreturn 0;\r\nprint_lockdep_off("BUG: MAX_LOCKDEP_CHAINS too low!");\r\ndump_stack();\r\nreturn 0;\r\n}\r\nchain = lock_chains + nr_lock_chains++;\r\nchain->chain_key = chain_key;\r\nchain->irq_context = hlock->irq_context;\r\nfor (i = curr->lockdep_depth - 1; i >= 0; i--) {\r\nhlock_curr = curr->held_locks + i;\r\nif (hlock_curr->irq_context != hlock->irq_context)\r\nbreak;\r\n}\r\ni++;\r\nchain->depth = curr->lockdep_depth + 1 - i;\r\nif (likely(nr_chain_hlocks + chain->depth <= MAX_LOCKDEP_CHAIN_HLOCKS)) {\r\nchain->base = nr_chain_hlocks;\r\nnr_chain_hlocks += chain->depth;\r\nfor (j = 0; j < chain->depth - 1; j++, i++) {\r\nint lock_id = curr->held_locks[i].class_idx - 1;\r\nchain_hlocks[chain->base + j] = lock_id;\r\n}\r\nchain_hlocks[chain->base + j] = class - lock_classes;\r\n}\r\nlist_add_tail_rcu(&chain->entry, hash_head);\r\ndebug_atomic_inc(chain_lookup_misses);\r\ninc_chains();\r\nreturn 1;\r\n}\r\nstatic int validate_chain(struct task_struct *curr, struct lockdep_map *lock,\r\nstruct held_lock *hlock, int chain_head, u64 chain_key)\r\n{\r\nif (!hlock->trylock && (hlock->check == 2) &&\r\nlookup_chain_cache(curr, hlock, chain_key)) {\r\nint ret = check_deadlock(curr, hlock, lock, hlock->read);\r\nif (!ret)\r\nreturn 0;\r\nif (ret == 2)\r\nhlock->read = 2;\r\nif (!chain_head && ret != 2)\r\nif (!check_prevs_add(curr, hlock))\r\nreturn 0;\r\ngraph_unlock();\r\n} else\r\nif (unlikely(!debug_locks))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic inline int validate_chain(struct task_struct *curr,\r\nstruct lockdep_map *lock, struct held_lock *hlock,\r\nint chain_head, u64 chain_key)\r\n{\r\nreturn 1;\r\n}\r\nstatic void check_chain_key(struct task_struct *curr)\r\n{\r\n#ifdef CONFIG_DEBUG_LOCKDEP\r\nstruct held_lock *hlock, *prev_hlock = NULL;\r\nunsigned int i, id;\r\nu64 chain_key = 0;\r\nfor (i = 0; i < curr->lockdep_depth; i++) {\r\nhlock = curr->held_locks + i;\r\nif (chain_key != hlock->prev_chain_key) {\r\ndebug_locks_off();\r\nWARN(1, "hm#1, depth: %u [%u], %016Lx != %016Lx\n",\r\ncurr->lockdep_depth, i,\r\n(unsigned long long)chain_key,\r\n(unsigned long long)hlock->prev_chain_key);\r\nreturn;\r\n}\r\nid = hlock->class_idx - 1;\r\nif (DEBUG_LOCKS_WARN_ON(id >= MAX_LOCKDEP_KEYS))\r\nreturn;\r\nif (prev_hlock && (prev_hlock->irq_context !=\r\nhlock->irq_context))\r\nchain_key = 0;\r\nchain_key = iterate_chain_key(chain_key, id);\r\nprev_hlock = hlock;\r\n}\r\nif (chain_key != curr->curr_chain_key) {\r\ndebug_locks_off();\r\nWARN(1, "hm#2, depth: %u [%u], %016Lx != %016Lx\n",\r\ncurr->lockdep_depth, i,\r\n(unsigned long long)chain_key,\r\n(unsigned long long)curr->curr_chain_key);\r\n}\r\n#endif\r\n}\r\nstatic void\r\nprint_usage_bug_scenario(struct held_lock *lock)\r\n{\r\nstruct lock_class *class = hlock_class(lock);\r\nprintk(" Possible unsafe locking scenario:\n\n");\r\nprintk(" CPU0\n");\r\nprintk(" ----\n");\r\nprintk(" lock(");\r\n__print_lock_name(class);\r\nprintk(");\n");\r\nprintk(" <Interrupt>\n");\r\nprintk(" lock(");\r\n__print_lock_name(class);\r\nprintk(");\n");\r\nprintk("\n *** DEADLOCK ***\n\n");\r\n}\r\nstatic int\r\nprint_usage_bug(struct task_struct *curr, struct held_lock *this,\r\nenum lock_usage_bit prev_bit, enum lock_usage_bit new_bit)\r\n{\r\nif (!debug_locks_off_graph_unlock() || debug_locks_silent)\r\nreturn 0;\r\nprintk("\n");\r\nprintk("=================================\n");\r\nprintk("[ INFO: inconsistent lock state ]\n");\r\nprint_kernel_ident();\r\nprintk("---------------------------------\n");\r\nprintk("inconsistent {%s} -> {%s} usage.\n",\r\nusage_str[prev_bit], usage_str[new_bit]);\r\nprintk("%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] takes:\n",\r\ncurr->comm, task_pid_nr(curr),\r\ntrace_hardirq_context(curr), hardirq_count() >> HARDIRQ_SHIFT,\r\ntrace_softirq_context(curr), softirq_count() >> SOFTIRQ_SHIFT,\r\ntrace_hardirqs_enabled(curr),\r\ntrace_softirqs_enabled(curr));\r\nprint_lock(this);\r\nprintk("{%s} state was registered at:\n", usage_str[prev_bit]);\r\nprint_stack_trace(hlock_class(this)->usage_traces + prev_bit, 1);\r\nprint_irqtrace_events(curr);\r\nprintk("\nother info that might help us debug this:\n");\r\nprint_usage_bug_scenario(this);\r\nlockdep_print_held_locks(curr);\r\nprintk("\nstack backtrace:\n");\r\ndump_stack();\r\nreturn 0;\r\n}\r\nstatic inline int\r\nvalid_state(struct task_struct *curr, struct held_lock *this,\r\nenum lock_usage_bit new_bit, enum lock_usage_bit bad_bit)\r\n{\r\nif (unlikely(hlock_class(this)->usage_mask & (1 << bad_bit)))\r\nreturn print_usage_bug(curr, this, bad_bit, new_bit);\r\nreturn 1;\r\n}\r\nstatic int\r\nprint_irq_inversion_bug(struct task_struct *curr,\r\nstruct lock_list *root, struct lock_list *other,\r\nstruct held_lock *this, int forwards,\r\nconst char *irqclass)\r\n{\r\nstruct lock_list *entry = other;\r\nstruct lock_list *middle = NULL;\r\nint depth;\r\nif (!debug_locks_off_graph_unlock() || debug_locks_silent)\r\nreturn 0;\r\nprintk("\n");\r\nprintk("=========================================================\n");\r\nprintk("[ INFO: possible irq lock inversion dependency detected ]\n");\r\nprint_kernel_ident();\r\nprintk("---------------------------------------------------------\n");\r\nprintk("%s/%d just changed the state of lock:\n",\r\ncurr->comm, task_pid_nr(curr));\r\nprint_lock(this);\r\nif (forwards)\r\nprintk("but this lock took another, %s-unsafe lock in the past:\n", irqclass);\r\nelse\r\nprintk("but this lock was taken by another, %s-safe lock in the past:\n", irqclass);\r\nprint_lock_name(other->class);\r\nprintk("\n\nand interrupts could create inverse lock ordering between them.\n\n");\r\nprintk("\nother info that might help us debug this:\n");\r\ndepth = get_lock_depth(other);\r\ndo {\r\nif (depth == 0 && (entry != root)) {\r\nprintk("lockdep:%s bad path found in chain graph\n", __func__);\r\nbreak;\r\n}\r\nmiddle = entry;\r\nentry = get_lock_parent(entry);\r\ndepth--;\r\n} while (entry && entry != root && (depth >= 0));\r\nif (forwards)\r\nprint_irq_lock_scenario(root, other,\r\nmiddle ? middle->class : root->class, other->class);\r\nelse\r\nprint_irq_lock_scenario(other, root,\r\nmiddle ? middle->class : other->class, root->class);\r\nlockdep_print_held_locks(curr);\r\nprintk("\nthe shortest dependencies between 2nd lock and 1st lock:\n");\r\nif (!save_trace(&root->trace))\r\nreturn 0;\r\nprint_shortest_lock_dependencies(other, root);\r\nprintk("\nstack backtrace:\n");\r\ndump_stack();\r\nreturn 0;\r\n}\r\nstatic int\r\ncheck_usage_forwards(struct task_struct *curr, struct held_lock *this,\r\nenum lock_usage_bit bit, const char *irqclass)\r\n{\r\nint ret;\r\nstruct lock_list root;\r\nstruct lock_list *uninitialized_var(target_entry);\r\nroot.parent = NULL;\r\nroot.class = hlock_class(this);\r\nret = find_usage_forwards(&root, bit, &target_entry);\r\nif (ret < 0)\r\nreturn print_bfs_bug(ret);\r\nif (ret == 1)\r\nreturn ret;\r\nreturn print_irq_inversion_bug(curr, &root, target_entry,\r\nthis, 1, irqclass);\r\n}\r\nstatic int\r\ncheck_usage_backwards(struct task_struct *curr, struct held_lock *this,\r\nenum lock_usage_bit bit, const char *irqclass)\r\n{\r\nint ret;\r\nstruct lock_list root;\r\nstruct lock_list *uninitialized_var(target_entry);\r\nroot.parent = NULL;\r\nroot.class = hlock_class(this);\r\nret = find_usage_backwards(&root, bit, &target_entry);\r\nif (ret < 0)\r\nreturn print_bfs_bug(ret);\r\nif (ret == 1)\r\nreturn ret;\r\nreturn print_irq_inversion_bug(curr, &root, target_entry,\r\nthis, 0, irqclass);\r\n}\r\nvoid print_irqtrace_events(struct task_struct *curr)\r\n{\r\nprintk("irq event stamp: %u\n", curr->irq_events);\r\nprintk("hardirqs last enabled at (%u): ", curr->hardirq_enable_event);\r\nprint_ip_sym(curr->hardirq_enable_ip);\r\nprintk("hardirqs last disabled at (%u): ", curr->hardirq_disable_event);\r\nprint_ip_sym(curr->hardirq_disable_ip);\r\nprintk("softirqs last enabled at (%u): ", curr->softirq_enable_event);\r\nprint_ip_sym(curr->softirq_enable_ip);\r\nprintk("softirqs last disabled at (%u): ", curr->softirq_disable_event);\r\nprint_ip_sym(curr->softirq_disable_ip);\r\n}\r\nstatic int HARDIRQ_verbose(struct lock_class *class)\r\n{\r\n#if HARDIRQ_VERBOSE\r\nreturn class_filter(class);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int SOFTIRQ_verbose(struct lock_class *class)\r\n{\r\n#if SOFTIRQ_VERBOSE\r\nreturn class_filter(class);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int RECLAIM_FS_verbose(struct lock_class *class)\r\n{\r\n#if RECLAIM_VERBOSE\r\nreturn class_filter(class);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic inline int state_verbose(enum lock_usage_bit bit,\r\nstruct lock_class *class)\r\n{\r\nreturn state_verbose_f[bit >> 2](class);\r\n}\r\nstatic int\r\nmark_lock_irq(struct task_struct *curr, struct held_lock *this,\r\nenum lock_usage_bit new_bit)\r\n{\r\nint excl_bit = exclusive_bit(new_bit);\r\nint read = new_bit & 1;\r\nint dir = new_bit & 2;\r\ncheck_usage_f usage = dir ?\r\ncheck_usage_backwards : check_usage_forwards;\r\nif (!valid_state(curr, this, new_bit, excl_bit))\r\nreturn 0;\r\nif ((!read || !dir || STRICT_READ_CHECKS) &&\r\n!usage(curr, this, excl_bit, state_name(new_bit & ~1)))\r\nreturn 0;\r\nif (!read) {\r\nif (!valid_state(curr, this, new_bit, excl_bit + 1))\r\nreturn 0;\r\nif (STRICT_READ_CHECKS &&\r\n!usage(curr, this, excl_bit + 1,\r\nstate_name(new_bit + 1)))\r\nreturn 0;\r\n}\r\nif (state_verbose(new_bit, hlock_class(this)))\r\nreturn 2;\r\nreturn 1;\r\n}\r\nstatic int\r\nmark_held_locks(struct task_struct *curr, enum mark_type mark)\r\n{\r\nenum lock_usage_bit usage_bit;\r\nstruct held_lock *hlock;\r\nint i;\r\nfor (i = 0; i < curr->lockdep_depth; i++) {\r\nhlock = curr->held_locks + i;\r\nusage_bit = 2 + (mark << 2);\r\nif (hlock->read)\r\nusage_bit += 1;\r\nBUG_ON(usage_bit >= LOCK_USAGE_STATES);\r\nif (hlock_class(hlock)->key == __lockdep_no_validate__.subkeys)\r\ncontinue;\r\nif (!mark_lock(curr, hlock, usage_bit))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void __trace_hardirqs_on_caller(unsigned long ip)\r\n{\r\nstruct task_struct *curr = current;\r\ncurr->hardirqs_enabled = 1;\r\nif (!mark_held_locks(curr, HARDIRQ))\r\nreturn;\r\nif (curr->softirqs_enabled)\r\nif (!mark_held_locks(curr, SOFTIRQ))\r\nreturn;\r\ncurr->hardirq_enable_ip = ip;\r\ncurr->hardirq_enable_event = ++curr->irq_events;\r\ndebug_atomic_inc(hardirqs_on_events);\r\n}\r\nvoid trace_hardirqs_on_caller(unsigned long ip)\r\n{\r\ntime_hardirqs_on(CALLER_ADDR0, ip);\r\nif (unlikely(!debug_locks || current->lockdep_recursion))\r\nreturn;\r\nif (unlikely(current->hardirqs_enabled)) {\r\n__debug_atomic_inc(redundant_hardirqs_on);\r\nreturn;\r\n}\r\nif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\r\nreturn;\r\nif (DEBUG_LOCKS_WARN_ON(unlikely(early_boot_irqs_disabled)))\r\nreturn;\r\nif (DEBUG_LOCKS_WARN_ON(current->hardirq_context))\r\nreturn;\r\ncurrent->lockdep_recursion = 1;\r\n__trace_hardirqs_on_caller(ip);\r\ncurrent->lockdep_recursion = 0;\r\n}\r\nvoid trace_hardirqs_on(void)\r\n{\r\ntrace_hardirqs_on_caller(CALLER_ADDR0);\r\n}\r\nvoid trace_hardirqs_off_caller(unsigned long ip)\r\n{\r\nstruct task_struct *curr = current;\r\ntime_hardirqs_off(CALLER_ADDR0, ip);\r\nif (unlikely(!debug_locks || current->lockdep_recursion))\r\nreturn;\r\nif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\r\nreturn;\r\nif (curr->hardirqs_enabled) {\r\ncurr->hardirqs_enabled = 0;\r\ncurr->hardirq_disable_ip = ip;\r\ncurr->hardirq_disable_event = ++curr->irq_events;\r\ndebug_atomic_inc(hardirqs_off_events);\r\n} else\r\ndebug_atomic_inc(redundant_hardirqs_off);\r\n}\r\nvoid trace_hardirqs_off(void)\r\n{\r\ntrace_hardirqs_off_caller(CALLER_ADDR0);\r\n}\r\nvoid trace_softirqs_on(unsigned long ip)\r\n{\r\nstruct task_struct *curr = current;\r\nif (unlikely(!debug_locks || current->lockdep_recursion))\r\nreturn;\r\nif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\r\nreturn;\r\nif (curr->softirqs_enabled) {\r\ndebug_atomic_inc(redundant_softirqs_on);\r\nreturn;\r\n}\r\ncurrent->lockdep_recursion = 1;\r\ncurr->softirqs_enabled = 1;\r\ncurr->softirq_enable_ip = ip;\r\ncurr->softirq_enable_event = ++curr->irq_events;\r\ndebug_atomic_inc(softirqs_on_events);\r\nif (curr->hardirqs_enabled)\r\nmark_held_locks(curr, SOFTIRQ);\r\ncurrent->lockdep_recursion = 0;\r\n}\r\nvoid trace_softirqs_off(unsigned long ip)\r\n{\r\nstruct task_struct *curr = current;\r\nif (unlikely(!debug_locks || current->lockdep_recursion))\r\nreturn;\r\nif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\r\nreturn;\r\nif (curr->softirqs_enabled) {\r\ncurr->softirqs_enabled = 0;\r\ncurr->softirq_disable_ip = ip;\r\ncurr->softirq_disable_event = ++curr->irq_events;\r\ndebug_atomic_inc(softirqs_off_events);\r\nDEBUG_LOCKS_WARN_ON(!softirq_count());\r\n} else\r\ndebug_atomic_inc(redundant_softirqs_off);\r\n}\r\nstatic void __lockdep_trace_alloc(gfp_t gfp_mask, unsigned long flags)\r\n{\r\nstruct task_struct *curr = current;\r\nif (unlikely(!debug_locks))\r\nreturn;\r\nif (!(gfp_mask & __GFP_WAIT))\r\nreturn;\r\nif ((curr->flags & PF_MEMALLOC) && !(gfp_mask & __GFP_NOMEMALLOC))\r\nreturn;\r\nif (!(gfp_mask & __GFP_FS))\r\nreturn;\r\nif (DEBUG_LOCKS_WARN_ON(irqs_disabled_flags(flags)))\r\nreturn;\r\nmark_held_locks(curr, RECLAIM_FS);\r\n}\r\nvoid lockdep_trace_alloc(gfp_t gfp_mask)\r\n{\r\nunsigned long flags;\r\nif (unlikely(current->lockdep_recursion))\r\nreturn;\r\nraw_local_irq_save(flags);\r\ncheck_flags(flags);\r\ncurrent->lockdep_recursion = 1;\r\n__lockdep_trace_alloc(gfp_mask, flags);\r\ncurrent->lockdep_recursion = 0;\r\nraw_local_irq_restore(flags);\r\n}\r\nstatic int mark_irqflags(struct task_struct *curr, struct held_lock *hlock)\r\n{\r\nif (!hlock->trylock) {\r\nif (hlock->read) {\r\nif (curr->hardirq_context)\r\nif (!mark_lock(curr, hlock,\r\nLOCK_USED_IN_HARDIRQ_READ))\r\nreturn 0;\r\nif (curr->softirq_context)\r\nif (!mark_lock(curr, hlock,\r\nLOCK_USED_IN_SOFTIRQ_READ))\r\nreturn 0;\r\n} else {\r\nif (curr->hardirq_context)\r\nif (!mark_lock(curr, hlock, LOCK_USED_IN_HARDIRQ))\r\nreturn 0;\r\nif (curr->softirq_context)\r\nif (!mark_lock(curr, hlock, LOCK_USED_IN_SOFTIRQ))\r\nreturn 0;\r\n}\r\n}\r\nif (!hlock->hardirqs_off) {\r\nif (hlock->read) {\r\nif (!mark_lock(curr, hlock,\r\nLOCK_ENABLED_HARDIRQ_READ))\r\nreturn 0;\r\nif (curr->softirqs_enabled)\r\nif (!mark_lock(curr, hlock,\r\nLOCK_ENABLED_SOFTIRQ_READ))\r\nreturn 0;\r\n} else {\r\nif (!mark_lock(curr, hlock,\r\nLOCK_ENABLED_HARDIRQ))\r\nreturn 0;\r\nif (curr->softirqs_enabled)\r\nif (!mark_lock(curr, hlock,\r\nLOCK_ENABLED_SOFTIRQ))\r\nreturn 0;\r\n}\r\n}\r\nif (!hlock->trylock && (curr->lockdep_reclaim_gfp & __GFP_FS)) {\r\nif (hlock->read) {\r\nif (!mark_lock(curr, hlock, LOCK_USED_IN_RECLAIM_FS_READ))\r\nreturn 0;\r\n} else {\r\nif (!mark_lock(curr, hlock, LOCK_USED_IN_RECLAIM_FS))\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int separate_irq_context(struct task_struct *curr,\r\nstruct held_lock *hlock)\r\n{\r\nunsigned int depth = curr->lockdep_depth;\r\nhlock->irq_context = 2*(curr->hardirq_context ? 1 : 0) +\r\ncurr->softirq_context;\r\nif (depth) {\r\nstruct held_lock *prev_hlock;\r\nprev_hlock = curr->held_locks + depth-1;\r\nif (prev_hlock->irq_context != hlock->irq_context)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline\r\nint mark_lock_irq(struct task_struct *curr, struct held_lock *this,\r\nenum lock_usage_bit new_bit)\r\n{\r\nWARN_ON(1);\r\nreturn 1;\r\n}\r\nstatic inline int mark_irqflags(struct task_struct *curr,\r\nstruct held_lock *hlock)\r\n{\r\nreturn 1;\r\n}\r\nstatic inline int separate_irq_context(struct task_struct *curr,\r\nstruct held_lock *hlock)\r\n{\r\nreturn 0;\r\n}\r\nvoid lockdep_trace_alloc(gfp_t gfp_mask)\r\n{\r\n}\r\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\r\nenum lock_usage_bit new_bit)\r\n{\r\nunsigned int new_mask = 1 << new_bit, ret = 1;\r\nif (likely(hlock_class(this)->usage_mask & new_mask))\r\nreturn 1;\r\nif (!graph_lock())\r\nreturn 0;\r\nif (unlikely(hlock_class(this)->usage_mask & new_mask)) {\r\ngraph_unlock();\r\nreturn 1;\r\n}\r\nhlock_class(this)->usage_mask |= new_mask;\r\nif (!save_trace(hlock_class(this)->usage_traces + new_bit))\r\nreturn 0;\r\nswitch (new_bit) {\r\n#define LOCKDEP_STATE(__STATE) \\r\ncase LOCK_USED_IN_##__STATE: \\r\ncase LOCK_USED_IN_##__STATE##_READ: \\r\ncase LOCK_ENABLED_##__STATE: \\r\ncase LOCK_ENABLED_##__STATE##_READ:\r\n#include "lockdep_states.h"\r\n#undef LOCKDEP_STATE\r\nret = mark_lock_irq(curr, this, new_bit);\r\nif (!ret)\r\nreturn 0;\r\nbreak;\r\ncase LOCK_USED:\r\ndebug_atomic_dec(nr_unused_locks);\r\nbreak;\r\ndefault:\r\nif (!debug_locks_off_graph_unlock())\r\nreturn 0;\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\ngraph_unlock();\r\nif (ret == 2) {\r\nprintk("\nmarked lock as {%s}:\n", usage_str[new_bit]);\r\nprint_lock(this);\r\nprint_irqtrace_events(curr);\r\ndump_stack();\r\n}\r\nreturn ret;\r\n}\r\nvoid lockdep_init_map(struct lockdep_map *lock, const char *name,\r\nstruct lock_class_key *key, int subclass)\r\n{\r\nint i;\r\nkmemcheck_mark_initialized(lock, sizeof(*lock));\r\nfor (i = 0; i < NR_LOCKDEP_CACHING_CLASSES; i++)\r\nlock->class_cache[i] = NULL;\r\n#ifdef CONFIG_LOCK_STAT\r\nlock->cpu = raw_smp_processor_id();\r\n#endif\r\nif (DEBUG_LOCKS_WARN_ON(!name)) {\r\nlock->name = "NULL";\r\nreturn;\r\n}\r\nlock->name = name;\r\nif (DEBUG_LOCKS_WARN_ON(!key))\r\nreturn;\r\nif (!static_obj(key)) {\r\nprintk("BUG: key %p not in .data!\n", key);\r\nDEBUG_LOCKS_WARN_ON(1);\r\nreturn;\r\n}\r\nlock->key = key;\r\nif (unlikely(!debug_locks))\r\nreturn;\r\nif (subclass)\r\nregister_lock_class(lock, subclass, 1);\r\n}\r\nstatic int\r\nprint_lock_nested_lock_not_held(struct task_struct *curr,\r\nstruct held_lock *hlock,\r\nunsigned long ip)\r\n{\r\nif (!debug_locks_off())\r\nreturn 0;\r\nif (debug_locks_silent)\r\nreturn 0;\r\nprintk("\n");\r\nprintk("==================================\n");\r\nprintk("[ BUG: Nested lock was not taken ]\n");\r\nprint_kernel_ident();\r\nprintk("----------------------------------\n");\r\nprintk("%s/%d is trying to lock:\n", curr->comm, task_pid_nr(curr));\r\nprint_lock(hlock);\r\nprintk("\nbut this task is not holding:\n");\r\nprintk("%s\n", hlock->nest_lock->name);\r\nprintk("\nstack backtrace:\n");\r\ndump_stack();\r\nprintk("\nother info that might help us debug this:\n");\r\nlockdep_print_held_locks(curr);\r\nprintk("\nstack backtrace:\n");\r\ndump_stack();\r\nreturn 0;\r\n}\r\nstatic int __lock_acquire(struct lockdep_map *lock, unsigned int subclass,\r\nint trylock, int read, int check, int hardirqs_off,\r\nstruct lockdep_map *nest_lock, unsigned long ip,\r\nint references)\r\n{\r\nstruct task_struct *curr = current;\r\nstruct lock_class *class = NULL;\r\nstruct held_lock *hlock;\r\nunsigned int depth, id;\r\nint chain_head = 0;\r\nint class_idx;\r\nu64 chain_key;\r\nif (!prove_locking)\r\ncheck = 1;\r\nif (unlikely(!debug_locks))\r\nreturn 0;\r\nif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\r\nreturn 0;\r\nif (lock->key == &__lockdep_no_validate__)\r\ncheck = 1;\r\nif (subclass < NR_LOCKDEP_CACHING_CLASSES)\r\nclass = lock->class_cache[subclass];\r\nif (unlikely(!class)) {\r\nclass = register_lock_class(lock, subclass, 0);\r\nif (!class)\r\nreturn 0;\r\n}\r\natomic_inc((atomic_t *)&class->ops);\r\nif (very_verbose(class)) {\r\nprintk("\nacquire class [%p] %s", class->key, class->name);\r\nif (class->name_version > 1)\r\nprintk("#%d", class->name_version);\r\nprintk("\n");\r\ndump_stack();\r\n}\r\ndepth = curr->lockdep_depth;\r\nif (DEBUG_LOCKS_WARN_ON(depth >= MAX_LOCK_DEPTH))\r\nreturn 0;\r\nclass_idx = class - lock_classes + 1;\r\nif (depth) {\r\nhlock = curr->held_locks + depth - 1;\r\nif (hlock->class_idx == class_idx && nest_lock) {\r\nif (hlock->references)\r\nhlock->references++;\r\nelse\r\nhlock->references = 2;\r\nreturn 1;\r\n}\r\n}\r\nhlock = curr->held_locks + depth;\r\nif (DEBUG_LOCKS_WARN_ON(!class))\r\nreturn 0;\r\nhlock->class_idx = class_idx;\r\nhlock->acquire_ip = ip;\r\nhlock->instance = lock;\r\nhlock->nest_lock = nest_lock;\r\nhlock->trylock = trylock;\r\nhlock->read = read;\r\nhlock->check = check;\r\nhlock->hardirqs_off = !!hardirqs_off;\r\nhlock->references = references;\r\n#ifdef CONFIG_LOCK_STAT\r\nhlock->waittime_stamp = 0;\r\nhlock->holdtime_stamp = lockstat_clock();\r\n#endif\r\nif (check == 2 && !mark_irqflags(curr, hlock))\r\nreturn 0;\r\nif (!mark_lock(curr, hlock, LOCK_USED))\r\nreturn 0;\r\nid = class - lock_classes;\r\nif (DEBUG_LOCKS_WARN_ON(id >= MAX_LOCKDEP_KEYS))\r\nreturn 0;\r\nchain_key = curr->curr_chain_key;\r\nif (!depth) {\r\nif (DEBUG_LOCKS_WARN_ON(chain_key != 0))\r\nreturn 0;\r\nchain_head = 1;\r\n}\r\nhlock->prev_chain_key = chain_key;\r\nif (separate_irq_context(curr, hlock)) {\r\nchain_key = 0;\r\nchain_head = 1;\r\n}\r\nchain_key = iterate_chain_key(chain_key, id);\r\nif (nest_lock && !__lock_is_held(nest_lock))\r\nreturn print_lock_nested_lock_not_held(curr, hlock, ip);\r\nif (!validate_chain(curr, lock, hlock, chain_head, chain_key))\r\nreturn 0;\r\ncurr->curr_chain_key = chain_key;\r\ncurr->lockdep_depth++;\r\ncheck_chain_key(curr);\r\n#ifdef CONFIG_DEBUG_LOCKDEP\r\nif (unlikely(!debug_locks))\r\nreturn 0;\r\n#endif\r\nif (unlikely(curr->lockdep_depth >= MAX_LOCK_DEPTH)) {\r\ndebug_locks_off();\r\nprint_lockdep_off("BUG: MAX_LOCK_DEPTH too low!");\r\nprintk(KERN_DEBUG "depth: %i max: %lu!\n",\r\ncurr->lockdep_depth, MAX_LOCK_DEPTH);\r\nlockdep_print_held_locks(current);\r\ndebug_show_all_locks();\r\ndump_stack();\r\nreturn 0;\r\n}\r\nif (unlikely(curr->lockdep_depth > max_lockdep_depth))\r\nmax_lockdep_depth = curr->lockdep_depth;\r\nreturn 1;\r\n}\r\nstatic int\r\nprint_unlock_imbalance_bug(struct task_struct *curr, struct lockdep_map *lock,\r\nunsigned long ip)\r\n{\r\nif (!debug_locks_off())\r\nreturn 0;\r\nif (debug_locks_silent)\r\nreturn 0;\r\nprintk("\n");\r\nprintk("=====================================\n");\r\nprintk("[ BUG: bad unlock balance detected! ]\n");\r\nprint_kernel_ident();\r\nprintk("-------------------------------------\n");\r\nprintk("%s/%d is trying to release lock (",\r\ncurr->comm, task_pid_nr(curr));\r\nprint_lockdep_cache(lock);\r\nprintk(") at:\n");\r\nprint_ip_sym(ip);\r\nprintk("but there are no more locks to release!\n");\r\nprintk("\nother info that might help us debug this:\n");\r\nlockdep_print_held_locks(curr);\r\nprintk("\nstack backtrace:\n");\r\ndump_stack();\r\nreturn 0;\r\n}\r\nstatic int check_unlock(struct task_struct *curr, struct lockdep_map *lock,\r\nunsigned long ip)\r\n{\r\nif (unlikely(!debug_locks))\r\nreturn 0;\r\nif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\r\nreturn 0;\r\nif (curr->lockdep_depth <= 0)\r\nreturn print_unlock_imbalance_bug(curr, lock, ip);\r\nreturn 1;\r\n}\r\nstatic int match_held_lock(struct held_lock *hlock, struct lockdep_map *lock)\r\n{\r\nif (hlock->instance == lock)\r\nreturn 1;\r\nif (hlock->references) {\r\nstruct lock_class *class = lock->class_cache[0];\r\nif (!class)\r\nclass = look_up_lock_class(lock, 0);\r\nif (!class)\r\nreturn 0;\r\nif (DEBUG_LOCKS_WARN_ON(!hlock->nest_lock))\r\nreturn 0;\r\nif (hlock->class_idx == class - lock_classes + 1)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\n__lock_set_class(struct lockdep_map *lock, const char *name,\r\nstruct lock_class_key *key, unsigned int subclass,\r\nunsigned long ip)\r\n{\r\nstruct task_struct *curr = current;\r\nstruct held_lock *hlock, *prev_hlock;\r\nstruct lock_class *class;\r\nunsigned int depth;\r\nint i;\r\ndepth = curr->lockdep_depth;\r\nif (DEBUG_LOCKS_WARN_ON(!depth))\r\nreturn 0;\r\nprev_hlock = NULL;\r\nfor (i = depth-1; i >= 0; i--) {\r\nhlock = curr->held_locks + i;\r\nif (prev_hlock && prev_hlock->irq_context != hlock->irq_context)\r\nbreak;\r\nif (match_held_lock(hlock, lock))\r\ngoto found_it;\r\nprev_hlock = hlock;\r\n}\r\nreturn print_unlock_imbalance_bug(curr, lock, ip);\r\nfound_it:\r\nlockdep_init_map(lock, name, key, 0);\r\nclass = register_lock_class(lock, subclass, 0);\r\nhlock->class_idx = class - lock_classes + 1;\r\ncurr->lockdep_depth = i;\r\ncurr->curr_chain_key = hlock->prev_chain_key;\r\nfor (; i < depth; i++) {\r\nhlock = curr->held_locks + i;\r\nif (!__lock_acquire(hlock->instance,\r\nhlock_class(hlock)->subclass, hlock->trylock,\r\nhlock->read, hlock->check, hlock->hardirqs_off,\r\nhlock->nest_lock, hlock->acquire_ip,\r\nhlock->references))\r\nreturn 0;\r\n}\r\nif (DEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int\r\nlock_release_non_nested(struct task_struct *curr,\r\nstruct lockdep_map *lock, unsigned long ip)\r\n{\r\nstruct held_lock *hlock, *prev_hlock;\r\nunsigned int depth;\r\nint i;\r\ndepth = curr->lockdep_depth;\r\nif (DEBUG_LOCKS_WARN_ON(!depth))\r\nreturn 0;\r\nprev_hlock = NULL;\r\nfor (i = depth-1; i >= 0; i--) {\r\nhlock = curr->held_locks + i;\r\nif (prev_hlock && prev_hlock->irq_context != hlock->irq_context)\r\nbreak;\r\nif (match_held_lock(hlock, lock))\r\ngoto found_it;\r\nprev_hlock = hlock;\r\n}\r\nreturn print_unlock_imbalance_bug(curr, lock, ip);\r\nfound_it:\r\nif (hlock->instance == lock)\r\nlock_release_holdtime(hlock);\r\nif (hlock->references) {\r\nhlock->references--;\r\nif (hlock->references) {\r\nreturn 1;\r\n}\r\n}\r\ncurr->lockdep_depth = i;\r\ncurr->curr_chain_key = hlock->prev_chain_key;\r\nfor (i++; i < depth; i++) {\r\nhlock = curr->held_locks + i;\r\nif (!__lock_acquire(hlock->instance,\r\nhlock_class(hlock)->subclass, hlock->trylock,\r\nhlock->read, hlock->check, hlock->hardirqs_off,\r\nhlock->nest_lock, hlock->acquire_ip,\r\nhlock->references))\r\nreturn 0;\r\n}\r\nif (DEBUG_LOCKS_WARN_ON(curr->lockdep_depth != depth - 1))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int lock_release_nested(struct task_struct *curr,\r\nstruct lockdep_map *lock, unsigned long ip)\r\n{\r\nstruct held_lock *hlock;\r\nunsigned int depth;\r\ndepth = curr->lockdep_depth - 1;\r\nhlock = curr->held_locks + depth;\r\nif (hlock->instance != lock || hlock->references)\r\nreturn lock_release_non_nested(curr, lock, ip);\r\ncurr->lockdep_depth--;\r\nif (DEBUG_LOCKS_WARN_ON(!depth && (hlock->prev_chain_key != 0)))\r\nreturn 0;\r\ncurr->curr_chain_key = hlock->prev_chain_key;\r\nlock_release_holdtime(hlock);\r\n#ifdef CONFIG_DEBUG_LOCKDEP\r\nhlock->prev_chain_key = 0;\r\nhlock->class_idx = 0;\r\nhlock->acquire_ip = 0;\r\nhlock->irq_context = 0;\r\n#endif\r\nreturn 1;\r\n}\r\nstatic void\r\n__lock_release(struct lockdep_map *lock, int nested, unsigned long ip)\r\n{\r\nstruct task_struct *curr = current;\r\nif (!check_unlock(curr, lock, ip))\r\nreturn;\r\nif (nested) {\r\nif (!lock_release_nested(curr, lock, ip))\r\nreturn;\r\n} else {\r\nif (!lock_release_non_nested(curr, lock, ip))\r\nreturn;\r\n}\r\ncheck_chain_key(curr);\r\n}\r\nstatic int __lock_is_held(struct lockdep_map *lock)\r\n{\r\nstruct task_struct *curr = current;\r\nint i;\r\nfor (i = 0; i < curr->lockdep_depth; i++) {\r\nstruct held_lock *hlock = curr->held_locks + i;\r\nif (match_held_lock(hlock, lock))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void check_flags(unsigned long flags)\r\n{\r\n#if defined(CONFIG_PROVE_LOCKING) && defined(CONFIG_DEBUG_LOCKDEP) && \\r\ndefined(CONFIG_TRACE_IRQFLAGS)\r\nif (!debug_locks)\r\nreturn;\r\nif (irqs_disabled_flags(flags)) {\r\nif (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {\r\nprintk("possible reason: unannotated irqs-off.\n");\r\n}\r\n} else {\r\nif (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {\r\nprintk("possible reason: unannotated irqs-on.\n");\r\n}\r\n}\r\nif (!hardirq_count()) {\r\nif (softirq_count()) {\r\nDEBUG_LOCKS_WARN_ON(current->softirqs_enabled);\r\n} else {\r\nDEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);\r\n}\r\n}\r\nif (!debug_locks)\r\nprint_irqtrace_events(current);\r\n#endif\r\n}\r\nvoid lock_set_class(struct lockdep_map *lock, const char *name,\r\nstruct lock_class_key *key, unsigned int subclass,\r\nunsigned long ip)\r\n{\r\nunsigned long flags;\r\nif (unlikely(current->lockdep_recursion))\r\nreturn;\r\nraw_local_irq_save(flags);\r\ncurrent->lockdep_recursion = 1;\r\ncheck_flags(flags);\r\nif (__lock_set_class(lock, name, key, subclass, ip))\r\ncheck_chain_key(current);\r\ncurrent->lockdep_recursion = 0;\r\nraw_local_irq_restore(flags);\r\n}\r\nvoid lock_acquire(struct lockdep_map *lock, unsigned int subclass,\r\nint trylock, int read, int check,\r\nstruct lockdep_map *nest_lock, unsigned long ip)\r\n{\r\nunsigned long flags;\r\nif (unlikely(current->lockdep_recursion))\r\nreturn;\r\nraw_local_irq_save(flags);\r\ncheck_flags(flags);\r\ncurrent->lockdep_recursion = 1;\r\ntrace_lock_acquire(lock, subclass, trylock, read, check, nest_lock, ip);\r\n__lock_acquire(lock, subclass, trylock, read, check,\r\nirqs_disabled_flags(flags), nest_lock, ip, 0);\r\ncurrent->lockdep_recursion = 0;\r\nraw_local_irq_restore(flags);\r\n}\r\nvoid lock_release(struct lockdep_map *lock, int nested,\r\nunsigned long ip)\r\n{\r\nunsigned long flags;\r\nif (unlikely(current->lockdep_recursion))\r\nreturn;\r\nraw_local_irq_save(flags);\r\ncheck_flags(flags);\r\ncurrent->lockdep_recursion = 1;\r\ntrace_lock_release(lock, ip);\r\n__lock_release(lock, nested, ip);\r\ncurrent->lockdep_recursion = 0;\r\nraw_local_irq_restore(flags);\r\n}\r\nint lock_is_held(struct lockdep_map *lock)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nif (unlikely(current->lockdep_recursion))\r\nreturn 1;\r\nraw_local_irq_save(flags);\r\ncheck_flags(flags);\r\ncurrent->lockdep_recursion = 1;\r\nret = __lock_is_held(lock);\r\ncurrent->lockdep_recursion = 0;\r\nraw_local_irq_restore(flags);\r\nreturn ret;\r\n}\r\nvoid lockdep_set_current_reclaim_state(gfp_t gfp_mask)\r\n{\r\ncurrent->lockdep_reclaim_gfp = gfp_mask;\r\n}\r\nvoid lockdep_clear_current_reclaim_state(void)\r\n{\r\ncurrent->lockdep_reclaim_gfp = 0;\r\n}\r\nstatic int\r\nprint_lock_contention_bug(struct task_struct *curr, struct lockdep_map *lock,\r\nunsigned long ip)\r\n{\r\nif (!debug_locks_off())\r\nreturn 0;\r\nif (debug_locks_silent)\r\nreturn 0;\r\nprintk("\n");\r\nprintk("=================================\n");\r\nprintk("[ BUG: bad contention detected! ]\n");\r\nprint_kernel_ident();\r\nprintk("---------------------------------\n");\r\nprintk("%s/%d is trying to contend lock (",\r\ncurr->comm, task_pid_nr(curr));\r\nprint_lockdep_cache(lock);\r\nprintk(") at:\n");\r\nprint_ip_sym(ip);\r\nprintk("but there are no locks held!\n");\r\nprintk("\nother info that might help us debug this:\n");\r\nlockdep_print_held_locks(curr);\r\nprintk("\nstack backtrace:\n");\r\ndump_stack();\r\nreturn 0;\r\n}\r\nstatic void\r\n__lock_contended(struct lockdep_map *lock, unsigned long ip)\r\n{\r\nstruct task_struct *curr = current;\r\nstruct held_lock *hlock, *prev_hlock;\r\nstruct lock_class_stats *stats;\r\nunsigned int depth;\r\nint i, contention_point, contending_point;\r\ndepth = curr->lockdep_depth;\r\nif (DEBUG_LOCKS_WARN_ON(!depth))\r\nreturn;\r\nprev_hlock = NULL;\r\nfor (i = depth-1; i >= 0; i--) {\r\nhlock = curr->held_locks + i;\r\nif (prev_hlock && prev_hlock->irq_context != hlock->irq_context)\r\nbreak;\r\nif (match_held_lock(hlock, lock))\r\ngoto found_it;\r\nprev_hlock = hlock;\r\n}\r\nprint_lock_contention_bug(curr, lock, ip);\r\nreturn;\r\nfound_it:\r\nif (hlock->instance != lock)\r\nreturn;\r\nhlock->waittime_stamp = lockstat_clock();\r\ncontention_point = lock_point(hlock_class(hlock)->contention_point, ip);\r\ncontending_point = lock_point(hlock_class(hlock)->contending_point,\r\nlock->ip);\r\nstats = get_lock_stats(hlock_class(hlock));\r\nif (contention_point < LOCKSTAT_POINTS)\r\nstats->contention_point[contention_point]++;\r\nif (contending_point < LOCKSTAT_POINTS)\r\nstats->contending_point[contending_point]++;\r\nif (lock->cpu != smp_processor_id())\r\nstats->bounces[bounce_contended + !!hlock->read]++;\r\nput_lock_stats(stats);\r\n}\r\nstatic void\r\n__lock_acquired(struct lockdep_map *lock, unsigned long ip)\r\n{\r\nstruct task_struct *curr = current;\r\nstruct held_lock *hlock, *prev_hlock;\r\nstruct lock_class_stats *stats;\r\nunsigned int depth;\r\nu64 now, waittime = 0;\r\nint i, cpu;\r\ndepth = curr->lockdep_depth;\r\nif (DEBUG_LOCKS_WARN_ON(!depth))\r\nreturn;\r\nprev_hlock = NULL;\r\nfor (i = depth-1; i >= 0; i--) {\r\nhlock = curr->held_locks + i;\r\nif (prev_hlock && prev_hlock->irq_context != hlock->irq_context)\r\nbreak;\r\nif (match_held_lock(hlock, lock))\r\ngoto found_it;\r\nprev_hlock = hlock;\r\n}\r\nprint_lock_contention_bug(curr, lock, _RET_IP_);\r\nreturn;\r\nfound_it:\r\nif (hlock->instance != lock)\r\nreturn;\r\ncpu = smp_processor_id();\r\nif (hlock->waittime_stamp) {\r\nnow = lockstat_clock();\r\nwaittime = now - hlock->waittime_stamp;\r\nhlock->holdtime_stamp = now;\r\n}\r\ntrace_lock_acquired(lock, ip);\r\nstats = get_lock_stats(hlock_class(hlock));\r\nif (waittime) {\r\nif (hlock->read)\r\nlock_time_inc(&stats->read_waittime, waittime);\r\nelse\r\nlock_time_inc(&stats->write_waittime, waittime);\r\n}\r\nif (lock->cpu != cpu)\r\nstats->bounces[bounce_acquired + !!hlock->read]++;\r\nput_lock_stats(stats);\r\nlock->cpu = cpu;\r\nlock->ip = ip;\r\n}\r\nvoid lock_contended(struct lockdep_map *lock, unsigned long ip)\r\n{\r\nunsigned long flags;\r\nif (unlikely(!lock_stat))\r\nreturn;\r\nif (unlikely(current->lockdep_recursion))\r\nreturn;\r\nraw_local_irq_save(flags);\r\ncheck_flags(flags);\r\ncurrent->lockdep_recursion = 1;\r\ntrace_lock_contended(lock, ip);\r\n__lock_contended(lock, ip);\r\ncurrent->lockdep_recursion = 0;\r\nraw_local_irq_restore(flags);\r\n}\r\nvoid lock_acquired(struct lockdep_map *lock, unsigned long ip)\r\n{\r\nunsigned long flags;\r\nif (unlikely(!lock_stat))\r\nreturn;\r\nif (unlikely(current->lockdep_recursion))\r\nreturn;\r\nraw_local_irq_save(flags);\r\ncheck_flags(flags);\r\ncurrent->lockdep_recursion = 1;\r\n__lock_acquired(lock, ip);\r\ncurrent->lockdep_recursion = 0;\r\nraw_local_irq_restore(flags);\r\n}\r\nvoid lockdep_reset(void)\r\n{\r\nunsigned long flags;\r\nint i;\r\nraw_local_irq_save(flags);\r\ncurrent->curr_chain_key = 0;\r\ncurrent->lockdep_depth = 0;\r\ncurrent->lockdep_recursion = 0;\r\nmemset(current->held_locks, 0, MAX_LOCK_DEPTH*sizeof(struct held_lock));\r\nnr_hardirq_chains = 0;\r\nnr_softirq_chains = 0;\r\nnr_process_chains = 0;\r\ndebug_locks = 1;\r\nfor (i = 0; i < CHAINHASH_SIZE; i++)\r\nINIT_LIST_HEAD(chainhash_table + i);\r\nraw_local_irq_restore(flags);\r\n}\r\nstatic void zap_class(struct lock_class *class)\r\n{\r\nint i;\r\nfor (i = 0; i < nr_list_entries; i++) {\r\nif (list_entries[i].class == class)\r\nlist_del_rcu(&list_entries[i].entry);\r\n}\r\nlist_del_rcu(&class->hash_entry);\r\nlist_del_rcu(&class->lock_entry);\r\nclass->key = NULL;\r\n}\r\nstatic inline int within(const void *addr, void *start, unsigned long size)\r\n{\r\nreturn addr >= start && addr < start + size;\r\n}\r\nvoid lockdep_free_key_range(void *start, unsigned long size)\r\n{\r\nstruct lock_class *class, *next;\r\nstruct list_head *head;\r\nunsigned long flags;\r\nint i;\r\nint locked;\r\nraw_local_irq_save(flags);\r\nlocked = graph_lock();\r\nfor (i = 0; i < CLASSHASH_SIZE; i++) {\r\nhead = classhash_table + i;\r\nif (list_empty(head))\r\ncontinue;\r\nlist_for_each_entry_safe(class, next, head, hash_entry) {\r\nif (within(class->key, start, size))\r\nzap_class(class);\r\nelse if (within(class->name, start, size))\r\nzap_class(class);\r\n}\r\n}\r\nif (locked)\r\ngraph_unlock();\r\nraw_local_irq_restore(flags);\r\n}\r\nvoid lockdep_reset_lock(struct lockdep_map *lock)\r\n{\r\nstruct lock_class *class, *next;\r\nstruct list_head *head;\r\nunsigned long flags;\r\nint i, j;\r\nint locked;\r\nraw_local_irq_save(flags);\r\nfor (j = 0; j < MAX_LOCKDEP_SUBCLASSES; j++) {\r\nclass = look_up_lock_class(lock, j);\r\nif (class)\r\nzap_class(class);\r\n}\r\nlocked = graph_lock();\r\nfor (i = 0; i < CLASSHASH_SIZE; i++) {\r\nhead = classhash_table + i;\r\nif (list_empty(head))\r\ncontinue;\r\nlist_for_each_entry_safe(class, next, head, hash_entry) {\r\nint match = 0;\r\nfor (j = 0; j < NR_LOCKDEP_CACHING_CLASSES; j++)\r\nmatch |= class == lock->class_cache[j];\r\nif (unlikely(match)) {\r\nif (debug_locks_off_graph_unlock()) {\r\nWARN_ON(1);\r\n}\r\ngoto out_restore;\r\n}\r\n}\r\n}\r\nif (locked)\r\ngraph_unlock();\r\nout_restore:\r\nraw_local_irq_restore(flags);\r\n}\r\nvoid lockdep_init(void)\r\n{\r\nint i;\r\nif (lockdep_initialized)\r\nreturn;\r\nfor (i = 0; i < CLASSHASH_SIZE; i++)\r\nINIT_LIST_HEAD(classhash_table + i);\r\nfor (i = 0; i < CHAINHASH_SIZE; i++)\r\nINIT_LIST_HEAD(chainhash_table + i);\r\nlockdep_initialized = 1;\r\n}\r\nvoid __init lockdep_info(void)\r\n{\r\nprintk("Lock dependency validator: Copyright (c) 2006 Red Hat, Inc., Ingo Molnar\n");\r\nprintk("... MAX_LOCKDEP_SUBCLASSES: %lu\n", MAX_LOCKDEP_SUBCLASSES);\r\nprintk("... MAX_LOCK_DEPTH: %lu\n", MAX_LOCK_DEPTH);\r\nprintk("... MAX_LOCKDEP_KEYS: %lu\n", MAX_LOCKDEP_KEYS);\r\nprintk("... CLASSHASH_SIZE: %lu\n", CLASSHASH_SIZE);\r\nprintk("... MAX_LOCKDEP_ENTRIES: %lu\n", MAX_LOCKDEP_ENTRIES);\r\nprintk("... MAX_LOCKDEP_CHAINS: %lu\n", MAX_LOCKDEP_CHAINS);\r\nprintk("... CHAINHASH_SIZE: %lu\n", CHAINHASH_SIZE);\r\nprintk(" memory used by lock dependency info: %lu kB\n",\r\n(sizeof(struct lock_class) * MAX_LOCKDEP_KEYS +\r\nsizeof(struct list_head) * CLASSHASH_SIZE +\r\nsizeof(struct lock_list) * MAX_LOCKDEP_ENTRIES +\r\nsizeof(struct lock_chain) * MAX_LOCKDEP_CHAINS +\r\nsizeof(struct list_head) * CHAINHASH_SIZE\r\n#ifdef CONFIG_PROVE_LOCKING\r\n+ sizeof(struct circular_queue)\r\n#endif\r\n) / 1024\r\n);\r\nprintk(" per task-struct memory footprint: %lu bytes\n",\r\nsizeof(struct held_lock) * MAX_LOCK_DEPTH);\r\n#ifdef CONFIG_DEBUG_LOCKDEP\r\nif (lockdep_init_error) {\r\nprintk("WARNING: lockdep init error! lock-%s was acquired"\r\n"before lockdep_init\n", lock_init_error);\r\nprintk("Call stack leading to lockdep invocation was:\n");\r\nprint_stack_trace(&lockdep_init_trace, 0);\r\n}\r\n#endif\r\n}\r\nstatic void\r\nprint_freed_lock_bug(struct task_struct *curr, const void *mem_from,\r\nconst void *mem_to, struct held_lock *hlock)\r\n{\r\nif (!debug_locks_off())\r\nreturn;\r\nif (debug_locks_silent)\r\nreturn;\r\nprintk("\n");\r\nprintk("=========================\n");\r\nprintk("[ BUG: held lock freed! ]\n");\r\nprint_kernel_ident();\r\nprintk("-------------------------\n");\r\nprintk("%s/%d is freeing memory %p-%p, with a lock still held there!\n",\r\ncurr->comm, task_pid_nr(curr), mem_from, mem_to-1);\r\nprint_lock(hlock);\r\nlockdep_print_held_locks(curr);\r\nprintk("\nstack backtrace:\n");\r\ndump_stack();\r\n}\r\nstatic inline int not_in_range(const void* mem_from, unsigned long mem_len,\r\nconst void* lock_from, unsigned long lock_len)\r\n{\r\nreturn lock_from + lock_len <= mem_from ||\r\nmem_from + mem_len <= lock_from;\r\n}\r\nvoid debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\r\n{\r\nstruct task_struct *curr = current;\r\nstruct held_lock *hlock;\r\nunsigned long flags;\r\nint i;\r\nif (unlikely(!debug_locks))\r\nreturn;\r\nlocal_irq_save(flags);\r\nfor (i = 0; i < curr->lockdep_depth; i++) {\r\nhlock = curr->held_locks + i;\r\nif (not_in_range(mem_from, mem_len, hlock->instance,\r\nsizeof(*hlock->instance)))\r\ncontinue;\r\nprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\r\nbreak;\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void print_held_locks_bug(void)\r\n{\r\nif (!debug_locks_off())\r\nreturn;\r\nif (debug_locks_silent)\r\nreturn;\r\nprintk("\n");\r\nprintk("=====================================\n");\r\nprintk("[ BUG: %s/%d still has locks held! ]\n",\r\ncurrent->comm, task_pid_nr(current));\r\nprint_kernel_ident();\r\nprintk("-------------------------------------\n");\r\nlockdep_print_held_locks(current);\r\nprintk("\nstack backtrace:\n");\r\ndump_stack();\r\n}\r\nvoid debug_check_no_locks_held(void)\r\n{\r\nif (unlikely(current->lockdep_depth > 0))\r\nprint_held_locks_bug();\r\n}\r\nvoid debug_show_all_locks(void)\r\n{\r\nstruct task_struct *g, *p;\r\nint count = 10;\r\nint unlock = 1;\r\nif (unlikely(!debug_locks)) {\r\nprintk("INFO: lockdep is turned off.\n");\r\nreturn;\r\n}\r\nprintk("\nShowing all locks held in the system:\n");\r\nretry:\r\nif (!read_trylock(&tasklist_lock)) {\r\nif (count == 10)\r\nprintk("hm, tasklist_lock locked, retrying... ");\r\nif (count) {\r\ncount--;\r\nprintk(" #%d", 10-count);\r\nmdelay(200);\r\ngoto retry;\r\n}\r\nprintk(" ignoring it.\n");\r\nunlock = 0;\r\n} else {\r\nif (count != 10)\r\nprintk(KERN_CONT " locked it.\n");\r\n}\r\ndo_each_thread(g, p) {\r\nif (p->state == TASK_RUNNING && p != current)\r\ncontinue;\r\nif (p->lockdep_depth)\r\nlockdep_print_held_locks(p);\r\nif (!unlock)\r\nif (read_trylock(&tasklist_lock))\r\nunlock = 1;\r\n} while_each_thread(g, p);\r\nprintk("\n");\r\nprintk("=============================================\n\n");\r\nif (unlock)\r\nread_unlock(&tasklist_lock);\r\n}\r\nvoid debug_show_held_locks(struct task_struct *task)\r\n{\r\nif (unlikely(!debug_locks)) {\r\nprintk("INFO: lockdep is turned off.\n");\r\nreturn;\r\n}\r\nlockdep_print_held_locks(task);\r\n}\r\nvoid lockdep_sys_exit(void)\r\n{\r\nstruct task_struct *curr = current;\r\nif (unlikely(curr->lockdep_depth)) {\r\nif (!debug_locks_off())\r\nreturn;\r\nprintk("\n");\r\nprintk("================================================\n");\r\nprintk("[ BUG: lock held when returning to user space! ]\n");\r\nprint_kernel_ident();\r\nprintk("------------------------------------------------\n");\r\nprintk("%s/%d is leaving the kernel with locks still held!\n",\r\ncurr->comm, curr->pid);\r\nlockdep_print_held_locks(curr);\r\n}\r\n}\r\nvoid lockdep_rcu_suspicious(const char *file, const int line, const char *s)\r\n{\r\nstruct task_struct *curr = current;\r\n#ifndef CONFIG_PROVE_RCU_REPEATEDLY\r\nif (!debug_locks_off())\r\nreturn;\r\n#endif\r\nprintk("\n");\r\nprintk("===============================\n");\r\nprintk("[ INFO: suspicious RCU usage. ]\n");\r\nprint_kernel_ident();\r\nprintk("-------------------------------\n");\r\nprintk("%s:%d %s!\n", file, line, s);\r\nprintk("\nother info that might help us debug this:\n\n");\r\nprintk("\n%srcu_scheduler_active = %d, debug_locks = %d\n",\r\n!rcu_lockdep_current_cpu_online()\r\n? "RCU used illegally from offline CPU!\n"\r\n: rcu_is_cpu_idle()\r\n? "RCU used illegally from idle CPU!\n"\r\n: "",\r\nrcu_scheduler_active, debug_locks);\r\nif (rcu_is_cpu_idle())\r\nprintk("RCU used illegally from extended quiescent state!\n");\r\nlockdep_print_held_locks(curr);\r\nprintk("\nstack backtrace:\n");\r\ndump_stack();\r\n}
