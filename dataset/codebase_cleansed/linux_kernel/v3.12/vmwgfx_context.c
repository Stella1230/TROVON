static void vmw_hw_context_destroy(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDestroyContext body;\r\n} *cmd;\r\nvmw_execbuf_release_pinned_bo(dev_priv);\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for surface "\r\n"destruction.\n");\r\nreturn;\r\n}\r\ncmd->header.id = cpu_to_le32(SVGA_3D_CMD_CONTEXT_DESTROY);\r\ncmd->header.size = cpu_to_le32(sizeof(cmd->body));\r\ncmd->body.cid = cpu_to_le32(res->id);\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nvmw_3d_resource_dec(dev_priv, false);\r\n}\r\nstatic int vmw_context_init(struct vmw_private *dev_priv,\r\nstruct vmw_resource *res,\r\nvoid (*res_free) (struct vmw_resource *res))\r\n{\r\nint ret;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDefineContext body;\r\n} *cmd;\r\nret = vmw_resource_init(dev_priv, res, false,\r\nres_free, &vmw_legacy_context_func);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed to allocate a resource id.\n");\r\ngoto out_early;\r\n}\r\nif (unlikely(res->id >= SVGA3D_MAX_CONTEXT_IDS)) {\r\nDRM_ERROR("Out of hw context ids.\n");\r\nvmw_resource_unreference(&res);\r\nreturn -ENOMEM;\r\n}\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Fifo reserve failed.\n");\r\nvmw_resource_unreference(&res);\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = cpu_to_le32(SVGA_3D_CMD_CONTEXT_DEFINE);\r\ncmd->header.size = cpu_to_le32(sizeof(cmd->body));\r\ncmd->body.cid = cpu_to_le32(res->id);\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\n(void) vmw_3d_resource_inc(dev_priv, false);\r\nvmw_resource_activate(res, vmw_hw_context_destroy);\r\nreturn 0;\r\nout_early:\r\nif (res_free == NULL)\r\nkfree(res);\r\nelse\r\nres_free(res);\r\nreturn ret;\r\n}\r\nstruct vmw_resource *vmw_context_alloc(struct vmw_private *dev_priv)\r\n{\r\nstruct vmw_resource *res = kmalloc(sizeof(*res), GFP_KERNEL);\r\nint ret;\r\nif (unlikely(res == NULL))\r\nreturn NULL;\r\nret = vmw_context_init(dev_priv, res, NULL);\r\nreturn (ret == 0) ? res : NULL;\r\n}\r\nstatic struct vmw_resource *\r\nvmw_user_context_base_to_res(struct ttm_base_object *base)\r\n{\r\nreturn &(container_of(base, struct vmw_user_context, base)->res);\r\n}\r\nstatic void vmw_user_context_free(struct vmw_resource *res)\r\n{\r\nstruct vmw_user_context *ctx =\r\ncontainer_of(res, struct vmw_user_context, res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nttm_base_object_kfree(ctx, base);\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_user_context_size);\r\n}\r\nstatic void vmw_user_context_base_release(struct ttm_base_object **p_base)\r\n{\r\nstruct ttm_base_object *base = *p_base;\r\nstruct vmw_user_context *ctx =\r\ncontainer_of(base, struct vmw_user_context, base);\r\nstruct vmw_resource *res = &ctx->res;\r\n*p_base = NULL;\r\nvmw_resource_unreference(&res);\r\n}\r\nint vmw_context_destroy_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_vmw_context_arg *arg = (struct drm_vmw_context_arg *)data;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nreturn ttm_ref_object_base_unref(tfile, arg->cid, TTM_REF_USAGE);\r\n}\r\nint vmw_context_define_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct vmw_user_context *ctx;\r\nstruct vmw_resource *res;\r\nstruct vmw_resource *tmp;\r\nstruct drm_vmw_context_arg *arg = (struct drm_vmw_context_arg *)data;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nstruct vmw_master *vmaster = vmw_master(file_priv->master);\r\nint ret;\r\nif (unlikely(vmw_user_context_size == 0))\r\nvmw_user_context_size = ttm_round_pot(sizeof(*ctx)) + 128;\r\nret = ttm_read_lock(&vmaster->lock, true);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nret = ttm_mem_global_alloc(vmw_mem_glob(dev_priv),\r\nvmw_user_context_size,\r\nfalse, true);\r\nif (unlikely(ret != 0)) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("Out of graphics memory for context"\r\n" creation.\n");\r\ngoto out_unlock;\r\n}\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (unlikely(ctx == NULL)) {\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_user_context_size);\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nres = &ctx->res;\r\nctx->base.shareable = false;\r\nctx->base.tfile = NULL;\r\nret = vmw_context_init(dev_priv, res, vmw_user_context_free);\r\nif (unlikely(ret != 0))\r\ngoto out_unlock;\r\ntmp = vmw_resource_reference(&ctx->res);\r\nret = ttm_base_object_init(tfile, &ctx->base, false, VMW_RES_CONTEXT,\r\n&vmw_user_context_base_release, NULL);\r\nif (unlikely(ret != 0)) {\r\nvmw_resource_unreference(&tmp);\r\ngoto out_err;\r\n}\r\narg->cid = ctx->base.hash.key;\r\nout_err:\r\nvmw_resource_unreference(&res);\r\nout_unlock:\r\nttm_read_unlock(&vmaster->lock);\r\nreturn ret;\r\n}
