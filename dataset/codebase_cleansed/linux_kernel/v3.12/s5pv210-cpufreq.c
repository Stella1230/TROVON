static void s5pv210_set_refresh(enum s5pv210_dmc_port ch, unsigned long freq)\r\n{\r\nunsigned long tmp, tmp1;\r\nvoid __iomem *reg = NULL;\r\nif (ch == DMC0) {\r\nreg = (S5P_VA_DMC0 + 0x30);\r\n} else if (ch == DMC1) {\r\nreg = (S5P_VA_DMC1 + 0x30);\r\n} else {\r\nprintk(KERN_ERR "Cannot find DMC port\n");\r\nreturn;\r\n}\r\ntmp = s5pv210_dram_conf[ch].freq;\r\ndo_div(tmp, freq);\r\ntmp1 = s5pv210_dram_conf[ch].refresh;\r\ndo_div(tmp1, tmp);\r\n__raw_writel(tmp1, reg);\r\n}\r\nstatic int s5pv210_verify_speed(struct cpufreq_policy *policy)\r\n{\r\nif (policy->cpu)\r\nreturn -EINVAL;\r\nreturn cpufreq_frequency_table_verify(policy, s5pv210_freq_table);\r\n}\r\nstatic unsigned int s5pv210_getspeed(unsigned int cpu)\r\n{\r\nif (cpu)\r\nreturn 0;\r\nreturn clk_get_rate(cpu_clk) / 1000;\r\n}\r\nstatic int s5pv210_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nunsigned long reg;\r\nunsigned int index, priv_index;\r\nunsigned int pll_changing = 0;\r\nunsigned int bus_speed_changing = 0;\r\nint arm_volt, int_volt;\r\nint ret = 0;\r\nmutex_lock(&set_freq_lock);\r\nif (relation & ENABLE_FURTHER_CPUFREQ)\r\nno_cpufreq_access = false;\r\nif (no_cpufreq_access) {\r\n#ifdef CONFIG_PM_VERBOSE\r\npr_err("%s:%d denied access to %s as it is disabled"\r\n"temporarily\n", __FILE__, __LINE__, __func__);\r\n#endif\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nif (relation & DISABLE_FURTHER_CPUFREQ)\r\nno_cpufreq_access = true;\r\nrelation &= ~(ENABLE_FURTHER_CPUFREQ | DISABLE_FURTHER_CPUFREQ);\r\nfreqs.old = s5pv210_getspeed(0);\r\nif (cpufreq_frequency_table_target(policy, s5pv210_freq_table,\r\ntarget_freq, relation, &index)) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nfreqs.new = s5pv210_freq_table[index].frequency;\r\nif (freqs.new == freqs.old)\r\ngoto exit;\r\nif (cpufreq_frequency_table_target(policy, s5pv210_freq_table,\r\nfreqs.old, relation, &priv_index)) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\narm_volt = dvs_conf[index].arm_volt;\r\nint_volt = dvs_conf[index].int_volt;\r\nif (freqs.new > freqs.old) {\r\nret = regulator_set_voltage(arm_regulator,\r\narm_volt, arm_volt_max);\r\nif (ret)\r\ngoto exit;\r\nret = regulator_set_voltage(int_regulator,\r\nint_volt, int_volt_max);\r\nif (ret)\r\ngoto exit;\r\n}\r\ncpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);\r\nif ((index == L0) || (priv_index == L0))\r\npll_changing = 1;\r\nif ((index == L4) || (priv_index == L4))\r\nbus_speed_changing = 1;\r\nif (bus_speed_changing) {\r\nif (pll_changing)\r\ns5pv210_set_refresh(DMC1, 83000);\r\nelse\r\ns5pv210_set_refresh(DMC1, 100000);\r\ns5pv210_set_refresh(DMC0, 83000);\r\n}\r\nif (pll_changing) {\r\nreg = __raw_readl(S5P_CLK_DIV2);\r\nreg &= ~(S5P_CLKDIV2_G3D_MASK | S5P_CLKDIV2_MFC_MASK);\r\nreg |= (3 << S5P_CLKDIV2_G3D_SHIFT) |\r\n(3 << S5P_CLKDIV2_MFC_SHIFT);\r\n__raw_writel(reg, S5P_CLK_DIV2);\r\ndo {\r\nreg = __raw_readl(S5P_CLKDIV_STAT0);\r\n} while (reg & ((1 << 16) | (1 << 17)));\r\nreg = __raw_readl(S5P_CLK_SRC2);\r\nreg &= ~(S5P_CLKSRC2_G3D_MASK | S5P_CLKSRC2_MFC_MASK);\r\nreg |= (1 << S5P_CLKSRC2_G3D_SHIFT) |\r\n(1 << S5P_CLKSRC2_MFC_SHIFT);\r\n__raw_writel(reg, S5P_CLK_SRC2);\r\ndo {\r\nreg = __raw_readl(S5P_CLKMUX_STAT1);\r\n} while (reg & ((1 << 7) | (1 << 3)));\r\nif (!bus_speed_changing)\r\ns5pv210_set_refresh(DMC1, 133000);\r\nreg = __raw_readl(S5P_CLK_SRC0);\r\nreg &= ~(S5P_CLKSRC0_MUX200_MASK);\r\nreg |= (0x1 << S5P_CLKSRC0_MUX200_SHIFT);\r\n__raw_writel(reg, S5P_CLK_SRC0);\r\ndo {\r\nreg = __raw_readl(S5P_CLKMUX_STAT0);\r\n} while (reg & (0x1 << 18));\r\n}\r\nreg = __raw_readl(S5P_CLK_DIV0);\r\nreg &= ~(S5P_CLKDIV0_APLL_MASK | S5P_CLKDIV0_A2M_MASK |\r\nS5P_CLKDIV0_HCLK200_MASK | S5P_CLKDIV0_PCLK100_MASK |\r\nS5P_CLKDIV0_HCLK166_MASK | S5P_CLKDIV0_PCLK83_MASK |\r\nS5P_CLKDIV0_HCLK133_MASK | S5P_CLKDIV0_PCLK66_MASK);\r\nreg |= ((clkdiv_val[index][0] << S5P_CLKDIV0_APLL_SHIFT) |\r\n(clkdiv_val[index][1] << S5P_CLKDIV0_A2M_SHIFT) |\r\n(clkdiv_val[index][2] << S5P_CLKDIV0_HCLK200_SHIFT) |\r\n(clkdiv_val[index][3] << S5P_CLKDIV0_PCLK100_SHIFT) |\r\n(clkdiv_val[index][4] << S5P_CLKDIV0_HCLK166_SHIFT) |\r\n(clkdiv_val[index][5] << S5P_CLKDIV0_PCLK83_SHIFT) |\r\n(clkdiv_val[index][6] << S5P_CLKDIV0_HCLK133_SHIFT) |\r\n(clkdiv_val[index][7] << S5P_CLKDIV0_PCLK66_SHIFT));\r\n__raw_writel(reg, S5P_CLK_DIV0);\r\ndo {\r\nreg = __raw_readl(S5P_CLKDIV_STAT0);\r\n} while (reg & 0xff);\r\nreg = __raw_readl(S5P_ARM_MCS_CON);\r\nreg &= ~0x3;\r\nif (index >= L3)\r\nreg |= 0x3;\r\nelse\r\nreg |= 0x1;\r\n__raw_writel(reg, S5P_ARM_MCS_CON);\r\nif (pll_changing) {\r\n__raw_writel(0x2cf, S5P_APLL_LOCK);\r\nif (index == L0)\r\n__raw_writel(APLL_VAL_1000, S5P_APLL_CON);\r\nelse\r\n__raw_writel(APLL_VAL_800, S5P_APLL_CON);\r\ndo {\r\nreg = __raw_readl(S5P_APLL_CON);\r\n} while (!(reg & (0x1 << 29)));\r\nreg = __raw_readl(S5P_CLK_SRC2);\r\nreg &= ~(S5P_CLKSRC2_G3D_MASK | S5P_CLKSRC2_MFC_MASK);\r\nreg |= (0 << S5P_CLKSRC2_G3D_SHIFT) |\r\n(0 << S5P_CLKSRC2_MFC_SHIFT);\r\n__raw_writel(reg, S5P_CLK_SRC2);\r\ndo {\r\nreg = __raw_readl(S5P_CLKMUX_STAT1);\r\n} while (reg & ((1 << 7) | (1 << 3)));\r\nreg = __raw_readl(S5P_CLK_DIV2);\r\nreg &= ~(S5P_CLKDIV2_G3D_MASK | S5P_CLKDIV2_MFC_MASK);\r\nreg |= (clkdiv_val[index][10] << S5P_CLKDIV2_G3D_SHIFT) |\r\n(clkdiv_val[index][9] << S5P_CLKDIV2_MFC_SHIFT);\r\n__raw_writel(reg, S5P_CLK_DIV2);\r\ndo {\r\nreg = __raw_readl(S5P_CLKDIV_STAT0);\r\n} while (reg & ((1 << 16) | (1 << 17)));\r\nreg = __raw_readl(S5P_CLK_SRC0);\r\nreg &= ~(S5P_CLKSRC0_MUX200_MASK);\r\nreg |= (0x0 << S5P_CLKSRC0_MUX200_SHIFT);\r\n__raw_writel(reg, S5P_CLK_SRC0);\r\ndo {\r\nreg = __raw_readl(S5P_CLKMUX_STAT0);\r\n} while (reg & (0x1 << 18));\r\nif (!bus_speed_changing)\r\ns5pv210_set_refresh(DMC1, 200000);\r\n}\r\nif (bus_speed_changing) {\r\nreg = __raw_readl(S5P_CLK_DIV6);\r\nreg &= ~S5P_CLKDIV6_ONEDRAM_MASK;\r\nreg |= (clkdiv_val[index][8] << S5P_CLKDIV6_ONEDRAM_SHIFT);\r\n__raw_writel(reg, S5P_CLK_DIV6);\r\ndo {\r\nreg = __raw_readl(S5P_CLKDIV_STAT1);\r\n} while (reg & (1 << 15));\r\nif (index != L4) {\r\ns5pv210_set_refresh(DMC0, 166000);\r\ns5pv210_set_refresh(DMC1, 200000);\r\n} else {\r\ns5pv210_set_refresh(DMC0, 83000);\r\ns5pv210_set_refresh(DMC1, 100000);\r\n}\r\n}\r\ncpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);\r\nif (freqs.new < freqs.old) {\r\nregulator_set_voltage(int_regulator,\r\nint_volt, int_volt_max);\r\nregulator_set_voltage(arm_regulator,\r\narm_volt, arm_volt_max);\r\n}\r\nprintk(KERN_DEBUG "Perf changed[L%d]\n", index);\r\nexit:\r\nmutex_unlock(&set_freq_lock);\r\nreturn ret;\r\n}\r\nstatic int s5pv210_cpufreq_suspend(struct cpufreq_policy *policy)\r\n{\r\nreturn 0;\r\n}\r\nstatic int s5pv210_cpufreq_resume(struct cpufreq_policy *policy)\r\n{\r\nreturn 0;\r\n}\r\nstatic int check_mem_type(void __iomem *dmc_reg)\r\n{\r\nunsigned long val;\r\nval = __raw_readl(dmc_reg + 0x4);\r\nval = (val & (0xf << 8));\r\nreturn val >> 8;\r\n}\r\nstatic int __init s5pv210_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nunsigned long mem_type;\r\nint ret;\r\ncpu_clk = clk_get(NULL, "armclk");\r\nif (IS_ERR(cpu_clk))\r\nreturn PTR_ERR(cpu_clk);\r\ndmc0_clk = clk_get(NULL, "sclk_dmc0");\r\nif (IS_ERR(dmc0_clk)) {\r\nret = PTR_ERR(dmc0_clk);\r\ngoto out_dmc0;\r\n}\r\ndmc1_clk = clk_get(NULL, "hclk_msys");\r\nif (IS_ERR(dmc1_clk)) {\r\nret = PTR_ERR(dmc1_clk);\r\ngoto out_dmc1;\r\n}\r\nif (policy->cpu != 0) {\r\nret = -EINVAL;\r\ngoto out_dmc1;\r\n}\r\nmem_type = check_mem_type(S5P_VA_DMC0);\r\nif ((mem_type != LPDDR) && (mem_type != LPDDR2)) {\r\nprintk(KERN_ERR "CPUFreq doesn't support this memory type\n");\r\nret = -EINVAL;\r\ngoto out_dmc1;\r\n}\r\ns5pv210_dram_conf[0].refresh = (__raw_readl(S5P_VA_DMC0 + 0x30) * 1000);\r\ns5pv210_dram_conf[0].freq = clk_get_rate(dmc0_clk);\r\ns5pv210_dram_conf[1].refresh = (__raw_readl(S5P_VA_DMC1 + 0x30) * 1000);\r\ns5pv210_dram_conf[1].freq = clk_get_rate(dmc1_clk);\r\npolicy->cur = policy->min = policy->max = s5pv210_getspeed(0);\r\ncpufreq_frequency_table_get_attr(s5pv210_freq_table, policy->cpu);\r\npolicy->cpuinfo.transition_latency = 40000;\r\nreturn cpufreq_frequency_table_cpuinfo(policy, s5pv210_freq_table);\r\nout_dmc1:\r\nclk_put(dmc0_clk);\r\nout_dmc0:\r\nclk_put(cpu_clk);\r\nreturn ret;\r\n}\r\nstatic int s5pv210_cpufreq_notifier_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nint ret;\r\nswitch (event) {\r\ncase PM_SUSPEND_PREPARE:\r\nret = cpufreq_driver_target(cpufreq_cpu_get(0), SLEEP_FREQ,\r\nDISABLE_FURTHER_CPUFREQ);\r\nif (ret < 0)\r\nreturn NOTIFY_BAD;\r\nreturn NOTIFY_OK;\r\ncase PM_POST_RESTORE:\r\ncase PM_POST_SUSPEND:\r\ncpufreq_driver_target(cpufreq_cpu_get(0), SLEEP_FREQ,\r\nENABLE_FURTHER_CPUFREQ);\r\nreturn NOTIFY_OK;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int s5pv210_cpufreq_reboot_notifier_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nint ret;\r\nret = cpufreq_driver_target(cpufreq_cpu_get(0), SLEEP_FREQ,\r\nDISABLE_FURTHER_CPUFREQ);\r\nif (ret < 0)\r\nreturn NOTIFY_BAD;\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init s5pv210_cpufreq_init(void)\r\n{\r\narm_regulator = regulator_get(NULL, "vddarm");\r\nif (IS_ERR(arm_regulator)) {\r\npr_err("failed to get regulator vddarm");\r\nreturn PTR_ERR(arm_regulator);\r\n}\r\nint_regulator = regulator_get(NULL, "vddint");\r\nif (IS_ERR(int_regulator)) {\r\npr_err("failed to get regulator vddint");\r\nregulator_put(arm_regulator);\r\nreturn PTR_ERR(int_regulator);\r\n}\r\nregister_pm_notifier(&s5pv210_cpufreq_notifier);\r\nregister_reboot_notifier(&s5pv210_cpufreq_reboot_notifier);\r\nreturn cpufreq_register_driver(&s5pv210_driver);\r\n}
