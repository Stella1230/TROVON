static void\r\nchip_init(int io_port)\r\n{\r\nREG1(io_port);\r\noutb(0x01, io_port + PIO_STATUS);\r\noutb(0x00, io_port + PIO_FLAG);\r\noutb(C4_IMG, io_port + CONFIG4);\r\noutb(C3_IMG, io_port + CONFIG3);\r\noutb(C2_IMG, io_port + CONFIG2);\r\noutb(C1_IMG, io_port + CONFIG1);\r\noutb(0x05, io_port + CLKCONV);\r\noutb(0x9C, io_port + SRTIMOUT);\r\noutb(0x05, io_port + SYNCPRD);\r\noutb(SYNC_MODE, io_port + SYNCOFF);\r\n}\r\nstatic void\r\nSYM53C500_int_host_reset(int io_port)\r\n{\r\noutb(C4_IMG, io_port + CONFIG4);\r\noutb(CHIP_RESET, io_port + CMD_REG);\r\noutb(SCSI_NOP, io_port + CMD_REG);\r\noutb(SCSI_RESET, io_port + CMD_REG);\r\nchip_init(io_port);\r\n}\r\nstatic __inline__ int\r\nSYM53C500_pio_read(int fast_pio, int base, unsigned char *request, unsigned int reqlen)\r\n{\r\nint i;\r\nint len;\r\nREG1(base);\r\nwhile (reqlen) {\r\ni = inb(base + PIO_STATUS);\r\nif (i & 0x80)\r\nreturn 0;\r\nswitch (i & 0x1e) {\r\ndefault:\r\ncase 0x10:\r\nlen = 0;\r\nbreak;\r\ncase 0x0:\r\nlen = 1;\r\nbreak;\r\ncase 0x8:\r\nlen = 42;\r\nbreak;\r\ncase 0xc:\r\nlen = 84;\r\nbreak;\r\ncase 0xe:\r\nlen = 128;\r\nbreak;\r\n}\r\nif ((i & 0x40) && len == 0) {\r\nreturn 0;\r\n}\r\nif (len) {\r\nif (len > reqlen)\r\nlen = reqlen;\r\nif (fast_pio && len > 3) {\r\ninsl(base + PIO_FIFO, request, len >> 2);\r\nrequest += len & 0xfc;\r\nreqlen -= len & 0xfc;\r\n} else {\r\nwhile (len--) {\r\n*request++ = inb(base + PIO_FIFO);\r\nreqlen--;\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic __inline__ int\r\nSYM53C500_pio_write(int fast_pio, int base, unsigned char *request, unsigned int reqlen)\r\n{\r\nint i = 0;\r\nint len;\r\nREG1(base);\r\nwhile (reqlen && !(i & 0x40)) {\r\ni = inb(base + PIO_STATUS);\r\nif (i & 0x80)\r\nreturn 0;\r\nswitch (i & 0x1e) {\r\ncase 0x10:\r\nlen = 128;\r\nbreak;\r\ncase 0x0:\r\nlen = 84;\r\nbreak;\r\ncase 0x8:\r\nlen = 42;\r\nbreak;\r\ncase 0xc:\r\nlen = 1;\r\nbreak;\r\ndefault:\r\ncase 0xe:\r\nlen = 0;\r\nbreak;\r\n}\r\nif (len) {\r\nif (len > reqlen)\r\nlen = reqlen;\r\nif (fast_pio && len > 3) {\r\noutsl(base + PIO_FIFO, request, len >> 2);\r\nrequest += len & 0xfc;\r\nreqlen -= len & 0xfc;\r\n} else {\r\nwhile (len--) {\r\noutb(*request++, base + PIO_FIFO);\r\nreqlen--;\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t\r\nSYM53C500_intr(int irq, void *dev_id)\r\n{\r\nunsigned long flags;\r\nstruct Scsi_Host *dev = dev_id;\r\nDEB(unsigned char fifo_size;)\r\nDEB(unsigned char seq_reg;)\r\nunsigned char status, int_reg;\r\nunsigned char pio_status;\r\nint port_base = dev->io_port;\r\nstruct sym53c500_data *data =\r\n(struct sym53c500_data *)dev->hostdata;\r\nstruct scsi_cmnd *curSC = data->current_SC;\r\nint fast_pio = data->fast_pio;\r\nspin_lock_irqsave(dev->host_lock, flags);\r\nVDEB(printk("SYM53C500_intr called\n"));\r\nREG1(port_base);\r\npio_status = inb(port_base + PIO_STATUS);\r\nREG0(port_base);\r\nstatus = inb(port_base + STAT_REG);\r\nDEB(seq_reg = inb(port_base + SEQ_REG));\r\nint_reg = inb(port_base + INT_REG);\r\nDEB(fifo_size = inb(port_base + FIFO_FLAGS) & 0x1f);\r\n#if SYM53C500_DEBUG\r\nprintk("status=%02x, seq_reg=%02x, int_reg=%02x, fifo_size=%02x",\r\nstatus, seq_reg, int_reg, fifo_size);\r\nprintk(", pio=%02x\n", pio_status);\r\n#endif\r\nif (int_reg & 0x80) {\r\nDEB(printk("SYM53C500: reset intr received\n"));\r\ncurSC->result = DID_RESET << 16;\r\ngoto idle_out;\r\n}\r\nif (pio_status & 0x80) {\r\nprintk("SYM53C500: Warning: PIO error!\n");\r\ncurSC->result = DID_ERROR << 16;\r\ngoto idle_out;\r\n}\r\nif (status & 0x20) {\r\nprintk("SYM53C500: Warning: parity error!\n");\r\ncurSC->result = DID_PARITY << 16;\r\ngoto idle_out;\r\n}\r\nif (status & 0x40) {\r\nprintk("SYM53C500: Warning: gross error!\n");\r\ncurSC->result = DID_ERROR << 16;\r\ngoto idle_out;\r\n}\r\nif (int_reg & 0x20) {\r\nDEB(printk("SYM53C500: disconnect intr received\n"));\r\nif (curSC->SCp.phase != message_in) {\r\ncurSC->result = DID_NO_CONNECT << 16;\r\n} else {\r\ncurSC->result = (curSC->SCp.Status & 0xff)\r\n| ((curSC->SCp.Message & 0xff) << 8) | (DID_OK << 16);\r\n}\r\ngoto idle_out;\r\n}\r\nswitch (status & 0x07) {\r\ncase 0x00:\r\nif (int_reg & 0x10) {\r\nstruct scatterlist *sg;\r\nint i;\r\ncurSC->SCp.phase = data_out;\r\nVDEB(printk("SYM53C500: Data-Out phase\n"));\r\noutb(FLUSH_FIFO, port_base + CMD_REG);\r\nLOAD_DMA_COUNT(port_base, scsi_bufflen(curSC));\r\noutb(TRANSFER_INFO | DMA_OP, port_base + CMD_REG);\r\nscsi_for_each_sg(curSC, sg, scsi_sg_count(curSC), i) {\r\nSYM53C500_pio_write(fast_pio, port_base,\r\nsg_virt(sg), sg->length);\r\n}\r\nREG0(port_base);\r\n}\r\nbreak;\r\ncase 0x01:\r\nif (int_reg & 0x10) {\r\nstruct scatterlist *sg;\r\nint i;\r\ncurSC->SCp.phase = data_in;\r\nVDEB(printk("SYM53C500: Data-In phase\n"));\r\noutb(FLUSH_FIFO, port_base + CMD_REG);\r\nLOAD_DMA_COUNT(port_base, scsi_bufflen(curSC));\r\noutb(TRANSFER_INFO | DMA_OP, port_base + CMD_REG);\r\nscsi_for_each_sg(curSC, sg, scsi_sg_count(curSC), i) {\r\nSYM53C500_pio_read(fast_pio, port_base,\r\nsg_virt(sg), sg->length);\r\n}\r\nREG0(port_base);\r\n}\r\nbreak;\r\ncase 0x02:\r\ncurSC->SCp.phase = command_ph;\r\nprintk("SYM53C500: Warning: Unknown interrupt occurred in command phase!\n");\r\nbreak;\r\ncase 0x03:\r\ncurSC->SCp.phase = status_ph;\r\nVDEB(printk("SYM53C500: Status phase\n"));\r\noutb(FLUSH_FIFO, port_base + CMD_REG);\r\noutb(INIT_CMD_COMPLETE, port_base + CMD_REG);\r\nbreak;\r\ncase 0x04:\r\ncase 0x05:\r\nprintk("SYM53C500: WARNING: Reserved phase!!!\n");\r\nbreak;\r\ncase 0x06:\r\nDEB(printk("SYM53C500: Message-Out phase\n"));\r\ncurSC->SCp.phase = message_out;\r\noutb(SET_ATN, port_base + CMD_REG);\r\noutb(MSG_ACCEPT, port_base + CMD_REG);\r\nbreak;\r\ncase 0x07:\r\nVDEB(printk("SYM53C500: Message-In phase\n"));\r\ncurSC->SCp.phase = message_in;\r\ncurSC->SCp.Status = inb(port_base + SCSI_FIFO);\r\ncurSC->SCp.Message = inb(port_base + SCSI_FIFO);\r\nVDEB(printk("SCSI FIFO size=%d\n", inb(port_base + FIFO_FLAGS) & 0x1f));\r\nDEB(printk("Status = %02x Message = %02x\n", curSC->SCp.Status, curSC->SCp.Message));\r\nif (curSC->SCp.Message == SAVE_POINTERS || curSC->SCp.Message == DISCONNECT) {\r\noutb(SET_ATN, port_base + CMD_REG);\r\nDEB(printk("Discarding SAVE_POINTERS message\n"));\r\n}\r\noutb(MSG_ACCEPT, port_base + CMD_REG);\r\nbreak;\r\n}\r\nout:\r\nspin_unlock_irqrestore(dev->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\nidle_out:\r\ncurSC->SCp.phase = idle;\r\ncurSC->scsi_done(curSC);\r\ngoto out;\r\n}\r\nstatic void\r\nSYM53C500_release(struct pcmcia_device *link)\r\n{\r\nstruct scsi_info_t *info = link->priv;\r\nstruct Scsi_Host *shost = info->host;\r\ndev_dbg(&link->dev, "SYM53C500_release\n");\r\nscsi_remove_host(shost);\r\nif (shost->irq)\r\nfree_irq(shost->irq, shost);\r\nif (shost->io_port && shost->n_io_port)\r\nrelease_region(shost->io_port, shost->n_io_port);\r\npcmcia_disable_device(link);\r\nscsi_host_put(shost);\r\n}\r\nstatic const char*\r\nSYM53C500_info(struct Scsi_Host *SChost)\r\n{\r\nstatic char info_msg[256];\r\nstruct sym53c500_data *data =\r\n(struct sym53c500_data *)SChost->hostdata;\r\nDEB(printk("SYM53C500_info called\n"));\r\n(void)snprintf(info_msg, sizeof(info_msg),\r\n"SYM53C500 at 0x%lx, IRQ %d, %s PIO mode.",\r\nSChost->io_port, SChost->irq, data->fast_pio ? "fast" : "slow");\r\nreturn (info_msg);\r\n}\r\nstatic int\r\nSYM53C500_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))\r\n{\r\nint i;\r\nint port_base = SCpnt->device->host->io_port;\r\nstruct sym53c500_data *data =\r\n(struct sym53c500_data *)SCpnt->device->host->hostdata;\r\nVDEB(printk("SYM53C500_queue called\n"));\r\nDEB(printk("cmd=%02x, cmd_len=%02x, target=%02x, lun=%02x, bufflen=%d\n",\r\nSCpnt->cmnd[0], SCpnt->cmd_len, SCpnt->device->id,\r\nSCpnt->device->lun, scsi_bufflen(SCpnt)));\r\nVDEB(for (i = 0; i < SCpnt->cmd_len; i++)\r\nprintk("cmd[%d]=%02x ", i, SCpnt->cmnd[i]));\r\nVDEB(printk("\n"));\r\ndata->current_SC = SCpnt;\r\ndata->current_SC->scsi_done = done;\r\ndata->current_SC->SCp.phase = command_ph;\r\ndata->current_SC->SCp.Status = 0;\r\ndata->current_SC->SCp.Message = 0;\r\nREG0(port_base);\r\noutb(scmd_id(SCpnt), port_base + DEST_ID);\r\noutb(FLUSH_FIFO, port_base + CMD_REG);\r\nfor (i = 0; i < SCpnt->cmd_len; i++) {\r\noutb(SCpnt->cmnd[i], port_base + SCSI_FIFO);\r\n}\r\noutb(SELECT_NO_ATN, port_base + CMD_REG);\r\nreturn 0;\r\n}\r\nstatic int\r\nSYM53C500_biosparm(struct scsi_device *disk,\r\nstruct block_device *dev,\r\nsector_t capacity, int *info_array)\r\n{\r\nint size;\r\nDEB(printk("SYM53C500_biosparm called\n"));\r\nsize = capacity;\r\ninfo_array[0] = 64;\r\ninfo_array[1] = 32;\r\ninfo_array[2] = size >> 11;\r\nif (info_array[2] > 1024) {\r\ninfo_array[0] = 255;\r\ninfo_array[1] = 63;\r\ninfo_array[2] = size / (255 * 63);\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nSYM53C500_show_pio(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *SHp = class_to_shost(dev);\r\nstruct sym53c500_data *data =\r\n(struct sym53c500_data *)SHp->hostdata;\r\nreturn snprintf(buf, 4, "%d\n", data->fast_pio);\r\n}\r\nstatic ssize_t\r\nSYM53C500_store_pio(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint pio;\r\nstruct Scsi_Host *SHp = class_to_shost(dev);\r\nstruct sym53c500_data *data =\r\n(struct sym53c500_data *)SHp->hostdata;\r\npio = simple_strtoul(buf, NULL, 0);\r\nif (pio == 0 || pio == 1) {\r\ndata->fast_pio = pio;\r\nreturn count;\r\n}\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int SYM53C500_config_check(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\np_dev->io_lines = 10;\r\np_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\r\nif (p_dev->resource[0]->start == 0)\r\nreturn -ENODEV;\r\nreturn pcmcia_request_io(p_dev);\r\n}\r\nstatic int\r\nSYM53C500_config(struct pcmcia_device *link)\r\n{\r\nstruct scsi_info_t *info = link->priv;\r\nint ret;\r\nint irq_level, port_base;\r\nstruct Scsi_Host *host;\r\nstruct scsi_host_template *tpnt = &sym53c500_driver_template;\r\nstruct sym53c500_data *data;\r\ndev_dbg(&link->dev, "SYM53C500_config\n");\r\ninfo->manf_id = link->manf_id;\r\nret = pcmcia_loop_config(link, SYM53C500_config_check, NULL);\r\nif (ret)\r\ngoto failed;\r\nif (!link->irq)\r\ngoto failed;\r\nret = pcmcia_enable_device(link);\r\nif (ret)\r\ngoto failed;\r\nif ((info->manf_id == MANFID_MACNICA) ||\r\n(info->manf_id == MANFID_PIONEER) ||\r\n(info->manf_id == 0x0098)) {\r\noutb(0xb4, link->resource[0]->start + 0xd);\r\noutb(0x24, link->resource[0]->start + 0x9);\r\noutb(0x04, link->resource[0]->start + 0xd);\r\n}\r\nport_base = link->resource[0]->start;\r\nirq_level = link->irq;\r\nDEB(printk("SYM53C500: port_base=0x%x, irq=%d, fast_pio=%d\n",\r\nport_base, irq_level, USE_FAST_PIO);)\r\nchip_init(port_base);\r\nhost = scsi_host_alloc(tpnt, sizeof(struct sym53c500_data));\r\nif (!host) {\r\nprintk("SYM53C500: Unable to register host, giving up.\n");\r\ngoto err_release;\r\n}\r\ndata = (struct sym53c500_data *)host->hostdata;\r\nif (irq_level > 0) {\r\nif (request_irq(irq_level, SYM53C500_intr, IRQF_SHARED, "SYM53C500", host)) {\r\nprintk("SYM53C500: unable to allocate IRQ %d\n", irq_level);\r\ngoto err_free_scsi;\r\n}\r\nDEB(printk("SYM53C500: allocated IRQ %d\n", irq_level));\r\n} else if (irq_level == 0) {\r\nDEB(printk("SYM53C500: No interrupts detected\n"));\r\ngoto err_free_scsi;\r\n} else {\r\nDEB(printk("SYM53C500: Shouldn't get here!\n"));\r\ngoto err_free_scsi;\r\n}\r\nhost->unique_id = port_base;\r\nhost->irq = irq_level;\r\nhost->io_port = port_base;\r\nhost->n_io_port = 0x10;\r\nhost->dma_channel = -1;\r\ndata->fast_pio = USE_FAST_PIO;\r\ninfo->host = host;\r\nif (scsi_add_host(host, NULL))\r\ngoto err_free_irq;\r\nscsi_scan_host(host);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(irq_level, host);\r\nerr_free_scsi:\r\nscsi_host_put(host);\r\nerr_release:\r\nrelease_region(port_base, 0x10);\r\nprintk(KERN_INFO "sym53c500_cs: no SCSI devices found\n");\r\nreturn -ENODEV;\r\nfailed:\r\nSYM53C500_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic int sym53c500_resume(struct pcmcia_device *link)\r\n{\r\nstruct scsi_info_t *info = link->priv;\r\nif ((info->manf_id == MANFID_MACNICA) ||\r\n(info->manf_id == MANFID_PIONEER) ||\r\n(info->manf_id == 0x0098)) {\r\noutb(0x80, link->resource[0]->start + 0xd);\r\noutb(0x24, link->resource[0]->start + 0x9);\r\noutb(0x04, link->resource[0]->start + 0xd);\r\n}\r\nSYM53C500_int_host_reset(link->resource[0]->start);\r\nreturn 0;\r\n}\r\nstatic void\r\nSYM53C500_detach(struct pcmcia_device *link)\r\n{\r\ndev_dbg(&link->dev, "SYM53C500_detach\n");\r\nSYM53C500_release(link);\r\nkfree(link->priv);\r\nlink->priv = NULL;\r\n}\r\nstatic int\r\nSYM53C500_probe(struct pcmcia_device *link)\r\n{\r\nstruct scsi_info_t *info;\r\ndev_dbg(&link->dev, "SYM53C500_attach()\n");\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->p_dev = link;\r\nlink->priv = info;\r\nlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\r\nreturn SYM53C500_config(link);\r\n}\r\nstatic int __init\r\ninit_sym53c500_cs(void)\r\n{\r\nreturn pcmcia_register_driver(&sym53c500_cs_driver);\r\n}\r\nstatic void __exit\r\nexit_sym53c500_cs(void)\r\n{\r\npcmcia_unregister_driver(&sym53c500_cs_driver);\r\n}
