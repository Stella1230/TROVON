static void mid_get_fuse_settings(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct pci_dev *pci_root = pci_get_bus_and_slot(0, 0);\r\nuint32_t fuse_value = 0;\r\nuint32_t fuse_value_tmp = 0;\r\n#define FB_REG06 0xD0810600\r\n#define FB_MIPI_DISABLE (1 << 11)\r\n#define FB_REG09 0xD0810900\r\n#define FB_REG09 0xD0810900\r\n#define FB_SKU_MASK 0x7000\r\n#define FB_SKU_SHIFT 12\r\n#define FB_SKU_100 0\r\n#define FB_SKU_100L 1\r\n#define FB_SKU_83 2\r\nif (pci_root == NULL) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\npci_write_config_dword(pci_root, 0xD0, FB_REG06);\r\npci_read_config_dword(pci_root, 0xD4, &fuse_value);\r\nif (IS_MRST(dev))\r\ndev_priv->iLVDS_enable = fuse_value & FB_MIPI_DISABLE;\r\nDRM_INFO("internal display is %s\n",\r\ndev_priv->iLVDS_enable ? "LVDS display" : "MIPI display");\r\nif (dev_priv->iLVDS_enable) {\r\ndev_priv->is_lvds_on = true;\r\ndev_priv->is_mipi_on = false;\r\n} else {\r\ndev_priv->is_mipi_on = true;\r\ndev_priv->is_lvds_on = false;\r\n}\r\ndev_priv->video_device_fuse = fuse_value;\r\npci_write_config_dword(pci_root, 0xD0, FB_REG09);\r\npci_read_config_dword(pci_root, 0xD4, &fuse_value);\r\ndev_dbg(dev->dev, "SKU values is 0x%x.\n", fuse_value);\r\nfuse_value_tmp = (fuse_value & FB_SKU_MASK) >> FB_SKU_SHIFT;\r\ndev_priv->fuse_reg_value = fuse_value;\r\nswitch (fuse_value_tmp) {\r\ncase FB_SKU_100:\r\ndev_priv->core_freq = 200;\r\nbreak;\r\ncase FB_SKU_100L:\r\ndev_priv->core_freq = 100;\r\nbreak;\r\ncase FB_SKU_83:\r\ndev_priv->core_freq = 166;\r\nbreak;\r\ndefault:\r\ndev_warn(dev->dev, "Invalid SKU values, SKU value = 0x%08x\n",\r\nfuse_value_tmp);\r\ndev_priv->core_freq = 0;\r\n}\r\ndev_dbg(dev->dev, "LNC core clk is %dMHz.\n", dev_priv->core_freq);\r\npci_dev_put(pci_root);\r\n}\r\nstatic void mid_get_pci_revID(struct drm_psb_private *dev_priv)\r\n{\r\nuint32_t platform_rev_id = 0;\r\nstruct pci_dev *pci_gfx_root = pci_get_bus_and_slot(0, PCI_DEVFN(2, 0));\r\nif (pci_gfx_root == NULL) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\npci_read_config_dword(pci_gfx_root, 0x08, &platform_rev_id);\r\ndev_priv->platform_rev_id = (uint8_t) platform_rev_id;\r\npci_dev_put(pci_gfx_root);\r\ndev_dbg(dev_priv->dev->dev, "platform_rev_id is %x\n",\r\ndev_priv->platform_rev_id);\r\n}\r\nstatic int read_vbt_r0(u32 addr, struct vbt_r0 *vbt)\r\n{\r\nvoid __iomem *vbt_virtual;\r\nvbt_virtual = ioremap(addr, sizeof(*vbt));\r\nif (vbt_virtual == NULL)\r\nreturn -1;\r\nmemcpy_fromio(vbt, vbt_virtual, sizeof(*vbt));\r\niounmap(vbt_virtual);\r\nreturn 0;\r\n}\r\nstatic int read_vbt_r10(u32 addr, struct vbt_r10 *vbt)\r\n{\r\nvoid __iomem *vbt_virtual;\r\nvbt_virtual = ioremap(addr, sizeof(*vbt));\r\nif (!vbt_virtual)\r\nreturn -1;\r\nmemcpy_fromio(vbt, vbt_virtual, sizeof(*vbt));\r\niounmap(vbt_virtual);\r\nreturn 0;\r\n}\r\nstatic int mid_get_vbt_data_r0(struct drm_psb_private *dev_priv, u32 addr)\r\n{\r\nstruct vbt_r0 vbt;\r\nvoid __iomem *gct_virtual;\r\nstruct gct_r0 gct;\r\nu8 bpi;\r\nif (read_vbt_r0(addr, &vbt))\r\nreturn -1;\r\ngct_virtual = ioremap(addr + sizeof(vbt), vbt.size - sizeof(vbt));\r\nif (!gct_virtual)\r\nreturn -1;\r\nmemcpy_fromio(&gct, gct_virtual, sizeof(gct));\r\niounmap(gct_virtual);\r\nbpi = gct.PD.BootPanelIndex;\r\ndev_priv->gct_data.bpi = bpi;\r\ndev_priv->gct_data.pt = gct.PD.PanelType;\r\ndev_priv->gct_data.DTD = gct.panel[bpi].DTD;\r\ndev_priv->gct_data.Panel_Port_Control =\r\ngct.panel[bpi].Panel_Port_Control;\r\ndev_priv->gct_data.Panel_MIPI_Display_Descriptor =\r\ngct.panel[bpi].Panel_MIPI_Display_Descriptor;\r\nreturn 0;\r\n}\r\nstatic int mid_get_vbt_data_r1(struct drm_psb_private *dev_priv, u32 addr)\r\n{\r\nstruct vbt_r0 vbt;\r\nvoid __iomem *gct_virtual;\r\nstruct gct_r1 gct;\r\nu8 bpi;\r\nif (read_vbt_r0(addr, &vbt))\r\nreturn -1;\r\ngct_virtual = ioremap(addr + sizeof(vbt), vbt.size - sizeof(vbt));\r\nif (!gct_virtual)\r\nreturn -1;\r\nmemcpy_fromio(&gct, gct_virtual, sizeof(gct));\r\niounmap(gct_virtual);\r\nbpi = gct.PD.BootPanelIndex;\r\ndev_priv->gct_data.bpi = bpi;\r\ndev_priv->gct_data.pt = gct.PD.PanelType;\r\ndev_priv->gct_data.DTD = gct.panel[bpi].DTD;\r\ndev_priv->gct_data.Panel_Port_Control =\r\ngct.panel[bpi].Panel_Port_Control;\r\ndev_priv->gct_data.Panel_MIPI_Display_Descriptor =\r\ngct.panel[bpi].Panel_MIPI_Display_Descriptor;\r\nreturn 0;\r\n}\r\nstatic int mid_get_vbt_data_r10(struct drm_psb_private *dev_priv, u32 addr)\r\n{\r\nstruct vbt_r10 vbt;\r\nvoid __iomem *gct_virtual;\r\nstruct gct_r10 *gct;\r\nstruct oaktrail_timing_info *dp_ti = &dev_priv->gct_data.DTD;\r\nstruct gct_r10_timing_info *ti;\r\nint ret = -1;\r\nif (read_vbt_r10(addr, &vbt))\r\nreturn -1;\r\ngct = kmalloc(sizeof(*gct) * vbt.panel_count, GFP_KERNEL);\r\nif (!gct)\r\nreturn -1;\r\ngct_virtual = ioremap(addr + sizeof(vbt),\r\nsizeof(*gct) * vbt.panel_count);\r\nif (!gct_virtual)\r\ngoto out;\r\nmemcpy_fromio(gct, gct_virtual, sizeof(*gct));\r\niounmap(gct_virtual);\r\ndev_priv->gct_data.bpi = vbt.primary_panel_idx;\r\ndev_priv->gct_data.Panel_MIPI_Display_Descriptor =\r\ngct[vbt.primary_panel_idx].Panel_MIPI_Display_Descriptor;\r\nti = &gct[vbt.primary_panel_idx].DTD;\r\ndp_ti->pixel_clock = ti->pixel_clock;\r\ndp_ti->hactive_hi = ti->hactive_hi;\r\ndp_ti->hactive_lo = ti->hactive_lo;\r\ndp_ti->hblank_hi = ti->hblank_hi;\r\ndp_ti->hblank_lo = ti->hblank_lo;\r\ndp_ti->hsync_offset_hi = ti->hsync_offset_hi;\r\ndp_ti->hsync_offset_lo = ti->hsync_offset_lo;\r\ndp_ti->hsync_pulse_width_hi = ti->hsync_pulse_width_hi;\r\ndp_ti->hsync_pulse_width_lo = ti->hsync_pulse_width_lo;\r\ndp_ti->vactive_hi = ti->vactive_hi;\r\ndp_ti->vactive_lo = ti->vactive_lo;\r\ndp_ti->vblank_hi = ti->vblank_hi;\r\ndp_ti->vblank_lo = ti->vblank_lo;\r\ndp_ti->vsync_offset_hi = ti->vsync_offset_hi;\r\ndp_ti->vsync_offset_lo = ti->vsync_offset_lo;\r\ndp_ti->vsync_pulse_width_hi = ti->vsync_pulse_width_hi;\r\ndp_ti->vsync_pulse_width_lo = ti->vsync_pulse_width_lo;\r\nret = 0;\r\nout:\r\nkfree(gct);\r\nreturn ret;\r\n}\r\nstatic void mid_get_vbt_data(struct drm_psb_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nu32 addr;\r\nu8 __iomem *vbt_virtual;\r\nstruct mid_vbt_header vbt_header;\r\nstruct pci_dev *pci_gfx_root = pci_get_bus_and_slot(0, PCI_DEVFN(2, 0));\r\nint ret = -1;\r\npci_read_config_dword(pci_gfx_root, 0xFC, &addr);\r\npci_dev_put(pci_gfx_root);\r\ndev_dbg(dev->dev, "drm platform config address is %x\n", addr);\r\nif (!addr)\r\ngoto out;\r\nvbt_virtual = ioremap(addr, sizeof(vbt_header));\r\nif (!vbt_virtual)\r\ngoto out;\r\nmemcpy_fromio(&vbt_header, vbt_virtual, sizeof(vbt_header));\r\niounmap(vbt_virtual);\r\nif (memcmp(&vbt_header.signature, "$GCT", 4))\r\ngoto out;\r\ndev_dbg(dev->dev, "GCT revision is %02x\n", vbt_header.revision);\r\nswitch (vbt_header.revision) {\r\ncase 0x00:\r\nret = mid_get_vbt_data_r0(dev_priv, addr);\r\nbreak;\r\ncase 0x01:\r\nret = mid_get_vbt_data_r1(dev_priv, addr);\r\nbreak;\r\ncase 0x10:\r\nret = mid_get_vbt_data_r10(dev_priv, addr);\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "Unknown revision of GCT!\n");\r\n}\r\nout:\r\nif (ret)\r\ndev_err(dev->dev, "Unable to read GCT!");\r\nelse\r\ndev_priv->has_gct = true;\r\n}\r\nint mid_chip_setup(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nmid_get_fuse_settings(dev);\r\nmid_get_vbt_data(dev_priv);\r\nmid_get_pci_revID(dev_priv);\r\nreturn 0;\r\n}
