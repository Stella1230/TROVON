static int\r\nnouveau_vram_manager_init(struct ttm_mem_type_manager *man, unsigned long psize)\r\n{\r\nstruct nouveau_drm *drm = nouveau_bdev(man->bdev);\r\nstruct nouveau_fb *pfb = nouveau_fb(drm->device);\r\nman->priv = pfb;\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_vram_manager_fini(struct ttm_mem_type_manager *man)\r\n{\r\nman->priv = NULL;\r\nreturn 0;\r\n}\r\nstatic inline void\r\nnouveau_mem_node_cleanup(struct nouveau_mem *node)\r\n{\r\nif (node->vma[0].node) {\r\nnouveau_vm_unmap(&node->vma[0]);\r\nnouveau_vm_put(&node->vma[0]);\r\n}\r\nif (node->vma[1].node) {\r\nnouveau_vm_unmap(&node->vma[1]);\r\nnouveau_vm_put(&node->vma[1]);\r\n}\r\n}\r\nstatic void\r\nnouveau_vram_manager_del(struct ttm_mem_type_manager *man,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nstruct nouveau_drm *drm = nouveau_bdev(man->bdev);\r\nstruct nouveau_fb *pfb = nouveau_fb(drm->device);\r\nnouveau_mem_node_cleanup(mem->mm_node);\r\npfb->ram->put(pfb, (struct nouveau_mem **)&mem->mm_node);\r\n}\r\nstatic int\r\nnouveau_vram_manager_new(struct ttm_mem_type_manager *man,\r\nstruct ttm_buffer_object *bo,\r\nstruct ttm_placement *placement,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nstruct nouveau_drm *drm = nouveau_bdev(man->bdev);\r\nstruct nouveau_fb *pfb = nouveau_fb(drm->device);\r\nstruct nouveau_bo *nvbo = nouveau_bo(bo);\r\nstruct nouveau_mem *node;\r\nu32 size_nc = 0;\r\nint ret;\r\nif (nvbo->tile_flags & NOUVEAU_GEM_TILE_NONCONTIG)\r\nsize_nc = 1 << nvbo->page_shift;\r\nret = pfb->ram->get(pfb, mem->num_pages << PAGE_SHIFT,\r\nmem->page_alignment << PAGE_SHIFT, size_nc,\r\n(nvbo->tile_flags >> 8) & 0x3ff, &node);\r\nif (ret) {\r\nmem->mm_node = NULL;\r\nreturn (ret == -ENOSPC) ? 0 : ret;\r\n}\r\nnode->page_shift = nvbo->page_shift;\r\nmem->mm_node = node;\r\nmem->start = node->offset >> PAGE_SHIFT;\r\nreturn 0;\r\n}\r\nstatic void\r\nnouveau_vram_manager_debug(struct ttm_mem_type_manager *man, const char *prefix)\r\n{\r\nstruct nouveau_fb *pfb = man->priv;\r\nstruct nouveau_mm *mm = &pfb->vram;\r\nstruct nouveau_mm_node *r;\r\nu32 total = 0, free = 0;\r\nmutex_lock(&nv_subdev(pfb)->mutex);\r\nlist_for_each_entry(r, &mm->nodes, nl_entry) {\r\nprintk(KERN_DEBUG "%s %d: 0x%010llx 0x%010llx\n",\r\nprefix, r->type, ((u64)r->offset << 12),\r\n(((u64)r->offset + r->length) << 12));\r\ntotal += r->length;\r\nif (!r->type)\r\nfree += r->length;\r\n}\r\nmutex_unlock(&nv_subdev(pfb)->mutex);\r\nprintk(KERN_DEBUG "%s total: 0x%010llx free: 0x%010llx\n",\r\nprefix, (u64)total << 12, (u64)free << 12);\r\nprintk(KERN_DEBUG "%s block: 0x%08x\n",\r\nprefix, mm->block_size << 12);\r\n}\r\nstatic int\r\nnouveau_gart_manager_init(struct ttm_mem_type_manager *man, unsigned long psize)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_gart_manager_fini(struct ttm_mem_type_manager *man)\r\n{\r\nreturn 0;\r\n}\r\nstatic void\r\nnouveau_gart_manager_del(struct ttm_mem_type_manager *man,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nnouveau_mem_node_cleanup(mem->mm_node);\r\nkfree(mem->mm_node);\r\nmem->mm_node = NULL;\r\n}\r\nstatic int\r\nnouveau_gart_manager_new(struct ttm_mem_type_manager *man,\r\nstruct ttm_buffer_object *bo,\r\nstruct ttm_placement *placement,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nstruct nouveau_drm *drm = nouveau_bdev(bo->bdev);\r\nstruct nouveau_bo *nvbo = nouveau_bo(bo);\r\nstruct nouveau_mem *node;\r\nnode = kzalloc(sizeof(*node), GFP_KERNEL);\r\nif (!node)\r\nreturn -ENOMEM;\r\nnode->page_shift = 12;\r\nswitch (nv_device(drm->device)->card_type) {\r\ncase NV_50:\r\nif (nv_device(drm->device)->chipset != 0x50)\r\nnode->memtype = (nvbo->tile_flags & 0x7f00) >> 8;\r\nbreak;\r\ncase NV_C0:\r\ncase NV_D0:\r\ncase NV_E0:\r\nnode->memtype = (nvbo->tile_flags & 0xff00) >> 8;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmem->mm_node = node;\r\nmem->start = 0;\r\nreturn 0;\r\n}\r\nstatic void\r\nnouveau_gart_manager_debug(struct ttm_mem_type_manager *man, const char *prefix)\r\n{\r\n}\r\nstatic int\r\nnv04_gart_manager_init(struct ttm_mem_type_manager *man, unsigned long psize)\r\n{\r\nstruct nouveau_drm *drm = nouveau_bdev(man->bdev);\r\nstruct nouveau_vmmgr *vmm = nouveau_vmmgr(drm->device);\r\nstruct nv04_vmmgr_priv *priv = (void *)vmm;\r\nstruct nouveau_vm *vm = NULL;\r\nnouveau_vm_ref(priv->vm, &vm, NULL);\r\nman->priv = vm;\r\nreturn 0;\r\n}\r\nstatic int\r\nnv04_gart_manager_fini(struct ttm_mem_type_manager *man)\r\n{\r\nstruct nouveau_vm *vm = man->priv;\r\nnouveau_vm_ref(NULL, &vm, NULL);\r\nman->priv = NULL;\r\nreturn 0;\r\n}\r\nstatic void\r\nnv04_gart_manager_del(struct ttm_mem_type_manager *man, struct ttm_mem_reg *mem)\r\n{\r\nstruct nouveau_mem *node = mem->mm_node;\r\nif (node->vma[0].node)\r\nnouveau_vm_put(&node->vma[0]);\r\nkfree(mem->mm_node);\r\nmem->mm_node = NULL;\r\n}\r\nstatic int\r\nnv04_gart_manager_new(struct ttm_mem_type_manager *man,\r\nstruct ttm_buffer_object *bo,\r\nstruct ttm_placement *placement,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nstruct nouveau_mem *node;\r\nint ret;\r\nnode = kzalloc(sizeof(*node), GFP_KERNEL);\r\nif (!node)\r\nreturn -ENOMEM;\r\nnode->page_shift = 12;\r\nret = nouveau_vm_get(man->priv, mem->num_pages << 12, node->page_shift,\r\nNV_MEM_ACCESS_RW, &node->vma[0]);\r\nif (ret) {\r\nkfree(node);\r\nreturn ret;\r\n}\r\nmem->mm_node = node;\r\nmem->start = node->vma[0].offset >> PAGE_SHIFT;\r\nreturn 0;\r\n}\r\nstatic void\r\nnv04_gart_manager_debug(struct ttm_mem_type_manager *man, const char *prefix)\r\n{\r\n}\r\nint\r\nnouveau_ttm_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nstruct nouveau_drm *drm = nouveau_drm(file_priv->minor->dev);\r\nif (unlikely(vma->vm_pgoff < DRM_FILE_PAGE_OFFSET))\r\nreturn drm_mmap(filp, vma);\r\nreturn ttm_bo_mmap(filp, vma, &drm->ttm.bdev);\r\n}\r\nstatic int\r\nnouveau_ttm_mem_global_init(struct drm_global_reference *ref)\r\n{\r\nreturn ttm_mem_global_init(ref->object);\r\n}\r\nstatic void\r\nnouveau_ttm_mem_global_release(struct drm_global_reference *ref)\r\n{\r\nttm_mem_global_release(ref->object);\r\n}\r\nint\r\nnouveau_ttm_global_init(struct nouveau_drm *drm)\r\n{\r\nstruct drm_global_reference *global_ref;\r\nint ret;\r\nglobal_ref = &drm->ttm.mem_global_ref;\r\nglobal_ref->global_type = DRM_GLOBAL_TTM_MEM;\r\nglobal_ref->size = sizeof(struct ttm_mem_global);\r\nglobal_ref->init = &nouveau_ttm_mem_global_init;\r\nglobal_ref->release = &nouveau_ttm_mem_global_release;\r\nret = drm_global_item_ref(global_ref);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed setting up TTM memory accounting\n");\r\ndrm->ttm.mem_global_ref.release = NULL;\r\nreturn ret;\r\n}\r\ndrm->ttm.bo_global_ref.mem_glob = global_ref->object;\r\nglobal_ref = &drm->ttm.bo_global_ref.ref;\r\nglobal_ref->global_type = DRM_GLOBAL_TTM_BO;\r\nglobal_ref->size = sizeof(struct ttm_bo_global);\r\nglobal_ref->init = &ttm_bo_global_init;\r\nglobal_ref->release = &ttm_bo_global_release;\r\nret = drm_global_item_ref(global_ref);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed setting up TTM BO subsystem\n");\r\ndrm_global_item_unref(&drm->ttm.mem_global_ref);\r\ndrm->ttm.mem_global_ref.release = NULL;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_ttm_global_release(struct nouveau_drm *drm)\r\n{\r\nif (drm->ttm.mem_global_ref.release == NULL)\r\nreturn;\r\ndrm_global_item_unref(&drm->ttm.bo_global_ref.ref);\r\ndrm_global_item_unref(&drm->ttm.mem_global_ref);\r\ndrm->ttm.mem_global_ref.release = NULL;\r\n}\r\nint\r\nnouveau_ttm_init(struct nouveau_drm *drm)\r\n{\r\nstruct drm_device *dev = drm->dev;\r\nu32 bits;\r\nint ret;\r\nbits = nouveau_vmmgr(drm->device)->dma_bits;\r\nif ( drm->agp.stat == ENABLED ||\r\n!pci_dma_supported(dev->pdev, DMA_BIT_MASK(bits)))\r\nbits = 32;\r\nret = pci_set_dma_mask(dev->pdev, DMA_BIT_MASK(bits));\r\nif (ret)\r\nreturn ret;\r\nret = pci_set_consistent_dma_mask(dev->pdev, DMA_BIT_MASK(bits));\r\nif (ret)\r\npci_set_consistent_dma_mask(dev->pdev, DMA_BIT_MASK(32));\r\nret = nouveau_ttm_global_init(drm);\r\nif (ret)\r\nreturn ret;\r\nret = ttm_bo_device_init(&drm->ttm.bdev,\r\ndrm->ttm.bo_global_ref.ref.object,\r\n&nouveau_bo_driver, DRM_FILE_PAGE_OFFSET,\r\nbits <= 32 ? true : false);\r\nif (ret) {\r\nNV_ERROR(drm, "error initialising bo driver, %d\n", ret);\r\nreturn ret;\r\n}\r\ndrm->gem.vram_available = nouveau_fb(drm->device)->ram->size;\r\ndrm->gem.vram_available -= nouveau_instmem(drm->device)->reserved;\r\nret = ttm_bo_init_mm(&drm->ttm.bdev, TTM_PL_VRAM,\r\ndrm->gem.vram_available >> PAGE_SHIFT);\r\nif (ret) {\r\nNV_ERROR(drm, "VRAM mm init failed, %d\n", ret);\r\nreturn ret;\r\n}\r\ndrm->ttm.mtrr = arch_phys_wc_add(pci_resource_start(dev->pdev, 1),\r\npci_resource_len(dev->pdev, 1));\r\nif (drm->agp.stat != ENABLED) {\r\ndrm->gem.gart_available = nouveau_vmmgr(drm->device)->limit;\r\n} else {\r\ndrm->gem.gart_available = drm->agp.size;\r\n}\r\nret = ttm_bo_init_mm(&drm->ttm.bdev, TTM_PL_TT,\r\ndrm->gem.gart_available >> PAGE_SHIFT);\r\nif (ret) {\r\nNV_ERROR(drm, "GART mm init failed, %d\n", ret);\r\nreturn ret;\r\n}\r\nNV_INFO(drm, "VRAM: %d MiB\n", (u32)(drm->gem.vram_available >> 20));\r\nNV_INFO(drm, "GART: %d MiB\n", (u32)(drm->gem.gart_available >> 20));\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_ttm_fini(struct nouveau_drm *drm)\r\n{\r\nmutex_lock(&drm->dev->struct_mutex);\r\nttm_bo_clean_mm(&drm->ttm.bdev, TTM_PL_VRAM);\r\nttm_bo_clean_mm(&drm->ttm.bdev, TTM_PL_TT);\r\nmutex_unlock(&drm->dev->struct_mutex);\r\nttm_bo_device_release(&drm->ttm.bdev);\r\nnouveau_ttm_global_release(drm);\r\narch_phys_wc_del(drm->ttm.mtrr);\r\ndrm->ttm.mtrr = 0;\r\n}
