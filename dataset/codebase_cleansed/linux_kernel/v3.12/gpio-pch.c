static void pch_gpio_set(struct gpio_chip *gpio, unsigned nr, int val)\r\n{\r\nu32 reg_val;\r\nstruct pch_gpio *chip = container_of(gpio, struct pch_gpio, gpio);\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\nreg_val = ioread32(&chip->reg->po);\r\nif (val)\r\nreg_val |= (1 << nr);\r\nelse\r\nreg_val &= ~(1 << nr);\r\niowrite32(reg_val, &chip->reg->po);\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\n}\r\nstatic int pch_gpio_get(struct gpio_chip *gpio, unsigned nr)\r\n{\r\nstruct pch_gpio *chip = container_of(gpio, struct pch_gpio, gpio);\r\nreturn ioread32(&chip->reg->pi) & (1 << nr);\r\n}\r\nstatic int pch_gpio_direction_output(struct gpio_chip *gpio, unsigned nr,\r\nint val)\r\n{\r\nstruct pch_gpio *chip = container_of(gpio, struct pch_gpio, gpio);\r\nu32 pm;\r\nu32 reg_val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\npm = ioread32(&chip->reg->pm) & ((1 << gpio_pins[chip->ioh]) - 1);\r\npm |= (1 << nr);\r\niowrite32(pm, &chip->reg->pm);\r\nreg_val = ioread32(&chip->reg->po);\r\nif (val)\r\nreg_val |= (1 << nr);\r\nelse\r\nreg_val &= ~(1 << nr);\r\niowrite32(reg_val, &chip->reg->po);\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int pch_gpio_direction_input(struct gpio_chip *gpio, unsigned nr)\r\n{\r\nstruct pch_gpio *chip = container_of(gpio, struct pch_gpio, gpio);\r\nu32 pm;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\npm = ioread32(&chip->reg->pm) & ((1 << gpio_pins[chip->ioh]) - 1);\r\npm &= ~(1 << nr);\r\niowrite32(pm, &chip->reg->pm);\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic void pch_gpio_save_reg_conf(struct pch_gpio *chip)\r\n{\r\nchip->pch_gpio_reg.ien_reg = ioread32(&chip->reg->ien);\r\nchip->pch_gpio_reg.imask_reg = ioread32(&chip->reg->imask);\r\nchip->pch_gpio_reg.po_reg = ioread32(&chip->reg->po);\r\nchip->pch_gpio_reg.pm_reg = ioread32(&chip->reg->pm);\r\nchip->pch_gpio_reg.im0_reg = ioread32(&chip->reg->im0);\r\nif (chip->ioh == INTEL_EG20T_PCH)\r\nchip->pch_gpio_reg.im1_reg = ioread32(&chip->reg->im1);\r\nif (chip->ioh == OKISEMI_ML7223n_IOH)\r\nchip->pch_gpio_reg.gpio_use_sel_reg =\\r\nioread32(&chip->reg->gpio_use_sel);\r\n}\r\nstatic void pch_gpio_restore_reg_conf(struct pch_gpio *chip)\r\n{\r\niowrite32(chip->pch_gpio_reg.ien_reg, &chip->reg->ien);\r\niowrite32(chip->pch_gpio_reg.imask_reg, &chip->reg->imask);\r\niowrite32(chip->pch_gpio_reg.po_reg, &chip->reg->po);\r\niowrite32(chip->pch_gpio_reg.pm_reg, &chip->reg->pm);\r\niowrite32(chip->pch_gpio_reg.im0_reg, &chip->reg->im0);\r\nif (chip->ioh == INTEL_EG20T_PCH)\r\niowrite32(chip->pch_gpio_reg.im1_reg, &chip->reg->im1);\r\nif (chip->ioh == OKISEMI_ML7223n_IOH)\r\niowrite32(chip->pch_gpio_reg.gpio_use_sel_reg,\r\n&chip->reg->gpio_use_sel);\r\n}\r\nstatic int pch_gpio_to_irq(struct gpio_chip *gpio, unsigned offset)\r\n{\r\nstruct pch_gpio *chip = container_of(gpio, struct pch_gpio, gpio);\r\nreturn chip->irq_base + offset;\r\n}\r\nstatic void pch_gpio_setup(struct pch_gpio *chip)\r\n{\r\nstruct gpio_chip *gpio = &chip->gpio;\r\ngpio->label = dev_name(chip->dev);\r\ngpio->dev = chip->dev;\r\ngpio->owner = THIS_MODULE;\r\ngpio->direction_input = pch_gpio_direction_input;\r\ngpio->get = pch_gpio_get;\r\ngpio->direction_output = pch_gpio_direction_output;\r\ngpio->set = pch_gpio_set;\r\ngpio->dbg_show = NULL;\r\ngpio->base = -1;\r\ngpio->ngpio = gpio_pins[chip->ioh];\r\ngpio->can_sleep = 0;\r\ngpio->to_irq = pch_gpio_to_irq;\r\n}\r\nstatic int pch_irq_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct pch_gpio *chip = gc->private;\r\nu32 im, im_pos, val;\r\nu32 __iomem *im_reg;\r\nunsigned long flags;\r\nint ch, irq = d->irq;\r\nch = irq - chip->irq_base;\r\nif (irq <= chip->irq_base + 7) {\r\nim_reg = &chip->reg->im0;\r\nim_pos = ch;\r\n} else {\r\nim_reg = &chip->reg->im1;\r\nim_pos = ch - 8;\r\n}\r\ndev_dbg(chip->dev, "%s:irq=%d type=%d ch=%d pos=%d\n",\r\n__func__, irq, type, ch, im_pos);\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nval = PCH_EDGE_RISING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nval = PCH_EDGE_FALLING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nval = PCH_EDGE_BOTH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nval = PCH_LEVEL_H;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nval = PCH_LEVEL_L;\r\nbreak;\r\ndefault:\r\ngoto unlock;\r\n}\r\nim = ioread32(im_reg) & ~(PCH_IM_MASK << (im_pos * 4));\r\niowrite32(im | (val << (im_pos * 4)), im_reg);\r\nif (type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH))\r\n__irq_set_handler_locked(d->irq, handle_level_irq);\r\nelse if (type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\r\n__irq_set_handler_locked(d->irq, handle_edge_irq);\r\nunlock:\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic void pch_irq_unmask(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct pch_gpio *chip = gc->private;\r\niowrite32(1 << (d->irq - chip->irq_base), &chip->reg->imaskclr);\r\n}\r\nstatic void pch_irq_mask(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct pch_gpio *chip = gc->private;\r\niowrite32(1 << (d->irq - chip->irq_base), &chip->reg->imask);\r\n}\r\nstatic void pch_irq_ack(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct pch_gpio *chip = gc->private;\r\niowrite32(1 << (d->irq - chip->irq_base), &chip->reg->iclr);\r\n}\r\nstatic irqreturn_t pch_gpio_handler(int irq, void *dev_id)\r\n{\r\nstruct pch_gpio *chip = dev_id;\r\nu32 reg_val = ioread32(&chip->reg->istatus);\r\nint i, ret = IRQ_NONE;\r\nfor (i = 0; i < gpio_pins[chip->ioh]; i++) {\r\nif (reg_val & BIT(i)) {\r\ndev_dbg(chip->dev, "%s:[%d]:irq=%d status=0x%x\n",\r\n__func__, i, irq, reg_val);\r\ngeneric_handle_irq(chip->irq_base + i);\r\nret = IRQ_HANDLED;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void pch_gpio_alloc_generic_chip(struct pch_gpio *chip,\r\nunsigned int irq_start, unsigned int num)\r\n{\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\ngc = irq_alloc_generic_chip("pch_gpio", 1, irq_start, chip->base,\r\nhandle_simple_irq);\r\ngc->private = chip;\r\nct = gc->chip_types;\r\nct->chip.irq_ack = pch_irq_ack;\r\nct->chip.irq_mask = pch_irq_mask;\r\nct->chip.irq_unmask = pch_irq_unmask;\r\nct->chip.irq_set_type = pch_irq_type;\r\nirq_setup_generic_chip(gc, IRQ_MSK(num), IRQ_GC_INIT_MASK_CACHE,\r\nIRQ_NOREQUEST | IRQ_NOPROBE, 0);\r\n}\r\nstatic int pch_gpio_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\ns32 ret;\r\nstruct pch_gpio *chip;\r\nint irq_base;\r\nu32 msk;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\nchip->dev = &pdev->dev;\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s : pci_enable_device FAILED", __func__);\r\ngoto err_pci_enable;\r\n}\r\nret = pci_request_regions(pdev, KBUILD_MODNAME);\r\nif (ret) {\r\ndev_err(&pdev->dev, "pci_request_regions FAILED-%d", ret);\r\ngoto err_request_regions;\r\n}\r\nchip->base = pci_iomap(pdev, 1, 0);\r\nif (!chip->base) {\r\ndev_err(&pdev->dev, "%s : pci_iomap FAILED", __func__);\r\nret = -ENOMEM;\r\ngoto err_iomap;\r\n}\r\nif (pdev->device == 0x8803)\r\nchip->ioh = INTEL_EG20T_PCH;\r\nelse if (pdev->device == 0x8014)\r\nchip->ioh = OKISEMI_ML7223m_IOH;\r\nelse if (pdev->device == 0x8043)\r\nchip->ioh = OKISEMI_ML7223n_IOH;\r\nchip->reg = chip->base;\r\npci_set_drvdata(pdev, chip);\r\nspin_lock_init(&chip->spinlock);\r\npch_gpio_setup(chip);\r\nret = gpiochip_add(&chip->gpio);\r\nif (ret) {\r\ndev_err(&pdev->dev, "PCH gpio: Failed to register GPIO\n");\r\ngoto err_gpiochip_add;\r\n}\r\nirq_base = irq_alloc_descs(-1, 0, gpio_pins[chip->ioh], NUMA_NO_NODE);\r\nif (irq_base < 0) {\r\ndev_warn(&pdev->dev, "PCH gpio: Failed to get IRQ base num\n");\r\nchip->irq_base = -1;\r\ngoto end;\r\n}\r\nchip->irq_base = irq_base;\r\nmsk = (1 << gpio_pins[chip->ioh]) - 1;\r\niowrite32(msk, &chip->reg->imask);\r\niowrite32(msk, &chip->reg->ien);\r\nret = request_irq(pdev->irq, pch_gpio_handler,\r\nIRQF_SHARED, KBUILD_MODNAME, chip);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev,\r\n"%s request_irq failed\n", __func__);\r\ngoto err_request_irq;\r\n}\r\npch_gpio_alloc_generic_chip(chip, irq_base, gpio_pins[chip->ioh]);\r\nend:\r\nreturn 0;\r\nerr_request_irq:\r\nirq_free_descs(irq_base, gpio_pins[chip->ioh]);\r\nif (gpiochip_remove(&chip->gpio))\r\ndev_err(&pdev->dev, "%s gpiochip_remove failed\n", __func__);\r\nerr_gpiochip_add:\r\npci_iounmap(pdev, chip->base);\r\nerr_iomap:\r\npci_release_regions(pdev);\r\nerr_request_regions:\r\npci_disable_device(pdev);\r\nerr_pci_enable:\r\nkfree(chip);\r\ndev_err(&pdev->dev, "%s Failed returns %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic void pch_gpio_remove(struct pci_dev *pdev)\r\n{\r\nint err;\r\nstruct pch_gpio *chip = pci_get_drvdata(pdev);\r\nif (chip->irq_base != -1) {\r\nfree_irq(pdev->irq, chip);\r\nirq_free_descs(chip->irq_base, gpio_pins[chip->ioh]);\r\n}\r\nerr = gpiochip_remove(&chip->gpio);\r\nif (err)\r\ndev_err(&pdev->dev, "Failed gpiochip_remove\n");\r\npci_iounmap(pdev, chip->base);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nkfree(chip);\r\n}\r\nstatic int pch_gpio_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\ns32 ret;\r\nstruct pch_gpio *chip = pci_get_drvdata(pdev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\npch_gpio_save_reg_conf(chip);\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\nret = pci_save_state(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "pci_save_state Failed-%d\n", ret);\r\nreturn ret;\r\n}\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, PCI_D0);\r\nret = pci_enable_wake(pdev, PCI_D0, 1);\r\nif (ret)\r\ndev_err(&pdev->dev, "pci_enable_wake Failed -%d\n", ret);\r\nreturn 0;\r\n}\r\nstatic int pch_gpio_resume(struct pci_dev *pdev)\r\n{\r\ns32 ret;\r\nstruct pch_gpio *chip = pci_get_drvdata(pdev);\r\nunsigned long flags;\r\nret = pci_enable_wake(pdev, PCI_D0, 0);\r\npci_set_power_state(pdev, PCI_D0);\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "pci_enable_device Failed-%d ", ret);\r\nreturn ret;\r\n}\r\npci_restore_state(pdev);\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\niowrite32(0x01, &chip->reg->reset);\r\niowrite32(0x00, &chip->reg->reset);\r\npch_gpio_restore_reg_conf(chip);\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\nreturn 0;\r\n}
