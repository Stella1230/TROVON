static int pata_imx_set_mode(struct ata_link *link, struct ata_device **unused)\r\n{\r\nstruct ata_device *dev;\r\nstruct ata_port *ap = link->ap;\r\nstruct pata_imx_priv *priv = ap->host->private_data;\r\nu32 val;\r\nata_for_each_dev(dev, link, ENABLED) {\r\ndev->pio_mode = dev->xfer_mode = XFER_PIO_0;\r\ndev->xfer_shift = ATA_SHIFT_PIO;\r\ndev->flags |= ATA_DFLAG_PIO;\r\nval = __raw_readl(priv->host_regs + PATA_IMX_ATA_CONTROL);\r\nif (ata_pio_need_iordy(dev))\r\nval |= PATA_IMX_ATA_CTRL_IORDY_EN;\r\nelse\r\nval &= ~PATA_IMX_ATA_CTRL_IORDY_EN;\r\n__raw_writel(val, priv->host_regs + PATA_IMX_ATA_CONTROL);\r\nata_dev_info(dev, "configured for PIO\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void pata_imx_setup_port(struct ata_ioports *ioaddr)\r\n{\r\nioaddr->data_addr = ioaddr->cmd_addr + (ATA_REG_DATA << 2);\r\nioaddr->error_addr = ioaddr->cmd_addr + (ATA_REG_ERR << 2);\r\nioaddr->feature_addr = ioaddr->cmd_addr + (ATA_REG_FEATURE << 2);\r\nioaddr->nsect_addr = ioaddr->cmd_addr + (ATA_REG_NSECT << 2);\r\nioaddr->lbal_addr = ioaddr->cmd_addr + (ATA_REG_LBAL << 2);\r\nioaddr->lbam_addr = ioaddr->cmd_addr + (ATA_REG_LBAM << 2);\r\nioaddr->lbah_addr = ioaddr->cmd_addr + (ATA_REG_LBAH << 2);\r\nioaddr->device_addr = ioaddr->cmd_addr + (ATA_REG_DEVICE << 2);\r\nioaddr->status_addr = ioaddr->cmd_addr + (ATA_REG_STATUS << 2);\r\nioaddr->command_addr = ioaddr->cmd_addr + (ATA_REG_CMD << 2);\r\n}\r\nstatic int pata_imx_probe(struct platform_device *pdev)\r\n{\r\nstruct ata_host *host;\r\nstruct ata_port *ap;\r\nstruct pata_imx_priv *priv;\r\nint irq = 0;\r\nstruct resource *io_res;\r\nint ret;\r\nio_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (io_res == NULL)\r\nreturn -EINVAL;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0)\r\nreturn -EINVAL;\r\npriv = devm_kzalloc(&pdev->dev,\r\nsizeof(struct pata_imx_priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(priv->clk)) {\r\ndev_err(&pdev->dev, "Failed to get clock\n");\r\nreturn PTR_ERR(priv->clk);\r\n}\r\nclk_prepare_enable(priv->clk);\r\nhost = ata_host_alloc(&pdev->dev, 1);\r\nif (!host) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nhost->private_data = priv;\r\nap = host->ports[0];\r\nap->ops = &pata_imx_port_ops;\r\nap->pio_mask = ATA_PIO0;\r\nap->flags |= ATA_FLAG_SLAVE_POSS;\r\npriv->host_regs = devm_ioremap(&pdev->dev, io_res->start,\r\nresource_size(io_res));\r\nif (!priv->host_regs) {\r\ndev_err(&pdev->dev, "failed to map IO/CTL base\n");\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nap->ioaddr.cmd_addr = priv->host_regs + PATA_IMX_DRIVE_DATA;\r\nap->ioaddr.ctl_addr = priv->host_regs + PATA_IMX_DRIVE_CONTROL;\r\nap->ioaddr.altstatus_addr = ap->ioaddr.ctl_addr;\r\npata_imx_setup_port(&ap->ioaddr);\r\nata_port_desc(ap, "cmd 0x%llx ctl 0x%llx",\r\n(unsigned long long)io_res->start + PATA_IMX_DRIVE_DATA,\r\n(unsigned long long)io_res->start + PATA_IMX_DRIVE_CONTROL);\r\n__raw_writel(PATA_IMX_ATA_CTRL_FIFO_RST_B |\r\nPATA_IMX_ATA_CTRL_ATA_RST_B,\r\npriv->host_regs + PATA_IMX_ATA_CONTROL);\r\n__raw_writel(PATA_IMX_ATA_INTR_ATA_INTRQ2,\r\npriv->host_regs + PATA_IMX_ATA_INT_EN);\r\nret = ata_host_activate(host, irq, ata_sff_interrupt, 0,\r\n&pata_imx_sht);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nclk_disable_unprepare(priv->clk);\r\nreturn ret;\r\n}\r\nstatic int pata_imx_remove(struct platform_device *pdev)\r\n{\r\nstruct ata_host *host = platform_get_drvdata(pdev);\r\nstruct pata_imx_priv *priv = host->private_data;\r\nata_host_detach(host);\r\n__raw_writel(0, priv->host_regs + PATA_IMX_ATA_INT_EN);\r\nclk_disable_unprepare(priv->clk);\r\nreturn 0;\r\n}\r\nstatic int pata_imx_suspend(struct device *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct pata_imx_priv *priv = host->private_data;\r\nint ret;\r\nret = ata_host_suspend(host, PMSG_SUSPEND);\r\nif (!ret) {\r\n__raw_writel(0, priv->host_regs + PATA_IMX_ATA_INT_EN);\r\npriv->ata_ctl =\r\n__raw_readl(priv->host_regs + PATA_IMX_ATA_CONTROL);\r\nclk_disable_unprepare(priv->clk);\r\n}\r\nreturn ret;\r\n}\r\nstatic int pata_imx_resume(struct device *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct pata_imx_priv *priv = host->private_data;\r\nclk_prepare_enable(priv->clk);\r\n__raw_writel(priv->ata_ctl, priv->host_regs + PATA_IMX_ATA_CONTROL);\r\n__raw_writel(PATA_IMX_ATA_INTR_ATA_INTRQ2,\r\npriv->host_regs + PATA_IMX_ATA_INT_EN);\r\nata_host_resume(host);\r\nreturn 0;\r\n}
