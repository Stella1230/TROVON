static void isight_update_pointers(struct isight *isight, unsigned int count)\r\n{\r\nstruct snd_pcm_runtime *runtime = isight->pcm->runtime;\r\nunsigned int ptr;\r\nsmp_wmb();\r\nptr = isight->buffer_pointer;\r\nptr += count;\r\nif (ptr >= runtime->buffer_size)\r\nptr -= runtime->buffer_size;\r\nACCESS_ONCE(isight->buffer_pointer) = ptr;\r\nisight->period_counter += count;\r\nif (isight->period_counter >= runtime->period_size) {\r\nisight->period_counter -= runtime->period_size;\r\nsnd_pcm_period_elapsed(isight->pcm);\r\n}\r\n}\r\nstatic void isight_samples(struct isight *isight,\r\nconst __be16 *samples, unsigned int count)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nunsigned int count1;\r\nif (!ACCESS_ONCE(isight->pcm_running))\r\nreturn;\r\nruntime = isight->pcm->runtime;\r\nif (isight->buffer_pointer + count <= runtime->buffer_size) {\r\nmemcpy(runtime->dma_area + isight->buffer_pointer * 4,\r\nsamples, count * 4);\r\n} else {\r\ncount1 = runtime->buffer_size - isight->buffer_pointer;\r\nmemcpy(runtime->dma_area + isight->buffer_pointer * 4,\r\nsamples, count1 * 4);\r\nsamples += count1 * 2;\r\nmemcpy(runtime->dma_area, samples, (count - count1) * 4);\r\n}\r\nisight_update_pointers(isight, count);\r\n}\r\nstatic void isight_pcm_abort(struct isight *isight)\r\n{\r\nunsigned long flags;\r\nif (ACCESS_ONCE(isight->pcm_active)) {\r\nsnd_pcm_stream_lock_irqsave(isight->pcm, flags);\r\nif (snd_pcm_running(isight->pcm))\r\nsnd_pcm_stop(isight->pcm, SNDRV_PCM_STATE_XRUN);\r\nsnd_pcm_stream_unlock_irqrestore(isight->pcm, flags);\r\n}\r\n}\r\nstatic void isight_dropped_samples(struct isight *isight, unsigned int total)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nu32 dropped;\r\nunsigned int count1;\r\nif (!ACCESS_ONCE(isight->pcm_running))\r\nreturn;\r\nruntime = isight->pcm->runtime;\r\ndropped = total - isight->total_samples;\r\nif (dropped < runtime->buffer_size) {\r\nif (isight->buffer_pointer + dropped <= runtime->buffer_size) {\r\nmemset(runtime->dma_area + isight->buffer_pointer * 4,\r\n0, dropped * 4);\r\n} else {\r\ncount1 = runtime->buffer_size - isight->buffer_pointer;\r\nmemset(runtime->dma_area + isight->buffer_pointer * 4,\r\n0, count1 * 4);\r\nmemset(runtime->dma_area, 0, (dropped - count1) * 4);\r\n}\r\nisight_update_pointers(isight, dropped);\r\n} else {\r\nisight_pcm_abort(isight);\r\n}\r\n}\r\nstatic void isight_packet(struct fw_iso_context *context, u32 cycle,\r\nsize_t header_length, void *header, void *data)\r\n{\r\nstruct isight *isight = data;\r\nconst struct audio_payload *payload;\r\nunsigned int index, length, count, total;\r\nint err;\r\nif (isight->packet_index < 0)\r\nreturn;\r\nindex = isight->packet_index;\r\npayload = isight->buffer.packets[index].buffer;\r\nlength = be32_to_cpup(header) >> 16;\r\nif (likely(length >= 16 &&\r\npayload->signature == cpu_to_be32(0x73676874))) {\r\ncount = be32_to_cpu(payload->sample_count);\r\nif (likely(count <= (length - 16) / 4)) {\r\ntotal = be32_to_cpu(payload->sample_total);\r\nif (unlikely(total != isight->total_samples)) {\r\nif (!isight->first_packet)\r\nisight_dropped_samples(isight, total);\r\nisight->first_packet = false;\r\nisight->total_samples = total;\r\n}\r\nisight_samples(isight, payload->samples, count);\r\nisight->total_samples += count;\r\n}\r\n}\r\nerr = fw_iso_context_queue(isight->context, &audio_packet,\r\n&isight->buffer.iso_buffer,\r\nisight->buffer.packets[index].offset);\r\nif (err < 0) {\r\ndev_err(&isight->unit->device, "queueing error: %d\n", err);\r\nisight_pcm_abort(isight);\r\nisight->packet_index = -1;\r\nreturn;\r\n}\r\nfw_iso_context_queue_flush(isight->context);\r\nif (++index >= QUEUE_LENGTH)\r\nindex = 0;\r\nisight->packet_index = index;\r\n}\r\nstatic int isight_connect(struct isight *isight)\r\n{\r\nint ch, err, rcode, errors = 0;\r\n__be32 value;\r\nretry_after_bus_reset:\r\nch = fw_iso_resources_allocate(&isight->resources,\r\nsizeof(struct audio_payload),\r\nisight->device->max_speed);\r\nif (ch < 0) {\r\nerr = ch;\r\ngoto error;\r\n}\r\nvalue = cpu_to_be32(ch | (isight->device->max_speed << SPEED_SHIFT));\r\nfor (;;) {\r\nrcode = fw_run_transaction(\r\nisight->device->card,\r\nTCODE_WRITE_QUADLET_REQUEST,\r\nisight->device->node_id,\r\nisight->resources.generation,\r\nisight->device->max_speed,\r\nisight->audio_base + REG_ISO_TX_CONFIG,\r\n&value, 4);\r\nif (rcode == RCODE_COMPLETE) {\r\nreturn 0;\r\n} else if (rcode == RCODE_GENERATION) {\r\nfw_iso_resources_free(&isight->resources);\r\ngoto retry_after_bus_reset;\r\n} else if (rcode_is_permanent_error(rcode) || ++errors >= 3) {\r\nerr = -EIO;\r\ngoto err_resources;\r\n}\r\nmsleep(5);\r\n}\r\nerr_resources:\r\nfw_iso_resources_free(&isight->resources);\r\nerror:\r\nreturn err;\r\n}\r\nstatic int isight_open(struct snd_pcm_substream *substream)\r\n{\r\nstatic const struct snd_pcm_hardware hardware = {\r\n.info = SNDRV_PCM_INFO_MMAP |\r\nSNDRV_PCM_INFO_MMAP_VALID |\r\nSNDRV_PCM_INFO_BATCH |\r\nSNDRV_PCM_INFO_INTERLEAVED |\r\nSNDRV_PCM_INFO_BLOCK_TRANSFER,\r\n.formats = SNDRV_PCM_FMTBIT_S16_BE,\r\n.rates = SNDRV_PCM_RATE_48000,\r\n.rate_min = 48000,\r\n.rate_max = 48000,\r\n.channels_min = 2,\r\n.channels_max = 2,\r\n.buffer_bytes_max = 4 * 1024 * 1024,\r\n.period_bytes_min = MAX_FRAMES_PER_PACKET * 4,\r\n.period_bytes_max = 1024 * 1024,\r\n.periods_min = 2,\r\n.periods_max = UINT_MAX,\r\n};\r\nstruct isight *isight = substream->private_data;\r\nsubstream->runtime->hw = hardware;\r\nreturn iso_packets_buffer_init(&isight->buffer, isight->unit,\r\nQUEUE_LENGTH,\r\nsizeof(struct audio_payload),\r\nDMA_FROM_DEVICE);\r\n}\r\nstatic int isight_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct isight *isight = substream->private_data;\r\niso_packets_buffer_destroy(&isight->buffer, isight->unit);\r\nreturn 0;\r\n}\r\nstatic int isight_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct isight *isight = substream->private_data;\r\nint err;\r\nerr = snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nACCESS_ONCE(isight->pcm_active) = true;\r\nreturn 0;\r\n}\r\nstatic int reg_read(struct isight *isight, int offset, __be32 *value)\r\n{\r\nreturn snd_fw_transaction(isight->unit, TCODE_READ_QUADLET_REQUEST,\r\nisight->audio_base + offset, value, 4);\r\n}\r\nstatic int reg_write(struct isight *isight, int offset, __be32 value)\r\n{\r\nreturn snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nisight->audio_base + offset, &value, 4);\r\n}\r\nstatic void isight_stop_streaming(struct isight *isight)\r\n{\r\nif (!isight->context)\r\nreturn;\r\nfw_iso_context_stop(isight->context);\r\nfw_iso_context_destroy(isight->context);\r\nisight->context = NULL;\r\nfw_iso_resources_free(&isight->resources);\r\nreg_write(isight, REG_AUDIO_ENABLE, 0);\r\n}\r\nstatic int isight_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct isight *isight = substream->private_data;\r\nACCESS_ONCE(isight->pcm_active) = false;\r\nmutex_lock(&isight->mutex);\r\nisight_stop_streaming(isight);\r\nmutex_unlock(&isight->mutex);\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int isight_start_streaming(struct isight *isight)\r\n{\r\nunsigned int i;\r\nint err;\r\nif (isight->context) {\r\nif (isight->packet_index < 0)\r\nisight_stop_streaming(isight);\r\nelse\r\nreturn 0;\r\n}\r\nerr = reg_write(isight, REG_SAMPLE_RATE, cpu_to_be32(RATE_48000));\r\nif (err < 0)\r\ngoto error;\r\nerr = isight_connect(isight);\r\nif (err < 0)\r\ngoto error;\r\nerr = reg_write(isight, REG_AUDIO_ENABLE, cpu_to_be32(AUDIO_ENABLE));\r\nif (err < 0)\r\ngoto err_resources;\r\nisight->context = fw_iso_context_create(isight->device->card,\r\nFW_ISO_CONTEXT_RECEIVE,\r\nisight->resources.channel,\r\nisight->device->max_speed,\r\n4, isight_packet, isight);\r\nif (IS_ERR(isight->context)) {\r\nerr = PTR_ERR(isight->context);\r\nisight->context = NULL;\r\ngoto err_resources;\r\n}\r\nfor (i = 0; i < QUEUE_LENGTH; ++i) {\r\nerr = fw_iso_context_queue(isight->context, &audio_packet,\r\n&isight->buffer.iso_buffer,\r\nisight->buffer.packets[i].offset);\r\nif (err < 0)\r\ngoto err_context;\r\n}\r\nisight->first_packet = true;\r\nisight->packet_index = 0;\r\nerr = fw_iso_context_start(isight->context, -1, 0,\r\nFW_ISO_CONTEXT_MATCH_ALL_TAGS);\r\nif (err < 0)\r\ngoto err_context;\r\nreturn 0;\r\nerr_context:\r\nfw_iso_context_destroy(isight->context);\r\nisight->context = NULL;\r\nerr_resources:\r\nfw_iso_resources_free(&isight->resources);\r\nreg_write(isight, REG_AUDIO_ENABLE, 0);\r\nerror:\r\nreturn err;\r\n}\r\nstatic int isight_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct isight *isight = substream->private_data;\r\nint err;\r\nisight->buffer_pointer = 0;\r\nisight->period_counter = 0;\r\nmutex_lock(&isight->mutex);\r\nerr = isight_start_streaming(isight);\r\nmutex_unlock(&isight->mutex);\r\nreturn err;\r\n}\r\nstatic int isight_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct isight *isight = substream->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nACCESS_ONCE(isight->pcm_running) = true;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nACCESS_ONCE(isight->pcm_running) = false;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t isight_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct isight *isight = substream->private_data;\r\nreturn ACCESS_ONCE(isight->buffer_pointer);\r\n}\r\nstatic int isight_create_pcm(struct isight *isight)\r\n{\r\nstatic struct snd_pcm_ops ops = {\r\n.open = isight_open,\r\n.close = isight_close,\r\n.ioctl = snd_pcm_lib_ioctl,\r\n.hw_params = isight_hw_params,\r\n.hw_free = isight_hw_free,\r\n.prepare = isight_prepare,\r\n.trigger = isight_trigger,\r\n.pointer = isight_pointer,\r\n.page = snd_pcm_lib_get_vmalloc_page,\r\n.mmap = snd_pcm_lib_mmap_vmalloc,\r\n};\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(isight->card, "iSight", 0, 0, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->private_data = isight;\r\nstrcpy(pcm->name, "iSight");\r\nisight->pcm = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;\r\nisight->pcm->ops = &ops;\r\nreturn 0;\r\n}\r\nstatic int isight_gain_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstruct isight *isight = ctl->private_data;\r\ninfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\ninfo->count = 1;\r\ninfo->value.integer.min = isight->gain_min;\r\ninfo->value.integer.max = isight->gain_max;\r\nreturn 0;\r\n}\r\nstatic int isight_gain_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct isight *isight = ctl->private_data;\r\n__be32 gain;\r\nint err;\r\nerr = reg_read(isight, REG_GAIN, &gain);\r\nif (err < 0)\r\nreturn err;\r\nvalue->value.integer.value[0] = (s32)be32_to_cpu(gain);\r\nreturn 0;\r\n}\r\nstatic int isight_gain_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct isight *isight = ctl->private_data;\r\nif (value->value.integer.value[0] < isight->gain_min ||\r\nvalue->value.integer.value[0] > isight->gain_max)\r\nreturn -EINVAL;\r\nreturn reg_write(isight, REG_GAIN,\r\ncpu_to_be32(value->value.integer.value[0]));\r\n}\r\nstatic int isight_mute_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct isight *isight = ctl->private_data;\r\n__be32 mute;\r\nint err;\r\nerr = reg_read(isight, REG_MUTE, &mute);\r\nif (err < 0)\r\nreturn err;\r\nvalue->value.integer.value[0] = !mute;\r\nreturn 0;\r\n}\r\nstatic int isight_mute_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct isight *isight = ctl->private_data;\r\nreturn reg_write(isight, REG_MUTE,\r\n(__force __be32)!value->value.integer.value[0]);\r\n}\r\nstatic int isight_create_mixer(struct isight *isight)\r\n{\r\nstatic const struct snd_kcontrol_new gain_control = {\r\n.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\r\n.name = "Mic Capture Volume",\r\n.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\r\nSNDRV_CTL_ELEM_ACCESS_TLV_READ,\r\n.info = isight_gain_info,\r\n.get = isight_gain_get,\r\n.put = isight_gain_put,\r\n};\r\nstatic const struct snd_kcontrol_new mute_control = {\r\n.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\r\n.name = "Mic Capture Switch",\r\n.info = snd_ctl_boolean_mono_info,\r\n.get = isight_mute_get,\r\n.put = isight_mute_put,\r\n};\r\n__be32 value;\r\nstruct snd_kcontrol *ctl;\r\nint err;\r\nerr = reg_read(isight, REG_GAIN_RAW_START, &value);\r\nif (err < 0)\r\nreturn err;\r\nisight->gain_min = be32_to_cpu(value);\r\nerr = reg_read(isight, REG_GAIN_RAW_END, &value);\r\nif (err < 0)\r\nreturn err;\r\nisight->gain_max = be32_to_cpu(value);\r\nisight->gain_tlv[0] = SNDRV_CTL_TLVT_DB_MINMAX;\r\nisight->gain_tlv[1] = 2 * sizeof(unsigned int);\r\nerr = reg_read(isight, REG_GAIN_DB_START, &value);\r\nif (err < 0)\r\nreturn err;\r\nisight->gain_tlv[2] = (s32)be32_to_cpu(value) * 100;\r\nerr = reg_read(isight, REG_GAIN_DB_END, &value);\r\nif (err < 0)\r\nreturn err;\r\nisight->gain_tlv[3] = (s32)be32_to_cpu(value) * 100;\r\nctl = snd_ctl_new1(&gain_control, isight);\r\nif (ctl)\r\nctl->tlv.p = isight->gain_tlv;\r\nerr = snd_ctl_add(isight->card, ctl);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(isight->card, snd_ctl_new1(&mute_control, isight));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void isight_card_free(struct snd_card *card)\r\n{\r\nstruct isight *isight = card->private_data;\r\nfw_iso_resources_destroy(&isight->resources);\r\nfw_unit_put(isight->unit);\r\nmutex_destroy(&isight->mutex);\r\n}\r\nstatic u64 get_unit_base(struct fw_unit *unit)\r\n{\r\nstruct fw_csr_iterator i;\r\nint key, value;\r\nfw_csr_iterator_init(&i, unit->directory);\r\nwhile (fw_csr_iterator_next(&i, &key, &value))\r\nif (key == CSR_OFFSET)\r\nreturn CSR_REGISTER_BASE + value * 4;\r\nreturn 0;\r\n}\r\nstatic int isight_probe(struct fw_unit *unit,\r\nconst struct ieee1394_device_id *id)\r\n{\r\nstruct fw_device *fw_dev = fw_parent_device(unit);\r\nstruct snd_card *card;\r\nstruct isight *isight;\r\nint err;\r\nerr = snd_card_create(-1, NULL, THIS_MODULE, sizeof(*isight), &card);\r\nif (err < 0)\r\nreturn err;\r\nsnd_card_set_dev(card, &unit->device);\r\nisight = card->private_data;\r\nisight->card = card;\r\nmutex_init(&isight->mutex);\r\nisight->unit = fw_unit_get(unit);\r\nisight->device = fw_dev;\r\nisight->audio_base = get_unit_base(unit);\r\nif (!isight->audio_base) {\r\ndev_err(&unit->device, "audio unit base not found\n");\r\nerr = -ENXIO;\r\ngoto err_unit;\r\n}\r\nfw_iso_resources_init(&isight->resources, unit);\r\ncard->private_free = isight_card_free;\r\nstrcpy(card->driver, "iSight");\r\nstrcpy(card->shortname, "Apple iSight");\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"Apple iSight (GUID %08x%08x) at %s, S%d",\r\nfw_dev->config_rom[3], fw_dev->config_rom[4],\r\ndev_name(&unit->device), 100 << fw_dev->max_speed);\r\nstrcpy(card->mixername, "iSight");\r\nerr = isight_create_pcm(isight);\r\nif (err < 0)\r\ngoto error;\r\nerr = isight_create_mixer(isight);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto error;\r\ndev_set_drvdata(&unit->device, isight);\r\nreturn 0;\r\nerr_unit:\r\nfw_unit_put(isight->unit);\r\nmutex_destroy(&isight->mutex);\r\nerror:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic void isight_bus_reset(struct fw_unit *unit)\r\n{\r\nstruct isight *isight = dev_get_drvdata(&unit->device);\r\nif (fw_iso_resources_update(&isight->resources) < 0) {\r\nisight_pcm_abort(isight);\r\nmutex_lock(&isight->mutex);\r\nisight_stop_streaming(isight);\r\nmutex_unlock(&isight->mutex);\r\n}\r\n}\r\nstatic void isight_remove(struct fw_unit *unit)\r\n{\r\nstruct isight *isight = dev_get_drvdata(&unit->device);\r\nisight_pcm_abort(isight);\r\nsnd_card_disconnect(isight->card);\r\nmutex_lock(&isight->mutex);\r\nisight_stop_streaming(isight);\r\nmutex_unlock(&isight->mutex);\r\nsnd_card_free_when_closed(isight->card);\r\n}\r\nstatic int __init alsa_isight_init(void)\r\n{\r\nreturn driver_register(&isight_driver.driver);\r\n}\r\nstatic void __exit alsa_isight_exit(void)\r\n{\r\ndriver_unregister(&isight_driver.driver);\r\n}
