static void mc13xxx_led_work(struct work_struct *work)\r\n{\r\nstruct mc13xxx_led *led = container_of(work, struct mc13xxx_led, work);\r\nint reg, mask, value, bank, off, shift;\r\nswitch (led->id) {\r\ncase MC13783_LED_MD:\r\nreg = MC13XXX_REG_LED_CONTROL(2);\r\nshift = 9;\r\nmask = 0x0f;\r\nvalue = led->new_brightness >> 4;\r\nbreak;\r\ncase MC13783_LED_AD:\r\nreg = MC13XXX_REG_LED_CONTROL(2);\r\nshift = 13;\r\nmask = 0x0f;\r\nvalue = led->new_brightness >> 4;\r\nbreak;\r\ncase MC13783_LED_KP:\r\nreg = MC13XXX_REG_LED_CONTROL(2);\r\nshift = 17;\r\nmask = 0x0f;\r\nvalue = led->new_brightness >> 4;\r\nbreak;\r\ncase MC13783_LED_R1:\r\ncase MC13783_LED_G1:\r\ncase MC13783_LED_B1:\r\ncase MC13783_LED_R2:\r\ncase MC13783_LED_G2:\r\ncase MC13783_LED_B2:\r\ncase MC13783_LED_R3:\r\ncase MC13783_LED_G3:\r\ncase MC13783_LED_B3:\r\noff = led->id - MC13783_LED_R1;\r\nbank = off / 3;\r\nreg = MC13XXX_REG_LED_CONTROL(3) + bank;\r\nshift = (off - bank * 3) * 5 + 6;\r\nvalue = led->new_brightness >> 3;\r\nmask = 0x1f;\r\nbreak;\r\ncase MC13892_LED_MD:\r\nreg = MC13XXX_REG_LED_CONTROL(0);\r\nshift = 3;\r\nmask = 0x3f;\r\nvalue = led->new_brightness >> 2;\r\nbreak;\r\ncase MC13892_LED_AD:\r\nreg = MC13XXX_REG_LED_CONTROL(0);\r\nshift = 15;\r\nmask = 0x3f;\r\nvalue = led->new_brightness >> 2;\r\nbreak;\r\ncase MC13892_LED_KP:\r\nreg = MC13XXX_REG_LED_CONTROL(1);\r\nshift = 3;\r\nmask = 0x3f;\r\nvalue = led->new_brightness >> 2;\r\nbreak;\r\ncase MC13892_LED_R:\r\ncase MC13892_LED_G:\r\ncase MC13892_LED_B:\r\noff = led->id - MC13892_LED_R;\r\nbank = off / 2;\r\nreg = MC13XXX_REG_LED_CONTROL(2) + bank;\r\nshift = (off - bank * 2) * 12 + 3;\r\nvalue = led->new_brightness >> 2;\r\nmask = 0x3f;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nmc13xxx_lock(led->master);\r\nmc13xxx_reg_rmw(led->master, reg, mask << shift, value << shift);\r\nmc13xxx_unlock(led->master);\r\n}\r\nstatic void mc13xxx_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct mc13xxx_led *led =\r\ncontainer_of(led_cdev, struct mc13xxx_led, cdev);\r\nled->new_brightness = value;\r\nschedule_work(&led->work);\r\n}\r\nstatic int __init mc13xxx_led_setup(struct mc13xxx_led *led, int max_current)\r\n{\r\nint shift, mask, reg, ret, bank;\r\nswitch (led->id) {\r\ncase MC13783_LED_MD:\r\nreg = MC13XXX_REG_LED_CONTROL(2);\r\nshift = 0;\r\nmask = 0x07;\r\nbreak;\r\ncase MC13783_LED_AD:\r\nreg = MC13XXX_REG_LED_CONTROL(2);\r\nshift = 3;\r\nmask = 0x07;\r\nbreak;\r\ncase MC13783_LED_KP:\r\nreg = MC13XXX_REG_LED_CONTROL(2);\r\nshift = 6;\r\nmask = 0x07;\r\nbreak;\r\ncase MC13783_LED_R1:\r\ncase MC13783_LED_G1:\r\ncase MC13783_LED_B1:\r\ncase MC13783_LED_R2:\r\ncase MC13783_LED_G2:\r\ncase MC13783_LED_B2:\r\ncase MC13783_LED_R3:\r\ncase MC13783_LED_G3:\r\ncase MC13783_LED_B3:\r\nbank = (led->id - MC13783_LED_R1) / 3;\r\nreg = MC13XXX_REG_LED_CONTROL(3) + bank;\r\nshift = ((led->id - MC13783_LED_R1) - bank * 3) * 2;\r\nmask = 0x03;\r\nbreak;\r\ncase MC13892_LED_MD:\r\nreg = MC13XXX_REG_LED_CONTROL(0);\r\nshift = 9;\r\nmask = 0x07;\r\nbreak;\r\ncase MC13892_LED_AD:\r\nreg = MC13XXX_REG_LED_CONTROL(0);\r\nshift = 21;\r\nmask = 0x07;\r\nbreak;\r\ncase MC13892_LED_KP:\r\nreg = MC13XXX_REG_LED_CONTROL(1);\r\nshift = 9;\r\nmask = 0x07;\r\nbreak;\r\ncase MC13892_LED_R:\r\ncase MC13892_LED_G:\r\ncase MC13892_LED_B:\r\nbank = (led->id - MC13892_LED_R) / 2;\r\nreg = MC13XXX_REG_LED_CONTROL(2) + bank;\r\nshift = ((led->id - MC13892_LED_R) - bank * 2) * 12 + 9;\r\nmask = 0x07;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nmc13xxx_lock(led->master);\r\nret = mc13xxx_reg_rmw(led->master, reg, mask << shift,\r\nmax_current << shift);\r\nmc13xxx_unlock(led->master);\r\nreturn ret;\r\n}\r\nstatic int __init mc13xxx_led_probe(struct platform_device *pdev)\r\n{\r\nstruct mc13xxx_leds_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct mc13xxx *mcdev = dev_get_drvdata(pdev->dev.parent);\r\nstruct mc13xxx_led_devtype *devtype =\r\n(struct mc13xxx_led_devtype *)pdev->id_entry->driver_data;\r\nstruct mc13xxx_leds *leds;\r\nint i, id, num_leds, ret = -ENODATA;\r\nu32 reg, init_led = 0;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "Missing platform data\n");\r\nreturn -ENODEV;\r\n}\r\nnum_leds = pdata->num_leds;\r\nif ((num_leds < 1) ||\r\n(num_leds > (devtype->led_max - devtype->led_min + 1))) {\r\ndev_err(&pdev->dev, "Invalid LED count %d\n", num_leds);\r\nreturn -EINVAL;\r\n}\r\nleds = devm_kzalloc(&pdev->dev, num_leds * sizeof(struct mc13xxx_led) +\r\nsizeof(struct mc13xxx_leds), GFP_KERNEL);\r\nif (!leds)\r\nreturn -ENOMEM;\r\nleds->devtype = devtype;\r\nleds->num_leds = num_leds;\r\nplatform_set_drvdata(pdev, leds);\r\nmc13xxx_lock(mcdev);\r\nfor (i = 0; i < devtype->num_regs; i++) {\r\nreg = pdata->led_control[i];\r\nWARN_ON(reg >= (1 << 24));\r\nret = mc13xxx_reg_write(mcdev, MC13XXX_REG_LED_CONTROL(i), reg);\r\nif (ret)\r\nbreak;\r\n}\r\nmc13xxx_unlock(mcdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to init LED driver\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < num_leds; i++) {\r\nconst char *name, *trig;\r\nchar max_current;\r\nret = -EINVAL;\r\nid = pdata->led[i].id;\r\nname = pdata->led[i].name;\r\ntrig = pdata->led[i].default_trigger;\r\nmax_current = pdata->led[i].max_current;\r\nif ((id > devtype->led_max) || (id < devtype->led_min)) {\r\ndev_err(&pdev->dev, "Invalid ID %i\n", id);\r\nbreak;\r\n}\r\nif (init_led & (1 << id)) {\r\ndev_warn(&pdev->dev,\r\n"LED %i already initialized\n", id);\r\nbreak;\r\n}\r\ninit_led |= 1 << id;\r\nleds->led[i].id = id;\r\nleds->led[i].master = mcdev;\r\nleds->led[i].cdev.name = name;\r\nleds->led[i].cdev.default_trigger = trig;\r\nleds->led[i].cdev.brightness_set = mc13xxx_led_set;\r\nleds->led[i].cdev.brightness = LED_OFF;\r\nINIT_WORK(&leds->led[i].work, mc13xxx_led_work);\r\nret = mc13xxx_led_setup(&leds->led[i], max_current);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to setup LED %i\n", id);\r\nbreak;\r\n}\r\nret = led_classdev_register(pdev->dev.parent,\r\n&leds->led[i].cdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to register LED %i\n", id);\r\nbreak;\r\n}\r\n}\r\nif (ret)\r\nwhile (--i >= 0) {\r\nled_classdev_unregister(&leds->led[i].cdev);\r\ncancel_work_sync(&leds->led[i].work);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mc13xxx_led_remove(struct platform_device *pdev)\r\n{\r\nstruct mc13xxx *mcdev = dev_get_drvdata(pdev->dev.parent);\r\nstruct mc13xxx_leds *leds = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < leds->num_leds; i++) {\r\nled_classdev_unregister(&leds->led[i].cdev);\r\ncancel_work_sync(&leds->led[i].work);\r\n}\r\nmc13xxx_lock(mcdev);\r\nfor (i = 0; i < leds->devtype->num_regs; i++)\r\nmc13xxx_reg_write(mcdev, MC13XXX_REG_LED_CONTROL(i), 0);\r\nmc13xxx_unlock(mcdev);\r\nreturn 0;\r\n}
