static void hal_set_beacon_period(struct hw_data *pHwData, u16 beacon_period)\r\n{\r\nu32 tmp;\r\nif (pHwData->SurpriseRemove)\r\nreturn;\r\npHwData->BeaconPeriod = beacon_period;\r\ntmp = pHwData->BeaconPeriod << 16;\r\ntmp |= pHwData->ProbeDelay;\r\nWb35Reg_Write(pHwData, 0x0848, tmp);\r\n}\r\nstatic int wbsoft_add_interface(struct ieee80211_hw *dev,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct wbsoft_priv *priv = dev->priv;\r\nhal_set_beacon_period(&priv->sHwData, vif->bss_conf.beacon_int);\r\nreturn 0;\r\n}\r\nstatic void wbsoft_remove_interface(struct ieee80211_hw *dev,\r\nstruct ieee80211_vif *vif)\r\n{\r\n}\r\nstatic void wbsoft_stop(struct ieee80211_hw *hw)\r\n{\r\n}\r\nstatic int wbsoft_get_stats(struct ieee80211_hw *hw,\r\nstruct ieee80211_low_level_stats *stats)\r\n{\r\nreturn 0;\r\n}\r\nstatic u64 wbsoft_prepare_multicast(struct ieee80211_hw *hw,\r\nstruct netdev_hw_addr_list *mc_list)\r\n{\r\nreturn netdev_hw_addr_list_count(mc_list);\r\n}\r\nstatic void wbsoft_configure_filter(struct ieee80211_hw *dev,\r\nunsigned int changed_flags,\r\nunsigned int *total_flags,\r\nu64 multicast)\r\n{\r\nunsigned int new_flags;\r\nnew_flags = 0;\r\nif (*total_flags & FIF_PROMISC_IN_BSS)\r\nnew_flags |= FIF_PROMISC_IN_BSS;\r\nelse if ((*total_flags & FIF_ALLMULTI) || (multicast > 32))\r\nnew_flags |= FIF_ALLMULTI;\r\ndev->flags &= ~IEEE80211_HW_RX_INCLUDES_FCS;\r\n*total_flags = new_flags;\r\n}\r\nstatic void wbsoft_tx(struct ieee80211_hw *dev,\r\nstruct ieee80211_tx_control *control,\r\nstruct sk_buff *skb)\r\n{\r\nstruct wbsoft_priv *priv = dev->priv;\r\nif (priv->sMlmeFrame.IsInUsed != PACKET_FREE_TO_USE) {\r\npriv->sMlmeFrame.wNumTxMMPDUDiscarded++;\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\npriv->sMlmeFrame.IsInUsed = PACKET_COME_FROM_MLME;\r\npriv->sMlmeFrame.pMMPDU = skb->data;\r\npriv->sMlmeFrame.DataType = FRAME_TYPE_802_11_MANAGEMENT;\r\npriv->sMlmeFrame.len = skb->len;\r\npriv->sMlmeFrame.wNumTxMMPDU++;\r\nMds_Tx(priv);\r\n}\r\nstatic int wbsoft_start(struct ieee80211_hw *dev)\r\n{\r\nstruct wbsoft_priv *priv = dev->priv;\r\npriv->enabled = true;\r\nreturn 0;\r\n}\r\nstatic void hal_set_radio_mode(struct hw_data *pHwData, unsigned char radio_off)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nif (pHwData->SurpriseRemove)\r\nreturn;\r\nif (radio_off) {\r\npHwData->CurrentRadioSw = 1;\r\nreg->M24_MacControl &= 0xffffffbf;\r\n} else {\r\npHwData->CurrentRadioSw = 0;\r\nreg->M24_MacControl |= 0x00000040;\r\n}\r\nWb35Reg_Write(pHwData, 0x0824, reg->M24_MacControl);\r\n}\r\nstatic void hal_set_current_channel_ex(struct hw_data *pHwData, struct chan_info channel)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nif (pHwData->SurpriseRemove)\r\nreturn;\r\nRFSynthesizer_SwitchingChannel(pHwData, channel);\r\npHwData->Channel = channel.ChanNo;\r\npHwData->band = channel.band;\r\nreg->M28_MacControl &= ~0xff;\r\nreg->M28_MacControl |= channel.ChanNo;\r\nWb35Reg_WriteWithCallbackValue(pHwData, 0x0828, reg->M28_MacControl,\r\n(s8 *) &channel,\r\nsizeof(struct chan_info));\r\n}\r\nstatic void hal_set_current_channel(struct hw_data *pHwData, struct chan_info channel)\r\n{\r\nhal_set_current_channel_ex(pHwData, channel);\r\n}\r\nstatic void hal_set_accept_broadcast(struct hw_data *pHwData, u8 enable)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nif (pHwData->SurpriseRemove)\r\nreturn;\r\nreg->M00_MacControl &= ~0x02000000;\r\nif (enable)\r\nreg->M00_MacControl |= 0x02000000;\r\nWb35Reg_Write(pHwData, 0x0800, reg->M00_MacControl);\r\n}\r\nstatic void hal_set_accept_promiscuous(struct hw_data *pHwData, u8 enable)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nif (pHwData->SurpriseRemove)\r\nreturn;\r\nif (enable) {\r\nreg->M00_MacControl |= 0x00400000;\r\nWb35Reg_Write(pHwData, 0x0800, reg->M00_MacControl);\r\n} else {\r\nreg->M00_MacControl &= ~0x00400000;\r\nWb35Reg_Write(pHwData, 0x0800, reg->M00_MacControl);\r\n}\r\n}\r\nstatic void hal_set_accept_multicast(struct hw_data *pHwData, u8 enable)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nif (pHwData->SurpriseRemove)\r\nreturn;\r\nreg->M00_MacControl &= ~0x01000000;\r\nif (enable)\r\nreg->M00_MacControl |= 0x01000000;\r\nWb35Reg_Write(pHwData, 0x0800, reg->M00_MacControl);\r\n}\r\nstatic void hal_set_accept_beacon(struct hw_data *pHwData, u8 enable)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nif (pHwData->SurpriseRemove)\r\nreturn;\r\nif (!enable)\r\nreturn;\r\nreg->M00_MacControl &= ~0x04000000;\r\nif (enable)\r\nreg->M00_MacControl |= 0x04000000;\r\nWb35Reg_Write(pHwData, 0x0800, reg->M00_MacControl);\r\n}\r\nstatic int wbsoft_config(struct ieee80211_hw *dev, u32 changed)\r\n{\r\nstruct wbsoft_priv *priv = dev->priv;\r\nstruct chan_info ch;\r\nch.band = 1;\r\nch.ChanNo = 1;\r\nhal_set_current_channel(&priv->sHwData, ch);\r\nhal_set_accept_broadcast(&priv->sHwData, 1);\r\nhal_set_accept_promiscuous(&priv->sHwData, 1);\r\nhal_set_accept_multicast(&priv->sHwData, 1);\r\nhal_set_accept_beacon(&priv->sHwData, 1);\r\nhal_set_radio_mode(&priv->sHwData, 0);\r\nreturn 0;\r\n}\r\nstatic u64 wbsoft_get_tsf(struct ieee80211_hw *dev, struct ieee80211_vif *vif)\r\n{\r\nreturn 0;\r\n}\r\nstatic void hal_set_ethernet_address(struct hw_data *pHwData, u8 *current_address)\r\n{\r\nu32 ltmp[2];\r\nif (pHwData->SurpriseRemove)\r\nreturn;\r\nmemcpy(pHwData->CurrentMacAddress, current_address, ETH_ALEN);\r\nltmp[0] = cpu_to_le32(*(u32 *) pHwData->CurrentMacAddress);\r\nltmp[1] = cpu_to_le32(*(u32 *) (pHwData->CurrentMacAddress + 4)) & 0xffff;\r\nWb35Reg_BurstWrite(pHwData, 0x03e8, ltmp, 2, AUTO_INCREMENT);\r\n}\r\nstatic void hal_get_permanent_address(struct hw_data *pHwData, u8 *pethernet_address)\r\n{\r\nif (pHwData->SurpriseRemove)\r\nreturn;\r\nmemcpy(pethernet_address, pHwData->PermanentMacAddress, 6);\r\n}\r\nstatic void hal_stop(struct hw_data *pHwData)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\npHwData->Wb35Rx.rx_halt = 1;\r\nWb35Rx_stop(pHwData);\r\npHwData->Wb35Tx.tx_halt = 1;\r\nWb35Tx_stop(pHwData);\r\nreg->D00_DmaControl &= ~0xc0000000;\r\nWb35Reg_Write(pHwData, 0x0400, reg->D00_DmaControl);\r\n}\r\nstatic unsigned char hal_idle(struct hw_data *pHwData)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nif (!pHwData->SurpriseRemove && reg->EP0vm_state != VM_STOP)\r\nreturn false;\r\nreturn true;\r\n}\r\nu8 hal_get_antenna_number(struct hw_data *pHwData)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nif ((reg->BB2C & BIT(11)) == 0)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic u8 hal_get_hw_radio_off(struct hw_data *pHwData)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nif (pHwData->SurpriseRemove)\r\nreturn 1;\r\nWb35Reg_Read(pHwData, 0x3b0, &reg->U1B0);\r\nif ((reg->U1B0 & 0x00010000)) {\r\npHwData->CurrentRadioHw = 1;\r\nreturn 1;\r\n} else {\r\npHwData->CurrentRadioHw = 0;\r\nreturn 0;\r\n}\r\n}\r\nstatic void hal_led_control(unsigned long data)\r\n{\r\nstruct wbsoft_priv *adapter = (struct wbsoft_priv *)data;\r\nstruct hw_data *pHwData = &adapter->sHwData;\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nu32 LEDSet = (pHwData->SoftwareSet & HAL_LED_SET_MASK) >> HAL_LED_SET_SHIFT;\r\nu32 TimeInterval = 500, ltmp, ltmp2;\r\nltmp = 0;\r\nif (pHwData->SurpriseRemove)\r\nreturn;\r\nif (pHwData->LED_control) {\r\nltmp2 = pHwData->LED_control & 0xff;\r\nif (ltmp2 == 5) {\r\nTimeInterval = 100;\r\nltmp2 = (pHwData->LED_control >> 8) & 0xff;\r\nswitch (ltmp2) {\r\ncase 1:\r\npHwData->LED_Blinking %= 3;\r\nltmp = 0x1010;\r\nif (pHwData->LED_Blinking == 2)\r\nltmp = 0;\r\nbreak;\r\ncase 2:\r\npHwData->LED_Blinking %= 2;\r\nltmp = 0x0010;\r\nif (pHwData->LED_Blinking)\r\nltmp = 0;\r\nbreak;\r\ncase 3:\r\npHwData->LED_Blinking %= 15;\r\nltmp = 0x0010;\r\nif ((pHwData->LED_Blinking >= 9) || (pHwData->LED_Blinking % 2))\r\nltmp = 0;\r\nbreak;\r\ncase 4:\r\nltmp = 0x1000;\r\nif (pHwData->LED_Blinking >= 3000)\r\nltmp = 0;\r\nbreak;\r\n}\r\npHwData->LED_Blinking++;\r\nreg->U1BC_LEDConfigure = ltmp;\r\nif (LEDSet != 7) {\r\nreg->U1BC_LEDConfigure |= (ltmp & 0xff) << 8;\r\nreg->U1BC_LEDConfigure |= (ltmp & 0xff00) >> 8;\r\n}\r\nWb35Reg_Write(pHwData, 0x03bc, reg->U1BC_LEDConfigure);\r\n}\r\n} else if (pHwData->CurrentRadioSw || pHwData->CurrentRadioHw) {\r\nif (reg->U1BC_LEDConfigure & 0x1010) {\r\nreg->U1BC_LEDConfigure &= ~0x1010;\r\nWb35Reg_Write(pHwData, 0x03bc, reg->U1BC_LEDConfigure);\r\n}\r\n} else {\r\nswitch (LEDSet) {\r\ncase 4:\r\nif (!pHwData->LED_LinkOn) {\r\nif (pHwData->LED_Scanning) {\r\nif (pHwData->LED_Blinking == 0) {\r\nreg->U1BC_LEDConfigure |= 0x10;\r\nWb35Reg_Write(pHwData, 0x03bc, reg->U1BC_LEDConfigure);\r\npHwData->LED_Blinking = 1;\r\nTimeInterval = 300;\r\n} else {\r\nreg->U1BC_LEDConfigure &= ~0x10;\r\nWb35Reg_Write(pHwData, 0x03bc, reg->U1BC_LEDConfigure);\r\npHwData->LED_Blinking = 0;\r\nTimeInterval = 300;\r\n}\r\n} else {\r\nif (reg->U1BC_LEDConfigure & 0x10) {\r\nreg->U1BC_LEDConfigure &= ~0x10;\r\nWb35Reg_Write(pHwData, 0x03bc, reg->U1BC_LEDConfigure);\r\n}\r\n}\r\n} else {\r\nif ((reg->U1BC_LEDConfigure & 0x10) == 0) {\r\nreg->U1BC_LEDConfigure |= 0x10;\r\nWb35Reg_Write(pHwData, 0x03bc, reg->U1BC_LEDConfigure);\r\n}\r\n}\r\nbreak;\r\ncase 6:\r\nif (!pHwData->LED_LinkOn) {\r\nif (pHwData->LED_Scanning) {\r\nif (pHwData->LED_Blinking == 0) {\r\nreg->U1BC_LEDConfigure &= ~0xf;\r\nreg->U1BC_LEDConfigure |= 0x10;\r\nWb35Reg_Write(pHwData, 0x03bc, reg->U1BC_LEDConfigure);\r\npHwData->LED_Blinking = 1;\r\nTimeInterval = 300;\r\n} else {\r\nreg->U1BC_LEDConfigure &= ~0x1f;\r\nWb35Reg_Write(pHwData, 0x03bc, reg->U1BC_LEDConfigure);\r\npHwData->LED_Blinking = 0;\r\nTimeInterval = 300;\r\n}\r\n} else {\r\nltmp = reg->U1BC_LEDConfigure;\r\nreg->U1BC_LEDConfigure &= ~0x1f;\r\nif (LED_GRAY2[(pHwData->LED_Blinking % 30)]) {\r\nreg->U1BC_LEDConfigure |= 0x10;\r\nreg->U1BC_LEDConfigure |=\r\nLED_GRAY2[(pHwData->LED_Blinking % 30)];\r\n}\r\npHwData->LED_Blinking++;\r\nif (reg->U1BC_LEDConfigure != ltmp)\r\nWb35Reg_Write(pHwData, 0x03bc, reg->U1BC_LEDConfigure);\r\nTimeInterval = 100;\r\n}\r\n} else {\r\nif ((reg->U1BC_LEDConfigure & 0x10) == 0) {\r\nreg->U1BC_LEDConfigure |= 0x10;\r\nWb35Reg_Write(pHwData, 0x03bc, reg->U1BC_LEDConfigure);\r\n}\r\n}\r\nbreak;\r\ncase 5:\r\nif (!pHwData->LED_LinkOn) {\r\nif (pHwData->LED_Scanning) {\r\nif (pHwData->LED_Blinking == 0) {\r\nreg->U1BC_LEDConfigure |= 0x1000;\r\nWb35Reg_Write(pHwData, 0x03bc, reg->U1BC_LEDConfigure);\r\npHwData->LED_Blinking = 1;\r\nTimeInterval = 300;\r\n} else {\r\nreg->U1BC_LEDConfigure &= ~0x1000;\r\nWb35Reg_Write(pHwData, 0x03bc, reg->U1BC_LEDConfigure);\r\npHwData->LED_Blinking = 0;\r\nTimeInterval = 300;\r\n}\r\n} else {\r\nif (reg->U1BC_LEDConfigure & 0x1000) {\r\nreg->U1BC_LEDConfigure &= ~0x1000;\r\nWb35Reg_Write(pHwData, 0x03bc, reg->U1BC_LEDConfigure);\r\n}\r\n}\r\n} else {\r\nif ((adapter->RxByteCount !=\r\npHwData->RxByteCountLast)\r\n|| (adapter->TxByteCount !=\r\npHwData->TxByteCountLast)) {\r\nif ((reg->U1BC_LEDConfigure & 0x3000) !=\r\n0x3000) {\r\nreg->U1BC_LEDConfigure |= 0x3000;\r\nWb35Reg_Write(pHwData, 0x03bc, reg->U1BC_LEDConfigure);\r\n}\r\npHwData->RxByteCountLast =\r\nadapter->RxByteCount;\r\npHwData->TxByteCountLast =\r\nadapter->TxByteCount;\r\nTimeInterval = 200;\r\n} else {\r\nif ((reg->U1BC_LEDConfigure & 0x3000) !=\r\n0x1000) {\r\nreg->U1BC_LEDConfigure &=\r\n~0x3000;\r\nreg->U1BC_LEDConfigure |=\r\n0x1000;\r\nWb35Reg_Write(pHwData, 0x03bc, reg->U1BC_LEDConfigure);\r\n}\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nif ((reg->U1BC_LEDConfigure & 0x3000) != 0x3000) {\r\nreg->U1BC_LEDConfigure |= 0x3000;\r\nWb35Reg_Write(pHwData, 0x03bc,\r\nreg->U1BC_LEDConfigure);\r\n}\r\nif (pHwData->LED_Blinking) {\r\nreg->U1BC_LEDConfigure &= ~0x0f;\r\nreg->U1BC_LEDConfigure |= 0x10;\r\nreg->U1BC_LEDConfigure |=\r\nLED_GRAY[(pHwData->LED_Blinking - 1) % 20];\r\nWb35Reg_Write(pHwData, 0x03bc,\r\nreg->U1BC_LEDConfigure);\r\npHwData->LED_Blinking += 2;\r\nif (pHwData->LED_Blinking < 40)\r\nTimeInterval = 100;\r\nelse {\r\npHwData->LED_Blinking = 0;\r\nreg->U1BC_LEDConfigure &= ~0x0f;\r\nWb35Reg_Write(pHwData, 0x03bc,\r\nreg->U1BC_LEDConfigure);\r\n}\r\nbreak;\r\n}\r\nif (pHwData->LED_LinkOn) {\r\nif (!(reg->U1BC_LEDConfigure & 0x10)) {\r\nreg->U1BC_LEDConfigure |= 0x10;\r\npHwData->LED_Blinking = 1;\r\nTimeInterval = 50;\r\n}\r\n} else {\r\nif (reg->U1BC_LEDConfigure & 0x10) {\r\nreg->U1BC_LEDConfigure &= ~0x10;\r\nWb35Reg_Write(pHwData, 0x03bc,\r\nreg->U1BC_LEDConfigure);\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\npHwData->time_count += TimeInterval;\r\nWb35Tx_CurrentTime(adapter, pHwData->time_count);\r\npHwData->LEDTimer.expires = jiffies + msecs_to_jiffies(TimeInterval);\r\nadd_timer(&pHwData->LEDTimer);\r\n}\r\nstatic int hal_init_hardware(struct ieee80211_hw *hw)\r\n{\r\nstruct wbsoft_priv *priv = hw->priv;\r\nstruct hw_data *pHwData = &priv->sHwData;\r\nu16 SoftwareSet;\r\npHwData->MaxReceiveLifeTime = DEFAULT_MSDU_LIFE_TIME;\r\npHwData->FragmentThreshold = DEFAULT_FRAGMENT_THRESHOLD;\r\nif (!Wb35Reg_initial(pHwData))\r\ngoto error_reg_destroy;\r\nif (!Wb35Tx_initial(pHwData))\r\ngoto error_tx_destroy;\r\nif (!Wb35Rx_initial(pHwData))\r\ngoto error_rx_destroy;\r\ninit_timer(&pHwData->LEDTimer);\r\npHwData->LEDTimer.function = hal_led_control;\r\npHwData->LEDTimer.data = (unsigned long)priv;\r\npHwData->LEDTimer.expires = jiffies + msecs_to_jiffies(1000);\r\nadd_timer(&pHwData->LEDTimer);\r\nSoftwareSet = hal_software_set(pHwData);\r\nWb35Rx_start(hw);\r\nWb35Tx_EP2VM_start(priv);\r\nreturn 0;\r\nerror_rx_destroy:\r\nWb35Rx_destroy(pHwData);\r\nerror_tx_destroy:\r\nWb35Tx_destroy(pHwData);\r\nerror_reg_destroy:\r\nWb35Reg_destroy(pHwData);\r\npHwData->SurpriseRemove = 1;\r\nreturn -EINVAL;\r\n}\r\nstatic int wb35_hw_init(struct ieee80211_hw *hw)\r\n{\r\nstruct wbsoft_priv *priv = hw->priv;\r\nstruct hw_data *pHwData = &priv->sHwData;\r\nu8 EEPROM_region;\r\nu8 HwRadioOff;\r\nu8 *pMacAddr2;\r\nu8 *pMacAddr;\r\nint err;\r\npHwData->phy_type = RF_DECIDE_BY_INF;\r\npriv->Mds.TxRTSThreshold = DEFAULT_RTSThreshold;\r\npriv->Mds.TxFragmentThreshold = DEFAULT_FRAGMENT_THRESHOLD;\r\npriv->sLocalPara.region_INF = REGION_AUTO;\r\npriv->sLocalPara.TxRateMode = RATE_AUTO;\r\npriv->sLocalPara.bMacOperationMode = MODE_802_11_BG;\r\npriv->sLocalPara.MTUsize = MAX_ETHERNET_PACKET_SIZE;\r\npriv->sLocalPara.bPreambleMode = AUTO_MODE;\r\npriv->sLocalPara.bWepKeyError = false;\r\npriv->sLocalPara.bToSelfPacketReceived = false;\r\npriv->sLocalPara.WepKeyDetectTimerCount = 2 * 100;\r\npriv->sLocalPara.RadioOffStatus.boSwRadioOff = false;\r\nerr = hal_init_hardware(hw);\r\nif (err)\r\ngoto error;\r\nEEPROM_region = hal_get_region_from_EEPROM(pHwData);\r\nif (EEPROM_region != REGION_AUTO)\r\npriv->sLocalPara.region = EEPROM_region;\r\nelse {\r\nif (priv->sLocalPara.region_INF != REGION_AUTO)\r\npriv->sLocalPara.region = priv->sLocalPara.region_INF;\r\nelse\r\npriv->sLocalPara.region = REGION_USA;\r\n}\r\nMds_initial(priv);\r\npMacAddr = priv->sLocalPara.ThisMacAddress;\r\npMacAddr2 = priv->sLocalPara.PermanentAddress;\r\nhal_get_permanent_address(pHwData, priv->sLocalPara.PermanentAddress);\r\nif (memcmp(pMacAddr, "\x00\x00\x00\x00\x00\x00", MAC_ADDR_LENGTH) == 0)\r\nmemcpy(pMacAddr, pMacAddr2, MAC_ADDR_LENGTH);\r\nelse {\r\nhal_set_ethernet_address(pHwData,\r\npriv->sLocalPara.ThisMacAddress);\r\n}\r\npriv->sLocalPara.bAntennaNo = hal_get_antenna_number(pHwData);\r\nhal_get_hw_radio_off(pHwData);\r\nwhile (!hal_idle(pHwData))\r\nmsleep(10);\r\nMTO_Init(priv);\r\nHwRadioOff = hal_get_hw_radio_off(pHwData);\r\npriv->sLocalPara.RadioOffStatus.boHwRadioOff = !!HwRadioOff;\r\nhal_set_radio_mode(pHwData,\r\n(unsigned char)(priv->sLocalPara.RadioOffStatus.\r\nboSwRadioOff\r\n|| priv->sLocalPara.RadioOffStatus.\r\nboHwRadioOff));\r\nhal_driver_init_OK(pHwData) = 1;\r\nerror:\r\nreturn err;\r\n}\r\nstatic int wb35_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id_table)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct usb_host_interface *interface;\r\nstruct ieee80211_hw *dev;\r\nstruct wbsoft_priv *priv;\r\nint err;\r\nu32 ltmp;\r\nusb_get_dev(udev);\r\nerr = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\n0x01,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n0x0, 0x400, &ltmp, 4, HZ * 100);\r\nif (err < 0)\r\ngoto error;\r\nltmp = cpu_to_le32(ltmp);\r\nif (ltmp) {\r\nerr = -EBUSY;\r\ngoto error;\r\n}\r\ndev = ieee80211_alloc_hw(sizeof(*priv), &wbsoft_ops);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\npriv = dev->priv;\r\npriv->sHwData.udev = udev;\r\ninterface = intf->cur_altsetting;\r\nendpoint = &interface->endpoint[0].desc;\r\nerr = wb35_hw_init(dev);\r\nif (err)\r\ngoto error_free_hw;\r\nSET_IEEE80211_DEV(dev, &udev->dev);\r\n{\r\nstruct hw_data *pHwData = &priv->sHwData;\r\nunsigned char dev_addr[MAX_ADDR_LEN];\r\nhal_get_permanent_address(pHwData, dev_addr);\r\nSET_IEEE80211_PERM_ADDR(dev, dev_addr);\r\n}\r\ndev->extra_tx_headroom = 12;\r\ndev->flags = IEEE80211_HW_SIGNAL_UNSPEC;\r\ndev->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);\r\ndev->channel_change_time = 1000;\r\ndev->max_signal = 100;\r\ndev->queues = 1;\r\ndev->wiphy->bands[IEEE80211_BAND_2GHZ] = &wbsoft_band_2GHz;\r\nerr = ieee80211_register_hw(dev);\r\nif (err)\r\ngoto error_free_hw;\r\nusb_set_intfdata(intf, dev);\r\nreturn 0;\r\nerror_free_hw:\r\nieee80211_free_hw(dev);\r\nerror:\r\nusb_put_dev(udev);\r\nreturn err;\r\n}\r\nstatic void hal_halt(struct hw_data *pHwData)\r\n{\r\ndel_timer_sync(&pHwData->LEDTimer);\r\nmsleep(100);\r\nWb35Rx_destroy(pHwData);\r\nWb35Tx_destroy(pHwData);\r\nWb35Reg_destroy(pHwData);\r\n}\r\nstatic void wb35_hw_halt(struct wbsoft_priv *adapter)\r\n{\r\nhal_stop(&adapter->sHwData);\r\nmsleep(100);\r\nhal_halt(&adapter->sHwData);\r\n}\r\nstatic void wb35_disconnect(struct usb_interface *intf)\r\n{\r\nstruct ieee80211_hw *hw = usb_get_intfdata(intf);\r\nstruct wbsoft_priv *priv = hw->priv;\r\nwb35_hw_halt(priv);\r\nieee80211_stop_queues(hw);\r\nieee80211_unregister_hw(hw);\r\nieee80211_free_hw(hw);\r\nusb_set_intfdata(intf, NULL);\r\nusb_put_dev(interface_to_usbdev(intf));\r\n}
