static struct afs_cell *afs_cell_alloc(const char *name, unsigned namelen,\r\nchar *vllist)\r\n{\r\nstruct afs_cell *cell;\r\nstruct key *key;\r\nchar keyname[4 + AFS_MAXCELLNAME + 1], *cp, *dp, *next;\r\nchar *dvllist = NULL, *_vllist = NULL;\r\nchar delimiter = ':';\r\nint ret;\r\n_enter("%*.*s,%s", namelen, namelen, name ?: "", vllist);\r\nBUG_ON(!name);\r\nif (namelen > AFS_MAXCELLNAME) {\r\n_leave(" = -ENAMETOOLONG");\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\n}\r\ncell = kzalloc(sizeof(struct afs_cell) + namelen + 1, GFP_KERNEL);\r\nif (!cell) {\r\n_leave(" = -ENOMEM");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nmemcpy(cell->name, name, namelen);\r\ncell->name[namelen] = 0;\r\natomic_set(&cell->usage, 1);\r\nINIT_LIST_HEAD(&cell->link);\r\nrwlock_init(&cell->servers_lock);\r\nINIT_LIST_HEAD(&cell->servers);\r\ninit_rwsem(&cell->vl_sem);\r\nINIT_LIST_HEAD(&cell->vl_list);\r\nspin_lock_init(&cell->vl_lock);\r\nif (!vllist || strlen(vllist) < 7) {\r\nret = dns_query("afsdb", name, namelen, "ipv4", &dvllist, NULL);\r\nif (ret < 0) {\r\nif (ret == -ENODATA || ret == -EAGAIN || ret == -ENOKEY)\r\nret = -EDESTADDRREQ;\r\n_leave(" = %d", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\n_vllist = dvllist;\r\ndelimiter = ',';\r\n} else {\r\n_vllist = vllist;\r\n}\r\ndo {\r\nunsigned a, b, c, d;\r\nnext = strchr(_vllist, delimiter);\r\nif (next)\r\n*next++ = 0;\r\nif (sscanf(_vllist, "%u.%u.%u.%u", &a, &b, &c, &d) != 4)\r\ngoto bad_address;\r\nif (a > 255 || b > 255 || c > 255 || d > 255)\r\ngoto bad_address;\r\ncell->vl_addrs[cell->vl_naddrs++].s_addr =\r\nhtonl((a << 24) | (b << 16) | (c << 8) | d);\r\n} while (cell->vl_naddrs < AFS_CELL_MAX_ADDRS && (_vllist = next));\r\nmemcpy(keyname, "afs@", 4);\r\ndp = keyname + 4;\r\ncp = cell->name;\r\ndo {\r\n*dp++ = toupper(*cp);\r\n} while (*cp++);\r\nkey = rxrpc_get_null_key(keyname);\r\nif (IS_ERR(key)) {\r\n_debug("no key");\r\nret = PTR_ERR(key);\r\ngoto error;\r\n}\r\ncell->anonymous_key = key;\r\n_debug("anon key %p{%x}",\r\ncell->anonymous_key, key_serial(cell->anonymous_key));\r\n_leave(" = %p", cell);\r\nreturn cell;\r\nbad_address:\r\nprintk(KERN_ERR "kAFS: bad VL server IP address\n");\r\nret = -EINVAL;\r\nerror:\r\nkey_put(cell->anonymous_key);\r\nkfree(dvllist);\r\nkfree(cell);\r\n_leave(" = %d", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nstruct afs_cell *afs_cell_create(const char *name, unsigned namesz,\r\nchar *vllist, bool retref)\r\n{\r\nstruct afs_cell *cell;\r\nint ret;\r\n_enter("%*.*s,%s", namesz, namesz, name ?: "", vllist);\r\ndown_write(&afs_cells_sem);\r\nread_lock(&afs_cells_lock);\r\nlist_for_each_entry(cell, &afs_cells, link) {\r\nif (strncasecmp(cell->name, name, namesz) == 0)\r\ngoto duplicate_name;\r\n}\r\nread_unlock(&afs_cells_lock);\r\ncell = afs_cell_alloc(name, namesz, vllist);\r\nif (IS_ERR(cell)) {\r\n_leave(" = %ld", PTR_ERR(cell));\r\nup_write(&afs_cells_sem);\r\nreturn cell;\r\n}\r\nret = afs_proc_cell_setup(cell);\r\nif (ret < 0)\r\ngoto error;\r\n#ifdef CONFIG_AFS_FSCACHE\r\ncell->cache = fscache_acquire_cookie(afs_cache_netfs.primary_index,\r\n&afs_cell_cache_index_def,\r\ncell);\r\n#endif\r\nwrite_lock(&afs_cells_lock);\r\nlist_add_tail(&cell->link, &afs_cells);\r\nwrite_unlock(&afs_cells_lock);\r\ndown_write(&afs_proc_cells_sem);\r\nlist_add_tail(&cell->proc_link, &afs_proc_cells);\r\nup_write(&afs_proc_cells_sem);\r\nup_write(&afs_cells_sem);\r\n_leave(" = %p", cell);\r\nreturn cell;\r\nerror:\r\nup_write(&afs_cells_sem);\r\nkey_put(cell->anonymous_key);\r\nkfree(cell);\r\n_leave(" = %d", ret);\r\nreturn ERR_PTR(ret);\r\nduplicate_name:\r\nif (retref && !IS_ERR(cell))\r\nafs_get_cell(cell);\r\nread_unlock(&afs_cells_lock);\r\nup_write(&afs_cells_sem);\r\nif (retref) {\r\n_leave(" = %p", cell);\r\nreturn cell;\r\n}\r\n_leave(" = -EEXIST");\r\nreturn ERR_PTR(-EEXIST);\r\n}\r\nint afs_cell_init(char *rootcell)\r\n{\r\nstruct afs_cell *old_root, *new_root;\r\nchar *cp;\r\n_enter("");\r\nif (!rootcell) {\r\n_leave(" = 0 [no root]");\r\nreturn 0;\r\n}\r\ncp = strchr(rootcell, ':');\r\nif (!cp)\r\n_debug("kAFS: no VL server IP addresses specified");\r\nelse\r\n*cp++ = 0;\r\nnew_root = afs_cell_create(rootcell, strlen(rootcell), cp, false);\r\nif (IS_ERR(new_root)) {\r\n_leave(" = %ld", PTR_ERR(new_root));\r\nreturn PTR_ERR(new_root);\r\n}\r\nwrite_lock(&afs_cells_lock);\r\nold_root = afs_cell_root;\r\nafs_cell_root = new_root;\r\nwrite_unlock(&afs_cells_lock);\r\nafs_put_cell(old_root);\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nstruct afs_cell *afs_cell_lookup(const char *name, unsigned namesz,\r\nbool dns_cell)\r\n{\r\nstruct afs_cell *cell;\r\n_enter("\"%*.*s\",", namesz, namesz, name ?: "");\r\ndown_read(&afs_cells_sem);\r\nread_lock(&afs_cells_lock);\r\nif (name) {\r\nlist_for_each_entry(cell, &afs_cells, link) {\r\nif (strncmp(cell->name, name, namesz) == 0) {\r\nafs_get_cell(cell);\r\ngoto found;\r\n}\r\n}\r\ncell = ERR_PTR(-ENOENT);\r\nif (dns_cell)\r\ngoto create_cell;\r\nfound:\r\n;\r\n} else {\r\ncell = afs_cell_root;\r\nif (!cell) {\r\ncell = ERR_PTR(-EDESTADDRREQ);\r\n} else {\r\nafs_get_cell(cell);\r\n}\r\n}\r\nread_unlock(&afs_cells_lock);\r\nup_read(&afs_cells_sem);\r\n_leave(" = %p", cell);\r\nreturn cell;\r\ncreate_cell:\r\nread_unlock(&afs_cells_lock);\r\nup_read(&afs_cells_sem);\r\ncell = afs_cell_create(name, namesz, NULL, true);\r\n_leave(" = %p", cell);\r\nreturn cell;\r\n}\r\nvoid afs_put_cell(struct afs_cell *cell)\r\n{\r\nif (!cell)\r\nreturn;\r\n_enter("%p{%d,%s}", cell, atomic_read(&cell->usage), cell->name);\r\nASSERTCMP(atomic_read(&cell->usage), >, 0);\r\nwrite_lock(&afs_cells_lock);\r\nif (likely(!atomic_dec_and_test(&cell->usage))) {\r\nwrite_unlock(&afs_cells_lock);\r\n_leave("");\r\nreturn;\r\n}\r\nASSERT(list_empty(&cell->servers));\r\nASSERT(list_empty(&cell->vl_list));\r\nwrite_unlock(&afs_cells_lock);\r\nwake_up(&afs_cells_freeable_wq);\r\n_leave(" [unused]");\r\n}\r\nstatic void afs_cell_destroy(struct afs_cell *cell)\r\n{\r\n_enter("%p{%d,%s}", cell, atomic_read(&cell->usage), cell->name);\r\nASSERTCMP(atomic_read(&cell->usage), >=, 0);\r\nASSERT(list_empty(&cell->link));\r\nif (atomic_read(&cell->usage) > 0) {\r\nDECLARE_WAITQUEUE(myself, current);\r\n_debug("wait for cell %s", cell->name);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&afs_cells_freeable_wq, &myself);\r\nwhile (atomic_read(&cell->usage) > 0) {\r\nschedule();\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\n}\r\nremove_wait_queue(&afs_cells_freeable_wq, &myself);\r\nset_current_state(TASK_RUNNING);\r\n}\r\n_debug("cell dead");\r\nASSERTCMP(atomic_read(&cell->usage), ==, 0);\r\nASSERT(list_empty(&cell->servers));\r\nASSERT(list_empty(&cell->vl_list));\r\nafs_proc_cell_remove(cell);\r\ndown_write(&afs_proc_cells_sem);\r\nlist_del_init(&cell->proc_link);\r\nup_write(&afs_proc_cells_sem);\r\n#ifdef CONFIG_AFS_FSCACHE\r\nfscache_relinquish_cookie(cell->cache, 0);\r\n#endif\r\nkey_put(cell->anonymous_key);\r\nkfree(cell);\r\n_leave(" [destroyed]");\r\n}\r\nvoid afs_cell_purge(void)\r\n{\r\nstruct afs_cell *cell;\r\n_enter("");\r\nafs_put_cell(afs_cell_root);\r\ndown_write(&afs_cells_sem);\r\nwhile (!list_empty(&afs_cells)) {\r\ncell = NULL;\r\nwrite_lock(&afs_cells_lock);\r\nif (!list_empty(&afs_cells)) {\r\ncell = list_entry(afs_cells.next,\r\nstruct afs_cell, link);\r\nlist_del_init(&cell->link);\r\n}\r\nwrite_unlock(&afs_cells_lock);\r\nif (cell) {\r\n_debug("PURGING CELL %s (%d)",\r\ncell->name, atomic_read(&cell->usage));\r\nafs_cell_destroy(cell);\r\n}\r\n}\r\nup_write(&afs_cells_sem);\r\n_leave("");\r\n}
