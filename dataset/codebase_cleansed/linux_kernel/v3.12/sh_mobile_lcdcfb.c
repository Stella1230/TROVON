static bool banked(int reg_nr)\r\n{\r\nswitch (reg_nr) {\r\ncase LDMT1R:\r\ncase LDMT2R:\r\ncase LDMT3R:\r\ncase LDDFR:\r\ncase LDSM1R:\r\ncase LDSA1R:\r\ncase LDSA2R:\r\ncase LDMLSR:\r\ncase LDHCNR:\r\ncase LDHSYNR:\r\ncase LDVLNR:\r\ncase LDVSYNR:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int lcdc_chan_is_sublcd(struct sh_mobile_lcdc_chan *chan)\r\n{\r\nreturn chan->cfg->chan == LCDC_CHAN_SUBLCD;\r\n}\r\nstatic void lcdc_write_chan(struct sh_mobile_lcdc_chan *chan,\r\nint reg_nr, unsigned long data)\r\n{\r\niowrite32(data, chan->lcdc->base + chan->reg_offs[reg_nr]);\r\nif (banked(reg_nr))\r\niowrite32(data, chan->lcdc->base + chan->reg_offs[reg_nr] +\r\nSIDE_B_OFFSET);\r\n}\r\nstatic void lcdc_write_chan_mirror(struct sh_mobile_lcdc_chan *chan,\r\nint reg_nr, unsigned long data)\r\n{\r\niowrite32(data, chan->lcdc->base + chan->reg_offs[reg_nr] +\r\nMIRROR_OFFSET);\r\n}\r\nstatic unsigned long lcdc_read_chan(struct sh_mobile_lcdc_chan *chan,\r\nint reg_nr)\r\n{\r\nreturn ioread32(chan->lcdc->base + chan->reg_offs[reg_nr]);\r\n}\r\nstatic void lcdc_write_overlay(struct sh_mobile_lcdc_overlay *ovl,\r\nint reg, unsigned long data)\r\n{\r\niowrite32(data, ovl->channel->lcdc->base + reg);\r\niowrite32(data, ovl->channel->lcdc->base + reg + SIDE_B_OFFSET);\r\n}\r\nstatic void lcdc_write(struct sh_mobile_lcdc_priv *priv,\r\nunsigned long reg_offs, unsigned long data)\r\n{\r\niowrite32(data, priv->base + reg_offs);\r\n}\r\nstatic unsigned long lcdc_read(struct sh_mobile_lcdc_priv *priv,\r\nunsigned long reg_offs)\r\n{\r\nreturn ioread32(priv->base + reg_offs);\r\n}\r\nstatic void lcdc_wait_bit(struct sh_mobile_lcdc_priv *priv,\r\nunsigned long reg_offs,\r\nunsigned long mask, unsigned long until)\r\n{\r\nwhile ((lcdc_read(priv, reg_offs) & mask) != until)\r\ncpu_relax();\r\n}\r\nstatic void sh_mobile_lcdc_clk_on(struct sh_mobile_lcdc_priv *priv)\r\n{\r\nif (atomic_inc_and_test(&priv->hw_usecnt)) {\r\nif (priv->dot_clk)\r\nclk_enable(priv->dot_clk);\r\npm_runtime_get_sync(priv->dev);\r\nif (priv->meram_dev && priv->meram_dev->pdev)\r\npm_runtime_get_sync(&priv->meram_dev->pdev->dev);\r\n}\r\n}\r\nstatic void sh_mobile_lcdc_clk_off(struct sh_mobile_lcdc_priv *priv)\r\n{\r\nif (atomic_sub_return(1, &priv->hw_usecnt) == -1) {\r\nif (priv->meram_dev && priv->meram_dev->pdev)\r\npm_runtime_put_sync(&priv->meram_dev->pdev->dev);\r\npm_runtime_put(priv->dev);\r\nif (priv->dot_clk)\r\nclk_disable(priv->dot_clk);\r\n}\r\n}\r\nstatic int sh_mobile_lcdc_setup_clocks(struct sh_mobile_lcdc_priv *priv,\r\nint clock_source)\r\n{\r\nstruct clk *clk;\r\nchar *str;\r\nswitch (clock_source) {\r\ncase LCDC_CLK_BUS:\r\nstr = "bus_clk";\r\npriv->lddckr = LDDCKR_ICKSEL_BUS;\r\nbreak;\r\ncase LCDC_CLK_PERIPHERAL:\r\nstr = "peripheral_clk";\r\npriv->lddckr = LDDCKR_ICKSEL_MIPI;\r\nbreak;\r\ncase LCDC_CLK_EXTERNAL:\r\nstr = NULL;\r\npriv->lddckr = LDDCKR_ICKSEL_HDMI;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (str == NULL)\r\nreturn 0;\r\nclk = clk_get(priv->dev, str);\r\nif (IS_ERR(clk)) {\r\ndev_err(priv->dev, "cannot get dot clock %s\n", str);\r\nreturn PTR_ERR(clk);\r\n}\r\npriv->dot_clk = clk;\r\nreturn 0;\r\n}\r\nstatic void lcdc_sys_write_index(void *handle, unsigned long data)\r\n{\r\nstruct sh_mobile_lcdc_chan *ch = handle;\r\nlcdc_write(ch->lcdc, _LDDWD0R, data | LDDWDxR_WDACT);\r\nlcdc_wait_bit(ch->lcdc, _LDSR, LDSR_AS, 0);\r\nlcdc_write(ch->lcdc, _LDDWAR, LDDWAR_WA |\r\n(lcdc_chan_is_sublcd(ch) ? 2 : 0));\r\nlcdc_wait_bit(ch->lcdc, _LDSR, LDSR_AS, 0);\r\n}\r\nstatic void lcdc_sys_write_data(void *handle, unsigned long data)\r\n{\r\nstruct sh_mobile_lcdc_chan *ch = handle;\r\nlcdc_write(ch->lcdc, _LDDWD0R, data | LDDWDxR_WDACT | LDDWDxR_RSW);\r\nlcdc_wait_bit(ch->lcdc, _LDSR, LDSR_AS, 0);\r\nlcdc_write(ch->lcdc, _LDDWAR, LDDWAR_WA |\r\n(lcdc_chan_is_sublcd(ch) ? 2 : 0));\r\nlcdc_wait_bit(ch->lcdc, _LDSR, LDSR_AS, 0);\r\n}\r\nstatic unsigned long lcdc_sys_read_data(void *handle)\r\n{\r\nstruct sh_mobile_lcdc_chan *ch = handle;\r\nlcdc_write(ch->lcdc, _LDDRDR, LDDRDR_RSR);\r\nlcdc_wait_bit(ch->lcdc, _LDSR, LDSR_AS, 0);\r\nlcdc_write(ch->lcdc, _LDDRAR, LDDRAR_RA |\r\n(lcdc_chan_is_sublcd(ch) ? 2 : 0));\r\nudelay(1);\r\nlcdc_wait_bit(ch->lcdc, _LDSR, LDSR_AS, 0);\r\nreturn lcdc_read(ch->lcdc, _LDDRDR) & LDDRDR_DRD_MASK;\r\n}\r\nstatic int sh_mobile_lcdc_sginit(struct fb_info *info,\r\nstruct list_head *pagelist)\r\n{\r\nstruct sh_mobile_lcdc_chan *ch = info->par;\r\nunsigned int nr_pages_max = ch->fb_size >> PAGE_SHIFT;\r\nstruct page *page;\r\nint nr_pages = 0;\r\nsg_init_table(ch->sglist, nr_pages_max);\r\nlist_for_each_entry(page, pagelist, lru)\r\nsg_set_page(&ch->sglist[nr_pages++], page, PAGE_SIZE, 0);\r\nreturn nr_pages;\r\n}\r\nstatic void sh_mobile_lcdc_deferred_io(struct fb_info *info,\r\nstruct list_head *pagelist)\r\n{\r\nstruct sh_mobile_lcdc_chan *ch = info->par;\r\nconst struct sh_mobile_lcdc_panel_cfg *panel = &ch->cfg->panel_cfg;\r\nsh_mobile_lcdc_clk_on(ch->lcdc);\r\nif (!list_empty(pagelist)) {\r\nunsigned int nr_pages = sh_mobile_lcdc_sginit(info, pagelist);\r\ndma_map_sg(ch->lcdc->dev, ch->sglist, nr_pages, DMA_TO_DEVICE);\r\nif (panel->start_transfer)\r\npanel->start_transfer(ch, &sh_mobile_lcdc_sys_bus_ops);\r\nlcdc_write_chan(ch, LDSM2R, LDSM2R_OSTRG);\r\ndma_unmap_sg(ch->lcdc->dev, ch->sglist, nr_pages,\r\nDMA_TO_DEVICE);\r\n} else {\r\nif (panel->start_transfer)\r\npanel->start_transfer(ch, &sh_mobile_lcdc_sys_bus_ops);\r\nlcdc_write_chan(ch, LDSM2R, LDSM2R_OSTRG);\r\n}\r\n}\r\nstatic void sh_mobile_lcdc_deferred_io_touch(struct fb_info *info)\r\n{\r\nstruct fb_deferred_io *fbdefio = info->fbdefio;\r\nif (fbdefio)\r\nschedule_delayed_work(&info->deferred_work, fbdefio->delay);\r\n}\r\nstatic void sh_mobile_lcdc_display_on(struct sh_mobile_lcdc_chan *ch)\r\n{\r\nconst struct sh_mobile_lcdc_panel_cfg *panel = &ch->cfg->panel_cfg;\r\nif (ch->tx_dev) {\r\nint ret;\r\nret = ch->tx_dev->ops->display_on(ch->tx_dev);\r\nif (ret < 0)\r\nreturn;\r\nif (ret == SH_MOBILE_LCDC_DISPLAY_DISCONNECTED)\r\nch->info->state = FBINFO_STATE_SUSPENDED;\r\n}\r\nif (panel->display_on)\r\npanel->display_on();\r\n}\r\nstatic void sh_mobile_lcdc_display_off(struct sh_mobile_lcdc_chan *ch)\r\n{\r\nconst struct sh_mobile_lcdc_panel_cfg *panel = &ch->cfg->panel_cfg;\r\nif (panel->display_off)\r\npanel->display_off();\r\nif (ch->tx_dev)\r\nch->tx_dev->ops->display_off(ch->tx_dev);\r\n}\r\nstatic bool\r\nsh_mobile_lcdc_must_reconfigure(struct sh_mobile_lcdc_chan *ch,\r\nconst struct fb_videomode *new_mode)\r\n{\r\ndev_dbg(ch->info->dev, "Old %ux%u, new %ux%u\n",\r\nch->display.mode.xres, ch->display.mode.yres,\r\nnew_mode->xres, new_mode->yres);\r\nif (fb_mode_is_equal(&ch->display.mode, new_mode))\r\nreturn false;\r\ndev_dbg(ch->info->dev, "Switching %u -> %u lines\n",\r\nch->display.mode.yres, new_mode->yres);\r\nch->display.mode = *new_mode;\r\nreturn true;\r\n}\r\nstatic int sh_mobile_lcdc_display_notify(struct sh_mobile_lcdc_chan *ch,\r\nenum sh_mobile_lcdc_entity_event event,\r\nconst struct fb_videomode *mode,\r\nconst struct fb_monspecs *monspec)\r\n{\r\nstruct fb_info *info = ch->info;\r\nstruct fb_var_screeninfo var;\r\nint ret = 0;\r\nswitch (event) {\r\ncase SH_MOBILE_LCDC_EVENT_DISPLAY_CONNECT:\r\nif (lock_fb_info(info)) {\r\nconsole_lock();\r\nch->display.width = monspec->max_x * 10;\r\nch->display.height = monspec->max_y * 10;\r\nif (!sh_mobile_lcdc_must_reconfigure(ch, mode) &&\r\ninfo->state == FBINFO_STATE_RUNNING) {\r\ninfo->var.width = ch->display.width;\r\ninfo->var.height = ch->display.height;\r\nsh_mobile_lcdc_display_on(ch);\r\n} else {\r\nfb_set_suspend(info, 0);\r\n}\r\nconsole_unlock();\r\nunlock_fb_info(info);\r\n}\r\nbreak;\r\ncase SH_MOBILE_LCDC_EVENT_DISPLAY_DISCONNECT:\r\nif (lock_fb_info(info)) {\r\nconsole_lock();\r\nfb_set_suspend(info, 1);\r\nconsole_unlock();\r\nunlock_fb_info(info);\r\n}\r\nbreak;\r\ncase SH_MOBILE_LCDC_EVENT_DISPLAY_MODE:\r\nfb_videomode_to_var(&var, mode);\r\nvar.bits_per_pixel = info->var.bits_per_pixel;\r\nvar.grayscale = info->var.grayscale;\r\nret = sh_mobile_lcdc_check_var(&var, info);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic const struct sh_mobile_lcdc_format_info *\r\nsh_mobile_format_info(u32 fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(sh_mobile_format_infos); ++i) {\r\nif (sh_mobile_format_infos[i].fourcc == fourcc)\r\nreturn &sh_mobile_format_infos[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic int sh_mobile_format_fourcc(const struct fb_var_screeninfo *var)\r\n{\r\nif (var->grayscale > 1)\r\nreturn var->grayscale;\r\nswitch (var->bits_per_pixel) {\r\ncase 16:\r\nreturn V4L2_PIX_FMT_RGB565;\r\ncase 24:\r\nreturn V4L2_PIX_FMT_BGR24;\r\ncase 32:\r\nreturn V4L2_PIX_FMT_BGR32;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int sh_mobile_format_is_fourcc(const struct fb_var_screeninfo *var)\r\n{\r\nreturn var->grayscale > 1;\r\n}\r\nstatic irqreturn_t sh_mobile_lcdc_irq(int irq, void *data)\r\n{\r\nstruct sh_mobile_lcdc_priv *priv = data;\r\nstruct sh_mobile_lcdc_chan *ch;\r\nunsigned long ldintr;\r\nint is_sub;\r\nint k;\r\nldintr = lcdc_read(priv, _LDINTR);\r\nlcdc_write(priv, _LDINTR, (ldintr ^ LDINTR_STATUS_MASK) & ~LDINTR_VEE);\r\nis_sub = (lcdc_read(priv, _LDSR) & LDSR_MSS) ? 1 : 0;\r\nfor (k = 0; k < ARRAY_SIZE(priv->ch); k++) {\r\nch = &priv->ch[k];\r\nif (!ch->enabled)\r\ncontinue;\r\nif (ldintr & LDINTR_FS) {\r\nif (is_sub == lcdc_chan_is_sublcd(ch)) {\r\nch->frame_end = 1;\r\nwake_up(&ch->frame_end_wait);\r\nsh_mobile_lcdc_clk_off(priv);\r\n}\r\n}\r\nif (ldintr & LDINTR_VES)\r\ncomplete(&ch->vsync_completion);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sh_mobile_lcdc_wait_for_vsync(struct sh_mobile_lcdc_chan *ch)\r\n{\r\nunsigned long ldintr;\r\nint ret;\r\nldintr = lcdc_read(ch->lcdc, _LDINTR);\r\nldintr |= LDINTR_VEE | LDINTR_STATUS_MASK;\r\nlcdc_write(ch->lcdc, _LDINTR, ldintr);\r\nret = wait_for_completion_interruptible_timeout(&ch->vsync_completion,\r\nmsecs_to_jiffies(100));\r\nif (!ret)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic void sh_mobile_lcdc_start_stop(struct sh_mobile_lcdc_priv *priv,\r\nint start)\r\n{\r\nunsigned long tmp = lcdc_read(priv, _LDCNT2R);\r\nint k;\r\nif (start)\r\nlcdc_write(priv, _LDCNT2R, tmp | LDCNT2R_DO);\r\nelse\r\nlcdc_write(priv, _LDCNT2R, tmp & ~LDCNT2R_DO);\r\nfor (k = 0; k < ARRAY_SIZE(priv->ch); k++)\r\nif (lcdc_read(priv, _LDCNT2R) & priv->ch[k].enabled)\r\nwhile (1) {\r\ntmp = lcdc_read_chan(&priv->ch[k], LDPMR)\r\n& LDPMR_LPS;\r\nif (start && tmp == LDPMR_LPS)\r\nbreak;\r\nif (!start && tmp == 0)\r\nbreak;\r\ncpu_relax();\r\n}\r\nif (!start)\r\nlcdc_write(priv, _LDDCKSTPR, 1);\r\n}\r\nstatic void sh_mobile_lcdc_geometry(struct sh_mobile_lcdc_chan *ch)\r\n{\r\nconst struct fb_var_screeninfo *var = &ch->info->var;\r\nconst struct fb_videomode *mode = &ch->display.mode;\r\nunsigned long h_total, hsync_pos, display_h_total;\r\nu32 tmp;\r\ntmp = ch->ldmt1r_value;\r\ntmp |= (var->sync & FB_SYNC_VERT_HIGH_ACT) ? 0 : LDMT1R_VPOL;\r\ntmp |= (var->sync & FB_SYNC_HOR_HIGH_ACT) ? 0 : LDMT1R_HPOL;\r\ntmp |= (ch->cfg->flags & LCDC_FLAGS_DWPOL) ? LDMT1R_DWPOL : 0;\r\ntmp |= (ch->cfg->flags & LCDC_FLAGS_DIPOL) ? LDMT1R_DIPOL : 0;\r\ntmp |= (ch->cfg->flags & LCDC_FLAGS_DAPOL) ? LDMT1R_DAPOL : 0;\r\ntmp |= (ch->cfg->flags & LCDC_FLAGS_HSCNT) ? LDMT1R_HSCNT : 0;\r\ntmp |= (ch->cfg->flags & LCDC_FLAGS_DWCNT) ? LDMT1R_DWCNT : 0;\r\nlcdc_write_chan(ch, LDMT1R, tmp);\r\nlcdc_write_chan(ch, LDMT2R, ch->cfg->sys_bus_cfg.ldmt2r);\r\nlcdc_write_chan(ch, LDMT3R, ch->cfg->sys_bus_cfg.ldmt3r);\r\nh_total = mode->xres + mode->hsync_len + mode->left_margin\r\n+ mode->right_margin;\r\ntmp = h_total / 8;\r\ntmp |= (min(mode->xres, ch->xres) / 8) << 16;\r\nlcdc_write_chan(ch, LDHCNR, tmp);\r\nhsync_pos = mode->xres + mode->right_margin;\r\ntmp = hsync_pos / 8;\r\ntmp |= (mode->hsync_len / 8) << 16;\r\nlcdc_write_chan(ch, LDHSYNR, tmp);\r\ntmp = mode->yres + mode->vsync_len + mode->upper_margin\r\n+ mode->lower_margin;\r\ntmp |= min(mode->yres, ch->yres) << 16;\r\nlcdc_write_chan(ch, LDVLNR, tmp);\r\ntmp = mode->yres + mode->lower_margin;\r\ntmp |= mode->vsync_len << 16;\r\nlcdc_write_chan(ch, LDVSYNR, tmp);\r\ndisplay_h_total = mode->xres + mode->hsync_len + mode->left_margin\r\n+ mode->right_margin;\r\ntmp = ((mode->xres & 7) << 24) | ((display_h_total & 7) << 16)\r\n| ((mode->hsync_len & 7) << 8) | (hsync_pos & 7);\r\nlcdc_write_chan(ch, LDHAJR, tmp);\r\nlcdc_write_chan_mirror(ch, LDHAJR, tmp);\r\n}\r\nstatic void sh_mobile_lcdc_overlay_setup(struct sh_mobile_lcdc_overlay *ovl)\r\n{\r\nu32 format = 0;\r\nif (!ovl->enabled) {\r\nlcdc_write(ovl->channel->lcdc, LDBCR, LDBCR_UPC(ovl->index));\r\nlcdc_write_overlay(ovl, LDBnBSIFR(ovl->index), 0);\r\nlcdc_write(ovl->channel->lcdc, LDBCR,\r\nLDBCR_UPF(ovl->index) | LDBCR_UPD(ovl->index));\r\nreturn;\r\n}\r\novl->base_addr_y = ovl->dma_handle;\r\novl->base_addr_c = ovl->dma_handle\r\n+ ovl->xres_virtual * ovl->yres_virtual;\r\nswitch (ovl->mode) {\r\ncase LCDC_OVERLAY_BLEND:\r\nformat = LDBBSIFR_EN | (ovl->alpha << LDBBSIFR_LAY_SHIFT);\r\nbreak;\r\ncase LCDC_OVERLAY_ROP3:\r\nformat = LDBBSIFR_EN | LDBBSIFR_BRSEL\r\n| (ovl->rop3 << LDBBSIFR_ROP3_SHIFT);\r\nbreak;\r\n}\r\nswitch (ovl->format->fourcc) {\r\ncase V4L2_PIX_FMT_RGB565:\r\ncase V4L2_PIX_FMT_NV21:\r\ncase V4L2_PIX_FMT_NV61:\r\ncase V4L2_PIX_FMT_NV42:\r\nformat |= LDBBSIFR_SWPL | LDBBSIFR_SWPW;\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR24:\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV16:\r\ncase V4L2_PIX_FMT_NV24:\r\nformat |= LDBBSIFR_SWPL | LDBBSIFR_SWPW | LDBBSIFR_SWPB;\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR32:\r\ndefault:\r\nformat |= LDBBSIFR_SWPL;\r\nbreak;\r\n}\r\nswitch (ovl->format->fourcc) {\r\ncase V4L2_PIX_FMT_RGB565:\r\nformat |= LDBBSIFR_AL_1 | LDBBSIFR_RY | LDBBSIFR_RPKF_RGB16;\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR24:\r\nformat |= LDBBSIFR_AL_1 | LDBBSIFR_RY | LDBBSIFR_RPKF_RGB24;\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR32:\r\nformat |= LDBBSIFR_AL_PK | LDBBSIFR_RY | LDDFR_PKF_ARGB32;\r\nbreak;\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV21:\r\nformat |= LDBBSIFR_AL_1 | LDBBSIFR_CHRR_420;\r\nbreak;\r\ncase V4L2_PIX_FMT_NV16:\r\ncase V4L2_PIX_FMT_NV61:\r\nformat |= LDBBSIFR_AL_1 | LDBBSIFR_CHRR_422;\r\nbreak;\r\ncase V4L2_PIX_FMT_NV24:\r\ncase V4L2_PIX_FMT_NV42:\r\nformat |= LDBBSIFR_AL_1 | LDBBSIFR_CHRR_444;\r\nbreak;\r\n}\r\nlcdc_write(ovl->channel->lcdc, LDBCR, LDBCR_UPC(ovl->index));\r\nlcdc_write_overlay(ovl, LDBnBSIFR(ovl->index), format);\r\nlcdc_write_overlay(ovl, LDBnBSSZR(ovl->index),\r\n(ovl->yres << LDBBSSZR_BVSS_SHIFT) |\r\n(ovl->xres << LDBBSSZR_BHSS_SHIFT));\r\nlcdc_write_overlay(ovl, LDBnBLOCR(ovl->index),\r\n(ovl->pos_y << LDBBLOCR_CVLC_SHIFT) |\r\n(ovl->pos_x << LDBBLOCR_CHLC_SHIFT));\r\nlcdc_write_overlay(ovl, LDBnBSMWR(ovl->index),\r\novl->pitch << LDBBSMWR_BSMW_SHIFT);\r\nlcdc_write_overlay(ovl, LDBnBSAYR(ovl->index), ovl->base_addr_y);\r\nlcdc_write_overlay(ovl, LDBnBSACR(ovl->index), ovl->base_addr_c);\r\nlcdc_write(ovl->channel->lcdc, LDBCR,\r\nLDBCR_UPF(ovl->index) | LDBCR_UPD(ovl->index));\r\n}\r\nstatic void __sh_mobile_lcdc_start(struct sh_mobile_lcdc_priv *priv)\r\n{\r\nstruct sh_mobile_lcdc_chan *ch;\r\nunsigned long tmp;\r\nint k, m;\r\nlcdc_write(priv, _LDCNT2R, priv->ch[0].enabled | priv->ch[1].enabled);\r\nsh_mobile_lcdc_start_stop(priv, 0);\r\nlcdc_write(priv, _LDINTR, 0);\r\ntmp = priv->lddckr;\r\nfor (k = 0; k < ARRAY_SIZE(priv->ch); k++) {\r\nch = &priv->ch[k];\r\nif (!ch->enabled)\r\ncontinue;\r\nlcdc_write_chan(ch, LDPMR, 0);\r\nm = ch->cfg->clock_divider;\r\nif (!m)\r\ncontinue;\r\nlcdc_write_chan(ch, LDDCKPAT1R, 0);\r\nlcdc_write_chan(ch, LDDCKPAT2R, (1 << (m/2)) - 1);\r\nif (m == 1)\r\nm = LDDCKR_MOSEL;\r\ntmp |= m << (lcdc_chan_is_sublcd(ch) ? 8 : 0);\r\n}\r\nlcdc_write(priv, _LDDCKR, tmp);\r\nlcdc_write(priv, _LDDCKSTPR, 0);\r\nlcdc_wait_bit(priv, _LDDCKSTPR, ~0, 0);\r\nfor (k = 0; k < ARRAY_SIZE(priv->ch); k++) {\r\nch = &priv->ch[k];\r\nif (!ch->enabled)\r\ncontinue;\r\nsh_mobile_lcdc_geometry(ch);\r\ntmp = ch->format->lddfr;\r\nif (ch->format->yuv) {\r\nswitch (ch->colorspace) {\r\ncase V4L2_COLORSPACE_REC709:\r\ntmp |= LDDFR_CF1;\r\nbreak;\r\ncase V4L2_COLORSPACE_JPEG:\r\ntmp |= LDDFR_CF0;\r\nbreak;\r\n}\r\n}\r\nlcdc_write_chan(ch, LDDFR, tmp);\r\nlcdc_write_chan(ch, LDMLSR, ch->line_size);\r\nlcdc_write_chan(ch, LDSA1R, ch->base_addr_y);\r\nif (ch->format->yuv)\r\nlcdc_write_chan(ch, LDSA2R, ch->base_addr_c);\r\nif (ch->ldmt1r_value & LDMT1R_IFM &&\r\nch->cfg->sys_bus_cfg.deferred_io_msec) {\r\nlcdc_write_chan(ch, LDSM1R, LDSM1R_OS);\r\nlcdc_write(priv, _LDINTR, LDINTR_FE);\r\n} else {\r\nlcdc_write_chan(ch, LDSM1R, 0);\r\n}\r\n}\r\nswitch (priv->ch[0].format->fourcc) {\r\ncase V4L2_PIX_FMT_RGB565:\r\ncase V4L2_PIX_FMT_NV21:\r\ncase V4L2_PIX_FMT_NV61:\r\ncase V4L2_PIX_FMT_NV42:\r\ntmp = LDDDSR_LS | LDDDSR_WS;\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR24:\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV16:\r\ncase V4L2_PIX_FMT_NV24:\r\ntmp = LDDDSR_LS | LDDDSR_WS | LDDDSR_BS;\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR32:\r\ndefault:\r\ntmp = LDDDSR_LS;\r\nbreak;\r\n}\r\nlcdc_write(priv, _LDDDSR, tmp);\r\nlcdc_write(priv, _LDCNT1R, LDCNT1R_DE);\r\nsh_mobile_lcdc_start_stop(priv, 1);\r\npriv->started = 1;\r\n}\r\nstatic int sh_mobile_lcdc_start(struct sh_mobile_lcdc_priv *priv)\r\n{\r\nstruct sh_mobile_meram_info *mdev = priv->meram_dev;\r\nstruct sh_mobile_lcdc_chan *ch;\r\nunsigned long tmp;\r\nint ret;\r\nint k;\r\nfor (k = 0; k < ARRAY_SIZE(priv->ch); k++) {\r\nif (priv->ch[k].enabled)\r\nsh_mobile_lcdc_clk_on(priv);\r\n}\r\nlcdc_write(priv, _LDCNT2R, lcdc_read(priv, _LDCNT2R) | LDCNT2R_BR);\r\nlcdc_wait_bit(priv, _LDCNT2R, LDCNT2R_BR, 0);\r\nfor (k = 0; k < ARRAY_SIZE(priv->ch); k++) {\r\nconst struct sh_mobile_lcdc_panel_cfg *panel;\r\nch = &priv->ch[k];\r\nif (!ch->enabled)\r\ncontinue;\r\npanel = &ch->cfg->panel_cfg;\r\nif (panel->setup_sys) {\r\nret = panel->setup_sys(ch, &sh_mobile_lcdc_sys_bus_ops);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nfor (k = 0; k < ARRAY_SIZE(priv->ch); k++) {\r\nint pixelformat;\r\nvoid *cache;\r\nch = &priv->ch[k];\r\nif (!ch->enabled)\r\ncontinue;\r\nch->base_addr_y = ch->dma_handle;\r\nch->base_addr_c = ch->dma_handle\r\n+ ch->xres_virtual * ch->yres_virtual;\r\nch->line_size = ch->pitch;\r\nif (mdev == NULL || ch->cfg->meram_cfg == NULL)\r\ncontinue;\r\nif (ch->cache) {\r\nsh_mobile_meram_cache_free(mdev, ch->cache);\r\nch->cache = NULL;\r\n}\r\nswitch (ch->format->fourcc) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV21:\r\ncase V4L2_PIX_FMT_NV16:\r\ncase V4L2_PIX_FMT_NV61:\r\npixelformat = SH_MOBILE_MERAM_PF_NV;\r\nbreak;\r\ncase V4L2_PIX_FMT_NV24:\r\ncase V4L2_PIX_FMT_NV42:\r\npixelformat = SH_MOBILE_MERAM_PF_NV24;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\ncase V4L2_PIX_FMT_BGR24:\r\ncase V4L2_PIX_FMT_BGR32:\r\ndefault:\r\npixelformat = SH_MOBILE_MERAM_PF_RGB;\r\nbreak;\r\n}\r\ncache = sh_mobile_meram_cache_alloc(mdev, ch->cfg->meram_cfg,\r\nch->pitch, ch->yres, pixelformat,\r\n&ch->line_size);\r\nif (!IS_ERR(cache)) {\r\nsh_mobile_meram_cache_update(mdev, cache,\r\nch->base_addr_y, ch->base_addr_c,\r\n&ch->base_addr_y, &ch->base_addr_c);\r\nch->cache = cache;\r\n}\r\n}\r\nfor (k = 0; k < ARRAY_SIZE(priv->overlays); ++k) {\r\nstruct sh_mobile_lcdc_overlay *ovl = &priv->overlays[k];\r\nsh_mobile_lcdc_overlay_setup(ovl);\r\n}\r\n__sh_mobile_lcdc_start(priv);\r\nfor (k = 0; k < ARRAY_SIZE(priv->ch); k++) {\r\nch = &priv->ch[k];\r\nif (!ch->enabled)\r\ncontinue;\r\ntmp = ch->cfg->sys_bus_cfg.deferred_io_msec;\r\nif (ch->ldmt1r_value & LDMT1R_IFM && tmp) {\r\nch->defio.deferred_io = sh_mobile_lcdc_deferred_io;\r\nch->defio.delay = msecs_to_jiffies(tmp);\r\nch->info->fbdefio = &ch->defio;\r\nfb_deferred_io_init(ch->info);\r\n}\r\nsh_mobile_lcdc_display_on(ch);\r\nif (ch->bl) {\r\nch->bl->props.power = FB_BLANK_UNBLANK;\r\nbacklight_update_status(ch->bl);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void sh_mobile_lcdc_stop(struct sh_mobile_lcdc_priv *priv)\r\n{\r\nstruct sh_mobile_lcdc_chan *ch;\r\nint k;\r\nfor (k = 0; k < ARRAY_SIZE(priv->ch); k++) {\r\nch = &priv->ch[k];\r\nif (!ch->enabled)\r\ncontinue;\r\nif (ch->info && ch->info->fbdefio) {\r\nch->frame_end = 0;\r\nschedule_delayed_work(&ch->info->deferred_work, 0);\r\nwait_event(ch->frame_end_wait, ch->frame_end);\r\nfb_deferred_io_cleanup(ch->info);\r\nch->info->fbdefio = NULL;\r\nsh_mobile_lcdc_clk_on(priv);\r\n}\r\nif (ch->bl) {\r\nch->bl->props.power = FB_BLANK_POWERDOWN;\r\nbacklight_update_status(ch->bl);\r\n}\r\nsh_mobile_lcdc_display_off(ch);\r\nif (ch->cache) {\r\nsh_mobile_meram_cache_free(priv->meram_dev, ch->cache);\r\nch->cache = 0;\r\n}\r\n}\r\nif (priv->started) {\r\nsh_mobile_lcdc_start_stop(priv, 0);\r\npriv->started = 0;\r\n}\r\nfor (k = 0; k < ARRAY_SIZE(priv->ch); k++)\r\nif (priv->ch[k].enabled)\r\nsh_mobile_lcdc_clk_off(priv);\r\n}\r\nstatic int __sh_mobile_lcdc_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nif (var->xres > MAX_XRES || var->yres > MAX_YRES)\r\nreturn -EINVAL;\r\nif (var->xres_virtual < var->xres)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres_virtual < var->yres)\r\nvar->yres_virtual = var->yres;\r\nif (sh_mobile_format_is_fourcc(var)) {\r\nconst struct sh_mobile_lcdc_format_info *format;\r\nformat = sh_mobile_format_info(var->grayscale);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nvar->bits_per_pixel = format->bpp;\r\nif (!format->yuv)\r\nvar->colorspace = V4L2_COLORSPACE_SRGB;\r\nelse if (var->colorspace != V4L2_COLORSPACE_REC709)\r\nvar->colorspace = V4L2_COLORSPACE_JPEG;\r\n} else {\r\nif (var->bits_per_pixel <= 16) {\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\n} else if (var->bits_per_pixel <= 24) {\r\nvar->bits_per_pixel = 24;\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\n} else if (var->bits_per_pixel <= 32) {\r\nvar->bits_per_pixel = 32;\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\n} else\r\nreturn -EINVAL;\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.msb_right = 0;\r\n}\r\nif (var->xres_virtual * var->yres_virtual * var->bits_per_pixel / 8 >\r\ninfo->fix.smem_len)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\noverlay_alpha_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct sh_mobile_lcdc_overlay *ovl = info->par;\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", ovl->alpha);\r\n}\r\nstatic ssize_t\r\noverlay_alpha_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct sh_mobile_lcdc_overlay *ovl = info->par;\r\nunsigned int alpha;\r\nchar *endp;\r\nalpha = simple_strtoul(buf, &endp, 10);\r\nif (isspace(*endp))\r\nendp++;\r\nif (endp - buf != count)\r\nreturn -EINVAL;\r\nif (alpha > 255)\r\nreturn -EINVAL;\r\nif (ovl->alpha != alpha) {\r\novl->alpha = alpha;\r\nif (ovl->mode == LCDC_OVERLAY_BLEND && ovl->enabled)\r\nsh_mobile_lcdc_overlay_setup(ovl);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\noverlay_mode_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct sh_mobile_lcdc_overlay *ovl = info->par;\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", ovl->mode);\r\n}\r\nstatic ssize_t\r\noverlay_mode_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct sh_mobile_lcdc_overlay *ovl = info->par;\r\nunsigned int mode;\r\nchar *endp;\r\nmode = simple_strtoul(buf, &endp, 10);\r\nif (isspace(*endp))\r\nendp++;\r\nif (endp - buf != count)\r\nreturn -EINVAL;\r\nif (mode != LCDC_OVERLAY_BLEND && mode != LCDC_OVERLAY_ROP3)\r\nreturn -EINVAL;\r\nif (ovl->mode != mode) {\r\novl->mode = mode;\r\nif (ovl->enabled)\r\nsh_mobile_lcdc_overlay_setup(ovl);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\noverlay_position_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct sh_mobile_lcdc_overlay *ovl = info->par;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d,%d\n", ovl->pos_x, ovl->pos_y);\r\n}\r\nstatic ssize_t\r\noverlay_position_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct sh_mobile_lcdc_overlay *ovl = info->par;\r\nchar *endp;\r\nint pos_x;\r\nint pos_y;\r\npos_x = simple_strtol(buf, &endp, 10);\r\nif (*endp != ',')\r\nreturn -EINVAL;\r\npos_y = simple_strtol(endp + 1, &endp, 10);\r\nif (isspace(*endp))\r\nendp++;\r\nif (endp - buf != count)\r\nreturn -EINVAL;\r\nif (ovl->pos_x != pos_x || ovl->pos_y != pos_y) {\r\novl->pos_x = pos_x;\r\novl->pos_y = pos_y;\r\nif (ovl->enabled)\r\nsh_mobile_lcdc_overlay_setup(ovl);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\noverlay_rop3_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct sh_mobile_lcdc_overlay *ovl = info->par;\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", ovl->rop3);\r\n}\r\nstatic ssize_t\r\noverlay_rop3_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct sh_mobile_lcdc_overlay *ovl = info->par;\r\nunsigned int rop3;\r\nchar *endp;\r\nrop3 = !!simple_strtoul(buf, &endp, 10);\r\nif (isspace(*endp))\r\nendp++;\r\nif (endp - buf != count)\r\nreturn -EINVAL;\r\nif (rop3 > 255)\r\nreturn -EINVAL;\r\nif (ovl->rop3 != rop3) {\r\novl->rop3 = rop3;\r\nif (ovl->mode == LCDC_OVERLAY_ROP3 && ovl->enabled)\r\nsh_mobile_lcdc_overlay_setup(ovl);\r\n}\r\nreturn count;\r\n}\r\nstatic int sh_mobile_lcdc_overlay_pan(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct sh_mobile_lcdc_overlay *ovl = info->par;\r\nunsigned long base_addr_y;\r\nunsigned long base_addr_c;\r\nunsigned long y_offset;\r\nunsigned long c_offset;\r\nif (!ovl->format->yuv) {\r\ny_offset = (var->yoffset * ovl->xres_virtual + var->xoffset)\r\n* ovl->format->bpp / 8;\r\nc_offset = 0;\r\n} else {\r\nunsigned int xsub = ovl->format->bpp < 24 ? 2 : 1;\r\nunsigned int ysub = ovl->format->bpp < 16 ? 2 : 1;\r\ny_offset = var->yoffset * ovl->xres_virtual + var->xoffset;\r\nc_offset = var->yoffset / ysub * ovl->xres_virtual * 2 / xsub\r\n+ var->xoffset * 2 / xsub;\r\n}\r\nif (y_offset == ovl->pan_y_offset)\r\nreturn 0;\r\nbase_addr_y = ovl->dma_handle + y_offset;\r\nbase_addr_c = ovl->dma_handle + ovl->xres_virtual * ovl->yres_virtual\r\n+ c_offset;\r\novl->base_addr_y = base_addr_y;\r\novl->base_addr_c = base_addr_c;\r\novl->pan_y_offset = y_offset;\r\nlcdc_write(ovl->channel->lcdc, LDBCR, LDBCR_UPC(ovl->index));\r\nlcdc_write_overlay(ovl, LDBnBSAYR(ovl->index), ovl->base_addr_y);\r\nlcdc_write_overlay(ovl, LDBnBSACR(ovl->index), ovl->base_addr_c);\r\nlcdc_write(ovl->channel->lcdc, LDBCR,\r\nLDBCR_UPF(ovl->index) | LDBCR_UPD(ovl->index));\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_lcdc_overlay_ioctl(struct fb_info *info, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct sh_mobile_lcdc_overlay *ovl = info->par;\r\nswitch (cmd) {\r\ncase FBIO_WAITFORVSYNC:\r\nreturn sh_mobile_lcdc_wait_for_vsync(ovl->channel);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic int sh_mobile_lcdc_overlay_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nreturn __sh_mobile_lcdc_check_var(var, info);\r\n}\r\nstatic int sh_mobile_lcdc_overlay_set_par(struct fb_info *info)\r\n{\r\nstruct sh_mobile_lcdc_overlay *ovl = info->par;\r\novl->format =\r\nsh_mobile_format_info(sh_mobile_format_fourcc(&info->var));\r\novl->xres = info->var.xres;\r\novl->xres_virtual = info->var.xres_virtual;\r\novl->yres = info->var.yres;\r\novl->yres_virtual = info->var.yres_virtual;\r\nif (ovl->format->yuv)\r\novl->pitch = info->var.xres_virtual;\r\nelse\r\novl->pitch = info->var.xres_virtual * ovl->format->bpp / 8;\r\nsh_mobile_lcdc_overlay_setup(ovl);\r\ninfo->fix.line_length = ovl->pitch;\r\nif (sh_mobile_format_is_fourcc(&info->var)) {\r\ninfo->fix.type = FB_TYPE_FOURCC;\r\ninfo->fix.visual = FB_VISUAL_FOURCC;\r\n} else {\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_lcdc_overlay_blank(int blank, struct fb_info *info)\r\n{\r\nstruct sh_mobile_lcdc_overlay *ovl = info->par;\r\novl->enabled = !blank;\r\nsh_mobile_lcdc_overlay_setup(ovl);\r\nreturn 1;\r\n}\r\nstatic int\r\nsh_mobile_lcdc_overlay_mmap(struct fb_info *info, struct vm_area_struct *vma)\r\n{\r\nstruct sh_mobile_lcdc_overlay *ovl = info->par;\r\nreturn dma_mmap_coherent(ovl->channel->lcdc->dev, vma, ovl->fb_mem,\r\novl->dma_handle, ovl->fb_size);\r\n}\r\nstatic void\r\nsh_mobile_lcdc_overlay_fb_unregister(struct sh_mobile_lcdc_overlay *ovl)\r\n{\r\nstruct fb_info *info = ovl->info;\r\nif (info == NULL || info->dev == NULL)\r\nreturn;\r\nunregister_framebuffer(ovl->info);\r\n}\r\nstatic int\r\nsh_mobile_lcdc_overlay_fb_register(struct sh_mobile_lcdc_overlay *ovl)\r\n{\r\nstruct sh_mobile_lcdc_priv *lcdc = ovl->channel->lcdc;\r\nstruct fb_info *info = ovl->info;\r\nunsigned int i;\r\nint ret;\r\nif (info == NULL)\r\nreturn 0;\r\nret = register_framebuffer(info);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_info(lcdc->dev, "registered %s/overlay %u as %dx%d %dbpp.\n",\r\ndev_name(lcdc->dev), ovl->index, info->var.xres,\r\ninfo->var.yres, info->var.bits_per_pixel);\r\nfor (i = 0; i < ARRAY_SIZE(overlay_sysfs_attrs); ++i) {\r\nret = device_create_file(info->dev, &overlay_sysfs_attrs[i]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nsh_mobile_lcdc_overlay_fb_cleanup(struct sh_mobile_lcdc_overlay *ovl)\r\n{\r\nstruct fb_info *info = ovl->info;\r\nif (info == NULL || info->device == NULL)\r\nreturn;\r\nframebuffer_release(info);\r\n}\r\nstatic int\r\nsh_mobile_lcdc_overlay_fb_init(struct sh_mobile_lcdc_overlay *ovl)\r\n{\r\nstruct sh_mobile_lcdc_priv *priv = ovl->channel->lcdc;\r\nstruct fb_var_screeninfo *var;\r\nstruct fb_info *info;\r\ninfo = framebuffer_alloc(0, priv->dev);\r\nif (info == NULL) {\r\ndev_err(priv->dev, "unable to allocate fb_info\n");\r\nreturn -ENOMEM;\r\n}\r\novl->info = info;\r\ninfo->flags = FBINFO_FLAG_DEFAULT;\r\ninfo->fbops = &sh_mobile_lcdc_overlay_ops;\r\ninfo->device = priv->dev;\r\ninfo->screen_base = ovl->fb_mem;\r\ninfo->par = ovl;\r\ninfo->fix = sh_mobile_lcdc_overlay_fix;\r\nsnprintf(info->fix.id, sizeof(info->fix.id),\r\n"SH Mobile LCDC Overlay %u", ovl->index);\r\ninfo->fix.smem_start = ovl->dma_handle;\r\ninfo->fix.smem_len = ovl->fb_size;\r\ninfo->fix.line_length = ovl->pitch;\r\nif (ovl->format->yuv)\r\ninfo->fix.visual = FB_VISUAL_FOURCC;\r\nelse\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nswitch (ovl->format->fourcc) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV21:\r\ninfo->fix.ypanstep = 2;\r\ncase V4L2_PIX_FMT_NV16:\r\ncase V4L2_PIX_FMT_NV61:\r\ninfo->fix.xpanstep = 2;\r\n}\r\nvar = &info->var;\r\nmemset(var, 0, sizeof(*var));\r\nvar->xres = ovl->xres;\r\nvar->yres = ovl->yres;\r\nvar->xres_virtual = ovl->xres_virtual;\r\nvar->yres_virtual = ovl->yres_virtual;\r\nvar->activate = FB_ACTIVATE_NOW;\r\nif (!ovl->format->yuv)\r\nvar->bits_per_pixel = ovl->format->bpp;\r\nelse\r\nvar->grayscale = ovl->format->fourcc;\r\nreturn sh_mobile_lcdc_overlay_check_var(var, info);\r\n}\r\nstatic int sh_mobile_lcdc_setcolreg(u_int regno,\r\nu_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nu32 *palette = info->pseudo_palette;\r\nif (regno >= PALETTE_NR)\r\nreturn -EINVAL;\r\nred >>= 16 - info->var.red.length;\r\ngreen >>= 16 - info->var.green.length;\r\nblue >>= 16 - info->var.blue.length;\r\ntransp >>= 16 - info->var.transp.length;\r\npalette[regno] = (red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset) |\r\n(transp << info->var.transp.offset);\r\nreturn 0;\r\n}\r\nstatic void sh_mobile_lcdc_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *rect)\r\n{\r\nsys_fillrect(info, rect);\r\nsh_mobile_lcdc_deferred_io_touch(info);\r\n}\r\nstatic void sh_mobile_lcdc_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nsys_copyarea(info, area);\r\nsh_mobile_lcdc_deferred_io_touch(info);\r\n}\r\nstatic void sh_mobile_lcdc_imageblit(struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nsys_imageblit(info, image);\r\nsh_mobile_lcdc_deferred_io_touch(info);\r\n}\r\nstatic int sh_mobile_lcdc_pan(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct sh_mobile_lcdc_chan *ch = info->par;\r\nstruct sh_mobile_lcdc_priv *priv = ch->lcdc;\r\nunsigned long ldrcntr;\r\nunsigned long base_addr_y, base_addr_c;\r\nunsigned long y_offset;\r\nunsigned long c_offset;\r\nif (!ch->format->yuv) {\r\ny_offset = (var->yoffset * ch->xres_virtual + var->xoffset)\r\n* ch->format->bpp / 8;\r\nc_offset = 0;\r\n} else {\r\nunsigned int xsub = ch->format->bpp < 24 ? 2 : 1;\r\nunsigned int ysub = ch->format->bpp < 16 ? 2 : 1;\r\ny_offset = var->yoffset * ch->xres_virtual + var->xoffset;\r\nc_offset = var->yoffset / ysub * ch->xres_virtual * 2 / xsub\r\n+ var->xoffset * 2 / xsub;\r\n}\r\nif (y_offset == ch->pan_y_offset)\r\nreturn 0;\r\nbase_addr_y = ch->dma_handle + y_offset;\r\nbase_addr_c = ch->dma_handle + ch->xres_virtual * ch->yres_virtual\r\n+ c_offset;\r\nif (ch->cache)\r\nsh_mobile_meram_cache_update(priv->meram_dev, ch->cache,\r\nbase_addr_y, base_addr_c,\r\n&base_addr_y, &base_addr_c);\r\nch->base_addr_y = base_addr_y;\r\nch->base_addr_c = base_addr_c;\r\nch->pan_y_offset = y_offset;\r\nlcdc_write_chan_mirror(ch, LDSA1R, base_addr_y);\r\nif (ch->format->yuv)\r\nlcdc_write_chan_mirror(ch, LDSA2R, base_addr_c);\r\nldrcntr = lcdc_read(priv, _LDRCNTR);\r\nif (lcdc_chan_is_sublcd(ch))\r\nlcdc_write(ch->lcdc, _LDRCNTR, ldrcntr ^ LDRCNTR_SRS);\r\nelse\r\nlcdc_write(ch->lcdc, _LDRCNTR, ldrcntr ^ LDRCNTR_MRS);\r\nsh_mobile_lcdc_deferred_io_touch(info);\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_lcdc_ioctl(struct fb_info *info, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct sh_mobile_lcdc_chan *ch = info->par;\r\nint retval;\r\nswitch (cmd) {\r\ncase FBIO_WAITFORVSYNC:\r\nretval = sh_mobile_lcdc_wait_for_vsync(ch);\r\nbreak;\r\ndefault:\r\nretval = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic void sh_mobile_fb_reconfig(struct fb_info *info)\r\n{\r\nstruct sh_mobile_lcdc_chan *ch = info->par;\r\nstruct fb_var_screeninfo var;\r\nstruct fb_videomode mode;\r\nstruct fb_event event;\r\nint evnt = FB_EVENT_MODE_CHANGE_ALL;\r\nif (ch->use_count > 1 || (ch->use_count == 1 && !info->fbcon_par))\r\nreturn;\r\nfb_var_to_videomode(&mode, &info->var);\r\nif (fb_mode_is_equal(&ch->display.mode, &mode))\r\nreturn;\r\nvar = info->var;\r\nfb_videomode_to_var(&var, &ch->display.mode);\r\nvar.width = ch->display.width;\r\nvar.height = ch->display.height;\r\nvar.activate = FB_ACTIVATE_NOW;\r\nif (fb_set_var(info, &var) < 0)\r\nreturn;\r\nevent.info = info;\r\nevent.data = &ch->display.mode;\r\nfb_notifier_call_chain(evnt, &event);\r\n}\r\nstatic int sh_mobile_lcdc_release(struct fb_info *info, int user)\r\n{\r\nstruct sh_mobile_lcdc_chan *ch = info->par;\r\nmutex_lock(&ch->open_lock);\r\ndev_dbg(info->dev, "%s(): %d users\n", __func__, ch->use_count);\r\nch->use_count--;\r\nif (user) {\r\nconsole_lock();\r\nsh_mobile_fb_reconfig(info);\r\nconsole_unlock();\r\n}\r\nmutex_unlock(&ch->open_lock);\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_lcdc_open(struct fb_info *info, int user)\r\n{\r\nstruct sh_mobile_lcdc_chan *ch = info->par;\r\nmutex_lock(&ch->open_lock);\r\nch->use_count++;\r\ndev_dbg(info->dev, "%s(): %d users\n", __func__, ch->use_count);\r\nmutex_unlock(&ch->open_lock);\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_lcdc_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct sh_mobile_lcdc_chan *ch = info->par;\r\nstruct sh_mobile_lcdc_priv *p = ch->lcdc;\r\nunsigned int best_dist = (unsigned int)-1;\r\nunsigned int best_xres = 0;\r\nunsigned int best_yres = 0;\r\nunsigned int i;\r\nint ret;\r\nfor (i = 0; i < ch->cfg->num_modes; ++i) {\r\nconst struct fb_videomode *mode = &ch->cfg->lcd_modes[i];\r\nunsigned int dist;\r\nif (var->xres > mode->xres || var->yres > mode->yres)\r\ncontinue;\r\ndist = var->xres * var->yres + mode->xres * mode->yres\r\n- 2 * min(var->xres, mode->xres)\r\n* min(var->yres, mode->yres);\r\nif (dist < best_dist) {\r\nbest_xres = mode->xres;\r\nbest_yres = mode->yres;\r\nbest_dist = dist;\r\n}\r\n}\r\nif (ch->cfg->num_modes != 0) {\r\nif (best_dist == (unsigned int)-1)\r\nreturn -EINVAL;\r\nvar->xres = best_xres;\r\nvar->yres = best_yres;\r\n}\r\nret = __sh_mobile_lcdc_check_var(var, info);\r\nif (ret < 0)\r\nreturn ret;\r\nif (p->forced_fourcc &&\r\np->forced_fourcc != sh_mobile_format_fourcc(var))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_lcdc_set_par(struct fb_info *info)\r\n{\r\nstruct sh_mobile_lcdc_chan *ch = info->par;\r\nint ret;\r\nsh_mobile_lcdc_stop(ch->lcdc);\r\nch->format = sh_mobile_format_info(sh_mobile_format_fourcc(&info->var));\r\nch->colorspace = info->var.colorspace;\r\nch->xres = info->var.xres;\r\nch->xres_virtual = info->var.xres_virtual;\r\nch->yres = info->var.yres;\r\nch->yres_virtual = info->var.yres_virtual;\r\nif (ch->format->yuv)\r\nch->pitch = info->var.xres_virtual;\r\nelse\r\nch->pitch = info->var.xres_virtual * ch->format->bpp / 8;\r\nret = sh_mobile_lcdc_start(ch->lcdc);\r\nif (ret < 0)\r\ndev_err(info->dev, "%s: unable to restart LCDC\n", __func__);\r\ninfo->fix.line_length = ch->pitch;\r\nif (sh_mobile_format_is_fourcc(&info->var)) {\r\ninfo->fix.type = FB_TYPE_FOURCC;\r\ninfo->fix.visual = FB_VISUAL_FOURCC;\r\n} else {\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sh_mobile_lcdc_blank(int blank, struct fb_info *info)\r\n{\r\nstruct sh_mobile_lcdc_chan *ch = info->par;\r\nstruct sh_mobile_lcdc_priv *p = ch->lcdc;\r\nif (blank > FB_BLANK_UNBLANK && ch->blank_status == FB_BLANK_UNBLANK) {\r\nstruct fb_fillrect rect = {\r\n.width = ch->xres,\r\n.height = ch->yres,\r\n};\r\nsh_mobile_lcdc_fillrect(info, &rect);\r\n}\r\nif (blank <= FB_BLANK_NORMAL && ch->blank_status > FB_BLANK_NORMAL) {\r\nsh_mobile_lcdc_clk_on(p);\r\n}\r\nif (blank > FB_BLANK_NORMAL && ch->blank_status <= FB_BLANK_NORMAL) {\r\nif (!info->fbdefio) {\r\nsh_mobile_lcdc_wait_for_vsync(ch);\r\nsh_mobile_lcdc_wait_for_vsync(ch);\r\n}\r\nsh_mobile_lcdc_clk_off(p);\r\n}\r\nch->blank_status = blank;\r\nreturn 0;\r\n}\r\nstatic int\r\nsh_mobile_lcdc_mmap(struct fb_info *info, struct vm_area_struct *vma)\r\n{\r\nstruct sh_mobile_lcdc_chan *ch = info->par;\r\nreturn dma_mmap_coherent(ch->lcdc->dev, vma, ch->fb_mem,\r\nch->dma_handle, ch->fb_size);\r\n}\r\nstatic void\r\nsh_mobile_lcdc_channel_fb_unregister(struct sh_mobile_lcdc_chan *ch)\r\n{\r\nif (ch->info && ch->info->dev)\r\nunregister_framebuffer(ch->info);\r\n}\r\nstatic int\r\nsh_mobile_lcdc_channel_fb_register(struct sh_mobile_lcdc_chan *ch)\r\n{\r\nstruct fb_info *info = ch->info;\r\nint ret;\r\nif (info->fbdefio) {\r\nch->sglist = vmalloc(sizeof(struct scatterlist) *\r\nch->fb_size >> PAGE_SHIFT);\r\nif (!ch->sglist) {\r\ndev_err(ch->lcdc->dev, "cannot allocate sglist\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\ninfo->bl_dev = ch->bl;\r\nret = register_framebuffer(info);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_info(ch->lcdc->dev, "registered %s/%s as %dx%d %dbpp.\n",\r\ndev_name(ch->lcdc->dev), (ch->cfg->chan == LCDC_CHAN_MAINLCD) ?\r\n"mainlcd" : "sublcd", info->var.xres, info->var.yres,\r\ninfo->var.bits_per_pixel);\r\nif (info->fbdefio || info->state == FBINFO_STATE_SUSPENDED)\r\nsh_mobile_lcdc_clk_off(ch->lcdc);\r\nreturn ret;\r\n}\r\nstatic void\r\nsh_mobile_lcdc_channel_fb_cleanup(struct sh_mobile_lcdc_chan *ch)\r\n{\r\nstruct fb_info *info = ch->info;\r\nif (!info || !info->device)\r\nreturn;\r\nif (ch->sglist)\r\nvfree(ch->sglist);\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\nstatic int\r\nsh_mobile_lcdc_channel_fb_init(struct sh_mobile_lcdc_chan *ch,\r\nconst struct fb_videomode *modes,\r\nunsigned int num_modes)\r\n{\r\nstruct sh_mobile_lcdc_priv *priv = ch->lcdc;\r\nstruct fb_var_screeninfo *var;\r\nstruct fb_info *info;\r\nint ret;\r\ninfo = framebuffer_alloc(0, priv->dev);\r\nif (info == NULL) {\r\ndev_err(priv->dev, "unable to allocate fb_info\n");\r\nreturn -ENOMEM;\r\n}\r\nch->info = info;\r\ninfo->flags = FBINFO_FLAG_DEFAULT;\r\ninfo->fbops = &sh_mobile_lcdc_ops;\r\ninfo->device = priv->dev;\r\ninfo->screen_base = ch->fb_mem;\r\ninfo->pseudo_palette = &ch->pseudo_palette;\r\ninfo->par = ch;\r\nfb_videomode_to_modelist(modes, num_modes, &info->modelist);\r\nret = fb_alloc_cmap(&info->cmap, PALETTE_NR, 0);\r\nif (ret < 0) {\r\ndev_err(priv->dev, "unable to allocate cmap\n");\r\nreturn ret;\r\n}\r\ninfo->fix = sh_mobile_lcdc_fix;\r\ninfo->fix.smem_start = ch->dma_handle;\r\ninfo->fix.smem_len = ch->fb_size;\r\ninfo->fix.line_length = ch->pitch;\r\nif (ch->format->yuv)\r\ninfo->fix.visual = FB_VISUAL_FOURCC;\r\nelse\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nswitch (ch->format->fourcc) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV21:\r\ninfo->fix.ypanstep = 2;\r\ncase V4L2_PIX_FMT_NV16:\r\ncase V4L2_PIX_FMT_NV61:\r\ninfo->fix.xpanstep = 2;\r\n}\r\nvar = &info->var;\r\nfb_videomode_to_var(var, modes);\r\nvar->width = ch->display.width;\r\nvar->height = ch->display.height;\r\nvar->xres_virtual = ch->xres_virtual;\r\nvar->yres_virtual = ch->yres_virtual;\r\nvar->activate = FB_ACTIVATE_NOW;\r\nif (!ch->format->yuv)\r\nvar->bits_per_pixel = ch->format->bpp;\r\nelse\r\nvar->grayscale = ch->format->fourcc;\r\nret = sh_mobile_lcdc_check_var(var, info);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_lcdc_update_bl(struct backlight_device *bdev)\r\n{\r\nstruct sh_mobile_lcdc_chan *ch = bl_get_data(bdev);\r\nint brightness = bdev->props.brightness;\r\nif (bdev->props.power != FB_BLANK_UNBLANK ||\r\nbdev->props.state & (BL_CORE_SUSPENDED | BL_CORE_FBBLANK))\r\nbrightness = 0;\r\nch->bl_brightness = brightness;\r\nreturn ch->cfg->bl_info.set_brightness(brightness);\r\n}\r\nstatic int sh_mobile_lcdc_get_brightness(struct backlight_device *bdev)\r\n{\r\nstruct sh_mobile_lcdc_chan *ch = bl_get_data(bdev);\r\nreturn ch->bl_brightness;\r\n}\r\nstatic int sh_mobile_lcdc_check_fb(struct backlight_device *bdev,\r\nstruct fb_info *info)\r\n{\r\nreturn (info->bl_dev == bdev);\r\n}\r\nstatic struct backlight_device *sh_mobile_lcdc_bl_probe(struct device *parent,\r\nstruct sh_mobile_lcdc_chan *ch)\r\n{\r\nstruct backlight_device *bl;\r\nbl = backlight_device_register(ch->cfg->bl_info.name, parent, ch,\r\n&sh_mobile_lcdc_bl_ops, NULL);\r\nif (IS_ERR(bl)) {\r\ndev_err(parent, "unable to register backlight device: %ld\n",\r\nPTR_ERR(bl));\r\nreturn NULL;\r\n}\r\nbl->props.max_brightness = ch->cfg->bl_info.max_brightness;\r\nbl->props.brightness = bl->props.max_brightness;\r\nbacklight_update_status(bl);\r\nreturn bl;\r\n}\r\nstatic void sh_mobile_lcdc_bl_remove(struct backlight_device *bdev)\r\n{\r\nbacklight_device_unregister(bdev);\r\n}\r\nstatic int sh_mobile_lcdc_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nsh_mobile_lcdc_stop(platform_get_drvdata(pdev));\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_lcdc_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nreturn sh_mobile_lcdc_start(platform_get_drvdata(pdev));\r\n}\r\nstatic int sh_mobile_lcdc_runtime_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct sh_mobile_lcdc_priv *priv = platform_get_drvdata(pdev);\r\nlcdc_write(priv, _LDCNT1R, 0);\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_lcdc_runtime_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct sh_mobile_lcdc_priv *priv = platform_get_drvdata(pdev);\r\n__sh_mobile_lcdc_start(priv);\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_lcdc_notify(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct fb_event *event = data;\r\nstruct fb_info *info = event->info;\r\nstruct sh_mobile_lcdc_chan *ch = info->par;\r\nif (&ch->lcdc->notifier != nb)\r\nreturn NOTIFY_DONE;\r\ndev_dbg(info->dev, "%s(): action = %lu, data = %p\n",\r\n__func__, action, event->data);\r\nswitch(action) {\r\ncase FB_EVENT_SUSPEND:\r\nsh_mobile_lcdc_display_off(ch);\r\nsh_mobile_lcdc_stop(ch->lcdc);\r\nbreak;\r\ncase FB_EVENT_RESUME:\r\nmutex_lock(&ch->open_lock);\r\nsh_mobile_fb_reconfig(info);\r\nmutex_unlock(&ch->open_lock);\r\nsh_mobile_lcdc_display_on(ch);\r\nsh_mobile_lcdc_start(ch->lcdc);\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int sh_mobile_lcdc_remove(struct platform_device *pdev)\r\n{\r\nstruct sh_mobile_lcdc_priv *priv = platform_get_drvdata(pdev);\r\nunsigned int i;\r\nfb_unregister_client(&priv->notifier);\r\nfor (i = 0; i < ARRAY_SIZE(priv->overlays); i++)\r\nsh_mobile_lcdc_overlay_fb_unregister(&priv->overlays[i]);\r\nfor (i = 0; i < ARRAY_SIZE(priv->ch); i++)\r\nsh_mobile_lcdc_channel_fb_unregister(&priv->ch[i]);\r\nsh_mobile_lcdc_stop(priv);\r\nfor (i = 0; i < ARRAY_SIZE(priv->overlays); i++) {\r\nstruct sh_mobile_lcdc_overlay *ovl = &priv->overlays[i];\r\nsh_mobile_lcdc_overlay_fb_cleanup(ovl);\r\nif (ovl->fb_mem)\r\ndma_free_coherent(&pdev->dev, ovl->fb_size,\r\novl->fb_mem, ovl->dma_handle);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(priv->ch); i++) {\r\nstruct sh_mobile_lcdc_chan *ch = &priv->ch[i];\r\nif (ch->tx_dev) {\r\nch->tx_dev->lcdc = NULL;\r\nmodule_put(ch->cfg->tx_dev->dev.driver->owner);\r\n}\r\nsh_mobile_lcdc_channel_fb_cleanup(ch);\r\nif (ch->fb_mem)\r\ndma_free_coherent(&pdev->dev, ch->fb_size,\r\nch->fb_mem, ch->dma_handle);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(priv->ch); i++) {\r\nstruct sh_mobile_lcdc_chan *ch = &priv->ch[i];\r\nif (ch->bl)\r\nsh_mobile_lcdc_bl_remove(ch->bl);\r\nmutex_destroy(&ch->open_lock);\r\n}\r\nif (priv->dot_clk) {\r\npm_runtime_disable(&pdev->dev);\r\nclk_put(priv->dot_clk);\r\n}\r\nif (priv->base)\r\niounmap(priv->base);\r\nif (priv->irq)\r\nfree_irq(priv->irq, priv);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_lcdc_check_interface(struct sh_mobile_lcdc_chan *ch)\r\n{\r\nint interface_type = ch->cfg->interface_type;\r\nswitch (interface_type) {\r\ncase RGB8:\r\ncase RGB9:\r\ncase RGB12A:\r\ncase RGB12B:\r\ncase RGB16:\r\ncase RGB18:\r\ncase RGB24:\r\ncase SYS8A:\r\ncase SYS8B:\r\ncase SYS8C:\r\ncase SYS8D:\r\ncase SYS9:\r\ncase SYS12:\r\ncase SYS16A:\r\ncase SYS16B:\r\ncase SYS16C:\r\ncase SYS18:\r\ncase SYS24:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (lcdc_chan_is_sublcd(ch)) {\r\nif (!(interface_type & LDMT1R_IFM))\r\nreturn -EINVAL;\r\ninterface_type &= ~LDMT1R_IFM;\r\n}\r\nch->ldmt1r_value = interface_type;\r\nreturn 0;\r\n}\r\nstatic int\r\nsh_mobile_lcdc_overlay_init(struct sh_mobile_lcdc_overlay *ovl)\r\n{\r\nconst struct sh_mobile_lcdc_format_info *format;\r\nstruct device *dev = ovl->channel->lcdc->dev;\r\nint ret;\r\nif (ovl->cfg->fourcc == 0)\r\nreturn 0;\r\nformat = sh_mobile_format_info(ovl->cfg->fourcc);\r\nif (format == NULL) {\r\ndev_err(dev, "Invalid FOURCC %08x\n", ovl->cfg->fourcc);\r\nreturn -EINVAL;\r\n}\r\novl->enabled = false;\r\novl->mode = LCDC_OVERLAY_BLEND;\r\novl->alpha = 255;\r\novl->rop3 = 0;\r\novl->pos_x = 0;\r\novl->pos_y = 0;\r\novl->format = format;\r\novl->xres = ovl->cfg->max_xres;\r\novl->xres_virtual = ovl->xres;\r\novl->yres = ovl->cfg->max_yres;\r\novl->yres_virtual = ovl->yres * 2;\r\nif (!format->yuv)\r\novl->pitch = ovl->xres_virtual * format->bpp / 8;\r\nelse\r\novl->pitch = ovl->xres_virtual;\r\novl->fb_size = ovl->cfg->max_xres * ovl->cfg->max_yres\r\n* format->bpp / 8 * 2;\r\novl->fb_mem = dma_alloc_coherent(dev, ovl->fb_size, &ovl->dma_handle,\r\nGFP_KERNEL);\r\nif (!ovl->fb_mem) {\r\ndev_err(dev, "unable to allocate buffer\n");\r\nreturn -ENOMEM;\r\n}\r\nret = sh_mobile_lcdc_overlay_fb_init(ovl);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int\r\nsh_mobile_lcdc_channel_init(struct sh_mobile_lcdc_chan *ch)\r\n{\r\nconst struct sh_mobile_lcdc_format_info *format;\r\nconst struct sh_mobile_lcdc_chan_cfg *cfg = ch->cfg;\r\nstruct device *dev = ch->lcdc->dev;\r\nconst struct fb_videomode *max_mode;\r\nconst struct fb_videomode *mode;\r\nunsigned int num_modes;\r\nunsigned int max_size;\r\nunsigned int i;\r\nmutex_init(&ch->open_lock);\r\nch->notify = sh_mobile_lcdc_display_notify;\r\nformat = sh_mobile_format_info(cfg->fourcc);\r\nif (format == NULL) {\r\ndev_err(dev, "Invalid FOURCC %08x.\n", cfg->fourcc);\r\nreturn -EINVAL;\r\n}\r\nmax_mode = NULL;\r\nmax_size = 0;\r\nfor (i = 0, mode = cfg->lcd_modes; i < cfg->num_modes; i++, mode++) {\r\nunsigned int size = mode->yres * mode->xres;\r\nif ((cfg->fourcc == V4L2_PIX_FMT_NV12 ||\r\ncfg->fourcc == V4L2_PIX_FMT_NV21) && (mode->yres & 0x1)) {\r\ndev_err(dev, "yres must be multiple of 2 for "\r\n"YCbCr420 mode.\n");\r\nreturn -EINVAL;\r\n}\r\nif (size > max_size) {\r\nmax_mode = mode;\r\nmax_size = size;\r\n}\r\n}\r\nif (!max_size)\r\nmax_size = MAX_XRES * MAX_YRES;\r\nelse\r\ndev_dbg(dev, "Found largest videomode %ux%u\n",\r\nmax_mode->xres, max_mode->yres);\r\nif (cfg->lcd_modes == NULL) {\r\nmode = &default_720p;\r\nnum_modes = 1;\r\n} else {\r\nmode = cfg->lcd_modes;\r\nnum_modes = cfg->num_modes;\r\n}\r\nch->format = format;\r\nch->xres = mode->xres;\r\nch->xres_virtual = mode->xres;\r\nch->yres = mode->yres;\r\nch->yres_virtual = mode->yres * 2;\r\nif (!format->yuv) {\r\nch->colorspace = V4L2_COLORSPACE_SRGB;\r\nch->pitch = ch->xres_virtual * format->bpp / 8;\r\n} else {\r\nch->colorspace = V4L2_COLORSPACE_REC709;\r\nch->pitch = ch->xres_virtual;\r\n}\r\nch->display.width = cfg->panel_cfg.width;\r\nch->display.height = cfg->panel_cfg.height;\r\nch->display.mode = *mode;\r\nch->fb_size = max_size * format->bpp / 8 * 2;\r\nch->fb_mem = dma_alloc_coherent(dev, ch->fb_size, &ch->dma_handle,\r\nGFP_KERNEL);\r\nif (ch->fb_mem == NULL) {\r\ndev_err(dev, "unable to allocate buffer\n");\r\nreturn -ENOMEM;\r\n}\r\nif (cfg->tx_dev) {\r\nif (!cfg->tx_dev->dev.driver ||\r\n!try_module_get(cfg->tx_dev->dev.driver->owner)) {\r\ndev_warn(dev, "unable to get transmitter device\n");\r\nreturn -EINVAL;\r\n}\r\nch->tx_dev = platform_get_drvdata(cfg->tx_dev);\r\nch->tx_dev->lcdc = ch;\r\nch->tx_dev->def_mode = *mode;\r\n}\r\nreturn sh_mobile_lcdc_channel_fb_init(ch, mode, num_modes);\r\n}\r\nstatic int sh_mobile_lcdc_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_mobile_lcdc_info *pdata = pdev->dev.platform_data;\r\nstruct sh_mobile_lcdc_priv *priv;\r\nstruct resource *res;\r\nint num_channels;\r\nint error;\r\nint i;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data defined\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ni = platform_get_irq(pdev, 0);\r\nif (!res || i < 0) {\r\ndev_err(&pdev->dev, "cannot get platform resources\n");\r\nreturn -ENOENT;\r\n}\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&pdev->dev, "cannot allocate device data\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->dev = &pdev->dev;\r\npriv->meram_dev = pdata->meram_dev;\r\nplatform_set_drvdata(pdev, priv);\r\nerror = request_irq(i, sh_mobile_lcdc_irq, 0,\r\ndev_name(&pdev->dev), priv);\r\nif (error) {\r\ndev_err(&pdev->dev, "unable to request irq\n");\r\ngoto err1;\r\n}\r\npriv->irq = i;\r\natomic_set(&priv->hw_usecnt, -1);\r\nfor (i = 0, num_channels = 0; i < ARRAY_SIZE(pdata->ch); i++) {\r\nstruct sh_mobile_lcdc_chan *ch = priv->ch + num_channels;\r\nch->lcdc = priv;\r\nch->cfg = &pdata->ch[i];\r\nerror = sh_mobile_lcdc_check_interface(ch);\r\nif (error) {\r\ndev_err(&pdev->dev, "unsupported interface type\n");\r\ngoto err1;\r\n}\r\ninit_waitqueue_head(&ch->frame_end_wait);\r\ninit_completion(&ch->vsync_completion);\r\nif (ch->cfg->bl_info.max_brightness)\r\nch->bl = sh_mobile_lcdc_bl_probe(&pdev->dev, ch);\r\nswitch (pdata->ch[i].chan) {\r\ncase LCDC_CHAN_MAINLCD:\r\nch->enabled = LDCNT2R_ME;\r\nch->reg_offs = lcdc_offs_mainlcd;\r\nnum_channels++;\r\nbreak;\r\ncase LCDC_CHAN_SUBLCD:\r\nch->enabled = LDCNT2R_SE;\r\nch->reg_offs = lcdc_offs_sublcd;\r\nnum_channels++;\r\nbreak;\r\n}\r\n}\r\nif (!num_channels) {\r\ndev_err(&pdev->dev, "no channels defined\n");\r\nerror = -EINVAL;\r\ngoto err1;\r\n}\r\nif (num_channels == 2)\r\npriv->forced_fourcc = pdata->ch[0].fourcc;\r\npriv->base = ioremap_nocache(res->start, resource_size(res));\r\nif (!priv->base)\r\ngoto err1;\r\nerror = sh_mobile_lcdc_setup_clocks(priv, pdata->clock_source);\r\nif (error) {\r\ndev_err(&pdev->dev, "unable to setup clocks\n");\r\ngoto err1;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\nfor (i = 0; i < num_channels; i++) {\r\nstruct sh_mobile_lcdc_chan *ch = &priv->ch[i];\r\nerror = sh_mobile_lcdc_channel_init(ch);\r\nif (error)\r\ngoto err1;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(pdata->overlays); i++) {\r\nstruct sh_mobile_lcdc_overlay *ovl = &priv->overlays[i];\r\novl->cfg = &pdata->overlays[i];\r\novl->channel = &priv->ch[0];\r\nerror = sh_mobile_lcdc_overlay_init(ovl);\r\nif (error)\r\ngoto err1;\r\n}\r\nerror = sh_mobile_lcdc_start(priv);\r\nif (error) {\r\ndev_err(&pdev->dev, "unable to start hardware\n");\r\ngoto err1;\r\n}\r\nfor (i = 0; i < num_channels; i++) {\r\nstruct sh_mobile_lcdc_chan *ch = priv->ch + i;\r\nerror = sh_mobile_lcdc_channel_fb_register(ch);\r\nif (error)\r\ngoto err1;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(pdata->overlays); i++) {\r\nstruct sh_mobile_lcdc_overlay *ovl = &priv->overlays[i];\r\nerror = sh_mobile_lcdc_overlay_fb_register(ovl);\r\nif (error)\r\ngoto err1;\r\n}\r\npriv->notifier.notifier_call = sh_mobile_lcdc_notify;\r\nfb_register_client(&priv->notifier);\r\nreturn 0;\r\nerr1:\r\nsh_mobile_lcdc_remove(pdev);\r\nreturn error;\r\n}
