static void read_main_config_table(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nvoid __iomem *address = pm8001_ha->main_cfg_tbl_addr;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.signature =\r\npm8001_mr32(address, 0x00);\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.interface_rev =\r\npm8001_mr32(address, 0x04);\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.firmware_rev =\r\npm8001_mr32(address, 0x08);\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.max_out_io =\r\npm8001_mr32(address, 0x0C);\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.max_sgl =\r\npm8001_mr32(address, 0x10);\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.ctrl_cap_flag =\r\npm8001_mr32(address, 0x14);\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.gst_offset =\r\npm8001_mr32(address, 0x18);\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.inbound_queue_offset =\r\npm8001_mr32(address, MAIN_IBQ_OFFSET);\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_queue_offset =\r\npm8001_mr32(address, MAIN_OBQ_OFFSET);\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.hda_mode_flag =\r\npm8001_mr32(address, MAIN_HDA_FLAGS_OFFSET);\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.anolog_setup_table_offset =\r\npm8001_mr32(address, MAIN_ANALOG_SETUP_OFFSET);\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.fatal_err_dump_offset0 =\r\npm8001_mr32(address, MAIN_FATAL_ERROR_RDUMP0_OFFSET);\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.fatal_err_dump_length0 =\r\npm8001_mr32(address, MAIN_FATAL_ERROR_RDUMP0_LENGTH);\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.fatal_err_dump_offset1 =\r\npm8001_mr32(address, MAIN_FATAL_ERROR_RDUMP1_OFFSET);\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.fatal_err_dump_length1 =\r\npm8001_mr32(address, MAIN_FATAL_ERROR_RDUMP1_LENGTH);\r\n}\r\nstatic void read_general_status_table(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nvoid __iomem *address = pm8001_ha->general_stat_tbl_addr;\r\npm8001_ha->gs_tbl.pm8001_tbl.gst_len_mpistate =\r\npm8001_mr32(address, 0x00);\r\npm8001_ha->gs_tbl.pm8001_tbl.iq_freeze_state0 =\r\npm8001_mr32(address, 0x04);\r\npm8001_ha->gs_tbl.pm8001_tbl.iq_freeze_state1 =\r\npm8001_mr32(address, 0x08);\r\npm8001_ha->gs_tbl.pm8001_tbl.msgu_tcnt =\r\npm8001_mr32(address, 0x0C);\r\npm8001_ha->gs_tbl.pm8001_tbl.iop_tcnt =\r\npm8001_mr32(address, 0x10);\r\npm8001_ha->gs_tbl.pm8001_tbl.rsvd =\r\npm8001_mr32(address, 0x14);\r\npm8001_ha->gs_tbl.pm8001_tbl.phy_state[0] =\r\npm8001_mr32(address, 0x18);\r\npm8001_ha->gs_tbl.pm8001_tbl.phy_state[1] =\r\npm8001_mr32(address, 0x1C);\r\npm8001_ha->gs_tbl.pm8001_tbl.phy_state[2] =\r\npm8001_mr32(address, 0x20);\r\npm8001_ha->gs_tbl.pm8001_tbl.phy_state[3] =\r\npm8001_mr32(address, 0x24);\r\npm8001_ha->gs_tbl.pm8001_tbl.phy_state[4] =\r\npm8001_mr32(address, 0x28);\r\npm8001_ha->gs_tbl.pm8001_tbl.phy_state[5] =\r\npm8001_mr32(address, 0x2C);\r\npm8001_ha->gs_tbl.pm8001_tbl.phy_state[6] =\r\npm8001_mr32(address, 0x30);\r\npm8001_ha->gs_tbl.pm8001_tbl.phy_state[7] =\r\npm8001_mr32(address, 0x34);\r\npm8001_ha->gs_tbl.pm8001_tbl.gpio_input_val =\r\npm8001_mr32(address, 0x38);\r\npm8001_ha->gs_tbl.pm8001_tbl.rsvd1[0] =\r\npm8001_mr32(address, 0x3C);\r\npm8001_ha->gs_tbl.pm8001_tbl.rsvd1[1] =\r\npm8001_mr32(address, 0x40);\r\npm8001_ha->gs_tbl.pm8001_tbl.recover_err_info[0] =\r\npm8001_mr32(address, 0x44);\r\npm8001_ha->gs_tbl.pm8001_tbl.recover_err_info[1] =\r\npm8001_mr32(address, 0x48);\r\npm8001_ha->gs_tbl.pm8001_tbl.recover_err_info[2] =\r\npm8001_mr32(address, 0x4C);\r\npm8001_ha->gs_tbl.pm8001_tbl.recover_err_info[3] =\r\npm8001_mr32(address, 0x50);\r\npm8001_ha->gs_tbl.pm8001_tbl.recover_err_info[4] =\r\npm8001_mr32(address, 0x54);\r\npm8001_ha->gs_tbl.pm8001_tbl.recover_err_info[5] =\r\npm8001_mr32(address, 0x58);\r\npm8001_ha->gs_tbl.pm8001_tbl.recover_err_info[6] =\r\npm8001_mr32(address, 0x5C);\r\npm8001_ha->gs_tbl.pm8001_tbl.recover_err_info[7] =\r\npm8001_mr32(address, 0x60);\r\n}\r\nstatic void read_inbnd_queue_table(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nint i;\r\nvoid __iomem *address = pm8001_ha->inbnd_q_tbl_addr;\r\nfor (i = 0; i < PM8001_MAX_INB_NUM; i++) {\r\nu32 offset = i * 0x20;\r\npm8001_ha->inbnd_q_tbl[i].pi_pci_bar =\r\nget_pci_bar_index(pm8001_mr32(address, (offset + 0x14)));\r\npm8001_ha->inbnd_q_tbl[i].pi_offset =\r\npm8001_mr32(address, (offset + 0x18));\r\n}\r\n}\r\nstatic void read_outbnd_queue_table(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nint i;\r\nvoid __iomem *address = pm8001_ha->outbnd_q_tbl_addr;\r\nfor (i = 0; i < PM8001_MAX_OUTB_NUM; i++) {\r\nu32 offset = i * 0x24;\r\npm8001_ha->outbnd_q_tbl[i].ci_pci_bar =\r\nget_pci_bar_index(pm8001_mr32(address, (offset + 0x14)));\r\npm8001_ha->outbnd_q_tbl[i].ci_offset =\r\npm8001_mr32(address, (offset + 0x18));\r\n}\r\n}\r\nstatic void init_default_table_values(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nint i;\r\nu32 offsetib, offsetob;\r\nvoid __iomem *addressib = pm8001_ha->inbnd_q_tbl_addr;\r\nvoid __iomem *addressob = pm8001_ha->outbnd_q_tbl_addr;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.inbound_q_nppd_hppd = 0;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_hw_event_pid0_3 = 0;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_hw_event_pid4_7 = 0;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_ncq_event_pid0_3 = 0;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_ncq_event_pid4_7 = 0;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_tgt_ITNexus_event_pid0_3 =\r\n0;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_tgt_ITNexus_event_pid4_7 =\r\n0;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_tgt_ssp_event_pid0_3 = 0;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_tgt_ssp_event_pid4_7 = 0;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_tgt_smp_event_pid0_3 = 0;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_tgt_smp_event_pid4_7 = 0;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.upper_event_log_addr =\r\npm8001_ha->memoryMap.region[AAP1].phys_addr_hi;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.lower_event_log_addr =\r\npm8001_ha->memoryMap.region[AAP1].phys_addr_lo;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.event_log_size =\r\nPM8001_EVENT_LOG_SIZE;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.event_log_option = 0x01;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.upper_iop_event_log_addr =\r\npm8001_ha->memoryMap.region[IOP].phys_addr_hi;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.lower_iop_event_log_addr =\r\npm8001_ha->memoryMap.region[IOP].phys_addr_lo;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.iop_event_log_size =\r\nPM8001_EVENT_LOG_SIZE;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.iop_event_log_option = 0x01;\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.fatal_err_interrupt = 0x01;\r\nfor (i = 0; i < PM8001_MAX_INB_NUM; i++) {\r\npm8001_ha->inbnd_q_tbl[i].element_pri_size_cnt =\r\nPM8001_MPI_QUEUE | (pm8001_ha->iomb_size << 16) | (0x00<<30);\r\npm8001_ha->inbnd_q_tbl[i].upper_base_addr =\r\npm8001_ha->memoryMap.region[IB + i].phys_addr_hi;\r\npm8001_ha->inbnd_q_tbl[i].lower_base_addr =\r\npm8001_ha->memoryMap.region[IB + i].phys_addr_lo;\r\npm8001_ha->inbnd_q_tbl[i].base_virt =\r\n(u8 *)pm8001_ha->memoryMap.region[IB + i].virt_ptr;\r\npm8001_ha->inbnd_q_tbl[i].total_length =\r\npm8001_ha->memoryMap.region[IB + i].total_len;\r\npm8001_ha->inbnd_q_tbl[i].ci_upper_base_addr =\r\npm8001_ha->memoryMap.region[CI + i].phys_addr_hi;\r\npm8001_ha->inbnd_q_tbl[i].ci_lower_base_addr =\r\npm8001_ha->memoryMap.region[CI + i].phys_addr_lo;\r\npm8001_ha->inbnd_q_tbl[i].ci_virt =\r\npm8001_ha->memoryMap.region[CI + i].virt_ptr;\r\noffsetib = i * 0x20;\r\npm8001_ha->inbnd_q_tbl[i].pi_pci_bar =\r\nget_pci_bar_index(pm8001_mr32(addressib,\r\n(offsetib + 0x14)));\r\npm8001_ha->inbnd_q_tbl[i].pi_offset =\r\npm8001_mr32(addressib, (offsetib + 0x18));\r\npm8001_ha->inbnd_q_tbl[i].producer_idx = 0;\r\npm8001_ha->inbnd_q_tbl[i].consumer_index = 0;\r\n}\r\nfor (i = 0; i < PM8001_MAX_OUTB_NUM; i++) {\r\npm8001_ha->outbnd_q_tbl[i].element_size_cnt =\r\nPM8001_MPI_QUEUE | (pm8001_ha->iomb_size << 16) | (0x01<<30);\r\npm8001_ha->outbnd_q_tbl[i].upper_base_addr =\r\npm8001_ha->memoryMap.region[OB + i].phys_addr_hi;\r\npm8001_ha->outbnd_q_tbl[i].lower_base_addr =\r\npm8001_ha->memoryMap.region[OB + i].phys_addr_lo;\r\npm8001_ha->outbnd_q_tbl[i].base_virt =\r\n(u8 *)pm8001_ha->memoryMap.region[OB + i].virt_ptr;\r\npm8001_ha->outbnd_q_tbl[i].total_length =\r\npm8001_ha->memoryMap.region[OB + i].total_len;\r\npm8001_ha->outbnd_q_tbl[i].pi_upper_base_addr =\r\npm8001_ha->memoryMap.region[PI + i].phys_addr_hi;\r\npm8001_ha->outbnd_q_tbl[i].pi_lower_base_addr =\r\npm8001_ha->memoryMap.region[PI + i].phys_addr_lo;\r\npm8001_ha->outbnd_q_tbl[i].interrup_vec_cnt_delay =\r\n0 | (10 << 16) | (i << 24);\r\npm8001_ha->outbnd_q_tbl[i].pi_virt =\r\npm8001_ha->memoryMap.region[PI + i].virt_ptr;\r\noffsetob = i * 0x24;\r\npm8001_ha->outbnd_q_tbl[i].ci_pci_bar =\r\nget_pci_bar_index(pm8001_mr32(addressob,\r\noffsetob + 0x14));\r\npm8001_ha->outbnd_q_tbl[i].ci_offset =\r\npm8001_mr32(addressob, (offsetob + 0x18));\r\npm8001_ha->outbnd_q_tbl[i].consumer_idx = 0;\r\npm8001_ha->outbnd_q_tbl[i].producer_index = 0;\r\n}\r\n}\r\nstatic void update_main_config_table(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nvoid __iomem *address = pm8001_ha->main_cfg_tbl_addr;\r\npm8001_mw32(address, 0x24,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.inbound_q_nppd_hppd);\r\npm8001_mw32(address, 0x28,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_hw_event_pid0_3);\r\npm8001_mw32(address, 0x2C,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_hw_event_pid4_7);\r\npm8001_mw32(address, 0x30,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_ncq_event_pid0_3);\r\npm8001_mw32(address, 0x34,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_ncq_event_pid4_7);\r\npm8001_mw32(address, 0x38,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.\r\noutbound_tgt_ITNexus_event_pid0_3);\r\npm8001_mw32(address, 0x3C,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.\r\noutbound_tgt_ITNexus_event_pid4_7);\r\npm8001_mw32(address, 0x40,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.\r\noutbound_tgt_ssp_event_pid0_3);\r\npm8001_mw32(address, 0x44,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.\r\noutbound_tgt_ssp_event_pid4_7);\r\npm8001_mw32(address, 0x48,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.\r\noutbound_tgt_smp_event_pid0_3);\r\npm8001_mw32(address, 0x4C,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.\r\noutbound_tgt_smp_event_pid4_7);\r\npm8001_mw32(address, 0x50,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.upper_event_log_addr);\r\npm8001_mw32(address, 0x54,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.lower_event_log_addr);\r\npm8001_mw32(address, 0x58,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.event_log_size);\r\npm8001_mw32(address, 0x5C,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.event_log_option);\r\npm8001_mw32(address, 0x60,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.upper_iop_event_log_addr);\r\npm8001_mw32(address, 0x64,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.lower_iop_event_log_addr);\r\npm8001_mw32(address, 0x68,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.iop_event_log_size);\r\npm8001_mw32(address, 0x6C,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.iop_event_log_option);\r\npm8001_mw32(address, 0x70,\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.fatal_err_interrupt);\r\n}\r\nstatic void update_inbnd_queue_table(struct pm8001_hba_info *pm8001_ha,\r\nint number)\r\n{\r\nvoid __iomem *address = pm8001_ha->inbnd_q_tbl_addr;\r\nu16 offset = number * 0x20;\r\npm8001_mw32(address, offset + 0x00,\r\npm8001_ha->inbnd_q_tbl[number].element_pri_size_cnt);\r\npm8001_mw32(address, offset + 0x04,\r\npm8001_ha->inbnd_q_tbl[number].upper_base_addr);\r\npm8001_mw32(address, offset + 0x08,\r\npm8001_ha->inbnd_q_tbl[number].lower_base_addr);\r\npm8001_mw32(address, offset + 0x0C,\r\npm8001_ha->inbnd_q_tbl[number].ci_upper_base_addr);\r\npm8001_mw32(address, offset + 0x10,\r\npm8001_ha->inbnd_q_tbl[number].ci_lower_base_addr);\r\n}\r\nstatic void update_outbnd_queue_table(struct pm8001_hba_info *pm8001_ha,\r\nint number)\r\n{\r\nvoid __iomem *address = pm8001_ha->outbnd_q_tbl_addr;\r\nu16 offset = number * 0x24;\r\npm8001_mw32(address, offset + 0x00,\r\npm8001_ha->outbnd_q_tbl[number].element_size_cnt);\r\npm8001_mw32(address, offset + 0x04,\r\npm8001_ha->outbnd_q_tbl[number].upper_base_addr);\r\npm8001_mw32(address, offset + 0x08,\r\npm8001_ha->outbnd_q_tbl[number].lower_base_addr);\r\npm8001_mw32(address, offset + 0x0C,\r\npm8001_ha->outbnd_q_tbl[number].pi_upper_base_addr);\r\npm8001_mw32(address, offset + 0x10,\r\npm8001_ha->outbnd_q_tbl[number].pi_lower_base_addr);\r\npm8001_mw32(address, offset + 0x1C,\r\npm8001_ha->outbnd_q_tbl[number].interrup_vec_cnt_delay);\r\n}\r\nint pm8001_bar4_shift(struct pm8001_hba_info *pm8001_ha, u32 shiftValue)\r\n{\r\nu32 regVal;\r\nunsigned long start;\r\npm8001_cw32(pm8001_ha, 1, SPC_IBW_AXI_TRANSLATION_LOW, shiftValue);\r\nstart = jiffies + HZ;\r\ndo {\r\nregVal = pm8001_cr32(pm8001_ha, 1, SPC_IBW_AXI_TRANSLATION_LOW);\r\n} while ((regVal != shiftValue) && time_before(jiffies, start));\r\nif (regVal != shiftValue) {\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("TIMEOUT:SPC_IBW_AXI_TRANSLATION_LOW"\r\n" = 0x%x\n", regVal));\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mpi_set_phys_g3_with_ssc(struct pm8001_hba_info *pm8001_ha,\r\nu32 SSCbit)\r\n{\r\nu32 value, offset, i;\r\nunsigned long flags;\r\n#define SAS2_SETTINGS_LOCAL_PHY_0_3_SHIFT_ADDR 0x00030000\r\n#define SAS2_SETTINGS_LOCAL_PHY_4_7_SHIFT_ADDR 0x00040000\r\n#define SAS2_SETTINGS_LOCAL_PHY_0_3_OFFSET 0x1074\r\n#define SAS2_SETTINGS_LOCAL_PHY_4_7_OFFSET 0x1074\r\n#define PHY_G3_WITHOUT_SSC_BIT_SHIFT 12\r\n#define PHY_G3_WITH_SSC_BIT_SHIFT 13\r\n#define SNW3_PHY_CAPABILITIES_PARITY 31\r\nspin_lock_irqsave(&pm8001_ha->lock, flags);\r\nif (-1 == pm8001_bar4_shift(pm8001_ha,\r\nSAS2_SETTINGS_LOCAL_PHY_0_3_SHIFT_ADDR)) {\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nreturn;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\noffset = SAS2_SETTINGS_LOCAL_PHY_0_3_OFFSET + 0x4000 * i;\r\npm8001_cw32(pm8001_ha, 2, offset, 0x80001501);\r\n}\r\nif (-1 == pm8001_bar4_shift(pm8001_ha,\r\nSAS2_SETTINGS_LOCAL_PHY_4_7_SHIFT_ADDR)) {\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nreturn;\r\n}\r\nfor (i = 4; i < 8; i++) {\r\noffset = SAS2_SETTINGS_LOCAL_PHY_4_7_OFFSET + 0x4000 * (i-4);\r\npm8001_cw32(pm8001_ha, 2, offset, 0x80001501);\r\n}\r\nvalue = pm8001_cr32(pm8001_ha, 2, 0xd8);\r\npm8001_cw32(pm8001_ha, 2, 0xd8, 0x8000C016);\r\npm8001_bar4_shift(pm8001_ha, 0x0);\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nreturn;\r\n}\r\nstatic void mpi_set_open_retry_interval_reg(struct pm8001_hba_info *pm8001_ha,\r\nu32 interval)\r\n{\r\nu32 offset;\r\nu32 value;\r\nu32 i;\r\nunsigned long flags;\r\n#define OPEN_RETRY_INTERVAL_PHY_0_3_SHIFT_ADDR 0x00030000\r\n#define OPEN_RETRY_INTERVAL_PHY_4_7_SHIFT_ADDR 0x00040000\r\n#define OPEN_RETRY_INTERVAL_PHY_0_3_OFFSET 0x30B4\r\n#define OPEN_RETRY_INTERVAL_PHY_4_7_OFFSET 0x30B4\r\n#define OPEN_RETRY_INTERVAL_REG_MASK 0x0000FFFF\r\nvalue = interval & OPEN_RETRY_INTERVAL_REG_MASK;\r\nspin_lock_irqsave(&pm8001_ha->lock, flags);\r\nif (-1 == pm8001_bar4_shift(pm8001_ha,\r\nOPEN_RETRY_INTERVAL_PHY_0_3_SHIFT_ADDR)) {\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nreturn;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\noffset = OPEN_RETRY_INTERVAL_PHY_0_3_OFFSET + 0x4000 * i;\r\npm8001_cw32(pm8001_ha, 2, offset, value);\r\n}\r\nif (-1 == pm8001_bar4_shift(pm8001_ha,\r\nOPEN_RETRY_INTERVAL_PHY_4_7_SHIFT_ADDR)) {\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nreturn;\r\n}\r\nfor (i = 4; i < 8; i++) {\r\noffset = OPEN_RETRY_INTERVAL_PHY_4_7_OFFSET + 0x4000 * (i-4);\r\npm8001_cw32(pm8001_ha, 2, offset, value);\r\n}\r\npm8001_bar4_shift(pm8001_ha, 0x0);\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nreturn;\r\n}\r\nstatic int mpi_init_check(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu32 max_wait_count;\r\nu32 value;\r\nu32 gst_len_mpistate;\r\npm8001_cw32(pm8001_ha, 0, MSGU_IBDB_SET, SPC_MSGU_CFG_TABLE_UPDATE);\r\nmax_wait_count = 1 * 1000 * 1000;\r\ndo {\r\nudelay(1);\r\nvalue = pm8001_cr32(pm8001_ha, 0, MSGU_IBDB_SET);\r\nvalue &= SPC_MSGU_CFG_TABLE_UPDATE;\r\n} while ((value != 0) && (--max_wait_count));\r\nif (!max_wait_count)\r\nreturn -1;\r\ngst_len_mpistate =\r\npm8001_mr32(pm8001_ha->general_stat_tbl_addr,\r\nGST_GSTLEN_MPIS_OFFSET);\r\nif (GST_MPI_STATE_INIT != (gst_len_mpistate & GST_MPI_STATE_MASK))\r\nreturn -1;\r\ngst_len_mpistate = gst_len_mpistate >> 16;\r\nif (0x0000 != gst_len_mpistate)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int check_fw_ready(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu32 value, value1;\r\nu32 max_wait_count;\r\nvalue = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1);\r\nvalue1 = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_2);\r\nif (SCRATCH_PAD1_ERR == (value & SCRATCH_PAD_STATE_MASK)) {\r\nvalue = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_0);\r\nreturn -1;\r\n}\r\nif (SCRATCH_PAD2_ERR == (value1 & SCRATCH_PAD_STATE_MASK)) {\r\nvalue1 = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_3);\r\nreturn -1;\r\n}\r\nif (value & SCRATCH_PAD1_STATE_MASK) {\r\npm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_0);\r\nreturn -1;\r\n}\r\nif (value1 & SCRATCH_PAD2_STATE_MASK) {\r\nreturn -1;\r\n}\r\nmax_wait_count = 1 * 1000 * 1000;\r\ndo {\r\nudelay(1);\r\nvalue = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1)\r\n& SCRATCH_PAD1_RDY;\r\nvalue1 = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_2)\r\n& SCRATCH_PAD2_RDY;\r\nif ((--max_wait_count) == 0)\r\nreturn -1;\r\n} while ((value != SCRATCH_PAD1_RDY) || (value1 != SCRATCH_PAD2_RDY));\r\nreturn 0;\r\n}\r\nstatic void init_pci_device_addresses(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nvoid __iomem *base_addr;\r\nu32 value;\r\nu32 offset;\r\nu32 pcibar;\r\nu32 pcilogic;\r\nvalue = pm8001_cr32(pm8001_ha, 0, 0x44);\r\noffset = value & 0x03FFFFFF;\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("Scratchpad 0 Offset: %x\n", offset));\r\npcilogic = (value & 0xFC000000) >> 26;\r\npcibar = get_pci_bar_index(pcilogic);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("Scratchpad 0 PCI BAR: %d\n", pcibar));\r\npm8001_ha->main_cfg_tbl_addr = base_addr =\r\npm8001_ha->io_mem[pcibar].memvirtaddr + offset;\r\npm8001_ha->general_stat_tbl_addr =\r\nbase_addr + pm8001_cr32(pm8001_ha, pcibar, offset + 0x18);\r\npm8001_ha->inbnd_q_tbl_addr =\r\nbase_addr + pm8001_cr32(pm8001_ha, pcibar, offset + 0x1C);\r\npm8001_ha->outbnd_q_tbl_addr =\r\nbase_addr + pm8001_cr32(pm8001_ha, pcibar, offset + 0x20);\r\n}\r\nstatic int pm8001_chip_init(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu8 i = 0;\r\nu16 deviceid;\r\npci_read_config_word(pm8001_ha->pdev, PCI_DEVICE_ID, &deviceid);\r\nif (deviceid == 0x8081) {\r\nif (-1 == pm8001_bar4_shift(pm8001_ha, GSM_SM_BASE)) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Shift Bar4 to 0x%x failed\n",\r\nGSM_SM_BASE));\r\nreturn -1;\r\n}\r\n}\r\nif (-1 == check_fw_ready(pm8001_ha)) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Firmware is not ready!\n"));\r\nreturn -EBUSY;\r\n}\r\ninit_pci_device_addresses(pm8001_ha);\r\ninit_default_table_values(pm8001_ha);\r\nread_main_config_table(pm8001_ha);\r\nread_general_status_table(pm8001_ha);\r\nread_inbnd_queue_table(pm8001_ha);\r\nread_outbnd_queue_table(pm8001_ha);\r\nupdate_main_config_table(pm8001_ha);\r\nfor (i = 0; i < PM8001_MAX_INB_NUM; i++)\r\nupdate_inbnd_queue_table(pm8001_ha, i);\r\nfor (i = 0; i < PM8001_MAX_OUTB_NUM; i++)\r\nupdate_outbnd_queue_table(pm8001_ha, i);\r\nif (deviceid != 0x8081) {\r\nmpi_set_phys_g3_with_ssc(pm8001_ha, 0);\r\nmpi_set_open_retry_interval_reg(pm8001_ha, 119);\r\n}\r\nif (0 == mpi_init_check(pm8001_ha)) {\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("MPI initialize successful!\n"));\r\n} else\r\nreturn -EBUSY;\r\npm8001_cw32(pm8001_ha, 1, 0x0033c0, 0x1);\r\npm8001_cw32(pm8001_ha, 1, 0x0033c4, 0x0);\r\nreturn 0;\r\n}\r\nstatic int mpi_uninit_check(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu32 max_wait_count;\r\nu32 value;\r\nu32 gst_len_mpistate;\r\nu16 deviceid;\r\npci_read_config_word(pm8001_ha->pdev, PCI_DEVICE_ID, &deviceid);\r\nif (deviceid == 0x8081) {\r\nif (-1 == pm8001_bar4_shift(pm8001_ha, GSM_SM_BASE)) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Shift Bar4 to 0x%x failed\n",\r\nGSM_SM_BASE));\r\nreturn -1;\r\n}\r\n}\r\ninit_pci_device_addresses(pm8001_ha);\r\npm8001_cw32(pm8001_ha, 0, MSGU_IBDB_SET, SPC_MSGU_CFG_TABLE_RESET);\r\nmax_wait_count = 1 * 1000 * 1000;\r\ndo {\r\nudelay(1);\r\nvalue = pm8001_cr32(pm8001_ha, 0, MSGU_IBDB_SET);\r\nvalue &= SPC_MSGU_CFG_TABLE_RESET;\r\n} while ((value != 0) && (--max_wait_count));\r\nif (!max_wait_count) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("TIMEOUT:IBDB value/=0x%x\n", value));\r\nreturn -1;\r\n}\r\nmax_wait_count = 1 * 1000 * 1000;\r\ndo {\r\nudelay(1);\r\ngst_len_mpistate =\r\npm8001_mr32(pm8001_ha->general_stat_tbl_addr,\r\nGST_GSTLEN_MPIS_OFFSET);\r\nif (GST_MPI_STATE_UNINIT ==\r\n(gst_len_mpistate & GST_MPI_STATE_MASK))\r\nbreak;\r\n} while (--max_wait_count);\r\nif (!max_wait_count) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk(" TIME OUT MPI State = 0x%x\n",\r\ngst_len_mpistate & GST_MPI_STATE_MASK));\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 soft_reset_ready_check(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu32 regVal, regVal1, regVal2;\r\nif (mpi_uninit_check(pm8001_ha) != 0) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("MPI state is not ready\n"));\r\nreturn -1;\r\n}\r\nregVal = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_2)\r\n& SCRATCH_PAD2_FWRDY_RST;\r\nif (regVal == SCRATCH_PAD2_FWRDY_RST) {\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("Firmware is ready for reset .\n"));\r\n} else {\r\nunsigned long flags;\r\nspin_lock_irqsave(&pm8001_ha->lock, flags);\r\nif (-1 == pm8001_bar4_shift(pm8001_ha, RB6_ACCESS_REG)) {\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Shift Bar4 to 0x%x failed\n",\r\nRB6_ACCESS_REG));\r\nreturn -1;\r\n}\r\npm8001_cw32(pm8001_ha, 2, SPC_RB6_OFFSET,\r\nRB6_MAGIC_NUMBER_RST);\r\npm8001_cw32(pm8001_ha, 2, SPC_RB6_OFFSET, RB6_MAGIC_NUMBER_RST);\r\nmdelay(100);\r\nregVal = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_2) &\r\nSCRATCH_PAD2_FWRDY_RST;\r\nif (regVal != SCRATCH_PAD2_FWRDY_RST) {\r\nregVal1 = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1);\r\nregVal2 = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_2);\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("TIMEOUT:MSGU_SCRATCH_PAD1"\r\n"=0x%x, MSGU_SCRATCH_PAD2=0x%x\n",\r\nregVal1, regVal2));\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("SCRATCH_PAD0 value = 0x%x\n",\r\npm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_0)));\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("SCRATCH_PAD3 value = 0x%x\n",\r\npm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_3)));\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nreturn -1;\r\n}\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\npm8001_chip_soft_rst(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu32 regVal, toggleVal;\r\nu32 max_wait_count;\r\nu32 regVal1, regVal2, regVal3;\r\nu32 signature = 0x252acbcd;\r\nunsigned long flags;\r\nif (soft_reset_ready_check(pm8001_ha) != 0) {\r\nPM8001_FAIL_DBG(pm8001_ha, pm8001_printk("FW is not ready\n"));\r\nreturn -1;\r\n}\r\nspin_lock_irqsave(&pm8001_ha->lock, flags);\r\nif (-1 == pm8001_bar4_shift(pm8001_ha, MBIC_AAP1_ADDR_BASE)) {\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Shift Bar4 to 0x%x failed\n",\r\nMBIC_AAP1_ADDR_BASE));\r\nreturn -1;\r\n}\r\nregVal = pm8001_cr32(pm8001_ha, 2, MBIC_NMI_ENABLE_VPE0_IOP);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("MBIC - NMI Enable VPE0 (IOP)= 0x%x\n", regVal));\r\npm8001_cw32(pm8001_ha, 2, MBIC_NMI_ENABLE_VPE0_IOP, 0x0);\r\nif (-1 == pm8001_bar4_shift(pm8001_ha, MBIC_IOP_ADDR_BASE)) {\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Shift Bar4 to 0x%x failed\n",\r\nMBIC_IOP_ADDR_BASE));\r\nreturn -1;\r\n}\r\nregVal = pm8001_cr32(pm8001_ha, 2, MBIC_NMI_ENABLE_VPE0_AAP1);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("MBIC - NMI Enable VPE0 (AAP1)= 0x%x\n", regVal));\r\npm8001_cw32(pm8001_ha, 2, MBIC_NMI_ENABLE_VPE0_AAP1, 0x0);\r\nregVal = pm8001_cr32(pm8001_ha, 1, PCIE_EVENT_INTERRUPT_ENABLE);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("PCIE -Event Interrupt Enable = 0x%x\n", regVal));\r\npm8001_cw32(pm8001_ha, 1, PCIE_EVENT_INTERRUPT_ENABLE, 0x0);\r\nregVal = pm8001_cr32(pm8001_ha, 1, PCIE_EVENT_INTERRUPT);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("PCIE - Event Interrupt = 0x%x\n", regVal));\r\npm8001_cw32(pm8001_ha, 1, PCIE_EVENT_INTERRUPT, regVal);\r\nregVal = pm8001_cr32(pm8001_ha, 1, PCIE_ERROR_INTERRUPT_ENABLE);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("PCIE -Error Interrupt Enable = 0x%x\n", regVal));\r\npm8001_cw32(pm8001_ha, 1, PCIE_ERROR_INTERRUPT_ENABLE, 0x0);\r\nregVal = pm8001_cr32(pm8001_ha, 1, PCIE_ERROR_INTERRUPT);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("PCIE - Error Interrupt = 0x%x\n", regVal));\r\npm8001_cw32(pm8001_ha, 1, PCIE_ERROR_INTERRUPT, regVal);\r\nregVal = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1)\r\n& SCRATCH_PAD1_RST;\r\ntoggleVal = regVal ^ SCRATCH_PAD1_RST;\r\npm8001_cw32(pm8001_ha, 0, MSGU_HOST_SCRATCH_PAD_0, signature);\r\nif (-1 == pm8001_bar4_shift(pm8001_ha, GSM_ADDR_BASE)) {\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Shift Bar4 to 0x%x failed\n",\r\nGSM_ADDR_BASE));\r\nreturn -1;\r\n}\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("GSM 0x0(0x00007b88)-GSM Configuration and"\r\n" Reset = 0x%x\n",\r\npm8001_cr32(pm8001_ha, 2, GSM_CONFIG_RESET)));\r\nregVal = pm8001_cr32(pm8001_ha, 2, GSM_CONFIG_RESET);\r\nregVal &= ~(0x00003b00);\r\npm8001_cw32(pm8001_ha, 2, GSM_CONFIG_RESET, regVal);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("GSM 0x0 (0x00007b88 ==> 0x00004088) - GSM "\r\n"Configuration and Reset is set to = 0x%x\n",\r\npm8001_cr32(pm8001_ha, 2, GSM_CONFIG_RESET)));\r\nregVal1 = pm8001_cr32(pm8001_ha, 2, GSM_READ_ADDR_PARITY_CHECK);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("GSM 0x700038 - Read Address Parity Check "\r\n"Enable = 0x%x\n", regVal1));\r\npm8001_cw32(pm8001_ha, 2, GSM_READ_ADDR_PARITY_CHECK, 0x0);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("GSM 0x700038 - Read Address Parity Check Enable"\r\n"is set to = 0x%x\n",\r\npm8001_cr32(pm8001_ha, 2, GSM_READ_ADDR_PARITY_CHECK)));\r\nregVal2 = pm8001_cr32(pm8001_ha, 2, GSM_WRITE_ADDR_PARITY_CHECK);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("GSM 0x700040 - Write Address Parity Check"\r\n" Enable = 0x%x\n", regVal2));\r\npm8001_cw32(pm8001_ha, 2, GSM_WRITE_ADDR_PARITY_CHECK, 0x0);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("GSM 0x700040 - Write Address Parity Check "\r\n"Enable is set to = 0x%x\n",\r\npm8001_cr32(pm8001_ha, 2, GSM_WRITE_ADDR_PARITY_CHECK)));\r\nregVal3 = pm8001_cr32(pm8001_ha, 2, GSM_WRITE_DATA_PARITY_CHECK);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("GSM 0x300048 - Write Data Parity Check"\r\n" Enable = 0x%x\n", regVal3));\r\npm8001_cw32(pm8001_ha, 2, GSM_WRITE_DATA_PARITY_CHECK, 0x0);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("GSM 0x300048 - Write Data Parity Check Enable"\r\n"is set to = 0x%x\n",\r\npm8001_cr32(pm8001_ha, 2, GSM_WRITE_DATA_PARITY_CHECK)));\r\nudelay(10);\r\nif (-1 == pm8001_bar4_shift(pm8001_ha, GPIO_ADDR_BASE)) {\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("Shift Bar4 to 0x%x failed\n",\r\nGPIO_ADDR_BASE));\r\nreturn -1;\r\n}\r\nregVal = pm8001_cr32(pm8001_ha, 2, GPIO_GPIO_0_0UTPUT_CTL_OFFSET);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("GPIO Output Control Register:"\r\n" = 0x%x\n", regVal));\r\nregVal &= 0xFFFFFFFC;\r\npm8001_cw32(pm8001_ha, 2, GPIO_GPIO_0_0UTPUT_CTL_OFFSET, regVal);\r\nif (-1 == pm8001_bar4_shift(pm8001_ha, SPC_TOP_LEVEL_ADDR_BASE)) {\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("SPC Shift Bar4 to 0x%x failed\n",\r\nSPC_TOP_LEVEL_ADDR_BASE));\r\nreturn -1;\r\n}\r\nregVal = pm8001_cr32(pm8001_ha, 2, SPC_REG_RESET);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("Top Register before resetting IOP/AAP1"\r\n":= 0x%x\n", regVal));\r\nregVal &= ~(SPC_REG_RESET_PCS_IOP_SS | SPC_REG_RESET_PCS_AAP1_SS);\r\npm8001_cw32(pm8001_ha, 2, SPC_REG_RESET, regVal);\r\nregVal = pm8001_cr32(pm8001_ha, 2, SPC_REG_RESET);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("Top Register before resetting BDMA/OSSP"\r\n": = 0x%x\n", regVal));\r\nregVal &= ~(SPC_REG_RESET_BDMA_CORE | SPC_REG_RESET_OSSP);\r\npm8001_cw32(pm8001_ha, 2, SPC_REG_RESET, regVal);\r\nudelay(10);\r\nregVal = pm8001_cr32(pm8001_ha, 2, SPC_REG_RESET);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("Top Register before bringing up BDMA/OSSP"\r\n":= 0x%x\n", regVal));\r\nregVal |= (SPC_REG_RESET_BDMA_CORE | SPC_REG_RESET_OSSP);\r\npm8001_cw32(pm8001_ha, 2, SPC_REG_RESET, regVal);\r\nudelay(10);\r\nif (-1 == pm8001_bar4_shift(pm8001_ha, GSM_ADDR_BASE)) {\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("SPC Shift Bar4 to 0x%x failed\n",\r\nGSM_ADDR_BASE));\r\nreturn -1;\r\n}\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("GSM 0x0 (0x00007b88)-GSM Configuration and "\r\n"Reset = 0x%x\n", pm8001_cr32(pm8001_ha, 2, GSM_CONFIG_RESET)));\r\nregVal = pm8001_cr32(pm8001_ha, 2, GSM_CONFIG_RESET);\r\nregVal |= (GSM_CONFIG_RESET_VALUE);\r\npm8001_cw32(pm8001_ha, 2, GSM_CONFIG_RESET, regVal);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("GSM (0x00004088 ==> 0x00007b88) - GSM"\r\n" Configuration and Reset is set to = 0x%x\n",\r\npm8001_cr32(pm8001_ha, 2, GSM_CONFIG_RESET)));\r\nregVal = pm8001_cr32(pm8001_ha, 2, GSM_READ_ADDR_PARITY_CHECK);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("GSM 0x700038 - Read Address Parity Check Enable"\r\n" = 0x%x\n", regVal));\r\npm8001_cw32(pm8001_ha, 2, GSM_READ_ADDR_PARITY_CHECK, regVal1);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("GSM 0x700038 - Read Address Parity"\r\n" Check Enable is set to = 0x%x\n",\r\npm8001_cr32(pm8001_ha, 2, GSM_READ_ADDR_PARITY_CHECK)));\r\nregVal = pm8001_cr32(pm8001_ha, 2, GSM_WRITE_ADDR_PARITY_CHECK);\r\npm8001_cw32(pm8001_ha, 2, GSM_WRITE_ADDR_PARITY_CHECK, regVal2);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("GSM 0x700040 - Write Address Parity Check"\r\n" Enable is set to = 0x%x\n",\r\npm8001_cr32(pm8001_ha, 2, GSM_WRITE_ADDR_PARITY_CHECK)));\r\nregVal = pm8001_cr32(pm8001_ha, 2, GSM_WRITE_DATA_PARITY_CHECK);\r\npm8001_cw32(pm8001_ha, 2, GSM_WRITE_DATA_PARITY_CHECK, regVal3);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("GSM 0x700048 - Write Data Parity Check Enable"\r\n"is set to = 0x%x\n",\r\npm8001_cr32(pm8001_ha, 2, GSM_WRITE_DATA_PARITY_CHECK)));\r\nif (-1 == pm8001_bar4_shift(pm8001_ha, SPC_TOP_LEVEL_ADDR_BASE)) {\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Shift Bar4 to 0x%x failed\n",\r\nSPC_TOP_LEVEL_ADDR_BASE));\r\nreturn -1;\r\n}\r\nregVal = pm8001_cr32(pm8001_ha, 2, SPC_REG_RESET);\r\nregVal |= (SPC_REG_RESET_PCS_IOP_SS | SPC_REG_RESET_PCS_AAP1_SS);\r\npm8001_cw32(pm8001_ha, 2, SPC_REG_RESET, regVal);\r\nudelay(10);\r\nif (signature == SPC_SOFT_RESET_SIGNATURE) {\r\nmax_wait_count = 2 * 1000 * 1000;\r\ndo {\r\nudelay(1);\r\nregVal = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1) &\r\nSCRATCH_PAD1_RST;\r\n} while ((regVal != toggleVal) && (--max_wait_count));\r\nif (!max_wait_count) {\r\nregVal = pm8001_cr32(pm8001_ha, 0,\r\nMSGU_SCRATCH_PAD_1);\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("TIMEOUT : ToggleVal 0x%x,"\r\n"MSGU_SCRATCH_PAD1 = 0x%x\n",\r\ntoggleVal, regVal));\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("SCRATCH_PAD0 value = 0x%x\n",\r\npm8001_cr32(pm8001_ha, 0,\r\nMSGU_SCRATCH_PAD_0)));\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("SCRATCH_PAD2 value = 0x%x\n",\r\npm8001_cr32(pm8001_ha, 0,\r\nMSGU_SCRATCH_PAD_2)));\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("SCRATCH_PAD3 value = 0x%x\n",\r\npm8001_cr32(pm8001_ha, 0,\r\nMSGU_SCRATCH_PAD_3)));\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nreturn -1;\r\n}\r\npm8001_cw32(pm8001_ha, 0, MSGU_ODCR, ODCR_CLEAR_ALL);\r\npm8001_cw32(pm8001_ha, 0, MSGU_ODMR, ODMR_CLEAR_ALL);\r\nif (check_fw_ready(pm8001_ha) == -1) {\r\nregVal = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("FW not ready SCRATCH_PAD1"\r\n" = 0x%x\n", regVal));\r\nregVal = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_2);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("FW not ready SCRATCH_PAD2"\r\n" = 0x%x\n", regVal));\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("SCRATCH_PAD0 value = 0x%x\n",\r\npm8001_cr32(pm8001_ha, 0,\r\nMSGU_SCRATCH_PAD_0)));\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("SCRATCH_PAD3 value = 0x%x\n",\r\npm8001_cr32(pm8001_ha, 0,\r\nMSGU_SCRATCH_PAD_3)));\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nreturn -1;\r\n}\r\n}\r\npm8001_bar4_shift(pm8001_ha, 0);\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("SPC soft reset Complete\n"));\r\nreturn 0;\r\n}\r\nstatic void pm8001_hw_chip_rst(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu32 i;\r\nu32 regVal;\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("chip reset start\n"));\r\nregVal = pm8001_cr32(pm8001_ha, 1, SPC_REG_RESET);\r\nregVal &= ~(SPC_REG_RESET_DEVICE);\r\npm8001_cw32(pm8001_ha, 1, SPC_REG_RESET, regVal);\r\nudelay(10);\r\nregVal = pm8001_cr32(pm8001_ha, 1, SPC_REG_RESET);\r\nregVal |= SPC_REG_RESET_DEVICE;\r\npm8001_cw32(pm8001_ha, 1, SPC_REG_RESET, regVal);\r\nudelay(10);\r\ni = 20;\r\ndo {\r\nmdelay(1);\r\n} while ((--i) != 0);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("chip reset finished\n"));\r\n}\r\nvoid pm8001_chip_iounmap(struct pm8001_hba_info *pm8001_ha)\r\n{\r\ns8 bar, logical = 0;\r\nfor (bar = 0; bar < 6; bar++) {\r\nif ((bar == 1) || (bar == 3))\r\ncontinue;\r\nif (pm8001_ha->io_mem[logical].memvirtaddr) {\r\niounmap(pm8001_ha->io_mem[logical].memvirtaddr);\r\nlogical++;\r\n}\r\n}\r\n}\r\nstatic void\r\npm8001_chip_intx_interrupt_enable(struct pm8001_hba_info *pm8001_ha)\r\n{\r\npm8001_cw32(pm8001_ha, 0, MSGU_ODMR, ODMR_CLEAR_ALL);\r\npm8001_cw32(pm8001_ha, 0, MSGU_ODCR, ODCR_CLEAR_ALL);\r\n}\r\nstatic void\r\npm8001_chip_intx_interrupt_disable(struct pm8001_hba_info *pm8001_ha)\r\n{\r\npm8001_cw32(pm8001_ha, 0, MSGU_ODMR, ODMR_MASK_ALL);\r\n}\r\nstatic void\r\npm8001_chip_msix_interrupt_enable(struct pm8001_hba_info *pm8001_ha,\r\nu32 int_vec_idx)\r\n{\r\nu32 msi_index;\r\nu32 value;\r\nmsi_index = int_vec_idx * MSIX_TABLE_ELEMENT_SIZE;\r\nmsi_index += MSIX_TABLE_BASE;\r\npm8001_cw32(pm8001_ha, 0, msi_index, MSIX_INTERRUPT_ENABLE);\r\nvalue = (1 << int_vec_idx);\r\npm8001_cw32(pm8001_ha, 0, MSGU_ODCR, value);\r\n}\r\nstatic void\r\npm8001_chip_msix_interrupt_disable(struct pm8001_hba_info *pm8001_ha,\r\nu32 int_vec_idx)\r\n{\r\nu32 msi_index;\r\nmsi_index = int_vec_idx * MSIX_TABLE_ELEMENT_SIZE;\r\nmsi_index += MSIX_TABLE_BASE;\r\npm8001_cw32(pm8001_ha, 0, msi_index, MSIX_INTERRUPT_DISABLE);\r\n}\r\nstatic void\r\npm8001_chip_interrupt_enable(struct pm8001_hba_info *pm8001_ha, u8 vec)\r\n{\r\n#ifdef PM8001_USE_MSIX\r\npm8001_chip_msix_interrupt_enable(pm8001_ha, 0);\r\nreturn;\r\n#endif\r\npm8001_chip_intx_interrupt_enable(pm8001_ha);\r\n}\r\nstatic void\r\npm8001_chip_interrupt_disable(struct pm8001_hba_info *pm8001_ha, u8 vec)\r\n{\r\n#ifdef PM8001_USE_MSIX\r\npm8001_chip_msix_interrupt_disable(pm8001_ha, 0);\r\nreturn;\r\n#endif\r\npm8001_chip_intx_interrupt_disable(pm8001_ha);\r\n}\r\nint pm8001_mpi_msg_free_get(struct inbound_queue_table *circularQ,\r\nu16 messageSize, void **messagePtr)\r\n{\r\nu32 offset, consumer_index;\r\nstruct mpi_msg_hdr *msgHeader;\r\nu8 bcCount = 1;\r\nif (messageSize > IOMB_SIZE_SPCV) {\r\n*messagePtr = NULL;\r\nreturn -1;\r\n}\r\nconsumer_index = pm8001_read_32(circularQ->ci_virt);\r\ncircularQ->consumer_index = cpu_to_le32(consumer_index);\r\nif (((circularQ->producer_idx + bcCount) % PM8001_MPI_QUEUE) ==\r\nle32_to_cpu(circularQ->consumer_index)) {\r\n*messagePtr = NULL;\r\nreturn -1;\r\n}\r\noffset = circularQ->producer_idx * messageSize;\r\ncircularQ->producer_idx = (circularQ->producer_idx + bcCount)\r\n% PM8001_MPI_QUEUE;\r\nmsgHeader = (struct mpi_msg_hdr *)(circularQ->base_virt + offset);\r\n*messagePtr = ((void *)msgHeader) + sizeof(struct mpi_msg_hdr);\r\nreturn 0;\r\n}\r\nint pm8001_mpi_build_cmd(struct pm8001_hba_info *pm8001_ha,\r\nstruct inbound_queue_table *circularQ,\r\nu32 opCode, void *payload, u32 responseQueue)\r\n{\r\nu32 Header = 0, hpriority = 0, bc = 1, category = 0x02;\r\nvoid *pMessage;\r\nif (pm8001_mpi_msg_free_get(circularQ, pm8001_ha->iomb_size,\r\n&pMessage) < 0) {\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("No free mpi buffer\n"));\r\nreturn -1;\r\n}\r\nBUG_ON(!payload);\r\nmemcpy(pMessage, payload, (pm8001_ha->iomb_size -\r\nsizeof(struct mpi_msg_hdr)));\r\nHeader = ((1 << 31) | (hpriority << 30) | ((bc & 0x1f) << 24)\r\n| ((responseQueue & 0x3F) << 16)\r\n| ((category & 0xF) << 12) | (opCode & 0xFFF));\r\npm8001_write_32((pMessage - 4), 0, cpu_to_le32(Header));\r\npm8001_cw32(pm8001_ha, circularQ->pi_pci_bar,\r\ncircularQ->pi_offset, circularQ->producer_idx);\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("INB Q %x OPCODE:%x , UPDATED PI=%d CI=%d\n",\r\nresponseQueue, opCode, circularQ->producer_idx,\r\ncircularQ->consumer_index));\r\nreturn 0;\r\n}\r\nu32 pm8001_mpi_msg_free_set(struct pm8001_hba_info *pm8001_ha, void *pMsg,\r\nstruct outbound_queue_table *circularQ, u8 bc)\r\n{\r\nu32 producer_index;\r\nstruct mpi_msg_hdr *msgHeader;\r\nstruct mpi_msg_hdr *pOutBoundMsgHeader;\r\nmsgHeader = (struct mpi_msg_hdr *)(pMsg - sizeof(struct mpi_msg_hdr));\r\npOutBoundMsgHeader = (struct mpi_msg_hdr *)(circularQ->base_virt +\r\ncircularQ->consumer_idx * pm8001_ha->iomb_size);\r\nif (pOutBoundMsgHeader != msgHeader) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("consumer_idx = %d msgHeader = %p\n",\r\ncircularQ->consumer_idx, msgHeader));\r\nproducer_index = pm8001_read_32(circularQ->pi_virt);\r\ncircularQ->producer_index = cpu_to_le32(producer_index);\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("consumer_idx = %d producer_index = %d"\r\n"msgHeader = %p\n", circularQ->consumer_idx,\r\ncircularQ->producer_index, msgHeader));\r\nreturn 0;\r\n}\r\ncircularQ->consumer_idx = (circularQ->consumer_idx + bc)\r\n% PM8001_MPI_QUEUE;\r\npm8001_cw32(pm8001_ha, circularQ->ci_pci_bar, circularQ->ci_offset,\r\ncircularQ->consumer_idx);\r\nproducer_index = pm8001_read_32(circularQ->pi_virt);\r\ncircularQ->producer_index = cpu_to_le32(producer_index);\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk(" CI=%d PI=%d\n", circularQ->consumer_idx,\r\ncircularQ->producer_index));\r\nreturn 0;\r\n}\r\nu32 pm8001_mpi_msg_consume(struct pm8001_hba_info *pm8001_ha,\r\nstruct outbound_queue_table *circularQ,\r\nvoid **messagePtr1, u8 *pBC)\r\n{\r\nstruct mpi_msg_hdr *msgHeader;\r\n__le32 msgHeader_tmp;\r\nu32 header_tmp;\r\ndo {\r\nif (le32_to_cpu(circularQ->producer_index)\r\n!= circularQ->consumer_idx) {\r\nmsgHeader = (struct mpi_msg_hdr *)\r\n(circularQ->base_virt +\r\ncircularQ->consumer_idx * pm8001_ha->iomb_size);\r\nheader_tmp = pm8001_read_32(msgHeader);\r\nmsgHeader_tmp = cpu_to_le32(header_tmp);\r\nif (0 != (le32_to_cpu(msgHeader_tmp) & 0x80000000)) {\r\nif (OPC_OUB_SKIP_ENTRY !=\r\n(le32_to_cpu(msgHeader_tmp) & 0xfff)) {\r\n*messagePtr1 =\r\n((u8 *)msgHeader) +\r\nsizeof(struct mpi_msg_hdr);\r\n*pBC = (u8)((le32_to_cpu(msgHeader_tmp)\r\n>> 24) & 0x1f);\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk(": CI=%d PI=%d "\r\n"msgHeader=%x\n",\r\ncircularQ->consumer_idx,\r\ncircularQ->producer_index,\r\nmsgHeader_tmp));\r\nreturn MPI_IO_STATUS_SUCCESS;\r\n} else {\r\ncircularQ->consumer_idx =\r\n(circularQ->consumer_idx +\r\n((le32_to_cpu(msgHeader_tmp)\r\n>> 24) & 0x1f))\r\n% PM8001_MPI_QUEUE;\r\nmsgHeader_tmp = 0;\r\npm8001_write_32(msgHeader, 0, 0);\r\npm8001_cw32(pm8001_ha,\r\ncircularQ->ci_pci_bar,\r\ncircularQ->ci_offset,\r\ncircularQ->consumer_idx);\r\n}\r\n} else {\r\ncircularQ->consumer_idx =\r\n(circularQ->consumer_idx +\r\n((le32_to_cpu(msgHeader_tmp) >> 24) &\r\n0x1f)) % PM8001_MPI_QUEUE;\r\nmsgHeader_tmp = 0;\r\npm8001_write_32(msgHeader, 0, 0);\r\npm8001_cw32(pm8001_ha, circularQ->ci_pci_bar,\r\ncircularQ->ci_offset,\r\ncircularQ->consumer_idx);\r\nreturn MPI_IO_STATUS_FAIL;\r\n}\r\n} else {\r\nu32 producer_index;\r\nvoid *pi_virt = circularQ->pi_virt;\r\nproducer_index = pm8001_read_32(pi_virt);\r\ncircularQ->producer_index = cpu_to_le32(producer_index);\r\n}\r\n} while (le32_to_cpu(circularQ->producer_index) !=\r\ncircularQ->consumer_idx);\r\nreturn MPI_IO_STATUS_BUSY;\r\n}\r\nvoid pm8001_work_fn(struct work_struct *work)\r\n{\r\nstruct pm8001_work *pw = container_of(work, struct pm8001_work, work);\r\nstruct pm8001_device *pm8001_dev;\r\nstruct domain_device *dev;\r\npm8001_dev = pw->data;\r\nif ((pm8001_dev == NULL)\r\n|| ((pw->handler != IO_XFER_ERROR_BREAK)\r\n&& (pm8001_dev->dev_type == SAS_PHY_UNUSED))) {\r\nkfree(pw);\r\nreturn;\r\n}\r\nswitch (pw->handler) {\r\ncase IO_XFER_ERROR_BREAK:\r\n{\r\nstruct sas_task *t = (struct sas_task *)pm8001_dev;\r\nu32 tag;\r\nstruct pm8001_ccb_info *ccb;\r\nstruct pm8001_hba_info *pm8001_ha = pw->pm8001_ha;\r\nunsigned long flags, flags1;\r\nstruct task_status_struct *ts;\r\nint i;\r\nif (pm8001_query_task(t) == TMF_RESP_FUNC_SUCC)\r\nbreak;\r\nspin_lock_irqsave(&pm8001_ha->lock, flags);\r\nspin_lock_irqsave(&t->task_state_lock, flags1);\r\nif (unlikely((t->task_state_flags & SAS_TASK_STATE_DONE))) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags1);\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&t->task_state_lock, flags1);\r\nfor (i = 0; ccb = NULL, i < PM8001_MAX_CCB; i++) {\r\nccb = &pm8001_ha->ccb_info[i];\r\ntag = ccb->ccb_tag;\r\nif ((tag != 0xFFFFFFFF) && (ccb->task == t))\r\nbreak;\r\n}\r\nif (!ccb) {\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nbreak;\r\n}\r\nts = &t->task_status;\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_QUEUE_FULL;\r\npm8001_dev = ccb->device;\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nspin_lock_irqsave(&t->task_state_lock, flags1);\r\nt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\r\nt->task_state_flags &= ~SAS_TASK_AT_INITIATOR;\r\nt->task_state_flags |= SAS_TASK_STATE_DONE;\r\nif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags1);\r\nPM8001_FAIL_DBG(pm8001_ha, pm8001_printk("task 0x%p"\r\n" done with event 0x%x resp 0x%x stat 0x%x but"\r\n" aborted by upper layer!\n",\r\nt, pw->handler, ts->resp, ts->stat));\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\n} else {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags1);\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nt->task_done(t);\r\n}\r\n} break;\r\ncase IO_XFER_OPEN_RETRY_TIMEOUT:\r\n{\r\nstruct sas_task *t = (struct sas_task *)pm8001_dev;\r\nu32 tag;\r\nstruct pm8001_ccb_info *ccb;\r\nstruct pm8001_hba_info *pm8001_ha = pw->pm8001_ha;\r\nunsigned long flags, flags1;\r\nint i, ret = 0;\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_OPEN_RETRY_TIMEOUT\n"));\r\nret = pm8001_query_task(t);\r\nPM8001_IO_DBG(pm8001_ha,\r\nswitch (ret) {\r\ncase TMF_RESP_FUNC_SUCC:\r\npm8001_printk("...Task on lu\n");\r\nbreak;\r\ncase TMF_RESP_FUNC_COMPLETE:\r\npm8001_printk("...Task NOT on lu\n");\r\nbreak;\r\ndefault:\r\npm8001_printk("...query task failed!!!\n");\r\nbreak;\r\n});\r\nspin_lock_irqsave(&pm8001_ha->lock, flags);\r\nspin_lock_irqsave(&t->task_state_lock, flags1);\r\nif (unlikely((t->task_state_flags & SAS_TASK_STATE_DONE))) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags1);\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nif (ret == TMF_RESP_FUNC_SUCC)\r\n(void)pm8001_abort_task(t);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&t->task_state_lock, flags1);\r\nfor (i = 0; ccb = NULL, i < PM8001_MAX_CCB; i++) {\r\nccb = &pm8001_ha->ccb_info[i];\r\ntag = ccb->ccb_tag;\r\nif ((tag != 0xFFFFFFFF) && (ccb->task == t))\r\nbreak;\r\n}\r\nif (!ccb) {\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nif (ret == TMF_RESP_FUNC_SUCC)\r\n(void)pm8001_abort_task(t);\r\nbreak;\r\n}\r\npm8001_dev = ccb->device;\r\ndev = pm8001_dev->sas_device;\r\nswitch (ret) {\r\ncase TMF_RESP_FUNC_SUCC:\r\nccb->open_retry = 1;\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nret = pm8001_abort_task(t);\r\nccb->open_retry = 0;\r\nswitch (ret) {\r\ncase TMF_RESP_FUNC_SUCC:\r\ncase TMF_RESP_FUNC_COMPLETE:\r\nbreak;\r\ndefault:\r\nret = TMF_RESP_FUNC_FAILED;\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("...Reset phy\n"));\r\npm8001_I_T_nexus_reset(dev);\r\nbreak;\r\n}\r\nbreak;\r\ncase TMF_RESP_FUNC_COMPLETE:\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nbreak;\r\ndefault:\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nret = TMF_RESP_FUNC_FAILED;\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("...Reset phy\n"));\r\npm8001_I_T_nexus_reset(dev);\r\n}\r\nif (ret == TMF_RESP_FUNC_FAILED)\r\nt = NULL;\r\npm8001_open_reject_retry(pm8001_ha, t, pm8001_dev);\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("...Complete\n"));\r\n} break;\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\r\ndev = pm8001_dev->sas_device;\r\npm8001_I_T_nexus_event_handler(dev);\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_STP_RESOURCES_BUSY:\r\ndev = pm8001_dev->sas_device;\r\npm8001_I_T_nexus_reset(dev);\r\nbreak;\r\ncase IO_DS_IN_ERROR:\r\ndev = pm8001_dev->sas_device;\r\npm8001_I_T_nexus_reset(dev);\r\nbreak;\r\ncase IO_DS_NON_OPERATIONAL:\r\ndev = pm8001_dev->sas_device;\r\npm8001_I_T_nexus_reset(dev);\r\nbreak;\r\n}\r\nkfree(pw);\r\n}\r\nint pm8001_handle_event(struct pm8001_hba_info *pm8001_ha, void *data,\r\nint handler)\r\n{\r\nstruct pm8001_work *pw;\r\nint ret = 0;\r\npw = kmalloc(sizeof(struct pm8001_work), GFP_ATOMIC);\r\nif (pw) {\r\npw->pm8001_ha = pm8001_ha;\r\npw->data = data;\r\npw->handler = handler;\r\nINIT_WORK(&pw->work, pm8001_work_fn);\r\nqueue_work(pm8001_wq, &pw->work);\r\n} else\r\nret = -ENOMEM;\r\nreturn ret;\r\n}\r\nstatic void pm8001_send_abort_all(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_device *pm8001_ha_dev)\r\n{\r\nint res;\r\nu32 ccb_tag;\r\nstruct pm8001_ccb_info *ccb;\r\nstruct sas_task *task = NULL;\r\nstruct task_abort_req task_abort;\r\nstruct inbound_queue_table *circularQ;\r\nu32 opc = OPC_INB_SATA_ABORT;\r\nint ret;\r\nif (!pm8001_ha_dev) {\r\nPM8001_FAIL_DBG(pm8001_ha, pm8001_printk("dev is null\n"));\r\nreturn;\r\n}\r\ntask = sas_alloc_slow_task(GFP_ATOMIC);\r\nif (!task) {\r\nPM8001_FAIL_DBG(pm8001_ha, pm8001_printk("cannot "\r\n"allocate task\n"));\r\nreturn;\r\n}\r\ntask->task_done = pm8001_task_done;\r\nres = pm8001_tag_alloc(pm8001_ha, &ccb_tag);\r\nif (res)\r\nreturn;\r\nccb = &pm8001_ha->ccb_info[ccb_tag];\r\nccb->device = pm8001_ha_dev;\r\nccb->ccb_tag = ccb_tag;\r\nccb->task = task;\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nmemset(&task_abort, 0, sizeof(task_abort));\r\ntask_abort.abort_all = cpu_to_le32(1);\r\ntask_abort.device_id = cpu_to_le32(pm8001_ha_dev->device_id);\r\ntask_abort.tag = cpu_to_le32(ccb_tag);\r\nret = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &task_abort, 0);\r\n}\r\nstatic void pm8001_send_read_log(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_device *pm8001_ha_dev)\r\n{\r\nstruct sata_start_req sata_cmd;\r\nint res;\r\nu32 ccb_tag;\r\nstruct pm8001_ccb_info *ccb;\r\nstruct sas_task *task = NULL;\r\nstruct host_to_dev_fis fis;\r\nstruct domain_device *dev;\r\nstruct inbound_queue_table *circularQ;\r\nu32 opc = OPC_INB_SATA_HOST_OPSTART;\r\ntask = sas_alloc_slow_task(GFP_ATOMIC);\r\nif (!task) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("cannot allocate task !!!\n"));\r\nreturn;\r\n}\r\ntask->task_done = pm8001_task_done;\r\nres = pm8001_tag_alloc(pm8001_ha, &ccb_tag);\r\nif (res) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("cannot allocate tag !!!\n"));\r\nreturn;\r\n}\r\ndev = kzalloc(sizeof(struct domain_device), GFP_ATOMIC);\r\nif (!dev) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Domain device cannot be allocated\n"));\r\nsas_free_task(task);\r\nreturn;\r\n} else {\r\ntask->dev = dev;\r\ntask->dev->lldd_dev = pm8001_ha_dev;\r\n}\r\nccb = &pm8001_ha->ccb_info[ccb_tag];\r\nccb->device = pm8001_ha_dev;\r\nccb->ccb_tag = ccb_tag;\r\nccb->task = task;\r\npm8001_ha_dev->id |= NCQ_READ_LOG_FLAG;\r\npm8001_ha_dev->id |= NCQ_2ND_RLE_FLAG;\r\nmemset(&sata_cmd, 0, sizeof(sata_cmd));\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nmemset(&fis, 0, sizeof(struct host_to_dev_fis));\r\nfis.fis_type = 0x27;\r\nfis.flags = 0x80;\r\nfis.command = ATA_CMD_READ_LOG_EXT;\r\nfis.lbal = 0x10;\r\nfis.sector_count = 0x1;\r\nsata_cmd.tag = cpu_to_le32(ccb_tag);\r\nsata_cmd.device_id = cpu_to_le32(pm8001_ha_dev->device_id);\r\nsata_cmd.ncqtag_atap_dir_m |= ((0x1 << 7) | (0x5 << 9));\r\nmemcpy(&sata_cmd.sata_fis, &fis, sizeof(struct host_to_dev_fis));\r\nres = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &sata_cmd, 0);\r\n}\r\nstatic void\r\nmpi_ssp_completion(struct pm8001_hba_info *pm8001_ha , void *piomb)\r\n{\r\nstruct sas_task *t;\r\nstruct pm8001_ccb_info *ccb;\r\nunsigned long flags;\r\nu32 status;\r\nu32 param;\r\nu32 tag;\r\nstruct ssp_completion_resp *psspPayload;\r\nstruct task_status_struct *ts;\r\nstruct ssp_response_iu *iu;\r\nstruct pm8001_device *pm8001_dev;\r\npsspPayload = (struct ssp_completion_resp *)(piomb + 4);\r\nstatus = le32_to_cpu(psspPayload->status);\r\ntag = le32_to_cpu(psspPayload->tag);\r\nccb = &pm8001_ha->ccb_info[tag];\r\nif ((status == IO_ABORTED) && ccb->open_retry) {\r\nccb->open_retry = 0;\r\nreturn;\r\n}\r\npm8001_dev = ccb->device;\r\nparam = le32_to_cpu(psspPayload->param);\r\nt = ccb->task;\r\nif (status && status != IO_UNDERFLOW)\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("sas IO status 0x%x\n", status));\r\nif (unlikely(!t || !t->lldd_task || !t->dev))\r\nreturn;\r\nts = &t->task_status;\r\nswitch (status) {\r\ncase IO_SUCCESS:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("IO_SUCCESS"\r\n",param = %d\n", param));\r\nif (param == 0) {\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAM_STAT_GOOD;\r\n} else {\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_PROTO_RESPONSE;\r\nts->residual = param;\r\niu = &psspPayload->ssp_resp_iu;\r\nsas_ssp_task_response(pm8001_ha->dev, t, iu);\r\n}\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nbreak;\r\ncase IO_ABORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_ABORTED IOMB Tag\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_ABORTED_TASK;\r\nbreak;\r\ncase IO_UNDERFLOW:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("IO_UNDERFLOW"\r\n",param = %d\n", param));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_UNDERRUN;\r\nts->residual = param;\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nbreak;\r\ncase IO_NO_DEVICE:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_NO_DEVICE\n"));\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_PHY_DOWN;\r\nbreak;\r\ncase IO_XFER_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_BREAK\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_XFER_ERROR_PHY_NOT_READY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_PHY_NOT_READY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_EPROTO;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_ZONE_VIOLATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BREAK\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\nif (!t->uldd_task)\r\npm8001_handle_event(pm8001_ha,\r\npm8001_dev,\r\nIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BAD_DESTINATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_BAD_DEST;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_CONNECTION_RATE_"\r\n"NOT_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_CONN_RATE;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_WRONG_DESTINATION\n"));\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_WRONG_DEST;\r\nbreak;\r\ncase IO_XFER_ERROR_NAK_RECEIVED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_NAK_RECEIVED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_XFER_ERROR_ACK_NAK_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_ACK_NAK_TIMEOUT\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_NAK_R_ERR;\r\nbreak;\r\ncase IO_XFER_ERROR_DMA:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_DMA\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nbreak;\r\ncase IO_XFER_OPEN_RETRY_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_OPEN_RETRY_TIMEOUT\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_XFER_ERROR_OFFSET_MISMATCH:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_OFFSET_MISMATCH\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nbreak;\r\ncase IO_PORT_IN_RESET:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_PORT_IN_RESET\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nbreak;\r\ncase IO_DS_NON_OPERATIONAL:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_DS_NON_OPERATIONAL\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nif (!t->uldd_task)\r\npm8001_handle_event(pm8001_ha,\r\npm8001_dev,\r\nIO_DS_NON_OPERATIONAL);\r\nbreak;\r\ncase IO_DS_IN_RECOVERY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_DS_IN_RECOVERY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nbreak;\r\ncase IO_TM_TAG_NOT_FOUND:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_TM_TAG_NOT_FOUND\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nbreak;\r\ncase IO_SSP_EXT_IU_ZERO_LEN_ERROR:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_SSP_EXT_IU_ZERO_LEN_ERROR\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ndefault:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("Unknown status 0x%x\n", status));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nbreak;\r\n}\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("scsi_status = %x\n ",\r\npsspPayload->ssp_resp_iu.status));\r\nspin_lock_irqsave(&t->task_state_lock, flags);\r\nt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\r\nt->task_state_flags &= ~SAS_TASK_AT_INITIATOR;\r\nt->task_state_flags |= SAS_TASK_STATE_DONE;\r\nif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\nPM8001_FAIL_DBG(pm8001_ha, pm8001_printk("task 0x%p done with"\r\n" io_status 0x%x resp 0x%x "\r\n"stat 0x%x but aborted by upper layer!\n",\r\nt, status, ts->resp, ts->stat));\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\n} else {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nt->task_done(t);\r\n}\r\n}\r\nstatic void mpi_ssp_event(struct pm8001_hba_info *pm8001_ha , void *piomb)\r\n{\r\nstruct sas_task *t;\r\nunsigned long flags;\r\nstruct task_status_struct *ts;\r\nstruct pm8001_ccb_info *ccb;\r\nstruct pm8001_device *pm8001_dev;\r\nstruct ssp_event_resp *psspPayload =\r\n(struct ssp_event_resp *)(piomb + 4);\r\nu32 event = le32_to_cpu(psspPayload->event);\r\nu32 tag = le32_to_cpu(psspPayload->tag);\r\nu32 port_id = le32_to_cpu(psspPayload->port_id);\r\nu32 dev_id = le32_to_cpu(psspPayload->device_id);\r\nccb = &pm8001_ha->ccb_info[tag];\r\nt = ccb->task;\r\npm8001_dev = ccb->device;\r\nif (event)\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("sas IO status 0x%x\n", event));\r\nif (unlikely(!t || !t->lldd_task || !t->dev))\r\nreturn;\r\nts = &t->task_status;\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("port_id = %x,device_id = %x\n",\r\nport_id, dev_id));\r\nswitch (event) {\r\ncase IO_OVERFLOW:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("IO_UNDERFLOW\n");)\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nts->residual = 0;\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nbreak;\r\ncase IO_XFER_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_BREAK\n"));\r\npm8001_handle_event(pm8001_ha, t, IO_XFER_ERROR_BREAK);\r\nreturn;\r\ncase IO_XFER_ERROR_PHY_NOT_READY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_PHY_NOT_READY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_PROTOCOL_NOT"\r\n"_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_EPROTO;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_ZONE_VIOLATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BREAK\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\nif (!t->uldd_task)\r\npm8001_handle_event(pm8001_ha,\r\npm8001_dev,\r\nIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BAD_DESTINATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_BAD_DEST;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_CONNECTION_RATE_"\r\n"NOT_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_CONN_RATE;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_WRONG_DESTINATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_WRONG_DEST;\r\nbreak;\r\ncase IO_XFER_ERROR_NAK_RECEIVED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_NAK_RECEIVED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_XFER_ERROR_ACK_NAK_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_ACK_NAK_TIMEOUT\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_NAK_R_ERR;\r\nbreak;\r\ncase IO_XFER_OPEN_RETRY_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_OPEN_RETRY_TIMEOUT\n"));\r\npm8001_handle_event(pm8001_ha, t, IO_XFER_OPEN_RETRY_TIMEOUT);\r\nreturn;\r\ncase IO_XFER_ERROR_UNEXPECTED_PHASE:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_UNEXPECTED_PHASE\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nbreak;\r\ncase IO_XFER_ERROR_XFER_RDY_OVERRUN:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_XFER_RDY_OVERRUN\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nbreak;\r\ncase IO_XFER_ERROR_XFER_RDY_NOT_EXPECTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_XFER_RDY_NOT_EXPECTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nbreak;\r\ncase IO_XFER_ERROR_CMD_ISSUE_ACK_NAK_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_CMD_ISSUE_ACK_NAK_TIMEOUT\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nbreak;\r\ncase IO_XFER_ERROR_OFFSET_MISMATCH:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_OFFSET_MISMATCH\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nbreak;\r\ncase IO_XFER_ERROR_XFER_ZERO_DATA_LEN:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_XFER_ZERO_DATA_LEN\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nbreak;\r\ncase IO_XFER_CMD_FRAME_ISSUED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk(" IO_XFER_CMD_FRAME_ISSUED\n"));\r\nreturn;\r\ndefault:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("Unknown status 0x%x\n", event));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&t->task_state_lock, flags);\r\nt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\r\nt->task_state_flags &= ~SAS_TASK_AT_INITIATOR;\r\nt->task_state_flags |= SAS_TASK_STATE_DONE;\r\nif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\nPM8001_FAIL_DBG(pm8001_ha, pm8001_printk("task 0x%p done with"\r\n" event 0x%x resp 0x%x "\r\n"stat 0x%x but aborted by upper layer!\n",\r\nt, event, ts->resp, ts->stat));\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\n} else {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nt->task_done(t);\r\n}\r\n}\r\nstatic void\r\nmpi_sata_completion(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nstruct sas_task *t;\r\nstruct pm8001_ccb_info *ccb;\r\nu32 param;\r\nu32 status;\r\nu32 tag;\r\nstruct sata_completion_resp *psataPayload;\r\nstruct task_status_struct *ts;\r\nstruct ata_task_resp *resp ;\r\nu32 *sata_resp;\r\nstruct pm8001_device *pm8001_dev;\r\nunsigned long flags;\r\npsataPayload = (struct sata_completion_resp *)(piomb + 4);\r\nstatus = le32_to_cpu(psataPayload->status);\r\ntag = le32_to_cpu(psataPayload->tag);\r\nif (!tag) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("tag null\n"));\r\nreturn;\r\n}\r\nccb = &pm8001_ha->ccb_info[tag];\r\nparam = le32_to_cpu(psataPayload->param);\r\nif (ccb) {\r\nt = ccb->task;\r\npm8001_dev = ccb->device;\r\n} else {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("ccb null\n"));\r\nreturn;\r\n}\r\nif (t) {\r\nif (t->dev && (t->dev->lldd_dev))\r\npm8001_dev = t->dev->lldd_dev;\r\n} else {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("task null\n"));\r\nreturn;\r\n}\r\nif ((pm8001_dev && !(pm8001_dev->id & NCQ_READ_LOG_FLAG))\r\n&& unlikely(!t || !t->lldd_task || !t->dev)) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("task or dev null\n"));\r\nreturn;\r\n}\r\nts = &t->task_status;\r\nif (!ts) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("ts null\n"));\r\nreturn;\r\n}\r\nswitch (status) {\r\ncase IO_SUCCESS:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("IO_SUCCESS\n"));\r\nif (param == 0) {\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAM_STAT_GOOD;\r\nif (pm8001_dev &&\r\n(pm8001_dev->id & NCQ_READ_LOG_FLAG)) {\r\npm8001_dev->id |= NCQ_ABORT_ALL_FLAG;\r\npm8001_dev->id = pm8001_dev->id & 0x7FFFFFFF;\r\npm8001_send_abort_all(pm8001_ha, pm8001_dev);\r\npm8001_tag_free(pm8001_ha, tag);\r\nsas_free_task(t);\r\nreturn;\r\n}\r\n} else {\r\nu8 len;\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_PROTO_RESPONSE;\r\nts->residual = param;\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("SAS_PROTO_RESPONSE len = %d\n",\r\nparam));\r\nsata_resp = &psataPayload->sata_resp[0];\r\nresp = (struct ata_task_resp *)ts->buf;\r\nif (t->ata_task.dma_xfer == 0 &&\r\nt->data_dir == PCI_DMA_FROMDEVICE) {\r\nlen = sizeof(struct pio_setup_fis);\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("PIO read len = %d\n", len));\r\n} else if (t->ata_task.use_ncq) {\r\nlen = sizeof(struct set_dev_bits_fis);\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("FPDMA len = %d\n", len));\r\n} else {\r\nlen = sizeof(struct dev_to_host_fis);\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("other len = %d\n", len));\r\n}\r\nif (SAS_STATUS_BUF_SIZE >= sizeof(*resp)) {\r\nresp->frame_len = len;\r\nmemcpy(&resp->ending_fis[0], sata_resp, len);\r\nts->buf_valid_size = sizeof(*resp);\r\n} else\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("response to large\n"));\r\n}\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nbreak;\r\ncase IO_ABORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_ABORTED IOMB Tag\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_ABORTED_TASK;\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nbreak;\r\ncase IO_UNDERFLOW:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_UNDERFLOW param = %d\n", param));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_UNDERRUN;\r\nts->residual = param;\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nbreak;\r\ncase IO_NO_DEVICE:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_NO_DEVICE\n"));\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_PHY_DOWN;\r\nbreak;\r\ncase IO_XFER_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_BREAK\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_INTERRUPTED;\r\nbreak;\r\ncase IO_XFER_ERROR_PHY_NOT_READY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_PHY_NOT_READY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_PROTOCOL_NOT"\r\n"_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_EPROTO;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_ZONE_VIOLATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BREAK\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_CONT0;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nif (!t->uldd_task) {\r\npm8001_handle_event(pm8001_ha,\r\npm8001_dev,\r\nIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_QUEUE_FULL;\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\nreturn;\r\n}\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BAD_DESTINATION\n"));\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_BAD_DEST;\r\nif (!t->uldd_task) {\r\npm8001_handle_event(pm8001_ha,\r\npm8001_dev,\r\nIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_QUEUE_FULL;\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\nreturn;\r\n}\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_CONNECTION_RATE_"\r\n"NOT_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_CONN_RATE;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_STP_RESOURCES_BUSY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_STP_RESOURCES"\r\n"_BUSY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nif (!t->uldd_task) {\r\npm8001_handle_event(pm8001_ha,\r\npm8001_dev,\r\nIO_OPEN_CNX_ERROR_STP_RESOURCES_BUSY);\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_QUEUE_FULL;\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\nreturn;\r\n}\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_WRONG_DESTINATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_WRONG_DEST;\r\nbreak;\r\ncase IO_XFER_ERROR_NAK_RECEIVED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_NAK_RECEIVED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_NAK_R_ERR;\r\nbreak;\r\ncase IO_XFER_ERROR_ACK_NAK_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_ACK_NAK_TIMEOUT\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_NAK_R_ERR;\r\nbreak;\r\ncase IO_XFER_ERROR_DMA:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_DMA\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_ABORTED_TASK;\r\nbreak;\r\ncase IO_XFER_ERROR_SATA_LINK_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_SATA_LINK_TIMEOUT\n"));\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nbreak;\r\ncase IO_XFER_ERROR_REJECTED_NCQ_MODE:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_REJECTED_NCQ_MODE\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_UNDERRUN;\r\nbreak;\r\ncase IO_XFER_OPEN_RETRY_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_OPEN_RETRY_TIMEOUT\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\ncase IO_PORT_IN_RESET:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_PORT_IN_RESET\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nbreak;\r\ncase IO_DS_NON_OPERATIONAL:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_DS_NON_OPERATIONAL\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nif (!t->uldd_task) {\r\npm8001_handle_event(pm8001_ha, pm8001_dev,\r\nIO_DS_NON_OPERATIONAL);\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_QUEUE_FULL;\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\nreturn;\r\n}\r\nbreak;\r\ncase IO_DS_IN_RECOVERY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk(" IO_DS_IN_RECOVERY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nbreak;\r\ncase IO_DS_IN_ERROR:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_DS_IN_ERROR\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nif (!t->uldd_task) {\r\npm8001_handle_event(pm8001_ha, pm8001_dev,\r\nIO_DS_IN_ERROR);\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_QUEUE_FULL;\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\nreturn;\r\n}\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\ndefault:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("Unknown status 0x%x\n", status));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&t->task_state_lock, flags);\r\nt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\r\nt->task_state_flags &= ~SAS_TASK_AT_INITIATOR;\r\nt->task_state_flags |= SAS_TASK_STATE_DONE;\r\nif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("task 0x%p done with io_status 0x%x"\r\n" resp 0x%x stat 0x%x but aborted by upper layer!\n",\r\nt, status, ts->resp, ts->stat));\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\n} else if (t->uldd_task) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\n} else if (!t->uldd_task) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\n}\r\n}\r\nstatic void mpi_sata_event(struct pm8001_hba_info *pm8001_ha , void *piomb)\r\n{\r\nstruct sas_task *t;\r\nstruct task_status_struct *ts;\r\nstruct pm8001_ccb_info *ccb;\r\nstruct pm8001_device *pm8001_dev;\r\nstruct sata_event_resp *psataPayload =\r\n(struct sata_event_resp *)(piomb + 4);\r\nu32 event = le32_to_cpu(psataPayload->event);\r\nu32 tag = le32_to_cpu(psataPayload->tag);\r\nu32 port_id = le32_to_cpu(psataPayload->port_id);\r\nu32 dev_id = le32_to_cpu(psataPayload->device_id);\r\nunsigned long flags;\r\nccb = &pm8001_ha->ccb_info[tag];\r\nif (ccb) {\r\nt = ccb->task;\r\npm8001_dev = ccb->device;\r\n} else {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("No CCB !!!. returning\n"));\r\n}\r\nif (event)\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("SATA EVENT 0x%x\n", event));\r\nif (event == IO_XFER_ERROR_ABORTED_NCQ_MODE) {\r\npm8001_dev = pm8001_find_dev(pm8001_ha, dev_id);\r\nif (pm8001_dev)\r\npm8001_send_read_log(pm8001_ha, pm8001_dev);\r\nreturn;\r\n}\r\nccb = &pm8001_ha->ccb_info[tag];\r\nt = ccb->task;\r\npm8001_dev = ccb->device;\r\nif (event)\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("sata IO status 0x%x\n", event));\r\nif (unlikely(!t || !t->lldd_task || !t->dev))\r\nreturn;\r\nts = &t->task_status;\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"port_id:0x%x, device_id:0x%x, tag:0x%x, event:0x%x\n",\r\nport_id, dev_id, tag, event));\r\nswitch (event) {\r\ncase IO_OVERFLOW:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("IO_UNDERFLOW\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nts->residual = 0;\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nbreak;\r\ncase IO_XFER_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_BREAK\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_INTERRUPTED;\r\nbreak;\r\ncase IO_XFER_ERROR_PHY_NOT_READY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_PHY_NOT_READY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_PROTOCOL_NOT"\r\n"_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_EPROTO;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_ZONE_VIOLATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BREAK\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_CONT0;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\n"));\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nif (!t->uldd_task) {\r\npm8001_handle_event(pm8001_ha,\r\npm8001_dev,\r\nIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_QUEUE_FULL;\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\nreturn;\r\n}\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BAD_DESTINATION\n"));\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_BAD_DEST;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_CONNECTION_RATE_"\r\n"NOT_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_CONN_RATE;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_WRONG_DESTINATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_WRONG_DEST;\r\nbreak;\r\ncase IO_XFER_ERROR_NAK_RECEIVED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_NAK_RECEIVED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_NAK_R_ERR;\r\nbreak;\r\ncase IO_XFER_ERROR_PEER_ABORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_PEER_ABORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_NAK_R_ERR;\r\nbreak;\r\ncase IO_XFER_ERROR_REJECTED_NCQ_MODE:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_REJECTED_NCQ_MODE\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_UNDERRUN;\r\nbreak;\r\ncase IO_XFER_OPEN_RETRY_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_OPEN_RETRY_TIMEOUT\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\ncase IO_XFER_ERROR_UNEXPECTED_PHASE:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_UNEXPECTED_PHASE\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\ncase IO_XFER_ERROR_XFER_RDY_OVERRUN:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_XFER_RDY_OVERRUN\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\ncase IO_XFER_ERROR_XFER_RDY_NOT_EXPECTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_XFER_RDY_NOT_EXPECTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\ncase IO_XFER_ERROR_OFFSET_MISMATCH:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_OFFSET_MISMATCH\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\ncase IO_XFER_ERROR_XFER_ZERO_DATA_LEN:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_XFER_ZERO_DATA_LEN\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\ncase IO_XFER_CMD_FRAME_ISSUED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_CMD_FRAME_ISSUED\n"));\r\nbreak;\r\ncase IO_XFER_PIO_SETUP_ERROR:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_PIO_SETUP_ERROR\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\ndefault:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("Unknown status 0x%x\n", event));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&t->task_state_lock, flags);\r\nt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\r\nt->task_state_flags &= ~SAS_TASK_AT_INITIATOR;\r\nt->task_state_flags |= SAS_TASK_STATE_DONE;\r\nif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("task 0x%p done with io_status 0x%x"\r\n" resp 0x%x stat 0x%x but aborted by upper layer!\n",\r\nt, event, ts->resp, ts->stat));\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\n} else if (t->uldd_task) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\n} else if (!t->uldd_task) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\n}\r\n}\r\nstatic void\r\nmpi_smp_completion(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nu32 param;\r\nstruct sas_task *t;\r\nstruct pm8001_ccb_info *ccb;\r\nunsigned long flags;\r\nu32 status;\r\nu32 tag;\r\nstruct smp_completion_resp *psmpPayload;\r\nstruct task_status_struct *ts;\r\nstruct pm8001_device *pm8001_dev;\r\npsmpPayload = (struct smp_completion_resp *)(piomb + 4);\r\nstatus = le32_to_cpu(psmpPayload->status);\r\ntag = le32_to_cpu(psmpPayload->tag);\r\nccb = &pm8001_ha->ccb_info[tag];\r\nparam = le32_to_cpu(psmpPayload->param);\r\nt = ccb->task;\r\nts = &t->task_status;\r\npm8001_dev = ccb->device;\r\nif (status)\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("smp IO status 0x%x\n", status));\r\nif (unlikely(!t || !t->lldd_task || !t->dev))\r\nreturn;\r\nswitch (status) {\r\ncase IO_SUCCESS:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("IO_SUCCESS\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAM_STAT_GOOD;\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nbreak;\r\ncase IO_ABORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_ABORTED IOMB\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_ABORTED_TASK;\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nbreak;\r\ncase IO_OVERFLOW:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("IO_UNDERFLOW\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nts->residual = 0;\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nbreak;\r\ncase IO_NO_DEVICE:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("IO_NO_DEVICE\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_PHY_DOWN;\r\nbreak;\r\ncase IO_ERROR_HW_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_ERROR_HW_TIMEOUT\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAM_STAT_BUSY;\r\nbreak;\r\ncase IO_XFER_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_BREAK\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAM_STAT_BUSY;\r\nbreak;\r\ncase IO_XFER_ERROR_PHY_NOT_READY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_PHY_NOT_READY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAM_STAT_BUSY;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_ZONE_VIOLATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BREAK\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_CONT0;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\npm8001_handle_event(pm8001_ha,\r\npm8001_dev,\r\nIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BAD_DESTINATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_BAD_DEST;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_CONNECTION_RATE_"\r\n"NOT_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_CONN_RATE;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_WRONG_DESTINATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_WRONG_DEST;\r\nbreak;\r\ncase IO_XFER_ERROR_RX_FRAME:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_RX_FRAME\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nbreak;\r\ncase IO_XFER_OPEN_RETRY_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_OPEN_RETRY_TIMEOUT\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_ERROR_INTERNAL_SMP_RESOURCE:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_ERROR_INTERNAL_SMP_RESOURCE\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_QUEUE_FULL;\r\nbreak;\r\ncase IO_PORT_IN_RESET:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_PORT_IN_RESET\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_DS_NON_OPERATIONAL:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_DS_NON_OPERATIONAL\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nbreak;\r\ncase IO_DS_IN_RECOVERY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_DS_IN_RECOVERY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ndefault:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("Unknown status 0x%x\n", status));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&t->task_state_lock, flags);\r\nt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\r\nt->task_state_flags &= ~SAS_TASK_AT_INITIATOR;\r\nt->task_state_flags |= SAS_TASK_STATE_DONE;\r\nif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\nPM8001_FAIL_DBG(pm8001_ha, pm8001_printk("task 0x%p done with"\r\n" io_status 0x%x resp 0x%x "\r\n"stat 0x%x but aborted by upper layer!\n",\r\nt, status, ts->resp, ts->stat));\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\n} else {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nt->task_done(t);\r\n}\r\n}\r\nvoid pm8001_mpi_set_dev_state_resp(struct pm8001_hba_info *pm8001_ha,\r\nvoid *piomb)\r\n{\r\nstruct set_dev_state_resp *pPayload =\r\n(struct set_dev_state_resp *)(piomb + 4);\r\nu32 tag = le32_to_cpu(pPayload->tag);\r\nstruct pm8001_ccb_info *ccb = &pm8001_ha->ccb_info[tag];\r\nstruct pm8001_device *pm8001_dev = ccb->device;\r\nu32 status = le32_to_cpu(pPayload->status);\r\nu32 device_id = le32_to_cpu(pPayload->device_id);\r\nu8 pds = le32_to_cpu(pPayload->pds_nds) | PDS_BITS;\r\nu8 nds = le32_to_cpu(pPayload->pds_nds) | NDS_BITS;\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk("Set device id = 0x%x state "\r\n"from 0x%x to 0x%x status = 0x%x!\n",\r\ndevice_id, pds, nds, status));\r\ncomplete(pm8001_dev->setds_completion);\r\nccb->task = NULL;\r\nccb->ccb_tag = 0xFFFFFFFF;\r\npm8001_ccb_free(pm8001_ha, tag);\r\n}\r\nvoid pm8001_mpi_set_nvmd_resp(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nstruct get_nvm_data_resp *pPayload =\r\n(struct get_nvm_data_resp *)(piomb + 4);\r\nu32 tag = le32_to_cpu(pPayload->tag);\r\nstruct pm8001_ccb_info *ccb = &pm8001_ha->ccb_info[tag];\r\nu32 dlen_status = le32_to_cpu(pPayload->dlen_status);\r\ncomplete(pm8001_ha->nvmd_completion);\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk("Set nvm data complete!\n"));\r\nif ((dlen_status & NVMD_STAT) != 0) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Set nvm data error!\n"));\r\nreturn;\r\n}\r\nccb->task = NULL;\r\nccb->ccb_tag = 0xFFFFFFFF;\r\npm8001_ccb_free(pm8001_ha, tag);\r\n}\r\nvoid\r\npm8001_mpi_get_nvmd_resp(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nstruct fw_control_ex *fw_control_context;\r\nstruct get_nvm_data_resp *pPayload =\r\n(struct get_nvm_data_resp *)(piomb + 4);\r\nu32 tag = le32_to_cpu(pPayload->tag);\r\nstruct pm8001_ccb_info *ccb = &pm8001_ha->ccb_info[tag];\r\nu32 dlen_status = le32_to_cpu(pPayload->dlen_status);\r\nu32 ir_tds_bn_dps_das_nvm =\r\nle32_to_cpu(pPayload->ir_tda_bn_dps_das_nvm);\r\nvoid *virt_addr = pm8001_ha->memoryMap.region[NVMD].virt_ptr;\r\nfw_control_context = ccb->fw_control_context;\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk("Get nvm data complete!\n"));\r\nif ((dlen_status & NVMD_STAT) != 0) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Get nvm data error!\n"));\r\ncomplete(pm8001_ha->nvmd_completion);\r\nreturn;\r\n}\r\nif (ir_tds_bn_dps_das_nvm & IPMode) {\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("Get NVMD success, IR=1\n"));\r\nif ((ir_tds_bn_dps_das_nvm & NVMD_TYPE) == TWI_DEVICE) {\r\nif (ir_tds_bn_dps_das_nvm == 0x80a80200) {\r\nmemcpy(pm8001_ha->sas_addr,\r\n((u8 *)virt_addr + 4),\r\nSAS_ADDR_SIZE);\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("Get SAS address"\r\n" from VPD successfully!\n"));\r\n}\r\n} else if (((ir_tds_bn_dps_das_nvm & NVMD_TYPE) == C_SEEPROM)\r\n|| ((ir_tds_bn_dps_das_nvm & NVMD_TYPE) == VPD_FLASH) ||\r\n((ir_tds_bn_dps_das_nvm & NVMD_TYPE) == EXPAN_ROM)) {\r\n;\r\n} else if (((ir_tds_bn_dps_das_nvm & NVMD_TYPE) == AAP1_RDUMP)\r\n|| ((ir_tds_bn_dps_das_nvm & NVMD_TYPE) == IOP_RDUMP)) {\r\n;\r\n} else {\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("(IR=1)Wrong Device type 0x%x\n",\r\nir_tds_bn_dps_das_nvm));\r\n}\r\n} else {\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("Get NVMD success, IR=0, dataLen=%d\n",\r\n(dlen_status & NVMD_LEN) >> 24));\r\n}\r\nmemcpy(fw_control_context->usrAddr,\r\npm8001_ha->memoryMap.region[NVMD].virt_ptr,\r\nfw_control_context->len);\r\ncomplete(pm8001_ha->nvmd_completion);\r\nccb->task = NULL;\r\nccb->ccb_tag = 0xFFFFFFFF;\r\npm8001_ccb_free(pm8001_ha, tag);\r\n}\r\nint pm8001_mpi_local_phy_ctl(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nstruct local_phy_ctl_resp *pPayload =\r\n(struct local_phy_ctl_resp *)(piomb + 4);\r\nu32 status = le32_to_cpu(pPayload->status);\r\nu32 phy_id = le32_to_cpu(pPayload->phyop_phyid) & ID_BITS;\r\nu32 phy_op = le32_to_cpu(pPayload->phyop_phyid) & OP_BITS;\r\nif (status != 0) {\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("%x phy execute %x phy op failed!\n",\r\nphy_id, phy_op));\r\n} else\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("%x phy execute %x phy op success!\n",\r\nphy_id, phy_op));\r\nreturn 0;\r\n}\r\nvoid pm8001_bytes_dmaed(struct pm8001_hba_info *pm8001_ha, int i)\r\n{\r\nstruct pm8001_phy *phy = &pm8001_ha->phy[i];\r\nstruct asd_sas_phy *sas_phy = &phy->sas_phy;\r\nstruct sas_ha_struct *sas_ha;\r\nif (!phy->phy_attached)\r\nreturn;\r\nsas_ha = pm8001_ha->sas;\r\nif (sas_phy->phy) {\r\nstruct sas_phy *sphy = sas_phy->phy;\r\nsphy->negotiated_linkrate = sas_phy->linkrate;\r\nsphy->minimum_linkrate = phy->minimum_linkrate;\r\nsphy->minimum_linkrate_hw = SAS_LINK_RATE_1_5_GBPS;\r\nsphy->maximum_linkrate = phy->maximum_linkrate;\r\nsphy->maximum_linkrate_hw = phy->maximum_linkrate;\r\n}\r\nif (phy->phy_type & PORT_TYPE_SAS) {\r\nstruct sas_identify_frame *id;\r\nid = (struct sas_identify_frame *)phy->frame_rcvd;\r\nid->dev_type = phy->identify.device_type;\r\nid->initiator_bits = SAS_PROTOCOL_ALL;\r\nid->target_bits = phy->identify.target_port_protocols;\r\n} else if (phy->phy_type & PORT_TYPE_SATA) {\r\n}\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk("phy %d byte dmaded.\n", i));\r\nsas_phy->frame_rcvd_size = phy->frame_rcvd_size;\r\npm8001_ha->sas->notify_port_event(sas_phy, PORTE_BYTES_DMAED);\r\n}\r\nvoid pm8001_get_lrate_mode(struct pm8001_phy *phy, u8 link_rate)\r\n{\r\nstruct sas_phy *sas_phy = phy->sas_phy.phy;\r\nswitch (link_rate) {\r\ncase PHY_SPEED_60:\r\nphy->sas_phy.linkrate = SAS_LINK_RATE_6_0_GBPS;\r\nphy->sas_phy.phy->negotiated_linkrate = SAS_LINK_RATE_6_0_GBPS;\r\nbreak;\r\ncase PHY_SPEED_30:\r\nphy->sas_phy.linkrate = SAS_LINK_RATE_3_0_GBPS;\r\nphy->sas_phy.phy->negotiated_linkrate = SAS_LINK_RATE_3_0_GBPS;\r\nbreak;\r\ncase PHY_SPEED_15:\r\nphy->sas_phy.linkrate = SAS_LINK_RATE_1_5_GBPS;\r\nphy->sas_phy.phy->negotiated_linkrate = SAS_LINK_RATE_1_5_GBPS;\r\nbreak;\r\n}\r\nsas_phy->negotiated_linkrate = phy->sas_phy.linkrate;\r\nsas_phy->maximum_linkrate_hw = SAS_LINK_RATE_6_0_GBPS;\r\nsas_phy->minimum_linkrate_hw = SAS_LINK_RATE_1_5_GBPS;\r\nsas_phy->maximum_linkrate = SAS_LINK_RATE_6_0_GBPS;\r\nsas_phy->minimum_linkrate = SAS_LINK_RATE_1_5_GBPS;\r\n}\r\nvoid pm8001_get_attached_sas_addr(struct pm8001_phy *phy,\r\nu8 *sas_addr)\r\n{\r\nif (phy->sas_phy.frame_rcvd[0] == 0x34\r\n&& phy->sas_phy.oob_mode == SATA_OOB_MODE) {\r\nstruct pm8001_hba_info *pm8001_ha = phy->sas_phy.ha->lldd_ha;\r\nu64 addr = be64_to_cpu(*(__be64 *)pm8001_ha->sas_addr);\r\naddr += phy->sas_phy.id;\r\n*(__be64 *)sas_addr = cpu_to_be64(addr);\r\n} else {\r\nstruct sas_identify_frame *idframe =\r\n(void *) phy->sas_phy.frame_rcvd;\r\nmemcpy(sas_addr, idframe->sas_addr, SAS_ADDR_SIZE);\r\n}\r\n}\r\nstatic void pm8001_hw_event_ack_req(struct pm8001_hba_info *pm8001_ha,\r\nu32 Qnum, u32 SEA, u32 port_id, u32 phyId, u32 param0, u32 param1)\r\n{\r\nstruct hw_event_ack_req payload;\r\nu32 opc = OPC_INB_SAS_HW_EVENT_ACK;\r\nstruct inbound_queue_table *circularQ;\r\nmemset((u8 *)&payload, 0, sizeof(payload));\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[Qnum];\r\npayload.tag = cpu_to_le32(1);\r\npayload.sea_phyid_portid = cpu_to_le32(((SEA & 0xFFFF) << 8) |\r\n((phyId & 0x0F) << 4) | (port_id & 0x0F));\r\npayload.param0 = cpu_to_le32(param0);\r\npayload.param1 = cpu_to_le32(param1);\r\npm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &payload, 0);\r\n}\r\nstatic void\r\nhw_event_sas_phy_up(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nstruct hw_event_resp *pPayload =\r\n(struct hw_event_resp *)(piomb + 4);\r\nu32 lr_evt_status_phyid_portid =\r\nle32_to_cpu(pPayload->lr_evt_status_phyid_portid);\r\nu8 link_rate =\r\n(u8)((lr_evt_status_phyid_portid & 0xF0000000) >> 28);\r\nu8 port_id = (u8)(lr_evt_status_phyid_portid & 0x0000000F);\r\nu8 phy_id =\r\n(u8)((lr_evt_status_phyid_portid & 0x000000F0) >> 4);\r\nu32 npip_portstate = le32_to_cpu(pPayload->npip_portstate);\r\nu8 portstate = (u8)(npip_portstate & 0x0000000F);\r\nstruct pm8001_port *port = &pm8001_ha->port[port_id];\r\nstruct sas_ha_struct *sas_ha = pm8001_ha->sas;\r\nstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\r\nunsigned long flags;\r\nu8 deviceType = pPayload->sas_identify.dev_type;\r\nport->port_state = portstate;\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_SAS_PHY_UP port id = %d, phy id = %d\n",\r\nport_id, phy_id));\r\nswitch (deviceType) {\r\ncase SAS_PHY_UNUSED:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("device type no device.\n"));\r\nbreak;\r\ncase SAS_END_DEVICE:\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk("end device.\n"));\r\npm8001_chip_phy_ctl_req(pm8001_ha, phy_id,\r\nPHY_NOTIFY_ENABLE_SPINUP);\r\nport->port_attached = 1;\r\npm8001_get_lrate_mode(phy, link_rate);\r\nbreak;\r\ncase SAS_EDGE_EXPANDER_DEVICE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("expander device.\n"));\r\nport->port_attached = 1;\r\npm8001_get_lrate_mode(phy, link_rate);\r\nbreak;\r\ncase SAS_FANOUT_EXPANDER_DEVICE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("fanout expander device.\n"));\r\nport->port_attached = 1;\r\npm8001_get_lrate_mode(phy, link_rate);\r\nbreak;\r\ndefault:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("unknown device type(%x)\n", deviceType));\r\nbreak;\r\n}\r\nphy->phy_type |= PORT_TYPE_SAS;\r\nphy->identify.device_type = deviceType;\r\nphy->phy_attached = 1;\r\nif (phy->identify.device_type == SAS_END_DEVICE)\r\nphy->identify.target_port_protocols = SAS_PROTOCOL_SSP;\r\nelse if (phy->identify.device_type != SAS_PHY_UNUSED)\r\nphy->identify.target_port_protocols = SAS_PROTOCOL_SMP;\r\nphy->sas_phy.oob_mode = SAS_OOB_MODE;\r\nsas_ha->notify_phy_event(&phy->sas_phy, PHYE_OOB_DONE);\r\nspin_lock_irqsave(&phy->sas_phy.frame_rcvd_lock, flags);\r\nmemcpy(phy->frame_rcvd, &pPayload->sas_identify,\r\nsizeof(struct sas_identify_frame)-4);\r\nphy->frame_rcvd_size = sizeof(struct sas_identify_frame) - 4;\r\npm8001_get_attached_sas_addr(phy, phy->sas_phy.attached_sas_addr);\r\nspin_unlock_irqrestore(&phy->sas_phy.frame_rcvd_lock, flags);\r\nif (pm8001_ha->flags == PM8001F_RUN_TIME)\r\nmdelay(200);\r\npm8001_bytes_dmaed(pm8001_ha, phy_id);\r\n}\r\nstatic void\r\nhw_event_sata_phy_up(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nstruct hw_event_resp *pPayload =\r\n(struct hw_event_resp *)(piomb + 4);\r\nu32 lr_evt_status_phyid_portid =\r\nle32_to_cpu(pPayload->lr_evt_status_phyid_portid);\r\nu8 link_rate =\r\n(u8)((lr_evt_status_phyid_portid & 0xF0000000) >> 28);\r\nu8 port_id = (u8)(lr_evt_status_phyid_portid & 0x0000000F);\r\nu8 phy_id =\r\n(u8)((lr_evt_status_phyid_portid & 0x000000F0) >> 4);\r\nu32 npip_portstate = le32_to_cpu(pPayload->npip_portstate);\r\nu8 portstate = (u8)(npip_portstate & 0x0000000F);\r\nstruct pm8001_port *port = &pm8001_ha->port[port_id];\r\nstruct sas_ha_struct *sas_ha = pm8001_ha->sas;\r\nstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\r\nunsigned long flags;\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_SATA_PHY_UP port id = %d,"\r\n" phy id = %d\n", port_id, phy_id));\r\nport->port_state = portstate;\r\nport->port_attached = 1;\r\npm8001_get_lrate_mode(phy, link_rate);\r\nphy->phy_type |= PORT_TYPE_SATA;\r\nphy->phy_attached = 1;\r\nphy->sas_phy.oob_mode = SATA_OOB_MODE;\r\nsas_ha->notify_phy_event(&phy->sas_phy, PHYE_OOB_DONE);\r\nspin_lock_irqsave(&phy->sas_phy.frame_rcvd_lock, flags);\r\nmemcpy(phy->frame_rcvd, ((u8 *)&pPayload->sata_fis - 4),\r\nsizeof(struct dev_to_host_fis));\r\nphy->frame_rcvd_size = sizeof(struct dev_to_host_fis);\r\nphy->identify.target_port_protocols = SAS_PROTOCOL_SATA;\r\nphy->identify.device_type = SAS_SATA_DEV;\r\npm8001_get_attached_sas_addr(phy, phy->sas_phy.attached_sas_addr);\r\nspin_unlock_irqrestore(&phy->sas_phy.frame_rcvd_lock, flags);\r\npm8001_bytes_dmaed(pm8001_ha, phy_id);\r\n}\r\nstatic void\r\nhw_event_phy_down(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nstruct hw_event_resp *pPayload =\r\n(struct hw_event_resp *)(piomb + 4);\r\nu32 lr_evt_status_phyid_portid =\r\nle32_to_cpu(pPayload->lr_evt_status_phyid_portid);\r\nu8 port_id = (u8)(lr_evt_status_phyid_portid & 0x0000000F);\r\nu8 phy_id =\r\n(u8)((lr_evt_status_phyid_portid & 0x000000F0) >> 4);\r\nu32 npip_portstate = le32_to_cpu(pPayload->npip_portstate);\r\nu8 portstate = (u8)(npip_portstate & 0x0000000F);\r\nstruct pm8001_port *port = &pm8001_ha->port[port_id];\r\nstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\r\nport->port_state = portstate;\r\nphy->phy_type = 0;\r\nphy->identify.device_type = 0;\r\nphy->phy_attached = 0;\r\nmemset(&phy->dev_sas_addr, 0, SAS_ADDR_SIZE);\r\nswitch (portstate) {\r\ncase PORT_VALID:\r\nbreak;\r\ncase PORT_INVALID:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" PortInvalid portID %d\n", port_id));\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" Last phy Down and port invalid\n"));\r\nport->port_attached = 0;\r\npm8001_hw_event_ack_req(pm8001_ha, 0, HW_EVENT_PHY_DOWN,\r\nport_id, phy_id, 0, 0);\r\nbreak;\r\ncase PORT_IN_RESET:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" Port In Reset portID %d\n", port_id));\r\nbreak;\r\ncase PORT_NOT_ESTABLISHED:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" phy Down and PORT_NOT_ESTABLISHED\n"));\r\nport->port_attached = 0;\r\nbreak;\r\ncase PORT_LOSTCOMM:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" phy Down and PORT_LOSTCOMM\n"));\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" Last phy Down and port invalid\n"));\r\nport->port_attached = 0;\r\npm8001_hw_event_ack_req(pm8001_ha, 0, HW_EVENT_PHY_DOWN,\r\nport_id, phy_id, 0, 0);\r\nbreak;\r\ndefault:\r\nport->port_attached = 0;\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" phy Down and(default) = %x\n",\r\nportstate));\r\nbreak;\r\n}\r\n}\r\nint pm8001_mpi_reg_resp(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nu32 status;\r\nu32 device_id;\r\nu32 htag;\r\nstruct pm8001_ccb_info *ccb;\r\nstruct pm8001_device *pm8001_dev;\r\nstruct dev_reg_resp *registerRespPayload =\r\n(struct dev_reg_resp *)(piomb + 4);\r\nhtag = le32_to_cpu(registerRespPayload->tag);\r\nccb = &pm8001_ha->ccb_info[htag];\r\npm8001_dev = ccb->device;\r\nstatus = le32_to_cpu(registerRespPayload->status);\r\ndevice_id = le32_to_cpu(registerRespPayload->device_id);\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" register device is status = %d\n", status));\r\nswitch (status) {\r\ncase DEVREG_SUCCESS:\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk("DEVREG_SUCCESS\n"));\r\npm8001_dev->device_id = device_id;\r\nbreak;\r\ncase DEVREG_FAILURE_OUT_OF_RESOURCE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("DEVREG_FAILURE_OUT_OF_RESOURCE\n"));\r\nbreak;\r\ncase DEVREG_FAILURE_DEVICE_ALREADY_REGISTERED:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("DEVREG_FAILURE_DEVICE_ALREADY_REGISTERED\n"));\r\nbreak;\r\ncase DEVREG_FAILURE_INVALID_PHY_ID:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("DEVREG_FAILURE_INVALID_PHY_ID\n"));\r\nbreak;\r\ncase DEVREG_FAILURE_PHY_ID_ALREADY_REGISTERED:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("DEVREG_FAILURE_PHY_ID_ALREADY_REGISTERED\n"));\r\nbreak;\r\ncase DEVREG_FAILURE_PORT_ID_OUT_OF_RANGE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("DEVREG_FAILURE_PORT_ID_OUT_OF_RANGE\n"));\r\nbreak;\r\ncase DEVREG_FAILURE_PORT_NOT_VALID_STATE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("DEVREG_FAILURE_PORT_NOT_VALID_STATE\n"));\r\nbreak;\r\ncase DEVREG_FAILURE_DEVICE_TYPE_NOT_VALID:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("DEVREG_FAILURE_DEVICE_TYPE_NOT_VALID\n"));\r\nbreak;\r\ndefault:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("DEVREG_FAILURE_DEVICE_TYPE_NOT_UNSORPORTED\n"));\r\nbreak;\r\n}\r\ncomplete(pm8001_dev->dcompletion);\r\nccb->task = NULL;\r\nccb->ccb_tag = 0xFFFFFFFF;\r\npm8001_ccb_free(pm8001_ha, htag);\r\nreturn 0;\r\n}\r\nint pm8001_mpi_dereg_resp(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nu32 status;\r\nu32 device_id;\r\nstruct dev_reg_resp *registerRespPayload =\r\n(struct dev_reg_resp *)(piomb + 4);\r\nstatus = le32_to_cpu(registerRespPayload->status);\r\ndevice_id = le32_to_cpu(registerRespPayload->device_id);\r\nif (status != 0)\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" deregister device failed ,status = %x"\r\n", device_id = %x\n", status, device_id));\r\nreturn 0;\r\n}\r\nint pm8001_mpi_fw_flash_update_resp(struct pm8001_hba_info *pm8001_ha,\r\nvoid *piomb)\r\n{\r\nu32 status;\r\nstruct fw_control_ex fw_control_context;\r\nstruct fw_flash_Update_resp *ppayload =\r\n(struct fw_flash_Update_resp *)(piomb + 4);\r\nu32 tag = le32_to_cpu(ppayload->tag);\r\nstruct pm8001_ccb_info *ccb = &pm8001_ha->ccb_info[tag];\r\nstatus = le32_to_cpu(ppayload->status);\r\nmemcpy(&fw_control_context,\r\nccb->fw_control_context,\r\nsizeof(fw_control_context));\r\nswitch (status) {\r\ncase FLASH_UPDATE_COMPLETE_PENDING_REBOOT:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(": FLASH_UPDATE_COMPLETE_PENDING_REBOOT\n"));\r\nbreak;\r\ncase FLASH_UPDATE_IN_PROGRESS:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(": FLASH_UPDATE_IN_PROGRESS\n"));\r\nbreak;\r\ncase FLASH_UPDATE_HDR_ERR:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(": FLASH_UPDATE_HDR_ERR\n"));\r\nbreak;\r\ncase FLASH_UPDATE_OFFSET_ERR:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(": FLASH_UPDATE_OFFSET_ERR\n"));\r\nbreak;\r\ncase FLASH_UPDATE_CRC_ERR:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(": FLASH_UPDATE_CRC_ERR\n"));\r\nbreak;\r\ncase FLASH_UPDATE_LENGTH_ERR:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(": FLASH_UPDATE_LENGTH_ERR\n"));\r\nbreak;\r\ncase FLASH_UPDATE_HW_ERR:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(": FLASH_UPDATE_HW_ERR\n"));\r\nbreak;\r\ncase FLASH_UPDATE_DNLD_NOT_SUPPORTED:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(": FLASH_UPDATE_DNLD_NOT_SUPPORTED\n"));\r\nbreak;\r\ncase FLASH_UPDATE_DISABLED:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(": FLASH_UPDATE_DISABLED\n"));\r\nbreak;\r\ndefault:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("No matched status = %d\n", status));\r\nbreak;\r\n}\r\nccb->fw_control_context->fw_control->retcode = status;\r\ncomplete(pm8001_ha->nvmd_completion);\r\nccb->task = NULL;\r\nccb->ccb_tag = 0xFFFFFFFF;\r\npm8001_ccb_free(pm8001_ha, tag);\r\nreturn 0;\r\n}\r\nint pm8001_mpi_general_event(struct pm8001_hba_info *pm8001_ha , void *piomb)\r\n{\r\nu32 status;\r\nint i;\r\nstruct general_event_resp *pPayload =\r\n(struct general_event_resp *)(piomb + 4);\r\nstatus = le32_to_cpu(pPayload->status);\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" status = 0x%x\n", status));\r\nfor (i = 0; i < GENERAL_EVENT_PAYLOAD; i++)\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("inb_IOMB_payload[0x%x] 0x%x,\n", i,\r\npPayload->inb_IOMB_payload[i]));\r\nreturn 0;\r\n}\r\nint pm8001_mpi_task_abort_resp(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nstruct sas_task *t;\r\nstruct pm8001_ccb_info *ccb;\r\nunsigned long flags;\r\nu32 status ;\r\nu32 tag, scp;\r\nstruct task_status_struct *ts;\r\nstruct pm8001_device *pm8001_dev;\r\nstruct task_abort_resp *pPayload =\r\n(struct task_abort_resp *)(piomb + 4);\r\nstatus = le32_to_cpu(pPayload->status);\r\ntag = le32_to_cpu(pPayload->tag);\r\nif (!tag) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk(" TAG NULL. RETURNING !!!"));\r\nreturn -1;\r\n}\r\nscp = le32_to_cpu(pPayload->scp);\r\nccb = &pm8001_ha->ccb_info[tag];\r\nt = ccb->task;\r\npm8001_dev = ccb->device;\r\nif (!t) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk(" TASK NULL. RETURNING !!!"));\r\nreturn -1;\r\n}\r\nts = &t->task_status;\r\nif (status != 0)\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("task abort failed status 0x%x ,"\r\n"tag = 0x%x, scp= 0x%x\n", status, tag, scp));\r\nswitch (status) {\r\ncase IO_SUCCESS:\r\nPM8001_EH_DBG(pm8001_ha, pm8001_printk("IO_SUCCESS\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAM_STAT_GOOD;\r\nbreak;\r\ncase IO_NOT_VALID:\r\nPM8001_EH_DBG(pm8001_ha, pm8001_printk("IO_NOT_VALID\n"));\r\nts->resp = TMF_RESP_FUNC_FAILED;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&t->task_state_lock, flags);\r\nt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\r\nt->task_state_flags &= ~SAS_TASK_AT_INITIATOR;\r\nt->task_state_flags |= SAS_TASK_STATE_DONE;\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nif (pm8001_dev->id & NCQ_ABORT_ALL_FLAG) {\r\npm8001_tag_free(pm8001_ha, tag);\r\nsas_free_task(t);\r\npm8001_dev->id &= 0xBFFFFFFF;\r\n} else\r\nt->task_done(t);\r\nreturn 0;\r\n}\r\nstatic int mpi_hw_event(struct pm8001_hba_info *pm8001_ha, void* piomb)\r\n{\r\nunsigned long flags;\r\nstruct hw_event_resp *pPayload =\r\n(struct hw_event_resp *)(piomb + 4);\r\nu32 lr_evt_status_phyid_portid =\r\nle32_to_cpu(pPayload->lr_evt_status_phyid_portid);\r\nu8 port_id = (u8)(lr_evt_status_phyid_portid & 0x0000000F);\r\nu8 phy_id =\r\n(u8)((lr_evt_status_phyid_portid & 0x000000F0) >> 4);\r\nu16 eventType =\r\n(u16)((lr_evt_status_phyid_portid & 0x00FFFF00) >> 8);\r\nu8 status =\r\n(u8)((lr_evt_status_phyid_portid & 0x0F000000) >> 24);\r\nstruct sas_ha_struct *sas_ha = pm8001_ha->sas;\r\nstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\r\nstruct asd_sas_phy *sas_phy = sas_ha->sas_phy[phy_id];\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("outbound queue HW event & event type : "));\r\nswitch (eventType) {\r\ncase HW_EVENT_PHY_START_STATUS:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_PHY_START_STATUS"\r\n" status = %x\n", status));\r\nif (status == 0) {\r\nphy->phy_state = 1;\r\nif (pm8001_ha->flags == PM8001F_RUN_TIME)\r\ncomplete(phy->enable_completion);\r\n}\r\nbreak;\r\ncase HW_EVENT_SAS_PHY_UP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_PHY_START_STATUS\n"));\r\nhw_event_sas_phy_up(pm8001_ha, piomb);\r\nbreak;\r\ncase HW_EVENT_SATA_PHY_UP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_SATA_PHY_UP\n"));\r\nhw_event_sata_phy_up(pm8001_ha, piomb);\r\nbreak;\r\ncase HW_EVENT_PHY_STOP_STATUS:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_PHY_STOP_STATUS "\r\n"status = %x\n", status));\r\nif (status == 0)\r\nphy->phy_state = 0;\r\nbreak;\r\ncase HW_EVENT_SATA_SPINUP_HOLD:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_SATA_SPINUP_HOLD\n"));\r\nsas_ha->notify_phy_event(&phy->sas_phy, PHYE_SPINUP_HOLD);\r\nbreak;\r\ncase HW_EVENT_PHY_DOWN:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_PHY_DOWN\n"));\r\nsas_ha->notify_phy_event(&phy->sas_phy, PHYE_LOSS_OF_SIGNAL);\r\nphy->phy_attached = 0;\r\nphy->phy_state = 0;\r\nhw_event_phy_down(pm8001_ha, piomb);\r\nbreak;\r\ncase HW_EVENT_PORT_INVALID:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_PORT_INVALID\n"));\r\nsas_phy_disconnected(sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_port_event(sas_phy, PORTE_LINK_RESET_ERR);\r\nbreak;\r\ncase HW_EVENT_BROADCAST_CHANGE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_BROADCAST_CHANGE\n"));\r\npm8001_hw_event_ack_req(pm8001_ha, 0, HW_EVENT_BROADCAST_CHANGE,\r\nport_id, phy_id, 1, 0);\r\nspin_lock_irqsave(&sas_phy->sas_prim_lock, flags);\r\nsas_phy->sas_prim = HW_EVENT_BROADCAST_CHANGE;\r\nspin_unlock_irqrestore(&sas_phy->sas_prim_lock, flags);\r\nsas_ha->notify_port_event(sas_phy, PORTE_BROADCAST_RCVD);\r\nbreak;\r\ncase HW_EVENT_PHY_ERROR:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_PHY_ERROR\n"));\r\nsas_phy_disconnected(&phy->sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_phy_event(&phy->sas_phy, PHYE_OOB_ERROR);\r\nbreak;\r\ncase HW_EVENT_BROADCAST_EXP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_BROADCAST_EXP\n"));\r\nspin_lock_irqsave(&sas_phy->sas_prim_lock, flags);\r\nsas_phy->sas_prim = HW_EVENT_BROADCAST_EXP;\r\nspin_unlock_irqrestore(&sas_phy->sas_prim_lock, flags);\r\nsas_ha->notify_port_event(sas_phy, PORTE_BROADCAST_RCVD);\r\nbreak;\r\ncase HW_EVENT_LINK_ERR_INVALID_DWORD:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_LINK_ERR_INVALID_DWORD\n"));\r\npm8001_hw_event_ack_req(pm8001_ha, 0,\r\nHW_EVENT_LINK_ERR_INVALID_DWORD, port_id, phy_id, 0, 0);\r\nsas_phy_disconnected(sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_port_event(sas_phy, PORTE_LINK_RESET_ERR);\r\nbreak;\r\ncase HW_EVENT_LINK_ERR_DISPARITY_ERROR:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_LINK_ERR_DISPARITY_ERROR\n"));\r\npm8001_hw_event_ack_req(pm8001_ha, 0,\r\nHW_EVENT_LINK_ERR_DISPARITY_ERROR,\r\nport_id, phy_id, 0, 0);\r\nsas_phy_disconnected(sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_port_event(sas_phy, PORTE_LINK_RESET_ERR);\r\nbreak;\r\ncase HW_EVENT_LINK_ERR_CODE_VIOLATION:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_LINK_ERR_CODE_VIOLATION\n"));\r\npm8001_hw_event_ack_req(pm8001_ha, 0,\r\nHW_EVENT_LINK_ERR_CODE_VIOLATION,\r\nport_id, phy_id, 0, 0);\r\nsas_phy_disconnected(sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_port_event(sas_phy, PORTE_LINK_RESET_ERR);\r\nbreak;\r\ncase HW_EVENT_LINK_ERR_LOSS_OF_DWORD_SYNCH:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_LINK_ERR_LOSS_OF_DWORD_SYNCH\n"));\r\npm8001_hw_event_ack_req(pm8001_ha, 0,\r\nHW_EVENT_LINK_ERR_LOSS_OF_DWORD_SYNCH,\r\nport_id, phy_id, 0, 0);\r\nsas_phy_disconnected(sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_port_event(sas_phy, PORTE_LINK_RESET_ERR);\r\nbreak;\r\ncase HW_EVENT_MALFUNCTION:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_MALFUNCTION\n"));\r\nbreak;\r\ncase HW_EVENT_BROADCAST_SES:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_BROADCAST_SES\n"));\r\nspin_lock_irqsave(&sas_phy->sas_prim_lock, flags);\r\nsas_phy->sas_prim = HW_EVENT_BROADCAST_SES;\r\nspin_unlock_irqrestore(&sas_phy->sas_prim_lock, flags);\r\nsas_ha->notify_port_event(sas_phy, PORTE_BROADCAST_RCVD);\r\nbreak;\r\ncase HW_EVENT_INBOUND_CRC_ERROR:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_INBOUND_CRC_ERROR\n"));\r\npm8001_hw_event_ack_req(pm8001_ha, 0,\r\nHW_EVENT_INBOUND_CRC_ERROR,\r\nport_id, phy_id, 0, 0);\r\nbreak;\r\ncase HW_EVENT_HARD_RESET_RECEIVED:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_HARD_RESET_RECEIVED\n"));\r\nsas_ha->notify_port_event(sas_phy, PORTE_HARD_RESET);\r\nbreak;\r\ncase HW_EVENT_ID_FRAME_TIMEOUT:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_ID_FRAME_TIMEOUT\n"));\r\nsas_phy_disconnected(sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_port_event(sas_phy, PORTE_LINK_RESET_ERR);\r\nbreak;\r\ncase HW_EVENT_LINK_ERR_PHY_RESET_FAILED:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_LINK_ERR_PHY_RESET_FAILED\n"));\r\npm8001_hw_event_ack_req(pm8001_ha, 0,\r\nHW_EVENT_LINK_ERR_PHY_RESET_FAILED,\r\nport_id, phy_id, 0, 0);\r\nsas_phy_disconnected(sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_port_event(sas_phy, PORTE_LINK_RESET_ERR);\r\nbreak;\r\ncase HW_EVENT_PORT_RESET_TIMER_TMO:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_PORT_RESET_TIMER_TMO\n"));\r\nsas_phy_disconnected(sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_port_event(sas_phy, PORTE_LINK_RESET_ERR);\r\nbreak;\r\ncase HW_EVENT_PORT_RECOVERY_TIMER_TMO:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_PORT_RECOVERY_TIMER_TMO\n"));\r\nsas_phy_disconnected(sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_port_event(sas_phy, PORTE_LINK_RESET_ERR);\r\nbreak;\r\ncase HW_EVENT_PORT_RECOVER:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_PORT_RECOVER\n"));\r\nbreak;\r\ncase HW_EVENT_PORT_RESET_COMPLETE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_PORT_RESET_COMPLETE\n"));\r\nbreak;\r\ncase EVENT_BROADCAST_ASYNCH_EVENT:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("EVENT_BROADCAST_ASYNCH_EVENT\n"));\r\nbreak;\r\ndefault:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("Unknown event type = %x\n", eventType));\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void process_one_iomb(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\n__le32 pHeader = *(__le32 *)piomb;\r\nu8 opc = (u8)((le32_to_cpu(pHeader)) & 0xFFF);\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk("process_one_iomb:"));\r\nswitch (opc) {\r\ncase OPC_OUB_ECHO:\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk("OPC_OUB_ECHO\n"));\r\nbreak;\r\ncase OPC_OUB_HW_EVENT:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_HW_EVENT\n"));\r\nmpi_hw_event(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_SSP_COMP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SSP_COMP\n"));\r\nmpi_ssp_completion(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_SMP_COMP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SMP_COMP\n"));\r\nmpi_smp_completion(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_LOCAL_PHY_CNTRL:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_LOCAL_PHY_CNTRL\n"));\r\npm8001_mpi_local_phy_ctl(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_DEV_REGIST:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_DEV_REGIST\n"));\r\npm8001_mpi_reg_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_DEREG_DEV:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("unregister the device\n"));\r\npm8001_mpi_dereg_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_GET_DEV_HANDLE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_GET_DEV_HANDLE\n"));\r\nbreak;\r\ncase OPC_OUB_SATA_COMP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SATA_COMP\n"));\r\nmpi_sata_completion(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_SATA_EVENT:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SATA_EVENT\n"));\r\nmpi_sata_event(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_SSP_EVENT:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SSP_EVENT\n"));\r\nmpi_ssp_event(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_DEV_HANDLE_ARRIV:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_DEV_HANDLE_ARRIV\n"));\r\nbreak;\r\ncase OPC_OUB_SSP_RECV_EVENT:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SSP_RECV_EVENT\n"));\r\nbreak;\r\ncase OPC_OUB_DEV_INFO:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_DEV_INFO\n"));\r\nbreak;\r\ncase OPC_OUB_FW_FLASH_UPDATE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_FW_FLASH_UPDATE\n"));\r\npm8001_mpi_fw_flash_update_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_GPIO_RESPONSE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_GPIO_RESPONSE\n"));\r\nbreak;\r\ncase OPC_OUB_GPIO_EVENT:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_GPIO_EVENT\n"));\r\nbreak;\r\ncase OPC_OUB_GENERAL_EVENT:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_GENERAL_EVENT\n"));\r\npm8001_mpi_general_event(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_SSP_ABORT_RSP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SSP_ABORT_RSP\n"));\r\npm8001_mpi_task_abort_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_SATA_ABORT_RSP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SATA_ABORT_RSP\n"));\r\npm8001_mpi_task_abort_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_SAS_DIAG_MODE_START_END:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SAS_DIAG_MODE_START_END\n"));\r\nbreak;\r\ncase OPC_OUB_SAS_DIAG_EXECUTE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SAS_DIAG_EXECUTE\n"));\r\nbreak;\r\ncase OPC_OUB_GET_TIME_STAMP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_GET_TIME_STAMP\n"));\r\nbreak;\r\ncase OPC_OUB_SAS_HW_EVENT_ACK:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SAS_HW_EVENT_ACK\n"));\r\nbreak;\r\ncase OPC_OUB_PORT_CONTROL:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_PORT_CONTROL\n"));\r\nbreak;\r\ncase OPC_OUB_SMP_ABORT_RSP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SMP_ABORT_RSP\n"));\r\npm8001_mpi_task_abort_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_GET_NVMD_DATA:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_GET_NVMD_DATA\n"));\r\npm8001_mpi_get_nvmd_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_SET_NVMD_DATA:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SET_NVMD_DATA\n"));\r\npm8001_mpi_set_nvmd_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_DEVICE_HANDLE_REMOVAL:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_DEVICE_HANDLE_REMOVAL\n"));\r\nbreak;\r\ncase OPC_OUB_SET_DEVICE_STATE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SET_DEVICE_STATE\n"));\r\npm8001_mpi_set_dev_state_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_GET_DEVICE_STATE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_GET_DEVICE_STATE\n"));\r\nbreak;\r\ncase OPC_OUB_SET_DEV_INFO:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SET_DEV_INFO\n"));\r\nbreak;\r\ncase OPC_OUB_SAS_RE_INITIALIZE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SAS_RE_INITIALIZE\n"));\r\nbreak;\r\ndefault:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("Unknown outbound Queue IOMB OPC = %x\n",\r\nopc));\r\nbreak;\r\n}\r\n}\r\nstatic int process_oq(struct pm8001_hba_info *pm8001_ha, u8 vec)\r\n{\r\nstruct outbound_queue_table *circularQ;\r\nvoid *pMsg1 = NULL;\r\nu8 uninitialized_var(bc);\r\nu32 ret = MPI_IO_STATUS_FAIL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pm8001_ha->lock, flags);\r\ncircularQ = &pm8001_ha->outbnd_q_tbl[vec];\r\ndo {\r\nret = pm8001_mpi_msg_consume(pm8001_ha, circularQ, &pMsg1, &bc);\r\nif (MPI_IO_STATUS_SUCCESS == ret) {\r\nprocess_one_iomb(pm8001_ha, (void *)(pMsg1 - 4));\r\npm8001_mpi_msg_free_set(pm8001_ha, pMsg1,\r\ncircularQ, bc);\r\n}\r\nif (MPI_IO_STATUS_BUSY == ret) {\r\ncircularQ->producer_index =\r\ncpu_to_le32(pm8001_read_32(circularQ->pi_virt));\r\nif (le32_to_cpu(circularQ->producer_index) ==\r\ncircularQ->consumer_idx)\r\nbreak;\r\n}\r\n} while (1);\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nreturn ret;\r\n}\r\nvoid\r\npm8001_chip_make_sg(struct scatterlist *scatter, int nr, void *prd)\r\n{\r\nint i;\r\nstruct scatterlist *sg;\r\nstruct pm8001_prd *buf_prd = prd;\r\nfor_each_sg(scatter, sg, nr, i) {\r\nbuf_prd->addr = cpu_to_le64(sg_dma_address(sg));\r\nbuf_prd->im_len.len = cpu_to_le32(sg_dma_len(sg));\r\nbuf_prd->im_len.e = 0;\r\nbuf_prd++;\r\n}\r\n}\r\nstatic void build_smp_cmd(u32 deviceID, __le32 hTag, struct smp_req *psmp_cmd)\r\n{\r\npsmp_cmd->tag = hTag;\r\npsmp_cmd->device_id = cpu_to_le32(deviceID);\r\npsmp_cmd->len_ip_ir = cpu_to_le32(1|(1 << 1));\r\n}\r\nstatic int pm8001_chip_smp_req(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_ccb_info *ccb)\r\n{\r\nint elem, rc;\r\nstruct sas_task *task = ccb->task;\r\nstruct domain_device *dev = task->dev;\r\nstruct pm8001_device *pm8001_dev = dev->lldd_dev;\r\nstruct scatterlist *sg_req, *sg_resp;\r\nu32 req_len, resp_len;\r\nstruct smp_req smp_cmd;\r\nu32 opc;\r\nstruct inbound_queue_table *circularQ;\r\nmemset(&smp_cmd, 0, sizeof(smp_cmd));\r\nsg_req = &task->smp_task.smp_req;\r\nelem = dma_map_sg(pm8001_ha->dev, sg_req, 1, PCI_DMA_TODEVICE);\r\nif (!elem)\r\nreturn -ENOMEM;\r\nreq_len = sg_dma_len(sg_req);\r\nsg_resp = &task->smp_task.smp_resp;\r\nelem = dma_map_sg(pm8001_ha->dev, sg_resp, 1, PCI_DMA_FROMDEVICE);\r\nif (!elem) {\r\nrc = -ENOMEM;\r\ngoto err_out;\r\n}\r\nresp_len = sg_dma_len(sg_resp);\r\nif ((req_len & 0x3) || (resp_len & 0x3)) {\r\nrc = -EINVAL;\r\ngoto err_out_2;\r\n}\r\nopc = OPC_INB_SMP_REQUEST;\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nsmp_cmd.tag = cpu_to_le32(ccb->ccb_tag);\r\nsmp_cmd.long_smp_req.long_req_addr =\r\ncpu_to_le64((u64)sg_dma_address(&task->smp_task.smp_req));\r\nsmp_cmd.long_smp_req.long_req_size =\r\ncpu_to_le32((u32)sg_dma_len(&task->smp_task.smp_req)-4);\r\nsmp_cmd.long_smp_req.long_resp_addr =\r\ncpu_to_le64((u64)sg_dma_address(&task->smp_task.smp_resp));\r\nsmp_cmd.long_smp_req.long_resp_size =\r\ncpu_to_le32((u32)sg_dma_len(&task->smp_task.smp_resp)-4);\r\nbuild_smp_cmd(pm8001_dev->device_id, smp_cmd.tag, &smp_cmd);\r\npm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, (u32 *)&smp_cmd, 0);\r\nreturn 0;\r\nerr_out_2:\r\ndma_unmap_sg(pm8001_ha->dev, &ccb->task->smp_task.smp_resp, 1,\r\nPCI_DMA_FROMDEVICE);\r\nerr_out:\r\ndma_unmap_sg(pm8001_ha->dev, &ccb->task->smp_task.smp_req, 1,\r\nPCI_DMA_TODEVICE);\r\nreturn rc;\r\n}\r\nstatic int pm8001_chip_ssp_io_req(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_ccb_info *ccb)\r\n{\r\nstruct sas_task *task = ccb->task;\r\nstruct domain_device *dev = task->dev;\r\nstruct pm8001_device *pm8001_dev = dev->lldd_dev;\r\nstruct ssp_ini_io_start_req ssp_cmd;\r\nu32 tag = ccb->ccb_tag;\r\nint ret;\r\nu64 phys_addr;\r\nstruct inbound_queue_table *circularQ;\r\nu32 opc = OPC_INB_SSPINIIOSTART;\r\nmemset(&ssp_cmd, 0, sizeof(ssp_cmd));\r\nmemcpy(ssp_cmd.ssp_iu.lun, task->ssp_task.LUN, 8);\r\nssp_cmd.dir_m_tlr =\r\ncpu_to_le32(data_dir_flags[task->data_dir] << 8 | 0x0);\r\nssp_cmd.data_len = cpu_to_le32(task->total_xfer_len);\r\nssp_cmd.device_id = cpu_to_le32(pm8001_dev->device_id);\r\nssp_cmd.tag = cpu_to_le32(tag);\r\nif (task->ssp_task.enable_first_burst)\r\nssp_cmd.ssp_iu.efb_prio_attr |= 0x80;\r\nssp_cmd.ssp_iu.efb_prio_attr |= (task->ssp_task.task_prio << 3);\r\nssp_cmd.ssp_iu.efb_prio_attr |= (task->ssp_task.task_attr & 7);\r\nmemcpy(ssp_cmd.ssp_iu.cdb, task->ssp_task.cmd->cmnd,\r\ntask->ssp_task.cmd->cmd_len);\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nif (task->num_scatter > 1) {\r\npm8001_chip_make_sg(task->scatter, ccb->n_elem, ccb->buf_prd);\r\nphys_addr = ccb->ccb_dma_handle +\r\noffsetof(struct pm8001_ccb_info, buf_prd[0]);\r\nssp_cmd.addr_low = cpu_to_le32(lower_32_bits(phys_addr));\r\nssp_cmd.addr_high = cpu_to_le32(upper_32_bits(phys_addr));\r\nssp_cmd.esgl = cpu_to_le32(1<<31);\r\n} else if (task->num_scatter == 1) {\r\nu64 dma_addr = sg_dma_address(task->scatter);\r\nssp_cmd.addr_low = cpu_to_le32(lower_32_bits(dma_addr));\r\nssp_cmd.addr_high = cpu_to_le32(upper_32_bits(dma_addr));\r\nssp_cmd.len = cpu_to_le32(task->total_xfer_len);\r\nssp_cmd.esgl = 0;\r\n} else if (task->num_scatter == 0) {\r\nssp_cmd.addr_low = 0;\r\nssp_cmd.addr_high = 0;\r\nssp_cmd.len = cpu_to_le32(task->total_xfer_len);\r\nssp_cmd.esgl = 0;\r\n}\r\nret = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &ssp_cmd, 0);\r\nreturn ret;\r\n}\r\nstatic int pm8001_chip_sata_req(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_ccb_info *ccb)\r\n{\r\nstruct sas_task *task = ccb->task;\r\nstruct domain_device *dev = task->dev;\r\nstruct pm8001_device *pm8001_ha_dev = dev->lldd_dev;\r\nu32 tag = ccb->ccb_tag;\r\nint ret;\r\nstruct sata_start_req sata_cmd;\r\nu32 hdr_tag, ncg_tag = 0;\r\nu64 phys_addr;\r\nu32 ATAP = 0x0;\r\nu32 dir;\r\nstruct inbound_queue_table *circularQ;\r\nunsigned long flags;\r\nu32 opc = OPC_INB_SATA_HOST_OPSTART;\r\nmemset(&sata_cmd, 0, sizeof(sata_cmd));\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nif (task->data_dir == PCI_DMA_NONE) {\r\nATAP = 0x04;\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("no data\n"));\r\n} else if (likely(!task->ata_task.device_control_reg_update)) {\r\nif (task->ata_task.dma_xfer) {\r\nATAP = 0x06;\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("DMA\n"));\r\n} else {\r\nATAP = 0x05;\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("PIO\n"));\r\n}\r\nif (task->ata_task.use_ncq &&\r\ndev->sata_dev.command_set != ATAPI_COMMAND_SET) {\r\nATAP = 0x07;\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("FPDMA\n"));\r\n}\r\n}\r\nif (task->ata_task.use_ncq && pm8001_get_ncq_tag(task, &hdr_tag)) {\r\ntask->ata_task.fis.sector_count |= (u8) (hdr_tag << 3);\r\nncg_tag = hdr_tag;\r\n}\r\ndir = data_dir_flags[task->data_dir] << 8;\r\nsata_cmd.tag = cpu_to_le32(tag);\r\nsata_cmd.device_id = cpu_to_le32(pm8001_ha_dev->device_id);\r\nsata_cmd.data_len = cpu_to_le32(task->total_xfer_len);\r\nsata_cmd.ncqtag_atap_dir_m =\r\ncpu_to_le32(((ncg_tag & 0xff)<<16)|((ATAP & 0x3f) << 10) | dir);\r\nsata_cmd.sata_fis = task->ata_task.fis;\r\nif (likely(!task->ata_task.device_control_reg_update))\r\nsata_cmd.sata_fis.flags |= 0x80;\r\nsata_cmd.sata_fis.flags &= 0xF0;\r\nif (task->num_scatter > 1) {\r\npm8001_chip_make_sg(task->scatter, ccb->n_elem, ccb->buf_prd);\r\nphys_addr = ccb->ccb_dma_handle +\r\noffsetof(struct pm8001_ccb_info, buf_prd[0]);\r\nsata_cmd.addr_low = lower_32_bits(phys_addr);\r\nsata_cmd.addr_high = upper_32_bits(phys_addr);\r\nsata_cmd.esgl = cpu_to_le32(1 << 31);\r\n} else if (task->num_scatter == 1) {\r\nu64 dma_addr = sg_dma_address(task->scatter);\r\nsata_cmd.addr_low = lower_32_bits(dma_addr);\r\nsata_cmd.addr_high = upper_32_bits(dma_addr);\r\nsata_cmd.len = cpu_to_le32(task->total_xfer_len);\r\nsata_cmd.esgl = 0;\r\n} else if (task->num_scatter == 0) {\r\nsata_cmd.addr_low = 0;\r\nsata_cmd.addr_high = 0;\r\nsata_cmd.len = cpu_to_le32(task->total_xfer_len);\r\nsata_cmd.esgl = 0;\r\n}\r\nif (sata_cmd.sata_fis.command == 0x2f) {\r\nif (pm8001_ha_dev && ((pm8001_ha_dev->id & NCQ_READ_LOG_FLAG) ||\r\n(pm8001_ha_dev->id & NCQ_ABORT_ALL_FLAG) ||\r\n(pm8001_ha_dev->id & NCQ_2ND_RLE_FLAG))) {\r\nstruct task_status_struct *ts;\r\npm8001_ha_dev->id &= 0xDFFFFFFF;\r\nts = &task->task_status;\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAM_STAT_GOOD;\r\ntask->task_state_flags &= ~SAS_TASK_STATE_PENDING;\r\ntask->task_state_flags &= ~SAS_TASK_AT_INITIATOR;\r\ntask->task_state_flags |= SAS_TASK_STATE_DONE;\r\nif (unlikely((task->task_state_flags &\r\nSAS_TASK_STATE_ABORTED))) {\r\nspin_unlock_irqrestore(&task->task_state_lock,\r\nflags);\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("task 0x%p resp 0x%x "\r\n" stat 0x%x but aborted by upper layer "\r\n"\n", task, ts->resp, ts->stat));\r\npm8001_ccb_task_free(pm8001_ha, task, ccb, tag);\r\n} else if (task->uldd_task) {\r\nspin_unlock_irqrestore(&task->task_state_lock,\r\nflags);\r\npm8001_ccb_task_free(pm8001_ha, task, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\ntask->task_done(task);\r\nspin_lock_irq(&pm8001_ha->lock);\r\nreturn 0;\r\n} else if (!task->uldd_task) {\r\nspin_unlock_irqrestore(&task->task_state_lock,\r\nflags);\r\npm8001_ccb_task_free(pm8001_ha, task, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\ntask->task_done(task);\r\nspin_lock_irq(&pm8001_ha->lock);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nret = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &sata_cmd, 0);\r\nreturn ret;\r\n}\r\nstatic int\r\npm8001_chip_phy_start_req(struct pm8001_hba_info *pm8001_ha, u8 phy_id)\r\n{\r\nstruct phy_start_req payload;\r\nstruct inbound_queue_table *circularQ;\r\nint ret;\r\nu32 tag = 0x01;\r\nu32 opcode = OPC_INB_PHYSTART;\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nmemset(&payload, 0, sizeof(payload));\r\npayload.tag = cpu_to_le32(tag);\r\npayload.ase_sh_lm_slr_phyid = cpu_to_le32(SPINHOLD_DISABLE |\r\nLINKMODE_AUTO | LINKRATE_15 |\r\nLINKRATE_30 | LINKRATE_60 | phy_id);\r\npayload.sas_identify.dev_type = SAS_END_DEVICE;\r\npayload.sas_identify.initiator_bits = SAS_PROTOCOL_ALL;\r\nmemcpy(payload.sas_identify.sas_addr,\r\npm8001_ha->sas_addr, SAS_ADDR_SIZE);\r\npayload.sas_identify.phy_id = phy_id;\r\nret = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opcode, &payload, 0);\r\nreturn ret;\r\n}\r\nint pm8001_chip_phy_stop_req(struct pm8001_hba_info *pm8001_ha,\r\nu8 phy_id)\r\n{\r\nstruct phy_stop_req payload;\r\nstruct inbound_queue_table *circularQ;\r\nint ret;\r\nu32 tag = 0x01;\r\nu32 opcode = OPC_INB_PHYSTOP;\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nmemset(&payload, 0, sizeof(payload));\r\npayload.tag = cpu_to_le32(tag);\r\npayload.phy_id = cpu_to_le32(phy_id);\r\nret = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opcode, &payload, 0);\r\nreturn ret;\r\n}\r\nstatic int pm8001_chip_reg_dev_req(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_device *pm8001_dev, u32 flag)\r\n{\r\nstruct reg_dev_req payload;\r\nu32 opc;\r\nu32 stp_sspsmp_sata = 0x4;\r\nstruct inbound_queue_table *circularQ;\r\nu32 linkrate, phy_id;\r\nint rc, tag = 0xdeadbeef;\r\nstruct pm8001_ccb_info *ccb;\r\nu8 retryFlag = 0x1;\r\nu16 firstBurstSize = 0;\r\nu16 ITNT = 2000;\r\nstruct domain_device *dev = pm8001_dev->sas_device;\r\nstruct domain_device *parent_dev = dev->parent;\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nmemset(&payload, 0, sizeof(payload));\r\nrc = pm8001_tag_alloc(pm8001_ha, &tag);\r\nif (rc)\r\nreturn rc;\r\nccb = &pm8001_ha->ccb_info[tag];\r\nccb->device = pm8001_dev;\r\nccb->ccb_tag = tag;\r\npayload.tag = cpu_to_le32(tag);\r\nif (flag == 1)\r\nstp_sspsmp_sata = 0x02;\r\nelse {\r\nif (pm8001_dev->dev_type == SAS_SATA_DEV)\r\nstp_sspsmp_sata = 0x00;\r\nelse if (pm8001_dev->dev_type == SAS_END_DEVICE ||\r\npm8001_dev->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\r\npm8001_dev->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\r\nstp_sspsmp_sata = 0x01;\r\n}\r\nif (parent_dev && DEV_IS_EXPANDER(parent_dev->dev_type))\r\nphy_id = parent_dev->ex_dev.ex_phy->phy_id;\r\nelse\r\nphy_id = pm8001_dev->attached_phy;\r\nopc = OPC_INB_REG_DEV;\r\nlinkrate = (pm8001_dev->sas_device->linkrate < dev->port->linkrate) ?\r\npm8001_dev->sas_device->linkrate : dev->port->linkrate;\r\npayload.phyid_portid =\r\ncpu_to_le32(((pm8001_dev->sas_device->port->id) & 0x0F) |\r\n((phy_id & 0x0F) << 4));\r\npayload.dtype_dlr_retry = cpu_to_le32((retryFlag & 0x01) |\r\n((linkrate & 0x0F) * 0x1000000) |\r\n((stp_sspsmp_sata & 0x03) * 0x10000000));\r\npayload.firstburstsize_ITNexustimeout =\r\ncpu_to_le32(ITNT | (firstBurstSize * 0x10000));\r\nmemcpy(payload.sas_addr, pm8001_dev->sas_device->sas_addr,\r\nSAS_ADDR_SIZE);\r\nrc = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &payload, 0);\r\nreturn rc;\r\n}\r\nint pm8001_chip_dereg_dev_req(struct pm8001_hba_info *pm8001_ha,\r\nu32 device_id)\r\n{\r\nstruct dereg_dev_req payload;\r\nu32 opc = OPC_INB_DEREG_DEV_HANDLE;\r\nint ret;\r\nstruct inbound_queue_table *circularQ;\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nmemset(&payload, 0, sizeof(payload));\r\npayload.tag = cpu_to_le32(1);\r\npayload.device_id = cpu_to_le32(device_id);\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("unregister device device_id = %d\n", device_id));\r\nret = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &payload, 0);\r\nreturn ret;\r\n}\r\nstatic int pm8001_chip_phy_ctl_req(struct pm8001_hba_info *pm8001_ha,\r\nu32 phyId, u32 phy_op)\r\n{\r\nstruct local_phy_ctl_req payload;\r\nstruct inbound_queue_table *circularQ;\r\nint ret;\r\nu32 opc = OPC_INB_LOCAL_PHY_CONTROL;\r\nmemset(&payload, 0, sizeof(payload));\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\npayload.tag = cpu_to_le32(1);\r\npayload.phyop_phyid =\r\ncpu_to_le32(((phy_op & 0xff) << 8) | (phyId & 0x0F));\r\nret = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &payload, 0);\r\nreturn ret;\r\n}\r\nstatic u32 pm8001_chip_is_our_interupt(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu32 value;\r\n#ifdef PM8001_USE_MSIX\r\nreturn 1;\r\n#endif\r\nvalue = pm8001_cr32(pm8001_ha, 0, MSGU_ODR);\r\nif (value)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t\r\npm8001_chip_isr(struct pm8001_hba_info *pm8001_ha, u8 vec)\r\n{\r\npm8001_chip_interrupt_disable(pm8001_ha, vec);\r\nprocess_oq(pm8001_ha, vec);\r\npm8001_chip_interrupt_enable(pm8001_ha, vec);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int send_task_abort(struct pm8001_hba_info *pm8001_ha, u32 opc,\r\nu32 dev_id, u8 flag, u32 task_tag, u32 cmd_tag)\r\n{\r\nstruct task_abort_req task_abort;\r\nstruct inbound_queue_table *circularQ;\r\nint ret;\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nmemset(&task_abort, 0, sizeof(task_abort));\r\nif (ABORT_SINGLE == (flag & ABORT_MASK)) {\r\ntask_abort.abort_all = 0;\r\ntask_abort.device_id = cpu_to_le32(dev_id);\r\ntask_abort.tag_to_abort = cpu_to_le32(task_tag);\r\ntask_abort.tag = cpu_to_le32(cmd_tag);\r\n} else if (ABORT_ALL == (flag & ABORT_MASK)) {\r\ntask_abort.abort_all = cpu_to_le32(1);\r\ntask_abort.device_id = cpu_to_le32(dev_id);\r\ntask_abort.tag = cpu_to_le32(cmd_tag);\r\n}\r\nret = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &task_abort, 0);\r\nreturn ret;\r\n}\r\nint pm8001_chip_abort_task(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_device *pm8001_dev, u8 flag, u32 task_tag, u32 cmd_tag)\r\n{\r\nu32 opc, device_id;\r\nint rc = TMF_RESP_FUNC_FAILED;\r\nPM8001_EH_DBG(pm8001_ha,\r\npm8001_printk("cmd_tag = %x, abort task tag = 0x%x",\r\ncmd_tag, task_tag));\r\nif (pm8001_dev->dev_type == SAS_END_DEVICE)\r\nopc = OPC_INB_SSP_ABORT;\r\nelse if (pm8001_dev->dev_type == SAS_SATA_DEV)\r\nopc = OPC_INB_SATA_ABORT;\r\nelse\r\nopc = OPC_INB_SMP_ABORT;\r\ndevice_id = pm8001_dev->device_id;\r\nrc = send_task_abort(pm8001_ha, opc, device_id, flag,\r\ntask_tag, cmd_tag);\r\nif (rc != TMF_RESP_FUNC_COMPLETE)\r\nPM8001_EH_DBG(pm8001_ha, pm8001_printk("rc= %d\n", rc));\r\nreturn rc;\r\n}\r\nint pm8001_chip_ssp_tm_req(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_ccb_info *ccb, struct pm8001_tmf_task *tmf)\r\n{\r\nstruct sas_task *task = ccb->task;\r\nstruct domain_device *dev = task->dev;\r\nstruct pm8001_device *pm8001_dev = dev->lldd_dev;\r\nu32 opc = OPC_INB_SSPINITMSTART;\r\nstruct inbound_queue_table *circularQ;\r\nstruct ssp_ini_tm_start_req sspTMCmd;\r\nint ret;\r\nmemset(&sspTMCmd, 0, sizeof(sspTMCmd));\r\nsspTMCmd.device_id = cpu_to_le32(pm8001_dev->device_id);\r\nsspTMCmd.relate_tag = cpu_to_le32(tmf->tag_of_task_to_be_managed);\r\nsspTMCmd.tmf = cpu_to_le32(tmf->tmf);\r\nmemcpy(sspTMCmd.lun, task->ssp_task.LUN, 8);\r\nsspTMCmd.tag = cpu_to_le32(ccb->ccb_tag);\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nret = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &sspTMCmd, 0);\r\nreturn ret;\r\n}\r\nint pm8001_chip_get_nvmd_req(struct pm8001_hba_info *pm8001_ha,\r\nvoid *payload)\r\n{\r\nu32 opc = OPC_INB_GET_NVMD_DATA;\r\nu32 nvmd_type;\r\nint rc;\r\nu32 tag;\r\nstruct pm8001_ccb_info *ccb;\r\nstruct inbound_queue_table *circularQ;\r\nstruct get_nvm_data_req nvmd_req;\r\nstruct fw_control_ex *fw_control_context;\r\nstruct pm8001_ioctl_payload *ioctl_payload = payload;\r\nnvmd_type = ioctl_payload->minor_function;\r\nfw_control_context = kzalloc(sizeof(struct fw_control_ex), GFP_KERNEL);\r\nif (!fw_control_context)\r\nreturn -ENOMEM;\r\nfw_control_context->usrAddr = (u8 *)ioctl_payload->func_specific;\r\nfw_control_context->len = ioctl_payload->length;\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nmemset(&nvmd_req, 0, sizeof(nvmd_req));\r\nrc = pm8001_tag_alloc(pm8001_ha, &tag);\r\nif (rc) {\r\nkfree(fw_control_context);\r\nreturn rc;\r\n}\r\nccb = &pm8001_ha->ccb_info[tag];\r\nccb->ccb_tag = tag;\r\nccb->fw_control_context = fw_control_context;\r\nnvmd_req.tag = cpu_to_le32(tag);\r\nswitch (nvmd_type) {\r\ncase TWI_DEVICE: {\r\nu32 twi_addr, twi_page_size;\r\ntwi_addr = 0xa8;\r\ntwi_page_size = 2;\r\nnvmd_req.len_ir_vpdd = cpu_to_le32(IPMode | twi_addr << 16 |\r\ntwi_page_size << 8 | TWI_DEVICE);\r\nnvmd_req.resp_len = cpu_to_le32(ioctl_payload->length);\r\nnvmd_req.resp_addr_hi =\r\ncpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_hi);\r\nnvmd_req.resp_addr_lo =\r\ncpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_lo);\r\nbreak;\r\n}\r\ncase C_SEEPROM: {\r\nnvmd_req.len_ir_vpdd = cpu_to_le32(IPMode | C_SEEPROM);\r\nnvmd_req.resp_len = cpu_to_le32(ioctl_payload->length);\r\nnvmd_req.resp_addr_hi =\r\ncpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_hi);\r\nnvmd_req.resp_addr_lo =\r\ncpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_lo);\r\nbreak;\r\n}\r\ncase VPD_FLASH: {\r\nnvmd_req.len_ir_vpdd = cpu_to_le32(IPMode | VPD_FLASH);\r\nnvmd_req.resp_len = cpu_to_le32(ioctl_payload->length);\r\nnvmd_req.resp_addr_hi =\r\ncpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_hi);\r\nnvmd_req.resp_addr_lo =\r\ncpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_lo);\r\nbreak;\r\n}\r\ncase EXPAN_ROM: {\r\nnvmd_req.len_ir_vpdd = cpu_to_le32(IPMode | EXPAN_ROM);\r\nnvmd_req.resp_len = cpu_to_le32(ioctl_payload->length);\r\nnvmd_req.resp_addr_hi =\r\ncpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_hi);\r\nnvmd_req.resp_addr_lo =\r\ncpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_lo);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nrc = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &nvmd_req, 0);\r\nreturn rc;\r\n}\r\nint pm8001_chip_set_nvmd_req(struct pm8001_hba_info *pm8001_ha,\r\nvoid *payload)\r\n{\r\nu32 opc = OPC_INB_SET_NVMD_DATA;\r\nu32 nvmd_type;\r\nint rc;\r\nu32 tag;\r\nstruct pm8001_ccb_info *ccb;\r\nstruct inbound_queue_table *circularQ;\r\nstruct set_nvm_data_req nvmd_req;\r\nstruct fw_control_ex *fw_control_context;\r\nstruct pm8001_ioctl_payload *ioctl_payload = payload;\r\nnvmd_type = ioctl_payload->minor_function;\r\nfw_control_context = kzalloc(sizeof(struct fw_control_ex), GFP_KERNEL);\r\nif (!fw_control_context)\r\nreturn -ENOMEM;\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nmemcpy(pm8001_ha->memoryMap.region[NVMD].virt_ptr,\r\n&ioctl_payload->func_specific,\r\nioctl_payload->length);\r\nmemset(&nvmd_req, 0, sizeof(nvmd_req));\r\nrc = pm8001_tag_alloc(pm8001_ha, &tag);\r\nif (rc) {\r\nkfree(fw_control_context);\r\nreturn rc;\r\n}\r\nccb = &pm8001_ha->ccb_info[tag];\r\nccb->fw_control_context = fw_control_context;\r\nccb->ccb_tag = tag;\r\nnvmd_req.tag = cpu_to_le32(tag);\r\nswitch (nvmd_type) {\r\ncase TWI_DEVICE: {\r\nu32 twi_addr, twi_page_size;\r\ntwi_addr = 0xa8;\r\ntwi_page_size = 2;\r\nnvmd_req.reserved[0] = cpu_to_le32(0xFEDCBA98);\r\nnvmd_req.len_ir_vpdd = cpu_to_le32(IPMode | twi_addr << 16 |\r\ntwi_page_size << 8 | TWI_DEVICE);\r\nnvmd_req.resp_len = cpu_to_le32(ioctl_payload->length);\r\nnvmd_req.resp_addr_hi =\r\ncpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_hi);\r\nnvmd_req.resp_addr_lo =\r\ncpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_lo);\r\nbreak;\r\n}\r\ncase C_SEEPROM:\r\nnvmd_req.len_ir_vpdd = cpu_to_le32(IPMode | C_SEEPROM);\r\nnvmd_req.resp_len = cpu_to_le32(ioctl_payload->length);\r\nnvmd_req.reserved[0] = cpu_to_le32(0xFEDCBA98);\r\nnvmd_req.resp_addr_hi =\r\ncpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_hi);\r\nnvmd_req.resp_addr_lo =\r\ncpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_lo);\r\nbreak;\r\ncase VPD_FLASH:\r\nnvmd_req.len_ir_vpdd = cpu_to_le32(IPMode | VPD_FLASH);\r\nnvmd_req.resp_len = cpu_to_le32(ioctl_payload->length);\r\nnvmd_req.reserved[0] = cpu_to_le32(0xFEDCBA98);\r\nnvmd_req.resp_addr_hi =\r\ncpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_hi);\r\nnvmd_req.resp_addr_lo =\r\ncpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_lo);\r\nbreak;\r\ncase EXPAN_ROM:\r\nnvmd_req.len_ir_vpdd = cpu_to_le32(IPMode | EXPAN_ROM);\r\nnvmd_req.resp_len = cpu_to_le32(ioctl_payload->length);\r\nnvmd_req.reserved[0] = cpu_to_le32(0xFEDCBA98);\r\nnvmd_req.resp_addr_hi =\r\ncpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_hi);\r\nnvmd_req.resp_addr_lo =\r\ncpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_lo);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nrc = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &nvmd_req, 0);\r\nreturn rc;\r\n}\r\nint\r\npm8001_chip_fw_flash_update_build(struct pm8001_hba_info *pm8001_ha,\r\nvoid *fw_flash_updata_info, u32 tag)\r\n{\r\nstruct fw_flash_Update_req payload;\r\nstruct fw_flash_updata_info *info;\r\nstruct inbound_queue_table *circularQ;\r\nint ret;\r\nu32 opc = OPC_INB_FW_FLASH_UPDATE;\r\nmemset(&payload, 0, sizeof(struct fw_flash_Update_req));\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\ninfo = fw_flash_updata_info;\r\npayload.tag = cpu_to_le32(tag);\r\npayload.cur_image_len = cpu_to_le32(info->cur_image_len);\r\npayload.cur_image_offset = cpu_to_le32(info->cur_image_offset);\r\npayload.total_image_len = cpu_to_le32(info->total_image_len);\r\npayload.len = info->sgl.im_len.len ;\r\npayload.sgl_addr_lo =\r\ncpu_to_le32(lower_32_bits(le64_to_cpu(info->sgl.addr)));\r\npayload.sgl_addr_hi =\r\ncpu_to_le32(upper_32_bits(le64_to_cpu(info->sgl.addr)));\r\nret = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &payload, 0);\r\nreturn ret;\r\n}\r\nint\r\npm8001_chip_fw_flash_update_req(struct pm8001_hba_info *pm8001_ha,\r\nvoid *payload)\r\n{\r\nstruct fw_flash_updata_info flash_update_info;\r\nstruct fw_control_info *fw_control;\r\nstruct fw_control_ex *fw_control_context;\r\nint rc;\r\nu32 tag;\r\nstruct pm8001_ccb_info *ccb;\r\nvoid *buffer = pm8001_ha->memoryMap.region[FW_FLASH].virt_ptr;\r\ndma_addr_t phys_addr = pm8001_ha->memoryMap.region[FW_FLASH].phys_addr;\r\nstruct pm8001_ioctl_payload *ioctl_payload = payload;\r\nfw_control_context = kzalloc(sizeof(struct fw_control_ex), GFP_KERNEL);\r\nif (!fw_control_context)\r\nreturn -ENOMEM;\r\nfw_control = (struct fw_control_info *)&ioctl_payload->func_specific;\r\nmemcpy(buffer, fw_control->buffer, fw_control->len);\r\nflash_update_info.sgl.addr = cpu_to_le64(phys_addr);\r\nflash_update_info.sgl.im_len.len = cpu_to_le32(fw_control->len);\r\nflash_update_info.sgl.im_len.e = 0;\r\nflash_update_info.cur_image_offset = fw_control->offset;\r\nflash_update_info.cur_image_len = fw_control->len;\r\nflash_update_info.total_image_len = fw_control->size;\r\nfw_control_context->fw_control = fw_control;\r\nfw_control_context->virtAddr = buffer;\r\nfw_control_context->phys_addr = phys_addr;\r\nfw_control_context->len = fw_control->len;\r\nrc = pm8001_tag_alloc(pm8001_ha, &tag);\r\nif (rc) {\r\nkfree(fw_control_context);\r\nreturn rc;\r\n}\r\nccb = &pm8001_ha->ccb_info[tag];\r\nccb->fw_control_context = fw_control_context;\r\nccb->ccb_tag = tag;\r\nrc = pm8001_chip_fw_flash_update_build(pm8001_ha, &flash_update_info,\r\ntag);\r\nreturn rc;\r\n}\r\nint\r\npm8001_chip_set_dev_state_req(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_device *pm8001_dev, u32 state)\r\n{\r\nstruct set_dev_state_req payload;\r\nstruct inbound_queue_table *circularQ;\r\nstruct pm8001_ccb_info *ccb;\r\nint rc;\r\nu32 tag;\r\nu32 opc = OPC_INB_SET_DEVICE_STATE;\r\nmemset(&payload, 0, sizeof(payload));\r\nrc = pm8001_tag_alloc(pm8001_ha, &tag);\r\nif (rc)\r\nreturn -1;\r\nccb = &pm8001_ha->ccb_info[tag];\r\nccb->ccb_tag = tag;\r\nccb->device = pm8001_dev;\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\npayload.tag = cpu_to_le32(tag);\r\npayload.device_id = cpu_to_le32(pm8001_dev->device_id);\r\npayload.nds = cpu_to_le32(state);\r\nrc = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &payload, 0);\r\nreturn rc;\r\n}\r\nstatic int\r\npm8001_chip_sas_re_initialization(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nstruct sas_re_initialization_req payload;\r\nstruct inbound_queue_table *circularQ;\r\nstruct pm8001_ccb_info *ccb;\r\nint rc;\r\nu32 tag;\r\nu32 opc = OPC_INB_SAS_RE_INITIALIZE;\r\nmemset(&payload, 0, sizeof(payload));\r\nrc = pm8001_tag_alloc(pm8001_ha, &tag);\r\nif (rc)\r\nreturn -1;\r\nccb = &pm8001_ha->ccb_info[tag];\r\nccb->ccb_tag = tag;\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\npayload.tag = cpu_to_le32(tag);\r\npayload.SSAHOLT = cpu_to_le32(0xd << 25);\r\npayload.sata_hol_tmo = cpu_to_le32(80);\r\npayload.open_reject_cmdretries_data_retries = cpu_to_le32(0xff00ff);\r\nrc = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &payload, 0);\r\nreturn rc;\r\n}
