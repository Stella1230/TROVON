static int poseidon_check_mode_radio(struct poseidon *p)\r\n{\r\nint ret;\r\nu32 status;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(HZ/2);\r\nret = usb_set_interface(p->udev, 0, BULK_ALTERNATE_IFACE);\r\nif (ret < 0)\r\ngoto out;\r\nret = set_tuner_mode(p, TLG_MODE_FM_RADIO);\r\nif (ret != 0)\r\ngoto out;\r\nret = send_set_req(p, SGNL_SRC_SEL, TLG_SIG_SRC_ANTENNA, &status);\r\nret = send_set_req(p, TUNER_AUD_ANA_STD,\r\np->radio_data.pre_emphasis, &status);\r\nret |= send_set_req(p, TUNER_AUD_MODE,\r\nTLG_TUNE_TVAUDIO_MODE_STEREO, &status);\r\nret |= send_set_req(p, AUDIO_SAMPLE_RATE_SEL,\r\nATV_AUDIO_RATE_48K, &status);\r\nret |= send_set_req(p, TUNE_FREQ_SELECT, TUNER_FREQ_MIN_FM, &status);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int pm_fm_suspend(struct poseidon *p)\r\n{\r\nlogpm(p);\r\npm_alsa_suspend(p);\r\nusb_set_interface(p->udev, 0, 0);\r\nmsleep(300);\r\nreturn 0;\r\n}\r\nstatic int pm_fm_resume(struct poseidon *p)\r\n{\r\nlogpm(p);\r\nposeidon_check_mode_radio(p);\r\nset_frequency(p, p->radio_data.fm_freq);\r\npm_alsa_resume(p);\r\nreturn 0;\r\n}\r\nstatic int poseidon_fm_open(struct file *filp)\r\n{\r\nstruct poseidon *p = video_drvdata(filp);\r\nint ret = 0;\r\nmutex_lock(&p->lock);\r\nif (p->state & POSEIDON_STATE_DISCONNECT) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (p->state && !(p->state & POSEIDON_STATE_FM)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nret = v4l2_fh_open(filp);\r\nif (ret)\r\ngoto out;\r\nusb_autopm_get_interface(p->interface);\r\nif (0 == p->state) {\r\nstruct video_device *vfd = &p->radio_data.fm_dev;\r\nif (p->radio_data.pre_emphasis == 0)\r\np->radio_data.pre_emphasis = TLG_TUNE_ASTD_FM_EUR;\r\nset_debug_mode(vfd, debug_mode);\r\nret = poseidon_check_mode_radio(p);\r\nif (ret < 0) {\r\nusb_autopm_put_interface(p->interface);\r\ngoto out;\r\n}\r\np->state |= POSEIDON_STATE_FM;\r\n}\r\nkref_get(&p->kref);\r\nout:\r\nmutex_unlock(&p->lock);\r\nreturn ret;\r\n}\r\nstatic int poseidon_fm_close(struct file *filp)\r\n{\r\nstruct poseidon *p = video_drvdata(filp);\r\nstruct radio_data *fm = &p->radio_data;\r\nuint32_t status;\r\nmutex_lock(&p->lock);\r\nif (v4l2_fh_is_singular_file(filp))\r\np->state &= ~POSEIDON_STATE_FM;\r\nif (fm->is_radio_streaming && filp == p->file_for_stream) {\r\nfm->is_radio_streaming = 0;\r\nsend_set_req(p, PLAY_SERVICE, TLG_TUNE_PLAY_SVC_STOP, &status);\r\n}\r\nusb_autopm_put_interface(p->interface);\r\nmutex_unlock(&p->lock);\r\nkref_put(&p->kref, poseidon_delete);\r\nreturn v4l2_fh_release(filp);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstruct poseidon *p = video_drvdata(file);\r\nstrlcpy(v->driver, "tele-radio", sizeof(v->driver));\r\nstrlcpy(v->card, "Telegent Poseidon", sizeof(v->card));\r\nusb_make_path(p->udev, v->bus_info, sizeof(v->bus_info));\r\nv->device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\r\nv->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS |\r\nV4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VBI_CAPTURE |\r\nV4L2_CAP_AUDIO | V4L2_CAP_STREAMING |\r\nV4L2_CAP_READWRITE;\r\nreturn 0;\r\n}\r\nstatic int tlg_fm_vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *vt)\r\n{\r\nstruct poseidon *p = video_drvdata(file);\r\nstruct tuner_fm_sig_stat_s fm_stat = {};\r\nint ret, status, count = 5;\r\nif (vt->index != 0)\r\nreturn -EINVAL;\r\nvt->type = V4L2_TUNER_RADIO;\r\nvt->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LOW;\r\nvt->rangelow = TUNER_FREQ_MIN_FM * 2 / 125;\r\nvt->rangehigh = TUNER_FREQ_MAX_FM * 2 / 125;\r\nvt->rxsubchans = V4L2_TUNER_SUB_STEREO;\r\nvt->audmode = V4L2_TUNER_MODE_STEREO;\r\nvt->signal = 0;\r\nvt->afc = 0;\r\nstrlcpy(vt->name, "Radio", sizeof(vt->name));\r\nmutex_lock(&p->lock);\r\nret = send_get_req(p, TUNER_STATUS, TLG_MODE_FM_RADIO,\r\n&fm_stat, &status, sizeof(fm_stat));\r\nwhile (fm_stat.sig_lock_busy && count-- && !ret) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(HZ);\r\nret = send_get_req(p, TUNER_STATUS, TLG_MODE_FM_RADIO,\r\n&fm_stat, &status, sizeof(fm_stat));\r\n}\r\nmutex_unlock(&p->lock);\r\nif (ret || status) {\r\nvt->signal = 0;\r\n} else if ((fm_stat.sig_present || fm_stat.sig_locked)\r\n&& fm_stat.sig_strength == 0) {\r\nvt->signal = 0xffff;\r\n} else\r\nvt->signal = (fm_stat.sig_strength * 255 / 10) << 8;\r\nreturn 0;\r\n}\r\nstatic int fm_get_freq(struct file *file, void *priv,\r\nstruct v4l2_frequency *argp)\r\n{\r\nstruct poseidon *p = video_drvdata(file);\r\nif (argp->tuner)\r\nreturn -EINVAL;\r\nargp->frequency = p->radio_data.fm_freq;\r\nreturn 0;\r\n}\r\nstatic int set_frequency(struct poseidon *p, __u32 frequency)\r\n{\r\n__u32 freq ;\r\nint ret, status;\r\nmutex_lock(&p->lock);\r\nret = send_set_req(p, TUNER_AUD_ANA_STD,\r\np->radio_data.pre_emphasis, &status);\r\nfreq = (frequency * 125) / 2;\r\nfreq = clamp(freq, TUNER_FREQ_MIN_FM, TUNER_FREQ_MAX_FM);\r\nret = send_set_req(p, TUNE_FREQ_SELECT, freq, &status);\r\nif (ret < 0)\r\ngoto error ;\r\nret = send_set_req(p, TAKE_REQUEST, 0, &status);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(HZ/4);\r\nif (!p->radio_data.is_radio_streaming) {\r\nret = send_set_req(p, TAKE_REQUEST, 0, &status);\r\nret = send_set_req(p, PLAY_SERVICE,\r\nTLG_TUNE_PLAY_SVC_START, &status);\r\np->radio_data.is_radio_streaming = 1;\r\n}\r\np->radio_data.fm_freq = freq * 2 / 125;\r\nerror:\r\nmutex_unlock(&p->lock);\r\nreturn ret;\r\n}\r\nstatic int fm_set_freq(struct file *file, void *priv,\r\nconst struct v4l2_frequency *argp)\r\n{\r\nstruct poseidon *p = video_drvdata(file);\r\nif (argp->tuner)\r\nreturn -EINVAL;\r\np->file_for_stream = file;\r\n#ifdef CONFIG_PM\r\np->pm_suspend = pm_fm_suspend;\r\np->pm_resume = pm_fm_resume;\r\n#endif\r\nreturn set_frequency(p, argp->frequency);\r\n}\r\nstatic int tlg_fm_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct poseidon *p = container_of(ctrl->handler, struct poseidon,\r\nradio_data.ctrl_handler);\r\nint pre_emphasis;\r\nu32 status;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_TUNE_PREEMPHASIS:\r\npre_emphasis = preemphasis[ctrl->val];\r\nsend_set_req(p, TUNER_AUD_ANA_STD, pre_emphasis, &status);\r\np->radio_data.pre_emphasis = pre_emphasis;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv, const struct v4l2_tuner *vt)\r\n{\r\nreturn vt->index > 0 ? -EINVAL : 0;\r\n}\r\nint poseidon_fm_init(struct poseidon *p)\r\n{\r\nstruct video_device *vfd = &p->radio_data.fm_dev;\r\nstruct v4l2_ctrl_handler *hdl = &p->radio_data.ctrl_handler;\r\n*vfd = poseidon_fm_template;\r\nset_frequency(p, TUNER_FREQ_MIN_FM);\r\nv4l2_ctrl_handler_init(hdl, 1);\r\nv4l2_ctrl_new_std_menu(hdl, &tlg_fm_ctrl_ops, V4L2_CID_TUNE_PREEMPHASIS,\r\nV4L2_PREEMPHASIS_75_uS, 0, V4L2_PREEMPHASIS_50_uS);\r\nif (hdl->error) {\r\nv4l2_ctrl_handler_free(hdl);\r\nreturn hdl->error;\r\n}\r\nvfd->v4l2_dev = &p->v4l2_dev;\r\nvfd->ctrl_handler = hdl;\r\nset_bit(V4L2_FL_USE_FH_PRIO, &vfd->flags);\r\nvideo_set_drvdata(vfd, p);\r\nreturn video_register_device(vfd, VFL_TYPE_RADIO, -1);\r\n}\r\nint poseidon_fm_exit(struct poseidon *p)\r\n{\r\nvideo_unregister_device(&p->radio_data.fm_dev);\r\nv4l2_ctrl_handler_free(&p->radio_data.ctrl_handler);\r\nreturn 0;\r\n}
