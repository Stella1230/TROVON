void tcf_hash_destroy(struct tcf_common *p, struct tcf_hashinfo *hinfo)\r\n{\r\nunsigned int h = tcf_hash(p->tcfc_index, hinfo->hmask);\r\nstruct tcf_common **p1p;\r\nfor (p1p = &hinfo->htab[h]; *p1p; p1p = &(*p1p)->tcfc_next) {\r\nif (*p1p == p) {\r\nwrite_lock_bh(hinfo->lock);\r\n*p1p = p->tcfc_next;\r\nwrite_unlock_bh(hinfo->lock);\r\ngen_kill_estimator(&p->tcfc_bstats,\r\n&p->tcfc_rate_est);\r\nkfree_rcu(p, tcfc_rcu);\r\nreturn;\r\n}\r\n}\r\nWARN_ON(1);\r\n}\r\nint tcf_hash_release(struct tcf_common *p, int bind,\r\nstruct tcf_hashinfo *hinfo)\r\n{\r\nint ret = 0;\r\nif (p) {\r\nif (bind)\r\np->tcfc_bindcnt--;\r\np->tcfc_refcnt--;\r\nif (p->tcfc_bindcnt <= 0 && p->tcfc_refcnt <= 0) {\r\ntcf_hash_destroy(p, hinfo);\r\nret = 1;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int tcf_dump_walker(struct sk_buff *skb, struct netlink_callback *cb,\r\nstruct tc_action *a, struct tcf_hashinfo *hinfo)\r\n{\r\nstruct tcf_common *p;\r\nint err = 0, index = -1, i = 0, s_i = 0, n_i = 0;\r\nstruct nlattr *nest;\r\nread_lock_bh(hinfo->lock);\r\ns_i = cb->args[0];\r\nfor (i = 0; i < (hinfo->hmask + 1); i++) {\r\np = hinfo->htab[tcf_hash(i, hinfo->hmask)];\r\nfor (; p; p = p->tcfc_next) {\r\nindex++;\r\nif (index < s_i)\r\ncontinue;\r\na->priv = p;\r\na->order = n_i;\r\nnest = nla_nest_start(skb, a->order);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nerr = tcf_action_dump_1(skb, a, 0, 0);\r\nif (err < 0) {\r\nindex--;\r\nnlmsg_trim(skb, nest);\r\ngoto done;\r\n}\r\nnla_nest_end(skb, nest);\r\nn_i++;\r\nif (n_i >= TCA_ACT_MAX_PRIO)\r\ngoto done;\r\n}\r\n}\r\ndone:\r\nread_unlock_bh(hinfo->lock);\r\nif (n_i)\r\ncb->args[0] += n_i;\r\nreturn n_i;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nest);\r\ngoto done;\r\n}\r\nstatic int tcf_del_walker(struct sk_buff *skb, struct tc_action *a,\r\nstruct tcf_hashinfo *hinfo)\r\n{\r\nstruct tcf_common *p, *s_p;\r\nstruct nlattr *nest;\r\nint i = 0, n_i = 0;\r\nnest = nla_nest_start(skb, a->order);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (nla_put_string(skb, TCA_KIND, a->ops->kind))\r\ngoto nla_put_failure;\r\nfor (i = 0; i < (hinfo->hmask + 1); i++) {\r\np = hinfo->htab[tcf_hash(i, hinfo->hmask)];\r\nwhile (p != NULL) {\r\ns_p = p->tcfc_next;\r\nif (ACT_P_DELETED == tcf_hash_release(p, 0, hinfo))\r\nmodule_put(a->ops->owner);\r\nn_i++;\r\np = s_p;\r\n}\r\n}\r\nif (nla_put_u32(skb, TCA_FCNT, n_i))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\nreturn n_i;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nest);\r\nreturn -EINVAL;\r\n}\r\nint tcf_generic_walker(struct sk_buff *skb, struct netlink_callback *cb,\r\nint type, struct tc_action *a)\r\n{\r\nstruct tcf_hashinfo *hinfo = a->ops->hinfo;\r\nif (type == RTM_DELACTION) {\r\nreturn tcf_del_walker(skb, a, hinfo);\r\n} else if (type == RTM_GETACTION) {\r\nreturn tcf_dump_walker(skb, cb, a, hinfo);\r\n} else {\r\nWARN(1, "tcf_generic_walker: unknown action %d\n", type);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstruct tcf_common *tcf_hash_lookup(u32 index, struct tcf_hashinfo *hinfo)\r\n{\r\nstruct tcf_common *p;\r\nread_lock_bh(hinfo->lock);\r\nfor (p = hinfo->htab[tcf_hash(index, hinfo->hmask)]; p;\r\np = p->tcfc_next) {\r\nif (p->tcfc_index == index)\r\nbreak;\r\n}\r\nread_unlock_bh(hinfo->lock);\r\nreturn p;\r\n}\r\nu32 tcf_hash_new_index(u32 *idx_gen, struct tcf_hashinfo *hinfo)\r\n{\r\nu32 val = *idx_gen;\r\ndo {\r\nif (++val == 0)\r\nval = 1;\r\n} while (tcf_hash_lookup(val, hinfo));\r\nreturn (*idx_gen = val);\r\n}\r\nint tcf_hash_search(struct tc_action *a, u32 index)\r\n{\r\nstruct tcf_hashinfo *hinfo = a->ops->hinfo;\r\nstruct tcf_common *p = tcf_hash_lookup(index, hinfo);\r\nif (p) {\r\na->priv = p;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstruct tcf_common *tcf_hash_check(u32 index, struct tc_action *a, int bind,\r\nstruct tcf_hashinfo *hinfo)\r\n{\r\nstruct tcf_common *p = NULL;\r\nif (index && (p = tcf_hash_lookup(index, hinfo)) != NULL) {\r\nif (bind)\r\np->tcfc_bindcnt++;\r\np->tcfc_refcnt++;\r\na->priv = p;\r\n}\r\nreturn p;\r\n}\r\nstruct tcf_common *tcf_hash_create(u32 index, struct nlattr *est,\r\nstruct tc_action *a, int size, int bind,\r\nu32 *idx_gen, struct tcf_hashinfo *hinfo)\r\n{\r\nstruct tcf_common *p = kzalloc(size, GFP_KERNEL);\r\nif (unlikely(!p))\r\nreturn ERR_PTR(-ENOMEM);\r\np->tcfc_refcnt = 1;\r\nif (bind)\r\np->tcfc_bindcnt = 1;\r\nspin_lock_init(&p->tcfc_lock);\r\np->tcfc_index = index ? index : tcf_hash_new_index(idx_gen, hinfo);\r\np->tcfc_tm.install = jiffies;\r\np->tcfc_tm.lastuse = jiffies;\r\nif (est) {\r\nint err = gen_new_estimator(&p->tcfc_bstats, &p->tcfc_rate_est,\r\n&p->tcfc_lock, est);\r\nif (err) {\r\nkfree(p);\r\nreturn ERR_PTR(err);\r\n}\r\n}\r\na->priv = (void *) p;\r\nreturn p;\r\n}\r\nvoid tcf_hash_insert(struct tcf_common *p, struct tcf_hashinfo *hinfo)\r\n{\r\nunsigned int h = tcf_hash(p->tcfc_index, hinfo->hmask);\r\nwrite_lock_bh(hinfo->lock);\r\np->tcfc_next = hinfo->htab[h];\r\nhinfo->htab[h] = p;\r\nwrite_unlock_bh(hinfo->lock);\r\n}\r\nint tcf_register_action(struct tc_action_ops *act)\r\n{\r\nstruct tc_action_ops *a, **ap;\r\nwrite_lock(&act_mod_lock);\r\nfor (ap = &act_base; (a = *ap) != NULL; ap = &a->next) {\r\nif (act->type == a->type || (strcmp(act->kind, a->kind) == 0)) {\r\nwrite_unlock(&act_mod_lock);\r\nreturn -EEXIST;\r\n}\r\n}\r\nact->next = NULL;\r\n*ap = act;\r\nwrite_unlock(&act_mod_lock);\r\nreturn 0;\r\n}\r\nint tcf_unregister_action(struct tc_action_ops *act)\r\n{\r\nstruct tc_action_ops *a, **ap;\r\nint err = -ENOENT;\r\nwrite_lock(&act_mod_lock);\r\nfor (ap = &act_base; (a = *ap) != NULL; ap = &a->next)\r\nif (a == act)\r\nbreak;\r\nif (a) {\r\n*ap = a->next;\r\na->next = NULL;\r\nerr = 0;\r\n}\r\nwrite_unlock(&act_mod_lock);\r\nreturn err;\r\n}\r\nstatic struct tc_action_ops *tc_lookup_action_n(char *kind)\r\n{\r\nstruct tc_action_ops *a = NULL;\r\nif (kind) {\r\nread_lock(&act_mod_lock);\r\nfor (a = act_base; a; a = a->next) {\r\nif (strcmp(kind, a->kind) == 0) {\r\nif (!try_module_get(a->owner)) {\r\nread_unlock(&act_mod_lock);\r\nreturn NULL;\r\n}\r\nbreak;\r\n}\r\n}\r\nread_unlock(&act_mod_lock);\r\n}\r\nreturn a;\r\n}\r\nstatic struct tc_action_ops *tc_lookup_action(struct nlattr *kind)\r\n{\r\nstruct tc_action_ops *a = NULL;\r\nif (kind) {\r\nread_lock(&act_mod_lock);\r\nfor (a = act_base; a; a = a->next) {\r\nif (nla_strcmp(kind, a->kind) == 0) {\r\nif (!try_module_get(a->owner)) {\r\nread_unlock(&act_mod_lock);\r\nreturn NULL;\r\n}\r\nbreak;\r\n}\r\n}\r\nread_unlock(&act_mod_lock);\r\n}\r\nreturn a;\r\n}\r\nint tcf_action_exec(struct sk_buff *skb, const struct tc_action *act,\r\nstruct tcf_result *res)\r\n{\r\nconst struct tc_action *a;\r\nint ret = -1;\r\nif (skb->tc_verd & TC_NCLS) {\r\nskb->tc_verd = CLR_TC_NCLS(skb->tc_verd);\r\nret = TC_ACT_OK;\r\ngoto exec_done;\r\n}\r\nwhile ((a = act) != NULL) {\r\nrepeat:\r\nif (a->ops && a->ops->act) {\r\nret = a->ops->act(skb, a, res);\r\nif (TC_MUNGED & skb->tc_verd) {\r\nskb->tc_verd = SET_TC_OK2MUNGE(skb->tc_verd);\r\nskb->tc_verd = CLR_TC_MUNGED(skb->tc_verd);\r\n}\r\nif (ret == TC_ACT_REPEAT)\r\ngoto repeat;\r\nif (ret != TC_ACT_PIPE)\r\ngoto exec_done;\r\n}\r\nact = a->next;\r\n}\r\nexec_done:\r\nreturn ret;\r\n}\r\nvoid tcf_action_destroy(struct tc_action *act, int bind)\r\n{\r\nstruct tc_action *a;\r\nfor (a = act; a; a = act) {\r\nif (a->ops && a->ops->cleanup) {\r\nif (a->ops->cleanup(a, bind) == ACT_P_DELETED)\r\nmodule_put(a->ops->owner);\r\nact = act->next;\r\nkfree(a);\r\n} else {\r\nWARN(1, "tcf_action_destroy: BUG? destroying NULL ops\n");\r\nact = act->next;\r\nkfree(a);\r\n}\r\n}\r\n}\r\nint\r\ntcf_action_dump_old(struct sk_buff *skb, struct tc_action *a, int bind, int ref)\r\n{\r\nint err = -EINVAL;\r\nif (a->ops == NULL || a->ops->dump == NULL)\r\nreturn err;\r\nreturn a->ops->dump(skb, a, bind, ref);\r\n}\r\nint\r\ntcf_action_dump_1(struct sk_buff *skb, struct tc_action *a, int bind, int ref)\r\n{\r\nint err = -EINVAL;\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct nlattr *nest;\r\nif (a->ops == NULL || a->ops->dump == NULL)\r\nreturn err;\r\nif (nla_put_string(skb, TCA_KIND, a->ops->kind))\r\ngoto nla_put_failure;\r\nif (tcf_action_copy_stats(skb, a, 0))\r\ngoto nla_put_failure;\r\nnest = nla_nest_start(skb, TCA_OPTIONS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nerr = tcf_action_dump_old(skb, a, bind, ref);\r\nif (err > 0) {\r\nnla_nest_end(skb, nest);\r\nreturn err;\r\n}\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nint\r\ntcf_action_dump(struct sk_buff *skb, struct tc_action *act, int bind, int ref)\r\n{\r\nstruct tc_action *a;\r\nint err = -EINVAL;\r\nstruct nlattr *nest;\r\nwhile ((a = act) != NULL) {\r\nact = a->next;\r\nnest = nla_nest_start(skb, a->order);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nerr = tcf_action_dump_1(skb, a, bind, ref);\r\nif (err < 0)\r\ngoto errout;\r\nnla_nest_end(skb, nest);\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nerr = -EINVAL;\r\nerrout:\r\nnla_nest_cancel(skb, nest);\r\nreturn err;\r\n}\r\nstruct tc_action *tcf_action_init_1(struct net *net, struct nlattr *nla,\r\nstruct nlattr *est, char *name, int ovr,\r\nint bind)\r\n{\r\nstruct tc_action *a;\r\nstruct tc_action_ops *a_o;\r\nchar act_name[IFNAMSIZ];\r\nstruct nlattr *tb[TCA_ACT_MAX + 1];\r\nstruct nlattr *kind;\r\nint err;\r\nif (name == NULL) {\r\nerr = nla_parse_nested(tb, TCA_ACT_MAX, nla, NULL);\r\nif (err < 0)\r\ngoto err_out;\r\nerr = -EINVAL;\r\nkind = tb[TCA_ACT_KIND];\r\nif (kind == NULL)\r\ngoto err_out;\r\nif (nla_strlcpy(act_name, kind, IFNAMSIZ) >= IFNAMSIZ)\r\ngoto err_out;\r\n} else {\r\nerr = -EINVAL;\r\nif (strlcpy(act_name, name, IFNAMSIZ) >= IFNAMSIZ)\r\ngoto err_out;\r\n}\r\na_o = tc_lookup_action_n(act_name);\r\nif (a_o == NULL) {\r\n#ifdef CONFIG_MODULES\r\nrtnl_unlock();\r\nrequest_module("act_%s", act_name);\r\nrtnl_lock();\r\na_o = tc_lookup_action_n(act_name);\r\nif (a_o != NULL) {\r\nerr = -EAGAIN;\r\ngoto err_mod;\r\n}\r\n#endif\r\nerr = -ENOENT;\r\ngoto err_out;\r\n}\r\nerr = -ENOMEM;\r\na = kzalloc(sizeof(*a), GFP_KERNEL);\r\nif (a == NULL)\r\ngoto err_mod;\r\nif (name == NULL)\r\nerr = a_o->init(net, tb[TCA_ACT_OPTIONS], est, a, ovr, bind);\r\nelse\r\nerr = a_o->init(net, nla, est, a, ovr, bind);\r\nif (err < 0)\r\ngoto err_free;\r\nif (err != ACT_P_CREATED)\r\nmodule_put(a_o->owner);\r\na->ops = a_o;\r\nreturn a;\r\nerr_free:\r\nkfree(a);\r\nerr_mod:\r\nmodule_put(a_o->owner);\r\nerr_out:\r\nreturn ERR_PTR(err);\r\n}\r\nstruct tc_action *tcf_action_init(struct net *net, struct nlattr *nla,\r\nstruct nlattr *est, char *name, int ovr,\r\nint bind)\r\n{\r\nstruct nlattr *tb[TCA_ACT_MAX_PRIO + 1];\r\nstruct tc_action *head = NULL, *act, *act_prev = NULL;\r\nint err;\r\nint i;\r\nerr = nla_parse_nested(tb, TCA_ACT_MAX_PRIO, nla, NULL);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\nfor (i = 1; i <= TCA_ACT_MAX_PRIO && tb[i]; i++) {\r\nact = tcf_action_init_1(net, tb[i], est, name, ovr, bind);\r\nif (IS_ERR(act))\r\ngoto err;\r\nact->order = i;\r\nif (head == NULL)\r\nhead = act;\r\nelse\r\nact_prev->next = act;\r\nact_prev = act;\r\n}\r\nreturn head;\r\nerr:\r\nif (head != NULL)\r\ntcf_action_destroy(head, bind);\r\nreturn act;\r\n}\r\nint tcf_action_copy_stats(struct sk_buff *skb, struct tc_action *a,\r\nint compat_mode)\r\n{\r\nint err = 0;\r\nstruct gnet_dump d;\r\nstruct tcf_act_hdr *h = a->priv;\r\nif (h == NULL)\r\ngoto errout;\r\nif (compat_mode) {\r\nif (a->type == TCA_OLD_COMPAT)\r\nerr = gnet_stats_start_copy_compat(skb, 0,\r\nTCA_STATS, TCA_XSTATS, &h->tcf_lock, &d);\r\nelse\r\nreturn 0;\r\n} else\r\nerr = gnet_stats_start_copy(skb, TCA_ACT_STATS,\r\n&h->tcf_lock, &d);\r\nif (err < 0)\r\ngoto errout;\r\nif (a->ops != NULL && a->ops->get_stats != NULL)\r\nif (a->ops->get_stats(skb, a) < 0)\r\ngoto errout;\r\nif (gnet_stats_copy_basic(&d, &h->tcf_bstats) < 0 ||\r\ngnet_stats_copy_rate_est(&d, &h->tcf_bstats,\r\n&h->tcf_rate_est) < 0 ||\r\ngnet_stats_copy_queue(&d, &h->tcf_qstats) < 0)\r\ngoto errout;\r\nif (gnet_stats_finish_copy(&d) < 0)\r\ngoto errout;\r\nreturn 0;\r\nerrout:\r\nreturn -1;\r\n}\r\nstatic int\r\ntca_get_fill(struct sk_buff *skb, struct tc_action *a, u32 portid, u32 seq,\r\nu16 flags, int event, int bind, int ref)\r\n{\r\nstruct tcamsg *t;\r\nstruct nlmsghdr *nlh;\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct nlattr *nest;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*t), flags);\r\nif (!nlh)\r\ngoto out_nlmsg_trim;\r\nt = nlmsg_data(nlh);\r\nt->tca_family = AF_UNSPEC;\r\nt->tca__pad1 = 0;\r\nt->tca__pad2 = 0;\r\nnest = nla_nest_start(skb, TCA_ACT_TAB);\r\nif (nest == NULL)\r\ngoto out_nlmsg_trim;\r\nif (tcf_action_dump(skb, a, bind, ref) < 0)\r\ngoto out_nlmsg_trim;\r\nnla_nest_end(skb, nest);\r\nnlh->nlmsg_len = skb_tail_pointer(skb) - b;\r\nreturn skb->len;\r\nout_nlmsg_trim:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int\r\nact_get_notify(struct net *net, u32 portid, struct nlmsghdr *n,\r\nstruct tc_action *a, int event)\r\n{\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOBUFS;\r\nif (tca_get_fill(skb, a, portid, n->nlmsg_seq, 0, event, 0, 0) <= 0) {\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nreturn rtnl_unicast(skb, net, portid);\r\n}\r\nstatic struct tc_action *\r\ntcf_action_get_1(struct nlattr *nla, struct nlmsghdr *n, u32 portid)\r\n{\r\nstruct nlattr *tb[TCA_ACT_MAX + 1];\r\nstruct tc_action *a;\r\nint index;\r\nint err;\r\nerr = nla_parse_nested(tb, TCA_ACT_MAX, nla, NULL);\r\nif (err < 0)\r\ngoto err_out;\r\nerr = -EINVAL;\r\nif (tb[TCA_ACT_INDEX] == NULL ||\r\nnla_len(tb[TCA_ACT_INDEX]) < sizeof(index))\r\ngoto err_out;\r\nindex = nla_get_u32(tb[TCA_ACT_INDEX]);\r\nerr = -ENOMEM;\r\na = kzalloc(sizeof(struct tc_action), GFP_KERNEL);\r\nif (a == NULL)\r\ngoto err_out;\r\nerr = -EINVAL;\r\na->ops = tc_lookup_action(tb[TCA_ACT_KIND]);\r\nif (a->ops == NULL)\r\ngoto err_free;\r\nif (a->ops->lookup == NULL)\r\ngoto err_mod;\r\nerr = -ENOENT;\r\nif (a->ops->lookup(a, index) == 0)\r\ngoto err_mod;\r\nmodule_put(a->ops->owner);\r\nreturn a;\r\nerr_mod:\r\nmodule_put(a->ops->owner);\r\nerr_free:\r\nkfree(a);\r\nerr_out:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void cleanup_a(struct tc_action *act)\r\n{\r\nstruct tc_action *a;\r\nfor (a = act; a; a = act) {\r\nact = a->next;\r\nkfree(a);\r\n}\r\n}\r\nstatic struct tc_action *create_a(int i)\r\n{\r\nstruct tc_action *act;\r\nact = kzalloc(sizeof(*act), GFP_KERNEL);\r\nif (act == NULL) {\r\npr_debug("create_a: failed to alloc!\n");\r\nreturn NULL;\r\n}\r\nact->order = i;\r\nreturn act;\r\n}\r\nstatic int tca_action_flush(struct net *net, struct nlattr *nla,\r\nstruct nlmsghdr *n, u32 portid)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned char *b;\r\nstruct nlmsghdr *nlh;\r\nstruct tcamsg *t;\r\nstruct netlink_callback dcb;\r\nstruct nlattr *nest;\r\nstruct nlattr *tb[TCA_ACT_MAX + 1];\r\nstruct nlattr *kind;\r\nstruct tc_action *a = create_a(0);\r\nint err = -ENOMEM;\r\nif (a == NULL) {\r\npr_debug("tca_action_flush: couldnt create tc_action\n");\r\nreturn err;\r\n}\r\nskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!skb) {\r\npr_debug("tca_action_flush: failed skb alloc\n");\r\nkfree(a);\r\nreturn err;\r\n}\r\nb = skb_tail_pointer(skb);\r\nerr = nla_parse_nested(tb, TCA_ACT_MAX, nla, NULL);\r\nif (err < 0)\r\ngoto err_out;\r\nerr = -EINVAL;\r\nkind = tb[TCA_ACT_KIND];\r\na->ops = tc_lookup_action(kind);\r\nif (a->ops == NULL)\r\ngoto err_out;\r\nnlh = nlmsg_put(skb, portid, n->nlmsg_seq, RTM_DELACTION, sizeof(*t), 0);\r\nif (!nlh)\r\ngoto out_module_put;\r\nt = nlmsg_data(nlh);\r\nt->tca_family = AF_UNSPEC;\r\nt->tca__pad1 = 0;\r\nt->tca__pad2 = 0;\r\nnest = nla_nest_start(skb, TCA_ACT_TAB);\r\nif (nest == NULL)\r\ngoto out_module_put;\r\nerr = a->ops->walk(skb, &dcb, RTM_DELACTION, a);\r\nif (err < 0)\r\ngoto out_module_put;\r\nif (err == 0)\r\ngoto noflush_out;\r\nnla_nest_end(skb, nest);\r\nnlh->nlmsg_len = skb_tail_pointer(skb) - b;\r\nnlh->nlmsg_flags |= NLM_F_ROOT;\r\nmodule_put(a->ops->owner);\r\nkfree(a);\r\nerr = rtnetlink_send(skb, net, portid, RTNLGRP_TC,\r\nn->nlmsg_flags & NLM_F_ECHO);\r\nif (err > 0)\r\nreturn 0;\r\nreturn err;\r\nout_module_put:\r\nmodule_put(a->ops->owner);\r\nerr_out:\r\nnoflush_out:\r\nkfree_skb(skb);\r\nkfree(a);\r\nreturn err;\r\n}\r\nstatic int\r\ntca_action_gd(struct net *net, struct nlattr *nla, struct nlmsghdr *n,\r\nu32 portid, int event)\r\n{\r\nint i, ret;\r\nstruct nlattr *tb[TCA_ACT_MAX_PRIO + 1];\r\nstruct tc_action *head = NULL, *act, *act_prev = NULL;\r\nret = nla_parse_nested(tb, TCA_ACT_MAX_PRIO, nla, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nif (event == RTM_DELACTION && n->nlmsg_flags & NLM_F_ROOT) {\r\nif (tb[1] != NULL)\r\nreturn tca_action_flush(net, tb[1], n, portid);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nfor (i = 1; i <= TCA_ACT_MAX_PRIO && tb[i]; i++) {\r\nact = tcf_action_get_1(tb[i], n, portid);\r\nif (IS_ERR(act)) {\r\nret = PTR_ERR(act);\r\ngoto err;\r\n}\r\nact->order = i;\r\nif (head == NULL)\r\nhead = act;\r\nelse\r\nact_prev->next = act;\r\nact_prev = act;\r\n}\r\nif (event == RTM_GETACTION)\r\nret = act_get_notify(net, portid, n, head, event);\r\nelse {\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!skb) {\r\nret = -ENOBUFS;\r\ngoto err;\r\n}\r\nif (tca_get_fill(skb, head, portid, n->nlmsg_seq, 0, event,\r\n0, 1) <= 0) {\r\nkfree_skb(skb);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ntcf_action_destroy(head, 0);\r\nret = rtnetlink_send(skb, net, portid, RTNLGRP_TC,\r\nn->nlmsg_flags & NLM_F_ECHO);\r\nif (ret > 0)\r\nreturn 0;\r\nreturn ret;\r\n}\r\nerr:\r\ncleanup_a(head);\r\nreturn ret;\r\n}\r\nstatic int tcf_add_notify(struct net *net, struct tc_action *a,\r\nu32 portid, u32 seq, int event, u16 flags)\r\n{\r\nstruct tcamsg *t;\r\nstruct nlmsghdr *nlh;\r\nstruct sk_buff *skb;\r\nstruct nlattr *nest;\r\nunsigned char *b;\r\nint err = 0;\r\nskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOBUFS;\r\nb = skb_tail_pointer(skb);\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*t), flags);\r\nif (!nlh)\r\ngoto out_kfree_skb;\r\nt = nlmsg_data(nlh);\r\nt->tca_family = AF_UNSPEC;\r\nt->tca__pad1 = 0;\r\nt->tca__pad2 = 0;\r\nnest = nla_nest_start(skb, TCA_ACT_TAB);\r\nif (nest == NULL)\r\ngoto out_kfree_skb;\r\nif (tcf_action_dump(skb, a, 0, 0) < 0)\r\ngoto out_kfree_skb;\r\nnla_nest_end(skb, nest);\r\nnlh->nlmsg_len = skb_tail_pointer(skb) - b;\r\nNETLINK_CB(skb).dst_group = RTNLGRP_TC;\r\nerr = rtnetlink_send(skb, net, portid, RTNLGRP_TC, flags & NLM_F_ECHO);\r\nif (err > 0)\r\nerr = 0;\r\nreturn err;\r\nout_kfree_skb:\r\nkfree_skb(skb);\r\nreturn -1;\r\n}\r\nstatic int\r\ntcf_action_add(struct net *net, struct nlattr *nla, struct nlmsghdr *n,\r\nu32 portid, int ovr)\r\n{\r\nint ret = 0;\r\nstruct tc_action *act;\r\nstruct tc_action *a;\r\nu32 seq = n->nlmsg_seq;\r\nact = tcf_action_init(net, nla, NULL, NULL, ovr, 0);\r\nif (act == NULL)\r\ngoto done;\r\nif (IS_ERR(act)) {\r\nret = PTR_ERR(act);\r\ngoto done;\r\n}\r\nret = tcf_add_notify(net, act, portid, seq, RTM_NEWACTION, n->nlmsg_flags);\r\nfor (a = act; a; a = act) {\r\nact = a->next;\r\nkfree(a);\r\n}\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int tc_ctl_action(struct sk_buff *skb, struct nlmsghdr *n)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct nlattr *tca[TCA_ACT_MAX + 1];\r\nu32 portid = skb ? NETLINK_CB(skb).portid : 0;\r\nint ret = 0, ovr = 0;\r\nif ((n->nlmsg_type != RTM_GETACTION) && !capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nret = nlmsg_parse(n, sizeof(struct tcamsg), tca, TCA_ACT_MAX, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nif (tca[TCA_ACT_TAB] == NULL) {\r\npr_notice("tc_ctl_action: received NO action attribs\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (n->nlmsg_type) {\r\ncase RTM_NEWACTION:\r\nif (n->nlmsg_flags & NLM_F_REPLACE)\r\novr = 1;\r\nreplay:\r\nret = tcf_action_add(net, tca[TCA_ACT_TAB], n, portid, ovr);\r\nif (ret == -EAGAIN)\r\ngoto replay;\r\nbreak;\r\ncase RTM_DELACTION:\r\nret = tca_action_gd(net, tca[TCA_ACT_TAB], n,\r\nportid, RTM_DELACTION);\r\nbreak;\r\ncase RTM_GETACTION:\r\nret = tca_action_gd(net, tca[TCA_ACT_TAB], n,\r\nportid, RTM_GETACTION);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn ret;\r\n}\r\nstatic struct nlattr *\r\nfind_dump_kind(const struct nlmsghdr *n)\r\n{\r\nstruct nlattr *tb1, *tb2[TCA_ACT_MAX + 1];\r\nstruct nlattr *tb[TCA_ACT_MAX_PRIO + 1];\r\nstruct nlattr *nla[TCAA_MAX + 1];\r\nstruct nlattr *kind;\r\nif (nlmsg_parse(n, sizeof(struct tcamsg), nla, TCAA_MAX, NULL) < 0)\r\nreturn NULL;\r\ntb1 = nla[TCA_ACT_TAB];\r\nif (tb1 == NULL)\r\nreturn NULL;\r\nif (nla_parse(tb, TCA_ACT_MAX_PRIO, nla_data(tb1),\r\nNLMSG_ALIGN(nla_len(tb1)), NULL) < 0)\r\nreturn NULL;\r\nif (tb[1] == NULL)\r\nreturn NULL;\r\nif (nla_parse(tb2, TCA_ACT_MAX, nla_data(tb[1]),\r\nnla_len(tb[1]), NULL) < 0)\r\nreturn NULL;\r\nkind = tb2[TCA_ACT_KIND];\r\nreturn kind;\r\n}\r\nstatic int\r\ntc_dump_action(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct nlmsghdr *nlh;\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct nlattr *nest;\r\nstruct tc_action_ops *a_o;\r\nstruct tc_action a;\r\nint ret = 0;\r\nstruct tcamsg *t = (struct tcamsg *) nlmsg_data(cb->nlh);\r\nstruct nlattr *kind = find_dump_kind(cb->nlh);\r\nif (kind == NULL) {\r\npr_info("tc_dump_action: action bad kind\n");\r\nreturn 0;\r\n}\r\na_o = tc_lookup_action(kind);\r\nif (a_o == NULL)\r\nreturn 0;\r\nmemset(&a, 0, sizeof(struct tc_action));\r\na.ops = a_o;\r\nif (a_o->walk == NULL) {\r\nWARN(1, "tc_dump_action: %s !capable of dumping table\n",\r\na_o->kind);\r\ngoto out_module_put;\r\n}\r\nnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\r\ncb->nlh->nlmsg_type, sizeof(*t), 0);\r\nif (!nlh)\r\ngoto out_module_put;\r\nt = nlmsg_data(nlh);\r\nt->tca_family = AF_UNSPEC;\r\nt->tca__pad1 = 0;\r\nt->tca__pad2 = 0;\r\nnest = nla_nest_start(skb, TCA_ACT_TAB);\r\nif (nest == NULL)\r\ngoto out_module_put;\r\nret = a_o->walk(skb, cb, RTM_GETACTION, &a);\r\nif (ret < 0)\r\ngoto out_module_put;\r\nif (ret > 0) {\r\nnla_nest_end(skb, nest);\r\nret = skb->len;\r\n} else\r\nnla_nest_cancel(skb, nest);\r\nnlh->nlmsg_len = skb_tail_pointer(skb) - b;\r\nif (NETLINK_CB(cb->skb).portid && ret)\r\nnlh->nlmsg_flags |= NLM_F_MULTI;\r\nmodule_put(a_o->owner);\r\nreturn skb->len;\r\nout_module_put:\r\nmodule_put(a_o->owner);\r\nnlmsg_trim(skb, b);\r\nreturn skb->len;\r\n}\r\nstatic int __init tc_action_init(void)\r\n{\r\nrtnl_register(PF_UNSPEC, RTM_NEWACTION, tc_ctl_action, NULL, NULL);\r\nrtnl_register(PF_UNSPEC, RTM_DELACTION, tc_ctl_action, NULL, NULL);\r\nrtnl_register(PF_UNSPEC, RTM_GETACTION, tc_ctl_action, tc_dump_action,\r\nNULL);\r\nreturn 0;\r\n}
