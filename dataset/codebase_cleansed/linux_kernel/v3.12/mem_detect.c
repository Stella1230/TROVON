static void find_memory_chunks(struct mem_chunk chunk[], unsigned long maxsize)\r\n{\r\nunsigned long long memsize, rnmax, rzm;\r\nunsigned long addr = 0, size;\r\nint i = 0, type;\r\nrzm = sclp_get_rzm();\r\nrnmax = sclp_get_rnmax();\r\nmemsize = rzm * rnmax;\r\nif (!rzm)\r\nrzm = 1ULL << 17;\r\nif (sizeof(long) == 4) {\r\nrzm = min(ADDR2G, rzm);\r\nmemsize = memsize ? min(ADDR2G, memsize) : ADDR2G;\r\n}\r\nif (maxsize)\r\nmemsize = memsize ? min((unsigned long)memsize, maxsize) : maxsize;\r\ndo {\r\nsize = 0;\r\ntype = tprot(addr);\r\ndo {\r\nsize += rzm;\r\nif (memsize && addr + size >= memsize)\r\nbreak;\r\n} while (type == tprot(addr + size));\r\nif (type == CHUNK_READ_WRITE || type == CHUNK_READ_ONLY) {\r\nif (memsize && (addr + size > memsize))\r\nsize = memsize - addr;\r\nchunk[i].addr = addr;\r\nchunk[i].size = size;\r\nchunk[i].type = type;\r\ni++;\r\n}\r\naddr += size;\r\n} while (addr < memsize && i < MEMORY_CHUNKS);\r\n}\r\nvoid detect_memory_layout(struct mem_chunk chunk[], unsigned long maxsize)\r\n{\r\nunsigned long flags, flags_dat, cr0;\r\nmemset(chunk, 0, MEMORY_CHUNKS * sizeof(struct mem_chunk));\r\nlocal_irq_save(flags);\r\nflags_dat = __arch_local_irq_stnsm(0xfb);\r\nif (test_bit(5, &flags_dat)) {\r\nif (WARN_ON_ONCE(is_vmalloc_or_module_addr(chunk)))\r\ngoto out;\r\n}\r\n__ctl_store(cr0, 0, 0);\r\n__ctl_clear_bit(0, 28);\r\nfind_memory_chunks(chunk, maxsize);\r\n__ctl_load(cr0, 0, 0);\r\nout:\r\n__arch_local_irq_ssm(flags_dat);\r\nlocal_irq_restore(flags);\r\n}\r\nvoid create_mem_hole(struct mem_chunk mem_chunk[], unsigned long addr,\r\nunsigned long size)\r\n{\r\nint i;\r\nfor (i = 0; i < MEMORY_CHUNKS; i++) {\r\nstruct mem_chunk *chunk = &mem_chunk[i];\r\nif (chunk->size == 0)\r\ncontinue;\r\nif (addr > chunk->addr + chunk->size)\r\ncontinue;\r\nif (addr + size <= chunk->addr)\r\ncontinue;\r\nif ((addr > chunk->addr) &&\r\n(addr + size < chunk->addr + chunk->size)) {\r\nstruct mem_chunk *new = chunk + 1;\r\nmemmove(new, chunk, (MEMORY_CHUNKS-i-1) * sizeof(*new));\r\nnew->addr = addr + size;\r\nnew->size = chunk->addr + chunk->size - new->addr;\r\nchunk->size = addr - chunk->addr;\r\ncontinue;\r\n} else if ((addr <= chunk->addr) &&\r\n(addr + size >= chunk->addr + chunk->size)) {\r\nmemmove(chunk, chunk + 1, (MEMORY_CHUNKS-i-1) * sizeof(*chunk));\r\nmemset(&mem_chunk[MEMORY_CHUNKS-1], 0, sizeof(*chunk));\r\n} else if (addr + size < chunk->addr + chunk->size) {\r\nchunk->size = chunk->addr + chunk->size - addr - size;\r\nchunk->addr = addr + size;\r\n} else if (addr > chunk->addr) {\r\nchunk->size = addr - chunk->addr;\r\n}\r\n}\r\n}
