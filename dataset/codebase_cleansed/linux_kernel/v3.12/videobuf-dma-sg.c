static struct scatterlist *videobuf_vmalloc_to_sg(unsigned char *virt,\r\nint nr_pages)\r\n{\r\nstruct scatterlist *sglist;\r\nstruct page *pg;\r\nint i;\r\nsglist = vzalloc(nr_pages * sizeof(*sglist));\r\nif (NULL == sglist)\r\nreturn NULL;\r\nsg_init_table(sglist, nr_pages);\r\nfor (i = 0; i < nr_pages; i++, virt += PAGE_SIZE) {\r\npg = vmalloc_to_page(virt);\r\nif (NULL == pg)\r\ngoto err;\r\nBUG_ON(PageHighMem(pg));\r\nsg_set_page(&sglist[i], pg, PAGE_SIZE, 0);\r\n}\r\nreturn sglist;\r\nerr:\r\nvfree(sglist);\r\nreturn NULL;\r\n}\r\nstatic struct scatterlist *videobuf_pages_to_sg(struct page **pages,\r\nint nr_pages, int offset, size_t size)\r\n{\r\nstruct scatterlist *sglist;\r\nint i;\r\nif (NULL == pages[0])\r\nreturn NULL;\r\nsglist = vmalloc(nr_pages * sizeof(*sglist));\r\nif (NULL == sglist)\r\nreturn NULL;\r\nsg_init_table(sglist, nr_pages);\r\nif (PageHighMem(pages[0]))\r\ngoto highmem;\r\nsg_set_page(&sglist[0], pages[0],\r\nmin_t(size_t, PAGE_SIZE - offset, size), offset);\r\nsize -= min_t(size_t, PAGE_SIZE - offset, size);\r\nfor (i = 1; i < nr_pages; i++) {\r\nif (NULL == pages[i])\r\ngoto nopage;\r\nif (PageHighMem(pages[i]))\r\ngoto highmem;\r\nsg_set_page(&sglist[i], pages[i], min_t(size_t, PAGE_SIZE, size), 0);\r\nsize -= min_t(size_t, PAGE_SIZE, size);\r\n}\r\nreturn sglist;\r\nnopage:\r\ndprintk(2, "sgl: oops - no page\n");\r\nvfree(sglist);\r\nreturn NULL;\r\nhighmem:\r\ndprintk(2, "sgl: oops - highmem page\n");\r\nvfree(sglist);\r\nreturn NULL;\r\n}\r\nstruct videobuf_dmabuf *videobuf_to_dma(struct videobuf_buffer *buf)\r\n{\r\nstruct videobuf_dma_sg_memory *mem = buf->priv;\r\nBUG_ON(!mem);\r\nMAGIC_CHECK(mem->magic, MAGIC_SG_MEM);\r\nreturn &mem->dma;\r\n}\r\nvoid videobuf_dma_init(struct videobuf_dmabuf *dma)\r\n{\r\nmemset(dma, 0, sizeof(*dma));\r\ndma->magic = MAGIC_DMABUF;\r\n}\r\nstatic int videobuf_dma_init_user_locked(struct videobuf_dmabuf *dma,\r\nint direction, unsigned long data, unsigned long size)\r\n{\r\nunsigned long first, last;\r\nint err, rw = 0;\r\ndma->direction = direction;\r\nswitch (dma->direction) {\r\ncase DMA_FROM_DEVICE:\r\nrw = READ;\r\nbreak;\r\ncase DMA_TO_DEVICE:\r\nrw = WRITE;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nfirst = (data & PAGE_MASK) >> PAGE_SHIFT;\r\nlast = ((data+size-1) & PAGE_MASK) >> PAGE_SHIFT;\r\ndma->offset = data & ~PAGE_MASK;\r\ndma->size = size;\r\ndma->nr_pages = last-first+1;\r\ndma->pages = kmalloc(dma->nr_pages * sizeof(struct page *), GFP_KERNEL);\r\nif (NULL == dma->pages)\r\nreturn -ENOMEM;\r\ndprintk(1, "init user [0x%lx+0x%lx => %d pages]\n",\r\ndata, size, dma->nr_pages);\r\nerr = get_user_pages(current, current->mm,\r\ndata & PAGE_MASK, dma->nr_pages,\r\nrw == READ, 1,\r\ndma->pages, NULL);\r\nif (err != dma->nr_pages) {\r\ndma->nr_pages = (err >= 0) ? err : 0;\r\ndprintk(1, "get_user_pages: err=%d [%d]\n", err, dma->nr_pages);\r\nreturn err < 0 ? err : -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint videobuf_dma_init_user(struct videobuf_dmabuf *dma, int direction,\r\nunsigned long data, unsigned long size)\r\n{\r\nint ret;\r\ndown_read(&current->mm->mmap_sem);\r\nret = videobuf_dma_init_user_locked(dma, direction, data, size);\r\nup_read(&current->mm->mmap_sem);\r\nreturn ret;\r\n}\r\nint videobuf_dma_init_kernel(struct videobuf_dmabuf *dma, int direction,\r\nint nr_pages)\r\n{\r\ndprintk(1, "init kernel [%d pages]\n", nr_pages);\r\ndma->direction = direction;\r\ndma->vaddr = vmalloc_32(nr_pages << PAGE_SHIFT);\r\nif (NULL == dma->vaddr) {\r\ndprintk(1, "vmalloc_32(%d pages) failed\n", nr_pages);\r\nreturn -ENOMEM;\r\n}\r\ndprintk(1, "vmalloc is at addr 0x%08lx, size=%d\n",\r\n(unsigned long)dma->vaddr,\r\nnr_pages << PAGE_SHIFT);\r\nmemset(dma->vaddr, 0, nr_pages << PAGE_SHIFT);\r\ndma->nr_pages = nr_pages;\r\nreturn 0;\r\n}\r\nint videobuf_dma_init_overlay(struct videobuf_dmabuf *dma, int direction,\r\ndma_addr_t addr, int nr_pages)\r\n{\r\ndprintk(1, "init overlay [%d pages @ bus 0x%lx]\n",\r\nnr_pages, (unsigned long)addr);\r\ndma->direction = direction;\r\nif (0 == addr)\r\nreturn -EINVAL;\r\ndma->bus_addr = addr;\r\ndma->nr_pages = nr_pages;\r\nreturn 0;\r\n}\r\nint videobuf_dma_map(struct device *dev, struct videobuf_dmabuf *dma)\r\n{\r\nMAGIC_CHECK(dma->magic, MAGIC_DMABUF);\r\nBUG_ON(0 == dma->nr_pages);\r\nif (dma->pages) {\r\ndma->sglist = videobuf_pages_to_sg(dma->pages, dma->nr_pages,\r\ndma->offset, dma->size);\r\n}\r\nif (dma->vaddr) {\r\ndma->sglist = videobuf_vmalloc_to_sg(dma->vaddr,\r\ndma->nr_pages);\r\n}\r\nif (dma->bus_addr) {\r\ndma->sglist = vmalloc(sizeof(*dma->sglist));\r\nif (NULL != dma->sglist) {\r\ndma->sglen = 1;\r\nsg_dma_address(&dma->sglist[0]) = dma->bus_addr\r\n& PAGE_MASK;\r\ndma->sglist[0].offset = dma->bus_addr & ~PAGE_MASK;\r\nsg_dma_len(&dma->sglist[0]) = dma->nr_pages * PAGE_SIZE;\r\n}\r\n}\r\nif (NULL == dma->sglist) {\r\ndprintk(1, "scatterlist is NULL\n");\r\nreturn -ENOMEM;\r\n}\r\nif (!dma->bus_addr) {\r\ndma->sglen = dma_map_sg(dev, dma->sglist,\r\ndma->nr_pages, dma->direction);\r\nif (0 == dma->sglen) {\r\nprintk(KERN_WARNING\r\n"%s: videobuf_map_sg failed\n", __func__);\r\nvfree(dma->sglist);\r\ndma->sglist = NULL;\r\ndma->sglen = 0;\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint videobuf_dma_unmap(struct device *dev, struct videobuf_dmabuf *dma)\r\n{\r\nMAGIC_CHECK(dma->magic, MAGIC_DMABUF);\r\nif (!dma->sglen)\r\nreturn 0;\r\ndma_unmap_sg(dev, dma->sglist, dma->sglen, dma->direction);\r\nvfree(dma->sglist);\r\ndma->sglist = NULL;\r\ndma->sglen = 0;\r\nreturn 0;\r\n}\r\nint videobuf_dma_free(struct videobuf_dmabuf *dma)\r\n{\r\nint i;\r\nMAGIC_CHECK(dma->magic, MAGIC_DMABUF);\r\nBUG_ON(dma->sglen);\r\nif (dma->pages) {\r\nfor (i = 0; i < dma->nr_pages; i++)\r\npage_cache_release(dma->pages[i]);\r\nkfree(dma->pages);\r\ndma->pages = NULL;\r\n}\r\nvfree(dma->vaddr);\r\ndma->vaddr = NULL;\r\nif (dma->bus_addr)\r\ndma->bus_addr = 0;\r\ndma->direction = DMA_NONE;\r\nreturn 0;\r\n}\r\nstatic void videobuf_vm_open(struct vm_area_struct *vma)\r\n{\r\nstruct videobuf_mapping *map = vma->vm_private_data;\r\nstruct videobuf_queue *q = map->q;\r\ndprintk(2, "vm_open %p [count=%d,vma=%08lx-%08lx]\n", map,\r\nmap->count, vma->vm_start, vma->vm_end);\r\nvideobuf_queue_lock(q);\r\nmap->count++;\r\nvideobuf_queue_unlock(q);\r\n}\r\nstatic void videobuf_vm_close(struct vm_area_struct *vma)\r\n{\r\nstruct videobuf_mapping *map = vma->vm_private_data;\r\nstruct videobuf_queue *q = map->q;\r\nstruct videobuf_dma_sg_memory *mem;\r\nint i;\r\ndprintk(2, "vm_close %p [count=%d,vma=%08lx-%08lx]\n", map,\r\nmap->count, vma->vm_start, vma->vm_end);\r\nvideobuf_queue_lock(q);\r\nif (!--map->count) {\r\ndprintk(1, "munmap %p q=%p\n", map, q);\r\nfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\r\nif (NULL == q->bufs[i])\r\ncontinue;\r\nmem = q->bufs[i]->priv;\r\nif (!mem)\r\ncontinue;\r\nMAGIC_CHECK(mem->magic, MAGIC_SG_MEM);\r\nif (q->bufs[i]->map != map)\r\ncontinue;\r\nq->bufs[i]->map = NULL;\r\nq->bufs[i]->baddr = 0;\r\nq->ops->buf_release(q, q->bufs[i]);\r\n}\r\nkfree(map);\r\n}\r\nvideobuf_queue_unlock(q);\r\nreturn;\r\n}\r\nstatic int videobuf_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct page *page;\r\ndprintk(3, "fault: fault @ %08lx [vma %08lx-%08lx]\n",\r\n(unsigned long)vmf->virtual_address,\r\nvma->vm_start, vma->vm_end);\r\npage = alloc_page(GFP_USER | __GFP_DMA32);\r\nif (!page)\r\nreturn VM_FAULT_OOM;\r\nclear_user_highpage(page, (unsigned long)vmf->virtual_address);\r\nvmf->page = page;\r\nreturn 0;\r\n}\r\nstatic struct videobuf_buffer *__videobuf_alloc_vb(size_t size)\r\n{\r\nstruct videobuf_dma_sg_memory *mem;\r\nstruct videobuf_buffer *vb;\r\nvb = kzalloc(size + sizeof(*mem), GFP_KERNEL);\r\nif (!vb)\r\nreturn vb;\r\nmem = vb->priv = ((char *)vb) + size;\r\nmem->magic = MAGIC_SG_MEM;\r\nvideobuf_dma_init(&mem->dma);\r\ndprintk(1, "%s: allocated at %p(%ld+%ld) & %p(%ld)\n",\r\n__func__, vb, (long)sizeof(*vb), (long)size - sizeof(*vb),\r\nmem, (long)sizeof(*mem));\r\nreturn vb;\r\n}\r\nstatic void *__videobuf_to_vaddr(struct videobuf_buffer *buf)\r\n{\r\nstruct videobuf_dma_sg_memory *mem = buf->priv;\r\nBUG_ON(!mem);\r\nMAGIC_CHECK(mem->magic, MAGIC_SG_MEM);\r\nreturn mem->dma.vaddr;\r\n}\r\nstatic int __videobuf_iolock(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb,\r\nstruct v4l2_framebuffer *fbuf)\r\n{\r\nint err, pages;\r\ndma_addr_t bus;\r\nstruct videobuf_dma_sg_memory *mem = vb->priv;\r\nBUG_ON(!mem);\r\nMAGIC_CHECK(mem->magic, MAGIC_SG_MEM);\r\nswitch (vb->memory) {\r\ncase V4L2_MEMORY_MMAP:\r\ncase V4L2_MEMORY_USERPTR:\r\nif (0 == vb->baddr) {\r\npages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;\r\nerr = videobuf_dma_init_kernel(&mem->dma,\r\nDMA_FROM_DEVICE,\r\npages);\r\nif (0 != err)\r\nreturn err;\r\n} else if (vb->memory == V4L2_MEMORY_USERPTR) {\r\nerr = videobuf_dma_init_user(&mem->dma,\r\nDMA_FROM_DEVICE,\r\nvb->baddr, vb->bsize);\r\nif (0 != err)\r\nreturn err;\r\n} else {\r\nerr = videobuf_dma_init_user_locked(&mem->dma,\r\nDMA_FROM_DEVICE,\r\nvb->baddr, vb->bsize);\r\nif (0 != err)\r\nreturn err;\r\n}\r\nbreak;\r\ncase V4L2_MEMORY_OVERLAY:\r\nif (NULL == fbuf)\r\nreturn -EINVAL;\r\nbus = (dma_addr_t)(unsigned long)fbuf->base + vb->boff;\r\npages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;\r\nerr = videobuf_dma_init_overlay(&mem->dma, DMA_FROM_DEVICE,\r\nbus, pages);\r\nif (0 != err)\r\nreturn err;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nerr = videobuf_dma_map(q->dev, &mem->dma);\r\nif (0 != err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int __videobuf_sync(struct videobuf_queue *q,\r\nstruct videobuf_buffer *buf)\r\n{\r\nstruct videobuf_dma_sg_memory *mem = buf->priv;\r\nBUG_ON(!mem || !mem->dma.sglen);\r\nMAGIC_CHECK(mem->magic, MAGIC_SG_MEM);\r\nMAGIC_CHECK(mem->dma.magic, MAGIC_DMABUF);\r\ndma_sync_sg_for_cpu(q->dev, mem->dma.sglist,\r\nmem->dma.sglen, mem->dma.direction);\r\nreturn 0;\r\n}\r\nstatic int __videobuf_mmap_mapper(struct videobuf_queue *q,\r\nstruct videobuf_buffer *buf,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct videobuf_dma_sg_memory *mem = buf->priv;\r\nstruct videobuf_mapping *map;\r\nunsigned int first, last, size = 0, i;\r\nint retval;\r\nretval = -EINVAL;\r\nBUG_ON(!mem);\r\nMAGIC_CHECK(mem->magic, MAGIC_SG_MEM);\r\nfor (first = 0; first < VIDEO_MAX_FRAME; first++) {\r\nif (buf == q->bufs[first]) {\r\nsize = PAGE_ALIGN(q->bufs[first]->bsize);\r\nbreak;\r\n}\r\n}\r\nif (!size) {\r\ndprintk(1, "mmap app bug: offset invalid [offset=0x%lx]\n",\r\n(vma->vm_pgoff << PAGE_SHIFT));\r\ngoto done;\r\n}\r\nlast = first;\r\nretval = -ENOMEM;\r\nmap = kmalloc(sizeof(struct videobuf_mapping), GFP_KERNEL);\r\nif (NULL == map)\r\ngoto done;\r\nsize = 0;\r\nfor (i = first; i <= last; i++) {\r\nif (NULL == q->bufs[i])\r\ncontinue;\r\nq->bufs[i]->map = map;\r\nq->bufs[i]->baddr = vma->vm_start + size;\r\nsize += PAGE_ALIGN(q->bufs[i]->bsize);\r\n}\r\nmap->count = 1;\r\nmap->q = q;\r\nvma->vm_ops = &videobuf_vm_ops;\r\nvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\r\nvma->vm_flags &= ~VM_IO;\r\nvma->vm_private_data = map;\r\ndprintk(1, "mmap %p: q=%p %08lx-%08lx pgoff %08lx bufs %d-%d\n",\r\nmap, q, vma->vm_start, vma->vm_end, vma->vm_pgoff, first, last);\r\nretval = 0;\r\ndone:\r\nreturn retval;\r\n}\r\nvoid *videobuf_sg_alloc(size_t size)\r\n{\r\nstruct videobuf_queue q;\r\nq.int_ops = &sg_ops;\r\nq.msize = size;\r\nreturn videobuf_alloc_vb(&q);\r\n}\r\nvoid videobuf_queue_sg_init(struct videobuf_queue *q,\r\nconst struct videobuf_queue_ops *ops,\r\nstruct device *dev,\r\nspinlock_t *irqlock,\r\nenum v4l2_buf_type type,\r\nenum v4l2_field field,\r\nunsigned int msize,\r\nvoid *priv,\r\nstruct mutex *ext_lock)\r\n{\r\nvideobuf_queue_core_init(q, ops, dev, irqlock, type, field, msize,\r\npriv, &sg_ops, ext_lock);\r\n}
