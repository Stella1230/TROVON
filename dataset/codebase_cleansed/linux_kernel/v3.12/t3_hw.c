int t3_wait_op_done_val(struct adapter *adapter, int reg, u32 mask,\r\nint polarity, int attempts, int delay, u32 *valp)\r\n{\r\nwhile (1) {\r\nu32 val = t3_read_reg(adapter, reg);\r\nif (!!(val & mask) == polarity) {\r\nif (valp)\r\n*valp = val;\r\nreturn 0;\r\n}\r\nif (--attempts == 0)\r\nreturn -EAGAIN;\r\nif (delay)\r\nudelay(delay);\r\n}\r\n}\r\nvoid t3_write_regs(struct adapter *adapter, const struct addr_val_pair *p,\r\nint n, unsigned int offset)\r\n{\r\nwhile (n--) {\r\nt3_write_reg(adapter, p->reg_addr + offset, p->val);\r\np++;\r\n}\r\n}\r\nvoid t3_set_reg_field(struct adapter *adapter, unsigned int addr, u32 mask,\r\nu32 val)\r\n{\r\nu32 v = t3_read_reg(adapter, addr) & ~mask;\r\nt3_write_reg(adapter, addr, v | val);\r\nt3_read_reg(adapter, addr);\r\n}\r\nstatic void t3_read_indirect(struct adapter *adap, unsigned int addr_reg,\r\nunsigned int data_reg, u32 *vals,\r\nunsigned int nregs, unsigned int start_idx)\r\n{\r\nwhile (nregs--) {\r\nt3_write_reg(adap, addr_reg, start_idx);\r\n*vals++ = t3_read_reg(adap, data_reg);\r\nstart_idx++;\r\n}\r\n}\r\nint t3_mc7_bd_read(struct mc7 *mc7, unsigned int start, unsigned int n,\r\nu64 *buf)\r\n{\r\nstatic const int shift[] = { 0, 0, 16, 24 };\r\nstatic const int step[] = { 0, 32, 16, 8 };\r\nunsigned int size64 = mc7->size / 8;\r\nstruct adapter *adap = mc7->adapter;\r\nif (start >= size64 || start + n > size64)\r\nreturn -EINVAL;\r\nstart *= (8 << mc7->width);\r\nwhile (n--) {\r\nint i;\r\nu64 val64 = 0;\r\nfor (i = (1 << mc7->width) - 1; i >= 0; --i) {\r\nint attempts = 10;\r\nu32 val;\r\nt3_write_reg(adap, mc7->offset + A_MC7_BD_ADDR, start);\r\nt3_write_reg(adap, mc7->offset + A_MC7_BD_OP, 0);\r\nval = t3_read_reg(adap, mc7->offset + A_MC7_BD_OP);\r\nwhile ((val & F_BUSY) && attempts--)\r\nval = t3_read_reg(adap,\r\nmc7->offset + A_MC7_BD_OP);\r\nif (val & F_BUSY)\r\nreturn -EIO;\r\nval = t3_read_reg(adap, mc7->offset + A_MC7_BD_DATA1);\r\nif (mc7->width == 0) {\r\nval64 = t3_read_reg(adap,\r\nmc7->offset +\r\nA_MC7_BD_DATA0);\r\nval64 |= (u64) val << 32;\r\n} else {\r\nif (mc7->width > 1)\r\nval >>= shift[mc7->width];\r\nval64 |= (u64) val << (step[mc7->width] * i);\r\n}\r\nstart += 8;\r\n}\r\n*buf++ = val64;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mi1_init(struct adapter *adap, const struct adapter_info *ai)\r\n{\r\nu32 clkdiv = adap->params.vpd.cclk / (2 * adap->params.vpd.mdc) - 1;\r\nu32 val = F_PREEN | V_CLKDIV(clkdiv);\r\nt3_write_reg(adap, A_MI1_CFG, val);\r\n}\r\nstatic int t3_mi1_read(struct net_device *dev, int phy_addr, int mmd_addr,\r\nu16 reg_addr)\r\n{\r\nstruct port_info *pi = netdev_priv(dev);\r\nstruct adapter *adapter = pi->adapter;\r\nint ret;\r\nu32 addr = V_REGADDR(reg_addr) | V_PHYADDR(phy_addr);\r\nmutex_lock(&adapter->mdio_lock);\r\nt3_set_reg_field(adapter, A_MI1_CFG, V_ST(M_ST), V_ST(1));\r\nt3_write_reg(adapter, A_MI1_ADDR, addr);\r\nt3_write_reg(adapter, A_MI1_OP, V_MDI_OP(2));\r\nret = t3_wait_op_done(adapter, A_MI1_OP, F_BUSY, 0, MDIO_ATTEMPTS, 10);\r\nif (!ret)\r\nret = t3_read_reg(adapter, A_MI1_DATA);\r\nmutex_unlock(&adapter->mdio_lock);\r\nreturn ret;\r\n}\r\nstatic int t3_mi1_write(struct net_device *dev, int phy_addr, int mmd_addr,\r\nu16 reg_addr, u16 val)\r\n{\r\nstruct port_info *pi = netdev_priv(dev);\r\nstruct adapter *adapter = pi->adapter;\r\nint ret;\r\nu32 addr = V_REGADDR(reg_addr) | V_PHYADDR(phy_addr);\r\nmutex_lock(&adapter->mdio_lock);\r\nt3_set_reg_field(adapter, A_MI1_CFG, V_ST(M_ST), V_ST(1));\r\nt3_write_reg(adapter, A_MI1_ADDR, addr);\r\nt3_write_reg(adapter, A_MI1_DATA, val);\r\nt3_write_reg(adapter, A_MI1_OP, V_MDI_OP(1));\r\nret = t3_wait_op_done(adapter, A_MI1_OP, F_BUSY, 0, MDIO_ATTEMPTS, 10);\r\nmutex_unlock(&adapter->mdio_lock);\r\nreturn ret;\r\n}\r\nstatic int mi1_wr_addr(struct adapter *adapter, int phy_addr, int mmd_addr,\r\nint reg_addr)\r\n{\r\nu32 addr = V_REGADDR(mmd_addr) | V_PHYADDR(phy_addr);\r\nt3_set_reg_field(adapter, A_MI1_CFG, V_ST(M_ST), 0);\r\nt3_write_reg(adapter, A_MI1_ADDR, addr);\r\nt3_write_reg(adapter, A_MI1_DATA, reg_addr);\r\nt3_write_reg(adapter, A_MI1_OP, V_MDI_OP(0));\r\nreturn t3_wait_op_done(adapter, A_MI1_OP, F_BUSY, 0,\r\nMDIO_ATTEMPTS, 10);\r\n}\r\nstatic int mi1_ext_read(struct net_device *dev, int phy_addr, int mmd_addr,\r\nu16 reg_addr)\r\n{\r\nstruct port_info *pi = netdev_priv(dev);\r\nstruct adapter *adapter = pi->adapter;\r\nint ret;\r\nmutex_lock(&adapter->mdio_lock);\r\nret = mi1_wr_addr(adapter, phy_addr, mmd_addr, reg_addr);\r\nif (!ret) {\r\nt3_write_reg(adapter, A_MI1_OP, V_MDI_OP(3));\r\nret = t3_wait_op_done(adapter, A_MI1_OP, F_BUSY, 0,\r\nMDIO_ATTEMPTS, 10);\r\nif (!ret)\r\nret = t3_read_reg(adapter, A_MI1_DATA);\r\n}\r\nmutex_unlock(&adapter->mdio_lock);\r\nreturn ret;\r\n}\r\nstatic int mi1_ext_write(struct net_device *dev, int phy_addr, int mmd_addr,\r\nu16 reg_addr, u16 val)\r\n{\r\nstruct port_info *pi = netdev_priv(dev);\r\nstruct adapter *adapter = pi->adapter;\r\nint ret;\r\nmutex_lock(&adapter->mdio_lock);\r\nret = mi1_wr_addr(adapter, phy_addr, mmd_addr, reg_addr);\r\nif (!ret) {\r\nt3_write_reg(adapter, A_MI1_DATA, val);\r\nt3_write_reg(adapter, A_MI1_OP, V_MDI_OP(1));\r\nret = t3_wait_op_done(adapter, A_MI1_OP, F_BUSY, 0,\r\nMDIO_ATTEMPTS, 10);\r\n}\r\nmutex_unlock(&adapter->mdio_lock);\r\nreturn ret;\r\n}\r\nint t3_mdio_change_bits(struct cphy *phy, int mmd, int reg, unsigned int clear,\r\nunsigned int set)\r\n{\r\nint ret;\r\nunsigned int val;\r\nret = t3_mdio_read(phy, mmd, reg, &val);\r\nif (!ret) {\r\nval &= ~clear;\r\nret = t3_mdio_write(phy, mmd, reg, val | set);\r\n}\r\nreturn ret;\r\n}\r\nint t3_phy_reset(struct cphy *phy, int mmd, int wait)\r\n{\r\nint err;\r\nunsigned int ctl;\r\nerr = t3_mdio_change_bits(phy, mmd, MDIO_CTRL1, MDIO_CTRL1_LPOWER,\r\nMDIO_CTRL1_RESET);\r\nif (err || !wait)\r\nreturn err;\r\ndo {\r\nerr = t3_mdio_read(phy, mmd, MDIO_CTRL1, &ctl);\r\nif (err)\r\nreturn err;\r\nctl &= MDIO_CTRL1_RESET;\r\nif (ctl)\r\nmsleep(1);\r\n} while (ctl && --wait);\r\nreturn ctl ? -1 : 0;\r\n}\r\nint t3_phy_advertise(struct cphy *phy, unsigned int advert)\r\n{\r\nint err;\r\nunsigned int val = 0;\r\nerr = t3_mdio_read(phy, MDIO_DEVAD_NONE, MII_CTRL1000, &val);\r\nif (err)\r\nreturn err;\r\nval &= ~(ADVERTISE_1000HALF | ADVERTISE_1000FULL);\r\nif (advert & ADVERTISED_1000baseT_Half)\r\nval |= ADVERTISE_1000HALF;\r\nif (advert & ADVERTISED_1000baseT_Full)\r\nval |= ADVERTISE_1000FULL;\r\nerr = t3_mdio_write(phy, MDIO_DEVAD_NONE, MII_CTRL1000, val);\r\nif (err)\r\nreturn err;\r\nval = 1;\r\nif (advert & ADVERTISED_10baseT_Half)\r\nval |= ADVERTISE_10HALF;\r\nif (advert & ADVERTISED_10baseT_Full)\r\nval |= ADVERTISE_10FULL;\r\nif (advert & ADVERTISED_100baseT_Half)\r\nval |= ADVERTISE_100HALF;\r\nif (advert & ADVERTISED_100baseT_Full)\r\nval |= ADVERTISE_100FULL;\r\nif (advert & ADVERTISED_Pause)\r\nval |= ADVERTISE_PAUSE_CAP;\r\nif (advert & ADVERTISED_Asym_Pause)\r\nval |= ADVERTISE_PAUSE_ASYM;\r\nreturn t3_mdio_write(phy, MDIO_DEVAD_NONE, MII_ADVERTISE, val);\r\n}\r\nint t3_phy_advertise_fiber(struct cphy *phy, unsigned int advert)\r\n{\r\nunsigned int val = 0;\r\nif (advert & ADVERTISED_1000baseT_Half)\r\nval |= ADVERTISE_1000XHALF;\r\nif (advert & ADVERTISED_1000baseT_Full)\r\nval |= ADVERTISE_1000XFULL;\r\nif (advert & ADVERTISED_Pause)\r\nval |= ADVERTISE_1000XPAUSE;\r\nif (advert & ADVERTISED_Asym_Pause)\r\nval |= ADVERTISE_1000XPSE_ASYM;\r\nreturn t3_mdio_write(phy, MDIO_DEVAD_NONE, MII_ADVERTISE, val);\r\n}\r\nint t3_set_phy_speed_duplex(struct cphy *phy, int speed, int duplex)\r\n{\r\nint err;\r\nunsigned int ctl;\r\nerr = t3_mdio_read(phy, MDIO_DEVAD_NONE, MII_BMCR, &ctl);\r\nif (err)\r\nreturn err;\r\nif (speed >= 0) {\r\nctl &= ~(BMCR_SPEED100 | BMCR_SPEED1000 | BMCR_ANENABLE);\r\nif (speed == SPEED_100)\r\nctl |= BMCR_SPEED100;\r\nelse if (speed == SPEED_1000)\r\nctl |= BMCR_SPEED1000;\r\n}\r\nif (duplex >= 0) {\r\nctl &= ~(BMCR_FULLDPLX | BMCR_ANENABLE);\r\nif (duplex == DUPLEX_FULL)\r\nctl |= BMCR_FULLDPLX;\r\n}\r\nif (ctl & BMCR_SPEED1000)\r\nctl |= BMCR_ANENABLE;\r\nreturn t3_mdio_write(phy, MDIO_DEVAD_NONE, MII_BMCR, ctl);\r\n}\r\nint t3_phy_lasi_intr_enable(struct cphy *phy)\r\n{\r\nreturn t3_mdio_write(phy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_CTRL,\r\nMDIO_PMA_LASI_LSALARM);\r\n}\r\nint t3_phy_lasi_intr_disable(struct cphy *phy)\r\n{\r\nreturn t3_mdio_write(phy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_CTRL, 0);\r\n}\r\nint t3_phy_lasi_intr_clear(struct cphy *phy)\r\n{\r\nu32 val;\r\nreturn t3_mdio_read(phy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_STAT, &val);\r\n}\r\nint t3_phy_lasi_intr_handler(struct cphy *phy)\r\n{\r\nunsigned int status;\r\nint err = t3_mdio_read(phy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_STAT,\r\n&status);\r\nif (err)\r\nreturn err;\r\nreturn (status & MDIO_PMA_LASI_LSALARM) ? cphy_cause_link_change : 0;\r\n}\r\nconst struct adapter_info *t3_get_adapter_info(unsigned int id)\r\n{\r\nreturn id < ARRAY_SIZE(t3_adap_info) ? &t3_adap_info[id] : NULL;\r\n}\r\nint t3_seeprom_read(struct adapter *adapter, u32 addr, __le32 *data)\r\n{\r\nu16 val;\r\nint attempts = EEPROM_MAX_POLL;\r\nu32 v;\r\nunsigned int base = adapter->params.pci.vpd_cap_addr;\r\nif ((addr >= EEPROMSIZE && addr != EEPROM_STAT_ADDR) || (addr & 3))\r\nreturn -EINVAL;\r\npci_write_config_word(adapter->pdev, base + PCI_VPD_ADDR, addr);\r\ndo {\r\nudelay(10);\r\npci_read_config_word(adapter->pdev, base + PCI_VPD_ADDR, &val);\r\n} while (!(val & PCI_VPD_ADDR_F) && --attempts);\r\nif (!(val & PCI_VPD_ADDR_F)) {\r\nCH_ERR(adapter, "reading EEPROM address 0x%x failed\n", addr);\r\nreturn -EIO;\r\n}\r\npci_read_config_dword(adapter->pdev, base + PCI_VPD_DATA, &v);\r\n*data = cpu_to_le32(v);\r\nreturn 0;\r\n}\r\nint t3_seeprom_write(struct adapter *adapter, u32 addr, __le32 data)\r\n{\r\nu16 val;\r\nint attempts = EEPROM_MAX_POLL;\r\nunsigned int base = adapter->params.pci.vpd_cap_addr;\r\nif ((addr >= EEPROMSIZE && addr != EEPROM_STAT_ADDR) || (addr & 3))\r\nreturn -EINVAL;\r\npci_write_config_dword(adapter->pdev, base + PCI_VPD_DATA,\r\nle32_to_cpu(data));\r\npci_write_config_word(adapter->pdev,base + PCI_VPD_ADDR,\r\naddr | PCI_VPD_ADDR_F);\r\ndo {\r\nmsleep(1);\r\npci_read_config_word(adapter->pdev, base + PCI_VPD_ADDR, &val);\r\n} while ((val & PCI_VPD_ADDR_F) && --attempts);\r\nif (val & PCI_VPD_ADDR_F) {\r\nCH_ERR(adapter, "write to EEPROM address 0x%x failed\n", addr);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint t3_seeprom_wp(struct adapter *adapter, int enable)\r\n{\r\nreturn t3_seeprom_write(adapter, EEPROM_STAT_ADDR, enable ? 0xc : 0);\r\n}\r\nstatic int get_vpd_params(struct adapter *adapter, struct vpd_params *p)\r\n{\r\nint i, addr, ret;\r\nstruct t3_vpd vpd;\r\nret = t3_seeprom_read(adapter, VPD_BASE, (__le32 *)&vpd);\r\nif (ret)\r\nreturn ret;\r\naddr = vpd.id_tag == 0x82 ? VPD_BASE : 0;\r\nfor (i = 0; i < sizeof(vpd); i += 4) {\r\nret = t3_seeprom_read(adapter, addr + i,\r\n(__le32 *)((u8 *)&vpd + i));\r\nif (ret)\r\nreturn ret;\r\n}\r\np->cclk = simple_strtoul(vpd.cclk_data, NULL, 10);\r\np->mclk = simple_strtoul(vpd.mclk_data, NULL, 10);\r\np->uclk = simple_strtoul(vpd.uclk_data, NULL, 10);\r\np->mdc = simple_strtoul(vpd.mdc_data, NULL, 10);\r\np->mem_timing = simple_strtoul(vpd.mt_data, NULL, 10);\r\nmemcpy(p->sn, vpd.sn_data, SERNUM_LEN);\r\nif (adapter->params.rev == 0 && !vpd.port0_data[0]) {\r\np->port_type[0] = uses_xaui(adapter) ? 1 : 2;\r\np->port_type[1] = uses_xaui(adapter) ? 6 : 2;\r\n} else {\r\np->port_type[0] = hex_to_bin(vpd.port0_data[0]);\r\np->port_type[1] = hex_to_bin(vpd.port1_data[0]);\r\np->xauicfg[0] = simple_strtoul(vpd.xaui0cfg_data, NULL, 16);\r\np->xauicfg[1] = simple_strtoul(vpd.xaui1cfg_data, NULL, 16);\r\n}\r\nfor (i = 0; i < 6; i++)\r\np->eth_base[i] = hex_to_bin(vpd.na_data[2 * i]) * 16 +\r\nhex_to_bin(vpd.na_data[2 * i + 1]);\r\nreturn 0;\r\n}\r\nstatic int sf1_read(struct adapter *adapter, unsigned int byte_cnt, int cont,\r\nu32 *valp)\r\n{\r\nint ret;\r\nif (!byte_cnt || byte_cnt > 4)\r\nreturn -EINVAL;\r\nif (t3_read_reg(adapter, A_SF_OP) & F_BUSY)\r\nreturn -EBUSY;\r\nt3_write_reg(adapter, A_SF_OP, V_CONT(cont) | V_BYTECNT(byte_cnt - 1));\r\nret = t3_wait_op_done(adapter, A_SF_OP, F_BUSY, 0, SF_ATTEMPTS, 10);\r\nif (!ret)\r\n*valp = t3_read_reg(adapter, A_SF_DATA);\r\nreturn ret;\r\n}\r\nstatic int sf1_write(struct adapter *adapter, unsigned int byte_cnt, int cont,\r\nu32 val)\r\n{\r\nif (!byte_cnt || byte_cnt > 4)\r\nreturn -EINVAL;\r\nif (t3_read_reg(adapter, A_SF_OP) & F_BUSY)\r\nreturn -EBUSY;\r\nt3_write_reg(adapter, A_SF_DATA, val);\r\nt3_write_reg(adapter, A_SF_OP,\r\nV_CONT(cont) | V_BYTECNT(byte_cnt - 1) | V_OP(1));\r\nreturn t3_wait_op_done(adapter, A_SF_OP, F_BUSY, 0, SF_ATTEMPTS, 10);\r\n}\r\nstatic int flash_wait_op(struct adapter *adapter, int attempts, int delay)\r\n{\r\nint ret;\r\nu32 status;\r\nwhile (1) {\r\nif ((ret = sf1_write(adapter, 1, 1, SF_RD_STATUS)) != 0 ||\r\n(ret = sf1_read(adapter, 1, 0, &status)) != 0)\r\nreturn ret;\r\nif (!(status & 1))\r\nreturn 0;\r\nif (--attempts == 0)\r\nreturn -EAGAIN;\r\nif (delay)\r\nmsleep(delay);\r\n}\r\n}\r\nstatic int t3_read_flash(struct adapter *adapter, unsigned int addr,\r\nunsigned int nwords, u32 *data, int byte_oriented)\r\n{\r\nint ret;\r\nif (addr + nwords * sizeof(u32) > SF_SIZE || (addr & 3))\r\nreturn -EINVAL;\r\naddr = swab32(addr) | SF_RD_DATA_FAST;\r\nif ((ret = sf1_write(adapter, 4, 1, addr)) != 0 ||\r\n(ret = sf1_read(adapter, 1, 1, data)) != 0)\r\nreturn ret;\r\nfor (; nwords; nwords--, data++) {\r\nret = sf1_read(adapter, 4, nwords > 1, data);\r\nif (ret)\r\nreturn ret;\r\nif (byte_oriented)\r\n*data = htonl(*data);\r\n}\r\nreturn 0;\r\n}\r\nstatic int t3_write_flash(struct adapter *adapter, unsigned int addr,\r\nunsigned int n, const u8 *data)\r\n{\r\nint ret;\r\nu32 buf[64];\r\nunsigned int i, c, left, val, offset = addr & 0xff;\r\nif (addr + n > SF_SIZE || offset + n > 256)\r\nreturn -EINVAL;\r\nval = swab32(addr) | SF_PROG_PAGE;\r\nif ((ret = sf1_write(adapter, 1, 0, SF_WR_ENABLE)) != 0 ||\r\n(ret = sf1_write(adapter, 4, 1, val)) != 0)\r\nreturn ret;\r\nfor (left = n; left; left -= c) {\r\nc = min(left, 4U);\r\nfor (val = 0, i = 0; i < c; ++i)\r\nval = (val << 8) + *data++;\r\nret = sf1_write(adapter, c, c != left, val);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif ((ret = flash_wait_op(adapter, 5, 1)) != 0)\r\nreturn ret;\r\nret = t3_read_flash(adapter, addr & ~0xff, ARRAY_SIZE(buf), buf, 1);\r\nif (ret)\r\nreturn ret;\r\nif (memcmp(data - n, (u8 *) buf + offset, n))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nint t3_get_tp_version(struct adapter *adapter, u32 *vers)\r\n{\r\nint ret;\r\nt3_write_reg(adapter, A_TP_EMBED_OP_FIELD0, 0);\r\nret = t3_wait_op_done(adapter, A_TP_EMBED_OP_FIELD0,\r\n1, 1, 5, 1);\r\nif (ret)\r\nreturn ret;\r\n*vers = t3_read_reg(adapter, A_TP_EMBED_OP_FIELD1);\r\nreturn 0;\r\n}\r\nint t3_check_tpsram_version(struct adapter *adapter)\r\n{\r\nint ret;\r\nu32 vers;\r\nunsigned int major, minor;\r\nif (adapter->params.rev == T3_REV_A)\r\nreturn 0;\r\nret = t3_get_tp_version(adapter, &vers);\r\nif (ret)\r\nreturn ret;\r\nmajor = G_TP_VERSION_MAJOR(vers);\r\nminor = G_TP_VERSION_MINOR(vers);\r\nif (major == TP_VERSION_MAJOR && minor == TP_VERSION_MINOR)\r\nreturn 0;\r\nelse {\r\nCH_ERR(adapter, "found wrong TP version (%u.%u), "\r\n"driver compiled for version %d.%d\n", major, minor,\r\nTP_VERSION_MAJOR, TP_VERSION_MINOR);\r\n}\r\nreturn -EINVAL;\r\n}\r\nint t3_check_tpsram(struct adapter *adapter, const u8 *tp_sram,\r\nunsigned int size)\r\n{\r\nu32 csum;\r\nunsigned int i;\r\nconst __be32 *p = (const __be32 *)tp_sram;\r\nfor (csum = 0, i = 0; i < size / sizeof(csum); i++)\r\ncsum += ntohl(p[i]);\r\nif (csum != 0xffffffff) {\r\nCH_ERR(adapter, "corrupted protocol SRAM image, checksum %u\n",\r\ncsum);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint t3_get_fw_version(struct adapter *adapter, u32 *vers)\r\n{\r\nreturn t3_read_flash(adapter, FW_VERS_ADDR, 1, vers, 0);\r\n}\r\nint t3_check_fw_version(struct adapter *adapter)\r\n{\r\nint ret;\r\nu32 vers;\r\nunsigned int type, major, minor;\r\nret = t3_get_fw_version(adapter, &vers);\r\nif (ret)\r\nreturn ret;\r\ntype = G_FW_VERSION_TYPE(vers);\r\nmajor = G_FW_VERSION_MAJOR(vers);\r\nminor = G_FW_VERSION_MINOR(vers);\r\nif (type == FW_VERSION_T3 && major == FW_VERSION_MAJOR &&\r\nminor == FW_VERSION_MINOR)\r\nreturn 0;\r\nelse if (major != FW_VERSION_MAJOR || minor < FW_VERSION_MINOR)\r\nCH_WARN(adapter, "found old FW minor version(%u.%u), "\r\n"driver compiled for version %u.%u\n", major, minor,\r\nFW_VERSION_MAJOR, FW_VERSION_MINOR);\r\nelse {\r\nCH_WARN(adapter, "found newer FW version(%u.%u), "\r\n"driver compiled for version %u.%u\n", major, minor,\r\nFW_VERSION_MAJOR, FW_VERSION_MINOR);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int t3_flash_erase_sectors(struct adapter *adapter, int start, int end)\r\n{\r\nwhile (start <= end) {\r\nint ret;\r\nif ((ret = sf1_write(adapter, 1, 0, SF_WR_ENABLE)) != 0 ||\r\n(ret = sf1_write(adapter, 4, 0,\r\nSF_ERASE_SECTOR | (start << 8))) != 0 ||\r\n(ret = flash_wait_op(adapter, 5, 500)) != 0)\r\nreturn ret;\r\nstart++;\r\n}\r\nreturn 0;\r\n}\r\nint t3_load_fw(struct adapter *adapter, const u8 *fw_data, unsigned int size)\r\n{\r\nu32 csum;\r\nunsigned int i;\r\nconst __be32 *p = (const __be32 *)fw_data;\r\nint ret, addr, fw_sector = FW_FLASH_BOOT_ADDR >> 16;\r\nif ((size & 3) || size < FW_MIN_SIZE)\r\nreturn -EINVAL;\r\nif (size > FW_VERS_ADDR + 8 - FW_FLASH_BOOT_ADDR)\r\nreturn -EFBIG;\r\nfor (csum = 0, i = 0; i < size / sizeof(csum); i++)\r\ncsum += ntohl(p[i]);\r\nif (csum != 0xffffffff) {\r\nCH_ERR(adapter, "corrupted firmware image, checksum %u\n",\r\ncsum);\r\nreturn -EINVAL;\r\n}\r\nret = t3_flash_erase_sectors(adapter, fw_sector, fw_sector);\r\nif (ret)\r\ngoto out;\r\nsize -= 8;\r\nfor (addr = FW_FLASH_BOOT_ADDR; size;) {\r\nunsigned int chunk_size = min(size, 256U);\r\nret = t3_write_flash(adapter, addr, chunk_size, fw_data);\r\nif (ret)\r\ngoto out;\r\naddr += chunk_size;\r\nfw_data += chunk_size;\r\nsize -= chunk_size;\r\n}\r\nret = t3_write_flash(adapter, FW_VERS_ADDR, 4, fw_data);\r\nout:\r\nif (ret)\r\nCH_ERR(adapter, "firmware download failed, error %d\n", ret);\r\nreturn ret;\r\n}\r\nint t3_cim_ctl_blk_read(struct adapter *adap, unsigned int addr,\r\nunsigned int n, unsigned int *valp)\r\n{\r\nint ret = 0;\r\nif (t3_read_reg(adap, A_CIM_HOST_ACC_CTRL) & F_HOSTBUSY)\r\nreturn -EBUSY;\r\nfor ( ; !ret && n--; addr += 4) {\r\nt3_write_reg(adap, A_CIM_HOST_ACC_CTRL, CIM_CTL_BASE + addr);\r\nret = t3_wait_op_done(adap, A_CIM_HOST_ACC_CTRL, F_HOSTBUSY,\r\n0, 5, 2);\r\nif (!ret)\r\n*valp++ = t3_read_reg(adap, A_CIM_HOST_ACC_DATA);\r\n}\r\nreturn ret;\r\n}\r\nstatic void t3_gate_rx_traffic(struct cmac *mac, u32 *rx_cfg,\r\nu32 *rx_hash_high, u32 *rx_hash_low)\r\n{\r\nt3_mac_disable_exact_filters(mac);\r\n*rx_cfg = t3_read_reg(mac->adapter, A_XGM_RX_CFG);\r\nt3_set_reg_field(mac->adapter, A_XGM_RX_CFG,\r\nF_ENHASHMCAST | F_DISBCAST | F_COPYALLFRAMES,\r\nF_DISBCAST);\r\n*rx_hash_high = t3_read_reg(mac->adapter, A_XGM_RX_HASH_HIGH);\r\nt3_write_reg(mac->adapter, A_XGM_RX_HASH_HIGH, 0);\r\n*rx_hash_low = t3_read_reg(mac->adapter, A_XGM_RX_HASH_LOW);\r\nt3_write_reg(mac->adapter, A_XGM_RX_HASH_LOW, 0);\r\nmsleep(1);\r\n}\r\nstatic void t3_open_rx_traffic(struct cmac *mac, u32 rx_cfg,\r\nu32 rx_hash_high, u32 rx_hash_low)\r\n{\r\nt3_mac_enable_exact_filters(mac);\r\nt3_set_reg_field(mac->adapter, A_XGM_RX_CFG,\r\nF_ENHASHMCAST | F_DISBCAST | F_COPYALLFRAMES,\r\nrx_cfg);\r\nt3_write_reg(mac->adapter, A_XGM_RX_HASH_HIGH, rx_hash_high);\r\nt3_write_reg(mac->adapter, A_XGM_RX_HASH_LOW, rx_hash_low);\r\n}\r\nvoid t3_link_changed(struct adapter *adapter, int port_id)\r\n{\r\nint link_ok, speed, duplex, fc;\r\nstruct port_info *pi = adap2pinfo(adapter, port_id);\r\nstruct cphy *phy = &pi->phy;\r\nstruct cmac *mac = &pi->mac;\r\nstruct link_config *lc = &pi->link_config;\r\nphy->ops->get_link_status(phy, &link_ok, &speed, &duplex, &fc);\r\nif (!lc->link_ok && link_ok) {\r\nu32 rx_cfg, rx_hash_high, rx_hash_low;\r\nu32 status;\r\nt3_xgm_intr_enable(adapter, port_id);\r\nt3_gate_rx_traffic(mac, &rx_cfg, &rx_hash_high, &rx_hash_low);\r\nt3_write_reg(adapter, A_XGM_RX_CTRL + mac->offset, 0);\r\nt3_mac_enable(mac, MAC_DIRECTION_RX);\r\nstatus = t3_read_reg(adapter, A_XGM_INT_STATUS + mac->offset);\r\nif (status & F_LINKFAULTCHANGE) {\r\nmac->stats.link_faults++;\r\npi->link_fault = 1;\r\n}\r\nt3_open_rx_traffic(mac, rx_cfg, rx_hash_high, rx_hash_low);\r\n}\r\nif (lc->requested_fc & PAUSE_AUTONEG)\r\nfc &= lc->requested_fc;\r\nelse\r\nfc = lc->requested_fc & (PAUSE_RX | PAUSE_TX);\r\nif (link_ok == lc->link_ok && speed == lc->speed &&\r\nduplex == lc->duplex && fc == lc->fc)\r\nreturn;\r\nif (link_ok != lc->link_ok && adapter->params.rev > 0 &&\r\nuses_xaui(adapter)) {\r\nif (link_ok)\r\nt3b_pcs_reset(mac);\r\nt3_write_reg(adapter, A_XGM_XAUI_ACT_CTRL + mac->offset,\r\nlink_ok ? F_TXACTENABLE | F_RXEN : 0);\r\n}\r\nlc->link_ok = link_ok;\r\nlc->speed = speed < 0 ? SPEED_INVALID : speed;\r\nlc->duplex = duplex < 0 ? DUPLEX_INVALID : duplex;\r\nif (link_ok && speed >= 0 && lc->autoneg == AUTONEG_ENABLE) {\r\nt3_mac_set_speed_duplex_fc(mac, speed, duplex, fc);\r\nlc->fc = fc;\r\n}\r\nt3_os_link_changed(adapter, port_id, link_ok && !pi->link_fault,\r\nspeed, duplex, fc);\r\n}\r\nvoid t3_link_fault(struct adapter *adapter, int port_id)\r\n{\r\nstruct port_info *pi = adap2pinfo(adapter, port_id);\r\nstruct cmac *mac = &pi->mac;\r\nstruct cphy *phy = &pi->phy;\r\nstruct link_config *lc = &pi->link_config;\r\nint link_ok, speed, duplex, fc, link_fault;\r\nu32 rx_cfg, rx_hash_high, rx_hash_low;\r\nt3_gate_rx_traffic(mac, &rx_cfg, &rx_hash_high, &rx_hash_low);\r\nif (adapter->params.rev > 0 && uses_xaui(adapter))\r\nt3_write_reg(adapter, A_XGM_XAUI_ACT_CTRL + mac->offset, 0);\r\nt3_write_reg(adapter, A_XGM_RX_CTRL + mac->offset, 0);\r\nt3_mac_enable(mac, MAC_DIRECTION_RX);\r\nt3_open_rx_traffic(mac, rx_cfg, rx_hash_high, rx_hash_low);\r\nlink_fault = t3_read_reg(adapter,\r\nA_XGM_INT_STATUS + mac->offset);\r\nlink_fault &= F_LINKFAULTCHANGE;\r\nlink_ok = lc->link_ok;\r\nspeed = lc->speed;\r\nduplex = lc->duplex;\r\nfc = lc->fc;\r\nphy->ops->get_link_status(phy, &link_ok, &speed, &duplex, &fc);\r\nif (link_fault) {\r\nlc->link_ok = 0;\r\nlc->speed = SPEED_INVALID;\r\nlc->duplex = DUPLEX_INVALID;\r\nt3_os_link_fault(adapter, port_id, 0);\r\nif (link_ok)\r\nmac->stats.link_faults++;\r\n} else {\r\nif (link_ok)\r\nt3_write_reg(adapter, A_XGM_XAUI_ACT_CTRL + mac->offset,\r\nF_TXACTENABLE | F_RXEN);\r\npi->link_fault = 0;\r\nlc->link_ok = (unsigned char)link_ok;\r\nlc->speed = speed < 0 ? SPEED_INVALID : speed;\r\nlc->duplex = duplex < 0 ? DUPLEX_INVALID : duplex;\r\nt3_os_link_fault(adapter, port_id, link_ok);\r\n}\r\n}\r\nint t3_link_start(struct cphy *phy, struct cmac *mac, struct link_config *lc)\r\n{\r\nunsigned int fc = lc->requested_fc & (PAUSE_RX | PAUSE_TX);\r\nlc->link_ok = 0;\r\nif (lc->supported & SUPPORTED_Autoneg) {\r\nlc->advertising &= ~(ADVERTISED_Asym_Pause | ADVERTISED_Pause);\r\nif (fc) {\r\nlc->advertising |= ADVERTISED_Asym_Pause;\r\nif (fc & PAUSE_RX)\r\nlc->advertising |= ADVERTISED_Pause;\r\n}\r\nphy->ops->advertise(phy, lc->advertising);\r\nif (lc->autoneg == AUTONEG_DISABLE) {\r\nlc->speed = lc->requested_speed;\r\nlc->duplex = lc->requested_duplex;\r\nlc->fc = (unsigned char)fc;\r\nt3_mac_set_speed_duplex_fc(mac, lc->speed, lc->duplex,\r\nfc);\r\nphy->ops->set_speed_duplex(phy, lc->speed, lc->duplex);\r\n} else\r\nphy->ops->autoneg_enable(phy);\r\n} else {\r\nt3_mac_set_speed_duplex_fc(mac, -1, -1, fc);\r\nlc->fc = (unsigned char)fc;\r\nphy->ops->reset(phy, 0);\r\n}\r\nreturn 0;\r\n}\r\nvoid t3_set_vlan_accel(struct adapter *adapter, unsigned int ports, int on)\r\n{\r\nt3_set_reg_field(adapter, A_TP_OUT_CONFIG,\r\nports << S_VLANEXTRACTIONENABLE,\r\non ? (ports << S_VLANEXTRACTIONENABLE) : 0);\r\n}\r\nstatic int t3_handle_intr_status(struct adapter *adapter, unsigned int reg,\r\nunsigned int mask,\r\nconst struct intr_info *acts,\r\nunsigned long *stats)\r\n{\r\nint fatal = 0;\r\nunsigned int status = t3_read_reg(adapter, reg) & mask;\r\nfor (; acts->mask; ++acts) {\r\nif (!(status & acts->mask))\r\ncontinue;\r\nif (acts->fatal) {\r\nfatal++;\r\nCH_ALERT(adapter, "%s (0x%x)\n",\r\nacts->msg, status & acts->mask);\r\nstatus &= ~acts->mask;\r\n} else if (acts->msg)\r\nCH_WARN(adapter, "%s (0x%x)\n",\r\nacts->msg, status & acts->mask);\r\nif (acts->stat_idx >= 0)\r\nstats[acts->stat_idx]++;\r\n}\r\nif (status)\r\nt3_write_reg(adapter, reg, status);\r\nreturn fatal;\r\n}\r\nstatic void pci_intr_handler(struct adapter *adapter)\r\n{\r\nstatic const struct intr_info pcix1_intr_info[] = {\r\n{F_MSTDETPARERR, "PCI master detected parity error", -1, 1},\r\n{F_SIGTARABT, "PCI signaled target abort", -1, 1},\r\n{F_RCVTARABT, "PCI received target abort", -1, 1},\r\n{F_RCVMSTABT, "PCI received master abort", -1, 1},\r\n{F_SIGSYSERR, "PCI signaled system error", -1, 1},\r\n{F_DETPARERR, "PCI detected parity error", -1, 1},\r\n{F_SPLCMPDIS, "PCI split completion discarded", -1, 1},\r\n{F_UNXSPLCMP, "PCI unexpected split completion error", -1, 1},\r\n{F_RCVSPLCMPERR, "PCI received split completion error", -1,\r\n1},\r\n{F_DETCORECCERR, "PCI correctable ECC error",\r\nSTAT_PCI_CORR_ECC, 0},\r\n{F_DETUNCECCERR, "PCI uncorrectable ECC error", -1, 1},\r\n{F_PIOPARERR, "PCI PIO FIFO parity error", -1, 1},\r\n{V_WFPARERR(M_WFPARERR), "PCI write FIFO parity error", -1,\r\n1},\r\n{V_RFPARERR(M_RFPARERR), "PCI read FIFO parity error", -1,\r\n1},\r\n{V_CFPARERR(M_CFPARERR), "PCI command FIFO parity error", -1,\r\n1},\r\n{V_MSIXPARERR(M_MSIXPARERR), "PCI MSI-X table/PBA parity "\r\n"error", -1, 1},\r\n{0}\r\n};\r\nif (t3_handle_intr_status(adapter, A_PCIX_INT_CAUSE, PCIX_INTR_MASK,\r\npcix1_intr_info, adapter->irq_stats))\r\nt3_fatal_err(adapter);\r\n}\r\nstatic void pcie_intr_handler(struct adapter *adapter)\r\n{\r\nstatic const struct intr_info pcie_intr_info[] = {\r\n{F_PEXERR, "PCI PEX error", -1, 1},\r\n{F_UNXSPLCPLERRR,\r\n"PCI unexpected split completion DMA read error", -1, 1},\r\n{F_UNXSPLCPLERRC,\r\n"PCI unexpected split completion DMA command error", -1, 1},\r\n{F_PCIE_PIOPARERR, "PCI PIO FIFO parity error", -1, 1},\r\n{F_PCIE_WFPARERR, "PCI write FIFO parity error", -1, 1},\r\n{F_PCIE_RFPARERR, "PCI read FIFO parity error", -1, 1},\r\n{F_PCIE_CFPARERR, "PCI command FIFO parity error", -1, 1},\r\n{V_PCIE_MSIXPARERR(M_PCIE_MSIXPARERR),\r\n"PCI MSI-X table/PBA parity error", -1, 1},\r\n{F_RETRYBUFPARERR, "PCI retry buffer parity error", -1, 1},\r\n{F_RETRYLUTPARERR, "PCI retry LUT parity error", -1, 1},\r\n{F_RXPARERR, "PCI Rx parity error", -1, 1},\r\n{F_TXPARERR, "PCI Tx parity error", -1, 1},\r\n{V_BISTERR(M_BISTERR), "PCI BIST error", -1, 1},\r\n{0}\r\n};\r\nif (t3_read_reg(adapter, A_PCIE_INT_CAUSE) & F_PEXERR)\r\nCH_ALERT(adapter, "PEX error code 0x%x\n",\r\nt3_read_reg(adapter, A_PCIE_PEX_ERR));\r\nif (t3_handle_intr_status(adapter, A_PCIE_INT_CAUSE, PCIE_INTR_MASK,\r\npcie_intr_info, adapter->irq_stats))\r\nt3_fatal_err(adapter);\r\n}\r\nstatic void tp_intr_handler(struct adapter *adapter)\r\n{\r\nstatic const struct intr_info tp_intr_info[] = {\r\n{0xffffff, "TP parity error", -1, 1},\r\n{0x1000000, "TP out of Rx pages", -1, 1},\r\n{0x2000000, "TP out of Tx pages", -1, 1},\r\n{0}\r\n};\r\nstatic const struct intr_info tp_intr_info_t3c[] = {\r\n{0x1fffffff, "TP parity error", -1, 1},\r\n{F_FLMRXFLSTEMPTY, "TP out of Rx pages", -1, 1},\r\n{F_FLMTXFLSTEMPTY, "TP out of Tx pages", -1, 1},\r\n{0}\r\n};\r\nif (t3_handle_intr_status(adapter, A_TP_INT_CAUSE, 0xffffffff,\r\nadapter->params.rev < T3_REV_C ?\r\ntp_intr_info : tp_intr_info_t3c, NULL))\r\nt3_fatal_err(adapter);\r\n}\r\nstatic void cim_intr_handler(struct adapter *adapter)\r\n{\r\nstatic const struct intr_info cim_intr_info[] = {\r\n{F_RSVDSPACEINT, "CIM reserved space write", -1, 1},\r\n{F_SDRAMRANGEINT, "CIM SDRAM address out of range", -1, 1},\r\n{F_FLASHRANGEINT, "CIM flash address out of range", -1, 1},\r\n{F_BLKWRBOOTINT, "CIM block write to boot space", -1, 1},\r\n{F_WRBLKFLASHINT, "CIM write to cached flash space", -1, 1},\r\n{F_SGLWRFLASHINT, "CIM single write to flash space", -1, 1},\r\n{F_BLKRDFLASHINT, "CIM block read from flash space", -1, 1},\r\n{F_BLKWRFLASHINT, "CIM block write to flash space", -1, 1},\r\n{F_BLKRDCTLINT, "CIM block read from CTL space", -1, 1},\r\n{F_BLKWRCTLINT, "CIM block write to CTL space", -1, 1},\r\n{F_BLKRDPLINT, "CIM block read from PL space", -1, 1},\r\n{F_BLKWRPLINT, "CIM block write to PL space", -1, 1},\r\n{F_DRAMPARERR, "CIM DRAM parity error", -1, 1},\r\n{F_ICACHEPARERR, "CIM icache parity error", -1, 1},\r\n{F_DCACHEPARERR, "CIM dcache parity error", -1, 1},\r\n{F_OBQSGEPARERR, "CIM OBQ SGE parity error", -1, 1},\r\n{F_OBQULPHIPARERR, "CIM OBQ ULPHI parity error", -1, 1},\r\n{F_OBQULPLOPARERR, "CIM OBQ ULPLO parity error", -1, 1},\r\n{F_IBQSGELOPARERR, "CIM IBQ SGELO parity error", -1, 1},\r\n{F_IBQSGEHIPARERR, "CIM IBQ SGEHI parity error", -1, 1},\r\n{F_IBQULPPARERR, "CIM IBQ ULP parity error", -1, 1},\r\n{F_IBQTPPARERR, "CIM IBQ TP parity error", -1, 1},\r\n{F_ITAGPARERR, "CIM itag parity error", -1, 1},\r\n{F_DTAGPARERR, "CIM dtag parity error", -1, 1},\r\n{0}\r\n};\r\nif (t3_handle_intr_status(adapter, A_CIM_HOST_INT_CAUSE, 0xffffffff,\r\ncim_intr_info, NULL))\r\nt3_fatal_err(adapter);\r\n}\r\nstatic void ulprx_intr_handler(struct adapter *adapter)\r\n{\r\nstatic const struct intr_info ulprx_intr_info[] = {\r\n{F_PARERRDATA, "ULP RX data parity error", -1, 1},\r\n{F_PARERRPCMD, "ULP RX command parity error", -1, 1},\r\n{F_ARBPF1PERR, "ULP RX ArbPF1 parity error", -1, 1},\r\n{F_ARBPF0PERR, "ULP RX ArbPF0 parity error", -1, 1},\r\n{F_ARBFPERR, "ULP RX ArbF parity error", -1, 1},\r\n{F_PCMDMUXPERR, "ULP RX PCMDMUX parity error", -1, 1},\r\n{F_DATASELFRAMEERR1, "ULP RX frame error", -1, 1},\r\n{F_DATASELFRAMEERR0, "ULP RX frame error", -1, 1},\r\n{0}\r\n};\r\nif (t3_handle_intr_status(adapter, A_ULPRX_INT_CAUSE, 0xffffffff,\r\nulprx_intr_info, NULL))\r\nt3_fatal_err(adapter);\r\n}\r\nstatic void ulptx_intr_handler(struct adapter *adapter)\r\n{\r\nstatic const struct intr_info ulptx_intr_info[] = {\r\n{F_PBL_BOUND_ERR_CH0, "ULP TX channel 0 PBL out of bounds",\r\nSTAT_ULP_CH0_PBL_OOB, 0},\r\n{F_PBL_BOUND_ERR_CH1, "ULP TX channel 1 PBL out of bounds",\r\nSTAT_ULP_CH1_PBL_OOB, 0},\r\n{0xfc, "ULP TX parity error", -1, 1},\r\n{0}\r\n};\r\nif (t3_handle_intr_status(adapter, A_ULPTX_INT_CAUSE, 0xffffffff,\r\nulptx_intr_info, adapter->irq_stats))\r\nt3_fatal_err(adapter);\r\n}\r\nstatic void pmtx_intr_handler(struct adapter *adapter)\r\n{\r\nstatic const struct intr_info pmtx_intr_info[] = {\r\n{F_ZERO_C_CMD_ERROR, "PMTX 0-length pcmd", -1, 1},\r\n{ICSPI_FRM_ERR, "PMTX ispi framing error", -1, 1},\r\n{OESPI_FRM_ERR, "PMTX ospi framing error", -1, 1},\r\n{V_ICSPI_PAR_ERROR(M_ICSPI_PAR_ERROR),\r\n"PMTX ispi parity error", -1, 1},\r\n{V_OESPI_PAR_ERROR(M_OESPI_PAR_ERROR),\r\n"PMTX ospi parity error", -1, 1},\r\n{0}\r\n};\r\nif (t3_handle_intr_status(adapter, A_PM1_TX_INT_CAUSE, 0xffffffff,\r\npmtx_intr_info, NULL))\r\nt3_fatal_err(adapter);\r\n}\r\nstatic void pmrx_intr_handler(struct adapter *adapter)\r\n{\r\nstatic const struct intr_info pmrx_intr_info[] = {\r\n{F_ZERO_E_CMD_ERROR, "PMRX 0-length pcmd", -1, 1},\r\n{IESPI_FRM_ERR, "PMRX ispi framing error", -1, 1},\r\n{OCSPI_FRM_ERR, "PMRX ospi framing error", -1, 1},\r\n{V_IESPI_PAR_ERROR(M_IESPI_PAR_ERROR),\r\n"PMRX ispi parity error", -1, 1},\r\n{V_OCSPI_PAR_ERROR(M_OCSPI_PAR_ERROR),\r\n"PMRX ospi parity error", -1, 1},\r\n{0}\r\n};\r\nif (t3_handle_intr_status(adapter, A_PM1_RX_INT_CAUSE, 0xffffffff,\r\npmrx_intr_info, NULL))\r\nt3_fatal_err(adapter);\r\n}\r\nstatic void cplsw_intr_handler(struct adapter *adapter)\r\n{\r\nstatic const struct intr_info cplsw_intr_info[] = {\r\n{F_CIM_OP_MAP_PERR, "CPL switch CIM parity error", -1, 1},\r\n{F_CIM_OVFL_ERROR, "CPL switch CIM overflow", -1, 1},\r\n{F_TP_FRAMING_ERROR, "CPL switch TP framing error", -1, 1},\r\n{F_SGE_FRAMING_ERROR, "CPL switch SGE framing error", -1, 1},\r\n{F_CIM_FRAMING_ERROR, "CPL switch CIM framing error", -1, 1},\r\n{F_ZERO_SWITCH_ERROR, "CPL switch no-switch error", -1, 1},\r\n{0}\r\n};\r\nif (t3_handle_intr_status(adapter, A_CPL_INTR_CAUSE, 0xffffffff,\r\ncplsw_intr_info, NULL))\r\nt3_fatal_err(adapter);\r\n}\r\nstatic void mps_intr_handler(struct adapter *adapter)\r\n{\r\nstatic const struct intr_info mps_intr_info[] = {\r\n{0x1ff, "MPS parity error", -1, 1},\r\n{0}\r\n};\r\nif (t3_handle_intr_status(adapter, A_MPS_INT_CAUSE, 0xffffffff,\r\nmps_intr_info, NULL))\r\nt3_fatal_err(adapter);\r\n}\r\nstatic void mc7_intr_handler(struct mc7 *mc7)\r\n{\r\nstruct adapter *adapter = mc7->adapter;\r\nu32 cause = t3_read_reg(adapter, mc7->offset + A_MC7_INT_CAUSE);\r\nif (cause & F_CE) {\r\nmc7->stats.corr_err++;\r\nCH_WARN(adapter, "%s MC7 correctable error at addr 0x%x, "\r\n"data 0x%x 0x%x 0x%x\n", mc7->name,\r\nt3_read_reg(adapter, mc7->offset + A_MC7_CE_ADDR),\r\nt3_read_reg(adapter, mc7->offset + A_MC7_CE_DATA0),\r\nt3_read_reg(adapter, mc7->offset + A_MC7_CE_DATA1),\r\nt3_read_reg(adapter, mc7->offset + A_MC7_CE_DATA2));\r\n}\r\nif (cause & F_UE) {\r\nmc7->stats.uncorr_err++;\r\nCH_ALERT(adapter, "%s MC7 uncorrectable error at addr 0x%x, "\r\n"data 0x%x 0x%x 0x%x\n", mc7->name,\r\nt3_read_reg(adapter, mc7->offset + A_MC7_UE_ADDR),\r\nt3_read_reg(adapter, mc7->offset + A_MC7_UE_DATA0),\r\nt3_read_reg(adapter, mc7->offset + A_MC7_UE_DATA1),\r\nt3_read_reg(adapter, mc7->offset + A_MC7_UE_DATA2));\r\n}\r\nif (G_PE(cause)) {\r\nmc7->stats.parity_err++;\r\nCH_ALERT(adapter, "%s MC7 parity error 0x%x\n",\r\nmc7->name, G_PE(cause));\r\n}\r\nif (cause & F_AE) {\r\nu32 addr = 0;\r\nif (adapter->params.rev > 0)\r\naddr = t3_read_reg(adapter,\r\nmc7->offset + A_MC7_ERR_ADDR);\r\nmc7->stats.addr_err++;\r\nCH_ALERT(adapter, "%s MC7 address error: 0x%x\n",\r\nmc7->name, addr);\r\n}\r\nif (cause & MC7_INTR_FATAL)\r\nt3_fatal_err(adapter);\r\nt3_write_reg(adapter, mc7->offset + A_MC7_INT_CAUSE, cause);\r\n}\r\nstatic int mac_intr_handler(struct adapter *adap, unsigned int idx)\r\n{\r\nstruct cmac *mac = &adap2pinfo(adap, idx)->mac;\r\nu32 cause = t3_read_reg(adap, A_XGM_INT_CAUSE + mac->offset) &\r\n~F_RXFIFO_OVERFLOW;\r\nif (cause & V_TXFIFO_PRTY_ERR(M_TXFIFO_PRTY_ERR)) {\r\nmac->stats.tx_fifo_parity_err++;\r\nCH_ALERT(adap, "port%d: MAC TX FIFO parity error\n", idx);\r\n}\r\nif (cause & V_RXFIFO_PRTY_ERR(M_RXFIFO_PRTY_ERR)) {\r\nmac->stats.rx_fifo_parity_err++;\r\nCH_ALERT(adap, "port%d: MAC RX FIFO parity error\n", idx);\r\n}\r\nif (cause & F_TXFIFO_UNDERRUN)\r\nmac->stats.tx_fifo_urun++;\r\nif (cause & F_RXFIFO_OVERFLOW)\r\nmac->stats.rx_fifo_ovfl++;\r\nif (cause & V_SERDES_LOS(M_SERDES_LOS))\r\nmac->stats.serdes_signal_loss++;\r\nif (cause & F_XAUIPCSCTCERR)\r\nmac->stats.xaui_pcs_ctc_err++;\r\nif (cause & F_XAUIPCSALIGNCHANGE)\r\nmac->stats.xaui_pcs_align_change++;\r\nif (cause & F_XGM_INT) {\r\nt3_set_reg_field(adap,\r\nA_XGM_INT_ENABLE + mac->offset,\r\nF_XGM_INT, 0);\r\nmac->stats.link_faults++;\r\nt3_os_link_fault_handler(adap, idx);\r\n}\r\nif (cause & XGM_INTR_FATAL)\r\nt3_fatal_err(adap);\r\nt3_write_reg(adap, A_XGM_INT_CAUSE + mac->offset, cause);\r\nreturn cause != 0;\r\n}\r\nint t3_phy_intr_handler(struct adapter *adapter)\r\n{\r\nu32 i, cause = t3_read_reg(adapter, A_T3DBG_INT_CAUSE);\r\nfor_each_port(adapter, i) {\r\nstruct port_info *p = adap2pinfo(adapter, i);\r\nif (!(p->phy.caps & SUPPORTED_IRQ))\r\ncontinue;\r\nif (cause & (1 << adapter_info(adapter)->gpio_intr[i])) {\r\nint phy_cause = p->phy.ops->intr_handler(&p->phy);\r\nif (phy_cause & cphy_cause_link_change)\r\nt3_link_changed(adapter, i);\r\nif (phy_cause & cphy_cause_fifo_error)\r\np->phy.fifo_errors++;\r\nif (phy_cause & cphy_cause_module_change)\r\nt3_os_phymod_changed(adapter, i);\r\n}\r\n}\r\nt3_write_reg(adapter, A_T3DBG_INT_CAUSE, cause);\r\nreturn 0;\r\n}\r\nint t3_slow_intr_handler(struct adapter *adapter)\r\n{\r\nu32 cause = t3_read_reg(adapter, A_PL_INT_CAUSE0);\r\ncause &= adapter->slow_intr_mask;\r\nif (!cause)\r\nreturn 0;\r\nif (cause & F_PCIM0) {\r\nif (is_pcie(adapter))\r\npcie_intr_handler(adapter);\r\nelse\r\npci_intr_handler(adapter);\r\n}\r\nif (cause & F_SGE3)\r\nt3_sge_err_intr_handler(adapter);\r\nif (cause & F_MC7_PMRX)\r\nmc7_intr_handler(&adapter->pmrx);\r\nif (cause & F_MC7_PMTX)\r\nmc7_intr_handler(&adapter->pmtx);\r\nif (cause & F_MC7_CM)\r\nmc7_intr_handler(&adapter->cm);\r\nif (cause & F_CIM)\r\ncim_intr_handler(adapter);\r\nif (cause & F_TP1)\r\ntp_intr_handler(adapter);\r\nif (cause & F_ULP2_RX)\r\nulprx_intr_handler(adapter);\r\nif (cause & F_ULP2_TX)\r\nulptx_intr_handler(adapter);\r\nif (cause & F_PM1_RX)\r\npmrx_intr_handler(adapter);\r\nif (cause & F_PM1_TX)\r\npmtx_intr_handler(adapter);\r\nif (cause & F_CPL_SWITCH)\r\ncplsw_intr_handler(adapter);\r\nif (cause & F_MPS0)\r\nmps_intr_handler(adapter);\r\nif (cause & F_MC5A)\r\nt3_mc5_intr_handler(&adapter->mc5);\r\nif (cause & F_XGMAC0_0)\r\nmac_intr_handler(adapter, 0);\r\nif (cause & F_XGMAC0_1)\r\nmac_intr_handler(adapter, 1);\r\nif (cause & F_T3DBG)\r\nt3_os_ext_intr_handler(adapter);\r\nt3_write_reg(adapter, A_PL_INT_CAUSE0, cause);\r\nt3_read_reg(adapter, A_PL_INT_CAUSE0);\r\nreturn 1;\r\n}\r\nstatic unsigned int calc_gpio_intr(struct adapter *adap)\r\n{\r\nunsigned int i, gpi_intr = 0;\r\nfor_each_port(adap, i)\r\nif ((adap2pinfo(adap, i)->phy.caps & SUPPORTED_IRQ) &&\r\nadapter_info(adap)->gpio_intr[i])\r\ngpi_intr |= 1 << adapter_info(adap)->gpio_intr[i];\r\nreturn gpi_intr;\r\n}\r\nvoid t3_intr_enable(struct adapter *adapter)\r\n{\r\nstatic const struct addr_val_pair intr_en_avp[] = {\r\n{A_SG_INT_ENABLE, SGE_INTR_MASK},\r\n{A_MC7_INT_ENABLE, MC7_INTR_MASK},\r\n{A_MC7_INT_ENABLE - MC7_PMRX_BASE_ADDR + MC7_PMTX_BASE_ADDR,\r\nMC7_INTR_MASK},\r\n{A_MC7_INT_ENABLE - MC7_PMRX_BASE_ADDR + MC7_CM_BASE_ADDR,\r\nMC7_INTR_MASK},\r\n{A_MC5_DB_INT_ENABLE, MC5_INTR_MASK},\r\n{A_ULPRX_INT_ENABLE, ULPRX_INTR_MASK},\r\n{A_PM1_TX_INT_ENABLE, PMTX_INTR_MASK},\r\n{A_PM1_RX_INT_ENABLE, PMRX_INTR_MASK},\r\n{A_CIM_HOST_INT_ENABLE, CIM_INTR_MASK},\r\n{A_MPS_INT_ENABLE, MPS_INTR_MASK},\r\n};\r\nadapter->slow_intr_mask = PL_INTR_MASK;\r\nt3_write_regs(adapter, intr_en_avp, ARRAY_SIZE(intr_en_avp), 0);\r\nt3_write_reg(adapter, A_TP_INT_ENABLE,\r\nadapter->params.rev >= T3_REV_C ? 0x2bfffff : 0x3bfffff);\r\nif (adapter->params.rev > 0) {\r\nt3_write_reg(adapter, A_CPL_INTR_ENABLE,\r\nCPLSW_INTR_MASK | F_CIM_OVFL_ERROR);\r\nt3_write_reg(adapter, A_ULPTX_INT_ENABLE,\r\nULPTX_INTR_MASK | F_PBL_BOUND_ERR_CH0 |\r\nF_PBL_BOUND_ERR_CH1);\r\n} else {\r\nt3_write_reg(adapter, A_CPL_INTR_ENABLE, CPLSW_INTR_MASK);\r\nt3_write_reg(adapter, A_ULPTX_INT_ENABLE, ULPTX_INTR_MASK);\r\n}\r\nt3_write_reg(adapter, A_T3DBG_INT_ENABLE, calc_gpio_intr(adapter));\r\nif (is_pcie(adapter))\r\nt3_write_reg(adapter, A_PCIE_INT_ENABLE, PCIE_INTR_MASK);\r\nelse\r\nt3_write_reg(adapter, A_PCIX_INT_ENABLE, PCIX_INTR_MASK);\r\nt3_write_reg(adapter, A_PL_INT_ENABLE0, adapter->slow_intr_mask);\r\nt3_read_reg(adapter, A_PL_INT_ENABLE0);\r\n}\r\nvoid t3_intr_disable(struct adapter *adapter)\r\n{\r\nt3_write_reg(adapter, A_PL_INT_ENABLE0, 0);\r\nt3_read_reg(adapter, A_PL_INT_ENABLE0);\r\nadapter->slow_intr_mask = 0;\r\n}\r\nvoid t3_intr_clear(struct adapter *adapter)\r\n{\r\nstatic const unsigned int cause_reg_addr[] = {\r\nA_SG_INT_CAUSE,\r\nA_SG_RSPQ_FL_STATUS,\r\nA_PCIX_INT_CAUSE,\r\nA_MC7_INT_CAUSE,\r\nA_MC7_INT_CAUSE - MC7_PMRX_BASE_ADDR + MC7_PMTX_BASE_ADDR,\r\nA_MC7_INT_CAUSE - MC7_PMRX_BASE_ADDR + MC7_CM_BASE_ADDR,\r\nA_CIM_HOST_INT_CAUSE,\r\nA_TP_INT_CAUSE,\r\nA_MC5_DB_INT_CAUSE,\r\nA_ULPRX_INT_CAUSE,\r\nA_ULPTX_INT_CAUSE,\r\nA_CPL_INTR_CAUSE,\r\nA_PM1_TX_INT_CAUSE,\r\nA_PM1_RX_INT_CAUSE,\r\nA_MPS_INT_CAUSE,\r\nA_T3DBG_INT_CAUSE,\r\n};\r\nunsigned int i;\r\nfor_each_port(adapter, i)\r\nt3_port_intr_clear(adapter, i);\r\nfor (i = 0; i < ARRAY_SIZE(cause_reg_addr); ++i)\r\nt3_write_reg(adapter, cause_reg_addr[i], 0xffffffff);\r\nif (is_pcie(adapter))\r\nt3_write_reg(adapter, A_PCIE_PEX_ERR, 0xffffffff);\r\nt3_write_reg(adapter, A_PL_INT_CAUSE0, 0xffffffff);\r\nt3_read_reg(adapter, A_PL_INT_CAUSE0);\r\n}\r\nvoid t3_xgm_intr_enable(struct adapter *adapter, int idx)\r\n{\r\nstruct port_info *pi = adap2pinfo(adapter, idx);\r\nt3_write_reg(adapter, A_XGM_XGM_INT_ENABLE + pi->mac.offset,\r\nXGM_EXTRA_INTR_MASK);\r\n}\r\nvoid t3_xgm_intr_disable(struct adapter *adapter, int idx)\r\n{\r\nstruct port_info *pi = adap2pinfo(adapter, idx);\r\nt3_write_reg(adapter, A_XGM_XGM_INT_DISABLE + pi->mac.offset,\r\n0x7ff);\r\n}\r\nvoid t3_port_intr_enable(struct adapter *adapter, int idx)\r\n{\r\nstruct cphy *phy = &adap2pinfo(adapter, idx)->phy;\r\nt3_write_reg(adapter, XGM_REG(A_XGM_INT_ENABLE, idx), XGM_INTR_MASK);\r\nt3_read_reg(adapter, XGM_REG(A_XGM_INT_ENABLE, idx));\r\nphy->ops->intr_enable(phy);\r\n}\r\nvoid t3_port_intr_disable(struct adapter *adapter, int idx)\r\n{\r\nstruct cphy *phy = &adap2pinfo(adapter, idx)->phy;\r\nt3_write_reg(adapter, XGM_REG(A_XGM_INT_ENABLE, idx), 0);\r\nt3_read_reg(adapter, XGM_REG(A_XGM_INT_ENABLE, idx));\r\nphy->ops->intr_disable(phy);\r\n}\r\nstatic void t3_port_intr_clear(struct adapter *adapter, int idx)\r\n{\r\nstruct cphy *phy = &adap2pinfo(adapter, idx)->phy;\r\nt3_write_reg(adapter, XGM_REG(A_XGM_INT_CAUSE, idx), 0xffffffff);\r\nt3_read_reg(adapter, XGM_REG(A_XGM_INT_CAUSE, idx));\r\nphy->ops->intr_clear(phy);\r\n}\r\nstatic int t3_sge_write_context(struct adapter *adapter, unsigned int id,\r\nunsigned int type)\r\n{\r\nif (type == F_RESPONSEQ) {\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK0, 0xffffffff);\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK1, 0xffffffff);\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK2, 0x17ffffff);\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK3, 0xffffffff);\r\n} else {\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK0, 0xffffffff);\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK1, 0xffffffff);\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK2, 0xffffffff);\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK3, 0xffffffff);\r\n}\r\nt3_write_reg(adapter, A_SG_CONTEXT_CMD,\r\nV_CONTEXT_CMD_OPCODE(1) | type | V_CONTEXT(id));\r\nreturn t3_wait_op_done(adapter, A_SG_CONTEXT_CMD, F_CONTEXT_CMD_BUSY,\r\n0, SG_CONTEXT_CMD_ATTEMPTS, 1);\r\n}\r\nstatic int clear_sge_ctxt(struct adapter *adap, unsigned int id,\r\nunsigned int type)\r\n{\r\nt3_write_reg(adap, A_SG_CONTEXT_DATA0, 0);\r\nt3_write_reg(adap, A_SG_CONTEXT_DATA1, 0);\r\nt3_write_reg(adap, A_SG_CONTEXT_DATA2, 0);\r\nt3_write_reg(adap, A_SG_CONTEXT_DATA3, 0);\r\nt3_write_reg(adap, A_SG_CONTEXT_MASK0, 0xffffffff);\r\nt3_write_reg(adap, A_SG_CONTEXT_MASK1, 0xffffffff);\r\nt3_write_reg(adap, A_SG_CONTEXT_MASK2, 0xffffffff);\r\nt3_write_reg(adap, A_SG_CONTEXT_MASK3, 0xffffffff);\r\nt3_write_reg(adap, A_SG_CONTEXT_CMD,\r\nV_CONTEXT_CMD_OPCODE(1) | type | V_CONTEXT(id));\r\nreturn t3_wait_op_done(adap, A_SG_CONTEXT_CMD, F_CONTEXT_CMD_BUSY,\r\n0, SG_CONTEXT_CMD_ATTEMPTS, 1);\r\n}\r\nint t3_sge_init_ecntxt(struct adapter *adapter, unsigned int id, int gts_enable,\r\nenum sge_context_type type, int respq, u64 base_addr,\r\nunsigned int size, unsigned int token, int gen,\r\nunsigned int cidx)\r\n{\r\nunsigned int credits = type == SGE_CNTXT_OFLD ? 0 : FW_WR_NUM;\r\nif (base_addr & 0xfff)\r\nreturn -EINVAL;\r\nif (t3_read_reg(adapter, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\r\nreturn -EBUSY;\r\nbase_addr >>= 12;\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA0, V_EC_INDEX(cidx) |\r\nV_EC_CREDITS(credits) | V_EC_GTS(gts_enable));\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA1, V_EC_SIZE(size) |\r\nV_EC_BASE_LO(base_addr & 0xffff));\r\nbase_addr >>= 16;\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA2, base_addr);\r\nbase_addr >>= 32;\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA3,\r\nV_EC_BASE_HI(base_addr & 0xf) | V_EC_RESPQ(respq) |\r\nV_EC_TYPE(type) | V_EC_GEN(gen) | V_EC_UP_TOKEN(token) |\r\nF_EC_VALID);\r\nreturn t3_sge_write_context(adapter, id, F_EGRESS);\r\n}\r\nint t3_sge_init_flcntxt(struct adapter *adapter, unsigned int id,\r\nint gts_enable, u64 base_addr, unsigned int size,\r\nunsigned int bsize, unsigned int cong_thres, int gen,\r\nunsigned int cidx)\r\n{\r\nif (base_addr & 0xfff)\r\nreturn -EINVAL;\r\nif (t3_read_reg(adapter, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\r\nreturn -EBUSY;\r\nbase_addr >>= 12;\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA0, base_addr);\r\nbase_addr >>= 32;\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA1,\r\nV_FL_BASE_HI((u32) base_addr) |\r\nV_FL_INDEX_LO(cidx & M_FL_INDEX_LO));\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA2, V_FL_SIZE(size) |\r\nV_FL_GEN(gen) | V_FL_INDEX_HI(cidx >> 12) |\r\nV_FL_ENTRY_SIZE_LO(bsize & M_FL_ENTRY_SIZE_LO));\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA3,\r\nV_FL_ENTRY_SIZE_HI(bsize >> (32 - S_FL_ENTRY_SIZE_LO)) |\r\nV_FL_CONG_THRES(cong_thres) | V_FL_GTS(gts_enable));\r\nreturn t3_sge_write_context(adapter, id, F_FREELIST);\r\n}\r\nint t3_sge_init_rspcntxt(struct adapter *adapter, unsigned int id,\r\nint irq_vec_idx, u64 base_addr, unsigned int size,\r\nunsigned int fl_thres, int gen, unsigned int cidx)\r\n{\r\nunsigned int intr = 0;\r\nif (base_addr & 0xfff)\r\nreturn -EINVAL;\r\nif (t3_read_reg(adapter, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\r\nreturn -EBUSY;\r\nbase_addr >>= 12;\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA0, V_CQ_SIZE(size) |\r\nV_CQ_INDEX(cidx));\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA1, base_addr);\r\nbase_addr >>= 32;\r\nif (irq_vec_idx >= 0)\r\nintr = V_RQ_MSI_VEC(irq_vec_idx) | F_RQ_INTR_EN;\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA2,\r\nV_CQ_BASE_HI((u32) base_addr) | intr | V_RQ_GEN(gen));\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA3, fl_thres);\r\nreturn t3_sge_write_context(adapter, id, F_RESPONSEQ);\r\n}\r\nint t3_sge_init_cqcntxt(struct adapter *adapter, unsigned int id, u64 base_addr,\r\nunsigned int size, int rspq, int ovfl_mode,\r\nunsigned int credits, unsigned int credit_thres)\r\n{\r\nif (base_addr & 0xfff)\r\nreturn -EINVAL;\r\nif (t3_read_reg(adapter, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\r\nreturn -EBUSY;\r\nbase_addr >>= 12;\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA0, V_CQ_SIZE(size));\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA1, base_addr);\r\nbase_addr >>= 32;\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA2,\r\nV_CQ_BASE_HI((u32) base_addr) | V_CQ_RSPQ(rspq) |\r\nV_CQ_GEN(1) | V_CQ_OVERFLOW_MODE(ovfl_mode) |\r\nV_CQ_ERR(ovfl_mode));\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA3, V_CQ_CREDITS(credits) |\r\nV_CQ_CREDIT_THRES(credit_thres));\r\nreturn t3_sge_write_context(adapter, id, F_CQ);\r\n}\r\nint t3_sge_enable_ecntxt(struct adapter *adapter, unsigned int id, int enable)\r\n{\r\nif (t3_read_reg(adapter, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\r\nreturn -EBUSY;\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK0, 0);\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK1, 0);\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK2, 0);\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK3, F_EC_VALID);\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA3, V_EC_VALID(enable));\r\nt3_write_reg(adapter, A_SG_CONTEXT_CMD,\r\nV_CONTEXT_CMD_OPCODE(1) | F_EGRESS | V_CONTEXT(id));\r\nreturn t3_wait_op_done(adapter, A_SG_CONTEXT_CMD, F_CONTEXT_CMD_BUSY,\r\n0, SG_CONTEXT_CMD_ATTEMPTS, 1);\r\n}\r\nint t3_sge_disable_fl(struct adapter *adapter, unsigned int id)\r\n{\r\nif (t3_read_reg(adapter, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\r\nreturn -EBUSY;\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK0, 0);\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK1, 0);\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK2, V_FL_SIZE(M_FL_SIZE));\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK3, 0);\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA2, 0);\r\nt3_write_reg(adapter, A_SG_CONTEXT_CMD,\r\nV_CONTEXT_CMD_OPCODE(1) | F_FREELIST | V_CONTEXT(id));\r\nreturn t3_wait_op_done(adapter, A_SG_CONTEXT_CMD, F_CONTEXT_CMD_BUSY,\r\n0, SG_CONTEXT_CMD_ATTEMPTS, 1);\r\n}\r\nint t3_sge_disable_rspcntxt(struct adapter *adapter, unsigned int id)\r\n{\r\nif (t3_read_reg(adapter, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\r\nreturn -EBUSY;\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK0, V_CQ_SIZE(M_CQ_SIZE));\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK1, 0);\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK2, 0);\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK3, 0);\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA0, 0);\r\nt3_write_reg(adapter, A_SG_CONTEXT_CMD,\r\nV_CONTEXT_CMD_OPCODE(1) | F_RESPONSEQ | V_CONTEXT(id));\r\nreturn t3_wait_op_done(adapter, A_SG_CONTEXT_CMD, F_CONTEXT_CMD_BUSY,\r\n0, SG_CONTEXT_CMD_ATTEMPTS, 1);\r\n}\r\nint t3_sge_disable_cqcntxt(struct adapter *adapter, unsigned int id)\r\n{\r\nif (t3_read_reg(adapter, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\r\nreturn -EBUSY;\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK0, V_CQ_SIZE(M_CQ_SIZE));\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK1, 0);\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK2, 0);\r\nt3_write_reg(adapter, A_SG_CONTEXT_MASK3, 0);\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA0, 0);\r\nt3_write_reg(adapter, A_SG_CONTEXT_CMD,\r\nV_CONTEXT_CMD_OPCODE(1) | F_CQ | V_CONTEXT(id));\r\nreturn t3_wait_op_done(adapter, A_SG_CONTEXT_CMD, F_CONTEXT_CMD_BUSY,\r\n0, SG_CONTEXT_CMD_ATTEMPTS, 1);\r\n}\r\nint t3_sge_cqcntxt_op(struct adapter *adapter, unsigned int id, unsigned int op,\r\nunsigned int credits)\r\n{\r\nu32 val;\r\nif (t3_read_reg(adapter, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\r\nreturn -EBUSY;\r\nt3_write_reg(adapter, A_SG_CONTEXT_DATA0, credits << 16);\r\nt3_write_reg(adapter, A_SG_CONTEXT_CMD, V_CONTEXT_CMD_OPCODE(op) |\r\nV_CONTEXT(id) | F_CQ);\r\nif (t3_wait_op_done_val(adapter, A_SG_CONTEXT_CMD, F_CONTEXT_CMD_BUSY,\r\n0, SG_CONTEXT_CMD_ATTEMPTS, 1, &val))\r\nreturn -EIO;\r\nif (op >= 2 && op < 7) {\r\nif (adapter->params.rev > 0)\r\nreturn G_CQ_INDEX(val);\r\nt3_write_reg(adapter, A_SG_CONTEXT_CMD,\r\nV_CONTEXT_CMD_OPCODE(0) | F_CQ | V_CONTEXT(id));\r\nif (t3_wait_op_done(adapter, A_SG_CONTEXT_CMD,\r\nF_CONTEXT_CMD_BUSY, 0,\r\nSG_CONTEXT_CMD_ATTEMPTS, 1))\r\nreturn -EIO;\r\nreturn G_CQ_INDEX(t3_read_reg(adapter, A_SG_CONTEXT_DATA0));\r\n}\r\nreturn 0;\r\n}\r\nvoid t3_config_rss(struct adapter *adapter, unsigned int rss_config,\r\nconst u8 * cpus, const u16 *rspq)\r\n{\r\nint i, j, cpu_idx = 0, q_idx = 0;\r\nif (cpus)\r\nfor (i = 0; i < RSS_TABLE_SIZE; ++i) {\r\nu32 val = i << 16;\r\nfor (j = 0; j < 2; ++j) {\r\nval |= (cpus[cpu_idx++] & 0x3f) << (8 * j);\r\nif (cpus[cpu_idx] == 0xff)\r\ncpu_idx = 0;\r\n}\r\nt3_write_reg(adapter, A_TP_RSS_LKP_TABLE, val);\r\n}\r\nif (rspq)\r\nfor (i = 0; i < RSS_TABLE_SIZE; ++i) {\r\nt3_write_reg(adapter, A_TP_RSS_MAP_TABLE,\r\n(i << 16) | rspq[q_idx++]);\r\nif (rspq[q_idx] == 0xffff)\r\nq_idx = 0;\r\n}\r\nt3_write_reg(adapter, A_TP_RSS_CONFIG, rss_config);\r\n}\r\nvoid t3_tp_set_offload_mode(struct adapter *adap, int enable)\r\n{\r\nif (is_offload(adap) || !enable)\r\nt3_set_reg_field(adap, A_TP_IN_CONFIG, F_NICMODE,\r\nV_NICMODE(!enable));\r\n}\r\nstatic inline unsigned int pm_num_pages(unsigned int mem_size,\r\nunsigned int pg_size)\r\n{\r\nunsigned int n = mem_size / pg_size;\r\nreturn n - n % 24;\r\n}\r\nstatic void partition_mem(struct adapter *adap, const struct tp_params *p)\r\n{\r\nunsigned int m, pstructs, tids = t3_mc5_size(&adap->mc5);\r\nunsigned int timers = 0, timers_shift = 22;\r\nif (adap->params.rev > 0) {\r\nif (tids <= 16 * 1024) {\r\ntimers = 1;\r\ntimers_shift = 16;\r\n} else if (tids <= 64 * 1024) {\r\ntimers = 2;\r\ntimers_shift = 18;\r\n} else if (tids <= 256 * 1024) {\r\ntimers = 3;\r\ntimers_shift = 20;\r\n}\r\n}\r\nt3_write_reg(adap, A_TP_PMM_SIZE,\r\np->chan_rx_size | (p->chan_tx_size >> 16));\r\nt3_write_reg(adap, A_TP_PMM_TX_BASE, 0);\r\nt3_write_reg(adap, A_TP_PMM_TX_PAGE_SIZE, p->tx_pg_size);\r\nt3_write_reg(adap, A_TP_PMM_TX_MAX_PAGE, p->tx_num_pgs);\r\nt3_set_reg_field(adap, A_TP_PARA_REG3, V_TXDATAACKIDX(M_TXDATAACKIDX),\r\nV_TXDATAACKIDX(fls(p->tx_pg_size) - 12));\r\nt3_write_reg(adap, A_TP_PMM_RX_BASE, 0);\r\nt3_write_reg(adap, A_TP_PMM_RX_PAGE_SIZE, p->rx_pg_size);\r\nt3_write_reg(adap, A_TP_PMM_RX_MAX_PAGE, p->rx_num_pgs);\r\npstructs = p->rx_num_pgs + p->tx_num_pgs;\r\npstructs += 48;\r\npstructs -= pstructs % 24;\r\nt3_write_reg(adap, A_TP_CMM_MM_MAX_PSTRUCT, pstructs);\r\nm = tids * TCB_SIZE;\r\nmem_region(adap, m, (64 << 10) * 64, SG_EGR_CNTX_BADDR);\r\nmem_region(adap, m, (64 << 10) * 64, SG_CQ_CONTEXT_BADDR);\r\nt3_write_reg(adap, A_TP_CMM_TIMER_BASE, V_CMTIMERMAXNUM(timers) | m);\r\nm += ((p->ntimer_qs - 1) << timers_shift) + (1 << 22);\r\nmem_region(adap, m, pstructs * 64, TP_CMM_MM_BASE);\r\nmem_region(adap, m, 64 * (pstructs / 24), TP_CMM_MM_PS_FLST_BASE);\r\nmem_region(adap, m, 64 * (p->rx_num_pgs / 24), TP_CMM_MM_RX_FLST_BASE);\r\nmem_region(adap, m, 64 * (p->tx_num_pgs / 24), TP_CMM_MM_TX_FLST_BASE);\r\nm = (m + 4095) & ~0xfff;\r\nt3_write_reg(adap, A_CIM_SDRAM_BASE_ADDR, m);\r\nt3_write_reg(adap, A_CIM_SDRAM_ADDR_SIZE, p->cm_size - m);\r\ntids = (p->cm_size - m - (3 << 20)) / 3072 - 32;\r\nm = t3_mc5_size(&adap->mc5) - adap->params.mc5.nservers -\r\nadap->params.mc5.nfilters - adap->params.mc5.nroutes;\r\nif (tids < m)\r\nadap->params.mc5.nservers += m - tids;\r\n}\r\nstatic inline void tp_wr_indirect(struct adapter *adap, unsigned int addr,\r\nu32 val)\r\n{\r\nt3_write_reg(adap, A_TP_PIO_ADDR, addr);\r\nt3_write_reg(adap, A_TP_PIO_DATA, val);\r\n}\r\nstatic void tp_config(struct adapter *adap, const struct tp_params *p)\r\n{\r\nt3_write_reg(adap, A_TP_GLOBAL_CONFIG, F_TXPACINGENABLE | F_PATHMTU |\r\nF_IPCHECKSUMOFFLOAD | F_UDPCHECKSUMOFFLOAD |\r\nF_TCPCHECKSUMOFFLOAD | V_IPTTL(64));\r\nt3_write_reg(adap, A_TP_TCP_OPTIONS, V_MTUDEFAULT(576) |\r\nF_MTUENABLE | V_WINDOWSCALEMODE(1) |\r\nV_TIMESTAMPSMODE(1) | V_SACKMODE(1) | V_SACKRX(1));\r\nt3_write_reg(adap, A_TP_DACK_CONFIG, V_AUTOSTATE3(1) |\r\nV_AUTOSTATE2(1) | V_AUTOSTATE1(0) |\r\nV_BYTETHRESHOLD(26880) | V_MSSTHRESHOLD(2) |\r\nF_AUTOCAREFUL | F_AUTOENABLE | V_DACK_MODE(1));\r\nt3_set_reg_field(adap, A_TP_IN_CONFIG, F_RXFBARBPRIO | F_TXFBARBPRIO,\r\nF_IPV6ENABLE | F_NICMODE);\r\nt3_write_reg(adap, A_TP_TX_RESOURCE_LIMIT, 0x18141814);\r\nt3_write_reg(adap, A_TP_PARA_REG4, 0x5050105);\r\nt3_set_reg_field(adap, A_TP_PARA_REG6, 0,\r\nadap->params.rev > 0 ? F_ENABLEESND :\r\nF_T3A_ENABLEESND);\r\nt3_set_reg_field(adap, A_TP_PC_CONFIG,\r\nF_ENABLEEPCMDAFULL,\r\nF_ENABLEOCSPIFULL |F_TXDEFERENABLE | F_HEARBEATDACK |\r\nF_TXCONGESTIONMODE | F_RXCONGESTIONMODE);\r\nt3_set_reg_field(adap, A_TP_PC_CONFIG2, F_CHDRAFULL,\r\nF_ENABLEIPV6RSS | F_ENABLENONOFDTNLSYN |\r\nF_ENABLEARPMISS | F_DISBLEDAPARBIT0);\r\nt3_write_reg(adap, A_TP_PROXY_FLOW_CNTL, 1080);\r\nt3_write_reg(adap, A_TP_PROXY_FLOW_CNTL, 1000);\r\nif (adap->params.rev > 0) {\r\ntp_wr_indirect(adap, A_TP_EGRESS_CONFIG, F_REWRITEFORCETOSIZE);\r\nt3_set_reg_field(adap, A_TP_PARA_REG3, F_TXPACEAUTO,\r\nF_TXPACEAUTO);\r\nt3_set_reg_field(adap, A_TP_PC_CONFIG, F_LOCKTID, F_LOCKTID);\r\nt3_set_reg_field(adap, A_TP_PARA_REG3, 0, F_TXPACEAUTOSTRICT);\r\n} else\r\nt3_set_reg_field(adap, A_TP_PARA_REG3, 0, F_TXPACEFIXED);\r\nif (adap->params.rev == T3_REV_C)\r\nt3_set_reg_field(adap, A_TP_PC_CONFIG,\r\nV_TABLELATENCYDELTA(M_TABLELATENCYDELTA),\r\nV_TABLELATENCYDELTA(4));\r\nt3_write_reg(adap, A_TP_TX_MOD_QUEUE_WEIGHT1, 0);\r\nt3_write_reg(adap, A_TP_TX_MOD_QUEUE_WEIGHT0, 0);\r\nt3_write_reg(adap, A_TP_MOD_CHANNEL_WEIGHT, 0);\r\nt3_write_reg(adap, A_TP_MOD_RATE_LIMIT, 0xf2200000);\r\n}\r\nstatic void tp_set_timers(struct adapter *adap, unsigned int core_clk)\r\n{\r\nunsigned int tre = fls(core_clk / (1000000 / TP_TMR_RES)) - 1;\r\nunsigned int dack_re = fls(core_clk / 5000) - 1;\r\nunsigned int tstamp_re = fls(core_clk / 1000);\r\nunsigned int tps = core_clk >> tre;\r\nt3_write_reg(adap, A_TP_TIMER_RESOLUTION, V_TIMERRESOLUTION(tre) |\r\nV_DELAYEDACKRESOLUTION(dack_re) |\r\nV_TIMESTAMPRESOLUTION(tstamp_re));\r\nt3_write_reg(adap, A_TP_DACK_TIMER,\r\n(core_clk >> dack_re) / (1000 / TP_DACK_TIMER));\r\nt3_write_reg(adap, A_TP_TCP_BACKOFF_REG0, 0x3020100);\r\nt3_write_reg(adap, A_TP_TCP_BACKOFF_REG1, 0x7060504);\r\nt3_write_reg(adap, A_TP_TCP_BACKOFF_REG2, 0xb0a0908);\r\nt3_write_reg(adap, A_TP_TCP_BACKOFF_REG3, 0xf0e0d0c);\r\nt3_write_reg(adap, A_TP_SHIFT_CNT, V_SYNSHIFTMAX(6) |\r\nV_RXTSHIFTMAXR1(4) | V_RXTSHIFTMAXR2(15) |\r\nV_PERSHIFTBACKOFFMAX(8) | V_PERSHIFTMAX(8) |\r\nV_KEEPALIVEMAX(9));\r\n#define SECONDS * tps\r\nt3_write_reg(adap, A_TP_MSL, adap->params.rev > 0 ? 0 : 2 SECONDS);\r\nt3_write_reg(adap, A_TP_RXT_MIN, tps / (1000 / TP_RTO_MIN));\r\nt3_write_reg(adap, A_TP_RXT_MAX, 64 SECONDS);\r\nt3_write_reg(adap, A_TP_PERS_MIN, 5 SECONDS);\r\nt3_write_reg(adap, A_TP_PERS_MAX, 64 SECONDS);\r\nt3_write_reg(adap, A_TP_KEEP_IDLE, 7200 SECONDS);\r\nt3_write_reg(adap, A_TP_KEEP_INTVL, 75 SECONDS);\r\nt3_write_reg(adap, A_TP_INIT_SRTT, 3 SECONDS);\r\nt3_write_reg(adap, A_TP_FINWAIT2_TIMER, 600 SECONDS);\r\n#undef SECONDS\r\n}\r\nstatic int t3_tp_set_coalescing_size(struct adapter *adap,\r\nunsigned int size, int psh)\r\n{\r\nu32 val;\r\nif (size > MAX_RX_COALESCING_LEN)\r\nreturn -EINVAL;\r\nval = t3_read_reg(adap, A_TP_PARA_REG3);\r\nval &= ~(F_RXCOALESCEENABLE | F_RXCOALESCEPSHEN);\r\nif (size) {\r\nval |= F_RXCOALESCEENABLE;\r\nif (psh)\r\nval |= F_RXCOALESCEPSHEN;\r\nsize = min(MAX_RX_COALESCING_LEN, size);\r\nt3_write_reg(adap, A_TP_PARA_REG2, V_RXCOALESCESIZE(size) |\r\nV_MAXRXDATA(MAX_RX_COALESCING_LEN));\r\n}\r\nt3_write_reg(adap, A_TP_PARA_REG3, val);\r\nreturn 0;\r\n}\r\nstatic void t3_tp_set_max_rxsize(struct adapter *adap, unsigned int size)\r\n{\r\nt3_write_reg(adap, A_TP_PARA_REG7,\r\nV_PMMAXXFERLEN0(size) | V_PMMAXXFERLEN1(size));\r\n}\r\nstatic void init_mtus(unsigned short mtus[])\r\n{\r\nmtus[0] = 88;\r\nmtus[1] = 88;\r\nmtus[2] = 256;\r\nmtus[3] = 512;\r\nmtus[4] = 576;\r\nmtus[5] = 1024;\r\nmtus[6] = 1280;\r\nmtus[7] = 1492;\r\nmtus[8] = 1500;\r\nmtus[9] = 2002;\r\nmtus[10] = 2048;\r\nmtus[11] = 4096;\r\nmtus[12] = 4352;\r\nmtus[13] = 8192;\r\nmtus[14] = 9000;\r\nmtus[15] = 9600;\r\n}\r\nstatic void init_cong_ctrl(unsigned short *a, unsigned short *b)\r\n{\r\na[0] = a[1] = a[2] = a[3] = a[4] = a[5] = a[6] = a[7] = a[8] = 1;\r\na[9] = 2;\r\na[10] = 3;\r\na[11] = 4;\r\na[12] = 5;\r\na[13] = 6;\r\na[14] = 7;\r\na[15] = 8;\r\na[16] = 9;\r\na[17] = 10;\r\na[18] = 14;\r\na[19] = 17;\r\na[20] = 21;\r\na[21] = 25;\r\na[22] = 30;\r\na[23] = 35;\r\na[24] = 45;\r\na[25] = 60;\r\na[26] = 80;\r\na[27] = 100;\r\na[28] = 200;\r\na[29] = 300;\r\na[30] = 400;\r\na[31] = 500;\r\nb[0] = b[1] = b[2] = b[3] = b[4] = b[5] = b[6] = b[7] = b[8] = 0;\r\nb[9] = b[10] = 1;\r\nb[11] = b[12] = 2;\r\nb[13] = b[14] = b[15] = b[16] = 3;\r\nb[17] = b[18] = b[19] = b[20] = b[21] = 4;\r\nb[22] = b[23] = b[24] = b[25] = b[26] = b[27] = 5;\r\nb[28] = b[29] = 6;\r\nb[30] = b[31] = 7;\r\n}\r\nvoid t3_load_mtus(struct adapter *adap, unsigned short mtus[NMTUS],\r\nunsigned short alpha[NCCTRL_WIN],\r\nunsigned short beta[NCCTRL_WIN], unsigned short mtu_cap)\r\n{\r\nstatic const unsigned int avg_pkts[NCCTRL_WIN] = {\r\n2, 6, 10, 14, 20, 28, 40, 56, 80, 112, 160, 224, 320, 448, 640,\r\n896, 1281, 1792, 2560, 3584, 5120, 7168, 10240, 14336, 20480,\r\n28672, 40960, 57344, 81920, 114688, 163840, 229376\r\n};\r\nunsigned int i, w;\r\nfor (i = 0; i < NMTUS; ++i) {\r\nunsigned int mtu = min(mtus[i], mtu_cap);\r\nunsigned int log2 = fls(mtu);\r\nif (!(mtu & ((1 << log2) >> 2)))\r\nlog2--;\r\nt3_write_reg(adap, A_TP_MTU_TABLE,\r\n(i << 24) | (log2 << 16) | mtu);\r\nfor (w = 0; w < NCCTRL_WIN; ++w) {\r\nunsigned int inc;\r\ninc = max(((mtu - 40) * alpha[w]) / avg_pkts[w],\r\nCC_MIN_INCR);\r\nt3_write_reg(adap, A_TP_CCTRL_TABLE, (i << 21) |\r\n(w << 16) | (beta[w] << 13) | inc);\r\n}\r\n}\r\n}\r\nvoid t3_tp_get_mib_stats(struct adapter *adap, struct tp_mib_stats *tps)\r\n{\r\nt3_read_indirect(adap, A_TP_MIB_INDEX, A_TP_MIB_RDATA, (u32 *) tps,\r\nsizeof(*tps) / sizeof(u32), 0);\r\n}\r\nstatic void ulp_config(struct adapter *adap, const struct tp_params *p)\r\n{\r\nunsigned int m = p->chan_rx_size;\r\nulp_region(adap, ISCSI, m, p->chan_rx_size / 8);\r\nulp_region(adap, TDDP, m, p->chan_rx_size / 8);\r\nulptx_region(adap, TPT, m, p->chan_rx_size / 4);\r\nulp_region(adap, STAG, m, p->chan_rx_size / 4);\r\nulp_region(adap, RQ, m, p->chan_rx_size / 4);\r\nulptx_region(adap, PBL, m, p->chan_rx_size / 4);\r\nulp_region(adap, PBL, m, p->chan_rx_size / 4);\r\nt3_write_reg(adap, A_ULPRX_TDDP_TAGMASK, 0xffffffff);\r\n}\r\nint t3_set_proto_sram(struct adapter *adap, const u8 *data)\r\n{\r\nint i;\r\nconst __be32 *buf = (const __be32 *)data;\r\nfor (i = 0; i < PROTO_SRAM_LINES; i++) {\r\nt3_write_reg(adap, A_TP_EMBED_OP_FIELD5, be32_to_cpu(*buf++));\r\nt3_write_reg(adap, A_TP_EMBED_OP_FIELD4, be32_to_cpu(*buf++));\r\nt3_write_reg(adap, A_TP_EMBED_OP_FIELD3, be32_to_cpu(*buf++));\r\nt3_write_reg(adap, A_TP_EMBED_OP_FIELD2, be32_to_cpu(*buf++));\r\nt3_write_reg(adap, A_TP_EMBED_OP_FIELD1, be32_to_cpu(*buf++));\r\nt3_write_reg(adap, A_TP_EMBED_OP_FIELD0, i << 1 | 1 << 31);\r\nif (t3_wait_op_done(adap, A_TP_EMBED_OP_FIELD0, 1, 1, 5, 1))\r\nreturn -EIO;\r\n}\r\nt3_write_reg(adap, A_TP_EMBED_OP_FIELD0, 0);\r\nreturn 0;\r\n}\r\nvoid t3_config_trace_filter(struct adapter *adapter,\r\nconst struct trace_params *tp, int filter_index,\r\nint invert, int enable)\r\n{\r\nu32 addr, key[4], mask[4];\r\nkey[0] = tp->sport | (tp->sip << 16);\r\nkey[1] = (tp->sip >> 16) | (tp->dport << 16);\r\nkey[2] = tp->dip;\r\nkey[3] = tp->proto | (tp->vlan << 8) | (tp->intf << 20);\r\nmask[0] = tp->sport_mask | (tp->sip_mask << 16);\r\nmask[1] = (tp->sip_mask >> 16) | (tp->dport_mask << 16);\r\nmask[2] = tp->dip_mask;\r\nmask[3] = tp->proto_mask | (tp->vlan_mask << 8) | (tp->intf_mask << 20);\r\nif (invert)\r\nkey[3] |= (1 << 29);\r\nif (enable)\r\nkey[3] |= (1 << 28);\r\naddr = filter_index ? A_TP_RX_TRC_KEY0 : A_TP_TX_TRC_KEY0;\r\ntp_wr_indirect(adapter, addr++, key[0]);\r\ntp_wr_indirect(adapter, addr++, mask[0]);\r\ntp_wr_indirect(adapter, addr++, key[1]);\r\ntp_wr_indirect(adapter, addr++, mask[1]);\r\ntp_wr_indirect(adapter, addr++, key[2]);\r\ntp_wr_indirect(adapter, addr++, mask[2]);\r\ntp_wr_indirect(adapter, addr++, key[3]);\r\ntp_wr_indirect(adapter, addr, mask[3]);\r\nt3_read_reg(adapter, A_TP_PIO_DATA);\r\n}\r\nint t3_config_sched(struct adapter *adap, unsigned int kbps, int sched)\r\n{\r\nunsigned int v, tps, cpt, bpt, delta, mindelta = ~0;\r\nunsigned int clk = adap->params.vpd.cclk * 1000;\r\nunsigned int selected_cpt = 0, selected_bpt = 0;\r\nif (kbps > 0) {\r\nkbps *= 125;\r\nfor (cpt = 1; cpt <= 255; cpt++) {\r\ntps = clk / cpt;\r\nbpt = (kbps + tps / 2) / tps;\r\nif (bpt > 0 && bpt <= 255) {\r\nv = bpt * tps;\r\ndelta = v >= kbps ? v - kbps : kbps - v;\r\nif (delta <= mindelta) {\r\nmindelta = delta;\r\nselected_cpt = cpt;\r\nselected_bpt = bpt;\r\n}\r\n} else if (selected_cpt)\r\nbreak;\r\n}\r\nif (!selected_cpt)\r\nreturn -EINVAL;\r\n}\r\nt3_write_reg(adap, A_TP_TM_PIO_ADDR,\r\nA_TP_TX_MOD_Q1_Q0_RATE_LIMIT - sched / 2);\r\nv = t3_read_reg(adap, A_TP_TM_PIO_DATA);\r\nif (sched & 1)\r\nv = (v & 0xffff) | (selected_cpt << 16) | (selected_bpt << 24);\r\nelse\r\nv = (v & 0xffff0000) | selected_cpt | (selected_bpt << 8);\r\nt3_write_reg(adap, A_TP_TM_PIO_DATA, v);\r\nreturn 0;\r\n}\r\nstatic int tp_init(struct adapter *adap, const struct tp_params *p)\r\n{\r\nint busy = 0;\r\ntp_config(adap, p);\r\nt3_set_vlan_accel(adap, 3, 0);\r\nif (is_offload(adap)) {\r\ntp_set_timers(adap, adap->params.vpd.cclk * 1000);\r\nt3_write_reg(adap, A_TP_RESET, F_FLSTINITENABLE);\r\nbusy = t3_wait_op_done(adap, A_TP_RESET, F_FLSTINITENABLE,\r\n0, 1000, 5);\r\nif (busy)\r\nCH_ERR(adap, "TP initialization timed out\n");\r\n}\r\nif (!busy)\r\nt3_write_reg(adap, A_TP_RESET, F_TPRESET);\r\nreturn busy;\r\n}\r\nstatic void chan_init_hw(struct adapter *adap, unsigned int chan_map)\r\n{\r\nint i;\r\nif (chan_map != 3) {\r\nt3_set_reg_field(adap, A_ULPRX_CTL, F_ROUND_ROBIN, 0);\r\nt3_set_reg_field(adap, A_ULPTX_CONFIG, F_CFG_RR_ARB, 0);\r\nt3_write_reg(adap, A_MPS_CFG, F_TPRXPORTEN | F_ENFORCEPKT |\r\n(chan_map == 1 ? F_TPTXPORT0EN | F_PORT0ACTIVE :\r\nF_TPTXPORT1EN | F_PORT1ACTIVE));\r\nt3_write_reg(adap, A_PM1_TX_CFG,\r\nchan_map == 1 ? 0xffffffff : 0);\r\n} else {\r\nt3_set_reg_field(adap, A_ULPRX_CTL, 0, F_ROUND_ROBIN);\r\nt3_set_reg_field(adap, A_ULPTX_CONFIG, 0, F_CFG_RR_ARB);\r\nt3_write_reg(adap, A_ULPTX_DMA_WEIGHT,\r\nV_D1_WEIGHT(16) | V_D0_WEIGHT(16));\r\nt3_write_reg(adap, A_MPS_CFG, F_TPTXPORT0EN | F_TPTXPORT1EN |\r\nF_TPRXPORTEN | F_PORT0ACTIVE | F_PORT1ACTIVE |\r\nF_ENFORCEPKT);\r\nt3_write_reg(adap, A_PM1_TX_CFG, 0x80008000);\r\nt3_set_reg_field(adap, A_TP_PC_CONFIG, 0, F_TXTOSQUEUEMAPMODE);\r\nt3_write_reg(adap, A_TP_TX_MOD_QUEUE_REQ_MAP,\r\nV_TX_MOD_QUEUE_REQ_MAP(0xaa));\r\nfor (i = 0; i < 16; i++)\r\nt3_write_reg(adap, A_TP_TX_MOD_QUE_TABLE,\r\n(i << 16) | 0x1010);\r\n}\r\n}\r\nstatic int calibrate_xgm(struct adapter *adapter)\r\n{\r\nif (uses_xaui(adapter)) {\r\nunsigned int v, i;\r\nfor (i = 0; i < 5; ++i) {\r\nt3_write_reg(adapter, A_XGM_XAUI_IMP, 0);\r\nt3_read_reg(adapter, A_XGM_XAUI_IMP);\r\nmsleep(1);\r\nv = t3_read_reg(adapter, A_XGM_XAUI_IMP);\r\nif (!(v & (F_XGM_CALFAULT | F_CALBUSY))) {\r\nt3_write_reg(adapter, A_XGM_XAUI_IMP,\r\nV_XAUIIMP(G_CALIMP(v) >> 2));\r\nreturn 0;\r\n}\r\n}\r\nCH_ERR(adapter, "MAC calibration failed\n");\r\nreturn -1;\r\n} else {\r\nt3_write_reg(adapter, A_XGM_RGMII_IMP,\r\nV_RGMIIIMPPD(2) | V_RGMIIIMPPU(3));\r\nt3_set_reg_field(adapter, A_XGM_RGMII_IMP, F_XGM_IMPSETUPDATE,\r\nF_XGM_IMPSETUPDATE);\r\n}\r\nreturn 0;\r\n}\r\nstatic void calibrate_xgm_t3b(struct adapter *adapter)\r\n{\r\nif (!uses_xaui(adapter)) {\r\nt3_write_reg(adapter, A_XGM_RGMII_IMP, F_CALRESET |\r\nF_CALUPDATE | V_RGMIIIMPPD(2) | V_RGMIIIMPPU(3));\r\nt3_set_reg_field(adapter, A_XGM_RGMII_IMP, F_CALRESET, 0);\r\nt3_set_reg_field(adapter, A_XGM_RGMII_IMP, 0,\r\nF_XGM_IMPSETUPDATE);\r\nt3_set_reg_field(adapter, A_XGM_RGMII_IMP, F_XGM_IMPSETUPDATE,\r\n0);\r\nt3_set_reg_field(adapter, A_XGM_RGMII_IMP, F_CALUPDATE, 0);\r\nt3_set_reg_field(adapter, A_XGM_RGMII_IMP, 0, F_CALUPDATE);\r\n}\r\n}\r\nstatic int wrreg_wait(struct adapter *adapter, unsigned int addr, u32 val)\r\n{\r\nt3_write_reg(adapter, addr, val);\r\nt3_read_reg(adapter, addr);\r\nif (!(t3_read_reg(adapter, addr) & F_BUSY))\r\nreturn 0;\r\nCH_ERR(adapter, "write to MC7 register 0x%x timed out\n", addr);\r\nreturn -EIO;\r\n}\r\nstatic int mc7_init(struct mc7 *mc7, unsigned int mc7_clock, int mem_type)\r\n{\r\nstatic const unsigned int mc7_mode[] = {\r\n0x632, 0x642, 0x652, 0x432, 0x442\r\n};\r\nstatic const struct mc7_timing_params mc7_timings[] = {\r\n{12, 3, 4, {20, 28, 34, 52, 0}, 15, 6, 4},\r\n{12, 4, 5, {20, 28, 34, 52, 0}, 16, 7, 4},\r\n{12, 5, 6, {20, 28, 34, 52, 0}, 17, 8, 4},\r\n{9, 3, 4, {15, 21, 26, 39, 0}, 12, 6, 4},\r\n{9, 4, 5, {15, 21, 26, 39, 0}, 13, 7, 4}\r\n};\r\nu32 val;\r\nunsigned int width, density, slow, attempts;\r\nstruct adapter *adapter = mc7->adapter;\r\nconst struct mc7_timing_params *p = &mc7_timings[mem_type];\r\nif (!mc7->size)\r\nreturn 0;\r\nval = t3_read_reg(adapter, mc7->offset + A_MC7_CFG);\r\nslow = val & F_SLOW;\r\nwidth = G_WIDTH(val);\r\ndensity = G_DEN(val);\r\nt3_write_reg(adapter, mc7->offset + A_MC7_CFG, val | F_IFEN);\r\nval = t3_read_reg(adapter, mc7->offset + A_MC7_CFG);\r\nmsleep(1);\r\nif (!slow) {\r\nt3_write_reg(adapter, mc7->offset + A_MC7_CAL, F_SGL_CAL_EN);\r\nt3_read_reg(adapter, mc7->offset + A_MC7_CAL);\r\nmsleep(1);\r\nif (t3_read_reg(adapter, mc7->offset + A_MC7_CAL) &\r\n(F_BUSY | F_SGL_CAL_EN | F_CAL_FAULT)) {\r\nCH_ERR(adapter, "%s MC7 calibration timed out\n",\r\nmc7->name);\r\ngoto out_fail;\r\n}\r\n}\r\nt3_write_reg(adapter, mc7->offset + A_MC7_PARM,\r\nV_ACTTOPREDLY(p->ActToPreDly) |\r\nV_ACTTORDWRDLY(p->ActToRdWrDly) | V_PRECYC(p->PreCyc) |\r\nV_REFCYC(p->RefCyc[density]) | V_BKCYC(p->BkCyc) |\r\nV_WRTORDDLY(p->WrToRdDly) | V_RDTOWRDLY(p->RdToWrDly));\r\nt3_write_reg(adapter, mc7->offset + A_MC7_CFG,\r\nval | F_CLKEN | F_TERM150);\r\nt3_read_reg(adapter, mc7->offset + A_MC7_CFG);\r\nif (!slow)\r\nt3_set_reg_field(adapter, mc7->offset + A_MC7_DLL, F_DLLENB,\r\nF_DLLENB);\r\nudelay(1);\r\nval = slow ? 3 : 6;\r\nif (wrreg_wait(adapter, mc7->offset + A_MC7_PRE, 0) ||\r\nwrreg_wait(adapter, mc7->offset + A_MC7_EXT_MODE2, 0) ||\r\nwrreg_wait(adapter, mc7->offset + A_MC7_EXT_MODE3, 0) ||\r\nwrreg_wait(adapter, mc7->offset + A_MC7_EXT_MODE1, val))\r\ngoto out_fail;\r\nif (!slow) {\r\nt3_write_reg(adapter, mc7->offset + A_MC7_MODE, 0x100);\r\nt3_set_reg_field(adapter, mc7->offset + A_MC7_DLL, F_DLLRST, 0);\r\nudelay(5);\r\n}\r\nif (wrreg_wait(adapter, mc7->offset + A_MC7_PRE, 0) ||\r\nwrreg_wait(adapter, mc7->offset + A_MC7_REF, 0) ||\r\nwrreg_wait(adapter, mc7->offset + A_MC7_REF, 0) ||\r\nwrreg_wait(adapter, mc7->offset + A_MC7_MODE,\r\nmc7_mode[mem_type]) ||\r\nwrreg_wait(adapter, mc7->offset + A_MC7_EXT_MODE1, val | 0x380) ||\r\nwrreg_wait(adapter, mc7->offset + A_MC7_EXT_MODE1, val))\r\ngoto out_fail;\r\nmc7_clock = mc7_clock * 7812 + mc7_clock / 2;\r\nmc7_clock /= 1000000;\r\nt3_write_reg(adapter, mc7->offset + A_MC7_REF,\r\nF_PERREFEN | V_PREREFDIV(mc7_clock));\r\nt3_read_reg(adapter, mc7->offset + A_MC7_REF);\r\nt3_write_reg(adapter, mc7->offset + A_MC7_ECC, F_ECCGENEN | F_ECCCHKEN);\r\nt3_write_reg(adapter, mc7->offset + A_MC7_BIST_DATA, 0);\r\nt3_write_reg(adapter, mc7->offset + A_MC7_BIST_ADDR_BEG, 0);\r\nt3_write_reg(adapter, mc7->offset + A_MC7_BIST_ADDR_END,\r\n(mc7->size << width) - 1);\r\nt3_write_reg(adapter, mc7->offset + A_MC7_BIST_OP, V_OP(1));\r\nt3_read_reg(adapter, mc7->offset + A_MC7_BIST_OP);\r\nattempts = 50;\r\ndo {\r\nmsleep(250);\r\nval = t3_read_reg(adapter, mc7->offset + A_MC7_BIST_OP);\r\n} while ((val & F_BUSY) && --attempts);\r\nif (val & F_BUSY) {\r\nCH_ERR(adapter, "%s MC7 BIST timed out\n", mc7->name);\r\ngoto out_fail;\r\n}\r\nt3_set_reg_field(adapter, mc7->offset + A_MC7_CFG, 0, F_RDY);\r\nreturn 0;\r\nout_fail:\r\nreturn -1;\r\n}\r\nstatic void config_pcie(struct adapter *adap)\r\n{\r\nstatic const u16 ack_lat[4][6] = {\r\n{237, 416, 559, 1071, 2095, 4143},\r\n{128, 217, 289, 545, 1057, 2081},\r\n{73, 118, 154, 282, 538, 1050},\r\n{67, 107, 86, 150, 278, 534}\r\n};\r\nstatic const u16 rpl_tmr[4][6] = {\r\n{711, 1248, 1677, 3213, 6285, 12429},\r\n{384, 651, 867, 1635, 3171, 6243},\r\n{219, 354, 462, 846, 1614, 3150},\r\n{201, 321, 258, 450, 834, 1602}\r\n};\r\nu16 val, devid;\r\nunsigned int log2_width, pldsize;\r\nunsigned int fst_trn_rx, fst_trn_tx, acklat, rpllmt;\r\npcie_capability_read_word(adap->pdev, PCI_EXP_DEVCTL, &val);\r\npldsize = (val & PCI_EXP_DEVCTL_PAYLOAD) >> 5;\r\npci_read_config_word(adap->pdev, 0x2, &devid);\r\nif (devid == 0x37) {\r\npcie_capability_write_word(adap->pdev, PCI_EXP_DEVCTL,\r\nval & ~PCI_EXP_DEVCTL_READRQ &\r\n~PCI_EXP_DEVCTL_PAYLOAD);\r\npldsize = 0;\r\n}\r\npcie_capability_read_word(adap->pdev, PCI_EXP_LNKCTL, &val);\r\nfst_trn_tx = G_NUMFSTTRNSEQ(t3_read_reg(adap, A_PCIE_PEX_CTRL0));\r\nfst_trn_rx = adap->params.rev == 0 ? fst_trn_tx :\r\nG_NUMFSTTRNSEQRX(t3_read_reg(adap, A_PCIE_MODE));\r\nlog2_width = fls(adap->params.pci.width) - 1;\r\nacklat = ack_lat[log2_width][pldsize];\r\nif (val & PCI_EXP_LNKCTL_ASPM_L0S)\r\nacklat += fst_trn_tx * 4;\r\nrpllmt = rpl_tmr[log2_width][pldsize] + fst_trn_rx * 4;\r\nif (adap->params.rev == 0)\r\nt3_set_reg_field(adap, A_PCIE_PEX_CTRL1,\r\nV_T3A_ACKLAT(M_T3A_ACKLAT),\r\nV_T3A_ACKLAT(acklat));\r\nelse\r\nt3_set_reg_field(adap, A_PCIE_PEX_CTRL1, V_ACKLAT(M_ACKLAT),\r\nV_ACKLAT(acklat));\r\nt3_set_reg_field(adap, A_PCIE_PEX_CTRL0, V_REPLAYLMT(M_REPLAYLMT),\r\nV_REPLAYLMT(rpllmt));\r\nt3_write_reg(adap, A_PCIE_PEX_ERR, 0xffffffff);\r\nt3_set_reg_field(adap, A_PCIE_CFG, 0,\r\nF_ENABLELINKDWNDRST | F_ENABLELINKDOWNRST |\r\nF_PCIE_DMASTOPEN | F_PCIE_CLIDECEN);\r\n}\r\nint t3_init_hw(struct adapter *adapter, u32 fw_params)\r\n{\r\nint err = -EIO, attempts, i;\r\nconst struct vpd_params *vpd = &adapter->params.vpd;\r\nif (adapter->params.rev > 0)\r\ncalibrate_xgm_t3b(adapter);\r\nelse if (calibrate_xgm(adapter))\r\ngoto out_err;\r\nif (vpd->mclk) {\r\npartition_mem(adapter, &adapter->params.tp);\r\nif (mc7_init(&adapter->pmrx, vpd->mclk, vpd->mem_timing) ||\r\nmc7_init(&adapter->pmtx, vpd->mclk, vpd->mem_timing) ||\r\nmc7_init(&adapter->cm, vpd->mclk, vpd->mem_timing) ||\r\nt3_mc5_init(&adapter->mc5, adapter->params.mc5.nservers,\r\nadapter->params.mc5.nfilters,\r\nadapter->params.mc5.nroutes))\r\ngoto out_err;\r\nfor (i = 0; i < 32; i++)\r\nif (clear_sge_ctxt(adapter, i, F_CQ))\r\ngoto out_err;\r\n}\r\nif (tp_init(adapter, &adapter->params.tp))\r\ngoto out_err;\r\nt3_tp_set_coalescing_size(adapter,\r\nmin(adapter->params.sge.max_pkt_size,\r\nMAX_RX_COALESCING_LEN), 1);\r\nt3_tp_set_max_rxsize(adapter,\r\nmin(adapter->params.sge.max_pkt_size, 16384U));\r\nulp_config(adapter, &adapter->params.tp);\r\nif (is_pcie(adapter))\r\nconfig_pcie(adapter);\r\nelse\r\nt3_set_reg_field(adapter, A_PCIX_CFG, 0,\r\nF_DMASTOPEN | F_CLIDECEN);\r\nif (adapter->params.rev == T3_REV_C)\r\nt3_set_reg_field(adapter, A_ULPTX_CONFIG, 0,\r\nF_CFG_CQE_SOP_MASK);\r\nt3_write_reg(adapter, A_PM1_RX_CFG, 0xffffffff);\r\nt3_write_reg(adapter, A_PM1_RX_MODE, 0);\r\nt3_write_reg(adapter, A_PM1_TX_MODE, 0);\r\nchan_init_hw(adapter, adapter->params.chan_map);\r\nt3_sge_init(adapter, &adapter->params.sge);\r\nt3_set_reg_field(adapter, A_PL_RST, 0, F_FATALPERREN);\r\nt3_write_reg(adapter, A_T3DBG_GPIO_ACT_LOW, calc_gpio_intr(adapter));\r\nt3_write_reg(adapter, A_CIM_HOST_ACC_DATA, vpd->uclk | fw_params);\r\nt3_write_reg(adapter, A_CIM_BOOT_CFG,\r\nV_BOOTADDR(FW_FLASH_BOOT_ADDR >> 2));\r\nt3_read_reg(adapter, A_CIM_BOOT_CFG);\r\nattempts = 100;\r\ndo {\r\nmsleep(20);\r\n} while (t3_read_reg(adapter, A_CIM_HOST_ACC_DATA) && --attempts);\r\nif (!attempts) {\r\nCH_ERR(adapter, "uP initialization timed out\n");\r\ngoto out_err;\r\n}\r\nerr = 0;\r\nout_err:\r\nreturn err;\r\n}\r\nstatic void get_pci_mode(struct adapter *adapter, struct pci_params *p)\r\n{\r\nstatic unsigned short speed_map[] = { 33, 66, 100, 133 };\r\nu32 pci_mode;\r\nif (pci_is_pcie(adapter->pdev)) {\r\nu16 val;\r\np->variant = PCI_VARIANT_PCIE;\r\npcie_capability_read_word(adapter->pdev, PCI_EXP_LNKSTA, &val);\r\np->width = (val >> 4) & 0x3f;\r\nreturn;\r\n}\r\npci_mode = t3_read_reg(adapter, A_PCIX_MODE);\r\np->speed = speed_map[G_PCLKRANGE(pci_mode)];\r\np->width = (pci_mode & F_64BIT) ? 64 : 32;\r\npci_mode = G_PCIXINITPAT(pci_mode);\r\nif (pci_mode == 0)\r\np->variant = PCI_VARIANT_PCI;\r\nelse if (pci_mode < 4)\r\np->variant = PCI_VARIANT_PCIX_MODE1_PARITY;\r\nelse if (pci_mode < 8)\r\np->variant = PCI_VARIANT_PCIX_MODE1_ECC;\r\nelse\r\np->variant = PCI_VARIANT_PCIX_266_MODE2;\r\n}\r\nstatic void init_link_config(struct link_config *lc, unsigned int caps)\r\n{\r\nlc->supported = caps;\r\nlc->requested_speed = lc->speed = SPEED_INVALID;\r\nlc->requested_duplex = lc->duplex = DUPLEX_INVALID;\r\nlc->requested_fc = lc->fc = PAUSE_RX | PAUSE_TX;\r\nif (lc->supported & SUPPORTED_Autoneg) {\r\nlc->advertising = lc->supported;\r\nlc->autoneg = AUTONEG_ENABLE;\r\nlc->requested_fc |= PAUSE_AUTONEG;\r\n} else {\r\nlc->advertising = 0;\r\nlc->autoneg = AUTONEG_DISABLE;\r\n}\r\n}\r\nstatic unsigned int mc7_calc_size(u32 cfg)\r\n{\r\nunsigned int width = G_WIDTH(cfg);\r\nunsigned int banks = !!(cfg & F_BKS) + 1;\r\nunsigned int org = !!(cfg & F_ORG) + 1;\r\nunsigned int density = G_DEN(cfg);\r\nunsigned int MBs = ((256 << density) * banks) / (org << width);\r\nreturn MBs << 20;\r\n}\r\nstatic void mc7_prep(struct adapter *adapter, struct mc7 *mc7,\r\nunsigned int base_addr, const char *name)\r\n{\r\nu32 cfg;\r\nmc7->adapter = adapter;\r\nmc7->name = name;\r\nmc7->offset = base_addr - MC7_PMRX_BASE_ADDR;\r\ncfg = t3_read_reg(adapter, mc7->offset + A_MC7_CFG);\r\nmc7->size = G_DEN(cfg) == M_DEN ? 0 : mc7_calc_size(cfg);\r\nmc7->width = G_WIDTH(cfg);\r\n}\r\nstatic void mac_prep(struct cmac *mac, struct adapter *adapter, int index)\r\n{\r\nu16 devid;\r\nmac->adapter = adapter;\r\npci_read_config_word(adapter->pdev, 0x2, &devid);\r\nif (devid == 0x37 && !adapter->params.vpd.xauicfg[1])\r\nindex = 0;\r\nmac->offset = (XGMAC0_1_BASE_ADDR - XGMAC0_0_BASE_ADDR) * index;\r\nmac->nucast = 1;\r\nif (adapter->params.rev == 0 && uses_xaui(adapter)) {\r\nt3_write_reg(adapter, A_XGM_SERDES_CTRL + mac->offset,\r\nis_10G(adapter) ? 0x2901c04 : 0x2301c04);\r\nt3_set_reg_field(adapter, A_XGM_PORT_CFG + mac->offset,\r\nF_ENRGMII, 0);\r\n}\r\n}\r\nstatic void early_hw_init(struct adapter *adapter,\r\nconst struct adapter_info *ai)\r\n{\r\nu32 val = V_PORTSPEED(is_10G(adapter) ? 3 : 2);\r\nmi1_init(adapter, ai);\r\nt3_write_reg(adapter, A_I2C_CFG,\r\nV_I2C_CLKDIV(adapter->params.vpd.cclk / 80 - 1));\r\nt3_write_reg(adapter, A_T3DBG_GPIO_EN,\r\nai->gpio_out | F_GPIO0_OEN | F_GPIO0_OUT_VAL);\r\nt3_write_reg(adapter, A_MC5_DB_SERVER_INDEX, 0);\r\nt3_write_reg(adapter, A_SG_OCO_BASE, V_BASE1(0xfff));\r\nif (adapter->params.rev == 0 || !uses_xaui(adapter))\r\nval |= F_ENRGMII;\r\nt3_write_reg(adapter, A_XGM_PORT_CFG, val);\r\nt3_read_reg(adapter, A_XGM_PORT_CFG);\r\nval |= F_CLKDIVRESET_;\r\nt3_write_reg(adapter, A_XGM_PORT_CFG, val);\r\nt3_read_reg(adapter, A_XGM_PORT_CFG);\r\nt3_write_reg(adapter, XGM_REG(A_XGM_PORT_CFG, 1), val);\r\nt3_read_reg(adapter, A_XGM_PORT_CFG);\r\n}\r\nint t3_reset_adapter(struct adapter *adapter)\r\n{\r\nint i, save_and_restore_pcie =\r\nadapter->params.rev < T3_REV_B2 && is_pcie(adapter);\r\nuint16_t devid = 0;\r\nif (save_and_restore_pcie)\r\npci_save_state(adapter->pdev);\r\nt3_write_reg(adapter, A_PL_RST, F_CRSTWRM | F_CRSTWRMMODE);\r\nfor (i = 0; i < 10; i++) {\r\nmsleep(50);\r\npci_read_config_word(adapter->pdev, 0x00, &devid);\r\nif (devid == 0x1425)\r\nbreak;\r\n}\r\nif (devid != 0x1425)\r\nreturn -1;\r\nif (save_and_restore_pcie)\r\npci_restore_state(adapter->pdev);\r\nreturn 0;\r\n}\r\nstatic int init_parity(struct adapter *adap)\r\n{\r\nint i, err, addr;\r\nif (t3_read_reg(adap, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\r\nreturn -EBUSY;\r\nfor (err = i = 0; !err && i < 16; i++)\r\nerr = clear_sge_ctxt(adap, i, F_EGRESS);\r\nfor (i = 0xfff0; !err && i <= 0xffff; i++)\r\nerr = clear_sge_ctxt(adap, i, F_EGRESS);\r\nfor (i = 0; !err && i < SGE_QSETS; i++)\r\nerr = clear_sge_ctxt(adap, i, F_RESPONSEQ);\r\nif (err)\r\nreturn err;\r\nt3_write_reg(adap, A_CIM_IBQ_DBG_DATA, 0);\r\nfor (i = 0; i < 4; i++)\r\nfor (addr = 0; addr <= M_IBQDBGADDR; addr++) {\r\nt3_write_reg(adap, A_CIM_IBQ_DBG_CFG, F_IBQDBGEN |\r\nF_IBQDBGWR | V_IBQDBGQID(i) |\r\nV_IBQDBGADDR(addr));\r\nerr = t3_wait_op_done(adap, A_CIM_IBQ_DBG_CFG,\r\nF_IBQDBGBUSY, 0, 2, 1);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint t3_prep_adapter(struct adapter *adapter, const struct adapter_info *ai,\r\nint reset)\r\n{\r\nint ret;\r\nunsigned int i, j = -1;\r\nget_pci_mode(adapter, &adapter->params.pci);\r\nadapter->params.info = ai;\r\nadapter->params.nports = ai->nports0 + ai->nports1;\r\nadapter->params.chan_map = (!!ai->nports0) | (!!ai->nports1 << 1);\r\nadapter->params.rev = t3_read_reg(adapter, A_PL_REV);\r\nadapter->params.linkpoll_period = 10;\r\nadapter->params.stats_update_period = is_10G(adapter) ?\r\nMAC_STATS_ACCUM_SECS : (MAC_STATS_ACCUM_SECS * 10);\r\nadapter->params.pci.vpd_cap_addr =\r\npci_find_capability(adapter->pdev, PCI_CAP_ID_VPD);\r\nret = get_vpd_params(adapter, &adapter->params.vpd);\r\nif (ret < 0)\r\nreturn ret;\r\nif (reset && t3_reset_adapter(adapter))\r\nreturn -1;\r\nt3_sge_prep(adapter, &adapter->params.sge);\r\nif (adapter->params.vpd.mclk) {\r\nstruct tp_params *p = &adapter->params.tp;\r\nmc7_prep(adapter, &adapter->pmrx, MC7_PMRX_BASE_ADDR, "PMRX");\r\nmc7_prep(adapter, &adapter->pmtx, MC7_PMTX_BASE_ADDR, "PMTX");\r\nmc7_prep(adapter, &adapter->cm, MC7_CM_BASE_ADDR, "CM");\r\np->nchan = adapter->params.chan_map == 3 ? 2 : 1;\r\np->pmrx_size = t3_mc7_size(&adapter->pmrx);\r\np->pmtx_size = t3_mc7_size(&adapter->pmtx);\r\np->cm_size = t3_mc7_size(&adapter->cm);\r\np->chan_rx_size = p->pmrx_size / 2;\r\np->chan_tx_size = p->pmtx_size / p->nchan;\r\np->rx_pg_size = 64 * 1024;\r\np->tx_pg_size = is_10G(adapter) ? 64 * 1024 : 16 * 1024;\r\np->rx_num_pgs = pm_num_pages(p->chan_rx_size, p->rx_pg_size);\r\np->tx_num_pgs = pm_num_pages(p->chan_tx_size, p->tx_pg_size);\r\np->ntimer_qs = p->cm_size >= (128 << 20) ||\r\nadapter->params.rev > 0 ? 12 : 6;\r\n}\r\nadapter->params.offload = t3_mc7_size(&adapter->pmrx) &&\r\nt3_mc7_size(&adapter->pmtx) &&\r\nt3_mc7_size(&adapter->cm);\r\nif (is_offload(adapter)) {\r\nadapter->params.mc5.nservers = DEFAULT_NSERVERS;\r\nadapter->params.mc5.nfilters = adapter->params.rev > 0 ?\r\nDEFAULT_NFILTERS : 0;\r\nadapter->params.mc5.nroutes = 0;\r\nt3_mc5_prep(adapter, &adapter->mc5, MC5_MODE_144_BIT);\r\ninit_mtus(adapter->params.mtus);\r\ninit_cong_ctrl(adapter->params.a_wnd, adapter->params.b_wnd);\r\n}\r\nearly_hw_init(adapter, ai);\r\nret = init_parity(adapter);\r\nif (ret)\r\nreturn ret;\r\nfor_each_port(adapter, i) {\r\nu8 hw_addr[6];\r\nconst struct port_type_info *pti;\r\nstruct port_info *p = adap2pinfo(adapter, i);\r\nwhile (!adapter->params.vpd.port_type[++j])\r\n;\r\npti = &port_types[adapter->params.vpd.port_type[j]];\r\nif (!pti->phy_prep) {\r\nCH_ALERT(adapter, "Invalid port type index %d\n",\r\nadapter->params.vpd.port_type[j]);\r\nreturn -EINVAL;\r\n}\r\np->phy.mdio.dev = adapter->port[i];\r\nret = pti->phy_prep(&p->phy, adapter, ai->phy_base_addr + j,\r\nai->mdio_ops);\r\nif (ret)\r\nreturn ret;\r\nmac_prep(&p->mac, adapter, j);\r\nmemcpy(hw_addr, adapter->params.vpd.eth_base, 5);\r\nhw_addr[5] = adapter->params.vpd.eth_base[5] + i;\r\nmemcpy(adapter->port[i]->dev_addr, hw_addr,\r\nETH_ALEN);\r\ninit_link_config(&p->link_config, p->phy.caps);\r\np->phy.ops->power_down(&p->phy, 1);\r\nif (!(p->phy.caps & SUPPORTED_IRQ) &&\r\nadapter->params.linkpoll_period > 10)\r\nadapter->params.linkpoll_period = 10;\r\n}\r\nreturn 0;\r\n}\r\nvoid t3_led_ready(struct adapter *adapter)\r\n{\r\nt3_set_reg_field(adapter, A_T3DBG_GPIO_EN, F_GPIO0_OUT_VAL,\r\nF_GPIO0_OUT_VAL);\r\n}\r\nint t3_replay_prep_adapter(struct adapter *adapter)\r\n{\r\nconst struct adapter_info *ai = adapter->params.info;\r\nunsigned int i, j = -1;\r\nint ret;\r\nearly_hw_init(adapter, ai);\r\nret = init_parity(adapter);\r\nif (ret)\r\nreturn ret;\r\nfor_each_port(adapter, i) {\r\nconst struct port_type_info *pti;\r\nstruct port_info *p = adap2pinfo(adapter, i);\r\nwhile (!adapter->params.vpd.port_type[++j])\r\n;\r\npti = &port_types[adapter->params.vpd.port_type[j]];\r\nret = pti->phy_prep(&p->phy, adapter, p->phy.mdio.prtad, NULL);\r\nif (ret)\r\nreturn ret;\r\np->phy.ops->power_down(&p->phy, 1);\r\n}\r\nreturn 0;\r\n}
