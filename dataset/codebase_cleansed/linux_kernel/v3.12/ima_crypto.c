int ima_init_crypto(void)\r\n{\r\nlong rc;\r\nima_shash_tfm = crypto_alloc_shash(ima_hash, 0, 0);\r\nif (IS_ERR(ima_shash_tfm)) {\r\nrc = PTR_ERR(ima_shash_tfm);\r\npr_err("Can not allocate %s (reason: %ld)\n", ima_hash, rc);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nint ima_calc_file_hash(struct file *file, char *digest)\r\n{\r\nloff_t i_size, offset = 0;\r\nchar *rbuf;\r\nint rc, read = 0;\r\nstruct {\r\nstruct shash_desc shash;\r\nchar ctx[crypto_shash_descsize(ima_shash_tfm)];\r\n} desc;\r\ndesc.shash.tfm = ima_shash_tfm;\r\ndesc.shash.flags = 0;\r\nrc = crypto_shash_init(&desc.shash);\r\nif (rc != 0)\r\nreturn rc;\r\nrbuf = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!rbuf) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nif (!(file->f_mode & FMODE_READ)) {\r\nfile->f_mode |= FMODE_READ;\r\nread = 1;\r\n}\r\ni_size = i_size_read(file_inode(file));\r\nwhile (offset < i_size) {\r\nint rbuf_len;\r\nrbuf_len = kernel_read(file, offset, rbuf, PAGE_SIZE);\r\nif (rbuf_len < 0) {\r\nrc = rbuf_len;\r\nbreak;\r\n}\r\nif (rbuf_len == 0)\r\nbreak;\r\noffset += rbuf_len;\r\nrc = crypto_shash_update(&desc.shash, rbuf, rbuf_len);\r\nif (rc)\r\nbreak;\r\n}\r\nkfree(rbuf);\r\nif (!rc)\r\nrc = crypto_shash_final(&desc.shash, digest);\r\nif (read)\r\nfile->f_mode &= ~FMODE_READ;\r\nout:\r\nreturn rc;\r\n}\r\nint ima_calc_buffer_hash(const void *data, int len, char *digest)\r\n{\r\nstruct {\r\nstruct shash_desc shash;\r\nchar ctx[crypto_shash_descsize(ima_shash_tfm)];\r\n} desc;\r\ndesc.shash.tfm = ima_shash_tfm;\r\ndesc.shash.flags = 0;\r\nreturn crypto_shash_digest(&desc.shash, data, len, digest);\r\n}\r\nstatic void __init ima_pcrread(int idx, u8 *pcr)\r\n{\r\nif (!ima_used_chip)\r\nreturn;\r\nif (tpm_pcr_read(TPM_ANY_NUM, idx, pcr) != 0)\r\npr_err("IMA: Error Communicating to TPM chip\n");\r\n}\r\nint __init ima_calc_boot_aggregate(char *digest)\r\n{\r\nu8 pcr_i[IMA_DIGEST_SIZE];\r\nint rc, i;\r\nstruct {\r\nstruct shash_desc shash;\r\nchar ctx[crypto_shash_descsize(ima_shash_tfm)];\r\n} desc;\r\ndesc.shash.tfm = ima_shash_tfm;\r\ndesc.shash.flags = 0;\r\nrc = crypto_shash_init(&desc.shash);\r\nif (rc != 0)\r\nreturn rc;\r\nfor (i = TPM_PCR0; i < TPM_PCR8; i++) {\r\nima_pcrread(i, pcr_i);\r\nrc = crypto_shash_update(&desc.shash, pcr_i, IMA_DIGEST_SIZE);\r\n}\r\nif (!rc)\r\ncrypto_shash_final(&desc.shash, digest);\r\nreturn rc;\r\n}
