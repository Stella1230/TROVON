static void cvmx_bootmem_phy_set_size(uint64_t addr, uint64_t size)\r\n{\r\ncvmx_write64_uint64((addr + SIZE_OFFSET) | (1ull << 63), size);\r\n}\r\nstatic void cvmx_bootmem_phy_set_next(uint64_t addr, uint64_t next)\r\n{\r\ncvmx_write64_uint64((addr + NEXT_OFFSET) | (1ull << 63), next);\r\n}\r\nstatic uint64_t cvmx_bootmem_phy_get_size(uint64_t addr)\r\n{\r\nreturn cvmx_read64_uint64((addr + SIZE_OFFSET) | (1ull << 63));\r\n}\r\nstatic uint64_t cvmx_bootmem_phy_get_next(uint64_t addr)\r\n{\r\nreturn cvmx_read64_uint64((addr + NEXT_OFFSET) | (1ull << 63));\r\n}\r\nvoid *cvmx_bootmem_alloc_range(uint64_t size, uint64_t alignment,\r\nuint64_t min_addr, uint64_t max_addr)\r\n{\r\nint64_t address;\r\naddress =\r\ncvmx_bootmem_phy_alloc(size, min_addr, max_addr, alignment, 0);\r\nif (address > 0)\r\nreturn cvmx_phys_to_ptr(address);\r\nelse\r\nreturn NULL;\r\n}\r\nvoid *cvmx_bootmem_alloc_address(uint64_t size, uint64_t address,\r\nuint64_t alignment)\r\n{\r\nreturn cvmx_bootmem_alloc_range(size, alignment, address,\r\naddress + size);\r\n}\r\nvoid *cvmx_bootmem_alloc(uint64_t size, uint64_t alignment)\r\n{\r\nreturn cvmx_bootmem_alloc_range(size, alignment, 0, 0);\r\n}\r\nvoid *cvmx_bootmem_alloc_named_range(uint64_t size, uint64_t min_addr,\r\nuint64_t max_addr, uint64_t align,\r\nchar *name)\r\n{\r\nint64_t addr;\r\naddr = cvmx_bootmem_phy_named_block_alloc(size, min_addr, max_addr,\r\nalign, name, 0);\r\nif (addr >= 0)\r\nreturn cvmx_phys_to_ptr(addr);\r\nelse\r\nreturn NULL;\r\n}\r\nvoid *cvmx_bootmem_alloc_named_address(uint64_t size, uint64_t address,\r\nchar *name)\r\n{\r\nreturn cvmx_bootmem_alloc_named_range(size, address, address + size,\r\n0, name);\r\n}\r\nvoid *cvmx_bootmem_alloc_named(uint64_t size, uint64_t alignment, char *name)\r\n{\r\nreturn cvmx_bootmem_alloc_named_range(size, 0, 0, alignment, name);\r\n}\r\nint cvmx_bootmem_free_named(char *name)\r\n{\r\nreturn cvmx_bootmem_phy_named_block_free(name, 0);\r\n}\r\nstruct cvmx_bootmem_named_block_desc *cvmx_bootmem_find_named_block(char *name)\r\n{\r\nreturn cvmx_bootmem_phy_named_block_find(name, 0);\r\n}\r\nvoid cvmx_bootmem_lock(void)\r\n{\r\ncvmx_spinlock_lock((cvmx_spinlock_t *) &(cvmx_bootmem_desc->lock));\r\n}\r\nvoid cvmx_bootmem_unlock(void)\r\n{\r\ncvmx_spinlock_unlock((cvmx_spinlock_t *) &(cvmx_bootmem_desc->lock));\r\n}\r\nint cvmx_bootmem_init(void *mem_desc_ptr)\r\n{\r\nif (!cvmx_bootmem_desc) {\r\n#if defined(CVMX_ABI_64)\r\ncvmx_bootmem_desc = cvmx_phys_to_ptr(CAST64(mem_desc_ptr));\r\n#else\r\ncvmx_bootmem_desc = (struct cvmx_bootmem_desc *) mem_desc_ptr;\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nint64_t cvmx_bootmem_phy_alloc(uint64_t req_size, uint64_t address_min,\r\nuint64_t address_max, uint64_t alignment,\r\nuint32_t flags)\r\n{\r\nuint64_t head_addr;\r\nuint64_t ent_addr;\r\nuint64_t prev_addr = 0;\r\nuint64_t new_ent_addr = 0;\r\nuint64_t desired_min_addr;\r\n#ifdef DEBUG\r\ncvmx_dprintf("cvmx_bootmem_phy_alloc: req_size: 0x%llx, "\r\n"min_addr: 0x%llx, max_addr: 0x%llx, align: 0x%llx\n",\r\n(unsigned long long)req_size,\r\n(unsigned long long)address_min,\r\n(unsigned long long)address_max,\r\n(unsigned long long)alignment);\r\n#endif\r\nif (cvmx_bootmem_desc->major_version > 3) {\r\ncvmx_dprintf("ERROR: Incompatible bootmem descriptor "\r\n"version: %d.%d at addr: %p\n",\r\n(int)cvmx_bootmem_desc->major_version,\r\n(int)cvmx_bootmem_desc->minor_version,\r\ncvmx_bootmem_desc);\r\ngoto error_out;\r\n}\r\nif (!req_size)\r\ngoto error_out;\r\nreq_size = (req_size + (CVMX_BOOTMEM_ALIGNMENT_SIZE - 1)) &\r\n~(CVMX_BOOTMEM_ALIGNMENT_SIZE - 1);\r\nif (address_min && !address_max)\r\naddress_max = address_min + req_size;\r\nelse if (!address_min && !address_max)\r\naddress_max = ~0ull;\r\nif (alignment < CVMX_BOOTMEM_ALIGNMENT_SIZE)\r\nalignment = CVMX_BOOTMEM_ALIGNMENT_SIZE;\r\nif (alignment)\r\naddress_min = ALIGN(address_min, alignment);\r\nif (req_size > address_max - address_min)\r\ngoto error_out;\r\nif (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))\r\ncvmx_bootmem_lock();\r\nhead_addr = cvmx_bootmem_desc->head_addr;\r\nent_addr = head_addr;\r\nfor (; ent_addr;\r\nprev_addr = ent_addr,\r\nent_addr = cvmx_bootmem_phy_get_next(ent_addr)) {\r\nuint64_t usable_base, usable_max;\r\nuint64_t ent_size = cvmx_bootmem_phy_get_size(ent_addr);\r\nif (cvmx_bootmem_phy_get_next(ent_addr)\r\n&& ent_addr > cvmx_bootmem_phy_get_next(ent_addr)) {\r\ncvmx_dprintf("Internal bootmem_alloc() error: ent: "\r\n"0x%llx, next: 0x%llx\n",\r\n(unsigned long long)ent_addr,\r\n(unsigned long long)\r\ncvmx_bootmem_phy_get_next(ent_addr));\r\ngoto error_out;\r\n}\r\nusable_base =\r\nALIGN(max(address_min, ent_addr), alignment);\r\nusable_max = min(address_max, ent_addr + ent_size);\r\ndesired_min_addr = usable_base;\r\nif (!((ent_addr + ent_size) > usable_base\r\n&& ent_addr < address_max\r\n&& req_size <= usable_max - usable_base))\r\ncontinue;\r\nif (flags & CVMX_BOOTMEM_FLAG_END_ALLOC) {\r\ndesired_min_addr = usable_max - req_size;\r\ndesired_min_addr &= ~(alignment - 1);\r\n}\r\nif (desired_min_addr == ent_addr) {\r\nif (req_size < ent_size) {\r\nnew_ent_addr = ent_addr + req_size;\r\ncvmx_bootmem_phy_set_next(new_ent_addr,\r\ncvmx_bootmem_phy_get_next(ent_addr));\r\ncvmx_bootmem_phy_set_size(new_ent_addr,\r\nent_size -\r\nreq_size);\r\ncvmx_bootmem_phy_set_next(ent_addr,\r\nnew_ent_addr);\r\n}\r\nif (prev_addr)\r\ncvmx_bootmem_phy_set_next(prev_addr,\r\ncvmx_bootmem_phy_get_next(ent_addr));\r\nelse\r\ncvmx_bootmem_desc->head_addr =\r\ncvmx_bootmem_phy_get_next(ent_addr);\r\nif (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))\r\ncvmx_bootmem_unlock();\r\nreturn desired_min_addr;\r\n}\r\nnew_ent_addr = desired_min_addr;\r\ncvmx_bootmem_phy_set_next(new_ent_addr,\r\ncvmx_bootmem_phy_get_next\r\n(ent_addr));\r\ncvmx_bootmem_phy_set_size(new_ent_addr,\r\ncvmx_bootmem_phy_get_size\r\n(ent_addr) -\r\n(desired_min_addr -\r\nent_addr));\r\ncvmx_bootmem_phy_set_size(ent_addr,\r\ndesired_min_addr - ent_addr);\r\ncvmx_bootmem_phy_set_next(ent_addr, new_ent_addr);\r\n}\r\nerror_out:\r\nif (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))\r\ncvmx_bootmem_unlock();\r\nreturn -1;\r\n}\r\nint __cvmx_bootmem_phy_free(uint64_t phy_addr, uint64_t size, uint32_t flags)\r\n{\r\nuint64_t cur_addr;\r\nuint64_t prev_addr = 0;\r\nint retval = 0;\r\n#ifdef DEBUG\r\ncvmx_dprintf("__cvmx_bootmem_phy_free addr: 0x%llx, size: 0x%llx\n",\r\n(unsigned long long)phy_addr, (unsigned long long)size);\r\n#endif\r\nif (cvmx_bootmem_desc->major_version > 3) {\r\ncvmx_dprintf("ERROR: Incompatible bootmem descriptor "\r\n"version: %d.%d at addr: %p\n",\r\n(int)cvmx_bootmem_desc->major_version,\r\n(int)cvmx_bootmem_desc->minor_version,\r\ncvmx_bootmem_desc);\r\nreturn 0;\r\n}\r\nif (!size)\r\nreturn 0;\r\nif (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))\r\ncvmx_bootmem_lock();\r\ncur_addr = cvmx_bootmem_desc->head_addr;\r\nif (cur_addr == 0 || phy_addr < cur_addr) {\r\nif (cur_addr && phy_addr + size > cur_addr)\r\ngoto bootmem_free_done;\r\nelse if (phy_addr + size == cur_addr) {\r\ncvmx_bootmem_phy_set_next(phy_addr,\r\ncvmx_bootmem_phy_get_next\r\n(cur_addr));\r\ncvmx_bootmem_phy_set_size(phy_addr,\r\ncvmx_bootmem_phy_get_size\r\n(cur_addr) + size);\r\ncvmx_bootmem_desc->head_addr = phy_addr;\r\n} else {\r\ncvmx_bootmem_phy_set_next(phy_addr, cur_addr);\r\ncvmx_bootmem_phy_set_size(phy_addr, size);\r\ncvmx_bootmem_desc->head_addr = phy_addr;\r\n}\r\nretval = 1;\r\ngoto bootmem_free_done;\r\n}\r\nwhile (cur_addr && phy_addr > cur_addr) {\r\nprev_addr = cur_addr;\r\ncur_addr = cvmx_bootmem_phy_get_next(cur_addr);\r\n}\r\nif (!cur_addr) {\r\nif (prev_addr + cvmx_bootmem_phy_get_size(prev_addr) ==\r\nphy_addr) {\r\ncvmx_bootmem_phy_set_size(prev_addr,\r\ncvmx_bootmem_phy_get_size\r\n(prev_addr) + size);\r\n} else {\r\ncvmx_bootmem_phy_set_next(prev_addr, phy_addr);\r\ncvmx_bootmem_phy_set_size(phy_addr, size);\r\ncvmx_bootmem_phy_set_next(phy_addr, 0);\r\n}\r\nretval = 1;\r\ngoto bootmem_free_done;\r\n} else {\r\nif (prev_addr + cvmx_bootmem_phy_get_size(prev_addr) ==\r\nphy_addr) {\r\ncvmx_bootmem_phy_set_size(prev_addr,\r\ncvmx_bootmem_phy_get_size\r\n(prev_addr) + size);\r\nif (phy_addr + size == cur_addr) {\r\ncvmx_bootmem_phy_set_size(prev_addr,\r\ncvmx_bootmem_phy_get_size(cur_addr) +\r\ncvmx_bootmem_phy_get_size(prev_addr));\r\ncvmx_bootmem_phy_set_next(prev_addr,\r\ncvmx_bootmem_phy_get_next(cur_addr));\r\n}\r\nretval = 1;\r\ngoto bootmem_free_done;\r\n} else if (phy_addr + size == cur_addr) {\r\ncvmx_bootmem_phy_set_size(phy_addr,\r\ncvmx_bootmem_phy_get_size\r\n(cur_addr) + size);\r\ncvmx_bootmem_phy_set_next(phy_addr,\r\ncvmx_bootmem_phy_get_next\r\n(cur_addr));\r\ncvmx_bootmem_phy_set_next(prev_addr, phy_addr);\r\nretval = 1;\r\ngoto bootmem_free_done;\r\n}\r\ncvmx_bootmem_phy_set_size(phy_addr, size);\r\ncvmx_bootmem_phy_set_next(phy_addr, cur_addr);\r\ncvmx_bootmem_phy_set_next(prev_addr, phy_addr);\r\n}\r\nretval = 1;\r\nbootmem_free_done:\r\nif (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))\r\ncvmx_bootmem_unlock();\r\nreturn retval;\r\n}\r\nstruct cvmx_bootmem_named_block_desc *\r\ncvmx_bootmem_phy_named_block_find(char *name, uint32_t flags)\r\n{\r\nunsigned int i;\r\nstruct cvmx_bootmem_named_block_desc *named_block_array_ptr;\r\n#ifdef DEBUG\r\ncvmx_dprintf("cvmx_bootmem_phy_named_block_find: %s\n", name);\r\n#endif\r\nif (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))\r\ncvmx_bootmem_lock();\r\nnamed_block_array_ptr = (struct cvmx_bootmem_named_block_desc *)\r\ncvmx_phys_to_ptr(cvmx_bootmem_desc->named_block_array_addr);\r\n#ifdef DEBUG\r\ncvmx_dprintf\r\n("cvmx_bootmem_phy_named_block_find: named_block_array_ptr: %p\n",\r\nnamed_block_array_ptr);\r\n#endif\r\nif (cvmx_bootmem_desc->major_version == 3) {\r\nfor (i = 0;\r\ni < cvmx_bootmem_desc->named_block_num_blocks; i++) {\r\nif ((name && named_block_array_ptr[i].size\r\n&& !strncmp(name, named_block_array_ptr[i].name,\r\ncvmx_bootmem_desc->named_block_name_len\r\n- 1))\r\n|| (!name && !named_block_array_ptr[i].size)) {\r\nif (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))\r\ncvmx_bootmem_unlock();\r\nreturn &(named_block_array_ptr[i]);\r\n}\r\n}\r\n} else {\r\ncvmx_dprintf("ERROR: Incompatible bootmem descriptor "\r\n"version: %d.%d at addr: %p\n",\r\n(int)cvmx_bootmem_desc->major_version,\r\n(int)cvmx_bootmem_desc->minor_version,\r\ncvmx_bootmem_desc);\r\n}\r\nif (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))\r\ncvmx_bootmem_unlock();\r\nreturn NULL;\r\n}\r\nint cvmx_bootmem_phy_named_block_free(char *name, uint32_t flags)\r\n{\r\nstruct cvmx_bootmem_named_block_desc *named_block_ptr;\r\nif (cvmx_bootmem_desc->major_version != 3) {\r\ncvmx_dprintf("ERROR: Incompatible bootmem descriptor version: "\r\n"%d.%d at addr: %p\n",\r\n(int)cvmx_bootmem_desc->major_version,\r\n(int)cvmx_bootmem_desc->minor_version,\r\ncvmx_bootmem_desc);\r\nreturn 0;\r\n}\r\n#ifdef DEBUG\r\ncvmx_dprintf("cvmx_bootmem_phy_named_block_free: %s\n", name);\r\n#endif\r\ncvmx_bootmem_lock();\r\nnamed_block_ptr =\r\ncvmx_bootmem_phy_named_block_find(name,\r\nCVMX_BOOTMEM_FLAG_NO_LOCKING);\r\nif (named_block_ptr) {\r\n#ifdef DEBUG\r\ncvmx_dprintf("cvmx_bootmem_phy_named_block_free: "\r\n"%s, base: 0x%llx, size: 0x%llx\n",\r\nname,\r\n(unsigned long long)named_block_ptr->base_addr,\r\n(unsigned long long)named_block_ptr->size);\r\n#endif\r\n__cvmx_bootmem_phy_free(named_block_ptr->base_addr,\r\nnamed_block_ptr->size,\r\nCVMX_BOOTMEM_FLAG_NO_LOCKING);\r\nnamed_block_ptr->size = 0;\r\n}\r\ncvmx_bootmem_unlock();\r\nreturn named_block_ptr != NULL;\r\n}\r\nint64_t cvmx_bootmem_phy_named_block_alloc(uint64_t size, uint64_t min_addr,\r\nuint64_t max_addr,\r\nuint64_t alignment,\r\nchar *name,\r\nuint32_t flags)\r\n{\r\nint64_t addr_allocated;\r\nstruct cvmx_bootmem_named_block_desc *named_block_desc_ptr;\r\n#ifdef DEBUG\r\ncvmx_dprintf("cvmx_bootmem_phy_named_block_alloc: size: 0x%llx, min: "\r\n"0x%llx, max: 0x%llx, align: 0x%llx, name: %s\n",\r\n(unsigned long long)size,\r\n(unsigned long long)min_addr,\r\n(unsigned long long)max_addr,\r\n(unsigned long long)alignment,\r\nname);\r\n#endif\r\nif (cvmx_bootmem_desc->major_version != 3) {\r\ncvmx_dprintf("ERROR: Incompatible bootmem descriptor version: "\r\n"%d.%d at addr: %p\n",\r\n(int)cvmx_bootmem_desc->major_version,\r\n(int)cvmx_bootmem_desc->minor_version,\r\ncvmx_bootmem_desc);\r\nreturn -1;\r\n}\r\nif (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))\r\ncvmx_spinlock_lock((cvmx_spinlock_t *)&(cvmx_bootmem_desc->lock));\r\nnamed_block_desc_ptr =\r\ncvmx_bootmem_phy_named_block_find(NULL,\r\nflags | CVMX_BOOTMEM_FLAG_NO_LOCKING);\r\nif (cvmx_bootmem_phy_named_block_find(name,\r\nflags | CVMX_BOOTMEM_FLAG_NO_LOCKING) || !named_block_desc_ptr) {\r\nif (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))\r\ncvmx_spinlock_unlock((cvmx_spinlock_t *)&(cvmx_bootmem_desc->lock));\r\nreturn -1;\r\n}\r\nsize = ALIGN(size, CVMX_BOOTMEM_ALIGNMENT_SIZE);\r\naddr_allocated = cvmx_bootmem_phy_alloc(size, min_addr, max_addr,\r\nalignment,\r\nflags | CVMX_BOOTMEM_FLAG_NO_LOCKING);\r\nif (addr_allocated >= 0) {\r\nnamed_block_desc_ptr->base_addr = addr_allocated;\r\nnamed_block_desc_ptr->size = size;\r\nstrncpy(named_block_desc_ptr->name, name,\r\ncvmx_bootmem_desc->named_block_name_len);\r\nnamed_block_desc_ptr->name[cvmx_bootmem_desc->named_block_name_len - 1] = 0;\r\n}\r\nif (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))\r\ncvmx_spinlock_unlock((cvmx_spinlock_t *)&(cvmx_bootmem_desc->lock));\r\nreturn addr_allocated;\r\n}\r\nstruct cvmx_bootmem_desc *cvmx_bootmem_get_desc(void)\r\n{\r\nreturn cvmx_bootmem_desc;\r\n}
