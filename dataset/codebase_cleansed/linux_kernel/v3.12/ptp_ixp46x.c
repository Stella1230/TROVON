static u64 ixp_systime_read(struct ixp46x_ts_regs *regs)\r\n{\r\nu64 ns;\r\nu32 lo, hi;\r\nlo = __raw_readl(&regs->systime_lo);\r\nhi = __raw_readl(&regs->systime_hi);\r\nns = ((u64) hi) << 32;\r\nns |= lo;\r\nns <<= TICKS_NS_SHIFT;\r\nreturn ns;\r\n}\r\nstatic void ixp_systime_write(struct ixp46x_ts_regs *regs, u64 ns)\r\n{\r\nu32 hi, lo;\r\nns >>= TICKS_NS_SHIFT;\r\nhi = ns >> 32;\r\nlo = ns & 0xffffffff;\r\n__raw_writel(lo, &regs->systime_lo);\r\n__raw_writel(hi, &regs->systime_hi);\r\n}\r\nstatic irqreturn_t isr(int irq, void *priv)\r\n{\r\nstruct ixp_clock *ixp_clock = priv;\r\nstruct ixp46x_ts_regs *regs = ixp_clock->regs;\r\nstruct ptp_clock_event event;\r\nu32 ack = 0, lo, hi, val;\r\nval = __raw_readl(&regs->event);\r\nif (val & TSER_SNS) {\r\nack |= TSER_SNS;\r\nif (ixp_clock->exts0_enabled) {\r\nhi = __raw_readl(&regs->asms_hi);\r\nlo = __raw_readl(&regs->asms_lo);\r\nevent.type = PTP_CLOCK_EXTTS;\r\nevent.index = 0;\r\nevent.timestamp = ((u64) hi) << 32;\r\nevent.timestamp |= lo;\r\nevent.timestamp <<= TICKS_NS_SHIFT;\r\nptp_clock_event(ixp_clock->ptp_clock, &event);\r\n}\r\n}\r\nif (val & TSER_SNM) {\r\nack |= TSER_SNM;\r\nif (ixp_clock->exts1_enabled) {\r\nhi = __raw_readl(&regs->amms_hi);\r\nlo = __raw_readl(&regs->amms_lo);\r\nevent.type = PTP_CLOCK_EXTTS;\r\nevent.index = 1;\r\nevent.timestamp = ((u64) hi) << 32;\r\nevent.timestamp |= lo;\r\nevent.timestamp <<= TICKS_NS_SHIFT;\r\nptp_clock_event(ixp_clock->ptp_clock, &event);\r\n}\r\n}\r\nif (val & TTIPEND)\r\nack |= TTIPEND;\r\nif (ack) {\r\n__raw_writel(ack, &regs->event);\r\nreturn IRQ_HANDLED;\r\n} else\r\nreturn IRQ_NONE;\r\n}\r\nstatic int ptp_ixp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nu64 adj;\r\nu32 diff, addend;\r\nint neg_adj = 0;\r\nstruct ixp_clock *ixp_clock = container_of(ptp, struct ixp_clock, caps);\r\nstruct ixp46x_ts_regs *regs = ixp_clock->regs;\r\nif (ppb < 0) {\r\nneg_adj = 1;\r\nppb = -ppb;\r\n}\r\naddend = DEFAULT_ADDEND;\r\nadj = addend;\r\nadj *= ppb;\r\ndiff = div_u64(adj, 1000000000ULL);\r\naddend = neg_adj ? addend - diff : addend + diff;\r\n__raw_writel(addend, &regs->addend);\r\nreturn 0;\r\n}\r\nstatic int ptp_ixp_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\ns64 now;\r\nunsigned long flags;\r\nstruct ixp_clock *ixp_clock = container_of(ptp, struct ixp_clock, caps);\r\nstruct ixp46x_ts_regs *regs = ixp_clock->regs;\r\nspin_lock_irqsave(&register_lock, flags);\r\nnow = ixp_systime_read(regs);\r\nnow += delta;\r\nixp_systime_write(regs, now);\r\nspin_unlock_irqrestore(&register_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ptp_ixp_gettime(struct ptp_clock_info *ptp, struct timespec *ts)\r\n{\r\nu64 ns;\r\nu32 remainder;\r\nunsigned long flags;\r\nstruct ixp_clock *ixp_clock = container_of(ptp, struct ixp_clock, caps);\r\nstruct ixp46x_ts_regs *regs = ixp_clock->regs;\r\nspin_lock_irqsave(&register_lock, flags);\r\nns = ixp_systime_read(regs);\r\nspin_unlock_irqrestore(&register_lock, flags);\r\nts->tv_sec = div_u64_rem(ns, 1000000000, &remainder);\r\nts->tv_nsec = remainder;\r\nreturn 0;\r\n}\r\nstatic int ptp_ixp_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec *ts)\r\n{\r\nu64 ns;\r\nunsigned long flags;\r\nstruct ixp_clock *ixp_clock = container_of(ptp, struct ixp_clock, caps);\r\nstruct ixp46x_ts_regs *regs = ixp_clock->regs;\r\nns = ts->tv_sec * 1000000000ULL;\r\nns += ts->tv_nsec;\r\nspin_lock_irqsave(&register_lock, flags);\r\nixp_systime_write(regs, ns);\r\nspin_unlock_irqrestore(&register_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ptp_ixp_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq, int on)\r\n{\r\nstruct ixp_clock *ixp_clock = container_of(ptp, struct ixp_clock, caps);\r\nswitch (rq->type) {\r\ncase PTP_CLK_REQ_EXTTS:\r\nswitch (rq->extts.index) {\r\ncase 0:\r\nixp_clock->exts0_enabled = on ? 1 : 0;\r\nbreak;\r\ncase 1:\r\nixp_clock->exts1_enabled = on ? 1 : 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int setup_interrupt(int gpio)\r\n{\r\nint irq;\r\ngpio_line_config(gpio, IXP4XX_GPIO_IN);\r\nirq = gpio_to_irq(gpio);\r\nif (NO_IRQ == irq)\r\nreturn NO_IRQ;\r\nif (irq_set_irq_type(irq, IRQF_TRIGGER_FALLING)) {\r\npr_err("cannot set trigger type for irq %d\n", irq);\r\nreturn NO_IRQ;\r\n}\r\nif (request_irq(irq, isr, 0, DRIVER, &ixp_clock)) {\r\npr_err("request_irq failed for irq %d\n", irq);\r\nreturn NO_IRQ;\r\n}\r\nreturn irq;\r\n}\r\nstatic void __exit ptp_ixp_exit(void)\r\n{\r\nfree_irq(MASTER_IRQ, &ixp_clock);\r\nfree_irq(SLAVE_IRQ, &ixp_clock);\r\nixp46x_phc_index = -1;\r\nptp_clock_unregister(ixp_clock.ptp_clock);\r\n}\r\nstatic int __init ptp_ixp_init(void)\r\n{\r\nif (!cpu_is_ixp46x())\r\nreturn -ENODEV;\r\nixp_clock.regs =\r\n(struct ixp46x_ts_regs __iomem *) IXP4XX_TIMESYNC_BASE_VIRT;\r\nixp_clock.caps = ptp_ixp_caps;\r\nixp_clock.ptp_clock = ptp_clock_register(&ixp_clock.caps, NULL);\r\nif (IS_ERR(ixp_clock.ptp_clock))\r\nreturn PTR_ERR(ixp_clock.ptp_clock);\r\nixp46x_phc_index = ptp_clock_index(ixp_clock.ptp_clock);\r\n__raw_writel(DEFAULT_ADDEND, &ixp_clock.regs->addend);\r\n__raw_writel(1, &ixp_clock.regs->trgt_lo);\r\n__raw_writel(0, &ixp_clock.regs->trgt_hi);\r\n__raw_writel(TTIPEND, &ixp_clock.regs->event);\r\nif (MASTER_IRQ != setup_interrupt(MASTER_GPIO)) {\r\npr_err("failed to setup gpio %d as irq\n", MASTER_GPIO);\r\ngoto no_master;\r\n}\r\nif (SLAVE_IRQ != setup_interrupt(SLAVE_GPIO)) {\r\npr_err("failed to setup gpio %d as irq\n", SLAVE_GPIO);\r\ngoto no_slave;\r\n}\r\nreturn 0;\r\nno_slave:\r\nfree_irq(MASTER_IRQ, &ixp_clock);\r\nno_master:\r\nptp_clock_unregister(ixp_clock.ptp_clock);\r\nreturn -ENODEV;\r\n}
