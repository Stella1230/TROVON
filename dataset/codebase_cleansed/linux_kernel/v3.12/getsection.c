static char *unpack_sec_name(struct dload_state *dlthis, u32 soffset, char *dst)\r\n{\r\nu8 tmp, *src;\r\nif (soffset >= dlthis->dfile_hdr.df_scn_name_size) {\r\ndload_error(dlthis, stbl, soffset);\r\nreturn NULL;\r\n}\r\nsrc = (u8 *) dlthis->str_head +\r\n(soffset >> (LOG_BITS_PER_AU - LOG_BITS_PER_BYTE));\r\nif (soffset & 1)\r\n*dst++ = *src++;\r\ndo {\r\ntmp = *src++;\r\n*dst = (tmp >> BITS_PER_BYTE)\r\nif (!(*dst++))\r\nbreak;\r\n} while ((*dst++ = tmp & BYTE_MASK));\r\nreturn dst;\r\n}\r\nstatic void expand_sec_names(struct dload_state *dlthis)\r\n{\r\nchar *xstrings, *curr, *next;\r\nu32 xsize;\r\nu16 sec;\r\nstruct ldr_section_info *shp;\r\nxsize = dlthis->dfile_hdr.df_max_str_len * dlthis->dfile_hdr.df_no_scns;\r\nxstrings = (char *)dlthis->mysym->dload_allocate(dlthis->mysym, xsize);\r\nif (xstrings == NULL) {\r\ndload_error(dlthis, err_alloc, xsize);\r\nreturn;\r\n}\r\ndlthis->xstrings = xstrings;\r\ncurr = xstrings;\r\nfor (sec = 0; sec < dlthis->dfile_hdr.df_no_scns; sec++) {\r\nshp = (struct ldr_section_info *)&dlthis->sect_hdrs[sec];\r\nnext = unpack_sec_name(dlthis, *(u32 *) &shp->name, curr);\r\nif (next == NULL)\r\nbreak;\r\nshp->name = curr;\r\ncurr = next;\r\n}\r\n}\r\nvoid *dload_module_open(struct dynamic_loader_stream *module,\r\nstruct dynamic_loader_sym *syms)\r\n{\r\nstruct dload_state *dlthis;\r\nunsigned *dp, sz;\r\nu32 sec_start;\r\n#if BITS_PER_AU <= BITS_PER_BYTE\r\nu16 sec;\r\n#endif\r\nif (!module || !syms) {\r\nif (syms != NULL)\r\ndload_syms_error(syms, "Required parameter is NULL");\r\nreturn NULL;\r\n}\r\ndlthis = (struct dload_state *)\r\nsyms->dload_allocate(syms, sizeof(struct dload_state));\r\nif (!dlthis) {\r\ndload_syms_error(syms, "Can't allocate module info");\r\nreturn NULL;\r\n}\r\ndp = (unsigned *)dlthis;\r\nfor (sz = sizeof(struct dload_state) / sizeof(unsigned);\r\nsz > 0; sz -= 1)\r\n*dp++ = 0;\r\ndlthis->strm = module;\r\ndlthis->mysym = syms;\r\ndload_headers(dlthis);\r\nif (!dlthis->dload_errcount)\r\ndload_strings(dlthis, true);\r\nsec_start = sizeof(struct doff_filehdr_t) +\r\nsizeof(struct doff_verify_rec_t) +\r\nBYTE_TO_HOST(DOFF_ALIGN(dlthis->dfile_hdr.df_strtab_size));\r\nif (dlthis->strm->set_file_posn(dlthis->strm, sec_start) != 0) {\r\ndload_error(dlthis, seek, sec_start);\r\nreturn NULL;\r\n}\r\nif (!dlthis->dload_errcount)\r\ndload_sections(dlthis);\r\nif (dlthis->dload_errcount) {\r\ndload_module_close(dlthis);\r\ndlthis = NULL;\r\nreturn NULL;\r\n}\r\n#if BITS_PER_AU > BITS_PER_BYTE\r\nexpand_sec_names(dlthis);\r\n#else\r\nfor (sec = 0; sec < dlthis->dfile_hdr.df_no_scns; sec++) {\r\nstruct ldr_section_info *shp =\r\n(struct ldr_section_info *)&dlthis->sect_hdrs[sec];\r\nshp->name = dlthis->str_head + *(u32 *) &shp->name;\r\n}\r\n#endif\r\nreturn dlthis;\r\n}\r\nint dload_get_section_info(void *minfo, const char *section_name,\r\nconst struct ldr_section_info **const section_info)\r\n{\r\nstruct dload_state *dlthis;\r\nstruct ldr_section_info *shp;\r\nu16 sec;\r\ndlthis = (struct dload_state *)minfo;\r\nif (!dlthis)\r\nreturn false;\r\nfor (sec = 0; sec < dlthis->dfile_hdr.df_no_scns; sec++) {\r\nshp = (struct ldr_section_info *)&dlthis->sect_hdrs[sec];\r\nif (strcmp(section_name, shp->name) == 0) {\r\n*section_info = shp;\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nint dload_get_section(void *minfo,\r\nconst struct ldr_section_info *section_info,\r\nvoid *section_data)\r\n{\r\nstruct dload_state *dlthis;\r\nu32 pos;\r\nstruct doff_scnhdr_t *sptr = NULL;\r\ns32 nip;\r\nstruct image_packet_t ipacket;\r\ns32 ipsize;\r\nu32 checks;\r\ns8 *dest = (s8 *) section_data;\r\ndlthis = (struct dload_state *)minfo;\r\nif (!dlthis)\r\nreturn false;\r\nsptr = (struct doff_scnhdr_t *)section_info;\r\nif (sptr == NULL)\r\nreturn false;\r\npos = BYTE_TO_HOST(DOFF_ALIGN((u32) sptr->ds_first_pkt_offset));\r\nif (dlthis->strm->set_file_posn(dlthis->strm, pos) != 0) {\r\ndload_error(dlthis, seek, pos);\r\nreturn false;\r\n}\r\nnip = sptr->ds_nipacks;\r\nwhile ((nip -= 1) >= 0) {\r\nif (dlthis->strm->read_buffer(dlthis->strm, &ipacket,\r\nIPH_SIZE) != IPH_SIZE) {\r\ndload_error(dlthis, readstrm, "image packet");\r\nreturn false;\r\n}\r\nif (dlthis->reorder_map)\r\ndload_reorder(&ipacket, IPH_SIZE, dlthis->reorder_map);\r\nipsize = BYTE_TO_HOST(DOFF_ALIGN(ipacket.packet_size));\r\nif (ipsize > BYTE_TO_HOST(IMAGE_PACKET_SIZE)) {\r\ndload_error(dlthis, isiz, ipsize);\r\nreturn false;\r\n}\r\nif (dlthis->strm->read_buffer\r\n(dlthis->strm, dest, ipsize) != ipsize) {\r\ndload_error(dlthis, readstrm, "image packet");\r\nreturn false;\r\n}\r\n#if !defined(_BIG_ENDIAN) || (TARGET_AU_BITS > 16)\r\nif (dlthis->reorder_map)\r\ndload_reorder(dest, ipsize, dlthis->reorder_map);\r\nchecks = dload_checksum(dest, ipsize);\r\n#else\r\nif (dlthis->dfile_hdr.df_byte_reshuffle !=\r\nTARGET_ORDER(REORDER_MAP(BYTE_RESHUFFLE_VALUE))) {\r\ndload_reorder(dest, ipsize,\r\nTARGET_ORDER(dlthis->\r\ndfile_hdr.df_byte_reshuffle));\r\n}\r\n#if TARGET_AU_BITS > 8\r\nchecks = dload_reverse_checksum16(dest, ipsize);\r\n#else\r\nchecks = dload_reverse_checksum(dest, ipsize);\r\n#endif\r\n#endif\r\nchecks += dload_checksum(&ipacket, IPH_SIZE);\r\nif (ipacket.num_relocs != 0) {\r\ndload_error(dlthis, err_reloc, ipsize);\r\nreturn false;\r\n}\r\nif (~checks) {\r\ndload_error(dlthis, err_checksum, "image packet");\r\nreturn false;\r\n}\r\ndest += ipsize;\r\n}\r\nreturn true;\r\n}\r\nvoid dload_module_close(void *minfo)\r\n{\r\nstruct dload_state *dlthis;\r\ndlthis = (struct dload_state *)minfo;\r\nif (!dlthis)\r\nreturn;\r\nif (dlthis->str_head)\r\ndlthis->mysym->dload_deallocate(dlthis->mysym,\r\ndlthis->str_head);\r\nif (dlthis->sect_hdrs)\r\ndlthis->mysym->dload_deallocate(dlthis->mysym,\r\ndlthis->sect_hdrs);\r\n#if BITS_PER_AU > BITS_PER_BYTE\r\nif (dlthis->xstrings)\r\ndlthis->mysym->dload_deallocate(dlthis->mysym,\r\ndlthis->xstrings);\r\n#endif\r\ndlthis->mysym->dload_deallocate(dlthis->mysym, dlthis);\r\n}
