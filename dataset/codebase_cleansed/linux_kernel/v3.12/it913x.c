static u16 check_sum(u8 *p, u8 len)\r\n{\r\nu16 sum = 0;\r\nu8 i = 1;\r\nwhile (i < len)\r\nsum += (i++ & 1) ? (*p++) << 8 : *p++;\r\nreturn ~sum;\r\n}\r\nstatic int it913x_io(struct dvb_usb_device *d, u8 mode, u8 pro,\r\nu8 cmd, u32 reg, u8 addr, u8 *data, u8 len)\r\n{\r\nstruct it913x_state *st = d->priv;\r\nint ret = 0, i, buf_size = 1;\r\nu8 *buff;\r\nu8 rlen;\r\nu16 chk_sum;\r\nbuff = kzalloc(256, GFP_KERNEL);\r\nif (!buff) {\r\ninfo("USB Buffer Failed");\r\nreturn -ENOMEM;\r\n}\r\nbuff[buf_size++] = pro;\r\nbuff[buf_size++] = cmd;\r\nbuff[buf_size++] = st->cmd_counter;\r\nswitch (mode) {\r\ncase READ_LONG:\r\ncase WRITE_LONG:\r\nbuff[buf_size++] = len;\r\nbuff[buf_size++] = 2;\r\nbuff[buf_size++] = (reg >> 24);\r\nbuff[buf_size++] = (reg >> 16) & 0xff;\r\nbuff[buf_size++] = (reg >> 8) & 0xff;\r\nbuff[buf_size++] = reg & 0xff;\r\nbreak;\r\ncase READ_SHORT:\r\nbuff[buf_size++] = addr;\r\nbreak;\r\ncase WRITE_SHORT:\r\nbuff[buf_size++] = len;\r\nbuff[buf_size++] = addr;\r\nbuff[buf_size++] = (reg >> 8) & 0xff;\r\nbuff[buf_size++] = reg & 0xff;\r\nbreak;\r\ncase READ_DATA:\r\ncase WRITE_DATA:\r\nbreak;\r\ncase WRITE_CMD:\r\nmode = 7;\r\nbreak;\r\ndefault:\r\nkfree(buff);\r\nreturn -EINVAL;\r\n}\r\nif (mode & 1) {\r\nfor (i = 0; i < len ; i++)\r\nbuff[buf_size++] = data[i];\r\n}\r\nchk_sum = check_sum(&buff[1], buf_size);\r\nbuff[buf_size++] = chk_sum >> 8;\r\nbuff[0] = buf_size;\r\nbuff[buf_size++] = (chk_sum & 0xff);\r\nret = dvb_usbv2_generic_rw(d, buff, buf_size, buff, (mode & 1) ?\r\n5 : len + 5);\r\nif (ret < 0)\r\ngoto error;\r\nrlen = (mode & 0x1) ? 0x1 : len;\r\nif (mode & 1)\r\nret = buff[2];\r\nelse\r\nmemcpy(data, &buff[3], rlen);\r\nst->cmd_counter++;\r\nerror: kfree(buff);\r\nreturn ret;\r\n}\r\nstatic int it913x_wr_reg(struct dvb_usb_device *d, u8 pro, u32 reg , u8 data)\r\n{\r\nint ret;\r\nu8 b[1];\r\nb[0] = data;\r\nret = it913x_io(d, WRITE_LONG, pro,\r\nCMD_DEMOD_WRITE, reg, 0, b, sizeof(b));\r\nreturn ret;\r\n}\r\nstatic int it913x_read_reg(struct dvb_usb_device *d, u32 reg)\r\n{\r\nint ret;\r\nu8 data[1];\r\nret = it913x_io(d, READ_LONG, DEV_0,\r\nCMD_DEMOD_READ, reg, 0, &data[0], sizeof(data));\r\nreturn (ret < 0) ? ret : data[0];\r\n}\r\nstatic int it913x_query(struct dvb_usb_device *d, u8 pro)\r\n{\r\nstruct it913x_state *st = d->priv;\r\nint ret, i;\r\nu8 data[4];\r\nu8 ver;\r\nfor (i = 0; i < 5; i++) {\r\nret = it913x_io(d, READ_LONG, pro, CMD_DEMOD_READ,\r\n0x1222, 0, &data[0], 3);\r\nver = data[0];\r\nif (ver > 0 && ver < 3)\r\nbreak;\r\nmsleep(100);\r\n}\r\nif (ver < 1 || ver > 2) {\r\ninfo("Failed to identify chip version applying 1");\r\nst->it913x_config.chip_ver = 0x1;\r\nst->it913x_config.chip_type = 0x9135;\r\nreturn 0;\r\n}\r\nst->it913x_config.chip_ver = ver;\r\nst->it913x_config.chip_type = (u16)(data[2] << 8) + data[1];\r\ninfo("Chip Version=%02x Chip Type=%04x", st->it913x_config.chip_ver,\r\nst->it913x_config.chip_type);\r\nret = it913x_io(d, READ_SHORT, pro,\r\nCMD_QUERYINFO, 0, 0x1, &data[0], 4);\r\nst->it913x_config.firmware = (data[0] << 24) | (data[1] << 16) |\r\n(data[2] << 8) | data[3];\r\nreturn ret;\r\n}\r\nstatic int it913x_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct it913x_state *st = adap_to_priv(adap);\r\nint ret;\r\nu8 pro = (adap->id == 0) ? DEV_0_DMOD : DEV_1_DMOD;\r\nmutex_lock(&d->i2c_mutex);\r\ndeb_info(1, "PID_C (%02x)", onoff);\r\nst->pid_filter_onoff = adap->pid_filtering;\r\nret = it913x_wr_reg(d, pro, PID_EN, st->pid_filter_onoff);\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic int it913x_pid_filter(struct dvb_usb_adapter *adap,\r\nint index, u16 pid, int onoff)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct it913x_state *st = adap_to_priv(adap);\r\nint ret;\r\nu8 pro = (adap->id == 0) ? DEV_0_DMOD : DEV_1_DMOD;\r\nmutex_lock(&d->i2c_mutex);\r\ndeb_info(1, "PID_F (%02x)", onoff);\r\nret = it913x_wr_reg(d, pro, PID_LSB, (u8)(pid & 0xff));\r\nret |= it913x_wr_reg(d, pro, PID_MSB, (u8)(pid >> 8));\r\nret |= it913x_wr_reg(d, pro, PID_INX_EN, (u8)onoff);\r\nret |= it913x_wr_reg(d, pro, PID_INX, (u8)(index & 0x1f));\r\nif (d->udev->speed == USB_SPEED_HIGH && pid == 0x2000) {\r\nret |= it913x_wr_reg(d , pro, PID_EN, !onoff);\r\nst->pid_filter_onoff = !onoff;\r\n} else\r\nst->pid_filter_onoff =\r\nadap->pid_filtering;\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn 0;\r\n}\r\nstatic int it913x_return_status(struct dvb_usb_device *d)\r\n{\r\nstruct it913x_state *st = d->priv;\r\nint ret = it913x_query(d, DEV_0);\r\nif (st->it913x_config.firmware > 0)\r\ninfo("Firmware Version %d", st->it913x_config.firmware);\r\nreturn ret;\r\n}\r\nstatic int it913x_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstatic u8 data[256];\r\nint ret;\r\nu32 reg;\r\nu8 pro;\r\nmutex_lock(&d->i2c_mutex);\r\ndeb_info(2, "num of messages %d address %02x", num, msg[0].addr);\r\npro = (msg[0].addr & 0x2) ? DEV_0_DMOD : 0x0;\r\npro |= (msg[0].addr & 0x20) ? DEV_1 : DEV_0;\r\nmemcpy(data, msg[0].buf, msg[0].len);\r\nreg = (data[0] << 24) + (data[1] << 16) +\r\n(data[2] << 8) + data[3];\r\nif (num == 2) {\r\nret = it913x_io(d, READ_LONG, pro,\r\nCMD_DEMOD_READ, reg, 0, data, msg[1].len);\r\nmemcpy(msg[1].buf, data, msg[1].len);\r\n} else\r\nret = it913x_io(d, WRITE_LONG, pro, CMD_DEMOD_WRITE,\r\nreg, 0, &data[4], msg[0].len - 4);\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic u32 it913x_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int it913x_rc_query(struct dvb_usb_device *d)\r\n{\r\nu8 ibuf[4];\r\nint ret;\r\nu32 key;\r\nmutex_lock(&d->i2c_mutex);\r\nret = it913x_io(d, READ_LONG, PRO_LINK, CMD_IR_GET,\r\n0, 0, &ibuf[0], sizeof(ibuf));\r\nif ((ibuf[2] + ibuf[3]) == 0xff) {\r\nkey = ibuf[2];\r\nkey += ibuf[0] << 16;\r\nkey += ibuf[1] << 8;\r\ndeb_info(1, "NEC Extended Key =%08x", key);\r\nif (d->rc_dev != NULL)\r\nrc_keydown(d->rc_dev, key, 0);\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic int it913x_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)\r\n{\r\nstruct it913x_state *st = d->priv;\r\nif (st->proprietary_ir == false) {\r\nrc->map_name = NULL;\r\nreturn 0;\r\n}\r\nrc->allowed_protos = RC_BIT_NEC;\r\nrc->query = it913x_rc_query;\r\nrc->interval = 250;\r\nreturn 0;\r\n}\r\nstatic void ite_get_firmware_name(struct dvb_usb_device *d,\r\nconst char **name)\r\n{\r\nstruct it913x_state *st = d->priv;\r\nint sw;\r\nif (le16_to_cpu(d->udev->descriptor.idVendor) == USB_VID_KWORLD_2)\r\nsw = IT9137_FW;\r\nelse if (st->it913x_config.chip_ver == 1)\r\nsw = IT9135_V1_FW;\r\nelse\r\nsw = IT9135_V2_FW;\r\nif (dvb_usb_it913x_firmware != IT9135_AUTO)\r\nsw = dvb_usb_it913x_firmware;\r\nswitch (sw) {\r\ncase IT9135_V1_FW:\r\nst->it913x_config.firmware_ver = 1;\r\nst->it913x_config.adc_x2 = 1;\r\nst->it913x_config.read_slevel = false;\r\n*name = fw_it9135_v1;\r\nbreak;\r\ncase IT9135_V2_FW:\r\nst->it913x_config.firmware_ver = 1;\r\nst->it913x_config.adc_x2 = 1;\r\nst->it913x_config.read_slevel = false;\r\n*name = fw_it9135_v2;\r\nswitch (st->it913x_config.tuner_id_0) {\r\ncase IT9135_61:\r\ncase IT9135_62:\r\nbreak;\r\ndefault:\r\ninfo("Unknown tuner ID applying default 0x60");\r\ncase IT9135_60:\r\nst->it913x_config.tuner_id_0 = IT9135_60;\r\n}\r\nbreak;\r\ncase IT9137_FW:\r\ndefault:\r\nst->it913x_config.firmware_ver = 0;\r\nst->it913x_config.adc_x2 = 0;\r\nst->it913x_config.read_slevel = true;\r\n*name = fw_it9137;\r\n}\r\nreturn;\r\n}\r\nstatic int it913x_get_stream_config(struct dvb_frontend *fe, u8 *ts_type,\r\nstruct usb_data_stream_properties *stream)\r\n{\r\nstruct dvb_usb_adapter *adap = fe_to_adap(fe);\r\nif (adap->pid_filtering)\r\nstream->u.bulk.buffersize = TS_BUFFER_SIZE_PID;\r\nelse\r\nstream->u.bulk.buffersize = TS_BUFFER_SIZE_MAX;\r\nreturn 0;\r\n}\r\nstatic int it913x_select_config(struct dvb_usb_device *d)\r\n{\r\nstruct it913x_state *st = d->priv;\r\nint ret, reg;\r\nret = it913x_return_status(d);\r\nif (ret < 0)\r\nreturn ret;\r\nif (st->it913x_config.chip_ver == 0x02\r\n&& st->it913x_config.chip_type == 0x9135)\r\nreg = it913x_read_reg(d, 0x461d);\r\nelse\r\nreg = it913x_read_reg(d, 0x461b);\r\nif (reg < 0)\r\nreturn reg;\r\nif (reg == 0) {\r\nst->it913x_config.dual_mode = 0;\r\nst->it913x_config.tuner_id_0 = IT9135_38;\r\nst->proprietary_ir = true;\r\n} else {\r\nreg = it913x_read_reg(d, 0x49c5);\r\nif (reg < 0)\r\nreturn reg;\r\nst->it913x_config.dual_mode = reg;\r\nreg = it913x_read_reg(d, 0x49ac);\r\nif (reg < 0)\r\nreturn reg;\r\nif (reg == 5) {\r\ninfo("Remote propriety (raw) mode");\r\nst->proprietary_ir = true;\r\n} else if (reg == 1) {\r\ninfo("Remote HID mode NOT SUPPORTED");\r\nst->proprietary_ir = false;\r\n}\r\nreg = it913x_read_reg(d, 0x49d0);\r\nif (reg < 0)\r\nreturn reg;\r\nst->it913x_config.tuner_id_0 = reg;\r\n}\r\ninfo("Dual mode=%x Tuner Type=%x", st->it913x_config.dual_mode,\r\nst->it913x_config.tuner_id_0);\r\nreturn ret;\r\n}\r\nstatic int it913x_streaming_ctrl(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dvb_usb_adapter *adap = fe_to_adap(fe);\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct it913x_state *st = fe_to_priv(fe);\r\nint ret = 0;\r\nu8 pro = (adap->id == 0) ? DEV_0_DMOD : DEV_1_DMOD;\r\ndeb_info(1, "STM (%02x)", onoff);\r\nif (!onoff) {\r\nmutex_lock(&d->i2c_mutex);\r\nret = it913x_wr_reg(d, pro, PID_RST, 0x1);\r\nmutex_unlock(&d->i2c_mutex);\r\nst->pid_filter_onoff =\r\nadap->pid_filtering;\r\n}\r\nreturn ret;\r\n}\r\nstatic int it913x_identify_state(struct dvb_usb_device *d, const char **name)\r\n{\r\nstruct it913x_state *st = d->priv;\r\nint ret;\r\nu8 reg;\r\nret = it913x_select_config(d);\r\nif (ret < 0)\r\nreturn ret;\r\nite_get_firmware_name(d, name);\r\nif (st->it913x_config.firmware > 0)\r\nreturn WARM;\r\nif (st->it913x_config.dual_mode) {\r\nst->it913x_config.tuner_id_1 = it913x_read_reg(d, 0x49e0);\r\nret = it913x_wr_reg(d, DEV_0, GPIOH1_EN, 0x1);\r\nret |= it913x_wr_reg(d, DEV_0, GPIOH1_ON, 0x1);\r\nret |= it913x_wr_reg(d, DEV_0, GPIOH1_O, 0x1);\r\nmsleep(50);\r\nret |= it913x_wr_reg(d, DEV_0, GPIOH1_O, 0x0);\r\nmsleep(50);\r\nreg = it913x_read_reg(d, GPIOH1_O);\r\nif (reg == 0) {\r\nret |= it913x_wr_reg(d, DEV_0, GPIOH1_O, 0x1);\r\nret |= it913x_return_status(d);\r\nif (ret != 0)\r\nret = it913x_wr_reg(d, DEV_0,\r\nGPIOH1_O, 0x0);\r\n}\r\n}\r\nreg = it913x_read_reg(d, IO_MUX_POWER_CLK);\r\nif (st->it913x_config.dual_mode) {\r\nret |= it913x_wr_reg(d, DEV_0, 0x4bfb, CHIP2_I2C_ADDR);\r\nif (st->it913x_config.firmware_ver == 1)\r\nret |= it913x_wr_reg(d, DEV_0, 0xcfff, 0x1);\r\nelse\r\nret |= it913x_wr_reg(d, DEV_0, CLK_O_EN, 0x1);\r\n} else {\r\nret |= it913x_wr_reg(d, DEV_0, 0x4bfb, 0x0);\r\nif (st->it913x_config.firmware_ver == 1)\r\nret |= it913x_wr_reg(d, DEV_0, 0xcfff, 0x0);\r\nelse\r\nret |= it913x_wr_reg(d, DEV_0, CLK_O_EN, 0x0);\r\n}\r\nret |= it913x_wr_reg(d, DEV_0, I2C_CLK, I2C_CLK_100);\r\nreturn (ret < 0) ? ret : COLD;\r\n}\r\nstatic int it913x_download_firmware(struct dvb_usb_device *d,\r\nconst struct firmware *fw)\r\n{\r\nstruct it913x_state *st = d->priv;\r\nint ret = 0, i = 0, pos = 0;\r\nu8 packet_size, min_pkt;\r\nu8 *fw_data;\r\nret = it913x_wr_reg(d, DEV_0, I2C_CLK, I2C_CLK_100);\r\ninfo("FRM Starting Firmware Download");\r\nif (st->it913x_config.chip_ver == 2)\r\nmin_pkt = 0x11;\r\nelse\r\nmin_pkt = 0x19;\r\nwhile (i <= fw->size) {\r\nif (((fw->data[i] == 0x3) && (fw->data[i + 2] == 0x0))\r\n|| (i == fw->size)) {\r\npacket_size = i - pos;\r\nif ((packet_size > min_pkt) || (i == fw->size)) {\r\nfw_data = (u8 *)(fw->data + pos);\r\npos += packet_size;\r\nif (packet_size > 0) {\r\nret = it913x_io(d, WRITE_DATA,\r\nDEV_0, CMD_SCATTER_WRITE, 0,\r\n0, fw_data, packet_size);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nudelay(1000);\r\n}\r\n}\r\ni++;\r\n}\r\nif (ret < 0)\r\ninfo("FRM Firmware Download Failed (%d)" , ret);\r\nelse\r\ninfo("FRM Firmware Download Completed - Resetting Device");\r\nmsleep(30);\r\nret = it913x_io(d, WRITE_CMD, DEV_0, CMD_BOOT, 0, 0, NULL, 0);\r\nif (ret < 0)\r\ninfo("FRM Device not responding to reboot");\r\nret = it913x_return_status(d);\r\nif (st->it913x_config.firmware == 0) {\r\ninfo("FRM Failed to reboot device");\r\nreturn -ENODEV;\r\n}\r\nmsleep(30);\r\nret = it913x_wr_reg(d, DEV_0, I2C_CLK, I2C_CLK_400);\r\nmsleep(30);\r\nif (st->it913x_config.dual_mode)\r\nret |= it913x_wr_reg(d, DEV_0_DMOD , 0xec4c, 0xa0);\r\nelse\r\nret |= it913x_wr_reg(d, DEV_0_DMOD , 0xec4c, 0x68);\r\nif ((st->it913x_config.chip_ver == 1) &&\r\n(st->it913x_config.chip_type == 0x9135)) {\r\nret |= it913x_wr_reg(d, DEV_0, PADODPU, 0x0);\r\nret |= it913x_wr_reg(d, DEV_0, AGC_O_D, 0x0);\r\nif (st->it913x_config.dual_mode) {\r\nret |= it913x_wr_reg(d, DEV_1, PADODPU, 0x0);\r\nret |= it913x_wr_reg(d, DEV_1, AGC_O_D, 0x0);\r\n}\r\n}\r\nreturn (ret < 0) ? -ENODEV : 0;\r\n}\r\nstatic int it913x_name(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nconst char *desc = d->name;\r\nchar *fe_name[] = {"_1", "_2", "_3", "_4"};\r\nchar *name = adap->fe[0]->ops.info.name;\r\nstrlcpy(name, desc, 128);\r\nstrlcat(name, fe_name[adap->id], 128);\r\nreturn 0;\r\n}\r\nstatic int it913x_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct it913x_state *st = d->priv;\r\nint ret = 0;\r\nu8 adap_addr = I2C_BASE_ADDR + (adap->id << 5);\r\nu16 ep_size = (adap->pid_filtering) ? TS_BUFFER_SIZE_PID / 4 :\r\nTS_BUFFER_SIZE_MAX / 4;\r\nu8 pkt_size = 0x80;\r\nif (d->udev->speed != USB_SPEED_HIGH)\r\npkt_size = 0x10;\r\nst->it913x_config.adf = it913x_read_reg(d, IO_MUX_POWER_CLK);\r\nadap->fe[0] = dvb_attach(it913x_fe_attach,\r\n&d->i2c_adap, adap_addr, &st->it913x_config);\r\nif (adap->id == 0 && adap->fe[0]) {\r\nit913x_wr_reg(d, DEV_0_DMOD, MP2_SW_RST, 0x1);\r\nit913x_wr_reg(d, DEV_0_DMOD, MP2IF2_SW_RST, 0x1);\r\nit913x_wr_reg(d, DEV_0, EP0_TX_EN, 0x0f);\r\nit913x_wr_reg(d, DEV_0, EP0_TX_NAK, 0x1b);\r\nif (st->proprietary_ir == false)\r\nit913x_wr_reg(d, DEV_0, EP0_TX_EN, 0x3f);\r\nelse\r\nit913x_wr_reg(d, DEV_0, EP0_TX_EN, 0x2f);\r\nit913x_wr_reg(d, DEV_0, EP4_TX_LEN_LSB,\r\nep_size & 0xff);\r\nit913x_wr_reg(d, DEV_0, EP4_TX_LEN_MSB, ep_size >> 8);\r\nret = it913x_wr_reg(d, DEV_0, EP4_MAX_PKT, pkt_size);\r\n} else if (adap->id == 1 && adap->fe[0]) {\r\nif (st->proprietary_ir == false)\r\nit913x_wr_reg(d, DEV_0, EP0_TX_EN, 0x7f);\r\nelse\r\nit913x_wr_reg(d, DEV_0, EP0_TX_EN, 0x6f);\r\nit913x_wr_reg(d, DEV_0, EP5_TX_LEN_LSB,\r\nep_size & 0xff);\r\nit913x_wr_reg(d, DEV_0, EP5_TX_LEN_MSB, ep_size >> 8);\r\nit913x_wr_reg(d, DEV_0, EP5_MAX_PKT, pkt_size);\r\nit913x_wr_reg(d, DEV_0_DMOD, MP2IF2_EN, 0x1);\r\nit913x_wr_reg(d, DEV_1_DMOD, MP2IF_SERIAL, 0x1);\r\nit913x_wr_reg(d, DEV_1, TOP_HOSTB_SER_MODE, 0x1);\r\nit913x_wr_reg(d, DEV_0_DMOD, TSIS_ENABLE, 0x1);\r\nit913x_wr_reg(d, DEV_0_DMOD, MP2_SW_RST, 0x0);\r\nit913x_wr_reg(d, DEV_0_DMOD, MP2IF2_SW_RST, 0x0);\r\nit913x_wr_reg(d, DEV_0_DMOD, MP2IF2_HALF_PSB, 0x0);\r\nit913x_wr_reg(d, DEV_0_DMOD, MP2IF_STOP_EN, 0x1);\r\nit913x_wr_reg(d, DEV_1_DMOD, MPEG_FULL_SPEED, 0x0);\r\nret = it913x_wr_reg(d, DEV_1_DMOD, MP2IF_STOP_EN, 0x0);\r\n} else\r\nreturn -ENODEV;\r\nret |= it913x_name(adap);\r\nreturn ret;\r\n}\r\nstatic int it913x_get_adapter_count(struct dvb_usb_device *d)\r\n{\r\nstruct it913x_state *st = d->priv;\r\nif (st->it913x_config.dual_mode)\r\nreturn 2;\r\nreturn 1;\r\n}
