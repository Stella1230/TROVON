struct edac_pci_ctl_info *edac_pci_alloc_ctl_info(unsigned int sz_pvt,\r\nconst char *edac_pci_name)\r\n{\r\nstruct edac_pci_ctl_info *pci;\r\nvoid *p = NULL, *pvt;\r\nunsigned int size;\r\nedac_dbg(1, "\n");\r\npci = edac_align_ptr(&p, sizeof(*pci), 1);\r\npvt = edac_align_ptr(&p, 1, sz_pvt);\r\nsize = ((unsigned long)pvt) + sz_pvt;\r\npci = kzalloc(size, GFP_KERNEL);\r\nif (pci == NULL)\r\nreturn NULL;\r\npvt = sz_pvt ? ((char *)pci) + ((unsigned long)pvt) : NULL;\r\npci->pvt_info = pvt;\r\npci->op_state = OP_ALLOC;\r\nsnprintf(pci->name, strlen(edac_pci_name) + 1, "%s", edac_pci_name);\r\nreturn pci;\r\n}\r\nvoid edac_pci_free_ctl_info(struct edac_pci_ctl_info *pci)\r\n{\r\nedac_dbg(1, "\n");\r\nedac_pci_remove_sysfs(pci);\r\n}\r\nstatic struct edac_pci_ctl_info *find_edac_pci_by_dev(struct device *dev)\r\n{\r\nstruct edac_pci_ctl_info *pci;\r\nstruct list_head *item;\r\nedac_dbg(1, "\n");\r\nlist_for_each(item, &edac_pci_list) {\r\npci = list_entry(item, struct edac_pci_ctl_info, link);\r\nif (pci->dev == dev)\r\nreturn pci;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int add_edac_pci_to_global_list(struct edac_pci_ctl_info *pci)\r\n{\r\nstruct list_head *item, *insert_before;\r\nstruct edac_pci_ctl_info *rover;\r\nedac_dbg(1, "\n");\r\ninsert_before = &edac_pci_list;\r\nrover = find_edac_pci_by_dev(pci->dev);\r\nif (unlikely(rover != NULL))\r\ngoto fail0;\r\nlist_for_each(item, &edac_pci_list) {\r\nrover = list_entry(item, struct edac_pci_ctl_info, link);\r\nif (rover->pci_idx >= pci->pci_idx) {\r\nif (unlikely(rover->pci_idx == pci->pci_idx))\r\ngoto fail1;\r\ninsert_before = item;\r\nbreak;\r\n}\r\n}\r\nlist_add_tail_rcu(&pci->link, insert_before);\r\nreturn 0;\r\nfail0:\r\nedac_printk(KERN_WARNING, EDAC_PCI,\r\n"%s (%s) %s %s already assigned %d\n",\r\ndev_name(rover->dev), edac_dev_name(rover),\r\nrover->mod_name, rover->ctl_name, rover->pci_idx);\r\nreturn 1;\r\nfail1:\r\nedac_printk(KERN_WARNING, EDAC_PCI,\r\n"but in low-level driver: attempt to assign\n"\r\n"\tduplicate pci_idx %d in %s()\n", rover->pci_idx,\r\n__func__);\r\nreturn 1;\r\n}\r\nstatic void del_edac_pci_from_global_list(struct edac_pci_ctl_info *pci)\r\n{\r\nlist_del_rcu(&pci->link);\r\nsynchronize_rcu();\r\nINIT_LIST_HEAD(&pci->link);\r\n}\r\nstatic void edac_pci_workq_function(struct work_struct *work_req)\r\n{\r\nstruct delayed_work *d_work = to_delayed_work(work_req);\r\nstruct edac_pci_ctl_info *pci = to_edac_pci_ctl_work(d_work);\r\nint msec;\r\nunsigned long delay;\r\nedac_dbg(3, "checking\n");\r\nmutex_lock(&edac_pci_ctls_mutex);\r\nif (pci->op_state == OP_RUNNING_POLL) {\r\nif ((pci->edac_check != NULL) && edac_pci_get_check_errors())\r\npci->edac_check(pci);\r\nmsec = edac_pci_get_poll_msec();\r\nif (msec == 1000)\r\ndelay = round_jiffies_relative(msecs_to_jiffies(msec));\r\nelse\r\ndelay = msecs_to_jiffies(msec);\r\nqueue_delayed_work(edac_workqueue, &pci->work, delay);\r\n}\r\nmutex_unlock(&edac_pci_ctls_mutex);\r\n}\r\nstatic void edac_pci_workq_setup(struct edac_pci_ctl_info *pci,\r\nunsigned int msec)\r\n{\r\nedac_dbg(0, "\n");\r\nINIT_DELAYED_WORK(&pci->work, edac_pci_workq_function);\r\nqueue_delayed_work(edac_workqueue, &pci->work,\r\nmsecs_to_jiffies(edac_pci_get_poll_msec()));\r\n}\r\nstatic void edac_pci_workq_teardown(struct edac_pci_ctl_info *pci)\r\n{\r\nint status;\r\nedac_dbg(0, "\n");\r\nstatus = cancel_delayed_work(&pci->work);\r\nif (status == 0)\r\nflush_workqueue(edac_workqueue);\r\n}\r\nvoid edac_pci_reset_delay_period(struct edac_pci_ctl_info *pci,\r\nunsigned long value)\r\n{\r\nedac_dbg(0, "\n");\r\nedac_pci_workq_teardown(pci);\r\nmutex_lock(&edac_pci_ctls_mutex);\r\nedac_pci_workq_setup(pci, value);\r\nmutex_unlock(&edac_pci_ctls_mutex);\r\n}\r\nint edac_pci_alloc_index(void)\r\n{\r\nreturn atomic_inc_return(&pci_indexes) - 1;\r\n}\r\nint edac_pci_add_device(struct edac_pci_ctl_info *pci, int edac_idx)\r\n{\r\nedac_dbg(0, "\n");\r\npci->pci_idx = edac_idx;\r\npci->start_time = jiffies;\r\nmutex_lock(&edac_pci_ctls_mutex);\r\nif (add_edac_pci_to_global_list(pci))\r\ngoto fail0;\r\nif (edac_pci_create_sysfs(pci)) {\r\nedac_pci_printk(pci, KERN_WARNING,\r\n"failed to create sysfs pci\n");\r\ngoto fail1;\r\n}\r\nif (pci->edac_check != NULL) {\r\npci->op_state = OP_RUNNING_POLL;\r\nedac_pci_workq_setup(pci, 1000);\r\n} else {\r\npci->op_state = OP_RUNNING_INTERRUPT;\r\n}\r\nedac_pci_printk(pci, KERN_INFO,\r\n"Giving out device to module '%s' controller '%s':"\r\n" DEV '%s' (%s)\n",\r\npci->mod_name,\r\npci->ctl_name,\r\nedac_dev_name(pci), edac_op_state_to_string(pci->op_state));\r\nmutex_unlock(&edac_pci_ctls_mutex);\r\nreturn 0;\r\nfail1:\r\ndel_edac_pci_from_global_list(pci);\r\nfail0:\r\nmutex_unlock(&edac_pci_ctls_mutex);\r\nreturn 1;\r\n}\r\nstruct edac_pci_ctl_info *edac_pci_del_device(struct device *dev)\r\n{\r\nstruct edac_pci_ctl_info *pci;\r\nedac_dbg(0, "\n");\r\nmutex_lock(&edac_pci_ctls_mutex);\r\npci = find_edac_pci_by_dev(dev);\r\nif (pci == NULL) {\r\nmutex_unlock(&edac_pci_ctls_mutex);\r\nreturn NULL;\r\n}\r\npci->op_state = OP_OFFLINE;\r\ndel_edac_pci_from_global_list(pci);\r\nmutex_unlock(&edac_pci_ctls_mutex);\r\nedac_pci_workq_teardown(pci);\r\nedac_printk(KERN_INFO, EDAC_PCI,\r\n"Removed device %d for %s %s: DEV %s\n",\r\npci->pci_idx, pci->mod_name, pci->ctl_name, edac_dev_name(pci));\r\nreturn pci;\r\n}\r\nstatic void edac_pci_generic_check(struct edac_pci_ctl_info *pci)\r\n{\r\nedac_dbg(4, "\n");\r\nedac_pci_do_parity_check();\r\n}\r\nstruct edac_pci_ctl_info *edac_pci_create_generic_ctl(struct device *dev,\r\nconst char *mod_name)\r\n{\r\nstruct edac_pci_ctl_info *pci;\r\nstruct edac_pci_gen_data *pdata;\r\npci = edac_pci_alloc_ctl_info(sizeof(*pdata), EDAC_PCI_GENCTL_NAME);\r\nif (!pci)\r\nreturn NULL;\r\npdata = pci->pvt_info;\r\npci->dev = dev;\r\ndev_set_drvdata(pci->dev, pci);\r\npci->dev_name = pci_name(to_pci_dev(dev));\r\npci->mod_name = mod_name;\r\npci->ctl_name = EDAC_PCI_GENCTL_NAME;\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\npci->edac_check = edac_pci_generic_check;\r\npdata->edac_idx = edac_pci_idx++;\r\nif (edac_pci_add_device(pci, pdata->edac_idx) > 0) {\r\nedac_dbg(3, "failed edac_pci_add_device()\n");\r\nedac_pci_free_ctl_info(pci);\r\nreturn NULL;\r\n}\r\nreturn pci;\r\n}\r\nvoid edac_pci_release_generic_ctl(struct edac_pci_ctl_info *pci)\r\n{\r\nedac_dbg(0, "pci mod=%s\n", pci->mod_name);\r\nedac_pci_del_device(pci->dev);\r\nedac_pci_free_ctl_info(pci);\r\n}
