void mxr_get_mbus_fmt(struct mxr_device *mdev,\r\nstruct v4l2_mbus_framefmt *mbus_fmt)\r\n{\r\nstruct v4l2_subdev *sd;\r\nint ret;\r\nmutex_lock(&mdev->mutex);\r\nsd = to_outsd(mdev);\r\nret = v4l2_subdev_call(sd, video, g_mbus_fmt, mbus_fmt);\r\nWARN(ret, "failed to get mbus_fmt for output %s\n", sd->name);\r\nmutex_unlock(&mdev->mutex);\r\n}\r\nvoid mxr_streamer_get(struct mxr_device *mdev)\r\n{\r\nmutex_lock(&mdev->mutex);\r\n++mdev->n_streamer;\r\nmxr_dbg(mdev, "%s(%d)\n", __func__, mdev->n_streamer);\r\nif (mdev->n_streamer == 1) {\r\nstruct v4l2_subdev *sd = to_outsd(mdev);\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nstruct mxr_resources *res = &mdev->res;\r\nint ret;\r\nif (to_output(mdev)->cookie == 0)\r\nclk_set_parent(res->sclk_mixer, res->sclk_dac);\r\nelse\r\nclk_set_parent(res->sclk_mixer, res->sclk_hdmi);\r\nmxr_reg_s_output(mdev, to_output(mdev)->cookie);\r\nret = v4l2_subdev_call(sd, video, g_mbus_fmt, &mbus_fmt);\r\nWARN(ret, "failed to get mbus_fmt for output %s\n", sd->name);\r\nret = v4l2_subdev_call(sd, video, s_stream, 1);\r\nWARN(ret, "starting stream failed for output %s\n", sd->name);\r\nmxr_reg_set_mbus_fmt(mdev, &mbus_fmt);\r\nmxr_reg_streamon(mdev);\r\nret = mxr_reg_wait4vsync(mdev);\r\nWARN(ret, "failed to get vsync (%d) from output\n", ret);\r\n}\r\nmutex_unlock(&mdev->mutex);\r\nmxr_reg_dump(mdev);\r\n}\r\nvoid mxr_streamer_put(struct mxr_device *mdev)\r\n{\r\nmutex_lock(&mdev->mutex);\r\n--mdev->n_streamer;\r\nmxr_dbg(mdev, "%s(%d)\n", __func__, mdev->n_streamer);\r\nif (mdev->n_streamer == 0) {\r\nint ret;\r\nstruct v4l2_subdev *sd = to_outsd(mdev);\r\nmxr_reg_streamoff(mdev);\r\nret = mxr_reg_wait4vsync(mdev);\r\nWARN(ret, "failed to get vsync (%d) from output\n", ret);\r\nret = v4l2_subdev_call(sd, video, s_stream, 0);\r\nWARN(ret, "stopping stream failed for output %s\n", sd->name);\r\n}\r\nWARN(mdev->n_streamer < 0, "negative number of streamers (%d)\n",\r\nmdev->n_streamer);\r\nmutex_unlock(&mdev->mutex);\r\nmxr_reg_dump(mdev);\r\n}\r\nvoid mxr_output_get(struct mxr_device *mdev)\r\n{\r\nmutex_lock(&mdev->mutex);\r\n++mdev->n_output;\r\nmxr_dbg(mdev, "%s(%d)\n", __func__, mdev->n_output);\r\nif (mdev->n_output == 1)\r\nv4l2_subdev_call(to_outsd(mdev), core, s_power, 1);\r\nmutex_unlock(&mdev->mutex);\r\n}\r\nvoid mxr_output_put(struct mxr_device *mdev)\r\n{\r\nmutex_lock(&mdev->mutex);\r\n--mdev->n_output;\r\nmxr_dbg(mdev, "%s(%d)\n", __func__, mdev->n_output);\r\nif (mdev->n_output == 0)\r\nv4l2_subdev_call(to_outsd(mdev), core, s_power, 0);\r\nWARN(mdev->n_output < 0, "negative number of output users (%d)\n",\r\nmdev->n_output);\r\nmutex_unlock(&mdev->mutex);\r\n}\r\nint mxr_power_get(struct mxr_device *mdev)\r\n{\r\nint ret = pm_runtime_get_sync(mdev->dev);\r\nif (IS_ERR_VALUE(ret))\r\nreturn ret;\r\nreturn 0;\r\n}\r\nvoid mxr_power_put(struct mxr_device *mdev)\r\n{\r\npm_runtime_put_sync(mdev->dev);\r\n}\r\nstatic int mxr_acquire_plat_resources(struct mxr_device *mdev,\r\nstruct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint ret;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mxr");\r\nif (res == NULL) {\r\nmxr_err(mdev, "get memory resource failed.\n");\r\nret = -ENXIO;\r\ngoto fail;\r\n}\r\nmdev->res.mxr_regs = ioremap(res->start, resource_size(res));\r\nif (mdev->res.mxr_regs == NULL) {\r\nmxr_err(mdev, "register mapping failed.\n");\r\nret = -ENXIO;\r\ngoto fail;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "vp");\r\nif (res == NULL) {\r\nmxr_err(mdev, "get memory resource failed.\n");\r\nret = -ENXIO;\r\ngoto fail_mxr_regs;\r\n}\r\nmdev->res.vp_regs = ioremap(res->start, resource_size(res));\r\nif (mdev->res.vp_regs == NULL) {\r\nmxr_err(mdev, "register mapping failed.\n");\r\nret = -ENXIO;\r\ngoto fail_mxr_regs;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_IRQ, "irq");\r\nif (res == NULL) {\r\nmxr_err(mdev, "get interrupt resource failed.\n");\r\nret = -ENXIO;\r\ngoto fail_vp_regs;\r\n}\r\nret = request_irq(res->start, mxr_irq_handler, 0, "s5p-mixer", mdev);\r\nif (ret) {\r\nmxr_err(mdev, "request interrupt failed.\n");\r\ngoto fail_vp_regs;\r\n}\r\nmdev->res.irq = res->start;\r\nreturn 0;\r\nfail_vp_regs:\r\niounmap(mdev->res.vp_regs);\r\nfail_mxr_regs:\r\niounmap(mdev->res.mxr_regs);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic void mxr_resource_clear_clocks(struct mxr_resources *res)\r\n{\r\nres->mixer = ERR_PTR(-EINVAL);\r\nres->vp = ERR_PTR(-EINVAL);\r\nres->sclk_mixer = ERR_PTR(-EINVAL);\r\nres->sclk_hdmi = ERR_PTR(-EINVAL);\r\nres->sclk_dac = ERR_PTR(-EINVAL);\r\n}\r\nstatic void mxr_release_plat_resources(struct mxr_device *mdev)\r\n{\r\nfree_irq(mdev->res.irq, mdev);\r\niounmap(mdev->res.vp_regs);\r\niounmap(mdev->res.mxr_regs);\r\n}\r\nstatic void mxr_release_clocks(struct mxr_device *mdev)\r\n{\r\nstruct mxr_resources *res = &mdev->res;\r\nif (!IS_ERR(res->sclk_dac))\r\nclk_put(res->sclk_dac);\r\nif (!IS_ERR(res->sclk_hdmi))\r\nclk_put(res->sclk_hdmi);\r\nif (!IS_ERR(res->sclk_mixer))\r\nclk_put(res->sclk_mixer);\r\nif (!IS_ERR(res->vp))\r\nclk_put(res->vp);\r\nif (!IS_ERR(res->mixer))\r\nclk_put(res->mixer);\r\n}\r\nstatic int mxr_acquire_clocks(struct mxr_device *mdev)\r\n{\r\nstruct mxr_resources *res = &mdev->res;\r\nstruct device *dev = mdev->dev;\r\nmxr_resource_clear_clocks(res);\r\nres->mixer = clk_get(dev, "mixer");\r\nif (IS_ERR(res->mixer)) {\r\nmxr_err(mdev, "failed to get clock 'mixer'\n");\r\ngoto fail;\r\n}\r\nres->vp = clk_get(dev, "vp");\r\nif (IS_ERR(res->vp)) {\r\nmxr_err(mdev, "failed to get clock 'vp'\n");\r\ngoto fail;\r\n}\r\nres->sclk_mixer = clk_get(dev, "sclk_mixer");\r\nif (IS_ERR(res->sclk_mixer)) {\r\nmxr_err(mdev, "failed to get clock 'sclk_mixer'\n");\r\ngoto fail;\r\n}\r\nres->sclk_hdmi = clk_get(dev, "sclk_hdmi");\r\nif (IS_ERR(res->sclk_hdmi)) {\r\nmxr_err(mdev, "failed to get clock 'sclk_hdmi'\n");\r\ngoto fail;\r\n}\r\nres->sclk_dac = clk_get(dev, "sclk_dac");\r\nif (IS_ERR(res->sclk_dac)) {\r\nmxr_err(mdev, "failed to get clock 'sclk_dac'\n");\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nmxr_release_clocks(mdev);\r\nreturn -ENODEV;\r\n}\r\nstatic int mxr_acquire_resources(struct mxr_device *mdev,\r\nstruct platform_device *pdev)\r\n{\r\nint ret;\r\nret = mxr_acquire_plat_resources(mdev, pdev);\r\nif (ret)\r\ngoto fail;\r\nret = mxr_acquire_clocks(mdev);\r\nif (ret)\r\ngoto fail_plat;\r\nmxr_info(mdev, "resources acquired\n");\r\nreturn 0;\r\nfail_plat:\r\nmxr_release_plat_resources(mdev);\r\nfail:\r\nmxr_err(mdev, "resources acquire failed\n");\r\nreturn ret;\r\n}\r\nstatic void mxr_release_resources(struct mxr_device *mdev)\r\n{\r\nmxr_release_clocks(mdev);\r\nmxr_release_plat_resources(mdev);\r\nmemset(&mdev->res, 0, sizeof(mdev->res));\r\nmxr_resource_clear_clocks(&mdev->res);\r\n}\r\nstatic void mxr_release_layers(struct mxr_device *mdev)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mdev->layer); ++i)\r\nif (mdev->layer[i])\r\nmxr_layer_release(mdev->layer[i]);\r\n}\r\nstatic int mxr_acquire_layers(struct mxr_device *mdev,\r\nstruct mxr_platform_data *pdata)\r\n{\r\nmdev->layer[0] = mxr_graph_layer_create(mdev, 0);\r\nmdev->layer[1] = mxr_graph_layer_create(mdev, 1);\r\nmdev->layer[2] = mxr_vp_layer_create(mdev, 0);\r\nif (!mdev->layer[0] || !mdev->layer[1] || !mdev->layer[2]) {\r\nmxr_err(mdev, "failed to acquire layers\n");\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nmxr_release_layers(mdev);\r\nreturn -ENODEV;\r\n}\r\nstatic int mxr_runtime_resume(struct device *dev)\r\n{\r\nstruct mxr_device *mdev = to_mdev(dev);\r\nstruct mxr_resources *res = &mdev->res;\r\nmxr_dbg(mdev, "resume - start\n");\r\nmutex_lock(&mdev->mutex);\r\nclk_enable(res->mixer);\r\nclk_enable(res->vp);\r\nclk_enable(res->sclk_mixer);\r\nmxr_reg_reset(mdev);\r\nmxr_dbg(mdev, "resume - finished\n");\r\nmutex_unlock(&mdev->mutex);\r\nreturn 0;\r\n}\r\nstatic int mxr_runtime_suspend(struct device *dev)\r\n{\r\nstruct mxr_device *mdev = to_mdev(dev);\r\nstruct mxr_resources *res = &mdev->res;\r\nmxr_dbg(mdev, "suspend - start\n");\r\nmutex_lock(&mdev->mutex);\r\nclk_disable(res->sclk_mixer);\r\nclk_disable(res->vp);\r\nclk_disable(res->mixer);\r\nmutex_unlock(&mdev->mutex);\r\nmxr_dbg(mdev, "suspend - finished\n");\r\nreturn 0;\r\n}\r\nstatic int mxr_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mxr_platform_data *pdata = dev->platform_data;\r\nstruct mxr_device *mdev;\r\nint ret;\r\ndev_info(dev, "probe start\n");\r\nmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\r\nif (!mdev) {\r\ndev_err(dev, "not enough memory.\n");\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nmdev->dev = dev;\r\nmutex_init(&mdev->mutex);\r\nspin_lock_init(&mdev->reg_slock);\r\ninit_waitqueue_head(&mdev->event_queue);\r\nret = mxr_acquire_resources(mdev, pdev);\r\nif (ret)\r\ngoto fail_mem;\r\nret = mxr_acquire_video(mdev, mxr_output_conf,\r\nARRAY_SIZE(mxr_output_conf));\r\nif (ret)\r\ngoto fail_resources;\r\nret = mxr_acquire_layers(mdev, pdata);\r\nif (ret)\r\ngoto fail_video;\r\npm_runtime_enable(dev);\r\nmxr_info(mdev, "probe successful\n");\r\nreturn 0;\r\nfail_video:\r\nmxr_release_video(mdev);\r\nfail_resources:\r\nmxr_release_resources(mdev);\r\nfail_mem:\r\nkfree(mdev);\r\nfail:\r\ndev_info(dev, "probe failed\n");\r\nreturn ret;\r\n}\r\nstatic int mxr_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mxr_device *mdev = to_mdev(dev);\r\npm_runtime_disable(dev);\r\nmxr_release_layers(mdev);\r\nmxr_release_video(mdev);\r\nmxr_release_resources(mdev);\r\nkfree(mdev);\r\ndev_info(dev, "remove successful\n");\r\nreturn 0;\r\n}\r\nstatic int __init mxr_init(void)\r\n{\r\nint i, ret;\r\nstatic const char banner[] __initconst =\r\n"Samsung TV Mixer driver, "\r\n"(c) 2010-2011 Samsung Electronics Co., Ltd.\n";\r\npr_info("%s\n", banner);\r\nfor (i = 0; i < ARRAY_SIZE(mxr_output_conf); ++i)\r\nrequest_module(mxr_output_conf[i].module_name);\r\nret = platform_driver_register(&mxr_driver);\r\nif (ret != 0) {\r\npr_err("s5p-tv: registration of MIXER driver failed\n");\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit mxr_exit(void)\r\n{\r\nplatform_driver_unregister(&mxr_driver);\r\n}
