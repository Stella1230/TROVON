int string_get_size(u64 size, const enum string_size_units units,\r\nchar *buf, int len)\r\n{\r\nstatic const char *units_10[] = { "B", "kB", "MB", "GB", "TB", "PB",\r\n"EB", "ZB", "YB", NULL};\r\nstatic const char *units_2[] = {"B", "KiB", "MiB", "GiB", "TiB", "PiB",\r\n"EiB", "ZiB", "YiB", NULL };\r\nstatic const char **units_str[] = {\r\n[STRING_UNITS_10] = units_10,\r\n[STRING_UNITS_2] = units_2,\r\n};\r\nstatic const unsigned int divisor[] = {\r\n[STRING_UNITS_10] = 1000,\r\n[STRING_UNITS_2] = 1024,\r\n};\r\nint i, j;\r\nu64 remainder = 0, sf_cap;\r\nchar tmp[8];\r\ntmp[0] = '\0';\r\ni = 0;\r\nif (size >= divisor[units]) {\r\nwhile (size >= divisor[units] && units_str[units][i]) {\r\nremainder = do_div(size, divisor[units]);\r\ni++;\r\n}\r\nsf_cap = size;\r\nfor (j = 0; sf_cap*10 < 1000; j++)\r\nsf_cap *= 10;\r\nif (j) {\r\nremainder *= 1000;\r\ndo_div(remainder, divisor[units]);\r\nsnprintf(tmp, sizeof(tmp), ".%03lld",\r\n(unsigned long long)remainder);\r\ntmp[j+1] = '\0';\r\n}\r\n}\r\nsnprintf(buf, len, "%lld%s %s", (unsigned long long)size,\r\ntmp, units_str[units][i]);\r\nreturn 0;\r\n}\r\nstatic bool unescape_space(char **src, char **dst)\r\n{\r\nchar *p = *dst, *q = *src;\r\nswitch (*q) {\r\ncase 'n':\r\n*p = '\n';\r\nbreak;\r\ncase 'r':\r\n*p = '\r';\r\nbreak;\r\ncase 't':\r\n*p = '\t';\r\nbreak;\r\ncase 'v':\r\n*p = '\v';\r\nbreak;\r\ncase 'f':\r\n*p = '\f';\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\n*dst += 1;\r\n*src += 1;\r\nreturn true;\r\n}\r\nstatic bool unescape_octal(char **src, char **dst)\r\n{\r\nchar *p = *dst, *q = *src;\r\nu8 num;\r\nif (isodigit(*q) == 0)\r\nreturn false;\r\nnum = (*q++) & 7;\r\nwhile (num < 32 && isodigit(*q) && (q - *src < 3)) {\r\nnum <<= 3;\r\nnum += (*q++) & 7;\r\n}\r\n*p = num;\r\n*dst += 1;\r\n*src = q;\r\nreturn true;\r\n}\r\nstatic bool unescape_hex(char **src, char **dst)\r\n{\r\nchar *p = *dst, *q = *src;\r\nint digit;\r\nu8 num;\r\nif (*q++ != 'x')\r\nreturn false;\r\nnum = digit = hex_to_bin(*q++);\r\nif (digit < 0)\r\nreturn false;\r\ndigit = hex_to_bin(*q);\r\nif (digit >= 0) {\r\nq++;\r\nnum = (num << 4) | digit;\r\n}\r\n*p = num;\r\n*dst += 1;\r\n*src = q;\r\nreturn true;\r\n}\r\nstatic bool unescape_special(char **src, char **dst)\r\n{\r\nchar *p = *dst, *q = *src;\r\nswitch (*q) {\r\ncase '\"':\r\n*p = '\"';\r\nbreak;\r\ncase '\\':\r\n*p = '\\';\r\nbreak;\r\ncase 'a':\r\n*p = '\a';\r\nbreak;\r\ncase 'e':\r\n*p = '\e';\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\n*dst += 1;\r\n*src += 1;\r\nreturn true;\r\n}\r\nint string_unescape(char *src, char *dst, size_t size, unsigned int flags)\r\n{\r\nchar *out = dst;\r\nwhile (*src && --size) {\r\nif (src[0] == '\\' && src[1] != '\0' && size > 1) {\r\nsrc++;\r\nsize--;\r\nif (flags & UNESCAPE_SPACE &&\r\nunescape_space(&src, &out))\r\ncontinue;\r\nif (flags & UNESCAPE_OCTAL &&\r\nunescape_octal(&src, &out))\r\ncontinue;\r\nif (flags & UNESCAPE_HEX &&\r\nunescape_hex(&src, &out))\r\ncontinue;\r\nif (flags & UNESCAPE_SPECIAL &&\r\nunescape_special(&src, &out))\r\ncontinue;\r\n*out++ = '\\';\r\n}\r\n*out++ = *src++;\r\n}\r\n*out = '\0';\r\nreturn out - dst;\r\n}
