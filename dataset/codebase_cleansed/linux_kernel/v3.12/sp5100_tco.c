static void tco_timer_start(void)\r\n{\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tco_lock, flags);\r\nval = readl(SP5100_WDT_CONTROL(tcobase));\r\nval |= SP5100_WDT_START_STOP_BIT;\r\nwritel(val, SP5100_WDT_CONTROL(tcobase));\r\nspin_unlock_irqrestore(&tco_lock, flags);\r\n}\r\nstatic void tco_timer_stop(void)\r\n{\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tco_lock, flags);\r\nval = readl(SP5100_WDT_CONTROL(tcobase));\r\nval &= ~SP5100_WDT_START_STOP_BIT;\r\nwritel(val, SP5100_WDT_CONTROL(tcobase));\r\nspin_unlock_irqrestore(&tco_lock, flags);\r\n}\r\nstatic void tco_timer_keepalive(void)\r\n{\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tco_lock, flags);\r\nval = readl(SP5100_WDT_CONTROL(tcobase));\r\nval |= SP5100_WDT_TRIGGER_BIT;\r\nwritel(val, SP5100_WDT_CONTROL(tcobase));\r\nspin_unlock_irqrestore(&tco_lock, flags);\r\n}\r\nstatic int tco_timer_set_heartbeat(int t)\r\n{\r\nunsigned long flags;\r\nif (t < 0 || t > 0xffff)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&tco_lock, flags);\r\nwritel(t, SP5100_WDT_COUNT(tcobase));\r\nspin_unlock_irqrestore(&tco_lock, flags);\r\nheartbeat = t;\r\nreturn 0;\r\n}\r\nstatic void tco_timer_enable(void)\r\n{\r\nint val;\r\nif (sp5100_tco_pci->revision >= 0x40) {\r\noutb(SB800_PM_WATCHDOG_CONFIG, SB800_IO_PM_INDEX_REG);\r\nval = inb(SB800_IO_PM_DATA_REG);\r\nval |= SB800_PM_WATCHDOG_SECOND_RES;\r\noutb(val, SB800_IO_PM_DATA_REG);\r\noutb(SB800_PM_WATCHDOG_CONTROL, SB800_IO_PM_INDEX_REG);\r\nval = inb(SB800_IO_PM_DATA_REG);\r\nval |= SB800_PCI_WATCHDOG_DECODE_EN;\r\nval &= ~SB800_PM_WATCHDOG_DISABLE;\r\noutb(val, SB800_IO_PM_DATA_REG);\r\n} else {\r\npci_read_config_dword(sp5100_tco_pci,\r\nSP5100_PCI_WATCHDOG_MISC_REG,\r\n&val);\r\nval |= SP5100_PCI_WATCHDOG_DECODE_EN;\r\npci_write_config_dword(sp5100_tco_pci,\r\nSP5100_PCI_WATCHDOG_MISC_REG,\r\nval);\r\noutb(SP5100_PM_WATCHDOG_CONTROL, SP5100_IO_PM_INDEX_REG);\r\nval = inb(SP5100_IO_PM_DATA_REG);\r\nval |= SP5100_PM_WATCHDOG_SECOND_RES;\r\nval &= ~SP5100_PM_WATCHDOG_DISABLE;\r\noutb(val, SP5100_IO_PM_DATA_REG);\r\n}\r\n}\r\nstatic int sp5100_tco_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &timer_alive))\r\nreturn -EBUSY;\r\ntco_timer_start();\r\ntco_timer_keepalive();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int sp5100_tco_release(struct inode *inode, struct file *file)\r\n{\r\nif (tco_expect_close == 42) {\r\ntco_timer_stop();\r\n} else {\r\npr_crit("Unexpected close, not stopping watchdog!\n");\r\ntco_timer_keepalive();\r\n}\r\nclear_bit(0, &timer_alive);\r\ntco_expect_close = 0;\r\nreturn 0;\r\n}\r\nstatic ssize_t sp5100_tco_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\ntco_expect_close = 0;\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\ntco_expect_close = 42;\r\n}\r\n}\r\ntco_timer_keepalive();\r\n}\r\nreturn len;\r\n}\r\nstatic long sp5100_tco_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint new_options, retval = -EINVAL;\r\nint new_heartbeat;\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_SETTIMEOUT |\r\nWDIOF_KEEPALIVEPING |\r\nWDIOF_MAGICCLOSE,\r\n.firmware_version = 0,\r\n.identity = TCO_MODULE_NAME,\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp, &ident,\r\nsizeof(ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_SETOPTIONS:\r\nif (get_user(new_options, p))\r\nreturn -EFAULT;\r\nif (new_options & WDIOS_DISABLECARD) {\r\ntco_timer_stop();\r\nretval = 0;\r\n}\r\nif (new_options & WDIOS_ENABLECARD) {\r\ntco_timer_start();\r\ntco_timer_keepalive();\r\nretval = 0;\r\n}\r\nreturn retval;\r\ncase WDIOC_KEEPALIVE:\r\ntco_timer_keepalive();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_heartbeat, p))\r\nreturn -EFAULT;\r\nif (tco_timer_set_heartbeat(new_heartbeat))\r\nreturn -EINVAL;\r\ntco_timer_keepalive();\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(heartbeat, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic unsigned char sp5100_tco_setupdevice(void)\r\n{\r\nstruct pci_dev *dev = NULL;\r\nconst char *dev_name = NULL;\r\nu32 val;\r\nu32 index_reg, data_reg, base_addr;\r\nfor_each_pci_dev(dev) {\r\nif (pci_match_id(sp5100_tco_pci_tbl, dev) != NULL) {\r\nsp5100_tco_pci = dev;\r\nbreak;\r\n}\r\n}\r\nif (!sp5100_tco_pci)\r\nreturn 0;\r\npr_info("PCI Revision ID: 0x%x\n", sp5100_tco_pci->revision);\r\nif (sp5100_tco_pci->revision >= 0x40) {\r\ndev_name = SB800_DEVNAME;\r\nindex_reg = SB800_IO_PM_INDEX_REG;\r\ndata_reg = SB800_IO_PM_DATA_REG;\r\nbase_addr = SB800_PM_WATCHDOG_BASE;\r\n} else {\r\ndev_name = SP5100_DEVNAME;\r\nindex_reg = SP5100_IO_PM_INDEX_REG;\r\ndata_reg = SP5100_IO_PM_DATA_REG;\r\nbase_addr = SP5100_PM_WATCHDOG_BASE;\r\n}\r\npm_iobase = SP5100_IO_PM_INDEX_REG;\r\nif (!request_region(pm_iobase, SP5100_PM_IOPORTS_SIZE, dev_name)) {\r\npr_err("I/O address 0x%04x already in use\n", pm_iobase);\r\ngoto exit;\r\n}\r\noutb(base_addr+3, index_reg);\r\nval = inb(data_reg);\r\noutb(base_addr+2, index_reg);\r\nval = val << 8 | inb(data_reg);\r\noutb(base_addr+1, index_reg);\r\nval = val << 8 | inb(data_reg);\r\noutb(base_addr+0, index_reg);\r\nval = val << 8 | (inb(data_reg) & 0xf8);\r\npr_debug("Got 0x%04x from indirect I/O\n", val);\r\nif (request_mem_region_exclusive(val, SP5100_WDT_MEM_MAP_SIZE,\r\ndev_name))\r\ngoto setup_wdt;\r\nelse\r\npr_debug("MMIO address 0x%04x already in use\n", val);\r\nif (sp5100_tco_pci->revision >= 0x40) {\r\noutb(SB800_PM_ACPI_MMIO_EN+3, SB800_IO_PM_INDEX_REG);\r\nval = inb(SB800_IO_PM_DATA_REG);\r\noutb(SB800_PM_ACPI_MMIO_EN+2, SB800_IO_PM_INDEX_REG);\r\nval = val << 8 | inb(SB800_IO_PM_DATA_REG);\r\noutb(SB800_PM_ACPI_MMIO_EN+1, SB800_IO_PM_INDEX_REG);\r\nval = val << 8 | inb(SB800_IO_PM_DATA_REG);\r\noutb(SB800_PM_ACPI_MMIO_EN+0, SB800_IO_PM_INDEX_REG);\r\nval = val << 8 | inb(SB800_IO_PM_DATA_REG);\r\n} else {\r\npci_read_config_dword(sp5100_tco_pci,\r\nSP5100_SB_RESOURCE_MMIO_BASE, &val);\r\n}\r\nif ((val & (SB800_ACPI_MMIO_DECODE_EN | SB800_ACPI_MMIO_SEL)) ==\r\nSB800_ACPI_MMIO_DECODE_EN) {\r\nval &= ~0xFFF;\r\nval += SB800_PM_WDT_MMIO_OFFSET;\r\nif (request_mem_region_exclusive(val, SP5100_WDT_MEM_MAP_SIZE,\r\ndev_name)) {\r\npr_debug("Got 0x%04x from SBResource_MMIO register\n",\r\nval);\r\ngoto setup_wdt;\r\n} else\r\npr_debug("MMIO address 0x%04x already in use\n", val);\r\n} else\r\npr_debug("SBResource_MMIO is disabled(0x%04x)\n", val);\r\npr_notice("failed to find MMIO address, giving up.\n");\r\ngoto unreg_region;\r\nsetup_wdt:\r\ntcobase_phys = val;\r\ntcobase = ioremap(val, SP5100_WDT_MEM_MAP_SIZE);\r\nif (!tcobase) {\r\npr_err("failed to get tcobase address\n");\r\ngoto unreg_mem_region;\r\n}\r\npr_info("Using 0x%04x for watchdog MMIO address\n", val);\r\ntco_timer_enable();\r\nval = readl(SP5100_WDT_CONTROL(tcobase));\r\ntco_wdt_fired = val & SP5100_PM_WATCHDOG_FIRED;\r\nval &= ~SP5100_PM_WATCHDOG_ACTION_RESET;\r\nwritel(val, SP5100_WDT_CONTROL(tcobase));\r\ntco_timer_set_heartbeat(heartbeat);\r\ntco_timer_stop();\r\nreturn 1;\r\nunreg_mem_region:\r\nrelease_mem_region(tcobase_phys, SP5100_WDT_MEM_MAP_SIZE);\r\nunreg_region:\r\nrelease_region(pm_iobase, SP5100_PM_IOPORTS_SIZE);\r\nexit:\r\nreturn 0;\r\n}\r\nstatic int sp5100_tco_init(struct platform_device *dev)\r\n{\r\nint ret;\r\nif (!sp5100_tco_setupdevice())\r\nreturn -ENODEV;\r\npr_info("Last reboot was %striggered by watchdog.\n",\r\ntco_wdt_fired ? "" : "not ");\r\nif (tco_timer_set_heartbeat(heartbeat)) {\r\nheartbeat = WATCHDOG_HEARTBEAT;\r\ntco_timer_set_heartbeat(heartbeat);\r\n}\r\nret = misc_register(&sp5100_tco_miscdev);\r\nif (ret != 0) {\r\npr_err("cannot register miscdev on minor=%d (err=%d)\n",\r\nWATCHDOG_MINOR, ret);\r\ngoto exit;\r\n}\r\nclear_bit(0, &timer_alive);\r\npr_info("initialized (0x%p). heartbeat=%d sec (nowayout=%d)\n",\r\ntcobase, heartbeat, nowayout);\r\nreturn 0;\r\nexit:\r\niounmap(tcobase);\r\nrelease_mem_region(tcobase_phys, SP5100_WDT_MEM_MAP_SIZE);\r\nrelease_region(pm_iobase, SP5100_PM_IOPORTS_SIZE);\r\nreturn ret;\r\n}\r\nstatic void sp5100_tco_cleanup(void)\r\n{\r\nif (!nowayout)\r\ntco_timer_stop();\r\nmisc_deregister(&sp5100_tco_miscdev);\r\niounmap(tcobase);\r\nrelease_mem_region(tcobase_phys, SP5100_WDT_MEM_MAP_SIZE);\r\nrelease_region(pm_iobase, SP5100_PM_IOPORTS_SIZE);\r\n}\r\nstatic int sp5100_tco_remove(struct platform_device *dev)\r\n{\r\nif (tcobase)\r\nsp5100_tco_cleanup();\r\nreturn 0;\r\n}\r\nstatic void sp5100_tco_shutdown(struct platform_device *dev)\r\n{\r\ntco_timer_stop();\r\n}\r\nstatic int __init sp5100_tco_init_module(void)\r\n{\r\nint err;\r\npr_info("SP5100/SB800 TCO WatchDog Timer Driver v%s\n", TCO_VERSION);\r\nerr = platform_driver_register(&sp5100_tco_driver);\r\nif (err)\r\nreturn err;\r\nsp5100_tco_platform_device = platform_device_register_simple(\r\nTCO_MODULE_NAME, -1, NULL, 0);\r\nif (IS_ERR(sp5100_tco_platform_device)) {\r\nerr = PTR_ERR(sp5100_tco_platform_device);\r\ngoto unreg_platform_driver;\r\n}\r\nreturn 0;\r\nunreg_platform_driver:\r\nplatform_driver_unregister(&sp5100_tco_driver);\r\nreturn err;\r\n}\r\nstatic void __exit sp5100_tco_cleanup_module(void)\r\n{\r\nplatform_device_unregister(sp5100_tco_platform_device);\r\nplatform_driver_unregister(&sp5100_tco_driver);\r\npr_info("SP5100/SB800 TCO Watchdog Module Unloaded\n");\r\n}
