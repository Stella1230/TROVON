static struct ib_mw *nes_alloc_mw(struct ib_pd *ibpd, enum ib_mw_type type)\r\n{\r\nstruct nes_pd *nespd = to_nespd(ibpd);\r\nstruct nes_vnic *nesvnic = to_nesvnic(ibpd->device);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nstruct nes_cqp_request *cqp_request;\r\nstruct nes_mr *nesmr;\r\nstruct ib_mw *ibmw;\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nint ret;\r\nu32 stag;\r\nu32 stag_index = 0;\r\nu32 next_stag_index = 0;\r\nu32 driver_key = 0;\r\nu8 stag_key = 0;\r\nif (type != IB_MW_TYPE_1)\r\nreturn ERR_PTR(-EINVAL);\r\nget_random_bytes(&next_stag_index, sizeof(next_stag_index));\r\nstag_key = (u8)next_stag_index;\r\ndriver_key = 0;\r\nnext_stag_index >>= 8;\r\nnext_stag_index %= nesadapter->max_mr;\r\nret = nes_alloc_resource(nesadapter, nesadapter->allocated_mrs,\r\nnesadapter->max_mr, &stag_index, &next_stag_index, NES_RESOURCE_MW);\r\nif (ret) {\r\nreturn ERR_PTR(ret);\r\n}\r\nnesmr = kzalloc(sizeof(*nesmr), GFP_KERNEL);\r\nif (!nesmr) {\r\nnes_free_resource(nesadapter, nesadapter->allocated_mrs, stag_index);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstag = stag_index << 8;\r\nstag |= driver_key;\r\nstag += (u32)stag_key;\r\nnes_debug(NES_DBG_MR, "Registering STag 0x%08X, index = 0x%08X\n",\r\nstag, stag_index);\r\ncqp_request = nes_get_cqp_request(nesdev);\r\nif (cqp_request == NULL) {\r\nkfree(nesmr);\r\nnes_free_resource(nesadapter, nesadapter->allocated_mrs, stag_index);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ncqp_request->waiting = 1;\r\ncqp_wqe = &cqp_request->cqp_wqe;\r\ncqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX] =\r\ncpu_to_le32( NES_CQP_ALLOCATE_STAG | NES_CQP_STAG_RIGHTS_REMOTE_READ |\r\nNES_CQP_STAG_RIGHTS_REMOTE_WRITE | NES_CQP_STAG_VA_TO |\r\nNES_CQP_STAG_REM_ACC_EN);\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_STAG_WQE_LEN_HIGH_PD_IDX, (nespd->pd_id & 0x00007fff));\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_STAG_WQE_STAG_IDX, stag);\r\natomic_set(&cqp_request->refcount, 2);\r\nnes_post_cqp_request(nesdev, cqp_request);\r\nret = wait_event_timeout(cqp_request->waitq, (cqp_request->request_done != 0),\r\nNES_EVENT_TIMEOUT);\r\nnes_debug(NES_DBG_MR, "Register STag 0x%08X completed, wait_event_timeout ret = %u,"\r\n" CQP Major:Minor codes = 0x%04X:0x%04X.\n",\r\nstag, ret, cqp_request->major_code, cqp_request->minor_code);\r\nif ((!ret) || (cqp_request->major_code)) {\r\nnes_put_cqp_request(nesdev, cqp_request);\r\nkfree(nesmr);\r\nnes_free_resource(nesadapter, nesadapter->allocated_mrs, stag_index);\r\nif (!ret) {\r\nreturn ERR_PTR(-ETIME);\r\n} else {\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\n}\r\nnes_put_cqp_request(nesdev, cqp_request);\r\nnesmr->ibmw.rkey = stag;\r\nnesmr->mode = IWNES_MEMREG_TYPE_MW;\r\nibmw = &nesmr->ibmw;\r\nnesmr->pbl_4k = 0;\r\nnesmr->pbls_used = 0;\r\nreturn ibmw;\r\n}\r\nstatic int nes_dealloc_mw(struct ib_mw *ibmw)\r\n{\r\nstruct nes_mr *nesmr = to_nesmw(ibmw);\r\nstruct nes_vnic *nesvnic = to_nesvnic(ibmw->device);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nstruct nes_cqp_request *cqp_request;\r\nint err = 0;\r\nint ret;\r\ncqp_request = nes_get_cqp_request(nesdev);\r\nif (cqp_request == NULL) {\r\nnes_debug(NES_DBG_MR, "Failed to get a cqp_request.\n");\r\nreturn -ENOMEM;\r\n}\r\ncqp_request->waiting = 1;\r\ncqp_wqe = &cqp_request->cqp_wqe;\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_OPCODE_IDX, NES_CQP_DEALLOCATE_STAG);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_STAG_WQE_STAG_IDX, ibmw->rkey);\r\natomic_set(&cqp_request->refcount, 2);\r\nnes_post_cqp_request(nesdev, cqp_request);\r\nnes_debug(NES_DBG_MR, "Waiting for deallocate STag 0x%08X to complete.\n",\r\nibmw->rkey);\r\nret = wait_event_timeout(cqp_request->waitq, (0 != cqp_request->request_done),\r\nNES_EVENT_TIMEOUT);\r\nnes_debug(NES_DBG_MR, "Deallocate STag completed, wait_event_timeout ret = %u,"\r\n" CQP Major:Minor codes = 0x%04X:0x%04X.\n",\r\nret, cqp_request->major_code, cqp_request->minor_code);\r\nif (!ret)\r\nerr = -ETIME;\r\nelse if (cqp_request->major_code)\r\nerr = -EIO;\r\nnes_put_cqp_request(nesdev, cqp_request);\r\nnes_free_resource(nesadapter, nesadapter->allocated_mrs,\r\n(ibmw->rkey & 0x0fffff00) >> 8);\r\nkfree(nesmr);\r\nreturn err;\r\n}\r\nstatic int nes_bind_mw(struct ib_qp *ibqp, struct ib_mw *ibmw,\r\nstruct ib_mw_bind *ibmw_bind)\r\n{\r\nu64 u64temp;\r\nstruct nes_vnic *nesvnic = to_nesvnic(ibqp->device);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_qp *nesqp = to_nesqp(ibqp);\r\nstruct nes_hw_qp_wqe *wqe;\r\nunsigned long flags = 0;\r\nu32 head;\r\nu32 wqe_misc = 0;\r\nu32 qsize;\r\nif (nesqp->ibqp_state > IB_QPS_RTS)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&nesqp->lock, flags);\r\nhead = nesqp->hwqp.sq_head;\r\nqsize = nesqp->hwqp.sq_tail;\r\nif (((head + (2 * qsize) - nesqp->hwqp.sq_tail) % qsize) == (qsize - 1)) {\r\nspin_unlock_irqrestore(&nesqp->lock, flags);\r\nreturn -ENOMEM;\r\n}\r\nwqe = &nesqp->hwqp.sq_vbase[head];\r\nnes_fill_init_qp_wqe(wqe, nesqp, head);\r\nu64temp = ibmw_bind->wr_id;\r\nset_wqe_64bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_COMP_SCRATCH_LOW_IDX, u64temp);\r\nwqe_misc = NES_IWARP_SQ_OP_BIND;\r\nwqe_misc |= NES_IWARP_SQ_WQE_LOCAL_FENCE;\r\nif (ibmw_bind->send_flags & IB_SEND_SIGNALED)\r\nwqe_misc |= NES_IWARP_SQ_WQE_SIGNALED_COMPL;\r\nif (ibmw_bind->bind_info.mw_access_flags & IB_ACCESS_REMOTE_WRITE)\r\nwqe_misc |= NES_CQP_STAG_RIGHTS_REMOTE_WRITE;\r\nif (ibmw_bind->bind_info.mw_access_flags & IB_ACCESS_REMOTE_READ)\r\nwqe_misc |= NES_CQP_STAG_RIGHTS_REMOTE_READ;\r\nset_wqe_32bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_MISC_IDX, wqe_misc);\r\nset_wqe_32bit_value(wqe->wqe_words, NES_IWARP_SQ_BIND_WQE_MR_IDX,\r\nibmw_bind->bind_info.mr->lkey);\r\nset_wqe_32bit_value(wqe->wqe_words, NES_IWARP_SQ_BIND_WQE_MW_IDX, ibmw->rkey);\r\nset_wqe_32bit_value(wqe->wqe_words, NES_IWARP_SQ_BIND_WQE_LENGTH_LOW_IDX,\r\nibmw_bind->bind_info.length);\r\nwqe->wqe_words[NES_IWARP_SQ_BIND_WQE_LENGTH_HIGH_IDX] = 0;\r\nu64temp = (u64)ibmw_bind->bind_info.addr;\r\nset_wqe_64bit_value(wqe->wqe_words, NES_IWARP_SQ_BIND_WQE_VA_FBO_LOW_IDX, u64temp);\r\nhead++;\r\nif (head >= qsize)\r\nhead = 0;\r\nnesqp->hwqp.sq_head = head;\r\nbarrier();\r\nnes_write32(nesdev->regs+NES_WQE_ALLOC,\r\n(1 << 24) | 0x00800000 | nesqp->hwqp.qp_id);\r\nspin_unlock_irqrestore(&nesqp->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int alloc_fast_reg_mr(struct nes_device *nesdev, struct nes_pd *nespd,\r\nu32 stag, u32 page_count)\r\n{\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nstruct nes_cqp_request *cqp_request;\r\nunsigned long flags;\r\nint ret;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nu32 opcode = 0;\r\nu16 major_code;\r\nu64 region_length = page_count * PAGE_SIZE;\r\ncqp_request = nes_get_cqp_request(nesdev);\r\nif (cqp_request == NULL) {\r\nnes_debug(NES_DBG_MR, "Failed to get a cqp_request.\n");\r\nreturn -ENOMEM;\r\n}\r\nnes_debug(NES_DBG_MR, "alloc_fast_reg_mr: page_count = %d, "\r\n"region_length = %llu\n",\r\npage_count, region_length);\r\ncqp_request->waiting = 1;\r\ncqp_wqe = &cqp_request->cqp_wqe;\r\nspin_lock_irqsave(&nesadapter->pbl_lock, flags);\r\nif (nesadapter->free_4kpbl > 0) {\r\nnesadapter->free_4kpbl--;\r\nspin_unlock_irqrestore(&nesadapter->pbl_lock, flags);\r\n} else {\r\nspin_unlock_irqrestore(&nesadapter->pbl_lock, flags);\r\nnes_debug(NES_DBG_MR, "Out of Pbls\n");\r\nnes_free_cqp_request(nesdev, cqp_request);\r\nreturn -ENOMEM;\r\n}\r\nopcode = NES_CQP_ALLOCATE_STAG | NES_CQP_STAG_MR |\r\nNES_CQP_STAG_PBL_BLK_SIZE | NES_CQP_STAG_VA_TO |\r\nNES_CQP_STAG_REM_ACC_EN;\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_OPCODE_IDX, opcode);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_STAG_WQE_PBL_BLK_COUNT_IDX, 1);\r\ncqp_wqe->wqe_words[NES_CQP_STAG_WQE_LEN_HIGH_PD_IDX] =\r\ncpu_to_le32((u32)(region_length >> 8) & 0xff000000);\r\ncqp_wqe->wqe_words[NES_CQP_STAG_WQE_LEN_HIGH_PD_IDX] |=\r\ncpu_to_le32(nespd->pd_id & 0x00007fff);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_STAG_WQE_STAG_IDX, stag);\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, NES_CQP_STAG_WQE_VA_LOW_IDX, 0);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_STAG_WQE_LEN_LOW_IDX, 0);\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, NES_CQP_STAG_WQE_PA_LOW_IDX, 0);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_STAG_WQE_PBL_LEN_IDX, (page_count * 8));\r\ncqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX] |= cpu_to_le32(NES_CQP_STAG_PBL_BLK_SIZE);\r\nbarrier();\r\natomic_set(&cqp_request->refcount, 2);\r\nnes_post_cqp_request(nesdev, cqp_request);\r\nret = wait_event_timeout(cqp_request->waitq,\r\n(0 != cqp_request->request_done),\r\nNES_EVENT_TIMEOUT);\r\nnes_debug(NES_DBG_MR, "Allocate STag 0x%08X completed, "\r\n"wait_event_timeout ret = %u, CQP Major:Minor codes = "\r\n"0x%04X:0x%04X.\n", stag, ret, cqp_request->major_code,\r\ncqp_request->minor_code);\r\nmajor_code = cqp_request->major_code;\r\nnes_put_cqp_request(nesdev, cqp_request);\r\nif (!ret || major_code) {\r\nspin_lock_irqsave(&nesadapter->pbl_lock, flags);\r\nnesadapter->free_4kpbl++;\r\nspin_unlock_irqrestore(&nesadapter->pbl_lock, flags);\r\n}\r\nif (!ret)\r\nreturn -ETIME;\r\nelse if (major_code)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic struct ib_mr *nes_alloc_fast_reg_mr(struct ib_pd *ibpd, int max_page_list_len)\r\n{\r\nstruct nes_pd *nespd = to_nespd(ibpd);\r\nstruct nes_vnic *nesvnic = to_nesvnic(ibpd->device);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nu32 next_stag_index;\r\nu8 stag_key = 0;\r\nu32 driver_key = 0;\r\nint err = 0;\r\nu32 stag_index = 0;\r\nstruct nes_mr *nesmr;\r\nu32 stag;\r\nint ret;\r\nstruct ib_mr *ibmr;\r\nif (max_page_list_len > (NES_4K_PBL_CHUNK_SIZE / sizeof(u64)))\r\nreturn ERR_PTR(-E2BIG);\r\nget_random_bytes(&next_stag_index, sizeof(next_stag_index));\r\nstag_key = (u8)next_stag_index;\r\nnext_stag_index >>= 8;\r\nnext_stag_index %= nesadapter->max_mr;\r\nerr = nes_alloc_resource(nesadapter, nesadapter->allocated_mrs,\r\nnesadapter->max_mr, &stag_index,\r\n&next_stag_index, NES_RESOURCE_FAST_MR);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nnesmr = kzalloc(sizeof(*nesmr), GFP_KERNEL);\r\nif (!nesmr) {\r\nnes_free_resource(nesadapter, nesadapter->allocated_mrs, stag_index);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstag = stag_index << 8;\r\nstag |= driver_key;\r\nstag += (u32)stag_key;\r\nnes_debug(NES_DBG_MR, "Allocating STag 0x%08X index = 0x%08X\n",\r\nstag, stag_index);\r\nret = alloc_fast_reg_mr(nesdev, nespd, stag, max_page_list_len);\r\nif (ret == 0) {\r\nnesmr->ibmr.rkey = stag;\r\nnesmr->ibmr.lkey = stag;\r\nnesmr->mode = IWNES_MEMREG_TYPE_FMEM;\r\nibmr = &nesmr->ibmr;\r\n} else {\r\nkfree(nesmr);\r\nnes_free_resource(nesadapter, nesadapter->allocated_mrs, stag_index);\r\nibmr = ERR_PTR(-ENOMEM);\r\n}\r\nreturn ibmr;\r\n}\r\nstatic struct ib_fast_reg_page_list *nes_alloc_fast_reg_page_list(\r\nstruct ib_device *ibdev,\r\nint page_list_len)\r\n{\r\nstruct nes_vnic *nesvnic = to_nesvnic(ibdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct ib_fast_reg_page_list *pifrpl;\r\nstruct nes_ib_fast_reg_page_list *pnesfrpl;\r\nif (page_list_len > (NES_4K_PBL_CHUNK_SIZE / sizeof(u64)))\r\nreturn ERR_PTR(-E2BIG);\r\npnesfrpl = kmalloc(sizeof(struct nes_ib_fast_reg_page_list) +\r\npage_list_len * sizeof(u64), GFP_KERNEL);\r\nif (!pnesfrpl)\r\nreturn ERR_PTR(-ENOMEM);\r\npifrpl = &pnesfrpl->ibfrpl;\r\npifrpl->page_list = &pnesfrpl->pbl;\r\npifrpl->max_page_list_len = page_list_len;\r\npnesfrpl->nes_wqe_pbl.kva = pci_alloc_consistent(nesdev->pcidev,\r\npage_list_len * sizeof(u64),\r\n&pnesfrpl->nes_wqe_pbl.paddr);\r\nif (!pnesfrpl->nes_wqe_pbl.kva) {\r\nkfree(pnesfrpl);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nnes_debug(NES_DBG_MR, "nes_alloc_fast_reg_pbl: nes_frpl = %p, "\r\n"ibfrpl = %p, ibfrpl.page_list = %p, pbl.kva = %p, "\r\n"pbl.paddr = %llx\n", pnesfrpl, &pnesfrpl->ibfrpl,\r\npnesfrpl->ibfrpl.page_list, pnesfrpl->nes_wqe_pbl.kva,\r\n(unsigned long long) pnesfrpl->nes_wqe_pbl.paddr);\r\nreturn pifrpl;\r\n}\r\nstatic void nes_free_fast_reg_page_list(struct ib_fast_reg_page_list *pifrpl)\r\n{\r\nstruct nes_vnic *nesvnic = to_nesvnic(pifrpl->device);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_ib_fast_reg_page_list *pnesfrpl;\r\npnesfrpl = container_of(pifrpl, struct nes_ib_fast_reg_page_list, ibfrpl);\r\npci_free_consistent(nesdev->pcidev,\r\npifrpl->max_page_list_len * sizeof(u64),\r\npnesfrpl->nes_wqe_pbl.kva,\r\npnesfrpl->nes_wqe_pbl.paddr);\r\nkfree(pnesfrpl);\r\n}\r\nstatic int nes_query_device(struct ib_device *ibdev, struct ib_device_attr *props)\r\n{\r\nstruct nes_vnic *nesvnic = to_nesvnic(ibdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_ib_device *nesibdev = nesvnic->nesibdev;\r\nmemset(props, 0, sizeof(*props));\r\nmemcpy(&props->sys_image_guid, nesvnic->netdev->dev_addr, 6);\r\nprops->fw_ver = nesdev->nesadapter->firmware_version;\r\nprops->device_cap_flags = nesdev->nesadapter->device_cap_flags;\r\nprops->vendor_id = nesdev->nesadapter->vendor_id;\r\nprops->vendor_part_id = nesdev->nesadapter->vendor_part_id;\r\nprops->hw_ver = nesdev->nesadapter->hw_rev;\r\nprops->max_mr_size = 0x80000000;\r\nprops->max_qp = nesibdev->max_qp;\r\nprops->max_qp_wr = nesdev->nesadapter->max_qp_wr - 2;\r\nprops->max_sge = nesdev->nesadapter->max_sge;\r\nprops->max_cq = nesibdev->max_cq;\r\nprops->max_cqe = nesdev->nesadapter->max_cqe;\r\nprops->max_mr = nesibdev->max_mr;\r\nprops->max_mw = nesibdev->max_mr;\r\nprops->max_pd = nesibdev->max_pd;\r\nprops->max_sge_rd = 1;\r\nswitch (nesdev->nesadapter->max_irrq_wr) {\r\ncase 0:\r\nprops->max_qp_rd_atom = 2;\r\nbreak;\r\ncase 1:\r\nprops->max_qp_rd_atom = 8;\r\nbreak;\r\ncase 2:\r\nprops->max_qp_rd_atom = 32;\r\nbreak;\r\ncase 3:\r\nprops->max_qp_rd_atom = 64;\r\nbreak;\r\ndefault:\r\nprops->max_qp_rd_atom = 0;\r\n}\r\nprops->max_qp_init_rd_atom = props->max_qp_rd_atom;\r\nprops->atomic_cap = IB_ATOMIC_NONE;\r\nprops->max_map_per_fmr = 1;\r\nreturn 0;\r\n}\r\nstatic int nes_query_port(struct ib_device *ibdev, u8 port, struct ib_port_attr *props)\r\n{\r\nstruct nes_vnic *nesvnic = to_nesvnic(ibdev);\r\nstruct net_device *netdev = nesvnic->netdev;\r\nmemset(props, 0, sizeof(*props));\r\nprops->max_mtu = IB_MTU_4096;\r\nif (netdev->mtu >= 4096)\r\nprops->active_mtu = IB_MTU_4096;\r\nelse if (netdev->mtu >= 2048)\r\nprops->active_mtu = IB_MTU_2048;\r\nelse if (netdev->mtu >= 1024)\r\nprops->active_mtu = IB_MTU_1024;\r\nelse if (netdev->mtu >= 512)\r\nprops->active_mtu = IB_MTU_512;\r\nelse\r\nprops->active_mtu = IB_MTU_256;\r\nprops->lid = 1;\r\nprops->lmc = 0;\r\nprops->sm_lid = 0;\r\nprops->sm_sl = 0;\r\nif (netif_queue_stopped(netdev))\r\nprops->state = IB_PORT_DOWN;\r\nelse if (nesvnic->linkup)\r\nprops->state = IB_PORT_ACTIVE;\r\nelse\r\nprops->state = IB_PORT_DOWN;\r\nprops->phys_state = 0;\r\nprops->port_cap_flags = IB_PORT_CM_SUP | IB_PORT_REINIT_SUP |\r\nIB_PORT_VENDOR_CLASS_SUP | IB_PORT_BOOT_MGMT_SUP;\r\nprops->gid_tbl_len = 1;\r\nprops->pkey_tbl_len = 1;\r\nprops->qkey_viol_cntr = 0;\r\nprops->active_width = IB_WIDTH_4X;\r\nprops->active_speed = IB_SPEED_SDR;\r\nprops->max_msg_sz = 0x80000000;\r\nreturn 0;\r\n}\r\nstatic int nes_query_pkey(struct ib_device *ibdev, u8 port, u16 index, u16 *pkey)\r\n{\r\n*pkey = 0;\r\nreturn 0;\r\n}\r\nstatic int nes_query_gid(struct ib_device *ibdev, u8 port,\r\nint index, union ib_gid *gid)\r\n{\r\nstruct nes_vnic *nesvnic = to_nesvnic(ibdev);\r\nmemset(&(gid->raw[0]), 0, sizeof(gid->raw));\r\nmemcpy(&(gid->raw[0]), nesvnic->netdev->dev_addr, 6);\r\nreturn 0;\r\n}\r\nstatic struct ib_ucontext *nes_alloc_ucontext(struct ib_device *ibdev,\r\nstruct ib_udata *udata)\r\n{\r\nstruct nes_vnic *nesvnic = to_nesvnic(ibdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nstruct nes_alloc_ucontext_req req;\r\nstruct nes_alloc_ucontext_resp uresp;\r\nstruct nes_ucontext *nes_ucontext;\r\nstruct nes_ib_device *nesibdev = nesvnic->nesibdev;\r\nif (ib_copy_from_udata(&req, udata, sizeof(struct nes_alloc_ucontext_req))) {\r\nprintk(KERN_ERR PFX "Invalid structure size on allocate user context.\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (req.userspace_ver != NES_ABI_USERSPACE_VER) {\r\nprintk(KERN_ERR PFX "Invalid userspace driver version detected. Detected version %d, should be %d\n",\r\nreq.userspace_ver, NES_ABI_USERSPACE_VER);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nmemset(&uresp, 0, sizeof uresp);\r\nuresp.max_qps = nesibdev->max_qp;\r\nuresp.max_pds = nesibdev->max_pd;\r\nuresp.wq_size = nesdev->nesadapter->max_qp_wr * 2;\r\nuresp.virtwq = nesadapter->virtwq;\r\nuresp.kernel_ver = NES_ABI_KERNEL_VER;\r\nnes_ucontext = kzalloc(sizeof *nes_ucontext, GFP_KERNEL);\r\nif (!nes_ucontext)\r\nreturn ERR_PTR(-ENOMEM);\r\nnes_ucontext->nesdev = nesdev;\r\nnes_ucontext->mmap_wq_offset = uresp.max_pds;\r\nnes_ucontext->mmap_cq_offset = nes_ucontext->mmap_wq_offset +\r\n((sizeof(struct nes_hw_qp_wqe) * uresp.max_qps * 2) + PAGE_SIZE-1) /\r\nPAGE_SIZE;\r\nif (ib_copy_to_udata(udata, &uresp, sizeof uresp)) {\r\nkfree(nes_ucontext);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\nINIT_LIST_HEAD(&nes_ucontext->cq_reg_mem_list);\r\nINIT_LIST_HEAD(&nes_ucontext->qp_reg_mem_list);\r\natomic_set(&nes_ucontext->usecnt, 1);\r\nreturn &nes_ucontext->ibucontext;\r\n}\r\nstatic int nes_dealloc_ucontext(struct ib_ucontext *context)\r\n{\r\nstruct nes_ucontext *nes_ucontext = to_nesucontext(context);\r\nif (!atomic_dec_and_test(&nes_ucontext->usecnt))\r\nreturn 0;\r\nkfree(nes_ucontext);\r\nreturn 0;\r\n}\r\nstatic int nes_mmap(struct ib_ucontext *context, struct vm_area_struct *vma)\r\n{\r\nunsigned long index;\r\nstruct nes_vnic *nesvnic = to_nesvnic(context->device);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_ucontext *nes_ucontext;\r\nstruct nes_qp *nesqp;\r\nnes_ucontext = to_nesucontext(context);\r\nif (vma->vm_pgoff >= nes_ucontext->mmap_wq_offset) {\r\nindex = (vma->vm_pgoff - nes_ucontext->mmap_wq_offset) * PAGE_SIZE;\r\nindex /= ((sizeof(struct nes_hw_qp_wqe) * nesdev->nesadapter->max_qp_wr * 2) +\r\nPAGE_SIZE-1) & (~(PAGE_SIZE-1));\r\nif (!test_bit(index, nes_ucontext->allocated_wqs)) {\r\nnes_debug(NES_DBG_MMAP, "wq %lu not allocated\n", index);\r\nreturn -EFAULT;\r\n}\r\nnesqp = nes_ucontext->mmap_nesqp[index];\r\nif (nesqp == NULL) {\r\nnes_debug(NES_DBG_MMAP, "wq %lu has a NULL QP base.\n", index);\r\nreturn -EFAULT;\r\n}\r\nif (remap_pfn_range(vma, vma->vm_start,\r\nvirt_to_phys(nesqp->hwqp.sq_vbase) >> PAGE_SHIFT,\r\nvma->vm_end - vma->vm_start,\r\nvma->vm_page_prot)) {\r\nnes_debug(NES_DBG_MMAP, "remap_pfn_range failed.\n");\r\nreturn -EAGAIN;\r\n}\r\nvma->vm_private_data = nesqp;\r\nreturn 0;\r\n} else {\r\nindex = vma->vm_pgoff;\r\nif (!test_bit(index, nes_ucontext->allocated_doorbells))\r\nreturn -EFAULT;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nif (io_remap_pfn_range(vma, vma->vm_start,\r\n(nesdev->doorbell_start +\r\n((nes_ucontext->mmap_db_index[index] - nesdev->base_doorbell_index) * 4096))\r\n>> PAGE_SHIFT, PAGE_SIZE, vma->vm_page_prot))\r\nreturn -EAGAIN;\r\nvma->vm_private_data = nes_ucontext;\r\nreturn 0;\r\n}\r\nreturn -ENOSYS;\r\n}\r\nstatic struct ib_pd *nes_alloc_pd(struct ib_device *ibdev,\r\nstruct ib_ucontext *context, struct ib_udata *udata)\r\n{\r\nstruct nes_pd *nespd;\r\nstruct nes_vnic *nesvnic = to_nesvnic(ibdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nstruct nes_ucontext *nesucontext;\r\nstruct nes_alloc_pd_resp uresp;\r\nu32 pd_num = 0;\r\nint err;\r\nnes_debug(NES_DBG_PD, "nesvnic=%p, netdev=%p %s, ibdev=%p, context=%p, netdev refcnt=%u\n",\r\nnesvnic, nesdev->netdev[0], nesdev->netdev[0]->name, ibdev, context,\r\nnetdev_refcnt_read(nesvnic->netdev));\r\nerr = nes_alloc_resource(nesadapter, nesadapter->allocated_pds,\r\nnesadapter->max_pd, &pd_num, &nesadapter->next_pd, NES_RESOURCE_PD);\r\nif (err) {\r\nreturn ERR_PTR(err);\r\n}\r\nnespd = kzalloc(sizeof (struct nes_pd), GFP_KERNEL);\r\nif (!nespd) {\r\nnes_free_resource(nesadapter, nesadapter->allocated_pds, pd_num);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nnes_debug(NES_DBG_PD, "Allocating PD (%p) for ib device %s\n",\r\nnespd, nesvnic->nesibdev->ibdev.name);\r\nnespd->pd_id = (pd_num << (PAGE_SHIFT-12)) + nesadapter->base_pd;\r\nif (context) {\r\nnesucontext = to_nesucontext(context);\r\nnespd->mmap_db_index = find_next_zero_bit(nesucontext->allocated_doorbells,\r\nNES_MAX_USER_DB_REGIONS, nesucontext->first_free_db);\r\nnes_debug(NES_DBG_PD, "find_first_zero_biton doorbells returned %u, mapping pd_id %u.\n",\r\nnespd->mmap_db_index, nespd->pd_id);\r\nif (nespd->mmap_db_index >= NES_MAX_USER_DB_REGIONS) {\r\nnes_debug(NES_DBG_PD, "mmap_db_index > MAX\n");\r\nnes_free_resource(nesadapter, nesadapter->allocated_pds, pd_num);\r\nkfree(nespd);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nuresp.pd_id = nespd->pd_id;\r\nuresp.mmap_db_index = nespd->mmap_db_index;\r\nif (ib_copy_to_udata(udata, &uresp, sizeof (struct nes_alloc_pd_resp))) {\r\nnes_free_resource(nesadapter, nesadapter->allocated_pds, pd_num);\r\nkfree(nespd);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\nset_bit(nespd->mmap_db_index, nesucontext->allocated_doorbells);\r\nnesucontext->mmap_db_index[nespd->mmap_db_index] = nespd->pd_id;\r\nnesucontext->first_free_db = nespd->mmap_db_index + 1;\r\n}\r\nnes_debug(NES_DBG_PD, "PD%u structure located @%p.\n", nespd->pd_id, nespd);\r\nreturn &nespd->ibpd;\r\n}\r\nstatic int nes_dealloc_pd(struct ib_pd *ibpd)\r\n{\r\nstruct nes_ucontext *nesucontext;\r\nstruct nes_pd *nespd = to_nespd(ibpd);\r\nstruct nes_vnic *nesvnic = to_nesvnic(ibpd->device);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nif ((ibpd->uobject) && (ibpd->uobject->context)) {\r\nnesucontext = to_nesucontext(ibpd->uobject->context);\r\nnes_debug(NES_DBG_PD, "Clearing bit %u from allocated doorbells\n",\r\nnespd->mmap_db_index);\r\nclear_bit(nespd->mmap_db_index, nesucontext->allocated_doorbells);\r\nnesucontext->mmap_db_index[nespd->mmap_db_index] = 0;\r\nif (nesucontext->first_free_db > nespd->mmap_db_index) {\r\nnesucontext->first_free_db = nespd->mmap_db_index;\r\n}\r\n}\r\nnes_debug(NES_DBG_PD, "Deallocating PD%u structure located @%p.\n",\r\nnespd->pd_id, nespd);\r\nnes_free_resource(nesadapter, nesadapter->allocated_pds,\r\n(nespd->pd_id-nesadapter->base_pd)>>(PAGE_SHIFT-12));\r\nkfree(nespd);\r\nreturn 0;\r\n}\r\nstatic struct ib_ah *nes_create_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr)\r\n{\r\nreturn ERR_PTR(-ENOSYS);\r\n}\r\nstatic int nes_destroy_ah(struct ib_ah *ah)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic inline u8 nes_get_encoded_size(int *size)\r\n{\r\nu8 encoded_size = 0;\r\nif (*size <= 32) {\r\n*size = 32;\r\nencoded_size = 1;\r\n} else if (*size <= 128) {\r\n*size = 128;\r\nencoded_size = 2;\r\n} else if (*size <= 512) {\r\n*size = 512;\r\nencoded_size = 3;\r\n}\r\nreturn (encoded_size);\r\n}\r\nstatic int nes_setup_virt_qp(struct nes_qp *nesqp, struct nes_pbl *nespbl,\r\nstruct nes_vnic *nesvnic, int sq_size, int rq_size)\r\n{\r\nunsigned long flags;\r\nvoid *mem;\r\n__le64 *pbl = NULL;\r\n__le64 *tpbl;\r\n__le64 *pblbuffer;\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nu32 pbl_entries;\r\nu8 rq_pbl_entries;\r\nu8 sq_pbl_entries;\r\npbl_entries = nespbl->pbl_size >> 3;\r\nnes_debug(NES_DBG_QP, "Userspace PBL, pbl_size=%u, pbl_entries = %d pbl_vbase=%p, pbl_pbase=%lx\n",\r\nnespbl->pbl_size, pbl_entries,\r\n(void *)nespbl->pbl_vbase,\r\n(unsigned long) nespbl->pbl_pbase);\r\npbl = (__le64 *) nespbl->pbl_vbase;\r\nrq_pbl_entries = (rq_size * sizeof(struct nes_hw_qp_wqe)) >> 12;\r\nsq_pbl_entries = (sq_size * sizeof(struct nes_hw_qp_wqe)) >> 12;\r\nnesqp->hwqp.sq_pbase = (le32_to_cpu(((__le32 *)pbl)[0])) | ((u64)((le32_to_cpu(((__le32 *)pbl)[1]))) << 32);\r\nif (!nespbl->page) {\r\nnes_debug(NES_DBG_QP, "QP nespbl->page is NULL \n");\r\nkfree(nespbl);\r\nreturn -ENOMEM;\r\n}\r\nnesqp->hwqp.sq_vbase = kmap(nespbl->page);\r\nnesqp->page = nespbl->page;\r\nif (!nesqp->hwqp.sq_vbase) {\r\nnes_debug(NES_DBG_QP, "QP sq_vbase kmap failed\n");\r\nkfree(nespbl);\r\nreturn -ENOMEM;\r\n}\r\npbl += sq_pbl_entries;\r\nnesqp->hwqp.rq_pbase = (le32_to_cpu(((__le32 *)pbl)[0])) | ((u64)((le32_to_cpu(((__le32 *)pbl)[1]))) << 32);\r\nnes_debug(NES_DBG_QP, "QP sq_vbase= %p sq_pbase=%lx rq_vbase=%p rq_pbase=%lx\n",\r\nnesqp->hwqp.sq_vbase, (unsigned long) nesqp->hwqp.sq_pbase,\r\nnesqp->hwqp.rq_vbase, (unsigned long) nesqp->hwqp.rq_pbase);\r\nspin_lock_irqsave(&nesadapter->pbl_lock, flags);\r\nif (!nesadapter->free_256pbl) {\r\npci_free_consistent(nesdev->pcidev, nespbl->pbl_size, nespbl->pbl_vbase,\r\nnespbl->pbl_pbase);\r\nspin_unlock_irqrestore(&nesadapter->pbl_lock, flags);\r\nkunmap(nesqp->page);\r\nkfree(nespbl);\r\nreturn -ENOMEM;\r\n}\r\nnesadapter->free_256pbl--;\r\nspin_unlock_irqrestore(&nesadapter->pbl_lock, flags);\r\nnesqp->pbl_vbase = pci_alloc_consistent(nesdev->pcidev, 256, &nesqp->pbl_pbase);\r\npblbuffer = nesqp->pbl_vbase;\r\nif (!nesqp->pbl_vbase) {\r\npci_free_consistent(nesdev->pcidev, nespbl->pbl_size, nespbl->pbl_vbase,\r\nnespbl->pbl_pbase);\r\nkfree(nespbl);\r\nspin_lock_irqsave(&nesadapter->pbl_lock, flags);\r\nnesadapter->free_256pbl++;\r\nspin_unlock_irqrestore(&nesadapter->pbl_lock, flags);\r\nkunmap(nesqp->page);\r\nreturn -ENOMEM;\r\n}\r\nmemset(nesqp->pbl_vbase, 0, 256);\r\ntpbl = pblbuffer + 16;\r\npbl = (__le64 *)nespbl->pbl_vbase;\r\nwhile (sq_pbl_entries--)\r\n*tpbl++ = *pbl++;\r\ntpbl = pblbuffer;\r\nwhile (rq_pbl_entries--)\r\n*tpbl++ = *pbl++;\r\npci_free_consistent(nesdev->pcidev, nespbl->pbl_size, nespbl->pbl_vbase,\r\nnespbl->pbl_pbase);\r\nkfree(nespbl);\r\nnesqp->qp_mem_size =\r\nmax((u32)sizeof(struct nes_qp_context), ((u32)256)) + 256;\r\nnesqp->qp_mem_size += PAGE_SIZE - 1;\r\nnesqp->qp_mem_size &= ~(PAGE_SIZE - 1);\r\nmem = pci_alloc_consistent(nesdev->pcidev, nesqp->qp_mem_size,\r\n&nesqp->hwqp.q2_pbase);\r\nif (!mem) {\r\npci_free_consistent(nesdev->pcidev, 256, nesqp->pbl_vbase, nesqp->pbl_pbase);\r\nnesqp->pbl_vbase = NULL;\r\nspin_lock_irqsave(&nesadapter->pbl_lock, flags);\r\nnesadapter->free_256pbl++;\r\nspin_unlock_irqrestore(&nesadapter->pbl_lock, flags);\r\nkunmap(nesqp->page);\r\nreturn -ENOMEM;\r\n}\r\nnesqp->sq_kmapped = 1;\r\nnesqp->hwqp.q2_vbase = mem;\r\nmem += 256;\r\nmemset(nesqp->hwqp.q2_vbase, 0, 256);\r\nnesqp->nesqp_context = mem;\r\nmemset(nesqp->nesqp_context, 0, sizeof(*nesqp->nesqp_context));\r\nnesqp->nesqp_context_pbase = nesqp->hwqp.q2_pbase + 256;\r\nreturn 0;\r\n}\r\nstatic int nes_setup_mmap_qp(struct nes_qp *nesqp, struct nes_vnic *nesvnic,\r\nint sq_size, int rq_size)\r\n{\r\nvoid *mem;\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nnesqp->qp_mem_size = (sizeof(struct nes_hw_qp_wqe) * sq_size) +\r\n(sizeof(struct nes_hw_qp_wqe) * rq_size) +\r\nmax((u32)sizeof(struct nes_qp_context), ((u32)256)) +\r\n256;\r\nnesqp->qp_mem_size += PAGE_SIZE - 1;\r\nnesqp->qp_mem_size &= ~(PAGE_SIZE - 1);\r\nmem = pci_alloc_consistent(nesdev->pcidev, nesqp->qp_mem_size,\r\n&nesqp->hwqp.sq_pbase);\r\nif (!mem)\r\nreturn -ENOMEM;\r\nnes_debug(NES_DBG_QP, "PCI consistent memory for "\r\n"host descriptor rings located @ %p (pa = 0x%08lX.) size = %u.\n",\r\nmem, (unsigned long)nesqp->hwqp.sq_pbase, nesqp->qp_mem_size);\r\nmemset(mem, 0, nesqp->qp_mem_size);\r\nnesqp->hwqp.sq_vbase = mem;\r\nmem += sizeof(struct nes_hw_qp_wqe) * sq_size;\r\nnesqp->hwqp.rq_vbase = mem;\r\nnesqp->hwqp.rq_pbase = nesqp->hwqp.sq_pbase +\r\nsizeof(struct nes_hw_qp_wqe) * sq_size;\r\nmem += sizeof(struct nes_hw_qp_wqe) * rq_size;\r\nnesqp->hwqp.q2_vbase = mem;\r\nnesqp->hwqp.q2_pbase = nesqp->hwqp.rq_pbase +\r\nsizeof(struct nes_hw_qp_wqe) * rq_size;\r\nmem += 256;\r\nmemset(nesqp->hwqp.q2_vbase, 0, 256);\r\nnesqp->nesqp_context = mem;\r\nnesqp->nesqp_context_pbase = nesqp->hwqp.q2_pbase + 256;\r\nmemset(nesqp->nesqp_context, 0, sizeof(*nesqp->nesqp_context));\r\nreturn 0;\r\n}\r\nstatic inline void nes_free_qp_mem(struct nes_device *nesdev,\r\nstruct nes_qp *nesqp, int virt_wqs)\r\n{\r\nunsigned long flags;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nif (!virt_wqs) {\r\npci_free_consistent(nesdev->pcidev, nesqp->qp_mem_size,\r\nnesqp->hwqp.sq_vbase, nesqp->hwqp.sq_pbase);\r\n}else {\r\nspin_lock_irqsave(&nesadapter->pbl_lock, flags);\r\nnesadapter->free_256pbl++;\r\nspin_unlock_irqrestore(&nesadapter->pbl_lock, flags);\r\npci_free_consistent(nesdev->pcidev, nesqp->qp_mem_size, nesqp->hwqp.q2_vbase, nesqp->hwqp.q2_pbase);\r\npci_free_consistent(nesdev->pcidev, 256, nesqp->pbl_vbase, nesqp->pbl_pbase );\r\nnesqp->pbl_vbase = NULL;\r\nif (nesqp->sq_kmapped) {\r\nnesqp->sq_kmapped = 0;\r\nkunmap(nesqp->page);\r\n}\r\n}\r\n}\r\nstatic struct ib_qp *nes_create_qp(struct ib_pd *ibpd,\r\nstruct ib_qp_init_attr *init_attr, struct ib_udata *udata)\r\n{\r\nu64 u64temp= 0;\r\nu64 u64nesqp = 0;\r\nstruct nes_pd *nespd = to_nespd(ibpd);\r\nstruct nes_vnic *nesvnic = to_nesvnic(ibpd->device);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nstruct nes_qp *nesqp;\r\nstruct nes_cq *nescq;\r\nstruct nes_ucontext *nes_ucontext;\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nstruct nes_cqp_request *cqp_request;\r\nstruct nes_create_qp_req req;\r\nstruct nes_create_qp_resp uresp;\r\nstruct nes_pbl *nespbl = NULL;\r\nu32 qp_num = 0;\r\nu32 opcode = 0;\r\nvoid *mem;\r\nunsigned long flags;\r\nint ret;\r\nint err;\r\nint virt_wqs = 0;\r\nint sq_size;\r\nint rq_size;\r\nu8 sq_encoded_size;\r\nu8 rq_encoded_size;\r\nif (init_attr->create_flags)\r\nreturn ERR_PTR(-EINVAL);\r\natomic_inc(&qps_created);\r\nswitch (init_attr->qp_type) {\r\ncase IB_QPT_RC:\r\nif (nes_drv_opt & NES_DRV_OPT_NO_INLINE_DATA) {\r\ninit_attr->cap.max_inline_data = 0;\r\n} else {\r\ninit_attr->cap.max_inline_data = 64;\r\n}\r\nsq_size = init_attr->cap.max_send_wr;\r\nrq_size = init_attr->cap.max_recv_wr;\r\nsq_encoded_size = nes_get_encoded_size(&sq_size);\r\nrq_encoded_size = nes_get_encoded_size(&rq_size);\r\nif ((!sq_encoded_size) || (!rq_encoded_size)) {\r\nnes_debug(NES_DBG_QP, "ERROR bad rq (%u) or sq (%u) size\n",\r\nrq_size, sq_size);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ninit_attr->cap.max_send_wr = sq_size -2;\r\ninit_attr->cap.max_recv_wr = rq_size -1;\r\nnes_debug(NES_DBG_QP, "RQ size=%u, SQ Size=%u\n", rq_size, sq_size);\r\nret = nes_alloc_resource(nesadapter, nesadapter->allocated_qps,\r\nnesadapter->max_qp, &qp_num, &nesadapter->next_qp, NES_RESOURCE_QP);\r\nif (ret) {\r\nreturn ERR_PTR(ret);\r\n}\r\nmem = kzalloc(sizeof(*nesqp)+NES_SW_CONTEXT_ALIGN-1, GFP_KERNEL);\r\nif (!mem) {\r\nnes_free_resource(nesadapter, nesadapter->allocated_qps, qp_num);\r\nnes_debug(NES_DBG_QP, "Unable to allocate QP\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nu64nesqp = (unsigned long)mem;\r\nu64nesqp += ((u64)NES_SW_CONTEXT_ALIGN) - 1;\r\nu64temp = ((u64)NES_SW_CONTEXT_ALIGN) - 1;\r\nu64nesqp &= ~u64temp;\r\nnesqp = (struct nes_qp *)(unsigned long)u64nesqp;\r\nnesqp->allocated_buffer = mem;\r\nif (udata) {\r\nif (ib_copy_from_udata(&req, udata, sizeof(struct nes_create_qp_req))) {\r\nnes_free_resource(nesadapter, nesadapter->allocated_qps, qp_num);\r\nkfree(nesqp->allocated_buffer);\r\nnes_debug(NES_DBG_QP, "ib_copy_from_udata() Failed \n");\r\nreturn NULL;\r\n}\r\nif (req.user_wqe_buffers) {\r\nvirt_wqs = 1;\r\n}\r\nif ((ibpd->uobject) && (ibpd->uobject->context)) {\r\nnesqp->user_mode = 1;\r\nnes_ucontext = to_nesucontext(ibpd->uobject->context);\r\nif (virt_wqs) {\r\nerr = 1;\r\nlist_for_each_entry(nespbl, &nes_ucontext->qp_reg_mem_list, list) {\r\nif (nespbl->user_base == (unsigned long )req.user_wqe_buffers) {\r\nlist_del(&nespbl->list);\r\nerr = 0;\r\nnes_debug(NES_DBG_QP, "Found PBL for virtual QP. nespbl=%p. user_base=0x%lx\n",\r\nnespbl, nespbl->user_base);\r\nbreak;\r\n}\r\n}\r\nif (err) {\r\nnes_debug(NES_DBG_QP, "Didn't Find PBL for virtual QP. address = %llx.\n",\r\n(long long unsigned int)req.user_wqe_buffers);\r\nnes_free_resource(nesadapter, nesadapter->allocated_qps, qp_num);\r\nkfree(nesqp->allocated_buffer);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\n}\r\nnes_ucontext = to_nesucontext(ibpd->uobject->context);\r\nnesqp->mmap_sq_db_index =\r\nfind_next_zero_bit(nes_ucontext->allocated_wqs,\r\nNES_MAX_USER_WQ_REGIONS, nes_ucontext->first_free_wq);\r\nif (nesqp->mmap_sq_db_index >= NES_MAX_USER_WQ_REGIONS) {\r\nnes_debug(NES_DBG_QP,\r\n"db index > max user regions, failing create QP\n");\r\nnes_free_resource(nesadapter, nesadapter->allocated_qps, qp_num);\r\nif (virt_wqs) {\r\npci_free_consistent(nesdev->pcidev, nespbl->pbl_size, nespbl->pbl_vbase,\r\nnespbl->pbl_pbase);\r\nkfree(nespbl);\r\n}\r\nkfree(nesqp->allocated_buffer);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nset_bit(nesqp->mmap_sq_db_index, nes_ucontext->allocated_wqs);\r\nnes_ucontext->mmap_nesqp[nesqp->mmap_sq_db_index] = nesqp;\r\nnes_ucontext->first_free_wq = nesqp->mmap_sq_db_index + 1;\r\n} else {\r\nnes_free_resource(nesadapter, nesadapter->allocated_qps, qp_num);\r\nkfree(nesqp->allocated_buffer);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\n}\r\nerr = (!virt_wqs) ? nes_setup_mmap_qp(nesqp, nesvnic, sq_size, rq_size) :\r\nnes_setup_virt_qp(nesqp, nespbl, nesvnic, sq_size, rq_size);\r\nif (err) {\r\nnes_debug(NES_DBG_QP,\r\n"error geting qp mem code = %d\n", err);\r\nnes_free_resource(nesadapter, nesadapter->allocated_qps, qp_num);\r\nkfree(nesqp->allocated_buffer);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nnesqp->hwqp.sq_size = sq_size;\r\nnesqp->hwqp.sq_encoded_size = sq_encoded_size;\r\nnesqp->hwqp.sq_head = 1;\r\nnesqp->hwqp.rq_size = rq_size;\r\nnesqp->hwqp.rq_encoded_size = rq_encoded_size;\r\nnesqp->hwqp.qp_id = qp_num;\r\nnesqp->ibqp.qp_num = nesqp->hwqp.qp_id;\r\nnesqp->nespd = nespd;\r\nnescq = to_nescq(init_attr->send_cq);\r\nnesqp->nesscq = nescq;\r\nnescq = to_nescq(init_attr->recv_cq);\r\nnesqp->nesrcq = nescq;\r\nnesqp->nesqp_context->misc |= cpu_to_le32((u32)PCI_FUNC(nesdev->pcidev->devfn) <<\r\nNES_QPCONTEXT_MISC_PCI_FCN_SHIFT);\r\nnesqp->nesqp_context->misc |= cpu_to_le32((u32)nesqp->hwqp.rq_encoded_size <<\r\nNES_QPCONTEXT_MISC_RQ_SIZE_SHIFT);\r\nnesqp->nesqp_context->misc |= cpu_to_le32((u32)nesqp->hwqp.sq_encoded_size <<\r\nNES_QPCONTEXT_MISC_SQ_SIZE_SHIFT);\r\nif (!udata) {\r\nnesqp->nesqp_context->misc |= cpu_to_le32(NES_QPCONTEXT_MISC_PRIV_EN);\r\nnesqp->nesqp_context->misc |= cpu_to_le32(NES_QPCONTEXT_MISC_FAST_REGISTER_EN);\r\n}\r\nnesqp->nesqp_context->cqs = cpu_to_le32(nesqp->nesscq->hw_cq.cq_number +\r\n((u32)nesqp->nesrcq->hw_cq.cq_number << 16));\r\nu64temp = (u64)nesqp->hwqp.sq_pbase;\r\nnesqp->nesqp_context->sq_addr_low = cpu_to_le32((u32)u64temp);\r\nnesqp->nesqp_context->sq_addr_high = cpu_to_le32((u32)(u64temp >> 32));\r\nif (!virt_wqs) {\r\nu64temp = (u64)nesqp->hwqp.sq_pbase;\r\nnesqp->nesqp_context->sq_addr_low = cpu_to_le32((u32)u64temp);\r\nnesqp->nesqp_context->sq_addr_high = cpu_to_le32((u32)(u64temp >> 32));\r\nu64temp = (u64)nesqp->hwqp.rq_pbase;\r\nnesqp->nesqp_context->rq_addr_low = cpu_to_le32((u32)u64temp);\r\nnesqp->nesqp_context->rq_addr_high = cpu_to_le32((u32)(u64temp >> 32));\r\n} else {\r\nu64temp = (u64)nesqp->pbl_pbase;\r\nnesqp->nesqp_context->rq_addr_low = cpu_to_le32((u32)u64temp);\r\nnesqp->nesqp_context->rq_addr_high = cpu_to_le32((u32)(u64temp >> 32));\r\n}\r\nspin_lock_irqsave(&nesdev->cqp.lock, flags);\r\nnesqp->nesqp_context->misc2 |= cpu_to_le32(\r\n(u32)nesvnic->qp_nic_index[nesvnic->next_qp_nic_index] <<\r\nNES_QPCONTEXT_MISC2_NIC_INDEX_SHIFT);\r\nnesvnic->next_qp_nic_index++;\r\nif ((nesvnic->next_qp_nic_index > 3) ||\r\n(nesvnic->qp_nic_index[nesvnic->next_qp_nic_index] == 0xf)) {\r\nnesvnic->next_qp_nic_index = 0;\r\n}\r\nspin_unlock_irqrestore(&nesdev->cqp.lock, flags);\r\nnesqp->nesqp_context->pd_index_wscale |= cpu_to_le32((u32)nesqp->nespd->pd_id << 16);\r\nu64temp = (u64)nesqp->hwqp.q2_pbase;\r\nnesqp->nesqp_context->q2_addr_low = cpu_to_le32((u32)u64temp);\r\nnesqp->nesqp_context->q2_addr_high = cpu_to_le32((u32)(u64temp >> 32));\r\nnesqp->nesqp_context->aeq_token_low = cpu_to_le32((u32)((unsigned long)(nesqp)));\r\nnesqp->nesqp_context->aeq_token_high = cpu_to_le32((u32)(upper_32_bits((unsigned long)(nesqp))));\r\nnesqp->nesqp_context->ird_ord_sizes = cpu_to_le32(NES_QPCONTEXT_ORDIRD_ALSMM |\r\nNES_QPCONTEXT_ORDIRD_AAH |\r\n((((u32)nesadapter->max_irrq_wr) <<\r\nNES_QPCONTEXT_ORDIRD_IRDSIZE_SHIFT) & NES_QPCONTEXT_ORDIRD_IRDSIZE_MASK));\r\nif (disable_mpa_crc) {\r\nnes_debug(NES_DBG_QP, "Disabling MPA crc checking due to module option.\n");\r\nnesqp->nesqp_context->ird_ord_sizes |= cpu_to_le32(NES_QPCONTEXT_ORDIRD_RNMC);\r\n}\r\ncqp_request = nes_get_cqp_request(nesdev);\r\nif (cqp_request == NULL) {\r\nnes_debug(NES_DBG_QP, "Failed to get a cqp_request\n");\r\nnes_free_resource(nesadapter, nesadapter->allocated_qps, qp_num);\r\nnes_free_qp_mem(nesdev, nesqp,virt_wqs);\r\nkfree(nesqp->allocated_buffer);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ncqp_request->waiting = 1;\r\ncqp_wqe = &cqp_request->cqp_wqe;\r\nif (!virt_wqs) {\r\nopcode = NES_CQP_CREATE_QP | NES_CQP_QP_TYPE_IWARP |\r\nNES_CQP_QP_IWARP_STATE_IDLE;\r\n} else {\r\nopcode = NES_CQP_CREATE_QP | NES_CQP_QP_TYPE_IWARP | NES_CQP_QP_VIRT_WQS |\r\nNES_CQP_QP_IWARP_STATE_IDLE;\r\n}\r\nopcode |= NES_CQP_QP_CQS_VALID;\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_OPCODE_IDX, opcode);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_ID_IDX, nesqp->hwqp.qp_id);\r\nu64temp = (u64)nesqp->nesqp_context_pbase;\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, NES_CQP_QP_WQE_CONTEXT_LOW_IDX, u64temp);\r\natomic_set(&cqp_request->refcount, 2);\r\nnes_post_cqp_request(nesdev, cqp_request);\r\nnes_debug(NES_DBG_QP, "Waiting for create iWARP QP%u to complete.\n",\r\nnesqp->hwqp.qp_id);\r\nret = wait_event_timeout(cqp_request->waitq,\r\n(cqp_request->request_done != 0), NES_EVENT_TIMEOUT);\r\nnes_debug(NES_DBG_QP, "Create iwarp QP%u completed, wait_event_timeout ret=%u,"\r\n" nesdev->cqp_head = %u, nesdev->cqp.sq_tail = %u,"\r\n" CQP Major:Minor codes = 0x%04X:0x%04X.\n",\r\nnesqp->hwqp.qp_id, ret, nesdev->cqp.sq_head, nesdev->cqp.sq_tail,\r\ncqp_request->major_code, cqp_request->minor_code);\r\nif ((!ret) || (cqp_request->major_code)) {\r\nnes_put_cqp_request(nesdev, cqp_request);\r\nnes_free_resource(nesadapter, nesadapter->allocated_qps, qp_num);\r\nnes_free_qp_mem(nesdev, nesqp,virt_wqs);\r\nkfree(nesqp->allocated_buffer);\r\nif (!ret) {\r\nreturn ERR_PTR(-ETIME);\r\n} else {\r\nreturn ERR_PTR(-EIO);\r\n}\r\n}\r\nnes_put_cqp_request(nesdev, cqp_request);\r\nif (ibpd->uobject) {\r\nuresp.mmap_sq_db_index = nesqp->mmap_sq_db_index;\r\nuresp.mmap_rq_db_index = 0;\r\nuresp.actual_sq_size = sq_size;\r\nuresp.actual_rq_size = rq_size;\r\nuresp.qp_id = nesqp->hwqp.qp_id;\r\nuresp.nes_drv_opt = nes_drv_opt;\r\nif (ib_copy_to_udata(udata, &uresp, sizeof uresp)) {\r\nnes_free_resource(nesadapter, nesadapter->allocated_qps, qp_num);\r\nnes_free_qp_mem(nesdev, nesqp,virt_wqs);\r\nkfree(nesqp->allocated_buffer);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\n}\r\nnes_debug(NES_DBG_QP, "QP%u structure located @%p.Size = %u.\n",\r\nnesqp->hwqp.qp_id, nesqp, (u32)sizeof(*nesqp));\r\nspin_lock_init(&nesqp->lock);\r\nnes_add_ref(&nesqp->ibqp);\r\nbreak;\r\ndefault:\r\nnes_debug(NES_DBG_QP, "Invalid QP type: %d\n", init_attr->qp_type);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nnesqp->sig_all = (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR);\r\ninit_timer(&nesqp->terminate_timer);\r\nnesqp->terminate_timer.function = nes_terminate_timeout;\r\nnesqp->terminate_timer.data = (unsigned long)nesqp;\r\nnesdev->nesadapter->qp_table[nesqp->hwqp.qp_id-NES_FIRST_QPN] = nesqp;\r\nnes_debug(NES_DBG_QP, "netdev refcnt=%u\n",\r\nnetdev_refcnt_read(nesvnic->netdev));\r\nreturn &nesqp->ibqp;\r\n}\r\nstatic void nes_clean_cq(struct nes_qp *nesqp, struct nes_cq *nescq)\r\n{\r\nu32 cq_head;\r\nu32 lo;\r\nu32 hi;\r\nu64 u64temp;\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&nescq->lock, flags);\r\ncq_head = nescq->hw_cq.cq_head;\r\nwhile (le32_to_cpu(nescq->hw_cq.cq_vbase[cq_head].cqe_words[NES_CQE_OPCODE_IDX]) & NES_CQE_VALID) {\r\nrmb();\r\nlo = le32_to_cpu(nescq->hw_cq.cq_vbase[cq_head].cqe_words[NES_CQE_COMP_COMP_CTX_LOW_IDX]);\r\nhi = le32_to_cpu(nescq->hw_cq.cq_vbase[cq_head].cqe_words[NES_CQE_COMP_COMP_CTX_HIGH_IDX]);\r\nu64temp = (((u64)hi) << 32) | ((u64)lo);\r\nu64temp &= ~(NES_SW_CONTEXT_ALIGN-1);\r\nif (u64temp == (u64)(unsigned long)nesqp) {\r\nnescq->hw_cq.cq_vbase[cq_head].cqe_words[NES_CQE_COMP_COMP_CTX_LOW_IDX] = 0;\r\nnescq->hw_cq.cq_vbase[cq_head].cqe_words[NES_CQE_COMP_COMP_CTX_HIGH_IDX] = 0;\r\n}\r\nif (++cq_head >= nescq->hw_cq.cq_size)\r\ncq_head = 0;\r\n}\r\nspin_unlock_irqrestore(&nescq->lock, flags);\r\n}\r\nstatic int nes_destroy_qp(struct ib_qp *ibqp)\r\n{\r\nstruct nes_qp *nesqp = to_nesqp(ibqp);\r\nstruct nes_ucontext *nes_ucontext;\r\nstruct ib_qp_attr attr;\r\nstruct iw_cm_id *cm_id;\r\nstruct iw_cm_event cm_event;\r\nint ret = 0;\r\natomic_inc(&sw_qps_destroyed);\r\nnesqp->destroyed = 1;\r\nif (nesqp->ibqp_state >= IB_QPS_INIT && nesqp->ibqp_state <= IB_QPS_RTS) {\r\nattr.qp_state = IB_QPS_ERR;\r\nnes_modify_qp(&nesqp->ibqp, &attr, IB_QP_STATE, NULL);\r\n}\r\nif (((nesqp->ibqp_state == IB_QPS_INIT) ||\r\n(nesqp->ibqp_state == IB_QPS_RTR)) && (nesqp->cm_id)) {\r\ncm_id = nesqp->cm_id;\r\ncm_event.event = IW_CM_EVENT_CONNECT_REPLY;\r\ncm_event.status = -ETIMEDOUT;\r\ncm_event.local_addr = cm_id->local_addr;\r\ncm_event.remote_addr = cm_id->remote_addr;\r\ncm_event.private_data = NULL;\r\ncm_event.private_data_len = 0;\r\nnes_debug(NES_DBG_QP, "Generating a CM Timeout Event for "\r\n"QP%u. cm_id = %p, refcount = %u. \n",\r\nnesqp->hwqp.qp_id, cm_id, atomic_read(&nesqp->refcount));\r\ncm_id->rem_ref(cm_id);\r\nret = cm_id->event_handler(cm_id, &cm_event);\r\nif (ret)\r\nnes_debug(NES_DBG_QP, "OFA CM event_handler returned, ret=%d\n", ret);\r\n}\r\nif (nesqp->user_mode) {\r\nif ((ibqp->uobject)&&(ibqp->uobject->context)) {\r\nnes_ucontext = to_nesucontext(ibqp->uobject->context);\r\nclear_bit(nesqp->mmap_sq_db_index, nes_ucontext->allocated_wqs);\r\nnes_ucontext->mmap_nesqp[nesqp->mmap_sq_db_index] = NULL;\r\nif (nes_ucontext->first_free_wq > nesqp->mmap_sq_db_index) {\r\nnes_ucontext->first_free_wq = nesqp->mmap_sq_db_index;\r\n}\r\n}\r\nif (nesqp->pbl_pbase && nesqp->sq_kmapped) {\r\nnesqp->sq_kmapped = 0;\r\nkunmap(nesqp->page);\r\n}\r\n} else {\r\nif (nesqp->nesscq)\r\nnes_clean_cq(nesqp, nesqp->nesscq);\r\nif ((nesqp->nesrcq) && (nesqp->nesrcq != nesqp->nesscq))\r\nnes_clean_cq(nesqp, nesqp->nesrcq);\r\n}\r\nnes_rem_ref(&nesqp->ibqp);\r\nreturn 0;\r\n}\r\nstatic struct ib_cq *nes_create_cq(struct ib_device *ibdev, int entries,\r\nint comp_vector,\r\nstruct ib_ucontext *context, struct ib_udata *udata)\r\n{\r\nu64 u64temp;\r\nstruct nes_vnic *nesvnic = to_nesvnic(ibdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nstruct nes_cq *nescq;\r\nstruct nes_ucontext *nes_ucontext = NULL;\r\nstruct nes_cqp_request *cqp_request;\r\nvoid *mem = NULL;\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nstruct nes_pbl *nespbl = NULL;\r\nstruct nes_create_cq_req req;\r\nstruct nes_create_cq_resp resp;\r\nu32 cq_num = 0;\r\nu32 opcode = 0;\r\nu32 pbl_entries = 1;\r\nint err;\r\nunsigned long flags;\r\nint ret;\r\nif (entries > nesadapter->max_cqe)\r\nreturn ERR_PTR(-EINVAL);\r\nerr = nes_alloc_resource(nesadapter, nesadapter->allocated_cqs,\r\nnesadapter->max_cq, &cq_num, &nesadapter->next_cq, NES_RESOURCE_CQ);\r\nif (err) {\r\nreturn ERR_PTR(err);\r\n}\r\nnescq = kzalloc(sizeof(struct nes_cq), GFP_KERNEL);\r\nif (!nescq) {\r\nnes_free_resource(nesadapter, nesadapter->allocated_cqs, cq_num);\r\nnes_debug(NES_DBG_CQ, "Unable to allocate nes_cq struct\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nnescq->hw_cq.cq_size = max(entries + 1, 5);\r\nnescq->hw_cq.cq_number = cq_num;\r\nnescq->ibcq.cqe = nescq->hw_cq.cq_size - 1;\r\nif (context) {\r\nnes_ucontext = to_nesucontext(context);\r\nif (ib_copy_from_udata(&req, udata, sizeof (struct nes_create_cq_req))) {\r\nnes_free_resource(nesadapter, nesadapter->allocated_cqs, cq_num);\r\nkfree(nescq);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\nnesvnic->mcrq_ucontext = nes_ucontext;\r\nnes_ucontext->mcrqf = req.mcrqf;\r\nif (nes_ucontext->mcrqf) {\r\nif (nes_ucontext->mcrqf & 0x80000000)\r\nnescq->hw_cq.cq_number = nesvnic->nic.qp_id + 28 + 2 * ((nes_ucontext->mcrqf & 0xf) - 1);\r\nelse if (nes_ucontext->mcrqf & 0x40000000)\r\nnescq->hw_cq.cq_number = nes_ucontext->mcrqf & 0xffff;\r\nelse\r\nnescq->hw_cq.cq_number = nesvnic->mcrq_qp_id + nes_ucontext->mcrqf-1;\r\nnescq->mcrqf = nes_ucontext->mcrqf;\r\nnes_free_resource(nesadapter, nesadapter->allocated_cqs, cq_num);\r\n}\r\nnes_debug(NES_DBG_CQ, "CQ Virtual Address = %08lX, size = %u.\n",\r\n(unsigned long)req.user_cq_buffer, entries);\r\nerr = 1;\r\nlist_for_each_entry(nespbl, &nes_ucontext->cq_reg_mem_list, list) {\r\nif (nespbl->user_base == (unsigned long )req.user_cq_buffer) {\r\nlist_del(&nespbl->list);\r\nerr = 0;\r\nnes_debug(NES_DBG_CQ, "Found PBL for virtual CQ. nespbl=%p.\n",\r\nnespbl);\r\nbreak;\r\n}\r\n}\r\nif (err) {\r\nnes_free_resource(nesadapter, nesadapter->allocated_cqs, cq_num);\r\nkfree(nescq);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\npbl_entries = nespbl->pbl_size >> 3;\r\nnescq->cq_mem_size = 0;\r\n} else {\r\nnescq->cq_mem_size = nescq->hw_cq.cq_size * sizeof(struct nes_hw_cqe);\r\nnes_debug(NES_DBG_CQ, "Attempting to allocate pci memory (%u entries, %u bytes) for CQ%u.\n",\r\nentries, nescq->cq_mem_size, nescq->hw_cq.cq_number);\r\nmem = pci_alloc_consistent(nesdev->pcidev, nescq->cq_mem_size,\r\n&nescq->hw_cq.cq_pbase);\r\nif (!mem) {\r\nprintk(KERN_ERR PFX "Unable to allocate pci memory for cq\n");\r\nnes_free_resource(nesadapter, nesadapter->allocated_cqs, cq_num);\r\nkfree(nescq);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nmemset(mem, 0, nescq->cq_mem_size);\r\nnescq->hw_cq.cq_vbase = mem;\r\nnescq->hw_cq.cq_head = 0;\r\nnes_debug(NES_DBG_CQ, "CQ%u virtual address @ %p, phys = 0x%08X\n",\r\nnescq->hw_cq.cq_number, nescq->hw_cq.cq_vbase,\r\n(u32)nescq->hw_cq.cq_pbase);\r\n}\r\nnescq->hw_cq.ce_handler = nes_iwarp_ce_handler;\r\nspin_lock_init(&nescq->lock);\r\ncqp_request = nes_get_cqp_request(nesdev);\r\nif (cqp_request == NULL) {\r\nnes_debug(NES_DBG_CQ, "Failed to get a cqp_request.\n");\r\nif (!context)\r\npci_free_consistent(nesdev->pcidev, nescq->cq_mem_size, mem,\r\nnescq->hw_cq.cq_pbase);\r\nelse {\r\npci_free_consistent(nesdev->pcidev, nespbl->pbl_size,\r\nnespbl->pbl_vbase, nespbl->pbl_pbase);\r\nkfree(nespbl);\r\n}\r\nnes_free_resource(nesadapter, nesadapter->allocated_cqs, cq_num);\r\nkfree(nescq);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ncqp_request->waiting = 1;\r\ncqp_wqe = &cqp_request->cqp_wqe;\r\nopcode = NES_CQP_CREATE_CQ | NES_CQP_CQ_CEQ_VALID |\r\nNES_CQP_CQ_CHK_OVERFLOW |\r\nNES_CQP_CQ_CEQE_MASK | ((u32)nescq->hw_cq.cq_size << 16);\r\nspin_lock_irqsave(&nesadapter->pbl_lock, flags);\r\nif (pbl_entries != 1) {\r\nif (pbl_entries > 32) {\r\nnes_debug(NES_DBG_CQ, "pbl_entries=%u, use a 4k PBL\n", pbl_entries);\r\nif (nesadapter->free_4kpbl == 0) {\r\nspin_unlock_irqrestore(&nesadapter->pbl_lock, flags);\r\nnes_free_cqp_request(nesdev, cqp_request);\r\nif (!context)\r\npci_free_consistent(nesdev->pcidev, nescq->cq_mem_size, mem,\r\nnescq->hw_cq.cq_pbase);\r\nelse {\r\npci_free_consistent(nesdev->pcidev, nespbl->pbl_size,\r\nnespbl->pbl_vbase, nespbl->pbl_pbase);\r\nkfree(nespbl);\r\n}\r\nnes_free_resource(nesadapter, nesadapter->allocated_cqs, cq_num);\r\nkfree(nescq);\r\nreturn ERR_PTR(-ENOMEM);\r\n} else {\r\nopcode |= (NES_CQP_CQ_VIRT | NES_CQP_CQ_4KB_CHUNK);\r\nnescq->virtual_cq = 2;\r\nnesadapter->free_4kpbl--;\r\n}\r\n} else {\r\nnes_debug(NES_DBG_CQ, "pbl_entries=%u, use a 256 byte PBL\n", pbl_entries);\r\nif (nesadapter->free_256pbl == 0) {\r\nspin_unlock_irqrestore(&nesadapter->pbl_lock, flags);\r\nnes_free_cqp_request(nesdev, cqp_request);\r\nif (!context)\r\npci_free_consistent(nesdev->pcidev, nescq->cq_mem_size, mem,\r\nnescq->hw_cq.cq_pbase);\r\nelse {\r\npci_free_consistent(nesdev->pcidev, nespbl->pbl_size,\r\nnespbl->pbl_vbase, nespbl->pbl_pbase);\r\nkfree(nespbl);\r\n}\r\nnes_free_resource(nesadapter, nesadapter->allocated_cqs, cq_num);\r\nkfree(nescq);\r\nreturn ERR_PTR(-ENOMEM);\r\n} else {\r\nopcode |= NES_CQP_CQ_VIRT;\r\nnescq->virtual_cq = 1;\r\nnesadapter->free_256pbl--;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&nesadapter->pbl_lock, flags);\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_OPCODE_IDX, opcode);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_ID_IDX,\r\n(nescq->hw_cq.cq_number | ((u32)nesdev->ceq_index << 16)));\r\nif (context) {\r\nif (pbl_entries != 1)\r\nu64temp = (u64)nespbl->pbl_pbase;\r\nelse\r\nu64temp = le64_to_cpu(nespbl->pbl_vbase[0]);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_CQ_WQE_DOORBELL_INDEX_HIGH_IDX,\r\nnes_ucontext->mmap_db_index[0]);\r\n} else {\r\nu64temp = (u64)nescq->hw_cq.cq_pbase;\r\ncqp_wqe->wqe_words[NES_CQP_CQ_WQE_DOORBELL_INDEX_HIGH_IDX] = 0;\r\n}\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, NES_CQP_CQ_WQE_PBL_LOW_IDX, u64temp);\r\ncqp_wqe->wqe_words[NES_CQP_CQ_WQE_CQ_CONTEXT_HIGH_IDX] = 0;\r\nu64temp = (u64)(unsigned long)&nescq->hw_cq;\r\ncqp_wqe->wqe_words[NES_CQP_CQ_WQE_CQ_CONTEXT_LOW_IDX] =\r\ncpu_to_le32((u32)(u64temp >> 1));\r\ncqp_wqe->wqe_words[NES_CQP_CQ_WQE_CQ_CONTEXT_HIGH_IDX] =\r\ncpu_to_le32(((u32)((u64temp) >> 33)) & 0x7FFFFFFF);\r\natomic_set(&cqp_request->refcount, 2);\r\nnes_post_cqp_request(nesdev, cqp_request);\r\nnes_debug(NES_DBG_CQ, "Waiting for create iWARP CQ%u to complete.\n",\r\nnescq->hw_cq.cq_number);\r\nret = wait_event_timeout(cqp_request->waitq, (0 != cqp_request->request_done),\r\nNES_EVENT_TIMEOUT * 2);\r\nnes_debug(NES_DBG_CQ, "Create iWARP CQ%u completed, wait_event_timeout ret = %d.\n",\r\nnescq->hw_cq.cq_number, ret);\r\nif ((!ret) || (cqp_request->major_code)) {\r\nnes_put_cqp_request(nesdev, cqp_request);\r\nif (!context)\r\npci_free_consistent(nesdev->pcidev, nescq->cq_mem_size, mem,\r\nnescq->hw_cq.cq_pbase);\r\nelse {\r\npci_free_consistent(nesdev->pcidev, nespbl->pbl_size,\r\nnespbl->pbl_vbase, nespbl->pbl_pbase);\r\nkfree(nespbl);\r\n}\r\nnes_free_resource(nesadapter, nesadapter->allocated_cqs, cq_num);\r\nkfree(nescq);\r\nreturn ERR_PTR(-EIO);\r\n}\r\nnes_put_cqp_request(nesdev, cqp_request);\r\nif (context) {\r\npci_free_consistent(nesdev->pcidev, nespbl->pbl_size, nespbl->pbl_vbase,\r\nnespbl->pbl_pbase);\r\nkfree(nespbl);\r\nresp.cq_id = nescq->hw_cq.cq_number;\r\nresp.cq_size = nescq->hw_cq.cq_size;\r\nresp.mmap_db_index = 0;\r\nif (ib_copy_to_udata(udata, &resp, sizeof resp - sizeof resp.reserved)) {\r\nnes_free_resource(nesadapter, nesadapter->allocated_cqs, cq_num);\r\nkfree(nescq);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\n}\r\nreturn &nescq->ibcq;\r\n}\r\nstatic int nes_destroy_cq(struct ib_cq *ib_cq)\r\n{\r\nstruct nes_cq *nescq;\r\nstruct nes_device *nesdev;\r\nstruct nes_vnic *nesvnic;\r\nstruct nes_adapter *nesadapter;\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nstruct nes_cqp_request *cqp_request;\r\nunsigned long flags;\r\nu32 opcode = 0;\r\nint ret;\r\nif (ib_cq == NULL)\r\nreturn 0;\r\nnescq = to_nescq(ib_cq);\r\nnesvnic = to_nesvnic(ib_cq->device);\r\nnesdev = nesvnic->nesdev;\r\nnesadapter = nesdev->nesadapter;\r\nnes_debug(NES_DBG_CQ, "Destroy CQ%u\n", nescq->hw_cq.cq_number);\r\ncqp_request = nes_get_cqp_request(nesdev);\r\nif (cqp_request == NULL) {\r\nnes_debug(NES_DBG_CQ, "Failed to get a cqp_request.\n");\r\nreturn -ENOMEM;\r\n}\r\ncqp_request->waiting = 1;\r\ncqp_wqe = &cqp_request->cqp_wqe;\r\nopcode = NES_CQP_DESTROY_CQ | (nescq->hw_cq.cq_size << 16);\r\nspin_lock_irqsave(&nesadapter->pbl_lock, flags);\r\nif (nescq->virtual_cq == 1) {\r\nnesadapter->free_256pbl++;\r\nif (nesadapter->free_256pbl > nesadapter->max_256pbl) {\r\nprintk(KERN_ERR PFX "%s: free 256B PBLs(%u) has exceeded the max(%u)\n",\r\n__func__, nesadapter->free_256pbl, nesadapter->max_256pbl);\r\n}\r\n} else if (nescq->virtual_cq == 2) {\r\nnesadapter->free_4kpbl++;\r\nif (nesadapter->free_4kpbl > nesadapter->max_4kpbl) {\r\nprintk(KERN_ERR PFX "%s: free 4K PBLs(%u) has exceeded the max(%u)\n",\r\n__func__, nesadapter->free_4kpbl, nesadapter->max_4kpbl);\r\n}\r\nopcode |= NES_CQP_CQ_4KB_CHUNK;\r\n}\r\nspin_unlock_irqrestore(&nesadapter->pbl_lock, flags);\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_OPCODE_IDX, opcode);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_ID_IDX,\r\n(nescq->hw_cq.cq_number | ((u32)PCI_FUNC(nesdev->pcidev->devfn) << 16)));\r\nif (!nescq->mcrqf)\r\nnes_free_resource(nesadapter, nesadapter->allocated_cqs, nescq->hw_cq.cq_number);\r\natomic_set(&cqp_request->refcount, 2);\r\nnes_post_cqp_request(nesdev, cqp_request);\r\nnes_debug(NES_DBG_CQ, "Waiting for destroy iWARP CQ%u to complete.\n",\r\nnescq->hw_cq.cq_number);\r\nret = wait_event_timeout(cqp_request->waitq, (0 != cqp_request->request_done),\r\nNES_EVENT_TIMEOUT);\r\nnes_debug(NES_DBG_CQ, "Destroy iWARP CQ%u completed, wait_event_timeout ret = %u,"\r\n" CQP Major:Minor codes = 0x%04X:0x%04X.\n",\r\nnescq->hw_cq.cq_number, ret, cqp_request->major_code,\r\ncqp_request->minor_code);\r\nif (!ret) {\r\nnes_debug(NES_DBG_CQ, "iWARP CQ%u destroy timeout expired\n",\r\nnescq->hw_cq.cq_number);\r\nret = -ETIME;\r\n} else if (cqp_request->major_code) {\r\nnes_debug(NES_DBG_CQ, "iWARP CQ%u destroy failed\n",\r\nnescq->hw_cq.cq_number);\r\nret = -EIO;\r\n} else {\r\nret = 0;\r\n}\r\nnes_put_cqp_request(nesdev, cqp_request);\r\nif (nescq->cq_mem_size)\r\npci_free_consistent(nesdev->pcidev, nescq->cq_mem_size,\r\nnescq->hw_cq.cq_vbase, nescq->hw_cq.cq_pbase);\r\nkfree(nescq);\r\nreturn ret;\r\n}\r\nstatic u32 root_256(struct nes_device *nesdev,\r\nstruct nes_root_vpbl *root_vpbl,\r\nstruct nes_root_vpbl *new_root,\r\nu16 pbl_count_4k)\r\n{\r\nu64 leaf_pbl;\r\nint i, j, k;\r\nif (pbl_count_4k == 1) {\r\nnew_root->pbl_vbase = pci_alloc_consistent(nesdev->pcidev,\r\n512, &new_root->pbl_pbase);\r\nif (new_root->pbl_vbase == NULL)\r\nreturn 0;\r\nleaf_pbl = (u64)root_vpbl->pbl_pbase;\r\nfor (i = 0; i < 16; i++) {\r\nnew_root->pbl_vbase[i].pa_low =\r\ncpu_to_le32((u32)leaf_pbl);\r\nnew_root->pbl_vbase[i].pa_high =\r\ncpu_to_le32((u32)((((u64)leaf_pbl) >> 32)));\r\nleaf_pbl += 256;\r\n}\r\n} else {\r\nfor (i = 3; i >= 0; i--) {\r\nj = i * 16;\r\nroot_vpbl->pbl_vbase[j] = root_vpbl->pbl_vbase[i];\r\nleaf_pbl = le32_to_cpu(root_vpbl->pbl_vbase[j].pa_low) +\r\n(((u64)le32_to_cpu(root_vpbl->pbl_vbase[j].pa_high))\r\n<< 32);\r\nfor (k = 1; k < 16; k++) {\r\nleaf_pbl += 256;\r\nroot_vpbl->pbl_vbase[j + k].pa_low =\r\ncpu_to_le32((u32)leaf_pbl);\r\nroot_vpbl->pbl_vbase[j + k].pa_high =\r\ncpu_to_le32((u32)((((u64)leaf_pbl) >> 32)));\r\n}\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int nes_reg_mr(struct nes_device *nesdev, struct nes_pd *nespd,\r\nu32 stag, u64 region_length, struct nes_root_vpbl *root_vpbl,\r\ndma_addr_t single_buffer, u16 pbl_count_4k,\r\nu16 residual_page_count_4k, int acc, u64 *iova_start,\r\nu16 *actual_pbl_cnt, u8 *used_4k_pbls)\r\n{\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nstruct nes_cqp_request *cqp_request;\r\nunsigned long flags;\r\nint ret;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nuint pg_cnt = 0;\r\nu16 pbl_count_256 = 0;\r\nu16 pbl_count = 0;\r\nu8 use_256_pbls = 0;\r\nu8 use_4k_pbls = 0;\r\nu16 use_two_level = (pbl_count_4k > 1) ? 1 : 0;\r\nstruct nes_root_vpbl new_root = { 0, NULL, NULL };\r\nu32 opcode = 0;\r\nu16 major_code;\r\ncqp_request = nes_get_cqp_request(nesdev);\r\nif (cqp_request == NULL) {\r\nnes_debug(NES_DBG_MR, "Failed to get a cqp_request.\n");\r\nreturn -ENOMEM;\r\n}\r\ncqp_request->waiting = 1;\r\ncqp_wqe = &cqp_request->cqp_wqe;\r\nif (pbl_count_4k) {\r\nspin_lock_irqsave(&nesadapter->pbl_lock, flags);\r\npg_cnt = ((pbl_count_4k - 1) * 512) + residual_page_count_4k;\r\npbl_count_256 = (pg_cnt + 31) / 32;\r\nif (pg_cnt <= 32) {\r\nif (pbl_count_256 <= nesadapter->free_256pbl)\r\nuse_256_pbls = 1;\r\nelse if (pbl_count_4k <= nesadapter->free_4kpbl)\r\nuse_4k_pbls = 1;\r\n} else if (pg_cnt <= 2048) {\r\nif (((pbl_count_4k + use_two_level) <= nesadapter->free_4kpbl) &&\r\n(nesadapter->free_4kpbl > (nesadapter->max_4kpbl >> 1))) {\r\nuse_4k_pbls = 1;\r\n} else if ((pbl_count_256 + 1) <= nesadapter->free_256pbl) {\r\nuse_256_pbls = 1;\r\nuse_two_level = 1;\r\n} else if ((pbl_count_4k + use_two_level) <= nesadapter->free_4kpbl) {\r\nuse_4k_pbls = 1;\r\n}\r\n} else {\r\nif ((pbl_count_4k + 1) <= nesadapter->free_4kpbl)\r\nuse_4k_pbls = 1;\r\n}\r\nif (use_256_pbls) {\r\npbl_count = pbl_count_256;\r\nnesadapter->free_256pbl -= pbl_count + use_two_level;\r\n} else if (use_4k_pbls) {\r\npbl_count = pbl_count_4k;\r\nnesadapter->free_4kpbl -= pbl_count + use_two_level;\r\n} else {\r\nspin_unlock_irqrestore(&nesadapter->pbl_lock, flags);\r\nnes_debug(NES_DBG_MR, "Out of Pbls\n");\r\nnes_free_cqp_request(nesdev, cqp_request);\r\nreturn -ENOMEM;\r\n}\r\nspin_unlock_irqrestore(&nesadapter->pbl_lock, flags);\r\n}\r\nif (use_256_pbls && use_two_level) {\r\nif (root_256(nesdev, root_vpbl, &new_root, pbl_count_4k) == 1) {\r\nif (new_root.pbl_pbase != 0)\r\nroot_vpbl = &new_root;\r\n} else {\r\nspin_lock_irqsave(&nesadapter->pbl_lock, flags);\r\nnesadapter->free_256pbl += pbl_count_256 + use_two_level;\r\nuse_256_pbls = 0;\r\nif (pbl_count_4k == 1)\r\nuse_two_level = 0;\r\npbl_count = pbl_count_4k;\r\nif ((pbl_count_4k + use_two_level) <= nesadapter->free_4kpbl) {\r\nnesadapter->free_4kpbl -= pbl_count + use_two_level;\r\nuse_4k_pbls = 1;\r\n}\r\nspin_unlock_irqrestore(&nesadapter->pbl_lock, flags);\r\nif (use_4k_pbls == 0)\r\nreturn -ENOMEM;\r\n}\r\n}\r\nopcode = NES_CQP_REGISTER_STAG | NES_CQP_STAG_RIGHTS_LOCAL_READ |\r\nNES_CQP_STAG_VA_TO | NES_CQP_STAG_MR;\r\nif (acc & IB_ACCESS_LOCAL_WRITE)\r\nopcode |= NES_CQP_STAG_RIGHTS_LOCAL_WRITE;\r\nif (acc & IB_ACCESS_REMOTE_WRITE)\r\nopcode |= NES_CQP_STAG_RIGHTS_REMOTE_WRITE | NES_CQP_STAG_REM_ACC_EN;\r\nif (acc & IB_ACCESS_REMOTE_READ)\r\nopcode |= NES_CQP_STAG_RIGHTS_REMOTE_READ | NES_CQP_STAG_REM_ACC_EN;\r\nif (acc & IB_ACCESS_MW_BIND)\r\nopcode |= NES_CQP_STAG_RIGHTS_WINDOW_BIND | NES_CQP_STAG_REM_ACC_EN;\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_OPCODE_IDX, opcode);\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, NES_CQP_STAG_WQE_VA_LOW_IDX, *iova_start);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_STAG_WQE_LEN_LOW_IDX, region_length);\r\ncqp_wqe->wqe_words[NES_CQP_STAG_WQE_LEN_HIGH_PD_IDX] =\r\ncpu_to_le32((u32)(region_length >> 8) & 0xff000000);\r\ncqp_wqe->wqe_words[NES_CQP_STAG_WQE_LEN_HIGH_PD_IDX] |=\r\ncpu_to_le32(nespd->pd_id & 0x00007fff);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_STAG_WQE_STAG_IDX, stag);\r\nif (pbl_count == 0) {\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, NES_CQP_STAG_WQE_PA_LOW_IDX, single_buffer);\r\n} else {\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, NES_CQP_STAG_WQE_PA_LOW_IDX, root_vpbl->pbl_pbase);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_STAG_WQE_PBL_BLK_COUNT_IDX, pbl_count);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_STAG_WQE_PBL_LEN_IDX, (pg_cnt * 8));\r\nif (use_4k_pbls)\r\ncqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX] |= cpu_to_le32(NES_CQP_STAG_PBL_BLK_SIZE);\r\n}\r\nbarrier();\r\natomic_set(&cqp_request->refcount, 2);\r\nnes_post_cqp_request(nesdev, cqp_request);\r\nret = wait_event_timeout(cqp_request->waitq, (0 != cqp_request->request_done),\r\nNES_EVENT_TIMEOUT);\r\nnes_debug(NES_DBG_MR, "Register STag 0x%08X completed, wait_event_timeout ret = %u,"\r\n" CQP Major:Minor codes = 0x%04X:0x%04X.\n",\r\nstag, ret, cqp_request->major_code, cqp_request->minor_code);\r\nmajor_code = cqp_request->major_code;\r\nnes_put_cqp_request(nesdev, cqp_request);\r\nif ((!ret || major_code) && pbl_count != 0) {\r\nspin_lock_irqsave(&nesadapter->pbl_lock, flags);\r\nif (use_256_pbls)\r\nnesadapter->free_256pbl += pbl_count + use_two_level;\r\nelse if (use_4k_pbls)\r\nnesadapter->free_4kpbl += pbl_count + use_two_level;\r\nspin_unlock_irqrestore(&nesadapter->pbl_lock, flags);\r\n}\r\nif (new_root.pbl_pbase)\r\npci_free_consistent(nesdev->pcidev, 512, new_root.pbl_vbase,\r\nnew_root.pbl_pbase);\r\nif (!ret)\r\nreturn -ETIME;\r\nelse if (major_code)\r\nreturn -EIO;\r\n*actual_pbl_cnt = pbl_count + use_two_level;\r\n*used_4k_pbls = use_4k_pbls;\r\nreturn 0;\r\n}\r\nstatic struct ib_mr *nes_reg_phys_mr(struct ib_pd *ib_pd,\r\nstruct ib_phys_buf *buffer_list, int num_phys_buf, int acc,\r\nu64 * iova_start)\r\n{\r\nu64 region_length;\r\nstruct nes_pd *nespd = to_nespd(ib_pd);\r\nstruct nes_vnic *nesvnic = to_nesvnic(ib_pd->device);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nstruct nes_mr *nesmr;\r\nstruct ib_mr *ibmr;\r\nstruct nes_vpbl vpbl;\r\nstruct nes_root_vpbl root_vpbl;\r\nu32 stag;\r\nu32 i;\r\nunsigned long mask;\r\nu32 stag_index = 0;\r\nu32 next_stag_index = 0;\r\nu32 driver_key = 0;\r\nu32 root_pbl_index = 0;\r\nu32 cur_pbl_index = 0;\r\nint err = 0;\r\nint ret = 0;\r\nu16 pbl_count = 0;\r\nu8 single_page = 1;\r\nu8 stag_key = 0;\r\nregion_length = 0;\r\nvpbl.pbl_vbase = NULL;\r\nroot_vpbl.pbl_vbase = NULL;\r\nroot_vpbl.pbl_pbase = 0;\r\nget_random_bytes(&next_stag_index, sizeof(next_stag_index));\r\nstag_key = (u8)next_stag_index;\r\ndriver_key = 0;\r\nnext_stag_index >>= 8;\r\nnext_stag_index %= nesadapter->max_mr;\r\nif (num_phys_buf > (1024*512)) {\r\nreturn ERR_PTR(-E2BIG);\r\n}\r\nif ((buffer_list[0].addr ^ *iova_start) & ~PAGE_MASK)\r\nreturn ERR_PTR(-EINVAL);\r\nerr = nes_alloc_resource(nesadapter, nesadapter->allocated_mrs, nesadapter->max_mr,\r\n&stag_index, &next_stag_index, NES_RESOURCE_PHYS_MR);\r\nif (err) {\r\nreturn ERR_PTR(err);\r\n}\r\nnesmr = kzalloc(sizeof(*nesmr), GFP_KERNEL);\r\nif (!nesmr) {\r\nnes_free_resource(nesadapter, nesadapter->allocated_mrs, stag_index);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nfor (i = 0; i < num_phys_buf; i++) {\r\nif ((i & 0x01FF) == 0) {\r\nif (root_pbl_index == 1) {\r\nroot_vpbl.pbl_vbase = pci_alloc_consistent(nesdev->pcidev, 8192,\r\n&root_vpbl.pbl_pbase);\r\nnes_debug(NES_DBG_MR, "Allocating root PBL, va = %p, pa = 0x%08X\n",\r\nroot_vpbl.pbl_vbase, (unsigned int)root_vpbl.pbl_pbase);\r\nif (!root_vpbl.pbl_vbase) {\r\npci_free_consistent(nesdev->pcidev, 4096, vpbl.pbl_vbase,\r\nvpbl.pbl_pbase);\r\nnes_free_resource(nesadapter, nesadapter->allocated_mrs, stag_index);\r\nkfree(nesmr);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nroot_vpbl.leaf_vpbl = kzalloc(sizeof(*root_vpbl.leaf_vpbl)*1024, GFP_KERNEL);\r\nif (!root_vpbl.leaf_vpbl) {\r\npci_free_consistent(nesdev->pcidev, 8192, root_vpbl.pbl_vbase,\r\nroot_vpbl.pbl_pbase);\r\npci_free_consistent(nesdev->pcidev, 4096, vpbl.pbl_vbase,\r\nvpbl.pbl_pbase);\r\nnes_free_resource(nesadapter, nesadapter->allocated_mrs, stag_index);\r\nkfree(nesmr);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nroot_vpbl.pbl_vbase[0].pa_low = cpu_to_le32((u32)vpbl.pbl_pbase);\r\nroot_vpbl.pbl_vbase[0].pa_high =\r\ncpu_to_le32((u32)((((u64)vpbl.pbl_pbase) >> 32)));\r\nroot_vpbl.leaf_vpbl[0] = vpbl;\r\n}\r\nvpbl.pbl_vbase = pci_alloc_consistent(nesdev->pcidev, 4096,\r\n&vpbl.pbl_pbase);\r\nnes_debug(NES_DBG_MR, "Allocating leaf PBL, va = %p, pa = 0x%016lX\n",\r\nvpbl.pbl_vbase, (unsigned long)vpbl.pbl_pbase);\r\nif (!vpbl.pbl_vbase) {\r\nnes_free_resource(nesadapter, nesadapter->allocated_mrs, stag_index);\r\nibmr = ERR_PTR(-ENOMEM);\r\nkfree(nesmr);\r\ngoto reg_phys_err;\r\n}\r\nif (1 <= root_pbl_index) {\r\nroot_vpbl.pbl_vbase[root_pbl_index].pa_low =\r\ncpu_to_le32((u32)vpbl.pbl_pbase);\r\nroot_vpbl.pbl_vbase[root_pbl_index].pa_high =\r\ncpu_to_le32((u32)((((u64)vpbl.pbl_pbase) >> 32)));\r\nroot_vpbl.leaf_vpbl[root_pbl_index] = vpbl;\r\n}\r\nroot_pbl_index++;\r\ncur_pbl_index = 0;\r\n}\r\nmask = !buffer_list[i].size;\r\nif (i != 0)\r\nmask |= buffer_list[i].addr;\r\nif (i != num_phys_buf - 1)\r\nmask |= buffer_list[i].addr + buffer_list[i].size;\r\nif (mask & ~PAGE_MASK) {\r\nnes_free_resource(nesadapter, nesadapter->allocated_mrs, stag_index);\r\nnes_debug(NES_DBG_MR, "Invalid buffer addr or size\n");\r\nibmr = ERR_PTR(-EINVAL);\r\nkfree(nesmr);\r\ngoto reg_phys_err;\r\n}\r\nregion_length += buffer_list[i].size;\r\nif ((i != 0) && (single_page)) {\r\nif ((buffer_list[i-1].addr+PAGE_SIZE) != buffer_list[i].addr)\r\nsingle_page = 0;\r\n}\r\nvpbl.pbl_vbase[cur_pbl_index].pa_low = cpu_to_le32((u32)buffer_list[i].addr & PAGE_MASK);\r\nvpbl.pbl_vbase[cur_pbl_index++].pa_high =\r\ncpu_to_le32((u32)((((u64)buffer_list[i].addr) >> 32)));\r\n}\r\nstag = stag_index << 8;\r\nstag |= driver_key;\r\nstag += (u32)stag_key;\r\nnes_debug(NES_DBG_MR, "Registering STag 0x%08X, VA = 0x%016lX,"\r\n" length = 0x%016lX, index = 0x%08X\n",\r\nstag, (unsigned long)*iova_start, (unsigned long)region_length, stag_index);\r\nif (root_pbl_index == 1) {\r\nroot_vpbl.pbl_pbase = vpbl.pbl_pbase;\r\n}\r\nif (single_page) {\r\npbl_count = 0;\r\n} else {\r\npbl_count = root_pbl_index;\r\n}\r\nret = nes_reg_mr(nesdev, nespd, stag, region_length, &root_vpbl,\r\nbuffer_list[0].addr, pbl_count, (u16)cur_pbl_index, acc, iova_start,\r\n&nesmr->pbls_used, &nesmr->pbl_4k);\r\nif (ret == 0) {\r\nnesmr->ibmr.rkey = stag;\r\nnesmr->ibmr.lkey = stag;\r\nnesmr->mode = IWNES_MEMREG_TYPE_MEM;\r\nibmr = &nesmr->ibmr;\r\n} else {\r\nkfree(nesmr);\r\nibmr = ERR_PTR(-ENOMEM);\r\n}\r\nreg_phys_err:\r\nif (root_pbl_index == 1) {\r\npci_free_consistent(nesdev->pcidev, 4096, vpbl.pbl_vbase, vpbl.pbl_pbase);\r\n} else {\r\nfor (i=0; i<root_pbl_index; i++) {\r\npci_free_consistent(nesdev->pcidev, 4096, root_vpbl.leaf_vpbl[i].pbl_vbase,\r\nroot_vpbl.leaf_vpbl[i].pbl_pbase);\r\n}\r\nkfree(root_vpbl.leaf_vpbl);\r\npci_free_consistent(nesdev->pcidev, 8192, root_vpbl.pbl_vbase,\r\nroot_vpbl.pbl_pbase);\r\n}\r\nreturn ibmr;\r\n}\r\nstatic struct ib_mr *nes_get_dma_mr(struct ib_pd *pd, int acc)\r\n{\r\nstruct ib_phys_buf bl;\r\nu64 kva = 0;\r\nnes_debug(NES_DBG_MR, "\n");\r\nbl.size = (u64)0xffffffffffULL;\r\nbl.addr = 0;\r\nreturn nes_reg_phys_mr(pd, &bl, 1, acc, &kva);\r\n}\r\nstatic struct ib_mr *nes_reg_user_mr(struct ib_pd *pd, u64 start, u64 length,\r\nu64 virt, int acc, struct ib_udata *udata)\r\n{\r\nu64 iova_start;\r\n__le64 *pbl;\r\nu64 region_length;\r\ndma_addr_t last_dma_addr = 0;\r\ndma_addr_t first_dma_addr = 0;\r\nstruct nes_pd *nespd = to_nespd(pd);\r\nstruct nes_vnic *nesvnic = to_nesvnic(pd->device);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nstruct ib_mr *ibmr = ERR_PTR(-EINVAL);\r\nstruct ib_umem_chunk *chunk;\r\nstruct nes_ucontext *nes_ucontext;\r\nstruct nes_pbl *nespbl;\r\nstruct nes_mr *nesmr;\r\nstruct ib_umem *region;\r\nstruct nes_mem_reg_req req;\r\nstruct nes_vpbl vpbl;\r\nstruct nes_root_vpbl root_vpbl;\r\nint nmap_index, page_index;\r\nint page_count = 0;\r\nint err, pbl_depth = 0;\r\nint chunk_pages;\r\nint ret;\r\nu32 stag;\r\nu32 stag_index = 0;\r\nu32 next_stag_index;\r\nu32 driver_key;\r\nu32 root_pbl_index = 0;\r\nu32 cur_pbl_index = 0;\r\nu32 skip_pages;\r\nu16 pbl_count;\r\nu8 single_page = 1;\r\nu8 stag_key;\r\nregion = ib_umem_get(pd->uobject->context, start, length, acc, 0);\r\nif (IS_ERR(region)) {\r\nreturn (struct ib_mr *)region;\r\n}\r\nnes_debug(NES_DBG_MR, "User base = 0x%lX, Virt base = 0x%lX, length = %u,"\r\n" offset = %u, page size = %u.\n",\r\n(unsigned long int)start, (unsigned long int)virt, (u32)length,\r\nregion->offset, region->page_size);\r\nskip_pages = ((u32)region->offset) >> 12;\r\nif (ib_copy_from_udata(&req, udata, sizeof(req))) {\r\nib_umem_release(region);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\nnes_debug(NES_DBG_MR, "Memory Registration type = %08X.\n", req.reg_type);\r\nswitch (req.reg_type) {\r\ncase IWNES_MEMREG_TYPE_MEM:\r\npbl_depth = 0;\r\nregion_length = 0;\r\nvpbl.pbl_vbase = NULL;\r\nroot_vpbl.pbl_vbase = NULL;\r\nroot_vpbl.pbl_pbase = 0;\r\nget_random_bytes(&next_stag_index, sizeof(next_stag_index));\r\nstag_key = (u8)next_stag_index;\r\ndriver_key = next_stag_index & 0x70000000;\r\nnext_stag_index >>= 8;\r\nnext_stag_index %= nesadapter->max_mr;\r\nerr = nes_alloc_resource(nesadapter, nesadapter->allocated_mrs,\r\nnesadapter->max_mr, &stag_index, &next_stag_index, NES_RESOURCE_USER_MR);\r\nif (err) {\r\nib_umem_release(region);\r\nreturn ERR_PTR(err);\r\n}\r\nnesmr = kzalloc(sizeof(*nesmr), GFP_KERNEL);\r\nif (!nesmr) {\r\nib_umem_release(region);\r\nnes_free_resource(nesadapter, nesadapter->allocated_mrs, stag_index);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nnesmr->region = region;\r\nlist_for_each_entry(chunk, &region->chunk_list, list) {\r\nnes_debug(NES_DBG_MR, "Chunk: nents = %u, nmap = %u .\n",\r\nchunk->nents, chunk->nmap);\r\nfor (nmap_index = 0; nmap_index < chunk->nmap; ++nmap_index) {\r\nif (sg_dma_address(&chunk->page_list[nmap_index]) & ~PAGE_MASK) {\r\nib_umem_release(region);\r\nnes_free_resource(nesadapter, nesadapter->allocated_mrs, stag_index);\r\nnes_debug(NES_DBG_MR, "Unaligned Memory Buffer: 0x%x\n",\r\n(unsigned int) sg_dma_address(&chunk->page_list[nmap_index]));\r\nibmr = ERR_PTR(-EINVAL);\r\nkfree(nesmr);\r\ngoto reg_user_mr_err;\r\n}\r\nif (!sg_dma_len(&chunk->page_list[nmap_index])) {\r\nib_umem_release(region);\r\nnes_free_resource(nesadapter, nesadapter->allocated_mrs,\r\nstag_index);\r\nnes_debug(NES_DBG_MR, "Invalid Buffer Size\n");\r\nibmr = ERR_PTR(-EINVAL);\r\nkfree(nesmr);\r\ngoto reg_user_mr_err;\r\n}\r\nregion_length += sg_dma_len(&chunk->page_list[nmap_index]);\r\nchunk_pages = sg_dma_len(&chunk->page_list[nmap_index]) >> 12;\r\nregion_length -= skip_pages << 12;\r\nfor (page_index=skip_pages; page_index < chunk_pages; page_index++) {\r\nskip_pages = 0;\r\nif ((page_count!=0)&&(page_count<<12)-(region->offset&(4096-1))>=region->length)\r\ngoto enough_pages;\r\nif ((page_count&0x01FF) == 0) {\r\nif (page_count >= 1024 * 512) {\r\nib_umem_release(region);\r\nnes_free_resource(nesadapter,\r\nnesadapter->allocated_mrs, stag_index);\r\nkfree(nesmr);\r\nibmr = ERR_PTR(-E2BIG);\r\ngoto reg_user_mr_err;\r\n}\r\nif (root_pbl_index == 1) {\r\nroot_vpbl.pbl_vbase = pci_alloc_consistent(nesdev->pcidev,\r\n8192, &root_vpbl.pbl_pbase);\r\nnes_debug(NES_DBG_MR, "Allocating root PBL, va = %p, pa = 0x%08X\n",\r\nroot_vpbl.pbl_vbase, (unsigned int)root_vpbl.pbl_pbase);\r\nif (!root_vpbl.pbl_vbase) {\r\nib_umem_release(region);\r\npci_free_consistent(nesdev->pcidev, 4096, vpbl.pbl_vbase,\r\nvpbl.pbl_pbase);\r\nnes_free_resource(nesadapter, nesadapter->allocated_mrs,\r\nstag_index);\r\nkfree(nesmr);\r\nibmr = ERR_PTR(-ENOMEM);\r\ngoto reg_user_mr_err;\r\n}\r\nroot_vpbl.leaf_vpbl = kzalloc(sizeof(*root_vpbl.leaf_vpbl)*1024,\r\nGFP_KERNEL);\r\nif (!root_vpbl.leaf_vpbl) {\r\nib_umem_release(region);\r\npci_free_consistent(nesdev->pcidev, 8192, root_vpbl.pbl_vbase,\r\nroot_vpbl.pbl_pbase);\r\npci_free_consistent(nesdev->pcidev, 4096, vpbl.pbl_vbase,\r\nvpbl.pbl_pbase);\r\nnes_free_resource(nesadapter, nesadapter->allocated_mrs,\r\nstag_index);\r\nkfree(nesmr);\r\nibmr = ERR_PTR(-ENOMEM);\r\ngoto reg_user_mr_err;\r\n}\r\nroot_vpbl.pbl_vbase[0].pa_low =\r\ncpu_to_le32((u32)vpbl.pbl_pbase);\r\nroot_vpbl.pbl_vbase[0].pa_high =\r\ncpu_to_le32((u32)((((u64)vpbl.pbl_pbase) >> 32)));\r\nroot_vpbl.leaf_vpbl[0] = vpbl;\r\n}\r\nvpbl.pbl_vbase = pci_alloc_consistent(nesdev->pcidev, 4096,\r\n&vpbl.pbl_pbase);\r\nnes_debug(NES_DBG_MR, "Allocating leaf PBL, va = %p, pa = 0x%08X\n",\r\nvpbl.pbl_vbase, (unsigned int)vpbl.pbl_pbase);\r\nif (!vpbl.pbl_vbase) {\r\nib_umem_release(region);\r\nnes_free_resource(nesadapter, nesadapter->allocated_mrs, stag_index);\r\nibmr = ERR_PTR(-ENOMEM);\r\nkfree(nesmr);\r\ngoto reg_user_mr_err;\r\n}\r\nif (1 <= root_pbl_index) {\r\nroot_vpbl.pbl_vbase[root_pbl_index].pa_low =\r\ncpu_to_le32((u32)vpbl.pbl_pbase);\r\nroot_vpbl.pbl_vbase[root_pbl_index].pa_high =\r\ncpu_to_le32((u32)((((u64)vpbl.pbl_pbase)>>32)));\r\nroot_vpbl.leaf_vpbl[root_pbl_index] = vpbl;\r\n}\r\nroot_pbl_index++;\r\ncur_pbl_index = 0;\r\n}\r\nif (single_page) {\r\nif (page_count != 0) {\r\nif ((last_dma_addr+4096) !=\r\n(sg_dma_address(&chunk->page_list[nmap_index])+\r\n(page_index*4096)))\r\nsingle_page = 0;\r\nlast_dma_addr = sg_dma_address(&chunk->page_list[nmap_index])+\r\n(page_index*4096);\r\n} else {\r\nfirst_dma_addr = sg_dma_address(&chunk->page_list[nmap_index])+\r\n(page_index*4096);\r\nlast_dma_addr = first_dma_addr;\r\n}\r\n}\r\nvpbl.pbl_vbase[cur_pbl_index].pa_low =\r\ncpu_to_le32((u32)(sg_dma_address(&chunk->page_list[nmap_index])+\r\n(page_index*4096)));\r\nvpbl.pbl_vbase[cur_pbl_index].pa_high =\r\ncpu_to_le32((u32)((((u64)(sg_dma_address(&chunk->page_list[nmap_index])+\r\n(page_index*4096))) >> 32)));\r\ncur_pbl_index++;\r\npage_count++;\r\n}\r\n}\r\n}\r\nenough_pages:\r\nnes_debug(NES_DBG_MR, "calculating stag, stag_index=0x%08x, driver_key=0x%08x,"\r\n" stag_key=0x%08x\n",\r\nstag_index, driver_key, stag_key);\r\nstag = stag_index << 8;\r\nstag |= driver_key;\r\nstag += (u32)stag_key;\r\niova_start = virt;\r\nif (root_pbl_index == 1) {\r\nroot_vpbl.pbl_pbase = vpbl.pbl_pbase;\r\n}\r\nif (single_page) {\r\npbl_count = 0;\r\n} else {\r\npbl_count = root_pbl_index;\r\nfirst_dma_addr = 0;\r\n}\r\nnes_debug(NES_DBG_MR, "Registering STag 0x%08X, VA = 0x%08X, length = 0x%08X,"\r\n" index = 0x%08X, region->length=0x%08llx, pbl_count = %u\n",\r\nstag, (unsigned int)iova_start,\r\n(unsigned int)region_length, stag_index,\r\n(unsigned long long)region->length, pbl_count);\r\nret = nes_reg_mr(nesdev, nespd, stag, region->length, &root_vpbl,\r\nfirst_dma_addr, pbl_count, (u16)cur_pbl_index, acc,\r\n&iova_start, &nesmr->pbls_used, &nesmr->pbl_4k);\r\nnes_debug(NES_DBG_MR, "ret=%d\n", ret);\r\nif (ret == 0) {\r\nnesmr->ibmr.rkey = stag;\r\nnesmr->ibmr.lkey = stag;\r\nnesmr->mode = IWNES_MEMREG_TYPE_MEM;\r\nibmr = &nesmr->ibmr;\r\n} else {\r\nib_umem_release(region);\r\nkfree(nesmr);\r\nibmr = ERR_PTR(-ENOMEM);\r\n}\r\nreg_user_mr_err:\r\nif (root_pbl_index == 1) {\r\npci_free_consistent(nesdev->pcidev, 4096, vpbl.pbl_vbase,\r\nvpbl.pbl_pbase);\r\n} else {\r\nfor (page_index=0; page_index<root_pbl_index; page_index++) {\r\npci_free_consistent(nesdev->pcidev, 4096,\r\nroot_vpbl.leaf_vpbl[page_index].pbl_vbase,\r\nroot_vpbl.leaf_vpbl[page_index].pbl_pbase);\r\n}\r\nkfree(root_vpbl.leaf_vpbl);\r\npci_free_consistent(nesdev->pcidev, 8192, root_vpbl.pbl_vbase,\r\nroot_vpbl.pbl_pbase);\r\n}\r\nnes_debug(NES_DBG_MR, "Leaving, ibmr=%p", ibmr);\r\nreturn ibmr;\r\ncase IWNES_MEMREG_TYPE_QP:\r\ncase IWNES_MEMREG_TYPE_CQ:\r\nif (!region->length) {\r\nnes_debug(NES_DBG_MR, "Unable to register zero length region for CQ\n");\r\nib_umem_release(region);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nnespbl = kzalloc(sizeof(*nespbl), GFP_KERNEL);\r\nif (!nespbl) {\r\nnes_debug(NES_DBG_MR, "Unable to allocate PBL\n");\r\nib_umem_release(region);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nnesmr = kzalloc(sizeof(*nesmr), GFP_KERNEL);\r\nif (!nesmr) {\r\nib_umem_release(region);\r\nkfree(nespbl);\r\nnes_debug(NES_DBG_MR, "Unable to allocate nesmr\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nnesmr->region = region;\r\nnes_ucontext = to_nesucontext(pd->uobject->context);\r\npbl_depth = region->length >> 12;\r\npbl_depth += (region->length & (4096-1)) ? 1 : 0;\r\nnespbl->pbl_size = pbl_depth*sizeof(u64);\r\nif (req.reg_type == IWNES_MEMREG_TYPE_QP) {\r\nnes_debug(NES_DBG_MR, "Attempting to allocate QP PBL memory");\r\n} else {\r\nnes_debug(NES_DBG_MR, "Attempting to allocate CP PBL memory");\r\n}\r\nnes_debug(NES_DBG_MR, " %u bytes, %u entries.\n",\r\nnespbl->pbl_size, pbl_depth);\r\npbl = pci_alloc_consistent(nesdev->pcidev, nespbl->pbl_size,\r\n&nespbl->pbl_pbase);\r\nif (!pbl) {\r\nib_umem_release(region);\r\nkfree(nesmr);\r\nkfree(nespbl);\r\nnes_debug(NES_DBG_MR, "Unable to allocate PBL memory\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nnespbl->pbl_vbase = (u64 *)pbl;\r\nnespbl->user_base = start;\r\nnes_debug(NES_DBG_MR, "Allocated PBL memory, %u bytes, pbl_pbase=%lx,"\r\n" pbl_vbase=%p user_base=0x%lx\n",\r\nnespbl->pbl_size, (unsigned long) nespbl->pbl_pbase,\r\n(void *) nespbl->pbl_vbase, nespbl->user_base);\r\nlist_for_each_entry(chunk, &region->chunk_list, list) {\r\nfor (nmap_index = 0; nmap_index < chunk->nmap; ++nmap_index) {\r\nchunk_pages = sg_dma_len(&chunk->page_list[nmap_index]) >> 12;\r\nchunk_pages += (sg_dma_len(&chunk->page_list[nmap_index]) & (4096-1)) ? 1 : 0;\r\nnespbl->page = sg_page(&chunk->page_list[0]);\r\nfor (page_index=0; page_index<chunk_pages; page_index++) {\r\n((__le32 *)pbl)[0] = cpu_to_le32((u32)\r\n(sg_dma_address(&chunk->page_list[nmap_index])+\r\n(page_index*4096)));\r\n((__le32 *)pbl)[1] = cpu_to_le32(((u64)\r\n(sg_dma_address(&chunk->page_list[nmap_index])+\r\n(page_index*4096)))>>32);\r\nnes_debug(NES_DBG_MR, "pbl=%p, *pbl=0x%016llx, 0x%08x%08x\n", pbl,\r\n(unsigned long long)*pbl,\r\nle32_to_cpu(((__le32 *)pbl)[1]), le32_to_cpu(((__le32 *)pbl)[0]));\r\npbl++;\r\n}\r\n}\r\n}\r\nif (req.reg_type == IWNES_MEMREG_TYPE_QP) {\r\nlist_add_tail(&nespbl->list, &nes_ucontext->qp_reg_mem_list);\r\n} else {\r\nlist_add_tail(&nespbl->list, &nes_ucontext->cq_reg_mem_list);\r\n}\r\nnesmr->ibmr.rkey = -1;\r\nnesmr->ibmr.lkey = -1;\r\nnesmr->mode = req.reg_type;\r\nreturn &nesmr->ibmr;\r\n}\r\nib_umem_release(region);\r\nreturn ERR_PTR(-ENOSYS);\r\n}\r\nstatic int nes_dereg_mr(struct ib_mr *ib_mr)\r\n{\r\nstruct nes_mr *nesmr = to_nesmr(ib_mr);\r\nstruct nes_vnic *nesvnic = to_nesvnic(ib_mr->device);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nstruct nes_cqp_request *cqp_request;\r\nunsigned long flags;\r\nint ret;\r\nu16 major_code;\r\nu16 minor_code;\r\nif (nesmr->region) {\r\nib_umem_release(nesmr->region);\r\n}\r\nif (nesmr->mode != IWNES_MEMREG_TYPE_MEM) {\r\nkfree(nesmr);\r\nreturn 0;\r\n}\r\ncqp_request = nes_get_cqp_request(nesdev);\r\nif (cqp_request == NULL) {\r\nnes_debug(NES_DBG_MR, "Failed to get a cqp_request.\n");\r\nreturn -ENOMEM;\r\n}\r\ncqp_request->waiting = 1;\r\ncqp_wqe = &cqp_request->cqp_wqe;\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_OPCODE_IDX,\r\nNES_CQP_DEALLOCATE_STAG | NES_CQP_STAG_VA_TO |\r\nNES_CQP_STAG_DEALLOC_PBLS | NES_CQP_STAG_MR);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_STAG_WQE_STAG_IDX, ib_mr->rkey);\r\natomic_set(&cqp_request->refcount, 2);\r\nnes_post_cqp_request(nesdev, cqp_request);\r\nnes_debug(NES_DBG_MR, "Waiting for deallocate STag 0x%08X completed\n", ib_mr->rkey);\r\nret = wait_event_timeout(cqp_request->waitq, (cqp_request->request_done != 0),\r\nNES_EVENT_TIMEOUT);\r\nnes_debug(NES_DBG_MR, "Deallocate STag 0x%08X completed, wait_event_timeout ret = %u,"\r\n" CQP Major:Minor codes = 0x%04X:0x%04X\n",\r\nib_mr->rkey, ret, cqp_request->major_code, cqp_request->minor_code);\r\nmajor_code = cqp_request->major_code;\r\nminor_code = cqp_request->minor_code;\r\nnes_put_cqp_request(nesdev, cqp_request);\r\nif (!ret) {\r\nnes_debug(NES_DBG_MR, "Timeout waiting to destroy STag,"\r\n" ib_mr=%p, rkey = 0x%08X\n",\r\nib_mr, ib_mr->rkey);\r\nreturn -ETIME;\r\n} else if (major_code) {\r\nnes_debug(NES_DBG_MR, "Error (0x%04X:0x%04X) while attempting"\r\n" to destroy STag, ib_mr=%p, rkey = 0x%08X\n",\r\nmajor_code, minor_code, ib_mr, ib_mr->rkey);\r\nreturn -EIO;\r\n}\r\nif (nesmr->pbls_used != 0) {\r\nspin_lock_irqsave(&nesadapter->pbl_lock, flags);\r\nif (nesmr->pbl_4k) {\r\nnesadapter->free_4kpbl += nesmr->pbls_used;\r\nif (nesadapter->free_4kpbl > nesadapter->max_4kpbl)\r\nprintk(KERN_ERR PFX "free 4KB PBLs(%u) has "\r\n"exceeded the max(%u)\n",\r\nnesadapter->free_4kpbl,\r\nnesadapter->max_4kpbl);\r\n} else {\r\nnesadapter->free_256pbl += nesmr->pbls_used;\r\nif (nesadapter->free_256pbl > nesadapter->max_256pbl)\r\nprintk(KERN_ERR PFX "free 256B PBLs(%u) has "\r\n"exceeded the max(%u)\n",\r\nnesadapter->free_256pbl,\r\nnesadapter->max_256pbl);\r\n}\r\nspin_unlock_irqrestore(&nesadapter->pbl_lock, flags);\r\n}\r\nnes_free_resource(nesadapter, nesadapter->allocated_mrs,\r\n(ib_mr->rkey & 0x0fffff00) >> 8);\r\nkfree(nesmr);\r\nreturn 0;\r\n}\r\nstatic ssize_t show_rev(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct nes_ib_device *nesibdev =\r\ncontainer_of(dev, struct nes_ib_device, ibdev.dev);\r\nstruct nes_vnic *nesvnic = nesibdev->nesvnic;\r\nnes_debug(NES_DBG_INIT, "\n");\r\nreturn sprintf(buf, "%x\n", nesvnic->nesdev->nesadapter->hw_rev);\r\n}\r\nstatic ssize_t show_fw_ver(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct nes_ib_device *nesibdev =\r\ncontainer_of(dev, struct nes_ib_device, ibdev.dev);\r\nstruct nes_vnic *nesvnic = nesibdev->nesvnic;\r\nnes_debug(NES_DBG_INIT, "\n");\r\nreturn sprintf(buf, "%u.%u\n",\r\n(nesvnic->nesdev->nesadapter->firmware_version >> 16),\r\n(nesvnic->nesdev->nesadapter->firmware_version & 0x000000ff));\r\n}\r\nstatic ssize_t show_hca(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nnes_debug(NES_DBG_INIT, "\n");\r\nreturn sprintf(buf, "NES020\n");\r\n}\r\nstatic ssize_t show_board(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nnes_debug(NES_DBG_INIT, "\n");\r\nreturn sprintf(buf, "%.*s\n", 32, "NES020 Board ID");\r\n}\r\nstatic int nes_query_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,\r\nint attr_mask, struct ib_qp_init_attr *init_attr)\r\n{\r\nstruct nes_qp *nesqp = to_nesqp(ibqp);\r\nnes_debug(NES_DBG_QP, "\n");\r\nattr->qp_access_flags = 0;\r\nattr->cap.max_send_wr = nesqp->hwqp.sq_size;\r\nattr->cap.max_recv_wr = nesqp->hwqp.rq_size;\r\nattr->cap.max_recv_sge = 1;\r\nif (nes_drv_opt & NES_DRV_OPT_NO_INLINE_DATA)\r\nattr->cap.max_inline_data = 0;\r\nelse\r\nattr->cap.max_inline_data = 64;\r\ninit_attr->event_handler = nesqp->ibqp.event_handler;\r\ninit_attr->qp_context = nesqp->ibqp.qp_context;\r\ninit_attr->send_cq = nesqp->ibqp.send_cq;\r\ninit_attr->recv_cq = nesqp->ibqp.recv_cq;\r\ninit_attr->srq = nesqp->ibqp.srq = nesqp->ibqp.srq;\r\ninit_attr->cap = attr->cap;\r\nreturn 0;\r\n}\r\nint nes_hw_modify_qp(struct nes_device *nesdev, struct nes_qp *nesqp,\r\nu32 next_iwarp_state, u32 termlen, u32 wait_completion)\r\n{\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nstruct nes_cqp_request *cqp_request;\r\nint ret;\r\nu16 major_code;\r\nnes_debug(NES_DBG_MOD_QP, "QP%u, refcount=%d\n",\r\nnesqp->hwqp.qp_id, atomic_read(&nesqp->refcount));\r\ncqp_request = nes_get_cqp_request(nesdev);\r\nif (cqp_request == NULL) {\r\nnes_debug(NES_DBG_MOD_QP, "Failed to get a cqp_request.\n");\r\nreturn -ENOMEM;\r\n}\r\nif (wait_completion) {\r\ncqp_request->waiting = 1;\r\n} else {\r\ncqp_request->waiting = 0;\r\n}\r\ncqp_wqe = &cqp_request->cqp_wqe;\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_OPCODE_IDX,\r\nNES_CQP_MODIFY_QP | NES_CQP_QP_TYPE_IWARP | next_iwarp_state);\r\nnes_debug(NES_DBG_MOD_QP, "using next_iwarp_state=%08x, wqe_words=%08x\n",\r\nnext_iwarp_state, le32_to_cpu(cqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX]));\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_ID_IDX, nesqp->hwqp.qp_id);\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, NES_CQP_QP_WQE_CONTEXT_LOW_IDX, (u64)nesqp->nesqp_context_pbase);\r\nif (((next_iwarp_state & NES_CQP_QP_IWARP_STATE_MASK) == NES_CQP_QP_IWARP_STATE_TERMINATE) &&\r\n!(next_iwarp_state & NES_CQP_QP_TERM_DONT_SEND_TERM_MSG)) {\r\ntermlen = ((termlen + 3) >> 2) << NES_CQP_OP_TERMLEN_SHIFT;\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_QP_WQE_NEW_MSS_IDX, termlen);\r\n}\r\natomic_set(&cqp_request->refcount, 2);\r\nnes_post_cqp_request(nesdev, cqp_request);\r\nif (wait_completion) {\r\nret = wait_event_timeout(cqp_request->waitq, (cqp_request->request_done != 0),\r\nNES_EVENT_TIMEOUT);\r\nnes_debug(NES_DBG_MOD_QP, "Modify iwarp QP%u completed, wait_event_timeout ret=%u, "\r\n"CQP Major:Minor codes = 0x%04X:0x%04X.\n",\r\nnesqp->hwqp.qp_id, ret, cqp_request->major_code, cqp_request->minor_code);\r\nmajor_code = cqp_request->major_code;\r\nif (major_code) {\r\nnes_debug(NES_DBG_MOD_QP, "Modify iwarp QP%u failed"\r\n"CQP Major:Minor codes = 0x%04X:0x%04X, intended next state = 0x%08X.\n",\r\nnesqp->hwqp.qp_id, cqp_request->major_code,\r\ncqp_request->minor_code, next_iwarp_state);\r\n}\r\nnes_put_cqp_request(nesdev, cqp_request);\r\nif (!ret)\r\nreturn -ETIME;\r\nelse if (major_code)\r\nreturn -EIO;\r\nelse\r\nreturn 0;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nint nes_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,\r\nint attr_mask, struct ib_udata *udata)\r\n{\r\nstruct nes_qp *nesqp = to_nesqp(ibqp);\r\nstruct nes_vnic *nesvnic = to_nesvnic(ibqp->device);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nu32 next_iwarp_state = 0;\r\nint err;\r\nunsigned long qplockflags;\r\nint ret;\r\nu16 original_last_aeq;\r\nu8 issue_modify_qp = 0;\r\nu8 dont_wait = 0;\r\nnes_debug(NES_DBG_MOD_QP, "QP%u: QP State=%u, cur QP State=%u,"\r\n" iwarp_state=0x%X, refcount=%d\n",\r\nnesqp->hwqp.qp_id, attr->qp_state, nesqp->ibqp_state,\r\nnesqp->iwarp_state, atomic_read(&nesqp->refcount));\r\nspin_lock_irqsave(&nesqp->lock, qplockflags);\r\nnes_debug(NES_DBG_MOD_QP, "QP%u: hw_iwarp_state=0x%X, hw_tcp_state=0x%X,"\r\n" QP Access Flags=0x%X, attr_mask = 0x%0x\n",\r\nnesqp->hwqp.qp_id, nesqp->hw_iwarp_state,\r\nnesqp->hw_tcp_state, attr->qp_access_flags, attr_mask);\r\nif (attr_mask & IB_QP_STATE) {\r\nswitch (attr->qp_state) {\r\ncase IB_QPS_INIT:\r\nnes_debug(NES_DBG_MOD_QP, "QP%u: new state = init\n",\r\nnesqp->hwqp.qp_id);\r\nif (nesqp->iwarp_state > (u32)NES_CQP_QP_IWARP_STATE_IDLE) {\r\nspin_unlock_irqrestore(&nesqp->lock, qplockflags);\r\nreturn -EINVAL;\r\n}\r\nnext_iwarp_state = NES_CQP_QP_IWARP_STATE_IDLE;\r\nissue_modify_qp = 1;\r\nbreak;\r\ncase IB_QPS_RTR:\r\nnes_debug(NES_DBG_MOD_QP, "QP%u: new state = rtr\n",\r\nnesqp->hwqp.qp_id);\r\nif (nesqp->iwarp_state>(u32)NES_CQP_QP_IWARP_STATE_IDLE) {\r\nspin_unlock_irqrestore(&nesqp->lock, qplockflags);\r\nreturn -EINVAL;\r\n}\r\nnext_iwarp_state = NES_CQP_QP_IWARP_STATE_IDLE;\r\nissue_modify_qp = 1;\r\nbreak;\r\ncase IB_QPS_RTS:\r\nnes_debug(NES_DBG_MOD_QP, "QP%u: new state = rts\n",\r\nnesqp->hwqp.qp_id);\r\nif (nesqp->iwarp_state>(u32)NES_CQP_QP_IWARP_STATE_RTS) {\r\nspin_unlock_irqrestore(&nesqp->lock, qplockflags);\r\nreturn -EINVAL;\r\n}\r\nif (nesqp->cm_id == NULL) {\r\nnes_debug(NES_DBG_MOD_QP, "QP%u: Failing attempt to move QP to RTS without a CM_ID. \n",\r\nnesqp->hwqp.qp_id );\r\nspin_unlock_irqrestore(&nesqp->lock, qplockflags);\r\nreturn -EINVAL;\r\n}\r\nnext_iwarp_state = NES_CQP_QP_IWARP_STATE_RTS;\r\nif (nesqp->iwarp_state != NES_CQP_QP_IWARP_STATE_RTS)\r\nnext_iwarp_state |= NES_CQP_QP_CONTEXT_VALID |\r\nNES_CQP_QP_ARP_VALID | NES_CQP_QP_ORD_VALID;\r\nissue_modify_qp = 1;\r\nnesqp->hw_tcp_state = NES_AEQE_TCP_STATE_ESTABLISHED;\r\nnesqp->hw_iwarp_state = NES_AEQE_IWARP_STATE_RTS;\r\nnesqp->hte_added = 1;\r\nbreak;\r\ncase IB_QPS_SQD:\r\nissue_modify_qp = 1;\r\nnes_debug(NES_DBG_MOD_QP, "QP%u: new state=closing. SQ head=%u, SQ tail=%u\n",\r\nnesqp->hwqp.qp_id, nesqp->hwqp.sq_head, nesqp->hwqp.sq_tail);\r\nif (nesqp->iwarp_state == (u32)NES_CQP_QP_IWARP_STATE_CLOSING) {\r\nspin_unlock_irqrestore(&nesqp->lock, qplockflags);\r\nreturn 0;\r\n} else {\r\nif (nesqp->iwarp_state > (u32)NES_CQP_QP_IWARP_STATE_CLOSING) {\r\nnes_debug(NES_DBG_MOD_QP, "QP%u: State change to closing"\r\n" ignored due to current iWARP state\n",\r\nnesqp->hwqp.qp_id);\r\nspin_unlock_irqrestore(&nesqp->lock, qplockflags);\r\nreturn -EINVAL;\r\n}\r\nif (nesqp->hw_iwarp_state != NES_AEQE_IWARP_STATE_RTS) {\r\nnes_debug(NES_DBG_MOD_QP, "QP%u: State change to closing"\r\n" already done based on hw state.\n",\r\nnesqp->hwqp.qp_id);\r\nissue_modify_qp = 0;\r\n}\r\nswitch (nesqp->hw_iwarp_state) {\r\ncase NES_AEQE_IWARP_STATE_CLOSING:\r\nnext_iwarp_state = NES_CQP_QP_IWARP_STATE_CLOSING;\r\nbreak;\r\ncase NES_AEQE_IWARP_STATE_TERMINATE:\r\nnext_iwarp_state = NES_CQP_QP_IWARP_STATE_TERMINATE;\r\nbreak;\r\ncase NES_AEQE_IWARP_STATE_ERROR:\r\nnext_iwarp_state = NES_CQP_QP_IWARP_STATE_ERROR;\r\nbreak;\r\ndefault:\r\nnext_iwarp_state = NES_CQP_QP_IWARP_STATE_CLOSING;\r\nnesqp->hw_iwarp_state = NES_AEQE_IWARP_STATE_CLOSING;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase IB_QPS_SQE:\r\nnes_debug(NES_DBG_MOD_QP, "QP%u: new state = terminate\n",\r\nnesqp->hwqp.qp_id);\r\nif (nesqp->iwarp_state>=(u32)NES_CQP_QP_IWARP_STATE_TERMINATE) {\r\nspin_unlock_irqrestore(&nesqp->lock, qplockflags);\r\nreturn -EINVAL;\r\n}\r\nnext_iwarp_state = NES_CQP_QP_IWARP_STATE_TERMINATE;\r\nnesqp->hw_iwarp_state = NES_AEQE_IWARP_STATE_TERMINATE;\r\nissue_modify_qp = 1;\r\nbreak;\r\ncase IB_QPS_ERR:\r\ncase IB_QPS_RESET:\r\nif (nesqp->iwarp_state == (u32)NES_CQP_QP_IWARP_STATE_ERROR) {\r\nspin_unlock_irqrestore(&nesqp->lock, qplockflags);\r\nreturn -EINVAL;\r\n}\r\nnes_debug(NES_DBG_MOD_QP, "QP%u: new state = error\n",\r\nnesqp->hwqp.qp_id);\r\nif (nesqp->term_flags)\r\ndel_timer(&nesqp->terminate_timer);\r\nnext_iwarp_state = NES_CQP_QP_IWARP_STATE_ERROR;\r\nif (nesqp->hte_added) {\r\nnes_debug(NES_DBG_MOD_QP, "set CQP_QP_DEL_HTE\n");\r\nnext_iwarp_state |= NES_CQP_QP_DEL_HTE;\r\nnesqp->hte_added = 0;\r\n}\r\nif ((nesqp->hw_tcp_state > NES_AEQE_TCP_STATE_CLOSED) &&\r\n(nesdev->iw_status) &&\r\n(nesqp->hw_tcp_state != NES_AEQE_TCP_STATE_TIME_WAIT)) {\r\nnext_iwarp_state |= NES_CQP_QP_RESET;\r\n} else {\r\nnes_debug(NES_DBG_MOD_QP, "QP%u NOT setting NES_CQP_QP_RESET since TCP state = %u\n",\r\nnesqp->hwqp.qp_id, nesqp->hw_tcp_state);\r\ndont_wait = 1;\r\n}\r\nissue_modify_qp = 1;\r\nnesqp->hw_iwarp_state = NES_AEQE_IWARP_STATE_ERROR;\r\nbreak;\r\ndefault:\r\nspin_unlock_irqrestore(&nesqp->lock, qplockflags);\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nnesqp->ibqp_state = attr->qp_state;\r\nnesqp->iwarp_state = next_iwarp_state & NES_CQP_QP_IWARP_STATE_MASK;\r\nnes_debug(NES_DBG_MOD_QP, "Change nesqp->iwarp_state=%08x\n",\r\nnesqp->iwarp_state);\r\n}\r\nif (attr_mask & IB_QP_ACCESS_FLAGS) {\r\nif (attr->qp_access_flags & IB_ACCESS_LOCAL_WRITE) {\r\nnesqp->nesqp_context->misc |= cpu_to_le32(NES_QPCONTEXT_MISC_RDMA_WRITE_EN |\r\nNES_QPCONTEXT_MISC_RDMA_READ_EN);\r\nissue_modify_qp = 1;\r\n}\r\nif (attr->qp_access_flags & IB_ACCESS_REMOTE_WRITE) {\r\nnesqp->nesqp_context->misc |= cpu_to_le32(NES_QPCONTEXT_MISC_RDMA_WRITE_EN);\r\nissue_modify_qp = 1;\r\n}\r\nif (attr->qp_access_flags & IB_ACCESS_REMOTE_READ) {\r\nnesqp->nesqp_context->misc |= cpu_to_le32(NES_QPCONTEXT_MISC_RDMA_READ_EN);\r\nissue_modify_qp = 1;\r\n}\r\nif (attr->qp_access_flags & IB_ACCESS_MW_BIND) {\r\nnesqp->nesqp_context->misc |= cpu_to_le32(NES_QPCONTEXT_MISC_WBIND_EN);\r\nissue_modify_qp = 1;\r\n}\r\nif (nesqp->user_mode) {\r\nnesqp->nesqp_context->misc |= cpu_to_le32(NES_QPCONTEXT_MISC_RDMA_WRITE_EN |\r\nNES_QPCONTEXT_MISC_RDMA_READ_EN);\r\nissue_modify_qp = 1;\r\n}\r\n}\r\noriginal_last_aeq = nesqp->last_aeq;\r\nspin_unlock_irqrestore(&nesqp->lock, qplockflags);\r\nnes_debug(NES_DBG_MOD_QP, "issue_modify_qp=%u\n", issue_modify_qp);\r\nret = 0;\r\nif (issue_modify_qp) {\r\nnes_debug(NES_DBG_MOD_QP, "call nes_hw_modify_qp\n");\r\nret = nes_hw_modify_qp(nesdev, nesqp, next_iwarp_state, 0, 1);\r\nif (ret)\r\nnes_debug(NES_DBG_MOD_QP, "nes_hw_modify_qp (next_iwarp_state = 0x%08X)"\r\n" failed for QP%u.\n",\r\nnext_iwarp_state, nesqp->hwqp.qp_id);\r\n}\r\nif ((issue_modify_qp) && (nesqp->ibqp_state > IB_QPS_RTS)) {\r\nnes_debug(NES_DBG_MOD_QP, "QP%u Issued ModifyQP refcount (%d),"\r\n" original_last_aeq = 0x%04X. last_aeq = 0x%04X.\n",\r\nnesqp->hwqp.qp_id, atomic_read(&nesqp->refcount),\r\noriginal_last_aeq, nesqp->last_aeq);\r\nif ((!ret) ||\r\n((original_last_aeq != NES_AEQE_AEID_RDMAP_ROE_BAD_LLP_CLOSE) &&\r\n(ret))) {\r\nif (dont_wait) {\r\nif (nesqp->cm_id && nesqp->hw_tcp_state != 0) {\r\nnes_debug(NES_DBG_MOD_QP, "QP%u Queuing fake disconnect for QP refcount (%d),"\r\n" original_last_aeq = 0x%04X. last_aeq = 0x%04X.\n",\r\nnesqp->hwqp.qp_id, atomic_read(&nesqp->refcount),\r\noriginal_last_aeq, nesqp->last_aeq);\r\nspin_lock_irqsave(&nesqp->lock, qplockflags);\r\nnesqp->hw_tcp_state = NES_AEQE_TCP_STATE_CLOSED;\r\nnesqp->last_aeq = NES_AEQE_AEID_RESET_SENT;\r\nspin_unlock_irqrestore(&nesqp->lock, qplockflags);\r\nnes_cm_disconn(nesqp);\r\n} else {\r\nnes_debug(NES_DBG_MOD_QP, "QP%u No fake disconnect, QP refcount=%d\n",\r\nnesqp->hwqp.qp_id, atomic_read(&nesqp->refcount));\r\n}\r\n} else {\r\nspin_lock_irqsave(&nesqp->lock, qplockflags);\r\nif (nesqp->cm_id) {\r\nif (atomic_inc_return(&nesqp->close_timer_started) == 1) {\r\nnesqp->cm_id->add_ref(nesqp->cm_id);\r\nnes_debug(NES_DBG_MOD_QP, "QP%u Not decrementing QP refcount (%d),"\r\n" need ae to finish up, original_last_aeq = 0x%04X."\r\n" last_aeq = 0x%04X, scheduling timer.\n",\r\nnesqp->hwqp.qp_id, atomic_read(&nesqp->refcount),\r\noriginal_last_aeq, nesqp->last_aeq);\r\nschedule_nes_timer(nesqp->cm_node, (struct sk_buff *) nesqp, NES_TIMER_TYPE_CLOSE, 1, 0);\r\n}\r\nspin_unlock_irqrestore(&nesqp->lock, qplockflags);\r\n} else {\r\nspin_unlock_irqrestore(&nesqp->lock, qplockflags);\r\nnes_debug(NES_DBG_MOD_QP, "QP%u Not decrementing QP refcount (%d),"\r\n" need ae to finish up, original_last_aeq = 0x%04X."\r\n" last_aeq = 0x%04X.\n",\r\nnesqp->hwqp.qp_id, atomic_read(&nesqp->refcount),\r\noriginal_last_aeq, nesqp->last_aeq);\r\n}\r\n}\r\n} else {\r\nnes_debug(NES_DBG_MOD_QP, "QP%u Decrementing QP refcount (%d), No ae to finish up,"\r\n" original_last_aeq = 0x%04X. last_aeq = 0x%04X.\n",\r\nnesqp->hwqp.qp_id, atomic_read(&nesqp->refcount),\r\noriginal_last_aeq, nesqp->last_aeq);\r\n}\r\n} else {\r\nnes_debug(NES_DBG_MOD_QP, "QP%u Decrementing QP refcount (%d), No ae to finish up,"\r\n" original_last_aeq = 0x%04X. last_aeq = 0x%04X.\n",\r\nnesqp->hwqp.qp_id, atomic_read(&nesqp->refcount),\r\noriginal_last_aeq, nesqp->last_aeq);\r\n}\r\nerr = 0;\r\nnes_debug(NES_DBG_MOD_QP, "QP%u Leaving, refcount=%d\n",\r\nnesqp->hwqp.qp_id, atomic_read(&nesqp->refcount));\r\nreturn err;\r\n}\r\nstatic int nes_multicast_attach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)\r\n{\r\nnes_debug(NES_DBG_INIT, "\n");\r\nreturn -ENOSYS;\r\n}\r\nstatic int nes_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)\r\n{\r\nnes_debug(NES_DBG_INIT, "\n");\r\nreturn -ENOSYS;\r\n}\r\nstatic int nes_process_mad(struct ib_device *ibdev, int mad_flags,\r\nu8 port_num, struct ib_wc *in_wc, struct ib_grh *in_grh,\r\nstruct ib_mad *in_mad, struct ib_mad *out_mad)\r\n{\r\nnes_debug(NES_DBG_INIT, "\n");\r\nreturn -ENOSYS;\r\n}\r\nstatic inline void\r\nfill_wqe_sg_send(struct nes_hw_qp_wqe *wqe, struct ib_send_wr *ib_wr, u32 uselkey)\r\n{\r\nint sge_index;\r\nint total_payload_length = 0;\r\nfor (sge_index = 0; sge_index < ib_wr->num_sge; sge_index++) {\r\nset_wqe_64bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_FRAG0_LOW_IDX+(sge_index*4),\r\nib_wr->sg_list[sge_index].addr);\r\nset_wqe_32bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_LENGTH0_IDX + (sge_index*4),\r\nib_wr->sg_list[sge_index].length);\r\nif (uselkey)\r\nset_wqe_32bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_STAG0_IDX + (sge_index*4),\r\n(ib_wr->sg_list[sge_index].lkey));\r\nelse\r\nset_wqe_32bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_STAG0_IDX + (sge_index*4), 0);\r\ntotal_payload_length += ib_wr->sg_list[sge_index].length;\r\n}\r\nnes_debug(NES_DBG_IW_TX, "UC UC UC, sending total_payload_length=%u \n",\r\ntotal_payload_length);\r\nset_wqe_32bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_TOTAL_PAYLOAD_IDX,\r\ntotal_payload_length);\r\n}\r\nstatic int nes_post_send(struct ib_qp *ibqp, struct ib_send_wr *ib_wr,\r\nstruct ib_send_wr **bad_wr)\r\n{\r\nu64 u64temp;\r\nunsigned long flags = 0;\r\nstruct nes_vnic *nesvnic = to_nesvnic(ibqp->device);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_qp *nesqp = to_nesqp(ibqp);\r\nstruct nes_hw_qp_wqe *wqe;\r\nint err = 0;\r\nu32 qsize = nesqp->hwqp.sq_size;\r\nu32 head;\r\nu32 wqe_misc = 0;\r\nu32 wqe_count = 0;\r\nu32 counter;\r\nif (nesqp->ibqp_state > IB_QPS_RTS) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nspin_lock_irqsave(&nesqp->lock, flags);\r\nhead = nesqp->hwqp.sq_head;\r\nwhile (ib_wr) {\r\nif (nesqp->term_flags) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (((head + (2 * qsize) - nesqp->hwqp.sq_tail) % qsize) == (qsize - 1)) {\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\nwqe = &nesqp->hwqp.sq_vbase[head];\r\nnes_fill_init_qp_wqe(wqe, nesqp, head);\r\nu64temp = (u64)(ib_wr->wr_id);\r\nset_wqe_64bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_COMP_SCRATCH_LOW_IDX,\r\nu64temp);\r\nswitch (ib_wr->opcode) {\r\ncase IB_WR_SEND:\r\ncase IB_WR_SEND_WITH_INV:\r\nif (IB_WR_SEND == ib_wr->opcode) {\r\nif (ib_wr->send_flags & IB_SEND_SOLICITED)\r\nwqe_misc = NES_IWARP_SQ_OP_SENDSE;\r\nelse\r\nwqe_misc = NES_IWARP_SQ_OP_SEND;\r\n} else {\r\nif (ib_wr->send_flags & IB_SEND_SOLICITED)\r\nwqe_misc = NES_IWARP_SQ_OP_SENDSEINV;\r\nelse\r\nwqe_misc = NES_IWARP_SQ_OP_SENDINV;\r\nset_wqe_32bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_INV_STAG_LOW_IDX,\r\nib_wr->ex.invalidate_rkey);\r\n}\r\nif (ib_wr->num_sge > nesdev->nesadapter->max_sge) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (ib_wr->send_flags & IB_SEND_FENCE)\r\nwqe_misc |= NES_IWARP_SQ_WQE_LOCAL_FENCE;\r\nif ((ib_wr->send_flags & IB_SEND_INLINE) &&\r\n((nes_drv_opt & NES_DRV_OPT_NO_INLINE_DATA) == 0) &&\r\n(ib_wr->sg_list[0].length <= 64)) {\r\nmemcpy(&wqe->wqe_words[NES_IWARP_SQ_WQE_IMM_DATA_START_IDX],\r\n(void *)(unsigned long)ib_wr->sg_list[0].addr, ib_wr->sg_list[0].length);\r\nset_wqe_32bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_TOTAL_PAYLOAD_IDX,\r\nib_wr->sg_list[0].length);\r\nwqe_misc |= NES_IWARP_SQ_WQE_IMM_DATA;\r\n} else {\r\nfill_wqe_sg_send(wqe, ib_wr, 1);\r\n}\r\nbreak;\r\ncase IB_WR_RDMA_WRITE:\r\nwqe_misc = NES_IWARP_SQ_OP_RDMAW;\r\nif (ib_wr->num_sge > nesdev->nesadapter->max_sge) {\r\nnes_debug(NES_DBG_IW_TX, "Exceeded max sge, ib_wr=%u, max=%u\n",\r\nib_wr->num_sge, nesdev->nesadapter->max_sge);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (ib_wr->send_flags & IB_SEND_FENCE)\r\nwqe_misc |= NES_IWARP_SQ_WQE_LOCAL_FENCE;\r\nset_wqe_32bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_RDMA_STAG_IDX,\r\nib_wr->wr.rdma.rkey);\r\nset_wqe_64bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_RDMA_TO_LOW_IDX,\r\nib_wr->wr.rdma.remote_addr);\r\nif ((ib_wr->send_flags & IB_SEND_INLINE) &&\r\n((nes_drv_opt & NES_DRV_OPT_NO_INLINE_DATA) == 0) &&\r\n(ib_wr->sg_list[0].length <= 64)) {\r\nmemcpy(&wqe->wqe_words[NES_IWARP_SQ_WQE_IMM_DATA_START_IDX],\r\n(void *)(unsigned long)ib_wr->sg_list[0].addr, ib_wr->sg_list[0].length);\r\nset_wqe_32bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_TOTAL_PAYLOAD_IDX,\r\nib_wr->sg_list[0].length);\r\nwqe_misc |= NES_IWARP_SQ_WQE_IMM_DATA;\r\n} else {\r\nfill_wqe_sg_send(wqe, ib_wr, 1);\r\n}\r\nwqe->wqe_words[NES_IWARP_SQ_WQE_RDMA_LENGTH_IDX] =\r\nwqe->wqe_words[NES_IWARP_SQ_WQE_TOTAL_PAYLOAD_IDX];\r\nbreak;\r\ncase IB_WR_RDMA_READ:\r\ncase IB_WR_RDMA_READ_WITH_INV:\r\nif (ib_wr->num_sge > 1) {\r\nnes_debug(NES_DBG_IW_TX, "Exceeded max sge, ib_wr=%u, max=1\n",\r\nib_wr->num_sge);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (ib_wr->opcode == IB_WR_RDMA_READ) {\r\nwqe_misc = NES_IWARP_SQ_OP_RDMAR;\r\n} else {\r\nwqe_misc = NES_IWARP_SQ_OP_RDMAR_LOCINV;\r\nset_wqe_32bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_INV_STAG_LOW_IDX,\r\nib_wr->ex.invalidate_rkey);\r\n}\r\nset_wqe_64bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_RDMA_TO_LOW_IDX,\r\nib_wr->wr.rdma.remote_addr);\r\nset_wqe_32bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_RDMA_STAG_IDX,\r\nib_wr->wr.rdma.rkey);\r\nset_wqe_32bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_RDMA_LENGTH_IDX,\r\nib_wr->sg_list->length);\r\nset_wqe_64bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_FRAG0_LOW_IDX,\r\nib_wr->sg_list->addr);\r\nset_wqe_32bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_STAG0_IDX,\r\nib_wr->sg_list->lkey);\r\nbreak;\r\ncase IB_WR_LOCAL_INV:\r\nwqe_misc = NES_IWARP_SQ_OP_LOCINV;\r\nset_wqe_32bit_value(wqe->wqe_words,\r\nNES_IWARP_SQ_LOCINV_WQE_INV_STAG_IDX,\r\nib_wr->ex.invalidate_rkey);\r\nbreak;\r\ncase IB_WR_FAST_REG_MR:\r\n{\r\nint i;\r\nint flags = ib_wr->wr.fast_reg.access_flags;\r\nstruct nes_ib_fast_reg_page_list *pnesfrpl =\r\ncontainer_of(ib_wr->wr.fast_reg.page_list,\r\nstruct nes_ib_fast_reg_page_list,\r\nibfrpl);\r\nu64 *src_page_list = pnesfrpl->ibfrpl.page_list;\r\nu64 *dst_page_list = pnesfrpl->nes_wqe_pbl.kva;\r\nif (ib_wr->wr.fast_reg.page_list_len >\r\n(NES_4K_PBL_CHUNK_SIZE / sizeof(u64))) {\r\nnes_debug(NES_DBG_IW_TX, "SQ_FMR: bad page_list_len\n");\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nwqe_misc = NES_IWARP_SQ_OP_FAST_REG;\r\nset_wqe_64bit_value(wqe->wqe_words,\r\nNES_IWARP_SQ_FMR_WQE_VA_FBO_LOW_IDX,\r\nib_wr->wr.fast_reg.iova_start);\r\nset_wqe_32bit_value(wqe->wqe_words,\r\nNES_IWARP_SQ_FMR_WQE_LENGTH_LOW_IDX,\r\nib_wr->wr.fast_reg.length);\r\nset_wqe_32bit_value(wqe->wqe_words,\r\nNES_IWARP_SQ_FMR_WQE_LENGTH_HIGH_IDX, 0);\r\nset_wqe_32bit_value(wqe->wqe_words,\r\nNES_IWARP_SQ_FMR_WQE_MR_STAG_IDX,\r\nib_wr->wr.fast_reg.rkey);\r\nif (ib_wr->wr.fast_reg.page_shift == 12) {\r\nwqe_misc |= NES_IWARP_SQ_FMR_WQE_PAGE_SIZE_4K;\r\n} else if (ib_wr->wr.fast_reg.page_shift == 21) {\r\nwqe_misc |= NES_IWARP_SQ_FMR_WQE_PAGE_SIZE_2M;\r\n} else {\r\nnes_debug(NES_DBG_IW_TX, "Invalid page shift,"\r\n" ib_wr=%u, max=1\n", ib_wr->num_sge);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nwqe_misc |= NES_IWARP_SQ_FMR_WQE_RIGHTS_ENABLE_LOCAL_READ;\r\nif (flags & IB_ACCESS_LOCAL_WRITE)\r\nwqe_misc |= NES_IWARP_SQ_FMR_WQE_RIGHTS_ENABLE_LOCAL_WRITE;\r\nif (flags & IB_ACCESS_REMOTE_WRITE)\r\nwqe_misc |= NES_IWARP_SQ_FMR_WQE_RIGHTS_ENABLE_REMOTE_WRITE;\r\nif (flags & IB_ACCESS_REMOTE_READ)\r\nwqe_misc |= NES_IWARP_SQ_FMR_WQE_RIGHTS_ENABLE_REMOTE_READ;\r\nif (flags & IB_ACCESS_MW_BIND)\r\nwqe_misc |= NES_IWARP_SQ_FMR_WQE_RIGHTS_ENABLE_WINDOW_BIND;\r\nif (ib_wr->wr.fast_reg.page_list_len >\r\npnesfrpl->ibfrpl.max_page_list_len) {\r\nnes_debug(NES_DBG_IW_TX, "Invalid page list length,"\r\n" ib_wr=%p, value=%u, max=%u\n",\r\nib_wr, ib_wr->wr.fast_reg.page_list_len,\r\npnesfrpl->ibfrpl.max_page_list_len);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nset_wqe_64bit_value(wqe->wqe_words,\r\nNES_IWARP_SQ_FMR_WQE_PBL_ADDR_LOW_IDX,\r\npnesfrpl->nes_wqe_pbl.paddr);\r\nset_wqe_32bit_value(wqe->wqe_words,\r\nNES_IWARP_SQ_FMR_WQE_PBL_LENGTH_IDX,\r\nib_wr->wr.fast_reg.page_list_len * 8);\r\nfor (i = 0; i < ib_wr->wr.fast_reg.page_list_len; i++)\r\ndst_page_list[i] = cpu_to_le64(src_page_list[i]);\r\nnes_debug(NES_DBG_IW_TX, "SQ_FMR: iova_start: %llx, "\r\n"length: %d, rkey: %0x, pgl_paddr: %llx, "\r\n"page_list_len: %u, wqe_misc: %x\n",\r\n(unsigned long long) ib_wr->wr.fast_reg.iova_start,\r\nib_wr->wr.fast_reg.length,\r\nib_wr->wr.fast_reg.rkey,\r\n(unsigned long long) pnesfrpl->nes_wqe_pbl.paddr,\r\nib_wr->wr.fast_reg.page_list_len,\r\nwqe_misc);\r\nbreak;\r\n}\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (err)\r\nbreak;\r\nif ((ib_wr->send_flags & IB_SEND_SIGNALED) || nesqp->sig_all)\r\nwqe_misc |= NES_IWARP_SQ_WQE_SIGNALED_COMPL;\r\nwqe->wqe_words[NES_IWARP_SQ_WQE_MISC_IDX] = cpu_to_le32(wqe_misc);\r\nib_wr = ib_wr->next;\r\nhead++;\r\nwqe_count++;\r\nif (head >= qsize)\r\nhead = 0;\r\n}\r\nnesqp->hwqp.sq_head = head;\r\nbarrier();\r\nwhile (wqe_count) {\r\ncounter = min(wqe_count, ((u32)255));\r\nwqe_count -= counter;\r\nnes_write32(nesdev->regs + NES_WQE_ALLOC,\r\n(counter << 24) | 0x00800000 | nesqp->hwqp.qp_id);\r\n}\r\nspin_unlock_irqrestore(&nesqp->lock, flags);\r\nout:\r\nif (err)\r\n*bad_wr = ib_wr;\r\nreturn err;\r\n}\r\nstatic int nes_post_recv(struct ib_qp *ibqp, struct ib_recv_wr *ib_wr,\r\nstruct ib_recv_wr **bad_wr)\r\n{\r\nu64 u64temp;\r\nunsigned long flags = 0;\r\nstruct nes_vnic *nesvnic = to_nesvnic(ibqp->device);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_qp *nesqp = to_nesqp(ibqp);\r\nstruct nes_hw_qp_wqe *wqe;\r\nint err = 0;\r\nint sge_index;\r\nu32 qsize = nesqp->hwqp.rq_size;\r\nu32 head;\r\nu32 wqe_count = 0;\r\nu32 counter;\r\nu32 total_payload_length;\r\nif (nesqp->ibqp_state > IB_QPS_RTS) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nspin_lock_irqsave(&nesqp->lock, flags);\r\nhead = nesqp->hwqp.rq_head;\r\nwhile (ib_wr) {\r\nif (nesqp->term_flags) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (ib_wr->num_sge > nesdev->nesadapter->max_sge) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (((head + (2 * qsize) - nesqp->hwqp.rq_tail) % qsize) == (qsize - 1)) {\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\nnes_debug(NES_DBG_IW_RX, "ibwr sge count = %u.\n", ib_wr->num_sge);\r\nwqe = &nesqp->hwqp.rq_vbase[head];\r\nnes_fill_init_qp_wqe(wqe, nesqp, head);\r\nu64temp = (u64)(ib_wr->wr_id);\r\nset_wqe_64bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_COMP_SCRATCH_LOW_IDX,\r\nu64temp);\r\ntotal_payload_length = 0;\r\nfor (sge_index=0; sge_index < ib_wr->num_sge; sge_index++) {\r\nset_wqe_64bit_value(wqe->wqe_words, NES_IWARP_RQ_WQE_FRAG0_LOW_IDX+(sge_index*4),\r\nib_wr->sg_list[sge_index].addr);\r\nset_wqe_32bit_value(wqe->wqe_words, NES_IWARP_RQ_WQE_LENGTH0_IDX+(sge_index*4),\r\nib_wr->sg_list[sge_index].length);\r\nset_wqe_32bit_value(wqe->wqe_words,NES_IWARP_RQ_WQE_STAG0_IDX+(sge_index*4),\r\nib_wr->sg_list[sge_index].lkey);\r\ntotal_payload_length += ib_wr->sg_list[sge_index].length;\r\n}\r\nset_wqe_32bit_value(wqe->wqe_words, NES_IWARP_RQ_WQE_TOTAL_PAYLOAD_IDX,\r\ntotal_payload_length);\r\nib_wr = ib_wr->next;\r\nhead++;\r\nwqe_count++;\r\nif (head >= qsize)\r\nhead = 0;\r\n}\r\nnesqp->hwqp.rq_head = head;\r\nbarrier();\r\nwhile (wqe_count) {\r\ncounter = min(wqe_count, ((u32)255));\r\nwqe_count -= counter;\r\nnes_write32(nesdev->regs+NES_WQE_ALLOC, (counter<<24) | nesqp->hwqp.qp_id);\r\n}\r\nspin_unlock_irqrestore(&nesqp->lock, flags);\r\nout:\r\nif (err)\r\n*bad_wr = ib_wr;\r\nreturn err;\r\n}\r\nstatic int nes_poll_cq(struct ib_cq *ibcq, int num_entries, struct ib_wc *entry)\r\n{\r\nu64 u64temp;\r\nu64 wrid;\r\nunsigned long flags = 0;\r\nstruct nes_vnic *nesvnic = to_nesvnic(ibcq->device);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_cq *nescq = to_nescq(ibcq);\r\nstruct nes_qp *nesqp;\r\nstruct nes_hw_cqe cqe;\r\nu32 head;\r\nu32 wq_tail = 0;\r\nu32 cq_size;\r\nu32 cqe_count = 0;\r\nu32 wqe_index;\r\nu32 u32temp;\r\nu32 move_cq_head = 1;\r\nu32 err_code;\r\nnes_debug(NES_DBG_CQ, "\n");\r\nspin_lock_irqsave(&nescq->lock, flags);\r\nhead = nescq->hw_cq.cq_head;\r\ncq_size = nescq->hw_cq.cq_size;\r\nwhile (cqe_count < num_entries) {\r\nif ((le32_to_cpu(nescq->hw_cq.cq_vbase[head].cqe_words[NES_CQE_OPCODE_IDX]) &\r\nNES_CQE_VALID) == 0)\r\nbreak;\r\nrmb();\r\ncqe = nescq->hw_cq.cq_vbase[head];\r\nu32temp = le32_to_cpu(cqe.cqe_words[NES_CQE_COMP_COMP_CTX_LOW_IDX]);\r\nwqe_index = u32temp & (nesdev->nesadapter->max_qp_wr - 1);\r\nu32temp &= ~(NES_SW_CONTEXT_ALIGN-1);\r\nu64temp = (((u64)(le32_to_cpu(cqe.cqe_words[NES_CQE_COMP_COMP_CTX_HIGH_IDX])))<<32) |\r\n((u64)u32temp);\r\nif (u64temp) {\r\nnesqp = (struct nes_qp *)(unsigned long)u64temp;\r\nmemset(entry, 0, sizeof *entry);\r\nif (cqe.cqe_words[NES_CQE_ERROR_CODE_IDX] == 0) {\r\nentry->status = IB_WC_SUCCESS;\r\n} else {\r\nerr_code = le32_to_cpu(cqe.cqe_words[NES_CQE_ERROR_CODE_IDX]);\r\nif (NES_IWARP_CQE_MAJOR_DRV == (err_code >> 16)) {\r\nentry->status = err_code & 0x0000ffff;\r\nnescq->hw_cq.cq_vbase[head].cqe_words[NES_CQE_ERROR_CODE_IDX] =\r\ncpu_to_le32((NES_IWARP_CQE_MAJOR_FLUSH << 16) |\r\nNES_IWARP_CQE_MINOR_FLUSH);\r\n} else\r\nentry->status = IB_WC_WR_FLUSH_ERR;\r\n}\r\nentry->qp = &nesqp->ibqp;\r\nentry->src_qp = nesqp->hwqp.qp_id;\r\nif (le32_to_cpu(cqe.cqe_words[NES_CQE_OPCODE_IDX]) & NES_CQE_SQ) {\r\nif (nesqp->skip_lsmm) {\r\nnesqp->skip_lsmm = 0;\r\nnesqp->hwqp.sq_tail++;\r\n}\r\nwrid = (((u64)(cpu_to_le32((u32)nesqp->hwqp.sq_vbase[wqe_index].\r\nwqe_words[NES_IWARP_SQ_WQE_COMP_SCRATCH_HIGH_IDX]))) << 32) |\r\n((u64)(cpu_to_le32((u32)nesqp->hwqp.sq_vbase[wqe_index].\r\nwqe_words[NES_IWARP_SQ_WQE_COMP_SCRATCH_LOW_IDX])));\r\nentry->byte_len = le32_to_cpu(nesqp->hwqp.sq_vbase[wqe_index].\r\nwqe_words[NES_IWARP_SQ_WQE_TOTAL_PAYLOAD_IDX]);\r\nswitch (le32_to_cpu(nesqp->hwqp.sq_vbase[wqe_index].\r\nwqe_words[NES_IWARP_SQ_WQE_MISC_IDX]) & 0x3f) {\r\ncase NES_IWARP_SQ_OP_RDMAW:\r\nnes_debug(NES_DBG_CQ, "Operation = RDMA WRITE.\n");\r\nentry->opcode = IB_WC_RDMA_WRITE;\r\nbreak;\r\ncase NES_IWARP_SQ_OP_RDMAR:\r\nnes_debug(NES_DBG_CQ, "Operation = RDMA READ.\n");\r\nentry->opcode = IB_WC_RDMA_READ;\r\nentry->byte_len = le32_to_cpu(nesqp->hwqp.sq_vbase[wqe_index].\r\nwqe_words[NES_IWARP_SQ_WQE_RDMA_LENGTH_IDX]);\r\nbreak;\r\ncase NES_IWARP_SQ_OP_SENDINV:\r\ncase NES_IWARP_SQ_OP_SENDSEINV:\r\ncase NES_IWARP_SQ_OP_SEND:\r\ncase NES_IWARP_SQ_OP_SENDSE:\r\nnes_debug(NES_DBG_CQ, "Operation = Send.\n");\r\nentry->opcode = IB_WC_SEND;\r\nbreak;\r\ncase NES_IWARP_SQ_OP_LOCINV:\r\nentry->opcode = IB_WC_LOCAL_INV;\r\nbreak;\r\ncase NES_IWARP_SQ_OP_FAST_REG:\r\nentry->opcode = IB_WC_FAST_REG_MR;\r\nbreak;\r\n}\r\nnesqp->hwqp.sq_tail = (wqe_index+1)&(nesqp->hwqp.sq_size - 1);\r\nif ((entry->status != IB_WC_SUCCESS) && (nesqp->hwqp.sq_tail != nesqp->hwqp.sq_head)) {\r\nmove_cq_head = 0;\r\nwq_tail = nesqp->hwqp.sq_tail;\r\n}\r\n} else {\r\nentry->byte_len = le32_to_cpu(cqe.cqe_words[NES_CQE_PAYLOAD_LENGTH_IDX]);\r\nwrid = ((u64)(le32_to_cpu(nesqp->hwqp.rq_vbase[wqe_index].wqe_words[NES_IWARP_RQ_WQE_COMP_SCRATCH_LOW_IDX]))) |\r\n((u64)(le32_to_cpu(nesqp->hwqp.rq_vbase[wqe_index].wqe_words[NES_IWARP_RQ_WQE_COMP_SCRATCH_HIGH_IDX]))<<32);\r\nentry->opcode = IB_WC_RECV;\r\nnesqp->hwqp.rq_tail = (wqe_index+1)&(nesqp->hwqp.rq_size - 1);\r\nif ((entry->status != IB_WC_SUCCESS) && (nesqp->hwqp.rq_tail != nesqp->hwqp.rq_head)) {\r\nmove_cq_head = 0;\r\nwq_tail = nesqp->hwqp.rq_tail;\r\n}\r\n}\r\nentry->wr_id = wrid;\r\nentry++;\r\ncqe_count++;\r\n}\r\nif (move_cq_head) {\r\nnescq->hw_cq.cq_vbase[head].cqe_words[NES_CQE_OPCODE_IDX] = 0;\r\nif (++head >= cq_size)\r\nhead = 0;\r\nnescq->polled_completions++;\r\nif ((nescq->polled_completions > (cq_size / 2)) ||\r\n(nescq->polled_completions == 255)) {\r\nnes_debug(NES_DBG_CQ, "CQ%u Issuing CQE Allocate since more than half of cqes"\r\n" are pending %u of %u.\n",\r\nnescq->hw_cq.cq_number, nescq->polled_completions, cq_size);\r\nnes_write32(nesdev->regs+NES_CQE_ALLOC,\r\nnescq->hw_cq.cq_number | (nescq->polled_completions << 16));\r\nnescq->polled_completions = 0;\r\n}\r\n} else {\r\nwqe_index = le32_to_cpu(cqe.cqe_words[NES_CQE_COMP_COMP_CTX_LOW_IDX]);\r\nwqe_index = (wqe_index & (~(nesdev->nesadapter->max_qp_wr - 1))) | wq_tail;\r\nnescq->hw_cq.cq_vbase[head].cqe_words[NES_CQE_COMP_COMP_CTX_LOW_IDX] =\r\ncpu_to_le32(wqe_index);\r\nmove_cq_head = 1;\r\n}\r\n}\r\nif (nescq->polled_completions) {\r\nnes_write32(nesdev->regs+NES_CQE_ALLOC,\r\nnescq->hw_cq.cq_number | (nescq->polled_completions << 16));\r\nnescq->polled_completions = 0;\r\n}\r\nnescq->hw_cq.cq_head = head;\r\nnes_debug(NES_DBG_CQ, "Reporting %u completions for CQ%u.\n",\r\ncqe_count, nescq->hw_cq.cq_number);\r\nspin_unlock_irqrestore(&nescq->lock, flags);\r\nreturn cqe_count;\r\n}\r\nstatic int nes_req_notify_cq(struct ib_cq *ibcq, enum ib_cq_notify_flags notify_flags)\r\n{\r\nstruct nes_vnic *nesvnic = to_nesvnic(ibcq->device);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_cq *nescq = to_nescq(ibcq);\r\nu32 cq_arm;\r\nnes_debug(NES_DBG_CQ, "Requesting notification for CQ%u.\n",\r\nnescq->hw_cq.cq_number);\r\ncq_arm = nescq->hw_cq.cq_number;\r\nif ((notify_flags & IB_CQ_SOLICITED_MASK) == IB_CQ_NEXT_COMP)\r\ncq_arm |= NES_CQE_ALLOC_NOTIFY_NEXT;\r\nelse if ((notify_flags & IB_CQ_SOLICITED_MASK) == IB_CQ_SOLICITED)\r\ncq_arm |= NES_CQE_ALLOC_NOTIFY_SE;\r\nelse\r\nreturn -EINVAL;\r\nnes_write32(nesdev->regs+NES_CQE_ALLOC, cq_arm);\r\nnes_read32(nesdev->regs+NES_CQE_ALLOC);\r\nreturn 0;\r\n}\r\nstruct nes_ib_device *nes_init_ofa_device(struct net_device *netdev)\r\n{\r\nstruct nes_ib_device *nesibdev;\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nnesibdev = (struct nes_ib_device *)ib_alloc_device(sizeof(struct nes_ib_device));\r\nif (nesibdev == NULL) {\r\nreturn NULL;\r\n}\r\nstrlcpy(nesibdev->ibdev.name, "nes%d", IB_DEVICE_NAME_MAX);\r\nnesibdev->ibdev.owner = THIS_MODULE;\r\nnesibdev->ibdev.node_type = RDMA_NODE_RNIC;\r\nmemset(&nesibdev->ibdev.node_guid, 0, sizeof(nesibdev->ibdev.node_guid));\r\nmemcpy(&nesibdev->ibdev.node_guid, netdev->dev_addr, 6);\r\nnesibdev->ibdev.uverbs_cmd_mask =\r\n(1ull << IB_USER_VERBS_CMD_GET_CONTEXT) |\r\n(1ull << IB_USER_VERBS_CMD_QUERY_DEVICE) |\r\n(1ull << IB_USER_VERBS_CMD_QUERY_PORT) |\r\n(1ull << IB_USER_VERBS_CMD_ALLOC_PD) |\r\n(1ull << IB_USER_VERBS_CMD_DEALLOC_PD) |\r\n(1ull << IB_USER_VERBS_CMD_REG_MR) |\r\n(1ull << IB_USER_VERBS_CMD_DEREG_MR) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_DESTROY_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_AH) |\r\n(1ull << IB_USER_VERBS_CMD_DESTROY_AH) |\r\n(1ull << IB_USER_VERBS_CMD_REQ_NOTIFY_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_QP) |\r\n(1ull << IB_USER_VERBS_CMD_MODIFY_QP) |\r\n(1ull << IB_USER_VERBS_CMD_POLL_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_DESTROY_QP) |\r\n(1ull << IB_USER_VERBS_CMD_ALLOC_MW) |\r\n(1ull << IB_USER_VERBS_CMD_BIND_MW) |\r\n(1ull << IB_USER_VERBS_CMD_DEALLOC_MW) |\r\n(1ull << IB_USER_VERBS_CMD_POST_RECV) |\r\n(1ull << IB_USER_VERBS_CMD_POST_SEND);\r\nnesibdev->ibdev.phys_port_cnt = 1;\r\nnesibdev->ibdev.num_comp_vectors = 1;\r\nnesibdev->ibdev.dma_device = &nesdev->pcidev->dev;\r\nnesibdev->ibdev.dev.parent = &nesdev->pcidev->dev;\r\nnesibdev->ibdev.query_device = nes_query_device;\r\nnesibdev->ibdev.query_port = nes_query_port;\r\nnesibdev->ibdev.query_pkey = nes_query_pkey;\r\nnesibdev->ibdev.query_gid = nes_query_gid;\r\nnesibdev->ibdev.alloc_ucontext = nes_alloc_ucontext;\r\nnesibdev->ibdev.dealloc_ucontext = nes_dealloc_ucontext;\r\nnesibdev->ibdev.mmap = nes_mmap;\r\nnesibdev->ibdev.alloc_pd = nes_alloc_pd;\r\nnesibdev->ibdev.dealloc_pd = nes_dealloc_pd;\r\nnesibdev->ibdev.create_ah = nes_create_ah;\r\nnesibdev->ibdev.destroy_ah = nes_destroy_ah;\r\nnesibdev->ibdev.create_qp = nes_create_qp;\r\nnesibdev->ibdev.modify_qp = nes_modify_qp;\r\nnesibdev->ibdev.query_qp = nes_query_qp;\r\nnesibdev->ibdev.destroy_qp = nes_destroy_qp;\r\nnesibdev->ibdev.create_cq = nes_create_cq;\r\nnesibdev->ibdev.destroy_cq = nes_destroy_cq;\r\nnesibdev->ibdev.poll_cq = nes_poll_cq;\r\nnesibdev->ibdev.get_dma_mr = nes_get_dma_mr;\r\nnesibdev->ibdev.reg_phys_mr = nes_reg_phys_mr;\r\nnesibdev->ibdev.reg_user_mr = nes_reg_user_mr;\r\nnesibdev->ibdev.dereg_mr = nes_dereg_mr;\r\nnesibdev->ibdev.alloc_mw = nes_alloc_mw;\r\nnesibdev->ibdev.dealloc_mw = nes_dealloc_mw;\r\nnesibdev->ibdev.bind_mw = nes_bind_mw;\r\nnesibdev->ibdev.alloc_fast_reg_mr = nes_alloc_fast_reg_mr;\r\nnesibdev->ibdev.alloc_fast_reg_page_list = nes_alloc_fast_reg_page_list;\r\nnesibdev->ibdev.free_fast_reg_page_list = nes_free_fast_reg_page_list;\r\nnesibdev->ibdev.attach_mcast = nes_multicast_attach;\r\nnesibdev->ibdev.detach_mcast = nes_multicast_detach;\r\nnesibdev->ibdev.process_mad = nes_process_mad;\r\nnesibdev->ibdev.req_notify_cq = nes_req_notify_cq;\r\nnesibdev->ibdev.post_send = nes_post_send;\r\nnesibdev->ibdev.post_recv = nes_post_recv;\r\nnesibdev->ibdev.iwcm = kzalloc(sizeof(*nesibdev->ibdev.iwcm), GFP_KERNEL);\r\nif (nesibdev->ibdev.iwcm == NULL) {\r\nib_dealloc_device(&nesibdev->ibdev);\r\nreturn NULL;\r\n}\r\nnesibdev->ibdev.iwcm->add_ref = nes_add_ref;\r\nnesibdev->ibdev.iwcm->rem_ref = nes_rem_ref;\r\nnesibdev->ibdev.iwcm->get_qp = nes_get_qp;\r\nnesibdev->ibdev.iwcm->connect = nes_connect;\r\nnesibdev->ibdev.iwcm->accept = nes_accept;\r\nnesibdev->ibdev.iwcm->reject = nes_reject;\r\nnesibdev->ibdev.iwcm->create_listen = nes_create_listen;\r\nnesibdev->ibdev.iwcm->destroy_listen = nes_destroy_listen;\r\nreturn nesibdev;\r\n}\r\nstatic void nes_handle_delayed_event(unsigned long data)\r\n{\r\nstruct nes_vnic *nesvnic = (void *) data;\r\nif (nesvnic->delayed_event != nesvnic->last_dispatched_event) {\r\nstruct ib_event event;\r\nevent.device = &nesvnic->nesibdev->ibdev;\r\nif (!event.device)\r\ngoto stop_timer;\r\nevent.event = nesvnic->delayed_event;\r\nevent.element.port_num = nesvnic->logical_port + 1;\r\nib_dispatch_event(&event);\r\n}\r\nstop_timer:\r\nnesvnic->event_timer.function = NULL;\r\n}\r\nvoid nes_port_ibevent(struct nes_vnic *nesvnic)\r\n{\r\nstruct nes_ib_device *nesibdev = nesvnic->nesibdev;\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct ib_event event;\r\nevent.device = &nesibdev->ibdev;\r\nevent.element.port_num = nesvnic->logical_port + 1;\r\nevent.event = nesdev->iw_status ? IB_EVENT_PORT_ACTIVE : IB_EVENT_PORT_ERR;\r\nif (!nesvnic->event_timer.function) {\r\nib_dispatch_event(&event);\r\nnesvnic->last_dispatched_event = event.event;\r\nnesvnic->event_timer.function = nes_handle_delayed_event;\r\nnesvnic->event_timer.data = (unsigned long) nesvnic;\r\nnesvnic->event_timer.expires = jiffies + NES_EVENT_DELAY;\r\nadd_timer(&nesvnic->event_timer);\r\n} else {\r\nmod_timer(&nesvnic->event_timer, jiffies + NES_EVENT_DELAY);\r\n}\r\nnesvnic->delayed_event = event.event;\r\n}\r\nvoid nes_destroy_ofa_device(struct nes_ib_device *nesibdev)\r\n{\r\nif (nesibdev == NULL)\r\nreturn;\r\nnes_unregister_ofa_device(nesibdev);\r\nkfree(nesibdev->ibdev.iwcm);\r\nib_dealloc_device(&nesibdev->ibdev);\r\n}\r\nint nes_register_ofa_device(struct nes_ib_device *nesibdev)\r\n{\r\nstruct nes_vnic *nesvnic = nesibdev->nesvnic;\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nint i, ret;\r\nret = ib_register_device(&nesvnic->nesibdev->ibdev, NULL);\r\nif (ret) {\r\nreturn ret;\r\n}\r\nnesibdev->max_cq = (nesadapter->max_cq-NES_FIRST_QPN) / nesadapter->port_count;\r\nnesibdev->max_mr = nesadapter->max_mr / nesadapter->port_count;\r\nnesibdev->max_qp = (nesadapter->max_qp-NES_FIRST_QPN) / nesadapter->port_count;\r\nnesibdev->max_pd = nesadapter->max_pd / nesadapter->port_count;\r\nfor (i = 0; i < ARRAY_SIZE(nes_dev_attributes); ++i) {\r\nret = device_create_file(&nesibdev->ibdev.dev, nes_dev_attributes[i]);\r\nif (ret) {\r\nwhile (i > 0) {\r\ni--;\r\ndevice_remove_file(&nesibdev->ibdev.dev,\r\nnes_dev_attributes[i]);\r\n}\r\nib_unregister_device(&nesibdev->ibdev);\r\nreturn ret;\r\n}\r\n}\r\nnesvnic->of_device_registered = 1;\r\nreturn 0;\r\n}\r\nstatic void nes_unregister_ofa_device(struct nes_ib_device *nesibdev)\r\n{\r\nstruct nes_vnic *nesvnic = nesibdev->nesvnic;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(nes_dev_attributes); ++i) {\r\ndevice_remove_file(&nesibdev->ibdev.dev, nes_dev_attributes[i]);\r\n}\r\nif (nesvnic->of_device_registered) {\r\nib_unregister_device(&nesibdev->ibdev);\r\n}\r\nnesvnic->of_device_registered = 0;\r\n}
