void aty_st_lcd(int index, u32 val, const struct atyfb_par *par)\r\n{\r\nif (M64_HAS(LT_LCD_REGS)) {\r\naty_st_le32(lt_lcd_regs[index], val, par);\r\n} else {\r\nunsigned long temp;\r\ntemp = aty_ld_le32(LCD_INDEX, par);\r\naty_st_le32(LCD_INDEX, (temp & ~LCD_INDEX_MASK) | index, par);\r\naty_st_le32(LCD_DATA, val, par);\r\n}\r\n}\r\nu32 aty_ld_lcd(int index, const struct atyfb_par *par)\r\n{\r\nif (M64_HAS(LT_LCD_REGS)) {\r\nreturn aty_ld_le32(lt_lcd_regs[index], par);\r\n} else {\r\nunsigned long temp;\r\ntemp = aty_ld_le32(LCD_INDEX, par);\r\naty_st_le32(LCD_INDEX, (temp & ~LCD_INDEX_MASK) | index, par);\r\nreturn aty_ld_le32(LCD_DATA, par);\r\n}\r\n}\r\nstatic void ATIReduceRatio(int *Numerator, int *Denominator)\r\n{\r\nint Multiplier, Divider, Remainder;\r\nMultiplier = *Numerator;\r\nDivider = *Denominator;\r\nwhile ((Remainder = Multiplier % Divider)) {\r\nMultiplier = Divider;\r\nDivider = Remainder;\r\n}\r\n*Numerator /= Divider;\r\n*Denominator /= Divider;\r\n}\r\nstatic int correct_chipset(struct atyfb_par *par)\r\n{\r\nu8 rev;\r\nu16 type;\r\nu32 chip_id;\r\nconst char *name;\r\nint i;\r\nfor (i = (int)ARRAY_SIZE(aty_chips) - 1; i >= 0; i--)\r\nif (par->pci_id == aty_chips[i].pci_id)\r\nbreak;\r\nif (i < 0)\r\nreturn -ENODEV;\r\nname = aty_chips[i].name;\r\npar->pll_limits.pll_max = aty_chips[i].pll;\r\npar->pll_limits.mclk = aty_chips[i].mclk;\r\npar->pll_limits.xclk = aty_chips[i].xclk;\r\npar->pll_limits.ecp_max = aty_chips[i].ecp_max;\r\npar->features = aty_chips[i].features;\r\nchip_id = aty_ld_le32(CNFG_CHIP_ID, par);\r\ntype = chip_id & CFG_CHIP_TYPE;\r\nrev = (chip_id & CFG_CHIP_REV) >> 24;\r\nswitch (par->pci_id) {\r\n#ifdef CONFIG_FB_ATY_GX\r\ncase PCI_CHIP_MACH64GX:\r\nif (type != 0x00d7)\r\nreturn -ENODEV;\r\nbreak;\r\ncase PCI_CHIP_MACH64CX:\r\nif (type != 0x0057)\r\nreturn -ENODEV;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_FB_ATY_CT\r\ncase PCI_CHIP_MACH64VT:\r\nswitch (rev & 0x07) {\r\ncase 0x00:\r\nswitch (rev & 0xc0) {\r\ncase 0x00:\r\nname = "ATI264VT (A3) (Mach64 VT)";\r\npar->pll_limits.pll_max = 170;\r\npar->pll_limits.mclk = 67;\r\npar->pll_limits.xclk = 67;\r\npar->pll_limits.ecp_max = 80;\r\npar->features = ATI_CHIP_264VT;\r\nbreak;\r\ncase 0x40:\r\nname = "ATI264VT2 (A4) (Mach64 VT)";\r\npar->pll_limits.pll_max = 200;\r\npar->pll_limits.mclk = 67;\r\npar->pll_limits.xclk = 67;\r\npar->pll_limits.ecp_max = 80;\r\npar->features = ATI_CHIP_264VT | M64F_MAGIC_POSTDIV;\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x01:\r\nname = "ATI264VT3 (B1) (Mach64 VT)";\r\npar->pll_limits.pll_max = 200;\r\npar->pll_limits.mclk = 67;\r\npar->pll_limits.xclk = 67;\r\npar->pll_limits.ecp_max = 80;\r\npar->features = ATI_CHIP_264VTB;\r\nbreak;\r\ncase 0x02:\r\nname = "ATI264VT3 (B2) (Mach64 VT)";\r\npar->pll_limits.pll_max = 200;\r\npar->pll_limits.mclk = 67;\r\npar->pll_limits.xclk = 67;\r\npar->pll_limits.ecp_max = 80;\r\npar->features = ATI_CHIP_264VT3;\r\nbreak;\r\n}\r\nbreak;\r\ncase PCI_CHIP_MACH64GT:\r\nswitch (rev & 0x07) {\r\ncase 0x01:\r\nname = "3D RAGE II (Mach64 GT)";\r\npar->pll_limits.pll_max = 170;\r\npar->pll_limits.mclk = 67;\r\npar->pll_limits.xclk = 67;\r\npar->pll_limits.ecp_max = 80;\r\npar->features = ATI_CHIP_264GTB;\r\nbreak;\r\ncase 0x02:\r\nname = "3D RAGE II+ (Mach64 GT)";\r\npar->pll_limits.pll_max = 200;\r\npar->pll_limits.mclk = 67;\r\npar->pll_limits.xclk = 67;\r\npar->pll_limits.ecp_max = 100;\r\npar->features = ATI_CHIP_264GTB;\r\nbreak;\r\n}\r\nbreak;\r\n#endif\r\n}\r\nPRINTKI("%s [0x%04x rev 0x%02x]\n", name, type, rev);\r\nreturn 0;\r\n}\r\nstatic u32 atyfb_get_pixclock(struct fb_var_screeninfo *var,\r\nstruct atyfb_par *par)\r\n{\r\nu32 pixclock = var->pixclock;\r\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\r\nu32 lcd_on_off;\r\npar->pll.ct.xres = 0;\r\nif (par->lcd_table != 0) {\r\nlcd_on_off = aty_ld_lcd(LCD_GEN_CNTL, par);\r\nif (lcd_on_off & LCD_ON) {\r\npar->pll.ct.xres = var->xres;\r\npixclock = par->lcd_pixclock;\r\n}\r\n}\r\n#endif\r\nreturn pixclock;\r\n}\r\nstatic int read_aty_sense(const struct atyfb_par *par)\r\n{\r\nint sense, i;\r\naty_st_le32(GP_IO, 0x31003100, par);\r\n__delay(200);\r\naty_st_le32(GP_IO, 0, par);\r\n__delay(2000);\r\ni = aty_ld_le32(GP_IO, par);\r\nsense = ((i & 0x3000) >> 3) | (i & 0x100);\r\naty_st_le32(GP_IO, 0x20000000, par);\r\n__delay(2000);\r\ni = aty_ld_le32(GP_IO, par);\r\nsense |= ((i & 0x1000) >> 7) | ((i & 0x100) >> 4);\r\naty_st_le32(GP_IO, 0x20002000, par);\r\n__delay(200);\r\naty_st_le32(GP_IO, 0x10000000, par);\r\n__delay(2000);\r\ni = aty_ld_le32(GP_IO, par);\r\nsense |= ((i & 0x2000) >> 10) | ((i & 0x100) >> 6);\r\naty_st_le32(GP_IO, 0x10001000, par);\r\n__delay(200);\r\naty_st_le32(GP_IO, 0x01000000, par);\r\n__delay(2000);\r\nsense |= (aty_ld_le32(GP_IO, par) & 0x3000) >> 12;\r\naty_st_le32(GP_IO, 0, par);\r\nreturn sense;\r\n}\r\nstatic void aty_get_crtc(const struct atyfb_par *par, struct crtc *crtc)\r\n{\r\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\r\nif (par->lcd_table != 0) {\r\nif (!M64_HAS(LT_LCD_REGS)) {\r\ncrtc->lcd_index = aty_ld_le32(LCD_INDEX, par);\r\naty_st_le32(LCD_INDEX, crtc->lcd_index, par);\r\n}\r\ncrtc->lcd_config_panel = aty_ld_lcd(CNFG_PANEL, par);\r\ncrtc->lcd_gen_cntl = aty_ld_lcd(LCD_GEN_CNTL, par);\r\naty_st_lcd(LCD_GEN_CNTL, crtc->lcd_gen_cntl &\r\n~(CRTC_RW_SELECT | SHADOW_EN | SHADOW_RW_EN), par);\r\ncrtc->horz_stretching = aty_ld_lcd(HORZ_STRETCHING, par);\r\ncrtc->vert_stretching = aty_ld_lcd(VERT_STRETCHING, par);\r\nif (!M64_HAS(LT_LCD_REGS))\r\ncrtc->ext_vert_stretch = aty_ld_lcd(EXT_VERT_STRETCH, par);\r\n}\r\n#endif\r\ncrtc->h_tot_disp = aty_ld_le32(CRTC_H_TOTAL_DISP, par);\r\ncrtc->h_sync_strt_wid = aty_ld_le32(CRTC_H_SYNC_STRT_WID, par);\r\ncrtc->v_tot_disp = aty_ld_le32(CRTC_V_TOTAL_DISP, par);\r\ncrtc->v_sync_strt_wid = aty_ld_le32(CRTC_V_SYNC_STRT_WID, par);\r\ncrtc->vline_crnt_vline = aty_ld_le32(CRTC_VLINE_CRNT_VLINE, par);\r\ncrtc->off_pitch = aty_ld_le32(CRTC_OFF_PITCH, par);\r\ncrtc->gen_cntl = aty_ld_le32(CRTC_GEN_CNTL, par);\r\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\r\nif (par->lcd_table != 0) {\r\naty_st_lcd(LCD_GEN_CNTL, (crtc->lcd_gen_cntl & ~CRTC_RW_SELECT) |\r\nSHADOW_EN | SHADOW_RW_EN, par);\r\ncrtc->shadow_h_tot_disp = aty_ld_le32(CRTC_H_TOTAL_DISP, par);\r\ncrtc->shadow_h_sync_strt_wid = aty_ld_le32(CRTC_H_SYNC_STRT_WID, par);\r\ncrtc->shadow_v_tot_disp = aty_ld_le32(CRTC_V_TOTAL_DISP, par);\r\ncrtc->shadow_v_sync_strt_wid = aty_ld_le32(CRTC_V_SYNC_STRT_WID, par);\r\naty_st_le32(LCD_GEN_CNTL, crtc->lcd_gen_cntl, par);\r\n}\r\n#endif\r\n}\r\nstatic void aty_set_crtc(const struct atyfb_par *par, const struct crtc *crtc)\r\n{\r\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\r\nif (par->lcd_table != 0) {\r\naty_st_le32(CRTC_GEN_CNTL, crtc->gen_cntl &\r\n~(CRTC_EXT_DISP_EN | CRTC_EN), par);\r\naty_st_lcd(CNFG_PANEL, crtc->lcd_config_panel, par);\r\naty_st_lcd(LCD_GEN_CNTL, crtc->lcd_gen_cntl &\r\n~(CRTC_RW_SELECT | SHADOW_EN | SHADOW_RW_EN), par);\r\naty_st_lcd(HORZ_STRETCHING, crtc->horz_stretching &\r\n~(HORZ_STRETCH_MODE | HORZ_STRETCH_EN), par);\r\naty_st_lcd(VERT_STRETCHING, crtc->vert_stretching &\r\n~(VERT_STRETCH_RATIO1 | VERT_STRETCH_RATIO2 |\r\nVERT_STRETCH_USE0 | VERT_STRETCH_EN), par);\r\n}\r\n#endif\r\naty_st_le32(CRTC_GEN_CNTL, crtc->gen_cntl & ~CRTC_EN, par);\r\nDPRINTK("setting up CRTC\n");\r\nDPRINTK("set primary CRT to %ix%i %c%c composite %c\n",\r\n((((crtc->h_tot_disp >> 16) & 0xff) + 1) << 3),\r\n(((crtc->v_tot_disp >> 16) & 0x7ff) + 1),\r\n(crtc->h_sync_strt_wid & 0x200000) ? 'N' : 'P',\r\n(crtc->v_sync_strt_wid & 0x200000) ? 'N' : 'P',\r\n(crtc->gen_cntl & CRTC_CSYNC_EN) ? 'P' : 'N');\r\nDPRINTK("CRTC_H_TOTAL_DISP: %x\n", crtc->h_tot_disp);\r\nDPRINTK("CRTC_H_SYNC_STRT_WID: %x\n", crtc->h_sync_strt_wid);\r\nDPRINTK("CRTC_V_TOTAL_DISP: %x\n", crtc->v_tot_disp);\r\nDPRINTK("CRTC_V_SYNC_STRT_WID: %x\n", crtc->v_sync_strt_wid);\r\nDPRINTK("CRTC_OFF_PITCH: %x\n", crtc->off_pitch);\r\nDPRINTK("CRTC_VLINE_CRNT_VLINE: %x\n", crtc->vline_crnt_vline);\r\nDPRINTK("CRTC_GEN_CNTL: %x\n", crtc->gen_cntl);\r\naty_st_le32(CRTC_H_TOTAL_DISP, crtc->h_tot_disp, par);\r\naty_st_le32(CRTC_H_SYNC_STRT_WID, crtc->h_sync_strt_wid, par);\r\naty_st_le32(CRTC_V_TOTAL_DISP, crtc->v_tot_disp, par);\r\naty_st_le32(CRTC_V_SYNC_STRT_WID, crtc->v_sync_strt_wid, par);\r\naty_st_le32(CRTC_OFF_PITCH, crtc->off_pitch, par);\r\naty_st_le32(CRTC_VLINE_CRNT_VLINE, crtc->vline_crnt_vline, par);\r\naty_st_le32(CRTC_GEN_CNTL, crtc->gen_cntl, par);\r\n#if 0\r\nFIXME\r\nif (par->accel_flags & FB_ACCELF_TEXT)\r\naty_init_engine(par, info);\r\n#endif\r\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\r\nif (par->lcd_table != 0) {\r\naty_st_lcd(LCD_GEN_CNTL, (crtc->lcd_gen_cntl & ~CRTC_RW_SELECT) |\r\nSHADOW_EN | SHADOW_RW_EN, par);\r\nDPRINTK("set shadow CRT to %ix%i %c%c\n",\r\n((((crtc->shadow_h_tot_disp >> 16) & 0xff) + 1) << 3),\r\n(((crtc->shadow_v_tot_disp >> 16) & 0x7ff) + 1),\r\n(crtc->shadow_h_sync_strt_wid & 0x200000) ? 'N' : 'P',\r\n(crtc->shadow_v_sync_strt_wid & 0x200000) ? 'N' : 'P');\r\nDPRINTK("SHADOW CRTC_H_TOTAL_DISP: %x\n",\r\ncrtc->shadow_h_tot_disp);\r\nDPRINTK("SHADOW CRTC_H_SYNC_STRT_WID: %x\n",\r\ncrtc->shadow_h_sync_strt_wid);\r\nDPRINTK("SHADOW CRTC_V_TOTAL_DISP: %x\n",\r\ncrtc->shadow_v_tot_disp);\r\nDPRINTK("SHADOW CRTC_V_SYNC_STRT_WID: %x\n",\r\ncrtc->shadow_v_sync_strt_wid);\r\naty_st_le32(CRTC_H_TOTAL_DISP, crtc->shadow_h_tot_disp, par);\r\naty_st_le32(CRTC_H_SYNC_STRT_WID, crtc->shadow_h_sync_strt_wid, par);\r\naty_st_le32(CRTC_V_TOTAL_DISP, crtc->shadow_v_tot_disp, par);\r\naty_st_le32(CRTC_V_SYNC_STRT_WID, crtc->shadow_v_sync_strt_wid, par);\r\nDPRINTK("LCD_GEN_CNTL: %x\n", crtc->lcd_gen_cntl);\r\nDPRINTK("HORZ_STRETCHING: %x\n", crtc->horz_stretching);\r\nDPRINTK("VERT_STRETCHING: %x\n", crtc->vert_stretching);\r\nif (!M64_HAS(LT_LCD_REGS))\r\nDPRINTK("EXT_VERT_STRETCH: %x\n", crtc->ext_vert_stretch);\r\naty_st_lcd(LCD_GEN_CNTL, crtc->lcd_gen_cntl, par);\r\naty_st_lcd(HORZ_STRETCHING, crtc->horz_stretching, par);\r\naty_st_lcd(VERT_STRETCHING, crtc->vert_stretching, par);\r\nif (!M64_HAS(LT_LCD_REGS)) {\r\naty_st_lcd(EXT_VERT_STRETCH, crtc->ext_vert_stretch, par);\r\naty_ld_le32(LCD_INDEX, par);\r\naty_st_le32(LCD_INDEX, crtc->lcd_index, par);\r\n}\r\n}\r\n#endif\r\n}\r\nstatic u32 calc_line_length(struct atyfb_par *par, u32 vxres, u32 bpp)\r\n{\r\nu32 line_length = vxres * bpp / 8;\r\nif (par->ram_type == SGRAM ||\r\n(!M64_HAS(XL_MEM) && par->ram_type == WRAM))\r\nline_length = (line_length + 63) & ~63;\r\nreturn line_length;\r\n}\r\nstatic int aty_var_to_crtc(const struct fb_info *info,\r\nconst struct fb_var_screeninfo *var,\r\nstruct crtc *crtc)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nu32 xres, yres, vxres, vyres, xoffset, yoffset, bpp;\r\nu32 sync, vmode, vdisplay;\r\nu32 h_total, h_disp, h_sync_strt, h_sync_end, h_sync_dly, h_sync_wid, h_sync_pol;\r\nu32 v_total, v_disp, v_sync_strt, v_sync_end, v_sync_wid, v_sync_pol, c_sync;\r\nu32 pix_width, dp_pix_width, dp_chain_mask;\r\nu32 line_length;\r\nxres = (var->xres + 7) & ~7;\r\nyres = var->yres;\r\nvxres = (var->xres_virtual + 7) & ~7;\r\nvyres = var->yres_virtual;\r\nxoffset = (var->xoffset + 7) & ~7;\r\nyoffset = var->yoffset;\r\nbpp = var->bits_per_pixel;\r\nif (bpp == 16)\r\nbpp = (var->green.length == 5) ? 15 : 16;\r\nsync = var->sync;\r\nvmode = var->vmode;\r\nif (vxres < xres + xoffset)\r\nvxres = xres + xoffset;\r\nh_disp = xres;\r\nif (vyres < yres + yoffset)\r\nvyres = yres + yoffset;\r\nv_disp = yres;\r\nif (bpp <= 8) {\r\nbpp = 8;\r\npix_width = CRTC_PIX_WIDTH_8BPP;\r\ndp_pix_width = HOST_8BPP | SRC_8BPP | DST_8BPP |\r\nBYTE_ORDER_LSB_TO_MSB;\r\ndp_chain_mask = DP_CHAIN_8BPP;\r\n} else if (bpp <= 15) {\r\nbpp = 16;\r\npix_width = CRTC_PIX_WIDTH_15BPP;\r\ndp_pix_width = HOST_15BPP | SRC_15BPP | DST_15BPP |\r\nBYTE_ORDER_LSB_TO_MSB;\r\ndp_chain_mask = DP_CHAIN_15BPP;\r\n} else if (bpp <= 16) {\r\nbpp = 16;\r\npix_width = CRTC_PIX_WIDTH_16BPP;\r\ndp_pix_width = HOST_16BPP | SRC_16BPP | DST_16BPP |\r\nBYTE_ORDER_LSB_TO_MSB;\r\ndp_chain_mask = DP_CHAIN_16BPP;\r\n} else if (bpp <= 24 && M64_HAS(INTEGRATED)) {\r\nbpp = 24;\r\npix_width = CRTC_PIX_WIDTH_24BPP;\r\ndp_pix_width = HOST_8BPP | SRC_8BPP | DST_8BPP |\r\nBYTE_ORDER_LSB_TO_MSB;\r\ndp_chain_mask = DP_CHAIN_24BPP;\r\n} else if (bpp <= 32) {\r\nbpp = 32;\r\npix_width = CRTC_PIX_WIDTH_32BPP;\r\ndp_pix_width = HOST_32BPP | SRC_32BPP | DST_32BPP |\r\nBYTE_ORDER_LSB_TO_MSB;\r\ndp_chain_mask = DP_CHAIN_32BPP;\r\n} else\r\nFAIL("invalid bpp");\r\nline_length = calc_line_length(par, vxres, bpp);\r\nif (vyres * line_length > info->fix.smem_len)\r\nFAIL("not enough video RAM");\r\nh_sync_pol = sync & FB_SYNC_HOR_HIGH_ACT ? 0 : 1;\r\nv_sync_pol = sync & FB_SYNC_VERT_HIGH_ACT ? 0 : 1;\r\nif ((xres > 1600) || (yres > 1200)) {\r\nFAIL("MACH64 chips are designed for max 1600x1200\n"\r\n"select another resolution.");\r\n}\r\nh_sync_strt = h_disp + var->right_margin;\r\nh_sync_end = h_sync_strt + var->hsync_len;\r\nh_sync_dly = var->right_margin & 7;\r\nh_total = h_sync_end + h_sync_dly + var->left_margin;\r\nv_sync_strt = v_disp + var->lower_margin;\r\nv_sync_end = v_sync_strt + var->vsync_len;\r\nv_total = v_sync_end + var->upper_margin;\r\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\r\nif (par->lcd_table != 0) {\r\nif (!M64_HAS(LT_LCD_REGS)) {\r\nu32 lcd_index = aty_ld_le32(LCD_INDEX, par);\r\ncrtc->lcd_index = lcd_index &\r\n~(LCD_INDEX_MASK | LCD_DISPLAY_DIS |\r\nLCD_SRC_SEL | CRTC2_DISPLAY_DIS);\r\naty_st_le32(LCD_INDEX, lcd_index, par);\r\n}\r\nif (!M64_HAS(MOBIL_BUS))\r\ncrtc->lcd_index |= CRTC2_DISPLAY_DIS;\r\ncrtc->lcd_config_panel = aty_ld_lcd(CNFG_PANEL, par) | 0x4000;\r\ncrtc->lcd_gen_cntl = aty_ld_lcd(LCD_GEN_CNTL, par) & ~CRTC_RW_SELECT;\r\ncrtc->lcd_gen_cntl &=\r\n~(HORZ_DIVBY2_EN | DIS_HOR_CRT_DIVBY2 | TVCLK_PM_EN |\r\nUSE_SHADOWED_ROWCUR | SHADOW_EN | SHADOW_RW_EN);\r\ncrtc->lcd_gen_cntl |= DONT_SHADOW_VPAR | LOCK_8DOT;\r\nif ((crtc->lcd_gen_cntl & LCD_ON) &&\r\n((xres > par->lcd_width) || (yres > par->lcd_height))) {\r\nif (crtc->lcd_gen_cntl & CRT_ON) {\r\nif (!(var->activate & FB_ACTIVATE_TEST))\r\nPRINTKI("Disable LCD panel, because video mode does not fit.\n");\r\ncrtc->lcd_gen_cntl &= ~LCD_ON;\r\n} else {\r\nif (!(var->activate & FB_ACTIVATE_TEST))\r\nPRINTKE("Video mode exceeds size of LCD panel.\nConnect this computer to a conventional monitor if you really need this mode.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nif ((par->lcd_table != 0) && (crtc->lcd_gen_cntl & LCD_ON)) {\r\nint VScan = 1;\r\nvmode &= ~(FB_VMODE_DOUBLE | FB_VMODE_INTERLACED);\r\nif (yres < par->lcd_height) {\r\nVScan = par->lcd_height / yres;\r\nif (VScan > 1) {\r\nVScan = 2;\r\nvmode |= FB_VMODE_DOUBLE;\r\n}\r\n}\r\nh_sync_strt = h_disp + par->lcd_right_margin;\r\nh_sync_end = h_sync_strt + par->lcd_hsync_len;\r\nh_sync_dly = par->lcd_hsync_dly;\r\nh_total = h_disp + par->lcd_hblank_len;\r\nv_sync_strt = v_disp + par->lcd_lower_margin / VScan;\r\nv_sync_end = v_sync_strt + par->lcd_vsync_len / VScan;\r\nv_total = v_disp + par->lcd_vblank_len / VScan;\r\n}\r\n#endif\r\nh_disp = (h_disp >> 3) - 1;\r\nh_sync_strt = (h_sync_strt >> 3) - 1;\r\nh_sync_end = (h_sync_end >> 3) - 1;\r\nh_total = (h_total >> 3) - 1;\r\nh_sync_wid = h_sync_end - h_sync_strt;\r\nFAIL_MAX("h_disp too large", h_disp, 0xff);\r\nFAIL_MAX("h_sync_strt too large", h_sync_strt, 0x1ff);\r\nif (h_sync_wid > 0x1f)\r\nh_sync_wid = 0x1f;\r\nFAIL_MAX("h_total too large", h_total, 0x1ff);\r\nif (vmode & FB_VMODE_DOUBLE) {\r\nv_disp <<= 1;\r\nv_sync_strt <<= 1;\r\nv_sync_end <<= 1;\r\nv_total <<= 1;\r\n}\r\nvdisplay = yres;\r\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\r\nif ((par->lcd_table != 0) && (crtc->lcd_gen_cntl & LCD_ON))\r\nvdisplay = par->lcd_height;\r\n#endif\r\nv_disp--;\r\nv_sync_strt--;\r\nv_sync_end--;\r\nv_total--;\r\nv_sync_wid = v_sync_end - v_sync_strt;\r\nFAIL_MAX("v_disp too large", v_disp, 0x7ff);\r\nFAIL_MAX("v_sync_stsrt too large", v_sync_strt, 0x7ff);\r\nif (v_sync_wid > 0x1f)\r\nv_sync_wid = 0x1f;\r\nFAIL_MAX("v_total too large", v_total, 0x7ff);\r\nc_sync = sync & FB_SYNC_COMP_HIGH_ACT ? CRTC_CSYNC_EN : 0;\r\ncrtc->vxres = vxres;\r\ncrtc->vyres = vyres;\r\ncrtc->xoffset = xoffset;\r\ncrtc->yoffset = yoffset;\r\ncrtc->bpp = bpp;\r\ncrtc->off_pitch =\r\n((yoffset * line_length + xoffset * bpp / 8) / 8) |\r\n((line_length / bpp) << 22);\r\ncrtc->vline_crnt_vline = 0;\r\ncrtc->h_tot_disp = h_total | (h_disp << 16);\r\ncrtc->h_sync_strt_wid = (h_sync_strt & 0xff) | (h_sync_dly << 8) |\r\n((h_sync_strt & 0x100) << 4) | (h_sync_wid << 16) |\r\n(h_sync_pol << 21);\r\ncrtc->v_tot_disp = v_total | (v_disp << 16);\r\ncrtc->v_sync_strt_wid = v_sync_strt | (v_sync_wid << 16) |\r\n(v_sync_pol << 21);\r\ncrtc->gen_cntl = CRTC_EXT_DISP_EN | CRTC_EN | pix_width | c_sync;\r\ncrtc->gen_cntl |= CRTC_VGA_LINEAR;\r\nif (vmode & FB_VMODE_DOUBLE)\r\ncrtc->gen_cntl |= CRTC_DBL_SCAN_EN;\r\nif (vmode & FB_VMODE_INTERLACED)\r\ncrtc->gen_cntl |= CRTC_INTERLACE_EN;\r\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\r\nif (par->lcd_table != 0) {\r\nvdisplay = yres;\r\nif (vmode & FB_VMODE_DOUBLE)\r\nvdisplay <<= 1;\r\ncrtc->gen_cntl &= ~(CRTC2_EN | CRTC2_PIX_WIDTH);\r\ncrtc->lcd_gen_cntl &= ~(HORZ_DIVBY2_EN | DIS_HOR_CRT_DIVBY2 |\r\nUSE_SHADOWED_VEND |\r\nUSE_SHADOWED_ROWCUR |\r\nSHADOW_EN | SHADOW_RW_EN);\r\ncrtc->lcd_gen_cntl |= DONT_SHADOW_VPAR;\r\ncrtc->horz_stretching = aty_ld_lcd(HORZ_STRETCHING, par);\r\nif (!M64_HAS(LT_LCD_REGS))\r\ncrtc->ext_vert_stretch = aty_ld_lcd(EXT_VERT_STRETCH, par) &\r\n~(AUTO_VERT_RATIO | VERT_STRETCH_MODE | VERT_STRETCH_RATIO3);\r\ncrtc->horz_stretching &= ~(HORZ_STRETCH_RATIO |\r\nHORZ_STRETCH_LOOP | AUTO_HORZ_RATIO |\r\nHORZ_STRETCH_MODE | HORZ_STRETCH_EN);\r\nif (xres < par->lcd_width && crtc->lcd_gen_cntl & LCD_ON) {\r\ndo {\r\nint HDisplay = xres & ~7;\r\nint nStretch = par->lcd_width / HDisplay;\r\nint Remainder = par->lcd_width % HDisplay;\r\nif ((!Remainder && ((nStretch > 2))) ||\r\n(((HDisplay * 16) / par->lcd_width) < 7)) {\r\nstatic const char StretchLoops[] = { 10, 12, 13, 15, 16 };\r\nint horz_stretch_loop = -1, BestRemainder;\r\nint Numerator = HDisplay, Denominator = par->lcd_width;\r\nint Index = 5;\r\nATIReduceRatio(&Numerator, &Denominator);\r\nBestRemainder = (Numerator * 16) / Denominator;\r\nwhile (--Index >= 0) {\r\nRemainder = ((Denominator - Numerator) * StretchLoops[Index]) %\r\nDenominator;\r\nif (Remainder < BestRemainder) {\r\nhorz_stretch_loop = Index;\r\nif (!(BestRemainder = Remainder))\r\nbreak;\r\n}\r\n}\r\nif ((horz_stretch_loop >= 0) && !BestRemainder) {\r\nint horz_stretch_ratio = 0, Accumulator = 0;\r\nint reuse_previous = 1;\r\nIndex = StretchLoops[horz_stretch_loop];\r\nwhile (--Index >= 0) {\r\nif (Accumulator > 0)\r\nhorz_stretch_ratio |= reuse_previous;\r\nelse\r\nAccumulator += Denominator;\r\nAccumulator -= Numerator;\r\nreuse_previous <<= 1;\r\n}\r\ncrtc->horz_stretching |= (HORZ_STRETCH_EN |\r\n((horz_stretch_loop & HORZ_STRETCH_LOOP) << 16) |\r\n(horz_stretch_ratio & HORZ_STRETCH_RATIO));\r\nbreak;\r\n}\r\n}\r\ncrtc->horz_stretching |= (HORZ_STRETCH_MODE | HORZ_STRETCH_EN |\r\n(((HDisplay * (HORZ_STRETCH_BLEND + 1)) / par->lcd_width) & HORZ_STRETCH_BLEND));\r\n} while (0);\r\n}\r\nif (vdisplay < par->lcd_height && crtc->lcd_gen_cntl & LCD_ON) {\r\ncrtc->vert_stretching = (VERT_STRETCH_USE0 | VERT_STRETCH_EN |\r\n(((vdisplay * (VERT_STRETCH_RATIO0 + 1)) / par->lcd_height) & VERT_STRETCH_RATIO0));\r\nif (!M64_HAS(LT_LCD_REGS) &&\r\nxres <= (M64_HAS(MOBIL_BUS) ? 1024 : 800))\r\ncrtc->ext_vert_stretch |= VERT_STRETCH_MODE;\r\n} else {\r\ncrtc->vert_stretching = 0;\r\n}\r\ncrtc->shadow_h_tot_disp = crtc->h_tot_disp;\r\ncrtc->shadow_h_sync_strt_wid = crtc->h_sync_strt_wid;\r\ncrtc->shadow_v_tot_disp = crtc->v_tot_disp;\r\ncrtc->shadow_v_sync_strt_wid = crtc->v_sync_strt_wid;\r\n}\r\n#endif\r\nif (M64_HAS(MAGIC_FIFO)) {\r\ncrtc->gen_cntl |= (aty_ld_le32(CRTC_GEN_CNTL, par) & CRTC_FIFO_LWM);\r\n}\r\ncrtc->dp_pix_width = dp_pix_width;\r\ncrtc->dp_chain_mask = dp_chain_mask;\r\nreturn 0;\r\n}\r\nstatic int aty_crtc_to_var(const struct crtc *crtc,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nu32 xres, yres, bpp, left, right, upper, lower, hslen, vslen, sync;\r\nu32 h_total, h_disp, h_sync_strt, h_sync_dly, h_sync_wid, h_sync_pol;\r\nu32 v_total, v_disp, v_sync_strt, v_sync_wid, v_sync_pol, c_sync;\r\nu32 pix_width;\r\nu32 double_scan, interlace;\r\nh_total = crtc->h_tot_disp & 0x1ff;\r\nh_disp = (crtc->h_tot_disp >> 16) & 0xff;\r\nh_sync_strt = (crtc->h_sync_strt_wid & 0xff) | ((crtc->h_sync_strt_wid >> 4) & 0x100);\r\nh_sync_dly = (crtc->h_sync_strt_wid >> 8) & 0x7;\r\nh_sync_wid = (crtc->h_sync_strt_wid >> 16) & 0x1f;\r\nh_sync_pol = (crtc->h_sync_strt_wid >> 21) & 0x1;\r\nv_total = crtc->v_tot_disp & 0x7ff;\r\nv_disp = (crtc->v_tot_disp >> 16) & 0x7ff;\r\nv_sync_strt = crtc->v_sync_strt_wid & 0x7ff;\r\nv_sync_wid = (crtc->v_sync_strt_wid >> 16) & 0x1f;\r\nv_sync_pol = (crtc->v_sync_strt_wid >> 21) & 0x1;\r\nc_sync = crtc->gen_cntl & CRTC_CSYNC_EN ? 1 : 0;\r\npix_width = crtc->gen_cntl & CRTC_PIX_WIDTH_MASK;\r\ndouble_scan = crtc->gen_cntl & CRTC_DBL_SCAN_EN;\r\ninterlace = crtc->gen_cntl & CRTC_INTERLACE_EN;\r\nxres = (h_disp + 1) * 8;\r\nyres = v_disp + 1;\r\nleft = (h_total - h_sync_strt - h_sync_wid) * 8 - h_sync_dly;\r\nright = (h_sync_strt - h_disp) * 8 + h_sync_dly;\r\nhslen = h_sync_wid * 8;\r\nupper = v_total - v_sync_strt - v_sync_wid;\r\nlower = v_sync_strt - v_disp;\r\nvslen = v_sync_wid;\r\nsync = (h_sync_pol ? 0 : FB_SYNC_HOR_HIGH_ACT) |\r\n(v_sync_pol ? 0 : FB_SYNC_VERT_HIGH_ACT) |\r\n(c_sync ? FB_SYNC_COMP_HIGH_ACT : 0);\r\nswitch (pix_width) {\r\n#if 0\r\ncase CRTC_PIX_WIDTH_4BPP:\r\nbpp = 4;\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 0;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\n#endif\r\ncase CRTC_PIX_WIDTH_8BPP:\r\nbpp = 8;\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 0;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase CRTC_PIX_WIDTH_15BPP:\r\nbpp = 16;\r\nvar->red.offset = 10;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 5;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase CRTC_PIX_WIDTH_16BPP:\r\nbpp = 16;\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase CRTC_PIX_WIDTH_24BPP:\r\nbpp = 24;\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase CRTC_PIX_WIDTH_32BPP:\r\nbpp = 32;\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\nbreak;\r\ndefault:\r\nPRINTKE("Invalid pixel width\n");\r\nreturn -EINVAL;\r\n}\r\nvar->xres = xres;\r\nvar->yres = yres;\r\nvar->xres_virtual = crtc->vxres;\r\nvar->yres_virtual = crtc->vyres;\r\nvar->bits_per_pixel = bpp;\r\nvar->left_margin = left;\r\nvar->right_margin = right;\r\nvar->upper_margin = upper;\r\nvar->lower_margin = lower;\r\nvar->hsync_len = hslen;\r\nvar->vsync_len = vslen;\r\nvar->sync = sync;\r\nvar->vmode = FB_VMODE_NONINTERLACED;\r\nif (interlace)\r\nvar->vmode = FB_VMODE_INTERLACED;\r\nif (double_scan) {\r\nvar->vmode = FB_VMODE_DOUBLE;\r\nvar->yres >>= 1;\r\nvar->upper_margin >>= 1;\r\nvar->lower_margin >>= 1;\r\nvar->vsync_len >>= 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atyfb_set_par(struct fb_info *info)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nu32 tmp, pixclock;\r\nint err;\r\n#ifdef DEBUG\r\nstruct fb_var_screeninfo debug;\r\nu32 pixclock_in_ps;\r\n#endif\r\nif (par->asleep)\r\nreturn 0;\r\nerr = aty_var_to_crtc(info, var, &par->crtc);\r\nif (err)\r\nreturn err;\r\npixclock = atyfb_get_pixclock(var, par);\r\nif (pixclock == 0) {\r\nPRINTKE("Invalid pixclock\n");\r\nreturn -EINVAL;\r\n} else {\r\nerr = par->pll_ops->var_to_pll(info, pixclock,\r\nvar->bits_per_pixel, &par->pll);\r\nif (err)\r\nreturn err;\r\n}\r\npar->accel_flags = var->accel_flags;\r\nif (var->accel_flags) {\r\ninfo->fbops->fb_sync = atyfb_sync;\r\ninfo->flags &= ~FBINFO_HWACCEL_DISABLED;\r\n} else {\r\ninfo->fbops->fb_sync = NULL;\r\ninfo->flags |= FBINFO_HWACCEL_DISABLED;\r\n}\r\nif (par->blitter_may_be_busy)\r\nwait_for_idle(par);\r\naty_set_crtc(par, &par->crtc);\r\npar->dac_ops->set_dac(info, &par->pll,\r\nvar->bits_per_pixel, par->accel_flags);\r\npar->pll_ops->set_pll(info, &par->pll);\r\n#ifdef DEBUG\r\nif (par->pll_ops && par->pll_ops->pll_to_var)\r\npixclock_in_ps = par->pll_ops->pll_to_var(info, &par->pll);\r\nelse\r\npixclock_in_ps = 0;\r\nif (0 == pixclock_in_ps) {\r\nPRINTKE("ALERT ops->pll_to_var get 0\n");\r\npixclock_in_ps = pixclock;\r\n}\r\nmemset(&debug, 0, sizeof(debug));\r\nif (!aty_crtc_to_var(&par->crtc, &debug)) {\r\nu32 hSync, vRefresh;\r\nu32 h_disp, h_sync_strt, h_sync_end, h_total;\r\nu32 v_disp, v_sync_strt, v_sync_end, v_total;\r\nh_disp = debug.xres;\r\nh_sync_strt = h_disp + debug.right_margin;\r\nh_sync_end = h_sync_strt + debug.hsync_len;\r\nh_total = h_sync_end + debug.left_margin;\r\nv_disp = debug.yres;\r\nv_sync_strt = v_disp + debug.lower_margin;\r\nv_sync_end = v_sync_strt + debug.vsync_len;\r\nv_total = v_sync_end + debug.upper_margin;\r\nhSync = 1000000000 / (pixclock_in_ps * h_total);\r\nvRefresh = (hSync * 1000) / v_total;\r\nif (par->crtc.gen_cntl & CRTC_INTERLACE_EN)\r\nvRefresh *= 2;\r\nif (par->crtc.gen_cntl & CRTC_DBL_SCAN_EN)\r\nvRefresh /= 2;\r\nDPRINTK("atyfb_set_par\n");\r\nDPRINTK(" Set Visible Mode to %ix%i-%i\n",\r\nvar->xres, var->yres, var->bits_per_pixel);\r\nDPRINTK(" Virtual resolution %ix%i, "\r\n"pixclock_in_ps %i (calculated %i)\n",\r\nvar->xres_virtual, var->yres_virtual,\r\npixclock, pixclock_in_ps);\r\nDPRINTK(" Dot clock: %i MHz\n",\r\n1000000 / pixclock_in_ps);\r\nDPRINTK(" Horizontal sync: %i kHz\n", hSync);\r\nDPRINTK(" Vertical refresh: %i Hz\n", vRefresh);\r\nDPRINTK(" x style: %i.%03i %i %i %i %i %i %i %i %i\n",\r\n1000000 / pixclock_in_ps, 1000000 % pixclock_in_ps,\r\nh_disp, h_sync_strt, h_sync_end, h_total,\r\nv_disp, v_sync_strt, v_sync_end, v_total);\r\nDPRINTK(" fb style: %i %i %i %i %i %i %i %i %i\n",\r\npixclock_in_ps,\r\ndebug.left_margin, h_disp, debug.right_margin, debug.hsync_len,\r\ndebug.upper_margin, v_disp, debug.lower_margin, debug.vsync_len);\r\n}\r\n#endif\r\nif (!M64_HAS(INTEGRATED)) {\r\ntmp = aty_ld_le32(MEM_CNTL, par) & 0xf0ffffff;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\ntmp |= 0x02000000;\r\nbreak;\r\ncase 16:\r\ntmp |= 0x03000000;\r\nbreak;\r\ncase 32:\r\ntmp |= 0x06000000;\r\nbreak;\r\n}\r\naty_st_le32(MEM_CNTL, tmp, par);\r\n} else {\r\ntmp = aty_ld_le32(MEM_CNTL, par) & 0xf00fffff;\r\nif (!M64_HAS(MAGIC_POSTDIV))\r\ntmp |= par->mem_refresh_rate << 20;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\ncase 24:\r\ntmp |= 0x00000000;\r\nbreak;\r\ncase 16:\r\ntmp |= 0x04000000;\r\nbreak;\r\ncase 32:\r\ntmp |= 0x08000000;\r\nbreak;\r\n}\r\nif (M64_HAS(CT_BUS)) {\r\naty_st_le32(DAC_CNTL, 0x87010184, par);\r\naty_st_le32(BUS_CNTL, 0x680000f9, par);\r\n} else if (M64_HAS(VT_BUS)) {\r\naty_st_le32(DAC_CNTL, 0x87010184, par);\r\naty_st_le32(BUS_CNTL, 0x680000f9, par);\r\n} else if (M64_HAS(MOBIL_BUS)) {\r\naty_st_le32(DAC_CNTL, 0x80010102, par);\r\naty_st_le32(BUS_CNTL, 0x7b33a040 | (par->aux_start ? BUS_APER_REG_DIS : 0), par);\r\n} else {\r\naty_st_le32(DAC_CNTL, 0x86010102, par);\r\naty_st_le32(BUS_CNTL, 0x7b23a040 | (par->aux_start ? BUS_APER_REG_DIS : 0), par);\r\naty_st_le32(EXT_MEM_CNTL, aty_ld_le32(EXT_MEM_CNTL, par) | 0x5000001, par);\r\n}\r\naty_st_le32(MEM_CNTL, tmp, par);\r\n}\r\naty_st_8(DAC_MASK, 0xff, par);\r\ninfo->fix.line_length = calc_line_length(par, var->xres_virtual,\r\nvar->bits_per_pixel);\r\ninfo->fix.visual = var->bits_per_pixel <= 8 ?\r\nFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_DIRECTCOLOR;\r\nif (par->accel_flags & FB_ACCELF_TEXT)\r\naty_init_engine(par, info);\r\n#ifdef CONFIG_BOOTX_TEXT\r\nbtext_update_display(info->fix.smem_start,\r\n(((par->crtc.h_tot_disp >> 16) & 0xff) + 1) * 8,\r\n((par->crtc.v_tot_disp >> 16) & 0x7ff) + 1,\r\nvar->bits_per_pixel,\r\npar->crtc.vxres * var->bits_per_pixel / 8);\r\n#endif\r\n#if 0\r\nif (!(par->crtc.gen_cntl & CRTC_EXT_DISP_EN))\r\naty_st_le32(CRTC_GEN_CNTL, par->crtc.gen_cntl | CRTC_EXT_DISP_EN, par);\r\n#endif\r\n#ifdef DEBUG\r\n{\r\nint i; u32 base;\r\nbase = 0x2000;\r\nprintk("debug atyfb: Mach64 non-shadow register values:");\r\nfor (i = 0; i < 256; i = i+4) {\r\nif (i % 16 == 0)\r\nprintk("\ndebug atyfb: 0x%04X: ", base + i);\r\nprintk(" %08X", aty_ld_le32(i, par));\r\n}\r\nprintk("\n\n");\r\n#ifdef CONFIG_FB_ATY_CT\r\nbase = 0x00;\r\nprintk("debug atyfb: Mach64 PLL register values:");\r\nfor (i = 0; i < 64; i++) {\r\nif (i % 16 == 0)\r\nprintk("\ndebug atyfb: 0x%02X: ", base + i);\r\nif (i % 4 == 0)\r\nprintk(" ");\r\nprintk("%02X", aty_ld_pll_ct(i, par));\r\n}\r\nprintk("\n\n");\r\n#endif\r\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\r\nif (par->lcd_table != 0) {\r\nbase = 0x00;\r\nprintk("debug atyfb: LCD register values:");\r\nif (M64_HAS(LT_LCD_REGS)) {\r\nfor (i = 0; i <= POWER_MANAGEMENT; i++) {\r\nif (i == EXT_VERT_STRETCH)\r\ncontinue;\r\nprintk("\ndebug atyfb: 0x%04X: ",\r\nlt_lcd_regs[i]);\r\nprintk(" %08X", aty_ld_lcd(i, par));\r\n}\r\n} else {\r\nfor (i = 0; i < 64; i++) {\r\nif (i % 4 == 0)\r\nprintk("\ndebug atyfb: 0x%02X: ",\r\nbase + i);\r\nprintk(" %08X", aty_ld_lcd(i, par));\r\n}\r\n}\r\nprintk("\n\n");\r\n}\r\n#endif\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int atyfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nint err;\r\nstruct crtc crtc;\r\nunion aty_pll pll;\r\nu32 pixclock;\r\nmemcpy(&pll, &par->pll, sizeof(pll));\r\nerr = aty_var_to_crtc(info, var, &crtc);\r\nif (err)\r\nreturn err;\r\npixclock = atyfb_get_pixclock(var, par);\r\nif (pixclock == 0) {\r\nif (!(var->activate & FB_ACTIVATE_TEST))\r\nPRINTKE("Invalid pixclock\n");\r\nreturn -EINVAL;\r\n} else {\r\nerr = par->pll_ops->var_to_pll(info, pixclock,\r\nvar->bits_per_pixel, &pll);\r\nif (err)\r\nreturn err;\r\n}\r\nif (var->accel_flags & FB_ACCELF_TEXT)\r\ninfo->var.accel_flags = FB_ACCELF_TEXT;\r\nelse\r\ninfo->var.accel_flags = 0;\r\naty_crtc_to_var(&crtc, var);\r\nvar->pixclock = par->pll_ops->pll_to_var(info, &pll);\r\nreturn 0;\r\n}\r\nstatic void set_off_pitch(struct atyfb_par *par, const struct fb_info *info)\r\n{\r\nu32 xoffset = info->var.xoffset;\r\nu32 yoffset = info->var.yoffset;\r\nu32 line_length = info->fix.line_length;\r\nu32 bpp = info->var.bits_per_pixel;\r\npar->crtc.off_pitch =\r\n((yoffset * line_length + xoffset * bpp / 8) / 8) |\r\n((line_length / bpp) << 22);\r\n}\r\nstatic int atyfb_open(struct fb_info *info, int user)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nif (user) {\r\npar->open++;\r\n#ifdef __sparc__\r\npar->mmaped = 0;\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t aty_irq(int irq, void *dev_id)\r\n{\r\nstruct atyfb_par *par = dev_id;\r\nint handled = 0;\r\nu32 int_cntl;\r\nspin_lock(&par->int_lock);\r\nint_cntl = aty_ld_le32(CRTC_INT_CNTL, par);\r\nif (int_cntl & CRTC_VBLANK_INT) {\r\naty_st_le32(CRTC_INT_CNTL, (int_cntl & CRTC_INT_EN_MASK) |\r\nCRTC_VBLANK_INT_AK, par);\r\npar->vblank.count++;\r\nif (par->vblank.pan_display) {\r\npar->vblank.pan_display = 0;\r\naty_st_le32(CRTC_OFF_PITCH, par->crtc.off_pitch, par);\r\n}\r\nwake_up_interruptible(&par->vblank.wait);\r\nhandled = 1;\r\n}\r\nspin_unlock(&par->int_lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int aty_enable_irq(struct atyfb_par *par, int reenable)\r\n{\r\nu32 int_cntl;\r\nif (!test_and_set_bit(0, &par->irq_flags)) {\r\nif (request_irq(par->irq, aty_irq, IRQF_SHARED, "atyfb", par)) {\r\nclear_bit(0, &par->irq_flags);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irq(&par->int_lock);\r\nint_cntl = aty_ld_le32(CRTC_INT_CNTL, par) & CRTC_INT_EN_MASK;\r\naty_st_le32(CRTC_INT_CNTL, int_cntl | CRTC_VBLANK_INT_AK, par);\r\naty_st_le32(CRTC_INT_CNTL, int_cntl | CRTC_VBLANK_INT_EN, par);\r\nspin_unlock_irq(&par->int_lock);\r\n} else if (reenable) {\r\nspin_lock_irq(&par->int_lock);\r\nint_cntl = aty_ld_le32(CRTC_INT_CNTL, par) & CRTC_INT_EN_MASK;\r\nif (!(int_cntl & CRTC_VBLANK_INT_EN)) {\r\nprintk("atyfb: someone disabled IRQ [%08x]\n",\r\nint_cntl);\r\naty_st_le32(CRTC_INT_CNTL, int_cntl |\r\nCRTC_VBLANK_INT_EN, par);\r\n}\r\nspin_unlock_irq(&par->int_lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int aty_disable_irq(struct atyfb_par *par)\r\n{\r\nu32 int_cntl;\r\nif (test_and_clear_bit(0, &par->irq_flags)) {\r\nif (par->vblank.pan_display) {\r\npar->vblank.pan_display = 0;\r\naty_st_le32(CRTC_OFF_PITCH, par->crtc.off_pitch, par);\r\n}\r\nspin_lock_irq(&par->int_lock);\r\nint_cntl = aty_ld_le32(CRTC_INT_CNTL, par) & CRTC_INT_EN_MASK;\r\naty_st_le32(CRTC_INT_CNTL, int_cntl & ~CRTC_VBLANK_INT_EN, par);\r\nspin_unlock_irq(&par->int_lock);\r\nfree_irq(par->irq, par);\r\n}\r\nreturn 0;\r\n}\r\nstatic int atyfb_release(struct fb_info *info, int user)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\n#ifdef __sparc__\r\nint was_mmaped;\r\n#endif\r\nif (!user)\r\nreturn 0;\r\npar->open--;\r\nmdelay(1);\r\nwait_for_idle(par);\r\nif (par->open)\r\nreturn 0;\r\n#ifdef __sparc__\r\nwas_mmaped = par->mmaped;\r\npar->mmaped = 0;\r\nif (was_mmaped) {\r\nstruct fb_var_screeninfo var;\r\nvar = default_var;\r\nif (noaccel)\r\nvar.accel_flags &= ~FB_ACCELF_TEXT;\r\nelse\r\nvar.accel_flags |= FB_ACCELF_TEXT;\r\nif (var.yres == var.yres_virtual) {\r\nu32 videoram = (info->fix.smem_len - (PAGE_SIZE << 2));\r\nvar.yres_virtual =\r\n((videoram * 8) / var.bits_per_pixel) /\r\nvar.xres_virtual;\r\nif (var.yres_virtual < var.yres)\r\nvar.yres_virtual = var.yres;\r\n}\r\n}\r\n#endif\r\naty_disable_irq(par);\r\nreturn 0;\r\n}\r\nstatic int atyfb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nu32 xres, yres, xoffset, yoffset;\r\nxres = (((par->crtc.h_tot_disp >> 16) & 0xff) + 1) * 8;\r\nyres = ((par->crtc.v_tot_disp >> 16) & 0x7ff) + 1;\r\nif (par->crtc.gen_cntl & CRTC_DBL_SCAN_EN)\r\nyres >>= 1;\r\nxoffset = (var->xoffset + 7) & ~7;\r\nyoffset = var->yoffset;\r\nif (xoffset + xres > par->crtc.vxres ||\r\nyoffset + yres > par->crtc.vyres)\r\nreturn -EINVAL;\r\ninfo->var.xoffset = xoffset;\r\ninfo->var.yoffset = yoffset;\r\nif (par->asleep)\r\nreturn 0;\r\nset_off_pitch(par, info);\r\nif ((var->activate & FB_ACTIVATE_VBL) && !aty_enable_irq(par, 0)) {\r\npar->vblank.pan_display = 1;\r\n} else {\r\npar->vblank.pan_display = 0;\r\naty_st_le32(CRTC_OFF_PITCH, par->crtc.off_pitch, par);\r\n}\r\nreturn 0;\r\n}\r\nstatic int aty_waitforvblank(struct atyfb_par *par, u32 crtc)\r\n{\r\nstruct aty_interrupt *vbl;\r\nunsigned int count;\r\nint ret;\r\nswitch (crtc) {\r\ncase 0:\r\nvbl = &par->vblank;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nret = aty_enable_irq(par, 0);\r\nif (ret)\r\nreturn ret;\r\ncount = vbl->count;\r\nret = wait_event_interruptible_timeout(vbl->wait,\r\ncount != vbl->count, HZ/10);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret == 0) {\r\naty_enable_irq(par, 1);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atyfb_ioctl(struct fb_info *info, u_int cmd, u_long arg)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\n#ifdef __sparc__\r\nstruct fbtype fbtyp;\r\n#endif\r\nswitch (cmd) {\r\n#ifdef __sparc__\r\ncase FBIOGTYPE:\r\nfbtyp.fb_type = FBTYPE_PCI_GENERIC;\r\nfbtyp.fb_width = par->crtc.vxres;\r\nfbtyp.fb_height = par->crtc.vyres;\r\nfbtyp.fb_depth = info->var.bits_per_pixel;\r\nfbtyp.fb_cmsize = info->cmap.len;\r\nfbtyp.fb_size = info->fix.smem_len;\r\nif (copy_to_user((struct fbtype __user *) arg, &fbtyp,\r\nsizeof(fbtyp)))\r\nreturn -EFAULT;\r\nbreak;\r\n#endif\r\ncase FBIO_WAITFORVSYNC:\r\n{\r\nu32 crtc;\r\nif (get_user(crtc, (__u32 __user *) arg))\r\nreturn -EFAULT;\r\nreturn aty_waitforvblank(par, crtc);\r\n}\r\nbreak;\r\n#if defined(DEBUG) && defined(CONFIG_FB_ATY_CT)\r\ncase ATYIO_CLKR:\r\nif (M64_HAS(INTEGRATED)) {\r\nstruct atyclk clk;\r\nunion aty_pll *pll = &par->pll;\r\nu32 dsp_config = pll->ct.dsp_config;\r\nu32 dsp_on_off = pll->ct.dsp_on_off;\r\nclk.ref_clk_per = par->ref_clk_per;\r\nclk.pll_ref_div = pll->ct.pll_ref_div;\r\nclk.mclk_fb_div = pll->ct.mclk_fb_div;\r\nclk.mclk_post_div = pll->ct.mclk_post_div_real;\r\nclk.mclk_fb_mult = pll->ct.mclk_fb_mult;\r\nclk.xclk_post_div = pll->ct.xclk_post_div_real;\r\nclk.vclk_fb_div = pll->ct.vclk_fb_div;\r\nclk.vclk_post_div = pll->ct.vclk_post_div_real;\r\nclk.dsp_xclks_per_row = dsp_config & 0x3fff;\r\nclk.dsp_loop_latency = (dsp_config >> 16) & 0xf;\r\nclk.dsp_precision = (dsp_config >> 20) & 7;\r\nclk.dsp_off = dsp_on_off & 0x7ff;\r\nclk.dsp_on = (dsp_on_off >> 16) & 0x7ff;\r\nif (copy_to_user((struct atyclk __user *) arg, &clk,\r\nsizeof(clk)))\r\nreturn -EFAULT;\r\n} else\r\nreturn -EINVAL;\r\nbreak;\r\ncase ATYIO_CLKW:\r\nif (M64_HAS(INTEGRATED)) {\r\nstruct atyclk clk;\r\nunion aty_pll *pll = &par->pll;\r\nif (copy_from_user(&clk, (struct atyclk __user *) arg,\r\nsizeof(clk)))\r\nreturn -EFAULT;\r\npar->ref_clk_per = clk.ref_clk_per;\r\npll->ct.pll_ref_div = clk.pll_ref_div;\r\npll->ct.mclk_fb_div = clk.mclk_fb_div;\r\npll->ct.mclk_post_div_real = clk.mclk_post_div;\r\npll->ct.mclk_fb_mult = clk.mclk_fb_mult;\r\npll->ct.xclk_post_div_real = clk.xclk_post_div;\r\npll->ct.vclk_fb_div = clk.vclk_fb_div;\r\npll->ct.vclk_post_div_real = clk.vclk_post_div;\r\npll->ct.dsp_config = (clk.dsp_xclks_per_row & 0x3fff) |\r\n((clk.dsp_loop_latency & 0xf) << 16) |\r\n((clk.dsp_precision & 7) << 20);\r\npll->ct.dsp_on_off = (clk.dsp_off & 0x7ff) |\r\n((clk.dsp_on & 0x7ff) << 16);\r\naty_set_pll_ct(info, pll);\r\n} else\r\nreturn -EINVAL;\r\nbreak;\r\ncase ATYIO_FEATR:\r\nif (get_user(par->features, (u32 __user *) arg))\r\nreturn -EFAULT;\r\nbreak;\r\ncase ATYIO_FEATW:\r\nif (put_user(par->features, (u32 __user *) arg))\r\nreturn -EFAULT;\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atyfb_sync(struct fb_info *info)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nif (par->blitter_may_be_busy)\r\nwait_for_idle(par);\r\nreturn 0;\r\n}\r\nstatic int atyfb_mmap(struct fb_info *info, struct vm_area_struct *vma)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nunsigned int size, page, map_size = 0;\r\nunsigned long map_offset = 0;\r\nunsigned long off;\r\nint i;\r\nif (!par->mmap_map)\r\nreturn -ENXIO;\r\nif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\r\nreturn -EINVAL;\r\noff = vma->vm_pgoff << PAGE_SHIFT;\r\nsize = vma->vm_end - vma->vm_start;\r\nif (((vma->vm_pgoff == 0) && (size == info->fix.smem_len)) ||\r\n((off == info->fix.smem_len) && (size == PAGE_SIZE)))\r\noff += 0x8000000000000000UL;\r\nvma->vm_pgoff = off >> PAGE_SHIFT;\r\nfor (page = 0; page < size;) {\r\nmap_size = 0;\r\nfor (i = 0; par->mmap_map[i].size; i++) {\r\nunsigned long start = par->mmap_map[i].voff;\r\nunsigned long end = start + par->mmap_map[i].size;\r\nunsigned long offset = off + page;\r\nif (start > offset)\r\ncontinue;\r\nif (offset >= end)\r\ncontinue;\r\nmap_size = par->mmap_map[i].size - (offset - start);\r\nmap_offset = par->mmap_map[i].poff + (offset - start);\r\nbreak;\r\n}\r\nif (!map_size) {\r\npage += PAGE_SIZE;\r\ncontinue;\r\n}\r\nif (page + map_size > size)\r\nmap_size = size - page;\r\npgprot_val(vma->vm_page_prot) &= ~(par->mmap_map[i].prot_mask);\r\npgprot_val(vma->vm_page_prot) |= par->mmap_map[i].prot_flag;\r\nif (remap_pfn_range(vma, vma->vm_start + page,\r\nmap_offset >> PAGE_SHIFT, map_size, vma->vm_page_prot))\r\nreturn -EAGAIN;\r\npage += map_size;\r\n}\r\nif (!map_size)\r\nreturn -EINVAL;\r\nif (!par->mmaped)\r\npar->mmaped = 1;\r\nreturn 0;\r\n}\r\nstatic int aty_power_mgmt(int sleep, struct atyfb_par *par)\r\n{\r\nu32 pm;\r\nint timeout;\r\npm = aty_ld_lcd(POWER_MANAGEMENT, par);\r\npm = (pm & ~PWR_MGT_MODE_MASK) | PWR_MGT_MODE_REG;\r\naty_st_lcd(POWER_MANAGEMENT, pm, par);\r\npm = aty_ld_lcd(POWER_MANAGEMENT, par);\r\ntimeout = 2000;\r\nif (sleep) {\r\npm &= ~PWR_MGT_ON;\r\naty_st_lcd(POWER_MANAGEMENT, pm, par);\r\npm = aty_ld_lcd(POWER_MANAGEMENT, par);\r\nudelay(10);\r\npm &= ~(PWR_BLON | AUTO_PWR_UP);\r\npm |= SUSPEND_NOW;\r\naty_st_lcd(POWER_MANAGEMENT, pm, par);\r\npm = aty_ld_lcd(POWER_MANAGEMENT, par);\r\nudelay(10);\r\npm |= PWR_MGT_ON;\r\naty_st_lcd(POWER_MANAGEMENT, pm, par);\r\ndo {\r\npm = aty_ld_lcd(POWER_MANAGEMENT, par);\r\nmdelay(1);\r\nif ((--timeout) == 0)\r\nbreak;\r\n} while ((pm & PWR_MGT_STATUS_MASK) != PWR_MGT_STATUS_SUSPEND);\r\n} else {\r\npm &= ~PWR_MGT_ON;\r\naty_st_lcd(POWER_MANAGEMENT, pm, par);\r\npm = aty_ld_lcd(POWER_MANAGEMENT, par);\r\nudelay(10);\r\npm &= ~SUSPEND_NOW;\r\npm |= (PWR_BLON | AUTO_PWR_UP);\r\naty_st_lcd(POWER_MANAGEMENT, pm, par);\r\npm = aty_ld_lcd(POWER_MANAGEMENT, par);\r\nudelay(10);\r\npm |= PWR_MGT_ON;\r\naty_st_lcd(POWER_MANAGEMENT, pm, par);\r\ndo {\r\npm = aty_ld_lcd(POWER_MANAGEMENT, par);\r\nmdelay(1);\r\nif ((--timeout) == 0)\r\nbreak;\r\n} while ((pm & PWR_MGT_STATUS_MASK) != 0);\r\n}\r\nmdelay(500);\r\nreturn timeout ? 0 : -EIO;\r\n}\r\nstatic int atyfb_pci_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pdev);\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nif (state.event == pdev->dev.power.power_state.event)\r\nreturn 0;\r\nconsole_lock();\r\nfb_set_suspend(info, 1);\r\nwait_for_idle(par);\r\naty_reset_engine(par);\r\natyfb_blank(FB_BLANK_POWERDOWN, info);\r\npar->asleep = 1;\r\npar->lock_blank = 1;\r\npci_save_state(pdev);\r\n#ifdef CONFIG_PPC_PMAC\r\nif (machine_is(powermac) && aty_power_mgmt(1, par)) {\r\npar->asleep = 0;\r\npar->lock_blank = 0;\r\natyfb_blank(FB_BLANK_UNBLANK, info);\r\nfb_set_suspend(info, 0);\r\nconsole_unlock();\r\nreturn -EIO;\r\n}\r\n#else\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\n#endif\r\nconsole_unlock();\r\npdev->dev.power.power_state = state;\r\nreturn 0;\r\n}\r\nstatic void aty_resume_chip(struct fb_info *info)\r\n{\r\nstruct atyfb_par *par = info->par;\r\naty_st_le32(MEM_CNTL, par->mem_cntl, par);\r\nif (par->pll_ops->resume_pll)\r\npar->pll_ops->resume_pll(info, &par->pll);\r\nif (par->aux_start)\r\naty_st_le32(BUS_CNTL,\r\naty_ld_le32(BUS_CNTL, par) | BUS_APER_REG_DIS, par);\r\n}\r\nstatic int atyfb_pci_resume(struct pci_dev *pdev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pdev);\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nif (pdev->dev.power.power_state.event == PM_EVENT_ON)\r\nreturn 0;\r\nconsole_lock();\r\n#ifdef CONFIG_PPC_PMAC\r\nif (machine_is(powermac) &&\r\npdev->dev.power.power_state.event == PM_EVENT_SUSPEND)\r\naty_power_mgmt(0, par);\r\n#endif\r\naty_resume_chip(info);\r\npar->asleep = 0;\r\natyfb_set_par(info);\r\nfb_set_suspend(info, 0);\r\npar->lock_blank = 0;\r\natyfb_blank(FB_BLANK_UNBLANK, info);\r\nconsole_unlock();\r\npdev->dev.power.power_state = PMSG_ON;\r\nreturn 0;\r\n}\r\nstatic int aty_bl_get_level_brightness(struct atyfb_par *par, int level)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(par->pdev);\r\nint atylevel;\r\natylevel = info->bl_curve[level] * FB_BACKLIGHT_MAX / MAX_LEVEL;\r\nif (atylevel < 0)\r\natylevel = 0;\r\nelse if (atylevel > MAX_LEVEL)\r\natylevel = MAX_LEVEL;\r\nreturn atylevel;\r\n}\r\nstatic int aty_bl_update_status(struct backlight_device *bd)\r\n{\r\nstruct atyfb_par *par = bl_get_data(bd);\r\nunsigned int reg = aty_ld_lcd(LCD_MISC_CNTL, par);\r\nint level;\r\nif (bd->props.power != FB_BLANK_UNBLANK ||\r\nbd->props.fb_blank != FB_BLANK_UNBLANK)\r\nlevel = 0;\r\nelse\r\nlevel = bd->props.brightness;\r\nreg |= (BLMOD_EN | BIASMOD_EN);\r\nif (level > 0) {\r\nreg &= ~BIAS_MOD_LEVEL_MASK;\r\nreg |= (aty_bl_get_level_brightness(par, level) << BIAS_MOD_LEVEL_SHIFT);\r\n} else {\r\nreg &= ~BIAS_MOD_LEVEL_MASK;\r\nreg |= (aty_bl_get_level_brightness(par, 0) << BIAS_MOD_LEVEL_SHIFT);\r\n}\r\naty_st_lcd(LCD_MISC_CNTL, reg, par);\r\nreturn 0;\r\n}\r\nstatic int aty_bl_get_brightness(struct backlight_device *bd)\r\n{\r\nreturn bd->props.brightness;\r\n}\r\nstatic void aty_bl_init(struct atyfb_par *par)\r\n{\r\nstruct backlight_properties props;\r\nstruct fb_info *info = pci_get_drvdata(par->pdev);\r\nstruct backlight_device *bd;\r\nchar name[12];\r\n#ifdef CONFIG_PMAC_BACKLIGHT\r\nif (!pmac_has_backlight_type("ati"))\r\nreturn;\r\n#endif\r\nsnprintf(name, sizeof(name), "atybl%d", info->node);\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = FB_BACKLIGHT_LEVELS - 1;\r\nbd = backlight_device_register(name, info->dev, par, &aty_bl_data,\r\n&props);\r\nif (IS_ERR(bd)) {\r\ninfo->bl_dev = NULL;\r\nprintk(KERN_WARNING "aty: Backlight registration failed\n");\r\ngoto error;\r\n}\r\ninfo->bl_dev = bd;\r\nfb_bl_default_curve(info, 0,\r\n0x3F * FB_BACKLIGHT_MAX / MAX_LEVEL,\r\n0xFF * FB_BACKLIGHT_MAX / MAX_LEVEL);\r\nbd->props.brightness = bd->props.max_brightness;\r\nbd->props.power = FB_BLANK_UNBLANK;\r\nbacklight_update_status(bd);\r\nprintk("aty: Backlight initialized (%s)\n", name);\r\nreturn;\r\nerror:\r\nreturn;\r\n}\r\nstatic void aty_bl_exit(struct backlight_device *bd)\r\n{\r\nbacklight_device_unregister(bd);\r\nprintk("aty: Backlight unloaded\n");\r\n}\r\nstatic void aty_calc_mem_refresh(struct atyfb_par *par, int xclk)\r\n{\r\nconst int ragepro_tbl[] = {\r\n44, 50, 55, 66, 75, 80, 100\r\n};\r\nconst int ragexl_tbl[] = {\r\n50, 66, 75, 83, 90, 95, 100, 105,\r\n110, 115, 120, 125, 133, 143, 166\r\n};\r\nconst int *refresh_tbl;\r\nint i, size;\r\nif (M64_HAS(XL_MEM)) {\r\nrefresh_tbl = ragexl_tbl;\r\nsize = ARRAY_SIZE(ragexl_tbl);\r\n} else {\r\nrefresh_tbl = ragepro_tbl;\r\nsize = ARRAY_SIZE(ragepro_tbl);\r\n}\r\nfor (i = 0; i < size; i++) {\r\nif (xclk < refresh_tbl[i])\r\nbreak;\r\n}\r\npar->mem_refresh_rate = i;\r\n}\r\nstatic int atyfb_get_timings_from_lcd(struct atyfb_par *par,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nint ret = -EINVAL;\r\nif (par->lcd_table != 0 && (aty_ld_lcd(LCD_GEN_CNTL, par) & LCD_ON)) {\r\n*var = default_var;\r\nvar->xres = var->xres_virtual = par->lcd_hdisp;\r\nvar->right_margin = par->lcd_right_margin;\r\nvar->left_margin = par->lcd_hblank_len -\r\n(par->lcd_right_margin + par->lcd_hsync_dly +\r\npar->lcd_hsync_len);\r\nvar->hsync_len = par->lcd_hsync_len + par->lcd_hsync_dly;\r\nvar->yres = var->yres_virtual = par->lcd_vdisp;\r\nvar->lower_margin = par->lcd_lower_margin;\r\nvar->upper_margin = par->lcd_vblank_len -\r\n(par->lcd_lower_margin + par->lcd_vsync_len);\r\nvar->vsync_len = par->lcd_vsync_len;\r\nvar->pixclock = par->lcd_pixclock;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int aty_init(struct fb_info *info)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nconst char *ramname = NULL, *xtal;\r\nint gtb_memsize, has_var = 0;\r\nstruct fb_var_screeninfo var;\r\nint ret;\r\ninit_waitqueue_head(&par->vblank.wait);\r\nspin_lock_init(&par->int_lock);\r\n#ifdef CONFIG_FB_ATY_GX\r\nif (!M64_HAS(INTEGRATED)) {\r\nu32 stat0;\r\nu8 dac_type, dac_subtype, clk_type;\r\nstat0 = aty_ld_le32(CNFG_STAT0, par);\r\npar->bus_type = (stat0 >> 0) & 0x07;\r\npar->ram_type = (stat0 >> 3) & 0x07;\r\nramname = aty_gx_ram[par->ram_type];\r\ndac_type = (aty_ld_le32(DAC_CNTL, par) >> 16) & 0x07;\r\n#ifdef CONFIG_ATARI\r\nclk_type = CLK_ATI18818_1;\r\ndac_type = (stat0 >> 9) & 0x07;\r\nif (dac_type == 0x07)\r\ndac_subtype = DAC_ATT20C408;\r\nelse\r\ndac_subtype = (aty_ld_8(SCRATCH_REG1 + 1, par) & 0xF0) | dac_type;\r\n#else\r\ndac_type = DAC_IBMRGB514;\r\ndac_subtype = DAC_IBMRGB514;\r\nclk_type = CLK_IBMRGB514;\r\n#endif\r\nswitch (dac_subtype) {\r\ncase DAC_IBMRGB514:\r\npar->dac_ops = &aty_dac_ibm514;\r\nbreak;\r\n#ifdef CONFIG_ATARI\r\ncase DAC_ATI68860_B:\r\ncase DAC_ATI68860_C:\r\npar->dac_ops = &aty_dac_ati68860b;\r\nbreak;\r\ncase DAC_ATT20C408:\r\ncase DAC_ATT21C498:\r\npar->dac_ops = &aty_dac_att21c498;\r\nbreak;\r\n#endif\r\ndefault:\r\nPRINTKI("aty_init: DAC type not implemented yet!\n");\r\npar->dac_ops = &aty_dac_unsupported;\r\nbreak;\r\n}\r\nswitch (clk_type) {\r\n#ifdef CONFIG_ATARI\r\ncase CLK_ATI18818_1:\r\npar->pll_ops = &aty_pll_ati18818_1;\r\nbreak;\r\n#else\r\ncase CLK_IBMRGB514:\r\npar->pll_ops = &aty_pll_ibm514;\r\nbreak;\r\n#endif\r\n#if 0\r\ncase CLK_STG1703:\r\npar->pll_ops = &aty_pll_stg1703;\r\nbreak;\r\ncase CLK_CH8398:\r\npar->pll_ops = &aty_pll_ch8398;\r\nbreak;\r\ncase CLK_ATT20C408:\r\npar->pll_ops = &aty_pll_att20c408;\r\nbreak;\r\n#endif\r\ndefault:\r\nPRINTKI("aty_init: CLK type not implemented yet!");\r\npar->pll_ops = &aty_pll_unsupported;\r\nbreak;\r\n}\r\n}\r\n#endif\r\n#ifdef CONFIG_FB_ATY_CT\r\nif (M64_HAS(INTEGRATED)) {\r\npar->dac_ops = &aty_dac_ct;\r\npar->pll_ops = &aty_pll_ct;\r\npar->bus_type = PCI;\r\npar->ram_type = (aty_ld_le32(CNFG_STAT0, par) & 0x07);\r\nif (M64_HAS(XL_MEM))\r\nramname = aty_xl_ram[par->ram_type];\r\nelse\r\nramname = aty_ct_ram[par->ram_type];\r\nif (par->pll_limits.mclk == 67 && par->ram_type < SDRAM)\r\npar->pll_limits.mclk = 63;\r\nif (M64_HAS(MOBIL_BUS) && par->ram_type == SDRAM32)\r\npar->pll_limits.xclk = (par->pll_limits.xclk + 1) >> 1;\r\n}\r\n#endif\r\n#ifdef CONFIG_PPC_PMAC\r\nif (of_machine_is_compatible("PowerBook2,1")) {\r\npar->pll_limits.mclk = 70;\r\npar->pll_limits.xclk = 53;\r\n}\r\n#endif\r\nif (pll)\r\npar->pll_limits.pll_max = pll;\r\nif (mclk)\r\npar->pll_limits.mclk = mclk;\r\nif (xclk)\r\npar->pll_limits.xclk = xclk;\r\naty_calc_mem_refresh(par, par->pll_limits.xclk);\r\npar->pll_per = 1000000/par->pll_limits.pll_max;\r\npar->mclk_per = 1000000/par->pll_limits.mclk;\r\npar->xclk_per = 1000000/par->pll_limits.xclk;\r\npar->ref_clk_per = 1000000000000ULL / 14318180;\r\nxtal = "14.31818";\r\n#ifdef CONFIG_FB_ATY_CT\r\nif (M64_HAS(GTB_DSP)) {\r\nu8 pll_ref_div = aty_ld_pll_ct(PLL_REF_DIV, par);\r\nif (pll_ref_div) {\r\nint diff1, diff2;\r\ndiff1 = 510 * 14 / pll_ref_div - par->pll_limits.pll_max;\r\ndiff2 = 510 * 29 / pll_ref_div - par->pll_limits.pll_max;\r\nif (diff1 < 0)\r\ndiff1 = -diff1;\r\nif (diff2 < 0)\r\ndiff2 = -diff2;\r\nif (diff2 < diff1) {\r\npar->ref_clk_per = 1000000000000ULL / 29498928;\r\nxtal = "29.498928";\r\n}\r\n}\r\n}\r\n#endif\r\naty_get_crtc(par, &par->saved_crtc);\r\nif (par->pll_ops->get_pll)\r\npar->pll_ops->get_pll(info, &par->saved_pll);\r\npar->mem_cntl = aty_ld_le32(MEM_CNTL, par);\r\ngtb_memsize = M64_HAS(GTB_DSP);\r\nif (gtb_memsize)\r\nswitch (par->mem_cntl & 0xF) {\r\ncase MEM_SIZE_512K:\r\ninfo->fix.smem_len = 0x80000;\r\nbreak;\r\ncase MEM_SIZE_1M:\r\ninfo->fix.smem_len = 0x100000;\r\nbreak;\r\ncase MEM_SIZE_2M_GTB:\r\ninfo->fix.smem_len = 0x200000;\r\nbreak;\r\ncase MEM_SIZE_4M_GTB:\r\ninfo->fix.smem_len = 0x400000;\r\nbreak;\r\ncase MEM_SIZE_6M_GTB:\r\ninfo->fix.smem_len = 0x600000;\r\nbreak;\r\ncase MEM_SIZE_8M_GTB:\r\ninfo->fix.smem_len = 0x800000;\r\nbreak;\r\ndefault:\r\ninfo->fix.smem_len = 0x80000;\r\n} else\r\nswitch (par->mem_cntl & MEM_SIZE_ALIAS) {\r\ncase MEM_SIZE_512K:\r\ninfo->fix.smem_len = 0x80000;\r\nbreak;\r\ncase MEM_SIZE_1M:\r\ninfo->fix.smem_len = 0x100000;\r\nbreak;\r\ncase MEM_SIZE_2M:\r\ninfo->fix.smem_len = 0x200000;\r\nbreak;\r\ncase MEM_SIZE_4M:\r\ninfo->fix.smem_len = 0x400000;\r\nbreak;\r\ncase MEM_SIZE_6M:\r\ninfo->fix.smem_len = 0x600000;\r\nbreak;\r\ncase MEM_SIZE_8M:\r\ninfo->fix.smem_len = 0x800000;\r\nbreak;\r\ndefault:\r\ninfo->fix.smem_len = 0x80000;\r\n}\r\nif (M64_HAS(MAGIC_VRAM_SIZE)) {\r\nif (aty_ld_le32(CNFG_STAT1, par) & 0x40000000)\r\ninfo->fix.smem_len += 0x400000;\r\n}\r\nif (vram) {\r\ninfo->fix.smem_len = vram * 1024;\r\npar->mem_cntl &= ~(gtb_memsize ? 0xF : MEM_SIZE_ALIAS);\r\nif (info->fix.smem_len <= 0x80000)\r\npar->mem_cntl |= MEM_SIZE_512K;\r\nelse if (info->fix.smem_len <= 0x100000)\r\npar->mem_cntl |= MEM_SIZE_1M;\r\nelse if (info->fix.smem_len <= 0x200000)\r\npar->mem_cntl |= gtb_memsize ? MEM_SIZE_2M_GTB : MEM_SIZE_2M;\r\nelse if (info->fix.smem_len <= 0x400000)\r\npar->mem_cntl |= gtb_memsize ? MEM_SIZE_4M_GTB : MEM_SIZE_4M;\r\nelse if (info->fix.smem_len <= 0x600000)\r\npar->mem_cntl |= gtb_memsize ? MEM_SIZE_6M_GTB : MEM_SIZE_6M;\r\nelse\r\npar->mem_cntl |= gtb_memsize ? MEM_SIZE_8M_GTB : MEM_SIZE_8M;\r\naty_st_le32(MEM_CNTL, par->mem_cntl, par);\r\n}\r\nif (M64_HAS(GX)) {\r\ninfo->fix.mmio_len = 0x400;\r\ninfo->fix.accel = FB_ACCEL_ATI_MACH64GX;\r\n} else if (M64_HAS(CT)) {\r\ninfo->fix.mmio_len = 0x400;\r\ninfo->fix.accel = FB_ACCEL_ATI_MACH64CT;\r\n} else if (M64_HAS(VT)) {\r\ninfo->fix.mmio_start -= 0x400;\r\ninfo->fix.mmio_len = 0x800;\r\ninfo->fix.accel = FB_ACCEL_ATI_MACH64VT;\r\n} else {\r\ninfo->fix.mmio_start -= 0x400;\r\ninfo->fix.mmio_len = 0x800;\r\ninfo->fix.accel = FB_ACCEL_ATI_MACH64GT;\r\n}\r\nPRINTKI("%d%c %s, %s MHz XTAL, %d MHz PLL, %d Mhz MCLK, %d MHz XCLK\n",\r\ninfo->fix.smem_len == 0x80000 ? 512 : (info->fix.smem_len>>20),\r\ninfo->fix.smem_len == 0x80000 ? 'K' : 'M', ramname, xtal,\r\npar->pll_limits.pll_max, par->pll_limits.mclk,\r\npar->pll_limits.xclk);\r\n#if defined(DEBUG) && defined(CONFIG_FB_ATY_CT)\r\nif (M64_HAS(INTEGRATED)) {\r\nint i;\r\nprintk("debug atyfb: BUS_CNTL DAC_CNTL MEM_CNTL "\r\n"EXT_MEM_CNTL CRTC_GEN_CNTL DSP_CONFIG "\r\n"DSP_ON_OFF CLOCK_CNTL\n"\r\n"debug atyfb: %08x %08x %08x "\r\n"%08x %08x %08x "\r\n"%08x %08x\n"\r\n"debug atyfb: PLL",\r\naty_ld_le32(BUS_CNTL, par),\r\naty_ld_le32(DAC_CNTL, par),\r\naty_ld_le32(MEM_CNTL, par),\r\naty_ld_le32(EXT_MEM_CNTL, par),\r\naty_ld_le32(CRTC_GEN_CNTL, par),\r\naty_ld_le32(DSP_CONFIG, par),\r\naty_ld_le32(DSP_ON_OFF, par),\r\naty_ld_le32(CLOCK_CNTL, par));\r\nfor (i = 0; i < 40; i++)\r\nprintk(" %02x", aty_ld_pll_ct(i, par));\r\nprintk("\n");\r\n}\r\n#endif\r\nif (par->pll_ops->init_pll)\r\npar->pll_ops->init_pll(info, &par->pll);\r\nif (par->pll_ops->resume_pll)\r\npar->pll_ops->resume_pll(info, &par->pll);\r\nif (!par->aux_start &&\r\n(info->fix.smem_len == 0x800000 ||\r\n(par->bus_type == ISA && info->fix.smem_len == 0x400000)))\r\ninfo->fix.smem_len -= GUI_RESERVE;\r\nif (par->aux_start)\r\naty_st_le32(BUS_CNTL, aty_ld_le32(BUS_CNTL, par) |\r\nBUS_APER_REG_DIS, par);\r\n#ifdef CONFIG_MTRR\r\npar->mtrr_aper = -1;\r\npar->mtrr_reg = -1;\r\nif (!nomtrr) {\r\npar->mtrr_aper = mtrr_add(par->res_start, par->res_size,\r\nMTRR_TYPE_WRCOMB, 1);\r\nif (par->mtrr_aper >= 0 && !par->aux_start) {\r\npar->mtrr_reg = mtrr_add(par->res_start + 0x800000 -\r\nGUI_RESERVE, GUI_RESERVE,\r\nMTRR_TYPE_UNCACHABLE, 1);\r\nif (par->mtrr_reg < 0) {\r\nmtrr_del(par->mtrr_aper, 0, 0);\r\npar->mtrr_aper = -1;\r\n}\r\n}\r\n}\r\n#endif\r\ninfo->fbops = &atyfb_ops;\r\ninfo->pseudo_palette = par->pseudo_palette;\r\ninfo->flags = FBINFO_DEFAULT |\r\nFBINFO_HWACCEL_IMAGEBLIT |\r\nFBINFO_HWACCEL_FILLRECT |\r\nFBINFO_HWACCEL_COPYAREA |\r\nFBINFO_HWACCEL_YPAN;\r\n#ifdef CONFIG_PMAC_BACKLIGHT\r\nif (M64_HAS(G3_PB_1_1) && of_machine_is_compatible("PowerBook1,1")) {\r\naty_st_lcd(POWER_MANAGEMENT, aty_ld_lcd(POWER_MANAGEMENT, par) |\r\nUSE_F32KHZ | TRISTATE_MEM_EN, par);\r\n} else\r\n#endif\r\nif (M64_HAS(MOBIL_BUS) && backlight) {\r\n#ifdef CONFIG_FB_ATY_BACKLIGHT\r\naty_bl_init(par);\r\n#endif\r\n}\r\nmemset(&var, 0, sizeof(var));\r\n#ifdef CONFIG_PPC\r\nif (machine_is(powermac)) {\r\nif (mode) {\r\nif (mac_find_mode(&var, info, mode, 8))\r\nhas_var = 1;\r\n} else {\r\nif (default_vmode == VMODE_CHOOSE) {\r\nint sense;\r\nif (M64_HAS(G3_PB_1024x768))\r\ndefault_vmode = VMODE_1024_768_60;\r\nelse if (of_machine_is_compatible("iMac"))\r\ndefault_vmode = VMODE_1024_768_75;\r\nelse if (of_machine_is_compatible("PowerBook2,1"))\r\ndefault_vmode = VMODE_800_600_60;\r\nelse\r\ndefault_vmode = VMODE_640_480_67;\r\nsense = read_aty_sense(par);\r\nPRINTKI("monitor sense=%x, mode %d\n",\r\nsense, mac_map_monitor_sense(sense));\r\n}\r\nif (default_vmode <= 0 || default_vmode > VMODE_MAX)\r\ndefault_vmode = VMODE_640_480_60;\r\nif (default_cmode < CMODE_8 || default_cmode > CMODE_32)\r\ndefault_cmode = CMODE_8;\r\nif (!mac_vmode_to_var(default_vmode, default_cmode,\r\n&var))\r\nhas_var = 1;\r\n}\r\n}\r\n#endif\r\n#if defined(__i386__) && defined(CONFIG_FB_ATY_GENERIC_LCD)\r\nif (!atyfb_get_timings_from_lcd(par, &var))\r\nhas_var = 1;\r\n#endif\r\nif (mode && fb_find_mode(&var, info, mode, NULL, 0, &defmode, 8))\r\nhas_var = 1;\r\nif (!has_var)\r\nvar = default_var;\r\nif (noaccel)\r\nvar.accel_flags &= ~FB_ACCELF_TEXT;\r\nelse\r\nvar.accel_flags |= FB_ACCELF_TEXT;\r\nif (comp_sync != -1) {\r\nif (!comp_sync)\r\nvar.sync &= ~FB_SYNC_COMP_HIGH_ACT;\r\nelse\r\nvar.sync |= FB_SYNC_COMP_HIGH_ACT;\r\n}\r\nif (var.yres == var.yres_virtual) {\r\nu32 videoram = (info->fix.smem_len - (PAGE_SIZE << 2));\r\nvar.yres_virtual = ((videoram * 8) / var.bits_per_pixel) / var.xres_virtual;\r\nif (var.yres_virtual < var.yres)\r\nvar.yres_virtual = var.yres;\r\n}\r\nret = atyfb_check_var(&var, info);\r\nif (ret) {\r\nPRINTKE("can't set default video mode\n");\r\ngoto aty_init_exit;\r\n}\r\n#ifdef CONFIG_FB_ATY_CT\r\nif (!noaccel && M64_HAS(INTEGRATED))\r\naty_init_cursor(info);\r\n#endif\r\ninfo->var = var;\r\nret = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (ret < 0)\r\ngoto aty_init_exit;\r\nret = register_framebuffer(info);\r\nif (ret < 0) {\r\nfb_dealloc_cmap(&info->cmap);\r\ngoto aty_init_exit;\r\n}\r\nfb_list = info;\r\nPRINTKI("fb%d: %s frame buffer device on %s\n",\r\ninfo->node, info->fix.id, par->bus_type == ISA ? "ISA" : "PCI");\r\nreturn 0;\r\naty_init_exit:\r\naty_set_crtc(par, &par->saved_crtc);\r\npar->pll_ops->set_pll(info, &par->saved_pll);\r\n#ifdef CONFIG_MTRR\r\nif (par->mtrr_reg >= 0) {\r\nmtrr_del(par->mtrr_reg, 0, 0);\r\npar->mtrr_reg = -1;\r\n}\r\nif (par->mtrr_aper >= 0) {\r\nmtrr_del(par->mtrr_aper, 0, 0);\r\npar->mtrr_aper = -1;\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int store_video_par(char *video_str, unsigned char m64_num)\r\n{\r\nchar *p;\r\nunsigned long vmembase, size, guiregbase;\r\nPRINTKI("store_video_par() '%s' \n", video_str);\r\nif (!(p = strsep(&video_str, ";")) || !*p)\r\ngoto mach64_invalid;\r\nvmembase = simple_strtoul(p, NULL, 0);\r\nif (!(p = strsep(&video_str, ";")) || !*p)\r\ngoto mach64_invalid;\r\nsize = simple_strtoul(p, NULL, 0);\r\nif (!(p = strsep(&video_str, ";")) || !*p)\r\ngoto mach64_invalid;\r\nguiregbase = simple_strtoul(p, NULL, 0);\r\nphys_vmembase[m64_num] = vmembase;\r\nphys_size[m64_num] = size;\r\nphys_guiregbase[m64_num] = guiregbase;\r\nPRINTKI("stored them all: $%08lX $%08lX $%08lX \n", vmembase, size,\r\nguiregbase);\r\nreturn 0;\r\nmach64_invalid:\r\nphys_vmembase[m64_num] = 0;\r\nreturn -1;\r\n}\r\nstatic int atyfb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nu32 gen_cntl;\r\nif (par->lock_blank || par->asleep)\r\nreturn 0;\r\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\r\nif (par->lcd_table && blank > FB_BLANK_NORMAL &&\r\n(aty_ld_lcd(LCD_GEN_CNTL, par) & LCD_ON)) {\r\nu32 pm = aty_ld_lcd(POWER_MANAGEMENT, par);\r\npm &= ~PWR_BLON;\r\naty_st_lcd(POWER_MANAGEMENT, pm, par);\r\n}\r\n#endif\r\ngen_cntl = aty_ld_le32(CRTC_GEN_CNTL, par);\r\ngen_cntl &= ~0x400004c;\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\ngen_cntl |= 0x4000040;\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ngen_cntl |= 0x4000048;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ngen_cntl |= 0x4000044;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\ngen_cntl |= 0x400004c;\r\nbreak;\r\n}\r\naty_st_le32(CRTC_GEN_CNTL, gen_cntl, par);\r\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\r\nif (par->lcd_table && blank <= FB_BLANK_NORMAL &&\r\n(aty_ld_lcd(LCD_GEN_CNTL, par) & LCD_ON)) {\r\nu32 pm = aty_ld_lcd(POWER_MANAGEMENT, par);\r\npm |= PWR_BLON;\r\naty_st_lcd(POWER_MANAGEMENT, pm, par);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void aty_st_pal(u_int regno, u_int red, u_int green, u_int blue,\r\nconst struct atyfb_par *par)\r\n{\r\naty_st_8(DAC_W_INDEX, regno, par);\r\naty_st_8(DAC_DATA, red, par);\r\naty_st_8(DAC_DATA, green, par);\r\naty_st_8(DAC_DATA, blue, par);\r\n}\r\nstatic int atyfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nint i, depth;\r\nu32 *pal = info->pseudo_palette;\r\ndepth = info->var.bits_per_pixel;\r\nif (depth == 16)\r\ndepth = (info->var.green.length == 5) ? 15 : 16;\r\nif (par->asleep)\r\nreturn 0;\r\nif (regno > 255 ||\r\n(depth == 16 && regno > 63) ||\r\n(depth == 15 && regno > 31))\r\nreturn 1;\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\npar->palette[regno].red = red;\r\npar->palette[regno].green = green;\r\npar->palette[regno].blue = blue;\r\nif (regno < 16) {\r\nswitch (depth) {\r\ncase 15:\r\npal[regno] = (regno << 10) | (regno << 5) | regno;\r\nbreak;\r\ncase 16:\r\npal[regno] = (regno << 11) | (regno << 5) | regno;\r\nbreak;\r\ncase 24:\r\npal[regno] = (regno << 16) | (regno << 8) | regno;\r\nbreak;\r\ncase 32:\r\ni = (regno << 8) | regno;\r\npal[regno] = (i << 16) | i;\r\nbreak;\r\n}\r\n}\r\ni = aty_ld_8(DAC_CNTL, par) & 0xfc;\r\nif (M64_HAS(EXTRA_BRIGHT))\r\ni |= 0x2;\r\naty_st_8(DAC_CNTL, i, par);\r\naty_st_8(DAC_MASK, 0xff, par);\r\nif (M64_HAS(INTEGRATED)) {\r\nif (depth == 16) {\r\nif (regno < 32)\r\naty_st_pal(regno << 3, red,\r\npar->palette[regno << 1].green,\r\nblue, par);\r\nred = par->palette[regno >> 1].red;\r\nblue = par->palette[regno >> 1].blue;\r\nregno <<= 2;\r\n} else if (depth == 15) {\r\nregno <<= 3;\r\nfor (i = 0; i < 8; i++)\r\naty_st_pal(regno + i, red, green, blue, par);\r\n}\r\n}\r\naty_st_pal(regno, red, green, blue, par);\r\nreturn 0;\r\n}\r\nstatic int atyfb_setup_sparc(struct pci_dev *pdev, struct fb_info *info,\r\nunsigned long addr)\r\n{\r\nstruct atyfb_par *par = info->par;\r\nstruct device_node *dp;\r\nu32 mem, chip_id;\r\nint i, j, ret;\r\npar->ati_regbase = (void *)addr + 0x7ffc00UL;\r\ninfo->fix.mmio_start = addr + 0x7ffc00UL;\r\ninfo->screen_base = (char *) (addr + 0x800000UL);\r\ninfo->fix.smem_start = addr + 0x800000UL;\r\nfor (i = 0; i < 6 && pdev->resource[i].start; i++)\r\n;\r\nj = i + 4;\r\npar->mmap_map = kcalloc(j, sizeof(*par->mmap_map), GFP_ATOMIC);\r\nif (!par->mmap_map) {\r\nPRINTKE("atyfb_setup_sparc() can't alloc mmap_map\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0, j = 2; i < 6 && pdev->resource[i].start; i++) {\r\nstruct resource *rp = &pdev->resource[i];\r\nint io, breg = PCI_BASE_ADDRESS_0 + (i << 2);\r\nunsigned long base;\r\nu32 size, pbase;\r\nbase = rp->start;\r\nio = (rp->flags & IORESOURCE_IO);\r\nsize = rp->end - base + 1;\r\npci_read_config_dword(pdev, breg, &pbase);\r\nif (io)\r\nsize &= ~1;\r\nif (base == addr) {\r\npar->mmap_map[j].voff = (pbase + 0x10000000) & PAGE_MASK;\r\npar->mmap_map[j].poff = base & PAGE_MASK;\r\npar->mmap_map[j].size = (size + ~PAGE_MASK) & PAGE_MASK;\r\npar->mmap_map[j].prot_mask = _PAGE_CACHE;\r\npar->mmap_map[j].prot_flag = _PAGE_E;\r\nj++;\r\n}\r\nif (base == addr) {\r\npar->mmap_map[j].voff = (pbase + 0x800000) & PAGE_MASK;\r\npar->mmap_map[j].poff = (base + 0x800000) & PAGE_MASK;\r\npar->mmap_map[j].size = 0x800000;\r\npar->mmap_map[j].prot_mask = _PAGE_CACHE;\r\npar->mmap_map[j].prot_flag = _PAGE_E | _PAGE_IE;\r\nsize -= 0x800000;\r\nj++;\r\n}\r\npar->mmap_map[j].voff = pbase & PAGE_MASK;\r\npar->mmap_map[j].poff = base & PAGE_MASK;\r\npar->mmap_map[j].size = (size + ~PAGE_MASK) & PAGE_MASK;\r\npar->mmap_map[j].prot_mask = _PAGE_CACHE;\r\npar->mmap_map[j].prot_flag = _PAGE_E;\r\nj++;\r\n}\r\nret = correct_chipset(par);\r\nif (ret)\r\nreturn ret;\r\nif (IS_XL(pdev->device)) {\r\nmem = aty_ld_le32(MEM_CNTL, par);\r\nchip_id = aty_ld_le32(CNFG_CHIP_ID, par);\r\nif (((chip_id & CFG_CHIP_TYPE) == VT_CHIP_ID) && !((chip_id >> 24) & 1)) {\r\nswitch (mem & 0x0f) {\r\ncase 3:\r\nmem = (mem & ~(0x0f)) | 2;\r\nbreak;\r\ncase 7:\r\nmem = (mem & ~(0x0f)) | 3;\r\nbreak;\r\ncase 9:\r\nmem = (mem & ~(0x0f)) | 4;\r\nbreak;\r\ncase 11:\r\nmem = (mem & ~(0x0f)) | 5;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif ((aty_ld_le32(CNFG_STAT0, par) & 7) >= SDRAM)\r\nmem &= ~(0x00700000);\r\n}\r\nmem &= ~(0xcf80e000);\r\naty_st_le32(MEM_CNTL, mem, par);\r\n}\r\ndp = pci_device_to_OF_node(pdev);\r\nif (dp == of_console_device) {\r\nstruct fb_var_screeninfo *var = &default_var;\r\nunsigned int N, P, Q, M, T, R;\r\nu32 v_total, h_total;\r\nstruct crtc crtc;\r\nu8 pll_regs[16];\r\nu8 clock_cntl;\r\ncrtc.vxres = of_getintprop_default(dp, "width", 1024);\r\ncrtc.vyres = of_getintprop_default(dp, "height", 768);\r\nvar->bits_per_pixel = of_getintprop_default(dp, "depth", 8);\r\nvar->xoffset = var->yoffset = 0;\r\ncrtc.h_tot_disp = aty_ld_le32(CRTC_H_TOTAL_DISP, par);\r\ncrtc.h_sync_strt_wid = aty_ld_le32(CRTC_H_SYNC_STRT_WID, par);\r\ncrtc.v_tot_disp = aty_ld_le32(CRTC_V_TOTAL_DISP, par);\r\ncrtc.v_sync_strt_wid = aty_ld_le32(CRTC_V_SYNC_STRT_WID, par);\r\ncrtc.gen_cntl = aty_ld_le32(CRTC_GEN_CNTL, par);\r\naty_crtc_to_var(&crtc, var);\r\nh_total = var->xres + var->right_margin + var->hsync_len + var->left_margin;\r\nv_total = var->yres + var->lower_margin + var->vsync_len + var->upper_margin;\r\nclock_cntl = aty_ld_8(CLOCK_CNTL, par);\r\nfor (i = 0; i < 16; i++)\r\npll_regs[i] = aty_ld_pll_ct(i, par);\r\nM = pll_regs[2];\r\nN = pll_regs[7 + (clock_cntl & 3)];\r\nP = 1 << (pll_regs[6] >> ((clock_cntl & 3) << 1));\r\nQ = N / P;\r\nif (IS_XL(pdev->device))\r\nR = 29498;\r\nelse\r\nR = 14318;\r\nT = 2 * Q * R / M;\r\ndefault_var.pixclock = 1000000000 / T;\r\n}\r\nreturn 0;\r\n}\r\nstatic void aty_init_lcd(struct atyfb_par *par, u32 bios_base)\r\n{\r\nu32 driv_inf_tab, sig;\r\nu16 lcd_ofs;\r\ndriv_inf_tab = bios_base + *((u16 *)(bios_base+0x78));\r\nsig = *(u32 *)driv_inf_tab;\r\nif ((sig == 0x54504c24) ||\r\n(sig == 0x544d5224) ||\r\n(sig == 0x54435824) ||\r\n(sig == 0x544c5824)) {\r\nPRINTKI("BIOS contains driver information table.\n");\r\nlcd_ofs = *(u16 *)(driv_inf_tab + 10);\r\npar->lcd_table = 0;\r\nif (lcd_ofs != 0)\r\npar->lcd_table = bios_base + lcd_ofs;\r\n}\r\nif (par->lcd_table != 0) {\r\nchar model[24];\r\nchar strbuf[16];\r\nchar refresh_rates_buf[100];\r\nint id, tech, f, i, m, default_refresh_rate;\r\nchar *txtcolour;\r\nchar *txtmonitor;\r\nchar *txtdual;\r\nchar *txtformat;\r\nu16 width, height, panel_type, refresh_rates;\r\nu16 *lcdmodeptr;\r\nu32 format;\r\nu8 lcd_refresh_rates[16] = { 50, 56, 60, 67, 70, 72, 75, 76, 85,\r\n90, 100, 120, 140, 150, 160, 200 };\r\nid = *(u8 *)par->lcd_table;\r\nstrncpy(model, (char *)par->lcd_table+1, 24);\r\nmodel[23] = 0;\r\nwidth = par->lcd_width = *(u16 *)(par->lcd_table+25);\r\nheight = par->lcd_height = *(u16 *)(par->lcd_table+27);\r\npanel_type = *(u16 *)(par->lcd_table+29);\r\nif (panel_type & 1)\r\ntxtcolour = "colour";\r\nelse\r\ntxtcolour = "monochrome";\r\nif (panel_type & 2)\r\ntxtdual = "dual (split) ";\r\nelse\r\ntxtdual = "";\r\ntech = (panel_type >> 2) & 63;\r\nswitch (tech) {\r\ncase 0:\r\ntxtmonitor = "passive matrix";\r\nbreak;\r\ncase 1:\r\ntxtmonitor = "active matrix";\r\nbreak;\r\ncase 2:\r\ntxtmonitor = "active addressed STN";\r\nbreak;\r\ncase 3:\r\ntxtmonitor = "EL";\r\nbreak;\r\ncase 4:\r\ntxtmonitor = "plasma";\r\nbreak;\r\ndefault:\r\ntxtmonitor = "unknown";\r\n}\r\nformat = *(u32 *)(par->lcd_table+57);\r\nif (tech == 0 || tech == 2) {\r\nswitch (format & 7) {\r\ncase 0:\r\ntxtformat = "12 bit interface";\r\nbreak;\r\ncase 1:\r\ntxtformat = "16 bit interface";\r\nbreak;\r\ncase 2:\r\ntxtformat = "24 bit interface";\r\nbreak;\r\ndefault:\r\ntxtformat = "unknown format";\r\n}\r\n} else {\r\nswitch (format & 7) {\r\ncase 0:\r\ntxtformat = "8 colours";\r\nbreak;\r\ncase 1:\r\ntxtformat = "512 colours";\r\nbreak;\r\ncase 2:\r\ntxtformat = "4096 colours";\r\nbreak;\r\ncase 4:\r\ntxtformat = "262144 colours (LT mode)";\r\nbreak;\r\ncase 5:\r\ntxtformat = "16777216 colours";\r\nbreak;\r\ncase 6:\r\ntxtformat = "262144 colours (FDPI-2 mode)";\r\nbreak;\r\ndefault:\r\ntxtformat = "unknown format";\r\n}\r\n}\r\nPRINTKI("%s%s %s monitor detected: %s\n",\r\ntxtdual, txtcolour, txtmonitor, model);\r\nPRINTKI(" id=%d, %dx%d pixels, %s\n",\r\nid, width, height, txtformat);\r\nrefresh_rates_buf[0] = 0;\r\nrefresh_rates = *(u16 *)(par->lcd_table+62);\r\nm = 1;\r\nf = 0;\r\nfor (i = 0; i < 16; i++) {\r\nif (refresh_rates & m) {\r\nif (f == 0) {\r\nsprintf(strbuf, "%d",\r\nlcd_refresh_rates[i]);\r\nf++;\r\n} else {\r\nsprintf(strbuf, ",%d",\r\nlcd_refresh_rates[i]);\r\n}\r\nstrcat(refresh_rates_buf, strbuf);\r\n}\r\nm = m << 1;\r\n}\r\ndefault_refresh_rate = (*(u8 *)(par->lcd_table+61) & 0xf0) >> 4;\r\nPRINTKI(" supports refresh rates [%s], default %d Hz\n",\r\nrefresh_rates_buf, lcd_refresh_rates[default_refresh_rate]);\r\npar->lcd_refreshrate = lcd_refresh_rates[default_refresh_rate];\r\nlcdmodeptr = (u16 *)(par->lcd_table + 64);\r\nwhile (*lcdmodeptr != 0) {\r\nu32 modeptr;\r\nu16 mwidth, mheight, lcd_hsync_start, lcd_vsync_start;\r\nmodeptr = bios_base + *lcdmodeptr;\r\nmwidth = *((u16 *)(modeptr+0));\r\nmheight = *((u16 *)(modeptr+2));\r\nif (mwidth == width && mheight == height) {\r\npar->lcd_pixclock = 100000000 / *((u16 *)(modeptr+9));\r\npar->lcd_htotal = *((u16 *)(modeptr+17)) & 511;\r\npar->lcd_hdisp = *((u16 *)(modeptr+19)) & 511;\r\nlcd_hsync_start = *((u16 *)(modeptr+21)) & 511;\r\npar->lcd_hsync_dly = (*((u16 *)(modeptr+21)) >> 9) & 7;\r\npar->lcd_hsync_len = *((u8 *)(modeptr+23)) & 63;\r\npar->lcd_vtotal = *((u16 *)(modeptr+24)) & 2047;\r\npar->lcd_vdisp = *((u16 *)(modeptr+26)) & 2047;\r\nlcd_vsync_start = *((u16 *)(modeptr+28)) & 2047;\r\npar->lcd_vsync_len = (*((u16 *)(modeptr+28)) >> 11) & 31;\r\npar->lcd_htotal = (par->lcd_htotal + 1) * 8;\r\npar->lcd_hdisp = (par->lcd_hdisp + 1) * 8;\r\nlcd_hsync_start = (lcd_hsync_start + 1) * 8;\r\npar->lcd_hsync_len = par->lcd_hsync_len * 8;\r\npar->lcd_vtotal++;\r\npar->lcd_vdisp++;\r\nlcd_vsync_start++;\r\npar->lcd_right_margin = lcd_hsync_start - par->lcd_hdisp;\r\npar->lcd_lower_margin = lcd_vsync_start - par->lcd_vdisp;\r\npar->lcd_hblank_len = par->lcd_htotal - par->lcd_hdisp;\r\npar->lcd_vblank_len = par->lcd_vtotal - par->lcd_vdisp;\r\nbreak;\r\n}\r\nlcdmodeptr++;\r\n}\r\nif (*lcdmodeptr == 0) {\r\nPRINTKE("LCD monitor CRTC parameters not found!!!\n");\r\n} else {\r\nPRINTKI(" LCD CRTC parameters: %d.%d %d %d %d %d %d %d %d %d\n",\r\n1000000 / par->lcd_pixclock, 1000000 % par->lcd_pixclock,\r\npar->lcd_hdisp,\r\npar->lcd_hdisp + par->lcd_right_margin,\r\npar->lcd_hdisp + par->lcd_right_margin\r\n+ par->lcd_hsync_dly + par->lcd_hsync_len,\r\npar->lcd_htotal,\r\npar->lcd_vdisp,\r\npar->lcd_vdisp + par->lcd_lower_margin,\r\npar->lcd_vdisp + par->lcd_lower_margin + par->lcd_vsync_len,\r\npar->lcd_vtotal);\r\nPRINTKI(" : %d %d %d %d %d %d %d %d %d\n",\r\npar->lcd_pixclock,\r\npar->lcd_hblank_len - (par->lcd_right_margin +\r\npar->lcd_hsync_dly + par->lcd_hsync_len),\r\npar->lcd_hdisp,\r\npar->lcd_right_margin,\r\npar->lcd_hsync_len,\r\npar->lcd_vblank_len - (par->lcd_lower_margin + par->lcd_vsync_len),\r\npar->lcd_vdisp,\r\npar->lcd_lower_margin,\r\npar->lcd_vsync_len);\r\n}\r\n}\r\n}\r\nstatic int init_from_bios(struct atyfb_par *par)\r\n{\r\nu32 bios_base, rom_addr;\r\nint ret;\r\nrom_addr = 0xc0000 + ((aty_ld_le32(SCRATCH_REG1, par) & 0x7f) << 11);\r\nbios_base = (unsigned long)ioremap(rom_addr, 0x10000);\r\nif (*((u16 *)bios_base) == 0xaa55) {\r\nu8 *bios_ptr;\r\nu16 rom_table_offset, freq_table_offset;\r\nPLL_BLOCK_MACH64 pll_block;\r\nPRINTKI("Mach64 BIOS is located at %x, mapped at %x.\n", rom_addr, bios_base);\r\nbios_ptr = (u8*)bios_base;\r\nrom_table_offset = (u16)(bios_ptr[0x48] | (bios_ptr[0x49] << 8));\r\nfreq_table_offset = bios_ptr[rom_table_offset + 16] | (bios_ptr[rom_table_offset + 17] << 8);\r\nmemcpy(&pll_block, bios_ptr + freq_table_offset, sizeof(PLL_BLOCK_MACH64));\r\nPRINTKI("BIOS frequency table:\n");\r\nPRINTKI("PCLK_min_freq %d, PCLK_max_freq %d, ref_freq %d, ref_divider %d\n",\r\npll_block.PCLK_min_freq, pll_block.PCLK_max_freq,\r\npll_block.ref_freq, pll_block.ref_divider);\r\nPRINTKI("MCLK_pwd %d, MCLK_max_freq %d, XCLK_max_freq %d, SCLK_freq %d\n",\r\npll_block.MCLK_pwd, pll_block.MCLK_max_freq,\r\npll_block.XCLK_max_freq, pll_block.SCLK_freq);\r\npar->pll_limits.pll_min = pll_block.PCLK_min_freq/100;\r\npar->pll_limits.pll_max = pll_block.PCLK_max_freq/100;\r\npar->pll_limits.ref_clk = pll_block.ref_freq/100;\r\npar->pll_limits.ref_div = pll_block.ref_divider;\r\npar->pll_limits.sclk = pll_block.SCLK_freq/100;\r\npar->pll_limits.mclk = pll_block.MCLK_max_freq/100;\r\npar->pll_limits.mclk_pm = pll_block.MCLK_pwd/100;\r\npar->pll_limits.xclk = pll_block.XCLK_max_freq/100;\r\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\r\naty_init_lcd(par, bios_base);\r\n#endif\r\nret = 0;\r\n} else {\r\nPRINTKE("no BIOS frequency table found, use parameters\n");\r\nret = -ENXIO;\r\n}\r\niounmap((void __iomem *)bios_base);\r\nreturn ret;\r\n}\r\nstatic int atyfb_setup_generic(struct pci_dev *pdev, struct fb_info *info,\r\nunsigned long addr)\r\n{\r\nstruct atyfb_par *par = info->par;\r\nu16 tmp;\r\nunsigned long raddr;\r\nstruct resource *rrp;\r\nint ret = 0;\r\nraddr = addr + 0x7ff000UL;\r\nrrp = &pdev->resource[2];\r\nif ((rrp->flags & IORESOURCE_MEM) &&\r\nrequest_mem_region(rrp->start, resource_size(rrp), "atyfb")) {\r\npar->aux_start = rrp->start;\r\npar->aux_size = resource_size(rrp);\r\nraddr = rrp->start;\r\nPRINTKI("using auxiliary register aperture\n");\r\n}\r\ninfo->fix.mmio_start = raddr;\r\npar->ati_regbase = ioremap(info->fix.mmio_start, 0x1000);\r\nif (par->ati_regbase == NULL)\r\nreturn -ENOMEM;\r\ninfo->fix.mmio_start += par->aux_start ? 0x400 : 0xc00;\r\npar->ati_regbase += par->aux_start ? 0x400 : 0xc00;\r\npci_read_config_word(pdev, PCI_COMMAND, &tmp);\r\nif (!(tmp & PCI_COMMAND_MEMORY)) {\r\ntmp |= PCI_COMMAND_MEMORY;\r\npci_write_config_word(pdev, PCI_COMMAND, tmp);\r\n}\r\n#ifdef __BIG_ENDIAN\r\naddr += 0x800000;\r\n#endif\r\ninfo->fix.smem_start = addr;\r\ninfo->screen_base = ioremap(addr, 0x800000);\r\nif (info->screen_base == NULL) {\r\nret = -ENOMEM;\r\ngoto atyfb_setup_generic_fail;\r\n}\r\nret = correct_chipset(par);\r\nif (ret)\r\ngoto atyfb_setup_generic_fail;\r\n#ifdef __i386__\r\nret = init_from_bios(par);\r\nif (ret)\r\ngoto atyfb_setup_generic_fail;\r\n#endif\r\nif (!(aty_ld_le32(CRTC_GEN_CNTL, par) & CRTC_EXT_DISP_EN))\r\npar->clk_wr_offset = (inb(R_GENMO) & 0x0CU) >> 2;\r\nelse\r\npar->clk_wr_offset = aty_ld_8(CLOCK_CNTL, par) & 0x03U;\r\npar->clk_wr_offset = 3;\r\nreturn 0;\r\natyfb_setup_generic_fail:\r\niounmap(par->ati_regbase);\r\npar->ati_regbase = NULL;\r\nif (info->screen_base) {\r\niounmap(info->screen_base);\r\ninfo->screen_base = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int atyfb_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nunsigned long addr, res_start, res_size;\r\nstruct fb_info *info;\r\nstruct resource *rp;\r\nstruct atyfb_par *par;\r\nint rc = -ENOMEM;\r\nif (pci_enable_device(pdev)) {\r\nPRINTKE("Cannot enable PCI device\n");\r\nreturn -ENXIO;\r\n}\r\nrp = &pdev->resource[0];\r\nif (rp->flags & IORESOURCE_IO)\r\nrp = &pdev->resource[1];\r\naddr = rp->start;\r\nif (!addr)\r\nreturn -ENXIO;\r\nres_start = rp->start;\r\nres_size = resource_size(rp);\r\nif (!request_mem_region(res_start, res_size, "atyfb"))\r\nreturn -EBUSY;\r\ninfo = framebuffer_alloc(sizeof(struct atyfb_par), &pdev->dev);\r\nif (!info) {\r\nPRINTKE("atyfb_pci_probe() can't alloc fb_info\n");\r\nreturn -ENOMEM;\r\n}\r\npar = info->par;\r\ninfo->fix = atyfb_fix;\r\ninfo->device = &pdev->dev;\r\npar->pci_id = pdev->device;\r\npar->res_start = res_start;\r\npar->res_size = res_size;\r\npar->irq = pdev->irq;\r\npar->pdev = pdev;\r\n#ifdef __sparc__\r\nrc = atyfb_setup_sparc(pdev, info, addr);\r\n#else\r\nrc = atyfb_setup_generic(pdev, info, addr);\r\n#endif\r\nif (rc)\r\ngoto err_release_mem;\r\npci_set_drvdata(pdev, info);\r\nrc = aty_init(info);\r\nif (rc)\r\ngoto err_release_io;\r\n#ifdef __sparc__\r\npar->mmap_map[0].voff = 0x8000000000000000UL;\r\npar->mmap_map[0].poff = (unsigned long) info->screen_base & PAGE_MASK;\r\npar->mmap_map[0].size = info->fix.smem_len;\r\npar->mmap_map[0].prot_mask = _PAGE_CACHE;\r\npar->mmap_map[0].prot_flag = _PAGE_E;\r\npar->mmap_map[1].voff = par->mmap_map[0].voff + info->fix.smem_len;\r\npar->mmap_map[1].poff = (long)par->ati_regbase & PAGE_MASK;\r\npar->mmap_map[1].size = PAGE_SIZE;\r\npar->mmap_map[1].prot_mask = _PAGE_CACHE;\r\npar->mmap_map[1].prot_flag = _PAGE_E;\r\n#endif\r\nmutex_lock(&reboot_lock);\r\nif (!reboot_info)\r\nreboot_info = info;\r\nmutex_unlock(&reboot_lock);\r\nreturn 0;\r\nerr_release_io:\r\n#ifdef __sparc__\r\nkfree(par->mmap_map);\r\n#else\r\nif (par->ati_regbase)\r\niounmap(par->ati_regbase);\r\nif (info->screen_base)\r\niounmap(info->screen_base);\r\n#endif\r\nerr_release_mem:\r\nif (par->aux_start)\r\nrelease_mem_region(par->aux_start, par->aux_size);\r\nrelease_mem_region(par->res_start, par->res_size);\r\nframebuffer_release(info);\r\nreturn rc;\r\n}\r\nstatic int __init atyfb_atari_probe(void)\r\n{\r\nstruct atyfb_par *par;\r\nstruct fb_info *info;\r\nint m64_num;\r\nu32 clock_r;\r\nint num_found = 0;\r\nfor (m64_num = 0; m64_num < mach64_count; m64_num++) {\r\nif (!phys_vmembase[m64_num] || !phys_size[m64_num] ||\r\n!phys_guiregbase[m64_num]) {\r\nPRINTKI("phys_*[%d] parameters not set => "\r\n"returning early. \n", m64_num);\r\ncontinue;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct atyfb_par), NULL);\r\nif (!info) {\r\nPRINTKE("atyfb_atari_probe() can't alloc fb_info\n");\r\nreturn -ENOMEM;\r\n}\r\npar = info->par;\r\ninfo->fix = atyfb_fix;\r\npar->irq = (unsigned int) -1;\r\ninfo->screen_base = ioremap(phys_vmembase[m64_num], phys_size[m64_num]);\r\ninfo->fix.smem_start = (unsigned long)info->screen_base;\r\npar->ati_regbase = ioremap(phys_guiregbase[m64_num], 0x10000) +\r\n0xFC00ul;\r\ninfo->fix.mmio_start = (unsigned long)par->ati_regbase;\r\naty_st_le32(CLOCK_CNTL, 0x12345678, par);\r\nclock_r = aty_ld_le32(CLOCK_CNTL, par);\r\nswitch (clock_r & 0x003F) {\r\ncase 0x12:\r\npar->clk_wr_offset = 3;\r\nbreak;\r\ncase 0x34:\r\npar->clk_wr_offset = 2;\r\nbreak;\r\ncase 0x16:\r\npar->clk_wr_offset = 1;\r\nbreak;\r\ncase 0x38:\r\npar->clk_wr_offset = 0;\r\nbreak;\r\n}\r\nswitch (aty_ld_le32(CNFG_CHIP_ID, par) & CFG_CHIP_TYPE) {\r\ncase 0x00d7:\r\npar->pci_id = PCI_CHIP_MACH64GX;\r\nbreak;\r\ncase 0x0057:\r\npar->pci_id = PCI_CHIP_MACH64CX;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (correct_chipset(par) || aty_init(info)) {\r\niounmap(info->screen_base);\r\niounmap(par->ati_regbase);\r\nframebuffer_release(info);\r\n} else {\r\nnum_found++;\r\n}\r\n}\r\nreturn num_found ? 0 : -ENXIO;\r\n}\r\nstatic void atyfb_remove(struct fb_info *info)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\naty_set_crtc(par, &par->saved_crtc);\r\npar->pll_ops->set_pll(info, &par->saved_pll);\r\nunregister_framebuffer(info);\r\n#ifdef CONFIG_FB_ATY_BACKLIGHT\r\nif (M64_HAS(MOBIL_BUS))\r\naty_bl_exit(info->bl_dev);\r\n#endif\r\n#ifdef CONFIG_MTRR\r\nif (par->mtrr_reg >= 0) {\r\nmtrr_del(par->mtrr_reg, 0, 0);\r\npar->mtrr_reg = -1;\r\n}\r\nif (par->mtrr_aper >= 0) {\r\nmtrr_del(par->mtrr_aper, 0, 0);\r\npar->mtrr_aper = -1;\r\n}\r\n#endif\r\n#ifndef __sparc__\r\nif (par->ati_regbase)\r\niounmap(par->ati_regbase);\r\nif (info->screen_base)\r\niounmap(info->screen_base);\r\n#ifdef __BIG_ENDIAN\r\nif (info->sprite.addr)\r\niounmap(info->sprite.addr);\r\n#endif\r\n#endif\r\n#ifdef __sparc__\r\nkfree(par->mmap_map);\r\n#endif\r\nif (par->aux_start)\r\nrelease_mem_region(par->aux_start, par->aux_size);\r\nif (par->res_start)\r\nrelease_mem_region(par->res_start, par->res_size);\r\nframebuffer_release(info);\r\n}\r\nstatic void atyfb_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pdev);\r\nmutex_lock(&reboot_lock);\r\nif (reboot_info == info)\r\nreboot_info = NULL;\r\nmutex_unlock(&reboot_lock);\r\natyfb_remove(info);\r\n}\r\nstatic int __init atyfb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!strncmp(this_opt, "noaccel", 7)) {\r\nnoaccel = 1;\r\n#ifdef CONFIG_MTRR\r\n} else if (!strncmp(this_opt, "nomtrr", 6)) {\r\nnomtrr = 1;\r\n#endif\r\n} else if (!strncmp(this_opt, "vram:", 5))\r\nvram = simple_strtoul(this_opt + 5, NULL, 0);\r\nelse if (!strncmp(this_opt, "pll:", 4))\r\npll = simple_strtoul(this_opt + 4, NULL, 0);\r\nelse if (!strncmp(this_opt, "mclk:", 5))\r\nmclk = simple_strtoul(this_opt + 5, NULL, 0);\r\nelse if (!strncmp(this_opt, "xclk:", 5))\r\nxclk = simple_strtoul(this_opt+5, NULL, 0);\r\nelse if (!strncmp(this_opt, "comp_sync:", 10))\r\ncomp_sync = simple_strtoul(this_opt+10, NULL, 0);\r\nelse if (!strncmp(this_opt, "backlight:", 10))\r\nbacklight = simple_strtoul(this_opt+10, NULL, 0);\r\n#ifdef CONFIG_PPC\r\nelse if (!strncmp(this_opt, "vmode:", 6)) {\r\nunsigned int vmode =\r\nsimple_strtoul(this_opt + 6, NULL, 0);\r\nif (vmode > 0 && vmode <= VMODE_MAX)\r\ndefault_vmode = vmode;\r\n} else if (!strncmp(this_opt, "cmode:", 6)) {\r\nunsigned int cmode =\r\nsimple_strtoul(this_opt + 6, NULL, 0);\r\nswitch (cmode) {\r\ncase 0:\r\ncase 8:\r\ndefault_cmode = CMODE_8;\r\nbreak;\r\ncase 15:\r\ncase 16:\r\ndefault_cmode = CMODE_16;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\ndefault_cmode = CMODE_32;\r\nbreak;\r\n}\r\n}\r\n#endif\r\n#ifdef CONFIG_ATARI\r\nelse if (MACH_IS_ATARI\r\n&& (!strncmp(this_opt, "Mach64:", 7))) {\r\nstatic unsigned char m64_num;\r\nstatic char mach64_str[80];\r\nstrlcpy(mach64_str, this_opt + 7, sizeof(mach64_str));\r\nif (!store_video_par(mach64_str, m64_num)) {\r\nm64_num++;\r\nmach64_count = m64_num;\r\n}\r\n}\r\n#endif\r\nelse\r\nmode = this_opt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atyfb_reboot_notify(struct notifier_block *nb,\r\nunsigned long code, void *unused)\r\n{\r\nstruct atyfb_par *par;\r\nif (code != SYS_RESTART)\r\nreturn NOTIFY_DONE;\r\nmutex_lock(&reboot_lock);\r\nif (!reboot_info)\r\ngoto out;\r\nif (!lock_fb_info(reboot_info))\r\ngoto out;\r\npar = reboot_info->par;\r\naty_set_crtc(par, &par->saved_crtc);\r\npar->pll_ops->set_pll(reboot_info, &par->saved_pll);\r\nunlock_fb_info(reboot_info);\r\nout:\r\nmutex_unlock(&reboot_lock);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init atyfb_init(void)\r\n{\r\nint err1 = 1, err2 = 1;\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("atyfb", &option))\r\nreturn -ENODEV;\r\natyfb_setup(option);\r\n#endif\r\n#ifdef CONFIG_PCI\r\nerr1 = pci_register_driver(&atyfb_driver);\r\n#endif\r\n#ifdef CONFIG_ATARI\r\nerr2 = atyfb_atari_probe();\r\n#endif\r\nif (err1 && err2)\r\nreturn -ENODEV;\r\nif (dmi_check_system(atyfb_reboot_ids))\r\nregister_reboot_notifier(&atyfb_reboot_notifier);\r\nreturn 0;\r\n}\r\nstatic void __exit atyfb_exit(void)\r\n{\r\nif (dmi_check_system(atyfb_reboot_ids))\r\nunregister_reboot_notifier(&atyfb_reboot_notifier);\r\n#ifdef CONFIG_PCI\r\npci_unregister_driver(&atyfb_driver);\r\n#endif\r\n}
