int saa7164_api_get_load_info(struct saa7164_dev *dev, struct tmFwInfoStruct *i)\r\n{\r\nint ret;\r\nif (!(saa_debug & DBGLVL_CPU))\r\nreturn 0;\r\ndprintk(DBGLVL_API, "%s()\n", __func__);\r\ni->deviceinst = 0;\r\ni->devicespec = 0;\r\ni->mode = 0;\r\ni->status = 0;\r\nret = saa7164_cmd_send(dev, 0, GET_CUR,\r\nGET_FW_STATUS_CONTROL, sizeof(struct tmFwInfoStruct), i);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nprintk(KERN_INFO "saa7164[%d]-CPU: %d percent", dev->nr, i->CPULoad);\r\nreturn ret;\r\n}\r\nint saa7164_api_collect_debug(struct saa7164_dev *dev)\r\n{\r\nstruct tmComResDebugGetData d;\r\nu8 more = 255;\r\nint ret;\r\ndprintk(DBGLVL_API, "%s()\n", __func__);\r\nwhile (more--) {\r\nmemset(&d, 0, sizeof(d));\r\nret = saa7164_cmd_send(dev, 0, GET_CUR,\r\nGET_DEBUG_DATA_CONTROL, sizeof(d), &d);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n",\r\n__func__, ret);\r\nif (d.dwResult != SAA_OK)\r\nbreak;\r\nprintk(KERN_INFO "saa7164[%d]-FWMSG: %s", dev->nr,\r\nd.ucDebugData);\r\n}\r\nreturn 0;\r\n}\r\nint saa7164_api_set_debug(struct saa7164_dev *dev, u8 level)\r\n{\r\nstruct tmComResDebugSetLevel lvl;\r\nint ret;\r\ndprintk(DBGLVL_API, "%s(level=%d)\n", __func__, level);\r\nret = saa7164_cmd_send(dev, 0, GET_CUR,\r\nSET_DEBUG_LEVEL_CONTROL, sizeof(lvl), &lvl);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\ndprintk(DBGLVL_API, "%s() Was %d\n", __func__, lvl.dwDebugLevel);\r\nlvl.dwDebugLevel = level;\r\nret = saa7164_cmd_send(dev, 0, SET_CUR,\r\nSET_DEBUG_LEVEL_CONTROL, sizeof(lvl), &lvl);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint saa7164_api_set_vbi_format(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nstruct tmComResProbeCommit fmt, rsp;\r\nint ret;\r\ndprintk(DBGLVL_API, "%s(nr=%d, unitid=0x%x)\n", __func__,\r\nport->nr, port->hwcfg.unitid);\r\nfmt.bmHint = 0;\r\nfmt.bFormatIndex = 1;\r\nfmt.bFrameIndex = 1;\r\nret = saa7164_cmd_send(port->dev, port->hwcfg.unitid,\r\nSET_CUR, SAA_PROBE_CONTROL, sizeof(fmt), &fmt);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() set error, ret = 0x%x\n", __func__, ret);\r\nret = saa7164_cmd_send(port->dev, port->hwcfg.unitid,\r\nGET_CUR, SAA_PROBE_CONTROL, sizeof(rsp), &rsp);\r\nif (ret != SAA_OK) {\r\nprintk(KERN_ERR "%s() get error, ret = 0x%x\n", __func__, ret);\r\n} else {\r\nif (memcmp(&fmt, &rsp, sizeof(rsp)) == 0) {\r\ndprintk(DBGLVL_API, "SET/PROBE Verified\n");\r\nret = saa7164_cmd_send(port->dev, port->hwcfg.unitid,\r\nSET_CUR, SAA_COMMIT_CONTROL, sizeof(fmt), &fmt);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() commit error, ret = 0x%x\n",\r\n__func__, ret);\r\nret = saa7164_cmd_send(port->dev, port->hwcfg.unitid,\r\nGET_CUR, SAA_COMMIT_CONTROL, sizeof(rsp), &rsp);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() GET commit error, ret = 0x%x\n",\r\n__func__, ret);\r\nif (memcmp(&fmt, &rsp, sizeof(rsp)) != 0) {\r\nprintk(KERN_ERR "%s() memcmp error, ret = 0x%x\n",\r\n__func__, ret);\r\n} else\r\ndprintk(DBGLVL_API, "SET/COMMIT Verified\n");\r\ndprintk(DBGLVL_API, "rsp.bmHint = 0x%x\n", rsp.bmHint);\r\ndprintk(DBGLVL_API, "rsp.bFormatIndex = 0x%x\n",\r\nrsp.bFormatIndex);\r\ndprintk(DBGLVL_API, "rsp.bFrameIndex = 0x%x\n",\r\nrsp.bFrameIndex);\r\n} else\r\nprintk(KERN_ERR "%s() compare failed\n", __func__);\r\n}\r\nif (ret == SAA_OK)\r\ndprintk(DBGLVL_API, "%s(nr=%d) Success\n", __func__, port->nr);\r\nreturn ret;\r\n}\r\nstatic int saa7164_api_set_gop_size(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nstruct tmComResEncVideoGopStructure gs;\r\nint ret;\r\ndprintk(DBGLVL_ENC, "%s()\n", __func__);\r\ngs.ucRefFrameDist = port->encoder_params.refdist;\r\ngs.ucGOPSize = port->encoder_params.gop_size;\r\nret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, SET_CUR,\r\nEU_VIDEO_GOP_STRUCTURE_CONTROL,\r\nsizeof(gs), &gs);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint saa7164_api_set_encoder(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nstruct tmComResEncVideoBitRate vb;\r\nstruct tmComResEncAudioBitRate ab;\r\nint ret;\r\ndprintk(DBGLVL_ENC, "%s() unitid=0x%x\n", __func__,\r\nport->hwcfg.sourceid);\r\nif (port->encoder_params.stream_type == V4L2_MPEG_STREAM_TYPE_MPEG2_PS)\r\nport->encoder_profile = EU_PROFILE_PS_DVD;\r\nelse\r\nport->encoder_profile = EU_PROFILE_TS_HQ;\r\nret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, SET_CUR,\r\nEU_PROFILE_CONTROL, sizeof(u8), &port->encoder_profile);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, SET_CUR,\r\nEU_PROFILE_CONTROL, sizeof(u8), &port->encoder_profile);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nif (port->encoder_params.bitrate_mode ==\r\nV4L2_MPEG_VIDEO_BITRATE_MODE_CBR)\r\nvb.ucVideoBitRateMode = EU_VIDEO_BIT_RATE_MODE_CONSTANT;\r\nelse\r\nvb.ucVideoBitRateMode = EU_VIDEO_BIT_RATE_MODE_VARIABLE_PEAK;\r\nvb.dwVideoBitRate = port->encoder_params.bitrate;\r\nvb.dwVideoBitRatePeak = port->encoder_params.bitrate_peak;\r\nret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, SET_CUR,\r\nEU_VIDEO_BIT_RATE_CONTROL,\r\nsizeof(struct tmComResEncVideoBitRate),\r\n&vb);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nab.ucAudioBitRateMode = 0;\r\nab.dwAudioBitRate = 384000;\r\nab.dwAudioBitRatePeak = ab.dwAudioBitRate;\r\nret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, SET_CUR,\r\nEU_AUDIO_BIT_RATE_CONTROL,\r\nsizeof(struct tmComResEncAudioBitRate),\r\n&ab);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__,\r\nret);\r\nsaa7164_api_set_aspect_ratio(port);\r\nsaa7164_api_set_gop_size(port);\r\nreturn ret;\r\n}\r\nint saa7164_api_get_encoder(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nstruct tmComResEncVideoBitRate v;\r\nstruct tmComResEncAudioBitRate a;\r\nstruct tmComResEncVideoInputAspectRatio ar;\r\nint ret;\r\ndprintk(DBGLVL_ENC, "%s() unitid=0x%x\n", __func__,\r\nport->hwcfg.sourceid);\r\nport->encoder_profile = 0;\r\nport->video_format = 0;\r\nport->video_resolution = 0;\r\nport->audio_format = 0;\r\nret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, GET_CUR,\r\nEU_PROFILE_CONTROL, sizeof(u8), &port->encoder_profile);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, GET_CUR,\r\nEU_VIDEO_RESOLUTION_CONTROL, sizeof(u8),\r\n&port->video_resolution);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, GET_CUR,\r\nEU_VIDEO_FORMAT_CONTROL, sizeof(u8), &port->video_format);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, GET_CUR,\r\nEU_VIDEO_BIT_RATE_CONTROL, sizeof(v), &v);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, GET_CUR,\r\nEU_AUDIO_FORMAT_CONTROL, sizeof(u8), &port->audio_format);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, GET_CUR,\r\nEU_AUDIO_BIT_RATE_CONTROL, sizeof(a), &a);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nar.width = 0;\r\nar.height = 0;\r\nret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, GET_CUR,\r\nEU_VIDEO_INPUT_ASPECT_CONTROL,\r\nsizeof(struct tmComResEncVideoInputAspectRatio), &ar);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\ndprintk(DBGLVL_ENC, "encoder_profile = %d\n", port->encoder_profile);\r\ndprintk(DBGLVL_ENC, "video_format = %d\n", port->video_format);\r\ndprintk(DBGLVL_ENC, "audio_format = %d\n", port->audio_format);\r\ndprintk(DBGLVL_ENC, "video_resolution= %d\n", port->video_resolution);\r\ndprintk(DBGLVL_ENC, "v.ucVideoBitRateMode = %d\n",\r\nv.ucVideoBitRateMode);\r\ndprintk(DBGLVL_ENC, "v.dwVideoBitRate = %d\n",\r\nv.dwVideoBitRate);\r\ndprintk(DBGLVL_ENC, "v.dwVideoBitRatePeak = %d\n",\r\nv.dwVideoBitRatePeak);\r\ndprintk(DBGLVL_ENC, "a.ucVideoBitRateMode = %d\n",\r\na.ucAudioBitRateMode);\r\ndprintk(DBGLVL_ENC, "a.dwVideoBitRate = %d\n",\r\na.dwAudioBitRate);\r\ndprintk(DBGLVL_ENC, "a.dwVideoBitRatePeak = %d\n",\r\na.dwAudioBitRatePeak);\r\ndprintk(DBGLVL_ENC, "aspect.width / height = %d:%d\n",\r\nar.width, ar.height);\r\nreturn ret;\r\n}\r\nint saa7164_api_set_aspect_ratio(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nstruct tmComResEncVideoInputAspectRatio ar;\r\nint ret;\r\ndprintk(DBGLVL_ENC, "%s(%d)\n", __func__,\r\nport->encoder_params.ctl_aspect);\r\nswitch (port->encoder_params.ctl_aspect) {\r\ncase V4L2_MPEG_VIDEO_ASPECT_1x1:\r\nar.width = 1;\r\nar.height = 1;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_ASPECT_4x3:\r\nar.width = 4;\r\nar.height = 3;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_ASPECT_16x9:\r\nar.width = 16;\r\nar.height = 9;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_ASPECT_221x100:\r\nar.width = 221;\r\nar.height = 100;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\ndprintk(DBGLVL_ENC, "%s(%d) now %d:%d\n", __func__,\r\nport->encoder_params.ctl_aspect,\r\nar.width, ar.height);\r\nret = saa7164_cmd_send(port->dev, port->hwcfg.sourceid, SET_CUR,\r\nEU_VIDEO_INPUT_ASPECT_CONTROL,\r\nsizeof(struct tmComResEncVideoInputAspectRatio), &ar);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint saa7164_api_set_usercontrol(struct saa7164_port *port, u8 ctl)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nint ret;\r\nu16 val;\r\nif (ctl == PU_BRIGHTNESS_CONTROL)\r\nval = port->ctl_brightness;\r\nelse\r\nif (ctl == PU_CONTRAST_CONTROL)\r\nval = port->ctl_contrast;\r\nelse\r\nif (ctl == PU_HUE_CONTROL)\r\nval = port->ctl_hue;\r\nelse\r\nif (ctl == PU_SATURATION_CONTROL)\r\nval = port->ctl_saturation;\r\nelse\r\nif (ctl == PU_SHARPNESS_CONTROL)\r\nval = port->ctl_sharpness;\r\nelse\r\nreturn -EINVAL;\r\ndprintk(DBGLVL_ENC, "%s() unitid=0x%x ctl=%d, val=%d\n",\r\n__func__, port->encunit.vsourceid, ctl, val);\r\nret = saa7164_cmd_send(port->dev, port->encunit.vsourceid, SET_CUR,\r\nctl, sizeof(u16), &val);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint saa7164_api_get_usercontrol(struct saa7164_port *port, u8 ctl)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nint ret;\r\nu16 val;\r\nret = saa7164_cmd_send(port->dev, port->encunit.vsourceid, GET_CUR,\r\nctl, sizeof(u16), &val);\r\nif (ret != SAA_OK) {\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nreturn ret;\r\n}\r\ndprintk(DBGLVL_ENC, "%s() ctl=%d, val=%d\n",\r\n__func__, ctl, val);\r\nif (ctl == PU_BRIGHTNESS_CONTROL)\r\nport->ctl_brightness = val;\r\nelse\r\nif (ctl == PU_CONTRAST_CONTROL)\r\nport->ctl_contrast = val;\r\nelse\r\nif (ctl == PU_HUE_CONTROL)\r\nport->ctl_hue = val;\r\nelse\r\nif (ctl == PU_SATURATION_CONTROL)\r\nport->ctl_saturation = val;\r\nelse\r\nif (ctl == PU_SHARPNESS_CONTROL)\r\nport->ctl_sharpness = val;\r\nreturn ret;\r\n}\r\nint saa7164_api_set_videomux(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nu8 inputs[] = { 1, 2, 2, 2, 5, 5, 5 };\r\nint ret;\r\ndprintk(DBGLVL_ENC, "%s() v_mux=%d a_mux=%d\n",\r\n__func__, port->mux_input, inputs[port->mux_input - 1]);\r\nret = saa7164_api_audio_mute(port, 1);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nret = saa7164_cmd_send(port->dev, port->vidproc.sourceid, SET_CUR,\r\nSU_INPUT_SELECT_CONTROL, sizeof(u8), &port->mux_input);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nret = saa7164_cmd_send(port->dev, port->audfeat.sourceid, SET_CUR,\r\nSU_INPUT_SELECT_CONTROL, sizeof(u8),\r\n&inputs[port->mux_input - 1]);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nret = saa7164_api_audio_mute(port, 0);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint saa7164_api_audio_mute(struct saa7164_port *port, int mute)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nu8 v = mute;\r\nint ret;\r\ndprintk(DBGLVL_API, "%s(%d)\n", __func__, mute);\r\nret = saa7164_cmd_send(port->dev, port->audfeat.unitid, SET_CUR,\r\nMUTE_CONTROL, sizeof(u8), &v);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint saa7164_api_set_audio_volume(struct saa7164_port *port, s8 level)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\ns16 v, min, max;\r\nint ret;\r\ndprintk(DBGLVL_API, "%s(%d)\n", __func__, level);\r\nret = saa7164_cmd_send(port->dev, port->audfeat.unitid, GET_MIN,\r\nVOLUME_CONTROL, sizeof(u16), &min);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nret = saa7164_cmd_send(port->dev, port->audfeat.unitid, GET_MAX,\r\nVOLUME_CONTROL, sizeof(u16), &max);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nret = saa7164_cmd_send(port->dev, port->audfeat.unitid, GET_CUR,\r\n(0x01 << 8) | VOLUME_CONTROL, sizeof(u16), &v);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\ndprintk(DBGLVL_API, "%s(%d) min=%d max=%d cur=%d\n", __func__,\r\nlevel, min, max, v);\r\nv = level;\r\nif (v < min)\r\nv = min;\r\nif (v > max)\r\nv = max;\r\nret = saa7164_cmd_send(port->dev, port->audfeat.unitid, SET_CUR,\r\n(0x01 << 8) | VOLUME_CONTROL, sizeof(s16), &v);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nret = saa7164_cmd_send(port->dev, port->audfeat.unitid, SET_CUR,\r\n(0x02 << 8) | VOLUME_CONTROL, sizeof(s16), &v);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nret = saa7164_cmd_send(port->dev, port->audfeat.unitid, GET_CUR,\r\n(0x01 << 8) | VOLUME_CONTROL, sizeof(u16), &v);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\ndprintk(DBGLVL_API, "%s(%d) min=%d max=%d cur=%d\n", __func__,\r\nlevel, min, max, v);\r\nreturn ret;\r\n}\r\nint saa7164_api_set_audio_std(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nstruct tmComResAudioDefaults lvl;\r\nstruct tmComResTunerStandard tvaudio;\r\nint ret;\r\ndprintk(DBGLVL_API, "%s()\n", __func__);\r\nlvl.ucDecoderLevel = TMHW_LEV_ADJ_DECLEV_DEFAULT;\r\nlvl.ucDecoderFM_Level = TMHW_LEV_ADJ_DECLEV_DEFAULT;\r\nlvl.ucMonoLevel = TMHW_LEV_ADJ_MONOLEV_DEFAULT;\r\nlvl.ucNICAM_Level = TMHW_LEV_ADJ_NICLEV_DEFAULT;\r\nlvl.ucSAP_Level = TMHW_LEV_ADJ_SAPLEV_DEFAULT;\r\nlvl.ucADC_Level = TMHW_LEV_ADJ_ADCLEV_DEFAULT;\r\nret = saa7164_cmd_send(port->dev, port->audfeat.unitid, SET_CUR,\r\nAUDIO_DEFAULT_CONTROL, sizeof(struct tmComResAudioDefaults),\r\n&lvl);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nif (port->encodernorm.id & V4L2_STD_NTSC) {\r\ntvaudio.std = TU_STANDARD_NTSC_M;\r\ntvaudio.country = 1;\r\n} else {\r\ntvaudio.std = TU_STANDARD_PAL_I;\r\ntvaudio.country = 44;\r\n}\r\nret = saa7164_cmd_send(port->dev, port->tunerunit.unitid, SET_CUR,\r\nTU_STANDARD_CONTROL, sizeof(tvaudio), &tvaudio);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() TU_STANDARD_CONTROL error, ret = 0x%x\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nint saa7164_api_set_audio_detection(struct saa7164_port *port, int autodetect)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nstruct tmComResTunerStandardAuto p;\r\nint ret;\r\ndprintk(DBGLVL_API, "%s(%d)\n", __func__, autodetect);\r\nif (autodetect)\r\np.mode = TU_STANDARD_AUTO;\r\nelse\r\np.mode = TU_STANDARD_MANUAL;\r\nret = saa7164_cmd_send(port->dev, port->tunerunit.unitid, SET_CUR,\r\nTU_STANDARD_AUTO_CONTROL, sizeof(p), &p);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR\r\n"%s() TU_STANDARD_AUTO_CONTROL error, ret = 0x%x\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nint saa7164_api_get_videomux(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nint ret;\r\nret = saa7164_cmd_send(port->dev, port->vidproc.sourceid, GET_CUR,\r\nSU_INPUT_SELECT_CONTROL, sizeof(u8), &port->mux_input);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\ndprintk(DBGLVL_ENC, "%s() v_mux=%d\n",\r\n__func__, port->mux_input);\r\nreturn ret;\r\n}\r\nstatic int saa7164_api_set_dif(struct saa7164_port *port, u8 reg, u8 val)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nu16 len = 0;\r\nu8 buf[256];\r\nint ret;\r\nu8 mas;\r\ndprintk(DBGLVL_API, "%s(nr=%d type=%d val=%x)\n", __func__,\r\nport->nr, port->type, val);\r\nif (port->nr == 0)\r\nmas = 0xd0;\r\nelse\r\nmas = 0xe0;\r\nmemset(buf, 0, sizeof(buf));\r\nbuf[0x00] = 0x04;\r\nbuf[0x01] = 0x00;\r\nbuf[0x02] = 0x00;\r\nbuf[0x03] = 0x00;\r\nbuf[0x04] = 0x04;\r\nbuf[0x05] = 0x00;\r\nbuf[0x06] = 0x00;\r\nbuf[0x07] = 0x00;\r\nbuf[0x08] = reg;\r\nbuf[0x09] = 0x26;\r\nbuf[0x0a] = mas;\r\nbuf[0x0b] = 0xb0;\r\nbuf[0x0c] = val;\r\nbuf[0x0d] = 0x00;\r\nbuf[0x0e] = 0x00;\r\nbuf[0x0f] = 0x00;\r\nret = saa7164_cmd_send(dev, port->ifunit.unitid, GET_LEN,\r\nEXU_REGISTER_ACCESS_CONTROL, sizeof(len), &len);\r\nif (ret != SAA_OK) {\r\nprintk(KERN_ERR "%s() error, ret(1) = 0x%x\n", __func__, ret);\r\nreturn -EIO;\r\n}\r\nret = saa7164_cmd_send(dev, port->ifunit.unitid, SET_CUR,\r\nEXU_REGISTER_ACCESS_CONTROL, len, &buf);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret(2) = 0x%x\n", __func__, ret);\r\n#if 0\r\nprint_hex_dump(KERN_INFO, "", DUMP_PREFIX_OFFSET, 16, 1, buf, 16,\r\nfalse);\r\n#endif\r\nreturn ret == SAA_OK ? 0 : -EIO;\r\n}\r\nint saa7164_api_configure_dif(struct saa7164_port *port, u32 std)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nint ret = 0;\r\nu8 agc_disable;\r\ndprintk(DBGLVL_API, "%s(nr=%d, 0x%x)\n", __func__, port->nr, std);\r\nif (std & V4L2_STD_NTSC) {\r\ndprintk(DBGLVL_API, " NTSC\n");\r\nsaa7164_api_set_dif(port, 0x00, 0x01);\r\nagc_disable = 0;\r\n} else if (std & V4L2_STD_PAL_I) {\r\ndprintk(DBGLVL_API, " PAL-I\n");\r\nsaa7164_api_set_dif(port, 0x00, 0x08);\r\nagc_disable = 0;\r\n} else if (std & V4L2_STD_PAL_M) {\r\ndprintk(DBGLVL_API, " PAL-M\n");\r\nsaa7164_api_set_dif(port, 0x00, 0x01);\r\nagc_disable = 0;\r\n} else if (std & V4L2_STD_PAL_N) {\r\ndprintk(DBGLVL_API, " PAL-N\n");\r\nsaa7164_api_set_dif(port, 0x00, 0x01);\r\nagc_disable = 0;\r\n} else if (std & V4L2_STD_PAL_Nc) {\r\ndprintk(DBGLVL_API, " PAL-Nc\n");\r\nsaa7164_api_set_dif(port, 0x00, 0x01);\r\nagc_disable = 0;\r\n} else if (std & V4L2_STD_PAL_B) {\r\ndprintk(DBGLVL_API, " PAL-B\n");\r\nsaa7164_api_set_dif(port, 0x00, 0x02);\r\nagc_disable = 0;\r\n} else if (std & V4L2_STD_PAL_DK) {\r\ndprintk(DBGLVL_API, " PAL-DK\n");\r\nsaa7164_api_set_dif(port, 0x00, 0x10);\r\nagc_disable = 0;\r\n} else if (std & V4L2_STD_SECAM_L) {\r\ndprintk(DBGLVL_API, " SECAM-L\n");\r\nsaa7164_api_set_dif(port, 0x00, 0x20);\r\nagc_disable = 0;\r\n} else {\r\ndprintk(DBGLVL_API, " Unknown (assuming DTV)\n");\r\nsaa7164_api_set_dif(port, 0x00, 0x80);\r\nagc_disable = 1;\r\n}\r\nsaa7164_api_set_dif(port, 0x48, 0xa0);\r\nsaa7164_api_set_dif(port, 0xc0, agc_disable);\r\nsaa7164_api_set_dif(port, 0x7c, 0x04);\r\nsaa7164_api_set_dif(port, 0x04, 0x01);\r\nmsleep(100);\r\nsaa7164_api_set_dif(port, 0x04, 0x00);\r\nmsleep(100);\r\nreturn ret;\r\n}\r\nint saa7164_api_initialize_dif(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nstruct saa7164_port *p = NULL;\r\nint ret = -EINVAL;\r\nu32 std = 0;\r\ndprintk(DBGLVL_API, "%s(nr=%d type=%d)\n", __func__,\r\nport->nr, port->type);\r\nif (port->type == SAA7164_MPEG_ENCODER) {\r\nstd = V4L2_STD_NTSC;\r\n} else\r\nif (port->type == SAA7164_MPEG_DVB) {\r\nif (port->nr == SAA7164_PORT_TS1)\r\np = &dev->ports[SAA7164_PORT_ENC1];\r\nelse\r\np = &dev->ports[SAA7164_PORT_ENC2];\r\n} else\r\nif (port->type == SAA7164_MPEG_VBI) {\r\nstd = V4L2_STD_NTSC;\r\nif (port->nr == SAA7164_PORT_VBI1)\r\np = &dev->ports[SAA7164_PORT_ENC1];\r\nelse\r\np = &dev->ports[SAA7164_PORT_ENC2];\r\n} else\r\nBUG();\r\nif (p)\r\nret = saa7164_api_configure_dif(p, std);\r\nreturn ret;\r\n}\r\nint saa7164_api_transition_port(struct saa7164_port *port, u8 mode)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nint ret;\r\ndprintk(DBGLVL_API, "%s(nr=%d unitid=0x%x,%d)\n",\r\n__func__, port->nr, port->hwcfg.unitid, mode);\r\nret = saa7164_cmd_send(port->dev, port->hwcfg.unitid, SET_CUR,\r\nSAA_STATE_CONTROL, sizeof(mode), &mode);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s(portnr %d unitid 0x%x) error, ret = 0x%x\n",\r\n__func__, port->nr, port->hwcfg.unitid, ret);\r\nreturn ret;\r\n}\r\nint saa7164_api_get_fw_version(struct saa7164_dev *dev, u32 *version)\r\n{\r\nint ret;\r\nret = saa7164_cmd_send(dev, 0, GET_CUR,\r\nGET_FW_VERSION_CONTROL, sizeof(u32), version);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint saa7164_api_read_eeprom(struct saa7164_dev *dev, u8 *buf, int buflen)\r\n{\r\nu8 reg[] = { 0x0f, 0x00 };\r\nif (buflen < 128)\r\nreturn -ENOMEM;\r\nreturn saa7164_api_i2c_read(&dev->i2c_bus[0], 0xa0 >> 1, sizeof(reg),\r\n&reg[0], 128, buf);\r\n}\r\nstatic int saa7164_api_configure_port_vbi(struct saa7164_dev *dev,\r\nstruct saa7164_port *port)\r\n{\r\nstruct tmComResVBIFormatDescrHeader *fmt = &port->vbi_fmt_ntsc;\r\ndprintk(DBGLVL_API, " bFormatIndex = 0x%x\n", fmt->bFormatIndex);\r\ndprintk(DBGLVL_API, " VideoStandard = 0x%x\n", fmt->VideoStandard);\r\ndprintk(DBGLVL_API, " StartLine = %d\n", fmt->StartLine);\r\ndprintk(DBGLVL_API, " EndLine = %d\n", fmt->EndLine);\r\ndprintk(DBGLVL_API, " FieldRate = %d\n", fmt->FieldRate);\r\ndprintk(DBGLVL_API, " bNumLines = %d\n", fmt->bNumLines);\r\nport->bufcounter = port->hwcfg.BARLocation;\r\nport->pitch = port->hwcfg.BARLocation + (2 * sizeof(u32));\r\nport->bufsize = port->hwcfg.BARLocation + (3 * sizeof(u32));\r\nport->bufoffset = port->hwcfg.BARLocation + (4 * sizeof(u32));\r\nport->bufptr32l = port->hwcfg.BARLocation +\r\n(4 * sizeof(u32)) +\r\n(sizeof(u32) * port->hwcfg.buffercount) + sizeof(u32);\r\nport->bufptr32h = port->hwcfg.BARLocation +\r\n(4 * sizeof(u32)) +\r\n(sizeof(u32) * port->hwcfg.buffercount);\r\nport->bufptr64 = port->hwcfg.BARLocation +\r\n(4 * sizeof(u32)) +\r\n(sizeof(u32) * port->hwcfg.buffercount);\r\ndprintk(DBGLVL_API, " = port->hwcfg.BARLocation = 0x%x\n",\r\nport->hwcfg.BARLocation);\r\ndprintk(DBGLVL_API, " = VS_FORMAT_VBI (becomes dev->en[%d])\n",\r\nport->nr);\r\nreturn 0;\r\n}\r\nstatic int\r\nsaa7164_api_configure_port_mpeg2ts(struct saa7164_dev *dev,\r\nstruct saa7164_port *port,\r\nstruct tmComResTSFormatDescrHeader *tsfmt)\r\n{\r\ndprintk(DBGLVL_API, " bFormatIndex = 0x%x\n", tsfmt->bFormatIndex);\r\ndprintk(DBGLVL_API, " bDataOffset = 0x%x\n", tsfmt->bDataOffset);\r\ndprintk(DBGLVL_API, " bPacketLength= 0x%x\n", tsfmt->bPacketLength);\r\ndprintk(DBGLVL_API, " bStrideLength= 0x%x\n", tsfmt->bStrideLength);\r\ndprintk(DBGLVL_API, " bguid = (....)\n");\r\nport->bufcounter = port->hwcfg.BARLocation;\r\nport->pitch = port->hwcfg.BARLocation + (2 * sizeof(u32));\r\nport->bufsize = port->hwcfg.BARLocation + (3 * sizeof(u32));\r\nport->bufoffset = port->hwcfg.BARLocation + (4 * sizeof(u32));\r\nport->bufptr32l = port->hwcfg.BARLocation +\r\n(4 * sizeof(u32)) +\r\n(sizeof(u32) * port->hwcfg.buffercount) + sizeof(u32);\r\nport->bufptr32h = port->hwcfg.BARLocation +\r\n(4 * sizeof(u32)) +\r\n(sizeof(u32) * port->hwcfg.buffercount);\r\nport->bufptr64 = port->hwcfg.BARLocation +\r\n(4 * sizeof(u32)) +\r\n(sizeof(u32) * port->hwcfg.buffercount);\r\ndprintk(DBGLVL_API, " = port->hwcfg.BARLocation = 0x%x\n",\r\nport->hwcfg.BARLocation);\r\ndprintk(DBGLVL_API, " = VS_FORMAT_MPEGTS (becomes dev->ts[%d])\n",\r\nport->nr);\r\nreturn 0;\r\n}\r\nstatic int\r\nsaa7164_api_configure_port_mpeg2ps(struct saa7164_dev *dev,\r\nstruct saa7164_port *port,\r\nstruct tmComResPSFormatDescrHeader *fmt)\r\n{\r\ndprintk(DBGLVL_API, " bFormatIndex = 0x%x\n", fmt->bFormatIndex);\r\ndprintk(DBGLVL_API, " wPacketLength= 0x%x\n", fmt->wPacketLength);\r\ndprintk(DBGLVL_API, " wPackLength= 0x%x\n", fmt->wPackLength);\r\ndprintk(DBGLVL_API, " bPackDataType= 0x%x\n", fmt->bPackDataType);\r\nport->bufcounter = port->hwcfg.BARLocation;\r\nport->pitch = port->hwcfg.BARLocation + (2 * sizeof(u32));\r\nport->bufsize = port->hwcfg.BARLocation + (3 * sizeof(u32));\r\nport->bufoffset = port->hwcfg.BARLocation + (4 * sizeof(u32));\r\nport->bufptr32l = port->hwcfg.BARLocation +\r\n(4 * sizeof(u32)) +\r\n(sizeof(u32) * port->hwcfg.buffercount) + sizeof(u32);\r\nport->bufptr32h = port->hwcfg.BARLocation +\r\n(4 * sizeof(u32)) +\r\n(sizeof(u32) * port->hwcfg.buffercount);\r\nport->bufptr64 = port->hwcfg.BARLocation +\r\n(4 * sizeof(u32)) +\r\n(sizeof(u32) * port->hwcfg.buffercount);\r\ndprintk(DBGLVL_API, " = port->hwcfg.BARLocation = 0x%x\n",\r\nport->hwcfg.BARLocation);\r\ndprintk(DBGLVL_API, " = VS_FORMAT_MPEGPS (becomes dev->enc[%d])\n",\r\nport->nr);\r\nreturn 0;\r\n}\r\nstatic int saa7164_api_dump_subdevs(struct saa7164_dev *dev, u8 *buf, int len)\r\n{\r\nstruct saa7164_port *tsport = NULL;\r\nstruct saa7164_port *encport = NULL;\r\nstruct saa7164_port *vbiport = NULL;\r\nu32 idx, next_offset;\r\nint i;\r\nstruct tmComResDescrHeader *hdr, *t;\r\nstruct tmComResExtDevDescrHeader *exthdr;\r\nstruct tmComResPathDescrHeader *pathhdr;\r\nstruct tmComResAntTermDescrHeader *anttermhdr;\r\nstruct tmComResTunerDescrHeader *tunerunithdr;\r\nstruct tmComResDMATermDescrHeader *vcoutputtermhdr;\r\nstruct tmComResTSFormatDescrHeader *tsfmt;\r\nstruct tmComResPSFormatDescrHeader *psfmt;\r\nstruct tmComResSelDescrHeader *psel;\r\nstruct tmComResProcDescrHeader *pdh;\r\nstruct tmComResAFeatureDescrHeader *afd;\r\nstruct tmComResEncoderDescrHeader *edh;\r\nstruct tmComResVBIFormatDescrHeader *vbifmt;\r\nu32 currpath = 0;\r\ndprintk(DBGLVL_API,\r\n"%s(?,?,%d) sizeof(struct tmComResDescrHeader) = %d bytes\n",\r\n__func__, len, (u32)sizeof(struct tmComResDescrHeader));\r\nfor (idx = 0; idx < (len - sizeof(struct tmComResDescrHeader));) {\r\nhdr = (struct tmComResDescrHeader *)(buf + idx);\r\nif (hdr->type != CS_INTERFACE)\r\nreturn SAA_ERR_NOT_SUPPORTED;\r\ndprintk(DBGLVL_API, "@ 0x%x =\n", idx);\r\nswitch (hdr->subtype) {\r\ncase GENERAL_REQUEST:\r\ndprintk(DBGLVL_API, " GENERAL_REQUEST\n");\r\nbreak;\r\ncase VC_TUNER_PATH:\r\ndprintk(DBGLVL_API, " VC_TUNER_PATH\n");\r\npathhdr = (struct tmComResPathDescrHeader *)(buf + idx);\r\ndprintk(DBGLVL_API, " pathid = 0x%x\n",\r\npathhdr->pathid);\r\ncurrpath = pathhdr->pathid;\r\nbreak;\r\ncase VC_INPUT_TERMINAL:\r\ndprintk(DBGLVL_API, " VC_INPUT_TERMINAL\n");\r\nanttermhdr =\r\n(struct tmComResAntTermDescrHeader *)(buf + idx);\r\ndprintk(DBGLVL_API, " terminalid = 0x%x\n",\r\nanttermhdr->terminalid);\r\ndprintk(DBGLVL_API, " terminaltype = 0x%x\n",\r\nanttermhdr->terminaltype);\r\nswitch (anttermhdr->terminaltype) {\r\ncase ITT_ANTENNA:\r\ndprintk(DBGLVL_API, " = ITT_ANTENNA\n");\r\nbreak;\r\ncase LINE_CONNECTOR:\r\ndprintk(DBGLVL_API, " = LINE_CONNECTOR\n");\r\nbreak;\r\ncase SPDIF_CONNECTOR:\r\ndprintk(DBGLVL_API, " = SPDIF_CONNECTOR\n");\r\nbreak;\r\ncase COMPOSITE_CONNECTOR:\r\ndprintk(DBGLVL_API,\r\n" = COMPOSITE_CONNECTOR\n");\r\nbreak;\r\ncase SVIDEO_CONNECTOR:\r\ndprintk(DBGLVL_API, " = SVIDEO_CONNECTOR\n");\r\nbreak;\r\ncase COMPONENT_CONNECTOR:\r\ndprintk(DBGLVL_API,\r\n" = COMPONENT_CONNECTOR\n");\r\nbreak;\r\ncase STANDARD_DMA:\r\ndprintk(DBGLVL_API, " = STANDARD_DMA\n");\r\nbreak;\r\ndefault:\r\ndprintk(DBGLVL_API, " = undefined (0x%x)\n",\r\nanttermhdr->terminaltype);\r\n}\r\ndprintk(DBGLVL_API, " assocterminal= 0x%x\n",\r\nanttermhdr->assocterminal);\r\ndprintk(DBGLVL_API, " iterminal = 0x%x\n",\r\nanttermhdr->iterminal);\r\ndprintk(DBGLVL_API, " controlsize = 0x%x\n",\r\nanttermhdr->controlsize);\r\nbreak;\r\ncase VC_OUTPUT_TERMINAL:\r\ndprintk(DBGLVL_API, " VC_OUTPUT_TERMINAL\n");\r\nvcoutputtermhdr =\r\n(struct tmComResDMATermDescrHeader *)(buf + idx);\r\ndprintk(DBGLVL_API, " unitid = 0x%x\n",\r\nvcoutputtermhdr->unitid);\r\ndprintk(DBGLVL_API, " terminaltype = 0x%x\n",\r\nvcoutputtermhdr->terminaltype);\r\nswitch (vcoutputtermhdr->terminaltype) {\r\ncase ITT_ANTENNA:\r\ndprintk(DBGLVL_API, " = ITT_ANTENNA\n");\r\nbreak;\r\ncase LINE_CONNECTOR:\r\ndprintk(DBGLVL_API, " = LINE_CONNECTOR\n");\r\nbreak;\r\ncase SPDIF_CONNECTOR:\r\ndprintk(DBGLVL_API, " = SPDIF_CONNECTOR\n");\r\nbreak;\r\ncase COMPOSITE_CONNECTOR:\r\ndprintk(DBGLVL_API,\r\n" = COMPOSITE_CONNECTOR\n");\r\nbreak;\r\ncase SVIDEO_CONNECTOR:\r\ndprintk(DBGLVL_API, " = SVIDEO_CONNECTOR\n");\r\nbreak;\r\ncase COMPONENT_CONNECTOR:\r\ndprintk(DBGLVL_API,\r\n" = COMPONENT_CONNECTOR\n");\r\nbreak;\r\ncase STANDARD_DMA:\r\ndprintk(DBGLVL_API, " = STANDARD_DMA\n");\r\nbreak;\r\ndefault:\r\ndprintk(DBGLVL_API, " = undefined (0x%x)\n",\r\nvcoutputtermhdr->terminaltype);\r\n}\r\ndprintk(DBGLVL_API, " assocterminal= 0x%x\n",\r\nvcoutputtermhdr->assocterminal);\r\ndprintk(DBGLVL_API, " sourceid = 0x%x\n",\r\nvcoutputtermhdr->sourceid);\r\ndprintk(DBGLVL_API, " iterminal = 0x%x\n",\r\nvcoutputtermhdr->iterminal);\r\ndprintk(DBGLVL_API, " BARLocation = 0x%x\n",\r\nvcoutputtermhdr->BARLocation);\r\ndprintk(DBGLVL_API, " flags = 0x%x\n",\r\nvcoutputtermhdr->flags);\r\ndprintk(DBGLVL_API, " interruptid = 0x%x\n",\r\nvcoutputtermhdr->interruptid);\r\ndprintk(DBGLVL_API, " buffercount = 0x%x\n",\r\nvcoutputtermhdr->buffercount);\r\ndprintk(DBGLVL_API, " metadatasize = 0x%x\n",\r\nvcoutputtermhdr->metadatasize);\r\ndprintk(DBGLVL_API, " controlsize = 0x%x\n",\r\nvcoutputtermhdr->controlsize);\r\ndprintk(DBGLVL_API, " numformats = 0x%x\n",\r\nvcoutputtermhdr->numformats);\r\nt = (struct tmComResDescrHeader *)\r\n((struct tmComResDMATermDescrHeader *)(buf + idx));\r\nnext_offset = idx + (vcoutputtermhdr->len);\r\nfor (i = 0; i < vcoutputtermhdr->numformats; i++) {\r\nt = (struct tmComResDescrHeader *)\r\n(buf + next_offset);\r\nswitch (t->subtype) {\r\ncase VS_FORMAT_MPEG2TS:\r\ntsfmt =\r\n(struct tmComResTSFormatDescrHeader *)t;\r\nif (currpath == 1)\r\ntsport = &dev->ports[SAA7164_PORT_TS1];\r\nelse\r\ntsport = &dev->ports[SAA7164_PORT_TS2];\r\nmemcpy(&tsport->hwcfg, vcoutputtermhdr,\r\nsizeof(*vcoutputtermhdr));\r\nsaa7164_api_configure_port_mpeg2ts(dev,\r\ntsport, tsfmt);\r\nbreak;\r\ncase VS_FORMAT_MPEG2PS:\r\npsfmt =\r\n(struct tmComResPSFormatDescrHeader *)t;\r\nif (currpath == 1)\r\nencport = &dev->ports[SAA7164_PORT_ENC1];\r\nelse\r\nencport = &dev->ports[SAA7164_PORT_ENC2];\r\nmemcpy(&encport->hwcfg, vcoutputtermhdr,\r\nsizeof(*vcoutputtermhdr));\r\nsaa7164_api_configure_port_mpeg2ps(dev,\r\nencport, psfmt);\r\nbreak;\r\ncase VS_FORMAT_VBI:\r\nvbifmt =\r\n(struct tmComResVBIFormatDescrHeader *)t;\r\nif (currpath == 1)\r\nvbiport = &dev->ports[SAA7164_PORT_VBI1];\r\nelse\r\nvbiport = &dev->ports[SAA7164_PORT_VBI2];\r\nmemcpy(&vbiport->hwcfg, vcoutputtermhdr,\r\nsizeof(*vcoutputtermhdr));\r\nmemcpy(&vbiport->vbi_fmt_ntsc, vbifmt,\r\nsizeof(*vbifmt));\r\nsaa7164_api_configure_port_vbi(dev,\r\nvbiport);\r\nbreak;\r\ncase VS_FORMAT_RDS:\r\ndprintk(DBGLVL_API,\r\n" = VS_FORMAT_RDS\n");\r\nbreak;\r\ncase VS_FORMAT_UNCOMPRESSED:\r\ndprintk(DBGLVL_API,\r\n" = VS_FORMAT_UNCOMPRESSED\n");\r\nbreak;\r\ncase VS_FORMAT_TYPE:\r\ndprintk(DBGLVL_API,\r\n" = VS_FORMAT_TYPE\n");\r\nbreak;\r\ndefault:\r\ndprintk(DBGLVL_API,\r\n" = undefined (0x%x)\n",\r\nt->subtype);\r\n}\r\nnext_offset += t->len;\r\n}\r\nbreak;\r\ncase TUNER_UNIT:\r\ndprintk(DBGLVL_API, " TUNER_UNIT\n");\r\ntunerunithdr =\r\n(struct tmComResTunerDescrHeader *)(buf + idx);\r\ndprintk(DBGLVL_API, " unitid = 0x%x\n",\r\ntunerunithdr->unitid);\r\ndprintk(DBGLVL_API, " sourceid = 0x%x\n",\r\ntunerunithdr->sourceid);\r\ndprintk(DBGLVL_API, " iunit = 0x%x\n",\r\ntunerunithdr->iunit);\r\ndprintk(DBGLVL_API, " tuningstandards = 0x%x\n",\r\ntunerunithdr->tuningstandards);\r\ndprintk(DBGLVL_API, " controlsize = 0x%x\n",\r\ntunerunithdr->controlsize);\r\ndprintk(DBGLVL_API, " controls = 0x%x\n",\r\ntunerunithdr->controls);\r\nif (tunerunithdr->unitid == tunerunithdr->iunit) {\r\nif (currpath == 1)\r\nencport = &dev->ports[SAA7164_PORT_ENC1];\r\nelse\r\nencport = &dev->ports[SAA7164_PORT_ENC2];\r\nmemcpy(&encport->tunerunit, tunerunithdr,\r\nsizeof(struct tmComResTunerDescrHeader));\r\ndprintk(DBGLVL_API,\r\n" (becomes dev->enc[%d] tuner)\n",\r\nencport->nr);\r\n}\r\nbreak;\r\ncase VC_SELECTOR_UNIT:\r\npsel = (struct tmComResSelDescrHeader *)(buf + idx);\r\ndprintk(DBGLVL_API, " VC_SELECTOR_UNIT\n");\r\ndprintk(DBGLVL_API, " unitid = 0x%x\n",\r\npsel->unitid);\r\ndprintk(DBGLVL_API, " nrinpins = 0x%x\n",\r\npsel->nrinpins);\r\ndprintk(DBGLVL_API, " sourceid = 0x%x\n",\r\npsel->sourceid);\r\nbreak;\r\ncase VC_PROCESSING_UNIT:\r\npdh = (struct tmComResProcDescrHeader *)(buf + idx);\r\ndprintk(DBGLVL_API, " VC_PROCESSING_UNIT\n");\r\ndprintk(DBGLVL_API, " unitid = 0x%x\n",\r\npdh->unitid);\r\ndprintk(DBGLVL_API, " sourceid = 0x%x\n",\r\npdh->sourceid);\r\ndprintk(DBGLVL_API, " controlsize = 0x%x\n",\r\npdh->controlsize);\r\nif (pdh->controlsize == 0x04) {\r\nif (currpath == 1)\r\nencport = &dev->ports[SAA7164_PORT_ENC1];\r\nelse\r\nencport = &dev->ports[SAA7164_PORT_ENC2];\r\nmemcpy(&encport->vidproc, pdh,\r\nsizeof(struct tmComResProcDescrHeader));\r\ndprintk(DBGLVL_API, " (becomes dev->enc[%d])\n",\r\nencport->nr);\r\n}\r\nbreak;\r\ncase FEATURE_UNIT:\r\nafd = (struct tmComResAFeatureDescrHeader *)(buf + idx);\r\ndprintk(DBGLVL_API, " FEATURE_UNIT\n");\r\ndprintk(DBGLVL_API, " unitid = 0x%x\n",\r\nafd->unitid);\r\ndprintk(DBGLVL_API, " sourceid = 0x%x\n",\r\nafd->sourceid);\r\ndprintk(DBGLVL_API, " controlsize = 0x%x\n",\r\nafd->controlsize);\r\nif (currpath == 1)\r\nencport = &dev->ports[SAA7164_PORT_ENC1];\r\nelse\r\nencport = &dev->ports[SAA7164_PORT_ENC2];\r\nmemcpy(&encport->audfeat, afd,\r\nsizeof(struct tmComResAFeatureDescrHeader));\r\ndprintk(DBGLVL_API, " (becomes dev->enc[%d])\n",\r\nencport->nr);\r\nbreak;\r\ncase ENCODER_UNIT:\r\nedh = (struct tmComResEncoderDescrHeader *)(buf + idx);\r\ndprintk(DBGLVL_API, " ENCODER_UNIT\n");\r\ndprintk(DBGLVL_API, " subtype = 0x%x\n", edh->subtype);\r\ndprintk(DBGLVL_API, " unitid = 0x%x\n", edh->unitid);\r\ndprintk(DBGLVL_API, " vsourceid = 0x%x\n",\r\nedh->vsourceid);\r\ndprintk(DBGLVL_API, " asourceid = 0x%x\n",\r\nedh->asourceid);\r\ndprintk(DBGLVL_API, " iunit = 0x%x\n", edh->iunit);\r\nif (edh->iunit == edh->unitid) {\r\nif (currpath == 1)\r\nencport = &dev->ports[SAA7164_PORT_ENC1];\r\nelse\r\nencport = &dev->ports[SAA7164_PORT_ENC2];\r\nmemcpy(&encport->encunit, edh,\r\nsizeof(struct tmComResEncoderDescrHeader));\r\ndprintk(DBGLVL_API,\r\n" (becomes dev->enc[%d])\n",\r\nencport->nr);\r\n}\r\nbreak;\r\ncase EXTENSION_UNIT:\r\ndprintk(DBGLVL_API, " EXTENSION_UNIT\n");\r\nexthdr = (struct tmComResExtDevDescrHeader *)(buf + idx);\r\ndprintk(DBGLVL_API, " unitid = 0x%x\n",\r\nexthdr->unitid);\r\ndprintk(DBGLVL_API, " deviceid = 0x%x\n",\r\nexthdr->deviceid);\r\ndprintk(DBGLVL_API, " devicetype = 0x%x\n",\r\nexthdr->devicetype);\r\nif (exthdr->devicetype & 0x1)\r\ndprintk(DBGLVL_API, " = Decoder Device\n");\r\nif (exthdr->devicetype & 0x2)\r\ndprintk(DBGLVL_API, " = GPIO Source\n");\r\nif (exthdr->devicetype & 0x4)\r\ndprintk(DBGLVL_API, " = Video Decoder\n");\r\nif (exthdr->devicetype & 0x8)\r\ndprintk(DBGLVL_API, " = Audio Decoder\n");\r\nif (exthdr->devicetype & 0x20)\r\ndprintk(DBGLVL_API, " = Crossbar\n");\r\nif (exthdr->devicetype & 0x40)\r\ndprintk(DBGLVL_API, " = Tuner\n");\r\nif (exthdr->devicetype & 0x80)\r\ndprintk(DBGLVL_API, " = IF PLL\n");\r\nif (exthdr->devicetype & 0x100)\r\ndprintk(DBGLVL_API, " = Demodulator\n");\r\nif (exthdr->devicetype & 0x200)\r\ndprintk(DBGLVL_API, " = RDS Decoder\n");\r\nif (exthdr->devicetype & 0x400)\r\ndprintk(DBGLVL_API, " = Encoder\n");\r\nif (exthdr->devicetype & 0x800)\r\ndprintk(DBGLVL_API, " = IR Decoder\n");\r\nif (exthdr->devicetype & 0x1000)\r\ndprintk(DBGLVL_API, " = EEPROM\n");\r\nif (exthdr->devicetype & 0x2000)\r\ndprintk(DBGLVL_API,\r\n" = VBI Decoder\n");\r\nif (exthdr->devicetype & 0x10000)\r\ndprintk(DBGLVL_API,\r\n" = Streaming Device\n");\r\nif (exthdr->devicetype & 0x20000)\r\ndprintk(DBGLVL_API,\r\n" = DRM Device\n");\r\nif (exthdr->devicetype & 0x40000000)\r\ndprintk(DBGLVL_API,\r\n" = Generic Device\n");\r\nif (exthdr->devicetype & 0x80000000)\r\ndprintk(DBGLVL_API,\r\n" = Config Space Device\n");\r\ndprintk(DBGLVL_API, " numgpiopins = 0x%x\n",\r\nexthdr->numgpiopins);\r\ndprintk(DBGLVL_API, " numgpiogroups = 0x%x\n",\r\nexthdr->numgpiogroups);\r\ndprintk(DBGLVL_API, " controlsize = 0x%x\n",\r\nexthdr->controlsize);\r\nif (exthdr->devicetype & 0x80) {\r\nif (currpath == 1)\r\nencport = &dev->ports[SAA7164_PORT_ENC1];\r\nelse\r\nencport = &dev->ports[SAA7164_PORT_ENC2];\r\nmemcpy(&encport->ifunit, exthdr,\r\nsizeof(struct tmComResExtDevDescrHeader));\r\ndprintk(DBGLVL_API,\r\n" (becomes dev->enc[%d])\n",\r\nencport->nr);\r\n}\r\nbreak;\r\ncase PVC_INFRARED_UNIT:\r\ndprintk(DBGLVL_API, " PVC_INFRARED_UNIT\n");\r\nbreak;\r\ncase DRM_UNIT:\r\ndprintk(DBGLVL_API, " DRM_UNIT\n");\r\nbreak;\r\ndefault:\r\ndprintk(DBGLVL_API, "default %d\n", hdr->subtype);\r\n}\r\ndprintk(DBGLVL_API, " 1.%x\n", hdr->len);\r\ndprintk(DBGLVL_API, " 2.%x\n", hdr->type);\r\ndprintk(DBGLVL_API, " 3.%x\n", hdr->subtype);\r\ndprintk(DBGLVL_API, " 4.%x\n", hdr->unitid);\r\nidx += hdr->len;\r\n}\r\nreturn 0;\r\n}\r\nint saa7164_api_enum_subdevs(struct saa7164_dev *dev)\r\n{\r\nint ret;\r\nu32 buflen = 0;\r\nu8 *buf;\r\ndprintk(DBGLVL_API, "%s()\n", __func__);\r\nret = saa7164_cmd_send(dev, 0, GET_LEN,\r\nGET_DESCRIPTORS_CONTROL, sizeof(buflen), &buflen);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\ndprintk(DBGLVL_API, "%s() total descriptor size = %d bytes.\n",\r\n__func__, buflen);\r\nbuf = kzalloc(buflen, GFP_KERNEL);\r\nif (!buf)\r\nreturn SAA_ERR_NO_RESOURCES;\r\nret = saa7164_cmd_send(dev, 0, GET_CUR,\r\nGET_DESCRIPTORS_CONTROL, buflen, buf);\r\nif (ret != SAA_OK) {\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);\r\ngoto out;\r\n}\r\nif (saa_debug & DBGLVL_API)\r\nprint_hex_dump(KERN_INFO, "", DUMP_PREFIX_OFFSET, 16, 1, buf,\r\nbuflen & ~15, false);\r\nsaa7164_api_dump_subdevs(dev, buf, buflen);\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nint saa7164_api_i2c_read(struct saa7164_i2c *bus, u8 addr, u32 reglen, u8 *reg,\r\nu32 datalen, u8 *data)\r\n{\r\nstruct saa7164_dev *dev = bus->dev;\r\nu16 len = 0;\r\nint unitid;\r\nu8 buf[256];\r\nint ret;\r\ndprintk(DBGLVL_API, "%s()\n", __func__);\r\nif (reglen > 4)\r\nreturn -EIO;\r\nmemset(buf, 0, sizeof(buf));\r\nmemcpy((buf + 2 * sizeof(u32) + 0), reg, reglen);\r\n*((u32 *)(buf + 0 * sizeof(u32))) = reglen;\r\n*((u32 *)(buf + 1 * sizeof(u32))) = datalen;\r\nunitid = saa7164_i2caddr_to_unitid(bus, addr);\r\nif (unitid < 0) {\r\nprintk(KERN_ERR\r\n"%s() error, cannot translate regaddr 0x%x to unitid\n",\r\n__func__, addr);\r\nreturn -EIO;\r\n}\r\nret = saa7164_cmd_send(bus->dev, unitid, GET_LEN,\r\nEXU_REGISTER_ACCESS_CONTROL, sizeof(len), &len);\r\nif (ret != SAA_OK) {\r\nprintk(KERN_ERR "%s() error, ret(1) = 0x%x\n", __func__, ret);\r\nreturn -EIO;\r\n}\r\ndprintk(DBGLVL_API, "%s() len = %d bytes\n", __func__, len);\r\nif (saa_debug & DBGLVL_I2C)\r\nprint_hex_dump(KERN_INFO, "", DUMP_PREFIX_OFFSET, 16, 1, buf,\r\n32, false);\r\nret = saa7164_cmd_send(bus->dev, unitid, GET_CUR,\r\nEXU_REGISTER_ACCESS_CONTROL, len, &buf);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret(2) = 0x%x\n", __func__, ret);\r\nelse {\r\nif (saa_debug & DBGLVL_I2C)\r\nprint_hex_dump(KERN_INFO, "", DUMP_PREFIX_OFFSET, 16, 1,\r\nbuf, sizeof(buf), false);\r\nmemcpy(data, (buf + 2 * sizeof(u32) + reglen), datalen);\r\n}\r\nreturn ret == SAA_OK ? 0 : -EIO;\r\n}\r\nint saa7164_api_i2c_write(struct saa7164_i2c *bus, u8 addr, u32 datalen,\r\nu8 *data)\r\n{\r\nstruct saa7164_dev *dev = bus->dev;\r\nu16 len = 0;\r\nint unitid;\r\nint reglen;\r\nu8 buf[256];\r\nint ret;\r\ndprintk(DBGLVL_API, "%s()\n", __func__);\r\nif ((datalen == 0) || (datalen > 232))\r\nreturn -EIO;\r\nmemset(buf, 0, sizeof(buf));\r\nunitid = saa7164_i2caddr_to_unitid(bus, addr);\r\nif (unitid < 0) {\r\nprintk(KERN_ERR\r\n"%s() error, cannot translate regaddr 0x%x to unitid\n",\r\n__func__, addr);\r\nreturn -EIO;\r\n}\r\nreglen = saa7164_i2caddr_to_reglen(bus, addr);\r\nif (reglen < 0) {\r\nprintk(KERN_ERR\r\n"%s() error, cannot translate regaddr to reglen\n",\r\n__func__);\r\nreturn -EIO;\r\n}\r\nret = saa7164_cmd_send(bus->dev, unitid, GET_LEN,\r\nEXU_REGISTER_ACCESS_CONTROL, sizeof(len), &len);\r\nif (ret != SAA_OK) {\r\nprintk(KERN_ERR "%s() error, ret(1) = 0x%x\n", __func__, ret);\r\nreturn -EIO;\r\n}\r\ndprintk(DBGLVL_API, "%s() len = %d bytes\n", __func__, len);\r\n*((u32 *)(buf + 0 * sizeof(u32))) = reglen;\r\n*((u32 *)(buf + 1 * sizeof(u32))) = datalen - reglen;\r\nmemcpy((buf + 2 * sizeof(u32)), data, datalen);\r\nif (saa_debug & DBGLVL_I2C)\r\nprint_hex_dump(KERN_INFO, "", DUMP_PREFIX_OFFSET, 16, 1,\r\nbuf, sizeof(buf), false);\r\nret = saa7164_cmd_send(bus->dev, unitid, SET_CUR,\r\nEXU_REGISTER_ACCESS_CONTROL, len, &buf);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret(2) = 0x%x\n", __func__, ret);\r\nreturn ret == SAA_OK ? 0 : -EIO;\r\n}\r\nstatic int saa7164_api_modify_gpio(struct saa7164_dev *dev, u8 unitid,\r\nu8 pin, u8 state)\r\n{\r\nint ret;\r\nstruct tmComResGPIO t;\r\ndprintk(DBGLVL_API, "%s(0x%x, %d, %d)\n",\r\n__func__, unitid, pin, state);\r\nif ((pin > 7) || (state > 2))\r\nreturn SAA_ERR_BAD_PARAMETER;\r\nt.pin = pin;\r\nt.state = state;\r\nret = saa7164_cmd_send(dev, unitid, SET_CUR,\r\nEXU_GPIO_CONTROL, sizeof(t), &t);\r\nif (ret != SAA_OK)\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nint saa7164_api_set_gpiobit(struct saa7164_dev *dev, u8 unitid,\r\nu8 pin)\r\n{\r\nreturn saa7164_api_modify_gpio(dev, unitid, pin, 1);\r\n}\r\nint saa7164_api_clear_gpiobit(struct saa7164_dev *dev, u8 unitid,\r\nu8 pin)\r\n{\r\nreturn saa7164_api_modify_gpio(dev, unitid, pin, 0);\r\n}
