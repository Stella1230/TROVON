static bool mei_me_quirk_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nu32 reg;\r\nif (ent->device == MEI_DEV_ID_PBG_1) {\r\npci_read_config_dword(pdev, 0x48, &reg);\r\nif ((reg & 0x600) == 0x200) {\r\ndev_info(&pdev->dev, "Device doesn't have valid ME Interface\n");\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic int mei_me_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct mei_device *dev;\r\nstruct mei_me_hw *hw;\r\nint err;\r\nif (!mei_me_quirk_probe(pdev, ent)) {\r\nerr = -ENODEV;\r\ngoto end;\r\n}\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to enable pci device.\n");\r\ngoto end;\r\n}\r\npci_set_master(pdev);\r\nerr = pci_request_regions(pdev, KBUILD_MODNAME);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to get pci regions.\n");\r\ngoto disable_device;\r\n}\r\ndev = mei_me_dev_init(pdev);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto release_regions;\r\n}\r\nhw = to_me_hw(dev);\r\nhw->mem_addr = pci_iomap(pdev, 0, 0);\r\nif (!hw->mem_addr) {\r\ndev_err(&pdev->dev, "mapping I/O device memory failure.\n");\r\nerr = -ENOMEM;\r\ngoto free_device;\r\n}\r\npci_enable_msi(pdev);\r\nif (pci_dev_msi_enabled(pdev))\r\nerr = request_threaded_irq(pdev->irq,\r\nNULL,\r\nmei_me_irq_thread_handler,\r\nIRQF_ONESHOT, KBUILD_MODNAME, dev);\r\nelse\r\nerr = request_threaded_irq(pdev->irq,\r\nmei_me_irq_quick_handler,\r\nmei_me_irq_thread_handler,\r\nIRQF_SHARED, KBUILD_MODNAME, dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "request_threaded_irq failure. irq = %d\n",\r\npdev->irq);\r\ngoto disable_msi;\r\n}\r\nif (mei_start(dev)) {\r\ndev_err(&pdev->dev, "init hw failure.\n");\r\nerr = -ENODEV;\r\ngoto release_irq;\r\n}\r\nerr = mei_register(dev);\r\nif (err)\r\ngoto release_irq;\r\npci_set_drvdata(pdev, dev);\r\nschedule_delayed_work(&dev->timer_work, HZ);\r\npr_debug("initialization successful.\n");\r\nreturn 0;\r\nrelease_irq:\r\nmei_disable_interrupts(dev);\r\nflush_scheduled_work();\r\nfree_irq(pdev->irq, dev);\r\ndisable_msi:\r\npci_disable_msi(pdev);\r\npci_iounmap(pdev, hw->mem_addr);\r\nfree_device:\r\nkfree(dev);\r\nrelease_regions:\r\npci_release_regions(pdev);\r\ndisable_device:\r\npci_disable_device(pdev);\r\nend:\r\ndev_err(&pdev->dev, "initialization failed.\n");\r\nreturn err;\r\n}\r\nstatic void mei_me_remove(struct pci_dev *pdev)\r\n{\r\nstruct mei_device *dev;\r\nstruct mei_me_hw *hw;\r\ndev = pci_get_drvdata(pdev);\r\nif (!dev)\r\nreturn;\r\nhw = to_me_hw(dev);\r\ndev_err(&pdev->dev, "stop\n");\r\nmei_stop(dev);\r\nmei_disable_interrupts(dev);\r\nfree_irq(pdev->irq, dev);\r\npci_disable_msi(pdev);\r\npci_set_drvdata(pdev, NULL);\r\nif (hw->mem_addr)\r\npci_iounmap(pdev, hw->mem_addr);\r\nmei_deregister(dev);\r\nkfree(dev);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int mei_me_pci_suspend(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct mei_device *dev = pci_get_drvdata(pdev);\r\nif (!dev)\r\nreturn -ENODEV;\r\ndev_err(&pdev->dev, "suspend\n");\r\nmei_stop(dev);\r\nmei_disable_interrupts(dev);\r\nfree_irq(pdev->irq, dev);\r\npci_disable_msi(pdev);\r\nreturn 0;\r\n}\r\nstatic int mei_me_pci_resume(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct mei_device *dev;\r\nint err;\r\ndev = pci_get_drvdata(pdev);\r\nif (!dev)\r\nreturn -ENODEV;\r\npci_enable_msi(pdev);\r\nif (pci_dev_msi_enabled(pdev))\r\nerr = request_threaded_irq(pdev->irq,\r\nNULL,\r\nmei_me_irq_thread_handler,\r\nIRQF_ONESHOT, KBUILD_MODNAME, dev);\r\nelse\r\nerr = request_threaded_irq(pdev->irq,\r\nmei_me_irq_quick_handler,\r\nmei_me_irq_thread_handler,\r\nIRQF_SHARED, KBUILD_MODNAME, dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "request_threaded_irq failed: irq = %d.\n",\r\npdev->irq);\r\nreturn err;\r\n}\r\nmutex_lock(&dev->device_lock);\r\ndev->dev_state = MEI_DEV_POWER_UP;\r\nmei_clear_interrupts(dev);\r\nmei_reset(dev, 1);\r\nmutex_unlock(&dev->device_lock);\r\nschedule_delayed_work(&dev->timer_work, HZ);\r\nreturn err;\r\n}
