static int mv64x60_wdt_toggle_wdc(int enabled_predicate, int field_shift)\r\n{\r\nu32 data;\r\nu32 enabled;\r\nint ret = 0;\r\nspin_lock(&mv64x60_wdt_spinlock);\r\ndata = readl(mv64x60_wdt_regs + MV64x60_WDT_WDC_OFFSET);\r\nenabled = (data >> MV64x60_WDC_ENABLED_SHIFT) & 1;\r\nif ((enabled ^ enabled_predicate) == 0) {\r\ndata = (1 << field_shift) | mv64x60_wdt_count;\r\nwritel(data, mv64x60_wdt_regs + MV64x60_WDT_WDC_OFFSET);\r\ndata = (2 << field_shift) | mv64x60_wdt_count;\r\nwritel(data, mv64x60_wdt_regs + MV64x60_WDT_WDC_OFFSET);\r\nret = 1;\r\n}\r\nspin_unlock(&mv64x60_wdt_spinlock);\r\nreturn ret;\r\n}\r\nstatic void mv64x60_wdt_service(void)\r\n{\r\nmv64x60_wdt_toggle_wdc(MV64x60_WDC_ENABLED_TRUE,\r\nMV64x60_WDC_SERVICE_SHIFT);\r\n}\r\nstatic void mv64x60_wdt_handler_enable(void)\r\n{\r\nif (mv64x60_wdt_toggle_wdc(MV64x60_WDC_ENABLED_FALSE,\r\nMV64x60_WDC_ENABLE_SHIFT)) {\r\nmv64x60_wdt_service();\r\npr_notice("watchdog activated\n");\r\n}\r\n}\r\nstatic void mv64x60_wdt_handler_disable(void)\r\n{\r\nif (mv64x60_wdt_toggle_wdc(MV64x60_WDC_ENABLED_TRUE,\r\nMV64x60_WDC_ENABLE_SHIFT))\r\npr_notice("watchdog deactivated\n");\r\n}\r\nstatic void mv64x60_wdt_set_timeout(unsigned int timeout)\r\n{\r\nif (timeout > 0xFFFFFFFF / bus_clk)\r\ntimeout = 0xFFFFFFFF / bus_clk;\r\nmv64x60_wdt_count = timeout * bus_clk >> 8;\r\nmv64x60_wdt_timeout = timeout;\r\n}\r\nstatic int mv64x60_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(MV64x60_WDOG_FLAG_OPENED, &wdt_flags))\r\nreturn -EBUSY;\r\nif (nowayout)\r\n__module_get(THIS_MODULE);\r\nmv64x60_wdt_handler_enable();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int mv64x60_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nif (expect_close == 42)\r\nmv64x60_wdt_handler_disable();\r\nelse {\r\npr_crit("unexpected close, not stopping timer!\n");\r\nmv64x60_wdt_service();\r\n}\r\nexpect_close = 0;\r\nclear_bit(MV64x60_WDOG_FLAG_OPENED, &wdt_flags);\r\nreturn 0;\r\n}\r\nstatic ssize_t mv64x60_wdt_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\nexpect_close = 0;\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_close = 42;\r\n}\r\n}\r\nmv64x60_wdt_service();\r\n}\r\nreturn len;\r\n}\r\nstatic long mv64x60_wdt_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint timeout;\r\nint options;\r\nvoid __user *argp = (void __user *)arg;\r\nstatic const struct watchdog_info info = {\r\n.options = WDIOF_SETTIMEOUT |\r\nWDIOF_MAGICCLOSE |\r\nWDIOF_KEEPALIVEPING,\r\n.firmware_version = 0,\r\n.identity = "MV64x60 watchdog",\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nif (copy_to_user(argp, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nif (put_user(wdt_status, (int __user *)argp))\r\nreturn -EFAULT;\r\nwdt_status &= ~WDIOF_KEEPALIVEPING;\r\nbreak;\r\ncase WDIOC_GETTEMP:\r\nreturn -EOPNOTSUPP;\r\ncase WDIOC_SETOPTIONS:\r\nif (get_user(options, (int __user *)argp))\r\nreturn -EFAULT;\r\nif (options & WDIOS_DISABLECARD)\r\nmv64x60_wdt_handler_disable();\r\nif (options & WDIOS_ENABLECARD)\r\nmv64x60_wdt_handler_enable();\r\nbreak;\r\ncase WDIOC_KEEPALIVE:\r\nmv64x60_wdt_service();\r\nwdt_status |= WDIOF_KEEPALIVEPING;\r\nbreak;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(timeout, (int __user *)argp))\r\nreturn -EFAULT;\r\nmv64x60_wdt_set_timeout(timeout);\r\ncase WDIOC_GETTIMEOUT:\r\nif (put_user(mv64x60_wdt_timeout, (int __user *)argp))\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mv64x60_wdt_probe(struct platform_device *dev)\r\n{\r\nstruct mv64x60_wdt_pdata *pdata = dev->dev.platform_data;\r\nstruct resource *r;\r\nint timeout = 10;\r\nbus_clk = 133;\r\nif (pdata) {\r\ntimeout = pdata->timeout;\r\nbus_clk = pdata->bus_clk;\r\n}\r\nbus_clk++;\r\nbus_clk *= 1000000;\r\nr = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (!r)\r\nreturn -ENODEV;\r\nmv64x60_wdt_regs = devm_ioremap(&dev->dev, r->start, resource_size(r));\r\nif (mv64x60_wdt_regs == NULL)\r\nreturn -ENOMEM;\r\nmv64x60_wdt_set_timeout(timeout);\r\nmv64x60_wdt_handler_disable();\r\nreturn misc_register(&mv64x60_wdt_miscdev);\r\n}\r\nstatic int mv64x60_wdt_remove(struct platform_device *dev)\r\n{\r\nmisc_deregister(&mv64x60_wdt_miscdev);\r\nmv64x60_wdt_handler_disable();\r\nreturn 0;\r\n}\r\nstatic int __init mv64x60_wdt_init(void)\r\n{\r\npr_info("MV64x60 watchdog driver\n");\r\nreturn platform_driver_register(&mv64x60_wdt_driver);\r\n}\r\nstatic void __exit mv64x60_wdt_exit(void)\r\n{\r\nplatform_driver_unregister(&mv64x60_wdt_driver);\r\n}
