static u32\r\nzr36060_read (struct videocodec *codec,\r\nu16 reg)\r\n{\r\nstruct zoran *zr = (struct zoran *) codec->master_data->data;\r\n__u32 data;\r\nif (post_office_wait(zr)\r\n|| post_office_write(zr, 0, 1, reg >> 8)\r\n|| post_office_write(zr, 0, 2, reg & 0xff)) {\r\nreturn -1;\r\n}\r\ndata = post_office_read(zr, 0, 3) & 0xff;\r\nreturn data;\r\n}\r\nstatic void\r\nzr36060_write (struct videocodec *codec,\r\nu16 reg,\r\nu32 val)\r\n{\r\nstruct zoran *zr = (struct zoran *) codec->master_data->data;\r\nif (post_office_wait(zr)\r\n|| post_office_write(zr, 0, 1, reg >> 8)\r\n|| post_office_write(zr, 0, 2, reg & 0xff)) {\r\nreturn;\r\n}\r\npost_office_write(zr, 0, 3, val & 0xff);\r\n}\r\nstatic u32\r\nzr36050_read (struct videocodec *codec,\r\nu16 reg)\r\n{\r\nstruct zoran *zr = (struct zoran *) codec->master_data->data;\r\n__u32 data;\r\nif (post_office_wait(zr)\r\n|| post_office_write(zr, 1, 0, reg >> 2)) {\r\nreturn -1;\r\n}\r\ndata = post_office_read(zr, 0, reg & 0x03) & 0xff;\r\nreturn data;\r\n}\r\nstatic void\r\nzr36050_write (struct videocodec *codec,\r\nu16 reg,\r\nu32 val)\r\n{\r\nstruct zoran *zr = (struct zoran *) codec->master_data->data;\r\nif (post_office_wait(zr)\r\n|| post_office_write(zr, 1, 0, reg >> 2)) {\r\nreturn;\r\n}\r\npost_office_write(zr, 0, reg & 0x03, val & 0xff);\r\n}\r\nstatic u32\r\nzr36016_read (struct videocodec *codec,\r\nu16 reg)\r\n{\r\nstruct zoran *zr = (struct zoran *) codec->master_data->data;\r\n__u32 data;\r\nif (post_office_wait(zr)) {\r\nreturn -1;\r\n}\r\ndata = post_office_read(zr, 2, reg & 0x03) & 0xff;\r\nreturn data;\r\n}\r\nvoid\r\nzr36016_write (struct videocodec *codec,\r\nu16 reg,\r\nu32 val)\r\n{\r\nstruct zoran *zr = (struct zoran *) codec->master_data->data;\r\nif (post_office_wait(zr)) {\r\nreturn;\r\n}\r\npost_office_write(zr, 2, reg & 0x03, val & 0x0ff);\r\n}\r\nstatic void\r\ndc10_init (struct zoran *zr)\r\n{\r\ndprintk(3, KERN_DEBUG "%s: %s\n", ZR_DEVNAME(zr), __func__);\r\nGPIO(zr, 4, 0);\r\nGPIO(zr, 5, 1);\r\nGPIO(zr, 7, 0);\r\n}\r\nstatic void\r\ndc10plus_init (struct zoran *zr)\r\n{\r\ndprintk(3, KERN_DEBUG "%s: %s\n", ZR_DEVNAME(zr), __func__);\r\n}\r\nstatic void\r\nbuz_init (struct zoran *zr)\r\n{\r\ndprintk(3, KERN_DEBUG "%s: %s\n", ZR_DEVNAME(zr), __func__);\r\npci_write_config_dword(zr->pci_dev, 0xfc, 0x90680f15);\r\npci_write_config_dword(zr->pci_dev, 0x0c, 0x00012020);\r\npci_write_config_dword(zr->pci_dev, 0xe8, 0xc0200000);\r\n}\r\nstatic void\r\nlml33_init (struct zoran *zr)\r\n{\r\ndprintk(3, KERN_DEBUG "%s: %s\n", ZR_DEVNAME(zr), __func__);\r\nGPIO(zr, 2, 1);\r\n}\r\nstatic void\r\navs6eyes_init (struct zoran *zr)\r\n{\r\nint mux = default_mux;\r\nGPIO(zr, 4, 1);\r\nudelay(2);\r\nGPIO(zr, 0, 1);\r\nGPIO(zr, 1, 0);\r\nGPIO(zr, 2, mux & 1);\r\nGPIO(zr, 3, 0);\r\nGPIO(zr, 4, 0);\r\nGPIO(zr, 5, mux & 2);\r\nGPIO(zr, 6, 0);\r\nGPIO(zr, 7, mux & 4);\r\n}\r\nstatic char *\r\ncodecid_to_modulename (u16 codecid)\r\n{\r\nchar *name = NULL;\r\nswitch (codecid) {\r\ncase CODEC_TYPE_ZR36060:\r\nname = "zr36060";\r\nbreak;\r\ncase CODEC_TYPE_ZR36050:\r\nname = "zr36050";\r\nbreak;\r\ncase CODEC_TYPE_ZR36016:\r\nname = "zr36016";\r\nbreak;\r\n}\r\nreturn name;\r\n}\r\nstatic int\r\nzoran_i2c_getsda (void *data)\r\n{\r\nstruct zoran *zr = (struct zoran *) data;\r\nreturn (btread(ZR36057_I2CBR) >> 1) & 1;\r\n}\r\nstatic int\r\nzoran_i2c_getscl (void *data)\r\n{\r\nstruct zoran *zr = (struct zoran *) data;\r\nreturn btread(ZR36057_I2CBR) & 1;\r\n}\r\nstatic void\r\nzoran_i2c_setsda (void *data,\r\nint state)\r\n{\r\nstruct zoran *zr = (struct zoran *) data;\r\nif (state)\r\nzr->i2cbr |= 2;\r\nelse\r\nzr->i2cbr &= ~2;\r\nbtwrite(zr->i2cbr, ZR36057_I2CBR);\r\n}\r\nstatic void\r\nzoran_i2c_setscl (void *data,\r\nint state)\r\n{\r\nstruct zoran *zr = (struct zoran *) data;\r\nif (state)\r\nzr->i2cbr |= 1;\r\nelse\r\nzr->i2cbr &= ~1;\r\nbtwrite(zr->i2cbr, ZR36057_I2CBR);\r\n}\r\nstatic int\r\nzoran_register_i2c (struct zoran *zr)\r\n{\r\nzr->i2c_algo = zoran_i2c_bit_data_template;\r\nzr->i2c_algo.data = zr;\r\nstrlcpy(zr->i2c_adapter.name, ZR_DEVNAME(zr),\r\nsizeof(zr->i2c_adapter.name));\r\ni2c_set_adapdata(&zr->i2c_adapter, &zr->v4l2_dev);\r\nzr->i2c_adapter.algo_data = &zr->i2c_algo;\r\nzr->i2c_adapter.dev.parent = &zr->pci_dev->dev;\r\nreturn i2c_bit_add_bus(&zr->i2c_adapter);\r\n}\r\nstatic void\r\nzoran_unregister_i2c (struct zoran *zr)\r\n{\r\ni2c_del_adapter(&zr->i2c_adapter);\r\n}\r\nint\r\nzoran_check_jpg_settings (struct zoran *zr,\r\nstruct zoran_jpg_settings *settings,\r\nint try)\r\n{\r\nint err = 0, err0 = 0;\r\ndprintk(4,\r\nKERN_DEBUG\r\n"%s: %s - dec: %d, Hdcm: %d, Vdcm: %d, Tdcm: %d\n",\r\nZR_DEVNAME(zr), __func__, settings->decimation, settings->HorDcm,\r\nsettings->VerDcm, settings->TmpDcm);\r\ndprintk(4,\r\nKERN_DEBUG\r\n"%s: %s - x: %d, y: %d, w: %d, y: %d\n",\r\nZR_DEVNAME(zr), __func__, settings->img_x, settings->img_y,\r\nsettings->img_width, settings->img_height);\r\nswitch (settings->decimation) {\r\ncase 1:\r\nsettings->HorDcm = 1;\r\nsettings->VerDcm = 1;\r\nsettings->TmpDcm = 1;\r\nsettings->field_per_buff = 2;\r\nsettings->img_x = 0;\r\nsettings->img_y = 0;\r\nsettings->img_width = BUZ_MAX_WIDTH;\r\nsettings->img_height = BUZ_MAX_HEIGHT / 2;\r\nbreak;\r\ncase 2:\r\nsettings->HorDcm = 2;\r\nsettings->VerDcm = 1;\r\nsettings->TmpDcm = 2;\r\nsettings->field_per_buff = 1;\r\nsettings->img_x = (BUZ_MAX_WIDTH == 720) ? 8 : 0;\r\nsettings->img_y = 0;\r\nsettings->img_width =\r\n(BUZ_MAX_WIDTH == 720) ? 704 : BUZ_MAX_WIDTH;\r\nsettings->img_height = BUZ_MAX_HEIGHT / 2;\r\nbreak;\r\ncase 4:\r\nif (zr->card.type == DC10_new) {\r\ndprintk(1,\r\nKERN_DEBUG\r\n"%s: %s - HDec by 4 is not supported on the DC10\n",\r\nZR_DEVNAME(zr), __func__);\r\nerr0++;\r\nbreak;\r\n}\r\nsettings->HorDcm = 4;\r\nsettings->VerDcm = 2;\r\nsettings->TmpDcm = 2;\r\nsettings->field_per_buff = 1;\r\nsettings->img_x = (BUZ_MAX_WIDTH == 720) ? 8 : 0;\r\nsettings->img_y = 0;\r\nsettings->img_width =\r\n(BUZ_MAX_WIDTH == 720) ? 704 : BUZ_MAX_WIDTH;\r\nsettings->img_height = BUZ_MAX_HEIGHT / 2;\r\nbreak;\r\ncase 0:\r\nif (settings->HorDcm != 1 && settings->HorDcm != 2 &&\r\n(zr->card.type == DC10_new || settings->HorDcm != 4)) {\r\nsettings->HorDcm = clamp(settings->HorDcm, 1, 2);\r\nerr0++;\r\n}\r\nif (settings->VerDcm != 1 && settings->VerDcm != 2) {\r\nsettings->VerDcm = clamp(settings->VerDcm, 1, 2);\r\nerr0++;\r\n}\r\nif (settings->TmpDcm != 1 && settings->TmpDcm != 2) {\r\nsettings->TmpDcm = clamp(settings->TmpDcm, 1, 2);\r\nerr0++;\r\n}\r\nif (settings->field_per_buff != 1 &&\r\nsettings->field_per_buff != 2) {\r\nsettings->field_per_buff = clamp(settings->field_per_buff, 1, 2);\r\nerr0++;\r\n}\r\nif (settings->img_x < 0) {\r\nsettings->img_x = 0;\r\nerr0++;\r\n}\r\nif (settings->img_y < 0) {\r\nsettings->img_y = 0;\r\nerr0++;\r\n}\r\nif (settings->img_width < 0 || settings->img_width > BUZ_MAX_WIDTH) {\r\nsettings->img_width = clamp(settings->img_width, 0, (int)BUZ_MAX_WIDTH);\r\nerr0++;\r\n}\r\nif (settings->img_height < 0 || settings->img_height > BUZ_MAX_HEIGHT / 2) {\r\nsettings->img_height = clamp(settings->img_height, 0, BUZ_MAX_HEIGHT / 2);\r\nerr0++;\r\n}\r\nif (settings->img_x + settings->img_width > BUZ_MAX_WIDTH) {\r\nsettings->img_x = BUZ_MAX_WIDTH - settings->img_width;\r\nerr0++;\r\n}\r\nif (settings->img_y + settings->img_height > BUZ_MAX_HEIGHT / 2) {\r\nsettings->img_y = BUZ_MAX_HEIGHT / 2 - settings->img_height;\r\nerr0++;\r\n}\r\nif (settings->img_width % (16 * settings->HorDcm) != 0) {\r\nsettings->img_width -= settings->img_width % (16 * settings->HorDcm);\r\nif (settings->img_width == 0)\r\nsettings->img_width = 16 * settings->HorDcm;\r\nerr0++;\r\n}\r\nif (settings->img_height % (8 * settings->VerDcm) != 0) {\r\nsettings->img_height -= settings->img_height % (8 * settings->VerDcm);\r\nif (settings->img_height == 0)\r\nsettings->img_height = 8 * settings->VerDcm;\r\nerr0++;\r\n}\r\nif (!try && err0) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - error in params for decimation = 0\n",\r\nZR_DEVNAME(zr), __func__);\r\nerr++;\r\n}\r\nbreak;\r\ndefault:\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - decimation = %d, must be 0, 1, 2 or 4\n",\r\nZR_DEVNAME(zr), __func__, settings->decimation);\r\nerr++;\r\nbreak;\r\n}\r\nif (settings->jpg_comp.quality > 100)\r\nsettings->jpg_comp.quality = 100;\r\nif (settings->jpg_comp.quality < 5)\r\nsettings->jpg_comp.quality = 5;\r\nif (settings->jpg_comp.APPn < 0)\r\nsettings->jpg_comp.APPn = 0;\r\nif (settings->jpg_comp.APPn > 15)\r\nsettings->jpg_comp.APPn = 15;\r\nif (settings->jpg_comp.APP_len < 0)\r\nsettings->jpg_comp.APP_len = 0;\r\nif (settings->jpg_comp.APP_len > 60)\r\nsettings->jpg_comp.APP_len = 60;\r\nif (settings->jpg_comp.COM_len < 0)\r\nsettings->jpg_comp.COM_len = 0;\r\nif (settings->jpg_comp.COM_len > 60)\r\nsettings->jpg_comp.COM_len = 60;\r\nif (err)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nvoid\r\nzoran_open_init_params (struct zoran *zr)\r\n{\r\nint i;\r\nzr->overlay_settings.is_set = 0;\r\nzr->overlay_mask = NULL;\r\nzr->overlay_active = ZORAN_FREE;\r\nzr->v4l_memgrab_active = 0;\r\nzr->v4l_overlay_active = 0;\r\nzr->v4l_grab_frame = NO_GRAB_ACTIVE;\r\nzr->v4l_grab_seq = 0;\r\nzr->v4l_settings.width = 192;\r\nzr->v4l_settings.height = 144;\r\nzr->v4l_settings.format = &zoran_formats[7];\r\nzr->v4l_settings.bytesperline =\r\nzr->v4l_settings.width *\r\n((zr->v4l_settings.format->depth + 7) / 8);\r\nzr->v4l_pend_tail = 0;\r\nzr->v4l_pend_head = 0;\r\nzr->v4l_sync_tail = 0;\r\nzr->v4l_buffers.active = ZORAN_FREE;\r\nfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\r\nzr->v4l_buffers.buffer[i].state = BUZ_STATE_USER;\r\n}\r\nzr->v4l_buffers.allocated = 0;\r\nfor (i = 0; i < BUZ_MAX_FRAME; i++) {\r\nzr->jpg_buffers.buffer[i].state = BUZ_STATE_USER;\r\n}\r\nzr->jpg_buffers.active = ZORAN_FREE;\r\nzr->jpg_buffers.allocated = 0;\r\nzr->jpg_settings.decimation = 1;\r\nzr->jpg_settings.jpg_comp.quality = 50;\r\nif (zr->card.type != BUZ)\r\nzr->jpg_settings.odd_even = 1;\r\nelse\r\nzr->jpg_settings.odd_even = 0;\r\nzr->jpg_settings.jpg_comp.APPn = 0;\r\nzr->jpg_settings.jpg_comp.APP_len = 0;\r\nmemset(zr->jpg_settings.jpg_comp.APP_data, 0,\r\nsizeof(zr->jpg_settings.jpg_comp.APP_data));\r\nzr->jpg_settings.jpg_comp.COM_len = 0;\r\nmemset(zr->jpg_settings.jpg_comp.COM_data, 0,\r\nsizeof(zr->jpg_settings.jpg_comp.COM_data));\r\nzr->jpg_settings.jpg_comp.jpeg_markers =\r\nV4L2_JPEG_MARKER_DHT | V4L2_JPEG_MARKER_DQT;\r\ni = zoran_check_jpg_settings(zr, &zr->jpg_settings, 0);\r\nif (i)\r\ndprintk(1, KERN_ERR "%s: %s internal error\n",\r\nZR_DEVNAME(zr), __func__);\r\nclear_interrupt_counters(zr);\r\nzr->testing = 0;\r\n}\r\nstatic void test_interrupts (struct zoran *zr)\r\n{\r\nDEFINE_WAIT(wait);\r\nint timeout, icr;\r\nclear_interrupt_counters(zr);\r\nzr->testing = 1;\r\nicr = btread(ZR36057_ICR);\r\nbtwrite(0x78000000 | ZR36057_ICR_IntPinEn, ZR36057_ICR);\r\nprepare_to_wait(&zr->test_q, &wait, TASK_INTERRUPTIBLE);\r\ntimeout = schedule_timeout(HZ);\r\nfinish_wait(&zr->test_q, &wait);\r\nbtwrite(0, ZR36057_ICR);\r\nbtwrite(0x78000000, ZR36057_ISR);\r\nzr->testing = 0;\r\ndprintk(5, KERN_INFO "%s: Testing interrupts...\n", ZR_DEVNAME(zr));\r\nif (timeout) {\r\ndprintk(1, ": time spent: %d\n", 1 * HZ - timeout);\r\n}\r\nif (zr36067_debug > 1)\r\nprint_interrupts(zr);\r\nbtwrite(icr, ZR36057_ICR);\r\n}\r\nstatic int zr36057_init (struct zoran *zr)\r\n{\r\nint j, err;\r\ndprintk(1,\r\nKERN_INFO\r\n"%s: %s - initializing card[%d], zr=%p\n",\r\nZR_DEVNAME(zr), __func__, zr->id, zr);\r\nzr->user = 0;\r\ninit_waitqueue_head(&zr->v4l_capq);\r\ninit_waitqueue_head(&zr->jpg_capq);\r\ninit_waitqueue_head(&zr->test_q);\r\nzr->jpg_buffers.allocated = 0;\r\nzr->v4l_buffers.allocated = 0;\r\nzr->vbuf_base = (void *) vidmem;\r\nzr->vbuf_width = 0;\r\nzr->vbuf_height = 0;\r\nzr->vbuf_depth = 0;\r\nzr->vbuf_bytesperline = 0;\r\nif (default_norm < 0 || default_norm > 2)\r\ndefault_norm = 0;\r\nif (default_norm == 0) {\r\nzr->norm = V4L2_STD_PAL;\r\nzr->timing = zr->card.tvn[0];\r\n} else if (default_norm == 1) {\r\nzr->norm = V4L2_STD_NTSC;\r\nzr->timing = zr->card.tvn[1];\r\n} else {\r\nzr->norm = V4L2_STD_SECAM;\r\nzr->timing = zr->card.tvn[2];\r\n}\r\nif (zr->timing == NULL) {\r\ndprintk(1,\r\nKERN_WARNING\r\n"%s: %s - default TV standard not supported by hardware. PAL will be used.\n",\r\nZR_DEVNAME(zr), __func__);\r\nzr->norm = V4L2_STD_PAL;\r\nzr->timing = zr->card.tvn[0];\r\n}\r\nif (default_input > zr->card.inputs-1) {\r\ndprintk(1,\r\nKERN_WARNING\r\n"%s: default_input value %d out of range (0-%d)\n",\r\nZR_DEVNAME(zr), default_input, zr->card.inputs-1);\r\ndefault_input = 0;\r\n}\r\nzr->input = default_input;\r\nzoran_open_init_params(zr);\r\nzr->stat_com = kzalloc(BUZ_NUM_STAT_COM * 4, GFP_KERNEL);\r\nzr->video_dev = video_device_alloc();\r\nif (!zr->stat_com || !zr->video_dev) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - kmalloc (STAT_COM) failed\n",\r\nZR_DEVNAME(zr), __func__);\r\nerr = -ENOMEM;\r\ngoto exit_free;\r\n}\r\nfor (j = 0; j < BUZ_NUM_STAT_COM; j++) {\r\nzr->stat_com[j] = cpu_to_le32(1);\r\n}\r\nmemcpy(zr->video_dev, &zoran_template, sizeof(zoran_template));\r\nzr->video_dev->v4l2_dev = &zr->v4l2_dev;\r\nstrcpy(zr->video_dev->name, ZR_DEVNAME(zr));\r\nzr->video_dev->vfl_dir = VFL_DIR_M2M;\r\nerr = video_register_device(zr->video_dev, VFL_TYPE_GRABBER, video_nr[zr->id]);\r\nif (err < 0)\r\ngoto exit_free;\r\nvideo_set_drvdata(zr->video_dev, zr);\r\nzoran_init_hardware(zr);\r\nif (zr36067_debug > 2)\r\ndetect_guest_activity(zr);\r\ntest_interrupts(zr);\r\nif (!pass_through) {\r\ndecoder_call(zr, video, s_stream, 0);\r\nencoder_call(zr, video, s_routing, 2, 0, 0);\r\n}\r\nzr->zoran_proc = NULL;\r\nzr->initialized = 1;\r\nreturn 0;\r\nexit_free:\r\nkfree(zr->stat_com);\r\nkfree(zr->video_dev);\r\nreturn err;\r\n}\r\nstatic void zoran_remove(struct pci_dev *pdev)\r\n{\r\nstruct v4l2_device *v4l2_dev = dev_get_drvdata(&pdev->dev);\r\nstruct zoran *zr = to_zoran(v4l2_dev);\r\nif (!zr->initialized)\r\ngoto exit_free;\r\nif (zr->codec) {\r\nstruct videocodec_master *master = zr->codec->master_data;\r\nvideocodec_detach(zr->codec);\r\nkfree(master);\r\n}\r\nif (zr->vfe) {\r\nstruct videocodec_master *master = zr->vfe->master_data;\r\nvideocodec_detach(zr->vfe);\r\nkfree(master);\r\n}\r\nzoran_unregister_i2c(zr);\r\nzoran_set_pci_master(zr, 0);\r\nbtwrite(0, ZR36057_SPGPPCR);\r\nfree_irq(zr->pci_dev->irq, zr);\r\nkfree(zr->stat_com);\r\nzoran_proc_cleanup(zr);\r\niounmap(zr->zr36057_mem);\r\npci_disable_device(zr->pci_dev);\r\nvideo_unregister_device(zr->video_dev);\r\nexit_free:\r\nv4l2_device_unregister(&zr->v4l2_dev);\r\nkfree(zr);\r\n}\r\nvoid\r\nzoran_vdev_release (struct video_device *vdev)\r\n{\r\nkfree(vdev);\r\n}\r\nstatic struct videocodec_master *zoran_setup_videocodec(struct zoran *zr,\r\nint type)\r\n{\r\nstruct videocodec_master *m = NULL;\r\nm = kmalloc(sizeof(struct videocodec_master), GFP_KERNEL);\r\nif (!m) {\r\ndprintk(1, KERN_ERR "%s: %s - no memory\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn m;\r\n}\r\nm->magic = 0L;\r\nm->type = 0;\r\nm->flags = CODEC_FLAG_ENCODER | CODEC_FLAG_DECODER;\r\nstrlcpy(m->name, ZR_DEVNAME(zr), sizeof(m->name));\r\nm->data = zr;\r\nswitch (type)\r\n{\r\ncase CODEC_TYPE_ZR36060:\r\nm->readreg = zr36060_read;\r\nm->writereg = zr36060_write;\r\nm->flags |= CODEC_FLAG_JPEG | CODEC_FLAG_VFE;\r\nbreak;\r\ncase CODEC_TYPE_ZR36050:\r\nm->readreg = zr36050_read;\r\nm->writereg = zr36050_write;\r\nm->flags |= CODEC_FLAG_JPEG;\r\nbreak;\r\ncase CODEC_TYPE_ZR36016:\r\nm->readreg = zr36016_read;\r\nm->writereg = zr36016_write;\r\nm->flags |= CODEC_FLAG_VFE;\r\nbreak;\r\n}\r\nreturn m;\r\n}\r\nstatic void zoran_subdev_notify(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\r\n{\r\nstruct zoran *zr = to_zoran(sd->v4l2_dev);\r\nif (cmd == BT819_FIFO_RESET_LOW)\r\nGPIO(zr, 7, 0);\r\nelse if (cmd == BT819_FIFO_RESET_HIGH)\r\nGPIO(zr, 7, 1);\r\n}\r\nstatic int zoran_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nunsigned char latency, need_latency;\r\nstruct zoran *zr;\r\nint result;\r\nstruct videocodec_master *master_vfe = NULL;\r\nstruct videocodec_master *master_codec = NULL;\r\nint card_num;\r\nchar *codec_name, *vfe_name;\r\nunsigned int nr;\r\nnr = zoran_num++;\r\nif (nr >= BUZ_MAX) {\r\ndprintk(1, KERN_ERR "%s: driver limited to %d card(s) maximum\n",\r\nZORAN_NAME, BUZ_MAX);\r\nreturn -ENOENT;\r\n}\r\nzr = kzalloc(sizeof(struct zoran), GFP_KERNEL);\r\nif (!zr) {\r\ndprintk(1, KERN_ERR "%s: %s - kzalloc failed\n",\r\nZORAN_NAME, __func__);\r\nreturn -ENOMEM;\r\n}\r\nzr->v4l2_dev.notify = zoran_subdev_notify;\r\nif (v4l2_device_register(&pdev->dev, &zr->v4l2_dev))\r\ngoto zr_free_mem;\r\nzr->pci_dev = pdev;\r\nzr->id = nr;\r\nsnprintf(ZR_DEVNAME(zr), sizeof(ZR_DEVNAME(zr)), "MJPEG[%u]", zr->id);\r\nspin_lock_init(&zr->spinlock);\r\nmutex_init(&zr->resource_lock);\r\nmutex_init(&zr->other_lock);\r\nif (pci_enable_device(pdev))\r\ngoto zr_unreg;\r\nzr->revision = zr->pci_dev->revision;\r\ndprintk(1,\r\nKERN_INFO\r\n"%s: Zoran ZR360%c7 (rev %d), irq: %d, memory: 0x%08llx\n",\r\nZR_DEVNAME(zr), zr->revision < 2 ? '5' : '6', zr->revision,\r\nzr->pci_dev->irq, (uint64_t)pci_resource_start(zr->pci_dev, 0));\r\nif (zr->revision >= 2) {\r\ndprintk(1,\r\nKERN_INFO\r\n"%s: Subsystem vendor=0x%04x id=0x%04x\n",\r\nZR_DEVNAME(zr), zr->pci_dev->subsystem_vendor,\r\nzr->pci_dev->subsystem_device);\r\n}\r\nif (card[nr] == -1) {\r\nif (zr->revision < 2) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: No card type specified, please use the card=X module parameter\n",\r\nZR_DEVNAME(zr));\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: It is not possible to auto-detect ZR36057 based cards\n",\r\nZR_DEVNAME(zr));\r\ngoto zr_unreg;\r\n}\r\ncard_num = ent->driver_data;\r\nif (card_num >= NUM_CARDS) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: Unknown card, try specifying card=X module parameter\n",\r\nZR_DEVNAME(zr));\r\ngoto zr_unreg;\r\n}\r\ndprintk(3,\r\nKERN_DEBUG\r\n"%s: %s() - card %s detected\n",\r\nZR_DEVNAME(zr), __func__, zoran_cards[card_num].name);\r\n} else {\r\ncard_num = card[nr];\r\nif (card_num >= NUM_CARDS || card_num < 0) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: User specified card type %d out of range (0 .. %d)\n",\r\nZR_DEVNAME(zr), card_num, NUM_CARDS - 1);\r\ngoto zr_unreg;\r\n}\r\n}\r\nzr->card = zoran_cards[card_num];\r\nsnprintf(ZR_DEVNAME(zr), sizeof(ZR_DEVNAME(zr)),\r\n"%s[%u]", zr->card.name, zr->id);\r\nzr->zr36057_mem = pci_ioremap_bar(zr->pci_dev, 0);\r\nif (!zr->zr36057_mem) {\r\ndprintk(1, KERN_ERR "%s: %s() - ioremap failed\n",\r\nZR_DEVNAME(zr), __func__);\r\ngoto zr_unreg;\r\n}\r\nresult = request_irq(zr->pci_dev->irq, zoran_irq,\r\nIRQF_SHARED | IRQF_DISABLED, ZR_DEVNAME(zr), zr);\r\nif (result < 0) {\r\nif (result == -EINVAL) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - bad irq number or handler\n",\r\nZR_DEVNAME(zr), __func__);\r\n} else if (result == -EBUSY) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - IRQ %d busy, change your PnP config in BIOS\n",\r\nZR_DEVNAME(zr), __func__, zr->pci_dev->irq);\r\n} else {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - can't assign irq, error code %d\n",\r\nZR_DEVNAME(zr), __func__, result);\r\n}\r\ngoto zr_unmap;\r\n}\r\npci_read_config_byte(zr->pci_dev, PCI_LATENCY_TIMER,\r\n&latency);\r\nneed_latency = zr->revision > 1 ? 32 : 48;\r\nif (latency != need_latency) {\r\ndprintk(2, KERN_INFO "%s: Changing PCI latency from %d to %d\n",\r\nZR_DEVNAME(zr), latency, need_latency);\r\npci_write_config_byte(zr->pci_dev, PCI_LATENCY_TIMER,\r\nneed_latency);\r\n}\r\nzr36057_restart(zr);\r\ndprintk(2, KERN_INFO "%s: Initializing i2c bus...\n",\r\nZR_DEVNAME(zr));\r\nif (zoran_register_i2c(zr) < 0) {\r\ndprintk(1, KERN_ERR "%s: %s - can't initialize i2c bus\n",\r\nZR_DEVNAME(zr), __func__);\r\ngoto zr_free_irq;\r\n}\r\nzr->decoder = v4l2_i2c_new_subdev(&zr->v4l2_dev,\r\n&zr->i2c_adapter, zr->card.i2c_decoder,\r\n0, zr->card.addrs_decoder);\r\nif (zr->card.i2c_encoder)\r\nzr->encoder = v4l2_i2c_new_subdev(&zr->v4l2_dev,\r\n&zr->i2c_adapter, zr->card.i2c_encoder,\r\n0, zr->card.addrs_encoder);\r\ndprintk(2,\r\nKERN_INFO "%s: Initializing videocodec bus...\n",\r\nZR_DEVNAME(zr));\r\nif (zr->card.video_codec) {\r\ncodec_name = codecid_to_modulename(zr->card.video_codec);\r\nif (codec_name) {\r\nresult = request_module(codec_name);\r\nif (result) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: failed to load modules %s: %d\n",\r\nZR_DEVNAME(zr), codec_name, result);\r\n}\r\n}\r\n}\r\nif (zr->card.video_vfe) {\r\nvfe_name = codecid_to_modulename(zr->card.video_vfe);\r\nif (vfe_name) {\r\nresult = request_module(vfe_name);\r\nif (result < 0) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: failed to load modules %s: %d\n",\r\nZR_DEVNAME(zr), vfe_name, result);\r\n}\r\n}\r\n}\r\njpeg_codec_sleep(zr, 1);\r\njpeg_codec_reset(zr);\r\nif (zr->card.video_codec != 0) {\r\nmaster_codec = zoran_setup_videocodec(zr, zr->card.video_codec);\r\nif (!master_codec)\r\ngoto zr_unreg_i2c;\r\nzr->codec = videocodec_attach(master_codec);\r\nif (!zr->codec) {\r\ndprintk(1, KERN_ERR "%s: %s - no codec found\n",\r\nZR_DEVNAME(zr), __func__);\r\ngoto zr_free_codec;\r\n}\r\nif (zr->codec->type != zr->card.video_codec) {\r\ndprintk(1, KERN_ERR "%s: %s - wrong codec\n",\r\nZR_DEVNAME(zr), __func__);\r\ngoto zr_detach_codec;\r\n}\r\n}\r\nif (zr->card.video_vfe != 0) {\r\nmaster_vfe = zoran_setup_videocodec(zr, zr->card.video_vfe);\r\nif (!master_vfe)\r\ngoto zr_detach_codec;\r\nzr->vfe = videocodec_attach(master_vfe);\r\nif (!zr->vfe) {\r\ndprintk(1, KERN_ERR "%s: %s - no VFE found\n",\r\nZR_DEVNAME(zr), __func__);\r\ngoto zr_free_vfe;\r\n}\r\nif (zr->vfe->type != zr->card.video_vfe) {\r\ndprintk(1, KERN_ERR "%s: %s = wrong VFE\n",\r\nZR_DEVNAME(zr), __func__);\r\ngoto zr_detach_vfe;\r\n}\r\n}\r\nif ((pci_pci_problems & PCIPCI_NATOMA) && zr->revision <= 1) {\r\nzr->jpg_buffers.need_contiguous = 1;\r\ndprintk(1, KERN_INFO\r\n"%s: ZR36057/Natoma bug, max. buffer size is 128K\n",\r\nZR_DEVNAME(zr));\r\n}\r\nif (zr36057_init(zr) < 0)\r\ngoto zr_detach_vfe;\r\nzoran_proc_init(zr);\r\nreturn 0;\r\nzr_detach_vfe:\r\nvideocodec_detach(zr->vfe);\r\nzr_free_vfe:\r\nkfree(master_vfe);\r\nzr_detach_codec:\r\nvideocodec_detach(zr->codec);\r\nzr_free_codec:\r\nkfree(master_codec);\r\nzr_unreg_i2c:\r\nzoran_unregister_i2c(zr);\r\nzr_free_irq:\r\nbtwrite(0, ZR36057_SPGPPCR);\r\nfree_irq(zr->pci_dev->irq, zr);\r\nzr_unmap:\r\niounmap(zr->zr36057_mem);\r\nzr_unreg:\r\nv4l2_device_unregister(&zr->v4l2_dev);\r\nzr_free_mem:\r\nkfree(zr);\r\nreturn -ENODEV;\r\n}\r\nstatic int __init zoran_init(void)\r\n{\r\nint res;\r\nprintk(KERN_INFO "Zoran MJPEG board driver version %s\n",\r\nZORAN_VERSION);\r\nif (v4l_nbufs < 2)\r\nv4l_nbufs = 2;\r\nif (v4l_nbufs > VIDEO_MAX_FRAME)\r\nv4l_nbufs = VIDEO_MAX_FRAME;\r\nv4l_bufsize = PAGE_ALIGN(v4l_bufsize * 1024);\r\nif (v4l_bufsize < 32768)\r\nv4l_bufsize = 32768;\r\nif (v4l_bufsize > 2048 * 1024)\r\nv4l_bufsize = 2048 * 1024;\r\nif (jpg_nbufs < 4)\r\njpg_nbufs = 4;\r\nif (jpg_nbufs > BUZ_MAX_FRAME)\r\njpg_nbufs = BUZ_MAX_FRAME;\r\njpg_bufsize = PAGE_ALIGN(jpg_bufsize * 1024);\r\nif (jpg_bufsize < 8192)\r\njpg_bufsize = 8192;\r\nif (jpg_bufsize > (512 * 1024))\r\njpg_bufsize = 512 * 1024;\r\nif (vidmem) {\r\ndprintk(1,\r\nKERN_INFO\r\n"%s: Using supplied video memory base address @ 0x%lx\n",\r\nZORAN_NAME, vidmem);\r\n}\r\nif (pci_pci_problems & (PCIPCI_FAIL|PCIAGP_FAIL|PCIPCI_ALIMAGIK)) {\r\ndprintk(1,\r\nKERN_WARNING\r\n"%s: chipset does not support reliable PCI-PCI DMA\n",\r\nZORAN_NAME);\r\n}\r\nres = pci_register_driver(&zoran_driver);\r\nif (res) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: Unable to register ZR36057 driver\n",\r\nZORAN_NAME);\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit zoran_exit(void)\r\n{\r\npci_unregister_driver(&zoran_driver);\r\n}
