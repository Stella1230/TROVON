static struct dmaengine_pcm *soc_platform_to_pcm(struct snd_soc_platform *p)\r\n{\r\nreturn container_of(p, struct dmaengine_pcm, platform);\r\n}\r\nint snd_dmaengine_pcm_prepare_slave_config(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct dma_slave_config *slave_config)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_dmaengine_dai_dma_data *dma_data;\r\nint ret;\r\ndma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nret = snd_hwparams_to_dma_slave_config(substream, params, slave_config);\r\nif (ret)\r\nreturn ret;\r\nsnd_dmaengine_pcm_set_config_from_dai_data(substream, dma_data,\r\nslave_config);\r\nreturn 0;\r\n}\r\nstatic int dmaengine_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);\r\nstruct dma_chan *chan = snd_dmaengine_pcm_get_chan(substream);\r\nstruct dma_slave_config slave_config;\r\nint ret;\r\nif (pcm->config->prepare_slave_config) {\r\nret = pcm->config->prepare_slave_config(substream, params,\r\n&slave_config);\r\nif (ret)\r\nreturn ret;\r\nret = dmaengine_slave_config(chan, &slave_config);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));\r\n}\r\nstatic int dmaengine_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);\r\nstruct dma_chan *chan = pcm->chan[substream->stream];\r\nint ret;\r\nret = snd_soc_set_runtime_hwparams(substream,\r\npcm->config->pcm_hardware);\r\nif (ret)\r\nreturn ret;\r\nreturn snd_dmaengine_pcm_open(substream, chan);\r\n}\r\nstatic struct device *dmaengine_dma_dev(struct dmaengine_pcm *pcm,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nif (!pcm->chan[substream->stream])\r\nreturn NULL;\r\nreturn pcm->chan[substream->stream]->device->dev;\r\n}\r\nstatic void dmaengine_pcm_free(struct snd_pcm *pcm)\r\n{\r\nsnd_pcm_lib_preallocate_free_for_all(pcm);\r\n}\r\nstatic struct dma_chan *dmaengine_pcm_compat_request_channel(\r\nstruct snd_soc_pcm_runtime *rtd,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);\r\nif ((pcm->flags & SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX) && pcm->chan[0])\r\nreturn pcm->chan[0];\r\nif (pcm->config->compat_request_channel)\r\nreturn pcm->config->compat_request_channel(rtd, substream);\r\nreturn snd_dmaengine_pcm_request_channel(pcm->config->compat_filter_fn,\r\nsnd_soc_dai_get_dma_data(rtd->cpu_dai, substream));\r\n}\r\nstatic int dmaengine_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);\r\nconst struct snd_dmaengine_pcm_config *config = pcm->config;\r\nstruct snd_pcm_substream *substream;\r\nunsigned int i;\r\nint ret;\r\nfor (i = SNDRV_PCM_STREAM_PLAYBACK; i <= SNDRV_PCM_STREAM_CAPTURE; i++) {\r\nsubstream = rtd->pcm->streams[i].substream;\r\nif (!substream)\r\ncontinue;\r\nif (!pcm->chan[i] && (pcm->flags & SND_DMAENGINE_PCM_FLAG_COMPAT)) {\r\npcm->chan[i] = dmaengine_pcm_compat_request_channel(rtd,\r\nsubstream);\r\n}\r\nif (!pcm->chan[i]) {\r\ndev_err(rtd->platform->dev,\r\n"Missing dma channel for stream: %d\n", i);\r\nret = -EINVAL;\r\ngoto err_free;\r\n}\r\nret = snd_pcm_lib_preallocate_pages(substream,\r\nSNDRV_DMA_TYPE_DEV,\r\ndmaengine_dma_dev(pcm, substream),\r\nconfig->prealloc_buffer_size,\r\nconfig->pcm_hardware->buffer_bytes_max);\r\nif (ret)\r\ngoto err_free;\r\n}\r\nreturn 0;\r\nerr_free:\r\ndmaengine_pcm_free(rtd->pcm);\r\nreturn ret;\r\n}\r\nstatic void dmaengine_pcm_request_chan_of(struct dmaengine_pcm *pcm,\r\nstruct device *dev)\r\n{\r\nunsigned int i;\r\nif ((pcm->flags & SND_DMAENGINE_PCM_FLAG_NO_DT) || !dev->of_node)\r\nreturn;\r\nif (pcm->flags & SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX) {\r\npcm->chan[0] = dma_request_slave_channel(dev, "rx-tx");\r\npcm->chan[1] = pcm->chan[0];\r\n} else {\r\nfor (i = SNDRV_PCM_STREAM_PLAYBACK; i <= SNDRV_PCM_STREAM_CAPTURE; i++) {\r\npcm->chan[i] = dma_request_slave_channel(dev,\r\ndmaengine_pcm_dma_channel_names[i]);\r\n}\r\n}\r\n}\r\nint snd_dmaengine_pcm_register(struct device *dev,\r\nconst struct snd_dmaengine_pcm_config *config, unsigned int flags)\r\n{\r\nstruct dmaengine_pcm *pcm;\r\npcm = kzalloc(sizeof(*pcm), GFP_KERNEL);\r\nif (!pcm)\r\nreturn -ENOMEM;\r\npcm->config = config;\r\npcm->flags = flags;\r\ndmaengine_pcm_request_chan_of(pcm, dev);\r\nif (flags & SND_DMAENGINE_PCM_FLAG_NO_RESIDUE)\r\nreturn snd_soc_add_platform(dev, &pcm->platform,\r\n&dmaengine_no_residue_pcm_platform);\r\nelse\r\nreturn snd_soc_add_platform(dev, &pcm->platform,\r\n&dmaengine_pcm_platform);\r\n}\r\nvoid snd_dmaengine_pcm_unregister(struct device *dev)\r\n{\r\nstruct snd_soc_platform *platform;\r\nstruct dmaengine_pcm *pcm;\r\nunsigned int i;\r\nplatform = snd_soc_lookup_platform(dev);\r\nif (!platform)\r\nreturn;\r\npcm = soc_platform_to_pcm(platform);\r\nfor (i = SNDRV_PCM_STREAM_PLAYBACK; i <= SNDRV_PCM_STREAM_CAPTURE; i++) {\r\nif (pcm->chan[i]) {\r\ndma_release_channel(pcm->chan[i]);\r\nif (pcm->flags & SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX)\r\nbreak;\r\n}\r\n}\r\nsnd_soc_remove_platform(platform);\r\nkfree(pcm);\r\n}
