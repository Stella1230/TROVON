static void free_substream(struct snd_usb_substream *subs)\r\n{\r\nstruct audioformat *fp, *n;\r\nif (!subs->num_formats)\r\nreturn;\r\nlist_for_each_entry_safe(fp, n, &subs->fmt_list, list) {\r\nkfree(fp->rate_table);\r\nkfree(fp->chmap);\r\nkfree(fp);\r\n}\r\nkfree(subs->rate_list.list);\r\n}\r\nstatic void snd_usb_audio_stream_free(struct snd_usb_stream *stream)\r\n{\r\nfree_substream(&stream->substream[0]);\r\nfree_substream(&stream->substream[1]);\r\nlist_del(&stream->list);\r\nkfree(stream);\r\n}\r\nstatic void snd_usb_audio_pcm_free(struct snd_pcm *pcm)\r\n{\r\nstruct snd_usb_stream *stream = pcm->private_data;\r\nif (stream) {\r\nstream->pcm = NULL;\r\nsnd_usb_audio_stream_free(stream);\r\n}\r\n}\r\nstatic void snd_usb_init_substream(struct snd_usb_stream *as,\r\nint stream,\r\nstruct audioformat *fp)\r\n{\r\nstruct snd_usb_substream *subs = &as->substream[stream];\r\nINIT_LIST_HEAD(&subs->fmt_list);\r\nspin_lock_init(&subs->lock);\r\nsubs->stream = as;\r\nsubs->direction = stream;\r\nsubs->dev = as->chip->dev;\r\nsubs->txfr_quirk = as->chip->txfr_quirk;\r\nsubs->speed = snd_usb_get_speed(subs->dev);\r\nsubs->pkt_offset_adj = 0;\r\nsnd_usb_set_pcm_ops(as->pcm, stream);\r\nlist_add_tail(&fp->list, &subs->fmt_list);\r\nsubs->formats |= fp->formats;\r\nsubs->num_formats++;\r\nsubs->fmt_type = fp->fmt_type;\r\nsubs->ep_num = fp->endpoint;\r\nif (fp->channels > subs->channels_max)\r\nsubs->channels_max = fp->channels;\r\n}\r\nstatic int usb_chmap_ctl_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\r\nstruct snd_usb_substream *subs = info->private_data;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = subs->channels_max;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = SNDRV_CHMAP_LAST;\r\nreturn 0;\r\n}\r\nstatic bool have_dup_chmap(struct snd_usb_substream *subs,\r\nstruct audioformat *fp)\r\n{\r\nstruct list_head *p;\r\nfor (p = fp->list.prev; p != &subs->fmt_list; p = p->prev) {\r\nstruct audioformat *prev;\r\nprev = list_entry(p, struct audioformat, list);\r\nif (prev->chmap &&\r\n!memcmp(prev->chmap, fp->chmap, sizeof(*fp->chmap)))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int usb_chmap_ctl_tlv(struct snd_kcontrol *kcontrol, int op_flag,\r\nunsigned int size, unsigned int __user *tlv)\r\n{\r\nstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\r\nstruct snd_usb_substream *subs = info->private_data;\r\nstruct audioformat *fp;\r\nunsigned int __user *dst;\r\nint count = 0;\r\nif (size < 8)\r\nreturn -ENOMEM;\r\nif (put_user(SNDRV_CTL_TLVT_CONTAINER, tlv))\r\nreturn -EFAULT;\r\nsize -= 8;\r\ndst = tlv + 2;\r\nlist_for_each_entry(fp, &subs->fmt_list, list) {\r\nint i, ch_bytes;\r\nif (!fp->chmap)\r\ncontinue;\r\nif (have_dup_chmap(subs, fp))\r\ncontinue;\r\nch_bytes = fp->chmap->channels * 4;\r\nif (size < 8 + ch_bytes)\r\nreturn -ENOMEM;\r\nif (put_user(SNDRV_CTL_TLVT_CHMAP_FIXED, dst) ||\r\nput_user(ch_bytes, dst + 1))\r\nreturn -EFAULT;\r\ndst += 2;\r\nfor (i = 0; i < fp->chmap->channels; i++, dst++) {\r\nif (put_user(fp->chmap->map[i], dst))\r\nreturn -EFAULT;\r\n}\r\ncount += 8 + ch_bytes;\r\nsize -= 8 + ch_bytes;\r\n}\r\nif (put_user(count, tlv + 1))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int usb_chmap_ctl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\r\nstruct snd_usb_substream *subs = info->private_data;\r\nstruct snd_pcm_chmap_elem *chmap = NULL;\r\nint i;\r\nmemset(ucontrol->value.integer.value, 0,\r\nsizeof(ucontrol->value.integer.value));\r\nif (subs->cur_audiofmt)\r\nchmap = subs->cur_audiofmt->chmap;\r\nif (chmap) {\r\nfor (i = 0; i < chmap->channels; i++)\r\nucontrol->value.integer.value[i] = chmap->map[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic int add_chmap(struct snd_pcm *pcm, int stream,\r\nstruct snd_usb_substream *subs)\r\n{\r\nstruct audioformat *fp;\r\nstruct snd_pcm_chmap *chmap;\r\nstruct snd_kcontrol *kctl;\r\nint err;\r\nlist_for_each_entry(fp, &subs->fmt_list, list)\r\nif (fp->chmap)\r\ngoto ok;\r\nreturn 0;\r\nok:\r\nerr = snd_pcm_add_chmap_ctls(pcm, stream, NULL, 0, 0, &chmap);\r\nif (err < 0)\r\nreturn err;\r\nchmap->private_data = subs;\r\nkctl = chmap->kctl;\r\nkctl->info = usb_chmap_ctl_info;\r\nkctl->get = usb_chmap_ctl_get;\r\nkctl->tlv.c = usb_chmap_ctl_tlv;\r\nreturn 0;\r\n}\r\nstatic struct snd_pcm_chmap_elem *convert_chmap(int channels, unsigned int bits,\r\nint protocol)\r\n{\r\nstatic unsigned int uac1_maps[] = {\r\nSNDRV_CHMAP_FL,\r\nSNDRV_CHMAP_FR,\r\nSNDRV_CHMAP_FC,\r\nSNDRV_CHMAP_LFE,\r\nSNDRV_CHMAP_SL,\r\nSNDRV_CHMAP_SR,\r\nSNDRV_CHMAP_FLC,\r\nSNDRV_CHMAP_FRC,\r\nSNDRV_CHMAP_RC,\r\nSNDRV_CHMAP_SL,\r\nSNDRV_CHMAP_SR,\r\nSNDRV_CHMAP_TC,\r\n0\r\n};\r\nstatic unsigned int uac2_maps[] = {\r\nSNDRV_CHMAP_FL,\r\nSNDRV_CHMAP_FR,\r\nSNDRV_CHMAP_FC,\r\nSNDRV_CHMAP_LFE,\r\nSNDRV_CHMAP_RL,\r\nSNDRV_CHMAP_RR,\r\nSNDRV_CHMAP_FLC,\r\nSNDRV_CHMAP_FRC,\r\nSNDRV_CHMAP_RC,\r\nSNDRV_CHMAP_SL,\r\nSNDRV_CHMAP_SR,\r\nSNDRV_CHMAP_TC,\r\nSNDRV_CHMAP_TFL,\r\nSNDRV_CHMAP_TFC,\r\nSNDRV_CHMAP_TFR,\r\nSNDRV_CHMAP_TRL,\r\nSNDRV_CHMAP_TRC,\r\nSNDRV_CHMAP_TRR,\r\nSNDRV_CHMAP_TFLC,\r\nSNDRV_CHMAP_TFRC,\r\nSNDRV_CHMAP_LLFE,\r\nSNDRV_CHMAP_RLFE,\r\nSNDRV_CHMAP_TSL,\r\nSNDRV_CHMAP_TSR,\r\nSNDRV_CHMAP_BC,\r\nSNDRV_CHMAP_BLC,\r\nSNDRV_CHMAP_BRC,\r\n0\r\n};\r\nstruct snd_pcm_chmap_elem *chmap;\r\nconst unsigned int *maps;\r\nint c;\r\nif (!bits)\r\nreturn NULL;\r\nif (channels > ARRAY_SIZE(chmap->map))\r\nreturn NULL;\r\nchmap = kzalloc(sizeof(*chmap), GFP_KERNEL);\r\nif (!chmap)\r\nreturn NULL;\r\nmaps = protocol == UAC_VERSION_2 ? uac2_maps : uac1_maps;\r\nchmap->channels = channels;\r\nc = 0;\r\nfor (; bits && *maps; maps++, bits >>= 1) {\r\nif (bits & 1)\r\nchmap->map[c++] = *maps;\r\n}\r\nfor (; c < channels; c++)\r\nchmap->map[c] = SNDRV_CHMAP_UNKNOWN;\r\nreturn chmap;\r\n}\r\nint snd_usb_add_audio_stream(struct snd_usb_audio *chip,\r\nint stream,\r\nstruct audioformat *fp)\r\n{\r\nstruct snd_usb_stream *as;\r\nstruct snd_usb_substream *subs;\r\nstruct snd_pcm *pcm;\r\nint err;\r\nlist_for_each_entry(as, &chip->pcm_list, list) {\r\nif (as->fmt_type != fp->fmt_type)\r\ncontinue;\r\nsubs = &as->substream[stream];\r\nif (subs->ep_num == fp->endpoint) {\r\nlist_add_tail(&fp->list, &subs->fmt_list);\r\nsubs->num_formats++;\r\nsubs->formats |= fp->formats;\r\nreturn 0;\r\n}\r\n}\r\nlist_for_each_entry(as, &chip->pcm_list, list) {\r\nif (as->fmt_type != fp->fmt_type)\r\ncontinue;\r\nsubs = &as->substream[stream];\r\nif (subs->ep_num)\r\ncontinue;\r\nerr = snd_pcm_new_stream(as->pcm, stream, 1);\r\nif (err < 0)\r\nreturn err;\r\nsnd_usb_init_substream(as, stream, fp);\r\nreturn add_chmap(as->pcm, stream, subs);\r\n}\r\nas = kzalloc(sizeof(*as), GFP_KERNEL);\r\nif (!as)\r\nreturn -ENOMEM;\r\nas->pcm_index = chip->pcm_devs;\r\nas->chip = chip;\r\nas->fmt_type = fp->fmt_type;\r\nerr = snd_pcm_new(chip->card, "USB Audio", chip->pcm_devs,\r\nstream == SNDRV_PCM_STREAM_PLAYBACK ? 1 : 0,\r\nstream == SNDRV_PCM_STREAM_PLAYBACK ? 0 : 1,\r\n&pcm);\r\nif (err < 0) {\r\nkfree(as);\r\nreturn err;\r\n}\r\nas->pcm = pcm;\r\npcm->private_data = as;\r\npcm->private_free = snd_usb_audio_pcm_free;\r\npcm->info_flags = 0;\r\nif (chip->pcm_devs > 0)\r\nsprintf(pcm->name, "USB Audio #%d", chip->pcm_devs);\r\nelse\r\nstrcpy(pcm->name, "USB Audio");\r\nsnd_usb_init_substream(as, stream, fp);\r\nlist_add(&as->list, &chip->pcm_list);\r\nchip->pcm_devs++;\r\nsnd_usb_proc_pcm_format_add(as);\r\nreturn add_chmap(pcm, stream, &as->substream[stream]);\r\n}\r\nstatic int parse_uac_endpoint_attributes(struct snd_usb_audio *chip,\r\nstruct usb_host_interface *alts,\r\nint protocol, int iface_no)\r\n{\r\nstruct uac_iso_endpoint_descriptor *csep;\r\nstruct usb_interface_descriptor *altsd = get_iface_desc(alts);\r\nint attributes = 0;\r\ncsep = snd_usb_find_desc(alts->endpoint[0].extra, alts->endpoint[0].extralen, NULL, USB_DT_CS_ENDPOINT);\r\nif (!csep && altsd->bNumEndpoints >= 2)\r\ncsep = snd_usb_find_desc(alts->endpoint[1].extra, alts->endpoint[1].extralen, NULL, USB_DT_CS_ENDPOINT);\r\nif (!csep)\r\ncsep = snd_usb_find_desc(alts->extra, alts->extralen, NULL, USB_DT_CS_ENDPOINT);\r\nif (!csep || csep->bLength < 7 ||\r\ncsep->bDescriptorSubtype != UAC_EP_GENERAL) {\r\nsnd_printk(KERN_WARNING "%d:%u:%d : no or invalid"\r\n" class specific endpoint descriptor\n",\r\nchip->dev->devnum, iface_no,\r\naltsd->bAlternateSetting);\r\nreturn 0;\r\n}\r\nif (protocol == UAC_VERSION_1) {\r\nattributes = csep->bmAttributes;\r\n} else {\r\nstruct uac2_iso_endpoint_descriptor *csep2 =\r\n(struct uac2_iso_endpoint_descriptor *) csep;\r\nattributes = csep->bmAttributes & UAC_EP_CS_ATTR_FILL_MAX;\r\nif (csep2->bmControls & UAC2_CONTROL_PITCH)\r\nattributes |= UAC_EP_CS_ATTR_PITCH_CONTROL;\r\n}\r\nreturn attributes;\r\n}\r\nstatic void *\r\nsnd_usb_find_input_terminal_descriptor(struct usb_host_interface *ctrl_iface,\r\nint terminal_id)\r\n{\r\nstruct uac2_input_terminal_descriptor *term = NULL;\r\nwhile ((term = snd_usb_find_csint_desc(ctrl_iface->extra,\r\nctrl_iface->extralen,\r\nterm, UAC_INPUT_TERMINAL))) {\r\nif (term->bTerminalID == terminal_id)\r\nreturn term;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct uac2_output_terminal_descriptor *\r\nsnd_usb_find_output_terminal_descriptor(struct usb_host_interface *ctrl_iface,\r\nint terminal_id)\r\n{\r\nstruct uac2_output_terminal_descriptor *term = NULL;\r\nwhile ((term = snd_usb_find_csint_desc(ctrl_iface->extra,\r\nctrl_iface->extralen,\r\nterm, UAC_OUTPUT_TERMINAL))) {\r\nif (term->bTerminalID == terminal_id)\r\nreturn term;\r\n}\r\nreturn NULL;\r\n}\r\nint snd_usb_parse_audio_interface(struct snd_usb_audio *chip, int iface_no)\r\n{\r\nstruct usb_device *dev;\r\nstruct usb_interface *iface;\r\nstruct usb_host_interface *alts;\r\nstruct usb_interface_descriptor *altsd;\r\nint i, altno, err, stream;\r\nunsigned int format = 0, num_channels = 0;\r\nstruct audioformat *fp = NULL;\r\nint num, protocol, clock = 0;\r\nstruct uac_format_type_i_continuous_descriptor *fmt;\r\nunsigned int chconfig;\r\ndev = chip->dev;\r\niface = usb_ifnum_to_if(dev, iface_no);\r\nnum = iface->num_altsetting;\r\nif (chip->usb_id == USB_ID(0x04fa, 0x4201))\r\nnum = 4;\r\nfor (i = 0; i < num; i++) {\r\nalts = &iface->altsetting[i];\r\naltsd = get_iface_desc(alts);\r\nprotocol = altsd->bInterfaceProtocol;\r\nif (((altsd->bInterfaceClass != USB_CLASS_AUDIO ||\r\n(altsd->bInterfaceSubClass != USB_SUBCLASS_AUDIOSTREAMING &&\r\naltsd->bInterfaceSubClass != USB_SUBCLASS_VENDOR_SPEC)) &&\r\naltsd->bInterfaceClass != USB_CLASS_VENDOR_SPEC) ||\r\naltsd->bNumEndpoints < 1 ||\r\nle16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize) == 0)\r\ncontinue;\r\nif ((get_endpoint(alts, 0)->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) !=\r\nUSB_ENDPOINT_XFER_ISOC)\r\ncontinue;\r\nstream = (get_endpoint(alts, 0)->bEndpointAddress & USB_DIR_IN) ?\r\nSNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;\r\naltno = altsd->bAlternateSetting;\r\nif (snd_usb_apply_interface_quirk(chip, iface_no, altno))\r\ncontinue;\r\nif (USB_ID_VENDOR(chip->usb_id) == 0x0582 &&\r\naltsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC &&\r\nprotocol <= 2)\r\nprotocol = UAC_VERSION_1;\r\nchconfig = 0;\r\nswitch (protocol) {\r\ndefault:\r\nsnd_printdd(KERN_WARNING "%d:%u:%d: unknown interface protocol %#02x, assuming v1\n",\r\ndev->devnum, iface_no, altno, protocol);\r\nprotocol = UAC_VERSION_1;\r\ncase UAC_VERSION_1: {\r\nstruct uac1_as_header_descriptor *as =\r\nsnd_usb_find_csint_desc(alts->extra, alts->extralen, NULL, UAC_AS_GENERAL);\r\nstruct uac_input_terminal_descriptor *iterm;\r\nif (!as) {\r\nsnd_printk(KERN_ERR "%d:%u:%d : UAC_AS_GENERAL descriptor not found\n",\r\ndev->devnum, iface_no, altno);\r\ncontinue;\r\n}\r\nif (as->bLength < sizeof(*as)) {\r\nsnd_printk(KERN_ERR "%d:%u:%d : invalid UAC_AS_GENERAL desc\n",\r\ndev->devnum, iface_no, altno);\r\ncontinue;\r\n}\r\nformat = le16_to_cpu(as->wFormatTag);\r\niterm = snd_usb_find_input_terminal_descriptor(chip->ctrl_intf,\r\nas->bTerminalLink);\r\nif (iterm) {\r\nnum_channels = iterm->bNrChannels;\r\nchconfig = le16_to_cpu(iterm->wChannelConfig);\r\n}\r\nbreak;\r\n}\r\ncase UAC_VERSION_2: {\r\nstruct uac2_input_terminal_descriptor *input_term;\r\nstruct uac2_output_terminal_descriptor *output_term;\r\nstruct uac2_as_header_descriptor *as =\r\nsnd_usb_find_csint_desc(alts->extra, alts->extralen, NULL, UAC_AS_GENERAL);\r\nif (!as) {\r\nsnd_printk(KERN_ERR "%d:%u:%d : UAC_AS_GENERAL descriptor not found\n",\r\ndev->devnum, iface_no, altno);\r\ncontinue;\r\n}\r\nif (as->bLength < sizeof(*as)) {\r\nsnd_printk(KERN_ERR "%d:%u:%d : invalid UAC_AS_GENERAL desc\n",\r\ndev->devnum, iface_no, altno);\r\ncontinue;\r\n}\r\nnum_channels = as->bNrChannels;\r\nformat = le32_to_cpu(as->bmFormats);\r\ninput_term = snd_usb_find_input_terminal_descriptor(chip->ctrl_intf,\r\nas->bTerminalLink);\r\nif (input_term) {\r\nclock = input_term->bCSourceID;\r\nchconfig = le32_to_cpu(input_term->bmChannelConfig);\r\nbreak;\r\n}\r\noutput_term = snd_usb_find_output_terminal_descriptor(chip->ctrl_intf,\r\nas->bTerminalLink);\r\nif (output_term) {\r\nclock = output_term->bCSourceID;\r\nbreak;\r\n}\r\nsnd_printk(KERN_ERR "%d:%u:%d : bogus bTerminalLink %d\n",\r\ndev->devnum, iface_no, altno, as->bTerminalLink);\r\ncontinue;\r\n}\r\n}\r\nfmt = snd_usb_find_csint_desc(alts->extra, alts->extralen, NULL, UAC_FORMAT_TYPE);\r\nif (!fmt) {\r\nsnd_printk(KERN_ERR "%d:%u:%d : no UAC_FORMAT_TYPE desc\n",\r\ndev->devnum, iface_no, altno);\r\ncontinue;\r\n}\r\nif (((protocol == UAC_VERSION_1) && (fmt->bLength < 8)) ||\r\n((protocol == UAC_VERSION_2) && (fmt->bLength < 6))) {\r\nsnd_printk(KERN_ERR "%d:%u:%d : invalid UAC_FORMAT_TYPE desc\n",\r\ndev->devnum, iface_no, altno);\r\ncontinue;\r\n}\r\nif (fmt->bNrChannels == 1 &&\r\nfmt->bSubframeSize == 2 &&\r\naltno == 2 && num == 3 &&\r\nfp && fp->altsetting == 1 && fp->channels == 1 &&\r\nfp->formats == SNDRV_PCM_FMTBIT_S16_LE &&\r\nprotocol == UAC_VERSION_1 &&\r\nle16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize) ==\r\nfp->maxpacksize * 2)\r\ncontinue;\r\nfp = kzalloc(sizeof(*fp), GFP_KERNEL);\r\nif (! fp) {\r\nsnd_printk(KERN_ERR "cannot malloc\n");\r\nreturn -ENOMEM;\r\n}\r\nfp->iface = iface_no;\r\nfp->altsetting = altno;\r\nfp->altset_idx = i;\r\nfp->endpoint = get_endpoint(alts, 0)->bEndpointAddress;\r\nfp->ep_attr = get_endpoint(alts, 0)->bmAttributes;\r\nfp->datainterval = snd_usb_parse_datainterval(chip, alts);\r\nfp->protocol = protocol;\r\nfp->maxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);\r\nfp->channels = num_channels;\r\nif (snd_usb_get_speed(dev) == USB_SPEED_HIGH)\r\nfp->maxpacksize = (((fp->maxpacksize >> 11) & 3) + 1)\r\n* (fp->maxpacksize & 0x7ff);\r\nfp->attributes = parse_uac_endpoint_attributes(chip, alts, protocol, iface_no);\r\nfp->clock = clock;\r\nfp->chmap = convert_chmap(num_channels, chconfig, protocol);\r\nswitch (chip->usb_id) {\r\ncase USB_ID(0x0a92, 0x0053):\r\nfp->attributes &= ~UAC_EP_CS_ATTR_SAMPLE_RATE;\r\nbreak;\r\ncase USB_ID(0x041e, 0x3020):\r\ncase USB_ID(0x0763, 0x2003):\r\nfp->attributes |= UAC_EP_CS_ATTR_SAMPLE_RATE;\r\nbreak;\r\ncase USB_ID(0x0763, 0x2001):\r\ncase USB_ID(0x0763, 0x2012):\r\ncase USB_ID(0x047f, 0x0ca1):\r\ncase USB_ID(0x077d, 0x07af):\r\nfp->ep_attr &= ~USB_ENDPOINT_SYNCTYPE;\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nfp->ep_attr |= USB_ENDPOINT_SYNC_ADAPTIVE;\r\nelse\r\nfp->ep_attr |= USB_ENDPOINT_SYNC_SYNC;\r\nbreak;\r\n}\r\nif (snd_usb_parse_audio_format(chip, fp, format, fmt, stream) < 0) {\r\nkfree(fp->rate_table);\r\nkfree(fp->chmap);\r\nkfree(fp);\r\nfp = NULL;\r\ncontinue;\r\n}\r\nsnd_printdd(KERN_INFO "%d:%u:%d: add audio endpoint %#x\n", dev->devnum, iface_no, altno, fp->endpoint);\r\nerr = snd_usb_add_audio_stream(chip, stream, fp);\r\nif (err < 0) {\r\nkfree(fp->rate_table);\r\nkfree(fp->chmap);\r\nkfree(fp);\r\nreturn err;\r\n}\r\nusb_set_interface(chip->dev, iface_no, altno);\r\nsnd_usb_init_pitch(chip, iface_no, alts, fp);\r\nsnd_usb_init_sample_rate(chip, iface_no, alts, fp, fp->rate_max);\r\n}\r\nreturn 0;\r\n}
