static unsigned int sh_clk_read(struct clk *clk)\r\n{\r\nif (clk->flags & CLK_ENABLE_REG_8BIT)\r\nreturn ioread8(clk->mapped_reg);\r\nelse if (clk->flags & CLK_ENABLE_REG_16BIT)\r\nreturn ioread16(clk->mapped_reg);\r\nreturn ioread32(clk->mapped_reg);\r\n}\r\nstatic void sh_clk_write(int value, struct clk *clk)\r\n{\r\nif (clk->flags & CLK_ENABLE_REG_8BIT)\r\niowrite8(value, clk->mapped_reg);\r\nelse if (clk->flags & CLK_ENABLE_REG_16BIT)\r\niowrite16(value, clk->mapped_reg);\r\nelse\r\niowrite32(value, clk->mapped_reg);\r\n}\r\nstatic int sh_clk_mstp_enable(struct clk *clk)\r\n{\r\nsh_clk_write(sh_clk_read(clk) & ~(1 << clk->enable_bit), clk);\r\nreturn 0;\r\n}\r\nstatic void sh_clk_mstp_disable(struct clk *clk)\r\n{\r\nsh_clk_write(sh_clk_read(clk) | (1 << clk->enable_bit), clk);\r\n}\r\nint __init sh_clk_mstp_register(struct clk *clks, int nr)\r\n{\r\nstruct clk *clkp;\r\nint ret = 0;\r\nint k;\r\nfor (k = 0; !ret && (k < nr); k++) {\r\nclkp = clks + k;\r\nclkp->ops = &sh_clk_mstp_clk_ops;\r\nret |= clk_register(clkp);\r\n}\r\nreturn ret;\r\n}\r\nstatic inline struct clk_div_table *clk_to_div_table(struct clk *clk)\r\n{\r\nreturn clk->priv;\r\n}\r\nstatic inline struct clk_div_mult_table *clk_to_div_mult_table(struct clk *clk)\r\n{\r\nreturn clk_to_div_table(clk)->div_mult_table;\r\n}\r\nstatic long sh_clk_div_round_rate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn clk_rate_table_round(clk, clk->freq_table, rate);\r\n}\r\nstatic unsigned long sh_clk_div_recalc(struct clk *clk)\r\n{\r\nstruct clk_div_mult_table *table = clk_to_div_mult_table(clk);\r\nunsigned int idx;\r\nclk_rate_table_build(clk, clk->freq_table, table->nr_divisors,\r\ntable, clk->arch_flags ? &clk->arch_flags : NULL);\r\nidx = (sh_clk_read(clk) >> clk->enable_bit) & clk->div_mask;\r\nreturn clk->freq_table[idx].frequency;\r\n}\r\nstatic int sh_clk_div_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nstruct clk_div_table *dt = clk_to_div_table(clk);\r\nunsigned long value;\r\nint idx;\r\nidx = clk_rate_table_find(clk, clk->freq_table, rate);\r\nif (idx < 0)\r\nreturn idx;\r\nvalue = sh_clk_read(clk);\r\nvalue &= ~(clk->div_mask << clk->enable_bit);\r\nvalue |= (idx << clk->enable_bit);\r\nsh_clk_write(value, clk);\r\nif (dt->kick)\r\ndt->kick(clk);\r\nreturn 0;\r\n}\r\nstatic int sh_clk_div_enable(struct clk *clk)\r\n{\r\nif (clk->div_mask == SH_CLK_DIV6_MSK) {\r\nint ret = sh_clk_div_set_rate(clk, clk->rate);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nsh_clk_write(sh_clk_read(clk) & ~CPG_CKSTP_BIT, clk);\r\nreturn 0;\r\n}\r\nstatic void sh_clk_div_disable(struct clk *clk)\r\n{\r\nunsigned int val;\r\nval = sh_clk_read(clk);\r\nval |= CPG_CKSTP_BIT;\r\nif (clk->flags & CLK_MASK_DIV_ON_DISABLE)\r\nval |= clk->div_mask;\r\nsh_clk_write(val, clk);\r\n}\r\nstatic int __init sh_clk_init_parent(struct clk *clk)\r\n{\r\nu32 val;\r\nif (clk->parent)\r\nreturn 0;\r\nif (!clk->parent_table || !clk->parent_num)\r\nreturn 0;\r\nif (!clk->src_width) {\r\npr_err("sh_clk_init_parent: cannot select parent clock\n");\r\nreturn -EINVAL;\r\n}\r\nval = (sh_clk_read(clk) >> clk->src_shift);\r\nval &= (1 << clk->src_width) - 1;\r\nif (val >= clk->parent_num) {\r\npr_err("sh_clk_init_parent: parent table size failed\n");\r\nreturn -EINVAL;\r\n}\r\nclk_reparent(clk, clk->parent_table[val]);\r\nif (!clk->parent) {\r\npr_err("sh_clk_init_parent: unable to set parent");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init sh_clk_div_register_ops(struct clk *clks, int nr,\r\nstruct clk_div_table *table, struct sh_clk_ops *ops)\r\n{\r\nstruct clk *clkp;\r\nvoid *freq_table;\r\nint nr_divs = table->div_mult_table->nr_divisors;\r\nint freq_table_size = sizeof(struct cpufreq_frequency_table);\r\nint ret = 0;\r\nint k;\r\nfreq_table_size *= (nr_divs + 1);\r\nfreq_table = kzalloc(freq_table_size * nr, GFP_KERNEL);\r\nif (!freq_table) {\r\npr_err("%s: unable to alloc memory\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nfor (k = 0; !ret && (k < nr); k++) {\r\nclkp = clks + k;\r\nclkp->ops = ops;\r\nclkp->priv = table;\r\nclkp->freq_table = freq_table + (k * freq_table_size);\r\nclkp->freq_table[nr_divs].frequency = CPUFREQ_TABLE_END;\r\nret = clk_register(clkp);\r\nif (ret == 0)\r\nret = sh_clk_init_parent(clkp);\r\n}\r\nreturn ret;\r\n}\r\nstatic int sh_clk_div6_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nstruct clk_div_mult_table *table = clk_to_div_mult_table(clk);\r\nu32 value;\r\nint ret, i;\r\nif (!clk->parent_table || !clk->parent_num)\r\nreturn -EINVAL;\r\nfor (i = 0; i < clk->parent_num; i++)\r\nif (clk->parent_table[i] == parent)\r\nbreak;\r\nif (i == clk->parent_num)\r\nreturn -ENODEV;\r\nret = clk_reparent(clk, parent);\r\nif (ret < 0)\r\nreturn ret;\r\nvalue = sh_clk_read(clk) &\r\n~(((1 << clk->src_width) - 1) << clk->src_shift);\r\nsh_clk_write(value | (i << clk->src_shift), clk);\r\nclk_rate_table_build(clk, clk->freq_table, table->nr_divisors,\r\ntable, NULL);\r\nreturn 0;\r\n}\r\nint __init sh_clk_div6_register(struct clk *clks, int nr)\r\n{\r\nreturn sh_clk_div_register_ops(clks, nr, &sh_clk_div6_table,\r\n&sh_clk_div_enable_clk_ops);\r\n}\r\nint __init sh_clk_div6_reparent_register(struct clk *clks, int nr)\r\n{\r\nreturn sh_clk_div_register_ops(clks, nr, &sh_clk_div6_table,\r\n&sh_clk_div6_reparent_clk_ops);\r\n}\r\nstatic int sh_clk_div4_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nstruct clk_div_mult_table *table = clk_to_div_mult_table(clk);\r\nu32 value;\r\nint ret;\r\nif (parent->flags & CLK_ENABLE_ON_INIT)\r\nvalue = sh_clk_read(clk) & ~(1 << 7);\r\nelse\r\nvalue = sh_clk_read(clk) | (1 << 7);\r\nret = clk_reparent(clk, parent);\r\nif (ret < 0)\r\nreturn ret;\r\nsh_clk_write(value, clk);\r\nclk_rate_table_build(clk, clk->freq_table, table->nr_divisors,\r\ntable, &clk->arch_flags);\r\nreturn 0;\r\n}\r\nint __init sh_clk_div4_register(struct clk *clks, int nr,\r\nstruct clk_div4_table *table)\r\n{\r\nreturn sh_clk_div_register_ops(clks, nr, table, &sh_clk_div_clk_ops);\r\n}\r\nint __init sh_clk_div4_enable_register(struct clk *clks, int nr,\r\nstruct clk_div4_table *table)\r\n{\r\nreturn sh_clk_div_register_ops(clks, nr, table,\r\n&sh_clk_div_enable_clk_ops);\r\n}\r\nint __init sh_clk_div4_reparent_register(struct clk *clks, int nr,\r\nstruct clk_div4_table *table)\r\n{\r\nreturn sh_clk_div_register_ops(clks, nr, table,\r\n&sh_clk_div4_reparent_clk_ops);\r\n}\r\nstatic unsigned long fsidiv_recalc(struct clk *clk)\r\n{\r\nu32 value;\r\nvalue = __raw_readl(clk->mapping->base);\r\nvalue >>= 16;\r\nif (value < 2)\r\nreturn clk->parent->rate;\r\nreturn clk->parent->rate / value;\r\n}\r\nstatic long fsidiv_round_rate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn clk_rate_div_range_round(clk, 1, 0xffff, rate);\r\n}\r\nstatic void fsidiv_disable(struct clk *clk)\r\n{\r\n__raw_writel(0, clk->mapping->base);\r\n}\r\nstatic int fsidiv_enable(struct clk *clk)\r\n{\r\nu32 value;\r\nvalue = __raw_readl(clk->mapping->base) >> 16;\r\nif (value < 2)\r\nreturn 0;\r\n__raw_writel((value << 16) | 0x3, clk->mapping->base);\r\nreturn 0;\r\n}\r\nstatic int fsidiv_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nint idx;\r\nidx = (clk->parent->rate / rate) & 0xffff;\r\nif (idx < 2)\r\n__raw_writel(0, clk->mapping->base);\r\nelse\r\n__raw_writel(idx << 16, clk->mapping->base);\r\nreturn 0;\r\n}\r\nint __init sh_clk_fsidiv_register(struct clk *clks, int nr)\r\n{\r\nstruct clk_mapping *map;\r\nint i;\r\nfor (i = 0; i < nr; i++) {\r\nmap = kzalloc(sizeof(struct clk_mapping), GFP_KERNEL);\r\nif (!map) {\r\npr_err("%s: unable to alloc memory\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nmap->phys = (phys_addr_t)clks[i].enable_reg;\r\nmap->len = 8;\r\nclks[i].enable_reg = 0;\r\nclks[i].ops = &fsidiv_clk_ops;\r\nclks[i].mapping = map;\r\nclk_register(&clks[i]);\r\n}\r\nreturn 0;\r\n}
