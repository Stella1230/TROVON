static void * __init __alloc_memory_core_early(int nid, u64 size, u64 align,\r\nu64 goal, u64 limit)\r\n{\r\nvoid *ptr;\r\nu64 addr;\r\nif (limit > memblock.current_limit)\r\nlimit = memblock.current_limit;\r\naddr = memblock_find_in_range_node(goal, limit, size, align, nid);\r\nif (!addr)\r\nreturn NULL;\r\nmemblock_reserve(addr, size);\r\nptr = phys_to_virt(addr);\r\nmemset(ptr, 0, size);\r\nkmemleak_alloc(ptr, size, 0, 0);\r\nreturn ptr;\r\n}\r\nvoid __init free_bootmem_late(unsigned long addr, unsigned long size)\r\n{\r\nunsigned long cursor, end;\r\nkmemleak_free_part(__va(addr), size);\r\ncursor = PFN_UP(addr);\r\nend = PFN_DOWN(addr + size);\r\nfor (; cursor < end; cursor++) {\r\n__free_pages_bootmem(pfn_to_page(cursor), 0);\r\ntotalram_pages++;\r\n}\r\n}\r\nstatic void __init __free_pages_memory(unsigned long start, unsigned long end)\r\n{\r\nunsigned long i, start_aligned, end_aligned;\r\nint order = ilog2(BITS_PER_LONG);\r\nstart_aligned = (start + (BITS_PER_LONG - 1)) & ~(BITS_PER_LONG - 1);\r\nend_aligned = end & ~(BITS_PER_LONG - 1);\r\nif (end_aligned <= start_aligned) {\r\nfor (i = start; i < end; i++)\r\n__free_pages_bootmem(pfn_to_page(i), 0);\r\nreturn;\r\n}\r\nfor (i = start; i < start_aligned; i++)\r\n__free_pages_bootmem(pfn_to_page(i), 0);\r\nfor (i = start_aligned; i < end_aligned; i += BITS_PER_LONG)\r\n__free_pages_bootmem(pfn_to_page(i), order);\r\nfor (i = end_aligned; i < end; i++)\r\n__free_pages_bootmem(pfn_to_page(i), 0);\r\n}\r\nstatic unsigned long __init __free_memory_core(phys_addr_t start,\r\nphys_addr_t end)\r\n{\r\nunsigned long start_pfn = PFN_UP(start);\r\nunsigned long end_pfn = min_t(unsigned long,\r\nPFN_DOWN(end), max_low_pfn);\r\nif (start_pfn > end_pfn)\r\nreturn 0;\r\n__free_pages_memory(start_pfn, end_pfn);\r\nreturn end_pfn - start_pfn;\r\n}\r\nstatic unsigned long __init free_low_memory_core_early(void)\r\n{\r\nunsigned long count = 0;\r\nphys_addr_t start, end, size;\r\nu64 i;\r\nfor_each_free_mem_range(i, MAX_NUMNODES, &start, &end, NULL)\r\ncount += __free_memory_core(start, end);\r\nsize = get_allocated_memblock_reserved_regions_info(&start);\r\nif (size)\r\ncount += __free_memory_core(start, start + size);\r\nreturn count;\r\n}\r\nstatic inline void __init reset_node_managed_pages(pg_data_t *pgdat)\r\n{\r\nstruct zone *z;\r\nif (reset_managed_pages_done)\r\nreturn;\r\nfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)\r\nz->managed_pages = 0;\r\n}\r\nvoid __init reset_all_zones_managed_pages(void)\r\n{\r\nstruct pglist_data *pgdat;\r\nfor_each_online_pgdat(pgdat)\r\nreset_node_managed_pages(pgdat);\r\nreset_managed_pages_done = 1;\r\n}\r\nunsigned long __init free_all_bootmem(void)\r\n{\r\nunsigned long pages;\r\nreset_all_zones_managed_pages();\r\npages = free_low_memory_core_early();\r\ntotalram_pages += pages;\r\nreturn pages;\r\n}\r\nvoid __init free_bootmem_node(pg_data_t *pgdat, unsigned long physaddr,\r\nunsigned long size)\r\n{\r\nkmemleak_free_part(__va(physaddr), size);\r\nmemblock_free(physaddr, size);\r\n}\r\nvoid __init free_bootmem(unsigned long addr, unsigned long size)\r\n{\r\nkmemleak_free_part(__va(addr), size);\r\nmemblock_free(addr, size);\r\n}\r\nstatic void * __init ___alloc_bootmem_nopanic(unsigned long size,\r\nunsigned long align,\r\nunsigned long goal,\r\nunsigned long limit)\r\n{\r\nvoid *ptr;\r\nif (WARN_ON_ONCE(slab_is_available()))\r\nreturn kzalloc(size, GFP_NOWAIT);\r\nrestart:\r\nptr = __alloc_memory_core_early(MAX_NUMNODES, size, align, goal, limit);\r\nif (ptr)\r\nreturn ptr;\r\nif (goal != 0) {\r\ngoal = 0;\r\ngoto restart;\r\n}\r\nreturn NULL;\r\n}\r\nvoid * __init __alloc_bootmem_nopanic(unsigned long size, unsigned long align,\r\nunsigned long goal)\r\n{\r\nunsigned long limit = -1UL;\r\nreturn ___alloc_bootmem_nopanic(size, align, goal, limit);\r\n}\r\nstatic void * __init ___alloc_bootmem(unsigned long size, unsigned long align,\r\nunsigned long goal, unsigned long limit)\r\n{\r\nvoid *mem = ___alloc_bootmem_nopanic(size, align, goal, limit);\r\nif (mem)\r\nreturn mem;\r\nprintk(KERN_ALERT "bootmem alloc of %lu bytes failed!\n", size);\r\npanic("Out of memory");\r\nreturn NULL;\r\n}\r\nvoid * __init __alloc_bootmem(unsigned long size, unsigned long align,\r\nunsigned long goal)\r\n{\r\nunsigned long limit = -1UL;\r\nreturn ___alloc_bootmem(size, align, goal, limit);\r\n}\r\nvoid * __init ___alloc_bootmem_node_nopanic(pg_data_t *pgdat,\r\nunsigned long size,\r\nunsigned long align,\r\nunsigned long goal,\r\nunsigned long limit)\r\n{\r\nvoid *ptr;\r\nagain:\r\nptr = __alloc_memory_core_early(pgdat->node_id, size, align,\r\ngoal, limit);\r\nif (ptr)\r\nreturn ptr;\r\nptr = __alloc_memory_core_early(MAX_NUMNODES, size, align,\r\ngoal, limit);\r\nif (ptr)\r\nreturn ptr;\r\nif (goal) {\r\ngoal = 0;\r\ngoto again;\r\n}\r\nreturn NULL;\r\n}\r\nvoid * __init __alloc_bootmem_node_nopanic(pg_data_t *pgdat, unsigned long size,\r\nunsigned long align, unsigned long goal)\r\n{\r\nif (WARN_ON_ONCE(slab_is_available()))\r\nreturn kzalloc_node(size, GFP_NOWAIT, pgdat->node_id);\r\nreturn ___alloc_bootmem_node_nopanic(pgdat, size, align, goal, 0);\r\n}\r\nvoid * __init ___alloc_bootmem_node(pg_data_t *pgdat, unsigned long size,\r\nunsigned long align, unsigned long goal,\r\nunsigned long limit)\r\n{\r\nvoid *ptr;\r\nptr = ___alloc_bootmem_node_nopanic(pgdat, size, align, goal, limit);\r\nif (ptr)\r\nreturn ptr;\r\nprintk(KERN_ALERT "bootmem alloc of %lu bytes failed!\n", size);\r\npanic("Out of memory");\r\nreturn NULL;\r\n}\r\nvoid * __init __alloc_bootmem_node(pg_data_t *pgdat, unsigned long size,\r\nunsigned long align, unsigned long goal)\r\n{\r\nif (WARN_ON_ONCE(slab_is_available()))\r\nreturn kzalloc_node(size, GFP_NOWAIT, pgdat->node_id);\r\nreturn ___alloc_bootmem_node(pgdat, size, align, goal, 0);\r\n}\r\nvoid * __init __alloc_bootmem_node_high(pg_data_t *pgdat, unsigned long size,\r\nunsigned long align, unsigned long goal)\r\n{\r\nreturn __alloc_bootmem_node(pgdat, size, align, goal);\r\n}\r\nvoid * __init __alloc_bootmem_low(unsigned long size, unsigned long align,\r\nunsigned long goal)\r\n{\r\nreturn ___alloc_bootmem(size, align, goal, ARCH_LOW_ADDRESS_LIMIT);\r\n}\r\nvoid * __init __alloc_bootmem_low_nopanic(unsigned long size,\r\nunsigned long align,\r\nunsigned long goal)\r\n{\r\nreturn ___alloc_bootmem_nopanic(size, align, goal,\r\nARCH_LOW_ADDRESS_LIMIT);\r\n}\r\nvoid * __init __alloc_bootmem_low_node(pg_data_t *pgdat, unsigned long size,\r\nunsigned long align, unsigned long goal)\r\n{\r\nif (WARN_ON_ONCE(slab_is_available()))\r\nreturn kzalloc_node(size, GFP_NOWAIT, pgdat->node_id);\r\nreturn ___alloc_bootmem_node(pgdat, size, align, goal,\r\nARCH_LOW_ADDRESS_LIMIT);\r\n}
