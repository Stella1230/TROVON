static void\r\ncdc_ncm_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstrlcpy(info->driver, dev->driver_name, sizeof(info->driver));\r\nstrlcpy(info->version, DRIVER_VERSION, sizeof(info->version));\r\nstrlcpy(info->fw_version, dev->driver_info->description,\r\nsizeof(info->fw_version));\r\nusb_make_path(dev->udev, info->bus_info, sizeof(info->bus_info));\r\n}\r\nstatic u8 cdc_ncm_setup(struct cdc_ncm_ctx *ctx)\r\n{\r\nu32 val;\r\nu8 flags;\r\nu8 iface_no;\r\nint err;\r\nint eth_hlen;\r\nu16 ntb_fmt_supported;\r\nu32 min_dgram_size;\r\nu32 min_hdr_size;\r\nstruct usbnet *dev = netdev_priv(ctx->netdev);\r\niface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;\r\nerr = usbnet_read_cmd(dev, USB_CDC_GET_NTB_PARAMETERS,\r\nUSB_TYPE_CLASS | USB_DIR_IN\r\n|USB_RECIP_INTERFACE,\r\n0, iface_no, &ctx->ncm_parm,\r\nsizeof(ctx->ncm_parm));\r\nif (err < 0) {\r\npr_debug("failed GET_NTB_PARAMETERS\n");\r\nreturn 1;\r\n}\r\nctx->rx_max = le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize);\r\nctx->tx_max = le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize);\r\nctx->tx_remainder = le16_to_cpu(ctx->ncm_parm.wNdpOutPayloadRemainder);\r\nctx->tx_modulus = le16_to_cpu(ctx->ncm_parm.wNdpOutDivisor);\r\nctx->tx_ndp_modulus = le16_to_cpu(ctx->ncm_parm.wNdpOutAlignment);\r\nctx->tx_max_datagrams = le16_to_cpu(ctx->ncm_parm.wNtbOutMaxDatagrams);\r\nntb_fmt_supported = le16_to_cpu(ctx->ncm_parm.bmNtbFormatsSupported);\r\neth_hlen = ETH_HLEN;\r\nmin_dgram_size = CDC_NCM_MIN_DATAGRAM_SIZE;\r\nmin_hdr_size = CDC_NCM_MIN_HDR_SIZE;\r\nif (ctx->mbim_desc != NULL) {\r\nflags = ctx->mbim_desc->bmNetworkCapabilities;\r\neth_hlen = 0;\r\nmin_dgram_size = CDC_MBIM_MIN_DATAGRAM_SIZE;\r\nmin_hdr_size = 0;\r\n} else if (ctx->func_desc != NULL) {\r\nflags = ctx->func_desc->bmNetworkCapabilities;\r\n} else {\r\nflags = 0;\r\n}\r\npr_debug("dwNtbInMaxSize=%u dwNtbOutMaxSize=%u "\r\n"wNdpOutPayloadRemainder=%u wNdpOutDivisor=%u "\r\n"wNdpOutAlignment=%u wNtbOutMaxDatagrams=%u flags=0x%x\n",\r\nctx->rx_max, ctx->tx_max, ctx->tx_remainder, ctx->tx_modulus,\r\nctx->tx_ndp_modulus, ctx->tx_max_datagrams, flags);\r\nif ((ctx->tx_max_datagrams == 0) ||\r\n(ctx->tx_max_datagrams > CDC_NCM_DPT_DATAGRAMS_MAX))\r\nctx->tx_max_datagrams = CDC_NCM_DPT_DATAGRAMS_MAX;\r\nif (ctx->rx_max < USB_CDC_NCM_NTB_MIN_IN_SIZE) {\r\npr_debug("Using min receive length=%d\n",\r\nUSB_CDC_NCM_NTB_MIN_IN_SIZE);\r\nctx->rx_max = USB_CDC_NCM_NTB_MIN_IN_SIZE;\r\n}\r\nif (ctx->rx_max > CDC_NCM_NTB_MAX_SIZE_RX) {\r\npr_debug("Using default maximum receive length=%d\n",\r\nCDC_NCM_NTB_MAX_SIZE_RX);\r\nctx->rx_max = CDC_NCM_NTB_MAX_SIZE_RX;\r\n}\r\nif (ctx->rx_max != le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize)) {\r\n__le32 dwNtbInMaxSize = cpu_to_le32(ctx->rx_max);\r\nerr = usbnet_write_cmd(dev, USB_CDC_SET_NTB_INPUT_SIZE,\r\nUSB_TYPE_CLASS | USB_DIR_OUT\r\n| USB_RECIP_INTERFACE,\r\n0, iface_no, &dwNtbInMaxSize, 4);\r\nif (err < 0)\r\npr_debug("Setting NTB Input Size failed\n");\r\n}\r\nif ((ctx->tx_max <\r\n(min_hdr_size + min_dgram_size)) ||\r\n(ctx->tx_max > CDC_NCM_NTB_MAX_SIZE_TX)) {\r\npr_debug("Using default maximum transmit length=%d\n",\r\nCDC_NCM_NTB_MAX_SIZE_TX);\r\nctx->tx_max = CDC_NCM_NTB_MAX_SIZE_TX;\r\n}\r\nval = ctx->tx_ndp_modulus;\r\nif ((val < USB_CDC_NCM_NDP_ALIGN_MIN_SIZE) ||\r\n(val != ((-val) & val)) || (val >= ctx->tx_max)) {\r\npr_debug("Using default alignment: 4 bytes\n");\r\nctx->tx_ndp_modulus = USB_CDC_NCM_NDP_ALIGN_MIN_SIZE;\r\n}\r\nval = ctx->tx_modulus;\r\nif ((val < USB_CDC_NCM_NDP_ALIGN_MIN_SIZE) ||\r\n(val != ((-val) & val)) || (val >= ctx->tx_max)) {\r\npr_debug("Using default transmit modulus: 4 bytes\n");\r\nctx->tx_modulus = USB_CDC_NCM_NDP_ALIGN_MIN_SIZE;\r\n}\r\nif (ctx->tx_remainder >= ctx->tx_modulus) {\r\npr_debug("Using default transmit remainder: 0 bytes\n");\r\nctx->tx_remainder = 0;\r\n}\r\nctx->tx_remainder = ((ctx->tx_remainder - eth_hlen) &\r\n(ctx->tx_modulus - 1));\r\nif (flags & USB_CDC_NCM_NCAP_CRC_MODE) {\r\nerr = usbnet_write_cmd(dev, USB_CDC_SET_CRC_MODE,\r\nUSB_TYPE_CLASS | USB_DIR_OUT\r\n| USB_RECIP_INTERFACE,\r\nUSB_CDC_NCM_CRC_NOT_APPENDED,\r\niface_no, NULL, 0);\r\nif (err < 0)\r\npr_debug("Setting CRC mode off failed\n");\r\n}\r\nif (ntb_fmt_supported & USB_CDC_NCM_NTH32_SIGN) {\r\nerr = usbnet_write_cmd(dev, USB_CDC_SET_NTB_FORMAT,\r\nUSB_TYPE_CLASS | USB_DIR_OUT\r\n| USB_RECIP_INTERFACE,\r\nUSB_CDC_NCM_NTB16_FORMAT,\r\niface_no, NULL, 0);\r\nif (err < 0)\r\npr_debug("Setting NTB format to 16-bit failed\n");\r\n}\r\nctx->max_datagram_size = min_dgram_size;\r\nif (flags & USB_CDC_NCM_NCAP_MAX_DATAGRAM_SIZE) {\r\n__le16 max_datagram_size;\r\nu16 eth_max_sz;\r\nif (ctx->ether_desc != NULL)\r\neth_max_sz = le16_to_cpu(ctx->ether_desc->wMaxSegmentSize);\r\nelse if (ctx->mbim_desc != NULL)\r\neth_max_sz = le16_to_cpu(ctx->mbim_desc->wMaxSegmentSize);\r\nelse\r\ngoto max_dgram_err;\r\nerr = usbnet_read_cmd(dev, USB_CDC_GET_MAX_DATAGRAM_SIZE,\r\nUSB_TYPE_CLASS | USB_DIR_IN\r\n| USB_RECIP_INTERFACE,\r\n0, iface_no, &max_datagram_size, 2);\r\nif (err < 0) {\r\npr_debug("GET_MAX_DATAGRAM_SIZE failed, use size=%u\n",\r\nmin_dgram_size);\r\n} else {\r\nctx->max_datagram_size =\r\nle16_to_cpu(max_datagram_size);\r\nif (ctx->max_datagram_size > eth_max_sz)\r\nctx->max_datagram_size = eth_max_sz;\r\nif (ctx->max_datagram_size > CDC_NCM_MAX_DATAGRAM_SIZE)\r\nctx->max_datagram_size = CDC_NCM_MAX_DATAGRAM_SIZE;\r\nif (ctx->max_datagram_size < min_dgram_size)\r\nctx->max_datagram_size = min_dgram_size;\r\nif (ctx->max_datagram_size !=\r\nle16_to_cpu(max_datagram_size)) {\r\nerr = usbnet_write_cmd(dev,\r\nUSB_CDC_SET_MAX_DATAGRAM_SIZE,\r\nUSB_TYPE_CLASS | USB_DIR_OUT\r\n| USB_RECIP_INTERFACE,\r\n0,\r\niface_no, &max_datagram_size,\r\n2);\r\nif (err < 0)\r\npr_debug("SET_MAX_DGRAM_SIZE failed\n");\r\n}\r\n}\r\n}\r\nmax_dgram_err:\r\nif (ctx->netdev->mtu != (ctx->max_datagram_size - eth_hlen))\r\nctx->netdev->mtu = ctx->max_datagram_size - eth_hlen;\r\nreturn 0;\r\n}\r\nstatic void\r\ncdc_ncm_find_endpoints(struct cdc_ncm_ctx *ctx, struct usb_interface *intf)\r\n{\r\nstruct usb_host_endpoint *e;\r\nu8 ep;\r\nfor (ep = 0; ep < intf->cur_altsetting->desc.bNumEndpoints; ep++) {\r\ne = intf->cur_altsetting->endpoint + ep;\r\nswitch (e->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (usb_endpoint_dir_in(&e->desc)) {\r\nif (ctx->status_ep == NULL)\r\nctx->status_ep = e;\r\n}\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (usb_endpoint_dir_in(&e->desc)) {\r\nif (ctx->in_ep == NULL)\r\nctx->in_ep = e;\r\n} else {\r\nif (ctx->out_ep == NULL)\r\nctx->out_ep = e;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void cdc_ncm_free(struct cdc_ncm_ctx *ctx)\r\n{\r\nif (ctx == NULL)\r\nreturn;\r\nif (ctx->tx_rem_skb != NULL) {\r\ndev_kfree_skb_any(ctx->tx_rem_skb);\r\nctx->tx_rem_skb = NULL;\r\n}\r\nif (ctx->tx_curr_skb != NULL) {\r\ndev_kfree_skb_any(ctx->tx_curr_skb);\r\nctx->tx_curr_skb = NULL;\r\n}\r\nkfree(ctx);\r\n}\r\nint cdc_ncm_bind_common(struct usbnet *dev, struct usb_interface *intf, u8 data_altsetting)\r\n{\r\nstruct cdc_ncm_ctx *ctx;\r\nstruct usb_driver *driver;\r\nu8 *buf;\r\nint len;\r\nint temp;\r\nu8 iface_no;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nhrtimer_init(&ctx->tx_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\r\nctx->tx_timer.function = &cdc_ncm_tx_timer_cb;\r\nctx->bh.data = (unsigned long)ctx;\r\nctx->bh.func = cdc_ncm_txpath_bh;\r\natomic_set(&ctx->stop, 0);\r\nspin_lock_init(&ctx->mtx);\r\nctx->netdev = dev->net;\r\ndev->data[0] = (unsigned long)ctx;\r\ndriver = driver_of(intf);\r\nbuf = intf->cur_altsetting->extra;\r\nlen = intf->cur_altsetting->extralen;\r\nctx->udev = dev->udev;\r\nctx->intf = intf;\r\nwhile ((len > 0) && (buf[0] > 2) && (buf[0] <= len)) {\r\nif (buf[1] != USB_DT_CS_INTERFACE)\r\ngoto advance;\r\nswitch (buf[2]) {\r\ncase USB_CDC_UNION_TYPE:\r\nif (buf[0] < sizeof(*(ctx->union_desc)))\r\nbreak;\r\nctx->union_desc =\r\n(const struct usb_cdc_union_desc *)buf;\r\nctx->control = usb_ifnum_to_if(dev->udev,\r\nctx->union_desc->bMasterInterface0);\r\nctx->data = usb_ifnum_to_if(dev->udev,\r\nctx->union_desc->bSlaveInterface0);\r\nbreak;\r\ncase USB_CDC_ETHERNET_TYPE:\r\nif (buf[0] < sizeof(*(ctx->ether_desc)))\r\nbreak;\r\nctx->ether_desc =\r\n(const struct usb_cdc_ether_desc *)buf;\r\ndev->hard_mtu =\r\nle16_to_cpu(ctx->ether_desc->wMaxSegmentSize);\r\nif (dev->hard_mtu < CDC_NCM_MIN_DATAGRAM_SIZE)\r\ndev->hard_mtu = CDC_NCM_MIN_DATAGRAM_SIZE;\r\nelse if (dev->hard_mtu > CDC_NCM_MAX_DATAGRAM_SIZE)\r\ndev->hard_mtu = CDC_NCM_MAX_DATAGRAM_SIZE;\r\nbreak;\r\ncase USB_CDC_NCM_TYPE:\r\nif (buf[0] < sizeof(*(ctx->func_desc)))\r\nbreak;\r\nctx->func_desc = (const struct usb_cdc_ncm_desc *)buf;\r\nbreak;\r\ncase USB_CDC_MBIM_TYPE:\r\nif (buf[0] < sizeof(*(ctx->mbim_desc)))\r\nbreak;\r\nctx->mbim_desc = (const struct usb_cdc_mbim_desc *)buf;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nadvance:\r\ntemp = buf[0];\r\nbuf += temp;\r\nlen -= temp;\r\n}\r\nif (!ctx->union_desc && intf->intf_assoc && intf->intf_assoc->bInterfaceCount == 2) {\r\nctx->control = intf;\r\nctx->data = usb_ifnum_to_if(dev->udev, intf->cur_altsetting->desc.bInterfaceNumber + 1);\r\ndev_dbg(&intf->dev, "CDC Union missing - got slave from IAD\n");\r\n}\r\nif ((ctx->control == NULL) || (ctx->data == NULL) ||\r\n((!ctx->mbim_desc) && ((ctx->ether_desc == NULL) || (ctx->control != intf))))\r\ngoto error;\r\nif (ctx->data != ctx->control) {\r\ntemp = usb_driver_claim_interface(driver, ctx->data, dev);\r\nif (temp)\r\ngoto error;\r\n}\r\niface_no = ctx->data->cur_altsetting->desc.bInterfaceNumber;\r\ntemp = usb_set_interface(dev->udev, iface_no, 0);\r\nif (temp)\r\ngoto error2;\r\nif (cdc_ncm_setup(ctx))\r\ngoto error2;\r\ntemp = usb_set_interface(dev->udev, iface_no, data_altsetting);\r\nif (temp)\r\ngoto error2;\r\ncdc_ncm_find_endpoints(ctx, ctx->data);\r\ncdc_ncm_find_endpoints(ctx, ctx->control);\r\nif ((ctx->in_ep == NULL) || (ctx->out_ep == NULL) ||\r\n(ctx->status_ep == NULL))\r\ngoto error2;\r\ndev->net->ethtool_ops = &cdc_ncm_ethtool_ops;\r\nusb_set_intfdata(ctx->data, dev);\r\nusb_set_intfdata(ctx->control, dev);\r\nusb_set_intfdata(ctx->intf, dev);\r\nif (ctx->ether_desc) {\r\ntemp = usbnet_get_ethernet_addr(dev, ctx->ether_desc->iMACAddress);\r\nif (temp)\r\ngoto error2;\r\ndev_info(&dev->udev->dev, "MAC-Address: %pM\n", dev->net->dev_addr);\r\n}\r\ndev->in = usb_rcvbulkpipe(dev->udev,\r\nctx->in_ep->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\r\ndev->out = usb_sndbulkpipe(dev->udev,\r\nctx->out_ep->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\r\ndev->status = ctx->status_ep;\r\ndev->rx_urb_size = ctx->rx_max;\r\nctx->tx_speed = ctx->rx_speed = 0;\r\nreturn 0;\r\nerror2:\r\nusb_set_intfdata(ctx->control, NULL);\r\nusb_set_intfdata(ctx->data, NULL);\r\nif (ctx->data != ctx->control)\r\nusb_driver_release_interface(driver, ctx->data);\r\nerror:\r\ncdc_ncm_free((struct cdc_ncm_ctx *)dev->data[0]);\r\ndev->data[0] = 0;\r\ndev_info(&dev->udev->dev, "bind() failure\n");\r\nreturn -ENODEV;\r\n}\r\nvoid cdc_ncm_unbind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nstruct usb_driver *driver = driver_of(intf);\r\nif (ctx == NULL)\r\nreturn;\r\natomic_set(&ctx->stop, 1);\r\nif (hrtimer_active(&ctx->tx_timer))\r\nhrtimer_cancel(&ctx->tx_timer);\r\ntasklet_kill(&ctx->bh);\r\nif (ctx->control == ctx->data)\r\nctx->data = NULL;\r\nif (intf == ctx->control && ctx->data) {\r\nusb_set_intfdata(ctx->data, NULL);\r\nusb_driver_release_interface(driver, ctx->data);\r\nctx->data = NULL;\r\n} else if (intf == ctx->data && ctx->control) {\r\nusb_set_intfdata(ctx->control, NULL);\r\nusb_driver_release_interface(driver, ctx->control);\r\nctx->control = NULL;\r\n}\r\nusb_set_intfdata(ctx->intf, NULL);\r\ncdc_ncm_free(ctx);\r\n}\r\nu8 cdc_ncm_select_altsetting(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct usb_host_interface *alt;\r\nif (prefer_mbim && intf->num_altsetting == 2) {\r\nalt = usb_altnum_to_altsetting(intf, CDC_NCM_COMM_ALTSETTING_MBIM);\r\nif (alt && cdc_ncm_comm_intf_is_mbim(alt) &&\r\n!usb_set_interface(dev->udev,\r\nintf->cur_altsetting->desc.bInterfaceNumber,\r\nCDC_NCM_COMM_ALTSETTING_MBIM))\r\nreturn CDC_NCM_DATA_ALTSETTING_MBIM;\r\n}\r\nreturn CDC_NCM_DATA_ALTSETTING_NCM;\r\n}\r\nstatic int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint ret;\r\ncdc_ncm_select_altsetting(dev, intf);\r\nif (cdc_ncm_comm_intf_is_mbim(intf->cur_altsetting))\r\nreturn -ENODEV;\r\nret = cdc_ncm_bind_common(dev, intf, 1);\r\nusbnet_link_change(dev, 0, 0);\r\nreturn ret;\r\n}\r\nstatic void cdc_ncm_align_tail(struct sk_buff *skb, size_t modulus, size_t remainder, size_t max)\r\n{\r\nsize_t align = ALIGN(skb->len, modulus) - skb->len + remainder;\r\nif (skb->len + align > max)\r\nalign = max - skb->len;\r\nif (align && skb_tailroom(skb) >= align)\r\nmemset(skb_put(skb, align), 0, align);\r\n}\r\nstatic struct usb_cdc_ncm_ndp16 *cdc_ncm_ndp(struct cdc_ncm_ctx *ctx, struct sk_buff *skb, __le32 sign, size_t reserve)\r\n{\r\nstruct usb_cdc_ncm_ndp16 *ndp16 = NULL;\r\nstruct usb_cdc_ncm_nth16 *nth16 = (void *)skb->data;\r\nsize_t ndpoffset = le16_to_cpu(nth16->wNdpIndex);\r\nwhile (ndpoffset) {\r\nndp16 = (struct usb_cdc_ncm_ndp16 *)(skb->data + ndpoffset);\r\nif (ndp16->dwSignature == sign)\r\nreturn ndp16;\r\nndpoffset = le16_to_cpu(ndp16->wNextNdpIndex);\r\n}\r\ncdc_ncm_align_tail(skb, ctx->tx_ndp_modulus, 0, ctx->tx_max);\r\nif ((ctx->tx_max - skb->len - reserve) < CDC_NCM_NDP_SIZE)\r\nreturn NULL;\r\nif (ndp16)\r\nndp16->wNextNdpIndex = cpu_to_le16(skb->len);\r\nelse\r\nnth16->wNdpIndex = cpu_to_le16(skb->len);\r\nndp16 = (struct usb_cdc_ncm_ndp16 *)memset(skb_put(skb, CDC_NCM_NDP_SIZE), 0, CDC_NCM_NDP_SIZE);\r\nndp16->dwSignature = sign;\r\nndp16->wLength = cpu_to_le16(sizeof(struct usb_cdc_ncm_ndp16) + sizeof(struct usb_cdc_ncm_dpe16));\r\nreturn ndp16;\r\n}\r\nstruct sk_buff *\r\ncdc_ncm_fill_tx_frame(struct cdc_ncm_ctx *ctx, struct sk_buff *skb, __le32 sign)\r\n{\r\nstruct usb_cdc_ncm_nth16 *nth16;\r\nstruct usb_cdc_ncm_ndp16 *ndp16;\r\nstruct sk_buff *skb_out;\r\nu16 n = 0, index, ndplen;\r\nu8 ready2send = 0;\r\nif (skb != NULL) {\r\nswap(skb, ctx->tx_rem_skb);\r\nswap(sign, ctx->tx_rem_sign);\r\n} else {\r\nready2send = 1;\r\n}\r\nskb_out = ctx->tx_curr_skb;\r\nif (!skb_out) {\r\nskb_out = alloc_skb((ctx->tx_max + 1), GFP_ATOMIC);\r\nif (skb_out == NULL) {\r\nif (skb != NULL) {\r\ndev_kfree_skb_any(skb);\r\nctx->netdev->stats.tx_dropped++;\r\n}\r\ngoto exit_no_skb;\r\n}\r\nnth16 = (struct usb_cdc_ncm_nth16 *)memset(skb_put(skb_out, sizeof(struct usb_cdc_ncm_nth16)), 0, sizeof(struct usb_cdc_ncm_nth16));\r\nnth16->dwSignature = cpu_to_le32(USB_CDC_NCM_NTH16_SIGN);\r\nnth16->wHeaderLength = cpu_to_le16(sizeof(struct usb_cdc_ncm_nth16));\r\nnth16->wSequence = cpu_to_le16(ctx->tx_seq++);\r\nctx->tx_curr_frame_num = 0;\r\n}\r\nfor (n = ctx->tx_curr_frame_num; n < ctx->tx_max_datagrams; n++) {\r\nif (skb == NULL) {\r\nskb = ctx->tx_rem_skb;\r\nsign = ctx->tx_rem_sign;\r\nctx->tx_rem_skb = NULL;\r\nif (skb == NULL)\r\nbreak;\r\n}\r\nndp16 = cdc_ncm_ndp(ctx, skb_out, sign, skb->len + ctx->tx_modulus + ctx->tx_remainder);\r\ncdc_ncm_align_tail(skb_out, ctx->tx_modulus, ctx->tx_remainder, ctx->tx_max);\r\nif (!ndp16 || skb_out->len + skb->len > ctx->tx_max) {\r\nif (n == 0) {\r\ndev_kfree_skb_any(skb);\r\nskb = NULL;\r\nctx->netdev->stats.tx_dropped++;\r\n} else {\r\nif (ctx->tx_rem_skb != NULL) {\r\ndev_kfree_skb_any(ctx->tx_rem_skb);\r\nctx->netdev->stats.tx_dropped++;\r\n}\r\nctx->tx_rem_skb = skb;\r\nctx->tx_rem_sign = sign;\r\nskb = NULL;\r\nready2send = 1;\r\n}\r\nbreak;\r\n}\r\nndplen = le16_to_cpu(ndp16->wLength);\r\nindex = (ndplen - sizeof(struct usb_cdc_ncm_ndp16)) / sizeof(struct usb_cdc_ncm_dpe16) - 1;\r\nndp16->dpe16[index].wDatagramLength = cpu_to_le16(skb->len);\r\nndp16->dpe16[index].wDatagramIndex = cpu_to_le16(skb_out->len);\r\nndp16->wLength = cpu_to_le16(ndplen + sizeof(struct usb_cdc_ncm_dpe16));\r\nmemcpy(skb_put(skb_out, skb->len), skb->data, skb->len);\r\ndev_kfree_skb_any(skb);\r\nskb = NULL;\r\nif (index >= CDC_NCM_DPT_DATAGRAMS_MAX) {\r\nready2send = 1;\r\nbreak;\r\n}\r\n}\r\nif (skb != NULL) {\r\ndev_kfree_skb_any(skb);\r\nskb = NULL;\r\nctx->netdev->stats.tx_dropped++;\r\n}\r\nctx->tx_curr_frame_num = n;\r\nif (n == 0) {\r\nctx->tx_curr_skb = skb_out;\r\ngoto exit_no_skb;\r\n} else if ((n < ctx->tx_max_datagrams) && (ready2send == 0)) {\r\nctx->tx_curr_skb = skb_out;\r\nif (n < CDC_NCM_RESTART_TIMER_DATAGRAM_CNT)\r\nctx->tx_timer_pending = CDC_NCM_TIMER_PENDING_CNT;\r\ngoto exit_no_skb;\r\n} else {\r\n}\r\nif (skb_out->len > CDC_NCM_MIN_TX_PKT)\r\nmemset(skb_put(skb_out, ctx->tx_max - skb_out->len), 0, ctx->tx_max - skb_out->len);\r\nif (((skb_out->len % le16_to_cpu(ctx->out_ep->desc.wMaxPacketSize)) == 0) &&\r\n(skb_out->len < le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize)) && skb_tailroom(skb_out))\r\n*skb_put(skb_out, 1) = 0;\r\nnth16 = (struct usb_cdc_ncm_nth16 *)skb_out->data;\r\nnth16->wBlockLength = cpu_to_le16(skb_out->len);\r\nctx->tx_curr_skb = NULL;\r\nctx->netdev->stats.tx_packets += ctx->tx_curr_frame_num;\r\nreturn skb_out;\r\nexit_no_skb:\r\nif (ctx->tx_curr_skb != NULL)\r\ncdc_ncm_tx_timeout_start(ctx);\r\nreturn NULL;\r\n}\r\nstatic void cdc_ncm_tx_timeout_start(struct cdc_ncm_ctx *ctx)\r\n{\r\nif (!(hrtimer_active(&ctx->tx_timer) || atomic_read(&ctx->stop)))\r\nhrtimer_start(&ctx->tx_timer,\r\nktime_set(0, CDC_NCM_TIMER_INTERVAL),\r\nHRTIMER_MODE_REL);\r\n}\r\nstatic enum hrtimer_restart cdc_ncm_tx_timer_cb(struct hrtimer *timer)\r\n{\r\nstruct cdc_ncm_ctx *ctx =\r\ncontainer_of(timer, struct cdc_ncm_ctx, tx_timer);\r\nif (!atomic_read(&ctx->stop))\r\ntasklet_schedule(&ctx->bh);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic void cdc_ncm_txpath_bh(unsigned long param)\r\n{\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)param;\r\nspin_lock_bh(&ctx->mtx);\r\nif (ctx->tx_timer_pending != 0) {\r\nctx->tx_timer_pending--;\r\ncdc_ncm_tx_timeout_start(ctx);\r\nspin_unlock_bh(&ctx->mtx);\r\n} else if (ctx->netdev != NULL) {\r\nspin_unlock_bh(&ctx->mtx);\r\nnetif_tx_lock_bh(ctx->netdev);\r\nusbnet_start_xmit(NULL, ctx->netdev);\r\nnetif_tx_unlock_bh(ctx->netdev);\r\n} else {\r\nspin_unlock_bh(&ctx->mtx);\r\n}\r\n}\r\nstatic struct sk_buff *\r\ncdc_ncm_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\r\n{\r\nstruct sk_buff *skb_out;\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nif (ctx == NULL)\r\ngoto error;\r\nspin_lock_bh(&ctx->mtx);\r\nskb_out = cdc_ncm_fill_tx_frame(ctx, skb, cpu_to_le32(USB_CDC_NCM_NDP16_NOCRC_SIGN));\r\nspin_unlock_bh(&ctx->mtx);\r\nreturn skb_out;\r\nerror:\r\nif (skb != NULL)\r\ndev_kfree_skb_any(skb);\r\nreturn NULL;\r\n}\r\nint cdc_ncm_rx_verify_nth16(struct cdc_ncm_ctx *ctx, struct sk_buff *skb_in)\r\n{\r\nstruct usb_cdc_ncm_nth16 *nth16;\r\nint len;\r\nint ret = -EINVAL;\r\nif (ctx == NULL)\r\ngoto error;\r\nif (skb_in->len < (sizeof(struct usb_cdc_ncm_nth16) +\r\nsizeof(struct usb_cdc_ncm_ndp16))) {\r\npr_debug("frame too short\n");\r\ngoto error;\r\n}\r\nnth16 = (struct usb_cdc_ncm_nth16 *)skb_in->data;\r\nif (le32_to_cpu(nth16->dwSignature) != USB_CDC_NCM_NTH16_SIGN) {\r\npr_debug("invalid NTH16 signature <%u>\n",\r\nle32_to_cpu(nth16->dwSignature));\r\ngoto error;\r\n}\r\nlen = le16_to_cpu(nth16->wBlockLength);\r\nif (len > ctx->rx_max) {\r\npr_debug("unsupported NTB block length %u/%u\n", len,\r\nctx->rx_max);\r\ngoto error;\r\n}\r\nif ((ctx->rx_seq + 1) != le16_to_cpu(nth16->wSequence) &&\r\n(ctx->rx_seq || le16_to_cpu(nth16->wSequence)) &&\r\n!((ctx->rx_seq == 0xffff) && !le16_to_cpu(nth16->wSequence))) {\r\npr_debug("sequence number glitch prev=%d curr=%d\n",\r\nctx->rx_seq, le16_to_cpu(nth16->wSequence));\r\n}\r\nctx->rx_seq = le16_to_cpu(nth16->wSequence);\r\nret = le16_to_cpu(nth16->wNdpIndex);\r\nerror:\r\nreturn ret;\r\n}\r\nint cdc_ncm_rx_verify_ndp16(struct sk_buff *skb_in, int ndpoffset)\r\n{\r\nstruct usb_cdc_ncm_ndp16 *ndp16;\r\nint ret = -EINVAL;\r\nif ((ndpoffset + sizeof(struct usb_cdc_ncm_ndp16)) > skb_in->len) {\r\npr_debug("invalid NDP offset <%u>\n", ndpoffset);\r\ngoto error;\r\n}\r\nndp16 = (struct usb_cdc_ncm_ndp16 *)(skb_in->data + ndpoffset);\r\nif (le16_to_cpu(ndp16->wLength) < USB_CDC_NCM_NDP16_LENGTH_MIN) {\r\npr_debug("invalid DPT16 length <%u>\n",\r\nle32_to_cpu(ndp16->dwSignature));\r\ngoto error;\r\n}\r\nret = ((le16_to_cpu(ndp16->wLength) -\r\nsizeof(struct usb_cdc_ncm_ndp16)) /\r\nsizeof(struct usb_cdc_ncm_dpe16));\r\nret--;\r\nif ((sizeof(struct usb_cdc_ncm_ndp16) + ret * (sizeof(struct usb_cdc_ncm_dpe16))) >\r\nskb_in->len) {\r\npr_debug("Invalid nframes = %d\n", ret);\r\nret = -EINVAL;\r\n}\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int cdc_ncm_rx_fixup(struct usbnet *dev, struct sk_buff *skb_in)\r\n{\r\nstruct sk_buff *skb;\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nint len;\r\nint nframes;\r\nint x;\r\nint offset;\r\nstruct usb_cdc_ncm_ndp16 *ndp16;\r\nstruct usb_cdc_ncm_dpe16 *dpe16;\r\nint ndpoffset;\r\nint loopcount = 50;\r\nndpoffset = cdc_ncm_rx_verify_nth16(ctx, skb_in);\r\nif (ndpoffset < 0)\r\ngoto error;\r\nnext_ndp:\r\nnframes = cdc_ncm_rx_verify_ndp16(skb_in, ndpoffset);\r\nif (nframes < 0)\r\ngoto error;\r\nndp16 = (struct usb_cdc_ncm_ndp16 *)(skb_in->data + ndpoffset);\r\nif (le32_to_cpu(ndp16->dwSignature) != USB_CDC_NCM_NDP16_NOCRC_SIGN) {\r\npr_debug("invalid DPT16 signature <%u>\n",\r\nle32_to_cpu(ndp16->dwSignature));\r\ngoto err_ndp;\r\n}\r\ndpe16 = ndp16->dpe16;\r\nfor (x = 0; x < nframes; x++, dpe16++) {\r\noffset = le16_to_cpu(dpe16->wDatagramIndex);\r\nlen = le16_to_cpu(dpe16->wDatagramLength);\r\nif ((offset == 0) || (len == 0)) {\r\nif (!x)\r\ngoto err_ndp;\r\nbreak;\r\n}\r\nif (((offset + len) > skb_in->len) ||\r\n(len > ctx->rx_max) || (len < ETH_HLEN)) {\r\npr_debug("invalid frame detected (ignored)"\r\n"offset[%u]=%u, length=%u, skb=%p\n",\r\nx, offset, len, skb_in);\r\nif (!x)\r\ngoto err_ndp;\r\nbreak;\r\n} else {\r\nskb = skb_clone(skb_in, GFP_ATOMIC);\r\nif (!skb)\r\ngoto error;\r\nskb->len = len;\r\nskb->data = ((u8 *)skb_in->data) + offset;\r\nskb_set_tail_pointer(skb, len);\r\nusbnet_skb_return(dev, skb);\r\n}\r\n}\r\nerr_ndp:\r\nndpoffset = le16_to_cpu(ndp16->wNextNdpIndex);\r\nif (ndpoffset && loopcount--)\r\ngoto next_ndp;\r\nreturn 1;\r\nerror:\r\nreturn 0;\r\n}\r\nstatic void\r\ncdc_ncm_speed_change(struct cdc_ncm_ctx *ctx,\r\nstruct usb_cdc_speed_change *data)\r\n{\r\nuint32_t rx_speed = le32_to_cpu(data->DLBitRRate);\r\nuint32_t tx_speed = le32_to_cpu(data->ULBitRate);\r\nif ((tx_speed != ctx->tx_speed) || (rx_speed != ctx->rx_speed)) {\r\nctx->tx_speed = tx_speed;\r\nctx->rx_speed = rx_speed;\r\nif ((tx_speed > 1000000) && (rx_speed > 1000000)) {\r\nprintk(KERN_INFO KBUILD_MODNAME\r\n": %s: %u mbit/s downlink "\r\n"%u mbit/s uplink\n",\r\nctx->netdev->name,\r\n(unsigned int)(rx_speed / 1000000U),\r\n(unsigned int)(tx_speed / 1000000U));\r\n} else {\r\nprintk(KERN_INFO KBUILD_MODNAME\r\n": %s: %u kbit/s downlink "\r\n"%u kbit/s uplink\n",\r\nctx->netdev->name,\r\n(unsigned int)(rx_speed / 1000U),\r\n(unsigned int)(tx_speed / 1000U));\r\n}\r\n}\r\n}\r\nstatic void cdc_ncm_status(struct usbnet *dev, struct urb *urb)\r\n{\r\nstruct cdc_ncm_ctx *ctx;\r\nstruct usb_cdc_notification *event;\r\nctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nif (urb->actual_length < sizeof(*event))\r\nreturn;\r\nif (test_and_clear_bit(EVENT_STS_SPLIT, &dev->flags)) {\r\ncdc_ncm_speed_change(ctx,\r\n(struct usb_cdc_speed_change *)urb->transfer_buffer);\r\nreturn;\r\n}\r\nevent = urb->transfer_buffer;\r\nswitch (event->bNotificationType) {\r\ncase USB_CDC_NOTIFY_NETWORK_CONNECTION:\r\nctx->connected = le16_to_cpu(event->wValue);\r\nprintk(KERN_INFO KBUILD_MODNAME ": %s: network connection:"\r\n" %sconnected\n",\r\nctx->netdev->name, ctx->connected ? "" : "dis");\r\nusbnet_link_change(dev, ctx->connected, 0);\r\nif (!ctx->connected)\r\nctx->tx_speed = ctx->rx_speed = 0;\r\nbreak;\r\ncase USB_CDC_NOTIFY_SPEED_CHANGE:\r\nif (urb->actual_length < (sizeof(*event) +\r\nsizeof(struct usb_cdc_speed_change)))\r\nset_bit(EVENT_STS_SPLIT, &dev->flags);\r\nelse\r\ncdc_ncm_speed_change(ctx,\r\n(struct usb_cdc_speed_change *) &event[1]);\r\nbreak;\r\ndefault:\r\ndev_dbg(&dev->udev->dev,\r\n"NCM: unexpected notification 0x%02x!\n",\r\nevent->bNotificationType);\r\nbreak;\r\n}\r\n}\r\nstatic int cdc_ncm_check_connect(struct usbnet *dev)\r\n{\r\nstruct cdc_ncm_ctx *ctx;\r\nctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nif (ctx == NULL)\r\nreturn 1;\r\nreturn !ctx->connected;\r\n}\r\nstatic int\r\ncdc_ncm_probe(struct usb_interface *udev, const struct usb_device_id *prod)\r\n{\r\nreturn usbnet_probe(udev, prod);\r\n}\r\nstatic void cdc_ncm_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nif (dev == NULL)\r\nreturn;\r\nusbnet_disconnect(intf);\r\n}
