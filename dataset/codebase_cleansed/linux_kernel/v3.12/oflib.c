void of_init(void *promptr)\r\n{\r\nprom = (int (*)(void *))promptr;\r\n}\r\nint of_call_prom(const char *service, int nargs, int nret, ...)\r\n{\r\nint i;\r\nstruct prom_args {\r\nconst char *service;\r\nint nargs;\r\nint nret;\r\nunsigned int args[12];\r\n} args;\r\nva_list list;\r\nargs.service = service;\r\nargs.nargs = nargs;\r\nargs.nret = nret;\r\nva_start(list, nret);\r\nfor (i = 0; i < nargs; i++)\r\nargs.args[i] = va_arg(list, unsigned int);\r\nva_end(list);\r\nfor (i = 0; i < nret; i++)\r\nargs.args[nargs+i] = 0;\r\nif (prom(&args) < 0)\r\nreturn -1;\r\nreturn (nret > 0)? args.args[nargs]: 0;\r\n}\r\nstatic int of_call_prom_ret(const char *service, int nargs, int nret,\r\nunsigned int *rets, ...)\r\n{\r\nint i;\r\nstruct prom_args {\r\nconst char *service;\r\nint nargs;\r\nint nret;\r\nunsigned int args[12];\r\n} args;\r\nva_list list;\r\nargs.service = service;\r\nargs.nargs = nargs;\r\nargs.nret = nret;\r\nva_start(list, rets);\r\nfor (i = 0; i < nargs; i++)\r\nargs.args[i] = va_arg(list, unsigned int);\r\nva_end(list);\r\nfor (i = 0; i < nret; i++)\r\nargs.args[nargs+i] = 0;\r\nif (prom(&args) < 0)\r\nreturn -1;\r\nif (rets != (void *) 0)\r\nfor (i = 1; i < nret; ++i)\r\nrets[i-1] = args.args[nargs+i];\r\nreturn (nret > 0)? args.args[nargs]: 0;\r\n}\r\nstatic int string_match(const char *s1, const char *s2)\r\n{\r\nfor (; *s2; ++s2)\r\nif (*s1++ != *s2)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int check_of_version(void)\r\n{\r\nphandle oprom, chosen;\r\nchar version[64];\r\noprom = of_finddevice("/openprom");\r\nif (oprom == (phandle) -1)\r\nreturn 0;\r\nif (of_getprop(oprom, "model", version, sizeof(version)) <= 0)\r\nreturn 0;\r\nversion[sizeof(version)-1] = 0;\r\nprintf("OF version = '%s'\r\n", version);\r\nif (!string_match(version, "Open Firmware, 1.")\r\n&& !string_match(version, "FirmWorks,3."))\r\nreturn 0;\r\nchosen = of_finddevice("/chosen");\r\nif (chosen == (phandle) -1) {\r\nchosen = of_finddevice("/chosen@0");\r\nif (chosen == (phandle) -1) {\r\nprintf("no chosen\n");\r\nreturn 0;\r\n}\r\n}\r\nif (of_getprop(chosen, "mmu", &chosen_mmu, sizeof(chosen_mmu)) <= 0) {\r\nprintf("no mmu\n");\r\nreturn 0;\r\n}\r\nmemory = (ihandle) of_call_prom("open", 1, 1, "/memory");\r\nif (memory == (ihandle) -1) {\r\nmemory = (ihandle) of_call_prom("open", 1, 1, "/memory@0");\r\nif (memory == (ihandle) -1) {\r\nprintf("no memory node\n");\r\nreturn 0;\r\n}\r\n}\r\nprintf("old OF detected\r\n");\r\nreturn 1;\r\n}\r\nvoid *of_claim(unsigned long virt, unsigned long size, unsigned long align)\r\n{\r\nint ret;\r\nunsigned int result;\r\nif (need_map < 0)\r\nneed_map = check_of_version();\r\nif (align || !need_map)\r\nreturn (void *) of_call_prom("claim", 3, 1, virt, size, align);\r\nret = of_call_prom_ret("call-method", 5, 2, &result, "claim", memory,\r\nalign, size, virt);\r\nif (ret != 0 || result == -1)\r\nreturn (void *) -1;\r\nret = of_call_prom_ret("call-method", 5, 2, &result, "claim", chosen_mmu,\r\nalign, size, virt);\r\nret = of_call_prom("call-method", 6, 1, "map", chosen_mmu,\r\n0x12, size, virt, virt);\r\nreturn (void *) virt;\r\n}\r\nvoid *of_vmlinux_alloc(unsigned long size)\r\n{\r\nunsigned long start = (unsigned long)_start, end = (unsigned long)_end;\r\nvoid *addr;\r\nvoid *p;\r\naddr = of_claim(start, end - start, 0);\r\nprintf("Trying to claim from 0x%lx to 0x%lx (0x%lx) got %p\r\n",\r\nstart, end, end - start, addr);\r\np = malloc(size);\r\nif (!p)\r\nfatal("Can't allocate memory for kernel image!\n\r");\r\nreturn p;\r\n}\r\nvoid of_exit(void)\r\n{\r\nof_call_prom("exit", 0, 0);\r\n}\r\nvoid *of_finddevice(const char *name)\r\n{\r\nreturn (phandle) of_call_prom("finddevice", 1, 1, name);\r\n}\r\nint of_getprop(const void *phandle, const char *name, void *buf,\r\nconst int buflen)\r\n{\r\nreturn of_call_prom("getprop", 4, 1, phandle, name, buf, buflen);\r\n}\r\nint of_setprop(const void *phandle, const char *name, const void *buf,\r\nconst int buflen)\r\n{\r\nreturn of_call_prom("setprop", 4, 1, phandle, name, buf, buflen);\r\n}
