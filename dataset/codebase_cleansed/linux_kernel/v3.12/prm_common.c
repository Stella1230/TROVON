static void omap_prcm_events_filter_priority(unsigned long *events,\r\nunsigned long *priority_events)\r\n{\r\nint i;\r\nfor (i = 0; i < prcm_irq_setup->nr_regs; i++) {\r\npriority_events[i] =\r\nevents[i] & prcm_irq_setup->priority_mask[i];\r\nevents[i] ^= priority_events[i];\r\n}\r\n}\r\nstatic void omap_prcm_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nunsigned long pending[OMAP_PRCM_MAX_NR_PENDING_REG];\r\nunsigned long priority_pending[OMAP_PRCM_MAX_NR_PENDING_REG];\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nunsigned int virtirq;\r\nint nr_irq = prcm_irq_setup->nr_regs * 32;\r\nif (prcm_irq_setup->suspended) {\r\nprcm_irq_setup->save_and_clear_irqen(prcm_irq_setup->saved_mask);\r\nprcm_irq_setup->suspend_save_flag = true;\r\n}\r\nwhile (!prcm_irq_setup->suspended) {\r\nprcm_irq_setup->read_pending_irqs(pending);\r\nif (find_first_bit(pending, nr_irq) >= nr_irq)\r\nbreak;\r\nomap_prcm_events_filter_priority(pending, priority_pending);\r\nfor_each_set_bit(virtirq, priority_pending, nr_irq)\r\ngeneric_handle_irq(prcm_irq_setup->base_irq + virtirq);\r\nfor_each_set_bit(virtirq, pending, nr_irq)\r\ngeneric_handle_irq(prcm_irq_setup->base_irq + virtirq);\r\n}\r\nif (chip->irq_ack)\r\nchip->irq_ack(&desc->irq_data);\r\nif (chip->irq_eoi)\r\nchip->irq_eoi(&desc->irq_data);\r\nchip->irq_unmask(&desc->irq_data);\r\nprcm_irq_setup->ocp_barrier();\r\n}\r\nint omap_prcm_event_to_irq(const char *name)\r\n{\r\nint i;\r\nif (!prcm_irq_setup || !name)\r\nreturn -ENOENT;\r\nfor (i = 0; i < prcm_irq_setup->nr_irqs; i++)\r\nif (!strcmp(prcm_irq_setup->irqs[i].name, name))\r\nreturn prcm_irq_setup->base_irq +\r\nprcm_irq_setup->irqs[i].offset;\r\nreturn -ENOENT;\r\n}\r\nvoid omap_prcm_irq_cleanup(void)\r\n{\r\nint i;\r\nif (!prcm_irq_setup) {\r\npr_err("PRCM: IRQ handler not initialized; cannot cleanup\n");\r\nreturn;\r\n}\r\nif (prcm_irq_chips) {\r\nfor (i = 0; i < prcm_irq_setup->nr_regs; i++) {\r\nif (prcm_irq_chips[i])\r\nirq_remove_generic_chip(prcm_irq_chips[i],\r\n0xffffffff, 0, 0);\r\nprcm_irq_chips[i] = NULL;\r\n}\r\nkfree(prcm_irq_chips);\r\nprcm_irq_chips = NULL;\r\n}\r\nkfree(prcm_irq_setup->saved_mask);\r\nprcm_irq_setup->saved_mask = NULL;\r\nkfree(prcm_irq_setup->priority_mask);\r\nprcm_irq_setup->priority_mask = NULL;\r\nirq_set_chained_handler(prcm_irq_setup->irq, NULL);\r\nif (prcm_irq_setup->base_irq > 0)\r\nirq_free_descs(prcm_irq_setup->base_irq,\r\nprcm_irq_setup->nr_regs * 32);\r\nprcm_irq_setup->base_irq = 0;\r\n}\r\nvoid omap_prcm_irq_prepare(void)\r\n{\r\nprcm_irq_setup->suspended = true;\r\n}\r\nvoid omap_prcm_irq_complete(void)\r\n{\r\nprcm_irq_setup->suspended = false;\r\nif (!prcm_irq_setup->suspend_save_flag)\r\nreturn;\r\nprcm_irq_setup->suspend_save_flag = false;\r\nprcm_irq_setup->restore_irqen(prcm_irq_setup->saved_mask);\r\n}\r\nint omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)\r\n{\r\nint nr_regs;\r\nu32 mask[OMAP_PRCM_MAX_NR_PENDING_REG];\r\nint offset, i;\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\nif (!irq_setup)\r\nreturn -EINVAL;\r\nnr_regs = irq_setup->nr_regs;\r\nif (prcm_irq_setup) {\r\npr_err("PRCM: already initialized; won't reinitialize\n");\r\nreturn -EINVAL;\r\n}\r\nif (nr_regs > OMAP_PRCM_MAX_NR_PENDING_REG) {\r\npr_err("PRCM: nr_regs too large\n");\r\nreturn -EINVAL;\r\n}\r\nprcm_irq_setup = irq_setup;\r\nprcm_irq_chips = kzalloc(sizeof(void *) * nr_regs, GFP_KERNEL);\r\nprcm_irq_setup->saved_mask = kzalloc(sizeof(u32) * nr_regs, GFP_KERNEL);\r\nprcm_irq_setup->priority_mask = kzalloc(sizeof(u32) * nr_regs,\r\nGFP_KERNEL);\r\nif (!prcm_irq_chips || !prcm_irq_setup->saved_mask ||\r\n!prcm_irq_setup->priority_mask) {\r\npr_err("PRCM: kzalloc failed\n");\r\ngoto err;\r\n}\r\nmemset(mask, 0, sizeof(mask));\r\nfor (i = 0; i < irq_setup->nr_irqs; i++) {\r\noffset = irq_setup->irqs[i].offset;\r\nmask[offset >> 5] |= 1 << (offset & 0x1f);\r\nif (irq_setup->irqs[i].priority)\r\nirq_setup->priority_mask[offset >> 5] |=\r\n1 << (offset & 0x1f);\r\n}\r\nirq_set_chained_handler(irq_setup->irq, omap_prcm_irq_handler);\r\nirq_setup->base_irq = irq_alloc_descs(-1, 0, irq_setup->nr_regs * 32,\r\n0);\r\nif (irq_setup->base_irq < 0) {\r\npr_err("PRCM: failed to allocate irq descs: %d\n",\r\nirq_setup->base_irq);\r\ngoto err;\r\n}\r\nfor (i = 0; i < irq_setup->nr_regs; i++) {\r\ngc = irq_alloc_generic_chip("PRCM", 1,\r\nirq_setup->base_irq + i * 32, prm_base,\r\nhandle_level_irq);\r\nif (!gc) {\r\npr_err("PRCM: failed to allocate generic chip\n");\r\ngoto err;\r\n}\r\nct = gc->chip_types;\r\nct->chip.irq_ack = irq_gc_ack_set_bit;\r\nct->chip.irq_mask = irq_gc_mask_clr_bit;\r\nct->chip.irq_unmask = irq_gc_mask_set_bit;\r\nct->regs.ack = irq_setup->ack + i * 4;\r\nct->regs.mask = irq_setup->mask + i * 4;\r\nirq_setup_generic_chip(gc, mask[i], 0, IRQ_NOREQUEST, 0);\r\nprcm_irq_chips[i] = gc;\r\n}\r\nreturn 0;\r\nerr:\r\nomap_prcm_irq_cleanup();\r\nreturn -ENOMEM;\r\n}\r\nvoid __init omap2_set_globals_prm(void __iomem *prm)\r\n{\r\nprm_base = prm;\r\n}\r\nu32 prm_read_reset_sources(void)\r\n{\r\nu32 ret = 1 << OMAP_UNKNOWN_RST_SRC_ID_SHIFT;\r\nif (prm_ll_data->read_reset_sources)\r\nret = prm_ll_data->read_reset_sources();\r\nelse\r\nWARN_ONCE(1, "prm: %s: no mapping function defined for reset sources\n", __func__);\r\nreturn ret;\r\n}\r\nbool prm_was_any_context_lost_old(u8 part, s16 inst, u16 idx)\r\n{\r\nbool ret = true;\r\nif (prm_ll_data->was_any_context_lost_old)\r\nret = prm_ll_data->was_any_context_lost_old(part, inst, idx);\r\nelse\r\nWARN_ONCE(1, "prm: %s: no mapping function defined\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nvoid prm_clear_context_loss_flags_old(u8 part, s16 inst, u16 idx)\r\n{\r\nif (prm_ll_data->clear_context_loss_flags_old)\r\nprm_ll_data->clear_context_loss_flags_old(part, inst, idx);\r\nelse\r\nWARN_ONCE(1, "prm: %s: no mapping function defined\n",\r\n__func__);\r\n}\r\nint prm_register(struct prm_ll_data *pld)\r\n{\r\nif (!pld)\r\nreturn -EINVAL;\r\nif (prm_ll_data != &null_prm_ll_data)\r\nreturn -EEXIST;\r\nprm_ll_data = pld;\r\nreturn 0;\r\n}\r\nint prm_unregister(struct prm_ll_data *pld)\r\n{\r\nif (!pld || prm_ll_data != pld)\r\nreturn -EINVAL;\r\nprm_ll_data = &null_prm_ll_data;\r\nreturn 0;\r\n}
