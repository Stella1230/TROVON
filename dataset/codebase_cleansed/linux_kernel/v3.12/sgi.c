int sgi_partition(struct parsed_partitions *state)\r\n{\r\nint i, csum;\r\n__be32 magic;\r\nint slot = 1;\r\nunsigned int start, blocks;\r\n__be32 *ui, cs;\r\nSector sect;\r\nstruct sgi_disklabel *label;\r\nstruct sgi_partition *p;\r\nchar b[BDEVNAME_SIZE];\r\nlabel = read_part_sector(state, 0, &sect);\r\nif (!label)\r\nreturn -1;\r\np = &label->partitions[0];\r\nmagic = label->magic_mushroom;\r\nif(be32_to_cpu(magic) != SGI_LABEL_MAGIC) {\r\nput_dev_sector(sect);\r\nreturn 0;\r\n}\r\nui = ((__be32 *) (label + 1)) - 1;\r\nfor(csum = 0; ui >= ((__be32 *) label);) {\r\ncs = *ui--;\r\ncsum += be32_to_cpu(cs);\r\n}\r\nif(csum) {\r\nprintk(KERN_WARNING "Dev %s SGI disklabel: csum bad, label corrupted\n",\r\nbdevname(state->bdev, b));\r\nput_dev_sector(sect);\r\nreturn 0;\r\n}\r\nfor(i = 0; i < 16; i++, p++) {\r\nblocks = be32_to_cpu(p->num_blocks);\r\nstart = be32_to_cpu(p->first_block);\r\nif (blocks) {\r\nput_partition(state, slot, start, blocks);\r\nif (be32_to_cpu(p->type) == LINUX_RAID_PARTITION)\r\nstate->parts[slot].flags = ADDPART_FLAG_RAID;\r\n}\r\nslot++;\r\n}\r\nstrlcat(state->pp_buf, "\n", PAGE_SIZE);\r\nput_dev_sector(sect);\r\nreturn 1;\r\n}
