static netdev_tx_t nlmon_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nint len = skb->len;\r\nstruct pcpu_lstats *stats = this_cpu_ptr(dev->lstats);\r\nu64_stats_update_begin(&stats->syncp);\r\nstats->bytes += len;\r\nstats->packets++;\r\nu64_stats_update_end(&stats->syncp);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int nlmon_is_valid_mtu(int new_mtu)\r\n{\r\nreturn new_mtu >= (int) sizeof(struct nlmsghdr);\r\n}\r\nstatic int nlmon_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif (!nlmon_is_valid_mtu(new_mtu))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic int nlmon_dev_init(struct net_device *dev)\r\n{\r\ndev->lstats = alloc_percpu(struct pcpu_lstats);\r\nreturn dev->lstats == NULL ? -ENOMEM : 0;\r\n}\r\nstatic void nlmon_dev_uninit(struct net_device *dev)\r\n{\r\nfree_percpu(dev->lstats);\r\n}\r\nstatic int nlmon_open(struct net_device *dev)\r\n{\r\nstruct nlmon *nlmon = netdev_priv(dev);\r\nnlmon->nt.dev = dev;\r\nnlmon->nt.module = THIS_MODULE;\r\nreturn netlink_add_tap(&nlmon->nt);\r\n}\r\nstatic int nlmon_close(struct net_device *dev)\r\n{\r\nstruct nlmon *nlmon = netdev_priv(dev);\r\nreturn netlink_remove_tap(&nlmon->nt);\r\n}\r\nstatic struct rtnl_link_stats64 *\r\nnlmon_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\r\n{\r\nint i;\r\nu64 bytes = 0, packets = 0;\r\nfor_each_possible_cpu(i) {\r\nconst struct pcpu_lstats *nl_stats;\r\nu64 tbytes, tpackets;\r\nunsigned int start;\r\nnl_stats = per_cpu_ptr(dev->lstats, i);\r\ndo {\r\nstart = u64_stats_fetch_begin_bh(&nl_stats->syncp);\r\ntbytes = nl_stats->bytes;\r\ntpackets = nl_stats->packets;\r\n} while (u64_stats_fetch_retry_bh(&nl_stats->syncp, start));\r\npackets += tpackets;\r\nbytes += tbytes;\r\n}\r\nstats->rx_packets = packets;\r\nstats->tx_packets = 0;\r\nstats->rx_bytes = bytes;\r\nstats->tx_bytes = 0;\r\nreturn stats;\r\n}\r\nstatic u32 always_on(struct net_device *dev)\r\n{\r\nreturn 1;\r\n}\r\nstatic void nlmon_setup(struct net_device *dev)\r\n{\r\ndev->type = ARPHRD_NETLINK;\r\ndev->tx_queue_len = 0;\r\ndev->netdev_ops = &nlmon_ops;\r\ndev->ethtool_ops = &nlmon_ethtool_ops;\r\ndev->destructor = free_netdev;\r\ndev->features = NETIF_F_FRAGLIST | NETIF_F_HIGHDMA;\r\ndev->flags = IFF_NOARP;\r\ndev->mtu = NLMSG_GOODSIZE;\r\n}\r\nstatic int nlmon_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\nif (tb[IFLA_ADDRESS])\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic __init int nlmon_register(void)\r\n{\r\nreturn rtnl_link_register(&nlmon_link_ops);\r\n}\r\nstatic __exit void nlmon_unregister(void)\r\n{\r\nrtnl_link_unregister(&nlmon_link_ops);\r\n}
