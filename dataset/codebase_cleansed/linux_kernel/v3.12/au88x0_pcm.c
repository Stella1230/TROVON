static void vortex_notify_pcm_vol_change(struct snd_card *card,\r\nstruct snd_kcontrol *kctl, int activate)\r\n{\r\nif (activate)\r\nkctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nelse\r\nkctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO, &(kctl->id));\r\n}\r\nstatic int snd_vortex_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nvortex_t *vortex = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nif ((err =\r\nsnd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS)) < 0)\r\nreturn err;\r\nif ((err =\r\nsnd_pcm_hw_constraint_pow2(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES)) < 0)\r\nreturn err;\r\nsnd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_BUFFER_BYTES, 64);\r\nif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT) {\r\n#ifndef CHIP_AU8820\r\nif (VORTEX_PCM_TYPE(substream->pcm) == VORTEX_PCM_A3D) {\r\nruntime->hw = snd_vortex_playback_hw_a3d;\r\n}\r\n#endif\r\nif (VORTEX_PCM_TYPE(substream->pcm) == VORTEX_PCM_SPDIF) {\r\nruntime->hw = snd_vortex_playback_hw_spdif;\r\nswitch (vortex->spdif_sr) {\r\ncase 32000:\r\nruntime->hw.rates = SNDRV_PCM_RATE_32000;\r\nbreak;\r\ncase 44100:\r\nruntime->hw.rates = SNDRV_PCM_RATE_44100;\r\nbreak;\r\ncase 48000:\r\nruntime->hw.rates = SNDRV_PCM_RATE_48000;\r\nbreak;\r\n}\r\n}\r\nif (VORTEX_PCM_TYPE(substream->pcm) == VORTEX_PCM_ADB\r\n|| VORTEX_PCM_TYPE(substream->pcm) == VORTEX_PCM_I2S)\r\nruntime->hw = snd_vortex_playback_hw_adb;\r\n#ifdef CHIP_AU8830\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\r\nVORTEX_IS_QUAD(vortex) &&\r\nVORTEX_PCM_TYPE(substream->pcm) == VORTEX_PCM_ADB) {\r\nruntime->hw.channels_max = 4;\r\nsnd_pcm_hw_constraint_list(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\n&hw_constraints_au8830_channels);\r\n}\r\n#endif\r\nsubstream->runtime->private_data = NULL;\r\n}\r\n#ifndef CHIP_AU8810\r\nelse {\r\nruntime->hw = snd_vortex_playback_hw_wt;\r\nsubstream->runtime->private_data = NULL;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_vortex_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstream_t *stream = (stream_t *) substream->runtime->private_data;\r\nif (stream != NULL) {\r\nstream->substream = NULL;\r\nstream->nr_ch = 0;\r\n}\r\nsubstream->runtime->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_vortex_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nvortex_t *chip = snd_pcm_substream_chip(substream);\r\nstream_t *stream = (stream_t *) (substream->runtime->private_data);\r\nint err;\r\nerr =\r\nsnd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\nif (err < 0) {\r\nprintk(KERN_ERR "Vortex: pcm page alloc failed!\n");\r\nreturn err;\r\n}\r\nspin_lock_irq(&chip->lock);\r\nif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT) {\r\nint dma, type = VORTEX_PCM_TYPE(substream->pcm);\r\nif (stream != NULL)\r\nvortex_adb_allocroute(chip, stream->dma,\r\nstream->nr_ch, stream->dir,\r\nstream->type,\r\nsubstream->number);\r\ndma =\r\nvortex_adb_allocroute(chip, -1,\r\nparams_channels(hw_params),\r\nsubstream->stream, type,\r\nsubstream->number);\r\nif (dma < 0) {\r\nspin_unlock_irq(&chip->lock);\r\nreturn dma;\r\n}\r\nstream = substream->runtime->private_data = &chip->dma_adb[dma];\r\nstream->substream = substream;\r\nvortex_adbdma_setbuffers(chip, dma,\r\nparams_period_bytes(hw_params),\r\nparams_periods(hw_params));\r\nif (VORTEX_PCM_TYPE(substream->pcm) == VORTEX_PCM_ADB) {\r\nchip->pcm_vol[substream->number].active = 1;\r\nvortex_notify_pcm_vol_change(chip->card,\r\nchip->pcm_vol[substream->number].kctl, 1);\r\n}\r\n}\r\n#ifndef CHIP_AU8810\r\nelse {\r\nvortex_wt_allocroute(chip, substream->number,\r\nparams_channels(hw_params));\r\nstream = substream->runtime->private_data =\r\n&chip->dma_wt[substream->number];\r\nstream->dma = substream->number;\r\nstream->substream = substream;\r\nvortex_wtdma_setbuffers(chip, substream->number,\r\nparams_period_bytes(hw_params),\r\nparams_periods(hw_params));\r\n}\r\n#endif\r\nspin_unlock_irq(&chip->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_vortex_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nvortex_t *chip = snd_pcm_substream_chip(substream);\r\nstream_t *stream = (stream_t *) (substream->runtime->private_data);\r\nspin_lock_irq(&chip->lock);\r\nif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT) {\r\nif (stream != NULL) {\r\nif (VORTEX_PCM_TYPE(substream->pcm) == VORTEX_PCM_ADB) {\r\nchip->pcm_vol[substream->number].active = 0;\r\nvortex_notify_pcm_vol_change(chip->card,\r\nchip->pcm_vol[substream->number].kctl,\r\n0);\r\n}\r\nvortex_adb_allocroute(chip, stream->dma,\r\nstream->nr_ch, stream->dir,\r\nstream->type,\r\nsubstream->number);\r\n}\r\n}\r\n#ifndef CHIP_AU8810\r\nelse {\r\nif (stream != NULL)\r\nvortex_wt_allocroute(chip, stream->dma, 0);\r\n}\r\n#endif\r\nsubstream->runtime->private_data = NULL;\r\nspin_unlock_irq(&chip->lock);\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_vortex_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nvortex_t *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstream_t *stream = (stream_t *) substream->runtime->private_data;\r\nint dma = stream->dma, fmt, dir;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndir = 1;\r\nelse\r\ndir = 0;\r\nfmt = vortex_alsafmt_aspfmt(runtime->format);\r\nspin_lock_irq(&chip->lock);\r\nif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT) {\r\nvortex_adbdma_setmode(chip, dma, 1, dir, fmt,\r\nruntime->channels == 1 ? 0 : 1, 0);\r\nvortex_adbdma_setstartbuffer(chip, dma, 0);\r\nif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_SPDIF)\r\nvortex_adb_setsrc(chip, dma, runtime->rate, dir);\r\n}\r\n#ifndef CHIP_AU8810\r\nelse {\r\nvortex_wtdma_setmode(chip, dma, 1, fmt, 0, 0);\r\nvortex_wtdma_setstartbuffer(chip, dma, 0);\r\n}\r\n#endif\r\nspin_unlock_irq(&chip->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_vortex_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nvortex_t *chip = snd_pcm_substream_chip(substream);\r\nstream_t *stream = (stream_t *) substream->runtime->private_data;\r\nint dma = stream->dma;\r\nspin_lock(&chip->lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nstream->fifo_enabled = 1;\r\nif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT) {\r\nvortex_adbdma_resetup(chip, dma);\r\nvortex_adbdma_startfifo(chip, dma);\r\n}\r\n#ifndef CHIP_AU8810\r\nelse {\r\nprintk(KERN_INFO "vortex: wt start %d\n", dma);\r\nvortex_wtdma_startfifo(chip, dma);\r\n}\r\n#endif\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nstream->fifo_enabled = 0;\r\nif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT)\r\nvortex_adbdma_stopfifo(chip, dma);\r\n#ifndef CHIP_AU8810\r\nelse {\r\nprintk(KERN_INFO "vortex: wt stop %d\n", dma);\r\nvortex_wtdma_stopfifo(chip, dma);\r\n}\r\n#endif\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT)\r\nvortex_adbdma_pausefifo(chip, dma);\r\n#ifndef CHIP_AU8810\r\nelse\r\nvortex_wtdma_pausefifo(chip, dma);\r\n#endif\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT)\r\nvortex_adbdma_resumefifo(chip, dma);\r\n#ifndef CHIP_AU8810\r\nelse\r\nvortex_wtdma_resumefifo(chip, dma);\r\n#endif\r\nbreak;\r\ndefault:\r\nspin_unlock(&chip->lock);\r\nreturn -EINVAL;\r\n}\r\nspin_unlock(&chip->lock);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_vortex_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nvortex_t *chip = snd_pcm_substream_chip(substream);\r\nstream_t *stream = (stream_t *) substream->runtime->private_data;\r\nint dma = stream->dma;\r\nsnd_pcm_uframes_t current_ptr = 0;\r\nspin_lock(&chip->lock);\r\nif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT)\r\ncurrent_ptr = vortex_adbdma_getlinearpos(chip, dma);\r\n#ifndef CHIP_AU8810\r\nelse\r\ncurrent_ptr = vortex_wtdma_getlinearpos(chip, dma);\r\n#endif\r\nspin_unlock(&chip->lock);\r\nreturn (bytes_to_frames(substream->runtime, current_ptr));\r\n}\r\nstatic int snd_vortex_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_vortex_spdif_mask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = 0xff;\r\nucontrol->value.iec958.status[1] = 0xff;\r\nucontrol->value.iec958.status[2] = 0xff;\r\nucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS;\r\nreturn 0;\r\n}\r\nstatic int snd_vortex_spdif_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nvortex_t *vortex = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.iec958.status[0] = 0x00;\r\nucontrol->value.iec958.status[1] = IEC958_AES1_CON_ORIGINAL|IEC958_AES1_CON_DIGDIGCONV_ID;\r\nucontrol->value.iec958.status[2] = 0x00;\r\nswitch (vortex->spdif_sr) {\r\ncase 32000: ucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS_32000; break;\r\ncase 44100: ucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS_44100; break;\r\ncase 48000: ucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS_48000; break;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_vortex_spdif_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nvortex_t *vortex = snd_kcontrol_chip(kcontrol);\r\nint spdif_sr = 48000;\r\nswitch (ucontrol->value.iec958.status[3] & IEC958_AES3_CON_FS) {\r\ncase IEC958_AES3_CON_FS_32000: spdif_sr = 32000; break;\r\ncase IEC958_AES3_CON_FS_44100: spdif_sr = 44100; break;\r\ncase IEC958_AES3_CON_FS_48000: spdif_sr = 48000; break;\r\n}\r\nif (spdif_sr == vortex->spdif_sr)\r\nreturn 0;\r\nvortex->spdif_sr = spdif_sr;\r\nvortex_spdif_init(vortex, vortex->spdif_sr, 1);\r\nreturn 1;\r\n}\r\nstatic int snd_vortex_pcm_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nvortex_t *vortex = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = (VORTEX_IS_QUAD(vortex) ? 4 : 2);\r\nuinfo->value.integer.min = -128;\r\nuinfo->value.integer.max = 32;\r\nreturn 0;\r\n}\r\nstatic int snd_vortex_pcm_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint i;\r\nvortex_t *vortex = snd_kcontrol_chip(kcontrol);\r\nint subdev = kcontrol->id.subdevice;\r\nstruct pcm_vol *p = &vortex->pcm_vol[subdev];\r\nint max_chn = (VORTEX_IS_QUAD(vortex) ? 4 : 2);\r\nfor (i = 0; i < max_chn; i++)\r\nucontrol->value.integer.value[i] = p->vol[i];\r\nreturn 0;\r\n}\r\nstatic int snd_vortex_pcm_vol_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint i;\r\nint changed = 0;\r\nint mixin;\r\nunsigned char vol;\r\nvortex_t *vortex = snd_kcontrol_chip(kcontrol);\r\nint subdev = kcontrol->id.subdevice;\r\nstruct pcm_vol *p = &vortex->pcm_vol[subdev];\r\nint max_chn = (VORTEX_IS_QUAD(vortex) ? 4 : 2);\r\nfor (i = 0; i < max_chn; i++) {\r\nif (p->vol[i] != ucontrol->value.integer.value[i]) {\r\np->vol[i] = ucontrol->value.integer.value[i];\r\nif (p->active) {\r\nswitch (vortex->dma_adb[p->dma].nr_ch) {\r\ncase 1:\r\nmixin = p->mixin[0];\r\nbreak;\r\ncase 2:\r\ndefault:\r\nmixin = p->mixin[(i < 2) ? i : (i - 2)];\r\nbreak;\r\ncase 4:\r\nmixin = p->mixin[i];\r\nbreak;\r\n}\r\nvol = p->vol[i];\r\nvortex_mix_setinputvolumebyte(vortex,\r\nvortex->mixplayb[i], mixin, vol);\r\n}\r\nchanged = 1;\r\n}\r\n}\r\nreturn changed;\r\n}\r\nstatic int snd_vortex_new_pcm(vortex_t *chip, int idx, int nr)\r\n{\r\nstruct snd_pcm *pcm;\r\nstruct snd_kcontrol *kctl;\r\nint i;\r\nint err, nr_capt;\r\nif (!chip || idx < 0 || idx >= VORTEX_PCM_LAST)\r\nreturn -ENODEV;\r\nif (idx == VORTEX_PCM_ADB)\r\nnr_capt = nr;\r\nelse\r\nnr_capt = 0;\r\nerr = snd_pcm_new(chip->card, vortex_pcm_prettyname[idx], idx, nr,\r\nnr_capt, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnprintf(pcm->name, sizeof(pcm->name),\r\n"%s %s", CARD_NAME_SHORT, vortex_pcm_name[idx]);\r\nchip->pcm[idx] = pcm;\r\nVORTEX_PCM_TYPE(pcm) = idx;\r\npcm->private_data = chip;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_vortex_playback_ops);\r\nif (idx == VORTEX_PCM_ADB)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_vortex_playback_ops);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\r\nsnd_dma_pci_data(chip->pci_dev),\r\n0x10000, 0x10000);\r\nswitch (VORTEX_PCM_TYPE(pcm)) {\r\ncase VORTEX_PCM_ADB:\r\nerr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\nsnd_pcm_std_chmaps,\r\nVORTEX_IS_QUAD(chip) ? 4 : 2,\r\n0, NULL);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\nsnd_pcm_std_chmaps, 2, 0, NULL);\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\n#ifdef CHIP_AU8830\r\ncase VORTEX_PCM_A3D:\r\nerr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\nsnd_pcm_std_chmaps, 1, 0, NULL);\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\n#endif\r\n};\r\nif (VORTEX_PCM_TYPE(pcm) == VORTEX_PCM_SPDIF) {\r\nfor (i = 0; i < ARRAY_SIZE(snd_vortex_mixer_spdif); i++) {\r\nkctl = snd_ctl_new1(&snd_vortex_mixer_spdif[i], chip);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nif ((err = snd_ctl_add(chip->card, kctl)) < 0)\r\nreturn err;\r\n}\r\n}\r\nif (VORTEX_PCM_TYPE(pcm) == VORTEX_PCM_ADB) {\r\nfor (i = 0; i < NR_PCM; i++) {\r\nchip->pcm_vol[i].active = 0;\r\nchip->pcm_vol[i].dma = -1;\r\nkctl = snd_ctl_new1(&snd_vortex_pcm_vol, chip);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nchip->pcm_vol[i].kctl = kctl;\r\nkctl->id.device = 0;\r\nkctl->id.subdevice = i;\r\nerr = snd_ctl_add(chip->card, kctl);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}
