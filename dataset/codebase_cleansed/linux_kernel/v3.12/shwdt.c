static int sh_wdt_start(struct watchdog_device *wdt_dev)\r\n{\r\nstruct sh_wdt *wdt = watchdog_get_drvdata(wdt_dev);\r\nunsigned long flags;\r\nu8 csr;\r\npm_runtime_get_sync(wdt->dev);\r\nclk_enable(wdt->clk);\r\nspin_lock_irqsave(&wdt->lock, flags);\r\nnext_heartbeat = jiffies + (heartbeat * HZ);\r\nmod_timer(&wdt->timer, next_ping_period(clock_division_ratio));\r\ncsr = sh_wdt_read_csr();\r\ncsr |= WTCSR_WT | clock_division_ratio;\r\nsh_wdt_write_csr(csr);\r\nsh_wdt_write_cnt(0);\r\ncsr = sh_wdt_read_csr();\r\ncsr |= WTCSR_TME;\r\ncsr &= ~WTCSR_RSTS;\r\nsh_wdt_write_csr(csr);\r\n#ifdef CONFIG_CPU_SH2\r\ncsr = sh_wdt_read_rstcsr();\r\ncsr &= ~RSTCSR_RSTS;\r\nsh_wdt_write_rstcsr(csr);\r\n#endif\r\nspin_unlock_irqrestore(&wdt->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sh_wdt_stop(struct watchdog_device *wdt_dev)\r\n{\r\nstruct sh_wdt *wdt = watchdog_get_drvdata(wdt_dev);\r\nunsigned long flags;\r\nu8 csr;\r\nspin_lock_irqsave(&wdt->lock, flags);\r\ndel_timer(&wdt->timer);\r\ncsr = sh_wdt_read_csr();\r\ncsr &= ~WTCSR_TME;\r\nsh_wdt_write_csr(csr);\r\nspin_unlock_irqrestore(&wdt->lock, flags);\r\nclk_disable(wdt->clk);\r\npm_runtime_put_sync(wdt->dev);\r\nreturn 0;\r\n}\r\nstatic int sh_wdt_keepalive(struct watchdog_device *wdt_dev)\r\n{\r\nstruct sh_wdt *wdt = watchdog_get_drvdata(wdt_dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdt->lock, flags);\r\nnext_heartbeat = jiffies + (heartbeat * HZ);\r\nspin_unlock_irqrestore(&wdt->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sh_wdt_set_heartbeat(struct watchdog_device *wdt_dev, unsigned t)\r\n{\r\nstruct sh_wdt *wdt = watchdog_get_drvdata(wdt_dev);\r\nunsigned long flags;\r\nif (unlikely(t < 1 || t > 3600))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&wdt->lock, flags);\r\nheartbeat = t;\r\nwdt_dev->timeout = t;\r\nspin_unlock_irqrestore(&wdt->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void sh_wdt_ping(unsigned long data)\r\n{\r\nstruct sh_wdt *wdt = (struct sh_wdt *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdt->lock, flags);\r\nif (time_before(jiffies, next_heartbeat)) {\r\nu8 csr;\r\ncsr = sh_wdt_read_csr();\r\ncsr &= ~WTCSR_IOVF;\r\nsh_wdt_write_csr(csr);\r\nsh_wdt_write_cnt(0);\r\nmod_timer(&wdt->timer, next_ping_period(clock_division_ratio));\r\n} else\r\ndev_warn(wdt->dev, "Heartbeat lost! Will not ping "\r\n"the watchdog\n");\r\nspin_unlock_irqrestore(&wdt->lock, flags);\r\n}\r\nstatic int sh_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_wdt *wdt;\r\nstruct resource *res;\r\nint rc;\r\nif (pdev->id != -1)\r\nreturn -EINVAL;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(!res))\r\nreturn -EINVAL;\r\nwdt = devm_kzalloc(&pdev->dev, sizeof(struct sh_wdt), GFP_KERNEL);\r\nif (unlikely(!wdt))\r\nreturn -ENOMEM;\r\nwdt->dev = &pdev->dev;\r\nwdt->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(wdt->clk)) {\r\nwdt->clk = NULL;\r\n}\r\nwdt->base = devm_ioremap_resource(wdt->dev, res);\r\nif (IS_ERR(wdt->base))\r\nreturn PTR_ERR(wdt->base);\r\nwatchdog_set_nowayout(&sh_wdt_dev, nowayout);\r\nwatchdog_set_drvdata(&sh_wdt_dev, wdt);\r\nspin_lock_init(&wdt->lock);\r\nrc = sh_wdt_set_heartbeat(&sh_wdt_dev, heartbeat);\r\nif (unlikely(rc)) {\r\nsh_wdt_set_heartbeat(&sh_wdt_dev, WATCHDOG_HEARTBEAT);\r\ndev_warn(&pdev->dev,\r\n"heartbeat value must be 1<=x<=3600, using %d\n",\r\nsh_wdt_dev.timeout);\r\n}\r\ndev_info(&pdev->dev, "configured with heartbeat=%d sec (nowayout=%d)\n",\r\nsh_wdt_dev.timeout, nowayout);\r\nrc = watchdog_register_device(&sh_wdt_dev);\r\nif (unlikely(rc)) {\r\ndev_err(&pdev->dev, "Can't register watchdog (err=%d)\n", rc);\r\nreturn rc;\r\n}\r\ninit_timer(&wdt->timer);\r\nwdt->timer.function = sh_wdt_ping;\r\nwdt->timer.data = (unsigned long)wdt;\r\nwdt->timer.expires = next_ping_period(clock_division_ratio);\r\nplatform_set_drvdata(pdev, wdt);\r\ndev_info(&pdev->dev, "initialized.\n");\r\npm_runtime_enable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int sh_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct sh_wdt *wdt = platform_get_drvdata(pdev);\r\nwatchdog_unregister_device(&sh_wdt_dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic void sh_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nsh_wdt_stop(&sh_wdt_dev);\r\n}\r\nstatic int __init sh_wdt_init(void)\r\n{\r\nif (unlikely(clock_division_ratio < 0x5 ||\r\nclock_division_ratio > 0x7)) {\r\nclock_division_ratio = WTCSR_CKS_4096;\r\npr_info("divisor must be 0x5<=x<=0x7, using %d\n",\r\nclock_division_ratio);\r\n}\r\nreturn platform_driver_register(&sh_wdt_driver);\r\n}\r\nstatic void __exit sh_wdt_exit(void)\r\n{\r\nplatform_driver_unregister(&sh_wdt_driver);\r\n}
