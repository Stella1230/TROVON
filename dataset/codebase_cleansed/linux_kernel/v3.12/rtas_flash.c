static int flash_list_valid(struct flash_block_list *flist)\r\n{\r\nstruct flash_block_list *f;\r\nint i;\r\nunsigned long block_size, image_size;\r\nimage_size = 0;\r\nfor (f = flist; f; f = f->next) {\r\nfor (i = 0; i < f->num_blocks; i++) {\r\nif (f->blocks[i].data == NULL) {\r\nreturn FLASH_IMG_NULL_DATA;\r\n}\r\nblock_size = f->blocks[i].length;\r\nif (block_size <= 0 || block_size > RTAS_BLK_SIZE) {\r\nreturn FLASH_IMG_BAD_LEN;\r\n}\r\nimage_size += block_size;\r\n}\r\n}\r\nif (image_size < (256 << 10)) {\r\nif (image_size < 2)\r\nreturn FLASH_NO_OP;\r\n}\r\nprintk(KERN_INFO "FLASH: flash image with %ld bytes stored for hardware flash on reboot\n", image_size);\r\nreturn FLASH_IMG_READY;\r\n}\r\nstatic void free_flash_list(struct flash_block_list *f)\r\n{\r\nstruct flash_block_list *next;\r\nint i;\r\nwhile (f) {\r\nfor (i = 0; i < f->num_blocks; i++)\r\nkmem_cache_free(flash_block_cache, f->blocks[i].data);\r\nnext = f->next;\r\nkmem_cache_free(flash_block_cache, f);\r\nf = next;\r\n}\r\n}\r\nstatic int rtas_flash_release(struct inode *inode, struct file *file)\r\n{\r\nstruct rtas_update_flash_t *const uf = &rtas_update_flash_data;\r\nmutex_lock(&rtas_update_flash_mutex);\r\nif (uf->flist) {\r\nif (rtas_firmware_flash_list) {\r\nfree_flash_list(rtas_firmware_flash_list);\r\nrtas_firmware_flash_list = NULL;\r\n}\r\nif (uf->status != FLASH_AUTH)\r\nuf->status = flash_list_valid(uf->flist);\r\nif (uf->status == FLASH_IMG_READY)\r\nrtas_firmware_flash_list = uf->flist;\r\nelse\r\nfree_flash_list(uf->flist);\r\nuf->flist = NULL;\r\n}\r\nmutex_unlock(&rtas_update_flash_mutex);\r\nreturn 0;\r\n}\r\nstatic size_t get_flash_status_msg(int status, char *buf)\r\n{\r\nconst char *msg;\r\nsize_t len;\r\nswitch (status) {\r\ncase FLASH_AUTH:\r\nmsg = "error: this partition does not have service authority\n";\r\nbreak;\r\ncase FLASH_NO_OP:\r\nmsg = "info: no firmware image for flash\n";\r\nbreak;\r\ncase FLASH_IMG_SHORT:\r\nmsg = "error: flash image short\n";\r\nbreak;\r\ncase FLASH_IMG_BAD_LEN:\r\nmsg = "error: internal error bad length\n";\r\nbreak;\r\ncase FLASH_IMG_NULL_DATA:\r\nmsg = "error: internal error null data\n";\r\nbreak;\r\ncase FLASH_IMG_READY:\r\nmsg = "ready: firmware image ready for flash on reboot\n";\r\nbreak;\r\ndefault:\r\nreturn sprintf(buf, "error: unexpected status value %d\n",\r\nstatus);\r\n}\r\nlen = strlen(msg);\r\nmemcpy(buf, msg, len + 1);\r\nreturn len;\r\n}\r\nstatic ssize_t rtas_flash_read_msg(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct rtas_update_flash_t *const uf = &rtas_update_flash_data;\r\nchar msg[RTAS_MSG_MAXLEN];\r\nsize_t len;\r\nint status;\r\nmutex_lock(&rtas_update_flash_mutex);\r\nstatus = uf->status;\r\nmutex_unlock(&rtas_update_flash_mutex);\r\nlen = get_flash_status_msg(status, msg);\r\nreturn simple_read_from_buffer(buf, count, ppos, msg, len);\r\n}\r\nstatic ssize_t rtas_flash_read_num(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct rtas_update_flash_t *const uf = &rtas_update_flash_data;\r\nchar msg[RTAS_MSG_MAXLEN];\r\nint status;\r\nmutex_lock(&rtas_update_flash_mutex);\r\nstatus = uf->status;\r\nmutex_unlock(&rtas_update_flash_mutex);\r\nsprintf(msg, "%d\n", status);\r\nreturn simple_read_from_buffer(buf, count, ppos, msg, strlen(msg));\r\n}\r\nstatic ssize_t rtas_flash_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct rtas_update_flash_t *const uf = &rtas_update_flash_data;\r\nchar *p;\r\nint next_free, rc;\r\nstruct flash_block_list *fl;\r\nmutex_lock(&rtas_update_flash_mutex);\r\nif (uf->status == FLASH_AUTH || count == 0)\r\ngoto out;\r\nif (uf->flist == NULL) {\r\nuf->flist = kmem_cache_zalloc(flash_block_cache, GFP_KERNEL);\r\nif (!uf->flist)\r\ngoto nomem;\r\n}\r\nfl = uf->flist;\r\nwhile (fl->next)\r\nfl = fl->next;\r\nnext_free = fl->num_blocks;\r\nif (next_free == FLASH_BLOCKS_PER_NODE) {\r\nfl->next = kmem_cache_zalloc(flash_block_cache, GFP_KERNEL);\r\nif (!fl->next)\r\ngoto nomem;\r\nfl = fl->next;\r\nnext_free = 0;\r\n}\r\nif (count > RTAS_BLK_SIZE)\r\ncount = RTAS_BLK_SIZE;\r\np = kmem_cache_zalloc(flash_block_cache, GFP_KERNEL);\r\nif (!p)\r\ngoto nomem;\r\nif(copy_from_user(p, buffer, count)) {\r\nkmem_cache_free(flash_block_cache, p);\r\nrc = -EFAULT;\r\ngoto error;\r\n}\r\nfl->blocks[next_free].data = p;\r\nfl->blocks[next_free].length = count;\r\nfl->num_blocks++;\r\nout:\r\nmutex_unlock(&rtas_update_flash_mutex);\r\nreturn count;\r\nnomem:\r\nrc = -ENOMEM;\r\nerror:\r\nmutex_unlock(&rtas_update_flash_mutex);\r\nreturn rc;\r\n}\r\nstatic void manage_flash(struct rtas_manage_flash_t *args_buf, unsigned int op)\r\n{\r\ns32 rc;\r\ndo {\r\nrc = rtas_call(rtas_token("ibm,manage-flash-image"), 1, 1,\r\nNULL, op);\r\n} while (rtas_busy_delay(rc));\r\nargs_buf->status = rc;\r\n}\r\nstatic ssize_t manage_flash_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct rtas_manage_flash_t *const args_buf = &rtas_manage_flash_data;\r\nchar msg[RTAS_MSG_MAXLEN];\r\nint msglen, status;\r\nmutex_lock(&rtas_manage_flash_mutex);\r\nstatus = args_buf->status;\r\nmutex_unlock(&rtas_manage_flash_mutex);\r\nmsglen = sprintf(msg, "%d\n", status);\r\nreturn simple_read_from_buffer(buf, count, ppos, msg, msglen);\r\n}\r\nstatic ssize_t manage_flash_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct rtas_manage_flash_t *const args_buf = &rtas_manage_flash_data;\r\nstatic const char reject_str[] = "0";\r\nstatic const char commit_str[] = "1";\r\nchar stkbuf[10];\r\nint op, rc;\r\nmutex_lock(&rtas_manage_flash_mutex);\r\nif ((args_buf->status == MANAGE_AUTH) || (count == 0))\r\ngoto out;\r\nop = -1;\r\nif (buf) {\r\nif (count > 9) count = 9;\r\nrc = -EFAULT;\r\nif (copy_from_user (stkbuf, buf, count))\r\ngoto error;\r\nif (strncmp(stkbuf, reject_str, strlen(reject_str)) == 0)\r\nop = RTAS_REJECT_TMP_IMG;\r\nelse if (strncmp(stkbuf, commit_str, strlen(commit_str)) == 0)\r\nop = RTAS_COMMIT_TMP_IMG;\r\n}\r\nif (op == -1) {\r\nrc = -EINVAL;\r\ngoto error;\r\n}\r\nmanage_flash(args_buf, op);\r\nout:\r\nmutex_unlock(&rtas_manage_flash_mutex);\r\nreturn count;\r\nerror:\r\nmutex_unlock(&rtas_manage_flash_mutex);\r\nreturn rc;\r\n}\r\nstatic void validate_flash(struct rtas_validate_flash_t *args_buf)\r\n{\r\nint token = rtas_token("ibm,validate-flash-image");\r\nint update_results;\r\ns32 rc;\r\nrc = 0;\r\ndo {\r\nspin_lock(&rtas_data_buf_lock);\r\nmemcpy(rtas_data_buf, args_buf->buf, VALIDATE_BUF_SIZE);\r\nrc = rtas_call(token, 2, 2, &update_results,\r\n(u32) __pa(rtas_data_buf), args_buf->buf_size);\r\nmemcpy(args_buf->buf, rtas_data_buf, VALIDATE_BUF_SIZE);\r\nspin_unlock(&rtas_data_buf_lock);\r\n} while (rtas_busy_delay(rc));\r\nargs_buf->status = rc;\r\nargs_buf->update_results = update_results;\r\n}\r\nstatic int get_validate_flash_msg(struct rtas_validate_flash_t *args_buf,\r\nchar *msg, int msglen)\r\n{\r\nint n;\r\nif (args_buf->status >= VALIDATE_TMP_UPDATE) {\r\nn = sprintf(msg, "%d\n", args_buf->update_results);\r\nif ((args_buf->update_results >= VALIDATE_CUR_UNKNOWN) ||\r\n(args_buf->update_results == VALIDATE_TMP_UPDATE))\r\nn += snprintf(msg + n, msglen - n, "%s\n",\r\nargs_buf->buf);\r\n} else {\r\nn = sprintf(msg, "%d\n", args_buf->status);\r\n}\r\nreturn n;\r\n}\r\nstatic ssize_t validate_flash_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct rtas_validate_flash_t *const args_buf =\r\n&rtas_validate_flash_data;\r\nchar msg[VALIDATE_MSG_LEN];\r\nint msglen;\r\nmutex_lock(&rtas_validate_flash_mutex);\r\nmsglen = get_validate_flash_msg(args_buf, msg, VALIDATE_MSG_LEN);\r\nmutex_unlock(&rtas_validate_flash_mutex);\r\nreturn simple_read_from_buffer(buf, count, ppos, msg, msglen);\r\n}\r\nstatic ssize_t validate_flash_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct rtas_validate_flash_t *const args_buf =\r\n&rtas_validate_flash_data;\r\nint rc;\r\nmutex_lock(&rtas_validate_flash_mutex);\r\nif ((*off >= VALIDATE_BUF_SIZE) ||\r\n(args_buf->status == VALIDATE_AUTH)) {\r\n*off += count;\r\nmutex_unlock(&rtas_validate_flash_mutex);\r\nreturn count;\r\n}\r\nif (*off + count >= VALIDATE_BUF_SIZE) {\r\ncount = VALIDATE_BUF_SIZE - *off;\r\nargs_buf->status = VALIDATE_READY;\r\n} else {\r\nargs_buf->status = VALIDATE_INCOMPLETE;\r\n}\r\nif (!access_ok(VERIFY_READ, buf, count)) {\r\nrc = -EFAULT;\r\ngoto done;\r\n}\r\nif (copy_from_user(args_buf->buf + *off, buf, count)) {\r\nrc = -EFAULT;\r\ngoto done;\r\n}\r\n*off += count;\r\nrc = count;\r\ndone:\r\nmutex_unlock(&rtas_validate_flash_mutex);\r\nreturn rc;\r\n}\r\nstatic int validate_flash_release(struct inode *inode, struct file *file)\r\n{\r\nstruct rtas_validate_flash_t *const args_buf =\r\n&rtas_validate_flash_data;\r\nmutex_lock(&rtas_validate_flash_mutex);\r\nif (args_buf->status == VALIDATE_READY) {\r\nargs_buf->buf_size = VALIDATE_BUF_SIZE;\r\nvalidate_flash(args_buf);\r\n}\r\nmutex_unlock(&rtas_validate_flash_mutex);\r\nreturn 0;\r\n}\r\nstatic void rtas_flash_firmware(int reboot_type)\r\n{\r\nunsigned long image_size;\r\nstruct flash_block_list *f, *next, *flist;\r\nunsigned long rtas_block_list;\r\nint i, status, update_token;\r\nif (rtas_firmware_flash_list == NULL)\r\nreturn;\r\nif (reboot_type != SYS_RESTART) {\r\nprintk(KERN_ALERT "FLASH: firmware flash requires a reboot\n");\r\nprintk(KERN_ALERT "FLASH: the firmware image will NOT be flashed\n");\r\nreturn;\r\n}\r\nupdate_token = rtas_token("ibm,update-flash-64-and-reboot");\r\nif (update_token == RTAS_UNKNOWN_SERVICE) {\r\nprintk(KERN_ALERT "FLASH: ibm,update-flash-64-and-reboot "\r\n"is not available -- not a service partition?\n");\r\nprintk(KERN_ALERT "FLASH: firmware will not be flashed\n");\r\nreturn;\r\n}\r\nrtas_cancel_event_scan();\r\nspin_lock(&rtas_data_buf_lock);\r\nflist = (struct flash_block_list *)&rtas_data_buf[0];\r\nflist->num_blocks = 0;\r\nflist->next = rtas_firmware_flash_list;\r\nrtas_block_list = __pa(flist);\r\nif (rtas_block_list >= 4UL*1024*1024*1024) {\r\nprintk(KERN_ALERT "FLASH: kernel bug...flash list header addr above 4GB\n");\r\nspin_unlock(&rtas_data_buf_lock);\r\nreturn;\r\n}\r\nprintk(KERN_ALERT "FLASH: preparing saved firmware image for flash\n");\r\nrtas_firmware_flash_list = NULL;\r\nimage_size = 0;\r\nfor (f = flist; f; f = next) {\r\nfor (i = 0; i < f->num_blocks; i++) {\r\nf->blocks[i].data = (char *)__pa(f->blocks[i].data);\r\nimage_size += f->blocks[i].length;\r\n}\r\nnext = f->next;\r\nif (f->next)\r\nf->next = (struct flash_block_list *)__pa(f->next);\r\nelse\r\nf->next = NULL;\r\nf->num_blocks = (FLASH_BLOCK_LIST_VERSION << 56) | ((f->num_blocks+1)*16);\r\n}\r\nprintk(KERN_ALERT "FLASH: flash image is %ld bytes\n", image_size);\r\nprintk(KERN_ALERT "FLASH: performing flash and reboot\n");\r\nrtas_progress("Flashing \n", 0x0);\r\nrtas_progress("Please Wait... ", 0x0);\r\nprintk(KERN_ALERT "FLASH: this will take several minutes. Do not power off!\n");\r\nstatus = rtas_call(update_token, 1, 1, NULL, rtas_block_list);\r\nswitch (status) {\r\ncase 0:\r\nprintk(KERN_ALERT "FLASH: success\n");\r\nbreak;\r\ncase -1:\r\nprintk(KERN_ALERT "FLASH: hardware error. Firmware may not be not flashed\n");\r\nbreak;\r\ncase -3:\r\nprintk(KERN_ALERT "FLASH: image is corrupt or not correct for this platform. Firmware not flashed\n");\r\nbreak;\r\ncase -4:\r\nprintk(KERN_ALERT "FLASH: flash failed when partially complete. System may not reboot\n");\r\nbreak;\r\ndefault:\r\nprintk(KERN_ALERT "FLASH: unknown flash return code %d\n", status);\r\nbreak;\r\n}\r\nspin_unlock(&rtas_data_buf_lock);\r\n}\r\nstatic int __init rtas_flash_init(void)\r\n{\r\nint i;\r\nif (rtas_token("ibm,update-flash-64-and-reboot") ==\r\nRTAS_UNKNOWN_SERVICE) {\r\npr_info("rtas_flash: no firmware flash support\n");\r\nreturn 1;\r\n}\r\nrtas_validate_flash_data.buf = kzalloc(VALIDATE_BUF_SIZE, GFP_KERNEL);\r\nif (!rtas_validate_flash_data.buf)\r\nreturn -ENOMEM;\r\nflash_block_cache = kmem_cache_create("rtas_flash_cache",\r\nRTAS_BLK_SIZE, RTAS_BLK_SIZE, 0,\r\nNULL);\r\nif (!flash_block_cache) {\r\nprintk(KERN_ERR "%s: failed to create block cache\n",\r\n__func__);\r\ngoto enomem_buf;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(rtas_flash_files); i++) {\r\nconst struct rtas_flash_file *f = &rtas_flash_files[i];\r\nint token;\r\nif (!proc_create(f->filename, S_IRUSR | S_IWUSR, NULL, &f->fops))\r\ngoto enomem;\r\ntoken = rtas_token(f->rtas_call_name);\r\nif (token == RTAS_UNKNOWN_SERVICE)\r\n*f->status = FLASH_AUTH;\r\nelse\r\n*f->status = FLASH_NO_OP;\r\n}\r\nrtas_flash_term_hook = rtas_flash_firmware;\r\nreturn 0;\r\nenomem:\r\nwhile (--i >= 0) {\r\nconst struct rtas_flash_file *f = &rtas_flash_files[i];\r\nremove_proc_entry(f->filename, NULL);\r\n}\r\nkmem_cache_destroy(flash_block_cache);\r\nenomem_buf:\r\nkfree(rtas_validate_flash_data.buf);\r\nreturn -ENOMEM;\r\n}\r\nstatic void __exit rtas_flash_cleanup(void)\r\n{\r\nint i;\r\nrtas_flash_term_hook = NULL;\r\nif (rtas_firmware_flash_list) {\r\nfree_flash_list(rtas_firmware_flash_list);\r\nrtas_firmware_flash_list = NULL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(rtas_flash_files); i++) {\r\nconst struct rtas_flash_file *f = &rtas_flash_files[i];\r\nremove_proc_entry(f->filename, NULL);\r\n}\r\nkmem_cache_destroy(flash_block_cache);\r\nkfree(rtas_validate_flash_data.buf);\r\n}
