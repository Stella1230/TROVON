static int mdc800_endpoint_equals (struct usb_endpoint_descriptor *a,struct usb_endpoint_descriptor *b)\r\n{\r\nreturn (\r\n( a->bEndpointAddress == b->bEndpointAddress )\r\n&& ( a->bmAttributes == b->bmAttributes )\r\n&& ( a->wMaxPacketSize == b->wMaxPacketSize )\r\n);\r\n}\r\nstatic int mdc800_isBusy (char* ch)\r\n{\r\nint i=0;\r\nwhile (i<8)\r\n{\r\nif (ch [i] != (char)0x99)\r\nreturn 0;\r\ni++;\r\n}\r\nreturn 1;\r\n}\r\nstatic int mdc800_isReady (char *ch)\r\n{\r\nint i=0;\r\nwhile (i<8)\r\n{\r\nif (ch [i] != (char)0xbb)\r\nreturn 0;\r\ni++;\r\n}\r\nreturn 1;\r\n}\r\nstatic void mdc800_usb_irq (struct urb *urb)\r\n{\r\nint data_received=0, wake_up;\r\nunsigned char* b=urb->transfer_buffer;\r\nstruct mdc800_data* mdc800=urb->context;\r\nstruct device *dev = &mdc800->dev->dev;\r\nint status = urb->status;\r\nif (status >= 0) {\r\nif (mdc800_isBusy (b))\r\n{\r\nif (!mdc800->camera_busy)\r\n{\r\nmdc800->camera_busy=1;\r\ndev_dbg(dev, "gets busy\n");\r\n}\r\n}\r\nelse\r\n{\r\nif (mdc800->camera_busy && mdc800_isReady (b))\r\n{\r\nmdc800->camera_busy=0;\r\ndev_dbg(dev, "gets ready\n");\r\n}\r\n}\r\nif (!(mdc800_isBusy (b) || mdc800_isReady (b)))\r\n{\r\ndev_dbg(dev, "%i %i %i %i %i %i %i %i \n",b[0],b[1],b[2],b[3],b[4],b[5],b[6],b[7]);\r\nmemcpy (mdc800->camera_response,b,8);\r\ndata_received=1;\r\n}\r\n}\r\nwake_up= ( mdc800->camera_request_ready > 0 )\r\n&&\r\n(\r\n((mdc800->camera_request_ready == 1) && (!mdc800->camera_busy))\r\n||\r\n((mdc800->camera_request_ready == 2) && data_received)\r\n||\r\n((mdc800->camera_request_ready == 3) && (mdc800->camera_busy))\r\n||\r\n(status < 0)\r\n);\r\nif (wake_up)\r\n{\r\nmdc800->camera_request_ready=0;\r\nmdc800->irq_woken=1;\r\nwake_up (&mdc800->irq_wait);\r\n}\r\n}\r\nstatic int mdc800_usb_waitForIRQ (int mode, int msec)\r\n{\r\nmdc800->camera_request_ready=1+mode;\r\nwait_event_timeout(mdc800->irq_wait, mdc800->irq_woken, msec*HZ/1000);\r\nmdc800->irq_woken = 0;\r\nif (mdc800->camera_request_ready>0)\r\n{\r\nmdc800->camera_request_ready=0;\r\ndev_err(&mdc800->dev->dev, "timeout waiting for camera.\n");\r\nreturn -1;\r\n}\r\nif (mdc800->state == NOT_CONNECTED)\r\n{\r\nprintk(KERN_WARNING "mdc800: Camera gets disconnected "\r\n"during waiting for irq.\n");\r\nmdc800->camera_request_ready=0;\r\nreturn -2;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mdc800_usb_write_notify (struct urb *urb)\r\n{\r\nstruct mdc800_data* mdc800=urb->context;\r\nint status = urb->status;\r\nif (status != 0)\r\ndev_err(&mdc800->dev->dev,\r\n"writing command fails (status=%i)\n", status);\r\nelse\r\nmdc800->state=READY;\r\nmdc800->written = 1;\r\nwake_up (&mdc800->write_wait);\r\n}\r\nstatic void mdc800_usb_download_notify (struct urb *urb)\r\n{\r\nstruct mdc800_data* mdc800=urb->context;\r\nint status = urb->status;\r\nif (status == 0) {\r\nmemcpy (mdc800->out, urb->transfer_buffer, 64);\r\nmdc800->out_count=64;\r\nmdc800->out_ptr=0;\r\nmdc800->download_left-=64;\r\nif (mdc800->download_left == 0)\r\n{\r\nmdc800->state=READY;\r\n}\r\n} else {\r\ndev_err(&mdc800->dev->dev,\r\n"request bytes fails (status:%i)\n", status);\r\n}\r\nmdc800->downloaded = 1;\r\nwake_up (&mdc800->download_wait);\r\n}\r\nstatic int mdc800_usb_probe (struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nint i,j;\r\nstruct usb_host_interface *intf_desc;\r\nstruct usb_device *dev = interface_to_usbdev (intf);\r\nint irq_interval=0;\r\nint retval;\r\ndev_dbg(&intf->dev, "(%s) called.\n", __func__);\r\nif (mdc800->dev != NULL)\r\n{\r\ndev_warn(&intf->dev, "only one Mustek MDC800 is supported.\n");\r\nreturn -ENODEV;\r\n}\r\nif (dev->descriptor.bNumConfigurations != 1)\r\n{\r\ndev_err(&intf->dev,\r\n"probe fails -> wrong Number of Configuration\n");\r\nreturn -ENODEV;\r\n}\r\nintf_desc = intf->cur_altsetting;\r\nif (\r\n( intf_desc->desc.bInterfaceClass != 0xff )\r\n|| ( intf_desc->desc.bInterfaceSubClass != 0 )\r\n|| ( intf_desc->desc.bInterfaceProtocol != 0 )\r\n|| ( intf_desc->desc.bNumEndpoints != 4)\r\n)\r\n{\r\ndev_err(&intf->dev, "probe fails -> wrong Interface\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i=0; i<4; i++)\r\n{\r\nmdc800->endpoint[i]=-1;\r\nfor (j=0; j<4; j++)\r\n{\r\nif (mdc800_endpoint_equals (&intf_desc->endpoint [j].desc,&mdc800_ed [i]))\r\n{\r\nmdc800->endpoint[i]=intf_desc->endpoint [j].desc.bEndpointAddress ;\r\nif (i==1)\r\n{\r\nirq_interval=intf_desc->endpoint [j].desc.bInterval;\r\n}\r\n}\r\n}\r\nif (mdc800->endpoint[i] == -1)\r\n{\r\ndev_err(&intf->dev, "probe fails -> Wrong Endpoints.\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\ndev_info(&intf->dev, "Found Mustek MDC800 on USB.\n");\r\nmutex_lock(&mdc800->io_lock);\r\nretval = usb_register_dev(intf, &mdc800_class);\r\nif (retval) {\r\ndev_err(&intf->dev, "Not able to get a minor for this device.\n");\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn -ENODEV;\r\n}\r\nmdc800->dev=dev;\r\nmdc800->open=0;\r\nusb_fill_int_urb (\r\nmdc800->irq_urb,\r\nmdc800->dev,\r\nusb_rcvintpipe (mdc800->dev,mdc800->endpoint [1]),\r\nmdc800->irq_urb_buffer,\r\n8,\r\nmdc800_usb_irq,\r\nmdc800,\r\nirq_interval\r\n);\r\nusb_fill_bulk_urb (\r\nmdc800->write_urb,\r\nmdc800->dev,\r\nusb_sndbulkpipe (mdc800->dev, mdc800->endpoint[0]),\r\nmdc800->write_urb_buffer,\r\n8,\r\nmdc800_usb_write_notify,\r\nmdc800\r\n);\r\nusb_fill_bulk_urb (\r\nmdc800->download_urb,\r\nmdc800->dev,\r\nusb_rcvbulkpipe (mdc800->dev, mdc800->endpoint [3]),\r\nmdc800->download_urb_buffer,\r\n64,\r\nmdc800_usb_download_notify,\r\nmdc800\r\n);\r\nmdc800->state=READY;\r\nmutex_unlock(&mdc800->io_lock);\r\nusb_set_intfdata(intf, mdc800);\r\nreturn 0;\r\n}\r\nstatic void mdc800_usb_disconnect (struct usb_interface *intf)\r\n{\r\nstruct mdc800_data* mdc800 = usb_get_intfdata(intf);\r\ndev_dbg(&intf->dev, "(%s) called\n", __func__);\r\nif (mdc800) {\r\nif (mdc800->state == NOT_CONNECTED)\r\nreturn;\r\nusb_deregister_dev(intf, &mdc800_class);\r\nmutex_lock(&mdc800->io_lock);\r\nmdc800->state=NOT_CONNECTED;\r\nusb_kill_urb(mdc800->irq_urb);\r\nusb_kill_urb(mdc800->write_urb);\r\nusb_kill_urb(mdc800->download_urb);\r\nmutex_unlock(&mdc800->io_lock);\r\nmdc800->dev = NULL;\r\nusb_set_intfdata(intf, NULL);\r\n}\r\ndev_info(&intf->dev, "Mustek MDC800 disconnected from USB.\n");\r\n}\r\nstatic int mdc800_getAnswerSize (char command)\r\n{\r\nswitch ((unsigned char) command)\r\n{\r\ncase 0x2a:\r\ncase 0x49:\r\ncase 0x51:\r\ncase 0x0d:\r\ncase 0x20:\r\ncase 0x07:\r\ncase 0x01:\r\ncase 0x25:\r\ncase 0x00:\r\nreturn 8;\r\ncase 0x05:\r\ncase 0x3e:\r\nreturn mdc800->pic_len;\r\ncase 0x09:\r\nreturn 4096;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int mdc800_device_open (struct inode* inode, struct file *file)\r\n{\r\nint retval=0;\r\nint errn=0;\r\nmutex_lock(&mdc800->io_lock);\r\nif (mdc800->state == NOT_CONNECTED)\r\n{\r\nerrn=-EBUSY;\r\ngoto error_out;\r\n}\r\nif (mdc800->open)\r\n{\r\nerrn=-EBUSY;\r\ngoto error_out;\r\n}\r\nmdc800->in_count=0;\r\nmdc800->out_count=0;\r\nmdc800->out_ptr=0;\r\nmdc800->pic_index=0;\r\nmdc800->pic_len=-1;\r\nmdc800->download_left=0;\r\nmdc800->camera_busy=0;\r\nmdc800->camera_request_ready=0;\r\nretval=0;\r\nmdc800->irq_urb->dev = mdc800->dev;\r\nretval = usb_submit_urb (mdc800->irq_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(&mdc800->dev->dev,\r\n"request USB irq fails (submit_retval=%i).\n", retval);\r\nerrn = -EIO;\r\ngoto error_out;\r\n}\r\nmdc800->open=1;\r\ndev_dbg(&mdc800->dev->dev, "Mustek MDC800 device opened.\n");\r\nerror_out:\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn errn;\r\n}\r\nstatic int mdc800_device_release (struct inode* inode, struct file *file)\r\n{\r\nint retval=0;\r\nmutex_lock(&mdc800->io_lock);\r\nif (mdc800->open && (mdc800->state != NOT_CONNECTED))\r\n{\r\nusb_kill_urb(mdc800->irq_urb);\r\nusb_kill_urb(mdc800->write_urb);\r\nusb_kill_urb(mdc800->download_urb);\r\nmdc800->open=0;\r\n}\r\nelse\r\n{\r\nretval=-EIO;\r\n}\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn retval;\r\n}\r\nstatic ssize_t mdc800_device_read (struct file *file, char __user *buf, size_t len, loff_t *pos)\r\n{\r\nsize_t left=len, sts=len;\r\nchar __user *ptr = buf;\r\nint retval;\r\nmutex_lock(&mdc800->io_lock);\r\nif (mdc800->state == NOT_CONNECTED)\r\n{\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn -EBUSY;\r\n}\r\nif (mdc800->state == WORKING)\r\n{\r\nprintk(KERN_WARNING "mdc800: Illegal State \"working\""\r\n"reached during read ?!\n");\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn -EBUSY;\r\n}\r\nif (!mdc800->open)\r\n{\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn -EBUSY;\r\n}\r\nwhile (left)\r\n{\r\nif (signal_pending (current))\r\n{\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn -EINTR;\r\n}\r\nsts=left > (mdc800->out_count-mdc800->out_ptr)?mdc800->out_count-mdc800->out_ptr:left;\r\nif (sts <= 0)\r\n{\r\nif (mdc800->state == DOWNLOAD)\r\n{\r\nmdc800->out_count=0;\r\nmdc800->out_ptr=0;\r\nmdc800->download_urb->dev = mdc800->dev;\r\nretval = usb_submit_urb (mdc800->download_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(&mdc800->dev->dev,\r\n"Can't submit download urb "\r\n"(retval=%i)\n", retval);\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn len-left;\r\n}\r\nwait_event_timeout(mdc800->download_wait, mdc800->downloaded,\r\nTO_DOWNLOAD_GET_READY*HZ/1000);\r\nmdc800->downloaded = 0;\r\nif (mdc800->download_urb->status != 0)\r\n{\r\ndev_err(&mdc800->dev->dev,\r\n"request download-bytes fails "\r\n"(status=%i)\n",\r\nmdc800->download_urb->status);\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn len-left;\r\n}\r\n}\r\nelse\r\n{\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn -EIO;\r\n}\r\n}\r\nelse\r\n{\r\nif (copy_to_user(ptr, &mdc800->out [mdc800->out_ptr],\r\nsts)) {\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn -EFAULT;\r\n}\r\nptr+=sts;\r\nleft-=sts;\r\nmdc800->out_ptr+=sts;\r\n}\r\n}\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn len-left;\r\n}\r\nstatic ssize_t mdc800_device_write (struct file *file, const char __user *buf, size_t len, loff_t *pos)\r\n{\r\nsize_t i=0;\r\nint retval;\r\nmutex_lock(&mdc800->io_lock);\r\nif (mdc800->state != READY)\r\n{\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn -EBUSY;\r\n}\r\nif (!mdc800->open )\r\n{\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn -EBUSY;\r\n}\r\nwhile (i<len)\r\n{\r\nunsigned char c;\r\nif (signal_pending (current))\r\n{\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn -EINTR;\r\n}\r\nif(get_user(c, buf+i))\r\n{\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn -EFAULT;\r\n}\r\nif (c == 0x55)\r\n{\r\nmdc800->in_count=0;\r\nmdc800->out_count=0;\r\nmdc800->out_ptr=0;\r\nmdc800->download_left=0;\r\n}\r\nif (mdc800->in_count < 8)\r\n{\r\nmdc800->in[mdc800->in_count] = c;\r\nmdc800->in_count++;\r\n}\r\nelse\r\n{\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn -EIO;\r\n}\r\nif (mdc800->in_count == 8)\r\n{\r\nint answersize;\r\nif (mdc800_usb_waitForIRQ (0,TO_GET_READY))\r\n{\r\ndev_err(&mdc800->dev->dev,\r\n"Camera didn't get ready.\n");\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn -EIO;\r\n}\r\nanswersize=mdc800_getAnswerSize (mdc800->in[1]);\r\nmdc800->state=WORKING;\r\nmemcpy (mdc800->write_urb->transfer_buffer, mdc800->in,8);\r\nmdc800->write_urb->dev = mdc800->dev;\r\nretval = usb_submit_urb (mdc800->write_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(&mdc800->dev->dev,\r\n"submitting write urb fails "\r\n"(retval=%i)\n", retval);\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn -EIO;\r\n}\r\nwait_event_timeout(mdc800->write_wait, mdc800->written, TO_WRITE_GET_READY*HZ/1000);\r\nmdc800->written = 0;\r\nif (mdc800->state == WORKING)\r\n{\r\nusb_kill_urb(mdc800->write_urb);\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn -EIO;\r\n}\r\nswitch ((unsigned char) mdc800->in[1])\r\n{\r\ncase 0x05:\r\ncase 0x3e:\r\nif (mdc800->pic_len < 0)\r\n{\r\ndev_err(&mdc800->dev->dev,\r\n"call 0x07 before "\r\n"0x05,0x3e\n");\r\nmdc800->state=READY;\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn -EIO;\r\n}\r\nmdc800->pic_len=-1;\r\ncase 0x09:\r\nmdc800->download_left=answersize+64;\r\nmdc800->state=DOWNLOAD;\r\nmdc800_usb_waitForIRQ (0,TO_DOWNLOAD_GET_BUSY);\r\nbreak;\r\ndefault:\r\nif (answersize)\r\n{\r\nif (mdc800_usb_waitForIRQ (1,TO_READ_FROM_IRQ))\r\n{\r\ndev_err(&mdc800->dev->dev, "requesting answer from irq fails\n");\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn -EIO;\r\n}\r\nmemcpy (mdc800->out, mdc800->camera_response,8);\r\nmemcpy (&mdc800->out[8], mdc800->camera_response,8);\r\nmdc800->out_ptr=0;\r\nmdc800->out_count=16;\r\nif (mdc800->in [1] == (char) 0x07)\r\n{\r\nmdc800->pic_len=(int) 65536*(unsigned char) mdc800->camera_response[0]+256*(unsigned char) mdc800->camera_response[1]+(unsigned char) mdc800->camera_response[2];\r\ndev_dbg(&mdc800->dev->dev, "cached imagesize = %i\n", mdc800->pic_len);\r\n}\r\n}\r\nelse\r\n{\r\nif (mdc800_usb_waitForIRQ (0,TO_DEFAULT_COMMAND))\r\n{\r\ndev_err(&mdc800->dev->dev, "Command Timeout.\n");\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn -EIO;\r\n}\r\n}\r\nmdc800->state=READY;\r\nbreak;\r\n}\r\n}\r\ni++;\r\n}\r\nmutex_unlock(&mdc800->io_lock);\r\nreturn i;\r\n}\r\nstatic int __init usb_mdc800_init (void)\r\n{\r\nint retval = -ENODEV;\r\nmdc800=kzalloc (sizeof (struct mdc800_data), GFP_KERNEL);\r\nif (!mdc800)\r\ngoto cleanup_on_fail;\r\nmdc800->dev = NULL;\r\nmdc800->state=NOT_CONNECTED;\r\nmutex_init (&mdc800->io_lock);\r\ninit_waitqueue_head (&mdc800->irq_wait);\r\ninit_waitqueue_head (&mdc800->write_wait);\r\ninit_waitqueue_head (&mdc800->download_wait);\r\nmdc800->irq_woken = 0;\r\nmdc800->downloaded = 0;\r\nmdc800->written = 0;\r\nmdc800->irq_urb_buffer=kmalloc (8, GFP_KERNEL);\r\nif (!mdc800->irq_urb_buffer)\r\ngoto cleanup_on_fail;\r\nmdc800->write_urb_buffer=kmalloc (8, GFP_KERNEL);\r\nif (!mdc800->write_urb_buffer)\r\ngoto cleanup_on_fail;\r\nmdc800->download_urb_buffer=kmalloc (64, GFP_KERNEL);\r\nif (!mdc800->download_urb_buffer)\r\ngoto cleanup_on_fail;\r\nmdc800->irq_urb=usb_alloc_urb (0, GFP_KERNEL);\r\nif (!mdc800->irq_urb)\r\ngoto cleanup_on_fail;\r\nmdc800->download_urb=usb_alloc_urb (0, GFP_KERNEL);\r\nif (!mdc800->download_urb)\r\ngoto cleanup_on_fail;\r\nmdc800->write_urb=usb_alloc_urb (0, GFP_KERNEL);\r\nif (!mdc800->write_urb)\r\ngoto cleanup_on_fail;\r\nretval = usb_register(&mdc800_usb_driver);\r\nif (retval)\r\ngoto cleanup_on_fail;\r\nprintk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"\r\nDRIVER_DESC "\n");\r\nreturn 0;\r\ncleanup_on_fail:\r\nif (mdc800 != NULL)\r\n{\r\nprintk(KERN_ERR "mdc800: can't alloc memory!\n");\r\nkfree(mdc800->download_urb_buffer);\r\nkfree(mdc800->write_urb_buffer);\r\nkfree(mdc800->irq_urb_buffer);\r\nusb_free_urb(mdc800->write_urb);\r\nusb_free_urb(mdc800->download_urb);\r\nusb_free_urb(mdc800->irq_urb);\r\nkfree (mdc800);\r\n}\r\nmdc800 = NULL;\r\nreturn retval;\r\n}\r\nstatic void __exit usb_mdc800_cleanup (void)\r\n{\r\nusb_deregister (&mdc800_usb_driver);\r\nusb_free_urb (mdc800->irq_urb);\r\nusb_free_urb (mdc800->download_urb);\r\nusb_free_urb (mdc800->write_urb);\r\nkfree (mdc800->irq_urb_buffer);\r\nkfree (mdc800->write_urb_buffer);\r\nkfree (mdc800->download_urb_buffer);\r\nkfree (mdc800);\r\nmdc800 = NULL;\r\n}
