static int determine_best_pix_fmt(struct fb_var_screeninfo *var)\r\n{\r\nif (var->bits_per_pixel == 8)\r\nreturn PIX_FMT_PSEUDOCOLOR;\r\nif (var->bits_per_pixel == 16 && var->red.length <= 5 &&\r\nvar->green.length <= 6 && var->blue.length <= 5) {\r\nif (var->transp.length == 0) {\r\nif (var->red.offset >= var->blue.offset)\r\nreturn PIX_FMT_RGB565;\r\nelse\r\nreturn PIX_FMT_BGR565;\r\n}\r\nif (var->transp.length == 1 && var->green.length <= 5) {\r\nif (var->red.offset >= var->blue.offset)\r\nreturn PIX_FMT_RGB1555;\r\nelse\r\nreturn PIX_FMT_BGR1555;\r\n}\r\n}\r\nif (var->bits_per_pixel <= 32 && var->red.length <= 8 &&\r\nvar->green.length <= 8 && var->blue.length <= 8) {\r\nif (var->bits_per_pixel == 24 && var->transp.length == 0) {\r\nif (var->red.offset >= var->blue.offset)\r\nreturn PIX_FMT_RGB888PACK;\r\nelse\r\nreturn PIX_FMT_BGR888PACK;\r\n}\r\nif (var->bits_per_pixel == 32 && var->transp.length == 8) {\r\nif (var->red.offset >= var->blue.offset)\r\nreturn PIX_FMT_RGBA888;\r\nelse\r\nreturn PIX_FMT_BGRA888;\r\n} else {\r\nif (var->red.offset >= var->blue.offset)\r\nreturn PIX_FMT_RGB888UNPACK;\r\nelse\r\nreturn PIX_FMT_BGR888UNPACK;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void set_pix_fmt(struct fb_var_screeninfo *var, int pix_fmt)\r\n{\r\nswitch (pix_fmt) {\r\ncase PIX_FMT_RGB565:\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 11; var->red.length = 5;\r\nvar->green.offset = 5; var->green.length = 6;\r\nvar->blue.offset = 0; var->blue.length = 5;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\ncase PIX_FMT_BGR565:\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 0; var->red.length = 5;\r\nvar->green.offset = 5; var->green.length = 6;\r\nvar->blue.offset = 11; var->blue.length = 5;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\ncase PIX_FMT_RGB1555:\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 10; var->red.length = 5;\r\nvar->green.offset = 5; var->green.length = 5;\r\nvar->blue.offset = 0; var->blue.length = 5;\r\nvar->transp.offset = 15; var->transp.length = 1;\r\nbreak;\r\ncase PIX_FMT_BGR1555:\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 0; var->red.length = 5;\r\nvar->green.offset = 5; var->green.length = 5;\r\nvar->blue.offset = 10; var->blue.length = 5;\r\nvar->transp.offset = 15; var->transp.length = 1;\r\nbreak;\r\ncase PIX_FMT_RGB888PACK:\r\nvar->bits_per_pixel = 24;\r\nvar->red.offset = 16; var->red.length = 8;\r\nvar->green.offset = 8; var->green.length = 8;\r\nvar->blue.offset = 0; var->blue.length = 8;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\ncase PIX_FMT_BGR888PACK:\r\nvar->bits_per_pixel = 24;\r\nvar->red.offset = 0; var->red.length = 8;\r\nvar->green.offset = 8; var->green.length = 8;\r\nvar->blue.offset = 16; var->blue.length = 8;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\ncase PIX_FMT_RGBA888:\r\nvar->bits_per_pixel = 32;\r\nvar->red.offset = 16; var->red.length = 8;\r\nvar->green.offset = 8; var->green.length = 8;\r\nvar->blue.offset = 0; var->blue.length = 8;\r\nvar->transp.offset = 24; var->transp.length = 8;\r\nbreak;\r\ncase PIX_FMT_BGRA888:\r\nvar->bits_per_pixel = 32;\r\nvar->red.offset = 0; var->red.length = 8;\r\nvar->green.offset = 8; var->green.length = 8;\r\nvar->blue.offset = 16; var->blue.length = 8;\r\nvar->transp.offset = 24; var->transp.length = 8;\r\nbreak;\r\ncase PIX_FMT_PSEUDOCOLOR:\r\nvar->bits_per_pixel = 8;\r\nvar->red.offset = 0; var->red.length = 8;\r\nvar->green.offset = 0; var->green.length = 8;\r\nvar->blue.offset = 0; var->blue.length = 8;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\n}\r\n}\r\nstatic void set_mode(struct pxa168fb_info *fbi, struct fb_var_screeninfo *var,\r\nstruct fb_videomode *mode, int pix_fmt, int ystretch)\r\n{\r\nstruct fb_info *info = fbi->info;\r\nset_pix_fmt(var, pix_fmt);\r\nvar->xres = mode->xres;\r\nvar->yres = mode->yres;\r\nvar->xres_virtual = max(var->xres, var->xres_virtual);\r\nif (ystretch)\r\nvar->yres_virtual = info->fix.smem_len /\r\n(var->xres_virtual * (var->bits_per_pixel >> 3));\r\nelse\r\nvar->yres_virtual = max(var->yres, var->yres_virtual);\r\nvar->grayscale = 0;\r\nvar->accel_flags = FB_ACCEL_NONE;\r\nvar->pixclock = mode->pixclock;\r\nvar->left_margin = mode->left_margin;\r\nvar->right_margin = mode->right_margin;\r\nvar->upper_margin = mode->upper_margin;\r\nvar->lower_margin = mode->lower_margin;\r\nvar->hsync_len = mode->hsync_len;\r\nvar->vsync_len = mode->vsync_len;\r\nvar->sync = mode->sync;\r\nvar->vmode = FB_VMODE_NONINTERLACED;\r\nvar->rotate = FB_ROTATE_UR;\r\n}\r\nstatic int pxa168fb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct pxa168fb_info *fbi = info->par;\r\nint pix_fmt;\r\npix_fmt = determine_best_pix_fmt(var);\r\nif (pix_fmt < 0)\r\nreturn pix_fmt;\r\nset_pix_fmt(var, pix_fmt);\r\nfbi->pix_fmt = pix_fmt;\r\nif (var->xoffset + var->xres > var->xres_virtual)\r\nreturn -EINVAL;\r\nif (var->yoffset + var->yres > var->yres_virtual)\r\nreturn -EINVAL;\r\nif (var->xres + var->right_margin +\r\nvar->hsync_len + var->left_margin > 2048)\r\nreturn -EINVAL;\r\nif (var->yres + var->lower_margin +\r\nvar->vsync_len + var->upper_margin > 2048)\r\nreturn -EINVAL;\r\nif (var->xres_virtual * var->yres_virtual *\r\n(var->bits_per_pixel >> 3) > info->fix.smem_len)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void set_clock_divider(struct pxa168fb_info *fbi,\r\nconst struct fb_videomode *m)\r\n{\r\nint divider_int;\r\nint needed_pixclk;\r\nu64 div_result;\r\nu32 x = 0;\r\nif (!m || !m->pixclock || !m->refresh) {\r\ndev_err(fbi->dev, "Input refresh or pixclock is wrong.\n");\r\nreturn;\r\n}\r\nx = 0x80000000;\r\ndiv_result = 1000000000000ll;\r\ndo_div(div_result, m->pixclock);\r\nneeded_pixclk = (u32)div_result;\r\ndivider_int = clk_get_rate(fbi->clk) / needed_pixclk;\r\nif (divider_int < 2) {\r\ndev_warn(fbi->dev, "Warning: clock source is too slow."\r\n"Try smaller resolution\n");\r\ndivider_int = 2;\r\n}\r\nx |= divider_int;\r\nwritel(x, fbi->reg_base + LCD_CFG_SCLK_DIV);\r\n}\r\nstatic void set_dma_control0(struct pxa168fb_info *fbi)\r\n{\r\nu32 x;\r\nx = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);\r\nx &= ~CFG_GRA_ENA_MASK;\r\nx |= fbi->active ? CFG_GRA_ENA(1) : CFG_GRA_ENA(0);\r\nif (fbi->pix_fmt == PIX_FMT_PSEUDOCOLOR)\r\nx |= 0x10000000;\r\nx &= ~(0xF << 16);\r\nx |= (fbi->pix_fmt >> 1) << 16;\r\nx &= ~(1 << 12);\r\nx |= ((fbi->pix_fmt & 1) ^ (fbi->panel_rbswap)) << 12;\r\nwritel(x, fbi->reg_base + LCD_SPU_DMA_CTRL0);\r\n}\r\nstatic void set_dma_control1(struct pxa168fb_info *fbi, int sync)\r\n{\r\nu32 x;\r\nx = readl(fbi->reg_base + LCD_SPU_DMA_CTRL1);\r\nx |= 0x2032ff81;\r\nif (!(sync & FB_SYNC_VERT_HIGH_ACT))\r\nx |= 0x08000000;\r\nwritel(x, fbi->reg_base + LCD_SPU_DMA_CTRL1);\r\n}\r\nstatic void set_graphics_start(struct fb_info *info, int xoffset, int yoffset)\r\n{\r\nstruct pxa168fb_info *fbi = info->par;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nint pixel_offset;\r\nunsigned long addr;\r\npixel_offset = (yoffset * var->xres_virtual) + xoffset;\r\naddr = fbi->fb_start_dma + (pixel_offset * (var->bits_per_pixel >> 3));\r\nwritel(addr, fbi->reg_base + LCD_CFG_GRA_START_ADDR0);\r\n}\r\nstatic void set_dumb_panel_control(struct fb_info *info)\r\n{\r\nstruct pxa168fb_info *fbi = info->par;\r\nstruct pxa168fb_mach_info *mi = fbi->dev->platform_data;\r\nu32 x;\r\nx = readl(fbi->reg_base + LCD_SPU_DUMB_CTRL) & 0x00000001;\r\nx |= (fbi->is_blanked ? 0x7 : mi->dumb_mode) << 28;\r\nx |= mi->gpio_output_data << 20;\r\nx |= mi->gpio_output_mask << 12;\r\nx |= mi->panel_rgb_reverse_lanes ? 0x00000080 : 0;\r\nx |= mi->invert_composite_blank ? 0x00000040 : 0;\r\nx |= (info->var.sync & FB_SYNC_COMP_HIGH_ACT) ? 0x00000020 : 0;\r\nx |= mi->invert_pix_val_ena ? 0x00000010 : 0;\r\nx |= (info->var.sync & FB_SYNC_VERT_HIGH_ACT) ? 0 : 0x00000008;\r\nx |= (info->var.sync & FB_SYNC_HOR_HIGH_ACT) ? 0 : 0x00000004;\r\nx |= mi->invert_pixclock ? 0x00000002 : 0;\r\nwritel(x, fbi->reg_base + LCD_SPU_DUMB_CTRL);\r\n}\r\nstatic void set_dumb_screen_dimensions(struct fb_info *info)\r\n{\r\nstruct pxa168fb_info *fbi = info->par;\r\nstruct fb_var_screeninfo *v = &info->var;\r\nint x;\r\nint y;\r\nx = v->xres + v->right_margin + v->hsync_len + v->left_margin;\r\ny = v->yres + v->lower_margin + v->vsync_len + v->upper_margin;\r\nwritel((y << 16) | x, fbi->reg_base + LCD_SPUT_V_H_TOTAL);\r\n}\r\nstatic int pxa168fb_set_par(struct fb_info *info)\r\n{\r\nstruct pxa168fb_info *fbi = info->par;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct fb_videomode mode;\r\nu32 x;\r\nstruct pxa168fb_mach_info *mi;\r\nmi = fbi->dev->platform_data;\r\nif (fbi->pix_fmt == PIX_FMT_PSEUDOCOLOR)\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nelse\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\ninfo->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;\r\ninfo->fix.ypanstep = var->yres;\r\nx = readl(fbi->reg_base + LCD_SPU_DUMB_CTRL);\r\nwritel(x & ~1, fbi->reg_base + LCD_SPU_DUMB_CTRL);\r\nwritel((var->yres << 16) | var->xres,\r\nfbi->reg_base + LCD_SPU_V_H_ACTIVE);\r\nfb_var_to_videomode(&mode, &info->var);\r\nset_clock_divider(fbi, &mode);\r\nset_dma_control0(fbi);\r\nset_dma_control1(fbi, info->var.sync);\r\nx = readl(fbi->reg_base + LCD_CFG_GRA_PITCH);\r\nx = (x & ~0xFFFF) | ((var->xres_virtual * var->bits_per_pixel) >> 3);\r\nwritel(x, fbi->reg_base + LCD_CFG_GRA_PITCH);\r\nwritel((var->yres << 16) | var->xres,\r\nfbi->reg_base + LCD_SPU_GRA_HPXL_VLN);\r\nwritel((var->yres << 16) | var->xres,\r\nfbi->reg_base + LCD_SPU_GZM_HPXL_VLN);\r\nset_dumb_panel_control(info);\r\nset_dumb_screen_dimensions(info);\r\nwritel((var->left_margin << 16) | var->right_margin,\r\nfbi->reg_base + LCD_SPU_H_PORCH);\r\nwritel((var->upper_margin << 16) | var->lower_margin,\r\nfbi->reg_base + LCD_SPU_V_PORCH);\r\nx = readl(fbi->reg_base + LCD_SPU_DUMB_CTRL);\r\nwritel(x | 1, fbi->reg_base + LCD_SPU_DUMB_CTRL);\r\nreturn 0;\r\n}\r\nstatic unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)\r\n{\r\nreturn ((chan & 0xffff) >> (16 - bf->length)) << bf->offset;\r\n}\r\nstatic u32 to_rgb(u16 red, u16 green, u16 blue)\r\n{\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nreturn (red << 16) | (green << 8) | blue;\r\n}\r\nstatic int\r\npxa168fb_setcolreg(unsigned int regno, unsigned int red, unsigned int green,\r\nunsigned int blue, unsigned int trans, struct fb_info *info)\r\n{\r\nstruct pxa168fb_info *fbi = info->par;\r\nu32 val;\r\nif (info->var.grayscale)\r\nred = green = blue = (19595 * red + 38470 * green +\r\n7471 * blue) >> 16;\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR && regno < 16) {\r\nval = chan_to_field(red, &info->var.red);\r\nval |= chan_to_field(green, &info->var.green);\r\nval |= chan_to_field(blue , &info->var.blue);\r\nfbi->pseudo_palette[regno] = val;\r\n}\r\nif (info->fix.visual == FB_VISUAL_PSEUDOCOLOR && regno < 256) {\r\nval = to_rgb(red, green, blue);\r\nwritel(val, fbi->reg_base + LCD_SPU_SRAM_WRDAT);\r\nwritel(0x8300 | regno, fbi->reg_base + LCD_SPU_SRAM_CTRL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pxa168fb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct pxa168fb_info *fbi = info->par;\r\nfbi->is_blanked = (blank == FB_BLANK_UNBLANK) ? 0 : 1;\r\nset_dumb_panel_control(info);\r\nreturn 0;\r\n}\r\nstatic int pxa168fb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nset_graphics_start(info, var->xoffset, var->yoffset);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t pxa168fb_handle_irq(int irq, void *dev_id)\r\n{\r\nstruct pxa168fb_info *fbi = dev_id;\r\nu32 isr = readl(fbi->reg_base + SPU_IRQ_ISR);\r\nif ((isr & GRA_FRAME_IRQ0_ENA_MASK)) {\r\nwritel(isr & (~GRA_FRAME_IRQ0_ENA_MASK),\r\nfbi->reg_base + SPU_IRQ_ISR);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int pxa168fb_init_mode(struct fb_info *info,\r\nstruct pxa168fb_mach_info *mi)\r\n{\r\nstruct pxa168fb_info *fbi = info->par;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nint ret = 0;\r\nu32 total_w, total_h, refresh;\r\nu64 div_result;\r\nconst struct fb_videomode *m;\r\nrefresh = DEFAULT_REFRESH;\r\nm = fb_find_best_mode(&info->var, &info->modelist);\r\nif (m)\r\nfb_videomode_to_var(&info->var, m);\r\nvar->xres_virtual = var->xres;\r\nvar->yres_virtual = info->fix.smem_len /\r\n(var->xres_virtual * (var->bits_per_pixel >> 3));\r\ndev_dbg(fbi->dev, "pxa168fb: find best mode: res = %dx%d\n",\r\nvar->xres, var->yres);\r\ntotal_w = var->xres + var->left_margin + var->right_margin +\r\nvar->hsync_len;\r\ntotal_h = var->yres + var->upper_margin + var->lower_margin +\r\nvar->vsync_len;\r\ndiv_result = 1000000000000ll;\r\ndo_div(div_result, total_w * total_h * refresh);\r\nvar->pixclock = (u32)div_result;\r\nreturn ret;\r\n}\r\nstatic int pxa168fb_probe(struct platform_device *pdev)\r\n{\r\nstruct pxa168fb_mach_info *mi;\r\nstruct fb_info *info = 0;\r\nstruct pxa168fb_info *fbi = 0;\r\nstruct resource *res;\r\nstruct clk *clk;\r\nint irq, ret;\r\nmi = pdev->dev.platform_data;\r\nif (mi == NULL) {\r\ndev_err(&pdev->dev, "no platform data defined\n");\r\nreturn -EINVAL;\r\n}\r\nclk = clk_get(&pdev->dev, "LCDCLK");\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "unable to get LCDCLK");\r\nreturn PTR_ERR(clk);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "no IO memory defined\n");\r\nret = -ENOENT;\r\ngoto failed_put_clk;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no IRQ defined\n");\r\nret = -ENOENT;\r\ngoto failed_put_clk;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct pxa168fb_info), &pdev->dev);\r\nif (info == NULL) {\r\nret = -ENOMEM;\r\ngoto failed_put_clk;\r\n}\r\nfbi = info->par;\r\nfbi->info = info;\r\nfbi->clk = clk;\r\nfbi->dev = info->dev = &pdev->dev;\r\nfbi->panel_rbswap = mi->panel_rbswap;\r\nfbi->is_blanked = 0;\r\nfbi->active = mi->active;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_PARTIAL_PAN_OK |\r\nFBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;\r\ninfo->node = -1;\r\nstrlcpy(info->fix.id, mi->id, 16);\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.type_aux = 0;\r\ninfo->fix.xpanstep = 0;\r\ninfo->fix.ypanstep = 0;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.mmio_start = res->start;\r\ninfo->fix.mmio_len = resource_size(res);\r\ninfo->fix.accel = FB_ACCEL_NONE;\r\ninfo->fbops = &pxa168fb_ops;\r\ninfo->pseudo_palette = fbi->pseudo_palette;\r\nfbi->reg_base = devm_ioremap_nocache(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (fbi->reg_base == NULL) {\r\nret = -ENOMEM;\r\ngoto failed_free_info;\r\n}\r\ninfo->fix.smem_len = PAGE_ALIGN(DEFAULT_FB_SIZE);\r\ninfo->screen_base = dma_alloc_writecombine(fbi->dev, info->fix.smem_len,\r\n&fbi->fb_start_dma, GFP_KERNEL);\r\nif (info->screen_base == NULL) {\r\nret = -ENOMEM;\r\ngoto failed_free_info;\r\n}\r\ninfo->fix.smem_start = (unsigned long)fbi->fb_start_dma;\r\nset_graphics_start(info, 0, 0);\r\nset_mode(fbi, &info->var, mi->modes, mi->pix_fmt, 1);\r\nfb_videomode_to_modelist(mi->modes, mi->num_modes, &info->modelist);\r\npxa168fb_init_mode(info, mi);\r\nret = pxa168fb_check_var(&info->var, info);\r\nif (ret)\r\ngoto failed_free_fbmem;\r\nclk_enable(fbi->clk);\r\npxa168fb_set_par(info);\r\nwritel(0, fbi->reg_base + LCD_SPU_BLANKCOLOR);\r\nwritel(mi->io_pin_allocation_mode, fbi->reg_base + SPU_IOPAD_CONTROL);\r\nwritel(0, fbi->reg_base + LCD_CFG_GRA_START_ADDR1);\r\nwritel(0, fbi->reg_base + LCD_SPU_GRA_OVSA_HPXL_VLN);\r\nwritel(0, fbi->reg_base + LCD_SPU_SRAM_PARA0);\r\nwritel(CFG_CSB_256x32(0x1)|CFG_CSB_256x24(0x1)|CFG_CSB_256x8(0x1),\r\nfbi->reg_base + LCD_SPU_SRAM_PARA1);\r\nif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\r\nret = -ENOMEM;\r\ngoto failed_free_clk;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, pxa168fb_handle_irq,\r\nIRQF_SHARED, info->fix.id, fbi);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "unable to request IRQ\n");\r\nret = -ENXIO;\r\ngoto failed_free_cmap;\r\n}\r\nwritel(GRA_FRAME_IRQ0_ENA(0x1), fbi->reg_base + SPU_IRQ_ENA);\r\nret = register_framebuffer(info);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to register pxa168-fb: %d\n", ret);\r\nret = -ENXIO;\r\ngoto failed_free_cmap;\r\n}\r\nplatform_set_drvdata(pdev, fbi);\r\nreturn 0;\r\nfailed_free_cmap:\r\nfb_dealloc_cmap(&info->cmap);\r\nfailed_free_clk:\r\nclk_disable(fbi->clk);\r\nfailed_free_fbmem:\r\ndma_free_coherent(fbi->dev, info->fix.smem_len,\r\ninfo->screen_base, fbi->fb_start_dma);\r\nfailed_free_info:\r\nkfree(info);\r\nfailed_put_clk:\r\nclk_put(clk);\r\ndev_err(&pdev->dev, "frame buffer device init failed with %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int pxa168fb_remove(struct platform_device *pdev)\r\n{\r\nstruct pxa168fb_info *fbi = platform_get_drvdata(pdev);\r\nstruct fb_info *info;\r\nint irq;\r\nunsigned int data;\r\nif (!fbi)\r\nreturn 0;\r\ndata = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);\r\ndata &= ~CFG_GRA_ENA_MASK;\r\nwritel(data, fbi->reg_base + LCD_SPU_DMA_CTRL0);\r\ninfo = fbi->info;\r\nunregister_framebuffer(info);\r\nwritel(GRA_FRAME_IRQ0_ENA(0x0), fbi->reg_base + SPU_IRQ_ENA);\r\nif (info->cmap.len)\r\nfb_dealloc_cmap(&info->cmap);\r\nirq = platform_get_irq(pdev, 0);\r\ndma_free_writecombine(fbi->dev, PAGE_ALIGN(info->fix.smem_len),\r\ninfo->screen_base, info->fix.smem_start);\r\nclk_disable(fbi->clk);\r\nclk_put(fbi->clk);\r\nframebuffer_release(info);\r\nreturn 0;\r\n}
