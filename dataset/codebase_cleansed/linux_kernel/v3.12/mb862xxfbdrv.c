static inline int h_total(struct fb_var_screeninfo *var)\r\n{\r\nreturn var->xres + var->left_margin +\r\nvar->right_margin + var->hsync_len;\r\n}\r\nstatic inline int v_total(struct fb_var_screeninfo *var)\r\n{\r\nreturn var->yres + var->upper_margin +\r\nvar->lower_margin + var->vsync_len;\r\n}\r\nstatic inline int hsp(struct fb_var_screeninfo *var)\r\n{\r\nreturn var->xres + var->right_margin - 1;\r\n}\r\nstatic inline int vsp(struct fb_var_screeninfo *var)\r\n{\r\nreturn var->yres + var->lower_margin - 1;\r\n}\r\nstatic inline int d_pitch(struct fb_var_screeninfo *var)\r\n{\r\nreturn var->xres * var->bits_per_pixel / 8;\r\n}\r\nstatic inline unsigned int chan_to_field(unsigned int chan,\r\nstruct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int mb862xxfb_setcolreg(unsigned regno,\r\nunsigned red, unsigned green, unsigned blue,\r\nunsigned transp, struct fb_info *info)\r\n{\r\nstruct mb862xxfb_par *par = info->par;\r\nunsigned int val;\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno < 16) {\r\nval = chan_to_field(red, &info->var.red);\r\nval |= chan_to_field(green, &info->var.green);\r\nval |= chan_to_field(blue, &info->var.blue);\r\npar->pseudo_palette[regno] = val;\r\n}\r\nbreak;\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nif (regno < 256) {\r\nval = (red >> 8) << 16;\r\nval |= (green >> 8) << 8;\r\nval |= blue >> 8;\r\noutreg(disp, GC_L0PAL0 + (regno * 4), val);\r\n}\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mb862xxfb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *fbi)\r\n{\r\nunsigned long tmp;\r\nif (fbi->dev)\r\ndev_dbg(fbi->dev, "%s\n", __func__);\r\nif (var->hsync_len > 255 || var->vsync_len > 255)\r\nreturn -EINVAL;\r\nif ((var->xres + var->right_margin) >= 4096)\r\nreturn -EINVAL;\r\nif ((var->yres + var->lower_margin) > 4096)\r\nreturn -EINVAL;\r\nif (h_total(var) > 4096 || v_total(var) > 4096)\r\nreturn -EINVAL;\r\nif (var->xres_virtual > 4096 || var->yres_virtual > 4096)\r\nreturn -EINVAL;\r\nif (var->bits_per_pixel <= 8)\r\nvar->bits_per_pixel = 8;\r\nelse if (var->bits_per_pixel <= 16)\r\nvar->bits_per_pixel = 16;\r\nelse if (var->bits_per_pixel <= 32)\r\nvar->bits_per_pixel = 32;\r\nif (d_pitch(&fbi->var) % GC_L0M_L0W_UNIT) {\r\nint r;\r\nvar->bits_per_pixel = 0;\r\ndo {\r\nvar->bits_per_pixel += 8;\r\nr = d_pitch(&fbi->var) % GC_L0M_L0W_UNIT;\r\n} while (r && var->bits_per_pixel <= 32);\r\nif (d_pitch(&fbi->var) % GC_L0M_L0W_UNIT)\r\nreturn -EINVAL;\r\n}\r\ntmp = (var->xres * var->bits_per_pixel) / 8;\r\nif ((tmp & 15) != 0)\r\nreturn -EINVAL;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nvar->red.length = var->bits_per_pixel;\r\nvar->green.length = var->bits_per_pixel;\r\nvar->blue.length = var->bits_per_pixel;\r\nvar->red.offset = 0;\r\nvar->green.offset = 0;\r\nvar->blue.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 16:\r\nvar->red.length = 5;\r\nvar->green.length = 5;\r\nvar->blue.length = 5;\r\nvar->red.offset = 10;\r\nvar->green.offset = 5;\r\nvar->blue.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nvar->transp.length = 8;\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 24;\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mb862xxfb_set_par(struct fb_info *fbi)\r\n{\r\nstruct mb862xxfb_par *par = fbi->par;\r\nunsigned long reg, sc;\r\ndev_dbg(par->dev, "%s\n", __func__);\r\nif (par->type == BT_CORALP)\r\nmb862xxfb_init_accel(fbi, fbi->var.xres);\r\nif (par->pre_init)\r\nreturn 0;\r\nreg = inreg(disp, GC_DCM1);\r\nreg &= ~GC_DCM01_DEN;\r\noutreg(disp, GC_DCM1, reg);\r\nsc = par->refclk / (1000000 / fbi->var.pixclock) - 1;\r\nreg = inreg(disp, GC_DCM1);\r\nreg &= ~(GC_DCM01_CKS | GC_DCM01_RESV | GC_DCM01_SC);\r\nreg |= sc << 8;\r\noutreg(disp, GC_DCM1, reg);\r\ndev_dbg(par->dev, "SC 0x%lx\n", sc);\r\nreg = pack(d_pitch(&fbi->var) / GC_L0M_L0W_UNIT,\r\n(fbi->var.yres - 1));\r\nif (fbi->var.bits_per_pixel == 16)\r\nreg |= GC_L0M_L0C_16;\r\noutreg(disp, GC_L0M, reg);\r\nif (fbi->var.bits_per_pixel == 32) {\r\nreg = inreg(disp, GC_L0EM);\r\noutreg(disp, GC_L0EM, reg | GC_L0EM_L0EC_24);\r\n}\r\noutreg(disp, GC_WY_WX, 0);\r\nreg = pack(fbi->var.yres - 1, fbi->var.xres);\r\noutreg(disp, GC_WH_WW, reg);\r\noutreg(disp, GC_L0OA0, 0);\r\noutreg(disp, GC_L0DA0, 0);\r\noutreg(disp, GC_L0DY_L0DX, 0);\r\noutreg(disp, GC_L0WY_L0WX, 0);\r\noutreg(disp, GC_L0WH_L0WW, reg);\r\nreg = inreg(disp, GC_CPM_CUTC);\r\nreg &= ~(GC_CPM_CEN0 | GC_CPM_CEN1);\r\noutreg(disp, GC_CPM_CUTC, reg);\r\nreg = pack(fbi->var.xres - 1, fbi->var.xres - 1);\r\noutreg(disp, GC_HDB_HDP, reg);\r\nreg = pack((fbi->var.yres - 1), vsp(&fbi->var));\r\noutreg(disp, GC_VDP_VSP, reg);\r\nreg = ((fbi->var.vsync_len - 1) << 24) |\r\npack((fbi->var.hsync_len - 1), hsp(&fbi->var));\r\noutreg(disp, GC_VSW_HSW_HSP, reg);\r\noutreg(disp, GC_HTP, pack(h_total(&fbi->var) - 1, 0));\r\noutreg(disp, GC_VTR, pack(v_total(&fbi->var) - 1, 0));\r\nreg = inreg(disp, GC_DCM1);\r\nreg |= GC_DCM01_DEN | GC_DCM01_L0E;\r\nreg &= ~GC_DCM01_ESY;\r\noutreg(disp, GC_DCM1, reg);\r\nreturn 0;\r\n}\r\nstatic int mb862xxfb_pan(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct mb862xxfb_par *par = info->par;\r\nunsigned long reg;\r\nreg = pack(var->yoffset, var->xoffset);\r\noutreg(disp, GC_L0WY_L0WX, reg);\r\nreg = pack(info->var.yres_virtual, info->var.xres_virtual);\r\noutreg(disp, GC_L0WH_L0WW, reg);\r\nreturn 0;\r\n}\r\nstatic int mb862xxfb_blank(int mode, struct fb_info *fbi)\r\n{\r\nstruct mb862xxfb_par *par = fbi->par;\r\nunsigned long reg;\r\ndev_dbg(fbi->dev, "blank mode=%d\n", mode);\r\nswitch (mode) {\r\ncase FB_BLANK_POWERDOWN:\r\nreg = inreg(disp, GC_DCM1);\r\nreg &= ~GC_DCM01_DEN;\r\noutreg(disp, GC_DCM1, reg);\r\nbreak;\r\ncase FB_BLANK_UNBLANK:\r\nreg = inreg(disp, GC_DCM1);\r\nreg |= GC_DCM01_DEN;\r\noutreg(disp, GC_DCM1, reg);\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mb862xxfb_ioctl(struct fb_info *fbi, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct mb862xxfb_par *par = fbi->par;\r\nstruct mb862xx_l1_cfg *l1_cfg = &par->l1_cfg;\r\nvoid __user *argp = (void __user *)arg;\r\nint *enable;\r\nu32 l1em = 0;\r\nswitch (cmd) {\r\ncase MB862XX_L1_GET_CFG:\r\nif (copy_to_user(argp, l1_cfg, sizeof(*l1_cfg)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase MB862XX_L1_SET_CFG:\r\nif (copy_from_user(l1_cfg, argp, sizeof(*l1_cfg)))\r\nreturn -EFAULT;\r\nif (l1_cfg->dh == 0 || l1_cfg->dw == 0)\r\nreturn -EINVAL;\r\nif ((l1_cfg->sw >= l1_cfg->dw) && (l1_cfg->sh >= l1_cfg->dh)) {\r\noutreg(cap, GC_CAP_CSC,\r\npack((l1_cfg->sh << 11) / l1_cfg->dh,\r\n(l1_cfg->sw << 11) / l1_cfg->dw));\r\nl1em = inreg(disp, GC_L1EM);\r\nl1em &= ~GC_L1EM_DM;\r\n} else if ((l1_cfg->sw <= l1_cfg->dw) &&\r\n(l1_cfg->sh <= l1_cfg->dh)) {\r\noutreg(cap, GC_CAP_CSC,\r\npack((l1_cfg->sh << 11) / l1_cfg->dh,\r\n(l1_cfg->sw << 11) / l1_cfg->dw));\r\noutreg(cap, GC_CAP_CMSS,\r\npack(l1_cfg->sw >> 1, l1_cfg->sh));\r\noutreg(cap, GC_CAP_CMDS,\r\npack(l1_cfg->dw >> 1, l1_cfg->dh));\r\nl1em = inreg(disp, GC_L1EM);\r\nl1em |= GC_L1EM_DM;\r\n}\r\nif (l1_cfg->mirror) {\r\noutreg(cap, GC_CAP_CBM,\r\ninreg(cap, GC_CAP_CBM) | GC_CBM_HRV);\r\nl1em |= l1_cfg->dw * 2 - 8;\r\n} else {\r\noutreg(cap, GC_CAP_CBM,\r\ninreg(cap, GC_CAP_CBM) & ~GC_CBM_HRV);\r\nl1em &= 0xffff0000;\r\n}\r\noutreg(disp, GC_L1EM, l1em);\r\nbreak;\r\ncase MB862XX_L1_ENABLE:\r\nenable = (int *)arg;\r\nif (*enable) {\r\noutreg(disp, GC_L1DA, par->cap_buf);\r\noutreg(cap, GC_CAP_IMG_START,\r\npack(l1_cfg->sy >> 1, l1_cfg->sx));\r\noutreg(cap, GC_CAP_IMG_END,\r\npack(l1_cfg->sh, l1_cfg->sw));\r\noutreg(disp, GC_L1M, GC_L1M_16 | GC_L1M_YC | GC_L1M_CS |\r\n(par->l1_stride << 16));\r\noutreg(disp, GC_L1WY_L1WX,\r\npack(l1_cfg->dy, l1_cfg->dx));\r\noutreg(disp, GC_L1WH_L1WW,\r\npack(l1_cfg->dh - 1, l1_cfg->dw));\r\noutreg(disp, GC_DLS, 1);\r\noutreg(cap, GC_CAP_VCM,\r\nGC_VCM_VIE | GC_VCM_CM | GC_VCM_VS_PAL);\r\noutreg(disp, GC_DCM1, inreg(disp, GC_DCM1) |\r\nGC_DCM1_DEN | GC_DCM1_L1E);\r\n} else {\r\noutreg(cap, GC_CAP_VCM,\r\ninreg(cap, GC_CAP_VCM) & ~GC_VCM_VIE);\r\noutreg(disp, GC_DCM1,\r\ninreg(disp, GC_DCM1) & ~GC_DCM1_L1E);\r\n}\r\nbreak;\r\ncase MB862XX_L1_CAP_CTL:\r\nenable = (int *)arg;\r\nif (*enable) {\r\noutreg(cap, GC_CAP_VCM,\r\ninreg(cap, GC_CAP_VCM) | GC_VCM_VIE);\r\n} else {\r\noutreg(cap, GC_CAP_VCM,\r\ninreg(cap, GC_CAP_VCM) & ~GC_VCM_VIE);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mb862xxfb_init_fbinfo(struct fb_info *fbi)\r\n{\r\nstruct mb862xxfb_par *par = fbi->par;\r\nstruct mb862xx_gc_mode *mode = par->gc_mode;\r\nunsigned long reg;\r\nint stride;\r\nfbi->fbops = &mb862xxfb_ops;\r\nfbi->pseudo_palette = par->pseudo_palette;\r\nfbi->screen_base = par->fb_base;\r\nfbi->screen_size = par->mapped_vram;\r\nstrcpy(fbi->fix.id, DRV_NAME);\r\nfbi->fix.smem_start = (unsigned long)par->fb_base_phys;\r\nfbi->fix.mmio_start = (unsigned long)par->mmio_base_phys;\r\nfbi->fix.mmio_len = par->mmio_len;\r\nfbi->fix.accel = FB_ACCEL_NONE;\r\nfbi->fix.type = FB_TYPE_PACKED_PIXELS;\r\nfbi->fix.type_aux = 0;\r\nfbi->fix.xpanstep = 1;\r\nfbi->fix.ypanstep = 1;\r\nfbi->fix.ywrapstep = 0;\r\nreg = inreg(disp, GC_DCM1);\r\nif (reg & GC_DCM01_DEN && reg & GC_DCM01_L0E) {\r\nunsigned long sc = ((reg & GC_DCM01_SC) >> 8) + 1;\r\nunsigned long hsp, vsp, ht, vt;\r\ndev_dbg(par->dev, "using bootloader's disp. mode\n");\r\nfbi->var.pixclock = (sc * 1000000) / par->refclk;\r\nfbi->var.xres = (inreg(disp, GC_HDB_HDP) & 0x0fff) + 1;\r\nreg = inreg(disp, GC_VDP_VSP);\r\nfbi->var.yres = ((reg >> 16) & 0x0fff) + 1;\r\nvsp = (reg & 0x0fff) + 1;\r\nfbi->var.xres_virtual = fbi->var.xres;\r\nfbi->var.yres_virtual = fbi->var.yres;\r\nreg = inreg(disp, GC_L0EM);\r\nif (reg & GC_L0EM_L0EC_24) {\r\nfbi->var.bits_per_pixel = 32;\r\n} else {\r\nreg = inreg(disp, GC_L0M);\r\nif (reg & GC_L0M_L0C_16)\r\nfbi->var.bits_per_pixel = 16;\r\nelse\r\nfbi->var.bits_per_pixel = 8;\r\n}\r\nreg = inreg(disp, GC_VSW_HSW_HSP);\r\nfbi->var.hsync_len = ((reg & 0xff0000) >> 16) + 1;\r\nfbi->var.vsync_len = ((reg & 0x3f000000) >> 24) + 1;\r\nhsp = (reg & 0xffff) + 1;\r\nht = ((inreg(disp, GC_HTP) & 0xfff0000) >> 16) + 1;\r\nfbi->var.right_margin = hsp - fbi->var.xres;\r\nfbi->var.left_margin = ht - hsp - fbi->var.hsync_len;\r\nvt = ((inreg(disp, GC_VTR) & 0xfff0000) >> 16) + 1;\r\nfbi->var.lower_margin = vsp - fbi->var.yres;\r\nfbi->var.upper_margin = vt - vsp - fbi->var.vsync_len;\r\n} else if (mode) {\r\ndev_dbg(par->dev, "using supplied mode\n");\r\nfb_videomode_to_var(&fbi->var, (struct fb_videomode *)mode);\r\nfbi->var.bits_per_pixel = mode->def_bpp ? mode->def_bpp : 8;\r\n} else {\r\nint ret;\r\nret = fb_find_mode(&fbi->var, fbi, "640x480-16@60",\r\nNULL, 0, NULL, 16);\r\nif (ret == 0 || ret == 4) {\r\ndev_err(par->dev,\r\n"failed to get initial mode\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nfbi->var.xoffset = 0;\r\nfbi->var.yoffset = 0;\r\nfbi->var.grayscale = 0;\r\nfbi->var.nonstd = 0;\r\nfbi->var.height = -1;\r\nfbi->var.width = -1;\r\nfbi->var.accel_flags = 0;\r\nfbi->var.vmode = FB_VMODE_NONINTERLACED;\r\nfbi->var.activate = FB_ACTIVATE_NOW;\r\nfbi->flags = FBINFO_DEFAULT |\r\n#ifdef __BIG_ENDIAN\r\nFBINFO_FOREIGN_ENDIAN |\r\n#endif\r\nFBINFO_HWACCEL_XPAN |\r\nFBINFO_HWACCEL_YPAN;\r\nif ((fbi->fbops->fb_check_var)(&fbi->var, fbi))\r\ndev_err(par->dev, "check_var() failed on initial setup?\n");\r\nfbi->fix.visual = fbi->var.bits_per_pixel == 8 ?\r\nFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\r\nfbi->fix.line_length = (fbi->var.xres_virtual *\r\nfbi->var.bits_per_pixel) / 8;\r\nfbi->fix.smem_len = fbi->fix.line_length * fbi->var.yres_virtual;\r\npar->cap_buf = par->mapped_vram - 0x1bd800 - 0x10000;\r\npar->cap_len = 0x1bd800;\r\npar->l1_cfg.sx = 0;\r\npar->l1_cfg.sy = 0;\r\npar->l1_cfg.sw = 720;\r\npar->l1_cfg.sh = 576;\r\npar->l1_cfg.dx = 0;\r\npar->l1_cfg.dy = 0;\r\npar->l1_cfg.dw = 720;\r\npar->l1_cfg.dh = 576;\r\nstride = par->l1_cfg.sw * (fbi->var.bits_per_pixel / 8);\r\npar->l1_stride = stride / 64 + ((stride % 64) ? 1 : 0);\r\noutreg(cap, GC_CAP_CBM, GC_CBM_OO | GC_CBM_CBST |\r\n(par->l1_stride << 16));\r\noutreg(cap, GC_CAP_CBOA, par->cap_buf);\r\noutreg(cap, GC_CAP_CBLA, par->cap_buf + par->cap_len);\r\nreturn 0;\r\n}\r\nstatic ssize_t mb862xxfb_show_dispregs(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *fbi = dev_get_drvdata(dev);\r\nstruct mb862xxfb_par *par = fbi->par;\r\nchar *ptr = buf;\r\nunsigned int reg;\r\nfor (reg = GC_DCM0; reg <= GC_L0DY_L0DX; reg += 4)\r\nptr += sprintf(ptr, "%08x = %08x\n",\r\nreg, inreg(disp, reg));\r\nfor (reg = GC_CPM_CUTC; reg <= GC_CUY1_CUX1; reg += 4)\r\nptr += sprintf(ptr, "%08x = %08x\n",\r\nreg, inreg(disp, reg));\r\nfor (reg = GC_DCM1; reg <= GC_L0WH_L0WW; reg += 4)\r\nptr += sprintf(ptr, "%08x = %08x\n",\r\nreg, inreg(disp, reg));\r\nfor (reg = 0x400; reg <= 0x410; reg += 4)\r\nptr += sprintf(ptr, "geo %08x = %08x\n",\r\nreg, inreg(geo, reg));\r\nfor (reg = 0x400; reg <= 0x410; reg += 4)\r\nptr += sprintf(ptr, "draw %08x = %08x\n",\r\nreg, inreg(draw, reg));\r\nfor (reg = 0x440; reg <= 0x450; reg += 4)\r\nptr += sprintf(ptr, "draw %08x = %08x\n",\r\nreg, inreg(draw, reg));\r\nreturn ptr - buf;\r\n}\r\nstatic irqreturn_t mb862xx_intr(int irq, void *dev_id)\r\n{\r\nstruct mb862xxfb_par *par = (struct mb862xxfb_par *) dev_id;\r\nunsigned long reg_ist, mask;\r\nif (!par)\r\nreturn IRQ_NONE;\r\nif (par->type == BT_CARMINE) {\r\nreg_ist = inreg(ctrl, GC_CTRL_STATUS);\r\nmask = inreg(ctrl, GC_CTRL_INT_MASK);\r\nif (reg_ist == 0)\r\nreturn IRQ_HANDLED;\r\nreg_ist &= mask;\r\nif (reg_ist == 0)\r\nreturn IRQ_HANDLED;\r\noutreg(ctrl, 0x0, reg_ist);\r\n} else {\r\nreg_ist = inreg(host, GC_IST);\r\nmask = inreg(host, GC_IMASK);\r\nreg_ist &= mask;\r\nif (reg_ist == 0)\r\nreturn IRQ_HANDLED;\r\noutreg(host, GC_IST, ~reg_ist);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mb862xx_gdc_init(struct mb862xxfb_par *par)\r\n{\r\nunsigned long ccf, mmr;\r\nunsigned long ver, rev;\r\nif (!par)\r\nreturn -ENODEV;\r\n#if defined(CONFIG_FB_PRE_INIT_FB)\r\npar->pre_init = 1;\r\n#endif\r\npar->host = par->mmio_base;\r\npar->i2c = par->mmio_base + MB862XX_I2C_BASE;\r\npar->disp = par->mmio_base + MB862XX_DISP_BASE;\r\npar->cap = par->mmio_base + MB862XX_CAP_BASE;\r\npar->draw = par->mmio_base + MB862XX_DRAW_BASE;\r\npar->geo = par->mmio_base + MB862XX_GEO_BASE;\r\npar->pio = par->mmio_base + MB862XX_PIO_BASE;\r\npar->refclk = GC_DISP_REFCLK_400;\r\nver = inreg(host, GC_CID);\r\nrev = inreg(pio, GC_REVISION);\r\nif ((ver == 0x303) && (rev & 0xffffff00) == 0x20050100) {\r\ndev_info(par->dev, "Fujitsu Lime v1.%d found\n",\r\n(int)rev & 0xff);\r\npar->type = BT_LIME;\r\nccf = par->gc_mode ? par->gc_mode->ccf : GC_CCF_COT_100;\r\nmmr = par->gc_mode ? par->gc_mode->mmr : 0x414fb7f2;\r\n} else {\r\ndev_info(par->dev, "? GDC, CID/Rev.: 0x%lx/0x%lx \n", ver, rev);\r\nreturn -ENODEV;\r\n}\r\nif (!par->pre_init) {\r\noutreg(host, GC_CCF, ccf);\r\nudelay(200);\r\noutreg(host, GC_MMR, mmr);\r\nudelay(10);\r\n}\r\noutreg(host, GC_IST, 0);\r\noutreg(host, GC_IMASK, GC_INT_EN);\r\nreturn 0;\r\n}\r\nstatic int of_platform_mb862xx_probe(struct platform_device *ofdev)\r\n{\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct device *dev = &ofdev->dev;\r\nstruct mb862xxfb_par *par;\r\nstruct fb_info *info;\r\nstruct resource res;\r\nresource_size_t res_size;\r\nunsigned long ret = -ENODEV;\r\nif (of_address_to_resource(np, 0, &res)) {\r\ndev_err(dev, "Invalid address\n");\r\nreturn -ENXIO;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct mb862xxfb_par), dev);\r\nif (info == NULL) {\r\ndev_err(dev, "cannot allocate framebuffer\n");\r\nreturn -ENOMEM;\r\n}\r\npar = info->par;\r\npar->info = info;\r\npar->dev = dev;\r\npar->irq = irq_of_parse_and_map(np, 0);\r\nif (par->irq == NO_IRQ) {\r\ndev_err(dev, "failed to map irq\n");\r\nret = -ENODEV;\r\ngoto fbrel;\r\n}\r\nres_size = resource_size(&res);\r\npar->res = request_mem_region(res.start, res_size, DRV_NAME);\r\nif (par->res == NULL) {\r\ndev_err(dev, "Cannot claim framebuffer/mmio\n");\r\nret = -ENXIO;\r\ngoto irqdisp;\r\n}\r\n#if defined(CONFIG_SOCRATES)\r\npar->gc_mode = &socrates_gc_mode;\r\n#endif\r\npar->fb_base_phys = res.start;\r\npar->mmio_base_phys = res.start + MB862XX_MMIO_BASE;\r\npar->mmio_len = MB862XX_MMIO_SIZE;\r\nif (par->gc_mode)\r\npar->mapped_vram = par->gc_mode->max_vram;\r\nelse\r\npar->mapped_vram = MB862XX_MEM_SIZE;\r\npar->fb_base = ioremap(par->fb_base_phys, par->mapped_vram);\r\nif (par->fb_base == NULL) {\r\ndev_err(dev, "Cannot map framebuffer\n");\r\ngoto rel_reg;\r\n}\r\npar->mmio_base = ioremap(par->mmio_base_phys, par->mmio_len);\r\nif (par->mmio_base == NULL) {\r\ndev_err(dev, "Cannot map registers\n");\r\ngoto fb_unmap;\r\n}\r\ndev_dbg(dev, "fb phys 0x%llx 0x%lx\n",\r\n(u64)par->fb_base_phys, (ulong)par->mapped_vram);\r\ndev_dbg(dev, "mmio phys 0x%llx 0x%lx, (irq = %d)\n",\r\n(u64)par->mmio_base_phys, (ulong)par->mmio_len, par->irq);\r\nif (mb862xx_gdc_init(par))\r\ngoto io_unmap;\r\nif (request_irq(par->irq, mb862xx_intr, 0,\r\nDRV_NAME, (void *)par)) {\r\ndev_err(dev, "Cannot request irq\n");\r\ngoto io_unmap;\r\n}\r\nmb862xxfb_init_fbinfo(info);\r\nif (fb_alloc_cmap(&info->cmap, NR_PALETTE, 0) < 0) {\r\ndev_err(dev, "Could not allocate cmap for fb_info.\n");\r\ngoto free_irq;\r\n}\r\nif ((info->fbops->fb_set_par)(info))\r\ndev_err(dev, "set_var() failed on initial setup?\n");\r\nif (register_framebuffer(info)) {\r\ndev_err(dev, "failed to register framebuffer\n");\r\ngoto rel_cmap;\r\n}\r\ndev_set_drvdata(dev, info);\r\nif (device_create_file(dev, &dev_attr_dispregs))\r\ndev_err(dev, "Can't create sysfs regdump file\n");\r\nreturn 0;\r\nrel_cmap:\r\nfb_dealloc_cmap(&info->cmap);\r\nfree_irq:\r\noutreg(host, GC_IMASK, 0);\r\nfree_irq(par->irq, (void *)par);\r\nio_unmap:\r\niounmap(par->mmio_base);\r\nfb_unmap:\r\niounmap(par->fb_base);\r\nrel_reg:\r\nrelease_mem_region(res.start, res_size);\r\nirqdisp:\r\nirq_dispose_mapping(par->irq);\r\nfbrel:\r\ndev_set_drvdata(dev, NULL);\r\nframebuffer_release(info);\r\nreturn ret;\r\n}\r\nstatic int of_platform_mb862xx_remove(struct platform_device *ofdev)\r\n{\r\nstruct fb_info *fbi = dev_get_drvdata(&ofdev->dev);\r\nstruct mb862xxfb_par *par = fbi->par;\r\nresource_size_t res_size = resource_size(par->res);\r\nunsigned long reg;\r\ndev_dbg(fbi->dev, "%s release\n", fbi->fix.id);\r\nreg = inreg(disp, GC_DCM1);\r\nreg &= ~(GC_DCM01_DEN | GC_DCM01_L0E);\r\noutreg(disp, GC_DCM1, reg);\r\noutreg(host, GC_IMASK, 0);\r\nfree_irq(par->irq, (void *)par);\r\nirq_dispose_mapping(par->irq);\r\ndevice_remove_file(&ofdev->dev, &dev_attr_dispregs);\r\nunregister_framebuffer(fbi);\r\nfb_dealloc_cmap(&fbi->cmap);\r\niounmap(par->mmio_base);\r\niounmap(par->fb_base);\r\ndev_set_drvdata(&ofdev->dev, NULL);\r\nrelease_mem_region(par->res->start, res_size);\r\nframebuffer_release(fbi);\r\nreturn 0;\r\n}\r\nstatic int coralp_init(struct mb862xxfb_par *par)\r\n{\r\nint cn, ver;\r\npar->host = par->mmio_base;\r\npar->i2c = par->mmio_base + MB862XX_I2C_BASE;\r\npar->disp = par->mmio_base + MB862XX_DISP_BASE;\r\npar->cap = par->mmio_base + MB862XX_CAP_BASE;\r\npar->draw = par->mmio_base + MB862XX_DRAW_BASE;\r\npar->geo = par->mmio_base + MB862XX_GEO_BASE;\r\npar->pio = par->mmio_base + MB862XX_PIO_BASE;\r\npar->refclk = GC_DISP_REFCLK_400;\r\nif (par->mapped_vram >= 0x2000000) {\r\nwritel(1, par->fb_base + MB862XX_MMIO_BASE + GC_RSW);\r\nudelay(1);\r\n}\r\nver = inreg(host, GC_CID);\r\ncn = (ver & GC_CID_CNAME_MSK) >> 8;\r\nver = ver & GC_CID_VERSION_MSK;\r\nif (cn == 3) {\r\nunsigned long reg;\r\ndev_info(par->dev, "Fujitsu Coral-%s GDC Rev.%d found\n",\\r\n(ver == 6) ? "P" : (ver == 8) ? "PA" : "?",\r\npar->pdev->revision);\r\nreg = inreg(disp, GC_DCM1);\r\nif (reg & GC_DCM01_DEN && reg & GC_DCM01_L0E)\r\npar->pre_init = 1;\r\nif (!par->pre_init) {\r\noutreg(host, GC_CCF, GC_CCF_CGE_166 | GC_CCF_COT_133);\r\nudelay(200);\r\noutreg(host, GC_MMR, GC_MMR_CORALP_EVB_VAL);\r\nudelay(10);\r\n}\r\noutreg(host, GC_IST, 0);\r\n} else {\r\nreturn -ENODEV;\r\n}\r\nmb862xx_i2c_init(par);\r\nreturn 0;\r\n}\r\nstatic int init_dram_ctrl(struct mb862xxfb_par *par)\r\n{\r\nunsigned long i = 0;\r\noutreg(dram_ctrl, GC_DCTL_IOCONT1_IOCONT0, GC_EVB_DCTL_IOCONT1_IOCONT0);\r\noutreg(dram_ctrl, GC_DCTL_MODE_ADD, GC_EVB_DCTL_MODE_ADD);\r\noutreg(dram_ctrl, GC_DCTL_SETTIME1_EMODE, GC_EVB_DCTL_SETTIME1_EMODE);\r\noutreg(dram_ctrl, GC_DCTL_REFRESH_SETTIME2,\r\nGC_EVB_DCTL_REFRESH_SETTIME2);\r\noutreg(dram_ctrl, GC_DCTL_RSV2_RSV1, GC_EVB_DCTL_RSV2_RSV1);\r\noutreg(dram_ctrl, GC_DCTL_DDRIF2_DDRIF1, GC_EVB_DCTL_DDRIF2_DDRIF1);\r\noutreg(dram_ctrl, GC_DCTL_RSV0_STATES, GC_EVB_DCTL_RSV0_STATES);\r\nwhile ((inreg(dram_ctrl, GC_DCTL_RSV0_STATES) & GC_DCTL_STATES_MSK)) {\r\nudelay(GC_DCTL_INIT_WAIT_INTERVAL);\r\nif (i++ > GC_DCTL_INIT_WAIT_CNT) {\r\ndev_err(par->dev, "VRAM init failed.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\noutreg(dram_ctrl, GC_DCTL_MODE_ADD, GC_EVB_DCTL_MODE_ADD_AFT_RST);\r\noutreg(dram_ctrl, GC_DCTL_RSV0_STATES, GC_EVB_DCTL_RSV0_STATES_AFT_RST);\r\nreturn 0;\r\n}\r\nstatic int carmine_init(struct mb862xxfb_par *par)\r\n{\r\nunsigned long reg;\r\npar->ctrl = par->mmio_base + MB86297_CTRL_BASE;\r\npar->i2c = par->mmio_base + MB86297_I2C_BASE;\r\npar->disp = par->mmio_base + MB86297_DISP0_BASE;\r\npar->disp1 = par->mmio_base + MB86297_DISP1_BASE;\r\npar->cap = par->mmio_base + MB86297_CAP0_BASE;\r\npar->cap1 = par->mmio_base + MB86297_CAP1_BASE;\r\npar->draw = par->mmio_base + MB86297_DRAW_BASE;\r\npar->dram_ctrl = par->mmio_base + MB86297_DRAMCTRL_BASE;\r\npar->wrback = par->mmio_base + MB86297_WRBACK_BASE;\r\npar->refclk = GC_DISP_REFCLK_533;\r\nreg = GC_CTRL_CLK_EN_DRAM | GC_CTRL_CLK_EN_2D3D | GC_CTRL_CLK_EN_DISP0;\r\noutreg(ctrl, GC_CTRL_CLK_ENABLE, reg);\r\nif (inreg(draw, GC_2D3D_REV) == GC_RE_REVISION)\r\ndev_info(par->dev, "Fujitsu Carmine GDC Rev.%d found\n",\r\npar->pdev->revision);\r\nelse\r\ngoto err_init;\r\nreg &= ~GC_CTRL_CLK_EN_2D3D;\r\noutreg(ctrl, GC_CTRL_CLK_ENABLE, reg);\r\nif (init_dram_ctrl(par) < 0)\r\ngoto err_init;\r\noutreg(ctrl, GC_CTRL_INT_MASK, 0);\r\nreturn 0;\r\nerr_init:\r\noutreg(ctrl, GC_CTRL_CLK_ENABLE, 0);\r\nreturn -EINVAL;\r\n}\r\nstatic inline int mb862xx_pci_gdc_init(struct mb862xxfb_par *par)\r\n{\r\nswitch (par->type) {\r\ncase BT_CORALP:\r\nreturn coralp_init(par);\r\ncase BT_CARMINE:\r\nreturn carmine_init(par);\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic int mb862xx_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct mb862xxfb_par *par;\r\nstruct fb_info *info;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\nret = pci_enable_device(pdev);\r\nif (ret < 0) {\r\ndev_err(dev, "Cannot enable PCI device\n");\r\ngoto out;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct mb862xxfb_par), dev);\r\nif (!info) {\r\ndev_err(dev, "framebuffer alloc failed\n");\r\nret = -ENOMEM;\r\ngoto dis_dev;\r\n}\r\npar = info->par;\r\npar->info = info;\r\npar->dev = dev;\r\npar->pdev = pdev;\r\npar->irq = pdev->irq;\r\nret = pci_request_regions(pdev, DRV_NAME);\r\nif (ret < 0) {\r\ndev_err(dev, "Cannot reserve region(s) for PCI device\n");\r\ngoto rel_fb;\r\n}\r\nswitch (pdev->device) {\r\ncase PCI_DEVICE_ID_FUJITSU_CORALP:\r\ncase PCI_DEVICE_ID_FUJITSU_CORALPA:\r\npar->fb_base_phys = pci_resource_start(par->pdev, 0);\r\npar->mapped_vram = CORALP_MEM_SIZE;\r\nif (par->mapped_vram >= 0x2000000) {\r\npar->mmio_base_phys = par->fb_base_phys +\r\nMB862XX_MMIO_HIGH_BASE;\r\n} else {\r\npar->mmio_base_phys = par->fb_base_phys +\r\nMB862XX_MMIO_BASE;\r\n}\r\npar->mmio_len = MB862XX_MMIO_SIZE;\r\npar->type = BT_CORALP;\r\nbreak;\r\ncase PCI_DEVICE_ID_FUJITSU_CARMINE:\r\npar->fb_base_phys = pci_resource_start(par->pdev, 2);\r\npar->mmio_base_phys = pci_resource_start(par->pdev, 3);\r\npar->mmio_len = pci_resource_len(par->pdev, 3);\r\npar->mapped_vram = CARMINE_MEM_SIZE;\r\npar->type = BT_CARMINE;\r\nbreak;\r\ndefault:\r\nret = -EIO;\r\ngoto rel_reg;\r\n}\r\npar->fb_base = ioremap(par->fb_base_phys, par->mapped_vram);\r\nif (par->fb_base == NULL) {\r\ndev_err(dev, "Cannot map framebuffer\n");\r\nret = -EIO;\r\ngoto rel_reg;\r\n}\r\npar->mmio_base = ioremap(par->mmio_base_phys, par->mmio_len);\r\nif (par->mmio_base == NULL) {\r\ndev_err(dev, "Cannot map registers\n");\r\nret = -EIO;\r\ngoto fb_unmap;\r\n}\r\ndev_dbg(dev, "fb phys 0x%llx 0x%lx\n",\r\n(unsigned long long)par->fb_base_phys, (ulong)par->mapped_vram);\r\ndev_dbg(dev, "mmio phys 0x%llx 0x%lx\n",\r\n(unsigned long long)par->mmio_base_phys, (ulong)par->mmio_len);\r\nret = mb862xx_pci_gdc_init(par);\r\nif (ret)\r\ngoto io_unmap;\r\nret = request_irq(par->irq, mb862xx_intr, IRQF_SHARED,\r\nDRV_NAME, (void *)par);\r\nif (ret) {\r\ndev_err(dev, "Cannot request irq\n");\r\ngoto io_unmap;\r\n}\r\nmb862xxfb_init_fbinfo(info);\r\nif (fb_alloc_cmap(&info->cmap, NR_PALETTE, 0) < 0) {\r\ndev_err(dev, "Could not allocate cmap for fb_info.\n");\r\nret = -ENOMEM;\r\ngoto free_irq;\r\n}\r\nif ((info->fbops->fb_set_par)(info))\r\ndev_err(dev, "set_var() failed on initial setup?\n");\r\nret = register_framebuffer(info);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to register framebuffer\n");\r\ngoto rel_cmap;\r\n}\r\npci_set_drvdata(pdev, info);\r\nif (device_create_file(dev, &dev_attr_dispregs))\r\ndev_err(dev, "Can't create sysfs regdump file\n");\r\nif (par->type == BT_CARMINE)\r\noutreg(ctrl, GC_CTRL_INT_MASK, GC_CARMINE_INT_EN);\r\nelse\r\noutreg(host, GC_IMASK, GC_INT_EN);\r\nreturn 0;\r\nrel_cmap:\r\nfb_dealloc_cmap(&info->cmap);\r\nfree_irq:\r\nfree_irq(par->irq, (void *)par);\r\nio_unmap:\r\niounmap(par->mmio_base);\r\nfb_unmap:\r\niounmap(par->fb_base);\r\nrel_reg:\r\npci_release_regions(pdev);\r\nrel_fb:\r\nframebuffer_release(info);\r\ndis_dev:\r\npci_disable_device(pdev);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void mb862xx_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct fb_info *fbi = pci_get_drvdata(pdev);\r\nstruct mb862xxfb_par *par = fbi->par;\r\nunsigned long reg;\r\ndev_dbg(fbi->dev, "%s release\n", fbi->fix.id);\r\nreg = inreg(disp, GC_DCM1);\r\nreg &= ~(GC_DCM01_DEN | GC_DCM01_L0E);\r\noutreg(disp, GC_DCM1, reg);\r\nif (par->type == BT_CARMINE) {\r\noutreg(ctrl, GC_CTRL_INT_MASK, 0);\r\noutreg(ctrl, GC_CTRL_CLK_ENABLE, 0);\r\n} else {\r\noutreg(host, GC_IMASK, 0);\r\n}\r\nmb862xx_i2c_exit(par);\r\ndevice_remove_file(&pdev->dev, &dev_attr_dispregs);\r\npci_set_drvdata(pdev, NULL);\r\nunregister_framebuffer(fbi);\r\nfb_dealloc_cmap(&fbi->cmap);\r\nfree_irq(par->irq, (void *)par);\r\niounmap(par->mmio_base);\r\niounmap(par->fb_base);\r\npci_release_regions(pdev);\r\nframebuffer_release(fbi);\r\npci_disable_device(pdev);\r\n}\r\nstatic int mb862xxfb_init(void)\r\n{\r\nint ret = -ENODEV;\r\n#if defined(CONFIG_FB_MB862XX_LIME)\r\nret = platform_driver_register(&of_platform_mb862xxfb_driver);\r\n#endif\r\n#if defined(CONFIG_FB_MB862XX_PCI_GDC)\r\nret = pci_register_driver(&mb862xxfb_pci_driver);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit mb862xxfb_exit(void)\r\n{\r\n#if defined(CONFIG_FB_MB862XX_LIME)\r\nplatform_driver_unregister(&of_platform_mb862xxfb_driver);\r\n#endif\r\n#if defined(CONFIG_FB_MB862XX_PCI_GDC)\r\npci_unregister_driver(&mb862xxfb_pci_driver);\r\n#endif\r\n}
