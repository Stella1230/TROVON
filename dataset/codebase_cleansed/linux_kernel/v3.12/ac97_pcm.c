static unsigned char get_slot_reg(struct ac97_pcm *pcm, unsigned short cidx,\r\nunsigned short slot, int dbl)\r\n{\r\nif (slot < 3)\r\nreturn 0xff;\r\nif (slot > 11)\r\nreturn 0xff;\r\nif (pcm->spdif)\r\nreturn AC97_SPDIF;\r\nif (pcm->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nreturn rate_reg_tables[dbl][pcm->r[dbl].rate_table[cidx]][slot - 3];\r\nelse\r\nreturn rate_cregs[slot - 3];\r\n}\r\nstatic int set_spdif_rate(struct snd_ac97 *ac97, unsigned short rate)\r\n{\r\nunsigned short old, bits, reg, mask;\r\nunsigned int sbits;\r\nif (! (ac97->ext_id & AC97_EI_SPDIF))\r\nreturn -ENODEV;\r\nif (ac97->flags & AC97_CS_SPDIF) {\r\nswitch (rate) {\r\ncase 48000: bits = 0; break;\r\ncase 44100: bits = 1 << AC97_SC_SPSR_SHIFT; break;\r\ndefault:\r\nsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);\r\nreturn -EINVAL;\r\n}\r\nreg = AC97_CSR_SPDIF;\r\nmask = 1 << AC97_SC_SPSR_SHIFT;\r\n} else {\r\nif (ac97->id == AC97_ID_CM9739 && rate != 48000) {\r\nsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);\r\nreturn -EINVAL;\r\n}\r\nswitch (rate) {\r\ncase 44100: bits = AC97_SC_SPSR_44K; break;\r\ncase 48000: bits = AC97_SC_SPSR_48K; break;\r\ncase 32000: bits = AC97_SC_SPSR_32K; break;\r\ndefault:\r\nsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);\r\nreturn -EINVAL;\r\n}\r\nreg = AC97_SPDIF;\r\nmask = AC97_SC_SPSR_MASK;\r\n}\r\nmutex_lock(&ac97->reg_mutex);\r\nold = snd_ac97_read(ac97, reg) & mask;\r\nif (old != bits) {\r\nsnd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);\r\nsnd_ac97_update_bits_nolock(ac97, reg, mask, bits);\r\nsbits = ac97->spdif_status;\r\nif (sbits & IEC958_AES0_PROFESSIONAL) {\r\nsbits &= ~IEC958_AES0_PRO_FS;\r\nswitch (rate) {\r\ncase 44100: sbits |= IEC958_AES0_PRO_FS_44100; break;\r\ncase 48000: sbits |= IEC958_AES0_PRO_FS_48000; break;\r\ncase 32000: sbits |= IEC958_AES0_PRO_FS_32000; break;\r\n}\r\n} else {\r\nsbits &= ~(IEC958_AES3_CON_FS << 24);\r\nswitch (rate) {\r\ncase 44100: sbits |= IEC958_AES3_CON_FS_44100<<24; break;\r\ncase 48000: sbits |= IEC958_AES3_CON_FS_48000<<24; break;\r\ncase 32000: sbits |= IEC958_AES3_CON_FS_32000<<24; break;\r\n}\r\n}\r\nac97->spdif_status = sbits;\r\n}\r\nsnd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, AC97_EA_SPDIF);\r\nmutex_unlock(&ac97->reg_mutex);\r\nreturn 0;\r\n}\r\nint snd_ac97_set_rate(struct snd_ac97 *ac97, int reg, unsigned int rate)\r\n{\r\nint dbl;\r\nunsigned int tmp;\r\ndbl = rate > 48000;\r\nif (dbl) {\r\nif (!(ac97->flags & AC97_DOUBLE_RATE))\r\nreturn -EINVAL;\r\nif (reg != AC97_PCM_FRONT_DAC_RATE)\r\nreturn -EINVAL;\r\n}\r\nsnd_ac97_update_power(ac97, reg, 1);\r\nswitch (reg) {\r\ncase AC97_PCM_MIC_ADC_RATE:\r\nif ((ac97->regs[AC97_EXTENDED_STATUS] & AC97_EA_VRM) == 0)\r\nif (rate != 48000)\r\nreturn -EINVAL;\r\nbreak;\r\ncase AC97_PCM_FRONT_DAC_RATE:\r\ncase AC97_PCM_LR_ADC_RATE:\r\nif ((ac97->regs[AC97_EXTENDED_STATUS] & AC97_EA_VRA) == 0)\r\nif (rate != 48000 && rate != 96000)\r\nreturn -EINVAL;\r\nbreak;\r\ncase AC97_PCM_SURR_DAC_RATE:\r\nif (! (ac97->scaps & AC97_SCAP_SURROUND_DAC))\r\nreturn -EINVAL;\r\nbreak;\r\ncase AC97_PCM_LFE_DAC_RATE:\r\nif (! (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC))\r\nreturn -EINVAL;\r\nbreak;\r\ncase AC97_SPDIF:\r\nreturn set_spdif_rate(ac97, rate);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (dbl)\r\nrate /= 2;\r\ntmp = (rate * ac97->bus->clock) / 48000;\r\nif (tmp > 65535)\r\nreturn -EINVAL;\r\nif ((ac97->ext_id & AC97_EI_DRA) && reg == AC97_PCM_FRONT_DAC_RATE)\r\nsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS,\r\nAC97_EA_DRA, dbl ? AC97_EA_DRA : 0);\r\nsnd_ac97_update(ac97, reg, tmp & 0xffff);\r\nsnd_ac97_read(ac97, reg);\r\nif ((ac97->ext_id & AC97_EI_DRA) && reg == AC97_PCM_FRONT_DAC_RATE) {\r\nsnd_ac97_update_bits(ac97, AC97_GENERAL_PURPOSE,\r\nAC97_GP_DRSS_MASK,\r\ndbl ? AC97_GP_DRSS_78 : 0);\r\nsnd_ac97_read(ac97, AC97_GENERAL_PURPOSE);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned short get_pslots(struct snd_ac97 *ac97, unsigned char *rate_table, unsigned short *spdif_slots)\r\n{\r\nif (!ac97_is_audio(ac97))\r\nreturn 0;\r\nif (ac97_is_rev22(ac97) || ac97_can_amap(ac97)) {\r\nunsigned short slots = 0;\r\nif (ac97_is_rev22(ac97)) {\r\nu16 es;\r\nes = ac97->regs[AC97_EXTENDED_ID] &= ~AC97_EI_DACS_SLOT_MASK;\r\nswitch (ac97->addr) {\r\ncase 1:\r\ncase 2: es |= (1<<AC97_EI_DACS_SLOT_SHIFT); break;\r\ncase 3: es |= (2<<AC97_EI_DACS_SLOT_SHIFT); break;\r\n}\r\nsnd_ac97_write_cache(ac97, AC97_EXTENDED_ID, es);\r\n}\r\nswitch (ac97->addr) {\r\ncase 0:\r\nslots |= (1<<AC97_SLOT_PCM_LEFT)|(1<<AC97_SLOT_PCM_RIGHT);\r\nif (ac97->scaps & AC97_SCAP_SURROUND_DAC)\r\nslots |= (1<<AC97_SLOT_PCM_SLEFT)|(1<<AC97_SLOT_PCM_SRIGHT);\r\nif (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC)\r\nslots |= (1<<AC97_SLOT_PCM_CENTER)|(1<<AC97_SLOT_LFE);\r\nif (ac97->ext_id & AC97_EI_SPDIF) {\r\nif (!(ac97->scaps & AC97_SCAP_SURROUND_DAC))\r\n*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT)|(1<<AC97_SLOT_SPDIF_RIGHT);\r\nelse if (!(ac97->scaps & AC97_SCAP_CENTER_LFE_DAC))\r\n*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT1)|(1<<AC97_SLOT_SPDIF_RIGHT1);\r\nelse\r\n*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT2)|(1<<AC97_SLOT_SPDIF_RIGHT2);\r\n}\r\n*rate_table = 0;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nslots |= (1<<AC97_SLOT_PCM_SLEFT)|(1<<AC97_SLOT_PCM_SRIGHT);\r\nif (ac97->scaps & AC97_SCAP_SURROUND_DAC)\r\nslots |= (1<<AC97_SLOT_PCM_CENTER)|(1<<AC97_SLOT_LFE);\r\nif (ac97->ext_id & AC97_EI_SPDIF) {\r\nif (!(ac97->scaps & AC97_SCAP_SURROUND_DAC))\r\n*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT1)|(1<<AC97_SLOT_SPDIF_RIGHT1);\r\nelse\r\n*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT2)|(1<<AC97_SLOT_SPDIF_RIGHT2);\r\n}\r\n*rate_table = 1;\r\nbreak;\r\ncase 3:\r\nslots |= (1<<AC97_SLOT_PCM_CENTER)|(1<<AC97_SLOT_LFE);\r\nif (ac97->ext_id & AC97_EI_SPDIF)\r\n*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT2)|(1<<AC97_SLOT_SPDIF_RIGHT2);\r\n*rate_table = 2;\r\nbreak;\r\n}\r\nreturn slots;\r\n} else {\r\nunsigned short slots;\r\nslots = (1<<AC97_SLOT_PCM_LEFT)|(1<<AC97_SLOT_PCM_RIGHT);\r\nif (ac97->scaps & AC97_SCAP_SURROUND_DAC)\r\nslots |= (1<<AC97_SLOT_PCM_SLEFT)|(1<<AC97_SLOT_PCM_SRIGHT);\r\nif (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC)\r\nslots |= (1<<AC97_SLOT_PCM_CENTER)|(1<<AC97_SLOT_LFE);\r\nif (ac97->ext_id & AC97_EI_SPDIF) {\r\nif (!(ac97->scaps & AC97_SCAP_SURROUND_DAC))\r\n*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT)|(1<<AC97_SLOT_SPDIF_RIGHT);\r\nelse if (!(ac97->scaps & AC97_SCAP_CENTER_LFE_DAC))\r\n*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT1)|(1<<AC97_SLOT_SPDIF_RIGHT1);\r\nelse\r\n*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT2)|(1<<AC97_SLOT_SPDIF_RIGHT2);\r\n}\r\n*rate_table = 0;\r\nreturn slots;\r\n}\r\n}\r\nstatic unsigned short get_cslots(struct snd_ac97 *ac97)\r\n{\r\nunsigned short slots;\r\nif (!ac97_is_audio(ac97))\r\nreturn 0;\r\nslots = (1<<AC97_SLOT_PCM_LEFT)|(1<<AC97_SLOT_PCM_RIGHT);\r\nslots |= (1<<AC97_SLOT_MIC);\r\nreturn slots;\r\n}\r\nstatic unsigned int get_rates(struct ac97_pcm *pcm, unsigned int cidx, unsigned short slots, int dbl)\r\n{\r\nint i, idx;\r\nunsigned int rates = ~0;\r\nunsigned char reg;\r\nfor (i = 3; i < 12; i++) {\r\nif (!(slots & (1 << i)))\r\ncontinue;\r\nreg = get_slot_reg(pcm, cidx, i, dbl);\r\nswitch (reg) {\r\ncase AC97_PCM_FRONT_DAC_RATE: idx = AC97_RATES_FRONT_DAC; break;\r\ncase AC97_PCM_SURR_DAC_RATE: idx = AC97_RATES_SURR_DAC; break;\r\ncase AC97_PCM_LFE_DAC_RATE: idx = AC97_RATES_LFE_DAC; break;\r\ncase AC97_PCM_LR_ADC_RATE: idx = AC97_RATES_ADC; break;\r\ncase AC97_PCM_MIC_ADC_RATE: idx = AC97_RATES_MIC_ADC; break;\r\ndefault: idx = AC97_RATES_SPDIF; break;\r\n}\r\nrates &= pcm->r[dbl].codec[cidx]->rates[idx];\r\n}\r\nif (!dbl)\r\nrates &= ~(SNDRV_PCM_RATE_64000 | SNDRV_PCM_RATE_88200 |\r\nSNDRV_PCM_RATE_96000);\r\nreturn rates;\r\n}\r\nint snd_ac97_pcm_assign(struct snd_ac97_bus *bus,\r\nunsigned short pcms_count,\r\nconst struct ac97_pcm *pcms)\r\n{\r\nint i, j, k;\r\nconst struct ac97_pcm *pcm;\r\nstruct ac97_pcm *rpcms, *rpcm;\r\nunsigned short avail_slots[2][4];\r\nunsigned char rate_table[2][4];\r\nunsigned short tmp, slots;\r\nunsigned short spdif_slots[4];\r\nunsigned int rates;\r\nstruct snd_ac97 *codec;\r\nrpcms = kcalloc(pcms_count, sizeof(struct ac97_pcm), GFP_KERNEL);\r\nif (rpcms == NULL)\r\nreturn -ENOMEM;\r\nmemset(avail_slots, 0, sizeof(avail_slots));\r\nmemset(rate_table, 0, sizeof(rate_table));\r\nmemset(spdif_slots, 0, sizeof(spdif_slots));\r\nfor (i = 0; i < 4; i++) {\r\ncodec = bus->codec[i];\r\nif (!codec)\r\ncontinue;\r\navail_slots[0][i] = get_pslots(codec, &rate_table[0][i], &spdif_slots[i]);\r\navail_slots[1][i] = get_cslots(codec);\r\nif (!(codec->scaps & AC97_SCAP_INDEP_SDIN)) {\r\nfor (j = 0; j < i; j++) {\r\nif (bus->codec[j])\r\navail_slots[1][i] &= ~avail_slots[1][j];\r\n}\r\n}\r\n}\r\nfor (i = 0; i < pcms_count; i++) {\r\npcm = &pcms[i];\r\nrpcm = &rpcms[i];\r\nif (pcm->copy_flag) {\r\n*rpcm = *pcm;\r\ncontinue;\r\n}\r\nrpcm->stream = pcm->stream;\r\nrpcm->exclusive = pcm->exclusive;\r\nrpcm->spdif = pcm->spdif;\r\nrpcm->private_value = pcm->private_value;\r\nrpcm->bus = bus;\r\nrpcm->rates = ~0;\r\nslots = pcm->r[0].slots;\r\nfor (j = 0; j < 4 && slots; j++) {\r\nif (!bus->codec[j])\r\ncontinue;\r\nrates = ~0;\r\nif (pcm->spdif && pcm->stream == 0)\r\ntmp = spdif_slots[j];\r\nelse\r\ntmp = avail_slots[pcm->stream][j];\r\nif (pcm->exclusive) {\r\ntmp &= slots;\r\nfor (k = 0; k < i; k++) {\r\nif (rpcm->stream == rpcms[k].stream)\r\ntmp &= ~rpcms[k].r[0].rslots[j];\r\n}\r\n} else {\r\ntmp &= pcm->r[0].slots;\r\n}\r\nif (tmp) {\r\nrpcm->r[0].rslots[j] = tmp;\r\nrpcm->r[0].codec[j] = bus->codec[j];\r\nrpcm->r[0].rate_table[j] = rate_table[pcm->stream][j];\r\nif (bus->no_vra)\r\nrates = SNDRV_PCM_RATE_48000;\r\nelse\r\nrates = get_rates(rpcm, j, tmp, 0);\r\nif (pcm->exclusive)\r\navail_slots[pcm->stream][j] &= ~tmp;\r\n}\r\nslots &= ~tmp;\r\nrpcm->r[0].slots |= tmp;\r\nrpcm->rates &= rates;\r\n}\r\nif (pcm->stream == SNDRV_PCM_STREAM_PLAYBACK &&\r\nbus->codec[0] && (bus->codec[0]->flags & AC97_DOUBLE_RATE) &&\r\nrate_table[pcm->stream][0] == 0) {\r\ntmp = (1<<AC97_SLOT_PCM_LEFT) | (1<<AC97_SLOT_PCM_RIGHT) |\r\n(1<<AC97_SLOT_PCM_LEFT_0) | (1<<AC97_SLOT_PCM_RIGHT_0);\r\nif ((tmp & pcm->r[1].slots) == tmp) {\r\nrpcm->r[1].slots = tmp;\r\nrpcm->r[1].rslots[0] = tmp;\r\nrpcm->r[1].rate_table[0] = 0;\r\nrpcm->r[1].codec[0] = bus->codec[0];\r\nif (pcm->exclusive)\r\navail_slots[pcm->stream][0] &= ~tmp;\r\nif (bus->no_vra)\r\nrates = SNDRV_PCM_RATE_96000;\r\nelse\r\nrates = get_rates(rpcm, 0, tmp, 1);\r\nrpcm->rates |= rates;\r\n}\r\n}\r\nif (rpcm->rates == ~0)\r\nrpcm->rates = 0;\r\n}\r\nbus->pcms_count = pcms_count;\r\nbus->pcms = rpcms;\r\nreturn 0;\r\n}\r\nint snd_ac97_pcm_open(struct ac97_pcm *pcm, unsigned int rate,\r\nenum ac97_pcm_cfg cfg, unsigned short slots)\r\n{\r\nstruct snd_ac97_bus *bus;\r\nint i, cidx, r, ok_flag;\r\nunsigned int reg_ok[4] = {0,0,0,0};\r\nunsigned char reg;\r\nint err = 0;\r\nr = rate > 48000;\r\nbus = pcm->bus;\r\nif (cfg == AC97_PCM_CFG_SPDIF) {\r\nfor (cidx = 0; cidx < 4; cidx++)\r\nif (bus->codec[cidx] && (bus->codec[cidx]->ext_id & AC97_EI_SPDIF)) {\r\nerr = set_spdif_rate(bus->codec[cidx], rate);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nspin_lock_irq(&pcm->bus->bus_lock);\r\nfor (i = 3; i < 12; i++) {\r\nif (!(slots & (1 << i)))\r\ncontinue;\r\nok_flag = 0;\r\nfor (cidx = 0; cidx < 4; cidx++) {\r\nif (bus->used_slots[pcm->stream][cidx] & (1 << i)) {\r\nspin_unlock_irq(&pcm->bus->bus_lock);\r\nerr = -EBUSY;\r\ngoto error;\r\n}\r\nif (pcm->r[r].rslots[cidx] & (1 << i)) {\r\nbus->used_slots[pcm->stream][cidx] |= (1 << i);\r\nok_flag++;\r\n}\r\n}\r\nif (!ok_flag) {\r\nspin_unlock_irq(&pcm->bus->bus_lock);\r\nsnd_printk(KERN_ERR "cannot find configuration for AC97 slot %i\n", i);\r\nerr = -EAGAIN;\r\ngoto error;\r\n}\r\n}\r\npcm->cur_dbl = r;\r\nspin_unlock_irq(&pcm->bus->bus_lock);\r\nfor (i = 3; i < 12; i++) {\r\nif (!(slots & (1 << i)))\r\ncontinue;\r\nfor (cidx = 0; cidx < 4; cidx++) {\r\nif (pcm->r[r].rslots[cidx] & (1 << i)) {\r\nreg = get_slot_reg(pcm, cidx, i, r);\r\nif (reg == 0xff) {\r\nsnd_printk(KERN_ERR "invalid AC97 slot %i?\n", i);\r\ncontinue;\r\n}\r\nif (reg_ok[cidx] & (1 << (reg - AC97_PCM_FRONT_DAC_RATE)))\r\ncontinue;\r\nerr = snd_ac97_set_rate(pcm->r[r].codec[cidx], reg, rate);\r\nif (err < 0)\r\nsnd_printk(KERN_ERR "error in snd_ac97_set_rate: cidx=%d, reg=0x%x, rate=%d, err=%d\n", cidx, reg, rate, err);\r\nelse\r\nreg_ok[cidx] |= (1 << (reg - AC97_PCM_FRONT_DAC_RATE));\r\n}\r\n}\r\n}\r\npcm->aslots = slots;\r\nreturn 0;\r\nerror:\r\npcm->aslots = slots;\r\nsnd_ac97_pcm_close(pcm);\r\nreturn err;\r\n}\r\nint snd_ac97_pcm_close(struct ac97_pcm *pcm)\r\n{\r\nstruct snd_ac97_bus *bus;\r\nunsigned short slots = pcm->aslots;\r\nint i, cidx;\r\n#ifdef CONFIG_SND_AC97_POWER_SAVE\r\nint r = pcm->cur_dbl;\r\nfor (i = 3; i < 12; i++) {\r\nif (!(slots & (1 << i)))\r\ncontinue;\r\nfor (cidx = 0; cidx < 4; cidx++) {\r\nif (pcm->r[r].rslots[cidx] & (1 << i)) {\r\nint reg = get_slot_reg(pcm, cidx, i, r);\r\nsnd_ac97_update_power(pcm->r[r].codec[cidx],\r\nreg, 0);\r\n}\r\n}\r\n}\r\n#endif\r\nbus = pcm->bus;\r\nspin_lock_irq(&pcm->bus->bus_lock);\r\nfor (i = 3; i < 12; i++) {\r\nif (!(slots & (1 << i)))\r\ncontinue;\r\nfor (cidx = 0; cidx < 4; cidx++)\r\nbus->used_slots[pcm->stream][cidx] &= ~(1 << i);\r\n}\r\npcm->aslots = 0;\r\npcm->cur_dbl = 0;\r\nspin_unlock_irq(&pcm->bus->bus_lock);\r\nreturn 0;\r\n}\r\nstatic int double_rate_hw_constraint_rate(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval *channels = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nif (channels->min > 2) {\r\nstatic const struct snd_interval single_rates = {\r\n.min = 1,\r\n.max = 48000,\r\n};\r\nstruct snd_interval *rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nreturn snd_interval_refine(rate, &single_rates);\r\n}\r\nreturn 0;\r\n}\r\nstatic int double_rate_hw_constraint_channels(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval *rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nif (rate->min > 48000) {\r\nstatic const struct snd_interval double_rate_channels = {\r\n.min = 2,\r\n.max = 2,\r\n};\r\nstruct snd_interval *channels = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nreturn snd_interval_refine(channels, &double_rate_channels);\r\n}\r\nreturn 0;\r\n}\r\nint snd_ac97_pcm_double_rate_rules(struct snd_pcm_runtime *runtime)\r\n{\r\nint err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\ndouble_rate_hw_constraint_rate, NULL,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\ndouble_rate_hw_constraint_channels, NULL,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\nreturn err;\r\n}
