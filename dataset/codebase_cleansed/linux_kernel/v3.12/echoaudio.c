static int get_firmware(const struct firmware **fw_entry,\r\nstruct echoaudio *chip, const short fw_index)\r\n{\r\nint err;\r\nchar name[30];\r\n#ifdef CONFIG_PM_SLEEP\r\nif (chip->fw_cache[fw_index]) {\r\nDE_ACT(("firmware requested: %s is cached\n", card_fw[fw_index].data));\r\n*fw_entry = chip->fw_cache[fw_index];\r\nreturn 0;\r\n}\r\n#endif\r\nDE_ACT(("firmware requested: %s\n", card_fw[fw_index].data));\r\nsnprintf(name, sizeof(name), "ea/%s", card_fw[fw_index].data);\r\nerr = request_firmware(fw_entry, name, pci_device(chip));\r\nif (err < 0)\r\nsnd_printk(KERN_ERR "get_firmware(): Firmware not available (%d)\n", err);\r\n#ifdef CONFIG_PM_SLEEP\r\nelse\r\nchip->fw_cache[fw_index] = *fw_entry;\r\n#endif\r\nreturn err;\r\n}\r\nstatic void free_firmware(const struct firmware *fw_entry)\r\n{\r\n#ifdef CONFIG_PM_SLEEP\r\nDE_ACT(("firmware not released (kept in cache)\n"));\r\n#else\r\nrelease_firmware(fw_entry);\r\nDE_ACT(("firmware released\n"));\r\n#endif\r\n}\r\nstatic void free_firmware_cache(struct echoaudio *chip)\r\n{\r\n#ifdef CONFIG_PM_SLEEP\r\nint i;\r\nfor (i = 0; i < 8 ; i++)\r\nif (chip->fw_cache[i]) {\r\nrelease_firmware(chip->fw_cache[i]);\r\nDE_ACT(("release_firmware(%d)\n", i));\r\n}\r\nDE_ACT(("firmware_cache released\n"));\r\n#endif\r\n}\r\nstatic void audiopipe_free(struct snd_pcm_runtime *runtime)\r\n{\r\nstruct audiopipe *pipe = runtime->private_data;\r\nif (pipe->sgpage.area)\r\nsnd_dma_free_pages(&pipe->sgpage);\r\nkfree(pipe);\r\n}\r\nstatic int hw_rule_capture_format_by_channels(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval *c = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\r\nstruct snd_mask fmt;\r\nsnd_mask_any(&fmt);\r\n#ifndef ECHOCARD_HAS_STEREO_BIG_ENDIAN32\r\nif (c->min == 2) {\r\nfmt.bits[0] &= ~SNDRV_PCM_FMTBIT_S32_BE;\r\nreturn snd_mask_refine(f, &fmt);\r\n}\r\n#endif\r\nif (c->min > 2) {\r\nfmt.bits[0] &= ~(SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S32_BE);\r\nreturn snd_mask_refine(f, &fmt);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hw_rule_capture_channels_by_format(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval *c = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\r\nstruct snd_interval ch;\r\nsnd_interval_any(&ch);\r\nif (f->bits[0] == SNDRV_PCM_FMTBIT_S32_BE) {\r\nch.min = 1;\r\n#ifdef ECHOCARD_HAS_STEREO_BIG_ENDIAN32\r\nch.max = 2;\r\n#else\r\nch.max = 1;\r\n#endif\r\nch.integer = 1;\r\nreturn snd_interval_refine(c, &ch);\r\n}\r\nif (f->bits[0] == SNDRV_PCM_FMTBIT_U8) {\r\nch.min = 1;\r\nch.max = 2;\r\nch.integer = 1;\r\nreturn snd_interval_refine(c, &ch);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hw_rule_playback_format_by_channels(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval *c = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\r\nstruct snd_mask fmt;\r\nu64 fmask;\r\nsnd_mask_any(&fmt);\r\nfmask = fmt.bits[0] + ((u64)fmt.bits[1] << 32);\r\nif (c->min > 2) {\r\nfmask &= SNDRV_PCM_FMTBIT_S16_LE |\r\nSNDRV_PCM_FMTBIT_S24_3LE |\r\nSNDRV_PCM_FMTBIT_S32_LE;\r\n} else if (c->max == 1)\r\nfmask &= SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S32_BE;\r\n#ifndef ECHOCARD_HAS_STEREO_BIG_ENDIAN32\r\nelse if (c->min == 2 && c->max == 2)\r\nfmask &= ~SNDRV_PCM_FMTBIT_S32_BE;\r\n#endif\r\nelse\r\nreturn 0;\r\nfmt.bits[0] &= (u32)fmask;\r\nfmt.bits[1] &= (u32)(fmask >> 32);\r\nreturn snd_mask_refine(f, &fmt);\r\n}\r\nstatic int hw_rule_playback_channels_by_format(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval *c = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\r\nstruct snd_interval ch;\r\nu64 fmask;\r\nsnd_interval_any(&ch);\r\nch.integer = 1;\r\nfmask = f->bits[0] + ((u64)f->bits[1] << 32);\r\nif (fmask == SNDRV_PCM_FMTBIT_S32_BE) {\r\nch.min = 1;\r\n#ifdef ECHOCARD_HAS_STEREO_BIG_ENDIAN32\r\nch.max = 2;\r\n#else\r\nch.max = 1;\r\n#endif\r\n} else if (fmask == SNDRV_PCM_FMTBIT_U8)\r\nch.min = ch.max = 2;\r\nelse if (!(fmask & ~(SNDRV_PCM_FMTBIT_S16_LE |\r\nSNDRV_PCM_FMTBIT_S24_3LE)))\r\nch.min = 2;\r\nelse\r\nreturn 0;\r\nreturn snd_interval_refine(c, &ch);\r\n}\r\nstatic int hw_rule_sample_rate(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval *rate = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_RATE);\r\nstruct echoaudio *chip = rule->private;\r\nstruct snd_interval fixed;\r\nif (!chip->can_set_rate) {\r\nsnd_interval_any(&fixed);\r\nfixed.min = fixed.max = chip->sample_rate;\r\nreturn snd_interval_refine(rate, &fixed);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcm_open(struct snd_pcm_substream *substream,\r\nsigned char max_channels)\r\n{\r\nstruct echoaudio *chip;\r\nstruct snd_pcm_runtime *runtime;\r\nstruct audiopipe *pipe;\r\nint err, i;\r\nif (max_channels <= 0)\r\nreturn -EAGAIN;\r\nchip = snd_pcm_substream_chip(substream);\r\nruntime = substream->runtime;\r\npipe = kzalloc(sizeof(struct audiopipe), GFP_KERNEL);\r\nif (!pipe)\r\nreturn -ENOMEM;\r\npipe->index = -1;\r\nmemcpy(&pipe->hw, &pcm_hardware_skel, sizeof(struct snd_pcm_hardware));\r\nDE_HWP(("max_channels=%d\n", max_channels));\r\npipe->constr.list = channels_list;\r\npipe->constr.mask = 0;\r\nfor (i = 0; channels_list[i] <= max_channels; i++);\r\npipe->constr.count = i;\r\nif (pipe->hw.channels_max > max_channels)\r\npipe->hw.channels_max = max_channels;\r\nif (chip->digital_mode == DIGITAL_MODE_ADAT) {\r\npipe->hw.rate_max = 48000;\r\npipe->hw.rates &= SNDRV_PCM_RATE_8000_48000;\r\n}\r\nruntime->hw = pipe->hw;\r\nruntime->private_data = pipe;\r\nruntime->private_free = audiopipe_free;\r\nsnd_pcm_set_sync(substream);\r\nif ((err = snd_pcm_hw_constraint_list(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\n&pipe->constr)) < 0)\r\nreturn err;\r\nif ((err = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS)) < 0)\r\nreturn err;\r\nif ((err = snd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_SIZE,\r\n32)) < 0)\r\nreturn err;\r\nif ((err = snd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_BUFFER_SIZE,\r\n32)) < 0)\r\nreturn err;\r\nif ((err = snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\nhw_rule_sample_rate, chip,\r\nSNDRV_PCM_HW_PARAM_RATE, -1)) < 0)\r\nreturn err;\r\nif ((err = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci),\r\nPAGE_SIZE, &pipe->sgpage)) < 0) {\r\nDE_HWP(("s-g list allocation failed\n"));\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcm_analog_in_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct echoaudio *chip = snd_pcm_substream_chip(substream);\r\nint err;\r\nDE_ACT(("pcm_analog_in_open\n"));\r\nif ((err = pcm_open(substream, num_analog_busses_in(chip) -\r\nsubstream->number)) < 0)\r\nreturn err;\r\nif ((err = snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\nhw_rule_capture_channels_by_format, NULL,\r\nSNDRV_PCM_HW_PARAM_FORMAT, -1)) < 0)\r\nreturn err;\r\nif ((err = snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_FORMAT,\r\nhw_rule_capture_format_by_channels, NULL,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1)) < 0)\r\nreturn err;\r\natomic_inc(&chip->opencount);\r\nif (atomic_read(&chip->opencount) > 1 && chip->rate_set)\r\nchip->can_set_rate=0;\r\nDE_HWP(("pcm_analog_in_open cs=%d oc=%d r=%d\n",\r\nchip->can_set_rate, atomic_read(&chip->opencount),\r\nchip->sample_rate));\r\nreturn 0;\r\n}\r\nstatic int pcm_analog_out_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct echoaudio *chip = snd_pcm_substream_chip(substream);\r\nint max_channels, err;\r\n#ifdef ECHOCARD_HAS_VMIXER\r\nmax_channels = num_pipes_out(chip);\r\n#else\r\nmax_channels = num_analog_busses_out(chip);\r\n#endif\r\nDE_ACT(("pcm_analog_out_open\n"));\r\nif ((err = pcm_open(substream, max_channels - substream->number)) < 0)\r\nreturn err;\r\nif ((err = snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\nhw_rule_playback_channels_by_format,\r\nNULL,\r\nSNDRV_PCM_HW_PARAM_FORMAT, -1)) < 0)\r\nreturn err;\r\nif ((err = snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_FORMAT,\r\nhw_rule_playback_format_by_channels,\r\nNULL,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1)) < 0)\r\nreturn err;\r\natomic_inc(&chip->opencount);\r\nif (atomic_read(&chip->opencount) > 1 && chip->rate_set)\r\nchip->can_set_rate=0;\r\nDE_HWP(("pcm_analog_out_open cs=%d oc=%d r=%d\n",\r\nchip->can_set_rate, atomic_read(&chip->opencount),\r\nchip->sample_rate));\r\nreturn 0;\r\n}\r\nstatic int pcm_digital_in_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct echoaudio *chip = snd_pcm_substream_chip(substream);\r\nint err, max_channels;\r\nDE_ACT(("pcm_digital_in_open\n"));\r\nmax_channels = num_digital_busses_in(chip) - substream->number;\r\nmutex_lock(&chip->mode_mutex);\r\nif (chip->digital_mode == DIGITAL_MODE_ADAT)\r\nerr = pcm_open(substream, max_channels);\r\nelse\r\nerr = pcm_open(substream, max_channels - ECHOCARD_HAS_ADAT);\r\nif (err < 0)\r\ngoto din_exit;\r\nif ((err = snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\nhw_rule_capture_channels_by_format, NULL,\r\nSNDRV_PCM_HW_PARAM_FORMAT, -1)) < 0)\r\ngoto din_exit;\r\nif ((err = snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_FORMAT,\r\nhw_rule_capture_format_by_channels, NULL,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1)) < 0)\r\ngoto din_exit;\r\natomic_inc(&chip->opencount);\r\nif (atomic_read(&chip->opencount) > 1 && chip->rate_set)\r\nchip->can_set_rate=0;\r\ndin_exit:\r\nmutex_unlock(&chip->mode_mutex);\r\nreturn err;\r\n}\r\nstatic int pcm_digital_out_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct echoaudio *chip = snd_pcm_substream_chip(substream);\r\nint err, max_channels;\r\nDE_ACT(("pcm_digital_out_open\n"));\r\nmax_channels = num_digital_busses_out(chip) - substream->number;\r\nmutex_lock(&chip->mode_mutex);\r\nif (chip->digital_mode == DIGITAL_MODE_ADAT)\r\nerr = pcm_open(substream, max_channels);\r\nelse\r\nerr = pcm_open(substream, max_channels - ECHOCARD_HAS_ADAT);\r\nif (err < 0)\r\ngoto dout_exit;\r\nif ((err = snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\nhw_rule_playback_channels_by_format,\r\nNULL, SNDRV_PCM_HW_PARAM_FORMAT,\r\n-1)) < 0)\r\ngoto dout_exit;\r\nif ((err = snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_FORMAT,\r\nhw_rule_playback_format_by_channels,\r\nNULL, SNDRV_PCM_HW_PARAM_CHANNELS,\r\n-1)) < 0)\r\ngoto dout_exit;\r\natomic_inc(&chip->opencount);\r\nif (atomic_read(&chip->opencount) > 1 && chip->rate_set)\r\nchip->can_set_rate=0;\r\ndout_exit:\r\nmutex_unlock(&chip->mode_mutex);\r\nreturn err;\r\n}\r\nstatic int pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct echoaudio *chip = snd_pcm_substream_chip(substream);\r\nint oc;\r\nDE_ACT(("pcm_close\n"));\r\natomic_dec(&chip->opencount);\r\noc = atomic_read(&chip->opencount);\r\nDE_ACT(("pcm_close oc=%d cs=%d rs=%d\n", oc,\r\nchip->can_set_rate, chip->rate_set));\r\nif (oc < 2)\r\nchip->can_set_rate = 1;\r\nif (oc == 0)\r\nchip->rate_set = 0;\r\nDE_ACT(("pcm_close2 oc=%d cs=%d rs=%d\n", oc,\r\nchip->can_set_rate,chip->rate_set));\r\nreturn 0;\r\n}\r\nstatic int init_engine(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params,\r\nint pipe_index, int interleave)\r\n{\r\nstruct echoaudio *chip;\r\nint err, per, rest, page, edge, offs;\r\nstruct audiopipe *pipe;\r\nchip = snd_pcm_substream_chip(substream);\r\npipe = (struct audiopipe *) substream->runtime->private_data;\r\nspin_lock_irq(&chip->lock);\r\nif (pipe->index >= 0) {\r\nDE_HWP(("hwp_ie free(%d)\n", pipe->index));\r\nerr = free_pipes(chip, pipe);\r\nsnd_BUG_ON(err);\r\nchip->substream[pipe->index] = NULL;\r\n}\r\nerr = allocate_pipes(chip, pipe, pipe_index, interleave);\r\nif (err < 0) {\r\nspin_unlock_irq(&chip->lock);\r\nDE_ACT((KERN_NOTICE "allocate_pipes(%d) err=%d\n",\r\npipe_index, err));\r\nreturn err;\r\n}\r\nspin_unlock_irq(&chip->lock);\r\nDE_ACT((KERN_NOTICE "allocate_pipes()=%d\n", pipe_index));\r\nDE_HWP(("pcm_hw_params (bufsize=%dB periods=%d persize=%dB)\n",\r\nparams_buffer_bytes(hw_params), params_periods(hw_params),\r\nparams_period_bytes(hw_params)));\r\nerr = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "malloc_pages err=%d\n", err);\r\nspin_lock_irq(&chip->lock);\r\nfree_pipes(chip, pipe);\r\nspin_unlock_irq(&chip->lock);\r\npipe->index = -1;\r\nreturn err;\r\n}\r\nsglist_init(chip, pipe);\r\nedge = PAGE_SIZE;\r\nfor (offs = page = per = 0; offs < params_buffer_bytes(hw_params);\r\nper++) {\r\nrest = params_period_bytes(hw_params);\r\nif (offs + rest > params_buffer_bytes(hw_params))\r\nrest = params_buffer_bytes(hw_params) - offs;\r\nwhile (rest) {\r\ndma_addr_t addr;\r\naddr = snd_pcm_sgbuf_get_addr(substream, offs);\r\nif (rest <= edge - offs) {\r\nsglist_add_mapping(chip, pipe, addr, rest);\r\nsglist_add_irq(chip, pipe);\r\noffs += rest;\r\nrest = 0;\r\n} else {\r\nsglist_add_mapping(chip, pipe, addr,\r\nedge - offs);\r\nrest -= edge - offs;\r\noffs = edge;\r\n}\r\nif (offs == edge) {\r\nedge += PAGE_SIZE;\r\npage++;\r\n}\r\n}\r\n}\r\nsglist_wrap(chip, pipe);\r\nchip->last_period[pipe_index] = 0;\r\npipe->last_counter = 0;\r\npipe->position = 0;\r\nsmp_wmb();\r\nchip->substream[pipe_index] = substream;\r\nchip->rate_set = 1;\r\nspin_lock_irq(&chip->lock);\r\nset_sample_rate(chip, hw_params->rate_num / hw_params->rate_den);\r\nspin_unlock_irq(&chip->lock);\r\nDE_HWP(("pcm_hw_params ok\n"));\r\nreturn 0;\r\n}\r\nstatic int pcm_analog_in_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct echoaudio *chip = snd_pcm_substream_chip(substream);\r\nreturn init_engine(substream, hw_params, px_analog_in(chip) +\r\nsubstream->number, params_channels(hw_params));\r\n}\r\nstatic int pcm_analog_out_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn init_engine(substream, hw_params, substream->number,\r\nparams_channels(hw_params));\r\n}\r\nstatic int pcm_digital_in_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct echoaudio *chip = snd_pcm_substream_chip(substream);\r\nreturn init_engine(substream, hw_params, px_digital_in(chip) +\r\nsubstream->number, params_channels(hw_params));\r\n}\r\nstatic int pcm_digital_out_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct echoaudio *chip = snd_pcm_substream_chip(substream);\r\nreturn init_engine(substream, hw_params, px_digital_out(chip) +\r\nsubstream->number, params_channels(hw_params));\r\n}\r\nstatic int pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct echoaudio *chip;\r\nstruct audiopipe *pipe;\r\nchip = snd_pcm_substream_chip(substream);\r\npipe = (struct audiopipe *) substream->runtime->private_data;\r\nspin_lock_irq(&chip->lock);\r\nif (pipe->index >= 0) {\r\nDE_HWP(("pcm_hw_free(%d)\n", pipe->index));\r\nfree_pipes(chip, pipe);\r\nchip->substream[pipe->index] = NULL;\r\npipe->index = -1;\r\n}\r\nspin_unlock_irq(&chip->lock);\r\nDE_HWP(("pcm_hw_freed\n"));\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic int pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct echoaudio *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct audioformat format;\r\nint pipe_index = ((struct audiopipe *)runtime->private_data)->index;\r\nDE_HWP(("Prepare rate=%d format=%d channels=%d\n",\r\nruntime->rate, runtime->format, runtime->channels));\r\nformat.interleave = runtime->channels;\r\nformat.data_are_bigendian = 0;\r\nformat.mono_to_stereo = 0;\r\nswitch (runtime->format) {\r\ncase SNDRV_PCM_FORMAT_U8:\r\nformat.bits_per_sample = 8;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nformat.bits_per_sample = 16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_3LE:\r\nformat.bits_per_sample = 24;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_BE:\r\nformat.data_are_bigendian = 1;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nformat.bits_per_sample = 32;\r\nbreak;\r\ndefault:\r\nDE_HWP(("Prepare error: unsupported format %d\n",\r\nruntime->format));\r\nreturn -EINVAL;\r\n}\r\nif (snd_BUG_ON(pipe_index >= px_num(chip)))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(!is_pipe_allocated(chip, pipe_index)))\r\nreturn -EINVAL;\r\nset_audio_format(chip, pipe_index, &format);\r\nreturn 0;\r\n}\r\nstatic int pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct echoaudio *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct audiopipe *pipe = runtime->private_data;\r\nint i, err;\r\nu32 channelmask = 0;\r\nstruct snd_pcm_substream *s;\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nfor (i = 0; i < DSP_MAXPIPES; i++) {\r\nif (s == chip->substream[i]) {\r\nchannelmask |= 1 << i;\r\nsnd_pcm_trigger_done(s, substream);\r\n}\r\n}\r\n}\r\nspin_lock(&chip->lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nDE_ACT(("pcm_trigger resume\n"));\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nDE_ACT(("pcm_trigger start\n"));\r\nfor (i = 0; i < DSP_MAXPIPES; i++) {\r\nif (channelmask & (1 << i)) {\r\npipe = chip->substream[i]->runtime->private_data;\r\nswitch (pipe->state) {\r\ncase PIPE_STATE_STOPPED:\r\nchip->last_period[i] = 0;\r\npipe->last_counter = 0;\r\npipe->position = 0;\r\n*pipe->dma_counter = 0;\r\ncase PIPE_STATE_PAUSED:\r\npipe->state = PIPE_STATE_STARTED;\r\nbreak;\r\ncase PIPE_STATE_STARTED:\r\nbreak;\r\n}\r\n}\r\n}\r\nerr = start_transport(chip, channelmask,\r\nchip->pipe_cyclic_mask);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nDE_ACT(("pcm_trigger suspend\n"));\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nDE_ACT(("pcm_trigger stop\n"));\r\nfor (i = 0; i < DSP_MAXPIPES; i++) {\r\nif (channelmask & (1 << i)) {\r\npipe = chip->substream[i]->runtime->private_data;\r\npipe->state = PIPE_STATE_STOPPED;\r\n}\r\n}\r\nerr = stop_transport(chip, channelmask);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nDE_ACT(("pcm_trigger pause\n"));\r\nfor (i = 0; i < DSP_MAXPIPES; i++) {\r\nif (channelmask & (1 << i)) {\r\npipe = chip->substream[i]->runtime->private_data;\r\npipe->state = PIPE_STATE_PAUSED;\r\n}\r\n}\r\nerr = pause_transport(chip, channelmask);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nspin_unlock(&chip->lock);\r\nreturn err;\r\n}\r\nstatic snd_pcm_uframes_t pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct audiopipe *pipe = runtime->private_data;\r\nsize_t cnt, bufsize, pos;\r\ncnt = le32_to_cpu(*pipe->dma_counter);\r\npipe->position += cnt - pipe->last_counter;\r\npipe->last_counter = cnt;\r\nbufsize = substream->runtime->buffer_size;\r\npos = bytes_to_frames(substream->runtime, pipe->position);\r\nwhile (pos >= bufsize) {\r\npipe->position -= frames_to_bytes(substream->runtime, bufsize);\r\npos -= bufsize;\r\n}\r\nreturn pos;\r\n}\r\nstatic int snd_echo_preallocate_pages(struct snd_pcm *pcm, struct device *dev)\r\n{\r\nstruct snd_pcm_substream *ss;\r\nint stream, err;\r\nfor (stream = 0; stream < 2; stream++)\r\nfor (ss = pcm->streams[stream].substream; ss; ss = ss->next) {\r\nerr = snd_pcm_lib_preallocate_pages(ss, SNDRV_DMA_TYPE_DEV_SG,\r\ndev,\r\nss->number ? 0 : 128<<10,\r\n256<<10);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_echo_new_pcm(struct echoaudio *chip)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\n#ifdef ECHOCARD_HAS_VMIXER\r\nif ((err = snd_pcm_new(chip->card, "PCM", 0, num_pipes_out(chip),\r\nnum_analog_busses_in(chip), &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\nchip->analog_pcm = pcm;\r\nstrcpy(pcm->name, chip->card->shortname);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &analog_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &analog_capture_ops);\r\nif ((err = snd_echo_preallocate_pages(pcm, snd_dma_pci_data(chip->pci))) < 0)\r\nreturn err;\r\nDE_INIT(("Analog PCM ok\n"));\r\n#ifdef ECHOCARD_HAS_DIGITAL_IO\r\nif ((err = snd_pcm_new(chip->card, "Digital PCM", 1, 0,\r\nnum_digital_busses_in(chip), &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\nchip->digital_pcm = pcm;\r\nstrcpy(pcm->name, chip->card->shortname);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &digital_capture_ops);\r\nif ((err = snd_echo_preallocate_pages(pcm, snd_dma_pci_data(chip->pci))) < 0)\r\nreturn err;\r\nDE_INIT(("Digital PCM ok\n"));\r\n#endif\r\n#else\r\nif ((err = snd_pcm_new(chip->card, "Analog PCM", 0,\r\nnum_analog_busses_out(chip),\r\nnum_analog_busses_in(chip), &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\nchip->analog_pcm = pcm;\r\nstrcpy(pcm->name, chip->card->shortname);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &analog_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &analog_capture_ops);\r\nif ((err = snd_echo_preallocate_pages(pcm, snd_dma_pci_data(chip->pci))) < 0)\r\nreturn err;\r\nDE_INIT(("Analog PCM ok\n"));\r\n#ifdef ECHOCARD_HAS_DIGITAL_IO\r\nif ((err = snd_pcm_new(chip->card, "Digital PCM", 1,\r\nnum_digital_busses_out(chip),\r\nnum_digital_busses_in(chip), &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\nchip->digital_pcm = pcm;\r\nstrcpy(pcm->name, chip->card->shortname);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &digital_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &digital_capture_ops);\r\nif ((err = snd_echo_preallocate_pages(pcm, snd_dma_pci_data(chip->pci))) < 0)\r\nreturn err;\r\nDE_INIT(("Digital PCM ok\n"));\r\n#endif\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_echo_output_gain_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct echoaudio *chip;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = num_busses_out(chip);\r\nuinfo->value.integer.min = ECHOGAIN_MINOUT;\r\nuinfo->value.integer.max = ECHOGAIN_MAXOUT;\r\nreturn 0;\r\n}\r\nstatic int snd_echo_output_gain_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nint c;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nfor (c = 0; c < num_busses_out(chip); c++)\r\nucontrol->value.integer.value[c] = chip->output_gain[c];\r\nreturn 0;\r\n}\r\nstatic int snd_echo_output_gain_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nint c, changed, gain;\r\nchanged = 0;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&chip->lock);\r\nfor (c = 0; c < num_busses_out(chip); c++) {\r\ngain = ucontrol->value.integer.value[c];\r\nif (gain < ECHOGAIN_MINOUT || gain > ECHOGAIN_MAXOUT)\r\ncontinue;\r\nif (chip->output_gain[c] != gain) {\r\nset_output_gain(chip, c, gain);\r\nchanged = 1;\r\n}\r\n}\r\nif (changed)\r\nupdate_output_line_level(chip);\r\nspin_unlock_irq(&chip->lock);\r\nreturn changed;\r\n}\r\nstatic int snd_echo_input_gain_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct echoaudio *chip;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = num_analog_busses_in(chip);\r\nuinfo->value.integer.min = ECHOGAIN_MININP;\r\nuinfo->value.integer.max = ECHOGAIN_MAXINP;\r\nreturn 0;\r\n}\r\nstatic int snd_echo_input_gain_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nint c;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nfor (c = 0; c < num_analog_busses_in(chip); c++)\r\nucontrol->value.integer.value[c] = chip->input_gain[c];\r\nreturn 0;\r\n}\r\nstatic int snd_echo_input_gain_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nint c, gain, changed;\r\nchanged = 0;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&chip->lock);\r\nfor (c = 0; c < num_analog_busses_in(chip); c++) {\r\ngain = ucontrol->value.integer.value[c];\r\nif (gain < ECHOGAIN_MININP || gain > ECHOGAIN_MAXINP)\r\ncontinue;\r\nif (chip->input_gain[c] != gain) {\r\nset_input_gain(chip, c, gain);\r\nchanged = 1;\r\n}\r\n}\r\nif (changed)\r\nupdate_input_line_level(chip);\r\nspin_unlock_irq(&chip->lock);\r\nreturn changed;\r\n}\r\nstatic int snd_echo_output_nominal_info (struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct echoaudio *chip;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = num_analog_busses_out(chip);\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_echo_output_nominal_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nint c;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nfor (c = 0; c < num_analog_busses_out(chip); c++)\r\nucontrol->value.integer.value[c] = chip->nominal_level[c];\r\nreturn 0;\r\n}\r\nstatic int snd_echo_output_nominal_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nint c, changed;\r\nchanged = 0;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&chip->lock);\r\nfor (c = 0; c < num_analog_busses_out(chip); c++) {\r\nif (chip->nominal_level[c] != ucontrol->value.integer.value[c]) {\r\nset_nominal_level(chip, c,\r\nucontrol->value.integer.value[c]);\r\nchanged = 1;\r\n}\r\n}\r\nif (changed)\r\nupdate_output_line_level(chip);\r\nspin_unlock_irq(&chip->lock);\r\nreturn changed;\r\n}\r\nstatic int snd_echo_input_nominal_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct echoaudio *chip;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = num_analog_busses_in(chip);\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_echo_input_nominal_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nint c;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nfor (c = 0; c < num_analog_busses_in(chip); c++)\r\nucontrol->value.integer.value[c] =\r\nchip->nominal_level[bx_analog_in(chip) + c];\r\nreturn 0;\r\n}\r\nstatic int snd_echo_input_nominal_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nint c, changed;\r\nchanged = 0;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&chip->lock);\r\nfor (c = 0; c < num_analog_busses_in(chip); c++) {\r\nif (chip->nominal_level[bx_analog_in(chip) + c] !=\r\nucontrol->value.integer.value[c]) {\r\nset_nominal_level(chip, bx_analog_in(chip) + c,\r\nucontrol->value.integer.value[c]);\r\nchanged = 1;\r\n}\r\n}\r\nif (changed)\r\nupdate_output_line_level(chip);\r\nspin_unlock_irq(&chip->lock);\r\nreturn changed;\r\n}\r\nstatic int snd_echo_mixer_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct echoaudio *chip;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = ECHOGAIN_MINOUT;\r\nuinfo->value.integer.max = ECHOGAIN_MAXOUT;\r\nuinfo->dimen.d[0] = num_busses_out(chip);\r\nuinfo->dimen.d[1] = num_busses_in(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_echo_mixer_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] =\r\nchip->monitor_gain[ucontrol->id.index / num_busses_in(chip)]\r\n[ucontrol->id.index % num_busses_in(chip)];\r\nreturn 0;\r\n}\r\nstatic int snd_echo_mixer_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nint changed, gain;\r\nshort out, in;\r\nchanged = 0;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nout = ucontrol->id.index / num_busses_in(chip);\r\nin = ucontrol->id.index % num_busses_in(chip);\r\ngain = ucontrol->value.integer.value[0];\r\nif (gain < ECHOGAIN_MINOUT || gain > ECHOGAIN_MAXOUT)\r\nreturn -EINVAL;\r\nif (chip->monitor_gain[out][in] != gain) {\r\nspin_lock_irq(&chip->lock);\r\nset_monitor_gain(chip, out, in, gain);\r\nupdate_output_line_level(chip);\r\nspin_unlock_irq(&chip->lock);\r\nchanged = 1;\r\n}\r\nreturn changed;\r\n}\r\nstatic int snd_echo_vmixer_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct echoaudio *chip;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = ECHOGAIN_MINOUT;\r\nuinfo->value.integer.max = ECHOGAIN_MAXOUT;\r\nuinfo->dimen.d[0] = num_busses_out(chip);\r\nuinfo->dimen.d[1] = num_pipes_out(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_echo_vmixer_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] =\r\nchip->vmixer_gain[ucontrol->id.index / num_pipes_out(chip)]\r\n[ucontrol->id.index % num_pipes_out(chip)];\r\nreturn 0;\r\n}\r\nstatic int snd_echo_vmixer_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nint gain, changed;\r\nshort vch, out;\r\nchanged = 0;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nout = ucontrol->id.index / num_pipes_out(chip);\r\nvch = ucontrol->id.index % num_pipes_out(chip);\r\ngain = ucontrol->value.integer.value[0];\r\nif (gain < ECHOGAIN_MINOUT || gain > ECHOGAIN_MAXOUT)\r\nreturn -EINVAL;\r\nif (chip->vmixer_gain[out][vch] != ucontrol->value.integer.value[0]) {\r\nspin_lock_irq(&chip->lock);\r\nset_vmixer_gain(chip, out, vch, ucontrol->value.integer.value[0]);\r\nupdate_vmixer_level(chip);\r\nspin_unlock_irq(&chip->lock);\r\nchanged = 1;\r\n}\r\nreturn changed;\r\n}\r\nstatic int snd_echo_digital_mode_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *names[4] = {\r\n"S/PDIF Coaxial", "S/PDIF Optical", "ADAT Optical",\r\n"S/PDIF Cdrom"\r\n};\r\nstruct echoaudio *chip;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->value.enumerated.items = chip->num_digital_modes;\r\nuinfo->count = 1;\r\nif (uinfo->value.enumerated.item >= chip->num_digital_modes)\r\nuinfo->value.enumerated.item = chip->num_digital_modes - 1;\r\nstrcpy(uinfo->value.enumerated.name, names[\r\nchip->digital_mode_list[uinfo->value.enumerated.item]]);\r\nreturn 0;\r\n}\r\nstatic int snd_echo_digital_mode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nint i, mode;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nmode = chip->digital_mode;\r\nfor (i = chip->num_digital_modes - 1; i >= 0; i--)\r\nif (mode == chip->digital_mode_list[i]) {\r\nucontrol->value.enumerated.item[0] = i;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_echo_digital_mode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nint changed;\r\nunsigned short emode, dmode;\r\nchanged = 0;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nemode = ucontrol->value.enumerated.item[0];\r\nif (emode >= chip->num_digital_modes)\r\nreturn -EINVAL;\r\ndmode = chip->digital_mode_list[emode];\r\nif (dmode != chip->digital_mode) {\r\nmutex_lock(&chip->mode_mutex);\r\nif (atomic_read(&chip->opencount)) {\r\nchanged = -EAGAIN;\r\n} else {\r\nchanged = set_digital_mode(chip, dmode);\r\nif (changed > 0 && chip->clock_src_ctl) {\r\nsnd_ctl_notify(chip->card,\r\nSNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->clock_src_ctl->id);\r\nDE_ACT(("SDM() =%d\n", changed));\r\n}\r\nif (changed >= 0)\r\nchanged = 1;\r\n}\r\nmutex_unlock(&chip->mode_mutex);\r\n}\r\nreturn changed;\r\n}\r\nstatic int snd_echo_spdif_mode_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *names[2] = {"Consumer", "Professional"};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->value.enumerated.items = 2;\r\nuinfo->count = 1;\r\nif (uinfo->value.enumerated.item)\r\nuinfo->value.enumerated.item = 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\nnames[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_echo_spdif_mode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = !!chip->professional_spdif;\r\nreturn 0;\r\n}\r\nstatic int snd_echo_spdif_mode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nint mode;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nmode = !!ucontrol->value.enumerated.item[0];\r\nif (mode != chip->professional_spdif) {\r\nspin_lock_irq(&chip->lock);\r\nset_professional_spdif(chip, mode);\r\nspin_unlock_irq(&chip->lock);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_echo_clock_source_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *names[8] = {\r\n"Internal", "Word", "Super", "S/PDIF", "ADAT", "ESync",\r\n"ESync96", "MTC"\r\n};\r\nstruct echoaudio *chip;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->value.enumerated.items = chip->num_clock_sources;\r\nuinfo->count = 1;\r\nif (uinfo->value.enumerated.item >= chip->num_clock_sources)\r\nuinfo->value.enumerated.item = chip->num_clock_sources - 1;\r\nstrcpy(uinfo->value.enumerated.name, names[\r\nchip->clock_source_list[uinfo->value.enumerated.item]]);\r\nreturn 0;\r\n}\r\nstatic int snd_echo_clock_source_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nint i, clock;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nclock = chip->input_clock;\r\nfor (i = 0; i < chip->num_clock_sources; i++)\r\nif (clock == chip->clock_source_list[i])\r\nucontrol->value.enumerated.item[0] = i;\r\nreturn 0;\r\n}\r\nstatic int snd_echo_clock_source_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nint changed;\r\nunsigned int eclock, dclock;\r\nchanged = 0;\r\nchip = snd_kcontrol_chip(kcontrol);\r\neclock = ucontrol->value.enumerated.item[0];\r\nif (eclock >= chip->input_clock_types)\r\nreturn -EINVAL;\r\ndclock = chip->clock_source_list[eclock];\r\nif (chip->input_clock != dclock) {\r\nmutex_lock(&chip->mode_mutex);\r\nspin_lock_irq(&chip->lock);\r\nif ((changed = set_input_clock(chip, dclock)) == 0)\r\nchanged = 1;\r\nspin_unlock_irq(&chip->lock);\r\nmutex_unlock(&chip->mode_mutex);\r\n}\r\nif (changed < 0)\r\nDE_ACT(("seticlk val%d err 0x%x\n", dclock, changed));\r\nreturn changed;\r\n}\r\nstatic int snd_echo_phantom_power_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = chip->phantom_power;\r\nreturn 0;\r\n}\r\nstatic int snd_echo_phantom_power_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip = snd_kcontrol_chip(kcontrol);\r\nint power, changed = 0;\r\npower = !!ucontrol->value.integer.value[0];\r\nif (chip->phantom_power != power) {\r\nspin_lock_irq(&chip->lock);\r\nchanged = set_phantom_power(chip, power);\r\nspin_unlock_irq(&chip->lock);\r\nif (changed == 0)\r\nchanged = 1;\r\n}\r\nreturn changed;\r\n}\r\nstatic int snd_echo_automute_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = chip->digital_in_automute;\r\nreturn 0;\r\n}\r\nstatic int snd_echo_automute_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip = snd_kcontrol_chip(kcontrol);\r\nint automute, changed = 0;\r\nautomute = !!ucontrol->value.integer.value[0];\r\nif (chip->digital_in_automute != automute) {\r\nspin_lock_irq(&chip->lock);\r\nchanged = set_input_auto_mute(chip, automute);\r\nspin_unlock_irq(&chip->lock);\r\nif (changed == 0)\r\nchanged = 1;\r\n}\r\nreturn changed;\r\n}\r\nstatic int snd_echo_vumeters_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&chip->lock);\r\nset_meters_on(chip, ucontrol->value.integer.value[0]);\r\nspin_unlock_irq(&chip->lock);\r\nreturn 1;\r\n}\r\nstatic int snd_echo_vumeters_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct echoaudio *chip;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 96;\r\nuinfo->value.integer.min = ECHOGAIN_MINOUT;\r\nuinfo->value.integer.max = 0;\r\n#ifdef ECHOCARD_HAS_VMIXER\r\nuinfo->dimen.d[0] = 3;\r\n#else\r\nuinfo->dimen.d[0] = 2;\r\n#endif\r\nuinfo->dimen.d[1] = 16;\r\nuinfo->dimen.d[2] = 2;\r\nreturn 0;\r\n}\r\nstatic int snd_echo_vumeters_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nget_audio_meters(chip, ucontrol->value.integer.value);\r\nreturn 0;\r\n}\r\nstatic int snd_echo_channels_info_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct echoaudio *chip;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 6;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1 << ECHO_CLOCK_NUMBER;\r\nreturn 0;\r\n}\r\nstatic int snd_echo_channels_info_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct echoaudio *chip;\r\nint detected, clocks, bit, src;\r\nchip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = num_busses_in(chip);\r\nucontrol->value.integer.value[1] = num_analog_busses_in(chip);\r\nucontrol->value.integer.value[2] = num_busses_out(chip);\r\nucontrol->value.integer.value[3] = num_analog_busses_out(chip);\r\nucontrol->value.integer.value[4] = num_pipes_out(chip);\r\ndetected = detect_input_clocks(chip);\r\nclocks = 0;\r\nsrc = chip->num_clock_sources - 1;\r\nfor (bit = ECHO_CLOCK_NUMBER - 1; bit >= 0; bit--)\r\nif (detected & (1 << bit))\r\nfor (; src >= 0; src--)\r\nif (bit == chip->clock_source_list[src]) {\r\nclocks |= 1 << src;\r\nbreak;\r\n}\r\nucontrol->value.integer.value[5] = clocks;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t snd_echo_interrupt(int irq, void *dev_id)\r\n{\r\nstruct echoaudio *chip = dev_id;\r\nstruct snd_pcm_substream *substream;\r\nint period, ss, st;\r\nspin_lock(&chip->lock);\r\nst = service_irq(chip);\r\nif (st < 0) {\r\nspin_unlock(&chip->lock);\r\nreturn IRQ_NONE;\r\n}\r\nfor (ss = 0; ss < DSP_MAXPIPES; ss++) {\r\nsubstream = chip->substream[ss];\r\nif (substream && ((struct audiopipe *)substream->runtime->\r\nprivate_data)->state == PIPE_STATE_STARTED) {\r\nperiod = pcm_pointer(substream) /\r\nsubstream->runtime->period_size;\r\nif (period != chip->last_period[ss]) {\r\nchip->last_period[ss] = period;\r\nspin_unlock(&chip->lock);\r\nsnd_pcm_period_elapsed(substream);\r\nspin_lock(&chip->lock);\r\n}\r\n}\r\n}\r\nspin_unlock(&chip->lock);\r\n#ifdef ECHOCARD_HAS_MIDI\r\nif (st > 0 && chip->midi_in) {\r\nsnd_rawmidi_receive(chip->midi_in, chip->midi_buffer, st);\r\nDE_MID(("rawmidi_iread=%d\n", st));\r\n}\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int snd_echo_free(struct echoaudio *chip)\r\n{\r\nDE_INIT(("Stop DSP...\n"));\r\nif (chip->comm_page)\r\nrest_in_peace(chip);\r\nDE_INIT(("Stopped.\n"));\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\nif (chip->comm_page)\r\nsnd_dma_free_pages(&chip->commpage_dma_buf);\r\nif (chip->dsp_registers)\r\niounmap(chip->dsp_registers);\r\nif (chip->iores)\r\nrelease_and_free_resource(chip->iores);\r\nDE_INIT(("MMIO freed.\n"));\r\npci_disable_device(chip->pci);\r\nfree_firmware_cache(chip);\r\nkfree(chip);\r\nDE_INIT(("Chip freed.\n"));\r\nreturn 0;\r\n}\r\nstatic int snd_echo_dev_free(struct snd_device *device)\r\n{\r\nstruct echoaudio *chip = device->device_data;\r\nDE_INIT(("snd_echo_dev_free()...\n"));\r\nreturn snd_echo_free(chip);\r\n}\r\nstatic int snd_echo_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nstruct echoaudio **rchip)\r\n{\r\nstruct echoaudio *chip;\r\nint err;\r\nsize_t sz;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_echo_dev_free,\r\n};\r\n*rchip = NULL;\r\npci_write_config_byte(pci, PCI_LATENCY_TIMER, 0xC0);\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\npci_set_master(pci);\r\nif (!*rchip) {\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (!chip) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nDE_INIT(("chip=%p\n", chip));\r\nspin_lock_init(&chip->lock);\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\natomic_set(&chip->opencount, 0);\r\nmutex_init(&chip->mode_mutex);\r\nchip->can_set_rate = 1;\r\n} else {\r\nchip = *rchip;\r\n}\r\nchip->dsp_registers_phys = pci_resource_start(pci, 0);\r\nsz = pci_resource_len(pci, 0);\r\nif (sz > PAGE_SIZE)\r\nsz = PAGE_SIZE;\r\nif ((chip->iores = request_mem_region(chip->dsp_registers_phys, sz,\r\nECHOCARD_NAME)) == NULL) {\r\nsnd_echo_free(chip);\r\nsnd_printk(KERN_ERR "cannot get memory region\n");\r\nreturn -EBUSY;\r\n}\r\nchip->dsp_registers = (volatile u32 __iomem *)\r\nioremap_nocache(chip->dsp_registers_phys, sz);\r\nif (request_irq(pci->irq, snd_echo_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, chip)) {\r\nsnd_echo_free(chip);\r\nsnd_printk(KERN_ERR "cannot grab irq\n");\r\nreturn -EBUSY;\r\n}\r\nchip->irq = pci->irq;\r\nDE_INIT(("pci=%p irq=%d subdev=%04x Init hardware...\n",\r\nchip->pci, chip->irq, chip->pci->subsystem_device));\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),\r\nsizeof(struct comm_page),\r\n&chip->commpage_dma_buf) < 0) {\r\nsnd_echo_free(chip);\r\nsnd_printk(KERN_ERR "cannot allocate the comm page\n");\r\nreturn -ENOMEM;\r\n}\r\nchip->comm_page_phys = chip->commpage_dma_buf.addr;\r\nchip->comm_page = (struct comm_page *)chip->commpage_dma_buf.area;\r\nerr = init_hw(chip, chip->pci->device, chip->pci->subsystem_device);\r\nif (err >= 0)\r\nerr = set_mixer_defaults(chip);\r\nif (err < 0) {\r\nDE_INIT(("init_hw err=%d\n", err));\r\nsnd_echo_free(chip);\r\nreturn err;\r\n}\r\nDE_INIT(("Card init OK\n"));\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\r\nsnd_echo_free(chip);\r\nreturn err;\r\n}\r\n*rchip = chip;\r\nreturn 0;\r\n}\r\nstatic int snd_echo_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct echoaudio *chip;\r\nchar *dsp;\r\nint i, err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nDE_INIT(("Echoaudio driver starting...\n"));\r\ni = 0;\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nsnd_card_set_dev(card, &pci->dev);\r\nchip = NULL;\r\nif ((err = snd_echo_create(card, pci, &chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstrcpy(card->driver, "Echo_" ECHOCARD_NAME);\r\nstrcpy(card->shortname, chip->card_name);\r\ndsp = "56301";\r\nif (pci_id->device == 0x3410)\r\ndsp = "56361";\r\nsprintf(card->longname, "%s rev.%d (DSP%s) at 0x%lx irq %i",\r\ncard->shortname, pci_id->subdevice & 0x000f, dsp,\r\nchip->dsp_registers_phys, chip->irq);\r\nif ((err = snd_echo_new_pcm(chip)) < 0) {\r\nsnd_printk(KERN_ERR "new pcm error %d\n", err);\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\n#ifdef ECHOCARD_HAS_MIDI\r\nif (chip->has_midi) {\r\nif ((err = snd_echo_midi_create(card, chip)) < 0) {\r\nsnd_printk(KERN_ERR "new midi error %d\n", err);\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\n}\r\n#endif\r\n#ifdef ECHOCARD_HAS_VMIXER\r\nsnd_echo_vmixer.count = num_pipes_out(chip) * num_busses_out(chip);\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_vmixer, chip))) < 0)\r\ngoto ctl_error;\r\n#ifdef ECHOCARD_HAS_LINE_OUT_GAIN\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&snd_echo_line_output_gain, chip));\r\nif (err < 0)\r\ngoto ctl_error;\r\n#endif\r\n#else\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&snd_echo_pcm_output_gain, chip));\r\nif (err < 0)\r\ngoto ctl_error;\r\n#endif\r\n#ifdef ECHOCARD_HAS_INPUT_GAIN\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_line_input_gain, chip))) < 0)\r\ngoto ctl_error;\r\n#endif\r\n#ifdef ECHOCARD_HAS_INPUT_NOMINAL_LEVEL\r\nif (!chip->hasnt_input_nominal_level)\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_intput_nominal_level, chip))) < 0)\r\ngoto ctl_error;\r\n#endif\r\n#ifdef ECHOCARD_HAS_OUTPUT_NOMINAL_LEVEL\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_output_nominal_level, chip))) < 0)\r\ngoto ctl_error;\r\n#endif\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_vumeters_switch, chip))) < 0)\r\ngoto ctl_error;\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_vumeters, chip))) < 0)\r\ngoto ctl_error;\r\n#ifdef ECHOCARD_HAS_MONITOR\r\nsnd_echo_monitor_mixer.count = num_busses_in(chip) * num_busses_out(chip);\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_monitor_mixer, chip))) < 0)\r\ngoto ctl_error;\r\n#endif\r\n#ifdef ECHOCARD_HAS_DIGITAL_IN_AUTOMUTE\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_automute_switch, chip))) < 0)\r\ngoto ctl_error;\r\n#endif\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_channels_info, chip))) < 0)\r\ngoto ctl_error;\r\n#ifdef ECHOCARD_HAS_DIGITAL_MODE_SWITCH\r\nchip->num_digital_modes = 0;\r\nfor (i = 0; i < 6; i++)\r\nif (chip->digital_modes & (1 << i))\r\nchip->digital_mode_list[chip->num_digital_modes++] = i;\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_digital_mode_switch, chip))) < 0)\r\ngoto ctl_error;\r\n#endif\r\n#ifdef ECHOCARD_HAS_EXTERNAL_CLOCK\r\nchip->num_clock_sources = 0;\r\nfor (i = 0; i < 10; i++)\r\nif (chip->input_clock_types & (1 << i))\r\nchip->clock_source_list[chip->num_clock_sources++] = i;\r\nif (chip->num_clock_sources > 1) {\r\nchip->clock_src_ctl = snd_ctl_new1(&snd_echo_clock_source_switch, chip);\r\nif ((err = snd_ctl_add(chip->card, chip->clock_src_ctl)) < 0)\r\ngoto ctl_error;\r\n}\r\n#endif\r\n#ifdef ECHOCARD_HAS_DIGITAL_IO\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_spdif_mode_switch, chip))) < 0)\r\ngoto ctl_error;\r\n#endif\r\n#ifdef ECHOCARD_HAS_PHANTOM_POWER\r\nif (chip->has_phantom_power)\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_phantom_power_switch, chip))) < 0)\r\ngoto ctl_error;\r\n#endif\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto ctl_error;\r\nsnd_printk(KERN_INFO "Card registered: %s\n", card->longname);\r\npci_set_drvdata(pci, chip);\r\ndev++;\r\nreturn 0;\r\nctl_error:\r\nsnd_printk(KERN_ERR "new control error %d\n", err);\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic int snd_echo_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct echoaudio *chip = dev_get_drvdata(dev);\r\nDE_INIT(("suspend start\n"));\r\nsnd_pcm_suspend_all(chip->analog_pcm);\r\nsnd_pcm_suspend_all(chip->digital_pcm);\r\n#ifdef ECHOCARD_HAS_MIDI\r\nif (chip->midi_out)\r\nsnd_echo_midi_output_trigger(chip->midi_out, 0);\r\n#endif\r\nspin_lock_irq(&chip->lock);\r\nif (wait_handshake(chip)) {\r\nspin_unlock_irq(&chip->lock);\r\nreturn -EIO;\r\n}\r\nclear_handshake(chip);\r\nif (send_vector(chip, DSP_VC_GO_COMATOSE) < 0) {\r\nspin_unlock_irq(&chip->lock);\r\nreturn -EIO;\r\n}\r\nspin_unlock_irq(&chip->lock);\r\nchip->dsp_code = NULL;\r\nfree_irq(chip->irq, chip);\r\nchip->irq = -1;\r\npci_save_state(pci);\r\npci_disable_device(pci);\r\nDE_INIT(("suspend done\n"));\r\nreturn 0;\r\n}\r\nstatic int snd_echo_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct echoaudio *chip = dev_get_drvdata(dev);\r\nstruct comm_page *commpage, *commpage_bak;\r\nu32 pipe_alloc_mask;\r\nint err;\r\nDE_INIT(("resume start\n"));\r\npci_restore_state(pci);\r\ncommpage_bak = kmalloc(sizeof(struct echoaudio), GFP_KERNEL);\r\nif (commpage_bak == NULL)\r\nreturn -ENOMEM;\r\ncommpage = chip->comm_page;\r\nmemcpy(commpage_bak, commpage, sizeof(struct comm_page));\r\nerr = init_hw(chip, chip->pci->device, chip->pci->subsystem_device);\r\nif (err < 0) {\r\nkfree(commpage_bak);\r\nDE_INIT(("resume init_hw err=%d\n", err));\r\nsnd_echo_free(chip);\r\nreturn err;\r\n}\r\nDE_INIT(("resume init OK\n"));\r\npipe_alloc_mask = chip->pipe_alloc_mask;\r\nchip->pipe_alloc_mask = 0;\r\nerr = restore_dsp_rettings(chip);\r\nchip->pipe_alloc_mask = pipe_alloc_mask;\r\nif (err < 0) {\r\nkfree(commpage_bak);\r\nreturn err;\r\n}\r\nDE_INIT(("resume restore OK\n"));\r\nmemcpy(&commpage->audio_format, &commpage_bak->audio_format,\r\nsizeof(commpage->audio_format));\r\nmemcpy(&commpage->sglist_addr, &commpage_bak->sglist_addr,\r\nsizeof(commpage->sglist_addr));\r\nmemcpy(&commpage->midi_output, &commpage_bak->midi_output,\r\nsizeof(commpage->midi_output));\r\nkfree(commpage_bak);\r\nif (request_irq(pci->irq, snd_echo_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, chip)) {\r\nsnd_echo_free(chip);\r\nsnd_printk(KERN_ERR "cannot grab irq\n");\r\nreturn -EBUSY;\r\n}\r\nchip->irq = pci->irq;\r\nDE_INIT(("resume irq=%d\n", chip->irq));\r\n#ifdef ECHOCARD_HAS_MIDI\r\nif (chip->midi_input_enabled)\r\nenable_midi_input(chip, TRUE);\r\nif (chip->midi_out)\r\nsnd_echo_midi_output_trigger(chip->midi_out, 1);\r\n#endif\r\nDE_INIT(("resume done\n"));\r\nreturn 0;\r\n}\r\nstatic void snd_echo_remove(struct pci_dev *pci)\r\n{\r\nstruct echoaudio *chip;\r\nchip = pci_get_drvdata(pci);\r\nif (chip)\r\nsnd_card_free(chip->card);\r\n}
