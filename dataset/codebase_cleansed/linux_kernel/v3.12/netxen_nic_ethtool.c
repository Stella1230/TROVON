static int netxen_nic_get_eeprom_len(struct net_device *dev)\r\n{\r\nreturn NETXEN_FLASH_TOTAL_SIZE;\r\n}\r\nstatic void\r\nnetxen_nic_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(dev);\r\nu32 fw_major = 0;\r\nu32 fw_minor = 0;\r\nu32 fw_build = 0;\r\nstrlcpy(drvinfo->driver, netxen_nic_driver_name,\r\nsizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, NETXEN_NIC_LINUX_VERSIONID,\r\nsizeof(drvinfo->version));\r\nfw_major = NXRD32(adapter, NETXEN_FW_VERSION_MAJOR);\r\nfw_minor = NXRD32(adapter, NETXEN_FW_VERSION_MINOR);\r\nfw_build = NXRD32(adapter, NETXEN_FW_VERSION_SUB);\r\nsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\r\n"%d.%d.%d", fw_major, fw_minor, fw_build);\r\nstrlcpy(drvinfo->bus_info, pci_name(adapter->pdev),\r\nsizeof(drvinfo->bus_info));\r\ndrvinfo->regdump_len = NETXEN_NIC_REGS_LEN;\r\ndrvinfo->eedump_len = netxen_nic_get_eeprom_len(dev);\r\n}\r\nstatic int\r\nnetxen_nic_get_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(dev);\r\nint check_sfp_module = 0;\r\nif (adapter->ahw.port_type == NETXEN_NIC_GBE) {\r\necmd->supported = (SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_1000baseT_Half |\r\nSUPPORTED_1000baseT_Full);\r\necmd->advertising = (ADVERTISED_100baseT_Half |\r\nADVERTISED_100baseT_Full |\r\nADVERTISED_1000baseT_Half |\r\nADVERTISED_1000baseT_Full);\r\necmd->port = PORT_TP;\r\nethtool_cmd_speed_set(ecmd, adapter->link_speed);\r\necmd->duplex = adapter->link_duplex;\r\necmd->autoneg = adapter->link_autoneg;\r\n} else if (adapter->ahw.port_type == NETXEN_NIC_XGBE) {\r\nu32 val;\r\nval = NXRD32(adapter, NETXEN_PORT_MODE_ADDR);\r\nif (val == NETXEN_PORT_MODE_802_3_AP) {\r\necmd->supported = SUPPORTED_1000baseT_Full;\r\necmd->advertising = ADVERTISED_1000baseT_Full;\r\n} else {\r\necmd->supported = SUPPORTED_10000baseT_Full;\r\necmd->advertising = ADVERTISED_10000baseT_Full;\r\n}\r\nif (netif_running(dev) && adapter->has_link_events) {\r\nethtool_cmd_speed_set(ecmd, adapter->link_speed);\r\necmd->autoneg = adapter->link_autoneg;\r\necmd->duplex = adapter->link_duplex;\r\ngoto skip;\r\n}\r\necmd->port = PORT_TP;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\r\nu16 pcifn = adapter->ahw.pci_func;\r\nval = NXRD32(adapter, P3_LINK_SPEED_REG(pcifn));\r\nethtool_cmd_speed_set(ecmd, P3_LINK_SPEED_MHZ *\r\nP3_LINK_SPEED_VAL(pcifn, val));\r\n} else\r\nethtool_cmd_speed_set(ecmd, SPEED_10000);\r\necmd->duplex = DUPLEX_FULL;\r\necmd->autoneg = AUTONEG_DISABLE;\r\n} else\r\nreturn -EIO;\r\nskip:\r\necmd->phy_address = adapter->physical_port;\r\necmd->transceiver = XCVR_EXTERNAL;\r\nswitch (adapter->ahw.board_type) {\r\ncase NETXEN_BRDTYPE_P2_SB35_4G:\r\ncase NETXEN_BRDTYPE_P2_SB31_2G:\r\ncase NETXEN_BRDTYPE_P3_REF_QG:\r\ncase NETXEN_BRDTYPE_P3_4_GB:\r\ncase NETXEN_BRDTYPE_P3_4_GB_MM:\r\necmd->supported |= SUPPORTED_Autoneg;\r\necmd->advertising |= ADVERTISED_Autoneg;\r\ncase NETXEN_BRDTYPE_P2_SB31_10G_CX4:\r\ncase NETXEN_BRDTYPE_P3_10G_CX4:\r\ncase NETXEN_BRDTYPE_P3_10G_CX4_LP:\r\ncase NETXEN_BRDTYPE_P3_10000_BASE_T:\r\necmd->supported |= SUPPORTED_TP;\r\necmd->advertising |= ADVERTISED_TP;\r\necmd->port = PORT_TP;\r\necmd->autoneg = (adapter->ahw.board_type ==\r\nNETXEN_BRDTYPE_P2_SB31_10G_CX4) ?\r\n(AUTONEG_DISABLE) : (adapter->link_autoneg);\r\nbreak;\r\ncase NETXEN_BRDTYPE_P2_SB31_10G_HMEZ:\r\ncase NETXEN_BRDTYPE_P2_SB31_10G_IMEZ:\r\ncase NETXEN_BRDTYPE_P3_IMEZ:\r\ncase NETXEN_BRDTYPE_P3_XG_LOM:\r\ncase NETXEN_BRDTYPE_P3_HMEZ:\r\necmd->supported |= SUPPORTED_MII;\r\necmd->advertising |= ADVERTISED_MII;\r\necmd->port = PORT_MII;\r\necmd->autoneg = AUTONEG_DISABLE;\r\nbreak;\r\ncase NETXEN_BRDTYPE_P3_10G_SFP_PLUS:\r\ncase NETXEN_BRDTYPE_P3_10G_SFP_CT:\r\ncase NETXEN_BRDTYPE_P3_10G_SFP_QT:\r\necmd->advertising |= ADVERTISED_TP;\r\necmd->supported |= SUPPORTED_TP;\r\ncheck_sfp_module = netif_running(dev) &&\r\nadapter->has_link_events;\r\ncase NETXEN_BRDTYPE_P2_SB31_10G:\r\ncase NETXEN_BRDTYPE_P3_10G_XFP:\r\necmd->supported |= SUPPORTED_FIBRE;\r\necmd->advertising |= ADVERTISED_FIBRE;\r\necmd->port = PORT_FIBRE;\r\necmd->autoneg = AUTONEG_DISABLE;\r\nbreak;\r\ncase NETXEN_BRDTYPE_P3_10G_TP:\r\nif (adapter->ahw.port_type == NETXEN_NIC_XGBE) {\r\necmd->autoneg = AUTONEG_DISABLE;\r\necmd->supported |= (SUPPORTED_FIBRE | SUPPORTED_TP);\r\necmd->advertising |=\r\n(ADVERTISED_FIBRE | ADVERTISED_TP);\r\necmd->port = PORT_FIBRE;\r\ncheck_sfp_module = netif_running(dev) &&\r\nadapter->has_link_events;\r\n} else {\r\necmd->supported |= (SUPPORTED_TP | SUPPORTED_Autoneg);\r\necmd->advertising |=\r\n(ADVERTISED_TP | ADVERTISED_Autoneg);\r\necmd->port = PORT_TP;\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "netxen-nic: Unsupported board model %d\n",\r\nadapter->ahw.board_type);\r\nreturn -EIO;\r\n}\r\nif (check_sfp_module) {\r\nswitch (adapter->module_type) {\r\ncase LINKEVENT_MODULE_OPTICAL_UNKNOWN:\r\ncase LINKEVENT_MODULE_OPTICAL_SRLR:\r\ncase LINKEVENT_MODULE_OPTICAL_LRM:\r\ncase LINKEVENT_MODULE_OPTICAL_SFP_1G:\r\necmd->port = PORT_FIBRE;\r\nbreak;\r\ncase LINKEVENT_MODULE_TWINAX_UNSUPPORTED_CABLE:\r\ncase LINKEVENT_MODULE_TWINAX_UNSUPPORTED_CABLELEN:\r\ncase LINKEVENT_MODULE_TWINAX:\r\necmd->port = PORT_TP;\r\nbreak;\r\ndefault:\r\necmd->port = -1;\r\n}\r\n}\r\nif (!netif_running(dev) || !adapter->ahw.linkup) {\r\necmd->duplex = DUPLEX_UNKNOWN;\r\nethtool_cmd_speed_set(ecmd, SPEED_UNKNOWN);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_nic_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(dev);\r\nu32 speed = ethtool_cmd_speed(ecmd);\r\nint ret;\r\nif (adapter->ahw.port_type != NETXEN_NIC_GBE)\r\nreturn -EOPNOTSUPP;\r\nif (!(adapter->capabilities & NX_FW_CAPABILITY_GBE_LINK_CFG))\r\nreturn -EOPNOTSUPP;\r\nret = nx_fw_cmd_set_gbe_port(adapter, speed, ecmd->duplex,\r\necmd->autoneg);\r\nif (ret == NX_RCODE_NOT_SUPPORTED)\r\nreturn -EOPNOTSUPP;\r\nelse if (ret)\r\nreturn -EIO;\r\nadapter->link_speed = speed;\r\nadapter->link_duplex = ecmd->duplex;\r\nadapter->link_autoneg = ecmd->autoneg;\r\nif (!netif_running(dev))\r\nreturn 0;\r\ndev->netdev_ops->ndo_stop(dev);\r\nreturn dev->netdev_ops->ndo_open(dev);\r\n}\r\nstatic int netxen_nic_get_regs_len(struct net_device *dev)\r\n{\r\nreturn NETXEN_NIC_REGS_LEN;\r\n}\r\nstatic void\r\nnetxen_nic_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *p)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(dev);\r\nstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\r\nstruct nx_host_sds_ring *sds_ring;\r\nu32 *regs_buff = p;\r\nint ring, i = 0;\r\nint port = adapter->physical_port;\r\nmemset(p, 0, NETXEN_NIC_REGS_LEN);\r\nregs->version = (1 << 24) | (adapter->ahw.revision_id << 16) |\r\n(adapter->pdev)->device;\r\nif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\r\nreturn;\r\nregs_buff[i++] = NXRD32(adapter, CRB_CMDPEG_STATE);\r\nregs_buff[i++] = NXRD32(adapter, CRB_RCVPEG_STATE);\r\nregs_buff[i++] = NXRD32(adapter, CRB_FW_CAPABILITIES_1);\r\nregs_buff[i++] = NXRDIO(adapter, adapter->crb_int_state_reg);\r\nregs_buff[i++] = NXRD32(adapter, NX_CRB_DEV_REF_COUNT);\r\nregs_buff[i++] = NXRD32(adapter, NX_CRB_DEV_STATE);\r\nregs_buff[i++] = NXRD32(adapter, NETXEN_PEG_ALIVE_COUNTER);\r\nregs_buff[i++] = NXRD32(adapter, NETXEN_PEG_HALT_STATUS1);\r\nregs_buff[i++] = NXRD32(adapter, NETXEN_PEG_HALT_STATUS2);\r\nregs_buff[i++] = NXRD32(adapter, NETXEN_CRB_PEG_NET_0+0x3c);\r\nregs_buff[i++] = NXRD32(adapter, NETXEN_CRB_PEG_NET_1+0x3c);\r\nregs_buff[i++] = NXRD32(adapter, NETXEN_CRB_PEG_NET_2+0x3c);\r\nregs_buff[i++] = NXRD32(adapter, NETXEN_CRB_PEG_NET_3+0x3c);\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\r\nregs_buff[i++] = NXRD32(adapter, NETXEN_CRB_PEG_NET_4+0x3c);\r\ni += 2;\r\nregs_buff[i++] = NXRD32(adapter, CRB_XG_STATE_P3);\r\nregs_buff[i++] = le32_to_cpu(*(adapter->tx_ring->hw_consumer));\r\n} else {\r\ni++;\r\nregs_buff[i++] = NXRD32(adapter,\r\nNETXEN_NIU_XGE_CONFIG_0+(0x10000*port));\r\nregs_buff[i++] = NXRD32(adapter,\r\nNETXEN_NIU_XGE_CONFIG_1+(0x10000*port));\r\nregs_buff[i++] = NXRD32(adapter, CRB_XG_STATE);\r\nregs_buff[i++] = NXRDIO(adapter,\r\nadapter->tx_ring->crb_cmd_consumer);\r\n}\r\nregs_buff[i++] = NXRDIO(adapter, adapter->tx_ring->crb_cmd_producer);\r\nregs_buff[i++] = NXRDIO(adapter,\r\nrecv_ctx->rds_rings[0].crb_rcv_producer);\r\nregs_buff[i++] = NXRDIO(adapter,\r\nrecv_ctx->rds_rings[1].crb_rcv_producer);\r\nregs_buff[i++] = adapter->max_sds_rings;\r\nfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\r\nsds_ring = &(recv_ctx->sds_rings[ring]);\r\nregs_buff[i++] = NXRDIO(adapter,\r\nsds_ring->crb_sts_consumer);\r\n}\r\n}\r\nstatic u32 netxen_nic_test_link(struct net_device *dev)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(dev);\r\nu32 val, port;\r\nport = adapter->physical_port;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\r\nval = NXRD32(adapter, CRB_XG_STATE_P3);\r\nval = XG_LINK_STATE_P3(adapter->ahw.pci_func, val);\r\nreturn (val == XG_LINK_UP_P3) ? 0 : 1;\r\n} else {\r\nval = NXRD32(adapter, CRB_XG_STATE);\r\nval = (val >> port*8) & 0xff;\r\nreturn (val == XG_LINK_UP) ? 0 : 1;\r\n}\r\n}\r\nstatic int\r\nnetxen_nic_get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,\r\nu8 *bytes)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(dev);\r\nint offset;\r\nint ret;\r\nif (eeprom->len == 0)\r\nreturn -EINVAL;\r\neeprom->magic = (adapter->pdev)->vendor |\r\n((adapter->pdev)->device << 16);\r\noffset = eeprom->offset;\r\nret = netxen_rom_fast_read_words(adapter, offset, bytes,\r\neeprom->len);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void\r\nnetxen_nic_get_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(dev);\r\nring->rx_pending = adapter->num_rxd;\r\nring->rx_jumbo_pending = adapter->num_jumbo_rxd;\r\nring->rx_jumbo_pending += adapter->num_lro_rxd;\r\nring->tx_pending = adapter->num_txd;\r\nif (adapter->ahw.port_type == NETXEN_NIC_GBE) {\r\nring->rx_max_pending = MAX_RCV_DESCRIPTORS_1G;\r\nring->rx_jumbo_max_pending = MAX_JUMBO_RCV_DESCRIPTORS_1G;\r\n} else {\r\nring->rx_max_pending = MAX_RCV_DESCRIPTORS_10G;\r\nring->rx_jumbo_max_pending = MAX_JUMBO_RCV_DESCRIPTORS_10G;\r\n}\r\nring->tx_max_pending = MAX_CMD_DESCRIPTORS;\r\n}\r\nstatic u32\r\nnetxen_validate_ringparam(u32 val, u32 min, u32 max, char *r_name)\r\n{\r\nu32 num_desc;\r\nnum_desc = max(val, min);\r\nnum_desc = min(num_desc, max);\r\nnum_desc = roundup_pow_of_two(num_desc);\r\nif (val != num_desc) {\r\nprintk(KERN_INFO "%s: setting %s ring size %d instead of %d\n",\r\nnetxen_nic_driver_name, r_name, num_desc, val);\r\n}\r\nreturn num_desc;\r\n}\r\nstatic int\r\nnetxen_nic_set_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(dev);\r\nu16 max_rcv_desc = MAX_RCV_DESCRIPTORS_10G;\r\nu16 max_jumbo_desc = MAX_JUMBO_RCV_DESCRIPTORS_10G;\r\nu16 num_rxd, num_jumbo_rxd, num_txd;\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\nreturn -EOPNOTSUPP;\r\nif (ring->rx_mini_pending)\r\nreturn -EOPNOTSUPP;\r\nif (adapter->ahw.port_type == NETXEN_NIC_GBE) {\r\nmax_rcv_desc = MAX_RCV_DESCRIPTORS_1G;\r\nmax_jumbo_desc = MAX_JUMBO_RCV_DESCRIPTORS_10G;\r\n}\r\nnum_rxd = netxen_validate_ringparam(ring->rx_pending,\r\nMIN_RCV_DESCRIPTORS, max_rcv_desc, "rx");\r\nnum_jumbo_rxd = netxen_validate_ringparam(ring->rx_jumbo_pending,\r\nMIN_JUMBO_DESCRIPTORS, max_jumbo_desc, "rx jumbo");\r\nnum_txd = netxen_validate_ringparam(ring->tx_pending,\r\nMIN_CMD_DESCRIPTORS, MAX_CMD_DESCRIPTORS, "tx");\r\nif (num_rxd == adapter->num_rxd && num_txd == adapter->num_txd &&\r\nnum_jumbo_rxd == adapter->num_jumbo_rxd)\r\nreturn 0;\r\nadapter->num_rxd = num_rxd;\r\nadapter->num_jumbo_rxd = num_jumbo_rxd;\r\nadapter->num_txd = num_txd;\r\nreturn netxen_nic_reset_context(adapter);\r\n}\r\nstatic void\r\nnetxen_nic_get_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(dev);\r\n__u32 val;\r\nint port = adapter->physical_port;\r\npause->autoneg = 0;\r\nif (adapter->ahw.port_type == NETXEN_NIC_GBE) {\r\nif ((port < 0) || (port >= NETXEN_NIU_MAX_GBE_PORTS))\r\nreturn;\r\nval = NXRD32(adapter, NETXEN_NIU_GB_MAC_CONFIG_0(port));\r\npause->rx_pause = netxen_gb_get_rx_flowctl(val);\r\nval = NXRD32(adapter, NETXEN_NIU_GB_PAUSE_CTL);\r\nswitch (port) {\r\ncase 0:\r\npause->tx_pause = !(netxen_gb_get_gb0_mask(val));\r\nbreak;\r\ncase 1:\r\npause->tx_pause = !(netxen_gb_get_gb1_mask(val));\r\nbreak;\r\ncase 2:\r\npause->tx_pause = !(netxen_gb_get_gb2_mask(val));\r\nbreak;\r\ncase 3:\r\ndefault:\r\npause->tx_pause = !(netxen_gb_get_gb3_mask(val));\r\nbreak;\r\n}\r\n} else if (adapter->ahw.port_type == NETXEN_NIC_XGBE) {\r\nif ((port < 0) || (port >= NETXEN_NIU_MAX_XG_PORTS))\r\nreturn;\r\npause->rx_pause = 1;\r\nval = NXRD32(adapter, NETXEN_NIU_XG_PAUSE_CTL);\r\nif (port == 0)\r\npause->tx_pause = !(netxen_xg_get_xg0_mask(val));\r\nelse\r\npause->tx_pause = !(netxen_xg_get_xg1_mask(val));\r\n} else {\r\nprintk(KERN_ERR"%s: Unknown board type: %x\n",\r\nnetxen_nic_driver_name, adapter->ahw.port_type);\r\n}\r\n}\r\nstatic int\r\nnetxen_nic_set_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(dev);\r\n__u32 val;\r\nint port = adapter->physical_port;\r\nif (pause->autoneg)\r\nreturn -EINVAL;\r\nif (adapter->ahw.port_type == NETXEN_NIC_GBE) {\r\nif ((port < 0) || (port >= NETXEN_NIU_MAX_GBE_PORTS))\r\nreturn -EIO;\r\nval = NXRD32(adapter, NETXEN_NIU_GB_MAC_CONFIG_0(port));\r\nif (pause->rx_pause)\r\nnetxen_gb_rx_flowctl(val);\r\nelse\r\nnetxen_gb_unset_rx_flowctl(val);\r\nNXWR32(adapter, NETXEN_NIU_GB_MAC_CONFIG_0(port),\r\nval);\r\nval = NXRD32(adapter, NETXEN_NIU_GB_PAUSE_CTL);\r\nswitch (port) {\r\ncase 0:\r\nif (pause->tx_pause)\r\nnetxen_gb_unset_gb0_mask(val);\r\nelse\r\nnetxen_gb_set_gb0_mask(val);\r\nbreak;\r\ncase 1:\r\nif (pause->tx_pause)\r\nnetxen_gb_unset_gb1_mask(val);\r\nelse\r\nnetxen_gb_set_gb1_mask(val);\r\nbreak;\r\ncase 2:\r\nif (pause->tx_pause)\r\nnetxen_gb_unset_gb2_mask(val);\r\nelse\r\nnetxen_gb_set_gb2_mask(val);\r\nbreak;\r\ncase 3:\r\ndefault:\r\nif (pause->tx_pause)\r\nnetxen_gb_unset_gb3_mask(val);\r\nelse\r\nnetxen_gb_set_gb3_mask(val);\r\nbreak;\r\n}\r\nNXWR32(adapter, NETXEN_NIU_GB_PAUSE_CTL, val);\r\n} else if (adapter->ahw.port_type == NETXEN_NIC_XGBE) {\r\nif ((port < 0) || (port >= NETXEN_NIU_MAX_XG_PORTS))\r\nreturn -EIO;\r\nval = NXRD32(adapter, NETXEN_NIU_XG_PAUSE_CTL);\r\nif (port == 0) {\r\nif (pause->tx_pause)\r\nnetxen_xg_unset_xg0_mask(val);\r\nelse\r\nnetxen_xg_set_xg0_mask(val);\r\n} else {\r\nif (pause->tx_pause)\r\nnetxen_xg_unset_xg1_mask(val);\r\nelse\r\nnetxen_xg_set_xg1_mask(val);\r\n}\r\nNXWR32(adapter, NETXEN_NIU_XG_PAUSE_CTL, val);\r\n} else {\r\nprintk(KERN_ERR "%s: Unknown board type: %x\n",\r\nnetxen_nic_driver_name,\r\nadapter->ahw.port_type);\r\n}\r\nreturn 0;\r\n}\r\nstatic int netxen_nic_reg_test(struct net_device *dev)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(dev);\r\nu32 data_read, data_written;\r\ndata_read = NXRD32(adapter, NETXEN_PCIX_PH_REG(0));\r\nif ((data_read & 0xffff) != adapter->pdev->vendor)\r\nreturn 1;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\r\nreturn 0;\r\ndata_written = (u32)0xa5a5a5a5;\r\nNXWR32(adapter, CRB_SCRATCHPAD_TEST, data_written);\r\ndata_read = NXRD32(adapter, CRB_SCRATCHPAD_TEST);\r\nif (data_written != data_read)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int netxen_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_TEST:\r\nreturn NETXEN_NIC_TEST_LEN;\r\ncase ETH_SS_STATS:\r\nreturn NETXEN_NIC_STATS_LEN;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void\r\nnetxen_nic_diag_test(struct net_device *dev, struct ethtool_test *eth_test,\r\nu64 *data)\r\n{\r\nmemset(data, 0, sizeof(uint64_t) * NETXEN_NIC_TEST_LEN);\r\nif ((data[0] = netxen_nic_reg_test(dev)))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nif ((data[1] = (u64) netxen_nic_test_link(dev)))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\n}\r\nstatic void\r\nnetxen_nic_get_strings(struct net_device *dev, u32 stringset, u8 *data)\r\n{\r\nint index;\r\nswitch (stringset) {\r\ncase ETH_SS_TEST:\r\nmemcpy(data, *netxen_nic_gstrings_test,\r\nNETXEN_NIC_TEST_LEN * ETH_GSTRING_LEN);\r\nbreak;\r\ncase ETH_SS_STATS:\r\nfor (index = 0; index < NETXEN_NIC_STATS_LEN; index++) {\r\nmemcpy(data + index * ETH_GSTRING_LEN,\r\nnetxen_nic_gstrings_stats[index].stat_string,\r\nETH_GSTRING_LEN);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nnetxen_nic_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(dev);\r\nint index;\r\nfor (index = 0; index < NETXEN_NIC_STATS_LEN; index++) {\r\nchar *p =\r\n(char *)adapter +\r\nnetxen_nic_gstrings_stats[index].stat_offset;\r\ndata[index] =\r\n(netxen_nic_gstrings_stats[index].sizeof_stat ==\r\nsizeof(u64)) ? *(u64 *) p : *(u32 *) p;\r\n}\r\n}\r\nstatic void\r\nnetxen_nic_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(dev);\r\nu32 wol_cfg = 0;\r\nwol->supported = 0;\r\nwol->wolopts = 0;\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\nreturn;\r\nwol_cfg = NXRD32(adapter, NETXEN_WOL_CONFIG_NV);\r\nif (wol_cfg & (1UL << adapter->portnum))\r\nwol->supported |= WAKE_MAGIC;\r\nwol_cfg = NXRD32(adapter, NETXEN_WOL_CONFIG);\r\nif (wol_cfg & (1UL << adapter->portnum))\r\nwol->wolopts |= WAKE_MAGIC;\r\n}\r\nstatic int\r\nnetxen_nic_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(dev);\r\nu32 wol_cfg = 0;\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\nreturn -EOPNOTSUPP;\r\nif (wol->wolopts & ~WAKE_MAGIC)\r\nreturn -EOPNOTSUPP;\r\nwol_cfg = NXRD32(adapter, NETXEN_WOL_CONFIG_NV);\r\nif (!(wol_cfg & (1 << adapter->portnum)))\r\nreturn -EOPNOTSUPP;\r\nwol_cfg = NXRD32(adapter, NETXEN_WOL_CONFIG);\r\nif (wol->wolopts & WAKE_MAGIC)\r\nwol_cfg |= 1UL << adapter->portnum;\r\nelse\r\nwol_cfg &= ~(1UL << adapter->portnum);\r\nNXWR32(adapter, NETXEN_WOL_CONFIG, wol_cfg);\r\nreturn 0;\r\n}\r\nstatic int netxen_set_intr_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ethcoal)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(netdev);\r\nif (!NX_IS_REVISION_P3(adapter->ahw.revision_id))\r\nreturn -EINVAL;\r\nif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\r\nreturn -EINVAL;\r\nif (ethcoal->rx_coalesce_usecs > 0xffff ||\r\nethcoal->rx_max_coalesced_frames > 0xffff ||\r\nethcoal->tx_coalesce_usecs > 0xffff ||\r\nethcoal->tx_max_coalesced_frames > 0xffff ||\r\nethcoal->rx_coalesce_usecs_irq ||\r\nethcoal->rx_max_coalesced_frames_irq ||\r\nethcoal->tx_coalesce_usecs_irq ||\r\nethcoal->tx_max_coalesced_frames_irq ||\r\nethcoal->stats_block_coalesce_usecs ||\r\nethcoal->use_adaptive_rx_coalesce ||\r\nethcoal->use_adaptive_tx_coalesce ||\r\nethcoal->pkt_rate_low ||\r\nethcoal->rx_coalesce_usecs_low ||\r\nethcoal->rx_max_coalesced_frames_low ||\r\nethcoal->tx_coalesce_usecs_low ||\r\nethcoal->tx_max_coalesced_frames_low ||\r\nethcoal->pkt_rate_high ||\r\nethcoal->rx_coalesce_usecs_high ||\r\nethcoal->rx_max_coalesced_frames_high ||\r\nethcoal->tx_coalesce_usecs_high ||\r\nethcoal->tx_max_coalesced_frames_high)\r\nreturn -EINVAL;\r\nif (!ethcoal->rx_coalesce_usecs ||\r\n!ethcoal->rx_max_coalesced_frames) {\r\nadapter->coal.flags = NETXEN_NIC_INTR_DEFAULT;\r\nadapter->coal.normal.data.rx_time_us =\r\nNETXEN_DEFAULT_INTR_COALESCE_RX_TIME_US;\r\nadapter->coal.normal.data.rx_packets =\r\nNETXEN_DEFAULT_INTR_COALESCE_RX_PACKETS;\r\n} else {\r\nadapter->coal.flags = 0;\r\nadapter->coal.normal.data.rx_time_us =\r\nethcoal->rx_coalesce_usecs;\r\nadapter->coal.normal.data.rx_packets =\r\nethcoal->rx_max_coalesced_frames;\r\n}\r\nadapter->coal.normal.data.tx_time_us = ethcoal->tx_coalesce_usecs;\r\nadapter->coal.normal.data.tx_packets =\r\nethcoal->tx_max_coalesced_frames;\r\nnetxen_config_intr_coalesce(adapter);\r\nreturn 0;\r\n}\r\nstatic int netxen_get_intr_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ethcoal)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(netdev);\r\nif (!NX_IS_REVISION_P3(adapter->ahw.revision_id))\r\nreturn -EINVAL;\r\nif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\r\nreturn -EINVAL;\r\nethcoal->rx_coalesce_usecs = adapter->coal.normal.data.rx_time_us;\r\nethcoal->tx_coalesce_usecs = adapter->coal.normal.data.tx_time_us;\r\nethcoal->rx_max_coalesced_frames =\r\nadapter->coal.normal.data.rx_packets;\r\nethcoal->tx_max_coalesced_frames =\r\nadapter->coal.normal.data.tx_packets;\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_get_dump_flag(struct net_device *netdev, struct ethtool_dump *dump)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(netdev);\r\nstruct netxen_minidump *mdump = &adapter->mdump;\r\nif (adapter->fw_mdump_rdy)\r\ndump->len = mdump->md_dump_size;\r\nelse\r\ndump->len = 0;\r\nif (!mdump->md_enabled)\r\ndump->flag = ETH_FW_DUMP_DISABLE;\r\nelse\r\ndump->flag = mdump->md_capture_mask;\r\ndump->version = adapter->fw_version;\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_set_dump(struct net_device *netdev, struct ethtool_dump *val)\r\n{\r\nint i;\r\nstruct netxen_adapter *adapter = netdev_priv(netdev);\r\nstruct netxen_minidump *mdump = &adapter->mdump;\r\nswitch (val->flag) {\r\ncase NX_FORCE_FW_DUMP_KEY:\r\nif (!mdump->md_enabled) {\r\nnetdev_info(netdev, "FW dump not enabled\n");\r\nreturn 0;\r\n}\r\nif (adapter->fw_mdump_rdy) {\r\nnetdev_info(netdev, "Previous dump not cleared, not forcing dump\n");\r\nreturn 0;\r\n}\r\nnetdev_info(netdev, "Forcing a fw dump\n");\r\nnx_dev_request_reset(adapter);\r\nbreak;\r\ncase NX_DISABLE_FW_DUMP:\r\nif (mdump->md_enabled) {\r\nnetdev_info(netdev, "Disabling FW Dump\n");\r\nmdump->md_enabled = 0;\r\n}\r\nbreak;\r\ncase NX_ENABLE_FW_DUMP:\r\nif (!mdump->md_enabled) {\r\nnetdev_info(netdev, "Enabling FW dump\n");\r\nmdump->md_enabled = 1;\r\n}\r\nbreak;\r\ncase NX_FORCE_FW_RESET:\r\nnetdev_info(netdev, "Forcing FW reset\n");\r\nnx_dev_request_reset(adapter);\r\nadapter->flags &= ~NETXEN_FW_RESET_OWNER;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i < ARRAY_SIZE(FW_DUMP_LEVELS); i++) {\r\nif (val->flag == FW_DUMP_LEVELS[i]) {\r\nmdump->md_capture_mask = val->flag;\r\nnetdev_info(netdev,\r\n"Driver mask changed to: 0x%x\n",\r\nmdump->md_capture_mask);\r\nreturn 0;\r\n}\r\n}\r\nnetdev_info(netdev,\r\n"Invalid dump level: 0x%x\n", val->flag);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_get_dump_data(struct net_device *netdev, struct ethtool_dump *dump,\r\nvoid *buffer)\r\n{\r\nint i, copy_sz;\r\nu32 *hdr_ptr, *data;\r\nstruct netxen_adapter *adapter = netdev_priv(netdev);\r\nstruct netxen_minidump *mdump = &adapter->mdump;\r\nif (!adapter->fw_mdump_rdy) {\r\nnetdev_info(netdev, "Dump not available\n");\r\nreturn -EINVAL;\r\n}\r\ncopy_sz = mdump->md_template_size;\r\nhdr_ptr = (u32 *) mdump->md_template;\r\ndata = buffer;\r\nfor (i = 0; i < copy_sz/sizeof(u32); i++)\r\n*data++ = cpu_to_le32(*hdr_ptr++);\r\nmemcpy(buffer + copy_sz,\r\nmdump->md_capture_buff + mdump->md_template_size,\r\nmdump->md_capture_size);\r\ndump->len = copy_sz + mdump->md_capture_size;\r\ndump->flag = mdump->md_capture_mask;\r\nvfree(mdump->md_capture_buff);\r\nmdump->md_capture_buff = NULL;\r\nadapter->fw_mdump_rdy = 0;\r\nnetdev_info(netdev, "extracted the fw dump Successfully\n");\r\nreturn 0;\r\n}
