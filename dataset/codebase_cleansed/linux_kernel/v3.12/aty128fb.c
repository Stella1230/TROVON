static inline u32 _aty_ld_le32(volatile unsigned int regindex,\r\nconst struct aty128fb_par *par)\r\n{\r\nreturn readl (par->regbase + regindex);\r\n}\r\nstatic inline void _aty_st_le32(volatile unsigned int regindex, u32 val,\r\nconst struct aty128fb_par *par)\r\n{\r\nwritel (val, par->regbase + regindex);\r\n}\r\nstatic inline u8 _aty_ld_8(unsigned int regindex,\r\nconst struct aty128fb_par *par)\r\n{\r\nreturn readb (par->regbase + regindex);\r\n}\r\nstatic inline void _aty_st_8(unsigned int regindex, u8 val,\r\nconst struct aty128fb_par *par)\r\n{\r\nwriteb (val, par->regbase + regindex);\r\n}\r\nstatic u32 _aty_ld_pll(unsigned int pll_index,\r\nconst struct aty128fb_par *par)\r\n{\r\naty_st_8(CLOCK_CNTL_INDEX, pll_index & 0x3F);\r\nreturn aty_ld_le32(CLOCK_CNTL_DATA);\r\n}\r\nstatic void _aty_st_pll(unsigned int pll_index, u32 val,\r\nconst struct aty128fb_par *par)\r\n{\r\naty_st_8(CLOCK_CNTL_INDEX, (pll_index & 0x3F) | PLL_WR_EN);\r\naty_st_le32(CLOCK_CNTL_DATA, val);\r\n}\r\nstatic int aty_pll_readupdate(const struct aty128fb_par *par)\r\n{\r\nreturn !(aty_ld_pll(PPLL_REF_DIV) & PPLL_ATOMIC_UPDATE_R);\r\n}\r\nstatic void aty_pll_wait_readupdate(const struct aty128fb_par *par)\r\n{\r\nunsigned long timeout = jiffies + HZ/100;\r\nint reset = 1;\r\nwhile (time_before(jiffies, timeout))\r\nif (aty_pll_readupdate(par)) {\r\nreset = 0;\r\nbreak;\r\n}\r\nif (reset)\r\nprintk(KERN_DEBUG "aty128fb: PLL write timeout!\n");\r\n}\r\nstatic void aty_pll_writeupdate(const struct aty128fb_par *par)\r\n{\r\naty_pll_wait_readupdate(par);\r\naty_st_pll(PPLL_REF_DIV,\r\naty_ld_pll(PPLL_REF_DIV) | PPLL_ATOMIC_UPDATE_W);\r\n}\r\nstatic int register_test(const struct aty128fb_par *par)\r\n{\r\nu32 val;\r\nint flag = 0;\r\nval = aty_ld_le32(BIOS_0_SCRATCH);\r\naty_st_le32(BIOS_0_SCRATCH, 0x55555555);\r\nif (aty_ld_le32(BIOS_0_SCRATCH) == 0x55555555) {\r\naty_st_le32(BIOS_0_SCRATCH, 0xAAAAAAAA);\r\nif (aty_ld_le32(BIOS_0_SCRATCH) == 0xAAAAAAAA)\r\nflag = 1;\r\n}\r\naty_st_le32(BIOS_0_SCRATCH, val);\r\nreturn flag;\r\n}\r\nstatic void do_wait_for_fifo(u16 entries, struct aty128fb_par *par)\r\n{\r\nint i;\r\nfor (;;) {\r\nfor (i = 0; i < 2000000; i++) {\r\npar->fifo_slots = aty_ld_le32(GUI_STAT) & 0x0fff;\r\nif (par->fifo_slots >= entries)\r\nreturn;\r\n}\r\naty128_reset_engine(par);\r\n}\r\n}\r\nstatic void wait_for_idle(struct aty128fb_par *par)\r\n{\r\nint i;\r\ndo_wait_for_fifo(64, par);\r\nfor (;;) {\r\nfor (i = 0; i < 2000000; i++) {\r\nif (!(aty_ld_le32(GUI_STAT) & (1 << 31))) {\r\naty128_flush_pixel_cache(par);\r\npar->blitter_may_be_busy = 0;\r\nreturn;\r\n}\r\n}\r\naty128_reset_engine(par);\r\n}\r\n}\r\nstatic void wait_for_fifo(u16 entries, struct aty128fb_par *par)\r\n{\r\nif (par->fifo_slots < entries)\r\ndo_wait_for_fifo(64, par);\r\npar->fifo_slots -= entries;\r\n}\r\nstatic void aty128_flush_pixel_cache(const struct aty128fb_par *par)\r\n{\r\nint i;\r\nu32 tmp;\r\ntmp = aty_ld_le32(PC_NGUI_CTLSTAT);\r\ntmp &= ~(0x00ff);\r\ntmp |= 0x00ff;\r\naty_st_le32(PC_NGUI_CTLSTAT, tmp);\r\nfor (i = 0; i < 2000000; i++)\r\nif (!(aty_ld_le32(PC_NGUI_CTLSTAT) & PC_BUSY))\r\nbreak;\r\n}\r\nstatic void aty128_reset_engine(const struct aty128fb_par *par)\r\n{\r\nu32 gen_reset_cntl, clock_cntl_index, mclk_cntl;\r\naty128_flush_pixel_cache(par);\r\nclock_cntl_index = aty_ld_le32(CLOCK_CNTL_INDEX);\r\nmclk_cntl = aty_ld_pll(MCLK_CNTL);\r\naty_st_pll(MCLK_CNTL, mclk_cntl | 0x00030000);\r\ngen_reset_cntl = aty_ld_le32(GEN_RESET_CNTL);\r\naty_st_le32(GEN_RESET_CNTL, gen_reset_cntl | SOFT_RESET_GUI);\r\naty_ld_le32(GEN_RESET_CNTL);\r\naty_st_le32(GEN_RESET_CNTL, gen_reset_cntl & ~(SOFT_RESET_GUI));\r\naty_ld_le32(GEN_RESET_CNTL);\r\naty_st_pll(MCLK_CNTL, mclk_cntl);\r\naty_st_le32(CLOCK_CNTL_INDEX, clock_cntl_index);\r\naty_st_le32(GEN_RESET_CNTL, gen_reset_cntl);\r\naty_st_le32(PM4_BUFFER_CNTL, PM4_BUFFER_CNTL_NONPM4);\r\nDBG("engine reset");\r\n}\r\nstatic void aty128_init_engine(struct aty128fb_par *par)\r\n{\r\nu32 pitch_value;\r\nwait_for_idle(par);\r\nwait_for_fifo(1, par);\r\naty_st_le32(SCALE_3D_CNTL, 0x00000000);\r\naty128_reset_engine(par);\r\npitch_value = par->crtc.pitch;\r\nif (par->crtc.bpp == 24) {\r\npitch_value = pitch_value * 3;\r\n}\r\nwait_for_fifo(4, par);\r\naty_st_le32(DEFAULT_OFFSET, 0x00000000);\r\naty_st_le32(DEFAULT_PITCH, pitch_value);\r\naty_st_le32(DEFAULT_SC_BOTTOM_RIGHT, (0x1FFF << 16) | 0x1FFF);\r\naty_st_le32(DP_GUI_MASTER_CNTL,\r\nGMC_SRC_PITCH_OFFSET_DEFAULT |\r\nGMC_DST_PITCH_OFFSET_DEFAULT |\r\nGMC_SRC_CLIP_DEFAULT |\r\nGMC_DST_CLIP_DEFAULT |\r\nGMC_BRUSH_SOLIDCOLOR |\r\n(depth_to_dst(par->crtc.depth) << 8) |\r\nGMC_SRC_DSTCOLOR |\r\nGMC_BYTE_ORDER_MSB_TO_LSB |\r\nGMC_DP_CONVERSION_TEMP_6500 |\r\nROP3_PATCOPY |\r\nGMC_DP_SRC_RECT |\r\nGMC_3D_FCN_EN_CLR |\r\nGMC_DST_CLR_CMP_FCN_CLEAR |\r\nGMC_AUX_CLIP_CLEAR |\r\nGMC_WRITE_MASK_SET);\r\nwait_for_fifo(8, par);\r\naty_st_le32(DST_BRES_ERR, 0);\r\naty_st_le32(DST_BRES_INC, 0);\r\naty_st_le32(DST_BRES_DEC, 0);\r\naty_st_le32(DP_BRUSH_FRGD_CLR, 0xFFFFFFFF);\r\naty_st_le32(DP_BRUSH_BKGD_CLR, 0x00000000);\r\naty_st_le32(DP_SRC_FRGD_CLR, 0xFFFFFFFF);\r\naty_st_le32(DP_SRC_BKGD_CLR, 0x00000000);\r\naty_st_le32(DP_WRITE_MASK, 0xFFFFFFFF);\r\nwait_for_idle(par);\r\n}\r\nstatic u32 depth_to_dst(u32 depth)\r\n{\r\nif (depth <= 8)\r\nreturn DST_8BPP;\r\nelse if (depth <= 15)\r\nreturn DST_15BPP;\r\nelse if (depth == 16)\r\nreturn DST_16BPP;\r\nelse if (depth <= 24)\r\nreturn DST_24BPP;\r\nelse if (depth <= 32)\r\nreturn DST_32BPP;\r\nreturn -EINVAL;\r\n}\r\nstatic void __iomem *aty128_map_ROM(const struct aty128fb_par *par,\r\nstruct pci_dev *dev)\r\n{\r\nu16 dptr;\r\nu8 rom_type;\r\nvoid __iomem *bios;\r\nsize_t rom_size;\r\nunsigned int temp;\r\ntemp = aty_ld_le32(RAGE128_MPP_TB_CONFIG);\r\ntemp &= 0x00ffffffu;\r\ntemp |= 0x04 << 24;\r\naty_st_le32(RAGE128_MPP_TB_CONFIG, temp);\r\ntemp = aty_ld_le32(RAGE128_MPP_TB_CONFIG);\r\nbios = pci_map_rom(dev, &rom_size);\r\nif (!bios) {\r\nprintk(KERN_ERR "aty128fb: ROM failed to map\n");\r\nreturn NULL;\r\n}\r\nif (BIOS_IN16(0) != 0xaa55) {\r\nprintk(KERN_DEBUG "aty128fb: Invalid ROM signature %x should "\r\n" be 0xaa55\n", BIOS_IN16(0));\r\ngoto failed;\r\n}\r\ndptr = BIOS_IN16(0x18);\r\nif (BIOS_IN32(dptr) != (('R' << 24) | ('I' << 16) | ('C' << 8) | 'P')) {\r\nprintk(KERN_WARNING "aty128fb: PCI DATA signature in ROM incorrect: %08x\n",\r\nBIOS_IN32(dptr));\r\ngoto anyway;\r\n}\r\nrom_type = BIOS_IN8(dptr + 0x14);\r\nswitch(rom_type) {\r\ncase 0:\r\nprintk(KERN_INFO "aty128fb: Found Intel x86 BIOS ROM Image\n");\r\nbreak;\r\ncase 1:\r\nprintk(KERN_INFO "aty128fb: Found Open Firmware ROM Image\n");\r\ngoto failed;\r\ncase 2:\r\nprintk(KERN_INFO "aty128fb: Found HP PA-RISC ROM Image\n");\r\ngoto failed;\r\ndefault:\r\nprintk(KERN_INFO "aty128fb: Found unknown type %d ROM Image\n",\r\nrom_type);\r\ngoto failed;\r\n}\r\nanyway:\r\nreturn bios;\r\nfailed:\r\npci_unmap_rom(dev, bios);\r\nreturn NULL;\r\n}\r\nstatic void aty128_get_pllinfo(struct aty128fb_par *par,\r\nunsigned char __iomem *bios)\r\n{\r\nunsigned int bios_hdr;\r\nunsigned int bios_pll;\r\nbios_hdr = BIOS_IN16(0x48);\r\nbios_pll = BIOS_IN16(bios_hdr + 0x30);\r\npar->constants.ppll_max = BIOS_IN32(bios_pll + 0x16);\r\npar->constants.ppll_min = BIOS_IN32(bios_pll + 0x12);\r\npar->constants.xclk = BIOS_IN16(bios_pll + 0x08);\r\npar->constants.ref_divider = BIOS_IN16(bios_pll + 0x10);\r\npar->constants.ref_clk = BIOS_IN16(bios_pll + 0x0e);\r\nDBG("ppll_max %d ppll_min %d xclk %d ref_divider %d ref clock %d\n",\r\npar->constants.ppll_max, par->constants.ppll_min,\r\npar->constants.xclk, par->constants.ref_divider,\r\npar->constants.ref_clk);\r\n}\r\nstatic void __iomem *aty128_find_mem_vbios(struct aty128fb_par *par)\r\n{\r\nu32 segstart;\r\nunsigned char __iomem *rom_base = NULL;\r\nfor (segstart=0x000c0000; segstart<0x000f0000; segstart+=0x00001000) {\r\nrom_base = ioremap(segstart, 0x10000);\r\nif (rom_base == NULL)\r\nreturn NULL;\r\nif (readb(rom_base) == 0x55 && readb(rom_base + 1) == 0xaa)\r\nbreak;\r\niounmap(rom_base);\r\nrom_base = NULL;\r\n}\r\nreturn rom_base;\r\n}\r\nstatic void aty128_timings(struct aty128fb_par *par)\r\n{\r\n#ifdef CONFIG_PPC_OF\r\nu32 x_mpll_ref_fb_div;\r\nu32 xclk_cntl;\r\nu32 Nx, M;\r\nunsigned PostDivSet[] = { 0, 1, 2, 4, 8, 3, 6, 12 };\r\n#endif\r\nif (!par->constants.ref_clk)\r\npar->constants.ref_clk = 2950;\r\n#ifdef CONFIG_PPC_OF\r\nx_mpll_ref_fb_div = aty_ld_pll(X_MPLL_REF_FB_DIV);\r\nxclk_cntl = aty_ld_pll(XCLK_CNTL) & 0x7;\r\nNx = (x_mpll_ref_fb_div & 0x00ff00) >> 8;\r\nM = x_mpll_ref_fb_div & 0x0000ff;\r\npar->constants.xclk = round_div((2 * Nx * par->constants.ref_clk),\r\n(M * PostDivSet[xclk_cntl]));\r\npar->constants.ref_divider =\r\naty_ld_pll(PPLL_REF_DIV) & PPLL_REF_DIV_MASK;\r\n#endif\r\nif (!par->constants.ref_divider) {\r\npar->constants.ref_divider = 0x3b;\r\naty_st_pll(X_MPLL_REF_FB_DIV, 0x004c4c1e);\r\naty_pll_writeupdate(par);\r\n}\r\naty_st_pll(PPLL_REF_DIV, par->constants.ref_divider);\r\naty_pll_writeupdate(par);\r\nif (!par->constants.ppll_min)\r\npar->constants.ppll_min = 12500;\r\nif (!par->constants.ppll_max)\r\npar->constants.ppll_max = 25000;\r\nif (!par->constants.xclk)\r\npar->constants.xclk = 0x1d4d;\r\npar->constants.fifo_width = 128;\r\npar->constants.fifo_depth = 32;\r\nswitch (aty_ld_le32(MEM_CNTL) & 0x3) {\r\ncase 0:\r\npar->mem = &sdr_128;\r\nbreak;\r\ncase 1:\r\npar->mem = &sdr_sgram;\r\nbreak;\r\ncase 2:\r\npar->mem = &ddr_sgram;\r\nbreak;\r\ndefault:\r\npar->mem = &sdr_sgram;\r\n}\r\n}\r\nstatic void aty128_set_crtc(const struct aty128_crtc *crtc,\r\nconst struct aty128fb_par *par)\r\n{\r\naty_st_le32(CRTC_GEN_CNTL, crtc->gen_cntl);\r\naty_st_le32(CRTC_H_TOTAL_DISP, crtc->h_total);\r\naty_st_le32(CRTC_H_SYNC_STRT_WID, crtc->h_sync_strt_wid);\r\naty_st_le32(CRTC_V_TOTAL_DISP, crtc->v_total);\r\naty_st_le32(CRTC_V_SYNC_STRT_WID, crtc->v_sync_strt_wid);\r\naty_st_le32(CRTC_PITCH, crtc->pitch);\r\naty_st_le32(CRTC_OFFSET, crtc->offset);\r\naty_st_le32(CRTC_OFFSET_CNTL, crtc->offset_cntl);\r\naty_st_pll(PPLL_CNTL, aty_ld_pll(PPLL_CNTL) & ~(0x00030000));\r\n}\r\nstatic int aty128_var_to_crtc(const struct fb_var_screeninfo *var,\r\nstruct aty128_crtc *crtc,\r\nconst struct aty128fb_par *par)\r\n{\r\nu32 xres, yres, vxres, vyres, xoffset, yoffset, bpp, dst;\r\nu32 left, right, upper, lower, hslen, vslen, sync, vmode;\r\nu32 h_total, h_disp, h_sync_strt, h_sync_wid, h_sync_pol;\r\nu32 v_total, v_disp, v_sync_strt, v_sync_wid, v_sync_pol, c_sync;\r\nu32 depth, bytpp;\r\nu8 mode_bytpp[7] = { 0, 0, 1, 2, 2, 3, 4 };\r\nxres = var->xres;\r\nyres = var->yres;\r\nvxres = var->xres_virtual;\r\nvyres = var->yres_virtual;\r\nxoffset = var->xoffset;\r\nyoffset = var->yoffset;\r\nbpp = var->bits_per_pixel;\r\nleft = var->left_margin;\r\nright = var->right_margin;\r\nupper = var->upper_margin;\r\nlower = var->lower_margin;\r\nhslen = var->hsync_len;\r\nvslen = var->vsync_len;\r\nsync = var->sync;\r\nvmode = var->vmode;\r\nif (bpp != 16)\r\ndepth = bpp;\r\nelse\r\ndepth = (var->green.length == 6) ? 16 : 15;\r\nif ((vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)\r\nreturn -EINVAL;\r\nxres = (xres + 7) & ~7;\r\nxoffset = (xoffset + 7) & ~7;\r\nif (vxres < xres + xoffset)\r\nvxres = xres + xoffset;\r\nif (vyres < yres + yoffset)\r\nvyres = yres + yoffset;\r\ndst = depth_to_dst(depth);\r\nif (dst == -EINVAL) {\r\nprintk(KERN_ERR "aty128fb: Invalid depth or RGBA\n");\r\nreturn -EINVAL;\r\n}\r\nbytpp = mode_bytpp[dst];\r\nif ((u32)(vxres * vyres * bytpp) > par->vram_size) {\r\nprintk(KERN_ERR "aty128fb: Not enough memory for mode\n");\r\nreturn -EINVAL;\r\n}\r\nh_disp = (xres >> 3) - 1;\r\nh_total = (((xres + right + hslen + left) >> 3) - 1) & 0xFFFFL;\r\nv_disp = yres - 1;\r\nv_total = (yres + upper + vslen + lower - 1) & 0xFFFFL;\r\nif (((h_total >> 3) - 1) > 0x1ff || (v_total - 1) > 0x7FF) {\r\nprintk(KERN_ERR "aty128fb: invalid width ranges\n");\r\nreturn -EINVAL;\r\n}\r\nh_sync_wid = (hslen + 7) >> 3;\r\nif (h_sync_wid == 0)\r\nh_sync_wid = 1;\r\nelse if (h_sync_wid > 0x3f)\r\nh_sync_wid = 0x3f;\r\nh_sync_strt = (h_disp << 3) + right;\r\nv_sync_wid = vslen;\r\nif (v_sync_wid == 0)\r\nv_sync_wid = 1;\r\nelse if (v_sync_wid > 0x1f)\r\nv_sync_wid = 0x1f;\r\nv_sync_strt = v_disp + lower;\r\nh_sync_pol = sync & FB_SYNC_HOR_HIGH_ACT ? 0 : 1;\r\nv_sync_pol = sync & FB_SYNC_VERT_HIGH_ACT ? 0 : 1;\r\nc_sync = sync & FB_SYNC_COMP_HIGH_ACT ? (1 << 4) : 0;\r\ncrtc->gen_cntl = 0x3000000L | c_sync | (dst << 8);\r\ncrtc->h_total = h_total | (h_disp << 16);\r\ncrtc->v_total = v_total | (v_disp << 16);\r\ncrtc->h_sync_strt_wid = h_sync_strt | (h_sync_wid << 16) |\r\n(h_sync_pol << 23);\r\ncrtc->v_sync_strt_wid = v_sync_strt | (v_sync_wid << 16) |\r\n(v_sync_pol << 23);\r\ncrtc->pitch = vxres >> 3;\r\ncrtc->offset = 0;\r\nif ((var->activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW)\r\ncrtc->offset_cntl = 0x00010000;\r\nelse\r\ncrtc->offset_cntl = 0;\r\ncrtc->vxres = vxres;\r\ncrtc->vyres = vyres;\r\ncrtc->xoffset = xoffset;\r\ncrtc->yoffset = yoffset;\r\ncrtc->depth = depth;\r\ncrtc->bpp = bpp;\r\nreturn 0;\r\n}\r\nstatic int aty128_pix_width_to_var(int pix_width, struct fb_var_screeninfo *var)\r\n{\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.offset = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->transp.msb_right = 0;\r\nswitch (pix_width) {\r\ncase CRTC_PIX_WIDTH_8BPP:\r\nvar->bits_per_pixel = 8;\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 0;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nbreak;\r\ncase CRTC_PIX_WIDTH_15BPP:\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 10;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 5;\r\nvar->blue.length = 5;\r\nbreak;\r\ncase CRTC_PIX_WIDTH_16BPP:\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.length = 5;\r\nbreak;\r\ncase CRTC_PIX_WIDTH_24BPP:\r\nvar->bits_per_pixel = 24;\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nbreak;\r\ncase CRTC_PIX_WIDTH_32BPP:\r\nvar->bits_per_pixel = 32;\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "aty128fb: Invalid pixel width\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aty128_crtc_to_var(const struct aty128_crtc *crtc,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nu32 xres, yres, left, right, upper, lower, hslen, vslen, sync;\r\nu32 h_total, h_disp, h_sync_strt, h_sync_dly, h_sync_wid, h_sync_pol;\r\nu32 v_total, v_disp, v_sync_strt, v_sync_wid, v_sync_pol, c_sync;\r\nu32 pix_width;\r\nh_total = crtc->h_total & 0x1ff;\r\nh_disp = (crtc->h_total >> 16) & 0xff;\r\nh_sync_strt = (crtc->h_sync_strt_wid >> 3) & 0x1ff;\r\nh_sync_dly = crtc->h_sync_strt_wid & 0x7;\r\nh_sync_wid = (crtc->h_sync_strt_wid >> 16) & 0x3f;\r\nh_sync_pol = (crtc->h_sync_strt_wid >> 23) & 0x1;\r\nv_total = crtc->v_total & 0x7ff;\r\nv_disp = (crtc->v_total >> 16) & 0x7ff;\r\nv_sync_strt = crtc->v_sync_strt_wid & 0x7ff;\r\nv_sync_wid = (crtc->v_sync_strt_wid >> 16) & 0x1f;\r\nv_sync_pol = (crtc->v_sync_strt_wid >> 23) & 0x1;\r\nc_sync = crtc->gen_cntl & CRTC_CSYNC_EN ? 1 : 0;\r\npix_width = crtc->gen_cntl & CRTC_PIX_WIDTH_MASK;\r\nxres = (h_disp + 1) << 3;\r\nyres = v_disp + 1;\r\nleft = ((h_total - h_sync_strt - h_sync_wid) << 3) - h_sync_dly;\r\nright = ((h_sync_strt - h_disp) << 3) + h_sync_dly;\r\nhslen = h_sync_wid << 3;\r\nupper = v_total - v_sync_strt - v_sync_wid;\r\nlower = v_sync_strt - v_disp;\r\nvslen = v_sync_wid;\r\nsync = (h_sync_pol ? 0 : FB_SYNC_HOR_HIGH_ACT) |\r\n(v_sync_pol ? 0 : FB_SYNC_VERT_HIGH_ACT) |\r\n(c_sync ? FB_SYNC_COMP_HIGH_ACT : 0);\r\naty128_pix_width_to_var(pix_width, var);\r\nvar->xres = xres;\r\nvar->yres = yres;\r\nvar->xres_virtual = crtc->vxres;\r\nvar->yres_virtual = crtc->vyres;\r\nvar->xoffset = crtc->xoffset;\r\nvar->yoffset = crtc->yoffset;\r\nvar->left_margin = left;\r\nvar->right_margin = right;\r\nvar->upper_margin = upper;\r\nvar->lower_margin = lower;\r\nvar->hsync_len = hslen;\r\nvar->vsync_len = vslen;\r\nvar->sync = sync;\r\nvar->vmode = FB_VMODE_NONINTERLACED;\r\nreturn 0;\r\n}\r\nstatic void aty128_set_crt_enable(struct aty128fb_par *par, int on)\r\n{\r\nif (on) {\r\naty_st_le32(CRTC_EXT_CNTL, aty_ld_le32(CRTC_EXT_CNTL) |\r\nCRT_CRTC_ON);\r\naty_st_le32(DAC_CNTL, (aty_ld_le32(DAC_CNTL) |\r\nDAC_PALETTE2_SNOOP_EN));\r\n} else\r\naty_st_le32(CRTC_EXT_CNTL, aty_ld_le32(CRTC_EXT_CNTL) &\r\n~CRT_CRTC_ON);\r\n}\r\nstatic void aty128_set_lcd_enable(struct aty128fb_par *par, int on)\r\n{\r\nu32 reg;\r\n#ifdef CONFIG_FB_ATY128_BACKLIGHT\r\nstruct fb_info *info = pci_get_drvdata(par->pdev);\r\n#endif\r\nif (on) {\r\nreg = aty_ld_le32(LVDS_GEN_CNTL);\r\nreg |= LVDS_ON | LVDS_EN | LVDS_BLON | LVDS_DIGION;\r\nreg &= ~LVDS_DISPLAY_DIS;\r\naty_st_le32(LVDS_GEN_CNTL, reg);\r\n#ifdef CONFIG_FB_ATY128_BACKLIGHT\r\naty128_bl_set_power(info, FB_BLANK_UNBLANK);\r\n#endif\r\n} else {\r\n#ifdef CONFIG_FB_ATY128_BACKLIGHT\r\naty128_bl_set_power(info, FB_BLANK_POWERDOWN);\r\n#endif\r\nreg = aty_ld_le32(LVDS_GEN_CNTL);\r\nreg |= LVDS_DISPLAY_DIS;\r\naty_st_le32(LVDS_GEN_CNTL, reg);\r\nmdelay(100);\r\nreg &= ~(LVDS_ON );\r\naty_st_le32(LVDS_GEN_CNTL, reg);\r\n}\r\n}\r\nstatic void aty128_set_pll(struct aty128_pll *pll,\r\nconst struct aty128fb_par *par)\r\n{\r\nu32 div3;\r\nunsigned char post_conv[] =\r\n{ 2, 0, 1, 4, 2, 2, 6, 2, 3, 2, 2, 2, 7 };\r\naty_st_le32(CLOCK_CNTL_INDEX, aty_ld_le32(CLOCK_CNTL_INDEX) | (3 << 8));\r\naty_st_pll(PPLL_CNTL,\r\naty_ld_pll(PPLL_CNTL) | PPLL_RESET | PPLL_ATOMIC_UPDATE_EN);\r\naty_pll_wait_readupdate(par);\r\naty_st_pll(PPLL_REF_DIV, par->constants.ref_divider & 0x3ff);\r\naty_pll_writeupdate(par);\r\ndiv3 = aty_ld_pll(PPLL_DIV_3);\r\ndiv3 &= ~PPLL_FB3_DIV_MASK;\r\ndiv3 |= pll->feedback_divider;\r\ndiv3 &= ~PPLL_POST3_DIV_MASK;\r\ndiv3 |= post_conv[pll->post_divider] << 16;\r\naty_pll_wait_readupdate(par);\r\naty_st_pll(PPLL_DIV_3, div3);\r\naty_pll_writeupdate(par);\r\naty_pll_wait_readupdate(par);\r\naty_st_pll(HTOTAL_CNTL, 0);\r\naty_pll_writeupdate(par);\r\naty_st_pll(PPLL_CNTL, aty_ld_pll(PPLL_CNTL) & ~PPLL_RESET);\r\n}\r\nstatic int aty128_var_to_pll(u32 period_in_ps, struct aty128_pll *pll,\r\nconst struct aty128fb_par *par)\r\n{\r\nconst struct aty128_constants c = par->constants;\r\nunsigned char post_dividers[] = {1,2,4,8,3,6,12};\r\nu32 output_freq;\r\nu32 vclk;\r\nint i = 0;\r\nu32 n, d;\r\nvclk = 100000000 / period_in_ps;\r\nif (vclk > c.ppll_max)\r\nvclk = c.ppll_max;\r\nif (vclk * 12 < c.ppll_min)\r\nvclk = c.ppll_min/12;\r\nfor (i = 0; i < ARRAY_SIZE(post_dividers); i++) {\r\noutput_freq = post_dividers[i] * vclk;\r\nif (output_freq >= c.ppll_min && output_freq <= c.ppll_max) {\r\npll->post_divider = post_dividers[i];\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(post_dividers))\r\nreturn -EINVAL;\r\nn = c.ref_divider * output_freq;\r\nd = c.ref_clk;\r\npll->feedback_divider = round_div(n, d);\r\npll->vclk = vclk;\r\nDBG("post %d feedback %d vlck %d output %d ref_divider %d "\r\n"vclk_per: %d\n", pll->post_divider,\r\npll->feedback_divider, vclk, output_freq,\r\nc.ref_divider, period_in_ps);\r\nreturn 0;\r\n}\r\nstatic int aty128_pll_to_var(const struct aty128_pll *pll,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nvar->pixclock = 100000000 / pll->vclk;\r\nreturn 0;\r\n}\r\nstatic void aty128_set_fifo(const struct aty128_ddafifo *dsp,\r\nconst struct aty128fb_par *par)\r\n{\r\naty_st_le32(DDA_CONFIG, dsp->dda_config);\r\naty_st_le32(DDA_ON_OFF, dsp->dda_on_off);\r\n}\r\nstatic int aty128_ddafifo(struct aty128_ddafifo *dsp,\r\nconst struct aty128_pll *pll,\r\nu32 depth,\r\nconst struct aty128fb_par *par)\r\n{\r\nconst struct aty128_meminfo *m = par->mem;\r\nu32 xclk = par->constants.xclk;\r\nu32 fifo_width = par->constants.fifo_width;\r\nu32 fifo_depth = par->constants.fifo_depth;\r\ns32 x, b, p, ron, roff;\r\nu32 n, d, bpp;\r\nbpp = (depth+7) & ~7;\r\nn = xclk * fifo_width;\r\nd = pll->vclk * bpp;\r\nx = round_div(n, d);\r\nron = 4 * m->MB +\r\n3 * ((m->Trcd - 2 > 0) ? m->Trcd - 2 : 0) +\r\n2 * m->Trp +\r\nm->Twr +\r\nm->CL +\r\nm->Tr2w +\r\nx;\r\nDBG("x %x\n", x);\r\nb = 0;\r\nwhile (x) {\r\nx >>= 1;\r\nb++;\r\n}\r\np = b + 1;\r\nron <<= (11 - p);\r\nn <<= (11 - p);\r\nx = round_div(n, d);\r\nroff = x * (fifo_depth - 4);\r\nif ((ron + m->Rloop) >= roff) {\r\nprintk(KERN_ERR "aty128fb: Mode out of range!\n");\r\nreturn -EINVAL;\r\n}\r\nDBG("p: %x rloop: %x x: %x ron: %x roff: %x\n",\r\np, m->Rloop, x, ron, roff);\r\ndsp->dda_config = p << 16 | m->Rloop << 20 | x;\r\ndsp->dda_on_off = ron << 16 | roff;\r\nreturn 0;\r\n}\r\nstatic int aty128fb_set_par(struct fb_info *info)\r\n{\r\nstruct aty128fb_par *par = info->par;\r\nu32 config;\r\nint err;\r\nif ((err = aty128_decode_var(&info->var, par)) != 0)\r\nreturn err;\r\nif (par->blitter_may_be_busy)\r\nwait_for_idle(par);\r\naty_st_le32(OVR_CLR, 0);\r\naty_st_le32(OVR_WID_LEFT_RIGHT, 0);\r\naty_st_le32(OVR_WID_TOP_BOTTOM, 0);\r\naty_st_le32(OV0_SCALE_CNTL, 0);\r\naty_st_le32(MPP_TB_CONFIG, 0);\r\naty_st_le32(MPP_GP_CONFIG, 0);\r\naty_st_le32(SUBPIC_CNTL, 0);\r\naty_st_le32(VIPH_CONTROL, 0);\r\naty_st_le32(I2C_CNTL_1, 0);\r\naty_st_le32(GEN_INT_CNTL, 0);\r\naty_st_le32(CAP0_TRIG_CNTL, 0);\r\naty_st_le32(CAP1_TRIG_CNTL, 0);\r\naty_st_8(CRTC_EXT_CNTL + 1, 4);\r\naty128_set_crtc(&par->crtc, par);\r\naty128_set_pll(&par->pll, par);\r\naty128_set_fifo(&par->fifo_reg, par);\r\nconfig = aty_ld_le32(CNFG_CNTL) & ~3;\r\n#if defined(__BIG_ENDIAN)\r\nif (par->crtc.bpp == 32)\r\nconfig |= 2;\r\nelse if (par->crtc.bpp == 16)\r\nconfig |= 1;\r\n#endif\r\naty_st_le32(CNFG_CNTL, config);\r\naty_st_8(CRTC_EXT_CNTL + 1, 0);\r\ninfo->fix.line_length = (par->crtc.vxres * par->crtc.bpp) >> 3;\r\ninfo->fix.visual = par->crtc.bpp == 8 ? FB_VISUAL_PSEUDOCOLOR\r\n: FB_VISUAL_DIRECTCOLOR;\r\nif (par->chip_gen == rage_M3) {\r\naty128_set_crt_enable(par, par->crt_on);\r\naty128_set_lcd_enable(par, par->lcd_on);\r\n}\r\nif (par->accel_flags & FB_ACCELF_TEXT)\r\naty128_init_engine(par);\r\n#ifdef CONFIG_BOOTX_TEXT\r\nbtext_update_display(info->fix.smem_start,\r\n(((par->crtc.h_total>>16) & 0xff)+1)*8,\r\n((par->crtc.v_total>>16) & 0x7ff)+1,\r\npar->crtc.bpp,\r\npar->crtc.vxres*par->crtc.bpp/8);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int aty128_decode_var(struct fb_var_screeninfo *var,\r\nstruct aty128fb_par *par)\r\n{\r\nint err;\r\nstruct aty128_crtc crtc;\r\nstruct aty128_pll pll;\r\nstruct aty128_ddafifo fifo_reg;\r\nif ((err = aty128_var_to_crtc(var, &crtc, par)))\r\nreturn err;\r\nif ((err = aty128_var_to_pll(var->pixclock, &pll, par)))\r\nreturn err;\r\nif ((err = aty128_ddafifo(&fifo_reg, &pll, crtc.depth, par)))\r\nreturn err;\r\npar->crtc = crtc;\r\npar->pll = pll;\r\npar->fifo_reg = fifo_reg;\r\npar->accel_flags = var->accel_flags;\r\nreturn 0;\r\n}\r\nstatic int aty128_encode_var(struct fb_var_screeninfo *var,\r\nconst struct aty128fb_par *par)\r\n{\r\nint err;\r\nif ((err = aty128_crtc_to_var(&par->crtc, var)))\r\nreturn err;\r\nif ((err = aty128_pll_to_var(&par->pll, var)))\r\nreturn err;\r\nvar->nonstd = 0;\r\nvar->activate = 0;\r\nvar->height = -1;\r\nvar->width = -1;\r\nvar->accel_flags = par->accel_flags;\r\nreturn 0;\r\n}\r\nstatic int aty128fb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct aty128fb_par par;\r\nint err;\r\npar = *(struct aty128fb_par *)info->par;\r\nif ((err = aty128_decode_var(var, &par)) != 0)\r\nreturn err;\r\naty128_encode_var(var, &par);\r\nreturn 0;\r\n}\r\nstatic int aty128fb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *fb)\r\n{\r\nstruct aty128fb_par *par = fb->par;\r\nu32 xoffset, yoffset;\r\nu32 offset;\r\nu32 xres, yres;\r\nxres = (((par->crtc.h_total >> 16) & 0xff) + 1) << 3;\r\nyres = ((par->crtc.v_total >> 16) & 0x7ff) + 1;\r\nxoffset = (var->xoffset +7) & ~7;\r\nyoffset = var->yoffset;\r\nif (xoffset+xres > par->crtc.vxres || yoffset+yres > par->crtc.vyres)\r\nreturn -EINVAL;\r\npar->crtc.xoffset = xoffset;\r\npar->crtc.yoffset = yoffset;\r\noffset = ((yoffset * par->crtc.vxres + xoffset) * (par->crtc.bpp >> 3))\r\n& ~7;\r\nif (par->crtc.bpp == 24)\r\noffset += 8 * (offset % 3);\r\naty_st_le32(CRTC_OFFSET, offset);\r\nreturn 0;\r\n}\r\nstatic void aty128_st_pal(u_int regno, u_int red, u_int green, u_int blue,\r\nstruct aty128fb_par *par)\r\n{\r\nif (par->chip_gen == rage_M3) {\r\n#if 0\r\naty_st_le32(DAC_CNTL, aty_ld_le32(DAC_CNTL) |\r\nDAC_PALETTE_ACCESS_CNTL);\r\naty_st_8(PALETTE_INDEX, regno);\r\naty_st_le32(PALETTE_DATA, (red<<16)|(green<<8)|blue);\r\n#endif\r\naty_st_le32(DAC_CNTL, aty_ld_le32(DAC_CNTL) &\r\n~DAC_PALETTE_ACCESS_CNTL);\r\n}\r\naty_st_8(PALETTE_INDEX, regno);\r\naty_st_le32(PALETTE_DATA, (red<<16)|(green<<8)|blue);\r\n}\r\nstatic int aty128fb_sync(struct fb_info *info)\r\n{\r\nstruct aty128fb_par *par = info->par;\r\nif (par->blitter_may_be_busy)\r\nwait_for_idle(par);\r\nreturn 0;\r\n}\r\nstatic int aty128fb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!strncmp(this_opt, "lcd:", 4)) {\r\ndefault_lcd_on = simple_strtoul(this_opt+4, NULL, 0);\r\ncontinue;\r\n} else if (!strncmp(this_opt, "crt:", 4)) {\r\ndefault_crt_on = simple_strtoul(this_opt+4, NULL, 0);\r\ncontinue;\r\n} else if (!strncmp(this_opt, "backlight:", 10)) {\r\nbacklight = simple_strtoul(this_opt+10, NULL, 0);\r\ncontinue;\r\n}\r\n#ifdef CONFIG_MTRR\r\nif(!strncmp(this_opt, "nomtrr", 6)) {\r\nmtrr = 0;\r\ncontinue;\r\n}\r\n#endif\r\n#ifdef CONFIG_PPC_PMAC\r\nif (!strncmp(this_opt, "vmode:", 6)) {\r\nunsigned int vmode = simple_strtoul(this_opt+6, NULL, 0);\r\nif (vmode > 0 && vmode <= VMODE_MAX)\r\ndefault_vmode = vmode;\r\ncontinue;\r\n} else if (!strncmp(this_opt, "cmode:", 6)) {\r\nunsigned int cmode = simple_strtoul(this_opt+6, NULL, 0);\r\nswitch (cmode) {\r\ncase 0:\r\ncase 8:\r\ndefault_cmode = CMODE_8;\r\nbreak;\r\ncase 15:\r\ncase 16:\r\ndefault_cmode = CMODE_16;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\ndefault_cmode = CMODE_32;\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\n#endif\r\nmode_option = this_opt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aty128_bl_get_level_brightness(struct aty128fb_par *par,\r\nint level)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(par->pdev);\r\nint atylevel;\r\natylevel = MAX_LEVEL -\r\n(info->bl_curve[level] * FB_BACKLIGHT_MAX / MAX_LEVEL);\r\nif (atylevel < 0)\r\natylevel = 0;\r\nelse if (atylevel > MAX_LEVEL)\r\natylevel = MAX_LEVEL;\r\nreturn atylevel;\r\n}\r\nstatic int aty128_bl_update_status(struct backlight_device *bd)\r\n{\r\nstruct aty128fb_par *par = bl_get_data(bd);\r\nunsigned int reg = aty_ld_le32(LVDS_GEN_CNTL);\r\nint level;\r\nif (bd->props.power != FB_BLANK_UNBLANK ||\r\nbd->props.fb_blank != FB_BLANK_UNBLANK ||\r\n!par->lcd_on)\r\nlevel = 0;\r\nelse\r\nlevel = bd->props.brightness;\r\nreg |= LVDS_BL_MOD_EN | LVDS_BLON;\r\nif (level > 0) {\r\nreg |= LVDS_DIGION;\r\nif (!(reg & LVDS_ON)) {\r\nreg &= ~LVDS_BLON;\r\naty_st_le32(LVDS_GEN_CNTL, reg);\r\naty_ld_le32(LVDS_GEN_CNTL);\r\nmdelay(10);\r\nreg |= LVDS_BLON;\r\naty_st_le32(LVDS_GEN_CNTL, reg);\r\n}\r\nreg &= ~LVDS_BL_MOD_LEVEL_MASK;\r\nreg |= (aty128_bl_get_level_brightness(par, level) <<\r\nLVDS_BL_MOD_LEVEL_SHIFT);\r\n#ifdef BACKLIGHT_LVDS_OFF\r\nreg |= LVDS_ON | LVDS_EN;\r\nreg &= ~LVDS_DISPLAY_DIS;\r\n#endif\r\naty_st_le32(LVDS_GEN_CNTL, reg);\r\n#ifdef BACKLIGHT_DAC_OFF\r\naty_st_le32(DAC_CNTL, aty_ld_le32(DAC_CNTL) & (~DAC_PDWN));\r\n#endif\r\n} else {\r\nreg &= ~LVDS_BL_MOD_LEVEL_MASK;\r\nreg |= (aty128_bl_get_level_brightness(par, 0) <<\r\nLVDS_BL_MOD_LEVEL_SHIFT);\r\n#ifdef BACKLIGHT_LVDS_OFF\r\nreg |= LVDS_DISPLAY_DIS;\r\naty_st_le32(LVDS_GEN_CNTL, reg);\r\naty_ld_le32(LVDS_GEN_CNTL);\r\nudelay(10);\r\nreg &= ~(LVDS_ON | LVDS_EN | LVDS_BLON | LVDS_DIGION);\r\n#endif\r\naty_st_le32(LVDS_GEN_CNTL, reg);\r\n#ifdef BACKLIGHT_DAC_OFF\r\naty_st_le32(DAC_CNTL, aty_ld_le32(DAC_CNTL) | DAC_PDWN);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic int aty128_bl_get_brightness(struct backlight_device *bd)\r\n{\r\nreturn bd->props.brightness;\r\n}\r\nstatic void aty128_bl_set_power(struct fb_info *info, int power)\r\n{\r\nif (info->bl_dev) {\r\ninfo->bl_dev->props.power = power;\r\nbacklight_update_status(info->bl_dev);\r\n}\r\n}\r\nstatic void aty128_bl_init(struct aty128fb_par *par)\r\n{\r\nstruct backlight_properties props;\r\nstruct fb_info *info = pci_get_drvdata(par->pdev);\r\nstruct backlight_device *bd;\r\nchar name[12];\r\nif (par->chip_gen != rage_M3)\r\nreturn;\r\n#ifdef CONFIG_PMAC_BACKLIGHT\r\nif (!pmac_has_backlight_type("ati"))\r\nreturn;\r\n#endif\r\nsnprintf(name, sizeof(name), "aty128bl%d", info->node);\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = FB_BACKLIGHT_LEVELS - 1;\r\nbd = backlight_device_register(name, info->dev, par, &aty128_bl_data,\r\n&props);\r\nif (IS_ERR(bd)) {\r\ninfo->bl_dev = NULL;\r\nprintk(KERN_WARNING "aty128: Backlight registration failed\n");\r\ngoto error;\r\n}\r\ninfo->bl_dev = bd;\r\nfb_bl_default_curve(info, 0,\r\n63 * FB_BACKLIGHT_MAX / MAX_LEVEL,\r\n219 * FB_BACKLIGHT_MAX / MAX_LEVEL);\r\nbd->props.brightness = bd->props.max_brightness;\r\nbd->props.power = FB_BLANK_UNBLANK;\r\nbacklight_update_status(bd);\r\nprintk("aty128: Backlight initialized (%s)\n", name);\r\nreturn;\r\nerror:\r\nreturn;\r\n}\r\nstatic void aty128_bl_exit(struct backlight_device *bd)\r\n{\r\nbacklight_device_unregister(bd);\r\nprintk("aty128: Backlight unloaded\n");\r\n}\r\nstatic void aty128_early_resume(void *data)\r\n{\r\nstruct aty128fb_par *par = data;\r\nif (!console_trylock())\r\nreturn;\r\npci_restore_state(par->pdev);\r\naty128_do_resume(par->pdev);\r\nconsole_unlock();\r\n}\r\nstatic int aty128_init(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pdev);\r\nstruct aty128fb_par *par = info->par;\r\nstruct fb_var_screeninfo var;\r\nchar video_card[50];\r\nu8 chip_rev;\r\nu32 dac;\r\nchip_rev = (aty_ld_le32(CNFG_CNTL) >> 16) & 0x1F;\r\nstrcpy(video_card, "Rage128 XX ");\r\nvideo_card[8] = ent->device >> 8;\r\nvideo_card[9] = ent->device & 0xFF;\r\nif (ent->driver_data < ARRAY_SIZE(r128_family))\r\nstrlcat(video_card, r128_family[ent->driver_data],\r\nsizeof(video_card));\r\nprintk(KERN_INFO "aty128fb: %s [chip rev 0x%x] ", video_card, chip_rev);\r\nif (par->vram_size % (1024 * 1024) == 0)\r\nprintk("%dM %s\n", par->vram_size / (1024*1024), par->mem->name);\r\nelse\r\nprintk("%dk %s\n", par->vram_size / 1024, par->mem->name);\r\npar->chip_gen = ent->driver_data;\r\ninfo->fbops = &aty128fb_ops;\r\ninfo->flags = FBINFO_FLAG_DEFAULT;\r\npar->lcd_on = default_lcd_on;\r\npar->crt_on = default_crt_on;\r\nvar = default_var;\r\n#ifdef CONFIG_PPC_PMAC\r\nif (machine_is(powermac)) {\r\nif (par->chip_gen == rage_M3) {\r\npmac_call_feature(PMAC_FTR_DEVICE_CAN_WAKE, NULL, 0, 1);\r\n#if 0\r\npmac_set_early_video_resume(aty128_early_resume, par);\r\n#endif\r\n}\r\nif (mode_option) {\r\nif (!mac_find_mode(&var, info, mode_option, 8))\r\nvar = default_var;\r\n} else {\r\nif (default_vmode <= 0 || default_vmode > VMODE_MAX)\r\ndefault_vmode = VMODE_1024_768_60;\r\nif (of_machine_is_compatible("PowerMac2,1") ||\r\nof_machine_is_compatible("PowerMac2,2") ||\r\nof_machine_is_compatible("PowerMac4,1"))\r\ndefault_vmode = VMODE_1024_768_75;\r\nif (of_machine_is_compatible("PowerBook2,2"))\r\ndefault_vmode = VMODE_800_600_60;\r\nif (of_machine_is_compatible("PowerBook3,1") ||\r\nof_machine_is_compatible("PowerBook4,1"))\r\ndefault_vmode = VMODE_1024_768_60;\r\nif (of_machine_is_compatible("PowerBook3,2"))\r\ndefault_vmode = VMODE_1152_768_60;\r\nif (default_cmode > 16)\r\ndefault_cmode = CMODE_32;\r\nelse if (default_cmode > 8)\r\ndefault_cmode = CMODE_16;\r\nelse\r\ndefault_cmode = CMODE_8;\r\nif (mac_vmode_to_var(default_vmode, default_cmode, &var))\r\nvar = default_var;\r\n}\r\n} else\r\n#endif\r\n{\r\nif (mode_option)\r\nif (fb_find_mode(&var, info, mode_option, NULL,\r\n0, &defaultmode, 8) == 0)\r\nvar = default_var;\r\n}\r\nvar.accel_flags &= ~FB_ACCELF_TEXT;\r\nif (aty128fb_check_var(&var, info)) {\r\nprintk(KERN_ERR "aty128fb: Cannot set default mode.\n");\r\nreturn 0;\r\n}\r\ndac = aty_ld_le32(DAC_CNTL);\r\ndac |= (DAC_8BIT_EN | DAC_RANGE_CNTL);\r\ndac |= DAC_MASK;\r\nif (par->chip_gen == rage_M3)\r\ndac |= DAC_PALETTE2_SNOOP_EN;\r\naty_st_le32(DAC_CNTL, dac);\r\naty_st_le32(BUS_CNTL, aty_ld_le32(BUS_CNTL) | BUS_MASTER_DIS);\r\ninfo->var = var;\r\nfb_alloc_cmap(&info->cmap, 256, 0);\r\nvar.activate = FB_ACTIVATE_NOW;\r\naty128_init_engine(par);\r\npar->pm_reg = pdev->pm_cap;\r\npar->pdev = pdev;\r\npar->asleep = 0;\r\npar->lock_blank = 0;\r\n#ifdef CONFIG_FB_ATY128_BACKLIGHT\r\nif (backlight)\r\naty128_bl_init(par);\r\n#endif\r\nif (register_framebuffer(info) < 0)\r\nreturn 0;\r\nprintk(KERN_INFO "fb%d: %s frame buffer device on %s\n",\r\ninfo->node, info->fix.id, video_card);\r\nreturn 1;\r\n}\r\nstatic int aty128_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nunsigned long fb_addr, reg_addr;\r\nstruct aty128fb_par *par;\r\nstruct fb_info *info;\r\nint err;\r\n#ifndef __sparc__\r\nvoid __iomem *bios = NULL;\r\n#endif\r\nif ((err = pci_enable_device(pdev))) {\r\nprintk(KERN_ERR "aty128fb: Cannot enable PCI device: %d\n",\r\nerr);\r\nreturn -ENODEV;\r\n}\r\nfb_addr = pci_resource_start(pdev, 0);\r\nif (!request_mem_region(fb_addr, pci_resource_len(pdev, 0),\r\n"aty128fb FB")) {\r\nprintk(KERN_ERR "aty128fb: cannot reserve frame "\r\n"buffer memory\n");\r\nreturn -ENODEV;\r\n}\r\nreg_addr = pci_resource_start(pdev, 2);\r\nif (!request_mem_region(reg_addr, pci_resource_len(pdev, 2),\r\n"aty128fb MMIO")) {\r\nprintk(KERN_ERR "aty128fb: cannot reserve MMIO region\n");\r\ngoto err_free_fb;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct aty128fb_par), &pdev->dev);\r\nif (info == NULL) {\r\nprintk(KERN_ERR "aty128fb: can't alloc fb_info_aty128\n");\r\ngoto err_free_mmio;\r\n}\r\npar = info->par;\r\ninfo->pseudo_palette = par->pseudo_palette;\r\ninfo->fix.mmio_start = reg_addr;\r\npar->regbase = pci_ioremap_bar(pdev, 2);\r\nif (!par->regbase)\r\ngoto err_free_info;\r\npar->vram_size = aty_ld_le32(CNFG_MEMSIZE) & 0x03FFFFFF;\r\ninfo->screen_base = ioremap(fb_addr, par->vram_size);\r\nif (!info->screen_base)\r\ngoto err_unmap_out;\r\ninfo->fix = aty128fb_fix;\r\ninfo->fix.smem_start = fb_addr;\r\ninfo->fix.smem_len = par->vram_size;\r\ninfo->fix.mmio_start = reg_addr;\r\nif (!register_test(par)) {\r\nprintk(KERN_ERR "aty128fb: Can't write to video register!\n");\r\ngoto err_out;\r\n}\r\n#ifndef __sparc__\r\nbios = aty128_map_ROM(par, pdev);\r\n#ifdef CONFIG_X86\r\nif (bios == NULL)\r\nbios = aty128_find_mem_vbios(par);\r\n#endif\r\nif (bios == NULL)\r\nprintk(KERN_INFO "aty128fb: BIOS not located, guessing timings.\n");\r\nelse {\r\nprintk(KERN_INFO "aty128fb: Rage128 BIOS located\n");\r\naty128_get_pllinfo(par, bios);\r\npci_unmap_rom(pdev, bios);\r\n}\r\n#endif\r\naty128_timings(par);\r\npci_set_drvdata(pdev, info);\r\nif (!aty128_init(pdev, ent))\r\ngoto err_out;\r\n#ifdef CONFIG_MTRR\r\nif (mtrr) {\r\npar->mtrr.vram = mtrr_add(info->fix.smem_start,\r\npar->vram_size, MTRR_TYPE_WRCOMB, 1);\r\npar->mtrr.vram_valid = 1;\r\nprintk(KERN_INFO "aty128fb: Rage128 MTRR set to ON\n");\r\n}\r\n#endif\r\nreturn 0;\r\nerr_out:\r\niounmap(info->screen_base);\r\nerr_unmap_out:\r\niounmap(par->regbase);\r\nerr_free_info:\r\nframebuffer_release(info);\r\nerr_free_mmio:\r\nrelease_mem_region(pci_resource_start(pdev, 2),\r\npci_resource_len(pdev, 2));\r\nerr_free_fb:\r\nrelease_mem_region(pci_resource_start(pdev, 0),\r\npci_resource_len(pdev, 0));\r\nreturn -ENODEV;\r\n}\r\nstatic void aty128_remove(struct pci_dev *pdev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pdev);\r\nstruct aty128fb_par *par;\r\nif (!info)\r\nreturn;\r\npar = info->par;\r\nunregister_framebuffer(info);\r\n#ifdef CONFIG_FB_ATY128_BACKLIGHT\r\naty128_bl_exit(info->bl_dev);\r\n#endif\r\n#ifdef CONFIG_MTRR\r\nif (par->mtrr.vram_valid)\r\nmtrr_del(par->mtrr.vram, info->fix.smem_start,\r\npar->vram_size);\r\n#endif\r\niounmap(par->regbase);\r\niounmap(info->screen_base);\r\nrelease_mem_region(pci_resource_start(pdev, 0),\r\npci_resource_len(pdev, 0));\r\nrelease_mem_region(pci_resource_start(pdev, 2),\r\npci_resource_len(pdev, 2));\r\nframebuffer_release(info);\r\n}\r\nstatic int aty128fb_blank(int blank, struct fb_info *fb)\r\n{\r\nstruct aty128fb_par *par = fb->par;\r\nu8 state;\r\nif (par->lock_blank || par->asleep)\r\nreturn 0;\r\nswitch (blank) {\r\ncase FB_BLANK_NORMAL:\r\nstate = 4;\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nstate = 6;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nstate = 5;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nstate = 7;\r\nbreak;\r\ncase FB_BLANK_UNBLANK:\r\ndefault:\r\nstate = 0;\r\nbreak;\r\n}\r\naty_st_8(CRTC_EXT_CNTL+1, state);\r\nif (par->chip_gen == rage_M3) {\r\naty128_set_crt_enable(par, par->crt_on && !blank);\r\naty128_set_lcd_enable(par, par->lcd_on && !blank);\r\n}\r\nreturn 0;\r\n}\r\nstatic int aty128fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nstruct aty128fb_par *par = info->par;\r\nif (regno > 255\r\n|| (par->crtc.depth == 16 && regno > 63)\r\n|| (par->crtc.depth == 15 && regno > 31))\r\nreturn 1;\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nif (regno < 16) {\r\nint i;\r\nu32 *pal = info->pseudo_palette;\r\nswitch (par->crtc.depth) {\r\ncase 15:\r\npal[regno] = (regno << 10) | (regno << 5) | regno;\r\nbreak;\r\ncase 16:\r\npal[regno] = (regno << 11) | (regno << 6) | regno;\r\nbreak;\r\ncase 24:\r\npal[regno] = (regno << 16) | (regno << 8) | regno;\r\nbreak;\r\ncase 32:\r\ni = (regno << 8) | regno;\r\npal[regno] = (i << 16) | i;\r\nbreak;\r\n}\r\n}\r\nif (par->crtc.depth == 16 && regno > 0) {\r\npar->green[regno] = green;\r\nif (regno < 32) {\r\npar->red[regno] = red;\r\npar->blue[regno] = blue;\r\naty128_st_pal(regno * 8, red, par->green[regno*2],\r\nblue, par);\r\n}\r\nred = par->red[regno/2];\r\nblue = par->blue[regno/2];\r\nregno <<= 2;\r\n} else if (par->crtc.bpp == 16)\r\nregno <<= 3;\r\naty128_st_pal(regno, red, green, blue, par);\r\nreturn 0;\r\n}\r\nstatic int aty128fb_ioctl(struct fb_info *info, u_int cmd, u_long arg)\r\n{\r\nstruct aty128fb_par *par = info->par;\r\nu32 value;\r\nint rc;\r\nswitch (cmd) {\r\ncase FBIO_ATY128_SET_MIRROR:\r\nif (par->chip_gen != rage_M3)\r\nreturn -EINVAL;\r\nrc = get_user(value, (__u32 __user *)arg);\r\nif (rc)\r\nreturn rc;\r\npar->lcd_on = (value & 0x01) != 0;\r\npar->crt_on = (value & 0x02) != 0;\r\nif (!par->crt_on && !par->lcd_on)\r\npar->lcd_on = 1;\r\naty128_set_crt_enable(par, par->crt_on);\r\naty128_set_lcd_enable(par, par->lcd_on);\r\nreturn 0;\r\ncase FBIO_ATY128_GET_MIRROR:\r\nif (par->chip_gen != rage_M3)\r\nreturn -EINVAL;\r\nvalue = (par->crt_on << 1) | par->lcd_on;\r\nreturn put_user(value, (__u32 __user *)arg);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void aty128_set_suspend(struct aty128fb_par *par, int suspend)\r\n{\r\nu32 pmgt;\r\nstruct pci_dev *pdev = par->pdev;\r\nif (!par->pm_reg)\r\nreturn;\r\nif (suspend) {\r\naty_st_le32(CRTC2_GEN_CNTL, aty_ld_le32(CRTC2_GEN_CNTL) &\r\n~(CRTC2_EN));\r\npmgt = 0x0c005407;\r\naty_st_pll(POWER_MANAGEMENT, pmgt);\r\n(void)aty_ld_pll(POWER_MANAGEMENT);\r\naty_st_le32(BUS_CNTL1, 0x00000010);\r\naty_st_le32(MEM_POWER_MISC, 0x0c830000);\r\nmdelay(100);\r\npci_set_power_state(pdev, PCI_D2);\r\n}\r\n}\r\nstatic int aty128_pci_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pdev);\r\nstruct aty128fb_par *par = info->par;\r\npci_save_state(pdev);\r\n#ifndef CONFIG_PPC_PMAC\r\nreturn 0;\r\n#endif\r\nif (state.event == pdev->dev.power.power_state.event)\r\nreturn 0;\r\nprintk(KERN_DEBUG "aty128fb: suspending...\n");\r\nconsole_lock();\r\nfb_set_suspend(info, 1);\r\nwait_for_idle(par);\r\naty128_reset_engine(par);\r\nwait_for_idle(par);\r\naty128fb_blank(FB_BLANK_POWERDOWN, info);\r\npar->asleep = 1;\r\npar->lock_blank = 1;\r\n#ifdef CONFIG_PPC_PMAC\r\npmac_suspend_agp_for_card(pdev);\r\n#endif\r\nif (state.event != PM_EVENT_ON)\r\naty128_set_suspend(par, 1);\r\nconsole_unlock();\r\npdev->dev.power.power_state = state;\r\nreturn 0;\r\n}\r\nstatic int aty128_do_resume(struct pci_dev *pdev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pdev);\r\nstruct aty128fb_par *par = info->par;\r\nif (pdev->dev.power.power_state.event == PM_EVENT_ON)\r\nreturn 0;\r\naty128_set_suspend(par, 0);\r\npar->asleep = 0;\r\naty128_reset_engine(par);\r\nwait_for_idle(par);\r\naty128fb_set_par(info);\r\nfb_pan_display(info, &info->var);\r\nfb_set_cmap(&info->cmap, info);\r\nfb_set_suspend(info, 0);\r\npar->lock_blank = 0;\r\naty128fb_blank(0, info);\r\n#ifdef CONFIG_PPC_PMAC\r\npmac_resume_agp_for_card(pdev);\r\n#endif\r\npdev->dev.power.power_state = PMSG_ON;\r\nprintk(KERN_DEBUG "aty128fb: resumed !\n");\r\nreturn 0;\r\n}\r\nstatic int aty128_pci_resume(struct pci_dev *pdev)\r\n{\r\nint rc;\r\nconsole_lock();\r\nrc = aty128_do_resume(pdev);\r\nconsole_unlock();\r\nreturn rc;\r\n}\r\nstatic int aty128fb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("aty128fb", &option))\r\nreturn -ENODEV;\r\naty128fb_setup(option);\r\n#endif\r\nreturn pci_register_driver(&aty128fb_driver);\r\n}\r\nstatic void __exit aty128fb_exit(void)\r\n{\r\npci_unregister_driver(&aty128fb_driver);\r\n}
