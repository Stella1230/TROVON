int cpu_is_not_present(int cpu)\r\n{\r\nreturn !CPU_ISSET_S(cpu, cpu_present_setsize, cpu_present_set);\r\n}\r\nint for_all_cpus(int (func)(struct thread_data *, struct core_data *, struct pkg_data *),\r\nstruct thread_data *thread_base, struct core_data *core_base, struct pkg_data *pkg_base)\r\n{\r\nint retval, pkg_no, core_no, thread_no;\r\nfor (pkg_no = 0; pkg_no < topo.num_packages; ++pkg_no) {\r\nfor (core_no = 0; core_no < topo.num_cores_per_pkg; ++core_no) {\r\nfor (thread_no = 0; thread_no <\r\ntopo.num_threads_per_core; ++thread_no) {\r\nstruct thread_data *t;\r\nstruct core_data *c;\r\nstruct pkg_data *p;\r\nt = GET_THREAD(thread_base, thread_no, core_no, pkg_no);\r\nif (cpu_is_not_present(t->cpu_id))\r\ncontinue;\r\nc = GET_CORE(core_base, core_no, pkg_no);\r\np = GET_PKG(pkg_base, pkg_no);\r\nretval = func(t, c, p);\r\nif (retval)\r\nreturn retval;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint cpu_migrate(int cpu)\r\n{\r\nCPU_ZERO_S(cpu_affinity_setsize, cpu_affinity_set);\r\nCPU_SET_S(cpu, cpu_affinity_setsize, cpu_affinity_set);\r\nif (sched_setaffinity(0, cpu_affinity_setsize, cpu_affinity_set) == -1)\r\nreturn -1;\r\nelse\r\nreturn 0;\r\n}\r\nint get_msr(int cpu, off_t offset, unsigned long long *msr)\r\n{\r\nssize_t retval;\r\nchar pathname[32];\r\nint fd;\r\nsprintf(pathname, "/dev/cpu/%d/msr", cpu);\r\nfd = open(pathname, O_RDONLY);\r\nif (fd < 0)\r\nreturn -1;\r\nretval = pread(fd, msr, sizeof *msr, offset);\r\nclose(fd);\r\nif (retval != sizeof *msr) {\r\nfprintf(stderr, "%s offset 0x%zx read failed\n", pathname, offset);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid print_header(void)\r\n{\r\nif (show_pkg)\r\noutp += sprintf(outp, "pk");\r\nif (show_pkg)\r\noutp += sprintf(outp, " ");\r\nif (show_core)\r\noutp += sprintf(outp, "cor");\r\nif (show_cpu)\r\noutp += sprintf(outp, " CPU");\r\nif (show_pkg || show_core || show_cpu)\r\noutp += sprintf(outp, " ");\r\nif (do_nhm_cstates)\r\noutp += sprintf(outp, " %%c0");\r\nif (has_aperf)\r\noutp += sprintf(outp, " GHz");\r\noutp += sprintf(outp, " TSC");\r\nif (do_smi)\r\noutp += sprintf(outp, " SMI");\r\nif (extra_delta_offset32)\r\noutp += sprintf(outp, " count 0x%03X", extra_delta_offset32);\r\nif (extra_delta_offset64)\r\noutp += sprintf(outp, " COUNT 0x%03X", extra_delta_offset64);\r\nif (extra_msr_offset32)\r\noutp += sprintf(outp, " MSR 0x%03X", extra_msr_offset32);\r\nif (extra_msr_offset64)\r\noutp += sprintf(outp, " MSR 0x%03X", extra_msr_offset64);\r\nif (do_nhm_cstates)\r\noutp += sprintf(outp, " %%c1");\r\nif (do_nhm_cstates)\r\noutp += sprintf(outp, " %%c3");\r\nif (do_nhm_cstates)\r\noutp += sprintf(outp, " %%c6");\r\nif (do_snb_cstates)\r\noutp += sprintf(outp, " %%c7");\r\nif (do_dts)\r\noutp += sprintf(outp, " CTMP");\r\nif (do_ptm)\r\noutp += sprintf(outp, " PTMP");\r\nif (do_snb_cstates)\r\noutp += sprintf(outp, " %%pc2");\r\nif (do_nhm_cstates)\r\noutp += sprintf(outp, " %%pc3");\r\nif (do_nhm_cstates)\r\noutp += sprintf(outp, " %%pc6");\r\nif (do_snb_cstates)\r\noutp += sprintf(outp, " %%pc7");\r\nif (do_c8_c9_c10) {\r\noutp += sprintf(outp, " %%pc8");\r\noutp += sprintf(outp, " %%pc9");\r\noutp += sprintf(outp, " %%pc10");\r\n}\r\nif (do_rapl & RAPL_PKG)\r\noutp += sprintf(outp, " Pkg_W");\r\nif (do_rapl & RAPL_CORES)\r\noutp += sprintf(outp, " Cor_W");\r\nif (do_rapl & RAPL_GFX)\r\noutp += sprintf(outp, " GFX_W");\r\nif (do_rapl & RAPL_DRAM)\r\noutp += sprintf(outp, " RAM_W");\r\nif (do_rapl & RAPL_PKG_PERF_STATUS)\r\noutp += sprintf(outp, " PKG_%%");\r\nif (do_rapl & RAPL_DRAM_PERF_STATUS)\r\noutp += sprintf(outp, " RAM_%%");\r\noutp += sprintf(outp, "\n");\r\n}\r\nint dump_counters(struct thread_data *t, struct core_data *c,\r\nstruct pkg_data *p)\r\n{\r\nfprintf(stderr, "t %p, c %p, p %p\n", t, c, p);\r\nif (t) {\r\nfprintf(stderr, "CPU: %d flags 0x%x\n", t->cpu_id, t->flags);\r\nfprintf(stderr, "TSC: %016llX\n", t->tsc);\r\nfprintf(stderr, "aperf: %016llX\n", t->aperf);\r\nfprintf(stderr, "mperf: %016llX\n", t->mperf);\r\nfprintf(stderr, "c1: %016llX\n", t->c1);\r\nfprintf(stderr, "msr0x%x: %08llX\n",\r\nextra_delta_offset32, t->extra_delta32);\r\nfprintf(stderr, "msr0x%x: %016llX\n",\r\nextra_delta_offset64, t->extra_delta64);\r\nfprintf(stderr, "msr0x%x: %08llX\n",\r\nextra_msr_offset32, t->extra_msr32);\r\nfprintf(stderr, "msr0x%x: %016llX\n",\r\nextra_msr_offset64, t->extra_msr64);\r\nif (do_smi)\r\nfprintf(stderr, "SMI: %08X\n", t->smi_count);\r\n}\r\nif (c) {\r\nfprintf(stderr, "core: %d\n", c->core_id);\r\nfprintf(stderr, "c3: %016llX\n", c->c3);\r\nfprintf(stderr, "c6: %016llX\n", c->c6);\r\nfprintf(stderr, "c7: %016llX\n", c->c7);\r\nfprintf(stderr, "DTS: %dC\n", c->core_temp_c);\r\n}\r\nif (p) {\r\nfprintf(stderr, "package: %d\n", p->package_id);\r\nfprintf(stderr, "pc2: %016llX\n", p->pc2);\r\nfprintf(stderr, "pc3: %016llX\n", p->pc3);\r\nfprintf(stderr, "pc6: %016llX\n", p->pc6);\r\nfprintf(stderr, "pc7: %016llX\n", p->pc7);\r\nfprintf(stderr, "pc8: %016llX\n", p->pc8);\r\nfprintf(stderr, "pc9: %016llX\n", p->pc9);\r\nfprintf(stderr, "pc10: %016llX\n", p->pc10);\r\nfprintf(stderr, "Joules PKG: %0X\n", p->energy_pkg);\r\nfprintf(stderr, "Joules COR: %0X\n", p->energy_cores);\r\nfprintf(stderr, "Joules GFX: %0X\n", p->energy_gfx);\r\nfprintf(stderr, "Joules RAM: %0X\n", p->energy_dram);\r\nfprintf(stderr, "Throttle PKG: %0X\n", p->rapl_pkg_perf_status);\r\nfprintf(stderr, "Throttle RAM: %0X\n", p->rapl_dram_perf_status);\r\nfprintf(stderr, "PTM: %dC\n", p->pkg_temp_c);\r\n}\r\nreturn 0;\r\n}\r\nint format_counters(struct thread_data *t, struct core_data *c,\r\nstruct pkg_data *p)\r\n{\r\ndouble interval_float;\r\nchar *fmt5, *fmt6;\r\nif (show_core_only && !(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))\r\nreturn 0;\r\nif (show_pkg_only && !(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\r\nreturn 0;\r\ninterval_float = tv_delta.tv_sec + tv_delta.tv_usec/1000000.0;\r\nif (t == &average.threads) {\r\nif (show_pkg)\r\noutp += sprintf(outp, " ");\r\nif (show_pkg && show_core)\r\noutp += sprintf(outp, " ");\r\nif (show_core)\r\noutp += sprintf(outp, " ");\r\nif (show_cpu)\r\noutp += sprintf(outp, " " " ");\r\n} else {\r\nif (show_pkg) {\r\nif (p)\r\noutp += sprintf(outp, "%2d", p->package_id);\r\nelse\r\noutp += sprintf(outp, " ");\r\n}\r\nif (show_pkg && show_core)\r\noutp += sprintf(outp, " ");\r\nif (show_core) {\r\nif (c)\r\noutp += sprintf(outp, "%3d", c->core_id);\r\nelse\r\noutp += sprintf(outp, " ");\r\n}\r\nif (show_cpu)\r\noutp += sprintf(outp, " %3d", t->cpu_id);\r\n}\r\nif (do_nhm_cstates) {\r\nif (show_pkg || show_core || show_cpu)\r\noutp += sprintf(outp, " ");\r\nif (!skip_c0)\r\noutp += sprintf(outp, "%6.2f", 100.0 * t->mperf/t->tsc);\r\nelse\r\noutp += sprintf(outp, " ****");\r\n}\r\nif (has_aperf) {\r\nif (!aperf_mperf_unstable) {\r\noutp += sprintf(outp, " %3.2f",\r\n1.0 * t->tsc / units * t->aperf /\r\nt->mperf / interval_float);\r\n} else {\r\nif (t->aperf > t->tsc || t->mperf > t->tsc) {\r\noutp += sprintf(outp, " ***");\r\n} else {\r\noutp += sprintf(outp, "%3.1f*",\r\n1.0 * t->tsc /\r\nunits * t->aperf /\r\nt->mperf / interval_float);\r\n}\r\n}\r\n}\r\noutp += sprintf(outp, "%5.2f", 1.0 * t->tsc/units/interval_float);\r\nif (do_smi)\r\noutp += sprintf(outp, "%4d", t->smi_count);\r\nif (extra_delta_offset32)\r\noutp += sprintf(outp, " %11llu", t->extra_delta32);\r\nif (extra_delta_offset64)\r\noutp += sprintf(outp, " %11llu", t->extra_delta64);\r\nif (extra_msr_offset32)\r\noutp += sprintf(outp, " 0x%08llx", t->extra_msr32);\r\nif (extra_msr_offset64)\r\noutp += sprintf(outp, " 0x%016llx", t->extra_msr64);\r\nif (do_nhm_cstates) {\r\nif (!skip_c1)\r\noutp += sprintf(outp, " %6.2f", 100.0 * t->c1/t->tsc);\r\nelse\r\noutp += sprintf(outp, " ****");\r\n}\r\nif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))\r\ngoto done;\r\nif (do_nhm_cstates)\r\noutp += sprintf(outp, " %6.2f", 100.0 * c->c3/t->tsc);\r\nif (do_nhm_cstates)\r\noutp += sprintf(outp, " %6.2f", 100.0 * c->c6/t->tsc);\r\nif (do_snb_cstates)\r\noutp += sprintf(outp, " %6.2f", 100.0 * c->c7/t->tsc);\r\nif (do_dts)\r\noutp += sprintf(outp, " %4d", c->core_temp_c);\r\nif (!(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\r\ngoto done;\r\nif (do_ptm)\r\noutp += sprintf(outp, " %4d", p->pkg_temp_c);\r\nif (do_snb_cstates)\r\noutp += sprintf(outp, " %6.2f", 100.0 * p->pc2/t->tsc);\r\nif (do_nhm_cstates)\r\noutp += sprintf(outp, " %6.2f", 100.0 * p->pc3/t->tsc);\r\nif (do_nhm_cstates)\r\noutp += sprintf(outp, " %6.2f", 100.0 * p->pc6/t->tsc);\r\nif (do_snb_cstates)\r\noutp += sprintf(outp, " %6.2f", 100.0 * p->pc7/t->tsc);\r\nif (do_c8_c9_c10) {\r\noutp += sprintf(outp, " %6.2f", 100.0 * p->pc8/t->tsc);\r\noutp += sprintf(outp, " %6.2f", 100.0 * p->pc9/t->tsc);\r\noutp += sprintf(outp, " %6.2f", 100.0 * p->pc10/t->tsc);\r\n}\r\nif (interval_float < rapl_joule_counter_range) {\r\nfmt5 = " %5.2f";\r\nfmt6 = " %6.2f";\r\n} else {\r\nfmt5 = " %3.0f**";\r\nfmt6 = " %4.0f**";\r\n}\r\nif (do_rapl & RAPL_PKG)\r\noutp += sprintf(outp, fmt6, p->energy_pkg * rapl_energy_units / interval_float);\r\nif (do_rapl & RAPL_CORES)\r\noutp += sprintf(outp, fmt6, p->energy_cores * rapl_energy_units / interval_float);\r\nif (do_rapl & RAPL_GFX)\r\noutp += sprintf(outp, fmt5, p->energy_gfx * rapl_energy_units / interval_float);\r\nif (do_rapl & RAPL_DRAM)\r\noutp += sprintf(outp, fmt5, p->energy_dram * rapl_energy_units / interval_float);\r\nif (do_rapl & RAPL_PKG_PERF_STATUS )\r\noutp += sprintf(outp, fmt5, 100.0 * p->rapl_pkg_perf_status * rapl_time_units / interval_float);\r\nif (do_rapl & RAPL_DRAM_PERF_STATUS )\r\noutp += sprintf(outp, fmt5, 100.0 * p->rapl_dram_perf_status * rapl_time_units / interval_float);\r\ndone:\r\noutp += sprintf(outp, "\n");\r\nreturn 0;\r\n}\r\nvoid flush_stdout()\r\n{\r\nfputs(output_buffer, stdout);\r\nfflush(stdout);\r\noutp = output_buffer;\r\n}\r\nvoid flush_stderr()\r\n{\r\nfputs(output_buffer, stderr);\r\noutp = output_buffer;\r\n}\r\nvoid format_all_counters(struct thread_data *t, struct core_data *c, struct pkg_data *p)\r\n{\r\nstatic int printed;\r\nif (!printed || !summary_only)\r\nprint_header();\r\nif (topo.num_cpus > 1)\r\nformat_counters(&average.threads, &average.cores,\r\n&average.packages);\r\nprinted = 1;\r\nif (summary_only)\r\nreturn;\r\nfor_all_cpus(format_counters, t, c, p);\r\n}\r\nvoid\r\ndelta_package(struct pkg_data *new, struct pkg_data *old)\r\n{\r\nold->pc2 = new->pc2 - old->pc2;\r\nold->pc3 = new->pc3 - old->pc3;\r\nold->pc6 = new->pc6 - old->pc6;\r\nold->pc7 = new->pc7 - old->pc7;\r\nold->pc8 = new->pc8 - old->pc8;\r\nold->pc9 = new->pc9 - old->pc9;\r\nold->pc10 = new->pc10 - old->pc10;\r\nold->pkg_temp_c = new->pkg_temp_c;\r\nDELTA_WRAP32(new->energy_pkg, old->energy_pkg);\r\nDELTA_WRAP32(new->energy_cores, old->energy_cores);\r\nDELTA_WRAP32(new->energy_gfx, old->energy_gfx);\r\nDELTA_WRAP32(new->energy_dram, old->energy_dram);\r\nDELTA_WRAP32(new->rapl_pkg_perf_status, old->rapl_pkg_perf_status);\r\nDELTA_WRAP32(new->rapl_dram_perf_status, old->rapl_dram_perf_status);\r\n}\r\nvoid\r\ndelta_core(struct core_data *new, struct core_data *old)\r\n{\r\nold->c3 = new->c3 - old->c3;\r\nold->c6 = new->c6 - old->c6;\r\nold->c7 = new->c7 - old->c7;\r\nold->core_temp_c = new->core_temp_c;\r\n}\r\nvoid\r\ndelta_thread(struct thread_data *new, struct thread_data *old,\r\nstruct core_data *core_delta)\r\n{\r\nold->tsc = new->tsc - old->tsc;\r\nif (old->tsc < (1000 * 1000)) {\r\nfprintf(stderr, "Insanely slow TSC rate, TSC stops in idle?\n");\r\nfprintf(stderr, "You can disable all c-states by booting with \"idle=poll\"\n");\r\nfprintf(stderr, "or just the deep ones with \"processor.max_cstate=1\"\n");\r\nexit(-3);\r\n}\r\nold->c1 = new->c1 - old->c1;\r\nif ((new->aperf > old->aperf) && (new->mperf > old->mperf)) {\r\nold->aperf = new->aperf - old->aperf;\r\nold->mperf = new->mperf - old->mperf;\r\n} else {\r\nif (!aperf_mperf_unstable) {\r\nfprintf(stderr, "%s: APERF or MPERF went backwards *\n", progname);\r\nfprintf(stderr, "* Frequency results do not cover entire interval *\n");\r\nfprintf(stderr, "* fix this by running Linux-2.6.30 or later *\n");\r\naperf_mperf_unstable = 1;\r\n}\r\nskip_c0 = 1;\r\nskip_c1 = 1;\r\n}\r\nif ((old->mperf + core_delta->c3 + core_delta->c6 + core_delta->c7) > old->tsc)\r\nold->c1 = 0;\r\nelse {\r\nold->c1 = old->tsc - old->mperf - core_delta->c3\r\n- core_delta->c6 - core_delta->c7;\r\n}\r\nif (old->mperf == 0) {\r\nif (verbose > 1) fprintf(stderr, "cpu%d MPERF 0!\n", old->cpu_id);\r\nold->mperf = 1;\r\n}\r\nold->extra_delta32 = new->extra_delta32 - old->extra_delta32;\r\nold->extra_delta32 &= 0xFFFFFFFF;\r\nold->extra_delta64 = new->extra_delta64 - old->extra_delta64;\r\nold->extra_msr32 = new->extra_msr32;\r\nold->extra_msr64 = new->extra_msr64;\r\nif (do_smi)\r\nold->smi_count = new->smi_count - old->smi_count;\r\n}\r\nint delta_cpu(struct thread_data *t, struct core_data *c,\r\nstruct pkg_data *p, struct thread_data *t2,\r\nstruct core_data *c2, struct pkg_data *p2)\r\n{\r\nif (t->flags & CPU_IS_FIRST_THREAD_IN_CORE)\r\ndelta_core(c, c2);\r\ndelta_thread(t, t2, c2);\r\nif (t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE)\r\ndelta_package(p, p2);\r\nreturn 0;\r\n}\r\nvoid clear_counters(struct thread_data *t, struct core_data *c, struct pkg_data *p)\r\n{\r\nt->tsc = 0;\r\nt->aperf = 0;\r\nt->mperf = 0;\r\nt->c1 = 0;\r\nt->smi_count = 0;\r\nt->extra_delta32 = 0;\r\nt->extra_delta64 = 0;\r\nt->flags = CPU_IS_FIRST_THREAD_IN_CORE | CPU_IS_FIRST_CORE_IN_PACKAGE;\r\nc->c3 = 0;\r\nc->c6 = 0;\r\nc->c7 = 0;\r\nc->core_temp_c = 0;\r\np->pc2 = 0;\r\np->pc3 = 0;\r\np->pc6 = 0;\r\np->pc7 = 0;\r\np->pc8 = 0;\r\np->pc9 = 0;\r\np->pc10 = 0;\r\np->energy_pkg = 0;\r\np->energy_dram = 0;\r\np->energy_cores = 0;\r\np->energy_gfx = 0;\r\np->rapl_pkg_perf_status = 0;\r\np->rapl_dram_perf_status = 0;\r\np->pkg_temp_c = 0;\r\n}\r\nint sum_counters(struct thread_data *t, struct core_data *c,\r\nstruct pkg_data *p)\r\n{\r\naverage.threads.tsc += t->tsc;\r\naverage.threads.aperf += t->aperf;\r\naverage.threads.mperf += t->mperf;\r\naverage.threads.c1 += t->c1;\r\naverage.threads.extra_delta32 += t->extra_delta32;\r\naverage.threads.extra_delta64 += t->extra_delta64;\r\nif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))\r\nreturn 0;\r\naverage.cores.c3 += c->c3;\r\naverage.cores.c6 += c->c6;\r\naverage.cores.c7 += c->c7;\r\naverage.cores.core_temp_c = MAX(average.cores.core_temp_c, c->core_temp_c);\r\nif (!(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\r\nreturn 0;\r\naverage.packages.pc2 += p->pc2;\r\naverage.packages.pc3 += p->pc3;\r\naverage.packages.pc6 += p->pc6;\r\naverage.packages.pc7 += p->pc7;\r\naverage.packages.pc8 += p->pc8;\r\naverage.packages.pc9 += p->pc9;\r\naverage.packages.pc10 += p->pc10;\r\naverage.packages.energy_pkg += p->energy_pkg;\r\naverage.packages.energy_dram += p->energy_dram;\r\naverage.packages.energy_cores += p->energy_cores;\r\naverage.packages.energy_gfx += p->energy_gfx;\r\naverage.packages.pkg_temp_c = MAX(average.packages.pkg_temp_c, p->pkg_temp_c);\r\naverage.packages.rapl_pkg_perf_status += p->rapl_pkg_perf_status;\r\naverage.packages.rapl_dram_perf_status += p->rapl_dram_perf_status;\r\nreturn 0;\r\n}\r\nvoid compute_average(struct thread_data *t, struct core_data *c,\r\nstruct pkg_data *p)\r\n{\r\nclear_counters(&average.threads, &average.cores, &average.packages);\r\nfor_all_cpus(sum_counters, t, c, p);\r\naverage.threads.tsc /= topo.num_cpus;\r\naverage.threads.aperf /= topo.num_cpus;\r\naverage.threads.mperf /= topo.num_cpus;\r\naverage.threads.c1 /= topo.num_cpus;\r\naverage.threads.extra_delta32 /= topo.num_cpus;\r\naverage.threads.extra_delta32 &= 0xFFFFFFFF;\r\naverage.threads.extra_delta64 /= topo.num_cpus;\r\naverage.cores.c3 /= topo.num_cores;\r\naverage.cores.c6 /= topo.num_cores;\r\naverage.cores.c7 /= topo.num_cores;\r\naverage.packages.pc2 /= topo.num_packages;\r\naverage.packages.pc3 /= topo.num_packages;\r\naverage.packages.pc6 /= topo.num_packages;\r\naverage.packages.pc7 /= topo.num_packages;\r\naverage.packages.pc8 /= topo.num_packages;\r\naverage.packages.pc9 /= topo.num_packages;\r\naverage.packages.pc10 /= topo.num_packages;\r\n}\r\nstatic unsigned long long rdtsc(void)\r\n{\r\nunsigned int low, high;\r\nasm volatile("rdtsc" : "=a" (low), "=d" (high));\r\nreturn low | ((unsigned long long)high) << 32;\r\n}\r\nint get_counters(struct thread_data *t, struct core_data *c, struct pkg_data *p)\r\n{\r\nint cpu = t->cpu_id;\r\nunsigned long long msr;\r\nif (cpu_migrate(cpu)) {\r\nfprintf(stderr, "Could not migrate to CPU %d\n", cpu);\r\nreturn -1;\r\n}\r\nt->tsc = rdtsc();\r\nif (has_aperf) {\r\nif (get_msr(cpu, MSR_IA32_APERF, &t->aperf))\r\nreturn -3;\r\nif (get_msr(cpu, MSR_IA32_MPERF, &t->mperf))\r\nreturn -4;\r\n}\r\nif (do_smi) {\r\nif (get_msr(cpu, MSR_SMI_COUNT, &msr))\r\nreturn -5;\r\nt->smi_count = msr & 0xFFFFFFFF;\r\n}\r\nif (extra_delta_offset32) {\r\nif (get_msr(cpu, extra_delta_offset32, &msr))\r\nreturn -5;\r\nt->extra_delta32 = msr & 0xFFFFFFFF;\r\n}\r\nif (extra_delta_offset64)\r\nif (get_msr(cpu, extra_delta_offset64, &t->extra_delta64))\r\nreturn -5;\r\nif (extra_msr_offset32) {\r\nif (get_msr(cpu, extra_msr_offset32, &msr))\r\nreturn -5;\r\nt->extra_msr32 = msr & 0xFFFFFFFF;\r\n}\r\nif (extra_msr_offset64)\r\nif (get_msr(cpu, extra_msr_offset64, &t->extra_msr64))\r\nreturn -5;\r\nif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))\r\nreturn 0;\r\nif (do_nhm_cstates) {\r\nif (get_msr(cpu, MSR_CORE_C3_RESIDENCY, &c->c3))\r\nreturn -6;\r\nif (get_msr(cpu, MSR_CORE_C6_RESIDENCY, &c->c6))\r\nreturn -7;\r\n}\r\nif (do_snb_cstates)\r\nif (get_msr(cpu, MSR_CORE_C7_RESIDENCY, &c->c7))\r\nreturn -8;\r\nif (do_dts) {\r\nif (get_msr(cpu, MSR_IA32_THERM_STATUS, &msr))\r\nreturn -9;\r\nc->core_temp_c = tcc_activation_temp - ((msr >> 16) & 0x7F);\r\n}\r\nif (!(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\r\nreturn 0;\r\nif (do_nhm_cstates) {\r\nif (get_msr(cpu, MSR_PKG_C3_RESIDENCY, &p->pc3))\r\nreturn -9;\r\nif (get_msr(cpu, MSR_PKG_C6_RESIDENCY, &p->pc6))\r\nreturn -10;\r\n}\r\nif (do_snb_cstates) {\r\nif (get_msr(cpu, MSR_PKG_C2_RESIDENCY, &p->pc2))\r\nreturn -11;\r\nif (get_msr(cpu, MSR_PKG_C7_RESIDENCY, &p->pc7))\r\nreturn -12;\r\n}\r\nif (do_c8_c9_c10) {\r\nif (get_msr(cpu, MSR_PKG_C8_RESIDENCY, &p->pc8))\r\nreturn -13;\r\nif (get_msr(cpu, MSR_PKG_C9_RESIDENCY, &p->pc9))\r\nreturn -13;\r\nif (get_msr(cpu, MSR_PKG_C10_RESIDENCY, &p->pc10))\r\nreturn -13;\r\n}\r\nif (do_rapl & RAPL_PKG) {\r\nif (get_msr(cpu, MSR_PKG_ENERGY_STATUS, &msr))\r\nreturn -13;\r\np->energy_pkg = msr & 0xFFFFFFFF;\r\n}\r\nif (do_rapl & RAPL_CORES) {\r\nif (get_msr(cpu, MSR_PP0_ENERGY_STATUS, &msr))\r\nreturn -14;\r\np->energy_cores = msr & 0xFFFFFFFF;\r\n}\r\nif (do_rapl & RAPL_DRAM) {\r\nif (get_msr(cpu, MSR_DRAM_ENERGY_STATUS, &msr))\r\nreturn -15;\r\np->energy_dram = msr & 0xFFFFFFFF;\r\n}\r\nif (do_rapl & RAPL_GFX) {\r\nif (get_msr(cpu, MSR_PP1_ENERGY_STATUS, &msr))\r\nreturn -16;\r\np->energy_gfx = msr & 0xFFFFFFFF;\r\n}\r\nif (do_rapl & RAPL_PKG_PERF_STATUS) {\r\nif (get_msr(cpu, MSR_PKG_PERF_STATUS, &msr))\r\nreturn -16;\r\np->rapl_pkg_perf_status = msr & 0xFFFFFFFF;\r\n}\r\nif (do_rapl & RAPL_DRAM_PERF_STATUS) {\r\nif (get_msr(cpu, MSR_DRAM_PERF_STATUS, &msr))\r\nreturn -16;\r\np->rapl_dram_perf_status = msr & 0xFFFFFFFF;\r\n}\r\nif (do_ptm) {\r\nif (get_msr(cpu, MSR_IA32_PACKAGE_THERM_STATUS, &msr))\r\nreturn -17;\r\np->pkg_temp_c = tcc_activation_temp - ((msr >> 16) & 0x7F);\r\n}\r\nreturn 0;\r\n}\r\nvoid print_verbose_header(void)\r\n{\r\nunsigned long long msr;\r\nunsigned int ratio;\r\nif (!do_nehalem_platform_info)\r\nreturn;\r\nget_msr(0, MSR_NHM_PLATFORM_INFO, &msr);\r\nfprintf(stderr, "cpu0: MSR_NHM_PLATFORM_INFO: 0x%08llx\n", msr);\r\nratio = (msr >> 40) & 0xFF;\r\nfprintf(stderr, "%d * %.0f = %.0f MHz max efficiency\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 8) & 0xFF;\r\nfprintf(stderr, "%d * %.0f = %.0f MHz TSC frequency\n",\r\nratio, bclk, ratio * bclk);\r\nget_msr(0, MSR_IA32_POWER_CTL, &msr);\r\nfprintf(stderr, "cpu0: MSR_IA32_POWER_CTL: 0x%08llx (C1E: %sabled)\n",\r\nmsr, msr & 0x2 ? "EN" : "DIS");\r\nif (!do_ivt_turbo_ratio_limit)\r\ngoto print_nhm_turbo_ratio_limits;\r\nget_msr(0, MSR_IVT_TURBO_RATIO_LIMIT, &msr);\r\nfprintf(stderr, "cpu0: MSR_IVT_TURBO_RATIO_LIMIT: 0x%08llx\n", msr);\r\nratio = (msr >> 56) & 0xFF;\r\nif (ratio)\r\nfprintf(stderr, "%d * %.0f = %.0f MHz max turbo 16 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 48) & 0xFF;\r\nif (ratio)\r\nfprintf(stderr, "%d * %.0f = %.0f MHz max turbo 15 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 40) & 0xFF;\r\nif (ratio)\r\nfprintf(stderr, "%d * %.0f = %.0f MHz max turbo 14 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 32) & 0xFF;\r\nif (ratio)\r\nfprintf(stderr, "%d * %.0f = %.0f MHz max turbo 13 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 24) & 0xFF;\r\nif (ratio)\r\nfprintf(stderr, "%d * %.0f = %.0f MHz max turbo 12 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 16) & 0xFF;\r\nif (ratio)\r\nfprintf(stderr, "%d * %.0f = %.0f MHz max turbo 11 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 8) & 0xFF;\r\nif (ratio)\r\nfprintf(stderr, "%d * %.0f = %.0f MHz max turbo 10 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 0) & 0xFF;\r\nif (ratio)\r\nfprintf(stderr, "%d * %.0f = %.0f MHz max turbo 9 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nprint_nhm_turbo_ratio_limits:\r\nget_msr(0, MSR_NHM_SNB_PKG_CST_CFG_CTL, &msr);\r\n#define SNB_C1_AUTO_UNDEMOTE (1UL << 27)\r\n#define SNB_C3_AUTO_UNDEMOTE (1UL << 28)\r\nfprintf(stderr, "cpu0: MSR_NHM_SNB_PKG_CST_CFG_CTL: 0x%08llx", msr);\r\nfprintf(stderr, " (%s%s%s%s%slocked: pkg-cstate-limit=%d: ",\r\n(msr & SNB_C3_AUTO_UNDEMOTE) ? "UNdemote-C3, " : "",\r\n(msr & SNB_C1_AUTO_UNDEMOTE) ? "UNdemote-C1, " : "",\r\n(msr & NHM_C3_AUTO_DEMOTE) ? "demote-C3, " : "",\r\n(msr & NHM_C1_AUTO_DEMOTE) ? "demote-C1, " : "",\r\n(msr & (1 << 15)) ? "" : "UN",\r\n(unsigned int)msr & 7);\r\nswitch(msr & 0x7) {\r\ncase 0:\r\nfprintf(stderr, "pc0");\r\nbreak;\r\ncase 1:\r\nfprintf(stderr, do_snb_cstates ? "pc2" : "pc0");\r\nbreak;\r\ncase 2:\r\nfprintf(stderr, do_snb_cstates ? "pc6-noret" : "pc3");\r\nbreak;\r\ncase 3:\r\nfprintf(stderr, "pc6");\r\nbreak;\r\ncase 4:\r\nfprintf(stderr, "pc7");\r\nbreak;\r\ncase 5:\r\nfprintf(stderr, do_snb_cstates ? "pc7s" : "invalid");\r\nbreak;\r\ncase 7:\r\nfprintf(stderr, "unlimited");\r\nbreak;\r\ndefault:\r\nfprintf(stderr, "invalid");\r\n}\r\nfprintf(stderr, ")\n");\r\nif (!do_nehalem_turbo_ratio_limit)\r\nreturn;\r\nget_msr(0, MSR_NHM_TURBO_RATIO_LIMIT, &msr);\r\nfprintf(stderr, "cpu0: MSR_NHM_TURBO_RATIO_LIMIT: 0x%08llx\n", msr);\r\nratio = (msr >> 56) & 0xFF;\r\nif (ratio)\r\nfprintf(stderr, "%d * %.0f = %.0f MHz max turbo 8 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 48) & 0xFF;\r\nif (ratio)\r\nfprintf(stderr, "%d * %.0f = %.0f MHz max turbo 7 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 40) & 0xFF;\r\nif (ratio)\r\nfprintf(stderr, "%d * %.0f = %.0f MHz max turbo 6 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 32) & 0xFF;\r\nif (ratio)\r\nfprintf(stderr, "%d * %.0f = %.0f MHz max turbo 5 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 24) & 0xFF;\r\nif (ratio)\r\nfprintf(stderr, "%d * %.0f = %.0f MHz max turbo 4 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 16) & 0xFF;\r\nif (ratio)\r\nfprintf(stderr, "%d * %.0f = %.0f MHz max turbo 3 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 8) & 0xFF;\r\nif (ratio)\r\nfprintf(stderr, "%d * %.0f = %.0f MHz max turbo 2 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 0) & 0xFF;\r\nif (ratio)\r\nfprintf(stderr, "%d * %.0f = %.0f MHz max turbo 1 active cores\n",\r\nratio, bclk, ratio * bclk);\r\n}\r\nvoid free_all_buffers(void)\r\n{\r\nCPU_FREE(cpu_present_set);\r\ncpu_present_set = NULL;\r\ncpu_present_set = 0;\r\nCPU_FREE(cpu_affinity_set);\r\ncpu_affinity_set = NULL;\r\ncpu_affinity_setsize = 0;\r\nfree(thread_even);\r\nfree(core_even);\r\nfree(package_even);\r\nthread_even = NULL;\r\ncore_even = NULL;\r\npackage_even = NULL;\r\nfree(thread_odd);\r\nfree(core_odd);\r\nfree(package_odd);\r\nthread_odd = NULL;\r\ncore_odd = NULL;\r\npackage_odd = NULL;\r\nfree(output_buffer);\r\noutput_buffer = NULL;\r\noutp = NULL;\r\n}\r\nint cpu_is_first_sibling_in_core(int cpu)\r\n{\r\nchar path[64];\r\nFILE *filep;\r\nint first_cpu;\r\nsprintf(path, "/sys/devices/system/cpu/cpu%d/topology/thread_siblings_list", cpu);\r\nfilep = fopen(path, "r");\r\nif (filep == NULL) {\r\nperror(path);\r\nexit(1);\r\n}\r\nfscanf(filep, "%d", &first_cpu);\r\nfclose(filep);\r\nreturn (cpu == first_cpu);\r\n}\r\nint cpu_is_first_core_in_package(int cpu)\r\n{\r\nchar path[64];\r\nFILE *filep;\r\nint first_cpu;\r\nsprintf(path, "/sys/devices/system/cpu/cpu%d/topology/core_siblings_list", cpu);\r\nfilep = fopen(path, "r");\r\nif (filep == NULL) {\r\nperror(path);\r\nexit(1);\r\n}\r\nfscanf(filep, "%d", &first_cpu);\r\nfclose(filep);\r\nreturn (cpu == first_cpu);\r\n}\r\nint get_physical_package_id(int cpu)\r\n{\r\nchar path[80];\r\nFILE *filep;\r\nint pkg;\r\nsprintf(path, "/sys/devices/system/cpu/cpu%d/topology/physical_package_id", cpu);\r\nfilep = fopen(path, "r");\r\nif (filep == NULL) {\r\nperror(path);\r\nexit(1);\r\n}\r\nfscanf(filep, "%d", &pkg);\r\nfclose(filep);\r\nreturn pkg;\r\n}\r\nint get_core_id(int cpu)\r\n{\r\nchar path[80];\r\nFILE *filep;\r\nint core;\r\nsprintf(path, "/sys/devices/system/cpu/cpu%d/topology/core_id", cpu);\r\nfilep = fopen(path, "r");\r\nif (filep == NULL) {\r\nperror(path);\r\nexit(1);\r\n}\r\nfscanf(filep, "%d", &core);\r\nfclose(filep);\r\nreturn core;\r\n}\r\nint get_num_ht_siblings(int cpu)\r\n{\r\nchar path[80];\r\nFILE *filep;\r\nint sib1, sib2;\r\nint matches;\r\nchar character;\r\nsprintf(path, "/sys/devices/system/cpu/cpu%d/topology/thread_siblings_list", cpu);\r\nfilep = fopen(path, "r");\r\nif (filep == NULL) {\r\nperror(path);\r\nexit(1);\r\n}\r\nmatches = fscanf(filep, "%d%c%d\n", &sib1, &character, &sib2);\r\nfclose(filep);\r\nif (matches == 3)\r\nreturn 2;\r\nelse\r\nreturn 1;\r\n}\r\nint for_all_cpus_2(int (func)(struct thread_data *, struct core_data *,\r\nstruct pkg_data *, struct thread_data *, struct core_data *,\r\nstruct pkg_data *), struct thread_data *thread_base,\r\nstruct core_data *core_base, struct pkg_data *pkg_base,\r\nstruct thread_data *thread_base2, struct core_data *core_base2,\r\nstruct pkg_data *pkg_base2)\r\n{\r\nint retval, pkg_no, core_no, thread_no;\r\nfor (pkg_no = 0; pkg_no < topo.num_packages; ++pkg_no) {\r\nfor (core_no = 0; core_no < topo.num_cores_per_pkg; ++core_no) {\r\nfor (thread_no = 0; thread_no <\r\ntopo.num_threads_per_core; ++thread_no) {\r\nstruct thread_data *t, *t2;\r\nstruct core_data *c, *c2;\r\nstruct pkg_data *p, *p2;\r\nt = GET_THREAD(thread_base, thread_no, core_no, pkg_no);\r\nif (cpu_is_not_present(t->cpu_id))\r\ncontinue;\r\nt2 = GET_THREAD(thread_base2, thread_no, core_no, pkg_no);\r\nc = GET_CORE(core_base, core_no, pkg_no);\r\nc2 = GET_CORE(core_base2, core_no, pkg_no);\r\np = GET_PKG(pkg_base, pkg_no);\r\np2 = GET_PKG(pkg_base2, pkg_no);\r\nretval = func(t, c, p, t2, c2, p2);\r\nif (retval)\r\nreturn retval;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint for_all_proc_cpus(int (func)(int))\r\n{\r\nFILE *fp;\r\nint cpu_num;\r\nint retval;\r\nfp = fopen(proc_stat, "r");\r\nif (fp == NULL) {\r\nperror(proc_stat);\r\nexit(1);\r\n}\r\nretval = fscanf(fp, "cpu %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d\n");\r\nif (retval != 0) {\r\nperror("/proc/stat format");\r\nexit(1);\r\n}\r\nwhile (1) {\r\nretval = fscanf(fp, "cpu%u %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d\n", &cpu_num);\r\nif (retval != 1)\r\nbreak;\r\nretval = func(cpu_num);\r\nif (retval) {\r\nfclose(fp);\r\nreturn(retval);\r\n}\r\n}\r\nfclose(fp);\r\nreturn 0;\r\n}\r\nvoid re_initialize(void)\r\n{\r\nfree_all_buffers();\r\nsetup_all_buffers();\r\nprintf("turbostat: re-initialized with num_cpus %d\n", topo.num_cpus);\r\n}\r\nint count_cpus(int cpu)\r\n{\r\nif (topo.max_cpu_num < cpu)\r\ntopo.max_cpu_num = cpu;\r\ntopo.num_cpus += 1;\r\nreturn 0;\r\n}\r\nint mark_cpu_present(int cpu)\r\n{\r\nCPU_SET_S(cpu, cpu_present_setsize, cpu_present_set);\r\nreturn 0;\r\n}\r\nvoid turbostat_loop()\r\n{\r\nint retval;\r\nint restarted = 0;\r\nrestart:\r\nrestarted++;\r\nretval = for_all_cpus(get_counters, EVEN_COUNTERS);\r\nif (retval < -1) {\r\nexit(retval);\r\n} else if (retval == -1) {\r\nif (restarted > 1) {\r\nexit(retval);\r\n}\r\nre_initialize();\r\ngoto restart;\r\n}\r\nrestarted = 0;\r\ngettimeofday(&tv_even, (struct timezone *)NULL);\r\nwhile (1) {\r\nif (for_all_proc_cpus(cpu_is_not_present)) {\r\nre_initialize();\r\ngoto restart;\r\n}\r\nsleep(interval_sec);\r\nretval = for_all_cpus(get_counters, ODD_COUNTERS);\r\nif (retval < -1) {\r\nexit(retval);\r\n} else if (retval == -1) {\r\nre_initialize();\r\ngoto restart;\r\n}\r\ngettimeofday(&tv_odd, (struct timezone *)NULL);\r\ntimersub(&tv_odd, &tv_even, &tv_delta);\r\nfor_all_cpus_2(delta_cpu, ODD_COUNTERS, EVEN_COUNTERS);\r\ncompute_average(EVEN_COUNTERS);\r\nformat_all_counters(EVEN_COUNTERS);\r\nflush_stdout();\r\nsleep(interval_sec);\r\nretval = for_all_cpus(get_counters, EVEN_COUNTERS);\r\nif (retval < -1) {\r\nexit(retval);\r\n} else if (retval == -1) {\r\nre_initialize();\r\ngoto restart;\r\n}\r\ngettimeofday(&tv_even, (struct timezone *)NULL);\r\ntimersub(&tv_even, &tv_odd, &tv_delta);\r\nfor_all_cpus_2(delta_cpu, EVEN_COUNTERS, ODD_COUNTERS);\r\ncompute_average(ODD_COUNTERS);\r\nformat_all_counters(ODD_COUNTERS);\r\nflush_stdout();\r\n}\r\n}\r\nvoid check_dev_msr()\r\n{\r\nstruct stat sb;\r\nif (stat("/dev/cpu/0/msr", &sb)) {\r\nfprintf(stderr, "no /dev/cpu/0/msr\n");\r\nfprintf(stderr, "Try \"# modprobe msr\"\n");\r\nexit(-5);\r\n}\r\n}\r\nvoid check_super_user()\r\n{\r\nif (getuid() != 0) {\r\nfprintf(stderr, "must be root\n");\r\nexit(-6);\r\n}\r\n}\r\nint has_nehalem_turbo_ratio_limit(unsigned int family, unsigned int model)\r\n{\r\nif (!genuine_intel)\r\nreturn 0;\r\nif (family != 6)\r\nreturn 0;\r\nswitch (model) {\r\ncase 0x1A:\r\ncase 0x1E:\r\ncase 0x1F:\r\ncase 0x25:\r\ncase 0x2C:\r\ncase 0x2A:\r\ncase 0x2D:\r\ncase 0x3A:\r\ncase 0x3E:\r\ncase 0x3C:\r\ncase 0x3F:\r\ncase 0x45:\r\ncase 0x46:\r\nreturn 1;\r\ncase 0x2E:\r\ncase 0x2F:\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nint has_ivt_turbo_ratio_limit(unsigned int family, unsigned int model)\r\n{\r\nif (!genuine_intel)\r\nreturn 0;\r\nif (family != 6)\r\nreturn 0;\r\nswitch (model) {\r\ncase 0x3E:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nint print_epb(struct thread_data *t, struct core_data *c, struct pkg_data *p)\r\n{\r\nunsigned long long msr;\r\nchar *epb_string;\r\nint cpu;\r\nif (!has_epb)\r\nreturn 0;\r\ncpu = t->cpu_id;\r\nif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE) || !(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\r\nreturn 0;\r\nif (cpu_migrate(cpu)) {\r\nfprintf(stderr, "Could not migrate to CPU %d\n", cpu);\r\nreturn -1;\r\n}\r\nif (get_msr(cpu, MSR_IA32_ENERGY_PERF_BIAS, &msr))\r\nreturn 0;\r\nswitch (msr & 0x7) {\r\ncase ENERGY_PERF_BIAS_PERFORMANCE:\r\nepb_string = "performance";\r\nbreak;\r\ncase ENERGY_PERF_BIAS_NORMAL:\r\nepb_string = "balanced";\r\nbreak;\r\ncase ENERGY_PERF_BIAS_POWERSAVE:\r\nepb_string = "powersave";\r\nbreak;\r\ndefault:\r\nepb_string = "custom";\r\nbreak;\r\n}\r\nfprintf(stderr, "cpu%d: MSR_IA32_ENERGY_PERF_BIAS: 0x%08llx (%s)\n", cpu, msr, epb_string);\r\nreturn 0;\r\n}\r\nvoid rapl_probe(unsigned int family, unsigned int model)\r\n{\r\nunsigned long long msr;\r\ndouble tdp;\r\nif (!genuine_intel)\r\nreturn;\r\nif (family != 6)\r\nreturn;\r\nswitch (model) {\r\ncase 0x2A:\r\ncase 0x3A:\r\ncase 0x3C:\r\ncase 0x3F:\r\ncase 0x45:\r\ncase 0x46:\r\ndo_rapl = RAPL_PKG | RAPL_CORES | RAPL_GFX;\r\nbreak;\r\ncase 0x2D:\r\ncase 0x3E:\r\ndo_rapl = RAPL_PKG | RAPL_CORES | RAPL_DRAM | RAPL_PKG_PERF_STATUS | RAPL_DRAM_PERF_STATUS;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (get_msr(0, MSR_RAPL_POWER_UNIT, &msr))\r\nreturn;\r\nrapl_power_units = 1.0 / (1 << (msr & 0xF));\r\nrapl_energy_units = 1.0 / (1 << (msr >> 8 & 0x1F));\r\nrapl_time_units = 1.0 / (1 << (msr >> 16 & 0xF));\r\nif (get_msr(0, MSR_PKG_POWER_INFO, &msr))\r\nreturn;\r\ntdp = ((msr >> 0) & RAPL_POWER_GRANULARITY) * rapl_power_units;\r\nrapl_joule_counter_range = 0xFFFFFFFF * rapl_energy_units / tdp;\r\nif (verbose)\r\nfprintf(stderr, "RAPL: %.0f sec. Joule Counter Range\n", rapl_joule_counter_range);\r\nreturn;\r\n}\r\nint print_thermal(struct thread_data *t, struct core_data *c, struct pkg_data *p)\r\n{\r\nunsigned long long msr;\r\nunsigned int dts;\r\nint cpu;\r\nif (!(do_dts || do_ptm))\r\nreturn 0;\r\ncpu = t->cpu_id;\r\nif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))\r\nreturn 0;\r\nif (cpu_migrate(cpu)) {\r\nfprintf(stderr, "Could not migrate to CPU %d\n", cpu);\r\nreturn -1;\r\n}\r\nif (do_ptm && (t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE)) {\r\nif (get_msr(cpu, MSR_IA32_PACKAGE_THERM_STATUS, &msr))\r\nreturn 0;\r\ndts = (msr >> 16) & 0x7F;\r\nfprintf(stderr, "cpu%d: MSR_IA32_PACKAGE_THERM_STATUS: 0x%08llx (%d C)\n",\r\ncpu, msr, tcc_activation_temp - dts);\r\n#ifdef THERM_DEBUG\r\nif (get_msr(cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT, &msr))\r\nreturn 0;\r\ndts = (msr >> 16) & 0x7F;\r\ndts2 = (msr >> 8) & 0x7F;\r\nfprintf(stderr, "cpu%d: MSR_IA32_PACKAGE_THERM_INTERRUPT: 0x%08llx (%d C, %d C)\n",\r\ncpu, msr, tcc_activation_temp - dts, tcc_activation_temp - dts2);\r\n#endif\r\n}\r\nif (do_dts) {\r\nunsigned int resolution;\r\nif (get_msr(cpu, MSR_IA32_THERM_STATUS, &msr))\r\nreturn 0;\r\ndts = (msr >> 16) & 0x7F;\r\nresolution = (msr >> 27) & 0xF;\r\nfprintf(stderr, "cpu%d: MSR_IA32_THERM_STATUS: 0x%08llx (%d C +/- %d)\n",\r\ncpu, msr, tcc_activation_temp - dts, resolution);\r\n#ifdef THERM_DEBUG\r\nif (get_msr(cpu, MSR_IA32_THERM_INTERRUPT, &msr))\r\nreturn 0;\r\ndts = (msr >> 16) & 0x7F;\r\ndts2 = (msr >> 8) & 0x7F;\r\nfprintf(stderr, "cpu%d: MSR_IA32_THERM_INTERRUPT: 0x%08llx (%d C, %d C)\n",\r\ncpu, msr, tcc_activation_temp - dts, tcc_activation_temp - dts2);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nvoid print_power_limit_msr(int cpu, unsigned long long msr, char *label)\r\n{\r\nfprintf(stderr, "cpu%d: %s: %sabled (%f Watts, %f sec, clamp %sabled)\n",\r\ncpu, label,\r\n((msr >> 15) & 1) ? "EN" : "DIS",\r\n((msr >> 0) & 0x7FFF) * rapl_power_units,\r\n(1.0 + (((msr >> 22) & 0x3)/4.0)) * (1 << ((msr >> 17) & 0x1F)) * rapl_time_units,\r\n(((msr >> 16) & 1) ? "EN" : "DIS"));\r\nreturn;\r\n}\r\nint print_rapl(struct thread_data *t, struct core_data *c, struct pkg_data *p)\r\n{\r\nunsigned long long msr;\r\nint cpu;\r\ndouble local_rapl_power_units, local_rapl_energy_units, local_rapl_time_units;\r\nif (!do_rapl)\r\nreturn 0;\r\nif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE) || !(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\r\nreturn 0;\r\ncpu = t->cpu_id;\r\nif (cpu_migrate(cpu)) {\r\nfprintf(stderr, "Could not migrate to CPU %d\n", cpu);\r\nreturn -1;\r\n}\r\nif (get_msr(cpu, MSR_RAPL_POWER_UNIT, &msr))\r\nreturn -1;\r\nlocal_rapl_power_units = 1.0 / (1 << (msr & 0xF));\r\nlocal_rapl_energy_units = 1.0 / (1 << (msr >> 8 & 0x1F));\r\nlocal_rapl_time_units = 1.0 / (1 << (msr >> 16 & 0xF));\r\nif (local_rapl_power_units != rapl_power_units)\r\nfprintf(stderr, "cpu%d, ERROR: Power units mis-match\n", cpu);\r\nif (local_rapl_energy_units != rapl_energy_units)\r\nfprintf(stderr, "cpu%d, ERROR: Energy units mis-match\n", cpu);\r\nif (local_rapl_time_units != rapl_time_units)\r\nfprintf(stderr, "cpu%d, ERROR: Time units mis-match\n", cpu);\r\nif (verbose) {\r\nfprintf(stderr, "cpu%d: MSR_RAPL_POWER_UNIT: 0x%08llx "\r\n"(%f Watts, %f Joules, %f sec.)\n", cpu, msr,\r\nlocal_rapl_power_units, local_rapl_energy_units, local_rapl_time_units);\r\n}\r\nif (do_rapl & RAPL_PKG) {\r\nif (get_msr(cpu, MSR_PKG_POWER_INFO, &msr))\r\nreturn -5;\r\nfprintf(stderr, "cpu%d: MSR_PKG_POWER_INFO: 0x%08llx (%.0f W TDP, RAPL %.0f - %.0f W, %f sec.)\n",\r\ncpu, msr,\r\n((msr >> 0) & RAPL_POWER_GRANULARITY) * rapl_power_units,\r\n((msr >> 16) & RAPL_POWER_GRANULARITY) * rapl_power_units,\r\n((msr >> 32) & RAPL_POWER_GRANULARITY) * rapl_power_units,\r\n((msr >> 48) & RAPL_TIME_GRANULARITY) * rapl_time_units);\r\nif (get_msr(cpu, MSR_PKG_POWER_LIMIT, &msr))\r\nreturn -9;\r\nfprintf(stderr, "cpu%d: MSR_PKG_POWER_LIMIT: 0x%08llx (%slocked)\n",\r\ncpu, msr, (msr >> 63) & 1 ? "": "UN");\r\nprint_power_limit_msr(cpu, msr, "PKG Limit #1");\r\nfprintf(stderr, "cpu%d: PKG Limit #2: %sabled (%f Watts, %f* sec, clamp %sabled)\n",\r\ncpu,\r\n((msr >> 47) & 1) ? "EN" : "DIS",\r\n((msr >> 32) & 0x7FFF) * rapl_power_units,\r\n(1.0 + (((msr >> 54) & 0x3)/4.0)) * (1 << ((msr >> 49) & 0x1F)) * rapl_time_units,\r\n((msr >> 48) & 1) ? "EN" : "DIS");\r\n}\r\nif (do_rapl & RAPL_DRAM) {\r\nif (get_msr(cpu, MSR_DRAM_POWER_INFO, &msr))\r\nreturn -6;\r\nfprintf(stderr, "cpu%d: MSR_DRAM_POWER_INFO,: 0x%08llx (%.0f W TDP, RAPL %.0f - %.0f W, %f sec.)\n",\r\ncpu, msr,\r\n((msr >> 0) & RAPL_POWER_GRANULARITY) * rapl_power_units,\r\n((msr >> 16) & RAPL_POWER_GRANULARITY) * rapl_power_units,\r\n((msr >> 32) & RAPL_POWER_GRANULARITY) * rapl_power_units,\r\n((msr >> 48) & RAPL_TIME_GRANULARITY) * rapl_time_units);\r\nif (get_msr(cpu, MSR_DRAM_POWER_LIMIT, &msr))\r\nreturn -9;\r\nfprintf(stderr, "cpu%d: MSR_DRAM_POWER_LIMIT: 0x%08llx (%slocked)\n",\r\ncpu, msr, (msr >> 31) & 1 ? "": "UN");\r\nprint_power_limit_msr(cpu, msr, "DRAM Limit");\r\n}\r\nif (do_rapl & RAPL_CORES) {\r\nif (verbose) {\r\nif (get_msr(cpu, MSR_PP0_POLICY, &msr))\r\nreturn -7;\r\nfprintf(stderr, "cpu%d: MSR_PP0_POLICY: %lld\n", cpu, msr & 0xF);\r\nif (get_msr(cpu, MSR_PP0_POWER_LIMIT, &msr))\r\nreturn -9;\r\nfprintf(stderr, "cpu%d: MSR_PP0_POWER_LIMIT: 0x%08llx (%slocked)\n",\r\ncpu, msr, (msr >> 31) & 1 ? "": "UN");\r\nprint_power_limit_msr(cpu, msr, "Cores Limit");\r\n}\r\n}\r\nif (do_rapl & RAPL_GFX) {\r\nif (verbose) {\r\nif (get_msr(cpu, MSR_PP1_POLICY, &msr))\r\nreturn -8;\r\nfprintf(stderr, "cpu%d: MSR_PP1_POLICY: %lld\n", cpu, msr & 0xF);\r\nif (get_msr(cpu, MSR_PP1_POWER_LIMIT, &msr))\r\nreturn -9;\r\nfprintf(stderr, "cpu%d: MSR_PP1_POWER_LIMIT: 0x%08llx (%slocked)\n",\r\ncpu, msr, (msr >> 31) & 1 ? "": "UN");\r\nprint_power_limit_msr(cpu, msr, "GFX Limit");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint is_snb(unsigned int family, unsigned int model)\r\n{\r\nif (!genuine_intel)\r\nreturn 0;\r\nswitch (model) {\r\ncase 0x2A:\r\ncase 0x2D:\r\ncase 0x3A:\r\ncase 0x3E:\r\ncase 0x3C:\r\ncase 0x3F:\r\ncase 0x45:\r\ncase 0x46:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint has_c8_c9_c10(unsigned int family, unsigned int model)\r\n{\r\nif (!genuine_intel)\r\nreturn 0;\r\nswitch (model) {\r\ncase 0x45:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\ndouble discover_bclk(unsigned int family, unsigned int model)\r\n{\r\nif (is_snb(family, model))\r\nreturn 100.00;\r\nelse\r\nreturn 133.33;\r\n}\r\nint set_temperature_target(struct thread_data *t, struct core_data *c, struct pkg_data *p)\r\n{\r\nunsigned long long msr;\r\nunsigned int target_c_local;\r\nint cpu;\r\nif (!(do_dts || do_ptm))\r\nreturn 0;\r\nif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE) || !(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\r\nreturn 0;\r\ncpu = t->cpu_id;\r\nif (cpu_migrate(cpu)) {\r\nfprintf(stderr, "Could not migrate to CPU %d\n", cpu);\r\nreturn -1;\r\n}\r\nif (tcc_activation_temp_override != 0) {\r\ntcc_activation_temp = tcc_activation_temp_override;\r\nfprintf(stderr, "cpu%d: Using cmdline TCC Target (%d C)\n",\r\ncpu, tcc_activation_temp);\r\nreturn 0;\r\n}\r\nif (!do_nehalem_platform_info)\r\ngoto guess;\r\nif (get_msr(0, MSR_IA32_TEMPERATURE_TARGET, &msr))\r\ngoto guess;\r\ntarget_c_local = (msr >> 16) & 0x7F;\r\nif (verbose)\r\nfprintf(stderr, "cpu%d: MSR_IA32_TEMPERATURE_TARGET: 0x%08llx (%d C)\n",\r\ncpu, msr, target_c_local);\r\nif (target_c_local < 85 || target_c_local > 120)\r\ngoto guess;\r\ntcc_activation_temp = target_c_local;\r\nreturn 0;\r\nguess:\r\ntcc_activation_temp = TJMAX_DEFAULT;\r\nfprintf(stderr, "cpu%d: Guessing tjMax %d C, Please use -T to specify\n",\r\ncpu, tcc_activation_temp);\r\nreturn 0;\r\n}\r\nvoid check_cpuid()\r\n{\r\nunsigned int eax, ebx, ecx, edx, max_level;\r\nunsigned int fms, family, model, stepping;\r\neax = ebx = ecx = edx = 0;\r\nasm("cpuid" : "=a" (max_level), "=b" (ebx), "=c" (ecx), "=d" (edx) : "a" (0));\r\nif (ebx == 0x756e6547 && edx == 0x49656e69 && ecx == 0x6c65746e)\r\ngenuine_intel = 1;\r\nif (verbose)\r\nfprintf(stderr, "CPUID(0): %.4s%.4s%.4s ",\r\n(char *)&ebx, (char *)&edx, (char *)&ecx);\r\nasm("cpuid" : "=a" (fms), "=c" (ecx), "=d" (edx) : "a" (1) : "ebx");\r\nfamily = (fms >> 8) & 0xf;\r\nmodel = (fms >> 4) & 0xf;\r\nstepping = fms & 0xf;\r\nif (family == 6 || family == 0xf)\r\nmodel += ((fms >> 16) & 0xf) << 4;\r\nif (verbose)\r\nfprintf(stderr, "%d CPUID levels; family:model:stepping 0x%x:%x:%x (%d:%d:%d)\n",\r\nmax_level, family, model, stepping, family, model, stepping);\r\nif (!(edx & (1 << 5))) {\r\nfprintf(stderr, "CPUID: no MSR\n");\r\nexit(1);\r\n}\r\nebx = ecx = edx = 0;\r\nasm("cpuid" : "=a" (max_level), "=b" (ebx), "=c" (ecx), "=d" (edx) : "a" (0x80000000));\r\nif (max_level < 0x80000007) {\r\nfprintf(stderr, "CPUID: no invariant TSC (max_level 0x%x)\n", max_level);\r\nexit(1);\r\n}\r\nasm("cpuid" : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx) : "a" (0x80000007));\r\nhas_invariant_tsc = edx & (1 << 8);\r\nif (!has_invariant_tsc) {\r\nfprintf(stderr, "No invariant TSC\n");\r\nexit(1);\r\n}\r\nasm("cpuid" : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx) : "a" (0x6));\r\nhas_aperf = ecx & (1 << 0);\r\ndo_dts = eax & (1 << 0);\r\ndo_ptm = eax & (1 << 6);\r\nhas_epb = ecx & (1 << 3);\r\nif (verbose)\r\nfprintf(stderr, "CPUID(6): %s%s%s%s\n",\r\nhas_aperf ? "APERF" : "No APERF!",\r\ndo_dts ? ", DTS" : "",\r\ndo_ptm ? ", PTM": "",\r\nhas_epb ? ", EPB": "");\r\nif (!has_aperf)\r\nexit(-1);\r\ndo_nehalem_platform_info = genuine_intel && has_invariant_tsc;\r\ndo_nhm_cstates = genuine_intel;\r\ndo_smi = do_nhm_cstates;\r\ndo_snb_cstates = is_snb(family, model);\r\ndo_c8_c9_c10 = has_c8_c9_c10(family, model);\r\nbclk = discover_bclk(family, model);\r\ndo_nehalem_turbo_ratio_limit = has_nehalem_turbo_ratio_limit(family, model);\r\ndo_ivt_turbo_ratio_limit = has_ivt_turbo_ratio_limit(family, model);\r\nrapl_probe(family, model);\r\nreturn;\r\n}\r\nvoid usage()\r\n{\r\nfprintf(stderr, "%s: [-v][-R][-T][-p|-P|-S][-c MSR# | -s]][-C MSR#][-m MSR#][-M MSR#][-i interval_sec | command ...]\n",\r\nprogname);\r\nexit(1);\r\n}\r\nint dir_filter(const struct dirent *dirp)\r\n{\r\nif (isdigit(dirp->d_name[0]))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nint open_dev_cpu_msr(int dummy1)\r\n{\r\nreturn 0;\r\n}\r\nvoid topology_probe()\r\n{\r\nint i;\r\nint max_core_id = 0;\r\nint max_package_id = 0;\r\nint max_siblings = 0;\r\nstruct cpu_topology {\r\nint core_id;\r\nint physical_package_id;\r\n} *cpus;\r\ntopo.num_cpus = 0;\r\ntopo.max_cpu_num = 0;\r\nfor_all_proc_cpus(count_cpus);\r\nif (!summary_only && topo.num_cpus > 1)\r\nshow_cpu = 1;\r\nif (verbose > 1)\r\nfprintf(stderr, "num_cpus %d max_cpu_num %d\n", topo.num_cpus, topo.max_cpu_num);\r\ncpus = calloc(1, (topo.max_cpu_num + 1) * sizeof(struct cpu_topology));\r\nif (cpus == NULL) {\r\nperror("calloc cpus");\r\nexit(1);\r\n}\r\ncpu_present_set = CPU_ALLOC((topo.max_cpu_num + 1));\r\nif (cpu_present_set == NULL) {\r\nperror("CPU_ALLOC");\r\nexit(3);\r\n}\r\ncpu_present_setsize = CPU_ALLOC_SIZE((topo.max_cpu_num + 1));\r\nCPU_ZERO_S(cpu_present_setsize, cpu_present_set);\r\nfor_all_proc_cpus(mark_cpu_present);\r\ncpu_affinity_set = CPU_ALLOC((topo.max_cpu_num + 1));\r\nif (cpu_affinity_set == NULL) {\r\nperror("CPU_ALLOC");\r\nexit(3);\r\n}\r\ncpu_affinity_setsize = CPU_ALLOC_SIZE((topo.max_cpu_num + 1));\r\nCPU_ZERO_S(cpu_affinity_setsize, cpu_affinity_set);\r\nfor (i = 0; i <= topo.max_cpu_num; ++i) {\r\nint siblings;\r\nif (cpu_is_not_present(i)) {\r\nif (verbose > 1)\r\nfprintf(stderr, "cpu%d NOT PRESENT\n", i);\r\ncontinue;\r\n}\r\ncpus[i].core_id = get_core_id(i);\r\nif (cpus[i].core_id > max_core_id)\r\nmax_core_id = cpus[i].core_id;\r\ncpus[i].physical_package_id = get_physical_package_id(i);\r\nif (cpus[i].physical_package_id > max_package_id)\r\nmax_package_id = cpus[i].physical_package_id;\r\nsiblings = get_num_ht_siblings(i);\r\nif (siblings > max_siblings)\r\nmax_siblings = siblings;\r\nif (verbose > 1)\r\nfprintf(stderr, "cpu %d pkg %d core %d\n",\r\ni, cpus[i].physical_package_id, cpus[i].core_id);\r\n}\r\ntopo.num_cores_per_pkg = max_core_id + 1;\r\nif (verbose > 1)\r\nfprintf(stderr, "max_core_id %d, sizing for %d cores per package\n",\r\nmax_core_id, topo.num_cores_per_pkg);\r\nif (!summary_only && topo.num_cores_per_pkg > 1)\r\nshow_core = 1;\r\ntopo.num_packages = max_package_id + 1;\r\nif (verbose > 1)\r\nfprintf(stderr, "max_package_id %d, sizing for %d packages\n",\r\nmax_package_id, topo.num_packages);\r\nif (!summary_only && topo.num_packages > 1)\r\nshow_pkg = 1;\r\ntopo.num_threads_per_core = max_siblings;\r\nif (verbose > 1)\r\nfprintf(stderr, "max_siblings %d\n", max_siblings);\r\nfree(cpus);\r\n}\r\nvoid\r\nallocate_counters(struct thread_data **t, struct core_data **c, struct pkg_data **p)\r\n{\r\nint i;\r\n*t = calloc(topo.num_threads_per_core * topo.num_cores_per_pkg *\r\ntopo.num_packages, sizeof(struct thread_data));\r\nif (*t == NULL)\r\ngoto error;\r\nfor (i = 0; i < topo.num_threads_per_core *\r\ntopo.num_cores_per_pkg * topo.num_packages; i++)\r\n(*t)[i].cpu_id = -1;\r\n*c = calloc(topo.num_cores_per_pkg * topo.num_packages,\r\nsizeof(struct core_data));\r\nif (*c == NULL)\r\ngoto error;\r\nfor (i = 0; i < topo.num_cores_per_pkg * topo.num_packages; i++)\r\n(*c)[i].core_id = -1;\r\n*p = calloc(topo.num_packages, sizeof(struct pkg_data));\r\nif (*p == NULL)\r\ngoto error;\r\nfor (i = 0; i < topo.num_packages; i++)\r\n(*p)[i].package_id = i;\r\nreturn;\r\nerror:\r\nperror("calloc counters");\r\nexit(1);\r\n}\r\nvoid init_counter(struct thread_data *thread_base, struct core_data *core_base,\r\nstruct pkg_data *pkg_base, int thread_num, int core_num,\r\nint pkg_num, int cpu_id)\r\n{\r\nstruct thread_data *t;\r\nstruct core_data *c;\r\nstruct pkg_data *p;\r\nt = GET_THREAD(thread_base, thread_num, core_num, pkg_num);\r\nc = GET_CORE(core_base, core_num, pkg_num);\r\np = GET_PKG(pkg_base, pkg_num);\r\nt->cpu_id = cpu_id;\r\nif (thread_num == 0) {\r\nt->flags |= CPU_IS_FIRST_THREAD_IN_CORE;\r\nif (cpu_is_first_core_in_package(cpu_id))\r\nt->flags |= CPU_IS_FIRST_CORE_IN_PACKAGE;\r\n}\r\nc->core_id = core_num;\r\np->package_id = pkg_num;\r\n}\r\nint initialize_counters(int cpu_id)\r\n{\r\nint my_thread_id, my_core_id, my_package_id;\r\nmy_package_id = get_physical_package_id(cpu_id);\r\nmy_core_id = get_core_id(cpu_id);\r\nif (cpu_is_first_sibling_in_core(cpu_id)) {\r\nmy_thread_id = 0;\r\ntopo.num_cores++;\r\n} else {\r\nmy_thread_id = 1;\r\n}\r\ninit_counter(EVEN_COUNTERS, my_thread_id, my_core_id, my_package_id, cpu_id);\r\ninit_counter(ODD_COUNTERS, my_thread_id, my_core_id, my_package_id, cpu_id);\r\nreturn 0;\r\n}\r\nvoid allocate_output_buffer()\r\n{\r\noutput_buffer = calloc(1, (1 + topo.num_cpus) * 256);\r\noutp = output_buffer;\r\nif (outp == NULL) {\r\nperror("calloc");\r\nexit(-1);\r\n}\r\n}\r\nvoid setup_all_buffers(void)\r\n{\r\ntopology_probe();\r\nallocate_counters(&thread_even, &core_even, &package_even);\r\nallocate_counters(&thread_odd, &core_odd, &package_odd);\r\nallocate_output_buffer();\r\nfor_all_proc_cpus(initialize_counters);\r\n}\r\nvoid turbostat_init()\r\n{\r\ncheck_cpuid();\r\ncheck_dev_msr();\r\ncheck_super_user();\r\nsetup_all_buffers();\r\nif (verbose)\r\nprint_verbose_header();\r\nif (verbose)\r\nfor_all_cpus(print_epb, ODD_COUNTERS);\r\nif (verbose)\r\nfor_all_cpus(print_rapl, ODD_COUNTERS);\r\nfor_all_cpus(set_temperature_target, ODD_COUNTERS);\r\nif (verbose)\r\nfor_all_cpus(print_thermal, ODD_COUNTERS);\r\n}\r\nint fork_it(char **argv)\r\n{\r\npid_t child_pid;\r\nint status;\r\nstatus = for_all_cpus(get_counters, EVEN_COUNTERS);\r\nif (status)\r\nexit(status);\r\nsched_setaffinity(0, cpu_present_setsize, cpu_present_set);\r\ngettimeofday(&tv_even, (struct timezone *)NULL);\r\nchild_pid = fork();\r\nif (!child_pid) {\r\nexecvp(argv[0], argv);\r\n} else {\r\nif (child_pid == -1) {\r\nperror("fork");\r\nexit(1);\r\n}\r\nsignal(SIGINT, SIG_IGN);\r\nsignal(SIGQUIT, SIG_IGN);\r\nif (waitpid(child_pid, &status, 0) == -1) {\r\nperror("wait");\r\nexit(status);\r\n}\r\n}\r\nfor_all_cpus(get_counters, ODD_COUNTERS);\r\ngettimeofday(&tv_odd, (struct timezone *)NULL);\r\ntimersub(&tv_odd, &tv_even, &tv_delta);\r\nfor_all_cpus_2(delta_cpu, ODD_COUNTERS, EVEN_COUNTERS);\r\ncompute_average(EVEN_COUNTERS);\r\nformat_all_counters(EVEN_COUNTERS);\r\nflush_stderr();\r\nfprintf(stderr, "%.6f sec\n", tv_delta.tv_sec + tv_delta.tv_usec/1000000.0);\r\nreturn status;\r\n}\r\nvoid cmdline(int argc, char **argv)\r\n{\r\nint opt;\r\nprogname = argv[0];\r\nwhile ((opt = getopt(argc, argv, "+pPSvi:sc:sC:m:M:RT:")) != -1) {\r\nswitch (opt) {\r\ncase 'p':\r\nshow_core_only++;\r\nbreak;\r\ncase 'P':\r\nshow_pkg_only++;\r\nbreak;\r\ncase 'S':\r\nsummary_only++;\r\nbreak;\r\ncase 'v':\r\nverbose++;\r\nbreak;\r\ncase 'i':\r\ninterval_sec = atoi(optarg);\r\nbreak;\r\ncase 'c':\r\nsscanf(optarg, "%x", &extra_delta_offset32);\r\nbreak;\r\ncase 'C':\r\nsscanf(optarg, "%x", &extra_delta_offset64);\r\nbreak;\r\ncase 'm':\r\nsscanf(optarg, "%x", &extra_msr_offset32);\r\nbreak;\r\ncase 'M':\r\nsscanf(optarg, "%x", &extra_msr_offset64);\r\nbreak;\r\ncase 'R':\r\nrapl_verbose++;\r\nbreak;\r\ncase 'T':\r\ntcc_activation_temp_override = atoi(optarg);\r\nbreak;\r\ndefault:\r\nusage();\r\n}\r\n}\r\n}\r\nint main(int argc, char **argv)\r\n{\r\ncmdline(argc, argv);\r\nif (verbose)\r\nfprintf(stderr, "turbostat v3.4 April 17, 2013"\r\n" - Len Brown <lenb@kernel.org>\n");\r\nturbostat_init();\r\nif (argc - optind)\r\nreturn fork_it(argv + optind);\r\nelse\r\nturbostat_loop();\r\nreturn 0;\r\n}
