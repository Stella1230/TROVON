const struct x86_cpu_id *x86_match_cpu(const struct x86_cpu_id *match)\r\n{\r\nconst struct x86_cpu_id *m;\r\nstruct cpuinfo_x86 *c = &boot_cpu_data;\r\nfor (m = match; m->vendor | m->family | m->model | m->feature; m++) {\r\nif (m->vendor != X86_VENDOR_ANY && c->x86_vendor != m->vendor)\r\ncontinue;\r\nif (m->family != X86_FAMILY_ANY && c->x86 != m->family)\r\ncontinue;\r\nif (m->model != X86_MODEL_ANY && c->x86_model != m->model)\r\ncontinue;\r\nif (m->feature != X86_FEATURE_ANY && !cpu_has(c, m->feature))\r\ncontinue;\r\nreturn m;\r\n}\r\nreturn NULL;\r\n}\r\nssize_t arch_print_cpu_modalias(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *bufptr)\r\n{\r\nint size = PAGE_SIZE;\r\nint i, n;\r\nchar *buf = bufptr;\r\nn = snprintf(buf, size, "x86cpu:vendor:%04X:family:%04X:"\r\n"model:%04X:feature:",\r\nboot_cpu_data.x86_vendor,\r\nboot_cpu_data.x86,\r\nboot_cpu_data.x86_model);\r\nsize -= n;\r\nbuf += n;\r\nsize -= 1;\r\nfor (i = 0; i < NCAPINTS*32; i++) {\r\nif (boot_cpu_has(i)) {\r\nn = snprintf(buf, size, ",%04X", i);\r\nif (n >= size) {\r\nWARN(1, "x86 features overflow page\n");\r\nbreak;\r\n}\r\nsize -= n;\r\nbuf += n;\r\n}\r\n}\r\n*buf++ = '\n';\r\nreturn buf - bufptr;\r\n}\r\nint arch_cpu_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nchar *buf = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (buf) {\r\narch_print_cpu_modalias(NULL, NULL, buf);\r\nadd_uevent_var(env, "MODALIAS=%s", buf);\r\nkfree(buf);\r\n}\r\nreturn 0;\r\n}
