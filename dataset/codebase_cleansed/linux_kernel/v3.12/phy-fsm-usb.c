static int otg_set_protocol(struct otg_fsm *fsm, int protocol)\r\n{\r\nint ret = 0;\r\nif (fsm->protocol != protocol) {\r\nVDBG("Changing role fsm->protocol= %d; new protocol= %d\n",\r\nfsm->protocol, protocol);\r\nif (fsm->protocol == PROTO_HOST)\r\nret = fsm->ops->start_host(fsm, 0);\r\nelse if (fsm->protocol == PROTO_GADGET)\r\nret = fsm->ops->start_gadget(fsm, 0);\r\nif (ret)\r\nreturn ret;\r\nif (protocol == PROTO_HOST)\r\nret = fsm->ops->start_host(fsm, 1);\r\nelse if (protocol == PROTO_GADGET)\r\nret = fsm->ops->start_gadget(fsm, 1);\r\nif (ret)\r\nreturn ret;\r\nfsm->protocol = protocol;\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nvoid otg_leave_state(struct otg_fsm *fsm, enum usb_otg_state old_state)\r\n{\r\nswitch (old_state) {\r\ncase OTG_STATE_B_IDLE:\r\notg_del_timer(fsm, b_se0_srp_tmr);\r\nfsm->b_se0_srp = 0;\r\nbreak;\r\ncase OTG_STATE_B_SRP_INIT:\r\nfsm->b_srp_done = 0;\r\nbreak;\r\ncase OTG_STATE_B_PERIPHERAL:\r\nbreak;\r\ncase OTG_STATE_B_WAIT_ACON:\r\notg_del_timer(fsm, b_ase0_brst_tmr);\r\nfsm->b_ase0_brst_tmout = 0;\r\nbreak;\r\ncase OTG_STATE_B_HOST:\r\nbreak;\r\ncase OTG_STATE_A_IDLE:\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VRISE:\r\notg_del_timer(fsm, a_wait_vrise_tmr);\r\nfsm->a_wait_vrise_tmout = 0;\r\nbreak;\r\ncase OTG_STATE_A_WAIT_BCON:\r\notg_del_timer(fsm, a_wait_bcon_tmr);\r\nfsm->a_wait_bcon_tmout = 0;\r\nbreak;\r\ncase OTG_STATE_A_HOST:\r\notg_del_timer(fsm, a_wait_enum_tmr);\r\nbreak;\r\ncase OTG_STATE_A_SUSPEND:\r\notg_del_timer(fsm, a_aidl_bdis_tmr);\r\nfsm->a_aidl_bdis_tmout = 0;\r\nfsm->a_suspend_req = 0;\r\nbreak;\r\ncase OTG_STATE_A_PERIPHERAL:\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\notg_del_timer(fsm, a_wait_vrise_tmr);\r\nbreak;\r\ncase OTG_STATE_A_VBUS_ERR:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nint otg_set_state(struct otg_fsm *fsm, enum usb_otg_state new_state)\r\n{\r\nstate_changed = 1;\r\nif (fsm->otg->phy->state == new_state)\r\nreturn 0;\r\nVDBG("Set state: %s\n", usb_otg_state_string(new_state));\r\notg_leave_state(fsm, fsm->otg->phy->state);\r\nswitch (new_state) {\r\ncase OTG_STATE_B_IDLE:\r\notg_drv_vbus(fsm, 0);\r\notg_chrg_vbus(fsm, 0);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_UNDEF);\r\notg_add_timer(fsm, b_se0_srp_tmr);\r\nbreak;\r\ncase OTG_STATE_B_SRP_INIT:\r\notg_start_pulse(fsm);\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_UNDEF);\r\notg_add_timer(fsm, b_srp_fail_tmr);\r\nbreak;\r\ncase OTG_STATE_B_PERIPHERAL:\r\notg_chrg_vbus(fsm, 0);\r\notg_loc_conn(fsm, 1);\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_GADGET);\r\nbreak;\r\ncase OTG_STATE_B_WAIT_ACON:\r\notg_chrg_vbus(fsm, 0);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_HOST);\r\notg_add_timer(fsm, b_ase0_brst_tmr);\r\nfsm->a_bus_suspend = 0;\r\nbreak;\r\ncase OTG_STATE_B_HOST:\r\notg_chrg_vbus(fsm, 0);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 1);\r\notg_set_protocol(fsm, PROTO_HOST);\r\nusb_bus_start_enum(fsm->otg->host,\r\nfsm->otg->host->otg_port);\r\nbreak;\r\ncase OTG_STATE_A_IDLE:\r\notg_drv_vbus(fsm, 0);\r\notg_chrg_vbus(fsm, 0);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_HOST);\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VRISE:\r\notg_drv_vbus(fsm, 1);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_HOST);\r\notg_add_timer(fsm, a_wait_vrise_tmr);\r\nbreak;\r\ncase OTG_STATE_A_WAIT_BCON:\r\notg_drv_vbus(fsm, 1);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_HOST);\r\notg_add_timer(fsm, a_wait_bcon_tmr);\r\nbreak;\r\ncase OTG_STATE_A_HOST:\r\notg_drv_vbus(fsm, 1);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 1);\r\notg_set_protocol(fsm, PROTO_HOST);\r\nif (!fsm->a_bus_req || fsm->a_suspend_req)\r\notg_add_timer(fsm, a_wait_enum_tmr);\r\nbreak;\r\ncase OTG_STATE_A_SUSPEND:\r\notg_drv_vbus(fsm, 1);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_HOST);\r\notg_add_timer(fsm, a_aidl_bdis_tmr);\r\nbreak;\r\ncase OTG_STATE_A_PERIPHERAL:\r\notg_loc_conn(fsm, 1);\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_GADGET);\r\notg_drv_vbus(fsm, 1);\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\notg_drv_vbus(fsm, 0);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_HOST);\r\nbreak;\r\ncase OTG_STATE_A_VBUS_ERR:\r\notg_drv_vbus(fsm, 0);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_UNDEF);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfsm->otg->phy->state = new_state;\r\nreturn 0;\r\n}\r\nint otg_statemachine(struct otg_fsm *fsm)\r\n{\r\nenum usb_otg_state state;\r\nunsigned long flags;\r\nspin_lock_irqsave(&fsm->lock, flags);\r\nstate = fsm->otg->phy->state;\r\nstate_changed = 0;\r\nswitch (state) {\r\ncase OTG_STATE_UNDEFINED:\r\nVDBG("fsm->id = %d\n", fsm->id);\r\nif (fsm->id)\r\notg_set_state(fsm, OTG_STATE_B_IDLE);\r\nelse\r\notg_set_state(fsm, OTG_STATE_A_IDLE);\r\nbreak;\r\ncase OTG_STATE_B_IDLE:\r\nif (!fsm->id)\r\notg_set_state(fsm, OTG_STATE_A_IDLE);\r\nelse if (fsm->b_sess_vld && fsm->otg->gadget)\r\notg_set_state(fsm, OTG_STATE_B_PERIPHERAL);\r\nelse if (fsm->b_bus_req && fsm->b_sess_end && fsm->b_se0_srp)\r\notg_set_state(fsm, OTG_STATE_B_SRP_INIT);\r\nbreak;\r\ncase OTG_STATE_B_SRP_INIT:\r\nif (!fsm->id || fsm->b_srp_done)\r\notg_set_state(fsm, OTG_STATE_B_IDLE);\r\nbreak;\r\ncase OTG_STATE_B_PERIPHERAL:\r\nif (!fsm->id || !fsm->b_sess_vld)\r\notg_set_state(fsm, OTG_STATE_B_IDLE);\r\nelse if (fsm->b_bus_req && fsm->otg->\r\ngadget->b_hnp_enable && fsm->a_bus_suspend)\r\notg_set_state(fsm, OTG_STATE_B_WAIT_ACON);\r\nbreak;\r\ncase OTG_STATE_B_WAIT_ACON:\r\nif (fsm->a_conn)\r\notg_set_state(fsm, OTG_STATE_B_HOST);\r\nelse if (!fsm->id || !fsm->b_sess_vld)\r\notg_set_state(fsm, OTG_STATE_B_IDLE);\r\nelse if (fsm->a_bus_resume || fsm->b_ase0_brst_tmout) {\r\nfsm->b_ase0_brst_tmout = 0;\r\notg_set_state(fsm, OTG_STATE_B_PERIPHERAL);\r\n}\r\nbreak;\r\ncase OTG_STATE_B_HOST:\r\nif (!fsm->id || !fsm->b_sess_vld)\r\notg_set_state(fsm, OTG_STATE_B_IDLE);\r\nelse if (!fsm->b_bus_req || !fsm->a_conn)\r\notg_set_state(fsm, OTG_STATE_B_PERIPHERAL);\r\nbreak;\r\ncase OTG_STATE_A_IDLE:\r\nif (fsm->id)\r\notg_set_state(fsm, OTG_STATE_B_IDLE);\r\nelse if (!fsm->a_bus_drop && (fsm->a_bus_req || fsm->a_srp_det))\r\notg_set_state(fsm, OTG_STATE_A_WAIT_VRISE);\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VRISE:\r\nif (fsm->id || fsm->a_bus_drop || fsm->a_vbus_vld ||\r\nfsm->a_wait_vrise_tmout) {\r\notg_set_state(fsm, OTG_STATE_A_WAIT_BCON);\r\n}\r\nbreak;\r\ncase OTG_STATE_A_WAIT_BCON:\r\nif (!fsm->a_vbus_vld)\r\notg_set_state(fsm, OTG_STATE_A_VBUS_ERR);\r\nelse if (fsm->b_conn)\r\notg_set_state(fsm, OTG_STATE_A_HOST);\r\nelse if (fsm->id | fsm->a_bus_drop | fsm->a_wait_bcon_tmout)\r\notg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);\r\nbreak;\r\ncase OTG_STATE_A_HOST:\r\nif ((!fsm->a_bus_req || fsm->a_suspend_req) &&\r\nfsm->otg->host->b_hnp_enable)\r\notg_set_state(fsm, OTG_STATE_A_SUSPEND);\r\nelse if (fsm->id || !fsm->b_conn || fsm->a_bus_drop)\r\notg_set_state(fsm, OTG_STATE_A_WAIT_BCON);\r\nelse if (!fsm->a_vbus_vld)\r\notg_set_state(fsm, OTG_STATE_A_VBUS_ERR);\r\nbreak;\r\ncase OTG_STATE_A_SUSPEND:\r\nif (!fsm->b_conn && fsm->otg->host->b_hnp_enable)\r\notg_set_state(fsm, OTG_STATE_A_PERIPHERAL);\r\nelse if (!fsm->b_conn && !fsm->otg->host->b_hnp_enable)\r\notg_set_state(fsm, OTG_STATE_A_WAIT_BCON);\r\nelse if (fsm->a_bus_req || fsm->b_bus_resume)\r\notg_set_state(fsm, OTG_STATE_A_HOST);\r\nelse if (fsm->id || fsm->a_bus_drop || fsm->a_aidl_bdis_tmout)\r\notg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);\r\nelse if (!fsm->a_vbus_vld)\r\notg_set_state(fsm, OTG_STATE_A_VBUS_ERR);\r\nbreak;\r\ncase OTG_STATE_A_PERIPHERAL:\r\nif (fsm->id || fsm->a_bus_drop)\r\notg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);\r\nelse if (fsm->b_bus_suspend)\r\notg_set_state(fsm, OTG_STATE_A_WAIT_BCON);\r\nelse if (!fsm->a_vbus_vld)\r\notg_set_state(fsm, OTG_STATE_A_VBUS_ERR);\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\nif (fsm->id || fsm->a_bus_req || (!fsm->a_sess_vld &&\r\n!fsm->b_conn))\r\notg_set_state(fsm, OTG_STATE_A_IDLE);\r\nbreak;\r\ncase OTG_STATE_A_VBUS_ERR:\r\nif (fsm->id || fsm->a_bus_drop || fsm->a_clr_err)\r\notg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&fsm->lock, flags);\r\nVDBG("quit statemachine, changed = %d\n", state_changed);\r\nreturn state_changed;\r\n}
