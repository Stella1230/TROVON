static int ad7291_i2c_read(struct ad7291_chip_info *chip, u8 reg, u16 *data)\r\n{\r\nstruct i2c_client *client = chip->client;\r\nint ret = 0;\r\nret = i2c_smbus_read_word_swapped(client, reg);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "I2C read error\n");\r\nreturn ret;\r\n}\r\n*data = ret;\r\nreturn 0;\r\n}\r\nstatic int ad7291_i2c_write(struct ad7291_chip_info *chip, u8 reg, u16 data)\r\n{\r\nreturn i2c_smbus_write_word_swapped(chip->client, reg, data);\r\n}\r\nstatic irqreturn_t ad7291_event_handler(int irq, void *private)\r\n{\r\nstruct iio_dev *indio_dev = private;\r\nstruct ad7291_chip_info *chip = iio_priv(private);\r\nu16 t_status, v_status;\r\nu16 command;\r\nint i;\r\ns64 timestamp = iio_get_time_ns();\r\nif (ad7291_i2c_read(chip, AD7291_T_ALERT_STATUS, &t_status))\r\nreturn IRQ_HANDLED;\r\nif (ad7291_i2c_read(chip, AD7291_VOLTAGE_ALERT_STATUS, &v_status))\r\nreturn IRQ_HANDLED;\r\nif (!(t_status || v_status))\r\nreturn IRQ_HANDLED;\r\ncommand = chip->command | AD7291_ALERT_CLEAR;\r\nad7291_i2c_write(chip, AD7291_COMMAND, command);\r\ncommand = chip->command & ~AD7291_ALERT_CLEAR;\r\nad7291_i2c_write(chip, AD7291_COMMAND, command);\r\nif ((t_status & (1 << 0)) || (t_status & (1 << 2)))\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(IIO_TEMP,\r\n0,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_FALLING),\r\ntimestamp);\r\nif ((t_status & (1 << 1)) || (t_status & (1 << 3)))\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(IIO_TEMP,\r\n0,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_RISING),\r\ntimestamp);\r\nfor (i = 0; i < AD7291_VOLTAGE_LIMIT_COUNT*2; i += 2) {\r\nif (v_status & (1 << i))\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(IIO_VOLTAGE,\r\ni/2,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_FALLING),\r\ntimestamp);\r\nif (v_status & (1 << (i + 1)))\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(IIO_VOLTAGE,\r\ni/2,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_RISING),\r\ntimestamp);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline ssize_t ad7291_show_hyst(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad7291_chip_info *chip = iio_priv(indio_dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nu16 data;\r\nint ret;\r\nret = ad7291_i2c_read(chip, this_attr->address, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", data & AD7291_VALUE_MASK);\r\n}\r\nstatic inline ssize_t ad7291_set_hyst(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad7291_chip_info *chip = iio_priv(indio_dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nu16 data;\r\nint ret;\r\nret = kstrtou16(buf, 10, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (data > AD7291_VALUE_MASK)\r\nreturn -EINVAL;\r\nret = ad7291_i2c_write(chip, this_attr->address, data);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic unsigned int ad7291_threshold_reg(u64 event_code)\r\n{\r\nunsigned int offset;\r\nswitch (IIO_EVENT_CODE_EXTRACT_CHAN_TYPE(event_code)) {\r\ncase IIO_VOLTAGE:\r\noffset = IIO_EVENT_CODE_EXTRACT_CHAN(event_code);\r\nbreak;\r\ncase IIO_TEMP:\r\noffset = 8;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (IIO_EVENT_CODE_EXTRACT_DIR(event_code) == IIO_EV_DIR_FALLING)\r\nreturn AD7291_DATA_LOW(offset);\r\nelse\r\nreturn AD7291_DATA_HIGH(offset);\r\n}\r\nstatic int ad7291_read_event_value(struct iio_dev *indio_dev,\r\nu64 event_code,\r\nint *val)\r\n{\r\nstruct ad7291_chip_info *chip = iio_priv(indio_dev);\r\nint ret;\r\nu16 uval;\r\nret = ad7291_i2c_read(chip, ad7291_threshold_reg(event_code), &uval);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (IIO_EVENT_CODE_EXTRACT_CHAN_TYPE(event_code)) {\r\ncase IIO_VOLTAGE:\r\n*val = uval & AD7291_VALUE_MASK;\r\nreturn 0;\r\ncase IIO_TEMP:\r\n*val = sign_extend32(uval, 11);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\n}\r\nstatic int ad7291_write_event_value(struct iio_dev *indio_dev,\r\nu64 event_code,\r\nint val)\r\n{\r\nstruct ad7291_chip_info *chip = iio_priv(indio_dev);\r\nswitch (IIO_EVENT_CODE_EXTRACT_CHAN_TYPE(event_code)) {\r\ncase IIO_VOLTAGE:\r\nif (val > AD7291_VALUE_MASK || val < 0)\r\nreturn -EINVAL;\r\nbreak;\r\ncase IIO_TEMP:\r\nif (val > 2047 || val < -2048)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ad7291_i2c_write(chip, ad7291_threshold_reg(event_code), val);\r\n}\r\nstatic int ad7291_read_event_config(struct iio_dev *indio_dev,\r\nu64 event_code)\r\n{\r\nstruct ad7291_chip_info *chip = iio_priv(indio_dev);\r\nswitch (IIO_EVENT_CODE_EXTRACT_CHAN_TYPE(event_code)) {\r\ncase IIO_VOLTAGE:\r\nif (chip->c_mask &\r\n(1 << (15 - IIO_EVENT_CODE_EXTRACT_CHAN(event_code))))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\ncase IIO_TEMP:\r\nreturn 1;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int ad7291_write_event_config(struct iio_dev *indio_dev,\r\nu64 event_code,\r\nint state)\r\n{\r\nint ret = 0;\r\nstruct ad7291_chip_info *chip = iio_priv(indio_dev);\r\nu16 regval;\r\nmutex_lock(&chip->state_lock);\r\nregval = chip->command;\r\nswitch (IIO_EVENT_CODE_EXTRACT_TYPE(event_code)) {\r\ncase IIO_VOLTAGE:\r\nif ((!state) && (chip->c_mask & (1 << (15 -\r\nIIO_EVENT_CODE_EXTRACT_CHAN(event_code)))))\r\nchip->c_mask &= ~(1 << (15 - IIO_EVENT_CODE_EXTRACT_CHAN\r\n(event_code)));\r\nelse if (state && (!(chip->c_mask & (1 << (15 -\r\nIIO_EVENT_CODE_EXTRACT_CHAN(event_code))))))\r\nchip->c_mask |= (1 << (15 - IIO_EVENT_CODE_EXTRACT_CHAN\r\n(event_code)));\r\nelse\r\nbreak;\r\nregval &= ~AD7291_AUTOCYCLE;\r\nregval |= chip->c_mask;\r\nif (chip->c_mask)\r\nregval |= AD7291_AUTOCYCLE;\r\nret = ad7291_i2c_write(chip, AD7291_COMMAND, regval);\r\nif (ret < 0)\r\ngoto error_ret;\r\nchip->command = regval;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nerror_ret:\r\nmutex_unlock(&chip->state_lock);\r\nreturn ret;\r\n}\r\nstatic int ad7291_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong mask)\r\n{\r\nint ret;\r\nstruct ad7291_chip_info *chip = iio_priv(indio_dev);\r\nu16 regval;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nswitch (chan->type) {\r\ncase IIO_VOLTAGE:\r\nmutex_lock(&chip->state_lock);\r\nif (chip->command & AD7291_AUTOCYCLE) {\r\nmutex_unlock(&chip->state_lock);\r\nreturn -EBUSY;\r\n}\r\nregval = chip->command & (~AD7291_VOLTAGE_MASK);\r\nregval |= 1 << (15 - chan->channel);\r\nret = ad7291_i2c_write(chip, AD7291_COMMAND, regval);\r\nif (ret < 0) {\r\nmutex_unlock(&chip->state_lock);\r\nreturn ret;\r\n}\r\nret = i2c_smbus_read_word_swapped(chip->client,\r\nAD7291_VOLTAGE);\r\nif (ret < 0) {\r\nmutex_unlock(&chip->state_lock);\r\nreturn ret;\r\n}\r\n*val = ret & AD7291_VALUE_MASK;\r\nmutex_unlock(&chip->state_lock);\r\nreturn IIO_VAL_INT;\r\ncase IIO_TEMP:\r\nret = i2c_smbus_read_word_swapped(chip->client,\r\nAD7291_T_SENSE);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = sign_extend32(ret, 11);\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_AVERAGE_RAW:\r\nret = i2c_smbus_read_word_swapped(chip->client,\r\nAD7291_T_AVERAGE);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = sign_extend32(ret, 11);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_VOLTAGE:\r\nif (chip->reg) {\r\nint vref;\r\nvref = regulator_get_voltage(chip->reg);\r\nif (vref < 0)\r\nreturn vref;\r\n*val = vref / 1000;\r\n} else {\r\n*val = 2500;\r\n}\r\n*val2 = AD7291_BITS;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ncase IIO_TEMP:\r\n*val = 250;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int ad7291_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ad7291_platform_data *pdata = client->dev.platform_data;\r\nstruct ad7291_chip_info *chip;\r\nstruct iio_dev *indio_dev;\r\nint ret = 0;\r\nindio_dev = iio_device_alloc(sizeof(*chip));\r\nif (indio_dev == NULL) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\nchip = iio_priv(indio_dev);\r\nif (pdata && pdata->use_external_ref) {\r\nchip->reg = regulator_get(&client->dev, "vref");\r\nif (IS_ERR(chip->reg))\r\ngoto error_free;\r\nret = regulator_enable(chip->reg);\r\nif (ret)\r\ngoto error_put_reg;\r\n}\r\nmutex_init(&chip->state_lock);\r\ni2c_set_clientdata(client, indio_dev);\r\nchip->client = client;\r\nchip->command = AD7291_NOISE_DELAY |\r\nAD7291_T_SENSE_MASK |\r\nAD7291_ALERT_POLARITY;\r\nif (pdata && pdata->use_external_ref)\r\nchip->command |= AD7291_EXT_REF;\r\nindio_dev->name = id->name;\r\nindio_dev->channels = ad7291_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(ad7291_channels);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->info = &ad7291_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nret = ad7291_i2c_write(chip, AD7291_COMMAND, AD7291_RESET);\r\nif (ret) {\r\nret = -EIO;\r\ngoto error_disable_reg;\r\n}\r\nret = ad7291_i2c_write(chip, AD7291_COMMAND, chip->command);\r\nif (ret) {\r\nret = -EIO;\r\ngoto error_disable_reg;\r\n}\r\nif (client->irq > 0) {\r\nret = request_threaded_irq(client->irq,\r\nNULL,\r\n&ad7291_event_handler,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\nid->name,\r\nindio_dev);\r\nif (ret)\r\ngoto error_disable_reg;\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_unreg_irq;\r\nreturn 0;\r\nerror_unreg_irq:\r\nif (client->irq)\r\nfree_irq(client->irq, indio_dev);\r\nerror_disable_reg:\r\nif (chip->reg)\r\nregulator_disable(chip->reg);\r\nerror_put_reg:\r\nif (chip->reg)\r\nregulator_put(chip->reg);\r\nerror_free:\r\niio_device_free(indio_dev);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int ad7291_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct ad7291_chip_info *chip = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nif (client->irq)\r\nfree_irq(client->irq, indio_dev);\r\nif (chip->reg) {\r\nregulator_disable(chip->reg);\r\nregulator_put(chip->reg);\r\n}\r\niio_device_free(indio_dev);\r\nreturn 0;\r\n}
