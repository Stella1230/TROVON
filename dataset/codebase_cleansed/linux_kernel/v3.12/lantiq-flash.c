static map_word\r\nltq_read16(struct map_info *map, unsigned long adr)\r\n{\r\nunsigned long flags;\r\nmap_word temp;\r\nif (map->map_priv_1 == LTQ_NOR_PROBING)\r\nadr ^= 2;\r\nspin_lock_irqsave(&ebu_lock, flags);\r\ntemp.x[0] = *(u16 *)(map->virt + adr);\r\nspin_unlock_irqrestore(&ebu_lock, flags);\r\nreturn temp;\r\n}\r\nstatic void\r\nltq_write16(struct map_info *map, map_word d, unsigned long adr)\r\n{\r\nunsigned long flags;\r\nif (map->map_priv_1 == LTQ_NOR_PROBING)\r\nadr ^= 2;\r\nspin_lock_irqsave(&ebu_lock, flags);\r\n*(u16 *)(map->virt + adr) = d.x[0];\r\nspin_unlock_irqrestore(&ebu_lock, flags);\r\n}\r\nstatic void\r\nltq_copy_from(struct map_info *map, void *to,\r\nunsigned long from, ssize_t len)\r\n{\r\nunsigned char *f = (unsigned char *)map->virt + from;\r\nunsigned char *t = (unsigned char *)to;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ebu_lock, flags);\r\nwhile (len--)\r\n*t++ = *f++;\r\nspin_unlock_irqrestore(&ebu_lock, flags);\r\n}\r\nstatic void\r\nltq_copy_to(struct map_info *map, unsigned long to,\r\nconst void *from, ssize_t len)\r\n{\r\nunsigned char *f = (unsigned char *)from;\r\nunsigned char *t = (unsigned char *)map->virt + to;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ebu_lock, flags);\r\nwhile (len--)\r\n*t++ = *f++;\r\nspin_unlock_irqrestore(&ebu_lock, flags);\r\n}\r\nstatic int\r\nltq_mtd_probe(struct platform_device *pdev)\r\n{\r\nstruct mtd_part_parser_data ppdata;\r\nstruct ltq_mtd *ltq_mtd;\r\nstruct cfi_private *cfi;\r\nint err;\r\nif (of_machine_is_compatible("lantiq,falcon") &&\r\n(ltq_boot_select() != BS_FLASH)) {\r\ndev_err(&pdev->dev, "invalid bootstrap options\n");\r\nreturn -ENODEV;\r\n}\r\nltq_mtd = kzalloc(sizeof(struct ltq_mtd), GFP_KERNEL);\r\nplatform_set_drvdata(pdev, ltq_mtd);\r\nltq_mtd->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!ltq_mtd->res) {\r\ndev_err(&pdev->dev, "failed to get memory resource\n");\r\nerr = -ENOENT;\r\ngoto err_out;\r\n}\r\nltq_mtd->map = kzalloc(sizeof(struct map_info), GFP_KERNEL);\r\nltq_mtd->map->phys = ltq_mtd->res->start;\r\nltq_mtd->map->size = resource_size(ltq_mtd->res);\r\nltq_mtd->map->virt = devm_ioremap_resource(&pdev->dev, ltq_mtd->res);\r\nif (IS_ERR(ltq_mtd->map->virt)) {\r\nerr = PTR_ERR(ltq_mtd->map->virt);\r\ngoto err_out;\r\n}\r\nltq_mtd->map->name = ltq_map_name;\r\nltq_mtd->map->bankwidth = 2;\r\nltq_mtd->map->read = ltq_read16;\r\nltq_mtd->map->write = ltq_write16;\r\nltq_mtd->map->copy_from = ltq_copy_from;\r\nltq_mtd->map->copy_to = ltq_copy_to;\r\nltq_mtd->map->map_priv_1 = LTQ_NOR_PROBING;\r\nltq_mtd->mtd = do_map_probe("cfi_probe", ltq_mtd->map);\r\nltq_mtd->map->map_priv_1 = LTQ_NOR_NORMAL;\r\nif (!ltq_mtd->mtd) {\r\ndev_err(&pdev->dev, "probing failed\n");\r\nerr = -ENXIO;\r\ngoto err_free;\r\n}\r\nltq_mtd->mtd->owner = THIS_MODULE;\r\ncfi = ltq_mtd->map->fldrv_priv;\r\ncfi->addr_unlock1 ^= 1;\r\ncfi->addr_unlock2 ^= 1;\r\nppdata.of_node = pdev->dev.of_node;\r\nerr = mtd_device_parse_register(ltq_mtd->mtd, ltq_probe_types,\r\n&ppdata, NULL, 0);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to add partitions\n");\r\ngoto err_destroy;\r\n}\r\nreturn 0;\r\nerr_destroy:\r\nmap_destroy(ltq_mtd->mtd);\r\nerr_free:\r\nkfree(ltq_mtd->map);\r\nerr_out:\r\nkfree(ltq_mtd);\r\nreturn err;\r\n}\r\nstatic int\r\nltq_mtd_remove(struct platform_device *pdev)\r\n{\r\nstruct ltq_mtd *ltq_mtd = platform_get_drvdata(pdev);\r\nif (ltq_mtd) {\r\nif (ltq_mtd->mtd) {\r\nmtd_device_unregister(ltq_mtd->mtd);\r\nmap_destroy(ltq_mtd->mtd);\r\n}\r\nkfree(ltq_mtd->map);\r\nkfree(ltq_mtd);\r\n}\r\nreturn 0;\r\n}
