static inline struct hso_net *dev2net(struct hso_device *hso_dev)\r\n{\r\nreturn hso_dev->port_data.dev_net;\r\n}\r\nstatic inline struct hso_serial *dev2ser(struct hso_device *hso_dev)\r\n{\r\nreturn hso_dev->port_data.dev_serial;\r\n}\r\nstatic void dbg_dump(int line_count, const char *func_name, unsigned char *buf,\r\nunsigned int len)\r\n{\r\nstatic char name[255];\r\nsprintf(name, "hso[%d:%s]", line_count, func_name);\r\nprint_hex_dump_bytes(name, DUMP_PREFIX_NONE, buf, len);\r\n}\r\nstatic ssize_t hso_sysfs_show_porttype(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hso_device *hso_dev = dev_get_drvdata(dev);\r\nchar *port_name;\r\nif (!hso_dev)\r\nreturn 0;\r\nswitch (hso_dev->port_spec & HSO_PORT_MASK) {\r\ncase HSO_PORT_CONTROL:\r\nport_name = "Control";\r\nbreak;\r\ncase HSO_PORT_APP:\r\nport_name = "Application";\r\nbreak;\r\ncase HSO_PORT_APP2:\r\nport_name = "Application2";\r\nbreak;\r\ncase HSO_PORT_GPS:\r\nport_name = "GPS";\r\nbreak;\r\ncase HSO_PORT_GPS_CONTROL:\r\nport_name = "GPS Control";\r\nbreak;\r\ncase HSO_PORT_PCSC:\r\nport_name = "PCSC";\r\nbreak;\r\ncase HSO_PORT_DIAG:\r\nport_name = "Diagnostic";\r\nbreak;\r\ncase HSO_PORT_DIAG2:\r\nport_name = "Diagnostic2";\r\nbreak;\r\ncase HSO_PORT_MODEM:\r\nport_name = "Modem";\r\nbreak;\r\ncase HSO_PORT_NETWORK:\r\nport_name = "Network";\r\nbreak;\r\ndefault:\r\nport_name = "Unknown";\r\nbreak;\r\n}\r\nreturn sprintf(buf, "%s\n", port_name);\r\n}\r\nstatic int hso_urb_to_index(struct hso_serial *serial, struct urb *urb)\r\n{\r\nint idx;\r\nfor (idx = 0; idx < serial->num_rx_urbs; idx++)\r\nif (serial->rx_urb[idx] == urb)\r\nreturn idx;\r\ndev_err(serial->parent->dev, "hso_urb_to_index failed\n");\r\nreturn -1;\r\n}\r\nstatic u32 hso_mux_to_port(int mux)\r\n{\r\nu32 result;\r\nswitch (mux) {\r\ncase 0x1:\r\nresult = HSO_PORT_CONTROL;\r\nbreak;\r\ncase 0x2:\r\nresult = HSO_PORT_APP;\r\nbreak;\r\ncase 0x4:\r\nresult = HSO_PORT_PCSC;\r\nbreak;\r\ncase 0x8:\r\nresult = HSO_PORT_GPS;\r\nbreak;\r\ncase 0x10:\r\nresult = HSO_PORT_APP2;\r\nbreak;\r\ndefault:\r\nresult = HSO_PORT_NO_PORT;\r\n}\r\nreturn result;\r\n}\r\nstatic u32 hso_port_to_mux(int port)\r\n{\r\nu32 result;\r\nswitch (port & HSO_PORT_MASK) {\r\ncase HSO_PORT_CONTROL:\r\nresult = 0x0;\r\nbreak;\r\ncase HSO_PORT_APP:\r\nresult = 0x1;\r\nbreak;\r\ncase HSO_PORT_PCSC:\r\nresult = 0x2;\r\nbreak;\r\ncase HSO_PORT_GPS:\r\nresult = 0x3;\r\nbreak;\r\ncase HSO_PORT_APP2:\r\nresult = 0x4;\r\nbreak;\r\ndefault:\r\nresult = 0x0;\r\n}\r\nreturn result;\r\n}\r\nstatic struct hso_serial *get_serial_by_shared_int_and_type(\r\nstruct hso_shared_int *shared_int,\r\nint mux)\r\n{\r\nint i, port;\r\nport = hso_mux_to_port(mux);\r\nfor (i = 0; i < HSO_SERIAL_TTY_MINORS; i++) {\r\nif (serial_table[i] &&\r\n(dev2ser(serial_table[i])->shared_int == shared_int) &&\r\n((serial_table[i]->port_spec & HSO_PORT_MASK) == port)) {\r\nreturn dev2ser(serial_table[i]);\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct hso_serial *get_serial_by_index(unsigned index)\r\n{\r\nstruct hso_serial *serial = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&serial_table_lock, flags);\r\nif (serial_table[index])\r\nserial = dev2ser(serial_table[index]);\r\nspin_unlock_irqrestore(&serial_table_lock, flags);\r\nreturn serial;\r\n}\r\nstatic int get_free_serial_index(void)\r\n{\r\nint index;\r\nunsigned long flags;\r\nspin_lock_irqsave(&serial_table_lock, flags);\r\nfor (index = 0; index < HSO_SERIAL_TTY_MINORS; index++) {\r\nif (serial_table[index] == NULL) {\r\nspin_unlock_irqrestore(&serial_table_lock, flags);\r\nreturn index;\r\n}\r\n}\r\nspin_unlock_irqrestore(&serial_table_lock, flags);\r\nprintk(KERN_ERR "%s: no free serial devices in table\n", __func__);\r\nreturn -1;\r\n}\r\nstatic void set_serial_by_index(unsigned index, struct hso_serial *serial)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&serial_table_lock, flags);\r\nif (serial)\r\nserial_table[index] = serial->parent;\r\nelse\r\nserial_table[index] = NULL;\r\nspin_unlock_irqrestore(&serial_table_lock, flags);\r\n}\r\nstatic void handle_usb_error(int status, const char *function,\r\nstruct hso_device *hso_dev)\r\n{\r\nchar *explanation;\r\nswitch (status) {\r\ncase -ENODEV:\r\nexplanation = "no device";\r\nbreak;\r\ncase -ENOENT:\r\nexplanation = "endpoint not enabled";\r\nbreak;\r\ncase -EPIPE:\r\nexplanation = "endpoint stalled";\r\nbreak;\r\ncase -ENOSPC:\r\nexplanation = "not enough bandwidth";\r\nbreak;\r\ncase -ESHUTDOWN:\r\nexplanation = "device disabled";\r\nbreak;\r\ncase -EHOSTUNREACH:\r\nexplanation = "device suspended";\r\nbreak;\r\ncase -EINVAL:\r\ncase -EAGAIN:\r\ncase -EFBIG:\r\ncase -EMSGSIZE:\r\nexplanation = "internal error";\r\nbreak;\r\ncase -EILSEQ:\r\ncase -EPROTO:\r\ncase -ETIME:\r\ncase -ETIMEDOUT:\r\nexplanation = "protocol error";\r\nif (hso_dev)\r\nschedule_work(&hso_dev->reset_device);\r\nbreak;\r\ndefault:\r\nexplanation = "unknown status";\r\nbreak;\r\n}\r\nD1("%s: received USB status - %s (%d)", function, explanation, status);\r\n}\r\nstatic int hso_net_open(struct net_device *net)\r\n{\r\nstruct hso_net *odev = netdev_priv(net);\r\nunsigned long flags = 0;\r\nif (!odev) {\r\ndev_err(&net->dev, "No net device !\n");\r\nreturn -ENODEV;\r\n}\r\nodev->skb_tx_buf = NULL;\r\nspin_lock_irqsave(&odev->net_lock, flags);\r\nodev->rx_parse_state = WAIT_IP;\r\nodev->rx_buf_size = 0;\r\nodev->rx_buf_missing = sizeof(struct iphdr);\r\nspin_unlock_irqrestore(&odev->net_lock, flags);\r\nset_bit(HSO_NET_RUNNING, &odev->flags);\r\nhso_start_net_device(odev->parent);\r\nnetif_start_queue(net);\r\nreturn 0;\r\n}\r\nstatic int hso_net_close(struct net_device *net)\r\n{\r\nstruct hso_net *odev = netdev_priv(net);\r\nnetif_stop_queue(net);\r\nclear_bit(HSO_NET_RUNNING, &odev->flags);\r\nhso_stop_net_device(odev->parent);\r\nreturn 0;\r\n}\r\nstatic void write_bulk_callback(struct urb *urb)\r\n{\r\nstruct hso_net *odev = urb->context;\r\nint status = urb->status;\r\nif (!odev || !test_bit(HSO_NET_RUNNING, &odev->flags)) {\r\ndev_err(&urb->dev->dev, "%s: device not running\n", __func__);\r\nreturn;\r\n}\r\nif (!netif_device_present(odev->net)) {\r\ndev_err(&urb->dev->dev, "%s: net device not present\n",\r\n__func__);\r\nreturn;\r\n}\r\nif (status)\r\nhandle_usb_error(status, __func__, odev->parent);\r\nhso_put_activity(odev->parent);\r\nnetif_wake_queue(odev->net);\r\n}\r\nstatic netdev_tx_t hso_net_start_xmit(struct sk_buff *skb,\r\nstruct net_device *net)\r\n{\r\nstruct hso_net *odev = netdev_priv(net);\r\nint result;\r\nnetif_stop_queue(net);\r\nif (hso_get_activity(odev->parent) == -EAGAIN) {\r\nodev->skb_tx_buf = skb;\r\nreturn NETDEV_TX_OK;\r\n}\r\nDUMP1(skb->data, skb->len);\r\nmemcpy(odev->mux_bulk_tx_buf, skb->data, skb->len);\r\nD1("len: %d/%d", skb->len, MUX_BULK_TX_BUF_SIZE);\r\nusb_fill_bulk_urb(odev->mux_bulk_tx_urb,\r\nodev->parent->usb,\r\nusb_sndbulkpipe(odev->parent->usb,\r\nodev->out_endp->\r\nbEndpointAddress & 0x7F),\r\nodev->mux_bulk_tx_buf, skb->len, write_bulk_callback,\r\nodev);\r\nodev->mux_bulk_tx_urb->transfer_flags |= URB_ZERO_PACKET;\r\nresult = usb_submit_urb(odev->mux_bulk_tx_urb, GFP_ATOMIC);\r\nif (result) {\r\ndev_warn(&odev->parent->interface->dev,\r\n"failed mux_bulk_tx_urb %d\n", result);\r\nnet->stats.tx_errors++;\r\nnetif_start_queue(net);\r\n} else {\r\nnet->stats.tx_packets++;\r\nnet->stats.tx_bytes += skb->len;\r\n}\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void hso_net_tx_timeout(struct net_device *net)\r\n{\r\nstruct hso_net *odev = netdev_priv(net);\r\nif (!odev)\r\nreturn;\r\ndev_warn(&net->dev, "Tx timed out.\n");\r\nif (odev->mux_bulk_tx_urb &&\r\n(odev->mux_bulk_tx_urb->status == -EINPROGRESS))\r\nusb_unlink_urb(odev->mux_bulk_tx_urb);\r\nnet->stats.tx_errors++;\r\n}\r\nstatic void packetizeRx(struct hso_net *odev, unsigned char *ip_pkt,\r\nunsigned int count, unsigned char is_eop)\r\n{\r\nunsigned short temp_bytes;\r\nunsigned short buffer_offset = 0;\r\nunsigned short frame_len;\r\nunsigned char *tmp_rx_buf;\r\nD1("Rx %d bytes", count);\r\nDUMP(ip_pkt, min(128, (int)count));\r\nwhile (count) {\r\nswitch (odev->rx_parse_state) {\r\ncase WAIT_IP:\r\ntemp_bytes =\r\n(count <\r\nodev->rx_buf_missing) ? count : odev->\r\nrx_buf_missing;\r\nmemcpy(((unsigned char *)(&odev->rx_ip_hdr)) +\r\nodev->rx_buf_size, ip_pkt + buffer_offset,\r\ntemp_bytes);\r\nodev->rx_buf_size += temp_bytes;\r\nbuffer_offset += temp_bytes;\r\nodev->rx_buf_missing -= temp_bytes;\r\ncount -= temp_bytes;\r\nif (!odev->rx_buf_missing) {\r\nframe_len = ntohs(odev->rx_ip_hdr.tot_len);\r\nif ((frame_len > DEFAULT_MRU) ||\r\n(frame_len < sizeof(struct iphdr))) {\r\ndev_err(&odev->net->dev,\r\n"Invalid frame (%d) length\n",\r\nframe_len);\r\nodev->rx_parse_state = WAIT_SYNC;\r\ncontinue;\r\n}\r\nodev->skb_rx_buf = netdev_alloc_skb(odev->net,\r\nframe_len);\r\nif (!odev->skb_rx_buf) {\r\nD1("could not allocate memory");\r\nodev->rx_parse_state = WAIT_SYNC;\r\nreturn;\r\n}\r\ntmp_rx_buf =\r\nskb_put(odev->skb_rx_buf,\r\nsizeof(struct iphdr));\r\nmemcpy(tmp_rx_buf, (char *)&(odev->rx_ip_hdr),\r\nsizeof(struct iphdr));\r\nodev->rx_buf_size = sizeof(struct iphdr);\r\nodev->rx_buf_missing =\r\nframe_len - sizeof(struct iphdr);\r\nodev->rx_parse_state = WAIT_DATA;\r\n}\r\nbreak;\r\ncase WAIT_DATA:\r\ntemp_bytes = (count < odev->rx_buf_missing)\r\n? count : odev->rx_buf_missing;\r\ntmp_rx_buf = skb_put(odev->skb_rx_buf, temp_bytes);\r\nmemcpy(tmp_rx_buf, ip_pkt + buffer_offset, temp_bytes);\r\nodev->rx_buf_missing -= temp_bytes;\r\ncount -= temp_bytes;\r\nbuffer_offset += temp_bytes;\r\nodev->rx_buf_size += temp_bytes;\r\nif (!odev->rx_buf_missing) {\r\nodev->skb_rx_buf->protocol = cpu_to_be16(ETH_P_IP);\r\nskb_reset_mac_header(odev->skb_rx_buf);\r\nnetif_rx(odev->skb_rx_buf);\r\nodev->skb_rx_buf = NULL;\r\nodev->net->stats.rx_packets++;\r\nodev->net->stats.rx_bytes += odev->rx_buf_size;\r\nodev->rx_buf_size = 0;\r\nodev->rx_buf_missing = sizeof(struct iphdr);\r\nodev->rx_parse_state = WAIT_IP;\r\n}\r\nbreak;\r\ncase WAIT_SYNC:\r\nD1(" W_S");\r\ncount = 0;\r\nbreak;\r\ndefault:\r\nD1(" ");\r\ncount--;\r\nbreak;\r\n}\r\n}\r\nif (is_eop) {\r\nif (odev->rx_parse_state == WAIT_SYNC) {\r\nodev->rx_parse_state = WAIT_IP;\r\nodev->rx_buf_size = 0;\r\nodev->rx_buf_missing = sizeof(struct iphdr);\r\n}\r\n}\r\n}\r\nstatic void fix_crc_bug(struct urb *urb, __le16 max_packet_size)\r\n{\r\nstatic const u8 crc_check[4] = { 0xDE, 0xAD, 0xBE, 0xEF };\r\nu32 rest = urb->actual_length % le16_to_cpu(max_packet_size);\r\nif (((rest == 5) || (rest == 6)) &&\r\n!memcmp(((u8 *)urb->transfer_buffer) + urb->actual_length - 4,\r\ncrc_check, 4)) {\r\nurb->actual_length -= 4;\r\n}\r\n}\r\nstatic void read_bulk_callback(struct urb *urb)\r\n{\r\nstruct hso_net *odev = urb->context;\r\nstruct net_device *net;\r\nint result;\r\nint status = urb->status;\r\nif (status) {\r\nhandle_usb_error(status, __func__, odev->parent);\r\nreturn;\r\n}\r\nif (!odev || !test_bit(HSO_NET_RUNNING, &odev->flags)) {\r\nD1("BULK IN callback but driver is not active!");\r\nreturn;\r\n}\r\nusb_mark_last_busy(urb->dev);\r\nnet = odev->net;\r\nif (!netif_device_present(net)) {\r\nreturn;\r\n}\r\nif (odev->parent->port_spec & HSO_INFO_CRC_BUG)\r\nfix_crc_bug(urb, odev->in_endp->wMaxPacketSize);\r\nif (urb->actual_length) {\r\nspin_lock(&odev->net_lock);\r\npacketizeRx(odev, urb->transfer_buffer, urb->actual_length,\r\n(urb->transfer_buffer_length >\r\nurb->actual_length) ? 1 : 0);\r\nspin_unlock(&odev->net_lock);\r\n}\r\nusb_fill_bulk_urb(urb,\r\nodev->parent->usb,\r\nusb_rcvbulkpipe(odev->parent->usb,\r\nodev->in_endp->\r\nbEndpointAddress & 0x7F),\r\nurb->transfer_buffer, MUX_BULK_RX_BUF_SIZE,\r\nread_bulk_callback, odev);\r\nresult = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (result)\r\ndev_warn(&odev->parent->interface->dev,\r\n"%s failed submit mux_bulk_rx_urb %d\n", __func__,\r\nresult);\r\n}\r\nstatic void hso_init_termios(struct ktermios *termios)\r\n{\r\ntermios->c_iflag &=\r\n~(IGNBRK\r\n| BRKINT\r\n| PARMRK\r\n| ISTRIP\r\n| INLCR\r\n| IGNCR\r\n| ICRNL\r\n| IXON);\r\ntermios->c_oflag &= ~OPOST;\r\ntermios->c_lflag &=\r\n~(ECHO\r\n| ECHONL\r\n| ICANON\r\n| ISIG\r\n| IEXTEN);\r\ntermios->c_cflag &=\r\n~(CSIZE\r\n| PARENB\r\n| CBAUD\r\n| CBAUDEX);\r\ntermios->c_cflag |= CS8;\r\ntty_termios_encode_baud_rate(termios, 115200, 115200);\r\n}\r\nstatic void _hso_serial_set_termios(struct tty_struct *tty,\r\nstruct ktermios *old)\r\n{\r\nstruct hso_serial *serial = tty->driver_data;\r\nif (!serial) {\r\nprintk(KERN_ERR "%s: no tty structures", __func__);\r\nreturn;\r\n}\r\nD4("port %d", serial->minor);\r\ntty->termios.c_iflag &= ~IXON;\r\ntty->termios.c_cflag &=\r\n~(CSIZE\r\n| PARENB\r\n| CBAUD\r\n| CBAUDEX);\r\ntty->termios.c_cflag |= CS8;\r\ntty_encode_baud_rate(tty, 115200, 115200);\r\n}\r\nstatic void hso_resubmit_rx_bulk_urb(struct hso_serial *serial, struct urb *urb)\r\n{\r\nint result;\r\nusb_fill_bulk_urb(urb, serial->parent->usb,\r\nusb_rcvbulkpipe(serial->parent->usb,\r\nserial->in_endp->\r\nbEndpointAddress & 0x7F),\r\nurb->transfer_buffer, serial->rx_data_length,\r\nhso_std_serial_read_bulk_callback, serial);\r\nresult = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (result) {\r\ndev_err(&urb->dev->dev, "%s failed submit serial rx_urb %d\n",\r\n__func__, result);\r\n}\r\n}\r\nstatic void put_rxbuf_data_and_resubmit_bulk_urb(struct hso_serial *serial)\r\n{\r\nint count;\r\nstruct urb *curr_urb;\r\nwhile (serial->rx_urb_filled[serial->curr_rx_urb_idx]) {\r\ncurr_urb = serial->rx_urb[serial->curr_rx_urb_idx];\r\ncount = put_rxbuf_data(curr_urb, serial);\r\nif (count == -1)\r\nreturn;\r\nif (count == 0) {\r\nserial->curr_rx_urb_idx++;\r\nif (serial->curr_rx_urb_idx >= serial->num_rx_urbs)\r\nserial->curr_rx_urb_idx = 0;\r\nhso_resubmit_rx_bulk_urb(serial, curr_urb);\r\n}\r\n}\r\n}\r\nstatic void put_rxbuf_data_and_resubmit_ctrl_urb(struct hso_serial *serial)\r\n{\r\nint count = 0;\r\nstruct urb *urb;\r\nurb = serial->rx_urb[0];\r\nif (serial->port.count > 0) {\r\ncount = put_rxbuf_data(urb, serial);\r\nif (count == -1)\r\nreturn;\r\n}\r\nif (count == 0 && ((urb->actual_length != 0) ||\r\n(serial->rx_state == RX_PENDING))) {\r\nserial->rx_state = RX_SENT;\r\nhso_mux_serial_read(serial);\r\n} else\r\nserial->rx_state = RX_IDLE;\r\n}\r\nstatic void hso_std_serial_read_bulk_callback(struct urb *urb)\r\n{\r\nstruct hso_serial *serial = urb->context;\r\nint status = urb->status;\r\nif (!serial) {\r\nD1("serial == NULL");\r\nreturn;\r\n} else if (status) {\r\nhandle_usb_error(status, __func__, serial->parent);\r\nreturn;\r\n}\r\nD4("\n--- Got serial_read_bulk callback %02x ---", status);\r\nD1("Actual length = %d\n", urb->actual_length);\r\nDUMP1(urb->transfer_buffer, urb->actual_length);\r\nif (serial->port.count == 0)\r\nreturn;\r\nif (status == 0) {\r\nif (serial->parent->port_spec & HSO_INFO_CRC_BUG)\r\nfix_crc_bug(urb, serial->in_endp->wMaxPacketSize);\r\nspin_lock(&serial->serial_lock);\r\nserial->rx_urb_filled[hso_urb_to_index(serial, urb)] = 1;\r\nput_rxbuf_data_and_resubmit_bulk_urb(serial);\r\nspin_unlock(&serial->serial_lock);\r\n} else if (status == -ENOENT || status == -ECONNRESET) {\r\nD2("Port %d, successfully unlinked urb", serial->minor);\r\nspin_lock(&serial->serial_lock);\r\nserial->rx_urb_filled[hso_urb_to_index(serial, urb)] = 0;\r\nhso_resubmit_rx_bulk_urb(serial, urb);\r\nspin_unlock(&serial->serial_lock);\r\n} else {\r\nD2("Port %d, status = %d for read urb", serial->minor, status);\r\nreturn;\r\n}\r\n}\r\nstatic void hso_unthrottle_tasklet(struct hso_serial *serial)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&serial->serial_lock, flags);\r\nif ((serial->parent->port_spec & HSO_INTF_MUX))\r\nput_rxbuf_data_and_resubmit_ctrl_urb(serial);\r\nelse\r\nput_rxbuf_data_and_resubmit_bulk_urb(serial);\r\nspin_unlock_irqrestore(&serial->serial_lock, flags);\r\n}\r\nstatic void hso_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct hso_serial *serial = tty->driver_data;\r\ntasklet_hi_schedule(&serial->unthrottle_tasklet);\r\n}\r\nstatic void hso_unthrottle_workfunc(struct work_struct *work)\r\n{\r\nstruct hso_serial *serial =\r\ncontainer_of(work, struct hso_serial,\r\nretry_unthrottle_workqueue);\r\nhso_unthrottle_tasklet(serial);\r\n}\r\nstatic int hso_serial_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct hso_serial *serial = get_serial_by_index(tty->index);\r\nint result;\r\nif (serial == NULL || serial->magic != HSO_SERIAL_MAGIC) {\r\nWARN_ON(1);\r\ntty->driver_data = NULL;\r\nD1("Failed to open port");\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&serial->parent->mutex);\r\nresult = usb_autopm_get_interface(serial->parent->interface);\r\nif (result < 0)\r\ngoto err_out;\r\nD1("Opening %d", serial->minor);\r\nkref_get(&serial->parent->ref);\r\ntty->driver_data = serial;\r\ntty_port_tty_set(&serial->port, tty);\r\nserial->port.count++;\r\nif (serial->port.count == 1) {\r\nserial->rx_state = RX_IDLE;\r\n_hso_serial_set_termios(tty, NULL);\r\ntasklet_init(&serial->unthrottle_tasklet,\r\n(void (*)(unsigned long))hso_unthrottle_tasklet,\r\n(unsigned long)serial);\r\nINIT_WORK(&serial->retry_unthrottle_workqueue,\r\nhso_unthrottle_workfunc);\r\nresult = hso_start_serial_device(serial->parent, GFP_KERNEL);\r\nif (result) {\r\nhso_stop_serial_device(serial->parent);\r\nserial->port.count--;\r\nkref_put(&serial->parent->ref, hso_serial_ref_free);\r\n}\r\n} else {\r\nD1("Port was already open");\r\n}\r\nusb_autopm_put_interface(serial->parent->interface);\r\nif (result)\r\nhso_serial_tiocmset(tty, TIOCM_RTS | TIOCM_DTR, 0);\r\nerr_out:\r\nmutex_unlock(&serial->parent->mutex);\r\nreturn result;\r\n}\r\nstatic void hso_serial_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct hso_serial *serial = tty->driver_data;\r\nu8 usb_gone;\r\nD1("Closing serial port");\r\nif (serial == NULL)\r\nreturn;\r\nmutex_lock(&serial->parent->mutex);\r\nusb_gone = serial->parent->usb_gone;\r\nif (!usb_gone)\r\nusb_autopm_get_interface(serial->parent->interface);\r\nserial->port.count--;\r\nif (serial->port.count <= 0) {\r\nserial->port.count = 0;\r\ntty_port_tty_set(&serial->port, NULL);\r\nif (!usb_gone)\r\nhso_stop_serial_device(serial->parent);\r\ntasklet_kill(&serial->unthrottle_tasklet);\r\ncancel_work_sync(&serial->retry_unthrottle_workqueue);\r\n}\r\nif (!usb_gone)\r\nusb_autopm_put_interface(serial->parent->interface);\r\nmutex_unlock(&serial->parent->mutex);\r\nkref_put(&serial->parent->ref, hso_serial_ref_free);\r\n}\r\nstatic int hso_serial_write(struct tty_struct *tty, const unsigned char *buf,\r\nint count)\r\n{\r\nstruct hso_serial *serial = tty->driver_data;\r\nint space, tx_bytes;\r\nunsigned long flags;\r\nif (serial == NULL) {\r\nprintk(KERN_ERR "%s: serial is NULL\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nspin_lock_irqsave(&serial->serial_lock, flags);\r\nspace = serial->tx_data_length - serial->tx_buffer_count;\r\ntx_bytes = (count < space) ? count : space;\r\nif (!tx_bytes)\r\ngoto out;\r\nmemcpy(serial->tx_buffer + serial->tx_buffer_count, buf, tx_bytes);\r\nserial->tx_buffer_count += tx_bytes;\r\nout:\r\nspin_unlock_irqrestore(&serial->serial_lock, flags);\r\nhso_kick_transmit(serial);\r\nreturn tx_bytes;\r\n}\r\nstatic int hso_serial_write_room(struct tty_struct *tty)\r\n{\r\nstruct hso_serial *serial = tty->driver_data;\r\nint room;\r\nunsigned long flags;\r\nspin_lock_irqsave(&serial->serial_lock, flags);\r\nroom = serial->tx_data_length - serial->tx_buffer_count;\r\nspin_unlock_irqrestore(&serial->serial_lock, flags);\r\nreturn room;\r\n}\r\nstatic void hso_serial_set_termios(struct tty_struct *tty, struct ktermios *old)\r\n{\r\nstruct hso_serial *serial = tty->driver_data;\r\nunsigned long flags;\r\nif (old)\r\nD5("Termios called with: cflags new[%d] - old[%d]",\r\ntty->termios.c_cflag, old->c_cflag);\r\nspin_lock_irqsave(&serial->serial_lock, flags);\r\nif (serial->port.count)\r\n_hso_serial_set_termios(tty, old);\r\nelse\r\ntty->termios = *old;\r\nspin_unlock_irqrestore(&serial->serial_lock, flags);\r\n}\r\nstatic int hso_serial_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct hso_serial *serial = tty->driver_data;\r\nint chars;\r\nunsigned long flags;\r\nif (serial == NULL)\r\nreturn 0;\r\nspin_lock_irqsave(&serial->serial_lock, flags);\r\nchars = serial->tx_buffer_count;\r\nspin_unlock_irqrestore(&serial->serial_lock, flags);\r\nreturn chars;\r\n}\r\nstatic int tiocmget_submit_urb(struct hso_serial *serial,\r\nstruct hso_tiocmget *tiocmget,\r\nstruct usb_device *usb)\r\n{\r\nint result;\r\nif (serial->parent->usb_gone)\r\nreturn -ENODEV;\r\nusb_fill_int_urb(tiocmget->urb, usb,\r\nusb_rcvintpipe(usb,\r\ntiocmget->endp->\r\nbEndpointAddress & 0x7F),\r\n&tiocmget->serial_state_notification,\r\nsizeof(struct hso_serial_state_notification),\r\ntiocmget_intr_callback, serial,\r\ntiocmget->endp->bInterval);\r\nresult = usb_submit_urb(tiocmget->urb, GFP_ATOMIC);\r\nif (result) {\r\ndev_warn(&usb->dev, "%s usb_submit_urb failed %d\n", __func__,\r\nresult);\r\n}\r\nreturn result;\r\n}\r\nstatic void tiocmget_intr_callback(struct urb *urb)\r\n{\r\nstruct hso_serial *serial = urb->context;\r\nstruct hso_tiocmget *tiocmget;\r\nint status = urb->status;\r\nu16 UART_state_bitmap, prev_UART_state_bitmap;\r\nstruct uart_icount *icount;\r\nstruct hso_serial_state_notification *serial_state_notification;\r\nstruct usb_device *usb;\r\nif (!serial)\r\nreturn;\r\nif (status) {\r\nhandle_usb_error(status, __func__, serial->parent);\r\nreturn;\r\n}\r\ntiocmget = serial->tiocmget;\r\nif (!tiocmget)\r\nreturn;\r\nusb = serial->parent->usb;\r\nserial_state_notification = &tiocmget->serial_state_notification;\r\nif (serial_state_notification->bmRequestType != BM_REQUEST_TYPE ||\r\nserial_state_notification->bNotification != B_NOTIFICATION ||\r\nle16_to_cpu(serial_state_notification->wValue) != W_VALUE ||\r\nle16_to_cpu(serial_state_notification->wIndex) != W_INDEX ||\r\nle16_to_cpu(serial_state_notification->wLength) != W_LENGTH) {\r\ndev_warn(&usb->dev,\r\n"hso received invalid serial state notification\n");\r\nDUMP(serial_state_notification,\r\nsizeof(struct hso_serial_state_notification));\r\n} else {\r\nUART_state_bitmap = le16_to_cpu(serial_state_notification->\r\nUART_state_bitmap);\r\nprev_UART_state_bitmap = tiocmget->prev_UART_state_bitmap;\r\nicount = &tiocmget->icount;\r\nspin_lock(&serial->serial_lock);\r\nif ((UART_state_bitmap & B_OVERRUN) !=\r\n(prev_UART_state_bitmap & B_OVERRUN))\r\nicount->parity++;\r\nif ((UART_state_bitmap & B_PARITY) !=\r\n(prev_UART_state_bitmap & B_PARITY))\r\nicount->parity++;\r\nif ((UART_state_bitmap & B_FRAMING) !=\r\n(prev_UART_state_bitmap & B_FRAMING))\r\nicount->frame++;\r\nif ((UART_state_bitmap & B_RING_SIGNAL) &&\r\n!(prev_UART_state_bitmap & B_RING_SIGNAL))\r\nicount->rng++;\r\nif ((UART_state_bitmap & B_BREAK) !=\r\n(prev_UART_state_bitmap & B_BREAK))\r\nicount->brk++;\r\nif ((UART_state_bitmap & B_TX_CARRIER) !=\r\n(prev_UART_state_bitmap & B_TX_CARRIER))\r\nicount->dsr++;\r\nif ((UART_state_bitmap & B_RX_CARRIER) !=\r\n(prev_UART_state_bitmap & B_RX_CARRIER))\r\nicount->dcd++;\r\ntiocmget->prev_UART_state_bitmap = UART_state_bitmap;\r\nspin_unlock(&serial->serial_lock);\r\ntiocmget->intr_completed = 1;\r\nwake_up_interruptible(&tiocmget->waitq);\r\n}\r\nmemset(serial_state_notification, 0,\r\nsizeof(struct hso_serial_state_notification));\r\ntiocmget_submit_urb(serial,\r\ntiocmget,\r\nserial->parent->usb);\r\n}\r\nstatic int\r\nhso_wait_modem_status(struct hso_serial *serial, unsigned long arg)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nstruct uart_icount cprev, cnow;\r\nstruct hso_tiocmget *tiocmget;\r\nint ret;\r\ntiocmget = serial->tiocmget;\r\nif (!tiocmget)\r\nreturn -ENOENT;\r\nspin_lock_irq(&serial->serial_lock);\r\nmemcpy(&cprev, &tiocmget->icount, sizeof(struct uart_icount));\r\nspin_unlock_irq(&serial->serial_lock);\r\nadd_wait_queue(&tiocmget->waitq, &wait);\r\nfor (;;) {\r\nspin_lock_irq(&serial->serial_lock);\r\nmemcpy(&cnow, &tiocmget->icount, sizeof(struct uart_icount));\r\nspin_unlock_irq(&serial->serial_lock);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||\r\n((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||\r\n((arg & TIOCM_CD) && (cnow.dcd != cprev.dcd))) {\r\nret = 0;\r\nbreak;\r\n}\r\nschedule();\r\nif (signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\ncprev = cnow;\r\n}\r\ncurrent->state = TASK_RUNNING;\r\nremove_wait_queue(&tiocmget->waitq, &wait);\r\nreturn ret;\r\n}\r\nstatic int hso_get_count(struct tty_struct *tty,\r\nstruct serial_icounter_struct *icount)\r\n{\r\nstruct uart_icount cnow;\r\nstruct hso_serial *serial = tty->driver_data;\r\nstruct hso_tiocmget *tiocmget = serial->tiocmget;\r\nmemset(icount, 0, sizeof(struct serial_icounter_struct));\r\nif (!tiocmget)\r\nreturn -ENOENT;\r\nspin_lock_irq(&serial->serial_lock);\r\nmemcpy(&cnow, &tiocmget->icount, sizeof(struct uart_icount));\r\nspin_unlock_irq(&serial->serial_lock);\r\nicount->cts = cnow.cts;\r\nicount->dsr = cnow.dsr;\r\nicount->rng = cnow.rng;\r\nicount->dcd = cnow.dcd;\r\nicount->rx = cnow.rx;\r\nicount->tx = cnow.tx;\r\nicount->frame = cnow.frame;\r\nicount->overrun = cnow.overrun;\r\nicount->parity = cnow.parity;\r\nicount->brk = cnow.brk;\r\nicount->buf_overrun = cnow.buf_overrun;\r\nreturn 0;\r\n}\r\nstatic int hso_serial_tiocmget(struct tty_struct *tty)\r\n{\r\nint retval;\r\nstruct hso_serial *serial = tty->driver_data;\r\nstruct hso_tiocmget *tiocmget;\r\nu16 UART_state_bitmap;\r\nif (!serial) {\r\nD1("no tty structures");\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irq(&serial->serial_lock);\r\nretval = ((serial->rts_state) ? TIOCM_RTS : 0) |\r\n((serial->dtr_state) ? TIOCM_DTR : 0);\r\ntiocmget = serial->tiocmget;\r\nif (tiocmget) {\r\nUART_state_bitmap = le16_to_cpu(\r\ntiocmget->prev_UART_state_bitmap);\r\nif (UART_state_bitmap & B_RING_SIGNAL)\r\nretval |= TIOCM_RNG;\r\nif (UART_state_bitmap & B_RX_CARRIER)\r\nretval |= TIOCM_CD;\r\nif (UART_state_bitmap & B_TX_CARRIER)\r\nretval |= TIOCM_DSR;\r\n}\r\nspin_unlock_irq(&serial->serial_lock);\r\nreturn retval;\r\n}\r\nstatic int hso_serial_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nint val = 0;\r\nunsigned long flags;\r\nint if_num;\r\nstruct hso_serial *serial = tty->driver_data;\r\nif (!serial) {\r\nD1("no tty structures");\r\nreturn -EINVAL;\r\n}\r\nif ((serial->parent->port_spec & HSO_PORT_MASK) != HSO_PORT_MODEM)\r\nreturn -EINVAL;\r\nif_num = serial->parent->interface->altsetting->desc.bInterfaceNumber;\r\nspin_lock_irqsave(&serial->serial_lock, flags);\r\nif (set & TIOCM_RTS)\r\nserial->rts_state = 1;\r\nif (set & TIOCM_DTR)\r\nserial->dtr_state = 1;\r\nif (clear & TIOCM_RTS)\r\nserial->rts_state = 0;\r\nif (clear & TIOCM_DTR)\r\nserial->dtr_state = 0;\r\nif (serial->dtr_state)\r\nval |= 0x01;\r\nif (serial->rts_state)\r\nval |= 0x02;\r\nspin_unlock_irqrestore(&serial->serial_lock, flags);\r\nreturn usb_control_msg(serial->parent->usb,\r\nusb_rcvctrlpipe(serial->parent->usb, 0), 0x22,\r\n0x21, val, if_num, NULL, 0,\r\nUSB_CTRL_SET_TIMEOUT);\r\n}\r\nstatic int hso_serial_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct hso_serial *serial = tty->driver_data;\r\nint ret = 0;\r\nD4("IOCTL cmd: %d, arg: %ld", cmd, arg);\r\nif (!serial)\r\nreturn -ENODEV;\r\nswitch (cmd) {\r\ncase TIOCMIWAIT:\r\nret = hso_wait_modem_status(serial, arg);\r\nbreak;\r\ndefault:\r\nret = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void hso_kick_transmit(struct hso_serial *serial)\r\n{\r\nu8 *temp;\r\nunsigned long flags;\r\nint res;\r\nspin_lock_irqsave(&serial->serial_lock, flags);\r\nif (!serial->tx_buffer_count)\r\ngoto out;\r\nif (serial->tx_urb_used)\r\ngoto out;\r\nif (hso_get_activity(serial->parent) == -EAGAIN)\r\ngoto out;\r\ntemp = serial->tx_buffer;\r\nserial->tx_buffer = serial->tx_data;\r\nserial->tx_data = temp;\r\nserial->tx_data_count = serial->tx_buffer_count;\r\nserial->tx_buffer_count = 0;\r\nif (temp && serial->write_data) {\r\nres = serial->write_data(serial);\r\nif (res >= 0)\r\nserial->tx_urb_used = 1;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&serial->serial_lock, flags);\r\n}\r\nstatic int mux_device_request(struct hso_serial *serial, u8 type, u16 port,\r\nstruct urb *ctrl_urb,\r\nstruct usb_ctrlrequest *ctrl_req,\r\nu8 *ctrl_urb_data, u32 size)\r\n{\r\nint result;\r\nint pipe;\r\nif (!serial || !ctrl_urb || !ctrl_req) {\r\nprintk(KERN_ERR "%s: Wrong arguments\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nctrl_req->wValue = 0;\r\nctrl_req->wIndex = cpu_to_le16(hso_port_to_mux(port));\r\nctrl_req->wLength = cpu_to_le16(size);\r\nif (type == USB_CDC_GET_ENCAPSULATED_RESPONSE) {\r\nctrl_req->bRequestType = USB_DIR_IN |\r\nUSB_TYPE_OPTION_VENDOR |\r\nUSB_RECIP_INTERFACE;\r\nctrl_req->bRequest = USB_CDC_GET_ENCAPSULATED_RESPONSE;\r\npipe = usb_rcvctrlpipe(serial->parent->usb, 0);\r\n} else {\r\nctrl_req->bRequestType = USB_DIR_OUT |\r\nUSB_TYPE_OPTION_VENDOR |\r\nUSB_RECIP_INTERFACE;\r\nctrl_req->bRequest = USB_CDC_SEND_ENCAPSULATED_COMMAND;\r\npipe = usb_sndctrlpipe(serial->parent->usb, 0);\r\n}\r\nD2("%s command (%02x) len: %d, port: %d",\r\ntype == USB_CDC_GET_ENCAPSULATED_RESPONSE ? "Read" : "Write",\r\nctrl_req->bRequestType, ctrl_req->wLength, port);\r\nctrl_urb->transfer_flags = 0;\r\nusb_fill_control_urb(ctrl_urb,\r\nserial->parent->usb,\r\npipe,\r\n(u8 *) ctrl_req,\r\nctrl_urb_data, size, ctrl_callback, serial);\r\nresult = usb_submit_urb(ctrl_urb, GFP_ATOMIC);\r\nif (result) {\r\ndev_err(&ctrl_urb->dev->dev,\r\n"%s failed submit ctrl_urb %d type %d\n", __func__,\r\nresult, type);\r\nreturn result;\r\n}\r\nreturn size;\r\n}\r\nstatic int hso_mux_serial_read(struct hso_serial *serial)\r\n{\r\nif (!serial)\r\nreturn -EINVAL;\r\nmemset(serial->rx_data[0], 0, CTRL_URB_RX_SIZE);\r\nif (serial->num_rx_urbs != 1) {\r\ndev_err(&serial->parent->interface->dev,\r\n"ERROR: mux'd reads with multiple buffers "\r\n"not possible\n");\r\nreturn 0;\r\n}\r\nreturn mux_device_request(serial,\r\nUSB_CDC_GET_ENCAPSULATED_RESPONSE,\r\nserial->parent->port_spec & HSO_PORT_MASK,\r\nserial->rx_urb[0],\r\n&serial->ctrl_req_rx,\r\nserial->rx_data[0], serial->rx_data_length);\r\n}\r\nstatic void intr_callback(struct urb *urb)\r\n{\r\nstruct hso_shared_int *shared_int = urb->context;\r\nstruct hso_serial *serial;\r\nunsigned char *port_req;\r\nint status = urb->status;\r\nint i;\r\nusb_mark_last_busy(urb->dev);\r\nif (!shared_int)\r\nreturn;\r\nif (status) {\r\nhandle_usb_error(status, __func__, NULL);\r\nreturn;\r\n}\r\nD4("\n--- Got intr callback 0x%02X ---", status);\r\nport_req = urb->transfer_buffer;\r\nD4(" port_req = 0x%.2X\n", *port_req);\r\nfor (i = 0; i < 8; i++) {\r\nif (*port_req & (1 << i)) {\r\nserial = get_serial_by_shared_int_and_type(shared_int,\r\n(1 << i));\r\nif (serial != NULL) {\r\nD1("Pending read interrupt on port %d\n", i);\r\nspin_lock(&serial->serial_lock);\r\nif (serial->rx_state == RX_IDLE &&\r\nserial->port.count > 0) {\r\nif (!serial->rx_urb_filled[0]) {\r\nserial->rx_state = RX_SENT;\r\nhso_mux_serial_read(serial);\r\n} else\r\nserial->rx_state = RX_PENDING;\r\n} else {\r\nD1("Already a read pending on "\r\n"port %d or port not open\n", i);\r\n}\r\nspin_unlock(&serial->serial_lock);\r\n}\r\n}\r\n}\r\nhso_mux_submit_intr_urb(shared_int, urb->dev, GFP_ATOMIC);\r\n}\r\nstatic int hso_mux_serial_write_data(struct hso_serial *serial)\r\n{\r\nif (NULL == serial)\r\nreturn -EINVAL;\r\nreturn mux_device_request(serial,\r\nUSB_CDC_SEND_ENCAPSULATED_COMMAND,\r\nserial->parent->port_spec & HSO_PORT_MASK,\r\nserial->tx_urb,\r\n&serial->ctrl_req_tx,\r\nserial->tx_data, serial->tx_data_count);\r\n}\r\nstatic void hso_std_serial_write_bulk_callback(struct urb *urb)\r\n{\r\nstruct hso_serial *serial = urb->context;\r\nint status = urb->status;\r\nif (!serial) {\r\nD1("serial == NULL");\r\nreturn;\r\n}\r\nspin_lock(&serial->serial_lock);\r\nserial->tx_urb_used = 0;\r\nspin_unlock(&serial->serial_lock);\r\nif (status) {\r\nhandle_usb_error(status, __func__, serial->parent);\r\nreturn;\r\n}\r\nhso_put_activity(serial->parent);\r\ntty_port_tty_wakeup(&serial->port);\r\nhso_kick_transmit(serial);\r\nD1(" ");\r\n}\r\nstatic int hso_std_serial_write_data(struct hso_serial *serial)\r\n{\r\nint count = serial->tx_data_count;\r\nint result;\r\nusb_fill_bulk_urb(serial->tx_urb,\r\nserial->parent->usb,\r\nusb_sndbulkpipe(serial->parent->usb,\r\nserial->out_endp->\r\nbEndpointAddress & 0x7F),\r\nserial->tx_data, serial->tx_data_count,\r\nhso_std_serial_write_bulk_callback, serial);\r\nresult = usb_submit_urb(serial->tx_urb, GFP_ATOMIC);\r\nif (result) {\r\ndev_warn(&serial->parent->usb->dev,\r\n"Failed to submit urb - res %d\n", result);\r\nreturn result;\r\n}\r\nreturn count;\r\n}\r\nstatic void ctrl_callback(struct urb *urb)\r\n{\r\nstruct hso_serial *serial = urb->context;\r\nstruct usb_ctrlrequest *req;\r\nint status = urb->status;\r\nif (!serial)\r\nreturn;\r\nspin_lock(&serial->serial_lock);\r\nserial->tx_urb_used = 0;\r\nspin_unlock(&serial->serial_lock);\r\nif (status) {\r\nhandle_usb_error(status, __func__, serial->parent);\r\nreturn;\r\n}\r\nreq = (struct usb_ctrlrequest *)(urb->setup_packet);\r\nD4("\n--- Got muxed ctrl callback 0x%02X ---", status);\r\nD4("Actual length of urb = %d\n", urb->actual_length);\r\nDUMP1(urb->transfer_buffer, urb->actual_length);\r\nif (req->bRequestType ==\r\n(USB_DIR_IN | USB_TYPE_OPTION_VENDOR | USB_RECIP_INTERFACE)) {\r\nserial->rx_urb_filled[0] = 1;\r\nspin_lock(&serial->serial_lock);\r\nput_rxbuf_data_and_resubmit_ctrl_urb(serial);\r\nspin_unlock(&serial->serial_lock);\r\n} else {\r\nhso_put_activity(serial->parent);\r\ntty_port_tty_wakeup(&serial->port);\r\nhso_kick_transmit(serial);\r\n}\r\n}\r\nstatic int put_rxbuf_data(struct urb *urb, struct hso_serial *serial)\r\n{\r\nstruct tty_struct *tty;\r\nint write_length_remaining = 0;\r\nint curr_write_len;\r\nif (urb == NULL || serial == NULL) {\r\nD1("serial = NULL");\r\nreturn -2;\r\n}\r\ntty = tty_port_tty_get(&serial->port);\r\nwrite_length_remaining = urb->actual_length -\r\nserial->curr_rx_urb_offset;\r\nD1("data to push to tty");\r\nwhile (write_length_remaining) {\r\nif (tty && test_bit(TTY_THROTTLED, &tty->flags)) {\r\ntty_kref_put(tty);\r\nreturn -1;\r\n}\r\ncurr_write_len = tty_insert_flip_string(&serial->port,\r\nurb->transfer_buffer + serial->curr_rx_urb_offset,\r\nwrite_length_remaining);\r\nserial->curr_rx_urb_offset += curr_write_len;\r\nwrite_length_remaining -= curr_write_len;\r\ntty_flip_buffer_push(&serial->port);\r\n}\r\ntty_kref_put(tty);\r\nif (write_length_remaining == 0) {\r\nserial->curr_rx_urb_offset = 0;\r\nserial->rx_urb_filled[hso_urb_to_index(serial, urb)] = 0;\r\n}\r\nreturn write_length_remaining;\r\n}\r\nstatic void hso_log_port(struct hso_device *hso_dev)\r\n{\r\nchar *port_type;\r\nchar port_dev[20];\r\nswitch (hso_dev->port_spec & HSO_PORT_MASK) {\r\ncase HSO_PORT_CONTROL:\r\nport_type = "Control";\r\nbreak;\r\ncase HSO_PORT_APP:\r\nport_type = "Application";\r\nbreak;\r\ncase HSO_PORT_GPS:\r\nport_type = "GPS";\r\nbreak;\r\ncase HSO_PORT_GPS_CONTROL:\r\nport_type = "GPS control";\r\nbreak;\r\ncase HSO_PORT_APP2:\r\nport_type = "Application2";\r\nbreak;\r\ncase HSO_PORT_PCSC:\r\nport_type = "PCSC";\r\nbreak;\r\ncase HSO_PORT_DIAG:\r\nport_type = "Diagnostic";\r\nbreak;\r\ncase HSO_PORT_DIAG2:\r\nport_type = "Diagnostic2";\r\nbreak;\r\ncase HSO_PORT_MODEM:\r\nport_type = "Modem";\r\nbreak;\r\ncase HSO_PORT_NETWORK:\r\nport_type = "Network";\r\nbreak;\r\ndefault:\r\nport_type = "Unknown";\r\nbreak;\r\n}\r\nif ((hso_dev->port_spec & HSO_PORT_MASK) == HSO_PORT_NETWORK) {\r\nsprintf(port_dev, "%s", dev2net(hso_dev)->net->name);\r\n} else\r\nsprintf(port_dev, "/dev/%s%d", tty_filename,\r\ndev2ser(hso_dev)->minor);\r\ndev_dbg(&hso_dev->interface->dev, "HSO: Found %s port %s\n",\r\nport_type, port_dev);\r\n}\r\nstatic int hso_start_net_device(struct hso_device *hso_dev)\r\n{\r\nint i, result = 0;\r\nstruct hso_net *hso_net = dev2net(hso_dev);\r\nif (!hso_net)\r\nreturn -ENODEV;\r\nfor (i = 0; i < MUX_BULK_RX_BUF_COUNT; i++) {\r\nusb_fill_bulk_urb(hso_net->mux_bulk_rx_urb_pool[i],\r\nhso_dev->usb,\r\nusb_rcvbulkpipe(hso_dev->usb,\r\nhso_net->in_endp->\r\nbEndpointAddress & 0x7F),\r\nhso_net->mux_bulk_rx_buf_pool[i],\r\nMUX_BULK_RX_BUF_SIZE, read_bulk_callback,\r\nhso_net);\r\nresult = usb_submit_urb(hso_net->mux_bulk_rx_urb_pool[i],\r\nGFP_NOIO);\r\nif (result)\r\ndev_warn(&hso_dev->usb->dev,\r\n"%s failed mux_bulk_rx_urb[%d] %d\n", __func__,\r\ni, result);\r\n}\r\nreturn result;\r\n}\r\nstatic int hso_stop_net_device(struct hso_device *hso_dev)\r\n{\r\nint i;\r\nstruct hso_net *hso_net = dev2net(hso_dev);\r\nif (!hso_net)\r\nreturn -ENODEV;\r\nfor (i = 0; i < MUX_BULK_RX_BUF_COUNT; i++) {\r\nif (hso_net->mux_bulk_rx_urb_pool[i])\r\nusb_kill_urb(hso_net->mux_bulk_rx_urb_pool[i]);\r\n}\r\nif (hso_net->mux_bulk_tx_urb)\r\nusb_kill_urb(hso_net->mux_bulk_tx_urb);\r\nreturn 0;\r\n}\r\nstatic int hso_start_serial_device(struct hso_device *hso_dev, gfp_t flags)\r\n{\r\nint i, result = 0;\r\nstruct hso_serial *serial = dev2ser(hso_dev);\r\nif (!serial)\r\nreturn -ENODEV;\r\nif (!(serial->parent->port_spec & HSO_INTF_MUX)) {\r\nfor (i = 0; i < serial->num_rx_urbs; i++) {\r\nusb_fill_bulk_urb(serial->rx_urb[i],\r\nserial->parent->usb,\r\nusb_rcvbulkpipe(serial->parent->usb,\r\nserial->in_endp->\r\nbEndpointAddress &\r\n0x7F),\r\nserial->rx_data[i],\r\nserial->rx_data_length,\r\nhso_std_serial_read_bulk_callback,\r\nserial);\r\nresult = usb_submit_urb(serial->rx_urb[i], flags);\r\nif (result) {\r\ndev_warn(&serial->parent->usb->dev,\r\n"Failed to submit urb - res %d\n",\r\nresult);\r\nbreak;\r\n}\r\n}\r\n} else {\r\nmutex_lock(&serial->shared_int->shared_int_lock);\r\nif (!serial->shared_int->use_count) {\r\nresult =\r\nhso_mux_submit_intr_urb(serial->shared_int,\r\nhso_dev->usb, flags);\r\n}\r\nserial->shared_int->use_count++;\r\nmutex_unlock(&serial->shared_int->shared_int_lock);\r\n}\r\nif (serial->tiocmget)\r\ntiocmget_submit_urb(serial,\r\nserial->tiocmget,\r\nserial->parent->usb);\r\nreturn result;\r\n}\r\nstatic int hso_stop_serial_device(struct hso_device *hso_dev)\r\n{\r\nint i;\r\nstruct hso_serial *serial = dev2ser(hso_dev);\r\nstruct hso_tiocmget *tiocmget;\r\nif (!serial)\r\nreturn -ENODEV;\r\nfor (i = 0; i < serial->num_rx_urbs; i++) {\r\nif (serial->rx_urb[i]) {\r\nusb_kill_urb(serial->rx_urb[i]);\r\nserial->rx_urb_filled[i] = 0;\r\n}\r\n}\r\nserial->curr_rx_urb_idx = 0;\r\nserial->curr_rx_urb_offset = 0;\r\nif (serial->tx_urb)\r\nusb_kill_urb(serial->tx_urb);\r\nif (serial->shared_int) {\r\nmutex_lock(&serial->shared_int->shared_int_lock);\r\nif (serial->shared_int->use_count &&\r\n(--serial->shared_int->use_count == 0)) {\r\nstruct urb *urb;\r\nurb = serial->shared_int->shared_intr_urb;\r\nif (urb)\r\nusb_kill_urb(urb);\r\n}\r\nmutex_unlock(&serial->shared_int->shared_int_lock);\r\n}\r\ntiocmget = serial->tiocmget;\r\nif (tiocmget) {\r\nwake_up_interruptible(&tiocmget->waitq);\r\nusb_kill_urb(tiocmget->urb);\r\n}\r\nreturn 0;\r\n}\r\nstatic void hso_serial_common_free(struct hso_serial *serial)\r\n{\r\nint i;\r\nif (serial->parent->dev)\r\ndevice_remove_file(serial->parent->dev, &dev_attr_hsotype);\r\ntty_unregister_device(tty_drv, serial->minor);\r\nfor (i = 0; i < serial->num_rx_urbs; i++) {\r\nusb_free_urb(serial->rx_urb[i]);\r\nkfree(serial->rx_data[i]);\r\n}\r\nusb_free_urb(serial->tx_urb);\r\nkfree(serial->tx_data);\r\ntty_port_destroy(&serial->port);\r\n}\r\nstatic int hso_serial_common_create(struct hso_serial *serial, int num_urbs,\r\nint rx_size, int tx_size)\r\n{\r\nstruct device *dev;\r\nint minor;\r\nint i;\r\ntty_port_init(&serial->port);\r\nminor = get_free_serial_index();\r\nif (minor < 0)\r\ngoto exit;\r\nserial->parent->dev = tty_port_register_device(&serial->port, tty_drv,\r\nminor, &serial->parent->interface->dev);\r\ndev = serial->parent->dev;\r\ndev_set_drvdata(dev, serial->parent);\r\ni = device_create_file(dev, &dev_attr_hsotype);\r\nserial->minor = minor;\r\nserial->magic = HSO_SERIAL_MAGIC;\r\nspin_lock_init(&serial->serial_lock);\r\nserial->num_rx_urbs = num_urbs;\r\nserial->rx_data_length = rx_size;\r\nfor (i = 0; i < serial->num_rx_urbs; i++) {\r\nserial->rx_urb[i] = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!serial->rx_urb[i]) {\r\ndev_err(dev, "Could not allocate urb?\n");\r\ngoto exit;\r\n}\r\nserial->rx_urb[i]->transfer_buffer = NULL;\r\nserial->rx_urb[i]->transfer_buffer_length = 0;\r\nserial->rx_data[i] = kzalloc(serial->rx_data_length,\r\nGFP_KERNEL);\r\nif (!serial->rx_data[i])\r\ngoto exit;\r\n}\r\nserial->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!serial->tx_urb) {\r\ndev_err(dev, "Could not allocate urb?\n");\r\ngoto exit;\r\n}\r\nserial->tx_urb->transfer_buffer = NULL;\r\nserial->tx_urb->transfer_buffer_length = 0;\r\nserial->tx_data_count = 0;\r\nserial->tx_buffer_count = 0;\r\nserial->tx_data_length = tx_size;\r\nserial->tx_data = kzalloc(serial->tx_data_length, GFP_KERNEL);\r\nif (!serial->tx_data)\r\ngoto exit;\r\nserial->tx_buffer = kzalloc(serial->tx_data_length, GFP_KERNEL);\r\nif (!serial->tx_buffer)\r\ngoto exit;\r\nreturn 0;\r\nexit:\r\nhso_serial_common_free(serial);\r\nreturn -1;\r\n}\r\nstatic struct hso_device *hso_create_device(struct usb_interface *intf,\r\nint port_spec)\r\n{\r\nstruct hso_device *hso_dev;\r\nhso_dev = kzalloc(sizeof(*hso_dev), GFP_ATOMIC);\r\nif (!hso_dev)\r\nreturn NULL;\r\nhso_dev->port_spec = port_spec;\r\nhso_dev->usb = interface_to_usbdev(intf);\r\nhso_dev->interface = intf;\r\nkref_init(&hso_dev->ref);\r\nmutex_init(&hso_dev->mutex);\r\nINIT_WORK(&hso_dev->async_get_intf, async_get_intf);\r\nINIT_WORK(&hso_dev->async_put_intf, async_put_intf);\r\nINIT_WORK(&hso_dev->reset_device, reset_device);\r\nreturn hso_dev;\r\n}\r\nstatic int remove_net_device(struct hso_device *hso_dev)\r\n{\r\nint i;\r\nfor (i = 0; i < HSO_MAX_NET_DEVICES; i++) {\r\nif (network_table[i] == hso_dev) {\r\nnetwork_table[i] = NULL;\r\nbreak;\r\n}\r\n}\r\nif (i == HSO_MAX_NET_DEVICES)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void hso_free_net_device(struct hso_device *hso_dev)\r\n{\r\nint i;\r\nstruct hso_net *hso_net = dev2net(hso_dev);\r\nif (!hso_net)\r\nreturn;\r\nremove_net_device(hso_net->parent);\r\nif (hso_net->net)\r\nunregister_netdev(hso_net->net);\r\nfor (i = 0; i < MUX_BULK_RX_BUF_COUNT; i++) {\r\nusb_free_urb(hso_net->mux_bulk_rx_urb_pool[i]);\r\nkfree(hso_net->mux_bulk_rx_buf_pool[i]);\r\nhso_net->mux_bulk_rx_buf_pool[i] = NULL;\r\n}\r\nusb_free_urb(hso_net->mux_bulk_tx_urb);\r\nkfree(hso_net->mux_bulk_tx_buf);\r\nhso_net->mux_bulk_tx_buf = NULL;\r\nif (hso_net->net)\r\nfree_netdev(hso_net->net);\r\nkfree(hso_dev);\r\n}\r\nstatic void hso_net_init(struct net_device *net)\r\n{\r\nstruct hso_net *hso_net = netdev_priv(net);\r\nD1("sizeof hso_net is %d", (int)sizeof(*hso_net));\r\nnet->netdev_ops = &hso_netdev_ops;\r\nnet->watchdog_timeo = HSO_NET_TX_TIMEOUT;\r\nnet->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\r\nnet->type = ARPHRD_NONE;\r\nnet->mtu = DEFAULT_MTU - 14;\r\nnet->tx_queue_len = 10;\r\nSET_ETHTOOL_OPS(net, &ops);\r\nspin_lock_init(&hso_net->net_lock);\r\n}\r\nstatic int add_net_device(struct hso_device *hso_dev)\r\n{\r\nint i;\r\nfor (i = 0; i < HSO_MAX_NET_DEVICES; i++) {\r\nif (network_table[i] == NULL) {\r\nnetwork_table[i] = hso_dev;\r\nbreak;\r\n}\r\n}\r\nif (i == HSO_MAX_NET_DEVICES)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int hso_rfkill_set_block(void *data, bool blocked)\r\n{\r\nstruct hso_device *hso_dev = data;\r\nint enabled = !blocked;\r\nint rv;\r\nmutex_lock(&hso_dev->mutex);\r\nif (hso_dev->usb_gone)\r\nrv = 0;\r\nelse\r\nrv = usb_control_msg(hso_dev->usb, usb_rcvctrlpipe(hso_dev->usb, 0),\r\nenabled ? 0x82 : 0x81, 0x40, 0, 0, NULL, 0,\r\nUSB_CTRL_SET_TIMEOUT);\r\nmutex_unlock(&hso_dev->mutex);\r\nreturn rv;\r\n}\r\nstatic void hso_create_rfkill(struct hso_device *hso_dev,\r\nstruct usb_interface *interface)\r\n{\r\nstruct hso_net *hso_net = dev2net(hso_dev);\r\nstruct device *dev = &hso_net->net->dev;\r\nchar *rfkn;\r\nrfkn = kzalloc(20, GFP_KERNEL);\r\nif (!rfkn)\r\ndev_err(dev, "%s - Out of memory\n", __func__);\r\nsnprintf(rfkn, 20, "hso-%d",\r\ninterface->altsetting->desc.bInterfaceNumber);\r\nhso_net->rfkill = rfkill_alloc(rfkn,\r\n&interface_to_usbdev(interface)->dev,\r\nRFKILL_TYPE_WWAN,\r\n&hso_rfkill_ops, hso_dev);\r\nif (!hso_net->rfkill) {\r\ndev_err(dev, "%s - Out of memory\n", __func__);\r\nkfree(rfkn);\r\nreturn;\r\n}\r\nif (rfkill_register(hso_net->rfkill) < 0) {\r\nrfkill_destroy(hso_net->rfkill);\r\nkfree(rfkn);\r\nhso_net->rfkill = NULL;\r\ndev_err(dev, "%s - Failed to register rfkill\n", __func__);\r\nreturn;\r\n}\r\n}\r\nstatic struct hso_device *hso_create_net_device(struct usb_interface *interface,\r\nint port_spec)\r\n{\r\nint result, i;\r\nstruct net_device *net;\r\nstruct hso_net *hso_net;\r\nstruct hso_device *hso_dev;\r\nhso_dev = hso_create_device(interface, port_spec);\r\nif (!hso_dev)\r\nreturn NULL;\r\nnet = alloc_netdev(sizeof(struct hso_net), "hso%d", hso_net_init);\r\nif (!net) {\r\ndev_err(&interface->dev, "Unable to create ethernet device\n");\r\ngoto exit;\r\n}\r\nhso_net = netdev_priv(net);\r\nhso_dev->port_data.dev_net = hso_net;\r\nhso_net->net = net;\r\nhso_net->parent = hso_dev;\r\nhso_net->in_endp = hso_get_ep(interface, USB_ENDPOINT_XFER_BULK,\r\nUSB_DIR_IN);\r\nif (!hso_net->in_endp) {\r\ndev_err(&interface->dev, "Can't find BULK IN endpoint\n");\r\ngoto exit;\r\n}\r\nhso_net->out_endp = hso_get_ep(interface, USB_ENDPOINT_XFER_BULK,\r\nUSB_DIR_OUT);\r\nif (!hso_net->out_endp) {\r\ndev_err(&interface->dev, "Can't find BULK OUT endpoint\n");\r\ngoto exit;\r\n}\r\nSET_NETDEV_DEV(net, &interface->dev);\r\nSET_NETDEV_DEVTYPE(net, &hso_type);\r\nresult = register_netdev(net);\r\nif (result) {\r\ndev_err(&interface->dev, "Failed to register device\n");\r\ngoto exit;\r\n}\r\nfor (i = 0; i < MUX_BULK_RX_BUF_COUNT; i++) {\r\nhso_net->mux_bulk_rx_urb_pool[i] = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!hso_net->mux_bulk_rx_urb_pool[i]) {\r\ndev_err(&interface->dev, "Could not allocate rx urb\n");\r\ngoto exit;\r\n}\r\nhso_net->mux_bulk_rx_buf_pool[i] = kzalloc(MUX_BULK_RX_BUF_SIZE,\r\nGFP_KERNEL);\r\nif (!hso_net->mux_bulk_rx_buf_pool[i])\r\ngoto exit;\r\n}\r\nhso_net->mux_bulk_tx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!hso_net->mux_bulk_tx_urb) {\r\ndev_err(&interface->dev, "Could not allocate tx urb\n");\r\ngoto exit;\r\n}\r\nhso_net->mux_bulk_tx_buf = kzalloc(MUX_BULK_TX_BUF_SIZE, GFP_KERNEL);\r\nif (!hso_net->mux_bulk_tx_buf)\r\ngoto exit;\r\nadd_net_device(hso_dev);\r\nhso_log_port(hso_dev);\r\nhso_create_rfkill(hso_dev, interface);\r\nreturn hso_dev;\r\nexit:\r\nhso_free_net_device(hso_dev);\r\nreturn NULL;\r\n}\r\nstatic void hso_free_tiomget(struct hso_serial *serial)\r\n{\r\nstruct hso_tiocmget *tiocmget;\r\nif (!serial)\r\nreturn;\r\ntiocmget = serial->tiocmget;\r\nif (tiocmget) {\r\nusb_free_urb(tiocmget->urb);\r\ntiocmget->urb = NULL;\r\nserial->tiocmget = NULL;\r\nkfree(tiocmget);\r\n}\r\n}\r\nstatic void hso_free_serial_device(struct hso_device *hso_dev)\r\n{\r\nstruct hso_serial *serial = dev2ser(hso_dev);\r\nif (!serial)\r\nreturn;\r\nset_serial_by_index(serial->minor, NULL);\r\nhso_serial_common_free(serial);\r\nif (serial->shared_int) {\r\nmutex_lock(&serial->shared_int->shared_int_lock);\r\nif (--serial->shared_int->ref_count == 0)\r\nhso_free_shared_int(serial->shared_int);\r\nelse\r\nmutex_unlock(&serial->shared_int->shared_int_lock);\r\n}\r\nhso_free_tiomget(serial);\r\nkfree(serial);\r\nkfree(hso_dev);\r\n}\r\nstatic struct hso_device *hso_create_bulk_serial_device(\r\nstruct usb_interface *interface, int port)\r\n{\r\nstruct hso_device *hso_dev;\r\nstruct hso_serial *serial;\r\nint num_urbs;\r\nstruct hso_tiocmget *tiocmget;\r\nhso_dev = hso_create_device(interface, port);\r\nif (!hso_dev)\r\nreturn NULL;\r\nserial = kzalloc(sizeof(*serial), GFP_KERNEL);\r\nif (!serial)\r\ngoto exit;\r\nserial->parent = hso_dev;\r\nhso_dev->port_data.dev_serial = serial;\r\nif ((port & HSO_PORT_MASK) == HSO_PORT_MODEM) {\r\nnum_urbs = 2;\r\nserial->tiocmget = kzalloc(sizeof(struct hso_tiocmget),\r\nGFP_KERNEL);\r\nif (serial->tiocmget) {\r\ntiocmget = serial->tiocmget;\r\ntiocmget->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (tiocmget->urb) {\r\nmutex_init(&tiocmget->mutex);\r\ninit_waitqueue_head(&tiocmget->waitq);\r\ntiocmget->endp = hso_get_ep(\r\ninterface,\r\nUSB_ENDPOINT_XFER_INT,\r\nUSB_DIR_IN);\r\n} else\r\nhso_free_tiomget(serial);\r\n}\r\n}\r\nelse\r\nnum_urbs = 1;\r\nif (hso_serial_common_create(serial, num_urbs, BULK_URB_RX_SIZE,\r\nBULK_URB_TX_SIZE))\r\ngoto exit;\r\nserial->in_endp = hso_get_ep(interface, USB_ENDPOINT_XFER_BULK,\r\nUSB_DIR_IN);\r\nif (!serial->in_endp) {\r\ndev_err(&interface->dev, "Failed to find BULK IN ep\n");\r\ngoto exit2;\r\n}\r\nif (!\r\n(serial->out_endp =\r\nhso_get_ep(interface, USB_ENDPOINT_XFER_BULK, USB_DIR_OUT))) {\r\ndev_err(&interface->dev, "Failed to find BULK IN ep\n");\r\ngoto exit2;\r\n}\r\nserial->write_data = hso_std_serial_write_data;\r\nset_serial_by_index(serial->minor, serial);\r\nhso_log_port(hso_dev);\r\nreturn hso_dev;\r\nexit2:\r\nhso_serial_common_free(serial);\r\nexit:\r\nhso_free_tiomget(serial);\r\nkfree(serial);\r\nkfree(hso_dev);\r\nreturn NULL;\r\n}\r\nstatic\r\nstruct hso_device *hso_create_mux_serial_device(struct usb_interface *interface,\r\nint port,\r\nstruct hso_shared_int *mux)\r\n{\r\nstruct hso_device *hso_dev;\r\nstruct hso_serial *serial;\r\nint port_spec;\r\nport_spec = HSO_INTF_MUX;\r\nport_spec &= ~HSO_PORT_MASK;\r\nport_spec |= hso_mux_to_port(port);\r\nif ((port_spec & HSO_PORT_MASK) == HSO_PORT_NO_PORT)\r\nreturn NULL;\r\nhso_dev = hso_create_device(interface, port_spec);\r\nif (!hso_dev)\r\nreturn NULL;\r\nserial = kzalloc(sizeof(*serial), GFP_KERNEL);\r\nif (!serial)\r\ngoto exit;\r\nhso_dev->port_data.dev_serial = serial;\r\nserial->parent = hso_dev;\r\nif (hso_serial_common_create\r\n(serial, 1, CTRL_URB_RX_SIZE, CTRL_URB_TX_SIZE))\r\ngoto exit;\r\nserial->tx_data_length--;\r\nserial->write_data = hso_mux_serial_write_data;\r\nserial->shared_int = mux;\r\nmutex_lock(&serial->shared_int->shared_int_lock);\r\nserial->shared_int->ref_count++;\r\nmutex_unlock(&serial->shared_int->shared_int_lock);\r\nset_serial_by_index(serial->minor, serial);\r\nhso_log_port(hso_dev);\r\nreturn hso_dev;\r\nexit:\r\nif (serial) {\r\ntty_unregister_device(tty_drv, serial->minor);\r\nkfree(serial);\r\n}\r\nif (hso_dev)\r\nkfree(hso_dev);\r\nreturn NULL;\r\n}\r\nstatic void hso_free_shared_int(struct hso_shared_int *mux)\r\n{\r\nusb_free_urb(mux->shared_intr_urb);\r\nkfree(mux->shared_intr_buf);\r\nmutex_unlock(&mux->shared_int_lock);\r\nkfree(mux);\r\n}\r\nstatic\r\nstruct hso_shared_int *hso_create_shared_int(struct usb_interface *interface)\r\n{\r\nstruct hso_shared_int *mux = kzalloc(sizeof(*mux), GFP_KERNEL);\r\nif (!mux)\r\nreturn NULL;\r\nmux->intr_endp = hso_get_ep(interface, USB_ENDPOINT_XFER_INT,\r\nUSB_DIR_IN);\r\nif (!mux->intr_endp) {\r\ndev_err(&interface->dev, "Can't find INT IN endpoint\n");\r\ngoto exit;\r\n}\r\nmux->shared_intr_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!mux->shared_intr_urb) {\r\ndev_err(&interface->dev, "Could not allocate intr urb?\n");\r\ngoto exit;\r\n}\r\nmux->shared_intr_buf =\r\nkzalloc(le16_to_cpu(mux->intr_endp->wMaxPacketSize),\r\nGFP_KERNEL);\r\nif (!mux->shared_intr_buf)\r\ngoto exit;\r\nmutex_init(&mux->shared_int_lock);\r\nreturn mux;\r\nexit:\r\nkfree(mux->shared_intr_buf);\r\nusb_free_urb(mux->shared_intr_urb);\r\nkfree(mux);\r\nreturn NULL;\r\n}\r\nstatic int hso_get_config_data(struct usb_interface *interface)\r\n{\r\nstruct usb_device *usbdev = interface_to_usbdev(interface);\r\nu8 *config_data = kmalloc(17, GFP_KERNEL);\r\nu32 if_num = interface->altsetting->desc.bInterfaceNumber;\r\ns32 result;\r\nif (!config_data)\r\nreturn -ENOMEM;\r\nif (usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\r\n0x86, 0xC0, 0, 0, config_data, 17,\r\nUSB_CTRL_SET_TIMEOUT) != 0x11) {\r\nkfree(config_data);\r\nreturn -EIO;\r\n}\r\nswitch (config_data[if_num]) {\r\ncase 0x0:\r\nresult = 0;\r\nbreak;\r\ncase 0x1:\r\nresult = HSO_PORT_DIAG;\r\nbreak;\r\ncase 0x2:\r\nresult = HSO_PORT_GPS;\r\nbreak;\r\ncase 0x3:\r\nresult = HSO_PORT_GPS_CONTROL;\r\nbreak;\r\ncase 0x4:\r\nresult = HSO_PORT_APP;\r\nbreak;\r\ncase 0x5:\r\nresult = HSO_PORT_APP2;\r\nbreak;\r\ncase 0x6:\r\nresult = HSO_PORT_CONTROL;\r\nbreak;\r\ncase 0x7:\r\nresult = HSO_PORT_NETWORK;\r\nbreak;\r\ncase 0x8:\r\nresult = HSO_PORT_MODEM;\r\nbreak;\r\ncase 0x9:\r\nresult = HSO_PORT_MSD;\r\nbreak;\r\ncase 0xa:\r\nresult = HSO_PORT_PCSC;\r\nbreak;\r\ncase 0xb:\r\nresult = HSO_PORT_VOICE;\r\nbreak;\r\ndefault:\r\nresult = 0;\r\n}\r\nif (result)\r\nresult |= HSO_INTF_BULK;\r\nif (config_data[16] & 0x1)\r\nresult |= HSO_INFO_CRC_BUG;\r\nkfree(config_data);\r\nreturn result;\r\n}\r\nstatic int hso_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nint mux, i, if_num, port_spec;\r\nunsigned char port_mask;\r\nstruct hso_device *hso_dev = NULL;\r\nstruct hso_shared_int *shared_int;\r\nstruct hso_device *tmp_dev = NULL;\r\nif (interface->cur_altsetting->desc.bInterfaceClass != 0xFF) {\r\ndev_err(&interface->dev, "Not our interface\n");\r\nreturn -ENODEV;\r\n}\r\nif_num = interface->altsetting->desc.bInterfaceNumber;\r\nif (id->driver_info)\r\nport_spec = ((u32 *)(id->driver_info))[if_num];\r\nelse\r\nport_spec = hso_get_config_data(interface);\r\nif (interface->num_altsetting > 1)\r\nusb_set_interface(interface_to_usbdev(interface), if_num, 1);\r\ninterface->needs_remote_wakeup = 1;\r\nswitch (port_spec & HSO_INTF_MASK) {\r\ncase HSO_INTF_MUX:\r\nif ((port_spec & HSO_PORT_MASK) == HSO_PORT_NETWORK) {\r\nif (!disable_net) {\r\nhso_dev = hso_create_net_device(interface,\r\nport_spec);\r\nif (!hso_dev)\r\ngoto exit;\r\ntmp_dev = hso_dev;\r\n}\r\n}\r\nif (hso_get_mux_ports(interface, &port_mask))\r\ngoto exit;\r\nshared_int = hso_create_shared_int(interface);\r\nif (!shared_int)\r\ngoto exit;\r\nfor (i = 1, mux = 0; i < 0x100; i = i << 1, mux++) {\r\nif (port_mask & i) {\r\nhso_dev = hso_create_mux_serial_device(\r\ninterface, i, shared_int);\r\nif (!hso_dev)\r\ngoto exit;\r\n}\r\n}\r\nif (tmp_dev)\r\nhso_dev = tmp_dev;\r\nbreak;\r\ncase HSO_INTF_BULK:\r\nif ((port_spec & HSO_PORT_MASK) == HSO_PORT_NETWORK) {\r\nif (!disable_net)\r\nhso_dev =\r\nhso_create_net_device(interface, port_spec);\r\n} else {\r\nhso_dev =\r\nhso_create_bulk_serial_device(interface, port_spec);\r\n}\r\nif (!hso_dev)\r\ngoto exit;\r\nbreak;\r\ndefault:\r\ngoto exit;\r\n}\r\nusb_set_intfdata(interface, hso_dev);\r\nreturn 0;\r\nexit:\r\nhso_free_interface(interface);\r\nreturn -ENODEV;\r\n}\r\nstatic void hso_disconnect(struct usb_interface *interface)\r\n{\r\nhso_free_interface(interface);\r\nusb_set_intfdata(interface, NULL);\r\n}\r\nstatic void async_get_intf(struct work_struct *data)\r\n{\r\nstruct hso_device *hso_dev =\r\ncontainer_of(data, struct hso_device, async_get_intf);\r\nusb_autopm_get_interface(hso_dev->interface);\r\n}\r\nstatic void async_put_intf(struct work_struct *data)\r\n{\r\nstruct hso_device *hso_dev =\r\ncontainer_of(data, struct hso_device, async_put_intf);\r\nusb_autopm_put_interface(hso_dev->interface);\r\n}\r\nstatic int hso_get_activity(struct hso_device *hso_dev)\r\n{\r\nif (hso_dev->usb->state == USB_STATE_SUSPENDED) {\r\nif (!hso_dev->is_active) {\r\nhso_dev->is_active = 1;\r\nschedule_work(&hso_dev->async_get_intf);\r\n}\r\n}\r\nif (hso_dev->usb->state != USB_STATE_CONFIGURED)\r\nreturn -EAGAIN;\r\nusb_mark_last_busy(hso_dev->usb);\r\nreturn 0;\r\n}\r\nstatic int hso_put_activity(struct hso_device *hso_dev)\r\n{\r\nif (hso_dev->usb->state != USB_STATE_SUSPENDED) {\r\nif (hso_dev->is_active) {\r\nhso_dev->is_active = 0;\r\nschedule_work(&hso_dev->async_put_intf);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nhso_dev->is_active = 0;\r\nreturn 0;\r\n}\r\nstatic int hso_suspend(struct usb_interface *iface, pm_message_t message)\r\n{\r\nint i, result;\r\nfor (i = 0; i < HSO_SERIAL_TTY_MINORS; i++) {\r\nif (serial_table[i] && (serial_table[i]->interface == iface)) {\r\nresult = hso_stop_serial_device(serial_table[i]);\r\nif (result)\r\ngoto out;\r\n}\r\n}\r\nfor (i = 0; i < HSO_MAX_NET_DEVICES; i++) {\r\nif (network_table[i] &&\r\n(network_table[i]->interface == iface)) {\r\nresult = hso_stop_net_device(network_table[i]);\r\nif (result)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn 0;\r\n}\r\nstatic int hso_resume(struct usb_interface *iface)\r\n{\r\nint i, result = 0;\r\nstruct hso_net *hso_net;\r\nfor (i = 0; i < HSO_SERIAL_TTY_MINORS; i++) {\r\nif (serial_table[i] && (serial_table[i]->interface == iface)) {\r\nif (dev2ser(serial_table[i])->port.count) {\r\nresult =\r\nhso_start_serial_device(serial_table[i], GFP_NOIO);\r\nhso_kick_transmit(dev2ser(serial_table[i]));\r\nif (result)\r\ngoto out;\r\n}\r\n}\r\n}\r\nfor (i = 0; i < HSO_MAX_NET_DEVICES; i++) {\r\nif (network_table[i] &&\r\n(network_table[i]->interface == iface)) {\r\nhso_net = dev2net(network_table[i]);\r\nif (hso_net->flags & IFF_UP) {\r\nif (hso_net->skb_tx_buf) {\r\ndev_dbg(&iface->dev,\r\n"Transmitting"\r\n" lingering data\n");\r\nhso_net_start_xmit(hso_net->skb_tx_buf,\r\nhso_net->net);\r\nhso_net->skb_tx_buf = NULL;\r\n}\r\nresult = hso_start_net_device(network_table[i]);\r\nif (result)\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\nreturn result;\r\n}\r\nstatic void reset_device(struct work_struct *data)\r\n{\r\nstruct hso_device *hso_dev =\r\ncontainer_of(data, struct hso_device, reset_device);\r\nstruct usb_device *usb = hso_dev->usb;\r\nint result;\r\nif (hso_dev->usb_gone) {\r\nD1("No reset during disconnect\n");\r\n} else {\r\nresult = usb_lock_device_for_reset(usb, hso_dev->interface);\r\nif (result < 0)\r\nD1("unable to lock device for reset: %d\n", result);\r\nelse {\r\nusb_reset_device(usb);\r\nusb_unlock_device(usb);\r\n}\r\n}\r\n}\r\nstatic void hso_serial_ref_free(struct kref *ref)\r\n{\r\nstruct hso_device *hso_dev = container_of(ref, struct hso_device, ref);\r\nhso_free_serial_device(hso_dev);\r\n}\r\nstatic void hso_free_interface(struct usb_interface *interface)\r\n{\r\nstruct hso_serial *hso_dev;\r\nint i;\r\nfor (i = 0; i < HSO_SERIAL_TTY_MINORS; i++) {\r\nif (serial_table[i] &&\r\n(serial_table[i]->interface == interface)) {\r\nhso_dev = dev2ser(serial_table[i]);\r\ntty_port_tty_hangup(&hso_dev->port, false);\r\nmutex_lock(&hso_dev->parent->mutex);\r\nhso_dev->parent->usb_gone = 1;\r\nmutex_unlock(&hso_dev->parent->mutex);\r\nkref_put(&serial_table[i]->ref, hso_serial_ref_free);\r\n}\r\n}\r\nfor (i = 0; i < HSO_MAX_NET_DEVICES; i++) {\r\nif (network_table[i] &&\r\n(network_table[i]->interface == interface)) {\r\nstruct rfkill *rfk = dev2net(network_table[i])->rfkill;\r\nnetif_stop_queue(dev2net(network_table[i])->net);\r\nhso_stop_net_device(network_table[i]);\r\ncancel_work_sync(&network_table[i]->async_put_intf);\r\ncancel_work_sync(&network_table[i]->async_get_intf);\r\nif (rfk) {\r\nrfkill_unregister(rfk);\r\nrfkill_destroy(rfk);\r\n}\r\nhso_free_net_device(network_table[i]);\r\n}\r\n}\r\n}\r\nstatic struct usb_endpoint_descriptor *hso_get_ep(struct usb_interface *intf,\r\nint type, int dir)\r\n{\r\nint i;\r\nstruct usb_host_interface *iface = intf->cur_altsetting;\r\nstruct usb_endpoint_descriptor *endp;\r\nfor (i = 0; i < iface->desc.bNumEndpoints; i++) {\r\nendp = &iface->endpoint[i].desc;\r\nif (((endp->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == dir) &&\r\n(usb_endpoint_type(endp) == type))\r\nreturn endp;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int hso_get_mux_ports(struct usb_interface *intf, unsigned char *ports)\r\n{\r\nint i;\r\nstruct usb_host_interface *iface = intf->cur_altsetting;\r\nif (iface->extralen == 3) {\r\n*ports = iface->extra[2];\r\nreturn 0;\r\n}\r\nfor (i = 0; i < iface->desc.bNumEndpoints; i++) {\r\nif (iface->endpoint[i].extralen == 3) {\r\n*ports = iface->endpoint[i].extra[2];\r\nreturn 0;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int hso_mux_submit_intr_urb(struct hso_shared_int *shared_int,\r\nstruct usb_device *usb, gfp_t gfp)\r\n{\r\nint result;\r\nusb_fill_int_urb(shared_int->shared_intr_urb, usb,\r\nusb_rcvintpipe(usb,\r\nshared_int->intr_endp->bEndpointAddress & 0x7F),\r\nshared_int->shared_intr_buf,\r\n1,\r\nintr_callback, shared_int,\r\nshared_int->intr_endp->bInterval);\r\nresult = usb_submit_urb(shared_int->shared_intr_urb, gfp);\r\nif (result)\r\ndev_warn(&usb->dev, "%s failed mux_intr_urb %d\n", __func__,\r\nresult);\r\nreturn result;\r\n}\r\nstatic int __init hso_init(void)\r\n{\r\nint i;\r\nint result;\r\nprintk(KERN_INFO "hso: %s\n", version);\r\nspin_lock_init(&serial_table_lock);\r\nfor (i = 0; i < HSO_SERIAL_TTY_MINORS; i++)\r\nserial_table[i] = NULL;\r\ntty_drv = alloc_tty_driver(HSO_SERIAL_TTY_MINORS);\r\nif (!tty_drv)\r\nreturn -ENOMEM;\r\ntty_drv->driver_name = driver_name;\r\ntty_drv->name = tty_filename;\r\nif (tty_major)\r\ntty_drv->major = tty_major;\r\ntty_drv->minor_start = 0;\r\ntty_drv->type = TTY_DRIVER_TYPE_SERIAL;\r\ntty_drv->subtype = SERIAL_TYPE_NORMAL;\r\ntty_drv->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\r\ntty_drv->init_termios = tty_std_termios;\r\nhso_init_termios(&tty_drv->init_termios);\r\ntty_set_operations(tty_drv, &hso_serial_ops);\r\nresult = tty_register_driver(tty_drv);\r\nif (result) {\r\nprintk(KERN_ERR "%s - tty_register_driver failed(%d)\n",\r\n__func__, result);\r\ngoto err_free_tty;\r\n}\r\nresult = usb_register(&hso_driver);\r\nif (result) {\r\nprintk(KERN_ERR "Could not register hso driver? error: %d\n",\r\nresult);\r\ngoto err_unreg_tty;\r\n}\r\nreturn 0;\r\nerr_unreg_tty:\r\ntty_unregister_driver(tty_drv);\r\nerr_free_tty:\r\nput_tty_driver(tty_drv);\r\nreturn result;\r\n}\r\nstatic void __exit hso_exit(void)\r\n{\r\nprintk(KERN_INFO "hso: unloaded\n");\r\ntty_unregister_driver(tty_drv);\r\nput_tty_driver(tty_drv);\r\nusb_deregister(&hso_driver);\r\n}
