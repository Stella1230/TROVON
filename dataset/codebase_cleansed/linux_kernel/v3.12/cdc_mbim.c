static int cdc_mbim_manage_power(struct usbnet *dev, int on)\r\n{\r\nstruct cdc_mbim_state *info = (void *)&dev->data;\r\nint rv = 0;\r\ndev_dbg(&dev->intf->dev, "%s() pmcount=%d, on=%d\n", __func__, atomic_read(&info->pmcount), on);\r\nif ((on && atomic_add_return(1, &info->pmcount) == 1) || (!on && atomic_dec_and_test(&info->pmcount))) {\r\nrv = usb_autopm_get_interface(dev->intf);\r\nif (rv < 0)\r\ngoto err;\r\ndev->intf->needs_remote_wakeup = on;\r\nusb_autopm_put_interface(dev->intf);\r\n}\r\nerr:\r\nreturn rv;\r\n}\r\nstatic int cdc_mbim_wdm_manage_power(struct usb_interface *intf, int status)\r\n{\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nif (!dev)\r\nreturn 0;\r\nreturn cdc_mbim_manage_power(dev, status);\r\n}\r\nstatic int cdc_mbim_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct cdc_ncm_ctx *ctx;\r\nstruct usb_driver *subdriver = ERR_PTR(-ENODEV);\r\nint ret = -ENODEV;\r\nu8 data_altsetting = cdc_ncm_select_altsetting(dev, intf);\r\nstruct cdc_mbim_state *info = (void *)&dev->data;\r\nif (!cdc_ncm_comm_intf_is_mbim(intf->cur_altsetting))\r\ngoto err;\r\nret = cdc_ncm_bind_common(dev, intf, data_altsetting);\r\nif (ret)\r\ngoto err;\r\nctx = info->ctx;\r\nif (ctx->mbim_desc && dev->status)\r\nsubdriver = usb_cdc_wdm_register(ctx->control,\r\n&dev->status->desc,\r\nle16_to_cpu(ctx->mbim_desc->wMaxControlMessage),\r\ncdc_mbim_wdm_manage_power);\r\nif (IS_ERR(subdriver)) {\r\nret = PTR_ERR(subdriver);\r\ncdc_ncm_unbind(dev, intf);\r\ngoto err;\r\n}\r\ndev->status = NULL;\r\ninfo->subdriver = subdriver;\r\ndev->net->flags |= IFF_NOARP;\r\ndev->net->features |= NETIF_F_HW_VLAN_CTAG_TX;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void cdc_mbim_unbind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct cdc_mbim_state *info = (void *)&dev->data;\r\nstruct cdc_ncm_ctx *ctx = info->ctx;\r\nif (info->subdriver && info->subdriver->disconnect)\r\ninfo->subdriver->disconnect(ctx->control);\r\ninfo->subdriver = NULL;\r\ncdc_ncm_unbind(dev, intf);\r\n}\r\nstatic struct sk_buff *cdc_mbim_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\r\n{\r\nstruct sk_buff *skb_out;\r\nstruct cdc_mbim_state *info = (void *)&dev->data;\r\nstruct cdc_ncm_ctx *ctx = info->ctx;\r\n__le32 sign = cpu_to_le32(USB_CDC_MBIM_NDP16_IPS_SIGN);\r\nu16 tci = 0;\r\nu8 *c;\r\nif (!ctx)\r\ngoto error;\r\nif (skb) {\r\nif (skb->len <= ETH_HLEN)\r\ngoto error;\r\nvlan_get_tag(skb, &tci);\r\nswitch (tci & 0x0f00) {\r\ncase 0x0000:\r\nskb_reset_mac_header(skb);\r\nswitch (eth_hdr(skb)->h_proto) {\r\ncase htons(ETH_P_IP):\r\ncase htons(ETH_P_IPV6):\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nc = (u8 *)&sign;\r\nc[3] = tci;\r\nbreak;\r\ncase 0x0100:\r\nsign = cpu_to_le32(USB_CDC_MBIM_NDP16_DSS_SIGN);\r\nc = (u8 *)&sign;\r\nc[3] = tci;\r\nbreak;\r\ndefault:\r\nnetif_err(dev, tx_err, dev->net,\r\n"unsupported tci=0x%04x\n", tci);\r\ngoto error;\r\n}\r\nskb_pull(skb, ETH_HLEN);\r\n}\r\nspin_lock_bh(&ctx->mtx);\r\nskb_out = cdc_ncm_fill_tx_frame(ctx, skb, sign);\r\nspin_unlock_bh(&ctx->mtx);\r\nreturn skb_out;\r\nerror:\r\nif (skb)\r\ndev_kfree_skb_any(skb);\r\nreturn NULL;\r\n}\r\nstatic struct sk_buff *cdc_mbim_process_dgram(struct usbnet *dev, u8 *buf, size_t len, u16 tci)\r\n{\r\n__be16 proto = htons(ETH_P_802_3);\r\nstruct sk_buff *skb = NULL;\r\nif (tci < 256) {\r\nif (len < sizeof(struct iphdr))\r\ngoto err;\r\nswitch (*buf & 0xf0) {\r\ncase 0x40:\r\nproto = htons(ETH_P_IP);\r\nbreak;\r\ncase 0x60:\r\nproto = htons(ETH_P_IPV6);\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\n}\r\nskb = netdev_alloc_skb_ip_align(dev->net, len + ETH_HLEN);\r\nif (!skb)\r\ngoto err;\r\nskb_put(skb, ETH_HLEN);\r\nskb_reset_mac_header(skb);\r\neth_hdr(skb)->h_proto = proto;\r\nmemset(eth_hdr(skb)->h_source, 0, ETH_ALEN);\r\nmemcpy(eth_hdr(skb)->h_dest, dev->net->dev_addr, ETH_ALEN);\r\nmemcpy(skb_put(skb, len), buf, len);\r\nif (tci)\r\nvlan_put_tag(skb, htons(ETH_P_8021Q), tci);\r\nerr:\r\nreturn skb;\r\n}\r\nstatic int cdc_mbim_rx_fixup(struct usbnet *dev, struct sk_buff *skb_in)\r\n{\r\nstruct sk_buff *skb;\r\nstruct cdc_mbim_state *info = (void *)&dev->data;\r\nstruct cdc_ncm_ctx *ctx = info->ctx;\r\nint len;\r\nint nframes;\r\nint x;\r\nint offset;\r\nstruct usb_cdc_ncm_ndp16 *ndp16;\r\nstruct usb_cdc_ncm_dpe16 *dpe16;\r\nint ndpoffset;\r\nint loopcount = 50;\r\nu8 *c;\r\nu16 tci;\r\nndpoffset = cdc_ncm_rx_verify_nth16(ctx, skb_in);\r\nif (ndpoffset < 0)\r\ngoto error;\r\nnext_ndp:\r\nnframes = cdc_ncm_rx_verify_ndp16(skb_in, ndpoffset);\r\nif (nframes < 0)\r\ngoto error;\r\nndp16 = (struct usb_cdc_ncm_ndp16 *)(skb_in->data + ndpoffset);\r\nswitch (ndp16->dwSignature & cpu_to_le32(0x00ffffff)) {\r\ncase cpu_to_le32(USB_CDC_MBIM_NDP16_IPS_SIGN):\r\nc = (u8 *)&ndp16->dwSignature;\r\ntci = c[3];\r\nbreak;\r\ncase cpu_to_le32(USB_CDC_MBIM_NDP16_DSS_SIGN):\r\nc = (u8 *)&ndp16->dwSignature;\r\ntci = c[3] + 256;\r\nbreak;\r\ndefault:\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"unsupported NDP signature <0x%08x>\n",\r\nle32_to_cpu(ndp16->dwSignature));\r\ngoto err_ndp;\r\n}\r\ndpe16 = ndp16->dpe16;\r\nfor (x = 0; x < nframes; x++, dpe16++) {\r\noffset = le16_to_cpu(dpe16->wDatagramIndex);\r\nlen = le16_to_cpu(dpe16->wDatagramLength);\r\nif ((offset == 0) || (len == 0)) {\r\nif (!x)\r\ngoto err_ndp;\r\nbreak;\r\n}\r\nif (((offset + len) > skb_in->len) || (len > ctx->rx_max)) {\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"invalid frame detected (ignored) offset[%u]=%u, length=%u, skb=%p\n",\r\nx, offset, len, skb_in);\r\nif (!x)\r\ngoto err_ndp;\r\nbreak;\r\n} else {\r\nskb = cdc_mbim_process_dgram(dev, skb_in->data + offset, len, tci);\r\nif (!skb)\r\ngoto error;\r\nusbnet_skb_return(dev, skb);\r\n}\r\n}\r\nerr_ndp:\r\nndpoffset = le16_to_cpu(ndp16->wNextNdpIndex);\r\nif (ndpoffset && loopcount--)\r\ngoto next_ndp;\r\nreturn 1;\r\nerror:\r\nreturn 0;\r\n}\r\nstatic int cdc_mbim_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nint ret = 0;\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nstruct cdc_mbim_state *info = (void *)&dev->data;\r\nstruct cdc_ncm_ctx *ctx = info->ctx;\r\nif (ctx == NULL) {\r\nret = -1;\r\ngoto error;\r\n}\r\nret = usbnet_suspend(intf, message);\r\nif (ret < 0)\r\ngoto error;\r\nif (intf == ctx->control && info->subdriver && info->subdriver->suspend)\r\nret = info->subdriver->suspend(intf, message);\r\nif (ret < 0)\r\nusbnet_resume(intf);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int cdc_mbim_resume(struct usb_interface *intf)\r\n{\r\nint ret = 0;\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nstruct cdc_mbim_state *info = (void *)&dev->data;\r\nstruct cdc_ncm_ctx *ctx = info->ctx;\r\nbool callsub = (intf == ctx->control && info->subdriver && info->subdriver->resume);\r\nif (callsub)\r\nret = info->subdriver->resume(intf);\r\nif (ret < 0)\r\ngoto err;\r\nret = usbnet_resume(intf);\r\nif (ret < 0 && callsub && info->subdriver->suspend)\r\ninfo->subdriver->suspend(intf, PMSG_SUSPEND);\r\nerr:\r\nreturn ret;\r\n}
