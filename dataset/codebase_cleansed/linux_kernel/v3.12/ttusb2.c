static int ttusb2_msg(struct dvb_usb_device *d, u8 cmd,\r\nu8 *wbuf, int wlen, u8 *rbuf, int rlen)\r\n{\r\nstruct ttusb2_state *st = d->priv;\r\nu8 *s, *r = NULL;\r\nint ret = 0;\r\ns = kzalloc(wlen+4, GFP_KERNEL);\r\nif (!s)\r\nreturn -ENOMEM;\r\nr = kzalloc(64, GFP_KERNEL);\r\nif (!r) {\r\nkfree(s);\r\nreturn -ENOMEM;\r\n}\r\ns[0] = 0xaa;\r\ns[1] = ++st->id;\r\ns[2] = cmd;\r\ns[3] = wlen;\r\nmemcpy(&s[4],wbuf,wlen);\r\nret = dvb_usb_generic_rw(d, s, wlen+4, r, 64, 0);\r\nif (ret != 0 ||\r\nr[0] != 0x55 ||\r\nr[1] != s[1] ||\r\nr[2] != cmd ||\r\n(rlen > 0 && r[3] != rlen)) {\r\nwarn("there might have been an error during control message transfer. (rlen = %d, was %d)",rlen,r[3]);\r\nkfree(s);\r\nkfree(r);\r\nreturn -EIO;\r\n}\r\nif (rlen > 0)\r\nmemcpy(rbuf, &r[4], rlen);\r\nkfree(s);\r\nkfree(r);\r\nreturn 0;\r\n}\r\nstatic int tt3650_ci_msg(struct dvb_usb_device *d, u8 cmd, u8 *data, unsigned int write_len, unsigned int read_len)\r\n{\r\nint ret;\r\nu8 rx[60];\r\nret = ttusb2_msg(d, cmd, data, write_len, rx, read_len);\r\nif (!ret)\r\nmemcpy(data, rx, read_len);\r\nreturn ret;\r\n}\r\nstatic int tt3650_ci_msg_locked(struct dvb_ca_en50221 *ca, u8 cmd, u8 *data, unsigned int write_len, unsigned int read_len)\r\n{\r\nstruct dvb_usb_device *d = ca->data;\r\nstruct ttusb2_state *state = d->priv;\r\nint ret;\r\nmutex_lock(&state->ca_mutex);\r\nret = tt3650_ci_msg(d, cmd, data, write_len, read_len);\r\nmutex_unlock(&state->ca_mutex);\r\nreturn ret;\r\n}\r\nstatic int tt3650_ci_read_attribute_mem(struct dvb_ca_en50221 *ca, int slot, int address)\r\n{\r\nu8 buf[3];\r\nint ret = 0;\r\nif (slot)\r\nreturn -EINVAL;\r\nbuf[0] = (address >> 8) & 0x0F;\r\nbuf[1] = address;\r\nret = tt3650_ci_msg_locked(ca, TT3650_CMD_CI_RD_ATTR, buf, 2, 3);\r\nci_dbg("%04x -> %d 0x%02x", address, ret, buf[2]);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn buf[2];\r\n}\r\nstatic int tt3650_ci_write_attribute_mem(struct dvb_ca_en50221 *ca, int slot, int address, u8 value)\r\n{\r\nu8 buf[3];\r\nci_dbg("%d 0x%04x 0x%02x", slot, address, value);\r\nif (slot)\r\nreturn -EINVAL;\r\nbuf[0] = (address >> 8) & 0x0F;\r\nbuf[1] = address;\r\nbuf[2] = value;\r\nreturn tt3650_ci_msg_locked(ca, TT3650_CMD_CI_WR_ATTR, buf, 3, 3);\r\n}\r\nstatic int tt3650_ci_read_cam_control(struct dvb_ca_en50221 *ca, int slot, u8 address)\r\n{\r\nu8 buf[2];\r\nint ret;\r\nif (slot)\r\nreturn -EINVAL;\r\nbuf[0] = address & 3;\r\nret = tt3650_ci_msg_locked(ca, TT3650_CMD_CI_RD_CTRL, buf, 1, 2);\r\nci_dbg("0x%02x -> %d 0x%02x", address, ret, buf[1]);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn buf[1];\r\n}\r\nstatic int tt3650_ci_write_cam_control(struct dvb_ca_en50221 *ca, int slot, u8 address, u8 value)\r\n{\r\nu8 buf[2];\r\nci_dbg("%d 0x%02x 0x%02x", slot, address, value);\r\nif (slot)\r\nreturn -EINVAL;\r\nbuf[0] = address;\r\nbuf[1] = value;\r\nreturn tt3650_ci_msg_locked(ca, TT3650_CMD_CI_WR_CTRL, buf, 2, 2);\r\n}\r\nstatic int tt3650_ci_set_video_port(struct dvb_ca_en50221 *ca, int slot, int enable)\r\n{\r\nu8 buf[1];\r\nint ret;\r\nci_dbg("%d %d", slot, enable);\r\nif (slot)\r\nreturn -EINVAL;\r\nbuf[0] = enable;\r\nret = tt3650_ci_msg_locked(ca, TT3650_CMD_CI_SET_VIDEO_PORT, buf, 1, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nif (enable != buf[0]) {\r\nerr("CI not %sabled.", enable ? "en" : "dis");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tt3650_ci_slot_shutdown(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nreturn tt3650_ci_set_video_port(ca, slot, 0);\r\n}\r\nstatic int tt3650_ci_slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nreturn tt3650_ci_set_video_port(ca, slot, 1);\r\n}\r\nstatic int tt3650_ci_slot_reset(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nstruct dvb_usb_device *d = ca->data;\r\nstruct ttusb2_state *state = d->priv;\r\nu8 buf[1];\r\nint ret;\r\nci_dbg("%d", slot);\r\nif (slot)\r\nreturn -EINVAL;\r\nbuf[0] = 0;\r\nmutex_lock(&state->ca_mutex);\r\nret = tt3650_ci_msg(d, TT3650_CMD_CI_RESET, buf, 1, 1);\r\nif (ret)\r\ngoto failed;\r\nmsleep(500);\r\nbuf[0] = 1;\r\nret = tt3650_ci_msg(d, TT3650_CMD_CI_RESET, buf, 1, 1);\r\nif (ret)\r\ngoto failed;\r\nmsleep(500);\r\nbuf[0] = 0;\r\nret = tt3650_ci_msg(d, TT3650_CMD_CI_SET_VIDEO_PORT, buf, 1, 1);\r\nmsleep(1100);\r\nfailed:\r\nmutex_unlock(&state->ca_mutex);\r\nreturn ret;\r\n}\r\nstatic int tt3650_ci_poll_slot_status(struct dvb_ca_en50221 *ca, int slot, int open)\r\n{\r\nu8 buf[1];\r\nint ret;\r\nif (slot)\r\nreturn -EINVAL;\r\nret = tt3650_ci_msg_locked(ca, TT3650_CMD_CI_TEST, buf, 0, 1);\r\nif (ret)\r\nreturn ret;\r\nif (1 == buf[0]) {\r\nreturn DVB_CA_EN50221_POLL_CAM_PRESENT |\r\nDVB_CA_EN50221_POLL_CAM_READY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tt3650_ci_uninit(struct dvb_usb_device *d)\r\n{\r\nstruct ttusb2_state *state;\r\nci_dbg("");\r\nif (NULL == d)\r\nreturn;\r\nstate = d->priv;\r\nif (NULL == state)\r\nreturn;\r\nif (NULL == state->ca.data)\r\nreturn;\r\ndvb_ca_en50221_release(&state->ca);\r\nmemset(&state->ca, 0, sizeof(state->ca));\r\n}\r\nstatic int tt3650_ci_init(struct dvb_usb_adapter *a)\r\n{\r\nstruct dvb_usb_device *d = a->dev;\r\nstruct ttusb2_state *state = d->priv;\r\nint ret;\r\nci_dbg("");\r\nmutex_init(&state->ca_mutex);\r\nstate->ca.owner = THIS_MODULE;\r\nstate->ca.read_attribute_mem = tt3650_ci_read_attribute_mem;\r\nstate->ca.write_attribute_mem = tt3650_ci_write_attribute_mem;\r\nstate->ca.read_cam_control = tt3650_ci_read_cam_control;\r\nstate->ca.write_cam_control = tt3650_ci_write_cam_control;\r\nstate->ca.slot_reset = tt3650_ci_slot_reset;\r\nstate->ca.slot_shutdown = tt3650_ci_slot_shutdown;\r\nstate->ca.slot_ts_enable = tt3650_ci_slot_ts_enable;\r\nstate->ca.poll_slot_status = tt3650_ci_poll_slot_status;\r\nstate->ca.data = d;\r\nret = dvb_ca_en50221_init(&a->dvb_adap,\r\n&state->ca,\r\n0,\r\n1);\r\nif (ret) {\r\nerr("Cannot initialize CI: Error %d.", ret);\r\nmemset(&state->ca, 0, sizeof(state->ca));\r\nreturn ret;\r\n}\r\ninfo("CI initialized.");\r\nreturn 0;\r\n}\r\nstatic int ttusb2_i2c_xfer(struct i2c_adapter *adap,struct i2c_msg msg[],int num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstatic u8 obuf[60], ibuf[60];\r\nint i, write_read, read;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nif (num > 2)\r\nwarn("more than 2 i2c messages at a time is not handled yet. TODO.");\r\nfor (i = 0; i < num; i++) {\r\nwrite_read = i+1 < num && (msg[i+1].flags & I2C_M_RD);\r\nread = msg[i].flags & I2C_M_RD;\r\nobuf[0] = (msg[i].addr << 1) | (write_read | read);\r\nif (read)\r\nobuf[1] = 0;\r\nelse\r\nobuf[1] = msg[i].len;\r\nif (write_read)\r\nobuf[2] = msg[i+1].len;\r\nelse if (read)\r\nobuf[2] = msg[i].len;\r\nelse\r\nobuf[2] = 0;\r\nmemcpy(&obuf[3], msg[i].buf, msg[i].len);\r\nif (ttusb2_msg(d, CMD_I2C_XFER, obuf, obuf[1]+3, ibuf, obuf[2] + 3) < 0) {\r\nerr("i2c transfer failed.");\r\nbreak;\r\n}\r\nif (write_read) {\r\nmemcpy(msg[i+1].buf, &ibuf[3], msg[i+1].len);\r\ni++;\r\n} else if (read)\r\nmemcpy(msg[i].buf, &ibuf[3], msg[i].len);\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn i;\r\n}\r\nstatic u32 ttusb2_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int tt3650_rc_query(struct dvb_usb_device *d)\r\n{\r\nint ret;\r\nu8 rx[9];\r\nstruct ttusb2_state *st = d->priv;\r\nret = ttusb2_msg(d, CMD_GET_IR_CODE, NULL, 0, rx, sizeof(rx));\r\nif (ret != 0)\r\nreturn ret;\r\nif (rx[8] & 0x01) {\r\nst->last_rc_key = (rx[3] << 8) | rx[2];\r\ndeb_info("%s: cmd=0x%02x sys=0x%02x\n", __func__, rx[2], rx[3]);\r\nrc_keydown(d->rc_dev, st->last_rc_key, rx[1]);\r\n} else if (st->last_rc_key) {\r\nrc_keyup(d->rc_dev);\r\nst->last_rc_key = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ttusb2_identify_state (struct usb_device *udev, struct\r\ndvb_usb_device_properties *props, struct dvb_usb_device_description **desc,\r\nint *cold)\r\n{\r\n*cold = udev->descriptor.iManufacturer == 0 && udev->descriptor.iProduct == 0;\r\nreturn 0;\r\n}\r\nstatic int ttusb2_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nu8 b = onoff;\r\nttusb2_msg(d, CMD_POWER, &b, 0, NULL, 0);\r\nreturn ttusb2_msg(d, CMD_POWER, &b, 1, NULL, 0);\r\n}\r\nstatic int ttusb2_frontend_tda10086_attach(struct dvb_usb_adapter *adap)\r\n{\r\nif (usb_set_interface(adap->dev->udev,0,3) < 0)\r\nerr("set interface to alts=3 failed");\r\nif ((adap->fe_adap[0].fe = dvb_attach(tda10086_attach, &tda10086_config, &adap->dev->i2c_adap)) == NULL) {\r\ndeb_info("TDA10086 attach failed\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ttusb2_ct3650_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nreturn adap->fe_adap[0].fe->ops.i2c_gate_ctrl(adap->fe_adap[0].fe, enable);\r\n}\r\nstatic int ttusb2_frontend_tda10023_attach(struct dvb_usb_adapter *adap)\r\n{\r\nif (usb_set_interface(adap->dev->udev, 0, 3) < 0)\r\nerr("set interface to alts=3 failed");\r\nif (adap->fe_adap[0].fe == NULL) {\r\nadap->fe_adap[0].fe = dvb_attach(tda10023_attach,\r\n&tda10023_config, &adap->dev->i2c_adap, 0x48);\r\nif (adap->fe_adap[0].fe == NULL) {\r\ndeb_info("TDA10023 attach failed\n");\r\nreturn -ENODEV;\r\n}\r\ntt3650_ci_init(adap);\r\n} else {\r\nadap->fe_adap[1].fe = dvb_attach(tda10048_attach,\r\n&tda10048_config, &adap->dev->i2c_adap);\r\nif (adap->fe_adap[1].fe == NULL) {\r\ndeb_info("TDA10048 attach failed\n");\r\nreturn -ENODEV;\r\n}\r\nadap->fe_adap[1].fe->ops.i2c_gate_ctrl = ttusb2_ct3650_i2c_gate_ctrl;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ttusb2_tuner_tda827x_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_frontend *fe;\r\nif (adap->fe_adap[1].fe == NULL)\r\nfe = adap->fe_adap[0].fe;\r\nelse\r\nfe = adap->fe_adap[1].fe;\r\nif (dvb_attach(tda827x_attach, fe, 0x61, &adap->dev->i2c_adap, &tda827x_config) == NULL) {\r\nprintk(KERN_ERR "%s: No tda827x found!\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ttusb2_tuner_tda826x_attach(struct dvb_usb_adapter *adap)\r\n{\r\nif (dvb_attach(tda826x_attach, adap->fe_adap[0].fe, 0x60, &adap->dev->i2c_adap, 0) == NULL) {\r\ndeb_info("TDA8263 attach failed\n");\r\nreturn -ENODEV;\r\n}\r\nif (dvb_attach(lnbp21_attach, adap->fe_adap[0].fe, &adap->dev->i2c_adap, 0, 0) == NULL) {\r\ndeb_info("LNBP21 attach failed\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ttusb2_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct dvb_usb_device *d = usb_get_intfdata(intf);\r\ntt3650_ci_uninit(d);\r\ndvb_usb_device_exit(intf);\r\n}\r\nstatic int ttusb2_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nif (0 == dvb_usb_device_init(intf, &ttusb2_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &ttusb2_properties_s2400,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &ttusb2_properties_ct3650,\r\nTHIS_MODULE, NULL, adapter_nr))\r\nreturn 0;\r\nreturn -ENODEV;\r\n}
