static void efi_char16_printk(efi_char16_t *str)\r\n{\r\nstruct efi_simple_text_output_protocol *out;\r\nout = (struct efi_simple_text_output_protocol *)sys_table->con_out;\r\nefi_call_phys2(out->output_string, out, str);\r\n}\r\nstatic void efi_printk(char *str)\r\n{\r\nchar *s8;\r\nfor (s8 = str; *s8; s8++) {\r\nefi_char16_t ch[2] = { 0 };\r\nch[0] = *s8;\r\nif (*s8 == '\n') {\r\nefi_char16_t nl[2] = { '\r', 0 };\r\nefi_char16_printk(nl);\r\n}\r\nefi_char16_printk(ch);\r\n}\r\n}\r\nstatic efi_status_t __get_map(efi_memory_desc_t **map, unsigned long *map_size,\r\nunsigned long *desc_size)\r\n{\r\nefi_memory_desc_t *m = NULL;\r\nefi_status_t status;\r\nunsigned long key;\r\nu32 desc_version;\r\n*map_size = sizeof(*m) * 32;\r\nagain:\r\n*map_size += sizeof(*m);\r\nstatus = efi_call_phys3(sys_table->boottime->allocate_pool,\r\nEFI_LOADER_DATA, *map_size, (void **)&m);\r\nif (status != EFI_SUCCESS)\r\ngoto fail;\r\nstatus = efi_call_phys5(sys_table->boottime->get_memory_map, map_size,\r\nm, &key, desc_size, &desc_version);\r\nif (status == EFI_BUFFER_TOO_SMALL) {\r\nefi_call_phys1(sys_table->boottime->free_pool, m);\r\ngoto again;\r\n}\r\nif (status != EFI_SUCCESS)\r\nefi_call_phys1(sys_table->boottime->free_pool, m);\r\nfail:\r\n*map = m;\r\nreturn status;\r\n}\r\nstatic efi_status_t high_alloc(unsigned long size, unsigned long align,\r\nunsigned long *addr, unsigned long max)\r\n{\r\nunsigned long map_size, desc_size;\r\nefi_memory_desc_t *map;\r\nefi_status_t status;\r\nunsigned long nr_pages;\r\nu64 max_addr = 0;\r\nint i;\r\nstatus = __get_map(&map, &map_size, &desc_size);\r\nif (status != EFI_SUCCESS)\r\ngoto fail;\r\nnr_pages = round_up(size, EFI_PAGE_SIZE) / EFI_PAGE_SIZE;\r\nagain:\r\nfor (i = 0; i < map_size / desc_size; i++) {\r\nefi_memory_desc_t *desc;\r\nunsigned long m = (unsigned long)map;\r\nu64 start, end;\r\ndesc = (efi_memory_desc_t *)(m + (i * desc_size));\r\nif (desc->type != EFI_CONVENTIONAL_MEMORY)\r\ncontinue;\r\nif (desc->num_pages < nr_pages)\r\ncontinue;\r\nstart = desc->phys_addr;\r\nend = start + desc->num_pages * (1UL << EFI_PAGE_SHIFT);\r\nif ((start + size) > end || (start + size) > max)\r\ncontinue;\r\nif (end - size > max)\r\nend = max;\r\nif (round_down(end - size, align) < start)\r\ncontinue;\r\nstart = round_down(end - size, align);\r\nif (start == 0x0)\r\ncontinue;\r\nif (start > max_addr)\r\nmax_addr = start;\r\n}\r\nif (!max_addr)\r\nstatus = EFI_NOT_FOUND;\r\nelse {\r\nstatus = efi_call_phys4(sys_table->boottime->allocate_pages,\r\nEFI_ALLOCATE_ADDRESS, EFI_LOADER_DATA,\r\nnr_pages, &max_addr);\r\nif (status != EFI_SUCCESS) {\r\nmax = max_addr;\r\nmax_addr = 0;\r\ngoto again;\r\n}\r\n*addr = max_addr;\r\n}\r\nfree_pool:\r\nefi_call_phys1(sys_table->boottime->free_pool, map);\r\nfail:\r\nreturn status;\r\n}\r\nstatic efi_status_t low_alloc(unsigned long size, unsigned long align,\r\nunsigned long *addr)\r\n{\r\nunsigned long map_size, desc_size;\r\nefi_memory_desc_t *map;\r\nefi_status_t status;\r\nunsigned long nr_pages;\r\nint i;\r\nstatus = __get_map(&map, &map_size, &desc_size);\r\nif (status != EFI_SUCCESS)\r\ngoto fail;\r\nnr_pages = round_up(size, EFI_PAGE_SIZE) / EFI_PAGE_SIZE;\r\nfor (i = 0; i < map_size / desc_size; i++) {\r\nefi_memory_desc_t *desc;\r\nunsigned long m = (unsigned long)map;\r\nu64 start, end;\r\ndesc = (efi_memory_desc_t *)(m + (i * desc_size));\r\nif (desc->type != EFI_CONVENTIONAL_MEMORY)\r\ncontinue;\r\nif (desc->num_pages < nr_pages)\r\ncontinue;\r\nstart = desc->phys_addr;\r\nend = start + desc->num_pages * (1UL << EFI_PAGE_SHIFT);\r\nif (start == 0x0)\r\nstart += 8;\r\nstart = round_up(start, align);\r\nif ((start + size) > end)\r\ncontinue;\r\nstatus = efi_call_phys4(sys_table->boottime->allocate_pages,\r\nEFI_ALLOCATE_ADDRESS, EFI_LOADER_DATA,\r\nnr_pages, &start);\r\nif (status == EFI_SUCCESS) {\r\n*addr = start;\r\nbreak;\r\n}\r\n}\r\nif (i == map_size / desc_size)\r\nstatus = EFI_NOT_FOUND;\r\nfree_pool:\r\nefi_call_phys1(sys_table->boottime->free_pool, map);\r\nfail:\r\nreturn status;\r\n}\r\nstatic void low_free(unsigned long size, unsigned long addr)\r\n{\r\nunsigned long nr_pages;\r\nnr_pages = round_up(size, EFI_PAGE_SIZE) / EFI_PAGE_SIZE;\r\nefi_call_phys2(sys_table->boottime->free_pages, addr, nr_pages);\r\n}\r\nstatic void find_bits(unsigned long mask, u8 *pos, u8 *size)\r\n{\r\nu8 first, len;\r\nfirst = 0;\r\nlen = 0;\r\nif (mask) {\r\nwhile (!(mask & 0x1)) {\r\nmask = mask >> 1;\r\nfirst++;\r\n}\r\nwhile (mask & 0x1) {\r\nmask = mask >> 1;\r\nlen++;\r\n}\r\n}\r\n*pos = first;\r\n*size = len;\r\n}\r\nstatic efi_status_t setup_efi_pci(struct boot_params *params)\r\n{\r\nefi_pci_io_protocol *pci;\r\nefi_status_t status;\r\nvoid **pci_handle;\r\nefi_guid_t pci_proto = EFI_PCI_IO_PROTOCOL_GUID;\r\nunsigned long nr_pci, size = 0;\r\nint i;\r\nstruct setup_data *data;\r\ndata = (struct setup_data *)(unsigned long)params->hdr.setup_data;\r\nwhile (data && data->next)\r\ndata = (struct setup_data *)(unsigned long)data->next;\r\nstatus = efi_call_phys5(sys_table->boottime->locate_handle,\r\nEFI_LOCATE_BY_PROTOCOL, &pci_proto,\r\nNULL, &size, pci_handle);\r\nif (status == EFI_BUFFER_TOO_SMALL) {\r\nstatus = efi_call_phys3(sys_table->boottime->allocate_pool,\r\nEFI_LOADER_DATA, size, &pci_handle);\r\nif (status != EFI_SUCCESS)\r\nreturn status;\r\nstatus = efi_call_phys5(sys_table->boottime->locate_handle,\r\nEFI_LOCATE_BY_PROTOCOL, &pci_proto,\r\nNULL, &size, pci_handle);\r\n}\r\nif (status != EFI_SUCCESS)\r\ngoto free_handle;\r\nnr_pci = size / sizeof(void *);\r\nfor (i = 0; i < nr_pci; i++) {\r\nvoid *h = pci_handle[i];\r\nuint64_t attributes;\r\nstruct pci_setup_rom *rom;\r\nstatus = efi_call_phys3(sys_table->boottime->handle_protocol,\r\nh, &pci_proto, &pci);\r\nif (status != EFI_SUCCESS)\r\ncontinue;\r\nif (!pci)\r\ncontinue;\r\n#ifdef CONFIG_X86_64\r\nstatus = efi_call_phys4(pci->attributes, pci,\r\nEfiPciIoAttributeOperationGet, 0,\r\n&attributes);\r\n#else\r\nstatus = efi_call_phys5(pci->attributes, pci,\r\nEfiPciIoAttributeOperationGet, 0, 0,\r\n&attributes);\r\n#endif\r\nif (status != EFI_SUCCESS)\r\ncontinue;\r\nif (!pci->romimage || !pci->romsize)\r\ncontinue;\r\nsize = pci->romsize + sizeof(*rom);\r\nstatus = efi_call_phys3(sys_table->boottime->allocate_pool,\r\nEFI_LOADER_DATA, size, &rom);\r\nif (status != EFI_SUCCESS)\r\ncontinue;\r\nrom->data.type = SETUP_PCI;\r\nrom->data.len = size - sizeof(struct setup_data);\r\nrom->data.next = 0;\r\nrom->pcilen = pci->romsize;\r\nstatus = efi_call_phys5(pci->pci.read, pci,\r\nEfiPciIoWidthUint16, PCI_VENDOR_ID,\r\n1, &(rom->vendor));\r\nif (status != EFI_SUCCESS)\r\ngoto free_struct;\r\nstatus = efi_call_phys5(pci->pci.read, pci,\r\nEfiPciIoWidthUint16, PCI_DEVICE_ID,\r\n1, &(rom->devid));\r\nif (status != EFI_SUCCESS)\r\ngoto free_struct;\r\nstatus = efi_call_phys5(pci->get_location, pci,\r\n&(rom->segment), &(rom->bus),\r\n&(rom->device), &(rom->function));\r\nif (status != EFI_SUCCESS)\r\ngoto free_struct;\r\nmemcpy(rom->romdata, pci->romimage, pci->romsize);\r\nif (data)\r\ndata->next = (unsigned long)rom;\r\nelse\r\nparams->hdr.setup_data = (unsigned long)rom;\r\ndata = (struct setup_data *)rom;\r\ncontinue;\r\nfree_struct:\r\nefi_call_phys1(sys_table->boottime->free_pool, rom);\r\n}\r\nfree_handle:\r\nefi_call_phys1(sys_table->boottime->free_pool, pci_handle);\r\nreturn status;\r\n}\r\nstatic efi_status_t setup_gop(struct screen_info *si, efi_guid_t *proto,\r\nunsigned long size)\r\n{\r\nstruct efi_graphics_output_protocol *gop, *first_gop;\r\nstruct efi_pixel_bitmask pixel_info;\r\nunsigned long nr_gops;\r\nefi_status_t status;\r\nvoid **gop_handle;\r\nu16 width, height;\r\nu32 fb_base, fb_size;\r\nu32 pixels_per_scan_line;\r\nint pixel_format;\r\nint i;\r\nstatus = efi_call_phys3(sys_table->boottime->allocate_pool,\r\nEFI_LOADER_DATA, size, &gop_handle);\r\nif (status != EFI_SUCCESS)\r\nreturn status;\r\nstatus = efi_call_phys5(sys_table->boottime->locate_handle,\r\nEFI_LOCATE_BY_PROTOCOL, proto,\r\nNULL, &size, gop_handle);\r\nif (status != EFI_SUCCESS)\r\ngoto free_handle;\r\nfirst_gop = NULL;\r\nnr_gops = size / sizeof(void *);\r\nfor (i = 0; i < nr_gops; i++) {\r\nstruct efi_graphics_output_mode_info *info;\r\nefi_guid_t conout_proto = EFI_CONSOLE_OUT_DEVICE_GUID;\r\nbool conout_found = false;\r\nvoid *dummy;\r\nvoid *h = gop_handle[i];\r\nstatus = efi_call_phys3(sys_table->boottime->handle_protocol,\r\nh, proto, &gop);\r\nif (status != EFI_SUCCESS)\r\ncontinue;\r\nstatus = efi_call_phys3(sys_table->boottime->handle_protocol,\r\nh, &conout_proto, &dummy);\r\nif (status == EFI_SUCCESS)\r\nconout_found = true;\r\nstatus = efi_call_phys4(gop->query_mode, gop,\r\ngop->mode->mode, &size, &info);\r\nif (status == EFI_SUCCESS && (!first_gop || conout_found)) {\r\nwidth = info->horizontal_resolution;\r\nheight = info->vertical_resolution;\r\nfb_base = gop->mode->frame_buffer_base;\r\nfb_size = gop->mode->frame_buffer_size;\r\npixel_format = info->pixel_format;\r\npixel_info = info->pixel_information;\r\npixels_per_scan_line = info->pixels_per_scan_line;\r\nfirst_gop = gop;\r\nif (conout_found)\r\nbreak;\r\n}\r\n}\r\nif (!first_gop)\r\ngoto free_handle;\r\nsi->orig_video_isVGA = VIDEO_TYPE_EFI;\r\nsi->lfb_width = width;\r\nsi->lfb_height = height;\r\nsi->lfb_base = fb_base;\r\nsi->pages = 1;\r\nif (pixel_format == PIXEL_RGB_RESERVED_8BIT_PER_COLOR) {\r\nsi->lfb_depth = 32;\r\nsi->lfb_linelength = pixels_per_scan_line * 4;\r\nsi->red_size = 8;\r\nsi->red_pos = 0;\r\nsi->green_size = 8;\r\nsi->green_pos = 8;\r\nsi->blue_size = 8;\r\nsi->blue_pos = 16;\r\nsi->rsvd_size = 8;\r\nsi->rsvd_pos = 24;\r\n} else if (pixel_format == PIXEL_BGR_RESERVED_8BIT_PER_COLOR) {\r\nsi->lfb_depth = 32;\r\nsi->lfb_linelength = pixels_per_scan_line * 4;\r\nsi->red_size = 8;\r\nsi->red_pos = 16;\r\nsi->green_size = 8;\r\nsi->green_pos = 8;\r\nsi->blue_size = 8;\r\nsi->blue_pos = 0;\r\nsi->rsvd_size = 8;\r\nsi->rsvd_pos = 24;\r\n} else if (pixel_format == PIXEL_BIT_MASK) {\r\nfind_bits(pixel_info.red_mask, &si->red_pos, &si->red_size);\r\nfind_bits(pixel_info.green_mask, &si->green_pos,\r\n&si->green_size);\r\nfind_bits(pixel_info.blue_mask, &si->blue_pos, &si->blue_size);\r\nfind_bits(pixel_info.reserved_mask, &si->rsvd_pos,\r\n&si->rsvd_size);\r\nsi->lfb_depth = si->red_size + si->green_size +\r\nsi->blue_size + si->rsvd_size;\r\nsi->lfb_linelength = (pixels_per_scan_line * si->lfb_depth) / 8;\r\n} else {\r\nsi->lfb_depth = 4;\r\nsi->lfb_linelength = si->lfb_width / 2;\r\nsi->red_size = 0;\r\nsi->red_pos = 0;\r\nsi->green_size = 0;\r\nsi->green_pos = 0;\r\nsi->blue_size = 0;\r\nsi->blue_pos = 0;\r\nsi->rsvd_size = 0;\r\nsi->rsvd_pos = 0;\r\n}\r\nsi->lfb_size = si->lfb_linelength * si->lfb_height;\r\nsi->capabilities |= VIDEO_CAPABILITY_SKIP_QUIRKS;\r\nfree_handle:\r\nefi_call_phys1(sys_table->boottime->free_pool, gop_handle);\r\nreturn status;\r\n}\r\nstatic efi_status_t setup_uga(struct screen_info *si, efi_guid_t *uga_proto,\r\nunsigned long size)\r\n{\r\nstruct efi_uga_draw_protocol *uga, *first_uga;\r\nunsigned long nr_ugas;\r\nefi_status_t status;\r\nu32 width, height;\r\nvoid **uga_handle = NULL;\r\nint i;\r\nstatus = efi_call_phys3(sys_table->boottime->allocate_pool,\r\nEFI_LOADER_DATA, size, &uga_handle);\r\nif (status != EFI_SUCCESS)\r\nreturn status;\r\nstatus = efi_call_phys5(sys_table->boottime->locate_handle,\r\nEFI_LOCATE_BY_PROTOCOL, uga_proto,\r\nNULL, &size, uga_handle);\r\nif (status != EFI_SUCCESS)\r\ngoto free_handle;\r\nfirst_uga = NULL;\r\nnr_ugas = size / sizeof(void *);\r\nfor (i = 0; i < nr_ugas; i++) {\r\nefi_guid_t pciio_proto = EFI_PCI_IO_PROTOCOL_GUID;\r\nvoid *handle = uga_handle[i];\r\nu32 w, h, depth, refresh;\r\nvoid *pciio;\r\nstatus = efi_call_phys3(sys_table->boottime->handle_protocol,\r\nhandle, uga_proto, &uga);\r\nif (status != EFI_SUCCESS)\r\ncontinue;\r\nefi_call_phys3(sys_table->boottime->handle_protocol,\r\nhandle, &pciio_proto, &pciio);\r\nstatus = efi_call_phys5(uga->get_mode, uga, &w, &h,\r\n&depth, &refresh);\r\nif (status == EFI_SUCCESS && (!first_uga || pciio)) {\r\nwidth = w;\r\nheight = h;\r\nif (pciio)\r\nbreak;\r\nfirst_uga = uga;\r\n}\r\n}\r\nif (!first_uga)\r\ngoto free_handle;\r\nsi->orig_video_isVGA = VIDEO_TYPE_EFI;\r\nsi->lfb_depth = 32;\r\nsi->lfb_width = width;\r\nsi->lfb_height = height;\r\nsi->red_size = 8;\r\nsi->red_pos = 16;\r\nsi->green_size = 8;\r\nsi->green_pos = 8;\r\nsi->blue_size = 8;\r\nsi->blue_pos = 0;\r\nsi->rsvd_size = 8;\r\nsi->rsvd_pos = 24;\r\nfree_handle:\r\nefi_call_phys1(sys_table->boottime->free_pool, uga_handle);\r\nreturn status;\r\n}\r\nvoid setup_graphics(struct boot_params *boot_params)\r\n{\r\nefi_guid_t graphics_proto = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;\r\nstruct screen_info *si;\r\nefi_guid_t uga_proto = EFI_UGA_PROTOCOL_GUID;\r\nefi_status_t status;\r\nunsigned long size;\r\nvoid **gop_handle = NULL;\r\nvoid **uga_handle = NULL;\r\nsi = &boot_params->screen_info;\r\nmemset(si, 0, sizeof(*si));\r\nsize = 0;\r\nstatus = efi_call_phys5(sys_table->boottime->locate_handle,\r\nEFI_LOCATE_BY_PROTOCOL, &graphics_proto,\r\nNULL, &size, gop_handle);\r\nif (status == EFI_BUFFER_TOO_SMALL)\r\nstatus = setup_gop(si, &graphics_proto, size);\r\nif (status != EFI_SUCCESS) {\r\nsize = 0;\r\nstatus = efi_call_phys5(sys_table->boottime->locate_handle,\r\nEFI_LOCATE_BY_PROTOCOL, &uga_proto,\r\nNULL, &size, uga_handle);\r\nif (status == EFI_BUFFER_TOO_SMALL)\r\nsetup_uga(si, &uga_proto, size);\r\n}\r\n}\r\nstatic efi_status_t handle_ramdisks(efi_loaded_image_t *image,\r\nstruct setup_header *hdr)\r\n{\r\nstruct initrd *initrds;\r\nunsigned long initrd_addr;\r\nefi_guid_t fs_proto = EFI_FILE_SYSTEM_GUID;\r\nu64 initrd_total;\r\nefi_file_io_interface_t *io;\r\nefi_file_handle_t *fh;\r\nefi_status_t status;\r\nint nr_initrds;\r\nchar *str;\r\nint i, j, k;\r\ninitrd_addr = 0;\r\ninitrd_total = 0;\r\nstr = (char *)(unsigned long)hdr->cmd_line_ptr;\r\nj = 0;\r\nif (!str || !*str)\r\nreturn EFI_SUCCESS;\r\nfor (nr_initrds = 0; *str; nr_initrds++) {\r\nstr = strstr(str, "initrd=");\r\nif (!str)\r\nbreak;\r\nstr += 7;\r\nwhile (*str == '/' || *str == '\\')\r\nstr++;\r\nwhile (*str && *str != ' ' && *str != '\n')\r\nstr++;\r\n}\r\nif (!nr_initrds)\r\nreturn EFI_SUCCESS;\r\nstatus = efi_call_phys3(sys_table->boottime->allocate_pool,\r\nEFI_LOADER_DATA,\r\nnr_initrds * sizeof(*initrds),\r\n&initrds);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk("Failed to alloc mem for initrds\n");\r\ngoto fail;\r\n}\r\nstr = (char *)(unsigned long)hdr->cmd_line_ptr;\r\nfor (i = 0; i < nr_initrds; i++) {\r\nstruct initrd *initrd;\r\nefi_file_handle_t *h;\r\nefi_file_info_t *info;\r\nefi_char16_t filename_16[256];\r\nunsigned long info_sz;\r\nefi_guid_t info_guid = EFI_FILE_INFO_ID;\r\nefi_char16_t *p;\r\nu64 file_sz;\r\nstr = strstr(str, "initrd=");\r\nif (!str)\r\nbreak;\r\nstr += 7;\r\ninitrd = &initrds[i];\r\np = filename_16;\r\nwhile (*str == '/' || *str == '\\')\r\nstr++;\r\nwhile (*str && *str != ' ' && *str != '\n') {\r\nif ((u8 *)p >= (u8 *)filename_16 + sizeof(filename_16))\r\nbreak;\r\nif (*str == '/') {\r\n*p++ = '\\';\r\n*str++;\r\n} else {\r\n*p++ = *str++;\r\n}\r\n}\r\n*p = '\0';\r\nif (!i) {\r\nefi_boot_services_t *boottime;\r\nboottime = sys_table->boottime;\r\nstatus = efi_call_phys3(boottime->handle_protocol,\r\nimage->device_handle, &fs_proto, &io);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk("Failed to handle fs_proto\n");\r\ngoto free_initrds;\r\n}\r\nstatus = efi_call_phys2(io->open_volume, io, &fh);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk("Failed to open volume\n");\r\ngoto free_initrds;\r\n}\r\n}\r\nstatus = efi_call_phys5(fh->open, fh, &h, filename_16,\r\nEFI_FILE_MODE_READ, (u64)0);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk("Failed to open initrd file: ");\r\nefi_char16_printk(filename_16);\r\nefi_printk("\n");\r\ngoto close_handles;\r\n}\r\ninitrd->handle = h;\r\ninfo_sz = 0;\r\nstatus = efi_call_phys4(h->get_info, h, &info_guid,\r\n&info_sz, NULL);\r\nif (status != EFI_BUFFER_TOO_SMALL) {\r\nefi_printk("Failed to get initrd info size\n");\r\ngoto close_handles;\r\n}\r\ngrow:\r\nstatus = efi_call_phys3(sys_table->boottime->allocate_pool,\r\nEFI_LOADER_DATA, info_sz, &info);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk("Failed to alloc mem for initrd info\n");\r\ngoto close_handles;\r\n}\r\nstatus = efi_call_phys4(h->get_info, h, &info_guid,\r\n&info_sz, info);\r\nif (status == EFI_BUFFER_TOO_SMALL) {\r\nefi_call_phys1(sys_table->boottime->free_pool, info);\r\ngoto grow;\r\n}\r\nfile_sz = info->file_size;\r\nefi_call_phys1(sys_table->boottime->free_pool, info);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk("Failed to get initrd info\n");\r\ngoto close_handles;\r\n}\r\ninitrd->size = file_sz;\r\ninitrd_total += file_sz;\r\n}\r\nif (initrd_total) {\r\nunsigned long addr;\r\nstatus = high_alloc(initrd_total, 0x1000,\r\n&initrd_addr, hdr->initrd_addr_max);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk("Failed to alloc highmem for initrds\n");\r\ngoto close_handles;\r\n}\r\nif (initrd_addr > hdr->initrd_addr_max) {\r\nefi_printk("We've run out of free low memory\n");\r\nstatus = EFI_INVALID_PARAMETER;\r\ngoto free_initrd_total;\r\n}\r\naddr = initrd_addr;\r\nfor (j = 0; j < nr_initrds; j++) {\r\nu64 size;\r\nsize = initrds[j].size;\r\nwhile (size) {\r\nu64 chunksize;\r\nif (size > EFI_READ_CHUNK_SIZE)\r\nchunksize = EFI_READ_CHUNK_SIZE;\r\nelse\r\nchunksize = size;\r\nstatus = efi_call_phys3(fh->read,\r\ninitrds[j].handle,\r\n&chunksize, addr);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk("Failed to read initrd\n");\r\ngoto free_initrd_total;\r\n}\r\naddr += chunksize;\r\nsize -= chunksize;\r\n}\r\nefi_call_phys1(fh->close, initrds[j].handle);\r\n}\r\n}\r\nefi_call_phys1(sys_table->boottime->free_pool, initrds);\r\nhdr->ramdisk_image = initrd_addr;\r\nhdr->ramdisk_size = initrd_total;\r\nreturn status;\r\nfree_initrd_total:\r\nlow_free(initrd_total, initrd_addr);\r\nclose_handles:\r\nfor (k = j; k < i; k++)\r\nefi_call_phys1(fh->close, initrds[k].handle);\r\nfree_initrds:\r\nefi_call_phys1(sys_table->boottime->free_pool, initrds);\r\nfail:\r\nhdr->ramdisk_image = 0;\r\nhdr->ramdisk_size = 0;\r\nreturn status;\r\n}\r\nstruct boot_params *make_boot_params(void *handle, efi_system_table_t *_table)\r\n{\r\nstruct boot_params *boot_params;\r\nstruct sys_desc_table *sdt;\r\nstruct apm_bios_info *bi;\r\nstruct setup_header *hdr;\r\nstruct efi_info *efi;\r\nefi_loaded_image_t *image;\r\nvoid *options;\r\nu32 load_options_size;\r\nefi_guid_t proto = LOADED_IMAGE_PROTOCOL_GUID;\r\nint options_size = 0;\r\nefi_status_t status;\r\nunsigned long cmdline;\r\nu16 *s2;\r\nu8 *s1;\r\nint i;\r\nsys_table = _table;\r\nif (sys_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)\r\nreturn NULL;\r\nstatus = efi_call_phys3(sys_table->boottime->handle_protocol,\r\nhandle, &proto, (void *)&image);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk("Failed to get handle for LOADED_IMAGE_PROTOCOL\n");\r\nreturn NULL;\r\n}\r\nstatus = low_alloc(0x4000, 1, (unsigned long *)&boot_params);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk("Failed to alloc lowmem for boot params\n");\r\nreturn NULL;\r\n}\r\nmemset(boot_params, 0x0, 0x4000);\r\nhdr = &boot_params->hdr;\r\nefi = &boot_params->efi_info;\r\nbi = &boot_params->apm_bios_info;\r\nsdt = &boot_params->sys_desc_table;\r\nmemcpy(&hdr->jump, image->image_base + 512, 512);\r\nhdr->root_flags = 1;\r\nhdr->vid_mode = 0xffff;\r\nhdr->boot_flag = 0xAA55;\r\nhdr->code32_start = (__u64)(unsigned long)image->image_base;\r\nhdr->type_of_loader = 0x21;\r\noptions = image->load_options;\r\nload_options_size = image->load_options_size / 2;\r\ncmdline = 0;\r\ns2 = (u16 *)options;\r\nif (s2) {\r\nwhile (*s2 && *s2 != '\n' && options_size < load_options_size) {\r\ns2++;\r\noptions_size++;\r\n}\r\nif (options_size) {\r\nif (options_size > hdr->cmdline_size)\r\noptions_size = hdr->cmdline_size;\r\noptions_size++;\r\nstatus = low_alloc(options_size, 1, &cmdline);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk("Failed to alloc mem for cmdline\n");\r\ngoto fail;\r\n}\r\ns1 = (u8 *)(unsigned long)cmdline;\r\ns2 = (u16 *)options;\r\nfor (i = 0; i < options_size - 1; i++)\r\n*s1++ = *s2++;\r\n*s1 = '\0';\r\n}\r\n}\r\nhdr->cmd_line_ptr = cmdline;\r\nhdr->ramdisk_image = 0;\r\nhdr->ramdisk_size = 0;\r\nmemset(bi, 0, sizeof(*bi));\r\nmemset(sdt, 0, sizeof(*sdt));\r\nstatus = handle_ramdisks(image, hdr);\r\nif (status != EFI_SUCCESS)\r\ngoto fail2;\r\nreturn boot_params;\r\nfail2:\r\nif (options_size)\r\nlow_free(options_size, hdr->cmd_line_ptr);\r\nfail:\r\nlow_free(0x4000, (unsigned long)boot_params);\r\nreturn NULL;\r\n}\r\nstatic efi_status_t exit_boot(struct boot_params *boot_params,\r\nvoid *handle)\r\n{\r\nstruct efi_info *efi = &boot_params->efi_info;\r\nstruct e820entry *e820_map = &boot_params->e820_map[0];\r\nstruct e820entry *prev = NULL;\r\nunsigned long size, key, desc_size, _size;\r\nefi_memory_desc_t *mem_map;\r\nefi_status_t status;\r\n__u32 desc_version;\r\nbool called_exit = false;\r\nu8 nr_entries;\r\nint i;\r\nsize = sizeof(*mem_map) * 32;\r\nagain:\r\nsize += sizeof(*mem_map) * 2;\r\n_size = size;\r\nstatus = low_alloc(size, 1, (unsigned long *)&mem_map);\r\nif (status != EFI_SUCCESS)\r\nreturn status;\r\nget_map:\r\nstatus = efi_call_phys5(sys_table->boottime->get_memory_map, &size,\r\nmem_map, &key, &desc_size, &desc_version);\r\nif (status == EFI_BUFFER_TOO_SMALL) {\r\nlow_free(_size, (unsigned long)mem_map);\r\ngoto again;\r\n}\r\nif (status != EFI_SUCCESS)\r\ngoto free_mem_map;\r\nmemcpy(&efi->efi_loader_signature, EFI_LOADER_SIGNATURE, sizeof(__u32));\r\nefi->efi_systab = (unsigned long)sys_table;\r\nefi->efi_memdesc_size = desc_size;\r\nefi->efi_memdesc_version = desc_version;\r\nefi->efi_memmap = (unsigned long)mem_map;\r\nefi->efi_memmap_size = size;\r\n#ifdef CONFIG_X86_64\r\nefi->efi_systab_hi = (unsigned long)sys_table >> 32;\r\nefi->efi_memmap_hi = (unsigned long)mem_map >> 32;\r\n#endif\r\nstatus = efi_call_phys2(sys_table->boottime->exit_boot_services,\r\nhandle, key);\r\nif (status != EFI_SUCCESS) {\r\nif (called_exit)\r\ngoto free_mem_map;\r\ncalled_exit = true;\r\ngoto get_map;\r\n}\r\nboot_params->alt_mem_k = 32 * 1024;\r\nnr_entries = 0;\r\nfor (i = 0; i < size / desc_size; i++) {\r\nefi_memory_desc_t *d;\r\nunsigned int e820_type = 0;\r\nunsigned long m = (unsigned long)mem_map;\r\nd = (efi_memory_desc_t *)(m + (i * desc_size));\r\nswitch (d->type) {\r\ncase EFI_RESERVED_TYPE:\r\ncase EFI_RUNTIME_SERVICES_CODE:\r\ncase EFI_RUNTIME_SERVICES_DATA:\r\ncase EFI_MEMORY_MAPPED_IO:\r\ncase EFI_MEMORY_MAPPED_IO_PORT_SPACE:\r\ncase EFI_PAL_CODE:\r\ne820_type = E820_RESERVED;\r\nbreak;\r\ncase EFI_UNUSABLE_MEMORY:\r\ne820_type = E820_UNUSABLE;\r\nbreak;\r\ncase EFI_ACPI_RECLAIM_MEMORY:\r\ne820_type = E820_ACPI;\r\nbreak;\r\ncase EFI_LOADER_CODE:\r\ncase EFI_LOADER_DATA:\r\ncase EFI_BOOT_SERVICES_CODE:\r\ncase EFI_BOOT_SERVICES_DATA:\r\ncase EFI_CONVENTIONAL_MEMORY:\r\ne820_type = E820_RAM;\r\nbreak;\r\ncase EFI_ACPI_MEMORY_NVS:\r\ne820_type = E820_NVS;\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nif (prev && prev->type == e820_type &&\r\n(prev->addr + prev->size) == d->phys_addr)\r\nprev->size += d->num_pages << 12;\r\nelse {\r\ne820_map->addr = d->phys_addr;\r\ne820_map->size = d->num_pages << 12;\r\ne820_map->type = e820_type;\r\nprev = e820_map++;\r\nnr_entries++;\r\n}\r\n}\r\nboot_params->e820_entries = nr_entries;\r\nreturn EFI_SUCCESS;\r\nfree_mem_map:\r\nlow_free(_size, (unsigned long)mem_map);\r\nreturn status;\r\n}\r\nstatic efi_status_t relocate_kernel(struct setup_header *hdr)\r\n{\r\nunsigned long start, nr_pages;\r\nefi_status_t status;\r\nstart = hdr->pref_address;\r\nnr_pages = round_up(hdr->init_size, EFI_PAGE_SIZE) / EFI_PAGE_SIZE;\r\nstatus = efi_call_phys4(sys_table->boottime->allocate_pages,\r\nEFI_ALLOCATE_ADDRESS, EFI_LOADER_DATA,\r\nnr_pages, &start);\r\nif (status != EFI_SUCCESS) {\r\nstatus = low_alloc(hdr->init_size, hdr->kernel_alignment,\r\n&start);\r\nif (status != EFI_SUCCESS)\r\nefi_printk("Failed to alloc mem for kernel\n");\r\n}\r\nif (status == EFI_SUCCESS)\r\nmemcpy((void *)start, (void *)(unsigned long)hdr->code32_start,\r\nhdr->init_size);\r\nhdr->pref_address = hdr->code32_start;\r\nhdr->code32_start = (__u32)start;\r\nreturn status;\r\n}\r\nstruct boot_params *efi_main(void *handle, efi_system_table_t *_table,\r\nstruct boot_params *boot_params)\r\n{\r\nstruct desc_ptr *gdt, *idt;\r\nefi_loaded_image_t *image;\r\nstruct setup_header *hdr = &boot_params->hdr;\r\nefi_status_t status;\r\nstruct desc_struct *desc;\r\nsys_table = _table;\r\nif (sys_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)\r\ngoto fail;\r\nsetup_graphics(boot_params);\r\nsetup_efi_pci(boot_params);\r\nstatus = efi_call_phys3(sys_table->boottime->allocate_pool,\r\nEFI_LOADER_DATA, sizeof(*gdt),\r\n(void **)&gdt);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk("Failed to alloc mem for gdt structure\n");\r\ngoto fail;\r\n}\r\ngdt->size = 0x800;\r\nstatus = low_alloc(gdt->size, 8, (unsigned long *)&gdt->address);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk("Failed to alloc mem for gdt\n");\r\ngoto fail;\r\n}\r\nstatus = efi_call_phys3(sys_table->boottime->allocate_pool,\r\nEFI_LOADER_DATA, sizeof(*idt),\r\n(void **)&idt);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk("Failed to alloc mem for idt structure\n");\r\ngoto fail;\r\n}\r\nidt->size = 0;\r\nidt->address = 0;\r\nif (hdr->pref_address != hdr->code32_start) {\r\nstatus = relocate_kernel(hdr);\r\nif (status != EFI_SUCCESS)\r\ngoto fail;\r\n}\r\nstatus = exit_boot(boot_params, handle);\r\nif (status != EFI_SUCCESS)\r\ngoto fail;\r\nmemset((char *)gdt->address, 0x0, gdt->size);\r\ndesc = (struct desc_struct *)gdt->address;\r\ndesc += 2;\r\ndesc->limit0 = 0xffff;\r\ndesc->base0 = 0x0000;\r\ndesc->base1 = 0x0000;\r\ndesc->type = SEG_TYPE_CODE | SEG_TYPE_EXEC_READ;\r\ndesc->s = DESC_TYPE_CODE_DATA;\r\ndesc->dpl = 0;\r\ndesc->p = 1;\r\ndesc->limit = 0xf;\r\ndesc->avl = 0;\r\ndesc->l = 0;\r\ndesc->d = SEG_OP_SIZE_32BIT;\r\ndesc->g = SEG_GRANULARITY_4KB;\r\ndesc->base2 = 0x00;\r\ndesc++;\r\ndesc->limit0 = 0xffff;\r\ndesc->base0 = 0x0000;\r\ndesc->base1 = 0x0000;\r\ndesc->type = SEG_TYPE_DATA | SEG_TYPE_READ_WRITE;\r\ndesc->s = DESC_TYPE_CODE_DATA;\r\ndesc->dpl = 0;\r\ndesc->p = 1;\r\ndesc->limit = 0xf;\r\ndesc->avl = 0;\r\ndesc->l = 0;\r\ndesc->d = SEG_OP_SIZE_32BIT;\r\ndesc->g = SEG_GRANULARITY_4KB;\r\ndesc->base2 = 0x00;\r\n#ifdef CONFIG_X86_64\r\ndesc++;\r\ndesc->limit0 = 0x0000;\r\ndesc->base0 = 0x0000;\r\ndesc->base1 = 0x0000;\r\ndesc->type = SEG_TYPE_TSS;\r\ndesc->s = 0;\r\ndesc->dpl = 0;\r\ndesc->p = 1;\r\ndesc->limit = 0x0;\r\ndesc->avl = 0;\r\ndesc->l = 0;\r\ndesc->d = 0;\r\ndesc->g = SEG_GRANULARITY_4KB;\r\ndesc->base2 = 0x00;\r\n#endif\r\nasm volatile ("lidt %0" : : "m" (*idt));\r\nasm volatile ("lgdt %0" : : "m" (*gdt));\r\nasm volatile("cli");\r\nreturn boot_params;\r\nfail:\r\nreturn NULL;\r\n}
