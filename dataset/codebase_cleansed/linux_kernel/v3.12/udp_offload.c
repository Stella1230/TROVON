static int udp4_ufo_send_check(struct sk_buff *skb)\r\n{\r\nif (!pskb_may_pull(skb, sizeof(struct udphdr)))\r\nreturn -EINVAL;\r\nif (likely(!skb->encapsulation)) {\r\nconst struct iphdr *iph;\r\nstruct udphdr *uh;\r\niph = ip_hdr(skb);\r\nuh = udp_hdr(skb);\r\nuh->check = ~csum_tcpudp_magic(iph->saddr, iph->daddr, skb->len,\r\nIPPROTO_UDP, 0);\r\nskb->csum_start = skb_transport_header(skb) - skb->head;\r\nskb->csum_offset = offsetof(struct udphdr, check);\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *udp4_ufo_fragment(struct sk_buff *skb,\r\nnetdev_features_t features)\r\n{\r\nstruct sk_buff *segs = ERR_PTR(-EINVAL);\r\nunsigned int mss;\r\nmss = skb_shinfo(skb)->gso_size;\r\nif (unlikely(skb->len <= mss))\r\ngoto out;\r\nif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\r\nint type = skb_shinfo(skb)->gso_type;\r\nif (unlikely(type & ~(SKB_GSO_UDP | SKB_GSO_DODGY |\r\nSKB_GSO_UDP_TUNNEL |\r\nSKB_GSO_GRE | SKB_GSO_MPLS) ||\r\n!(type & (SKB_GSO_UDP))))\r\ngoto out;\r\nskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\r\nsegs = NULL;\r\ngoto out;\r\n}\r\nif (skb->encapsulation && skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL)\r\nsegs = skb_udp_tunnel_segment(skb, features);\r\nelse {\r\nint offset;\r\n__wsum csum;\r\noffset = skb_checksum_start_offset(skb);\r\ncsum = skb_checksum(skb, offset, skb->len - offset, 0);\r\noffset += skb->csum_offset;\r\n*(__sum16 *)(skb->data + offset) = csum_fold(csum);\r\nskb->ip_summed = CHECKSUM_NONE;\r\nsegs = skb_segment(skb, features);\r\n}\r\nout:\r\nreturn segs;\r\n}\r\nint __init udpv4_offload_init(void)\r\n{\r\nreturn inet_add_offload(&udpv4_offload, IPPROTO_UDP);\r\n}
