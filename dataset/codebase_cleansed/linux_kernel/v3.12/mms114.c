static int __mms114_read_reg(struct mms114_data *data, unsigned int reg,\r\nunsigned int len, u8 *val)\r\n{\r\nstruct i2c_client *client = data->client;\r\nstruct i2c_msg xfer[2];\r\nu8 buf = reg & 0xff;\r\nint error;\r\nif (reg <= MMS114_MODE_CONTROL && reg + len > MMS114_MODE_CONTROL)\r\nBUG();\r\nxfer[0].addr = client->addr;\r\nxfer[0].flags = I2C_M_TEN | I2C_M_NOSTART;\r\nxfer[0].len = 1;\r\nxfer[0].buf = &buf;\r\nxfer[1].addr = client->addr;\r\nxfer[1].flags = I2C_M_RD;\r\nxfer[1].len = len;\r\nxfer[1].buf = val;\r\nerror = i2c_transfer(client->adapter, xfer, 2);\r\nif (error != 2) {\r\ndev_err(&client->dev,\r\n"%s: i2c transfer failed (%d)\n", __func__, error);\r\nreturn error < 0 ? error : -EIO;\r\n}\r\nudelay(MMS114_I2C_DELAY);\r\nreturn 0;\r\n}\r\nstatic int mms114_read_reg(struct mms114_data *data, unsigned int reg)\r\n{\r\nu8 val;\r\nint error;\r\nif (reg == MMS114_MODE_CONTROL)\r\nreturn data->cache_mode_control;\r\nerror = __mms114_read_reg(data, reg, 1, &val);\r\nreturn error < 0 ? error : val;\r\n}\r\nstatic int mms114_write_reg(struct mms114_data *data, unsigned int reg,\r\nunsigned int val)\r\n{\r\nstruct i2c_client *client = data->client;\r\nu8 buf[2];\r\nint error;\r\nbuf[0] = reg & 0xff;\r\nbuf[1] = val & 0xff;\r\nerror = i2c_master_send(client, buf, 2);\r\nif (error != 2) {\r\ndev_err(&client->dev,\r\n"%s: i2c send failed (%d)\n", __func__, error);\r\nreturn error < 0 ? error : -EIO;\r\n}\r\nudelay(MMS114_I2C_DELAY);\r\nif (reg == MMS114_MODE_CONTROL)\r\ndata->cache_mode_control = val;\r\nreturn 0;\r\n}\r\nstatic void mms114_process_mt(struct mms114_data *data, struct mms114_touch *touch)\r\n{\r\nconst struct mms114_platform_data *pdata = data->pdata;\r\nstruct i2c_client *client = data->client;\r\nstruct input_dev *input_dev = data->input_dev;\r\nunsigned int id;\r\nunsigned int x;\r\nunsigned int y;\r\nif (touch->id > MMS114_MAX_TOUCH) {\r\ndev_err(&client->dev, "Wrong touch id (%d)\n", touch->id);\r\nreturn;\r\n}\r\nif (touch->type != MMS114_TYPE_TOUCHSCREEN) {\r\ndev_err(&client->dev, "Wrong touch type (%d)\n", touch->type);\r\nreturn;\r\n}\r\nid = touch->id - 1;\r\nx = touch->x_lo | touch->x_hi << 8;\r\ny = touch->y_lo | touch->y_hi << 8;\r\nif (x > pdata->x_size || y > pdata->y_size) {\r\ndev_dbg(&client->dev,\r\n"Wrong touch coordinates (%d, %d)\n", x, y);\r\nreturn;\r\n}\r\nif (pdata->x_invert)\r\nx = pdata->x_size - x;\r\nif (pdata->y_invert)\r\ny = pdata->y_size - y;\r\ndev_dbg(&client->dev,\r\n"id: %d, type: %d, pressed: %d, x: %d, y: %d, width: %d, strength: %d\n",\r\nid, touch->type, touch->pressed,\r\nx, y, touch->width, touch->strength);\r\ninput_mt_slot(input_dev, id);\r\ninput_mt_report_slot_state(input_dev, MT_TOOL_FINGER, touch->pressed);\r\nif (touch->pressed) {\r\ninput_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, touch->width);\r\ninput_report_abs(input_dev, ABS_MT_POSITION_X, x);\r\ninput_report_abs(input_dev, ABS_MT_POSITION_Y, y);\r\ninput_report_abs(input_dev, ABS_MT_PRESSURE, touch->strength);\r\n}\r\n}\r\nstatic irqreturn_t mms114_interrupt(int irq, void *dev_id)\r\n{\r\nstruct mms114_data *data = dev_id;\r\nstruct input_dev *input_dev = data->input_dev;\r\nstruct mms114_touch touch[MMS114_MAX_TOUCH];\r\nint packet_size;\r\nint touch_size;\r\nint index;\r\nint error;\r\nmutex_lock(&input_dev->mutex);\r\nif (!input_dev->users) {\r\nmutex_unlock(&input_dev->mutex);\r\ngoto out;\r\n}\r\nmutex_unlock(&input_dev->mutex);\r\npacket_size = mms114_read_reg(data, MMS114_PACKET_SIZE);\r\nif (packet_size <= 0)\r\ngoto out;\r\ntouch_size = packet_size / MMS114_PACKET_NUM;\r\nerror = __mms114_read_reg(data, MMS114_INFOMATION, packet_size,\r\n(u8 *)touch);\r\nif (error < 0)\r\ngoto out;\r\nfor (index = 0; index < touch_size; index++)\r\nmms114_process_mt(data, touch + index);\r\ninput_mt_report_pointer_emulation(data->input_dev, true);\r\ninput_sync(data->input_dev);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mms114_set_active(struct mms114_data *data, bool active)\r\n{\r\nint val;\r\nval = mms114_read_reg(data, MMS114_MODE_CONTROL);\r\nif (val < 0)\r\nreturn val;\r\nval &= ~MMS114_OPERATION_MODE_MASK;\r\nif (active)\r\nval |= MMS114_ACTIVE;\r\nreturn mms114_write_reg(data, MMS114_MODE_CONTROL, val);\r\n}\r\nstatic int mms114_get_version(struct mms114_data *data)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nu8 buf[6];\r\nint error;\r\nerror = __mms114_read_reg(data, MMS114_TSP_REV, 6, buf);\r\nif (error < 0)\r\nreturn error;\r\ndev_info(dev, "TSP Rev: 0x%x, HW Rev: 0x%x, Firmware Ver: 0x%x\n",\r\nbuf[0], buf[1], buf[3]);\r\nreturn 0;\r\n}\r\nstatic int mms114_setup_regs(struct mms114_data *data)\r\n{\r\nconst struct mms114_platform_data *pdata = data->pdata;\r\nint val;\r\nint error;\r\nerror = mms114_get_version(data);\r\nif (error < 0)\r\nreturn error;\r\nerror = mms114_set_active(data, true);\r\nif (error < 0)\r\nreturn error;\r\nval = (pdata->x_size >> 8) & 0xf;\r\nval |= ((pdata->y_size >> 8) & 0xf) << 4;\r\nerror = mms114_write_reg(data, MMS114_XY_RESOLUTION_H, val);\r\nif (error < 0)\r\nreturn error;\r\nval = pdata->x_size & 0xff;\r\nerror = mms114_write_reg(data, MMS114_X_RESOLUTION, val);\r\nif (error < 0)\r\nreturn error;\r\nval = pdata->y_size & 0xff;\r\nerror = mms114_write_reg(data, MMS114_Y_RESOLUTION, val);\r\nif (error < 0)\r\nreturn error;\r\nif (pdata->contact_threshold) {\r\nerror = mms114_write_reg(data, MMS114_CONTACT_THRESHOLD,\r\npdata->contact_threshold);\r\nif (error < 0)\r\nreturn error;\r\n}\r\nif (pdata->moving_threshold) {\r\nerror = mms114_write_reg(data, MMS114_MOVING_THRESHOLD,\r\npdata->moving_threshold);\r\nif (error < 0)\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mms114_start(struct mms114_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint error;\r\nerror = regulator_enable(data->core_reg);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to enable avdd: %d\n", error);\r\nreturn error;\r\n}\r\nerror = regulator_enable(data->io_reg);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to enable vdd: %d\n", error);\r\nregulator_disable(data->core_reg);\r\nreturn error;\r\n}\r\nmdelay(MMS114_POWERON_DELAY);\r\nerror = mms114_setup_regs(data);\r\nif (error < 0) {\r\nregulator_disable(data->io_reg);\r\nregulator_disable(data->core_reg);\r\nreturn error;\r\n}\r\nif (data->pdata->cfg_pin)\r\ndata->pdata->cfg_pin(true);\r\nenable_irq(client->irq);\r\nreturn 0;\r\n}\r\nstatic void mms114_stop(struct mms114_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint error;\r\ndisable_irq(client->irq);\r\nif (data->pdata->cfg_pin)\r\ndata->pdata->cfg_pin(false);\r\nerror = regulator_disable(data->io_reg);\r\nif (error)\r\ndev_warn(&client->dev, "Failed to disable vdd: %d\n", error);\r\nerror = regulator_disable(data->core_reg);\r\nif (error)\r\ndev_warn(&client->dev, "Failed to disable avdd: %d\n", error);\r\n}\r\nstatic int mms114_input_open(struct input_dev *dev)\r\n{\r\nstruct mms114_data *data = input_get_drvdata(dev);\r\nreturn mms114_start(data);\r\n}\r\nstatic void mms114_input_close(struct input_dev *dev)\r\n{\r\nstruct mms114_data *data = input_get_drvdata(dev);\r\nmms114_stop(data);\r\n}\r\nstatic struct mms114_platform_data *mms114_parse_dt(struct device *dev)\r\n{\r\nstruct mms114_platform_data *pdata;\r\nstruct device_node *np = dev->of_node;\r\nif (!np)\r\nreturn NULL;\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata) {\r\ndev_err(dev, "failed to allocate platform data\n");\r\nreturn NULL;\r\n}\r\nif (of_property_read_u32(np, "x-size", &pdata->x_size)) {\r\ndev_err(dev, "failed to get x-size property\n");\r\nreturn NULL;\r\n};\r\nif (of_property_read_u32(np, "y-size", &pdata->y_size)) {\r\ndev_err(dev, "failed to get y-size property\n");\r\nreturn NULL;\r\n};\r\nof_property_read_u32(np, "contact-threshold",\r\n&pdata->contact_threshold);\r\nof_property_read_u32(np, "moving-threshold",\r\n&pdata->moving_threshold);\r\nif (of_find_property(np, "x-invert", NULL))\r\npdata->x_invert = true;\r\nif (of_find_property(np, "y-invert", NULL))\r\npdata->y_invert = true;\r\nreturn pdata;\r\n}\r\nstatic inline struct mms114_platform_data *mms114_parse_dt(struct device *dev)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int mms114_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct mms114_platform_data *pdata;\r\nstruct mms114_data *data;\r\nstruct input_dev *input_dev;\r\nint error;\r\npdata = dev_get_platdata(&client->dev);\r\nif (!pdata)\r\npdata = mms114_parse_dt(&client->dev);\r\nif (!pdata) {\r\ndev_err(&client->dev, "Need platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_PROTOCOL_MANGLING)) {\r\ndev_err(&client->dev,\r\n"Need i2c bus that supports protocol mangling\n");\r\nreturn -ENODEV;\r\n}\r\ndata = devm_kzalloc(&client->dev, sizeof(struct mms114_data),\r\nGFP_KERNEL);\r\ninput_dev = devm_input_allocate_device(&client->dev);\r\nif (!data || !input_dev) {\r\ndev_err(&client->dev, "Failed to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\ndata->client = client;\r\ndata->input_dev = input_dev;\r\ndata->pdata = pdata;\r\ninput_dev->name = "MELPAS MMS114 Touchscreen";\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->dev.parent = &client->dev;\r\ninput_dev->open = mms114_input_open;\r\ninput_dev->close = mms114_input_close;\r\n__set_bit(EV_ABS, input_dev->evbit);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(BTN_TOUCH, input_dev->keybit);\r\ninput_set_abs_params(input_dev, ABS_X, 0, data->pdata->x_size, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, data->pdata->y_size, 0, 0);\r\ninput_mt_init_slots(input_dev, MMS114_MAX_TOUCH, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,\r\n0, MMS114_MAX_AREA, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_X,\r\n0, data->pdata->x_size, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_Y,\r\n0, data->pdata->y_size, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_PRESSURE, 0, 255, 0, 0);\r\ninput_set_drvdata(input_dev, data);\r\ni2c_set_clientdata(client, data);\r\ndata->core_reg = devm_regulator_get(&client->dev, "avdd");\r\nif (IS_ERR(data->core_reg)) {\r\nerror = PTR_ERR(data->core_reg);\r\ndev_err(&client->dev,\r\n"Unable to get the Core regulator (%d)\n", error);\r\nreturn error;\r\n}\r\ndata->io_reg = devm_regulator_get(&client->dev, "vdd");\r\nif (IS_ERR(data->io_reg)) {\r\nerror = PTR_ERR(data->io_reg);\r\ndev_err(&client->dev,\r\n"Unable to get the IO regulator (%d)\n", error);\r\nreturn error;\r\n}\r\nerror = devm_request_threaded_irq(&client->dev, client->irq, NULL,\r\nmms114_interrupt, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\ndev_name(&client->dev), data);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to register interrupt\n");\r\nreturn error;\r\n}\r\ndisable_irq(client->irq);\r\nerror = input_register_device(data->input_dev);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to register input device\n");\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mms114_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct mms114_data *data = i2c_get_clientdata(client);\r\nstruct input_dev *input_dev = data->input_dev;\r\nint id;\r\nfor (id = 0; id < MMS114_MAX_TOUCH; id++) {\r\ninput_mt_slot(input_dev, id);\r\ninput_mt_report_slot_state(input_dev, MT_TOOL_FINGER, false);\r\n}\r\ninput_mt_report_pointer_emulation(input_dev, true);\r\ninput_sync(input_dev);\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\nmms114_stop(data);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}\r\nstatic int mms114_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct mms114_data *data = i2c_get_clientdata(client);\r\nstruct input_dev *input_dev = data->input_dev;\r\nint error;\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users) {\r\nerror = mms114_start(data);\r\nif (error < 0) {\r\nmutex_unlock(&input_dev->mutex);\r\nreturn error;\r\n}\r\n}\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}
