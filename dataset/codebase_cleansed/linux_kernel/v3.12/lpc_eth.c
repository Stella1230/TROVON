static phy_interface_t lpc_phy_interface_mode(struct device *dev)\r\n{\r\nif (dev && dev->of_node) {\r\nconst char *mode = of_get_property(dev->of_node,\r\n"phy-mode", NULL);\r\nif (mode && !strcmp(mode, "mii"))\r\nreturn PHY_INTERFACE_MODE_MII;\r\n}\r\nreturn PHY_INTERFACE_MODE_RMII;\r\n}\r\nstatic bool use_iram_for_net(struct device *dev)\r\n{\r\nif (dev && dev->of_node)\r\nreturn of_property_read_bool(dev->of_node, "use-iram");\r\nreturn false;\r\n}\r\nstatic void __lpc_set_mac(struct netdata_local *pldat, u8 *mac)\r\n{\r\nu32 tmp;\r\ntmp = mac[0] | ((u32)mac[1] << 8);\r\nwritel(tmp, LPC_ENET_SA2(pldat->net_base));\r\ntmp = mac[2] | ((u32)mac[3] << 8);\r\nwritel(tmp, LPC_ENET_SA1(pldat->net_base));\r\ntmp = mac[4] | ((u32)mac[5] << 8);\r\nwritel(tmp, LPC_ENET_SA0(pldat->net_base));\r\nnetdev_dbg(pldat->ndev, "Ethernet MAC address %pM\n", mac);\r\n}\r\nstatic void __lpc_get_mac(struct netdata_local *pldat, u8 *mac)\r\n{\r\nu32 tmp;\r\ntmp = readl(LPC_ENET_SA2(pldat->net_base));\r\nmac[0] = tmp & 0xFF;\r\nmac[1] = tmp >> 8;\r\ntmp = readl(LPC_ENET_SA1(pldat->net_base));\r\nmac[2] = tmp & 0xFF;\r\nmac[3] = tmp >> 8;\r\ntmp = readl(LPC_ENET_SA0(pldat->net_base));\r\nmac[4] = tmp & 0xFF;\r\nmac[5] = tmp >> 8;\r\n}\r\nstatic void __lpc_eth_clock_enable(struct netdata_local *pldat,\r\nbool enable)\r\n{\r\nif (enable)\r\nclk_enable(pldat->clk);\r\nelse\r\nclk_disable(pldat->clk);\r\n}\r\nstatic void __lpc_params_setup(struct netdata_local *pldat)\r\n{\r\nu32 tmp;\r\nif (pldat->duplex == DUPLEX_FULL) {\r\ntmp = readl(LPC_ENET_MAC2(pldat->net_base));\r\ntmp |= LPC_MAC2_FULL_DUPLEX;\r\nwritel(tmp, LPC_ENET_MAC2(pldat->net_base));\r\ntmp = readl(LPC_ENET_COMMAND(pldat->net_base));\r\ntmp |= LPC_COMMAND_FULLDUPLEX;\r\nwritel(tmp, LPC_ENET_COMMAND(pldat->net_base));\r\nwritel(LPC_IPGT_LOAD(0x15), LPC_ENET_IPGT(pldat->net_base));\r\n} else {\r\ntmp = readl(LPC_ENET_MAC2(pldat->net_base));\r\ntmp &= ~LPC_MAC2_FULL_DUPLEX;\r\nwritel(tmp, LPC_ENET_MAC2(pldat->net_base));\r\ntmp = readl(LPC_ENET_COMMAND(pldat->net_base));\r\ntmp &= ~LPC_COMMAND_FULLDUPLEX;\r\nwritel(tmp, LPC_ENET_COMMAND(pldat->net_base));\r\nwritel(LPC_IPGT_LOAD(0x12), LPC_ENET_IPGT(pldat->net_base));\r\n}\r\nif (pldat->speed == SPEED_100)\r\nwritel(LPC_SUPP_SPEED, LPC_ENET_SUPP(pldat->net_base));\r\nelse\r\nwritel(0, LPC_ENET_SUPP(pldat->net_base));\r\n}\r\nstatic void __lpc_eth_reset(struct netdata_local *pldat)\r\n{\r\nwritel((LPC_MAC1_RESET_TX | LPC_MAC1_RESET_MCS_TX | LPC_MAC1_RESET_RX |\r\nLPC_MAC1_RESET_MCS_RX | LPC_MAC1_SIMULATION_RESET |\r\nLPC_MAC1_SOFT_RESET), LPC_ENET_MAC1(pldat->net_base));\r\nwritel((LPC_COMMAND_REG_RESET | LPC_COMMAND_TXRESET |\r\nLPC_COMMAND_RXRESET), LPC_ENET_COMMAND(pldat->net_base));\r\n}\r\nstatic int __lpc_mii_mngt_reset(struct netdata_local *pldat)\r\n{\r\nwritel(LPC_MCFG_RESET_MII_MGMT, LPC_ENET_MCFG(pldat->net_base));\r\nwritel(LPC_MCFG_CLOCK_SELECT(LPC_MCFG_CLOCK_HOST_DIV_28),\r\nLPC_ENET_MCFG(pldat->net_base));\r\nreturn 0;\r\n}\r\nstatic inline phys_addr_t __va_to_pa(void *addr, struct netdata_local *pldat)\r\n{\r\nphys_addr_t phaddr;\r\nphaddr = addr - pldat->dma_buff_base_v;\r\nphaddr += pldat->dma_buff_base_p;\r\nreturn phaddr;\r\n}\r\nstatic void lpc_eth_enable_int(void __iomem *regbase)\r\n{\r\nwritel((LPC_MACINT_RXDONEINTEN | LPC_MACINT_TXDONEINTEN),\r\nLPC_ENET_INTENABLE(regbase));\r\n}\r\nstatic void lpc_eth_disable_int(void __iomem *regbase)\r\n{\r\nwritel(0, LPC_ENET_INTENABLE(regbase));\r\n}\r\nstatic void __lpc_txrx_desc_setup(struct netdata_local *pldat)\r\n{\r\nu32 *ptxstat;\r\nvoid *tbuff;\r\nint i;\r\nstruct txrx_desc_t *ptxrxdesc;\r\nstruct rx_status_t *prxstat;\r\ntbuff = PTR_ALIGN(pldat->dma_buff_base_v, 16);\r\npldat->tx_desc_v = tbuff;\r\ntbuff += sizeof(struct txrx_desc_t) * ENET_TX_DESC;\r\npldat->tx_stat_v = tbuff;\r\ntbuff += sizeof(u32) * ENET_TX_DESC;\r\ntbuff = PTR_ALIGN(tbuff, 16);\r\npldat->tx_buff_v = tbuff;\r\ntbuff += ENET_MAXF_SIZE * ENET_TX_DESC;\r\npldat->rx_desc_v = tbuff;\r\ntbuff += sizeof(struct txrx_desc_t) * ENET_RX_DESC;\r\ntbuff = PTR_ALIGN(tbuff, 16);\r\npldat->rx_stat_v = tbuff;\r\ntbuff += sizeof(struct rx_status_t) * ENET_RX_DESC;\r\ntbuff = PTR_ALIGN(tbuff, 16);\r\npldat->rx_buff_v = tbuff;\r\ntbuff += ENET_MAXF_SIZE * ENET_RX_DESC;\r\nfor (i = 0; i < ENET_TX_DESC; i++) {\r\nptxstat = &pldat->tx_stat_v[i];\r\nptxrxdesc = &pldat->tx_desc_v[i];\r\nptxrxdesc->packet = __va_to_pa(\r\npldat->tx_buff_v + i * ENET_MAXF_SIZE, pldat);\r\nptxrxdesc->control = 0;\r\n*ptxstat = 0;\r\n}\r\nfor (i = 0; i < ENET_RX_DESC; i++) {\r\nprxstat = &pldat->rx_stat_v[i];\r\nptxrxdesc = &pldat->rx_desc_v[i];\r\nptxrxdesc->packet = __va_to_pa(\r\npldat->rx_buff_v + i * ENET_MAXF_SIZE, pldat);\r\nptxrxdesc->control = RXDESC_CONTROL_INT | (ENET_MAXF_SIZE - 1);\r\nprxstat->statusinfo = 0;\r\nprxstat->statushashcrc = 0;\r\n}\r\nwritel((ENET_TX_DESC - 1),\r\nLPC_ENET_TXDESCRIPTORNUMBER(pldat->net_base));\r\nwritel(__va_to_pa(pldat->tx_desc_v, pldat),\r\nLPC_ENET_TXDESCRIPTOR(pldat->net_base));\r\nwritel(__va_to_pa(pldat->tx_stat_v, pldat),\r\nLPC_ENET_TXSTATUS(pldat->net_base));\r\nwritel((ENET_RX_DESC - 1),\r\nLPC_ENET_RXDESCRIPTORNUMBER(pldat->net_base));\r\nwritel(__va_to_pa(pldat->rx_desc_v, pldat),\r\nLPC_ENET_RXDESCRIPTOR(pldat->net_base));\r\nwritel(__va_to_pa(pldat->rx_stat_v, pldat),\r\nLPC_ENET_RXSTATUS(pldat->net_base));\r\n}\r\nstatic void __lpc_eth_init(struct netdata_local *pldat)\r\n{\r\nu32 tmp;\r\ntmp = readl(LPC_ENET_COMMAND(pldat->net_base));\r\ntmp &= ~LPC_COMMAND_RXENABLE | LPC_COMMAND_TXENABLE;\r\nwritel(tmp, LPC_ENET_COMMAND(pldat->net_base));\r\ntmp = readl(LPC_ENET_MAC1(pldat->net_base));\r\ntmp &= ~LPC_MAC1_RECV_ENABLE;\r\nwritel(tmp, LPC_ENET_MAC1(pldat->net_base));\r\nwritel(LPC_MAC1_PASS_ALL_RX_FRAMES, LPC_ENET_MAC1(pldat->net_base));\r\nwritel((LPC_MAC2_PAD_CRC_ENABLE | LPC_MAC2_CRC_ENABLE),\r\nLPC_ENET_MAC2(pldat->net_base));\r\nwritel(ENET_MAXF_SIZE, LPC_ENET_MAXF(pldat->net_base));\r\nwritel((LPC_CLRT_LOAD_RETRY_MAX(0xF) |\r\nLPC_CLRT_LOAD_COLLISION_WINDOW(0x37)),\r\nLPC_ENET_CLRT(pldat->net_base));\r\nwritel(LPC_IPGR_LOAD_PART2(0x12), LPC_ENET_IPGR(pldat->net_base));\r\nif (lpc_phy_interface_mode(&pldat->pdev->dev) == PHY_INTERFACE_MODE_MII)\r\nwritel(LPC_COMMAND_PASSRUNTFRAME,\r\nLPC_ENET_COMMAND(pldat->net_base));\r\nelse {\r\nwritel((LPC_COMMAND_PASSRUNTFRAME | LPC_COMMAND_RMII),\r\nLPC_ENET_COMMAND(pldat->net_base));\r\nwritel(LPC_SUPP_RESET_RMII, LPC_ENET_SUPP(pldat->net_base));\r\n}\r\n__lpc_params_setup(pldat);\r\n__lpc_txrx_desc_setup(pldat);\r\nwritel((LPC_RXFLTRW_ACCEPTUBROADCAST | LPC_RXFLTRW_ACCEPTPERFECT),\r\nLPC_ENET_RXFILTER_CTRL(pldat->net_base));\r\npldat->num_used_tx_buffs = 0;\r\npldat->last_tx_idx =\r\nreadl(LPC_ENET_TXCONSUMEINDEX(pldat->net_base));\r\nwritel(0xFFFF, LPC_ENET_INTCLEAR(pldat->net_base));\r\nsmp_wmb();\r\nlpc_eth_enable_int(pldat->net_base);\r\ntmp = readl(LPC_ENET_COMMAND(pldat->net_base));\r\ntmp |= LPC_COMMAND_RXENABLE | LPC_COMMAND_TXENABLE;\r\nwritel(tmp, LPC_ENET_COMMAND(pldat->net_base));\r\ntmp = readl(LPC_ENET_MAC1(pldat->net_base));\r\ntmp |= LPC_MAC1_RECV_ENABLE;\r\nwritel(tmp, LPC_ENET_MAC1(pldat->net_base));\r\n}\r\nstatic void __lpc_eth_shutdown(struct netdata_local *pldat)\r\n{\r\n__lpc_eth_reset(pldat);\r\nwritel(0, LPC_ENET_MAC1(pldat->net_base));\r\nwritel(0, LPC_ENET_MAC2(pldat->net_base));\r\n}\r\nstatic int lpc_mdio_read(struct mii_bus *bus, int phy_id, int phyreg)\r\n{\r\nstruct netdata_local *pldat = bus->priv;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(100);\r\nint lps;\r\nwritel(((phy_id << 8) | phyreg), LPC_ENET_MADR(pldat->net_base));\r\nwritel(LPC_MCMD_READ, LPC_ENET_MCMD(pldat->net_base));\r\nwhile (readl(LPC_ENET_MIND(pldat->net_base)) & LPC_MIND_BUSY) {\r\nif (time_after(jiffies, timeout))\r\nreturn -EIO;\r\ncpu_relax();\r\n}\r\nlps = readl(LPC_ENET_MRDD(pldat->net_base));\r\nwritel(0, LPC_ENET_MCMD(pldat->net_base));\r\nreturn lps;\r\n}\r\nstatic int lpc_mdio_write(struct mii_bus *bus, int phy_id, int phyreg,\r\nu16 phydata)\r\n{\r\nstruct netdata_local *pldat = bus->priv;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(100);\r\nwritel(((phy_id << 8) | phyreg), LPC_ENET_MADR(pldat->net_base));\r\nwritel(phydata, LPC_ENET_MWTD(pldat->net_base));\r\nwhile (readl(LPC_ENET_MIND(pldat->net_base)) & LPC_MIND_BUSY) {\r\nif (time_after(jiffies, timeout))\r\nreturn -EIO;\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpc_mdio_reset(struct mii_bus *bus)\r\n{\r\nreturn __lpc_mii_mngt_reset((struct netdata_local *)bus->priv);\r\n}\r\nstatic void lpc_handle_link_change(struct net_device *ndev)\r\n{\r\nstruct netdata_local *pldat = netdev_priv(ndev);\r\nstruct phy_device *phydev = pldat->phy_dev;\r\nunsigned long flags;\r\nbool status_change = false;\r\nspin_lock_irqsave(&pldat->lock, flags);\r\nif (phydev->link) {\r\nif ((pldat->speed != phydev->speed) ||\r\n(pldat->duplex != phydev->duplex)) {\r\npldat->speed = phydev->speed;\r\npldat->duplex = phydev->duplex;\r\nstatus_change = true;\r\n}\r\n}\r\nif (phydev->link != pldat->link) {\r\nif (!phydev->link) {\r\npldat->speed = 0;\r\npldat->duplex = -1;\r\n}\r\npldat->link = phydev->link;\r\nstatus_change = true;\r\n}\r\nspin_unlock_irqrestore(&pldat->lock, flags);\r\nif (status_change)\r\n__lpc_params_setup(pldat);\r\n}\r\nstatic int lpc_mii_probe(struct net_device *ndev)\r\n{\r\nstruct netdata_local *pldat = netdev_priv(ndev);\r\nstruct phy_device *phydev = phy_find_first(pldat->mii_bus);\r\nif (!phydev) {\r\nnetdev_err(ndev, "no PHY found\n");\r\nreturn -ENODEV;\r\n}\r\nif (lpc_phy_interface_mode(&pldat->pdev->dev) == PHY_INTERFACE_MODE_MII)\r\nnetdev_info(ndev, "using MII interface\n");\r\nelse\r\nnetdev_info(ndev, "using RMII interface\n");\r\nphydev = phy_connect(ndev, dev_name(&phydev->dev),\r\n&lpc_handle_link_change,\r\nlpc_phy_interface_mode(&pldat->pdev->dev));\r\nif (IS_ERR(phydev)) {\r\nnetdev_err(ndev, "Could not attach to PHY\n");\r\nreturn PTR_ERR(phydev);\r\n}\r\nphydev->supported &= PHY_BASIC_FEATURES;\r\nphydev->advertising = phydev->supported;\r\npldat->link = 0;\r\npldat->speed = 0;\r\npldat->duplex = -1;\r\npldat->phy_dev = phydev;\r\nnetdev_info(ndev,\r\n"attached PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)\n",\r\nphydev->drv->name, dev_name(&phydev->dev), phydev->irq);\r\nreturn 0;\r\n}\r\nstatic int lpc_mii_init(struct netdata_local *pldat)\r\n{\r\nint err = -ENXIO, i;\r\npldat->mii_bus = mdiobus_alloc();\r\nif (!pldat->mii_bus) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nif (lpc_phy_interface_mode(&pldat->pdev->dev) == PHY_INTERFACE_MODE_MII)\r\nwritel(LPC_COMMAND_PASSRUNTFRAME,\r\nLPC_ENET_COMMAND(pldat->net_base));\r\nelse {\r\nwritel((LPC_COMMAND_PASSRUNTFRAME | LPC_COMMAND_RMII),\r\nLPC_ENET_COMMAND(pldat->net_base));\r\nwritel(LPC_SUPP_RESET_RMII, LPC_ENET_SUPP(pldat->net_base));\r\n}\r\npldat->mii_bus->name = "lpc_mii_bus";\r\npldat->mii_bus->read = &lpc_mdio_read;\r\npldat->mii_bus->write = &lpc_mdio_write;\r\npldat->mii_bus->reset = &lpc_mdio_reset;\r\nsnprintf(pldat->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",\r\npldat->pdev->name, pldat->pdev->id);\r\npldat->mii_bus->priv = pldat;\r\npldat->mii_bus->parent = &pldat->pdev->dev;\r\npldat->mii_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);\r\nif (!pldat->mii_bus->irq) {\r\nerr = -ENOMEM;\r\ngoto err_out_1;\r\n}\r\nfor (i = 0; i < PHY_MAX_ADDR; i++)\r\npldat->mii_bus->irq[i] = PHY_POLL;\r\nplatform_set_drvdata(pldat->pdev, pldat->mii_bus);\r\nif (mdiobus_register(pldat->mii_bus))\r\ngoto err_out_free_mdio_irq;\r\nif (lpc_mii_probe(pldat->ndev) != 0)\r\ngoto err_out_unregister_bus;\r\nreturn 0;\r\nerr_out_unregister_bus:\r\nmdiobus_unregister(pldat->mii_bus);\r\nerr_out_free_mdio_irq:\r\nkfree(pldat->mii_bus->irq);\r\nerr_out_1:\r\nmdiobus_free(pldat->mii_bus);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic void __lpc_handle_xmit(struct net_device *ndev)\r\n{\r\nstruct netdata_local *pldat = netdev_priv(ndev);\r\nu32 txcidx, *ptxstat, txstat;\r\ntxcidx = readl(LPC_ENET_TXCONSUMEINDEX(pldat->net_base));\r\nwhile (pldat->last_tx_idx != txcidx) {\r\nunsigned int skblen = pldat->skblen[pldat->last_tx_idx];\r\nptxstat = &pldat->tx_stat_v[pldat->last_tx_idx];\r\ntxstat = *ptxstat;\r\npldat->num_used_tx_buffs--;\r\npldat->last_tx_idx++;\r\nif (pldat->last_tx_idx >= ENET_TX_DESC)\r\npldat->last_tx_idx = 0;\r\nndev->stats.collisions += TXSTATUS_COLLISIONS_GET(txstat);\r\nif (txstat & TXSTATUS_ERROR) {\r\nif (txstat & TXSTATUS_UNDERRUN) {\r\nndev->stats.tx_fifo_errors++;\r\n}\r\nif (txstat & TXSTATUS_LATECOLL) {\r\nndev->stats.tx_aborted_errors++;\r\n}\r\nif (txstat & TXSTATUS_EXCESSCOLL) {\r\nndev->stats.tx_aborted_errors++;\r\n}\r\nif (txstat & TXSTATUS_EXCESSDEFER) {\r\nndev->stats.tx_aborted_errors++;\r\n}\r\nndev->stats.tx_errors++;\r\n} else {\r\nndev->stats.tx_packets++;\r\nndev->stats.tx_bytes += skblen;\r\n}\r\ntxcidx = readl(LPC_ENET_TXCONSUMEINDEX(pldat->net_base));\r\n}\r\nif (pldat->num_used_tx_buffs <= ENET_TX_DESC/2) {\r\nif (netif_queue_stopped(ndev))\r\nnetif_wake_queue(ndev);\r\n}\r\n}\r\nstatic int __lpc_handle_recv(struct net_device *ndev, int budget)\r\n{\r\nstruct netdata_local *pldat = netdev_priv(ndev);\r\nstruct sk_buff *skb;\r\nu32 rxconsidx, len, ethst;\r\nstruct rx_status_t *prxstat;\r\nu8 *prdbuf;\r\nint rx_done = 0;\r\nrxconsidx = readl(LPC_ENET_RXCONSUMEINDEX(pldat->net_base));\r\nwhile (rx_done < budget && rxconsidx !=\r\nreadl(LPC_ENET_RXPRODUCEINDEX(pldat->net_base))) {\r\nprxstat = &pldat->rx_stat_v[rxconsidx];\r\nlen = (prxstat->statusinfo & RXSTATUS_SIZE) + 1;\r\nethst = prxstat->statusinfo;\r\nif ((ethst & (RXSTATUS_ERROR | RXSTATUS_STATUS_ERROR)) ==\r\n(RXSTATUS_ERROR | RXSTATUS_RANGE))\r\nethst &= ~RXSTATUS_ERROR;\r\nif (ethst & RXSTATUS_ERROR) {\r\nint si = prxstat->statusinfo;\r\nif (si & RXSTATUS_OVERRUN) {\r\nndev->stats.rx_fifo_errors++;\r\n} else if (si & RXSTATUS_CRC) {\r\nndev->stats.rx_crc_errors++;\r\n} else if (si & RXSTATUS_LENGTH) {\r\nndev->stats.rx_length_errors++;\r\n} else if (si & RXSTATUS_ERROR) {\r\nndev->stats.rx_length_errors++;\r\n}\r\nndev->stats.rx_errors++;\r\n} else {\r\nskb = dev_alloc_skb(len);\r\nif (!skb) {\r\nndev->stats.rx_dropped++;\r\n} else {\r\nprdbuf = skb_put(skb, len);\r\nmemcpy(prdbuf, pldat->rx_buff_v +\r\nrxconsidx * ENET_MAXF_SIZE, len);\r\nskb->protocol = eth_type_trans(skb, ndev);\r\nnetif_receive_skb(skb);\r\nndev->stats.rx_packets++;\r\nndev->stats.rx_bytes += len;\r\n}\r\n}\r\nrxconsidx = rxconsidx + 1;\r\nif (rxconsidx >= ENET_RX_DESC)\r\nrxconsidx = 0;\r\nwritel(rxconsidx,\r\nLPC_ENET_RXCONSUMEINDEX(pldat->net_base));\r\nrx_done++;\r\n}\r\nreturn rx_done;\r\n}\r\nstatic int lpc_eth_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct netdata_local *pldat = container_of(napi,\r\nstruct netdata_local, napi);\r\nstruct net_device *ndev = pldat->ndev;\r\nint rx_done = 0;\r\nstruct netdev_queue *txq = netdev_get_tx_queue(ndev, 0);\r\n__netif_tx_lock(txq, smp_processor_id());\r\n__lpc_handle_xmit(ndev);\r\n__netif_tx_unlock(txq);\r\nrx_done = __lpc_handle_recv(ndev, budget);\r\nif (rx_done < budget) {\r\nnapi_complete(napi);\r\nlpc_eth_enable_int(pldat->net_base);\r\n}\r\nreturn rx_done;\r\n}\r\nstatic irqreturn_t __lpc_eth_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *ndev = dev_id;\r\nstruct netdata_local *pldat = netdev_priv(ndev);\r\nu32 tmp;\r\nspin_lock(&pldat->lock);\r\ntmp = readl(LPC_ENET_INTSTATUS(pldat->net_base));\r\nwritel(tmp, LPC_ENET_INTCLEAR(pldat->net_base));\r\nlpc_eth_disable_int(pldat->net_base);\r\nif (likely(napi_schedule_prep(&pldat->napi)))\r\n__napi_schedule(&pldat->napi);\r\nspin_unlock(&pldat->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lpc_eth_close(struct net_device *ndev)\r\n{\r\nunsigned long flags;\r\nstruct netdata_local *pldat = netdev_priv(ndev);\r\nif (netif_msg_ifdown(pldat))\r\ndev_dbg(&pldat->pdev->dev, "shutting down %s\n", ndev->name);\r\nnapi_disable(&pldat->napi);\r\nnetif_stop_queue(ndev);\r\nif (pldat->phy_dev)\r\nphy_stop(pldat->phy_dev);\r\nspin_lock_irqsave(&pldat->lock, flags);\r\n__lpc_eth_reset(pldat);\r\nnetif_carrier_off(ndev);\r\nwritel(0, LPC_ENET_MAC1(pldat->net_base));\r\nwritel(0, LPC_ENET_MAC2(pldat->net_base));\r\nspin_unlock_irqrestore(&pldat->lock, flags);\r\n__lpc_eth_clock_enable(pldat, false);\r\nreturn 0;\r\n}\r\nstatic int lpc_eth_hard_start_xmit(struct sk_buff *skb, struct net_device *ndev)\r\n{\r\nstruct netdata_local *pldat = netdev_priv(ndev);\r\nu32 len, txidx;\r\nu32 *ptxstat;\r\nstruct txrx_desc_t *ptxrxdesc;\r\nlen = skb->len;\r\nspin_lock_irq(&pldat->lock);\r\nif (pldat->num_used_tx_buffs >= (ENET_TX_DESC - 1)) {\r\nnetif_stop_queue(ndev);\r\nspin_unlock_irq(&pldat->lock);\r\nWARN(1, "BUG! TX request when no free TX buffers!\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\ntxidx = readl(LPC_ENET_TXPRODUCEINDEX(pldat->net_base));\r\nptxstat = &pldat->tx_stat_v[txidx];\r\n*ptxstat = 0;\r\nptxrxdesc = &pldat->tx_desc_v[txidx];\r\nptxrxdesc->control =\r\n(len - 1) | TXDESC_CONTROL_LAST | TXDESC_CONTROL_INT;\r\nmemcpy(pldat->tx_buff_v + txidx * ENET_MAXF_SIZE, skb->data, len);\r\npldat->skblen[txidx] = len;\r\npldat->num_used_tx_buffs++;\r\ntxidx++;\r\nif (txidx >= ENET_TX_DESC)\r\ntxidx = 0;\r\nwritel(txidx, LPC_ENET_TXPRODUCEINDEX(pldat->net_base));\r\nif (pldat->num_used_tx_buffs >= (ENET_TX_DESC - 1))\r\nnetif_stop_queue(ndev);\r\nspin_unlock_irq(&pldat->lock);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int lpc_set_mac_address(struct net_device *ndev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nstruct netdata_local *pldat = netdev_priv(ndev);\r\nunsigned long flags;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(ndev->dev_addr, addr->sa_data, ETH_ALEN);\r\nspin_lock_irqsave(&pldat->lock, flags);\r\n__lpc_set_mac(pldat, ndev->dev_addr);\r\nspin_unlock_irqrestore(&pldat->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void lpc_eth_set_multicast_list(struct net_device *ndev)\r\n{\r\nstruct netdata_local *pldat = netdev_priv(ndev);\r\nstruct netdev_hw_addr_list *mcptr = &ndev->mc;\r\nstruct netdev_hw_addr *ha;\r\nu32 tmp32, hash_val, hashlo, hashhi;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pldat->lock, flags);\r\n__lpc_set_mac(pldat, ndev->dev_addr);\r\ntmp32 = LPC_RXFLTRW_ACCEPTUBROADCAST | LPC_RXFLTRW_ACCEPTPERFECT;\r\nif (ndev->flags & IFF_PROMISC)\r\ntmp32 |= LPC_RXFLTRW_ACCEPTUNICAST |\r\nLPC_RXFLTRW_ACCEPTUMULTICAST;\r\nif (ndev->flags & IFF_ALLMULTI)\r\ntmp32 |= LPC_RXFLTRW_ACCEPTUMULTICAST;\r\nif (netdev_hw_addr_list_count(mcptr))\r\ntmp32 |= LPC_RXFLTRW_ACCEPTUMULTICASTHASH;\r\nwritel(tmp32, LPC_ENET_RXFILTER_CTRL(pldat->net_base));\r\nhashlo = 0x0;\r\nhashhi = 0x0;\r\nnetdev_hw_addr_list_for_each(ha, mcptr) {\r\nhash_val = (ether_crc(6, ha->addr) >> 23) & 0x3F;\r\nif (hash_val >= 32)\r\nhashhi |= 1 << (hash_val - 32);\r\nelse\r\nhashlo |= 1 << hash_val;\r\n}\r\nwritel(hashlo, LPC_ENET_HASHFILTERL(pldat->net_base));\r\nwritel(hashhi, LPC_ENET_HASHFILTERH(pldat->net_base));\r\nspin_unlock_irqrestore(&pldat->lock, flags);\r\n}\r\nstatic int lpc_eth_ioctl(struct net_device *ndev, struct ifreq *req, int cmd)\r\n{\r\nstruct netdata_local *pldat = netdev_priv(ndev);\r\nstruct phy_device *phydev = pldat->phy_dev;\r\nif (!netif_running(ndev))\r\nreturn -EINVAL;\r\nif (!phydev)\r\nreturn -ENODEV;\r\nreturn phy_mii_ioctl(phydev, req, cmd);\r\n}\r\nstatic int lpc_eth_open(struct net_device *ndev)\r\n{\r\nstruct netdata_local *pldat = netdev_priv(ndev);\r\nif (netif_msg_ifup(pldat))\r\ndev_dbg(&pldat->pdev->dev, "enabling %s\n", ndev->name);\r\n__lpc_eth_clock_enable(pldat, true);\r\n__lpc_eth_reset(pldat);\r\n__lpc_eth_init(pldat);\r\nphy_start(pldat->phy_dev);\r\nnetif_start_queue(ndev);\r\nnapi_enable(&pldat->napi);\r\nreturn 0;\r\n}\r\nstatic void lpc_eth_ethtool_getdrvinfo(struct net_device *ndev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, MODNAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, dev_name(ndev->dev.parent),\r\nsizeof(info->bus_info));\r\n}\r\nstatic u32 lpc_eth_ethtool_getmsglevel(struct net_device *ndev)\r\n{\r\nstruct netdata_local *pldat = netdev_priv(ndev);\r\nreturn pldat->msg_enable;\r\n}\r\nstatic void lpc_eth_ethtool_setmsglevel(struct net_device *ndev, u32 level)\r\n{\r\nstruct netdata_local *pldat = netdev_priv(ndev);\r\npldat->msg_enable = level;\r\n}\r\nstatic int lpc_eth_ethtool_getsettings(struct net_device *ndev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct netdata_local *pldat = netdev_priv(ndev);\r\nstruct phy_device *phydev = pldat->phy_dev;\r\nif (!phydev)\r\nreturn -EOPNOTSUPP;\r\nreturn phy_ethtool_gset(phydev, cmd);\r\n}\r\nstatic int lpc_eth_ethtool_setsettings(struct net_device *ndev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct netdata_local *pldat = netdev_priv(ndev);\r\nstruct phy_device *phydev = pldat->phy_dev;\r\nif (!phydev)\r\nreturn -EOPNOTSUPP;\r\nreturn phy_ethtool_sset(phydev, cmd);\r\n}\r\nstatic int lpc_eth_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct net_device *ndev;\r\nstruct netdata_local *pldat;\r\nstruct phy_device *phydev;\r\ndma_addr_t dma_handle;\r\nint irq, ret;\r\nu32 tmp;\r\ntmp = __raw_readl(LPC32XX_CLKPWR_MACCLK_CTRL);\r\ntmp &= ~LPC32XX_CLKPWR_MACCTRL_PINS_MSK;\r\nif (lpc_phy_interface_mode(&pdev->dev) == PHY_INTERFACE_MODE_MII)\r\ntmp |= LPC32XX_CLKPWR_MACCTRL_USE_MII_PINS;\r\nelse\r\ntmp |= LPC32XX_CLKPWR_MACCTRL_USE_RMII_PINS;\r\n__raw_writel(tmp, LPC32XX_CLKPWR_MACCLK_CTRL);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif ((!res) || (irq < 0) || (irq >= NR_IRQS)) {\r\ndev_err(&pdev->dev, "error getting resources.\n");\r\nret = -ENXIO;\r\ngoto err_exit;\r\n}\r\nndev = alloc_etherdev(sizeof(struct netdata_local));\r\nif (!ndev) {\r\ndev_err(&pdev->dev, "could not allocate device.\n");\r\nret = -ENOMEM;\r\ngoto err_exit;\r\n}\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\npldat = netdev_priv(ndev);\r\npldat->pdev = pdev;\r\npldat->ndev = ndev;\r\nspin_lock_init(&pldat->lock);\r\nndev->irq = irq;\r\npldat->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(pldat->clk)) {\r\ndev_err(&pdev->dev, "error getting clock.\n");\r\nret = PTR_ERR(pldat->clk);\r\ngoto err_out_free_dev;\r\n}\r\n__lpc_eth_clock_enable(pldat, true);\r\npldat->net_base = ioremap(res->start, res->end - res->start + 1);\r\nif (!pldat->net_base) {\r\ndev_err(&pdev->dev, "failed to map registers\n");\r\nret = -ENOMEM;\r\ngoto err_out_disable_clocks;\r\n}\r\nret = request_irq(ndev->irq, __lpc_eth_interrupt, 0,\r\nndev->name, ndev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "error requesting interrupt.\n");\r\ngoto err_out_iounmap;\r\n}\r\nether_setup(ndev);\r\nndev->netdev_ops = &lpc_netdev_ops;\r\nndev->ethtool_ops = &lpc_eth_ethtool_ops;\r\nndev->watchdog_timeo = msecs_to_jiffies(2500);\r\npldat->dma_buff_size = (ENET_TX_DESC + ENET_RX_DESC) * (ENET_MAXF_SIZE +\r\nsizeof(struct txrx_desc_t) + sizeof(struct rx_status_t));\r\npldat->dma_buff_base_v = 0;\r\nif (use_iram_for_net(&pldat->pdev->dev)) {\r\ndma_handle = LPC32XX_IRAM_BASE;\r\nif (pldat->dma_buff_size <= lpc32xx_return_iram_size())\r\npldat->dma_buff_base_v =\r\nio_p2v(LPC32XX_IRAM_BASE);\r\nelse\r\nnetdev_err(ndev,\r\n"IRAM not big enough for net buffers, using SDRAM instead.\n");\r\n}\r\nif (pldat->dma_buff_base_v == 0) {\r\npldat->pdev->dev.coherent_dma_mask = 0xFFFFFFFF;\r\npldat->pdev->dev.dma_mask = &pldat->pdev->dev.coherent_dma_mask;\r\npldat->dma_buff_size = PAGE_ALIGN(pldat->dma_buff_size);\r\npldat->dma_buff_base_v =\r\ndma_alloc_coherent(&pldat->pdev->dev,\r\npldat->dma_buff_size, &dma_handle,\r\nGFP_KERNEL);\r\nif (pldat->dma_buff_base_v == NULL) {\r\nret = -ENOMEM;\r\ngoto err_out_free_irq;\r\n}\r\n}\r\npldat->dma_buff_base_p = dma_handle;\r\nnetdev_dbg(ndev, "IO address start :0x%08x\n",\r\nres->start);\r\nnetdev_dbg(ndev, "IO address size :%d\n",\r\nres->end - res->start + 1);\r\nnetdev_dbg(ndev, "IO address (mapped) :0x%p\n",\r\npldat->net_base);\r\nnetdev_dbg(ndev, "IRQ number :%d\n", ndev->irq);\r\nnetdev_dbg(ndev, "DMA buffer size :%d\n", pldat->dma_buff_size);\r\nnetdev_dbg(ndev, "DMA buffer P address :0x%08x\n",\r\npldat->dma_buff_base_p);\r\nnetdev_dbg(ndev, "DMA buffer V address :0x%p\n",\r\npldat->dma_buff_base_v);\r\n__lpc_get_mac(pldat, ndev->dev_addr);\r\nif (!is_valid_ether_addr(ndev->dev_addr)) {\r\nconst char *macaddr = of_get_mac_address(pdev->dev.of_node);\r\nif (macaddr)\r\nmemcpy(ndev->dev_addr, macaddr, ETH_ALEN);\r\n}\r\nif (!is_valid_ether_addr(ndev->dev_addr))\r\neth_hw_addr_random(ndev);\r\n__lpc_eth_reset(pldat);\r\n__lpc_eth_shutdown(pldat);\r\npldat->msg_enable = NETIF_MSG_LINK;\r\n__lpc_mii_mngt_reset(pldat);\r\npldat->link = 0;\r\npldat->speed = 100;\r\npldat->duplex = DUPLEX_FULL;\r\n__lpc_params_setup(pldat);\r\nnetif_napi_add(ndev, &pldat->napi, lpc_eth_poll, NAPI_WEIGHT);\r\nret = register_netdev(ndev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Cannot register net device, aborting.\n");\r\ngoto err_out_dma_unmap;\r\n}\r\nplatform_set_drvdata(pdev, ndev);\r\nret = lpc_mii_init(pldat);\r\nif (ret)\r\ngoto err_out_unregister_netdev;\r\nnetdev_info(ndev, "LPC mac at 0x%08x irq %d\n",\r\nres->start, ndev->irq);\r\nphydev = pldat->phy_dev;\r\ndevice_init_wakeup(&pdev->dev, 1);\r\ndevice_set_wakeup_enable(&pdev->dev, 0);\r\nreturn 0;\r\nerr_out_unregister_netdev:\r\nunregister_netdev(ndev);\r\nerr_out_dma_unmap:\r\nif (!use_iram_for_net(&pldat->pdev->dev) ||\r\npldat->dma_buff_size > lpc32xx_return_iram_size())\r\ndma_free_coherent(&pldat->pdev->dev, pldat->dma_buff_size,\r\npldat->dma_buff_base_v,\r\npldat->dma_buff_base_p);\r\nerr_out_free_irq:\r\nfree_irq(ndev->irq, ndev);\r\nerr_out_iounmap:\r\niounmap(pldat->net_base);\r\nerr_out_disable_clocks:\r\nclk_disable(pldat->clk);\r\nclk_put(pldat->clk);\r\nerr_out_free_dev:\r\nfree_netdev(ndev);\r\nerr_exit:\r\npr_err("%s: not found (%d).\n", MODNAME, ret);\r\nreturn ret;\r\n}\r\nstatic int lpc_eth_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct netdata_local *pldat = netdev_priv(ndev);\r\nunregister_netdev(ndev);\r\nif (!use_iram_for_net(&pldat->pdev->dev) ||\r\npldat->dma_buff_size > lpc32xx_return_iram_size())\r\ndma_free_coherent(&pldat->pdev->dev, pldat->dma_buff_size,\r\npldat->dma_buff_base_v,\r\npldat->dma_buff_base_p);\r\nfree_irq(ndev->irq, ndev);\r\niounmap(pldat->net_base);\r\nmdiobus_unregister(pldat->mii_bus);\r\nmdiobus_free(pldat->mii_bus);\r\nclk_disable(pldat->clk);\r\nclk_put(pldat->clk);\r\nfree_netdev(ndev);\r\nreturn 0;\r\n}\r\nstatic int lpc_eth_drv_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct netdata_local *pldat = netdev_priv(ndev);\r\nif (device_may_wakeup(&pdev->dev))\r\nenable_irq_wake(ndev->irq);\r\nif (ndev) {\r\nif (netif_running(ndev)) {\r\nnetif_device_detach(ndev);\r\n__lpc_eth_shutdown(pldat);\r\nclk_disable(pldat->clk);\r\n__lpc_eth_reset(pldat);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpc_eth_drv_resume(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct netdata_local *pldat;\r\nif (device_may_wakeup(&pdev->dev))\r\ndisable_irq_wake(ndev->irq);\r\nif (ndev) {\r\nif (netif_running(ndev)) {\r\npldat = netdev_priv(ndev);\r\nclk_enable(pldat->clk);\r\n__lpc_eth_reset(pldat);\r\n__lpc_eth_init(pldat);\r\nnetif_device_attach(ndev);\r\n}\r\n}\r\nreturn 0;\r\n}
