void power_state_active_enable(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&power_state_active_lock, flags);\r\npower_state_active_cnt++;\r\nspin_unlock_irqrestore(&power_state_active_lock, flags);\r\n}\r\nint power_state_active_disable(void)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&power_state_active_lock, flags);\r\nif (power_state_active_cnt <= 0) {\r\npr_err("power state: unbalanced enable/disable calls\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\npower_state_active_cnt--;\r\nout:\r\nspin_unlock_irqrestore(&power_state_active_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int power_state_active_get(void)\r\n{\r\nunsigned long flags;\r\nint cnt;\r\nspin_lock_irqsave(&power_state_active_lock, flags);\r\ncnt = power_state_active_cnt;\r\nspin_unlock_irqrestore(&power_state_active_lock, flags);\r\nreturn cnt;\r\n}\r\nvoid ux500_regulator_suspend_debug(void)\r\n{\r\nint i;\r\nfor (i = 0; i < rdebug.num_regulators; i++)\r\nrdebug.state_before_suspend[i] =\r\nrdebug.regulator_array[i].is_enabled;\r\n}\r\nvoid ux500_regulator_resume_debug(void)\r\n{\r\nint i;\r\nfor (i = 0; i < rdebug.num_regulators; i++)\r\nrdebug.state_after_suspend[i] =\r\nrdebug.regulator_array[i].is_enabled;\r\n}\r\nstatic int ux500_regulator_power_state_cnt_print(struct seq_file *s, void *p)\r\n{\r\nstruct device *dev = s->private;\r\nint err;\r\nerr = seq_printf(s, "ux500-regulator power state count: %i\n",\r\npower_state_active_get());\r\nif (err < 0)\r\ndev_err(dev, "seq_printf overflow\n");\r\nreturn 0;\r\n}\r\nstatic int ux500_regulator_power_state_cnt_open(struct inode *inode,\r\nstruct file *file)\r\n{\r\nreturn single_open(file, ux500_regulator_power_state_cnt_print,\r\ninode->i_private);\r\n}\r\nstatic int ux500_regulator_status_print(struct seq_file *s, void *p)\r\n{\r\nstruct device *dev = s->private;\r\nint err;\r\nint i;\r\nerr = seq_printf(s, "ux500-regulator status:\n");\r\nif (err < 0)\r\ndev_err(dev, "seq_printf overflow\n");\r\nerr = seq_printf(s, "%31s : %8s : %8s\n", "current",\r\n"before", "after");\r\nif (err < 0)\r\ndev_err(dev, "seq_printf overflow\n");\r\nfor (i = 0; i < rdebug.num_regulators; i++) {\r\nstruct dbx500_regulator_info *info;\r\ninfo = &rdebug.regulator_array[i];\r\nerr = seq_printf(s, "%20s : %8s : %8s : %8s\n", info->desc.name,\r\ninfo->is_enabled ? "enabled" : "disabled",\r\nrdebug.state_before_suspend[i] ? "enabled" : "disabled",\r\nrdebug.state_after_suspend[i] ? "enabled" : "disabled");\r\nif (err < 0)\r\ndev_err(dev, "seq_printf overflow\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int ux500_regulator_status_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ux500_regulator_status_print,\r\ninode->i_private);\r\n}\r\nint\r\nux500_regulator_debug_init(struct platform_device *pdev,\r\nstruct dbx500_regulator_info *regulator_info,\r\nint num_regulators)\r\n{\r\nrdebug.dir = debugfs_create_dir("ux500-regulator", NULL);\r\nif (!rdebug.dir)\r\ngoto exit_no_debugfs;\r\nrdebug.status_file = debugfs_create_file("status",\r\nS_IRUGO, rdebug.dir, &pdev->dev,\r\n&ux500_regulator_status_fops);\r\nif (!rdebug.status_file)\r\ngoto exit_destroy_dir;\r\nrdebug.power_state_cnt_file = debugfs_create_file("power-state-count",\r\nS_IRUGO, rdebug.dir, &pdev->dev,\r\n&ux500_regulator_power_state_cnt_fops);\r\nif (!rdebug.power_state_cnt_file)\r\ngoto exit_destroy_status;\r\nrdebug.regulator_array = regulator_info;\r\nrdebug.num_regulators = num_regulators;\r\nrdebug.state_before_suspend = kzalloc(num_regulators, GFP_KERNEL);\r\nif (!rdebug.state_before_suspend) {\r\ndev_err(&pdev->dev,\r\n"could not allocate memory for saving state\n");\r\ngoto exit_destroy_power_state;\r\n}\r\nrdebug.state_after_suspend = kzalloc(num_regulators, GFP_KERNEL);\r\nif (!rdebug.state_after_suspend) {\r\ndev_err(&pdev->dev,\r\n"could not allocate memory for saving state\n");\r\ngoto exit_free;\r\n}\r\ndbx500_regulator_testcase(regulator_info, num_regulators);\r\nreturn 0;\r\nexit_free:\r\nkfree(rdebug.state_before_suspend);\r\nexit_destroy_power_state:\r\ndebugfs_remove(rdebug.power_state_cnt_file);\r\nexit_destroy_status:\r\ndebugfs_remove(rdebug.status_file);\r\nexit_destroy_dir:\r\ndebugfs_remove(rdebug.dir);\r\nexit_no_debugfs:\r\ndev_err(&pdev->dev, "failed to create debugfs entries.\n");\r\nreturn -ENOMEM;\r\n}\r\nint ux500_regulator_debug_exit(void)\r\n{\r\ndebugfs_remove_recursive(rdebug.dir);\r\nkfree(rdebug.state_after_suspend);\r\nkfree(rdebug.state_before_suspend);\r\nreturn 0;\r\n}
