static int powernv_eeh_init(void)\r\n{\r\nif (!firmware_has_feature(FW_FEATURE_OPALv3)) {\r\npr_warning("%s: OPALv3 is required !\n", __func__);\r\nreturn -EINVAL;\r\n}\r\neeh_probe_mode_set(EEH_PROBE_MODE_DEV);\r\nreturn 0;\r\n}\r\nstatic int powernv_eeh_post_init(void)\r\n{\r\nstruct pci_controller *hose;\r\nstruct pnv_phb *phb;\r\nint ret = 0;\r\nlist_for_each_entry(hose, &hose_list, list_node) {\r\nphb = hose->private_data;\r\nif (phb->eeh_ops && phb->eeh_ops->post_init) {\r\nret = phb->eeh_ops->post_init(hose);\r\nif (ret)\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int powernv_eeh_dev_probe(struct pci_dev *dev, void *flag)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct device_node *dn = pci_device_to_OF_node(dev);\r\nstruct eeh_dev *edev = of_node_to_eeh_dev(dn);\r\nif (!dn || !edev || edev->pe)\r\nreturn 0;\r\nif ((dev->class >> 8) == PCI_CLASS_BRIDGE_ISA)\r\nreturn 0;\r\nedev->class_code = dev->class;\r\nedev->mode &= 0xFFFFFF00;\r\nif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE)\r\nedev->mode |= EEH_DEV_BRIDGE;\r\nif (pci_is_pcie(dev)) {\r\nedev->pcie_cap = pci_pcie_cap(dev);\r\nif (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT)\r\nedev->mode |= EEH_DEV_ROOT_PORT;\r\nelse if (pci_pcie_type(dev) == PCI_EXP_TYPE_DOWNSTREAM)\r\nedev->mode |= EEH_DEV_DS_PORT;\r\n}\r\nedev->config_addr = ((dev->bus->number << 8) | dev->devfn);\r\nedev->pe_config_addr = phb->bdfn_to_pe(phb, dev->bus, dev->devfn & 0xff);\r\neeh_add_to_parent_pe(edev);\r\nif (phb->type == PNV_PHB_IODA1)\r\neeh_subsystem_enabled = 1;\r\neeh_save_bars(edev);\r\nreturn 0;\r\n}\r\nstatic int powernv_eeh_set_option(struct eeh_pe *pe, int option)\r\n{\r\nstruct pci_controller *hose = pe->phb;\r\nstruct pnv_phb *phb = hose->private_data;\r\nint ret = -EEXIST;\r\nif (phb->eeh_ops && phb->eeh_ops->set_option)\r\nret = phb->eeh_ops->set_option(pe, option);\r\nreturn ret;\r\n}\r\nstatic int powernv_eeh_get_pe_addr(struct eeh_pe *pe)\r\n{\r\nreturn pe->addr;\r\n}\r\nstatic int powernv_eeh_get_state(struct eeh_pe *pe, int *delay)\r\n{\r\nstruct pci_controller *hose = pe->phb;\r\nstruct pnv_phb *phb = hose->private_data;\r\nint ret = EEH_STATE_NOT_SUPPORT;\r\nif (phb->eeh_ops && phb->eeh_ops->get_state) {\r\nret = phb->eeh_ops->get_state(pe);\r\nif (delay) {\r\n*delay = 0;\r\nif (ret & EEH_STATE_UNAVAILABLE)\r\n*delay = 1000;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int powernv_eeh_reset(struct eeh_pe *pe, int option)\r\n{\r\nstruct pci_controller *hose = pe->phb;\r\nstruct pnv_phb *phb = hose->private_data;\r\nint ret = -EEXIST;\r\nif (phb->eeh_ops && phb->eeh_ops->reset)\r\nret = phb->eeh_ops->reset(pe, option);\r\nreturn ret;\r\n}\r\nstatic int powernv_eeh_wait_state(struct eeh_pe *pe, int max_wait)\r\n{\r\nint ret;\r\nint mwait;\r\nwhile (1) {\r\nret = powernv_eeh_get_state(pe, &mwait);\r\nif (ret != EEH_STATE_UNAVAILABLE)\r\nreturn ret;\r\nmax_wait -= mwait;\r\nif (max_wait <= 0) {\r\npr_warning("%s: Timeout getting PE#%x's state (%d)\n",\r\n__func__, pe->addr, max_wait);\r\nreturn EEH_STATE_NOT_SUPPORT;\r\n}\r\nmsleep(mwait);\r\n}\r\nreturn EEH_STATE_NOT_SUPPORT;\r\n}\r\nstatic int powernv_eeh_get_log(struct eeh_pe *pe, int severity,\r\nchar *drv_log, unsigned long len)\r\n{\r\nstruct pci_controller *hose = pe->phb;\r\nstruct pnv_phb *phb = hose->private_data;\r\nint ret = -EEXIST;\r\nif (phb->eeh_ops && phb->eeh_ops->get_log)\r\nret = phb->eeh_ops->get_log(pe, severity, drv_log, len);\r\nreturn ret;\r\n}\r\nstatic int powernv_eeh_configure_bridge(struct eeh_pe *pe)\r\n{\r\nstruct pci_controller *hose = pe->phb;\r\nstruct pnv_phb *phb = hose->private_data;\r\nint ret = 0;\r\nif (phb->eeh_ops && phb->eeh_ops->configure_bridge)\r\nret = phb->eeh_ops->configure_bridge(pe);\r\nreturn ret;\r\n}\r\nstatic int powernv_eeh_next_error(struct eeh_pe **pe)\r\n{\r\nstruct pci_controller *hose;\r\nstruct pnv_phb *phb = NULL;\r\nlist_for_each_entry(hose, &hose_list, list_node) {\r\nphb = hose->private_data;\r\nbreak;\r\n}\r\nif (phb && phb->eeh_ops->next_error)\r\nreturn phb->eeh_ops->next_error(pe);\r\nreturn -EEXIST;\r\n}\r\nstatic int __init eeh_powernv_init(void)\r\n{\r\nint ret = -EINVAL;\r\nif (!machine_is(powernv))\r\nreturn ret;\r\nret = eeh_ops_register(&powernv_eeh_ops);\r\nif (!ret)\r\npr_info("EEH: PowerNV platform initialized\n");\r\nelse\r\npr_info("EEH: Failed to initialize PowerNV platform (%d)\n", ret);\r\nreturn ret;\r\n}
