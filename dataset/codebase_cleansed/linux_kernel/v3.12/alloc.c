uint8_t bch_inc_gen(struct cache *ca, struct bucket *b)\r\n{\r\nuint8_t ret = ++b->gen;\r\nca->set->need_gc = max(ca->set->need_gc, bucket_gc_gen(b));\r\nWARN_ON_ONCE(ca->set->need_gc > BUCKET_GC_GEN_MAX);\r\nif (CACHE_SYNC(&ca->set->sb)) {\r\nca->need_save_prio = max(ca->need_save_prio,\r\nbucket_disk_gen(b));\r\nWARN_ON_ONCE(ca->need_save_prio > BUCKET_DISK_GEN_MAX);\r\n}\r\nreturn ret;\r\n}\r\nvoid bch_rescale_priorities(struct cache_set *c, int sectors)\r\n{\r\nstruct cache *ca;\r\nstruct bucket *b;\r\nunsigned next = c->nbuckets * c->sb.bucket_size / 1024;\r\nunsigned i;\r\nint r;\r\natomic_sub(sectors, &c->rescale);\r\ndo {\r\nr = atomic_read(&c->rescale);\r\nif (r >= 0)\r\nreturn;\r\n} while (atomic_cmpxchg(&c->rescale, r, r + next) != r);\r\nmutex_lock(&c->bucket_lock);\r\nc->min_prio = USHRT_MAX;\r\nfor_each_cache(ca, c, i)\r\nfor_each_bucket(b, ca)\r\nif (b->prio &&\r\nb->prio != BTREE_PRIO &&\r\n!atomic_read(&b->pin)) {\r\nb->prio--;\r\nc->min_prio = min(c->min_prio, b->prio);\r\n}\r\nmutex_unlock(&c->bucket_lock);\r\n}\r\nstatic void discard_finish(struct work_struct *w)\r\n{\r\nstruct discard *d = container_of(w, struct discard, work);\r\nstruct cache *ca = d->ca;\r\nchar buf[BDEVNAME_SIZE];\r\nif (!test_bit(BIO_UPTODATE, &d->bio.bi_flags)) {\r\npr_notice("discard error on %s, disabling",\r\nbdevname(ca->bdev, buf));\r\nd->ca->discard = 0;\r\n}\r\nmutex_lock(&ca->set->bucket_lock);\r\nfifo_push(&ca->free, d->bucket);\r\nlist_add(&d->list, &ca->discards);\r\natomic_dec(&ca->discards_in_flight);\r\nmutex_unlock(&ca->set->bucket_lock);\r\nclosure_wake_up(&ca->set->bucket_wait);\r\nwake_up_process(ca->alloc_thread);\r\nclosure_put(&ca->set->cl);\r\n}\r\nstatic void discard_endio(struct bio *bio, int error)\r\n{\r\nstruct discard *d = container_of(bio, struct discard, bio);\r\nschedule_work(&d->work);\r\n}\r\nstatic void do_discard(struct cache *ca, long bucket)\r\n{\r\nstruct discard *d = list_first_entry(&ca->discards,\r\nstruct discard, list);\r\nlist_del(&d->list);\r\nd->bucket = bucket;\r\natomic_inc(&ca->discards_in_flight);\r\nclosure_get(&ca->set->cl);\r\nbio_init(&d->bio);\r\nd->bio.bi_sector = bucket_to_sector(ca->set, d->bucket);\r\nd->bio.bi_bdev = ca->bdev;\r\nd->bio.bi_rw = REQ_WRITE|REQ_DISCARD;\r\nd->bio.bi_max_vecs = 1;\r\nd->bio.bi_io_vec = d->bio.bi_inline_vecs;\r\nd->bio.bi_size = bucket_bytes(ca);\r\nd->bio.bi_end_io = discard_endio;\r\nbio_set_prio(&d->bio, IOPRIO_PRIO_VALUE(IOPRIO_CLASS_IDLE, 0));\r\nsubmit_bio(0, &d->bio);\r\n}\r\nstatic inline bool can_inc_bucket_gen(struct bucket *b)\r\n{\r\nreturn bucket_gc_gen(b) < BUCKET_GC_GEN_MAX &&\r\nbucket_disk_gen(b) < BUCKET_DISK_GEN_MAX;\r\n}\r\nbool bch_bucket_add_unused(struct cache *ca, struct bucket *b)\r\n{\r\nBUG_ON(GC_MARK(b) || GC_SECTORS_USED(b));\r\nif (fifo_used(&ca->free) > ca->watermark[WATERMARK_MOVINGGC] &&\r\nCACHE_REPLACEMENT(&ca->sb) == CACHE_REPLACEMENT_FIFO)\r\nreturn false;\r\nb->prio = 0;\r\nif (can_inc_bucket_gen(b) &&\r\nfifo_push(&ca->unused, b - ca->buckets)) {\r\natomic_inc(&b->pin);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool can_invalidate_bucket(struct cache *ca, struct bucket *b)\r\n{\r\nreturn GC_MARK(b) == GC_MARK_RECLAIMABLE &&\r\n!atomic_read(&b->pin) &&\r\ncan_inc_bucket_gen(b);\r\n}\r\nstatic void invalidate_one_bucket(struct cache *ca, struct bucket *b)\r\n{\r\nbch_inc_gen(ca, b);\r\nb->prio = INITIAL_PRIO;\r\natomic_inc(&b->pin);\r\nfifo_push(&ca->free_inc, b - ca->buckets);\r\n}\r\nstatic void invalidate_buckets_lru(struct cache *ca)\r\n{\r\nstruct bucket *b;\r\nssize_t i;\r\nca->heap.used = 0;\r\nfor_each_bucket(b, ca) {\r\nif (fifo_full(&ca->unused))\r\nreturn;\r\nif (!can_invalidate_bucket(ca, b))\r\ncontinue;\r\nif (!GC_SECTORS_USED(b) &&\r\nbch_bucket_add_unused(ca, b))\r\ncontinue;\r\nif (!heap_full(&ca->heap))\r\nheap_add(&ca->heap, b, bucket_max_cmp);\r\nelse if (bucket_max_cmp(b, heap_peek(&ca->heap))) {\r\nca->heap.data[0] = b;\r\nheap_sift(&ca->heap, 0, bucket_max_cmp);\r\n}\r\n}\r\nfor (i = ca->heap.used / 2 - 1; i >= 0; --i)\r\nheap_sift(&ca->heap, i, bucket_min_cmp);\r\nwhile (!fifo_full(&ca->free_inc)) {\r\nif (!heap_pop(&ca->heap, b, bucket_min_cmp)) {\r\nca->invalidate_needs_gc = 1;\r\nbch_queue_gc(ca->set);\r\nreturn;\r\n}\r\ninvalidate_one_bucket(ca, b);\r\n}\r\n}\r\nstatic void invalidate_buckets_fifo(struct cache *ca)\r\n{\r\nstruct bucket *b;\r\nsize_t checked = 0;\r\nwhile (!fifo_full(&ca->free_inc)) {\r\nif (ca->fifo_last_bucket < ca->sb.first_bucket ||\r\nca->fifo_last_bucket >= ca->sb.nbuckets)\r\nca->fifo_last_bucket = ca->sb.first_bucket;\r\nb = ca->buckets + ca->fifo_last_bucket++;\r\nif (can_invalidate_bucket(ca, b))\r\ninvalidate_one_bucket(ca, b);\r\nif (++checked >= ca->sb.nbuckets) {\r\nca->invalidate_needs_gc = 1;\r\nbch_queue_gc(ca->set);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void invalidate_buckets_random(struct cache *ca)\r\n{\r\nstruct bucket *b;\r\nsize_t checked = 0;\r\nwhile (!fifo_full(&ca->free_inc)) {\r\nsize_t n;\r\nget_random_bytes(&n, sizeof(n));\r\nn %= (size_t) (ca->sb.nbuckets - ca->sb.first_bucket);\r\nn += ca->sb.first_bucket;\r\nb = ca->buckets + n;\r\nif (can_invalidate_bucket(ca, b))\r\ninvalidate_one_bucket(ca, b);\r\nif (++checked >= ca->sb.nbuckets / 2) {\r\nca->invalidate_needs_gc = 1;\r\nbch_queue_gc(ca->set);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void invalidate_buckets(struct cache *ca)\r\n{\r\nif (ca->invalidate_needs_gc)\r\nreturn;\r\nswitch (CACHE_REPLACEMENT(&ca->sb)) {\r\ncase CACHE_REPLACEMENT_LRU:\r\ninvalidate_buckets_lru(ca);\r\nbreak;\r\ncase CACHE_REPLACEMENT_FIFO:\r\ninvalidate_buckets_fifo(ca);\r\nbreak;\r\ncase CACHE_REPLACEMENT_RANDOM:\r\ninvalidate_buckets_random(ca);\r\nbreak;\r\n}\r\ntrace_bcache_alloc_invalidate(ca);\r\n}\r\nstatic int bch_allocator_thread(void *arg)\r\n{\r\nstruct cache *ca = arg;\r\nmutex_lock(&ca->set->bucket_lock);\r\nwhile (1) {\r\nwhile (1) {\r\nlong bucket;\r\nif ((!atomic_read(&ca->set->prio_blocked) ||\r\n!CACHE_SYNC(&ca->set->sb)) &&\r\n!fifo_empty(&ca->unused))\r\nfifo_pop(&ca->unused, bucket);\r\nelse if (!fifo_empty(&ca->free_inc))\r\nfifo_pop(&ca->free_inc, bucket);\r\nelse\r\nbreak;\r\nallocator_wait(ca, (int) fifo_free(&ca->free) >\r\natomic_read(&ca->discards_in_flight));\r\nif (ca->discard) {\r\nallocator_wait(ca, !list_empty(&ca->discards));\r\ndo_discard(ca, bucket);\r\n} else {\r\nfifo_push(&ca->free, bucket);\r\nclosure_wake_up(&ca->set->bucket_wait);\r\n}\r\n}\r\nallocator_wait(ca, ca->set->gc_mark_valid &&\r\n(ca->need_save_prio > 64 ||\r\n!ca->invalidate_needs_gc));\r\ninvalidate_buckets(ca);\r\nallocator_wait(ca, !atomic_read(&ca->set->prio_blocked));\r\nif (CACHE_SYNC(&ca->set->sb) &&\r\n(!fifo_empty(&ca->free_inc) ||\r\nca->need_save_prio > 64))\r\nbch_prio_write(ca);\r\n}\r\n}\r\nlong bch_bucket_alloc(struct cache *ca, unsigned watermark, struct closure *cl)\r\n{\r\nlong r = -1;\r\nagain:\r\nwake_up_process(ca->alloc_thread);\r\nif (fifo_used(&ca->free) > ca->watermark[watermark] &&\r\nfifo_pop(&ca->free, r)) {\r\nstruct bucket *b = ca->buckets + r;\r\n#ifdef CONFIG_BCACHE_EDEBUG\r\nsize_t iter;\r\nlong i;\r\nfor (iter = 0; iter < prio_buckets(ca) * 2; iter++)\r\nBUG_ON(ca->prio_buckets[iter] == (uint64_t) r);\r\nfifo_for_each(i, &ca->free, iter)\r\nBUG_ON(i == r);\r\nfifo_for_each(i, &ca->free_inc, iter)\r\nBUG_ON(i == r);\r\nfifo_for_each(i, &ca->unused, iter)\r\nBUG_ON(i == r);\r\n#endif\r\nBUG_ON(atomic_read(&b->pin) != 1);\r\nSET_GC_SECTORS_USED(b, ca->sb.bucket_size);\r\nif (watermark <= WATERMARK_METADATA) {\r\nSET_GC_MARK(b, GC_MARK_METADATA);\r\nb->prio = BTREE_PRIO;\r\n} else {\r\nSET_GC_MARK(b, GC_MARK_RECLAIMABLE);\r\nb->prio = INITIAL_PRIO;\r\n}\r\nreturn r;\r\n}\r\ntrace_bcache_alloc_fail(ca);\r\nif (cl) {\r\nclosure_wait(&ca->set->bucket_wait, cl);\r\nif (closure_blocking(cl)) {\r\nmutex_unlock(&ca->set->bucket_lock);\r\nclosure_sync(cl);\r\nmutex_lock(&ca->set->bucket_lock);\r\ngoto again;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nvoid bch_bucket_free(struct cache_set *c, struct bkey *k)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < KEY_PTRS(k); i++) {\r\nstruct bucket *b = PTR_BUCKET(c, k, i);\r\nSET_GC_MARK(b, GC_MARK_RECLAIMABLE);\r\nSET_GC_SECTORS_USED(b, 0);\r\nbch_bucket_add_unused(PTR_CACHE(c, k, i), b);\r\n}\r\n}\r\nint __bch_bucket_alloc_set(struct cache_set *c, unsigned watermark,\r\nstruct bkey *k, int n, struct closure *cl)\r\n{\r\nint i;\r\nlockdep_assert_held(&c->bucket_lock);\r\nBUG_ON(!n || n > c->caches_loaded || n > 8);\r\nbkey_init(k);\r\nfor (i = 0; i < n; i++) {\r\nstruct cache *ca = c->cache_by_alloc[i];\r\nlong b = bch_bucket_alloc(ca, watermark, cl);\r\nif (b == -1)\r\ngoto err;\r\nk->ptr[i] = PTR(ca->buckets[b].gen,\r\nbucket_to_sector(c, b),\r\nca->sb.nr_this_dev);\r\nSET_KEY_PTRS(k, i + 1);\r\n}\r\nreturn 0;\r\nerr:\r\nbch_bucket_free(c, k);\r\n__bkey_put(c, k);\r\nreturn -1;\r\n}\r\nint bch_bucket_alloc_set(struct cache_set *c, unsigned watermark,\r\nstruct bkey *k, int n, struct closure *cl)\r\n{\r\nint ret;\r\nmutex_lock(&c->bucket_lock);\r\nret = __bch_bucket_alloc_set(c, watermark, k, n, cl);\r\nmutex_unlock(&c->bucket_lock);\r\nreturn ret;\r\n}\r\nint bch_cache_allocator_start(struct cache *ca)\r\n{\r\nstruct task_struct *k = kthread_run(bch_allocator_thread,\r\nca, "bcache_allocator");\r\nif (IS_ERR(k))\r\nreturn PTR_ERR(k);\r\nca->alloc_thread = k;\r\nreturn 0;\r\n}\r\nvoid bch_cache_allocator_exit(struct cache *ca)\r\n{\r\nstruct discard *d;\r\nwhile (!list_empty(&ca->discards)) {\r\nd = list_first_entry(&ca->discards, struct discard, list);\r\ncancel_work_sync(&d->work);\r\nlist_del(&d->list);\r\nkfree(d);\r\n}\r\n}\r\nint bch_cache_allocator_init(struct cache *ca)\r\n{\r\nunsigned i;\r\nca->watermark[WATERMARK_PRIO] = 0;\r\nca->watermark[WATERMARK_METADATA] = prio_buckets(ca);\r\nca->watermark[WATERMARK_MOVINGGC] = 8 +\r\nca->watermark[WATERMARK_METADATA];\r\nca->watermark[WATERMARK_NONE] = ca->free.size / 2 +\r\nca->watermark[WATERMARK_MOVINGGC];\r\nfor (i = 0; i < MAX_IN_FLIGHT_DISCARDS; i++) {\r\nstruct discard *d = kzalloc(sizeof(*d), GFP_KERNEL);\r\nif (!d)\r\nreturn -ENOMEM;\r\nd->ca = ca;\r\nINIT_WORK(&d->work, discard_finish);\r\nlist_add(&d->list, &ca->discards);\r\n}\r\nreturn 0;\r\n}
