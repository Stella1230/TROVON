void efuse_initialize(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 bytetemp;\r\nu8 temp;\r\nbytetemp = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[SYS_FUNC_EN] + 1);\r\ntemp = bytetemp | 0x20;\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[SYS_FUNC_EN] + 1, temp);\r\nbytetemp = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[SYS_ISO_CTRL] + 1);\r\ntemp = bytetemp & 0xFE;\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[SYS_ISO_CTRL] + 1, temp);\r\nbytetemp = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_TEST] + 3);\r\ntemp = bytetemp | 0x80;\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_TEST] + 3, temp);\r\nrtl_write_byte(rtlpriv, 0x2F8, 0x3);\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 3, 0x72);\r\n}\r\nu8 efuse_read_1byte(struct ieee80211_hw *hw, u16 address)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 data;\r\nu8 bytetemp;\r\nu8 temp;\r\nu32 k = 0;\r\nconst u32 efuse_len =\r\nrtlpriv->cfg->maps[EFUSE_REAL_CONTENT_SIZE];\r\nif (address < efuse_len) {\r\ntemp = address & 0xFF;\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 1,\r\ntemp);\r\nbytetemp = rtl_read_byte(rtlpriv,\r\nrtlpriv->cfg->maps[EFUSE_CTRL] + 2);\r\ntemp = ((address >> 8) & 0x03) | (bytetemp & 0xFC);\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 2,\r\ntemp);\r\nbytetemp = rtl_read_byte(rtlpriv,\r\nrtlpriv->cfg->maps[EFUSE_CTRL] + 3);\r\ntemp = bytetemp & 0x7F;\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 3,\r\ntemp);\r\nbytetemp = rtl_read_byte(rtlpriv,\r\nrtlpriv->cfg->maps[EFUSE_CTRL] + 3);\r\nwhile (!(bytetemp & 0x80)) {\r\nbytetemp = rtl_read_byte(rtlpriv,\r\nrtlpriv->cfg->\r\nmaps[EFUSE_CTRL] + 3);\r\nk++;\r\nif (k == 1000) {\r\nk = 0;\r\nbreak;\r\n}\r\n}\r\ndata = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]);\r\nreturn data;\r\n} else\r\nreturn 0xFF;\r\n}\r\nvoid efuse_write_1byte(struct ieee80211_hw *hw, u16 address, u8 value)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 bytetemp;\r\nu8 temp;\r\nu32 k = 0;\r\nconst u32 efuse_len =\r\nrtlpriv->cfg->maps[EFUSE_REAL_CONTENT_SIZE];\r\nRT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "Addr=%x Data =%x\n",\r\naddress, value);\r\nif (address < efuse_len) {\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL], value);\r\ntemp = address & 0xFF;\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 1,\r\ntemp);\r\nbytetemp = rtl_read_byte(rtlpriv,\r\nrtlpriv->cfg->maps[EFUSE_CTRL] + 2);\r\ntemp = ((address >> 8) & 0x03) | (bytetemp & 0xFC);\r\nrtl_write_byte(rtlpriv,\r\nrtlpriv->cfg->maps[EFUSE_CTRL] + 2, temp);\r\nbytetemp = rtl_read_byte(rtlpriv,\r\nrtlpriv->cfg->maps[EFUSE_CTRL] + 3);\r\ntemp = bytetemp | 0x80;\r\nrtl_write_byte(rtlpriv,\r\nrtlpriv->cfg->maps[EFUSE_CTRL] + 3, temp);\r\nbytetemp = rtl_read_byte(rtlpriv,\r\nrtlpriv->cfg->maps[EFUSE_CTRL] + 3);\r\nwhile (bytetemp & 0x80) {\r\nbytetemp = rtl_read_byte(rtlpriv,\r\nrtlpriv->cfg->\r\nmaps[EFUSE_CTRL] + 3);\r\nk++;\r\nif (k == 100) {\r\nk = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nvoid read_efuse_byte(struct ieee80211_hw *hw, u16 _offset, u8 *pbuf)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 value32;\r\nu8 readbyte;\r\nu16 retry;\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 1,\r\n(_offset & 0xff));\r\nreadbyte = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 2);\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 2,\r\n((_offset >> 8) & 0x03) | (readbyte & 0xfc));\r\nreadbyte = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 3);\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 3,\r\n(readbyte & 0x7f));\r\nretry = 0;\r\nvalue32 = rtl_read_dword(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]);\r\nwhile (!(((value32 >> 24) & 0xff) & 0x80) && (retry < 10000)) {\r\nvalue32 = rtl_read_dword(rtlpriv,\r\nrtlpriv->cfg->maps[EFUSE_CTRL]);\r\nretry++;\r\n}\r\nudelay(50);\r\nvalue32 = rtl_read_dword(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]);\r\n*pbuf = (u8) (value32 & 0xff);\r\n}\r\nvoid read_efuse(struct ieee80211_hw *hw, u16 _offset, u16 _size_byte, u8 *pbuf)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nu8 *efuse_tbl;\r\nu8 rtemp8[1];\r\nu16 efuse_addr = 0;\r\nu8 offset, wren;\r\nu8 u1temp = 0;\r\nu16 i;\r\nu16 j;\r\nconst u16 efuse_max_section =\r\nrtlpriv->cfg->maps[EFUSE_MAX_SECTION_MAP];\r\nconst u32 efuse_len =\r\nrtlpriv->cfg->maps[EFUSE_REAL_CONTENT_SIZE];\r\nu16 **efuse_word;\r\nu16 efuse_utilized = 0;\r\nu8 efuse_usage;\r\nif ((_offset + _size_byte) > rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]) {\r\nRT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD,\r\n"read_efuse(): Invalid offset(%#x) with read bytes(%#x)!!\n",\r\n_offset, _size_byte);\r\nreturn;\r\n}\r\nefuse_tbl = kmalloc(rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE] *\r\nsizeof(u8), GFP_ATOMIC);\r\nif (!efuse_tbl)\r\nreturn;\r\nefuse_word = kmalloc(EFUSE_MAX_WORD_UNIT * sizeof(u16 *), GFP_ATOMIC);\r\nif (!efuse_word)\r\ngoto done;\r\nfor (i = 0; i < EFUSE_MAX_WORD_UNIT; i++) {\r\nefuse_word[i] = kmalloc(efuse_max_section * sizeof(u16),\r\nGFP_ATOMIC);\r\nif (!efuse_word[i])\r\ngoto done;\r\n}\r\nfor (i = 0; i < efuse_max_section; i++)\r\nfor (j = 0; j < EFUSE_MAX_WORD_UNIT; j++)\r\nefuse_word[j][i] = 0xFFFF;\r\nread_efuse_byte(hw, efuse_addr, rtemp8);\r\nif (*rtemp8 != 0xFF) {\r\nefuse_utilized++;\r\nRTPRINT(rtlpriv, FEEPROM, EFUSE_READ_ALL,\r\n"Addr=%d\n", efuse_addr);\r\nefuse_addr++;\r\n}\r\nwhile ((*rtemp8 != 0xFF) && (efuse_addr < efuse_len)) {\r\nif ((*rtemp8 & 0x1F) == 0x0F) {\r\nu1temp = ((*rtemp8 & 0xE0) >> 5);\r\nread_efuse_byte(hw, efuse_addr, rtemp8);\r\nif ((*rtemp8 & 0x0F) == 0x0F) {\r\nefuse_addr++;\r\nread_efuse_byte(hw, efuse_addr, rtemp8);\r\nif (*rtemp8 != 0xFF &&\r\n(efuse_addr < efuse_len)) {\r\nefuse_addr++;\r\n}\r\ncontinue;\r\n} else {\r\noffset = ((*rtemp8 & 0xF0) >> 1) | u1temp;\r\nwren = (*rtemp8 & 0x0F);\r\nefuse_addr++;\r\n}\r\n} else {\r\noffset = ((*rtemp8 >> 4) & 0x0f);\r\nwren = (*rtemp8 & 0x0f);\r\n}\r\nif (offset < efuse_max_section) {\r\nRTPRINT(rtlpriv, FEEPROM, EFUSE_READ_ALL,\r\n"offset-%d Worden=%x\n", offset, wren);\r\nfor (i = 0; i < EFUSE_MAX_WORD_UNIT; i++) {\r\nif (!(wren & 0x01)) {\r\nRTPRINT(rtlpriv, FEEPROM,\r\nEFUSE_READ_ALL,\r\n"Addr=%d\n", efuse_addr);\r\nread_efuse_byte(hw, efuse_addr, rtemp8);\r\nefuse_addr++;\r\nefuse_utilized++;\r\nefuse_word[i][offset] =\r\n(*rtemp8 & 0xff);\r\nif (efuse_addr >= efuse_len)\r\nbreak;\r\nRTPRINT(rtlpriv, FEEPROM,\r\nEFUSE_READ_ALL,\r\n"Addr=%d\n", efuse_addr);\r\nread_efuse_byte(hw, efuse_addr, rtemp8);\r\nefuse_addr++;\r\nefuse_utilized++;\r\nefuse_word[i][offset] |=\r\n(((u16)*rtemp8 << 8) & 0xff00);\r\nif (efuse_addr >= efuse_len)\r\nbreak;\r\n}\r\nwren >>= 1;\r\n}\r\n}\r\nRTPRINT(rtlpriv, FEEPROM, EFUSE_READ_ALL,\r\n"Addr=%d\n", efuse_addr);\r\nread_efuse_byte(hw, efuse_addr, rtemp8);\r\nif (*rtemp8 != 0xFF && (efuse_addr < efuse_len)) {\r\nefuse_utilized++;\r\nefuse_addr++;\r\n}\r\n}\r\nfor (i = 0; i < efuse_max_section; i++) {\r\nfor (j = 0; j < EFUSE_MAX_WORD_UNIT; j++) {\r\nefuse_tbl[(i * 8) + (j * 2)] =\r\n(efuse_word[j][i] & 0xff);\r\nefuse_tbl[(i * 8) + ((j * 2) + 1)] =\r\n((efuse_word[j][i] >> 8) & 0xff);\r\n}\r\n}\r\nfor (i = 0; i < _size_byte; i++)\r\npbuf[i] = efuse_tbl[_offset + i];\r\nrtlefuse->efuse_usedbytes = efuse_utilized;\r\nefuse_usage = (u8) ((efuse_utilized * 100) / efuse_len);\r\nrtlefuse->efuse_usedpercentage = efuse_usage;\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_EFUSE_BYTES,\r\n(u8 *)&efuse_utilized);\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_EFUSE_USAGE,\r\n&efuse_usage);\r\ndone:\r\nfor (i = 0; i < EFUSE_MAX_WORD_UNIT; i++)\r\nkfree(efuse_word[i]);\r\nkfree(efuse_word);\r\nkfree(efuse_tbl);\r\n}\r\nbool efuse_shadow_update_chk(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nu8 section_idx, i, Base;\r\nu16 words_need = 0, hdr_num = 0, totalbytes, efuse_used;\r\nbool wordchanged, result = true;\r\nfor (section_idx = 0; section_idx < 16; section_idx++) {\r\nBase = section_idx * 8;\r\nwordchanged = false;\r\nfor (i = 0; i < 8; i = i + 2) {\r\nif ((rtlefuse->efuse_map[EFUSE_INIT_MAP][Base + i] !=\r\nrtlefuse->efuse_map[EFUSE_MODIFY_MAP][Base + i]) ||\r\n(rtlefuse->efuse_map[EFUSE_INIT_MAP][Base + i + 1] !=\r\nrtlefuse->efuse_map[EFUSE_MODIFY_MAP][Base + i +\r\n1])) {\r\nwords_need++;\r\nwordchanged = true;\r\n}\r\n}\r\nif (wordchanged)\r\nhdr_num++;\r\n}\r\ntotalbytes = hdr_num + words_need * 2;\r\nefuse_used = rtlefuse->efuse_usedbytes;\r\nif ((totalbytes + efuse_used) >=\r\n(EFUSE_MAX_SIZE -\r\nrtlpriv->cfg->maps[EFUSE_OOB_PROTECT_BYTES_LEN]))\r\nresult = false;\r\nRT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD,\r\n"efuse_shadow_update_chk(): totalbytes(%#x), hdr_num(%#x), words_need(%#x), efuse_used(%d)\n",\r\ntotalbytes, hdr_num, words_need, efuse_used);\r\nreturn result;\r\n}\r\nvoid efuse_shadow_read(struct ieee80211_hw *hw, u8 type,\r\nu16 offset, u32 *value)\r\n{\r\nif (type == 1)\r\nefuse_shadow_read_1byte(hw, offset, (u8 *) value);\r\nelse if (type == 2)\r\nefuse_shadow_read_2byte(hw, offset, (u16 *) value);\r\nelse if (type == 4)\r\nefuse_shadow_read_4byte(hw, offset, value);\r\n}\r\nvoid efuse_shadow_write(struct ieee80211_hw *hw, u8 type, u16 offset,\r\nu32 value)\r\n{\r\nif (type == 1)\r\nefuse_shadow_write_1byte(hw, offset, (u8) value);\r\nelse if (type == 2)\r\nefuse_shadow_write_2byte(hw, offset, (u16) value);\r\nelse if (type == 4)\r\nefuse_shadow_write_4byte(hw, offset, value);\r\n}\r\nbool efuse_shadow_update(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nu16 i, offset, base;\r\nu8 word_en = 0x0F;\r\nu8 first_pg = false;\r\nRT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "--->\n");\r\nif (!efuse_shadow_update_chk(hw)) {\r\nefuse_read_all_map(hw, &rtlefuse->efuse_map[EFUSE_INIT_MAP][0]);\r\nmemcpy(&rtlefuse->efuse_map[EFUSE_MODIFY_MAP][0],\r\n&rtlefuse->efuse_map[EFUSE_INIT_MAP][0],\r\nrtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]);\r\nRT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD,\r\n"<---efuse out of capacity!!\n");\r\nreturn false;\r\n}\r\nefuse_power_switch(hw, true, true);\r\nfor (offset = 0; offset < 16; offset++) {\r\nword_en = 0x0F;\r\nbase = offset * 8;\r\nfor (i = 0; i < 8; i++) {\r\nif (first_pg) {\r\nword_en &= ~(BIT(i / 2));\r\nrtlefuse->efuse_map[EFUSE_INIT_MAP][base + i] =\r\nrtlefuse->efuse_map[EFUSE_MODIFY_MAP][base + i];\r\n} else {\r\nif (rtlefuse->efuse_map[EFUSE_INIT_MAP][base + i] !=\r\nrtlefuse->efuse_map[EFUSE_MODIFY_MAP][base + i]) {\r\nword_en &= ~(BIT(i / 2));\r\nrtlefuse->efuse_map[EFUSE_INIT_MAP][base + i] =\r\nrtlefuse->efuse_map[EFUSE_MODIFY_MAP][base + i];\r\n}\r\n}\r\n}\r\nif (word_en != 0x0F) {\r\nu8 tmpdata[8];\r\nmemcpy(tmpdata,\r\n&rtlefuse->efuse_map[EFUSE_MODIFY_MAP][base],\r\n8);\r\nRT_PRINT_DATA(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"U-efuse", tmpdata, 8);\r\nif (!efuse_pg_packet_write(hw, (u8) offset, word_en,\r\ntmpdata)) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,\r\n"PG section(%#x) fail!!\n", offset);\r\nbreak;\r\n}\r\n}\r\n}\r\nefuse_power_switch(hw, true, false);\r\nefuse_read_all_map(hw, &rtlefuse->efuse_map[EFUSE_INIT_MAP][0]);\r\nmemcpy(&rtlefuse->efuse_map[EFUSE_MODIFY_MAP][0],\r\n&rtlefuse->efuse_map[EFUSE_INIT_MAP][0],\r\nrtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]);\r\nRT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "<---\n");\r\nreturn true;\r\n}\r\nvoid rtl_efuse_shadow_map_update(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nif (rtlefuse->autoload_failflag)\r\nmemset(&rtlefuse->efuse_map[EFUSE_INIT_MAP][0], 0xFF,\r\nrtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]);\r\nelse\r\nefuse_read_all_map(hw, &rtlefuse->efuse_map[EFUSE_INIT_MAP][0]);\r\nmemcpy(&rtlefuse->efuse_map[EFUSE_MODIFY_MAP][0],\r\n&rtlefuse->efuse_map[EFUSE_INIT_MAP][0],\r\nrtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]);\r\n}\r\nvoid efuse_force_write_vendor_Id(struct ieee80211_hw *hw)\r\n{\r\nu8 tmpdata[8] = { 0xFF, 0xFF, 0xEC, 0x10, 0xFF, 0xFF, 0xFF, 0xFF };\r\nefuse_power_switch(hw, true, true);\r\nefuse_pg_packet_write(hw, 1, 0xD, tmpdata);\r\nefuse_power_switch(hw, true, false);\r\n}\r\nvoid efuse_re_pg_section(struct ieee80211_hw *hw, u8 section_idx)\r\n{\r\n}\r\nstatic void efuse_shadow_read_1byte(struct ieee80211_hw *hw,\r\nu16 offset, u8 *value)\r\n{\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\n*value = rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset];\r\n}\r\nstatic void efuse_shadow_read_2byte(struct ieee80211_hw *hw,\r\nu16 offset, u16 *value)\r\n{\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\n*value = rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset];\r\n*value |= rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 1] << 8;\r\n}\r\nstatic void efuse_shadow_read_4byte(struct ieee80211_hw *hw,\r\nu16 offset, u32 *value)\r\n{\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\n*value = rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset];\r\n*value |= rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 1] << 8;\r\n*value |= rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 2] << 16;\r\n*value |= rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 3] << 24;\r\n}\r\nstatic void efuse_shadow_write_1byte(struct ieee80211_hw *hw,\r\nu16 offset, u8 value)\r\n{\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nrtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset] = value;\r\n}\r\nstatic void efuse_shadow_write_2byte(struct ieee80211_hw *hw,\r\nu16 offset, u16 value)\r\n{\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nrtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset] = value & 0x00FF;\r\nrtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 1] = value >> 8;\r\n}\r\nstatic void efuse_shadow_write_4byte(struct ieee80211_hw *hw,\r\nu16 offset, u32 value)\r\n{\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nrtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset] =\r\n(u8) (value & 0x000000FF);\r\nrtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 1] =\r\n(u8) ((value >> 8) & 0x0000FF);\r\nrtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 2] =\r\n(u8) ((value >> 16) & 0x00FF);\r\nrtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 3] =\r\n(u8) ((value >> 24) & 0xFF);\r\n}\r\nstatic int efuse_one_byte_read(struct ieee80211_hw *hw, u16 addr, u8 *data)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 tmpidx = 0;\r\nint result;\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 1,\r\n(u8) (addr & 0xff));\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 2,\r\n((u8) ((addr >> 8) & 0x03)) |\r\n(rtl_read_byte(rtlpriv,\r\nrtlpriv->cfg->maps[EFUSE_CTRL] + 2) &\r\n0xFC));\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 3, 0x72);\r\nwhile (!(0x80 & rtl_read_byte(rtlpriv,\r\nrtlpriv->cfg->maps[EFUSE_CTRL] + 3))\r\n&& (tmpidx < 100)) {\r\ntmpidx++;\r\n}\r\nif (tmpidx < 100) {\r\n*data = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]);\r\nresult = true;\r\n} else {\r\n*data = 0xff;\r\nresult = false;\r\n}\r\nreturn result;\r\n}\r\nstatic int efuse_one_byte_write(struct ieee80211_hw *hw, u16 addr, u8 data)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 tmpidx = 0;\r\nRT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "Addr = %x Data=%x\n",\r\naddr, data);\r\nrtl_write_byte(rtlpriv,\r\nrtlpriv->cfg->maps[EFUSE_CTRL] + 1, (u8) (addr & 0xff));\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 2,\r\n(rtl_read_byte(rtlpriv,\r\nrtlpriv->cfg->maps[EFUSE_CTRL] +\r\n2) & 0xFC) | (u8) ((addr >> 8) & 0x03));\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL], data);\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 3, 0xF2);\r\nwhile ((0x80 & rtl_read_byte(rtlpriv,\r\nrtlpriv->cfg->maps[EFUSE_CTRL] + 3))\r\n&& (tmpidx < 100)) {\r\ntmpidx++;\r\n}\r\nif (tmpidx < 100)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void efuse_read_all_map(struct ieee80211_hw *hw, u8 * efuse)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nefuse_power_switch(hw, false, true);\r\nread_efuse(hw, 0, rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE], efuse);\r\nefuse_power_switch(hw, false, false);\r\n}\r\nstatic void efuse_read_data_case1(struct ieee80211_hw *hw, u16 *efuse_addr,\r\nu8 efuse_data, u8 offset, u8 *tmpdata,\r\nu8 *readstate)\r\n{\r\nbool dataempty = true;\r\nu8 hoffset;\r\nu8 tmpidx;\r\nu8 hworden;\r\nu8 word_cnts;\r\nhoffset = (efuse_data >> 4) & 0x0F;\r\nhworden = efuse_data & 0x0F;\r\nword_cnts = efuse_calculate_word_cnts(hworden);\r\nif (hoffset == offset) {\r\nfor (tmpidx = 0; tmpidx < word_cnts * 2; tmpidx++) {\r\nif (efuse_one_byte_read(hw, *efuse_addr + 1 + tmpidx,\r\n&efuse_data)) {\r\ntmpdata[tmpidx] = efuse_data;\r\nif (efuse_data != 0xff)\r\ndataempty = true;\r\n}\r\n}\r\nif (dataempty) {\r\n*readstate = PG_STATE_DATA;\r\n} else {\r\n*efuse_addr = *efuse_addr + (word_cnts * 2) + 1;\r\n*readstate = PG_STATE_HEADER;\r\n}\r\n} else {\r\n*efuse_addr = *efuse_addr + (word_cnts * 2) + 1;\r\n*readstate = PG_STATE_HEADER;\r\n}\r\n}\r\nstatic int efuse_pg_packet_read(struct ieee80211_hw *hw, u8 offset, u8 *data)\r\n{\r\nu8 readstate = PG_STATE_HEADER;\r\nbool continual = true;\r\nu8 efuse_data, word_cnts = 0;\r\nu16 efuse_addr = 0;\r\nu8 tmpdata[8];\r\nif (data == NULL)\r\nreturn false;\r\nif (offset > 15)\r\nreturn false;\r\nmemset(data, 0xff, PGPKT_DATA_SIZE * sizeof(u8));\r\nmemset(tmpdata, 0xff, PGPKT_DATA_SIZE * sizeof(u8));\r\nwhile (continual && (efuse_addr < EFUSE_MAX_SIZE)) {\r\nif (readstate & PG_STATE_HEADER) {\r\nif (efuse_one_byte_read(hw, efuse_addr, &efuse_data)\r\n&& (efuse_data != 0xFF))\r\nefuse_read_data_case1(hw, &efuse_addr,\r\nefuse_data,\r\noffset, tmpdata,\r\n&readstate);\r\nelse\r\ncontinual = false;\r\n} else if (readstate & PG_STATE_DATA) {\r\nefuse_word_enable_data_read(0, tmpdata, data);\r\nefuse_addr = efuse_addr + (word_cnts * 2) + 1;\r\nreadstate = PG_STATE_HEADER;\r\n}\r\n}\r\nif ((data[0] == 0xff) && (data[1] == 0xff) &&\r\n(data[2] == 0xff) && (data[3] == 0xff) &&\r\n(data[4] == 0xff) && (data[5] == 0xff) &&\r\n(data[6] == 0xff) && (data[7] == 0xff))\r\nreturn false;\r\nelse\r\nreturn true;\r\n}\r\nstatic void efuse_write_data_case1(struct ieee80211_hw *hw, u16 *efuse_addr,\r\nu8 efuse_data, u8 offset, int *continual,\r\nu8 *write_state, struct pgpkt_struct *target_pkt,\r\nint *repeat_times, int *result, u8 word_en)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct pgpkt_struct tmp_pkt;\r\nbool dataempty = true;\r\nu8 originaldata[8 * sizeof(u8)];\r\nu8 badworden = 0x0F;\r\nu8 match_word_en, tmp_word_en;\r\nu8 tmpindex;\r\nu8 tmp_header = efuse_data;\r\nu8 tmp_word_cnts;\r\ntmp_pkt.offset = (tmp_header >> 4) & 0x0F;\r\ntmp_pkt.word_en = tmp_header & 0x0F;\r\ntmp_word_cnts = efuse_calculate_word_cnts(tmp_pkt.word_en);\r\nif (tmp_pkt.offset != target_pkt->offset) {\r\n*efuse_addr = *efuse_addr + (tmp_word_cnts * 2) + 1;\r\n*write_state = PG_STATE_HEADER;\r\n} else {\r\nfor (tmpindex = 0; tmpindex < (tmp_word_cnts * 2); tmpindex++) {\r\nu16 address = *efuse_addr + 1 + tmpindex;\r\nif (efuse_one_byte_read(hw, address,\r\n&efuse_data) && (efuse_data != 0xFF))\r\ndataempty = false;\r\n}\r\nif (!dataempty) {\r\n*efuse_addr = *efuse_addr + (tmp_word_cnts * 2) + 1;\r\n*write_state = PG_STATE_HEADER;\r\n} else {\r\nmatch_word_en = 0x0F;\r\nif (!((target_pkt->word_en & BIT(0)) |\r\n(tmp_pkt.word_en & BIT(0))))\r\nmatch_word_en &= (~BIT(0));\r\nif (!((target_pkt->word_en & BIT(1)) |\r\n(tmp_pkt.word_en & BIT(1))))\r\nmatch_word_en &= (~BIT(1));\r\nif (!((target_pkt->word_en & BIT(2)) |\r\n(tmp_pkt.word_en & BIT(2))))\r\nmatch_word_en &= (~BIT(2));\r\nif (!((target_pkt->word_en & BIT(3)) |\r\n(tmp_pkt.word_en & BIT(3))))\r\nmatch_word_en &= (~BIT(3));\r\nif ((match_word_en & 0x0F) != 0x0F) {\r\nbadworden = efuse_word_enable_data_write(\r\nhw, *efuse_addr + 1,\r\ntmp_pkt.word_en,\r\ntarget_pkt->data);\r\nif (0x0F != (badworden & 0x0F)) {\r\nu8 reorg_offset = offset;\r\nu8 reorg_worden = badworden;\r\nefuse_pg_packet_write(hw, reorg_offset,\r\nreorg_worden,\r\noriginaldata);\r\n}\r\ntmp_word_en = 0x0F;\r\nif ((target_pkt->word_en & BIT(0)) ^\r\n(match_word_en & BIT(0)))\r\ntmp_word_en &= (~BIT(0));\r\nif ((target_pkt->word_en & BIT(1)) ^\r\n(match_word_en & BIT(1)))\r\ntmp_word_en &= (~BIT(1));\r\nif ((target_pkt->word_en & BIT(2)) ^\r\n(match_word_en & BIT(2)))\r\ntmp_word_en &= (~BIT(2));\r\nif ((target_pkt->word_en & BIT(3)) ^\r\n(match_word_en & BIT(3)))\r\ntmp_word_en &= (~BIT(3));\r\nif ((tmp_word_en & 0x0F) != 0x0F) {\r\n*efuse_addr = efuse_get_current_size(hw);\r\ntarget_pkt->offset = offset;\r\ntarget_pkt->word_en = tmp_word_en;\r\n} else {\r\n*continual = false;\r\n}\r\n*write_state = PG_STATE_HEADER;\r\n*repeat_times += 1;\r\nif (*repeat_times > EFUSE_REPEAT_THRESHOLD_) {\r\n*continual = false;\r\n*result = false;\r\n}\r\n} else {\r\n*efuse_addr += (2 * tmp_word_cnts) + 1;\r\ntarget_pkt->offset = offset;\r\ntarget_pkt->word_en = word_en;\r\n*write_state = PG_STATE_HEADER;\r\n}\r\n}\r\n}\r\nRTPRINT(rtlpriv, FEEPROM, EFUSE_PG, "efuse PG_STATE_HEADER-1\n");\r\n}\r\nstatic void efuse_write_data_case2(struct ieee80211_hw *hw, u16 *efuse_addr,\r\nint *continual, u8 *write_state,\r\nstruct pgpkt_struct target_pkt,\r\nint *repeat_times, int *result)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct pgpkt_struct tmp_pkt;\r\nu8 pg_header;\r\nu8 tmp_header;\r\nu8 originaldata[8 * sizeof(u8)];\r\nu8 tmp_word_cnts;\r\nu8 badworden = 0x0F;\r\npg_header = ((target_pkt.offset << 4) & 0xf0) | target_pkt.word_en;\r\nefuse_one_byte_write(hw, *efuse_addr, pg_header);\r\nefuse_one_byte_read(hw, *efuse_addr, &tmp_header);\r\nif (tmp_header == pg_header) {\r\n*write_state = PG_STATE_DATA;\r\n} else if (tmp_header == 0xFF) {\r\n*write_state = PG_STATE_HEADER;\r\n*repeat_times += 1;\r\nif (*repeat_times > EFUSE_REPEAT_THRESHOLD_) {\r\n*continual = false;\r\n*result = false;\r\n}\r\n} else {\r\ntmp_pkt.offset = (tmp_header >> 4) & 0x0F;\r\ntmp_pkt.word_en = tmp_header & 0x0F;\r\ntmp_word_cnts = efuse_calculate_word_cnts(tmp_pkt.word_en);\r\nmemset(originaldata, 0xff, 8 * sizeof(u8));\r\nif (efuse_pg_packet_read(hw, tmp_pkt.offset, originaldata)) {\r\nbadworden = efuse_word_enable_data_write(hw,\r\n*efuse_addr + 1, tmp_pkt.word_en,\r\noriginaldata);\r\nif (0x0F != (badworden & 0x0F)) {\r\nu8 reorg_offset = tmp_pkt.offset;\r\nu8 reorg_worden = badworden;\r\nefuse_pg_packet_write(hw, reorg_offset,\r\nreorg_worden,\r\noriginaldata);\r\n*efuse_addr = efuse_get_current_size(hw);\r\n} else {\r\n*efuse_addr = *efuse_addr + (tmp_word_cnts * 2)\r\n+ 1;\r\n}\r\n} else {\r\n*efuse_addr = *efuse_addr + (tmp_word_cnts * 2) + 1;\r\n}\r\n*write_state = PG_STATE_HEADER;\r\n*repeat_times += 1;\r\nif (*repeat_times > EFUSE_REPEAT_THRESHOLD_) {\r\n*continual = false;\r\n*result = false;\r\n}\r\nRTPRINT(rtlpriv, FEEPROM, EFUSE_PG,\r\n"efuse PG_STATE_HEADER-2\n");\r\n}\r\n}\r\nstatic int efuse_pg_packet_write(struct ieee80211_hw *hw,\r\nu8 offset, u8 word_en, u8 *data)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct pgpkt_struct target_pkt;\r\nu8 write_state = PG_STATE_HEADER;\r\nint continual = true, result = true;\r\nu16 efuse_addr = 0;\r\nu8 efuse_data;\r\nu8 target_word_cnts = 0;\r\nu8 badworden = 0x0F;\r\nstatic int repeat_times;\r\nif (efuse_get_current_size(hw) >= (EFUSE_MAX_SIZE -\r\nrtlpriv->cfg->maps[EFUSE_OOB_PROTECT_BYTES_LEN])) {\r\nRTPRINT(rtlpriv, FEEPROM, EFUSE_PG,\r\n"efuse_pg_packet_write error\n");\r\nreturn false;\r\n}\r\ntarget_pkt.offset = offset;\r\ntarget_pkt.word_en = word_en;\r\nmemset(target_pkt.data, 0xFF, 8 * sizeof(u8));\r\nefuse_word_enable_data_read(word_en, data, target_pkt.data);\r\ntarget_word_cnts = efuse_calculate_word_cnts(target_pkt.word_en);\r\nRTPRINT(rtlpriv, FEEPROM, EFUSE_PG, "efuse Power ON\n");\r\nwhile (continual && (efuse_addr < (EFUSE_MAX_SIZE -\r\nrtlpriv->cfg->maps[EFUSE_OOB_PROTECT_BYTES_LEN]))) {\r\nif (write_state == PG_STATE_HEADER) {\r\nbadworden = 0x0F;\r\nRTPRINT(rtlpriv, FEEPROM, EFUSE_PG,\r\n"efuse PG_STATE_HEADER\n");\r\nif (efuse_one_byte_read(hw, efuse_addr, &efuse_data) &&\r\n(efuse_data != 0xFF))\r\nefuse_write_data_case1(hw, &efuse_addr,\r\nefuse_data, offset,\r\n&continual,\r\n&write_state, &target_pkt,\r\n&repeat_times, &result,\r\nword_en);\r\nelse\r\nefuse_write_data_case2(hw, &efuse_addr,\r\n&continual,\r\n&write_state,\r\ntarget_pkt,\r\n&repeat_times,\r\n&result);\r\n} else if (write_state == PG_STATE_DATA) {\r\nRTPRINT(rtlpriv, FEEPROM, EFUSE_PG,\r\n"efuse PG_STATE_DATA\n");\r\nbadworden =\r\nefuse_word_enable_data_write(hw, efuse_addr + 1,\r\ntarget_pkt.word_en,\r\ntarget_pkt.data);\r\nif ((badworden & 0x0F) == 0x0F) {\r\ncontinual = false;\r\n} else {\r\nefuse_addr += (2 * target_word_cnts) + 1;\r\ntarget_pkt.offset = offset;\r\ntarget_pkt.word_en = badworden;\r\ntarget_word_cnts =\r\nefuse_calculate_word_cnts(target_pkt.\r\nword_en);\r\nwrite_state = PG_STATE_HEADER;\r\nrepeat_times++;\r\nif (repeat_times > EFUSE_REPEAT_THRESHOLD_) {\r\ncontinual = false;\r\nresult = false;\r\n}\r\nRTPRINT(rtlpriv, FEEPROM, EFUSE_PG,\r\n"efuse PG_STATE_HEADER-3\n");\r\n}\r\n}\r\n}\r\nif (efuse_addr >= (EFUSE_MAX_SIZE -\r\nrtlpriv->cfg->maps[EFUSE_OOB_PROTECT_BYTES_LEN])) {\r\nRT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD,\r\n"efuse_addr(%#x) Out of size!!\n", efuse_addr);\r\n}\r\nreturn true;\r\n}\r\nstatic void efuse_word_enable_data_read(u8 word_en,\r\nu8 *sourdata, u8 *targetdata)\r\n{\r\nif (!(word_en & BIT(0))) {\r\ntargetdata[0] = sourdata[0];\r\ntargetdata[1] = sourdata[1];\r\n}\r\nif (!(word_en & BIT(1))) {\r\ntargetdata[2] = sourdata[2];\r\ntargetdata[3] = sourdata[3];\r\n}\r\nif (!(word_en & BIT(2))) {\r\ntargetdata[4] = sourdata[4];\r\ntargetdata[5] = sourdata[5];\r\n}\r\nif (!(word_en & BIT(3))) {\r\ntargetdata[6] = sourdata[6];\r\ntargetdata[7] = sourdata[7];\r\n}\r\n}\r\nstatic u8 efuse_word_enable_data_write(struct ieee80211_hw *hw,\r\nu16 efuse_addr, u8 word_en, u8 *data)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu16 tmpaddr;\r\nu16 start_addr = efuse_addr;\r\nu8 badworden = 0x0F;\r\nu8 tmpdata[8];\r\nmemset(tmpdata, 0xff, PGPKT_DATA_SIZE);\r\nRT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "word_en = %x efuse_addr=%x\n",\r\nword_en, efuse_addr);\r\nif (!(word_en & BIT(0))) {\r\ntmpaddr = start_addr;\r\nefuse_one_byte_write(hw, start_addr++, data[0]);\r\nefuse_one_byte_write(hw, start_addr++, data[1]);\r\nefuse_one_byte_read(hw, tmpaddr, &tmpdata[0]);\r\nefuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[1]);\r\nif ((data[0] != tmpdata[0]) || (data[1] != tmpdata[1]))\r\nbadworden &= (~BIT(0));\r\n}\r\nif (!(word_en & BIT(1))) {\r\ntmpaddr = start_addr;\r\nefuse_one_byte_write(hw, start_addr++, data[2]);\r\nefuse_one_byte_write(hw, start_addr++, data[3]);\r\nefuse_one_byte_read(hw, tmpaddr, &tmpdata[2]);\r\nefuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[3]);\r\nif ((data[2] != tmpdata[2]) || (data[3] != tmpdata[3]))\r\nbadworden &= (~BIT(1));\r\n}\r\nif (!(word_en & BIT(2))) {\r\ntmpaddr = start_addr;\r\nefuse_one_byte_write(hw, start_addr++, data[4]);\r\nefuse_one_byte_write(hw, start_addr++, data[5]);\r\nefuse_one_byte_read(hw, tmpaddr, &tmpdata[4]);\r\nefuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[5]);\r\nif ((data[4] != tmpdata[4]) || (data[5] != tmpdata[5]))\r\nbadworden &= (~BIT(2));\r\n}\r\nif (!(word_en & BIT(3))) {\r\ntmpaddr = start_addr;\r\nefuse_one_byte_write(hw, start_addr++, data[6]);\r\nefuse_one_byte_write(hw, start_addr++, data[7]);\r\nefuse_one_byte_read(hw, tmpaddr, &tmpdata[6]);\r\nefuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[7]);\r\nif ((data[6] != tmpdata[6]) || (data[7] != tmpdata[7]))\r\nbadworden &= (~BIT(3));\r\n}\r\nreturn badworden;\r\n}\r\nstatic void efuse_power_switch(struct ieee80211_hw *hw, u8 write, u8 pwrstate)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nu8 tempval;\r\nu16 tmpV16;\r\nif (pwrstate && (rtlhal->hw_type != HARDWARE_TYPE_RTL8192SE)) {\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8188EE)\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_ACCESS],\r\n0x69);\r\ntmpV16 = rtl_read_word(rtlpriv,\r\nrtlpriv->cfg->maps[SYS_ISO_CTRL]);\r\nif (!(tmpV16 & rtlpriv->cfg->maps[EFUSE_PWC_EV12V])) {\r\ntmpV16 |= rtlpriv->cfg->maps[EFUSE_PWC_EV12V];\r\nrtl_write_word(rtlpriv,\r\nrtlpriv->cfg->maps[SYS_ISO_CTRL],\r\ntmpV16);\r\n}\r\ntmpV16 = rtl_read_word(rtlpriv,\r\nrtlpriv->cfg->maps[SYS_FUNC_EN]);\r\nif (!(tmpV16 & rtlpriv->cfg->maps[EFUSE_FEN_ELDR])) {\r\ntmpV16 |= rtlpriv->cfg->maps[EFUSE_FEN_ELDR];\r\nrtl_write_word(rtlpriv,\r\nrtlpriv->cfg->maps[SYS_FUNC_EN], tmpV16);\r\n}\r\ntmpV16 = rtl_read_word(rtlpriv, rtlpriv->cfg->maps[SYS_CLK]);\r\nif ((!(tmpV16 & rtlpriv->cfg->maps[EFUSE_LOADER_CLK_EN])) ||\r\n(!(tmpV16 & rtlpriv->cfg->maps[EFUSE_ANA8M]))) {\r\ntmpV16 |= (rtlpriv->cfg->maps[EFUSE_LOADER_CLK_EN] |\r\nrtlpriv->cfg->maps[EFUSE_ANA8M]);\r\nrtl_write_word(rtlpriv,\r\nrtlpriv->cfg->maps[SYS_CLK], tmpV16);\r\n}\r\n}\r\nif (pwrstate) {\r\nif (write) {\r\ntempval = rtl_read_byte(rtlpriv,\r\nrtlpriv->cfg->maps[EFUSE_TEST] +\r\n3);\r\nif (rtlhal->hw_type != HARDWARE_TYPE_RTL8192SE) {\r\ntempval &= 0x0F;\r\ntempval |= (VOLTAGE_V25 << 4);\r\n}\r\nrtl_write_byte(rtlpriv,\r\nrtlpriv->cfg->maps[EFUSE_TEST] + 3,\r\n(tempval | 0x80));\r\n}\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8192SE) {\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CLK],\r\n0x03);\r\n}\r\n} else {\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8188EE)\r\nrtl_write_byte(rtlpriv,\r\nrtlpriv->cfg->maps[EFUSE_ACCESS], 0);\r\nif (write) {\r\ntempval = rtl_read_byte(rtlpriv,\r\nrtlpriv->cfg->maps[EFUSE_TEST] +\r\n3);\r\nrtl_write_byte(rtlpriv,\r\nrtlpriv->cfg->maps[EFUSE_TEST] + 3,\r\n(tempval & 0x7F));\r\n}\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8192SE) {\r\nrtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CLK],\r\n0x02);\r\n}\r\n}\r\n}\r\nstatic u16 efuse_get_current_size(struct ieee80211_hw *hw)\r\n{\r\nint continual = true;\r\nu16 efuse_addr = 0;\r\nu8 hworden;\r\nu8 efuse_data, word_cnts;\r\nwhile (continual && efuse_one_byte_read(hw, efuse_addr, &efuse_data)\r\n&& (efuse_addr < EFUSE_MAX_SIZE)) {\r\nif (efuse_data != 0xFF) {\r\nhworden = efuse_data & 0x0F;\r\nword_cnts = efuse_calculate_word_cnts(hworden);\r\nefuse_addr = efuse_addr + (word_cnts * 2) + 1;\r\n} else {\r\ncontinual = false;\r\n}\r\n}\r\nreturn efuse_addr;\r\n}\r\nstatic u8 efuse_calculate_word_cnts(u8 word_en)\r\n{\r\nu8 word_cnts = 0;\r\nif (!(word_en & BIT(0)))\r\nword_cnts++;\r\nif (!(word_en & BIT(1)))\r\nword_cnts++;\r\nif (!(word_en & BIT(2)))\r\nword_cnts++;\r\nif (!(word_en & BIT(3)))\r\nword_cnts++;\r\nreturn word_cnts;\r\n}
