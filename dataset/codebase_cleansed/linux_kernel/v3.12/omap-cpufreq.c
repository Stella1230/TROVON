static int omap_verify_speed(struct cpufreq_policy *policy)\r\n{\r\nif (!freq_table)\r\nreturn -EINVAL;\r\nreturn cpufreq_frequency_table_verify(policy, freq_table);\r\n}\r\nstatic unsigned int omap_getspeed(unsigned int cpu)\r\n{\r\nunsigned long rate;\r\nif (cpu >= NR_CPUS)\r\nreturn 0;\r\nrate = clk_get_rate(mpu_clk) / 1000;\r\nreturn rate;\r\n}\r\nstatic int omap_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nunsigned int i;\r\nint r, ret = 0;\r\nstruct cpufreq_freqs freqs;\r\nstruct opp *opp;\r\nunsigned long freq, volt = 0, volt_old = 0, tol = 0;\r\nif (!freq_table) {\r\ndev_err(mpu_dev, "%s: cpu%d: no freq table!\n", __func__,\r\npolicy->cpu);\r\nreturn -EINVAL;\r\n}\r\nret = cpufreq_frequency_table_target(policy, freq_table, target_freq,\r\nrelation, &i);\r\nif (ret) {\r\ndev_dbg(mpu_dev, "%s: cpu%d: no freq match for %d(ret=%d)\n",\r\n__func__, policy->cpu, target_freq, ret);\r\nreturn ret;\r\n}\r\nfreqs.new = freq_table[i].frequency;\r\nif (!freqs.new) {\r\ndev_err(mpu_dev, "%s: cpu%d: no match for freq %d\n", __func__,\r\npolicy->cpu, target_freq);\r\nreturn -EINVAL;\r\n}\r\nfreqs.old = omap_getspeed(policy->cpu);\r\nif (freqs.old == freqs.new && policy->cur == freqs.new)\r\nreturn ret;\r\nfreq = freqs.new * 1000;\r\nret = clk_round_rate(mpu_clk, freq);\r\nif (IS_ERR_VALUE(ret)) {\r\ndev_warn(mpu_dev,\r\n"CPUfreq: Cannot find matching frequency for %lu\n",\r\nfreq);\r\nreturn ret;\r\n}\r\nfreq = ret;\r\nif (mpu_reg) {\r\nrcu_read_lock();\r\nopp = opp_find_freq_ceil(mpu_dev, &freq);\r\nif (IS_ERR(opp)) {\r\nrcu_read_unlock();\r\ndev_err(mpu_dev, "%s: unable to find MPU OPP for %d\n",\r\n__func__, freqs.new);\r\nreturn -EINVAL;\r\n}\r\nvolt = opp_get_voltage(opp);\r\nrcu_read_unlock();\r\ntol = volt * OPP_TOLERANCE / 100;\r\nvolt_old = regulator_get_voltage(mpu_reg);\r\n}\r\ndev_dbg(mpu_dev, "cpufreq-omap: %u MHz, %ld mV --> %u MHz, %ld mV\n",\r\nfreqs.old / 1000, volt_old ? volt_old / 1000 : -1,\r\nfreqs.new / 1000, volt ? volt / 1000 : -1);\r\ncpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);\r\nif (mpu_reg && (freqs.new > freqs.old)) {\r\nr = regulator_set_voltage(mpu_reg, volt - tol, volt + tol);\r\nif (r < 0) {\r\ndev_warn(mpu_dev, "%s: unable to scale voltage up.\n",\r\n__func__);\r\nfreqs.new = freqs.old;\r\ngoto done;\r\n}\r\n}\r\nret = clk_set_rate(mpu_clk, freqs.new * 1000);\r\nif (mpu_reg && (freqs.new < freqs.old)) {\r\nr = regulator_set_voltage(mpu_reg, volt - tol, volt + tol);\r\nif (r < 0) {\r\ndev_warn(mpu_dev, "%s: unable to scale voltage down.\n",\r\n__func__);\r\nret = clk_set_rate(mpu_clk, freqs.old * 1000);\r\nfreqs.new = freqs.old;\r\ngoto done;\r\n}\r\n}\r\nfreqs.new = omap_getspeed(policy->cpu);\r\ndone:\r\ncpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);\r\nreturn ret;\r\n}\r\nstatic inline void freq_table_free(void)\r\n{\r\nif (atomic_dec_and_test(&freq_table_users))\r\nopp_free_cpufreq_table(mpu_dev, &freq_table);\r\n}\r\nstatic int omap_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nint result = 0;\r\nmpu_clk = clk_get(NULL, "cpufreq_ck");\r\nif (IS_ERR(mpu_clk))\r\nreturn PTR_ERR(mpu_clk);\r\nif (policy->cpu >= NR_CPUS) {\r\nresult = -EINVAL;\r\ngoto fail_ck;\r\n}\r\npolicy->cur = omap_getspeed(policy->cpu);\r\nif (!freq_table)\r\nresult = opp_init_cpufreq_table(mpu_dev, &freq_table);\r\nif (result) {\r\ndev_err(mpu_dev, "%s: cpu%d: failed creating freq table[%d]\n",\r\n__func__, policy->cpu, result);\r\ngoto fail_ck;\r\n}\r\natomic_inc_return(&freq_table_users);\r\nresult = cpufreq_frequency_table_cpuinfo(policy, freq_table);\r\nif (result)\r\ngoto fail_table;\r\ncpufreq_frequency_table_get_attr(freq_table, policy->cpu);\r\npolicy->cur = omap_getspeed(policy->cpu);\r\nif (is_smp())\r\ncpumask_setall(policy->cpus);\r\npolicy->cpuinfo.transition_latency = 300 * 1000;\r\nreturn 0;\r\nfail_table:\r\nfreq_table_free();\r\nfail_ck:\r\nclk_put(mpu_clk);\r\nreturn result;\r\n}\r\nstatic int omap_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\nfreq_table_free();\r\nclk_put(mpu_clk);\r\nreturn 0;\r\n}\r\nstatic int omap_cpufreq_probe(struct platform_device *pdev)\r\n{\r\nmpu_dev = get_cpu_device(0);\r\nif (!mpu_dev) {\r\npr_warning("%s: unable to get the mpu device\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmpu_reg = regulator_get(mpu_dev, "vcc");\r\nif (IS_ERR(mpu_reg)) {\r\npr_warning("%s: unable to get MPU regulator\n", __func__);\r\nmpu_reg = NULL;\r\n} else {\r\nif (regulator_get_voltage(mpu_reg) < 0) {\r\npr_warn("%s: physical regulator not present for MPU\n",\r\n__func__);\r\nregulator_put(mpu_reg);\r\nmpu_reg = NULL;\r\n}\r\n}\r\nreturn cpufreq_register_driver(&omap_driver);\r\n}\r\nstatic int omap_cpufreq_remove(struct platform_device *pdev)\r\n{\r\nreturn cpufreq_unregister_driver(&omap_driver);\r\n}
