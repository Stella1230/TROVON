static int\r\nread_i2c_reg(void __iomem *addr, u8 index, u8 *data)\r\n{\r\nu32 tmp = index;\r\niowrite32((tmp<<17) | IIC_READ, addr + IIC_CSR2);\r\nmmiowb();\r\nudelay(45);\r\nif (ioread32(addr + IIC_CSR2) & NEW_CYCLE)\r\nreturn -EIO;\r\ntmp = ioread32(addr + IIC_CSR1);\r\nif (tmp & DIRECT_ABORT) {\r\niowrite32(DIRECT_ABORT, addr + IIC_CSR1);\r\nreturn -EIO;\r\n}\r\n*data = tmp>>24;\r\nreturn 0;\r\n}\r\nstatic int\r\nwrite_i2c_reg(void __iomem *addr, u8 index, u8 data)\r\n{\r\nu32 tmp = index;\r\niowrite32((tmp<<17) | IIC_WRITE | data, addr + IIC_CSR2);\r\nmmiowb();\r\nudelay(65);\r\nif (ioread32(addr + IIC_CSR2) & NEW_CYCLE)\r\nreturn -EIO;\r\nif (ioread32(addr + IIC_CSR1) & DIRECT_ABORT) {\r\niowrite32(DIRECT_ABORT, addr + IIC_CSR1);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void write_i2c_reg_nowait(void __iomem *addr, u8 index, u8 data)\r\n{\r\nu32 tmp = index;\r\niowrite32((tmp<<17) | IIC_WRITE | data, addr + IIC_CSR2);\r\nmmiowb();\r\n}\r\nstatic int wait_i2c_reg(void __iomem *addr)\r\n{\r\nif (ioread32(addr + IIC_CSR2) & NEW_CYCLE)\r\nudelay(65);\r\nif (ioread32(addr + IIC_CSR2) & NEW_CYCLE)\r\nreturn -EIO;\r\nif (ioread32(addr + IIC_CSR1) & DIRECT_ABORT) {\r\niowrite32(DIRECT_ABORT, addr + IIC_CSR1);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ndt3155_start_acq(struct dt3155_priv *pd)\r\n{\r\nstruct vb2_buffer *vb = pd->curr_buf;\r\ndma_addr_t dma_addr;\r\ndma_addr = vb2_dma_contig_plane_dma_addr(vb, 0);\r\niowrite32(dma_addr, pd->regs + EVEN_DMA_START);\r\niowrite32(dma_addr + img_width, pd->regs + ODD_DMA_START);\r\niowrite32(img_width, pd->regs + EVEN_DMA_STRIDE);\r\niowrite32(img_width, pd->regs + ODD_DMA_STRIDE);\r\niowrite32(FLD_START_EN | FLD_END_ODD_EN | FLD_START |\r\nFLD_END_EVEN | FLD_END_ODD, pd->regs + INT_CSR);\r\niowrite32(FIFO_EN | SRST | FLD_CRPT_ODD | FLD_CRPT_EVEN |\r\nFLD_DN_ODD | FLD_DN_EVEN | CAP_CONT_EVEN | CAP_CONT_ODD,\r\npd->regs + CSR1);\r\nwait_i2c_reg(pd->regs);\r\nwrite_i2c_reg(pd->regs, CONFIG, pd->config);\r\nwrite_i2c_reg(pd->regs, EVEN_CSR, CSR_ERROR | CSR_DONE);\r\nwrite_i2c_reg(pd->regs, ODD_CSR, CSR_ERROR | CSR_DONE);\r\nwrite_i2c_reg(pd->regs, CSR2, pd->csr2 | BUSY_EVEN | BUSY_ODD);\r\nreturn 0;\r\n}\r\nstatic int\r\ndt3155_queue_setup(struct vb2_queue *q, const struct v4l2_format *fmt,\r\nunsigned int *num_buffers, unsigned int *num_planes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct dt3155_priv *pd = vb2_get_drv_priv(q);\r\nvoid *ret;\r\nif (*num_buffers == 0)\r\n*num_buffers = 1;\r\n*num_planes = 1;\r\nsizes[0] = img_width * img_height;\r\nif (pd->q->alloc_ctx[0])\r\nreturn 0;\r\nret = vb2_dma_contig_init_ctx(&pd->pdev->dev);\r\nif (IS_ERR(ret))\r\nreturn PTR_ERR(ret);\r\npd->q->alloc_ctx[0] = ret;\r\nreturn 0;\r\n}\r\nstatic void\r\ndt3155_wait_prepare(struct vb2_queue *q)\r\n{\r\nstruct dt3155_priv *pd = vb2_get_drv_priv(q);\r\nmutex_unlock(pd->vdev->lock);\r\n}\r\nstatic void\r\ndt3155_wait_finish(struct vb2_queue *q)\r\n{\r\nstruct dt3155_priv *pd = vb2_get_drv_priv(q);\r\nmutex_lock(pd->vdev->lock);\r\n}\r\nstatic int\r\ndt3155_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nvb2_set_plane_payload(vb, 0, img_width * img_height);\r\nreturn 0;\r\n}\r\nstatic int\r\ndt3155_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct dt3155_priv *pd = vb2_get_drv_priv(q);\r\nstruct vb2_buffer *vb;\r\nspin_lock_irq(&pd->lock);\r\nwhile (!list_empty(&pd->dmaq)) {\r\nvb = list_first_entry(&pd->dmaq, typeof(*vb), done_entry);\r\nlist_del(&vb->done_entry);\r\nvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irq(&pd->lock);\r\nmsleep(45);\r\nreturn 0;\r\n}\r\nstatic void\r\ndt3155_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct dt3155_priv *pd = vb2_get_drv_priv(vb->vb2_queue);\r\nspin_lock_irq(&pd->lock);\r\nif (pd->curr_buf)\r\nlist_add_tail(&vb->done_entry, &pd->dmaq);\r\nelse {\r\npd->curr_buf = vb;\r\ndt3155_start_acq(pd);\r\n}\r\nspin_unlock_irq(&pd->lock);\r\n}\r\nstatic irqreturn_t\r\ndt3155_irq_handler_even(int irq, void *dev_id)\r\n{\r\nstruct dt3155_priv *ipd = dev_id;\r\nstruct vb2_buffer *ivb;\r\ndma_addr_t dma_addr;\r\nu32 tmp;\r\ntmp = ioread32(ipd->regs + INT_CSR) & (FLD_START | FLD_END_ODD);\r\nif (!tmp)\r\nreturn IRQ_NONE;\r\nif ((tmp & FLD_START) && !(tmp & FLD_END_ODD)) {\r\niowrite32(FLD_START_EN | FLD_END_ODD_EN | FLD_START,\r\nipd->regs + INT_CSR);\r\nipd->field_count++;\r\nreturn IRQ_HANDLED;\r\n}\r\nif ((tmp & FLD_START) && (tmp & FLD_END_ODD))\r\nipd->stats.start_before_end++;\r\ntmp = ioread32(ipd->regs + CSR1) & (FLD_CRPT_EVEN | FLD_CRPT_ODD);\r\nif (tmp) {\r\nipd->stats.corrupted_fields++;\r\niowrite32(FIFO_EN | SRST | FLD_CRPT_ODD | FLD_CRPT_EVEN |\r\nFLD_DN_ODD | FLD_DN_EVEN |\r\nCAP_CONT_EVEN | CAP_CONT_ODD,\r\nipd->regs + CSR1);\r\nmmiowb();\r\n}\r\nspin_lock(&ipd->lock);\r\nif (ipd->curr_buf) {\r\nv4l2_get_timestamp(&ipd->curr_buf->v4l2_buf.timestamp);\r\nipd->curr_buf->v4l2_buf.sequence = (ipd->field_count) >> 1;\r\nvb2_buffer_done(ipd->curr_buf, VB2_BUF_STATE_DONE);\r\n}\r\nif (!ipd->q->streaming || list_empty(&ipd->dmaq))\r\ngoto stop_dma;\r\nivb = list_first_entry(&ipd->dmaq, typeof(*ivb), done_entry);\r\nlist_del(&ivb->done_entry);\r\nipd->curr_buf = ivb;\r\ndma_addr = vb2_dma_contig_plane_dma_addr(ivb, 0);\r\niowrite32(dma_addr, ipd->regs + EVEN_DMA_START);\r\niowrite32(dma_addr + img_width, ipd->regs + ODD_DMA_START);\r\niowrite32(img_width, ipd->regs + EVEN_DMA_STRIDE);\r\niowrite32(img_width, ipd->regs + ODD_DMA_STRIDE);\r\nmmiowb();\r\niowrite32(FLD_START_EN | FLD_END_ODD_EN | FLD_START |\r\nFLD_END_EVEN | FLD_END_ODD, ipd->regs + INT_CSR);\r\nspin_unlock(&ipd->lock);\r\nreturn IRQ_HANDLED;\r\nstop_dma:\r\nipd->curr_buf = NULL;\r\nwrite_i2c_reg_nowait(ipd->regs, CSR2, ipd->csr2);\r\niowrite32(FIFO_EN | SRST | FLD_CRPT_ODD | FLD_CRPT_EVEN |\r\nFLD_DN_ODD | FLD_DN_EVEN, ipd->regs + CSR1);\r\niowrite32(FLD_START | FLD_END_EVEN | FLD_END_ODD, ipd->regs + INT_CSR);\r\nspin_unlock(&ipd->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\ndt3155_open(struct file *filp)\r\n{\r\nint ret = 0;\r\nstruct dt3155_priv *pd = video_drvdata(filp);\r\nif (mutex_lock_interruptible(&pd->mux))\r\nreturn -ERESTARTSYS;\r\nif (!pd->users) {\r\npd->q = kzalloc(sizeof(*pd->q), GFP_KERNEL);\r\nif (!pd->q) {\r\nret = -ENOMEM;\r\ngoto err_alloc_queue;\r\n}\r\npd->q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\npd->q->timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\npd->q->io_modes = VB2_READ | VB2_MMAP;\r\npd->q->ops = &q_ops;\r\npd->q->mem_ops = &vb2_dma_contig_memops;\r\npd->q->drv_priv = pd;\r\npd->curr_buf = NULL;\r\npd->field_count = 0;\r\nret = vb2_queue_init(pd->q);\r\nif (ret < 0)\r\ngoto err_request_irq;\r\nINIT_LIST_HEAD(&pd->dmaq);\r\nspin_lock_init(&pd->lock);\r\niowrite32(FLD_START | FLD_END_EVEN | FLD_END_ODD,\r\npd->regs + INT_CSR);\r\nret = request_irq(pd->pdev->irq, dt3155_irq_handler_even,\r\nIRQF_SHARED, DT3155_NAME, pd);\r\nif (ret)\r\ngoto err_request_irq;\r\n}\r\npd->users++;\r\nmutex_unlock(&pd->mux);\r\nreturn 0;\r\nerr_request_irq:\r\nkfree(pd->q);\r\npd->q = NULL;\r\nerr_alloc_queue:\r\nmutex_unlock(&pd->mux);\r\nreturn ret;\r\n}\r\nstatic int\r\ndt3155_release(struct file *filp)\r\n{\r\nstruct dt3155_priv *pd = video_drvdata(filp);\r\nmutex_lock(&pd->mux);\r\npd->users--;\r\nBUG_ON(pd->users < 0);\r\nif (!pd->users) {\r\nvb2_queue_release(pd->q);\r\nfree_irq(pd->pdev->irq, pd);\r\nif (pd->q->alloc_ctx[0])\r\nvb2_dma_contig_cleanup_ctx(pd->q->alloc_ctx[0]);\r\nkfree(pd->q);\r\npd->q = NULL;\r\n}\r\nmutex_unlock(&pd->mux);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\ndt3155_read(struct file *filp, char __user *user, size_t size, loff_t *loff)\r\n{\r\nstruct dt3155_priv *pd = video_drvdata(filp);\r\nssize_t res;\r\nif (mutex_lock_interruptible(&pd->mux))\r\nreturn -ERESTARTSYS;\r\nres = vb2_read(pd->q, user, size, loff, filp->f_flags & O_NONBLOCK);\r\nmutex_unlock(&pd->mux);\r\nreturn res;\r\n}\r\nstatic unsigned int\r\ndt3155_poll(struct file *filp, struct poll_table_struct *polltbl)\r\n{\r\nstruct dt3155_priv *pd = video_drvdata(filp);\r\nunsigned int res;\r\nmutex_lock(&pd->mux);\r\nres = vb2_poll(pd->q, filp, polltbl);\r\nmutex_unlock(&pd->mux);\r\nreturn res;\r\n}\r\nstatic int\r\ndt3155_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct dt3155_priv *pd = video_drvdata(filp);\r\nint res;\r\nif (mutex_lock_interruptible(&pd->mux))\r\nreturn -ERESTARTSYS;\r\nres = vb2_mmap(pd->q, vma);\r\nmutex_unlock(&pd->mux);\r\nreturn res;\r\n}\r\nstatic int\r\ndt3155_ioc_streamon(struct file *filp, void *p, enum v4l2_buf_type type)\r\n{\r\nstruct dt3155_priv *pd = video_drvdata(filp);\r\nreturn vb2_streamon(pd->q, type);\r\n}\r\nstatic int\r\ndt3155_ioc_streamoff(struct file *filp, void *p, enum v4l2_buf_type type)\r\n{\r\nstruct dt3155_priv *pd = video_drvdata(filp);\r\nreturn vb2_streamoff(pd->q, type);\r\n}\r\nstatic int\r\ndt3155_ioc_querycap(struct file *filp, void *p, struct v4l2_capability *cap)\r\n{\r\nstruct dt3155_priv *pd = video_drvdata(filp);\r\nstrcpy(cap->driver, DT3155_NAME);\r\nstrcpy(cap->card, DT3155_NAME " frame grabber");\r\nsprintf(cap->bus_info, "PCI:%s", pci_name(pd->pdev));\r\ncap->version =\r\nKERNEL_VERSION(DT3155_VER_MAJ, DT3155_VER_MIN, DT3155_VER_EXT);\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE |\r\nDT3155_CAPTURE_METHOD;\r\nreturn 0;\r\n}\r\nstatic int\r\ndt3155_ioc_enum_fmt_vid_cap(struct file *filp, void *p, struct v4l2_fmtdesc *f)\r\n{\r\nif (f->index >= NUM_OF_FORMATS)\r\nreturn -EINVAL;\r\n*f = frame_std[f->index];\r\nreturn 0;\r\n}\r\nstatic int\r\ndt3155_ioc_g_fmt_vid_cap(struct file *filp, void *p, struct v4l2_format *f)\r\n{\r\nif (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nf->fmt.pix.width = img_width;\r\nf->fmt.pix.height = img_height;\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_GREY;\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nf->fmt.pix.bytesperline = f->fmt.pix.width;\r\nf->fmt.pix.sizeimage = f->fmt.pix.width * f->fmt.pix.height;\r\nf->fmt.pix.colorspace = 0;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\ndt3155_ioc_try_fmt_vid_cap(struct file *filp, void *p, struct v4l2_format *f)\r\n{\r\nif (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (f->fmt.pix.width == img_width &&\r\nf->fmt.pix.height == img_height &&\r\nf->fmt.pix.pixelformat == V4L2_PIX_FMT_GREY &&\r\nf->fmt.pix.field == V4L2_FIELD_NONE &&\r\nf->fmt.pix.bytesperline == f->fmt.pix.width &&\r\nf->fmt.pix.sizeimage == f->fmt.pix.width * f->fmt.pix.height)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\ndt3155_ioc_s_fmt_vid_cap(struct file *filp, void *p, struct v4l2_format *f)\r\n{\r\nreturn dt3155_ioc_g_fmt_vid_cap(filp, p, f);\r\n}\r\nstatic int\r\ndt3155_ioc_reqbufs(struct file *filp, void *p, struct v4l2_requestbuffers *b)\r\n{\r\nstruct dt3155_priv *pd = video_drvdata(filp);\r\nreturn vb2_reqbufs(pd->q, b);\r\n}\r\nstatic int\r\ndt3155_ioc_querybuf(struct file *filp, void *p, struct v4l2_buffer *b)\r\n{\r\nstruct dt3155_priv *pd = video_drvdata(filp);\r\nreturn vb2_querybuf(pd->q, b);\r\n}\r\nstatic int\r\ndt3155_ioc_qbuf(struct file *filp, void *p, struct v4l2_buffer *b)\r\n{\r\nstruct dt3155_priv *pd = video_drvdata(filp);\r\nreturn vb2_qbuf(pd->q, b);\r\n}\r\nstatic int\r\ndt3155_ioc_dqbuf(struct file *filp, void *p, struct v4l2_buffer *b)\r\n{\r\nstruct dt3155_priv *pd = video_drvdata(filp);\r\nreturn vb2_dqbuf(pd->q, b, filp->f_flags & O_NONBLOCK);\r\n}\r\nstatic int\r\ndt3155_ioc_querystd(struct file *filp, void *p, v4l2_std_id *norm)\r\n{\r\n*norm = DT3155_CURRENT_NORM;\r\nreturn 0;\r\n}\r\nstatic int\r\ndt3155_ioc_g_std(struct file *filp, void *p, v4l2_std_id *norm)\r\n{\r\n*norm = DT3155_CURRENT_NORM;\r\nreturn 0;\r\n}\r\nstatic int\r\ndt3155_ioc_s_std(struct file *filp, void *p, v4l2_std_id norm)\r\n{\r\nif (norm & DT3155_CURRENT_NORM)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\ndt3155_ioc_enum_input(struct file *filp, void *p, struct v4l2_input *input)\r\n{\r\nif (input->index)\r\nreturn -EINVAL;\r\nstrcpy(input->name, "Coax in");\r\ninput->type = V4L2_INPUT_TYPE_CAMERA;\r\ninput->std = DT3155_CURRENT_NORM;\r\ninput->status = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\ndt3155_ioc_g_input(struct file *filp, void *p, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\ndt3155_ioc_s_input(struct file *filp, void *p, unsigned int i)\r\n{\r\nif (i)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\ndt3155_ioc_g_parm(struct file *filp, void *p, struct v4l2_streamparm *parms)\r\n{\r\nif (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nparms->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\r\nparms->parm.capture.capturemode = 0;\r\nparms->parm.capture.timeperframe.numerator = 1001;\r\nparms->parm.capture.timeperframe.denominator = frames_per_sec * 1000;\r\nparms->parm.capture.extendedmode = 0;\r\nparms->parm.capture.readbuffers = 1;\r\nreturn 0;\r\n}\r\nstatic int\r\ndt3155_ioc_s_parm(struct file *filp, void *p, struct v4l2_streamparm *parms)\r\n{\r\nif (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nparms->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\r\nparms->parm.capture.capturemode = 0;\r\nparms->parm.capture.timeperframe.numerator = 1001;\r\nparms->parm.capture.timeperframe.denominator = frames_per_sec * 1000;\r\nparms->parm.capture.extendedmode = 0;\r\nparms->parm.capture.readbuffers = 1;\r\nreturn 0;\r\n}\r\nstatic int\r\ndt3155_init_board(struct pci_dev *pdev)\r\n{\r\nstruct dt3155_priv *pd = pci_get_drvdata(pdev);\r\nvoid *buf_cpu;\r\ndma_addr_t buf_dma;\r\nint i;\r\nu8 tmp;\r\npci_set_master(pdev);\r\niowrite32(FLD_CRPT_ODD | FLD_CRPT_EVEN | FLD_DN_ODD | FLD_DN_EVEN,\r\npd->regs + CSR1);\r\nmmiowb();\r\nmsleep(20);\r\niowrite32(FIFO_EN | SRST, pd->regs + CSR1);\r\nmmiowb();\r\niowrite32(0xEEEEEE01, pd->regs + EVEN_PIXEL_FMT);\r\niowrite32(0xEEEEEE01, pd->regs + ODD_PIXEL_FMT);\r\niowrite32(0x00000020, pd->regs + FIFO_TRIGER);\r\niowrite32(0x00000103, pd->regs + XFER_MODE);\r\niowrite32(0, pd->regs + RETRY_WAIT_CNT);\r\niowrite32(0, pd->regs + INT_CSR);\r\niowrite32(1, pd->regs + EVEN_FLD_MASK);\r\niowrite32(1, pd->regs + ODD_FLD_MASK);\r\niowrite32(0, pd->regs + MASK_LENGTH);\r\niowrite32(0x0005007C, pd->regs + FIFO_FLAG_CNT);\r\niowrite32(0x01010101, pd->regs + IIC_CLK_DUR);\r\nmmiowb();\r\nread_i2c_reg(pd->regs, DT_ID, &tmp);\r\nif (tmp != DT3155_ID)\r\nreturn -ENODEV;\r\nwrite_i2c_reg(pd->regs, AD_ADDR, 0);\r\nfor (i = 0; i < 256; i++)\r\nwrite_i2c_reg(pd->regs, AD_LUT, i);\r\nwrite_i2c_reg(pd->regs, AD_ADDR, AD_CMD_REG);\r\nwrite_i2c_reg(pd->regs, AD_CMD, VIDEO_CNL_1 | SYNC_CNL_1 | SYNC_LVL_3);\r\nwrite_i2c_reg(pd->regs, AD_ADDR, AD_POS_REF);\r\nwrite_i2c_reg(pd->regs, AD_CMD, 34);\r\nwrite_i2c_reg(pd->regs, AD_ADDR, AD_NEG_REF);\r\nwrite_i2c_reg(pd->regs, AD_CMD, 0);\r\nwrite_i2c_reg(pd->regs, CONFIG, pd->config | PM_LUT_PGM);\r\nfor (i = 0; i < 256; i++) {\r\nwrite_i2c_reg(pd->regs, PM_LUT_ADDR, i);\r\nwrite_i2c_reg(pd->regs, PM_LUT_DATA, i);\r\n}\r\nwrite_i2c_reg(pd->regs, CONFIG, pd->config | PM_LUT_PGM | PM_LUT_SEL);\r\nfor (i = 0; i < 256; i++) {\r\nwrite_i2c_reg(pd->regs, PM_LUT_ADDR, i);\r\nwrite_i2c_reg(pd->regs, PM_LUT_DATA, i);\r\n}\r\nwrite_i2c_reg(pd->regs, CONFIG, pd->config);\r\nwrite_i2c_reg(pd->regs, AD_ADDR, AD_CMD_REG);\r\nwrite_i2c_reg(pd->regs, AD_CMD, VIDEO_CNL_1 | SYNC_CNL_1 | SYNC_LVL_3);\r\nbuf_cpu = dma_alloc_coherent(&pdev->dev, DT3155_BUF_SIZE, &buf_dma,\r\nGFP_KERNEL);\r\nif (!buf_cpu)\r\nreturn -ENOMEM;\r\niowrite32(buf_dma, pd->regs + EVEN_DMA_START);\r\niowrite32(buf_dma, pd->regs + ODD_DMA_START);\r\niowrite32(0, pd->regs + EVEN_DMA_STRIDE);\r\niowrite32(0, pd->regs + ODD_DMA_STRIDE);\r\niowrite32(FIFO_EN | SRST | CAP_CONT_ODD, pd->regs + CSR1);\r\nwrite_i2c_reg(pd->regs, CSR2, pd->csr2 | SYNC_SNTL);\r\nwrite_i2c_reg(pd->regs, CONFIG, pd->config);\r\nwrite_i2c_reg(pd->regs, EVEN_CSR, CSR_SNGL);\r\nwrite_i2c_reg(pd->regs, CSR2, pd->csr2 | BUSY_EVEN | SYNC_SNTL);\r\nmsleep(100);\r\nread_i2c_reg(pd->regs, CSR2, &tmp);\r\nwrite_i2c_reg(pd->regs, EVEN_CSR, CSR_ERROR | CSR_SNGL | CSR_DONE);\r\nwrite_i2c_reg(pd->regs, ODD_CSR, CSR_ERROR | CSR_SNGL | CSR_DONE);\r\nwrite_i2c_reg(pd->regs, CSR2, pd->csr2);\r\niowrite32(FIFO_EN | SRST | FLD_DN_EVEN | FLD_DN_ODD, pd->regs + CSR1);\r\ndma_free_coherent(&pdev->dev, DT3155_BUF_SIZE, buf_cpu, buf_dma);\r\nif (tmp & BUSY_EVEN)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int\r\ndt3155_alloc_coherent(struct device *dev, size_t size, int flags)\r\n{\r\nstruct dma_coherent_mem *mem;\r\ndma_addr_t dev_base;\r\nint pages = size >> PAGE_SHIFT;\r\nint bitmap_size = BITS_TO_LONGS(pages) * sizeof(long);\r\nif ((flags & DMA_MEMORY_MAP) == 0)\r\ngoto out;\r\nif (!size)\r\ngoto out;\r\nif (dev->dma_mem)\r\ngoto out;\r\nmem = kzalloc(sizeof(*mem), GFP_KERNEL);\r\nif (!mem)\r\ngoto out;\r\nmem->virt_base = dma_alloc_coherent(dev, size, &dev_base,\r\nDT3155_COH_FLAGS);\r\nif (!mem->virt_base)\r\ngoto err_alloc_coherent;\r\nmem->bitmap = kzalloc(bitmap_size, GFP_KERNEL);\r\nif (!mem->bitmap)\r\ngoto err_bitmap;\r\nmem->device_base = dev_base;\r\nmem->size = pages;\r\nmem->flags = flags;\r\ndev->dma_mem = mem;\r\nreturn DMA_MEMORY_MAP;\r\nerr_bitmap:\r\ndma_free_coherent(dev, size, mem->virt_base, dev_base);\r\nerr_alloc_coherent:\r\nkfree(mem);\r\nout:\r\nreturn 0;\r\n}\r\nstatic void\r\ndt3155_free_coherent(struct device *dev)\r\n{\r\nstruct dma_coherent_mem *mem = dev->dma_mem;\r\nif (!mem)\r\nreturn;\r\ndev->dma_mem = NULL;\r\ndma_free_coherent(dev, mem->size << PAGE_SHIFT,\r\nmem->virt_base, mem->device_base);\r\nkfree(mem->bitmap);\r\nkfree(mem);\r\n}\r\nstatic int\r\ndt3155_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nint err;\r\nstruct dt3155_priv *pd;\r\nerr = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\r\nif (err)\r\nreturn -ENODEV;\r\nerr = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\r\nif (err)\r\nreturn -ENODEV;\r\npd = kzalloc(sizeof(*pd), GFP_KERNEL);\r\nif (!pd)\r\nreturn -ENOMEM;\r\npd->vdev = video_device_alloc();\r\nif (!pd->vdev)\r\ngoto err_video_device_alloc;\r\n*pd->vdev = dt3155_vdev;\r\npci_set_drvdata(pdev, pd);\r\nvideo_set_drvdata(pd->vdev, pd);\r\npd->users = 0;\r\npd->pdev = pdev;\r\nINIT_LIST_HEAD(&pd->dmaq);\r\nmutex_init(&pd->mux);\r\npd->vdev->lock = &pd->mux;\r\nspin_lock_init(&pd->lock);\r\npd->csr2 = csr2_init;\r\npd->config = config_init;\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\ngoto err_enable_dev;\r\nerr = pci_request_region(pdev, 0, pci_name(pdev));\r\nif (err)\r\ngoto err_req_region;\r\npd->regs = pci_iomap(pdev, 0, pci_resource_len(pd->pdev, 0));\r\nif (!pd->regs) {\r\nerr = -ENOMEM;\r\ngoto err_pci_iomap;\r\n}\r\nerr = dt3155_init_board(pdev);\r\nif (err)\r\ngoto err_init_board;\r\nerr = video_register_device(pd->vdev, VFL_TYPE_GRABBER, -1);\r\nif (err)\r\ngoto err_init_board;\r\nif (dt3155_alloc_coherent(&pdev->dev, DT3155_CHUNK_SIZE,\r\nDMA_MEMORY_MAP))\r\ndev_info(&pdev->dev, "preallocated 8 buffers\n");\r\ndev_info(&pdev->dev, "/dev/video%i is ready\n", pd->vdev->minor);\r\nreturn 0;\r\nerr_init_board:\r\npci_iounmap(pdev, pd->regs);\r\nerr_pci_iomap:\r\npci_release_region(pdev, 0);\r\nerr_req_region:\r\npci_disable_device(pdev);\r\nerr_enable_dev:\r\nvideo_device_release(pd->vdev);\r\nerr_video_device_alloc:\r\nkfree(pd);\r\nreturn err;\r\n}\r\nstatic void\r\ndt3155_remove(struct pci_dev *pdev)\r\n{\r\nstruct dt3155_priv *pd = pci_get_drvdata(pdev);\r\ndt3155_free_coherent(&pdev->dev);\r\nvideo_unregister_device(pd->vdev);\r\npci_iounmap(pdev, pd->regs);\r\npci_release_region(pdev, 0);\r\npci_disable_device(pdev);\r\nkfree(pd);\r\n}
