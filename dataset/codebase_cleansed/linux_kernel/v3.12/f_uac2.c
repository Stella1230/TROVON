static inline\r\nstruct audio_dev *func_to_agdev(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct audio_dev, func);\r\n}\r\nstatic inline\r\nstruct audio_dev *uac2_to_agdev(struct snd_uac2_chip *u)\r\n{\r\nreturn container_of(u, struct audio_dev, uac2);\r\n}\r\nstatic inline\r\nstruct snd_uac2_chip *pdev_to_uac2(struct platform_device *p)\r\n{\r\nreturn container_of(p, struct snd_uac2_chip, pdev);\r\n}\r\nstatic inline\r\nuint num_channels(uint chanmask)\r\n{\r\nuint num = 0;\r\nwhile (chanmask) {\r\nnum += (chanmask & 1);\r\nchanmask >>= 1;\r\n}\r\nreturn num;\r\n}\r\nstatic void\r\nagdev_iso_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nunsigned pending;\r\nunsigned long flags;\r\nbool update_alsa = false;\r\nunsigned char *src, *dst;\r\nint status = req->status;\r\nstruct uac2_req *ur = req->context;\r\nstruct snd_pcm_substream *substream;\r\nstruct uac2_rtd_params *prm = ur->pp;\r\nstruct snd_uac2_chip *uac2 = prm->uac2;\r\nif (!prm->ep_enabled)\r\nreturn;\r\nif (status)\r\npr_debug("%s: iso_complete status(%d) %d/%d\n",\r\n__func__, status, req->actual, req->length);\r\nsubstream = prm->ss;\r\nif (!substream)\r\ngoto exit;\r\nspin_lock_irqsave(&prm->lock, flags);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nsrc = prm->dma_area + prm->hw_ptr;\r\nreq->actual = req->length;\r\ndst = req->buf;\r\n} else {\r\ndst = prm->dma_area + prm->hw_ptr;\r\nsrc = req->buf;\r\n}\r\npending = prm->hw_ptr % prm->period_size;\r\npending += req->actual;\r\nif (pending >= prm->period_size)\r\nupdate_alsa = true;\r\nprm->hw_ptr = (prm->hw_ptr + req->actual) % prm->dma_bytes;\r\nspin_unlock_irqrestore(&prm->lock, flags);\r\nmemcpy(dst, src, req->actual);\r\nexit:\r\nif (usb_ep_queue(ep, req, GFP_ATOMIC))\r\ndev_err(&uac2->pdev.dev, "%d Error!\n", __LINE__);\r\nif (update_alsa)\r\nsnd_pcm_period_elapsed(substream);\r\nreturn;\r\n}\r\nstatic int\r\nuac2_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_uac2_chip *uac2 = snd_pcm_substream_chip(substream);\r\nstruct uac2_rtd_params *prm;\r\nunsigned long flags;\r\nint err = 0;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nprm = &uac2->p_prm;\r\nelse\r\nprm = &uac2->c_prm;\r\nspin_lock_irqsave(&prm->lock, flags);\r\nprm->hw_ptr = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nprm->ss = substream;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nprm->ss = NULL;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nspin_unlock_irqrestore(&prm->lock, flags);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK && !prm->ss)\r\nmemset(prm->rbuf, 0, prm->max_psize * USB_XFERS);\r\nreturn err;\r\n}\r\nstatic snd_pcm_uframes_t uac2_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_uac2_chip *uac2 = snd_pcm_substream_chip(substream);\r\nstruct uac2_rtd_params *prm;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nprm = &uac2->p_prm;\r\nelse\r\nprm = &uac2->c_prm;\r\nreturn bytes_to_frames(substream->runtime, prm->hw_ptr);\r\n}\r\nstatic int uac2_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_uac2_chip *uac2 = snd_pcm_substream_chip(substream);\r\nstruct uac2_rtd_params *prm;\r\nint err;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nprm = &uac2->p_prm;\r\nelse\r\nprm = &uac2->c_prm;\r\nerr = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err >= 0) {\r\nprm->dma_bytes = substream->runtime->dma_bytes;\r\nprm->dma_area = substream->runtime->dma_area;\r\nprm->period_size = params_period_bytes(hw_params);\r\n}\r\nreturn err;\r\n}\r\nstatic int uac2_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_uac2_chip *uac2 = snd_pcm_substream_chip(substream);\r\nstruct uac2_rtd_params *prm;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nprm = &uac2->p_prm;\r\nelse\r\nprm = &uac2->c_prm;\r\nprm->dma_area = NULL;\r\nprm->dma_bytes = 0;\r\nprm->period_size = 0;\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int uac2_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_uac2_chip *uac2 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->hw = uac2_pcm_hardware;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nspin_lock_init(&uac2->p_prm.lock);\r\nruntime->hw.rate_min = p_srate;\r\nruntime->hw.formats = SNDRV_PCM_FMTBIT_S16_LE;\r\nruntime->hw.channels_min = num_channels(p_chmask);\r\nruntime->hw.period_bytes_min = 2 * uac2->p_prm.max_psize\r\n/ runtime->hw.periods_min;\r\n} else {\r\nspin_lock_init(&uac2->c_prm.lock);\r\nruntime->hw.rate_min = c_srate;\r\nruntime->hw.formats = SNDRV_PCM_FMTBIT_S16_LE;\r\nruntime->hw.channels_min = num_channels(c_chmask);\r\nruntime->hw.period_bytes_min = 2 * uac2->c_prm.max_psize\r\n/ runtime->hw.periods_min;\r\n}\r\nruntime->hw.rate_max = runtime->hw.rate_min;\r\nruntime->hw.channels_max = runtime->hw.channels_min;\r\nsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\r\nreturn 0;\r\n}\r\nstatic int uac2_pcm_null(struct snd_pcm_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic int snd_uac2_probe(struct platform_device *pdev)\r\n{\r\nstruct snd_uac2_chip *uac2 = pdev_to_uac2(pdev);\r\nstruct snd_card *card;\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_card_create(-1, NULL, THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nuac2->card = card;\r\nerr = snd_pcm_new(uac2->card, "UAC2 PCM", 0,\r\np_chmask ? 1 : 0, c_chmask ? 1 : 0, &pcm);\r\nif (err < 0)\r\ngoto snd_fail;\r\nstrcpy(pcm->name, "UAC2 PCM");\r\npcm->private_data = uac2;\r\nuac2->pcm = pcm;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &uac2_pcm_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &uac2_pcm_ops);\r\nstrcpy(card->driver, "UAC2_Gadget");\r\nstrcpy(card->shortname, "UAC2_Gadget");\r\nsprintf(card->longname, "UAC2_Gadget %i", pdev->id);\r\nsnd_card_set_dev(card, &pdev->dev);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL), 0, BUFF_SIZE_MAX);\r\nerr = snd_card_register(card);\r\nif (!err) {\r\nplatform_set_drvdata(pdev, card);\r\nreturn 0;\r\n}\r\nsnd_fail:\r\nsnd_card_free(card);\r\nuac2->pcm = NULL;\r\nuac2->card = NULL;\r\nreturn err;\r\n}\r\nstatic int snd_uac2_remove(struct platform_device *pdev)\r\n{\r\nstruct snd_card *card = platform_get_drvdata(pdev);\r\nif (card)\r\nreturn snd_card_free(card);\r\nreturn 0;\r\n}\r\nstatic int alsa_uac2_init(struct audio_dev *agdev)\r\n{\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nint err;\r\nuac2->pdrv.probe = snd_uac2_probe;\r\nuac2->pdrv.remove = snd_uac2_remove;\r\nuac2->pdrv.driver.name = uac2_name;\r\nuac2->pdev.id = 0;\r\nuac2->pdev.name = uac2_name;\r\nerr = platform_driver_register(&uac2->pdrv);\r\nif (err)\r\nreturn err;\r\nerr = platform_device_register(&uac2->pdev);\r\nif (err)\r\nplatform_driver_unregister(&uac2->pdrv);\r\nreturn err;\r\n}\r\nstatic void alsa_uac2_exit(struct audio_dev *agdev)\r\n{\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nplatform_driver_unregister(&uac2->pdrv);\r\nplatform_device_unregister(&uac2->pdev);\r\n}\r\nstatic inline void\r\nfree_ep(struct uac2_rtd_params *prm, struct usb_ep *ep)\r\n{\r\nstruct snd_uac2_chip *uac2 = prm->uac2;\r\nint i;\r\nprm->ep_enabled = false;\r\nfor (i = 0; i < USB_XFERS; i++) {\r\nif (prm->ureq[i].req) {\r\nusb_ep_dequeue(ep, prm->ureq[i].req);\r\nusb_ep_free_request(ep, prm->ureq[i].req);\r\nprm->ureq[i].req = NULL;\r\n}\r\n}\r\nif (usb_ep_disable(ep))\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d Error!\n", __func__, __LINE__);\r\n}\r\nstatic int __init\r\nafunc_bind(struct usb_configuration *cfg, struct usb_function *fn)\r\n{\r\nstruct audio_dev *agdev = func_to_agdev(fn);\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nstruct usb_composite_dev *cdev = cfg->cdev;\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nstruct uac2_rtd_params *prm;\r\nint ret;\r\nret = usb_interface_id(cfg, fn);\r\nif (ret < 0) {\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d Error!\n", __func__, __LINE__);\r\nreturn ret;\r\n}\r\nstd_ac_if_desc.bInterfaceNumber = ret;\r\nagdev->ac_intf = ret;\r\nagdev->ac_alt = 0;\r\nret = usb_interface_id(cfg, fn);\r\nif (ret < 0) {\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d Error!\n", __func__, __LINE__);\r\nreturn ret;\r\n}\r\nstd_as_out_if0_desc.bInterfaceNumber = ret;\r\nstd_as_out_if1_desc.bInterfaceNumber = ret;\r\nagdev->as_out_intf = ret;\r\nagdev->as_out_alt = 0;\r\nret = usb_interface_id(cfg, fn);\r\nif (ret < 0) {\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d Error!\n", __func__, __LINE__);\r\nreturn ret;\r\n}\r\nstd_as_in_if0_desc.bInterfaceNumber = ret;\r\nstd_as_in_if1_desc.bInterfaceNumber = ret;\r\nagdev->as_in_intf = ret;\r\nagdev->as_in_alt = 0;\r\nagdev->out_ep = usb_ep_autoconfig(gadget, &fs_epout_desc);\r\nif (!agdev->out_ep) {\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d Error!\n", __func__, __LINE__);\r\ngoto err;\r\n}\r\nagdev->out_ep->driver_data = agdev;\r\nagdev->in_ep = usb_ep_autoconfig(gadget, &fs_epin_desc);\r\nif (!agdev->in_ep) {\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d Error!\n", __func__, __LINE__);\r\ngoto err;\r\n}\r\nagdev->in_ep->driver_data = agdev;\r\nuac2->p_prm.uac2 = uac2;\r\nuac2->c_prm.uac2 = uac2;\r\nhs_epout_desc.bEndpointAddress = fs_epout_desc.bEndpointAddress;\r\nhs_epout_desc.wMaxPacketSize = fs_epout_desc.wMaxPacketSize;\r\nhs_epin_desc.bEndpointAddress = fs_epin_desc.bEndpointAddress;\r\nhs_epin_desc.wMaxPacketSize = fs_epin_desc.wMaxPacketSize;\r\nret = usb_assign_descriptors(fn, fs_audio_desc, hs_audio_desc, NULL);\r\nif (ret)\r\ngoto err;\r\nprm = &agdev->uac2.c_prm;\r\nprm->max_psize = hs_epout_desc.wMaxPacketSize;\r\nprm->rbuf = kzalloc(prm->max_psize * USB_XFERS, GFP_KERNEL);\r\nif (!prm->rbuf) {\r\nprm->max_psize = 0;\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d Error!\n", __func__, __LINE__);\r\ngoto err;\r\n}\r\nprm = &agdev->uac2.p_prm;\r\nprm->max_psize = hs_epin_desc.wMaxPacketSize;\r\nprm->rbuf = kzalloc(prm->max_psize * USB_XFERS, GFP_KERNEL);\r\nif (!prm->rbuf) {\r\nprm->max_psize = 0;\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d Error!\n", __func__, __LINE__);\r\ngoto err;\r\n}\r\nret = alsa_uac2_init(agdev);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nkfree(agdev->uac2.p_prm.rbuf);\r\nkfree(agdev->uac2.c_prm.rbuf);\r\nusb_free_all_descriptors(fn);\r\nif (agdev->in_ep)\r\nagdev->in_ep->driver_data = NULL;\r\nif (agdev->out_ep)\r\nagdev->out_ep->driver_data = NULL;\r\nreturn -EINVAL;\r\n}\r\nstatic void\r\nafunc_unbind(struct usb_configuration *cfg, struct usb_function *fn)\r\n{\r\nstruct audio_dev *agdev = func_to_agdev(fn);\r\nstruct uac2_rtd_params *prm;\r\nalsa_uac2_exit(agdev);\r\nprm = &agdev->uac2.p_prm;\r\nkfree(prm->rbuf);\r\nprm = &agdev->uac2.c_prm;\r\nkfree(prm->rbuf);\r\nusb_free_all_descriptors(fn);\r\nif (agdev->in_ep)\r\nagdev->in_ep->driver_data = NULL;\r\nif (agdev->out_ep)\r\nagdev->out_ep->driver_data = NULL;\r\n}\r\nstatic int\r\nafunc_set_alt(struct usb_function *fn, unsigned intf, unsigned alt)\r\n{\r\nstruct usb_composite_dev *cdev = fn->config->cdev;\r\nstruct audio_dev *agdev = func_to_agdev(fn);\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nstruct usb_request *req;\r\nstruct usb_ep *ep;\r\nstruct uac2_rtd_params *prm;\r\nint i;\r\nif (alt > 1) {\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d Error!\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nif (intf == agdev->ac_intf) {\r\nif (alt) {\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d Error!\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nif (intf == agdev->as_out_intf) {\r\nep = agdev->out_ep;\r\nprm = &uac2->c_prm;\r\nconfig_ep_by_speed(gadget, fn, ep);\r\nagdev->as_out_alt = alt;\r\n} else if (intf == agdev->as_in_intf) {\r\nep = agdev->in_ep;\r\nprm = &uac2->p_prm;\r\nconfig_ep_by_speed(gadget, fn, ep);\r\nagdev->as_in_alt = alt;\r\n} else {\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d Error!\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nif (alt == 0) {\r\nfree_ep(prm, ep);\r\nreturn 0;\r\n}\r\nprm->ep_enabled = true;\r\nusb_ep_enable(ep);\r\nfor (i = 0; i < USB_XFERS; i++) {\r\nif (prm->ureq[i].req) {\r\nif (usb_ep_queue(ep, prm->ureq[i].req, GFP_ATOMIC))\r\ndev_err(&uac2->pdev.dev, "%d Error!\n",\r\n__LINE__);\r\ncontinue;\r\n}\r\nreq = usb_ep_alloc_request(ep, GFP_ATOMIC);\r\nif (req == NULL) {\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d Error!\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nprm->ureq[i].req = req;\r\nprm->ureq[i].pp = prm;\r\nreq->zero = 0;\r\nreq->context = &prm->ureq[i];\r\nreq->length = prm->max_psize;\r\nreq->complete = agdev_iso_complete;\r\nreq->buf = prm->rbuf + i * req->length;\r\nif (usb_ep_queue(ep, req, GFP_ATOMIC))\r\ndev_err(&uac2->pdev.dev, "%d Error!\n", __LINE__);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nafunc_get_alt(struct usb_function *fn, unsigned intf)\r\n{\r\nstruct audio_dev *agdev = func_to_agdev(fn);\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nif (intf == agdev->ac_intf)\r\nreturn agdev->ac_alt;\r\nelse if (intf == agdev->as_out_intf)\r\nreturn agdev->as_out_alt;\r\nelse if (intf == agdev->as_in_intf)\r\nreturn agdev->as_in_alt;\r\nelse\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d Invalid Interface %d!\n",\r\n__func__, __LINE__, intf);\r\nreturn -EINVAL;\r\n}\r\nstatic void\r\nafunc_disable(struct usb_function *fn)\r\n{\r\nstruct audio_dev *agdev = func_to_agdev(fn);\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nfree_ep(&uac2->p_prm, agdev->in_ep);\r\nagdev->as_in_alt = 0;\r\nfree_ep(&uac2->c_prm, agdev->out_ep);\r\nagdev->as_out_alt = 0;\r\n}\r\nstatic int\r\nin_rq_cur(struct usb_function *fn, const struct usb_ctrlrequest *cr)\r\n{\r\nstruct usb_request *req = fn->config->cdev->req;\r\nstruct audio_dev *agdev = func_to_agdev(fn);\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nu16 w_length = le16_to_cpu(cr->wLength);\r\nu16 w_index = le16_to_cpu(cr->wIndex);\r\nu16 w_value = le16_to_cpu(cr->wValue);\r\nu8 entity_id = (w_index >> 8) & 0xff;\r\nu8 control_selector = w_value >> 8;\r\nint value = -EOPNOTSUPP;\r\nif (control_selector == UAC2_CS_CONTROL_SAM_FREQ) {\r\nstruct cntrl_cur_lay3 c;\r\nif (entity_id == USB_IN_CLK_ID)\r\nc.dCUR = p_srate;\r\nelse if (entity_id == USB_OUT_CLK_ID)\r\nc.dCUR = c_srate;\r\nvalue = min_t(unsigned, w_length, sizeof c);\r\nmemcpy(req->buf, &c, value);\r\n} else if (control_selector == UAC2_CS_CONTROL_CLOCK_VALID) {\r\n*(u8 *)req->buf = 1;\r\nvalue = min_t(unsigned, w_length, 1);\r\n} else {\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d control_selector=%d TODO!\n",\r\n__func__, __LINE__, control_selector);\r\n}\r\nreturn value;\r\n}\r\nstatic int\r\nin_rq_range(struct usb_function *fn, const struct usb_ctrlrequest *cr)\r\n{\r\nstruct usb_request *req = fn->config->cdev->req;\r\nstruct audio_dev *agdev = func_to_agdev(fn);\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nu16 w_length = le16_to_cpu(cr->wLength);\r\nu16 w_index = le16_to_cpu(cr->wIndex);\r\nu16 w_value = le16_to_cpu(cr->wValue);\r\nu8 entity_id = (w_index >> 8) & 0xff;\r\nu8 control_selector = w_value >> 8;\r\nstruct cntrl_range_lay3 r;\r\nint value = -EOPNOTSUPP;\r\nif (control_selector == UAC2_CS_CONTROL_SAM_FREQ) {\r\nif (entity_id == USB_IN_CLK_ID)\r\nr.dMIN = p_srate;\r\nelse if (entity_id == USB_OUT_CLK_ID)\r\nr.dMIN = c_srate;\r\nelse\r\nreturn -EOPNOTSUPP;\r\nr.dMAX = r.dMIN;\r\nr.dRES = 0;\r\nr.wNumSubRanges = 1;\r\nvalue = min_t(unsigned, w_length, sizeof r);\r\nmemcpy(req->buf, &r, value);\r\n} else {\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d control_selector=%d TODO!\n",\r\n__func__, __LINE__, control_selector);\r\n}\r\nreturn value;\r\n}\r\nstatic int\r\nac_rq_in(struct usb_function *fn, const struct usb_ctrlrequest *cr)\r\n{\r\nif (cr->bRequest == UAC2_CS_CUR)\r\nreturn in_rq_cur(fn, cr);\r\nelse if (cr->bRequest == UAC2_CS_RANGE)\r\nreturn in_rq_range(fn, cr);\r\nelse\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int\r\nout_rq_cur(struct usb_function *fn, const struct usb_ctrlrequest *cr)\r\n{\r\nu16 w_length = le16_to_cpu(cr->wLength);\r\nu16 w_value = le16_to_cpu(cr->wValue);\r\nu8 control_selector = w_value >> 8;\r\nif (control_selector == UAC2_CS_CONTROL_SAM_FREQ)\r\nreturn w_length;\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int\r\nsetup_rq_inf(struct usb_function *fn, const struct usb_ctrlrequest *cr)\r\n{\r\nstruct audio_dev *agdev = func_to_agdev(fn);\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nu16 w_index = le16_to_cpu(cr->wIndex);\r\nu8 intf = w_index & 0xff;\r\nif (intf != agdev->ac_intf) {\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d Error!\n", __func__, __LINE__);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (cr->bRequestType & USB_DIR_IN)\r\nreturn ac_rq_in(fn, cr);\r\nelse if (cr->bRequest == UAC2_CS_CUR)\r\nreturn out_rq_cur(fn, cr);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int\r\nafunc_setup(struct usb_function *fn, const struct usb_ctrlrequest *cr)\r\n{\r\nstruct usb_composite_dev *cdev = fn->config->cdev;\r\nstruct audio_dev *agdev = func_to_agdev(fn);\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nstruct usb_request *req = cdev->req;\r\nu16 w_length = le16_to_cpu(cr->wLength);\r\nint value = -EOPNOTSUPP;\r\nif ((cr->bRequestType & USB_TYPE_MASK) != USB_TYPE_CLASS)\r\nreturn -EOPNOTSUPP;\r\nif ((cr->bRequestType & USB_RECIP_MASK) == USB_RECIP_INTERFACE)\r\nvalue = setup_rq_inf(fn, cr);\r\nelse\r\ndev_err(&uac2->pdev.dev, "%s:%d Error!\n", __func__, __LINE__);\r\nif (value >= 0) {\r\nreq->length = value;\r\nreq->zero = value < w_length;\r\nvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\r\nif (value < 0) {\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d Error!\n", __func__, __LINE__);\r\nreq->status = 0;\r\n}\r\n}\r\nreturn value;\r\n}\r\nstatic int audio_bind_config(struct usb_configuration *cfg)\r\n{\r\nint res;\r\nagdev_g = kzalloc(sizeof *agdev_g, GFP_KERNEL);\r\nif (agdev_g == NULL) {\r\nprintk(KERN_ERR "Unable to allocate audio gadget\n");\r\nreturn -ENOMEM;\r\n}\r\nres = usb_string_ids_tab(cfg->cdev, strings_fn);\r\nif (res)\r\nreturn res;\r\niad_desc.iFunction = strings_fn[STR_ASSOC].id;\r\nstd_ac_if_desc.iInterface = strings_fn[STR_IF_CTRL].id;\r\nin_clk_src_desc.iClockSource = strings_fn[STR_CLKSRC_IN].id;\r\nout_clk_src_desc.iClockSource = strings_fn[STR_CLKSRC_OUT].id;\r\nusb_out_it_desc.iTerminal = strings_fn[STR_USB_IT].id;\r\nio_in_it_desc.iTerminal = strings_fn[STR_IO_IT].id;\r\nusb_in_ot_desc.iTerminal = strings_fn[STR_USB_OT].id;\r\nio_out_ot_desc.iTerminal = strings_fn[STR_IO_OT].id;\r\nstd_as_out_if0_desc.iInterface = strings_fn[STR_AS_OUT_ALT0].id;\r\nstd_as_out_if1_desc.iInterface = strings_fn[STR_AS_OUT_ALT1].id;\r\nstd_as_in_if0_desc.iInterface = strings_fn[STR_AS_IN_ALT0].id;\r\nstd_as_in_if1_desc.iInterface = strings_fn[STR_AS_IN_ALT1].id;\r\nagdev_g->func.name = "uac2_func";\r\nagdev_g->func.strings = fn_strings;\r\nagdev_g->func.bind = afunc_bind;\r\nagdev_g->func.unbind = afunc_unbind;\r\nagdev_g->func.set_alt = afunc_set_alt;\r\nagdev_g->func.get_alt = afunc_get_alt;\r\nagdev_g->func.disable = afunc_disable;\r\nagdev_g->func.setup = afunc_setup;\r\nusb_out_it_desc.bNrChannels = num_channels(c_chmask);\r\nusb_out_it_desc.bmChannelConfig = cpu_to_le32(c_chmask);\r\nio_in_it_desc.bNrChannels = num_channels(p_chmask);\r\nio_in_it_desc.bmChannelConfig = cpu_to_le32(p_chmask);\r\nas_out_hdr_desc.bNrChannels = num_channels(c_chmask);\r\nas_out_hdr_desc.bmChannelConfig = cpu_to_le32(c_chmask);\r\nas_in_hdr_desc.bNrChannels = num_channels(p_chmask);\r\nas_in_hdr_desc.bmChannelConfig = cpu_to_le32(p_chmask);\r\nas_out_fmt1_desc.bSubslotSize = c_ssize;\r\nas_out_fmt1_desc.bBitResolution = c_ssize * 8;\r\nas_in_fmt1_desc.bSubslotSize = p_ssize;\r\nas_in_fmt1_desc.bBitResolution = p_ssize * 8;\r\nsnprintf(clksrc_in, sizeof(clksrc_in), "%uHz", p_srate);\r\nsnprintf(clksrc_out, sizeof(clksrc_out), "%uHz", c_srate);\r\nres = usb_add_function(cfg, &agdev_g->func);\r\nif (res < 0)\r\nkfree(agdev_g);\r\nreturn res;\r\n}\r\nstatic void\r\nuac2_unbind_config(struct usb_configuration *cfg)\r\n{\r\nkfree(agdev_g);\r\nagdev_g = NULL;\r\n}
