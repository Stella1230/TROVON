static int ricoh_probe(struct sdhci_pci_chip *chip)\r\n{\r\nif (chip->pdev->subsystem_vendor == PCI_VENDOR_ID_SAMSUNG ||\r\nchip->pdev->subsystem_vendor == PCI_VENDOR_ID_SONY)\r\nchip->quirks |= SDHCI_QUIRK_NO_CARD_NO_RESET;\r\nreturn 0;\r\n}\r\nstatic int ricoh_mmc_probe_slot(struct sdhci_pci_slot *slot)\r\n{\r\nslot->host->caps =\r\n((0x21 << SDHCI_TIMEOUT_CLK_SHIFT)\r\n& SDHCI_TIMEOUT_CLK_MASK) |\r\n((0x21 << SDHCI_CLOCK_BASE_SHIFT)\r\n& SDHCI_CLOCK_BASE_MASK) |\r\nSDHCI_TIMEOUT_CLK_UNIT |\r\nSDHCI_CAN_VDD_330 |\r\nSDHCI_CAN_DO_HISPD |\r\nSDHCI_CAN_DO_SDMA;\r\nreturn 0;\r\n}\r\nstatic int ricoh_mmc_resume(struct sdhci_pci_chip *chip)\r\n{\r\nmsleep(500);\r\nreturn 0;\r\n}\r\nstatic int mrst_hc_probe_slot(struct sdhci_pci_slot *slot)\r\n{\r\nslot->host->mmc->caps |= MMC_CAP_8_BIT_DATA;\r\nreturn 0;\r\n}\r\nstatic int mrst_hc_probe(struct sdhci_pci_chip *chip)\r\n{\r\nchip->num_slots = 1;\r\nreturn 0;\r\n}\r\nstatic int pch_hc_probe_slot(struct sdhci_pci_slot *slot)\r\n{\r\nslot->host->mmc->caps |= MMC_CAP_8_BIT_DATA;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t sdhci_pci_sd_cd(int irq, void *dev_id)\r\n{\r\nstruct sdhci_pci_slot *slot = dev_id;\r\nstruct sdhci_host *host = slot->host;\r\nmmc_detect_change(host->mmc, msecs_to_jiffies(200));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sdhci_pci_add_own_cd(struct sdhci_pci_slot *slot)\r\n{\r\nint err, irq, gpio = slot->cd_gpio;\r\nslot->cd_gpio = -EINVAL;\r\nslot->cd_irq = -EINVAL;\r\nif (!gpio_is_valid(gpio))\r\nreturn;\r\nerr = gpio_request(gpio, "sd_cd");\r\nif (err < 0)\r\ngoto out;\r\nerr = gpio_direction_input(gpio);\r\nif (err < 0)\r\ngoto out_free;\r\nirq = gpio_to_irq(gpio);\r\nif (irq < 0)\r\ngoto out_free;\r\nerr = request_irq(irq, sdhci_pci_sd_cd, IRQF_TRIGGER_RISING |\r\nIRQF_TRIGGER_FALLING, "sd_cd", slot);\r\nif (err)\r\ngoto out_free;\r\nslot->cd_gpio = gpio;\r\nslot->cd_irq = irq;\r\nreturn;\r\nout_free:\r\ngpio_free(gpio);\r\nout:\r\ndev_warn(&slot->chip->pdev->dev, "failed to setup card detect wake up\n");\r\n}\r\nstatic void sdhci_pci_remove_own_cd(struct sdhci_pci_slot *slot)\r\n{\r\nif (slot->cd_irq >= 0)\r\nfree_irq(slot->cd_irq, slot);\r\nif (gpio_is_valid(slot->cd_gpio))\r\ngpio_free(slot->cd_gpio);\r\n}\r\nstatic inline void sdhci_pci_add_own_cd(struct sdhci_pci_slot *slot)\r\n{\r\n}\r\nstatic inline void sdhci_pci_remove_own_cd(struct sdhci_pci_slot *slot)\r\n{\r\n}\r\nstatic int mfd_emmc_probe_slot(struct sdhci_pci_slot *slot)\r\n{\r\nslot->host->mmc->caps |= MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE;\r\nslot->host->mmc->caps2 |= MMC_CAP2_BOOTPART_NOACC |\r\nMMC_CAP2_HC_ERASE_SZ;\r\nreturn 0;\r\n}\r\nstatic int mfd_sdio_probe_slot(struct sdhci_pci_slot *slot)\r\n{\r\nslot->host->mmc->caps |= MMC_CAP_POWER_OFF_CARD | MMC_CAP_NONREMOVABLE;\r\nreturn 0;\r\n}\r\nstatic void sdhci_pci_int_hw_reset(struct sdhci_host *host)\r\n{\r\nu8 reg;\r\nreg = sdhci_readb(host, SDHCI_POWER_CONTROL);\r\nreg |= 0x10;\r\nsdhci_writeb(host, reg, SDHCI_POWER_CONTROL);\r\nudelay(9);\r\nreg &= ~0x10;\r\nsdhci_writeb(host, reg, SDHCI_POWER_CONTROL);\r\nusleep_range(300, 1000);\r\n}\r\nstatic int byt_emmc_probe_slot(struct sdhci_pci_slot *slot)\r\n{\r\nslot->host->mmc->caps |= MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE |\r\nMMC_CAP_HW_RESET;\r\nslot->host->mmc->caps2 |= MMC_CAP2_HC_ERASE_SZ;\r\nslot->hw_reset = sdhci_pci_int_hw_reset;\r\nreturn 0;\r\n}\r\nstatic int byt_sdio_probe_slot(struct sdhci_pci_slot *slot)\r\n{\r\nslot->host->mmc->caps |= MMC_CAP_POWER_OFF_CARD | MMC_CAP_NONREMOVABLE;\r\nreturn 0;\r\n}\r\nstatic int o2_probe(struct sdhci_pci_chip *chip)\r\n{\r\nint ret;\r\nu8 scratch;\r\nswitch (chip->pdev->device) {\r\ncase PCI_DEVICE_ID_O2_8220:\r\ncase PCI_DEVICE_ID_O2_8221:\r\ncase PCI_DEVICE_ID_O2_8320:\r\ncase PCI_DEVICE_ID_O2_8321:\r\nret = pci_read_config_byte(chip->pdev, O2_SD_LOCK_WP, &scratch);\r\nif (ret)\r\nreturn ret;\r\nscratch &= 0x7f;\r\npci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch);\r\npci_write_config_byte(chip->pdev, O2_SD_MULTI_VCC3V, 0x08);\r\nret = pci_read_config_byte(chip->pdev, O2_SD_CLKREQ, &scratch);\r\nif (ret)\r\nreturn ret;\r\nscratch |= 0x20;\r\npci_write_config_byte(chip->pdev, O2_SD_CLKREQ, scratch);\r\nret = pci_read_config_byte(chip->pdev, O2_SD_CAPS, &scratch);\r\nif (ret)\r\nreturn ret;\r\nscratch |= 0x01;\r\npci_write_config_byte(chip->pdev, O2_SD_CAPS, scratch);\r\npci_write_config_byte(chip->pdev, O2_SD_CAPS, 0x73);\r\npci_write_config_byte(chip->pdev, O2_SD_ADMA1, 0x39);\r\npci_write_config_byte(chip->pdev, O2_SD_ADMA2, 0x08);\r\nret = pci_read_config_byte(chip->pdev, O2_SD_INF_MOD, &scratch);\r\nif (ret)\r\nreturn ret;\r\nscratch |= 0x08;\r\npci_write_config_byte(chip->pdev, O2_SD_INF_MOD, scratch);\r\nret = pci_read_config_byte(chip->pdev, O2_SD_LOCK_WP, &scratch);\r\nif (ret)\r\nreturn ret;\r\nscratch |= 0x80;\r\npci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch);\r\n}\r\nreturn 0;\r\n}\r\nstatic int jmicron_pmos(struct sdhci_pci_chip *chip, int on)\r\n{\r\nu8 scratch;\r\nint ret;\r\nret = pci_read_config_byte(chip->pdev, 0xAE, &scratch);\r\nif (ret)\r\nreturn ret;\r\nif (on)\r\nscratch |= 0x47;\r\nelse\r\nscratch &= ~0x47;\r\nret = pci_write_config_byte(chip->pdev, 0xAE, scratch);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int jmicron_probe(struct sdhci_pci_chip *chip)\r\n{\r\nint ret;\r\nu16 mmcdev = 0;\r\nif (chip->pdev->revision == 0) {\r\nchip->quirks |= SDHCI_QUIRK_32BIT_DMA_ADDR |\r\nSDHCI_QUIRK_32BIT_DMA_SIZE |\r\nSDHCI_QUIRK_32BIT_ADMA_SIZE |\r\nSDHCI_QUIRK_RESET_AFTER_REQUEST |\r\nSDHCI_QUIRK_BROKEN_SMALL_PIO;\r\n}\r\nif (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_SD)\r\nmmcdev = PCI_DEVICE_ID_JMICRON_JMB38X_MMC;\r\nelse if (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_SD)\r\nmmcdev = PCI_DEVICE_ID_JMICRON_JMB388_ESD;\r\nif (mmcdev) {\r\nstruct pci_dev *sd_dev;\r\nsd_dev = NULL;\r\nwhile ((sd_dev = pci_get_device(PCI_VENDOR_ID_JMICRON,\r\nmmcdev, sd_dev)) != NULL) {\r\nif ((PCI_SLOT(chip->pdev->devfn) ==\r\nPCI_SLOT(sd_dev->devfn)) &&\r\n(chip->pdev->bus == sd_dev->bus))\r\nbreak;\r\n}\r\nif (sd_dev) {\r\npci_dev_put(sd_dev);\r\ndev_info(&chip->pdev->dev, "Refusing to bind to "\r\n"secondary interface.\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nret = jmicron_pmos(chip, 1);\r\nif (ret) {\r\ndev_err(&chip->pdev->dev, "Failure enabling card power\n");\r\nreturn ret;\r\n}\r\nif (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_SD ||\r\nchip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD)\r\nchip->quirks |= SDHCI_QUIRK_UNSTABLE_RO_DETECT;\r\nreturn 0;\r\n}\r\nstatic void jmicron_enable_mmc(struct sdhci_host *host, int on)\r\n{\r\nu8 scratch;\r\nscratch = readb(host->ioaddr + 0xC0);\r\nif (on)\r\nscratch |= 0x01;\r\nelse\r\nscratch &= ~0x01;\r\nwriteb(scratch, host->ioaddr + 0xC0);\r\n}\r\nstatic int jmicron_probe_slot(struct sdhci_pci_slot *slot)\r\n{\r\nif (slot->chip->pdev->revision == 0) {\r\nu16 version;\r\nversion = readl(slot->host->ioaddr + SDHCI_HOST_VERSION);\r\nversion = (version & SDHCI_VENDOR_VER_MASK) >>\r\nSDHCI_VENDOR_VER_SHIFT;\r\nif (version < 0xAC)\r\nslot->host->quirks |= SDHCI_QUIRK_BROKEN_ADMA;\r\n}\r\nif (slot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD) {\r\nslot->host->ocr_avail_sd = MMC_VDD_32_33 | MMC_VDD_33_34 |\r\nMMC_VDD_29_30 | MMC_VDD_30_31 |\r\nMMC_VDD_165_195;\r\nslot->host->ocr_avail_mmc = MMC_VDD_32_33 | MMC_VDD_33_34 |\r\nMMC_VDD_29_30 | MMC_VDD_30_31;\r\n}\r\nif (slot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_MMC ||\r\nslot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD)\r\njmicron_enable_mmc(slot->host, 1);\r\nslot->host->mmc->caps |= MMC_CAP_BUS_WIDTH_TEST;\r\nreturn 0;\r\n}\r\nstatic void jmicron_remove_slot(struct sdhci_pci_slot *slot, int dead)\r\n{\r\nif (dead)\r\nreturn;\r\nif (slot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_MMC ||\r\nslot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD)\r\njmicron_enable_mmc(slot->host, 0);\r\n}\r\nstatic int jmicron_suspend(struct sdhci_pci_chip *chip)\r\n{\r\nint i;\r\nif (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_MMC ||\r\nchip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD) {\r\nfor (i = 0; i < chip->num_slots; i++)\r\njmicron_enable_mmc(chip->slots[i]->host, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int jmicron_resume(struct sdhci_pci_chip *chip)\r\n{\r\nint ret, i;\r\nif (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_MMC ||\r\nchip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD) {\r\nfor (i = 0; i < chip->num_slots; i++)\r\njmicron_enable_mmc(chip->slots[i]->host, 1);\r\n}\r\nret = jmicron_pmos(chip, 1);\r\nif (ret) {\r\ndev_err(&chip->pdev->dev, "Failure enabling card power\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int syskt_probe(struct sdhci_pci_chip *chip)\r\n{\r\nif ((chip->pdev->class & 0x0000FF) == PCI_SDHCI_IFVENDOR) {\r\nchip->pdev->class &= ~0x0000FF;\r\nchip->pdev->class |= PCI_SDHCI_IFDMA;\r\n}\r\nreturn 0;\r\n}\r\nstatic int syskt_probe_slot(struct sdhci_pci_slot *slot)\r\n{\r\nint tm, ps;\r\nu8 board_rev = readb(slot->host->ioaddr + SYSKT_BOARD_REV);\r\nu8 chip_rev = readb(slot->host->ioaddr + SYSKT_CHIP_REV);\r\ndev_info(&slot->chip->pdev->dev, "SysKonnect CardBus2SDIO, "\r\n"board rev %d.%d, chip rev %d.%d\n",\r\nboard_rev >> 4, board_rev & 0xf,\r\nchip_rev >> 4, chip_rev & 0xf);\r\nif (chip_rev >= 0x20)\r\nslot->host->quirks |= SDHCI_QUIRK_FORCE_DMA;\r\nwriteb(SYSKT_POWER_330, slot->host->ioaddr + SYSKT_POWER_DATA);\r\nwriteb(SYSKT_POWER_START, slot->host->ioaddr + SYSKT_POWER_CMD);\r\nudelay(50);\r\ntm = 10;\r\ndo {\r\nps = readw(slot->host->ioaddr + SYSKT_POWER_STATUS);\r\nif (ps & SYSKT_POWER_STATUS_OK)\r\nbreak;\r\nudelay(100);\r\n} while (--tm);\r\nif (!tm) {\r\ndev_err(&slot->chip->pdev->dev,\r\n"power regulator never stabilized");\r\nwriteb(0, slot->host->ioaddr + SYSKT_POWER_CMD);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int via_probe(struct sdhci_pci_chip *chip)\r\n{\r\nif (chip->pdev->revision == 0x10)\r\nchip->quirks |= SDHCI_QUIRK_DELAY_AFTER_POWER;\r\nreturn 0;\r\n}\r\nstatic int sdhci_pci_enable_dma(struct sdhci_host *host)\r\n{\r\nstruct sdhci_pci_slot *slot;\r\nstruct pci_dev *pdev;\r\nint ret;\r\nslot = sdhci_priv(host);\r\npdev = slot->chip->pdev;\r\nif (((pdev->class & 0xFFFF00) == (PCI_CLASS_SYSTEM_SDHCI << 8)) &&\r\n((pdev->class & 0x0000FF) != PCI_SDHCI_IFDMA) &&\r\n(host->flags & SDHCI_USE_SDMA)) {\r\ndev_warn(&pdev->dev, "Will use DMA mode even though HW "\r\n"doesn't fully claim to support it.\n");\r\n}\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret)\r\nreturn ret;\r\npci_set_master(pdev);\r\nreturn 0;\r\n}\r\nstatic int sdhci_pci_bus_width(struct sdhci_host *host, int width)\r\n{\r\nu8 ctrl;\r\nctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);\r\nswitch (width) {\r\ncase MMC_BUS_WIDTH_8:\r\nctrl |= SDHCI_CTRL_8BITBUS;\r\nctrl &= ~SDHCI_CTRL_4BITBUS;\r\nbreak;\r\ncase MMC_BUS_WIDTH_4:\r\nctrl |= SDHCI_CTRL_4BITBUS;\r\nctrl &= ~SDHCI_CTRL_8BITBUS;\r\nbreak;\r\ndefault:\r\nctrl &= ~(SDHCI_CTRL_8BITBUS | SDHCI_CTRL_4BITBUS);\r\nbreak;\r\n}\r\nsdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);\r\nreturn 0;\r\n}\r\nstatic void sdhci_pci_gpio_hw_reset(struct sdhci_host *host)\r\n{\r\nstruct sdhci_pci_slot *slot = sdhci_priv(host);\r\nint rst_n_gpio = slot->rst_n_gpio;\r\nif (!gpio_is_valid(rst_n_gpio))\r\nreturn;\r\ngpio_set_value_cansleep(rst_n_gpio, 0);\r\nudelay(10);\r\ngpio_set_value_cansleep(rst_n_gpio, 1);\r\nusleep_range(300, 1000);\r\n}\r\nstatic void sdhci_pci_hw_reset(struct sdhci_host *host)\r\n{\r\nstruct sdhci_pci_slot *slot = sdhci_priv(host);\r\nif (slot->hw_reset)\r\nslot->hw_reset(host);\r\n}\r\nstatic int sdhci_pci_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct sdhci_pci_chip *chip;\r\nstruct sdhci_pci_slot *slot;\r\nmmc_pm_flag_t slot_pm_flags;\r\nmmc_pm_flag_t pm_flags = 0;\r\nint i, ret;\r\nchip = pci_get_drvdata(pdev);\r\nif (!chip)\r\nreturn 0;\r\nfor (i = 0; i < chip->num_slots; i++) {\r\nslot = chip->slots[i];\r\nif (!slot)\r\ncontinue;\r\nret = sdhci_suspend_host(slot->host);\r\nif (ret)\r\ngoto err_pci_suspend;\r\nslot_pm_flags = slot->host->mmc->pm_flags;\r\nif (slot_pm_flags & MMC_PM_WAKE_SDIO_IRQ)\r\nsdhci_enable_irq_wakeups(slot->host);\r\npm_flags |= slot_pm_flags;\r\n}\r\nif (chip->fixes && chip->fixes->suspend) {\r\nret = chip->fixes->suspend(chip);\r\nif (ret)\r\ngoto err_pci_suspend;\r\n}\r\npci_save_state(pdev);\r\nif (pm_flags & MMC_PM_KEEP_POWER) {\r\nif (pm_flags & MMC_PM_WAKE_SDIO_IRQ) {\r\npci_pme_active(pdev, true);\r\npci_enable_wake(pdev, PCI_D3hot, 1);\r\n}\r\npci_set_power_state(pdev, PCI_D3hot);\r\n} else {\r\npci_enable_wake(pdev, PCI_D3hot, 0);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, PCI_D3hot);\r\n}\r\nreturn 0;\r\nerr_pci_suspend:\r\nwhile (--i >= 0)\r\nsdhci_resume_host(chip->slots[i]->host);\r\nreturn ret;\r\n}\r\nstatic int sdhci_pci_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct sdhci_pci_chip *chip;\r\nstruct sdhci_pci_slot *slot;\r\nint i, ret;\r\nchip = pci_get_drvdata(pdev);\r\nif (!chip)\r\nreturn 0;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nret = pci_enable_device(pdev);\r\nif (ret)\r\nreturn ret;\r\nif (chip->fixes && chip->fixes->resume) {\r\nret = chip->fixes->resume(chip);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < chip->num_slots; i++) {\r\nslot = chip->slots[i];\r\nif (!slot)\r\ncontinue;\r\nret = sdhci_resume_host(slot->host);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sdhci_pci_runtime_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = container_of(dev, struct pci_dev, dev);\r\nstruct sdhci_pci_chip *chip;\r\nstruct sdhci_pci_slot *slot;\r\nint i, ret;\r\nchip = pci_get_drvdata(pdev);\r\nif (!chip)\r\nreturn 0;\r\nfor (i = 0; i < chip->num_slots; i++) {\r\nslot = chip->slots[i];\r\nif (!slot)\r\ncontinue;\r\nret = sdhci_runtime_suspend_host(slot->host);\r\nif (ret)\r\ngoto err_pci_runtime_suspend;\r\n}\r\nif (chip->fixes && chip->fixes->suspend) {\r\nret = chip->fixes->suspend(chip);\r\nif (ret)\r\ngoto err_pci_runtime_suspend;\r\n}\r\nreturn 0;\r\nerr_pci_runtime_suspend:\r\nwhile (--i >= 0)\r\nsdhci_runtime_resume_host(chip->slots[i]->host);\r\nreturn ret;\r\n}\r\nstatic int sdhci_pci_runtime_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = container_of(dev, struct pci_dev, dev);\r\nstruct sdhci_pci_chip *chip;\r\nstruct sdhci_pci_slot *slot;\r\nint i, ret;\r\nchip = pci_get_drvdata(pdev);\r\nif (!chip)\r\nreturn 0;\r\nif (chip->fixes && chip->fixes->resume) {\r\nret = chip->fixes->resume(chip);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < chip->num_slots; i++) {\r\nslot = chip->slots[i];\r\nif (!slot)\r\ncontinue;\r\nret = sdhci_runtime_resume_host(slot->host);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sdhci_pci_runtime_idle(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic struct sdhci_pci_slot *sdhci_pci_probe_slot(\r\nstruct pci_dev *pdev, struct sdhci_pci_chip *chip, int first_bar,\r\nint slotno)\r\n{\r\nstruct sdhci_pci_slot *slot;\r\nstruct sdhci_host *host;\r\nint ret, bar = first_bar + slotno;\r\nif (!(pci_resource_flags(pdev, bar) & IORESOURCE_MEM)) {\r\ndev_err(&pdev->dev, "BAR %d is not iomem. Aborting.\n", bar);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nif (pci_resource_len(pdev, bar) < 0x100) {\r\ndev_err(&pdev->dev, "Invalid iomem size. You may "\r\n"experience problems.\n");\r\n}\r\nif ((pdev->class & 0x0000FF) == PCI_SDHCI_IFVENDOR) {\r\ndev_err(&pdev->dev, "Vendor specific interface. Aborting.\n");\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nif ((pdev->class & 0x0000FF) > PCI_SDHCI_IFVENDOR) {\r\ndev_err(&pdev->dev, "Unknown interface. Aborting.\n");\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nhost = sdhci_alloc_host(&pdev->dev, sizeof(struct sdhci_pci_slot));\r\nif (IS_ERR(host)) {\r\ndev_err(&pdev->dev, "cannot allocate host\n");\r\nreturn ERR_CAST(host);\r\n}\r\nslot = sdhci_priv(host);\r\nslot->chip = chip;\r\nslot->host = host;\r\nslot->pci_bar = bar;\r\nslot->rst_n_gpio = -EINVAL;\r\nslot->cd_gpio = -EINVAL;\r\nif (*sdhci_pci_get_data)\r\nslot->data = sdhci_pci_get_data(pdev, slotno);\r\nif (slot->data) {\r\nif (slot->data->setup) {\r\nret = slot->data->setup(slot->data);\r\nif (ret) {\r\ndev_err(&pdev->dev, "platform setup failed\n");\r\ngoto free;\r\n}\r\n}\r\nslot->rst_n_gpio = slot->data->rst_n_gpio;\r\nslot->cd_gpio = slot->data->cd_gpio;\r\n}\r\nhost->hw_name = "PCI";\r\nhost->ops = &sdhci_pci_ops;\r\nhost->quirks = chip->quirks;\r\nhost->quirks2 = chip->quirks2;\r\nhost->irq = pdev->irq;\r\nret = pci_request_region(pdev, bar, mmc_hostname(host->mmc));\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot request region\n");\r\ngoto cleanup;\r\n}\r\nhost->ioaddr = pci_ioremap_bar(pdev, bar);\r\nif (!host->ioaddr) {\r\ndev_err(&pdev->dev, "failed to remap registers\n");\r\nret = -ENOMEM;\r\ngoto release;\r\n}\r\nif (chip->fixes && chip->fixes->probe_slot) {\r\nret = chip->fixes->probe_slot(slot);\r\nif (ret)\r\ngoto unmap;\r\n}\r\nif (gpio_is_valid(slot->rst_n_gpio)) {\r\nif (!gpio_request(slot->rst_n_gpio, "eMMC_reset")) {\r\ngpio_direction_output(slot->rst_n_gpio, 1);\r\nslot->host->mmc->caps |= MMC_CAP_HW_RESET;\r\nslot->hw_reset = sdhci_pci_gpio_hw_reset;\r\n} else {\r\ndev_warn(&pdev->dev, "failed to request rst_n_gpio\n");\r\nslot->rst_n_gpio = -EINVAL;\r\n}\r\n}\r\nhost->mmc->pm_caps = MMC_PM_KEEP_POWER | MMC_PM_WAKE_SDIO_IRQ;\r\nhost->mmc->slotno = slotno;\r\nhost->mmc->caps2 |= MMC_CAP2_NO_PRESCAN_POWERUP;\r\nret = sdhci_add_host(host);\r\nif (ret)\r\ngoto remove;\r\nsdhci_pci_add_own_cd(slot);\r\nreturn slot;\r\nremove:\r\nif (gpio_is_valid(slot->rst_n_gpio))\r\ngpio_free(slot->rst_n_gpio);\r\nif (chip->fixes && chip->fixes->remove_slot)\r\nchip->fixes->remove_slot(slot, 0);\r\nunmap:\r\niounmap(host->ioaddr);\r\nrelease:\r\npci_release_region(pdev, bar);\r\ncleanup:\r\nif (slot->data && slot->data->cleanup)\r\nslot->data->cleanup(slot->data);\r\nfree:\r\nsdhci_free_host(host);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void sdhci_pci_remove_slot(struct sdhci_pci_slot *slot)\r\n{\r\nint dead;\r\nu32 scratch;\r\nsdhci_pci_remove_own_cd(slot);\r\ndead = 0;\r\nscratch = readl(slot->host->ioaddr + SDHCI_INT_STATUS);\r\nif (scratch == (u32)-1)\r\ndead = 1;\r\nsdhci_remove_host(slot->host, dead);\r\nif (gpio_is_valid(slot->rst_n_gpio))\r\ngpio_free(slot->rst_n_gpio);\r\nif (slot->chip->fixes && slot->chip->fixes->remove_slot)\r\nslot->chip->fixes->remove_slot(slot, dead);\r\nif (slot->data && slot->data->cleanup)\r\nslot->data->cleanup(slot->data);\r\npci_release_region(slot->chip->pdev, slot->pci_bar);\r\nsdhci_free_host(slot->host);\r\n}\r\nstatic void sdhci_pci_runtime_pm_allow(struct device *dev)\r\n{\r\npm_runtime_put_noidle(dev);\r\npm_runtime_allow(dev);\r\npm_runtime_set_autosuspend_delay(dev, 50);\r\npm_runtime_use_autosuspend(dev);\r\npm_suspend_ignore_children(dev, 1);\r\n}\r\nstatic void sdhci_pci_runtime_pm_forbid(struct device *dev)\r\n{\r\npm_runtime_forbid(dev);\r\npm_runtime_get_noresume(dev);\r\n}\r\nstatic int sdhci_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct sdhci_pci_chip *chip;\r\nstruct sdhci_pci_slot *slot;\r\nu8 slots, first_bar;\r\nint ret, i;\r\nBUG_ON(pdev == NULL);\r\nBUG_ON(ent == NULL);\r\ndev_info(&pdev->dev, "SDHCI controller found [%04x:%04x] (rev %x)\n",\r\n(int)pdev->vendor, (int)pdev->device, (int)pdev->revision);\r\nret = pci_read_config_byte(pdev, PCI_SLOT_INFO, &slots);\r\nif (ret)\r\nreturn ret;\r\nslots = PCI_SLOT_INFO_SLOTS(slots) + 1;\r\ndev_dbg(&pdev->dev, "found %d slot(s)\n", slots);\r\nif (slots == 0)\r\nreturn -ENODEV;\r\nBUG_ON(slots > MAX_SLOTS);\r\nret = pci_read_config_byte(pdev, PCI_SLOT_INFO, &first_bar);\r\nif (ret)\r\nreturn ret;\r\nfirst_bar &= PCI_SLOT_INFO_FIRST_BAR_MASK;\r\nif (first_bar > 5) {\r\ndev_err(&pdev->dev, "Invalid first BAR. Aborting.\n");\r\nreturn -ENODEV;\r\n}\r\nret = pci_enable_device(pdev);\r\nif (ret)\r\nreturn ret;\r\nchip = kzalloc(sizeof(struct sdhci_pci_chip), GFP_KERNEL);\r\nif (!chip) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nchip->pdev = pdev;\r\nchip->fixes = (const struct sdhci_pci_fixes *)ent->driver_data;\r\nif (chip->fixes) {\r\nchip->quirks = chip->fixes->quirks;\r\nchip->quirks2 = chip->fixes->quirks2;\r\nchip->allow_runtime_pm = chip->fixes->allow_runtime_pm;\r\n}\r\nchip->num_slots = slots;\r\npci_set_drvdata(pdev, chip);\r\nif (chip->fixes && chip->fixes->probe) {\r\nret = chip->fixes->probe(chip);\r\nif (ret)\r\ngoto free;\r\n}\r\nslots = chip->num_slots;\r\nfor (i = 0; i < slots; i++) {\r\nslot = sdhci_pci_probe_slot(pdev, chip, first_bar, i);\r\nif (IS_ERR(slot)) {\r\nfor (i--; i >= 0; i--)\r\nsdhci_pci_remove_slot(chip->slots[i]);\r\nret = PTR_ERR(slot);\r\ngoto free;\r\n}\r\nchip->slots[i] = slot;\r\n}\r\nif (chip->allow_runtime_pm)\r\nsdhci_pci_runtime_pm_allow(&pdev->dev);\r\nreturn 0;\r\nfree:\r\npci_set_drvdata(pdev, NULL);\r\nkfree(chip);\r\nerr:\r\npci_disable_device(pdev);\r\nreturn ret;\r\n}\r\nstatic void sdhci_pci_remove(struct pci_dev *pdev)\r\n{\r\nint i;\r\nstruct sdhci_pci_chip *chip;\r\nchip = pci_get_drvdata(pdev);\r\nif (chip) {\r\nif (chip->allow_runtime_pm)\r\nsdhci_pci_runtime_pm_forbid(&pdev->dev);\r\nfor (i = 0; i < chip->num_slots; i++)\r\nsdhci_pci_remove_slot(chip->slots[i]);\r\npci_set_drvdata(pdev, NULL);\r\nkfree(chip);\r\n}\r\npci_disable_device(pdev);\r\n}
