fnic_trace_data_t *fnic_trace_get_buf(void)\r\n{\r\nunsigned long fnic_buf_head;\r\nunsigned long flags;\r\nspin_lock_irqsave(&fnic_trace_lock, flags);\r\nfnic_buf_head =\r\nfnic_trace_entries.page_offset[fnic_trace_entries.wr_idx];\r\nfnic_trace_entries.wr_idx++;\r\nif (fnic_trace_entries.wr_idx >= fnic_max_trace_entries)\r\nfnic_trace_entries.wr_idx = 0;\r\nif (fnic_trace_entries.wr_idx == fnic_trace_entries.rd_idx) {\r\nfnic_trace_entries.rd_idx++;\r\nif (fnic_trace_entries.rd_idx >= fnic_max_trace_entries)\r\nfnic_trace_entries.rd_idx = 0;\r\n}\r\nspin_unlock_irqrestore(&fnic_trace_lock, flags);\r\nreturn (fnic_trace_data_t *)fnic_buf_head;\r\n}\r\nint fnic_get_trace_data(fnic_dbgfs_t *fnic_dbgfs_prt)\r\n{\r\nint rd_idx;\r\nint wr_idx;\r\nint len = 0;\r\nunsigned long flags;\r\nchar str[KSYM_SYMBOL_LEN];\r\nstruct timespec val;\r\nfnic_trace_data_t *tbp;\r\nspin_lock_irqsave(&fnic_trace_lock, flags);\r\nrd_idx = fnic_trace_entries.rd_idx;\r\nwr_idx = fnic_trace_entries.wr_idx;\r\nif (wr_idx < rd_idx) {\r\nwhile (1) {\r\ntbp = (fnic_trace_data_t *)\r\nfnic_trace_entries.page_offset[rd_idx];\r\nif (!tbp) {\r\nspin_unlock_irqrestore(&fnic_trace_lock, flags);\r\nreturn 0;\r\n}\r\nif (sizeof(unsigned long) < 8) {\r\nsprint_symbol(str, tbp->fnaddr.low);\r\njiffies_to_timespec(tbp->timestamp.low, &val);\r\n} else {\r\nsprint_symbol(str, tbp->fnaddr.val);\r\njiffies_to_timespec(tbp->timestamp.val, &val);\r\n}\r\nlen += snprintf(fnic_dbgfs_prt->buffer + len,\r\n(trace_max_pages * PAGE_SIZE * 3) - len,\r\n"%16lu.%16lu %-50s %8x %8x %16llx %16llx "\r\n"%16llx %16llx %16llx\n", val.tv_sec,\r\nval.tv_nsec, str, tbp->host_no, tbp->tag,\r\ntbp->data[0], tbp->data[1], tbp->data[2],\r\ntbp->data[3], tbp->data[4]);\r\nrd_idx++;\r\nif (rd_idx > (fnic_max_trace_entries-1))\r\nrd_idx = 0;\r\nif (rd_idx == wr_idx)\r\nbreak;\r\n}\r\n} else if (wr_idx > rd_idx) {\r\nwhile (1) {\r\ntbp = (fnic_trace_data_t *)\r\nfnic_trace_entries.page_offset[rd_idx];\r\nif (!tbp) {\r\nspin_unlock_irqrestore(&fnic_trace_lock, flags);\r\nreturn 0;\r\n}\r\nif (sizeof(unsigned long) < 8) {\r\nsprint_symbol(str, tbp->fnaddr.low);\r\njiffies_to_timespec(tbp->timestamp.low, &val);\r\n} else {\r\nsprint_symbol(str, tbp->fnaddr.val);\r\njiffies_to_timespec(tbp->timestamp.val, &val);\r\n}\r\nlen += snprintf(fnic_dbgfs_prt->buffer + len,\r\n(trace_max_pages * PAGE_SIZE * 3) - len,\r\n"%16lu.%16lu %-50s %8x %8x %16llx %16llx "\r\n"%16llx %16llx %16llx\n", val.tv_sec,\r\nval.tv_nsec, str, tbp->host_no, tbp->tag,\r\ntbp->data[0], tbp->data[1], tbp->data[2],\r\ntbp->data[3], tbp->data[4]);\r\nrd_idx++;\r\nif (rd_idx == wr_idx)\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&fnic_trace_lock, flags);\r\nreturn len;\r\n}\r\nint fnic_trace_buf_init(void)\r\n{\r\nunsigned long fnic_buf_head;\r\nint i;\r\nint err = 0;\r\ntrace_max_pages = fnic_trace_max_pages;\r\nfnic_max_trace_entries = (trace_max_pages * PAGE_SIZE)/\r\nFNIC_ENTRY_SIZE_BYTES;\r\nfnic_trace_buf_p = (unsigned long)vmalloc((trace_max_pages * PAGE_SIZE));\r\nif (!fnic_trace_buf_p) {\r\nprintk(KERN_ERR PFX "Failed to allocate memory "\r\n"for fnic_trace_buf_p\n");\r\nerr = -ENOMEM;\r\ngoto err_fnic_trace_buf_init;\r\n}\r\nmemset((void *)fnic_trace_buf_p, 0, (trace_max_pages * PAGE_SIZE));\r\nfnic_trace_entries.page_offset = vmalloc(fnic_max_trace_entries *\r\nsizeof(unsigned long));\r\nif (!fnic_trace_entries.page_offset) {\r\nprintk(KERN_ERR PFX "Failed to allocate memory for"\r\n" page_offset\n");\r\nif (fnic_trace_buf_p) {\r\nvfree((void *)fnic_trace_buf_p);\r\nfnic_trace_buf_p = 0;\r\n}\r\nerr = -ENOMEM;\r\ngoto err_fnic_trace_buf_init;\r\n}\r\nmemset((void *)fnic_trace_entries.page_offset, 0,\r\n(fnic_max_trace_entries * sizeof(unsigned long)));\r\nfnic_trace_entries.wr_idx = fnic_trace_entries.rd_idx = 0;\r\nfnic_buf_head = fnic_trace_buf_p;\r\nfor (i = 0; i < fnic_max_trace_entries; i++) {\r\nfnic_trace_entries.page_offset[i] = fnic_buf_head;\r\nfnic_buf_head += FNIC_ENTRY_SIZE_BYTES;\r\n}\r\nerr = fnic_trace_debugfs_init();\r\nif (err < 0) {\r\nprintk(KERN_ERR PFX "Failed to initialize debugfs for tracing\n");\r\ngoto err_fnic_trace_debugfs_init;\r\n}\r\nprintk(KERN_INFO PFX "Successfully Initialized Trace Buffer\n");\r\nreturn err;\r\nerr_fnic_trace_debugfs_init:\r\nfnic_trace_free();\r\nerr_fnic_trace_buf_init:\r\nreturn err;\r\n}\r\nvoid fnic_trace_free(void)\r\n{\r\nfnic_tracing_enabled = 0;\r\nfnic_trace_debugfs_terminate();\r\nif (fnic_trace_entries.page_offset) {\r\nvfree((void *)fnic_trace_entries.page_offset);\r\nfnic_trace_entries.page_offset = NULL;\r\n}\r\nif (fnic_trace_buf_p) {\r\nvfree((void *)fnic_trace_buf_p);\r\nfnic_trace_buf_p = 0;\r\n}\r\nprintk(KERN_INFO PFX "Successfully Freed Trace Buffer\n");\r\n}
