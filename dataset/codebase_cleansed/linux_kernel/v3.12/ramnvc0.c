void\r\nnvc0_ram_put(struct nouveau_fb *pfb, struct nouveau_mem **pmem)\r\n{\r\nstruct nouveau_ltcg *ltcg = nouveau_ltcg(pfb);\r\nstruct nouveau_mem *mem = *pmem;\r\n*pmem = NULL;\r\nif (unlikely(mem == NULL))\r\nreturn;\r\nmutex_lock(&pfb->base.mutex);\r\nif (mem->tag)\r\nltcg->tags_free(ltcg, &mem->tag);\r\n__nv50_ram_put(pfb, mem);\r\nmutex_unlock(&pfb->base.mutex);\r\nkfree(mem);\r\n}\r\nint\r\nnvc0_ram_get(struct nouveau_fb *pfb, u64 size, u32 align, u32 ncmin,\r\nu32 memtype, struct nouveau_mem **pmem)\r\n{\r\nstruct nouveau_mm *mm = &pfb->vram;\r\nstruct nouveau_mm_node *r;\r\nstruct nouveau_mem *mem;\r\nint type = (memtype & 0x0ff);\r\nint back = (memtype & 0x800);\r\nconst bool comp = nvc0_pte_storage_type_map[type] != type;\r\nint ret;\r\nsize >>= 12;\r\nalign >>= 12;\r\nncmin >>= 12;\r\nif (!ncmin)\r\nncmin = size;\r\nmem = kzalloc(sizeof(*mem), GFP_KERNEL);\r\nif (!mem)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&mem->regions);\r\nmem->size = size;\r\nmutex_lock(&pfb->base.mutex);\r\nif (comp) {\r\nstruct nouveau_ltcg *ltcg = nouveau_ltcg(pfb);\r\nif (align == (1 << (17 - 12))) {\r\nint n = size >> 5;\r\nltcg->tags_alloc(ltcg, n, &mem->tag);\r\n}\r\nif (unlikely(!mem->tag))\r\ntype = nvc0_pte_storage_type_map[type];\r\n}\r\nmem->memtype = type;\r\ndo {\r\nif (back)\r\nret = nouveau_mm_tail(mm, 1, size, ncmin, align, &r);\r\nelse\r\nret = nouveau_mm_head(mm, 1, size, ncmin, align, &r);\r\nif (ret) {\r\nmutex_unlock(&pfb->base.mutex);\r\npfb->ram->put(pfb, &mem);\r\nreturn ret;\r\n}\r\nlist_add_tail(&r->rl_entry, &mem->regions);\r\nsize -= r->length;\r\n} while (size);\r\nmutex_unlock(&pfb->base.mutex);\r\nr = list_first_entry(&mem->regions, struct nouveau_mm_node, rl_entry);\r\nmem->offset = (u64)r->offset << 12;\r\n*pmem = mem;\r\nreturn 0;\r\n}\r\nstatic int\r\nnvc0_ram_create(struct nouveau_object *parent, struct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass, void *data, u32 size,\r\nstruct nouveau_object **pobject)\r\n{\r\nstruct nouveau_fb *pfb = nouveau_fb(parent);\r\nstruct nouveau_bios *bios = nouveau_bios(pfb);\r\nstruct nouveau_ram *ram;\r\nconst u32 rsvd_head = ( 256 * 1024) >> 12;\r\nconst u32 rsvd_tail = (1024 * 1024) >> 12;\r\nu32 parts = nv_rd32(pfb, 0x022438);\r\nu32 pmask = nv_rd32(pfb, 0x022554);\r\nu32 bsize = nv_rd32(pfb, 0x10f20c);\r\nu32 offset, length;\r\nbool uniform = true;\r\nint ret, part;\r\nret = nouveau_ram_create(parent, engine, oclass, &ram);\r\n*pobject = nv_object(ram);\r\nif (ret)\r\nreturn ret;\r\nnv_debug(pfb, "0x100800: 0x%08x\n", nv_rd32(pfb, 0x100800));\r\nnv_debug(pfb, "parts 0x%08x mask 0x%08x\n", parts, pmask);\r\nram->type = nouveau_fb_bios_memtype(bios);\r\nram->ranks = (nv_rd32(pfb, 0x10f200) & 0x00000004) ? 2 : 1;\r\nfor (part = 0; part < parts; part++) {\r\nif (!(pmask & (1 << part))) {\r\nu32 psize = nv_rd32(pfb, 0x11020c + (part * 0x1000));\r\nif (psize != bsize) {\r\nif (psize < bsize)\r\nbsize = psize;\r\nuniform = false;\r\n}\r\nnv_debug(pfb, "%d: mem_amount 0x%08x\n", part, psize);\r\nram->size += (u64)psize << 20;\r\n}\r\n}\r\nif (uniform) {\r\noffset = rsvd_head;\r\nlength = (ram->size >> 12) - rsvd_head - rsvd_tail;\r\nret = nouveau_mm_init(&pfb->vram, offset, length, 1);\r\n} else {\r\nret = nouveau_mm_init(&pfb->vram, rsvd_head,\r\n(bsize << 8) * parts, 1);\r\nif (ret)\r\nreturn ret;\r\noffset = (0x0200000000ULL >> 12) + (bsize << 8);\r\nlength = (ram->size >> 12) - (bsize << 8) - rsvd_tail;\r\nret = nouveau_mm_init(&pfb->vram, offset, length, 0);\r\nif (ret)\r\nnouveau_mm_fini(&pfb->vram);\r\n}\r\nif (ret)\r\nreturn ret;\r\nram->get = nvc0_ram_get;\r\nram->put = nvc0_ram_put;\r\nreturn 0;\r\n}
