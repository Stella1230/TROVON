static int __xipram cfi_probe_chip(struct map_info *map, __u32 base,\r\nunsigned long *chip_map, struct cfi_private *cfi)\r\n{\r\nint i;\r\nif ((base + 0) >= map->size) {\r\nprintk(KERN_NOTICE\r\n"Probe at base[0x00](0x%08lx) past the end of the map(0x%08lx)\n",\r\n(unsigned long)base, map->size -1);\r\nreturn 0;\r\n}\r\nif ((base + 0xff) >= map->size) {\r\nprintk(KERN_NOTICE\r\n"Probe at base[0x55](0x%08lx) past the end of the map(0x%08lx)\n",\r\n(unsigned long)base + 0x55, map->size -1);\r\nreturn 0;\r\n}\r\nxip_disable();\r\nif (!cfi_qry_mode_on(base, map, cfi)) {\r\nxip_enable(base, map, cfi);\r\nreturn 0;\r\n}\r\nif (!cfi->numchips) {\r\nreturn cfi_chip_setup(map, cfi);\r\n}\r\nfor (i=0; i < (base >> cfi->chipshift); i++) {\r\nunsigned long start;\r\nif(!test_bit(i, chip_map)) {\r\ncontinue;\r\n}\r\nstart = i << cfi->chipshift;\r\nif (cfi_qry_present(map, start, cfi)) {\r\ncfi_qry_mode_off(start, map, cfi);\r\nif (!cfi_qry_present(map, start, cfi)) {\r\nxip_allowed(base, map);\r\nprintk(KERN_DEBUG "%s: Found an alias at 0x%x for the chip at 0x%lx\n",\r\nmap->name, base, start);\r\nreturn 0;\r\n}\r\ncfi_qry_mode_off(base, map, cfi);\r\nif (cfi_qry_present(map, base, cfi)) {\r\nxip_allowed(base, map);\r\nprintk(KERN_DEBUG "%s: Found an alias at 0x%x for the chip at 0x%lx\n",\r\nmap->name, base, start);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nset_bit((base >> cfi->chipshift), chip_map);\r\ncfi->numchips++;\r\ncfi_qry_mode_off(base, map, cfi);\r\nxip_allowed(base, map);\r\nprintk(KERN_INFO "%s: Found %d x%d devices at 0x%x in %d-bit bank\n",\r\nmap->name, cfi->interleave, cfi->device_type*8, base,\r\nmap->bankwidth*8);\r\nreturn 1;\r\n}\r\nstatic int __xipram cfi_chip_setup(struct map_info *map,\r\nstruct cfi_private *cfi)\r\n{\r\nint ofs_factor = cfi->interleave*cfi->device_type;\r\n__u32 base = 0;\r\nint num_erase_regions = cfi_read_query(map, base + (0x10 + 28)*ofs_factor);\r\nint i;\r\nint addr_unlock1 = 0x555, addr_unlock2 = 0x2AA;\r\nxip_enable(base, map, cfi);\r\n#ifdef DEBUG_CFI\r\nprintk("Number of erase regions: %d\n", num_erase_regions);\r\n#endif\r\nif (!num_erase_regions)\r\nreturn 0;\r\ncfi->cfiq = kmalloc(sizeof(struct cfi_ident) + num_erase_regions * 4, GFP_KERNEL);\r\nif (!cfi->cfiq) {\r\nprintk(KERN_WARNING "%s: kmalloc failed for CFI ident structure\n", map->name);\r\nreturn 0;\r\n}\r\nmemset(cfi->cfiq,0,sizeof(struct cfi_ident));\r\ncfi->cfi_mode = CFI_MODE_CFI;\r\ncfi->sector_erase_cmd = CMD(0x30);\r\nxip_disable_qry(base, map, cfi);\r\nfor (i=0; i<(sizeof(struct cfi_ident) + num_erase_regions * 4); i++)\r\n((unsigned char *)cfi->cfiq)[i] = cfi_read_query(map,base + (0x10 + i)*ofs_factor);\r\ncfi->cfiq->P_ID = le16_to_cpu(cfi->cfiq->P_ID);\r\ncfi->cfiq->P_ADR = le16_to_cpu(cfi->cfiq->P_ADR);\r\ncfi->cfiq->A_ID = le16_to_cpu(cfi->cfiq->A_ID);\r\ncfi->cfiq->A_ADR = le16_to_cpu(cfi->cfiq->A_ADR);\r\ncfi->cfiq->InterfaceDesc = le16_to_cpu(cfi->cfiq->InterfaceDesc);\r\ncfi->cfiq->MaxBufWriteSize = le16_to_cpu(cfi->cfiq->MaxBufWriteSize);\r\n#ifdef DEBUG_CFI\r\nprint_cfi_ident(cfi->cfiq);\r\n#endif\r\nfor (i=0; i<cfi->cfiq->NumEraseRegions; i++) {\r\ncfi->cfiq->EraseRegionInfo[i] = le32_to_cpu(cfi->cfiq->EraseRegionInfo[i]);\r\n#ifdef DEBUG_CFI\r\nprintk(" Erase Region #%d: BlockSize 0x%4.4X bytes, %d blocks\n",\r\ni, (cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff,\r\n(cfi->cfiq->EraseRegionInfo[i] & 0xffff) + 1);\r\n#endif\r\n}\r\nif (cfi->cfiq->P_ID == P_ID_SST_OLD) {\r\naddr_unlock1 = 0x5555;\r\naddr_unlock2 = 0x2AAA;\r\n}\r\ncfi_send_gen_cmd(0xf0, 0, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0xaa, addr_unlock1, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x55, addr_unlock2, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x90, addr_unlock1, base, map, cfi, cfi->device_type, NULL);\r\ncfi->mfr = cfi_read_query16(map, base);\r\ncfi->id = cfi_read_query16(map, base + ofs_factor);\r\nif (cfi->mfr == CFI_MFR_AMD && (cfi->id & 0xff) == 0x7e)\r\ncfi->id = cfi_read_query(map, base + 0xe * ofs_factor) << 8 |\r\ncfi_read_query(map, base + 0xf * ofs_factor);\r\ncfi_qry_mode_off(base, map, cfi);\r\nxip_allowed(base, map);\r\nprintk(KERN_INFO "%s: Found %d x%d devices at 0x%x in %d-bit bank. Manufacturer ID %#08x Chip ID %#08x\n",\r\nmap->name, cfi->interleave, cfi->device_type*8, base,\r\nmap->bankwidth*8, cfi->mfr, cfi->id);\r\nreturn 1;\r\n}\r\nstatic char *vendorname(__u16 vendor)\r\n{\r\nswitch (vendor) {\r\ncase P_ID_NONE:\r\nreturn "None";\r\ncase P_ID_INTEL_EXT:\r\nreturn "Intel/Sharp Extended";\r\ncase P_ID_AMD_STD:\r\nreturn "AMD/Fujitsu Standard";\r\ncase P_ID_INTEL_STD:\r\nreturn "Intel/Sharp Standard";\r\ncase P_ID_AMD_EXT:\r\nreturn "AMD/Fujitsu Extended";\r\ncase P_ID_WINBOND:\r\nreturn "Winbond Standard";\r\ncase P_ID_ST_ADV:\r\nreturn "ST Advanced";\r\ncase P_ID_MITSUBISHI_STD:\r\nreturn "Mitsubishi Standard";\r\ncase P_ID_MITSUBISHI_EXT:\r\nreturn "Mitsubishi Extended";\r\ncase P_ID_SST_PAGE:\r\nreturn "SST Page Write";\r\ncase P_ID_SST_OLD:\r\nreturn "SST 39VF160x/39VF320x";\r\ncase P_ID_INTEL_PERFORMANCE:\r\nreturn "Intel Performance Code";\r\ncase P_ID_INTEL_DATA:\r\nreturn "Intel Data";\r\ncase P_ID_RESERVED:\r\nreturn "Not Allowed / Reserved for Future Use";\r\ndefault:\r\nreturn "Unknown";\r\n}\r\n}\r\nstatic void print_cfi_ident(struct cfi_ident *cfip)\r\n{\r\n#if 0\r\nif (cfip->qry[0] != 'Q' || cfip->qry[1] != 'R' || cfip->qry[2] != 'Y') {\r\nprintk("Invalid CFI ident structure.\n");\r\nreturn;\r\n}\r\n#endif\r\nprintk("Primary Vendor Command Set: %4.4X (%s)\n", cfip->P_ID, vendorname(cfip->P_ID));\r\nif (cfip->P_ADR)\r\nprintk("Primary Algorithm Table at %4.4X\n", cfip->P_ADR);\r\nelse\r\nprintk("No Primary Algorithm Table\n");\r\nprintk("Alternative Vendor Command Set: %4.4X (%s)\n", cfip->A_ID, vendorname(cfip->A_ID));\r\nif (cfip->A_ADR)\r\nprintk("Alternate Algorithm Table at %4.4X\n", cfip->A_ADR);\r\nelse\r\nprintk("No Alternate Algorithm Table\n");\r\nprintk("Vcc Minimum: %2d.%d V\n", cfip->VccMin >> 4, cfip->VccMin & 0xf);\r\nprintk("Vcc Maximum: %2d.%d V\n", cfip->VccMax >> 4, cfip->VccMax & 0xf);\r\nif (cfip->VppMin) {\r\nprintk("Vpp Minimum: %2d.%d V\n", cfip->VppMin >> 4, cfip->VppMin & 0xf);\r\nprintk("Vpp Maximum: %2d.%d V\n", cfip->VppMax >> 4, cfip->VppMax & 0xf);\r\n}\r\nelse\r\nprintk("No Vpp line\n");\r\nprintk("Typical byte/word write timeout: %d ÃƒÆ’&#8218;Ãƒâ€šÃ‚Âµs\n", 1<<cfip->WordWriteTimeoutTyp);\r\nprintk("Maximum byte/word write timeout: %d ÃƒÆ’&#8218;Ãƒâ€šÃ‚Âµs\n", (1<<cfip->WordWriteTimeoutMax) * (1<<cfip->WordWriteTimeoutTyp));\r\nif (cfip->BufWriteTimeoutTyp || cfip->BufWriteTimeoutMax) {\r\nprintk("Typical full buffer write timeout: %d ÃƒÆ’&#8218;Ãƒâ€šÃ‚Âµs\n", 1<<cfip->BufWriteTimeoutTyp);\r\nprintk("Maximum full buffer write timeout: %d ÃƒÆ’&#8218;Ãƒâ€šÃ‚Âµs\n", (1<<cfip->BufWriteTimeoutMax) * (1<<cfip->BufWriteTimeoutTyp));\r\n}\r\nelse\r\nprintk("Full buffer write not supported\n");\r\nprintk("Typical block erase timeout: %d ms\n", 1<<cfip->BlockEraseTimeoutTyp);\r\nprintk("Maximum block erase timeout: %d ms\n", (1<<cfip->BlockEraseTimeoutMax) * (1<<cfip->BlockEraseTimeoutTyp));\r\nif (cfip->ChipEraseTimeoutTyp || cfip->ChipEraseTimeoutMax) {\r\nprintk("Typical chip erase timeout: %d ms\n", 1<<cfip->ChipEraseTimeoutTyp);\r\nprintk("Maximum chip erase timeout: %d ms\n", (1<<cfip->ChipEraseTimeoutMax) * (1<<cfip->ChipEraseTimeoutTyp));\r\n}\r\nelse\r\nprintk("Chip erase not supported\n");\r\nprintk("Device size: 0x%X bytes (%d MiB)\n", 1 << cfip->DevSize, 1<< (cfip->DevSize - 20));\r\nprintk("Flash Device Interface description: 0x%4.4X\n", cfip->InterfaceDesc);\r\nswitch(cfip->InterfaceDesc) {\r\ncase CFI_INTERFACE_X8_ASYNC:\r\nprintk(" - x8-only asynchronous interface\n");\r\nbreak;\r\ncase CFI_INTERFACE_X16_ASYNC:\r\nprintk(" - x16-only asynchronous interface\n");\r\nbreak;\r\ncase CFI_INTERFACE_X8_BY_X16_ASYNC:\r\nprintk(" - supports x8 and x16 via BYTE# with asynchronous interface\n");\r\nbreak;\r\ncase CFI_INTERFACE_X32_ASYNC:\r\nprintk(" - x32-only asynchronous interface\n");\r\nbreak;\r\ncase CFI_INTERFACE_X16_BY_X32_ASYNC:\r\nprintk(" - supports x16 and x32 via Word# with asynchronous interface\n");\r\nbreak;\r\ncase CFI_INTERFACE_NOT_ALLOWED:\r\nprintk(" - Not Allowed / Reserved\n");\r\nbreak;\r\ndefault:\r\nprintk(" - Unknown\n");\r\nbreak;\r\n}\r\nprintk("Max. bytes in buffer write: 0x%x\n", 1<< cfip->MaxBufWriteSize);\r\nprintk("Number of Erase Block Regions: %d\n", cfip->NumEraseRegions);\r\n}\r\nstruct mtd_info *cfi_probe(struct map_info *map)\r\n{\r\nreturn mtd_do_chip_probe(map, &cfi_chip_probe);\r\n}\r\nstatic int __init cfi_probe_init(void)\r\n{\r\nregister_mtd_chip_driver(&cfi_chipdrv);\r\nreturn 0;\r\n}\r\nstatic void __exit cfi_probe_exit(void)\r\n{\r\nunregister_mtd_chip_driver(&cfi_chipdrv);\r\n}
