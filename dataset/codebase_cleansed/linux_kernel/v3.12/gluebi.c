static struct gluebi_device *find_gluebi_nolock(int ubi_num, int vol_id)\r\n{\r\nstruct gluebi_device *gluebi;\r\nlist_for_each_entry(gluebi, &gluebi_devices, list)\r\nif (gluebi->ubi_num == ubi_num && gluebi->vol_id == vol_id)\r\nreturn gluebi;\r\nreturn NULL;\r\n}\r\nstatic int gluebi_get_device(struct mtd_info *mtd)\r\n{\r\nstruct gluebi_device *gluebi;\r\nint ubi_mode = UBI_READONLY;\r\nif (!try_module_get(THIS_MODULE))\r\nreturn -ENODEV;\r\nif (mtd->flags & MTD_WRITEABLE)\r\nubi_mode = UBI_READWRITE;\r\ngluebi = container_of(mtd, struct gluebi_device, mtd);\r\nmutex_lock(&devices_mutex);\r\nif (gluebi->refcnt > 0) {\r\ngluebi->refcnt += 1;\r\nmutex_unlock(&devices_mutex);\r\nreturn 0;\r\n}\r\ngluebi->desc = ubi_open_volume(gluebi->ubi_num, gluebi->vol_id,\r\nubi_mode);\r\nif (IS_ERR(gluebi->desc)) {\r\nmutex_unlock(&devices_mutex);\r\nmodule_put(THIS_MODULE);\r\nreturn PTR_ERR(gluebi->desc);\r\n}\r\ngluebi->refcnt += 1;\r\nmutex_unlock(&devices_mutex);\r\nreturn 0;\r\n}\r\nstatic void gluebi_put_device(struct mtd_info *mtd)\r\n{\r\nstruct gluebi_device *gluebi;\r\ngluebi = container_of(mtd, struct gluebi_device, mtd);\r\nmutex_lock(&devices_mutex);\r\ngluebi->refcnt -= 1;\r\nif (gluebi->refcnt == 0)\r\nubi_close_volume(gluebi->desc);\r\nmodule_put(THIS_MODULE);\r\nmutex_unlock(&devices_mutex);\r\n}\r\nstatic int gluebi_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, unsigned char *buf)\r\n{\r\nint err = 0, lnum, offs, bytes_left;\r\nstruct gluebi_device *gluebi;\r\ngluebi = container_of(mtd, struct gluebi_device, mtd);\r\nlnum = div_u64_rem(from, mtd->erasesize, &offs);\r\nbytes_left = len;\r\nwhile (bytes_left) {\r\nsize_t to_read = mtd->erasesize - offs;\r\nif (to_read > bytes_left)\r\nto_read = bytes_left;\r\nerr = ubi_read(gluebi->desc, lnum, buf, offs, to_read);\r\nif (err)\r\nbreak;\r\nlnum += 1;\r\noffs = 0;\r\nbytes_left -= to_read;\r\nbuf += to_read;\r\n}\r\n*retlen = len - bytes_left;\r\nreturn err;\r\n}\r\nstatic int gluebi_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nint err = 0, lnum, offs, bytes_left;\r\nstruct gluebi_device *gluebi;\r\ngluebi = container_of(mtd, struct gluebi_device, mtd);\r\nlnum = div_u64_rem(to, mtd->erasesize, &offs);\r\nif (len % mtd->writesize || offs % mtd->writesize)\r\nreturn -EINVAL;\r\nbytes_left = len;\r\nwhile (bytes_left) {\r\nsize_t to_write = mtd->erasesize - offs;\r\nif (to_write > bytes_left)\r\nto_write = bytes_left;\r\nerr = ubi_leb_write(gluebi->desc, lnum, buf, offs, to_write);\r\nif (err)\r\nbreak;\r\nlnum += 1;\r\noffs = 0;\r\nbytes_left -= to_write;\r\nbuf += to_write;\r\n}\r\n*retlen = len - bytes_left;\r\nreturn err;\r\n}\r\nstatic int gluebi_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nint err, i, lnum, count;\r\nstruct gluebi_device *gluebi;\r\nif (mtd_mod_by_ws(instr->addr, mtd) || mtd_mod_by_ws(instr->len, mtd))\r\nreturn -EINVAL;\r\nlnum = mtd_div_by_eb(instr->addr, mtd);\r\ncount = mtd_div_by_eb(instr->len, mtd);\r\ngluebi = container_of(mtd, struct gluebi_device, mtd);\r\nfor (i = 0; i < count - 1; i++) {\r\nerr = ubi_leb_unmap(gluebi->desc, lnum + i);\r\nif (err)\r\ngoto out_err;\r\n}\r\nerr = ubi_leb_erase(gluebi->desc, lnum + i);\r\nif (err)\r\ngoto out_err;\r\ninstr->state = MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\nreturn 0;\r\nout_err:\r\ninstr->state = MTD_ERASE_FAILED;\r\ninstr->fail_addr = (long long)lnum * mtd->erasesize;\r\nreturn err;\r\n}\r\nstatic int gluebi_create(struct ubi_device_info *di,\r\nstruct ubi_volume_info *vi)\r\n{\r\nstruct gluebi_device *gluebi, *g;\r\nstruct mtd_info *mtd;\r\ngluebi = kzalloc(sizeof(struct gluebi_device), GFP_KERNEL);\r\nif (!gluebi)\r\nreturn -ENOMEM;\r\nmtd = &gluebi->mtd;\r\nmtd->name = kmemdup(vi->name, vi->name_len + 1, GFP_KERNEL);\r\nif (!mtd->name) {\r\nkfree(gluebi);\r\nreturn -ENOMEM;\r\n}\r\ngluebi->vol_id = vi->vol_id;\r\ngluebi->ubi_num = vi->ubi_num;\r\nmtd->type = MTD_UBIVOLUME;\r\nif (!di->ro_mode)\r\nmtd->flags = MTD_WRITEABLE;\r\nmtd->owner = THIS_MODULE;\r\nmtd->writesize = di->min_io_size;\r\nmtd->erasesize = vi->usable_leb_size;\r\nmtd->_read = gluebi_read;\r\nmtd->_write = gluebi_write;\r\nmtd->_erase = gluebi_erase;\r\nmtd->_get_device = gluebi_get_device;\r\nmtd->_put_device = gluebi_put_device;\r\nif (vi->vol_type == UBI_DYNAMIC_VOLUME)\r\nmtd->size = (unsigned long long)vi->usable_leb_size * vi->size;\r\nelse\r\nmtd->size = vi->used_bytes;\r\nmutex_lock(&devices_mutex);\r\ng = find_gluebi_nolock(vi->ubi_num, vi->vol_id);\r\nif (g)\r\nerr_msg("gluebi MTD device %d form UBI device %d volume %d already exists",\r\ng->mtd.index, vi->ubi_num, vi->vol_id);\r\nmutex_unlock(&devices_mutex);\r\nif (mtd_device_register(mtd, NULL, 0)) {\r\nerr_msg("cannot add MTD device");\r\nkfree(mtd->name);\r\nkfree(gluebi);\r\nreturn -ENFILE;\r\n}\r\nmutex_lock(&devices_mutex);\r\nlist_add_tail(&gluebi->list, &gluebi_devices);\r\nmutex_unlock(&devices_mutex);\r\nreturn 0;\r\n}\r\nstatic int gluebi_remove(struct ubi_volume_info *vi)\r\n{\r\nint err = 0;\r\nstruct mtd_info *mtd;\r\nstruct gluebi_device *gluebi;\r\nmutex_lock(&devices_mutex);\r\ngluebi = find_gluebi_nolock(vi->ubi_num, vi->vol_id);\r\nif (!gluebi) {\r\nerr_msg("got remove notification for unknown UBI device %d volume %d",\r\nvi->ubi_num, vi->vol_id);\r\nerr = -ENOENT;\r\n} else if (gluebi->refcnt)\r\nerr = -EBUSY;\r\nelse\r\nlist_del(&gluebi->list);\r\nmutex_unlock(&devices_mutex);\r\nif (err)\r\nreturn err;\r\nmtd = &gluebi->mtd;\r\nerr = mtd_device_unregister(mtd);\r\nif (err) {\r\nerr_msg("cannot remove fake MTD device %d, UBI device %d, volume %d, error %d",\r\nmtd->index, gluebi->ubi_num, gluebi->vol_id, err);\r\nmutex_lock(&devices_mutex);\r\nlist_add_tail(&gluebi->list, &gluebi_devices);\r\nmutex_unlock(&devices_mutex);\r\nreturn err;\r\n}\r\nkfree(mtd->name);\r\nkfree(gluebi);\r\nreturn 0;\r\n}\r\nstatic int gluebi_updated(struct ubi_volume_info *vi)\r\n{\r\nstruct gluebi_device *gluebi;\r\nmutex_lock(&devices_mutex);\r\ngluebi = find_gluebi_nolock(vi->ubi_num, vi->vol_id);\r\nif (!gluebi) {\r\nmutex_unlock(&devices_mutex);\r\nerr_msg("got update notification for unknown UBI device %d volume %d",\r\nvi->ubi_num, vi->vol_id);\r\nreturn -ENOENT;\r\n}\r\nif (vi->vol_type == UBI_STATIC_VOLUME)\r\ngluebi->mtd.size = vi->used_bytes;\r\nmutex_unlock(&devices_mutex);\r\nreturn 0;\r\n}\r\nstatic int gluebi_resized(struct ubi_volume_info *vi)\r\n{\r\nstruct gluebi_device *gluebi;\r\nmutex_lock(&devices_mutex);\r\ngluebi = find_gluebi_nolock(vi->ubi_num, vi->vol_id);\r\nif (!gluebi) {\r\nmutex_unlock(&devices_mutex);\r\nerr_msg("got update notification for unknown UBI device %d volume %d",\r\nvi->ubi_num, vi->vol_id);\r\nreturn -ENOENT;\r\n}\r\ngluebi->mtd.size = vi->used_bytes;\r\nmutex_unlock(&devices_mutex);\r\nreturn 0;\r\n}\r\nstatic int gluebi_notify(struct notifier_block *nb, unsigned long l,\r\nvoid *ns_ptr)\r\n{\r\nstruct ubi_notification *nt = ns_ptr;\r\nswitch (l) {\r\ncase UBI_VOLUME_ADDED:\r\ngluebi_create(&nt->di, &nt->vi);\r\nbreak;\r\ncase UBI_VOLUME_REMOVED:\r\ngluebi_remove(&nt->vi);\r\nbreak;\r\ncase UBI_VOLUME_RESIZED:\r\ngluebi_resized(&nt->vi);\r\nbreak;\r\ncase UBI_VOLUME_UPDATED:\r\ngluebi_updated(&nt->vi);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init ubi_gluebi_init(void)\r\n{\r\nreturn ubi_register_volume_notifier(&gluebi_notifier, 0);\r\n}\r\nstatic void __exit ubi_gluebi_exit(void)\r\n{\r\nstruct gluebi_device *gluebi, *g;\r\nlist_for_each_entry_safe(gluebi, g, &gluebi_devices, list) {\r\nint err;\r\nstruct mtd_info *mtd = &gluebi->mtd;\r\nerr = mtd_device_unregister(mtd);\r\nif (err)\r\nerr_msg("error %d while removing gluebi MTD device %d, UBI device %d, volume %d - ignoring",\r\nerr, mtd->index, gluebi->ubi_num,\r\ngluebi->vol_id);\r\nkfree(mtd->name);\r\nkfree(gluebi);\r\n}\r\nubi_unregister_volume_notifier(&gluebi_notifier);\r\n}
