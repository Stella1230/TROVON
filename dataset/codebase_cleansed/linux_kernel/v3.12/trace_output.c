int trace_print_seq(struct seq_file *m, struct trace_seq *s)\r\n{\r\nint len = s->len >= PAGE_SIZE ? PAGE_SIZE - 1 : s->len;\r\nint ret;\r\nret = seq_write(m, s->buffer, len);\r\nif (!ret)\r\ntrace_seq_init(s);\r\nreturn ret;\r\n}\r\nenum print_line_t trace_print_bputs_msg_only(struct trace_iterator *iter)\r\n{\r\nstruct trace_seq *s = &iter->seq;\r\nstruct trace_entry *entry = iter->ent;\r\nstruct bputs_entry *field;\r\nint ret;\r\ntrace_assign_type(field, entry);\r\nret = trace_seq_puts(s, field->str);\r\nif (!ret)\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\nreturn TRACE_TYPE_HANDLED;\r\n}\r\nenum print_line_t trace_print_bprintk_msg_only(struct trace_iterator *iter)\r\n{\r\nstruct trace_seq *s = &iter->seq;\r\nstruct trace_entry *entry = iter->ent;\r\nstruct bprint_entry *field;\r\nint ret;\r\ntrace_assign_type(field, entry);\r\nret = trace_seq_bprintf(s, field->fmt, field->buf);\r\nif (!ret)\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\nreturn TRACE_TYPE_HANDLED;\r\n}\r\nenum print_line_t trace_print_printk_msg_only(struct trace_iterator *iter)\r\n{\r\nstruct trace_seq *s = &iter->seq;\r\nstruct trace_entry *entry = iter->ent;\r\nstruct print_entry *field;\r\nint ret;\r\ntrace_assign_type(field, entry);\r\nret = trace_seq_puts(s, field->buf);\r\nif (!ret)\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\nreturn TRACE_TYPE_HANDLED;\r\n}\r\nint\r\ntrace_seq_printf(struct trace_seq *s, const char *fmt, ...)\r\n{\r\nint len = (PAGE_SIZE - 1) - s->len;\r\nva_list ap;\r\nint ret;\r\nif (s->full || !len)\r\nreturn 0;\r\nva_start(ap, fmt);\r\nret = vsnprintf(s->buffer + s->len, len, fmt, ap);\r\nva_end(ap);\r\nif (ret >= len) {\r\ns->full = 1;\r\nreturn 0;\r\n}\r\ns->len += ret;\r\nreturn 1;\r\n}\r\nint\r\ntrace_seq_vprintf(struct trace_seq *s, const char *fmt, va_list args)\r\n{\r\nint len = (PAGE_SIZE - 1) - s->len;\r\nint ret;\r\nif (s->full || !len)\r\nreturn 0;\r\nret = vsnprintf(s->buffer + s->len, len, fmt, args);\r\nif (ret >= len) {\r\ns->full = 1;\r\nreturn 0;\r\n}\r\ns->len += ret;\r\nreturn len;\r\n}\r\nint trace_seq_bprintf(struct trace_seq *s, const char *fmt, const u32 *binary)\r\n{\r\nint len = (PAGE_SIZE - 1) - s->len;\r\nint ret;\r\nif (s->full || !len)\r\nreturn 0;\r\nret = bstr_printf(s->buffer + s->len, len, fmt, binary);\r\nif (ret >= len) {\r\ns->full = 1;\r\nreturn 0;\r\n}\r\ns->len += ret;\r\nreturn len;\r\n}\r\nint trace_seq_puts(struct trace_seq *s, const char *str)\r\n{\r\nint len = strlen(str);\r\nif (s->full)\r\nreturn 0;\r\nif (len > ((PAGE_SIZE - 1) - s->len)) {\r\ns->full = 1;\r\nreturn 0;\r\n}\r\nmemcpy(s->buffer + s->len, str, len);\r\ns->len += len;\r\nreturn len;\r\n}\r\nint trace_seq_putc(struct trace_seq *s, unsigned char c)\r\n{\r\nif (s->full)\r\nreturn 0;\r\nif (s->len >= (PAGE_SIZE - 1)) {\r\ns->full = 1;\r\nreturn 0;\r\n}\r\ns->buffer[s->len++] = c;\r\nreturn 1;\r\n}\r\nint trace_seq_putmem(struct trace_seq *s, const void *mem, size_t len)\r\n{\r\nif (s->full)\r\nreturn 0;\r\nif (len > ((PAGE_SIZE - 1) - s->len)) {\r\ns->full = 1;\r\nreturn 0;\r\n}\r\nmemcpy(s->buffer + s->len, mem, len);\r\ns->len += len;\r\nreturn len;\r\n}\r\nvoid *trace_seq_reserve(struct trace_seq *s, size_t len)\r\n{\r\nvoid *ret;\r\nif (s->full)\r\nreturn NULL;\r\nif (len > ((PAGE_SIZE - 1) - s->len)) {\r\ns->full = 1;\r\nreturn NULL;\r\n}\r\nret = s->buffer + s->len;\r\ns->len += len;\r\nreturn ret;\r\n}\r\nint trace_seq_path(struct trace_seq *s, const struct path *path)\r\n{\r\nunsigned char *p;\r\nif (s->full)\r\nreturn 0;\r\nif (s->len >= (PAGE_SIZE - 1)) {\r\ns->full = 1;\r\nreturn 0;\r\n}\r\np = d_path(path, s->buffer + s->len, PAGE_SIZE - s->len);\r\nif (!IS_ERR(p)) {\r\np = mangle_path(s->buffer + s->len, p, "\n");\r\nif (p) {\r\ns->len = p - s->buffer;\r\nreturn 1;\r\n}\r\n} else {\r\ns->buffer[s->len++] = '?';\r\nreturn 1;\r\n}\r\ns->full = 1;\r\nreturn 0;\r\n}\r\nconst char *\r\nftrace_print_flags_seq(struct trace_seq *p, const char *delim,\r\nunsigned long flags,\r\nconst struct trace_print_flags *flag_array)\r\n{\r\nunsigned long mask;\r\nconst char *str;\r\nconst char *ret = p->buffer + p->len;\r\nint i, first = 1;\r\nfor (i = 0; flag_array[i].name && flags; i++) {\r\nmask = flag_array[i].mask;\r\nif ((flags & mask) != mask)\r\ncontinue;\r\nstr = flag_array[i].name;\r\nflags &= ~mask;\r\nif (!first && delim)\r\ntrace_seq_puts(p, delim);\r\nelse\r\nfirst = 0;\r\ntrace_seq_puts(p, str);\r\n}\r\nif (flags) {\r\nif (!first && delim)\r\ntrace_seq_puts(p, delim);\r\ntrace_seq_printf(p, "0x%lx", flags);\r\n}\r\ntrace_seq_putc(p, 0);\r\nreturn ret;\r\n}\r\nconst char *\r\nftrace_print_symbols_seq(struct trace_seq *p, unsigned long val,\r\nconst struct trace_print_flags *symbol_array)\r\n{\r\nint i;\r\nconst char *ret = p->buffer + p->len;\r\nfor (i = 0; symbol_array[i].name; i++) {\r\nif (val != symbol_array[i].mask)\r\ncontinue;\r\ntrace_seq_puts(p, symbol_array[i].name);\r\nbreak;\r\n}\r\nif (ret == (const char *)(p->buffer + p->len))\r\ntrace_seq_printf(p, "0x%lx", val);\r\ntrace_seq_putc(p, 0);\r\nreturn ret;\r\n}\r\nconst char *\r\nftrace_print_symbols_seq_u64(struct trace_seq *p, unsigned long long val,\r\nconst struct trace_print_flags_u64 *symbol_array)\r\n{\r\nint i;\r\nconst char *ret = p->buffer + p->len;\r\nfor (i = 0; symbol_array[i].name; i++) {\r\nif (val != symbol_array[i].mask)\r\ncontinue;\r\ntrace_seq_puts(p, symbol_array[i].name);\r\nbreak;\r\n}\r\nif (ret == (const char *)(p->buffer + p->len))\r\ntrace_seq_printf(p, "0x%llx", val);\r\ntrace_seq_putc(p, 0);\r\nreturn ret;\r\n}\r\nconst char *\r\nftrace_print_hex_seq(struct trace_seq *p, const unsigned char *buf, int buf_len)\r\n{\r\nint i;\r\nconst char *ret = p->buffer + p->len;\r\nfor (i = 0; i < buf_len; i++)\r\ntrace_seq_printf(p, "%s%2.2x", i == 0 ? "" : " ", buf[i]);\r\ntrace_seq_putc(p, 0);\r\nreturn ret;\r\n}\r\nint ftrace_raw_output_prep(struct trace_iterator *iter,\r\nstruct trace_event *trace_event)\r\n{\r\nstruct ftrace_event_call *event;\r\nstruct trace_seq *s = &iter->seq;\r\nstruct trace_seq *p = &iter->tmp_seq;\r\nstruct trace_entry *entry;\r\nint ret;\r\nevent = container_of(trace_event, struct ftrace_event_call, event);\r\nentry = iter->ent;\r\nif (entry->type != event->event.type) {\r\nWARN_ON_ONCE(1);\r\nreturn TRACE_TYPE_UNHANDLED;\r\n}\r\ntrace_seq_init(p);\r\nret = trace_seq_printf(s, "%s: ", event->name);\r\nif (!ret)\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\nreturn 0;\r\n}\r\nstatic inline const char *kretprobed(const char *name)\r\n{\r\nstatic const char tramp_name[] = "kretprobe_trampoline";\r\nint size = sizeof(tramp_name);\r\nif (strncmp(tramp_name, name, size) == 0)\r\nreturn "[unknown/kretprobe'd]";\r\nreturn name;\r\n}\r\nstatic inline const char *kretprobed(const char *name)\r\n{\r\nreturn name;\r\n}\r\nstatic int\r\nseq_print_sym_short(struct trace_seq *s, const char *fmt, unsigned long address)\r\n{\r\n#ifdef CONFIG_KALLSYMS\r\nchar str[KSYM_SYMBOL_LEN];\r\nconst char *name;\r\nkallsyms_lookup(address, NULL, NULL, NULL, str);\r\nname = kretprobed(str);\r\nreturn trace_seq_printf(s, fmt, name);\r\n#endif\r\nreturn 1;\r\n}\r\nstatic int\r\nseq_print_sym_offset(struct trace_seq *s, const char *fmt,\r\nunsigned long address)\r\n{\r\n#ifdef CONFIG_KALLSYMS\r\nchar str[KSYM_SYMBOL_LEN];\r\nconst char *name;\r\nsprint_symbol(str, address);\r\nname = kretprobed(str);\r\nreturn trace_seq_printf(s, fmt, name);\r\n#endif\r\nreturn 1;\r\n}\r\nint seq_print_user_ip(struct trace_seq *s, struct mm_struct *mm,\r\nunsigned long ip, unsigned long sym_flags)\r\n{\r\nstruct file *file = NULL;\r\nunsigned long vmstart = 0;\r\nint ret = 1;\r\nif (s->full)\r\nreturn 0;\r\nif (mm) {\r\nconst struct vm_area_struct *vma;\r\ndown_read(&mm->mmap_sem);\r\nvma = find_vma(mm, ip);\r\nif (vma) {\r\nfile = vma->vm_file;\r\nvmstart = vma->vm_start;\r\n}\r\nif (file) {\r\nret = trace_seq_path(s, &file->f_path);\r\nif (ret)\r\nret = trace_seq_printf(s, "[+0x%lx]",\r\nip - vmstart);\r\n}\r\nup_read(&mm->mmap_sem);\r\n}\r\nif (ret && ((sym_flags & TRACE_ITER_SYM_ADDR) || !file))\r\nret = trace_seq_printf(s, " <" IP_FMT ">", ip);\r\nreturn ret;\r\n}\r\nint\r\nseq_print_userip_objs(const struct userstack_entry *entry, struct trace_seq *s,\r\nunsigned long sym_flags)\r\n{\r\nstruct mm_struct *mm = NULL;\r\nint ret = 1;\r\nunsigned int i;\r\nif (trace_flags & TRACE_ITER_SYM_USEROBJ) {\r\nstruct task_struct *task;\r\nrcu_read_lock();\r\ntask = find_task_by_vpid(entry->tgid);\r\nif (task)\r\nmm = get_task_mm(task);\r\nrcu_read_unlock();\r\n}\r\nfor (i = 0; i < FTRACE_STACK_ENTRIES; i++) {\r\nunsigned long ip = entry->caller[i];\r\nif (ip == ULONG_MAX || !ret)\r\nbreak;\r\nif (ret)\r\nret = trace_seq_puts(s, " => ");\r\nif (!ip) {\r\nif (ret)\r\nret = trace_seq_puts(s, "??");\r\nif (ret)\r\nret = trace_seq_putc(s, '\n');\r\ncontinue;\r\n}\r\nif (!ret)\r\nbreak;\r\nif (ret)\r\nret = seq_print_user_ip(s, mm, ip, sym_flags);\r\nret = trace_seq_putc(s, '\n');\r\n}\r\nif (mm)\r\nmmput(mm);\r\nreturn ret;\r\n}\r\nint\r\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\r\n{\r\nint ret;\r\nif (!ip)\r\nreturn trace_seq_putc(s, '0');\r\nif (sym_flags & TRACE_ITER_SYM_OFFSET)\r\nret = seq_print_sym_offset(s, "%s", ip);\r\nelse\r\nret = seq_print_sym_short(s, "%s", ip);\r\nif (!ret)\r\nreturn 0;\r\nif (sym_flags & TRACE_ITER_SYM_ADDR)\r\nret = trace_seq_printf(s, " <" IP_FMT ">", ip);\r\nreturn ret;\r\n}\r\nint trace_print_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\r\n{\r\nchar hardsoft_irq;\r\nchar need_resched;\r\nchar irqs_off;\r\nint hardirq;\r\nint softirq;\r\nint ret;\r\nhardirq = entry->flags & TRACE_FLAG_HARDIRQ;\r\nsoftirq = entry->flags & TRACE_FLAG_SOFTIRQ;\r\nirqs_off =\r\n(entry->flags & TRACE_FLAG_IRQS_OFF) ? 'd' :\r\n(entry->flags & TRACE_FLAG_IRQS_NOSUPPORT) ? 'X' :\r\n'.';\r\nneed_resched =\r\n(entry->flags & TRACE_FLAG_NEED_RESCHED) ? 'N' : '.';\r\nhardsoft_irq =\r\n(hardirq && softirq) ? 'H' :\r\nhardirq ? 'h' :\r\nsoftirq ? 's' :\r\n'.';\r\nif (!trace_seq_printf(s, "%c%c%c",\r\nirqs_off, need_resched, hardsoft_irq))\r\nreturn 0;\r\nif (entry->preempt_count)\r\nret = trace_seq_printf(s, "%x", entry->preempt_count);\r\nelse\r\nret = trace_seq_putc(s, '.');\r\nreturn ret;\r\n}\r\nstatic int\r\nlat_print_generic(struct trace_seq *s, struct trace_entry *entry, int cpu)\r\n{\r\nchar comm[TASK_COMM_LEN];\r\ntrace_find_cmdline(entry->pid, comm);\r\nif (!trace_seq_printf(s, "%8.8s-%-5d %3d",\r\ncomm, entry->pid, cpu))\r\nreturn 0;\r\nreturn trace_print_lat_fmt(s, entry);\r\n}\r\nstatic int\r\nlat_print_timestamp(struct trace_iterator *iter, u64 next_ts)\r\n{\r\nunsigned long verbose = trace_flags & TRACE_ITER_VERBOSE;\r\nunsigned long in_ns = iter->iter_flags & TRACE_FILE_TIME_IN_NS;\r\nunsigned long long abs_ts = iter->ts - iter->trace_buffer->time_start;\r\nunsigned long long rel_ts = next_ts - iter->ts;\r\nstruct trace_seq *s = &iter->seq;\r\nif (in_ns) {\r\nabs_ts = ns2usecs(abs_ts);\r\nrel_ts = ns2usecs(rel_ts);\r\n}\r\nif (verbose && in_ns) {\r\nunsigned long abs_usec = do_div(abs_ts, USEC_PER_MSEC);\r\nunsigned long abs_msec = (unsigned long)abs_ts;\r\nunsigned long rel_usec = do_div(rel_ts, USEC_PER_MSEC);\r\nunsigned long rel_msec = (unsigned long)rel_ts;\r\nreturn trace_seq_printf(\r\ns, "[%08llx] %ld.%03ldms (+%ld.%03ldms): ",\r\nns2usecs(iter->ts),\r\nabs_msec, abs_usec,\r\nrel_msec, rel_usec);\r\n} else if (verbose && !in_ns) {\r\nreturn trace_seq_printf(\r\ns, "[%016llx] %lld (+%lld): ",\r\niter->ts, abs_ts, rel_ts);\r\n} else if (!verbose && in_ns) {\r\nreturn trace_seq_printf(\r\ns, " %4lldus%c: ",\r\nabs_ts,\r\nrel_ts > preempt_mark_thresh_us ? '!' :\r\nrel_ts > 1 ? '+' : ' ');\r\n} else {\r\nreturn trace_seq_printf(s, " %4lld: ", abs_ts);\r\n}\r\n}\r\nint trace_print_context(struct trace_iterator *iter)\r\n{\r\nstruct trace_seq *s = &iter->seq;\r\nstruct trace_entry *entry = iter->ent;\r\nunsigned long long t;\r\nunsigned long secs, usec_rem;\r\nchar comm[TASK_COMM_LEN];\r\nint ret;\r\ntrace_find_cmdline(entry->pid, comm);\r\nret = trace_seq_printf(s, "%16s-%-5d [%03d] ",\r\ncomm, entry->pid, iter->cpu);\r\nif (!ret)\r\nreturn 0;\r\nif (trace_flags & TRACE_ITER_IRQ_INFO) {\r\nret = trace_print_lat_fmt(s, entry);\r\nif (!ret)\r\nreturn 0;\r\n}\r\nif (iter->iter_flags & TRACE_FILE_TIME_IN_NS) {\r\nt = ns2usecs(iter->ts);\r\nusec_rem = do_div(t, USEC_PER_SEC);\r\nsecs = (unsigned long)t;\r\nreturn trace_seq_printf(s, " %5lu.%06lu: ", secs, usec_rem);\r\n} else\r\nreturn trace_seq_printf(s, " %12llu: ", iter->ts);\r\n}\r\nint trace_print_lat_context(struct trace_iterator *iter)\r\n{\r\nu64 next_ts;\r\nint ret;\r\nint ent_size = iter->ent_size;\r\nstruct trace_seq *s = &iter->seq;\r\nstruct trace_entry *entry = iter->ent,\r\n*next_entry = trace_find_next_entry(iter, NULL,\r\n&next_ts);\r\nunsigned long verbose = (trace_flags & TRACE_ITER_VERBOSE);\r\niter->ent_size = ent_size;\r\nif (!next_entry)\r\nnext_ts = iter->ts;\r\nif (verbose) {\r\nchar comm[TASK_COMM_LEN];\r\ntrace_find_cmdline(entry->pid, comm);\r\nret = trace_seq_printf(\r\ns, "%16s %5d %3d %d %08x %08lx ",\r\ncomm, entry->pid, iter->cpu, entry->flags,\r\nentry->preempt_count, iter->idx);\r\n} else {\r\nret = lat_print_generic(s, entry, iter->cpu);\r\n}\r\nif (ret)\r\nret = lat_print_timestamp(iter, next_ts);\r\nreturn ret;\r\n}\r\nstatic int task_state_char(unsigned long state)\r\n{\r\nint bit = state ? __ffs(state) + 1 : 0;\r\nreturn bit < sizeof(state_to_char) - 1 ? state_to_char[bit] : '?';\r\n}\r\nstruct trace_event *ftrace_find_event(int type)\r\n{\r\nstruct trace_event *event;\r\nunsigned key;\r\nkey = type & (EVENT_HASHSIZE - 1);\r\nhlist_for_each_entry(event, &event_hash[key], node) {\r\nif (event->type == type)\r\nreturn event;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int trace_search_list(struct list_head **list)\r\n{\r\nstruct trace_event *e;\r\nint last = __TRACE_LAST_TYPE;\r\nif (list_empty(&ftrace_event_list)) {\r\n*list = &ftrace_event_list;\r\nreturn last + 1;\r\n}\r\nlist_for_each_entry(e, &ftrace_event_list, list) {\r\nif (e->type != last + 1)\r\nbreak;\r\nlast++;\r\n}\r\nif ((last + 1) > FTRACE_MAX_EVENT)\r\nreturn 0;\r\n*list = &e->list;\r\nreturn last + 1;\r\n}\r\nvoid trace_event_read_lock(void)\r\n{\r\ndown_read(&trace_event_sem);\r\n}\r\nvoid trace_event_read_unlock(void)\r\n{\r\nup_read(&trace_event_sem);\r\n}\r\nint register_ftrace_event(struct trace_event *event)\r\n{\r\nunsigned key;\r\nint ret = 0;\r\ndown_write(&trace_event_sem);\r\nif (WARN_ON(!event))\r\ngoto out;\r\nif (WARN_ON(!event->funcs))\r\ngoto out;\r\nINIT_LIST_HEAD(&event->list);\r\nif (!event->type) {\r\nstruct list_head *list = NULL;\r\nif (next_event_type > FTRACE_MAX_EVENT) {\r\nevent->type = trace_search_list(&list);\r\nif (!event->type)\r\ngoto out;\r\n} else {\r\nevent->type = next_event_type++;\r\nlist = &ftrace_event_list;\r\n}\r\nif (WARN_ON(ftrace_find_event(event->type)))\r\ngoto out;\r\nlist_add_tail(&event->list, list);\r\n} else if (event->type > __TRACE_LAST_TYPE) {\r\nprintk(KERN_WARNING "Need to add type to trace.h\n");\r\nWARN_ON(1);\r\ngoto out;\r\n} else {\r\nif (ftrace_find_event(event->type))\r\ngoto out;\r\n}\r\nif (event->funcs->trace == NULL)\r\nevent->funcs->trace = trace_nop_print;\r\nif (event->funcs->raw == NULL)\r\nevent->funcs->raw = trace_nop_print;\r\nif (event->funcs->hex == NULL)\r\nevent->funcs->hex = trace_nop_print;\r\nif (event->funcs->binary == NULL)\r\nevent->funcs->binary = trace_nop_print;\r\nkey = event->type & (EVENT_HASHSIZE - 1);\r\nhlist_add_head(&event->node, &event_hash[key]);\r\nret = event->type;\r\nout:\r\nup_write(&trace_event_sem);\r\nreturn ret;\r\n}\r\nint __unregister_ftrace_event(struct trace_event *event)\r\n{\r\nhlist_del(&event->node);\r\nlist_del(&event->list);\r\nreturn 0;\r\n}\r\nint unregister_ftrace_event(struct trace_event *event)\r\n{\r\ndown_write(&trace_event_sem);\r\n__unregister_ftrace_event(event);\r\nup_write(&trace_event_sem);\r\nreturn 0;\r\n}\r\nenum print_line_t trace_nop_print(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nif (!trace_seq_printf(&iter->seq, "type: %d\n", iter->ent->type))\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\nreturn TRACE_TYPE_HANDLED;\r\n}\r\nstatic enum print_line_t trace_fn_trace(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nstruct ftrace_entry *field;\r\nstruct trace_seq *s = &iter->seq;\r\ntrace_assign_type(field, iter->ent);\r\nif (!seq_print_ip_sym(s, field->ip, flags))\r\ngoto partial;\r\nif ((flags & TRACE_ITER_PRINT_PARENT) && field->parent_ip) {\r\nif (!trace_seq_puts(s, " <-"))\r\ngoto partial;\r\nif (!seq_print_ip_sym(s,\r\nfield->parent_ip,\r\nflags))\r\ngoto partial;\r\n}\r\nif (!trace_seq_putc(s, '\n'))\r\ngoto partial;\r\nreturn TRACE_TYPE_HANDLED;\r\npartial:\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\n}\r\nstatic enum print_line_t trace_fn_raw(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nstruct ftrace_entry *field;\r\ntrace_assign_type(field, iter->ent);\r\nif (!trace_seq_printf(&iter->seq, "%lx %lx\n",\r\nfield->ip,\r\nfield->parent_ip))\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\nreturn TRACE_TYPE_HANDLED;\r\n}\r\nstatic enum print_line_t trace_fn_hex(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nstruct ftrace_entry *field;\r\nstruct trace_seq *s = &iter->seq;\r\ntrace_assign_type(field, iter->ent);\r\nSEQ_PUT_HEX_FIELD_RET(s, field->ip);\r\nSEQ_PUT_HEX_FIELD_RET(s, field->parent_ip);\r\nreturn TRACE_TYPE_HANDLED;\r\n}\r\nstatic enum print_line_t trace_fn_bin(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nstruct ftrace_entry *field;\r\nstruct trace_seq *s = &iter->seq;\r\ntrace_assign_type(field, iter->ent);\r\nSEQ_PUT_FIELD_RET(s, field->ip);\r\nSEQ_PUT_FIELD_RET(s, field->parent_ip);\r\nreturn TRACE_TYPE_HANDLED;\r\n}\r\nstatic enum print_line_t trace_ctxwake_print(struct trace_iterator *iter,\r\nchar *delim)\r\n{\r\nstruct ctx_switch_entry *field;\r\nchar comm[TASK_COMM_LEN];\r\nint S, T;\r\ntrace_assign_type(field, iter->ent);\r\nT = task_state_char(field->next_state);\r\nS = task_state_char(field->prev_state);\r\ntrace_find_cmdline(field->next_pid, comm);\r\nif (!trace_seq_printf(&iter->seq,\r\n" %5d:%3d:%c %s [%03d] %5d:%3d:%c %s\n",\r\nfield->prev_pid,\r\nfield->prev_prio,\r\nS, delim,\r\nfield->next_cpu,\r\nfield->next_pid,\r\nfield->next_prio,\r\nT, comm))\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\nreturn TRACE_TYPE_HANDLED;\r\n}\r\nstatic enum print_line_t trace_ctx_print(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nreturn trace_ctxwake_print(iter, "==>");\r\n}\r\nstatic enum print_line_t trace_wake_print(struct trace_iterator *iter,\r\nint flags, struct trace_event *event)\r\n{\r\nreturn trace_ctxwake_print(iter, " +");\r\n}\r\nstatic int trace_ctxwake_raw(struct trace_iterator *iter, char S)\r\n{\r\nstruct ctx_switch_entry *field;\r\nint T;\r\ntrace_assign_type(field, iter->ent);\r\nif (!S)\r\nS = task_state_char(field->prev_state);\r\nT = task_state_char(field->next_state);\r\nif (!trace_seq_printf(&iter->seq, "%d %d %c %d %d %d %c\n",\r\nfield->prev_pid,\r\nfield->prev_prio,\r\nS,\r\nfield->next_cpu,\r\nfield->next_pid,\r\nfield->next_prio,\r\nT))\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\nreturn TRACE_TYPE_HANDLED;\r\n}\r\nstatic enum print_line_t trace_ctx_raw(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nreturn trace_ctxwake_raw(iter, 0);\r\n}\r\nstatic enum print_line_t trace_wake_raw(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nreturn trace_ctxwake_raw(iter, '+');\r\n}\r\nstatic int trace_ctxwake_hex(struct trace_iterator *iter, char S)\r\n{\r\nstruct ctx_switch_entry *field;\r\nstruct trace_seq *s = &iter->seq;\r\nint T;\r\ntrace_assign_type(field, iter->ent);\r\nif (!S)\r\nS = task_state_char(field->prev_state);\r\nT = task_state_char(field->next_state);\r\nSEQ_PUT_HEX_FIELD_RET(s, field->prev_pid);\r\nSEQ_PUT_HEX_FIELD_RET(s, field->prev_prio);\r\nSEQ_PUT_HEX_FIELD_RET(s, S);\r\nSEQ_PUT_HEX_FIELD_RET(s, field->next_cpu);\r\nSEQ_PUT_HEX_FIELD_RET(s, field->next_pid);\r\nSEQ_PUT_HEX_FIELD_RET(s, field->next_prio);\r\nSEQ_PUT_HEX_FIELD_RET(s, T);\r\nreturn TRACE_TYPE_HANDLED;\r\n}\r\nstatic enum print_line_t trace_ctx_hex(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nreturn trace_ctxwake_hex(iter, 0);\r\n}\r\nstatic enum print_line_t trace_wake_hex(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nreturn trace_ctxwake_hex(iter, '+');\r\n}\r\nstatic enum print_line_t trace_ctxwake_bin(struct trace_iterator *iter,\r\nint flags, struct trace_event *event)\r\n{\r\nstruct ctx_switch_entry *field;\r\nstruct trace_seq *s = &iter->seq;\r\ntrace_assign_type(field, iter->ent);\r\nSEQ_PUT_FIELD_RET(s, field->prev_pid);\r\nSEQ_PUT_FIELD_RET(s, field->prev_prio);\r\nSEQ_PUT_FIELD_RET(s, field->prev_state);\r\nSEQ_PUT_FIELD_RET(s, field->next_pid);\r\nSEQ_PUT_FIELD_RET(s, field->next_prio);\r\nSEQ_PUT_FIELD_RET(s, field->next_state);\r\nreturn TRACE_TYPE_HANDLED;\r\n}\r\nstatic enum print_line_t trace_stack_print(struct trace_iterator *iter,\r\nint flags, struct trace_event *event)\r\n{\r\nstruct stack_entry *field;\r\nstruct trace_seq *s = &iter->seq;\r\nunsigned long *p;\r\nunsigned long *end;\r\ntrace_assign_type(field, iter->ent);\r\nend = (unsigned long *)((long)iter->ent + iter->ent_size);\r\nif (!trace_seq_puts(s, "<stack trace>\n"))\r\ngoto partial;\r\nfor (p = field->caller; p && *p != ULONG_MAX && p < end; p++) {\r\nif (!trace_seq_puts(s, " => "))\r\ngoto partial;\r\nif (!seq_print_ip_sym(s, *p, flags))\r\ngoto partial;\r\nif (!trace_seq_putc(s, '\n'))\r\ngoto partial;\r\n}\r\nreturn TRACE_TYPE_HANDLED;\r\npartial:\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\n}\r\nstatic enum print_line_t trace_user_stack_print(struct trace_iterator *iter,\r\nint flags, struct trace_event *event)\r\n{\r\nstruct userstack_entry *field;\r\nstruct trace_seq *s = &iter->seq;\r\ntrace_assign_type(field, iter->ent);\r\nif (!trace_seq_puts(s, "<user stack trace>\n"))\r\ngoto partial;\r\nif (!seq_print_userip_objs(field, s, flags))\r\ngoto partial;\r\nreturn TRACE_TYPE_HANDLED;\r\npartial:\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\n}\r\nstatic enum print_line_t\r\ntrace_bputs_print(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nstruct trace_entry *entry = iter->ent;\r\nstruct trace_seq *s = &iter->seq;\r\nstruct bputs_entry *field;\r\ntrace_assign_type(field, entry);\r\nif (!seq_print_ip_sym(s, field->ip, flags))\r\ngoto partial;\r\nif (!trace_seq_puts(s, ": "))\r\ngoto partial;\r\nif (!trace_seq_puts(s, field->str))\r\ngoto partial;\r\nreturn TRACE_TYPE_HANDLED;\r\npartial:\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\n}\r\nstatic enum print_line_t\r\ntrace_bputs_raw(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nstruct bputs_entry *field;\r\nstruct trace_seq *s = &iter->seq;\r\ntrace_assign_type(field, iter->ent);\r\nif (!trace_seq_printf(s, ": %lx : ", field->ip))\r\ngoto partial;\r\nif (!trace_seq_puts(s, field->str))\r\ngoto partial;\r\nreturn TRACE_TYPE_HANDLED;\r\npartial:\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\n}\r\nstatic enum print_line_t\r\ntrace_bprint_print(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nstruct trace_entry *entry = iter->ent;\r\nstruct trace_seq *s = &iter->seq;\r\nstruct bprint_entry *field;\r\ntrace_assign_type(field, entry);\r\nif (!seq_print_ip_sym(s, field->ip, flags))\r\ngoto partial;\r\nif (!trace_seq_puts(s, ": "))\r\ngoto partial;\r\nif (!trace_seq_bprintf(s, field->fmt, field->buf))\r\ngoto partial;\r\nreturn TRACE_TYPE_HANDLED;\r\npartial:\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\n}\r\nstatic enum print_line_t\r\ntrace_bprint_raw(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nstruct bprint_entry *field;\r\nstruct trace_seq *s = &iter->seq;\r\ntrace_assign_type(field, iter->ent);\r\nif (!trace_seq_printf(s, ": %lx : ", field->ip))\r\ngoto partial;\r\nif (!trace_seq_bprintf(s, field->fmt, field->buf))\r\ngoto partial;\r\nreturn TRACE_TYPE_HANDLED;\r\npartial:\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\n}\r\nstatic enum print_line_t trace_print_print(struct trace_iterator *iter,\r\nint flags, struct trace_event *event)\r\n{\r\nstruct print_entry *field;\r\nstruct trace_seq *s = &iter->seq;\r\ntrace_assign_type(field, iter->ent);\r\nif (!seq_print_ip_sym(s, field->ip, flags))\r\ngoto partial;\r\nif (!trace_seq_printf(s, ": %s", field->buf))\r\ngoto partial;\r\nreturn TRACE_TYPE_HANDLED;\r\npartial:\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\n}\r\nstatic enum print_line_t trace_print_raw(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nstruct print_entry *field;\r\ntrace_assign_type(field, iter->ent);\r\nif (!trace_seq_printf(&iter->seq, "# %lx %s", field->ip, field->buf))\r\ngoto partial;\r\nreturn TRACE_TYPE_HANDLED;\r\npartial:\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\n}\r\n__init static int init_events(void)\r\n{\r\nstruct trace_event *event;\r\nint i, ret;\r\nfor (i = 0; events[i]; i++) {\r\nevent = events[i];\r\nret = register_ftrace_event(event);\r\nif (!ret) {\r\nprintk(KERN_WARNING "event %d failed to register\n",\r\nevent->type);\r\nWARN_ON_ONCE(1);\r\n}\r\n}\r\nreturn 0;\r\n}
