void saa7134_track_gpio(struct saa7134_dev *dev, char *msg)\r\n{\r\nunsigned long mode,status;\r\nif (!gpio_tracking)\r\nreturn;\r\nsaa_andorb(SAA7134_GPIO_GPMODE3,SAA7134_GPIO_GPRESCAN,0);\r\nsaa_andorb(SAA7134_GPIO_GPMODE3,SAA7134_GPIO_GPRESCAN,SAA7134_GPIO_GPRESCAN);\r\nmode = saa_readl(SAA7134_GPIO_GPMODE0 >> 2) & 0xfffffff;\r\nstatus = saa_readl(SAA7134_GPIO_GPSTATUS0 >> 2) & 0xfffffff;\r\nprintk(KERN_DEBUG\r\n"%s: gpio: mode=0x%07lx in=0x%07lx out=0x%07lx [%s]\n",\r\ndev->name, mode, (~mode) & status, mode & status, msg);\r\n}\r\nvoid saa7134_set_gpio(struct saa7134_dev *dev, int bit_no, int value)\r\n{\r\nu32 index, bitval;\r\nindex = 1 << bit_no;\r\nswitch (value) {\r\ncase 0:\r\ncase 1: dprintk("setting GPIO%d to static %d\n", bit_no, value);\r\nif (index & 0x00c00000)\r\nsaa_andorb(SAA7134_VIDEO_PORT_CTRL6, 0x0f, 0x00);\r\nif (value)\r\nbitval = index;\r\nelse\r\nbitval = 0;\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, index, index);\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, index, bitval);\r\nbreak;\r\ncase 3:\r\ndprintk("setting GPIO%d to tristate\n", bit_no);\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, index, 0);\r\nbreak;\r\n}\r\n}\r\nstatic void request_module_async(struct work_struct *work){\r\nstruct saa7134_dev* dev = container_of(work, struct saa7134_dev, request_module_wk);\r\nif (card_is_empress(dev))\r\nrequest_module("saa7134-empress");\r\nif (card_is_dvb(dev))\r\nrequest_module("saa7134-dvb");\r\nif (alsa) {\r\nif (dev->pci->device != PCI_DEVICE_ID_PHILIPS_SAA7130)\r\nrequest_module("saa7134-alsa");\r\n}\r\n}\r\nstatic void request_submodules(struct saa7134_dev *dev)\r\n{\r\nINIT_WORK(&dev->request_module_wk, request_module_async);\r\nschedule_work(&dev->request_module_wk);\r\n}\r\nstatic void flush_request_submodules(struct saa7134_dev *dev)\r\n{\r\nflush_work(&dev->request_module_wk);\r\n}\r\nstatic int saa7134_buffer_pages(int size)\r\n{\r\nsize = PAGE_ALIGN(size);\r\nsize += PAGE_SIZE;\r\nsize /= 4096;\r\nreturn size;\r\n}\r\nint saa7134_buffer_count(unsigned int size, unsigned int count)\r\n{\r\nunsigned int maxcount;\r\nmaxcount = 1024 / saa7134_buffer_pages(size);\r\nif (count > maxcount)\r\ncount = maxcount;\r\nreturn count;\r\n}\r\nint saa7134_buffer_startpage(struct saa7134_buf *buf)\r\n{\r\nreturn saa7134_buffer_pages(buf->vb.bsize) * buf->vb.i;\r\n}\r\nunsigned long saa7134_buffer_base(struct saa7134_buf *buf)\r\n{\r\nunsigned long base;\r\nstruct videobuf_dmabuf *dma=videobuf_to_dma(&buf->vb);\r\nbase = saa7134_buffer_startpage(buf) * 4096;\r\nbase += dma->sglist[0].offset;\r\nreturn base;\r\n}\r\nint saa7134_pgtable_alloc(struct pci_dev *pci, struct saa7134_pgtable *pt)\r\n{\r\n__le32 *cpu;\r\ndma_addr_t dma_addr = 0;\r\ncpu = pci_alloc_consistent(pci, SAA7134_PGTABLE_SIZE, &dma_addr);\r\nif (NULL == cpu)\r\nreturn -ENOMEM;\r\npt->size = SAA7134_PGTABLE_SIZE;\r\npt->cpu = cpu;\r\npt->dma = dma_addr;\r\nreturn 0;\r\n}\r\nint saa7134_pgtable_build(struct pci_dev *pci, struct saa7134_pgtable *pt,\r\nstruct scatterlist *list, unsigned int length,\r\nunsigned int startpage)\r\n{\r\n__le32 *ptr;\r\nunsigned int i,p;\r\nBUG_ON(NULL == pt || NULL == pt->cpu);\r\nptr = pt->cpu + startpage;\r\nfor (i = 0; i < length; i++, list++)\r\nfor (p = 0; p * 4096 < list->length; p++, ptr++)\r\n*ptr = cpu_to_le32(sg_dma_address(list) - list->offset);\r\nreturn 0;\r\n}\r\nvoid saa7134_pgtable_free(struct pci_dev *pci, struct saa7134_pgtable *pt)\r\n{\r\nif (NULL == pt->cpu)\r\nreturn;\r\npci_free_consistent(pci, pt->size, pt->cpu, pt->dma);\r\npt->cpu = NULL;\r\n}\r\nvoid saa7134_dma_free(struct videobuf_queue *q,struct saa7134_buf *buf)\r\n{\r\nstruct videobuf_dmabuf *dma=videobuf_to_dma(&buf->vb);\r\nBUG_ON(in_interrupt());\r\nvideobuf_waiton(q, &buf->vb, 0, 0);\r\nvideobuf_dma_unmap(q->dev, dma);\r\nvideobuf_dma_free(dma);\r\nbuf->vb.state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nint saa7134_buffer_queue(struct saa7134_dev *dev,\r\nstruct saa7134_dmaqueue *q,\r\nstruct saa7134_buf *buf)\r\n{\r\nstruct saa7134_buf *next = NULL;\r\nassert_spin_locked(&dev->slock);\r\ndprintk("buffer_queue %p\n",buf);\r\nif (NULL == q->curr) {\r\nif (!q->need_two) {\r\nq->curr = buf;\r\nbuf->activate(dev,buf,NULL);\r\n} else if (list_empty(&q->queue)) {\r\nlist_add_tail(&buf->vb.queue,&q->queue);\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\n} else {\r\nnext = list_entry(q->queue.next,struct saa7134_buf,\r\nvb.queue);\r\nq->curr = buf;\r\nbuf->activate(dev,buf,next);\r\n}\r\n} else {\r\nlist_add_tail(&buf->vb.queue,&q->queue);\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\n}\r\nreturn 0;\r\n}\r\nvoid saa7134_buffer_finish(struct saa7134_dev *dev,\r\nstruct saa7134_dmaqueue *q,\r\nunsigned int state)\r\n{\r\nassert_spin_locked(&dev->slock);\r\ndprintk("buffer_finish %p\n",q->curr);\r\nq->curr->vb.state = state;\r\nv4l2_get_timestamp(&q->curr->vb.ts);\r\nwake_up(&q->curr->vb.done);\r\nq->curr = NULL;\r\n}\r\nvoid saa7134_buffer_next(struct saa7134_dev *dev,\r\nstruct saa7134_dmaqueue *q)\r\n{\r\nstruct saa7134_buf *buf,*next = NULL;\r\nassert_spin_locked(&dev->slock);\r\nBUG_ON(NULL != q->curr);\r\nif (!list_empty(&q->queue)) {\r\nbuf = list_entry(q->queue.next,struct saa7134_buf,vb.queue);\r\ndprintk("buffer_next %p [prev=%p/next=%p]\n",\r\nbuf,q->queue.prev,q->queue.next);\r\nlist_del(&buf->vb.queue);\r\nif (!list_empty(&q->queue))\r\nnext = list_entry(q->queue.next,struct saa7134_buf,\r\nvb.queue);\r\nq->curr = buf;\r\nbuf->activate(dev,buf,next);\r\ndprintk("buffer_next #2 prev=%p/next=%p\n",\r\nq->queue.prev,q->queue.next);\r\n} else {\r\ndprintk("buffer_next %p\n",NULL);\r\nsaa7134_set_dmabits(dev);\r\ndel_timer(&q->timeout);\r\nif (card_has_mpeg(dev))\r\nif (dev->ts_started)\r\nsaa7134_ts_stop(dev);\r\n}\r\n}\r\nvoid saa7134_buffer_timeout(unsigned long data)\r\n{\r\nstruct saa7134_dmaqueue *q = (struct saa7134_dmaqueue*)data;\r\nstruct saa7134_dev *dev = q->dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->slock,flags);\r\nsaa_writeb(SAA7134_REGION_ENABLE, 0x00);\r\nsaa_writeb(SAA7134_REGION_ENABLE, 0x80);\r\nsaa_writeb(SAA7134_REGION_ENABLE, 0x00);\r\nif (q->curr) {\r\ndprintk("timeout on %p\n",q->curr);\r\nsaa7134_buffer_finish(dev,q,VIDEOBUF_ERROR);\r\n}\r\nsaa7134_buffer_next(dev,q);\r\nspin_unlock_irqrestore(&dev->slock,flags);\r\n}\r\nint saa7134_set_dmabits(struct saa7134_dev *dev)\r\n{\r\nu32 split, task=0, ctrl=0, irq=0;\r\nenum v4l2_field cap = V4L2_FIELD_ANY;\r\nenum v4l2_field ov = V4L2_FIELD_ANY;\r\nassert_spin_locked(&dev->slock);\r\nif (dev->insuspend)\r\nreturn 0;\r\nif (dev->video_q.curr) {\r\ntask |= 0x01;\r\nctrl |= SAA7134_MAIN_CTRL_TE0;\r\nirq |= SAA7134_IRQ1_INTE_RA0_1 |\r\nSAA7134_IRQ1_INTE_RA0_0;\r\ncap = dev->video_q.curr->vb.field;\r\n}\r\nif (dev->video_q.curr &&\r\ndev->video_q.curr->fmt->planar) {\r\nctrl |= SAA7134_MAIN_CTRL_TE4 |\r\nSAA7134_MAIN_CTRL_TE5;\r\n}\r\nif (dev->ovenable) {\r\ntask |= 0x10;\r\nctrl |= SAA7134_MAIN_CTRL_TE1;\r\nov = dev->ovfield;\r\n}\r\nif (dev->vbi_q.curr) {\r\ntask |= 0x22;\r\nctrl |= SAA7134_MAIN_CTRL_TE2 |\r\nSAA7134_MAIN_CTRL_TE3;\r\nirq |= SAA7134_IRQ1_INTE_RA0_7 |\r\nSAA7134_IRQ1_INTE_RA0_6 |\r\nSAA7134_IRQ1_INTE_RA0_5 |\r\nSAA7134_IRQ1_INTE_RA0_4;\r\n}\r\nif (dev->dmasound.dma_running) {\r\nctrl |= SAA7134_MAIN_CTRL_TE6;\r\nirq |= SAA7134_IRQ1_INTE_RA3_1 |\r\nSAA7134_IRQ1_INTE_RA3_0;\r\n}\r\nif (dev->ts_q.curr) {\r\nctrl |= SAA7134_MAIN_CTRL_TE5;\r\nirq |= SAA7134_IRQ1_INTE_RA2_1 |\r\nSAA7134_IRQ1_INTE_RA2_0;\r\n}\r\nif (V4L2_FIELD_HAS_BOTH(cap) || V4L2_FIELD_HAS_BOTH(ov) || cap == ov) {\r\nsaa_writeb(SAA7134_TASK_CONDITIONS(TASK_A), 0x0d);\r\nsaa_writeb(SAA7134_TASK_CONDITIONS(TASK_B), 0x0d);\r\nsaa_writeb(SAA7134_FIELD_HANDLING(TASK_A), 0x02);\r\nsaa_writeb(SAA7134_FIELD_HANDLING(TASK_B), 0x02);\r\nsplit = 0;\r\n} else {\r\nif (V4L2_FIELD_TOP == cap) {\r\nsaa_writeb(SAA7134_TASK_CONDITIONS(TASK_A), 0x0d);\r\nsaa_writeb(SAA7134_TASK_CONDITIONS(TASK_B), 0x0e);\r\n} else {\r\nsaa_writeb(SAA7134_TASK_CONDITIONS(TASK_A), 0x0e);\r\nsaa_writeb(SAA7134_TASK_CONDITIONS(TASK_B), 0x0d);\r\n}\r\nsaa_writeb(SAA7134_FIELD_HANDLING(TASK_A), 0x01);\r\nsaa_writeb(SAA7134_FIELD_HANDLING(TASK_B), 0x01);\r\nsplit = 1;\r\n}\r\nsaa_writeb(SAA7134_REGION_ENABLE, task);\r\nsaa_writel(SAA7134_IRQ1, irq);\r\nsaa_andorl(SAA7134_MAIN_CTRL,\r\nSAA7134_MAIN_CTRL_TE0 |\r\nSAA7134_MAIN_CTRL_TE1 |\r\nSAA7134_MAIN_CTRL_TE2 |\r\nSAA7134_MAIN_CTRL_TE3 |\r\nSAA7134_MAIN_CTRL_TE4 |\r\nSAA7134_MAIN_CTRL_TE5 |\r\nSAA7134_MAIN_CTRL_TE6,\r\nctrl);\r\ndprintk("dmabits: task=0x%02x ctrl=0x%02x irq=0x%x split=%s\n",\r\ntask, ctrl, irq, split ? "no" : "yes");\r\nreturn 0;\r\n}\r\nstatic void print_irqstatus(struct saa7134_dev *dev, int loop,\r\nunsigned long report, unsigned long status)\r\n{\r\nunsigned int i;\r\nprintk(KERN_DEBUG "%s/irq[%d,%ld]: r=0x%lx s=0x%02lx",\r\ndev->name,loop,jiffies,report,status);\r\nfor (i = 0; i < IRQBITS; i++) {\r\nif (!(report & (1 << i)))\r\ncontinue;\r\nprintk(" %s",irqbits[i]);\r\n}\r\nif (report & SAA7134_IRQ_REPORT_DONE_RA0) {\r\nprintk(" | RA0=%s,%s,%s,%ld",\r\n(status & 0x40) ? "vbi" : "video",\r\n(status & 0x20) ? "b" : "a",\r\n(status & 0x10) ? "odd" : "even",\r\n(status & 0x0f));\r\n}\r\nprintk("\n");\r\n}\r\nstatic irqreturn_t saa7134_irq(int irq, void *dev_id)\r\n{\r\nstruct saa7134_dev *dev = (struct saa7134_dev*) dev_id;\r\nunsigned long report,status;\r\nint loop, handled = 0;\r\nif (dev->insuspend)\r\ngoto out;\r\nfor (loop = 0; loop < 10; loop++) {\r\nreport = saa_readl(SAA7134_IRQ_REPORT);\r\nstatus = saa_readl(SAA7134_IRQ_STATUS);\r\nif ((report & SAA7134_IRQ_REPORT_DONE_RA3) &&\r\n(dev->dmasound.priv_data != NULL) )\r\n{\r\nif (irq_debug > 1)\r\nprintk(KERN_DEBUG "%s/irq: preserving DMA sound interrupt\n",\r\ndev->name);\r\nreport &= ~SAA7134_IRQ_REPORT_DONE_RA3;\r\n}\r\nif (0 == report) {\r\nif (irq_debug > 1)\r\nprintk(KERN_DEBUG "%s/irq: no (more) work\n",\r\ndev->name);\r\ngoto out;\r\n}\r\nhandled = 1;\r\nsaa_writel(SAA7134_IRQ_REPORT,report);\r\nif (irq_debug)\r\nprint_irqstatus(dev,loop,report,status);\r\nif ((report & SAA7134_IRQ_REPORT_RDCAP) ||\r\n(report & SAA7134_IRQ_REPORT_INTL))\r\nsaa7134_irq_video_signalchange(dev);\r\nif ((report & SAA7134_IRQ_REPORT_DONE_RA0) &&\r\n(status & 0x60) == 0)\r\nsaa7134_irq_video_done(dev,status);\r\nif ((report & SAA7134_IRQ_REPORT_DONE_RA0) &&\r\n(status & 0x40) == 0x40)\r\nsaa7134_irq_vbi_done(dev,status);\r\nif ((report & SAA7134_IRQ_REPORT_DONE_RA2) &&\r\ncard_has_mpeg(dev))\r\nsaa7134_irq_ts_done(dev,status);\r\nif (report & SAA7134_IRQ_REPORT_GPIO16) {\r\nswitch (dev->has_remote) {\r\ncase SAA7134_REMOTE_GPIO:\r\nif (!dev->remote)\r\nbreak;\r\nif (dev->remote->mask_keydown & 0x10000) {\r\nsaa7134_input_irq(dev);\r\n}\r\nbreak;\r\ncase SAA7134_REMOTE_I2C:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (report & SAA7134_IRQ_REPORT_GPIO18) {\r\nswitch (dev->has_remote) {\r\ncase SAA7134_REMOTE_GPIO:\r\nif (!dev->remote)\r\nbreak;\r\nif ((dev->remote->mask_keydown & 0x40000) ||\r\n(dev->remote->mask_keyup & 0x40000)) {\r\nsaa7134_input_irq(dev);\r\n}\r\nbreak;\r\ncase SAA7134_REMOTE_I2C:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nif (10 == loop) {\r\nprint_irqstatus(dev,loop,report,status);\r\nif (report & SAA7134_IRQ_REPORT_PE) {\r\nprintk(KERN_WARNING "%s/irq: looping -- "\r\n"clearing PE (parity error!) enable bit\n",dev->name);\r\nsaa_clearl(SAA7134_IRQ2,SAA7134_IRQ2_INTE_PE);\r\n} else if (report & SAA7134_IRQ_REPORT_GPIO16) {\r\nprintk(KERN_WARNING "%s/irq: looping -- "\r\n"clearing GPIO16 enable bit\n",dev->name);\r\nsaa_clearl(SAA7134_IRQ2, SAA7134_IRQ2_INTE_GPIO16_P);\r\nsaa_clearl(SAA7134_IRQ2, SAA7134_IRQ2_INTE_GPIO16_N);\r\n} else if (report & SAA7134_IRQ_REPORT_GPIO18) {\r\nprintk(KERN_WARNING "%s/irq: looping -- "\r\n"clearing GPIO18 enable bit\n",dev->name);\r\nsaa_clearl(SAA7134_IRQ2, SAA7134_IRQ2_INTE_GPIO18_P);\r\nsaa_clearl(SAA7134_IRQ2, SAA7134_IRQ2_INTE_GPIO18_N);\r\n} else {\r\nprintk(KERN_WARNING "%s/irq: looping -- "\r\n"clearing all enable bits\n",dev->name);\r\nsaa_writel(SAA7134_IRQ1,0);\r\nsaa_writel(SAA7134_IRQ2,0);\r\n}\r\n}\r\nout:\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int saa7134_hw_enable1(struct saa7134_dev *dev)\r\n{\r\nsaa_writel(SAA7134_FIFO_SIZE, 0x08070503);\r\nsaa_writel(SAA7134_THRESHOULD, 0x02020202);\r\nsaa_writel(SAA7134_MAIN_CTRL,\r\nSAA7134_MAIN_CTRL_VPLLE |\r\nSAA7134_MAIN_CTRL_APLLE |\r\nSAA7134_MAIN_CTRL_EXOSC |\r\nSAA7134_MAIN_CTRL_EVFE1 |\r\nSAA7134_MAIN_CTRL_EVFE2 |\r\nSAA7134_MAIN_CTRL_ESFE |\r\nSAA7134_MAIN_CTRL_EBDAC);\r\nsaa_writeb(SAA7134_SPECIAL_MODE, 0x01);\r\nsaa_writeb(SAA7134_SOURCE_TIMING2, 0x20);\r\nreturn 0;\r\n}\r\nstatic int saa7134_hwinit1(struct saa7134_dev *dev)\r\n{\r\ndprintk("hwinit1\n");\r\nsaa_writel(SAA7134_IRQ1, 0);\r\nsaa_writel(SAA7134_IRQ2, 0);\r\nsaa_writel(SAA7134_IRQ_REPORT, saa_readl(SAA7134_IRQ_REPORT));\r\nmutex_init(&dev->lock);\r\nspin_lock_init(&dev->slock);\r\nsaa7134_track_gpio(dev,"pre-init");\r\nsaa7134_video_init1(dev);\r\nsaa7134_vbi_init1(dev);\r\nif (card_has_mpeg(dev))\r\nsaa7134_ts_init1(dev);\r\nsaa7134_input_init1(dev);\r\nsaa7134_hw_enable1(dev);\r\nreturn 0;\r\n}\r\nstatic int saa7134_hw_enable2(struct saa7134_dev *dev)\r\n{\r\nunsigned int irq2_mask;\r\nirq2_mask =\r\nSAA7134_IRQ2_INTE_DEC3 |\r\nSAA7134_IRQ2_INTE_DEC2 |\r\nSAA7134_IRQ2_INTE_DEC1 |\r\nSAA7134_IRQ2_INTE_DEC0 |\r\nSAA7134_IRQ2_INTE_PE |\r\nSAA7134_IRQ2_INTE_AR;\r\nif (dev->has_remote == SAA7134_REMOTE_GPIO && dev->remote) {\r\nif (dev->remote->mask_keydown & 0x10000)\r\nirq2_mask |= SAA7134_IRQ2_INTE_GPIO16_N;\r\nelse {\r\nif (dev->remote->mask_keydown & 0x40000)\r\nirq2_mask |= SAA7134_IRQ2_INTE_GPIO18_P;\r\nif (dev->remote->mask_keyup & 0x40000)\r\nirq2_mask |= SAA7134_IRQ2_INTE_GPIO18_N;\r\n}\r\n}\r\nif (dev->has_remote == SAA7134_REMOTE_I2C) {\r\nrequest_module("ir-kbd-i2c");\r\n}\r\nsaa_writel(SAA7134_IRQ1, 0);\r\nsaa_writel(SAA7134_IRQ2, irq2_mask);\r\nreturn 0;\r\n}\r\nstatic int saa7134_hwinit2(struct saa7134_dev *dev)\r\n{\r\ndprintk("hwinit2\n");\r\nsaa7134_video_init2(dev);\r\nsaa7134_tvaudio_init2(dev);\r\nsaa7134_hw_enable2(dev);\r\nreturn 0;\r\n}\r\nstatic int saa7134_hwfini(struct saa7134_dev *dev)\r\n{\r\ndprintk("hwfini\n");\r\nif (card_has_mpeg(dev))\r\nsaa7134_ts_fini(dev);\r\nsaa7134_input_fini(dev);\r\nsaa7134_vbi_fini(dev);\r\nsaa7134_tvaudio_fini(dev);\r\nreturn 0;\r\n}\r\nstatic void must_configure_manually(int has_eeprom)\r\n{\r\nunsigned int i,p;\r\nif (!has_eeprom)\r\nprintk(KERN_WARNING\r\n"saa7134: <rant>\n"\r\n"saa7134: Congratulations! Your TV card vendor saved a few\n"\r\n"saa7134: cents for a eeprom, thus your pci board has no\n"\r\n"saa7134: subsystem ID and I can't identify it automatically\n"\r\n"saa7134: </rant>\n"\r\n"saa7134: I feel better now. Ok, here are the good news:\n"\r\n"saa7134: You can use the card=<nr> insmod option to specify\n"\r\n"saa7134: which board do you have. The list:\n");\r\nelse\r\nprintk(KERN_WARNING\r\n"saa7134: Board is currently unknown. You might try to use the card=<nr>\n"\r\n"saa7134: insmod option to specify which board do you have, but this is\n"\r\n"saa7134: somewhat risky, as might damage your card. It is better to ask\n"\r\n"saa7134: for support at linux-media@vger.kernel.org.\n"\r\n"saa7134: The supported cards are:\n");\r\nfor (i = 0; i < saa7134_bcount; i++) {\r\nprintk(KERN_WARNING "saa7134: card=%d -> %-40.40s",\r\ni,saa7134_boards[i].name);\r\nfor (p = 0; saa7134_pci_tbl[p].driver_data; p++) {\r\nif (saa7134_pci_tbl[p].driver_data != i)\r\ncontinue;\r\nprintk(" %04x:%04x",\r\nsaa7134_pci_tbl[p].subvendor,\r\nsaa7134_pci_tbl[p].subdevice);\r\n}\r\nprintk("\n");\r\n}\r\n}\r\nstatic struct video_device *vdev_init(struct saa7134_dev *dev,\r\nstruct video_device *template,\r\nchar *type)\r\n{\r\nstruct video_device *vfd;\r\nvfd = video_device_alloc();\r\nif (NULL == vfd)\r\nreturn NULL;\r\n*vfd = *template;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->release = video_device_release;\r\nvfd->debug = video_debug;\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s %s (%s)",\r\ndev->name, type, saa7134_boards[dev->board].name);\r\nset_bit(V4L2_FL_USE_FH_PRIO, &vfd->flags);\r\nvideo_set_drvdata(vfd, dev);\r\nreturn vfd;\r\n}\r\nstatic void saa7134_unregister_video(struct saa7134_dev *dev)\r\n{\r\nif (dev->video_dev) {\r\nif (video_is_registered(dev->video_dev))\r\nvideo_unregister_device(dev->video_dev);\r\nelse\r\nvideo_device_release(dev->video_dev);\r\ndev->video_dev = NULL;\r\n}\r\nif (dev->vbi_dev) {\r\nif (video_is_registered(dev->vbi_dev))\r\nvideo_unregister_device(dev->vbi_dev);\r\nelse\r\nvideo_device_release(dev->vbi_dev);\r\ndev->vbi_dev = NULL;\r\n}\r\nif (dev->radio_dev) {\r\nif (video_is_registered(dev->radio_dev))\r\nvideo_unregister_device(dev->radio_dev);\r\nelse\r\nvideo_device_release(dev->radio_dev);\r\ndev->radio_dev = NULL;\r\n}\r\n}\r\nstatic void mpeg_ops_attach(struct saa7134_mpeg_ops *ops,\r\nstruct saa7134_dev *dev)\r\n{\r\nint err;\r\nif (NULL != dev->mops)\r\nreturn;\r\nif (saa7134_boards[dev->board].mpeg != ops->type)\r\nreturn;\r\nerr = ops->init(dev);\r\nif (0 != err)\r\nreturn;\r\ndev->mops = ops;\r\n}\r\nstatic void mpeg_ops_detach(struct saa7134_mpeg_ops *ops,\r\nstruct saa7134_dev *dev)\r\n{\r\nif (NULL == dev->mops)\r\nreturn;\r\nif (dev->mops != ops)\r\nreturn;\r\ndev->mops->fini(dev);\r\ndev->mops = NULL;\r\n}\r\nstatic int saa7134_initdev(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct saa7134_dev *dev;\r\nstruct saa7134_mpeg_ops *mops;\r\nint err;\r\nif (saa7134_devcount == SAA7134_MAXBOARDS)\r\nreturn -ENOMEM;\r\ndev = kzalloc(sizeof(*dev),GFP_KERNEL);\r\nif (NULL == dev)\r\nreturn -ENOMEM;\r\nerr = v4l2_device_register(&pci_dev->dev, &dev->v4l2_dev);\r\nif (err)\r\ngoto fail0;\r\ndev->pci = pci_dev;\r\nif (pci_enable_device(pci_dev)) {\r\nerr = -EIO;\r\ngoto fail1;\r\n}\r\ndev->nr = saa7134_devcount;\r\nsprintf(dev->name,"saa%x[%d]",pci_dev->device,dev->nr);\r\nif (pci_pci_problems) {\r\nif (pci_pci_problems & PCIPCI_TRITON)\r\nprintk(KERN_INFO "%s: quirk: PCIPCI_TRITON\n", dev->name);\r\nif (pci_pci_problems & PCIPCI_NATOMA)\r\nprintk(KERN_INFO "%s: quirk: PCIPCI_NATOMA\n", dev->name);\r\nif (pci_pci_problems & PCIPCI_VIAETBF)\r\nprintk(KERN_INFO "%s: quirk: PCIPCI_VIAETBF\n", dev->name);\r\nif (pci_pci_problems & PCIPCI_VSFX)\r\nprintk(KERN_INFO "%s: quirk: PCIPCI_VSFX\n",dev->name);\r\n#ifdef PCIPCI_ALIMAGIK\r\nif (pci_pci_problems & PCIPCI_ALIMAGIK) {\r\nprintk(KERN_INFO "%s: quirk: PCIPCI_ALIMAGIK -- latency fixup\n",\r\ndev->name);\r\nlatency = 0x0A;\r\n}\r\n#endif\r\nif (pci_pci_problems & (PCIPCI_FAIL|PCIAGP_FAIL)) {\r\nprintk(KERN_INFO "%s: quirk: this driver and your "\r\n"chipset may not work together"\r\n" in overlay mode.\n",dev->name);\r\nif (!saa7134_no_overlay) {\r\nprintk(KERN_INFO "%s: quirk: overlay "\r\n"mode will be disabled.\n",\r\ndev->name);\r\nsaa7134_no_overlay = 1;\r\n} else {\r\nprintk(KERN_INFO "%s: quirk: overlay "\r\n"mode will be forced. Use this"\r\n" option at your own risk.\n",\r\ndev->name);\r\n}\r\n}\r\n}\r\nif (UNSET != latency) {\r\nprintk(KERN_INFO "%s: setting pci latency timer to %d\n",\r\ndev->name,latency);\r\npci_write_config_byte(pci_dev, PCI_LATENCY_TIMER, latency);\r\n}\r\ndev->pci_rev = pci_dev->revision;\r\npci_read_config_byte(pci_dev, PCI_LATENCY_TIMER, &dev->pci_lat);\r\nprintk(KERN_INFO "%s: found at %s, rev: %d, irq: %d, "\r\n"latency: %d, mmio: 0x%llx\n", dev->name,\r\npci_name(pci_dev), dev->pci_rev, pci_dev->irq,\r\ndev->pci_lat,(unsigned long long)pci_resource_start(pci_dev,0));\r\npci_set_master(pci_dev);\r\nif (!pci_dma_supported(pci_dev, DMA_BIT_MASK(32))) {\r\nprintk("%s: Oops: no 32bit PCI DMA ???\n",dev->name);\r\nerr = -EIO;\r\ngoto fail1;\r\n}\r\ndev->board = pci_id->driver_data;\r\nif ((unsigned)card[dev->nr] < saa7134_bcount)\r\ndev->board = card[dev->nr];\r\nif (SAA7134_BOARD_UNKNOWN == dev->board)\r\nmust_configure_manually(0);\r\nelse if (SAA7134_BOARD_NOAUTO == dev->board) {\r\nmust_configure_manually(1);\r\ndev->board = SAA7134_BOARD_UNKNOWN;\r\n}\r\ndev->autodetected = card[dev->nr] != dev->board;\r\ndev->tuner_type = saa7134_boards[dev->board].tuner_type;\r\ndev->tuner_addr = saa7134_boards[dev->board].tuner_addr;\r\ndev->radio_type = saa7134_boards[dev->board].radio_type;\r\ndev->radio_addr = saa7134_boards[dev->board].radio_addr;\r\ndev->tda9887_conf = saa7134_boards[dev->board].tda9887_conf;\r\nif (UNSET != tuner[dev->nr])\r\ndev->tuner_type = tuner[dev->nr];\r\nprintk(KERN_INFO "%s: subsystem: %04x:%04x, board: %s [card=%d,%s]\n",\r\ndev->name,pci_dev->subsystem_vendor,\r\npci_dev->subsystem_device,saa7134_boards[dev->board].name,\r\ndev->board, dev->autodetected ?\r\n"autodetected" : "insmod option");\r\nif (!request_mem_region(pci_resource_start(pci_dev,0),\r\npci_resource_len(pci_dev,0),\r\ndev->name)) {\r\nerr = -EBUSY;\r\nprintk(KERN_ERR "%s: can't get MMIO memory @ 0x%llx\n",\r\ndev->name,(unsigned long long)pci_resource_start(pci_dev,0));\r\ngoto fail1;\r\n}\r\ndev->lmmio = ioremap(pci_resource_start(pci_dev, 0),\r\npci_resource_len(pci_dev, 0));\r\ndev->bmmio = (__u8 __iomem *)dev->lmmio;\r\nif (NULL == dev->lmmio) {\r\nerr = -EIO;\r\nprintk(KERN_ERR "%s: can't ioremap() MMIO memory\n",\r\ndev->name);\r\ngoto fail2;\r\n}\r\nsaa7134_board_init1(dev);\r\nsaa7134_hwinit1(dev);\r\nerr = request_irq(pci_dev->irq, saa7134_irq,\r\nIRQF_SHARED | IRQF_DISABLED, dev->name, dev);\r\nif (err < 0) {\r\nprintk(KERN_ERR "%s: can't get IRQ %d\n",\r\ndev->name,pci_dev->irq);\r\ngoto fail3;\r\n}\r\nmsleep(100);\r\nsaa7134_i2c_register(dev);\r\nsaa7134_board_init2(dev);\r\nsaa7134_hwinit2(dev);\r\nif (card_is_empress(dev)) {\r\nstruct v4l2_subdev *sd =\r\nv4l2_i2c_new_subdev(&dev->v4l2_dev, &dev->i2c_adap,\r\n"saa6752hs",\r\nsaa7134_boards[dev->board].empress_addr, NULL);\r\nif (sd)\r\nsd->grp_id = GRP_EMPRESS;\r\n}\r\nif (saa7134_boards[dev->board].rds_addr) {\r\nstruct v4l2_subdev *sd;\r\nsd = v4l2_i2c_new_subdev(&dev->v4l2_dev,\r\n&dev->i2c_adap, "saa6588",\r\n0, I2C_ADDRS(saa7134_boards[dev->board].rds_addr));\r\nif (sd) {\r\nprintk(KERN_INFO "%s: found RDS decoder\n", dev->name);\r\ndev->has_rds = 1;\r\n}\r\n}\r\nmutex_lock(&saa7134_devlist_lock);\r\nlist_for_each_entry(mops, &mops_list, next)\r\nmpeg_ops_attach(mops, dev);\r\nlist_add_tail(&dev->devlist, &saa7134_devlist);\r\nmutex_unlock(&saa7134_devlist_lock);\r\nsaa7134_irq_video_signalchange(dev);\r\nif (TUNER_ABSENT != dev->tuner_type)\r\nsaa_call_all(dev, core, s_power, 0);\r\nif (saa7134_no_overlay > 0)\r\nprintk(KERN_INFO "%s: Overlay support disabled.\n", dev->name);\r\ndev->video_dev = vdev_init(dev,&saa7134_video_template,"video");\r\nerr = video_register_device(dev->video_dev,VFL_TYPE_GRABBER,\r\nvideo_nr[dev->nr]);\r\nif (err < 0) {\r\nprintk(KERN_INFO "%s: can't register video device\n",\r\ndev->name);\r\ngoto fail4;\r\n}\r\nprintk(KERN_INFO "%s: registered device %s [v4l2]\n",\r\ndev->name, video_device_node_name(dev->video_dev));\r\ndev->vbi_dev = vdev_init(dev, &saa7134_video_template, "vbi");\r\nerr = video_register_device(dev->vbi_dev,VFL_TYPE_VBI,\r\nvbi_nr[dev->nr]);\r\nif (err < 0)\r\ngoto fail4;\r\nprintk(KERN_INFO "%s: registered device %s\n",\r\ndev->name, video_device_node_name(dev->vbi_dev));\r\nif (card_has_radio(dev)) {\r\ndev->radio_dev = vdev_init(dev,&saa7134_radio_template,"radio");\r\nerr = video_register_device(dev->radio_dev,VFL_TYPE_RADIO,\r\nradio_nr[dev->nr]);\r\nif (err < 0)\r\ngoto fail4;\r\nprintk(KERN_INFO "%s: registered device %s\n",\r\ndev->name, video_device_node_name(dev->radio_dev));\r\n}\r\nsaa7134_devcount++;\r\nif (saa7134_dmasound_init && !dev->dmasound.priv_data)\r\nsaa7134_dmasound_init(dev);\r\nrequest_submodules(dev);\r\nreturn 0;\r\nfail4:\r\nsaa7134_unregister_video(dev);\r\nsaa7134_i2c_unregister(dev);\r\nfree_irq(pci_dev->irq, dev);\r\nfail3:\r\nsaa7134_hwfini(dev);\r\niounmap(dev->lmmio);\r\nfail2:\r\nrelease_mem_region(pci_resource_start(pci_dev,0),\r\npci_resource_len(pci_dev,0));\r\nfail1:\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nfail0:\r\nkfree(dev);\r\nreturn err;\r\n}\r\nstatic void saa7134_finidev(struct pci_dev *pci_dev)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\r\nstruct saa7134_dev *dev = container_of(v4l2_dev, struct saa7134_dev, v4l2_dev);\r\nstruct saa7134_mpeg_ops *mops;\r\nflush_request_submodules(dev);\r\nif (saa7134_dmasound_exit && dev->dmasound.priv_data) {\r\nsaa7134_dmasound_exit(dev);\r\n}\r\nif (irq_debug) {\r\nu32 report = saa_readl(SAA7134_IRQ_REPORT);\r\nu32 status = saa_readl(SAA7134_IRQ_STATUS);\r\nprint_irqstatus(dev,42,report,status);\r\n}\r\nsaa_writeb(SAA7134_SPECIAL_MODE,0);\r\nsaa_writel(SAA7134_IRQ1,0);\r\nsaa_writel(SAA7134_IRQ2,0);\r\nsaa_writel(SAA7134_MAIN_CTRL,0);\r\nsaa7134_hwfini(dev);\r\nmutex_lock(&saa7134_devlist_lock);\r\nlist_del(&dev->devlist);\r\nlist_for_each_entry(mops, &mops_list, next)\r\nmpeg_ops_detach(mops, dev);\r\nmutex_unlock(&saa7134_devlist_lock);\r\nsaa7134_devcount--;\r\nsaa7134_i2c_unregister(dev);\r\nsaa7134_unregister_video(dev);\r\nif (dev->dmasound.priv_data != NULL) {\r\nfree_irq(pci_dev->irq, &dev->dmasound);\r\ndev->dmasound.priv_data = NULL;\r\n}\r\nfree_irq(pci_dev->irq, dev);\r\niounmap(dev->lmmio);\r\nrelease_mem_region(pci_resource_start(pci_dev,0),\r\npci_resource_len(pci_dev,0));\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nkfree(dev);\r\n}\r\nstatic int saa7134_buffer_requeue(struct saa7134_dev *dev,\r\nstruct saa7134_dmaqueue *q)\r\n{\r\nstruct saa7134_buf *buf, *next;\r\nassert_spin_locked(&dev->slock);\r\nbuf = q->curr;\r\nnext = buf;\r\ndprintk("buffer_requeue\n");\r\nif (!buf)\r\nreturn 0;\r\ndprintk("buffer_requeue : resending active buffers \n");\r\nif (!list_empty(&q->queue))\r\nnext = list_entry(q->queue.next, struct saa7134_buf,\r\nvb.queue);\r\nbuf->activate(dev, buf, next);\r\nreturn 0;\r\n}\r\nstatic int saa7134_suspend(struct pci_dev *pci_dev , pm_message_t state)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\r\nstruct saa7134_dev *dev = container_of(v4l2_dev, struct saa7134_dev, v4l2_dev);\r\ndev->ovenable = 0;\r\nsaa_writel(SAA7134_IRQ1, 0);\r\nsaa_writel(SAA7134_IRQ2, 0);\r\nsaa_writel(SAA7134_MAIN_CTRL, 0);\r\ndev->insuspend = 1;\r\nsynchronize_irq(pci_dev->irq);\r\nsaa_writel(SAA7134_IRQ_REPORT, saa_readl(SAA7134_IRQ_REPORT));\r\ndel_timer(&dev->video_q.timeout);\r\ndel_timer(&dev->vbi_q.timeout);\r\ndel_timer(&dev->ts_q.timeout);\r\nif (dev->remote)\r\nsaa7134_ir_stop(dev);\r\npci_save_state(pci_dev);\r\npci_set_power_state(pci_dev, pci_choose_state(pci_dev, state));\r\nreturn 0;\r\n}\r\nstatic int saa7134_resume(struct pci_dev *pci_dev)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\r\nstruct saa7134_dev *dev = container_of(v4l2_dev, struct saa7134_dev, v4l2_dev);\r\nunsigned long flags;\r\npci_set_power_state(pci_dev, PCI_D0);\r\npci_restore_state(pci_dev);\r\nsaa7134_board_init1(dev);\r\nif (saa7134_boards[dev->board].video_out)\r\nsaa7134_videoport_init(dev);\r\nif (card_has_mpeg(dev))\r\nsaa7134_ts_init_hw(dev);\r\nif (dev->remote)\r\nsaa7134_ir_start(dev);\r\nsaa7134_hw_enable1(dev);\r\nmsleep(100);\r\nsaa7134_board_init2(dev);\r\nsaa7134_set_tvnorm_hw(dev);\r\nsaa7134_tvaudio_setmute(dev);\r\nsaa7134_tvaudio_setvolume(dev, dev->ctl_volume);\r\nsaa7134_tvaudio_init(dev);\r\nsaa7134_enable_i2s(dev);\r\nsaa7134_hw_enable2(dev);\r\nsaa7134_irq_video_signalchange(dev);\r\nspin_lock_irqsave(&dev->slock, flags);\r\nsaa7134_buffer_requeue(dev, &dev->video_q);\r\nsaa7134_buffer_requeue(dev, &dev->vbi_q);\r\nsaa7134_buffer_requeue(dev, &dev->ts_q);\r\ndev->dmasound.dma_running = 0;\r\ndev->insuspend = 0;\r\nsmp_wmb();\r\nsaa7134_set_dmabits(dev);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nreturn 0;\r\n}\r\nint saa7134_ts_register(struct saa7134_mpeg_ops *ops)\r\n{\r\nstruct saa7134_dev *dev;\r\nmutex_lock(&saa7134_devlist_lock);\r\nlist_for_each_entry(dev, &saa7134_devlist, devlist)\r\nmpeg_ops_attach(ops, dev);\r\nlist_add_tail(&ops->next,&mops_list);\r\nmutex_unlock(&saa7134_devlist_lock);\r\nreturn 0;\r\n}\r\nvoid saa7134_ts_unregister(struct saa7134_mpeg_ops *ops)\r\n{\r\nstruct saa7134_dev *dev;\r\nmutex_lock(&saa7134_devlist_lock);\r\nlist_del(&ops->next);\r\nlist_for_each_entry(dev, &saa7134_devlist, devlist)\r\nmpeg_ops_detach(ops, dev);\r\nmutex_unlock(&saa7134_devlist_lock);\r\n}\r\nstatic int __init saa7134_init(void)\r\n{\r\nINIT_LIST_HEAD(&saa7134_devlist);\r\nprintk(KERN_INFO "saa7130/34: v4l2 driver version %s loaded\n",\r\nSAA7134_VERSION);\r\nreturn pci_register_driver(&saa7134_pci_driver);\r\n}\r\nstatic void __exit saa7134_fini(void)\r\n{\r\npci_unregister_driver(&saa7134_pci_driver);\r\n}
