static void __init reset_tod_clock(void)\r\n{\r\nu64 time;\r\nif (store_tod_clock(&time) == 0)\r\nreturn;\r\nif (set_tod_clock(TOD_UNIX_EPOCH) != 0 || store_tod_clock(&time) != 0)\r\ndisabled_wait(0);\r\nsched_clock_base_cc = TOD_UNIX_EPOCH;\r\nS390_lowcore.last_update_clock = sched_clock_base_cc;\r\n}\r\nstatic noinline __init void create_kernel_nss(void)\r\n{\r\nunsigned int i, stext_pfn, eshared_pfn, end_pfn, min_size;\r\n#ifdef CONFIG_BLK_DEV_INITRD\r\nunsigned int sinitrd_pfn, einitrd_pfn;\r\n#endif\r\nint response;\r\nint hlen;\r\nsize_t len;\r\nchar *savesys_ptr;\r\nchar defsys_cmd[DEFSYS_CMD_SIZE];\r\nchar savesys_cmd[SAVESYS_CMD_SIZE];\r\nif (!MACHINE_IS_VM)\r\nreturn;\r\nfor (i = 0; i < strlen(boot_command_line); i++)\r\nupper_command_line[i] = toupper(boot_command_line[i]);\r\nsavesys_ptr = strstr(upper_command_line, "SAVESYS=");\r\nif (!savesys_ptr)\r\nreturn;\r\nsavesys_ptr += 8;\r\nfor (i = 0; i < NSS_NAME_SIZE; i++) {\r\nif (savesys_ptr[i] == ' ' || savesys_ptr[i] == '\0')\r\nbreak;\r\nkernel_nss_name[i] = savesys_ptr[i];\r\n}\r\nstext_pfn = PFN_DOWN(__pa(&_stext));\r\neshared_pfn = PFN_DOWN(__pa(&_eshared));\r\nend_pfn = PFN_UP(__pa(&_end));\r\nmin_size = end_pfn << 2;\r\nhlen = snprintf(defsys_cmd, DEFSYS_CMD_SIZE,\r\n"DEFSYS %s 00000-%.5X EW %.5X-%.5X SR %.5X-%.5X",\r\nkernel_nss_name, stext_pfn - 1, stext_pfn,\r\neshared_pfn - 1, eshared_pfn, end_pfn);\r\n#ifdef CONFIG_BLK_DEV_INITRD\r\nif (INITRD_START && INITRD_SIZE) {\r\nsinitrd_pfn = PFN_DOWN(__pa(INITRD_START));\r\neinitrd_pfn = PFN_UP(__pa(INITRD_START + INITRD_SIZE));\r\nmin_size = einitrd_pfn << 2;\r\nhlen += snprintf(defsys_cmd + hlen, DEFSYS_CMD_SIZE - hlen,\r\n" EW %.5X-%.5X", sinitrd_pfn, einitrd_pfn);\r\n}\r\n#endif\r\nsnprintf(defsys_cmd + hlen, DEFSYS_CMD_SIZE - hlen,\r\n" EW MINSIZE=%.7iK PARMREGS=0-13", min_size);\r\ndefsys_cmd[DEFSYS_CMD_SIZE - 1] = '\0';\r\nsnprintf(savesys_cmd, SAVESYS_CMD_SIZE, "SAVESYS %s \n IPL %s",\r\nkernel_nss_name, kernel_nss_name);\r\nsavesys_cmd[SAVESYS_CMD_SIZE - 1] = '\0';\r\n__cpcmd(defsys_cmd, NULL, 0, &response);\r\nif (response != 0) {\r\npr_err("Defining the Linux kernel NSS failed with rc=%d\n",\r\nresponse);\r\nkernel_nss_name[0] = '\0';\r\nreturn;\r\n}\r\nlen = strlen(savesys_cmd);\r\nASCEBC(savesys_cmd, len);\r\nresponse = savesys_ipl_nss(savesys_cmd, len);\r\nif (response > SAVESYS_CMD_SIZE || response == 1) {\r\npr_err("Saving the Linux kernel NSS failed with rc=%d\n",\r\nresponse);\r\nkernel_nss_name[0] = '\0';\r\nreturn;\r\n}\r\nsched_clock_base_cc = get_tod_clock();\r\nS390_lowcore.last_update_clock = sched_clock_base_cc;\r\nS390_lowcore.last_update_timer = 0x7fffffffffffffffULL;\r\nS390_lowcore.user_timer = 0;\r\nS390_lowcore.system_timer = 0;\r\nasm volatile("SPT 0(%0)" : : "a" (&S390_lowcore.last_update_timer));\r\nipl_update_parameters();\r\nsetup_boot_command_line();\r\nipl_flags = IPL_NSS_VALID;\r\n}\r\nstatic inline void create_kernel_nss(void) { }\r\nstatic noinline __init void clear_bss_section(void)\r\n{\r\nmemset(__bss_start, 0, __bss_stop - __bss_start);\r\n}\r\nstatic noinline __init void init_kernel_storage_key(void)\r\n{\r\nunsigned long end_pfn, init_pfn;\r\nend_pfn = PFN_UP(__pa(&_end));\r\nfor (init_pfn = 0 ; init_pfn < end_pfn; init_pfn++)\r\npage_set_storage_key(init_pfn << PAGE_SHIFT,\r\nPAGE_DEFAULT_KEY, 0);\r\n}\r\nstatic noinline __init void detect_machine_type(void)\r\n{\r\nstruct sysinfo_3_2_2 *vmms = (struct sysinfo_3_2_2 *)&sysinfo_page;\r\nif (stsi(NULL, 0, 0, 0) <= 2) {\r\nS390_lowcore.machine_flags |= MACHINE_FLAG_LPAR;\r\nreturn;\r\n}\r\nif (stsi(vmms, 3, 2, 2) || !vmms->count)\r\nreturn;\r\nif (!memcmp(vmms->vm[0].cpi, "\xd2\xe5\xd4", 3))\r\nS390_lowcore.machine_flags |= MACHINE_FLAG_KVM;\r\nelse\r\nS390_lowcore.machine_flags |= MACHINE_FLAG_VM;\r\n}\r\nstatic __init void setup_topology(void)\r\n{\r\n#ifdef CONFIG_64BIT\r\nint max_mnest;\r\nif (!test_facility(11))\r\nreturn;\r\nS390_lowcore.machine_flags |= MACHINE_FLAG_TOPOLOGY;\r\nfor (max_mnest = 6; max_mnest > 1; max_mnest--) {\r\nif (stsi(&sysinfo_page, 15, 1, max_mnest) == 0)\r\nbreak;\r\n}\r\ntopology_max_mnest = max_mnest;\r\n#endif\r\n}\r\nstatic void early_pgm_check_handler(void)\r\n{\r\nconst struct exception_table_entry *fixup;\r\nunsigned long addr;\r\naddr = S390_lowcore.program_old_psw.addr;\r\nfixup = search_exception_tables(addr & PSW_ADDR_INSN);\r\nif (!fixup)\r\ndisabled_wait(0);\r\nS390_lowcore.program_old_psw.addr = extable_fixup(fixup)|PSW_ADDR_AMODE;\r\n}\r\nstatic noinline __init void setup_lowcore_early(void)\r\n{\r\npsw_t psw;\r\npsw.mask = PSW_MASK_BASE | PSW_DEFAULT_KEY | PSW_MASK_EA | PSW_MASK_BA;\r\npsw.addr = PSW_ADDR_AMODE | (unsigned long) s390_base_ext_handler;\r\nS390_lowcore.external_new_psw = psw;\r\npsw.addr = PSW_ADDR_AMODE | (unsigned long) s390_base_pgm_handler;\r\nS390_lowcore.program_new_psw = psw;\r\ns390_base_pgm_handler_fn = early_pgm_check_handler;\r\n}\r\nstatic noinline __init void setup_facility_list(void)\r\n{\r\nstfle(S390_lowcore.stfle_fac_list,\r\nARRAY_SIZE(S390_lowcore.stfle_fac_list));\r\n}\r\nstatic __init void detect_mvpg(void)\r\n{\r\n#ifndef CONFIG_64BIT\r\nint rc;\r\nasm volatile(\r\n" la 0,0\n"\r\n" mvpg %2,%2\n"\r\n"0: la %0,0\n"\r\n"1:\n"\r\nEX_TABLE(0b,1b)\r\n: "=d" (rc) : "0" (-EOPNOTSUPP), "a" (0) : "memory", "cc", "0");\r\nif (!rc)\r\nS390_lowcore.machine_flags |= MACHINE_FLAG_MVPG;\r\n#endif\r\n}\r\nstatic __init void detect_ieee(void)\r\n{\r\n#ifndef CONFIG_64BIT\r\nint rc, tmp;\r\nasm volatile(\r\n" efpc %1,0\n"\r\n"0: la %0,0\n"\r\n"1:\n"\r\nEX_TABLE(0b,1b)\r\n: "=d" (rc), "=d" (tmp): "0" (-EOPNOTSUPP) : "cc");\r\nif (!rc)\r\nS390_lowcore.machine_flags |= MACHINE_FLAG_IEEE;\r\n#endif\r\n}\r\nstatic __init void detect_csp(void)\r\n{\r\n#ifndef CONFIG_64BIT\r\nint rc;\r\nasm volatile(\r\n" la 0,0\n"\r\n" la 1,0\n"\r\n" la 2,4\n"\r\n" csp 0,2\n"\r\n"0: la %0,0\n"\r\n"1:\n"\r\nEX_TABLE(0b,1b)\r\n: "=d" (rc) : "0" (-EOPNOTSUPP) : "cc", "0", "1", "2");\r\nif (!rc)\r\nS390_lowcore.machine_flags |= MACHINE_FLAG_CSP;\r\n#endif\r\n}\r\nstatic __init void detect_diag9c(void)\r\n{\r\nunsigned int cpu_address;\r\nint rc;\r\ncpu_address = stap();\r\nasm volatile(\r\n" diag %2,0,0x9c\n"\r\n"0: la %0,0\n"\r\n"1:\n"\r\nEX_TABLE(0b,1b)\r\n: "=d" (rc) : "0" (-EOPNOTSUPP), "d" (cpu_address) : "cc");\r\nif (!rc)\r\nS390_lowcore.machine_flags |= MACHINE_FLAG_DIAG9C;\r\n}\r\nstatic __init void detect_diag44(void)\r\n{\r\n#ifdef CONFIG_64BIT\r\nint rc;\r\nasm volatile(\r\n" diag 0,0,0x44\n"\r\n"0: la %0,0\n"\r\n"1:\n"\r\nEX_TABLE(0b,1b)\r\n: "=d" (rc) : "0" (-EOPNOTSUPP) : "cc");\r\nif (!rc)\r\nS390_lowcore.machine_flags |= MACHINE_FLAG_DIAG44;\r\n#endif\r\n}\r\nstatic __init void detect_machine_facilities(void)\r\n{\r\n#ifdef CONFIG_64BIT\r\nif (test_facility(8)) {\r\nS390_lowcore.machine_flags |= MACHINE_FLAG_EDAT1;\r\n__ctl_set_bit(0, 23);\r\n}\r\nif (test_facility(78))\r\nS390_lowcore.machine_flags |= MACHINE_FLAG_EDAT2;\r\nif (test_facility(3))\r\nS390_lowcore.machine_flags |= MACHINE_FLAG_IDTE;\r\nif (test_facility(27))\r\nS390_lowcore.machine_flags |= MACHINE_FLAG_MVCOS;\r\nif (test_facility(40))\r\nS390_lowcore.machine_flags |= MACHINE_FLAG_LPP;\r\nif (test_facility(50) && test_facility(73))\r\nS390_lowcore.machine_flags |= MACHINE_FLAG_TE;\r\nif (test_facility(66))\r\nS390_lowcore.machine_flags |= MACHINE_FLAG_RRBM;\r\n#endif\r\n}\r\nstatic __init void rescue_initrd(void)\r\n{\r\n#ifdef CONFIG_BLK_DEV_INITRD\r\nunsigned long min_initrd_addr = (unsigned long) _end + (4UL << 20);\r\nif (!INITRD_START || !INITRD_SIZE)\r\nreturn;\r\nif (INITRD_START >= min_initrd_addr)\r\nreturn;\r\nmemmove((void *) min_initrd_addr, (void *) INITRD_START, INITRD_SIZE);\r\nINITRD_START = min_initrd_addr;\r\n#endif\r\n}\r\nstatic void __init append_to_cmdline(size_t (*ipl_data)(char *, size_t))\r\n{\r\nchar *parm, *delim;\r\nsize_t rc, len;\r\nlen = strlen(boot_command_line);\r\ndelim = boot_command_line + len;\r\nparm = boot_command_line + len + 1;\r\nrc = ipl_data(parm, COMMAND_LINE_SIZE - len - 1);\r\nif (rc) {\r\nif (*parm == '=')\r\nmemmove(boot_command_line, parm + 1, rc);\r\nelse\r\n*delim = ' ';\r\n}\r\n}\r\nstatic inline int has_ebcdic_char(const char *str)\r\n{\r\nint i;\r\nfor (i = 0; str[i]; i++)\r\nif (str[i] & 0x80)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void __init setup_boot_command_line(void)\r\n{\r\nCOMMAND_LINE[ARCH_COMMAND_LINE_SIZE - 1] = 0;\r\nif (has_ebcdic_char(COMMAND_LINE))\r\nEBCASC(COMMAND_LINE, ARCH_COMMAND_LINE_SIZE);\r\nstrlcpy(boot_command_line, strstrip(COMMAND_LINE),\r\nARCH_COMMAND_LINE_SIZE);\r\nif (MACHINE_IS_VM)\r\nappend_to_cmdline(append_ipl_vmparm);\r\nappend_to_cmdline(append_ipl_scpdata);\r\n}\r\nvoid __init startup_init(void)\r\n{\r\nreset_tod_clock();\r\nipl_save_parameters();\r\nrescue_initrd();\r\nclear_bss_section();\r\ninit_kernel_storage_key();\r\nlockdep_init();\r\nlockdep_off();\r\nsetup_lowcore_early();\r\nsetup_facility_list();\r\ndetect_machine_type();\r\nipl_update_parameters();\r\nsetup_boot_command_line();\r\ncreate_kernel_nss();\r\ndetect_mvpg();\r\ndetect_ieee();\r\ndetect_csp();\r\ndetect_diag9c();\r\ndetect_diag44();\r\ndetect_machine_facilities();\r\nsetup_topology();\r\nsclp_facilities_detect();\r\n#ifdef CONFIG_DYNAMIC_FTRACE\r\nS390_lowcore.ftrace_func = (unsigned long)ftrace_caller;\r\n#endif\r\nlockdep_on();\r\n}
