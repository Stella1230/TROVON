bool r600_fmt_is_valid_color(u32 format)\r\n{\r\nif (format >= ARRAY_SIZE(color_formats_table))\r\nreturn false;\r\nif (color_formats_table[format].valid_color)\r\nreturn true;\r\nreturn false;\r\n}\r\nbool r600_fmt_is_valid_texture(u32 format, enum radeon_family family)\r\n{\r\nif (format >= ARRAY_SIZE(color_formats_table))\r\nreturn false;\r\nif (family < color_formats_table[format].min_family)\r\nreturn false;\r\nif (color_formats_table[format].blockwidth > 0)\r\nreturn true;\r\nreturn false;\r\n}\r\nint r600_fmt_get_blocksize(u32 format)\r\n{\r\nif (format >= ARRAY_SIZE(color_formats_table))\r\nreturn 0;\r\nreturn color_formats_table[format].blocksize;\r\n}\r\nint r600_fmt_get_nblocksx(u32 format, u32 w)\r\n{\r\nunsigned bw;\r\nif (format >= ARRAY_SIZE(color_formats_table))\r\nreturn 0;\r\nbw = color_formats_table[format].blockwidth;\r\nif (bw == 0)\r\nreturn 0;\r\nreturn (w + bw - 1) / bw;\r\n}\r\nint r600_fmt_get_nblocksy(u32 format, u32 h)\r\n{\r\nunsigned bh;\r\nif (format >= ARRAY_SIZE(color_formats_table))\r\nreturn 0;\r\nbh = color_formats_table[format].blockheight;\r\nif (bh == 0)\r\nreturn 0;\r\nreturn (h + bh - 1) / bh;\r\n}\r\nstatic int r600_get_array_mode_alignment(struct array_mode_checker *values,\r\nu32 *pitch_align,\r\nu32 *height_align,\r\nu32 *depth_align,\r\nu64 *base_align)\r\n{\r\nu32 tile_width = 8;\r\nu32 tile_height = 8;\r\nu32 macro_tile_width = values->nbanks;\r\nu32 macro_tile_height = values->npipes;\r\nu32 tile_bytes = tile_width * tile_height * values->blocksize * values->nsamples;\r\nu32 macro_tile_bytes = macro_tile_width * macro_tile_height * tile_bytes;\r\nswitch (values->array_mode) {\r\ncase ARRAY_LINEAR_GENERAL:\r\n*pitch_align = 1;\r\n*height_align = 1;\r\n*depth_align = 1;\r\n*base_align = 1;\r\nbreak;\r\ncase ARRAY_LINEAR_ALIGNED:\r\n*pitch_align = max((u32)64, (u32)(values->group_size / values->blocksize));\r\n*height_align = 1;\r\n*depth_align = 1;\r\n*base_align = values->group_size;\r\nbreak;\r\ncase ARRAY_1D_TILED_THIN1:\r\n*pitch_align = max((u32)tile_width,\r\n(u32)(values->group_size /\r\n(tile_height * values->blocksize * values->nsamples)));\r\n*height_align = tile_height;\r\n*depth_align = 1;\r\n*base_align = values->group_size;\r\nbreak;\r\ncase ARRAY_2D_TILED_THIN1:\r\n*pitch_align = max((u32)macro_tile_width * tile_width,\r\n(u32)((values->group_size * values->nbanks) /\r\n(values->blocksize * values->nsamples * tile_width)));\r\n*height_align = macro_tile_height * tile_height;\r\n*depth_align = 1;\r\n*base_align = max(macro_tile_bytes,\r\n(*pitch_align) * values->blocksize * (*height_align) * values->nsamples);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void r600_cs_track_init(struct r600_cs_track *track)\r\n{\r\nint i;\r\ntrack->sq_config = DX9_CONSTS;\r\nfor (i = 0; i < 8; i++) {\r\ntrack->cb_color_base_last[i] = 0;\r\ntrack->cb_color_size[i] = 0;\r\ntrack->cb_color_size_idx[i] = 0;\r\ntrack->cb_color_info[i] = 0;\r\ntrack->cb_color_view[i] = 0xFFFFFFFF;\r\ntrack->cb_color_bo[i] = NULL;\r\ntrack->cb_color_bo_offset[i] = 0xFFFFFFFF;\r\ntrack->cb_color_bo_mc[i] = 0xFFFFFFFF;\r\ntrack->cb_color_frag_bo[i] = NULL;\r\ntrack->cb_color_frag_offset[i] = 0xFFFFFFFF;\r\ntrack->cb_color_tile_bo[i] = NULL;\r\ntrack->cb_color_tile_offset[i] = 0xFFFFFFFF;\r\ntrack->cb_color_mask[i] = 0xFFFFFFFF;\r\n}\r\ntrack->is_resolve = false;\r\ntrack->nsamples = 16;\r\ntrack->log_nsamples = 4;\r\ntrack->cb_target_mask = 0xFFFFFFFF;\r\ntrack->cb_shader_mask = 0xFFFFFFFF;\r\ntrack->cb_dirty = true;\r\ntrack->db_bo = NULL;\r\ntrack->db_bo_mc = 0xFFFFFFFF;\r\ntrack->db_depth_info = 7 | (1 << 25);\r\ntrack->db_depth_view = 0xFFFFC000;\r\ntrack->db_depth_size = 0xFFFFFFFF;\r\ntrack->db_depth_size_idx = 0;\r\ntrack->db_depth_control = 0xFFFFFFFF;\r\ntrack->db_dirty = true;\r\ntrack->htile_bo = NULL;\r\ntrack->htile_offset = 0xFFFFFFFF;\r\ntrack->htile_surface = 0;\r\nfor (i = 0; i < 4; i++) {\r\ntrack->vgt_strmout_size[i] = 0;\r\ntrack->vgt_strmout_bo[i] = NULL;\r\ntrack->vgt_strmout_bo_offset[i] = 0xFFFFFFFF;\r\ntrack->vgt_strmout_bo_mc[i] = 0xFFFFFFFF;\r\n}\r\ntrack->streamout_dirty = true;\r\ntrack->sx_misc_kill_all_prims = false;\r\n}\r\nstatic int r600_cs_track_validate_cb(struct radeon_cs_parser *p, int i)\r\n{\r\nstruct r600_cs_track *track = p->track;\r\nu32 slice_tile_max, size, tmp;\r\nu32 height, height_align, pitch, pitch_align, depth_align;\r\nu64 base_offset, base_align;\r\nstruct array_mode_checker array_check;\r\nvolatile u32 *ib = p->ib.ptr;\r\nunsigned array_mode;\r\nu32 format;\r\nunsigned nsamples = track->is_resolve && i == 1 ? 1 : track->nsamples;\r\nsize = radeon_bo_size(track->cb_color_bo[i]) - track->cb_color_bo_offset[i];\r\nformat = G_0280A0_FORMAT(track->cb_color_info[i]);\r\nif (!r600_fmt_is_valid_color(format)) {\r\ndev_warn(p->dev, "%s:%d cb invalid format %d for %d (0x%08X)\n",\r\n__func__, __LINE__, format,\r\ni, track->cb_color_info[i]);\r\nreturn -EINVAL;\r\n}\r\npitch = (G_028060_PITCH_TILE_MAX(track->cb_color_size[i]) + 1) * 8;\r\nslice_tile_max = G_028060_SLICE_TILE_MAX(track->cb_color_size[i]) + 1;\r\nslice_tile_max *= 64;\r\nheight = slice_tile_max / pitch;\r\nif (height > 8192)\r\nheight = 8192;\r\narray_mode = G_0280A0_ARRAY_MODE(track->cb_color_info[i]);\r\nbase_offset = track->cb_color_bo_mc[i] + track->cb_color_bo_offset[i];\r\narray_check.array_mode = array_mode;\r\narray_check.group_size = track->group_size;\r\narray_check.nbanks = track->nbanks;\r\narray_check.npipes = track->npipes;\r\narray_check.nsamples = nsamples;\r\narray_check.blocksize = r600_fmt_get_blocksize(format);\r\nif (r600_get_array_mode_alignment(&array_check,\r\n&pitch_align, &height_align, &depth_align, &base_align)) {\r\ndev_warn(p->dev, "%s invalid tiling %d for %d (0x%08X)\n", __func__,\r\nG_0280A0_ARRAY_MODE(track->cb_color_info[i]), i,\r\ntrack->cb_color_info[i]);\r\nreturn -EINVAL;\r\n}\r\nswitch (array_mode) {\r\ncase V_0280A0_ARRAY_LINEAR_GENERAL:\r\nbreak;\r\ncase V_0280A0_ARRAY_LINEAR_ALIGNED:\r\nbreak;\r\ncase V_0280A0_ARRAY_1D_TILED_THIN1:\r\nif (height > 7)\r\nheight &= ~0x7;\r\nbreak;\r\ncase V_0280A0_ARRAY_2D_TILED_THIN1:\r\nbreak;\r\ndefault:\r\ndev_warn(p->dev, "%s invalid tiling %d for %d (0x%08X)\n", __func__,\r\nG_0280A0_ARRAY_MODE(track->cb_color_info[i]), i,\r\ntrack->cb_color_info[i]);\r\nreturn -EINVAL;\r\n}\r\nif (!IS_ALIGNED(pitch, pitch_align)) {\r\ndev_warn(p->dev, "%s:%d cb pitch (%d, 0x%x, %d) invalid\n",\r\n__func__, __LINE__, pitch, pitch_align, array_mode);\r\nreturn -EINVAL;\r\n}\r\nif (!IS_ALIGNED(height, height_align)) {\r\ndev_warn(p->dev, "%s:%d cb height (%d, 0x%x, %d) invalid\n",\r\n__func__, __LINE__, height, height_align, array_mode);\r\nreturn -EINVAL;\r\n}\r\nif (!IS_ALIGNED(base_offset, base_align)) {\r\ndev_warn(p->dev, "%s offset[%d] 0x%llx 0x%llx, %d not aligned\n", __func__, i,\r\nbase_offset, base_align, array_mode);\r\nreturn -EINVAL;\r\n}\r\ntmp = r600_fmt_get_nblocksy(format, height) * r600_fmt_get_nblocksx(format, pitch) *\r\nr600_fmt_get_blocksize(format) * nsamples;\r\nswitch (array_mode) {\r\ndefault:\r\ncase V_0280A0_ARRAY_LINEAR_GENERAL:\r\ncase V_0280A0_ARRAY_LINEAR_ALIGNED:\r\ntmp += track->cb_color_view[i] & 0xFF;\r\nbreak;\r\ncase V_0280A0_ARRAY_1D_TILED_THIN1:\r\ncase V_0280A0_ARRAY_2D_TILED_THIN1:\r\ntmp += G_028080_SLICE_MAX(track->cb_color_view[i]) * tmp;\r\nbreak;\r\n}\r\nif ((tmp + track->cb_color_bo_offset[i]) > radeon_bo_size(track->cb_color_bo[i])) {\r\nif (array_mode == V_0280A0_ARRAY_LINEAR_GENERAL) {\r\n} else {\r\ndev_warn(p->dev, "%s offset[%d] %d %llu %d %lu too big (%d %d) (%d %d %d)\n",\r\n__func__, i, array_mode,\r\ntrack->cb_color_bo_offset[i], tmp,\r\nradeon_bo_size(track->cb_color_bo[i]),\r\npitch, height, r600_fmt_get_nblocksx(format, pitch),\r\nr600_fmt_get_nblocksy(format, height),\r\nr600_fmt_get_blocksize(format));\r\nreturn -EINVAL;\r\n}\r\n}\r\ntmp = (height * pitch) >> 6;\r\nif (tmp < slice_tile_max)\r\nslice_tile_max = tmp;\r\ntmp = S_028060_PITCH_TILE_MAX((pitch / 8) - 1) |\r\nS_028060_SLICE_TILE_MAX(slice_tile_max - 1);\r\nib[track->cb_color_size_idx[i]] = tmp;\r\nswitch (G_0280A0_TILE_MODE(track->cb_color_info[i])) {\r\ncase V_0280A0_TILE_DISABLE:\r\nbreak;\r\ncase V_0280A0_FRAG_ENABLE:\r\nif (track->nsamples > 1) {\r\nuint32_t tile_max = G_028100_FMASK_TILE_MAX(track->cb_color_mask[i]);\r\nuint32_t bytes = track->nsamples * track->log_nsamples * 8 * (tile_max + 1);\r\nif (bytes + track->cb_color_frag_offset[i] >\r\nradeon_bo_size(track->cb_color_frag_bo[i])) {\r\ndev_warn(p->dev, "%s FMASK_TILE_MAX too large "\r\n"(tile_max=%u, bytes=%u, offset=%llu, bo_size=%lu)\n",\r\n__func__, tile_max, bytes,\r\ntrack->cb_color_frag_offset[i],\r\nradeon_bo_size(track->cb_color_frag_bo[i]));\r\nreturn -EINVAL;\r\n}\r\n}\r\ncase V_0280A0_CLEAR_ENABLE:\r\n{\r\nuint32_t block_max = G_028100_CMASK_BLOCK_MAX(track->cb_color_mask[i]);\r\nuint32_t bytes = (block_max + 1) * 128;\r\nif (bytes + track->cb_color_tile_offset[i] >\r\nradeon_bo_size(track->cb_color_tile_bo[i])) {\r\ndev_warn(p->dev, "%s CMASK_BLOCK_MAX too large "\r\n"(block_max=%u, bytes=%u, offset=%llu, bo_size=%lu)\n",\r\n__func__, block_max, bytes,\r\ntrack->cb_color_tile_offset[i],\r\nradeon_bo_size(track->cb_color_tile_bo[i]));\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\ndev_warn(p->dev, "%s invalid tile mode\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int r600_cs_track_validate_db(struct radeon_cs_parser *p)\r\n{\r\nstruct r600_cs_track *track = p->track;\r\nu32 nviews, bpe, ntiles, size, slice_tile_max, tmp;\r\nu32 height_align, pitch_align, depth_align;\r\nu32 pitch = 8192;\r\nu32 height = 8192;\r\nu64 base_offset, base_align;\r\nstruct array_mode_checker array_check;\r\nint array_mode;\r\nvolatile u32 *ib = p->ib.ptr;\r\nif (track->db_bo == NULL) {\r\ndev_warn(p->dev, "z/stencil with no depth buffer\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (G_028010_FORMAT(track->db_depth_info)) {\r\ncase V_028010_DEPTH_16:\r\nbpe = 2;\r\nbreak;\r\ncase V_028010_DEPTH_X8_24:\r\ncase V_028010_DEPTH_8_24:\r\ncase V_028010_DEPTH_X8_24_FLOAT:\r\ncase V_028010_DEPTH_8_24_FLOAT:\r\ncase V_028010_DEPTH_32_FLOAT:\r\nbpe = 4;\r\nbreak;\r\ncase V_028010_DEPTH_X24_8_32_FLOAT:\r\nbpe = 8;\r\nbreak;\r\ndefault:\r\ndev_warn(p->dev, "z/stencil with invalid format %d\n", G_028010_FORMAT(track->db_depth_info));\r\nreturn -EINVAL;\r\n}\r\nif ((track->db_depth_size & 0xFFFFFC00) == 0xFFFFFC00) {\r\nif (!track->db_depth_size_idx) {\r\ndev_warn(p->dev, "z/stencil buffer size not set\n");\r\nreturn -EINVAL;\r\n}\r\ntmp = radeon_bo_size(track->db_bo) - track->db_offset;\r\ntmp = (tmp / bpe) >> 6;\r\nif (!tmp) {\r\ndev_warn(p->dev, "z/stencil buffer too small (0x%08X %d %d %ld)\n",\r\ntrack->db_depth_size, bpe, track->db_offset,\r\nradeon_bo_size(track->db_bo));\r\nreturn -EINVAL;\r\n}\r\nib[track->db_depth_size_idx] = S_028000_SLICE_TILE_MAX(tmp - 1) | (track->db_depth_size & 0x3FF);\r\n} else {\r\nsize = radeon_bo_size(track->db_bo);\r\npitch = (G_028000_PITCH_TILE_MAX(track->db_depth_size) + 1) * 8;\r\nslice_tile_max = G_028000_SLICE_TILE_MAX(track->db_depth_size) + 1;\r\nslice_tile_max *= 64;\r\nheight = slice_tile_max / pitch;\r\nif (height > 8192)\r\nheight = 8192;\r\nbase_offset = track->db_bo_mc + track->db_offset;\r\narray_mode = G_028010_ARRAY_MODE(track->db_depth_info);\r\narray_check.array_mode = array_mode;\r\narray_check.group_size = track->group_size;\r\narray_check.nbanks = track->nbanks;\r\narray_check.npipes = track->npipes;\r\narray_check.nsamples = track->nsamples;\r\narray_check.blocksize = bpe;\r\nif (r600_get_array_mode_alignment(&array_check,\r\n&pitch_align, &height_align, &depth_align, &base_align)) {\r\ndev_warn(p->dev, "%s invalid tiling %d (0x%08X)\n", __func__,\r\nG_028010_ARRAY_MODE(track->db_depth_info),\r\ntrack->db_depth_info);\r\nreturn -EINVAL;\r\n}\r\nswitch (array_mode) {\r\ncase V_028010_ARRAY_1D_TILED_THIN1:\r\nheight &= ~0x7;\r\nbreak;\r\ncase V_028010_ARRAY_2D_TILED_THIN1:\r\nbreak;\r\ndefault:\r\ndev_warn(p->dev, "%s invalid tiling %d (0x%08X)\n", __func__,\r\nG_028010_ARRAY_MODE(track->db_depth_info),\r\ntrack->db_depth_info);\r\nreturn -EINVAL;\r\n}\r\nif (!IS_ALIGNED(pitch, pitch_align)) {\r\ndev_warn(p->dev, "%s:%d db pitch (%d, 0x%x, %d) invalid\n",\r\n__func__, __LINE__, pitch, pitch_align, array_mode);\r\nreturn -EINVAL;\r\n}\r\nif (!IS_ALIGNED(height, height_align)) {\r\ndev_warn(p->dev, "%s:%d db height (%d, 0x%x, %d) invalid\n",\r\n__func__, __LINE__, height, height_align, array_mode);\r\nreturn -EINVAL;\r\n}\r\nif (!IS_ALIGNED(base_offset, base_align)) {\r\ndev_warn(p->dev, "%s offset 0x%llx, 0x%llx, %d not aligned\n", __func__,\r\nbase_offset, base_align, array_mode);\r\nreturn -EINVAL;\r\n}\r\nntiles = G_028000_SLICE_TILE_MAX(track->db_depth_size) + 1;\r\nnviews = G_028004_SLICE_MAX(track->db_depth_view) + 1;\r\ntmp = ntiles * bpe * 64 * nviews * track->nsamples;\r\nif ((tmp + track->db_offset) > radeon_bo_size(track->db_bo)) {\r\ndev_warn(p->dev, "z/stencil buffer (%d) too small (0x%08X %d %d %d -> %u have %lu)\n",\r\narray_mode,\r\ntrack->db_depth_size, ntiles, nviews, bpe, tmp + track->db_offset,\r\nradeon_bo_size(track->db_bo));\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (G_028010_TILE_SURFACE_ENABLE(track->db_depth_info)) {\r\nunsigned long size;\r\nunsigned nbx, nby;\r\nif (track->htile_bo == NULL) {\r\ndev_warn(p->dev, "%s:%d htile enabled without htile surface 0x%08x\n",\r\n__func__, __LINE__, track->db_depth_info);\r\nreturn -EINVAL;\r\n}\r\nif ((track->db_depth_size & 0xFFFFFC00) == 0xFFFFFC00) {\r\ndev_warn(p->dev, "%s:%d htile can't be enabled with bogus db_depth_size 0x%08x\n",\r\n__func__, __LINE__, track->db_depth_size);\r\nreturn -EINVAL;\r\n}\r\nnbx = pitch;\r\nnby = height;\r\nif (G_028D24_LINEAR(track->htile_surface)) {\r\nnbx = round_up(nbx, 16 * 8);\r\nnby = round_up(nby, track->npipes * 8);\r\n} else {\r\nswitch (track->npipes) {\r\ncase 8:\r\nnbx = round_up(nbx, 64 * 8);\r\nnby = round_up(nby, 64 * 8);\r\nbreak;\r\ncase 4:\r\nnbx = round_up(nbx, 64 * 8);\r\nnby = round_up(nby, 32 * 8);\r\nbreak;\r\ncase 2:\r\nnbx = round_up(nbx, 32 * 8);\r\nnby = round_up(nby, 32 * 8);\r\nbreak;\r\ncase 1:\r\nnbx = round_up(nbx, 32 * 8);\r\nnby = round_up(nby, 16 * 8);\r\nbreak;\r\ndefault:\r\ndev_warn(p->dev, "%s:%d invalid num pipes %d\n",\r\n__func__, __LINE__, track->npipes);\r\nreturn -EINVAL;\r\n}\r\n}\r\nnbx = nbx >> 3;\r\nnby = nby >> 3;\r\nsize = roundup(nbx * nby * 4, track->npipes * (2 << 10));\r\nsize += track->htile_offset;\r\nif (size > radeon_bo_size(track->htile_bo)) {\r\ndev_warn(p->dev, "%s:%d htile surface too small %ld for %ld (%d %d)\n",\r\n__func__, __LINE__, radeon_bo_size(track->htile_bo),\r\nsize, nbx, nby);\r\nreturn -EINVAL;\r\n}\r\n}\r\ntrack->db_dirty = false;\r\nreturn 0;\r\n}\r\nstatic int r600_cs_track_check(struct radeon_cs_parser *p)\r\n{\r\nstruct r600_cs_track *track = p->track;\r\nu32 tmp;\r\nint r, i;\r\nif (p->rdev == NULL)\r\nreturn 0;\r\nif (track->streamout_dirty && track->vgt_strmout_en) {\r\nfor (i = 0; i < 4; i++) {\r\nif (track->vgt_strmout_buffer_en & (1 << i)) {\r\nif (track->vgt_strmout_bo[i]) {\r\nu64 offset = (u64)track->vgt_strmout_bo_offset[i] +\r\n(u64)track->vgt_strmout_size[i];\r\nif (offset > radeon_bo_size(track->vgt_strmout_bo[i])) {\r\nDRM_ERROR("streamout %d bo too small: 0x%llx, 0x%lx\n",\r\ni, offset,\r\nradeon_bo_size(track->vgt_strmout_bo[i]));\r\nreturn -EINVAL;\r\n}\r\n} else {\r\ndev_warn(p->dev, "No buffer for streamout %d\n", i);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\ntrack->streamout_dirty = false;\r\n}\r\nif (track->sx_misc_kill_all_prims)\r\nreturn 0;\r\nif (track->cb_dirty) {\r\ntmp = track->cb_target_mask;\r\nif (track->is_resolve) {\r\ntmp |= 0xff;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nif ((tmp >> (i * 4)) & 0xF) {\r\nif (track->cb_color_bo[i] == NULL) {\r\ndev_warn(p->dev, "%s:%d mask 0x%08X | 0x%08X no cb for %d\n",\r\n__func__, __LINE__, track->cb_target_mask, track->cb_shader_mask, i);\r\nreturn -EINVAL;\r\n}\r\nr = r600_cs_track_validate_cb(p, i);\r\nif (r)\r\nreturn r;\r\n}\r\n}\r\ntrack->cb_dirty = false;\r\n}\r\nif (track->db_dirty &&\r\nG_028010_FORMAT(track->db_depth_info) != V_028010_DEPTH_INVALID &&\r\n(G_028800_STENCIL_ENABLE(track->db_depth_control) ||\r\nG_028800_Z_ENABLE(track->db_depth_control))) {\r\nr = r600_cs_track_validate_db(p);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int r600_cs_packet_parse_vline(struct radeon_cs_parser *p)\r\n{\r\nstatic uint32_t vline_start_end[2] = {AVIVO_D1MODE_VLINE_START_END,\r\nAVIVO_D2MODE_VLINE_START_END};\r\nstatic uint32_t vline_status[2] = {AVIVO_D1MODE_VLINE_STATUS,\r\nAVIVO_D2MODE_VLINE_STATUS};\r\nreturn r600_cs_common_vline_parse(p, vline_start_end, vline_status);\r\n}\r\nint r600_cs_common_vline_parse(struct radeon_cs_parser *p,\r\nuint32_t *vline_start_end,\r\nuint32_t *vline_status)\r\n{\r\nstruct drm_mode_object *obj;\r\nstruct drm_crtc *crtc;\r\nstruct radeon_crtc *radeon_crtc;\r\nstruct radeon_cs_packet p3reloc, wait_reg_mem;\r\nint crtc_id;\r\nint r;\r\nuint32_t header, h_idx, reg, wait_reg_mem_info;\r\nvolatile uint32_t *ib;\r\nib = p->ib.ptr;\r\nr = radeon_cs_packet_parse(p, &wait_reg_mem, p->idx);\r\nif (r)\r\nreturn r;\r\nif (wait_reg_mem.type != RADEON_PACKET_TYPE3 ||\r\nwait_reg_mem.opcode != PACKET3_WAIT_REG_MEM) {\r\nDRM_ERROR("vline wait missing WAIT_REG_MEM segment\n");\r\nreturn -EINVAL;\r\n}\r\nwait_reg_mem_info = radeon_get_ib_value(p, wait_reg_mem.idx + 1);\r\nif (wait_reg_mem_info & 0x10) {\r\nDRM_ERROR("vline WAIT_REG_MEM waiting on MEM instead of REG\n");\r\nreturn -EINVAL;\r\n}\r\nif (wait_reg_mem_info & 0x100) {\r\nDRM_ERROR("vline WAIT_REG_MEM waiting on PFP instead of ME\n");\r\nreturn -EINVAL;\r\n}\r\nif ((wait_reg_mem_info & 0x7) != 0x3) {\r\nDRM_ERROR("vline WAIT_REG_MEM function not equal\n");\r\nreturn -EINVAL;\r\n}\r\nif ((radeon_get_ib_value(p, wait_reg_mem.idx + 2) << 2) != vline_status[0]) {\r\nDRM_ERROR("vline WAIT_REG_MEM bad reg\n");\r\nreturn -EINVAL;\r\n}\r\nif (radeon_get_ib_value(p, wait_reg_mem.idx + 5) != RADEON_VLINE_STAT) {\r\nDRM_ERROR("vline WAIT_REG_MEM bad bit mask\n");\r\nreturn -EINVAL;\r\n}\r\nr = radeon_cs_packet_parse(p, &p3reloc, p->idx + wait_reg_mem.count + 2);\r\nif (r)\r\nreturn r;\r\nh_idx = p->idx - 2;\r\np->idx += wait_reg_mem.count + 2;\r\np->idx += p3reloc.count + 2;\r\nheader = radeon_get_ib_value(p, h_idx);\r\ncrtc_id = radeon_get_ib_value(p, h_idx + 2 + 7 + 1);\r\nreg = R600_CP_PACKET0_GET_REG(header);\r\nobj = drm_mode_object_find(p->rdev->ddev, crtc_id, DRM_MODE_OBJECT_CRTC);\r\nif (!obj) {\r\nDRM_ERROR("cannot find crtc %d\n", crtc_id);\r\nreturn -EINVAL;\r\n}\r\ncrtc = obj_to_crtc(obj);\r\nradeon_crtc = to_radeon_crtc(crtc);\r\ncrtc_id = radeon_crtc->crtc_id;\r\nif (!crtc->enabled) {\r\nib[h_idx + 2] = PACKET2(0);\r\nib[h_idx + 3] = PACKET2(0);\r\nib[h_idx + 4] = PACKET2(0);\r\nib[h_idx + 5] = PACKET2(0);\r\nib[h_idx + 6] = PACKET2(0);\r\nib[h_idx + 7] = PACKET2(0);\r\nib[h_idx + 8] = PACKET2(0);\r\n} else if (reg == vline_start_end[0]) {\r\nheader &= ~R600_CP_PACKET0_REG_MASK;\r\nheader |= vline_start_end[crtc_id] >> 2;\r\nib[h_idx] = header;\r\nib[h_idx + 4] = vline_status[crtc_id] >> 2;\r\n} else {\r\nDRM_ERROR("unknown crtc reloc\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int r600_packet0_check(struct radeon_cs_parser *p,\r\nstruct radeon_cs_packet *pkt,\r\nunsigned idx, unsigned reg)\r\n{\r\nint r;\r\nswitch (reg) {\r\ncase AVIVO_D1MODE_VLINE_START_END:\r\nr = r600_cs_packet_parse_vline(p);\r\nif (r) {\r\nDRM_ERROR("No reloc for ib[%d]=0x%04X\n",\r\nidx, reg);\r\nreturn r;\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Forbidden register 0x%04X in cs at %d\n",\r\nreg, idx);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int r600_cs_parse_packet0(struct radeon_cs_parser *p,\r\nstruct radeon_cs_packet *pkt)\r\n{\r\nunsigned reg, i;\r\nunsigned idx;\r\nint r;\r\nidx = pkt->idx + 1;\r\nreg = pkt->reg;\r\nfor (i = 0; i <= pkt->count; i++, idx++, reg += 4) {\r\nr = r600_packet0_check(p, pkt, idx, reg);\r\nif (r) {\r\nreturn r;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int r600_cs_check_reg(struct radeon_cs_parser *p, u32 reg, u32 idx)\r\n{\r\nstruct r600_cs_track *track = (struct r600_cs_track *)p->track;\r\nstruct radeon_cs_reloc *reloc;\r\nu32 m, i, tmp, *ib;\r\nint r;\r\ni = (reg >> 7);\r\nif (i >= ARRAY_SIZE(r600_reg_safe_bm)) {\r\ndev_warn(p->dev, "forbidden register 0x%08x at %d\n", reg, idx);\r\nreturn -EINVAL;\r\n}\r\nm = 1 << ((reg >> 2) & 31);\r\nif (!(r600_reg_safe_bm[i] & m))\r\nreturn 0;\r\nib = p->ib.ptr;\r\nswitch (reg) {\r\ncase R_0288A8_SQ_ESGS_RING_ITEMSIZE:\r\ncase R_008C44_SQ_ESGS_RING_SIZE:\r\ncase R_0288B0_SQ_ESTMP_RING_ITEMSIZE:\r\ncase R_008C54_SQ_ESTMP_RING_SIZE:\r\ncase R_0288C0_SQ_FBUF_RING_ITEMSIZE:\r\ncase R_008C74_SQ_FBUF_RING_SIZE:\r\ncase R_0288B4_SQ_GSTMP_RING_ITEMSIZE:\r\ncase R_008C5C_SQ_GSTMP_RING_SIZE:\r\ncase R_0288AC_SQ_GSVS_RING_ITEMSIZE:\r\ncase R_008C4C_SQ_GSVS_RING_SIZE:\r\ncase R_0288BC_SQ_PSTMP_RING_ITEMSIZE:\r\ncase R_008C6C_SQ_PSTMP_RING_SIZE:\r\ncase R_0288C4_SQ_REDUC_RING_ITEMSIZE:\r\ncase R_008C7C_SQ_REDUC_RING_SIZE:\r\ncase R_0288B8_SQ_VSTMP_RING_ITEMSIZE:\r\ncase R_008C64_SQ_VSTMP_RING_SIZE:\r\ncase R_0288C8_SQ_GS_VERT_ITEMSIZE:\r\ntmp =radeon_get_ib_value(p, idx);\r\nib[idx] = 0;\r\nbreak;\r\ncase SQ_CONFIG:\r\ntrack->sq_config = radeon_get_ib_value(p, idx);\r\nbreak;\r\ncase R_028800_DB_DEPTH_CONTROL:\r\ntrack->db_depth_control = radeon_get_ib_value(p, idx);\r\ntrack->db_dirty = true;\r\nbreak;\r\ncase R_028010_DB_DEPTH_INFO:\r\nif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS) &&\r\nradeon_cs_packet_next_is_pkt3_nop(p)) {\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntrack->db_depth_info = radeon_get_ib_value(p, idx);\r\nib[idx] &= C_028010_ARRAY_MODE;\r\ntrack->db_depth_info &= C_028010_ARRAY_MODE;\r\nif (reloc->lobj.tiling_flags & RADEON_TILING_MACRO) {\r\nib[idx] |= S_028010_ARRAY_MODE(V_028010_ARRAY_2D_TILED_THIN1);\r\ntrack->db_depth_info |= S_028010_ARRAY_MODE(V_028010_ARRAY_2D_TILED_THIN1);\r\n} else {\r\nib[idx] |= S_028010_ARRAY_MODE(V_028010_ARRAY_1D_TILED_THIN1);\r\ntrack->db_depth_info |= S_028010_ARRAY_MODE(V_028010_ARRAY_1D_TILED_THIN1);\r\n}\r\n} else {\r\ntrack->db_depth_info = radeon_get_ib_value(p, idx);\r\n}\r\ntrack->db_dirty = true;\r\nbreak;\r\ncase R_028004_DB_DEPTH_VIEW:\r\ntrack->db_depth_view = radeon_get_ib_value(p, idx);\r\ntrack->db_dirty = true;\r\nbreak;\r\ncase R_028000_DB_DEPTH_SIZE:\r\ntrack->db_depth_size = radeon_get_ib_value(p, idx);\r\ntrack->db_depth_size_idx = idx;\r\ntrack->db_dirty = true;\r\nbreak;\r\ncase R_028AB0_VGT_STRMOUT_EN:\r\ntrack->vgt_strmout_en = radeon_get_ib_value(p, idx);\r\ntrack->streamout_dirty = true;\r\nbreak;\r\ncase R_028B20_VGT_STRMOUT_BUFFER_EN:\r\ntrack->vgt_strmout_buffer_en = radeon_get_ib_value(p, idx);\r\ntrack->streamout_dirty = true;\r\nbreak;\r\ncase VGT_STRMOUT_BUFFER_BASE_0:\r\ncase VGT_STRMOUT_BUFFER_BASE_1:\r\ncase VGT_STRMOUT_BUFFER_BASE_2:\r\ncase VGT_STRMOUT_BUFFER_BASE_3:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntmp = (reg - VGT_STRMOUT_BUFFER_BASE_0) / 16;\r\ntrack->vgt_strmout_bo_offset[tmp] = radeon_get_ib_value(p, idx) << 8;\r\nib[idx] += (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);\r\ntrack->vgt_strmout_bo[tmp] = reloc->robj;\r\ntrack->vgt_strmout_bo_mc[tmp] = reloc->lobj.gpu_offset;\r\ntrack->streamout_dirty = true;\r\nbreak;\r\ncase VGT_STRMOUT_BUFFER_SIZE_0:\r\ncase VGT_STRMOUT_BUFFER_SIZE_1:\r\ncase VGT_STRMOUT_BUFFER_SIZE_2:\r\ncase VGT_STRMOUT_BUFFER_SIZE_3:\r\ntmp = (reg - VGT_STRMOUT_BUFFER_SIZE_0) / 16;\r\ntrack->vgt_strmout_size[tmp] = radeon_get_ib_value(p, idx) * 4;\r\ntrack->streamout_dirty = true;\r\nbreak;\r\ncase CP_COHER_BASE:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\ndev_warn(p->dev, "missing reloc for CP_COHER_BASE "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\nib[idx] += (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);\r\nbreak;\r\ncase R_028238_CB_TARGET_MASK:\r\ntrack->cb_target_mask = radeon_get_ib_value(p, idx);\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase R_02823C_CB_SHADER_MASK:\r\ntrack->cb_shader_mask = radeon_get_ib_value(p, idx);\r\nbreak;\r\ncase R_028C04_PA_SC_AA_CONFIG:\r\ntmp = G_028C04_MSAA_NUM_SAMPLES(radeon_get_ib_value(p, idx));\r\ntrack->log_nsamples = tmp;\r\ntrack->nsamples = 1 << tmp;\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase R_028808_CB_COLOR_CONTROL:\r\ntmp = G_028808_SPECIAL_OP(radeon_get_ib_value(p, idx));\r\ntrack->is_resolve = tmp == V_028808_SPECIAL_RESOLVE_BOX;\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase R_0280A0_CB_COLOR0_INFO:\r\ncase R_0280A4_CB_COLOR1_INFO:\r\ncase R_0280A8_CB_COLOR2_INFO:\r\ncase R_0280AC_CB_COLOR3_INFO:\r\ncase R_0280B0_CB_COLOR4_INFO:\r\ncase R_0280B4_CB_COLOR5_INFO:\r\ncase R_0280B8_CB_COLOR6_INFO:\r\ncase R_0280BC_CB_COLOR7_INFO:\r\nif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS) &&\r\nradeon_cs_packet_next_is_pkt3_nop(p)) {\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\ndev_err(p->dev, "bad SET_CONTEXT_REG 0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntmp = (reg - R_0280A0_CB_COLOR0_INFO) / 4;\r\ntrack->cb_color_info[tmp] = radeon_get_ib_value(p, idx);\r\nif (reloc->lobj.tiling_flags & RADEON_TILING_MACRO) {\r\nib[idx] |= S_0280A0_ARRAY_MODE(V_0280A0_ARRAY_2D_TILED_THIN1);\r\ntrack->cb_color_info[tmp] |= S_0280A0_ARRAY_MODE(V_0280A0_ARRAY_2D_TILED_THIN1);\r\n} else if (reloc->lobj.tiling_flags & RADEON_TILING_MICRO) {\r\nib[idx] |= S_0280A0_ARRAY_MODE(V_0280A0_ARRAY_1D_TILED_THIN1);\r\ntrack->cb_color_info[tmp] |= S_0280A0_ARRAY_MODE(V_0280A0_ARRAY_1D_TILED_THIN1);\r\n}\r\n} else {\r\ntmp = (reg - R_0280A0_CB_COLOR0_INFO) / 4;\r\ntrack->cb_color_info[tmp] = radeon_get_ib_value(p, idx);\r\n}\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase R_028080_CB_COLOR0_VIEW:\r\ncase R_028084_CB_COLOR1_VIEW:\r\ncase R_028088_CB_COLOR2_VIEW:\r\ncase R_02808C_CB_COLOR3_VIEW:\r\ncase R_028090_CB_COLOR4_VIEW:\r\ncase R_028094_CB_COLOR5_VIEW:\r\ncase R_028098_CB_COLOR6_VIEW:\r\ncase R_02809C_CB_COLOR7_VIEW:\r\ntmp = (reg - R_028080_CB_COLOR0_VIEW) / 4;\r\ntrack->cb_color_view[tmp] = radeon_get_ib_value(p, idx);\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase R_028060_CB_COLOR0_SIZE:\r\ncase R_028064_CB_COLOR1_SIZE:\r\ncase R_028068_CB_COLOR2_SIZE:\r\ncase R_02806C_CB_COLOR3_SIZE:\r\ncase R_028070_CB_COLOR4_SIZE:\r\ncase R_028074_CB_COLOR5_SIZE:\r\ncase R_028078_CB_COLOR6_SIZE:\r\ncase R_02807C_CB_COLOR7_SIZE:\r\ntmp = (reg - R_028060_CB_COLOR0_SIZE) / 4;\r\ntrack->cb_color_size[tmp] = radeon_get_ib_value(p, idx);\r\ntrack->cb_color_size_idx[tmp] = idx;\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase R_0280E0_CB_COLOR0_FRAG:\r\ncase R_0280E4_CB_COLOR1_FRAG:\r\ncase R_0280E8_CB_COLOR2_FRAG:\r\ncase R_0280EC_CB_COLOR3_FRAG:\r\ncase R_0280F0_CB_COLOR4_FRAG:\r\ncase R_0280F4_CB_COLOR5_FRAG:\r\ncase R_0280F8_CB_COLOR6_FRAG:\r\ncase R_0280FC_CB_COLOR7_FRAG:\r\ntmp = (reg - R_0280E0_CB_COLOR0_FRAG) / 4;\r\nif (!radeon_cs_packet_next_is_pkt3_nop(p)) {\r\nif (!track->cb_color_base_last[tmp]) {\r\ndev_err(p->dev, "Broken old userspace ? no cb_color0_base supplied before trying to write 0x%08X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntrack->cb_color_frag_bo[tmp] = track->cb_color_bo[tmp];\r\ntrack->cb_color_frag_offset[tmp] = track->cb_color_bo_offset[tmp];\r\nib[idx] = track->cb_color_base_last[tmp];\r\n} else {\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\ndev_err(p->dev, "bad SET_CONTEXT_REG 0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntrack->cb_color_frag_bo[tmp] = reloc->robj;\r\ntrack->cb_color_frag_offset[tmp] = (u64)ib[idx] << 8;\r\nib[idx] += (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);\r\n}\r\nif (G_0280A0_TILE_MODE(track->cb_color_info[tmp])) {\r\ntrack->cb_dirty = true;\r\n}\r\nbreak;\r\ncase R_0280C0_CB_COLOR0_TILE:\r\ncase R_0280C4_CB_COLOR1_TILE:\r\ncase R_0280C8_CB_COLOR2_TILE:\r\ncase R_0280CC_CB_COLOR3_TILE:\r\ncase R_0280D0_CB_COLOR4_TILE:\r\ncase R_0280D4_CB_COLOR5_TILE:\r\ncase R_0280D8_CB_COLOR6_TILE:\r\ncase R_0280DC_CB_COLOR7_TILE:\r\ntmp = (reg - R_0280C0_CB_COLOR0_TILE) / 4;\r\nif (!radeon_cs_packet_next_is_pkt3_nop(p)) {\r\nif (!track->cb_color_base_last[tmp]) {\r\ndev_err(p->dev, "Broken old userspace ? no cb_color0_base supplied before trying to write 0x%08X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntrack->cb_color_tile_bo[tmp] = track->cb_color_bo[tmp];\r\ntrack->cb_color_tile_offset[tmp] = track->cb_color_bo_offset[tmp];\r\nib[idx] = track->cb_color_base_last[tmp];\r\n} else {\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\ndev_err(p->dev, "bad SET_CONTEXT_REG 0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntrack->cb_color_tile_bo[tmp] = reloc->robj;\r\ntrack->cb_color_tile_offset[tmp] = (u64)ib[idx] << 8;\r\nib[idx] += (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);\r\n}\r\nif (G_0280A0_TILE_MODE(track->cb_color_info[tmp])) {\r\ntrack->cb_dirty = true;\r\n}\r\nbreak;\r\ncase R_028100_CB_COLOR0_MASK:\r\ncase R_028104_CB_COLOR1_MASK:\r\ncase R_028108_CB_COLOR2_MASK:\r\ncase R_02810C_CB_COLOR3_MASK:\r\ncase R_028110_CB_COLOR4_MASK:\r\ncase R_028114_CB_COLOR5_MASK:\r\ncase R_028118_CB_COLOR6_MASK:\r\ncase R_02811C_CB_COLOR7_MASK:\r\ntmp = (reg - R_028100_CB_COLOR0_MASK) / 4;\r\ntrack->cb_color_mask[tmp] = radeon_get_ib_value(p, idx);\r\nif (G_0280A0_TILE_MODE(track->cb_color_info[tmp])) {\r\ntrack->cb_dirty = true;\r\n}\r\nbreak;\r\ncase CB_COLOR0_BASE:\r\ncase CB_COLOR1_BASE:\r\ncase CB_COLOR2_BASE:\r\ncase CB_COLOR3_BASE:\r\ncase CB_COLOR4_BASE:\r\ncase CB_COLOR5_BASE:\r\ncase CB_COLOR6_BASE:\r\ncase CB_COLOR7_BASE:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntmp = (reg - CB_COLOR0_BASE) / 4;\r\ntrack->cb_color_bo_offset[tmp] = radeon_get_ib_value(p, idx) << 8;\r\nib[idx] += (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);\r\ntrack->cb_color_base_last[tmp] = ib[idx];\r\ntrack->cb_color_bo[tmp] = reloc->robj;\r\ntrack->cb_color_bo_mc[tmp] = reloc->lobj.gpu_offset;\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase DB_DEPTH_BASE:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntrack->db_offset = radeon_get_ib_value(p, idx) << 8;\r\nib[idx] += (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);\r\ntrack->db_bo = reloc->robj;\r\ntrack->db_bo_mc = reloc->lobj.gpu_offset;\r\ntrack->db_dirty = true;\r\nbreak;\r\ncase DB_HTILE_DATA_BASE:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntrack->htile_offset = radeon_get_ib_value(p, idx) << 8;\r\nib[idx] += (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);\r\ntrack->htile_bo = reloc->robj;\r\ntrack->db_dirty = true;\r\nbreak;\r\ncase DB_HTILE_SURFACE:\r\ntrack->htile_surface = radeon_get_ib_value(p, idx);\r\nib[idx] |= 3;\r\ntrack->db_dirty = true;\r\nbreak;\r\ncase SQ_PGM_START_FS:\r\ncase SQ_PGM_START_ES:\r\ncase SQ_PGM_START_VS:\r\ncase SQ_PGM_START_GS:\r\ncase SQ_PGM_START_PS:\r\ncase SQ_ALU_CONST_CACHE_GS_0:\r\ncase SQ_ALU_CONST_CACHE_GS_1:\r\ncase SQ_ALU_CONST_CACHE_GS_2:\r\ncase SQ_ALU_CONST_CACHE_GS_3:\r\ncase SQ_ALU_CONST_CACHE_GS_4:\r\ncase SQ_ALU_CONST_CACHE_GS_5:\r\ncase SQ_ALU_CONST_CACHE_GS_6:\r\ncase SQ_ALU_CONST_CACHE_GS_7:\r\ncase SQ_ALU_CONST_CACHE_GS_8:\r\ncase SQ_ALU_CONST_CACHE_GS_9:\r\ncase SQ_ALU_CONST_CACHE_GS_10:\r\ncase SQ_ALU_CONST_CACHE_GS_11:\r\ncase SQ_ALU_CONST_CACHE_GS_12:\r\ncase SQ_ALU_CONST_CACHE_GS_13:\r\ncase SQ_ALU_CONST_CACHE_GS_14:\r\ncase SQ_ALU_CONST_CACHE_GS_15:\r\ncase SQ_ALU_CONST_CACHE_PS_0:\r\ncase SQ_ALU_CONST_CACHE_PS_1:\r\ncase SQ_ALU_CONST_CACHE_PS_2:\r\ncase SQ_ALU_CONST_CACHE_PS_3:\r\ncase SQ_ALU_CONST_CACHE_PS_4:\r\ncase SQ_ALU_CONST_CACHE_PS_5:\r\ncase SQ_ALU_CONST_CACHE_PS_6:\r\ncase SQ_ALU_CONST_CACHE_PS_7:\r\ncase SQ_ALU_CONST_CACHE_PS_8:\r\ncase SQ_ALU_CONST_CACHE_PS_9:\r\ncase SQ_ALU_CONST_CACHE_PS_10:\r\ncase SQ_ALU_CONST_CACHE_PS_11:\r\ncase SQ_ALU_CONST_CACHE_PS_12:\r\ncase SQ_ALU_CONST_CACHE_PS_13:\r\ncase SQ_ALU_CONST_CACHE_PS_14:\r\ncase SQ_ALU_CONST_CACHE_PS_15:\r\ncase SQ_ALU_CONST_CACHE_VS_0:\r\ncase SQ_ALU_CONST_CACHE_VS_1:\r\ncase SQ_ALU_CONST_CACHE_VS_2:\r\ncase SQ_ALU_CONST_CACHE_VS_3:\r\ncase SQ_ALU_CONST_CACHE_VS_4:\r\ncase SQ_ALU_CONST_CACHE_VS_5:\r\ncase SQ_ALU_CONST_CACHE_VS_6:\r\ncase SQ_ALU_CONST_CACHE_VS_7:\r\ncase SQ_ALU_CONST_CACHE_VS_8:\r\ncase SQ_ALU_CONST_CACHE_VS_9:\r\ncase SQ_ALU_CONST_CACHE_VS_10:\r\ncase SQ_ALU_CONST_CACHE_VS_11:\r\ncase SQ_ALU_CONST_CACHE_VS_12:\r\ncase SQ_ALU_CONST_CACHE_VS_13:\r\ncase SQ_ALU_CONST_CACHE_VS_14:\r\ncase SQ_ALU_CONST_CACHE_VS_15:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\nib[idx] += (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);\r\nbreak;\r\ncase SX_MEMORY_EXPORT_BASE:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONFIG_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\nib[idx] += (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);\r\nbreak;\r\ncase SX_MISC:\r\ntrack->sx_misc_kill_all_prims = (radeon_get_ib_value(p, idx) & 0x1) != 0;\r\nbreak;\r\ndefault:\r\ndev_warn(p->dev, "forbidden register 0x%08x at %d\n", reg, idx);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nunsigned r600_mip_minify(unsigned size, unsigned level)\r\n{\r\nunsigned val;\r\nval = max(1U, size >> level);\r\nif (level > 0)\r\nval = roundup_pow_of_two(val);\r\nreturn val;\r\n}\r\nstatic void r600_texture_size(unsigned nfaces, unsigned blevel, unsigned llevel,\r\nunsigned w0, unsigned h0, unsigned d0, unsigned nsamples, unsigned format,\r\nunsigned block_align, unsigned height_align, unsigned base_align,\r\nunsigned *l0_size, unsigned *mipmap_size)\r\n{\r\nunsigned offset, i, level;\r\nunsigned width, height, depth, size;\r\nunsigned blocksize;\r\nunsigned nbx, nby;\r\nunsigned nlevels = llevel - blevel + 1;\r\n*l0_size = -1;\r\nblocksize = r600_fmt_get_blocksize(format);\r\nw0 = r600_mip_minify(w0, 0);\r\nh0 = r600_mip_minify(h0, 0);\r\nd0 = r600_mip_minify(d0, 0);\r\nfor(i = 0, offset = 0, level = blevel; i < nlevels; i++, level++) {\r\nwidth = r600_mip_minify(w0, i);\r\nnbx = r600_fmt_get_nblocksx(format, width);\r\nnbx = round_up(nbx, block_align);\r\nheight = r600_mip_minify(h0, i);\r\nnby = r600_fmt_get_nblocksy(format, height);\r\nnby = round_up(nby, height_align);\r\ndepth = r600_mip_minify(d0, i);\r\nsize = nbx * nby * blocksize * nsamples;\r\nif (nfaces)\r\nsize *= nfaces;\r\nelse\r\nsize *= depth;\r\nif (i == 0)\r\n*l0_size = size;\r\nif (i == 0 || i == 1)\r\noffset = round_up(offset, base_align);\r\noffset += size;\r\n}\r\n*mipmap_size = offset;\r\nif (llevel == 0)\r\n*mipmap_size = *l0_size;\r\nif (!blevel)\r\n*mipmap_size -= *l0_size;\r\n}\r\nstatic int r600_check_texture_resource(struct radeon_cs_parser *p, u32 idx,\r\nstruct radeon_bo *texture,\r\nstruct radeon_bo *mipmap,\r\nu64 base_offset,\r\nu64 mip_offset,\r\nu32 tiling_flags)\r\n{\r\nstruct r600_cs_track *track = p->track;\r\nu32 dim, nfaces, llevel, blevel, w0, h0, d0;\r\nu32 word0, word1, l0_size, mipmap_size, word2, word3, word4, word5;\r\nu32 height_align, pitch, pitch_align, depth_align;\r\nu32 barray, larray;\r\nu64 base_align;\r\nstruct array_mode_checker array_check;\r\nu32 format;\r\nbool is_array;\r\nif (p->rdev == NULL)\r\nreturn 0;\r\nbase_offset <<= 8;\r\nmip_offset <<= 8;\r\nword0 = radeon_get_ib_value(p, idx + 0);\r\nif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\r\nif (tiling_flags & RADEON_TILING_MACRO)\r\nword0 |= S_038000_TILE_MODE(V_038000_ARRAY_2D_TILED_THIN1);\r\nelse if (tiling_flags & RADEON_TILING_MICRO)\r\nword0 |= S_038000_TILE_MODE(V_038000_ARRAY_1D_TILED_THIN1);\r\n}\r\nword1 = radeon_get_ib_value(p, idx + 1);\r\nword2 = radeon_get_ib_value(p, idx + 2) << 8;\r\nword3 = radeon_get_ib_value(p, idx + 3) << 8;\r\nword4 = radeon_get_ib_value(p, idx + 4);\r\nword5 = radeon_get_ib_value(p, idx + 5);\r\ndim = G_038000_DIM(word0);\r\nw0 = G_038000_TEX_WIDTH(word0) + 1;\r\npitch = (G_038000_PITCH(word0) + 1) * 8;\r\nh0 = G_038004_TEX_HEIGHT(word1) + 1;\r\nd0 = G_038004_TEX_DEPTH(word1);\r\nformat = G_038004_DATA_FORMAT(word1);\r\nblevel = G_038010_BASE_LEVEL(word4);\r\nllevel = G_038014_LAST_LEVEL(word5);\r\narray_check.array_mode = G_038000_TILE_MODE(word0);\r\narray_check.group_size = track->group_size;\r\narray_check.nbanks = track->nbanks;\r\narray_check.npipes = track->npipes;\r\narray_check.nsamples = 1;\r\narray_check.blocksize = r600_fmt_get_blocksize(format);\r\nnfaces = 1;\r\nis_array = false;\r\nswitch (dim) {\r\ncase V_038000_SQ_TEX_DIM_1D:\r\ncase V_038000_SQ_TEX_DIM_2D:\r\ncase V_038000_SQ_TEX_DIM_3D:\r\nbreak;\r\ncase V_038000_SQ_TEX_DIM_CUBEMAP:\r\nif (p->family >= CHIP_RV770)\r\nnfaces = 8;\r\nelse\r\nnfaces = 6;\r\nbreak;\r\ncase V_038000_SQ_TEX_DIM_1D_ARRAY:\r\ncase V_038000_SQ_TEX_DIM_2D_ARRAY:\r\nis_array = true;\r\nbreak;\r\ncase V_038000_SQ_TEX_DIM_2D_ARRAY_MSAA:\r\nis_array = true;\r\ncase V_038000_SQ_TEX_DIM_2D_MSAA:\r\narray_check.nsamples = 1 << llevel;\r\nllevel = 0;\r\nbreak;\r\ndefault:\r\ndev_warn(p->dev, "this kernel doesn't support %d texture dim\n", G_038000_DIM(word0));\r\nreturn -EINVAL;\r\n}\r\nif (!r600_fmt_is_valid_texture(format, p->family)) {\r\ndev_warn(p->dev, "%s:%d texture invalid format %d\n",\r\n__func__, __LINE__, format);\r\nreturn -EINVAL;\r\n}\r\nif (r600_get_array_mode_alignment(&array_check,\r\n&pitch_align, &height_align, &depth_align, &base_align)) {\r\ndev_warn(p->dev, "%s:%d tex array mode (%d) invalid\n",\r\n__func__, __LINE__, G_038000_TILE_MODE(word0));\r\nreturn -EINVAL;\r\n}\r\nif (!IS_ALIGNED(pitch, pitch_align)) {\r\ndev_warn(p->dev, "%s:%d tex pitch (%d, 0x%x, %d) invalid\n",\r\n__func__, __LINE__, pitch, pitch_align, G_038000_TILE_MODE(word0));\r\nreturn -EINVAL;\r\n}\r\nif (!IS_ALIGNED(base_offset, base_align)) {\r\ndev_warn(p->dev, "%s:%d tex base offset (0x%llx, 0x%llx, %d) invalid\n",\r\n__func__, __LINE__, base_offset, base_align, G_038000_TILE_MODE(word0));\r\nreturn -EINVAL;\r\n}\r\nif (!IS_ALIGNED(mip_offset, base_align)) {\r\ndev_warn(p->dev, "%s:%d tex mip offset (0x%llx, 0x%llx, %d) invalid\n",\r\n__func__, __LINE__, mip_offset, base_align, G_038000_TILE_MODE(word0));\r\nreturn -EINVAL;\r\n}\r\nif (blevel > llevel) {\r\ndev_warn(p->dev, "texture blevel %d > llevel %d\n",\r\nblevel, llevel);\r\n}\r\nif (is_array) {\r\nbarray = G_038014_BASE_ARRAY(word5);\r\nlarray = G_038014_LAST_ARRAY(word5);\r\nnfaces = larray - barray + 1;\r\n}\r\nr600_texture_size(nfaces, blevel, llevel, w0, h0, d0, array_check.nsamples, format,\r\npitch_align, height_align, base_align,\r\n&l0_size, &mipmap_size);\r\nif ((l0_size + word2) > radeon_bo_size(texture)) {\r\ndev_warn(p->dev, "texture bo too small ((%d %d) (%d %d) %d %d %d -> %d have %ld)\n",\r\nw0, h0, pitch_align, height_align,\r\narray_check.array_mode, format, word2,\r\nl0_size, radeon_bo_size(texture));\r\ndev_warn(p->dev, "alignments %d %d %d %lld\n", pitch, pitch_align, height_align, base_align);\r\nreturn -EINVAL;\r\n}\r\nif ((mipmap_size + word3) > radeon_bo_size(mipmap)) {\r\n}\r\nreturn 0;\r\n}\r\nstatic bool r600_is_safe_reg(struct radeon_cs_parser *p, u32 reg, u32 idx)\r\n{\r\nu32 m, i;\r\ni = (reg >> 7);\r\nif (i >= ARRAY_SIZE(r600_reg_safe_bm)) {\r\ndev_warn(p->dev, "forbidden register 0x%08x at %d\n", reg, idx);\r\nreturn false;\r\n}\r\nm = 1 << ((reg >> 2) & 31);\r\nif (!(r600_reg_safe_bm[i] & m))\r\nreturn true;\r\ndev_warn(p->dev, "forbidden register 0x%08x at %d\n", reg, idx);\r\nreturn false;\r\n}\r\nstatic int r600_packet3_check(struct radeon_cs_parser *p,\r\nstruct radeon_cs_packet *pkt)\r\n{\r\nstruct radeon_cs_reloc *reloc;\r\nstruct r600_cs_track *track;\r\nvolatile u32 *ib;\r\nunsigned idx;\r\nunsigned i;\r\nunsigned start_reg, end_reg, reg;\r\nint r;\r\nu32 idx_value;\r\ntrack = (struct r600_cs_track *)p->track;\r\nib = p->ib.ptr;\r\nidx = pkt->idx + 1;\r\nidx_value = radeon_get_ib_value(p, idx);\r\nswitch (pkt->opcode) {\r\ncase PACKET3_SET_PREDICATION:\r\n{\r\nint pred_op;\r\nint tmp;\r\nuint64_t offset;\r\nif (pkt->count != 1) {\r\nDRM_ERROR("bad SET PREDICATION\n");\r\nreturn -EINVAL;\r\n}\r\ntmp = radeon_get_ib_value(p, idx + 1);\r\npred_op = (tmp >> 16) & 0x7;\r\nif (pred_op == 0)\r\nreturn 0;\r\nif (pred_op > 2) {\r\nDRM_ERROR("bad SET PREDICATION operation %d\n", pred_op);\r\nreturn -EINVAL;\r\n}\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\nDRM_ERROR("bad SET PREDICATION\n");\r\nreturn -EINVAL;\r\n}\r\noffset = reloc->lobj.gpu_offset +\r\n(idx_value & 0xfffffff0) +\r\n((u64)(tmp & 0xff) << 32);\r\nib[idx + 0] = offset;\r\nib[idx + 1] = (tmp & 0xffffff00) | (upper_32_bits(offset) & 0xff);\r\n}\r\nbreak;\r\ncase PACKET3_START_3D_CMDBUF:\r\nif (p->family >= CHIP_RV770 || pkt->count) {\r\nDRM_ERROR("bad START_3D\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_CONTEXT_CONTROL:\r\nif (pkt->count != 1) {\r\nDRM_ERROR("bad CONTEXT_CONTROL\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_INDEX_TYPE:\r\ncase PACKET3_NUM_INSTANCES:\r\nif (pkt->count) {\r\nDRM_ERROR("bad INDEX_TYPE/NUM_INSTANCES\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_DRAW_INDEX:\r\n{\r\nuint64_t offset;\r\nif (pkt->count != 3) {\r\nDRM_ERROR("bad DRAW_INDEX\n");\r\nreturn -EINVAL;\r\n}\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\nDRM_ERROR("bad DRAW_INDEX\n");\r\nreturn -EINVAL;\r\n}\r\noffset = reloc->lobj.gpu_offset +\r\nidx_value +\r\n((u64)(radeon_get_ib_value(p, idx+1) & 0xff) << 32);\r\nib[idx+0] = offset;\r\nib[idx+1] = upper_32_bits(offset) & 0xff;\r\nr = r600_cs_track_check(p);\r\nif (r) {\r\ndev_warn(p->dev, "%s:%d invalid cmd stream\n", __func__, __LINE__);\r\nreturn r;\r\n}\r\nbreak;\r\n}\r\ncase PACKET3_DRAW_INDEX_AUTO:\r\nif (pkt->count != 1) {\r\nDRM_ERROR("bad DRAW_INDEX_AUTO\n");\r\nreturn -EINVAL;\r\n}\r\nr = r600_cs_track_check(p);\r\nif (r) {\r\ndev_warn(p->dev, "%s:%d invalid cmd stream %d\n", __func__, __LINE__, idx);\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_DRAW_INDEX_IMMD_BE:\r\ncase PACKET3_DRAW_INDEX_IMMD:\r\nif (pkt->count < 2) {\r\nDRM_ERROR("bad DRAW_INDEX_IMMD\n");\r\nreturn -EINVAL;\r\n}\r\nr = r600_cs_track_check(p);\r\nif (r) {\r\ndev_warn(p->dev, "%s:%d invalid cmd stream\n", __func__, __LINE__);\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_WAIT_REG_MEM:\r\nif (pkt->count != 5) {\r\nDRM_ERROR("bad WAIT_REG_MEM\n");\r\nreturn -EINVAL;\r\n}\r\nif (idx_value & 0x10) {\r\nuint64_t offset;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\nDRM_ERROR("bad WAIT_REG_MEM\n");\r\nreturn -EINVAL;\r\n}\r\noffset = reloc->lobj.gpu_offset +\r\n(radeon_get_ib_value(p, idx+1) & 0xfffffff0) +\r\n((u64)(radeon_get_ib_value(p, idx+2) & 0xff) << 32);\r\nib[idx+1] = (ib[idx+1] & 0x3) | (offset & 0xfffffff0);\r\nib[idx+2] = upper_32_bits(offset) & 0xff;\r\n} else if (idx_value & 0x100) {\r\nDRM_ERROR("cannot use PFP on REG wait\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_CP_DMA:\r\n{\r\nu32 command, size;\r\nu64 offset, tmp;\r\nif (pkt->count != 4) {\r\nDRM_ERROR("bad CP DMA\n");\r\nreturn -EINVAL;\r\n}\r\ncommand = radeon_get_ib_value(p, idx+4);\r\nsize = command & 0x1fffff;\r\nif (command & PACKET3_CP_DMA_CMD_SAS) {\r\nDRM_ERROR("CP DMA SAS not supported\n");\r\nreturn -EINVAL;\r\n} else {\r\nif (command & PACKET3_CP_DMA_CMD_SAIC) {\r\nDRM_ERROR("CP DMA SAIC only supported for registers\n");\r\nreturn -EINVAL;\r\n}\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\nDRM_ERROR("bad CP DMA SRC\n");\r\nreturn -EINVAL;\r\n}\r\ntmp = radeon_get_ib_value(p, idx) +\r\n((u64)(radeon_get_ib_value(p, idx+1) & 0xff) << 32);\r\noffset = reloc->lobj.gpu_offset + tmp;\r\nif ((tmp + size) > radeon_bo_size(reloc->robj)) {\r\ndev_warn(p->dev, "CP DMA src buffer too small (%llu %lu)\n",\r\ntmp + size, radeon_bo_size(reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nib[idx] = offset;\r\nib[idx+1] = (ib[idx+1] & 0xffffff00) | (upper_32_bits(offset) & 0xff);\r\n}\r\nif (command & PACKET3_CP_DMA_CMD_DAS) {\r\nDRM_ERROR("CP DMA DAS not supported\n");\r\nreturn -EINVAL;\r\n} else {\r\nif (command & PACKET3_CP_DMA_CMD_DAIC) {\r\nDRM_ERROR("CP DMA DAIC only supported for registers\n");\r\nreturn -EINVAL;\r\n}\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\nDRM_ERROR("bad CP DMA DST\n");\r\nreturn -EINVAL;\r\n}\r\ntmp = radeon_get_ib_value(p, idx+2) +\r\n((u64)(radeon_get_ib_value(p, idx+3) & 0xff) << 32);\r\noffset = reloc->lobj.gpu_offset + tmp;\r\nif ((tmp + size) > radeon_bo_size(reloc->robj)) {\r\ndev_warn(p->dev, "CP DMA dst buffer too small (%llu %lu)\n",\r\ntmp + size, radeon_bo_size(reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nib[idx+2] = offset;\r\nib[idx+3] = upper_32_bits(offset) & 0xff;\r\n}\r\nbreak;\r\n}\r\ncase PACKET3_SURFACE_SYNC:\r\nif (pkt->count != 3) {\r\nDRM_ERROR("bad SURFACE_SYNC\n");\r\nreturn -EINVAL;\r\n}\r\nif (radeon_get_ib_value(p, idx + 1) != 0xffffffff ||\r\nradeon_get_ib_value(p, idx + 2) != 0) {\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\nDRM_ERROR("bad SURFACE_SYNC\n");\r\nreturn -EINVAL;\r\n}\r\nib[idx+2] += (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);\r\n}\r\nbreak;\r\ncase PACKET3_EVENT_WRITE:\r\nif (pkt->count != 2 && pkt->count != 0) {\r\nDRM_ERROR("bad EVENT_WRITE\n");\r\nreturn -EINVAL;\r\n}\r\nif (pkt->count) {\r\nuint64_t offset;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\nDRM_ERROR("bad EVENT_WRITE\n");\r\nreturn -EINVAL;\r\n}\r\noffset = reloc->lobj.gpu_offset +\r\n(radeon_get_ib_value(p, idx+1) & 0xfffffff8) +\r\n((u64)(radeon_get_ib_value(p, idx+2) & 0xff) << 32);\r\nib[idx+1] = offset & 0xfffffff8;\r\nib[idx+2] = upper_32_bits(offset) & 0xff;\r\n}\r\nbreak;\r\ncase PACKET3_EVENT_WRITE_EOP:\r\n{\r\nuint64_t offset;\r\nif (pkt->count != 4) {\r\nDRM_ERROR("bad EVENT_WRITE_EOP\n");\r\nreturn -EINVAL;\r\n}\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\nDRM_ERROR("bad EVENT_WRITE\n");\r\nreturn -EINVAL;\r\n}\r\noffset = reloc->lobj.gpu_offset +\r\n(radeon_get_ib_value(p, idx+1) & 0xfffffffc) +\r\n((u64)(radeon_get_ib_value(p, idx+2) & 0xff) << 32);\r\nib[idx+1] = offset & 0xfffffffc;\r\nib[idx+2] = (ib[idx+2] & 0xffffff00) | (upper_32_bits(offset) & 0xff);\r\nbreak;\r\n}\r\ncase PACKET3_SET_CONFIG_REG:\r\nstart_reg = (idx_value << 2) + PACKET3_SET_CONFIG_REG_OFFSET;\r\nend_reg = 4 * pkt->count + start_reg - 4;\r\nif ((start_reg < PACKET3_SET_CONFIG_REG_OFFSET) ||\r\n(start_reg >= PACKET3_SET_CONFIG_REG_END) ||\r\n(end_reg >= PACKET3_SET_CONFIG_REG_END)) {\r\nDRM_ERROR("bad PACKET3_SET_CONFIG_REG\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < pkt->count; i++) {\r\nreg = start_reg + (4 * i);\r\nr = r600_cs_check_reg(p, reg, idx+1+i);\r\nif (r)\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_SET_CONTEXT_REG:\r\nstart_reg = (idx_value << 2) + PACKET3_SET_CONTEXT_REG_OFFSET;\r\nend_reg = 4 * pkt->count + start_reg - 4;\r\nif ((start_reg < PACKET3_SET_CONTEXT_REG_OFFSET) ||\r\n(start_reg >= PACKET3_SET_CONTEXT_REG_END) ||\r\n(end_reg >= PACKET3_SET_CONTEXT_REG_END)) {\r\nDRM_ERROR("bad PACKET3_SET_CONTEXT_REG\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < pkt->count; i++) {\r\nreg = start_reg + (4 * i);\r\nr = r600_cs_check_reg(p, reg, idx+1+i);\r\nif (r)\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_SET_RESOURCE:\r\nif (pkt->count % 7) {\r\nDRM_ERROR("bad SET_RESOURCE\n");\r\nreturn -EINVAL;\r\n}\r\nstart_reg = (idx_value << 2) + PACKET3_SET_RESOURCE_OFFSET;\r\nend_reg = 4 * pkt->count + start_reg - 4;\r\nif ((start_reg < PACKET3_SET_RESOURCE_OFFSET) ||\r\n(start_reg >= PACKET3_SET_RESOURCE_END) ||\r\n(end_reg >= PACKET3_SET_RESOURCE_END)) {\r\nDRM_ERROR("bad SET_RESOURCE\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < (pkt->count / 7); i++) {\r\nstruct radeon_bo *texture, *mipmap;\r\nu32 size, offset, base_offset, mip_offset;\r\nswitch (G__SQ_VTX_CONSTANT_TYPE(radeon_get_ib_value(p, idx+(i*7)+6+1))) {\r\ncase SQ_TEX_VTX_VALID_TEXTURE:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\nDRM_ERROR("bad SET_RESOURCE\n");\r\nreturn -EINVAL;\r\n}\r\nbase_offset = (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);\r\nif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\r\nif (reloc->lobj.tiling_flags & RADEON_TILING_MACRO)\r\nib[idx+1+(i*7)+0] |= S_038000_TILE_MODE(V_038000_ARRAY_2D_TILED_THIN1);\r\nelse if (reloc->lobj.tiling_flags & RADEON_TILING_MICRO)\r\nib[idx+1+(i*7)+0] |= S_038000_TILE_MODE(V_038000_ARRAY_1D_TILED_THIN1);\r\n}\r\ntexture = reloc->robj;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\nDRM_ERROR("bad SET_RESOURCE\n");\r\nreturn -EINVAL;\r\n}\r\nmip_offset = (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);\r\nmipmap = reloc->robj;\r\nr = r600_check_texture_resource(p, idx+(i*7)+1,\r\ntexture, mipmap,\r\nbase_offset + radeon_get_ib_value(p, idx+1+(i*7)+2),\r\nmip_offset + radeon_get_ib_value(p, idx+1+(i*7)+3),\r\nreloc->lobj.tiling_flags);\r\nif (r)\r\nreturn r;\r\nib[idx+1+(i*7)+2] += base_offset;\r\nib[idx+1+(i*7)+3] += mip_offset;\r\nbreak;\r\ncase SQ_TEX_VTX_VALID_BUFFER:\r\n{\r\nuint64_t offset64;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\nDRM_ERROR("bad SET_RESOURCE\n");\r\nreturn -EINVAL;\r\n}\r\noffset = radeon_get_ib_value(p, idx+1+(i*7)+0);\r\nsize = radeon_get_ib_value(p, idx+1+(i*7)+1) + 1;\r\nif (p->rdev && (size + offset) > radeon_bo_size(reloc->robj)) {\r\ndev_warn(p->dev, "vbo resource seems too big (%d) for the bo (%ld)\n",\r\nsize + offset, radeon_bo_size(reloc->robj));\r\nib[idx+1+(i*7)+1] = radeon_bo_size(reloc->robj) - offset;\r\n}\r\noffset64 = reloc->lobj.gpu_offset + offset;\r\nib[idx+1+(i*8)+0] = offset64;\r\nib[idx+1+(i*8)+2] = (ib[idx+1+(i*8)+2] & 0xffffff00) |\r\n(upper_32_bits(offset64) & 0xff);\r\nbreak;\r\n}\r\ncase SQ_TEX_VTX_INVALID_TEXTURE:\r\ncase SQ_TEX_VTX_INVALID_BUFFER:\r\ndefault:\r\nDRM_ERROR("bad SET_RESOURCE\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nbreak;\r\ncase PACKET3_SET_ALU_CONST:\r\nif (track->sq_config & DX9_CONSTS) {\r\nstart_reg = (idx_value << 2) + PACKET3_SET_ALU_CONST_OFFSET;\r\nend_reg = 4 * pkt->count + start_reg - 4;\r\nif ((start_reg < PACKET3_SET_ALU_CONST_OFFSET) ||\r\n(start_reg >= PACKET3_SET_ALU_CONST_END) ||\r\n(end_reg >= PACKET3_SET_ALU_CONST_END)) {\r\nDRM_ERROR("bad SET_ALU_CONST\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nbreak;\r\ncase PACKET3_SET_BOOL_CONST:\r\nstart_reg = (idx_value << 2) + PACKET3_SET_BOOL_CONST_OFFSET;\r\nend_reg = 4 * pkt->count + start_reg - 4;\r\nif ((start_reg < PACKET3_SET_BOOL_CONST_OFFSET) ||\r\n(start_reg >= PACKET3_SET_BOOL_CONST_END) ||\r\n(end_reg >= PACKET3_SET_BOOL_CONST_END)) {\r\nDRM_ERROR("bad SET_BOOL_CONST\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_SET_LOOP_CONST:\r\nstart_reg = (idx_value << 2) + PACKET3_SET_LOOP_CONST_OFFSET;\r\nend_reg = 4 * pkt->count + start_reg - 4;\r\nif ((start_reg < PACKET3_SET_LOOP_CONST_OFFSET) ||\r\n(start_reg >= PACKET3_SET_LOOP_CONST_END) ||\r\n(end_reg >= PACKET3_SET_LOOP_CONST_END)) {\r\nDRM_ERROR("bad SET_LOOP_CONST\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_SET_CTL_CONST:\r\nstart_reg = (idx_value << 2) + PACKET3_SET_CTL_CONST_OFFSET;\r\nend_reg = 4 * pkt->count + start_reg - 4;\r\nif ((start_reg < PACKET3_SET_CTL_CONST_OFFSET) ||\r\n(start_reg >= PACKET3_SET_CTL_CONST_END) ||\r\n(end_reg >= PACKET3_SET_CTL_CONST_END)) {\r\nDRM_ERROR("bad SET_CTL_CONST\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_SET_SAMPLER:\r\nif (pkt->count % 3) {\r\nDRM_ERROR("bad SET_SAMPLER\n");\r\nreturn -EINVAL;\r\n}\r\nstart_reg = (idx_value << 2) + PACKET3_SET_SAMPLER_OFFSET;\r\nend_reg = 4 * pkt->count + start_reg - 4;\r\nif ((start_reg < PACKET3_SET_SAMPLER_OFFSET) ||\r\n(start_reg >= PACKET3_SET_SAMPLER_END) ||\r\n(end_reg >= PACKET3_SET_SAMPLER_END)) {\r\nDRM_ERROR("bad SET_SAMPLER\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_STRMOUT_BASE_UPDATE:\r\nif (p->family < CHIP_RS780) {\r\nDRM_ERROR("STRMOUT_BASE_UPDATE only supported on 7xx\n");\r\nreturn -EINVAL;\r\n}\r\nif (pkt->count != 1) {\r\nDRM_ERROR("bad STRMOUT_BASE_UPDATE packet count\n");\r\nreturn -EINVAL;\r\n}\r\nif (idx_value > 3) {\r\nDRM_ERROR("bad STRMOUT_BASE_UPDATE index\n");\r\nreturn -EINVAL;\r\n}\r\n{\r\nu64 offset;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\nDRM_ERROR("bad STRMOUT_BASE_UPDATE reloc\n");\r\nreturn -EINVAL;\r\n}\r\nif (reloc->robj != track->vgt_strmout_bo[idx_value]) {\r\nDRM_ERROR("bad STRMOUT_BASE_UPDATE, bo does not match\n");\r\nreturn -EINVAL;\r\n}\r\noffset = radeon_get_ib_value(p, idx+1) << 8;\r\nif (offset != track->vgt_strmout_bo_offset[idx_value]) {\r\nDRM_ERROR("bad STRMOUT_BASE_UPDATE, bo offset does not match: 0x%llx, 0x%x\n",\r\noffset, track->vgt_strmout_bo_offset[idx_value]);\r\nreturn -EINVAL;\r\n}\r\nif ((offset + 4) > radeon_bo_size(reloc->robj)) {\r\nDRM_ERROR("bad STRMOUT_BASE_UPDATE bo too small: 0x%llx, 0x%lx\n",\r\noffset + 4, radeon_bo_size(reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nib[idx+1] += (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);\r\n}\r\nbreak;\r\ncase PACKET3_SURFACE_BASE_UPDATE:\r\nif (p->family >= CHIP_RV770 || p->family == CHIP_R600) {\r\nDRM_ERROR("bad SURFACE_BASE_UPDATE\n");\r\nreturn -EINVAL;\r\n}\r\nif (pkt->count) {\r\nDRM_ERROR("bad SURFACE_BASE_UPDATE\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_STRMOUT_BUFFER_UPDATE:\r\nif (pkt->count != 4) {\r\nDRM_ERROR("bad STRMOUT_BUFFER_UPDATE (invalid count)\n");\r\nreturn -EINVAL;\r\n}\r\nif (idx_value & 0x1) {\r\nu64 offset;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\nDRM_ERROR("bad STRMOUT_BUFFER_UPDATE (missing dst reloc)\n");\r\nreturn -EINVAL;\r\n}\r\noffset = radeon_get_ib_value(p, idx+1);\r\noffset += ((u64)(radeon_get_ib_value(p, idx+2) & 0xff)) << 32;\r\nif ((offset + 4) > radeon_bo_size(reloc->robj)) {\r\nDRM_ERROR("bad STRMOUT_BUFFER_UPDATE dst bo too small: 0x%llx, 0x%lx\n",\r\noffset + 4, radeon_bo_size(reloc->robj));\r\nreturn -EINVAL;\r\n}\r\noffset += reloc->lobj.gpu_offset;\r\nib[idx+1] = offset;\r\nib[idx+2] = upper_32_bits(offset) & 0xff;\r\n}\r\nif (((idx_value >> 1) & 0x3) == 2) {\r\nu64 offset;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\nDRM_ERROR("bad STRMOUT_BUFFER_UPDATE (missing src reloc)\n");\r\nreturn -EINVAL;\r\n}\r\noffset = radeon_get_ib_value(p, idx+3);\r\noffset += ((u64)(radeon_get_ib_value(p, idx+4) & 0xff)) << 32;\r\nif ((offset + 4) > radeon_bo_size(reloc->robj)) {\r\nDRM_ERROR("bad STRMOUT_BUFFER_UPDATE src bo too small: 0x%llx, 0x%lx\n",\r\noffset + 4, radeon_bo_size(reloc->robj));\r\nreturn -EINVAL;\r\n}\r\noffset += reloc->lobj.gpu_offset;\r\nib[idx+3] = offset;\r\nib[idx+4] = upper_32_bits(offset) & 0xff;\r\n}\r\nbreak;\r\ncase PACKET3_MEM_WRITE:\r\n{\r\nu64 offset;\r\nif (pkt->count != 3) {\r\nDRM_ERROR("bad MEM_WRITE (invalid count)\n");\r\nreturn -EINVAL;\r\n}\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\nDRM_ERROR("bad MEM_WRITE (missing reloc)\n");\r\nreturn -EINVAL;\r\n}\r\noffset = radeon_get_ib_value(p, idx+0);\r\noffset += ((u64)(radeon_get_ib_value(p, idx+1) & 0xff)) << 32UL;\r\nif (offset & 0x7) {\r\nDRM_ERROR("bad MEM_WRITE (address not qwords aligned)\n");\r\nreturn -EINVAL;\r\n}\r\nif ((offset + 8) > radeon_bo_size(reloc->robj)) {\r\nDRM_ERROR("bad MEM_WRITE bo too small: 0x%llx, 0x%lx\n",\r\noffset + 8, radeon_bo_size(reloc->robj));\r\nreturn -EINVAL;\r\n}\r\noffset += reloc->lobj.gpu_offset;\r\nib[idx+0] = offset;\r\nib[idx+1] = upper_32_bits(offset) & 0xff;\r\nbreak;\r\n}\r\ncase PACKET3_COPY_DW:\r\nif (pkt->count != 4) {\r\nDRM_ERROR("bad COPY_DW (invalid count)\n");\r\nreturn -EINVAL;\r\n}\r\nif (idx_value & 0x1) {\r\nu64 offset;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\nDRM_ERROR("bad COPY_DW (missing src reloc)\n");\r\nreturn -EINVAL;\r\n}\r\noffset = radeon_get_ib_value(p, idx+1);\r\noffset += ((u64)(radeon_get_ib_value(p, idx+2) & 0xff)) << 32;\r\nif ((offset + 4) > radeon_bo_size(reloc->robj)) {\r\nDRM_ERROR("bad COPY_DW src bo too small: 0x%llx, 0x%lx\n",\r\noffset + 4, radeon_bo_size(reloc->robj));\r\nreturn -EINVAL;\r\n}\r\noffset += reloc->lobj.gpu_offset;\r\nib[idx+1] = offset;\r\nib[idx+2] = upper_32_bits(offset) & 0xff;\r\n} else {\r\nreg = radeon_get_ib_value(p, idx+1) << 2;\r\nif (!r600_is_safe_reg(p, reg, idx+1))\r\nreturn -EINVAL;\r\n}\r\nif (idx_value & 0x2) {\r\nu64 offset;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\r\nif (r) {\r\nDRM_ERROR("bad COPY_DW (missing dst reloc)\n");\r\nreturn -EINVAL;\r\n}\r\noffset = radeon_get_ib_value(p, idx+3);\r\noffset += ((u64)(radeon_get_ib_value(p, idx+4) & 0xff)) << 32;\r\nif ((offset + 4) > radeon_bo_size(reloc->robj)) {\r\nDRM_ERROR("bad COPY_DW dst bo too small: 0x%llx, 0x%lx\n",\r\noffset + 4, radeon_bo_size(reloc->robj));\r\nreturn -EINVAL;\r\n}\r\noffset += reloc->lobj.gpu_offset;\r\nib[idx+3] = offset;\r\nib[idx+4] = upper_32_bits(offset) & 0xff;\r\n} else {\r\nreg = radeon_get_ib_value(p, idx+3) << 2;\r\nif (!r600_is_safe_reg(p, reg, idx+3))\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_NOP:\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Packet3 opcode %x not supported\n", pkt->opcode);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint r600_cs_parse(struct radeon_cs_parser *p)\r\n{\r\nstruct radeon_cs_packet pkt;\r\nstruct r600_cs_track *track;\r\nint r;\r\nif (p->track == NULL) {\r\ntrack = kzalloc(sizeof(*track), GFP_KERNEL);\r\nif (track == NULL)\r\nreturn -ENOMEM;\r\nr600_cs_track_init(track);\r\nif (p->rdev->family < CHIP_RV770) {\r\ntrack->npipes = p->rdev->config.r600.tiling_npipes;\r\ntrack->nbanks = p->rdev->config.r600.tiling_nbanks;\r\ntrack->group_size = p->rdev->config.r600.tiling_group_size;\r\n} else if (p->rdev->family <= CHIP_RV740) {\r\ntrack->npipes = p->rdev->config.rv770.tiling_npipes;\r\ntrack->nbanks = p->rdev->config.rv770.tiling_nbanks;\r\ntrack->group_size = p->rdev->config.rv770.tiling_group_size;\r\n}\r\np->track = track;\r\n}\r\ndo {\r\nr = radeon_cs_packet_parse(p, &pkt, p->idx);\r\nif (r) {\r\nkfree(p->track);\r\np->track = NULL;\r\nreturn r;\r\n}\r\np->idx += pkt.count + 2;\r\nswitch (pkt.type) {\r\ncase RADEON_PACKET_TYPE0:\r\nr = r600_cs_parse_packet0(p, &pkt);\r\nbreak;\r\ncase RADEON_PACKET_TYPE2:\r\nbreak;\r\ncase RADEON_PACKET_TYPE3:\r\nr = r600_packet3_check(p, &pkt);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown packet type %d !\n", pkt.type);\r\nkfree(p->track);\r\np->track = NULL;\r\nreturn -EINVAL;\r\n}\r\nif (r) {\r\nkfree(p->track);\r\np->track = NULL;\r\nreturn r;\r\n}\r\n} while (p->idx < p->chunks[p->chunk_ib_idx].length_dw);\r\n#if 0\r\nfor (r = 0; r < p->ib.length_dw; r++) {\r\nprintk(KERN_INFO "%05d 0x%08X\n", r, p->ib.ptr[r]);\r\nmdelay(1);\r\n}\r\n#endif\r\nkfree(p->track);\r\np->track = NULL;\r\nreturn 0;\r\n}\r\nstatic void r600_cs_parser_fini(struct radeon_cs_parser *parser, int error)\r\n{\r\nunsigned i;\r\nkfree(parser->relocs);\r\nfor (i = 0; i < parser->nchunks; i++) {\r\nkfree(parser->chunks[i].kdata);\r\nif (parser->rdev && (parser->rdev->flags & RADEON_IS_AGP)) {\r\nkfree(parser->chunks[i].kpage[0]);\r\nkfree(parser->chunks[i].kpage[1]);\r\n}\r\n}\r\nkfree(parser->chunks);\r\nkfree(parser->chunks_array);\r\n}\r\nstatic int r600_cs_parser_relocs_legacy(struct radeon_cs_parser *p)\r\n{\r\nif (p->chunk_relocs_idx == -1) {\r\nreturn 0;\r\n}\r\np->relocs = kzalloc(sizeof(struct radeon_cs_reloc), GFP_KERNEL);\r\nif (p->relocs == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nint r600_cs_legacy(struct drm_device *dev, void *data, struct drm_file *filp,\r\nunsigned family, u32 *ib, int *l)\r\n{\r\nstruct radeon_cs_parser parser;\r\nstruct radeon_cs_chunk *ib_chunk;\r\nstruct r600_cs_track *track;\r\nint r;\r\ntrack = kzalloc(sizeof(*track), GFP_KERNEL);\r\nif (track == NULL)\r\nreturn -ENOMEM;\r\nr600_cs_track_init(track);\r\nr600_cs_legacy_get_tiling_conf(dev, &track->npipes, &track->nbanks, &track->group_size);\r\nmemset(&parser, 0, sizeof(struct radeon_cs_parser));\r\nparser.filp = filp;\r\nparser.dev = &dev->pdev->dev;\r\nparser.rdev = NULL;\r\nparser.family = family;\r\nparser.track = track;\r\nparser.ib.ptr = ib;\r\nr = radeon_cs_parser_init(&parser, data);\r\nif (r) {\r\nDRM_ERROR("Failed to initialize parser !\n");\r\nr600_cs_parser_fini(&parser, r);\r\nreturn r;\r\n}\r\nr = r600_cs_parser_relocs_legacy(&parser);\r\nif (r) {\r\nDRM_ERROR("Failed to parse relocation !\n");\r\nr600_cs_parser_fini(&parser, r);\r\nreturn r;\r\n}\r\nib_chunk = &parser.chunks[parser.chunk_ib_idx];\r\nparser.ib.length_dw = ib_chunk->length_dw;\r\n*l = parser.ib.length_dw;\r\nr = r600_cs_parse(&parser);\r\nif (r) {\r\nDRM_ERROR("Invalid command stream !\n");\r\nr600_cs_parser_fini(&parser, r);\r\nreturn r;\r\n}\r\nr = radeon_cs_finish_pages(&parser);\r\nif (r) {\r\nDRM_ERROR("Invalid command stream !\n");\r\nr600_cs_parser_fini(&parser, r);\r\nreturn r;\r\n}\r\nr600_cs_parser_fini(&parser, r);\r\nreturn r;\r\n}\r\nvoid r600_cs_legacy_init(void)\r\n{\r\nr600_nomm = 1;\r\n}\r\nint r600_dma_cs_next_reloc(struct radeon_cs_parser *p,\r\nstruct radeon_cs_reloc **cs_reloc)\r\n{\r\nstruct radeon_cs_chunk *relocs_chunk;\r\nunsigned idx;\r\n*cs_reloc = NULL;\r\nif (p->chunk_relocs_idx == -1) {\r\nDRM_ERROR("No relocation chunk !\n");\r\nreturn -EINVAL;\r\n}\r\nrelocs_chunk = &p->chunks[p->chunk_relocs_idx];\r\nidx = p->dma_reloc_idx;\r\nif (idx >= p->nrelocs) {\r\nDRM_ERROR("Relocs at %d after relocations chunk end %d !\n",\r\nidx, p->nrelocs);\r\nreturn -EINVAL;\r\n}\r\n*cs_reloc = p->relocs_ptr[idx];\r\np->dma_reloc_idx++;\r\nreturn 0;\r\n}\r\nint r600_dma_cs_parse(struct radeon_cs_parser *p)\r\n{\r\nstruct radeon_cs_chunk *ib_chunk = &p->chunks[p->chunk_ib_idx];\r\nstruct radeon_cs_reloc *src_reloc, *dst_reloc;\r\nu32 header, cmd, count, tiled;\r\nvolatile u32 *ib = p->ib.ptr;\r\nu32 idx, idx_value;\r\nu64 src_offset, dst_offset;\r\nint r;\r\ndo {\r\nif (p->idx >= ib_chunk->length_dw) {\r\nDRM_ERROR("Can not parse packet at %d after CS end %d !\n",\r\np->idx, ib_chunk->length_dw);\r\nreturn -EINVAL;\r\n}\r\nidx = p->idx;\r\nheader = radeon_get_ib_value(p, idx);\r\ncmd = GET_DMA_CMD(header);\r\ncount = GET_DMA_COUNT(header);\r\ntiled = GET_DMA_T(header);\r\nswitch (cmd) {\r\ncase DMA_PACKET_WRITE:\r\nr = r600_dma_cs_next_reloc(p, &dst_reloc);\r\nif (r) {\r\nDRM_ERROR("bad DMA_PACKET_WRITE\n");\r\nreturn -EINVAL;\r\n}\r\nif (tiled) {\r\ndst_offset = radeon_get_ib_value(p, idx+1);\r\ndst_offset <<= 8;\r\nib[idx+1] += (u32)(dst_reloc->lobj.gpu_offset >> 8);\r\np->idx += count + 5;\r\n} else {\r\ndst_offset = radeon_get_ib_value(p, idx+1);\r\ndst_offset |= ((u64)(radeon_get_ib_value(p, idx+2) & 0xff)) << 32;\r\nib[idx+1] += (u32)(dst_reloc->lobj.gpu_offset & 0xfffffffc);\r\nib[idx+2] += upper_32_bits(dst_reloc->lobj.gpu_offset) & 0xff;\r\np->idx += count + 3;\r\n}\r\nif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\r\ndev_warn(p->dev, "DMA write buffer too small (%llu %lu)\n",\r\ndst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase DMA_PACKET_COPY:\r\nr = r600_dma_cs_next_reloc(p, &src_reloc);\r\nif (r) {\r\nDRM_ERROR("bad DMA_PACKET_COPY\n");\r\nreturn -EINVAL;\r\n}\r\nr = r600_dma_cs_next_reloc(p, &dst_reloc);\r\nif (r) {\r\nDRM_ERROR("bad DMA_PACKET_COPY\n");\r\nreturn -EINVAL;\r\n}\r\nif (tiled) {\r\nidx_value = radeon_get_ib_value(p, idx + 2);\r\nif (idx_value & (1 << 31)) {\r\nsrc_offset = radeon_get_ib_value(p, idx+1);\r\nsrc_offset <<= 8;\r\nib[idx+1] += (u32)(src_reloc->lobj.gpu_offset >> 8);\r\ndst_offset = radeon_get_ib_value(p, idx+5);\r\ndst_offset |= ((u64)(radeon_get_ib_value(p, idx+6) & 0xff)) << 32;\r\nib[idx+5] += (u32)(dst_reloc->lobj.gpu_offset & 0xfffffffc);\r\nib[idx+6] += upper_32_bits(dst_reloc->lobj.gpu_offset) & 0xff;\r\n} else {\r\nsrc_offset = radeon_get_ib_value(p, idx+5);\r\nsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+6) & 0xff)) << 32;\r\nib[idx+5] += (u32)(src_reloc->lobj.gpu_offset & 0xfffffffc);\r\nib[idx+6] += upper_32_bits(src_reloc->lobj.gpu_offset) & 0xff;\r\ndst_offset = radeon_get_ib_value(p, idx+1);\r\ndst_offset <<= 8;\r\nib[idx+1] += (u32)(dst_reloc->lobj.gpu_offset >> 8);\r\n}\r\np->idx += 7;\r\n} else {\r\nif (p->family >= CHIP_RV770) {\r\nsrc_offset = radeon_get_ib_value(p, idx+2);\r\nsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+4) & 0xff)) << 32;\r\ndst_offset = radeon_get_ib_value(p, idx+1);\r\ndst_offset |= ((u64)(radeon_get_ib_value(p, idx+3) & 0xff)) << 32;\r\nib[idx+1] += (u32)(dst_reloc->lobj.gpu_offset & 0xfffffffc);\r\nib[idx+2] += (u32)(src_reloc->lobj.gpu_offset & 0xfffffffc);\r\nib[idx+3] += upper_32_bits(dst_reloc->lobj.gpu_offset) & 0xff;\r\nib[idx+4] += upper_32_bits(src_reloc->lobj.gpu_offset) & 0xff;\r\np->idx += 5;\r\n} else {\r\nsrc_offset = radeon_get_ib_value(p, idx+2);\r\nsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+3) & 0xff)) << 32;\r\ndst_offset = radeon_get_ib_value(p, idx+1);\r\ndst_offset |= ((u64)(radeon_get_ib_value(p, idx+3) & 0xff0000)) << 16;\r\nib[idx+1] += (u32)(dst_reloc->lobj.gpu_offset & 0xfffffffc);\r\nib[idx+2] += (u32)(src_reloc->lobj.gpu_offset & 0xfffffffc);\r\nib[idx+3] += upper_32_bits(src_reloc->lobj.gpu_offset) & 0xff;\r\nib[idx+3] += (upper_32_bits(dst_reloc->lobj.gpu_offset) & 0xff) << 16;\r\np->idx += 4;\r\n}\r\n}\r\nif ((src_offset + (count * 4)) > radeon_bo_size(src_reloc->robj)) {\r\ndev_warn(p->dev, "DMA copy src buffer too small (%llu %lu)\n",\r\nsrc_offset + (count * 4), radeon_bo_size(src_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\r\ndev_warn(p->dev, "DMA write dst buffer too small (%llu %lu)\n",\r\ndst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase DMA_PACKET_CONSTANT_FILL:\r\nif (p->family < CHIP_RV770) {\r\nDRM_ERROR("Constant Fill is 7xx only !\n");\r\nreturn -EINVAL;\r\n}\r\nr = r600_dma_cs_next_reloc(p, &dst_reloc);\r\nif (r) {\r\nDRM_ERROR("bad DMA_PACKET_WRITE\n");\r\nreturn -EINVAL;\r\n}\r\ndst_offset = radeon_get_ib_value(p, idx+1);\r\ndst_offset |= ((u64)(radeon_get_ib_value(p, idx+3) & 0x00ff0000)) << 16;\r\nif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\r\ndev_warn(p->dev, "DMA constant fill buffer too small (%llu %lu)\n",\r\ndst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nib[idx+1] += (u32)(dst_reloc->lobj.gpu_offset & 0xfffffffc);\r\nib[idx+3] += (upper_32_bits(dst_reloc->lobj.gpu_offset) << 16) & 0x00ff0000;\r\np->idx += 4;\r\nbreak;\r\ncase DMA_PACKET_NOP:\r\np->idx += 1;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown packet type %d at %d !\n", cmd, idx);\r\nreturn -EINVAL;\r\n}\r\n} while (p->idx < p->chunks[p->chunk_ib_idx].length_dw);\r\n#if 0\r\nfor (r = 0; r < p->ib->length_dw; r++) {\r\nprintk(KERN_INFO "%05d 0x%08X\n", r, p->ib.ptr[r]);\r\nmdelay(1);\r\n}\r\n#endif\r\nreturn 0;\r\n}
