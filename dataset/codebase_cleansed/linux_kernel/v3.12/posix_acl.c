void\r\nposix_acl_init(struct posix_acl *acl, int count)\r\n{\r\natomic_set(&acl->a_refcount, 1);\r\nacl->a_count = count;\r\n}\r\nstruct posix_acl *\r\nposix_acl_alloc(int count, gfp_t flags)\r\n{\r\nconst size_t size = sizeof(struct posix_acl) +\r\ncount * sizeof(struct posix_acl_entry);\r\nstruct posix_acl *acl = kmalloc(size, flags);\r\nif (acl)\r\nposix_acl_init(acl, count);\r\nreturn acl;\r\n}\r\nstatic struct posix_acl *\r\nposix_acl_clone(const struct posix_acl *acl, gfp_t flags)\r\n{\r\nstruct posix_acl *clone = NULL;\r\nif (acl) {\r\nint size = sizeof(struct posix_acl) + acl->a_count *\r\nsizeof(struct posix_acl_entry);\r\nclone = kmemdup(acl, size, flags);\r\nif (clone)\r\natomic_set(&clone->a_refcount, 1);\r\n}\r\nreturn clone;\r\n}\r\nint\r\nposix_acl_valid(const struct posix_acl *acl)\r\n{\r\nconst struct posix_acl_entry *pa, *pe;\r\nint state = ACL_USER_OBJ;\r\nkuid_t prev_uid = INVALID_UID;\r\nkgid_t prev_gid = INVALID_GID;\r\nint needs_mask = 0;\r\nFOREACH_ACL_ENTRY(pa, acl, pe) {\r\nif (pa->e_perm & ~(ACL_READ|ACL_WRITE|ACL_EXECUTE))\r\nreturn -EINVAL;\r\nswitch (pa->e_tag) {\r\ncase ACL_USER_OBJ:\r\nif (state == ACL_USER_OBJ) {\r\nstate = ACL_USER;\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\ncase ACL_USER:\r\nif (state != ACL_USER)\r\nreturn -EINVAL;\r\nif (!uid_valid(pa->e_uid))\r\nreturn -EINVAL;\r\nif (uid_valid(prev_uid) &&\r\nuid_lte(pa->e_uid, prev_uid))\r\nreturn -EINVAL;\r\nprev_uid = pa->e_uid;\r\nneeds_mask = 1;\r\nbreak;\r\ncase ACL_GROUP_OBJ:\r\nif (state == ACL_USER) {\r\nstate = ACL_GROUP;\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\ncase ACL_GROUP:\r\nif (state != ACL_GROUP)\r\nreturn -EINVAL;\r\nif (!gid_valid(pa->e_gid))\r\nreturn -EINVAL;\r\nif (gid_valid(prev_gid) &&\r\ngid_lte(pa->e_gid, prev_gid))\r\nreturn -EINVAL;\r\nprev_gid = pa->e_gid;\r\nneeds_mask = 1;\r\nbreak;\r\ncase ACL_MASK:\r\nif (state != ACL_GROUP)\r\nreturn -EINVAL;\r\nstate = ACL_OTHER;\r\nbreak;\r\ncase ACL_OTHER:\r\nif (state == ACL_OTHER ||\r\n(state == ACL_GROUP && !needs_mask)) {\r\nstate = 0;\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (state == 0)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nint\r\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\r\n{\r\nconst struct posix_acl_entry *pa, *pe;\r\numode_t mode = 0;\r\nint not_equiv = 0;\r\nFOREACH_ACL_ENTRY(pa, acl, pe) {\r\nswitch (pa->e_tag) {\r\ncase ACL_USER_OBJ:\r\nmode |= (pa->e_perm & S_IRWXO) << 6;\r\nbreak;\r\ncase ACL_GROUP_OBJ:\r\nmode |= (pa->e_perm & S_IRWXO) << 3;\r\nbreak;\r\ncase ACL_OTHER:\r\nmode |= pa->e_perm & S_IRWXO;\r\nbreak;\r\ncase ACL_MASK:\r\nmode = (mode & ~S_IRWXG) |\r\n((pa->e_perm & S_IRWXO) << 3);\r\nnot_equiv = 1;\r\nbreak;\r\ncase ACL_USER:\r\ncase ACL_GROUP:\r\nnot_equiv = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (mode_p)\r\n*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\r\nreturn not_equiv;\r\n}\r\nstruct posix_acl *\r\nposix_acl_from_mode(umode_t mode, gfp_t flags)\r\n{\r\nstruct posix_acl *acl = posix_acl_alloc(3, flags);\r\nif (!acl)\r\nreturn ERR_PTR(-ENOMEM);\r\nacl->a_entries[0].e_tag = ACL_USER_OBJ;\r\nacl->a_entries[0].e_perm = (mode & S_IRWXU) >> 6;\r\nacl->a_entries[1].e_tag = ACL_GROUP_OBJ;\r\nacl->a_entries[1].e_perm = (mode & S_IRWXG) >> 3;\r\nacl->a_entries[2].e_tag = ACL_OTHER;\r\nacl->a_entries[2].e_perm = (mode & S_IRWXO);\r\nreturn acl;\r\n}\r\nint\r\nposix_acl_permission(struct inode *inode, const struct posix_acl *acl, int want)\r\n{\r\nconst struct posix_acl_entry *pa, *pe, *mask_obj;\r\nint found = 0;\r\nwant &= MAY_READ | MAY_WRITE | MAY_EXEC | MAY_NOT_BLOCK;\r\nFOREACH_ACL_ENTRY(pa, acl, pe) {\r\nswitch(pa->e_tag) {\r\ncase ACL_USER_OBJ:\r\nif (uid_eq(inode->i_uid, current_fsuid()))\r\ngoto check_perm;\r\nbreak;\r\ncase ACL_USER:\r\nif (uid_eq(pa->e_uid, current_fsuid()))\r\ngoto mask;\r\nbreak;\r\ncase ACL_GROUP_OBJ:\r\nif (in_group_p(inode->i_gid)) {\r\nfound = 1;\r\nif ((pa->e_perm & want) == want)\r\ngoto mask;\r\n}\r\nbreak;\r\ncase ACL_GROUP:\r\nif (in_group_p(pa->e_gid)) {\r\nfound = 1;\r\nif ((pa->e_perm & want) == want)\r\ngoto mask;\r\n}\r\nbreak;\r\ncase ACL_MASK:\r\nbreak;\r\ncase ACL_OTHER:\r\nif (found)\r\nreturn -EACCES;\r\nelse\r\ngoto check_perm;\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nreturn -EIO;\r\nmask:\r\nfor (mask_obj = pa+1; mask_obj != pe; mask_obj++) {\r\nif (mask_obj->e_tag == ACL_MASK) {\r\nif ((pa->e_perm & mask_obj->e_perm & want) == want)\r\nreturn 0;\r\nreturn -EACCES;\r\n}\r\n}\r\ncheck_perm:\r\nif ((pa->e_perm & want) == want)\r\nreturn 0;\r\nreturn -EACCES;\r\n}\r\nstatic int posix_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\r\n{\r\nstruct posix_acl_entry *pa, *pe;\r\nstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\r\numode_t mode = *mode_p;\r\nint not_equiv = 0;\r\nFOREACH_ACL_ENTRY(pa, acl, pe) {\r\nswitch(pa->e_tag) {\r\ncase ACL_USER_OBJ:\r\npa->e_perm &= (mode >> 6) | ~S_IRWXO;\r\nmode &= (pa->e_perm << 6) | ~S_IRWXU;\r\nbreak;\r\ncase ACL_USER:\r\ncase ACL_GROUP:\r\nnot_equiv = 1;\r\nbreak;\r\ncase ACL_GROUP_OBJ:\r\ngroup_obj = pa;\r\nbreak;\r\ncase ACL_OTHER:\r\npa->e_perm &= mode | ~S_IRWXO;\r\nmode &= pa->e_perm | ~S_IRWXO;\r\nbreak;\r\ncase ACL_MASK:\r\nmask_obj = pa;\r\nnot_equiv = 1;\r\nbreak;\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nif (mask_obj) {\r\nmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\r\nmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\r\n} else {\r\nif (!group_obj)\r\nreturn -EIO;\r\ngroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\r\nmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\r\n}\r\n*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\r\nreturn not_equiv;\r\n}\r\nstatic int posix_acl_chmod_masq(struct posix_acl *acl, umode_t mode)\r\n{\r\nstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\r\nstruct posix_acl_entry *pa, *pe;\r\nFOREACH_ACL_ENTRY(pa, acl, pe) {\r\nswitch(pa->e_tag) {\r\ncase ACL_USER_OBJ:\r\npa->e_perm = (mode & S_IRWXU) >> 6;\r\nbreak;\r\ncase ACL_USER:\r\ncase ACL_GROUP:\r\nbreak;\r\ncase ACL_GROUP_OBJ:\r\ngroup_obj = pa;\r\nbreak;\r\ncase ACL_MASK:\r\nmask_obj = pa;\r\nbreak;\r\ncase ACL_OTHER:\r\npa->e_perm = (mode & S_IRWXO);\r\nbreak;\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nif (mask_obj) {\r\nmask_obj->e_perm = (mode & S_IRWXG) >> 3;\r\n} else {\r\nif (!group_obj)\r\nreturn -EIO;\r\ngroup_obj->e_perm = (mode & S_IRWXG) >> 3;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nposix_acl_create(struct posix_acl **acl, gfp_t gfp, umode_t *mode_p)\r\n{\r\nstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\r\nint err = -ENOMEM;\r\nif (clone) {\r\nerr = posix_acl_create_masq(clone, mode_p);\r\nif (err < 0) {\r\nposix_acl_release(clone);\r\nclone = NULL;\r\n}\r\n}\r\nposix_acl_release(*acl);\r\n*acl = clone;\r\nreturn err;\r\n}\r\nint\r\nposix_acl_chmod(struct posix_acl **acl, gfp_t gfp, umode_t mode)\r\n{\r\nstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\r\nint err = -ENOMEM;\r\nif (clone) {\r\nerr = posix_acl_chmod_masq(clone, mode);\r\nif (err) {\r\nposix_acl_release(clone);\r\nclone = NULL;\r\n}\r\n}\r\nposix_acl_release(*acl);\r\n*acl = clone;\r\nreturn err;\r\n}
