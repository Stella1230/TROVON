void pm_vt_switch_required(struct device *dev, bool required)\r\n{\r\nstruct pm_vt_switch *entry, *tmp;\r\nmutex_lock(&vt_switch_mutex);\r\nlist_for_each_entry(tmp, &pm_vt_switch_list, head) {\r\nif (tmp->dev == dev) {\r\ntmp->required = required;\r\ngoto out;\r\n}\r\n}\r\nentry = kmalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\ngoto out;\r\nentry->required = required;\r\nentry->dev = dev;\r\nlist_add(&entry->head, &pm_vt_switch_list);\r\nout:\r\nmutex_unlock(&vt_switch_mutex);\r\n}\r\nvoid pm_vt_switch_unregister(struct device *dev)\r\n{\r\nstruct pm_vt_switch *tmp;\r\nmutex_lock(&vt_switch_mutex);\r\nlist_for_each_entry(tmp, &pm_vt_switch_list, head) {\r\nif (tmp->dev == dev) {\r\nlist_del(&tmp->head);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&vt_switch_mutex);\r\n}\r\nstatic bool pm_vt_switch(void)\r\n{\r\nstruct pm_vt_switch *entry;\r\nbool ret = true;\r\nmutex_lock(&vt_switch_mutex);\r\nif (list_empty(&pm_vt_switch_list))\r\ngoto out;\r\nif (!console_suspend_enabled)\r\ngoto out;\r\nlist_for_each_entry(entry, &pm_vt_switch_list, head) {\r\nif (entry->required)\r\ngoto out;\r\n}\r\nret = false;\r\nout:\r\nmutex_unlock(&vt_switch_mutex);\r\nreturn ret;\r\n}\r\nint pm_prepare_console(void)\r\n{\r\nif (!pm_vt_switch())\r\nreturn 0;\r\norig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\r\nif (orig_fgconsole < 0)\r\nreturn 1;\r\norig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\r\nreturn 0;\r\n}\r\nvoid pm_restore_console(void)\r\n{\r\nif (!pm_vt_switch())\r\nreturn;\r\nif (orig_fgconsole >= 0) {\r\nvt_move_to_console(orig_fgconsole, 0);\r\nvt_kmsg_redirect(orig_kmsg);\r\n}\r\n}
