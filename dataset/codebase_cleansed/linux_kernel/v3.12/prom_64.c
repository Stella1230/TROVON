void * __init prom_early_alloc(unsigned long size)\r\n{\r\nunsigned long paddr = memblock_alloc(size, SMP_CACHE_BYTES);\r\nvoid *ret;\r\nif (!paddr) {\r\nprom_printf("prom_early_alloc(%lu) failed\n", size);\r\nprom_halt();\r\n}\r\nret = __va(paddr);\r\nmemset(ret, 0, size);\r\nprom_early_allocated += size;\r\nreturn ret;\r\n}\r\nstatic void __init sun4v_path_component(struct device_node *dp, char *tmp_buf)\r\n{\r\nstruct linux_prom64_registers *regs;\r\nstruct property *rprop;\r\nu32 high_bits, low_bits, type;\r\nrprop = of_find_property(dp, "reg", NULL);\r\nif (!rprop)\r\nreturn;\r\nregs = rprop->value;\r\nif (!of_node_is_root(dp->parent)) {\r\nsprintf(tmp_buf, "%s@%x,%x",\r\ndp->name,\r\n(unsigned int) (regs->phys_addr >> 32UL),\r\n(unsigned int) (regs->phys_addr & 0xffffffffUL));\r\nreturn;\r\n}\r\ntype = regs->phys_addr >> 60UL;\r\nhigh_bits = (regs->phys_addr >> 32UL) & 0x0fffffffUL;\r\nlow_bits = (regs->phys_addr & 0xffffffffUL);\r\nif (type == 0 || type == 8) {\r\nconst char *prefix = (type == 0) ? "m" : "i";\r\nif (low_bits)\r\nsprintf(tmp_buf, "%s@%s%x,%x",\r\ndp->name, prefix,\r\nhigh_bits, low_bits);\r\nelse\r\nsprintf(tmp_buf, "%s@%s%x",\r\ndp->name,\r\nprefix,\r\nhigh_bits);\r\n} else if (type == 12) {\r\nsprintf(tmp_buf, "%s@%x",\r\ndp->name, high_bits);\r\n}\r\n}\r\nstatic void __init sun4u_path_component(struct device_node *dp, char *tmp_buf)\r\n{\r\nstruct linux_prom64_registers *regs;\r\nstruct property *prop;\r\nprop = of_find_property(dp, "reg", NULL);\r\nif (!prop)\r\nreturn;\r\nregs = prop->value;\r\nif (!of_node_is_root(dp->parent)) {\r\nsprintf(tmp_buf, "%s@%x,%x",\r\ndp->name,\r\n(unsigned int) (regs->phys_addr >> 32UL),\r\n(unsigned int) (regs->phys_addr & 0xffffffffUL));\r\nreturn;\r\n}\r\nprop = of_find_property(dp, "upa-portid", NULL);\r\nif (!prop)\r\nprop = of_find_property(dp, "portid", NULL);\r\nif (prop) {\r\nunsigned long mask = 0xffffffffUL;\r\nif (tlb_type >= cheetah)\r\nmask = 0x7fffff;\r\nsprintf(tmp_buf, "%s@%x,%x",\r\ndp->name,\r\n*(u32 *)prop->value,\r\n(unsigned int) (regs->phys_addr & mask));\r\n}\r\n}\r\nstatic void __init sbus_path_component(struct device_node *dp, char *tmp_buf)\r\n{\r\nstruct linux_prom_registers *regs;\r\nstruct property *prop;\r\nprop = of_find_property(dp, "reg", NULL);\r\nif (!prop)\r\nreturn;\r\nregs = prop->value;\r\nsprintf(tmp_buf, "%s@%x,%x",\r\ndp->name,\r\nregs->which_io,\r\nregs->phys_addr);\r\n}\r\nstatic void __init pci_path_component(struct device_node *dp, char *tmp_buf)\r\n{\r\nstruct linux_prom_pci_registers *regs;\r\nstruct property *prop;\r\nunsigned int devfn;\r\nprop = of_find_property(dp, "reg", NULL);\r\nif (!prop)\r\nreturn;\r\nregs = prop->value;\r\ndevfn = (regs->phys_hi >> 8) & 0xff;\r\nif (devfn & 0x07) {\r\nsprintf(tmp_buf, "%s@%x,%x",\r\ndp->name,\r\ndevfn >> 3,\r\ndevfn & 0x07);\r\n} else {\r\nsprintf(tmp_buf, "%s@%x",\r\ndp->name,\r\ndevfn >> 3);\r\n}\r\n}\r\nstatic void __init upa_path_component(struct device_node *dp, char *tmp_buf)\r\n{\r\nstruct linux_prom64_registers *regs;\r\nstruct property *prop;\r\nprop = of_find_property(dp, "reg", NULL);\r\nif (!prop)\r\nreturn;\r\nregs = prop->value;\r\nprop = of_find_property(dp, "upa-portid", NULL);\r\nif (!prop)\r\nreturn;\r\nsprintf(tmp_buf, "%s@%x,%x",\r\ndp->name,\r\n*(u32 *) prop->value,\r\n(unsigned int) (regs->phys_addr & 0xffffffffUL));\r\n}\r\nstatic void __init vdev_path_component(struct device_node *dp, char *tmp_buf)\r\n{\r\nstruct property *prop;\r\nu32 *regs;\r\nprop = of_find_property(dp, "reg", NULL);\r\nif (!prop)\r\nreturn;\r\nregs = prop->value;\r\nsprintf(tmp_buf, "%s@%x", dp->name, *regs);\r\n}\r\nstatic void __init ebus_path_component(struct device_node *dp, char *tmp_buf)\r\n{\r\nstruct linux_prom64_registers *regs;\r\nstruct property *prop;\r\nprop = of_find_property(dp, "reg", NULL);\r\nif (!prop)\r\nreturn;\r\nregs = prop->value;\r\nsprintf(tmp_buf, "%s@%x,%x",\r\ndp->name,\r\n(unsigned int) (regs->phys_addr >> 32UL),\r\n(unsigned int) (regs->phys_addr & 0xffffffffUL));\r\n}\r\nstatic void __init i2c_path_component(struct device_node *dp, char *tmp_buf)\r\n{\r\nstruct property *prop;\r\nu32 *regs;\r\nprop = of_find_property(dp, "reg", NULL);\r\nif (!prop)\r\nreturn;\r\nregs = prop->value;\r\nsprintf(tmp_buf, "%s@%x,%x",\r\ndp->name, regs[0], regs[1]);\r\n}\r\nstatic void __init usb_path_component(struct device_node *dp, char *tmp_buf)\r\n{\r\nstruct property *prop;\r\nu32 *regs;\r\nprop = of_find_property(dp, "reg", NULL);\r\nif (!prop)\r\nreturn;\r\nregs = prop->value;\r\nif (prop->length == sizeof(u32) || regs[1] == 1) {\r\nsprintf(tmp_buf, "%s@%x",\r\ndp->name, regs[0]);\r\n} else {\r\nsprintf(tmp_buf, "%s@%x,%x",\r\ndp->name, regs[0], regs[1]);\r\n}\r\n}\r\nstatic void __init ieee1394_path_component(struct device_node *dp, char *tmp_buf)\r\n{\r\nstruct property *prop;\r\nu32 *regs;\r\nprop = of_find_property(dp, "reg", NULL);\r\nif (!prop)\r\nreturn;\r\nregs = prop->value;\r\nif (regs[2] || regs[3]) {\r\nsprintf(tmp_buf, "%s@%08x%08x,%04x%08x",\r\ndp->name, regs[0], regs[1], regs[2], regs[3]);\r\n} else {\r\nsprintf(tmp_buf, "%s@%08x%08x",\r\ndp->name, regs[0], regs[1]);\r\n}\r\n}\r\nstatic void __init __build_path_component(struct device_node *dp, char *tmp_buf)\r\n{\r\nstruct device_node *parent = dp->parent;\r\nif (parent != NULL) {\r\nif (!strcmp(parent->type, "pci") ||\r\n!strcmp(parent->type, "pciex")) {\r\npci_path_component(dp, tmp_buf);\r\nreturn;\r\n}\r\nif (!strcmp(parent->type, "sbus")) {\r\nsbus_path_component(dp, tmp_buf);\r\nreturn;\r\n}\r\nif (!strcmp(parent->type, "upa")) {\r\nupa_path_component(dp, tmp_buf);\r\nreturn;\r\n}\r\nif (!strcmp(parent->type, "ebus")) {\r\nebus_path_component(dp, tmp_buf);\r\nreturn;\r\n}\r\nif (!strcmp(parent->name, "usb") ||\r\n!strcmp(parent->name, "hub")) {\r\nusb_path_component(dp, tmp_buf);\r\nreturn;\r\n}\r\nif (!strcmp(parent->type, "i2c")) {\r\ni2c_path_component(dp, tmp_buf);\r\nreturn;\r\n}\r\nif (!strcmp(parent->type, "firewire")) {\r\nieee1394_path_component(dp, tmp_buf);\r\nreturn;\r\n}\r\nif (!strcmp(parent->type, "virtual-devices")) {\r\nvdev_path_component(dp, tmp_buf);\r\nreturn;\r\n}\r\n}\r\nif (tlb_type == hypervisor) {\r\nsun4v_path_component(dp, tmp_buf);\r\nreturn;\r\n} else {\r\nsun4u_path_component(dp, tmp_buf);\r\n}\r\n}\r\nchar * __init build_path_component(struct device_node *dp)\r\n{\r\nchar tmp_buf[64], *n;\r\ntmp_buf[0] = '\0';\r\n__build_path_component(dp, tmp_buf);\r\nif (tmp_buf[0] == '\0')\r\nstrcpy(tmp_buf, dp->name);\r\nn = prom_early_alloc(strlen(tmp_buf) + 1);\r\nstrcpy(n, tmp_buf);\r\nreturn n;\r\n}\r\nstatic const char *get_mid_prop(void)\r\n{\r\nreturn (tlb_type == spitfire ? "upa-portid" : "portid");\r\n}\r\nstatic void *of_iterate_over_cpus(void *(*func)(struct device_node *, int, int), int arg)\r\n{\r\nstruct device_node *dp;\r\nconst char *mid_prop;\r\nmid_prop = get_mid_prop();\r\nfor_each_node_by_type(dp, "cpu") {\r\nint cpuid = of_getintprop_default(dp, mid_prop, -1);\r\nconst char *this_mid_prop = mid_prop;\r\nvoid *ret;\r\nif (cpuid < 0) {\r\nthis_mid_prop = "cpuid";\r\ncpuid = of_getintprop_default(dp, this_mid_prop, -1);\r\n}\r\nif (cpuid < 0) {\r\nprom_printf("OF: Serious problem, cpu lacks "\r\n"%s property", this_mid_prop);\r\nprom_halt();\r\n}\r\n#ifdef CONFIG_SMP\r\nif (cpuid >= NR_CPUS) {\r\nprintk(KERN_WARNING "Ignoring CPU %d which is "\r\n">= NR_CPUS (%d)\n",\r\ncpuid, NR_CPUS);\r\ncontinue;\r\n}\r\n#endif\r\nret = func(dp, cpuid, arg);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *check_cpu_node(struct device_node *dp, int cpuid, int id)\r\n{\r\nif (id == cpuid)\r\nreturn dp;\r\nreturn NULL;\r\n}\r\nstruct device_node *of_find_node_by_cpuid(int cpuid)\r\n{\r\nreturn of_iterate_over_cpus(check_cpu_node, cpuid);\r\n}\r\nstatic void *record_one_cpu(struct device_node *dp, int cpuid, int arg)\r\n{\r\nncpus_probed++;\r\n#ifdef CONFIG_SMP\r\nset_cpu_present(cpuid, true);\r\nset_cpu_possible(cpuid, true);\r\n#endif\r\nreturn NULL;\r\n}\r\nvoid __init of_populate_present_mask(void)\r\n{\r\nif (tlb_type == hypervisor)\r\nreturn;\r\nncpus_probed = 0;\r\nof_iterate_over_cpus(record_one_cpu, 0);\r\n}\r\nstatic void *fill_in_one_cpu(struct device_node *dp, int cpuid, int arg)\r\n{\r\nstruct device_node *portid_parent = NULL;\r\nint portid = -1;\r\nif (of_find_property(dp, "cpuid", NULL)) {\r\nint limit = 2;\r\nportid_parent = dp;\r\nwhile (limit--) {\r\nportid_parent = portid_parent->parent;\r\nif (!portid_parent)\r\nbreak;\r\nportid = of_getintprop_default(portid_parent,\r\n"portid", -1);\r\nif (portid >= 0)\r\nbreak;\r\n}\r\n}\r\n#ifndef CONFIG_SMP\r\nif (cpuid != real_hard_smp_processor_id())\r\nreturn NULL;\r\ncpuid = 0;\r\n#endif\r\ncpu_data(cpuid).clock_tick =\r\nof_getintprop_default(dp, "clock-frequency", 0);\r\nif (portid_parent) {\r\ncpu_data(cpuid).dcache_size =\r\nof_getintprop_default(dp, "l1-dcache-size",\r\n16 * 1024);\r\ncpu_data(cpuid).dcache_line_size =\r\nof_getintprop_default(dp, "l1-dcache-line-size",\r\n32);\r\ncpu_data(cpuid).icache_size =\r\nof_getintprop_default(dp, "l1-icache-size",\r\n8 * 1024);\r\ncpu_data(cpuid).icache_line_size =\r\nof_getintprop_default(dp, "l1-icache-line-size",\r\n32);\r\ncpu_data(cpuid).ecache_size =\r\nof_getintprop_default(dp, "l2-cache-size", 0);\r\ncpu_data(cpuid).ecache_line_size =\r\nof_getintprop_default(dp, "l2-cache-line-size", 0);\r\nif (!cpu_data(cpuid).ecache_size ||\r\n!cpu_data(cpuid).ecache_line_size) {\r\ncpu_data(cpuid).ecache_size =\r\nof_getintprop_default(portid_parent,\r\n"l2-cache-size",\r\n(4 * 1024 * 1024));\r\ncpu_data(cpuid).ecache_line_size =\r\nof_getintprop_default(portid_parent,\r\n"l2-cache-line-size", 64);\r\n}\r\ncpu_data(cpuid).core_id = portid + 1;\r\ncpu_data(cpuid).proc_id = portid;\r\n#ifdef CONFIG_SMP\r\nsparc64_multi_core = 1;\r\n#endif\r\n} else {\r\ncpu_data(cpuid).dcache_size =\r\nof_getintprop_default(dp, "dcache-size", 16 * 1024);\r\ncpu_data(cpuid).dcache_line_size =\r\nof_getintprop_default(dp, "dcache-line-size", 32);\r\ncpu_data(cpuid).icache_size =\r\nof_getintprop_default(dp, "icache-size", 16 * 1024);\r\ncpu_data(cpuid).icache_line_size =\r\nof_getintprop_default(dp, "icache-line-size", 32);\r\ncpu_data(cpuid).ecache_size =\r\nof_getintprop_default(dp, "ecache-size",\r\n(4 * 1024 * 1024));\r\ncpu_data(cpuid).ecache_line_size =\r\nof_getintprop_default(dp, "ecache-line-size", 64);\r\ncpu_data(cpuid).core_id = 0;\r\ncpu_data(cpuid).proc_id = -1;\r\n}\r\nreturn NULL;\r\n}\r\nvoid __init of_fill_in_cpu_data(void)\r\n{\r\nif (tlb_type == hypervisor)\r\nreturn;\r\nof_iterate_over_cpus(fill_in_one_cpu, 0);\r\nsmp_fill_in_sib_core_maps();\r\n}\r\nvoid __init of_console_init(void)\r\n{\r\nchar *msg = "OF stdout device is: %s\n";\r\nstruct device_node *dp;\r\nconst char *type;\r\nphandle node;\r\nof_console_path = prom_early_alloc(256);\r\nif (prom_ihandle2path(prom_stdout, of_console_path, 256) < 0) {\r\nprom_printf("Cannot obtain path of stdout.\n");\r\nprom_halt();\r\n}\r\nof_console_options = strrchr(of_console_path, ':');\r\nif (of_console_options) {\r\nof_console_options++;\r\nif (*of_console_options == '\0')\r\nof_console_options = NULL;\r\n}\r\nnode = prom_inst2pkg(prom_stdout);\r\nif (!node) {\r\nprom_printf("Cannot resolve stdout node from "\r\n"instance %08x.\n", prom_stdout);\r\nprom_halt();\r\n}\r\ndp = of_find_node_by_phandle(node);\r\ntype = of_get_property(dp, "device_type", NULL);\r\nif (!type) {\r\nprom_printf("Console stdout lacks device_type property.\n");\r\nprom_halt();\r\n}\r\nif (strcmp(type, "display") && strcmp(type, "serial")) {\r\nprom_printf("Console device_type is neither display "\r\n"nor serial.\n");\r\nprom_halt();\r\n}\r\nof_console_device = dp;\r\nprintk(msg, of_console_path);\r\n}
