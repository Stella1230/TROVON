int qib_eeprom_read(struct qib_devdata *dd, u8 eeprom_offset,\r\nvoid *buff, int len)\r\n{\r\nint ret;\r\nret = mutex_lock_interruptible(&dd->eep_lock);\r\nif (!ret) {\r\nret = qib_twsi_reset(dd);\r\nif (ret)\r\nqib_dev_err(dd, "EEPROM Reset for read failed\n");\r\nelse\r\nret = qib_twsi_blk_rd(dd, dd->twsi_eeprom_dev,\r\neeprom_offset, buff, len);\r\nmutex_unlock(&dd->eep_lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic int eeprom_write_with_enable(struct qib_devdata *dd, u8 offset,\r\nconst void *buf, int len)\r\n{\r\nint ret, pwen;\r\npwen = dd->f_eeprom_wen(dd, 1);\r\nret = qib_twsi_reset(dd);\r\nif (ret)\r\nqib_dev_err(dd, "EEPROM Reset for write failed\n");\r\nelse\r\nret = qib_twsi_blk_wr(dd, dd->twsi_eeprom_dev,\r\noffset, buf, len);\r\ndd->f_eeprom_wen(dd, pwen);\r\nreturn ret;\r\n}\r\nint qib_eeprom_write(struct qib_devdata *dd, u8 eeprom_offset,\r\nconst void *buff, int len)\r\n{\r\nint ret;\r\nret = mutex_lock_interruptible(&dd->eep_lock);\r\nif (!ret) {\r\nret = eeprom_write_with_enable(dd, eeprom_offset, buff, len);\r\nmutex_unlock(&dd->eep_lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic u8 flash_csum(struct qib_flash *ifp, int adjust)\r\n{\r\nu8 *ip = (u8 *) ifp;\r\nu8 csum = 0, len;\r\nlen = ifp->if_length;\r\nif (len > sizeof(struct qib_flash))\r\nlen = sizeof(struct qib_flash);\r\nwhile (len--)\r\ncsum += *ip++;\r\ncsum -= ifp->if_csum;\r\ncsum = ~csum;\r\nif (adjust)\r\nifp->if_csum = csum;\r\nreturn csum;\r\n}\r\nvoid qib_get_eeprom_info(struct qib_devdata *dd)\r\n{\r\nvoid *buf;\r\nstruct qib_flash *ifp;\r\n__be64 guid;\r\nint len, eep_stat;\r\nu8 csum, *bguid;\r\nint t = dd->unit;\r\nstruct qib_devdata *dd0 = qib_lookup(0);\r\nif (t && dd0->nguid > 1 && t <= dd0->nguid) {\r\nu8 oguid;\r\ndd->base_guid = dd0->base_guid;\r\nbguid = (u8 *) &dd->base_guid;\r\noguid = bguid[7];\r\nbguid[7] += t;\r\nif (oguid > bguid[7]) {\r\nif (bguid[6] == 0xff) {\r\nif (bguid[5] == 0xff) {\r\nqib_dev_err(dd,\r\n"Can't set %s GUID from base, wraps to OUI!\n",\r\nqib_get_unit_name(t));\r\ndd->base_guid = 0;\r\ngoto bail;\r\n}\r\nbguid[5]++;\r\n}\r\nbguid[6]++;\r\n}\r\ndd->nguid = 1;\r\ngoto bail;\r\n}\r\nlen = sizeof(struct qib_flash);\r\nbuf = vmalloc(len);\r\nif (!buf) {\r\nqib_dev_err(dd,\r\n"Couldn't allocate memory to read %u bytes from eeprom for GUID\n",\r\nlen);\r\ngoto bail;\r\n}\r\neep_stat = qib_eeprom_read(dd, 0, buf, len);\r\nif (eep_stat) {\r\nqib_dev_err(dd, "Failed reading GUID from eeprom\n");\r\ngoto done;\r\n}\r\nifp = (struct qib_flash *)buf;\r\ncsum = flash_csum(ifp, 0);\r\nif (csum != ifp->if_csum) {\r\nqib_devinfo(dd->pcidev,\r\n"Bad I2C flash checksum: 0x%x, not 0x%x\n",\r\ncsum, ifp->if_csum);\r\ngoto done;\r\n}\r\nif (*(__be64 *) ifp->if_guid == cpu_to_be64(0) ||\r\n*(__be64 *) ifp->if_guid == ~cpu_to_be64(0)) {\r\nqib_dev_err(dd,\r\n"Invalid GUID %llx from flash; ignoring\n",\r\n*(unsigned long long *) ifp->if_guid);\r\ngoto done;\r\n}\r\nif (*(u64 *) ifp->if_guid == 0x100007511000000ULL)\r\nqib_devinfo(dd->pcidev,\r\n"Warning, GUID %llx is default, probably not correct!\n",\r\n*(unsigned long long *) ifp->if_guid);\r\nbguid = ifp->if_guid;\r\nif (!bguid[0] && !bguid[1] && !bguid[2]) {\r\nbguid[1] = bguid[3];\r\nbguid[2] = bguid[4];\r\nbguid[3] = 0;\r\nbguid[4] = 0;\r\nguid = *(__be64 *) ifp->if_guid;\r\n} else\r\nguid = *(__be64 *) ifp->if_guid;\r\ndd->base_guid = guid;\r\ndd->nguid = ifp->if_numguid;\r\nif ((ifp->if_fversion > 1) && ifp->if_sprefix[0] &&\r\n((u8 *) ifp->if_sprefix)[0] != 0xFF) {\r\nchar *snp = dd->serial;\r\nmemcpy(snp, ifp->if_sprefix, sizeof ifp->if_sprefix);\r\nsnp[sizeof ifp->if_sprefix] = '\0';\r\nlen = strlen(snp);\r\nsnp += len;\r\nlen = (sizeof dd->serial) - len;\r\nif (len > sizeof ifp->if_serial)\r\nlen = sizeof ifp->if_serial;\r\nmemcpy(snp, ifp->if_serial, len);\r\n} else\r\nmemcpy(dd->serial, ifp->if_serial,\r\nsizeof ifp->if_serial);\r\nif (!strstr(ifp->if_comment, "Tested successfully"))\r\nqib_dev_err(dd,\r\n"Board SN %s did not pass functional test: %s\n",\r\ndd->serial, ifp->if_comment);\r\nmemcpy(&dd->eep_st_errs, &ifp->if_errcntp, QIB_EEP_LOG_CNT);\r\natomic_set(&dd->active_time, 0);\r\ndd->eep_hrs = ifp->if_powerhour[0] | (ifp->if_powerhour[1] << 8);\r\ndone:\r\nvfree(buf);\r\nbail:;\r\n}\r\nint qib_update_eeprom_log(struct qib_devdata *dd)\r\n{\r\nvoid *buf;\r\nstruct qib_flash *ifp;\r\nint len, hi_water;\r\nuint32_t new_time, new_hrs;\r\nu8 csum;\r\nint ret, idx;\r\nunsigned long flags;\r\nret = 0;\r\nfor (idx = 0; idx < QIB_EEP_LOG_CNT; ++idx) {\r\nif (dd->eep_st_new_errs[idx]) {\r\nret = 1;\r\nbreak;\r\n}\r\n}\r\nnew_time = atomic_read(&dd->active_time);\r\nif (ret == 0 && new_time < 3600)\r\ngoto bail;\r\nlen = sizeof(struct qib_flash);\r\nbuf = vmalloc(len);\r\nret = 1;\r\nif (!buf) {\r\nqib_dev_err(dd,\r\n"Couldn't allocate memory to read %u bytes from eeprom for logging\n",\r\nlen);\r\ngoto bail;\r\n}\r\nret = mutex_lock_interruptible(&dd->eep_lock);\r\nif (ret) {\r\nqib_dev_err(dd, "Unable to acquire EEPROM for logging\n");\r\ngoto free_bail;\r\n}\r\nret = qib_twsi_blk_rd(dd, dd->twsi_eeprom_dev, 0, buf, len);\r\nif (ret) {\r\nmutex_unlock(&dd->eep_lock);\r\nqib_dev_err(dd, "Unable read EEPROM for logging\n");\r\ngoto free_bail;\r\n}\r\nifp = (struct qib_flash *)buf;\r\ncsum = flash_csum(ifp, 0);\r\nif (csum != ifp->if_csum) {\r\nmutex_unlock(&dd->eep_lock);\r\nqib_dev_err(dd, "EEPROM cks err (0x%02X, S/B 0x%02X)\n",\r\ncsum, ifp->if_csum);\r\nret = 1;\r\ngoto free_bail;\r\n}\r\nhi_water = 0;\r\nspin_lock_irqsave(&dd->eep_st_lock, flags);\r\nfor (idx = 0; idx < QIB_EEP_LOG_CNT; ++idx) {\r\nint new_val = dd->eep_st_new_errs[idx];\r\nif (new_val) {\r\nnew_val += ifp->if_errcntp[idx];\r\nif (new_val > 0xFF)\r\nnew_val = 0xFF;\r\nif (ifp->if_errcntp[idx] != new_val) {\r\nifp->if_errcntp[idx] = new_val;\r\nhi_water = offsetof(struct qib_flash,\r\nif_errcntp) + idx;\r\n}\r\ndd->eep_st_errs[idx] = new_val;\r\ndd->eep_st_new_errs[idx] = 0;\r\n}\r\n}\r\nif (new_time >= 3600) {\r\nnew_hrs = new_time / 3600;\r\natomic_sub((new_hrs * 3600), &dd->active_time);\r\nnew_hrs += dd->eep_hrs;\r\nif (new_hrs > 0xFFFF)\r\nnew_hrs = 0xFFFF;\r\ndd->eep_hrs = new_hrs;\r\nif ((new_hrs & 0xFF) != ifp->if_powerhour[0]) {\r\nifp->if_powerhour[0] = new_hrs & 0xFF;\r\nhi_water = offsetof(struct qib_flash, if_powerhour);\r\n}\r\nif ((new_hrs >> 8) != ifp->if_powerhour[1]) {\r\nifp->if_powerhour[1] = new_hrs >> 8;\r\nhi_water = offsetof(struct qib_flash, if_powerhour) + 1;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dd->eep_st_lock, flags);\r\nif (hi_water) {\r\ncsum = flash_csum(ifp, 1);\r\nret = eeprom_write_with_enable(dd, 0, buf, hi_water + 1);\r\n}\r\nmutex_unlock(&dd->eep_lock);\r\nif (ret)\r\nqib_dev_err(dd, "Failed updating EEPROM\n");\r\nfree_bail:\r\nvfree(buf);\r\nbail:\r\nreturn ret;\r\n}\r\nvoid qib_inc_eeprom_err(struct qib_devdata *dd, u32 eidx, u32 incr)\r\n{\r\nuint new_val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dd->eep_st_lock, flags);\r\nnew_val = dd->eep_st_new_errs[eidx] + incr;\r\nif (new_val > 255)\r\nnew_val = 255;\r\ndd->eep_st_new_errs[eidx] = new_val;\r\nspin_unlock_irqrestore(&dd->eep_st_lock, flags);\r\n}
