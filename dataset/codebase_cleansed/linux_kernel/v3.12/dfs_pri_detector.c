static u32 pde_get_multiple(u32 val, u32 fraction, u32 tolerance)\r\n{\r\nu32 remainder;\r\nu32 factor;\r\nu32 delta;\r\nif (fraction == 0)\r\nreturn 0;\r\ndelta = (val < fraction) ? (fraction - val) : (val - fraction);\r\nif (delta <= tolerance)\r\nreturn 1;\r\nfactor = val / fraction;\r\nremainder = val % fraction;\r\nif (remainder > tolerance) {\r\nif ((fraction - remainder) <= tolerance)\r\nfactor++;\r\nelse\r\nfactor = 0;\r\n}\r\nreturn factor;\r\n}\r\nstatic void pool_register_ref(void)\r\n{\r\nspin_lock_bh(&pool_lock);\r\nsingleton_pool_references++;\r\nDFS_POOL_STAT_INC(pool_reference);\r\nspin_unlock_bh(&pool_lock);\r\n}\r\nstatic void pool_deregister_ref(void)\r\n{\r\nspin_lock_bh(&pool_lock);\r\nsingleton_pool_references--;\r\nDFS_POOL_STAT_DEC(pool_reference);\r\nif (singleton_pool_references == 0) {\r\nstruct pri_sequence *ps, *ps0;\r\nstruct pulse_elem *p, *p0;\r\nlist_for_each_entry_safe(p, p0, &pulse_pool, head) {\r\nlist_del(&p->head);\r\nDFS_POOL_STAT_DEC(pulse_allocated);\r\nkfree(p);\r\n}\r\nlist_for_each_entry_safe(ps, ps0, &pseq_pool, head) {\r\nlist_del(&ps->head);\r\nDFS_POOL_STAT_DEC(pseq_allocated);\r\nkfree(ps);\r\n}\r\n}\r\nspin_unlock_bh(&pool_lock);\r\n}\r\nstatic void pool_put_pulse_elem(struct pulse_elem *pe)\r\n{\r\nspin_lock_bh(&pool_lock);\r\nlist_add(&pe->head, &pulse_pool);\r\nDFS_POOL_STAT_DEC(pulse_used);\r\nspin_unlock_bh(&pool_lock);\r\n}\r\nstatic void pool_put_pseq_elem(struct pri_sequence *pse)\r\n{\r\nspin_lock_bh(&pool_lock);\r\nlist_add(&pse->head, &pseq_pool);\r\nDFS_POOL_STAT_DEC(pseq_used);\r\nspin_unlock_bh(&pool_lock);\r\n}\r\nstatic struct pri_sequence *pool_get_pseq_elem(void)\r\n{\r\nstruct pri_sequence *pse = NULL;\r\nspin_lock_bh(&pool_lock);\r\nif (!list_empty(&pseq_pool)) {\r\npse = list_first_entry(&pseq_pool, struct pri_sequence, head);\r\nlist_del(&pse->head);\r\nDFS_POOL_STAT_INC(pseq_used);\r\n}\r\nspin_unlock_bh(&pool_lock);\r\nreturn pse;\r\n}\r\nstatic struct pulse_elem *pool_get_pulse_elem(void)\r\n{\r\nstruct pulse_elem *pe = NULL;\r\nspin_lock_bh(&pool_lock);\r\nif (!list_empty(&pulse_pool)) {\r\npe = list_first_entry(&pulse_pool, struct pulse_elem, head);\r\nlist_del(&pe->head);\r\nDFS_POOL_STAT_INC(pulse_used);\r\n}\r\nspin_unlock_bh(&pool_lock);\r\nreturn pe;\r\n}\r\nstatic struct pulse_elem *pulse_queue_get_tail(struct pri_detector *pde)\r\n{\r\nstruct list_head *l = &pde->pulses;\r\nif (list_empty(l))\r\nreturn NULL;\r\nreturn list_entry(l->prev, struct pulse_elem, head);\r\n}\r\nstatic bool pulse_queue_dequeue(struct pri_detector *pde)\r\n{\r\nstruct pulse_elem *p = pulse_queue_get_tail(pde);\r\nif (p != NULL) {\r\nlist_del_init(&p->head);\r\npde->count--;\r\npool_put_pulse_elem(p);\r\n}\r\nreturn (pde->count > 0);\r\n}\r\nstatic void pulse_queue_check_window(struct pri_detector *pde)\r\n{\r\nu64 min_valid_ts;\r\nstruct pulse_elem *p;\r\nif (pde->count < 2)\r\nreturn;\r\nif (pde->last_ts <= pde->window_size)\r\nreturn;\r\nmin_valid_ts = pde->last_ts - pde->window_size;\r\nwhile ((p = pulse_queue_get_tail(pde)) != NULL) {\r\nif (p->ts >= min_valid_ts)\r\nreturn;\r\npulse_queue_dequeue(pde);\r\n}\r\n}\r\nstatic bool pulse_queue_enqueue(struct pri_detector *pde, u64 ts)\r\n{\r\nstruct pulse_elem *p = pool_get_pulse_elem();\r\nif (p == NULL) {\r\np = kmalloc(sizeof(*p), GFP_ATOMIC);\r\nif (p == NULL) {\r\nDFS_POOL_STAT_INC(pulse_alloc_error);\r\nreturn false;\r\n}\r\nDFS_POOL_STAT_INC(pulse_allocated);\r\nDFS_POOL_STAT_INC(pulse_used);\r\n}\r\nINIT_LIST_HEAD(&p->head);\r\np->ts = ts;\r\nlist_add(&p->head, &pde->pulses);\r\npde->count++;\r\npde->last_ts = ts;\r\npulse_queue_check_window(pde);\r\nif (pde->count >= pde->max_count)\r\npulse_queue_dequeue(pde);\r\nreturn true;\r\n}\r\nstatic bool pseq_handler_create_sequences(struct pri_detector *pde,\r\nu64 ts, u32 min_count)\r\n{\r\nstruct pulse_elem *p;\r\nlist_for_each_entry(p, &pde->pulses, head) {\r\nstruct pri_sequence ps, *new_ps;\r\nstruct pulse_elem *p2;\r\nu32 tmp_false_count;\r\nu64 min_valid_ts;\r\nu32 delta_ts = ts - p->ts;\r\nif (delta_ts < pde->rs->pri_min)\r\ncontinue;\r\nif (delta_ts > pde->rs->pri_max)\r\nbreak;\r\nps.count = 2;\r\nps.count_falses = 0;\r\nps.first_ts = p->ts;\r\nps.last_ts = ts;\r\nps.pri = ts - p->ts;\r\nps.dur = ps.pri * (pde->rs->ppb - 1)\r\n+ 2 * pde->rs->max_pri_tolerance;\r\np2 = p;\r\ntmp_false_count = 0;\r\nmin_valid_ts = ts - ps.dur;\r\nlist_for_each_entry_continue(p2, &pde->pulses, head) {\r\nu32 factor;\r\nif (p2->ts < min_valid_ts)\r\nbreak;\r\nfactor = pde_get_multiple(ps.last_ts - p2->ts, ps.pri,\r\npde->rs->max_pri_tolerance);\r\nif (factor > 0) {\r\nps.count++;\r\nps.first_ts = p2->ts;\r\nps.count_falses += tmp_false_count;\r\ntmp_false_count = 0;\r\n} else {\r\ntmp_false_count++;\r\n}\r\n}\r\nif (ps.count < min_count)\r\ncontinue;\r\nps.deadline_ts = ps.first_ts + ps.dur;\r\nnew_ps = pool_get_pseq_elem();\r\nif (new_ps == NULL) {\r\nnew_ps = kmalloc(sizeof(*new_ps), GFP_ATOMIC);\r\nif (new_ps == NULL) {\r\nDFS_POOL_STAT_INC(pseq_alloc_error);\r\nreturn false;\r\n}\r\nDFS_POOL_STAT_INC(pseq_allocated);\r\nDFS_POOL_STAT_INC(pseq_used);\r\n}\r\nmemcpy(new_ps, &ps, sizeof(ps));\r\nINIT_LIST_HEAD(&new_ps->head);\r\nlist_add(&new_ps->head, &pde->sequences);\r\n}\r\nreturn true;\r\n}\r\nstatic u32\r\npseq_handler_add_to_existing_seqs(struct pri_detector *pde, u64 ts)\r\n{\r\nu32 max_count = 0;\r\nstruct pri_sequence *ps, *ps2;\r\nlist_for_each_entry_safe(ps, ps2, &pde->sequences, head) {\r\nu32 delta_ts;\r\nu32 factor;\r\nif (ts > ps->deadline_ts) {\r\nlist_del_init(&ps->head);\r\npool_put_pseq_elem(ps);\r\ncontinue;\r\n}\r\ndelta_ts = ts - ps->last_ts;\r\nfactor = pde_get_multiple(delta_ts, ps->pri,\r\npde->rs->max_pri_tolerance);\r\nif (factor > 0) {\r\nps->last_ts = ts;\r\nps->count++;\r\nif (max_count < ps->count)\r\nmax_count = ps->count;\r\n} else {\r\nps->count_falses++;\r\n}\r\n}\r\nreturn max_count;\r\n}\r\nstatic struct pri_sequence *\r\npseq_handler_check_detection(struct pri_detector *pde)\r\n{\r\nstruct pri_sequence *ps;\r\nif (list_empty(&pde->sequences))\r\nreturn NULL;\r\nlist_for_each_entry(ps, &pde->sequences, head) {\r\nif ((ps->count >= pde->rs->ppb_thresh) &&\r\n(ps->count * pde->rs->num_pri >= ps->count_falses))\r\nreturn ps;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void pri_detector_reset(struct pri_detector *pde, u64 ts)\r\n{\r\nstruct pri_sequence *ps, *ps0;\r\nstruct pulse_elem *p, *p0;\r\nlist_for_each_entry_safe(ps, ps0, &pde->sequences, head) {\r\nlist_del_init(&ps->head);\r\npool_put_pseq_elem(ps);\r\n}\r\nlist_for_each_entry_safe(p, p0, &pde->pulses, head) {\r\nlist_del_init(&p->head);\r\npool_put_pulse_elem(p);\r\n}\r\npde->count = 0;\r\npde->last_ts = ts;\r\n}\r\nstatic void pri_detector_exit(struct pri_detector *de)\r\n{\r\npri_detector_reset(de, 0);\r\npool_deregister_ref();\r\nkfree(de);\r\n}\r\nstatic struct pri_sequence *pri_detector_add_pulse(struct pri_detector *de,\r\nstruct pulse_event *event)\r\n{\r\nu32 max_updated_seq;\r\nstruct pri_sequence *ps;\r\nu64 ts = event->ts;\r\nconst struct radar_detector_specs *rs = de->rs;\r\nif ((rs->width_min > event->width) || (rs->width_max < event->width))\r\nreturn NULL;\r\nif ((ts - de->last_ts) < rs->max_pri_tolerance)\r\nreturn NULL;\r\nde->last_ts = ts;\r\nmax_updated_seq = pseq_handler_add_to_existing_seqs(de, ts);\r\nif (!pseq_handler_create_sequences(de, ts, max_updated_seq)) {\r\npri_detector_reset(de, ts);\r\nreturn false;\r\n}\r\nps = pseq_handler_check_detection(de);\r\nif (ps == NULL)\r\npulse_queue_enqueue(de, ts);\r\nreturn ps;\r\n}\r\nstruct pri_detector *pri_detector_init(const struct radar_detector_specs *rs)\r\n{\r\nstruct pri_detector *de;\r\nde = kzalloc(sizeof(*de), GFP_ATOMIC);\r\nif (de == NULL)\r\nreturn NULL;\r\nde->exit = pri_detector_exit;\r\nde->add_pulse = pri_detector_add_pulse;\r\nde->reset = pri_detector_reset;\r\nINIT_LIST_HEAD(&de->sequences);\r\nINIT_LIST_HEAD(&de->pulses);\r\nde->window_size = rs->pri_max * rs->ppb * rs->num_pri;\r\nde->max_count = rs->ppb * 2;\r\nde->rs = rs;\r\npool_register_ref();\r\nreturn de;\r\n}
