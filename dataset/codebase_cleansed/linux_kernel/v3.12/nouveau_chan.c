int\r\nnouveau_channel_idle(struct nouveau_channel *chan)\r\n{\r\nstruct nouveau_cli *cli = chan->cli;\r\nstruct nouveau_fence *fence = NULL;\r\nint ret;\r\nret = nouveau_fence_new(chan, false, &fence);\r\nif (!ret) {\r\nret = nouveau_fence_wait(fence, false, false);\r\nnouveau_fence_unref(&fence);\r\n}\r\nif (ret)\r\nNV_ERROR(cli, "failed to idle channel 0x%08x [%s]\n",\r\nchan->handle, cli->base.name);\r\nreturn ret;\r\n}\r\nvoid\r\nnouveau_channel_del(struct nouveau_channel **pchan)\r\n{\r\nstruct nouveau_channel *chan = *pchan;\r\nif (chan) {\r\nstruct nouveau_object *client = nv_object(chan->cli);\r\nif (chan->fence) {\r\nnouveau_channel_idle(chan);\r\nnouveau_fence(chan->drm)->context_del(chan);\r\n}\r\nnouveau_object_del(client, NVDRM_DEVICE, chan->handle);\r\nnouveau_object_del(client, NVDRM_DEVICE, chan->push.handle);\r\nnouveau_bo_vma_del(chan->push.buffer, &chan->push.vma);\r\nnouveau_bo_unmap(chan->push.buffer);\r\nif (chan->push.buffer && chan->push.buffer->pin_refcnt)\r\nnouveau_bo_unpin(chan->push.buffer);\r\nnouveau_bo_ref(NULL, &chan->push.buffer);\r\nkfree(chan);\r\n}\r\n*pchan = NULL;\r\n}\r\nstatic int\r\nnouveau_channel_prep(struct nouveau_drm *drm, struct nouveau_cli *cli,\r\nu32 parent, u32 handle, u32 size,\r\nstruct nouveau_channel **pchan)\r\n{\r\nstruct nouveau_device *device = nv_device(drm->device);\r\nstruct nouveau_instmem *imem = nouveau_instmem(device);\r\nstruct nouveau_vmmgr *vmm = nouveau_vmmgr(device);\r\nstruct nouveau_fb *pfb = nouveau_fb(device);\r\nstruct nouveau_client *client = &cli->base;\r\nstruct nv_dma_class args = {};\r\nstruct nouveau_channel *chan;\r\nstruct nouveau_object *push;\r\nu32 target;\r\nint ret;\r\nchan = *pchan = kzalloc(sizeof(*chan), GFP_KERNEL);\r\nif (!chan)\r\nreturn -ENOMEM;\r\nchan->cli = cli;\r\nchan->drm = drm;\r\nchan->handle = handle;\r\ntarget = TTM_PL_FLAG_TT;\r\nif (nouveau_vram_pushbuf)\r\ntarget = TTM_PL_FLAG_VRAM;\r\nret = nouveau_bo_new(drm->dev, size, 0, target, 0, 0, NULL,\r\n&chan->push.buffer);\r\nif (ret == 0) {\r\nret = nouveau_bo_pin(chan->push.buffer, target);\r\nif (ret == 0)\r\nret = nouveau_bo_map(chan->push.buffer);\r\n}\r\nif (ret) {\r\nnouveau_channel_del(pchan);\r\nreturn ret;\r\n}\r\nchan->push.vma.offset = chan->push.buffer->bo.offset;\r\nchan->push.handle = NVDRM_PUSH | (handle & 0xffff);\r\nif (device->card_type >= NV_50) {\r\nret = nouveau_bo_vma_add(chan->push.buffer, client->vm,\r\n&chan->push.vma);\r\nif (ret) {\r\nnouveau_channel_del(pchan);\r\nreturn ret;\r\n}\r\nargs.flags = NV_DMA_TARGET_VM | NV_DMA_ACCESS_VM;\r\nargs.start = 0;\r\nargs.limit = client->vm->vmm->limit - 1;\r\n} else\r\nif (chan->push.buffer->bo.mem.mem_type == TTM_PL_VRAM) {\r\nu64 limit = pfb->ram->size - imem->reserved - 1;\r\nif (device->card_type == NV_04) {\r\nargs.flags = NV_DMA_TARGET_PCI | NV_DMA_ACCESS_RDWR;\r\nargs.start = pci_resource_start(device->pdev, 1);\r\nargs.limit = args.start + limit;\r\n} else {\r\nargs.flags = NV_DMA_TARGET_VRAM | NV_DMA_ACCESS_RDWR;\r\nargs.start = 0;\r\nargs.limit = limit;\r\n}\r\n} else {\r\nif (chan->drm->agp.stat == ENABLED) {\r\nargs.flags = NV_DMA_TARGET_AGP | NV_DMA_ACCESS_RDWR;\r\nargs.start = chan->drm->agp.base;\r\nargs.limit = chan->drm->agp.base +\r\nchan->drm->agp.size - 1;\r\n} else {\r\nargs.flags = NV_DMA_TARGET_VM | NV_DMA_ACCESS_RDWR;\r\nargs.start = 0;\r\nargs.limit = vmm->limit - 1;\r\n}\r\n}\r\nret = nouveau_object_new(nv_object(chan->cli), parent,\r\nchan->push.handle, 0x0002,\r\n&args, sizeof(args), &push);\r\nif (ret) {\r\nnouveau_channel_del(pchan);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_channel_ind(struct nouveau_drm *drm, struct nouveau_cli *cli,\r\nu32 parent, u32 handle, u32 engine,\r\nstruct nouveau_channel **pchan)\r\n{\r\nstatic const u16 oclasses[] = { NVE0_CHANNEL_IND_CLASS,\r\nNVC0_CHANNEL_IND_CLASS,\r\nNV84_CHANNEL_IND_CLASS,\r\nNV50_CHANNEL_IND_CLASS,\r\n0 };\r\nconst u16 *oclass = oclasses;\r\nstruct nve0_channel_ind_class args;\r\nstruct nouveau_channel *chan;\r\nint ret;\r\nret = nouveau_channel_prep(drm, cli, parent, handle, 0x12000, &chan);\r\n*pchan = chan;\r\nif (ret)\r\nreturn ret;\r\nargs.pushbuf = chan->push.handle;\r\nargs.ioffset = 0x10000 + chan->push.vma.offset;\r\nargs.ilength = 0x02000;\r\nargs.engine = engine;\r\ndo {\r\nret = nouveau_object_new(nv_object(cli), parent, handle,\r\n*oclass++, &args, sizeof(args),\r\n&chan->object);\r\nif (ret == 0)\r\nreturn ret;\r\n} while (*oclass);\r\nnouveau_channel_del(pchan);\r\nreturn ret;\r\n}\r\nstatic int\r\nnouveau_channel_dma(struct nouveau_drm *drm, struct nouveau_cli *cli,\r\nu32 parent, u32 handle, struct nouveau_channel **pchan)\r\n{\r\nstatic const u16 oclasses[] = { NV40_CHANNEL_DMA_CLASS,\r\nNV17_CHANNEL_DMA_CLASS,\r\nNV10_CHANNEL_DMA_CLASS,\r\nNV03_CHANNEL_DMA_CLASS,\r\n0 };\r\nconst u16 *oclass = oclasses;\r\nstruct nv03_channel_dma_class args;\r\nstruct nouveau_channel *chan;\r\nint ret;\r\nret = nouveau_channel_prep(drm, cli, parent, handle, 0x10000, &chan);\r\n*pchan = chan;\r\nif (ret)\r\nreturn ret;\r\nargs.pushbuf = chan->push.handle;\r\nargs.offset = chan->push.vma.offset;\r\ndo {\r\nret = nouveau_object_new(nv_object(cli), parent, handle,\r\n*oclass++, &args, sizeof(args),\r\n&chan->object);\r\nif (ret == 0)\r\nreturn ret;\r\n} while (ret && *oclass);\r\nnouveau_channel_del(pchan);\r\nreturn ret;\r\n}\r\nstatic int\r\nnouveau_channel_init(struct nouveau_channel *chan, u32 vram, u32 gart)\r\n{\r\nstruct nouveau_client *client = nv_client(chan->cli);\r\nstruct nouveau_device *device = nv_device(chan->drm->device);\r\nstruct nouveau_instmem *imem = nouveau_instmem(device);\r\nstruct nouveau_vmmgr *vmm = nouveau_vmmgr(device);\r\nstruct nouveau_fb *pfb = nouveau_fb(device);\r\nstruct nouveau_software_chan *swch;\r\nstruct nouveau_object *object;\r\nstruct nv_dma_class args = {};\r\nint ret, i;\r\nif (device->card_type < NV_C0) {\r\nif (device->card_type >= NV_50) {\r\nargs.flags = NV_DMA_TARGET_VM | NV_DMA_ACCESS_VM;\r\nargs.start = 0;\r\nargs.limit = client->vm->vmm->limit - 1;\r\n} else {\r\nargs.flags = NV_DMA_TARGET_VRAM | NV_DMA_ACCESS_RDWR;\r\nargs.start = 0;\r\nargs.limit = pfb->ram->size - imem->reserved - 1;\r\n}\r\nret = nouveau_object_new(nv_object(client), chan->handle, vram,\r\n0x003d, &args, sizeof(args), &object);\r\nif (ret)\r\nreturn ret;\r\nif (device->card_type >= NV_50) {\r\nargs.flags = NV_DMA_TARGET_VM | NV_DMA_ACCESS_VM;\r\nargs.start = 0;\r\nargs.limit = client->vm->vmm->limit - 1;\r\n} else\r\nif (chan->drm->agp.stat == ENABLED) {\r\nargs.flags = NV_DMA_TARGET_AGP | NV_DMA_ACCESS_RDWR;\r\nargs.start = chan->drm->agp.base;\r\nargs.limit = chan->drm->agp.base +\r\nchan->drm->agp.size - 1;\r\n} else {\r\nargs.flags = NV_DMA_TARGET_VM | NV_DMA_ACCESS_RDWR;\r\nargs.start = 0;\r\nargs.limit = vmm->limit - 1;\r\n}\r\nret = nouveau_object_new(nv_object(client), chan->handle, gart,\r\n0x003d, &args, sizeof(args), &object);\r\nif (ret)\r\nreturn ret;\r\nchan->vram = vram;\r\nchan->gart = gart;\r\n}\r\nswitch (nv_hclass(chan->object) & 0x00ff) {\r\ncase 0x006b:\r\ncase 0x006e:\r\nchan->user_put = 0x40;\r\nchan->user_get = 0x44;\r\nchan->dma.max = (0x10000 / 4) - 2;\r\nbreak;\r\ndefault:\r\nchan->user_put = 0x40;\r\nchan->user_get = 0x44;\r\nchan->user_get_hi = 0x60;\r\nchan->dma.ib_base = 0x10000 / 4;\r\nchan->dma.ib_max = (0x02000 / 8) - 1;\r\nchan->dma.ib_put = 0;\r\nchan->dma.ib_free = chan->dma.ib_max - chan->dma.ib_put;\r\nchan->dma.max = chan->dma.ib_base;\r\nbreak;\r\n}\r\nchan->dma.put = 0;\r\nchan->dma.cur = chan->dma.put;\r\nchan->dma.free = chan->dma.max - chan->dma.cur;\r\nret = RING_SPACE(chan, NOUVEAU_DMA_SKIPS);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < NOUVEAU_DMA_SKIPS; i++)\r\nOUT_RING(chan, 0x00000000);\r\nif ((device->card_type < NV_E0) || gart ) {\r\nret = nouveau_object_new(nv_object(client), chan->handle,\r\nNvSw, nouveau_abi16_swclass(chan->drm),\r\nNULL, 0, &object);\r\nif (ret)\r\nreturn ret;\r\nswch = (void *)object->parent;\r\nswch->flip = nouveau_flip_complete;\r\nswch->flip_data = chan;\r\n}\r\nif (device->card_type < NV_C0) {\r\nret = RING_SPACE(chan, 2);\r\nif (ret)\r\nreturn ret;\r\nBEGIN_NV04(chan, NvSubSw, 0x0000, 1);\r\nOUT_RING (chan, NvSw);\r\nFIRE_RING (chan);\r\n}\r\nreturn nouveau_fence(chan->drm)->context_new(chan);\r\n}\r\nint\r\nnouveau_channel_new(struct nouveau_drm *drm, struct nouveau_cli *cli,\r\nu32 parent, u32 handle, u32 arg0, u32 arg1,\r\nstruct nouveau_channel **pchan)\r\n{\r\nint ret;\r\nret = nouveau_channel_ind(drm, cli, parent, handle, arg0, pchan);\r\nif (ret) {\r\nNV_DEBUG(cli, "ib channel create, %d\n", ret);\r\nret = nouveau_channel_dma(drm, cli, parent, handle, pchan);\r\nif (ret) {\r\nNV_DEBUG(cli, "dma channel create, %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = nouveau_channel_init(*pchan, arg0, arg1);\r\nif (ret) {\r\nNV_ERROR(cli, "channel failed to initialise, %d\n", ret);\r\nnouveau_channel_del(pchan);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
