static int vprbrd_gpioa_get(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nint ret, answer, error = 0;\r\nstruct vprbrd_gpio *gpio =\r\ncontainer_of(chip, struct vprbrd_gpio, gpioa);\r\nstruct vprbrd *vb = gpio->vb;\r\nstruct vprbrd_gpioa_msg *gamsg = (struct vprbrd_gpioa_msg *)vb->buf;\r\nif (gpio->gpioa_out & (1 << offset))\r\nreturn gpio->gpioa_val & (1 << offset);\r\nmutex_lock(&vb->lock);\r\ngamsg->cmd = VPRBRD_GPIOA_CMD_GETIN;\r\ngamsg->clk = 0x00;\r\ngamsg->offset = offset;\r\ngamsg->t1 = 0x00;\r\ngamsg->t2 = 0x00;\r\ngamsg->invert = 0x00;\r\ngamsg->pwmlevel = 0x00;\r\ngamsg->outval = 0x00;\r\ngamsg->risefall = 0x00;\r\ngamsg->answer = 0x00;\r\ngamsg->__fill = 0x00;\r\nret = usb_control_msg(vb->usb_dev, usb_sndctrlpipe(vb->usb_dev, 0),\r\nVPRBRD_USB_REQUEST_GPIOA, VPRBRD_USB_TYPE_OUT, 0x0000,\r\n0x0000, gamsg, sizeof(struct vprbrd_gpioa_msg),\r\nVPRBRD_USB_TIMEOUT_MS);\r\nif (ret != sizeof(struct vprbrd_gpioa_msg))\r\nerror = -EREMOTEIO;\r\nret = usb_control_msg(vb->usb_dev, usb_rcvctrlpipe(vb->usb_dev, 0),\r\nVPRBRD_USB_REQUEST_GPIOA, VPRBRD_USB_TYPE_IN, 0x0000,\r\n0x0000, gamsg, sizeof(struct vprbrd_gpioa_msg),\r\nVPRBRD_USB_TIMEOUT_MS);\r\nanswer = gamsg->answer & 0x01;\r\nmutex_unlock(&vb->lock);\r\nif (ret != sizeof(struct vprbrd_gpioa_msg))\r\nerror = -EREMOTEIO;\r\nif (error)\r\nreturn error;\r\nreturn answer;\r\n}\r\nstatic void vprbrd_gpioa_set(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nint ret;\r\nstruct vprbrd_gpio *gpio =\r\ncontainer_of(chip, struct vprbrd_gpio, gpioa);\r\nstruct vprbrd *vb = gpio->vb;\r\nstruct vprbrd_gpioa_msg *gamsg = (struct vprbrd_gpioa_msg *)vb->buf;\r\nif (gpio->gpioa_out & (1 << offset)) {\r\nif (value)\r\ngpio->gpioa_val |= (1 << offset);\r\nelse\r\ngpio->gpioa_val &= ~(1 << offset);\r\nmutex_lock(&vb->lock);\r\ngamsg->cmd = VPRBRD_GPIOA_CMD_SETOUT;\r\ngamsg->clk = 0x00;\r\ngamsg->offset = offset;\r\ngamsg->t1 = 0x00;\r\ngamsg->t2 = 0x00;\r\ngamsg->invert = 0x00;\r\ngamsg->pwmlevel = 0x00;\r\ngamsg->outval = value;\r\ngamsg->risefall = 0x00;\r\ngamsg->answer = 0x00;\r\ngamsg->__fill = 0x00;\r\nret = usb_control_msg(vb->usb_dev,\r\nusb_sndctrlpipe(vb->usb_dev, 0),\r\nVPRBRD_USB_REQUEST_GPIOA, VPRBRD_USB_TYPE_OUT,\r\n0x0000, 0x0000, gamsg,\r\nsizeof(struct vprbrd_gpioa_msg), VPRBRD_USB_TIMEOUT_MS);\r\nmutex_unlock(&vb->lock);\r\nif (ret != sizeof(struct vprbrd_gpioa_msg))\r\ndev_err(chip->dev, "usb error setting pin value\n");\r\n}\r\n}\r\nstatic int vprbrd_gpioa_direction_input(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nint ret;\r\nstruct vprbrd_gpio *gpio =\r\ncontainer_of(chip, struct vprbrd_gpio, gpioa);\r\nstruct vprbrd *vb = gpio->vb;\r\nstruct vprbrd_gpioa_msg *gamsg = (struct vprbrd_gpioa_msg *)vb->buf;\r\ngpio->gpioa_out &= ~(1 << offset);\r\nmutex_lock(&vb->lock);\r\ngamsg->cmd = VPRBRD_GPIOA_CMD_SETIN;\r\ngamsg->clk = gpioa_clk;\r\ngamsg->offset = offset;\r\ngamsg->t1 = 0x00;\r\ngamsg->t2 = 0x00;\r\ngamsg->invert = 0x00;\r\ngamsg->pwmlevel = 0x00;\r\ngamsg->outval = 0x00;\r\ngamsg->risefall = 0x00;\r\ngamsg->answer = 0x00;\r\ngamsg->__fill = 0x00;\r\nret = usb_control_msg(vb->usb_dev, usb_sndctrlpipe(vb->usb_dev, 0),\r\nVPRBRD_USB_REQUEST_GPIOA, VPRBRD_USB_TYPE_OUT, 0x0000,\r\n0x0000, gamsg, sizeof(struct vprbrd_gpioa_msg),\r\nVPRBRD_USB_TIMEOUT_MS);\r\nmutex_unlock(&vb->lock);\r\nif (ret != sizeof(struct vprbrd_gpioa_msg))\r\nreturn -EREMOTEIO;\r\nreturn 0;\r\n}\r\nstatic int vprbrd_gpioa_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nint ret;\r\nstruct vprbrd_gpio *gpio =\r\ncontainer_of(chip, struct vprbrd_gpio, gpioa);\r\nstruct vprbrd *vb = gpio->vb;\r\nstruct vprbrd_gpioa_msg *gamsg = (struct vprbrd_gpioa_msg *)vb->buf;\r\ngpio->gpioa_out |= (1 << offset);\r\nif (value)\r\ngpio->gpioa_val |= (1 << offset);\r\nelse\r\ngpio->gpioa_val &= ~(1 << offset);\r\nmutex_lock(&vb->lock);\r\ngamsg->cmd = VPRBRD_GPIOA_CMD_SETOUT;\r\ngamsg->clk = 0x00;\r\ngamsg->offset = offset;\r\ngamsg->t1 = 0x00;\r\ngamsg->t2 = 0x00;\r\ngamsg->invert = 0x00;\r\ngamsg->pwmlevel = 0x00;\r\ngamsg->outval = value;\r\ngamsg->risefall = 0x00;\r\ngamsg->answer = 0x00;\r\ngamsg->__fill = 0x00;\r\nret = usb_control_msg(vb->usb_dev, usb_sndctrlpipe(vb->usb_dev, 0),\r\nVPRBRD_USB_REQUEST_GPIOA, VPRBRD_USB_TYPE_OUT, 0x0000,\r\n0x0000, gamsg, sizeof(struct vprbrd_gpioa_msg),\r\nVPRBRD_USB_TIMEOUT_MS);\r\nmutex_unlock(&vb->lock);\r\nif (ret != sizeof(struct vprbrd_gpioa_msg))\r\nreturn -EREMOTEIO;\r\nreturn 0;\r\n}\r\nstatic int vprbrd_gpiob_setdir(struct vprbrd *vb, unsigned offset,\r\nunsigned dir)\r\n{\r\nstruct vprbrd_gpiob_msg *gbmsg = (struct vprbrd_gpiob_msg *)vb->buf;\r\nint ret;\r\ngbmsg->cmd = VPRBRD_GPIOB_CMD_SETDIR;\r\ngbmsg->val = cpu_to_be16(dir << offset);\r\ngbmsg->mask = cpu_to_be16(0x0001 << offset);\r\nret = usb_control_msg(vb->usb_dev, usb_sndctrlpipe(vb->usb_dev, 0),\r\nVPRBRD_USB_REQUEST_GPIOB, VPRBRD_USB_TYPE_OUT, 0x0000,\r\n0x0000, gbmsg, sizeof(struct vprbrd_gpiob_msg),\r\nVPRBRD_USB_TIMEOUT_MS);\r\nif (ret != sizeof(struct vprbrd_gpiob_msg))\r\nreturn -EREMOTEIO;\r\nreturn 0;\r\n}\r\nstatic int vprbrd_gpiob_get(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nint ret;\r\nu16 val;\r\nstruct vprbrd_gpio *gpio =\r\ncontainer_of(chip, struct vprbrd_gpio, gpiob);\r\nstruct vprbrd *vb = gpio->vb;\r\nstruct vprbrd_gpiob_msg *gbmsg = (struct vprbrd_gpiob_msg *)vb->buf;\r\nif (gpio->gpiob_out & (1 << offset))\r\nreturn gpio->gpiob_val & (1 << offset);\r\nmutex_lock(&vb->lock);\r\nret = usb_control_msg(vb->usb_dev, usb_rcvctrlpipe(vb->usb_dev, 0),\r\nVPRBRD_USB_REQUEST_GPIOB, VPRBRD_USB_TYPE_IN, 0x0000,\r\n0x0000, gbmsg, sizeof(struct vprbrd_gpiob_msg),\r\nVPRBRD_USB_TIMEOUT_MS);\r\nval = gbmsg->val;\r\nmutex_unlock(&vb->lock);\r\nif (ret != sizeof(struct vprbrd_gpiob_msg))\r\nreturn ret;\r\ngpio->gpiob_val = be16_to_cpu(val);\r\nreturn (gpio->gpiob_val >> offset) & 0x1;\r\n}\r\nstatic void vprbrd_gpiob_set(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nint ret;\r\nstruct vprbrd_gpio *gpio =\r\ncontainer_of(chip, struct vprbrd_gpio, gpiob);\r\nstruct vprbrd *vb = gpio->vb;\r\nstruct vprbrd_gpiob_msg *gbmsg = (struct vprbrd_gpiob_msg *)vb->buf;\r\nif (gpio->gpiob_out & (1 << offset)) {\r\nif (value)\r\ngpio->gpiob_val |= (1 << offset);\r\nelse\r\ngpio->gpiob_val &= ~(1 << offset);\r\nmutex_lock(&vb->lock);\r\ngbmsg->cmd = VPRBRD_GPIOB_CMD_SETVAL;\r\ngbmsg->val = cpu_to_be16(value << offset);\r\ngbmsg->mask = cpu_to_be16(0x0001 << offset);\r\nret = usb_control_msg(vb->usb_dev,\r\nusb_sndctrlpipe(vb->usb_dev, 0),\r\nVPRBRD_USB_REQUEST_GPIOB, VPRBRD_USB_TYPE_OUT,\r\n0x0000, 0x0000, gbmsg,\r\nsizeof(struct vprbrd_gpiob_msg), VPRBRD_USB_TIMEOUT_MS);\r\nmutex_unlock(&vb->lock);\r\nif (ret != sizeof(struct vprbrd_gpiob_msg))\r\ndev_err(chip->dev, "usb error setting pin value\n");\r\n}\r\n}\r\nstatic int vprbrd_gpiob_direction_input(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nint ret;\r\nstruct vprbrd_gpio *gpio =\r\ncontainer_of(chip, struct vprbrd_gpio, gpiob);\r\nstruct vprbrd *vb = gpio->vb;\r\ngpio->gpiob_out &= ~(1 << offset);\r\nmutex_lock(&vb->lock);\r\nret = vprbrd_gpiob_setdir(vb, offset, 0);\r\nmutex_unlock(&vb->lock);\r\nif (ret)\r\ndev_err(chip->dev, "usb error setting pin to input\n");\r\nreturn ret;\r\n}\r\nstatic int vprbrd_gpiob_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nint ret;\r\nstruct vprbrd_gpio *gpio =\r\ncontainer_of(chip, struct vprbrd_gpio, gpiob);\r\nstruct vprbrd *vb = gpio->vb;\r\ngpio->gpiob_out |= (1 << offset);\r\nmutex_lock(&vb->lock);\r\nret = vprbrd_gpiob_setdir(vb, offset, 1);\r\nif (ret)\r\ndev_err(chip->dev, "usb error setting pin to output\n");\r\nmutex_unlock(&vb->lock);\r\nvprbrd_gpiob_set(chip, offset, value);\r\nreturn ret;\r\n}\r\nstatic int vprbrd_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct vprbrd *vb = dev_get_drvdata(pdev->dev.parent);\r\nstruct vprbrd_gpio *vb_gpio;\r\nint ret;\r\nvb_gpio = devm_kzalloc(&pdev->dev, sizeof(*vb_gpio), GFP_KERNEL);\r\nif (vb_gpio == NULL)\r\nreturn -ENOMEM;\r\nvb_gpio->vb = vb;\r\nvb_gpio->gpioa.label = "viperboard gpio a";\r\nvb_gpio->gpioa.dev = &pdev->dev;\r\nvb_gpio->gpioa.owner = THIS_MODULE;\r\nvb_gpio->gpioa.base = -1;\r\nvb_gpio->gpioa.ngpio = 16;\r\nvb_gpio->gpioa.can_sleep = 1;\r\nvb_gpio->gpioa.set = vprbrd_gpioa_set;\r\nvb_gpio->gpioa.get = vprbrd_gpioa_get;\r\nvb_gpio->gpioa.direction_input = vprbrd_gpioa_direction_input;\r\nvb_gpio->gpioa.direction_output = vprbrd_gpioa_direction_output;\r\nret = gpiochip_add(&vb_gpio->gpioa);\r\nif (ret < 0) {\r\ndev_err(vb_gpio->gpioa.dev, "could not add gpio a");\r\ngoto err_gpioa;\r\n}\r\nvb_gpio->gpiob.label = "viperboard gpio b";\r\nvb_gpio->gpiob.dev = &pdev->dev;\r\nvb_gpio->gpiob.owner = THIS_MODULE;\r\nvb_gpio->gpiob.base = -1;\r\nvb_gpio->gpiob.ngpio = 16;\r\nvb_gpio->gpiob.can_sleep = 1;\r\nvb_gpio->gpiob.set = vprbrd_gpiob_set;\r\nvb_gpio->gpiob.get = vprbrd_gpiob_get;\r\nvb_gpio->gpiob.direction_input = vprbrd_gpiob_direction_input;\r\nvb_gpio->gpiob.direction_output = vprbrd_gpiob_direction_output;\r\nret = gpiochip_add(&vb_gpio->gpiob);\r\nif (ret < 0) {\r\ndev_err(vb_gpio->gpiob.dev, "could not add gpio b");\r\ngoto err_gpiob;\r\n}\r\nplatform_set_drvdata(pdev, vb_gpio);\r\nreturn ret;\r\nerr_gpiob:\r\nif (gpiochip_remove(&vb_gpio->gpioa))\r\ndev_err(&pdev->dev, "%s gpiochip_remove failed\n", __func__);\r\nerr_gpioa:\r\nreturn ret;\r\n}\r\nstatic int vprbrd_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct vprbrd_gpio *vb_gpio = platform_get_drvdata(pdev);\r\nint ret;\r\nret = gpiochip_remove(&vb_gpio->gpiob);\r\nif (ret == 0)\r\nret = gpiochip_remove(&vb_gpio->gpioa);\r\nreturn ret;\r\n}\r\nstatic int __init vprbrd_gpio_init(void)\r\n{\r\nswitch (gpioa_freq) {\r\ncase 1000000:\r\ngpioa_clk = VPRBRD_GPIOA_CLK_1MHZ;\r\nbreak;\r\ncase 100000:\r\ngpioa_clk = VPRBRD_GPIOA_CLK_100KHZ;\r\nbreak;\r\ncase 10000:\r\ngpioa_clk = VPRBRD_GPIOA_CLK_10KHZ;\r\nbreak;\r\ncase 1000:\r\ngpioa_clk = VPRBRD_GPIOA_CLK_1KHZ;\r\nbreak;\r\ncase 100:\r\ngpioa_clk = VPRBRD_GPIOA_CLK_100HZ;\r\nbreak;\r\ncase 10:\r\ngpioa_clk = VPRBRD_GPIOA_CLK_10HZ;\r\nbreak;\r\ndefault:\r\npr_warn("invalid gpioa_freq (%d)\n", gpioa_freq);\r\ngpioa_clk = VPRBRD_GPIOA_CLK_1KHZ;\r\n}\r\nreturn platform_driver_register(&vprbrd_gpio_driver);\r\n}\r\nstatic void __exit vprbrd_gpio_exit(void)\r\n{\r\nplatform_driver_unregister(&vprbrd_gpio_driver);\r\n}
