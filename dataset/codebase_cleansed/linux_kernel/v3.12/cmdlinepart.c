static struct mtd_partition * newpart(char *s,\r\nchar **retptr,\r\nint *num_parts,\r\nint this_part,\r\nunsigned char **extra_mem_ptr,\r\nint extra_mem_size)\r\n{\r\nstruct mtd_partition *parts;\r\nunsigned long long size, offset = OFFSET_CONTINUOUS;\r\nchar *name;\r\nint name_len;\r\nunsigned char *extra_mem;\r\nchar delim;\r\nunsigned int mask_flags;\r\nif (*s == '-') {\r\nsize = SIZE_REMAINING;\r\ns++;\r\n} else {\r\nsize = memparse(s, &s);\r\nif (size < PAGE_SIZE) {\r\nprintk(KERN_ERR ERRP "partition size too small (%llx)\n",\r\nsize);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n}\r\nmask_flags = 0;\r\ndelim = 0;\r\nif (*s == '@') {\r\ns++;\r\noffset = memparse(s, &s);\r\n}\r\nif (*s == '(')\r\ndelim = ')';\r\nif (delim) {\r\nchar *p;\r\nname = ++s;\r\np = strchr(name, delim);\r\nif (!p) {\r\nprintk(KERN_ERR ERRP "no closing %c found in partition name\n", delim);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nname_len = p - name;\r\ns = p + 1;\r\n} else {\r\nname = NULL;\r\nname_len = 13;\r\n}\r\nextra_mem_size += name_len + 1;\r\nif (strncmp(s, "ro", 2) == 0) {\r\nmask_flags |= MTD_WRITEABLE;\r\ns += 2;\r\n}\r\nif (strncmp(s, "lk", 2) == 0) {\r\nmask_flags |= MTD_POWERUP_LOCK;\r\ns += 2;\r\n}\r\nif (*s == ',') {\r\nif (size == SIZE_REMAINING) {\r\nprintk(KERN_ERR ERRP "no partitions allowed after a fill-up partition\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nparts = newpart(s + 1, &s, num_parts, this_part + 1,\r\n&extra_mem, extra_mem_size);\r\nif (IS_ERR(parts))\r\nreturn parts;\r\n} else {\r\nint alloc_size;\r\n*num_parts = this_part + 1;\r\nalloc_size = *num_parts * sizeof(struct mtd_partition) +\r\nextra_mem_size;\r\nparts = kzalloc(alloc_size, GFP_KERNEL);\r\nif (!parts)\r\nreturn ERR_PTR(-ENOMEM);\r\nextra_mem = (unsigned char *)(parts + *num_parts);\r\n}\r\nparts[this_part].size = size;\r\nparts[this_part].offset = offset;\r\nparts[this_part].mask_flags = mask_flags;\r\nif (name)\r\nstrlcpy(extra_mem, name, name_len + 1);\r\nelse\r\nsprintf(extra_mem, "Partition_%03d", this_part);\r\nparts[this_part].name = extra_mem;\r\nextra_mem += name_len + 1;\r\ndbg(("partition %d: name <%s>, offset %llx, size %llx, mask flags %x\n",\r\nthis_part, parts[this_part].name, parts[this_part].offset,\r\nparts[this_part].size, parts[this_part].mask_flags));\r\nif (extra_mem_ptr)\r\n*extra_mem_ptr = extra_mem;\r\n*retptr = s;\r\nreturn parts;\r\n}\r\nstatic int mtdpart_setup_real(char *s)\r\n{\r\ncmdline_parsed = 1;\r\nfor( ; s != NULL; )\r\n{\r\nstruct cmdline_mtd_partition *this_mtd;\r\nstruct mtd_partition *parts;\r\nint mtd_id_len, num_parts;\r\nchar *p, *mtd_id;\r\nmtd_id = s;\r\np = strchr(s, ':');\r\nif (!p) {\r\nprintk(KERN_ERR ERRP "no mtd-id\n");\r\nreturn -EINVAL;\r\n}\r\nmtd_id_len = p - mtd_id;\r\ndbg(("parsing <%s>\n", p+1));\r\nparts = newpart(p + 1,\r\n&s,\r\n&num_parts,\r\n0,\r\n(unsigned char**)&this_mtd,\r\nmtd_id_len + 1 + sizeof(*this_mtd) +\r\nsizeof(void*)-1 );\r\nif (IS_ERR(parts)) {\r\nreturn PTR_ERR(parts);\r\n}\r\nthis_mtd = (struct cmdline_mtd_partition *)\r\nALIGN((unsigned long)this_mtd, sizeof(void *));\r\nthis_mtd->parts = parts;\r\nthis_mtd->num_parts = num_parts;\r\nthis_mtd->mtd_id = (char*)(this_mtd + 1);\r\nstrlcpy(this_mtd->mtd_id, mtd_id, mtd_id_len + 1);\r\nthis_mtd->next = partitions;\r\npartitions = this_mtd;\r\ndbg(("mtdid=<%s> num_parts=<%d>\n",\r\nthis_mtd->mtd_id, this_mtd->num_parts));\r\nif (*s == 0)\r\nbreak;\r\nif (*s != ';') {\r\nprintk(KERN_ERR ERRP "bad character after partition (%c)\n", *s);\r\nreturn -EINVAL;\r\n}\r\ns++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_cmdline_partitions(struct mtd_info *master,\r\nstruct mtd_partition **pparts,\r\nstruct mtd_part_parser_data *data)\r\n{\r\nunsigned long long offset;\r\nint i, err;\r\nstruct cmdline_mtd_partition *part;\r\nconst char *mtd_id = master->name;\r\nif (!cmdline_parsed) {\r\nerr = mtdpart_setup_real(cmdline);\r\nif (err)\r\nreturn err;\r\n}\r\nfor (part = partitions; part; part = part->next) {\r\nif ((!mtd_id) || (!strcmp(part->mtd_id, mtd_id)))\r\nbreak;\r\n}\r\nif (!part)\r\nreturn 0;\r\nfor (i = 0, offset = 0; i < part->num_parts; i++) {\r\nif (part->parts[i].offset == OFFSET_CONTINUOUS)\r\npart->parts[i].offset = offset;\r\nelse\r\noffset = part->parts[i].offset;\r\nif (part->parts[i].size == SIZE_REMAINING)\r\npart->parts[i].size = master->size - offset;\r\nif (offset + part->parts[i].size > master->size) {\r\nprintk(KERN_WARNING ERRP\r\n"%s: partitioning exceeds flash size, truncating\n",\r\npart->mtd_id);\r\npart->parts[i].size = master->size - offset;\r\n}\r\noffset += part->parts[i].size;\r\nif (part->parts[i].size == 0) {\r\nprintk(KERN_WARNING ERRP\r\n"%s: skipping zero sized partition\n",\r\npart->mtd_id);\r\npart->num_parts--;\r\nmemmove(&part->parts[i], &part->parts[i + 1],\r\nsizeof(*part->parts) * (part->num_parts - i));\r\ni--;\r\n}\r\n}\r\n*pparts = kmemdup(part->parts, sizeof(*part->parts) * part->num_parts,\r\nGFP_KERNEL);\r\nif (!*pparts)\r\nreturn -ENOMEM;\r\nreturn part->num_parts;\r\n}\r\nstatic int __init mtdpart_setup(char *s)\r\n{\r\ncmdline = s;\r\nreturn 1;\r\n}\r\nstatic int __init cmdline_parser_init(void)\r\n{\r\nif (mtdparts)\r\nmtdpart_setup(mtdparts);\r\nreturn register_mtd_parser(&cmdline_parser);\r\n}\r\nstatic void __exit cmdline_parser_exit(void)\r\n{\r\nderegister_mtd_parser(&cmdline_parser);\r\n}
