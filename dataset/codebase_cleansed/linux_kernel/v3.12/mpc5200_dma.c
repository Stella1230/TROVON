static irqreturn_t psc_dma_status_irq(int irq, void *_psc_dma)\r\n{\r\nstruct psc_dma *psc_dma = _psc_dma;\r\nstruct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;\r\nu16 isr;\r\nisr = in_be16(&regs->mpc52xx_psc_isr);\r\nif (psc_dma->playback.active && (isr & MPC52xx_PSC_IMR_TXEMP))\r\npsc_dma->stats.underrun_count++;\r\nif (psc_dma->capture.active && (isr & MPC52xx_PSC_IMR_ORERR))\r\npsc_dma->stats.overrun_count++;\r\nout_8(&regs->command, MPC52xx_PSC_RST_ERR_STAT);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void psc_dma_bcom_enqueue_next_buffer(struct psc_dma_stream *s)\r\n{\r\nstruct bcom_bd *bd;\r\nbd = bcom_prepare_next_buffer(s->bcom_task);\r\nbd->status = s->period_bytes;\r\nbd->data[0] = s->runtime->dma_addr + (s->period_next * s->period_bytes);\r\nbcom_submit_next_buffer(s->bcom_task, NULL);\r\ns->period_next = (s->period_next + 1) % s->runtime->periods;\r\n}\r\nstatic irqreturn_t psc_dma_bcom_irq(int irq, void *_psc_dma_stream)\r\n{\r\nstruct psc_dma_stream *s = _psc_dma_stream;\r\nspin_lock(&s->psc_dma->lock);\r\nwhile (bcom_buffer_done(s->bcom_task)) {\r\nbcom_retrieve_buffer(s->bcom_task, NULL, NULL);\r\ns->period_current = (s->period_current+1) % s->runtime->periods;\r\ns->period_count++;\r\npsc_dma_bcom_enqueue_next_buffer(s);\r\n}\r\nspin_unlock(&s->psc_dma->lock);\r\nif (s->active)\r\nsnd_pcm_period_elapsed(s->stream);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int psc_dma_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nsnd_pcm_set_runtime_buffer(substream, NULL);\r\nreturn 0;\r\n}\r\nstatic int psc_dma_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct psc_dma *psc_dma = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct psc_dma_stream *s = to_psc_dma_stream(substream, psc_dma);\r\nstruct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;\r\nu16 imr;\r\nunsigned long flags;\r\nint i;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ndev_dbg(psc_dma->dev, "START: stream=%i fbits=%u ps=%u #p=%u\n",\r\nsubstream->pstr->stream, runtime->frame_bits,\r\n(int)runtime->period_size, runtime->periods);\r\ns->period_bytes = frames_to_bytes(runtime,\r\nruntime->period_size);\r\ns->period_next = 0;\r\ns->period_current = 0;\r\ns->active = 1;\r\ns->period_count = 0;\r\ns->runtime = runtime;\r\nspin_lock_irqsave(&psc_dma->lock, flags);\r\nif (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nbcom_gen_bd_rx_reset(s->bcom_task);\r\nelse\r\nbcom_gen_bd_tx_reset(s->bcom_task);\r\nfor (i = 0; i < runtime->periods; i++)\r\nif (!bcom_queue_full(s->bcom_task))\r\npsc_dma_bcom_enqueue_next_buffer(s);\r\nbcom_enable(s->bcom_task);\r\nspin_unlock_irqrestore(&psc_dma->lock, flags);\r\nout_8(&regs->command, MPC52xx_PSC_RST_ERR_STAT);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ndev_dbg(psc_dma->dev, "STOP: stream=%i periods_count=%i\n",\r\nsubstream->pstr->stream, s->period_count);\r\ns->active = 0;\r\nspin_lock_irqsave(&psc_dma->lock, flags);\r\nbcom_disable(s->bcom_task);\r\nif (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nbcom_gen_bd_rx_reset(s->bcom_task);\r\nelse\r\nbcom_gen_bd_tx_reset(s->bcom_task);\r\nspin_unlock_irqrestore(&psc_dma->lock, flags);\r\nbreak;\r\ndefault:\r\ndev_dbg(psc_dma->dev, "unhandled trigger: stream=%i cmd=%i\n",\r\nsubstream->pstr->stream, cmd);\r\nreturn -EINVAL;\r\n}\r\nimr = 0;\r\nif (psc_dma->playback.active)\r\nimr |= MPC52xx_PSC_IMR_TXEMP;\r\nif (psc_dma->capture.active)\r\nimr |= MPC52xx_PSC_IMR_ORERR;\r\nout_be16(&regs->isr_imr.imr, psc_dma->imr | imr);\r\nreturn 0;\r\n}\r\nstatic int psc_dma_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct psc_dma *psc_dma = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nstruct psc_dma_stream *s;\r\nint rc;\r\ndev_dbg(psc_dma->dev, "psc_dma_open(substream=%p)\n", substream);\r\nif (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE)\r\ns = &psc_dma->capture;\r\nelse\r\ns = &psc_dma->playback;\r\nsnd_soc_set_runtime_hwparams(substream, &psc_dma_hardware);\r\nrc = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (rc < 0) {\r\ndev_err(substream->pcm->card->dev, "invalid buffer size\n");\r\nreturn rc;\r\n}\r\ns->stream = substream;\r\nreturn 0;\r\n}\r\nstatic int psc_dma_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct psc_dma *psc_dma = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nstruct psc_dma_stream *s;\r\ndev_dbg(psc_dma->dev, "psc_dma_close(substream=%p)\n", substream);\r\nif (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE)\r\ns = &psc_dma->capture;\r\nelse\r\ns = &psc_dma->playback;\r\nif (!psc_dma->playback.active &&\r\n!psc_dma->capture.active) {\r\nout_be16(&psc_dma->psc_regs->isr_imr.imr, psc_dma->imr);\r\nout_8(&psc_dma->psc_regs->command, 4 << 4);\r\n}\r\ns->stream = NULL;\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\npsc_dma_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct psc_dma *psc_dma = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nstruct psc_dma_stream *s;\r\ndma_addr_t count;\r\nif (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE)\r\ns = &psc_dma->capture;\r\nelse\r\ns = &psc_dma->playback;\r\ncount = s->period_current * s->period_bytes;\r\nreturn bytes_to_frames(substream->runtime, count);\r\n}\r\nstatic int\r\npsc_dma_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\r\nreturn 0;\r\n}\r\nstatic int psc_dma_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_card *card = rtd->card->snd_card;\r\nstruct snd_soc_dai *dai = rtd->cpu_dai;\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nstruct psc_dma *psc_dma = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nsize_t size = psc_dma_hardware.buffer_bytes_max;\r\nint rc = 0;\r\ndev_dbg(rtd->platform->dev, "psc_dma_new(card=%p, dai=%p, pcm=%p)\n",\r\ncard, dai, pcm);\r\nif (!card->dev->dma_mask)\r\ncard->dev->dma_mask = &psc_dma_dmamask;\r\nif (!card->dev->coherent_dma_mask)\r\ncard->dev->coherent_dma_mask = DMA_BIT_MASK(32);\r\nif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {\r\nrc = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, pcm->card->dev,\r\nsize, &pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream->dma_buffer);\r\nif (rc)\r\ngoto playback_alloc_err;\r\n}\r\nif (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {\r\nrc = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, pcm->card->dev,\r\nsize, &pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream->dma_buffer);\r\nif (rc)\r\ngoto capture_alloc_err;\r\n}\r\nif (rtd->codec->ac97)\r\nrtd->codec->ac97->private_data = psc_dma;\r\nreturn 0;\r\ncapture_alloc_err:\r\nif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream)\r\nsnd_dma_free_pages(&pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream->dma_buffer);\r\nplayback_alloc_err:\r\ndev_err(card->dev, "Cannot allocate buffer(s)\n");\r\nreturn -ENOMEM;\r\n}\r\nstatic void psc_dma_free(struct snd_pcm *pcm)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = pcm->private_data;\r\nstruct snd_pcm_substream *substream;\r\nint stream;\r\ndev_dbg(rtd->platform->dev, "psc_dma_free(pcm=%p)\n", pcm);\r\nfor (stream = 0; stream < 2; stream++) {\r\nsubstream = pcm->streams[stream].substream;\r\nif (substream) {\r\nsnd_dma_free_pages(&substream->dma_buffer);\r\nsubstream->dma_buffer.area = NULL;\r\nsubstream->dma_buffer.addr = 0;\r\n}\r\n}\r\n}\r\nint mpc5200_audio_dma_create(struct platform_device *op)\r\n{\r\nphys_addr_t fifo;\r\nstruct psc_dma *psc_dma;\r\nstruct resource res;\r\nint size, irq, rc;\r\nconst __be32 *prop;\r\nvoid __iomem *regs;\r\nint ret;\r\nirq = irq_of_parse_and_map(op->dev.of_node, 0);\r\nif (of_address_to_resource(op->dev.of_node, 0, &res)) {\r\ndev_err(&op->dev, "Missing reg property\n");\r\nreturn -ENODEV;\r\n}\r\nregs = ioremap(res.start, resource_size(&res));\r\nif (!regs) {\r\ndev_err(&op->dev, "Could not map registers\n");\r\nreturn -ENODEV;\r\n}\r\npsc_dma = kzalloc(sizeof *psc_dma, GFP_KERNEL);\r\nif (!psc_dma) {\r\nret = -ENOMEM;\r\ngoto out_unmap;\r\n}\r\nprop = of_get_property(op->dev.of_node, "cell-index", &size);\r\nif (!prop || size < sizeof *prop) {\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\nspin_lock_init(&psc_dma->lock);\r\nmutex_init(&psc_dma->mutex);\r\npsc_dma->id = be32_to_cpu(*prop);\r\npsc_dma->irq = irq;\r\npsc_dma->psc_regs = regs;\r\npsc_dma->fifo_regs = regs + sizeof *psc_dma->psc_regs;\r\npsc_dma->dev = &op->dev;\r\npsc_dma->playback.psc_dma = psc_dma;\r\npsc_dma->capture.psc_dma = psc_dma;\r\nsnprintf(psc_dma->name, sizeof psc_dma->name, "PSC%u", psc_dma->id);\r\nfifo = res.start + offsetof(struct mpc52xx_psc, buffer.buffer_32);\r\npsc_dma->capture.bcom_task =\r\nbcom_psc_gen_bd_rx_init(psc_dma->id, 10, fifo, 512);\r\npsc_dma->playback.bcom_task =\r\nbcom_psc_gen_bd_tx_init(psc_dma->id, 10, fifo);\r\nif (!psc_dma->capture.bcom_task ||\r\n!psc_dma->playback.bcom_task) {\r\ndev_err(&op->dev, "Could not allocate bestcomm tasks\n");\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\nout_be16(&psc_dma->psc_regs->isr_imr.imr, psc_dma->imr);\r\nout_8(&psc_dma->psc_regs->command, MPC52xx_PSC_RST_RX);\r\nout_8(&psc_dma->psc_regs->command, MPC52xx_PSC_RST_TX);\r\nout_8(&psc_dma->psc_regs->command, MPC52xx_PSC_RST_ERR_STAT);\r\nout_8(&psc_dma->psc_regs->command, MPC52xx_PSC_SEL_MODE_REG_1);\r\nout_8(&psc_dma->psc_regs->mode, 0);\r\nout_8(&psc_dma->psc_regs->mode, 0);\r\nout_be16(&psc_dma->fifo_regs->rfalarm, 0x100);\r\nout_8(&psc_dma->fifo_regs->rfcntl, 0x4);\r\nout_be16(&psc_dma->fifo_regs->tfalarm, 0x100);\r\nout_8(&psc_dma->fifo_regs->tfcntl, 0x7);\r\npsc_dma->playback.irq =\r\nbcom_get_task_irq(psc_dma->playback.bcom_task);\r\npsc_dma->capture.irq =\r\nbcom_get_task_irq(psc_dma->capture.bcom_task);\r\nrc = request_irq(psc_dma->irq, &psc_dma_status_irq, IRQF_SHARED,\r\n"psc-dma-status", psc_dma);\r\nrc |= request_irq(psc_dma->capture.irq, &psc_dma_bcom_irq, IRQF_SHARED,\r\n"psc-dma-capture", &psc_dma->capture);\r\nrc |= request_irq(psc_dma->playback.irq, &psc_dma_bcom_irq, IRQF_SHARED,\r\n"psc-dma-playback", &psc_dma->playback);\r\nif (rc) {\r\nret = -ENODEV;\r\ngoto out_irq;\r\n}\r\ndev_set_drvdata(&op->dev, psc_dma);\r\nreturn snd_soc_register_platform(&op->dev, &mpc5200_audio_dma_platform);\r\nout_irq:\r\nfree_irq(psc_dma->irq, psc_dma);\r\nfree_irq(psc_dma->capture.irq, &psc_dma->capture);\r\nfree_irq(psc_dma->playback.irq, &psc_dma->playback);\r\nout_free:\r\nkfree(psc_dma);\r\nout_unmap:\r\niounmap(regs);\r\nreturn ret;\r\n}\r\nint mpc5200_audio_dma_destroy(struct platform_device *op)\r\n{\r\nstruct psc_dma *psc_dma = dev_get_drvdata(&op->dev);\r\ndev_dbg(&op->dev, "mpc5200_audio_dma_destroy()\n");\r\nsnd_soc_unregister_platform(&op->dev);\r\nbcom_gen_bd_rx_release(psc_dma->capture.bcom_task);\r\nbcom_gen_bd_tx_release(psc_dma->playback.bcom_task);\r\nfree_irq(psc_dma->irq, psc_dma);\r\nfree_irq(psc_dma->capture.irq, &psc_dma->capture);\r\nfree_irq(psc_dma->playback.irq, &psc_dma->playback);\r\niounmap(psc_dma->psc_regs);\r\nkfree(psc_dma);\r\ndev_set_drvdata(&op->dev, NULL);\r\nreturn 0;\r\n}
