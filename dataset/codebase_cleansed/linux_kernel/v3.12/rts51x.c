static inline void usb_autopm_enable(struct usb_interface *intf)\r\n{\r\natomic_set(&intf->pm_usage_cnt, 1);\r\nusb_autopm_put_interface(intf);\r\n}\r\nstatic inline void usb_autopm_disable(struct usb_interface *intf)\r\n{\r\natomic_set(&intf->pm_usage_cnt, 0);\r\nusb_autopm_get_interface(intf);\r\n}\r\nstatic void rts51x_try_to_enter_ss(struct rts51x_chip *chip)\r\n{\r\nRTS51X_DEBUGP("Ready to enter SS state\n");\r\nusb_autopm_enable(chip->usb->pusb_intf);\r\n}\r\nvoid rts51x_try_to_exit_ss(struct rts51x_chip *chip)\r\n{\r\nRTS51X_DEBUGP("Exit from SS state\n");\r\nusb_autopm_disable(chip->usb->pusb_intf);\r\n}\r\nint rts51x_suspend(struct usb_interface *iface, pm_message_t message)\r\n{\r\nstruct rts51x_chip *chip = usb_get_intfdata(iface);\r\nRTS51X_DEBUGP("%s, message.event = 0x%x\n", __func__, message.event);\r\nmutex_lock(&chip->usb->dev_mutex);\r\nchip->fake_card_ready = chip->card_ready;\r\nrts51x_do_before_power_down(chip);\r\nif (message.event == PM_EVENT_AUTO_SUSPEND) {\r\nRTS51X_DEBUGP("Enter SS state");\r\nchip->resume_from_scsi = 0;\r\nRTS51X_SET_STAT(chip, STAT_SS);\r\n} else {\r\nRTS51X_DEBUGP("Enter SUSPEND state");\r\nRTS51X_SET_STAT(chip, STAT_SUSPEND);\r\n}\r\nmutex_unlock(&chip->usb->dev_mutex);\r\nreturn 0;\r\n}\r\nint rts51x_resume(struct usb_interface *iface)\r\n{\r\nstruct rts51x_chip *chip = usb_get_intfdata(iface);\r\nRTS51X_DEBUGP("%s\n", __func__);\r\nif (!RTS51X_CHK_STAT(chip, STAT_SS) || !chip->resume_from_scsi) {\r\nmutex_lock(&chip->usb->dev_mutex);\r\nif (chip->option.ss_en) {\r\nif (GET_PM_USAGE_CNT(chip) <= 0) {\r\nRTS51X_DEBUGP("Incr pm_usage_cnt\n");\r\nSET_PM_USAGE_CNT(chip, 1);\r\n}\r\n}\r\nRTS51X_SET_STAT(chip, STAT_RUN);\r\nrts51x_init_chip(chip);\r\nrts51x_init_cards(chip);\r\nmutex_unlock(&chip->usb->dev_mutex);\r\n}\r\nreturn 0;\r\n}\r\nint rts51x_reset_resume(struct usb_interface *iface)\r\n{\r\nstruct rts51x_chip *chip = usb_get_intfdata(iface);\r\nRTS51X_DEBUGP("%s\n", __func__);\r\nmutex_lock(&chip->usb->dev_mutex);\r\nRTS51X_SET_STAT(chip, STAT_RUN);\r\nif (chip->option.ss_en)\r\nSET_PM_USAGE_CNT(chip, 1);\r\nrts51x_init_chip(chip);\r\nrts51x_init_cards(chip);\r\nmutex_unlock(&chip->usb->dev_mutex);\r\nreturn 0;\r\n}\r\nstatic void rts51x_try_to_enter_ss(struct rts51x_chip *chip)\r\n{\r\n}\r\nvoid rts51x_try_to_exit_ss(struct rts51x_chip *chip)\r\n{\r\n}\r\nint rts51x_pre_reset(struct usb_interface *iface)\r\n{\r\nstruct rts51x_chip *chip = usb_get_intfdata(iface);\r\nRTS51X_DEBUGP("%s\n", __func__);\r\nmutex_lock(&chip->usb->dev_mutex);\r\nreturn 0;\r\n}\r\nint rts51x_post_reset(struct usb_interface *iface)\r\n{\r\nstruct rts51x_chip *chip = usb_get_intfdata(iface);\r\nRTS51X_DEBUGP("%s\n", __func__);\r\nmutex_unlock(&chip->usb->dev_mutex);\r\nreturn 0;\r\n}\r\nstatic int rts51x_control_thread(void *__chip)\r\n{\r\nstruct rts51x_chip *chip = (struct rts51x_chip *)__chip;\r\nstruct Scsi_Host *host = rts51x_to_host(chip);\r\nfor (;;) {\r\nif (wait_for_completion_interruptible(&chip->usb->cmnd_ready))\r\nbreak;\r\nif (test_bit(FLIDX_DISCONNECTING, &chip->usb->dflags)) {\r\nRTS51X_DEBUGP("-- exiting from rts51x-control\n");\r\nbreak;\r\n}\r\nmutex_lock(&(chip->usb->dev_mutex));\r\nscsi_lock(host);\r\nif (chip->srb == NULL) {\r\nscsi_unlock(host);\r\nmutex_unlock(&chip->usb->dev_mutex);\r\nRTS51X_DEBUGP("-- exiting from control thread\n");\r\nbreak;\r\n}\r\nif (test_bit(FLIDX_TIMED_OUT, &chip->usb->dflags)) {\r\nchip->srb->result = DID_ABORT << 16;\r\ngoto SkipForAbort;\r\n}\r\nscsi_unlock(host);\r\nif (chip->srb->sc_data_direction == DMA_BIDIRECTIONAL) {\r\nRTS51X_DEBUGP("UNKNOWN data direction\n");\r\nchip->srb->result = DID_ERROR << 16;\r\n}\r\nelse if (chip->srb->device->id) {\r\nRTS51X_DEBUGP("Bad target number (%d:%d)\n",\r\nchip->srb->device->id,\r\nchip->srb->device->lun);\r\nchip->srb->result = DID_BAD_TARGET << 16;\r\n}\r\nelse if (chip->srb->device->lun > chip->max_lun) {\r\nRTS51X_DEBUGP("Bad LUN (%d:%d)\n",\r\nchip->srb->device->id,\r\nchip->srb->device->lun);\r\nchip->srb->result = DID_BAD_TARGET << 16;\r\n}\r\nelse {\r\nRTS51X_DEBUG(rts51x_scsi_show_command(chip->srb));\r\nrts51x_invoke_transport(chip->srb, chip);\r\n}\r\nscsi_lock(host);\r\nif (chip->srb->result != DID_ABORT << 16)\r\nchip->srb->scsi_done(chip->srb);\r\nelse\r\nSkipForAbort :\r\nRTS51X_DEBUGP("scsi command aborted\n");\r\nif (test_bit(FLIDX_TIMED_OUT, &chip->usb->dflags)) {\r\ncomplete(&(chip->usb->notify));\r\nclear_bit(FLIDX_ABORTING, &chip->usb->dflags);\r\nclear_bit(FLIDX_TIMED_OUT, &chip->usb->dflags);\r\n}\r\nchip->srb = NULL;\r\nscsi_unlock(host);\r\nmutex_unlock(&chip->usb->dev_mutex);\r\n}\r\ncomplete(&chip->usb->control_exit);\r\nreturn 0;\r\n}\r\nstatic int rts51x_polling_thread(void *__chip)\r\n{\r\nstruct rts51x_chip *chip = (struct rts51x_chip *)__chip;\r\nfor (;;) {\r\nwait_timeout(POLLING_INTERVAL);\r\nif (test_bit(FLIDX_DISCONNECTING, &chip->usb->dflags)) {\r\nRTS51X_DEBUGP("-- exiting from rts51x-polling\n");\r\nbreak;\r\n}\r\n#ifdef CONFIG_PM\r\nif (RTS51X_CHK_STAT(chip, STAT_SS) ||\r\nRTS51X_CHK_STAT(chip, STAT_SS_PRE) ||\r\nRTS51X_CHK_STAT(chip, STAT_SUSPEND)) {\r\ncontinue;\r\n}\r\nif (ss_en) {\r\nif (RTS51X_CHK_STAT(chip, STAT_IDLE)) {\r\nif (chip->ss_counter <\r\n(ss_delay * 1000 / POLLING_INTERVAL)) {\r\nchip->ss_counter++;\r\n} else {\r\nRTS51X_SET_STAT(chip, STAT_SS_PRE);\r\nrts51x_try_to_enter_ss(chip);\r\ncontinue;\r\n}\r\n} else {\r\nchip->ss_counter = 0;\r\n}\r\n}\r\n#endif\r\nrts51x_mspro_polling_format_status(chip);\r\nmutex_lock(&(chip->usb->dev_mutex));\r\nrts51x_polling_func(chip);\r\nmutex_unlock(&chip->usb->dev_mutex);\r\n}\r\ncomplete(&chip->usb->polling_exit);\r\nreturn 0;\r\n}\r\nstatic int associate_dev(struct rts51x_chip *chip, struct usb_interface *intf)\r\n{\r\nstruct rts51x_usb *rts51x = chip->usb;\r\n#ifdef SUPPORT_FILE_OP\r\nint retval;\r\n#endif\r\nrts51x->pusb_dev = interface_to_usbdev(intf);\r\nrts51x->pusb_intf = intf;\r\nrts51x->ifnum = intf->cur_altsetting->desc.bInterfaceNumber;\r\nRTS51X_DEBUGP("Vendor: 0x%04x, Product: 0x%04x, Revision: 0x%04x\n",\r\nle16_to_cpu(rts51x->pusb_dev->descriptor.idVendor),\r\nle16_to_cpu(rts51x->pusb_dev->descriptor.idProduct),\r\nle16_to_cpu(rts51x->pusb_dev->descriptor.bcdDevice));\r\nRTS51X_DEBUGP("Interface Subclass: 0x%02x, Protocol: 0x%02x\n",\r\nintf->cur_altsetting->desc.bInterfaceSubClass,\r\nintf->cur_altsetting->desc.bInterfaceProtocol);\r\nusb_set_intfdata(intf, chip);\r\n#ifdef SUPPORT_FILE_OP\r\nretval = usb_register_dev(intf, &rts51x_class);\r\nif (retval) {\r\nRTS51X_DEBUGP("Not able to get a minor for this device.");\r\nusb_set_intfdata(intf, NULL);\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nrts51x->cr = usb_buffer_alloc(rts51x->pusb_dev, sizeof(*rts51x->cr),\r\nGFP_KERNEL, &rts51x->cr_dma);\r\nif (!rts51x->cr) {\r\nRTS51X_DEBUGP("usb_ctrlrequest allocation failed\n");\r\nusb_set_intfdata(intf, NULL);\r\nreturn -ENOMEM;\r\n}\r\nrts51x->iobuf = usb_buffer_alloc(rts51x->pusb_dev, RTS51X_IOBUF_SIZE,\r\nGFP_KERNEL, &rts51x->iobuf_dma);\r\nif (!rts51x->iobuf) {\r\nRTS51X_DEBUGP("I/O buffer allocation failed\n");\r\nusb_set_intfdata(intf, NULL);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rts51x_init_options(struct rts51x_chip *chip)\r\n{\r\nstruct rts51x_option *option = &(chip->option);\r\noption->rts51x_mspro_formatter_enable = 1;\r\noption->fpga_sd_sdr104_clk = CLK_100;\r\noption->fpga_sd_sdr50_clk = CLK_100;\r\noption->fpga_sd_ddr50_clk = CLK_100;\r\noption->fpga_sd_hs_clk = CLK_100;\r\noption->fpga_mmc_52m_clk = CLK_80;\r\noption->fpga_ms_hg_clk = CLK_80;\r\noption->fpga_ms_4bit_clk = CLK_80;\r\noption->asic_sd_sdr104_clk = 98;\r\noption->asic_sd_sdr50_clk = 98;\r\noption->asic_sd_ddr50_clk = 98;\r\noption->asic_sd_hs_clk = 97;\r\noption->asic_mmc_52m_clk = 95;\r\noption->asic_ms_hg_clk = 116;\r\noption->asic_ms_4bit_clk = 77;\r\noption->sd_ddr_tx_phase = 0;\r\noption->mmc_ddr_tx_phase = 1;\r\noption->sd_speed_prior = 0;\r\noption->sd_ctl =\r\nSD_PUSH_POINT_AUTO | SD_SAMPLE_POINT_AUTO | SUPPORT_UHS50_MMC44;\r\noption->ss_en = ss_en;\r\noption->ss_delay = ss_delay;\r\noption->auto_delink_en = auto_delink_en;\r\noption->FT2_fast_mode = 0;\r\noption->pwr_delay = 800;\r\noption->rts51x_xd_rw_step = 0;\r\noption->D3318_off_delay = 50;\r\noption->delink_delay = 100;\r\noption->rts5129_D3318_off_enable = 0;\r\noption->sd20_pad_drive = 0;\r\noption->reset_or_rw_fail_set_pad_drive = 1;\r\noption->debounce_num = 2;\r\noption->led_toggle_interval = 6;\r\noption->rts51x_xd_rwn_step = 0;\r\noption->sd_send_status_en = 0;\r\noption->sdr50_tx_phase = 0x01;\r\noption->sdr50_rx_phase = 0x05;\r\noption->ddr50_tx_phase = 0x09;\r\noption->ddr50_rx_phase = 0x06;\r\noption->sdr50_phase_sel = 0;\r\noption->sd30_pad_drive = 1;\r\noption->ms_errreg_fix = 0;\r\noption->reset_mmc_first = 0;\r\noption->speed_mmc = 1;\r\noption->led_always_on = 0;\r\n}\r\nstatic int get_pipes(struct rts51x_chip *chip)\r\n{\r\nstruct rts51x_usb *rts51x = chip->usb;\r\nstruct usb_host_interface *altsetting =\r\nrts51x->pusb_intf->cur_altsetting;\r\nint i;\r\nstruct usb_endpoint_descriptor *ep;\r\nstruct usb_endpoint_descriptor *ep_in = NULL;\r\nstruct usb_endpoint_descriptor *ep_out = NULL;\r\nstruct usb_endpoint_descriptor *ep_int = NULL;\r\nfor (i = 0; i < altsetting->desc.bNumEndpoints; i++) {\r\nep = &altsetting->endpoint[i].desc;\r\nif (usb_endpoint_xfer_bulk(ep)) {\r\nif (usb_endpoint_dir_in(ep)) {\r\nif (!ep_in)\r\nep_in = ep;\r\n} else {\r\nif (!ep_out)\r\nep_out = ep;\r\n}\r\n}\r\nelse if (usb_endpoint_is_int_in(ep)) {\r\nif (!ep_int)\r\nep_int = ep;\r\n}\r\n}\r\nif (!ep_in || !ep_out) {\r\nRTS51X_DEBUGP("Endpoint sanity check failed!"\r\n"Rejecting dev.\n");\r\nreturn -EIO;\r\n}\r\nrts51x->send_ctrl_pipe = usb_sndctrlpipe(rts51x->pusb_dev, 0);\r\nrts51x->recv_ctrl_pipe = usb_rcvctrlpipe(rts51x->pusb_dev, 0);\r\nrts51x->send_bulk_pipe = usb_sndbulkpipe(rts51x->pusb_dev,\r\nusb_endpoint_num(ep_out));\r\nrts51x->recv_bulk_pipe = usb_rcvbulkpipe(rts51x->pusb_dev,\r\nusb_endpoint_num(ep_in));\r\nif (ep_int) {\r\nrts51x->recv_intr_pipe = usb_rcvintpipe(rts51x->pusb_dev,\r\nusb_endpoint_num\r\n(ep_int));\r\nrts51x->ep_bInterval = ep_int->bInterval;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rts51x_acquire_resources(struct rts51x_chip *chip)\r\n{\r\nstruct rts51x_usb *rts51x = chip->usb;\r\nint retval;\r\nrts51x->current_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!rts51x->current_urb) {\r\nRTS51X_DEBUGP("URB allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nrts51x->intr_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!rts51x->intr_urb) {\r\nRTS51X_DEBUGP("URB allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nchip->cmd_buf = chip->rsp_buf = rts51x->iobuf;\r\nrts51x_init_options(chip);\r\nretval = rts51x_init_chip(chip);\r\nif (retval != STATUS_SUCCESS)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void rts51x_release_resources(struct rts51x_chip *chip)\r\n{\r\nRTS51X_DEBUGP("-- %s\n", __func__);\r\nRTS51X_DEBUGP("-- sending exit command to thread\n");\r\ncomplete(&chip->usb->cmnd_ready);\r\nif (chip->usb->ctl_thread)\r\nwait_for_completion(&chip->usb->control_exit);\r\nif (chip->usb->polling_thread)\r\nwait_for_completion(&chip->usb->polling_exit);\r\nwait_timeout(200);\r\nrts51x_release_chip(chip);\r\nusb_free_urb(chip->usb->current_urb);\r\nusb_free_urb(chip->usb->intr_urb);\r\n}\r\nstatic void dissociate_dev(struct rts51x_chip *chip)\r\n{\r\nstruct rts51x_usb *rts51x = chip->usb;\r\nRTS51X_DEBUGP("-- %s\n", __func__);\r\nif (rts51x->cr)\r\nusb_buffer_free(rts51x->pusb_dev, sizeof(*rts51x->cr),\r\nrts51x->cr, rts51x->cr_dma);\r\nif (rts51x->iobuf)\r\nusb_buffer_free(rts51x->pusb_dev, RTS51X_IOBUF_SIZE,\r\nrts51x->iobuf, rts51x->iobuf_dma);\r\nusb_set_intfdata(rts51x->pusb_intf, NULL);\r\n#ifdef SUPPORT_FILE_OP\r\nusb_deregister_dev(rts51x->pusb_intf, &rts51x_class);\r\n#endif\r\nkfree(rts51x);\r\nchip->usb = NULL;\r\n}\r\nstatic void quiesce_and_remove_host(struct rts51x_chip *chip)\r\n{\r\nstruct rts51x_usb *rts51x = chip->usb;\r\nstruct Scsi_Host *host = rts51x_to_host(chip);\r\nif (rts51x->pusb_dev->state == USB_STATE_NOTATTACHED)\r\nset_bit(FLIDX_DISCONNECTING, &rts51x->dflags);\r\nscsi_remove_host(host);\r\nscsi_lock(host);\r\nset_bit(FLIDX_DISCONNECTING, &rts51x->dflags);\r\nscsi_unlock(host);\r\n}\r\nstatic void release_everything(struct rts51x_chip *chip)\r\n{\r\nrts51x_release_resources(chip);\r\ndissociate_dev(chip);\r\nscsi_host_put(rts51x_to_host(chip));\r\n}\r\nstatic int rts51x_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct Scsi_Host *host;\r\nstruct rts51x_chip *chip;\r\nstruct rts51x_usb *rts51x;\r\nint result;\r\nstruct task_struct *th;\r\nRTS51X_DEBUGP("%s detected\n", RTS51X_NAME);\r\nrts51x = kzalloc(sizeof(struct rts51x_usb), GFP_KERNEL);\r\nif (!rts51x) {\r\nprintk(KERN_WARNING RTS51X_TIP\r\n"Unable to allocate rts51x_usb\n");\r\nreturn -ENOMEM;\r\n}\r\nhost = scsi_host_alloc(&rts51x_host_template, sizeof(*chip));\r\nif (!host) {\r\nprintk(KERN_WARNING RTS51X_TIP\r\n"Unable to allocate the scsi host\n");\r\nkfree(rts51x);\r\nreturn -ENOMEM;\r\n}\r\nhost->max_cmd_len = 16;\r\nchip = host_to_rts51x(host);\r\nmemset(chip, 0, sizeof(struct rts51x_chip));\r\nchip->vendor_id = id->idVendor;\r\nchip->product_id = id->idProduct;\r\nmutex_init(&(rts51x->dev_mutex));\r\ninit_completion(&rts51x->cmnd_ready);\r\ninit_completion(&rts51x->control_exit);\r\ninit_completion(&rts51x->polling_exit);\r\ninit_completion(&(rts51x->notify));\r\nchip->usb = rts51x;\r\nresult = associate_dev(chip, intf);\r\nif (result)\r\ngoto BadDevice;\r\nresult = get_pipes(chip);\r\nif (result)\r\ngoto BadDevice;\r\nresult = rts51x_acquire_resources(chip);\r\nif (result)\r\ngoto BadDevice;\r\nth = kthread_run(rts51x_control_thread, chip, RTS51X_CTL_THREAD);\r\nif (IS_ERR(th)) {\r\nprintk(KERN_WARNING RTS51X_TIP\r\n"Unable to start control thread\n");\r\nresult = PTR_ERR(th);\r\ngoto BadDevice;\r\n}\r\nrts51x->ctl_thread = th;\r\nresult = scsi_add_host(rts51x_to_host(chip), &rts51x->pusb_intf->dev);\r\nif (result) {\r\nprintk(KERN_WARNING RTS51X_TIP "Unable to add the scsi host\n");\r\ngoto BadDevice;\r\n}\r\nscsi_scan_host(rts51x_to_host(chip));\r\nth = kthread_run(rts51x_polling_thread, chip, RTS51X_POLLING_THREAD);\r\nif (IS_ERR(th)) {\r\nprintk(KERN_WARNING RTS51X_TIP\r\n"Unable to start polling thread\n");\r\nresult = PTR_ERR(th);\r\ngoto BadDevice;\r\n}\r\nrts51x->polling_thread = th;\r\n#ifdef CONFIG_PM\r\nif (ss_en) {\r\nrts51x->pusb_intf->needs_remote_wakeup = needs_remote_wakeup;\r\nSET_PM_USAGE_CNT(chip, 1);\r\nRTS51X_DEBUGP("pm_usage_cnt = %d\n", GET_PM_USAGE_CNT(chip));\r\n}\r\n#endif\r\nreturn 0;\r\nBadDevice:\r\nRTS51X_DEBUGP("rts51x_probe() failed\n");\r\nrelease_everything(chip);\r\nreturn result;\r\n}\r\nstatic void rts51x_disconnect(struct usb_interface *intf)\r\n{\r\nstruct rts51x_chip *chip = (struct rts51x_chip *)usb_get_intfdata(intf);\r\nRTS51X_DEBUGP("rts51x_disconnect() called\n");\r\nquiesce_and_remove_host(chip);\r\nrelease_everything(chip);\r\n}
