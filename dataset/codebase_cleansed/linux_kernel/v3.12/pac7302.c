static void reg_w_buf(struct gspca_dev *gspca_dev,\r\nu8 index,\r\nconst u8 *buffer, int len)\r\n{\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nmemcpy(gspca_dev->usb_buf, buffer, len);\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0,\r\nindex, gspca_dev->usb_buf, len,\r\n500);\r\nif (ret < 0) {\r\npr_err("reg_w_buf failed i: %02x error %d\n",\r\nindex, ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void reg_w(struct gspca_dev *gspca_dev,\r\nu8 index,\r\nu8 value)\r\n{\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\ngspca_dev->usb_buf[0] = value;\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, index, gspca_dev->usb_buf, 1,\r\n500);\r\nif (ret < 0) {\r\npr_err("reg_w() failed i: %02x v: %02x error %d\n",\r\nindex, value, ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void reg_w_seq(struct gspca_dev *gspca_dev,\r\nconst u8 *seq, int len)\r\n{\r\nwhile (--len >= 0) {\r\nreg_w(gspca_dev, seq[0], seq[1]);\r\nseq += 2;\r\n}\r\n}\r\nstatic void reg_w_page(struct gspca_dev *gspca_dev,\r\nconst u8 *page, int len)\r\n{\r\nint index;\r\nint ret = 0;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nfor (index = 0; index < len; index++) {\r\nif (page[index] == SKIP)\r\ncontinue;\r\ngspca_dev->usb_buf[0] = page[index];\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, index, gspca_dev->usb_buf, 1,\r\n500);\r\nif (ret < 0) {\r\npr_err("reg_w_page() failed i: %02x v: %02x error %d\n",\r\nindex, page[index], ret);\r\ngspca_dev->usb_err = ret;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void reg_w_var(struct gspca_dev *gspca_dev,\r\nconst u8 *seq,\r\nconst u8 *page3, unsigned int page3_len)\r\n{\r\nint index, len;\r\nfor (;;) {\r\nindex = *seq++;\r\nlen = *seq++;\r\nswitch (len) {\r\ncase END_OF_SEQUENCE:\r\nreturn;\r\ncase LOAD_PAGE3:\r\nreg_w_page(gspca_dev, page3, page3_len);\r\nbreak;\r\ndefault:\r\nif (len > USB_BUF_SZ) {\r\nPERR("Incorrect variable sequence");\r\nreturn;\r\n}\r\nwhile (len > 0) {\r\nif (len < 8) {\r\nreg_w_buf(gspca_dev,\r\nindex, seq, len);\r\nseq += len;\r\nbreak;\r\n}\r\nreg_w_buf(gspca_dev, index, seq, 8);\r\nseq += 8;\r\nindex += 8;\r\nlen -= 8;\r\n}\r\n}\r\n}\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\ncam = &gspca_dev->cam;\r\ncam->cam_mode = vga_mode;\r\ncam->nmodes = ARRAY_SIZE(vga_mode);\r\nsd->flags = id->driver_info;\r\nreturn 0;\r\n}\r\nstatic void setbrightcont(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i, v;\r\nstatic const u8 max[10] =\r\n{0x29, 0x33, 0x42, 0x5a, 0x6e, 0x80, 0x9f, 0xbb,\r\n0xd4, 0xec};\r\nstatic const u8 delta[10] =\r\n{0x35, 0x33, 0x33, 0x2f, 0x2a, 0x25, 0x1e, 0x17,\r\n0x11, 0x0b};\r\nreg_w(gspca_dev, 0xff, 0x00);\r\nfor (i = 0; i < 10; i++) {\r\nv = max[i];\r\nv += (sd->brightness->val - sd->brightness->maximum)\r\n* 150 / sd->brightness->maximum;\r\nv -= delta[i] * sd->contrast->val / sd->contrast->maximum;\r\nif (v < 0)\r\nv = 0;\r\nelse if (v > 0xff)\r\nv = 0xff;\r\nreg_w(gspca_dev, 0xa2 + i, v);\r\n}\r\nreg_w(gspca_dev, 0xdc, 0x01);\r\n}\r\nstatic void setcolors(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i, v;\r\nstatic const int a[9] =\r\n{217, -212, 0, -101, 170, -67, -38, -315, 355};\r\nstatic const int b[9] =\r\n{19, 106, 0, 19, 106, 1, 19, 106, 1};\r\nreg_w(gspca_dev, 0xff, 0x03);\r\nreg_w(gspca_dev, 0x11, 0x01);\r\nreg_w(gspca_dev, 0xff, 0x00);\r\nfor (i = 0; i < 9; i++) {\r\nv = a[i] * sd->saturation->val / sd->saturation->maximum;\r\nv += b[i];\r\nreg_w(gspca_dev, 0x0f + 2 * i, (v >> 8) & 0x07);\r\nreg_w(gspca_dev, 0x0f + 2 * i + 1, v);\r\n}\r\nreg_w(gspca_dev, 0xdc, 0x01);\r\n}\r\nstatic void setwhitebalance(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nreg_w(gspca_dev, 0xff, 0x00);\r\nreg_w(gspca_dev, 0xc6, sd->white_balance->val);\r\nreg_w(gspca_dev, 0xdc, 0x01);\r\n}\r\nstatic u8 rgbbalance_ctrl_to_reg_value(s32 rgb_ctrl_val)\r\n{\r\nconst unsigned int k = 1000;\r\nunsigned int norm;\r\nnorm = k * (rgb_ctrl_val - PAC7302_RGB_BALANCE_MIN)\r\n/ (PAC7302_RGB_BALANCE_MAX - PAC7302_RGB_BALANCE_MIN);\r\nreturn 64 * norm * norm / (k*k) + 32 * norm / k + 32;\r\n}\r\nstatic void setredbalance(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nreg_w(gspca_dev, 0xff, 0x00);\r\nreg_w(gspca_dev, 0x01,\r\nrgbbalance_ctrl_to_reg_value(sd->red_balance->val));\r\nreg_w(gspca_dev, 0xdc, 0x01);\r\n}\r\nstatic void setbluebalance(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nreg_w(gspca_dev, 0xff, 0x00);\r\nreg_w(gspca_dev, 0x03,\r\nrgbbalance_ctrl_to_reg_value(sd->blue_balance->val));\r\nreg_w(gspca_dev, 0xdc, 0x01);\r\n}\r\nstatic void setgain(struct gspca_dev *gspca_dev)\r\n{\r\nu8 reg10, reg12;\r\nif (gspca_dev->gain->val < 32) {\r\nreg10 = gspca_dev->gain->val;\r\nreg12 = 0;\r\n} else {\r\nreg10 = 31;\r\nreg12 = gspca_dev->gain->val - 31;\r\n}\r\nreg_w(gspca_dev, 0xff, 0x03);\r\nreg_w(gspca_dev, 0x10, reg10);\r\nreg_w(gspca_dev, 0x12, reg12);\r\nreg_w(gspca_dev, 0x11, 0x01);\r\n}\r\nstatic void setexposure(struct gspca_dev *gspca_dev)\r\n{\r\nu8 clockdiv;\r\nu16 exposure;\r\nclockdiv = (90 * gspca_dev->exposure->val + 1999) / 2000;\r\nif (clockdiv < 6)\r\nclockdiv = 6;\r\nelse if (clockdiv > 63)\r\nclockdiv = 63;\r\nif (clockdiv < 6 || clockdiv > 12)\r\nclockdiv = ((clockdiv + 2) / 3) * 3;\r\nexposure = (gspca_dev->exposure->val * 45 * 448) / (1000 * clockdiv);\r\nexposure = 448 - exposure;\r\nreg_w(gspca_dev, 0xff, 0x03);\r\nreg_w(gspca_dev, 0x02, clockdiv);\r\nreg_w(gspca_dev, 0x0e, exposure & 0xff);\r\nreg_w(gspca_dev, 0x0f, exposure >> 8);\r\nreg_w(gspca_dev, 0x11, 0x01);\r\n}\r\nstatic void sethvflip(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 data, hflip, vflip;\r\nhflip = sd->hflip->val;\r\nif (sd->flags & FL_HFLIP)\r\nhflip = !hflip;\r\nvflip = sd->vflip->val;\r\nif (sd->flags & FL_VFLIP)\r\nvflip = !vflip;\r\nreg_w(gspca_dev, 0xff, 0x03);\r\ndata = (hflip ? 0x08 : 0x00) | (vflip ? 0x04 : 0x00);\r\nreg_w(gspca_dev, 0x21, data);\r\nreg_w(gspca_dev, 0x11, 0x01);\r\n}\r\nstatic void setsharpness(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nreg_w(gspca_dev, 0xff, 0x00);\r\nreg_w(gspca_dev, 0xb6, sd->sharpness->val);\r\nreg_w(gspca_dev, 0xdc, 0x01);\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nreg_w_seq(gspca_dev, init_7302, sizeof(init_7302)/2);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\ngspca_dev->usb_err = 0;\r\nif (ctrl->id == V4L2_CID_AUTOGAIN && ctrl->is_new && ctrl->val) {\r\ngspca_dev->exposure->val = PAC7302_EXPOSURE_DEFAULT;\r\ngspca_dev->gain->val = PAC7302_GAIN_DEFAULT;\r\nsd->autogain_ignore_frames = PAC_AUTOGAIN_IGNORE_FRAMES;\r\n}\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsetbrightcont(gspca_dev);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nsetcolors(gspca_dev);\r\nbreak;\r\ncase V4L2_CID_WHITE_BALANCE_TEMPERATURE:\r\nsetwhitebalance(gspca_dev);\r\nbreak;\r\ncase V4L2_CID_RED_BALANCE:\r\nsetredbalance(gspca_dev);\r\nbreak;\r\ncase V4L2_CID_BLUE_BALANCE:\r\nsetbluebalance(gspca_dev);\r\nbreak;\r\ncase V4L2_CID_AUTOGAIN:\r\nif (gspca_dev->exposure->is_new || (ctrl->is_new && ctrl->val))\r\nsetexposure(gspca_dev);\r\nif (gspca_dev->gain->is_new || (ctrl->is_new && ctrl->val))\r\nsetgain(gspca_dev);\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\nsethvflip(gspca_dev);\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nsetsharpness(gspca_dev);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 12);\r\nsd->brightness = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 32, 1, 16);\r\nsd->contrast = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 127);\r\nsd->saturation = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 127);\r\nsd->white_balance = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_WHITE_BALANCE_TEMPERATURE,\r\n0, 255, 1, 55);\r\nsd->red_balance = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_RED_BALANCE,\r\nPAC7302_RGB_BALANCE_MIN,\r\nPAC7302_RGB_BALANCE_MAX,\r\n1, PAC7302_RGB_BALANCE_DEFAULT);\r\nsd->blue_balance = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BLUE_BALANCE,\r\nPAC7302_RGB_BALANCE_MIN,\r\nPAC7302_RGB_BALANCE_MAX,\r\n1, PAC7302_RGB_BALANCE_DEFAULT);\r\ngspca_dev->autogain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\ngspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 0, 1023, 1,\r\nPAC7302_EXPOSURE_DEFAULT);\r\ngspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 62, 1,\r\nPAC7302_GAIN_DEFAULT);\r\nsd->hflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nsd->vflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nsd->sharpness = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_SHARPNESS, 0, 15, 1, 8);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nv4l2_ctrl_cluster(2, &sd->brightness);\r\nv4l2_ctrl_auto_cluster(3, &gspca_dev->autogain, 0, false);\r\nv4l2_ctrl_cluster(2, &sd->hflip);\r\nreturn 0;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nreg_w_var(gspca_dev, start_7302,\r\npage3_7302, sizeof(page3_7302));\r\nsd->sof_read = 0;\r\nsd->autogain_ignore_frames = 0;\r\natomic_set(&sd->avg_lum, 270 + sd->brightness->val);\r\nreg_w(gspca_dev, 0xff, 0x01);\r\nreg_w(gspca_dev, 0x78, 0x01);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nreg_w(gspca_dev, 0xff, 0x01);\r\nreg_w(gspca_dev, 0x78, 0x00);\r\n}\r\nstatic void sd_stop0(struct gspca_dev *gspca_dev)\r\n{\r\nif (!gspca_dev->present)\r\nreturn;\r\nreg_w(gspca_dev, 0xff, 0x01);\r\nreg_w(gspca_dev, 0x78, 0x40);\r\n}\r\nstatic void do_autogain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint avg_lum = atomic_read(&sd->avg_lum);\r\nint desired_lum;\r\nconst int deadzone = 30;\r\nif (sd->autogain_ignore_frames < 0)\r\nreturn;\r\nif (sd->autogain_ignore_frames > 0) {\r\nsd->autogain_ignore_frames--;\r\n} else {\r\ndesired_lum = 270 + sd->brightness->val;\r\nif (gspca_expo_autogain(gspca_dev, avg_lum, desired_lum,\r\ndeadzone, PAC7302_GAIN_KNEE,\r\nPAC7302_EXPOSURE_KNEE))\r\nsd->autogain_ignore_frames =\r\nPAC_AUTOGAIN_IGNORE_FRAMES;\r\n}\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 *image;\r\nu8 *sof;\r\nsof = pac_find_sof(gspca_dev, &sd->sof_read, data, len);\r\nif (sof) {\r\nint n, lum_offset, footer_length;\r\nlum_offset = 61 + sizeof pac_sof_marker;\r\nfooter_length = 74;\r\nn = (sof - data) - (footer_length + sizeof pac_sof_marker);\r\nif (n < 0) {\r\ngspca_dev->image_len += n;\r\nn = 0;\r\n} else {\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, n);\r\n}\r\nimage = gspca_dev->image;\r\nif (image != NULL\r\n&& image[gspca_dev->image_len - 2] == 0xff\r\n&& image[gspca_dev->image_len - 1] == 0xd9)\r\ngspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\r\nn = sof - data;\r\nlen -= n;\r\ndata = sof;\r\nif (gspca_dev->last_packet_type == LAST_PACKET &&\r\nn >= lum_offset)\r\natomic_set(&sd->avg_lum, data[-lum_offset] +\r\ndata[-lum_offset + 1]);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\njpeg_header, sizeof jpeg_header);\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\nstatic int sd_dbg_s_register(struct gspca_dev *gspca_dev,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nu8 index;\r\nu8 value;\r\nif (reg->match.addr == 0 &&\r\n(reg->reg < 0x000000ff) &&\r\n(reg->val <= 0x000000ff)\r\n) {\r\nindex = reg->reg;\r\nvalue = reg->val;\r\nreg_w(gspca_dev, 0xff, 0x00);\r\nreg_w(gspca_dev, index, value);\r\nreg_w(gspca_dev, 0xdc, 0x01);\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_int_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nint ret = -EINVAL;\r\nu8 data0, data1;\r\nif (len == 2) {\r\ndata0 = data[0];\r\ndata1 = data[1];\r\nif ((data0 == 0x00 && data1 == 0x11) ||\r\n(data0 == 0x22 && data1 == 0x33) ||\r\n(data0 == 0x44 && data1 == 0x55) ||\r\n(data0 == 0x66 && data1 == 0x77) ||\r\n(data0 == 0x88 && data1 == 0x99) ||\r\n(data0 == 0xaa && data1 == 0xbb) ||\r\n(data0 == 0xcc && data1 == 0xdd) ||\r\n(data0 == 0xee && data1 == 0xff)) {\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);\r\ninput_sync(gspca_dev->input_dev);\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\r\ninput_sync(gspca_dev->input_dev);\r\nret = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
