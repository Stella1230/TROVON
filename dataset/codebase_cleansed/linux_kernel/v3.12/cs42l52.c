static bool cs42l52_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS42L52_CHIP:\r\ncase CS42L52_PWRCTL1:\r\ncase CS42L52_PWRCTL2:\r\ncase CS42L52_PWRCTL3:\r\ncase CS42L52_CLK_CTL:\r\ncase CS42L52_IFACE_CTL1:\r\ncase CS42L52_IFACE_CTL2:\r\ncase CS42L52_ADC_PGA_A:\r\ncase CS42L52_ADC_PGA_B:\r\ncase CS42L52_ANALOG_HPF_CTL:\r\ncase CS42L52_ADC_HPF_FREQ:\r\ncase CS42L52_ADC_MISC_CTL:\r\ncase CS42L52_PB_CTL1:\r\ncase CS42L52_MISC_CTL:\r\ncase CS42L52_PB_CTL2:\r\ncase CS42L52_MICA_CTL:\r\ncase CS42L52_MICB_CTL:\r\ncase CS42L52_PGAA_CTL:\r\ncase CS42L52_PGAB_CTL:\r\ncase CS42L52_PASSTHRUA_VOL:\r\ncase CS42L52_PASSTHRUB_VOL:\r\ncase CS42L52_ADCA_VOL:\r\ncase CS42L52_ADCB_VOL:\r\ncase CS42L52_ADCA_MIXER_VOL:\r\ncase CS42L52_ADCB_MIXER_VOL:\r\ncase CS42L52_PCMA_MIXER_VOL:\r\ncase CS42L52_PCMB_MIXER_VOL:\r\ncase CS42L52_BEEP_FREQ:\r\ncase CS42L52_BEEP_VOL:\r\ncase CS42L52_BEEP_TONE_CTL:\r\ncase CS42L52_TONE_CTL:\r\ncase CS42L52_MASTERA_VOL:\r\ncase CS42L52_MASTERB_VOL:\r\ncase CS42L52_HPA_VOL:\r\ncase CS42L52_HPB_VOL:\r\ncase CS42L52_SPKA_VOL:\r\ncase CS42L52_SPKB_VOL:\r\ncase CS42L52_ADC_PCM_MIXER:\r\ncase CS42L52_LIMITER_CTL1:\r\ncase CS42L52_LIMITER_CTL2:\r\ncase CS42L52_LIMITER_AT_RATE:\r\ncase CS42L52_ALC_CTL:\r\ncase CS42L52_ALC_RATE:\r\ncase CS42L52_ALC_THRESHOLD:\r\ncase CS42L52_NOISE_GATE_CTL:\r\ncase CS42L52_CLK_STATUS:\r\ncase CS42L52_BATT_COMPEN:\r\ncase CS42L52_BATT_LEVEL:\r\ncase CS42L52_SPK_STATUS:\r\ncase CS42L52_TEM_CTL:\r\ncase CS42L52_THE_FOLDBACK:\r\ncase CS42L52_CHARGE_PUMP:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool cs42l52_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS42L52_IFACE_CTL2:\r\ncase CS42L52_CLK_STATUS:\r\ncase CS42L52_BATT_LEVEL:\r\ncase CS42L52_SPK_STATUS:\r\ncase CS42L52_CHARGE_PUMP:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int cs42l52_get_clk(int mclk, int rate)\r\n{\r\nint i, ret = -EINVAL;\r\nu_int mclk1, mclk2 = 0;\r\nfor (i = 0; i < ARRAY_SIZE(clk_map_table); i++) {\r\nif (clk_map_table[i].rate == rate) {\r\nmclk1 = clk_map_table[i].mclk;\r\nif (abs(mclk - mclk1) < abs(mclk - mclk2)) {\r\nmclk2 = mclk1;\r\nret = i;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int cs42l52_set_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct cs42l52_private *cs42l52 = snd_soc_codec_get_drvdata(codec);\r\nif ((freq >= CS42L52_MIN_CLK) && (freq <= CS42L52_MAX_CLK)) {\r\ncs42l52->sysclk = freq;\r\n} else {\r\ndev_err(codec->dev, "Invalid freq parameter\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs42l52_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct cs42l52_private *cs42l52 = snd_soc_codec_get_drvdata(codec);\r\nu8 iface = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\niface = CS42L52_IFACE_CTL1_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\niface = CS42L52_IFACE_CTL1_SLAVE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\niface |= CS42L52_IFACE_CTL1_ADC_FMT_I2S |\r\nCS42L52_IFACE_CTL1_DAC_FMT_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\niface |= CS42L52_IFACE_CTL1_DAC_FMT_RIGHT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\niface |= CS42L52_IFACE_CTL1_ADC_FMT_LEFT_J |\r\nCS42L52_IFACE_CTL1_DAC_FMT_LEFT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\niface |= CS42L52_IFACE_CTL1_DSP_MODE_EN;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\niface |= CS42L52_IFACE_CTL1_INV_SCLK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\niface |= CS42L52_IFACE_CTL1_INV_SCLK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncs42l52->config.format = iface;\r\nsnd_soc_write(codec, CS42L52_IFACE_CTL1, cs42l52->config.format);\r\nreturn 0;\r\n}\r\nstatic int cs42l52_digital_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nif (mute)\r\nsnd_soc_update_bits(codec, CS42L52_PB_CTL1,\r\nCS42L52_PB_CTL1_MUTE_MASK,\r\nCS42L52_PB_CTL1_MUTE);\r\nelse\r\nsnd_soc_update_bits(codec, CS42L52_PB_CTL1,\r\nCS42L52_PB_CTL1_MUTE_MASK,\r\nCS42L52_PB_CTL1_UNMUTE);\r\nreturn 0;\r\n}\r\nstatic int cs42l52_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs42l52_private *cs42l52 = snd_soc_codec_get_drvdata(codec);\r\nu32 clk = 0;\r\nint index;\r\nindex = cs42l52_get_clk(cs42l52->sysclk, params_rate(params));\r\nif (index >= 0) {\r\ncs42l52->sysclk = clk_map_table[index].mclk;\r\nclk |= (clk_map_table[index].speed << CLK_SPEED_SHIFT) |\r\n(clk_map_table[index].group << CLK_32K_SR_SHIFT) |\r\n(clk_map_table[index].videoclk << CLK_27M_MCLK_SHIFT) |\r\n(clk_map_table[index].ratio << CLK_RATIO_SHIFT) |\r\nclk_map_table[index].mclkdiv2;\r\nsnd_soc_write(codec, CS42L52_CLK_CTL, clk);\r\n} else {\r\ndev_err(codec->dev, "can't get correct mclk\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs42l52_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct cs42l52_private *cs42l52 = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, CS42L52_PWRCTL1,\r\nCS42L52_PWRCTL1_PDN_CODEC, 0);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nregcache_cache_only(cs42l52->regmap, false);\r\nregcache_sync(cs42l52->regmap);\r\n}\r\nsnd_soc_write(codec, CS42L52_PWRCTL1, CS42L52_PWRCTL1_PDN_ALL);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_write(codec, CS42L52_PWRCTL1, CS42L52_PWRCTL1_PDN_ALL);\r\nregcache_cache_only(cs42l52->regmap, true);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int cs42l52_suspend(struct snd_soc_codec *codec)\r\n{\r\ncs42l52_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int cs42l52_resume(struct snd_soc_codec *codec)\r\n{\r\ncs42l52_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic void cs42l52_beep_work(struct work_struct *work)\r\n{\r\nstruct cs42l52_private *cs42l52 =\r\ncontainer_of(work, struct cs42l52_private, beep_work);\r\nstruct snd_soc_codec *codec = cs42l52->codec;\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nint i;\r\nint val = 0;\r\nint best = 0;\r\nif (cs42l52->beep_rate) {\r\nfor (i = 0; i < ARRAY_SIZE(beep_rates); i++) {\r\nif (abs(cs42l52->beep_rate - beep_rates[i]) <\r\nabs(cs42l52->beep_rate - beep_rates[best]))\r\nbest = i;\r\n}\r\ndev_dbg(codec->dev, "Set beep rate %dHz for requested %dHz\n",\r\nbeep_rates[best], cs42l52->beep_rate);\r\nval = (best << CS42L52_BEEP_RATE_SHIFT);\r\nsnd_soc_dapm_enable_pin(dapm, "Beep");\r\n} else {\r\ndev_dbg(codec->dev, "Disabling beep\n");\r\nsnd_soc_dapm_disable_pin(dapm, "Beep");\r\n}\r\nsnd_soc_update_bits(codec, CS42L52_BEEP_FREQ,\r\nCS42L52_BEEP_RATE_MASK, val);\r\nsnd_soc_dapm_sync(dapm);\r\n}\r\nstatic int cs42l52_beep_event(struct input_dev *dev, unsigned int type,\r\nunsigned int code, int hz)\r\n{\r\nstruct snd_soc_codec *codec = input_get_drvdata(dev);\r\nstruct cs42l52_private *cs42l52 = snd_soc_codec_get_drvdata(codec);\r\ndev_dbg(codec->dev, "Beep event %x %x\n", code, hz);\r\nswitch (code) {\r\ncase SND_BELL:\r\nif (hz)\r\nhz = 261;\r\ncase SND_TONE:\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\ncs42l52->beep_rate = hz;\r\nschedule_work(&cs42l52->beep_work);\r\nreturn 0;\r\n}\r\nstatic ssize_t cs42l52_beep_set(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct cs42l52_private *cs42l52 = dev_get_drvdata(dev);\r\nlong int time;\r\nint ret;\r\nret = kstrtol(buf, 10, &time);\r\nif (ret != 0)\r\nreturn ret;\r\ninput_event(cs42l52->beep, EV_SND, SND_TONE, time);\r\nreturn count;\r\n}\r\nstatic void cs42l52_init_beep(struct snd_soc_codec *codec)\r\n{\r\nstruct cs42l52_private *cs42l52 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\ncs42l52->beep = devm_input_allocate_device(codec->dev);\r\nif (!cs42l52->beep) {\r\ndev_err(codec->dev, "Failed to allocate beep device\n");\r\nreturn;\r\n}\r\nINIT_WORK(&cs42l52->beep_work, cs42l52_beep_work);\r\ncs42l52->beep_rate = 0;\r\ncs42l52->beep->name = "CS42L52 Beep Generator";\r\ncs42l52->beep->phys = dev_name(codec->dev);\r\ncs42l52->beep->id.bustype = BUS_I2C;\r\ncs42l52->beep->evbit[0] = BIT_MASK(EV_SND);\r\ncs42l52->beep->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);\r\ncs42l52->beep->event = cs42l52_beep_event;\r\ncs42l52->beep->dev.parent = codec->dev;\r\ninput_set_drvdata(cs42l52->beep, codec);\r\nret = input_register_device(cs42l52->beep);\r\nif (ret != 0) {\r\ncs42l52->beep = NULL;\r\ndev_err(codec->dev, "Failed to register beep device\n");\r\n}\r\nret = device_create_file(codec->dev, &dev_attr_beep);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to create keyclick file: %d\n",\r\nret);\r\n}\r\n}\r\nstatic void cs42l52_free_beep(struct snd_soc_codec *codec)\r\n{\r\nstruct cs42l52_private *cs42l52 = snd_soc_codec_get_drvdata(codec);\r\ndevice_remove_file(codec->dev, &dev_attr_beep);\r\ncancel_work_sync(&cs42l52->beep_work);\r\ncs42l52->beep = NULL;\r\nsnd_soc_update_bits(codec, CS42L52_BEEP_TONE_CTL,\r\nCS42L52_BEEP_EN_MASK, 0);\r\n}\r\nstatic void cs42l52_init_beep(struct snd_soc_codec *codec)\r\n{\r\n}\r\nstatic void cs42l52_free_beep(struct snd_soc_codec *codec)\r\n{\r\n}\r\nstatic int cs42l52_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct cs42l52_private *cs42l52 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\ncodec->control_data = cs42l52->regmap;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_REGMAP);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nregcache_cache_only(cs42l52->regmap, true);\r\ncs42l52_init_beep(codec);\r\ncs42l52_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\ncs42l52->sysclk = CS42L52_DEFAULT_CLK;\r\ncs42l52->config.format = CS42L52_DEFAULT_FORMAT;\r\nsnd_soc_update_bits(codec, CS42L52_MICA_CTL,\r\nCS42L52_MIC_CTL_TYPE_MASK,\r\ncs42l52->pdata.mica_cfg <<\r\nCS42L52_MIC_CTL_TYPE_SHIFT);\r\nsnd_soc_update_bits(codec, CS42L52_MICB_CTL,\r\nCS42L52_MIC_CTL_TYPE_MASK,\r\ncs42l52->pdata.micb_cfg <<\r\nCS42L52_MIC_CTL_TYPE_SHIFT);\r\nif (cs42l52->pdata.mica_cfg)\r\nsnd_soc_update_bits(codec, CS42L52_MICA_CTL,\r\nCS42L52_MIC_CTL_MIC_SEL_MASK,\r\ncs42l52->pdata.mica_sel <<\r\nCS42L52_MIC_CTL_MIC_SEL_SHIFT);\r\nif (cs42l52->pdata.micb_cfg)\r\nsnd_soc_update_bits(codec, CS42L52_MICB_CTL,\r\nCS42L52_MIC_CTL_MIC_SEL_MASK,\r\ncs42l52->pdata.micb_sel <<\r\nCS42L52_MIC_CTL_MIC_SEL_SHIFT);\r\nsnd_soc_update_bits(codec, CS42L52_CHARGE_PUMP,\r\nCS42L52_CHARGE_PUMP_MASK,\r\ncs42l52->pdata.chgfreq <<\r\nCS42L52_CHARGE_PUMP_SHIFT);\r\nsnd_soc_update_bits(codec, CS42L52_IFACE_CTL2,\r\nCS42L52_IFACE_CTL2_BIAS_LVL,\r\ncs42l52->pdata.micbias_lvl);\r\nreturn ret;\r\n}\r\nstatic int cs42l52_remove(struct snd_soc_codec *codec)\r\n{\r\ncs42l52_free_beep(codec);\r\ncs42l52_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int cs42l52_i2c_probe(struct i2c_client *i2c_client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct cs42l52_private *cs42l52;\r\nint ret;\r\nunsigned int devid = 0;\r\nunsigned int reg;\r\ncs42l52 = devm_kzalloc(&i2c_client->dev, sizeof(struct cs42l52_private),\r\nGFP_KERNEL);\r\nif (cs42l52 == NULL)\r\nreturn -ENOMEM;\r\ncs42l52->dev = &i2c_client->dev;\r\ncs42l52->regmap = devm_regmap_init_i2c(i2c_client, &cs42l52_regmap);\r\nif (IS_ERR(cs42l52->regmap)) {\r\nret = PTR_ERR(cs42l52->regmap);\r\ndev_err(&i2c_client->dev, "regmap_init() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(i2c_client, cs42l52);\r\nif (dev_get_platdata(&i2c_client->dev))\r\nmemcpy(&cs42l52->pdata, dev_get_platdata(&i2c_client->dev),\r\nsizeof(cs42l52->pdata));\r\nret = regmap_register_patch(cs42l52->regmap, cs42l52_threshold_patch,\r\nARRAY_SIZE(cs42l52_threshold_patch));\r\nif (ret != 0)\r\ndev_warn(cs42l52->dev, "Failed to apply regmap patch: %d\n",\r\nret);\r\nret = regmap_read(cs42l52->regmap, CS42L52_CHIP, &reg);\r\ndevid = reg & CS42L52_CHIP_ID_MASK;\r\nif (devid != CS42L52_CHIP_ID) {\r\nret = -ENODEV;\r\ndev_err(&i2c_client->dev,\r\n"CS42L52 Device ID (%X). Expected %X\n",\r\ndevid, CS42L52_CHIP_ID);\r\nreturn ret;\r\n}\r\nregcache_cache_only(cs42l52->regmap, true);\r\nret = snd_soc_register_codec(&i2c_client->dev,\r\n&soc_codec_dev_cs42l52, &cs42l52_dai, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int cs42l52_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
