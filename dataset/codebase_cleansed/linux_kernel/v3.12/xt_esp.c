static inline bool\r\nspi_match(u_int32_t min, u_int32_t max, u_int32_t spi, bool invert)\r\n{\r\nbool r;\r\npr_debug("spi_match:%c 0x%x <= 0x%x <= 0x%x\n",\r\ninvert ? '!' : ' ', min, spi, max);\r\nr = (spi >= min && spi <= max) ^ invert;\r\npr_debug(" result %s\n", r ? "PASS" : "FAILED");\r\nreturn r;\r\n}\r\nstatic bool esp_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct ip_esp_hdr *eh;\r\nstruct ip_esp_hdr _esp;\r\nconst struct xt_esp *espinfo = par->matchinfo;\r\nif (par->fragoff != 0)\r\nreturn false;\r\neh = skb_header_pointer(skb, par->thoff, sizeof(_esp), &_esp);\r\nif (eh == NULL) {\r\npr_debug("Dropping evil ESP tinygram.\n");\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\nreturn spi_match(espinfo->spis[0], espinfo->spis[1], ntohl(eh->spi),\r\n!!(espinfo->invflags & XT_ESP_INV_SPI));\r\n}\r\nstatic int esp_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_esp *espinfo = par->matchinfo;\r\nif (espinfo->invflags & ~XT_ESP_INV_MASK) {\r\npr_debug("unknown flags %X\n", espinfo->invflags);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init esp_mt_init(void)\r\n{\r\nreturn xt_register_matches(esp_mt_reg, ARRAY_SIZE(esp_mt_reg));\r\n}\r\nstatic void __exit esp_mt_exit(void)\r\n{\r\nxt_unregister_matches(esp_mt_reg, ARRAY_SIZE(esp_mt_reg));\r\n}
