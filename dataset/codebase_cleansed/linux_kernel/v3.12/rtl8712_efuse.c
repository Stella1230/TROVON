static void efuse_reg_ctrl(struct _adapter *padapter, u8 bPowerOn)\r\n{\r\nu8 tmpu8 = 0;\r\nif (true == bPowerOn) {\r\ntmpu8 = r8712_read8(padapter, EFUSE_TEST + 3);\r\ntmpu8 |= 0x80;\r\nr8712_write8(padapter, EFUSE_TEST + 3, tmpu8);\r\nmsleep(20);\r\nr8712_write8(padapter, EFUSE_CLK_CTRL, 0x03);\r\nmsleep(20);\r\n} else {\r\ntmpu8 = r8712_read8(padapter, EFUSE_TEST + 3);\r\ntmpu8 &= 0x7F;\r\nr8712_write8(padapter, EFUSE_TEST + 3, tmpu8);\r\nr8712_write8(padapter, EFUSE_CLK_CTRL, 0x02);\r\n}\r\n}\r\nu8 r8712_efuse_reg_init(struct _adapter *padapter)\r\n{\r\nreturn true;\r\n}\r\nvoid r8712_efuse_reg_uninit(struct _adapter *padapter)\r\n{\r\nefuse_reg_ctrl(padapter, false);\r\n}\r\nstatic u8 efuse_one_byte_read(struct _adapter *padapter, u16 addr, u8 *data)\r\n{\r\nu8 tmpidx = 0, bResult;\r\nr8712_write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF));\r\nr8712_write8(padapter, EFUSE_CTRL+2, ((u8)((addr>>8)&0x03)) |\r\n(r8712_read8(padapter, EFUSE_CTRL+2)&0xFC));\r\nr8712_write8(padapter, EFUSE_CTRL+3, 0x72);\r\nwhile (!(0x80 & r8712_read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 100))\r\ntmpidx++;\r\nif (tmpidx < 100) {\r\n*data = r8712_read8(padapter, EFUSE_CTRL);\r\nbResult = true;\r\n} else {\r\n*data = 0xff;\r\nbResult = false;\r\n}\r\nreturn bResult;\r\n}\r\nstatic u8 efuse_one_byte_write(struct _adapter *padapter, u16 addr, u8 data)\r\n{\r\nu8 tmpidx = 0, bResult;\r\nr8712_write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF));\r\nr8712_write8(padapter, EFUSE_CTRL+2, ((u8)((addr>>8)&0x03)) |\r\n(r8712_read8(padapter, EFUSE_CTRL+2)&0xFC));\r\nr8712_write8(padapter, EFUSE_CTRL, data);\r\nr8712_write8(padapter, EFUSE_CTRL+3, 0xF2);\r\nwhile ((0x80 & r8712_read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 100))\r\ntmpidx++;\r\nif (tmpidx < 100)\r\nbResult = true;\r\nelse\r\nbResult = false;\r\nreturn bResult;\r\n}\r\nstatic u8 efuse_one_byte_rw(struct _adapter *padapter, u8 bRead, u16 addr,\r\nu8 *data)\r\n{\r\nu8 tmpidx = 0, tmpv8 = 0, bResult;\r\nr8712_write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF));\r\ntmpv8 = ((u8)((addr >> 8) & 0x03)) |\r\n(r8712_read8(padapter, EFUSE_CTRL + 2) & 0xFC);\r\nr8712_write8(padapter, EFUSE_CTRL+2, tmpv8);\r\nif (true == bRead) {\r\nr8712_write8(padapter, EFUSE_CTRL+3, 0x72);\r\nwhile (!(0x80 & r8712_read8(padapter, EFUSE_CTRL+3)) &&\r\n(tmpidx < 100))\r\ntmpidx++;\r\nif (tmpidx < 100) {\r\n*data = r8712_read8(padapter, EFUSE_CTRL);\r\nbResult = true;\r\n} else {\r\n*data = 0;\r\nbResult = false;\r\n}\r\n} else {\r\nr8712_write8(padapter, EFUSE_CTRL, *data);\r\nr8712_write8(padapter, EFUSE_CTRL+3, 0xF2);\r\nwhile ((0x80 & r8712_read8(padapter, EFUSE_CTRL+3)) &&\r\n(tmpidx < 100))\r\ntmpidx++;\r\nif (tmpidx < 100)\r\nbResult = true;\r\nelse\r\nbResult = false;\r\n}\r\nreturn bResult;\r\n}\r\nstatic u8 efuse_is_empty(struct _adapter *padapter, u8 *empty)\r\n{\r\nu8 value, ret = true;\r\nif (efuse_one_byte_rw(padapter, true, 0, &value) == true) {\r\nif (0xFF == value)\r\n*empty = true;\r\nelse\r\n*empty = false;\r\n} else\r\nret = false;\r\nreturn ret;\r\n}\r\nvoid r8712_efuse_change_max_size(struct _adapter *padapter)\r\n{\r\nu16 pre_pg_data_saddr = 0x1FB;\r\nu16 i;\r\nu16 pre_pg_data_size = 5;\r\nu8 pre_pg_data[5];\r\nfor (i = 0; i < pre_pg_data_size; i++)\r\nefuse_one_byte_read(padapter, pre_pg_data_saddr + i,\r\n&pre_pg_data[i]);\r\nif ((pre_pg_data[0] == 0x03) && (pre_pg_data[1] == 0x00) &&\r\n(pre_pg_data[2] == 0x00) && (pre_pg_data[3] == 0x00) &&\r\n(pre_pg_data[4] == 0x0C))\r\nefuse_available_max_size -= pre_pg_data_size;\r\n}\r\nint r8712_efuse_get_max_size(struct _adapter *padapter)\r\n{\r\nreturn efuse_available_max_size;\r\n}\r\nstatic u8 calculate_word_cnts(const u8 word_en)\r\n{\r\nu8 word_cnts = 0;\r\nu8 word_idx;\r\nfor (word_idx = 0; word_idx < PGPKG_MAX_WORDS; word_idx++)\r\nif (!(word_en & BIT(word_idx)))\r\nword_cnts++;\r\nreturn word_cnts;\r\n}\r\nstatic void pgpacket_copy_data(const u8 word_en, const u8 *sourdata,\r\nu8 *targetdata)\r\n{\r\nu8 tmpindex = 0;\r\nu8 word_idx, byte_idx;\r\nfor (word_idx = 0; word_idx < PGPKG_MAX_WORDS; word_idx++) {\r\nif (!(word_en&BIT(word_idx))) {\r\nbyte_idx = word_idx * 2;\r\ntargetdata[byte_idx] = sourdata[tmpindex++];\r\ntargetdata[byte_idx + 1] = sourdata[tmpindex++];\r\n}\r\n}\r\n}\r\nu16 r8712_efuse_get_current_size(struct _adapter *padapter)\r\n{\r\nint bContinual = true;\r\nu16 efuse_addr = 0;\r\nu8 hoffset = 0, hworden = 0;\r\nu8 efuse_data, word_cnts = 0;\r\nwhile (bContinual && efuse_one_byte_read(padapter, efuse_addr,\r\n&efuse_data) && (efuse_addr < efuse_available_max_size)) {\r\nif (efuse_data != 0xFF) {\r\nhoffset = (efuse_data >> 4) & 0x0F;\r\nhworden = efuse_data & 0x0F;\r\nword_cnts = calculate_word_cnts(hworden);\r\nefuse_addr = efuse_addr + (word_cnts * 2) + 1;\r\n} else\r\nbContinual = false ;\r\n}\r\nreturn efuse_addr;\r\n}\r\nu8 r8712_efuse_pg_packet_read(struct _adapter *padapter, u8 offset, u8 *data)\r\n{\r\nu8 hoffset = 0, hworden = 0, word_cnts = 0;\r\nu16 efuse_addr = 0;\r\nu8 efuse_data;\r\nu8 tmpidx = 0;\r\nu8 tmpdata[PGPKT_DATA_SIZE];\r\nu8 ret = true;\r\nif (data == NULL)\r\nreturn false;\r\nif (offset > 0x0f)\r\nreturn false;\r\nmemset(data, 0xFF, sizeof(u8)*PGPKT_DATA_SIZE);\r\nwhile (efuse_addr < efuse_available_max_size) {\r\nif (efuse_one_byte_read(padapter, efuse_addr, &efuse_data) ==\r\ntrue) {\r\nif (efuse_data == 0xFF)\r\nbreak;\r\nhoffset = (efuse_data >> 4) & 0x0F;\r\nhworden = efuse_data & 0x0F;\r\nword_cnts = calculate_word_cnts(hworden);\r\nif (hoffset == offset) {\r\nmemset(tmpdata, 0xFF, PGPKT_DATA_SIZE);\r\nfor (tmpidx = 0; tmpidx < word_cnts * 2;\r\ntmpidx++) {\r\nif (efuse_one_byte_read(padapter,\r\nefuse_addr+1+tmpidx, &efuse_data) ==\r\ntrue) {\r\ntmpdata[tmpidx] = efuse_data;\r\n} else\r\nret = false;\r\n}\r\npgpacket_copy_data(hworden, tmpdata, data);\r\n}\r\nefuse_addr += 1 + (word_cnts*2);\r\n} else {\r\nret = false;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)\r\n{\r\nstruct PGPKT_STRUCT pkt;\r\nu8 offset, word_en, value;\r\nu16 addr;\r\nint i;\r\nu8 ret = true;\r\npkt.offset = GET_EFUSE_OFFSET(header);\r\npkt.word_en = GET_EFUSE_WORD_EN(header);\r\naddr = header_addr + 1 + calculate_word_cnts(pkt.word_en) * 2;\r\nif (addr > efuse_available_max_size)\r\nreturn false;\r\naddr = 0;\r\nwhile (addr < header_addr) {\r\nif (efuse_one_byte_read(padapter, addr++, &value) == false) {\r\nret = false;\r\nbreak;\r\n}\r\noffset = GET_EFUSE_OFFSET(value);\r\nword_en = GET_EFUSE_WORD_EN(value);\r\nif (pkt.offset != offset) {\r\naddr += calculate_word_cnts(word_en)*2;\r\ncontinue;\r\n}\r\nfor (i = 0; i < PGPKG_MAX_WORDS; i++) {\r\nif (BIT(i) & word_en) {\r\nif (BIT(i) & pkt.word_en) {\r\nif (efuse_one_byte_read(\r\npadapter, addr,\r\n&value) == true)\r\npkt.data[i*2] = value;\r\nelse\r\nreturn false;\r\nif (efuse_one_byte_read(\r\npadapter,\r\naddr + 1,\r\n&value) == true)\r\npkt.data[i*2 + 1] =\r\nvalue;\r\nelse\r\nreturn false;\r\n}\r\naddr += 2;\r\n}\r\n}\r\n}\r\nif (addr != header_addr)\r\nreturn false;\r\naddr++;\r\nfor (i = 0; i < PGPKG_MAX_WORDS; i++) {\r\nif (BIT(i) & pkt.word_en) {\r\nefuse_one_byte_write(padapter, addr, pkt.data[i*2]);\r\nefuse_one_byte_write(padapter, addr+1,\r\npkt.data[i*2 + 1]);\r\nif (efuse_one_byte_read(padapter, addr, &value)\r\n== false)\r\nret = false;\r\nelse if (pkt.data[i*2] != value) {\r\nret = false;\r\nif (0xFF == value)\r\nefuse_one_byte_write(padapter, addr,\r\npkt.data[i * 2]);\r\n}\r\nif (efuse_one_byte_read(padapter, addr+1, &value) ==\r\nfalse)\r\nret = false;\r\nelse if (pkt.data[i*2 + 1] != value) {\r\nret = false;\r\nif (0xFF == value)\r\nefuse_one_byte_write(padapter, addr+1,\r\npkt.data[i*2 + 1]);\r\n}\r\n}\r\naddr += 2;\r\n}\r\nreturn ret;\r\n}\r\nu8 r8712_efuse_pg_packet_write(struct _adapter *padapter, const u8 offset,\r\nconst u8 word_en, const u8 *data)\r\n{\r\nu8 pg_header = 0;\r\nu16 efuse_addr = 0, curr_size = 0;\r\nu8 efuse_data, target_word_cnts = 0;\r\nstatic int repeat_times;\r\nint sub_repeat;\r\nu8 bResult = true;\r\nefuse_data = r8712_read8(padapter, EFUSE_CLK_CTRL);\r\nif (efuse_data != 0x03)\r\nreturn false;\r\npg_header = MAKE_EFUSE_HEADER(offset, word_en);\r\ntarget_word_cnts = calculate_word_cnts(word_en);\r\nrepeat_times = 0;\r\nefuse_addr = 0;\r\nwhile (efuse_addr < efuse_available_max_size) {\r\ncurr_size = r8712_efuse_get_current_size(padapter);\r\nif ((curr_size + 1 + target_word_cnts * 2) >\r\nefuse_available_max_size)\r\nreturn false;\r\nefuse_addr = curr_size;\r\nefuse_one_byte_write(padapter, efuse_addr, pg_header);\r\nsub_repeat = 0;\r\nwhile (efuse_one_byte_read(padapter, efuse_addr,\r\n&efuse_data) == false) {\r\nif (++sub_repeat > _REPEAT_THRESHOLD_) {\r\nbResult = false;\r\nbreak;\r\n}\r\n}\r\nif ((sub_repeat > _REPEAT_THRESHOLD_) ||\r\n(pg_header == efuse_data)) {\r\nu8 i;\r\nefuse_addr++;\r\nfor (i = 0; i < target_word_cnts*2; i++) {\r\nefuse_one_byte_write(padapter,\r\nefuse_addr + i,\r\n*(data + i));\r\nif (efuse_one_byte_read(padapter,\r\nefuse_addr + i, &efuse_data) == false)\r\nbResult = false;\r\nelse if (*(data+i) != efuse_data)\r\nbResult = false;\r\n}\r\nbreak;\r\n} else {\r\nbResult = false;\r\nif (0xFF == efuse_data)\r\nreturn bResult;\r\nif (fix_header(padapter, efuse_data, efuse_addr) ==\r\nfalse)\r\nreturn false;\r\nif (++repeat_times > _REPEAT_THRESHOLD_)\r\nbreak;\r\n}\r\n}\r\nreturn bResult;\r\n}\r\nu8 r8712_efuse_access(struct _adapter *padapter, u8 bRead, u16 start_addr,\r\nu16 cnts, u8 *data)\r\n{\r\nint i;\r\nu8 res = true;\r\nif (start_addr > EFUSE_MAX_SIZE)\r\nreturn false;\r\nif ((bRead == false) && ((start_addr + cnts) >\r\nefuse_available_max_size))\r\nreturn false;\r\nif ((false == bRead) && (r8712_efuse_reg_init(padapter) == false))\r\nreturn false;\r\nfor (i = 0; i < cnts; i++) {\r\nif ((start_addr + i) > EFUSE_MAX_SIZE) {\r\nres = false;\r\nbreak;\r\n}\r\nres = efuse_one_byte_rw(padapter, bRead, start_addr + i,\r\ndata + i);\r\nif ((false == bRead) && (false == res))\r\nbreak;\r\n}\r\nif (false == bRead)\r\nr8712_efuse_reg_uninit(padapter);\r\nreturn res;\r\n}\r\nu8 r8712_efuse_map_read(struct _adapter *padapter, u16 addr, u16 cnts, u8 *data)\r\n{\r\nu8 offset, ret = true;\r\nu8 pktdata[PGPKT_DATA_SIZE];\r\nint i, idx;\r\nif ((addr + cnts) > EFUSE_MAP_MAX_SIZE)\r\nreturn false;\r\nif ((efuse_is_empty(padapter, &offset) == true) && (offset ==\r\ntrue)) {\r\nfor (i = 0; i < cnts; i++)\r\ndata[i] = 0xFF;\r\nreturn ret;\r\n}\r\noffset = (addr >> 3) & 0xF;\r\nret = r8712_efuse_pg_packet_read(padapter, offset, pktdata);\r\ni = addr & 0x7;\r\nidx = 0;\r\ndo {\r\nfor (; i < PGPKT_DATA_SIZE; i++) {\r\ndata[idx++] = pktdata[i];\r\nif (idx == cnts)\r\nreturn ret;\r\n}\r\noffset++;\r\nif (!r8712_efuse_pg_packet_read(padapter, offset, pktdata))\r\nret = false;\r\ni = 0;\r\n} while (1);\r\nreturn ret;\r\n}\r\nu8 r8712_efuse_map_write(struct _adapter *padapter, u16 addr, u16 cnts,\r\nu8 *data)\r\n{\r\nu8 offset, word_en, empty;\r\nu8 pktdata[PGPKT_DATA_SIZE], newdata[PGPKT_DATA_SIZE];\r\nint i, j, idx;\r\nif ((addr + cnts) > EFUSE_MAP_MAX_SIZE)\r\nreturn false;\r\nempty = r8712_read8(padapter, EFUSE_CLK_CTRL);\r\nif (empty != 0x03)\r\nreturn false;\r\nif (efuse_is_empty(padapter, &empty) == true) {\r\nif (true == empty)\r\nmemset(pktdata, 0xFF, PGPKT_DATA_SIZE);\r\n} else\r\nreturn false;\r\noffset = (addr >> 3) & 0xF;\r\nif (empty == false)\r\nif (!r8712_efuse_pg_packet_read(padapter, offset, pktdata))\r\nreturn false;\r\nword_en = 0xF;\r\nmemset(newdata, 0xFF, PGPKT_DATA_SIZE);\r\ni = addr & 0x7;\r\nj = 0;\r\nidx = 0;\r\nif (i & 0x1) {\r\nif (data[idx] != pktdata[i]) {\r\nword_en &= ~BIT(i >> 1);\r\nnewdata[j++] = pktdata[i - 1];\r\nnewdata[j++] = data[idx];\r\n}\r\ni++;\r\nidx++;\r\n}\r\ndo {\r\nfor (; i < PGPKT_DATA_SIZE; i += 2) {\r\nif ((cnts - idx) == 1) {\r\nif (data[idx] != pktdata[i]) {\r\nword_en &= ~BIT(i >> 1);\r\nnewdata[j++] = data[idx];\r\nnewdata[j++] = pktdata[1 + 1];\r\n}\r\nidx++;\r\nbreak;\r\n} else {\r\nif ((data[idx] != pktdata[i]) || (data[idx+1] !=\r\npktdata[i+1])) {\r\nword_en &= ~BIT(i >> 1);\r\nnewdata[j++] = data[idx];\r\nnewdata[j++] = data[idx + 1];\r\n}\r\nidx += 2;\r\n}\r\nif (idx == cnts)\r\nbreak;\r\n}\r\nif (word_en != 0xF)\r\nif (r8712_efuse_pg_packet_write(padapter, offset,\r\nword_en, newdata) == false)\r\nreturn false;\r\nif (idx == cnts)\r\nbreak;\r\noffset++;\r\nif (empty == false)\r\nif (!r8712_efuse_pg_packet_read(padapter, offset,\r\npktdata))\r\nreturn false;\r\ni = 0;\r\nj = 0;\r\nword_en = 0xF;\r\nmemset(newdata, 0xFF, PGPKT_DATA_SIZE);\r\n} while (1);\r\nreturn true;\r\n}
