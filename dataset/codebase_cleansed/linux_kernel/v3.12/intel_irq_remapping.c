static struct irq_2_iommu *irq_2_iommu(unsigned int irq)\r\n{\r\nstruct irq_cfg *cfg = irq_get_chip_data(irq);\r\nreturn cfg ? &cfg->irq_2_iommu : NULL;\r\n}\r\nint get_irte(int irq, struct irte *entry)\r\n{\r\nstruct irq_2_iommu *irq_iommu = irq_2_iommu(irq);\r\nunsigned long flags;\r\nint index;\r\nif (!entry || !irq_iommu)\r\nreturn -1;\r\nraw_spin_lock_irqsave(&irq_2_ir_lock, flags);\r\nindex = irq_iommu->irte_index + irq_iommu->sub_handle;\r\n*entry = *(irq_iommu->iommu->ir_table->base + index);\r\nraw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int alloc_irte(struct intel_iommu *iommu, int irq, u16 count)\r\n{\r\nstruct ir_table *table = iommu->ir_table;\r\nstruct irq_2_iommu *irq_iommu = irq_2_iommu(irq);\r\nstruct irq_cfg *cfg = irq_get_chip_data(irq);\r\nu16 index, start_index;\r\nunsigned int mask = 0;\r\nunsigned long flags;\r\nint i;\r\nif (!count || !irq_iommu)\r\nreturn -1;\r\nindex = start_index = 0;\r\nif (count > 1) {\r\ncount = __roundup_pow_of_two(count);\r\nmask = ilog2(count);\r\n}\r\nif (mask > ecap_max_handle_mask(iommu->ecap)) {\r\nprintk(KERN_ERR\r\n"Requested mask %x exceeds the max invalidation handle"\r\n" mask value %Lx\n", mask,\r\necap_max_handle_mask(iommu->ecap));\r\nreturn -1;\r\n}\r\nraw_spin_lock_irqsave(&irq_2_ir_lock, flags);\r\ndo {\r\nfor (i = index; i < index + count; i++)\r\nif (table->base[i].present)\r\nbreak;\r\nif (i == index + count)\r\nbreak;\r\nindex = (index + count) % INTR_REMAP_TABLE_ENTRIES;\r\nif (index == start_index) {\r\nraw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\r\nprintk(KERN_ERR "can't allocate an IRTE\n");\r\nreturn -1;\r\n}\r\n} while (1);\r\nfor (i = index; i < index + count; i++)\r\ntable->base[i].present = 1;\r\ncfg->remapped = 1;\r\nirq_iommu->iommu = iommu;\r\nirq_iommu->irte_index = index;\r\nirq_iommu->sub_handle = 0;\r\nirq_iommu->irte_mask = mask;\r\nraw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\r\nreturn index;\r\n}\r\nstatic int qi_flush_iec(struct intel_iommu *iommu, int index, int mask)\r\n{\r\nstruct qi_desc desc;\r\ndesc.low = QI_IEC_IIDEX(index) | QI_IEC_TYPE | QI_IEC_IM(mask)\r\n| QI_IEC_SELECTIVE;\r\ndesc.high = 0;\r\nreturn qi_submit_sync(&desc, iommu);\r\n}\r\nstatic int map_irq_to_irte_handle(int irq, u16 *sub_handle)\r\n{\r\nstruct irq_2_iommu *irq_iommu = irq_2_iommu(irq);\r\nunsigned long flags;\r\nint index;\r\nif (!irq_iommu)\r\nreturn -1;\r\nraw_spin_lock_irqsave(&irq_2_ir_lock, flags);\r\n*sub_handle = irq_iommu->sub_handle;\r\nindex = irq_iommu->irte_index;\r\nraw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\r\nreturn index;\r\n}\r\nstatic int set_irte_irq(int irq, struct intel_iommu *iommu, u16 index, u16 subhandle)\r\n{\r\nstruct irq_2_iommu *irq_iommu = irq_2_iommu(irq);\r\nstruct irq_cfg *cfg = irq_get_chip_data(irq);\r\nunsigned long flags;\r\nif (!irq_iommu)\r\nreturn -1;\r\nraw_spin_lock_irqsave(&irq_2_ir_lock, flags);\r\ncfg->remapped = 1;\r\nirq_iommu->iommu = iommu;\r\nirq_iommu->irte_index = index;\r\nirq_iommu->sub_handle = subhandle;\r\nirq_iommu->irte_mask = 0;\r\nraw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int modify_irte(int irq, struct irte *irte_modified)\r\n{\r\nstruct irq_2_iommu *irq_iommu = irq_2_iommu(irq);\r\nstruct intel_iommu *iommu;\r\nunsigned long flags;\r\nstruct irte *irte;\r\nint rc, index;\r\nif (!irq_iommu)\r\nreturn -1;\r\nraw_spin_lock_irqsave(&irq_2_ir_lock, flags);\r\niommu = irq_iommu->iommu;\r\nindex = irq_iommu->irte_index + irq_iommu->sub_handle;\r\nirte = &iommu->ir_table->base[index];\r\nset_64bit(&irte->low, irte_modified->low);\r\nset_64bit(&irte->high, irte_modified->high);\r\n__iommu_flush_cache(iommu, irte, sizeof(*irte));\r\nrc = qi_flush_iec(iommu, index, 0);\r\nraw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\r\nreturn rc;\r\n}\r\nstatic struct intel_iommu *map_hpet_to_ir(u8 hpet_id)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_HPET_TBS; i++)\r\nif (ir_hpet[i].id == hpet_id)\r\nreturn ir_hpet[i].iommu;\r\nreturn NULL;\r\n}\r\nstatic struct intel_iommu *map_ioapic_to_ir(int apic)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_IO_APICS; i++)\r\nif (ir_ioapic[i].id == apic)\r\nreturn ir_ioapic[i].iommu;\r\nreturn NULL;\r\n}\r\nstatic struct intel_iommu *map_dev_to_ir(struct pci_dev *dev)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\ndrhd = dmar_find_matched_drhd_unit(dev);\r\nif (!drhd)\r\nreturn NULL;\r\nreturn drhd->iommu;\r\n}\r\nstatic int clear_entries(struct irq_2_iommu *irq_iommu)\r\n{\r\nstruct irte *start, *entry, *end;\r\nstruct intel_iommu *iommu;\r\nint index;\r\nif (irq_iommu->sub_handle)\r\nreturn 0;\r\niommu = irq_iommu->iommu;\r\nindex = irq_iommu->irte_index + irq_iommu->sub_handle;\r\nstart = iommu->ir_table->base + index;\r\nend = start + (1 << irq_iommu->irte_mask);\r\nfor (entry = start; entry < end; entry++) {\r\nset_64bit(&entry->low, 0);\r\nset_64bit(&entry->high, 0);\r\n}\r\nreturn qi_flush_iec(iommu, index, irq_iommu->irte_mask);\r\n}\r\nstatic int free_irte(int irq)\r\n{\r\nstruct irq_2_iommu *irq_iommu = irq_2_iommu(irq);\r\nunsigned long flags;\r\nint rc;\r\nif (!irq_iommu)\r\nreturn -1;\r\nraw_spin_lock_irqsave(&irq_2_ir_lock, flags);\r\nrc = clear_entries(irq_iommu);\r\nirq_iommu->iommu = NULL;\r\nirq_iommu->irte_index = 0;\r\nirq_iommu->sub_handle = 0;\r\nirq_iommu->irte_mask = 0;\r\nraw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\r\nreturn rc;\r\n}\r\nstatic void set_irte_sid(struct irte *irte, unsigned int svt,\r\nunsigned int sq, unsigned int sid)\r\n{\r\nif (disable_sourceid_checking)\r\nsvt = SVT_NO_VERIFY;\r\nirte->svt = svt;\r\nirte->sq = sq;\r\nirte->sid = sid;\r\n}\r\nstatic int set_ioapic_sid(struct irte *irte, int apic)\r\n{\r\nint i;\r\nu16 sid = 0;\r\nif (!irte)\r\nreturn -1;\r\nfor (i = 0; i < MAX_IO_APICS; i++) {\r\nif (ir_ioapic[i].id == apic) {\r\nsid = (ir_ioapic[i].bus << 8) | ir_ioapic[i].devfn;\r\nbreak;\r\n}\r\n}\r\nif (sid == 0) {\r\npr_warning("Failed to set source-id of IOAPIC (%d)\n", apic);\r\nreturn -1;\r\n}\r\nset_irte_sid(irte, 1, 0, sid);\r\nreturn 0;\r\n}\r\nstatic int set_hpet_sid(struct irte *irte, u8 id)\r\n{\r\nint i;\r\nu16 sid = 0;\r\nif (!irte)\r\nreturn -1;\r\nfor (i = 0; i < MAX_HPET_TBS; i++) {\r\nif (ir_hpet[i].id == id) {\r\nsid = (ir_hpet[i].bus << 8) | ir_hpet[i].devfn;\r\nbreak;\r\n}\r\n}\r\nif (sid == 0) {\r\npr_warning("Failed to set source-id of HPET block (%d)\n", id);\r\nreturn -1;\r\n}\r\nset_irte_sid(irte, SVT_VERIFY_SID_SQ, SQ_13_IGNORE_3, sid);\r\nreturn 0;\r\n}\r\nstatic int set_msi_sid(struct irte *irte, struct pci_dev *dev)\r\n{\r\nstruct pci_dev *bridge;\r\nif (!irte || !dev)\r\nreturn -1;\r\nif (pci_is_pcie(dev) || !dev->bus->parent) {\r\nset_irte_sid(irte, SVT_VERIFY_SID_SQ, SQ_ALL_16,\r\n(dev->bus->number << 8) | dev->devfn);\r\nreturn 0;\r\n}\r\nbridge = pci_find_upstream_pcie_bridge(dev);\r\nif (bridge) {\r\nif (pci_is_pcie(bridge))\r\nset_irte_sid(irte, SVT_VERIFY_BUS, SQ_ALL_16,\r\n(bridge->bus->number << 8) | dev->bus->number);\r\nelse\r\nset_irte_sid(irte, SVT_VERIFY_SID_SQ, SQ_ALL_16,\r\n(bridge->bus->number << 8) | bridge->devfn);\r\n}\r\nreturn 0;\r\n}\r\nstatic void iommu_set_irq_remapping(struct intel_iommu *iommu, int mode)\r\n{\r\nu64 addr;\r\nu32 sts;\r\nunsigned long flags;\r\naddr = virt_to_phys((void *)iommu->ir_table->base);\r\nraw_spin_lock_irqsave(&iommu->register_lock, flags);\r\ndmar_writeq(iommu->reg + DMAR_IRTA_REG,\r\n(addr) | IR_X2APIC_MODE(mode) | INTR_REMAP_TABLE_REG_SIZE);\r\niommu->gcmd |= DMA_GCMD_SIRTP;\r\nwritel(iommu->gcmd, iommu->reg + DMAR_GCMD_REG);\r\nIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\r\nreadl, (sts & DMA_GSTS_IRTPS), sts);\r\nraw_spin_unlock_irqrestore(&iommu->register_lock, flags);\r\nqi_global_iec(iommu);\r\nraw_spin_lock_irqsave(&iommu->register_lock, flags);\r\niommu->gcmd |= DMA_GCMD_IRE;\r\niommu->gcmd &= ~DMA_GCMD_CFI;\r\nwritel(iommu->gcmd, iommu->reg + DMAR_GCMD_REG);\r\nIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\r\nreadl, (sts & DMA_GSTS_IRES), sts);\r\nif (sts & DMA_GSTS_CFIS)\r\nWARN(1, KERN_WARNING\r\n"Compatibility-format IRQs enabled despite intr remapping;\n"\r\n"you are vulnerable to IRQ injection.\n");\r\nraw_spin_unlock_irqrestore(&iommu->register_lock, flags);\r\n}\r\nstatic int intel_setup_irq_remapping(struct intel_iommu *iommu, int mode)\r\n{\r\nstruct ir_table *ir_table;\r\nstruct page *pages;\r\nir_table = iommu->ir_table = kzalloc(sizeof(struct ir_table),\r\nGFP_ATOMIC);\r\nif (!iommu->ir_table)\r\nreturn -ENOMEM;\r\npages = alloc_pages_node(iommu->node, GFP_ATOMIC | __GFP_ZERO,\r\nINTR_REMAP_PAGE_ORDER);\r\nif (!pages) {\r\nprintk(KERN_ERR "failed to allocate pages of order %d\n",\r\nINTR_REMAP_PAGE_ORDER);\r\nkfree(iommu->ir_table);\r\nreturn -ENOMEM;\r\n}\r\nir_table->base = page_address(pages);\r\niommu_set_irq_remapping(iommu, mode);\r\nreturn 0;\r\n}\r\nstatic void iommu_disable_irq_remapping(struct intel_iommu *iommu)\r\n{\r\nunsigned long flags;\r\nu32 sts;\r\nif (!ecap_ir_support(iommu->ecap))\r\nreturn;\r\nqi_global_iec(iommu);\r\nraw_spin_lock_irqsave(&iommu->register_lock, flags);\r\nsts = dmar_readq(iommu->reg + DMAR_GSTS_REG);\r\nif (!(sts & DMA_GSTS_IRES))\r\ngoto end;\r\niommu->gcmd &= ~DMA_GCMD_IRE;\r\nwritel(iommu->gcmd, iommu->reg + DMAR_GCMD_REG);\r\nIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\r\nreadl, !(sts & DMA_GSTS_IRES), sts);\r\nend:\r\nraw_spin_unlock_irqrestore(&iommu->register_lock, flags);\r\n}\r\nstatic int __init dmar_x2apic_optout(void)\r\n{\r\nstruct acpi_table_dmar *dmar;\r\ndmar = (struct acpi_table_dmar *)dmar_tbl;\r\nif (!dmar || no_x2apic_optout)\r\nreturn 0;\r\nreturn dmar->flags & DMAR_X2APIC_OPT_OUT;\r\n}\r\nstatic int __init intel_irq_remapping_supported(void)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\nif (disable_irq_remap)\r\nreturn 0;\r\nif (irq_remap_broken) {\r\nWARN_TAINT(1, TAINT_FIRMWARE_WORKAROUND,\r\n"This system BIOS has enabled interrupt remapping\n"\r\n"on a chipset that contains an erratum making that\n"\r\n"feature unstable. To maintain system stability\n"\r\n"interrupt remapping is being disabled. Please\n"\r\n"contact your BIOS vendor for an update\n");\r\ndisable_irq_remap = 1;\r\nreturn 0;\r\n}\r\nif (!dmar_ir_support())\r\nreturn 0;\r\nfor_each_drhd_unit(drhd) {\r\nstruct intel_iommu *iommu = drhd->iommu;\r\nif (!ecap_ir_support(iommu->ecap))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init intel_enable_irq_remapping(void)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\nbool x2apic_present;\r\nint setup = 0;\r\nint eim = 0;\r\nx2apic_present = x2apic_supported();\r\nif (parse_ioapics_under_ir() != 1) {\r\nprintk(KERN_INFO "Not enable interrupt remapping\n");\r\ngoto error;\r\n}\r\nif (x2apic_present) {\r\neim = !dmar_x2apic_optout();\r\nif (!eim)\r\nprintk(KERN_WARNING\r\n"Your BIOS is broken and requested that x2apic be disabled.\n"\r\n"This will slightly decrease performance.\n"\r\n"Use 'intremap=no_x2apic_optout' to override BIOS request.\n");\r\n}\r\nfor_each_drhd_unit(drhd) {\r\nstruct intel_iommu *iommu = drhd->iommu;\r\nif (iommu->qi)\r\ncontinue;\r\ndmar_fault(-1, iommu);\r\niommu_disable_irq_remapping(iommu);\r\ndmar_disable_qi(iommu);\r\n}\r\nfor_each_drhd_unit(drhd) {\r\nstruct intel_iommu *iommu = drhd->iommu;\r\nif (!ecap_ir_support(iommu->ecap))\r\ncontinue;\r\nif (eim && !ecap_eim_support(iommu->ecap)) {\r\nprintk(KERN_INFO "DRHD %Lx: EIM not supported by DRHD, "\r\n" ecap %Lx\n", drhd->reg_base_addr, iommu->ecap);\r\ngoto error;\r\n}\r\n}\r\nfor_each_drhd_unit(drhd) {\r\nint ret;\r\nstruct intel_iommu *iommu = drhd->iommu;\r\nret = dmar_enable_qi(iommu);\r\nif (ret) {\r\nprintk(KERN_ERR "DRHD %Lx: failed to enable queued, "\r\n" invalidation, ecap %Lx, ret %d\n",\r\ndrhd->reg_base_addr, iommu->ecap, ret);\r\ngoto error;\r\n}\r\n}\r\nfor_each_drhd_unit(drhd) {\r\nstruct intel_iommu *iommu = drhd->iommu;\r\nif (!ecap_ir_support(iommu->ecap))\r\ncontinue;\r\nif (intel_setup_irq_remapping(iommu, eim))\r\ngoto error;\r\nsetup = 1;\r\n}\r\nif (!setup)\r\ngoto error;\r\nirq_remapping_enabled = 1;\r\nx86_io_apic_ops.print_entries = intel_ir_io_apic_print_entries;\r\npr_info("Enabled IRQ remapping in %s mode\n", eim ? "x2apic" : "xapic");\r\nreturn eim ? IRQ_REMAP_X2APIC_MODE : IRQ_REMAP_XAPIC_MODE;\r\nerror:\r\nif (x2apic_present)\r\npr_warn("Failed to enable irq remapping. You are vulnerable to irq-injection attacks.\n");\r\nreturn -1;\r\n}\r\nstatic void ir_parse_one_hpet_scope(struct acpi_dmar_device_scope *scope,\r\nstruct intel_iommu *iommu)\r\n{\r\nstruct acpi_dmar_pci_path *path;\r\nu8 bus;\r\nint count;\r\nbus = scope->bus;\r\npath = (struct acpi_dmar_pci_path *)(scope + 1);\r\ncount = (scope->length - sizeof(struct acpi_dmar_device_scope))\r\n/ sizeof(struct acpi_dmar_pci_path);\r\nwhile (--count > 0) {\r\nbus = read_pci_config_byte(bus, path->dev, path->fn,\r\nPCI_SECONDARY_BUS);\r\npath++;\r\n}\r\nir_hpet[ir_hpet_num].bus = bus;\r\nir_hpet[ir_hpet_num].devfn = PCI_DEVFN(path->dev, path->fn);\r\nir_hpet[ir_hpet_num].iommu = iommu;\r\nir_hpet[ir_hpet_num].id = scope->enumeration_id;\r\nir_hpet_num++;\r\n}\r\nstatic void ir_parse_one_ioapic_scope(struct acpi_dmar_device_scope *scope,\r\nstruct intel_iommu *iommu)\r\n{\r\nstruct acpi_dmar_pci_path *path;\r\nu8 bus;\r\nint count;\r\nbus = scope->bus;\r\npath = (struct acpi_dmar_pci_path *)(scope + 1);\r\ncount = (scope->length - sizeof(struct acpi_dmar_device_scope))\r\n/ sizeof(struct acpi_dmar_pci_path);\r\nwhile (--count > 0) {\r\nbus = read_pci_config_byte(bus, path->dev, path->fn,\r\nPCI_SECONDARY_BUS);\r\npath++;\r\n}\r\nir_ioapic[ir_ioapic_num].bus = bus;\r\nir_ioapic[ir_ioapic_num].devfn = PCI_DEVFN(path->dev, path->fn);\r\nir_ioapic[ir_ioapic_num].iommu = iommu;\r\nir_ioapic[ir_ioapic_num].id = scope->enumeration_id;\r\nir_ioapic_num++;\r\n}\r\nstatic int ir_parse_ioapic_hpet_scope(struct acpi_dmar_header *header,\r\nstruct intel_iommu *iommu)\r\n{\r\nstruct acpi_dmar_hardware_unit *drhd;\r\nstruct acpi_dmar_device_scope *scope;\r\nvoid *start, *end;\r\ndrhd = (struct acpi_dmar_hardware_unit *)header;\r\nstart = (void *)(drhd + 1);\r\nend = ((void *)drhd) + header->length;\r\nwhile (start < end) {\r\nscope = start;\r\nif (scope->entry_type == ACPI_DMAR_SCOPE_TYPE_IOAPIC) {\r\nif (ir_ioapic_num == MAX_IO_APICS) {\r\nprintk(KERN_WARNING "Exceeded Max IO APICS\n");\r\nreturn -1;\r\n}\r\nprintk(KERN_INFO "IOAPIC id %d under DRHD base "\r\n" 0x%Lx IOMMU %d\n", scope->enumeration_id,\r\ndrhd->address, iommu->seq_id);\r\nir_parse_one_ioapic_scope(scope, iommu);\r\n} else if (scope->entry_type == ACPI_DMAR_SCOPE_TYPE_HPET) {\r\nif (ir_hpet_num == MAX_HPET_TBS) {\r\nprintk(KERN_WARNING "Exceeded Max HPET blocks\n");\r\nreturn -1;\r\n}\r\nprintk(KERN_INFO "HPET id %d under DRHD base"\r\n" 0x%Lx\n", scope->enumeration_id,\r\ndrhd->address);\r\nir_parse_one_hpet_scope(scope, iommu);\r\n}\r\nstart += scope->length;\r\n}\r\nreturn 0;\r\n}\r\nint __init parse_ioapics_under_ir(void)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\nint ir_supported = 0;\r\nint ioapic_idx;\r\nfor_each_drhd_unit(drhd) {\r\nstruct intel_iommu *iommu = drhd->iommu;\r\nif (ecap_ir_support(iommu->ecap)) {\r\nif (ir_parse_ioapic_hpet_scope(drhd->hdr, iommu))\r\nreturn -1;\r\nir_supported = 1;\r\n}\r\n}\r\nif (!ir_supported)\r\nreturn 0;\r\nfor (ioapic_idx = 0; ioapic_idx < nr_ioapics; ioapic_idx++) {\r\nint ioapic_id = mpc_ioapic_id(ioapic_idx);\r\nif (!map_ioapic_to_ir(ioapic_id)) {\r\npr_err(FW_BUG "ioapic %d has no mapping iommu, "\r\n"interrupt remapping will be disabled\n",\r\nioapic_id);\r\nreturn -1;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nint __init ir_dev_scope_init(void)\r\n{\r\nif (!irq_remapping_enabled)\r\nreturn 0;\r\nreturn dmar_dev_scope_init();\r\n}\r\nstatic void disable_irq_remapping(void)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\nstruct intel_iommu *iommu = NULL;\r\nfor_each_iommu(iommu, drhd) {\r\nif (!ecap_ir_support(iommu->ecap))\r\ncontinue;\r\niommu_disable_irq_remapping(iommu);\r\n}\r\n}\r\nstatic int reenable_irq_remapping(int eim)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\nint setup = 0;\r\nstruct intel_iommu *iommu = NULL;\r\nfor_each_iommu(iommu, drhd)\r\nif (iommu->qi)\r\ndmar_reenable_qi(iommu);\r\nfor_each_iommu(iommu, drhd) {\r\nif (!ecap_ir_support(iommu->ecap))\r\ncontinue;\r\niommu_set_irq_remapping(iommu, eim);\r\nsetup = 1;\r\n}\r\nif (!setup)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nreturn -1;\r\n}\r\nstatic void prepare_irte(struct irte *irte, int vector,\r\nunsigned int dest)\r\n{\r\nmemset(irte, 0, sizeof(*irte));\r\nirte->present = 1;\r\nirte->dst_mode = apic->irq_dest_mode;\r\nirte->trigger_mode = 0;\r\nirte->dlvry_mode = apic->irq_delivery_mode;\r\nirte->vector = vector;\r\nirte->dest_id = IRTE_DEST(dest);\r\nirte->redir_hint = 1;\r\n}\r\nstatic int intel_setup_ioapic_entry(int irq,\r\nstruct IO_APIC_route_entry *route_entry,\r\nunsigned int destination, int vector,\r\nstruct io_apic_irq_attr *attr)\r\n{\r\nint ioapic_id = mpc_ioapic_id(attr->ioapic);\r\nstruct intel_iommu *iommu = map_ioapic_to_ir(ioapic_id);\r\nstruct IR_IO_APIC_route_entry *entry;\r\nstruct irte irte;\r\nint index;\r\nif (!iommu) {\r\npr_warn("No mapping iommu for ioapic %d\n", ioapic_id);\r\nreturn -ENODEV;\r\n}\r\nentry = (struct IR_IO_APIC_route_entry *)route_entry;\r\nindex = alloc_irte(iommu, irq, 1);\r\nif (index < 0) {\r\npr_warn("Failed to allocate IRTE for ioapic %d\n", ioapic_id);\r\nreturn -ENOMEM;\r\n}\r\nprepare_irte(&irte, vector, destination);\r\nset_ioapic_sid(&irte, ioapic_id);\r\nmodify_irte(irq, &irte);\r\napic_printk(APIC_VERBOSE, KERN_DEBUG "IOAPIC[%d]: "\r\n"Set IRTE entry (P:%d FPD:%d Dst_Mode:%d "\r\n"Redir_hint:%d Trig_Mode:%d Dlvry_Mode:%X "\r\n"Avail:%X Vector:%02X Dest:%08X "\r\n"SID:%04X SQ:%X SVT:%X)\n",\r\nattr->ioapic, irte.present, irte.fpd, irte.dst_mode,\r\nirte.redir_hint, irte.trigger_mode, irte.dlvry_mode,\r\nirte.avail, irte.vector, irte.dest_id,\r\nirte.sid, irte.sq, irte.svt);\r\nmemset(entry, 0, sizeof(*entry));\r\nentry->index2 = (index >> 15) & 0x1;\r\nentry->zero = 0;\r\nentry->format = 1;\r\nentry->index = (index & 0x7fff);\r\nentry->vector = attr->ioapic_pin;\r\nentry->mask = 0;\r\nentry->trigger = attr->trigger;\r\nentry->polarity = attr->polarity;\r\nif (attr->trigger)\r\nentry->mask = 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nintel_ioapic_set_affinity(struct irq_data *data, const struct cpumask *mask,\r\nbool force)\r\n{\r\nstruct irq_cfg *cfg = data->chip_data;\r\nunsigned int dest, irq = data->irq;\r\nstruct irte irte;\r\nint err;\r\nif (!config_enabled(CONFIG_SMP))\r\nreturn -EINVAL;\r\nif (!cpumask_intersects(mask, cpu_online_mask))\r\nreturn -EINVAL;\r\nif (get_irte(irq, &irte))\r\nreturn -EBUSY;\r\nerr = assign_irq_vector(irq, cfg, mask);\r\nif (err)\r\nreturn err;\r\nerr = apic->cpu_mask_to_apicid_and(cfg->domain, mask, &dest);\r\nif (err) {\r\nif (assign_irq_vector(irq, cfg, data->affinity))\r\npr_err("Failed to recover vector for irq %d\n", irq);\r\nreturn err;\r\n}\r\nirte.vector = cfg->vector;\r\nirte.dest_id = IRTE_DEST(dest);\r\nmodify_irte(irq, &irte);\r\nif (cfg->move_in_progress)\r\nsend_cleanup_vector(cfg);\r\ncpumask_copy(data->affinity, mask);\r\nreturn 0;\r\n}\r\nstatic void intel_compose_msi_msg(struct pci_dev *pdev,\r\nunsigned int irq, unsigned int dest,\r\nstruct msi_msg *msg, u8 hpet_id)\r\n{\r\nstruct irq_cfg *cfg;\r\nstruct irte irte;\r\nu16 sub_handle = 0;\r\nint ir_index;\r\ncfg = irq_get_chip_data(irq);\r\nir_index = map_irq_to_irte_handle(irq, &sub_handle);\r\nBUG_ON(ir_index == -1);\r\nprepare_irte(&irte, cfg->vector, dest);\r\nif (pdev)\r\nset_msi_sid(&irte, pdev);\r\nelse\r\nset_hpet_sid(&irte, hpet_id);\r\nmodify_irte(irq, &irte);\r\nmsg->address_hi = MSI_ADDR_BASE_HI;\r\nmsg->data = sub_handle;\r\nmsg->address_lo = MSI_ADDR_BASE_LO | MSI_ADDR_IR_EXT_INT |\r\nMSI_ADDR_IR_SHV |\r\nMSI_ADDR_IR_INDEX1(ir_index) |\r\nMSI_ADDR_IR_INDEX2(ir_index);\r\n}\r\nstatic int intel_msi_alloc_irq(struct pci_dev *dev, int irq, int nvec)\r\n{\r\nstruct intel_iommu *iommu;\r\nint index;\r\niommu = map_dev_to_ir(dev);\r\nif (!iommu) {\r\nprintk(KERN_ERR\r\n"Unable to map PCI %s to iommu\n", pci_name(dev));\r\nreturn -ENOENT;\r\n}\r\nindex = alloc_irte(iommu, irq, nvec);\r\nif (index < 0) {\r\nprintk(KERN_ERR\r\n"Unable to allocate %d IRTE for PCI %s\n", nvec,\r\npci_name(dev));\r\nreturn -ENOSPC;\r\n}\r\nreturn index;\r\n}\r\nstatic int intel_msi_setup_irq(struct pci_dev *pdev, unsigned int irq,\r\nint index, int sub_handle)\r\n{\r\nstruct intel_iommu *iommu;\r\niommu = map_dev_to_ir(pdev);\r\nif (!iommu)\r\nreturn -ENOENT;\r\nset_irte_irq(irq, iommu, index, sub_handle);\r\nreturn 0;\r\n}\r\nstatic int intel_setup_hpet_msi(unsigned int irq, unsigned int id)\r\n{\r\nstruct intel_iommu *iommu = map_hpet_to_ir(id);\r\nint index;\r\nif (!iommu)\r\nreturn -1;\r\nindex = alloc_irte(iommu, irq, 1);\r\nif (index < 0)\r\nreturn -1;\r\nreturn 0;\r\n}
