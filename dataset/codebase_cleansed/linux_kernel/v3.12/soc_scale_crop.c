static bool is_smaller(const struct v4l2_rect *r1, const struct v4l2_rect *r2)\r\n{\r\nreturn r1->width < r2->width || r1->height < r2->height;\r\n}\r\nstatic bool is_inside(const struct v4l2_rect *r1, const struct v4l2_rect *r2)\r\n{\r\nreturn r1->left > r2->left || r1->top > r2->top ||\r\nr1->left + r1->width < r2->left + r2->width ||\r\nr1->top + r1->height < r2->top + r2->height;\r\n}\r\nint soc_camera_client_g_rect(struct v4l2_subdev *sd, struct v4l2_rect *rect)\r\n{\r\nstruct v4l2_crop crop;\r\nstruct v4l2_cropcap cap;\r\nint ret;\r\ncrop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nret = v4l2_subdev_call(sd, video, g_crop, &crop);\r\nif (!ret) {\r\n*rect = crop.c;\r\nreturn ret;\r\n}\r\ncap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nret = v4l2_subdev_call(sd, video, cropcap, &cap);\r\nif (!ret)\r\n*rect = cap.defrect;\r\nreturn ret;\r\n}\r\nstatic void update_subrect(struct v4l2_rect *rect, struct v4l2_rect *subrect)\r\n{\r\nif (rect->width < subrect->width)\r\nsubrect->width = rect->width;\r\nif (rect->height < subrect->height)\r\nsubrect->height = rect->height;\r\nif (rect->left > subrect->left)\r\nsubrect->left = rect->left;\r\nelse if (rect->left + rect->width >\r\nsubrect->left + subrect->width)\r\nsubrect->left = rect->left + rect->width -\r\nsubrect->width;\r\nif (rect->top > subrect->top)\r\nsubrect->top = rect->top;\r\nelse if (rect->top + rect->height >\r\nsubrect->top + subrect->height)\r\nsubrect->top = rect->top + rect->height -\r\nsubrect->height;\r\n}\r\nint soc_camera_client_s_crop(struct v4l2_subdev *sd,\r\nstruct v4l2_crop *crop, struct v4l2_crop *cam_crop,\r\nstruct v4l2_rect *target_rect, struct v4l2_rect *subrect)\r\n{\r\nstruct v4l2_rect *rect = &crop->c, *cam_rect = &cam_crop->c;\r\nstruct device *dev = sd->v4l2_dev->dev;\r\nstruct v4l2_cropcap cap;\r\nint ret;\r\nunsigned int width, height;\r\nv4l2_subdev_call(sd, video, s_crop, crop);\r\nret = soc_camera_client_g_rect(sd, cam_rect);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!memcmp(rect, cam_rect, sizeof(*rect))) {\r\ndev_dbg(dev, "Camera S_CROP successful for %dx%d@%d:%d\n",\r\nrect->width, rect->height, rect->left, rect->top);\r\n*target_rect = *cam_rect;\r\nreturn 0;\r\n}\r\ndev_geo(dev, "Fix camera S_CROP for %dx%d@%d:%d to %dx%d@%d:%d\n",\r\ncam_rect->width, cam_rect->height,\r\ncam_rect->left, cam_rect->top,\r\nrect->width, rect->height, rect->left, rect->top);\r\nret = v4l2_subdev_call(sd, video, cropcap, &cap);\r\nif (ret < 0)\r\nreturn ret;\r\nsoc_camera_limit_side(&rect->left, &rect->width, cap.bounds.left, 2,\r\ncap.bounds.width);\r\nsoc_camera_limit_side(&rect->top, &rect->height, cap.bounds.top, 4,\r\ncap.bounds.height);\r\nwidth = max(cam_rect->width, 2);\r\nheight = max(cam_rect->height, 2);\r\nwhile (!ret && (is_smaller(cam_rect, rect) ||\r\nis_inside(cam_rect, rect)) &&\r\n(cap.bounds.width > width || cap.bounds.height > height)) {\r\nwidth *= 2;\r\nheight *= 2;\r\ncam_rect->width = width;\r\ncam_rect->height = height;\r\nif (cam_rect->left > rect->left)\r\ncam_rect->left = cap.bounds.left;\r\nif (cam_rect->left + cam_rect->width < rect->left + rect->width)\r\ncam_rect->width = rect->left + rect->width -\r\ncam_rect->left;\r\nif (cam_rect->top > rect->top)\r\ncam_rect->top = cap.bounds.top;\r\nif (cam_rect->top + cam_rect->height < rect->top + rect->height)\r\ncam_rect->height = rect->top + rect->height -\r\ncam_rect->top;\r\nv4l2_subdev_call(sd, video, s_crop, cam_crop);\r\nret = soc_camera_client_g_rect(sd, cam_rect);\r\ndev_geo(dev, "Camera S_CROP %d for %dx%d@%d:%d\n", ret,\r\ncam_rect->width, cam_rect->height,\r\ncam_rect->left, cam_rect->top);\r\n}\r\nif (is_smaller(cam_rect, rect) || is_inside(cam_rect, rect)) {\r\n*cam_rect = cap.bounds;\r\nv4l2_subdev_call(sd, video, s_crop, cam_crop);\r\nret = soc_camera_client_g_rect(sd, cam_rect);\r\ndev_geo(dev, "Camera S_CROP %d for max %dx%d@%d:%d\n", ret,\r\ncam_rect->width, cam_rect->height,\r\ncam_rect->left, cam_rect->top);\r\n}\r\nif (!ret) {\r\n*target_rect = *cam_rect;\r\nupdate_subrect(target_rect, subrect);\r\n}\r\nreturn ret;\r\n}\r\nstatic int client_s_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_rect *rect, struct v4l2_rect *subrect,\r\nunsigned int max_width, unsigned int max_height,\r\nstruct v4l2_mbus_framefmt *mf, bool host_can_scale)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct device *dev = icd->parent;\r\nunsigned int width = mf->width, height = mf->height, tmp_w, tmp_h;\r\nstruct v4l2_cropcap cap;\r\nbool host_1to1;\r\nint ret;\r\nret = v4l2_device_call_until_err(sd->v4l2_dev,\r\nsoc_camera_grp_id(icd), video,\r\ns_mbus_fmt, mf);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_geo(dev, "camera scaled to %ux%u\n", mf->width, mf->height);\r\nif (width == mf->width && height == mf->height) {\r\nhost_1to1 = true;\r\ngoto update_cache;\r\n}\r\nhost_1to1 = false;\r\nif (!host_can_scale)\r\ngoto update_cache;\r\ncap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nret = v4l2_subdev_call(sd, video, cropcap, &cap);\r\nif (ret < 0)\r\nreturn ret;\r\nif (max_width > cap.bounds.width)\r\nmax_width = cap.bounds.width;\r\nif (max_height > cap.bounds.height)\r\nmax_height = cap.bounds.height;\r\ntmp_w = mf->width;\r\ntmp_h = mf->height;\r\nwhile ((width > tmp_w || height > tmp_h) &&\r\ntmp_w < max_width && tmp_h < max_height) {\r\ntmp_w = min(2 * tmp_w, max_width);\r\ntmp_h = min(2 * tmp_h, max_height);\r\nmf->width = tmp_w;\r\nmf->height = tmp_h;\r\nret = v4l2_device_call_until_err(sd->v4l2_dev,\r\nsoc_camera_grp_id(icd), video,\r\ns_mbus_fmt, mf);\r\ndev_geo(dev, "Camera scaled to %ux%u\n",\r\nmf->width, mf->height);\r\nif (ret < 0) {\r\ndev_err(dev, "Client failed to set format: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nupdate_cache:\r\nret = soc_camera_client_g_rect(sd, rect);\r\nif (ret < 0)\r\nreturn ret;\r\nif (host_1to1)\r\n*subrect = *rect;\r\nelse\r\nupdate_subrect(rect, subrect);\r\nreturn 0;\r\n}\r\nint soc_camera_client_scale(struct soc_camera_device *icd,\r\nstruct v4l2_rect *rect, struct v4l2_rect *subrect,\r\nstruct v4l2_mbus_framefmt *mf,\r\nunsigned int *width, unsigned int *height,\r\nbool host_can_scale, unsigned int shift)\r\n{\r\nstruct device *dev = icd->parent;\r\nstruct v4l2_mbus_framefmt mf_tmp = *mf;\r\nunsigned int scale_h, scale_v;\r\nint ret;\r\nret = client_s_fmt(icd, rect, subrect, *width, *height,\r\n&mf_tmp, host_can_scale);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_geo(dev, "5: camera scaled to %ux%u\n",\r\nmf_tmp.width, mf_tmp.height);\r\nscale_h = soc_camera_calc_scale(rect->width, shift, mf_tmp.width);\r\nscale_v = soc_camera_calc_scale(rect->height, shift, mf_tmp.height);\r\nmf->width = mf_tmp.width;\r\nmf->height = mf_tmp.height;\r\nmf->colorspace = mf_tmp.colorspace;\r\n*width = soc_camera_shift_scale(subrect->width, shift, scale_h);\r\n*height = soc_camera_shift_scale(subrect->height, shift, scale_v);\r\ndev_geo(dev, "8: new client sub-window %ux%u\n", *width, *height);\r\nreturn 0;\r\n}\r\nvoid soc_camera_calc_client_output(struct soc_camera_device *icd,\r\nstruct v4l2_rect *rect, struct v4l2_rect *subrect,\r\nconst struct v4l2_pix_format *pix, struct v4l2_mbus_framefmt *mf,\r\nunsigned int shift)\r\n{\r\nstruct device *dev = icd->parent;\r\nunsigned int scale_v, scale_h;\r\nif (subrect->width == rect->width &&\r\nsubrect->height == rect->height) {\r\nmf->width = pix->width;\r\nmf->height = pix->height;\r\nreturn;\r\n}\r\ndev_geo(dev, "2: subwin %ux%u@%u:%u\n",\r\nsubrect->width, subrect->height,\r\nsubrect->left, subrect->top);\r\nscale_h = soc_camera_calc_scale(subrect->width, shift, pix->width);\r\nscale_v = soc_camera_calc_scale(subrect->height, shift, pix->height);\r\ndev_geo(dev, "3: scales %u:%u\n", scale_h, scale_v);\r\nmf->width = soc_camera_shift_scale(rect->width, shift, scale_h);\r\nmf->height = soc_camera_shift_scale(rect->height, shift, scale_v);\r\n}
