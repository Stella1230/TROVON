asmlinkage unsigned long sys_getpagesize(void)\r\n{\r\nreturn PAGE_SIZE;\r\n}\r\nunsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags)\r\n{\r\nstruct vm_unmapped_area_info info;\r\nif (flags & MAP_FIXED) {\r\nif ((flags & MAP_SHARED) &&\r\n((addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1)))\r\nreturn -EINVAL;\r\nreturn addr;\r\n}\r\nif (len > TASK_SIZE - PAGE_SIZE)\r\nreturn -ENOMEM;\r\nif (!addr)\r\naddr = TASK_UNMAPPED_BASE;\r\ninfo.flags = 0;\r\ninfo.length = len;\r\ninfo.low_limit = addr;\r\ninfo.high_limit = TASK_SIZE;\r\ninfo.align_mask = (flags & MAP_SHARED) ?\r\n(PAGE_MASK & (SHMLBA - 1)) : 0;\r\ninfo.align_offset = pgoff << PAGE_SHIFT;\r\nreturn vm_unmapped_area(&info);\r\n}\r\nasmlinkage int sparc_pipe(struct pt_regs *regs)\r\n{\r\nint fd[2];\r\nint error;\r\nerror = do_pipe_flags(fd, 0);\r\nif (error)\r\ngoto out;\r\nregs->u_regs[UREG_I1] = fd[1];\r\nerror = fd[0];\r\nout:\r\nreturn error;\r\n}\r\nint sparc_mmap_check(unsigned long addr, unsigned long len)\r\n{\r\nif (len > TASK_SIZE - PAGE_SIZE || addr + len > TASK_SIZE - PAGE_SIZE)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nasmlinkage unsigned long sys_mmap2(unsigned long addr, unsigned long len,\r\nunsigned long prot, unsigned long flags, unsigned long fd,\r\nunsigned long pgoff)\r\n{\r\nreturn sys_mmap_pgoff(addr, len, prot, flags, fd,\r\npgoff >> (PAGE_SHIFT - 12));\r\n}\r\nasmlinkage unsigned long sys_mmap(unsigned long addr, unsigned long len,\r\nunsigned long prot, unsigned long flags, unsigned long fd,\r\nunsigned long off)\r\n{\r\nreturn sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);\r\n}\r\nlong sparc_remap_file_pages(unsigned long start, unsigned long size,\r\nunsigned long prot, unsigned long pgoff,\r\nunsigned long flags)\r\n{\r\nreturn sys_remap_file_pages(start, size, prot,\r\n(pgoff >> (PAGE_SHIFT - 12)), flags);\r\n}\r\nasmlinkage unsigned long\r\nc_sys_nis_syscall (struct pt_regs *regs)\r\n{\r\nstatic int count = 0;\r\nif (count++ > 5)\r\nreturn -ENOSYS;\r\nprintk ("%s[%d]: Unimplemented SPARC system call %d\n",\r\ncurrent->comm, task_pid_nr(current), (int)regs->u_regs[1]);\r\n#ifdef DEBUG_UNIMP_SYSCALL\r\nshow_regs (regs);\r\n#endif\r\nreturn -ENOSYS;\r\n}\r\nasmlinkage void\r\nsparc_breakpoint (struct pt_regs *regs)\r\n{\r\nsiginfo_t info;\r\n#ifdef DEBUG_SPARC_BREAKPOINT\r\nprintk ("TRAP: Entering kernel PC=%x, nPC=%x\n", regs->pc, regs->npc);\r\n#endif\r\ninfo.si_signo = SIGTRAP;\r\ninfo.si_errno = 0;\r\ninfo.si_code = TRAP_BRKPT;\r\ninfo.si_addr = (void __user *)regs->pc;\r\ninfo.si_trapno = 0;\r\nforce_sig_info(SIGTRAP, &info, current);\r\n#ifdef DEBUG_SPARC_BREAKPOINT\r\nprintk ("TRAP: Returning to space: PC=%x nPC=%x\n", regs->pc, regs->npc);\r\n#endif\r\n}\r\nasmlinkage int sys_getdomainname(char __user *name, int len)\r\n{\r\nint nlen, err;\r\nif (len < 0)\r\nreturn -EINVAL;\r\ndown_read(&uts_sem);\r\nnlen = strlen(utsname()->domainname) + 1;\r\nerr = -EINVAL;\r\nif (nlen > len)\r\ngoto out;\r\nerr = -EFAULT;\r\nif (!copy_to_user(name, utsname()->domainname, nlen))\r\nerr = 0;\r\nout:\r\nup_read(&uts_sem);\r\nreturn err;\r\n}
