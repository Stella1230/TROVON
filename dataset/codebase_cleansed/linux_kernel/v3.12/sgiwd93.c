static irqreturn_t sgiwd93_intr(int irq, void *dev_id)\r\n{\r\nstruct Scsi_Host * host = dev_id;\r\nunsigned long flags;\r\nspin_lock_irqsave(host->host_lock, flags);\r\nwd33c93_intr(host);\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline\r\nvoid fill_hpc_entries(struct ip22_hostdata *hd, struct scsi_cmnd *cmd, int din)\r\n{\r\nunsigned long len = cmd->SCp.this_residual;\r\nvoid *addr = cmd->SCp.ptr;\r\ndma_addr_t physaddr;\r\nunsigned long count;\r\nstruct hpc_chunk *hcp;\r\nphysaddr = dma_map_single(hd->dev, addr, len, DMA_DIR(din));\r\ncmd->SCp.dma_handle = physaddr;\r\nhcp = hd->cpu;\r\nwhile (len) {\r\ncount = len > 8192 ? 8192 : len;\r\nhcp->desc.pbuf = physaddr;\r\nhcp->desc.cntinfo = count;\r\nhcp++;\r\nlen -= count;\r\nphysaddr += count;\r\n}\r\nhcp->desc.pbuf = 0;\r\nhcp->desc.cntinfo = HPCDMA_EOX;\r\ndma_cache_sync(hd->dev, hd->cpu,\r\n(unsigned long)(hcp + 1) - (unsigned long)hd->cpu,\r\nDMA_TO_DEVICE);\r\n}\r\nstatic int dma_setup(struct scsi_cmnd *cmd, int datainp)\r\n{\r\nstruct ip22_hostdata *hdata = host_to_hostdata(cmd->device->host);\r\nstruct hpc3_scsiregs *hregs =\r\n(struct hpc3_scsiregs *) cmd->device->host->base;\r\npr_debug("dma_setup: datainp<%d> hcp<%p> ", datainp, hdata->cpu);\r\nhdata->wh.dma_dir = datainp;\r\nif (cmd->SCp.ptr == NULL || cmd->SCp.this_residual == 0)\r\nreturn 1;\r\nfill_hpc_entries(hdata, cmd, datainp);\r\npr_debug(" HPCGO\n");\r\nhregs->ndptr = hdata->dma;\r\nif (datainp)\r\nhregs->ctrl = HPC3_SCTRL_ACTIVE;\r\nelse\r\nhregs->ctrl = HPC3_SCTRL_ACTIVE | HPC3_SCTRL_DIR;\r\nreturn 0;\r\n}\r\nstatic void dma_stop(struct Scsi_Host *instance, struct scsi_cmnd *SCpnt,\r\nint status)\r\n{\r\nstruct ip22_hostdata *hdata = host_to_hostdata(instance);\r\nstruct hpc3_scsiregs *hregs;\r\nif (!SCpnt)\r\nreturn;\r\nif (SCpnt->SCp.ptr == NULL || SCpnt->SCp.this_residual == 0)\r\nreturn;\r\nhregs = (struct hpc3_scsiregs *) SCpnt->device->host->base;\r\npr_debug("dma_stop: status<%d> ", status);\r\nif (hdata->wh.dma_dir) {\r\nhregs->ctrl |= HPC3_SCTRL_FLUSH;\r\nwhile (hregs->ctrl & HPC3_SCTRL_ACTIVE)\r\nbarrier();\r\n}\r\nhregs->ctrl = 0;\r\ndma_unmap_single(hdata->dev, SCpnt->SCp.dma_handle,\r\nSCpnt->SCp.this_residual,\r\nDMA_DIR(hdata->wh.dma_dir));\r\npr_debug("\n");\r\n}\r\nvoid sgiwd93_reset(unsigned long base)\r\n{\r\nstruct hpc3_scsiregs *hregs = (struct hpc3_scsiregs *) base;\r\nhregs->ctrl = HPC3_SCTRL_CRESET;\r\nudelay(50);\r\nhregs->ctrl = 0;\r\n}\r\nstatic inline void init_hpc_chain(struct ip22_hostdata *hdata)\r\n{\r\nstruct hpc_chunk *hcp = (struct hpc_chunk *)hdata->cpu;\r\ndma_addr_t dma = hdata->dma;\r\nunsigned long start, end;\r\nstart = (unsigned long) hcp;\r\nend = start + HPC_DMA_SIZE;\r\nwhile (start < end) {\r\nhcp->desc.pnext = (u32) (dma + sizeof(struct hpc_chunk));\r\nhcp->desc.cntinfo = HPCDMA_EOX;\r\nhcp++;\r\ndma += sizeof(struct hpc_chunk);\r\nstart += sizeof(struct hpc_chunk);\r\n};\r\nhcp--;\r\nhcp->desc.pnext = hdata->dma;\r\n}\r\nstatic int sgiwd93_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nspin_lock_irq(cmd->device->host->host_lock);\r\nwd33c93_host_reset(cmd);\r\nspin_unlock_irq(cmd->device->host->host_lock);\r\nreturn SUCCESS;\r\n}\r\nstatic int sgiwd93_probe(struct platform_device *pdev)\r\n{\r\nstruct sgiwd93_platform_data *pd = pdev->dev.platform_data;\r\nunsigned char *wdregs = pd->wdregs;\r\nstruct hpc3_scsiregs *hregs = pd->hregs;\r\nstruct ip22_hostdata *hdata;\r\nstruct Scsi_Host *host;\r\nwd33c93_regs regs;\r\nunsigned int unit = pd->unit;\r\nunsigned int irq = pd->irq;\r\nint err;\r\nhost = scsi_host_alloc(&sgiwd93_template, sizeof(struct ip22_hostdata));\r\nif (!host) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nhost->base = (unsigned long) hregs;\r\nhost->irq = irq;\r\nhdata = host_to_hostdata(host);\r\nhdata->dev = &pdev->dev;\r\nhdata->cpu = dma_alloc_noncoherent(&pdev->dev, HPC_DMA_SIZE,\r\n&hdata->dma, GFP_KERNEL);\r\nif (!hdata->cpu) {\r\nprintk(KERN_WARNING "sgiwd93: Could not allocate memory for "\r\n"host %d buffer.\n", unit);\r\nerr = -ENOMEM;\r\ngoto out_put;\r\n}\r\ninit_hpc_chain(hdata);\r\nregs.SASR = wdregs + 3;\r\nregs.SCMD = wdregs + 7;\r\nhdata->wh.no_sync = 0;\r\nhdata->wh.fast = 1;\r\nhdata->wh.dma_mode = CTRL_BURST;\r\nwd33c93_init(host, regs, dma_setup, dma_stop, WD33C93_FS_MHZ(20));\r\nerr = request_irq(irq, sgiwd93_intr, 0, "SGI WD93", host);\r\nif (err) {\r\nprintk(KERN_WARNING "sgiwd93: Could not register irq %d "\r\n"for host %d.\n", irq, unit);\r\ngoto out_free;\r\n}\r\nplatform_set_drvdata(pdev, host);\r\nerr = scsi_add_host(host, NULL);\r\nif (err)\r\ngoto out_irq;\r\nscsi_scan_host(host);\r\nreturn 0;\r\nout_irq:\r\nfree_irq(irq, host);\r\nout_free:\r\ndma_free_noncoherent(&pdev->dev, HPC_DMA_SIZE, hdata->cpu, hdata->dma);\r\nout_put:\r\nscsi_host_put(host);\r\nout:\r\nreturn err;\r\n}\r\nstatic int __exit sgiwd93_remove(struct platform_device *pdev)\r\n{\r\nstruct Scsi_Host *host = platform_get_drvdata(pdev);\r\nstruct ip22_hostdata *hdata = (struct ip22_hostdata *) host->hostdata;\r\nstruct sgiwd93_platform_data *pd = pdev->dev.platform_data;\r\nscsi_remove_host(host);\r\nfree_irq(pd->irq, host);\r\ndma_free_noncoherent(&pdev->dev, HPC_DMA_SIZE, hdata->cpu, hdata->dma);\r\nscsi_host_put(host);\r\nreturn 0;\r\n}\r\nstatic int __init sgiwd93_module_init(void)\r\n{\r\nreturn platform_driver_register(&sgiwd93_driver);\r\n}\r\nstatic void __exit sgiwd93_module_exit(void)\r\n{\r\nreturn platform_driver_unregister(&sgiwd93_driver);\r\n}
