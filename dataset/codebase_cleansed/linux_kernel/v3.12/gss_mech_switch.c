static void\r\ngss_mech_free(struct gss_api_mech *gm)\r\n{\r\nstruct pf_desc *pf;\r\nint i;\r\nfor (i = 0; i < gm->gm_pf_num; i++) {\r\npf = &gm->gm_pfs[i];\r\nkfree(pf->auth_domain_name);\r\npf->auth_domain_name = NULL;\r\n}\r\n}\r\nstatic inline char *\r\nmake_auth_domain_name(char *name)\r\n{\r\nstatic char *prefix = "gss/";\r\nchar *new;\r\nnew = kmalloc(strlen(name) + strlen(prefix) + 1, GFP_KERNEL);\r\nif (new) {\r\nstrcpy(new, prefix);\r\nstrcat(new, name);\r\n}\r\nreturn new;\r\n}\r\nstatic int\r\ngss_mech_svc_setup(struct gss_api_mech *gm)\r\n{\r\nstruct pf_desc *pf;\r\nint i, status;\r\nfor (i = 0; i < gm->gm_pf_num; i++) {\r\npf = &gm->gm_pfs[i];\r\npf->auth_domain_name = make_auth_domain_name(pf->name);\r\nstatus = -ENOMEM;\r\nif (pf->auth_domain_name == NULL)\r\ngoto out;\r\nstatus = svcauth_gss_register_pseudoflavor(pf->pseudoflavor,\r\npf->auth_domain_name);\r\nif (status)\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\ngss_mech_free(gm);\r\nreturn status;\r\n}\r\nint gss_mech_register(struct gss_api_mech *gm)\r\n{\r\nint status;\r\nstatus = gss_mech_svc_setup(gm);\r\nif (status)\r\nreturn status;\r\nspin_lock(&registered_mechs_lock);\r\nlist_add(&gm->gm_list, &registered_mechs);\r\nspin_unlock(&registered_mechs_lock);\r\ndprintk("RPC: registered gss mechanism %s\n", gm->gm_name);\r\nreturn 0;\r\n}\r\nvoid gss_mech_unregister(struct gss_api_mech *gm)\r\n{\r\nspin_lock(&registered_mechs_lock);\r\nlist_del(&gm->gm_list);\r\nspin_unlock(&registered_mechs_lock);\r\ndprintk("RPC: unregistered gss mechanism %s\n", gm->gm_name);\r\ngss_mech_free(gm);\r\n}\r\nstruct gss_api_mech *gss_mech_get(struct gss_api_mech *gm)\r\n{\r\n__module_get(gm->gm_owner);\r\nreturn gm;\r\n}\r\nstatic struct gss_api_mech *\r\n_gss_mech_get_by_name(const char *name)\r\n{\r\nstruct gss_api_mech *pos, *gm = NULL;\r\nspin_lock(&registered_mechs_lock);\r\nlist_for_each_entry(pos, &registered_mechs, gm_list) {\r\nif (0 == strcmp(name, pos->gm_name)) {\r\nif (try_module_get(pos->gm_owner))\r\ngm = pos;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&registered_mechs_lock);\r\nreturn gm;\r\n}\r\nstruct gss_api_mech * gss_mech_get_by_name(const char *name)\r\n{\r\nstruct gss_api_mech *gm = NULL;\r\ngm = _gss_mech_get_by_name(name);\r\nif (!gm) {\r\nrequest_module("rpc-auth-gss-%s", name);\r\ngm = _gss_mech_get_by_name(name);\r\n}\r\nreturn gm;\r\n}\r\nstruct gss_api_mech *gss_mech_get_by_OID(struct rpcsec_gss_oid *obj)\r\n{\r\nstruct gss_api_mech *pos, *gm = NULL;\r\nchar buf[32];\r\nif (sprint_oid(obj->data, obj->len, buf, sizeof(buf)) < 0)\r\nreturn NULL;\r\ndprintk("RPC: %s(%s)\n", __func__, buf);\r\nrequest_module("rpc-auth-gss-%s", buf);\r\nspin_lock(&registered_mechs_lock);\r\nlist_for_each_entry(pos, &registered_mechs, gm_list) {\r\nif (obj->len == pos->gm_oid.len) {\r\nif (0 == memcmp(obj->data, pos->gm_oid.data, obj->len)) {\r\nif (try_module_get(pos->gm_owner))\r\ngm = pos;\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock(&registered_mechs_lock);\r\nreturn gm;\r\n}\r\nstatic inline int\r\nmech_supports_pseudoflavor(struct gss_api_mech *gm, u32 pseudoflavor)\r\n{\r\nint i;\r\nfor (i = 0; i < gm->gm_pf_num; i++) {\r\nif (gm->gm_pfs[i].pseudoflavor == pseudoflavor)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct gss_api_mech *_gss_mech_get_by_pseudoflavor(u32 pseudoflavor)\r\n{\r\nstruct gss_api_mech *gm = NULL, *pos;\r\nspin_lock(&registered_mechs_lock);\r\nlist_for_each_entry(pos, &registered_mechs, gm_list) {\r\nif (!mech_supports_pseudoflavor(pos, pseudoflavor)) {\r\nmodule_put(pos->gm_owner);\r\ncontinue;\r\n}\r\nif (try_module_get(pos->gm_owner))\r\ngm = pos;\r\nbreak;\r\n}\r\nspin_unlock(&registered_mechs_lock);\r\nreturn gm;\r\n}\r\nstruct gss_api_mech *\r\ngss_mech_get_by_pseudoflavor(u32 pseudoflavor)\r\n{\r\nstruct gss_api_mech *gm;\r\ngm = _gss_mech_get_by_pseudoflavor(pseudoflavor);\r\nif (!gm) {\r\nrequest_module("rpc-auth-gss-%u", pseudoflavor);\r\ngm = _gss_mech_get_by_pseudoflavor(pseudoflavor);\r\n}\r\nreturn gm;\r\n}\r\nint gss_mech_list_pseudoflavors(rpc_authflavor_t *array_ptr, int size)\r\n{\r\nstruct gss_api_mech *pos = NULL;\r\nint j, i = 0;\r\nspin_lock(&registered_mechs_lock);\r\nlist_for_each_entry(pos, &registered_mechs, gm_list) {\r\nfor (j = 0; j < pos->gm_pf_num; j++) {\r\nif (i >= size) {\r\nspin_unlock(&registered_mechs_lock);\r\nreturn -ENOMEM;\r\n}\r\narray_ptr[i++] = pos->gm_pfs[j].pseudoflavor;\r\n}\r\n}\r\nspin_unlock(&registered_mechs_lock);\r\nreturn i;\r\n}\r\nrpc_authflavor_t gss_svc_to_pseudoflavor(struct gss_api_mech *gm, u32 qop,\r\nu32 service)\r\n{\r\nint i;\r\nfor (i = 0; i < gm->gm_pf_num; i++) {\r\nif (gm->gm_pfs[i].qop == qop &&\r\ngm->gm_pfs[i].service == service) {\r\nreturn gm->gm_pfs[i].pseudoflavor;\r\n}\r\n}\r\nreturn RPC_AUTH_MAXFLAVOR;\r\n}\r\nrpc_authflavor_t gss_mech_info2flavor(struct rpcsec_gss_info *info)\r\n{\r\nrpc_authflavor_t pseudoflavor;\r\nstruct gss_api_mech *gm;\r\ngm = gss_mech_get_by_OID(&info->oid);\r\nif (gm == NULL)\r\nreturn RPC_AUTH_MAXFLAVOR;\r\npseudoflavor = gss_svc_to_pseudoflavor(gm, info->qop, info->service);\r\ngss_mech_put(gm);\r\nreturn pseudoflavor;\r\n}\r\nint gss_mech_flavor2info(rpc_authflavor_t pseudoflavor,\r\nstruct rpcsec_gss_info *info)\r\n{\r\nstruct gss_api_mech *gm;\r\nint i;\r\ngm = gss_mech_get_by_pseudoflavor(pseudoflavor);\r\nif (gm == NULL)\r\nreturn -ENOENT;\r\nfor (i = 0; i < gm->gm_pf_num; i++) {\r\nif (gm->gm_pfs[i].pseudoflavor == pseudoflavor) {\r\nmemcpy(info->oid.data, gm->gm_oid.data, gm->gm_oid.len);\r\ninfo->oid.len = gm->gm_oid.len;\r\ninfo->qop = gm->gm_pfs[i].qop;\r\ninfo->service = gm->gm_pfs[i].service;\r\ngss_mech_put(gm);\r\nreturn 0;\r\n}\r\n}\r\ngss_mech_put(gm);\r\nreturn -ENOENT;\r\n}\r\nu32\r\ngss_pseudoflavor_to_service(struct gss_api_mech *gm, u32 pseudoflavor)\r\n{\r\nint i;\r\nfor (i = 0; i < gm->gm_pf_num; i++) {\r\nif (gm->gm_pfs[i].pseudoflavor == pseudoflavor)\r\nreturn gm->gm_pfs[i].service;\r\n}\r\nreturn 0;\r\n}\r\nchar *\r\ngss_service_to_auth_domain_name(struct gss_api_mech *gm, u32 service)\r\n{\r\nint i;\r\nfor (i = 0; i < gm->gm_pf_num; i++) {\r\nif (gm->gm_pfs[i].service == service)\r\nreturn gm->gm_pfs[i].auth_domain_name;\r\n}\r\nreturn NULL;\r\n}\r\nvoid\r\ngss_mech_put(struct gss_api_mech * gm)\r\n{\r\nif (gm)\r\nmodule_put(gm->gm_owner);\r\n}\r\nint\r\ngss_import_sec_context(const void *input_token, size_t bufsize,\r\nstruct gss_api_mech *mech,\r\nstruct gss_ctx **ctx_id,\r\ntime_t *endtime,\r\ngfp_t gfp_mask)\r\n{\r\nif (!(*ctx_id = kzalloc(sizeof(**ctx_id), gfp_mask)))\r\nreturn -ENOMEM;\r\n(*ctx_id)->mech_type = gss_mech_get(mech);\r\nreturn mech->gm_ops->gss_import_sec_context(input_token, bufsize,\r\n*ctx_id, endtime, gfp_mask);\r\n}\r\nu32\r\ngss_get_mic(struct gss_ctx *context_handle,\r\nstruct xdr_buf *message,\r\nstruct xdr_netobj *mic_token)\r\n{\r\nreturn context_handle->mech_type->gm_ops\r\n->gss_get_mic(context_handle,\r\nmessage,\r\nmic_token);\r\n}\r\nu32\r\ngss_verify_mic(struct gss_ctx *context_handle,\r\nstruct xdr_buf *message,\r\nstruct xdr_netobj *mic_token)\r\n{\r\nreturn context_handle->mech_type->gm_ops\r\n->gss_verify_mic(context_handle,\r\nmessage,\r\nmic_token);\r\n}\r\nu32\r\ngss_wrap(struct gss_ctx *ctx_id,\r\nint offset,\r\nstruct xdr_buf *buf,\r\nstruct page **inpages)\r\n{\r\nreturn ctx_id->mech_type->gm_ops\r\n->gss_wrap(ctx_id, offset, buf, inpages);\r\n}\r\nu32\r\ngss_unwrap(struct gss_ctx *ctx_id,\r\nint offset,\r\nstruct xdr_buf *buf)\r\n{\r\nreturn ctx_id->mech_type->gm_ops\r\n->gss_unwrap(ctx_id, offset, buf);\r\n}\r\nu32\r\ngss_delete_sec_context(struct gss_ctx **context_handle)\r\n{\r\ndprintk("RPC: gss_delete_sec_context deleting %p\n",\r\n*context_handle);\r\nif (!*context_handle)\r\nreturn GSS_S_NO_CONTEXT;\r\nif ((*context_handle)->internal_ctx_id)\r\n(*context_handle)->mech_type->gm_ops\r\n->gss_delete_sec_context((*context_handle)\r\n->internal_ctx_id);\r\ngss_mech_put((*context_handle)->mech_type);\r\nkfree(*context_handle);\r\n*context_handle=NULL;\r\nreturn GSS_S_COMPLETE;\r\n}
