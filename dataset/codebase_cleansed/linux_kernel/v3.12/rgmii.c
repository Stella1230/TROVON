static inline int rgmii_valid_mode(int phy_mode)\r\n{\r\nreturn phy_mode == PHY_MODE_GMII ||\r\nphy_mode == PHY_MODE_MII ||\r\nphy_mode == PHY_MODE_RGMII ||\r\nphy_mode == PHY_MODE_TBI ||\r\nphy_mode == PHY_MODE_RTBI;\r\n}\r\nstatic inline const char *rgmii_mode_name(int mode)\r\n{\r\nswitch (mode) {\r\ncase PHY_MODE_RGMII:\r\nreturn "RGMII";\r\ncase PHY_MODE_TBI:\r\nreturn "TBI";\r\ncase PHY_MODE_GMII:\r\nreturn "GMII";\r\ncase PHY_MODE_MII:\r\nreturn "MII";\r\ncase PHY_MODE_RTBI:\r\nreturn "RTBI";\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic inline u32 rgmii_mode_mask(int mode, int input)\r\n{\r\nswitch (mode) {\r\ncase PHY_MODE_RGMII:\r\nreturn RGMII_FER_RGMII(input);\r\ncase PHY_MODE_TBI:\r\nreturn RGMII_FER_TBI(input);\r\ncase PHY_MODE_GMII:\r\nreturn RGMII_FER_GMII(input);\r\ncase PHY_MODE_MII:\r\nreturn RGMII_FER_MII(input);\r\ncase PHY_MODE_RTBI:\r\nreturn RGMII_FER_RTBI(input);\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nint rgmii_attach(struct platform_device *ofdev, int input, int mode)\r\n{\r\nstruct rgmii_instance *dev = platform_get_drvdata(ofdev);\r\nstruct rgmii_regs __iomem *p = dev->base;\r\nRGMII_DBG(dev, "attach(%d)" NL, input);\r\nif (input < 0 || !rgmii_valid_mode(mode)) {\r\nprintk(KERN_ERR "%s: unsupported settings !\n",\r\nofdev->dev.of_node->full_name);\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&dev->lock);\r\nout_be32(&p->fer, in_be32(&p->fer) | rgmii_mode_mask(mode, input));\r\nprintk(KERN_NOTICE "%s: input %d in %s mode\n",\r\nofdev->dev.of_node->full_name, input, rgmii_mode_name(mode));\r\n++dev->users;\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nvoid rgmii_set_speed(struct platform_device *ofdev, int input, int speed)\r\n{\r\nstruct rgmii_instance *dev = platform_get_drvdata(ofdev);\r\nstruct rgmii_regs __iomem *p = dev->base;\r\nu32 ssr;\r\nmutex_lock(&dev->lock);\r\nssr = in_be32(&p->ssr) & ~RGMII_SSR_MASK(input);\r\nRGMII_DBG(dev, "speed(%d, %d)" NL, input, speed);\r\nif (speed == SPEED_1000)\r\nssr |= RGMII_SSR_1000(input);\r\nelse if (speed == SPEED_100)\r\nssr |= RGMII_SSR_100(input);\r\nout_be32(&p->ssr, ssr);\r\nmutex_unlock(&dev->lock);\r\n}\r\nvoid rgmii_get_mdio(struct platform_device *ofdev, int input)\r\n{\r\nstruct rgmii_instance *dev = platform_get_drvdata(ofdev);\r\nstruct rgmii_regs __iomem *p = dev->base;\r\nu32 fer;\r\nRGMII_DBG2(dev, "get_mdio(%d)" NL, input);\r\nif (!(dev->flags & EMAC_RGMII_FLAG_HAS_MDIO))\r\nreturn;\r\nmutex_lock(&dev->lock);\r\nfer = in_be32(&p->fer);\r\nfer |= 0x00080000u >> input;\r\nout_be32(&p->fer, fer);\r\n(void)in_be32(&p->fer);\r\nDBG2(dev, " fer = 0x%08x\n", fer);\r\n}\r\nvoid rgmii_put_mdio(struct platform_device *ofdev, int input)\r\n{\r\nstruct rgmii_instance *dev = platform_get_drvdata(ofdev);\r\nstruct rgmii_regs __iomem *p = dev->base;\r\nu32 fer;\r\nRGMII_DBG2(dev, "put_mdio(%d)" NL, input);\r\nif (!(dev->flags & EMAC_RGMII_FLAG_HAS_MDIO))\r\nreturn;\r\nfer = in_be32(&p->fer);\r\nfer &= ~(0x00080000u >> input);\r\nout_be32(&p->fer, fer);\r\n(void)in_be32(&p->fer);\r\nDBG2(dev, " fer = 0x%08x\n", fer);\r\nmutex_unlock(&dev->lock);\r\n}\r\nvoid rgmii_detach(struct platform_device *ofdev, int input)\r\n{\r\nstruct rgmii_instance *dev = platform_get_drvdata(ofdev);\r\nstruct rgmii_regs __iomem *p;\r\nBUG_ON(!dev || dev->users == 0);\r\np = dev->base;\r\nmutex_lock(&dev->lock);\r\nRGMII_DBG(dev, "detach(%d)" NL, input);\r\nout_be32(&p->fer, in_be32(&p->fer) & ~RGMII_FER_MASK(input));\r\n--dev->users;\r\nmutex_unlock(&dev->lock);\r\n}\r\nint rgmii_get_regs_len(struct platform_device *ofdev)\r\n{\r\nreturn sizeof(struct emac_ethtool_regs_subhdr) +\r\nsizeof(struct rgmii_regs);\r\n}\r\nvoid *rgmii_dump_regs(struct platform_device *ofdev, void *buf)\r\n{\r\nstruct rgmii_instance *dev = platform_get_drvdata(ofdev);\r\nstruct emac_ethtool_regs_subhdr *hdr = buf;\r\nstruct rgmii_regs *regs = (struct rgmii_regs *)(hdr + 1);\r\nhdr->version = 0;\r\nhdr->index = 0;\r\nmemcpy_fromio(regs, dev->base, sizeof(struct rgmii_regs));\r\nreturn regs + 1;\r\n}\r\nstatic int rgmii_probe(struct platform_device *ofdev)\r\n{\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct rgmii_instance *dev;\r\nstruct resource regs;\r\nint rc;\r\nrc = -ENOMEM;\r\ndev = kzalloc(sizeof(struct rgmii_instance), GFP_KERNEL);\r\nif (dev == NULL)\r\ngoto err_gone;\r\nmutex_init(&dev->lock);\r\ndev->ofdev = ofdev;\r\nrc = -ENXIO;\r\nif (of_address_to_resource(np, 0, &regs)) {\r\nprintk(KERN_ERR "%s: Can't get registers address\n",\r\nnp->full_name);\r\ngoto err_free;\r\n}\r\nrc = -ENOMEM;\r\ndev->base = (struct rgmii_regs __iomem *)ioremap(regs.start,\r\nsizeof(struct rgmii_regs));\r\nif (dev->base == NULL) {\r\nprintk(KERN_ERR "%s: Can't map device registers!\n",\r\nnp->full_name);\r\ngoto err_free;\r\n}\r\nif (of_get_property(ofdev->dev.of_node, "has-mdio", NULL))\r\ndev->flags |= EMAC_RGMII_FLAG_HAS_MDIO;\r\nif (of_device_is_compatible(ofdev->dev.of_node, "ibm,rgmii-axon"))\r\ndev->flags |= EMAC_RGMII_FLAG_HAS_MDIO;\r\nDBG2(dev, " Boot FER = 0x%08x, SSR = 0x%08x\n",\r\nin_be32(&dev->base->fer), in_be32(&dev->base->ssr));\r\nout_be32(&dev->base->fer, 0);\r\nprintk(KERN_INFO\r\n"RGMII %s initialized with%s MDIO support\n",\r\nofdev->dev.of_node->full_name,\r\n(dev->flags & EMAC_RGMII_FLAG_HAS_MDIO) ? "" : "out");\r\nwmb();\r\nplatform_set_drvdata(ofdev, dev);\r\nreturn 0;\r\nerr_free:\r\nkfree(dev);\r\nerr_gone:\r\nreturn rc;\r\n}\r\nstatic int rgmii_remove(struct platform_device *ofdev)\r\n{\r\nstruct rgmii_instance *dev = platform_get_drvdata(ofdev);\r\nWARN_ON(dev->users != 0);\r\niounmap(dev->base);\r\nkfree(dev);\r\nreturn 0;\r\n}\r\nint __init rgmii_init(void)\r\n{\r\nreturn platform_driver_register(&rgmii_driver);\r\n}\r\nvoid rgmii_exit(void)\r\n{\r\nplatform_driver_unregister(&rgmii_driver);\r\n}
