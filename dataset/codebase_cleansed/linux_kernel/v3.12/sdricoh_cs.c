static inline unsigned int sdricoh_readl(struct sdricoh_host *host,\r\nunsigned int reg)\r\n{\r\nunsigned int value = readl(host->iobase + reg);\r\ndev_vdbg(host->dev, "rl %x 0x%x\n", reg, value);\r\nreturn value;\r\n}\r\nstatic inline void sdricoh_writel(struct sdricoh_host *host, unsigned int reg,\r\nunsigned int value)\r\n{\r\nwritel(value, host->iobase + reg);\r\ndev_vdbg(host->dev, "wl %x 0x%x\n", reg, value);\r\n}\r\nstatic inline unsigned int sdricoh_readw(struct sdricoh_host *host,\r\nunsigned int reg)\r\n{\r\nunsigned int value = readw(host->iobase + reg);\r\ndev_vdbg(host->dev, "rb %x 0x%x\n", reg, value);\r\nreturn value;\r\n}\r\nstatic inline void sdricoh_writew(struct sdricoh_host *host, unsigned int reg,\r\nunsigned short value)\r\n{\r\nwritew(value, host->iobase + reg);\r\ndev_vdbg(host->dev, "ww %x 0x%x\n", reg, value);\r\n}\r\nstatic inline unsigned int sdricoh_readb(struct sdricoh_host *host,\r\nunsigned int reg)\r\n{\r\nunsigned int value = readb(host->iobase + reg);\r\ndev_vdbg(host->dev, "rb %x 0x%x\n", reg, value);\r\nreturn value;\r\n}\r\nstatic int sdricoh_query_status(struct sdricoh_host *host, unsigned int wanted,\r\nunsigned int timeout){\r\nunsigned int loop;\r\nunsigned int status = 0;\r\nstruct device *dev = host->dev;\r\nfor (loop = 0; loop < timeout; loop++) {\r\nstatus = sdricoh_readl(host, R21C_STATUS);\r\nsdricoh_writel(host, R2E4_STATUS_RESP, status);\r\nif (status & wanted)\r\nbreak;\r\n}\r\nif (loop == timeout) {\r\ndev_err(dev, "query_status: timeout waiting for %x\n", wanted);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (status & 0x7F0000) {\r\ndev_err(dev, "waiting for status bit %x failed\n", wanted);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sdricoh_mmc_cmd(struct sdricoh_host *host, unsigned char opcode,\r\nunsigned int arg)\r\n{\r\nunsigned int status;\r\nint result = 0;\r\nunsigned int loop = 0;\r\nsdricoh_writel(host, R21C_STATUS, 0x18);\r\nsdricoh_writel(host, R204_CMD_ARG, arg);\r\nsdricoh_writel(host, R200_CMD, (0x10000 << 8) | opcode);\r\nif (opcode) {\r\nfor (loop = 0; loop < CMD_TIMEOUT; loop++) {\r\nstatus = sdricoh_readl(host, R21C_STATUS);\r\nsdricoh_writel(host, R2E4_STATUS_RESP, status);\r\nif (status & STATUS_CMD_FINISHED)\r\nbreak;\r\n}\r\nif (loop == CMD_TIMEOUT || status & STATUS_CMD_TIMEOUT)\r\nresult = -ETIMEDOUT;\r\n}\r\nreturn result;\r\n}\r\nstatic int sdricoh_reset(struct sdricoh_host *host)\r\n{\r\ndev_dbg(host->dev, "reset\n");\r\nsdricoh_writel(host, R2F0_RESET, 0x10001);\r\nsdricoh_writel(host, R2E0_INIT, 0x10000);\r\nif (sdricoh_readl(host, R2E0_INIT) != 0x10000)\r\nreturn -EIO;\r\nsdricoh_writel(host, R2E0_INIT, 0x10007);\r\nsdricoh_writel(host, R224_MODE, 0x2000000);\r\nsdricoh_writel(host, R228_POWER, 0xe0);\r\nsdricoh_writel(host, R21C_STATUS, 0x18);\r\nreturn 0;\r\n}\r\nstatic int sdricoh_blockio(struct sdricoh_host *host, int read,\r\nu8 *buf, int len)\r\n{\r\nint size;\r\nu32 data = 0;\r\nif (read) {\r\nif (sdricoh_query_status(host, STATUS_READY_TO_READ,\r\nTRANSFER_TIMEOUT))\r\nreturn -ETIMEDOUT;\r\nsdricoh_writel(host, R21C_STATUS, 0x18);\r\nwhile (len) {\r\ndata = sdricoh_readl(host, R230_DATA);\r\nsize = min(len, 4);\r\nlen -= size;\r\nwhile (size) {\r\n*buf = data & 0xFF;\r\nbuf++;\r\ndata >>= 8;\r\nsize--;\r\n}\r\n}\r\n} else {\r\nif (sdricoh_query_status(host, STATUS_READY_TO_WRITE,\r\nTRANSFER_TIMEOUT))\r\nreturn -ETIMEDOUT;\r\nsdricoh_writel(host, R21C_STATUS, 0x18);\r\nwhile (len) {\r\nsize = min(len, 4);\r\nlen -= size;\r\nwhile (size) {\r\ndata >>= 8;\r\ndata |= (u32)*buf << 24;\r\nbuf++;\r\nsize--;\r\n}\r\nsdricoh_writel(host, R230_DATA, data);\r\n}\r\n}\r\nif (len)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void sdricoh_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct sdricoh_host *host = mmc_priv(mmc);\r\nstruct mmc_command *cmd = mrq->cmd;\r\nstruct mmc_data *data = cmd->data;\r\nstruct device *dev = host->dev;\r\nunsigned char opcode = cmd->opcode;\r\nint i;\r\ndev_dbg(dev, "=============================\n");\r\ndev_dbg(dev, "sdricoh_request opcode=%i\n", opcode);\r\nsdricoh_writel(host, R21C_STATUS, 0x18);\r\nif (host->app_cmd) {\r\nopcode |= 64;\r\nhost->app_cmd = 0;\r\n} else if (opcode == 55)\r\nhost->app_cmd = 1;\r\nif (data) {\r\nsdricoh_writew(host, R226_BLOCKSIZE, data->blksz);\r\nsdricoh_writel(host, R208_DATAIO, 0);\r\n}\r\ncmd->error = sdricoh_mmc_cmd(host, opcode, cmd->arg);\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\nif (cmd->flags & MMC_RSP_136) {\r\nfor (i = 0; i < 4; i++) {\r\ncmd->resp[i] =\r\nsdricoh_readl(host,\r\nR20C_RESP + (3 - i) * 4) << 8;\r\nif (i != 3)\r\ncmd->resp[i] |=\r\nsdricoh_readb(host, R20C_RESP +\r\n(3 - i) * 4 - 1);\r\n}\r\n} else\r\ncmd->resp[0] = sdricoh_readl(host, R20C_RESP);\r\n}\r\nif (data && cmd->error == 0) {\r\ndev_dbg(dev, "transfer: blksz %i blocks %i sg_len %i "\r\n"sg length %i\n", data->blksz, data->blocks,\r\ndata->sg_len, data->sg->length);\r\nsdricoh_writel(host, R21C_STATUS, 0x837f031e);\r\nfor (i = 0; i < data->blocks; i++) {\r\nsize_t len = data->blksz;\r\nu8 *buf;\r\nstruct page *page;\r\nint result;\r\npage = sg_page(data->sg);\r\nbuf = kmap(page) + data->sg->offset + (len * i);\r\nresult =\r\nsdricoh_blockio(host,\r\ndata->flags & MMC_DATA_READ, buf, len);\r\nkunmap(page);\r\nflush_dcache_page(page);\r\nif (result) {\r\ndev_err(dev, "sdricoh_request: cmd %i "\r\n"block transfer failed\n", cmd->opcode);\r\ncmd->error = result;\r\nbreak;\r\n} else\r\ndata->bytes_xfered += len;\r\n}\r\nsdricoh_writel(host, R208_DATAIO, 1);\r\nif (sdricoh_query_status(host, STATUS_TRANSFER_FINISHED,\r\nTRANSFER_TIMEOUT)) {\r\ndev_err(dev, "sdricoh_request: transfer end error\n");\r\ncmd->error = -EINVAL;\r\n}\r\n}\r\nmmc_request_done(mmc, mrq);\r\ndev_dbg(dev, "=============================\n");\r\n}\r\nstatic void sdricoh_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct sdricoh_host *host = mmc_priv(mmc);\r\ndev_dbg(host->dev, "set_ios\n");\r\nif (ios->power_mode == MMC_POWER_ON) {\r\nsdricoh_writel(host, R228_POWER, 0xc0e0);\r\nif (ios->bus_width == MMC_BUS_WIDTH_4) {\r\nsdricoh_writel(host, R224_MODE, 0x2000300);\r\nsdricoh_writel(host, R228_POWER, 0x40e0);\r\n} else {\r\nsdricoh_writel(host, R224_MODE, 0x2000340);\r\n}\r\n} else if (ios->power_mode == MMC_POWER_UP) {\r\nsdricoh_writel(host, R224_MODE, 0x2000320);\r\nsdricoh_writel(host, R228_POWER, 0xe0);\r\n}\r\n}\r\nstatic int sdricoh_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct sdricoh_host *host = mmc_priv(mmc);\r\nunsigned int status;\r\nstatus = sdricoh_readl(host, R21C_STATUS);\r\nsdricoh_writel(host, R2E4_STATUS_RESP, status);\r\nif (switchlocked)\r\nreturn !(status & STATUS_CARD_LOCKED);\r\nreturn (status & STATUS_CARD_LOCKED);\r\n}\r\nstatic int sdricoh_init_mmc(struct pci_dev *pci_dev,\r\nstruct pcmcia_device *pcmcia_dev)\r\n{\r\nint result = 0;\r\nvoid __iomem *iobase = NULL;\r\nstruct mmc_host *mmc = NULL;\r\nstruct sdricoh_host *host = NULL;\r\nstruct device *dev = &pcmcia_dev->dev;\r\nif (pci_resource_len(pci_dev, SDRICOH_PCI_REGION) !=\r\nSDRICOH_PCI_REGION_SIZE) {\r\ndev_dbg(dev, "unexpected pci resource len\n");\r\nreturn -ENODEV;\r\n}\r\niobase =\r\npci_iomap(pci_dev, SDRICOH_PCI_REGION, SDRICOH_PCI_REGION_SIZE);\r\nif (!iobase) {\r\ndev_err(dev, "unable to map iobase\n");\r\nreturn -ENODEV;\r\n}\r\nif (readl(iobase + R104_VERSION) != 0x4000) {\r\ndev_dbg(dev, "no supported mmc controller found\n");\r\nresult = -ENODEV;\r\ngoto err;\r\n}\r\nmmc = pcmcia_dev->priv =\r\nmmc_alloc_host(sizeof(struct sdricoh_host), &pcmcia_dev->dev);\r\nif (!mmc) {\r\ndev_err(dev, "mmc_alloc_host failed\n");\r\nresult = -ENOMEM;\r\ngoto err;\r\n}\r\nhost = mmc_priv(mmc);\r\nhost->iobase = iobase;\r\nhost->dev = dev;\r\nhost->pci_dev = pci_dev;\r\nmmc->ops = &sdricoh_ops;\r\nmmc->f_min = 450000;\r\nmmc->f_max = 24000000;\r\nmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\r\nmmc->caps |= MMC_CAP_4_BIT_DATA;\r\nmmc->max_seg_size = 1024 * 512;\r\nmmc->max_blk_size = 512;\r\nif (sdricoh_reset(host)) {\r\ndev_dbg(dev, "could not reset\n");\r\nresult = -EIO;\r\ngoto err;\r\n}\r\nresult = mmc_add_host(mmc);\r\nif (!result) {\r\ndev_dbg(dev, "mmc host registered\n");\r\nreturn 0;\r\n}\r\nerr:\r\nif (iobase)\r\npci_iounmap(pci_dev, iobase);\r\nif (mmc)\r\nmmc_free_host(mmc);\r\nreturn result;\r\n}\r\nstatic int sdricoh_pcmcia_probe(struct pcmcia_device *pcmcia_dev)\r\n{\r\nstruct pci_dev *pci_dev = NULL;\r\ndev_info(&pcmcia_dev->dev, "Searching MMC controller for pcmcia device"\r\n" %s %s ...\n", pcmcia_dev->prod_id[0], pcmcia_dev->prod_id[1]);\r\nwhile ((pci_dev =\r\npci_get_device(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_RL5C476,\r\npci_dev))) {\r\nif (!sdricoh_init_mmc(pci_dev, pcmcia_dev)) {\r\ndev_info(&pcmcia_dev->dev, "MMC controller found\n");\r\nreturn 0;\r\n}\r\n}\r\ndev_err(&pcmcia_dev->dev, "No MMC controller was found.\n");\r\nreturn -ENODEV;\r\n}\r\nstatic void sdricoh_pcmcia_detach(struct pcmcia_device *link)\r\n{\r\nstruct mmc_host *mmc = link->priv;\r\ndev_dbg(&link->dev, "detach\n");\r\nif (mmc) {\r\nstruct sdricoh_host *host = mmc_priv(mmc);\r\nmmc_remove_host(mmc);\r\npci_iounmap(host->pci_dev, host->iobase);\r\npci_dev_put(host->pci_dev);\r\nmmc_free_host(mmc);\r\n}\r\npcmcia_disable_device(link);\r\n}\r\nstatic int sdricoh_pcmcia_suspend(struct pcmcia_device *link)\r\n{\r\nstruct mmc_host *mmc = link->priv;\r\ndev_dbg(&link->dev, "suspend\n");\r\nmmc_suspend_host(mmc);\r\nreturn 0;\r\n}\r\nstatic int sdricoh_pcmcia_resume(struct pcmcia_device *link)\r\n{\r\nstruct mmc_host *mmc = link->priv;\r\ndev_dbg(&link->dev, "resume\n");\r\nsdricoh_reset(mmc_priv(mmc));\r\nmmc_resume_host(mmc);\r\nreturn 0;\r\n}
