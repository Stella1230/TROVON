static void snd_wm8766_write(struct snd_wm8766 *wm, u16 addr, u16 data)\r\n{\r\nif (addr < WM8766_REG_COUNT)\r\nwm->regs[addr] = data;\r\nwm->ops.write(wm, addr, data);\r\n}\r\nvoid snd_wm8766_init(struct snd_wm8766 *wm)\r\n{\r\nint i;\r\nstatic const u16 default_values[] = {\r\n0x000, 0x100,\r\n0x120, 0x000,\r\n0x000, 0x100, 0x000, 0x100, 0x000,\r\n0x000, 0x080,\r\n};\r\nmemcpy(wm->ctl, snd_wm8766_default_ctl, sizeof(wm->ctl));\r\nsnd_wm8766_write(wm, WM8766_REG_RESET, 0x00);\r\nudelay(10);\r\nfor (i = 0; i < ARRAY_SIZE(default_values); i++)\r\nsnd_wm8766_write(wm, i, default_values[i]);\r\n}\r\nvoid snd_wm8766_resume(struct snd_wm8766 *wm)\r\n{\r\nint i;\r\nfor (i = 0; i < WM8766_REG_COUNT; i++)\r\nsnd_wm8766_write(wm, i, wm->regs[i]);\r\n}\r\nvoid snd_wm8766_set_if(struct snd_wm8766 *wm, u16 dac)\r\n{\r\nu16 val = wm->regs[WM8766_REG_IFCTRL] & ~WM8766_IF_MASK;\r\ndac &= WM8766_IF_MASK;\r\nsnd_wm8766_write(wm, WM8766_REG_IFCTRL, val | dac);\r\n}\r\nvoid snd_wm8766_set_master_mode(struct snd_wm8766 *wm, u16 mode)\r\n{\r\nu16 val = wm->regs[WM8766_REG_DACCTRL3] & ~WM8766_DAC3_MSTR_MASK;\r\nmode &= WM8766_DAC3_MSTR_MASK;\r\nsnd_wm8766_write(wm, WM8766_REG_DACCTRL3, val | mode);\r\n}\r\nvoid snd_wm8766_set_power(struct snd_wm8766 *wm, u16 power)\r\n{\r\nu16 val = wm->regs[WM8766_REG_DACCTRL3] & ~WM8766_DAC3_POWER_MASK;\r\npower &= WM8766_DAC3_POWER_MASK;\r\nsnd_wm8766_write(wm, WM8766_REG_DACCTRL3, val | power);\r\n}\r\nvoid snd_wm8766_volume_restore(struct snd_wm8766 *wm)\r\n{\r\nu16 val = wm->regs[WM8766_REG_DACR1];\r\nsnd_wm8766_write(wm, WM8766_REG_DACR1, val | WM8766_VOL_UPDATE);\r\n}\r\nstatic int snd_wm8766_volume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_wm8766 *wm = snd_kcontrol_chip(kcontrol);\r\nint n = kcontrol->private_value;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = (wm->ctl[n].flags & WM8766_FLAG_STEREO) ? 2 : 1;\r\nuinfo->value.integer.min = wm->ctl[n].min;\r\nuinfo->value.integer.max = wm->ctl[n].max;\r\nreturn 0;\r\n}\r\nstatic int snd_wm8766_enum_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_wm8766 *wm = snd_kcontrol_chip(kcontrol);\r\nint n = kcontrol->private_value;\r\nreturn snd_ctl_enum_info(uinfo, 1, wm->ctl[n].max,\r\nwm->ctl[n].enum_names);\r\n}\r\nstatic int snd_wm8766_ctl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wm8766 *wm = snd_kcontrol_chip(kcontrol);\r\nint n = kcontrol->private_value;\r\nu16 val1, val2;\r\nif (wm->ctl[n].get)\r\nwm->ctl[n].get(wm, &val1, &val2);\r\nelse {\r\nval1 = wm->regs[wm->ctl[n].reg1] & wm->ctl[n].mask1;\r\nval1 >>= __ffs(wm->ctl[n].mask1);\r\nif (wm->ctl[n].flags & WM8766_FLAG_STEREO) {\r\nval2 = wm->regs[wm->ctl[n].reg2] & wm->ctl[n].mask2;\r\nval2 >>= __ffs(wm->ctl[n].mask2);\r\nif (wm->ctl[n].flags & WM8766_FLAG_VOL_UPDATE)\r\nval2 &= ~WM8766_VOL_UPDATE;\r\n}\r\n}\r\nif (wm->ctl[n].flags & WM8766_FLAG_INVERT) {\r\nval1 = wm->ctl[n].max - (val1 - wm->ctl[n].min);\r\nval2 = wm->ctl[n].max - (val2 - wm->ctl[n].min);\r\n}\r\nucontrol->value.integer.value[0] = val1;\r\nif (wm->ctl[n].flags & WM8766_FLAG_STEREO)\r\nucontrol->value.integer.value[1] = val2;\r\nreturn 0;\r\n}\r\nstatic int snd_wm8766_ctl_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wm8766 *wm = snd_kcontrol_chip(kcontrol);\r\nint n = kcontrol->private_value;\r\nu16 val, regval1, regval2;\r\nregval1 = ucontrol->value.integer.value[0];\r\nregval2 = ucontrol->value.integer.value[1];\r\nif (wm->ctl[n].flags & WM8766_FLAG_INVERT) {\r\nregval1 = wm->ctl[n].max - (regval1 - wm->ctl[n].min);\r\nregval2 = wm->ctl[n].max - (regval2 - wm->ctl[n].min);\r\n}\r\nif (wm->ctl[n].set)\r\nwm->ctl[n].set(wm, regval1, regval2);\r\nelse {\r\nval = wm->regs[wm->ctl[n].reg1] & ~wm->ctl[n].mask1;\r\nval |= regval1 << __ffs(wm->ctl[n].mask1);\r\nif (wm->ctl[n].flags & WM8766_FLAG_STEREO &&\r\nwm->ctl[n].reg1 == wm->ctl[n].reg2) {\r\nval &= ~wm->ctl[n].mask2;\r\nval |= regval2 << __ffs(wm->ctl[n].mask2);\r\n}\r\nsnd_wm8766_write(wm, wm->ctl[n].reg1, val);\r\nif (wm->ctl[n].flags & WM8766_FLAG_STEREO &&\r\nwm->ctl[n].reg1 != wm->ctl[n].reg2) {\r\nval = wm->regs[wm->ctl[n].reg2] & ~wm->ctl[n].mask2;\r\nval |= regval2 << __ffs(wm->ctl[n].mask2);\r\nif (wm->ctl[n].flags & WM8766_FLAG_VOL_UPDATE)\r\nval |= WM8766_VOL_UPDATE;\r\nsnd_wm8766_write(wm, wm->ctl[n].reg2, val);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_wm8766_add_control(struct snd_wm8766 *wm, int num)\r\n{\r\nstruct snd_kcontrol_new cont;\r\nstruct snd_kcontrol *ctl;\r\nmemset(&cont, 0, sizeof(cont));\r\ncont.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\ncont.private_value = num;\r\ncont.name = wm->ctl[num].name;\r\ncont.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\r\nif (wm->ctl[num].flags & WM8766_FLAG_LIM ||\r\nwm->ctl[num].flags & WM8766_FLAG_ALC)\r\ncont.access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\ncont.tlv.p = NULL;\r\ncont.get = snd_wm8766_ctl_get;\r\ncont.put = snd_wm8766_ctl_put;\r\nswitch (wm->ctl[num].type) {\r\ncase SNDRV_CTL_ELEM_TYPE_INTEGER:\r\ncont.info = snd_wm8766_volume_info;\r\ncont.access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;\r\ncont.tlv.p = wm->ctl[num].tlv;\r\nbreak;\r\ncase SNDRV_CTL_ELEM_TYPE_BOOLEAN:\r\nwm->ctl[num].max = 1;\r\nif (wm->ctl[num].flags & WM8766_FLAG_STEREO)\r\ncont.info = snd_ctl_boolean_stereo_info;\r\nelse\r\ncont.info = snd_ctl_boolean_mono_info;\r\nbreak;\r\ncase SNDRV_CTL_ELEM_TYPE_ENUMERATED:\r\ncont.info = snd_wm8766_enum_info;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nctl = snd_ctl_new1(&cont, wm);\r\nif (!ctl)\r\nreturn -ENOMEM;\r\nwm->ctl[num].kctl = ctl;\r\nreturn snd_ctl_add(wm->card, ctl);\r\n}\r\nint snd_wm8766_build_controls(struct snd_wm8766 *wm)\r\n{\r\nint err, i;\r\nfor (i = 0; i < WM8766_CTL_COUNT; i++)\r\nif (wm->ctl[i].name) {\r\nerr = snd_wm8766_add_control(wm, i);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
