static u32\r\nsn9c102_request_buffers(struct sn9c102_device* cam, u32 count,\r\nenum sn9c102_io_method io)\r\n{\r\nstruct v4l2_pix_format* p = &(cam->sensor.pix_format);\r\nstruct v4l2_rect* r = &(cam->sensor.cropcap.bounds);\r\nsize_t imagesize = cam->module_param.force_munmap || io == IO_READ ?\r\n(p->width * p->height * p->priv) / 8 :\r\n(r->width * r->height * p->priv) / 8;\r\nvoid* buff = NULL;\r\nu32 i;\r\nif (count > SN9C102_MAX_FRAMES)\r\ncount = SN9C102_MAX_FRAMES;\r\nif (cam->bridge == BRIDGE_SN9C105 || cam->bridge == BRIDGE_SN9C120)\r\nimagesize += 589 + 2;\r\ncam->nbuffers = count;\r\nwhile (cam->nbuffers > 0) {\r\nif ((buff = vmalloc_32_user(cam->nbuffers *\r\nPAGE_ALIGN(imagesize))))\r\nbreak;\r\ncam->nbuffers--;\r\n}\r\nfor (i = 0; i < cam->nbuffers; i++) {\r\ncam->frame[i].bufmem = buff + i*PAGE_ALIGN(imagesize);\r\ncam->frame[i].buf.index = i;\r\ncam->frame[i].buf.m.offset = i*PAGE_ALIGN(imagesize);\r\ncam->frame[i].buf.length = imagesize;\r\ncam->frame[i].buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ncam->frame[i].buf.sequence = 0;\r\ncam->frame[i].buf.field = V4L2_FIELD_NONE;\r\ncam->frame[i].buf.memory = V4L2_MEMORY_MMAP;\r\ncam->frame[i].buf.flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\n}\r\nreturn cam->nbuffers;\r\n}\r\nstatic void sn9c102_release_buffers(struct sn9c102_device* cam)\r\n{\r\nif (cam->nbuffers) {\r\nvfree(cam->frame[0].bufmem);\r\ncam->nbuffers = 0;\r\n}\r\ncam->frame_current = NULL;\r\n}\r\nstatic void sn9c102_empty_framequeues(struct sn9c102_device* cam)\r\n{\r\nu32 i;\r\nINIT_LIST_HEAD(&cam->inqueue);\r\nINIT_LIST_HEAD(&cam->outqueue);\r\nfor (i = 0; i < SN9C102_MAX_FRAMES; i++) {\r\ncam->frame[i].state = F_UNUSED;\r\ncam->frame[i].buf.bytesused = 0;\r\n}\r\n}\r\nstatic void sn9c102_requeue_outqueue(struct sn9c102_device* cam)\r\n{\r\nstruct sn9c102_frame_t *i;\r\nlist_for_each_entry(i, &cam->outqueue, frame) {\r\ni->state = F_QUEUED;\r\nlist_add(&i->frame, &cam->inqueue);\r\n}\r\nINIT_LIST_HEAD(&cam->outqueue);\r\n}\r\nstatic void sn9c102_queue_unusedframes(struct sn9c102_device* cam)\r\n{\r\nunsigned long lock_flags;\r\nu32 i;\r\nfor (i = 0; i < cam->nbuffers; i++)\r\nif (cam->frame[i].state == F_UNUSED) {\r\ncam->frame[i].state = F_QUEUED;\r\nspin_lock_irqsave(&cam->queue_lock, lock_flags);\r\nlist_add_tail(&cam->frame[i].frame, &cam->inqueue);\r\nspin_unlock_irqrestore(&cam->queue_lock, lock_flags);\r\n}\r\n}\r\nint sn9c102_write_regs(struct sn9c102_device* cam, const u8 valreg[][2],\r\nint count)\r\n{\r\nstruct usb_device* udev = cam->usbdev;\r\nu8* buff = cam->control_buffer;\r\nint i, res;\r\nfor (i = 0; i < count; i++) {\r\nu8 index = valreg[i][1];\r\n*buff = valreg[i][0];\r\nres = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x08,\r\n0x41, index, 0, buff, 1,\r\nSN9C102_CTRL_TIMEOUT);\r\nif (res < 0) {\r\nDBG(3, "Failed to write a register (value 0x%02X, "\r\n"index 0x%02X, error %d)", *buff, index, res);\r\nreturn -1;\r\n}\r\ncam->reg[index] = *buff;\r\n}\r\nreturn 0;\r\n}\r\nint sn9c102_write_reg(struct sn9c102_device* cam, u8 value, u16 index)\r\n{\r\nstruct usb_device* udev = cam->usbdev;\r\nu8* buff = cam->control_buffer;\r\nint res;\r\nif (index >= ARRAY_SIZE(cam->reg))\r\nreturn -1;\r\n*buff = value;\r\nres = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x08, 0x41,\r\nindex, 0, buff, 1, SN9C102_CTRL_TIMEOUT);\r\nif (res < 0) {\r\nDBG(3, "Failed to write a register (value 0x%02X, index "\r\n"0x%02X, error %d)", value, index, res);\r\nreturn -1;\r\n}\r\ncam->reg[index] = value;\r\nreturn 0;\r\n}\r\nint sn9c102_read_reg(struct sn9c102_device* cam, u16 index)\r\n{\r\nstruct usb_device* udev = cam->usbdev;\r\nu8* buff = cam->control_buffer;\r\nint res;\r\nres = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x00, 0xc1,\r\nindex, 0, buff, 1, SN9C102_CTRL_TIMEOUT);\r\nif (res < 0)\r\nDBG(3, "Failed to read a register (index 0x%02X, error %d)",\r\nindex, res);\r\nreturn (res >= 0) ? (int)(*buff) : -1;\r\n}\r\nint sn9c102_pread_reg(struct sn9c102_device* cam, u16 index)\r\n{\r\nif (index >= ARRAY_SIZE(cam->reg))\r\nreturn -1;\r\nreturn cam->reg[index];\r\n}\r\nstatic int\r\nsn9c102_i2c_wait(struct sn9c102_device* cam,\r\nconst struct sn9c102_sensor* sensor)\r\n{\r\nint i, r;\r\nfor (i = 1; i <= 5; i++) {\r\nr = sn9c102_read_reg(cam, 0x08);\r\nif (r < 0)\r\nreturn -EIO;\r\nif (r & 0x04)\r\nreturn 0;\r\nif (sensor->frequency & SN9C102_I2C_400KHZ)\r\nudelay(5*16);\r\nelse\r\nudelay(16*16);\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int\r\nsn9c102_i2c_detect_read_error(struct sn9c102_device* cam,\r\nconst struct sn9c102_sensor* sensor)\r\n{\r\nint r , err = 0;\r\nr = sn9c102_read_reg(cam, 0x08);\r\nif (r < 0)\r\nerr += r;\r\nif (cam->bridge == BRIDGE_SN9C101 || cam->bridge == BRIDGE_SN9C102) {\r\nif (!(r & 0x08))\r\nerr += -1;\r\n} else {\r\nif (r & 0x08)\r\nerr += -1;\r\n}\r\nreturn err ? -EIO : 0;\r\n}\r\nstatic int\r\nsn9c102_i2c_detect_write_error(struct sn9c102_device* cam,\r\nconst struct sn9c102_sensor* sensor)\r\n{\r\nint r;\r\nr = sn9c102_read_reg(cam, 0x08);\r\nreturn (r < 0 || (r >= 0 && (r & 0x08))) ? -EIO : 0;\r\n}\r\nint\r\nsn9c102_i2c_try_raw_read(struct sn9c102_device* cam,\r\nconst struct sn9c102_sensor* sensor, u8 data0,\r\nu8 data1, u8 n, u8 buffer[])\r\n{\r\nstruct usb_device* udev = cam->usbdev;\r\nu8* data = cam->control_buffer;\r\nint i = 0, err = 0, res;\r\ndata[0] = ((sensor->interface == SN9C102_I2C_2WIRES) ? 0x80 : 0) |\r\n((sensor->frequency & SN9C102_I2C_400KHZ) ? 0x01 : 0) | 0x10;\r\ndata[1] = data0;\r\ndata[2] = data1;\r\ndata[7] = 0x10;\r\nres = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x08, 0x41,\r\n0x08, 0, data, 8, SN9C102_CTRL_TIMEOUT);\r\nif (res < 0)\r\nerr += res;\r\nerr += sn9c102_i2c_wait(cam, sensor);\r\ndata[0] = ((sensor->interface == SN9C102_I2C_2WIRES) ? 0x80 : 0) |\r\n((sensor->frequency & SN9C102_I2C_400KHZ) ? 0x01 : 0) |\r\n(n << 4) | 0x02;\r\ndata[1] = data0;\r\ndata[7] = 0x10;\r\nres = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x08, 0x41,\r\n0x08, 0, data, 8, SN9C102_CTRL_TIMEOUT);\r\nif (res < 0)\r\nerr += res;\r\nerr += sn9c102_i2c_wait(cam, sensor);\r\nres = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x00, 0xc1,\r\n0x0a, 0, data, 5, SN9C102_CTRL_TIMEOUT);\r\nif (res < 0)\r\nerr += res;\r\nerr += sn9c102_i2c_detect_read_error(cam, sensor);\r\nPDBGG("I2C read: address 0x%02X, first read byte: 0x%02X", data1,\r\ndata[4]);\r\nif (err) {\r\nDBG(3, "I2C read failed for %s image sensor", sensor->name);\r\nreturn -1;\r\n}\r\nif (buffer)\r\nfor (i = 0; i < n && i < 5; i++)\r\nbuffer[n-i-1] = data[4-i];\r\nreturn (int)data[4];\r\n}\r\nint\r\nsn9c102_i2c_try_raw_write(struct sn9c102_device* cam,\r\nconst struct sn9c102_sensor* sensor, u8 n, u8 data0,\r\nu8 data1, u8 data2, u8 data3, u8 data4, u8 data5)\r\n{\r\nstruct usb_device* udev = cam->usbdev;\r\nu8* data = cam->control_buffer;\r\nint err = 0, res;\r\ndata[0] = ((sensor->interface == SN9C102_I2C_2WIRES) ? 0x80 : 0) |\r\n((sensor->frequency & SN9C102_I2C_400KHZ) ? 0x01 : 0)\r\n| ((n - 1) << 4);\r\ndata[1] = data0;\r\ndata[2] = data1;\r\ndata[3] = data2;\r\ndata[4] = data3;\r\ndata[5] = data4;\r\ndata[6] = data5;\r\ndata[7] = 0x17;\r\nres = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x08, 0x41,\r\n0x08, 0, data, 8, SN9C102_CTRL_TIMEOUT);\r\nif (res < 0)\r\nerr += res;\r\nerr += sn9c102_i2c_wait(cam, sensor);\r\nerr += sn9c102_i2c_detect_write_error(cam, sensor);\r\nif (err)\r\nDBG(3, "I2C write failed for %s image sensor", sensor->name);\r\nPDBGG("I2C raw write: %u bytes, data0 = 0x%02X, data1 = 0x%02X, "\r\n"data2 = 0x%02X, data3 = 0x%02X, data4 = 0x%02X, data5 = 0x%02X",\r\nn, data0, data1, data2, data3, data4, data5);\r\nreturn err ? -1 : 0;\r\n}\r\nint\r\nsn9c102_i2c_try_read(struct sn9c102_device* cam,\r\nconst struct sn9c102_sensor* sensor, u8 address)\r\n{\r\nreturn sn9c102_i2c_try_raw_read(cam, sensor, sensor->i2c_slave_id,\r\naddress, 1, NULL);\r\n}\r\nstatic int sn9c102_i2c_try_write(struct sn9c102_device* cam,\r\nconst struct sn9c102_sensor* sensor,\r\nu8 address, u8 value)\r\n{\r\nreturn sn9c102_i2c_try_raw_write(cam, sensor, 3,\r\nsensor->i2c_slave_id, address,\r\nvalue, 0, 0, 0);\r\n}\r\nint sn9c102_i2c_read(struct sn9c102_device* cam, u8 address)\r\n{\r\nreturn sn9c102_i2c_try_read(cam, &cam->sensor, address);\r\n}\r\nint sn9c102_i2c_write(struct sn9c102_device* cam, u8 address, u8 value)\r\n{\r\nreturn sn9c102_i2c_try_write(cam, &cam->sensor, address, value);\r\n}\r\nstatic size_t sn9c102_sof_length(struct sn9c102_device* cam)\r\n{\r\nswitch (cam->bridge) {\r\ncase BRIDGE_SN9C101:\r\ncase BRIDGE_SN9C102:\r\nreturn 12;\r\ncase BRIDGE_SN9C103:\r\nreturn 18;\r\ncase BRIDGE_SN9C105:\r\ncase BRIDGE_SN9C120:\r\nreturn 62;\r\n}\r\nreturn 0;\r\n}\r\nstatic void*\r\nsn9c102_find_sof_header(struct sn9c102_device* cam, void* mem, size_t len)\r\n{\r\nstatic const char marker[6] = {0xff, 0xff, 0x00, 0xc4, 0xc4, 0x96};\r\nconst char *m = mem;\r\nsize_t soflen = 0, i, j;\r\nsoflen = sn9c102_sof_length(cam);\r\nfor (i = 0; i < len; i++) {\r\nsize_t b;\r\nif (unlikely(cam->sof.bytesread >= sizeof(marker))) {\r\ncam->sof.header[cam->sof.bytesread] = *(m+i);\r\nif (++cam->sof.bytesread == soflen) {\r\ncam->sof.bytesread = 0;\r\nreturn mem + i;\r\n}\r\ncontinue;\r\n}\r\nfor (j = 0, b=cam->sof.bytesread; j+b < sizeof(marker); j++) {\r\nif (unlikely(i+j == len))\r\nreturn NULL;\r\nif (*(m+i+j) == marker[cam->sof.bytesread]) {\r\ncam->sof.header[cam->sof.bytesread] = *(m+i+j);\r\nif (++cam->sof.bytesread == sizeof(marker)) {\r\nPDBGG("Bytes to analyze: %zd. SOF "\r\n"starts at byte #%zd", len, i);\r\ni += j+1;\r\nbreak;\r\n}\r\n} else {\r\ncam->sof.bytesread = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void*\r\nsn9c102_find_eof_header(struct sn9c102_device* cam, void* mem, size_t len)\r\n{\r\nstatic const u8 eof_header[4][4] = {\r\n{0x00, 0x00, 0x00, 0x00},\r\n{0x40, 0x00, 0x00, 0x00},\r\n{0x80, 0x00, 0x00, 0x00},\r\n{0xc0, 0x00, 0x00, 0x00},\r\n};\r\nsize_t i, j;\r\nif (cam->sensor.pix_format.pixelformat == V4L2_PIX_FMT_SN9C10X ||\r\ncam->sensor.pix_format.pixelformat == V4L2_PIX_FMT_JPEG)\r\nreturn NULL;\r\nfor (i = 0; (len >= 4) && (i <= len - 4); i++)\r\nfor (j = 0; j < ARRAY_SIZE(eof_header); j++)\r\nif (!memcmp(mem + i, eof_header[j], 4))\r\nreturn mem + i;\r\nreturn NULL;\r\n}\r\nstatic void\r\nsn9c102_write_jpegheader(struct sn9c102_device* cam, struct sn9c102_frame_t* f)\r\n{\r\nstatic const u8 jpeg_header[589] = {\r\n0xff, 0xd8, 0xff, 0xdb, 0x00, 0x84, 0x00, 0x06, 0x04, 0x05,\r\n0x06, 0x05, 0x04, 0x06, 0x06, 0x05, 0x06, 0x07, 0x07, 0x06,\r\n0x08, 0x0a, 0x10, 0x0a, 0x0a, 0x09, 0x09, 0x0a, 0x14, 0x0e,\r\n0x0f, 0x0c, 0x10, 0x17, 0x14, 0x18, 0x18, 0x17, 0x14, 0x16,\r\n0x16, 0x1a, 0x1d, 0x25, 0x1f, 0x1a, 0x1b, 0x23, 0x1c, 0x16,\r\n0x16, 0x20, 0x2c, 0x20, 0x23, 0x26, 0x27, 0x29, 0x2a, 0x29,\r\n0x19, 0x1f, 0x2d, 0x30, 0x2d, 0x28, 0x30, 0x25, 0x28, 0x29,\r\n0x28, 0x01, 0x07, 0x07, 0x07, 0x0a, 0x08, 0x0a, 0x13, 0x0a,\r\n0x0a, 0x13, 0x28, 0x1a, 0x16, 0x1a, 0x28, 0x28, 0x28, 0x28,\r\n0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,\r\n0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,\r\n0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,\r\n0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,\r\n0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0xff, 0xc4, 0x01, 0xa2,\r\n0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02,\r\n0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x01,\r\n0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\r\n0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03,\r\n0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x10, 0x00,\r\n0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04,\r\n0x04, 0x00, 0x00, 0x01, 0x7d, 0x01, 0x02, 0x03, 0x00, 0x04,\r\n0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61,\r\n0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23,\r\n0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62,\r\n0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25,\r\n0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38,\r\n0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a,\r\n0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64,\r\n0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76,\r\n0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88,\r\n0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,\r\n0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa,\r\n0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2,\r\n0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3,\r\n0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3,\r\n0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3,\r\n0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0x11, 0x00, 0x02,\r\n0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04,\r\n0x00, 0x01, 0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04,\r\n0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,\r\n0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1,\r\n0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1,\r\n0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19,\r\n0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38,\r\n0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a,\r\n0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64,\r\n0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76,\r\n0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\r\n0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,\r\n0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9,\r\n0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba,\r\n0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,\r\n0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3,\r\n0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4,\r\n0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xff, 0xc0, 0x00, 0x11,\r\n0x08, 0x01, 0xe0, 0x02, 0x80, 0x03, 0x01, 0x21, 0x00, 0x02,\r\n0x11, 0x01, 0x03, 0x11, 0x01, 0xff, 0xda, 0x00, 0x0c, 0x03,\r\n0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3f, 0x00\r\n};\r\nu8 *pos = f->bufmem;\r\nmemcpy(pos, jpeg_header, sizeof(jpeg_header));\r\n*(pos + 6) = 0x00;\r\n*(pos + 7 + 64) = 0x01;\r\nif (cam->compression.quality == 0) {\r\nmemcpy(pos + 7, SN9C102_Y_QTABLE0, 64);\r\nmemcpy(pos + 8 + 64, SN9C102_UV_QTABLE0, 64);\r\n} else if (cam->compression.quality == 1) {\r\nmemcpy(pos + 7, SN9C102_Y_QTABLE1, 64);\r\nmemcpy(pos + 8 + 64, SN9C102_UV_QTABLE1, 64);\r\n}\r\n*(pos + 564) = cam->sensor.pix_format.width & 0xFF;\r\n*(pos + 563) = (cam->sensor.pix_format.width >> 8) & 0xFF;\r\n*(pos + 562) = cam->sensor.pix_format.height & 0xFF;\r\n*(pos + 561) = (cam->sensor.pix_format.height >> 8) & 0xFF;\r\n*(pos + 567) = 0x21;\r\nf->buf.bytesused += sizeof(jpeg_header);\r\n}\r\nstatic void sn9c102_urb_complete(struct urb *urb)\r\n{\r\nstruct sn9c102_device* cam = urb->context;\r\nstruct sn9c102_frame_t** f;\r\nsize_t imagesize, soflen;\r\nu8 i;\r\nint err = 0;\r\nif (urb->status == -ENOENT)\r\nreturn;\r\nf = &cam->frame_current;\r\nif (cam->stream == STREAM_INTERRUPT) {\r\ncam->stream = STREAM_OFF;\r\nif ((*f))\r\n(*f)->state = F_QUEUED;\r\ncam->sof.bytesread = 0;\r\nDBG(3, "Stream interrupted by application");\r\nwake_up(&cam->wait_stream);\r\n}\r\nif (cam->state & DEV_DISCONNECTED)\r\nreturn;\r\nif (cam->state & DEV_MISCONFIGURED) {\r\nwake_up_interruptible(&cam->wait_frame);\r\nreturn;\r\n}\r\nif (cam->stream == STREAM_OFF || list_empty(&cam->inqueue))\r\ngoto resubmit_urb;\r\nif (!(*f))\r\n(*f) = list_entry(cam->inqueue.next, struct sn9c102_frame_t,\r\nframe);\r\nimagesize = (cam->sensor.pix_format.width *\r\ncam->sensor.pix_format.height *\r\ncam->sensor.pix_format.priv) / 8;\r\nif (cam->sensor.pix_format.pixelformat == V4L2_PIX_FMT_JPEG)\r\nimagesize += 589;\r\nsoflen = sn9c102_sof_length(cam);\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nunsigned int img, len, status;\r\nvoid *pos, *sof, *eof;\r\nlen = urb->iso_frame_desc[i].actual_length;\r\nstatus = urb->iso_frame_desc[i].status;\r\npos = urb->iso_frame_desc[i].offset + urb->transfer_buffer;\r\nif (status) {\r\nDBG(3, "Error in isochronous frame");\r\n(*f)->state = F_ERROR;\r\ncam->sof.bytesread = 0;\r\ncontinue;\r\n}\r\nPDBGG("Isochrnous frame: length %u, #%u i", len, i);\r\nredo:\r\nsof = sn9c102_find_sof_header(cam, pos, len);\r\nif (likely(!sof)) {\r\neof = sn9c102_find_eof_header(cam, pos, len);\r\nif ((*f)->state == F_GRABBING) {\r\nend_of_frame:\r\nimg = len;\r\nif (eof)\r\nimg = (eof > pos) ? eof - pos - 1 : 0;\r\nif ((*f)->buf.bytesused + img > imagesize) {\r\nu32 b;\r\nb = (*f)->buf.bytesused + img -\r\nimagesize;\r\nimg = imagesize - (*f)->buf.bytesused;\r\nPDBGG("Expected EOF not found: video "\r\n"frame cut");\r\nif (eof)\r\nDBG(3, "Exceeded limit: +%u "\r\n"bytes", (unsigned)(b));\r\n}\r\nmemcpy((*f)->bufmem + (*f)->buf.bytesused, pos,\r\nimg);\r\nif ((*f)->buf.bytesused == 0)\r\nv4l2_get_timestamp(\r\n&(*f)->buf.timestamp);\r\n(*f)->buf.bytesused += img;\r\nif ((*f)->buf.bytesused == imagesize ||\r\n((cam->sensor.pix_format.pixelformat ==\r\nV4L2_PIX_FMT_SN9C10X ||\r\ncam->sensor.pix_format.pixelformat ==\r\nV4L2_PIX_FMT_JPEG) && eof)) {\r\nu32 b;\r\nb = (*f)->buf.bytesused;\r\n(*f)->state = F_DONE;\r\n(*f)->buf.sequence= ++cam->frame_count;\r\nspin_lock(&cam->queue_lock);\r\nlist_move_tail(&(*f)->frame,\r\n&cam->outqueue);\r\nif (!list_empty(&cam->inqueue))\r\n(*f) = list_entry(\r\ncam->inqueue.next,\r\nstruct sn9c102_frame_t,\r\nframe );\r\nelse\r\n(*f) = NULL;\r\nspin_unlock(&cam->queue_lock);\r\nmemcpy(cam->sysfs.frame_header,\r\ncam->sof.header, soflen);\r\nDBG(3, "Video frame captured: %lu "\r\n"bytes", (unsigned long)(b));\r\nif (!(*f))\r\ngoto resubmit_urb;\r\n} else if (eof) {\r\n(*f)->state = F_ERROR;\r\nDBG(3, "Not expected EOF after %lu "\r\n"bytes of image data",\r\n(unsigned long)\r\n((*f)->buf.bytesused));\r\n}\r\nif (sof)\r\ngoto start_of_frame;\r\n} else if (eof) {\r\nDBG(3, "EOF without SOF");\r\ncontinue;\r\n} else {\r\nPDBGG("Ignoring pointless isochronous frame");\r\ncontinue;\r\n}\r\n} else if ((*f)->state == F_QUEUED || (*f)->state == F_ERROR) {\r\nstart_of_frame:\r\n(*f)->state = F_GRABBING;\r\n(*f)->buf.bytesused = 0;\r\nlen -= (sof - pos);\r\npos = sof;\r\nif (cam->sensor.pix_format.pixelformat ==\r\nV4L2_PIX_FMT_JPEG)\r\nsn9c102_write_jpegheader(cam, (*f));\r\nDBG(3, "SOF detected: new video frame");\r\nif (len)\r\ngoto redo;\r\n} else if ((*f)->state == F_GRABBING) {\r\neof = sn9c102_find_eof_header(cam, pos, len);\r\nif (eof && eof < sof)\r\ngoto end_of_frame;\r\nelse {\r\nif (cam->sensor.pix_format.pixelformat ==\r\nV4L2_PIX_FMT_SN9C10X ||\r\ncam->sensor.pix_format.pixelformat ==\r\nV4L2_PIX_FMT_JPEG) {\r\nif (sof - pos >= soflen) {\r\neof = sof - soflen;\r\n} else {\r\neof = pos;\r\n(*f)->buf.bytesused -=\r\n(soflen - (sof - pos));\r\n}\r\ngoto end_of_frame;\r\n} else {\r\nDBG(3, "SOF before expected EOF after "\r\n"%lu bytes of image data",\r\n(unsigned long)\r\n((*f)->buf.bytesused));\r\ngoto start_of_frame;\r\n}\r\n}\r\n}\r\n}\r\nresubmit_urb:\r\nurb->dev = cam->usbdev;\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err < 0 && err != -EPERM) {\r\ncam->state |= DEV_MISCONFIGURED;\r\nDBG(1, "usb_submit_urb() failed");\r\n}\r\nwake_up_interruptible(&cam->wait_frame);\r\n}\r\nstatic int sn9c102_start_transfer(struct sn9c102_device* cam)\r\n{\r\nstruct usb_device *udev = cam->usbdev;\r\nstruct urb* urb;\r\nstruct usb_host_interface* altsetting = usb_altnum_to_altsetting(\r\nusb_ifnum_to_if(udev, 0),\r\nSN9C102_ALTERNATE_SETTING);\r\nconst unsigned int psz = le16_to_cpu(altsetting->\r\nendpoint[0].desc.wMaxPacketSize);\r\ns8 i, j;\r\nint err = 0;\r\nfor (i = 0; i < SN9C102_URBS; i++) {\r\ncam->transfer_buffer[i] = kzalloc(SN9C102_ISO_PACKETS * psz,\r\nGFP_KERNEL);\r\nif (!cam->transfer_buffer[i]) {\r\nerr = -ENOMEM;\r\nDBG(1, "Not enough memory");\r\ngoto free_buffers;\r\n}\r\n}\r\nfor (i = 0; i < SN9C102_URBS; i++) {\r\nurb = usb_alloc_urb(SN9C102_ISO_PACKETS, GFP_KERNEL);\r\ncam->urb[i] = urb;\r\nif (!urb) {\r\nerr = -ENOMEM;\r\nDBG(1, "usb_alloc_urb() failed");\r\ngoto free_urbs;\r\n}\r\nurb->dev = udev;\r\nurb->context = cam;\r\nurb->pipe = usb_rcvisocpipe(udev, 1);\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->number_of_packets = SN9C102_ISO_PACKETS;\r\nurb->complete = sn9c102_urb_complete;\r\nurb->transfer_buffer = cam->transfer_buffer[i];\r\nurb->transfer_buffer_length = psz * SN9C102_ISO_PACKETS;\r\nurb->interval = 1;\r\nfor (j = 0; j < SN9C102_ISO_PACKETS; j++) {\r\nurb->iso_frame_desc[j].offset = psz * j;\r\nurb->iso_frame_desc[j].length = psz;\r\n}\r\n}\r\nif (!(cam->reg[0x01] & 0x04)) {\r\nerr = sn9c102_write_reg(cam, cam->reg[0x01] | 0x04, 0x01);\r\nif (err) {\r\nerr = -EIO;\r\nDBG(1, "I/O hardware error");\r\ngoto free_urbs;\r\n}\r\n}\r\nerr = usb_set_interface(udev, 0, SN9C102_ALTERNATE_SETTING);\r\nif (err) {\r\nDBG(1, "usb_set_interface() failed");\r\ngoto free_urbs;\r\n}\r\ncam->frame_current = NULL;\r\ncam->sof.bytesread = 0;\r\nfor (i = 0; i < SN9C102_URBS; i++) {\r\nerr = usb_submit_urb(cam->urb[i], GFP_KERNEL);\r\nif (err) {\r\nfor (j = i-1; j >= 0; j--)\r\nusb_kill_urb(cam->urb[j]);\r\nDBG(1, "usb_submit_urb() failed, error %d", err);\r\ngoto free_urbs;\r\n}\r\n}\r\nreturn 0;\r\nfree_urbs:\r\nfor (i = 0; (i < SN9C102_URBS) && cam->urb[i]; i++)\r\nusb_free_urb(cam->urb[i]);\r\nfree_buffers:\r\nfor (i = 0; (i < SN9C102_URBS) && cam->transfer_buffer[i]; i++)\r\nkfree(cam->transfer_buffer[i]);\r\nreturn err;\r\n}\r\nstatic int sn9c102_stop_transfer(struct sn9c102_device* cam)\r\n{\r\nstruct usb_device *udev = cam->usbdev;\r\ns8 i;\r\nint err = 0;\r\nif (cam->state & DEV_DISCONNECTED)\r\nreturn 0;\r\nfor (i = SN9C102_URBS-1; i >= 0; i--) {\r\nusb_kill_urb(cam->urb[i]);\r\nusb_free_urb(cam->urb[i]);\r\nkfree(cam->transfer_buffer[i]);\r\n}\r\nerr = usb_set_interface(udev, 0, 0);\r\nif (err)\r\nDBG(3, "usb_set_interface() failed");\r\nreturn err;\r\n}\r\nstatic int sn9c102_stream_interrupt(struct sn9c102_device* cam)\r\n{\r\ncam->stream = STREAM_INTERRUPT;\r\nwait_event_timeout(cam->wait_stream,\r\n(cam->stream == STREAM_OFF) ||\r\n(cam->state & DEV_DISCONNECTED),\r\nSN9C102_URB_TIMEOUT);\r\nif (cam->state & DEV_DISCONNECTED)\r\nreturn -ENODEV;\r\nelse if (cam->stream != STREAM_OFF) {\r\ncam->state |= DEV_MISCONFIGURED;\r\nDBG(1, "URB timeout reached. The camera is misconfigured. "\r\n"To use it, close and open %s again.",\r\nvideo_device_node_name(cam->v4ldev));\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 sn9c102_strtou16(const char* buff, size_t len, ssize_t* count)\r\n{\r\nchar str[7];\r\nchar* endp;\r\nunsigned long val;\r\nif (len < 6) {\r\nstrncpy(str, buff, len);\r\nstr[len] = '\0';\r\n} else {\r\nstrncpy(str, buff, 6);\r\nstr[6] = '\0';\r\n}\r\nval = simple_strtoul(str, &endp, 0);\r\n*count = 0;\r\nif (val <= 0xffff)\r\n*count = (ssize_t)(endp - str);\r\nif ((*count) && (len == *count+1) && (buff[*count] == '\n'))\r\n*count += 1;\r\nreturn (u16)val;\r\n}\r\nstatic ssize_t sn9c102_show_reg(struct device* cd,\r\nstruct device_attribute *attr, char* buf)\r\n{\r\nstruct sn9c102_device* cam;\r\nssize_t count;\r\nif (mutex_lock_interruptible(&sn9c102_sysfs_lock))\r\nreturn -ERESTARTSYS;\r\ncam = video_get_drvdata(container_of(cd, struct video_device, dev));\r\nif (!cam) {\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn -ENODEV;\r\n}\r\ncount = sprintf(buf, "%u\n", cam->sysfs.reg);\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nsn9c102_store_reg(struct device* cd, struct device_attribute *attr,\r\nconst char* buf, size_t len)\r\n{\r\nstruct sn9c102_device* cam;\r\nu16 index;\r\nssize_t count;\r\nif (mutex_lock_interruptible(&sn9c102_sysfs_lock))\r\nreturn -ERESTARTSYS;\r\ncam = video_get_drvdata(container_of(cd, struct video_device, dev));\r\nif (!cam) {\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn -ENODEV;\r\n}\r\nindex = sn9c102_strtou16(buf, len, &count);\r\nif (index >= ARRAY_SIZE(cam->reg) || !count) {\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn -EINVAL;\r\n}\r\ncam->sysfs.reg = index;\r\nDBG(2, "Moved SN9C1XX register index to 0x%02X", cam->sysfs.reg);\r\nDBG(3, "Written bytes: %zd", count);\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t sn9c102_show_val(struct device* cd,\r\nstruct device_attribute *attr, char* buf)\r\n{\r\nstruct sn9c102_device* cam;\r\nssize_t count;\r\nint val;\r\nif (mutex_lock_interruptible(&sn9c102_sysfs_lock))\r\nreturn -ERESTARTSYS;\r\ncam = video_get_drvdata(container_of(cd, struct video_device, dev));\r\nif (!cam) {\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn -ENODEV;\r\n}\r\nif ((val = sn9c102_read_reg(cam, cam->sysfs.reg)) < 0) {\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn -EIO;\r\n}\r\ncount = sprintf(buf, "%d\n", val);\r\nDBG(3, "Read bytes: %zd, value: %d", count, val);\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nsn9c102_store_val(struct device* cd, struct device_attribute *attr,\r\nconst char* buf, size_t len)\r\n{\r\nstruct sn9c102_device* cam;\r\nu16 value;\r\nssize_t count;\r\nint err;\r\nif (mutex_lock_interruptible(&sn9c102_sysfs_lock))\r\nreturn -ERESTARTSYS;\r\ncam = video_get_drvdata(container_of(cd, struct video_device, dev));\r\nif (!cam) {\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn -ENODEV;\r\n}\r\nvalue = sn9c102_strtou16(buf, len, &count);\r\nif (!count) {\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn -EINVAL;\r\n}\r\nerr = sn9c102_write_reg(cam, value, cam->sysfs.reg);\r\nif (err) {\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn -EIO;\r\n}\r\nDBG(2, "Written SN9C1XX reg. 0x%02X, val. 0x%02X",\r\ncam->sysfs.reg, value);\r\nDBG(3, "Written bytes: %zd", count);\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t sn9c102_show_i2c_reg(struct device* cd,\r\nstruct device_attribute *attr, char* buf)\r\n{\r\nstruct sn9c102_device* cam;\r\nssize_t count;\r\nif (mutex_lock_interruptible(&sn9c102_sysfs_lock))\r\nreturn -ERESTARTSYS;\r\ncam = video_get_drvdata(container_of(cd, struct video_device, dev));\r\nif (!cam) {\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn -ENODEV;\r\n}\r\ncount = sprintf(buf, "%u\n", cam->sysfs.i2c_reg);\r\nDBG(3, "Read bytes: %zd", count);\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nsn9c102_store_i2c_reg(struct device* cd, struct device_attribute *attr,\r\nconst char* buf, size_t len)\r\n{\r\nstruct sn9c102_device* cam;\r\nu16 index;\r\nssize_t count;\r\nif (mutex_lock_interruptible(&sn9c102_sysfs_lock))\r\nreturn -ERESTARTSYS;\r\ncam = video_get_drvdata(container_of(cd, struct video_device, dev));\r\nif (!cam) {\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn -ENODEV;\r\n}\r\nindex = sn9c102_strtou16(buf, len, &count);\r\nif (!count) {\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn -EINVAL;\r\n}\r\ncam->sysfs.i2c_reg = index;\r\nDBG(2, "Moved sensor register index to 0x%02X", cam->sysfs.i2c_reg);\r\nDBG(3, "Written bytes: %zd", count);\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t sn9c102_show_i2c_val(struct device* cd,\r\nstruct device_attribute *attr, char* buf)\r\n{\r\nstruct sn9c102_device* cam;\r\nssize_t count;\r\nint val;\r\nif (mutex_lock_interruptible(&sn9c102_sysfs_lock))\r\nreturn -ERESTARTSYS;\r\ncam = video_get_drvdata(container_of(cd, struct video_device, dev));\r\nif (!cam) {\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn -ENODEV;\r\n}\r\nif (!(cam->sensor.sysfs_ops & SN9C102_I2C_READ)) {\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn -ENOSYS;\r\n}\r\nif ((val = sn9c102_i2c_read(cam, cam->sysfs.i2c_reg)) < 0) {\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn -EIO;\r\n}\r\ncount = sprintf(buf, "%d\n", val);\r\nDBG(3, "Read bytes: %zd, value: %d", count, val);\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nsn9c102_store_i2c_val(struct device* cd, struct device_attribute *attr,\r\nconst char* buf, size_t len)\r\n{\r\nstruct sn9c102_device* cam;\r\nu16 value;\r\nssize_t count;\r\nint err;\r\nif (mutex_lock_interruptible(&sn9c102_sysfs_lock))\r\nreturn -ERESTARTSYS;\r\ncam = video_get_drvdata(container_of(cd, struct video_device, dev));\r\nif (!cam) {\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn -ENODEV;\r\n}\r\nif (!(cam->sensor.sysfs_ops & SN9C102_I2C_WRITE)) {\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn -ENOSYS;\r\n}\r\nvalue = sn9c102_strtou16(buf, len, &count);\r\nif (!count) {\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn -EINVAL;\r\n}\r\nerr = sn9c102_i2c_write(cam, cam->sysfs.i2c_reg, value);\r\nif (err) {\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn -EIO;\r\n}\r\nDBG(2, "Written sensor reg. 0x%02X, val. 0x%02X",\r\ncam->sysfs.i2c_reg, value);\r\nDBG(3, "Written bytes: %zd", count);\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nsn9c102_store_green(struct device* cd, struct device_attribute *attr,\r\nconst char* buf, size_t len)\r\n{\r\nstruct sn9c102_device* cam;\r\nenum sn9c102_bridge bridge;\r\nssize_t res = 0;\r\nu16 value;\r\nssize_t count;\r\nif (mutex_lock_interruptible(&sn9c102_sysfs_lock))\r\nreturn -ERESTARTSYS;\r\ncam = video_get_drvdata(container_of(cd, struct video_device, dev));\r\nif (!cam) {\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nreturn -ENODEV;\r\n}\r\nbridge = cam->bridge;\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\nvalue = sn9c102_strtou16(buf, len, &count);\r\nif (!count)\r\nreturn -EINVAL;\r\nswitch (bridge) {\r\ncase BRIDGE_SN9C101:\r\ncase BRIDGE_SN9C102:\r\nif (value > 0x0f)\r\nreturn -EINVAL;\r\nif ((res = sn9c102_store_reg(cd, attr, "0x11", 4)) >= 0)\r\nres = sn9c102_store_val(cd, attr, buf, len);\r\nbreak;\r\ncase BRIDGE_SN9C103:\r\ncase BRIDGE_SN9C105:\r\ncase BRIDGE_SN9C120:\r\nif (value > 0x7f)\r\nreturn -EINVAL;\r\nif ((res = sn9c102_store_reg(cd, attr, "0x07", 4)) >= 0)\r\nres = sn9c102_store_val(cd, attr, buf, len);\r\nbreak;\r\n}\r\nreturn res;\r\n}\r\nstatic ssize_t\r\nsn9c102_store_blue(struct device* cd, struct device_attribute *attr,\r\nconst char* buf, size_t len)\r\n{\r\nssize_t res = 0;\r\nu16 value;\r\nssize_t count;\r\nvalue = sn9c102_strtou16(buf, len, &count);\r\nif (!count || value > 0x7f)\r\nreturn -EINVAL;\r\nif ((res = sn9c102_store_reg(cd, attr, "0x06", 4)) >= 0)\r\nres = sn9c102_store_val(cd, attr, buf, len);\r\nreturn res;\r\n}\r\nstatic ssize_t\r\nsn9c102_store_red(struct device* cd, struct device_attribute *attr,\r\nconst char* buf, size_t len)\r\n{\r\nssize_t res = 0;\r\nu16 value;\r\nssize_t count;\r\nvalue = sn9c102_strtou16(buf, len, &count);\r\nif (!count || value > 0x7f)\r\nreturn -EINVAL;\r\nif ((res = sn9c102_store_reg(cd, attr, "0x05", 4)) >= 0)\r\nres = sn9c102_store_val(cd, attr, buf, len);\r\nreturn res;\r\n}\r\nstatic ssize_t sn9c102_show_frame_header(struct device* cd,\r\nstruct device_attribute *attr,\r\nchar* buf)\r\n{\r\nstruct sn9c102_device* cam;\r\nssize_t count;\r\ncam = video_get_drvdata(container_of(cd, struct video_device, dev));\r\nif (!cam)\r\nreturn -ENODEV;\r\ncount = sizeof(cam->sysfs.frame_header);\r\nmemcpy(buf, cam->sysfs.frame_header, count);\r\nDBG(3, "Frame header, read bytes: %zd", count);\r\nreturn count;\r\n}\r\nstatic int sn9c102_create_sysfs(struct sn9c102_device* cam)\r\n{\r\nstruct device *dev = &(cam->v4ldev->dev);\r\nint err = 0;\r\nif ((err = device_create_file(dev, &dev_attr_reg)))\r\ngoto err_out;\r\nif ((err = device_create_file(dev, &dev_attr_val)))\r\ngoto err_reg;\r\nif ((err = device_create_file(dev, &dev_attr_frame_header)))\r\ngoto err_val;\r\nif (cam->sensor.sysfs_ops) {\r\nif ((err = device_create_file(dev, &dev_attr_i2c_reg)))\r\ngoto err_frame_header;\r\nif ((err = device_create_file(dev, &dev_attr_i2c_val)))\r\ngoto err_i2c_reg;\r\n}\r\nif (cam->bridge == BRIDGE_SN9C101 || cam->bridge == BRIDGE_SN9C102) {\r\nif ((err = device_create_file(dev, &dev_attr_green)))\r\ngoto err_i2c_val;\r\n} else {\r\nif ((err = device_create_file(dev, &dev_attr_blue)))\r\ngoto err_i2c_val;\r\nif ((err = device_create_file(dev, &dev_attr_red)))\r\ngoto err_blue;\r\n}\r\nreturn 0;\r\nerr_blue:\r\ndevice_remove_file(dev, &dev_attr_blue);\r\nerr_i2c_val:\r\nif (cam->sensor.sysfs_ops)\r\ndevice_remove_file(dev, &dev_attr_i2c_val);\r\nerr_i2c_reg:\r\nif (cam->sensor.sysfs_ops)\r\ndevice_remove_file(dev, &dev_attr_i2c_reg);\r\nerr_frame_header:\r\ndevice_remove_file(dev, &dev_attr_frame_header);\r\nerr_val:\r\ndevice_remove_file(dev, &dev_attr_val);\r\nerr_reg:\r\ndevice_remove_file(dev, &dev_attr_reg);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic int\r\nsn9c102_set_pix_format(struct sn9c102_device* cam, struct v4l2_pix_format* pix)\r\n{\r\nint err = 0;\r\nif (pix->pixelformat == V4L2_PIX_FMT_SN9C10X ||\r\npix->pixelformat == V4L2_PIX_FMT_JPEG) {\r\nswitch (cam->bridge) {\r\ncase BRIDGE_SN9C101:\r\ncase BRIDGE_SN9C102:\r\ncase BRIDGE_SN9C103:\r\nerr += sn9c102_write_reg(cam, cam->reg[0x18] | 0x80,\r\n0x18);\r\nbreak;\r\ncase BRIDGE_SN9C105:\r\ncase BRIDGE_SN9C120:\r\nerr += sn9c102_write_reg(cam, cam->reg[0x18] & 0x7f,\r\n0x18);\r\nbreak;\r\n}\r\n} else {\r\nswitch (cam->bridge) {\r\ncase BRIDGE_SN9C101:\r\ncase BRIDGE_SN9C102:\r\ncase BRIDGE_SN9C103:\r\nerr += sn9c102_write_reg(cam, cam->reg[0x18] & 0x7f,\r\n0x18);\r\nbreak;\r\ncase BRIDGE_SN9C105:\r\ncase BRIDGE_SN9C120:\r\nerr += sn9c102_write_reg(cam, cam->reg[0x18] | 0x80,\r\n0x18);\r\nbreak;\r\n}\r\n}\r\nreturn err ? -EIO : 0;\r\n}\r\nstatic int\r\nsn9c102_set_compression(struct sn9c102_device* cam,\r\nstruct v4l2_jpegcompression* compression)\r\n{\r\nint i, err = 0;\r\nswitch (cam->bridge) {\r\ncase BRIDGE_SN9C101:\r\ncase BRIDGE_SN9C102:\r\ncase BRIDGE_SN9C103:\r\nif (compression->quality == 0)\r\nerr += sn9c102_write_reg(cam, cam->reg[0x17] | 0x01,\r\n0x17);\r\nelse if (compression->quality == 1)\r\nerr += sn9c102_write_reg(cam, cam->reg[0x17] & 0xfe,\r\n0x17);\r\nbreak;\r\ncase BRIDGE_SN9C105:\r\ncase BRIDGE_SN9C120:\r\nif (compression->quality == 0) {\r\nfor (i = 0; i <= 63; i++) {\r\nerr += sn9c102_write_reg(cam,\r\nSN9C102_Y_QTABLE1[i],\r\n0x100 + i);\r\nerr += sn9c102_write_reg(cam,\r\nSN9C102_UV_QTABLE1[i],\r\n0x140 + i);\r\n}\r\nerr += sn9c102_write_reg(cam, cam->reg[0x18] & 0xbf,\r\n0x18);\r\n} else if (compression->quality == 1) {\r\nfor (i = 0; i <= 63; i++) {\r\nerr += sn9c102_write_reg(cam,\r\nSN9C102_Y_QTABLE1[i],\r\n0x100 + i);\r\nerr += sn9c102_write_reg(cam,\r\nSN9C102_UV_QTABLE1[i],\r\n0x140 + i);\r\n}\r\nerr += sn9c102_write_reg(cam, cam->reg[0x18] | 0x40,\r\n0x18);\r\n}\r\nbreak;\r\n}\r\nreturn err ? -EIO : 0;\r\n}\r\nstatic int sn9c102_set_scale(struct sn9c102_device* cam, u8 scale)\r\n{\r\nu8 r = 0;\r\nint err = 0;\r\nif (scale == 1)\r\nr = cam->reg[0x18] & 0xcf;\r\nelse if (scale == 2) {\r\nr = cam->reg[0x18] & 0xcf;\r\nr |= 0x10;\r\n} else if (scale == 4)\r\nr = cam->reg[0x18] | 0x20;\r\nerr += sn9c102_write_reg(cam, r, 0x18);\r\nif (err)\r\nreturn -EIO;\r\nPDBGG("Scaling factor: %u", scale);\r\nreturn 0;\r\n}\r\nstatic int sn9c102_set_crop(struct sn9c102_device* cam, struct v4l2_rect* rect)\r\n{\r\nstruct sn9c102_sensor* s = &cam->sensor;\r\nu8 h_start = (u8)(rect->left - s->cropcap.bounds.left),\r\nv_start = (u8)(rect->top - s->cropcap.bounds.top),\r\nh_size = (u8)(rect->width / 16),\r\nv_size = (u8)(rect->height / 16);\r\nint err = 0;\r\nerr += sn9c102_write_reg(cam, h_start, 0x12);\r\nerr += sn9c102_write_reg(cam, v_start, 0x13);\r\nerr += sn9c102_write_reg(cam, h_size, 0x15);\r\nerr += sn9c102_write_reg(cam, v_size, 0x16);\r\nif (err)\r\nreturn -EIO;\r\nPDBGG("h_start, v_start, h_size, v_size, ho_size, vo_size "\r\n"%u %u %u %u", h_start, v_start, h_size, v_size);\r\nreturn 0;\r\n}\r\nstatic int sn9c102_init(struct sn9c102_device* cam)\r\n{\r\nstruct sn9c102_sensor* s = &cam->sensor;\r\nstruct v4l2_control ctrl;\r\nstruct v4l2_queryctrl *qctrl;\r\nstruct v4l2_rect* rect;\r\nu8 i = 0;\r\nint err = 0;\r\nif (!(cam->state & DEV_INITIALIZED)) {\r\nmutex_init(&cam->open_mutex);\r\ninit_waitqueue_head(&cam->wait_open);\r\nqctrl = s->qctrl;\r\nrect = &(s->cropcap.defrect);\r\n} else {\r\nqctrl = s->_qctrl;\r\nrect = &(s->_rect);\r\n}\r\nerr += sn9c102_set_scale(cam, rect->width / s->pix_format.width);\r\nerr += sn9c102_set_crop(cam, rect);\r\nif (err)\r\nreturn err;\r\nif (s->init) {\r\nerr = s->init(cam);\r\nif (err) {\r\nDBG(3, "Sensor initialization failed");\r\nreturn err;\r\n}\r\n}\r\nif (!(cam->state & DEV_INITIALIZED))\r\nif (cam->bridge == BRIDGE_SN9C101 ||\r\ncam->bridge == BRIDGE_SN9C102 ||\r\ncam->bridge == BRIDGE_SN9C103) {\r\nif (s->pix_format.pixelformat == V4L2_PIX_FMT_JPEG)\r\ns->pix_format.pixelformat= V4L2_PIX_FMT_SBGGR8;\r\ncam->compression.quality = cam->reg[0x17] & 0x01 ?\r\n0 : 1;\r\n} else {\r\nif (s->pix_format.pixelformat == V4L2_PIX_FMT_SN9C10X)\r\ns->pix_format.pixelformat = V4L2_PIX_FMT_JPEG;\r\ncam->compression.quality = cam->reg[0x18] & 0x40 ?\r\n0 : 1;\r\nerr += sn9c102_set_compression(cam, &cam->compression);\r\n}\r\nelse\r\nerr += sn9c102_set_compression(cam, &cam->compression);\r\nerr += sn9c102_set_pix_format(cam, &s->pix_format);\r\nif (s->set_pix_format)\r\nerr += s->set_pix_format(cam, &s->pix_format);\r\nif (err)\r\nreturn err;\r\nif (s->pix_format.pixelformat == V4L2_PIX_FMT_SN9C10X ||\r\ns->pix_format.pixelformat == V4L2_PIX_FMT_JPEG)\r\nDBG(3, "Compressed video format is active, quality %d",\r\ncam->compression.quality);\r\nelse\r\nDBG(3, "Uncompressed video format is active");\r\nif (s->set_crop)\r\nif ((err = s->set_crop(cam, rect))) {\r\nDBG(3, "set_crop() failed");\r\nreturn err;\r\n}\r\nif (s->set_ctrl) {\r\nfor (i = 0; i < ARRAY_SIZE(s->qctrl); i++)\r\nif (s->qctrl[i].id != 0 &&\r\n!(s->qctrl[i].flags & V4L2_CTRL_FLAG_DISABLED)) {\r\nctrl.id = s->qctrl[i].id;\r\nctrl.value = qctrl[i].default_value;\r\nerr = s->set_ctrl(cam, &ctrl);\r\nif (err) {\r\nDBG(3, "Set %s control failed",\r\ns->qctrl[i].name);\r\nreturn err;\r\n}\r\nDBG(3, "Image sensor supports '%s' control",\r\ns->qctrl[i].name);\r\n}\r\n}\r\nif (!(cam->state & DEV_INITIALIZED)) {\r\nmutex_init(&cam->fileop_mutex);\r\nspin_lock_init(&cam->queue_lock);\r\ninit_waitqueue_head(&cam->wait_frame);\r\ninit_waitqueue_head(&cam->wait_stream);\r\ncam->nreadbuffers = 2;\r\nmemcpy(s->_qctrl, s->qctrl, sizeof(s->qctrl));\r\nmemcpy(&(s->_rect), &(s->cropcap.defrect),\r\nsizeof(struct v4l2_rect));\r\ncam->state |= DEV_INITIALIZED;\r\n}\r\nDBG(2, "Initialization succeeded");\r\nreturn 0;\r\n}\r\nstatic void sn9c102_release_resources(struct kref *kref)\r\n{\r\nstruct sn9c102_device *cam;\r\nmutex_lock(&sn9c102_sysfs_lock);\r\ncam = container_of(kref, struct sn9c102_device, kref);\r\nDBG(2, "V4L2 device %s deregistered",\r\nvideo_device_node_name(cam->v4ldev));\r\nvideo_set_drvdata(cam->v4ldev, NULL);\r\nvideo_unregister_device(cam->v4ldev);\r\nv4l2_device_unregister(&cam->v4l2_dev);\r\nusb_put_dev(cam->usbdev);\r\nkfree(cam->control_buffer);\r\nkfree(cam);\r\nmutex_unlock(&sn9c102_sysfs_lock);\r\n}\r\nstatic int sn9c102_open(struct file *filp)\r\n{\r\nstruct sn9c102_device* cam;\r\nint err = 0;\r\nif (!down_read_trylock(&sn9c102_dev_lock))\r\nreturn -ERESTARTSYS;\r\ncam = video_drvdata(filp);\r\nif (wait_for_completion_interruptible(&cam->probe)) {\r\nup_read(&sn9c102_dev_lock);\r\nreturn -ERESTARTSYS;\r\n}\r\nkref_get(&cam->kref);\r\nif (mutex_lock_interruptible(&cam->open_mutex)) {\r\nkref_put(&cam->kref, sn9c102_release_resources);\r\nup_read(&sn9c102_dev_lock);\r\nreturn -ERESTARTSYS;\r\n}\r\nif (cam->state & DEV_DISCONNECTED) {\r\nDBG(1, "Device not present");\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nif (cam->users) {\r\nDBG(2, "Device %s is already in use",\r\nvideo_device_node_name(cam->v4ldev));\r\nDBG(3, "Simultaneous opens are not supported");\r\nif ((filp->f_flags & O_NONBLOCK) ||\r\n(filp->f_flags & O_NDELAY)) {\r\nerr = -EWOULDBLOCK;\r\ngoto out;\r\n}\r\nDBG(2, "A blocking open() has been requested. Wait for the "\r\n"device to be released...");\r\nup_read(&sn9c102_dev_lock);\r\nerr = wait_event_interruptible_exclusive(cam->wait_open,\r\n(cam->state & DEV_DISCONNECTED)\r\n|| !cam->users);\r\ndown_read(&sn9c102_dev_lock);\r\nif (err)\r\ngoto out;\r\nif (cam->state & DEV_DISCONNECTED) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\n}\r\nif (cam->state & DEV_MISCONFIGURED) {\r\nerr = sn9c102_init(cam);\r\nif (err) {\r\nDBG(1, "Initialization failed again. "\r\n"I will retry on next open().");\r\ngoto out;\r\n}\r\ncam->state &= ~DEV_MISCONFIGURED;\r\n}\r\nif ((err = sn9c102_start_transfer(cam)))\r\ngoto out;\r\nfilp->private_data = cam;\r\ncam->users++;\r\ncam->io = IO_NONE;\r\ncam->stream = STREAM_OFF;\r\ncam->nbuffers = 0;\r\ncam->frame_count = 0;\r\nsn9c102_empty_framequeues(cam);\r\nDBG(3, "Video device %s is open", video_device_node_name(cam->v4ldev));\r\nout:\r\nmutex_unlock(&cam->open_mutex);\r\nif (err)\r\nkref_put(&cam->kref, sn9c102_release_resources);\r\nup_read(&sn9c102_dev_lock);\r\nreturn err;\r\n}\r\nstatic int sn9c102_release(struct file *filp)\r\n{\r\nstruct sn9c102_device* cam;\r\ndown_write(&sn9c102_dev_lock);\r\ncam = video_drvdata(filp);\r\nsn9c102_stop_transfer(cam);\r\nsn9c102_release_buffers(cam);\r\ncam->users--;\r\nwake_up_interruptible_nr(&cam->wait_open, 1);\r\nDBG(3, "Video device %s closed", video_device_node_name(cam->v4ldev));\r\nkref_put(&cam->kref, sn9c102_release_resources);\r\nup_write(&sn9c102_dev_lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nsn9c102_read(struct file* filp, char __user * buf, size_t count, loff_t* f_pos)\r\n{\r\nstruct sn9c102_device *cam = video_drvdata(filp);\r\nstruct sn9c102_frame_t* f, * i;\r\nunsigned long lock_flags;\r\nlong timeout;\r\nint err = 0;\r\nif (mutex_lock_interruptible(&cam->fileop_mutex))\r\nreturn -ERESTARTSYS;\r\nif (cam->state & DEV_DISCONNECTED) {\r\nDBG(1, "Device not present");\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -ENODEV;\r\n}\r\nif (cam->state & DEV_MISCONFIGURED) {\r\nDBG(1, "The camera is misconfigured. Close and open it "\r\n"again.");\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EIO;\r\n}\r\nif (cam->io == IO_MMAP) {\r\nDBG(3, "Close and open the device again to choose "\r\n"the read method");\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EBUSY;\r\n}\r\nif (cam->io == IO_NONE) {\r\nif (!sn9c102_request_buffers(cam,cam->nreadbuffers, IO_READ)) {\r\nDBG(1, "read() failed, not enough memory");\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -ENOMEM;\r\n}\r\ncam->io = IO_READ;\r\ncam->stream = STREAM_ON;\r\n}\r\nif (list_empty(&cam->inqueue)) {\r\nif (!list_empty(&cam->outqueue))\r\nsn9c102_empty_framequeues(cam);\r\nsn9c102_queue_unusedframes(cam);\r\n}\r\nif (!count) {\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn 0;\r\n}\r\nif (list_empty(&cam->outqueue)) {\r\nif (filp->f_flags & O_NONBLOCK) {\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EAGAIN;\r\n}\r\nif (!cam->module_param.frame_timeout) {\r\nerr = wait_event_interruptible\r\n( cam->wait_frame,\r\n(!list_empty(&cam->outqueue)) ||\r\n(cam->state & DEV_DISCONNECTED) ||\r\n(cam->state & DEV_MISCONFIGURED) );\r\nif (err) {\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn err;\r\n}\r\n} else {\r\ntimeout = wait_event_interruptible_timeout\r\n( cam->wait_frame,\r\n(!list_empty(&cam->outqueue)) ||\r\n(cam->state & DEV_DISCONNECTED) ||\r\n(cam->state & DEV_MISCONFIGURED),\r\nmsecs_to_jiffies(\r\ncam->module_param.frame_timeout * 1000\r\n)\r\n);\r\nif (timeout < 0) {\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn timeout;\r\n} else if (timeout == 0 &&\r\n!(cam->state & DEV_DISCONNECTED)) {\r\nDBG(1, "Video frame timeout elapsed");\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EIO;\r\n}\r\n}\r\nif (cam->state & DEV_DISCONNECTED) {\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -ENODEV;\r\n}\r\nif (cam->state & DEV_MISCONFIGURED) {\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EIO;\r\n}\r\n}\r\nf = list_entry(cam->outqueue.prev, struct sn9c102_frame_t, frame);\r\nif (count > f->buf.bytesused)\r\ncount = f->buf.bytesused;\r\nif (copy_to_user(buf, f->bufmem, count)) {\r\nerr = -EFAULT;\r\ngoto exit;\r\n}\r\n*f_pos += count;\r\nexit:\r\nspin_lock_irqsave(&cam->queue_lock, lock_flags);\r\nlist_for_each_entry(i, &cam->outqueue, frame)\r\ni->state = F_UNUSED;\r\nINIT_LIST_HEAD(&cam->outqueue);\r\nspin_unlock_irqrestore(&cam->queue_lock, lock_flags);\r\nsn9c102_queue_unusedframes(cam);\r\nPDBGG("Frame #%lu, bytes read: %zu",\r\n(unsigned long)f->buf.index, count);\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn count;\r\n}\r\nstatic unsigned int sn9c102_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct sn9c102_device *cam = video_drvdata(filp);\r\nstruct sn9c102_frame_t* f;\r\nunsigned long lock_flags;\r\nunsigned int mask = 0;\r\nif (mutex_lock_interruptible(&cam->fileop_mutex))\r\nreturn POLLERR;\r\nif (cam->state & DEV_DISCONNECTED) {\r\nDBG(1, "Device not present");\r\ngoto error;\r\n}\r\nif (cam->state & DEV_MISCONFIGURED) {\r\nDBG(1, "The camera is misconfigured. Close and open it "\r\n"again.");\r\ngoto error;\r\n}\r\nif (cam->io == IO_NONE) {\r\nif (!sn9c102_request_buffers(cam, cam->nreadbuffers,\r\nIO_READ)) {\r\nDBG(1, "poll() failed, not enough memory");\r\ngoto error;\r\n}\r\ncam->io = IO_READ;\r\ncam->stream = STREAM_ON;\r\n}\r\nif (cam->io == IO_READ) {\r\nspin_lock_irqsave(&cam->queue_lock, lock_flags);\r\nlist_for_each_entry(f, &cam->outqueue, frame)\r\nf->state = F_UNUSED;\r\nINIT_LIST_HEAD(&cam->outqueue);\r\nspin_unlock_irqrestore(&cam->queue_lock, lock_flags);\r\nsn9c102_queue_unusedframes(cam);\r\n}\r\npoll_wait(filp, &cam->wait_frame, wait);\r\nif (!list_empty(&cam->outqueue))\r\nmask |= POLLIN | POLLRDNORM;\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn mask;\r\nerror:\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn POLLERR;\r\n}\r\nstatic void sn9c102_vm_open(struct vm_area_struct* vma)\r\n{\r\nstruct sn9c102_frame_t* f = vma->vm_private_data;\r\nf->vma_use_count++;\r\n}\r\nstatic void sn9c102_vm_close(struct vm_area_struct* vma)\r\n{\r\nstruct sn9c102_frame_t* f = vma->vm_private_data;\r\nf->vma_use_count--;\r\n}\r\nstatic int sn9c102_mmap(struct file* filp, struct vm_area_struct *vma)\r\n{\r\nstruct sn9c102_device *cam = video_drvdata(filp);\r\nunsigned long size = vma->vm_end - vma->vm_start,\r\nstart = vma->vm_start;\r\nvoid *pos;\r\nu32 i;\r\nif (mutex_lock_interruptible(&cam->fileop_mutex))\r\nreturn -ERESTARTSYS;\r\nif (cam->state & DEV_DISCONNECTED) {\r\nDBG(1, "Device not present");\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -ENODEV;\r\n}\r\nif (cam->state & DEV_MISCONFIGURED) {\r\nDBG(1, "The camera is misconfigured. Close and open it "\r\n"again.");\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EIO;\r\n}\r\nif (!(vma->vm_flags & (VM_WRITE | VM_READ))) {\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EACCES;\r\n}\r\nif (cam->io != IO_MMAP ||\r\nsize != PAGE_ALIGN(cam->frame[0].buf.length)) {\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < cam->nbuffers; i++) {\r\nif ((cam->frame[i].buf.m.offset>>PAGE_SHIFT) == vma->vm_pgoff)\r\nbreak;\r\n}\r\nif (i == cam->nbuffers) {\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EINVAL;\r\n}\r\nvma->vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;\r\npos = cam->frame[i].bufmem;\r\nwhile (size > 0) {\r\nif (vm_insert_page(vma, start, vmalloc_to_page(pos))) {\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EAGAIN;\r\n}\r\nstart += PAGE_SIZE;\r\npos += PAGE_SIZE;\r\nsize -= PAGE_SIZE;\r\n}\r\nvma->vm_ops = &sn9c102_vm_ops;\r\nvma->vm_private_data = &cam->frame[i];\r\nsn9c102_vm_open(vma);\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_querycap(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_capability cap = {\r\n.driver = "sn9c102",\r\n.version = LINUX_VERSION_CODE,\r\n.capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING,\r\n};\r\nstrlcpy(cap.card, cam->v4ldev->name, sizeof(cap.card));\r\nif (usb_make_path(cam->usbdev, cap.bus_info, sizeof(cap.bus_info)) < 0)\r\nstrlcpy(cap.bus_info, dev_name(&cam->usbdev->dev),\r\nsizeof(cap.bus_info));\r\nif (copy_to_user(arg, &cap, sizeof(cap)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_enuminput(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_input i;\r\nif (copy_from_user(&i, arg, sizeof(i)))\r\nreturn -EFAULT;\r\nif (i.index)\r\nreturn -EINVAL;\r\nmemset(&i, 0, sizeof(i));\r\nstrcpy(i.name, "Camera");\r\ni.type = V4L2_INPUT_TYPE_CAMERA;\r\ni.capabilities = V4L2_IN_CAP_STD;\r\nif (copy_to_user(arg, &i, sizeof(i)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_g_input(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nint index = 0;\r\nif (copy_to_user(arg, &index, sizeof(index)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_s_input(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nint index;\r\nif (copy_from_user(&index, arg, sizeof(index)))\r\nreturn -EFAULT;\r\nif (index != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_query_ctrl(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct sn9c102_sensor* s = &cam->sensor;\r\nstruct v4l2_queryctrl qc;\r\nu8 i;\r\nif (copy_from_user(&qc, arg, sizeof(qc)))\r\nreturn -EFAULT;\r\nfor (i = 0; i < ARRAY_SIZE(s->qctrl); i++)\r\nif (qc.id && qc.id == s->qctrl[i].id) {\r\nmemcpy(&qc, &(s->qctrl[i]), sizeof(qc));\r\nif (copy_to_user(arg, &qc, sizeof(qc)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nsn9c102_vidioc_g_ctrl(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct sn9c102_sensor* s = &cam->sensor;\r\nstruct v4l2_control ctrl;\r\nint err = 0;\r\nu8 i;\r\nif (!s->get_ctrl && !s->set_ctrl)\r\nreturn -EINVAL;\r\nif (copy_from_user(&ctrl, arg, sizeof(ctrl)))\r\nreturn -EFAULT;\r\nif (!s->get_ctrl) {\r\nfor (i = 0; i < ARRAY_SIZE(s->qctrl); i++)\r\nif (ctrl.id && ctrl.id == s->qctrl[i].id) {\r\nctrl.value = s->_qctrl[i].default_value;\r\ngoto exit;\r\n}\r\nreturn -EINVAL;\r\n} else\r\nerr = s->get_ctrl(cam, &ctrl);\r\nexit:\r\nif (copy_to_user(arg, &ctrl, sizeof(ctrl)))\r\nreturn -EFAULT;\r\nPDBGG("VIDIOC_G_CTRL: id %lu, value %lu",\r\n(unsigned long)ctrl.id, (unsigned long)ctrl.value);\r\nreturn err;\r\n}\r\nstatic int\r\nsn9c102_vidioc_s_ctrl(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct sn9c102_sensor* s = &cam->sensor;\r\nstruct v4l2_control ctrl;\r\nu8 i;\r\nint err = 0;\r\nif (!s->set_ctrl)\r\nreturn -EINVAL;\r\nif (copy_from_user(&ctrl, arg, sizeof(ctrl)))\r\nreturn -EFAULT;\r\nfor (i = 0; i < ARRAY_SIZE(s->qctrl); i++) {\r\nif (ctrl.id == s->qctrl[i].id) {\r\nif (s->qctrl[i].flags & V4L2_CTRL_FLAG_DISABLED)\r\nreturn -EINVAL;\r\nif (ctrl.value < s->qctrl[i].minimum ||\r\nctrl.value > s->qctrl[i].maximum)\r\nreturn -ERANGE;\r\nctrl.value -= ctrl.value % s->qctrl[i].step;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(s->qctrl))\r\nreturn -EINVAL;\r\nif ((err = s->set_ctrl(cam, &ctrl)))\r\nreturn err;\r\ns->_qctrl[i].default_value = ctrl.value;\r\nPDBGG("VIDIOC_S_CTRL: id %lu, value %lu",\r\n(unsigned long)ctrl.id, (unsigned long)ctrl.value);\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_cropcap(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_cropcap* cc = &(cam->sensor.cropcap);\r\ncc->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ncc->pixelaspect.numerator = 1;\r\ncc->pixelaspect.denominator = 1;\r\nif (copy_to_user(arg, cc, sizeof(*cc)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_g_crop(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct sn9c102_sensor* s = &cam->sensor;\r\nstruct v4l2_crop crop = {\r\n.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\r\n};\r\nmemcpy(&(crop.c), &(s->_rect), sizeof(struct v4l2_rect));\r\nif (copy_to_user(arg, &crop, sizeof(crop)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_s_crop(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct sn9c102_sensor* s = &cam->sensor;\r\nstruct v4l2_crop crop;\r\nstruct v4l2_rect* rect;\r\nstruct v4l2_rect* bounds = &(s->cropcap.bounds);\r\nstruct v4l2_pix_format* pix_format = &(s->pix_format);\r\nu8 scale;\r\nconst enum sn9c102_stream_state stream = cam->stream;\r\nconst u32 nbuffers = cam->nbuffers;\r\nu32 i;\r\nint err = 0;\r\nif (copy_from_user(&crop, arg, sizeof(crop)))\r\nreturn -EFAULT;\r\nrect = &(crop.c);\r\nif (crop.type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (cam->module_param.force_munmap)\r\nfor (i = 0; i < cam->nbuffers; i++)\r\nif (cam->frame[i].vma_use_count) {\r\nDBG(3, "VIDIOC_S_CROP failed. "\r\n"Unmap the buffers first.");\r\nreturn -EBUSY;\r\n}\r\nrect->left = (s->_rect.left & 1L) ? rect->left | 1L : rect->left & ~1L;\r\nrect->top = (s->_rect.top & 1L) ? rect->top | 1L : rect->top & ~1L;\r\nif (rect->width < 16)\r\nrect->width = 16;\r\nif (rect->height < 16)\r\nrect->height = 16;\r\nif (rect->width > bounds->width)\r\nrect->width = bounds->width;\r\nif (rect->height > bounds->height)\r\nrect->height = bounds->height;\r\nif (rect->left < bounds->left)\r\nrect->left = bounds->left;\r\nif (rect->top < bounds->top)\r\nrect->top = bounds->top;\r\nif (rect->left + rect->width > bounds->left + bounds->width)\r\nrect->left = bounds->left+bounds->width - rect->width;\r\nif (rect->top + rect->height > bounds->top + bounds->height)\r\nrect->top = bounds->top+bounds->height - rect->height;\r\nrect->width &= ~15L;\r\nrect->height &= ~15L;\r\nif (SN9C102_PRESERVE_IMGSCALE) {\r\nu32 a, b;\r\na = rect->width * rect->height;\r\nb = pix_format->width * pix_format->height;\r\nscale = b ? (u8)((a / b) < 4 ? 1 : ((a / b) < 16 ? 2 : 4)) : 1;\r\n} else\r\nscale = 1;\r\nif (cam->stream == STREAM_ON)\r\nif ((err = sn9c102_stream_interrupt(cam)))\r\nreturn err;\r\nif (copy_to_user(arg, &crop, sizeof(crop))) {\r\ncam->stream = stream;\r\nreturn -EFAULT;\r\n}\r\nif (cam->module_param.force_munmap || cam->io == IO_READ)\r\nsn9c102_release_buffers(cam);\r\nerr = sn9c102_set_crop(cam, rect);\r\nif (s->set_crop)\r\nerr += s->set_crop(cam, rect);\r\nerr += sn9c102_set_scale(cam, scale);\r\nif (err) {\r\ncam->state |= DEV_MISCONFIGURED;\r\nDBG(1, "VIDIOC_S_CROP failed because of hardware problems. To "\r\n"use the camera, close and open %s again.",\r\nvideo_device_node_name(cam->v4ldev));\r\nreturn -EIO;\r\n}\r\ns->pix_format.width = rect->width/scale;\r\ns->pix_format.height = rect->height/scale;\r\nmemcpy(&(s->_rect), rect, sizeof(*rect));\r\nif ((cam->module_param.force_munmap || cam->io == IO_READ) &&\r\nnbuffers != sn9c102_request_buffers(cam, nbuffers, cam->io)) {\r\ncam->state |= DEV_MISCONFIGURED;\r\nDBG(1, "VIDIOC_S_CROP failed because of not enough memory. To "\r\n"use the camera, close and open %s again.",\r\nvideo_device_node_name(cam->v4ldev));\r\nreturn -ENOMEM;\r\n}\r\nif (cam->io == IO_READ)\r\nsn9c102_empty_framequeues(cam);\r\nelse if (cam->module_param.force_munmap)\r\nsn9c102_requeue_outqueue(cam);\r\ncam->stream = stream;\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_enum_framesizes(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_frmsizeenum frmsize;\r\nif (copy_from_user(&frmsize, arg, sizeof(frmsize)))\r\nreturn -EFAULT;\r\nif (frmsize.index != 0)\r\nreturn -EINVAL;\r\nswitch (cam->bridge) {\r\ncase BRIDGE_SN9C101:\r\ncase BRIDGE_SN9C102:\r\ncase BRIDGE_SN9C103:\r\nif (frmsize.pixel_format != V4L2_PIX_FMT_SN9C10X &&\r\nfrmsize.pixel_format != V4L2_PIX_FMT_SBGGR8)\r\nreturn -EINVAL;\r\nbreak;\r\ncase BRIDGE_SN9C105:\r\ncase BRIDGE_SN9C120:\r\nif (frmsize.pixel_format != V4L2_PIX_FMT_JPEG &&\r\nfrmsize.pixel_format != V4L2_PIX_FMT_SBGGR8)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nfrmsize.type = V4L2_FRMSIZE_TYPE_STEPWISE;\r\nfrmsize.stepwise.min_width = frmsize.stepwise.step_width = 16;\r\nfrmsize.stepwise.min_height = frmsize.stepwise.step_height = 16;\r\nfrmsize.stepwise.max_width = cam->sensor.cropcap.bounds.width;\r\nfrmsize.stepwise.max_height = cam->sensor.cropcap.bounds.height;\r\nmemset(&frmsize.reserved, 0, sizeof(frmsize.reserved));\r\nif (copy_to_user(arg, &frmsize, sizeof(frmsize)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_enum_fmt(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_fmtdesc fmtd;\r\nif (copy_from_user(&fmtd, arg, sizeof(fmtd)))\r\nreturn -EFAULT;\r\nif (fmtd.type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (fmtd.index == 0) {\r\nstrcpy(fmtd.description, "bayer rgb");\r\nfmtd.pixelformat = V4L2_PIX_FMT_SBGGR8;\r\n} else if (fmtd.index == 1) {\r\nswitch (cam->bridge) {\r\ncase BRIDGE_SN9C101:\r\ncase BRIDGE_SN9C102:\r\ncase BRIDGE_SN9C103:\r\nstrcpy(fmtd.description, "compressed");\r\nfmtd.pixelformat = V4L2_PIX_FMT_SN9C10X;\r\nbreak;\r\ncase BRIDGE_SN9C105:\r\ncase BRIDGE_SN9C120:\r\nstrcpy(fmtd.description, "JPEG");\r\nfmtd.pixelformat = V4L2_PIX_FMT_JPEG;\r\nbreak;\r\n}\r\nfmtd.flags = V4L2_FMT_FLAG_COMPRESSED;\r\n} else\r\nreturn -EINVAL;\r\nfmtd.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nmemset(&fmtd.reserved, 0, sizeof(fmtd.reserved));\r\nif (copy_to_user(arg, &fmtd, sizeof(fmtd)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_g_fmt(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_format format;\r\nstruct v4l2_pix_format* pfmt = &(cam->sensor.pix_format);\r\nif (copy_from_user(&format, arg, sizeof(format)))\r\nreturn -EFAULT;\r\nif (format.type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\npfmt->colorspace = (pfmt->pixelformat == V4L2_PIX_FMT_JPEG) ?\r\nV4L2_COLORSPACE_JPEG : V4L2_COLORSPACE_SRGB;\r\npfmt->bytesperline = (pfmt->pixelformat == V4L2_PIX_FMT_SN9C10X ||\r\npfmt->pixelformat == V4L2_PIX_FMT_JPEG)\r\n? 0 : (pfmt->width * pfmt->priv) / 8;\r\npfmt->sizeimage = pfmt->height * ((pfmt->width*pfmt->priv)/8);\r\npfmt->field = V4L2_FIELD_NONE;\r\nmemcpy(&(format.fmt.pix), pfmt, sizeof(*pfmt));\r\nif (copy_to_user(arg, &format, sizeof(format)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_try_s_fmt(struct sn9c102_device* cam, unsigned int cmd,\r\nvoid __user * arg)\r\n{\r\nstruct sn9c102_sensor* s = &cam->sensor;\r\nstruct v4l2_format format;\r\nstruct v4l2_pix_format* pix;\r\nstruct v4l2_pix_format* pfmt = &(s->pix_format);\r\nstruct v4l2_rect* bounds = &(s->cropcap.bounds);\r\nstruct v4l2_rect rect;\r\nu8 scale;\r\nconst enum sn9c102_stream_state stream = cam->stream;\r\nconst u32 nbuffers = cam->nbuffers;\r\nu32 i;\r\nint err = 0;\r\nif (copy_from_user(&format, arg, sizeof(format)))\r\nreturn -EFAULT;\r\npix = &(format.fmt.pix);\r\nif (format.type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nmemcpy(&rect, &(s->_rect), sizeof(rect));\r\n{\r\nu32 a, b;\r\na = rect.width * rect.height;\r\nb = pix->width * pix->height;\r\nscale = b ? (u8)((a / b) < 4 ? 1 : ((a / b) < 16 ? 2 : 4)) : 1;\r\n}\r\nrect.width = scale * pix->width;\r\nrect.height = scale * pix->height;\r\nif (rect.width < 16)\r\nrect.width = 16;\r\nif (rect.height < 16)\r\nrect.height = 16;\r\nif (rect.width > bounds->left + bounds->width - rect.left)\r\nrect.width = bounds->left + bounds->width - rect.left;\r\nif (rect.height > bounds->top + bounds->height - rect.top)\r\nrect.height = bounds->top + bounds->height - rect.top;\r\nrect.width &= ~15L;\r\nrect.height &= ~15L;\r\n{\r\nu32 a, b;\r\na = rect.width * rect.height;\r\nb = pix->width * pix->height;\r\nscale = b ? (u8)((a / b) < 4 ? 1 : ((a / b) < 16 ? 2 : 4)) : 1;\r\n}\r\npix->width = rect.width / scale;\r\npix->height = rect.height / scale;\r\nswitch (cam->bridge) {\r\ncase BRIDGE_SN9C101:\r\ncase BRIDGE_SN9C102:\r\ncase BRIDGE_SN9C103:\r\nif (pix->pixelformat != V4L2_PIX_FMT_SN9C10X &&\r\npix->pixelformat != V4L2_PIX_FMT_SBGGR8)\r\npix->pixelformat = pfmt->pixelformat;\r\nbreak;\r\ncase BRIDGE_SN9C105:\r\ncase BRIDGE_SN9C120:\r\nif (pix->pixelformat != V4L2_PIX_FMT_JPEG &&\r\npix->pixelformat != V4L2_PIX_FMT_SBGGR8)\r\npix->pixelformat = pfmt->pixelformat;\r\nbreak;\r\n}\r\npix->priv = pfmt->priv;\r\npix->colorspace = (pix->pixelformat == V4L2_PIX_FMT_JPEG) ?\r\nV4L2_COLORSPACE_JPEG : V4L2_COLORSPACE_SRGB;\r\npix->bytesperline = (pix->pixelformat == V4L2_PIX_FMT_SN9C10X ||\r\npix->pixelformat == V4L2_PIX_FMT_JPEG)\r\n? 0 : (pix->width * pix->priv) / 8;\r\npix->sizeimage = pix->height * ((pix->width * pix->priv) / 8);\r\npix->field = V4L2_FIELD_NONE;\r\nif (cmd == VIDIOC_TRY_FMT) {\r\nif (copy_to_user(arg, &format, sizeof(format)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nif (cam->module_param.force_munmap)\r\nfor (i = 0; i < cam->nbuffers; i++)\r\nif (cam->frame[i].vma_use_count) {\r\nDBG(3, "VIDIOC_S_FMT failed. Unmap the "\r\n"buffers first.");\r\nreturn -EBUSY;\r\n}\r\nif (cam->stream == STREAM_ON)\r\nif ((err = sn9c102_stream_interrupt(cam)))\r\nreturn err;\r\nif (copy_to_user(arg, &format, sizeof(format))) {\r\ncam->stream = stream;\r\nreturn -EFAULT;\r\n}\r\nif (cam->module_param.force_munmap || cam->io == IO_READ)\r\nsn9c102_release_buffers(cam);\r\nerr += sn9c102_set_pix_format(cam, pix);\r\nerr += sn9c102_set_crop(cam, &rect);\r\nif (s->set_pix_format)\r\nerr += s->set_pix_format(cam, pix);\r\nif (s->set_crop)\r\nerr += s->set_crop(cam, &rect);\r\nerr += sn9c102_set_scale(cam, scale);\r\nif (err) {\r\ncam->state |= DEV_MISCONFIGURED;\r\nDBG(1, "VIDIOC_S_FMT failed because of hardware problems. To "\r\n"use the camera, close and open %s again.",\r\nvideo_device_node_name(cam->v4ldev));\r\nreturn -EIO;\r\n}\r\nmemcpy(pfmt, pix, sizeof(*pix));\r\nmemcpy(&(s->_rect), &rect, sizeof(rect));\r\nif ((cam->module_param.force_munmap || cam->io == IO_READ) &&\r\nnbuffers != sn9c102_request_buffers(cam, nbuffers, cam->io)) {\r\ncam->state |= DEV_MISCONFIGURED;\r\nDBG(1, "VIDIOC_S_FMT failed because of not enough memory. To "\r\n"use the camera, close and open %s again.",\r\nvideo_device_node_name(cam->v4ldev));\r\nreturn -ENOMEM;\r\n}\r\nif (cam->io == IO_READ)\r\nsn9c102_empty_framequeues(cam);\r\nelse if (cam->module_param.force_munmap)\r\nsn9c102_requeue_outqueue(cam);\r\ncam->stream = stream;\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_g_jpegcomp(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nif (copy_to_user(arg, &cam->compression, sizeof(cam->compression)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_s_jpegcomp(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_jpegcompression jc;\r\nconst enum sn9c102_stream_state stream = cam->stream;\r\nint err = 0;\r\nif (copy_from_user(&jc, arg, sizeof(jc)))\r\nreturn -EFAULT;\r\nif (jc.quality != 0 && jc.quality != 1)\r\nreturn -EINVAL;\r\nif (cam->stream == STREAM_ON)\r\nif ((err = sn9c102_stream_interrupt(cam)))\r\nreturn err;\r\nerr += sn9c102_set_compression(cam, &jc);\r\nif (err) {\r\ncam->state |= DEV_MISCONFIGURED;\r\nDBG(1, "VIDIOC_S_JPEGCOMP failed because of hardware problems. "\r\n"To use the camera, close and open %s again.",\r\nvideo_device_node_name(cam->v4ldev));\r\nreturn -EIO;\r\n}\r\ncam->compression.quality = jc.quality;\r\ncam->stream = stream;\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_reqbufs(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_requestbuffers rb;\r\nu32 i;\r\nint err;\r\nif (copy_from_user(&rb, arg, sizeof(rb)))\r\nreturn -EFAULT;\r\nif (rb.type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\r\nrb.memory != V4L2_MEMORY_MMAP)\r\nreturn -EINVAL;\r\nif (cam->io == IO_READ) {\r\nDBG(3, "Close and open the device again to choose the mmap "\r\n"I/O method");\r\nreturn -EBUSY;\r\n}\r\nfor (i = 0; i < cam->nbuffers; i++)\r\nif (cam->frame[i].vma_use_count) {\r\nDBG(3, "VIDIOC_REQBUFS failed. Previous buffers are "\r\n"still mapped.");\r\nreturn -EBUSY;\r\n}\r\nif (cam->stream == STREAM_ON)\r\nif ((err = sn9c102_stream_interrupt(cam)))\r\nreturn err;\r\nsn9c102_empty_framequeues(cam);\r\nsn9c102_release_buffers(cam);\r\nif (rb.count)\r\nrb.count = sn9c102_request_buffers(cam, rb.count, IO_MMAP);\r\nif (copy_to_user(arg, &rb, sizeof(rb))) {\r\nsn9c102_release_buffers(cam);\r\ncam->io = IO_NONE;\r\nreturn -EFAULT;\r\n}\r\ncam->io = rb.count ? IO_MMAP : IO_NONE;\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_querybuf(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_buffer b;\r\nif (copy_from_user(&b, arg, sizeof(b)))\r\nreturn -EFAULT;\r\nif (b.type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\r\nb.index >= cam->nbuffers || cam->io != IO_MMAP)\r\nreturn -EINVAL;\r\nb = cam->frame[b.index].buf;\r\nif (cam->frame[b.index].vma_use_count)\r\nb.flags |= V4L2_BUF_FLAG_MAPPED;\r\nif (cam->frame[b.index].state == F_DONE)\r\nb.flags |= V4L2_BUF_FLAG_DONE;\r\nelse if (cam->frame[b.index].state != F_UNUSED)\r\nb.flags |= V4L2_BUF_FLAG_QUEUED;\r\nif (copy_to_user(arg, &b, sizeof(b)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_qbuf(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_buffer b;\r\nunsigned long lock_flags;\r\nif (copy_from_user(&b, arg, sizeof(b)))\r\nreturn -EFAULT;\r\nif (b.type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\r\nb.index >= cam->nbuffers || cam->io != IO_MMAP)\r\nreturn -EINVAL;\r\nif (cam->frame[b.index].state != F_UNUSED)\r\nreturn -EINVAL;\r\ncam->frame[b.index].state = F_QUEUED;\r\nspin_lock_irqsave(&cam->queue_lock, lock_flags);\r\nlist_add_tail(&cam->frame[b.index].frame, &cam->inqueue);\r\nspin_unlock_irqrestore(&cam->queue_lock, lock_flags);\r\nPDBGG("Frame #%lu queued", (unsigned long)b.index);\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_dqbuf(struct sn9c102_device* cam, struct file* filp,\r\nvoid __user * arg)\r\n{\r\nstruct v4l2_buffer b;\r\nstruct sn9c102_frame_t *f;\r\nunsigned long lock_flags;\r\nlong timeout;\r\nint err = 0;\r\nif (copy_from_user(&b, arg, sizeof(b)))\r\nreturn -EFAULT;\r\nif (b.type != V4L2_BUF_TYPE_VIDEO_CAPTURE || cam->io != IO_MMAP)\r\nreturn -EINVAL;\r\nif (list_empty(&cam->outqueue)) {\r\nif (cam->stream == STREAM_OFF)\r\nreturn -EINVAL;\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nif (!cam->module_param.frame_timeout) {\r\nerr = wait_event_interruptible\r\n( cam->wait_frame,\r\n(!list_empty(&cam->outqueue)) ||\r\n(cam->state & DEV_DISCONNECTED) ||\r\n(cam->state & DEV_MISCONFIGURED) );\r\nif (err)\r\nreturn err;\r\n} else {\r\ntimeout = wait_event_interruptible_timeout\r\n( cam->wait_frame,\r\n(!list_empty(&cam->outqueue)) ||\r\n(cam->state & DEV_DISCONNECTED) ||\r\n(cam->state & DEV_MISCONFIGURED),\r\ncam->module_param.frame_timeout *\r\n1000 * msecs_to_jiffies(1) );\r\nif (timeout < 0)\r\nreturn timeout;\r\nelse if (timeout == 0 &&\r\n!(cam->state & DEV_DISCONNECTED)) {\r\nDBG(1, "Video frame timeout elapsed");\r\nreturn -EIO;\r\n}\r\n}\r\nif (cam->state & DEV_DISCONNECTED)\r\nreturn -ENODEV;\r\nif (cam->state & DEV_MISCONFIGURED)\r\nreturn -EIO;\r\n}\r\nspin_lock_irqsave(&cam->queue_lock, lock_flags);\r\nf = list_entry(cam->outqueue.next, struct sn9c102_frame_t, frame);\r\nlist_del(cam->outqueue.next);\r\nspin_unlock_irqrestore(&cam->queue_lock, lock_flags);\r\nf->state = F_UNUSED;\r\nb = f->buf;\r\nif (f->vma_use_count)\r\nb.flags |= V4L2_BUF_FLAG_MAPPED;\r\nif (copy_to_user(arg, &b, sizeof(b)))\r\nreturn -EFAULT;\r\nPDBGG("Frame #%lu dequeued", (unsigned long)f->buf.index);\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_streamon(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nint type;\r\nif (copy_from_user(&type, arg, sizeof(type)))\r\nreturn -EFAULT;\r\nif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE || cam->io != IO_MMAP)\r\nreturn -EINVAL;\r\ncam->stream = STREAM_ON;\r\nDBG(3, "Stream on");\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_streamoff(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nint type, err;\r\nif (copy_from_user(&type, arg, sizeof(type)))\r\nreturn -EFAULT;\r\nif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE || cam->io != IO_MMAP)\r\nreturn -EINVAL;\r\nif (cam->stream == STREAM_ON)\r\nif ((err = sn9c102_stream_interrupt(cam)))\r\nreturn err;\r\nsn9c102_empty_framequeues(cam);\r\nDBG(3, "Stream off");\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_g_parm(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_streamparm sp;\r\nif (copy_from_user(&sp, arg, sizeof(sp)))\r\nreturn -EFAULT;\r\nif (sp.type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nsp.parm.capture.extendedmode = 0;\r\nsp.parm.capture.readbuffers = cam->nreadbuffers;\r\nif (copy_to_user(arg, &sp, sizeof(sp)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_s_parm(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_streamparm sp;\r\nif (copy_from_user(&sp, arg, sizeof(sp)))\r\nreturn -EFAULT;\r\nif (sp.type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nsp.parm.capture.extendedmode = 0;\r\nif (sp.parm.capture.readbuffers == 0)\r\nsp.parm.capture.readbuffers = cam->nreadbuffers;\r\nif (sp.parm.capture.readbuffers > SN9C102_MAX_FRAMES)\r\nsp.parm.capture.readbuffers = SN9C102_MAX_FRAMES;\r\nif (copy_to_user(arg, &sp, sizeof(sp)))\r\nreturn -EFAULT;\r\ncam->nreadbuffers = sp.parm.capture.readbuffers;\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_enumaudio(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_audio audio;\r\nif (cam->bridge == BRIDGE_SN9C101 || cam->bridge == BRIDGE_SN9C102)\r\nreturn -EINVAL;\r\nif (copy_from_user(&audio, arg, sizeof(audio)))\r\nreturn -EFAULT;\r\nif (audio.index != 0)\r\nreturn -EINVAL;\r\nstrcpy(audio.name, "Microphone");\r\naudio.capability = 0;\r\naudio.mode = 0;\r\nif (copy_to_user(arg, &audio, sizeof(audio)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_g_audio(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_audio audio;\r\nif (cam->bridge == BRIDGE_SN9C101 || cam->bridge == BRIDGE_SN9C102)\r\nreturn -EINVAL;\r\nif (copy_from_user(&audio, arg, sizeof(audio)))\r\nreturn -EFAULT;\r\nmemset(&audio, 0, sizeof(audio));\r\nstrcpy(audio.name, "Microphone");\r\nif (copy_to_user(arg, &audio, sizeof(audio)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\nsn9c102_vidioc_s_audio(struct sn9c102_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_audio audio;\r\nif (cam->bridge == BRIDGE_SN9C101 || cam->bridge == BRIDGE_SN9C102)\r\nreturn -EINVAL;\r\nif (copy_from_user(&audio, arg, sizeof(audio)))\r\nreturn -EFAULT;\r\nif (audio.index != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic long sn9c102_ioctl_v4l2(struct file *filp,\r\nunsigned int cmd, void __user *arg)\r\n{\r\nstruct sn9c102_device *cam = video_drvdata(filp);\r\nswitch (cmd) {\r\ncase VIDIOC_QUERYCAP:\r\nreturn sn9c102_vidioc_querycap(cam, arg);\r\ncase VIDIOC_ENUMINPUT:\r\nreturn sn9c102_vidioc_enuminput(cam, arg);\r\ncase VIDIOC_G_INPUT:\r\nreturn sn9c102_vidioc_g_input(cam, arg);\r\ncase VIDIOC_S_INPUT:\r\nreturn sn9c102_vidioc_s_input(cam, arg);\r\ncase VIDIOC_QUERYCTRL:\r\nreturn sn9c102_vidioc_query_ctrl(cam, arg);\r\ncase VIDIOC_G_CTRL:\r\nreturn sn9c102_vidioc_g_ctrl(cam, arg);\r\ncase VIDIOC_S_CTRL:\r\nreturn sn9c102_vidioc_s_ctrl(cam, arg);\r\ncase VIDIOC_CROPCAP:\r\nreturn sn9c102_vidioc_cropcap(cam, arg);\r\ncase VIDIOC_G_CROP:\r\nreturn sn9c102_vidioc_g_crop(cam, arg);\r\ncase VIDIOC_S_CROP:\r\nreturn sn9c102_vidioc_s_crop(cam, arg);\r\ncase VIDIOC_ENUM_FRAMESIZES:\r\nreturn sn9c102_vidioc_enum_framesizes(cam, arg);\r\ncase VIDIOC_ENUM_FMT:\r\nreturn sn9c102_vidioc_enum_fmt(cam, arg);\r\ncase VIDIOC_G_FMT:\r\nreturn sn9c102_vidioc_g_fmt(cam, arg);\r\ncase VIDIOC_TRY_FMT:\r\ncase VIDIOC_S_FMT:\r\nreturn sn9c102_vidioc_try_s_fmt(cam, cmd, arg);\r\ncase VIDIOC_G_JPEGCOMP:\r\nreturn sn9c102_vidioc_g_jpegcomp(cam, arg);\r\ncase VIDIOC_S_JPEGCOMP:\r\nreturn sn9c102_vidioc_s_jpegcomp(cam, arg);\r\ncase VIDIOC_REQBUFS:\r\nreturn sn9c102_vidioc_reqbufs(cam, arg);\r\ncase VIDIOC_QUERYBUF:\r\nreturn sn9c102_vidioc_querybuf(cam, arg);\r\ncase VIDIOC_QBUF:\r\nreturn sn9c102_vidioc_qbuf(cam, arg);\r\ncase VIDIOC_DQBUF:\r\nreturn sn9c102_vidioc_dqbuf(cam, filp, arg);\r\ncase VIDIOC_STREAMON:\r\nreturn sn9c102_vidioc_streamon(cam, arg);\r\ncase VIDIOC_STREAMOFF:\r\nreturn sn9c102_vidioc_streamoff(cam, arg);\r\ncase VIDIOC_G_PARM:\r\nreturn sn9c102_vidioc_g_parm(cam, arg);\r\ncase VIDIOC_S_PARM:\r\nreturn sn9c102_vidioc_s_parm(cam, arg);\r\ncase VIDIOC_ENUMAUDIO:\r\nreturn sn9c102_vidioc_enumaudio(cam, arg);\r\ncase VIDIOC_G_AUDIO:\r\nreturn sn9c102_vidioc_g_audio(cam, arg);\r\ncase VIDIOC_S_AUDIO:\r\nreturn sn9c102_vidioc_s_audio(cam, arg);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic long sn9c102_ioctl(struct file *filp,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct sn9c102_device *cam = video_drvdata(filp);\r\nint err = 0;\r\nif (mutex_lock_interruptible(&cam->fileop_mutex))\r\nreturn -ERESTARTSYS;\r\nif (cam->state & DEV_DISCONNECTED) {\r\nDBG(1, "Device not present");\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -ENODEV;\r\n}\r\nif (cam->state & DEV_MISCONFIGURED) {\r\nDBG(1, "The camera is misconfigured. Close and open it "\r\n"again.");\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EIO;\r\n}\r\nV4LDBG(3, "sn9c102", cmd);\r\nerr = sn9c102_ioctl_v4l2(filp, cmd, (void __user *)arg);\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn err;\r\n}\r\nstatic int\r\nsn9c102_usb_probe(struct usb_interface* intf, const struct usb_device_id* id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct sn9c102_device* cam;\r\nstatic unsigned int dev_nr;\r\nunsigned int i;\r\nint err = 0, r;\r\nif (!(cam = kzalloc(sizeof(struct sn9c102_device), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\ncam->usbdev = udev;\r\nif (v4l2_device_register(&intf->dev, &cam->v4l2_dev)) {\r\ndev_err(&intf->dev, "v4l2_device_register failed\n");\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nif (!(cam->control_buffer = kzalloc(8, GFP_KERNEL))) {\r\nDBG(1, "kzalloc() failed");\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nif (!(cam->v4ldev = video_device_alloc())) {\r\nDBG(1, "video_device_alloc() failed");\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nr = sn9c102_read_reg(cam, 0x00);\r\nif (r < 0 || (r != 0x10 && r != 0x11 && r != 0x12)) {\r\nDBG(1, "Sorry, this is not a SN9C1xx-based camera "\r\n"(vid:pid 0x%04X:0x%04X)", id->idVendor, id->idProduct);\r\nerr = -ENODEV;\r\ngoto fail;\r\n}\r\ncam->bridge = id->driver_info;\r\nswitch (cam->bridge) {\r\ncase BRIDGE_SN9C101:\r\ncase BRIDGE_SN9C102:\r\nDBG(2, "SN9C10[12] PC Camera Controller detected "\r\n"(vid:pid 0x%04X:0x%04X)", id->idVendor, id->idProduct);\r\nbreak;\r\ncase BRIDGE_SN9C103:\r\nDBG(2, "SN9C103 PC Camera Controller detected "\r\n"(vid:pid 0x%04X:0x%04X)", id->idVendor, id->idProduct);\r\nbreak;\r\ncase BRIDGE_SN9C105:\r\nDBG(2, "SN9C105 PC Camera Controller detected "\r\n"(vid:pid 0x%04X:0x%04X)", id->idVendor, id->idProduct);\r\nbreak;\r\ncase BRIDGE_SN9C120:\r\nDBG(2, "SN9C120 PC Camera Controller detected "\r\n"(vid:pid 0x%04X:0x%04X)", id->idVendor, id->idProduct);\r\nbreak;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(sn9c102_sensor_table); i++) {\r\nerr = sn9c102_sensor_table[i](cam);\r\nif (!err)\r\nbreak;\r\n}\r\nif (!err) {\r\nDBG(2, "%s image sensor detected", cam->sensor.name);\r\nDBG(3, "Support for %s maintained by %s",\r\ncam->sensor.name, cam->sensor.maintainer);\r\n} else {\r\nDBG(1, "No supported image sensor detected for this bridge");\r\nerr = -ENODEV;\r\ngoto fail;\r\n}\r\nif (!(cam->bridge & cam->sensor.supported_bridge)) {\r\nDBG(1, "Bridge not supported");\r\nerr = -ENODEV;\r\ngoto fail;\r\n}\r\nif (sn9c102_init(cam)) {\r\nDBG(1, "Initialization failed. I will retry on open().");\r\ncam->state |= DEV_MISCONFIGURED;\r\n}\r\nstrcpy(cam->v4ldev->name, "SN9C1xx PC Camera");\r\ncam->v4ldev->fops = &sn9c102_fops;\r\ncam->v4ldev->release = video_device_release;\r\ncam->v4ldev->v4l2_dev = &cam->v4l2_dev;\r\ninit_completion(&cam->probe);\r\nerr = video_register_device(cam->v4ldev, VFL_TYPE_GRABBER,\r\nvideo_nr[dev_nr]);\r\nif (err) {\r\nDBG(1, "V4L2 device registration failed");\r\nif (err == -ENFILE && video_nr[dev_nr] == -1)\r\nDBG(1, "Free /dev/videoX node not found");\r\nvideo_nr[dev_nr] = -1;\r\ndev_nr = (dev_nr < SN9C102_MAX_DEVICES-1) ? dev_nr+1 : 0;\r\ncomplete_all(&cam->probe);\r\ngoto fail;\r\n}\r\nDBG(2, "V4L2 device registered as %s",\r\nvideo_device_node_name(cam->v4ldev));\r\nvideo_set_drvdata(cam->v4ldev, cam);\r\ncam->module_param.force_munmap = force_munmap[dev_nr];\r\ncam->module_param.frame_timeout = frame_timeout[dev_nr];\r\ndev_nr = (dev_nr < SN9C102_MAX_DEVICES-1) ? dev_nr+1 : 0;\r\n#ifdef CONFIG_VIDEO_ADV_DEBUG\r\nerr = sn9c102_create_sysfs(cam);\r\nif (!err)\r\nDBG(2, "Optional device control through 'sysfs' "\r\n"interface ready");\r\nelse\r\nDBG(2, "Failed to create optional 'sysfs' interface for "\r\n"device controlling. Error #%d", err);\r\n#else\r\nDBG(2, "Optional device control through 'sysfs' interface disabled");\r\nDBG(3, "Compile the kernel with the 'CONFIG_VIDEO_ADV_DEBUG' "\r\n"configuration option to enable it.");\r\n#endif\r\nusb_set_intfdata(intf, cam);\r\nkref_init(&cam->kref);\r\nusb_get_dev(cam->usbdev);\r\ncomplete_all(&cam->probe);\r\nreturn 0;\r\nfail:\r\nif (cam) {\r\nkfree(cam->control_buffer);\r\nif (cam->v4ldev)\r\nvideo_device_release(cam->v4ldev);\r\nv4l2_device_unregister(&cam->v4l2_dev);\r\nkfree(cam);\r\n}\r\nreturn err;\r\n}\r\nstatic void sn9c102_usb_disconnect(struct usb_interface* intf)\r\n{\r\nstruct sn9c102_device* cam;\r\ndown_write(&sn9c102_dev_lock);\r\ncam = usb_get_intfdata(intf);\r\nDBG(2, "Disconnecting %s...", cam->v4ldev->name);\r\nif (cam->users) {\r\nDBG(2, "Device %s is open! Deregistration and memory "\r\n"deallocation are deferred.",\r\nvideo_device_node_name(cam->v4ldev));\r\ncam->state |= DEV_MISCONFIGURED;\r\nsn9c102_stop_transfer(cam);\r\ncam->state |= DEV_DISCONNECTED;\r\nwake_up_interruptible(&cam->wait_frame);\r\nwake_up(&cam->wait_stream);\r\n} else\r\ncam->state |= DEV_DISCONNECTED;\r\nwake_up_interruptible_all(&cam->wait_open);\r\nv4l2_device_disconnect(&cam->v4l2_dev);\r\nkref_put(&cam->kref, sn9c102_release_resources);\r\nup_write(&sn9c102_dev_lock);\r\n}
