static int txsrc_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec;\r\nunsigned int src;\r\ncodec = snd_kcontrol_chip(kcontrol);\r\nsrc = snd_soc_read(codec, WM8804_SPDTX4);\r\nif (src & 0x40)\r\nucontrol->value.integer.value[0] = 1;\r\nelse\r\nucontrol->value.integer.value[0] = 0;\r\nreturn 0;\r\n}\r\nstatic int txsrc_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec;\r\nunsigned int src, txpwr;\r\ncodec = snd_kcontrol_chip(kcontrol);\r\nif (ucontrol->value.integer.value[0] != 0\r\n&& ucontrol->value.integer.value[0] != 1)\r\nreturn -EINVAL;\r\nsrc = snd_soc_read(codec, WM8804_SPDTX4);\r\nswitch ((src & 0x40) >> 6) {\r\ncase 0:\r\nif (!ucontrol->value.integer.value[0])\r\nreturn 0;\r\nbreak;\r\ncase 1:\r\nif (ucontrol->value.integer.value[1])\r\nreturn 0;\r\nbreak;\r\n}\r\ntxpwr = snd_soc_read(codec, WM8804_PWRDN) & 0x4;\r\nsnd_soc_update_bits(codec, WM8804_PWRDN, 0x4, 0x4);\r\nsnd_soc_update_bits(codec, WM8804_SPDTX4, 0x40,\r\nucontrol->value.integer.value[0] << 6);\r\nif (ucontrol->value.integer.value[0]) {\r\nsnd_soc_update_bits(codec, WM8804_PWRDN, 0x2, 0x2);\r\nsnd_soc_update_bits(codec, WM8804_PWRDN, 0x10, 0);\r\n} else {\r\nsnd_soc_update_bits(codec, WM8804_PWRDN, 0x2, 0);\r\n}\r\nsnd_soc_update_bits(codec, WM8804_PWRDN, 0x4, txpwr);\r\nreturn 0;\r\n}\r\nstatic bool wm8804_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8804_RST_DEVID1:\r\ncase WM8804_DEVID2:\r\ncase WM8804_DEVREV:\r\ncase WM8804_INTSTAT:\r\ncase WM8804_SPDSTAT:\r\ncase WM8804_RXCHAN1:\r\ncase WM8804_RXCHAN2:\r\ncase WM8804_RXCHAN3:\r\ncase WM8804_RXCHAN4:\r\ncase WM8804_RXCHAN5:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int wm8804_reset(struct snd_soc_codec *codec)\r\n{\r\nreturn snd_soc_write(codec, WM8804_RST_DEVID1, 0x0);\r\n}\r\nstatic int wm8804_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec;\r\nu16 format, master, bcp, lrp;\r\ncodec = dai->codec;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nformat = 0x2;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nformat = 0x0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nformat = 0x1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nformat = 0x3;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown dai format\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8804_AIFTX, 0x3, format);\r\nsnd_soc_update_bits(codec, WM8804_AIFRX, 0x3, format);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nmaster = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nmaster = 0;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown master/slave configuration\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8804_AIFRX, 0x40, master << 6);\r\nbcp = lrp = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nbcp = lrp = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nbcp = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nlrp = 1;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown polarity configuration\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8804_AIFTX, 0x10 | 0x20,\r\n(bcp << 4) | (lrp << 5));\r\nsnd_soc_update_bits(codec, WM8804_AIFRX, 0x10 | 0x20,\r\n(bcp << 4) | (lrp << 5));\r\nreturn 0;\r\n}\r\nstatic int wm8804_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec;\r\nu16 blen;\r\ncodec = dai->codec;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nblen = 0x0;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nblen = 0x1;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nblen = 0x2;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unsupported word length: %u\n",\r\nparams_format(params));\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8804_AIFTX, 0xc, blen << 2);\r\nsnd_soc_update_bits(codec, WM8804_AIFRX, 0xc, blen << 2);\r\nreturn 0;\r\n}\r\nstatic int pll_factors(struct pll_div *pll_div, unsigned int target,\r\nunsigned int source)\r\n{\r\nu64 Kpart;\r\nunsigned long int K, Ndiv, Nmod, tmp;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(post_table); i++) {\r\ntmp = target * post_table[i].div;\r\nif (tmp >= 90000000 && tmp <= 100000000) {\r\npll_div->freqmode = post_table[i].freqmode;\r\npll_div->mclkdiv = post_table[i].mclkdiv;\r\ntarget *= post_table[i].div;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(post_table)) {\r\npr_err("%s: Unable to scale output frequency: %uHz\n",\r\n__func__, target);\r\nreturn -EINVAL;\r\n}\r\npll_div->prescale = 0;\r\nNdiv = target / source;\r\nif (Ndiv < 5) {\r\nsource >>= 1;\r\npll_div->prescale = 1;\r\nNdiv = target / source;\r\n}\r\nif (Ndiv < 5 || Ndiv > 13) {\r\npr_err("%s: WM8804 N value is not within the recommended range: %lu\n",\r\n__func__, Ndiv);\r\nreturn -EINVAL;\r\n}\r\npll_div->n = Ndiv;\r\nNmod = target % source;\r\nKpart = FIXED_PLL_SIZE * (u64)Nmod;\r\ndo_div(Kpart, source);\r\nK = Kpart & 0xffffffff;\r\nif ((K % 10) >= 5)\r\nK += 5;\r\nK /= 10;\r\npll_div->k = K;\r\nreturn 0;\r\n}\r\nstatic int wm8804_set_pll(struct snd_soc_dai *dai, int pll_id,\r\nint source, unsigned int freq_in,\r\nunsigned int freq_out)\r\n{\r\nstruct snd_soc_codec *codec;\r\ncodec = dai->codec;\r\nif (!freq_in || !freq_out) {\r\nsnd_soc_update_bits(codec, WM8804_PWRDN, 0x1, 0x1);\r\nreturn 0;\r\n} else {\r\nint ret;\r\nstruct pll_div pll_div;\r\nret = pll_factors(&pll_div, freq_out, freq_in);\r\nif (ret)\r\nreturn ret;\r\nsnd_soc_update_bits(codec, WM8804_PWRDN, 0x1, 0x1);\r\nsnd_soc_update_bits(codec, WM8804_PLL4, 0xf | 0x10,\r\npll_div.n | (pll_div.prescale << 4));\r\nsnd_soc_update_bits(codec, WM8804_PLL5, 0x3 | 0x8,\r\npll_div.freqmode | (pll_div.mclkdiv << 3));\r\nsnd_soc_write(codec, WM8804_PLL1, pll_div.k & 0xff);\r\nsnd_soc_write(codec, WM8804_PLL2, (pll_div.k >> 8) & 0xff);\r\nsnd_soc_write(codec, WM8804_PLL3, pll_div.k >> 16);\r\nsnd_soc_update_bits(codec, WM8804_PWRDN, 0x1, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8804_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec;\r\ncodec = dai->codec;\r\nswitch (clk_id) {\r\ncase WM8804_TX_CLKSRC_MCLK:\r\nif ((freq >= 10000000 && freq <= 14400000)\r\n|| (freq >= 16280000 && freq <= 27000000))\r\nsnd_soc_update_bits(codec, WM8804_PLL6, 0x80, 0x80);\r\nelse {\r\ndev_err(dai->dev, "OSCCLOCK is not within the "\r\n"recommended range: %uHz\n", freq);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase WM8804_TX_CLKSRC_PLL:\r\nsnd_soc_update_bits(codec, WM8804_PLL6, 0x80, 0);\r\nbreak;\r\ncase WM8804_CLKOUT_SRC_CLK1:\r\nsnd_soc_update_bits(codec, WM8804_PLL6, 0x8, 0);\r\nbreak;\r\ncase WM8804_CLKOUT_SRC_OSCCLK:\r\nsnd_soc_update_bits(codec, WM8804_PLL6, 0x8, 0x8);\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown clock source: %d\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8804_set_clkdiv(struct snd_soc_dai *dai,\r\nint div_id, int div)\r\n{\r\nstruct snd_soc_codec *codec;\r\ncodec = dai->codec;\r\nswitch (div_id) {\r\ncase WM8804_CLKOUT_DIV:\r\nsnd_soc_update_bits(codec, WM8804_PLL5, 0x30,\r\n(div & 0x3) << 4);\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown clock divider: %d\n", div_id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8804_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nint ret;\r\nstruct wm8804_priv *wm8804;\r\nwm8804 = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, WM8804_PWRDN, 0x9, 0);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8804->supplies),\r\nwm8804->supplies);\r\nif (ret) {\r\ndev_err(codec->dev,\r\n"Failed to enable supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nregcache_sync(wm8804->regmap);\r\n}\r\nsnd_soc_update_bits(codec, WM8804_PWRDN, 0x9, 0x9);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, WM8804_PWRDN, 0x9, 0x9);\r\nregulator_bulk_disable(ARRAY_SIZE(wm8804->supplies),\r\nwm8804->supplies);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm8804_suspend(struct snd_soc_codec *codec)\r\n{\r\nwm8804_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8804_resume(struct snd_soc_codec *codec)\r\n{\r\nwm8804_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int wm8804_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8804_priv *wm8804;\r\nint i;\r\nwm8804 = snd_soc_codec_get_drvdata(codec);\r\nwm8804_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nfor (i = 0; i < ARRAY_SIZE(wm8804->supplies); ++i)\r\nregulator_unregister_notifier(wm8804->supplies[i].consumer,\r\n&wm8804->disable_nb[i]);\r\nregulator_bulk_free(ARRAY_SIZE(wm8804->supplies), wm8804->supplies);\r\nreturn 0;\r\n}\r\nstatic int wm8804_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8804_priv *wm8804;\r\nint i, id1, id2, ret;\r\nwm8804 = snd_soc_codec_get_drvdata(codec);\r\ncodec->control_data = wm8804->regmap;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_REGMAP);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to set cache i/o: %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(wm8804->supplies); i++)\r\nwm8804->supplies[i].supply = wm8804_supply_names[i];\r\nret = regulator_bulk_get(codec->dev, ARRAY_SIZE(wm8804->supplies),\r\nwm8804->supplies);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nwm8804->disable_nb[0].notifier_call = wm8804_regulator_event_0;\r\nwm8804->disable_nb[1].notifier_call = wm8804_regulator_event_1;\r\nfor (i = 0; i < ARRAY_SIZE(wm8804->supplies); i++) {\r\nret = regulator_register_notifier(wm8804->supplies[i].consumer,\r\n&wm8804->disable_nb[i]);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to register regulator notifier: %d\n",\r\nret);\r\n}\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8804->supplies),\r\nwm8804->supplies);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to enable supplies: %d\n", ret);\r\ngoto err_reg_get;\r\n}\r\nid1 = snd_soc_read(codec, WM8804_RST_DEVID1);\r\nif (id1 < 0) {\r\ndev_err(codec->dev, "Failed to read device ID: %d\n", id1);\r\nret = id1;\r\ngoto err_reg_enable;\r\n}\r\nid2 = snd_soc_read(codec, WM8804_DEVID2);\r\nif (id2 < 0) {\r\ndev_err(codec->dev, "Failed to read device ID: %d\n", id2);\r\nret = id2;\r\ngoto err_reg_enable;\r\n}\r\nid2 = (id2 << 8) | id1;\r\nif (id2 != 0x8805) {\r\ndev_err(codec->dev, "Invalid device ID: %#x\n", id2);\r\nret = -EINVAL;\r\ngoto err_reg_enable;\r\n}\r\nret = snd_soc_read(codec, WM8804_DEVREV);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to read device revision: %d\n",\r\nret);\r\ngoto err_reg_enable;\r\n}\r\ndev_info(codec->dev, "revision %c\n", ret + 'A');\r\nret = wm8804_reset(codec);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to issue reset: %d\n", ret);\r\ngoto err_reg_enable;\r\n}\r\nwm8804_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\nerr_reg_enable:\r\nregulator_bulk_disable(ARRAY_SIZE(wm8804->supplies), wm8804->supplies);\r\nerr_reg_get:\r\nregulator_bulk_free(ARRAY_SIZE(wm8804->supplies), wm8804->supplies);\r\nreturn ret;\r\n}\r\nstatic int wm8804_spi_probe(struct spi_device *spi)\r\n{\r\nstruct wm8804_priv *wm8804;\r\nint ret;\r\nwm8804 = devm_kzalloc(&spi->dev, sizeof *wm8804, GFP_KERNEL);\r\nif (!wm8804)\r\nreturn -ENOMEM;\r\nwm8804->regmap = devm_regmap_init_spi(spi, &wm8804_regmap_config);\r\nif (IS_ERR(wm8804->regmap)) {\r\nret = PTR_ERR(wm8804->regmap);\r\nreturn ret;\r\n}\r\nspi_set_drvdata(spi, wm8804);\r\nret = snd_soc_register_codec(&spi->dev,\r\n&soc_codec_dev_wm8804, &wm8804_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int wm8804_spi_remove(struct spi_device *spi)\r\n{\r\nsnd_soc_unregister_codec(&spi->dev);\r\nreturn 0;\r\n}\r\nstatic int wm8804_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm8804_priv *wm8804;\r\nint ret;\r\nwm8804 = devm_kzalloc(&i2c->dev, sizeof *wm8804, GFP_KERNEL);\r\nif (!wm8804)\r\nreturn -ENOMEM;\r\nwm8804->regmap = devm_regmap_init_i2c(i2c, &wm8804_regmap_config);\r\nif (IS_ERR(wm8804->regmap)) {\r\nret = PTR_ERR(wm8804->regmap);\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(i2c, wm8804);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm8804, &wm8804_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int wm8804_i2c_remove(struct i2c_client *i2c)\r\n{\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nreturn 0;\r\n}\r\nstatic int __init wm8804_modinit(void)\r\n{\r\nint ret = 0;\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\nret = i2c_add_driver(&wm8804_i2c_driver);\r\nif (ret) {\r\nprintk(KERN_ERR "Failed to register wm8804 I2C driver: %d\n",\r\nret);\r\n}\r\n#endif\r\n#if defined(CONFIG_SPI_MASTER)\r\nret = spi_register_driver(&wm8804_spi_driver);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "Failed to register wm8804 SPI driver: %d\n",\r\nret);\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit wm8804_exit(void)\r\n{\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\ni2c_del_driver(&wm8804_i2c_driver);\r\n#endif\r\n#if defined(CONFIG_SPI_MASTER)\r\nspi_unregister_driver(&wm8804_spi_driver);\r\n#endif\r\n}
