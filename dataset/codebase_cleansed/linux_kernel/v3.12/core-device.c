void fw_csr_iterator_init(struct fw_csr_iterator *ci, const u32 *p)\r\n{\r\nci->p = p + 1;\r\nci->end = ci->p + (p[0] >> 16);\r\n}\r\nint fw_csr_iterator_next(struct fw_csr_iterator *ci, int *key, int *value)\r\n{\r\n*key = *ci->p >> 24;\r\n*value = *ci->p & 0xffffff;\r\nreturn ci->p++ < ci->end;\r\n}\r\nstatic const u32 *search_leaf(const u32 *directory, int search_key)\r\n{\r\nstruct fw_csr_iterator ci;\r\nint last_key = 0, key, value;\r\nfw_csr_iterator_init(&ci, directory);\r\nwhile (fw_csr_iterator_next(&ci, &key, &value)) {\r\nif (last_key == search_key &&\r\nkey == (CSR_DESCRIPTOR | CSR_LEAF))\r\nreturn ci.p - 1 + value;\r\nlast_key = key;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int textual_leaf_to_string(const u32 *block, char *buf, size_t size)\r\n{\r\nunsigned int quadlets, i;\r\nchar c;\r\nif (!size || !buf)\r\nreturn -EINVAL;\r\nquadlets = min(block[0] >> 16, 256U);\r\nif (quadlets < 2)\r\nreturn -ENODATA;\r\nif (block[1] != 0 || block[2] != 0)\r\nreturn -ENODATA;\r\nblock += 3;\r\nquadlets -= 2;\r\nfor (i = 0; i < quadlets * 4 && i < size - 1; i++) {\r\nc = block[i / 4] >> (24 - 8 * (i % 4));\r\nif (c == '\0')\r\nbreak;\r\nbuf[i] = c;\r\n}\r\nbuf[i] = '\0';\r\nreturn i;\r\n}\r\nint fw_csr_string(const u32 *directory, int key, char *buf, size_t size)\r\n{\r\nconst u32 *leaf = search_leaf(directory, key);\r\nif (!leaf)\r\nreturn -ENOENT;\r\nreturn textual_leaf_to_string(leaf, buf, size);\r\n}\r\nstatic void get_ids(const u32 *directory, int *id)\r\n{\r\nstruct fw_csr_iterator ci;\r\nint key, value;\r\nfw_csr_iterator_init(&ci, directory);\r\nwhile (fw_csr_iterator_next(&ci, &key, &value)) {\r\nswitch (key) {\r\ncase CSR_VENDOR: id[0] = value; break;\r\ncase CSR_MODEL: id[1] = value; break;\r\ncase CSR_SPECIFIER_ID: id[2] = value; break;\r\ncase CSR_VERSION: id[3] = value; break;\r\n}\r\n}\r\n}\r\nstatic void get_modalias_ids(struct fw_unit *unit, int *id)\r\n{\r\nget_ids(&fw_parent_device(unit)->config_rom[5], id);\r\nget_ids(unit->directory, id);\r\n}\r\nstatic bool match_ids(const struct ieee1394_device_id *id_table, int *id)\r\n{\r\nint match = 0;\r\nif (id[0] == id_table->vendor_id)\r\nmatch |= IEEE1394_MATCH_VENDOR_ID;\r\nif (id[1] == id_table->model_id)\r\nmatch |= IEEE1394_MATCH_MODEL_ID;\r\nif (id[2] == id_table->specifier_id)\r\nmatch |= IEEE1394_MATCH_SPECIFIER_ID;\r\nif (id[3] == id_table->version)\r\nmatch |= IEEE1394_MATCH_VERSION;\r\nreturn (match & id_table->match_flags) == id_table->match_flags;\r\n}\r\nstatic const struct ieee1394_device_id *unit_match(struct device *dev,\r\nstruct device_driver *drv)\r\n{\r\nconst struct ieee1394_device_id *id_table =\r\ncontainer_of(drv, struct fw_driver, driver)->id_table;\r\nint id[] = {0, 0, 0, 0};\r\nget_modalias_ids(fw_unit(dev), id);\r\nfor (; id_table->match_flags != 0; id_table++)\r\nif (match_ids(id_table, id))\r\nreturn id_table;\r\nreturn NULL;\r\n}\r\nstatic int fw_unit_match(struct device *dev, struct device_driver *drv)\r\n{\r\nreturn is_fw_unit(dev) && unit_match(dev, drv) != NULL;\r\n}\r\nstatic int fw_unit_probe(struct device *dev)\r\n{\r\nstruct fw_driver *driver =\r\ncontainer_of(dev->driver, struct fw_driver, driver);\r\nreturn driver->probe(fw_unit(dev), unit_match(dev, dev->driver));\r\n}\r\nstatic int fw_unit_remove(struct device *dev)\r\n{\r\nstruct fw_driver *driver =\r\ncontainer_of(dev->driver, struct fw_driver, driver);\r\nreturn driver->remove(fw_unit(dev)), 0;\r\n}\r\nstatic int get_modalias(struct fw_unit *unit, char *buffer, size_t buffer_size)\r\n{\r\nint id[] = {0, 0, 0, 0};\r\nget_modalias_ids(unit, id);\r\nreturn snprintf(buffer, buffer_size,\r\n"ieee1394:ven%08Xmo%08Xsp%08Xver%08X",\r\nid[0], id[1], id[2], id[3]);\r\n}\r\nstatic int fw_unit_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct fw_unit *unit = fw_unit(dev);\r\nchar modalias[64];\r\nget_modalias(unit, modalias, sizeof(modalias));\r\nif (add_uevent_var(env, "MODALIAS=%s", modalias))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint fw_device_enable_phys_dma(struct fw_device *device)\r\n{\r\nint generation = device->generation;\r\nsmp_rmb();\r\nreturn device->card->driver->enable_phys_dma(device->card,\r\ndevice->node_id,\r\ngeneration);\r\n}\r\nstatic ssize_t show_immediate(struct device *dev,\r\nstruct device_attribute *dattr, char *buf)\r\n{\r\nstruct config_rom_attribute *attr =\r\ncontainer_of(dattr, struct config_rom_attribute, attr);\r\nstruct fw_csr_iterator ci;\r\nconst u32 *dir;\r\nint key, value, ret = -ENOENT;\r\ndown_read(&fw_device_rwsem);\r\nif (is_fw_unit(dev))\r\ndir = fw_unit(dev)->directory;\r\nelse\r\ndir = fw_device(dev)->config_rom + 5;\r\nfw_csr_iterator_init(&ci, dir);\r\nwhile (fw_csr_iterator_next(&ci, &key, &value))\r\nif (attr->key == key) {\r\nret = snprintf(buf, buf ? PAGE_SIZE : 0,\r\n"0x%06x\n", value);\r\nbreak;\r\n}\r\nup_read(&fw_device_rwsem);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_text_leaf(struct device *dev,\r\nstruct device_attribute *dattr, char *buf)\r\n{\r\nstruct config_rom_attribute *attr =\r\ncontainer_of(dattr, struct config_rom_attribute, attr);\r\nconst u32 *dir;\r\nsize_t bufsize;\r\nchar dummy_buf[2];\r\nint ret;\r\ndown_read(&fw_device_rwsem);\r\nif (is_fw_unit(dev))\r\ndir = fw_unit(dev)->directory;\r\nelse\r\ndir = fw_device(dev)->config_rom + 5;\r\nif (buf) {\r\nbufsize = PAGE_SIZE - 1;\r\n} else {\r\nbuf = dummy_buf;\r\nbufsize = 1;\r\n}\r\nret = fw_csr_string(dir, attr->key, buf, bufsize);\r\nif (ret >= 0) {\r\nwhile (ret > 0 && isspace(buf[ret - 1]))\r\nret--;\r\nstrcpy(buf + ret, "\n");\r\nret++;\r\n}\r\nup_read(&fw_device_rwsem);\r\nreturn ret;\r\n}\r\nstatic void init_fw_attribute_group(struct device *dev,\r\nstruct device_attribute *attrs,\r\nstruct fw_attribute_group *group)\r\n{\r\nstruct device_attribute *attr;\r\nint i, j;\r\nfor (j = 0; attrs[j].attr.name != NULL; j++)\r\ngroup->attrs[j] = &attrs[j].attr;\r\nfor (i = 0; i < ARRAY_SIZE(config_rom_attributes); i++) {\r\nattr = &config_rom_attributes[i].attr;\r\nif (attr->show(dev, attr, NULL) < 0)\r\ncontinue;\r\ngroup->attrs[j++] = &attr->attr;\r\n}\r\ngroup->attrs[j] = NULL;\r\ngroup->groups[0] = &group->group;\r\ngroup->groups[1] = NULL;\r\ngroup->group.attrs = group->attrs;\r\ndev->groups = (const struct attribute_group **) group->groups;\r\n}\r\nstatic ssize_t modalias_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fw_unit *unit = fw_unit(dev);\r\nint length;\r\nlength = get_modalias(unit, buf, PAGE_SIZE);\r\nstrcpy(buf + length, "\n");\r\nreturn length + 1;\r\n}\r\nstatic ssize_t rom_index_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fw_device *device = fw_device(dev->parent);\r\nstruct fw_unit *unit = fw_unit(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\n(int)(unit->directory - device->config_rom));\r\n}\r\nstatic ssize_t config_rom_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fw_device *device = fw_device(dev);\r\nsize_t length;\r\ndown_read(&fw_device_rwsem);\r\nlength = device->config_rom_length * 4;\r\nmemcpy(buf, device->config_rom, length);\r\nup_read(&fw_device_rwsem);\r\nreturn length;\r\n}\r\nstatic ssize_t guid_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fw_device *device = fw_device(dev);\r\nint ret;\r\ndown_read(&fw_device_rwsem);\r\nret = snprintf(buf, PAGE_SIZE, "0x%08x%08x\n",\r\ndevice->config_rom[3], device->config_rom[4]);\r\nup_read(&fw_device_rwsem);\r\nreturn ret;\r\n}\r\nstatic ssize_t is_local_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fw_device *device = fw_device(dev);\r\nreturn sprintf(buf, "%u\n", device->is_local);\r\n}\r\nstatic int units_sprintf(char *buf, const u32 *directory)\r\n{\r\nstruct fw_csr_iterator ci;\r\nint key, value;\r\nint specifier_id = 0;\r\nint version = 0;\r\nfw_csr_iterator_init(&ci, directory);\r\nwhile (fw_csr_iterator_next(&ci, &key, &value)) {\r\nswitch (key) {\r\ncase CSR_SPECIFIER_ID:\r\nspecifier_id = value;\r\nbreak;\r\ncase CSR_VERSION:\r\nversion = value;\r\nbreak;\r\n}\r\n}\r\nreturn sprintf(buf, "0x%06x:0x%06x ", specifier_id, version);\r\n}\r\nstatic ssize_t units_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fw_device *device = fw_device(dev);\r\nstruct fw_csr_iterator ci;\r\nint key, value, i = 0;\r\ndown_read(&fw_device_rwsem);\r\nfw_csr_iterator_init(&ci, &device->config_rom[5]);\r\nwhile (fw_csr_iterator_next(&ci, &key, &value)) {\r\nif (key != (CSR_UNIT | CSR_DIRECTORY))\r\ncontinue;\r\ni += units_sprintf(&buf[i], ci.p + value - 1);\r\nif (i >= PAGE_SIZE - (8 + 1 + 8 + 1))\r\nbreak;\r\n}\r\nup_read(&fw_device_rwsem);\r\nif (i)\r\nbuf[i - 1] = '\n';\r\nreturn i;\r\n}\r\nstatic int read_rom(struct fw_device *device,\r\nint generation, int index, u32 *data)\r\n{\r\nu64 offset = (CSR_REGISTER_BASE | CSR_CONFIG_ROM) + index * 4;\r\nint i, rcode;\r\nsmp_rmb();\r\nfor (i = 10; i < 100; i += 10) {\r\nrcode = fw_run_transaction(device->card,\r\nTCODE_READ_QUADLET_REQUEST, device->node_id,\r\ngeneration, device->max_speed, offset, data, 4);\r\nif (rcode != RCODE_BUSY)\r\nbreak;\r\nmsleep(i);\r\n}\r\nbe32_to_cpus(data);\r\nreturn rcode;\r\n}\r\nstatic int read_config_rom(struct fw_device *device, int generation)\r\n{\r\nstruct fw_card *card = device->card;\r\nconst u32 *old_rom, *new_rom;\r\nu32 *rom, *stack;\r\nu32 sp, key;\r\nint i, end, length, ret;\r\nrom = kmalloc(sizeof(*rom) * MAX_CONFIG_ROM_SIZE +\r\nsizeof(*stack) * MAX_CONFIG_ROM_SIZE, GFP_KERNEL);\r\nif (rom == NULL)\r\nreturn -ENOMEM;\r\nstack = &rom[MAX_CONFIG_ROM_SIZE];\r\nmemset(rom, 0, sizeof(*rom) * MAX_CONFIG_ROM_SIZE);\r\ndevice->max_speed = SCODE_100;\r\nfor (i = 0; i < 5; i++) {\r\nret = read_rom(device, generation, i, &rom[i]);\r\nif (ret != RCODE_COMPLETE)\r\ngoto out;\r\nif (i == 0 && rom[i] == 0) {\r\nret = RCODE_BUSY;\r\ngoto out;\r\n}\r\n}\r\ndevice->max_speed = device->node->max_speed;\r\nif ((rom[2] & 0x7) < device->max_speed ||\r\ndevice->max_speed == SCODE_BETA ||\r\ncard->beta_repeaters_present) {\r\nu32 dummy;\r\nif (device->max_speed == SCODE_BETA)\r\ndevice->max_speed = card->link_speed;\r\nwhile (device->max_speed > SCODE_100) {\r\nif (read_rom(device, generation, 0, &dummy) ==\r\nRCODE_COMPLETE)\r\nbreak;\r\ndevice->max_speed--;\r\n}\r\n}\r\nlength = i;\r\nsp = 0;\r\nstack[sp++] = 0xc0000005;\r\nwhile (sp > 0) {\r\nkey = stack[--sp];\r\ni = key & 0xffffff;\r\nif (WARN_ON(i >= MAX_CONFIG_ROM_SIZE)) {\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nret = read_rom(device, generation, i, &rom[i]);\r\nif (ret != RCODE_COMPLETE)\r\ngoto out;\r\nend = i + (rom[i] >> 16) + 1;\r\nif (end > MAX_CONFIG_ROM_SIZE) {\r\nfw_err(card, "skipped invalid ROM block %x at %llx\n",\r\nrom[i],\r\ni * 4 | CSR_REGISTER_BASE | CSR_CONFIG_ROM);\r\nrom[i] = 0;\r\nend = i;\r\n}\r\ni++;\r\nfor (; i < end; i++) {\r\nret = read_rom(device, generation, i, &rom[i]);\r\nif (ret != RCODE_COMPLETE)\r\ngoto out;\r\nif ((key >> 30) != 3 || (rom[i] >> 30) < 2)\r\ncontinue;\r\nif (i + (rom[i] & 0xffffff) >= MAX_CONFIG_ROM_SIZE) {\r\nfw_err(card,\r\n"skipped unsupported ROM entry %x at %llx\n",\r\nrom[i],\r\ni * 4 | CSR_REGISTER_BASE | CSR_CONFIG_ROM);\r\nrom[i] = 0;\r\ncontinue;\r\n}\r\nstack[sp++] = i + rom[i];\r\n}\r\nif (length < i)\r\nlength = i;\r\n}\r\nold_rom = device->config_rom;\r\nnew_rom = kmemdup(rom, length * 4, GFP_KERNEL);\r\nif (new_rom == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ndown_write(&fw_device_rwsem);\r\ndevice->config_rom = new_rom;\r\ndevice->config_rom_length = length;\r\nup_write(&fw_device_rwsem);\r\nkfree(old_rom);\r\nret = RCODE_COMPLETE;\r\ndevice->max_rec = rom[2] >> 12 & 0xf;\r\ndevice->cmc = rom[2] >> 30 & 1;\r\ndevice->irmc = rom[2] >> 31 & 1;\r\nout:\r\nkfree(rom);\r\nreturn ret;\r\n}\r\nstatic void fw_unit_release(struct device *dev)\r\n{\r\nstruct fw_unit *unit = fw_unit(dev);\r\nfw_device_put(fw_parent_device(unit));\r\nkfree(unit);\r\n}\r\nstatic bool is_fw_unit(struct device *dev)\r\n{\r\nreturn dev->type == &fw_unit_type;\r\n}\r\nstatic void create_units(struct fw_device *device)\r\n{\r\nstruct fw_csr_iterator ci;\r\nstruct fw_unit *unit;\r\nint key, value, i;\r\ni = 0;\r\nfw_csr_iterator_init(&ci, &device->config_rom[5]);\r\nwhile (fw_csr_iterator_next(&ci, &key, &value)) {\r\nif (key != (CSR_UNIT | CSR_DIRECTORY))\r\ncontinue;\r\nunit = kzalloc(sizeof(*unit), GFP_KERNEL);\r\nif (unit == NULL)\r\ncontinue;\r\nunit->directory = ci.p + value - 1;\r\nunit->device.bus = &fw_bus_type;\r\nunit->device.type = &fw_unit_type;\r\nunit->device.parent = &device->device;\r\ndev_set_name(&unit->device, "%s.%d", dev_name(&device->device), i++);\r\nBUILD_BUG_ON(ARRAY_SIZE(unit->attribute_group.attrs) <\r\nARRAY_SIZE(fw_unit_attributes) +\r\nARRAY_SIZE(config_rom_attributes));\r\ninit_fw_attribute_group(&unit->device,\r\nfw_unit_attributes,\r\n&unit->attribute_group);\r\nif (device_register(&unit->device) < 0)\r\ngoto skip_unit;\r\nfw_device_get(device);\r\ncontinue;\r\nskip_unit:\r\nkfree(unit);\r\n}\r\n}\r\nstatic int shutdown_unit(struct device *device, void *data)\r\n{\r\ndevice_unregister(device);\r\nreturn 0;\r\n}\r\nstruct fw_device *fw_device_get_by_devt(dev_t devt)\r\n{\r\nstruct fw_device *device;\r\ndown_read(&fw_device_rwsem);\r\ndevice = idr_find(&fw_device_idr, MINOR(devt));\r\nif (device)\r\nfw_device_get(device);\r\nup_read(&fw_device_rwsem);\r\nreturn device;\r\n}\r\nstatic void fw_schedule_device_work(struct fw_device *device,\r\nunsigned long delay)\r\n{\r\nqueue_delayed_work(fw_workqueue, &device->work, delay);\r\n}\r\nstatic void fw_device_shutdown(struct work_struct *work)\r\n{\r\nstruct fw_device *device =\r\ncontainer_of(work, struct fw_device, work.work);\r\nint minor = MINOR(device->device.devt);\r\nif (time_before64(get_jiffies_64(),\r\ndevice->card->reset_jiffies + SHUTDOWN_DELAY)\r\n&& !list_empty(&device->card->link)) {\r\nfw_schedule_device_work(device, SHUTDOWN_DELAY);\r\nreturn;\r\n}\r\nif (atomic_cmpxchg(&device->state,\r\nFW_DEVICE_GONE,\r\nFW_DEVICE_SHUTDOWN) != FW_DEVICE_GONE)\r\nreturn;\r\nfw_device_cdev_remove(device);\r\ndevice_for_each_child(&device->device, NULL, shutdown_unit);\r\ndevice_unregister(&device->device);\r\ndown_write(&fw_device_rwsem);\r\nidr_remove(&fw_device_idr, minor);\r\nup_write(&fw_device_rwsem);\r\nfw_device_put(device);\r\n}\r\nstatic void fw_device_release(struct device *dev)\r\n{\r\nstruct fw_device *device = fw_device(dev);\r\nstruct fw_card *card = device->card;\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\ndevice->node->data = NULL;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nfw_node_put(device->node);\r\nkfree(device->config_rom);\r\nkfree(device);\r\nfw_card_put(card);\r\n}\r\nstatic bool is_fw_device(struct device *dev)\r\n{\r\nreturn dev->type == &fw_device_type;\r\n}\r\nstatic int update_unit(struct device *dev, void *data)\r\n{\r\nstruct fw_unit *unit = fw_unit(dev);\r\nstruct fw_driver *driver = (struct fw_driver *)dev->driver;\r\nif (is_fw_unit(dev) && driver != NULL && driver->update != NULL) {\r\ndevice_lock(dev);\r\ndriver->update(unit);\r\ndevice_unlock(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void fw_device_update(struct work_struct *work)\r\n{\r\nstruct fw_device *device =\r\ncontainer_of(work, struct fw_device, work.work);\r\nfw_device_cdev_update(device);\r\ndevice_for_each_child(&device->device, NULL, update_unit);\r\n}\r\nstatic int lookup_existing_device(struct device *dev, void *data)\r\n{\r\nstruct fw_device *old = fw_device(dev);\r\nstruct fw_device *new = data;\r\nstruct fw_card *card = new->card;\r\nint match = 0;\r\nif (!is_fw_device(dev))\r\nreturn 0;\r\ndown_read(&fw_device_rwsem);\r\nspin_lock_irq(&card->lock);\r\nif (memcmp(old->config_rom, new->config_rom, 6 * 4) == 0 &&\r\natomic_cmpxchg(&old->state,\r\nFW_DEVICE_GONE,\r\nFW_DEVICE_RUNNING) == FW_DEVICE_GONE) {\r\nstruct fw_node *current_node = new->node;\r\nstruct fw_node *obsolete_node = old->node;\r\nnew->node = obsolete_node;\r\nnew->node->data = new;\r\nold->node = current_node;\r\nold->node->data = old;\r\nold->max_speed = new->max_speed;\r\nold->node_id = current_node->node_id;\r\nsmp_wmb();\r\nold->generation = card->generation;\r\nold->config_rom_retries = 0;\r\nfw_notice(card, "rediscovered device %s\n", dev_name(dev));\r\nPREPARE_DELAYED_WORK(&old->work, fw_device_update);\r\nfw_schedule_device_work(old, 0);\r\nif (current_node == card->root_node)\r\nfw_schedule_bm_work(card, 0);\r\nmatch = 1;\r\n}\r\nspin_unlock_irq(&card->lock);\r\nup_read(&fw_device_rwsem);\r\nreturn match;\r\n}\r\nstatic void set_broadcast_channel(struct fw_device *device, int generation)\r\n{\r\nstruct fw_card *card = device->card;\r\n__be32 data;\r\nint rcode;\r\nif (!card->broadcast_channel_allocated)\r\nreturn;\r\nif (!device->irmc || device->max_rec < 8)\r\nreturn;\r\nif (device->bc_implemented == BC_UNKNOWN) {\r\nrcode = fw_run_transaction(card, TCODE_READ_QUADLET_REQUEST,\r\ndevice->node_id, generation, device->max_speed,\r\nCSR_REGISTER_BASE + CSR_BROADCAST_CHANNEL,\r\n&data, 4);\r\nswitch (rcode) {\r\ncase RCODE_COMPLETE:\r\nif (data & cpu_to_be32(1 << 31)) {\r\ndevice->bc_implemented = BC_IMPLEMENTED;\r\nbreak;\r\n}\r\ncase RCODE_ADDRESS_ERROR:\r\ndevice->bc_implemented = BC_UNIMPLEMENTED;\r\n}\r\n}\r\nif (device->bc_implemented == BC_IMPLEMENTED) {\r\ndata = cpu_to_be32(BROADCAST_CHANNEL_INITIAL |\r\nBROADCAST_CHANNEL_VALID);\r\nfw_run_transaction(card, TCODE_WRITE_QUADLET_REQUEST,\r\ndevice->node_id, generation, device->max_speed,\r\nCSR_REGISTER_BASE + CSR_BROADCAST_CHANNEL,\r\n&data, 4);\r\n}\r\n}\r\nint fw_device_set_broadcast_channel(struct device *dev, void *gen)\r\n{\r\nif (is_fw_device(dev))\r\nset_broadcast_channel(fw_device(dev), (long)gen);\r\nreturn 0;\r\n}\r\nstatic void fw_device_init(struct work_struct *work)\r\n{\r\nstruct fw_device *device =\r\ncontainer_of(work, struct fw_device, work.work);\r\nstruct fw_card *card = device->card;\r\nstruct device *revived_dev;\r\nint minor, ret;\r\nret = read_config_rom(device, device->generation);\r\nif (ret != RCODE_COMPLETE) {\r\nif (device->config_rom_retries < MAX_RETRIES &&\r\natomic_read(&device->state) == FW_DEVICE_INITIALIZING) {\r\ndevice->config_rom_retries++;\r\nfw_schedule_device_work(device, RETRY_DELAY);\r\n} else {\r\nif (device->node->link_on)\r\nfw_notice(card, "giving up on node %x: reading config rom failed: %s\n",\r\ndevice->node_id,\r\nfw_rcode_string(ret));\r\nif (device->node == card->root_node)\r\nfw_schedule_bm_work(card, 0);\r\nfw_device_release(&device->device);\r\n}\r\nreturn;\r\n}\r\nrevived_dev = device_find_child(card->device,\r\ndevice, lookup_existing_device);\r\nif (revived_dev) {\r\nput_device(revived_dev);\r\nfw_device_release(&device->device);\r\nreturn;\r\n}\r\ndevice_initialize(&device->device);\r\nfw_device_get(device);\r\ndown_write(&fw_device_rwsem);\r\nminor = idr_alloc(&fw_device_idr, device, 0, 1 << MINORBITS,\r\nGFP_KERNEL);\r\nup_write(&fw_device_rwsem);\r\nif (minor < 0)\r\ngoto error;\r\ndevice->device.bus = &fw_bus_type;\r\ndevice->device.type = &fw_device_type;\r\ndevice->device.parent = card->device;\r\ndevice->device.devt = MKDEV(fw_cdev_major, minor);\r\ndev_set_name(&device->device, "fw%d", minor);\r\nBUILD_BUG_ON(ARRAY_SIZE(device->attribute_group.attrs) <\r\nARRAY_SIZE(fw_device_attributes) +\r\nARRAY_SIZE(config_rom_attributes));\r\ninit_fw_attribute_group(&device->device,\r\nfw_device_attributes,\r\n&device->attribute_group);\r\nif (device_add(&device->device)) {\r\nfw_err(card, "failed to add device\n");\r\ngoto error_with_cdev;\r\n}\r\ncreate_units(device);\r\nif (atomic_cmpxchg(&device->state,\r\nFW_DEVICE_INITIALIZING,\r\nFW_DEVICE_RUNNING) == FW_DEVICE_GONE) {\r\nPREPARE_DELAYED_WORK(&device->work, fw_device_shutdown);\r\nfw_schedule_device_work(device, SHUTDOWN_DELAY);\r\n} else {\r\nfw_notice(card, "created device %s: GUID %08x%08x, S%d00\n",\r\ndev_name(&device->device),\r\ndevice->config_rom[3], device->config_rom[4],\r\n1 << device->max_speed);\r\ndevice->config_rom_retries = 0;\r\nset_broadcast_channel(device, device->generation);\r\nadd_device_randomness(&device->config_rom[3], 8);\r\n}\r\nif (device->node == card->root_node)\r\nfw_schedule_bm_work(card, 0);\r\nreturn;\r\nerror_with_cdev:\r\ndown_write(&fw_device_rwsem);\r\nidr_remove(&fw_device_idr, minor);\r\nup_write(&fw_device_rwsem);\r\nerror:\r\nfw_device_put(device);\r\nput_device(&device->device);\r\n}\r\nstatic int reread_config_rom(struct fw_device *device, int generation,\r\nbool *changed)\r\n{\r\nu32 q;\r\nint i, rcode;\r\nfor (i = 0; i < 6; i++) {\r\nrcode = read_rom(device, generation, i, &q);\r\nif (rcode != RCODE_COMPLETE)\r\nreturn rcode;\r\nif (i == 0 && q == 0)\r\nreturn RCODE_BUSY;\r\nif (q != device->config_rom[i]) {\r\n*changed = true;\r\nreturn RCODE_COMPLETE;\r\n}\r\n}\r\n*changed = false;\r\nreturn RCODE_COMPLETE;\r\n}\r\nstatic void fw_device_refresh(struct work_struct *work)\r\n{\r\nstruct fw_device *device =\r\ncontainer_of(work, struct fw_device, work.work);\r\nstruct fw_card *card = device->card;\r\nint ret, node_id = device->node_id;\r\nbool changed;\r\nret = reread_config_rom(device, device->generation, &changed);\r\nif (ret != RCODE_COMPLETE)\r\ngoto failed_config_rom;\r\nif (!changed) {\r\nif (atomic_cmpxchg(&device->state,\r\nFW_DEVICE_INITIALIZING,\r\nFW_DEVICE_RUNNING) == FW_DEVICE_GONE)\r\ngoto gone;\r\nfw_device_update(work);\r\ndevice->config_rom_retries = 0;\r\ngoto out;\r\n}\r\ndevice_for_each_child(&device->device, NULL, shutdown_unit);\r\nret = read_config_rom(device, device->generation);\r\nif (ret != RCODE_COMPLETE)\r\ngoto failed_config_rom;\r\nfw_device_cdev_update(device);\r\ncreate_units(device);\r\nkobject_uevent(&device->device.kobj, KOBJ_CHANGE);\r\nif (atomic_cmpxchg(&device->state,\r\nFW_DEVICE_INITIALIZING,\r\nFW_DEVICE_RUNNING) == FW_DEVICE_GONE)\r\ngoto gone;\r\nfw_notice(card, "refreshed device %s\n", dev_name(&device->device));\r\ndevice->config_rom_retries = 0;\r\ngoto out;\r\nfailed_config_rom:\r\nif (device->config_rom_retries < MAX_RETRIES &&\r\natomic_read(&device->state) == FW_DEVICE_INITIALIZING) {\r\ndevice->config_rom_retries++;\r\nfw_schedule_device_work(device, RETRY_DELAY);\r\nreturn;\r\n}\r\nfw_notice(card, "giving up on refresh of device %s: %s\n",\r\ndev_name(&device->device), fw_rcode_string(ret));\r\ngone:\r\natomic_set(&device->state, FW_DEVICE_GONE);\r\nPREPARE_DELAYED_WORK(&device->work, fw_device_shutdown);\r\nfw_schedule_device_work(device, SHUTDOWN_DELAY);\r\nout:\r\nif (node_id == card->root_node->node_id)\r\nfw_schedule_bm_work(card, 0);\r\n}\r\nvoid fw_node_event(struct fw_card *card, struct fw_node *node, int event)\r\n{\r\nstruct fw_device *device;\r\nswitch (event) {\r\ncase FW_NODE_CREATED:\r\ncreate:\r\ndevice = kzalloc(sizeof(*device), GFP_ATOMIC);\r\nif (device == NULL)\r\nbreak;\r\natomic_set(&device->state, FW_DEVICE_INITIALIZING);\r\ndevice->card = fw_card_get(card);\r\ndevice->node = fw_node_get(node);\r\ndevice->node_id = node->node_id;\r\ndevice->generation = card->generation;\r\ndevice->is_local = node == card->local_node;\r\nmutex_init(&device->client_list_mutex);\r\nINIT_LIST_HEAD(&device->client_list);\r\nnode->data = device;\r\nINIT_DELAYED_WORK(&device->work, fw_device_init);\r\nfw_schedule_device_work(device, INITIAL_DELAY);\r\nbreak;\r\ncase FW_NODE_INITIATED_RESET:\r\ncase FW_NODE_LINK_ON:\r\ndevice = node->data;\r\nif (device == NULL)\r\ngoto create;\r\ndevice->node_id = node->node_id;\r\nsmp_wmb();\r\ndevice->generation = card->generation;\r\nif (atomic_cmpxchg(&device->state,\r\nFW_DEVICE_RUNNING,\r\nFW_DEVICE_INITIALIZING) == FW_DEVICE_RUNNING) {\r\nPREPARE_DELAYED_WORK(&device->work, fw_device_refresh);\r\nfw_schedule_device_work(device,\r\ndevice->is_local ? 0 : INITIAL_DELAY);\r\n}\r\nbreak;\r\ncase FW_NODE_UPDATED:\r\ndevice = node->data;\r\nif (device == NULL)\r\nbreak;\r\ndevice->node_id = node->node_id;\r\nsmp_wmb();\r\ndevice->generation = card->generation;\r\nif (atomic_read(&device->state) == FW_DEVICE_RUNNING) {\r\nPREPARE_DELAYED_WORK(&device->work, fw_device_update);\r\nfw_schedule_device_work(device, 0);\r\n}\r\nbreak;\r\ncase FW_NODE_DESTROYED:\r\ncase FW_NODE_LINK_OFF:\r\nif (!node->data)\r\nbreak;\r\ndevice = node->data;\r\nif (atomic_xchg(&device->state,\r\nFW_DEVICE_GONE) == FW_DEVICE_RUNNING) {\r\nPREPARE_DELAYED_WORK(&device->work, fw_device_shutdown);\r\nfw_schedule_device_work(device,\r\nlist_empty(&card->link) ? 0 : SHUTDOWN_DELAY);\r\n}\r\nbreak;\r\n}\r\n}
