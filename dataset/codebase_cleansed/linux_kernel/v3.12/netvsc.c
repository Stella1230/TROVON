static struct netvsc_device *alloc_net_device(struct hv_device *device)\r\n{\r\nstruct netvsc_device *net_device;\r\nstruct net_device *ndev = hv_get_drvdata(device);\r\nnet_device = kzalloc(sizeof(struct netvsc_device), GFP_KERNEL);\r\nif (!net_device)\r\nreturn NULL;\r\ninit_waitqueue_head(&net_device->wait_drain);\r\nnet_device->start_remove = false;\r\nnet_device->destroy = false;\r\nnet_device->dev = device;\r\nnet_device->ndev = ndev;\r\nhv_set_drvdata(device, net_device);\r\nreturn net_device;\r\n}\r\nstatic struct netvsc_device *get_outbound_net_device(struct hv_device *device)\r\n{\r\nstruct netvsc_device *net_device;\r\nnet_device = hv_get_drvdata(device);\r\nif (net_device && net_device->destroy)\r\nnet_device = NULL;\r\nreturn net_device;\r\n}\r\nstatic struct netvsc_device *get_inbound_net_device(struct hv_device *device)\r\n{\r\nstruct netvsc_device *net_device;\r\nnet_device = hv_get_drvdata(device);\r\nif (!net_device)\r\ngoto get_in_err;\r\nif (net_device->destroy &&\r\natomic_read(&net_device->num_outstanding_sends) == 0)\r\nnet_device = NULL;\r\nget_in_err:\r\nreturn net_device;\r\n}\r\nstatic int netvsc_destroy_recv_buf(struct netvsc_device *net_device)\r\n{\r\nstruct nvsp_message *revoke_packet;\r\nint ret = 0;\r\nstruct net_device *ndev = net_device->ndev;\r\nif (net_device->recv_section_cnt) {\r\nrevoke_packet = &net_device->revoke_packet;\r\nmemset(revoke_packet, 0, sizeof(struct nvsp_message));\r\nrevoke_packet->hdr.msg_type =\r\nNVSP_MSG1_TYPE_REVOKE_RECV_BUF;\r\nrevoke_packet->msg.v1_msg.\r\nrevoke_recv_buf.id = NETVSC_RECEIVE_BUFFER_ID;\r\nret = vmbus_sendpacket(net_device->dev->channel,\r\nrevoke_packet,\r\nsizeof(struct nvsp_message),\r\n(unsigned long)revoke_packet,\r\nVM_PKT_DATA_INBAND, 0);\r\nif (ret != 0) {\r\nnetdev_err(ndev, "unable to send "\r\n"revoke receive buffer to netvsp\n");\r\nreturn ret;\r\n}\r\n}\r\nif (net_device->recv_buf_gpadl_handle) {\r\nret = vmbus_teardown_gpadl(net_device->dev->channel,\r\nnet_device->recv_buf_gpadl_handle);\r\nif (ret != 0) {\r\nnetdev_err(ndev,\r\n"unable to teardown receive buffer's gpadl\n");\r\nreturn ret;\r\n}\r\nnet_device->recv_buf_gpadl_handle = 0;\r\n}\r\nif (net_device->recv_buf) {\r\nfree_pages((unsigned long)net_device->recv_buf,\r\nget_order(net_device->recv_buf_size));\r\nnet_device->recv_buf = NULL;\r\n}\r\nif (net_device->recv_section) {\r\nnet_device->recv_section_cnt = 0;\r\nkfree(net_device->recv_section);\r\nnet_device->recv_section = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int netvsc_init_recv_buf(struct hv_device *device)\r\n{\r\nint ret = 0;\r\nint t;\r\nstruct netvsc_device *net_device;\r\nstruct nvsp_message *init_packet;\r\nstruct net_device *ndev;\r\nnet_device = get_outbound_net_device(device);\r\nif (!net_device)\r\nreturn -ENODEV;\r\nndev = net_device->ndev;\r\nnet_device->recv_buf =\r\n(void *)__get_free_pages(GFP_KERNEL|__GFP_ZERO,\r\nget_order(net_device->recv_buf_size));\r\nif (!net_device->recv_buf) {\r\nnetdev_err(ndev, "unable to allocate receive "\r\n"buffer of size %d\n", net_device->recv_buf_size);\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nret = vmbus_establish_gpadl(device->channel, net_device->recv_buf,\r\nnet_device->recv_buf_size,\r\n&net_device->recv_buf_gpadl_handle);\r\nif (ret != 0) {\r\nnetdev_err(ndev,\r\n"unable to establish receive buffer's gpadl\n");\r\ngoto cleanup;\r\n}\r\ninit_packet = &net_device->channel_init_pkt;\r\nmemset(init_packet, 0, sizeof(struct nvsp_message));\r\ninit_packet->hdr.msg_type = NVSP_MSG1_TYPE_SEND_RECV_BUF;\r\ninit_packet->msg.v1_msg.send_recv_buf.\r\ngpadl_handle = net_device->recv_buf_gpadl_handle;\r\ninit_packet->msg.v1_msg.\r\nsend_recv_buf.id = NETVSC_RECEIVE_BUFFER_ID;\r\nret = vmbus_sendpacket(device->channel, init_packet,\r\nsizeof(struct nvsp_message),\r\n(unsigned long)init_packet,\r\nVM_PKT_DATA_INBAND,\r\nVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\r\nif (ret != 0) {\r\nnetdev_err(ndev,\r\n"unable to send receive buffer's gpadl to netvsp\n");\r\ngoto cleanup;\r\n}\r\nt = wait_for_completion_timeout(&net_device->channel_init_wait, 5*HZ);\r\nBUG_ON(t == 0);\r\nif (init_packet->msg.v1_msg.\r\nsend_recv_buf_complete.status != NVSP_STAT_SUCCESS) {\r\nnetdev_err(ndev, "Unable to complete receive buffer "\r\n"initialization with NetVsp - status %d\n",\r\ninit_packet->msg.v1_msg.\r\nsend_recv_buf_complete.status);\r\nret = -EINVAL;\r\ngoto cleanup;\r\n}\r\nnet_device->recv_section_cnt = init_packet->msg.\r\nv1_msg.send_recv_buf_complete.num_sections;\r\nnet_device->recv_section = kmemdup(\r\ninit_packet->msg.v1_msg.send_recv_buf_complete.sections,\r\nnet_device->recv_section_cnt *\r\nsizeof(struct nvsp_1_receive_buffer_section),\r\nGFP_KERNEL);\r\nif (net_device->recv_section == NULL) {\r\nret = -EINVAL;\r\ngoto cleanup;\r\n}\r\nif (net_device->recv_section_cnt != 1 ||\r\nnet_device->recv_section->offset != 0) {\r\nret = -EINVAL;\r\ngoto cleanup;\r\n}\r\ngoto exit;\r\ncleanup:\r\nnetvsc_destroy_recv_buf(net_device);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int negotiate_nvsp_ver(struct hv_device *device,\r\nstruct netvsc_device *net_device,\r\nstruct nvsp_message *init_packet,\r\nu32 nvsp_ver)\r\n{\r\nint ret, t;\r\nmemset(init_packet, 0, sizeof(struct nvsp_message));\r\ninit_packet->hdr.msg_type = NVSP_MSG_TYPE_INIT;\r\ninit_packet->msg.init_msg.init.min_protocol_ver = nvsp_ver;\r\ninit_packet->msg.init_msg.init.max_protocol_ver = nvsp_ver;\r\nret = vmbus_sendpacket(device->channel, init_packet,\r\nsizeof(struct nvsp_message),\r\n(unsigned long)init_packet,\r\nVM_PKT_DATA_INBAND,\r\nVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\r\nif (ret != 0)\r\nreturn ret;\r\nt = wait_for_completion_timeout(&net_device->channel_init_wait, 5*HZ);\r\nif (t == 0)\r\nreturn -ETIMEDOUT;\r\nif (init_packet->msg.init_msg.init_complete.status !=\r\nNVSP_STAT_SUCCESS)\r\nreturn -EINVAL;\r\nif (nvsp_ver != NVSP_PROTOCOL_VERSION_2)\r\nreturn 0;\r\nmemset(init_packet, 0, sizeof(struct nvsp_message));\r\ninit_packet->hdr.msg_type = NVSP_MSG2_TYPE_SEND_NDIS_CONFIG;\r\ninit_packet->msg.v2_msg.send_ndis_config.mtu = net_device->ndev->mtu;\r\ninit_packet->msg.v2_msg.send_ndis_config.capability.ieee8021q = 1;\r\nret = vmbus_sendpacket(device->channel, init_packet,\r\nsizeof(struct nvsp_message),\r\n(unsigned long)init_packet,\r\nVM_PKT_DATA_INBAND, 0);\r\nreturn ret;\r\n}\r\nstatic int netvsc_connect_vsp(struct hv_device *device)\r\n{\r\nint ret;\r\nstruct netvsc_device *net_device;\r\nstruct nvsp_message *init_packet;\r\nint ndis_version;\r\nstruct net_device *ndev;\r\nnet_device = get_outbound_net_device(device);\r\nif (!net_device)\r\nreturn -ENODEV;\r\nndev = net_device->ndev;\r\ninit_packet = &net_device->channel_init_pkt;\r\nif (negotiate_nvsp_ver(device, net_device, init_packet,\r\nNVSP_PROTOCOL_VERSION_2) == 0) {\r\nnet_device->nvsp_version = NVSP_PROTOCOL_VERSION_2;\r\n} else if (negotiate_nvsp_ver(device, net_device, init_packet,\r\nNVSP_PROTOCOL_VERSION_1) == 0) {\r\nnet_device->nvsp_version = NVSP_PROTOCOL_VERSION_1;\r\n} else {\r\nret = -EPROTO;\r\ngoto cleanup;\r\n}\r\npr_debug("Negotiated NVSP version:%x\n", net_device->nvsp_version);\r\nmemset(init_packet, 0, sizeof(struct nvsp_message));\r\nndis_version = 0x00050001;\r\ninit_packet->hdr.msg_type = NVSP_MSG1_TYPE_SEND_NDIS_VER;\r\ninit_packet->msg.v1_msg.\r\nsend_ndis_ver.ndis_major_ver =\r\n(ndis_version & 0xFFFF0000) >> 16;\r\ninit_packet->msg.v1_msg.\r\nsend_ndis_ver.ndis_minor_ver =\r\nndis_version & 0xFFFF;\r\nret = vmbus_sendpacket(device->channel, init_packet,\r\nsizeof(struct nvsp_message),\r\n(unsigned long)init_packet,\r\nVM_PKT_DATA_INBAND, 0);\r\nif (ret != 0)\r\ngoto cleanup;\r\nret = netvsc_init_recv_buf(device);\r\ncleanup:\r\nreturn ret;\r\n}\r\nstatic void netvsc_disconnect_vsp(struct netvsc_device *net_device)\r\n{\r\nnetvsc_destroy_recv_buf(net_device);\r\n}\r\nint netvsc_device_remove(struct hv_device *device)\r\n{\r\nstruct netvsc_device *net_device;\r\nstruct hv_netvsc_packet *netvsc_packet, *pos;\r\nunsigned long flags;\r\nnet_device = hv_get_drvdata(device);\r\nnetvsc_disconnect_vsp(net_device);\r\nspin_lock_irqsave(&device->channel->inbound_lock, flags);\r\nhv_set_drvdata(device, NULL);\r\nspin_unlock_irqrestore(&device->channel->inbound_lock, flags);\r\ndev_notice(&device->device, "net device safe to remove\n");\r\nvmbus_close(device->channel);\r\nlist_for_each_entry_safe(netvsc_packet, pos,\r\n&net_device->recv_pkt_list, list_ent) {\r\nlist_del(&netvsc_packet->list_ent);\r\nkfree(netvsc_packet);\r\n}\r\nkfree(net_device);\r\nreturn 0;\r\n}\r\nstatic inline u32 hv_ringbuf_avail_percent(\r\nstruct hv_ring_buffer_info *ring_info)\r\n{\r\nu32 avail_read, avail_write;\r\nhv_get_ringbuffer_availbytes(ring_info, &avail_read, &avail_write);\r\nreturn avail_write * 100 / ring_info->ring_datasize;\r\n}\r\nstatic void netvsc_send_completion(struct hv_device *device,\r\nstruct vmpacket_descriptor *packet)\r\n{\r\nstruct netvsc_device *net_device;\r\nstruct nvsp_message *nvsp_packet;\r\nstruct hv_netvsc_packet *nvsc_packet;\r\nstruct net_device *ndev;\r\nnet_device = get_inbound_net_device(device);\r\nif (!net_device)\r\nreturn;\r\nndev = net_device->ndev;\r\nnvsp_packet = (struct nvsp_message *)((unsigned long)packet +\r\n(packet->offset8 << 3));\r\nif ((nvsp_packet->hdr.msg_type == NVSP_MSG_TYPE_INIT_COMPLETE) ||\r\n(nvsp_packet->hdr.msg_type ==\r\nNVSP_MSG1_TYPE_SEND_RECV_BUF_COMPLETE) ||\r\n(nvsp_packet->hdr.msg_type ==\r\nNVSP_MSG1_TYPE_SEND_SEND_BUF_COMPLETE)) {\r\nmemcpy(&net_device->channel_init_pkt, nvsp_packet,\r\nsizeof(struct nvsp_message));\r\ncomplete(&net_device->channel_init_wait);\r\n} else if (nvsp_packet->hdr.msg_type ==\r\nNVSP_MSG1_TYPE_SEND_RNDIS_PKT_COMPLETE) {\r\nint num_outstanding_sends;\r\nnvsc_packet = (struct hv_netvsc_packet *)(unsigned long)\r\npacket->trans_id;\r\nif (nvsc_packet)\r\nnvsc_packet->completion.send.send_completion(\r\nnvsc_packet->completion.send.\r\nsend_completion_ctx);\r\nnum_outstanding_sends =\r\natomic_dec_return(&net_device->num_outstanding_sends);\r\nif (net_device->destroy && num_outstanding_sends == 0)\r\nwake_up(&net_device->wait_drain);\r\nif (netif_queue_stopped(ndev) && !net_device->start_remove &&\r\n(hv_ringbuf_avail_percent(&device->channel->outbound)\r\n> RING_AVAIL_PERCENT_HIWATER ||\r\nnum_outstanding_sends < 1))\r\nnetif_wake_queue(ndev);\r\n} else {\r\nnetdev_err(ndev, "Unknown send completion packet type- "\r\n"%d received!!\n", nvsp_packet->hdr.msg_type);\r\n}\r\n}\r\nint netvsc_send(struct hv_device *device,\r\nstruct hv_netvsc_packet *packet)\r\n{\r\nstruct netvsc_device *net_device;\r\nint ret = 0;\r\nstruct nvsp_message sendMessage;\r\nstruct net_device *ndev;\r\nu64 req_id;\r\nnet_device = get_outbound_net_device(device);\r\nif (!net_device)\r\nreturn -ENODEV;\r\nndev = net_device->ndev;\r\nsendMessage.hdr.msg_type = NVSP_MSG1_TYPE_SEND_RNDIS_PKT;\r\nif (packet->is_data_pkt) {\r\nsendMessage.msg.v1_msg.send_rndis_pkt.channel_type = 0;\r\n} else {\r\nsendMessage.msg.v1_msg.send_rndis_pkt.channel_type = 1;\r\n}\r\nsendMessage.msg.v1_msg.send_rndis_pkt.send_buf_section_index =\r\n0xFFFFFFFF;\r\nsendMessage.msg.v1_msg.send_rndis_pkt.send_buf_section_size = 0;\r\nif (packet->completion.send.send_completion)\r\nreq_id = (ulong)packet;\r\nelse\r\nreq_id = 0;\r\nif (packet->page_buf_cnt) {\r\nret = vmbus_sendpacket_pagebuffer(device->channel,\r\npacket->page_buf,\r\npacket->page_buf_cnt,\r\n&sendMessage,\r\nsizeof(struct nvsp_message),\r\nreq_id);\r\n} else {\r\nret = vmbus_sendpacket(device->channel, &sendMessage,\r\nsizeof(struct nvsp_message),\r\nreq_id,\r\nVM_PKT_DATA_INBAND,\r\nVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\r\n}\r\nif (ret == 0) {\r\natomic_inc(&net_device->num_outstanding_sends);\r\nif (hv_ringbuf_avail_percent(&device->channel->outbound) <\r\nRING_AVAIL_PERCENT_LOWATER) {\r\nnetif_stop_queue(ndev);\r\nif (atomic_read(&net_device->\r\nnum_outstanding_sends) < 1)\r\nnetif_wake_queue(ndev);\r\n}\r\n} else if (ret == -EAGAIN) {\r\nnetif_stop_queue(ndev);\r\nif (atomic_read(&net_device->num_outstanding_sends) < 1) {\r\nnetif_wake_queue(ndev);\r\nret = -ENOSPC;\r\n}\r\n} else {\r\nnetdev_err(ndev, "Unable to send packet %p ret %d\n",\r\npacket, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic void netvsc_send_recv_completion(struct hv_device *device,\r\nu64 transaction_id, u32 status)\r\n{\r\nstruct nvsp_message recvcompMessage;\r\nint retries = 0;\r\nint ret;\r\nstruct net_device *ndev;\r\nstruct netvsc_device *net_device = hv_get_drvdata(device);\r\nndev = net_device->ndev;\r\nrecvcompMessage.hdr.msg_type =\r\nNVSP_MSG1_TYPE_SEND_RNDIS_PKT_COMPLETE;\r\nrecvcompMessage.msg.v1_msg.send_rndis_pkt_complete.status = status;\r\nretry_send_cmplt:\r\nret = vmbus_sendpacket(device->channel, &recvcompMessage,\r\nsizeof(struct nvsp_message), transaction_id,\r\nVM_PKT_COMP, 0);\r\nif (ret == 0) {\r\n} else if (ret == -EAGAIN) {\r\nretries++;\r\nnetdev_err(ndev, "unable to send receive completion pkt"\r\n" (tid %llx)...retrying %d\n", transaction_id, retries);\r\nif (retries < 4) {\r\nudelay(100);\r\ngoto retry_send_cmplt;\r\n} else {\r\nnetdev_err(ndev, "unable to send receive "\r\n"completion pkt (tid %llx)...give up retrying\n",\r\ntransaction_id);\r\n}\r\n} else {\r\nnetdev_err(ndev, "unable to send receive "\r\n"completion pkt - %llx\n", transaction_id);\r\n}\r\n}\r\nstatic void netvsc_receive_completion(void *context)\r\n{\r\nstruct hv_netvsc_packet *packet = context;\r\nstruct hv_device *device = packet->device;\r\nstruct netvsc_device *net_device;\r\nu64 transaction_id = 0;\r\nbool fsend_receive_comp = false;\r\nunsigned long flags;\r\nstruct net_device *ndev;\r\nu32 status = NVSP_STAT_NONE;\r\nnet_device = get_inbound_net_device(device);\r\nif (!net_device)\r\nreturn;\r\nndev = net_device->ndev;\r\nspin_lock_irqsave(&net_device->recv_pkt_list_lock, flags);\r\nif (packet->status != NVSP_STAT_SUCCESS)\r\npacket->xfer_page_pkt->status = NVSP_STAT_FAIL;\r\npacket->xfer_page_pkt->count--;\r\nif (packet->xfer_page_pkt->count == 0) {\r\nfsend_receive_comp = true;\r\ntransaction_id = packet->completion.recv.recv_completion_tid;\r\nstatus = packet->xfer_page_pkt->status;\r\nlist_add_tail(&packet->xfer_page_pkt->list_ent,\r\n&net_device->recv_pkt_list);\r\n}\r\nlist_add_tail(&packet->list_ent, &net_device->recv_pkt_list);\r\nspin_unlock_irqrestore(&net_device->recv_pkt_list_lock, flags);\r\nif (fsend_receive_comp)\r\nnetvsc_send_recv_completion(device, transaction_id, status);\r\n}\r\nstatic void netvsc_receive(struct hv_device *device,\r\nstruct vmpacket_descriptor *packet)\r\n{\r\nstruct netvsc_device *net_device;\r\nstruct vmtransfer_page_packet_header *vmxferpage_packet;\r\nstruct nvsp_message *nvsp_packet;\r\nstruct hv_netvsc_packet *netvsc_packet = NULL;\r\nstruct xferpage_packet *xferpage_packet = NULL;\r\nint i;\r\nint count = 0;\r\nunsigned long flags;\r\nstruct net_device *ndev;\r\nLIST_HEAD(listHead);\r\nnet_device = get_inbound_net_device(device);\r\nif (!net_device)\r\nreturn;\r\nndev = net_device->ndev;\r\nif (packet->type != VM_PKT_DATA_USING_XFER_PAGES) {\r\nnetdev_err(ndev, "Unknown packet type received - %d\n",\r\npacket->type);\r\nreturn;\r\n}\r\nnvsp_packet = (struct nvsp_message *)((unsigned long)packet +\r\n(packet->offset8 << 3));\r\nif (nvsp_packet->hdr.msg_type !=\r\nNVSP_MSG1_TYPE_SEND_RNDIS_PKT) {\r\nnetdev_err(ndev, "Unknown nvsp packet type received-"\r\n" %d\n", nvsp_packet->hdr.msg_type);\r\nreturn;\r\n}\r\nvmxferpage_packet = (struct vmtransfer_page_packet_header *)packet;\r\nif (vmxferpage_packet->xfer_pageset_id != NETVSC_RECEIVE_BUFFER_ID) {\r\nnetdev_err(ndev, "Invalid xfer page set id - "\r\n"expecting %x got %x\n", NETVSC_RECEIVE_BUFFER_ID,\r\nvmxferpage_packet->xfer_pageset_id);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&net_device->recv_pkt_list_lock, flags);\r\nwhile (!list_empty(&net_device->recv_pkt_list)) {\r\nlist_move_tail(net_device->recv_pkt_list.next, &listHead);\r\nif (++count == vmxferpage_packet->range_cnt + 1)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&net_device->recv_pkt_list_lock, flags);\r\nif (count < 2) {\r\nnetdev_err(ndev, "Got only %d netvsc pkt...needed "\r\n"%d pkts. Dropping this xfer page packet completely!\n",\r\ncount, vmxferpage_packet->range_cnt + 1);\r\nspin_lock_irqsave(&net_device->recv_pkt_list_lock, flags);\r\nfor (i = count; i != 0; i--) {\r\nlist_move_tail(listHead.next,\r\n&net_device->recv_pkt_list);\r\n}\r\nspin_unlock_irqrestore(&net_device->recv_pkt_list_lock,\r\nflags);\r\nnetvsc_send_recv_completion(device,\r\nvmxferpage_packet->d.trans_id,\r\nNVSP_STAT_FAIL);\r\nreturn;\r\n}\r\nxferpage_packet = (struct xferpage_packet *)listHead.next;\r\nlist_del(&xferpage_packet->list_ent);\r\nxferpage_packet->status = NVSP_STAT_SUCCESS;\r\nxferpage_packet->count = count - 1;\r\nif (xferpage_packet->count != vmxferpage_packet->range_cnt) {\r\nnetdev_err(ndev, "Needed %d netvsc pkts to satisfy "\r\n"this xfer page...got %d\n",\r\nvmxferpage_packet->range_cnt, xferpage_packet->count);\r\n}\r\nfor (i = 0; i < (count - 1); i++) {\r\nnetvsc_packet = (struct hv_netvsc_packet *)listHead.next;\r\nlist_del(&netvsc_packet->list_ent);\r\nnetvsc_packet->status = NVSP_STAT_SUCCESS;\r\nnetvsc_packet->xfer_page_pkt = xferpage_packet;\r\nnetvsc_packet->completion.recv.recv_completion =\r\nnetvsc_receive_completion;\r\nnetvsc_packet->completion.recv.recv_completion_ctx =\r\nnetvsc_packet;\r\nnetvsc_packet->device = device;\r\nnetvsc_packet->completion.recv.recv_completion_tid =\r\nvmxferpage_packet->d.trans_id;\r\nnetvsc_packet->data = (void *)((unsigned long)net_device->\r\nrecv_buf + vmxferpage_packet->ranges[i].byte_offset);\r\nnetvsc_packet->total_data_buflen =\r\nvmxferpage_packet->ranges[i].byte_count;\r\nrndis_filter_receive(device, netvsc_packet);\r\nnetvsc_receive_completion(netvsc_packet->\r\ncompletion.recv.recv_completion_ctx);\r\n}\r\n}\r\nstatic void netvsc_channel_cb(void *context)\r\n{\r\nint ret;\r\nstruct hv_device *device = context;\r\nstruct netvsc_device *net_device;\r\nu32 bytes_recvd;\r\nu64 request_id;\r\nunsigned char *packet;\r\nstruct vmpacket_descriptor *desc;\r\nunsigned char *buffer;\r\nint bufferlen = NETVSC_PACKET_SIZE;\r\nstruct net_device *ndev;\r\npacket = kzalloc(NETVSC_PACKET_SIZE * sizeof(unsigned char),\r\nGFP_ATOMIC);\r\nif (!packet)\r\nreturn;\r\nbuffer = packet;\r\nnet_device = get_inbound_net_device(device);\r\nif (!net_device)\r\ngoto out;\r\nndev = net_device->ndev;\r\ndo {\r\nret = vmbus_recvpacket_raw(device->channel, buffer, bufferlen,\r\n&bytes_recvd, &request_id);\r\nif (ret == 0) {\r\nif (bytes_recvd > 0) {\r\ndesc = (struct vmpacket_descriptor *)buffer;\r\nswitch (desc->type) {\r\ncase VM_PKT_COMP:\r\nnetvsc_send_completion(device, desc);\r\nbreak;\r\ncase VM_PKT_DATA_USING_XFER_PAGES:\r\nnetvsc_receive(device, desc);\r\nbreak;\r\ndefault:\r\nnetdev_err(ndev,\r\n"unhandled packet type %d, "\r\n"tid %llx len %d\n",\r\ndesc->type, request_id,\r\nbytes_recvd);\r\nbreak;\r\n}\r\nif (bufferlen > NETVSC_PACKET_SIZE) {\r\nkfree(buffer);\r\nbuffer = packet;\r\nbufferlen = NETVSC_PACKET_SIZE;\r\n}\r\n} else {\r\nif (bufferlen > NETVSC_PACKET_SIZE) {\r\nkfree(buffer);\r\nbuffer = packet;\r\nbufferlen = NETVSC_PACKET_SIZE;\r\n}\r\nbreak;\r\n}\r\n} else if (ret == -ENOBUFS) {\r\nbuffer = kmalloc(bytes_recvd, GFP_ATOMIC);\r\nif (buffer == NULL) {\r\nnetdev_err(ndev,\r\n"unable to allocate buffer of size "\r\n"(%d)!!\n", bytes_recvd);\r\nbreak;\r\n}\r\nbufferlen = bytes_recvd;\r\n}\r\n} while (1);\r\nout:\r\nkfree(buffer);\r\nreturn;\r\n}\r\nint netvsc_device_add(struct hv_device *device, void *additional_info)\r\n{\r\nint ret = 0;\r\nint i;\r\nint ring_size =\r\n((struct netvsc_device_info *)additional_info)->ring_size;\r\nstruct netvsc_device *net_device;\r\nstruct hv_netvsc_packet *packet, *pos;\r\nstruct net_device *ndev;\r\nnet_device = alloc_net_device(device);\r\nif (!net_device) {\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nndev = net_device->ndev;\r\nnet_device->recv_buf_size = NETVSC_RECEIVE_BUFFER_SIZE;\r\nspin_lock_init(&net_device->recv_pkt_list_lock);\r\nINIT_LIST_HEAD(&net_device->recv_pkt_list);\r\nfor (i = 0; i < NETVSC_RECEIVE_PACKETLIST_COUNT; i++) {\r\npacket = kzalloc(sizeof(struct hv_netvsc_packet), GFP_KERNEL);\r\nif (!packet)\r\nbreak;\r\nlist_add_tail(&packet->list_ent,\r\n&net_device->recv_pkt_list);\r\n}\r\ninit_completion(&net_device->channel_init_wait);\r\nret = vmbus_open(device->channel, ring_size * PAGE_SIZE,\r\nring_size * PAGE_SIZE, NULL, 0,\r\nnetvsc_channel_cb, device);\r\nif (ret != 0) {\r\nnetdev_err(ndev, "unable to open channel: %d\n", ret);\r\ngoto cleanup;\r\n}\r\npr_info("hv_netvsc channel opened successfully\n");\r\nret = netvsc_connect_vsp(device);\r\nif (ret != 0) {\r\nnetdev_err(ndev,\r\n"unable to connect to NetVSP - %d\n", ret);\r\ngoto close;\r\n}\r\nreturn ret;\r\nclose:\r\nvmbus_close(device->channel);\r\ncleanup:\r\nif (net_device) {\r\nlist_for_each_entry_safe(packet, pos,\r\n&net_device->recv_pkt_list,\r\nlist_ent) {\r\nlist_del(&packet->list_ent);\r\nkfree(packet);\r\n}\r\nkfree(net_device);\r\n}\r\nreturn ret;\r\n}
