void closure_queue(struct closure *cl)\r\n{\r\nstruct workqueue_struct *wq = cl->wq;\r\nif (wq) {\r\nINIT_WORK(&cl->work, cl->work.func);\r\nBUG_ON(!queue_work(wq, &cl->work));\r\n} else\r\ncl->fn(cl);\r\n}\r\nstatic struct closure_waitlist *closure_waitlist(struct closure *cl)\r\n{\r\nswitch (cl->type) {\r\nCL_FIELD(closure_with_waitlist, wait);\r\nCL_FIELD(closure_with_waitlist_and_timer, wait);\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic struct timer_list *closure_timer(struct closure *cl)\r\n{\r\nswitch (cl->type) {\r\nCL_FIELD(closure_with_timer, timer);\r\nCL_FIELD(closure_with_waitlist_and_timer, timer);\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic inline void closure_put_after_sub(struct closure *cl, int flags)\r\n{\r\nint r = flags & CLOSURE_REMAINING_MASK;\r\nBUG_ON(flags & CLOSURE_GUARD_MASK);\r\nBUG_ON(!r && (flags & ~(CLOSURE_DESTRUCTOR|CLOSURE_BLOCKING)));\r\nif (r == 1 && (flags & CLOSURE_SLEEPING))\r\nwake_up_process(cl->task);\r\nif (!r) {\r\nif (cl->fn && !(flags & CLOSURE_DESTRUCTOR)) {\r\natomic_set(&cl->remaining,\r\nCLOSURE_REMAINING_INITIALIZER);\r\nclosure_queue(cl);\r\n} else {\r\nstruct closure *parent = cl->parent;\r\nstruct closure_waitlist *wait = closure_waitlist(cl);\r\nclosure_fn *destructor = cl->fn;\r\nclosure_debug_destroy(cl);\r\nsmp_mb();\r\natomic_set(&cl->remaining, -1);\r\nif (wait)\r\nclosure_wake_up(wait);\r\nif (destructor)\r\ndestructor(cl);\r\nif (parent)\r\nclosure_put(parent);\r\n}\r\n}\r\n}\r\nvoid closure_sub(struct closure *cl, int v)\r\n{\r\nclosure_put_after_sub(cl, atomic_sub_return(v, &cl->remaining));\r\n}\r\nvoid closure_put(struct closure *cl)\r\n{\r\nclosure_put_after_sub(cl, atomic_dec_return(&cl->remaining));\r\n}\r\nstatic void set_waiting(struct closure *cl, unsigned long f)\r\n{\r\n#ifdef CONFIG_BCACHE_CLOSURES_DEBUG\r\ncl->waiting_on = f;\r\n#endif\r\n}\r\nvoid __closure_wake_up(struct closure_waitlist *wait_list)\r\n{\r\nstruct llist_node *list;\r\nstruct closure *cl;\r\nstruct llist_node *reverse = NULL;\r\nlist = llist_del_all(&wait_list->list);\r\nwhile (list) {\r\nstruct llist_node *t = list;\r\nlist = llist_next(list);\r\nt->next = reverse;\r\nreverse = t;\r\n}\r\nwhile (reverse) {\r\ncl = container_of(reverse, struct closure, list);\r\nreverse = llist_next(reverse);\r\nset_waiting(cl, 0);\r\nclosure_sub(cl, CLOSURE_WAITING + 1);\r\n}\r\n}\r\nbool closure_wait(struct closure_waitlist *list, struct closure *cl)\r\n{\r\nif (atomic_read(&cl->remaining) & CLOSURE_WAITING)\r\nreturn false;\r\nset_waiting(cl, _RET_IP_);\r\natomic_add(CLOSURE_WAITING + 1, &cl->remaining);\r\nllist_add(&cl->list, &list->list);\r\nreturn true;\r\n}\r\nvoid closure_sync(struct closure *cl)\r\n{\r\nwhile (1) {\r\n__closure_start_sleep(cl);\r\nclosure_set_ret_ip(cl);\r\nif ((atomic_read(&cl->remaining) &\r\nCLOSURE_REMAINING_MASK) == 1)\r\nbreak;\r\nschedule();\r\n}\r\n__closure_end_sleep(cl);\r\n}\r\nbool closure_trylock(struct closure *cl, struct closure *parent)\r\n{\r\nif (atomic_cmpxchg(&cl->remaining, -1,\r\nCLOSURE_REMAINING_INITIALIZER) != -1)\r\nreturn false;\r\nclosure_set_ret_ip(cl);\r\nsmp_mb();\r\ncl->parent = parent;\r\nif (parent)\r\nclosure_get(parent);\r\nclosure_debug_create(cl);\r\nreturn true;\r\n}\r\nvoid __closure_lock(struct closure *cl, struct closure *parent,\r\nstruct closure_waitlist *wait_list)\r\n{\r\nstruct closure wait;\r\nclosure_init_stack(&wait);\r\nwhile (1) {\r\nif (closure_trylock(cl, parent))\r\nreturn;\r\nclosure_wait_event_sync(wait_list, &wait,\r\natomic_read(&cl->remaining) == -1);\r\n}\r\n}\r\nstatic void closure_delay_timer_fn(unsigned long data)\r\n{\r\nstruct closure *cl = (struct closure *) data;\r\nclosure_sub(cl, CLOSURE_TIMER + 1);\r\n}\r\nvoid do_closure_timer_init(struct closure *cl)\r\n{\r\nstruct timer_list *timer = closure_timer(cl);\r\ninit_timer(timer);\r\ntimer->data = (unsigned long) cl;\r\ntimer->function = closure_delay_timer_fn;\r\n}\r\nbool __closure_delay(struct closure *cl, unsigned long delay,\r\nstruct timer_list *timer)\r\n{\r\nif (atomic_read(&cl->remaining) & CLOSURE_TIMER)\r\nreturn false;\r\nBUG_ON(timer_pending(timer));\r\ntimer->expires = jiffies + delay;\r\natomic_add(CLOSURE_TIMER + 1, &cl->remaining);\r\nadd_timer(timer);\r\nreturn true;\r\n}\r\nvoid __closure_flush(struct closure *cl, struct timer_list *timer)\r\n{\r\nif (del_timer(timer))\r\nclosure_sub(cl, CLOSURE_TIMER + 1);\r\n}\r\nvoid __closure_flush_sync(struct closure *cl, struct timer_list *timer)\r\n{\r\nif (del_timer_sync(timer))\r\nclosure_sub(cl, CLOSURE_TIMER + 1);\r\n}\r\nvoid closure_debug_create(struct closure *cl)\r\n{\r\nunsigned long flags;\r\nBUG_ON(cl->magic == CLOSURE_MAGIC_ALIVE);\r\ncl->magic = CLOSURE_MAGIC_ALIVE;\r\nspin_lock_irqsave(&closure_list_lock, flags);\r\nlist_add(&cl->all, &closure_list);\r\nspin_unlock_irqrestore(&closure_list_lock, flags);\r\n}\r\nvoid closure_debug_destroy(struct closure *cl)\r\n{\r\nunsigned long flags;\r\nBUG_ON(cl->magic != CLOSURE_MAGIC_ALIVE);\r\ncl->magic = CLOSURE_MAGIC_DEAD;\r\nspin_lock_irqsave(&closure_list_lock, flags);\r\nlist_del(&cl->all);\r\nspin_unlock_irqrestore(&closure_list_lock, flags);\r\n}\r\nstatic int debug_seq_show(struct seq_file *f, void *data)\r\n{\r\nstruct closure *cl;\r\nspin_lock_irq(&closure_list_lock);\r\nlist_for_each_entry(cl, &closure_list, all) {\r\nint r = atomic_read(&cl->remaining);\r\nseq_printf(f, "%p: %pF -> %pf p %p r %i ",\r\ncl, (void *) cl->ip, cl->fn, cl->parent,\r\nr & CLOSURE_REMAINING_MASK);\r\nseq_printf(f, "%s%s%s%s%s%s\n",\r\ntest_bit(WORK_STRUCT_PENDING,\r\nwork_data_bits(&cl->work)) ? "Q" : "",\r\nr & CLOSURE_RUNNING ? "R" : "",\r\nr & CLOSURE_BLOCKING ? "B" : "",\r\nr & CLOSURE_STACK ? "S" : "",\r\nr & CLOSURE_SLEEPING ? "Sl" : "",\r\nr & CLOSURE_TIMER ? "T" : "");\r\nif (r & CLOSURE_WAITING)\r\nseq_printf(f, " W %pF\n",\r\n(void *) cl->waiting_on);\r\nseq_printf(f, "\n");\r\n}\r\nspin_unlock_irq(&closure_list_lock);\r\nreturn 0;\r\n}\r\nstatic int debug_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, debug_seq_show, NULL);\r\n}\r\nvoid __init closure_debug_init(void)\r\n{\r\ndebug = debugfs_create_file("closures", 0400, NULL, NULL, &debug_ops);\r\n}
