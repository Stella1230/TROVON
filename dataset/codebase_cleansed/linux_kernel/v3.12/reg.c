static const struct ieee80211_regdomain *get_cfg80211_regdom(void)\r\n{\r\nreturn rtnl_dereference(cfg80211_regdomain);\r\n}\r\nstatic const struct ieee80211_regdomain *get_wiphy_regdom(struct wiphy *wiphy)\r\n{\r\nreturn rtnl_dereference(wiphy->regd);\r\n}\r\nstatic void rcu_free_regdom(const struct ieee80211_regdomain *r)\r\n{\r\nif (!r)\r\nreturn;\r\nkfree_rcu((struct ieee80211_regdomain *)r, rcu_head);\r\n}\r\nstatic struct regulatory_request *get_last_request(void)\r\n{\r\nreturn rcu_dereference_rtnl(last_request);\r\n}\r\nstatic void reset_regdomains(bool full_reset,\r\nconst struct ieee80211_regdomain *new_regdom)\r\n{\r\nconst struct ieee80211_regdomain *r;\r\nstruct regulatory_request *lr;\r\nASSERT_RTNL();\r\nr = get_cfg80211_regdom();\r\nif (r == cfg80211_world_regdom)\r\nr = NULL;\r\nif (cfg80211_world_regdom == &world_regdom)\r\ncfg80211_world_regdom = NULL;\r\nif (r == &world_regdom)\r\nr = NULL;\r\nrcu_free_regdom(r);\r\nrcu_free_regdom(cfg80211_world_regdom);\r\ncfg80211_world_regdom = &world_regdom;\r\nrcu_assign_pointer(cfg80211_regdomain, new_regdom);\r\nif (!full_reset)\r\nreturn;\r\nlr = get_last_request();\r\nif (lr != &core_request_world && lr)\r\nkfree_rcu(lr, rcu_head);\r\nrcu_assign_pointer(last_request, &core_request_world);\r\n}\r\nstatic void update_world_regdomain(const struct ieee80211_regdomain *rd)\r\n{\r\nstruct regulatory_request *lr;\r\nlr = get_last_request();\r\nWARN_ON(!lr);\r\nreset_regdomains(false, rd);\r\ncfg80211_world_regdom = rd;\r\n}\r\nbool is_world_regdom(const char *alpha2)\r\n{\r\nif (!alpha2)\r\nreturn false;\r\nreturn alpha2[0] == '0' && alpha2[1] == '0';\r\n}\r\nstatic bool is_alpha2_set(const char *alpha2)\r\n{\r\nif (!alpha2)\r\nreturn false;\r\nreturn alpha2[0] && alpha2[1];\r\n}\r\nstatic bool is_unknown_alpha2(const char *alpha2)\r\n{\r\nif (!alpha2)\r\nreturn false;\r\nreturn alpha2[0] == '9' && alpha2[1] == '9';\r\n}\r\nstatic bool is_intersected_alpha2(const char *alpha2)\r\n{\r\nif (!alpha2)\r\nreturn false;\r\nreturn alpha2[0] == '9' && alpha2[1] == '8';\r\n}\r\nstatic bool is_an_alpha2(const char *alpha2)\r\n{\r\nif (!alpha2)\r\nreturn false;\r\nreturn isalpha(alpha2[0]) && isalpha(alpha2[1]);\r\n}\r\nstatic bool alpha2_equal(const char *alpha2_x, const char *alpha2_y)\r\n{\r\nif (!alpha2_x || !alpha2_y)\r\nreturn false;\r\nreturn alpha2_x[0] == alpha2_y[0] && alpha2_x[1] == alpha2_y[1];\r\n}\r\nstatic bool regdom_changes(const char *alpha2)\r\n{\r\nconst struct ieee80211_regdomain *r = get_cfg80211_regdom();\r\nif (!r)\r\nreturn true;\r\nreturn !alpha2_equal(r->alpha2, alpha2);\r\n}\r\nstatic bool is_user_regdom_saved(void)\r\n{\r\nif (user_alpha2[0] == '9' && user_alpha2[1] == '7')\r\nreturn false;\r\nif (WARN(!is_world_regdom(user_alpha2) && !is_an_alpha2(user_alpha2),\r\n"Unexpected user alpha2: %c%c\n",\r\nuser_alpha2[0], user_alpha2[1]))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic const struct ieee80211_regdomain *\r\nreg_copy_regd(const struct ieee80211_regdomain *src_regd)\r\n{\r\nstruct ieee80211_regdomain *regd;\r\nint size_of_regd;\r\nunsigned int i;\r\nsize_of_regd =\r\nsizeof(struct ieee80211_regdomain) +\r\nsrc_regd->n_reg_rules * sizeof(struct ieee80211_reg_rule);\r\nregd = kzalloc(size_of_regd, GFP_KERNEL);\r\nif (!regd)\r\nreturn ERR_PTR(-ENOMEM);\r\nmemcpy(regd, src_regd, sizeof(struct ieee80211_regdomain));\r\nfor (i = 0; i < src_regd->n_reg_rules; i++)\r\nmemcpy(&regd->reg_rules[i], &src_regd->reg_rules[i],\r\nsizeof(struct ieee80211_reg_rule));\r\nreturn regd;\r\n}\r\nstatic void reg_regdb_search(struct work_struct *work)\r\n{\r\nstruct reg_regdb_search_request *request;\r\nconst struct ieee80211_regdomain *curdom, *regdom = NULL;\r\nint i;\r\nrtnl_lock();\r\nmutex_lock(&reg_regdb_search_mutex);\r\nwhile (!list_empty(&reg_regdb_search_list)) {\r\nrequest = list_first_entry(&reg_regdb_search_list,\r\nstruct reg_regdb_search_request,\r\nlist);\r\nlist_del(&request->list);\r\nfor (i = 0; i < reg_regdb_size; i++) {\r\ncurdom = reg_regdb[i];\r\nif (alpha2_equal(request->alpha2, curdom->alpha2)) {\r\nregdom = reg_copy_regd(curdom);\r\nbreak;\r\n}\r\n}\r\nkfree(request);\r\n}\r\nmutex_unlock(&reg_regdb_search_mutex);\r\nif (!IS_ERR_OR_NULL(regdom))\r\nset_regdom(regdom);\r\nrtnl_unlock();\r\n}\r\nstatic void reg_regdb_query(const char *alpha2)\r\n{\r\nstruct reg_regdb_search_request *request;\r\nif (!alpha2)\r\nreturn;\r\nrequest = kzalloc(sizeof(struct reg_regdb_search_request), GFP_KERNEL);\r\nif (!request)\r\nreturn;\r\nmemcpy(request->alpha2, alpha2, 2);\r\nmutex_lock(&reg_regdb_search_mutex);\r\nlist_add_tail(&request->list, &reg_regdb_search_list);\r\nmutex_unlock(&reg_regdb_search_mutex);\r\nschedule_work(&reg_regdb_work);\r\n}\r\nstatic void reg_regdb_size_check(void)\r\n{\r\nWARN_ONCE(!reg_regdb_size, "db.txt is empty, you should update it...");\r\n}\r\nstatic inline void reg_regdb_size_check(void) {}\r\nstatic inline void reg_regdb_query(const char *alpha2) {}\r\nstatic int call_crda(const char *alpha2)\r\n{\r\nif (!is_world_regdom((char *) alpha2))\r\npr_info("Calling CRDA for country: %c%c\n",\r\nalpha2[0], alpha2[1]);\r\nelse\r\npr_info("Calling CRDA to update world regulatory domain\n");\r\nreg_regdb_query(alpha2);\r\nreturn kobject_uevent(&reg_pdev->dev.kobj, KOBJ_CHANGE);\r\n}\r\nstatic bool reg_is_valid_request(const char *alpha2)\r\n{\r\nstruct regulatory_request *lr = get_last_request();\r\nif (!lr || lr->processed)\r\nreturn false;\r\nreturn alpha2_equal(lr->alpha2, alpha2);\r\n}\r\nstatic bool is_valid_reg_rule(const struct ieee80211_reg_rule *rule)\r\n{\r\nconst struct ieee80211_freq_range *freq_range = &rule->freq_range;\r\nu32 freq_diff;\r\nif (freq_range->start_freq_khz <= 0 || freq_range->end_freq_khz <= 0)\r\nreturn false;\r\nif (freq_range->start_freq_khz > freq_range->end_freq_khz)\r\nreturn false;\r\nfreq_diff = freq_range->end_freq_khz - freq_range->start_freq_khz;\r\nif (freq_range->end_freq_khz <= freq_range->start_freq_khz ||\r\nfreq_range->max_bandwidth_khz > freq_diff)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool is_valid_rd(const struct ieee80211_regdomain *rd)\r\n{\r\nconst struct ieee80211_reg_rule *reg_rule = NULL;\r\nunsigned int i;\r\nif (!rd->n_reg_rules)\r\nreturn false;\r\nif (WARN_ON(rd->n_reg_rules > NL80211_MAX_SUPP_REG_RULES))\r\nreturn false;\r\nfor (i = 0; i < rd->n_reg_rules; i++) {\r\nreg_rule = &rd->reg_rules[i];\r\nif (!is_valid_reg_rule(reg_rule))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool reg_does_bw_fit(const struct ieee80211_freq_range *freq_range,\r\nu32 center_freq_khz, u32 bw_khz)\r\n{\r\nu32 start_freq_khz, end_freq_khz;\r\nstart_freq_khz = center_freq_khz - (bw_khz/2);\r\nend_freq_khz = center_freq_khz + (bw_khz/2);\r\nif (start_freq_khz >= freq_range->start_freq_khz &&\r\nend_freq_khz <= freq_range->end_freq_khz)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool freq_in_rule_band(const struct ieee80211_freq_range *freq_range,\r\nu32 freq_khz)\r\n{\r\n#define ONE_GHZ_IN_KHZ 1000000\r\nu32 limit = freq_khz > 45 * ONE_GHZ_IN_KHZ ?\r\n10 * ONE_GHZ_IN_KHZ : 2 * ONE_GHZ_IN_KHZ;\r\nif (abs(freq_khz - freq_range->start_freq_khz) <= limit)\r\nreturn true;\r\nif (abs(freq_khz - freq_range->end_freq_khz) <= limit)\r\nreturn true;\r\nreturn false;\r\n#undef ONE_GHZ_IN_KHZ\r\n}\r\nstatic int reg_rules_intersect(const struct ieee80211_reg_rule *rule1,\r\nconst struct ieee80211_reg_rule *rule2,\r\nstruct ieee80211_reg_rule *intersected_rule)\r\n{\r\nconst struct ieee80211_freq_range *freq_range1, *freq_range2;\r\nstruct ieee80211_freq_range *freq_range;\r\nconst struct ieee80211_power_rule *power_rule1, *power_rule2;\r\nstruct ieee80211_power_rule *power_rule;\r\nu32 freq_diff;\r\nfreq_range1 = &rule1->freq_range;\r\nfreq_range2 = &rule2->freq_range;\r\nfreq_range = &intersected_rule->freq_range;\r\npower_rule1 = &rule1->power_rule;\r\npower_rule2 = &rule2->power_rule;\r\npower_rule = &intersected_rule->power_rule;\r\nfreq_range->start_freq_khz = max(freq_range1->start_freq_khz,\r\nfreq_range2->start_freq_khz);\r\nfreq_range->end_freq_khz = min(freq_range1->end_freq_khz,\r\nfreq_range2->end_freq_khz);\r\nfreq_range->max_bandwidth_khz = min(freq_range1->max_bandwidth_khz,\r\nfreq_range2->max_bandwidth_khz);\r\nfreq_diff = freq_range->end_freq_khz - freq_range->start_freq_khz;\r\nif (freq_range->max_bandwidth_khz > freq_diff)\r\nfreq_range->max_bandwidth_khz = freq_diff;\r\npower_rule->max_eirp = min(power_rule1->max_eirp,\r\npower_rule2->max_eirp);\r\npower_rule->max_antenna_gain = min(power_rule1->max_antenna_gain,\r\npower_rule2->max_antenna_gain);\r\nintersected_rule->flags = rule1->flags | rule2->flags;\r\nif (!is_valid_reg_rule(intersected_rule))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic struct ieee80211_regdomain *\r\nregdom_intersect(const struct ieee80211_regdomain *rd1,\r\nconst struct ieee80211_regdomain *rd2)\r\n{\r\nint r, size_of_regd;\r\nunsigned int x, y;\r\nunsigned int num_rules = 0, rule_idx = 0;\r\nconst struct ieee80211_reg_rule *rule1, *rule2;\r\nstruct ieee80211_reg_rule *intersected_rule;\r\nstruct ieee80211_regdomain *rd;\r\nstruct ieee80211_reg_rule dummy_rule;\r\nif (!rd1 || !rd2)\r\nreturn NULL;\r\nfor (x = 0; x < rd1->n_reg_rules; x++) {\r\nrule1 = &rd1->reg_rules[x];\r\nfor (y = 0; y < rd2->n_reg_rules; y++) {\r\nrule2 = &rd2->reg_rules[y];\r\nif (!reg_rules_intersect(rule1, rule2, &dummy_rule))\r\nnum_rules++;\r\n}\r\n}\r\nif (!num_rules)\r\nreturn NULL;\r\nsize_of_regd = sizeof(struct ieee80211_regdomain) +\r\nnum_rules * sizeof(struct ieee80211_reg_rule);\r\nrd = kzalloc(size_of_regd, GFP_KERNEL);\r\nif (!rd)\r\nreturn NULL;\r\nfor (x = 0; x < rd1->n_reg_rules && rule_idx < num_rules; x++) {\r\nrule1 = &rd1->reg_rules[x];\r\nfor (y = 0; y < rd2->n_reg_rules && rule_idx < num_rules; y++) {\r\nrule2 = &rd2->reg_rules[y];\r\nintersected_rule = &rd->reg_rules[rule_idx];\r\nr = reg_rules_intersect(rule1, rule2, intersected_rule);\r\nif (r)\r\ncontinue;\r\nrule_idx++;\r\n}\r\n}\r\nif (rule_idx != num_rules) {\r\nkfree(rd);\r\nreturn NULL;\r\n}\r\nrd->n_reg_rules = num_rules;\r\nrd->alpha2[0] = '9';\r\nrd->alpha2[1] = '8';\r\nreturn rd;\r\n}\r\nstatic u32 map_regdom_flags(u32 rd_flags)\r\n{\r\nu32 channel_flags = 0;\r\nif (rd_flags & NL80211_RRF_PASSIVE_SCAN)\r\nchannel_flags |= IEEE80211_CHAN_PASSIVE_SCAN;\r\nif (rd_flags & NL80211_RRF_NO_IBSS)\r\nchannel_flags |= IEEE80211_CHAN_NO_IBSS;\r\nif (rd_flags & NL80211_RRF_DFS)\r\nchannel_flags |= IEEE80211_CHAN_RADAR;\r\nif (rd_flags & NL80211_RRF_NO_OFDM)\r\nchannel_flags |= IEEE80211_CHAN_NO_OFDM;\r\nreturn channel_flags;\r\n}\r\nstatic const struct ieee80211_reg_rule *\r\nfreq_reg_info_regd(struct wiphy *wiphy, u32 center_freq,\r\nconst struct ieee80211_regdomain *regd)\r\n{\r\nint i;\r\nbool band_rule_found = false;\r\nbool bw_fits = false;\r\nif (!regd)\r\nreturn ERR_PTR(-EINVAL);\r\nfor (i = 0; i < regd->n_reg_rules; i++) {\r\nconst struct ieee80211_reg_rule *rr;\r\nconst struct ieee80211_freq_range *fr = NULL;\r\nrr = &regd->reg_rules[i];\r\nfr = &rr->freq_range;\r\nif (!band_rule_found)\r\nband_rule_found = freq_in_rule_band(fr, center_freq);\r\nbw_fits = reg_does_bw_fit(fr, center_freq, MHZ_TO_KHZ(20));\r\nif (band_rule_found && bw_fits)\r\nreturn rr;\r\n}\r\nif (!band_rule_found)\r\nreturn ERR_PTR(-ERANGE);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nconst struct ieee80211_reg_rule *freq_reg_info(struct wiphy *wiphy,\r\nu32 center_freq)\r\n{\r\nconst struct ieee80211_regdomain *regd;\r\nstruct regulatory_request *lr = get_last_request();\r\nif (lr->initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE &&\r\nlr->initiator != NL80211_REGDOM_SET_BY_USER &&\r\nwiphy->regd)\r\nregd = get_wiphy_regdom(wiphy);\r\nelse\r\nregd = get_cfg80211_regdom();\r\nreturn freq_reg_info_regd(wiphy, center_freq, regd);\r\n}\r\nstatic const char *reg_initiator_name(enum nl80211_reg_initiator initiator)\r\n{\r\nswitch (initiator) {\r\ncase NL80211_REGDOM_SET_BY_CORE:\r\nreturn "Set by core";\r\ncase NL80211_REGDOM_SET_BY_USER:\r\nreturn "Set by user";\r\ncase NL80211_REGDOM_SET_BY_DRIVER:\r\nreturn "Set by driver";\r\ncase NL80211_REGDOM_SET_BY_COUNTRY_IE:\r\nreturn "Set by country IE";\r\ndefault:\r\nWARN_ON(1);\r\nreturn "Set by bug";\r\n}\r\n}\r\nstatic void chan_reg_rule_print_dbg(struct ieee80211_channel *chan,\r\nconst struct ieee80211_reg_rule *reg_rule)\r\n{\r\nconst struct ieee80211_power_rule *power_rule;\r\nconst struct ieee80211_freq_range *freq_range;\r\nchar max_antenna_gain[32];\r\npower_rule = &reg_rule->power_rule;\r\nfreq_range = &reg_rule->freq_range;\r\nif (!power_rule->max_antenna_gain)\r\nsnprintf(max_antenna_gain, 32, "N/A");\r\nelse\r\nsnprintf(max_antenna_gain, 32, "%d", power_rule->max_antenna_gain);\r\nREG_DBG_PRINT("Updating information on frequency %d MHz with regulatory rule:\n",\r\nchan->center_freq);\r\nREG_DBG_PRINT("%d KHz - %d KHz @ %d KHz), (%s mBi, %d mBm)\n",\r\nfreq_range->start_freq_khz, freq_range->end_freq_khz,\r\nfreq_range->max_bandwidth_khz, max_antenna_gain,\r\npower_rule->max_eirp);\r\n}\r\nstatic void chan_reg_rule_print_dbg(struct ieee80211_channel *chan,\r\nconst struct ieee80211_reg_rule *reg_rule)\r\n{\r\nreturn;\r\n}\r\nstatic void handle_channel(struct wiphy *wiphy,\r\nenum nl80211_reg_initiator initiator,\r\nstruct ieee80211_channel *chan)\r\n{\r\nu32 flags, bw_flags = 0;\r\nconst struct ieee80211_reg_rule *reg_rule = NULL;\r\nconst struct ieee80211_power_rule *power_rule = NULL;\r\nconst struct ieee80211_freq_range *freq_range = NULL;\r\nstruct wiphy *request_wiphy = NULL;\r\nstruct regulatory_request *lr = get_last_request();\r\nrequest_wiphy = wiphy_idx_to_wiphy(lr->wiphy_idx);\r\nflags = chan->orig_flags;\r\nreg_rule = freq_reg_info(wiphy, MHZ_TO_KHZ(chan->center_freq));\r\nif (IS_ERR(reg_rule)) {\r\nif (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE &&\r\nPTR_ERR(reg_rule) == -ERANGE)\r\nreturn;\r\nREG_DBG_PRINT("Disabling freq %d MHz\n", chan->center_freq);\r\nchan->flags |= IEEE80211_CHAN_DISABLED;\r\nreturn;\r\n}\r\nchan_reg_rule_print_dbg(chan, reg_rule);\r\npower_rule = &reg_rule->power_rule;\r\nfreq_range = &reg_rule->freq_range;\r\nif (freq_range->max_bandwidth_khz < MHZ_TO_KHZ(40))\r\nbw_flags = IEEE80211_CHAN_NO_HT40;\r\nif (freq_range->max_bandwidth_khz < MHZ_TO_KHZ(80))\r\nbw_flags |= IEEE80211_CHAN_NO_80MHZ;\r\nif (freq_range->max_bandwidth_khz < MHZ_TO_KHZ(160))\r\nbw_flags |= IEEE80211_CHAN_NO_160MHZ;\r\nif (lr->initiator == NL80211_REGDOM_SET_BY_DRIVER &&\r\nrequest_wiphy && request_wiphy == wiphy &&\r\nrequest_wiphy->flags & WIPHY_FLAG_STRICT_REGULATORY) {\r\nchan->flags = chan->orig_flags =\r\nmap_regdom_flags(reg_rule->flags) | bw_flags;\r\nchan->max_antenna_gain = chan->orig_mag =\r\n(int) MBI_TO_DBI(power_rule->max_antenna_gain);\r\nchan->max_reg_power = chan->max_power = chan->orig_mpwr =\r\n(int) MBM_TO_DBM(power_rule->max_eirp);\r\nreturn;\r\n}\r\nchan->dfs_state = NL80211_DFS_USABLE;\r\nchan->dfs_state_entered = jiffies;\r\nchan->beacon_found = false;\r\nchan->flags = flags | bw_flags | map_regdom_flags(reg_rule->flags);\r\nchan->max_antenna_gain =\r\nmin_t(int, chan->orig_mag,\r\nMBI_TO_DBI(power_rule->max_antenna_gain));\r\nchan->max_reg_power = (int) MBM_TO_DBM(power_rule->max_eirp);\r\nif (chan->orig_mpwr) {\r\nif (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE &&\r\nwiphy->flags & WIPHY_FLAG_CUSTOM_REGULATORY &&\r\nwiphy->flags & WIPHY_FLAG_STRICT_REGULATORY)\r\nchan->max_power = chan->max_reg_power;\r\nelse\r\nchan->max_power = min(chan->orig_mpwr,\r\nchan->max_reg_power);\r\n} else\r\nchan->max_power = chan->max_reg_power;\r\n}\r\nstatic void handle_band(struct wiphy *wiphy,\r\nenum nl80211_reg_initiator initiator,\r\nstruct ieee80211_supported_band *sband)\r\n{\r\nunsigned int i;\r\nif (!sband)\r\nreturn;\r\nfor (i = 0; i < sband->n_channels; i++)\r\nhandle_channel(wiphy, initiator, &sband->channels[i]);\r\n}\r\nstatic bool reg_request_cell_base(struct regulatory_request *request)\r\n{\r\nif (request->initiator != NL80211_REGDOM_SET_BY_USER)\r\nreturn false;\r\nreturn request->user_reg_hint_type == NL80211_USER_REG_HINT_CELL_BASE;\r\n}\r\nbool reg_last_request_cell_base(void)\r\n{\r\nreturn reg_request_cell_base(get_last_request());\r\n}\r\nstatic enum reg_request_treatment\r\nreg_ignore_cell_hint(struct regulatory_request *pending_request)\r\n{\r\nstruct regulatory_request *lr = get_last_request();\r\nif (!reg_num_devs_support_basehint)\r\nreturn REG_REQ_IGNORE;\r\nif (reg_request_cell_base(lr) &&\r\n!regdom_changes(pending_request->alpha2))\r\nreturn REG_REQ_ALREADY_SET;\r\nreturn REG_REQ_OK;\r\n}\r\nstatic bool reg_dev_ignore_cell_hint(struct wiphy *wiphy)\r\n{\r\nreturn !(wiphy->features & NL80211_FEATURE_CELL_BASE_REG_HINTS);\r\n}\r\nstatic int reg_ignore_cell_hint(struct regulatory_request *pending_request)\r\n{\r\nreturn REG_REQ_IGNORE;\r\n}\r\nstatic bool reg_dev_ignore_cell_hint(struct wiphy *wiphy)\r\n{\r\nreturn true;\r\n}\r\nstatic bool ignore_reg_update(struct wiphy *wiphy,\r\nenum nl80211_reg_initiator initiator)\r\n{\r\nstruct regulatory_request *lr = get_last_request();\r\nif (!lr) {\r\nREG_DBG_PRINT("Ignoring regulatory request %s since last_request is not set\n",\r\nreg_initiator_name(initiator));\r\nreturn true;\r\n}\r\nif (initiator == NL80211_REGDOM_SET_BY_CORE &&\r\nwiphy->flags & WIPHY_FLAG_CUSTOM_REGULATORY) {\r\nREG_DBG_PRINT("Ignoring regulatory request %s since the driver uses its own custom regulatory domain\n",\r\nreg_initiator_name(initiator));\r\nreturn true;\r\n}\r\nif (wiphy->flags & WIPHY_FLAG_STRICT_REGULATORY && !wiphy->regd &&\r\ninitiator != NL80211_REGDOM_SET_BY_COUNTRY_IE &&\r\n!is_world_regdom(lr->alpha2)) {\r\nREG_DBG_PRINT("Ignoring regulatory request %s since the driver requires its own regulatory domain to be set first\n",\r\nreg_initiator_name(initiator));\r\nreturn true;\r\n}\r\nif (reg_request_cell_base(lr))\r\nreturn reg_dev_ignore_cell_hint(wiphy);\r\nreturn false;\r\n}\r\nstatic bool reg_is_world_roaming(struct wiphy *wiphy)\r\n{\r\nconst struct ieee80211_regdomain *cr = get_cfg80211_regdom();\r\nconst struct ieee80211_regdomain *wr = get_wiphy_regdom(wiphy);\r\nstruct regulatory_request *lr = get_last_request();\r\nif (is_world_regdom(cr->alpha2) || (wr && is_world_regdom(wr->alpha2)))\r\nreturn true;\r\nif (lr && lr->initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE &&\r\nwiphy->flags & WIPHY_FLAG_CUSTOM_REGULATORY)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void handle_reg_beacon(struct wiphy *wiphy, unsigned int chan_idx,\r\nstruct reg_beacon *reg_beacon)\r\n{\r\nstruct ieee80211_supported_band *sband;\r\nstruct ieee80211_channel *chan;\r\nbool channel_changed = false;\r\nstruct ieee80211_channel chan_before;\r\nsband = wiphy->bands[reg_beacon->chan.band];\r\nchan = &sband->channels[chan_idx];\r\nif (likely(chan->center_freq != reg_beacon->chan.center_freq))\r\nreturn;\r\nif (chan->beacon_found)\r\nreturn;\r\nchan->beacon_found = true;\r\nif (!reg_is_world_roaming(wiphy))\r\nreturn;\r\nif (wiphy->flags & WIPHY_FLAG_DISABLE_BEACON_HINTS)\r\nreturn;\r\nchan_before.center_freq = chan->center_freq;\r\nchan_before.flags = chan->flags;\r\nif (chan->flags & IEEE80211_CHAN_PASSIVE_SCAN) {\r\nchan->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;\r\nchannel_changed = true;\r\n}\r\nif (chan->flags & IEEE80211_CHAN_NO_IBSS) {\r\nchan->flags &= ~IEEE80211_CHAN_NO_IBSS;\r\nchannel_changed = true;\r\n}\r\nif (channel_changed)\r\nnl80211_send_beacon_hint_event(wiphy, &chan_before, chan);\r\n}\r\nstatic void wiphy_update_new_beacon(struct wiphy *wiphy,\r\nstruct reg_beacon *reg_beacon)\r\n{\r\nunsigned int i;\r\nstruct ieee80211_supported_band *sband;\r\nif (!wiphy->bands[reg_beacon->chan.band])\r\nreturn;\r\nsband = wiphy->bands[reg_beacon->chan.band];\r\nfor (i = 0; i < sband->n_channels; i++)\r\nhandle_reg_beacon(wiphy, i, reg_beacon);\r\n}\r\nstatic void wiphy_update_beacon_reg(struct wiphy *wiphy)\r\n{\r\nunsigned int i;\r\nstruct ieee80211_supported_band *sband;\r\nstruct reg_beacon *reg_beacon;\r\nlist_for_each_entry(reg_beacon, &reg_beacon_list, list) {\r\nif (!wiphy->bands[reg_beacon->chan.band])\r\ncontinue;\r\nsband = wiphy->bands[reg_beacon->chan.band];\r\nfor (i = 0; i < sband->n_channels; i++)\r\nhandle_reg_beacon(wiphy, i, reg_beacon);\r\n}\r\n}\r\nstatic void reg_process_beacons(struct wiphy *wiphy)\r\n{\r\nif (!last_request)\r\nreturn;\r\nwiphy_update_beacon_reg(wiphy);\r\n}\r\nstatic bool is_ht40_allowed(struct ieee80211_channel *chan)\r\n{\r\nif (!chan)\r\nreturn false;\r\nif (chan->flags & IEEE80211_CHAN_DISABLED)\r\nreturn false;\r\nif ((chan->flags & IEEE80211_CHAN_NO_HT40) == IEEE80211_CHAN_NO_HT40)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void reg_process_ht_flags_channel(struct wiphy *wiphy,\r\nstruct ieee80211_channel *channel)\r\n{\r\nstruct ieee80211_supported_band *sband = wiphy->bands[channel->band];\r\nstruct ieee80211_channel *channel_before = NULL, *channel_after = NULL;\r\nunsigned int i;\r\nif (!is_ht40_allowed(channel)) {\r\nchannel->flags |= IEEE80211_CHAN_NO_HT40;\r\nreturn;\r\n}\r\nfor (i = 0; i < sband->n_channels; i++) {\r\nstruct ieee80211_channel *c = &sband->channels[i];\r\nif (c->center_freq == (channel->center_freq - 20))\r\nchannel_before = c;\r\nif (c->center_freq == (channel->center_freq + 20))\r\nchannel_after = c;\r\n}\r\nif (!is_ht40_allowed(channel_before))\r\nchannel->flags |= IEEE80211_CHAN_NO_HT40MINUS;\r\nelse\r\nchannel->flags &= ~IEEE80211_CHAN_NO_HT40MINUS;\r\nif (!is_ht40_allowed(channel_after))\r\nchannel->flags |= IEEE80211_CHAN_NO_HT40PLUS;\r\nelse\r\nchannel->flags &= ~IEEE80211_CHAN_NO_HT40PLUS;\r\n}\r\nstatic void reg_process_ht_flags_band(struct wiphy *wiphy,\r\nstruct ieee80211_supported_band *sband)\r\n{\r\nunsigned int i;\r\nif (!sband)\r\nreturn;\r\nfor (i = 0; i < sband->n_channels; i++)\r\nreg_process_ht_flags_channel(wiphy, &sband->channels[i]);\r\n}\r\nstatic void reg_process_ht_flags(struct wiphy *wiphy)\r\n{\r\nenum ieee80211_band band;\r\nif (!wiphy)\r\nreturn;\r\nfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\r\nreg_process_ht_flags_band(wiphy, wiphy->bands[band]);\r\n}\r\nstatic void wiphy_update_regulatory(struct wiphy *wiphy,\r\nenum nl80211_reg_initiator initiator)\r\n{\r\nenum ieee80211_band band;\r\nstruct regulatory_request *lr = get_last_request();\r\nif (ignore_reg_update(wiphy, initiator))\r\nreturn;\r\nlr->dfs_region = get_cfg80211_regdom()->dfs_region;\r\nfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\r\nhandle_band(wiphy, initiator, wiphy->bands[band]);\r\nreg_process_beacons(wiphy);\r\nreg_process_ht_flags(wiphy);\r\nif (wiphy->reg_notifier)\r\nwiphy->reg_notifier(wiphy, lr);\r\n}\r\nstatic void update_all_wiphy_regulatory(enum nl80211_reg_initiator initiator)\r\n{\r\nstruct cfg80211_registered_device *rdev;\r\nstruct wiphy *wiphy;\r\nASSERT_RTNL();\r\nlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\r\nwiphy = &rdev->wiphy;\r\nwiphy_update_regulatory(wiphy, initiator);\r\nif (initiator == NL80211_REGDOM_SET_BY_CORE &&\r\nwiphy->flags & WIPHY_FLAG_CUSTOM_REGULATORY &&\r\nwiphy->reg_notifier)\r\nwiphy->reg_notifier(wiphy, get_last_request());\r\n}\r\n}\r\nstatic void handle_channel_custom(struct wiphy *wiphy,\r\nstruct ieee80211_channel *chan,\r\nconst struct ieee80211_regdomain *regd)\r\n{\r\nu32 bw_flags = 0;\r\nconst struct ieee80211_reg_rule *reg_rule = NULL;\r\nconst struct ieee80211_power_rule *power_rule = NULL;\r\nconst struct ieee80211_freq_range *freq_range = NULL;\r\nreg_rule = freq_reg_info_regd(wiphy, MHZ_TO_KHZ(chan->center_freq),\r\nregd);\r\nif (IS_ERR(reg_rule)) {\r\nREG_DBG_PRINT("Disabling freq %d MHz as custom regd has no rule that fits it\n",\r\nchan->center_freq);\r\nchan->flags = IEEE80211_CHAN_DISABLED;\r\nreturn;\r\n}\r\nchan_reg_rule_print_dbg(chan, reg_rule);\r\npower_rule = &reg_rule->power_rule;\r\nfreq_range = &reg_rule->freq_range;\r\nif (freq_range->max_bandwidth_khz < MHZ_TO_KHZ(40))\r\nbw_flags = IEEE80211_CHAN_NO_HT40;\r\nif (freq_range->max_bandwidth_khz < MHZ_TO_KHZ(80))\r\nbw_flags |= IEEE80211_CHAN_NO_80MHZ;\r\nif (freq_range->max_bandwidth_khz < MHZ_TO_KHZ(160))\r\nbw_flags |= IEEE80211_CHAN_NO_160MHZ;\r\nchan->flags |= map_regdom_flags(reg_rule->flags) | bw_flags;\r\nchan->max_antenna_gain = (int) MBI_TO_DBI(power_rule->max_antenna_gain);\r\nchan->max_reg_power = chan->max_power =\r\n(int) MBM_TO_DBM(power_rule->max_eirp);\r\n}\r\nstatic void handle_band_custom(struct wiphy *wiphy,\r\nstruct ieee80211_supported_band *sband,\r\nconst struct ieee80211_regdomain *regd)\r\n{\r\nunsigned int i;\r\nif (!sband)\r\nreturn;\r\nfor (i = 0; i < sband->n_channels; i++)\r\nhandle_channel_custom(wiphy, &sband->channels[i], regd);\r\n}\r\nvoid wiphy_apply_custom_regulatory(struct wiphy *wiphy,\r\nconst struct ieee80211_regdomain *regd)\r\n{\r\nenum ieee80211_band band;\r\nunsigned int bands_set = 0;\r\nfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\r\nif (!wiphy->bands[band])\r\ncontinue;\r\nhandle_band_custom(wiphy, wiphy->bands[band], regd);\r\nbands_set++;\r\n}\r\nWARN_ON(!bands_set);\r\n}\r\nstatic enum reg_request_treatment\r\nget_reg_request_treatment(struct wiphy *wiphy,\r\nstruct regulatory_request *pending_request)\r\n{\r\nstruct wiphy *last_wiphy = NULL;\r\nstruct regulatory_request *lr = get_last_request();\r\nif (!lr)\r\nreturn REG_REQ_OK;\r\nswitch (pending_request->initiator) {\r\ncase NL80211_REGDOM_SET_BY_CORE:\r\nreturn REG_REQ_OK;\r\ncase NL80211_REGDOM_SET_BY_COUNTRY_IE:\r\nif (reg_request_cell_base(lr)) {\r\nif (regdom_changes(pending_request->alpha2))\r\nreturn REG_REQ_IGNORE;\r\nreturn REG_REQ_ALREADY_SET;\r\n}\r\nlast_wiphy = wiphy_idx_to_wiphy(lr->wiphy_idx);\r\nif (unlikely(!is_an_alpha2(pending_request->alpha2)))\r\nreturn -EINVAL;\r\nif (lr->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE) {\r\nif (last_wiphy != wiphy) {\r\nif (regdom_changes(pending_request->alpha2))\r\nreturn REG_REQ_IGNORE;\r\nreturn REG_REQ_ALREADY_SET;\r\n}\r\nif (WARN_ON(regdom_changes(pending_request->alpha2)))\r\nreturn REG_REQ_OK;\r\nreturn REG_REQ_ALREADY_SET;\r\n}\r\nreturn REG_REQ_OK;\r\ncase NL80211_REGDOM_SET_BY_DRIVER:\r\nif (lr->initiator == NL80211_REGDOM_SET_BY_CORE) {\r\nif (regdom_changes(pending_request->alpha2))\r\nreturn REG_REQ_OK;\r\nreturn REG_REQ_ALREADY_SET;\r\n}\r\nif (lr->initiator == NL80211_REGDOM_SET_BY_DRIVER &&\r\n!regdom_changes(pending_request->alpha2))\r\nreturn REG_REQ_ALREADY_SET;\r\nreturn REG_REQ_INTERSECT;\r\ncase NL80211_REGDOM_SET_BY_USER:\r\nif (reg_request_cell_base(pending_request))\r\nreturn reg_ignore_cell_hint(pending_request);\r\nif (reg_request_cell_base(lr))\r\nreturn REG_REQ_IGNORE;\r\nif (lr->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE)\r\nreturn REG_REQ_INTERSECT;\r\nif (lr->initiator == NL80211_REGDOM_SET_BY_USER &&\r\nlr->intersect)\r\nreturn REG_REQ_IGNORE;\r\nif ((lr->initiator == NL80211_REGDOM_SET_BY_CORE ||\r\nlr->initiator == NL80211_REGDOM_SET_BY_DRIVER ||\r\nlr->initiator == NL80211_REGDOM_SET_BY_USER) &&\r\nregdom_changes(lr->alpha2))\r\nreturn REG_REQ_IGNORE;\r\nif (!regdom_changes(pending_request->alpha2))\r\nreturn REG_REQ_ALREADY_SET;\r\nreturn REG_REQ_OK;\r\n}\r\nreturn REG_REQ_IGNORE;\r\n}\r\nstatic void reg_set_request_processed(void)\r\n{\r\nbool need_more_processing = false;\r\nstruct regulatory_request *lr = get_last_request();\r\nlr->processed = true;\r\nspin_lock(&reg_requests_lock);\r\nif (!list_empty(&reg_requests_list))\r\nneed_more_processing = true;\r\nspin_unlock(&reg_requests_lock);\r\nif (lr->initiator == NL80211_REGDOM_SET_BY_USER)\r\ncancel_delayed_work(&reg_timeout);\r\nif (need_more_processing)\r\nschedule_work(&reg_work);\r\n}\r\nstatic enum reg_request_treatment\r\n__regulatory_hint(struct wiphy *wiphy,\r\nstruct regulatory_request *pending_request)\r\n{\r\nconst struct ieee80211_regdomain *regd;\r\nbool intersect = false;\r\nenum reg_request_treatment treatment;\r\nstruct regulatory_request *lr;\r\ntreatment = get_reg_request_treatment(wiphy, pending_request);\r\nswitch (treatment) {\r\ncase REG_REQ_INTERSECT:\r\nif (pending_request->initiator ==\r\nNL80211_REGDOM_SET_BY_DRIVER) {\r\nregd = reg_copy_regd(get_cfg80211_regdom());\r\nif (IS_ERR(regd)) {\r\nkfree(pending_request);\r\nreturn PTR_ERR(regd);\r\n}\r\nrcu_assign_pointer(wiphy->regd, regd);\r\n}\r\nintersect = true;\r\nbreak;\r\ncase REG_REQ_OK:\r\nbreak;\r\ndefault:\r\nif (treatment == REG_REQ_ALREADY_SET &&\r\npending_request->initiator == NL80211_REGDOM_SET_BY_DRIVER) {\r\nregd = reg_copy_regd(get_cfg80211_regdom());\r\nif (IS_ERR(regd)) {\r\nkfree(pending_request);\r\nreturn REG_REQ_IGNORE;\r\n}\r\ntreatment = REG_REQ_ALREADY_SET;\r\nrcu_assign_pointer(wiphy->regd, regd);\r\ngoto new_request;\r\n}\r\nkfree(pending_request);\r\nreturn treatment;\r\n}\r\nnew_request:\r\nlr = get_last_request();\r\nif (lr != &core_request_world && lr)\r\nkfree_rcu(lr, rcu_head);\r\npending_request->intersect = intersect;\r\npending_request->processed = false;\r\nrcu_assign_pointer(last_request, pending_request);\r\nlr = pending_request;\r\npending_request = NULL;\r\nif (lr->initiator == NL80211_REGDOM_SET_BY_USER) {\r\nuser_alpha2[0] = lr->alpha2[0];\r\nuser_alpha2[1] = lr->alpha2[1];\r\n}\r\nif (treatment != REG_REQ_OK && treatment != REG_REQ_INTERSECT) {\r\nif (treatment == REG_REQ_ALREADY_SET) {\r\nnl80211_send_reg_change_event(lr);\r\nreg_set_request_processed();\r\n}\r\nreturn treatment;\r\n}\r\nif (call_crda(lr->alpha2))\r\nreturn REG_REQ_IGNORE;\r\nreturn REG_REQ_OK;\r\n}\r\nstatic void reg_process_hint(struct regulatory_request *reg_request,\r\nenum nl80211_reg_initiator reg_initiator)\r\n{\r\nstruct wiphy *wiphy = NULL;\r\nif (WARN_ON(!reg_request->alpha2))\r\nreturn;\r\nif (reg_request->wiphy_idx != WIPHY_IDX_INVALID)\r\nwiphy = wiphy_idx_to_wiphy(reg_request->wiphy_idx);\r\nif (reg_initiator == NL80211_REGDOM_SET_BY_DRIVER && !wiphy) {\r\nkfree(reg_request);\r\nreturn;\r\n}\r\nswitch (__regulatory_hint(wiphy, reg_request)) {\r\ncase REG_REQ_ALREADY_SET:\r\nif (wiphy && wiphy->flags & WIPHY_FLAG_STRICT_REGULATORY)\r\nwiphy_update_regulatory(wiphy, reg_initiator);\r\nbreak;\r\ndefault:\r\nif (reg_initiator == NL80211_REGDOM_SET_BY_USER)\r\nschedule_delayed_work(&reg_timeout,\r\nmsecs_to_jiffies(3142));\r\nbreak;\r\n}\r\n}\r\nstatic void reg_process_pending_hints(void)\r\n{\r\nstruct regulatory_request *reg_request, *lr;\r\nlr = get_last_request();\r\nif (lr && !lr->processed) {\r\nREG_DBG_PRINT("Pending regulatory request, waiting for it to be processed...\n");\r\nreturn;\r\n}\r\nspin_lock(&reg_requests_lock);\r\nif (list_empty(&reg_requests_list)) {\r\nspin_unlock(&reg_requests_lock);\r\nreturn;\r\n}\r\nreg_request = list_first_entry(&reg_requests_list,\r\nstruct regulatory_request,\r\nlist);\r\nlist_del_init(&reg_request->list);\r\nspin_unlock(&reg_requests_lock);\r\nreg_process_hint(reg_request, reg_request->initiator);\r\n}\r\nstatic void reg_process_pending_beacon_hints(void)\r\n{\r\nstruct cfg80211_registered_device *rdev;\r\nstruct reg_beacon *pending_beacon, *tmp;\r\nspin_lock_bh(&reg_pending_beacons_lock);\r\nlist_for_each_entry_safe(pending_beacon, tmp,\r\n&reg_pending_beacons, list) {\r\nlist_del_init(&pending_beacon->list);\r\nlist_for_each_entry(rdev, &cfg80211_rdev_list, list)\r\nwiphy_update_new_beacon(&rdev->wiphy, pending_beacon);\r\nlist_add_tail(&pending_beacon->list, &reg_beacon_list);\r\n}\r\nspin_unlock_bh(&reg_pending_beacons_lock);\r\n}\r\nstatic void reg_todo(struct work_struct *work)\r\n{\r\nrtnl_lock();\r\nreg_process_pending_hints();\r\nreg_process_pending_beacon_hints();\r\nrtnl_unlock();\r\n}\r\nstatic void queue_regulatory_request(struct regulatory_request *request)\r\n{\r\nrequest->alpha2[0] = toupper(request->alpha2[0]);\r\nrequest->alpha2[1] = toupper(request->alpha2[1]);\r\nspin_lock(&reg_requests_lock);\r\nlist_add_tail(&request->list, &reg_requests_list);\r\nspin_unlock(&reg_requests_lock);\r\nschedule_work(&reg_work);\r\n}\r\nstatic int regulatory_hint_core(const char *alpha2)\r\n{\r\nstruct regulatory_request *request;\r\nrequest = kzalloc(sizeof(struct regulatory_request), GFP_KERNEL);\r\nif (!request)\r\nreturn -ENOMEM;\r\nrequest->alpha2[0] = alpha2[0];\r\nrequest->alpha2[1] = alpha2[1];\r\nrequest->initiator = NL80211_REGDOM_SET_BY_CORE;\r\nqueue_regulatory_request(request);\r\nreturn 0;\r\n}\r\nint regulatory_hint_user(const char *alpha2,\r\nenum nl80211_user_reg_hint_type user_reg_hint_type)\r\n{\r\nstruct regulatory_request *request;\r\nif (WARN_ON(!alpha2))\r\nreturn -EINVAL;\r\nrequest = kzalloc(sizeof(struct regulatory_request), GFP_KERNEL);\r\nif (!request)\r\nreturn -ENOMEM;\r\nrequest->wiphy_idx = WIPHY_IDX_INVALID;\r\nrequest->alpha2[0] = alpha2[0];\r\nrequest->alpha2[1] = alpha2[1];\r\nrequest->initiator = NL80211_REGDOM_SET_BY_USER;\r\nrequest->user_reg_hint_type = user_reg_hint_type;\r\nqueue_regulatory_request(request);\r\nreturn 0;\r\n}\r\nint regulatory_hint(struct wiphy *wiphy, const char *alpha2)\r\n{\r\nstruct regulatory_request *request;\r\nif (WARN_ON(!alpha2 || !wiphy))\r\nreturn -EINVAL;\r\nrequest = kzalloc(sizeof(struct regulatory_request), GFP_KERNEL);\r\nif (!request)\r\nreturn -ENOMEM;\r\nrequest->wiphy_idx = get_wiphy_idx(wiphy);\r\nrequest->alpha2[0] = alpha2[0];\r\nrequest->alpha2[1] = alpha2[1];\r\nrequest->initiator = NL80211_REGDOM_SET_BY_DRIVER;\r\nqueue_regulatory_request(request);\r\nreturn 0;\r\n}\r\nvoid regulatory_hint_11d(struct wiphy *wiphy, enum ieee80211_band band,\r\nconst u8 *country_ie, u8 country_ie_len)\r\n{\r\nchar alpha2[2];\r\nenum environment_cap env = ENVIRON_ANY;\r\nstruct regulatory_request *request = NULL, *lr;\r\nif (country_ie_len & 0x01)\r\nreturn;\r\nif (country_ie_len < IEEE80211_COUNTRY_IE_MIN_LEN)\r\nreturn;\r\nrequest = kzalloc(sizeof(*request), GFP_KERNEL);\r\nif (!request)\r\nreturn;\r\nalpha2[0] = country_ie[0];\r\nalpha2[1] = country_ie[1];\r\nif (country_ie[2] == 'I')\r\nenv = ENVIRON_INDOOR;\r\nelse if (country_ie[2] == 'O')\r\nenv = ENVIRON_OUTDOOR;\r\nrcu_read_lock();\r\nlr = get_last_request();\r\nif (unlikely(!lr))\r\ngoto out;\r\nif (lr->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE &&\r\nlr->wiphy_idx != WIPHY_IDX_INVALID)\r\ngoto out;\r\nrequest->wiphy_idx = get_wiphy_idx(wiphy);\r\nrequest->alpha2[0] = alpha2[0];\r\nrequest->alpha2[1] = alpha2[1];\r\nrequest->initiator = NL80211_REGDOM_SET_BY_COUNTRY_IE;\r\nrequest->country_ie_env = env;\r\nqueue_regulatory_request(request);\r\nrequest = NULL;\r\nout:\r\nkfree(request);\r\nrcu_read_unlock();\r\n}\r\nstatic void restore_alpha2(char *alpha2, bool reset_user)\r\n{\r\nalpha2[0] = '9';\r\nalpha2[1] = '7';\r\nif (is_user_regdom_saved()) {\r\nif (reset_user) {\r\nREG_DBG_PRINT("Restoring regulatory settings including user preference\n");\r\nuser_alpha2[0] = '9';\r\nuser_alpha2[1] = '7';\r\nif (!is_world_regdom(ieee80211_regdom)) {\r\nREG_DBG_PRINT("Keeping preference on module parameter ieee80211_regdom: %c%c\n",\r\nieee80211_regdom[0], ieee80211_regdom[1]);\r\nalpha2[0] = ieee80211_regdom[0];\r\nalpha2[1] = ieee80211_regdom[1];\r\n}\r\n} else {\r\nREG_DBG_PRINT("Restoring regulatory settings while preserving user preference for: %c%c\n",\r\nuser_alpha2[0], user_alpha2[1]);\r\nalpha2[0] = user_alpha2[0];\r\nalpha2[1] = user_alpha2[1];\r\n}\r\n} else if (!is_world_regdom(ieee80211_regdom)) {\r\nREG_DBG_PRINT("Keeping preference on module parameter ieee80211_regdom: %c%c\n",\r\nieee80211_regdom[0], ieee80211_regdom[1]);\r\nalpha2[0] = ieee80211_regdom[0];\r\nalpha2[1] = ieee80211_regdom[1];\r\n} else\r\nREG_DBG_PRINT("Restoring regulatory settings\n");\r\n}\r\nstatic void restore_custom_reg_settings(struct wiphy *wiphy)\r\n{\r\nstruct ieee80211_supported_band *sband;\r\nenum ieee80211_band band;\r\nstruct ieee80211_channel *chan;\r\nint i;\r\nfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\r\nsband = wiphy->bands[band];\r\nif (!sband)\r\ncontinue;\r\nfor (i = 0; i < sband->n_channels; i++) {\r\nchan = &sband->channels[i];\r\nchan->flags = chan->orig_flags;\r\nchan->max_antenna_gain = chan->orig_mag;\r\nchan->max_power = chan->orig_mpwr;\r\nchan->beacon_found = false;\r\n}\r\n}\r\n}\r\nstatic void restore_regulatory_settings(bool reset_user)\r\n{\r\nchar alpha2[2];\r\nchar world_alpha2[2];\r\nstruct reg_beacon *reg_beacon, *btmp;\r\nstruct regulatory_request *reg_request, *tmp;\r\nLIST_HEAD(tmp_reg_req_list);\r\nstruct cfg80211_registered_device *rdev;\r\nASSERT_RTNL();\r\nreset_regdomains(true, &world_regdom);\r\nrestore_alpha2(alpha2, reset_user);\r\nspin_lock(&reg_requests_lock);\r\nlist_for_each_entry_safe(reg_request, tmp, &reg_requests_list, list) {\r\nif (reg_request->initiator != NL80211_REGDOM_SET_BY_USER)\r\ncontinue;\r\nlist_move_tail(&reg_request->list, &tmp_reg_req_list);\r\n}\r\nspin_unlock(&reg_requests_lock);\r\nspin_lock_bh(&reg_pending_beacons_lock);\r\nlist_for_each_entry_safe(reg_beacon, btmp, &reg_pending_beacons, list) {\r\nlist_del(&reg_beacon->list);\r\nkfree(reg_beacon);\r\n}\r\nspin_unlock_bh(&reg_pending_beacons_lock);\r\nlist_for_each_entry_safe(reg_beacon, btmp, &reg_beacon_list, list) {\r\nlist_del(&reg_beacon->list);\r\nkfree(reg_beacon);\r\n}\r\nworld_alpha2[0] = cfg80211_world_regdom->alpha2[0];\r\nworld_alpha2[1] = cfg80211_world_regdom->alpha2[1];\r\nlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\r\nif (rdev->wiphy.flags & WIPHY_FLAG_CUSTOM_REGULATORY)\r\nrestore_custom_reg_settings(&rdev->wiphy);\r\n}\r\nregulatory_hint_core(world_alpha2);\r\nif (is_an_alpha2(alpha2))\r\nregulatory_hint_user(user_alpha2, NL80211_USER_REG_HINT_USER);\r\nspin_lock(&reg_requests_lock);\r\nlist_splice_tail_init(&tmp_reg_req_list, &reg_requests_list);\r\nspin_unlock(&reg_requests_lock);\r\nREG_DBG_PRINT("Kicking the queue\n");\r\nschedule_work(&reg_work);\r\n}\r\nvoid regulatory_hint_disconnect(void)\r\n{\r\nREG_DBG_PRINT("All devices are disconnected, going to restore regulatory settings\n");\r\nrestore_regulatory_settings(false);\r\n}\r\nstatic bool freq_is_chan_12_13_14(u16 freq)\r\n{\r\nif (freq == ieee80211_channel_to_frequency(12, IEEE80211_BAND_2GHZ) ||\r\nfreq == ieee80211_channel_to_frequency(13, IEEE80211_BAND_2GHZ) ||\r\nfreq == ieee80211_channel_to_frequency(14, IEEE80211_BAND_2GHZ))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool pending_reg_beacon(struct ieee80211_channel *beacon_chan)\r\n{\r\nstruct reg_beacon *pending_beacon;\r\nlist_for_each_entry(pending_beacon, &reg_pending_beacons, list)\r\nif (beacon_chan->center_freq ==\r\npending_beacon->chan.center_freq)\r\nreturn true;\r\nreturn false;\r\n}\r\nint regulatory_hint_found_beacon(struct wiphy *wiphy,\r\nstruct ieee80211_channel *beacon_chan,\r\ngfp_t gfp)\r\n{\r\nstruct reg_beacon *reg_beacon;\r\nbool processing;\r\nif (beacon_chan->beacon_found ||\r\nbeacon_chan->flags & IEEE80211_CHAN_RADAR ||\r\n(beacon_chan->band == IEEE80211_BAND_2GHZ &&\r\n!freq_is_chan_12_13_14(beacon_chan->center_freq)))\r\nreturn 0;\r\nspin_lock_bh(&reg_pending_beacons_lock);\r\nprocessing = pending_reg_beacon(beacon_chan);\r\nspin_unlock_bh(&reg_pending_beacons_lock);\r\nif (processing)\r\nreturn 0;\r\nreg_beacon = kzalloc(sizeof(struct reg_beacon), gfp);\r\nif (!reg_beacon)\r\nreturn -ENOMEM;\r\nREG_DBG_PRINT("Found new beacon on frequency: %d MHz (Ch %d) on %s\n",\r\nbeacon_chan->center_freq,\r\nieee80211_frequency_to_channel(beacon_chan->center_freq),\r\nwiphy_name(wiphy));\r\nmemcpy(&reg_beacon->chan, beacon_chan,\r\nsizeof(struct ieee80211_channel));\r\nspin_lock_bh(&reg_pending_beacons_lock);\r\nlist_add_tail(&reg_beacon->list, &reg_pending_beacons);\r\nspin_unlock_bh(&reg_pending_beacons_lock);\r\nschedule_work(&reg_work);\r\nreturn 0;\r\n}\r\nstatic void print_rd_rules(const struct ieee80211_regdomain *rd)\r\n{\r\nunsigned int i;\r\nconst struct ieee80211_reg_rule *reg_rule = NULL;\r\nconst struct ieee80211_freq_range *freq_range = NULL;\r\nconst struct ieee80211_power_rule *power_rule = NULL;\r\npr_info(" (start_freq - end_freq @ bandwidth), (max_antenna_gain, max_eirp)\n");\r\nfor (i = 0; i < rd->n_reg_rules; i++) {\r\nreg_rule = &rd->reg_rules[i];\r\nfreq_range = &reg_rule->freq_range;\r\npower_rule = &reg_rule->power_rule;\r\nif (power_rule->max_antenna_gain)\r\npr_info(" (%d KHz - %d KHz @ %d KHz), (%d mBi, %d mBm)\n",\r\nfreq_range->start_freq_khz,\r\nfreq_range->end_freq_khz,\r\nfreq_range->max_bandwidth_khz,\r\npower_rule->max_antenna_gain,\r\npower_rule->max_eirp);\r\nelse\r\npr_info(" (%d KHz - %d KHz @ %d KHz), (N/A, %d mBm)\n",\r\nfreq_range->start_freq_khz,\r\nfreq_range->end_freq_khz,\r\nfreq_range->max_bandwidth_khz,\r\npower_rule->max_eirp);\r\n}\r\n}\r\nbool reg_supported_dfs_region(u8 dfs_region)\r\n{\r\nswitch (dfs_region) {\r\ncase NL80211_DFS_UNSET:\r\ncase NL80211_DFS_FCC:\r\ncase NL80211_DFS_ETSI:\r\ncase NL80211_DFS_JP:\r\nreturn true;\r\ndefault:\r\nREG_DBG_PRINT("Ignoring uknown DFS master region: %d\n",\r\ndfs_region);\r\nreturn false;\r\n}\r\n}\r\nstatic void print_dfs_region(u8 dfs_region)\r\n{\r\nif (!dfs_region)\r\nreturn;\r\nswitch (dfs_region) {\r\ncase NL80211_DFS_FCC:\r\npr_info(" DFS Master region FCC");\r\nbreak;\r\ncase NL80211_DFS_ETSI:\r\npr_info(" DFS Master region ETSI");\r\nbreak;\r\ncase NL80211_DFS_JP:\r\npr_info(" DFS Master region JP");\r\nbreak;\r\ndefault:\r\npr_info(" DFS Master region Unknown");\r\nbreak;\r\n}\r\n}\r\nstatic void print_regdomain(const struct ieee80211_regdomain *rd)\r\n{\r\nstruct regulatory_request *lr = get_last_request();\r\nif (is_intersected_alpha2(rd->alpha2)) {\r\nif (lr->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE) {\r\nstruct cfg80211_registered_device *rdev;\r\nrdev = cfg80211_rdev_by_wiphy_idx(lr->wiphy_idx);\r\nif (rdev) {\r\npr_info("Current regulatory domain updated by AP to: %c%c\n",\r\nrdev->country_ie_alpha2[0],\r\nrdev->country_ie_alpha2[1]);\r\n} else\r\npr_info("Current regulatory domain intersected:\n");\r\n} else\r\npr_info("Current regulatory domain intersected:\n");\r\n} else if (is_world_regdom(rd->alpha2)) {\r\npr_info("World regulatory domain updated:\n");\r\n} else {\r\nif (is_unknown_alpha2(rd->alpha2))\r\npr_info("Regulatory domain changed to driver built-in settings (unknown country)\n");\r\nelse {\r\nif (reg_request_cell_base(lr))\r\npr_info("Regulatory domain changed to country: %c%c by Cell Station\n",\r\nrd->alpha2[0], rd->alpha2[1]);\r\nelse\r\npr_info("Regulatory domain changed to country: %c%c\n",\r\nrd->alpha2[0], rd->alpha2[1]);\r\n}\r\n}\r\nprint_dfs_region(rd->dfs_region);\r\nprint_rd_rules(rd);\r\n}\r\nstatic void print_regdomain_info(const struct ieee80211_regdomain *rd)\r\n{\r\npr_info("Regulatory domain: %c%c\n", rd->alpha2[0], rd->alpha2[1]);\r\nprint_rd_rules(rd);\r\n}\r\nstatic int __set_regdom(const struct ieee80211_regdomain *rd)\r\n{\r\nconst struct ieee80211_regdomain *regd;\r\nconst struct ieee80211_regdomain *intersected_rd = NULL;\r\nstruct wiphy *request_wiphy;\r\nstruct regulatory_request *lr = get_last_request();\r\nif (!reg_is_valid_request(rd->alpha2))\r\nreturn -EINVAL;\r\nif (is_world_regdom(rd->alpha2)) {\r\nupdate_world_regdomain(rd);\r\nreturn 0;\r\n}\r\nif (!is_alpha2_set(rd->alpha2) && !is_an_alpha2(rd->alpha2) &&\r\n!is_unknown_alpha2(rd->alpha2))\r\nreturn -EINVAL;\r\nif (lr->initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE) {\r\nif (!regdom_changes(rd->alpha2))\r\nreturn -EALREADY;\r\n}\r\nif (!is_valid_rd(rd)) {\r\npr_err("Invalid regulatory domain detected:\n");\r\nprint_regdomain_info(rd);\r\nreturn -EINVAL;\r\n}\r\nrequest_wiphy = wiphy_idx_to_wiphy(lr->wiphy_idx);\r\nif (!request_wiphy &&\r\n(lr->initiator == NL80211_REGDOM_SET_BY_DRIVER ||\r\nlr->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE)) {\r\nschedule_delayed_work(&reg_timeout, 0);\r\nreturn -ENODEV;\r\n}\r\nif (!lr->intersect) {\r\nif (lr->initiator != NL80211_REGDOM_SET_BY_DRIVER) {\r\nreset_regdomains(false, rd);\r\nreturn 0;\r\n}\r\nif (request_wiphy->regd)\r\nreturn -EALREADY;\r\nregd = reg_copy_regd(rd);\r\nif (IS_ERR(regd))\r\nreturn PTR_ERR(regd);\r\nrcu_assign_pointer(request_wiphy->regd, regd);\r\nreset_regdomains(false, rd);\r\nreturn 0;\r\n}\r\nif (lr->initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE) {\r\nintersected_rd = regdom_intersect(rd, get_cfg80211_regdom());\r\nif (!intersected_rd)\r\nreturn -EINVAL;\r\nif (lr->initiator == NL80211_REGDOM_SET_BY_DRIVER) {\r\nconst struct ieee80211_regdomain *tmp;\r\ntmp = get_wiphy_regdom(request_wiphy);\r\nrcu_assign_pointer(request_wiphy->regd, rd);\r\nrcu_free_regdom(tmp);\r\n} else {\r\nkfree(rd);\r\n}\r\nrd = NULL;\r\nreset_regdomains(false, intersected_rd);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint set_regdom(const struct ieee80211_regdomain *rd)\r\n{\r\nstruct regulatory_request *lr;\r\nint r;\r\nlr = get_last_request();\r\nr = __set_regdom(rd);\r\nif (r) {\r\nif (r == -EALREADY)\r\nreg_set_request_processed();\r\nkfree(rd);\r\nreturn r;\r\n}\r\nif (WARN_ON(!lr->intersect && rd != get_cfg80211_regdom()))\r\nreturn -EINVAL;\r\nupdate_all_wiphy_regulatory(lr->initiator);\r\nprint_regdomain(get_cfg80211_regdom());\r\nnl80211_send_reg_change_event(lr);\r\nreg_set_request_processed();\r\nreturn 0;\r\n}\r\nint reg_device_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct regulatory_request *lr;\r\nu8 alpha2[2];\r\nbool add = false;\r\nrcu_read_lock();\r\nlr = get_last_request();\r\nif (lr && !lr->processed) {\r\nmemcpy(alpha2, lr->alpha2, 2);\r\nadd = true;\r\n}\r\nrcu_read_unlock();\r\nif (add)\r\nreturn add_uevent_var(env, "COUNTRY=%c%c",\r\nalpha2[0], alpha2[1]);\r\nreturn 0;\r\n}\r\nvoid wiphy_regulatory_register(struct wiphy *wiphy)\r\n{\r\nstruct regulatory_request *lr;\r\nif (!reg_dev_ignore_cell_hint(wiphy))\r\nreg_num_devs_support_basehint++;\r\nlr = get_last_request();\r\nwiphy_update_regulatory(wiphy, lr->initiator);\r\n}\r\nvoid wiphy_regulatory_deregister(struct wiphy *wiphy)\r\n{\r\nstruct wiphy *request_wiphy = NULL;\r\nstruct regulatory_request *lr;\r\nlr = get_last_request();\r\nif (!reg_dev_ignore_cell_hint(wiphy))\r\nreg_num_devs_support_basehint--;\r\nrcu_free_regdom(get_wiphy_regdom(wiphy));\r\nrcu_assign_pointer(wiphy->regd, NULL);\r\nif (lr)\r\nrequest_wiphy = wiphy_idx_to_wiphy(lr->wiphy_idx);\r\nif (!request_wiphy || request_wiphy != wiphy)\r\nreturn;\r\nlr->wiphy_idx = WIPHY_IDX_INVALID;\r\nlr->country_ie_env = ENVIRON_ANY;\r\n}\r\nstatic void reg_timeout_work(struct work_struct *work)\r\n{\r\nREG_DBG_PRINT("Timeout while waiting for CRDA to reply, restoring regulatory settings\n");\r\nrtnl_lock();\r\nrestore_regulatory_settings(true);\r\nrtnl_unlock();\r\n}\r\nint __init regulatory_init(void)\r\n{\r\nint err = 0;\r\nreg_pdev = platform_device_register_simple("regulatory", 0, NULL, 0);\r\nif (IS_ERR(reg_pdev))\r\nreturn PTR_ERR(reg_pdev);\r\nreg_pdev->dev.type = &reg_device_type;\r\nspin_lock_init(&reg_requests_lock);\r\nspin_lock_init(&reg_pending_beacons_lock);\r\nreg_regdb_size_check();\r\nrcu_assign_pointer(cfg80211_regdomain, cfg80211_world_regdom);\r\nuser_alpha2[0] = '9';\r\nuser_alpha2[1] = '7';\r\nerr = regulatory_hint_core(cfg80211_world_regdom->alpha2);\r\nif (err) {\r\nif (err == -ENOMEM)\r\nreturn err;\r\npr_err("kobject_uevent_env() was unable to call CRDA during init\n");\r\n}\r\nif (!is_world_regdom(ieee80211_regdom))\r\nregulatory_hint_user(ieee80211_regdom,\r\nNL80211_USER_REG_HINT_USER);\r\nreturn 0;\r\n}\r\nvoid regulatory_exit(void)\r\n{\r\nstruct regulatory_request *reg_request, *tmp;\r\nstruct reg_beacon *reg_beacon, *btmp;\r\ncancel_work_sync(&reg_work);\r\ncancel_delayed_work_sync(&reg_timeout);\r\nrtnl_lock();\r\nreset_regdomains(true, NULL);\r\nrtnl_unlock();\r\ndev_set_uevent_suppress(&reg_pdev->dev, true);\r\nplatform_device_unregister(reg_pdev);\r\nlist_for_each_entry_safe(reg_beacon, btmp, &reg_pending_beacons, list) {\r\nlist_del(&reg_beacon->list);\r\nkfree(reg_beacon);\r\n}\r\nlist_for_each_entry_safe(reg_beacon, btmp, &reg_beacon_list, list) {\r\nlist_del(&reg_beacon->list);\r\nkfree(reg_beacon);\r\n}\r\nlist_for_each_entry_safe(reg_request, tmp, &reg_requests_list, list) {\r\nlist_del(&reg_request->list);\r\nkfree(reg_request);\r\n}\r\n}
