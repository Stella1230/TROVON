static int\r\ncifs_idmap_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\r\n{\r\nchar *payload;\r\nif (prep->datalen <= sizeof(key->payload)) {\r\nkey->payload.value = 0;\r\nmemcpy(&key->payload.value, prep->data, prep->datalen);\r\nkey->datalen = prep->datalen;\r\nreturn 0;\r\n}\r\npayload = kmemdup(prep->data, prep->datalen, GFP_KERNEL);\r\nif (!payload)\r\nreturn -ENOMEM;\r\nkey->payload.data = payload;\r\nkey->datalen = prep->datalen;\r\nreturn 0;\r\n}\r\nstatic inline void\r\ncifs_idmap_key_destroy(struct key *key)\r\n{\r\nif (key->datalen > sizeof(key->payload))\r\nkfree(key->payload.data);\r\n}\r\nstatic char *\r\nsid_to_key_str(struct cifs_sid *sidptr, unsigned int type)\r\n{\r\nint i, len;\r\nunsigned int saval;\r\nchar *sidstr, *strptr;\r\nunsigned long long id_auth_val;\r\nsidstr = kmalloc(3 + SID_STRING_BASE_SIZE +\r\n(SID_STRING_SUBAUTH_SIZE * sidptr->num_subauth),\r\nGFP_KERNEL);\r\nif (!sidstr)\r\nreturn sidstr;\r\nstrptr = sidstr;\r\nlen = sprintf(strptr, "%cs:S-%hhu", type == SIDOWNER ? 'o' : 'g',\r\nsidptr->revision);\r\nstrptr += len;\r\nid_auth_val = (unsigned long long)sidptr->authority[5];\r\nid_auth_val |= (unsigned long long)sidptr->authority[4] << 8;\r\nid_auth_val |= (unsigned long long)sidptr->authority[3] << 16;\r\nid_auth_val |= (unsigned long long)sidptr->authority[2] << 24;\r\nid_auth_val |= (unsigned long long)sidptr->authority[1] << 32;\r\nid_auth_val |= (unsigned long long)sidptr->authority[0] << 48;\r\nif (id_auth_val <= UINT_MAX)\r\nlen = sprintf(strptr, "-%llu", id_auth_val);\r\nelse\r\nlen = sprintf(strptr, "-0x%llx", id_auth_val);\r\nstrptr += len;\r\nfor (i = 0; i < sidptr->num_subauth; ++i) {\r\nsaval = le32_to_cpu(sidptr->sub_auth[i]);\r\nlen = sprintf(strptr, "-%u", saval);\r\nstrptr += len;\r\n}\r\nreturn sidstr;\r\n}\r\nstatic int\r\ncompare_sids(const struct cifs_sid *ctsid, const struct cifs_sid *cwsid)\r\n{\r\nint i;\r\nint num_subauth, num_sat, num_saw;\r\nif ((!ctsid) || (!cwsid))\r\nreturn 1;\r\nif (ctsid->revision != cwsid->revision) {\r\nif (ctsid->revision > cwsid->revision)\r\nreturn 1;\r\nelse\r\nreturn -1;\r\n}\r\nfor (i = 0; i < NUM_AUTHS; ++i) {\r\nif (ctsid->authority[i] != cwsid->authority[i]) {\r\nif (ctsid->authority[i] > cwsid->authority[i])\r\nreturn 1;\r\nelse\r\nreturn -1;\r\n}\r\n}\r\nnum_sat = ctsid->num_subauth;\r\nnum_saw = cwsid->num_subauth;\r\nnum_subauth = num_sat < num_saw ? num_sat : num_saw;\r\nif (num_subauth) {\r\nfor (i = 0; i < num_subauth; ++i) {\r\nif (ctsid->sub_auth[i] != cwsid->sub_auth[i]) {\r\nif (le32_to_cpu(ctsid->sub_auth[i]) >\r\nle32_to_cpu(cwsid->sub_auth[i]))\r\nreturn 1;\r\nelse\r\nreturn -1;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ncifs_copy_sid(struct cifs_sid *dst, const struct cifs_sid *src)\r\n{\r\nint i;\r\ndst->revision = src->revision;\r\ndst->num_subauth = min_t(u8, src->num_subauth, SID_MAX_SUB_AUTHORITIES);\r\nfor (i = 0; i < NUM_AUTHS; ++i)\r\ndst->authority[i] = src->authority[i];\r\nfor (i = 0; i < dst->num_subauth; ++i)\r\ndst->sub_auth[i] = src->sub_auth[i];\r\n}\r\nstatic int\r\nid_to_sid(unsigned int cid, uint sidtype, struct cifs_sid *ssid)\r\n{\r\nint rc;\r\nstruct key *sidkey;\r\nstruct cifs_sid *ksid;\r\nunsigned int ksid_size;\r\nchar desc[3 + 10 + 1];\r\nconst struct cred *saved_cred;\r\nrc = snprintf(desc, sizeof(desc), "%ci:%u",\r\nsidtype == SIDOWNER ? 'o' : 'g', cid);\r\nif (rc >= sizeof(desc))\r\nreturn -EINVAL;\r\nrc = 0;\r\nsaved_cred = override_creds(root_cred);\r\nsidkey = request_key(&cifs_idmap_key_type, desc, "");\r\nif (IS_ERR(sidkey)) {\r\nrc = -EINVAL;\r\ncifs_dbg(FYI, "%s: Can't map %cid %u to a SID\n",\r\n__func__, sidtype == SIDOWNER ? 'u' : 'g', cid);\r\ngoto out_revert_creds;\r\n} else if (sidkey->datalen < CIFS_SID_BASE_SIZE) {\r\nrc = -EIO;\r\ncifs_dbg(FYI, "%s: Downcall contained malformed key (datalen=%hu)\n",\r\n__func__, sidkey->datalen);\r\ngoto invalidate_key;\r\n}\r\nksid = sidkey->datalen <= sizeof(sidkey->payload) ?\r\n(struct cifs_sid *)&sidkey->payload.value :\r\n(struct cifs_sid *)sidkey->payload.data;\r\nksid_size = CIFS_SID_BASE_SIZE + (ksid->num_subauth * sizeof(__le32));\r\nif (ksid_size > sidkey->datalen) {\r\nrc = -EIO;\r\ncifs_dbg(FYI, "%s: Downcall contained malformed key (datalen=%hu, ksid_size=%u)\n",\r\n__func__, sidkey->datalen, ksid_size);\r\ngoto invalidate_key;\r\n}\r\ncifs_copy_sid(ssid, ksid);\r\nout_key_put:\r\nkey_put(sidkey);\r\nout_revert_creds:\r\nrevert_creds(saved_cred);\r\nreturn rc;\r\ninvalidate_key:\r\nkey_invalidate(sidkey);\r\ngoto out_key_put;\r\n}\r\nstatic int\r\nsid_to_id(struct cifs_sb_info *cifs_sb, struct cifs_sid *psid,\r\nstruct cifs_fattr *fattr, uint sidtype)\r\n{\r\nint rc;\r\nstruct key *sidkey;\r\nchar *sidstr;\r\nconst struct cred *saved_cred;\r\nkuid_t fuid = cifs_sb->mnt_uid;\r\nkgid_t fgid = cifs_sb->mnt_gid;\r\nif (unlikely(psid->num_subauth > SID_MAX_SUB_AUTHORITIES)) {\r\ncifs_dbg(FYI, "%s: %u subauthorities is too many!\n",\r\n__func__, psid->num_subauth);\r\nreturn -EIO;\r\n}\r\nsidstr = sid_to_key_str(psid, sidtype);\r\nif (!sidstr)\r\nreturn -ENOMEM;\r\nsaved_cred = override_creds(root_cred);\r\nsidkey = request_key(&cifs_idmap_key_type, sidstr, "");\r\nif (IS_ERR(sidkey)) {\r\nrc = -EINVAL;\r\ncifs_dbg(FYI, "%s: Can't map SID %s to a %cid\n",\r\n__func__, sidstr, sidtype == SIDOWNER ? 'u' : 'g');\r\ngoto out_revert_creds;\r\n}\r\nBUILD_BUG_ON(sizeof(uid_t) != sizeof(gid_t));\r\nif (sidkey->datalen != sizeof(uid_t)) {\r\nrc = -EIO;\r\ncifs_dbg(FYI, "%s: Downcall contained malformed key (datalen=%hu)\n",\r\n__func__, sidkey->datalen);\r\nkey_invalidate(sidkey);\r\ngoto out_key_put;\r\n}\r\nif (sidtype == SIDOWNER) {\r\nkuid_t uid;\r\nuid_t id;\r\nmemcpy(&id, &sidkey->payload.value, sizeof(uid_t));\r\nuid = make_kuid(&init_user_ns, id);\r\nif (uid_valid(uid))\r\nfuid = uid;\r\n} else {\r\nkgid_t gid;\r\ngid_t id;\r\nmemcpy(&id, &sidkey->payload.value, sizeof(gid_t));\r\ngid = make_kgid(&init_user_ns, id);\r\nif (gid_valid(gid))\r\nfgid = gid;\r\n}\r\nout_key_put:\r\nkey_put(sidkey);\r\nout_revert_creds:\r\nrevert_creds(saved_cred);\r\nkfree(sidstr);\r\nif (sidtype == SIDOWNER)\r\nfattr->cf_uid = fuid;\r\nelse\r\nfattr->cf_gid = fgid;\r\nreturn 0;\r\n}\r\nint\r\ninit_cifs_idmap(void)\r\n{\r\nstruct cred *cred;\r\nstruct key *keyring;\r\nint ret;\r\ncifs_dbg(FYI, "Registering the %s key type\n",\r\ncifs_idmap_key_type.name);\r\ncred = prepare_kernel_cred(NULL);\r\nif (!cred)\r\nreturn -ENOMEM;\r\nkeyring = keyring_alloc(".cifs_idmap",\r\nGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\r\n(KEY_POS_ALL & ~KEY_POS_SETATTR) |\r\nKEY_USR_VIEW | KEY_USR_READ,\r\nKEY_ALLOC_NOT_IN_QUOTA, NULL);\r\nif (IS_ERR(keyring)) {\r\nret = PTR_ERR(keyring);\r\ngoto failed_put_cred;\r\n}\r\nret = register_key_type(&cifs_idmap_key_type);\r\nif (ret < 0)\r\ngoto failed_put_key;\r\nset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\r\ncred->thread_keyring = keyring;\r\ncred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\r\nroot_cred = cred;\r\ncifs_dbg(FYI, "cifs idmap keyring: %d\n", key_serial(keyring));\r\nreturn 0;\r\nfailed_put_key:\r\nkey_put(keyring);\r\nfailed_put_cred:\r\nput_cred(cred);\r\nreturn ret;\r\n}\r\nvoid\r\nexit_cifs_idmap(void)\r\n{\r\nkey_revoke(root_cred->thread_keyring);\r\nunregister_key_type(&cifs_idmap_key_type);\r\nput_cred(root_cred);\r\ncifs_dbg(FYI, "Unregistered %s key type\n", cifs_idmap_key_type.name);\r\n}\r\nstatic void copy_sec_desc(const struct cifs_ntsd *pntsd,\r\nstruct cifs_ntsd *pnntsd, __u32 sidsoffset)\r\n{\r\nstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\r\nstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\r\npnntsd->revision = pntsd->revision;\r\npnntsd->type = pntsd->type;\r\npnntsd->dacloffset = cpu_to_le32(sizeof(struct cifs_ntsd));\r\npnntsd->sacloffset = 0;\r\npnntsd->osidoffset = cpu_to_le32(sidsoffset);\r\npnntsd->gsidoffset = cpu_to_le32(sidsoffset + sizeof(struct cifs_sid));\r\nowner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\r\nle32_to_cpu(pntsd->osidoffset));\r\nnowner_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset);\r\ncifs_copy_sid(nowner_sid_ptr, owner_sid_ptr);\r\ngroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\r\nle32_to_cpu(pntsd->gsidoffset));\r\nngroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset +\r\nsizeof(struct cifs_sid));\r\ncifs_copy_sid(ngroup_sid_ptr, group_sid_ptr);\r\nreturn;\r\n}\r\nstatic void access_flags_to_mode(__le32 ace_flags, int type, umode_t *pmode,\r\numode_t *pbits_to_set)\r\n{\r\n__u32 flags = le32_to_cpu(ace_flags);\r\nif (type == ACCESS_DENIED) {\r\nif (flags & GENERIC_ALL)\r\n*pbits_to_set &= ~S_IRWXUGO;\r\nif ((flags & GENERIC_WRITE) ||\r\n((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\r\n*pbits_to_set &= ~S_IWUGO;\r\nif ((flags & GENERIC_READ) ||\r\n((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\r\n*pbits_to_set &= ~S_IRUGO;\r\nif ((flags & GENERIC_EXECUTE) ||\r\n((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\r\n*pbits_to_set &= ~S_IXUGO;\r\nreturn;\r\n} else if (type != ACCESS_ALLOWED) {\r\ncifs_dbg(VFS, "unknown access control type %d\n", type);\r\nreturn;\r\n}\r\nif (flags & GENERIC_ALL) {\r\n*pmode |= (S_IRWXUGO & (*pbits_to_set));\r\ncifs_dbg(NOISY, "all perms\n");\r\nreturn;\r\n}\r\nif ((flags & GENERIC_WRITE) ||\r\n((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\r\n*pmode |= (S_IWUGO & (*pbits_to_set));\r\nif ((flags & GENERIC_READ) ||\r\n((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\r\n*pmode |= (S_IRUGO & (*pbits_to_set));\r\nif ((flags & GENERIC_EXECUTE) ||\r\n((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\r\n*pmode |= (S_IXUGO & (*pbits_to_set));\r\ncifs_dbg(NOISY, "access flags 0x%x mode now 0x%x\n", flags, *pmode);\r\nreturn;\r\n}\r\nstatic void mode_to_access_flags(umode_t mode, umode_t bits_to_use,\r\n__u32 *pace_flags)\r\n{\r\n*pace_flags = 0x0;\r\nmode &= bits_to_use;\r\nif (mode & S_IRUGO)\r\n*pace_flags |= SET_FILE_READ_RIGHTS;\r\nif (mode & S_IWUGO)\r\n*pace_flags |= SET_FILE_WRITE_RIGHTS;\r\nif (mode & S_IXUGO)\r\n*pace_flags |= SET_FILE_EXEC_RIGHTS;\r\ncifs_dbg(NOISY, "mode: 0x%x, access flags now 0x%x\n",\r\nmode, *pace_flags);\r\nreturn;\r\n}\r\nstatic __u16 fill_ace_for_sid(struct cifs_ace *pntace,\r\nconst struct cifs_sid *psid, __u64 nmode, umode_t bits)\r\n{\r\nint i;\r\n__u16 size = 0;\r\n__u32 access_req = 0;\r\npntace->type = ACCESS_ALLOWED;\r\npntace->flags = 0x0;\r\nmode_to_access_flags(nmode, bits, &access_req);\r\nif (!access_req)\r\naccess_req = SET_MINIMUM_RIGHTS;\r\npntace->access_req = cpu_to_le32(access_req);\r\npntace->sid.revision = psid->revision;\r\npntace->sid.num_subauth = psid->num_subauth;\r\nfor (i = 0; i < NUM_AUTHS; i++)\r\npntace->sid.authority[i] = psid->authority[i];\r\nfor (i = 0; i < psid->num_subauth; i++)\r\npntace->sid.sub_auth[i] = psid->sub_auth[i];\r\nsize = 1 + 1 + 2 + 4 + 1 + 1 + 6 + (psid->num_subauth * 4);\r\npntace->size = cpu_to_le16(size);\r\nreturn size;\r\n}\r\nstatic void dump_ace(struct cifs_ace *pace, char *end_of_acl)\r\n{\r\nint num_subauth;\r\nif (le16_to_cpu(pace->size) < 16) {\r\ncifs_dbg(VFS, "ACE too small %d\n", le16_to_cpu(pace->size));\r\nreturn;\r\n}\r\nif (end_of_acl < (char *)pace + le16_to_cpu(pace->size)) {\r\ncifs_dbg(VFS, "ACL too small to parse ACE\n");\r\nreturn;\r\n}\r\nnum_subauth = pace->sid.num_subauth;\r\nif (num_subauth) {\r\nint i;\r\ncifs_dbg(FYI, "ACE revision %d num_auth %d type %d flags %d size %d\n",\r\npace->sid.revision, pace->sid.num_subauth, pace->type,\r\npace->flags, le16_to_cpu(pace->size));\r\nfor (i = 0; i < num_subauth; ++i) {\r\ncifs_dbg(FYI, "ACE sub_auth[%d]: 0x%x\n",\r\ni, le32_to_cpu(pace->sid.sub_auth[i]));\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic void parse_dacl(struct cifs_acl *pdacl, char *end_of_acl,\r\nstruct cifs_sid *pownersid, struct cifs_sid *pgrpsid,\r\nstruct cifs_fattr *fattr)\r\n{\r\nint i;\r\nint num_aces = 0;\r\nint acl_size;\r\nchar *acl_base;\r\nstruct cifs_ace **ppace;\r\nif (!pdacl) {\r\nfattr->cf_mode |= S_IRWXUGO;\r\nreturn;\r\n}\r\nif (end_of_acl < (char *)pdacl + le16_to_cpu(pdacl->size)) {\r\ncifs_dbg(VFS, "ACL too small to parse DACL\n");\r\nreturn;\r\n}\r\ncifs_dbg(NOISY, "DACL revision %d size %d num aces %d\n",\r\nle16_to_cpu(pdacl->revision), le16_to_cpu(pdacl->size),\r\nle32_to_cpu(pdacl->num_aces));\r\nfattr->cf_mode &= ~(S_IRWXUGO);\r\nacl_base = (char *)pdacl;\r\nacl_size = sizeof(struct cifs_acl);\r\nnum_aces = le32_to_cpu(pdacl->num_aces);\r\nif (num_aces > 0) {\r\numode_t user_mask = S_IRWXU;\r\numode_t group_mask = S_IRWXG;\r\numode_t other_mask = S_IRWXU | S_IRWXG | S_IRWXO;\r\nif (num_aces > ULONG_MAX / sizeof(struct cifs_ace *))\r\nreturn;\r\nppace = kmalloc(num_aces * sizeof(struct cifs_ace *),\r\nGFP_KERNEL);\r\nif (!ppace)\r\nreturn;\r\nfor (i = 0; i < num_aces; ++i) {\r\nppace[i] = (struct cifs_ace *) (acl_base + acl_size);\r\n#ifdef CONFIG_CIFS_DEBUG2\r\ndump_ace(ppace[i], end_of_acl);\r\n#endif\r\nif (compare_sids(&(ppace[i]->sid), pownersid) == 0)\r\naccess_flags_to_mode(ppace[i]->access_req,\r\nppace[i]->type,\r\n&fattr->cf_mode,\r\n&user_mask);\r\nif (compare_sids(&(ppace[i]->sid), pgrpsid) == 0)\r\naccess_flags_to_mode(ppace[i]->access_req,\r\nppace[i]->type,\r\n&fattr->cf_mode,\r\n&group_mask);\r\nif (compare_sids(&(ppace[i]->sid), &sid_everyone) == 0)\r\naccess_flags_to_mode(ppace[i]->access_req,\r\nppace[i]->type,\r\n&fattr->cf_mode,\r\n&other_mask);\r\nif (compare_sids(&(ppace[i]->sid), &sid_authusers) == 0)\r\naccess_flags_to_mode(ppace[i]->access_req,\r\nppace[i]->type,\r\n&fattr->cf_mode,\r\n&other_mask);\r\nacl_base = (char *)ppace[i];\r\nacl_size = le16_to_cpu(ppace[i]->size);\r\n}\r\nkfree(ppace);\r\n}\r\nreturn;\r\n}\r\nstatic int set_chmod_dacl(struct cifs_acl *pndacl, struct cifs_sid *pownersid,\r\nstruct cifs_sid *pgrpsid, __u64 nmode)\r\n{\r\nu16 size = 0;\r\nstruct cifs_acl *pnndacl;\r\npnndacl = (struct cifs_acl *)((char *)pndacl + sizeof(struct cifs_acl));\r\nsize += fill_ace_for_sid((struct cifs_ace *) ((char *)pnndacl + size),\r\npownersid, nmode, S_IRWXU);\r\nsize += fill_ace_for_sid((struct cifs_ace *)((char *)pnndacl + size),\r\npgrpsid, nmode, S_IRWXG);\r\nsize += fill_ace_for_sid((struct cifs_ace *)((char *)pnndacl + size),\r\n&sid_everyone, nmode, S_IRWXO);\r\npndacl->size = cpu_to_le16(size + sizeof(struct cifs_acl));\r\npndacl->num_aces = cpu_to_le32(3);\r\nreturn 0;\r\n}\r\nstatic int parse_sid(struct cifs_sid *psid, char *end_of_acl)\r\n{\r\nif (end_of_acl < (char *)psid + 8) {\r\ncifs_dbg(VFS, "ACL too small to parse SID %p\n", psid);\r\nreturn -EINVAL;\r\n}\r\n#ifdef CONFIG_CIFS_DEBUG2\r\nif (psid->num_subauth) {\r\nint i;\r\ncifs_dbg(FYI, "SID revision %d num_auth %d\n",\r\npsid->revision, psid->num_subauth);\r\nfor (i = 0; i < psid->num_subauth; i++) {\r\ncifs_dbg(FYI, "SID sub_auth[%d]: 0x%x\n",\r\ni, le32_to_cpu(psid->sub_auth[i]));\r\n}\r\ncifs_dbg(FYI, "RID 0x%x\n",\r\nle32_to_cpu(psid->sub_auth[psid->num_subauth-1]));\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int parse_sec_desc(struct cifs_sb_info *cifs_sb,\r\nstruct cifs_ntsd *pntsd, int acl_len, struct cifs_fattr *fattr)\r\n{\r\nint rc = 0;\r\nstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\r\nstruct cifs_acl *dacl_ptr;\r\nchar *end_of_acl = ((char *)pntsd) + acl_len;\r\n__u32 dacloffset;\r\nif (pntsd == NULL)\r\nreturn -EIO;\r\nowner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\r\nle32_to_cpu(pntsd->osidoffset));\r\ngroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\r\nle32_to_cpu(pntsd->gsidoffset));\r\ndacloffset = le32_to_cpu(pntsd->dacloffset);\r\ndacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\r\ncifs_dbg(NOISY, "revision %d type 0x%x ooffset 0x%x goffset 0x%x sacloffset 0x%x dacloffset 0x%x\n",\r\npntsd->revision, pntsd->type, le32_to_cpu(pntsd->osidoffset),\r\nle32_to_cpu(pntsd->gsidoffset),\r\nle32_to_cpu(pntsd->sacloffset), dacloffset);\r\nrc = parse_sid(owner_sid_ptr, end_of_acl);\r\nif (rc) {\r\ncifs_dbg(FYI, "%s: Error %d parsing Owner SID\n", __func__, rc);\r\nreturn rc;\r\n}\r\nrc = sid_to_id(cifs_sb, owner_sid_ptr, fattr, SIDOWNER);\r\nif (rc) {\r\ncifs_dbg(FYI, "%s: Error %d mapping Owner SID to uid\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nrc = parse_sid(group_sid_ptr, end_of_acl);\r\nif (rc) {\r\ncifs_dbg(FYI, "%s: Error %d mapping Owner SID to gid\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nrc = sid_to_id(cifs_sb, group_sid_ptr, fattr, SIDGROUP);\r\nif (rc) {\r\ncifs_dbg(FYI, "%s: Error %d mapping Group SID to gid\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nif (dacloffset)\r\nparse_dacl(dacl_ptr, end_of_acl, owner_sid_ptr,\r\ngroup_sid_ptr, fattr);\r\nelse\r\ncifs_dbg(FYI, "no ACL\n");\r\nreturn rc;\r\n}\r\nstatic int build_sec_desc(struct cifs_ntsd *pntsd, struct cifs_ntsd *pnntsd,\r\n__u32 secdesclen, __u64 nmode, kuid_t uid, kgid_t gid, int *aclflag)\r\n{\r\nint rc = 0;\r\n__u32 dacloffset;\r\n__u32 ndacloffset;\r\n__u32 sidsoffset;\r\nstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\r\nstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\r\nstruct cifs_acl *dacl_ptr = NULL;\r\nstruct cifs_acl *ndacl_ptr = NULL;\r\nif (nmode != NO_CHANGE_64) {\r\nowner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\r\nle32_to_cpu(pntsd->osidoffset));\r\ngroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\r\nle32_to_cpu(pntsd->gsidoffset));\r\ndacloffset = le32_to_cpu(pntsd->dacloffset);\r\ndacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\r\nndacloffset = sizeof(struct cifs_ntsd);\r\nndacl_ptr = (struct cifs_acl *)((char *)pnntsd + ndacloffset);\r\nndacl_ptr->revision = dacl_ptr->revision;\r\nndacl_ptr->size = 0;\r\nndacl_ptr->num_aces = 0;\r\nrc = set_chmod_dacl(ndacl_ptr, owner_sid_ptr, group_sid_ptr,\r\nnmode);\r\nsidsoffset = ndacloffset + le16_to_cpu(ndacl_ptr->size);\r\ncopy_sec_desc(pntsd, pnntsd, sidsoffset);\r\n*aclflag = CIFS_ACL_DACL;\r\n} else {\r\nmemcpy(pnntsd, pntsd, secdesclen);\r\nif (uid_valid(uid)) {\r\nuid_t id;\r\nowner_sid_ptr = (struct cifs_sid *)((char *)pnntsd +\r\nle32_to_cpu(pnntsd->osidoffset));\r\nnowner_sid_ptr = kmalloc(sizeof(struct cifs_sid),\r\nGFP_KERNEL);\r\nif (!nowner_sid_ptr)\r\nreturn -ENOMEM;\r\nid = from_kuid(&init_user_ns, uid);\r\nrc = id_to_sid(id, SIDOWNER, nowner_sid_ptr);\r\nif (rc) {\r\ncifs_dbg(FYI, "%s: Mapping error %d for owner id %d\n",\r\n__func__, rc, id);\r\nkfree(nowner_sid_ptr);\r\nreturn rc;\r\n}\r\ncifs_copy_sid(owner_sid_ptr, nowner_sid_ptr);\r\nkfree(nowner_sid_ptr);\r\n*aclflag = CIFS_ACL_OWNER;\r\n}\r\nif (gid_valid(gid)) {\r\ngid_t id;\r\ngroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd +\r\nle32_to_cpu(pnntsd->gsidoffset));\r\nngroup_sid_ptr = kmalloc(sizeof(struct cifs_sid),\r\nGFP_KERNEL);\r\nif (!ngroup_sid_ptr)\r\nreturn -ENOMEM;\r\nid = from_kgid(&init_user_ns, gid);\r\nrc = id_to_sid(id, SIDGROUP, ngroup_sid_ptr);\r\nif (rc) {\r\ncifs_dbg(FYI, "%s: Mapping error %d for group id %d\n",\r\n__func__, rc, id);\r\nkfree(ngroup_sid_ptr);\r\nreturn rc;\r\n}\r\ncifs_copy_sid(group_sid_ptr, ngroup_sid_ptr);\r\nkfree(ngroup_sid_ptr);\r\n*aclflag = CIFS_ACL_GROUP;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic struct cifs_ntsd *get_cifs_acl_by_fid(struct cifs_sb_info *cifs_sb,\r\n__u16 fid, u32 *pacllen)\r\n{\r\nstruct cifs_ntsd *pntsd = NULL;\r\nunsigned int xid;\r\nint rc;\r\nstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\r\nif (IS_ERR(tlink))\r\nreturn ERR_CAST(tlink);\r\nxid = get_xid();\r\nrc = CIFSSMBGetCIFSACL(xid, tlink_tcon(tlink), fid, &pntsd, pacllen);\r\nfree_xid(xid);\r\ncifs_put_tlink(tlink);\r\ncifs_dbg(FYI, "%s: rc = %d ACL len %d\n", __func__, rc, *pacllen);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\nreturn pntsd;\r\n}\r\nstatic struct cifs_ntsd *get_cifs_acl_by_path(struct cifs_sb_info *cifs_sb,\r\nconst char *path, u32 *pacllen)\r\n{\r\nstruct cifs_ntsd *pntsd = NULL;\r\nint oplock = 0;\r\nunsigned int xid;\r\nint rc, create_options = 0;\r\n__u16 fid;\r\nstruct cifs_tcon *tcon;\r\nstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\r\nif (IS_ERR(tlink))\r\nreturn ERR_CAST(tlink);\r\ntcon = tlink_tcon(tlink);\r\nxid = get_xid();\r\nif (backup_cred(cifs_sb))\r\ncreate_options |= CREATE_OPEN_BACKUP_INTENT;\r\nrc = CIFSSMBOpen(xid, tcon, path, FILE_OPEN, READ_CONTROL,\r\ncreate_options, &fid, &oplock, NULL, cifs_sb->local_nls,\r\ncifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\r\nif (!rc) {\r\nrc = CIFSSMBGetCIFSACL(xid, tcon, fid, &pntsd, pacllen);\r\nCIFSSMBClose(xid, tcon, fid);\r\n}\r\ncifs_put_tlink(tlink);\r\nfree_xid(xid);\r\ncifs_dbg(FYI, "%s: rc = %d ACL len %d\n", __func__, rc, *pacllen);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\nreturn pntsd;\r\n}\r\nstruct cifs_ntsd *get_cifs_acl(struct cifs_sb_info *cifs_sb,\r\nstruct inode *inode, const char *path,\r\nu32 *pacllen)\r\n{\r\nstruct cifs_ntsd *pntsd = NULL;\r\nstruct cifsFileInfo *open_file = NULL;\r\nif (inode)\r\nopen_file = find_readable_file(CIFS_I(inode), true);\r\nif (!open_file)\r\nreturn get_cifs_acl_by_path(cifs_sb, path, pacllen);\r\npntsd = get_cifs_acl_by_fid(cifs_sb, open_file->fid.netfid, pacllen);\r\ncifsFileInfo_put(open_file);\r\nreturn pntsd;\r\n}\r\nint set_cifs_acl(struct cifs_ntsd *pnntsd, __u32 acllen,\r\nstruct inode *inode, const char *path, int aclflag)\r\n{\r\nint oplock = 0;\r\nunsigned int xid;\r\nint rc, access_flags, create_options = 0;\r\n__u16 fid;\r\nstruct cifs_tcon *tcon;\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\r\nstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\r\nif (IS_ERR(tlink))\r\nreturn PTR_ERR(tlink);\r\ntcon = tlink_tcon(tlink);\r\nxid = get_xid();\r\nif (backup_cred(cifs_sb))\r\ncreate_options |= CREATE_OPEN_BACKUP_INTENT;\r\nif (aclflag == CIFS_ACL_OWNER || aclflag == CIFS_ACL_GROUP)\r\naccess_flags = WRITE_OWNER;\r\nelse\r\naccess_flags = WRITE_DAC;\r\nrc = CIFSSMBOpen(xid, tcon, path, FILE_OPEN, access_flags,\r\ncreate_options, &fid, &oplock, NULL, cifs_sb->local_nls,\r\ncifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\r\nif (rc) {\r\ncifs_dbg(VFS, "Unable to open file to set ACL\n");\r\ngoto out;\r\n}\r\nrc = CIFSSMBSetCIFSACL(xid, tcon, fid, pnntsd, acllen, aclflag);\r\ncifs_dbg(NOISY, "SetCIFSACL rc = %d\n", rc);\r\nCIFSSMBClose(xid, tcon, fid);\r\nout:\r\nfree_xid(xid);\r\ncifs_put_tlink(tlink);\r\nreturn rc;\r\n}\r\nint\r\ncifs_acl_to_fattr(struct cifs_sb_info *cifs_sb, struct cifs_fattr *fattr,\r\nstruct inode *inode, const char *path, const __u16 *pfid)\r\n{\r\nstruct cifs_ntsd *pntsd = NULL;\r\nu32 acllen = 0;\r\nint rc = 0;\r\ncifs_dbg(NOISY, "converting ACL to mode for %s\n", path);\r\nif (pfid)\r\npntsd = get_cifs_acl_by_fid(cifs_sb, *pfid, &acllen);\r\nelse\r\npntsd = get_cifs_acl(cifs_sb, inode, path, &acllen);\r\nif (IS_ERR(pntsd)) {\r\nrc = PTR_ERR(pntsd);\r\ncifs_dbg(VFS, "%s: error %d getting sec desc\n", __func__, rc);\r\n} else {\r\nrc = parse_sec_desc(cifs_sb, pntsd, acllen, fattr);\r\nkfree(pntsd);\r\nif (rc)\r\ncifs_dbg(VFS, "parse sec desc failed rc = %d\n", rc);\r\n}\r\nreturn rc;\r\n}\r\nint\r\nid_mode_to_cifs_acl(struct inode *inode, const char *path, __u64 nmode,\r\nkuid_t uid, kgid_t gid)\r\n{\r\nint rc = 0;\r\nint aclflag = CIFS_ACL_DACL;\r\n__u32 secdesclen = 0;\r\nstruct cifs_ntsd *pntsd = NULL;\r\nstruct cifs_ntsd *pnntsd = NULL;\r\ncifs_dbg(NOISY, "set ACL from mode for %s\n", path);\r\npntsd = get_cifs_acl(CIFS_SB(inode->i_sb), inode, path, &secdesclen);\r\nif (IS_ERR(pntsd)) {\r\nrc = PTR_ERR(pntsd);\r\ncifs_dbg(VFS, "%s: error %d getting sec desc\n", __func__, rc);\r\ngoto out;\r\n}\r\nsecdesclen = max_t(u32, secdesclen, DEFAULT_SEC_DESC_LEN);\r\npnntsd = kmalloc(secdesclen, GFP_KERNEL);\r\nif (!pnntsd) {\r\nkfree(pntsd);\r\nreturn -ENOMEM;\r\n}\r\nrc = build_sec_desc(pntsd, pnntsd, secdesclen, nmode, uid, gid,\r\n&aclflag);\r\ncifs_dbg(NOISY, "build_sec_desc rc: %d\n", rc);\r\nif (!rc) {\r\nrc = set_cifs_acl(pnntsd, secdesclen, inode, path, aclflag);\r\ncifs_dbg(NOISY, "set_cifs_acl rc: %d\n", rc);\r\n}\r\nkfree(pnntsd);\r\nkfree(pntsd);\r\nout:\r\nreturn rc;\r\n}
