struct ip_vs_pe *__ip_vs_pe_getbyname(const char *pe_name)\r\n{\r\nstruct ip_vs_pe *pe;\r\nIP_VS_DBG(10, "%s(): pe_name \"%s\"\n", __func__,\r\npe_name);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(pe, &ip_vs_pe, n_list) {\r\nif (pe->module &&\r\n!try_module_get(pe->module)) {\r\ncontinue;\r\n}\r\nif (strcmp(pe_name, pe->name)==0) {\r\nrcu_read_unlock();\r\nreturn pe;\r\n}\r\nif (pe->module)\r\nmodule_put(pe->module);\r\n}\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nstruct ip_vs_pe *ip_vs_pe_getbyname(const char *name)\r\n{\r\nstruct ip_vs_pe *pe;\r\npe = __ip_vs_pe_getbyname(name);\r\nif (!pe) {\r\nrequest_module("ip_vs_pe_%s", name);\r\npe = __ip_vs_pe_getbyname(name);\r\n}\r\nreturn pe;\r\n}\r\nint register_ip_vs_pe(struct ip_vs_pe *pe)\r\n{\r\nstruct ip_vs_pe *tmp;\r\nip_vs_use_count_inc();\r\nmutex_lock(&ip_vs_pe_mutex);\r\nlist_for_each_entry(tmp, &ip_vs_pe, n_list) {\r\nif (strcmp(tmp->name, pe->name) == 0) {\r\nmutex_unlock(&ip_vs_pe_mutex);\r\nip_vs_use_count_dec();\r\npr_err("%s(): [%s] pe already existed "\r\n"in the system\n", __func__, pe->name);\r\nreturn -EINVAL;\r\n}\r\n}\r\nlist_add_rcu(&pe->n_list, &ip_vs_pe);\r\nmutex_unlock(&ip_vs_pe_mutex);\r\npr_info("[%s] pe registered.\n", pe->name);\r\nreturn 0;\r\n}\r\nint unregister_ip_vs_pe(struct ip_vs_pe *pe)\r\n{\r\nmutex_lock(&ip_vs_pe_mutex);\r\nlist_del_rcu(&pe->n_list);\r\nmutex_unlock(&ip_vs_pe_mutex);\r\nip_vs_use_count_dec();\r\npr_info("[%s] pe unregistered.\n", pe->name);\r\nreturn 0;\r\n}
