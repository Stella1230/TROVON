static void panel_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct panel_encoder *panel_encoder = to_panel_encoder(encoder);\r\ndrm_encoder_cleanup(encoder);\r\nkfree(panel_encoder);\r\n}\r\nstatic void panel_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct panel_encoder *panel_encoder = to_panel_encoder(encoder);\r\nstruct backlight_device *backlight = panel_encoder->mod->backlight;\r\nif (!backlight)\r\nreturn;\r\nbacklight->props.power = mode == DRM_MODE_DPMS_ON\r\n? FB_BLANK_UNBLANK : FB_BLANK_POWERDOWN;\r\nbacklight_update_status(backlight);\r\n}\r\nstatic bool panel_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void panel_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct panel_encoder *panel_encoder = to_panel_encoder(encoder);\r\npanel_encoder_dpms(encoder, DRM_MODE_DPMS_OFF);\r\ntilcdc_crtc_set_panel_info(encoder->crtc, panel_encoder->mod->info);\r\n}\r\nstatic void panel_encoder_commit(struct drm_encoder *encoder)\r\n{\r\npanel_encoder_dpms(encoder, DRM_MODE_DPMS_ON);\r\n}\r\nstatic void panel_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\n}\r\nstatic struct drm_encoder *panel_encoder_create(struct drm_device *dev,\r\nstruct panel_module *mod)\r\n{\r\nstruct panel_encoder *panel_encoder;\r\nstruct drm_encoder *encoder;\r\nint ret;\r\npanel_encoder = kzalloc(sizeof(*panel_encoder), GFP_KERNEL);\r\nif (!panel_encoder) {\r\ndev_err(dev->dev, "allocation failed\n");\r\nreturn NULL;\r\n}\r\npanel_encoder->mod = mod;\r\nencoder = &panel_encoder->base;\r\nencoder->possible_crtcs = 1;\r\nret = drm_encoder_init(dev, encoder, &panel_encoder_funcs,\r\nDRM_MODE_ENCODER_LVDS);\r\nif (ret < 0)\r\ngoto fail;\r\ndrm_encoder_helper_add(encoder, &panel_encoder_helper_funcs);\r\nreturn encoder;\r\nfail:\r\npanel_encoder_destroy(encoder);\r\nreturn NULL;\r\n}\r\nstatic void panel_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct panel_connector *panel_connector = to_panel_connector(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(panel_connector);\r\n}\r\nstatic enum drm_connector_status panel_connector_detect(\r\nstruct drm_connector *connector,\r\nbool force)\r\n{\r\nreturn connector_status_connected;\r\n}\r\nstatic int panel_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct panel_connector *panel_connector = to_panel_connector(connector);\r\nstruct display_timings *timings = panel_connector->mod->timings;\r\nint i;\r\nfor (i = 0; i < timings->num_timings; i++) {\r\nstruct drm_display_mode *mode = drm_mode_create(dev);\r\nstruct videomode vm;\r\nif (videomode_from_timings(timings, &vm, i))\r\nbreak;\r\ndrm_display_mode_from_videomode(&vm, mode);\r\nmode->type = DRM_MODE_TYPE_DRIVER;\r\nif (timings->native_mode == i)\r\nmode->type |= DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_set_name(mode);\r\ndrm_mode_probed_add(connector, mode);\r\n}\r\nreturn i;\r\n}\r\nstatic int panel_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct tilcdc_drm_private *priv = connector->dev->dev_private;\r\nreturn tilcdc_crtc_mode_valid(priv->crtc, mode);\r\n}\r\nstatic struct drm_encoder *panel_connector_best_encoder(\r\nstruct drm_connector *connector)\r\n{\r\nstruct panel_connector *panel_connector = to_panel_connector(connector);\r\nreturn panel_connector->encoder;\r\n}\r\nstatic struct drm_connector *panel_connector_create(struct drm_device *dev,\r\nstruct panel_module *mod, struct drm_encoder *encoder)\r\n{\r\nstruct panel_connector *panel_connector;\r\nstruct drm_connector *connector;\r\nint ret;\r\npanel_connector = kzalloc(sizeof(*panel_connector), GFP_KERNEL);\r\nif (!panel_connector) {\r\ndev_err(dev->dev, "allocation failed\n");\r\nreturn NULL;\r\n}\r\npanel_connector->encoder = encoder;\r\npanel_connector->mod = mod;\r\nconnector = &panel_connector->base;\r\ndrm_connector_init(dev, connector, &panel_connector_funcs,\r\nDRM_MODE_CONNECTOR_LVDS);\r\ndrm_connector_helper_add(connector, &panel_connector_helper_funcs);\r\nconnector->interlace_allowed = 0;\r\nconnector->doublescan_allowed = 0;\r\nret = drm_mode_connector_attach_encoder(connector, encoder);\r\nif (ret)\r\ngoto fail;\r\ndrm_sysfs_connector_add(connector);\r\nreturn connector;\r\nfail:\r\npanel_connector_destroy(connector);\r\nreturn NULL;\r\n}\r\nstatic int panel_modeset_init(struct tilcdc_module *mod, struct drm_device *dev)\r\n{\r\nstruct panel_module *panel_mod = to_panel_module(mod);\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\nstruct drm_encoder *encoder;\r\nstruct drm_connector *connector;\r\nencoder = panel_encoder_create(dev, panel_mod);\r\nif (!encoder)\r\nreturn -ENOMEM;\r\nconnector = panel_connector_create(dev, panel_mod, encoder);\r\nif (!connector)\r\nreturn -ENOMEM;\r\npriv->encoders[priv->num_encoders++] = encoder;\r\npriv->connectors[priv->num_connectors++] = connector;\r\nreturn 0;\r\n}\r\nstatic void panel_destroy(struct tilcdc_module *mod)\r\n{\r\nstruct panel_module *panel_mod = to_panel_module(mod);\r\nif (panel_mod->timings) {\r\ndisplay_timings_release(panel_mod->timings);\r\nkfree(panel_mod->timings);\r\n}\r\ntilcdc_module_cleanup(mod);\r\nkfree(panel_mod->info);\r\nkfree(panel_mod);\r\n}\r\nstatic struct tilcdc_panel_info *of_get_panel_info(struct device_node *np)\r\n{\r\nstruct device_node *info_np;\r\nstruct tilcdc_panel_info *info;\r\nint ret = 0;\r\nif (!np) {\r\npr_err("%s: no devicenode given\n", __func__);\r\nreturn NULL;\r\n}\r\ninfo_np = of_get_child_by_name(np, "panel-info");\r\nif (!info_np) {\r\npr_err("%s: could not find panel-info node\n", __func__);\r\nreturn NULL;\r\n}\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info) {\r\npr_err("%s: allocation failed\n", __func__);\r\nreturn NULL;\r\n}\r\nret |= of_property_read_u32(info_np, "ac-bias", &info->ac_bias);\r\nret |= of_property_read_u32(info_np, "ac-bias-intrpt", &info->ac_bias_intrpt);\r\nret |= of_property_read_u32(info_np, "dma-burst-sz", &info->dma_burst_sz);\r\nret |= of_property_read_u32(info_np, "bpp", &info->bpp);\r\nret |= of_property_read_u32(info_np, "fdd", &info->fdd);\r\nret |= of_property_read_u32(info_np, "sync-edge", &info->sync_edge);\r\nret |= of_property_read_u32(info_np, "sync-ctrl", &info->sync_ctrl);\r\nret |= of_property_read_u32(info_np, "raster-order", &info->raster_order);\r\nret |= of_property_read_u32(info_np, "fifo-th", &info->fifo_th);\r\ninfo->tft_alt_mode = of_property_read_bool(info_np, "tft-alt-mode");\r\ninfo->invert_pxl_clk = of_property_read_bool(info_np, "invert-pxl-clk");\r\nif (ret) {\r\npr_err("%s: error reading panel-info properties\n", __func__);\r\nkfree(info);\r\nreturn NULL;\r\n}\r\nreturn info;\r\n}\r\nstatic int panel_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct panel_module *panel_mod;\r\nstruct tilcdc_module *mod;\r\nstruct pinctrl *pinctrl;\r\nint ret = -EINVAL;\r\nif (!node) {\r\ndev_err(&pdev->dev, "device-tree data is missing\n");\r\nreturn -ENXIO;\r\n}\r\npanel_mod = kzalloc(sizeof(*panel_mod), GFP_KERNEL);\r\nif (!panel_mod)\r\nreturn -ENOMEM;\r\nmod = &panel_mod->base;\r\ntilcdc_module_init(mod, "panel", &panel_module_ops);\r\npinctrl = devm_pinctrl_get_select_default(&pdev->dev);\r\nif (IS_ERR(pinctrl))\r\ndev_warn(&pdev->dev, "pins are not configured\n");\r\npanel_mod->timings = of_get_display_timings(node);\r\nif (!panel_mod->timings) {\r\ndev_err(&pdev->dev, "could not get panel timings\n");\r\ngoto fail;\r\n}\r\npanel_mod->info = of_get_panel_info(node);\r\nif (!panel_mod->info) {\r\ndev_err(&pdev->dev, "could not get panel info\n");\r\ngoto fail;\r\n}\r\nmod->preferred_bpp = panel_mod->info->bpp;\r\npanel_mod->backlight = of_find_backlight_by_node(node);\r\nif (panel_mod->backlight)\r\ndev_info(&pdev->dev, "found backlight\n");\r\nreturn 0;\r\nfail:\r\npanel_destroy(mod);\r\nreturn ret;\r\n}\r\nstatic int panel_remove(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nint __init tilcdc_panel_init(void)\r\n{\r\nreturn platform_driver_register(&panel_driver);\r\n}\r\nvoid __exit tilcdc_panel_fini(void)\r\n{\r\nplatform_driver_unregister(&panel_driver);\r\n}
