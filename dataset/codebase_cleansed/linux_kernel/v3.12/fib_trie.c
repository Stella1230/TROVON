static inline struct tnode *node_parent(const struct rt_trie_node *node)\r\n{\r\nunsigned long parent;\r\nparent = rcu_dereference_index_check(node->parent, lockdep_rtnl_is_held());\r\nreturn (struct tnode *)(parent & ~NODE_TYPE_MASK);\r\n}\r\nstatic inline struct tnode *node_parent_rcu(const struct rt_trie_node *node)\r\n{\r\nunsigned long parent;\r\nparent = rcu_dereference_index_check(node->parent, rcu_read_lock_held() ||\r\nlockdep_rtnl_is_held());\r\nreturn (struct tnode *)(parent & ~NODE_TYPE_MASK);\r\n}\r\nstatic inline void node_set_parent(struct rt_trie_node *node, struct tnode *ptr)\r\n{\r\nsmp_wmb();\r\nnode->parent = (unsigned long)ptr | NODE_TYPE(node);\r\n}\r\nstatic inline struct rt_trie_node *tnode_get_child(const struct tnode *tn, unsigned int i)\r\n{\r\nBUG_ON(i >= 1U << tn->bits);\r\nreturn rtnl_dereference(tn->child[i]);\r\n}\r\nstatic inline struct rt_trie_node *tnode_get_child_rcu(const struct tnode *tn, unsigned int i)\r\n{\r\nBUG_ON(i >= 1U << tn->bits);\r\nreturn rcu_dereference_rtnl(tn->child[i]);\r\n}\r\nstatic inline int tnode_child_length(const struct tnode *tn)\r\n{\r\nreturn 1 << tn->bits;\r\n}\r\nstatic inline t_key mask_pfx(t_key k, unsigned int l)\r\n{\r\nreturn (l == 0) ? 0 : k >> (KEYLENGTH-l) << (KEYLENGTH-l);\r\n}\r\nstatic inline t_key tkey_extract_bits(t_key a, unsigned int offset, unsigned int bits)\r\n{\r\nif (offset < KEYLENGTH)\r\nreturn ((t_key)(a << offset)) >> (KEYLENGTH - bits);\r\nelse\r\nreturn 0;\r\n}\r\nstatic inline int tkey_equals(t_key a, t_key b)\r\n{\r\nreturn a == b;\r\n}\r\nstatic inline int tkey_sub_equals(t_key a, int offset, int bits, t_key b)\r\n{\r\nif (bits == 0 || offset >= KEYLENGTH)\r\nreturn 1;\r\nbits = bits > KEYLENGTH ? KEYLENGTH : bits;\r\nreturn ((a ^ b) << offset) >> (KEYLENGTH - bits) == 0;\r\n}\r\nstatic inline int tkey_mismatch(t_key a, int offset, t_key b)\r\n{\r\nt_key diff = a ^ b;\r\nint i = offset;\r\nif (!diff)\r\nreturn 0;\r\nwhile ((diff << i) >> (KEYLENGTH-1) == 0)\r\ni++;\r\nreturn i;\r\n}\r\nstatic inline void check_tnode(const struct tnode *tn)\r\n{\r\nWARN_ON(tn && tn->pos+tn->bits > 32);\r\n}\r\nstatic void __alias_free_mem(struct rcu_head *head)\r\n{\r\nstruct fib_alias *fa = container_of(head, struct fib_alias, rcu);\r\nkmem_cache_free(fn_alias_kmem, fa);\r\n}\r\nstatic inline void alias_free_mem_rcu(struct fib_alias *fa)\r\n{\r\ncall_rcu(&fa->rcu, __alias_free_mem);\r\n}\r\nstatic void __leaf_free_rcu(struct rcu_head *head)\r\n{\r\nstruct leaf *l = container_of(head, struct leaf, rcu);\r\nkmem_cache_free(trie_leaf_kmem, l);\r\n}\r\nstatic inline void free_leaf(struct leaf *l)\r\n{\r\ncall_rcu(&l->rcu, __leaf_free_rcu);\r\n}\r\nstatic inline void free_leaf_info(struct leaf_info *leaf)\r\n{\r\nkfree_rcu(leaf, rcu);\r\n}\r\nstatic struct tnode *tnode_alloc(size_t size)\r\n{\r\nif (size <= PAGE_SIZE)\r\nreturn kzalloc(size, GFP_KERNEL);\r\nelse\r\nreturn vzalloc(size);\r\n}\r\nstatic void __tnode_free_rcu(struct rcu_head *head)\r\n{\r\nstruct tnode *tn = container_of(head, struct tnode, rcu);\r\nsize_t size = sizeof(struct tnode) +\r\n(sizeof(struct rt_trie_node *) << tn->bits);\r\nif (size <= PAGE_SIZE)\r\nkfree(tn);\r\nelse\r\nvfree(tn);\r\n}\r\nstatic inline void tnode_free(struct tnode *tn)\r\n{\r\nif (IS_LEAF(tn))\r\nfree_leaf((struct leaf *) tn);\r\nelse\r\ncall_rcu(&tn->rcu, __tnode_free_rcu);\r\n}\r\nstatic void tnode_free_safe(struct tnode *tn)\r\n{\r\nBUG_ON(IS_LEAF(tn));\r\ntn->tnode_free = tnode_free_head;\r\ntnode_free_head = tn;\r\ntnode_free_size += sizeof(struct tnode) +\r\n(sizeof(struct rt_trie_node *) << tn->bits);\r\n}\r\nstatic void tnode_free_flush(void)\r\n{\r\nstruct tnode *tn;\r\nwhile ((tn = tnode_free_head)) {\r\ntnode_free_head = tn->tnode_free;\r\ntn->tnode_free = NULL;\r\ntnode_free(tn);\r\n}\r\nif (tnode_free_size >= PAGE_SIZE * sync_pages) {\r\ntnode_free_size = 0;\r\nsynchronize_rcu();\r\n}\r\n}\r\nstatic struct leaf *leaf_new(void)\r\n{\r\nstruct leaf *l = kmem_cache_alloc(trie_leaf_kmem, GFP_KERNEL);\r\nif (l) {\r\nl->parent = T_LEAF;\r\nINIT_HLIST_HEAD(&l->list);\r\n}\r\nreturn l;\r\n}\r\nstatic struct leaf_info *leaf_info_new(int plen)\r\n{\r\nstruct leaf_info *li = kmalloc(sizeof(struct leaf_info), GFP_KERNEL);\r\nif (li) {\r\nli->plen = plen;\r\nli->mask_plen = ntohl(inet_make_mask(plen));\r\nINIT_LIST_HEAD(&li->falh);\r\n}\r\nreturn li;\r\n}\r\nstatic struct tnode *tnode_new(t_key key, int pos, int bits)\r\n{\r\nsize_t sz = sizeof(struct tnode) + (sizeof(struct rt_trie_node *) << bits);\r\nstruct tnode *tn = tnode_alloc(sz);\r\nif (tn) {\r\ntn->parent = T_TNODE;\r\ntn->pos = pos;\r\ntn->bits = bits;\r\ntn->key = key;\r\ntn->full_children = 0;\r\ntn->empty_children = 1<<bits;\r\n}\r\npr_debug("AT %p s=%zu %zu\n", tn, sizeof(struct tnode),\r\nsizeof(struct rt_trie_node *) << bits);\r\nreturn tn;\r\n}\r\nstatic inline int tnode_full(const struct tnode *tn, const struct rt_trie_node *n)\r\n{\r\nif (n == NULL || IS_LEAF(n))\r\nreturn 0;\r\nreturn ((struct tnode *) n)->pos == tn->pos + tn->bits;\r\n}\r\nstatic inline void put_child(struct tnode *tn, int i,\r\nstruct rt_trie_node *n)\r\n{\r\ntnode_put_child_reorg(tn, i, n, -1);\r\n}\r\nstatic void tnode_put_child_reorg(struct tnode *tn, int i, struct rt_trie_node *n,\r\nint wasfull)\r\n{\r\nstruct rt_trie_node *chi = rtnl_dereference(tn->child[i]);\r\nint isfull;\r\nBUG_ON(i >= 1<<tn->bits);\r\nif (n == NULL && chi != NULL)\r\ntn->empty_children++;\r\nelse if (n != NULL && chi == NULL)\r\ntn->empty_children--;\r\nif (wasfull == -1)\r\nwasfull = tnode_full(tn, chi);\r\nisfull = tnode_full(tn, n);\r\nif (wasfull && !isfull)\r\ntn->full_children--;\r\nelse if (!wasfull && isfull)\r\ntn->full_children++;\r\nif (n)\r\nnode_set_parent(n, tn);\r\nrcu_assign_pointer(tn->child[i], n);\r\n}\r\nstatic struct rt_trie_node *resize(struct trie *t, struct tnode *tn)\r\n{\r\nint i;\r\nstruct tnode *old_tn;\r\nint inflate_threshold_use;\r\nint halve_threshold_use;\r\nint max_work;\r\nif (!tn)\r\nreturn NULL;\r\npr_debug("In tnode_resize %p inflate_threshold=%d threshold=%d\n",\r\ntn, inflate_threshold, halve_threshold);\r\nif (tn->empty_children == tnode_child_length(tn)) {\r\ntnode_free_safe(tn);\r\nreturn NULL;\r\n}\r\nif (tn->empty_children == tnode_child_length(tn) - 1)\r\ngoto one_child;\r\ncheck_tnode(tn);\r\nif (!node_parent((struct rt_trie_node *)tn)) {\r\ninflate_threshold_use = inflate_threshold_root;\r\nhalve_threshold_use = halve_threshold_root;\r\n} else {\r\ninflate_threshold_use = inflate_threshold;\r\nhalve_threshold_use = halve_threshold;\r\n}\r\nmax_work = MAX_WORK;\r\nwhile ((tn->full_children > 0 && max_work-- &&\r\n50 * (tn->full_children + tnode_child_length(tn)\r\n- tn->empty_children)\r\n>= inflate_threshold_use * tnode_child_length(tn))) {\r\nold_tn = tn;\r\ntn = inflate(t, tn);\r\nif (IS_ERR(tn)) {\r\ntn = old_tn;\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nt->stats.resize_node_skipped++;\r\n#endif\r\nbreak;\r\n}\r\n}\r\ncheck_tnode(tn);\r\nif (max_work != MAX_WORK)\r\nreturn (struct rt_trie_node *) tn;\r\nmax_work = MAX_WORK;\r\nwhile (tn->bits > 1 && max_work-- &&\r\n100 * (tnode_child_length(tn) - tn->empty_children) <\r\nhalve_threshold_use * tnode_child_length(tn)) {\r\nold_tn = tn;\r\ntn = halve(t, tn);\r\nif (IS_ERR(tn)) {\r\ntn = old_tn;\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nt->stats.resize_node_skipped++;\r\n#endif\r\nbreak;\r\n}\r\n}\r\nif (tn->empty_children == tnode_child_length(tn) - 1) {\r\none_child:\r\nfor (i = 0; i < tnode_child_length(tn); i++) {\r\nstruct rt_trie_node *n;\r\nn = rtnl_dereference(tn->child[i]);\r\nif (!n)\r\ncontinue;\r\nnode_set_parent(n, NULL);\r\ntnode_free_safe(tn);\r\nreturn n;\r\n}\r\n}\r\nreturn (struct rt_trie_node *) tn;\r\n}\r\nstatic void tnode_clean_free(struct tnode *tn)\r\n{\r\nint i;\r\nstruct tnode *tofree;\r\nfor (i = 0; i < tnode_child_length(tn); i++) {\r\ntofree = (struct tnode *)rtnl_dereference(tn->child[i]);\r\nif (tofree)\r\ntnode_free(tofree);\r\n}\r\ntnode_free(tn);\r\n}\r\nstatic struct tnode *inflate(struct trie *t, struct tnode *tn)\r\n{\r\nstruct tnode *oldtnode = tn;\r\nint olen = tnode_child_length(tn);\r\nint i;\r\npr_debug("In inflate\n");\r\ntn = tnode_new(oldtnode->key, oldtnode->pos, oldtnode->bits + 1);\r\nif (!tn)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < olen; i++) {\r\nstruct tnode *inode;\r\ninode = (struct tnode *) tnode_get_child(oldtnode, i);\r\nif (inode &&\r\nIS_TNODE(inode) &&\r\ninode->pos == oldtnode->pos + oldtnode->bits &&\r\ninode->bits > 1) {\r\nstruct tnode *left, *right;\r\nt_key m = ~0U << (KEYLENGTH - 1) >> inode->pos;\r\nleft = tnode_new(inode->key&(~m), inode->pos + 1,\r\ninode->bits - 1);\r\nif (!left)\r\ngoto nomem;\r\nright = tnode_new(inode->key|m, inode->pos + 1,\r\ninode->bits - 1);\r\nif (!right) {\r\ntnode_free(left);\r\ngoto nomem;\r\n}\r\nput_child(tn, 2*i, (struct rt_trie_node *) left);\r\nput_child(tn, 2*i+1, (struct rt_trie_node *) right);\r\n}\r\n}\r\nfor (i = 0; i < olen; i++) {\r\nstruct tnode *inode;\r\nstruct rt_trie_node *node = tnode_get_child(oldtnode, i);\r\nstruct tnode *left, *right;\r\nint size, j;\r\nif (node == NULL)\r\ncontinue;\r\nif (IS_LEAF(node) || ((struct tnode *) node)->pos >\r\ntn->pos + tn->bits - 1) {\r\nif (tkey_extract_bits(node->key,\r\noldtnode->pos + oldtnode->bits,\r\n1) == 0)\r\nput_child(tn, 2*i, node);\r\nelse\r\nput_child(tn, 2*i+1, node);\r\ncontinue;\r\n}\r\ninode = (struct tnode *) node;\r\nif (inode->bits == 1) {\r\nput_child(tn, 2*i, rtnl_dereference(inode->child[0]));\r\nput_child(tn, 2*i+1, rtnl_dereference(inode->child[1]));\r\ntnode_free_safe(inode);\r\ncontinue;\r\n}\r\nleft = (struct tnode *) tnode_get_child(tn, 2*i);\r\nput_child(tn, 2*i, NULL);\r\nBUG_ON(!left);\r\nright = (struct tnode *) tnode_get_child(tn, 2*i+1);\r\nput_child(tn, 2*i+1, NULL);\r\nBUG_ON(!right);\r\nsize = tnode_child_length(left);\r\nfor (j = 0; j < size; j++) {\r\nput_child(left, j, rtnl_dereference(inode->child[j]));\r\nput_child(right, j, rtnl_dereference(inode->child[j + size]));\r\n}\r\nput_child(tn, 2*i, resize(t, left));\r\nput_child(tn, 2*i+1, resize(t, right));\r\ntnode_free_safe(inode);\r\n}\r\ntnode_free_safe(oldtnode);\r\nreturn tn;\r\nnomem:\r\ntnode_clean_free(tn);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic struct tnode *halve(struct trie *t, struct tnode *tn)\r\n{\r\nstruct tnode *oldtnode = tn;\r\nstruct rt_trie_node *left, *right;\r\nint i;\r\nint olen = tnode_child_length(tn);\r\npr_debug("In halve\n");\r\ntn = tnode_new(oldtnode->key, oldtnode->pos, oldtnode->bits - 1);\r\nif (!tn)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < olen; i += 2) {\r\nleft = tnode_get_child(oldtnode, i);\r\nright = tnode_get_child(oldtnode, i+1);\r\nif (left && right) {\r\nstruct tnode *newn;\r\nnewn = tnode_new(left->key, tn->pos + tn->bits, 1);\r\nif (!newn)\r\ngoto nomem;\r\nput_child(tn, i/2, (struct rt_trie_node *)newn);\r\n}\r\n}\r\nfor (i = 0; i < olen; i += 2) {\r\nstruct tnode *newBinNode;\r\nleft = tnode_get_child(oldtnode, i);\r\nright = tnode_get_child(oldtnode, i+1);\r\nif (left == NULL) {\r\nif (right == NULL)\r\ncontinue;\r\nput_child(tn, i/2, right);\r\ncontinue;\r\n}\r\nif (right == NULL) {\r\nput_child(tn, i/2, left);\r\ncontinue;\r\n}\r\nnewBinNode = (struct tnode *) tnode_get_child(tn, i/2);\r\nput_child(tn, i/2, NULL);\r\nput_child(newBinNode, 0, left);\r\nput_child(newBinNode, 1, right);\r\nput_child(tn, i/2, resize(t, newBinNode));\r\n}\r\ntnode_free_safe(oldtnode);\r\nreturn tn;\r\nnomem:\r\ntnode_clean_free(tn);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic struct leaf_info *find_leaf_info(struct leaf *l, int plen)\r\n{\r\nstruct hlist_head *head = &l->list;\r\nstruct leaf_info *li;\r\nhlist_for_each_entry_rcu(li, head, hlist)\r\nif (li->plen == plen)\r\nreturn li;\r\nreturn NULL;\r\n}\r\nstatic inline struct list_head *get_fa_head(struct leaf *l, int plen)\r\n{\r\nstruct leaf_info *li = find_leaf_info(l, plen);\r\nif (!li)\r\nreturn NULL;\r\nreturn &li->falh;\r\n}\r\nstatic void insert_leaf_info(struct hlist_head *head, struct leaf_info *new)\r\n{\r\nstruct leaf_info *li = NULL, *last = NULL;\r\nif (hlist_empty(head)) {\r\nhlist_add_head_rcu(&new->hlist, head);\r\n} else {\r\nhlist_for_each_entry(li, head, hlist) {\r\nif (new->plen > li->plen)\r\nbreak;\r\nlast = li;\r\n}\r\nif (last)\r\nhlist_add_after_rcu(&last->hlist, &new->hlist);\r\nelse\r\nhlist_add_before_rcu(&new->hlist, &li->hlist);\r\n}\r\n}\r\nstatic struct leaf *\r\nfib_find_node(struct trie *t, u32 key)\r\n{\r\nint pos;\r\nstruct tnode *tn;\r\nstruct rt_trie_node *n;\r\npos = 0;\r\nn = rcu_dereference_rtnl(t->trie);\r\nwhile (n != NULL && NODE_TYPE(n) == T_TNODE) {\r\ntn = (struct tnode *) n;\r\ncheck_tnode(tn);\r\nif (tkey_sub_equals(tn->key, pos, tn->pos-pos, key)) {\r\npos = tn->pos + tn->bits;\r\nn = tnode_get_child_rcu(tn,\r\ntkey_extract_bits(key,\r\ntn->pos,\r\ntn->bits));\r\n} else\r\nbreak;\r\n}\r\nif (n != NULL && IS_LEAF(n) && tkey_equals(key, n->key))\r\nreturn (struct leaf *)n;\r\nreturn NULL;\r\n}\r\nstatic void trie_rebalance(struct trie *t, struct tnode *tn)\r\n{\r\nint wasfull;\r\nt_key cindex, key;\r\nstruct tnode *tp;\r\nkey = tn->key;\r\nwhile (tn != NULL && (tp = node_parent((struct rt_trie_node *)tn)) != NULL) {\r\ncindex = tkey_extract_bits(key, tp->pos, tp->bits);\r\nwasfull = tnode_full(tp, tnode_get_child(tp, cindex));\r\ntn = (struct tnode *)resize(t, tn);\r\ntnode_put_child_reorg(tp, cindex,\r\n(struct rt_trie_node *)tn, wasfull);\r\ntp = node_parent((struct rt_trie_node *) tn);\r\nif (!tp)\r\nrcu_assign_pointer(t->trie, (struct rt_trie_node *)tn);\r\ntnode_free_flush();\r\nif (!tp)\r\nbreak;\r\ntn = tp;\r\n}\r\nif (IS_TNODE(tn))\r\ntn = (struct tnode *)resize(t, tn);\r\nrcu_assign_pointer(t->trie, (struct rt_trie_node *)tn);\r\ntnode_free_flush();\r\n}\r\nstatic struct list_head *fib_insert_node(struct trie *t, u32 key, int plen)\r\n{\r\nint pos, newpos;\r\nstruct tnode *tp = NULL, *tn = NULL;\r\nstruct rt_trie_node *n;\r\nstruct leaf *l;\r\nint missbit;\r\nstruct list_head *fa_head = NULL;\r\nstruct leaf_info *li;\r\nt_key cindex;\r\npos = 0;\r\nn = rtnl_dereference(t->trie);\r\nwhile (n != NULL && NODE_TYPE(n) == T_TNODE) {\r\ntn = (struct tnode *) n;\r\ncheck_tnode(tn);\r\nif (tkey_sub_equals(tn->key, pos, tn->pos-pos, key)) {\r\ntp = tn;\r\npos = tn->pos + tn->bits;\r\nn = tnode_get_child(tn,\r\ntkey_extract_bits(key,\r\ntn->pos,\r\ntn->bits));\r\nBUG_ON(n && node_parent(n) != tn);\r\n} else\r\nbreak;\r\n}\r\nBUG_ON(tp && IS_LEAF(tp));\r\nif (n != NULL && IS_LEAF(n) && tkey_equals(key, n->key)) {\r\nl = (struct leaf *) n;\r\nli = leaf_info_new(plen);\r\nif (!li)\r\nreturn NULL;\r\nfa_head = &li->falh;\r\ninsert_leaf_info(&l->list, li);\r\ngoto done;\r\n}\r\nl = leaf_new();\r\nif (!l)\r\nreturn NULL;\r\nl->key = key;\r\nli = leaf_info_new(plen);\r\nif (!li) {\r\nfree_leaf(l);\r\nreturn NULL;\r\n}\r\nfa_head = &li->falh;\r\ninsert_leaf_info(&l->list, li);\r\nif (t->trie && n == NULL) {\r\nnode_set_parent((struct rt_trie_node *)l, tp);\r\ncindex = tkey_extract_bits(key, tp->pos, tp->bits);\r\nput_child(tp, cindex, (struct rt_trie_node *)l);\r\n} else {\r\nif (tp)\r\npos = tp->pos+tp->bits;\r\nelse\r\npos = 0;\r\nif (n) {\r\nnewpos = tkey_mismatch(key, pos, n->key);\r\ntn = tnode_new(n->key, newpos, 1);\r\n} else {\r\nnewpos = 0;\r\ntn = tnode_new(key, newpos, 1);\r\n}\r\nif (!tn) {\r\nfree_leaf_info(li);\r\nfree_leaf(l);\r\nreturn NULL;\r\n}\r\nnode_set_parent((struct rt_trie_node *)tn, tp);\r\nmissbit = tkey_extract_bits(key, newpos, 1);\r\nput_child(tn, missbit, (struct rt_trie_node *)l);\r\nput_child(tn, 1-missbit, n);\r\nif (tp) {\r\ncindex = tkey_extract_bits(key, tp->pos, tp->bits);\r\nput_child(tp, cindex, (struct rt_trie_node *)tn);\r\n} else {\r\nrcu_assign_pointer(t->trie, (struct rt_trie_node *)tn);\r\ntp = tn;\r\n}\r\n}\r\nif (tp && tp->pos + tp->bits > 32)\r\npr_warn("fib_trie tp=%p pos=%d, bits=%d, key=%0x plen=%d\n",\r\ntp, tp->pos, tp->bits, key, plen);\r\ntrie_rebalance(t, tp);\r\ndone:\r\nreturn fa_head;\r\n}\r\nint fib_table_insert(struct fib_table *tb, struct fib_config *cfg)\r\n{\r\nstruct trie *t = (struct trie *) tb->tb_data;\r\nstruct fib_alias *fa, *new_fa;\r\nstruct list_head *fa_head = NULL;\r\nstruct fib_info *fi;\r\nint plen = cfg->fc_dst_len;\r\nu8 tos = cfg->fc_tos;\r\nu32 key, mask;\r\nint err;\r\nstruct leaf *l;\r\nif (plen > 32)\r\nreturn -EINVAL;\r\nkey = ntohl(cfg->fc_dst);\r\npr_debug("Insert table=%u %08x/%d\n", tb->tb_id, key, plen);\r\nmask = ntohl(inet_make_mask(plen));\r\nif (key & ~mask)\r\nreturn -EINVAL;\r\nkey = key & mask;\r\nfi = fib_create_info(cfg);\r\nif (IS_ERR(fi)) {\r\nerr = PTR_ERR(fi);\r\ngoto err;\r\n}\r\nl = fib_find_node(t, key);\r\nfa = NULL;\r\nif (l) {\r\nfa_head = get_fa_head(l, plen);\r\nfa = fib_find_alias(fa_head, tos, fi->fib_priority);\r\n}\r\nif (fa && fa->fa_tos == tos &&\r\nfa->fa_info->fib_priority == fi->fib_priority) {\r\nstruct fib_alias *fa_first, *fa_match;\r\nerr = -EEXIST;\r\nif (cfg->fc_nlflags & NLM_F_EXCL)\r\ngoto out;\r\nfa_match = NULL;\r\nfa_first = fa;\r\nfa = list_entry(fa->fa_list.prev, struct fib_alias, fa_list);\r\nlist_for_each_entry_continue(fa, fa_head, fa_list) {\r\nif (fa->fa_tos != tos)\r\nbreak;\r\nif (fa->fa_info->fib_priority != fi->fib_priority)\r\nbreak;\r\nif (fa->fa_type == cfg->fc_type &&\r\nfa->fa_info == fi) {\r\nfa_match = fa;\r\nbreak;\r\n}\r\n}\r\nif (cfg->fc_nlflags & NLM_F_REPLACE) {\r\nstruct fib_info *fi_drop;\r\nu8 state;\r\nfa = fa_first;\r\nif (fa_match) {\r\nif (fa == fa_match)\r\nerr = 0;\r\ngoto out;\r\n}\r\nerr = -ENOBUFS;\r\nnew_fa = kmem_cache_alloc(fn_alias_kmem, GFP_KERNEL);\r\nif (new_fa == NULL)\r\ngoto out;\r\nfi_drop = fa->fa_info;\r\nnew_fa->fa_tos = fa->fa_tos;\r\nnew_fa->fa_info = fi;\r\nnew_fa->fa_type = cfg->fc_type;\r\nstate = fa->fa_state;\r\nnew_fa->fa_state = state & ~FA_S_ACCESSED;\r\nlist_replace_rcu(&fa->fa_list, &new_fa->fa_list);\r\nalias_free_mem_rcu(fa);\r\nfib_release_info(fi_drop);\r\nif (state & FA_S_ACCESSED)\r\nrt_cache_flush(cfg->fc_nlinfo.nl_net);\r\nrtmsg_fib(RTM_NEWROUTE, htonl(key), new_fa, plen,\r\ntb->tb_id, &cfg->fc_nlinfo, NLM_F_REPLACE);\r\ngoto succeeded;\r\n}\r\nif (fa_match)\r\ngoto out;\r\nif (!(cfg->fc_nlflags & NLM_F_APPEND))\r\nfa = fa_first;\r\n}\r\nerr = -ENOENT;\r\nif (!(cfg->fc_nlflags & NLM_F_CREATE))\r\ngoto out;\r\nerr = -ENOBUFS;\r\nnew_fa = kmem_cache_alloc(fn_alias_kmem, GFP_KERNEL);\r\nif (new_fa == NULL)\r\ngoto out;\r\nnew_fa->fa_info = fi;\r\nnew_fa->fa_tos = tos;\r\nnew_fa->fa_type = cfg->fc_type;\r\nnew_fa->fa_state = 0;\r\nif (!fa_head) {\r\nfa_head = fib_insert_node(t, key, plen);\r\nif (unlikely(!fa_head)) {\r\nerr = -ENOMEM;\r\ngoto out_free_new_fa;\r\n}\r\n}\r\nif (!plen)\r\ntb->tb_num_default++;\r\nlist_add_tail_rcu(&new_fa->fa_list,\r\n(fa ? &fa->fa_list : fa_head));\r\nrt_cache_flush(cfg->fc_nlinfo.nl_net);\r\nrtmsg_fib(RTM_NEWROUTE, htonl(key), new_fa, plen, tb->tb_id,\r\n&cfg->fc_nlinfo, 0);\r\nsucceeded:\r\nreturn 0;\r\nout_free_new_fa:\r\nkmem_cache_free(fn_alias_kmem, new_fa);\r\nout:\r\nfib_release_info(fi);\r\nerr:\r\nreturn err;\r\n}\r\nstatic int check_leaf(struct fib_table *tb, struct trie *t, struct leaf *l,\r\nt_key key, const struct flowi4 *flp,\r\nstruct fib_result *res, int fib_flags)\r\n{\r\nstruct leaf_info *li;\r\nstruct hlist_head *hhead = &l->list;\r\nhlist_for_each_entry_rcu(li, hhead, hlist) {\r\nstruct fib_alias *fa;\r\nif (l->key != (key & li->mask_plen))\r\ncontinue;\r\nlist_for_each_entry_rcu(fa, &li->falh, fa_list) {\r\nstruct fib_info *fi = fa->fa_info;\r\nint nhsel, err;\r\nif (fa->fa_tos && fa->fa_tos != flp->flowi4_tos)\r\ncontinue;\r\nif (fi->fib_dead)\r\ncontinue;\r\nif (fa->fa_info->fib_scope < flp->flowi4_scope)\r\ncontinue;\r\nfib_alias_accessed(fa);\r\nerr = fib_props[fa->fa_type].error;\r\nif (err) {\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nt->stats.semantic_match_passed++;\r\n#endif\r\nreturn err;\r\n}\r\nif (fi->fib_flags & RTNH_F_DEAD)\r\ncontinue;\r\nfor (nhsel = 0; nhsel < fi->fib_nhs; nhsel++) {\r\nconst struct fib_nh *nh = &fi->fib_nh[nhsel];\r\nif (nh->nh_flags & RTNH_F_DEAD)\r\ncontinue;\r\nif (flp->flowi4_oif && flp->flowi4_oif != nh->nh_oif)\r\ncontinue;\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nt->stats.semantic_match_passed++;\r\n#endif\r\nres->prefixlen = li->plen;\r\nres->nh_sel = nhsel;\r\nres->type = fa->fa_type;\r\nres->scope = fa->fa_info->fib_scope;\r\nres->fi = fi;\r\nres->table = tb;\r\nres->fa_head = &li->falh;\r\nif (!(fib_flags & FIB_LOOKUP_NOREF))\r\natomic_inc(&fi->fib_clntref);\r\nreturn 0;\r\n}\r\n}\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nt->stats.semantic_match_miss++;\r\n#endif\r\n}\r\nreturn 1;\r\n}\r\nint fib_table_lookup(struct fib_table *tb, const struct flowi4 *flp,\r\nstruct fib_result *res, int fib_flags)\r\n{\r\nstruct trie *t = (struct trie *) tb->tb_data;\r\nint ret;\r\nstruct rt_trie_node *n;\r\nstruct tnode *pn;\r\nunsigned int pos, bits;\r\nt_key key = ntohl(flp->daddr);\r\nunsigned int chopped_off;\r\nt_key cindex = 0;\r\nunsigned int current_prefix_length = KEYLENGTH;\r\nstruct tnode *cn;\r\nt_key pref_mismatch;\r\nrcu_read_lock();\r\nn = rcu_dereference(t->trie);\r\nif (!n)\r\ngoto failed;\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nt->stats.gets++;\r\n#endif\r\nif (IS_LEAF(n)) {\r\nret = check_leaf(tb, t, (struct leaf *)n, key, flp, res, fib_flags);\r\ngoto found;\r\n}\r\npn = (struct tnode *) n;\r\nchopped_off = 0;\r\nwhile (pn) {\r\npos = pn->pos;\r\nbits = pn->bits;\r\nif (!chopped_off)\r\ncindex = tkey_extract_bits(mask_pfx(key, current_prefix_length),\r\npos, bits);\r\nn = tnode_get_child_rcu(pn, cindex);\r\nif (n == NULL) {\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nt->stats.null_node_hit++;\r\n#endif\r\ngoto backtrace;\r\n}\r\nif (IS_LEAF(n)) {\r\nret = check_leaf(tb, t, (struct leaf *)n, key, flp, res, fib_flags);\r\nif (ret > 0)\r\ngoto backtrace;\r\ngoto found;\r\n}\r\ncn = (struct tnode *)n;\r\nif (current_prefix_length < pos+bits) {\r\nif (tkey_extract_bits(cn->key, current_prefix_length,\r\ncn->pos - current_prefix_length)\r\n|| !(cn->child[0]))\r\ngoto backtrace;\r\n}\r\npref_mismatch = mask_pfx(cn->key ^ key, cn->pos);\r\nif (pref_mismatch) {\r\nint mp = KEYLENGTH - __fls(pref_mismatch) - 1;\r\nif (tkey_extract_bits(cn->key, mp, cn->pos - mp) != 0)\r\ngoto backtrace;\r\nif (current_prefix_length >= cn->pos)\r\ncurrent_prefix_length = mp;\r\n}\r\npn = (struct tnode *)n;\r\nchopped_off = 0;\r\ncontinue;\r\nbacktrace:\r\nchopped_off++;\r\nwhile ((chopped_off <= pn->bits)\r\n&& !(cindex & (1<<(chopped_off-1))))\r\nchopped_off++;\r\nif (current_prefix_length > pn->pos + pn->bits - chopped_off)\r\ncurrent_prefix_length = pn->pos + pn->bits\r\n- chopped_off;\r\nif (chopped_off <= pn->bits) {\r\ncindex &= ~(1 << (chopped_off-1));\r\n} else {\r\nstruct tnode *parent = node_parent_rcu((struct rt_trie_node *) pn);\r\nif (!parent)\r\ngoto failed;\r\ncindex = tkey_extract_bits(pn->key, parent->pos, parent->bits);\r\npn = parent;\r\nchopped_off = 0;\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nt->stats.backtrack++;\r\n#endif\r\ngoto backtrace;\r\n}\r\n}\r\nfailed:\r\nret = 1;\r\nfound:\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic void trie_leaf_remove(struct trie *t, struct leaf *l)\r\n{\r\nstruct tnode *tp = node_parent((struct rt_trie_node *) l);\r\npr_debug("entering trie_leaf_remove(%p)\n", l);\r\nif (tp) {\r\nt_key cindex = tkey_extract_bits(l->key, tp->pos, tp->bits);\r\nput_child(tp, cindex, NULL);\r\ntrie_rebalance(t, tp);\r\n} else\r\nRCU_INIT_POINTER(t->trie, NULL);\r\nfree_leaf(l);\r\n}\r\nint fib_table_delete(struct fib_table *tb, struct fib_config *cfg)\r\n{\r\nstruct trie *t = (struct trie *) tb->tb_data;\r\nu32 key, mask;\r\nint plen = cfg->fc_dst_len;\r\nu8 tos = cfg->fc_tos;\r\nstruct fib_alias *fa, *fa_to_delete;\r\nstruct list_head *fa_head;\r\nstruct leaf *l;\r\nstruct leaf_info *li;\r\nif (plen > 32)\r\nreturn -EINVAL;\r\nkey = ntohl(cfg->fc_dst);\r\nmask = ntohl(inet_make_mask(plen));\r\nif (key & ~mask)\r\nreturn -EINVAL;\r\nkey = key & mask;\r\nl = fib_find_node(t, key);\r\nif (!l)\r\nreturn -ESRCH;\r\nli = find_leaf_info(l, plen);\r\nif (!li)\r\nreturn -ESRCH;\r\nfa_head = &li->falh;\r\nfa = fib_find_alias(fa_head, tos, 0);\r\nif (!fa)\r\nreturn -ESRCH;\r\npr_debug("Deleting %08x/%d tos=%d t=%p\n", key, plen, tos, t);\r\nfa_to_delete = NULL;\r\nfa = list_entry(fa->fa_list.prev, struct fib_alias, fa_list);\r\nlist_for_each_entry_continue(fa, fa_head, fa_list) {\r\nstruct fib_info *fi = fa->fa_info;\r\nif (fa->fa_tos != tos)\r\nbreak;\r\nif ((!cfg->fc_type || fa->fa_type == cfg->fc_type) &&\r\n(cfg->fc_scope == RT_SCOPE_NOWHERE ||\r\nfa->fa_info->fib_scope == cfg->fc_scope) &&\r\n(!cfg->fc_prefsrc ||\r\nfi->fib_prefsrc == cfg->fc_prefsrc) &&\r\n(!cfg->fc_protocol ||\r\nfi->fib_protocol == cfg->fc_protocol) &&\r\nfib_nh_match(cfg, fi) == 0) {\r\nfa_to_delete = fa;\r\nbreak;\r\n}\r\n}\r\nif (!fa_to_delete)\r\nreturn -ESRCH;\r\nfa = fa_to_delete;\r\nrtmsg_fib(RTM_DELROUTE, htonl(key), fa, plen, tb->tb_id,\r\n&cfg->fc_nlinfo, 0);\r\nlist_del_rcu(&fa->fa_list);\r\nif (!plen)\r\ntb->tb_num_default--;\r\nif (list_empty(fa_head)) {\r\nhlist_del_rcu(&li->hlist);\r\nfree_leaf_info(li);\r\n}\r\nif (hlist_empty(&l->list))\r\ntrie_leaf_remove(t, l);\r\nif (fa->fa_state & FA_S_ACCESSED)\r\nrt_cache_flush(cfg->fc_nlinfo.nl_net);\r\nfib_release_info(fa->fa_info);\r\nalias_free_mem_rcu(fa);\r\nreturn 0;\r\n}\r\nstatic int trie_flush_list(struct list_head *head)\r\n{\r\nstruct fib_alias *fa, *fa_node;\r\nint found = 0;\r\nlist_for_each_entry_safe(fa, fa_node, head, fa_list) {\r\nstruct fib_info *fi = fa->fa_info;\r\nif (fi && (fi->fib_flags & RTNH_F_DEAD)) {\r\nlist_del_rcu(&fa->fa_list);\r\nfib_release_info(fa->fa_info);\r\nalias_free_mem_rcu(fa);\r\nfound++;\r\n}\r\n}\r\nreturn found;\r\n}\r\nstatic int trie_flush_leaf(struct leaf *l)\r\n{\r\nint found = 0;\r\nstruct hlist_head *lih = &l->list;\r\nstruct hlist_node *tmp;\r\nstruct leaf_info *li = NULL;\r\nhlist_for_each_entry_safe(li, tmp, lih, hlist) {\r\nfound += trie_flush_list(&li->falh);\r\nif (list_empty(&li->falh)) {\r\nhlist_del_rcu(&li->hlist);\r\nfree_leaf_info(li);\r\n}\r\n}\r\nreturn found;\r\n}\r\nstatic struct leaf *leaf_walk_rcu(struct tnode *p, struct rt_trie_node *c)\r\n{\r\ndo {\r\nt_key idx;\r\nif (c)\r\nidx = tkey_extract_bits(c->key, p->pos, p->bits) + 1;\r\nelse\r\nidx = 0;\r\nwhile (idx < 1u << p->bits) {\r\nc = tnode_get_child_rcu(p, idx++);\r\nif (!c)\r\ncontinue;\r\nif (IS_LEAF(c))\r\nreturn (struct leaf *) c;\r\np = (struct tnode *) c;\r\nidx = 0;\r\n}\r\nc = (struct rt_trie_node *) p;\r\n} while ((p = node_parent_rcu(c)) != NULL);\r\nreturn NULL;\r\n}\r\nstatic struct leaf *trie_firstleaf(struct trie *t)\r\n{\r\nstruct tnode *n = (struct tnode *)rcu_dereference_rtnl(t->trie);\r\nif (!n)\r\nreturn NULL;\r\nif (IS_LEAF(n))\r\nreturn (struct leaf *) n;\r\nreturn leaf_walk_rcu(n, NULL);\r\n}\r\nstatic struct leaf *trie_nextleaf(struct leaf *l)\r\n{\r\nstruct rt_trie_node *c = (struct rt_trie_node *) l;\r\nstruct tnode *p = node_parent_rcu(c);\r\nif (!p)\r\nreturn NULL;\r\nreturn leaf_walk_rcu(p, c);\r\n}\r\nstatic struct leaf *trie_leafindex(struct trie *t, int index)\r\n{\r\nstruct leaf *l = trie_firstleaf(t);\r\nwhile (l && index-- > 0)\r\nl = trie_nextleaf(l);\r\nreturn l;\r\n}\r\nint fib_table_flush(struct fib_table *tb)\r\n{\r\nstruct trie *t = (struct trie *) tb->tb_data;\r\nstruct leaf *l, *ll = NULL;\r\nint found = 0;\r\nfor (l = trie_firstleaf(t); l; l = trie_nextleaf(l)) {\r\nfound += trie_flush_leaf(l);\r\nif (ll && hlist_empty(&ll->list))\r\ntrie_leaf_remove(t, ll);\r\nll = l;\r\n}\r\nif (ll && hlist_empty(&ll->list))\r\ntrie_leaf_remove(t, ll);\r\npr_debug("trie_flush found=%d\n", found);\r\nreturn found;\r\n}\r\nvoid fib_free_table(struct fib_table *tb)\r\n{\r\nkfree(tb);\r\n}\r\nstatic int fn_trie_dump_fa(t_key key, int plen, struct list_head *fah,\r\nstruct fib_table *tb,\r\nstruct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nint i, s_i;\r\nstruct fib_alias *fa;\r\n__be32 xkey = htonl(key);\r\ns_i = cb->args[5];\r\ni = 0;\r\nlist_for_each_entry_rcu(fa, fah, fa_list) {\r\nif (i < s_i) {\r\ni++;\r\ncontinue;\r\n}\r\nif (fib_dump_info(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nRTM_NEWROUTE,\r\ntb->tb_id,\r\nfa->fa_type,\r\nxkey,\r\nplen,\r\nfa->fa_tos,\r\nfa->fa_info, NLM_F_MULTI) < 0) {\r\ncb->args[5] = i;\r\nreturn -1;\r\n}\r\ni++;\r\n}\r\ncb->args[5] = i;\r\nreturn skb->len;\r\n}\r\nstatic int fn_trie_dump_leaf(struct leaf *l, struct fib_table *tb,\r\nstruct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct leaf_info *li;\r\nint i, s_i;\r\ns_i = cb->args[4];\r\ni = 0;\r\nhlist_for_each_entry_rcu(li, &l->list, hlist) {\r\nif (i < s_i) {\r\ni++;\r\ncontinue;\r\n}\r\nif (i > s_i)\r\ncb->args[5] = 0;\r\nif (list_empty(&li->falh))\r\ncontinue;\r\nif (fn_trie_dump_fa(l->key, li->plen, &li->falh, tb, skb, cb) < 0) {\r\ncb->args[4] = i;\r\nreturn -1;\r\n}\r\ni++;\r\n}\r\ncb->args[4] = i;\r\nreturn skb->len;\r\n}\r\nint fib_table_dump(struct fib_table *tb, struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nstruct leaf *l;\r\nstruct trie *t = (struct trie *) tb->tb_data;\r\nt_key key = cb->args[2];\r\nint count = cb->args[3];\r\nrcu_read_lock();\r\nif (count == 0)\r\nl = trie_firstleaf(t);\r\nelse {\r\nl = fib_find_node(t, key);\r\nif (!l)\r\nl = trie_leafindex(t, count);\r\n}\r\nwhile (l) {\r\ncb->args[2] = l->key;\r\nif (fn_trie_dump_leaf(l, tb, skb, cb) < 0) {\r\ncb->args[3] = count;\r\nrcu_read_unlock();\r\nreturn -1;\r\n}\r\n++count;\r\nl = trie_nextleaf(l);\r\nmemset(&cb->args[4], 0,\r\nsizeof(cb->args) - 4*sizeof(cb->args[0]));\r\n}\r\ncb->args[3] = count;\r\nrcu_read_unlock();\r\nreturn skb->len;\r\n}\r\nvoid __init fib_trie_init(void)\r\n{\r\nfn_alias_kmem = kmem_cache_create("ip_fib_alias",\r\nsizeof(struct fib_alias),\r\n0, SLAB_PANIC, NULL);\r\ntrie_leaf_kmem = kmem_cache_create("ip_fib_trie",\r\nmax(sizeof(struct leaf),\r\nsizeof(struct leaf_info)),\r\n0, SLAB_PANIC, NULL);\r\n}\r\nstruct fib_table *fib_trie_table(u32 id)\r\n{\r\nstruct fib_table *tb;\r\nstruct trie *t;\r\ntb = kmalloc(sizeof(struct fib_table) + sizeof(struct trie),\r\nGFP_KERNEL);\r\nif (tb == NULL)\r\nreturn NULL;\r\ntb->tb_id = id;\r\ntb->tb_default = -1;\r\ntb->tb_num_default = 0;\r\nt = (struct trie *) tb->tb_data;\r\nmemset(t, 0, sizeof(*t));\r\nreturn tb;\r\n}\r\nstatic struct rt_trie_node *fib_trie_get_next(struct fib_trie_iter *iter)\r\n{\r\nstruct tnode *tn = iter->tnode;\r\nunsigned int cindex = iter->index;\r\nstruct tnode *p;\r\nif (!tn)\r\nreturn NULL;\r\npr_debug("get_next iter={node=%p index=%d depth=%d}\n",\r\niter->tnode, iter->index, iter->depth);\r\nrescan:\r\nwhile (cindex < (1<<tn->bits)) {\r\nstruct rt_trie_node *n = tnode_get_child_rcu(tn, cindex);\r\nif (n) {\r\nif (IS_LEAF(n)) {\r\niter->tnode = tn;\r\niter->index = cindex + 1;\r\n} else {\r\niter->tnode = (struct tnode *) n;\r\niter->index = 0;\r\n++iter->depth;\r\n}\r\nreturn n;\r\n}\r\n++cindex;\r\n}\r\np = node_parent_rcu((struct rt_trie_node *)tn);\r\nif (p) {\r\ncindex = tkey_extract_bits(tn->key, p->pos, p->bits)+1;\r\ntn = p;\r\n--iter->depth;\r\ngoto rescan;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct rt_trie_node *fib_trie_get_first(struct fib_trie_iter *iter,\r\nstruct trie *t)\r\n{\r\nstruct rt_trie_node *n;\r\nif (!t)\r\nreturn NULL;\r\nn = rcu_dereference(t->trie);\r\nif (!n)\r\nreturn NULL;\r\nif (IS_TNODE(n)) {\r\niter->tnode = (struct tnode *) n;\r\niter->index = 0;\r\niter->depth = 1;\r\n} else {\r\niter->tnode = NULL;\r\niter->index = 0;\r\niter->depth = 0;\r\n}\r\nreturn n;\r\n}\r\nstatic void trie_collect_stats(struct trie *t, struct trie_stat *s)\r\n{\r\nstruct rt_trie_node *n;\r\nstruct fib_trie_iter iter;\r\nmemset(s, 0, sizeof(*s));\r\nrcu_read_lock();\r\nfor (n = fib_trie_get_first(&iter, t); n; n = fib_trie_get_next(&iter)) {\r\nif (IS_LEAF(n)) {\r\nstruct leaf *l = (struct leaf *)n;\r\nstruct leaf_info *li;\r\ns->leaves++;\r\ns->totdepth += iter.depth;\r\nif (iter.depth > s->maxdepth)\r\ns->maxdepth = iter.depth;\r\nhlist_for_each_entry_rcu(li, &l->list, hlist)\r\n++s->prefixes;\r\n} else {\r\nconst struct tnode *tn = (const struct tnode *) n;\r\nint i;\r\ns->tnodes++;\r\nif (tn->bits < MAX_STAT_DEPTH)\r\ns->nodesizes[tn->bits]++;\r\nfor (i = 0; i < (1<<tn->bits); i++)\r\nif (!tn->child[i])\r\ns->nullpointers++;\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void trie_show_stats(struct seq_file *seq, struct trie_stat *stat)\r\n{\r\nunsigned int i, max, pointers, bytes, avdepth;\r\nif (stat->leaves)\r\navdepth = stat->totdepth*100 / stat->leaves;\r\nelse\r\navdepth = 0;\r\nseq_printf(seq, "\tAver depth: %u.%02d\n",\r\navdepth / 100, avdepth % 100);\r\nseq_printf(seq, "\tMax depth: %u\n", stat->maxdepth);\r\nseq_printf(seq, "\tLeaves: %u\n", stat->leaves);\r\nbytes = sizeof(struct leaf) * stat->leaves;\r\nseq_printf(seq, "\tPrefixes: %u\n", stat->prefixes);\r\nbytes += sizeof(struct leaf_info) * stat->prefixes;\r\nseq_printf(seq, "\tInternal nodes: %u\n\t", stat->tnodes);\r\nbytes += sizeof(struct tnode) * stat->tnodes;\r\nmax = MAX_STAT_DEPTH;\r\nwhile (max > 0 && stat->nodesizes[max-1] == 0)\r\nmax--;\r\npointers = 0;\r\nfor (i = 1; i < max; i++)\r\nif (stat->nodesizes[i] != 0) {\r\nseq_printf(seq, " %u: %u", i, stat->nodesizes[i]);\r\npointers += (1<<i) * stat->nodesizes[i];\r\n}\r\nseq_putc(seq, '\n');\r\nseq_printf(seq, "\tPointers: %u\n", pointers);\r\nbytes += sizeof(struct rt_trie_node *) * pointers;\r\nseq_printf(seq, "Null ptrs: %u\n", stat->nullpointers);\r\nseq_printf(seq, "Total size: %u kB\n", (bytes + 1023) / 1024);\r\n}\r\nstatic void trie_show_usage(struct seq_file *seq,\r\nconst struct trie_use_stats *stats)\r\n{\r\nseq_printf(seq, "\nCounters:\n---------\n");\r\nseq_printf(seq, "gets = %u\n", stats->gets);\r\nseq_printf(seq, "backtracks = %u\n", stats->backtrack);\r\nseq_printf(seq, "semantic match passed = %u\n",\r\nstats->semantic_match_passed);\r\nseq_printf(seq, "semantic match miss = %u\n",\r\nstats->semantic_match_miss);\r\nseq_printf(seq, "null node hit= %u\n", stats->null_node_hit);\r\nseq_printf(seq, "skipped node resize = %u\n\n",\r\nstats->resize_node_skipped);\r\n}\r\nstatic void fib_table_print(struct seq_file *seq, struct fib_table *tb)\r\n{\r\nif (tb->tb_id == RT_TABLE_LOCAL)\r\nseq_puts(seq, "Local:\n");\r\nelse if (tb->tb_id == RT_TABLE_MAIN)\r\nseq_puts(seq, "Main:\n");\r\nelse\r\nseq_printf(seq, "Id %d:\n", tb->tb_id);\r\n}\r\nstatic int fib_triestat_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct net *net = (struct net *)seq->private;\r\nunsigned int h;\r\nseq_printf(seq,\r\n"Basic info: size of leaf:"\r\n" %Zd bytes, size of tnode: %Zd bytes.\n",\r\nsizeof(struct leaf), sizeof(struct tnode));\r\nfor (h = 0; h < FIB_TABLE_HASHSZ; h++) {\r\nstruct hlist_head *head = &net->ipv4.fib_table_hash[h];\r\nstruct fib_table *tb;\r\nhlist_for_each_entry_rcu(tb, head, tb_hlist) {\r\nstruct trie *t = (struct trie *) tb->tb_data;\r\nstruct trie_stat stat;\r\nif (!t)\r\ncontinue;\r\nfib_table_print(seq, tb);\r\ntrie_collect_stats(t, &stat);\r\ntrie_show_stats(seq, &stat);\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\ntrie_show_usage(seq, &t->stats);\r\n#endif\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int fib_triestat_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open_net(inode, file, fib_triestat_seq_show);\r\n}\r\nstatic struct rt_trie_node *fib_trie_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct fib_trie_iter *iter = seq->private;\r\nstruct net *net = seq_file_net(seq);\r\nloff_t idx = 0;\r\nunsigned int h;\r\nfor (h = 0; h < FIB_TABLE_HASHSZ; h++) {\r\nstruct hlist_head *head = &net->ipv4.fib_table_hash[h];\r\nstruct fib_table *tb;\r\nhlist_for_each_entry_rcu(tb, head, tb_hlist) {\r\nstruct rt_trie_node *n;\r\nfor (n = fib_trie_get_first(iter,\r\n(struct trie *) tb->tb_data);\r\nn; n = fib_trie_get_next(iter))\r\nif (pos == idx++) {\r\niter->tb = tb;\r\nreturn n;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *fib_trie_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU)\r\n{\r\nrcu_read_lock();\r\nreturn fib_trie_get_idx(seq, *pos);\r\n}\r\nstatic void *fib_trie_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct fib_trie_iter *iter = seq->private;\r\nstruct net *net = seq_file_net(seq);\r\nstruct fib_table *tb = iter->tb;\r\nstruct hlist_node *tb_node;\r\nunsigned int h;\r\nstruct rt_trie_node *n;\r\n++*pos;\r\nn = fib_trie_get_next(iter);\r\nif (n)\r\nreturn n;\r\nh = tb->tb_id & (FIB_TABLE_HASHSZ - 1);\r\nwhile ((tb_node = rcu_dereference(hlist_next_rcu(&tb->tb_hlist)))) {\r\ntb = hlist_entry(tb_node, struct fib_table, tb_hlist);\r\nn = fib_trie_get_first(iter, (struct trie *) tb->tb_data);\r\nif (n)\r\ngoto found;\r\n}\r\nwhile (++h < FIB_TABLE_HASHSZ) {\r\nstruct hlist_head *head = &net->ipv4.fib_table_hash[h];\r\nhlist_for_each_entry_rcu(tb, head, tb_hlist) {\r\nn = fib_trie_get_first(iter, (struct trie *) tb->tb_data);\r\nif (n)\r\ngoto found;\r\n}\r\n}\r\nreturn NULL;\r\nfound:\r\niter->tb = tb;\r\nreturn n;\r\n}\r\nstatic void fib_trie_seq_stop(struct seq_file *seq, void *v)\r\n__releases(RCU)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic void seq_indent(struct seq_file *seq, int n)\r\n{\r\nwhile (n-- > 0)\r\nseq_puts(seq, " ");\r\n}\r\nstatic inline const char *rtn_scope(char *buf, size_t len, enum rt_scope_t s)\r\n{\r\nswitch (s) {\r\ncase RT_SCOPE_UNIVERSE: return "universe";\r\ncase RT_SCOPE_SITE: return "site";\r\ncase RT_SCOPE_LINK: return "link";\r\ncase RT_SCOPE_HOST: return "host";\r\ncase RT_SCOPE_NOWHERE: return "nowhere";\r\ndefault:\r\nsnprintf(buf, len, "scope=%d", s);\r\nreturn buf;\r\n}\r\n}\r\nstatic inline const char *rtn_type(char *buf, size_t len, unsigned int t)\r\n{\r\nif (t < __RTN_MAX && rtn_type_names[t])\r\nreturn rtn_type_names[t];\r\nsnprintf(buf, len, "type %u", t);\r\nreturn buf;\r\n}\r\nstatic int fib_trie_seq_show(struct seq_file *seq, void *v)\r\n{\r\nconst struct fib_trie_iter *iter = seq->private;\r\nstruct rt_trie_node *n = v;\r\nif (!node_parent_rcu(n))\r\nfib_table_print(seq, iter->tb);\r\nif (IS_TNODE(n)) {\r\nstruct tnode *tn = (struct tnode *) n;\r\n__be32 prf = htonl(mask_pfx(tn->key, tn->pos));\r\nseq_indent(seq, iter->depth-1);\r\nseq_printf(seq, " +-- %pI4/%d %d %d %d\n",\r\n&prf, tn->pos, tn->bits, tn->full_children,\r\ntn->empty_children);\r\n} else {\r\nstruct leaf *l = (struct leaf *) n;\r\nstruct leaf_info *li;\r\n__be32 val = htonl(l->key);\r\nseq_indent(seq, iter->depth);\r\nseq_printf(seq, " |-- %pI4\n", &val);\r\nhlist_for_each_entry_rcu(li, &l->list, hlist) {\r\nstruct fib_alias *fa;\r\nlist_for_each_entry_rcu(fa, &li->falh, fa_list) {\r\nchar buf1[32], buf2[32];\r\nseq_indent(seq, iter->depth+1);\r\nseq_printf(seq, " /%d %s %s", li->plen,\r\nrtn_scope(buf1, sizeof(buf1),\r\nfa->fa_info->fib_scope),\r\nrtn_type(buf2, sizeof(buf2),\r\nfa->fa_type));\r\nif (fa->fa_tos)\r\nseq_printf(seq, " tos=%d", fa->fa_tos);\r\nseq_putc(seq, '\n');\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int fib_trie_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &fib_trie_seq_ops,\r\nsizeof(struct fib_trie_iter));\r\n}\r\nstatic struct leaf *fib_route_get_idx(struct fib_route_iter *iter, loff_t pos)\r\n{\r\nstruct leaf *l = NULL;\r\nstruct trie *t = iter->main_trie;\r\nif (iter->pos > 0 && pos >= iter->pos && (l = fib_find_node(t, iter->key)))\r\npos -= iter->pos;\r\nelse {\r\niter->pos = 0;\r\nl = trie_firstleaf(t);\r\n}\r\nwhile (l && pos-- > 0) {\r\niter->pos++;\r\nl = trie_nextleaf(l);\r\n}\r\nif (l)\r\niter->key = pos;\r\nelse\r\niter->pos = 0;\r\nreturn l;\r\n}\r\nstatic void *fib_route_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU)\r\n{\r\nstruct fib_route_iter *iter = seq->private;\r\nstruct fib_table *tb;\r\nrcu_read_lock();\r\ntb = fib_get_table(seq_file_net(seq), RT_TABLE_MAIN);\r\nif (!tb)\r\nreturn NULL;\r\niter->main_trie = (struct trie *) tb->tb_data;\r\nif (*pos == 0)\r\nreturn SEQ_START_TOKEN;\r\nelse\r\nreturn fib_route_get_idx(iter, *pos - 1);\r\n}\r\nstatic void *fib_route_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct fib_route_iter *iter = seq->private;\r\nstruct leaf *l = v;\r\n++*pos;\r\nif (v == SEQ_START_TOKEN) {\r\niter->pos = 0;\r\nl = trie_firstleaf(iter->main_trie);\r\n} else {\r\niter->pos++;\r\nl = trie_nextleaf(l);\r\n}\r\nif (l)\r\niter->key = l->key;\r\nelse\r\niter->pos = 0;\r\nreturn l;\r\n}\r\nstatic void fib_route_seq_stop(struct seq_file *seq, void *v)\r\n__releases(RCU)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic unsigned int fib_flag_trans(int type, __be32 mask, const struct fib_info *fi)\r\n{\r\nunsigned int flags = 0;\r\nif (type == RTN_UNREACHABLE || type == RTN_PROHIBIT)\r\nflags = RTF_REJECT;\r\nif (fi && fi->fib_nh->nh_gw)\r\nflags |= RTF_GATEWAY;\r\nif (mask == htonl(0xFFFFFFFF))\r\nflags |= RTF_HOST;\r\nflags |= RTF_UP;\r\nreturn flags;\r\n}\r\nstatic int fib_route_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct leaf *l = v;\r\nstruct leaf_info *li;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_printf(seq, "%-127s\n", "Iface\tDestination\tGateway "\r\n"\tFlags\tRefCnt\tUse\tMetric\tMask\t\tMTU"\r\n"\tWindow\tIRTT");\r\nreturn 0;\r\n}\r\nhlist_for_each_entry_rcu(li, &l->list, hlist) {\r\nstruct fib_alias *fa;\r\n__be32 mask, prefix;\r\nmask = inet_make_mask(li->plen);\r\nprefix = htonl(l->key);\r\nlist_for_each_entry_rcu(fa, &li->falh, fa_list) {\r\nconst struct fib_info *fi = fa->fa_info;\r\nunsigned int flags = fib_flag_trans(fa->fa_type, mask, fi);\r\nint len;\r\nif (fa->fa_type == RTN_BROADCAST\r\n|| fa->fa_type == RTN_MULTICAST)\r\ncontinue;\r\nif (fi)\r\nseq_printf(seq,\r\n"%s\t%08X\t%08X\t%04X\t%d\t%u\t"\r\n"%d\t%08X\t%d\t%u\t%u%n",\r\nfi->fib_dev ? fi->fib_dev->name : "*",\r\nprefix,\r\nfi->fib_nh->nh_gw, flags, 0, 0,\r\nfi->fib_priority,\r\nmask,\r\n(fi->fib_advmss ?\r\nfi->fib_advmss + 40 : 0),\r\nfi->fib_window,\r\nfi->fib_rtt >> 3, &len);\r\nelse\r\nseq_printf(seq,\r\n"*\t%08X\t%08X\t%04X\t%d\t%u\t"\r\n"%d\t%08X\t%d\t%u\t%u%n",\r\nprefix, 0, flags, 0, 0, 0,\r\nmask, 0, 0, 0, &len);\r\nseq_printf(seq, "%*s\n", 127 - len, "");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int fib_route_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &fib_route_seq_ops,\r\nsizeof(struct fib_route_iter));\r\n}\r\nint __net_init fib_proc_init(struct net *net)\r\n{\r\nif (!proc_create("fib_trie", S_IRUGO, net->proc_net, &fib_trie_fops))\r\ngoto out1;\r\nif (!proc_create("fib_triestat", S_IRUGO, net->proc_net,\r\n&fib_triestat_fops))\r\ngoto out2;\r\nif (!proc_create("route", S_IRUGO, net->proc_net, &fib_route_fops))\r\ngoto out3;\r\nreturn 0;\r\nout3:\r\nremove_proc_entry("fib_triestat", net->proc_net);\r\nout2:\r\nremove_proc_entry("fib_trie", net->proc_net);\r\nout1:\r\nreturn -ENOMEM;\r\n}\r\nvoid __net_exit fib_proc_exit(struct net *net)\r\n{\r\nremove_proc_entry("fib_trie", net->proc_net);\r\nremove_proc_entry("fib_triestat", net->proc_net);\r\nremove_proc_entry("route", net->proc_net);\r\n}
