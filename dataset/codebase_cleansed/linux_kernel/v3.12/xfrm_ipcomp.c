static int ipcomp_decompress(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nstruct ipcomp_data *ipcd = x->data;\r\nconst int plen = skb->len;\r\nint dlen = IPCOMP_SCRATCH_SIZE;\r\nconst u8 *start = skb->data;\r\nconst int cpu = get_cpu();\r\nu8 *scratch = *per_cpu_ptr(ipcomp_scratches, cpu);\r\nstruct crypto_comp *tfm = *per_cpu_ptr(ipcd->tfms, cpu);\r\nint err = crypto_comp_decompress(tfm, start, plen, scratch, &dlen);\r\nint len;\r\nif (err)\r\ngoto out;\r\nif (dlen < (plen + sizeof(struct ip_comp_hdr))) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nlen = dlen - plen;\r\nif (len > skb_tailroom(skb))\r\nlen = skb_tailroom(skb);\r\n__skb_put(skb, len);\r\nlen += plen;\r\nskb_copy_to_linear_data(skb, scratch, len);\r\nwhile ((scratch += len, dlen -= len) > 0) {\r\nskb_frag_t *frag;\r\nstruct page *page;\r\nerr = -EMSGSIZE;\r\nif (WARN_ON(skb_shinfo(skb)->nr_frags >= MAX_SKB_FRAGS))\r\ngoto out;\r\nfrag = skb_shinfo(skb)->frags + skb_shinfo(skb)->nr_frags;\r\npage = alloc_page(GFP_ATOMIC);\r\nerr = -ENOMEM;\r\nif (!page)\r\ngoto out;\r\n__skb_frag_set_page(frag, page);\r\nlen = PAGE_SIZE;\r\nif (dlen < len)\r\nlen = dlen;\r\nfrag->page_offset = 0;\r\nskb_frag_size_set(frag, len);\r\nmemcpy(skb_frag_address(frag), scratch, len);\r\nskb->truesize += len;\r\nskb->data_len += len;\r\nskb->len += len;\r\nskb_shinfo(skb)->nr_frags++;\r\n}\r\nerr = 0;\r\nout:\r\nput_cpu();\r\nreturn err;\r\n}\r\nint ipcomp_input(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nint nexthdr;\r\nint err = -ENOMEM;\r\nstruct ip_comp_hdr *ipch;\r\nif (skb_linearize_cow(skb))\r\ngoto out;\r\nskb->ip_summed = CHECKSUM_NONE;\r\nipch = (void *)skb->data;\r\nnexthdr = ipch->nexthdr;\r\nskb->transport_header = skb->network_header + sizeof(*ipch);\r\n__skb_pull(skb, sizeof(*ipch));\r\nerr = ipcomp_decompress(x, skb);\r\nif (err)\r\ngoto out;\r\nerr = nexthdr;\r\nout:\r\nreturn err;\r\n}\r\nstatic int ipcomp_compress(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nstruct ipcomp_data *ipcd = x->data;\r\nconst int plen = skb->len;\r\nint dlen = IPCOMP_SCRATCH_SIZE;\r\nu8 *start = skb->data;\r\nconst int cpu = get_cpu();\r\nu8 *scratch = *per_cpu_ptr(ipcomp_scratches, cpu);\r\nstruct crypto_comp *tfm = *per_cpu_ptr(ipcd->tfms, cpu);\r\nint err;\r\nlocal_bh_disable();\r\nerr = crypto_comp_compress(tfm, start, plen, scratch, &dlen);\r\nlocal_bh_enable();\r\nif (err)\r\ngoto out;\r\nif ((dlen + sizeof(struct ip_comp_hdr)) >= plen) {\r\nerr = -EMSGSIZE;\r\ngoto out;\r\n}\r\nmemcpy(start + sizeof(struct ip_comp_hdr), scratch, dlen);\r\nput_cpu();\r\npskb_trim(skb, dlen + sizeof(struct ip_comp_hdr));\r\nreturn 0;\r\nout:\r\nput_cpu();\r\nreturn err;\r\n}\r\nint ipcomp_output(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nint err;\r\nstruct ip_comp_hdr *ipch;\r\nstruct ipcomp_data *ipcd = x->data;\r\nif (skb->len < ipcd->threshold) {\r\ngoto out_ok;\r\n}\r\nif (skb_linearize_cow(skb))\r\ngoto out_ok;\r\nerr = ipcomp_compress(x, skb);\r\nif (err) {\r\ngoto out_ok;\r\n}\r\nipch = ip_comp_hdr(skb);\r\nipch->nexthdr = *skb_mac_header(skb);\r\nipch->flags = 0;\r\nipch->cpi = htons((u16 )ntohl(x->id.spi));\r\n*skb_mac_header(skb) = IPPROTO_COMP;\r\nout_ok:\r\nskb_push(skb, -skb_network_offset(skb));\r\nreturn 0;\r\n}\r\nstatic void ipcomp_free_scratches(void)\r\n{\r\nint i;\r\nvoid * __percpu *scratches;\r\nif (--ipcomp_scratch_users)\r\nreturn;\r\nscratches = ipcomp_scratches;\r\nif (!scratches)\r\nreturn;\r\nfor_each_possible_cpu(i)\r\nvfree(*per_cpu_ptr(scratches, i));\r\nfree_percpu(scratches);\r\n}\r\nstatic void * __percpu *ipcomp_alloc_scratches(void)\r\n{\r\nint i;\r\nvoid * __percpu *scratches;\r\nif (ipcomp_scratch_users++)\r\nreturn ipcomp_scratches;\r\nscratches = alloc_percpu(void *);\r\nif (!scratches)\r\nreturn NULL;\r\nipcomp_scratches = scratches;\r\nfor_each_possible_cpu(i) {\r\nvoid *scratch = vmalloc(IPCOMP_SCRATCH_SIZE);\r\nif (!scratch)\r\nreturn NULL;\r\n*per_cpu_ptr(scratches, i) = scratch;\r\n}\r\nreturn scratches;\r\n}\r\nstatic void ipcomp_free_tfms(struct crypto_comp * __percpu *tfms)\r\n{\r\nstruct ipcomp_tfms *pos;\r\nint cpu;\r\nlist_for_each_entry(pos, &ipcomp_tfms_list, list) {\r\nif (pos->tfms == tfms)\r\nbreak;\r\n}\r\nWARN_ON(!pos);\r\nif (--pos->users)\r\nreturn;\r\nlist_del(&pos->list);\r\nkfree(pos);\r\nif (!tfms)\r\nreturn;\r\nfor_each_possible_cpu(cpu) {\r\nstruct crypto_comp *tfm = *per_cpu_ptr(tfms, cpu);\r\ncrypto_free_comp(tfm);\r\n}\r\nfree_percpu(tfms);\r\n}\r\nstatic struct crypto_comp * __percpu *ipcomp_alloc_tfms(const char *alg_name)\r\n{\r\nstruct ipcomp_tfms *pos;\r\nstruct crypto_comp * __percpu *tfms;\r\nint cpu;\r\nlist_for_each_entry(pos, &ipcomp_tfms_list, list) {\r\nstruct crypto_comp *tfm;\r\ntfm = __this_cpu_read(*pos->tfms);\r\nif (!strcmp(crypto_comp_name(tfm), alg_name)) {\r\npos->users++;\r\nreturn pos->tfms;\r\n}\r\n}\r\npos = kmalloc(sizeof(*pos), GFP_KERNEL);\r\nif (!pos)\r\nreturn NULL;\r\npos->users = 1;\r\nINIT_LIST_HEAD(&pos->list);\r\nlist_add(&pos->list, &ipcomp_tfms_list);\r\npos->tfms = tfms = alloc_percpu(struct crypto_comp *);\r\nif (!tfms)\r\ngoto error;\r\nfor_each_possible_cpu(cpu) {\r\nstruct crypto_comp *tfm = crypto_alloc_comp(alg_name, 0,\r\nCRYPTO_ALG_ASYNC);\r\nif (IS_ERR(tfm))\r\ngoto error;\r\n*per_cpu_ptr(tfms, cpu) = tfm;\r\n}\r\nreturn tfms;\r\nerror:\r\nipcomp_free_tfms(tfms);\r\nreturn NULL;\r\n}\r\nstatic void ipcomp_free_data(struct ipcomp_data *ipcd)\r\n{\r\nif (ipcd->tfms)\r\nipcomp_free_tfms(ipcd->tfms);\r\nipcomp_free_scratches();\r\n}\r\nvoid ipcomp_destroy(struct xfrm_state *x)\r\n{\r\nstruct ipcomp_data *ipcd = x->data;\r\nif (!ipcd)\r\nreturn;\r\nxfrm_state_delete_tunnel(x);\r\nmutex_lock(&ipcomp_resource_mutex);\r\nipcomp_free_data(ipcd);\r\nmutex_unlock(&ipcomp_resource_mutex);\r\nkfree(ipcd);\r\n}\r\nint ipcomp_init_state(struct xfrm_state *x)\r\n{\r\nint err;\r\nstruct ipcomp_data *ipcd;\r\nstruct xfrm_algo_desc *calg_desc;\r\nerr = -EINVAL;\r\nif (!x->calg)\r\ngoto out;\r\nif (x->encap)\r\ngoto out;\r\nerr = -ENOMEM;\r\nipcd = kzalloc(sizeof(*ipcd), GFP_KERNEL);\r\nif (!ipcd)\r\ngoto out;\r\nmutex_lock(&ipcomp_resource_mutex);\r\nif (!ipcomp_alloc_scratches())\r\ngoto error;\r\nipcd->tfms = ipcomp_alloc_tfms(x->calg->alg_name);\r\nif (!ipcd->tfms)\r\ngoto error;\r\nmutex_unlock(&ipcomp_resource_mutex);\r\ncalg_desc = xfrm_calg_get_byname(x->calg->alg_name, 0);\r\nBUG_ON(!calg_desc);\r\nipcd->threshold = calg_desc->uinfo.comp.threshold;\r\nx->data = ipcd;\r\nerr = 0;\r\nout:\r\nreturn err;\r\nerror:\r\nipcomp_free_data(ipcd);\r\nmutex_unlock(&ipcomp_resource_mutex);\r\nkfree(ipcd);\r\ngoto out;\r\n}
