static bool alc5632_volatile_register(struct device *dev,\r\nunsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase ALC5632_RESET:\r\ncase ALC5632_PWR_DOWN_CTRL_STATUS:\r\ncase ALC5632_GPIO_PIN_STATUS:\r\ncase ALC5632_OVER_CURR_STATUS:\r\ncase ALC5632_HID_CTRL_DATA:\r\ncase ALC5632_EQ_CTRL:\r\ncase ALC5632_VENDOR_ID1:\r\ncase ALC5632_VENDOR_ID2:\r\nreturn true;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nstatic inline int alc5632_reset(struct regmap *map)\r\n{\r\nreturn regmap_write(map, ALC5632_RESET, 0x59B4);\r\n}\r\nstatic int amp_mixer_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nsnd_soc_write(w->codec, ALC5632_HID_CTRL_INDEX, 0x46);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nsnd_soc_write(w->codec, ALC5632_HID_CTRL_DATA, 0xFFFF);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_write(w->codec, ALC5632_HID_CTRL_DATA, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int alc5632_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\r\nint source, unsigned int freq_in, unsigned int freq_out)\r\n{\r\nint i;\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nint gbl_clk = 0, pll_div = 0;\r\nu16 reg;\r\nif (pll_id < ALC5632_PLL_FR_MCLK || pll_id > ALC5632_PLL_FR_VBCLK)\r\nreturn -EINVAL;\r\nsnd_soc_update_bits(codec, ALC5632_PWR_MANAG_ADD2,\r\nALC5632_PWR_ADD2_PLL1,\r\n0);\r\nsnd_soc_update_bits(codec, ALC5632_PWR_MANAG_ADD2,\r\nALC5632_PWR_ADD2_PLL2,\r\n0);\r\nreg = snd_soc_read(codec, ALC5632_DAI_CONTROL);\r\nif (reg & ALC5632_DAI_SDP_SLAVE_MODE)\r\nreturn 0;\r\nif (!freq_in || !freq_out)\r\nreturn 0;\r\nswitch (pll_id) {\r\ncase ALC5632_PLL_FR_MCLK:\r\nfor (i = 0; i < ARRAY_SIZE(codec_master_pll_div); i++) {\r\nif (codec_master_pll_div[i].pll_in == freq_in\r\n&& codec_master_pll_div[i].pll_out == freq_out) {\r\npll_div = codec_master_pll_div[i].regvalue;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase ALC5632_PLL_FR_BCLK:\r\nfor (i = 0; i < ARRAY_SIZE(codec_slave_pll_div); i++) {\r\nif (codec_slave_pll_div[i].pll_in == freq_in\r\n&& codec_slave_pll_div[i].pll_out == freq_out) {\r\ngbl_clk = ALC5632_PLL_FR_BCLK;\r\npll_div = codec_slave_pll_div[i].regvalue;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase ALC5632_PLL_FR_VBCLK:\r\nfor (i = 0; i < ARRAY_SIZE(codec_slave_pll_div); i++) {\r\nif (codec_slave_pll_div[i].pll_in == freq_in\r\n&& codec_slave_pll_div[i].pll_out == freq_out) {\r\ngbl_clk = ALC5632_PLL_FR_VBCLK;\r\npll_div = codec_slave_pll_div[i].regvalue;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!pll_div)\r\nreturn -EINVAL;\r\nsnd_soc_write(codec, ALC5632_GPCR2, gbl_clk);\r\nsnd_soc_write(codec, ALC5632_PLL1_CTRL, pll_div);\r\nsnd_soc_update_bits(codec, ALC5632_PWR_MANAG_ADD2,\r\nALC5632_PWR_ADD2_PLL1,\r\nALC5632_PWR_ADD2_PLL1);\r\nsnd_soc_update_bits(codec, ALC5632_PWR_MANAG_ADD2,\r\nALC5632_PWR_ADD2_PLL2,\r\nALC5632_PWR_ADD2_PLL2);\r\nsnd_soc_update_bits(codec, ALC5632_GPCR1,\r\nALC5632_GPCR1_CLK_SYS_SRC_SEL_PLL1,\r\nALC5632_GPCR1_CLK_SYS_SRC_SEL_PLL1);\r\nreturn 0;\r\n}\r\nstatic int get_coeff(struct snd_soc_codec *codec, int rate)\r\n{\r\nstruct alc5632_priv *alc5632 = snd_soc_codec_get_drvdata(codec);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(coeff_div); i++) {\r\nif (coeff_div[i].fs * rate == alc5632->sysclk)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int alc5632_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct alc5632_priv *alc5632 = snd_soc_codec_get_drvdata(codec);\r\nswitch (freq) {\r\ncase 4096000:\r\ncase 8192000:\r\ncase 11289600:\r\ncase 12288000:\r\ncase 16384000:\r\ncase 16934400:\r\ncase 18432000:\r\ncase 22579200:\r\ncase 24576000:\r\nalc5632->sysclk = freq;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int alc5632_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 iface = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\niface = ALC5632_DAI_SDP_MASTER_MODE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\niface = ALC5632_DAI_SDP_SLAVE_MODE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\niface |= ALC5632_DAI_I2S_DF_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\niface |= ALC5632_DAI_I2S_DF_LEFT;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\niface |= ALC5632_DAI_I2S_DF_PCM_A;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\niface |= ALC5632_DAI_I2S_DF_PCM_B;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\niface |= ALC5632_DAI_MAIN_I2S_BCLK_POL_CTRL;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\niface |= ALC5632_DAI_MAIN_I2S_BCLK_POL_CTRL;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn snd_soc_write(codec, ALC5632_DAI_CONTROL, iface);\r\n}\r\nstatic int alc5632_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nint coeff, rate;\r\nu16 iface;\r\niface = snd_soc_read(codec, ALC5632_DAI_CONTROL);\r\niface &= ~ALC5632_DAI_I2S_DL_MASK;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\niface |= ALC5632_DAI_I2S_DL_16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\niface |= ALC5632_DAI_I2S_DL_20;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\niface |= ALC5632_DAI_I2S_DL_24;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, ALC5632_DAI_CONTROL, iface);\r\nrate = params_rate(params);\r\ncoeff = get_coeff(codec, rate);\r\nif (coeff < 0)\r\nreturn -EINVAL;\r\ncoeff = coeff_div[coeff].regvalue;\r\nsnd_soc_write(codec, ALC5632_DAC_CLK_CTRL1, coeff);\r\nreturn 0;\r\n}\r\nstatic int alc5632_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 hp_mute = ALC5632_MISC_HP_DEPOP_MUTE_L\r\n|ALC5632_MISC_HP_DEPOP_MUTE_R;\r\nu16 mute_reg = snd_soc_read(codec, ALC5632_MISC_CTRL) & ~hp_mute;\r\nif (mute)\r\nmute_reg |= hp_mute;\r\nreturn snd_soc_write(codec, ALC5632_MISC_CTRL, mute_reg);\r\n}\r\nstatic void enable_power_depop(struct snd_soc_codec *codec)\r\n{\r\nsnd_soc_update_bits(codec, ALC5632_PWR_MANAG_ADD1,\r\nALC5632_PWR_ADD1_SOFTGEN_EN,\r\nALC5632_PWR_ADD1_SOFTGEN_EN);\r\nsnd_soc_update_bits(codec, ALC5632_PWR_MANAG_ADD3,\r\nALC5632_ADD3_POWER_EN,\r\nALC5632_ADD3_POWER_EN);\r\nsnd_soc_update_bits(codec, ALC5632_MISC_CTRL,\r\nALC5632_MISC_HP_DEPOP_MODE2_EN,\r\nALC5632_MISC_HP_DEPOP_MODE2_EN);\r\nsnd_soc_update_bits(codec, ALC5632_PWR_DOWN_CTRL_STATUS,\r\nALC5632_PWR_DOWN_CTRL_STATUS_MASK,\r\n0);\r\nmsleep(500);\r\nsnd_soc_update_bits(codec, ALC5632_PWR_MANAG_ADD2,\r\nALC5632_ADD2_POWER_EN,\r\nALC5632_ADD2_POWER_EN);\r\nsnd_soc_update_bits(codec, ALC5632_PWR_MANAG_ADD1,\r\nALC5632_ADD1_POWER_EN,\r\nALC5632_ADD1_POWER_EN);\r\nsnd_soc_update_bits(codec, ALC5632_MISC_CTRL,\r\nALC5632_MISC_HP_DEPOP_MODE2_EN,\r\n0);\r\n}\r\nstatic int alc5632_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nenable_power_depop(codec);\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nsnd_soc_update_bits(codec, ALC5632_PWR_MANAG_ADD1,\r\nALC5632_PWR_MANAG_ADD1_MASK,\r\nALC5632_PWR_ADD1_MAIN_BIAS);\r\nsnd_soc_update_bits(codec, ALC5632_PWR_MANAG_ADD2,\r\nALC5632_PWR_MANAG_ADD2_MASK,\r\nALC5632_PWR_ADD2_VREF);\r\nsnd_soc_update_bits(codec, ALC5632_PWR_DOWN_CTRL_STATUS,\r\nALC5632_PWR_DOWN_CTRL_STATUS_MASK,\r\n0xffff ^ (ALC5632_PWR_VREF_PR3\r\n| ALC5632_PWR_VREF_PR2));\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, ALC5632_PWR_MANAG_ADD2,\r\nALC5632_PWR_MANAG_ADD2_MASK, 0);\r\nsnd_soc_update_bits(codec, ALC5632_PWR_MANAG_ADD3,\r\nALC5632_PWR_MANAG_ADD3_MASK, 0);\r\nsnd_soc_update_bits(codec, ALC5632_PWR_MANAG_ADD1,\r\nALC5632_PWR_MANAG_ADD1_MASK, 0);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int alc5632_suspend(struct snd_soc_codec *codec)\r\n{\r\nalc5632_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int alc5632_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct alc5632_priv *alc5632 = snd_soc_codec_get_drvdata(codec);\r\nregcache_sync(alc5632->regmap);\r\nalc5632_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int alc5632_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct alc5632_priv *alc5632 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\ncodec->control_data = alc5632->regmap;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 16, SND_SOC_REGMAP);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nalc5632_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nswitch (alc5632->id) {\r\ncase 0x5c:\r\nsnd_soc_add_codec_controls(codec, alc5632_vol_snd_controls,\r\nARRAY_SIZE(alc5632_vol_snd_controls));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int alc5632_remove(struct snd_soc_codec *codec)\r\n{\r\nalc5632_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int alc5632_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct alc5632_priv *alc5632;\r\nint ret, ret1, ret2;\r\nunsigned int vid1, vid2;\r\nalc5632 = devm_kzalloc(&client->dev,\r\nsizeof(struct alc5632_priv), GFP_KERNEL);\r\nif (alc5632 == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, alc5632);\r\nalc5632->regmap = devm_regmap_init_i2c(client, &alc5632_regmap);\r\nif (IS_ERR(alc5632->regmap)) {\r\nret = PTR_ERR(alc5632->regmap);\r\ndev_err(&client->dev, "regmap_init() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret1 = regmap_read(alc5632->regmap, ALC5632_VENDOR_ID1, &vid1);\r\nret2 = regmap_read(alc5632->regmap, ALC5632_VENDOR_ID2, &vid2);\r\nif (ret1 != 0 || ret2 != 0) {\r\ndev_err(&client->dev,\r\n"Failed to read chip ID: ret1=%d, ret2=%d\n", ret1, ret2);\r\nreturn -EIO;\r\n}\r\nvid2 >>= 8;\r\nif ((vid1 != 0x10EC) || (vid2 != id->driver_data)) {\r\ndev_err(&client->dev,\r\n"Device is not a ALC5632: VID1=0x%x, VID2=0x%x\n", vid1, vid2);\r\nreturn -EINVAL;\r\n}\r\nret = alc5632_reset(alc5632->regmap);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to issue reset\n");\r\nreturn ret;\r\n}\r\nalc5632->id = vid2;\r\nswitch (alc5632->id) {\r\ncase 0x5c:\r\nalc5632_dai.name = "alc5632-hifi";\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = snd_soc_register_codec(&client->dev,\r\n&soc_codec_device_alc5632, &alc5632_dai, 1);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to register codec: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int alc5632_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
