acpi_status acpi_ns_root_initialize(void)\r\n{\r\nacpi_status status;\r\nconst struct acpi_predefined_names *init_val = NULL;\r\nstruct acpi_namespace_node *new_node;\r\nunion acpi_operand_object *obj_desc;\r\nacpi_string val = NULL;\r\nACPI_FUNCTION_TRACE(ns_root_initialize);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (acpi_gbl_root_node) {\r\nstatus = AE_OK;\r\ngoto unlock_and_exit;\r\n}\r\nacpi_gbl_root_node = &acpi_gbl_root_node_struct;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Entering predefined entries into namespace\n"));\r\nfor (init_val = acpi_gbl_pre_defined_names; init_val->name; init_val++) {\r\nif (!ACPI_STRCMP(init_val->name, "_OSI")\r\n&& !acpi_gbl_create_osi_method) {\r\ncontinue;\r\n}\r\nstatus = acpi_ns_lookup(NULL, init_val->name, init_val->type,\r\nACPI_IMODE_LOAD_PASS2,\r\nACPI_NS_NO_UPSEARCH, NULL, &new_node);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"Could not create predefined name %s",\r\ninit_val->name));\r\ncontinue;\r\n}\r\nif (init_val->val) {\r\nstatus = acpi_os_predefined_override(init_val, &val);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_ERROR((AE_INFO,\r\n"Could not override predefined %s",\r\ninit_val->name));\r\n}\r\nif (!val) {\r\nval = init_val->val;\r\n}\r\nobj_desc =\r\nacpi_ut_create_internal_object(init_val->type);\r\nif (!obj_desc) {\r\nstatus = AE_NO_MEMORY;\r\ngoto unlock_and_exit;\r\n}\r\nswitch (init_val->type) {\r\ncase ACPI_TYPE_METHOD:\r\nobj_desc->method.param_count =\r\n(u8) ACPI_TO_INTEGER(val);\r\nobj_desc->common.flags |= AOPOBJ_DATA_VALID;\r\n#if defined (ACPI_ASL_COMPILER)\r\nnew_node->value = obj_desc->method.param_count;\r\n#else\r\nobj_desc->method.info_flags =\r\nACPI_METHOD_INTERNAL_ONLY;\r\nobj_desc->method.dispatch.implementation =\r\nacpi_ut_osi_implementation;\r\n#endif\r\nbreak;\r\ncase ACPI_TYPE_INTEGER:\r\nobj_desc->integer.value = ACPI_TO_INTEGER(val);\r\nbreak;\r\ncase ACPI_TYPE_STRING:\r\nobj_desc->string.length = (u32)ACPI_STRLEN(val);\r\nobj_desc->string.pointer = val;\r\nobj_desc->common.flags |= AOPOBJ_STATIC_POINTER;\r\nbreak;\r\ncase ACPI_TYPE_MUTEX:\r\nobj_desc->mutex.node = new_node;\r\nobj_desc->mutex.sync_level =\r\n(u8) (ACPI_TO_INTEGER(val) - 1);\r\nstatus =\r\nacpi_os_create_mutex(&obj_desc->mutex.\r\nos_mutex);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_ut_remove_reference(obj_desc);\r\ngoto unlock_and_exit;\r\n}\r\nif (ACPI_STRCMP(init_val->name, "_GL_") == 0) {\r\nacpi_gbl_global_lock_mutex = obj_desc;\r\nstatus =\r\nacpi_os_create_semaphore(1, 0,\r\n&acpi_gbl_global_lock_semaphore);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_ut_remove_reference\r\n(obj_desc);\r\ngoto unlock_and_exit;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nACPI_ERROR((AE_INFO,\r\n"Unsupported initial type value 0x%X",\r\ninit_val->type));\r\nacpi_ut_remove_reference(obj_desc);\r\nobj_desc = NULL;\r\ncontinue;\r\n}\r\nstatus = acpi_ns_attach_object(new_node, obj_desc,\r\nobj_desc->common.type);\r\nacpi_ut_remove_reference(obj_desc);\r\n}\r\n}\r\nunlock_and_exit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_SUCCESS(status)) {\r\nstatus = acpi_ns_get_node(NULL, "\\_GPE", ACPI_NS_NO_UPSEARCH,\r\n&acpi_gbl_fadt_gpe_device);\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ns_lookup(union acpi_generic_state *scope_info,\r\nchar *pathname,\r\nacpi_object_type type,\r\nacpi_interpreter_mode interpreter_mode,\r\nu32 flags,\r\nstruct acpi_walk_state *walk_state,\r\nstruct acpi_namespace_node **return_node)\r\n{\r\nacpi_status status;\r\nchar *path = pathname;\r\nstruct acpi_namespace_node *prefix_node;\r\nstruct acpi_namespace_node *current_node = NULL;\r\nstruct acpi_namespace_node *this_node = NULL;\r\nu32 num_segments;\r\nu32 num_carats;\r\nacpi_name simple_name;\r\nacpi_object_type type_to_check_for;\r\nacpi_object_type this_search_type;\r\nu32 search_parent_flag = ACPI_NS_SEARCH_PARENT;\r\nu32 local_flags;\r\nACPI_FUNCTION_TRACE(ns_lookup);\r\nif (!return_node) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nlocal_flags = flags & ~(ACPI_NS_ERROR_IF_FOUND | ACPI_NS_SEARCH_PARENT);\r\n*return_node = ACPI_ENTRY_NOT_FOUND;\r\nacpi_gbl_ns_lookup_count++;\r\nif (!acpi_gbl_root_node) {\r\nreturn_ACPI_STATUS(AE_NO_NAMESPACE);\r\n}\r\nif ((!scope_info) || (!scope_info->scope.node)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_NAMES,\r\n"Null scope prefix, using root node (%p)\n",\r\nacpi_gbl_root_node));\r\nprefix_node = acpi_gbl_root_node;\r\n} else {\r\nprefix_node = scope_info->scope.node;\r\nif (ACPI_GET_DESCRIPTOR_TYPE(prefix_node) !=\r\nACPI_DESC_TYPE_NAMED) {\r\nACPI_ERROR((AE_INFO, "%p is not a namespace node [%s]",\r\nprefix_node,\r\nacpi_ut_get_descriptor_name(prefix_node)));\r\nreturn_ACPI_STATUS(AE_AML_INTERNAL);\r\n}\r\nif (!(flags & ACPI_NS_PREFIX_IS_SCOPE)) {\r\nwhile (!acpi_ns_opens_scope(prefix_node->type) &&\r\nprefix_node->type != ACPI_TYPE_ANY) {\r\nprefix_node = prefix_node->parent;\r\n}\r\n}\r\n}\r\ntype_to_check_for = type;\r\nif (!pathname) {\r\nnum_segments = 0;\r\nthis_node = acpi_gbl_root_node;\r\npath = "";\r\nACPI_DEBUG_PRINT((ACPI_DB_NAMES,\r\n"Null Pathname (Zero segments), Flags=%X\n",\r\nflags));\r\n} else {\r\nif (*path == (u8) AML_ROOT_PREFIX) {\r\nthis_node = acpi_gbl_root_node;\r\nsearch_parent_flag = ACPI_NS_NO_UPSEARCH;\r\npath++;\r\nACPI_DEBUG_PRINT((ACPI_DB_NAMES,\r\n"Path is absolute from root [%p]\n",\r\nthis_node));\r\n} else {\r\nACPI_DEBUG_PRINT((ACPI_DB_NAMES,\r\n"Searching relative to prefix scope [%4.4s] (%p)\n",\r\nacpi_ut_get_node_name(prefix_node),\r\nprefix_node));\r\nthis_node = prefix_node;\r\nnum_carats = 0;\r\nwhile (*path == (u8) AML_PARENT_PREFIX) {\r\nsearch_parent_flag = ACPI_NS_NO_UPSEARCH;\r\npath++;\r\nnum_carats++;\r\nthis_node = this_node->parent;\r\nif (!this_node) {\r\nACPI_ERROR((AE_INFO,\r\n"ACPI path has too many parent prefixes (^) "\r\n"- reached beyond root node"));\r\nreturn_ACPI_STATUS(AE_NOT_FOUND);\r\n}\r\n}\r\nif (search_parent_flag == ACPI_NS_NO_UPSEARCH) {\r\nACPI_DEBUG_PRINT((ACPI_DB_NAMES,\r\n"Search scope is [%4.4s], path has %u carat(s)\n",\r\nacpi_ut_get_node_name\r\n(this_node), num_carats));\r\n}\r\n}\r\nswitch (*path) {\r\ncase 0:\r\nnum_segments = 0;\r\ntype = this_node->type;\r\nACPI_DEBUG_PRINT((ACPI_DB_NAMES,\r\n"Prefix-only Pathname (Zero name segments), Flags=%X\n",\r\nflags));\r\nbreak;\r\ncase AML_DUAL_NAME_PREFIX:\r\nsearch_parent_flag = ACPI_NS_NO_UPSEARCH;\r\nnum_segments = 2;\r\npath++;\r\nACPI_DEBUG_PRINT((ACPI_DB_NAMES,\r\n"Dual Pathname (2 segments, Flags=%X)\n",\r\nflags));\r\nbreak;\r\ncase AML_MULTI_NAME_PREFIX_OP:\r\nsearch_parent_flag = ACPI_NS_NO_UPSEARCH;\r\npath++;\r\nnum_segments = (u32) (u8) * path;\r\npath++;\r\nACPI_DEBUG_PRINT((ACPI_DB_NAMES,\r\n"Multi Pathname (%u Segments, Flags=%X)\n",\r\nnum_segments, flags));\r\nbreak;\r\ndefault:\r\nnum_segments = 1;\r\nACPI_DEBUG_PRINT((ACPI_DB_NAMES,\r\n"Simple Pathname (1 segment, Flags=%X)\n",\r\nflags));\r\nbreak;\r\n}\r\nACPI_DEBUG_EXEC(acpi_ns_print_pathname(num_segments, path));\r\n}\r\nthis_search_type = ACPI_TYPE_ANY;\r\ncurrent_node = this_node;\r\nwhile (num_segments && current_node) {\r\nnum_segments--;\r\nif (!num_segments) {\r\nthis_search_type = type;\r\nif ((search_parent_flag != ACPI_NS_NO_UPSEARCH) &&\r\n(flags & ACPI_NS_SEARCH_PARENT)) {\r\nlocal_flags |= ACPI_NS_SEARCH_PARENT;\r\n}\r\nif (flags & ACPI_NS_ERROR_IF_FOUND) {\r\nlocal_flags |= ACPI_NS_ERROR_IF_FOUND;\r\n}\r\n}\r\nACPI_MOVE_32_TO_32(&simple_name, path);\r\nstatus =\r\nacpi_ns_search_and_enter(simple_name, walk_state,\r\ncurrent_node, interpreter_mode,\r\nthis_search_type, local_flags,\r\n&this_node);\r\nif (ACPI_FAILURE(status)) {\r\nif (status == AE_NOT_FOUND) {\r\nACPI_DEBUG_PRINT((ACPI_DB_NAMES,\r\n"Name [%4.4s] not found in scope [%4.4s] %p\n",\r\n(char *)&simple_name,\r\n(char *)&current_node->name,\r\ncurrent_node));\r\n}\r\n*return_node = this_node;\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (num_segments > 0) {\r\nif (this_node->type == ACPI_TYPE_LOCAL_ALIAS) {\r\nif (!this_node->object) {\r\nreturn_ACPI_STATUS(AE_NOT_EXIST);\r\n}\r\nif (acpi_ns_opens_scope\r\n(((struct acpi_namespace_node *)\r\nthis_node->object)->type)) {\r\nthis_node =\r\n(struct acpi_namespace_node *)\r\nthis_node->object;\r\n}\r\n}\r\n}\r\nelse {\r\nif ((type_to_check_for != ACPI_TYPE_ANY) &&\r\n(type_to_check_for != ACPI_TYPE_LOCAL_ALIAS) &&\r\n(type_to_check_for != ACPI_TYPE_LOCAL_METHOD_ALIAS)\r\n&& (type_to_check_for != ACPI_TYPE_LOCAL_SCOPE)\r\n&& (this_node->type != ACPI_TYPE_ANY)\r\n&& (this_node->type != type_to_check_for)) {\r\nACPI_WARNING((AE_INFO,\r\n"NsLookup: Type mismatch on %4.4s (%s), searching for (%s)",\r\nACPI_CAST_PTR(char, &simple_name),\r\nacpi_ut_get_type_name(this_node->\r\ntype),\r\nacpi_ut_get_type_name\r\n(type_to_check_for)));\r\n}\r\nif (type == ACPI_TYPE_ANY) {\r\ntype = this_node->type;\r\n}\r\n}\r\npath += ACPI_NAME_SIZE;\r\ncurrent_node = this_node;\r\n}\r\nif (!(flags & ACPI_NS_DONT_OPEN_SCOPE) && (walk_state)) {\r\nif (acpi_ns_opens_scope(type)) {\r\nstatus =\r\nacpi_ds_scope_stack_push(this_node, type,\r\nwalk_state);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\n}\r\n*return_node = this_node;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}
