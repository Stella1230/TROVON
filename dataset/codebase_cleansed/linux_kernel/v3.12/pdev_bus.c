static void goldfish_pdev_worker(struct work_struct *work)\r\n{\r\nint ret;\r\nstruct pdev_bus_dev *pos, *n;\r\nlist_for_each_entry_safe(pos, n, &pdev_bus_removed_devices, list) {\r\nlist_del(&pos->list);\r\nplatform_device_unregister(&pos->pdev);\r\nkfree(pos);\r\n}\r\nlist_for_each_entry_safe(pos, n, &pdev_bus_new_devices, list) {\r\nlist_del(&pos->list);\r\nret = platform_device_register(&pos->pdev);\r\nif (ret)\r\npr_err("goldfish_pdev_worker failed to register device, %s\n",\r\npos->pdev.name);\r\nlist_add_tail(&pos->list, &pdev_bus_registered_devices);\r\n}\r\n}\r\nstatic void goldfish_pdev_remove(void)\r\n{\r\nstruct pdev_bus_dev *pos, *n;\r\nu32 base;\r\nbase = readl(pdev_bus_base + PDEV_BUS_IO_BASE);\r\nlist_for_each_entry_safe(pos, n, &pdev_bus_new_devices, list) {\r\nif (pos->resources[0].start == base) {\r\nlist_del(&pos->list);\r\nkfree(pos);\r\nreturn;\r\n}\r\n}\r\nlist_for_each_entry_safe(pos, n, &pdev_bus_registered_devices, list) {\r\nif (pos->resources[0].start == base) {\r\nlist_del(&pos->list);\r\nlist_add_tail(&pos->list, &pdev_bus_removed_devices);\r\nschedule_work(&pdev_bus_worker);\r\nreturn;\r\n}\r\n};\r\npr_err("goldfish_pdev_remove could not find device at %x\n", base);\r\n}\r\nstatic int goldfish_new_pdev(void)\r\n{\r\nstruct pdev_bus_dev *dev;\r\nu32 name_len;\r\nu32 irq = -1, irq_count;\r\nint resource_count = 2;\r\nu32 base;\r\nchar *name;\r\nbase = readl(pdev_bus_base + PDEV_BUS_IO_BASE);\r\nirq_count = readl(pdev_bus_base + PDEV_BUS_IRQ_COUNT);\r\nname_len = readl(pdev_bus_base + PDEV_BUS_NAME_LEN);\r\nif (irq_count)\r\nresource_count++;\r\ndev = kzalloc(sizeof(*dev) +\r\nsizeof(struct resource) * resource_count +\r\nname_len + 1 + sizeof(*dev->pdev.dev.dma_mask), GFP_ATOMIC);\r\nif (dev == NULL)\r\nreturn -ENOMEM;\r\ndev->pdev.num_resources = resource_count;\r\ndev->pdev.resource = (struct resource *)(dev + 1);\r\ndev->pdev.name = name = (char *)(dev->pdev.resource + resource_count);\r\ndev->pdev.dev.coherent_dma_mask = ~0;\r\ndev->pdev.dev.dma_mask = (void *)(dev->pdev.name + name_len + 1);\r\n*dev->pdev.dev.dma_mask = ~0;\r\nwritel((unsigned long)name, pdev_bus_base + PDEV_BUS_GET_NAME);\r\nname[name_len] = '\0';\r\ndev->pdev.id = readl(pdev_bus_base + PDEV_BUS_ID);\r\ndev->pdev.resource[0].start = base;\r\ndev->pdev.resource[0].end = base +\r\nreadl(pdev_bus_base + PDEV_BUS_IO_SIZE) - 1;\r\ndev->pdev.resource[0].flags = IORESOURCE_MEM;\r\nif (irq_count) {\r\nirq = readl(pdev_bus_base + PDEV_BUS_IRQ);\r\ndev->pdev.resource[1].start = irq;\r\ndev->pdev.resource[1].end = irq + irq_count - 1;\r\ndev->pdev.resource[1].flags = IORESOURCE_IRQ;\r\n}\r\npr_debug("goldfish_new_pdev %s at %x irq %d\n", name, base, irq);\r\nlist_add_tail(&dev->list, &pdev_bus_new_devices);\r\nschedule_work(&pdev_bus_worker);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t goldfish_pdev_bus_interrupt(int irq, void *dev_id)\r\n{\r\nirqreturn_t ret = IRQ_NONE;\r\nwhile (1) {\r\nu32 op = readl(pdev_bus_base + PDEV_BUS_OP);\r\nswitch (op) {\r\ncase PDEV_BUS_OP_DONE:\r\nreturn IRQ_NONE;\r\ncase PDEV_BUS_OP_REMOVE_DEV:\r\ngoldfish_pdev_remove();\r\nbreak;\r\ncase PDEV_BUS_OP_ADD_DEV:\r\ngoldfish_new_pdev();\r\nbreak;\r\n}\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic int goldfish_pdev_bus_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct resource *r;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (r == NULL)\r\nreturn -EINVAL;\r\npdev_bus_addr = r->start;\r\npdev_bus_len = resource_size(r);\r\nif (request_mem_region(pdev_bus_addr, pdev_bus_len, "goldfish")) {\r\ndev_err(&pdev->dev, "unable to reserve Goldfish MMIO.\n");\r\nreturn -EBUSY;\r\n}\r\npdev_bus_base = ioremap(pdev_bus_addr, pdev_bus_len);\r\nif (pdev_bus_base == NULL) {\r\nret = -ENOMEM;\r\ndev_err(&pdev->dev, "unable to map Goldfish MMIO.\n");\r\ngoto free_resources;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (r == NULL) {\r\nret = -ENOENT;\r\ngoto free_map;\r\n}\r\npdev_bus_irq = r->start;\r\nret = request_irq(pdev_bus_irq, goldfish_pdev_bus_interrupt,\r\nIRQF_SHARED, "goldfish_pdev_bus", pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to request Goldfish IRQ\n");\r\ngoto free_map;\r\n}\r\nwritel(PDEV_BUS_OP_INIT, pdev_bus_base + PDEV_BUS_OP);\r\nreturn 0;\r\nfree_map:\r\niounmap(pdev_bus_base);\r\nfree_resources:\r\nrelease_mem_region(pdev_bus_addr, pdev_bus_len);\r\nreturn ret;\r\n}\r\nstatic int goldfish_pdev_bus_remove(struct platform_device *pdev)\r\n{\r\niounmap(pdev_bus_base);\r\nfree_irq(pdev_bus_irq, pdev);\r\nrelease_mem_region(pdev_bus_addr, pdev_bus_len);\r\nreturn 0;\r\n}
