int ntfs_map_runlist_nolock(ntfs_inode *ni, VCN vcn, ntfs_attr_search_ctx *ctx)\r\n{\r\nVCN end_vcn;\r\nunsigned long flags;\r\nntfs_inode *base_ni;\r\nMFT_RECORD *m;\r\nATTR_RECORD *a;\r\nrunlist_element *rl;\r\nstruct page *put_this_page = NULL;\r\nint err = 0;\r\nbool ctx_is_temporary, ctx_needs_reset;\r\nntfs_attr_search_ctx old_ctx = { NULL, };\r\nntfs_debug("Mapping runlist part containing vcn 0x%llx.",\r\n(unsigned long long)vcn);\r\nif (!NInoAttr(ni))\r\nbase_ni = ni;\r\nelse\r\nbase_ni = ni->ext.base_ntfs_ino;\r\nif (!ctx) {\r\nctx_is_temporary = ctx_needs_reset = true;\r\nm = map_mft_record(base_ni);\r\nif (IS_ERR(m))\r\nreturn PTR_ERR(m);\r\nctx = ntfs_attr_get_search_ctx(base_ni, m);\r\nif (unlikely(!ctx)) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\n} else {\r\nVCN allocated_size_vcn;\r\nBUG_ON(IS_ERR(ctx->mrec));\r\na = ctx->attr;\r\nBUG_ON(!a->non_resident);\r\nctx_is_temporary = false;\r\nend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\r\nread_lock_irqsave(&ni->size_lock, flags);\r\nallocated_size_vcn = ni->allocated_size >>\r\nni->vol->cluster_size_bits;\r\nread_unlock_irqrestore(&ni->size_lock, flags);\r\nif (!a->data.non_resident.lowest_vcn && end_vcn <= 0)\r\nend_vcn = allocated_size_vcn - 1;\r\nif (vcn >= allocated_size_vcn || (a->type == ni->type &&\r\na->name_length == ni->name_len &&\r\n!memcmp((u8*)a + le16_to_cpu(a->name_offset),\r\nni->name, ni->name_len) &&\r\nsle64_to_cpu(a->data.non_resident.lowest_vcn)\r\n<= vcn && end_vcn >= vcn))\r\nctx_needs_reset = false;\r\nelse {\r\nold_ctx = *ctx;\r\nif (old_ctx.base_ntfs_ino && old_ctx.ntfs_ino !=\r\nold_ctx.base_ntfs_ino) {\r\nput_this_page = old_ctx.ntfs_ino->page;\r\npage_cache_get(put_this_page);\r\n}\r\nntfs_attr_reinit_search_ctx(ctx);\r\nctx_needs_reset = true;\r\n}\r\n}\r\nif (ctx_needs_reset) {\r\nerr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\r\nCASE_SENSITIVE, vcn, NULL, 0, ctx);\r\nif (unlikely(err)) {\r\nif (err == -ENOENT)\r\nerr = -EIO;\r\ngoto err_out;\r\n}\r\nBUG_ON(!ctx->attr->non_resident);\r\n}\r\na = ctx->attr;\r\nend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn) + 1;\r\nif (unlikely(vcn && vcn >= end_vcn)) {\r\nerr = -ENOENT;\r\ngoto err_out;\r\n}\r\nrl = ntfs_mapping_pairs_decompress(ni->vol, a, ni->runlist.rl);\r\nif (IS_ERR(rl))\r\nerr = PTR_ERR(rl);\r\nelse\r\nni->runlist.rl = rl;\r\nerr_out:\r\nif (ctx_is_temporary) {\r\nif (likely(ctx))\r\nntfs_attr_put_search_ctx(ctx);\r\nunmap_mft_record(base_ni);\r\n} else if (ctx_needs_reset) {\r\nif (NInoAttrList(base_ni)) {\r\nif (ctx->ntfs_ino != old_ctx.ntfs_ino) {\r\nif (ctx->base_ntfs_ino && ctx->ntfs_ino !=\r\nctx->base_ntfs_ino) {\r\nunmap_extent_mft_record(ctx->ntfs_ino);\r\nctx->mrec = ctx->base_mrec;\r\nBUG_ON(!ctx->mrec);\r\n}\r\nif (old_ctx.base_ntfs_ino &&\r\nold_ctx.ntfs_ino !=\r\nold_ctx.base_ntfs_ino) {\r\nretry_map:\r\nctx->mrec = map_mft_record(\r\nold_ctx.ntfs_ino);\r\nif (IS_ERR(ctx->mrec)) {\r\nif (PTR_ERR(ctx->mrec) ==\r\n-ENOMEM) {\r\nschedule();\r\ngoto retry_map;\r\n} else\r\nold_ctx.ntfs_ino =\r\nold_ctx.\r\nbase_ntfs_ino;\r\n}\r\n}\r\n}\r\nif (ctx->mrec != old_ctx.mrec) {\r\nif (!IS_ERR(ctx->mrec))\r\nold_ctx.attr = (ATTR_RECORD*)(\r\n(u8*)ctx->mrec +\r\n((u8*)old_ctx.attr -\r\n(u8*)old_ctx.mrec));\r\nold_ctx.mrec = ctx->mrec;\r\n}\r\n}\r\n*ctx = old_ctx;\r\nif (put_this_page)\r\npage_cache_release(put_this_page);\r\n}\r\nreturn err;\r\n}\r\nint ntfs_map_runlist(ntfs_inode *ni, VCN vcn)\r\n{\r\nint err = 0;\r\ndown_write(&ni->runlist.lock);\r\nif (likely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) <=\r\nLCN_RL_NOT_MAPPED))\r\nerr = ntfs_map_runlist_nolock(ni, vcn, NULL);\r\nup_write(&ni->runlist.lock);\r\nreturn err;\r\n}\r\nLCN ntfs_attr_vcn_to_lcn_nolock(ntfs_inode *ni, const VCN vcn,\r\nconst bool write_locked)\r\n{\r\nLCN lcn;\r\nunsigned long flags;\r\nbool is_retry = false;\r\nBUG_ON(!ni);\r\nntfs_debug("Entering for i_ino 0x%lx, vcn 0x%llx, %s_locked.",\r\nni->mft_no, (unsigned long long)vcn,\r\nwrite_locked ? "write" : "read");\r\nBUG_ON(!NInoNonResident(ni));\r\nBUG_ON(vcn < 0);\r\nif (!ni->runlist.rl) {\r\nread_lock_irqsave(&ni->size_lock, flags);\r\nif (!ni->allocated_size) {\r\nread_unlock_irqrestore(&ni->size_lock, flags);\r\nreturn LCN_ENOENT;\r\n}\r\nread_unlock_irqrestore(&ni->size_lock, flags);\r\n}\r\nretry_remap:\r\nlcn = ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn);\r\nif (likely(lcn >= LCN_HOLE)) {\r\nntfs_debug("Done, lcn 0x%llx.", (long long)lcn);\r\nreturn lcn;\r\n}\r\nif (lcn != LCN_RL_NOT_MAPPED) {\r\nif (lcn != LCN_ENOENT)\r\nlcn = LCN_EIO;\r\n} else if (!is_retry) {\r\nint err;\r\nif (!write_locked) {\r\nup_read(&ni->runlist.lock);\r\ndown_write(&ni->runlist.lock);\r\nif (unlikely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) !=\r\nLCN_RL_NOT_MAPPED)) {\r\nup_write(&ni->runlist.lock);\r\ndown_read(&ni->runlist.lock);\r\ngoto retry_remap;\r\n}\r\n}\r\nerr = ntfs_map_runlist_nolock(ni, vcn, NULL);\r\nif (!write_locked) {\r\nup_write(&ni->runlist.lock);\r\ndown_read(&ni->runlist.lock);\r\n}\r\nif (likely(!err)) {\r\nis_retry = true;\r\ngoto retry_remap;\r\n}\r\nif (err == -ENOENT)\r\nlcn = LCN_ENOENT;\r\nelse if (err == -ENOMEM)\r\nlcn = LCN_ENOMEM;\r\nelse\r\nlcn = LCN_EIO;\r\n}\r\nif (lcn != LCN_ENOENT)\r\nntfs_error(ni->vol->sb, "Failed with error code %lli.",\r\n(long long)lcn);\r\nreturn lcn;\r\n}\r\nrunlist_element *ntfs_attr_find_vcn_nolock(ntfs_inode *ni, const VCN vcn,\r\nntfs_attr_search_ctx *ctx)\r\n{\r\nunsigned long flags;\r\nrunlist_element *rl;\r\nint err = 0;\r\nbool is_retry = false;\r\nBUG_ON(!ni);\r\nntfs_debug("Entering for i_ino 0x%lx, vcn 0x%llx, with%s ctx.",\r\nni->mft_no, (unsigned long long)vcn, ctx ? "" : "out");\r\nBUG_ON(!NInoNonResident(ni));\r\nBUG_ON(vcn < 0);\r\nif (!ni->runlist.rl) {\r\nread_lock_irqsave(&ni->size_lock, flags);\r\nif (!ni->allocated_size) {\r\nread_unlock_irqrestore(&ni->size_lock, flags);\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nread_unlock_irqrestore(&ni->size_lock, flags);\r\n}\r\nretry_remap:\r\nrl = ni->runlist.rl;\r\nif (likely(rl && vcn >= rl[0].vcn)) {\r\nwhile (likely(rl->length)) {\r\nif (unlikely(vcn < rl[1].vcn)) {\r\nif (likely(rl->lcn >= LCN_HOLE)) {\r\nntfs_debug("Done.");\r\nreturn rl;\r\n}\r\nbreak;\r\n}\r\nrl++;\r\n}\r\nif (likely(rl->lcn != LCN_RL_NOT_MAPPED)) {\r\nif (likely(rl->lcn == LCN_ENOENT))\r\nerr = -ENOENT;\r\nelse\r\nerr = -EIO;\r\n}\r\n}\r\nif (!err && !is_retry) {\r\nif (IS_ERR(ctx->mrec))\r\nerr = PTR_ERR(ctx->mrec);\r\nelse {\r\nerr = ntfs_map_runlist_nolock(ni, vcn, ctx);\r\nif (likely(!err)) {\r\nis_retry = true;\r\ngoto retry_remap;\r\n}\r\n}\r\nif (err == -EINVAL)\r\nerr = -EIO;\r\n} else if (!err)\r\nerr = -EIO;\r\nif (err != -ENOENT)\r\nntfs_error(ni->vol->sb, "Failed with error code %i.", err);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int ntfs_attr_find(const ATTR_TYPE type, const ntfschar *name,\r\nconst u32 name_len, const IGNORE_CASE_BOOL ic,\r\nconst u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx)\r\n{\r\nATTR_RECORD *a;\r\nntfs_volume *vol = ctx->ntfs_ino->vol;\r\nntfschar *upcase = vol->upcase;\r\nu32 upcase_len = vol->upcase_len;\r\nif (ctx->is_first) {\r\na = ctx->attr;\r\nctx->is_first = false;\r\n} else\r\na = (ATTR_RECORD*)((u8*)ctx->attr +\r\nle32_to_cpu(ctx->attr->length));\r\nfor (;; a = (ATTR_RECORD*)((u8*)a + le32_to_cpu(a->length))) {\r\nif ((u8*)a < (u8*)ctx->mrec || (u8*)a > (u8*)ctx->mrec +\r\nle32_to_cpu(ctx->mrec->bytes_allocated))\r\nbreak;\r\nctx->attr = a;\r\nif (unlikely(le32_to_cpu(a->type) > le32_to_cpu(type) ||\r\na->type == AT_END))\r\nreturn -ENOENT;\r\nif (unlikely(!a->length))\r\nbreak;\r\nif (a->type != type)\r\ncontinue;\r\nif (!name) {\r\nif (a->name_length)\r\nreturn -ENOENT;\r\n} else if (!ntfs_are_names_equal(name, name_len,\r\n(ntfschar*)((u8*)a + le16_to_cpu(a->name_offset)),\r\na->name_length, ic, upcase, upcase_len)) {\r\nregister int rc;\r\nrc = ntfs_collate_names(name, name_len,\r\n(ntfschar*)((u8*)a +\r\nle16_to_cpu(a->name_offset)),\r\na->name_length, 1, IGNORE_CASE,\r\nupcase, upcase_len);\r\nif (rc == -1)\r\nreturn -ENOENT;\r\nif (rc)\r\ncontinue;\r\nrc = ntfs_collate_names(name, name_len,\r\n(ntfschar*)((u8*)a +\r\nle16_to_cpu(a->name_offset)),\r\na->name_length, 1, CASE_SENSITIVE,\r\nupcase, upcase_len);\r\nif (rc == -1)\r\nreturn -ENOENT;\r\nif (rc)\r\ncontinue;\r\n}\r\nif (!val)\r\nreturn 0;\r\nelse {\r\nregister int rc;\r\nrc = memcmp(val, (u8*)a + le16_to_cpu(\r\na->data.resident.value_offset),\r\nmin_t(u32, val_len, le32_to_cpu(\r\na->data.resident.value_length)));\r\nif (!rc) {\r\nregister u32 avl;\r\navl = le32_to_cpu(\r\na->data.resident.value_length);\r\nif (val_len == avl)\r\nreturn 0;\r\nif (val_len < avl)\r\nreturn -ENOENT;\r\n} else if (rc < 0)\r\nreturn -ENOENT;\r\n}\r\n}\r\nntfs_error(vol->sb, "Inode is corrupt. Run chkdsk.");\r\nNVolSetErrors(vol);\r\nreturn -EIO;\r\n}\r\nint load_attribute_list(ntfs_volume *vol, runlist *runlist, u8 *al_start,\r\nconst s64 size, const s64 initialized_size)\r\n{\r\nLCN lcn;\r\nu8 *al = al_start;\r\nu8 *al_end = al + initialized_size;\r\nrunlist_element *rl;\r\nstruct buffer_head *bh;\r\nstruct super_block *sb;\r\nunsigned long block_size;\r\nunsigned long block, max_block;\r\nint err = 0;\r\nunsigned char block_size_bits;\r\nntfs_debug("Entering.");\r\nif (!vol || !runlist || !al || size <= 0 || initialized_size < 0 ||\r\ninitialized_size > size)\r\nreturn -EINVAL;\r\nif (!initialized_size) {\r\nmemset(al, 0, size);\r\nreturn 0;\r\n}\r\nsb = vol->sb;\r\nblock_size = sb->s_blocksize;\r\nblock_size_bits = sb->s_blocksize_bits;\r\ndown_read(&runlist->lock);\r\nrl = runlist->rl;\r\nif (!rl) {\r\nntfs_error(sb, "Cannot read attribute list since runlist is "\r\n"missing.");\r\ngoto err_out;\r\n}\r\nwhile (rl->length) {\r\nlcn = ntfs_rl_vcn_to_lcn(rl, rl->vcn);\r\nntfs_debug("Reading vcn = 0x%llx, lcn = 0x%llx.",\r\n(unsigned long long)rl->vcn,\r\n(unsigned long long)lcn);\r\nif (lcn < 0) {\r\nntfs_error(sb, "ntfs_rl_vcn_to_lcn() failed. Cannot "\r\n"read attribute list.");\r\ngoto err_out;\r\n}\r\nblock = lcn << vol->cluster_size_bits >> block_size_bits;\r\nmax_block = block + (rl->length << vol->cluster_size_bits >>\r\nblock_size_bits);\r\nntfs_debug("max_block = 0x%lx.", max_block);\r\ndo {\r\nntfs_debug("Reading block = 0x%lx.", block);\r\nbh = sb_bread(sb, block);\r\nif (!bh) {\r\nntfs_error(sb, "sb_bread() failed. Cannot "\r\n"read attribute list.");\r\ngoto err_out;\r\n}\r\nif (al + block_size >= al_end)\r\ngoto do_final;\r\nmemcpy(al, bh->b_data, block_size);\r\nbrelse(bh);\r\nal += block_size;\r\n} while (++block < max_block);\r\nrl++;\r\n}\r\nif (initialized_size < size) {\r\ninitialize:\r\nmemset(al_start + initialized_size, 0, size - initialized_size);\r\n}\r\ndone:\r\nup_read(&runlist->lock);\r\nreturn err;\r\ndo_final:\r\nif (al < al_end) {\r\nmemcpy(al, bh->b_data, al_end - al);\r\nbrelse(bh);\r\nif (initialized_size < size)\r\ngoto initialize;\r\ngoto done;\r\n}\r\nbrelse(bh);\r\nntfs_error(sb, "Attribute list buffer overflow. Read attribute list "\r\n"is truncated.");\r\nerr_out:\r\nerr = -EIO;\r\ngoto done;\r\n}\r\nstatic int ntfs_external_attr_find(const ATTR_TYPE type,\r\nconst ntfschar *name, const u32 name_len,\r\nconst IGNORE_CASE_BOOL ic, const VCN lowest_vcn,\r\nconst u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx)\r\n{\r\nntfs_inode *base_ni, *ni;\r\nntfs_volume *vol;\r\nATTR_LIST_ENTRY *al_entry, *next_al_entry;\r\nu8 *al_start, *al_end;\r\nATTR_RECORD *a;\r\nntfschar *al_name;\r\nu32 al_name_len;\r\nint err = 0;\r\nstatic const char *es = " Unmount and run chkdsk.";\r\nni = ctx->ntfs_ino;\r\nbase_ni = ctx->base_ntfs_ino;\r\nntfs_debug("Entering for inode 0x%lx, type 0x%x.", ni->mft_no, type);\r\nif (!base_ni) {\r\nbase_ni = ctx->base_ntfs_ino = ctx->ntfs_ino;\r\nctx->base_mrec = ctx->mrec;\r\n}\r\nif (ni == base_ni)\r\nctx->base_attr = ctx->attr;\r\nif (type == AT_END)\r\ngoto not_found;\r\nvol = base_ni->vol;\r\nal_start = base_ni->attr_list;\r\nal_end = al_start + base_ni->attr_list_size;\r\nif (!ctx->al_entry)\r\nctx->al_entry = (ATTR_LIST_ENTRY*)al_start;\r\nif (ctx->is_first) {\r\nal_entry = ctx->al_entry;\r\nctx->is_first = false;\r\n} else\r\nal_entry = (ATTR_LIST_ENTRY*)((u8*)ctx->al_entry +\r\nle16_to_cpu(ctx->al_entry->length));\r\nfor (;; al_entry = next_al_entry) {\r\nif ((u8*)al_entry < base_ni->attr_list ||\r\n(u8*)al_entry > al_end)\r\nbreak;\r\nctx->al_entry = al_entry;\r\nif ((u8*)al_entry == al_end)\r\ngoto not_found;\r\nif (!al_entry->length)\r\nbreak;\r\nif ((u8*)al_entry + 6 > al_end || (u8*)al_entry +\r\nle16_to_cpu(al_entry->length) > al_end)\r\nbreak;\r\nnext_al_entry = (ATTR_LIST_ENTRY*)((u8*)al_entry +\r\nle16_to_cpu(al_entry->length));\r\nif (le32_to_cpu(al_entry->type) > le32_to_cpu(type))\r\ngoto not_found;\r\nif (type != al_entry->type)\r\ncontinue;\r\nal_name_len = al_entry->name_length;\r\nal_name = (ntfschar*)((u8*)al_entry + al_entry->name_offset);\r\nif (!name) {\r\nif (al_name_len)\r\ngoto not_found;\r\n} else if (!ntfs_are_names_equal(al_name, al_name_len, name,\r\nname_len, ic, vol->upcase, vol->upcase_len)) {\r\nregister int rc;\r\nrc = ntfs_collate_names(name, name_len, al_name,\r\nal_name_len, 1, IGNORE_CASE,\r\nvol->upcase, vol->upcase_len);\r\nif (rc == -1)\r\ngoto not_found;\r\nif (rc)\r\ncontinue;\r\nrc = ntfs_collate_names(name, name_len, al_name,\r\nal_name_len, 1, CASE_SENSITIVE,\r\nvol->upcase, vol->upcase_len);\r\nif (rc == -1)\r\ngoto not_found;\r\nif (rc)\r\ncontinue;\r\n}\r\nif (lowest_vcn && (u8*)next_al_entry >= al_start &&\r\n(u8*)next_al_entry + 6 < al_end &&\r\n(u8*)next_al_entry + le16_to_cpu(\r\nnext_al_entry->length) <= al_end &&\r\nsle64_to_cpu(next_al_entry->lowest_vcn) <=\r\nlowest_vcn &&\r\nnext_al_entry->type == al_entry->type &&\r\nnext_al_entry->name_length == al_name_len &&\r\nntfs_are_names_equal((ntfschar*)((u8*)\r\nnext_al_entry +\r\nnext_al_entry->name_offset),\r\nnext_al_entry->name_length,\r\nal_name, al_name_len, CASE_SENSITIVE,\r\nvol->upcase, vol->upcase_len))\r\ncontinue;\r\nif (MREF_LE(al_entry->mft_reference) == ni->mft_no) {\r\nif (MSEQNO_LE(al_entry->mft_reference) != ni->seq_no) {\r\nntfs_error(vol->sb, "Found stale mft "\r\n"reference in attribute list "\r\n"of base inode 0x%lx.%s",\r\nbase_ni->mft_no, es);\r\nerr = -EIO;\r\nbreak;\r\n}\r\n} else {\r\nif (ni != base_ni)\r\nunmap_extent_mft_record(ni);\r\nif (MREF_LE(al_entry->mft_reference) ==\r\nbase_ni->mft_no) {\r\nni = ctx->ntfs_ino = base_ni;\r\nctx->mrec = ctx->base_mrec;\r\n} else {\r\nctx->mrec = map_extent_mft_record(base_ni,\r\nle64_to_cpu(\r\nal_entry->mft_reference), &ni);\r\nif (IS_ERR(ctx->mrec)) {\r\nntfs_error(vol->sb, "Failed to map "\r\n"extent mft record "\r\n"0x%lx of base inode "\r\n"0x%lx.%s",\r\nMREF_LE(al_entry->\r\nmft_reference),\r\nbase_ni->mft_no, es);\r\nerr = PTR_ERR(ctx->mrec);\r\nif (err == -ENOENT)\r\nerr = -EIO;\r\nni = NULL;\r\nbreak;\r\n}\r\nctx->ntfs_ino = ni;\r\n}\r\nctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\r\nle16_to_cpu(ctx->mrec->attrs_offset));\r\n}\r\na = ctx->attr;\r\ndo_next_attr_loop:\r\nif ((u8*)a < (u8*)ctx->mrec || (u8*)a > (u8*)ctx->mrec +\r\nle32_to_cpu(ctx->mrec->bytes_allocated))\r\nbreak;\r\nif (a->type == AT_END)\r\nbreak;\r\nif (!a->length)\r\nbreak;\r\nif (al_entry->instance != a->instance)\r\ngoto do_next_attr;\r\nif (al_entry->type != a->type)\r\nbreak;\r\nif (!ntfs_are_names_equal((ntfschar*)((u8*)a +\r\nle16_to_cpu(a->name_offset)), a->name_length,\r\nal_name, al_name_len, CASE_SENSITIVE,\r\nvol->upcase, vol->upcase_len))\r\nbreak;\r\nctx->attr = a;\r\nif (!val || (!a->non_resident && le32_to_cpu(\r\na->data.resident.value_length) == val_len &&\r\n!memcmp((u8*)a +\r\nle16_to_cpu(a->data.resident.value_offset),\r\nval, val_len))) {\r\nntfs_debug("Done, found.");\r\nreturn 0;\r\n}\r\ndo_next_attr:\r\na = (ATTR_RECORD*)((u8*)a + le32_to_cpu(a->length));\r\ngoto do_next_attr_loop;\r\n}\r\nif (!err) {\r\nntfs_error(vol->sb, "Base inode 0x%lx contains corrupt "\r\n"attribute list attribute.%s", base_ni->mft_no,\r\nes);\r\nerr = -EIO;\r\n}\r\nif (ni != base_ni) {\r\nif (ni)\r\nunmap_extent_mft_record(ni);\r\nctx->ntfs_ino = base_ni;\r\nctx->mrec = ctx->base_mrec;\r\nctx->attr = ctx->base_attr;\r\n}\r\nif (err != -ENOMEM)\r\nNVolSetErrors(vol);\r\nreturn err;\r\nnot_found:\r\nif (type == AT_END) {\r\nntfs_attr_reinit_search_ctx(ctx);\r\nreturn ntfs_attr_find(AT_END, name, name_len, ic, val, val_len,\r\nctx);\r\n}\r\nif (ni != base_ni)\r\nunmap_extent_mft_record(ni);\r\nctx->mrec = ctx->base_mrec;\r\nctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\r\nle16_to_cpu(ctx->mrec->attrs_offset));\r\nctx->is_first = true;\r\nctx->ntfs_ino = base_ni;\r\nctx->base_ntfs_ino = NULL;\r\nctx->base_mrec = NULL;\r\nctx->base_attr = NULL;\r\ndo {\r\nerr = ntfs_attr_find(type, name, name_len, ic, val, val_len,\r\nctx);\r\n} while (!err);\r\nntfs_debug("Done, not found.");\r\nreturn err;\r\n}\r\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\r\nconst u32 name_len, const IGNORE_CASE_BOOL ic,\r\nconst VCN lowest_vcn, const u8 *val, const u32 val_len,\r\nntfs_attr_search_ctx *ctx)\r\n{\r\nntfs_inode *base_ni;\r\nntfs_debug("Entering.");\r\nBUG_ON(IS_ERR(ctx->mrec));\r\nif (ctx->base_ntfs_ino)\r\nbase_ni = ctx->base_ntfs_ino;\r\nelse\r\nbase_ni = ctx->ntfs_ino;\r\nBUG_ON(!base_ni);\r\nif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\r\nreturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\r\nctx);\r\nreturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\r\nval, val_len, ctx);\r\n}\r\nstatic inline void ntfs_attr_init_search_ctx(ntfs_attr_search_ctx *ctx,\r\nntfs_inode *ni, MFT_RECORD *mrec)\r\n{\r\n*ctx = (ntfs_attr_search_ctx) {\r\n.mrec = mrec,\r\n.attr = (ATTR_RECORD*)((u8*)mrec +\r\nle16_to_cpu(mrec->attrs_offset)),\r\n.is_first = true,\r\n.ntfs_ino = ni,\r\n};\r\n}\r\nvoid ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\r\n{\r\nif (likely(!ctx->base_ntfs_ino)) {\r\nctx->is_first = true;\r\nctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\r\nle16_to_cpu(ctx->mrec->attrs_offset));\r\nctx->al_entry = NULL;\r\nreturn;\r\n}\r\nif (ctx->ntfs_ino != ctx->base_ntfs_ino)\r\nunmap_extent_mft_record(ctx->ntfs_ino);\r\nntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\r\nreturn;\r\n}\r\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\r\n{\r\nntfs_attr_search_ctx *ctx;\r\nctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\r\nif (ctx)\r\nntfs_attr_init_search_ctx(ctx, ni, mrec);\r\nreturn ctx;\r\n}\r\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\r\n{\r\nif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\r\nunmap_extent_mft_record(ctx->ntfs_ino);\r\nkmem_cache_free(ntfs_attr_ctx_cache, ctx);\r\nreturn;\r\n}\r\nstatic ATTR_DEF *ntfs_attr_find_in_attrdef(const ntfs_volume *vol,\r\nconst ATTR_TYPE type)\r\n{\r\nATTR_DEF *ad;\r\nBUG_ON(!vol->attrdef);\r\nBUG_ON(!type);\r\nfor (ad = vol->attrdef; (u8*)ad - (u8*)vol->attrdef <\r\nvol->attrdef_size && ad->type; ++ad) {\r\nif (likely(le32_to_cpu(ad->type) < le32_to_cpu(type)))\r\ncontinue;\r\nif (likely(ad->type == type))\r\nreturn ad;\r\nbreak;\r\n}\r\nntfs_debug("Attribute type 0x%x not found in $AttrDef.",\r\nle32_to_cpu(type));\r\nreturn NULL;\r\n}\r\nint ntfs_attr_size_bounds_check(const ntfs_volume *vol, const ATTR_TYPE type,\r\nconst s64 size)\r\n{\r\nATTR_DEF *ad;\r\nBUG_ON(size < 0);\r\nif (unlikely(type == AT_ATTRIBUTE_LIST && size > 256 * 1024))\r\nreturn -ERANGE;\r\nad = ntfs_attr_find_in_attrdef(vol, type);\r\nif (unlikely(!ad))\r\nreturn -ENOENT;\r\nif (((sle64_to_cpu(ad->min_size) > 0) &&\r\nsize < sle64_to_cpu(ad->min_size)) ||\r\n((sle64_to_cpu(ad->max_size) > 0) && size >\r\nsle64_to_cpu(ad->max_size)))\r\nreturn -ERANGE;\r\nreturn 0;\r\n}\r\nint ntfs_attr_can_be_non_resident(const ntfs_volume *vol, const ATTR_TYPE type)\r\n{\r\nATTR_DEF *ad;\r\nad = ntfs_attr_find_in_attrdef(vol, type);\r\nif (unlikely(!ad))\r\nreturn -ENOENT;\r\nif (ad->flags & ATTR_DEF_RESIDENT)\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nint ntfs_attr_can_be_resident(const ntfs_volume *vol, const ATTR_TYPE type)\r\n{\r\nif (type == AT_INDEX_ALLOCATION)\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nint ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)\r\n{\r\nntfs_debug("Entering for new_size %u.", new_size);\r\nif (new_size & 7)\r\nnew_size = (new_size + 7) & ~7;\r\nif (new_size != le32_to_cpu(a->length)) {\r\nu32 new_muse = le32_to_cpu(m->bytes_in_use) -\r\nle32_to_cpu(a->length) + new_size;\r\nif (new_muse > le32_to_cpu(m->bytes_allocated))\r\nreturn -ENOSPC;\r\nmemmove((u8*)a + new_size, (u8*)a + le32_to_cpu(a->length),\r\nle32_to_cpu(m->bytes_in_use) - ((u8*)a -\r\n(u8*)m) - le32_to_cpu(a->length));\r\nm->bytes_in_use = cpu_to_le32(new_muse);\r\nif (new_size >= offsetof(ATTR_REC, length) + sizeof(a->length))\r\na->length = cpu_to_le32(new_size);\r\n}\r\nreturn 0;\r\n}\r\nint ntfs_resident_attr_value_resize(MFT_RECORD *m, ATTR_RECORD *a,\r\nconst u32 new_size)\r\n{\r\nu32 old_size;\r\nif (ntfs_attr_record_resize(m, a,\r\nle16_to_cpu(a->data.resident.value_offset) + new_size))\r\nreturn -ENOSPC;\r\nold_size = le32_to_cpu(a->data.resident.value_length);\r\nif (new_size > old_size)\r\nmemset((u8*)a + le16_to_cpu(a->data.resident.value_offset) +\r\nold_size, 0, new_size - old_size);\r\na->data.resident.value_length = cpu_to_le32(new_size);\r\nreturn 0;\r\n}\r\nint ntfs_attr_make_non_resident(ntfs_inode *ni, const u32 data_size)\r\n{\r\ns64 new_size;\r\nstruct inode *vi = VFS_I(ni);\r\nntfs_volume *vol = ni->vol;\r\nntfs_inode *base_ni;\r\nMFT_RECORD *m;\r\nATTR_RECORD *a;\r\nntfs_attr_search_ctx *ctx;\r\nstruct page *page;\r\nrunlist_element *rl;\r\nu8 *kaddr;\r\nunsigned long flags;\r\nint mp_size, mp_ofs, name_ofs, arec_size, err, err2;\r\nu32 attr_size;\r\nu8 old_res_attr_flags;\r\nerr = ntfs_attr_can_be_non_resident(vol, ni->type);\r\nif (unlikely(err)) {\r\nif (err == -EPERM)\r\nntfs_debug("Attribute is not allowed to be "\r\n"non-resident.");\r\nelse\r\nntfs_debug("Attribute not defined on the NTFS "\r\n"volume!");\r\nreturn err;\r\n}\r\nBUG_ON(NInoCompressed(ni));\r\nBUG_ON(NInoEncrypted(ni));\r\nnew_size = (data_size + vol->cluster_size - 1) &\r\n~(vol->cluster_size - 1);\r\nif (new_size > 0) {\r\npage = find_or_create_page(vi->i_mapping, 0,\r\nmapping_gfp_mask(vi->i_mapping));\r\nif (unlikely(!page))\r\nreturn -ENOMEM;\r\nrl = ntfs_cluster_alloc(vol, 0, new_size >>\r\nvol->cluster_size_bits, -1, DATA_ZONE, true);\r\nif (IS_ERR(rl)) {\r\nerr = PTR_ERR(rl);\r\nntfs_debug("Failed to allocate cluster%s, error code "\r\n"%i.", (new_size >>\r\nvol->cluster_size_bits) > 1 ? "s" : "",\r\nerr);\r\ngoto page_err_out;\r\n}\r\n} else {\r\nrl = NULL;\r\npage = NULL;\r\n}\r\nmp_size = ntfs_get_size_for_mapping_pairs(vol, rl, 0, -1);\r\nif (unlikely(mp_size < 0)) {\r\nerr = mp_size;\r\nntfs_debug("Failed to get size for mapping pairs array, error "\r\n"code %i.", err);\r\ngoto rl_err_out;\r\n}\r\ndown_write(&ni->runlist.lock);\r\nif (!NInoAttr(ni))\r\nbase_ni = ni;\r\nelse\r\nbase_ni = ni->ext.base_ntfs_ino;\r\nm = map_mft_record(base_ni);\r\nif (IS_ERR(m)) {\r\nerr = PTR_ERR(m);\r\nm = NULL;\r\nctx = NULL;\r\ngoto err_out;\r\n}\r\nctx = ntfs_attr_get_search_ctx(base_ni, m);\r\nif (unlikely(!ctx)) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nerr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\r\nCASE_SENSITIVE, 0, NULL, 0, ctx);\r\nif (unlikely(err)) {\r\nif (err == -ENOENT)\r\nerr = -EIO;\r\ngoto err_out;\r\n}\r\nm = ctx->mrec;\r\na = ctx->attr;\r\nBUG_ON(NInoNonResident(ni));\r\nBUG_ON(a->non_resident);\r\nif (NInoSparse(ni) || NInoCompressed(ni))\r\nname_ofs = (offsetof(ATTR_REC,\r\ndata.non_resident.compressed_size) +\r\nsizeof(a->data.non_resident.compressed_size) +\r\n7) & ~7;\r\nelse\r\nname_ofs = (offsetof(ATTR_REC,\r\ndata.non_resident.compressed_size) + 7) & ~7;\r\nmp_ofs = (name_ofs + a->name_length * sizeof(ntfschar) + 7) & ~7;\r\narec_size = (mp_ofs + mp_size + 7) & ~7;\r\nattr_size = le32_to_cpu(a->data.resident.value_length);\r\nBUG_ON(attr_size != data_size);\r\nif (page && !PageUptodate(page)) {\r\nkaddr = kmap_atomic(page);\r\nmemcpy(kaddr, (u8*)a +\r\nle16_to_cpu(a->data.resident.value_offset),\r\nattr_size);\r\nmemset(kaddr + attr_size, 0, PAGE_CACHE_SIZE - attr_size);\r\nkunmap_atomic(kaddr);\r\nflush_dcache_page(page);\r\nSetPageUptodate(page);\r\n}\r\nold_res_attr_flags = a->data.resident.flags;\r\nerr = ntfs_attr_record_resize(m, a, arec_size);\r\nif (unlikely(err))\r\ngoto err_out;\r\na->non_resident = 1;\r\nif (a->name_length)\r\nmemmove((u8*)a + name_ofs, (u8*)a + le16_to_cpu(a->name_offset),\r\na->name_length * sizeof(ntfschar));\r\na->name_offset = cpu_to_le16(name_ofs);\r\na->data.non_resident.lowest_vcn = 0;\r\na->data.non_resident.highest_vcn = cpu_to_sle64((new_size - 1) >>\r\nvol->cluster_size_bits);\r\na->data.non_resident.mapping_pairs_offset = cpu_to_le16(mp_ofs);\r\nmemset(&a->data.non_resident.reserved, 0,\r\nsizeof(a->data.non_resident.reserved));\r\na->data.non_resident.allocated_size = cpu_to_sle64(new_size);\r\na->data.non_resident.data_size =\r\na->data.non_resident.initialized_size =\r\ncpu_to_sle64(attr_size);\r\nif (NInoSparse(ni) || NInoCompressed(ni)) {\r\na->data.non_resident.compression_unit = 0;\r\nif (NInoCompressed(ni) || vol->major_ver < 3)\r\na->data.non_resident.compression_unit = 4;\r\na->data.non_resident.compressed_size =\r\na->data.non_resident.allocated_size;\r\n} else\r\na->data.non_resident.compression_unit = 0;\r\nerr = ntfs_mapping_pairs_build(vol, (u8*)a + mp_ofs,\r\narec_size - mp_ofs, rl, 0, -1, NULL);\r\nif (unlikely(err)) {\r\nntfs_debug("Failed to build mapping pairs, error code %i.",\r\nerr);\r\ngoto undo_err_out;\r\n}\r\nni->runlist.rl = rl;\r\nwrite_lock_irqsave(&ni->size_lock, flags);\r\nni->allocated_size = new_size;\r\nif (NInoSparse(ni) || NInoCompressed(ni)) {\r\nni->itype.compressed.size = ni->allocated_size;\r\nif (a->data.non_resident.compression_unit) {\r\nni->itype.compressed.block_size = 1U << (a->data.\r\nnon_resident.compression_unit +\r\nvol->cluster_size_bits);\r\nni->itype.compressed.block_size_bits =\r\nffs(ni->itype.compressed.block_size) -\r\n1;\r\nni->itype.compressed.block_clusters = 1U <<\r\na->data.non_resident.compression_unit;\r\n} else {\r\nni->itype.compressed.block_size = 0;\r\nni->itype.compressed.block_size_bits = 0;\r\nni->itype.compressed.block_clusters = 0;\r\n}\r\nvi->i_blocks = ni->itype.compressed.size >> 9;\r\n} else\r\nvi->i_blocks = ni->allocated_size >> 9;\r\nwrite_unlock_irqrestore(&ni->size_lock, flags);\r\nNInoSetNonResident(ni);\r\nflush_dcache_mft_record_page(ctx->ntfs_ino);\r\nmark_mft_record_dirty(ctx->ntfs_ino);\r\nntfs_attr_put_search_ctx(ctx);\r\nunmap_mft_record(base_ni);\r\nup_write(&ni->runlist.lock);\r\nif (page) {\r\nset_page_dirty(page);\r\nunlock_page(page);\r\nmark_page_accessed(page);\r\npage_cache_release(page);\r\n}\r\nntfs_debug("Done.");\r\nreturn 0;\r\nundo_err_out:\r\na->non_resident = 0;\r\nname_ofs = (offsetof(ATTR_RECORD, data.resident.reserved) +\r\nsizeof(a->data.resident.reserved) + 7) & ~7;\r\nif (a->name_length)\r\nmemmove((u8*)a + name_ofs, (u8*)a + le16_to_cpu(a->name_offset),\r\na->name_length * sizeof(ntfschar));\r\nmp_ofs = (name_ofs + a->name_length * sizeof(ntfschar) + 7) & ~7;\r\na->name_offset = cpu_to_le16(name_ofs);\r\narec_size = (mp_ofs + attr_size + 7) & ~7;\r\nerr2 = ntfs_attr_record_resize(m, a, arec_size);\r\nif (unlikely(err2)) {\r\narec_size = le32_to_cpu(a->length);\r\nif ((mp_ofs + attr_size) > arec_size) {\r\nerr2 = attr_size;\r\nattr_size = arec_size - mp_ofs;\r\nntfs_error(vol->sb, "Failed to undo partial resident "\r\n"to non-resident attribute "\r\n"conversion. Truncating inode 0x%lx, "\r\n"attribute type 0x%x from %i bytes to "\r\n"%i bytes to maintain metadata "\r\n"consistency. THIS MEANS YOU ARE "\r\n"LOSING %i BYTES DATA FROM THIS %s.",\r\nvi->i_ino,\r\n(unsigned)le32_to_cpu(ni->type),\r\nerr2, attr_size, err2 - attr_size,\r\n((ni->type == AT_DATA) &&\r\n!ni->name_len) ? "FILE": "ATTRIBUTE");\r\nwrite_lock_irqsave(&ni->size_lock, flags);\r\nni->initialized_size = attr_size;\r\ni_size_write(vi, attr_size);\r\nwrite_unlock_irqrestore(&ni->size_lock, flags);\r\n}\r\n}\r\na->data.resident.value_length = cpu_to_le32(attr_size);\r\na->data.resident.value_offset = cpu_to_le16(mp_ofs);\r\na->data.resident.flags = old_res_attr_flags;\r\nmemset(&a->data.resident.reserved, 0,\r\nsizeof(a->data.resident.reserved));\r\nif (page) {\r\nkaddr = kmap_atomic(page);\r\nmemcpy((u8*)a + mp_ofs, kaddr, attr_size);\r\nkunmap_atomic(kaddr);\r\n}\r\nwrite_lock_irqsave(&ni->size_lock, flags);\r\nni->allocated_size = arec_size - mp_ofs;\r\nwrite_unlock_irqrestore(&ni->size_lock, flags);\r\nflush_dcache_mft_record_page(ctx->ntfs_ino);\r\nmark_mft_record_dirty(ctx->ntfs_ino);\r\nerr_out:\r\nif (ctx)\r\nntfs_attr_put_search_ctx(ctx);\r\nif (m)\r\nunmap_mft_record(base_ni);\r\nni->runlist.rl = NULL;\r\nup_write(&ni->runlist.lock);\r\nrl_err_out:\r\nif (rl) {\r\nif (ntfs_cluster_free_from_rl(vol, rl) < 0) {\r\nntfs_error(vol->sb, "Failed to release allocated "\r\n"cluster(s) in error code path. Run "\r\n"chkdsk to recover the lost "\r\n"cluster(s).");\r\nNVolSetErrors(vol);\r\n}\r\nntfs_free(rl);\r\npage_err_out:\r\nunlock_page(page);\r\npage_cache_release(page);\r\n}\r\nif (err == -EINVAL)\r\nerr = -EIO;\r\nreturn err;\r\n}\r\ns64 ntfs_attr_extend_allocation(ntfs_inode *ni, s64 new_alloc_size,\r\nconst s64 new_data_size, const s64 data_start)\r\n{\r\nVCN vcn;\r\ns64 ll, allocated_size, start = data_start;\r\nstruct inode *vi = VFS_I(ni);\r\nntfs_volume *vol = ni->vol;\r\nntfs_inode *base_ni;\r\nMFT_RECORD *m;\r\nATTR_RECORD *a;\r\nntfs_attr_search_ctx *ctx;\r\nrunlist_element *rl, *rl2;\r\nunsigned long flags;\r\nint err, mp_size;\r\nu32 attr_len = 0;\r\nbool mp_rebuilt;\r\n#ifdef DEBUG\r\nread_lock_irqsave(&ni->size_lock, flags);\r\nallocated_size = ni->allocated_size;\r\nread_unlock_irqrestore(&ni->size_lock, flags);\r\nntfs_debug("Entering for i_ino 0x%lx, attribute type 0x%x, "\r\n"old_allocated_size 0x%llx, "\r\n"new_allocated_size 0x%llx, new_data_size 0x%llx, "\r\n"data_start 0x%llx.", vi->i_ino,\r\n(unsigned)le32_to_cpu(ni->type),\r\n(unsigned long long)allocated_size,\r\n(unsigned long long)new_alloc_size,\r\n(unsigned long long)new_data_size,\r\n(unsigned long long)start);\r\n#endif\r\nretry_extend:\r\nif (NInoNonResident(ni)) {\r\nif (start > 0)\r\nstart &= ~(s64)vol->cluster_size_mask;\r\nnew_alloc_size = (new_alloc_size + vol->cluster_size - 1) &\r\n~(s64)vol->cluster_size_mask;\r\n}\r\nBUG_ON(new_data_size >= 0 && new_data_size > new_alloc_size);\r\nerr = ntfs_attr_size_bounds_check(vol, ni->type, new_alloc_size);\r\nif (unlikely(err)) {\r\nread_lock_irqsave(&ni->size_lock, flags);\r\nallocated_size = ni->allocated_size;\r\nread_unlock_irqrestore(&ni->size_lock, flags);\r\nif (start < 0 || start >= allocated_size) {\r\nif (err == -ERANGE) {\r\nntfs_error(vol->sb, "Cannot extend allocation "\r\n"of inode 0x%lx, attribute "\r\n"type 0x%x, because the new "\r\n"allocation would exceed the "\r\n"maximum allowed size for "\r\n"this attribute type.",\r\nvi->i_ino, (unsigned)\r\nle32_to_cpu(ni->type));\r\n} else {\r\nntfs_error(vol->sb, "Cannot extend allocation "\r\n"of inode 0x%lx, attribute "\r\n"type 0x%x, because this "\r\n"attribute type is not "\r\n"defined on the NTFS volume. "\r\n"Possible corruption! You "\r\n"should run chkdsk!",\r\nvi->i_ino, (unsigned)\r\nle32_to_cpu(ni->type));\r\n}\r\n}\r\nif (err == -ERANGE)\r\nerr = -EFBIG;\r\nelse\r\nerr = -EIO;\r\nreturn err;\r\n}\r\nif (!NInoAttr(ni))\r\nbase_ni = ni;\r\nelse\r\nbase_ni = ni->ext.base_ntfs_ino;\r\ndown_write(&ni->runlist.lock);\r\nm = map_mft_record(base_ni);\r\nif (IS_ERR(m)) {\r\nerr = PTR_ERR(m);\r\nm = NULL;\r\nctx = NULL;\r\ngoto err_out;\r\n}\r\nctx = ntfs_attr_get_search_ctx(base_ni, m);\r\nif (unlikely(!ctx)) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nread_lock_irqsave(&ni->size_lock, flags);\r\nallocated_size = ni->allocated_size;\r\nread_unlock_irqrestore(&ni->size_lock, flags);\r\nvcn = NInoNonResident(ni) ? allocated_size >> vol->cluster_size_bits :\r\n0;\r\nif (unlikely(new_alloc_size <= allocated_size)) {\r\nntfs_debug("Allocated size already exceeds requested size.");\r\nnew_alloc_size = allocated_size;\r\nif (new_data_size < 0)\r\ngoto done;\r\nvcn = 0;\r\n}\r\nerr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\r\nCASE_SENSITIVE, vcn, NULL, 0, ctx);\r\nif (unlikely(err)) {\r\nif (err == -ENOENT)\r\nerr = -EIO;\r\ngoto err_out;\r\n}\r\nm = ctx->mrec;\r\na = ctx->attr;\r\nif (a->non_resident)\r\ngoto do_non_resident_extend;\r\nBUG_ON(NInoNonResident(ni));\r\nattr_len = le32_to_cpu(a->data.resident.value_length);\r\nif (new_alloc_size < vol->mft_record_size &&\r\n!ntfs_attr_record_resize(m, a,\r\nle16_to_cpu(a->data.resident.value_offset) +\r\nnew_alloc_size)) {\r\nwrite_lock_irqsave(&ni->size_lock, flags);\r\nni->allocated_size = le32_to_cpu(a->length) -\r\nle16_to_cpu(a->data.resident.value_offset);\r\nwrite_unlock_irqrestore(&ni->size_lock, flags);\r\nif (new_data_size >= 0) {\r\nBUG_ON(new_data_size < attr_len);\r\na->data.resident.value_length =\r\ncpu_to_le32((u32)new_data_size);\r\n}\r\ngoto flush_done;\r\n}\r\nntfs_attr_put_search_ctx(ctx);\r\nunmap_mft_record(base_ni);\r\nup_write(&ni->runlist.lock);\r\nerr = ntfs_attr_make_non_resident(ni, attr_len);\r\nif (likely(!err))\r\ngoto retry_extend;\r\nif (unlikely(err != -EPERM && err != -ENOSPC)) {\r\nread_lock_irqsave(&ni->size_lock, flags);\r\nallocated_size = ni->allocated_size;\r\nread_unlock_irqrestore(&ni->size_lock, flags);\r\nif (start < 0 || start >= allocated_size)\r\nntfs_error(vol->sb, "Cannot extend allocation of "\r\n"inode 0x%lx, attribute type 0x%x, "\r\n"because the conversion from resident "\r\n"to non-resident attribute failed "\r\n"with error code %i.", vi->i_ino,\r\n(unsigned)le32_to_cpu(ni->type), err);\r\nif (err != -ENOMEM)\r\nerr = -EIO;\r\ngoto conv_err_out;\r\n}\r\nread_lock_irqsave(&ni->size_lock, flags);\r\nallocated_size = ni->allocated_size;\r\nread_unlock_irqrestore(&ni->size_lock, flags);\r\nif (start < 0 || start >= allocated_size) {\r\nif (err == -ENOSPC)\r\nntfs_error(vol->sb, "Not enough space in the mft "\r\n"record/on disk for the non-resident "\r\n"attribute value. This case is not "\r\n"implemented yet.");\r\nelse\r\nntfs_error(vol->sb, "This attribute type may not be "\r\n"non-resident. This case is not "\r\n"implemented yet.");\r\n}\r\nerr = -EOPNOTSUPP;\r\ngoto conv_err_out;\r\n#if 0\r\nif (!err)\r\ngoto do_resident_extend;\r\nif (ni->type == AT_ATTRIBUTE_LIST ||\r\nni->type == AT_STANDARD_INFORMATION) {\r\nerr = -EOPNOTSUPP;\r\nif (!err)\r\ngoto do_resident_extend;\r\ngoto err_out;\r\n}\r\nerr = -EOPNOTSUPP;\r\nif (!err)\r\ngoto do_resident_extend;\r\ngoto err_out;\r\n#endif\r\ndo_non_resident_extend:\r\nBUG_ON(!NInoNonResident(ni));\r\nif (new_alloc_size == allocated_size) {\r\nBUG_ON(vcn);\r\ngoto alloc_done;\r\n}\r\nif ((start >= 0 && start <= allocated_size) || ni->type != AT_DATA ||\r\n!NVolSparseEnabled(vol) || NInoSparseDisabled(ni))\r\ngoto skip_sparse;\r\nntfs_debug("Inserting holes is not-implemented yet. Falling back to "\r\n"allocating real clusters instead.");\r\nskip_sparse:\r\nrl = ni->runlist.rl;\r\nif (likely(rl)) {\r\nwhile (rl->length)\r\nrl++;\r\n}\r\nif (unlikely(!rl || rl->lcn == LCN_RL_NOT_MAPPED ||\r\n(rl->lcn == LCN_ENOENT && rl > ni->runlist.rl &&\r\n(rl-1)->lcn == LCN_RL_NOT_MAPPED))) {\r\nif (!rl && !allocated_size)\r\ngoto first_alloc;\r\nrl = ntfs_mapping_pairs_decompress(vol, a, ni->runlist.rl);\r\nif (IS_ERR(rl)) {\r\nerr = PTR_ERR(rl);\r\nif (start < 0 || start >= allocated_size)\r\nntfs_error(vol->sb, "Cannot extend allocation "\r\n"of inode 0x%lx, attribute "\r\n"type 0x%x, because the "\r\n"mapping of a runlist "\r\n"fragment failed with error "\r\n"code %i.", vi->i_ino,\r\n(unsigned)le32_to_cpu(ni->type),\r\nerr);\r\nif (err != -ENOMEM)\r\nerr = -EIO;\r\ngoto err_out;\r\n}\r\nni->runlist.rl = rl;\r\nwhile (rl->length)\r\nrl++;\r\n}\r\nwhile (rl->lcn < 0 && rl > ni->runlist.rl)\r\nrl--;\r\nfirst_alloc:\r\nrl2 = ntfs_cluster_alloc(vol, allocated_size >> vol->cluster_size_bits,\r\n(new_alloc_size - allocated_size) >>\r\nvol->cluster_size_bits, (rl && (rl->lcn >= 0)) ?\r\nrl->lcn + rl->length : -1, DATA_ZONE, true);\r\nif (IS_ERR(rl2)) {\r\nerr = PTR_ERR(rl2);\r\nif (start < 0 || start >= allocated_size)\r\nntfs_error(vol->sb, "Cannot extend allocation of "\r\n"inode 0x%lx, attribute type 0x%x, "\r\n"because the allocation of clusters "\r\n"failed with error code %i.", vi->i_ino,\r\n(unsigned)le32_to_cpu(ni->type), err);\r\nif (err != -ENOMEM && err != -ENOSPC)\r\nerr = -EIO;\r\ngoto err_out;\r\n}\r\nrl = ntfs_runlists_merge(ni->runlist.rl, rl2);\r\nif (IS_ERR(rl)) {\r\nerr = PTR_ERR(rl);\r\nif (start < 0 || start >= allocated_size)\r\nntfs_error(vol->sb, "Cannot extend allocation of "\r\n"inode 0x%lx, attribute type 0x%x, "\r\n"because the runlist merge failed "\r\n"with error code %i.", vi->i_ino,\r\n(unsigned)le32_to_cpu(ni->type), err);\r\nif (err != -ENOMEM)\r\nerr = -EIO;\r\nif (ntfs_cluster_free_from_rl(vol, rl2)) {\r\nntfs_error(vol->sb, "Failed to release allocated "\r\n"cluster(s) in error code path. Run "\r\n"chkdsk to recover the lost "\r\n"cluster(s).");\r\nNVolSetErrors(vol);\r\n}\r\nntfs_free(rl2);\r\ngoto err_out;\r\n}\r\nni->runlist.rl = rl;\r\nntfs_debug("Allocated 0x%llx clusters.", (long long)(new_alloc_size -\r\nallocated_size) >> vol->cluster_size_bits);\r\nll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\r\nrl2 = ntfs_rl_find_vcn_nolock(rl, ll);\r\nBUG_ON(!rl2);\r\nBUG_ON(!rl2->length);\r\nBUG_ON(rl2->lcn < LCN_HOLE);\r\nmp_rebuilt = false;\r\nmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\r\nif (unlikely(mp_size <= 0)) {\r\nerr = mp_size;\r\nif (start < 0 || start >= allocated_size)\r\nntfs_error(vol->sb, "Cannot extend allocation of "\r\n"inode 0x%lx, attribute type 0x%x, "\r\n"because determining the size for the "\r\n"mapping pairs failed with error code "\r\n"%i.", vi->i_ino,\r\n(unsigned)le32_to_cpu(ni->type), err);\r\nerr = -EIO;\r\ngoto undo_alloc;\r\n}\r\nattr_len = le32_to_cpu(a->length);\r\nerr = ntfs_attr_record_resize(m, a, mp_size +\r\nle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\r\nif (unlikely(err)) {\r\nBUG_ON(err != -ENOSPC);\r\nif (start < 0 || start >= allocated_size)\r\nntfs_error(vol->sb, "Not enough space in the mft "\r\n"record for the extended attribute "\r\n"record. This case is not "\r\n"implemented yet.");\r\nerr = -EOPNOTSUPP;\r\ngoto undo_alloc;\r\n}\r\nmp_rebuilt = true;\r\nerr = ntfs_mapping_pairs_build(vol, (u8*)a +\r\nle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\r\nmp_size, rl2, ll, -1, NULL);\r\nif (unlikely(err)) {\r\nif (start < 0 || start >= allocated_size)\r\nntfs_error(vol->sb, "Cannot extend allocation of "\r\n"inode 0x%lx, attribute type 0x%x, "\r\n"because building the mapping pairs "\r\n"failed with error code %i.", vi->i_ino,\r\n(unsigned)le32_to_cpu(ni->type), err);\r\nerr = -EIO;\r\ngoto undo_alloc;\r\n}\r\na->data.non_resident.highest_vcn = cpu_to_sle64((new_alloc_size >>\r\nvol->cluster_size_bits) - 1);\r\nif (a->data.non_resident.lowest_vcn) {\r\nflush_dcache_mft_record_page(ctx->ntfs_ino);\r\nmark_mft_record_dirty(ctx->ntfs_ino);\r\nntfs_attr_reinit_search_ctx(ctx);\r\nerr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\r\nCASE_SENSITIVE, 0, NULL, 0, ctx);\r\nif (unlikely(err))\r\ngoto restore_undo_alloc;\r\na = ctx->attr;\r\n}\r\nwrite_lock_irqsave(&ni->size_lock, flags);\r\nni->allocated_size = new_alloc_size;\r\na->data.non_resident.allocated_size = cpu_to_sle64(new_alloc_size);\r\nif (NInoSparse(ni) || NInoCompressed(ni)) {\r\nni->itype.compressed.size += new_alloc_size - allocated_size;\r\na->data.non_resident.compressed_size =\r\ncpu_to_sle64(ni->itype.compressed.size);\r\nvi->i_blocks = ni->itype.compressed.size >> 9;\r\n} else\r\nvi->i_blocks = new_alloc_size >> 9;\r\nwrite_unlock_irqrestore(&ni->size_lock, flags);\r\nalloc_done:\r\nif (new_data_size >= 0) {\r\nBUG_ON(new_data_size <\r\nsle64_to_cpu(a->data.non_resident.data_size));\r\na->data.non_resident.data_size = cpu_to_sle64(new_data_size);\r\n}\r\nflush_done:\r\nflush_dcache_mft_record_page(ctx->ntfs_ino);\r\nmark_mft_record_dirty(ctx->ntfs_ino);\r\ndone:\r\nntfs_attr_put_search_ctx(ctx);\r\nunmap_mft_record(base_ni);\r\nup_write(&ni->runlist.lock);\r\nntfs_debug("Done, new_allocated_size 0x%llx.",\r\n(unsigned long long)new_alloc_size);\r\nreturn new_alloc_size;\r\nrestore_undo_alloc:\r\nif (start < 0 || start >= allocated_size)\r\nntfs_error(vol->sb, "Cannot complete extension of allocation "\r\n"of inode 0x%lx, attribute type 0x%x, because "\r\n"lookup of first attribute extent failed with "\r\n"error code %i.", vi->i_ino,\r\n(unsigned)le32_to_cpu(ni->type), err);\r\nif (err == -ENOENT)\r\nerr = -EIO;\r\nntfs_attr_reinit_search_ctx(ctx);\r\nif (ntfs_attr_lookup(ni->type, ni->name, ni->name_len, CASE_SENSITIVE,\r\nallocated_size >> vol->cluster_size_bits, NULL, 0,\r\nctx)) {\r\nntfs_error(vol->sb, "Failed to find last attribute extent of "\r\n"attribute in error code path. Run chkdsk to "\r\n"recover.");\r\nwrite_lock_irqsave(&ni->size_lock, flags);\r\nni->allocated_size = new_alloc_size;\r\nif (NInoSparse(ni) || NInoCompressed(ni)) {\r\nni->itype.compressed.size += new_alloc_size -\r\nallocated_size;\r\nvi->i_blocks = ni->itype.compressed.size >> 9;\r\n} else\r\nvi->i_blocks = new_alloc_size >> 9;\r\nwrite_unlock_irqrestore(&ni->size_lock, flags);\r\nntfs_attr_put_search_ctx(ctx);\r\nunmap_mft_record(base_ni);\r\nup_write(&ni->runlist.lock);\r\nNVolSetErrors(vol);\r\nreturn err;\r\n}\r\nctx->attr->data.non_resident.highest_vcn = cpu_to_sle64(\r\n(allocated_size >> vol->cluster_size_bits) - 1);\r\nundo_alloc:\r\nll = allocated_size >> vol->cluster_size_bits;\r\nif (ntfs_cluster_free(ni, ll, -1, ctx) < 0) {\r\nntfs_error(vol->sb, "Failed to release allocated cluster(s) "\r\n"in error code path. Run chkdsk to recover "\r\n"the lost cluster(s).");\r\nNVolSetErrors(vol);\r\n}\r\nm = ctx->mrec;\r\na = ctx->attr;\r\nif (ntfs_rl_truncate_nolock(vol, &ni->runlist, ll) || IS_ERR(m)) {\r\nntfs_error(vol->sb, "Failed to %s in error code path. Run "\r\n"chkdsk to recover.", IS_ERR(m) ?\r\n"restore attribute search context" :\r\n"truncate attribute runlist");\r\nNVolSetErrors(vol);\r\n} else if (mp_rebuilt) {\r\nif (ntfs_attr_record_resize(m, a, attr_len)) {\r\nntfs_error(vol->sb, "Failed to restore attribute "\r\n"record in error code path. Run "\r\n"chkdsk to recover.");\r\nNVolSetErrors(vol);\r\n} else {\r\nif (ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\r\na->data.non_resident.\r\nmapping_pairs_offset), attr_len -\r\nle16_to_cpu(a->data.non_resident.\r\nmapping_pairs_offset), rl2, ll, -1,\r\nNULL)) {\r\nntfs_error(vol->sb, "Failed to restore "\r\n"mapping pairs array in error "\r\n"code path. Run chkdsk to "\r\n"recover.");\r\nNVolSetErrors(vol);\r\n}\r\nflush_dcache_mft_record_page(ctx->ntfs_ino);\r\nmark_mft_record_dirty(ctx->ntfs_ino);\r\n}\r\n}\r\nerr_out:\r\nif (ctx)\r\nntfs_attr_put_search_ctx(ctx);\r\nif (m)\r\nunmap_mft_record(base_ni);\r\nup_write(&ni->runlist.lock);\r\nconv_err_out:\r\nntfs_debug("Failed. Returning error code %i.", err);\r\nreturn err;\r\n}\r\nint ntfs_attr_set(ntfs_inode *ni, const s64 ofs, const s64 cnt, const u8 val)\r\n{\r\nntfs_volume *vol = ni->vol;\r\nstruct address_space *mapping;\r\nstruct page *page;\r\nu8 *kaddr;\r\npgoff_t idx, end;\r\nunsigned start_ofs, end_ofs, size;\r\nntfs_debug("Entering for ofs 0x%llx, cnt 0x%llx, val 0x%hx.",\r\n(long long)ofs, (long long)cnt, val);\r\nBUG_ON(ofs < 0);\r\nBUG_ON(cnt < 0);\r\nif (!cnt)\r\ngoto done;\r\nBUG_ON(NInoCompressed(ni));\r\nBUG_ON(NInoEncrypted(ni));\r\nmapping = VFS_I(ni)->i_mapping;\r\nidx = ofs >> PAGE_CACHE_SHIFT;\r\nstart_ofs = ofs & ~PAGE_CACHE_MASK;\r\nend = ofs + cnt;\r\nend_ofs = end & ~PAGE_CACHE_MASK;\r\nif (unlikely(end > i_size_read(VFS_I(ni)))) {\r\nntfs_error(vol->sb, "Request exceeds end of attribute.");\r\nreturn -ESPIPE;\r\n}\r\nend >>= PAGE_CACHE_SHIFT;\r\nif (start_ofs) {\r\npage = read_mapping_page(mapping, idx, NULL);\r\nif (IS_ERR(page)) {\r\nntfs_error(vol->sb, "Failed to read first partial "\r\n"page (error, index 0x%lx).", idx);\r\nreturn PTR_ERR(page);\r\n}\r\nsize = PAGE_CACHE_SIZE;\r\nif (idx == end)\r\nsize = end_ofs;\r\nkaddr = kmap_atomic(page);\r\nmemset(kaddr + start_ofs, val, size - start_ofs);\r\nflush_dcache_page(page);\r\nkunmap_atomic(kaddr);\r\nset_page_dirty(page);\r\npage_cache_release(page);\r\nbalance_dirty_pages_ratelimited(mapping);\r\ncond_resched();\r\nif (idx == end)\r\ngoto done;\r\nidx++;\r\n}\r\nfor (; idx < end; idx++) {\r\npage = grab_cache_page(mapping, idx);\r\nif (unlikely(!page)) {\r\nntfs_error(vol->sb, "Insufficient memory to grab "\r\n"page (index 0x%lx).", idx);\r\nreturn -ENOMEM;\r\n}\r\nkaddr = kmap_atomic(page);\r\nmemset(kaddr, val, PAGE_CACHE_SIZE);\r\nflush_dcache_page(page);\r\nkunmap_atomic(kaddr);\r\nif (page_has_buffers(page)) {\r\nstruct buffer_head *bh, *head;\r\nbh = head = page_buffers(page);\r\ndo {\r\nset_buffer_uptodate(bh);\r\n} while ((bh = bh->b_this_page) != head);\r\n}\r\nSetPageUptodate(page);\r\nset_page_dirty(page);\r\nunlock_page(page);\r\npage_cache_release(page);\r\nbalance_dirty_pages_ratelimited(mapping);\r\ncond_resched();\r\n}\r\nif (end_ofs) {\r\npage = read_mapping_page(mapping, idx, NULL);\r\nif (IS_ERR(page)) {\r\nntfs_error(vol->sb, "Failed to read last partial page "\r\n"(error, index 0x%lx).", idx);\r\nreturn PTR_ERR(page);\r\n}\r\nkaddr = kmap_atomic(page);\r\nmemset(kaddr, val, end_ofs);\r\nflush_dcache_page(page);\r\nkunmap_atomic(kaddr);\r\nset_page_dirty(page);\r\npage_cache_release(page);\r\nbalance_dirty_pages_ratelimited(mapping);\r\ncond_resched();\r\n}\r\ndone:\r\nntfs_debug("Done.");\r\nreturn 0;\r\n}
