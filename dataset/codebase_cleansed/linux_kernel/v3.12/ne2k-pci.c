static int ne2k_pci_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct net_device *dev;\r\nint i;\r\nunsigned char SA_prom[32];\r\nint start_page, stop_page;\r\nint irq, reg0, chip_idx = ent->driver_data;\r\nstatic unsigned int fnd_cnt;\r\nlong ioaddr;\r\nint flags = pci_clone_list[chip_idx].flags;\r\n#ifndef MODULE\r\nstatic int printed_version;\r\nif (!printed_version++)\r\nprintk(version);\r\n#endif\r\nfnd_cnt++;\r\ni = pci_enable_device (pdev);\r\nif (i)\r\nreturn i;\r\nioaddr = pci_resource_start (pdev, 0);\r\nirq = pdev->irq;\r\nif (!ioaddr || ((pci_resource_flags (pdev, 0) & IORESOURCE_IO) == 0)) {\r\ndev_err(&pdev->dev, "no I/O resource at PCI BAR #0\n");\r\nreturn -ENODEV;\r\n}\r\nif (request_region (ioaddr, NE_IO_EXTENT, DRV_NAME) == NULL) {\r\ndev_err(&pdev->dev, "I/O resource 0x%x @ 0x%lx busy\n",\r\nNE_IO_EXTENT, ioaddr);\r\nreturn -EBUSY;\r\n}\r\nreg0 = inb(ioaddr);\r\nif (reg0 == 0xFF)\r\ngoto err_out_free_res;\r\n{\r\nint regd;\r\noutb(E8390_NODMA+E8390_PAGE1+E8390_STOP, ioaddr + E8390_CMD);\r\nregd = inb(ioaddr + 0x0d);\r\noutb(0xff, ioaddr + 0x0d);\r\noutb(E8390_NODMA+E8390_PAGE0, ioaddr + E8390_CMD);\r\ninb(ioaddr + EN0_COUNTER0);\r\nif (inb(ioaddr + EN0_COUNTER0) != 0) {\r\noutb(reg0, ioaddr);\r\noutb(regd, ioaddr + 0x0d);\r\ngoto err_out_free_res;\r\n}\r\n}\r\ndev = alloc_ei_netdev();\r\nif (!dev) {\r\ndev_err(&pdev->dev, "cannot allocate ethernet device\n");\r\ngoto err_out_free_res;\r\n}\r\ndev->netdev_ops = &ne2k_netdev_ops;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\n{\r\nunsigned long reset_start_time = jiffies;\r\noutb(inb(ioaddr + NE_RESET), ioaddr + NE_RESET);\r\nwhile ((inb(ioaddr + EN0_ISR) & ENISR_RESET) == 0)\r\nif (jiffies - reset_start_time > 2) {\r\ndev_err(&pdev->dev,\r\n"Card failure (no reset ack).\n");\r\ngoto err_out_free_netdev;\r\n}\r\noutb(0xff, ioaddr + EN0_ISR);\r\n}\r\n{\r\nstruct {unsigned char value, offset; } program_seq[] = {\r\n{E8390_NODMA+E8390_PAGE0+E8390_STOP, E8390_CMD},\r\n{0x49, EN0_DCFG},\r\n{0x00, EN0_RCNTLO},\r\n{0x00, EN0_RCNTHI},\r\n{0x00, EN0_IMR},\r\n{0xFF, EN0_ISR},\r\n{E8390_RXOFF, EN0_RXCR},\r\n{E8390_TXOFF, EN0_TXCR},\r\n{32, EN0_RCNTLO},\r\n{0x00, EN0_RCNTHI},\r\n{0x00, EN0_RSARLO},\r\n{0x00, EN0_RSARHI},\r\n{E8390_RREAD+E8390_START, E8390_CMD},\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(program_seq); i++)\r\noutb(program_seq[i].value, ioaddr + program_seq[i].offset);\r\n}\r\nif (flags & ONLY_32BIT_IO) {\r\nfor (i = 0; i < 4 ; i++)\r\n((u32 *)SA_prom)[i] = le32_to_cpu(inl(ioaddr + NE_DATAPORT));\r\n} else\r\nfor(i = 0; i < 32 ; i++)\r\nSA_prom[i] = inb(ioaddr + NE_DATAPORT);\r\noutb(0x49, ioaddr + EN0_DCFG);\r\nstart_page = NESM_START_PG;\r\nstop_page = flags & STOP_PG_0x60 ? 0x60 : NESM_STOP_PG;\r\ndev->irq = irq;\r\ndev->base_addr = ioaddr;\r\npci_set_drvdata(pdev, dev);\r\nei_status.name = pci_clone_list[chip_idx].name;\r\nei_status.tx_start_page = start_page;\r\nei_status.stop_page = stop_page;\r\nei_status.word16 = 1;\r\nei_status.ne2k_flags = flags;\r\nif (fnd_cnt < MAX_UNITS) {\r\nif (full_duplex[fnd_cnt] > 0 || (options[fnd_cnt] & FORCE_FDX))\r\nei_status.ne2k_flags |= FORCE_FDX;\r\n}\r\nei_status.rx_start_page = start_page + TX_PAGES;\r\n#ifdef PACKETBUF_MEMSIZE\r\nei_status.stop_page = ei_status.tx_start_page + PACKETBUF_MEMSIZE;\r\n#endif\r\nei_status.reset_8390 = &ne2k_pci_reset_8390;\r\nei_status.block_input = &ne2k_pci_block_input;\r\nei_status.block_output = &ne2k_pci_block_output;\r\nei_status.get_8390_hdr = &ne2k_pci_get_8390_hdr;\r\nei_status.priv = (unsigned long) pdev;\r\ndev->ethtool_ops = &ne2k_pci_ethtool_ops;\r\nNS8390_init(dev, 0);\r\nmemcpy(dev->dev_addr, SA_prom, dev->addr_len);\r\ni = register_netdev(dev);\r\nif (i)\r\ngoto err_out_free_netdev;\r\nprintk("%s: %s found at %#lx, IRQ %d, %pM.\n",\r\ndev->name, pci_clone_list[chip_idx].name, ioaddr, dev->irq,\r\ndev->dev_addr);\r\nreturn 0;\r\nerr_out_free_netdev:\r\nfree_netdev (dev);\r\nerr_out_free_res:\r\nrelease_region (ioaddr, NE_IO_EXTENT);\r\npci_set_drvdata (pdev, NULL);\r\nreturn -ENODEV;\r\n}\r\nstatic inline int set_realtek_fdx(struct net_device *dev)\r\n{\r\nlong ioaddr = dev->base_addr;\r\noutb(0xC0 + E8390_NODMA, ioaddr + NE_CMD);\r\noutb(0xC0, ioaddr + 0x01);\r\noutb(0x40, ioaddr + 0x06);\r\noutb(0x00, ioaddr + 0x01);\r\noutb(E8390_PAGE0 + E8390_NODMA, ioaddr + NE_CMD);\r\nreturn 0;\r\n}\r\nstatic inline int set_holtek_fdx(struct net_device *dev)\r\n{\r\nlong ioaddr = dev->base_addr;\r\noutb(inb(ioaddr + 0x20) | 0x80, ioaddr + 0x20);\r\nreturn 0;\r\n}\r\nstatic int ne2k_pci_set_fdx(struct net_device *dev)\r\n{\r\nif (ei_status.ne2k_flags & REALTEK_FDX)\r\nreturn set_realtek_fdx(dev);\r\nelse if (ei_status.ne2k_flags & HOLTEK_FDX)\r\nreturn set_holtek_fdx(dev);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int ne2k_pci_open(struct net_device *dev)\r\n{\r\nint ret = request_irq(dev->irq, ei_interrupt, IRQF_SHARED, dev->name, dev);\r\nif (ret)\r\nreturn ret;\r\nif (ei_status.ne2k_flags & FORCE_FDX)\r\nne2k_pci_set_fdx(dev);\r\nei_open(dev);\r\nreturn 0;\r\n}\r\nstatic int ne2k_pci_close(struct net_device *dev)\r\n{\r\nei_close(dev);\r\nfree_irq(dev->irq, dev);\r\nreturn 0;\r\n}\r\nstatic void ne2k_pci_reset_8390(struct net_device *dev)\r\n{\r\nunsigned long reset_start_time = jiffies;\r\nif (debug > 1) printk("%s: Resetting the 8390 t=%ld...",\r\ndev->name, jiffies);\r\noutb(inb(NE_BASE + NE_RESET), NE_BASE + NE_RESET);\r\nei_status.txing = 0;\r\nei_status.dmaing = 0;\r\nwhile ((inb(NE_BASE+EN0_ISR) & ENISR_RESET) == 0)\r\nif (jiffies - reset_start_time > 2) {\r\nprintk("%s: ne2k_pci_reset_8390() did not complete.\n", dev->name);\r\nbreak;\r\n}\r\noutb(ENISR_RESET, NE_BASE + EN0_ISR);\r\n}\r\nstatic void ne2k_pci_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nlong nic_base = dev->base_addr;\r\nif (ei_status.dmaing) {\r\nprintk("%s: DMAing conflict in ne2k_pci_get_8390_hdr "\r\n"[DMAstat:%d][irqlock:%d].\n",\r\ndev->name, ei_status.dmaing, ei_status.irqlock);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\noutb(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base+ NE_CMD);\r\noutb(sizeof(struct e8390_pkt_hdr), nic_base + EN0_RCNTLO);\r\noutb(0, nic_base + EN0_RCNTHI);\r\noutb(0, nic_base + EN0_RSARLO);\r\noutb(ring_page, nic_base + EN0_RSARHI);\r\noutb(E8390_RREAD+E8390_START, nic_base + NE_CMD);\r\nif (ei_status.ne2k_flags & ONLY_16BIT_IO) {\r\ninsw(NE_BASE + NE_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr)>>1);\r\n} else {\r\n*(u32*)hdr = le32_to_cpu(inl(NE_BASE + NE_DATAPORT));\r\nle16_to_cpus(&hdr->count);\r\n}\r\noutb(ENISR_RDC, nic_base + EN0_ISR);\r\nei_status.dmaing &= ~0x01;\r\n}\r\nstatic void ne2k_pci_block_input(struct net_device *dev, int count,\r\nstruct sk_buff *skb, int ring_offset)\r\n{\r\nlong nic_base = dev->base_addr;\r\nchar *buf = skb->data;\r\nif (ei_status.dmaing) {\r\nprintk("%s: DMAing conflict in ne2k_pci_block_input "\r\n"[DMAstat:%d][irqlock:%d].\n",\r\ndev->name, ei_status.dmaing, ei_status.irqlock);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\nif (ei_status.ne2k_flags & ONLY_32BIT_IO)\r\ncount = (count + 3) & 0xFFFC;\r\noutb(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base+ NE_CMD);\r\noutb(count & 0xff, nic_base + EN0_RCNTLO);\r\noutb(count >> 8, nic_base + EN0_RCNTHI);\r\noutb(ring_offset & 0xff, nic_base + EN0_RSARLO);\r\noutb(ring_offset >> 8, nic_base + EN0_RSARHI);\r\noutb(E8390_RREAD+E8390_START, nic_base + NE_CMD);\r\nif (ei_status.ne2k_flags & ONLY_16BIT_IO) {\r\ninsw(NE_BASE + NE_DATAPORT,buf,count>>1);\r\nif (count & 0x01) {\r\nbuf[count-1] = inb(NE_BASE + NE_DATAPORT);\r\n}\r\n} else {\r\ninsl(NE_BASE + NE_DATAPORT, buf, count>>2);\r\nif (count & 3) {\r\nbuf += count & ~3;\r\nif (count & 2) {\r\n__le16 *b = (__le16 *)buf;\r\n*b++ = cpu_to_le16(inw(NE_BASE + NE_DATAPORT));\r\nbuf = (char *)b;\r\n}\r\nif (count & 1)\r\n*buf = inb(NE_BASE + NE_DATAPORT);\r\n}\r\n}\r\noutb(ENISR_RDC, nic_base + EN0_ISR);\r\nei_status.dmaing &= ~0x01;\r\n}\r\nstatic void ne2k_pci_block_output(struct net_device *dev, int count,\r\nconst unsigned char *buf, const int start_page)\r\n{\r\nlong nic_base = NE_BASE;\r\nunsigned long dma_start;\r\nif (ei_status.ne2k_flags & ONLY_32BIT_IO)\r\ncount = (count + 3) & 0xFFFC;\r\nelse\r\nif (count & 0x01)\r\ncount++;\r\nif (ei_status.dmaing) {\r\nprintk("%s: DMAing conflict in ne2k_pci_block_output."\r\n"[DMAstat:%d][irqlock:%d]\n",\r\ndev->name, ei_status.dmaing, ei_status.irqlock);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\noutb(E8390_PAGE0+E8390_START+E8390_NODMA, nic_base + NE_CMD);\r\n#ifdef NE8390_RW_BUGFIX\r\noutb(0x42, nic_base + EN0_RCNTLO);\r\noutb(0x00, nic_base + EN0_RCNTHI);\r\noutb(0x42, nic_base + EN0_RSARLO);\r\noutb(0x00, nic_base + EN0_RSARHI);\r\noutb(E8390_RREAD+E8390_START, nic_base + NE_CMD);\r\n#endif\r\noutb(ENISR_RDC, nic_base + EN0_ISR);\r\noutb(count & 0xff, nic_base + EN0_RCNTLO);\r\noutb(count >> 8, nic_base + EN0_RCNTHI);\r\noutb(0x00, nic_base + EN0_RSARLO);\r\noutb(start_page, nic_base + EN0_RSARHI);\r\noutb(E8390_RWRITE+E8390_START, nic_base + NE_CMD);\r\nif (ei_status.ne2k_flags & ONLY_16BIT_IO) {\r\noutsw(NE_BASE + NE_DATAPORT, buf, count>>1);\r\n} else {\r\noutsl(NE_BASE + NE_DATAPORT, buf, count>>2);\r\nif (count & 3) {\r\nbuf += count & ~3;\r\nif (count & 2) {\r\n__le16 *b = (__le16 *)buf;\r\noutw(le16_to_cpu(*b++), NE_BASE + NE_DATAPORT);\r\nbuf = (char *)b;\r\n}\r\n}\r\n}\r\ndma_start = jiffies;\r\nwhile ((inb(nic_base + EN0_ISR) & ENISR_RDC) == 0)\r\nif (jiffies - dma_start > 2) {\r\nprintk(KERN_WARNING "%s: timeout waiting for Tx RDC.\n", dev->name);\r\nne2k_pci_reset_8390(dev);\r\nNS8390_init(dev,1);\r\nbreak;\r\n}\r\noutb(ENISR_RDC, nic_base + EN0_ISR);\r\nei_status.dmaing &= ~0x01;\r\n}\r\nstatic void ne2k_pci_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct ei_device *ei = netdev_priv(dev);\r\nstruct pci_dev *pci_dev = (struct pci_dev *) ei->priv;\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(pci_dev), sizeof(info->bus_info));\r\n}\r\nstatic void ne2k_pci_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nBUG_ON(!dev);\r\nunregister_netdev(dev);\r\nrelease_region(dev->base_addr, NE_IO_EXTENT);\r\nfree_netdev(dev);\r\npci_disable_device(pdev);\r\npci_set_drvdata(pdev, NULL);\r\n}\r\nstatic int ne2k_pci_suspend (struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata (pdev);\r\nnetif_device_detach(dev);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int ne2k_pci_resume (struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata (pdev);\r\nint rc;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nrc = pci_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nNS8390_init(dev, 1);\r\nnetif_device_attach(dev);\r\nreturn 0;\r\n}\r\nstatic int __init ne2k_pci_init(void)\r\n{\r\n#ifdef MODULE\r\nprintk(version);\r\n#endif\r\nreturn pci_register_driver(&ne2k_driver);\r\n}\r\nstatic void __exit ne2k_pci_cleanup(void)\r\n{\r\npci_unregister_driver (&ne2k_driver);\r\n}
