static struct mt9p031 *to_mt9p031(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct mt9p031, subdev);\r\n}\r\nstatic int mt9p031_read(struct i2c_client *client, u8 reg)\r\n{\r\nreturn i2c_smbus_read_word_swapped(client, reg);\r\n}\r\nstatic int mt9p031_write(struct i2c_client *client, u8 reg, u16 data)\r\n{\r\nreturn i2c_smbus_write_word_swapped(client, reg, data);\r\n}\r\nstatic int mt9p031_set_output_control(struct mt9p031 *mt9p031, u16 clear,\r\nu16 set)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);\r\nu16 value = (mt9p031->output_control & ~clear) | set;\r\nint ret;\r\nret = mt9p031_write(client, MT9P031_OUTPUT_CONTROL, value);\r\nif (ret < 0)\r\nreturn ret;\r\nmt9p031->output_control = value;\r\nreturn 0;\r\n}\r\nstatic int mt9p031_set_mode2(struct mt9p031 *mt9p031, u16 clear, u16 set)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);\r\nu16 value = (mt9p031->mode2 & ~clear) | set;\r\nint ret;\r\nret = mt9p031_write(client, MT9P031_READ_MODE_2, value);\r\nif (ret < 0)\r\nreturn ret;\r\nmt9p031->mode2 = value;\r\nreturn 0;\r\n}\r\nstatic int mt9p031_reset(struct mt9p031 *mt9p031)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);\r\nint ret;\r\nret = mt9p031_write(client, MT9P031_RST, MT9P031_RST_ENABLE);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9p031_write(client, MT9P031_RST, MT9P031_RST_DISABLE);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn mt9p031_set_output_control(mt9p031, MT9P031_OUTPUT_CONTROL_CEN,\r\n0);\r\n}\r\nstatic int mt9p031_clk_setup(struct mt9p031 *mt9p031)\r\n{\r\nstatic const struct aptina_pll_limits limits = {\r\n.ext_clock_min = 6000000,\r\n.ext_clock_max = 27000000,\r\n.int_clock_min = 2000000,\r\n.int_clock_max = 13500000,\r\n.out_clock_min = 180000000,\r\n.out_clock_max = 360000000,\r\n.pix_clock_max = 96000000,\r\n.n_min = 1,\r\n.n_max = 64,\r\n.m_min = 16,\r\n.m_max = 255,\r\n.p1_min = 1,\r\n.p1_max = 128,\r\n};\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);\r\nstruct mt9p031_platform_data *pdata = mt9p031->pdata;\r\nmt9p031->clk = devm_clk_get(&client->dev, NULL);\r\nif (IS_ERR(mt9p031->clk))\r\nreturn PTR_ERR(mt9p031->clk);\r\nclk_set_rate(mt9p031->clk, pdata->ext_freq);\r\nmt9p031->pll.ext_clock = pdata->ext_freq;\r\nmt9p031->pll.pix_clock = pdata->target_freq;\r\nreturn aptina_pll_calculate(&client->dev, &limits, &mt9p031->pll);\r\n}\r\nstatic int mt9p031_pll_enable(struct mt9p031 *mt9p031)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);\r\nint ret;\r\nret = mt9p031_write(client, MT9P031_PLL_CONTROL,\r\nMT9P031_PLL_CONTROL_PWRON);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9p031_write(client, MT9P031_PLL_CONFIG_1,\r\n(mt9p031->pll.m << 8) | (mt9p031->pll.n - 1));\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9p031_write(client, MT9P031_PLL_CONFIG_2, mt9p031->pll.p1 - 1);\r\nif (ret < 0)\r\nreturn ret;\r\nusleep_range(1000, 2000);\r\nret = mt9p031_write(client, MT9P031_PLL_CONTROL,\r\nMT9P031_PLL_CONTROL_PWRON |\r\nMT9P031_PLL_CONTROL_USEPLL);\r\nreturn ret;\r\n}\r\nstatic inline int mt9p031_pll_disable(struct mt9p031 *mt9p031)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);\r\nreturn mt9p031_write(client, MT9P031_PLL_CONTROL,\r\nMT9P031_PLL_CONTROL_PWROFF);\r\n}\r\nstatic int mt9p031_power_on(struct mt9p031 *mt9p031)\r\n{\r\nint ret;\r\nif (gpio_is_valid(mt9p031->reset)) {\r\ngpio_set_value(mt9p031->reset, 0);\r\nusleep_range(1000, 2000);\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(mt9p031->regulators),\r\nmt9p031->regulators);\r\nif (ret < 0)\r\nreturn ret;\r\nif (mt9p031->clk)\r\nclk_prepare_enable(mt9p031->clk);\r\nif (gpio_is_valid(mt9p031->reset)) {\r\ngpio_set_value(mt9p031->reset, 1);\r\nusleep_range(1000, 2000);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mt9p031_power_off(struct mt9p031 *mt9p031)\r\n{\r\nif (gpio_is_valid(mt9p031->reset)) {\r\ngpio_set_value(mt9p031->reset, 0);\r\nusleep_range(1000, 2000);\r\n}\r\nregulator_bulk_disable(ARRAY_SIZE(mt9p031->regulators),\r\nmt9p031->regulators);\r\nif (mt9p031->clk)\r\nclk_disable_unprepare(mt9p031->clk);\r\n}\r\nstatic int __mt9p031_set_power(struct mt9p031 *mt9p031, bool on)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);\r\nint ret;\r\nif (!on) {\r\nmt9p031_power_off(mt9p031);\r\nreturn 0;\r\n}\r\nret = mt9p031_power_on(mt9p031);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9p031_reset(mt9p031);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to reset the camera\n");\r\nreturn ret;\r\n}\r\nreturn v4l2_ctrl_handler_setup(&mt9p031->ctrls);\r\n}\r\nstatic int mt9p031_set_params(struct mt9p031 *mt9p031)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);\r\nstruct v4l2_mbus_framefmt *format = &mt9p031->format;\r\nconst struct v4l2_rect *crop = &mt9p031->crop;\r\nunsigned int hblank;\r\nunsigned int vblank;\r\nunsigned int xskip;\r\nunsigned int yskip;\r\nunsigned int xbin;\r\nunsigned int ybin;\r\nint ret;\r\nret = mt9p031_write(client, MT9P031_COLUMN_START, crop->left);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9p031_write(client, MT9P031_ROW_START, crop->top);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9p031_write(client, MT9P031_WINDOW_WIDTH, crop->width - 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9p031_write(client, MT9P031_WINDOW_HEIGHT, crop->height - 1);\r\nif (ret < 0)\r\nreturn ret;\r\nxskip = DIV_ROUND_CLOSEST(crop->width, format->width);\r\nyskip = DIV_ROUND_CLOSEST(crop->height, format->height);\r\nxbin = 1 << (ffs(xskip) - 1);\r\nybin = 1 << (ffs(yskip) - 1);\r\nret = mt9p031_write(client, MT9P031_COLUMN_ADDRESS_MODE,\r\n((xbin - 1) << 4) | (xskip - 1));\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9p031_write(client, MT9P031_ROW_ADDRESS_MODE,\r\n((ybin - 1) << 4) | (yskip - 1));\r\nif (ret < 0)\r\nreturn ret;\r\nhblank = 346 * ybin + 64 + (80 >> min_t(unsigned int, xbin, 3));\r\nvblank = MT9P031_VERTICAL_BLANK_DEF;\r\nret = mt9p031_write(client, MT9P031_HORIZONTAL_BLANK, hblank - 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9p031_write(client, MT9P031_VERTICAL_BLANK, vblank - 1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nstatic int mt9p031_s_stream(struct v4l2_subdev *subdev, int enable)\r\n{\r\nstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\r\nint ret;\r\nif (!enable) {\r\nret = mt9p031_set_output_control(mt9p031,\r\nMT9P031_OUTPUT_CONTROL_CEN, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn mt9p031_pll_disable(mt9p031);\r\n}\r\nret = mt9p031_set_params(mt9p031);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9p031_set_output_control(mt9p031, 0,\r\nMT9P031_OUTPUT_CONTROL_CEN);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn mt9p031_pll_enable(mt9p031);\r\n}\r\nstatic int mt9p031_enum_mbus_code(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\r\nif (code->pad || code->index)\r\nreturn -EINVAL;\r\ncode->code = mt9p031->format.code;\r\nreturn 0;\r\n}\r\nstatic int mt9p031_enum_frame_size(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\r\nif (fse->index >= 8 || fse->code != mt9p031->format.code)\r\nreturn -EINVAL;\r\nfse->min_width = MT9P031_WINDOW_WIDTH_DEF\r\n/ min_t(unsigned int, 7, fse->index + 1);\r\nfse->max_width = fse->min_width;\r\nfse->min_height = MT9P031_WINDOW_HEIGHT_DEF / (fse->index + 1);\r\nfse->max_height = fse->min_height;\r\nreturn 0;\r\n}\r\nstatic struct v4l2_mbus_framefmt *\r\n__mt9p031_get_pad_format(struct mt9p031 *mt9p031, struct v4l2_subdev_fh *fh,\r\nunsigned int pad, u32 which)\r\n{\r\nswitch (which) {\r\ncase V4L2_SUBDEV_FORMAT_TRY:\r\nreturn v4l2_subdev_get_try_format(fh, pad);\r\ncase V4L2_SUBDEV_FORMAT_ACTIVE:\r\nreturn &mt9p031->format;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic struct v4l2_rect *\r\n__mt9p031_get_pad_crop(struct mt9p031 *mt9p031, struct v4l2_subdev_fh *fh,\r\nunsigned int pad, u32 which)\r\n{\r\nswitch (which) {\r\ncase V4L2_SUBDEV_FORMAT_TRY:\r\nreturn v4l2_subdev_get_try_crop(fh, pad);\r\ncase V4L2_SUBDEV_FORMAT_ACTIVE:\r\nreturn &mt9p031->crop;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic int mt9p031_get_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\r\nfmt->format = *__mt9p031_get_pad_format(mt9p031, fh, fmt->pad,\r\nfmt->which);\r\nreturn 0;\r\n}\r\nstatic int mt9p031_set_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\r\nstruct v4l2_mbus_framefmt *__format;\r\nstruct v4l2_rect *__crop;\r\nunsigned int width;\r\nunsigned int height;\r\nunsigned int hratio;\r\nunsigned int vratio;\r\n__crop = __mt9p031_get_pad_crop(mt9p031, fh, format->pad,\r\nformat->which);\r\nwidth = clamp_t(unsigned int, ALIGN(format->format.width, 2),\r\nmax(__crop->width / 7, MT9P031_WINDOW_WIDTH_MIN),\r\n__crop->width);\r\nheight = clamp_t(unsigned int, ALIGN(format->format.height, 2),\r\nmax(__crop->height / 8, MT9P031_WINDOW_HEIGHT_MIN),\r\n__crop->height);\r\nhratio = DIV_ROUND_CLOSEST(__crop->width, width);\r\nvratio = DIV_ROUND_CLOSEST(__crop->height, height);\r\n__format = __mt9p031_get_pad_format(mt9p031, fh, format->pad,\r\nformat->which);\r\n__format->width = __crop->width / hratio;\r\n__format->height = __crop->height / vratio;\r\nformat->format = *__format;\r\nreturn 0;\r\n}\r\nstatic int mt9p031_get_crop(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_crop *crop)\r\n{\r\nstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\r\ncrop->rect = *__mt9p031_get_pad_crop(mt9p031, fh, crop->pad,\r\ncrop->which);\r\nreturn 0;\r\n}\r\nstatic int mt9p031_set_crop(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_crop *crop)\r\n{\r\nstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\r\nstruct v4l2_mbus_framefmt *__format;\r\nstruct v4l2_rect *__crop;\r\nstruct v4l2_rect rect;\r\nrect.left = clamp(ALIGN(crop->rect.left, 2), MT9P031_COLUMN_START_MIN,\r\nMT9P031_COLUMN_START_MAX);\r\nrect.top = clamp(ALIGN(crop->rect.top, 2), MT9P031_ROW_START_MIN,\r\nMT9P031_ROW_START_MAX);\r\nrect.width = clamp(ALIGN(crop->rect.width, 2),\r\nMT9P031_WINDOW_WIDTH_MIN,\r\nMT9P031_WINDOW_WIDTH_MAX);\r\nrect.height = clamp(ALIGN(crop->rect.height, 2),\r\nMT9P031_WINDOW_HEIGHT_MIN,\r\nMT9P031_WINDOW_HEIGHT_MAX);\r\nrect.width = min(rect.width, MT9P031_PIXEL_ARRAY_WIDTH - rect.left);\r\nrect.height = min(rect.height, MT9P031_PIXEL_ARRAY_HEIGHT - rect.top);\r\n__crop = __mt9p031_get_pad_crop(mt9p031, fh, crop->pad, crop->which);\r\nif (rect.width != __crop->width || rect.height != __crop->height) {\r\n__format = __mt9p031_get_pad_format(mt9p031, fh, crop->pad,\r\ncrop->which);\r\n__format->width = rect.width;\r\n__format->height = rect.height;\r\n}\r\n*__crop = rect;\r\ncrop->rect = rect;\r\nreturn 0;\r\n}\r\nstatic int mt9p031_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct mt9p031 *mt9p031 =\r\ncontainer_of(ctrl->handler, struct mt9p031, ctrls);\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);\r\nu16 data;\r\nint ret;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_EXPOSURE:\r\nret = mt9p031_write(client, MT9P031_SHUTTER_WIDTH_UPPER,\r\n(ctrl->val >> 16) & 0xffff);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn mt9p031_write(client, MT9P031_SHUTTER_WIDTH_LOWER,\r\nctrl->val & 0xffff);\r\ncase V4L2_CID_GAIN:\r\nif (ctrl->val <= 32) {\r\ndata = ctrl->val;\r\n} else if (ctrl->val <= 64) {\r\nctrl->val &= ~1;\r\ndata = (1 << 6) | (ctrl->val >> 1);\r\n} else {\r\nctrl->val &= ~7;\r\ndata = ((ctrl->val - 64) << 5) | (1 << 6) | 32;\r\n}\r\nreturn mt9p031_write(client, MT9P031_GLOBAL_GAIN, data);\r\ncase V4L2_CID_HFLIP:\r\nif (ctrl->val)\r\nreturn mt9p031_set_mode2(mt9p031,\r\n0, MT9P031_READ_MODE_2_COL_MIR);\r\nelse\r\nreturn mt9p031_set_mode2(mt9p031,\r\nMT9P031_READ_MODE_2_COL_MIR, 0);\r\ncase V4L2_CID_VFLIP:\r\nif (ctrl->val)\r\nreturn mt9p031_set_mode2(mt9p031,\r\n0, MT9P031_READ_MODE_2_ROW_MIR);\r\nelse\r\nreturn mt9p031_set_mode2(mt9p031,\r\nMT9P031_READ_MODE_2_ROW_MIR, 0);\r\ncase V4L2_CID_TEST_PATTERN:\r\nif (!ctrl->val) {\r\nif (mt9p031->blc_auto->cur.val != 0) {\r\nret = mt9p031_s_ctrl(mt9p031->blc_auto);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (mt9p031->blc_offset->cur.val != 0) {\r\nret = mt9p031_s_ctrl(mt9p031->blc_offset);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn mt9p031_write(client, MT9P031_TEST_PATTERN,\r\nMT9P031_TEST_PATTERN_DISABLE);\r\n}\r\nret = mt9p031_write(client, MT9P031_TEST_PATTERN_GREEN, 0x05a0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9p031_write(client, MT9P031_TEST_PATTERN_RED, 0x0a50);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9p031_write(client, MT9P031_TEST_PATTERN_BLUE, 0x0aa0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9p031_set_mode2(mt9p031, MT9P031_READ_MODE_2_ROW_BLC,\r\n0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9p031_write(client, MT9P031_ROW_BLACK_DEF_OFFSET, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn mt9p031_write(client, MT9P031_TEST_PATTERN,\r\n((ctrl->val - 1) << MT9P031_TEST_PATTERN_SHIFT)\r\n| MT9P031_TEST_PATTERN_ENABLE);\r\ncase V4L2_CID_BLC_AUTO:\r\nret = mt9p031_set_mode2(mt9p031,\r\nctrl->val ? 0 : MT9P031_READ_MODE_2_ROW_BLC,\r\nctrl->val ? MT9P031_READ_MODE_2_ROW_BLC : 0);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn mt9p031_write(client, MT9P031_BLACK_LEVEL_CALIBRATION,\r\nctrl->val ? 0 : MT9P031_BLC_MANUAL_BLC);\r\ncase V4L2_CID_BLC_TARGET_LEVEL:\r\nreturn mt9p031_write(client, MT9P031_ROW_BLACK_TARGET,\r\nctrl->val);\r\ncase V4L2_CID_BLC_ANALOG_OFFSET:\r\ndata = ctrl->val & ((1 << 9) - 1);\r\nret = mt9p031_write(client, MT9P031_GREEN1_OFFSET, data);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9p031_write(client, MT9P031_GREEN2_OFFSET, data);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9p031_write(client, MT9P031_RED_OFFSET, data);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn mt9p031_write(client, MT9P031_BLUE_OFFSET, data);\r\ncase V4L2_CID_BLC_DIGITAL_OFFSET:\r\nreturn mt9p031_write(client, MT9P031_ROW_BLACK_DEF_OFFSET,\r\nctrl->val & ((1 << 12) - 1));\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt9p031_set_power(struct v4l2_subdev *subdev, int on)\r\n{\r\nstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\r\nint ret = 0;\r\nmutex_lock(&mt9p031->power_lock);\r\nif (mt9p031->power_count == !on) {\r\nret = __mt9p031_set_power(mt9p031, !!on);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nmt9p031->power_count += on ? 1 : -1;\r\nWARN_ON(mt9p031->power_count < 0);\r\nout:\r\nmutex_unlock(&mt9p031->power_lock);\r\nreturn ret;\r\n}\r\nstatic int mt9p031_registered(struct v4l2_subdev *subdev)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(subdev);\r\nstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\r\ns32 data;\r\nint ret;\r\nret = mt9p031_power_on(mt9p031);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "MT9P031 power up failed\n");\r\nreturn ret;\r\n}\r\ndata = mt9p031_read(client, MT9P031_CHIP_VERSION);\r\nmt9p031_power_off(mt9p031);\r\nif (data != MT9P031_CHIP_VERSION_VALUE) {\r\ndev_err(&client->dev, "MT9P031 not detected, wrong version "\r\n"0x%04x\n", data);\r\nreturn -ENODEV;\r\n}\r\ndev_info(&client->dev, "MT9P031 detected at address 0x%02x\n",\r\nclient->addr);\r\nreturn 0;\r\n}\r\nstatic int mt9p031_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\r\nstruct v4l2_mbus_framefmt *format;\r\nstruct v4l2_rect *crop;\r\ncrop = v4l2_subdev_get_try_crop(fh, 0);\r\ncrop->left = MT9P031_COLUMN_START_DEF;\r\ncrop->top = MT9P031_ROW_START_DEF;\r\ncrop->width = MT9P031_WINDOW_WIDTH_DEF;\r\ncrop->height = MT9P031_WINDOW_HEIGHT_DEF;\r\nformat = v4l2_subdev_get_try_format(fh, 0);\r\nif (mt9p031->model == MT9P031_MODEL_MONOCHROME)\r\nformat->code = V4L2_MBUS_FMT_Y12_1X12;\r\nelse\r\nformat->code = V4L2_MBUS_FMT_SGRBG12_1X12;\r\nformat->width = MT9P031_WINDOW_WIDTH_DEF;\r\nformat->height = MT9P031_WINDOW_HEIGHT_DEF;\r\nformat->field = V4L2_FIELD_NONE;\r\nformat->colorspace = V4L2_COLORSPACE_SRGB;\r\nreturn mt9p031_set_power(subdev, 1);\r\n}\r\nstatic int mt9p031_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)\r\n{\r\nreturn mt9p031_set_power(subdev, 0);\r\n}\r\nstatic struct mt9p031_platform_data *\r\nmt9p031_get_pdata(struct i2c_client *client)\r\n{\r\nstruct mt9p031_platform_data *pdata;\r\nstruct device_node *np;\r\nif (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)\r\nreturn client->dev.platform_data;\r\nnp = v4l2_of_get_next_endpoint(client->dev.of_node, NULL);\r\nif (!np)\r\nreturn NULL;\r\npdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\ngoto done;\r\npdata->reset = of_get_named_gpio(client->dev.of_node, "reset-gpios", 0);\r\nof_property_read_u32(np, "input-clock-frequency", &pdata->ext_freq);\r\nof_property_read_u32(np, "pixel-clock-frequency", &pdata->target_freq);\r\ndone:\r\nof_node_put(np);\r\nreturn pdata;\r\n}\r\nstatic int mt9p031_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct mt9p031_platform_data *pdata = mt9p031_get_pdata(client);\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct mt9p031 *mt9p031;\r\nunsigned int i;\r\nint ret;\r\nif (pdata == NULL) {\r\ndev_err(&client->dev, "No platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA)) {\r\ndev_warn(&client->dev,\r\n"I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\n");\r\nreturn -EIO;\r\n}\r\nmt9p031 = devm_kzalloc(&client->dev, sizeof(*mt9p031), GFP_KERNEL);\r\nif (mt9p031 == NULL)\r\nreturn -ENOMEM;\r\nmt9p031->pdata = pdata;\r\nmt9p031->output_control = MT9P031_OUTPUT_CONTROL_DEF;\r\nmt9p031->mode2 = MT9P031_READ_MODE_2_ROW_BLC;\r\nmt9p031->model = did->driver_data;\r\nmt9p031->reset = -1;\r\nmt9p031->regulators[0].supply = "vdd";\r\nmt9p031->regulators[1].supply = "vdd_io";\r\nmt9p031->regulators[2].supply = "vaa";\r\nret = devm_regulator_bulk_get(&client->dev, 3, mt9p031->regulators);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Unable to get regulators\n");\r\nreturn ret;\r\n}\r\nv4l2_ctrl_handler_init(&mt9p031->ctrls, ARRAY_SIZE(mt9p031_ctrls) + 6);\r\nv4l2_ctrl_new_std(&mt9p031->ctrls, &mt9p031_ctrl_ops,\r\nV4L2_CID_EXPOSURE, MT9P031_SHUTTER_WIDTH_MIN,\r\nMT9P031_SHUTTER_WIDTH_MAX, 1,\r\nMT9P031_SHUTTER_WIDTH_DEF);\r\nv4l2_ctrl_new_std(&mt9p031->ctrls, &mt9p031_ctrl_ops,\r\nV4L2_CID_GAIN, MT9P031_GLOBAL_GAIN_MIN,\r\nMT9P031_GLOBAL_GAIN_MAX, 1, MT9P031_GLOBAL_GAIN_DEF);\r\nv4l2_ctrl_new_std(&mt9p031->ctrls, &mt9p031_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&mt9p031->ctrls, &mt9p031_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&mt9p031->ctrls, &mt9p031_ctrl_ops,\r\nV4L2_CID_PIXEL_RATE, pdata->target_freq,\r\npdata->target_freq, 1, pdata->target_freq);\r\nv4l2_ctrl_new_std_menu_items(&mt9p031->ctrls, &mt9p031_ctrl_ops,\r\nV4L2_CID_TEST_PATTERN,\r\nARRAY_SIZE(mt9p031_test_pattern_menu) - 1, 0,\r\n0, mt9p031_test_pattern_menu);\r\nfor (i = 0; i < ARRAY_SIZE(mt9p031_ctrls); ++i)\r\nv4l2_ctrl_new_custom(&mt9p031->ctrls, &mt9p031_ctrls[i], NULL);\r\nmt9p031->subdev.ctrl_handler = &mt9p031->ctrls;\r\nif (mt9p031->ctrls.error) {\r\nprintk(KERN_INFO "%s: control initialization error %d\n",\r\n__func__, mt9p031->ctrls.error);\r\nret = mt9p031->ctrls.error;\r\ngoto done;\r\n}\r\nmt9p031->blc_auto = v4l2_ctrl_find(&mt9p031->ctrls, V4L2_CID_BLC_AUTO);\r\nmt9p031->blc_offset = v4l2_ctrl_find(&mt9p031->ctrls,\r\nV4L2_CID_BLC_DIGITAL_OFFSET);\r\nmutex_init(&mt9p031->power_lock);\r\nv4l2_i2c_subdev_init(&mt9p031->subdev, client, &mt9p031_subdev_ops);\r\nmt9p031->subdev.internal_ops = &mt9p031_subdev_internal_ops;\r\nmt9p031->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_init(&mt9p031->subdev.entity, 1, &mt9p031->pad, 0);\r\nif (ret < 0)\r\ngoto done;\r\nmt9p031->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nmt9p031->crop.width = MT9P031_WINDOW_WIDTH_DEF;\r\nmt9p031->crop.height = MT9P031_WINDOW_HEIGHT_DEF;\r\nmt9p031->crop.left = MT9P031_COLUMN_START_DEF;\r\nmt9p031->crop.top = MT9P031_ROW_START_DEF;\r\nif (mt9p031->model == MT9P031_MODEL_MONOCHROME)\r\nmt9p031->format.code = V4L2_MBUS_FMT_Y12_1X12;\r\nelse\r\nmt9p031->format.code = V4L2_MBUS_FMT_SGRBG12_1X12;\r\nmt9p031->format.width = MT9P031_WINDOW_WIDTH_DEF;\r\nmt9p031->format.height = MT9P031_WINDOW_HEIGHT_DEF;\r\nmt9p031->format.field = V4L2_FIELD_NONE;\r\nmt9p031->format.colorspace = V4L2_COLORSPACE_SRGB;\r\nif (gpio_is_valid(pdata->reset)) {\r\nret = devm_gpio_request_one(&client->dev, pdata->reset,\r\nGPIOF_OUT_INIT_LOW, "mt9p031_rst");\r\nif (ret < 0)\r\ngoto done;\r\nmt9p031->reset = pdata->reset;\r\n}\r\nret = mt9p031_clk_setup(mt9p031);\r\ndone:\r\nif (ret < 0) {\r\nv4l2_ctrl_handler_free(&mt9p031->ctrls);\r\nmedia_entity_cleanup(&mt9p031->subdev.entity);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mt9p031_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\r\nv4l2_ctrl_handler_free(&mt9p031->ctrls);\r\nv4l2_device_unregister_subdev(subdev);\r\nmedia_entity_cleanup(&subdev->entity);\r\nreturn 0;\r\n}
