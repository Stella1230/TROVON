static inline void init_trace_uprobe_filter(struct trace_uprobe_filter *filter)\r\n{\r\nrwlock_init(&filter->rwlock);\r\nfilter->nr_systemwide = 0;\r\nINIT_LIST_HEAD(&filter->perf_events);\r\n}\r\nstatic inline bool uprobe_filter_is_empty(struct trace_uprobe_filter *filter)\r\n{\r\nreturn !filter->nr_systemwide && list_empty(&filter->perf_events);\r\n}\r\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\r\n{\r\nreturn tu->consumer.ret_handler != NULL;\r\n}\r\nstatic struct trace_uprobe *\r\nalloc_trace_uprobe(const char *group, const char *event, int nargs, bool is_ret)\r\n{\r\nstruct trace_uprobe *tu;\r\nif (!event || !is_good_name(event))\r\nreturn ERR_PTR(-EINVAL);\r\nif (!group || !is_good_name(group))\r\nreturn ERR_PTR(-EINVAL);\r\ntu = kzalloc(SIZEOF_TRACE_UPROBE(nargs), GFP_KERNEL);\r\nif (!tu)\r\nreturn ERR_PTR(-ENOMEM);\r\ntu->call.class = &tu->class;\r\ntu->call.name = kstrdup(event, GFP_KERNEL);\r\nif (!tu->call.name)\r\ngoto error;\r\ntu->class.system = kstrdup(group, GFP_KERNEL);\r\nif (!tu->class.system)\r\ngoto error;\r\nINIT_LIST_HEAD(&tu->list);\r\ntu->consumer.handler = uprobe_dispatcher;\r\nif (is_ret)\r\ntu->consumer.ret_handler = uretprobe_dispatcher;\r\ninit_trace_uprobe_filter(&tu->filter);\r\nreturn tu;\r\nerror:\r\nkfree(tu->call.name);\r\nkfree(tu);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic void free_trace_uprobe(struct trace_uprobe *tu)\r\n{\r\nint i;\r\nfor (i = 0; i < tu->nr_args; i++)\r\ntraceprobe_free_probe_arg(&tu->args[i]);\r\niput(tu->inode);\r\nkfree(tu->call.class->system);\r\nkfree(tu->call.name);\r\nkfree(tu->filename);\r\nkfree(tu);\r\n}\r\nstatic struct trace_uprobe *find_probe_event(const char *event, const char *group)\r\n{\r\nstruct trace_uprobe *tu;\r\nlist_for_each_entry(tu, &uprobe_list, list)\r\nif (strcmp(tu->call.name, event) == 0 &&\r\nstrcmp(tu->call.class->system, group) == 0)\r\nreturn tu;\r\nreturn NULL;\r\n}\r\nstatic int unregister_trace_uprobe(struct trace_uprobe *tu)\r\n{\r\nint ret;\r\nret = unregister_uprobe_event(tu);\r\nif (ret)\r\nreturn ret;\r\nlist_del(&tu->list);\r\nfree_trace_uprobe(tu);\r\nreturn 0;\r\n}\r\nstatic int register_trace_uprobe(struct trace_uprobe *tu)\r\n{\r\nstruct trace_uprobe *old_tp;\r\nint ret;\r\nmutex_lock(&uprobe_lock);\r\nold_tp = find_probe_event(tu->call.name, tu->call.class->system);\r\nif (old_tp) {\r\nret = unregister_trace_uprobe(old_tp);\r\nif (ret)\r\ngoto end;\r\n}\r\nret = register_uprobe_event(tu);\r\nif (ret) {\r\npr_warning("Failed to register probe event(%d)\n", ret);\r\ngoto end;\r\n}\r\nlist_add_tail(&tu->list, &uprobe_list);\r\nend:\r\nmutex_unlock(&uprobe_lock);\r\nreturn ret;\r\n}\r\nstatic int create_trace_uprobe(int argc, char **argv)\r\n{\r\nstruct trace_uprobe *tu;\r\nstruct inode *inode;\r\nchar *arg, *event, *group, *filename;\r\nchar buf[MAX_EVENT_NAME_LEN];\r\nstruct path path;\r\nunsigned long offset;\r\nbool is_delete, is_return;\r\nint i, ret;\r\ninode = NULL;\r\nret = 0;\r\nis_delete = false;\r\nis_return = false;\r\nevent = NULL;\r\ngroup = NULL;\r\nif (argv[0][0] == '-')\r\nis_delete = true;\r\nelse if (argv[0][0] == 'r')\r\nis_return = true;\r\nelse if (argv[0][0] != 'p') {\r\npr_info("Probe definition must be started with 'p', 'r' or '-'.\n");\r\nreturn -EINVAL;\r\n}\r\nif (argv[0][1] == ':') {\r\nevent = &argv[0][2];\r\narg = strchr(event, '/');\r\nif (arg) {\r\ngroup = event;\r\nevent = arg + 1;\r\nevent[-1] = '\0';\r\nif (strlen(group) == 0) {\r\npr_info("Group name is not specified\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (strlen(event) == 0) {\r\npr_info("Event name is not specified\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!group)\r\ngroup = UPROBE_EVENT_SYSTEM;\r\nif (is_delete) {\r\nint ret;\r\nif (!event) {\r\npr_info("Delete command needs an event name.\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&uprobe_lock);\r\ntu = find_probe_event(event, group);\r\nif (!tu) {\r\nmutex_unlock(&uprobe_lock);\r\npr_info("Event %s/%s doesn't exist.\n", group, event);\r\nreturn -ENOENT;\r\n}\r\nret = unregister_trace_uprobe(tu);\r\nmutex_unlock(&uprobe_lock);\r\nreturn ret;\r\n}\r\nif (argc < 2) {\r\npr_info("Probe point is not specified.\n");\r\nreturn -EINVAL;\r\n}\r\nif (isdigit(argv[1][0])) {\r\npr_info("probe point must be have a filename.\n");\r\nreturn -EINVAL;\r\n}\r\narg = strchr(argv[1], ':');\r\nif (!arg) {\r\nret = -EINVAL;\r\ngoto fail_address_parse;\r\n}\r\n*arg++ = '\0';\r\nfilename = argv[1];\r\nret = kern_path(filename, LOOKUP_FOLLOW, &path);\r\nif (ret)\r\ngoto fail_address_parse;\r\ninode = igrab(path.dentry->d_inode);\r\npath_put(&path);\r\nif (!inode || !S_ISREG(inode->i_mode)) {\r\nret = -EINVAL;\r\ngoto fail_address_parse;\r\n}\r\nret = kstrtoul(arg, 0, &offset);\r\nif (ret)\r\ngoto fail_address_parse;\r\nargc -= 2;\r\nargv += 2;\r\nif (!event) {\r\nchar *tail;\r\nchar *ptr;\r\ntail = kstrdup(kbasename(filename), GFP_KERNEL);\r\nif (!tail) {\r\nret = -ENOMEM;\r\ngoto fail_address_parse;\r\n}\r\nptr = strpbrk(tail, ".-_");\r\nif (ptr)\r\n*ptr = '\0';\r\nsnprintf(buf, MAX_EVENT_NAME_LEN, "%c_%s_0x%lx", 'p', tail, offset);\r\nevent = buf;\r\nkfree(tail);\r\n}\r\ntu = alloc_trace_uprobe(group, event, argc, is_return);\r\nif (IS_ERR(tu)) {\r\npr_info("Failed to allocate trace_uprobe.(%d)\n", (int)PTR_ERR(tu));\r\nret = PTR_ERR(tu);\r\ngoto fail_address_parse;\r\n}\r\ntu->offset = offset;\r\ntu->inode = inode;\r\ntu->filename = kstrdup(filename, GFP_KERNEL);\r\nif (!tu->filename) {\r\npr_info("Failed to allocate filename.\n");\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nret = 0;\r\nfor (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {\r\ntu->nr_args++;\r\narg = strchr(argv[i], '=');\r\nif (arg) {\r\n*arg++ = '\0';\r\ntu->args[i].name = kstrdup(argv[i], GFP_KERNEL);\r\n} else {\r\narg = argv[i];\r\nsnprintf(buf, MAX_EVENT_NAME_LEN, "arg%d", i + 1);\r\ntu->args[i].name = kstrdup(buf, GFP_KERNEL);\r\n}\r\nif (!tu->args[i].name) {\r\npr_info("Failed to allocate argument[%d] name.\n", i);\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (!is_good_name(tu->args[i].name)) {\r\npr_info("Invalid argument[%d] name: %s\n", i, tu->args[i].name);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nif (traceprobe_conflict_field_name(tu->args[i].name, tu->args, i)) {\r\npr_info("Argument[%d] name '%s' conflicts with "\r\n"another field.\n", i, argv[i]);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nret = traceprobe_parse_probe_arg(arg, &tu->size, &tu->args[i], false, false);\r\nif (ret) {\r\npr_info("Parse error at argument[%d]. (%d)\n", i, ret);\r\ngoto error;\r\n}\r\n}\r\nret = register_trace_uprobe(tu);\r\nif (ret)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nfree_trace_uprobe(tu);\r\nreturn ret;\r\nfail_address_parse:\r\nif (inode)\r\niput(inode);\r\npr_info("Failed to parse address or file.\n");\r\nreturn ret;\r\n}\r\nstatic int cleanup_all_probes(void)\r\n{\r\nstruct trace_uprobe *tu;\r\nint ret = 0;\r\nmutex_lock(&uprobe_lock);\r\nwhile (!list_empty(&uprobe_list)) {\r\ntu = list_entry(uprobe_list.next, struct trace_uprobe, list);\r\nret = unregister_trace_uprobe(tu);\r\nif (ret)\r\nbreak;\r\n}\r\nmutex_unlock(&uprobe_lock);\r\nreturn ret;\r\n}\r\nstatic void *probes_seq_start(struct seq_file *m, loff_t *pos)\r\n{\r\nmutex_lock(&uprobe_lock);\r\nreturn seq_list_start(&uprobe_list, *pos);\r\n}\r\nstatic void *probes_seq_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\nreturn seq_list_next(v, &uprobe_list, pos);\r\n}\r\nstatic void probes_seq_stop(struct seq_file *m, void *v)\r\n{\r\nmutex_unlock(&uprobe_lock);\r\n}\r\nstatic int probes_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct trace_uprobe *tu = v;\r\nchar c = is_ret_probe(tu) ? 'r' : 'p';\r\nint i;\r\nseq_printf(m, "%c:%s/%s", c, tu->call.class->system, tu->call.name);\r\nseq_printf(m, " %s:0x%p", tu->filename, (void *)tu->offset);\r\nfor (i = 0; i < tu->nr_args; i++)\r\nseq_printf(m, " %s=%s", tu->args[i].name, tu->args[i].comm);\r\nseq_printf(m, "\n");\r\nreturn 0;\r\n}\r\nstatic int probes_open(struct inode *inode, struct file *file)\r\n{\r\nint ret;\r\nif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\r\nret = cleanup_all_probes();\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn seq_open(file, &probes_seq_op);\r\n}\r\nstatic ssize_t probes_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn traceprobe_probes_write(file, buffer, count, ppos, create_trace_uprobe);\r\n}\r\nstatic int probes_profile_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct trace_uprobe *tu = v;\r\nseq_printf(m, " %s %-44s %15lu\n", tu->filename, tu->call.name, tu->nhit);\r\nreturn 0;\r\n}\r\nstatic int profile_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &profile_seq_op);\r\n}\r\nstatic void uprobe_trace_print(struct trace_uprobe *tu,\r\nunsigned long func, struct pt_regs *regs)\r\n{\r\nstruct uprobe_trace_entry_head *entry;\r\nstruct ring_buffer_event *event;\r\nstruct ring_buffer *buffer;\r\nvoid *data;\r\nint size, i;\r\nstruct ftrace_event_call *call = &tu->call;\r\nsize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\r\nevent = trace_current_buffer_lock_reserve(&buffer, call->event.type,\r\nsize + tu->size, 0, 0);\r\nif (!event)\r\nreturn;\r\nentry = ring_buffer_event_data(event);\r\nif (is_ret_probe(tu)) {\r\nentry->vaddr[0] = func;\r\nentry->vaddr[1] = instruction_pointer(regs);\r\ndata = DATAOF_TRACE_ENTRY(entry, true);\r\n} else {\r\nentry->vaddr[0] = instruction_pointer(regs);\r\ndata = DATAOF_TRACE_ENTRY(entry, false);\r\n}\r\nfor (i = 0; i < tu->nr_args; i++)\r\ncall_fetch(&tu->args[i].fetch, regs, data + tu->args[i].offset);\r\nif (!filter_current_check_discard(buffer, call, entry, event))\r\ntrace_buffer_unlock_commit(buffer, event, 0, 0);\r\n}\r\nstatic int uprobe_trace_func(struct trace_uprobe *tu, struct pt_regs *regs)\r\n{\r\nif (!is_ret_probe(tu))\r\nuprobe_trace_print(tu, 0, regs);\r\nreturn 0;\r\n}\r\nstatic void uretprobe_trace_func(struct trace_uprobe *tu, unsigned long func,\r\nstruct pt_regs *regs)\r\n{\r\nuprobe_trace_print(tu, func, regs);\r\n}\r\nstatic enum print_line_t\r\nprint_uprobe_event(struct trace_iterator *iter, int flags, struct trace_event *event)\r\n{\r\nstruct uprobe_trace_entry_head *entry;\r\nstruct trace_seq *s = &iter->seq;\r\nstruct trace_uprobe *tu;\r\nu8 *data;\r\nint i;\r\nentry = (struct uprobe_trace_entry_head *)iter->ent;\r\ntu = container_of(event, struct trace_uprobe, call.event);\r\nif (is_ret_probe(tu)) {\r\nif (!trace_seq_printf(s, "%s: (0x%lx <- 0x%lx)", tu->call.name,\r\nentry->vaddr[1], entry->vaddr[0]))\r\ngoto partial;\r\ndata = DATAOF_TRACE_ENTRY(entry, true);\r\n} else {\r\nif (!trace_seq_printf(s, "%s: (0x%lx)", tu->call.name,\r\nentry->vaddr[0]))\r\ngoto partial;\r\ndata = DATAOF_TRACE_ENTRY(entry, false);\r\n}\r\nfor (i = 0; i < tu->nr_args; i++) {\r\nif (!tu->args[i].type->print(s, tu->args[i].name,\r\ndata + tu->args[i].offset, entry))\r\ngoto partial;\r\n}\r\nif (trace_seq_puts(s, "\n"))\r\nreturn TRACE_TYPE_HANDLED;\r\npartial:\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\n}\r\nstatic inline bool is_trace_uprobe_enabled(struct trace_uprobe *tu)\r\n{\r\nreturn tu->flags & (TP_FLAG_TRACE | TP_FLAG_PROFILE);\r\n}\r\nstatic int\r\nprobe_event_enable(struct trace_uprobe *tu, int flag, filter_func_t filter)\r\n{\r\nint ret = 0;\r\nif (is_trace_uprobe_enabled(tu))\r\nreturn -EINTR;\r\nWARN_ON(!uprobe_filter_is_empty(&tu->filter));\r\ntu->flags |= flag;\r\ntu->consumer.filter = filter;\r\nret = uprobe_register(tu->inode, tu->offset, &tu->consumer);\r\nif (ret)\r\ntu->flags &= ~flag;\r\nreturn ret;\r\n}\r\nstatic void probe_event_disable(struct trace_uprobe *tu, int flag)\r\n{\r\nif (!is_trace_uprobe_enabled(tu))\r\nreturn;\r\nWARN_ON(!uprobe_filter_is_empty(&tu->filter));\r\nuprobe_unregister(tu->inode, tu->offset, &tu->consumer);\r\ntu->flags &= ~flag;\r\n}\r\nstatic int uprobe_event_define_fields(struct ftrace_event_call *event_call)\r\n{\r\nint ret, i, size;\r\nstruct uprobe_trace_entry_head field;\r\nstruct trace_uprobe *tu = event_call->data;\r\nif (is_ret_probe(tu)) {\r\nDEFINE_FIELD(unsigned long, vaddr[0], FIELD_STRING_FUNC, 0);\r\nDEFINE_FIELD(unsigned long, vaddr[1], FIELD_STRING_RETIP, 0);\r\nsize = SIZEOF_TRACE_ENTRY(true);\r\n} else {\r\nDEFINE_FIELD(unsigned long, vaddr[0], FIELD_STRING_IP, 0);\r\nsize = SIZEOF_TRACE_ENTRY(false);\r\n}\r\nfor (i = 0; i < tu->nr_args; i++) {\r\nret = trace_define_field(event_call, tu->args[i].type->fmttype,\r\ntu->args[i].name,\r\nsize + tu->args[i].offset,\r\ntu->args[i].type->size,\r\ntu->args[i].type->is_signed,\r\nFILTER_OTHER);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __set_print_fmt(struct trace_uprobe *tu, char *buf, int len)\r\n{\r\nconst char *fmt, *arg;\r\nint i;\r\nint pos = 0;\r\nif (is_ret_probe(tu)) {\r\nfmt = "(%lx <- %lx)";\r\narg = "REC->" FIELD_STRING_FUNC ", REC->" FIELD_STRING_RETIP;\r\n} else {\r\nfmt = "(%lx)";\r\narg = "REC->" FIELD_STRING_IP;\r\n}\r\npos += snprintf(buf + pos, LEN_OR_ZERO, "\"%s", fmt);\r\nfor (i = 0; i < tu->nr_args; i++) {\r\npos += snprintf(buf + pos, LEN_OR_ZERO, " %s=%s",\r\ntu->args[i].name, tu->args[i].type->fmt);\r\n}\r\npos += snprintf(buf + pos, LEN_OR_ZERO, "\", %s", arg);\r\nfor (i = 0; i < tu->nr_args; i++) {\r\npos += snprintf(buf + pos, LEN_OR_ZERO, ", REC->%s",\r\ntu->args[i].name);\r\n}\r\nreturn pos;\r\n}\r\nstatic int set_print_fmt(struct trace_uprobe *tu)\r\n{\r\nchar *print_fmt;\r\nint len;\r\nlen = __set_print_fmt(tu, NULL, 0);\r\nprint_fmt = kmalloc(len + 1, GFP_KERNEL);\r\nif (!print_fmt)\r\nreturn -ENOMEM;\r\n__set_print_fmt(tu, print_fmt, len + 1);\r\ntu->call.print_fmt = print_fmt;\r\nreturn 0;\r\n}\r\nstatic bool\r\n__uprobe_perf_filter(struct trace_uprobe_filter *filter, struct mm_struct *mm)\r\n{\r\nstruct perf_event *event;\r\nif (filter->nr_systemwide)\r\nreturn true;\r\nlist_for_each_entry(event, &filter->perf_events, hw.tp_list) {\r\nif (event->hw.tp_target->mm == mm)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic inline bool\r\nuprobe_filter_event(struct trace_uprobe *tu, struct perf_event *event)\r\n{\r\nreturn __uprobe_perf_filter(&tu->filter, event->hw.tp_target->mm);\r\n}\r\nstatic int uprobe_perf_open(struct trace_uprobe *tu, struct perf_event *event)\r\n{\r\nbool done;\r\nwrite_lock(&tu->filter.rwlock);\r\nif (event->hw.tp_target) {\r\ndone = tu->filter.nr_systemwide ||\r\nevent->parent || event->attr.enable_on_exec ||\r\nuprobe_filter_event(tu, event);\r\nlist_add(&event->hw.tp_list, &tu->filter.perf_events);\r\n} else {\r\ndone = tu->filter.nr_systemwide;\r\ntu->filter.nr_systemwide++;\r\n}\r\nwrite_unlock(&tu->filter.rwlock);\r\nif (!done)\r\nuprobe_apply(tu->inode, tu->offset, &tu->consumer, true);\r\nreturn 0;\r\n}\r\nstatic int uprobe_perf_close(struct trace_uprobe *tu, struct perf_event *event)\r\n{\r\nbool done;\r\nwrite_lock(&tu->filter.rwlock);\r\nif (event->hw.tp_target) {\r\nlist_del(&event->hw.tp_list);\r\ndone = tu->filter.nr_systemwide ||\r\n(event->hw.tp_target->flags & PF_EXITING) ||\r\nuprobe_filter_event(tu, event);\r\n} else {\r\ntu->filter.nr_systemwide--;\r\ndone = tu->filter.nr_systemwide;\r\n}\r\nwrite_unlock(&tu->filter.rwlock);\r\nif (!done)\r\nuprobe_apply(tu->inode, tu->offset, &tu->consumer, false);\r\nreturn 0;\r\n}\r\nstatic bool uprobe_perf_filter(struct uprobe_consumer *uc,\r\nenum uprobe_filter_ctx ctx, struct mm_struct *mm)\r\n{\r\nstruct trace_uprobe *tu;\r\nint ret;\r\ntu = container_of(uc, struct trace_uprobe, consumer);\r\nread_lock(&tu->filter.rwlock);\r\nret = __uprobe_perf_filter(&tu->filter, mm);\r\nread_unlock(&tu->filter.rwlock);\r\nreturn ret;\r\n}\r\nstatic void uprobe_perf_print(struct trace_uprobe *tu,\r\nunsigned long func, struct pt_regs *regs)\r\n{\r\nstruct ftrace_event_call *call = &tu->call;\r\nstruct uprobe_trace_entry_head *entry;\r\nstruct hlist_head *head;\r\nvoid *data;\r\nint size, rctx, i;\r\nsize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\r\nsize = ALIGN(size + tu->size + sizeof(u32), sizeof(u64)) - sizeof(u32);\r\npreempt_disable();\r\nhead = this_cpu_ptr(call->perf_events);\r\nif (hlist_empty(head))\r\ngoto out;\r\nentry = perf_trace_buf_prepare(size, call->event.type, regs, &rctx);\r\nif (!entry)\r\ngoto out;\r\nif (is_ret_probe(tu)) {\r\nentry->vaddr[0] = func;\r\nentry->vaddr[1] = instruction_pointer(regs);\r\ndata = DATAOF_TRACE_ENTRY(entry, true);\r\n} else {\r\nentry->vaddr[0] = instruction_pointer(regs);\r\ndata = DATAOF_TRACE_ENTRY(entry, false);\r\n}\r\nfor (i = 0; i < tu->nr_args; i++)\r\ncall_fetch(&tu->args[i].fetch, regs, data + tu->args[i].offset);\r\nperf_trace_buf_submit(entry, size, rctx, 0, 1, regs, head, NULL);\r\nout:\r\npreempt_enable();\r\n}\r\nstatic int uprobe_perf_func(struct trace_uprobe *tu, struct pt_regs *regs)\r\n{\r\nif (!uprobe_perf_filter(&tu->consumer, 0, current->mm))\r\nreturn UPROBE_HANDLER_REMOVE;\r\nif (!is_ret_probe(tu))\r\nuprobe_perf_print(tu, 0, regs);\r\nreturn 0;\r\n}\r\nstatic void uretprobe_perf_func(struct trace_uprobe *tu, unsigned long func,\r\nstruct pt_regs *regs)\r\n{\r\nuprobe_perf_print(tu, func, regs);\r\n}\r\nstatic\r\nint trace_uprobe_register(struct ftrace_event_call *event, enum trace_reg type, void *data)\r\n{\r\nstruct trace_uprobe *tu = event->data;\r\nswitch (type) {\r\ncase TRACE_REG_REGISTER:\r\nreturn probe_event_enable(tu, TP_FLAG_TRACE, NULL);\r\ncase TRACE_REG_UNREGISTER:\r\nprobe_event_disable(tu, TP_FLAG_TRACE);\r\nreturn 0;\r\n#ifdef CONFIG_PERF_EVENTS\r\ncase TRACE_REG_PERF_REGISTER:\r\nreturn probe_event_enable(tu, TP_FLAG_PROFILE, uprobe_perf_filter);\r\ncase TRACE_REG_PERF_UNREGISTER:\r\nprobe_event_disable(tu, TP_FLAG_PROFILE);\r\nreturn 0;\r\ncase TRACE_REG_PERF_OPEN:\r\nreturn uprobe_perf_open(tu, data);\r\ncase TRACE_REG_PERF_CLOSE:\r\nreturn uprobe_perf_close(tu, data);\r\n#endif\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs)\r\n{\r\nstruct trace_uprobe *tu;\r\nint ret = 0;\r\ntu = container_of(con, struct trace_uprobe, consumer);\r\ntu->nhit++;\r\nif (tu->flags & TP_FLAG_TRACE)\r\nret |= uprobe_trace_func(tu, regs);\r\n#ifdef CONFIG_PERF_EVENTS\r\nif (tu->flags & TP_FLAG_PROFILE)\r\nret |= uprobe_perf_func(tu, regs);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\r\nunsigned long func, struct pt_regs *regs)\r\n{\r\nstruct trace_uprobe *tu;\r\ntu = container_of(con, struct trace_uprobe, consumer);\r\nif (tu->flags & TP_FLAG_TRACE)\r\nuretprobe_trace_func(tu, func, regs);\r\n#ifdef CONFIG_PERF_EVENTS\r\nif (tu->flags & TP_FLAG_PROFILE)\r\nuretprobe_perf_func(tu, func, regs);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int register_uprobe_event(struct trace_uprobe *tu)\r\n{\r\nstruct ftrace_event_call *call = &tu->call;\r\nint ret;\r\nINIT_LIST_HEAD(&call->class->fields);\r\ncall->event.funcs = &uprobe_funcs;\r\ncall->class->define_fields = uprobe_event_define_fields;\r\nif (set_print_fmt(tu) < 0)\r\nreturn -ENOMEM;\r\nret = register_ftrace_event(&call->event);\r\nif (!ret) {\r\nkfree(call->print_fmt);\r\nreturn -ENODEV;\r\n}\r\ncall->flags = 0;\r\ncall->class->reg = trace_uprobe_register;\r\ncall->data = tu;\r\nret = trace_add_event_call(call);\r\nif (ret) {\r\npr_info("Failed to register uprobe event: %s\n", call->name);\r\nkfree(call->print_fmt);\r\nunregister_ftrace_event(&call->event);\r\n}\r\nreturn ret;\r\n}\r\nstatic int unregister_uprobe_event(struct trace_uprobe *tu)\r\n{\r\nint ret;\r\nret = trace_remove_event_call(&tu->call);\r\nif (ret)\r\nreturn ret;\r\nkfree(tu->call.print_fmt);\r\ntu->call.print_fmt = NULL;\r\nreturn 0;\r\n}\r\nstatic __init int init_uprobe_trace(void)\r\n{\r\nstruct dentry *d_tracer;\r\nd_tracer = tracing_init_dentry();\r\nif (!d_tracer)\r\nreturn 0;\r\ntrace_create_file("uprobe_events", 0644, d_tracer,\r\nNULL, &uprobe_events_ops);\r\ntrace_create_file("uprobe_profile", 0444, d_tracer,\r\nNULL, &uprobe_profile_ops);\r\nreturn 0;\r\n}
