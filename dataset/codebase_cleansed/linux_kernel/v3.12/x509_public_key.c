static int x509_check_signature(const struct public_key *pub,\r\nconst struct x509_certificate *cert)\r\n{\r\nstruct public_key_signature *sig;\r\nstruct crypto_shash *tfm;\r\nstruct shash_desc *desc;\r\nsize_t digest_size, desc_size;\r\nint ret;\r\npr_devel("==>%s()\n", __func__);\r\ntfm = crypto_alloc_shash(pkey_hash_algo[cert->sig_hash_algo], 0, 0);\r\nif (IS_ERR(tfm))\r\nreturn (PTR_ERR(tfm) == -ENOENT) ? -ENOPKG : PTR_ERR(tfm);\r\ndesc_size = crypto_shash_descsize(tfm) + sizeof(*desc);\r\ndigest_size = crypto_shash_digestsize(tfm);\r\nret = -ENOMEM;\r\nsig = kzalloc(sizeof(*sig) + desc_size + digest_size, GFP_KERNEL);\r\nif (!sig)\r\ngoto error_no_sig;\r\nsig->pkey_hash_algo = cert->sig_hash_algo;\r\nsig->digest = (u8 *)sig + sizeof(*sig) + desc_size;\r\nsig->digest_size = digest_size;\r\ndesc = (void *)sig + sizeof(*sig);\r\ndesc->tfm = tfm;\r\ndesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nret = crypto_shash_init(desc);\r\nif (ret < 0)\r\ngoto error;\r\nret = -ENOMEM;\r\nsig->rsa.s = mpi_read_raw_data(cert->sig, cert->sig_size);\r\nif (!sig->rsa.s)\r\ngoto error;\r\nret = crypto_shash_finup(desc, cert->tbs, cert->tbs_size, sig->digest);\r\nif (ret < 0)\r\ngoto error_mpi;\r\nret = pub->algo->verify_signature(pub, sig);\r\npr_debug("Cert Verification: %d\n", ret);\r\nerror_mpi:\r\nmpi_free(sig->rsa.s);\r\nerror:\r\nkfree(sig);\r\nerror_no_sig:\r\ncrypto_free_shash(tfm);\r\npr_devel("<==%s() = %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int x509_key_preparse(struct key_preparsed_payload *prep)\r\n{\r\nstruct x509_certificate *cert;\r\nstruct tm now;\r\nsize_t srlen, sulen;\r\nchar *desc = NULL;\r\nint ret;\r\ncert = x509_cert_parse(prep->data, prep->datalen);\r\nif (IS_ERR(cert))\r\nreturn PTR_ERR(cert);\r\npr_devel("Cert Issuer: %s\n", cert->issuer);\r\npr_devel("Cert Subject: %s\n", cert->subject);\r\npr_devel("Cert Key Algo: %s\n", pkey_algo[cert->pkey_algo]);\r\npr_devel("Cert Valid From: %04ld-%02d-%02d %02d:%02d:%02d\n",\r\ncert->valid_from.tm_year + 1900, cert->valid_from.tm_mon + 1,\r\ncert->valid_from.tm_mday, cert->valid_from.tm_hour,\r\ncert->valid_from.tm_min, cert->valid_from.tm_sec);\r\npr_devel("Cert Valid To: %04ld-%02d-%02d %02d:%02d:%02d\n",\r\ncert->valid_to.tm_year + 1900, cert->valid_to.tm_mon + 1,\r\ncert->valid_to.tm_mday, cert->valid_to.tm_hour,\r\ncert->valid_to.tm_min, cert->valid_to.tm_sec);\r\npr_devel("Cert Signature: %s + %s\n",\r\npkey_algo[cert->sig_pkey_algo],\r\npkey_hash_algo[cert->sig_hash_algo]);\r\nif (!cert->fingerprint || !cert->authority) {\r\npr_warn("Cert for '%s' must have SubjKeyId and AuthKeyId extensions\n",\r\ncert->subject);\r\nret = -EKEYREJECTED;\r\ngoto error_free_cert;\r\n}\r\ntime_to_tm(CURRENT_TIME.tv_sec, 0, &now);\r\npr_devel("Now: %04ld-%02d-%02d %02d:%02d:%02d\n",\r\nnow.tm_year + 1900, now.tm_mon + 1, now.tm_mday,\r\nnow.tm_hour, now.tm_min, now.tm_sec);\r\nif (now.tm_year < cert->valid_from.tm_year ||\r\n(now.tm_year == cert->valid_from.tm_year &&\r\n(now.tm_mon < cert->valid_from.tm_mon ||\r\n(now.tm_mon == cert->valid_from.tm_mon &&\r\n(now.tm_mday < cert->valid_from.tm_mday ||\r\n(now.tm_mday == cert->valid_from.tm_mday &&\r\n(now.tm_hour < cert->valid_from.tm_hour ||\r\n(now.tm_hour == cert->valid_from.tm_hour &&\r\n(now.tm_min < cert->valid_from.tm_min ||\r\n(now.tm_min == cert->valid_from.tm_min &&\r\n(now.tm_sec < cert->valid_from.tm_sec\r\n))))))))))) {\r\npr_warn("Cert %s is not yet valid\n", cert->fingerprint);\r\nret = -EKEYREJECTED;\r\ngoto error_free_cert;\r\n}\r\nif (now.tm_year > cert->valid_to.tm_year ||\r\n(now.tm_year == cert->valid_to.tm_year &&\r\n(now.tm_mon > cert->valid_to.tm_mon ||\r\n(now.tm_mon == cert->valid_to.tm_mon &&\r\n(now.tm_mday > cert->valid_to.tm_mday ||\r\n(now.tm_mday == cert->valid_to.tm_mday &&\r\n(now.tm_hour > cert->valid_to.tm_hour ||\r\n(now.tm_hour == cert->valid_to.tm_hour &&\r\n(now.tm_min > cert->valid_to.tm_min ||\r\n(now.tm_min == cert->valid_to.tm_min &&\r\n(now.tm_sec > cert->valid_to.tm_sec\r\n))))))))))) {\r\npr_warn("Cert %s has expired\n", cert->fingerprint);\r\nret = -EKEYEXPIRED;\r\ngoto error_free_cert;\r\n}\r\ncert->pub->algo = x509_public_key_algorithms[cert->pkey_algo];\r\ncert->pub->id_type = PKEY_ID_X509;\r\nif (strcmp(cert->fingerprint, cert->authority) == 0) {\r\nret = x509_check_signature(cert->pub, cert);\r\nif (ret < 0)\r\ngoto error_free_cert;\r\n}\r\nsulen = strlen(cert->subject);\r\nsrlen = strlen(cert->fingerprint);\r\nret = -ENOMEM;\r\ndesc = kmalloc(sulen + 2 + srlen + 1, GFP_KERNEL);\r\nif (!desc)\r\ngoto error_free_cert;\r\nmemcpy(desc, cert->subject, sulen);\r\ndesc[sulen] = ':';\r\ndesc[sulen + 1] = ' ';\r\nmemcpy(desc + sulen + 2, cert->fingerprint, srlen);\r\ndesc[sulen + 2 + srlen] = 0;\r\n__module_get(public_key_subtype.owner);\r\nprep->type_data[0] = &public_key_subtype;\r\nprep->type_data[1] = cert->fingerprint;\r\nprep->payload = cert->pub;\r\nprep->description = desc;\r\nprep->quotalen = 100;\r\ncert->pub = NULL;\r\ncert->fingerprint = NULL;\r\ndesc = NULL;\r\nret = 0;\r\nerror_free_cert:\r\nx509_free_certificate(cert);\r\nreturn ret;\r\n}\r\nstatic int __init x509_key_init(void)\r\n{\r\nreturn register_asymmetric_key_parser(&x509_key_parser);\r\n}\r\nstatic void __exit x509_key_exit(void)\r\n{\r\nunregister_asymmetric_key_parser(&x509_key_parser);\r\n}
