static acpi_status\r\nacpi_ex_setup_region(union acpi_operand_object *obj_desc,\r\nu32 field_datum_byte_offset)\r\n{\r\nacpi_status status = AE_OK;\r\nunion acpi_operand_object *rgn_desc;\r\nu8 space_id;\r\nACPI_FUNCTION_TRACE_U32(ex_setup_region, field_datum_byte_offset);\r\nrgn_desc = obj_desc->common_field.region_obj;\r\nif (rgn_desc->common.type != ACPI_TYPE_REGION) {\r\nACPI_ERROR((AE_INFO, "Needed Region, found type 0x%X (%s)",\r\nrgn_desc->common.type,\r\nacpi_ut_get_object_type_name(rgn_desc)));\r\nreturn_ACPI_STATUS(AE_AML_OPERAND_TYPE);\r\n}\r\nspace_id = rgn_desc->region.space_id;\r\nif (!acpi_is_valid_space_id(space_id)) {\r\nACPI_ERROR((AE_INFO,\r\n"Invalid/unknown Address Space ID: 0x%2.2X",\r\nspace_id));\r\nreturn_ACPI_STATUS(AE_AML_INVALID_SPACE_ID);\r\n}\r\nif (!(rgn_desc->common.flags & AOPOBJ_DATA_VALID)) {\r\nstatus = acpi_ds_get_region_arguments(rgn_desc);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nif (rgn_desc->common.flags & AOPOBJ_INVALID) {\r\nreturn_ACPI_STATUS(AE_AML_ILLEGAL_ADDRESS);\r\n}\r\nif (space_id == ACPI_ADR_SPACE_SMBUS ||\r\nspace_id == ACPI_ADR_SPACE_GSBUS ||\r\nspace_id == ACPI_ADR_SPACE_IPMI) {\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\n#ifdef ACPI_UNDER_DEVELOPMENT\r\nif (!(obj_desc->common.flags & AOPOBJ_DATA_VALID)) {\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\n#endif\r\nif (rgn_desc->region.length <\r\n(obj_desc->common_field.base_byte_offset + field_datum_byte_offset +\r\nobj_desc->common_field.access_byte_width)) {\r\nif (acpi_gbl_enable_interpreter_slack) {\r\nif (ACPI_ROUND_UP(rgn_desc->region.length,\r\nobj_desc->common_field.\r\naccess_byte_width) >=\r\n((acpi_size) obj_desc->common_field.\r\nbase_byte_offset +\r\nobj_desc->common_field.access_byte_width +\r\nfield_datum_byte_offset)) {\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\n}\r\nif (rgn_desc->region.length <\r\nobj_desc->common_field.access_byte_width) {\r\nACPI_ERROR((AE_INFO,\r\n"Field [%4.4s] access width (%u bytes) too large for region [%4.4s] (length %u)",\r\nacpi_ut_get_node_name(obj_desc->\r\ncommon_field.node),\r\nobj_desc->common_field.access_byte_width,\r\nacpi_ut_get_node_name(rgn_desc->region.\r\nnode),\r\nrgn_desc->region.length));\r\n}\r\nACPI_ERROR((AE_INFO,\r\n"Field [%4.4s] Base+Offset+Width %u+%u+%u is beyond end of region [%4.4s] (length %u)",\r\nacpi_ut_get_node_name(obj_desc->common_field.node),\r\nobj_desc->common_field.base_byte_offset,\r\nfield_datum_byte_offset,\r\nobj_desc->common_field.access_byte_width,\r\nacpi_ut_get_node_name(rgn_desc->region.node),\r\nrgn_desc->region.length));\r\nreturn_ACPI_STATUS(AE_AML_REGION_LIMIT);\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_ex_access_region(union acpi_operand_object *obj_desc,\r\nu32 field_datum_byte_offset, u64 *value, u32 function)\r\n{\r\nacpi_status status;\r\nunion acpi_operand_object *rgn_desc;\r\nu32 region_offset;\r\nACPI_FUNCTION_TRACE(ex_access_region);\r\nstatus = acpi_ex_setup_region(obj_desc, field_datum_byte_offset);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nrgn_desc = obj_desc->common_field.region_obj;\r\nregion_offset =\r\nobj_desc->common_field.base_byte_offset + field_datum_byte_offset;\r\nif ((function & ACPI_IO_MASK) == ACPI_READ) {\r\nACPI_DEBUG_PRINT((ACPI_DB_BFIELD, "[READ]"));\r\n} else {\r\nACPI_DEBUG_PRINT((ACPI_DB_BFIELD, "[WRITE]"));\r\n}\r\nACPI_DEBUG_PRINT_RAW((ACPI_DB_BFIELD,\r\n" Region [%s:%X], Width %X, ByteBase %X, Offset %X at %p\n",\r\nacpi_ut_get_region_name(rgn_desc->region.\r\nspace_id),\r\nrgn_desc->region.space_id,\r\nobj_desc->common_field.access_byte_width,\r\nobj_desc->common_field.base_byte_offset,\r\nfield_datum_byte_offset, ACPI_CAST_PTR(void,\r\n(rgn_desc->\r\nregion.\r\naddress +\r\nregion_offset))));\r\nstatus = acpi_ev_address_space_dispatch(rgn_desc, obj_desc,\r\nfunction, region_offset,\r\nACPI_MUL_8(obj_desc->\r\ncommon_field.\r\naccess_byte_width),\r\nvalue);\r\nif (ACPI_FAILURE(status)) {\r\nif (status == AE_NOT_IMPLEMENTED) {\r\nACPI_ERROR((AE_INFO,\r\n"Region %s (ID=%u) not implemented",\r\nacpi_ut_get_region_name(rgn_desc->region.\r\nspace_id),\r\nrgn_desc->region.space_id));\r\n} else if (status == AE_NOT_EXIST) {\r\nACPI_ERROR((AE_INFO,\r\n"Region %s (ID=%u) has no handler",\r\nacpi_ut_get_region_name(rgn_desc->region.\r\nspace_id),\r\nrgn_desc->region.space_id));\r\n}\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatic u8\r\nacpi_ex_register_overflow(union acpi_operand_object *obj_desc, u64 value)\r\n{\r\nif (obj_desc->common_field.bit_length >= ACPI_INTEGER_BIT_SIZE) {\r\nreturn (FALSE);\r\n}\r\nif (value >= ((u64) 1 << obj_desc->common_field.bit_length)) {\r\nACPI_ERROR((AE_INFO,\r\n"Index value 0x%8.8X%8.8X overflows field width 0x%X",\r\nACPI_FORMAT_UINT64(value),\r\nobj_desc->common_field.bit_length));\r\nreturn (TRUE);\r\n}\r\nreturn (FALSE);\r\n}\r\nstatic acpi_status\r\nacpi_ex_field_datum_io(union acpi_operand_object *obj_desc,\r\nu32 field_datum_byte_offset, u64 *value, u32 read_write)\r\n{\r\nacpi_status status;\r\nu64 local_value;\r\nACPI_FUNCTION_TRACE_U32(ex_field_datum_io, field_datum_byte_offset);\r\nif (read_write == ACPI_READ) {\r\nif (!value) {\r\nlocal_value = 0;\r\nvalue = &local_value;\r\n}\r\n*value = 0;\r\n}\r\nswitch (obj_desc->common.type) {\r\ncase ACPI_TYPE_BUFFER_FIELD:\r\nif (!(obj_desc->common.flags & AOPOBJ_DATA_VALID)) {\r\nstatus = acpi_ds_get_buffer_field_arguments(obj_desc);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nif (read_write == ACPI_READ) {\r\nACPI_MEMCPY(value,\r\n(obj_desc->buffer_field.buffer_obj)->buffer.\r\npointer +\r\nobj_desc->buffer_field.base_byte_offset +\r\nfield_datum_byte_offset,\r\nobj_desc->common_field.access_byte_width);\r\n} else {\r\nACPI_MEMCPY((obj_desc->buffer_field.buffer_obj)->buffer.\r\npointer +\r\nobj_desc->buffer_field.base_byte_offset +\r\nfield_datum_byte_offset, value,\r\nobj_desc->common_field.access_byte_width);\r\n}\r\nstatus = AE_OK;\r\nbreak;\r\ncase ACPI_TYPE_LOCAL_BANK_FIELD:\r\nif (acpi_ex_register_overflow(obj_desc->bank_field.bank_obj,\r\n(u64) obj_desc->bank_field.\r\nvalue)) {\r\nreturn_ACPI_STATUS(AE_AML_REGISTER_LIMIT);\r\n}\r\nstatus =\r\nacpi_ex_insert_into_field(obj_desc->bank_field.bank_obj,\r\n&obj_desc->bank_field.value,\r\nsizeof(obj_desc->bank_field.\r\nvalue));\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\ncase ACPI_TYPE_LOCAL_REGION_FIELD:\r\nstatus =\r\nacpi_ex_access_region(obj_desc, field_datum_byte_offset,\r\nvalue, read_write);\r\nbreak;\r\ncase ACPI_TYPE_LOCAL_INDEX_FIELD:\r\nif (acpi_ex_register_overflow(obj_desc->index_field.index_obj,\r\n(u64) obj_desc->index_field.\r\nvalue)) {\r\nreturn_ACPI_STATUS(AE_AML_REGISTER_LIMIT);\r\n}\r\nfield_datum_byte_offset += obj_desc->index_field.value;\r\nACPI_DEBUG_PRINT((ACPI_DB_BFIELD,\r\n"Write to Index Register: Value %8.8X\n",\r\nfield_datum_byte_offset));\r\nstatus =\r\nacpi_ex_insert_into_field(obj_desc->index_field.index_obj,\r\n&field_datum_byte_offset,\r\nsizeof(field_datum_byte_offset));\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (read_write == ACPI_READ) {\r\nACPI_DEBUG_PRINT((ACPI_DB_BFIELD,\r\n"Read from Data Register\n"));\r\nstatus =\r\nacpi_ex_extract_from_field(obj_desc->index_field.\r\ndata_obj, value,\r\nsizeof(u64));\r\n} else {\r\nACPI_DEBUG_PRINT((ACPI_DB_BFIELD,\r\n"Write to Data Register: Value %8.8X%8.8X\n",\r\nACPI_FORMAT_UINT64(*value)));\r\nstatus =\r\nacpi_ex_insert_into_field(obj_desc->index_field.\r\ndata_obj, value,\r\nsizeof(u64));\r\n}\r\nbreak;\r\ndefault:\r\nACPI_ERROR((AE_INFO, "Wrong object type in field I/O %u",\r\nobj_desc->common.type));\r\nstatus = AE_AML_INTERNAL;\r\nbreak;\r\n}\r\nif (ACPI_SUCCESS(status)) {\r\nif (read_write == ACPI_READ) {\r\nACPI_DEBUG_PRINT((ACPI_DB_BFIELD,\r\n"Value Read %8.8X%8.8X, Width %u\n",\r\nACPI_FORMAT_UINT64(*value),\r\nobj_desc->common_field.\r\naccess_byte_width));\r\n} else {\r\nACPI_DEBUG_PRINT((ACPI_DB_BFIELD,\r\n"Value Written %8.8X%8.8X, Width %u\n",\r\nACPI_FORMAT_UINT64(*value),\r\nobj_desc->common_field.\r\naccess_byte_width));\r\n}\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ex_write_with_update_rule(union acpi_operand_object *obj_desc,\r\nu64 mask,\r\nu64 field_value, u32 field_datum_byte_offset)\r\n{\r\nacpi_status status = AE_OK;\r\nu64 merged_value;\r\nu64 current_value;\r\nACPI_FUNCTION_TRACE_U32(ex_write_with_update_rule, mask);\r\nmerged_value = field_value;\r\nif (mask != ACPI_UINT64_MAX) {\r\nswitch (obj_desc->common_field.\r\nfield_flags & AML_FIELD_UPDATE_RULE_MASK) {\r\ncase AML_FIELD_UPDATE_PRESERVE:\r\nif ((~mask << (ACPI_MUL_8(sizeof(mask)) -\r\nACPI_MUL_8(obj_desc->common_field.\r\naccess_byte_width))) != 0) {\r\nstatus =\r\nacpi_ex_field_datum_io(obj_desc,\r\nfield_datum_byte_offset,\r\n&current_value,\r\nACPI_READ);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nmerged_value |= (current_value & ~mask);\r\n}\r\nbreak;\r\ncase AML_FIELD_UPDATE_WRITE_AS_ONES:\r\nmerged_value |= ~mask;\r\nbreak;\r\ncase AML_FIELD_UPDATE_WRITE_AS_ZEROS:\r\nmerged_value &= mask;\r\nbreak;\r\ndefault:\r\nACPI_ERROR((AE_INFO,\r\n"Unknown UpdateRule value: 0x%X",\r\n(obj_desc->common_field.\r\nfield_flags &\r\nAML_FIELD_UPDATE_RULE_MASK)));\r\nreturn_ACPI_STATUS(AE_AML_OPERAND_VALUE);\r\n}\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_BFIELD,\r\n"Mask %8.8X%8.8X, DatumOffset %X, Width %X, Value %8.8X%8.8X, MergedValue %8.8X%8.8X\n",\r\nACPI_FORMAT_UINT64(mask),\r\nfield_datum_byte_offset,\r\nobj_desc->common_field.access_byte_width,\r\nACPI_FORMAT_UINT64(field_value),\r\nACPI_FORMAT_UINT64(merged_value)));\r\nstatus = acpi_ex_field_datum_io(obj_desc, field_datum_byte_offset,\r\n&merged_value, ACPI_WRITE);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ex_extract_from_field(union acpi_operand_object *obj_desc,\r\nvoid *buffer, u32 buffer_length)\r\n{\r\nacpi_status status;\r\nu64 raw_datum;\r\nu64 merged_datum;\r\nu32 field_offset = 0;\r\nu32 buffer_offset = 0;\r\nu32 buffer_tail_bits;\r\nu32 datum_count;\r\nu32 field_datum_count;\r\nu32 access_bit_width;\r\nu32 i;\r\nACPI_FUNCTION_TRACE(ex_extract_from_field);\r\nif (buffer_length <\r\nACPI_ROUND_BITS_UP_TO_BYTES(obj_desc->common_field.bit_length)) {\r\nACPI_ERROR((AE_INFO,\r\n"Field size %u (bits) is too large for buffer (%u)",\r\nobj_desc->common_field.bit_length, buffer_length));\r\nreturn_ACPI_STATUS(AE_BUFFER_OVERFLOW);\r\n}\r\nACPI_MEMSET(buffer, 0, buffer_length);\r\naccess_bit_width = ACPI_MUL_8(obj_desc->common_field.access_byte_width);\r\nif ((obj_desc->common_field.start_field_bit_offset == 0) &&\r\n(obj_desc->common_field.bit_length == access_bit_width)) {\r\nif (buffer_length >= sizeof(u64)) {\r\nstatus =\r\nacpi_ex_field_datum_io(obj_desc, 0, buffer,\r\nACPI_READ);\r\n} else {\r\nstatus =\r\nacpi_ex_field_datum_io(obj_desc, 0, &raw_datum,\r\nACPI_READ);\r\nACPI_MEMCPY(buffer, &raw_datum, buffer_length);\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (obj_desc->common_field.access_byte_width > sizeof(u64)) {\r\nobj_desc->common_field.access_byte_width = sizeof(u64);\r\naccess_bit_width = sizeof(u64) * 8;\r\n}\r\ndatum_count =\r\nACPI_ROUND_UP_TO(obj_desc->common_field.bit_length,\r\naccess_bit_width);\r\nfield_datum_count = ACPI_ROUND_UP_TO(obj_desc->common_field.bit_length +\r\nobj_desc->common_field.\r\nstart_field_bit_offset,\r\naccess_bit_width);\r\nstatus =\r\nacpi_ex_field_datum_io(obj_desc, field_offset, &raw_datum,\r\nACPI_READ);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nmerged_datum =\r\nraw_datum >> obj_desc->common_field.start_field_bit_offset;\r\nfor (i = 1; i < field_datum_count; i++) {\r\nfield_offset += obj_desc->common_field.access_byte_width;\r\nstatus = acpi_ex_field_datum_io(obj_desc, field_offset,\r\n&raw_datum, ACPI_READ);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (access_bit_width -\r\nobj_desc->common_field.start_field_bit_offset <\r\nACPI_INTEGER_BIT_SIZE) {\r\nmerged_datum |=\r\nraw_datum << (access_bit_width -\r\nobj_desc->common_field.\r\nstart_field_bit_offset);\r\n}\r\nif (i == datum_count) {\r\nbreak;\r\n}\r\nACPI_MEMCPY(((char *)buffer) + buffer_offset, &merged_datum,\r\nACPI_MIN(obj_desc->common_field.access_byte_width,\r\nbuffer_length - buffer_offset));\r\nbuffer_offset += obj_desc->common_field.access_byte_width;\r\nmerged_datum =\r\nraw_datum >> obj_desc->common_field.start_field_bit_offset;\r\n}\r\nbuffer_tail_bits = obj_desc->common_field.bit_length % access_bit_width;\r\nif (buffer_tail_bits) {\r\nmerged_datum &= ACPI_MASK_BITS_ABOVE(buffer_tail_bits);\r\n}\r\nACPI_MEMCPY(((char *)buffer) + buffer_offset, &merged_datum,\r\nACPI_MIN(obj_desc->common_field.access_byte_width,\r\nbuffer_length - buffer_offset));\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_ex_insert_into_field(union acpi_operand_object *obj_desc,\r\nvoid *buffer, u32 buffer_length)\r\n{\r\nvoid *new_buffer;\r\nacpi_status status;\r\nu64 mask;\r\nu64 width_mask;\r\nu64 merged_datum;\r\nu64 raw_datum = 0;\r\nu32 field_offset = 0;\r\nu32 buffer_offset = 0;\r\nu32 buffer_tail_bits;\r\nu32 datum_count;\r\nu32 field_datum_count;\r\nu32 access_bit_width;\r\nu32 required_length;\r\nu32 i;\r\nACPI_FUNCTION_TRACE(ex_insert_into_field);\r\nnew_buffer = NULL;\r\nrequired_length =\r\nACPI_ROUND_BITS_UP_TO_BYTES(obj_desc->common_field.bit_length);\r\nif (buffer_length < required_length) {\r\nnew_buffer = ACPI_ALLOCATE_ZEROED(required_length);\r\nif (!new_buffer) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nACPI_MEMCPY((char *)new_buffer, (char *)buffer, buffer_length);\r\nbuffer = new_buffer;\r\nbuffer_length = required_length;\r\n}\r\nif (obj_desc->common_field.access_byte_width > sizeof(u64)) {\r\nobj_desc->common_field.access_byte_width = sizeof(u64);\r\n}\r\naccess_bit_width = ACPI_MUL_8(obj_desc->common_field.access_byte_width);\r\nif (access_bit_width == ACPI_INTEGER_BIT_SIZE) {\r\nwidth_mask = ACPI_UINT64_MAX;\r\n} else {\r\nwidth_mask = ACPI_MASK_BITS_ABOVE(access_bit_width);\r\n}\r\nmask = width_mask &\r\nACPI_MASK_BITS_BELOW(obj_desc->common_field.start_field_bit_offset);\r\ndatum_count = ACPI_ROUND_UP_TO(obj_desc->common_field.bit_length,\r\naccess_bit_width);\r\nfield_datum_count = ACPI_ROUND_UP_TO(obj_desc->common_field.bit_length +\r\nobj_desc->common_field.\r\nstart_field_bit_offset,\r\naccess_bit_width);\r\nACPI_MEMCPY(&raw_datum, buffer,\r\nACPI_MIN(obj_desc->common_field.access_byte_width,\r\nbuffer_length - buffer_offset));\r\nmerged_datum =\r\nraw_datum << obj_desc->common_field.start_field_bit_offset;\r\nfor (i = 1; i < field_datum_count; i++) {\r\nmerged_datum &= mask;\r\nstatus = acpi_ex_write_with_update_rule(obj_desc, mask,\r\nmerged_datum,\r\nfield_offset);\r\nif (ACPI_FAILURE(status)) {\r\ngoto exit;\r\n}\r\nfield_offset += obj_desc->common_field.access_byte_width;\r\nif ((access_bit_width -\r\nobj_desc->common_field.start_field_bit_offset) <\r\nACPI_INTEGER_BIT_SIZE) {\r\nmerged_datum =\r\nraw_datum >> (access_bit_width -\r\nobj_desc->common_field.\r\nstart_field_bit_offset);\r\n} else {\r\nmerged_datum = 0;\r\n}\r\nmask = width_mask;\r\nif (i == datum_count) {\r\nbreak;\r\n}\r\nbuffer_offset += obj_desc->common_field.access_byte_width;\r\nACPI_MEMCPY(&raw_datum, ((char *)buffer) + buffer_offset,\r\nACPI_MIN(obj_desc->common_field.access_byte_width,\r\nbuffer_length - buffer_offset));\r\nmerged_datum |=\r\nraw_datum << obj_desc->common_field.start_field_bit_offset;\r\n}\r\nbuffer_tail_bits = (obj_desc->common_field.bit_length +\r\nobj_desc->common_field.start_field_bit_offset) %\r\naccess_bit_width;\r\nif (buffer_tail_bits) {\r\nmask &= ACPI_MASK_BITS_ABOVE(buffer_tail_bits);\r\n}\r\nmerged_datum &= mask;\r\nstatus = acpi_ex_write_with_update_rule(obj_desc,\r\nmask, merged_datum,\r\nfield_offset);\r\nexit:\r\nif (new_buffer) {\r\nACPI_FREE(new_buffer);\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}
