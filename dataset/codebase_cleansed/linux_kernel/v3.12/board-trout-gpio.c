static int msm_gpiolib_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct msm_gpio_chip *msm_gpio = to_msm_gpio_chip(chip);\r\nunsigned mask = 1 << offset;\r\nreturn !!(readb(msm_gpio->reg) & mask);\r\n}\r\nstatic void msm_gpiolib_set(struct gpio_chip *chip, unsigned offset, int val)\r\n{\r\nstruct msm_gpio_chip *msm_gpio = to_msm_gpio_chip(chip);\r\nunsigned mask = 1 << offset;\r\nif (val)\r\nmsm_gpio->shadow |= mask;\r\nelse\r\nmsm_gpio->shadow &= ~mask;\r\nwriteb(msm_gpio->shadow, msm_gpio->reg);\r\n}\r\nstatic int msm_gpiolib_direction_input(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nmsm_gpiolib_set(chip, offset, 0);\r\nreturn 0;\r\n}\r\nstatic int msm_gpiolib_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int val)\r\n{\r\nmsm_gpiolib_set(chip, offset, val);\r\nreturn 0;\r\n}\r\nstatic int trout_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn TROUT_GPIO_TO_INT(offset + chip->base);\r\n}\r\nstatic void trout_gpio_irq_ack(struct irq_data *d)\r\n{\r\nint bank = TROUT_INT_TO_BANK(d->irq);\r\nuint8_t mask = TROUT_INT_TO_MASK(d->irq);\r\nint reg = TROUT_BANK_TO_STAT_REG(bank);\r\nwriteb(mask, TROUT_CPLD_BASE + reg);\r\n}\r\nstatic void trout_gpio_irq_mask(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nuint8_t reg_val;\r\nint bank = TROUT_INT_TO_BANK(d->irq);\r\nuint8_t mask = TROUT_INT_TO_MASK(d->irq);\r\nint reg = TROUT_BANK_TO_MASK_REG(bank);\r\nlocal_irq_save(flags);\r\nreg_val = trout_int_mask[bank] |= mask;\r\nwriteb(reg_val, TROUT_CPLD_BASE + reg);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void trout_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nuint8_t reg_val;\r\nint bank = TROUT_INT_TO_BANK(d->irq);\r\nuint8_t mask = TROUT_INT_TO_MASK(d->irq);\r\nint reg = TROUT_BANK_TO_MASK_REG(bank);\r\nlocal_irq_save(flags);\r\nreg_val = trout_int_mask[bank] &= ~mask;\r\nwriteb(reg_val, TROUT_CPLD_BASE + reg);\r\nlocal_irq_restore(flags);\r\n}\r\nint trout_gpio_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nunsigned long flags;\r\nint bank = TROUT_INT_TO_BANK(d->irq);\r\nuint8_t mask = TROUT_INT_TO_MASK(d->irq);\r\nlocal_irq_save(flags);\r\nif(on)\r\ntrout_sleep_int_mask[bank] &= ~mask;\r\nelse\r\ntrout_sleep_int_mask[bank] |= mask;\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic void trout_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nint j, m;\r\nunsigned v;\r\nint bank;\r\nint stat_reg;\r\nint int_base = TROUT_INT_START;\r\nuint8_t int_mask;\r\nfor (bank = 0; bank < 2; bank++) {\r\nstat_reg = TROUT_BANK_TO_STAT_REG(bank);\r\nv = readb(TROUT_CPLD_BASE + stat_reg);\r\nint_mask = trout_int_mask[bank];\r\nif (v & int_mask) {\r\nwriteb(v & int_mask, TROUT_CPLD_BASE + stat_reg);\r\nprintk(KERN_ERR "trout_gpio_irq_handler: got masked "\r\n"interrupt: %d:%02x\n", bank, v & int_mask);\r\n}\r\nv &= ~int_mask;\r\nwhile (v) {\r\nm = v & -v;\r\nj = fls(m) - 1;\r\nv &= ~m;\r\ngeneric_handle_irq(int_base + j);\r\n}\r\nint_base += TROUT_INT_BANK0_COUNT;\r\n}\r\ndesc->irq_data.chip->irq_ack(&desc->irq_data);\r\n}\r\nint __init trout_init_gpio(void)\r\n{\r\nint i;\r\nfor(i = TROUT_INT_START; i <= TROUT_INT_END; i++) {\r\nirq_set_chip_and_handler(i, &trout_gpio_irq_chip,\r\nhandle_edge_irq);\r\nset_irq_flags(i, IRQF_VALID);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(msm_gpio_banks); i++)\r\ngpiochip_add(&msm_gpio_banks[i].chip);\r\nirq_set_irq_type(MSM_GPIO_TO_INT(17), IRQF_TRIGGER_HIGH);\r\nirq_set_chained_handler(MSM_GPIO_TO_INT(17), trout_gpio_irq_handler);\r\nirq_set_irq_wake(MSM_GPIO_TO_INT(17), 1);\r\nreturn 0;\r\n}
