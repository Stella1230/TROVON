struct afs_volume *afs_volume_lookup(struct afs_mount_params *params)\r\n{\r\nstruct afs_vlocation *vlocation = NULL;\r\nstruct afs_volume *volume = NULL;\r\nstruct afs_server *server = NULL;\r\nchar srvtmask;\r\nint ret, loop;\r\n_enter("{%*.*s,%d}",\r\nparams->volnamesz, params->volnamesz, params->volname, params->rwpath);\r\nvlocation = afs_vlocation_lookup(params->cell, params->key,\r\nparams->volname, params->volnamesz);\r\nif (IS_ERR(vlocation)) {\r\nret = PTR_ERR(vlocation);\r\nvlocation = NULL;\r\ngoto error;\r\n}\r\nret = -ENOMEDIUM;\r\nif (params->force && !(vlocation->vldb.vidmask & (1 << params->type)))\r\ngoto error;\r\nsrvtmask = 0;\r\nfor (loop = 0; loop < vlocation->vldb.nservers; loop++)\r\nsrvtmask |= vlocation->vldb.srvtmask[loop];\r\nif (params->force) {\r\nif (!(srvtmask & (1 << params->type)))\r\ngoto error;\r\n} else if (srvtmask & AFS_VOL_VTM_RO) {\r\nparams->type = AFSVL_ROVOL;\r\n} else if (srvtmask & AFS_VOL_VTM_RW) {\r\nparams->type = AFSVL_RWVOL;\r\n} else {\r\ngoto error;\r\n}\r\ndown_write(&params->cell->vl_sem);\r\nif (vlocation->vols[params->type]) {\r\nvolume = vlocation->vols[params->type];\r\nafs_get_volume(volume);\r\ngoto success;\r\n}\r\n_debug("creating new volume record");\r\nret = -ENOMEM;\r\nvolume = kzalloc(sizeof(struct afs_volume), GFP_KERNEL);\r\nif (!volume)\r\ngoto error_up;\r\natomic_set(&volume->usage, 1);\r\nvolume->type = params->type;\r\nvolume->type_force = params->force;\r\nvolume->cell = params->cell;\r\nvolume->vid = vlocation->vldb.vid[params->type];\r\nret = bdi_setup_and_register(&volume->bdi, "afs", BDI_CAP_MAP_COPY);\r\nif (ret)\r\ngoto error_bdi;\r\ninit_rwsem(&volume->server_sem);\r\nfor (loop = 0; loop < 8; loop++) {\r\nif (vlocation->vldb.srvtmask[loop] & (1 << volume->type)) {\r\nserver = afs_lookup_server(\r\nvolume->cell, &vlocation->vldb.servers[loop]);\r\nif (IS_ERR(server)) {\r\nret = PTR_ERR(server);\r\ngoto error_discard;\r\n}\r\nvolume->servers[volume->nservers] = server;\r\nvolume->nservers++;\r\n}\r\n}\r\n#ifdef CONFIG_AFS_FSCACHE\r\nvolume->cache = fscache_acquire_cookie(vlocation->cache,\r\n&afs_volume_cache_index_def,\r\nvolume);\r\n#endif\r\nafs_get_vlocation(vlocation);\r\nvolume->vlocation = vlocation;\r\nvlocation->vols[volume->type] = volume;\r\nsuccess:\r\n_debug("kAFS selected %s volume %08x",\r\nafs_voltypes[volume->type], volume->vid);\r\nup_write(&params->cell->vl_sem);\r\nafs_put_vlocation(vlocation);\r\n_leave(" = %p", volume);\r\nreturn volume;\r\nerror_up:\r\nup_write(&params->cell->vl_sem);\r\nerror:\r\nafs_put_vlocation(vlocation);\r\n_leave(" = %d", ret);\r\nreturn ERR_PTR(ret);\r\nerror_discard:\r\nbdi_destroy(&volume->bdi);\r\nerror_bdi:\r\nup_write(&params->cell->vl_sem);\r\nfor (loop = volume->nservers - 1; loop >= 0; loop--)\r\nafs_put_server(volume->servers[loop]);\r\nkfree(volume);\r\ngoto error;\r\n}\r\nvoid afs_put_volume(struct afs_volume *volume)\r\n{\r\nstruct afs_vlocation *vlocation;\r\nint loop;\r\nif (!volume)\r\nreturn;\r\n_enter("%p", volume);\r\nASSERTCMP(atomic_read(&volume->usage), >, 0);\r\nvlocation = volume->vlocation;\r\ndown_write(&vlocation->cell->vl_sem);\r\nif (likely(!atomic_dec_and_test(&volume->usage))) {\r\nup_write(&vlocation->cell->vl_sem);\r\n_leave("");\r\nreturn;\r\n}\r\nvlocation->vols[volume->type] = NULL;\r\nup_write(&vlocation->cell->vl_sem);\r\n#ifdef CONFIG_AFS_FSCACHE\r\nfscache_relinquish_cookie(volume->cache, 0);\r\n#endif\r\nafs_put_vlocation(vlocation);\r\nfor (loop = volume->nservers - 1; loop >= 0; loop--)\r\nafs_put_server(volume->servers[loop]);\r\nbdi_destroy(&volume->bdi);\r\nkfree(volume);\r\n_leave(" [destroyed]");\r\n}\r\nstruct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\r\n{\r\nstruct afs_volume *volume = vnode->volume;\r\nstruct afs_server *server;\r\nint ret, state, loop;\r\n_enter("%s", volume->vlocation->vldb.name);\r\nif (vnode->server && vnode->server->fs_state == 0) {\r\nafs_get_server(vnode->server);\r\n_leave(" = %p [current]", vnode->server);\r\nreturn vnode->server;\r\n}\r\ndown_read(&volume->server_sem);\r\nif (volume->nservers == 0) {\r\nret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\r\nup_read(&volume->server_sem);\r\n_leave(" = %d [no servers]", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nret = 0;\r\nfor (loop = 0; loop < volume->nservers; loop++) {\r\nserver = volume->servers[loop];\r\nstate = server->fs_state;\r\n_debug("consider %d [%d]", loop, state);\r\nswitch (state) {\r\ncase 0:\r\nafs_get_server(server);\r\nup_read(&volume->server_sem);\r\n_leave(" = %p (picked %08x)",\r\nserver, ntohl(server->addr.s_addr));\r\nreturn server;\r\ncase -ENETUNREACH:\r\nif (ret == 0)\r\nret = state;\r\nbreak;\r\ncase -EHOSTUNREACH:\r\nif (ret == 0 ||\r\nret == -ENETUNREACH)\r\nret = state;\r\nbreak;\r\ncase -ECONNREFUSED:\r\nif (ret == 0 ||\r\nret == -ENETUNREACH ||\r\nret == -EHOSTUNREACH)\r\nret = state;\r\nbreak;\r\ndefault:\r\ncase -EREMOTEIO:\r\nif (ret == 0 ||\r\nret == -ENETUNREACH ||\r\nret == -EHOSTUNREACH ||\r\nret == -ECONNREFUSED)\r\nret = state;\r\nbreak;\r\n}\r\n}\r\nup_read(&volume->server_sem);\r\n_leave(" = %d", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nint afs_volume_release_fileserver(struct afs_vnode *vnode,\r\nstruct afs_server *server,\r\nint result)\r\n{\r\nstruct afs_volume *volume = vnode->volume;\r\nunsigned loop;\r\n_enter("%s,%08x,%d",\r\nvolume->vlocation->vldb.name, ntohl(server->addr.s_addr),\r\nresult);\r\nswitch (result) {\r\ncase 0:\r\nserver->fs_act_jif = jiffies;\r\nserver->fs_state = 0;\r\n_leave("");\r\nreturn 1;\r\ncase -ENOMEDIUM:\r\nserver->fs_act_jif = jiffies;\r\ndown_write(&volume->server_sem);\r\nfor (loop = 0; loop < volume->nservers; loop++)\r\nif (volume->servers[loop] == server)\r\ngoto present;\r\ngoto try_next_server_upw;\r\npresent:\r\nvolume->nservers--;\r\nmemmove(&volume->servers[loop],\r\n&volume->servers[loop + 1],\r\nsizeof(volume->servers[loop]) *\r\n(volume->nservers - loop));\r\nvolume->servers[volume->nservers] = NULL;\r\nafs_put_server(server);\r\nvolume->rjservers++;\r\nif (volume->nservers > 0)\r\ngoto try_next_server_upw;\r\nup_write(&volume->server_sem);\r\nafs_put_server(server);\r\n_leave(" [completely rejected]");\r\nreturn 1;\r\ncase -ENETUNREACH:\r\ncase -EHOSTUNREACH:\r\ncase -ECONNREFUSED:\r\ncase -ETIME:\r\ncase -ETIMEDOUT:\r\ncase -EREMOTEIO:\r\nspin_lock(&server->fs_lock);\r\nif (!server->fs_state) {\r\nserver->fs_dead_jif = jiffies + HZ * 10;\r\nserver->fs_state = result;\r\nprintk("kAFS: SERVER DEAD state=%d\n", result);\r\n}\r\nspin_unlock(&server->fs_lock);\r\ngoto try_next_server;\r\ndefault:\r\nserver->fs_act_jif = jiffies;\r\ncase -ENOMEM:\r\ncase -ENONET:\r\nafs_put_server(server);\r\n_leave(" [local failure]");\r\nreturn 1;\r\n}\r\ntry_next_server_upw:\r\nup_write(&volume->server_sem);\r\ntry_next_server:\r\nafs_put_server(server);\r\n_leave(" [try next server]");\r\nreturn 0;\r\n}
