bool ROUTEbRelay(PSDevice pDevice, unsigned char *pbySkbData, unsigned int uDataLen, unsigned int uNodeIndex)\r\n{\r\nPSMgmtObject pMgmt = pDevice->pMgmt;\r\nPSTxDesc pHeadTD, pLastTD;\r\nunsigned int cbFrameBodySize;\r\nunsigned int uMACfragNum;\r\nunsigned char byPktType;\r\nbool bNeedEncryption = false;\r\nSKeyItem STempKey;\r\nPSKeyItem pTransmitKey = NULL;\r\nunsigned int cbHeaderSize;\r\nunsigned int ii;\r\nunsigned char *pbyBSSID;\r\nif (AVAIL_TD(pDevice, TYPE_AC0DMA) <= 0) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Relay can't allocate TD1..\n");\r\nreturn false;\r\n}\r\npHeadTD = pDevice->apCurrTD[TYPE_AC0DMA];\r\npHeadTD->m_td1TD1.byTCR = (TCR_EDP | TCR_STP);\r\nmemcpy(pDevice->sTxEthHeader.abyDstAddr, (unsigned char *)pbySkbData, ETH_HLEN);\r\ncbFrameBodySize = uDataLen - ETH_HLEN;\r\nif (ntohs(pDevice->sTxEthHeader.wType) > ETH_DATA_LEN) {\r\ncbFrameBodySize += 8;\r\n}\r\nif (pDevice->bEncryptionEnable == true) {\r\nbNeedEncryption = true;\r\npbyBSSID = pDevice->abyBroadcastAddr;\r\nif (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == false) {\r\npTransmitKey = NULL;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG "Get GTK.\n");\r\n}\r\n}\r\nif (pDevice->bEnableHostWEP) {\r\nif (uNodeIndex < MAX_NODE_NUM + 1) {\r\npTransmitKey = &STempKey;\r\npTransmitKey->byCipherSuite = pMgmt->sNodeDBTable[uNodeIndex].byCipherSuite;\r\npTransmitKey->dwKeyIndex = pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex;\r\npTransmitKey->uKeyLength = pMgmt->sNodeDBTable[uNodeIndex].uWepKeyLength;\r\npTransmitKey->dwTSC47_16 = pMgmt->sNodeDBTable[uNodeIndex].dwTSC47_16;\r\npTransmitKey->wTSC15_0 = pMgmt->sNodeDBTable[uNodeIndex].wTSC15_0;\r\nmemcpy(pTransmitKey->abyKey,\r\n&pMgmt->sNodeDBTable[uNodeIndex].abyWepKey[0],\r\npTransmitKey->uKeyLength\r\n);\r\n}\r\n}\r\nuMACfragNum = cbGetFragCount(pDevice, pTransmitKey, cbFrameBodySize, &pDevice->sTxEthHeader);\r\nif (uMACfragNum > AVAIL_TD(pDevice, TYPE_AC0DMA)) {\r\nreturn false;\r\n}\r\nbyPktType = (unsigned char)pDevice->byPacketType;\r\nif (pDevice->bFixRate) {\r\nif (pDevice->eCurrentPHYType == PHY_TYPE_11B) {\r\nif (pDevice->uConnectionRate >= RATE_11M) {\r\npDevice->wCurrentRate = RATE_11M;\r\n} else {\r\npDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;\r\n}\r\n} else {\r\nif ((pDevice->eCurrentPHYType == PHY_TYPE_11A) &&\r\n(pDevice->uConnectionRate <= RATE_6M)) {\r\npDevice->wCurrentRate = RATE_6M;\r\n} else {\r\nif (pDevice->uConnectionRate >= RATE_54M)\r\npDevice->wCurrentRate = RATE_54M;\r\nelse\r\npDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;\r\n}\r\n}\r\n} else {\r\npDevice->wCurrentRate = pDevice->pMgmt->sNodeDBTable[uNodeIndex].wTxDataRate;\r\n}\r\nif (pDevice->wCurrentRate <= RATE_11M)\r\nbyPktType = PK_TYPE_11B;\r\nvGenerateFIFOHeader(pDevice, byPktType, pDevice->pbyTmpBuff, bNeedEncryption,\r\ncbFrameBodySize, TYPE_AC0DMA, pHeadTD,\r\n&pDevice->sTxEthHeader, pbySkbData, pTransmitKey, uNodeIndex,\r\n&uMACfragNum,\r\n&cbHeaderSize\r\n);\r\nif (MACbIsRegBitsOn(pDevice->PortOffset, MAC_REG_PSCTL, PSCTL_PS)) {\r\nMACbPSWakeup(pDevice->PortOffset);\r\n}\r\npDevice->bPWBitOn = false;\r\npLastTD = pHeadTD;\r\nfor (ii = 0; ii < uMACfragNum; ii++) {\r\nwmb();\r\npHeadTD->m_td0TD0.f1Owner = OWNED_BY_NIC;\r\nwmb();\r\nif (ii == (uMACfragNum - 1))\r\npLastTD = pHeadTD;\r\npHeadTD = pHeadTD->next;\r\n}\r\npLastTD->pTDInfo->skb = 0;\r\npLastTD->pTDInfo->byFlags = 0;\r\npDevice->apCurrTD[TYPE_AC0DMA] = pHeadTD;\r\nMACvTransmitAC0(pDevice->PortOffset);\r\nreturn true;\r\n}
