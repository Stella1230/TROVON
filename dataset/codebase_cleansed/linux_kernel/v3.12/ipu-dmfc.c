int ipu_dmfc_enable_channel(struct dmfc_channel *dmfc)\r\n{\r\nstruct ipu_dmfc_priv *priv = dmfc->priv;\r\nmutex_lock(&priv->mutex);\r\nif (!priv->use_count)\r\nipu_module_enable(priv->ipu, IPU_CONF_DMFC_EN);\r\npriv->use_count++;\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nvoid ipu_dmfc_disable_channel(struct dmfc_channel *dmfc)\r\n{\r\nstruct ipu_dmfc_priv *priv = dmfc->priv;\r\nmutex_lock(&priv->mutex);\r\npriv->use_count--;\r\nif (!priv->use_count)\r\nipu_module_disable(priv->ipu, IPU_CONF_DMFC_EN);\r\nif (priv->use_count < 0)\r\npriv->use_count = 0;\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int ipu_dmfc_setup_channel(struct dmfc_channel *dmfc, int slots,\r\nint segment, int burstsize)\r\n{\r\nstruct ipu_dmfc_priv *priv = dmfc->priv;\r\nu32 val, field;\r\ndev_dbg(priv->dev,\r\n"dmfc: using %d slots starting from segment %d for IPU channel %d\n",\r\nslots, segment, dmfc->data->ipu_channel);\r\nif (!dmfc)\r\nreturn -EINVAL;\r\nswitch (slots) {\r\ncase 1:\r\nfield = DMFC_FIFO_SIZE_64;\r\nbreak;\r\ncase 2:\r\nfield = DMFC_FIFO_SIZE_128;\r\nbreak;\r\ncase 4:\r\nfield = DMFC_FIFO_SIZE_256;\r\nbreak;\r\ncase 8:\r\nfield = DMFC_FIFO_SIZE_512;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (burstsize) {\r\ncase 16:\r\nfield |= DMFC_BURSTSIZE_16;\r\nbreak;\r\ncase 32:\r\nfield |= DMFC_BURSTSIZE_32;\r\nbreak;\r\ncase 64:\r\nfield |= DMFC_BURSTSIZE_64;\r\nbreak;\r\ncase 128:\r\nfield |= DMFC_BURSTSIZE_128;\r\nbreak;\r\n}\r\nfield |= DMFC_SEGMENT(segment);\r\nval = readl(priv->base + dmfc->data->channel_reg);\r\nval &= ~(0xff << dmfc->data->shift);\r\nval |= field << dmfc->data->shift;\r\nwritel(val, priv->base + dmfc->data->channel_reg);\r\ndmfc->slots = slots;\r\ndmfc->segment = segment;\r\ndmfc->burstsize = burstsize;\r\ndmfc->slotmask = ((1 << slots) - 1) << segment;\r\nreturn 0;\r\n}\r\nstatic int dmfc_bandwidth_to_slots(struct ipu_dmfc_priv *priv,\r\nunsigned long bandwidth)\r\n{\r\nint slots = 1;\r\nwhile (slots * priv->bandwidth_per_slot < bandwidth)\r\nslots *= 2;\r\nreturn slots;\r\n}\r\nstatic int dmfc_find_slots(struct ipu_dmfc_priv *priv, int slots)\r\n{\r\nunsigned slotmask_need, slotmask_used = 0;\r\nint i, segment = 0;\r\nslotmask_need = (1 << slots) - 1;\r\nfor (i = 0; i < DMFC_NUM_CHANNELS; i++)\r\nslotmask_used |= priv->channels[i].slotmask;\r\nwhile (slotmask_need <= 0xff) {\r\nif (!(slotmask_used & slotmask_need))\r\nreturn segment;\r\nslotmask_need <<= 1;\r\nsegment++;\r\n}\r\nreturn -EBUSY;\r\n}\r\nvoid ipu_dmfc_free_bandwidth(struct dmfc_channel *dmfc)\r\n{\r\nstruct ipu_dmfc_priv *priv = dmfc->priv;\r\nint i;\r\ndev_dbg(priv->dev, "dmfc: freeing %d slots starting from segment %d\n",\r\ndmfc->slots, dmfc->segment);\r\nmutex_lock(&priv->mutex);\r\nif (!dmfc->slots)\r\ngoto out;\r\ndmfc->slotmask = 0;\r\ndmfc->slots = 0;\r\ndmfc->segment = 0;\r\nfor (i = 0; i < DMFC_NUM_CHANNELS; i++)\r\npriv->channels[i].slotmask = 0;\r\nfor (i = 0; i < DMFC_NUM_CHANNELS; i++) {\r\nif (priv->channels[i].slots > 0) {\r\npriv->channels[i].segment =\r\ndmfc_find_slots(priv, priv->channels[i].slots);\r\npriv->channels[i].slotmask =\r\n((1 << priv->channels[i].slots) - 1) <<\r\npriv->channels[i].segment;\r\n}\r\n}\r\nfor (i = 0; i < DMFC_NUM_CHANNELS; i++) {\r\nif (priv->channels[i].slots > 0)\r\nipu_dmfc_setup_channel(&priv->channels[i],\r\npriv->channels[i].slots,\r\npriv->channels[i].segment,\r\npriv->channels[i].burstsize);\r\n}\r\nout:\r\nmutex_unlock(&priv->mutex);\r\n}\r\nint ipu_dmfc_alloc_bandwidth(struct dmfc_channel *dmfc,\r\nunsigned long bandwidth_pixel_per_second, int burstsize)\r\n{\r\nstruct ipu_dmfc_priv *priv = dmfc->priv;\r\nint slots = dmfc_bandwidth_to_slots(priv, bandwidth_pixel_per_second);\r\nint segment = -1, ret = 0;\r\ndev_dbg(priv->dev, "dmfc: trying to allocate %ldMpixel/s for IPU channel %d\n",\r\nbandwidth_pixel_per_second / 1000000,\r\ndmfc->data->ipu_channel);\r\nipu_dmfc_free_bandwidth(dmfc);\r\nmutex_lock(&priv->mutex);\r\nif (slots > 8) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (slots < 2)\r\nslots = 2;\r\nif (dmfc->data->ipu_channel == IPUV3_CHANNEL_MEM_BG_SYNC)\r\nsegment = dmfc_find_slots(priv, slots * 2);\r\nif (segment >= 0)\r\nslots *= 2;\r\nelse\r\nsegment = dmfc_find_slots(priv, slots);\r\nif (segment < 0) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nipu_dmfc_setup_channel(dmfc, slots, segment, burstsize);\r\nout:\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nint ipu_dmfc_init_channel(struct dmfc_channel *dmfc, int width)\r\n{\r\nstruct ipu_dmfc_priv *priv = dmfc->priv;\r\nu32 dmfc_gen1;\r\ndmfc_gen1 = readl(priv->base + DMFC_GENERAL1);\r\nif ((dmfc->slots * 64 * 4) / width > dmfc->data->max_fifo_lines)\r\ndmfc_gen1 |= 1 << dmfc->data->eot_shift;\r\nelse\r\ndmfc_gen1 &= ~(1 << dmfc->data->eot_shift);\r\nwritel(dmfc_gen1, priv->base + DMFC_GENERAL1);\r\nreturn 0;\r\n}\r\nstruct dmfc_channel *ipu_dmfc_get(struct ipu_soc *ipu, int ipu_channel)\r\n{\r\nstruct ipu_dmfc_priv *priv = ipu->dmfc_priv;\r\nint i;\r\nfor (i = 0; i < DMFC_NUM_CHANNELS; i++)\r\nif (dmfcdata[i].ipu_channel == ipu_channel)\r\nreturn &priv->channels[i];\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nvoid ipu_dmfc_put(struct dmfc_channel *dmfc)\r\n{\r\nipu_dmfc_free_bandwidth(dmfc);\r\n}\r\nint ipu_dmfc_init(struct ipu_soc *ipu, struct device *dev, unsigned long base,\r\nstruct clk *ipu_clk)\r\n{\r\nstruct ipu_dmfc_priv *priv;\r\nint i;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->base = devm_ioremap(dev, base, PAGE_SIZE);\r\nif (!priv->base)\r\nreturn -ENOMEM;\r\npriv->dev = dev;\r\npriv->ipu = ipu;\r\nmutex_init(&priv->mutex);\r\nipu->dmfc_priv = priv;\r\nfor (i = 0; i < DMFC_NUM_CHANNELS; i++) {\r\npriv->channels[i].priv = priv;\r\npriv->channels[i].ipu = ipu;\r\npriv->channels[i].data = &dmfcdata[i];\r\n}\r\nwritel(0x0, priv->base + DMFC_WR_CHAN);\r\nwritel(0x0, priv->base + DMFC_DP_CHAN);\r\npriv->bandwidth_per_slot = clk_get_rate(ipu_clk) * 4 / 8;\r\ndev_dbg(dev, "dmfc: 8 slots with %ldMpixel/s bandwidth each\n",\r\npriv->bandwidth_per_slot / 1000000);\r\nwritel(0x202020f6, priv->base + DMFC_WR_CHAN_DEF);\r\nwritel(0x2020f6f6, priv->base + DMFC_DP_CHAN_DEF);\r\nwritel(0x00000003, priv->base + DMFC_GENERAL1);\r\nreturn 0;\r\n}\r\nvoid ipu_dmfc_exit(struct ipu_soc *ipu)\r\n{\r\n}
