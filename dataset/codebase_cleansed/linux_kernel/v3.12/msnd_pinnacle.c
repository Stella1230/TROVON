static void set_default_audio_parameters(struct snd_msnd *chip)\r\n{\r\nchip->play_sample_size = DEFSAMPLESIZE;\r\nchip->play_sample_rate = DEFSAMPLERATE;\r\nchip->play_channels = DEFCHANNELS;\r\nchip->capture_sample_size = DEFSAMPLESIZE;\r\nchip->capture_sample_rate = DEFSAMPLERATE;\r\nchip->capture_channels = DEFCHANNELS;\r\n}\r\nstatic void snd_msnd_eval_dsp_msg(struct snd_msnd *chip, u16 wMessage)\r\n{\r\nswitch (HIBYTE(wMessage)) {\r\ncase HIMT_PLAY_DONE: {\r\nif (chip->banksPlayed < 3)\r\nsnd_printdd("%08X: HIMT_PLAY_DONE: %i\n",\r\n(unsigned)jiffies, LOBYTE(wMessage));\r\nif (chip->last_playbank == LOBYTE(wMessage)) {\r\nsnd_printdd("chip.last_playbank == LOBYTE(wMessage)\n");\r\nbreak;\r\n}\r\nchip->banksPlayed++;\r\nif (test_bit(F_WRITING, &chip->flags))\r\nsnd_msnd_DAPQ(chip, 0);\r\nchip->last_playbank = LOBYTE(wMessage);\r\nchip->playDMAPos += chip->play_period_bytes;\r\nif (chip->playDMAPos > chip->playLimit)\r\nchip->playDMAPos = 0;\r\nsnd_pcm_period_elapsed(chip->playback_substream);\r\nbreak;\r\n}\r\ncase HIMT_RECORD_DONE:\r\nif (chip->last_recbank == LOBYTE(wMessage))\r\nbreak;\r\nchip->last_recbank = LOBYTE(wMessage);\r\nchip->captureDMAPos += chip->capturePeriodBytes;\r\nif (chip->captureDMAPos > (chip->captureLimit))\r\nchip->captureDMAPos = 0;\r\nif (test_bit(F_READING, &chip->flags))\r\nsnd_msnd_DARQ(chip, chip->last_recbank);\r\nsnd_pcm_period_elapsed(chip->capture_substream);\r\nbreak;\r\ncase HIMT_DSP:\r\nswitch (LOBYTE(wMessage)) {\r\n#ifndef MSND_CLASSIC\r\ncase HIDSP_PLAY_UNDER:\r\n#endif\r\ncase HIDSP_INT_PLAY_UNDER:\r\nsnd_printd(KERN_WARNING LOGNAME ": Play underflow %i\n",\r\nchip->banksPlayed);\r\nif (chip->banksPlayed > 2)\r\nclear_bit(F_WRITING, &chip->flags);\r\nbreak;\r\ncase HIDSP_INT_RECORD_OVER:\r\nsnd_printd(KERN_WARNING LOGNAME ": Record overflow\n");\r\nclear_bit(F_READING, &chip->flags);\r\nbreak;\r\ndefault:\r\nsnd_printd(KERN_WARNING LOGNAME\r\n": DSP message %d 0x%02x\n",\r\nLOBYTE(wMessage), LOBYTE(wMessage));\r\nbreak;\r\n}\r\nbreak;\r\ncase HIMT_MIDI_IN_UCHAR:\r\nif (chip->msndmidi_mpu)\r\nsnd_msndmidi_input_read(chip->msndmidi_mpu);\r\nbreak;\r\ndefault:\r\nsnd_printd(KERN_WARNING LOGNAME ": HIMT message %d 0x%02x\n",\r\nHIBYTE(wMessage), HIBYTE(wMessage));\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t snd_msnd_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_msnd *chip = dev_id;\r\nvoid *pwDSPQData = chip->mappedbase + DSPQ_DATA_BUFF;\r\nwhile (readw(chip->DSPQ + JQS_wTail) != readw(chip->DSPQ + JQS_wHead)) {\r\nu16 wTmp;\r\nsnd_msnd_eval_dsp_msg(chip,\r\nreadw(pwDSPQData + 2 * readw(chip->DSPQ + JQS_wHead)));\r\nwTmp = readw(chip->DSPQ + JQS_wHead) + 1;\r\nif (wTmp > readw(chip->DSPQ + JQS_wSize))\r\nwritew(0, chip->DSPQ + JQS_wHead);\r\nelse\r\nwritew(wTmp, chip->DSPQ + JQS_wHead);\r\n}\r\ninb(chip->io + HP_RXL);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int snd_msnd_reset_dsp(long io, unsigned char *info)\r\n{\r\nint timeout = 100;\r\noutb(HPDSPRESET_ON, io + HP_DSPR);\r\nmsleep(1);\r\n#ifndef MSND_CLASSIC\r\nif (info)\r\n*info = inb(io + HP_INFO);\r\n#endif\r\noutb(HPDSPRESET_OFF, io + HP_DSPR);\r\nmsleep(1);\r\nwhile (timeout-- > 0) {\r\nif (inb(io + HP_CVR) == HP_CVR_DEF)\r\nreturn 0;\r\nmsleep(1);\r\n}\r\nsnd_printk(KERN_ERR LOGNAME ": Cannot reset DSP\n");\r\nreturn -EIO;\r\n}\r\nstatic int snd_msnd_probe(struct snd_card *card)\r\n{\r\nstruct snd_msnd *chip = card->private_data;\r\nunsigned char info;\r\n#ifndef MSND_CLASSIC\r\nchar *xv, *rev = NULL;\r\nchar *pin = "TB Pinnacle", *fiji = "TB Fiji";\r\nchar *pinfiji = "TB Pinnacle/Fiji";\r\n#endif\r\nif (!request_region(chip->io, DSP_NUMIO, "probing")) {\r\nsnd_printk(KERN_ERR LOGNAME ": I/O port conflict\n");\r\nreturn -ENODEV;\r\n}\r\nif (snd_msnd_reset_dsp(chip->io, &info) < 0) {\r\nrelease_region(chip->io, DSP_NUMIO);\r\nreturn -ENODEV;\r\n}\r\n#ifdef MSND_CLASSIC\r\nstrcpy(card->shortname, "Classic/Tahiti/Monterey");\r\nstrcpy(card->longname, "Turtle Beach Multisound");\r\nprintk(KERN_INFO LOGNAME ": %s, "\r\n"I/O 0x%lx-0x%lx, IRQ %d, memory mapped to 0x%lX-0x%lX\n",\r\ncard->shortname,\r\nchip->io, chip->io + DSP_NUMIO - 1,\r\nchip->irq,\r\nchip->base, chip->base + 0x7fff);\r\n#else\r\nswitch (info >> 4) {\r\ncase 0xf:\r\nxv = "<= 1.15";\r\nbreak;\r\ncase 0x1:\r\nxv = "1.18/1.2";\r\nbreak;\r\ncase 0x2:\r\nxv = "1.3";\r\nbreak;\r\ncase 0x3:\r\nxv = "1.4";\r\nbreak;\r\ndefault:\r\nxv = "unknown";\r\nbreak;\r\n}\r\nswitch (info & 0x7) {\r\ncase 0x0:\r\nrev = "I";\r\nstrcpy(card->shortname, pin);\r\nbreak;\r\ncase 0x1:\r\nrev = "F";\r\nstrcpy(card->shortname, pin);\r\nbreak;\r\ncase 0x2:\r\nrev = "G";\r\nstrcpy(card->shortname, pin);\r\nbreak;\r\ncase 0x3:\r\nrev = "H";\r\nstrcpy(card->shortname, pin);\r\nbreak;\r\ncase 0x4:\r\nrev = "E";\r\nstrcpy(card->shortname, fiji);\r\nbreak;\r\ncase 0x5:\r\nrev = "C";\r\nstrcpy(card->shortname, fiji);\r\nbreak;\r\ncase 0x6:\r\nrev = "D";\r\nstrcpy(card->shortname, fiji);\r\nbreak;\r\ncase 0x7:\r\nrev = "A-B (Fiji) or A-E (Pinnacle)";\r\nstrcpy(card->shortname, pinfiji);\r\nbreak;\r\n}\r\nstrcpy(card->longname, "Turtle Beach Multisound Pinnacle");\r\nprintk(KERN_INFO LOGNAME ": %s revision %s, Xilinx version %s, "\r\n"I/O 0x%lx-0x%lx, IRQ %d, memory mapped to 0x%lX-0x%lX\n",\r\ncard->shortname,\r\nrev, xv,\r\nchip->io, chip->io + DSP_NUMIO - 1,\r\nchip->irq,\r\nchip->base, chip->base + 0x7fff);\r\n#endif\r\nrelease_region(chip->io, DSP_NUMIO);\r\nreturn 0;\r\n}\r\nstatic int snd_msnd_init_sma(struct snd_msnd *chip)\r\n{\r\nstatic int initted;\r\nu16 mastVolLeft, mastVolRight;\r\nunsigned long flags;\r\n#ifdef MSND_CLASSIC\r\noutb(chip->memid, chip->io + HP_MEMM);\r\n#endif\r\noutb(HPBLKSEL_0, chip->io + HP_BLKS);\r\nchip->SMA = chip->mappedbase + SMA_STRUCT_START;\r\nif (initted) {\r\nmastVolLeft = readw(chip->SMA + SMA_wCurrMastVolLeft);\r\nmastVolRight = readw(chip->SMA + SMA_wCurrMastVolRight);\r\n} else\r\nmastVolLeft = mastVolRight = 0;\r\nmemset_io(chip->mappedbase, 0, 0x8000);\r\nspin_lock_irqsave(&chip->lock, flags);\r\noutb(HPBLKSEL_1, chip->io + HP_BLKS);\r\nmemset_io(chip->mappedbase, 0, 0x8000);\r\noutb(HPBLKSEL_0, chip->io + HP_BLKS);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nchip->DAPQ = chip->mappedbase + DAPQ_OFFSET;\r\nsnd_msnd_init_queue(chip->DAPQ, DAPQ_DATA_BUFF, DAPQ_BUFF_SIZE);\r\nchip->DARQ = chip->mappedbase + DARQ_OFFSET;\r\nsnd_msnd_init_queue(chip->DARQ, DARQ_DATA_BUFF, DARQ_BUFF_SIZE);\r\nchip->MODQ = chip->mappedbase + MODQ_OFFSET;\r\nsnd_msnd_init_queue(chip->MODQ, MODQ_DATA_BUFF, MODQ_BUFF_SIZE);\r\nchip->MIDQ = chip->mappedbase + MIDQ_OFFSET;\r\nsnd_msnd_init_queue(chip->MIDQ, MIDQ_DATA_BUFF, MIDQ_BUFF_SIZE);\r\nchip->DSPQ = chip->mappedbase + DSPQ_OFFSET;\r\nsnd_msnd_init_queue(chip->DSPQ, DSPQ_DATA_BUFF, DSPQ_BUFF_SIZE);\r\n#ifndef MSND_CLASSIC\r\nwritew(1, chip->SMA + SMA_wCurrPlayFormat);\r\nwritew(chip->play_sample_size, chip->SMA + SMA_wCurrPlaySampleSize);\r\nwritew(chip->play_channels, chip->SMA + SMA_wCurrPlayChannels);\r\nwritew(chip->play_sample_rate, chip->SMA + SMA_wCurrPlaySampleRate);\r\n#endif\r\nwritew(chip->play_sample_rate, chip->SMA + SMA_wCalFreqAtoD);\r\nwritew(mastVolLeft, chip->SMA + SMA_wCurrMastVolLeft);\r\nwritew(mastVolRight, chip->SMA + SMA_wCurrMastVolRight);\r\n#ifndef MSND_CLASSIC\r\nwritel(0x00010000, chip->SMA + SMA_dwCurrPlayPitch);\r\nwritel(0x00000001, chip->SMA + SMA_dwCurrPlayRate);\r\n#endif\r\nwritew(0x303, chip->SMA + SMA_wCurrInputTagBits);\r\ninitted = 1;\r\nreturn 0;\r\n}\r\nstatic int upload_dsp_code(struct snd_card *card)\r\n{\r\nstruct snd_msnd *chip = card->private_data;\r\nconst struct firmware *init_fw = NULL, *perm_fw = NULL;\r\nint err;\r\noutb(HPBLKSEL_0, chip->io + HP_BLKS);\r\nerr = request_firmware(&init_fw, INITCODEFILE, card->dev);\r\nif (err < 0) {\r\nprintk(KERN_ERR LOGNAME ": Error loading " INITCODEFILE);\r\ngoto cleanup1;\r\n}\r\nerr = request_firmware(&perm_fw, PERMCODEFILE, card->dev);\r\nif (err < 0) {\r\nprintk(KERN_ERR LOGNAME ": Error loading " PERMCODEFILE);\r\ngoto cleanup;\r\n}\r\nmemcpy_toio(chip->mappedbase, perm_fw->data, perm_fw->size);\r\nif (snd_msnd_upload_host(chip, init_fw->data, init_fw->size) < 0) {\r\nprintk(KERN_WARNING LOGNAME ": Error uploading to DSP\n");\r\nerr = -ENODEV;\r\ngoto cleanup;\r\n}\r\nprintk(KERN_INFO LOGNAME ": DSP firmware uploaded\n");\r\nerr = 0;\r\ncleanup:\r\nrelease_firmware(perm_fw);\r\ncleanup1:\r\nrelease_firmware(init_fw);\r\nreturn err;\r\n}\r\nstatic void reset_proteus(struct snd_msnd *chip)\r\n{\r\noutb(HPPRORESET_ON, chip->io + HP_PROR);\r\nmsleep(TIME_PRO_RESET);\r\noutb(HPPRORESET_OFF, chip->io + HP_PROR);\r\nmsleep(TIME_PRO_RESET_DONE);\r\n}\r\nstatic int snd_msnd_initialize(struct snd_card *card)\r\n{\r\nstruct snd_msnd *chip = card->private_data;\r\nint err, timeout;\r\n#ifdef MSND_CLASSIC\r\noutb(HPWAITSTATE_0, chip->io + HP_WAIT);\r\noutb(HPBITMODE_16, chip->io + HP_BITM);\r\nreset_proteus(chip);\r\n#endif\r\nerr = snd_msnd_init_sma(chip);\r\nif (err < 0) {\r\nprintk(KERN_WARNING LOGNAME ": Cannot initialize SMA\n");\r\nreturn err;\r\n}\r\nerr = snd_msnd_reset_dsp(chip->io, NULL);\r\nif (err < 0)\r\nreturn err;\r\nerr = upload_dsp_code(card);\r\nif (err < 0) {\r\nprintk(KERN_WARNING LOGNAME ": Cannot upload DSP code\n");\r\nreturn err;\r\n}\r\ntimeout = 200;\r\nwhile (readw(chip->mappedbase)) {\r\nmsleep(1);\r\nif (!timeout--) {\r\nsnd_printd(KERN_ERR LOGNAME ": DSP reset timeout\n");\r\nreturn -EIO;\r\n}\r\n}\r\nsnd_msndmix_setup(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_msnd_dsp_full_reset(struct snd_card *card)\r\n{\r\nstruct snd_msnd *chip = card->private_data;\r\nint rv;\r\nif (test_bit(F_RESETTING, &chip->flags) || ++chip->nresets > 10)\r\nreturn 0;\r\nset_bit(F_RESETTING, &chip->flags);\r\nsnd_msnd_dsp_halt(chip, NULL);\r\nrv = snd_msnd_initialize(card);\r\nif (rv)\r\nprintk(KERN_WARNING LOGNAME ": DSP reset failed\n");\r\nsnd_msndmix_force_recsrc(chip, 0);\r\nclear_bit(F_RESETTING, &chip->flags);\r\nreturn rv;\r\n}\r\nstatic int snd_msnd_dev_free(struct snd_device *device)\r\n{\r\nsnd_printdd("snd_msnd_chip_free()\n");\r\nreturn 0;\r\n}\r\nstatic int snd_msnd_send_dsp_cmd_chk(struct snd_msnd *chip, u8 cmd)\r\n{\r\nif (snd_msnd_send_dsp_cmd(chip, cmd) == 0)\r\nreturn 0;\r\nsnd_msnd_dsp_full_reset(chip->card);\r\nreturn snd_msnd_send_dsp_cmd(chip, cmd);\r\n}\r\nstatic int snd_msnd_calibrate_adc(struct snd_msnd *chip, u16 srate)\r\n{\r\nsnd_printdd("snd_msnd_calibrate_adc(%i)\n", srate);\r\nwritew(srate, chip->SMA + SMA_wCalFreqAtoD);\r\nif (chip->calibrate_signal == 0)\r\nwritew(readw(chip->SMA + SMA_wCurrHostStatusFlags)\r\n| 0x0001, chip->SMA + SMA_wCurrHostStatusFlags);\r\nelse\r\nwritew(readw(chip->SMA + SMA_wCurrHostStatusFlags)\r\n& ~0x0001, chip->SMA + SMA_wCurrHostStatusFlags);\r\nif (snd_msnd_send_word(chip, 0, 0, HDEXAR_CAL_A_TO_D) == 0 &&\r\nsnd_msnd_send_dsp_cmd_chk(chip, HDEX_AUX_REQ) == 0) {\r\nschedule_timeout_interruptible(msecs_to_jiffies(333));\r\nreturn 0;\r\n}\r\nprintk(KERN_WARNING LOGNAME ": ADC calibration failed\n");\r\nreturn -EIO;\r\n}\r\nstatic int snd_msnd_mpu401_open(struct snd_mpu401 *mpu)\r\n{\r\nsnd_msnd_enable_irq(mpu->private_data);\r\nsnd_msnd_send_dsp_cmd(mpu->private_data, HDEX_MIDI_IN_START);\r\nreturn 0;\r\n}\r\nstatic void snd_msnd_mpu401_close(struct snd_mpu401 *mpu)\r\n{\r\nsnd_msnd_send_dsp_cmd(mpu->private_data, HDEX_MIDI_IN_STOP);\r\nsnd_msnd_disable_irq(mpu->private_data);\r\n}\r\nstatic int snd_msnd_attach(struct snd_card *card)\r\n{\r\nstruct snd_msnd *chip = card->private_data;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_msnd_dev_free,\r\n};\r\nerr = request_irq(chip->irq, snd_msnd_interrupt, 0, card->shortname,\r\nchip);\r\nif (err < 0) {\r\nprintk(KERN_ERR LOGNAME ": Couldn't grab IRQ %d\n", chip->irq);\r\nreturn err;\r\n}\r\nif (request_region(chip->io, DSP_NUMIO, card->shortname) == NULL) {\r\nfree_irq(chip->irq, chip);\r\nreturn -EBUSY;\r\n}\r\nif (!request_mem_region(chip->base, BUFFSIZE, card->shortname)) {\r\nprintk(KERN_ERR LOGNAME\r\n": unable to grab memory region 0x%lx-0x%lx\n",\r\nchip->base, chip->base + BUFFSIZE - 1);\r\nrelease_region(chip->io, DSP_NUMIO);\r\nfree_irq(chip->irq, chip);\r\nreturn -EBUSY;\r\n}\r\nchip->mappedbase = ioremap_nocache(chip->base, 0x8000);\r\nif (!chip->mappedbase) {\r\nprintk(KERN_ERR LOGNAME\r\n": unable to map memory region 0x%lx-0x%lx\n",\r\nchip->base, chip->base + BUFFSIZE - 1);\r\nerr = -EIO;\r\ngoto err_release_region;\r\n}\r\nerr = snd_msnd_dsp_full_reset(card);\r\nif (err < 0)\r\ngoto err_release_region;\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\r\nif (err < 0)\r\ngoto err_release_region;\r\nerr = snd_msnd_pcm(card, 0, NULL);\r\nif (err < 0) {\r\nprintk(KERN_ERR LOGNAME ": error creating new PCM device\n");\r\ngoto err_release_region;\r\n}\r\nerr = snd_msndmix_new(card);\r\nif (err < 0) {\r\nprintk(KERN_ERR LOGNAME ": error creating new Mixer device\n");\r\ngoto err_release_region;\r\n}\r\nif (mpu_io[0] != SNDRV_AUTO_PORT) {\r\nstruct snd_mpu401 *mpu;\r\nerr = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,\r\nmpu_io[0],\r\nMPU401_MODE_INPUT |\r\nMPU401_MODE_OUTPUT,\r\nmpu_irq[0],\r\n&chip->rmidi);\r\nif (err < 0) {\r\nprintk(KERN_ERR LOGNAME\r\n": error creating new Midi device\n");\r\ngoto err_release_region;\r\n}\r\nmpu = chip->rmidi->private_data;\r\nmpu->open_input = snd_msnd_mpu401_open;\r\nmpu->close_input = snd_msnd_mpu401_close;\r\nmpu->private_data = chip;\r\n}\r\ndisable_irq(chip->irq);\r\nsnd_msnd_calibrate_adc(chip, chip->play_sample_rate);\r\nsnd_msndmix_force_recsrc(chip, 0);\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto err_release_region;\r\nreturn 0;\r\nerr_release_region:\r\nif (chip->mappedbase)\r\niounmap(chip->mappedbase);\r\nrelease_mem_region(chip->base, BUFFSIZE);\r\nrelease_region(chip->io, DSP_NUMIO);\r\nfree_irq(chip->irq, chip);\r\nreturn err;\r\n}\r\nstatic void snd_msnd_unload(struct snd_card *card)\r\n{\r\nstruct snd_msnd *chip = card->private_data;\r\niounmap(chip->mappedbase);\r\nrelease_mem_region(chip->base, BUFFSIZE);\r\nrelease_region(chip->io, DSP_NUMIO);\r\nfree_irq(chip->irq, chip);\r\nsnd_card_free(card);\r\n}\r\nstatic int snd_msnd_write_cfg(int cfg, int reg, int value)\r\n{\r\noutb(reg, cfg);\r\noutb(value, cfg + 1);\r\nif (value != inb(cfg + 1)) {\r\nprintk(KERN_ERR LOGNAME ": snd_msnd_write_cfg: I/O error\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_msnd_write_cfg_io0(int cfg, int num, u16 io)\r\n{\r\nif (snd_msnd_write_cfg(cfg, IREG_LOGDEVICE, num))\r\nreturn -EIO;\r\nif (snd_msnd_write_cfg(cfg, IREG_IO0_BASEHI, HIBYTE(io)))\r\nreturn -EIO;\r\nif (snd_msnd_write_cfg(cfg, IREG_IO0_BASELO, LOBYTE(io)))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int snd_msnd_write_cfg_io1(int cfg, int num, u16 io)\r\n{\r\nif (snd_msnd_write_cfg(cfg, IREG_LOGDEVICE, num))\r\nreturn -EIO;\r\nif (snd_msnd_write_cfg(cfg, IREG_IO1_BASEHI, HIBYTE(io)))\r\nreturn -EIO;\r\nif (snd_msnd_write_cfg(cfg, IREG_IO1_BASELO, LOBYTE(io)))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int snd_msnd_write_cfg_irq(int cfg, int num, u16 irq)\r\n{\r\nif (snd_msnd_write_cfg(cfg, IREG_LOGDEVICE, num))\r\nreturn -EIO;\r\nif (snd_msnd_write_cfg(cfg, IREG_IRQ_NUMBER, LOBYTE(irq)))\r\nreturn -EIO;\r\nif (snd_msnd_write_cfg(cfg, IREG_IRQ_TYPE, IRQTYPE_EDGE))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int snd_msnd_write_cfg_mem(int cfg, int num, int mem)\r\n{\r\nu16 wmem;\r\nmem >>= 8;\r\nwmem = (u16)(mem & 0xfff);\r\nif (snd_msnd_write_cfg(cfg, IREG_LOGDEVICE, num))\r\nreturn -EIO;\r\nif (snd_msnd_write_cfg(cfg, IREG_MEMBASEHI, HIBYTE(wmem)))\r\nreturn -EIO;\r\nif (snd_msnd_write_cfg(cfg, IREG_MEMBASELO, LOBYTE(wmem)))\r\nreturn -EIO;\r\nif (wmem && snd_msnd_write_cfg(cfg, IREG_MEMCONTROL,\r\nMEMTYPE_HIADDR | MEMTYPE_16BIT))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int snd_msnd_activate_logical(int cfg, int num)\r\n{\r\nif (snd_msnd_write_cfg(cfg, IREG_LOGDEVICE, num))\r\nreturn -EIO;\r\nif (snd_msnd_write_cfg(cfg, IREG_ACTIVATE, LD_ACTIVATE))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int snd_msnd_write_cfg_logical(int cfg, int num, u16 io0,\r\nu16 io1, u16 irq, int mem)\r\n{\r\nif (snd_msnd_write_cfg(cfg, IREG_LOGDEVICE, num))\r\nreturn -EIO;\r\nif (snd_msnd_write_cfg_io0(cfg, num, io0))\r\nreturn -EIO;\r\nif (snd_msnd_write_cfg_io1(cfg, num, io1))\r\nreturn -EIO;\r\nif (snd_msnd_write_cfg_irq(cfg, num, irq))\r\nreturn -EIO;\r\nif (snd_msnd_write_cfg_mem(cfg, num, mem))\r\nreturn -EIO;\r\nif (snd_msnd_activate_logical(cfg, num))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int snd_msnd_pinnacle_cfg_reset(int cfg)\r\n{\r\nint i;\r\nprintk(KERN_INFO LOGNAME ": Resetting all devices\n");\r\nfor (i = 0; i < 4; ++i)\r\nif (snd_msnd_write_cfg_logical(cfg, i, 0, 0, 0, 0))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int snd_msnd_isa_match(struct device *pdev, unsigned int i)\r\n{\r\nif (io[i] == SNDRV_AUTO_PORT)\r\nreturn 0;\r\nif (irq[i] == SNDRV_AUTO_PORT || mem[i] == SNDRV_AUTO_PORT) {\r\nprintk(KERN_WARNING LOGNAME ": io, irq and mem must be set\n");\r\nreturn 0;\r\n}\r\n#ifdef MSND_CLASSIC\r\nif (!(io[i] == 0x290 ||\r\nio[i] == 0x260 ||\r\nio[i] == 0x250 ||\r\nio[i] == 0x240 ||\r\nio[i] == 0x230 ||\r\nio[i] == 0x220 ||\r\nio[i] == 0x210 ||\r\nio[i] == 0x3e0)) {\r\nprintk(KERN_ERR LOGNAME ": \"io\" - DSP I/O base must be set "\r\n" to 0x210, 0x220, 0x230, 0x240, 0x250, 0x260, 0x290, "\r\n"or 0x3E0\n");\r\nreturn 0;\r\n}\r\n#else\r\nif (io[i] < 0x100 || io[i] > 0x3e0 || (io[i] % 0x10) != 0) {\r\nprintk(KERN_ERR LOGNAME\r\n": \"io\" - DSP I/O base must within the range 0x100 "\r\n"to 0x3E0 and must be evenly divisible by 0x10\n");\r\nreturn 0;\r\n}\r\n#endif\r\nif (!(irq[i] == 5 ||\r\nirq[i] == 7 ||\r\nirq[i] == 9 ||\r\nirq[i] == 10 ||\r\nirq[i] == 11 ||\r\nirq[i] == 12)) {\r\nprintk(KERN_ERR LOGNAME\r\n": \"irq\" - must be set to 5, 7, 9, 10, 11 or 12\n");\r\nreturn 0;\r\n}\r\nif (!(mem[i] == 0xb0000 ||\r\nmem[i] == 0xc8000 ||\r\nmem[i] == 0xd0000 ||\r\nmem[i] == 0xd8000 ||\r\nmem[i] == 0xe0000 ||\r\nmem[i] == 0xe8000)) {\r\nprintk(KERN_ERR LOGNAME ": \"mem\" - must be set to "\r\n"0xb0000, 0xc8000, 0xd0000, 0xd8000, 0xe0000 or "\r\n"0xe8000\n");\r\nreturn 0;\r\n}\r\n#ifndef MSND_CLASSIC\r\nif (cfg[i] == SNDRV_AUTO_PORT) {\r\nprintk(KERN_INFO LOGNAME ": Assuming PnP mode\n");\r\n} else if (cfg[i] != 0x250 && cfg[i] != 0x260 && cfg[i] != 0x270) {\r\nprintk(KERN_INFO LOGNAME\r\n": Config port must be 0x250, 0x260 or 0x270 "\r\n"(or unspecified for PnP mode)\n");\r\nreturn 0;\r\n}\r\n#endif\r\nreturn 1;\r\n}\r\nstatic int snd_msnd_isa_probe(struct device *pdev, unsigned int idx)\r\n{\r\nint err;\r\nstruct snd_card *card;\r\nstruct snd_msnd *chip;\r\nif (has_isapnp(idx)\r\n#ifndef MSND_CLASSIC\r\n|| cfg[idx] == SNDRV_AUTO_PORT\r\n#endif\r\n) {\r\nprintk(KERN_INFO LOGNAME ": Assuming PnP mode\n");\r\nreturn -ENODEV;\r\n}\r\nerr = snd_card_create(index[idx], id[idx], THIS_MODULE,\r\nsizeof(struct snd_msnd), &card);\r\nif (err < 0)\r\nreturn err;\r\nsnd_card_set_dev(card, pdev);\r\nchip = card->private_data;\r\nchip->card = card;\r\n#ifdef MSND_CLASSIC\r\nswitch (irq[idx]) {\r\ncase 5:\r\nchip->irqid = HPIRQ_5; break;\r\ncase 7:\r\nchip->irqid = HPIRQ_7; break;\r\ncase 9:\r\nchip->irqid = HPIRQ_9; break;\r\ncase 10:\r\nchip->irqid = HPIRQ_10; break;\r\ncase 11:\r\nchip->irqid = HPIRQ_11; break;\r\ncase 12:\r\nchip->irqid = HPIRQ_12; break;\r\n}\r\nswitch (mem[idx]) {\r\ncase 0xb0000:\r\nchip->memid = HPMEM_B000; break;\r\ncase 0xc8000:\r\nchip->memid = HPMEM_C800; break;\r\ncase 0xd0000:\r\nchip->memid = HPMEM_D000; break;\r\ncase 0xd8000:\r\nchip->memid = HPMEM_D800; break;\r\ncase 0xe0000:\r\nchip->memid = HPMEM_E000; break;\r\ncase 0xe8000:\r\nchip->memid = HPMEM_E800; break;\r\n}\r\n#else\r\nprintk(KERN_INFO LOGNAME ": Non-PnP mode: configuring at port 0x%lx\n",\r\ncfg[idx]);\r\nif (!request_region(cfg[idx], 2, "Pinnacle/Fiji Config")) {\r\nprintk(KERN_ERR LOGNAME ": Config port 0x%lx conflict\n",\r\ncfg[idx]);\r\nsnd_card_free(card);\r\nreturn -EIO;\r\n}\r\nif (reset[idx])\r\nif (snd_msnd_pinnacle_cfg_reset(cfg[idx])) {\r\nerr = -EIO;\r\ngoto cfg_error;\r\n}\r\nerr = snd_msnd_write_cfg_logical(cfg[idx], 0,\r\nio[idx], 0,\r\nirq[idx], mem[idx]);\r\nif (err)\r\ngoto cfg_error;\r\nif (mpu_io[idx] != SNDRV_AUTO_PORT\r\n&& mpu_irq[idx] != SNDRV_AUTO_IRQ) {\r\nprintk(KERN_INFO LOGNAME\r\n": Configuring MPU to I/O 0x%lx IRQ %d\n",\r\nmpu_io[idx], mpu_irq[idx]);\r\nerr = snd_msnd_write_cfg_logical(cfg[idx], 1,\r\nmpu_io[idx], 0,\r\nmpu_irq[idx], 0);\r\nif (err)\r\ngoto cfg_error;\r\n}\r\nif (ide_io0[idx] != SNDRV_AUTO_PORT\r\n&& ide_io1[idx] != SNDRV_AUTO_PORT\r\n&& ide_irq[idx] != SNDRV_AUTO_IRQ) {\r\nprintk(KERN_INFO LOGNAME\r\n": Configuring IDE to I/O 0x%lx, 0x%lx IRQ %d\n",\r\nide_io0[idx], ide_io1[idx], ide_irq[idx]);\r\nerr = snd_msnd_write_cfg_logical(cfg[idx], 2,\r\nide_io0[idx], ide_io1[idx],\r\nide_irq[idx], 0);\r\nif (err)\r\ngoto cfg_error;\r\n}\r\nif (joystick_io[idx] != SNDRV_AUTO_PORT) {\r\nprintk(KERN_INFO LOGNAME\r\n": Configuring joystick to I/O 0x%lx\n",\r\njoystick_io[idx]);\r\nerr = snd_msnd_write_cfg_logical(cfg[idx], 3,\r\njoystick_io[idx], 0,\r\n0, 0);\r\nif (err)\r\ngoto cfg_error;\r\n}\r\nrelease_region(cfg[idx], 2);\r\n#endif\r\nset_default_audio_parameters(chip);\r\n#ifdef MSND_CLASSIC\r\nchip->type = msndClassic;\r\n#else\r\nchip->type = msndPinnacle;\r\n#endif\r\nchip->io = io[idx];\r\nchip->irq = irq[idx];\r\nchip->base = mem[idx];\r\nchip->calibrate_signal = calibrate_signal ? 1 : 0;\r\nchip->recsrc = 0;\r\nchip->dspq_data_buff = DSPQ_DATA_BUFF;\r\nchip->dspq_buff_size = DSPQ_BUFF_SIZE;\r\nif (write_ndelay[idx])\r\nclear_bit(F_DISABLE_WRITE_NDELAY, &chip->flags);\r\nelse\r\nset_bit(F_DISABLE_WRITE_NDELAY, &chip->flags);\r\n#ifndef MSND_CLASSIC\r\nif (digital[idx])\r\nset_bit(F_HAVEDIGITAL, &chip->flags);\r\n#endif\r\nspin_lock_init(&chip->lock);\r\nerr = snd_msnd_probe(card);\r\nif (err < 0) {\r\nprintk(KERN_ERR LOGNAME ": Probe failed\n");\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nerr = snd_msnd_attach(card);\r\nif (err < 0) {\r\nprintk(KERN_ERR LOGNAME ": Attach failed\n");\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\ndev_set_drvdata(pdev, card);\r\nreturn 0;\r\n#ifndef MSND_CLASSIC\r\ncfg_error:\r\nrelease_region(cfg[idx], 2);\r\nsnd_card_free(card);\r\nreturn err;\r\n#endif\r\n}\r\nstatic int snd_msnd_isa_remove(struct device *pdev, unsigned int dev)\r\n{\r\nsnd_msnd_unload(dev_get_drvdata(pdev));\r\nreturn 0;\r\n}\r\nstatic int snd_msnd_pnp_detect(struct pnp_card_link *pcard,\r\nconst struct pnp_card_device_id *pid)\r\n{\r\nstatic int idx;\r\nstruct pnp_dev *pnp_dev;\r\nstruct pnp_dev *mpu_dev;\r\nstruct snd_card *card;\r\nstruct snd_msnd *chip;\r\nint ret;\r\nfor ( ; idx < SNDRV_CARDS; idx++) {\r\nif (has_isapnp(idx))\r\nbreak;\r\n}\r\nif (idx >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\npnp_dev = pnp_request_card_device(pcard, pid->devs[0].id, NULL);\r\nif (!pnp_dev)\r\nreturn -ENODEV;\r\nmpu_dev = pnp_request_card_device(pcard, pid->devs[1].id, NULL);\r\nif (!mpu_dev)\r\nreturn -ENODEV;\r\nif (!pnp_is_active(pnp_dev) && pnp_activate_dev(pnp_dev) < 0) {\r\nprintk(KERN_INFO "msnd_pinnacle: device is inactive\n");\r\nreturn -EBUSY;\r\n}\r\nif (!pnp_is_active(mpu_dev) && pnp_activate_dev(mpu_dev) < 0) {\r\nprintk(KERN_INFO "msnd_pinnacle: MPU device is inactive\n");\r\nreturn -EBUSY;\r\n}\r\nret = snd_card_create(index[idx], id[idx], THIS_MODULE,\r\nsizeof(struct snd_msnd), &card);\r\nif (ret < 0)\r\nreturn ret;\r\nchip = card->private_data;\r\nchip->card = card;\r\nsnd_card_set_dev(card, &pcard->card->dev);\r\nio[idx] = pnp_port_start(pnp_dev, 0);\r\nirq[idx] = pnp_irq(pnp_dev, 0);\r\nmem[idx] = pnp_mem_start(pnp_dev, 0);\r\nmpu_io[idx] = pnp_port_start(mpu_dev, 0);\r\nmpu_irq[idx] = pnp_irq(mpu_dev, 0);\r\nset_default_audio_parameters(chip);\r\n#ifdef MSND_CLASSIC\r\nchip->type = msndClassic;\r\n#else\r\nchip->type = msndPinnacle;\r\n#endif\r\nchip->io = io[idx];\r\nchip->irq = irq[idx];\r\nchip->base = mem[idx];\r\nchip->calibrate_signal = calibrate_signal ? 1 : 0;\r\nchip->recsrc = 0;\r\nchip->dspq_data_buff = DSPQ_DATA_BUFF;\r\nchip->dspq_buff_size = DSPQ_BUFF_SIZE;\r\nif (write_ndelay[idx])\r\nclear_bit(F_DISABLE_WRITE_NDELAY, &chip->flags);\r\nelse\r\nset_bit(F_DISABLE_WRITE_NDELAY, &chip->flags);\r\n#ifndef MSND_CLASSIC\r\nif (digital[idx])\r\nset_bit(F_HAVEDIGITAL, &chip->flags);\r\n#endif\r\nspin_lock_init(&chip->lock);\r\nret = snd_msnd_probe(card);\r\nif (ret < 0) {\r\nprintk(KERN_ERR LOGNAME ": Probe failed\n");\r\ngoto _release_card;\r\n}\r\nret = snd_msnd_attach(card);\r\nif (ret < 0) {\r\nprintk(KERN_ERR LOGNAME ": Attach failed\n");\r\ngoto _release_card;\r\n}\r\npnp_set_card_drvdata(pcard, card);\r\n++idx;\r\nreturn 0;\r\n_release_card:\r\nsnd_card_free(card);\r\nreturn ret;\r\n}\r\nstatic void snd_msnd_pnp_remove(struct pnp_card_link *pcard)\r\n{\r\nsnd_msnd_unload(pnp_get_card_drvdata(pcard));\r\npnp_set_card_drvdata(pcard, NULL);\r\n}\r\nstatic int __init snd_msnd_init(void)\r\n{\r\nint err;\r\nerr = isa_register_driver(&snd_msnd_driver, SNDRV_CARDS);\r\n#ifdef CONFIG_PNP\r\nif (!err)\r\nisa_registered = 1;\r\nerr = pnp_register_card_driver(&msnd_pnpc_driver);\r\nif (!err)\r\npnp_registered = 1;\r\nif (isa_registered)\r\nerr = 0;\r\n#endif\r\nreturn err;\r\n}\r\nstatic void __exit snd_msnd_exit(void)\r\n{\r\n#ifdef CONFIG_PNP\r\nif (pnp_registered)\r\npnp_unregister_card_driver(&msnd_pnpc_driver);\r\nif (isa_registered)\r\n#endif\r\nisa_unregister_driver(&snd_msnd_driver);\r\n}
