static void\r\nbfa_fcs_lport_sm_uninit(\r\nstruct bfa_fcs_lport_s *port,\r\nenum bfa_fcs_lport_event event)\r\n{\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nbfa_trc(port->fcs, event);\r\nswitch (event) {\r\ncase BFA_FCS_PORT_SM_CREATE:\r\nbfa_sm_set_state(port, bfa_fcs_lport_sm_init);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_sm_init(struct bfa_fcs_lport_s *port,\r\nenum bfa_fcs_lport_event event)\r\n{\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nbfa_trc(port->fcs, event);\r\nswitch (event) {\r\ncase BFA_FCS_PORT_SM_ONLINE:\r\nbfa_sm_set_state(port, bfa_fcs_lport_sm_online);\r\nbfa_fcs_lport_online_actions(port);\r\nbreak;\r\ncase BFA_FCS_PORT_SM_DELETE:\r\nbfa_sm_set_state(port, bfa_fcs_lport_sm_uninit);\r\nbfa_fcs_lport_deleted(port);\r\nbreak;\r\ncase BFA_FCS_PORT_SM_STOP:\r\nif (port->vport)\r\nbfa_fcs_vport_stop_comp(port->vport);\r\nelse\r\nbfa_wc_down(&(port->fabric->stop_wc));\r\nbreak;\r\ncase BFA_FCS_PORT_SM_OFFLINE:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_sm_online(\r\nstruct bfa_fcs_lport_s *port,\r\nenum bfa_fcs_lport_event event)\r\n{\r\nstruct bfa_fcs_rport_s *rport;\r\nstruct list_head *qe, *qen;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nbfa_trc(port->fcs, event);\r\nswitch (event) {\r\ncase BFA_FCS_PORT_SM_OFFLINE:\r\nbfa_sm_set_state(port, bfa_fcs_lport_sm_offline);\r\nbfa_fcs_lport_offline_actions(port);\r\nbreak;\r\ncase BFA_FCS_PORT_SM_STOP:\r\n__port_action[port->fabric->fab_type].offline(port);\r\nif (port->num_rports == 0) {\r\nbfa_sm_set_state(port, bfa_fcs_lport_sm_init);\r\nif (port->vport)\r\nbfa_fcs_vport_stop_comp(port->vport);\r\nelse\r\nbfa_wc_down(&(port->fabric->stop_wc));\r\n} else {\r\nbfa_sm_set_state(port, bfa_fcs_lport_sm_stopping);\r\nlist_for_each_safe(qe, qen, &port->rport_q) {\r\nrport = (struct bfa_fcs_rport_s *) qe;\r\nbfa_sm_send_event(rport, RPSM_EVENT_DELETE);\r\n}\r\n}\r\nbreak;\r\ncase BFA_FCS_PORT_SM_DELETE:\r\n__port_action[port->fabric->fab_type].offline(port);\r\nif (port->num_rports == 0) {\r\nbfa_sm_set_state(port, bfa_fcs_lport_sm_uninit);\r\nbfa_fcs_lport_deleted(port);\r\n} else {\r\nbfa_sm_set_state(port, bfa_fcs_lport_sm_deleting);\r\nlist_for_each_safe(qe, qen, &port->rport_q) {\r\nrport = (struct bfa_fcs_rport_s *) qe;\r\nbfa_sm_send_event(rport, RPSM_EVENT_DELETE);\r\n}\r\n}\r\nbreak;\r\ncase BFA_FCS_PORT_SM_DELRPORT:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_sm_offline(\r\nstruct bfa_fcs_lport_s *port,\r\nenum bfa_fcs_lport_event event)\r\n{\r\nstruct bfa_fcs_rport_s *rport;\r\nstruct list_head *qe, *qen;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nbfa_trc(port->fcs, event);\r\nswitch (event) {\r\ncase BFA_FCS_PORT_SM_ONLINE:\r\nbfa_sm_set_state(port, bfa_fcs_lport_sm_online);\r\nbfa_fcs_lport_online_actions(port);\r\nbreak;\r\ncase BFA_FCS_PORT_SM_STOP:\r\nif (port->num_rports == 0) {\r\nbfa_sm_set_state(port, bfa_fcs_lport_sm_init);\r\nif (port->vport)\r\nbfa_fcs_vport_stop_comp(port->vport);\r\nelse\r\nbfa_wc_down(&(port->fabric->stop_wc));\r\n} else {\r\nbfa_sm_set_state(port, bfa_fcs_lport_sm_stopping);\r\nlist_for_each_safe(qe, qen, &port->rport_q) {\r\nrport = (struct bfa_fcs_rport_s *) qe;\r\nbfa_sm_send_event(rport, RPSM_EVENT_DELETE);\r\n}\r\n}\r\nbreak;\r\ncase BFA_FCS_PORT_SM_DELETE:\r\nif (port->num_rports == 0) {\r\nbfa_sm_set_state(port, bfa_fcs_lport_sm_uninit);\r\nbfa_fcs_lport_deleted(port);\r\n} else {\r\nbfa_sm_set_state(port, bfa_fcs_lport_sm_deleting);\r\nlist_for_each_safe(qe, qen, &port->rport_q) {\r\nrport = (struct bfa_fcs_rport_s *) qe;\r\nbfa_sm_send_event(rport, RPSM_EVENT_DELETE);\r\n}\r\n}\r\nbreak;\r\ncase BFA_FCS_PORT_SM_DELRPORT:\r\ncase BFA_FCS_PORT_SM_OFFLINE:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_sm_stopping(struct bfa_fcs_lport_s *port,\r\nenum bfa_fcs_lport_event event)\r\n{\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nbfa_trc(port->fcs, event);\r\nswitch (event) {\r\ncase BFA_FCS_PORT_SM_DELRPORT:\r\nif (port->num_rports == 0) {\r\nbfa_sm_set_state(port, bfa_fcs_lport_sm_init);\r\nif (port->vport)\r\nbfa_fcs_vport_stop_comp(port->vport);\r\nelse\r\nbfa_wc_down(&(port->fabric->stop_wc));\r\n}\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_sm_deleting(\r\nstruct bfa_fcs_lport_s *port,\r\nenum bfa_fcs_lport_event event)\r\n{\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nbfa_trc(port->fcs, event);\r\nswitch (event) {\r\ncase BFA_FCS_PORT_SM_DELRPORT:\r\nif (port->num_rports == 0) {\r\nbfa_sm_set_state(port, bfa_fcs_lport_sm_uninit);\r\nbfa_fcs_lport_deleted(port);\r\n}\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_aen_post(struct bfa_fcs_lport_s *port,\r\nenum bfa_lport_aen_event event)\r\n{\r\nstruct bfad_s *bfad = (struct bfad_s *)port->fabric->fcs->bfad;\r\nstruct bfa_aen_entry_s *aen_entry;\r\nbfad_get_aen_entry(bfad, aen_entry);\r\nif (!aen_entry)\r\nreturn;\r\naen_entry->aen_data.lport.vf_id = port->fabric->vf_id;\r\naen_entry->aen_data.lport.roles = port->port_cfg.roles;\r\naen_entry->aen_data.lport.ppwwn = bfa_fcs_lport_get_pwwn(\r\nbfa_fcs_get_base_port(port->fcs));\r\naen_entry->aen_data.lport.lpwwn = bfa_fcs_lport_get_pwwn(port);\r\nbfad_im_post_vendor_event(aen_entry, bfad, ++port->fcs->fcs_aen_seq,\r\nBFA_AEN_CAT_LPORT, event);\r\n}\r\nstatic void\r\nbfa_fcs_lport_send_ls_rjt(struct bfa_fcs_lport_s *port, struct fchs_s *rx_fchs,\r\nu8 reason_code, u8 reason_code_expl)\r\n{\r\nstruct fchs_s fchs;\r\nstruct bfa_fcxp_s *fcxp;\r\nstruct bfa_rport_s *bfa_rport = NULL;\r\nint len;\r\nbfa_trc(port->fcs, rx_fchs->d_id);\r\nbfa_trc(port->fcs, rx_fchs->s_id);\r\nfcxp = bfa_fcs_fcxp_alloc(port->fcs, BFA_FALSE);\r\nif (!fcxp)\r\nreturn;\r\nlen = fc_ls_rjt_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\r\nrx_fchs->s_id, bfa_fcs_lport_get_fcid(port),\r\nrx_fchs->ox_id, reason_code, reason_code_expl);\r\nbfa_fcxp_send(fcxp, bfa_rport, port->fabric->vf_id, port->lp_tag,\r\nBFA_FALSE, FC_CLASS_3, len, &fchs, NULL, NULL,\r\nFC_MAX_PDUSZ, 0);\r\n}\r\nstatic void\r\nbfa_fcs_lport_send_fcgs_rjt(struct bfa_fcs_lport_s *port,\r\nstruct fchs_s *rx_fchs, u8 reason_code, u8 reason_code_expl)\r\n{\r\nstruct fchs_s fchs;\r\nstruct bfa_fcxp_s *fcxp;\r\nstruct bfa_rport_s *bfa_rport = NULL;\r\nint len;\r\nstruct ct_hdr_s *rx_cthdr = (struct ct_hdr_s *)(rx_fchs + 1);\r\nstruct ct_hdr_s *ct_hdr;\r\nbfa_trc(port->fcs, rx_fchs->d_id);\r\nbfa_trc(port->fcs, rx_fchs->s_id);\r\nfcxp = bfa_fcs_fcxp_alloc(port->fcs, BFA_FALSE);\r\nif (!fcxp)\r\nreturn;\r\nct_hdr = bfa_fcxp_get_reqbuf(fcxp);\r\nct_hdr->gs_type = rx_cthdr->gs_type;\r\nct_hdr->gs_sub_type = rx_cthdr->gs_sub_type;\r\nlen = fc_gs_rjt_build(&fchs, ct_hdr, rx_fchs->s_id,\r\nbfa_fcs_lport_get_fcid(port),\r\nrx_fchs->ox_id, reason_code, reason_code_expl);\r\nbfa_fcxp_send(fcxp, bfa_rport, port->fabric->vf_id, port->lp_tag,\r\nBFA_FALSE, FC_CLASS_3, len, &fchs, NULL, NULL,\r\nFC_MAX_PDUSZ, 0);\r\n}\r\nstatic void\r\nbfa_fcs_lport_plogi(struct bfa_fcs_lport_s *port,\r\nstruct fchs_s *rx_fchs, struct fc_logi_s *plogi)\r\n{\r\nstruct bfa_fcs_rport_s *rport;\r\nbfa_trc(port->fcs, rx_fchs->d_id);\r\nbfa_trc(port->fcs, rx_fchs->s_id);\r\nif (__fcs_min_cfg(port->fcs)) {\r\nbfa_trc(port->fcs, rx_fchs->s_id);\r\nreturn;\r\n}\r\nif (fc_plogi_parse(rx_fchs) != FC_PARSE_OK) {\r\nbfa_trc(port->fcs, rx_fchs->s_id);\r\nbfa_fcs_lport_send_ls_rjt(port, rx_fchs,\r\nFC_LS_RJT_RSN_PROTOCOL_ERROR,\r\nFC_LS_RJT_EXP_SPARMS_ERR_OPTIONS);\r\nreturn;\r\n}\r\nif ((!bfa_fcs_fabric_is_switched(port->fabric)) &&\r\n(memcmp((void *)&bfa_fcs_lport_get_pwwn(port),\r\n(void *)&plogi->port_name, sizeof(wwn_t)) < 0)) {\r\nif (BFA_FCS_PID_IS_WKA(rx_fchs->d_id)) {\r\nbfa_fcs_lport_send_ls_rjt(port, rx_fchs,\r\nFC_LS_RJT_RSN_PROTOCOL_ERROR,\r\nFC_LS_RJT_EXP_INVALID_NPORT_ID);\r\nreturn;\r\n}\r\nport->pid = rx_fchs->d_id;\r\nbfa_lps_set_n2n_pid(port->fabric->lps, rx_fchs->d_id);\r\n}\r\nrport = bfa_fcs_lport_get_rport_by_pwwn(port, plogi->port_name);\r\nif (rport) {\r\nif ((!bfa_fcs_fabric_is_switched(port->fabric)) &&\r\n(memcmp((void *)&bfa_fcs_lport_get_pwwn(port),\r\n(void *)&plogi->port_name, sizeof(wwn_t)) < 0)) {\r\nport->pid = rx_fchs->d_id;\r\nbfa_lps_set_n2n_pid(port->fabric->lps, rx_fchs->d_id);\r\nrport->pid = rx_fchs->s_id;\r\n}\r\nbfa_fcs_rport_plogi(rport, rx_fchs, plogi);\r\nreturn;\r\n}\r\nrport = bfa_fcs_lport_get_rport_by_pid(port, rx_fchs->s_id);\r\nif (!rport) {\r\nbfa_fcs_rport_plogi_create(port, rx_fchs, plogi);\r\nreturn;\r\n}\r\nif (rport->pwwn) {\r\nWARN_ON(rport->pwwn == plogi->port_name);\r\nbfa_sm_send_event(rport, RPSM_EVENT_LOGO_IMP);\r\nbfa_fcs_rport_plogi_create(port, rx_fchs, plogi);\r\nreturn;\r\n}\r\nWARN_ON(rport->pwwn != WWN_NULL);\r\nbfa_fcs_rport_plogi(rport, rx_fchs, plogi);\r\n}\r\nstatic void\r\nbfa_fcs_lport_echo(struct bfa_fcs_lport_s *port, struct fchs_s *rx_fchs,\r\nstruct fc_echo_s *echo, u16 rx_len)\r\n{\r\nstruct fchs_s fchs;\r\nstruct bfa_fcxp_s *fcxp;\r\nstruct bfa_rport_s *bfa_rport = NULL;\r\nint len, pyld_len;\r\nbfa_trc(port->fcs, rx_fchs->s_id);\r\nbfa_trc(port->fcs, rx_fchs->d_id);\r\nfcxp = bfa_fcs_fcxp_alloc(port->fcs, BFA_FALSE);\r\nif (!fcxp)\r\nreturn;\r\nlen = fc_ls_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\r\nrx_fchs->s_id, bfa_fcs_lport_get_fcid(port),\r\nrx_fchs->ox_id);\r\npyld_len = rx_len - sizeof(struct fchs_s);\r\nbfa_trc(port->fcs, rx_len);\r\nbfa_trc(port->fcs, pyld_len);\r\nif (pyld_len > len)\r\nmemcpy(((u8 *) bfa_fcxp_get_reqbuf(fcxp)) +\r\nsizeof(struct fc_echo_s), (echo + 1),\r\n(pyld_len - sizeof(struct fc_echo_s)));\r\nbfa_fcxp_send(fcxp, bfa_rport, port->fabric->vf_id, port->lp_tag,\r\nBFA_FALSE, FC_CLASS_3, pyld_len, &fchs, NULL, NULL,\r\nFC_MAX_PDUSZ, 0);\r\n}\r\nstatic void\r\nbfa_fcs_lport_rnid(struct bfa_fcs_lport_s *port, struct fchs_s *rx_fchs,\r\nstruct fc_rnid_cmd_s *rnid, u16 rx_len)\r\n{\r\nstruct fc_rnid_common_id_data_s common_id_data;\r\nstruct fc_rnid_general_topology_data_s gen_topo_data;\r\nstruct fchs_s fchs;\r\nstruct bfa_fcxp_s *fcxp;\r\nstruct bfa_rport_s *bfa_rport = NULL;\r\nu16 len;\r\nu32 data_format;\r\nbfa_trc(port->fcs, rx_fchs->s_id);\r\nbfa_trc(port->fcs, rx_fchs->d_id);\r\nbfa_trc(port->fcs, rx_len);\r\nfcxp = bfa_fcs_fcxp_alloc(port->fcs, BFA_FALSE);\r\nif (!fcxp)\r\nreturn;\r\nbfa_trc(port->fcs, rnid->node_id_data_format);\r\nif (rnid->node_id_data_format == RNID_NODEID_DATA_FORMAT_DISCOVERY) {\r\ndata_format = RNID_NODEID_DATA_FORMAT_DISCOVERY;\r\nbfa_fs_port_get_gen_topo_data(port, &gen_topo_data);\r\n} else {\r\ndata_format = RNID_NODEID_DATA_FORMAT_COMMON;\r\n}\r\ncommon_id_data.port_name = bfa_fcs_lport_get_pwwn(port);\r\ncommon_id_data.node_name = bfa_fcs_lport_get_nwwn(port);\r\nlen = fc_rnid_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\r\nrx_fchs->s_id, bfa_fcs_lport_get_fcid(port),\r\nrx_fchs->ox_id, data_format, &common_id_data,\r\n&gen_topo_data);\r\nbfa_fcxp_send(fcxp, bfa_rport, port->fabric->vf_id, port->lp_tag,\r\nBFA_FALSE, FC_CLASS_3, len, &fchs, NULL, NULL,\r\nFC_MAX_PDUSZ, 0);\r\n}\r\nstatic void\r\nbfa_fs_port_get_gen_topo_data(struct bfa_fcs_lport_s *port,\r\nstruct fc_rnid_general_topology_data_s *gen_topo_data)\r\n{\r\nmemset(gen_topo_data, 0,\r\nsizeof(struct fc_rnid_general_topology_data_s));\r\ngen_topo_data->asso_type = cpu_to_be32(RNID_ASSOCIATED_TYPE_HOST);\r\ngen_topo_data->phy_port_num = 0;\r\ngen_topo_data->num_attached_nodes = cpu_to_be32(1);\r\n}\r\nstatic void\r\nbfa_fcs_lport_online_actions(struct bfa_fcs_lport_s *port)\r\n{\r\nstruct bfad_s *bfad = (struct bfad_s *)port->fcs->bfad;\r\nchar lpwwn_buf[BFA_STRING_32];\r\nbfa_trc(port->fcs, port->fabric->oper_type);\r\n__port_action[port->fabric->fab_type].init(port);\r\n__port_action[port->fabric->fab_type].online(port);\r\nwwn2str(lpwwn_buf, bfa_fcs_lport_get_pwwn(port));\r\nBFA_LOG(KERN_WARNING, bfad, bfa_log_level,\r\n"Logical port online: WWN = %s Role = %s\n",\r\nlpwwn_buf, "Initiator");\r\nbfa_fcs_lport_aen_post(port, BFA_LPORT_AEN_ONLINE);\r\nbfad->bfad_flags |= BFAD_PORT_ONLINE;\r\n}\r\nstatic void\r\nbfa_fcs_lport_offline_actions(struct bfa_fcs_lport_s *port)\r\n{\r\nstruct list_head *qe, *qen;\r\nstruct bfa_fcs_rport_s *rport;\r\nstruct bfad_s *bfad = (struct bfad_s *)port->fcs->bfad;\r\nchar lpwwn_buf[BFA_STRING_32];\r\nbfa_trc(port->fcs, port->fabric->oper_type);\r\n__port_action[port->fabric->fab_type].offline(port);\r\nwwn2str(lpwwn_buf, bfa_fcs_lport_get_pwwn(port));\r\nif (bfa_sm_cmp_state(port->fabric,\r\nbfa_fcs_fabric_sm_online) == BFA_TRUE) {\r\nBFA_LOG(KERN_WARNING, bfad, bfa_log_level,\r\n"Logical port lost fabric connectivity: WWN = %s Role = %s\n",\r\nlpwwn_buf, "Initiator");\r\nbfa_fcs_lport_aen_post(port, BFA_LPORT_AEN_DISCONNECT);\r\n} else {\r\nBFA_LOG(KERN_WARNING, bfad, bfa_log_level,\r\n"Logical port taken offline: WWN = %s Role = %s\n",\r\nlpwwn_buf, "Initiator");\r\nbfa_fcs_lport_aen_post(port, BFA_LPORT_AEN_OFFLINE);\r\n}\r\nlist_for_each_safe(qe, qen, &port->rport_q) {\r\nrport = (struct bfa_fcs_rport_s *) qe;\r\nbfa_sm_send_event(rport, RPSM_EVENT_LOGO_IMP);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_unknown_init(struct bfa_fcs_lport_s *port)\r\n{\r\nWARN_ON(1);\r\n}\r\nstatic void\r\nbfa_fcs_lport_unknown_online(struct bfa_fcs_lport_s *port)\r\n{\r\nWARN_ON(1);\r\n}\r\nstatic void\r\nbfa_fcs_lport_unknown_offline(struct bfa_fcs_lport_s *port)\r\n{\r\nWARN_ON(1);\r\n}\r\nstatic void\r\nbfa_fcs_lport_abts_acc(struct bfa_fcs_lport_s *port, struct fchs_s *rx_fchs)\r\n{\r\nstruct fchs_s fchs;\r\nstruct bfa_fcxp_s *fcxp;\r\nint len;\r\nbfa_trc(port->fcs, rx_fchs->d_id);\r\nbfa_trc(port->fcs, rx_fchs->s_id);\r\nfcxp = bfa_fcs_fcxp_alloc(port->fcs, BFA_FALSE);\r\nif (!fcxp)\r\nreturn;\r\nlen = fc_ba_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\r\nrx_fchs->s_id, bfa_fcs_lport_get_fcid(port),\r\nrx_fchs->ox_id, 0);\r\nbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag,\r\nBFA_FALSE, FC_CLASS_3, len, &fchs, NULL, NULL,\r\nFC_MAX_PDUSZ, 0);\r\n}\r\nstatic void\r\nbfa_fcs_lport_deleted(struct bfa_fcs_lport_s *port)\r\n{\r\nstruct bfad_s *bfad = (struct bfad_s *)port->fcs->bfad;\r\nchar lpwwn_buf[BFA_STRING_32];\r\nwwn2str(lpwwn_buf, bfa_fcs_lport_get_pwwn(port));\r\nBFA_LOG(KERN_INFO, bfad, bfa_log_level,\r\n"Logical port deleted: WWN = %s Role = %s\n",\r\nlpwwn_buf, "Initiator");\r\nbfa_fcs_lport_aen_post(port, BFA_LPORT_AEN_DELETE);\r\nif (port->vport)\r\nbfa_fcs_vport_delete_comp(port->vport);\r\nelse\r\nbfa_wc_down(&port->fabric->wc);\r\n}\r\nvoid\r\nbfa_fcs_lport_uf_recv(struct bfa_fcs_lport_s *lport,\r\nstruct fchs_s *fchs, u16 len)\r\n{\r\nu32 pid = fchs->s_id;\r\nstruct bfa_fcs_rport_s *rport = NULL;\r\nstruct fc_els_cmd_s *els_cmd = (struct fc_els_cmd_s *) (fchs + 1);\r\nbfa_stats(lport, uf_recvs);\r\nbfa_trc(lport->fcs, fchs->type);\r\nif (!bfa_fcs_lport_is_online(lport)) {\r\nbfa_stats(lport, uf_recv_drops);\r\nreturn;\r\n}\r\nif ((fchs->type == FC_TYPE_ELS) &&\r\n(els_cmd->els_code == FC_ELS_PLOGI)) {\r\nbfa_fcs_lport_plogi(lport, fchs, (struct fc_logi_s *) els_cmd);\r\nreturn;\r\n}\r\nif ((fchs->type == FC_TYPE_ELS) && (els_cmd->els_code == FC_ELS_ECHO)) {\r\nbfa_fcs_lport_echo(lport, fchs,\r\n(struct fc_echo_s *)els_cmd, len);\r\nreturn;\r\n}\r\nif ((fchs->type == FC_TYPE_ELS) && (els_cmd->els_code == FC_ELS_RNID)) {\r\nbfa_fcs_lport_rnid(lport, fchs,\r\n(struct fc_rnid_cmd_s *) els_cmd, len);\r\nreturn;\r\n}\r\nif (fchs->type == FC_TYPE_BLS) {\r\nif ((fchs->routing == FC_RTG_BASIC_LINK) &&\r\n(fchs->cat_info == FC_CAT_ABTS))\r\nbfa_fcs_lport_abts_acc(lport, fchs);\r\nreturn;\r\n}\r\nif (fchs->type == FC_TYPE_SERVICES) {\r\nbfa_fcs_lport_send_fcgs_rjt(lport, fchs, CT_RSN_NOT_SUPP,\r\nCT_NS_EXP_NOADDITIONAL);\r\nreturn;\r\n}\r\nrport = bfa_fcs_lport_get_rport_by_pid(lport, pid);\r\nif (rport) {\r\nbfa_trc(rport->fcs, fchs->s_id);\r\nbfa_trc(rport->fcs, fchs->d_id);\r\nbfa_trc(rport->fcs, fchs->type);\r\nbfa_fcs_rport_uf_recv(rport, fchs, len);\r\nreturn;\r\n}\r\nif (fchs->type != FC_TYPE_ELS) {\r\nbfa_trc(lport->fcs, fchs->s_id);\r\nbfa_trc(lport->fcs, fchs->d_id);\r\nif (fchs->type != FC_TYPE_FC_FSS)\r\nbfa_sm_fault(lport->fcs, fchs->type);\r\nreturn;\r\n}\r\nbfa_trc(lport->fcs, els_cmd->els_code);\r\nif (els_cmd->els_code == FC_ELS_RSCN) {\r\nbfa_fcs_lport_scn_process_rscn(lport, fchs, len);\r\nreturn;\r\n}\r\nif (els_cmd->els_code == FC_ELS_LOGO) {\r\nreturn;\r\n}\r\nif (els_cmd->els_code == FC_ELS_PRLI) {\r\nreturn;\r\n}\r\nbfa_fcs_lport_send_ls_rjt(lport, fchs, FC_LS_RJT_RSN_CMD_NOT_SUPP,\r\nFC_LS_RJT_EXP_NO_ADDL_INFO);\r\n}\r\nstruct bfa_fcs_rport_s *\r\nbfa_fcs_lport_get_rport_by_pid(struct bfa_fcs_lport_s *port, u32 pid)\r\n{\r\nstruct bfa_fcs_rport_s *rport;\r\nstruct list_head *qe;\r\nlist_for_each(qe, &port->rport_q) {\r\nrport = (struct bfa_fcs_rport_s *) qe;\r\nif (rport->pid == pid)\r\nreturn rport;\r\n}\r\nbfa_trc(port->fcs, pid);\r\nreturn NULL;\r\n}\r\nstruct bfa_fcs_rport_s *\r\nbfa_fcs_lport_get_rport_by_old_pid(struct bfa_fcs_lport_s *port, u32 pid)\r\n{\r\nstruct bfa_fcs_rport_s *rport;\r\nstruct list_head *qe;\r\nlist_for_each(qe, &port->rport_q) {\r\nrport = (struct bfa_fcs_rport_s *) qe;\r\nif (rport->old_pid == pid)\r\nreturn rport;\r\n}\r\nbfa_trc(port->fcs, pid);\r\nreturn NULL;\r\n}\r\nstruct bfa_fcs_rport_s *\r\nbfa_fcs_lport_get_rport_by_pwwn(struct bfa_fcs_lport_s *port, wwn_t pwwn)\r\n{\r\nstruct bfa_fcs_rport_s *rport;\r\nstruct list_head *qe;\r\nlist_for_each(qe, &port->rport_q) {\r\nrport = (struct bfa_fcs_rport_s *) qe;\r\nif (wwn_is_equal(rport->pwwn, pwwn))\r\nreturn rport;\r\n}\r\nbfa_trc(port->fcs, pwwn);\r\nreturn NULL;\r\n}\r\nstruct bfa_fcs_rport_s *\r\nbfa_fcs_lport_get_rport_by_nwwn(struct bfa_fcs_lport_s *port, wwn_t nwwn)\r\n{\r\nstruct bfa_fcs_rport_s *rport;\r\nstruct list_head *qe;\r\nlist_for_each(qe, &port->rport_q) {\r\nrport = (struct bfa_fcs_rport_s *) qe;\r\nif (wwn_is_equal(rport->nwwn, nwwn))\r\nreturn rport;\r\n}\r\nbfa_trc(port->fcs, nwwn);\r\nreturn NULL;\r\n}\r\nstruct bfa_fcs_rport_s *\r\nbfa_fcs_lport_get_rport_by_qualifier(struct bfa_fcs_lport_s *port,\r\nwwn_t pwwn, u32 pid)\r\n{\r\nstruct bfa_fcs_rport_s *rport;\r\nstruct list_head *qe;\r\nlist_for_each(qe, &port->rport_q) {\r\nrport = (struct bfa_fcs_rport_s *) qe;\r\nif (wwn_is_equal(rport->pwwn, pwwn) && rport->pid == pid)\r\nreturn rport;\r\n}\r\nbfa_trc(port->fcs, pwwn);\r\nreturn NULL;\r\n}\r\nvoid\r\nbfa_fcs_lport_add_rport(\r\nstruct bfa_fcs_lport_s *port,\r\nstruct bfa_fcs_rport_s *rport)\r\n{\r\nlist_add_tail(&rport->qe, &port->rport_q);\r\nport->num_rports++;\r\n}\r\nvoid\r\nbfa_fcs_lport_del_rport(\r\nstruct bfa_fcs_lport_s *port,\r\nstruct bfa_fcs_rport_s *rport)\r\n{\r\nWARN_ON(!bfa_q_is_on_q(&port->rport_q, rport));\r\nlist_del(&rport->qe);\r\nport->num_rports--;\r\nbfa_sm_send_event(port, BFA_FCS_PORT_SM_DELRPORT);\r\n}\r\nvoid\r\nbfa_fcs_lport_online(struct bfa_fcs_lport_s *port)\r\n{\r\nbfa_sm_send_event(port, BFA_FCS_PORT_SM_ONLINE);\r\n}\r\nvoid\r\nbfa_fcs_lport_offline(struct bfa_fcs_lport_s *port)\r\n{\r\nbfa_sm_send_event(port, BFA_FCS_PORT_SM_OFFLINE);\r\n}\r\nvoid\r\nbfa_fcs_lport_stop(struct bfa_fcs_lport_s *port)\r\n{\r\nbfa_sm_send_event(port, BFA_FCS_PORT_SM_STOP);\r\n}\r\nvoid\r\nbfa_fcs_lport_delete(struct bfa_fcs_lport_s *port)\r\n{\r\nbfa_sm_send_event(port, BFA_FCS_PORT_SM_DELETE);\r\n}\r\nbfa_boolean_t\r\nbfa_fcs_lport_is_online(struct bfa_fcs_lport_s *port)\r\n{\r\nreturn bfa_sm_cmp_state(port, bfa_fcs_lport_sm_online);\r\n}\r\nvoid\r\nbfa_fcs_lport_attach(struct bfa_fcs_lport_s *lport, struct bfa_fcs_s *fcs,\r\nu16 vf_id, struct bfa_fcs_vport_s *vport)\r\n{\r\nlport->fcs = fcs;\r\nlport->fabric = bfa_fcs_vf_lookup(fcs, vf_id);\r\nlport->vport = vport;\r\nlport->lp_tag = (vport) ? vport->lps->bfa_tag :\r\nlport->fabric->lps->bfa_tag;\r\nINIT_LIST_HEAD(&lport->rport_q);\r\nlport->num_rports = 0;\r\n}\r\nvoid\r\nbfa_fcs_lport_init(struct bfa_fcs_lport_s *lport,\r\nstruct bfa_lport_cfg_s *port_cfg)\r\n{\r\nstruct bfa_fcs_vport_s *vport = lport->vport;\r\nstruct bfad_s *bfad = (struct bfad_s *)lport->fcs->bfad;\r\nchar lpwwn_buf[BFA_STRING_32];\r\nlport->port_cfg = *port_cfg;\r\nlport->bfad_port = bfa_fcb_lport_new(lport->fcs->bfad, lport,\r\nlport->port_cfg.roles,\r\nlport->fabric->vf_drv,\r\nvport ? vport->vport_drv : NULL);\r\nwwn2str(lpwwn_buf, bfa_fcs_lport_get_pwwn(lport));\r\nBFA_LOG(KERN_INFO, bfad, bfa_log_level,\r\n"New logical port created: WWN = %s Role = %s\n",\r\nlpwwn_buf, "Initiator");\r\nbfa_fcs_lport_aen_post(lport, BFA_LPORT_AEN_NEW);\r\nbfa_sm_set_state(lport, bfa_fcs_lport_sm_uninit);\r\nbfa_sm_send_event(lport, BFA_FCS_PORT_SM_CREATE);\r\n}\r\nvoid\r\nbfa_fcs_lport_get_attr(\r\nstruct bfa_fcs_lport_s *port,\r\nstruct bfa_lport_attr_s *port_attr)\r\n{\r\nif (bfa_sm_cmp_state(port, bfa_fcs_lport_sm_online))\r\nport_attr->pid = port->pid;\r\nelse\r\nport_attr->pid = 0;\r\nport_attr->port_cfg = port->port_cfg;\r\nif (port->fabric) {\r\nport_attr->port_type = port->fabric->oper_type;\r\nport_attr->loopback = bfa_sm_cmp_state(port->fabric,\r\nbfa_fcs_fabric_sm_loopback);\r\nport_attr->authfail =\r\nbfa_sm_cmp_state(port->fabric,\r\nbfa_fcs_fabric_sm_auth_failed);\r\nport_attr->fabric_name = bfa_fcs_lport_get_fabric_name(port);\r\nmemcpy(port_attr->fabric_ip_addr,\r\nbfa_fcs_lport_get_fabric_ipaddr(port),\r\nBFA_FCS_FABRIC_IPADDR_SZ);\r\nif (port->vport != NULL) {\r\nport_attr->port_type = BFA_PORT_TYPE_VPORT;\r\nport_attr->fpma_mac =\r\nport->vport->lps->lp_mac;\r\n} else {\r\nport_attr->fpma_mac =\r\nport->fabric->lps->lp_mac;\r\n}\r\n} else {\r\nport_attr->port_type = BFA_PORT_TYPE_UNKNOWN;\r\nport_attr->state = BFA_LPORT_UNINIT;\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_fab_init(struct bfa_fcs_lport_s *port)\r\n{\r\nbfa_fcs_lport_ns_init(port);\r\nbfa_fcs_lport_scn_init(port);\r\nbfa_fcs_lport_ms_init(port);\r\n}\r\nstatic void\r\nbfa_fcs_lport_fab_online(struct bfa_fcs_lport_s *port)\r\n{\r\nbfa_fcs_lport_ns_online(port);\r\nbfa_fcs_lport_fab_scn_online(port);\r\n}\r\nstatic void\r\nbfa_fcs_lport_fab_offline(struct bfa_fcs_lport_s *port)\r\n{\r\nbfa_fcs_lport_ns_offline(port);\r\nbfa_fcs_lport_scn_offline(port);\r\nbfa_fcs_lport_ms_offline(port);\r\n}\r\nstatic void\r\nbfa_fcs_lport_n2n_init(struct bfa_fcs_lport_s *port)\r\n{\r\n}\r\nstatic void\r\nbfa_fcs_lport_n2n_online(struct bfa_fcs_lport_s *port)\r\n{\r\nstruct bfa_fcs_lport_n2n_s *n2n_port = &port->port_topo.pn2n;\r\nstruct bfa_lport_cfg_s *pcfg = &port->port_cfg;\r\nstruct bfa_fcs_rport_s *rport;\r\nbfa_trc(port->fcs, pcfg->pwwn);\r\nif (memcmp\r\n((void *)&pcfg->pwwn, (void *)&n2n_port->rem_port_wwn,\r\nsizeof(wwn_t)) > 0) {\r\nport->pid = N2N_LOCAL_PID;\r\nbfa_lps_set_n2n_pid(port->fabric->lps, N2N_LOCAL_PID);\r\nrport = bfa_fcs_lport_get_rport_by_pwwn(port,\r\nn2n_port->rem_port_wwn);\r\nif (rport) {\r\nbfa_trc(port->fcs, rport->pid);\r\nbfa_trc(port->fcs, rport->pwwn);\r\nrport->pid = N2N_REMOTE_PID;\r\nbfa_sm_send_event(rport, RPSM_EVENT_PLOGI_SEND);\r\nreturn;\r\n}\r\nif (port->num_rports > 0) {\r\nrport = bfa_fcs_lport_get_rport_by_pid(port, 0);\r\nWARN_ON(rport == NULL);\r\nif (rport) {\r\nbfa_trc(port->fcs, rport->pwwn);\r\nbfa_sm_send_event(rport, RPSM_EVENT_DELETE);\r\n}\r\n}\r\nbfa_fcs_rport_create(port, N2N_REMOTE_PID);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_n2n_offline(struct bfa_fcs_lport_s *port)\r\n{\r\nstruct bfa_fcs_lport_n2n_s *n2n_port = &port->port_topo.pn2n;\r\nbfa_trc(port->fcs, port->pid);\r\nport->pid = 0;\r\nn2n_port->rem_port_wwn = 0;\r\nn2n_port->reply_oxid = 0;\r\n}\r\nvoid\r\nbfa_fcport_get_loop_attr(struct bfa_fcs_lport_s *port)\r\n{\r\nint i = 0, j = 0, bit = 0, alpa_bit = 0;\r\nu8 k = 0;\r\nstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(port->fcs->bfa);\r\nport->port_topo.ploop.alpabm_valid = fcport->alpabm_valid;\r\nport->pid = fcport->myalpa;\r\nport->pid = bfa_hton3b(port->pid);\r\nfor (i = 0; i < (FC_ALPA_MAX / 8); i++) {\r\nfor (j = 0, alpa_bit = 0; j < 8; j++, alpa_bit++) {\r\nbfa_trc(port->fcs->bfa, fcport->alpabm.alpa_bm[i]);\r\nbit = (fcport->alpabm.alpa_bm[i] & (1 << (7 - j)));\r\nif (bit) {\r\nport->port_topo.ploop.alpa_pos_map[k] =\r\nloop_alpa_map[(i * 8) + alpa_bit];\r\nk++;\r\nbfa_trc(port->fcs->bfa, k);\r\nbfa_trc(port->fcs->bfa,\r\nport->port_topo.ploop.alpa_pos_map[k]);\r\n}\r\n}\r\n}\r\nport->port_topo.ploop.num_alpa = k;\r\n}\r\nstatic void\r\nbfa_fcs_lport_loop_init(struct bfa_fcs_lport_s *port)\r\n{\r\n}\r\nstatic void\r\nbfa_fcs_lport_loop_online(struct bfa_fcs_lport_s *port)\r\n{\r\nu8 num_alpa = 0, alpabm_valid = 0;\r\nstruct bfa_fcs_rport_s *rport;\r\nu8 *alpa_map = NULL;\r\nint i = 0;\r\nu32 pid;\r\nbfa_fcport_get_loop_attr(port);\r\nnum_alpa = port->port_topo.ploop.num_alpa;\r\nalpabm_valid = port->port_topo.ploop.alpabm_valid;\r\nalpa_map = port->port_topo.ploop.alpa_pos_map;\r\nbfa_trc(port->fcs->bfa, port->pid);\r\nbfa_trc(port->fcs->bfa, num_alpa);\r\nif (alpabm_valid == 1) {\r\nfor (i = 0; i < num_alpa; i++) {\r\nbfa_trc(port->fcs->bfa, alpa_map[i]);\r\nif (alpa_map[i] != bfa_hton3b(port->pid)) {\r\npid = alpa_map[i];\r\nbfa_trc(port->fcs->bfa, pid);\r\nrport = bfa_fcs_lport_get_rport_by_pid(port,\r\nbfa_hton3b(pid));\r\nif (!rport)\r\nrport = bfa_fcs_rport_create(port,\r\nbfa_hton3b(pid));\r\n}\r\n}\r\n} else {\r\nfor (i = 0; i < MAX_ALPA_COUNT; i++) {\r\nif (alpa_map[i] != port->pid) {\r\npid = loop_alpa_map[i];\r\nbfa_trc(port->fcs->bfa, pid);\r\nrport = bfa_fcs_lport_get_rport_by_pid(port,\r\nbfa_hton3b(pid));\r\nif (!rport)\r\nrport = bfa_fcs_rport_create(port,\r\nbfa_hton3b(pid));\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_loop_offline(struct bfa_fcs_lport_s *port)\r\n{\r\n}\r\nstatic void\r\nbfa_fcs_lport_fdmi_sm_offline(struct bfa_fcs_lport_fdmi_s *fdmi,\r\nenum port_fdmi_event event)\r\n{\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nbfa_trc(port->fcs, event);\r\nfdmi->retry_cnt = 0;\r\nswitch (event) {\r\ncase FDMISM_EVENT_PORT_ONLINE:\r\nif (port->vport) {\r\nbfa_sm_set_state(fdmi,\r\nbfa_fcs_lport_fdmi_sm_sending_rprt);\r\nbfa_fcs_lport_fdmi_send_rprt(fdmi, NULL);\r\n} else {\r\nbfa_sm_set_state(fdmi,\r\nbfa_fcs_lport_fdmi_sm_sending_rhba);\r\nbfa_fcs_lport_fdmi_send_rhba(fdmi, NULL);\r\n}\r\nbreak;\r\ncase FDMISM_EVENT_PORT_OFFLINE:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_fdmi_sm_sending_rhba(struct bfa_fcs_lport_fdmi_s *fdmi,\r\nenum port_fdmi_event event)\r\n{\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nbfa_trc(port->fcs, event);\r\nswitch (event) {\r\ncase FDMISM_EVENT_RHBA_SENT:\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_rhba);\r\nbreak;\r\ncase FDMISM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\r\nbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(port),\r\n&fdmi->fcxp_wqe);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_fdmi_sm_rhba(struct bfa_fcs_lport_fdmi_s *fdmi,\r\nenum port_fdmi_event event)\r\n{\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nbfa_trc(port->fcs, event);\r\nswitch (event) {\r\ncase FDMISM_EVENT_RSP_ERROR:\r\nif (fdmi->retry_cnt++ < BFA_FCS_FDMI_CMD_MAX_RETRIES) {\r\nbfa_sm_set_state(fdmi,\r\nbfa_fcs_lport_fdmi_sm_rhba_retry);\r\nbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(port),\r\n&fdmi->timer,\r\nbfa_fcs_lport_fdmi_timeout, fdmi,\r\nBFA_FCS_RETRY_TIMEOUT);\r\n} else {\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\r\n}\r\nbreak;\r\ncase FDMISM_EVENT_RSP_OK:\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_sending_rpa);\r\nfdmi->retry_cnt = 0;\r\nbfa_fcs_lport_fdmi_send_rpa(fdmi, NULL);\r\nbreak;\r\ncase FDMISM_EVENT_PORT_OFFLINE:\r\nbfa_fcxp_discard(fdmi->fcxp);\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_fdmi_sm_rhba_retry(struct bfa_fcs_lport_fdmi_s *fdmi,\r\nenum port_fdmi_event event)\r\n{\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nbfa_trc(port->fcs, event);\r\nswitch (event) {\r\ncase FDMISM_EVENT_TIMEOUT:\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_sending_rhba);\r\nbfa_fcs_lport_fdmi_send_rhba(fdmi, NULL);\r\nbreak;\r\ncase FDMISM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\r\nbfa_timer_stop(&fdmi->timer);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_fdmi_sm_sending_rprt(struct bfa_fcs_lport_fdmi_s *fdmi,\r\nenum port_fdmi_event event)\r\n{\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nbfa_trc(port->fcs, event);\r\nswitch (event) {\r\ncase FDMISM_EVENT_RPRT_SENT:\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_rprt);\r\nbreak;\r\ncase FDMISM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\r\nbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(port),\r\n&fdmi->fcxp_wqe);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_fdmi_sm_rprt(struct bfa_fcs_lport_fdmi_s *fdmi,\r\nenum port_fdmi_event event)\r\n{\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nbfa_trc(port->fcs, event);\r\nswitch (event) {\r\ncase FDMISM_EVENT_RSP_ERROR:\r\nif (fdmi->retry_cnt++ < BFA_FCS_FDMI_CMD_MAX_RETRIES) {\r\nbfa_sm_set_state(fdmi,\r\nbfa_fcs_lport_fdmi_sm_rprt_retry);\r\nbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(port),\r\n&fdmi->timer,\r\nbfa_fcs_lport_fdmi_timeout, fdmi,\r\nBFA_FCS_RETRY_TIMEOUT);\r\n} else {\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\r\nfdmi->retry_cnt = 0;\r\n}\r\nbreak;\r\ncase FDMISM_EVENT_RSP_OK:\r\nfdmi->retry_cnt = 0;\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_online);\r\nbreak;\r\ncase FDMISM_EVENT_PORT_OFFLINE:\r\nbfa_fcxp_discard(fdmi->fcxp);\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_fdmi_sm_rprt_retry(struct bfa_fcs_lport_fdmi_s *fdmi,\r\nenum port_fdmi_event event)\r\n{\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nbfa_trc(port->fcs, event);\r\nswitch (event) {\r\ncase FDMISM_EVENT_TIMEOUT:\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_sending_rprt);\r\nbfa_fcs_lport_fdmi_send_rprt(fdmi, NULL);\r\nbreak;\r\ncase FDMISM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\r\nbfa_timer_stop(&fdmi->timer);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_fdmi_sm_sending_rpa(struct bfa_fcs_lport_fdmi_s *fdmi,\r\nenum port_fdmi_event event)\r\n{\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nbfa_trc(port->fcs, event);\r\nswitch (event) {\r\ncase FDMISM_EVENT_RPA_SENT:\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_rpa);\r\nbreak;\r\ncase FDMISM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\r\nbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(port),\r\n&fdmi->fcxp_wqe);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_fdmi_sm_rpa(struct bfa_fcs_lport_fdmi_s *fdmi,\r\nenum port_fdmi_event event)\r\n{\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nbfa_trc(port->fcs, event);\r\nswitch (event) {\r\ncase FDMISM_EVENT_RSP_ERROR:\r\nif (fdmi->retry_cnt++ < BFA_FCS_FDMI_CMD_MAX_RETRIES) {\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_rpa_retry);\r\nbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(port),\r\n&fdmi->timer,\r\nbfa_fcs_lport_fdmi_timeout, fdmi,\r\nBFA_FCS_RETRY_TIMEOUT);\r\n} else {\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\r\nfdmi->retry_cnt = 0;\r\n}\r\nbreak;\r\ncase FDMISM_EVENT_RSP_OK:\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_online);\r\nfdmi->retry_cnt = 0;\r\nbreak;\r\ncase FDMISM_EVENT_PORT_OFFLINE:\r\nbfa_fcxp_discard(fdmi->fcxp);\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_fdmi_sm_rpa_retry(struct bfa_fcs_lport_fdmi_s *fdmi,\r\nenum port_fdmi_event event)\r\n{\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nbfa_trc(port->fcs, event);\r\nswitch (event) {\r\ncase FDMISM_EVENT_TIMEOUT:\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_sending_rpa);\r\nbfa_fcs_lport_fdmi_send_rpa(fdmi, NULL);\r\nbreak;\r\ncase FDMISM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\r\nbfa_timer_stop(&fdmi->timer);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_fdmi_sm_online(struct bfa_fcs_lport_fdmi_s *fdmi,\r\nenum port_fdmi_event event)\r\n{\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nbfa_trc(port->fcs, event);\r\nswitch (event) {\r\ncase FDMISM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_fdmi_sm_disabled(struct bfa_fcs_lport_fdmi_s *fdmi,\r\nenum port_fdmi_event event)\r\n{\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nbfa_trc(port->fcs, event);\r\n}\r\nstatic void\r\nbfa_fcs_lport_fdmi_send_rhba(void *fdmi_cbarg, struct bfa_fcxp_s *fcxp_alloced)\r\n{\r\nstruct bfa_fcs_lport_fdmi_s *fdmi = fdmi_cbarg;\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nstruct fchs_s fchs;\r\nint len, attr_len;\r\nstruct bfa_fcxp_s *fcxp;\r\nu8 *pyld;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nfcxp = fcxp_alloced ? fcxp_alloced :\r\nbfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\r\nif (!fcxp) {\r\nbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &fdmi->fcxp_wqe,\r\nbfa_fcs_lport_fdmi_send_rhba, fdmi, BFA_TRUE);\r\nreturn;\r\n}\r\nfdmi->fcxp = fcxp;\r\npyld = bfa_fcxp_get_reqbuf(fcxp);\r\nmemset(pyld, 0, FC_MAX_PDUSZ);\r\nlen = fc_fdmi_reqhdr_build(&fchs, pyld, bfa_fcs_lport_get_fcid(port),\r\nFDMI_RHBA);\r\nattr_len =\r\nbfa_fcs_lport_fdmi_build_rhba_pyld(fdmi,\r\n(u8 *) ((struct ct_hdr_s *) pyld\r\n+ 1));\r\nbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\r\nFC_CLASS_3, (len + attr_len), &fchs,\r\nbfa_fcs_lport_fdmi_rhba_response, (void *)fdmi,\r\nFC_MAX_PDUSZ, FC_FCCT_TOV);\r\nbfa_sm_send_event(fdmi, FDMISM_EVENT_RHBA_SENT);\r\n}\r\nstatic u16\r\nbfa_fcs_lport_fdmi_build_rhba_pyld(struct bfa_fcs_lport_fdmi_s *fdmi, u8 *pyld)\r\n{\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nstruct bfa_fcs_fdmi_hba_attr_s hba_attr;\r\nstruct bfa_fcs_fdmi_hba_attr_s *fcs_hba_attr = &hba_attr;\r\nstruct fdmi_rhba_s *rhba = (struct fdmi_rhba_s *) pyld;\r\nstruct fdmi_attr_s *attr;\r\nu8 *curr_ptr;\r\nu16 len, count;\r\nu16 templen;\r\nbfa_fcs_fdmi_get_hbaattr(fdmi, fcs_hba_attr);\r\nrhba->hba_id = bfa_fcs_lport_get_pwwn(port);\r\nrhba->port_list.num_ports = cpu_to_be32(1);\r\nrhba->port_list.port_entry = bfa_fcs_lport_get_pwwn(port);\r\nlen = sizeof(rhba->hba_id) + sizeof(rhba->port_list);\r\ncount = 0;\r\nlen += sizeof(rhba->hba_attr_blk.attr_count);\r\ncurr_ptr = (u8 *) &rhba->hba_attr_blk.hba_attr;\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_NODENAME);\r\ntemplen = sizeof(wwn_t);\r\nmemcpy(attr->value, &bfa_fcs_lport_get_nwwn(port), templen);\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\ncount++;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_MANUFACTURER);\r\ntemplen = (u16) strlen(fcs_hba_attr->manufacturer);\r\nmemcpy(attr->value, fcs_hba_attr->manufacturer, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\ncount++;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_SERIALNUM);\r\ntemplen = (u16) strlen(fcs_hba_attr->serial_num);\r\nmemcpy(attr->value, fcs_hba_attr->serial_num, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\ncount++;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_MODEL);\r\ntemplen = (u16) strlen(fcs_hba_attr->model);\r\nmemcpy(attr->value, fcs_hba_attr->model, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\ncount++;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_MODEL_DESC);\r\ntemplen = (u16) strlen(fcs_hba_attr->model_desc);\r\nmemcpy(attr->value, fcs_hba_attr->model_desc, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\ncount++;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nif (fcs_hba_attr->hw_version[0] != '\0') {\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_HW_VERSION);\r\ntemplen = (u16) strlen(fcs_hba_attr->hw_version);\r\nmemcpy(attr->value, fcs_hba_attr->hw_version, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\ncount++;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\n}\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_DRIVER_VERSION);\r\ntemplen = (u16) strlen(fcs_hba_attr->driver_version);\r\nmemcpy(attr->value, fcs_hba_attr->driver_version, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\ncount++;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nif (fcs_hba_attr->option_rom_ver[0] != '\0') {\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_ROM_VERSION);\r\ntemplen = (u16) strlen(fcs_hba_attr->option_rom_ver);\r\nmemcpy(attr->value, fcs_hba_attr->option_rom_ver, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\ncount++;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\n}\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_FW_VERSION);\r\ntemplen = (u16) strlen(fcs_hba_attr->fw_version);\r\nmemcpy(attr->value, fcs_hba_attr->fw_version, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\ncount++;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nif (fcs_hba_attr->os_name[0] != '\0') {\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_OS_NAME);\r\ntemplen = (u16) strlen(fcs_hba_attr->os_name);\r\nmemcpy(attr->value, fcs_hba_attr->os_name, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\ncount++;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\n}\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_MAX_CT);\r\ntemplen = sizeof(fcs_hba_attr->max_ct_pyld);\r\nmemcpy(attr->value, &fcs_hba_attr->max_ct_pyld, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\ncount++;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nif (fdmi->retry_cnt == 0) {\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_NODE_SYM_NAME);\r\ntemplen = sizeof(fcs_hba_attr->node_sym_name);\r\nmemcpy(attr->value, &fcs_hba_attr->node_sym_name, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\ncount++;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_VENDOR_ID);\r\ntemplen = sizeof(fcs_hba_attr->vendor_info);\r\nmemcpy(attr->value, &fcs_hba_attr->vendor_info, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\ncount++;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_NUM_PORTS);\r\ntemplen = sizeof(fcs_hba_attr->num_ports);\r\nmemcpy(attr->value, &fcs_hba_attr->num_ports, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\ncount++;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_FABRIC_NAME);\r\ntemplen = sizeof(fcs_hba_attr->fabric_name);\r\nmemcpy(attr->value, &fcs_hba_attr->fabric_name, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\ncount++;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_BIOS_VER);\r\ntemplen = sizeof(fcs_hba_attr->bios_ver);\r\nmemcpy(attr->value, &fcs_hba_attr->bios_ver, templen);\r\ntemplen = fc_roundup(attr->len, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\ncount++;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\n}\r\nlen += ((sizeof(attr->type) + sizeof(attr->len)) * count);\r\nrhba->hba_attr_blk.attr_count = cpu_to_be32(count);\r\nreturn len;\r\n}\r\nstatic void\r\nbfa_fcs_lport_fdmi_rhba_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\r\nvoid *cbarg, bfa_status_t req_status,\r\nu32 rsp_len, u32 resid_len,\r\nstruct fchs_s *rsp_fchs)\r\n{\r\nstruct bfa_fcs_lport_fdmi_s *fdmi =\r\n(struct bfa_fcs_lport_fdmi_s *) cbarg;\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nstruct ct_hdr_s *cthdr = NULL;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nif (req_status != BFA_STATUS_OK) {\r\nbfa_trc(port->fcs, req_status);\r\nbfa_sm_send_event(fdmi, FDMISM_EVENT_RSP_ERROR);\r\nreturn;\r\n}\r\ncthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\r\ncthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\r\nif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\r\nbfa_sm_send_event(fdmi, FDMISM_EVENT_RSP_OK);\r\nreturn;\r\n}\r\nbfa_trc(port->fcs, cthdr->reason_code);\r\nbfa_trc(port->fcs, cthdr->exp_code);\r\nbfa_sm_send_event(fdmi, FDMISM_EVENT_RSP_ERROR);\r\n}\r\nstatic void\r\nbfa_fcs_lport_fdmi_send_rprt(void *fdmi_cbarg, struct bfa_fcxp_s *fcxp_alloced)\r\n{\r\nstruct bfa_fcs_lport_fdmi_s *fdmi = fdmi_cbarg;\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nstruct fchs_s fchs;\r\nu16 len, attr_len;\r\nstruct bfa_fcxp_s *fcxp;\r\nu8 *pyld;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nfcxp = fcxp_alloced ? fcxp_alloced :\r\nbfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\r\nif (!fcxp) {\r\nbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &fdmi->fcxp_wqe,\r\nbfa_fcs_lport_fdmi_send_rprt, fdmi, BFA_TRUE);\r\nreturn;\r\n}\r\nfdmi->fcxp = fcxp;\r\npyld = bfa_fcxp_get_reqbuf(fcxp);\r\nmemset(pyld, 0, FC_MAX_PDUSZ);\r\nlen = fc_fdmi_reqhdr_build(&fchs, pyld, bfa_fcs_lport_get_fcid(port),\r\nFDMI_RPRT);\r\nattr_len =\r\nbfa_fcs_lport_fdmi_build_rprt_pyld(fdmi,\r\n(u8 *) ((struct ct_hdr_s *) pyld\r\n+ 1));\r\nbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\r\nFC_CLASS_3, len + attr_len, &fchs,\r\nbfa_fcs_lport_fdmi_rprt_response, (void *)fdmi,\r\nFC_MAX_PDUSZ, FC_FCCT_TOV);\r\nbfa_sm_send_event(fdmi, FDMISM_EVENT_RPRT_SENT);\r\n}\r\nstatic u16\r\nbfa_fcs_lport_fdmi_build_portattr_block(struct bfa_fcs_lport_fdmi_s *fdmi,\r\nu8 *pyld)\r\n{\r\nstruct bfa_fcs_fdmi_port_attr_s fcs_port_attr;\r\nstruct fdmi_port_attr_s *port_attrib = (struct fdmi_port_attr_s *) pyld;\r\nstruct fdmi_attr_s *attr;\r\nu8 *curr_ptr;\r\nu16 len;\r\nu8 count = 0;\r\nu16 templen;\r\nbfa_fcs_fdmi_get_portattr(fdmi, &fcs_port_attr);\r\nlen = sizeof(port_attrib->attr_count);\r\ncurr_ptr = (u8 *) &port_attrib->port_attr;\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_FC4_TYPES);\r\ntemplen = sizeof(fcs_port_attr.supp_fc4_types);\r\nmemcpy(attr->value, fcs_port_attr.supp_fc4_types, templen);\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\n++count;\r\nattr->len =\r\ncpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_SUPP_SPEED);\r\ntemplen = sizeof(fcs_port_attr.supp_speed);\r\nmemcpy(attr->value, &fcs_port_attr.supp_speed, templen);\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\n++count;\r\nattr->len =\r\ncpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_PORT_SPEED);\r\ntemplen = sizeof(fcs_port_attr.curr_speed);\r\nmemcpy(attr->value, &fcs_port_attr.curr_speed, templen);\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\n++count;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_FRAME_SIZE);\r\ntemplen = sizeof(fcs_port_attr.max_frm_size);\r\nmemcpy(attr->value, &fcs_port_attr.max_frm_size, templen);\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\n++count;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nif (fcs_port_attr.os_device_name[0] != '\0') {\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_DEV_NAME);\r\ntemplen = (u16) strlen(fcs_port_attr.os_device_name);\r\nmemcpy(attr->value, fcs_port_attr.os_device_name, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\n++count;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\n}\r\nif (fcs_port_attr.host_name[0] != '\0') {\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_HOST_NAME);\r\ntemplen = (u16) strlen(fcs_port_attr.host_name);\r\nmemcpy(attr->value, fcs_port_attr.host_name, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\n++count;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\n}\r\nif (fdmi->retry_cnt == 0) {\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_NODE_NAME);\r\ntemplen = sizeof(fcs_port_attr.node_name);\r\nmemcpy(attr->value, &fcs_port_attr.node_name, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\n++count;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_PORT_NAME);\r\ntemplen = sizeof(fcs_port_attr.port_name);\r\nmemcpy(attr->value, &fcs_port_attr.port_name, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(attr->len) + templen;\r\nlen += templen;\r\n++count;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nif (fcs_port_attr.port_sym_name.symname[0] != '\0') {\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type =\r\ncpu_to_be16(FDMI_PORT_ATTRIB_PORT_SYM_NAME);\r\ntemplen = sizeof(fcs_port_attr.port_sym_name);\r\nmemcpy(attr->value,\r\n&fcs_port_attr.port_sym_name, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) +\r\nsizeof(templen) + templen;\r\nlen += templen;\r\n++count;\r\nattr->len = cpu_to_be16(templen +\r\nsizeof(attr->type) + sizeof(templen));\r\n}\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_PORT_TYPE);\r\ntemplen = sizeof(fcs_port_attr.port_type);\r\nmemcpy(attr->value, &fcs_port_attr.port_type, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\n++count;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_SUPP_COS);\r\ntemplen = sizeof(fcs_port_attr.scos);\r\nmemcpy(attr->value, &fcs_port_attr.scos, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\n++count;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_PORT_FAB_NAME);\r\ntemplen = sizeof(fcs_port_attr.port_fabric_name);\r\nmemcpy(attr->value, &fcs_port_attr.port_fabric_name, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\n++count;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_PORT_FC4_TYPE);\r\ntemplen = sizeof(fcs_port_attr.port_act_fc4_type);\r\nmemcpy(attr->value, fcs_port_attr.port_act_fc4_type,\r\ntemplen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\n++count;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_PORT_STATE);\r\ntemplen = sizeof(fcs_port_attr.port_state);\r\nmemcpy(attr->value, &fcs_port_attr.port_state, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\n++count;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\nattr = (struct fdmi_attr_s *) curr_ptr;\r\nattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_PORT_NUM_RPRT);\r\ntemplen = sizeof(fcs_port_attr.num_ports);\r\nmemcpy(attr->value, &fcs_port_attr.num_ports, templen);\r\ntemplen = fc_roundup(templen, sizeof(u32));\r\ncurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\r\nlen += templen;\r\n++count;\r\nattr->len = cpu_to_be16(templen + sizeof(attr->type) +\r\nsizeof(templen));\r\n}\r\nport_attrib->attr_count = cpu_to_be32(count);\r\nlen += ((sizeof(attr->type) + sizeof(attr->len)) * count);\r\nreturn len;\r\n}\r\nstatic u16\r\nbfa_fcs_lport_fdmi_build_rprt_pyld(struct bfa_fcs_lport_fdmi_s *fdmi, u8 *pyld)\r\n{\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nstruct fdmi_rprt_s *rprt = (struct fdmi_rprt_s *) pyld;\r\nu16 len;\r\nrprt->hba_id = bfa_fcs_lport_get_pwwn(bfa_fcs_get_base_port(port->fcs));\r\nrprt->port_name = bfa_fcs_lport_get_pwwn(port);\r\nlen = bfa_fcs_lport_fdmi_build_portattr_block(fdmi,\r\n(u8 *) &rprt->port_attr_blk);\r\nlen += sizeof(rprt->hba_id) + sizeof(rprt->port_name);\r\nreturn len;\r\n}\r\nstatic void\r\nbfa_fcs_lport_fdmi_rprt_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\r\nvoid *cbarg, bfa_status_t req_status,\r\nu32 rsp_len, u32 resid_len,\r\nstruct fchs_s *rsp_fchs)\r\n{\r\nstruct bfa_fcs_lport_fdmi_s *fdmi =\r\n(struct bfa_fcs_lport_fdmi_s *) cbarg;\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nstruct ct_hdr_s *cthdr = NULL;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nif (req_status != BFA_STATUS_OK) {\r\nbfa_trc(port->fcs, req_status);\r\nbfa_sm_send_event(fdmi, FDMISM_EVENT_RSP_ERROR);\r\nreturn;\r\n}\r\ncthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\r\ncthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\r\nif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\r\nbfa_sm_send_event(fdmi, FDMISM_EVENT_RSP_OK);\r\nreturn;\r\n}\r\nbfa_trc(port->fcs, cthdr->reason_code);\r\nbfa_trc(port->fcs, cthdr->exp_code);\r\nbfa_sm_send_event(fdmi, FDMISM_EVENT_RSP_ERROR);\r\n}\r\nstatic void\r\nbfa_fcs_lport_fdmi_send_rpa(void *fdmi_cbarg, struct bfa_fcxp_s *fcxp_alloced)\r\n{\r\nstruct bfa_fcs_lport_fdmi_s *fdmi = fdmi_cbarg;\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nstruct fchs_s fchs;\r\nu16 len, attr_len;\r\nstruct bfa_fcxp_s *fcxp;\r\nu8 *pyld;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nfcxp = fcxp_alloced ? fcxp_alloced :\r\nbfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\r\nif (!fcxp) {\r\nbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &fdmi->fcxp_wqe,\r\nbfa_fcs_lport_fdmi_send_rpa, fdmi, BFA_TRUE);\r\nreturn;\r\n}\r\nfdmi->fcxp = fcxp;\r\npyld = bfa_fcxp_get_reqbuf(fcxp);\r\nmemset(pyld, 0, FC_MAX_PDUSZ);\r\nlen = fc_fdmi_reqhdr_build(&fchs, pyld, bfa_fcs_lport_get_fcid(port),\r\nFDMI_RPA);\r\nattr_len = bfa_fcs_lport_fdmi_build_rpa_pyld(fdmi,\r\n(u8 *) ((struct ct_hdr_s *) pyld + 1));\r\nbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\r\nFC_CLASS_3, len + attr_len, &fchs,\r\nbfa_fcs_lport_fdmi_rpa_response, (void *)fdmi,\r\nFC_MAX_PDUSZ, FC_FCCT_TOV);\r\nbfa_sm_send_event(fdmi, FDMISM_EVENT_RPA_SENT);\r\n}\r\nstatic u16\r\nbfa_fcs_lport_fdmi_build_rpa_pyld(struct bfa_fcs_lport_fdmi_s *fdmi, u8 *pyld)\r\n{\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nstruct fdmi_rpa_s *rpa = (struct fdmi_rpa_s *) pyld;\r\nu16 len;\r\nrpa->port_name = bfa_fcs_lport_get_pwwn(port);\r\nlen = bfa_fcs_lport_fdmi_build_portattr_block(fdmi,\r\n(u8 *) &rpa->port_attr_blk);\r\nlen += sizeof(rpa->port_name);\r\nreturn len;\r\n}\r\nstatic void\r\nbfa_fcs_lport_fdmi_rpa_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\r\nvoid *cbarg, bfa_status_t req_status, u32 rsp_len,\r\nu32 resid_len, struct fchs_s *rsp_fchs)\r\n{\r\nstruct bfa_fcs_lport_fdmi_s *fdmi =\r\n(struct bfa_fcs_lport_fdmi_s *) cbarg;\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nstruct ct_hdr_s *cthdr = NULL;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nif (req_status != BFA_STATUS_OK) {\r\nbfa_trc(port->fcs, req_status);\r\nbfa_sm_send_event(fdmi, FDMISM_EVENT_RSP_ERROR);\r\nreturn;\r\n}\r\ncthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\r\ncthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\r\nif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\r\nbfa_sm_send_event(fdmi, FDMISM_EVENT_RSP_OK);\r\nreturn;\r\n}\r\nbfa_trc(port->fcs, cthdr->reason_code);\r\nbfa_trc(port->fcs, cthdr->exp_code);\r\nbfa_sm_send_event(fdmi, FDMISM_EVENT_RSP_ERROR);\r\n}\r\nstatic void\r\nbfa_fcs_lport_fdmi_timeout(void *arg)\r\n{\r\nstruct bfa_fcs_lport_fdmi_s *fdmi = (struct bfa_fcs_lport_fdmi_s *) arg;\r\nbfa_sm_send_event(fdmi, FDMISM_EVENT_TIMEOUT);\r\n}\r\nstatic void\r\nbfa_fcs_fdmi_get_hbaattr(struct bfa_fcs_lport_fdmi_s *fdmi,\r\nstruct bfa_fcs_fdmi_hba_attr_s *hba_attr)\r\n{\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nstruct bfa_fcs_driver_info_s *driver_info = &port->fcs->driver_info;\r\nstruct bfa_fcs_fdmi_port_attr_s fcs_port_attr;\r\nmemset(hba_attr, 0, sizeof(struct bfa_fcs_fdmi_hba_attr_s));\r\nbfa_ioc_get_adapter_manufacturer(&port->fcs->bfa->ioc,\r\nhba_attr->manufacturer);\r\nbfa_ioc_get_adapter_serial_num(&port->fcs->bfa->ioc,\r\nhba_attr->serial_num);\r\nbfa_ioc_get_adapter_model(&port->fcs->bfa->ioc,\r\nhba_attr->model);\r\nbfa_ioc_get_adapter_model(&port->fcs->bfa->ioc,\r\nhba_attr->model_desc);\r\nbfa_ioc_get_pci_chip_rev(&port->fcs->bfa->ioc,\r\nhba_attr->hw_version);\r\nbfa_ioc_get_adapter_optrom_ver(&port->fcs->bfa->ioc,\r\nhba_attr->option_rom_ver);\r\nbfa_ioc_get_adapter_fw_ver(&port->fcs->bfa->ioc,\r\nhba_attr->fw_version);\r\nstrncpy(hba_attr->driver_version, (char *)driver_info->version,\r\nsizeof(hba_attr->driver_version));\r\nstrncpy(hba_attr->os_name, driver_info->host_os_name,\r\nsizeof(hba_attr->os_name));\r\nif (driver_info->host_os_patch[0] != '\0') {\r\nstrncat(hba_attr->os_name, BFA_FCS_PORT_SYMBNAME_SEPARATOR,\r\nsizeof(BFA_FCS_PORT_SYMBNAME_SEPARATOR));\r\nstrncat(hba_attr->os_name, driver_info->host_os_patch,\r\nsizeof(driver_info->host_os_patch));\r\n}\r\nbfa_fcs_fdmi_get_portattr(fdmi, &fcs_port_attr);\r\nhba_attr->max_ct_pyld = fcs_port_attr.max_frm_size;\r\nstrncpy(hba_attr->node_sym_name.symname,\r\nport->port_cfg.node_sym_name.symname, BFA_SYMNAME_MAXLEN);\r\nstrcpy(hba_attr->vendor_info, "BROCADE");\r\nhba_attr->num_ports =\r\ncpu_to_be32(bfa_ioc_get_nports(&port->fcs->bfa->ioc));\r\nhba_attr->fabric_name = port->fabric->lps->pr_nwwn;\r\nstrncpy(hba_attr->bios_ver, hba_attr->option_rom_ver, BFA_VERSION_LEN);\r\n}\r\nstatic void\r\nbfa_fcs_fdmi_get_portattr(struct bfa_fcs_lport_fdmi_s *fdmi,\r\nstruct bfa_fcs_fdmi_port_attr_s *port_attr)\r\n{\r\nstruct bfa_fcs_lport_s *port = fdmi->ms->port;\r\nstruct bfa_fcs_driver_info_s *driver_info = &port->fcs->driver_info;\r\nstruct bfa_port_attr_s pport_attr;\r\nstruct bfa_lport_attr_s lport_attr;\r\nmemset(port_attr, 0, sizeof(struct bfa_fcs_fdmi_port_attr_s));\r\nbfa_fcport_get_attr(port->fcs->bfa, &pport_attr);\r\nfc_get_fc4type_bitmask(FC_TYPE_FCP, port_attr->supp_fc4_types);\r\nswitch (pport_attr.speed_supported) {\r\ncase BFA_PORT_SPEED_16GBPS:\r\nport_attr->supp_speed =\r\ncpu_to_be32(BFA_FCS_FDMI_SUPP_SPEEDS_16G);\r\nbreak;\r\ncase BFA_PORT_SPEED_10GBPS:\r\nport_attr->supp_speed =\r\ncpu_to_be32(BFA_FCS_FDMI_SUPP_SPEEDS_10G);\r\nbreak;\r\ncase BFA_PORT_SPEED_8GBPS:\r\nport_attr->supp_speed =\r\ncpu_to_be32(BFA_FCS_FDMI_SUPP_SPEEDS_8G);\r\nbreak;\r\ncase BFA_PORT_SPEED_4GBPS:\r\nport_attr->supp_speed =\r\ncpu_to_be32(BFA_FCS_FDMI_SUPP_SPEEDS_4G);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(port->fcs, pport_attr.speed_supported);\r\n}\r\nport_attr->curr_speed = cpu_to_be32(\r\nbfa_fcs_fdmi_convert_speed(pport_attr.speed));\r\nport_attr->max_frm_size = cpu_to_be32(pport_attr.pport_cfg.maxfrsize);\r\nstrncpy(port_attr->os_device_name, (char *)driver_info->os_device_name,\r\nsizeof(port_attr->os_device_name));\r\nstrncpy(port_attr->host_name, (char *)driver_info->host_machine_name,\r\nsizeof(port_attr->host_name));\r\nport_attr->node_name = bfa_fcs_lport_get_nwwn(port);\r\nport_attr->port_name = bfa_fcs_lport_get_pwwn(port);\r\nstrncpy(port_attr->port_sym_name.symname,\r\n(char *)&bfa_fcs_lport_get_psym_name(port), BFA_SYMNAME_MAXLEN);\r\nbfa_fcs_lport_get_attr(port, &lport_attr);\r\nport_attr->port_type = cpu_to_be32(lport_attr.port_type);\r\nport_attr->scos = pport_attr.cos_supported;\r\nport_attr->port_fabric_name = port->fabric->lps->pr_nwwn;\r\nfc_get_fc4type_bitmask(FC_TYPE_FCP, port_attr->port_act_fc4_type);\r\nport_attr->port_state = cpu_to_be32(pport_attr.port_state);\r\nport_attr->num_ports = cpu_to_be32(port->num_rports);\r\n}\r\nu32\r\nbfa_fcs_fdmi_convert_speed(bfa_port_speed_t pport_speed)\r\n{\r\nu32 ret;\r\nswitch (pport_speed) {\r\ncase BFA_PORT_SPEED_1GBPS:\r\ncase BFA_PORT_SPEED_2GBPS:\r\nret = pport_speed;\r\nbreak;\r\ncase BFA_PORT_SPEED_4GBPS:\r\nret = FDMI_TRANS_SPEED_4G;\r\nbreak;\r\ncase BFA_PORT_SPEED_8GBPS:\r\nret = FDMI_TRANS_SPEED_8G;\r\nbreak;\r\ncase BFA_PORT_SPEED_10GBPS:\r\nret = FDMI_TRANS_SPEED_10G;\r\nbreak;\r\ncase BFA_PORT_SPEED_16GBPS:\r\nret = FDMI_TRANS_SPEED_16G;\r\nbreak;\r\ndefault:\r\nret = FDMI_TRANS_SPEED_UNKNOWN;\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nbfa_fcs_lport_fdmi_init(struct bfa_fcs_lport_ms_s *ms)\r\n{\r\nstruct bfa_fcs_lport_fdmi_s *fdmi = &ms->fdmi;\r\nfdmi->ms = ms;\r\nif (ms->port->fcs->fdmi_enabled)\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\r\nelse\r\nbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_disabled);\r\n}\r\nvoid\r\nbfa_fcs_lport_fdmi_offline(struct bfa_fcs_lport_ms_s *ms)\r\n{\r\nstruct bfa_fcs_lport_fdmi_s *fdmi = &ms->fdmi;\r\nfdmi->ms = ms;\r\nbfa_sm_send_event(fdmi, FDMISM_EVENT_PORT_OFFLINE);\r\n}\r\nvoid\r\nbfa_fcs_lport_fdmi_online(struct bfa_fcs_lport_ms_s *ms)\r\n{\r\nstruct bfa_fcs_lport_fdmi_s *fdmi = &ms->fdmi;\r\nfdmi->ms = ms;\r\nbfa_sm_send_event(fdmi, FDMISM_EVENT_PORT_ONLINE);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ms_sm_offline(struct bfa_fcs_lport_ms_s *ms,\r\nenum port_ms_event event)\r\n{\r\nbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\r\nbfa_trc(ms->port->fcs, event);\r\nswitch (event) {\r\ncase MSSM_EVENT_PORT_ONLINE:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_plogi_sending);\r\nbfa_fcs_lport_ms_send_plogi(ms, NULL);\r\nbreak;\r\ncase MSSM_EVENT_PORT_OFFLINE:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ms->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ms_sm_plogi_sending(struct bfa_fcs_lport_ms_s *ms,\r\nenum port_ms_event event)\r\n{\r\nbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\r\nbfa_trc(ms->port->fcs, event);\r\nswitch (event) {\r\ncase MSSM_EVENT_FCXP_SENT:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_plogi);\r\nbreak;\r\ncase MSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\r\nbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ms->port),\r\n&ms->fcxp_wqe);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ms->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ms_sm_plogi(struct bfa_fcs_lport_ms_s *ms,\r\nenum port_ms_event event)\r\n{\r\nbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\r\nbfa_trc(ms->port->fcs, event);\r\nswitch (event) {\r\ncase MSSM_EVENT_RSP_ERROR:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_plogi_retry);\r\nms->port->stats.ms_retries++;\r\nbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ms->port),\r\n&ms->timer, bfa_fcs_lport_ms_timeout, ms,\r\nBFA_FCS_RETRY_TIMEOUT);\r\nbreak;\r\ncase MSSM_EVENT_RSP_OK:\r\nbfa_fcs_lport_fdmi_online(ms);\r\nif (ms->port->vport) {\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_online);\r\nbreak;\r\n}\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gmal_sending);\r\nbfa_fcs_lport_ms_send_gmal(ms, NULL);\r\nbreak;\r\ncase MSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\r\nbfa_fcxp_discard(ms->fcxp);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ms->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ms_sm_plogi_retry(struct bfa_fcs_lport_ms_s *ms,\r\nenum port_ms_event event)\r\n{\r\nbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\r\nbfa_trc(ms->port->fcs, event);\r\nswitch (event) {\r\ncase MSSM_EVENT_TIMEOUT:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_plogi_sending);\r\nbfa_fcs_lport_ms_send_plogi(ms, NULL);\r\nbreak;\r\ncase MSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\r\nbfa_timer_stop(&ms->timer);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ms->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ms_sm_online(struct bfa_fcs_lport_ms_s *ms,\r\nenum port_ms_event event)\r\n{\r\nbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\r\nbfa_trc(ms->port->fcs, event);\r\nswitch (event) {\r\ncase MSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\r\nbreak;\r\ncase MSSM_EVENT_PORT_FABRIC_RSCN:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gfn_sending);\r\nms->retry_cnt = 0;\r\nbfa_fcs_lport_ms_send_gfn(ms, NULL);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ms->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ms_sm_gmal_sending(struct bfa_fcs_lport_ms_s *ms,\r\nenum port_ms_event event)\r\n{\r\nbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\r\nbfa_trc(ms->port->fcs, event);\r\nswitch (event) {\r\ncase MSSM_EVENT_FCXP_SENT:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gmal);\r\nbreak;\r\ncase MSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\r\nbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ms->port),\r\n&ms->fcxp_wqe);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ms->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ms_sm_gmal(struct bfa_fcs_lport_ms_s *ms,\r\nenum port_ms_event event)\r\n{\r\nbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\r\nbfa_trc(ms->port->fcs, event);\r\nswitch (event) {\r\ncase MSSM_EVENT_RSP_ERROR:\r\nif (ms->retry_cnt++ < BFA_FCS_MS_CMD_MAX_RETRIES) {\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gmal_retry);\r\nms->port->stats.ms_retries++;\r\nbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ms->port),\r\n&ms->timer, bfa_fcs_lport_ms_timeout, ms,\r\nBFA_FCS_RETRY_TIMEOUT);\r\n} else {\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gfn_sending);\r\nbfa_fcs_lport_ms_send_gfn(ms, NULL);\r\nms->retry_cnt = 0;\r\n}\r\nbreak;\r\ncase MSSM_EVENT_RSP_OK:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gfn_sending);\r\nbfa_fcs_lport_ms_send_gfn(ms, NULL);\r\nbreak;\r\ncase MSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\r\nbfa_fcxp_discard(ms->fcxp);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ms->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ms_sm_gmal_retry(struct bfa_fcs_lport_ms_s *ms,\r\nenum port_ms_event event)\r\n{\r\nbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\r\nbfa_trc(ms->port->fcs, event);\r\nswitch (event) {\r\ncase MSSM_EVENT_TIMEOUT:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gmal_sending);\r\nbfa_fcs_lport_ms_send_gmal(ms, NULL);\r\nbreak;\r\ncase MSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\r\nbfa_timer_stop(&ms->timer);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ms->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ms_send_gmal(void *ms_cbarg, struct bfa_fcxp_s *fcxp_alloced)\r\n{\r\nstruct bfa_fcs_lport_ms_s *ms = ms_cbarg;\r\nbfa_fcs_lport_t *port = ms->port;\r\nstruct fchs_s fchs;\r\nint len;\r\nstruct bfa_fcxp_s *fcxp;\r\nbfa_trc(port->fcs, port->pid);\r\nfcxp = fcxp_alloced ? fcxp_alloced :\r\nbfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\r\nif (!fcxp) {\r\nbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ms->fcxp_wqe,\r\nbfa_fcs_lport_ms_send_gmal, ms, BFA_TRUE);\r\nreturn;\r\n}\r\nms->fcxp = fcxp;\r\nlen = fc_gmal_req_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\r\nbfa_fcs_lport_get_fcid(port),\r\nport->fabric->lps->pr_nwwn);\r\nbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\r\nFC_CLASS_3, len, &fchs,\r\nbfa_fcs_lport_ms_gmal_response, (void *)ms,\r\nFC_MAX_PDUSZ, FC_FCCT_TOV);\r\nbfa_sm_send_event(ms, MSSM_EVENT_FCXP_SENT);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ms_gmal_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\r\nvoid *cbarg, bfa_status_t req_status,\r\nu32 rsp_len, u32 resid_len,\r\nstruct fchs_s *rsp_fchs)\r\n{\r\nstruct bfa_fcs_lport_ms_s *ms = (struct bfa_fcs_lport_ms_s *) cbarg;\r\nbfa_fcs_lport_t *port = ms->port;\r\nstruct ct_hdr_s *cthdr = NULL;\r\nstruct fcgs_gmal_resp_s *gmal_resp;\r\nstruct fcgs_gmal_entry_s *gmal_entry;\r\nu32 num_entries;\r\nu8 *rsp_str;\r\nbfa_trc(port->fcs, req_status);\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nif (req_status != BFA_STATUS_OK) {\r\nbfa_trc(port->fcs, req_status);\r\nbfa_sm_send_event(ms, MSSM_EVENT_RSP_ERROR);\r\nreturn;\r\n}\r\ncthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\r\ncthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\r\nif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\r\ngmal_resp = (struct fcgs_gmal_resp_s *)(cthdr + 1);\r\nnum_entries = be32_to_cpu(gmal_resp->ms_len);\r\nif (num_entries == 0) {\r\nbfa_sm_send_event(ms, MSSM_EVENT_RSP_ERROR);\r\nreturn;\r\n}\r\ngmal_entry = (struct fcgs_gmal_entry_s *)gmal_resp->ms_ma;\r\nwhile (num_entries > 0) {\r\nif (strncmp(gmal_entry->prefix,\r\nCT_GMAL_RESP_PREFIX_HTTP,\r\nsizeof(gmal_entry->prefix)) == 0) {\r\nrsp_str = &(gmal_entry->prefix[0]);\r\nif (rsp_str[gmal_entry->len-1] == '/')\r\nrsp_str[gmal_entry->len-1] = 0;\r\nstrncpy(bfa_fcs_lport_get_fabric_ipaddr(port),\r\ngmal_entry->ip_addr,\r\nBFA_FCS_FABRIC_IPADDR_SZ);\r\nbreak;\r\n} else {\r\n--num_entries;\r\n++gmal_entry;\r\n}\r\n}\r\nbfa_sm_send_event(ms, MSSM_EVENT_RSP_OK);\r\nreturn;\r\n}\r\nbfa_trc(port->fcs, cthdr->reason_code);\r\nbfa_trc(port->fcs, cthdr->exp_code);\r\nbfa_sm_send_event(ms, MSSM_EVENT_RSP_ERROR);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ms_sm_gfn_sending(struct bfa_fcs_lport_ms_s *ms,\r\nenum port_ms_event event)\r\n{\r\nbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\r\nbfa_trc(ms->port->fcs, event);\r\nswitch (event) {\r\ncase MSSM_EVENT_FCXP_SENT:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gfn);\r\nbreak;\r\ncase MSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\r\nbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ms->port),\r\n&ms->fcxp_wqe);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ms->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ms_sm_gfn(struct bfa_fcs_lport_ms_s *ms,\r\nenum port_ms_event event)\r\n{\r\nbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\r\nbfa_trc(ms->port->fcs, event);\r\nswitch (event) {\r\ncase MSSM_EVENT_RSP_ERROR:\r\nif (ms->retry_cnt++ < BFA_FCS_MS_CMD_MAX_RETRIES) {\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gfn_retry);\r\nms->port->stats.ms_retries++;\r\nbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ms->port),\r\n&ms->timer, bfa_fcs_lport_ms_timeout, ms,\r\nBFA_FCS_RETRY_TIMEOUT);\r\n} else {\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_online);\r\nms->retry_cnt = 0;\r\n}\r\nbreak;\r\ncase MSSM_EVENT_RSP_OK:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_online);\r\nbreak;\r\ncase MSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\r\nbfa_fcxp_discard(ms->fcxp);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ms->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ms_sm_gfn_retry(struct bfa_fcs_lport_ms_s *ms,\r\nenum port_ms_event event)\r\n{\r\nbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\r\nbfa_trc(ms->port->fcs, event);\r\nswitch (event) {\r\ncase MSSM_EVENT_TIMEOUT:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gfn_sending);\r\nbfa_fcs_lport_ms_send_gfn(ms, NULL);\r\nbreak;\r\ncase MSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\r\nbfa_timer_stop(&ms->timer);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ms->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ms_send_gfn(void *ms_cbarg, struct bfa_fcxp_s *fcxp_alloced)\r\n{\r\nstruct bfa_fcs_lport_ms_s *ms = ms_cbarg;\r\nbfa_fcs_lport_t *port = ms->port;\r\nstruct fchs_s fchs;\r\nint len;\r\nstruct bfa_fcxp_s *fcxp;\r\nbfa_trc(port->fcs, port->pid);\r\nfcxp = fcxp_alloced ? fcxp_alloced :\r\nbfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\r\nif (!fcxp) {\r\nbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ms->fcxp_wqe,\r\nbfa_fcs_lport_ms_send_gfn, ms, BFA_TRUE);\r\nreturn;\r\n}\r\nms->fcxp = fcxp;\r\nlen = fc_gfn_req_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\r\nbfa_fcs_lport_get_fcid(port),\r\nport->fabric->lps->pr_nwwn);\r\nbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\r\nFC_CLASS_3, len, &fchs,\r\nbfa_fcs_lport_ms_gfn_response, (void *)ms,\r\nFC_MAX_PDUSZ, FC_FCCT_TOV);\r\nbfa_sm_send_event(ms, MSSM_EVENT_FCXP_SENT);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ms_gfn_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\r\nvoid *cbarg, bfa_status_t req_status, u32 rsp_len,\r\nu32 resid_len, struct fchs_s *rsp_fchs)\r\n{\r\nstruct bfa_fcs_lport_ms_s *ms = (struct bfa_fcs_lport_ms_s *) cbarg;\r\nbfa_fcs_lport_t *port = ms->port;\r\nstruct ct_hdr_s *cthdr = NULL;\r\nwwn_t *gfn_resp;\r\nbfa_trc(port->fcs, req_status);\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nif (req_status != BFA_STATUS_OK) {\r\nbfa_trc(port->fcs, req_status);\r\nbfa_sm_send_event(ms, MSSM_EVENT_RSP_ERROR);\r\nreturn;\r\n}\r\ncthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\r\ncthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\r\nif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\r\ngfn_resp = (wwn_t *)(cthdr + 1);\r\nif ((memcmp((void *)&bfa_fcs_lport_get_fabric_name(port),\r\ngfn_resp, sizeof(wwn_t)) != 0)) {\r\nbfa_fcs_fabric_set_fabric_name(port->fabric, *gfn_resp);\r\n}\r\nbfa_sm_send_event(ms, MSSM_EVENT_RSP_OK);\r\nreturn;\r\n}\r\nbfa_trc(port->fcs, cthdr->reason_code);\r\nbfa_trc(port->fcs, cthdr->exp_code);\r\nbfa_sm_send_event(ms, MSSM_EVENT_RSP_ERROR);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ms_send_plogi(void *ms_cbarg, struct bfa_fcxp_s *fcxp_alloced)\r\n{\r\nstruct bfa_fcs_lport_ms_s *ms = ms_cbarg;\r\nstruct bfa_fcs_lport_s *port = ms->port;\r\nstruct fchs_s fchs;\r\nint len;\r\nstruct bfa_fcxp_s *fcxp;\r\nbfa_trc(port->fcs, port->pid);\r\nfcxp = fcxp_alloced ? fcxp_alloced :\r\nbfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\r\nif (!fcxp) {\r\nport->stats.ms_plogi_alloc_wait++;\r\nbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ms->fcxp_wqe,\r\nbfa_fcs_lport_ms_send_plogi, ms, BFA_TRUE);\r\nreturn;\r\n}\r\nms->fcxp = fcxp;\r\nlen = fc_plogi_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\r\nbfa_hton3b(FC_MGMT_SERVER),\r\nbfa_fcs_lport_get_fcid(port), 0,\r\nport->port_cfg.pwwn, port->port_cfg.nwwn,\r\nbfa_fcport_get_maxfrsize(port->fcs->bfa),\r\nbfa_fcport_get_rx_bbcredit(port->fcs->bfa));\r\nbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\r\nFC_CLASS_3, len, &fchs,\r\nbfa_fcs_lport_ms_plogi_response, (void *)ms,\r\nFC_MAX_PDUSZ, FC_ELS_TOV);\r\nport->stats.ms_plogi_sent++;\r\nbfa_sm_send_event(ms, MSSM_EVENT_FCXP_SENT);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ms_plogi_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\r\nvoid *cbarg, bfa_status_t req_status,\r\nu32 rsp_len, u32 resid_len, struct fchs_s *rsp_fchs)\r\n{\r\nstruct bfa_fcs_lport_ms_s *ms = (struct bfa_fcs_lport_ms_s *) cbarg;\r\nstruct bfa_fcs_lport_s *port = ms->port;\r\nstruct fc_els_cmd_s *els_cmd;\r\nstruct fc_ls_rjt_s *ls_rjt;\r\nbfa_trc(port->fcs, req_status);\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nif (req_status != BFA_STATUS_OK) {\r\nport->stats.ms_plogi_rsp_err++;\r\nbfa_trc(port->fcs, req_status);\r\nbfa_sm_send_event(ms, MSSM_EVENT_RSP_ERROR);\r\nreturn;\r\n}\r\nels_cmd = (struct fc_els_cmd_s *) BFA_FCXP_RSP_PLD(fcxp);\r\nswitch (els_cmd->els_code) {\r\ncase FC_ELS_ACC:\r\nif (rsp_len < sizeof(struct fc_logi_s)) {\r\nbfa_trc(port->fcs, rsp_len);\r\nport->stats.ms_plogi_acc_err++;\r\nbfa_sm_send_event(ms, MSSM_EVENT_RSP_ERROR);\r\nbreak;\r\n}\r\nport->stats.ms_plogi_accepts++;\r\nbfa_sm_send_event(ms, MSSM_EVENT_RSP_OK);\r\nbreak;\r\ncase FC_ELS_LS_RJT:\r\nls_rjt = (struct fc_ls_rjt_s *) BFA_FCXP_RSP_PLD(fcxp);\r\nbfa_trc(port->fcs, ls_rjt->reason_code);\r\nbfa_trc(port->fcs, ls_rjt->reason_code_expl);\r\nport->stats.ms_rejects++;\r\nbfa_sm_send_event(ms, MSSM_EVENT_RSP_ERROR);\r\nbreak;\r\ndefault:\r\nport->stats.ms_plogi_unknown_rsp++;\r\nbfa_trc(port->fcs, els_cmd->els_code);\r\nbfa_sm_send_event(ms, MSSM_EVENT_RSP_ERROR);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ms_timeout(void *arg)\r\n{\r\nstruct bfa_fcs_lport_ms_s *ms = (struct bfa_fcs_lport_ms_s *) arg;\r\nms->port->stats.ms_timeouts++;\r\nbfa_sm_send_event(ms, MSSM_EVENT_TIMEOUT);\r\n}\r\nvoid\r\nbfa_fcs_lport_ms_init(struct bfa_fcs_lport_s *port)\r\n{\r\nstruct bfa_fcs_lport_ms_s *ms = BFA_FCS_GET_MS_FROM_PORT(port);\r\nms->port = port;\r\nbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\r\nbfa_fcs_lport_fdmi_init(ms);\r\n}\r\nvoid\r\nbfa_fcs_lport_ms_offline(struct bfa_fcs_lport_s *port)\r\n{\r\nstruct bfa_fcs_lport_ms_s *ms = BFA_FCS_GET_MS_FROM_PORT(port);\r\nms->port = port;\r\nbfa_sm_send_event(ms, MSSM_EVENT_PORT_OFFLINE);\r\nbfa_fcs_lport_fdmi_offline(ms);\r\n}\r\nvoid\r\nbfa_fcs_lport_ms_online(struct bfa_fcs_lport_s *port)\r\n{\r\nstruct bfa_fcs_lport_ms_s *ms = BFA_FCS_GET_MS_FROM_PORT(port);\r\nms->port = port;\r\nbfa_sm_send_event(ms, MSSM_EVENT_PORT_ONLINE);\r\n}\r\nvoid\r\nbfa_fcs_lport_ms_fabric_rscn(struct bfa_fcs_lport_s *port)\r\n{\r\nstruct bfa_fcs_lport_ms_s *ms = BFA_FCS_GET_MS_FROM_PORT(port);\r\nif (bfa_sm_cmp_state(ms, bfa_fcs_lport_ms_sm_online))\r\nbfa_sm_send_event(ms, MSSM_EVENT_PORT_FABRIC_RSCN);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_offline(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_PORT_ONLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_plogi_sending);\r\nbfa_fcs_lport_ns_send_plogi(ns, NULL);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_plogi_sending(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_PLOGI_SENT:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_plogi);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\r\n&ns->fcxp_wqe);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_plogi(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_RSP_ERROR:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_plogi_retry);\r\nns->port->stats.ns_retries++;\r\nbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\r\n&ns->timer, bfa_fcs_lport_ns_timeout, ns,\r\nBFA_FCS_RETRY_TIMEOUT);\r\nbreak;\r\ncase NSSM_EVENT_RSP_OK:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rnn_id);\r\nns->num_rnnid_retries = 0;\r\nbfa_fcs_lport_ns_send_rnn_id(ns, NULL);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbfa_fcxp_discard(ns->fcxp);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_plogi_retry(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_TIMEOUT:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_plogi_sending);\r\nbfa_fcs_lport_ns_send_plogi(ns, NULL);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbfa_timer_stop(&ns->timer);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_sending_rnn_id(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_RNNID_SENT:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rnn_id);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\r\n&ns->fcxp_wqe);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_rnn_id(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_RSP_OK:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rsnn_nn);\r\nns->num_rnnid_retries = 0;\r\nns->num_rsnn_nn_retries = 0;\r\nbfa_fcs_lport_ns_send_rsnn_nn(ns, NULL);\r\nbreak;\r\ncase NSSM_EVENT_RSP_ERROR:\r\nif (ns->num_rnnid_retries < BFA_FCS_MAX_NS_RETRIES) {\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rnn_id_retry);\r\nns->port->stats.ns_retries++;\r\nns->num_rnnid_retries++;\r\nbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\r\n&ns->timer, bfa_fcs_lport_ns_timeout, ns,\r\nBFA_FCS_RETRY_TIMEOUT);\r\n} else {\r\nbfa_sm_set_state(ns,\r\nbfa_fcs_lport_ns_sm_sending_rspn_id);\r\nbfa_fcs_lport_ns_send_rspn_id(ns, NULL);\r\n}\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_fcxp_discard(ns->fcxp);\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_rnn_id_retry(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_TIMEOUT:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rnn_id);\r\nbfa_fcs_lport_ns_send_rnn_id(ns, NULL);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbfa_timer_stop(&ns->timer);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_sending_rsnn_nn(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_RSNN_NN_SENT:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rsnn_nn);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\r\n&ns->fcxp_wqe);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_rsnn_nn(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_RSP_OK:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rspn_id);\r\nns->num_rsnn_nn_retries = 0;\r\nbfa_fcs_lport_ns_send_rspn_id(ns, NULL);\r\nbreak;\r\ncase NSSM_EVENT_RSP_ERROR:\r\nif (ns->num_rsnn_nn_retries < BFA_FCS_MAX_NS_RETRIES) {\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rsnn_nn_retry);\r\nns->port->stats.ns_retries++;\r\nns->num_rsnn_nn_retries++;\r\nbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\r\n&ns->timer, bfa_fcs_lport_ns_timeout,\r\nns, BFA_FCS_RETRY_TIMEOUT);\r\n} else {\r\nbfa_sm_set_state(ns,\r\nbfa_fcs_lport_ns_sm_sending_rspn_id);\r\nbfa_fcs_lport_ns_send_rspn_id(ns, NULL);\r\n}\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbfa_fcxp_discard(ns->fcxp);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_rsnn_nn_retry(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_TIMEOUT:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rsnn_nn);\r\nbfa_fcs_lport_ns_send_rsnn_nn(ns, NULL);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbfa_timer_stop(&ns->timer);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_sending_rspn_id(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_RSPNID_SENT:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rspn_id);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\r\n&ns->fcxp_wqe);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_rspn_id(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_RSP_ERROR:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rspn_id_retry);\r\nns->port->stats.ns_retries++;\r\nbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\r\n&ns->timer, bfa_fcs_lport_ns_timeout, ns,\r\nBFA_FCS_RETRY_TIMEOUT);\r\nbreak;\r\ncase NSSM_EVENT_RSP_OK:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rft_id);\r\nbfa_fcs_lport_ns_send_rft_id(ns, NULL);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_fcxp_discard(ns->fcxp);\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_rspn_id_retry(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_TIMEOUT:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rspn_id);\r\nbfa_fcs_lport_ns_send_rspn_id(ns, NULL);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbfa_timer_stop(&ns->timer);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_sending_rft_id(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_RFTID_SENT:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rft_id);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\r\n&ns->fcxp_wqe);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_rft_id(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_RSP_OK:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rff_id);\r\nbfa_fcs_lport_ns_send_rff_id(ns, NULL);\r\nbreak;\r\ncase NSSM_EVENT_RSP_ERROR:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rft_id_retry);\r\nns->port->stats.ns_retries++;\r\nbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\r\n&ns->timer, bfa_fcs_lport_ns_timeout, ns,\r\nBFA_FCS_RETRY_TIMEOUT);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbfa_fcxp_discard(ns->fcxp);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_rft_id_retry(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_TIMEOUT:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rft_id);\r\nbfa_fcs_lport_ns_send_rft_id(ns, NULL);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbfa_timer_stop(&ns->timer);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_sending_rff_id(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_RFFID_SENT:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rff_id);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\r\n&ns->fcxp_wqe);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_rff_id(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_RSP_OK:\r\nif (__fcs_min_cfg(ns->port->fcs)) {\r\nbfa_fcs_lport_ns_boot_target_disc(ns->port);\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_online);\r\nreturn;\r\n}\r\nif (BFA_FCS_VPORT_IS_INITIATOR_MODE(ns->port)) {\r\nbfa_sm_set_state(ns,\r\nbfa_fcs_lport_ns_sm_sending_gid_ft);\r\nbfa_fcs_lport_ns_send_gid_ft(ns, NULL);\r\n}\r\nbfa_fcs_lport_ms_online(ns->port);\r\nbreak;\r\ncase NSSM_EVENT_RSP_ERROR:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rff_id_retry);\r\nns->port->stats.ns_retries++;\r\nbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\r\n&ns->timer, bfa_fcs_lport_ns_timeout, ns,\r\nBFA_FCS_RETRY_TIMEOUT);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbfa_fcxp_discard(ns->fcxp);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_rff_id_retry(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_TIMEOUT:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rff_id);\r\nbfa_fcs_lport_ns_send_rff_id(ns, NULL);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbfa_timer_stop(&ns->timer);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_sending_gid_ft(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_GIDFT_SENT:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_gid_ft);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\r\n&ns->fcxp_wqe);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_gid_ft(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_RSP_OK:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_online);\r\nbreak;\r\ncase NSSM_EVENT_RSP_ERROR:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_gid_ft_retry);\r\nns->port->stats.ns_retries++;\r\nbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\r\n&ns->timer, bfa_fcs_lport_ns_timeout, ns,\r\nBFA_FCS_RETRY_TIMEOUT);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbfa_fcxp_discard(ns->fcxp);\r\nbreak;\r\ncase NSSM_EVENT_NS_QUERY:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_gid_ft_retry(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_TIMEOUT:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_gid_ft);\r\nbfa_fcs_lport_ns_send_gid_ft(ns, NULL);\r\nbreak;\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbfa_timer_stop(&ns->timer);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_sm_online(struct bfa_fcs_lport_ns_s *ns,\r\nenum vport_ns_event event)\r\n{\r\nbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\r\nbfa_trc(ns->port->fcs, event);\r\nswitch (event) {\r\ncase NSSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\nbreak;\r\ncase NSSM_EVENT_NS_QUERY:\r\nif (BFA_FCS_VPORT_IS_INITIATOR_MODE(ns->port)) {\r\nbfa_sm_set_state(ns,\r\nbfa_fcs_lport_ns_sm_sending_gid_ft);\r\nbfa_fcs_lport_ns_send_gid_ft(ns, NULL);\r\n};\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ns->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_send_plogi(void *ns_cbarg, struct bfa_fcxp_s *fcxp_alloced)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = ns_cbarg;\r\nstruct bfa_fcs_lport_s *port = ns->port;\r\nstruct fchs_s fchs;\r\nint len;\r\nstruct bfa_fcxp_s *fcxp;\r\nbfa_trc(port->fcs, port->pid);\r\nfcxp = fcxp_alloced ? fcxp_alloced :\r\nbfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\r\nif (!fcxp) {\r\nport->stats.ns_plogi_alloc_wait++;\r\nbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,\r\nbfa_fcs_lport_ns_send_plogi, ns, BFA_TRUE);\r\nreturn;\r\n}\r\nns->fcxp = fcxp;\r\nlen = fc_plogi_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\r\nbfa_hton3b(FC_NAME_SERVER),\r\nbfa_fcs_lport_get_fcid(port), 0,\r\nport->port_cfg.pwwn, port->port_cfg.nwwn,\r\nbfa_fcport_get_maxfrsize(port->fcs->bfa),\r\nbfa_fcport_get_rx_bbcredit(port->fcs->bfa));\r\nbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\r\nFC_CLASS_3, len, &fchs,\r\nbfa_fcs_lport_ns_plogi_response, (void *)ns,\r\nFC_MAX_PDUSZ, FC_ELS_TOV);\r\nport->stats.ns_plogi_sent++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_PLOGI_SENT);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_plogi_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\r\nvoid *cbarg, bfa_status_t req_status, u32 rsp_len,\r\nu32 resid_len, struct fchs_s *rsp_fchs)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = (struct bfa_fcs_lport_ns_s *) cbarg;\r\nstruct bfa_fcs_lport_s *port = ns->port;\r\nstruct fc_els_cmd_s *els_cmd;\r\nstruct fc_ls_rjt_s *ls_rjt;\r\nbfa_trc(port->fcs, req_status);\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nif (req_status != BFA_STATUS_OK) {\r\nbfa_trc(port->fcs, req_status);\r\nport->stats.ns_plogi_rsp_err++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\r\nreturn;\r\n}\r\nels_cmd = (struct fc_els_cmd_s *) BFA_FCXP_RSP_PLD(fcxp);\r\nswitch (els_cmd->els_code) {\r\ncase FC_ELS_ACC:\r\nif (rsp_len < sizeof(struct fc_logi_s)) {\r\nbfa_trc(port->fcs, rsp_len);\r\nport->stats.ns_plogi_acc_err++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\r\nbreak;\r\n}\r\nport->stats.ns_plogi_accepts++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_OK);\r\nbreak;\r\ncase FC_ELS_LS_RJT:\r\nls_rjt = (struct fc_ls_rjt_s *) BFA_FCXP_RSP_PLD(fcxp);\r\nbfa_trc(port->fcs, ls_rjt->reason_code);\r\nbfa_trc(port->fcs, ls_rjt->reason_code_expl);\r\nport->stats.ns_rejects++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\r\nbreak;\r\ndefault:\r\nport->stats.ns_plogi_unknown_rsp++;\r\nbfa_trc(port->fcs, els_cmd->els_code);\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_send_rnn_id(void *ns_cbarg, struct bfa_fcxp_s *fcxp_alloced)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = ns_cbarg;\r\nstruct bfa_fcs_lport_s *port = ns->port;\r\nstruct fchs_s fchs;\r\nint len;\r\nstruct bfa_fcxp_s *fcxp;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nfcxp = fcxp_alloced ? fcxp_alloced :\r\nbfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\r\nif (!fcxp) {\r\nport->stats.ns_rnnid_alloc_wait++;\r\nbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,\r\nbfa_fcs_lport_ns_send_rnn_id, ns, BFA_TRUE);\r\nreturn;\r\n}\r\nns->fcxp = fcxp;\r\nlen = fc_rnnid_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\r\nbfa_fcs_lport_get_fcid(port),\r\nbfa_fcs_lport_get_fcid(port),\r\nbfa_fcs_lport_get_nwwn(port));\r\nbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\r\nFC_CLASS_3, len, &fchs,\r\nbfa_fcs_lport_ns_rnn_id_response, (void *)ns,\r\nFC_MAX_PDUSZ, FC_FCCT_TOV);\r\nport->stats.ns_rnnid_sent++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RNNID_SENT);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_rnn_id_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\r\nvoid *cbarg, bfa_status_t req_status,\r\nu32 rsp_len, u32 resid_len,\r\nstruct fchs_s *rsp_fchs)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = (struct bfa_fcs_lport_ns_s *) cbarg;\r\nstruct bfa_fcs_lport_s *port = ns->port;\r\nstruct ct_hdr_s *cthdr = NULL;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nif (req_status != BFA_STATUS_OK) {\r\nbfa_trc(port->fcs, req_status);\r\nport->stats.ns_rnnid_rsp_err++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\r\nreturn;\r\n}\r\ncthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\r\ncthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\r\nif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\r\nport->stats.ns_rnnid_accepts++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_OK);\r\nreturn;\r\n}\r\nport->stats.ns_rnnid_rejects++;\r\nbfa_trc(port->fcs, cthdr->reason_code);\r\nbfa_trc(port->fcs, cthdr->exp_code);\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_send_rsnn_nn(void *ns_cbarg, struct bfa_fcxp_s *fcxp_alloced)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = ns_cbarg;\r\nstruct bfa_fcs_lport_s *port = ns->port;\r\nstruct fchs_s fchs;\r\nint len;\r\nstruct bfa_fcxp_s *fcxp;\r\nu8 *nsymbl;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nfcxp = fcxp_alloced ? fcxp_alloced :\r\nbfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\r\nif (!fcxp) {\r\nport->stats.ns_rsnn_nn_alloc_wait++;\r\nbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,\r\nbfa_fcs_lport_ns_send_rsnn_nn, ns, BFA_TRUE);\r\nreturn;\r\n}\r\nns->fcxp = fcxp;\r\nnsymbl = (u8 *) &(bfa_fcs_lport_get_nsym_name(\r\nbfa_fcs_get_base_port(port->fcs)));\r\nlen = fc_rsnn_nn_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\r\nbfa_fcs_lport_get_fcid(port),\r\nbfa_fcs_lport_get_nwwn(port), nsymbl);\r\nbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\r\nFC_CLASS_3, len, &fchs,\r\nbfa_fcs_lport_ns_rsnn_nn_response, (void *)ns,\r\nFC_MAX_PDUSZ, FC_FCCT_TOV);\r\nport->stats.ns_rsnn_nn_sent++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSNN_NN_SENT);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_rsnn_nn_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\r\nvoid *cbarg, bfa_status_t req_status,\r\nu32 rsp_len, u32 resid_len,\r\nstruct fchs_s *rsp_fchs)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = (struct bfa_fcs_lport_ns_s *) cbarg;\r\nstruct bfa_fcs_lport_s *port = ns->port;\r\nstruct ct_hdr_s *cthdr = NULL;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nif (req_status != BFA_STATUS_OK) {\r\nbfa_trc(port->fcs, req_status);\r\nport->stats.ns_rsnn_nn_rsp_err++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\r\nreturn;\r\n}\r\ncthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\r\ncthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\r\nif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\r\nport->stats.ns_rsnn_nn_accepts++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_OK);\r\nreturn;\r\n}\r\nport->stats.ns_rsnn_nn_rejects++;\r\nbfa_trc(port->fcs, cthdr->reason_code);\r\nbfa_trc(port->fcs, cthdr->exp_code);\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_send_rspn_id(void *ns_cbarg, struct bfa_fcxp_s *fcxp_alloced)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = ns_cbarg;\r\nstruct bfa_fcs_lport_s *port = ns->port;\r\nstruct fchs_s fchs;\r\nint len;\r\nstruct bfa_fcxp_s *fcxp;\r\nu8 symbl[256];\r\nu8 *psymbl = &symbl[0];\r\nmemset(symbl, 0, sizeof(symbl));\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nfcxp = fcxp_alloced ? fcxp_alloced :\r\nbfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\r\nif (!fcxp) {\r\nport->stats.ns_rspnid_alloc_wait++;\r\nbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,\r\nbfa_fcs_lport_ns_send_rspn_id, ns, BFA_TRUE);\r\nreturn;\r\n}\r\nns->fcxp = fcxp;\r\nif (port->vport) {\r\nstrncpy((char *)psymbl,\r\n(char *) &\r\n(bfa_fcs_lport_get_psym_name\r\n(bfa_fcs_get_base_port(port->fcs))),\r\nstrlen((char *) &\r\nbfa_fcs_lport_get_psym_name(bfa_fcs_get_base_port\r\n(port->fcs))));\r\n((char *)psymbl)[strlen((char *) &\r\nbfa_fcs_lport_get_psym_name(bfa_fcs_get_base_port\r\n(port->fcs)))] = 0;\r\nstrncat((char *)psymbl,\r\n(char *) &(bfa_fcs_lport_get_psym_name(port)),\r\nstrlen((char *) &bfa_fcs_lport_get_psym_name(port)));\r\n} else {\r\npsymbl = (u8 *) &(bfa_fcs_lport_get_psym_name(port));\r\n}\r\nlen = fc_rspnid_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\r\nbfa_fcs_lport_get_fcid(port), 0, psymbl);\r\nbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\r\nFC_CLASS_3, len, &fchs,\r\nbfa_fcs_lport_ns_rspn_id_response, (void *)ns,\r\nFC_MAX_PDUSZ, FC_FCCT_TOV);\r\nport->stats.ns_rspnid_sent++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSPNID_SENT);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_rspn_id_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\r\nvoid *cbarg, bfa_status_t req_status,\r\nu32 rsp_len, u32 resid_len,\r\nstruct fchs_s *rsp_fchs)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = (struct bfa_fcs_lport_ns_s *) cbarg;\r\nstruct bfa_fcs_lport_s *port = ns->port;\r\nstruct ct_hdr_s *cthdr = NULL;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nif (req_status != BFA_STATUS_OK) {\r\nbfa_trc(port->fcs, req_status);\r\nport->stats.ns_rspnid_rsp_err++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\r\nreturn;\r\n}\r\ncthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\r\ncthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\r\nif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\r\nport->stats.ns_rspnid_accepts++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_OK);\r\nreturn;\r\n}\r\nport->stats.ns_rspnid_rejects++;\r\nbfa_trc(port->fcs, cthdr->reason_code);\r\nbfa_trc(port->fcs, cthdr->exp_code);\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_send_rft_id(void *ns_cbarg, struct bfa_fcxp_s *fcxp_alloced)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = ns_cbarg;\r\nstruct bfa_fcs_lport_s *port = ns->port;\r\nstruct fchs_s fchs;\r\nint len;\r\nstruct bfa_fcxp_s *fcxp;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nfcxp = fcxp_alloced ? fcxp_alloced :\r\nbfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\r\nif (!fcxp) {\r\nport->stats.ns_rftid_alloc_wait++;\r\nbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,\r\nbfa_fcs_lport_ns_send_rft_id, ns, BFA_TRUE);\r\nreturn;\r\n}\r\nns->fcxp = fcxp;\r\nlen = fc_rftid_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\r\nbfa_fcs_lport_get_fcid(port), 0, port->port_cfg.roles);\r\nbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\r\nFC_CLASS_3, len, &fchs,\r\nbfa_fcs_lport_ns_rft_id_response, (void *)ns,\r\nFC_MAX_PDUSZ, FC_FCCT_TOV);\r\nport->stats.ns_rftid_sent++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RFTID_SENT);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_rft_id_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\r\nvoid *cbarg, bfa_status_t req_status,\r\nu32 rsp_len, u32 resid_len,\r\nstruct fchs_s *rsp_fchs)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = (struct bfa_fcs_lport_ns_s *) cbarg;\r\nstruct bfa_fcs_lport_s *port = ns->port;\r\nstruct ct_hdr_s *cthdr = NULL;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nif (req_status != BFA_STATUS_OK) {\r\nbfa_trc(port->fcs, req_status);\r\nport->stats.ns_rftid_rsp_err++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\r\nreturn;\r\n}\r\ncthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\r\ncthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\r\nif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\r\nport->stats.ns_rftid_accepts++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_OK);\r\nreturn;\r\n}\r\nport->stats.ns_rftid_rejects++;\r\nbfa_trc(port->fcs, cthdr->reason_code);\r\nbfa_trc(port->fcs, cthdr->exp_code);\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_send_rff_id(void *ns_cbarg, struct bfa_fcxp_s *fcxp_alloced)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = ns_cbarg;\r\nstruct bfa_fcs_lport_s *port = ns->port;\r\nstruct fchs_s fchs;\r\nint len;\r\nstruct bfa_fcxp_s *fcxp;\r\nu8 fc4_ftrs = 0;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nfcxp = fcxp_alloced ? fcxp_alloced :\r\nbfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\r\nif (!fcxp) {\r\nport->stats.ns_rffid_alloc_wait++;\r\nbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,\r\nbfa_fcs_lport_ns_send_rff_id, ns, BFA_TRUE);\r\nreturn;\r\n}\r\nns->fcxp = fcxp;\r\nif (BFA_FCS_VPORT_IS_INITIATOR_MODE(ns->port))\r\nfc4_ftrs = FC_GS_FCP_FC4_FEATURE_INITIATOR;\r\nlen = fc_rffid_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\r\nbfa_fcs_lport_get_fcid(port), 0,\r\nFC_TYPE_FCP, fc4_ftrs);\r\nbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\r\nFC_CLASS_3, len, &fchs,\r\nbfa_fcs_lport_ns_rff_id_response, (void *)ns,\r\nFC_MAX_PDUSZ, FC_FCCT_TOV);\r\nport->stats.ns_rffid_sent++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RFFID_SENT);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_rff_id_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\r\nvoid *cbarg, bfa_status_t req_status,\r\nu32 rsp_len, u32 resid_len,\r\nstruct fchs_s *rsp_fchs)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = (struct bfa_fcs_lport_ns_s *) cbarg;\r\nstruct bfa_fcs_lport_s *port = ns->port;\r\nstruct ct_hdr_s *cthdr = NULL;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nif (req_status != BFA_STATUS_OK) {\r\nbfa_trc(port->fcs, req_status);\r\nport->stats.ns_rffid_rsp_err++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\r\nreturn;\r\n}\r\ncthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\r\ncthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\r\nif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\r\nport->stats.ns_rffid_accepts++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_OK);\r\nreturn;\r\n}\r\nport->stats.ns_rffid_rejects++;\r\nbfa_trc(port->fcs, cthdr->reason_code);\r\nbfa_trc(port->fcs, cthdr->exp_code);\r\nif (cthdr->reason_code == CT_RSN_NOT_SUPP) {\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_OK);\r\n} else\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_send_gid_ft(void *ns_cbarg, struct bfa_fcxp_s *fcxp_alloced)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = ns_cbarg;\r\nstruct bfa_fcs_lport_s *port = ns->port;\r\nstruct fchs_s fchs;\r\nint len;\r\nstruct bfa_fcxp_s *fcxp;\r\nbfa_trc(port->fcs, port->pid);\r\nfcxp = fcxp_alloced ? fcxp_alloced :\r\nbfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\r\nif (!fcxp) {\r\nport->stats.ns_gidft_alloc_wait++;\r\nbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,\r\nbfa_fcs_lport_ns_send_gid_ft, ns, BFA_TRUE);\r\nreturn;\r\n}\r\nns->fcxp = fcxp;\r\nlen = fc_gid_ft_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\r\nns->port->pid, FC_TYPE_FCP);\r\nbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\r\nFC_CLASS_3, len, &fchs,\r\nbfa_fcs_lport_ns_gid_ft_response, (void *)ns,\r\nbfa_fcxp_get_maxrsp(port->fcs->bfa), FC_FCCT_TOV);\r\nport->stats.ns_gidft_sent++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_GIDFT_SENT);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_gid_ft_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\r\nvoid *cbarg, bfa_status_t req_status,\r\nu32 rsp_len, u32 resid_len,\r\nstruct fchs_s *rsp_fchs)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = (struct bfa_fcs_lport_ns_s *) cbarg;\r\nstruct bfa_fcs_lport_s *port = ns->port;\r\nstruct ct_hdr_s *cthdr = NULL;\r\nu32 n_pids;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nif (req_status != BFA_STATUS_OK) {\r\nbfa_trc(port->fcs, req_status);\r\nport->stats.ns_gidft_rsp_err++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\r\nreturn;\r\n}\r\nif (resid_len != 0) {\r\nbfa_trc(port->fcs, rsp_len);\r\nbfa_trc(port->fcs, resid_len);\r\nreturn;\r\n}\r\ncthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\r\ncthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\r\nswitch (cthdr->cmd_rsp_code) {\r\ncase CT_RSP_ACCEPT:\r\nport->stats.ns_gidft_accepts++;\r\nn_pids = (fc_get_ctresp_pyld_len(rsp_len) / sizeof(u32));\r\nbfa_trc(port->fcs, n_pids);\r\nbfa_fcs_lport_ns_process_gidft_pids(port,\r\n(u32 *) (cthdr + 1),\r\nn_pids);\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_OK);\r\nbreak;\r\ncase CT_RSP_REJECT:\r\nport->stats.ns_gidft_rejects++;\r\nbfa_trc(port->fcs, cthdr->reason_code);\r\nbfa_trc(port->fcs, cthdr->exp_code);\r\nif ((cthdr->reason_code == CT_RSN_UNABLE_TO_PERF)\r\n&& (cthdr->exp_code == CT_NS_EXP_FT_NOT_REG)) {\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_OK);\r\n} else {\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\r\n}\r\nbreak;\r\ndefault:\r\nport->stats.ns_gidft_unknown_rsp++;\r\nbfa_trc(port->fcs, cthdr->cmd_rsp_code);\r\nbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_timeout(void *arg)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = (struct bfa_fcs_lport_ns_s *) arg;\r\nns->port->stats.ns_timeouts++;\r\nbfa_sm_send_event(ns, NSSM_EVENT_TIMEOUT);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_process_gidft_pids(struct bfa_fcs_lport_s *port, u32 *pid_buf,\r\nu32 n_pids)\r\n{\r\nstruct fcgs_gidft_resp_s *gidft_entry;\r\nstruct bfa_fcs_rport_s *rport;\r\nu32 ii;\r\nstruct bfa_fcs_fabric_s *fabric = port->fabric;\r\nstruct bfa_fcs_vport_s *vport;\r\nstruct list_head *qe;\r\nu8 found = 0;\r\nfor (ii = 0; ii < n_pids; ii++) {\r\ngidft_entry = (struct fcgs_gidft_resp_s *) &pid_buf[ii];\r\nif (gidft_entry->pid == port->pid)\r\ncontinue;\r\nif (gidft_entry->pid == fabric->bport.pid)\r\ncontinue;\r\nlist_for_each(qe, &fabric->vport_q) {\r\nvport = (struct bfa_fcs_vport_s *) qe;\r\nif (vport->lport.pid == gidft_entry->pid)\r\nfound = 1;\r\n}\r\nif (found) {\r\nfound = 0;\r\ncontinue;\r\n}\r\nrport = bfa_fcs_lport_get_rport_by_pid(port, gidft_entry->pid);\r\nif (rport == NULL) {\r\nrport = bfa_fcs_rport_create(port, gidft_entry->pid);\r\n} else {\r\nbfa_fcs_rport_scn(rport);\r\n}\r\nbfa_trc(port->fcs, gidft_entry->pid);\r\nif (gidft_entry->last)\r\nreturn;\r\n}\r\n}\r\nvoid\r\nbfa_fcs_lport_ns_init(struct bfa_fcs_lport_s *port)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = BFA_FCS_GET_NS_FROM_PORT(port);\r\nns->port = port;\r\nbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\r\n}\r\nvoid\r\nbfa_fcs_lport_ns_offline(struct bfa_fcs_lport_s *port)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = BFA_FCS_GET_NS_FROM_PORT(port);\r\nns->port = port;\r\nbfa_sm_send_event(ns, NSSM_EVENT_PORT_OFFLINE);\r\n}\r\nvoid\r\nbfa_fcs_lport_ns_online(struct bfa_fcs_lport_s *port)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = BFA_FCS_GET_NS_FROM_PORT(port);\r\nns->port = port;\r\nbfa_sm_send_event(ns, NSSM_EVENT_PORT_ONLINE);\r\n}\r\nvoid\r\nbfa_fcs_lport_ns_query(struct bfa_fcs_lport_s *port)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = BFA_FCS_GET_NS_FROM_PORT(port);\r\nbfa_trc(port->fcs, port->pid);\r\nif (bfa_sm_cmp_state(ns, bfa_fcs_lport_ns_sm_online))\r\nbfa_sm_send_event(ns, NSSM_EVENT_NS_QUERY);\r\n}\r\nstatic void\r\nbfa_fcs_lport_ns_boot_target_disc(bfa_fcs_lport_t *port)\r\n{\r\nstruct bfa_fcs_rport_s *rport;\r\nu8 nwwns;\r\nwwn_t wwns[BFA_PREBOOT_BOOTLUN_MAX];\r\nint ii;\r\nbfa_iocfc_get_bootwwns(port->fcs->bfa, &nwwns, wwns);\r\nfor (ii = 0 ; ii < nwwns; ++ii) {\r\nrport = bfa_fcs_rport_create_by_wwn(port, wwns[ii]);\r\nWARN_ON(!rport);\r\n}\r\n}\r\nvoid\r\nbfa_fcs_lport_ns_util_send_rspn_id(void *cbarg, struct bfa_fcxp_s *fcxp_alloced)\r\n{\r\nstruct bfa_fcs_lport_ns_s *ns = cbarg;\r\nstruct bfa_fcs_lport_s *port = ns->port;\r\nstruct fchs_s fchs;\r\nstruct bfa_fcxp_s *fcxp;\r\nu8 symbl[256];\r\nu8 *psymbl = &symbl[0];\r\nint len;\r\nif (!bfa_sm_cmp_state(port, bfa_fcs_lport_sm_online))\r\nreturn;\r\nif (bfa_sm_cmp_state(ns, bfa_fcs_lport_ns_sm_offline) ||\r\nbfa_sm_cmp_state(ns, bfa_fcs_lport_ns_sm_plogi_sending) ||\r\nbfa_sm_cmp_state(ns, bfa_fcs_lport_ns_sm_plogi) ||\r\nbfa_sm_cmp_state(ns, bfa_fcs_lport_ns_sm_plogi_retry) ||\r\nbfa_sm_cmp_state(ns, bfa_fcs_lport_ns_sm_rspn_id_retry))\r\nreturn;\r\nmemset(symbl, 0, sizeof(symbl));\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nfcxp = fcxp_alloced ? fcxp_alloced :\r\nbfa_fcs_fcxp_alloc(port->fcs, BFA_FALSE);\r\nif (!fcxp) {\r\nport->stats.ns_rspnid_alloc_wait++;\r\nbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,\r\nbfa_fcs_lport_ns_util_send_rspn_id, ns, BFA_FALSE);\r\nreturn;\r\n}\r\nns->fcxp = fcxp;\r\nif (port->vport) {\r\nstrncpy((char *)psymbl, (char *)&(bfa_fcs_lport_get_psym_name\r\n(bfa_fcs_get_base_port(port->fcs))),\r\nstrlen((char *)&bfa_fcs_lport_get_psym_name(\r\nbfa_fcs_get_base_port(port->fcs))));\r\n((char *)psymbl)[strlen((char *)&bfa_fcs_lport_get_psym_name(\r\nbfa_fcs_get_base_port(port->fcs)))] = 0;\r\nstrncat((char *)psymbl,\r\n(char *)&(bfa_fcs_lport_get_psym_name(port)),\r\nstrlen((char *)&bfa_fcs_lport_get_psym_name(port)));\r\n}\r\nlen = fc_rspnid_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\r\nbfa_fcs_lport_get_fcid(port), 0, psymbl);\r\nbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\r\nFC_CLASS_3, len, &fchs, NULL, NULL, FC_MAX_PDUSZ, 0);\r\nport->stats.ns_rspnid_sent++;\r\n}\r\nstatic void\r\nbfa_fcs_lport_scn_sm_offline(struct bfa_fcs_lport_scn_s *scn,\r\nenum port_scn_event event)\r\n{\r\nswitch (event) {\r\ncase SCNSM_EVENT_PORT_ONLINE:\r\nbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_sending_scr);\r\nbfa_fcs_lport_scn_send_scr(scn, NULL);\r\nbreak;\r\ncase SCNSM_EVENT_PORT_OFFLINE:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(scn->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_scn_sm_sending_scr(struct bfa_fcs_lport_scn_s *scn,\r\nenum port_scn_event event)\r\n{\r\nswitch (event) {\r\ncase SCNSM_EVENT_SCR_SENT:\r\nbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_scr);\r\nbreak;\r\ncase SCNSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_offline);\r\nbfa_fcxp_walloc_cancel(scn->port->fcs->bfa, &scn->fcxp_wqe);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(scn->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_scn_sm_scr(struct bfa_fcs_lport_scn_s *scn,\r\nenum port_scn_event event)\r\n{\r\nstruct bfa_fcs_lport_s *port = scn->port;\r\nswitch (event) {\r\ncase SCNSM_EVENT_RSP_OK:\r\nbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_online);\r\nbreak;\r\ncase SCNSM_EVENT_RSP_ERROR:\r\nbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_scr_retry);\r\nbfa_timer_start(port->fcs->bfa, &scn->timer,\r\nbfa_fcs_lport_scn_timeout, scn,\r\nBFA_FCS_RETRY_TIMEOUT);\r\nbreak;\r\ncase SCNSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_offline);\r\nbfa_fcxp_discard(scn->fcxp);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_scn_sm_scr_retry(struct bfa_fcs_lport_scn_s *scn,\r\nenum port_scn_event event)\r\n{\r\nswitch (event) {\r\ncase SCNSM_EVENT_TIMEOUT:\r\nbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_sending_scr);\r\nbfa_fcs_lport_scn_send_scr(scn, NULL);\r\nbreak;\r\ncase SCNSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_offline);\r\nbfa_timer_stop(&scn->timer);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(scn->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_scn_sm_online(struct bfa_fcs_lport_scn_s *scn,\r\nenum port_scn_event event)\r\n{\r\nswitch (event) {\r\ncase SCNSM_EVENT_PORT_OFFLINE:\r\nbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_offline);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(scn->port->fcs, event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_scn_send_scr(void *scn_cbarg, struct bfa_fcxp_s *fcxp_alloced)\r\n{\r\nstruct bfa_fcs_lport_scn_s *scn = scn_cbarg;\r\nstruct bfa_fcs_lport_s *port = scn->port;\r\nstruct fchs_s fchs;\r\nint len;\r\nstruct bfa_fcxp_s *fcxp;\r\nbfa_trc(port->fcs, port->pid);\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nfcxp = fcxp_alloced ? fcxp_alloced :\r\nbfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\r\nif (!fcxp) {\r\nbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &scn->fcxp_wqe,\r\nbfa_fcs_lport_scn_send_scr, scn, BFA_TRUE);\r\nreturn;\r\n}\r\nscn->fcxp = fcxp;\r\nif ((!port->vport) && bfa_ioc_get_fcmode(&port->fcs->bfa->ioc)) {\r\nlen = fc_scr_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\r\nport->fabric->lps->brcd_switch,\r\nport->pid, 0);\r\n} else {\r\nlen = fc_scr_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\r\nBFA_FALSE,\r\nport->pid, 0);\r\n}\r\nbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\r\nFC_CLASS_3, len, &fchs,\r\nbfa_fcs_lport_scn_scr_response,\r\n(void *)scn, FC_MAX_PDUSZ, FC_ELS_TOV);\r\nbfa_sm_send_event(scn, SCNSM_EVENT_SCR_SENT);\r\n}\r\nstatic void\r\nbfa_fcs_lport_scn_scr_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\r\nvoid *cbarg, bfa_status_t req_status, u32 rsp_len,\r\nu32 resid_len, struct fchs_s *rsp_fchs)\r\n{\r\nstruct bfa_fcs_lport_scn_s *scn = (struct bfa_fcs_lport_scn_s *) cbarg;\r\nstruct bfa_fcs_lport_s *port = scn->port;\r\nstruct fc_els_cmd_s *els_cmd;\r\nstruct fc_ls_rjt_s *ls_rjt;\r\nbfa_trc(port->fcs, port->port_cfg.pwwn);\r\nif (req_status != BFA_STATUS_OK) {\r\nbfa_trc(port->fcs, req_status);\r\nbfa_sm_send_event(scn, SCNSM_EVENT_RSP_ERROR);\r\nreturn;\r\n}\r\nels_cmd = (struct fc_els_cmd_s *) BFA_FCXP_RSP_PLD(fcxp);\r\nswitch (els_cmd->els_code) {\r\ncase FC_ELS_ACC:\r\nbfa_sm_send_event(scn, SCNSM_EVENT_RSP_OK);\r\nbreak;\r\ncase FC_ELS_LS_RJT:\r\nls_rjt = (struct fc_ls_rjt_s *) BFA_FCXP_RSP_PLD(fcxp);\r\nbfa_trc(port->fcs, ls_rjt->reason_code);\r\nbfa_trc(port->fcs, ls_rjt->reason_code_expl);\r\nbfa_sm_send_event(scn, SCNSM_EVENT_RSP_ERROR);\r\nbreak;\r\ndefault:\r\nbfa_sm_send_event(scn, SCNSM_EVENT_RSP_ERROR);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_lport_scn_send_ls_acc(struct bfa_fcs_lport_s *port,\r\nstruct fchs_s *rx_fchs)\r\n{\r\nstruct fchs_s fchs;\r\nstruct bfa_fcxp_s *fcxp;\r\nstruct bfa_rport_s *bfa_rport = NULL;\r\nint len;\r\nbfa_trc(port->fcs, rx_fchs->s_id);\r\nfcxp = bfa_fcs_fcxp_alloc(port->fcs, BFA_FALSE);\r\nif (!fcxp)\r\nreturn;\r\nlen = fc_ls_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\r\nrx_fchs->s_id, bfa_fcs_lport_get_fcid(port),\r\nrx_fchs->ox_id);\r\nbfa_fcxp_send(fcxp, bfa_rport, port->fabric->vf_id, port->lp_tag,\r\nBFA_FALSE, FC_CLASS_3, len, &fchs, NULL, NULL,\r\nFC_MAX_PDUSZ, 0);\r\n}\r\nstatic void\r\nbfa_fcs_lport_scn_timeout(void *arg)\r\n{\r\nstruct bfa_fcs_lport_scn_s *scn = (struct bfa_fcs_lport_scn_s *) arg;\r\nbfa_sm_send_event(scn, SCNSM_EVENT_TIMEOUT);\r\n}\r\nvoid\r\nbfa_fcs_lport_scn_init(struct bfa_fcs_lport_s *port)\r\n{\r\nstruct bfa_fcs_lport_scn_s *scn = BFA_FCS_GET_SCN_FROM_PORT(port);\r\nscn->port = port;\r\nbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_offline);\r\n}\r\nvoid\r\nbfa_fcs_lport_scn_offline(struct bfa_fcs_lport_s *port)\r\n{\r\nstruct bfa_fcs_lport_scn_s *scn = BFA_FCS_GET_SCN_FROM_PORT(port);\r\nscn->port = port;\r\nbfa_sm_send_event(scn, SCNSM_EVENT_PORT_OFFLINE);\r\n}\r\nvoid\r\nbfa_fcs_lport_fab_scn_online(struct bfa_fcs_lport_s *port)\r\n{\r\nstruct bfa_fcs_lport_scn_s *scn = BFA_FCS_GET_SCN_FROM_PORT(port);\r\nscn->port = port;\r\nbfa_sm_send_event(scn, SCNSM_EVENT_PORT_ONLINE);\r\n}\r\nstatic void\r\nbfa_fcs_lport_scn_portid_rscn(struct bfa_fcs_lport_s *port, u32 rpid)\r\n{\r\nstruct bfa_fcs_rport_s *rport;\r\nstruct bfa_fcs_fabric_s *fabric = port->fabric;\r\nstruct bfa_fcs_vport_s *vport;\r\nstruct list_head *qe;\r\nbfa_trc(port->fcs, rpid);\r\nif (rpid == fabric->bport.pid)\r\nreturn;\r\nlist_for_each(qe, &fabric->vport_q) {\r\nvport = (struct bfa_fcs_vport_s *) qe;\r\nif (vport->lport.pid == rpid)\r\nreturn;\r\n}\r\nrport = bfa_fcs_lport_get_rport_by_pid(port, rpid);\r\nif (!rport)\r\nrport = bfa_fcs_lport_get_rport_by_old_pid(port, rpid);\r\nif (rport == NULL) {\r\nif (!__fcs_min_cfg(port->fcs))\r\nrport = bfa_fcs_rport_create(port, rpid);\r\n} else\r\nbfa_fcs_rport_scn(rport);\r\n}\r\nstatic void\r\nbfa_fcs_lport_scn_multiport_rscn(struct bfa_fcs_lport_s *port,\r\nenum fc_rscn_format format,\r\nu32 rscn_pid)\r\n{\r\nstruct bfa_fcs_rport_s *rport;\r\nstruct list_head *qe, *qe_next;\r\nu8 *c0, *c1;\r\nbfa_trc(port->fcs, format);\r\nbfa_trc(port->fcs, rscn_pid);\r\nc0 = (u8 *) &rscn_pid;\r\nlist_for_each_safe(qe, qe_next, &port->rport_q) {\r\nrport = (struct bfa_fcs_rport_s *) qe;\r\nc1 = (u8 *) &rport->pid;\r\nif (__fc_pid_match(c0, c1, format))\r\nbfa_fcs_rport_scn(rport);\r\n}\r\n}\r\nvoid\r\nbfa_fcs_lport_scn_process_rscn(struct bfa_fcs_lport_s *port,\r\nstruct fchs_s *fchs, u32 len)\r\n{\r\nstruct fc_rscn_pl_s *rscn = (struct fc_rscn_pl_s *) (fchs + 1);\r\nint num_entries;\r\nu32 rscn_pid;\r\nbfa_boolean_t nsquery = BFA_FALSE, found;\r\nint i = 0, j;\r\nnum_entries =\r\n(be16_to_cpu(rscn->payldlen) -\r\nsizeof(u32)) / sizeof(rscn->event[0]);\r\nbfa_trc(port->fcs, num_entries);\r\nport->stats.num_rscn++;\r\nbfa_fcs_lport_scn_send_ls_acc(port, fchs);\r\nfor (i = 0; i < num_entries; i++) {\r\nrscn_pid = rscn->event[i].portid;\r\nbfa_trc(port->fcs, rscn->event[i].format);\r\nbfa_trc(port->fcs, rscn_pid);\r\nfound = BFA_FALSE;\r\nfor (j = 0; j < i; j++) {\r\nif (rscn->event[j].portid == rscn_pid) {\r\nfound = BFA_TRUE;\r\nbreak;\r\n}\r\n}\r\nif (found) {\r\nbfa_trc(port->fcs, rscn_pid);\r\ncontinue;\r\n}\r\nswitch (rscn->event[i].format) {\r\ncase FC_RSCN_FORMAT_PORTID:\r\nif (rscn->event[i].qualifier == FC_QOS_RSCN_EVENT) {\r\nbfa_trc(port->fcs, rscn_pid);\r\n} else {\r\nport->stats.num_portid_rscn++;\r\nbfa_fcs_lport_scn_portid_rscn(port, rscn_pid);\r\n}\r\nbreak;\r\ncase FC_RSCN_FORMAT_FABRIC:\r\nif (rscn->event[i].qualifier ==\r\nFC_FABRIC_NAME_RSCN_EVENT) {\r\nbfa_fcs_lport_ms_fabric_rscn(port);\r\nbreak;\r\n}\r\ncase FC_RSCN_FORMAT_AREA:\r\ncase FC_RSCN_FORMAT_DOMAIN:\r\nnsquery = BFA_TRUE;\r\nbfa_fcs_lport_scn_multiport_rscn(port,\r\nrscn->event[i].format,\r\nrscn_pid);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nnsquery = BFA_TRUE;\r\n}\r\n}\r\nif (nsquery)\r\nbfa_fcs_lport_ns_query(port);\r\n}\r\nstruct bfa_fcs_lport_s *\r\nbfa_fcs_get_base_port(struct bfa_fcs_s *fcs)\r\n{\r\nreturn &fcs->fabric.bport;\r\n}\r\nwwn_t\r\nbfa_fcs_lport_get_rport(struct bfa_fcs_lport_s *port, wwn_t wwn, int index,\r\nint nrports, bfa_boolean_t bwwn)\r\n{\r\nstruct list_head *qh, *qe;\r\nstruct bfa_fcs_rport_s *rport = NULL;\r\nint i;\r\nstruct bfa_fcs_s *fcs;\r\nif (port == NULL || nrports == 0)\r\nreturn (wwn_t) 0;\r\nfcs = port->fcs;\r\nbfa_trc(fcs, (u32) nrports);\r\ni = 0;\r\nqh = &port->rport_q;\r\nqe = bfa_q_first(qh);\r\nwhile ((qe != qh) && (i < nrports)) {\r\nrport = (struct bfa_fcs_rport_s *) qe;\r\nif (bfa_ntoh3b(rport->pid) > 0xFFF000) {\r\nqe = bfa_q_next(qe);\r\nbfa_trc(fcs, (u32) rport->pwwn);\r\nbfa_trc(fcs, rport->pid);\r\nbfa_trc(fcs, i);\r\ncontinue;\r\n}\r\nif (bwwn) {\r\nif (!memcmp(&wwn, &rport->pwwn, 8))\r\nbreak;\r\n} else {\r\nif (i == index)\r\nbreak;\r\n}\r\ni++;\r\nqe = bfa_q_next(qe);\r\n}\r\nbfa_trc(fcs, i);\r\nif (rport)\r\nreturn rport->pwwn;\r\nelse\r\nreturn (wwn_t) 0;\r\n}\r\nvoid\r\nbfa_fcs_lport_get_rport_quals(struct bfa_fcs_lport_s *port,\r\nstruct bfa_rport_qualifier_s rports[], int *nrports)\r\n{\r\nstruct list_head *qh, *qe;\r\nstruct bfa_fcs_rport_s *rport = NULL;\r\nint i;\r\nstruct bfa_fcs_s *fcs;\r\nif (port == NULL || rports == NULL || *nrports == 0)\r\nreturn;\r\nfcs = port->fcs;\r\nbfa_trc(fcs, (u32) *nrports);\r\ni = 0;\r\nqh = &port->rport_q;\r\nqe = bfa_q_first(qh);\r\nwhile ((qe != qh) && (i < *nrports)) {\r\nrport = (struct bfa_fcs_rport_s *) qe;\r\nif (bfa_ntoh3b(rport->pid) > 0xFFF000) {\r\nqe = bfa_q_next(qe);\r\nbfa_trc(fcs, (u32) rport->pwwn);\r\nbfa_trc(fcs, rport->pid);\r\nbfa_trc(fcs, i);\r\ncontinue;\r\n}\r\nif (!rport->pwwn && !rport->pid) {\r\nqe = bfa_q_next(qe);\r\ncontinue;\r\n}\r\nrports[i].pwwn = rport->pwwn;\r\nrports[i].pid = rport->pid;\r\ni++;\r\nqe = bfa_q_next(qe);\r\n}\r\nbfa_trc(fcs, i);\r\n*nrports = i;\r\n}\r\nbfa_port_speed_t\r\nbfa_fcs_lport_get_rport_max_speed(bfa_fcs_lport_t *port)\r\n{\r\nstruct list_head *qh, *qe;\r\nstruct bfa_fcs_rport_s *rport = NULL;\r\nstruct bfa_fcs_s *fcs;\r\nbfa_port_speed_t max_speed = 0;\r\nstruct bfa_port_attr_s port_attr;\r\nbfa_port_speed_t port_speed, rport_speed;\r\nbfa_boolean_t trl_enabled = bfa_fcport_is_ratelim(port->fcs->bfa);\r\nif (port == NULL)\r\nreturn 0;\r\nfcs = port->fcs;\r\nbfa_fcport_get_attr(port->fcs->bfa, &port_attr);\r\nport_speed = port_attr.speed;\r\nbfa_trc(fcs, port_speed);\r\nqh = &port->rport_q;\r\nqe = bfa_q_first(qh);\r\nwhile (qe != qh) {\r\nrport = (struct bfa_fcs_rport_s *) qe;\r\nif ((bfa_ntoh3b(rport->pid) > 0xFFF000) ||\r\n(bfa_fcs_rport_get_state(rport) == BFA_RPORT_OFFLINE) ||\r\n(rport->scsi_function != BFA_RPORT_TARGET)) {\r\nqe = bfa_q_next(qe);\r\ncontinue;\r\n}\r\nrport_speed = rport->rpf.rpsc_speed;\r\nif ((trl_enabled) && (rport_speed ==\r\nBFA_PORT_SPEED_UNKNOWN)) {\r\nrport_speed =\r\nbfa_fcport_get_ratelim_speed(port->fcs->bfa);\r\n}\r\nif (rport_speed > max_speed)\r\nmax_speed = rport_speed;\r\nqe = bfa_q_next(qe);\r\n}\r\nif (max_speed > port_speed)\r\nmax_speed = port_speed;\r\nbfa_trc(fcs, max_speed);\r\nreturn max_speed;\r\n}\r\nstruct bfa_fcs_lport_s *\r\nbfa_fcs_lookup_port(struct bfa_fcs_s *fcs, u16 vf_id, wwn_t lpwwn)\r\n{\r\nstruct bfa_fcs_vport_s *vport;\r\nbfa_fcs_vf_t *vf;\r\nWARN_ON(fcs == NULL);\r\nvf = bfa_fcs_vf_lookup(fcs, vf_id);\r\nif (vf == NULL) {\r\nbfa_trc(fcs, vf_id);\r\nreturn NULL;\r\n}\r\nif (!lpwwn || (vf->bport.port_cfg.pwwn == lpwwn))\r\nreturn &vf->bport;\r\nvport = bfa_fcs_fabric_vport_lookup(vf, lpwwn);\r\nif (vport)\r\nreturn &vport->lport;\r\nreturn NULL;\r\n}\r\nvoid\r\nbfa_fcs_lport_get_info(struct bfa_fcs_lport_s *port,\r\nstruct bfa_lport_info_s *port_info)\r\n{\r\nbfa_trc(port->fcs, port->fabric->fabric_name);\r\nif (port->vport == NULL) {\r\nport_info->port_type = BFA_LPORT_TYPE_PHYSICAL;\r\nport_info->port_state = 0;\r\nport_info->offline_reason = 0;\r\nport_info->port_wwn = bfa_fcs_lport_get_pwwn(port);\r\nport_info->node_wwn = bfa_fcs_lport_get_nwwn(port);\r\nport_info->max_vports_supp =\r\nbfa_lps_get_max_vport(port->fcs->bfa);\r\nport_info->num_vports_inuse =\r\nport->fabric->num_vports;\r\nport_info->max_rports_supp = BFA_FCS_MAX_RPORTS_SUPP;\r\nport_info->num_rports_inuse = port->num_rports;\r\n} else {\r\nport_info->port_type = BFA_LPORT_TYPE_VIRTUAL;\r\nport_info->port_state = 0;\r\nport_info->offline_reason = 0;\r\nport_info->port_wwn = bfa_fcs_lport_get_pwwn(port);\r\nport_info->node_wwn = bfa_fcs_lport_get_nwwn(port);\r\n}\r\n}\r\nvoid\r\nbfa_fcs_lport_get_stats(struct bfa_fcs_lport_s *fcs_port,\r\nstruct bfa_lport_stats_s *port_stats)\r\n{\r\n*port_stats = fcs_port->stats;\r\n}\r\nvoid\r\nbfa_fcs_lport_clear_stats(struct bfa_fcs_lport_s *fcs_port)\r\n{\r\nmemset(&fcs_port->stats, 0, sizeof(struct bfa_lport_stats_s));\r\n}\r\nvoid\r\nbfa_fcs_lport_lip_scn_online(struct bfa_fcs_lport_s *port)\r\n{\r\nbfa_fcs_lport_loop_online(port);\r\n}\r\nstatic void\r\nbfa_fcs_vport_sm_uninit(struct bfa_fcs_vport_s *vport,\r\nenum bfa_fcs_vport_event event)\r\n{\r\nbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\r\nbfa_trc(__vport_fcs(vport), event);\r\nswitch (event) {\r\ncase BFA_FCS_VPORT_SM_CREATE:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_created);\r\nbfa_fcs_fabric_addvport(__vport_fabric(vport), vport);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(__vport_fcs(vport), event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_vport_sm_created(struct bfa_fcs_vport_s *vport,\r\nenum bfa_fcs_vport_event event)\r\n{\r\nbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\r\nbfa_trc(__vport_fcs(vport), event);\r\nswitch (event) {\r\ncase BFA_FCS_VPORT_SM_START:\r\nif (bfa_sm_cmp_state(__vport_fabric(vport),\r\nbfa_fcs_fabric_sm_online)\r\n&& bfa_fcs_fabric_npiv_capable(__vport_fabric(vport))) {\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_fdisc);\r\nbfa_fcs_vport_do_fdisc(vport);\r\n} else {\r\nvport->vport_stats.fab_no_npiv++;\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_offline);\r\n}\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_DELETE:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_cleanup);\r\nbfa_fcs_lport_delete(&vport->lport);\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_ONLINE:\r\ncase BFA_FCS_VPORT_SM_OFFLINE:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(__vport_fcs(vport), event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_vport_sm_offline(struct bfa_fcs_vport_s *vport,\r\nenum bfa_fcs_vport_event event)\r\n{\r\nbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\r\nbfa_trc(__vport_fcs(vport), event);\r\nswitch (event) {\r\ncase BFA_FCS_VPORT_SM_DELETE:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_cleanup);\r\nbfa_fcs_lport_delete(&vport->lport);\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_ONLINE:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_fdisc);\r\nvport->fdisc_retries = 0;\r\nbfa_fcs_vport_do_fdisc(vport);\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_STOP:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_cleanup);\r\nbfa_sm_send_event(&vport->lport, BFA_FCS_PORT_SM_STOP);\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_OFFLINE:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(__vport_fcs(vport), event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_vport_sm_fdisc(struct bfa_fcs_vport_s *vport,\r\nenum bfa_fcs_vport_event event)\r\n{\r\nbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\r\nbfa_trc(__vport_fcs(vport), event);\r\nswitch (event) {\r\ncase BFA_FCS_VPORT_SM_DELETE:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_fdisc_rsp_wait);\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_OFFLINE:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_offline);\r\nbfa_sm_send_event(vport->lps, BFA_LPS_SM_OFFLINE);\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_RSP_OK:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_online);\r\nbfa_fcs_lport_online(&vport->lport);\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_RSP_ERROR:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_fdisc_retry);\r\nbfa_timer_start(__vport_bfa(vport), &vport->timer,\r\nbfa_fcs_vport_timeout, vport,\r\nBFA_FCS_RETRY_TIMEOUT);\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_RSP_FAILED:\r\ncase BFA_FCS_VPORT_SM_FABRIC_MAX:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_offline);\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_RSP_DUP_WWN:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_error);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(__vport_fcs(vport), event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_vport_sm_fdisc_retry(struct bfa_fcs_vport_s *vport,\r\nenum bfa_fcs_vport_event event)\r\n{\r\nbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\r\nbfa_trc(__vport_fcs(vport), event);\r\nswitch (event) {\r\ncase BFA_FCS_VPORT_SM_DELETE:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_cleanup);\r\nbfa_timer_stop(&vport->timer);\r\nbfa_fcs_lport_delete(&vport->lport);\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_OFFLINE:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_offline);\r\nbfa_timer_stop(&vport->timer);\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_TIMEOUT:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_fdisc);\r\nvport->vport_stats.fdisc_retries++;\r\nvport->fdisc_retries++;\r\nbfa_fcs_vport_do_fdisc(vport);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(__vport_fcs(vport), event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_vport_sm_fdisc_rsp_wait(struct bfa_fcs_vport_s *vport,\r\nenum bfa_fcs_vport_event event)\r\n{\r\nbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\r\nbfa_trc(__vport_fcs(vport), event);\r\nswitch (event) {\r\ncase BFA_FCS_VPORT_SM_RSP_OK:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_deleting);\r\nbfa_fcs_lport_delete(&vport->lport);\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_DELETE:\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_OFFLINE:\r\ncase BFA_FCS_VPORT_SM_RSP_ERROR:\r\ncase BFA_FCS_VPORT_SM_RSP_FAILED:\r\ncase BFA_FCS_VPORT_SM_FABRIC_MAX:\r\ncase BFA_FCS_VPORT_SM_RSP_DUP_WWN:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_cleanup);\r\nbfa_sm_send_event(vport->lps, BFA_LPS_SM_OFFLINE);\r\nbfa_fcs_lport_delete(&vport->lport);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(__vport_fcs(vport), event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_vport_sm_online(struct bfa_fcs_vport_s *vport,\r\nenum bfa_fcs_vport_event event)\r\n{\r\nbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\r\nbfa_trc(__vport_fcs(vport), event);\r\nswitch (event) {\r\ncase BFA_FCS_VPORT_SM_DELETE:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_deleting);\r\nbfa_fcs_lport_delete(&vport->lport);\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_STOP:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_stopping);\r\nbfa_sm_send_event(&vport->lport, BFA_FCS_PORT_SM_STOP);\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_OFFLINE:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_offline);\r\nbfa_sm_send_event(vport->lps, BFA_LPS_SM_OFFLINE);\r\nbfa_fcs_lport_offline(&vport->lport);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(__vport_fcs(vport), event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_vport_sm_stopping(struct bfa_fcs_vport_s *vport,\r\nenum bfa_fcs_vport_event event)\r\n{\r\nbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\r\nbfa_trc(__vport_fcs(vport), event);\r\nswitch (event) {\r\ncase BFA_FCS_VPORT_SM_STOPCOMP:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_logo_for_stop);\r\nbfa_fcs_vport_do_logo(vport);\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_OFFLINE:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_cleanup);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(__vport_fcs(vport), event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_vport_sm_deleting(struct bfa_fcs_vport_s *vport,\r\nenum bfa_fcs_vport_event event)\r\n{\r\nbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\r\nbfa_trc(__vport_fcs(vport), event);\r\nswitch (event) {\r\ncase BFA_FCS_VPORT_SM_DELETE:\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_DELCOMP:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_logo);\r\nbfa_fcs_vport_do_logo(vport);\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_OFFLINE:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_cleanup);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(__vport_fcs(vport), event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_vport_sm_error(struct bfa_fcs_vport_s *vport,\r\nenum bfa_fcs_vport_event event)\r\n{\r\nbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\r\nbfa_trc(__vport_fcs(vport), event);\r\nswitch (event) {\r\ncase BFA_FCS_VPORT_SM_DELETE:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_cleanup);\r\nbfa_fcs_lport_delete(&vport->lport);\r\nbreak;\r\ndefault:\r\nbfa_trc(__vport_fcs(vport), event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_vport_sm_cleanup(struct bfa_fcs_vport_s *vport,\r\nenum bfa_fcs_vport_event event)\r\n{\r\nbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\r\nbfa_trc(__vport_fcs(vport), event);\r\nswitch (event) {\r\ncase BFA_FCS_VPORT_SM_DELCOMP:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_uninit);\r\nbfa_fcs_vport_free(vport);\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_STOPCOMP:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_created);\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_DELETE:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(__vport_fcs(vport), event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_vport_sm_logo_for_stop(struct bfa_fcs_vport_s *vport,\r\nenum bfa_fcs_vport_event event)\r\n{\r\nbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\r\nbfa_trc(__vport_fcs(vport), event);\r\nswitch (event) {\r\ncase BFA_FCS_VPORT_SM_OFFLINE:\r\nbfa_sm_send_event(vport->lps, BFA_LPS_SM_OFFLINE);\r\ncase BFA_FCS_VPORT_SM_RSP_OK:\r\ncase BFA_FCS_VPORT_SM_RSP_ERROR:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_created);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(__vport_fcs(vport), event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_vport_sm_logo(struct bfa_fcs_vport_s *vport,\r\nenum bfa_fcs_vport_event event)\r\n{\r\nbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\r\nbfa_trc(__vport_fcs(vport), event);\r\nswitch (event) {\r\ncase BFA_FCS_VPORT_SM_OFFLINE:\r\nbfa_sm_send_event(vport->lps, BFA_LPS_SM_OFFLINE);\r\ncase BFA_FCS_VPORT_SM_RSP_OK:\r\ncase BFA_FCS_VPORT_SM_RSP_ERROR:\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_uninit);\r\nbfa_fcs_vport_free(vport);\r\nbreak;\r\ncase BFA_FCS_VPORT_SM_DELETE:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(__vport_fcs(vport), event);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_vport_aen_post(struct bfa_fcs_lport_s *port,\r\nenum bfa_lport_aen_event event)\r\n{\r\nstruct bfad_s *bfad = (struct bfad_s *)port->fabric->fcs->bfad;\r\nstruct bfa_aen_entry_s *aen_entry;\r\nbfad_get_aen_entry(bfad, aen_entry);\r\nif (!aen_entry)\r\nreturn;\r\naen_entry->aen_data.lport.vf_id = port->fabric->vf_id;\r\naen_entry->aen_data.lport.roles = port->port_cfg.roles;\r\naen_entry->aen_data.lport.ppwwn = bfa_fcs_lport_get_pwwn(\r\nbfa_fcs_get_base_port(port->fcs));\r\naen_entry->aen_data.lport.lpwwn = bfa_fcs_lport_get_pwwn(port);\r\nbfad_im_post_vendor_event(aen_entry, bfad, ++port->fcs->fcs_aen_seq,\r\nBFA_AEN_CAT_LPORT, event);\r\n}\r\nstatic void\r\nbfa_fcs_vport_do_fdisc(struct bfa_fcs_vport_s *vport)\r\n{\r\nbfa_lps_fdisc(vport->lps, vport,\r\nbfa_fcport_get_maxfrsize(__vport_bfa(vport)),\r\n__vport_pwwn(vport), __vport_nwwn(vport));\r\nvport->vport_stats.fdisc_sent++;\r\n}\r\nstatic void\r\nbfa_fcs_vport_fdisc_rejected(struct bfa_fcs_vport_s *vport)\r\n{\r\nu8 lsrjt_rsn = vport->lps->lsrjt_rsn;\r\nu8 lsrjt_expl = vport->lps->lsrjt_expl;\r\nbfa_trc(__vport_fcs(vport), lsrjt_rsn);\r\nbfa_trc(__vport_fcs(vport), lsrjt_expl);\r\nswitch (vport->lps->lsrjt_expl) {\r\ncase FC_LS_RJT_EXP_INV_PORT_NAME:\r\ncase FC_LS_RJT_EXP_INVALID_NPORT_ID:\r\nif (vport->fdisc_retries < BFA_FCS_VPORT_MAX_RETRIES)\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_ERROR);\r\nelse {\r\nbfa_fcs_vport_aen_post(&vport->lport,\r\nBFA_LPORT_AEN_NPIV_DUP_WWN);\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_DUP_WWN);\r\n}\r\nbreak;\r\ncase FC_LS_RJT_EXP_INSUFF_RES:\r\nif (vport->fdisc_retries < BFA_FCS_VPORT_MAX_RETRIES)\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_ERROR);\r\nelse {\r\nbfa_fcs_vport_aen_post(&vport->lport,\r\nBFA_LPORT_AEN_NPIV_FABRIC_MAX);\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_FABRIC_MAX);\r\n}\r\nbreak;\r\ndefault:\r\nif (vport->fdisc_retries == 0)\r\nbfa_fcs_vport_aen_post(&vport->lport,\r\nBFA_LPORT_AEN_NPIV_UNKNOWN);\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_ERROR);\r\n}\r\n}\r\nstatic void\r\nbfa_fcs_vport_do_logo(struct bfa_fcs_vport_s *vport)\r\n{\r\nbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\r\nvport->vport_stats.logo_sent++;\r\nbfa_lps_fdisclogo(vport->lps);\r\n}\r\nstatic void\r\nbfa_fcs_vport_timeout(void *vport_arg)\r\n{\r\nstruct bfa_fcs_vport_s *vport = (struct bfa_fcs_vport_s *) vport_arg;\r\nvport->vport_stats.fdisc_timeouts++;\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_TIMEOUT);\r\n}\r\nstatic void\r\nbfa_fcs_vport_free(struct bfa_fcs_vport_s *vport)\r\n{\r\nstruct bfad_vport_s *vport_drv =\r\n(struct bfad_vport_s *)vport->vport_drv;\r\nbfa_fcs_fabric_delvport(__vport_fabric(vport), vport);\r\nbfa_lps_delete(vport->lps);\r\nif (vport_drv->comp_del) {\r\ncomplete(vport_drv->comp_del);\r\nreturn;\r\n}\r\nbfad_im_port_delete(vport_drv->drv_port.bfad, &vport_drv->drv_port);\r\n}\r\nvoid\r\nbfa_fcs_vport_online(struct bfa_fcs_vport_s *vport)\r\n{\r\nvport->vport_stats.fab_online++;\r\nif (bfa_fcs_fabric_npiv_capable(__vport_fabric(vport)))\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_ONLINE);\r\nelse\r\nvport->vport_stats.fab_no_npiv++;\r\n}\r\nvoid\r\nbfa_fcs_vport_offline(struct bfa_fcs_vport_s *vport)\r\n{\r\nvport->vport_stats.fab_offline++;\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_OFFLINE);\r\n}\r\nvoid\r\nbfa_fcs_vport_cleanup(struct bfa_fcs_vport_s *vport)\r\n{\r\nvport->vport_stats.fab_cleanup++;\r\n}\r\nvoid\r\nbfa_fcs_vport_fcs_stop(struct bfa_fcs_vport_s *vport)\r\n{\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_STOP);\r\n}\r\nvoid\r\nbfa_fcs_vport_fcs_delete(struct bfa_fcs_vport_s *vport)\r\n{\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_DELETE);\r\n}\r\nvoid\r\nbfa_fcs_vport_stop_comp(struct bfa_fcs_vport_s *vport)\r\n{\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_STOPCOMP);\r\n}\r\nvoid\r\nbfa_fcs_vport_delete_comp(struct bfa_fcs_vport_s *vport)\r\n{\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_DELCOMP);\r\n}\r\nbfa_status_t\r\nbfa_fcs_vport_create(struct bfa_fcs_vport_s *vport, struct bfa_fcs_s *fcs,\r\nu16 vf_id, struct bfa_lport_cfg_s *vport_cfg,\r\nstruct bfad_vport_s *vport_drv)\r\n{\r\nif (vport_cfg->pwwn == 0)\r\nreturn BFA_STATUS_INVALID_WWN;\r\nif (bfa_fcs_lport_get_pwwn(&fcs->fabric.bport) == vport_cfg->pwwn)\r\nreturn BFA_STATUS_VPORT_WWN_BP;\r\nif (bfa_fcs_vport_lookup(fcs, vf_id, vport_cfg->pwwn) != NULL)\r\nreturn BFA_STATUS_VPORT_EXISTS;\r\nif (fcs->fabric.num_vports ==\r\nbfa_lps_get_max_vport(fcs->bfa))\r\nreturn BFA_STATUS_VPORT_MAX;\r\nvport->lps = bfa_lps_alloc(fcs->bfa);\r\nif (!vport->lps)\r\nreturn BFA_STATUS_VPORT_MAX;\r\nvport->vport_drv = vport_drv;\r\nvport_cfg->preboot_vp = BFA_FALSE;\r\nbfa_sm_set_state(vport, bfa_fcs_vport_sm_uninit);\r\nbfa_fcs_lport_attach(&vport->lport, fcs, vf_id, vport);\r\nbfa_fcs_lport_init(&vport->lport, vport_cfg);\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_CREATE);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_fcs_pbc_vport_create(struct bfa_fcs_vport_s *vport, struct bfa_fcs_s *fcs,\r\nu16 vf_id, struct bfa_lport_cfg_s *vport_cfg,\r\nstruct bfad_vport_s *vport_drv)\r\n{\r\nbfa_status_t rc;\r\nrc = bfa_fcs_vport_create(vport, fcs, vf_id, vport_cfg, vport_drv);\r\nvport->lport.port_cfg.preboot_vp = BFA_TRUE;\r\nreturn rc;\r\n}\r\nbfa_boolean_t\r\nbfa_fcs_is_pbc_vport(struct bfa_fcs_vport_s *vport)\r\n{\r\nif (vport && (vport->lport.port_cfg.preboot_vp == BFA_TRUE))\r\nreturn BFA_TRUE;\r\nelse\r\nreturn BFA_FALSE;\r\n}\r\nbfa_status_t\r\nbfa_fcs_vport_start(struct bfa_fcs_vport_s *vport)\r\n{\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_START);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_fcs_vport_stop(struct bfa_fcs_vport_s *vport)\r\n{\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_STOP);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_fcs_vport_delete(struct bfa_fcs_vport_s *vport)\r\n{\r\nif (vport->lport.port_cfg.preboot_vp)\r\nreturn BFA_STATUS_PBC;\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_DELETE);\r\nreturn BFA_STATUS_OK;\r\n}\r\nvoid\r\nbfa_fcs_vport_get_attr(struct bfa_fcs_vport_s *vport,\r\nstruct bfa_vport_attr_s *attr)\r\n{\r\nif (vport == NULL || attr == NULL)\r\nreturn;\r\nmemset(attr, 0, sizeof(struct bfa_vport_attr_s));\r\nbfa_fcs_lport_get_attr(&vport->lport, &attr->port_attr);\r\nattr->vport_state = bfa_sm_to_state(vport_sm_table, vport->sm);\r\n}\r\nstruct bfa_fcs_vport_s *\r\nbfa_fcs_vport_lookup(struct bfa_fcs_s *fcs, u16 vf_id, wwn_t vpwwn)\r\n{\r\nstruct bfa_fcs_vport_s *vport;\r\nstruct bfa_fcs_fabric_s *fabric;\r\nbfa_trc(fcs, vf_id);\r\nbfa_trc(fcs, vpwwn);\r\nfabric = bfa_fcs_vf_lookup(fcs, vf_id);\r\nif (!fabric) {\r\nbfa_trc(fcs, vf_id);\r\nreturn NULL;\r\n}\r\nvport = bfa_fcs_fabric_vport_lookup(fabric, vpwwn);\r\nreturn vport;\r\n}\r\nvoid\r\nbfa_cb_lps_fdisc_comp(void *bfad, void *uarg, bfa_status_t status)\r\n{\r\nstruct bfa_fcs_vport_s *vport = uarg;\r\nbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\r\nbfa_trc(__vport_fcs(vport), status);\r\nswitch (status) {\r\ncase BFA_STATUS_OK:\r\n__vport_fcid(vport) = vport->lps->lp_pid;\r\nvport->vport_stats.fdisc_accepts++;\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_OK);\r\nbreak;\r\ncase BFA_STATUS_INVALID_MAC:\r\nvport->vport_stats.fdisc_acc_bad++;\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_ERROR);\r\nbreak;\r\ncase BFA_STATUS_EPROTOCOL:\r\nswitch (vport->lps->ext_status) {\r\ncase BFA_EPROTO_BAD_ACCEPT:\r\nvport->vport_stats.fdisc_acc_bad++;\r\nbreak;\r\ncase BFA_EPROTO_UNKNOWN_RSP:\r\nvport->vport_stats.fdisc_unknown_rsp++;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (vport->fdisc_retries < BFA_FCS_VPORT_MAX_RETRIES)\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_ERROR);\r\nelse\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_FAILED);\r\nbreak;\r\ncase BFA_STATUS_ETIMER:\r\nvport->vport_stats.fdisc_timeouts++;\r\nif (vport->fdisc_retries < BFA_FCS_VPORT_MAX_RETRIES)\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_ERROR);\r\nelse\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_FAILED);\r\nbreak;\r\ncase BFA_STATUS_FABRIC_RJT:\r\nvport->vport_stats.fdisc_rejects++;\r\nbfa_fcs_vport_fdisc_rejected(vport);\r\nbreak;\r\ndefault:\r\nvport->vport_stats.fdisc_rsp_err++;\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_ERROR);\r\n}\r\n}\r\nvoid\r\nbfa_cb_lps_fdisclogo_comp(void *bfad, void *uarg)\r\n{\r\nstruct bfa_fcs_vport_s *vport = uarg;\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_OK);\r\n}\r\nvoid\r\nbfa_cb_lps_cvl_event(void *bfad, void *uarg)\r\n{\r\nstruct bfa_fcs_vport_s *vport = uarg;\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_OFFLINE);\r\nbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_ONLINE);\r\n}
