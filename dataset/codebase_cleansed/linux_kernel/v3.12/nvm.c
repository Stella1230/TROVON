static int iwl_nvm_write_chunk(struct iwl_mvm *mvm, u16 section,\r\nu16 offset, u16 length, const u8 *data)\r\n{\r\nstruct iwl_nvm_access_cmd nvm_access_cmd = {\r\n.offset = cpu_to_le16(offset),\r\n.length = cpu_to_le16(length),\r\n.type = cpu_to_le16(section),\r\n.op_code = NVM_WRITE_OPCODE,\r\n};\r\nstruct iwl_host_cmd cmd = {\r\n.id = NVM_ACCESS_CMD,\r\n.len = { sizeof(struct iwl_nvm_access_cmd), length },\r\n.flags = CMD_SYNC | CMD_SEND_IN_RFKILL,\r\n.data = { &nvm_access_cmd, data },\r\n.dataflags = { 0, IWL_HCMD_DFL_DUP },\r\n};\r\nreturn iwl_mvm_send_cmd(mvm, &cmd);\r\n}\r\nstatic int iwl_nvm_read_chunk(struct iwl_mvm *mvm, u16 section,\r\nu16 offset, u16 length, u8 *data)\r\n{\r\nstruct iwl_nvm_access_cmd nvm_access_cmd = {\r\n.offset = cpu_to_le16(offset),\r\n.length = cpu_to_le16(length),\r\n.type = cpu_to_le16(section),\r\n.op_code = NVM_READ_OPCODE,\r\n};\r\nstruct iwl_nvm_access_resp *nvm_resp;\r\nstruct iwl_rx_packet *pkt;\r\nstruct iwl_host_cmd cmd = {\r\n.id = NVM_ACCESS_CMD,\r\n.flags = CMD_SYNC | CMD_WANT_SKB | CMD_SEND_IN_RFKILL,\r\n.data = { &nvm_access_cmd, },\r\n};\r\nint ret, bytes_read, offset_read;\r\nu8 *resp_data;\r\ncmd.len[0] = sizeof(struct iwl_nvm_access_cmd);\r\nret = iwl_mvm_send_cmd(mvm, &cmd);\r\nif (ret)\r\nreturn ret;\r\npkt = cmd.resp_pkt;\r\nif (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {\r\nIWL_ERR(mvm, "Bad return from NVM_ACCES_COMMAND (0x%08X)\n",\r\npkt->hdr.flags);\r\nret = -EIO;\r\ngoto exit;\r\n}\r\nnvm_resp = (void *)pkt->data;\r\nret = le16_to_cpu(nvm_resp->status);\r\nbytes_read = le16_to_cpu(nvm_resp->length);\r\noffset_read = le16_to_cpu(nvm_resp->offset);\r\nresp_data = nvm_resp->data;\r\nif (ret) {\r\nIWL_ERR(mvm,\r\n"NVM access command failed with status %d (device: %s)\n",\r\nret, mvm->cfg->name);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nif (offset_read != offset) {\r\nIWL_ERR(mvm, "NVM ACCESS response with invalid offset %d\n",\r\noffset_read);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nmemcpy(data + offset, resp_data, bytes_read);\r\nret = bytes_read;\r\nexit:\r\niwl_free_resp(&cmd);\r\nreturn ret;\r\n}\r\nstatic int iwl_nvm_write_section(struct iwl_mvm *mvm, u16 section,\r\nconst u8 *data, u16 length)\r\n{\r\nint offset = 0;\r\nwhile (offset < length) {\r\nint chunk_size, ret;\r\nchunk_size = min(IWL_NVM_DEFAULT_CHUNK_SIZE,\r\nlength - offset);\r\nret = iwl_nvm_write_chunk(mvm, section, offset,\r\nchunk_size, data + offset);\r\nif (ret < 0)\r\nreturn ret;\r\noffset += chunk_size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iwl_nvm_read_section(struct iwl_mvm *mvm, u16 section,\r\nu8 *data)\r\n{\r\nu16 length, offset = 0;\r\nint ret;\r\nlength = IWL_NVM_DEFAULT_CHUNK_SIZE;\r\nret = length;\r\nwhile (ret == length) {\r\nret = iwl_nvm_read_chunk(mvm, section, offset, length, data);\r\nif (ret < 0) {\r\nIWL_ERR(mvm,\r\n"Cannot read NVM from section %d offset %d, length %d\n",\r\nsection, offset, length);\r\nreturn ret;\r\n}\r\noffset += ret;\r\n}\r\nIWL_DEBUG_EEPROM(mvm->trans->dev,\r\n"NVM section %d read completed\n", section);\r\nreturn offset;\r\n}\r\nstatic struct iwl_nvm_data *\r\niwl_parse_nvm_sections(struct iwl_mvm *mvm)\r\n{\r\nstruct iwl_nvm_section *sections = mvm->nvm_sections;\r\nconst __le16 *hw, *sw, *calib;\r\nif (!mvm->nvm_sections[NVM_SECTION_TYPE_SW].data ||\r\n!mvm->nvm_sections[NVM_SECTION_TYPE_HW].data) {\r\nIWL_ERR(mvm, "Can't parse empty NVM sections\n");\r\nreturn NULL;\r\n}\r\nif (WARN_ON(!mvm->cfg))\r\nreturn NULL;\r\nhw = (const __le16 *)sections[NVM_SECTION_TYPE_HW].data;\r\nsw = (const __le16 *)sections[NVM_SECTION_TYPE_SW].data;\r\ncalib = (const __le16 *)sections[NVM_SECTION_TYPE_CALIBRATION].data;\r\nreturn iwl_parse_nvm_data(mvm->trans->dev, mvm->cfg, hw, sw, calib,\r\niwl_fw_valid_tx_ant(mvm->fw),\r\niwl_fw_valid_rx_ant(mvm->fw));\r\n}\r\nstatic int iwl_mvm_load_external_nvm(struct iwl_mvm *mvm)\r\n{\r\nint ret, section_id, section_size;\r\nconst struct firmware *fw_entry;\r\nconst struct {\r\n__le16 word1;\r\n__le16 word2;\r\nu8 data[];\r\n} *file_sec;\r\nconst u8 *eof;\r\n#define NVM_WORD1_LEN(x) (8 * (x & 0x03FF))\r\n#define NVM_WORD2_ID(x) (x >> 12)\r\nret = request_firmware(&fw_entry, iwlwifi_mod_params.nvm_file,\r\nmvm->trans->dev);\r\nif (ret) {\r\nIWL_ERR(mvm, "ERROR: %s isn't available %d\n",\r\niwlwifi_mod_params.nvm_file, ret);\r\nreturn ret;\r\n}\r\nIWL_INFO(mvm, "Loaded NVM file %s (%zu bytes)\n",\r\niwlwifi_mod_params.nvm_file, fw_entry->size);\r\nif (fw_entry->size < sizeof(*file_sec)) {\r\nIWL_ERR(mvm, "NVM file too small\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (fw_entry->size > MAX_NVM_FILE_LEN) {\r\nIWL_ERR(mvm, "NVM file too large\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\neof = fw_entry->data + fw_entry->size;\r\nfile_sec = (void *)fw_entry->data;\r\nwhile (true) {\r\nif (file_sec->data > eof) {\r\nIWL_ERR(mvm,\r\n"ERROR - NVM file too short for section header\n");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (!file_sec->word1 && !file_sec->word2) {\r\nret = 0;\r\nbreak;\r\n}\r\nsection_size = 2 * NVM_WORD1_LEN(le16_to_cpu(file_sec->word1));\r\nsection_id = NVM_WORD2_ID(le16_to_cpu(file_sec->word2));\r\nif (section_size > IWL_MAX_NVM_SECTION_SIZE) {\r\nIWL_ERR(mvm, "ERROR - section too large (%d)\n",\r\nsection_size);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (!section_size) {\r\nIWL_ERR(mvm, "ERROR - section empty\n");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (file_sec->data + section_size > eof) {\r\nIWL_ERR(mvm,\r\n"ERROR - NVM file too short for section (%d bytes)\n",\r\nsection_size);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = iwl_nvm_write_section(mvm, section_id, file_sec->data,\r\nsection_size);\r\nif (ret < 0) {\r\nIWL_ERR(mvm, "iwl_mvm_send_cmd failed: %d\n", ret);\r\nbreak;\r\n}\r\nfile_sec = (void *)(file_sec->data + section_size);\r\n}\r\nout:\r\nrelease_firmware(fw_entry);\r\nreturn ret;\r\n}\r\nint iwl_nvm_init(struct iwl_mvm *mvm)\r\n{\r\nint ret, i, section;\r\nu8 *nvm_buffer, *temp;\r\nif (iwlwifi_mod_params.nvm_file) {\r\nret = iwl_mvm_load_external_nvm(mvm);\r\nif (ret)\r\nreturn ret;\r\n}\r\nIWL_DEBUG_EEPROM(mvm->trans->dev, "Read from NVM\n");\r\nnvm_buffer = kmalloc(mvm->cfg->base_params->eeprom_size,\r\nGFP_KERNEL);\r\nif (!nvm_buffer)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(nvm_to_read); i++) {\r\nsection = nvm_to_read[i];\r\nret = iwl_nvm_read_section(mvm, section, nvm_buffer);\r\nif (ret < 0)\r\nbreak;\r\ntemp = kmemdup(nvm_buffer, ret, GFP_KERNEL);\r\nif (!temp) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nmvm->nvm_sections[section].data = temp;\r\nmvm->nvm_sections[section].length = ret;\r\n}\r\nkfree(nvm_buffer);\r\nif (ret < 0)\r\nreturn ret;\r\nmvm->nvm_data = iwl_parse_nvm_sections(mvm);\r\nif (!mvm->nvm_data)\r\nreturn -ENODATA;\r\nreturn 0;\r\n}
