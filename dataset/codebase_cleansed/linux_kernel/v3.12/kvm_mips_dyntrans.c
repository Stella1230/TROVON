int\r\nkvm_mips_trans_cache_index(uint32_t inst, uint32_t *opc,\r\nstruct kvm_vcpu *vcpu)\r\n{\r\nint result = 0;\r\nunsigned long kseg0_opc;\r\nuint32_t synci_inst = 0x0;\r\nkseg0_opc =\r\nCKSEG0ADDR(kvm_mips_translate_guest_kseg0_to_hpa\r\n(vcpu, (unsigned long) opc));\r\nmemcpy((void *)kseg0_opc, (void *)&synci_inst, sizeof(uint32_t));\r\nmips32_SyncICache(kseg0_opc, 32);\r\nreturn result;\r\n}\r\nint\r\nkvm_mips_trans_cache_va(uint32_t inst, uint32_t *opc,\r\nstruct kvm_vcpu *vcpu)\r\n{\r\nint result = 0;\r\nunsigned long kseg0_opc;\r\nuint32_t synci_inst = SYNCI_TEMPLATE, base, offset;\r\nbase = (inst >> 21) & 0x1f;\r\noffset = inst & 0xffff;\r\nsynci_inst |= (base << 21);\r\nsynci_inst |= offset;\r\nkseg0_opc =\r\nCKSEG0ADDR(kvm_mips_translate_guest_kseg0_to_hpa\r\n(vcpu, (unsigned long) opc));\r\nmemcpy((void *)kseg0_opc, (void *)&synci_inst, sizeof(uint32_t));\r\nmips32_SyncICache(kseg0_opc, 32);\r\nreturn result;\r\n}\r\nint\r\nkvm_mips_trans_mfc0(uint32_t inst, uint32_t *opc, struct kvm_vcpu *vcpu)\r\n{\r\nint32_t rt, rd, sel;\r\nuint32_t mfc0_inst;\r\nunsigned long kseg0_opc, flags;\r\nrt = (inst >> 16) & 0x1f;\r\nrd = (inst >> 11) & 0x1f;\r\nsel = inst & 0x7;\r\nif ((rd == MIPS_CP0_ERRCTL) && (sel == 0)) {\r\nmfc0_inst = CLEAR_TEMPLATE;\r\nmfc0_inst |= ((rt & 0x1f) << 16);\r\n} else {\r\nmfc0_inst = LW_TEMPLATE;\r\nmfc0_inst |= ((rt & 0x1f) << 16);\r\nmfc0_inst |=\r\noffsetof(struct mips_coproc,\r\nreg[rd][sel]) + offsetof(struct kvm_mips_commpage,\r\ncop0);\r\n}\r\nif (KVM_GUEST_KSEGX(opc) == KVM_GUEST_KSEG0) {\r\nkseg0_opc =\r\nCKSEG0ADDR(kvm_mips_translate_guest_kseg0_to_hpa\r\n(vcpu, (unsigned long) opc));\r\nmemcpy((void *)kseg0_opc, (void *)&mfc0_inst, sizeof(uint32_t));\r\nmips32_SyncICache(kseg0_opc, 32);\r\n} else if (KVM_GUEST_KSEGX((unsigned long) opc) == KVM_GUEST_KSEG23) {\r\nlocal_irq_save(flags);\r\nmemcpy((void *)opc, (void *)&mfc0_inst, sizeof(uint32_t));\r\nmips32_SyncICache((unsigned long) opc, 32);\r\nlocal_irq_restore(flags);\r\n} else {\r\nkvm_err("%s: Invalid address: %p\n", __func__, opc);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nkvm_mips_trans_mtc0(uint32_t inst, uint32_t *opc, struct kvm_vcpu *vcpu)\r\n{\r\nint32_t rt, rd, sel;\r\nuint32_t mtc0_inst = SW_TEMPLATE;\r\nunsigned long kseg0_opc, flags;\r\nrt = (inst >> 16) & 0x1f;\r\nrd = (inst >> 11) & 0x1f;\r\nsel = inst & 0x7;\r\nmtc0_inst |= ((rt & 0x1f) << 16);\r\nmtc0_inst |=\r\noffsetof(struct mips_coproc,\r\nreg[rd][sel]) + offsetof(struct kvm_mips_commpage, cop0);\r\nif (KVM_GUEST_KSEGX(opc) == KVM_GUEST_KSEG0) {\r\nkseg0_opc =\r\nCKSEG0ADDR(kvm_mips_translate_guest_kseg0_to_hpa\r\n(vcpu, (unsigned long) opc));\r\nmemcpy((void *)kseg0_opc, (void *)&mtc0_inst, sizeof(uint32_t));\r\nmips32_SyncICache(kseg0_opc, 32);\r\n} else if (KVM_GUEST_KSEGX((unsigned long) opc) == KVM_GUEST_KSEG23) {\r\nlocal_irq_save(flags);\r\nmemcpy((void *)opc, (void *)&mtc0_inst, sizeof(uint32_t));\r\nmips32_SyncICache((unsigned long) opc, 32);\r\nlocal_irq_restore(flags);\r\n} else {\r\nkvm_err("%s: Invalid address: %p\n", __func__, opc);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}
