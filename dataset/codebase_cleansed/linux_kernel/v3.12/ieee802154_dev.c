int mac802154_slave_open(struct net_device *dev)\r\n{\r\nstruct mac802154_sub_if_data *priv = netdev_priv(dev);\r\nstruct mac802154_priv *ipriv = priv->hw;\r\nint res = 0;\r\nif (ipriv->open_count++ == 0) {\r\nres = ipriv->ops->start(&ipriv->hw);\r\nWARN_ON(res);\r\nif (res)\r\ngoto err;\r\n}\r\nif (ipriv->ops->ieee_addr) {\r\nres = ipriv->ops->ieee_addr(&ipriv->hw, dev->dev_addr);\r\nWARN_ON(res);\r\nif (res)\r\ngoto err;\r\nmac802154_dev_set_ieee_addr(dev);\r\n}\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nerr:\r\npriv->hw->open_count--;\r\nreturn res;\r\n}\r\nint mac802154_slave_close(struct net_device *dev)\r\n{\r\nstruct mac802154_sub_if_data *priv = netdev_priv(dev);\r\nstruct mac802154_priv *ipriv = priv->hw;\r\nnetif_stop_queue(dev);\r\nif (!--ipriv->open_count)\r\nipriv->ops->stop(&ipriv->hw);\r\nreturn 0;\r\n}\r\nstatic int\r\nmac802154_netdev_register(struct wpan_phy *phy, struct net_device *dev)\r\n{\r\nstruct mac802154_sub_if_data *priv;\r\nstruct mac802154_priv *ipriv;\r\nint err;\r\nipriv = wpan_phy_priv(phy);\r\npriv = netdev_priv(dev);\r\npriv->dev = dev;\r\npriv->hw = ipriv;\r\ndev->needed_headroom = ipriv->hw.extra_tx_headroom;\r\nSET_NETDEV_DEV(dev, &ipriv->phy->dev);\r\nmutex_lock(&ipriv->slaves_mtx);\r\nif (!ipriv->running) {\r\nmutex_unlock(&ipriv->slaves_mtx);\r\nreturn -ENODEV;\r\n}\r\nmutex_unlock(&ipriv->slaves_mtx);\r\nerr = register_netdev(dev);\r\nif (err < 0)\r\nreturn err;\r\nrtnl_lock();\r\nmutex_lock(&ipriv->slaves_mtx);\r\nlist_add_tail_rcu(&priv->list, &ipriv->slaves);\r\nmutex_unlock(&ipriv->slaves_mtx);\r\nrtnl_unlock();\r\nreturn 0;\r\n}\r\nstatic void\r\nmac802154_del_iface(struct wpan_phy *phy, struct net_device *dev)\r\n{\r\nstruct mac802154_sub_if_data *sdata;\r\nASSERT_RTNL();\r\nsdata = netdev_priv(dev);\r\nBUG_ON(sdata->hw->phy != phy);\r\nmutex_lock(&sdata->hw->slaves_mtx);\r\nlist_del_rcu(&sdata->list);\r\nmutex_unlock(&sdata->hw->slaves_mtx);\r\nsynchronize_rcu();\r\nunregister_netdevice(sdata->dev);\r\n}\r\nstatic struct net_device *\r\nmac802154_add_iface(struct wpan_phy *phy, const char *name, int type)\r\n{\r\nstruct net_device *dev;\r\nint err = -ENOMEM;\r\nswitch (type) {\r\ncase IEEE802154_DEV_MONITOR:\r\ndev = alloc_netdev(sizeof(struct mac802154_sub_if_data),\r\nname, mac802154_monitor_setup);\r\nbreak;\r\ncase IEEE802154_DEV_WPAN:\r\ndev = alloc_netdev(sizeof(struct mac802154_sub_if_data),\r\nname, mac802154_wpan_setup);\r\nbreak;\r\ndefault:\r\ndev = NULL;\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (!dev)\r\ngoto err;\r\nerr = mac802154_netdev_register(phy, dev);\r\nif (err)\r\ngoto err_free;\r\ndev_hold(dev);\r\nreturn dev;\r\nerr_free:\r\nfree_netdev(dev);\r\nerr:\r\nreturn ERR_PTR(err);\r\n}\r\nstruct ieee802154_dev *\r\nieee802154_alloc_device(size_t priv_data_len, struct ieee802154_ops *ops)\r\n{\r\nstruct wpan_phy *phy;\r\nstruct mac802154_priv *priv;\r\nsize_t priv_size;\r\nif (!ops || !ops->xmit || !ops->ed || !ops->start ||\r\n!ops->stop || !ops->set_channel) {\r\nprintk(KERN_ERR\r\n"undefined IEEE802.15.4 device operations\n");\r\nreturn NULL;\r\n}\r\npriv_size = ALIGN(sizeof(*priv), NETDEV_ALIGN) + priv_data_len;\r\nphy = wpan_phy_alloc(priv_size);\r\nif (!phy) {\r\nprintk(KERN_ERR\r\n"failure to allocate master IEEE802.15.4 device\n");\r\nreturn NULL;\r\n}\r\npriv = wpan_phy_priv(phy);\r\npriv->hw.phy = priv->phy = phy;\r\npriv->hw.priv = (char *)priv + ALIGN(sizeof(*priv), NETDEV_ALIGN);\r\npriv->ops = ops;\r\nINIT_LIST_HEAD(&priv->slaves);\r\nmutex_init(&priv->slaves_mtx);\r\nreturn &priv->hw;\r\n}\r\nvoid ieee802154_free_device(struct ieee802154_dev *hw)\r\n{\r\nstruct mac802154_priv *priv = mac802154_to_priv(hw);\r\nBUG_ON(!list_empty(&priv->slaves));\r\nmutex_destroy(&priv->slaves_mtx);\r\nwpan_phy_free(priv->phy);\r\n}\r\nint ieee802154_register_device(struct ieee802154_dev *dev)\r\n{\r\nstruct mac802154_priv *priv = mac802154_to_priv(dev);\r\nint rc = -ENOMEM;\r\npriv->dev_workqueue =\r\ncreate_singlethread_workqueue(wpan_phy_name(priv->phy));\r\nif (!priv->dev_workqueue)\r\ngoto out;\r\nwpan_phy_set_dev(priv->phy, priv->hw.parent);\r\npriv->phy->add_iface = mac802154_add_iface;\r\npriv->phy->del_iface = mac802154_del_iface;\r\nrc = wpan_phy_register(priv->phy);\r\nif (rc < 0)\r\ngoto out_wq;\r\nrtnl_lock();\r\nmutex_lock(&priv->slaves_mtx);\r\npriv->running = MAC802154_DEVICE_RUN;\r\nmutex_unlock(&priv->slaves_mtx);\r\nrtnl_unlock();\r\nreturn 0;\r\nout_wq:\r\ndestroy_workqueue(priv->dev_workqueue);\r\nout:\r\nreturn rc;\r\n}\r\nvoid ieee802154_unregister_device(struct ieee802154_dev *dev)\r\n{\r\nstruct mac802154_priv *priv = mac802154_to_priv(dev);\r\nstruct mac802154_sub_if_data *sdata, *next;\r\nflush_workqueue(priv->dev_workqueue);\r\ndestroy_workqueue(priv->dev_workqueue);\r\nrtnl_lock();\r\nmutex_lock(&priv->slaves_mtx);\r\npriv->running = MAC802154_DEVICE_STOPPED;\r\nmutex_unlock(&priv->slaves_mtx);\r\nlist_for_each_entry_safe(sdata, next, &priv->slaves, list) {\r\nmutex_lock(&sdata->hw->slaves_mtx);\r\nlist_del(&sdata->list);\r\nmutex_unlock(&sdata->hw->slaves_mtx);\r\nunregister_netdevice(sdata->dev);\r\n}\r\nrtnl_unlock();\r\nwpan_phy_unregister(priv->phy);\r\n}
