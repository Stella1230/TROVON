void sms_ir_event(struct smscore_device_t *coredev, const char *buf, int len)\r\n{\r\nint i;\r\nconst s32 *samples = (const void *)buf;\r\nfor (i = 0; i < len >> 2; i++) {\r\nDEFINE_IR_RAW_EVENT(ev);\r\nev.duration = abs(samples[i]) * 1000;\r\nev.pulse = (samples[i] > 0) ? false : true;\r\nir_raw_event_store(coredev->ir.dev, &ev);\r\n}\r\nir_raw_event_handle(coredev->ir.dev);\r\n}\r\nint sms_ir_init(struct smscore_device_t *coredev)\r\n{\r\nint err;\r\nint board_id = smscore_get_board_id(coredev);\r\nstruct rc_dev *dev;\r\nsms_log("Allocating rc device");\r\ndev = rc_allocate_device();\r\nif (!dev) {\r\nsms_err("Not enough memory");\r\nreturn -ENOMEM;\r\n}\r\ncoredev->ir.controller = 0;\r\ncoredev->ir.timeout = IR_DEFAULT_TIMEOUT;\r\nsms_log("IR port %d, timeout %d ms",\r\ncoredev->ir.controller, coredev->ir.timeout);\r\nsnprintf(coredev->ir.name, sizeof(coredev->ir.name),\r\n"SMS IR (%s)", sms_get_board(board_id)->name);\r\nstrlcpy(coredev->ir.phys, coredev->devpath, sizeof(coredev->ir.phys));\r\nstrlcat(coredev->ir.phys, "/ir0", sizeof(coredev->ir.phys));\r\ndev->input_name = coredev->ir.name;\r\ndev->input_phys = coredev->ir.phys;\r\ndev->dev.parent = coredev->device;\r\n#if 0\r\ndev->input_id.bustype = BUS_USB;\r\ndev->input_id.version = 1;\r\ndev->input_id.vendor = le16_to_cpu(dev->udev->descriptor.idVendor);\r\ndev->input_id.product = le16_to_cpu(dev->udev->descriptor.idProduct);\r\n#endif\r\ndev->priv = coredev;\r\ndev->driver_type = RC_DRIVER_IR_RAW;\r\ndev->allowed_protos = RC_BIT_ALL;\r\ndev->map_name = sms_get_board(board_id)->rc_codes;\r\ndev->driver_name = MODULE_NAME;\r\nsms_log("Input device (IR) %s is set for key events", dev->input_name);\r\nerr = rc_register_device(dev);\r\nif (err < 0) {\r\nsms_err("Failed to register device");\r\nrc_free_device(dev);\r\nreturn err;\r\n}\r\ncoredev->ir.dev = dev;\r\nreturn 0;\r\n}\r\nvoid sms_ir_exit(struct smscore_device_t *coredev)\r\n{\r\nif (coredev->ir.dev)\r\nrc_unregister_device(coredev->ir.dev);\r\nsms_log("");\r\n}
