static void dvb_bt8xx_task(unsigned long data)\r\n{\r\nstruct dvb_bt8xx_card *card = (struct dvb_bt8xx_card *)data;\r\nwhile (card->bt->last_block != card->bt->finished_block) {\r\n(card->bt->TS_Size ? dvb_dmx_swfilter_204 : dvb_dmx_swfilter)\r\n(&card->demux,\r\n&card->bt->buf_cpu[card->bt->last_block *\r\ncard->bt->block_bytes],\r\ncard->bt->block_bytes);\r\ncard->bt->last_block = (card->bt->last_block + 1) %\r\ncard->bt->block_count;\r\n}\r\n}\r\nstatic int dvb_bt8xx_start_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct dvb_demux*dvbdmx = dvbdmxfeed->demux;\r\nstruct dvb_bt8xx_card *card = dvbdmx->priv;\r\nint rc;\r\ndprintk("dvb_bt8xx: start_feed\n");\r\nif (!dvbdmx->dmx.frontend)\r\nreturn -EINVAL;\r\nmutex_lock(&card->lock);\r\ncard->nfeeds++;\r\nrc = card->nfeeds;\r\nif (card->nfeeds == 1)\r\nbt878_start(card->bt, card->gpio_mode,\r\ncard->op_sync_orin, card->irq_err_ignore);\r\nmutex_unlock(&card->lock);\r\nreturn rc;\r\n}\r\nstatic int dvb_bt8xx_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\r\nstruct dvb_bt8xx_card *card = dvbdmx->priv;\r\ndprintk("dvb_bt8xx: stop_feed\n");\r\nif (!dvbdmx->dmx.frontend)\r\nreturn -EINVAL;\r\nmutex_lock(&card->lock);\r\ncard->nfeeds--;\r\nif (card->nfeeds == 0)\r\nbt878_stop(card->bt);\r\nmutex_unlock(&card->lock);\r\nreturn 0;\r\n}\r\nstatic int is_pci_slot_eq(struct pci_dev* adev, struct pci_dev* bdev)\r\n{\r\nif ((adev->subsystem_vendor == bdev->subsystem_vendor) &&\r\n(adev->subsystem_device == bdev->subsystem_device) &&\r\n(adev->bus->number == bdev->bus->number) &&\r\n(PCI_SLOT(adev->devfn) == PCI_SLOT(bdev->devfn)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic struct bt878 *dvb_bt8xx_878_match(unsigned int bttv_nr,\r\nstruct pci_dev* bttv_pci_dev)\r\n{\r\nunsigned int card_nr;\r\nfor (card_nr = 0; card_nr < bt878_num; card_nr++)\r\nif (is_pci_slot_eq(bt878[card_nr].dev, bttv_pci_dev))\r\nreturn &bt878[card_nr];\r\nreturn NULL;\r\n}\r\nstatic int thomson_dtt7579_demod_init(struct dvb_frontend* fe)\r\n{\r\nstatic u8 mt352_clock_config [] = { 0x89, 0x38, 0x38 };\r\nstatic u8 mt352_reset [] = { 0x50, 0x80 };\r\nstatic u8 mt352_adc_ctl_1_cfg [] = { 0x8E, 0x40 };\r\nstatic u8 mt352_agc_cfg [] = { 0x67, 0x28, 0x20 };\r\nstatic u8 mt352_gpp_ctl_cfg [] = { 0x8C, 0x33 };\r\nstatic u8 mt352_capt_range_cfg[] = { 0x75, 0x32 };\r\nmt352_write(fe, mt352_clock_config, sizeof(mt352_clock_config));\r\nudelay(2000);\r\nmt352_write(fe, mt352_reset, sizeof(mt352_reset));\r\nmt352_write(fe, mt352_adc_ctl_1_cfg, sizeof(mt352_adc_ctl_1_cfg));\r\nmt352_write(fe, mt352_agc_cfg, sizeof(mt352_agc_cfg));\r\nmt352_write(fe, mt352_gpp_ctl_cfg, sizeof(mt352_gpp_ctl_cfg));\r\nmt352_write(fe, mt352_capt_range_cfg, sizeof(mt352_capt_range_cfg));\r\nreturn 0;\r\n}\r\nstatic int thomson_dtt7579_tuner_calc_regs(struct dvb_frontend *fe, u8* pllbuf, int buf_len)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu32 div;\r\nunsigned char bs = 0;\r\nunsigned char cp = 0;\r\nif (buf_len < 5)\r\nreturn -EINVAL;\r\ndiv = (((c->frequency + 83333) * 3) / 500000) + IF_FREQUENCYx6;\r\nif (c->frequency < 542000000)\r\ncp = 0xb4;\r\nelse if (c->frequency < 771000000)\r\ncp = 0xbc;\r\nelse\r\ncp = 0xf4;\r\nif (c->frequency == 0)\r\nbs = 0x03;\r\nelse if (c->frequency < 443250000)\r\nbs = 0x02;\r\nelse\r\nbs = 0x08;\r\npllbuf[0] = 0x60;\r\npllbuf[1] = div >> 8;\r\npllbuf[2] = div & 0xff;\r\npllbuf[3] = cp;\r\npllbuf[4] = bs;\r\nreturn 5;\r\n}\r\nstatic int cx24108_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu32 freq = c->frequency;\r\nint i, a, n, pump;\r\nu32 band, pll;\r\nu32 osci[]={950000,1019000,1075000,1178000,1296000,1432000,\r\n1576000,1718000,1856000,2036000,2150000};\r\nu32 bandsel[]={0,0x00020000,0x00040000,0x00100800,0x00101000,\r\n0x00102000,0x00104000,0x00108000,0x00110000,\r\n0x00120000,0x00140000};\r\n#define XTAL 1011100\r\ndprintk("cx24108 debug: entering SetTunerFreq, freq=%d\n", freq);\r\nif (freq<950000)\r\nfreq = 950000;\r\nelse if (freq>2150000)\r\nfreq = 2150000;\r\nfor(i = 1; (i < ARRAY_SIZE(osci) - 1) && (osci[i] < freq); i++);\r\ndprintk("cx24108 debug: select vco #%d (f=%d)\n", i, freq);\r\nband=bandsel[i];\r\nn=((i<=2?2:1)*freq*10L)/(XTAL/100);\r\na=n%32; n/=32; if(a==0) n--;\r\npump=(freq<(osci[i-1]+osci[i])/2);\r\npll=0xf8000000|\r\n((pump?1:2)<<(14+11))|\r\n((n&0x1ff)<<(5+11))|\r\n((a&0x1f)<<11);\r\ndprintk("cx24108 debug: pump=%d, n=%d, a=%d\n", pump, n, a);\r\ncx24110_pll_write(fe,band);\r\ncx24110_pll_write(fe,0x500c0000);\r\ncx24110_pll_write(fe,0x83f1f800);\r\ncx24110_pll_write(fe,pll);\r\nreturn 0;\r\n}\r\nstatic int pinnsat_tuner_init(struct dvb_frontend* fe)\r\n{\r\nstruct dvb_bt8xx_card *card = fe->dvb->priv;\r\nbttv_gpio_enable(card->bttv_nr, 1, 1);\r\nbttv_write_gpio(card->bttv_nr, 1, 1);\r\nreturn 0;\r\n}\r\nstatic int pinnsat_tuner_sleep(struct dvb_frontend* fe)\r\n{\r\nstruct dvb_bt8xx_card *card = fe->dvb->priv;\r\nbttv_write_gpio(card->bttv_nr, 1, 0);\r\nreturn 0;\r\n}\r\nstatic int microtune_mt7202dtf_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct dvb_bt8xx_card *card = (struct dvb_bt8xx_card *) fe->dvb->priv;\r\nu8 cfg, cpump, band_select;\r\nu8 data[4];\r\nu32 div;\r\nstruct i2c_msg msg = { .addr = 0x60, .flags = 0, .buf = data, .len = sizeof(data) };\r\ndiv = (36000000 + c->frequency + 83333) / 166666;\r\ncfg = 0x88;\r\nif (c->frequency < 175000000)\r\ncpump = 2;\r\nelse if (c->frequency < 390000000)\r\ncpump = 1;\r\nelse if (c->frequency < 470000000)\r\ncpump = 2;\r\nelse if (c->frequency < 750000000)\r\ncpump = 2;\r\nelse\r\ncpump = 3;\r\nif (c->frequency < 175000000)\r\nband_select = 0x0e;\r\nelse if (c->frequency < 470000000)\r\nband_select = 0x05;\r\nelse\r\nband_select = 0x03;\r\ndata[0] = (div >> 8) & 0x7f;\r\ndata[1] = div & 0xff;\r\ndata[2] = ((div >> 10) & 0x60) | cfg;\r\ndata[3] = (cpump << 6) | band_select;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\ni2c_transfer(card->i2c_adapter, &msg, 1);\r\nreturn (div * 166666 - 36000000);\r\n}\r\nstatic int microtune_mt7202dtf_request_firmware(struct dvb_frontend* fe, const struct firmware **fw, char* name)\r\n{\r\nstruct dvb_bt8xx_card* bt = (struct dvb_bt8xx_card*) fe->dvb->priv;\r\nreturn request_firmware(fw, name, &bt->bt->dev->dev);\r\n}\r\nstatic int advbt771_samsung_tdtc9251dh0_demod_init(struct dvb_frontend* fe)\r\n{\r\nstatic u8 mt352_clock_config [] = { 0x89, 0x38, 0x2d };\r\nstatic u8 mt352_reset [] = { 0x50, 0x80 };\r\nstatic u8 mt352_adc_ctl_1_cfg [] = { 0x8E, 0x40 };\r\nstatic u8 mt352_agc_cfg [] = { 0x67, 0x10, 0x23, 0x00, 0xFF, 0xFF,\r\n0x00, 0xFF, 0x00, 0x40, 0x40 };\r\nstatic u8 mt352_av771_extra[] = { 0xB5, 0x7A };\r\nstatic u8 mt352_capt_range_cfg[] = { 0x75, 0x32 };\r\nmt352_write(fe, mt352_clock_config, sizeof(mt352_clock_config));\r\nudelay(2000);\r\nmt352_write(fe, mt352_reset, sizeof(mt352_reset));\r\nmt352_write(fe, mt352_adc_ctl_1_cfg, sizeof(mt352_adc_ctl_1_cfg));\r\nmt352_write(fe, mt352_agc_cfg,sizeof(mt352_agc_cfg));\r\nudelay(2000);\r\nmt352_write(fe, mt352_av771_extra,sizeof(mt352_av771_extra));\r\nmt352_write(fe, mt352_capt_range_cfg, sizeof(mt352_capt_range_cfg));\r\nreturn 0;\r\n}\r\nstatic int advbt771_samsung_tdtc9251dh0_tuner_calc_regs(struct dvb_frontend *fe, u8 *pllbuf, int buf_len)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu32 div;\r\nunsigned char bs = 0;\r\nunsigned char cp = 0;\r\nif (buf_len < 5) return -EINVAL;\r\ndiv = (((c->frequency + 83333) * 3) / 500000) + IF_FREQUENCYx6;\r\nif (c->frequency < 150000000)\r\ncp = 0xB4;\r\nelse if (c->frequency < 173000000)\r\ncp = 0xBC;\r\nelse if (c->frequency < 250000000)\r\ncp = 0xB4;\r\nelse if (c->frequency < 400000000)\r\ncp = 0xBC;\r\nelse if (c->frequency < 420000000)\r\ncp = 0xF4;\r\nelse if (c->frequency < 470000000)\r\ncp = 0xFC;\r\nelse if (c->frequency < 600000000)\r\ncp = 0xBC;\r\nelse if (c->frequency < 730000000)\r\ncp = 0xF4;\r\nelse\r\ncp = 0xFC;\r\nif (c->frequency < 150000000)\r\nbs = 0x01;\r\nelse if (c->frequency < 173000000)\r\nbs = 0x01;\r\nelse if (c->frequency < 250000000)\r\nbs = 0x02;\r\nelse if (c->frequency < 400000000)\r\nbs = 0x02;\r\nelse if (c->frequency < 420000000)\r\nbs = 0x02;\r\nelse if (c->frequency < 470000000)\r\nbs = 0x02;\r\nelse if (c->frequency < 600000000)\r\nbs = 0x08;\r\nelse if (c->frequency < 730000000)\r\nbs = 0x08;\r\nelse\r\nbs = 0x08;\r\npllbuf[0] = 0x61;\r\npllbuf[1] = div >> 8;\r\npllbuf[2] = div & 0xff;\r\npllbuf[3] = cp;\r\npllbuf[4] = bs;\r\nreturn 5;\r\n}\r\nstatic int or51211_request_firmware(struct dvb_frontend* fe, const struct firmware **fw, char* name)\r\n{\r\nstruct dvb_bt8xx_card* bt = (struct dvb_bt8xx_card*) fe->dvb->priv;\r\nreturn request_firmware(fw, name, &bt->bt->dev->dev);\r\n}\r\nstatic void or51211_setmode(struct dvb_frontend * fe, int mode)\r\n{\r\nstruct dvb_bt8xx_card *bt = fe->dvb->priv;\r\nbttv_write_gpio(bt->bttv_nr, 0x0002, mode);\r\nmsleep(20);\r\n}\r\nstatic void or51211_reset(struct dvb_frontend * fe)\r\n{\r\nstruct dvb_bt8xx_card *bt = fe->dvb->priv;\r\nint ret = bttv_gpio_enable(bt->bttv_nr, 0x001F, 0x001F);\r\nif (ret != 0)\r\nprintk(KERN_WARNING "or51211: Init Error - Can't Reset DVR (%i)\n", ret);\r\nbttv_write_gpio(bt->bttv_nr, 0x001F, 0x0000);\r\nmsleep(20);\r\nbttv_write_gpio(bt->bttv_nr, 0x0001F, 0x0001);\r\nmsleep(500);\r\n}\r\nstatic void or51211_sleep(struct dvb_frontend * fe)\r\n{\r\nstruct dvb_bt8xx_card *bt = fe->dvb->priv;\r\nbttv_write_gpio(bt->bttv_nr, 0x0001, 0x0000);\r\n}\r\nstatic int vp3021_alps_tded4_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct dvb_bt8xx_card *card = (struct dvb_bt8xx_card *) fe->dvb->priv;\r\nu8 buf[4];\r\nu32 div;\r\nstruct i2c_msg msg = { .addr = 0x60, .flags = 0, .buf = buf, .len = sizeof(buf) };\r\ndiv = (c->frequency + 36166667) / 166667;\r\nbuf[0] = (div >> 8) & 0x7F;\r\nbuf[1] = div & 0xFF;\r\nbuf[2] = 0x85;\r\nif ((c->frequency >= 47000000) && (c->frequency < 153000000))\r\nbuf[3] = 0x01;\r\nelse if ((c->frequency >= 153000000) && (c->frequency < 430000000))\r\nbuf[3] = 0x02;\r\nelse if ((c->frequency >= 430000000) && (c->frequency < 824000000))\r\nbuf[3] = 0x0C;\r\nelse if ((c->frequency >= 824000000) && (c->frequency < 863000000))\r\nbuf[3] = 0x8C;\r\nelse\r\nreturn -EINVAL;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\ni2c_transfer(card->i2c_adapter, &msg, 1);\r\nreturn 0;\r\n}\r\nstatic int digitv_alps_tded4_demod_init(struct dvb_frontend* fe)\r\n{\r\nstatic u8 mt352_clock_config [] = { 0x89, 0x38, 0x2d };\r\nstatic u8 mt352_reset [] = { 0x50, 0x80 };\r\nstatic u8 mt352_adc_ctl_1_cfg [] = { 0x8E, 0x40 };\r\nstatic u8 mt352_agc_cfg [] = { 0x67, 0x20, 0xa0 };\r\nstatic u8 mt352_capt_range_cfg[] = { 0x75, 0x32 };\r\nmt352_write(fe, mt352_clock_config, sizeof(mt352_clock_config));\r\nudelay(2000);\r\nmt352_write(fe, mt352_reset, sizeof(mt352_reset));\r\nmt352_write(fe, mt352_adc_ctl_1_cfg, sizeof(mt352_adc_ctl_1_cfg));\r\nmt352_write(fe, mt352_agc_cfg,sizeof(mt352_agc_cfg));\r\nmt352_write(fe, mt352_capt_range_cfg, sizeof(mt352_capt_range_cfg));\r\nreturn 0;\r\n}\r\nstatic int digitv_alps_tded4_tuner_calc_regs(struct dvb_frontend *fe, u8 *pllbuf, int buf_len)\r\n{\r\nu32 div;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nif (buf_len < 5)\r\nreturn -EINVAL;\r\ndiv = (((c->frequency + 83333) * 3) / 500000) + IF_FREQUENCYx6;\r\npllbuf[0] = 0x61;\r\npllbuf[1] = (div >> 8) & 0x7F;\r\npllbuf[2] = div & 0xFF;\r\npllbuf[3] = 0x85;\r\ndprintk("frequency %u, div %u\n", c->frequency, div);\r\nif (c->frequency < 470000000)\r\npllbuf[4] = 0x02;\r\nelse if (c->frequency > 823000000)\r\npllbuf[4] = 0x88;\r\nelse\r\npllbuf[4] = 0x08;\r\nif (c->bandwidth_hz == 8000000)\r\npllbuf[4] |= 0x04;\r\nreturn 5;\r\n}\r\nstatic void digitv_alps_tded4_reset(struct dvb_bt8xx_card *bt)\r\n{\r\nint ret = bttv_gpio_enable(bt->bttv_nr, 0x08, 0x08);\r\nif (ret != 0)\r\nprintk(KERN_WARNING "digitv_alps_tded4: Init Error - Can't Reset DVR (%i)\n", ret);\r\nbttv_write_gpio(bt->bttv_nr, 0x08, 0x08);\r\nbttv_write_gpio(bt->bttv_nr, 0x08, 0x00);\r\nmsleep(100);\r\nbttv_write_gpio(bt->bttv_nr, 0x08, 0x08);\r\n}\r\nstatic void lgdt330x_reset(struct dvb_bt8xx_card *bt)\r\n{\r\nbttv_write_gpio(bt->bttv_nr, 0x00e00007, 0x00000001);\r\nbttv_write_gpio(bt->bttv_nr, 0x00e00007, 0x00000000);\r\nmsleep(100);\r\nbttv_write_gpio(bt->bttv_nr, 0x00e00007, 0x00000001);\r\nmsleep(100);\r\n}\r\nstatic void frontend_init(struct dvb_bt8xx_card *card, u32 type)\r\n{\r\nstruct dst_state* state = NULL;\r\nswitch(type) {\r\ncase BTTV_BOARD_DVICO_DVBT_LITE:\r\ncard->fe = dvb_attach(mt352_attach, &thomson_dtt7579_config, card->i2c_adapter);\r\nif (card->fe == NULL)\r\ncard->fe = dvb_attach(zl10353_attach, &thomson_dtt7579_zl10353_config,\r\ncard->i2c_adapter);\r\nif (card->fe != NULL) {\r\ncard->fe->ops.tuner_ops.calc_regs = thomson_dtt7579_tuner_calc_regs;\r\ncard->fe->ops.info.frequency_min = 174000000;\r\ncard->fe->ops.info.frequency_max = 862000000;\r\n}\r\nbreak;\r\ncase BTTV_BOARD_DVICO_FUSIONHDTV_5_LITE:\r\nlgdt330x_reset(card);\r\ncard->fe = dvb_attach(lgdt330x_attach, &tdvs_tua6034_config, card->i2c_adapter);\r\nif (card->fe != NULL) {\r\ndvb_attach(simple_tuner_attach, card->fe,\r\ncard->i2c_adapter, 0x61,\r\nTUNER_LG_TDVS_H06XF);\r\ndprintk ("dvb_bt8xx: lgdt330x detected\n");\r\n}\r\nbreak;\r\ncase BTTV_BOARD_NEBULA_DIGITV:\r\ndigitv_alps_tded4_reset(card);\r\ncard->fe = dvb_attach(nxt6000_attach, &vp3021_alps_tded4_config, card->i2c_adapter);\r\nif (card->fe != NULL) {\r\ncard->fe->ops.tuner_ops.set_params = vp3021_alps_tded4_tuner_set_params;\r\ndprintk ("dvb_bt8xx: an nxt6000 was detected on your digitv card\n");\r\nbreak;\r\n}\r\ndigitv_alps_tded4_reset(card);\r\ncard->fe = dvb_attach(mt352_attach, &digitv_alps_tded4_config, card->i2c_adapter);\r\nif (card->fe != NULL) {\r\ncard->fe->ops.tuner_ops.calc_regs = digitv_alps_tded4_tuner_calc_regs;\r\ndprintk ("dvb_bt8xx: an mt352 was detected on your digitv card\n");\r\n}\r\nbreak;\r\ncase BTTV_BOARD_AVDVBT_761:\r\ncard->fe = dvb_attach(sp887x_attach, &microtune_mt7202dtf_config, card->i2c_adapter);\r\nif (card->fe) {\r\ncard->fe->ops.tuner_ops.set_params = microtune_mt7202dtf_tuner_set_params;\r\n}\r\nbreak;\r\ncase BTTV_BOARD_AVDVBT_771:\r\ncard->fe = dvb_attach(mt352_attach, &advbt771_samsung_tdtc9251dh0_config, card->i2c_adapter);\r\nif (card->fe != NULL) {\r\ncard->fe->ops.tuner_ops.calc_regs = advbt771_samsung_tdtc9251dh0_tuner_calc_regs;\r\ncard->fe->ops.info.frequency_min = 174000000;\r\ncard->fe->ops.info.frequency_max = 862000000;\r\n}\r\nbreak;\r\ncase BTTV_BOARD_TWINHAN_DST:\r\nstate = kmalloc(sizeof (struct dst_state), GFP_KERNEL);\r\nif (!state) {\r\npr_err("No memory\n");\r\nbreak;\r\n}\r\nstate->config = &dst_config;\r\nstate->i2c = card->i2c_adapter;\r\nstate->bt = card->bt;\r\nstate->dst_ca = NULL;\r\nif (dvb_attach(dst_attach, state, &card->dvb_adapter) == NULL) {\r\npr_err("%s: Could not find a Twinhan DST\n", __func__);\r\nbreak;\r\n}\r\ncard->fe = &state->frontend;\r\nif (state->dst_hw_cap & DST_TYPE_HAS_CA)\r\ndvb_attach(dst_ca_attach, state, &card->dvb_adapter);\r\nbreak;\r\ncase BTTV_BOARD_PINNACLESAT:\r\ncard->fe = dvb_attach(cx24110_attach, &pctvsat_config, card->i2c_adapter);\r\nif (card->fe) {\r\ncard->fe->ops.tuner_ops.init = pinnsat_tuner_init;\r\ncard->fe->ops.tuner_ops.sleep = pinnsat_tuner_sleep;\r\ncard->fe->ops.tuner_ops.set_params = cx24108_tuner_set_params;\r\n}\r\nbreak;\r\ncase BTTV_BOARD_PC_HDTV:\r\ncard->fe = dvb_attach(or51211_attach, &or51211_config, card->i2c_adapter);\r\nif (card->fe != NULL)\r\ndvb_attach(simple_tuner_attach, card->fe,\r\ncard->i2c_adapter, 0x61,\r\nTUNER_PHILIPS_FCV1236D);\r\nbreak;\r\n}\r\nif (card->fe == NULL)\r\npr_err("A frontend driver was not found for device [%04x:%04x] subsystem [%04x:%04x]\n",\r\ncard->bt->dev->vendor,\r\ncard->bt->dev->device,\r\ncard->bt->dev->subsystem_vendor,\r\ncard->bt->dev->subsystem_device);\r\nelse\r\nif (dvb_register_frontend(&card->dvb_adapter, card->fe)) {\r\npr_err("Frontend registration failed!\n");\r\ndvb_frontend_detach(card->fe);\r\ncard->fe = NULL;\r\n}\r\n}\r\nstatic int dvb_bt8xx_load_card(struct dvb_bt8xx_card *card, u32 type)\r\n{\r\nint result;\r\nresult = dvb_register_adapter(&card->dvb_adapter, card->card_name,\r\nTHIS_MODULE, &card->bt->dev->dev,\r\nadapter_nr);\r\nif (result < 0) {\r\npr_err("dvb_register_adapter failed (errno = %d)\n", result);\r\nreturn result;\r\n}\r\ncard->dvb_adapter.priv = card;\r\ncard->bt->adapter = card->i2c_adapter;\r\nmemset(&card->demux, 0, sizeof(struct dvb_demux));\r\ncard->demux.dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING | DMX_MEMORY_BASED_FILTERING;\r\ncard->demux.priv = card;\r\ncard->demux.filternum = 256;\r\ncard->demux.feednum = 256;\r\ncard->demux.start_feed = dvb_bt8xx_start_feed;\r\ncard->demux.stop_feed = dvb_bt8xx_stop_feed;\r\ncard->demux.write_to_decoder = NULL;\r\nresult = dvb_dmx_init(&card->demux);\r\nif (result < 0) {\r\npr_err("dvb_dmx_init failed (errno = %d)\n", result);\r\ngoto err_unregister_adaptor;\r\n}\r\ncard->dmxdev.filternum = 256;\r\ncard->dmxdev.demux = &card->demux.dmx;\r\ncard->dmxdev.capabilities = 0;\r\nresult = dvb_dmxdev_init(&card->dmxdev, &card->dvb_adapter);\r\nif (result < 0) {\r\npr_err("dvb_dmxdev_init failed (errno = %d)\n", result);\r\ngoto err_dmx_release;\r\n}\r\ncard->fe_hw.source = DMX_FRONTEND_0;\r\nresult = card->demux.dmx.add_frontend(&card->demux.dmx, &card->fe_hw);\r\nif (result < 0) {\r\npr_err("dvb_dmx_init failed (errno = %d)\n", result);\r\ngoto err_dmxdev_release;\r\n}\r\ncard->fe_mem.source = DMX_MEMORY_FE;\r\nresult = card->demux.dmx.add_frontend(&card->demux.dmx, &card->fe_mem);\r\nif (result < 0) {\r\npr_err("dvb_dmx_init failed (errno = %d)\n", result);\r\ngoto err_remove_hw_frontend;\r\n}\r\nresult = card->demux.dmx.connect_frontend(&card->demux.dmx, &card->fe_hw);\r\nif (result < 0) {\r\npr_err("dvb_dmx_init failed (errno = %d)\n", result);\r\ngoto err_remove_mem_frontend;\r\n}\r\nresult = dvb_net_init(&card->dvb_adapter, &card->dvbnet, &card->demux.dmx);\r\nif (result < 0) {\r\npr_err("dvb_net_init failed (errno = %d)\n", result);\r\ngoto err_disconnect_frontend;\r\n}\r\ntasklet_init(&card->bt->tasklet, dvb_bt8xx_task, (unsigned long) card);\r\nfrontend_init(card, type);\r\nreturn 0;\r\nerr_disconnect_frontend:\r\ncard->demux.dmx.disconnect_frontend(&card->demux.dmx);\r\nerr_remove_mem_frontend:\r\ncard->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_mem);\r\nerr_remove_hw_frontend:\r\ncard->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_hw);\r\nerr_dmxdev_release:\r\ndvb_dmxdev_release(&card->dmxdev);\r\nerr_dmx_release:\r\ndvb_dmx_release(&card->demux);\r\nerr_unregister_adaptor:\r\ndvb_unregister_adapter(&card->dvb_adapter);\r\nreturn result;\r\n}\r\nstatic int dvb_bt8xx_probe(struct bttv_sub_device *sub)\r\n{\r\nstruct dvb_bt8xx_card *card;\r\nstruct pci_dev* bttv_pci_dev;\r\nint ret;\r\nif (!(card = kzalloc(sizeof(struct dvb_bt8xx_card), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nmutex_init(&card->lock);\r\ncard->bttv_nr = sub->core->nr;\r\nstrlcpy(card->card_name, sub->core->v4l2_dev.name, sizeof(card->card_name));\r\ncard->i2c_adapter = &sub->core->i2c_adap;\r\nswitch(sub->core->type) {\r\ncase BTTV_BOARD_PINNACLESAT:\r\ncard->gpio_mode = 0x0400c060;\r\ncard->op_sync_orin = BT878_RISC_SYNC_MASK;\r\ncard->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;\r\nbreak;\r\ncase BTTV_BOARD_DVICO_DVBT_LITE:\r\ncard->gpio_mode = 0x0400C060;\r\ncard->op_sync_orin = BT878_RISC_SYNC_MASK;\r\ncard->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;\r\nbreak;\r\ncase BTTV_BOARD_DVICO_FUSIONHDTV_5_LITE:\r\ncard->gpio_mode = 0x0400c060;\r\ncard->op_sync_orin = BT878_RISC_SYNC_MASK;\r\ncard->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;\r\nbreak;\r\ncase BTTV_BOARD_NEBULA_DIGITV:\r\ncase BTTV_BOARD_AVDVBT_761:\r\ncard->gpio_mode = (1 << 26) | (1 << 14) | (1 << 5);\r\ncard->op_sync_orin = BT878_RISC_SYNC_MASK;\r\ncard->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;\r\nbreak;\r\ncase BTTV_BOARD_AVDVBT_771:\r\ncard->gpio_mode = 0x0400402B;\r\ncard->op_sync_orin = BT878_RISC_SYNC_MASK;\r\ncard->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;\r\nbreak;\r\ncase BTTV_BOARD_TWINHAN_DST:\r\ncard->gpio_mode = 0x2204f2c;\r\ncard->op_sync_orin = BT878_RISC_SYNC_MASK;\r\ncard->irq_err_ignore = BT878_APABORT | BT878_ARIPERR |\r\nBT878_APPERR | BT878_AFBUS;\r\nbreak;\r\ncase BTTV_BOARD_PC_HDTV:\r\ncard->gpio_mode = 0x0100EC7B;\r\ncard->op_sync_orin = BT878_RISC_SYNC_MASK;\r\ncard->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;\r\nbreak;\r\ndefault:\r\npr_err("Unknown bttv card type: %d\n", sub->core->type);\r\nkfree(card);\r\nreturn -ENODEV;\r\n}\r\ndprintk("dvb_bt8xx: identified card%d as %s\n", card->bttv_nr, card->card_name);\r\nif (!(bttv_pci_dev = bttv_get_pcidev(card->bttv_nr))) {\r\npr_err("no pci device for card %d\n", card->bttv_nr);\r\nkfree(card);\r\nreturn -ENODEV;\r\n}\r\nif (!(card->bt = dvb_bt8xx_878_match(card->bttv_nr, bttv_pci_dev))) {\r\npr_err("unable to determine DMA core of card %d,\n", card->bttv_nr);\r\npr_err("if you have the ALSA bt87x audio driver installed, try removing it.\n");\r\nkfree(card);\r\nreturn -ENODEV;\r\n}\r\nmutex_init(&card->bt->gpio_lock);\r\ncard->bt->bttv_nr = sub->core->nr;\r\nif ( (ret = dvb_bt8xx_load_card(card, sub->core->type)) ) {\r\nkfree(card);\r\nreturn ret;\r\n}\r\ndev_set_drvdata(&sub->dev, card);\r\nreturn 0;\r\n}\r\nstatic void dvb_bt8xx_remove(struct bttv_sub_device *sub)\r\n{\r\nstruct dvb_bt8xx_card *card = dev_get_drvdata(&sub->dev);\r\ndprintk("dvb_bt8xx: unloading card%d\n", card->bttv_nr);\r\nbt878_stop(card->bt);\r\ntasklet_kill(&card->bt->tasklet);\r\ndvb_net_release(&card->dvbnet);\r\ncard->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_mem);\r\ncard->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_hw);\r\ndvb_dmxdev_release(&card->dmxdev);\r\ndvb_dmx_release(&card->demux);\r\nif (card->fe) {\r\ndvb_unregister_frontend(card->fe);\r\ndvb_frontend_detach(card->fe);\r\n}\r\ndvb_unregister_adapter(&card->dvb_adapter);\r\nkfree(card);\r\n}\r\nstatic int __init dvb_bt8xx_init(void)\r\n{\r\nreturn bttv_sub_register(&driver, "dvb");\r\n}\r\nstatic void __exit dvb_bt8xx_exit(void)\r\n{\r\nbttv_sub_unregister(&driver);\r\n}
