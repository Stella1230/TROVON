static bool wm2200_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(wm2200_ranges); i++)\r\nif ((reg >= wm2200_ranges[i].window_start &&\r\nreg <= wm2200_ranges[i].window_start +\r\nwm2200_ranges[i].window_len) ||\r\n(reg >= wm2200_ranges[i].range_min &&\r\nreg <= wm2200_ranges[i].range_max))\r\nreturn true;\r\nswitch (reg) {\r\ncase WM2200_SOFTWARE_RESET:\r\ncase WM2200_DEVICE_REVISION:\r\ncase WM2200_ADPS1_IRQ0:\r\ncase WM2200_ADPS1_IRQ1:\r\ncase WM2200_INTERRUPT_STATUS_1:\r\ncase WM2200_INTERRUPT_STATUS_2:\r\ncase WM2200_INTERRUPT_RAW_STATUS_2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool wm2200_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(wm2200_ranges); i++)\r\nif ((reg >= wm2200_ranges[i].window_start &&\r\nreg <= wm2200_ranges[i].window_start +\r\nwm2200_ranges[i].window_len) ||\r\n(reg >= wm2200_ranges[i].range_min &&\r\nreg <= wm2200_ranges[i].range_max))\r\nreturn true;\r\nswitch (reg) {\r\ncase WM2200_SOFTWARE_RESET:\r\ncase WM2200_DEVICE_REVISION:\r\ncase WM2200_TONE_GENERATOR_1:\r\ncase WM2200_CLOCKING_3:\r\ncase WM2200_CLOCKING_4:\r\ncase WM2200_FLL_CONTROL_1:\r\ncase WM2200_FLL_CONTROL_2:\r\ncase WM2200_FLL_CONTROL_3:\r\ncase WM2200_FLL_CONTROL_4:\r\ncase WM2200_FLL_CONTROL_6:\r\ncase WM2200_FLL_CONTROL_7:\r\ncase WM2200_FLL_EFS_1:\r\ncase WM2200_FLL_EFS_2:\r\ncase WM2200_MIC_CHARGE_PUMP_1:\r\ncase WM2200_MIC_CHARGE_PUMP_2:\r\ncase WM2200_DM_CHARGE_PUMP_1:\r\ncase WM2200_MIC_BIAS_CTRL_1:\r\ncase WM2200_MIC_BIAS_CTRL_2:\r\ncase WM2200_EAR_PIECE_CTRL_1:\r\ncase WM2200_EAR_PIECE_CTRL_2:\r\ncase WM2200_INPUT_ENABLES:\r\ncase WM2200_IN1L_CONTROL:\r\ncase WM2200_IN1R_CONTROL:\r\ncase WM2200_IN2L_CONTROL:\r\ncase WM2200_IN2R_CONTROL:\r\ncase WM2200_IN3L_CONTROL:\r\ncase WM2200_IN3R_CONTROL:\r\ncase WM2200_RXANC_SRC:\r\ncase WM2200_INPUT_VOLUME_RAMP:\r\ncase WM2200_ADC_DIGITAL_VOLUME_1L:\r\ncase WM2200_ADC_DIGITAL_VOLUME_1R:\r\ncase WM2200_ADC_DIGITAL_VOLUME_2L:\r\ncase WM2200_ADC_DIGITAL_VOLUME_2R:\r\ncase WM2200_ADC_DIGITAL_VOLUME_3L:\r\ncase WM2200_ADC_DIGITAL_VOLUME_3R:\r\ncase WM2200_OUTPUT_ENABLES:\r\ncase WM2200_DAC_VOLUME_LIMIT_1L:\r\ncase WM2200_DAC_VOLUME_LIMIT_1R:\r\ncase WM2200_DAC_VOLUME_LIMIT_2L:\r\ncase WM2200_DAC_VOLUME_LIMIT_2R:\r\ncase WM2200_DAC_AEC_CONTROL_1:\r\ncase WM2200_OUTPUT_VOLUME_RAMP:\r\ncase WM2200_DAC_DIGITAL_VOLUME_1L:\r\ncase WM2200_DAC_DIGITAL_VOLUME_1R:\r\ncase WM2200_DAC_DIGITAL_VOLUME_2L:\r\ncase WM2200_DAC_DIGITAL_VOLUME_2R:\r\ncase WM2200_PDM_1:\r\ncase WM2200_PDM_2:\r\ncase WM2200_AUDIO_IF_1_1:\r\ncase WM2200_AUDIO_IF_1_2:\r\ncase WM2200_AUDIO_IF_1_3:\r\ncase WM2200_AUDIO_IF_1_4:\r\ncase WM2200_AUDIO_IF_1_5:\r\ncase WM2200_AUDIO_IF_1_6:\r\ncase WM2200_AUDIO_IF_1_7:\r\ncase WM2200_AUDIO_IF_1_8:\r\ncase WM2200_AUDIO_IF_1_9:\r\ncase WM2200_AUDIO_IF_1_10:\r\ncase WM2200_AUDIO_IF_1_11:\r\ncase WM2200_AUDIO_IF_1_12:\r\ncase WM2200_AUDIO_IF_1_13:\r\ncase WM2200_AUDIO_IF_1_14:\r\ncase WM2200_AUDIO_IF_1_15:\r\ncase WM2200_AUDIO_IF_1_16:\r\ncase WM2200_AUDIO_IF_1_17:\r\ncase WM2200_AUDIO_IF_1_18:\r\ncase WM2200_AUDIO_IF_1_19:\r\ncase WM2200_AUDIO_IF_1_20:\r\ncase WM2200_AUDIO_IF_1_21:\r\ncase WM2200_AUDIO_IF_1_22:\r\ncase WM2200_OUT1LMIX_INPUT_1_SOURCE:\r\ncase WM2200_OUT1LMIX_INPUT_1_VOLUME:\r\ncase WM2200_OUT1LMIX_INPUT_2_SOURCE:\r\ncase WM2200_OUT1LMIX_INPUT_2_VOLUME:\r\ncase WM2200_OUT1LMIX_INPUT_3_SOURCE:\r\ncase WM2200_OUT1LMIX_INPUT_3_VOLUME:\r\ncase WM2200_OUT1LMIX_INPUT_4_SOURCE:\r\ncase WM2200_OUT1LMIX_INPUT_4_VOLUME:\r\ncase WM2200_OUT1RMIX_INPUT_1_SOURCE:\r\ncase WM2200_OUT1RMIX_INPUT_1_VOLUME:\r\ncase WM2200_OUT1RMIX_INPUT_2_SOURCE:\r\ncase WM2200_OUT1RMIX_INPUT_2_VOLUME:\r\ncase WM2200_OUT1RMIX_INPUT_3_SOURCE:\r\ncase WM2200_OUT1RMIX_INPUT_3_VOLUME:\r\ncase WM2200_OUT1RMIX_INPUT_4_SOURCE:\r\ncase WM2200_OUT1RMIX_INPUT_4_VOLUME:\r\ncase WM2200_OUT2LMIX_INPUT_1_SOURCE:\r\ncase WM2200_OUT2LMIX_INPUT_1_VOLUME:\r\ncase WM2200_OUT2LMIX_INPUT_2_SOURCE:\r\ncase WM2200_OUT2LMIX_INPUT_2_VOLUME:\r\ncase WM2200_OUT2LMIX_INPUT_3_SOURCE:\r\ncase WM2200_OUT2LMIX_INPUT_3_VOLUME:\r\ncase WM2200_OUT2LMIX_INPUT_4_SOURCE:\r\ncase WM2200_OUT2LMIX_INPUT_4_VOLUME:\r\ncase WM2200_OUT2RMIX_INPUT_1_SOURCE:\r\ncase WM2200_OUT2RMIX_INPUT_1_VOLUME:\r\ncase WM2200_OUT2RMIX_INPUT_2_SOURCE:\r\ncase WM2200_OUT2RMIX_INPUT_2_VOLUME:\r\ncase WM2200_OUT2RMIX_INPUT_3_SOURCE:\r\ncase WM2200_OUT2RMIX_INPUT_3_VOLUME:\r\ncase WM2200_OUT2RMIX_INPUT_4_SOURCE:\r\ncase WM2200_OUT2RMIX_INPUT_4_VOLUME:\r\ncase WM2200_AIF1TX1MIX_INPUT_1_SOURCE:\r\ncase WM2200_AIF1TX1MIX_INPUT_1_VOLUME:\r\ncase WM2200_AIF1TX1MIX_INPUT_2_SOURCE:\r\ncase WM2200_AIF1TX1MIX_INPUT_2_VOLUME:\r\ncase WM2200_AIF1TX1MIX_INPUT_3_SOURCE:\r\ncase WM2200_AIF1TX1MIX_INPUT_3_VOLUME:\r\ncase WM2200_AIF1TX1MIX_INPUT_4_SOURCE:\r\ncase WM2200_AIF1TX1MIX_INPUT_4_VOLUME:\r\ncase WM2200_AIF1TX2MIX_INPUT_1_SOURCE:\r\ncase WM2200_AIF1TX2MIX_INPUT_1_VOLUME:\r\ncase WM2200_AIF1TX2MIX_INPUT_2_SOURCE:\r\ncase WM2200_AIF1TX2MIX_INPUT_2_VOLUME:\r\ncase WM2200_AIF1TX2MIX_INPUT_3_SOURCE:\r\ncase WM2200_AIF1TX2MIX_INPUT_3_VOLUME:\r\ncase WM2200_AIF1TX2MIX_INPUT_4_SOURCE:\r\ncase WM2200_AIF1TX2MIX_INPUT_4_VOLUME:\r\ncase WM2200_AIF1TX3MIX_INPUT_1_SOURCE:\r\ncase WM2200_AIF1TX3MIX_INPUT_1_VOLUME:\r\ncase WM2200_AIF1TX3MIX_INPUT_2_SOURCE:\r\ncase WM2200_AIF1TX3MIX_INPUT_2_VOLUME:\r\ncase WM2200_AIF1TX3MIX_INPUT_3_SOURCE:\r\ncase WM2200_AIF1TX3MIX_INPUT_3_VOLUME:\r\ncase WM2200_AIF1TX3MIX_INPUT_4_SOURCE:\r\ncase WM2200_AIF1TX3MIX_INPUT_4_VOLUME:\r\ncase WM2200_AIF1TX4MIX_INPUT_1_SOURCE:\r\ncase WM2200_AIF1TX4MIX_INPUT_1_VOLUME:\r\ncase WM2200_AIF1TX4MIX_INPUT_2_SOURCE:\r\ncase WM2200_AIF1TX4MIX_INPUT_2_VOLUME:\r\ncase WM2200_AIF1TX4MIX_INPUT_3_SOURCE:\r\ncase WM2200_AIF1TX4MIX_INPUT_3_VOLUME:\r\ncase WM2200_AIF1TX4MIX_INPUT_4_SOURCE:\r\ncase WM2200_AIF1TX4MIX_INPUT_4_VOLUME:\r\ncase WM2200_AIF1TX5MIX_INPUT_1_SOURCE:\r\ncase WM2200_AIF1TX5MIX_INPUT_1_VOLUME:\r\ncase WM2200_AIF1TX5MIX_INPUT_2_SOURCE:\r\ncase WM2200_AIF1TX5MIX_INPUT_2_VOLUME:\r\ncase WM2200_AIF1TX5MIX_INPUT_3_SOURCE:\r\ncase WM2200_AIF1TX5MIX_INPUT_3_VOLUME:\r\ncase WM2200_AIF1TX5MIX_INPUT_4_SOURCE:\r\ncase WM2200_AIF1TX5MIX_INPUT_4_VOLUME:\r\ncase WM2200_AIF1TX6MIX_INPUT_1_SOURCE:\r\ncase WM2200_AIF1TX6MIX_INPUT_1_VOLUME:\r\ncase WM2200_AIF1TX6MIX_INPUT_2_SOURCE:\r\ncase WM2200_AIF1TX6MIX_INPUT_2_VOLUME:\r\ncase WM2200_AIF1TX6MIX_INPUT_3_SOURCE:\r\ncase WM2200_AIF1TX6MIX_INPUT_3_VOLUME:\r\ncase WM2200_AIF1TX6MIX_INPUT_4_SOURCE:\r\ncase WM2200_AIF1TX6MIX_INPUT_4_VOLUME:\r\ncase WM2200_EQLMIX_INPUT_1_SOURCE:\r\ncase WM2200_EQLMIX_INPUT_1_VOLUME:\r\ncase WM2200_EQLMIX_INPUT_2_SOURCE:\r\ncase WM2200_EQLMIX_INPUT_2_VOLUME:\r\ncase WM2200_EQLMIX_INPUT_3_SOURCE:\r\ncase WM2200_EQLMIX_INPUT_3_VOLUME:\r\ncase WM2200_EQLMIX_INPUT_4_SOURCE:\r\ncase WM2200_EQLMIX_INPUT_4_VOLUME:\r\ncase WM2200_EQRMIX_INPUT_1_SOURCE:\r\ncase WM2200_EQRMIX_INPUT_1_VOLUME:\r\ncase WM2200_EQRMIX_INPUT_2_SOURCE:\r\ncase WM2200_EQRMIX_INPUT_2_VOLUME:\r\ncase WM2200_EQRMIX_INPUT_3_SOURCE:\r\ncase WM2200_EQRMIX_INPUT_3_VOLUME:\r\ncase WM2200_EQRMIX_INPUT_4_SOURCE:\r\ncase WM2200_EQRMIX_INPUT_4_VOLUME:\r\ncase WM2200_LHPF1MIX_INPUT_1_SOURCE:\r\ncase WM2200_LHPF1MIX_INPUT_1_VOLUME:\r\ncase WM2200_LHPF1MIX_INPUT_2_SOURCE:\r\ncase WM2200_LHPF1MIX_INPUT_2_VOLUME:\r\ncase WM2200_LHPF1MIX_INPUT_3_SOURCE:\r\ncase WM2200_LHPF1MIX_INPUT_3_VOLUME:\r\ncase WM2200_LHPF1MIX_INPUT_4_SOURCE:\r\ncase WM2200_LHPF1MIX_INPUT_4_VOLUME:\r\ncase WM2200_LHPF2MIX_INPUT_1_SOURCE:\r\ncase WM2200_LHPF2MIX_INPUT_1_VOLUME:\r\ncase WM2200_LHPF2MIX_INPUT_2_SOURCE:\r\ncase WM2200_LHPF2MIX_INPUT_2_VOLUME:\r\ncase WM2200_LHPF2MIX_INPUT_3_SOURCE:\r\ncase WM2200_LHPF2MIX_INPUT_3_VOLUME:\r\ncase WM2200_LHPF2MIX_INPUT_4_SOURCE:\r\ncase WM2200_LHPF2MIX_INPUT_4_VOLUME:\r\ncase WM2200_DSP1LMIX_INPUT_1_SOURCE:\r\ncase WM2200_DSP1LMIX_INPUT_1_VOLUME:\r\ncase WM2200_DSP1LMIX_INPUT_2_SOURCE:\r\ncase WM2200_DSP1LMIX_INPUT_2_VOLUME:\r\ncase WM2200_DSP1LMIX_INPUT_3_SOURCE:\r\ncase WM2200_DSP1LMIX_INPUT_3_VOLUME:\r\ncase WM2200_DSP1LMIX_INPUT_4_SOURCE:\r\ncase WM2200_DSP1LMIX_INPUT_4_VOLUME:\r\ncase WM2200_DSP1RMIX_INPUT_1_SOURCE:\r\ncase WM2200_DSP1RMIX_INPUT_1_VOLUME:\r\ncase WM2200_DSP1RMIX_INPUT_2_SOURCE:\r\ncase WM2200_DSP1RMIX_INPUT_2_VOLUME:\r\ncase WM2200_DSP1RMIX_INPUT_3_SOURCE:\r\ncase WM2200_DSP1RMIX_INPUT_3_VOLUME:\r\ncase WM2200_DSP1RMIX_INPUT_4_SOURCE:\r\ncase WM2200_DSP1RMIX_INPUT_4_VOLUME:\r\ncase WM2200_DSP1AUX1MIX_INPUT_1_SOURCE:\r\ncase WM2200_DSP1AUX2MIX_INPUT_1_SOURCE:\r\ncase WM2200_DSP1AUX3MIX_INPUT_1_SOURCE:\r\ncase WM2200_DSP1AUX4MIX_INPUT_1_SOURCE:\r\ncase WM2200_DSP1AUX5MIX_INPUT_1_SOURCE:\r\ncase WM2200_DSP1AUX6MIX_INPUT_1_SOURCE:\r\ncase WM2200_DSP2LMIX_INPUT_1_SOURCE:\r\ncase WM2200_DSP2LMIX_INPUT_1_VOLUME:\r\ncase WM2200_DSP2LMIX_INPUT_2_SOURCE:\r\ncase WM2200_DSP2LMIX_INPUT_2_VOLUME:\r\ncase WM2200_DSP2LMIX_INPUT_3_SOURCE:\r\ncase WM2200_DSP2LMIX_INPUT_3_VOLUME:\r\ncase WM2200_DSP2LMIX_INPUT_4_SOURCE:\r\ncase WM2200_DSP2LMIX_INPUT_4_VOLUME:\r\ncase WM2200_DSP2RMIX_INPUT_1_SOURCE:\r\ncase WM2200_DSP2RMIX_INPUT_1_VOLUME:\r\ncase WM2200_DSP2RMIX_INPUT_2_SOURCE:\r\ncase WM2200_DSP2RMIX_INPUT_2_VOLUME:\r\ncase WM2200_DSP2RMIX_INPUT_3_SOURCE:\r\ncase WM2200_DSP2RMIX_INPUT_3_VOLUME:\r\ncase WM2200_DSP2RMIX_INPUT_4_SOURCE:\r\ncase WM2200_DSP2RMIX_INPUT_4_VOLUME:\r\ncase WM2200_DSP2AUX1MIX_INPUT_1_SOURCE:\r\ncase WM2200_DSP2AUX2MIX_INPUT_1_SOURCE:\r\ncase WM2200_DSP2AUX3MIX_INPUT_1_SOURCE:\r\ncase WM2200_DSP2AUX4MIX_INPUT_1_SOURCE:\r\ncase WM2200_DSP2AUX5MIX_INPUT_1_SOURCE:\r\ncase WM2200_DSP2AUX6MIX_INPUT_1_SOURCE:\r\ncase WM2200_GPIO_CTRL_1:\r\ncase WM2200_GPIO_CTRL_2:\r\ncase WM2200_GPIO_CTRL_3:\r\ncase WM2200_GPIO_CTRL_4:\r\ncase WM2200_ADPS1_IRQ0:\r\ncase WM2200_ADPS1_IRQ1:\r\ncase WM2200_MISC_PAD_CTRL_1:\r\ncase WM2200_INTERRUPT_STATUS_1:\r\ncase WM2200_INTERRUPT_STATUS_1_MASK:\r\ncase WM2200_INTERRUPT_STATUS_2:\r\ncase WM2200_INTERRUPT_RAW_STATUS_2:\r\ncase WM2200_INTERRUPT_STATUS_2_MASK:\r\ncase WM2200_INTERRUPT_CONTROL:\r\ncase WM2200_EQL_1:\r\ncase WM2200_EQL_2:\r\ncase WM2200_EQL_3:\r\ncase WM2200_EQL_4:\r\ncase WM2200_EQL_5:\r\ncase WM2200_EQL_6:\r\ncase WM2200_EQL_7:\r\ncase WM2200_EQL_8:\r\ncase WM2200_EQL_9:\r\ncase WM2200_EQL_10:\r\ncase WM2200_EQL_11:\r\ncase WM2200_EQL_12:\r\ncase WM2200_EQL_13:\r\ncase WM2200_EQL_14:\r\ncase WM2200_EQL_15:\r\ncase WM2200_EQL_16:\r\ncase WM2200_EQL_17:\r\ncase WM2200_EQL_18:\r\ncase WM2200_EQL_19:\r\ncase WM2200_EQL_20:\r\ncase WM2200_EQR_1:\r\ncase WM2200_EQR_2:\r\ncase WM2200_EQR_3:\r\ncase WM2200_EQR_4:\r\ncase WM2200_EQR_5:\r\ncase WM2200_EQR_6:\r\ncase WM2200_EQR_7:\r\ncase WM2200_EQR_8:\r\ncase WM2200_EQR_9:\r\ncase WM2200_EQR_10:\r\ncase WM2200_EQR_11:\r\ncase WM2200_EQR_12:\r\ncase WM2200_EQR_13:\r\ncase WM2200_EQR_14:\r\ncase WM2200_EQR_15:\r\ncase WM2200_EQR_16:\r\ncase WM2200_EQR_17:\r\ncase WM2200_EQR_18:\r\ncase WM2200_EQR_19:\r\ncase WM2200_EQR_20:\r\ncase WM2200_HPLPF1_1:\r\ncase WM2200_HPLPF1_2:\r\ncase WM2200_HPLPF2_1:\r\ncase WM2200_HPLPF2_2:\r\ncase WM2200_DSP1_CONTROL_1:\r\ncase WM2200_DSP1_CONTROL_2:\r\ncase WM2200_DSP1_CONTROL_3:\r\ncase WM2200_DSP1_CONTROL_4:\r\ncase WM2200_DSP1_CONTROL_5:\r\ncase WM2200_DSP1_CONTROL_6:\r\ncase WM2200_DSP1_CONTROL_7:\r\ncase WM2200_DSP1_CONTROL_8:\r\ncase WM2200_DSP1_CONTROL_9:\r\ncase WM2200_DSP1_CONTROL_10:\r\ncase WM2200_DSP1_CONTROL_11:\r\ncase WM2200_DSP1_CONTROL_12:\r\ncase WM2200_DSP1_CONTROL_13:\r\ncase WM2200_DSP1_CONTROL_14:\r\ncase WM2200_DSP1_CONTROL_15:\r\ncase WM2200_DSP1_CONTROL_16:\r\ncase WM2200_DSP1_CONTROL_17:\r\ncase WM2200_DSP1_CONTROL_18:\r\ncase WM2200_DSP1_CONTROL_19:\r\ncase WM2200_DSP1_CONTROL_20:\r\ncase WM2200_DSP1_CONTROL_21:\r\ncase WM2200_DSP1_CONTROL_22:\r\ncase WM2200_DSP1_CONTROL_23:\r\ncase WM2200_DSP1_CONTROL_24:\r\ncase WM2200_DSP1_CONTROL_25:\r\ncase WM2200_DSP1_CONTROL_26:\r\ncase WM2200_DSP1_CONTROL_27:\r\ncase WM2200_DSP1_CONTROL_28:\r\ncase WM2200_DSP1_CONTROL_29:\r\ncase WM2200_DSP1_CONTROL_30:\r\ncase WM2200_DSP1_CONTROL_31:\r\ncase WM2200_DSP2_CONTROL_1:\r\ncase WM2200_DSP2_CONTROL_2:\r\ncase WM2200_DSP2_CONTROL_3:\r\ncase WM2200_DSP2_CONTROL_4:\r\ncase WM2200_DSP2_CONTROL_5:\r\ncase WM2200_DSP2_CONTROL_6:\r\ncase WM2200_DSP2_CONTROL_7:\r\ncase WM2200_DSP2_CONTROL_8:\r\ncase WM2200_DSP2_CONTROL_9:\r\ncase WM2200_DSP2_CONTROL_10:\r\ncase WM2200_DSP2_CONTROL_11:\r\ncase WM2200_DSP2_CONTROL_12:\r\ncase WM2200_DSP2_CONTROL_13:\r\ncase WM2200_DSP2_CONTROL_14:\r\ncase WM2200_DSP2_CONTROL_15:\r\ncase WM2200_DSP2_CONTROL_16:\r\ncase WM2200_DSP2_CONTROL_17:\r\ncase WM2200_DSP2_CONTROL_18:\r\ncase WM2200_DSP2_CONTROL_19:\r\ncase WM2200_DSP2_CONTROL_20:\r\ncase WM2200_DSP2_CONTROL_21:\r\ncase WM2200_DSP2_CONTROL_22:\r\ncase WM2200_DSP2_CONTROL_23:\r\ncase WM2200_DSP2_CONTROL_24:\r\ncase WM2200_DSP2_CONTROL_25:\r\ncase WM2200_DSP2_CONTROL_26:\r\ncase WM2200_DSP2_CONTROL_27:\r\ncase WM2200_DSP2_CONTROL_28:\r\ncase WM2200_DSP2_CONTROL_29:\r\ncase WM2200_DSP2_CONTROL_30:\r\ncase WM2200_DSP2_CONTROL_31:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int wm2200_reset(struct wm2200_priv *wm2200)\r\n{\r\nif (wm2200->pdata.reset) {\r\ngpio_set_value_cansleep(wm2200->pdata.reset, 0);\r\ngpio_set_value_cansleep(wm2200->pdata.reset, 1);\r\nreturn 0;\r\n} else {\r\nreturn regmap_write(wm2200->regmap, WM2200_SOFTWARE_RESET,\r\n0x2200);\r\n}\r\n}\r\nstatic int wm2200_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm2200_priv *wm2200 = dev_get_drvdata(codec->dev);\r\nint ret;\r\nwm2200->codec = codec;\r\ncodec->control_data = wm2200->regmap;\r\ncodec->dapm.bias_level = SND_SOC_BIAS_OFF;\r\nret = snd_soc_codec_set_cache_io(codec, 16, 16, SND_SOC_REGMAP);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_add_codec_controls(codec, wm_adsp1_fw_controls, 2);\r\nif (ret != 0)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nstatic int wm2200_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nint lrclk, bclk, fmt_val;\r\nlrclk = 0;\r\nbclk = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nfmt_val = 0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nfmt_val = 2;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unsupported DAI format %d\n",\r\nfmt & SND_SOC_DAIFMT_FORMAT_MASK);\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nlrclk |= WM2200_AIF1TX_LRCLK_MSTR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nbclk |= WM2200_AIF1_BCLK_MSTR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nlrclk |= WM2200_AIF1TX_LRCLK_MSTR;\r\nbclk |= WM2200_AIF1_BCLK_MSTR;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unsupported master mode %d\n",\r\nfmt & SND_SOC_DAIFMT_MASTER_MASK);\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nbclk |= WM2200_AIF1_BCLK_INV;\r\nlrclk |= WM2200_AIF1TX_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nbclk |= WM2200_AIF1_BCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nlrclk |= WM2200_AIF1TX_LRCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM2200_AUDIO_IF_1_1, WM2200_AIF1_BCLK_MSTR |\r\nWM2200_AIF1_BCLK_INV, bclk);\r\nsnd_soc_update_bits(codec, WM2200_AUDIO_IF_1_2,\r\nWM2200_AIF1TX_LRCLK_MSTR | WM2200_AIF1TX_LRCLK_INV,\r\nlrclk);\r\nsnd_soc_update_bits(codec, WM2200_AUDIO_IF_1_3,\r\nWM2200_AIF1TX_LRCLK_MSTR | WM2200_AIF1TX_LRCLK_INV,\r\nlrclk);\r\nsnd_soc_update_bits(codec, WM2200_AUDIO_IF_1_5,\r\nWM2200_AIF1_FMT_MASK, fmt_val);\r\nreturn 0;\r\n}\r\nstatic int wm2200_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm2200_priv *wm2200 = snd_soc_codec_get_drvdata(codec);\r\nint i, bclk, lrclk, wl, fl, sr_code;\r\nint *bclk_rates;\r\nwl = snd_pcm_format_width(params_format(params));\r\nif (wl < 0)\r\nreturn wl;\r\nfl = snd_soc_params_to_frame_size(params);\r\nif (fl < 0)\r\nreturn fl;\r\ndev_dbg(codec->dev, "Word length %d bits, frame length %d bits\n",\r\nwl, fl);\r\nbclk = snd_soc_params_to_bclk(params);\r\nif (bclk < 0)\r\nreturn bclk;\r\nif (!wm2200->sysclk) {\r\ndev_err(codec->dev, "SYSCLK has no rate set\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(wm2200_sr_code); i++)\r\nif (wm2200_sr_code[i] == params_rate(params))\r\nbreak;\r\nif (i == ARRAY_SIZE(wm2200_sr_code)) {\r\ndev_err(codec->dev, "Unsupported sample rate: %dHz\n",\r\nparams_rate(params));\r\nreturn -EINVAL;\r\n}\r\nsr_code = i;\r\ndev_dbg(codec->dev, "Target BCLK is %dHz, using %dHz SYSCLK\n",\r\nbclk, wm2200->sysclk);\r\nif (wm2200->sysclk % 4000)\r\nbclk_rates = wm2200_bclk_rates_cd;\r\nelse\r\nbclk_rates = wm2200_bclk_rates_dat;\r\nfor (i = 0; i < WM2200_NUM_BCLK_RATES; i++)\r\nif (bclk_rates[i] >= bclk && (bclk_rates[i] % bclk == 0))\r\nbreak;\r\nif (i == WM2200_NUM_BCLK_RATES) {\r\ndev_err(codec->dev,\r\n"No valid BCLK for %dHz found from %dHz SYSCLK\n",\r\nbclk, wm2200->sysclk);\r\nreturn -EINVAL;\r\n}\r\nbclk = i;\r\ndev_dbg(codec->dev, "Setting %dHz BCLK\n", bclk_rates[bclk]);\r\nsnd_soc_update_bits(codec, WM2200_AUDIO_IF_1_1,\r\nWM2200_AIF1_BCLK_DIV_MASK, bclk);\r\nlrclk = bclk_rates[bclk] / params_rate(params);\r\ndev_dbg(codec->dev, "Setting %dHz LRCLK\n", bclk_rates[bclk] / lrclk);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ||\r\ndai->symmetric_rates)\r\nsnd_soc_update_bits(codec, WM2200_AUDIO_IF_1_7,\r\nWM2200_AIF1RX_BCPF_MASK, lrclk);\r\nelse\r\nsnd_soc_update_bits(codec, WM2200_AUDIO_IF_1_6,\r\nWM2200_AIF1TX_BCPF_MASK, lrclk);\r\ni = (wl << WM2200_AIF1TX_WL_SHIFT) | wl;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nsnd_soc_update_bits(codec, WM2200_AUDIO_IF_1_9,\r\nWM2200_AIF1RX_WL_MASK |\r\nWM2200_AIF1RX_SLOT_LEN_MASK, i);\r\nelse\r\nsnd_soc_update_bits(codec, WM2200_AUDIO_IF_1_8,\r\nWM2200_AIF1TX_WL_MASK |\r\nWM2200_AIF1TX_SLOT_LEN_MASK, i);\r\nsnd_soc_update_bits(codec, WM2200_CLOCKING_4,\r\nWM2200_SAMPLE_RATE_1_MASK, sr_code);\r\nreturn 0;\r\n}\r\nstatic int wm2200_set_sysclk(struct snd_soc_codec *codec, int clk_id,\r\nint source, unsigned int freq, int dir)\r\n{\r\nstruct wm2200_priv *wm2200 = snd_soc_codec_get_drvdata(codec);\r\nint fval;\r\nswitch (clk_id) {\r\ncase WM2200_CLK_SYSCLK:\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unknown clock %d\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\nswitch (source) {\r\ncase WM2200_CLKSRC_MCLK1:\r\ncase WM2200_CLKSRC_MCLK2:\r\ncase WM2200_CLKSRC_FLL:\r\ncase WM2200_CLKSRC_BCLK1:\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid source %d\n", source);\r\nreturn -EINVAL;\r\n}\r\nswitch (freq) {\r\ncase 22579200:\r\ncase 24576000:\r\nfval = 2;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid clock rate: %d\n", freq);\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM2200_CLOCKING_3, WM2200_SYSCLK_FREQ_MASK |\r\nWM2200_SYSCLK_SRC_MASK,\r\nfval << WM2200_SYSCLK_FREQ_SHIFT | source);\r\nwm2200->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int fll_factors(struct _fll_div *fll_div, unsigned int Fref,\r\nunsigned int Fout)\r\n{\r\nunsigned int target;\r\nunsigned int div;\r\nunsigned int fratio, gcd_fll;\r\nint i;\r\ndiv = 1;\r\nfll_div->fll_refclk_div = 0;\r\nwhile ((Fref / div) > 13500000) {\r\ndiv *= 2;\r\nfll_div->fll_refclk_div++;\r\nif (div > 8) {\r\npr_err("Can't scale %dMHz input down to <=13.5MHz\n",\r\nFref);\r\nreturn -EINVAL;\r\n}\r\n}\r\npr_debug("FLL Fref=%u Fout=%u\n", Fref, Fout);\r\nFref /= div;\r\ndiv = 2;\r\nwhile (Fout * div < 90000000) {\r\ndiv++;\r\nif (div > 64) {\r\npr_err("Unable to find FLL_OUTDIV for Fout=%uHz\n",\r\nFout);\r\nreturn -EINVAL;\r\n}\r\n}\r\ntarget = Fout * div;\r\nfll_div->fll_outdiv = div - 1;\r\npr_debug("FLL Fvco=%dHz\n", target);\r\nfor (i = 0; i < ARRAY_SIZE(fll_fratios); i++) {\r\nif (fll_fratios[i].min <= Fref && Fref <= fll_fratios[i].max) {\r\nfll_div->fll_fratio = fll_fratios[i].fll_fratio;\r\nfratio = fll_fratios[i].ratio;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(fll_fratios)) {\r\npr_err("Unable to find FLL_FRATIO for Fref=%uHz\n", Fref);\r\nreturn -EINVAL;\r\n}\r\nfll_div->n = target / (fratio * Fref);\r\nif (target % Fref == 0) {\r\nfll_div->theta = 0;\r\nfll_div->lambda = 0;\r\n} else {\r\ngcd_fll = gcd(target, fratio * Fref);\r\nfll_div->theta = (target - (fll_div->n * fratio * Fref))\r\n/ gcd_fll;\r\nfll_div->lambda = (fratio * Fref) / gcd_fll;\r\n}\r\npr_debug("FLL N=%x THETA=%x LAMBDA=%x\n",\r\nfll_div->n, fll_div->theta, fll_div->lambda);\r\npr_debug("FLL_FRATIO=%x(%d) FLL_OUTDIV=%x FLL_REFCLK_DIV=%x\n",\r\nfll_div->fll_fratio, fratio, fll_div->fll_outdiv,\r\nfll_div->fll_refclk_div);\r\nreturn 0;\r\n}\r\nstatic int wm2200_set_fll(struct snd_soc_codec *codec, int fll_id, int source,\r\nunsigned int Fref, unsigned int Fout)\r\n{\r\nstruct i2c_client *i2c = to_i2c_client(codec->dev);\r\nstruct wm2200_priv *wm2200 = snd_soc_codec_get_drvdata(codec);\r\nstruct _fll_div factors;\r\nint ret, i, timeout;\r\nif (!Fout) {\r\ndev_dbg(codec->dev, "FLL disabled");\r\nif (wm2200->fll_fout)\r\npm_runtime_put(codec->dev);\r\nwm2200->fll_fout = 0;\r\nsnd_soc_update_bits(codec, WM2200_FLL_CONTROL_1,\r\nWM2200_FLL_ENA, 0);\r\nreturn 0;\r\n}\r\nswitch (source) {\r\ncase WM2200_FLL_SRC_MCLK1:\r\ncase WM2200_FLL_SRC_MCLK2:\r\ncase WM2200_FLL_SRC_BCLK:\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid FLL source %d\n", source);\r\nreturn -EINVAL;\r\n}\r\nret = fll_factors(&factors, Fref, Fout);\r\nif (ret < 0)\r\nreturn ret;\r\nsnd_soc_update_bits(codec, WM2200_FLL_CONTROL_1, WM2200_FLL_ENA, 0);\r\nsnd_soc_update_bits(codec, WM2200_FLL_CONTROL_2,\r\nWM2200_FLL_OUTDIV_MASK | WM2200_FLL_FRATIO_MASK,\r\n(factors.fll_outdiv << WM2200_FLL_OUTDIV_SHIFT) |\r\nfactors.fll_fratio);\r\nif (factors.theta) {\r\nsnd_soc_update_bits(codec, WM2200_FLL_CONTROL_3,\r\nWM2200_FLL_FRACN_ENA,\r\nWM2200_FLL_FRACN_ENA);\r\nsnd_soc_update_bits(codec, WM2200_FLL_EFS_2,\r\nWM2200_FLL_EFS_ENA,\r\nWM2200_FLL_EFS_ENA);\r\n} else {\r\nsnd_soc_update_bits(codec, WM2200_FLL_CONTROL_3,\r\nWM2200_FLL_FRACN_ENA, 0);\r\nsnd_soc_update_bits(codec, WM2200_FLL_EFS_2,\r\nWM2200_FLL_EFS_ENA, 0);\r\n}\r\nsnd_soc_update_bits(codec, WM2200_FLL_CONTROL_4, WM2200_FLL_THETA_MASK,\r\nfactors.theta);\r\nsnd_soc_update_bits(codec, WM2200_FLL_CONTROL_6, WM2200_FLL_N_MASK,\r\nfactors.n);\r\nsnd_soc_update_bits(codec, WM2200_FLL_CONTROL_7,\r\nWM2200_FLL_CLK_REF_DIV_MASK |\r\nWM2200_FLL_CLK_REF_SRC_MASK,\r\n(factors.fll_refclk_div\r\n<< WM2200_FLL_CLK_REF_DIV_SHIFT) | source);\r\nsnd_soc_update_bits(codec, WM2200_FLL_EFS_1,\r\nWM2200_FLL_LAMBDA_MASK, factors.lambda);\r\ntry_wait_for_completion(&wm2200->fll_lock);\r\npm_runtime_get_sync(codec->dev);\r\nsnd_soc_update_bits(codec, WM2200_FLL_CONTROL_1,\r\nWM2200_FLL_ENA, WM2200_FLL_ENA);\r\nif (i2c->irq)\r\ntimeout = 2;\r\nelse\r\ntimeout = 50;\r\nsnd_soc_update_bits(codec, WM2200_CLOCKING_3, WM2200_SYSCLK_ENA,\r\nWM2200_SYSCLK_ENA);\r\nfor (i = 0; i < timeout; i++) {\r\nif (i2c->irq) {\r\nret = wait_for_completion_timeout(&wm2200->fll_lock,\r\nmsecs_to_jiffies(25));\r\nif (ret > 0)\r\nbreak;\r\n} else {\r\nmsleep(1);\r\n}\r\nret = snd_soc_read(codec,\r\nWM2200_INTERRUPT_RAW_STATUS_2);\r\nif (ret < 0) {\r\ndev_err(codec->dev,\r\n"Failed to read FLL status: %d\n",\r\nret);\r\ncontinue;\r\n}\r\nif (ret & WM2200_FLL_LOCK_STS)\r\nbreak;\r\n}\r\nif (i == timeout) {\r\ndev_err(codec->dev, "FLL lock timed out\n");\r\npm_runtime_put(codec->dev);\r\nreturn -ETIMEDOUT;\r\n}\r\nwm2200->fll_src = source;\r\nwm2200->fll_fref = Fref;\r\nwm2200->fll_fout = Fout;\r\ndev_dbg(codec->dev, "FLL running %dHz->%dHz\n", Fref, Fout);\r\nreturn 0;\r\n}\r\nstatic int wm2200_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nunsigned int val = 0;\r\nint ret;\r\nret = snd_soc_read(codec, WM2200_GPIO_CTRL_1);\r\nif (ret >= 0) {\r\nif ((ret & WM2200_GP1_FN_MASK) != 0) {\r\ndai->symmetric_rates = true;\r\nval = WM2200_AIF1TX_LRCLK_SRC;\r\n}\r\n} else {\r\ndev_err(codec->dev, "Failed to read GPIO 1 config: %d\n", ret);\r\n}\r\nsnd_soc_update_bits(codec, WM2200_AUDIO_IF_1_2,\r\nWM2200_AIF1TX_LRCLK_SRC, val);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t wm2200_irq(int irq, void *data)\r\n{\r\nstruct wm2200_priv *wm2200 = data;\r\nunsigned int val, mask;\r\nint ret;\r\nret = regmap_read(wm2200->regmap, WM2200_INTERRUPT_STATUS_2, &val);\r\nif (ret != 0) {\r\ndev_err(wm2200->dev, "Failed to read IRQ status: %d\n", ret);\r\nreturn IRQ_NONE;\r\n}\r\nret = regmap_read(wm2200->regmap, WM2200_INTERRUPT_STATUS_2_MASK,\r\n&mask);\r\nif (ret != 0) {\r\ndev_warn(wm2200->dev, "Failed to read IRQ mask: %d\n", ret);\r\nmask = 0;\r\n}\r\nval &= ~mask;\r\nif (val & WM2200_FLL_LOCK_EINT) {\r\ndev_dbg(wm2200->dev, "FLL locked\n");\r\ncomplete(&wm2200->fll_lock);\r\n}\r\nif (val) {\r\nregmap_write(wm2200->regmap, WM2200_INTERRUPT_STATUS_2, val);\r\nreturn IRQ_HANDLED;\r\n} else {\r\nreturn IRQ_NONE;\r\n}\r\n}\r\nstatic int wm2200_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm2200_pdata *pdata = dev_get_platdata(&i2c->dev);\r\nstruct wm2200_priv *wm2200;\r\nunsigned int reg;\r\nint ret, i;\r\nint val;\r\nwm2200 = devm_kzalloc(&i2c->dev, sizeof(struct wm2200_priv),\r\nGFP_KERNEL);\r\nif (wm2200 == NULL)\r\nreturn -ENOMEM;\r\nwm2200->dev = &i2c->dev;\r\ninit_completion(&wm2200->fll_lock);\r\nwm2200->regmap = devm_regmap_init_i2c(i2c, &wm2200_regmap);\r\nif (IS_ERR(wm2200->regmap)) {\r\nret = PTR_ERR(wm2200->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nwm2200->dsp[i].type = WMFW_ADSP1;\r\nwm2200->dsp[i].part = "wm2200";\r\nwm2200->dsp[i].num = i + 1;\r\nwm2200->dsp[i].dev = &i2c->dev;\r\nwm2200->dsp[i].regmap = wm2200->regmap;\r\nwm2200->dsp[i].sysclk_reg = WM2200_CLOCKING_3;\r\nwm2200->dsp[i].sysclk_mask = WM2200_SYSCLK_FREQ_MASK;\r\nwm2200->dsp[i].sysclk_shift = WM2200_SYSCLK_FREQ_SHIFT;\r\n}\r\nwm2200->dsp[0].base = WM2200_DSP1_CONTROL_1;\r\nwm2200->dsp[0].mem = wm2200_dsp1_regions;\r\nwm2200->dsp[0].num_mems = ARRAY_SIZE(wm2200_dsp1_regions);\r\nwm2200->dsp[1].base = WM2200_DSP2_CONTROL_1;\r\nwm2200->dsp[1].mem = wm2200_dsp2_regions;\r\nwm2200->dsp[1].num_mems = ARRAY_SIZE(wm2200_dsp2_regions);\r\nfor (i = 0; i < ARRAY_SIZE(wm2200->dsp); i++)\r\nwm_adsp1_init(&wm2200->dsp[i]);\r\nif (pdata)\r\nwm2200->pdata = *pdata;\r\ni2c_set_clientdata(i2c, wm2200);\r\nfor (i = 0; i < ARRAY_SIZE(wm2200->core_supplies); i++)\r\nwm2200->core_supplies[i].supply = wm2200_core_supply_names[i];\r\nret = devm_regulator_bulk_get(&i2c->dev,\r\nARRAY_SIZE(wm2200->core_supplies),\r\nwm2200->core_supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to request core supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm2200->core_supplies),\r\nwm2200->core_supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to enable core supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (wm2200->pdata.ldo_ena) {\r\nret = devm_gpio_request_one(&i2c->dev, wm2200->pdata.ldo_ena,\r\nGPIOF_OUT_INIT_HIGH,\r\n"WM2200 LDOENA");\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to request LDOENA %d: %d\n",\r\nwm2200->pdata.ldo_ena, ret);\r\ngoto err_enable;\r\n}\r\nmsleep(2);\r\n}\r\nif (wm2200->pdata.reset) {\r\nret = devm_gpio_request_one(&i2c->dev, wm2200->pdata.reset,\r\nGPIOF_OUT_INIT_HIGH,\r\n"WM2200 /RESET");\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to request /RESET %d: %d\n",\r\nwm2200->pdata.reset, ret);\r\ngoto err_ldo;\r\n}\r\n}\r\nret = regmap_read(wm2200->regmap, WM2200_SOFTWARE_RESET, &reg);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to read ID register: %d\n", ret);\r\ngoto err_reset;\r\n}\r\nswitch (reg) {\r\ncase 0x2200:\r\nbreak;\r\ndefault:\r\ndev_err(&i2c->dev, "Device is not a WM2200, ID is %x\n", reg);\r\nret = -EINVAL;\r\ngoto err_reset;\r\n}\r\nret = regmap_read(wm2200->regmap, WM2200_DEVICE_REVISION, &reg);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to read revision register\n");\r\ngoto err_reset;\r\n}\r\nwm2200->rev = reg & WM2200_DEVICE_REVISION_MASK;\r\ndev_info(&i2c->dev, "revision %c\n", wm2200->rev + 'A');\r\nswitch (wm2200->rev) {\r\ncase 0:\r\ncase 1:\r\nret = regmap_register_patch(wm2200->regmap, wm2200_reva_patch,\r\nARRAY_SIZE(wm2200_reva_patch));\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to register patch: %d\n",\r\nret);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nret = wm2200_reset(wm2200);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to issue reset\n");\r\ngoto err_reset;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(wm2200->pdata.gpio_defaults); i++) {\r\nif (!wm2200->pdata.gpio_defaults[i])\r\ncontinue;\r\nregmap_write(wm2200->regmap, WM2200_GPIO_CTRL_1 + i,\r\nwm2200->pdata.gpio_defaults[i]);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(wm2200_dig_vu); i++)\r\nregmap_update_bits(wm2200->regmap, wm2200_dig_vu[i],\r\nWM2200_OUT_VU, WM2200_OUT_VU);\r\nfor (i = 0; i < 6; i++) {\r\nregmap_write(wm2200->regmap, WM2200_AUDIO_IF_1_10 + i, i);\r\nregmap_write(wm2200->regmap, WM2200_AUDIO_IF_1_16 + i, i);\r\n}\r\nfor (i = 0; i < WM2200_MAX_MICBIAS; i++) {\r\nif (!wm2200->pdata.micbias[i].mb_lvl &&\r\n!wm2200->pdata.micbias[i].bypass)\r\ncontinue;\r\nif (!wm2200->pdata.micbias[i].mb_lvl)\r\nwm2200->pdata.micbias[i].mb_lvl\r\n= WM2200_MBIAS_LVL_1V5;\r\nval = (wm2200->pdata.micbias[i].mb_lvl -1)\r\n<< WM2200_MICB1_LVL_SHIFT;\r\nif (wm2200->pdata.micbias[i].discharge)\r\nval |= WM2200_MICB1_DISCH;\r\nif (wm2200->pdata.micbias[i].fast_start)\r\nval |= WM2200_MICB1_RATE;\r\nif (wm2200->pdata.micbias[i].bypass)\r\nval |= WM2200_MICB1_MODE;\r\nregmap_update_bits(wm2200->regmap,\r\nWM2200_MIC_BIAS_CTRL_1 + i,\r\nWM2200_MICB1_LVL_MASK |\r\nWM2200_MICB1_DISCH |\r\nWM2200_MICB1_MODE |\r\nWM2200_MICB1_RATE, val);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(wm2200->pdata.in_mode); i++) {\r\nregmap_update_bits(wm2200->regmap, wm2200_mic_ctrl_reg[i],\r\nWM2200_IN1_MODE_MASK |\r\nWM2200_IN1_DMIC_SUP_MASK,\r\n(wm2200->pdata.in_mode[i] <<\r\nWM2200_IN1_MODE_SHIFT) |\r\n(wm2200->pdata.dmic_sup[i] <<\r\nWM2200_IN1_DMIC_SUP_SHIFT));\r\n}\r\nif (i2c->irq) {\r\nret = request_threaded_irq(i2c->irq, NULL, wm2200_irq,\r\nIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\r\n"wm2200", wm2200);\r\nif (ret == 0)\r\nregmap_update_bits(wm2200->regmap,\r\nWM2200_INTERRUPT_STATUS_2_MASK,\r\nWM2200_FLL_LOCK_EINT, 0);\r\nelse\r\ndev_err(&i2c->dev, "Failed to request IRQ %d: %d\n",\r\ni2c->irq, ret);\r\n}\r\npm_runtime_set_active(&i2c->dev);\r\npm_runtime_enable(&i2c->dev);\r\npm_request_idle(&i2c->dev);\r\nret = snd_soc_register_codec(&i2c->dev, &soc_codec_wm2200,\r\n&wm2200_dai, 1);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to register CODEC: %d\n", ret);\r\ngoto err_pm_runtime;\r\n}\r\nreturn 0;\r\nerr_pm_runtime:\r\npm_runtime_disable(&i2c->dev);\r\nerr_reset:\r\nif (wm2200->pdata.reset)\r\ngpio_set_value_cansleep(wm2200->pdata.reset, 0);\r\nerr_ldo:\r\nif (wm2200->pdata.ldo_ena)\r\ngpio_set_value_cansleep(wm2200->pdata.ldo_ena, 0);\r\nerr_enable:\r\nregulator_bulk_disable(ARRAY_SIZE(wm2200->core_supplies),\r\nwm2200->core_supplies);\r\nreturn ret;\r\n}\r\nstatic int wm2200_i2c_remove(struct i2c_client *i2c)\r\n{\r\nstruct wm2200_priv *wm2200 = i2c_get_clientdata(i2c);\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nif (i2c->irq)\r\nfree_irq(i2c->irq, wm2200);\r\nif (wm2200->pdata.reset)\r\ngpio_set_value_cansleep(wm2200->pdata.reset, 0);\r\nif (wm2200->pdata.ldo_ena)\r\ngpio_set_value_cansleep(wm2200->pdata.ldo_ena, 0);\r\nreturn 0;\r\n}\r\nstatic int wm2200_runtime_suspend(struct device *dev)\r\n{\r\nstruct wm2200_priv *wm2200 = dev_get_drvdata(dev);\r\nregcache_cache_only(wm2200->regmap, true);\r\nregcache_mark_dirty(wm2200->regmap);\r\nif (wm2200->pdata.ldo_ena)\r\ngpio_set_value_cansleep(wm2200->pdata.ldo_ena, 0);\r\nregulator_bulk_disable(ARRAY_SIZE(wm2200->core_supplies),\r\nwm2200->core_supplies);\r\nreturn 0;\r\n}\r\nstatic int wm2200_runtime_resume(struct device *dev)\r\n{\r\nstruct wm2200_priv *wm2200 = dev_get_drvdata(dev);\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm2200->core_supplies),\r\nwm2200->core_supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (wm2200->pdata.ldo_ena) {\r\ngpio_set_value_cansleep(wm2200->pdata.ldo_ena, 1);\r\nmsleep(2);\r\n}\r\nregcache_cache_only(wm2200->regmap, false);\r\nregcache_sync(wm2200->regmap);\r\nreturn 0;\r\n}
