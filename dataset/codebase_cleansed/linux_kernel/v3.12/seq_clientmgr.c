static inline mm_segment_t snd_enter_user(void)\r\n{\r\nmm_segment_t fs = get_fs();\r\nset_fs(get_ds());\r\nreturn fs;\r\n}\r\nstatic inline void snd_leave_user(mm_segment_t fs)\r\n{\r\nset_fs(fs);\r\n}\r\nstatic inline unsigned short snd_seq_file_flags(struct file *file)\r\n{\r\nswitch (file->f_mode & (FMODE_READ | FMODE_WRITE)) {\r\ncase FMODE_WRITE:\r\nreturn SNDRV_SEQ_LFLG_OUTPUT;\r\ncase FMODE_READ:\r\nreturn SNDRV_SEQ_LFLG_INPUT;\r\ndefault:\r\nreturn SNDRV_SEQ_LFLG_OPEN;\r\n}\r\n}\r\nstatic inline int snd_seq_write_pool_allocated(struct snd_seq_client *client)\r\n{\r\nreturn snd_seq_total_cells(client->pool) > 0;\r\n}\r\nstatic struct snd_seq_client *clientptr(int clientid)\r\n{\r\nif (clientid < 0 || clientid >= SNDRV_SEQ_MAX_CLIENTS) {\r\nsnd_printd("Seq: oops. Trying to get pointer to client %d\n",\r\nclientid);\r\nreturn NULL;\r\n}\r\nreturn clienttab[clientid];\r\n}\r\nstruct snd_seq_client *snd_seq_client_use_ptr(int clientid)\r\n{\r\nunsigned long flags;\r\nstruct snd_seq_client *client;\r\nif (clientid < 0 || clientid >= SNDRV_SEQ_MAX_CLIENTS) {\r\nsnd_printd("Seq: oops. Trying to get pointer to client %d\n",\r\nclientid);\r\nreturn NULL;\r\n}\r\nspin_lock_irqsave(&clients_lock, flags);\r\nclient = clientptr(clientid);\r\nif (client)\r\ngoto __lock;\r\nif (clienttablock[clientid]) {\r\nspin_unlock_irqrestore(&clients_lock, flags);\r\nreturn NULL;\r\n}\r\nspin_unlock_irqrestore(&clients_lock, flags);\r\n#ifdef CONFIG_MODULES\r\nif (!in_interrupt()) {\r\nstatic char client_requested[SNDRV_SEQ_GLOBAL_CLIENTS];\r\nstatic char card_requested[SNDRV_CARDS];\r\nif (clientid < SNDRV_SEQ_GLOBAL_CLIENTS) {\r\nint idx;\r\nif (!client_requested[clientid]) {\r\nclient_requested[clientid] = 1;\r\nfor (idx = 0; idx < 15; idx++) {\r\nif (seq_client_load[idx] < 0)\r\nbreak;\r\nif (seq_client_load[idx] == clientid) {\r\nrequest_module("snd-seq-client-%i",\r\nclientid);\r\nbreak;\r\n}\r\n}\r\n}\r\n} else if (clientid < SNDRV_SEQ_DYNAMIC_CLIENTS_BEGIN) {\r\nint card = (clientid - SNDRV_SEQ_GLOBAL_CLIENTS) /\r\nSNDRV_SEQ_CLIENTS_PER_CARD;\r\nif (card < snd_ecards_limit) {\r\nif (! card_requested[card]) {\r\ncard_requested[card] = 1;\r\nsnd_request_card(card);\r\n}\r\nsnd_seq_device_load_drivers();\r\n}\r\n}\r\nspin_lock_irqsave(&clients_lock, flags);\r\nclient = clientptr(clientid);\r\nif (client)\r\ngoto __lock;\r\nspin_unlock_irqrestore(&clients_lock, flags);\r\n}\r\n#endif\r\nreturn NULL;\r\n__lock:\r\nsnd_use_lock_use(&client->use_lock);\r\nspin_unlock_irqrestore(&clients_lock, flags);\r\nreturn client;\r\n}\r\nstatic void usage_alloc(struct snd_seq_usage *res, int num)\r\n{\r\nres->cur += num;\r\nif (res->cur > res->peak)\r\nres->peak = res->cur;\r\n}\r\nstatic void usage_free(struct snd_seq_usage *res, int num)\r\n{\r\nres->cur -= num;\r\n}\r\nint __init client_init_data(void)\r\n{\r\nmemset(&clienttablock, 0, sizeof(clienttablock));\r\nmemset(&clienttab, 0, sizeof(clienttab));\r\nreturn 0;\r\n}\r\nstatic struct snd_seq_client *seq_create_client1(int client_index, int poolsize)\r\n{\r\nunsigned long flags;\r\nint c;\r\nstruct snd_seq_client *client;\r\nclient = kzalloc(sizeof(*client), GFP_KERNEL);\r\nif (client == NULL)\r\nreturn NULL;\r\nclient->pool = snd_seq_pool_new(poolsize);\r\nif (client->pool == NULL) {\r\nkfree(client);\r\nreturn NULL;\r\n}\r\nclient->type = NO_CLIENT;\r\nsnd_use_lock_init(&client->use_lock);\r\nrwlock_init(&client->ports_lock);\r\nmutex_init(&client->ports_mutex);\r\nINIT_LIST_HEAD(&client->ports_list_head);\r\nspin_lock_irqsave(&clients_lock, flags);\r\nif (client_index < 0) {\r\nfor (c = SNDRV_SEQ_DYNAMIC_CLIENTS_BEGIN;\r\nc < SNDRV_SEQ_MAX_CLIENTS;\r\nc++) {\r\nif (clienttab[c] || clienttablock[c])\r\ncontinue;\r\nclienttab[client->number = c] = client;\r\nspin_unlock_irqrestore(&clients_lock, flags);\r\nreturn client;\r\n}\r\n} else {\r\nif (clienttab[client_index] == NULL && !clienttablock[client_index]) {\r\nclienttab[client->number = client_index] = client;\r\nspin_unlock_irqrestore(&clients_lock, flags);\r\nreturn client;\r\n}\r\n}\r\nspin_unlock_irqrestore(&clients_lock, flags);\r\nsnd_seq_pool_delete(&client->pool);\r\nkfree(client);\r\nreturn NULL;\r\n}\r\nstatic int seq_free_client1(struct snd_seq_client *client)\r\n{\r\nunsigned long flags;\r\nif (!client)\r\nreturn 0;\r\nsnd_seq_delete_all_ports(client);\r\nsnd_seq_queue_client_leave(client->number);\r\nspin_lock_irqsave(&clients_lock, flags);\r\nclienttablock[client->number] = 1;\r\nclienttab[client->number] = NULL;\r\nspin_unlock_irqrestore(&clients_lock, flags);\r\nsnd_use_lock_sync(&client->use_lock);\r\nsnd_seq_queue_client_termination(client->number);\r\nif (client->pool)\r\nsnd_seq_pool_delete(&client->pool);\r\nspin_lock_irqsave(&clients_lock, flags);\r\nclienttablock[client->number] = 0;\r\nspin_unlock_irqrestore(&clients_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void seq_free_client(struct snd_seq_client * client)\r\n{\r\nmutex_lock(&register_mutex);\r\nswitch (client->type) {\r\ncase NO_CLIENT:\r\nsnd_printk(KERN_WARNING "Seq: Trying to free unused client %d\n",\r\nclient->number);\r\nbreak;\r\ncase USER_CLIENT:\r\ncase KERNEL_CLIENT:\r\nseq_free_client1(client);\r\nusage_free(&client_usage, 1);\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "Seq: Trying to free client %d with undefined type = %d\n",\r\nclient->number, client->type);\r\n}\r\nmutex_unlock(&register_mutex);\r\nsnd_seq_system_client_ev_client_exit(client->number);\r\n}\r\nstatic int snd_seq_open(struct inode *inode, struct file *file)\r\n{\r\nint c, mode;\r\nstruct snd_seq_client *client;\r\nstruct snd_seq_user_client *user;\r\nint err;\r\nerr = nonseekable_open(inode, file);\r\nif (err < 0)\r\nreturn err;\r\nif (mutex_lock_interruptible(&register_mutex))\r\nreturn -ERESTARTSYS;\r\nclient = seq_create_client1(-1, SNDRV_SEQ_DEFAULT_EVENTS);\r\nif (client == NULL) {\r\nmutex_unlock(&register_mutex);\r\nreturn -ENOMEM;\r\n}\r\nmode = snd_seq_file_flags(file);\r\nif (mode & SNDRV_SEQ_LFLG_INPUT)\r\nclient->accept_input = 1;\r\nif (mode & SNDRV_SEQ_LFLG_OUTPUT)\r\nclient->accept_output = 1;\r\nuser = &client->data.user;\r\nuser->fifo = NULL;\r\nuser->fifo_pool_size = 0;\r\nif (mode & SNDRV_SEQ_LFLG_INPUT) {\r\nuser->fifo_pool_size = SNDRV_SEQ_DEFAULT_CLIENT_EVENTS;\r\nuser->fifo = snd_seq_fifo_new(user->fifo_pool_size);\r\nif (user->fifo == NULL) {\r\nseq_free_client1(client);\r\nkfree(client);\r\nmutex_unlock(&register_mutex);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nusage_alloc(&client_usage, 1);\r\nclient->type = USER_CLIENT;\r\nmutex_unlock(&register_mutex);\r\nc = client->number;\r\nfile->private_data = client;\r\nuser->file = file;\r\nsprintf(client->name, "Client-%d", c);\r\nsnd_seq_system_client_ev_client_start(c);\r\nreturn 0;\r\n}\r\nstatic int snd_seq_release(struct inode *inode, struct file *file)\r\n{\r\nstruct snd_seq_client *client = file->private_data;\r\nif (client) {\r\nseq_free_client(client);\r\nif (client->data.user.fifo)\r\nsnd_seq_fifo_delete(&client->data.user.fifo);\r\nkfree(client);\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t snd_seq_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *offset)\r\n{\r\nstruct snd_seq_client *client = file->private_data;\r\nstruct snd_seq_fifo *fifo;\r\nint err;\r\nlong result = 0;\r\nstruct snd_seq_event_cell *cell;\r\nif (!(snd_seq_file_flags(file) & SNDRV_SEQ_LFLG_INPUT))\r\nreturn -ENXIO;\r\nif (!access_ok(VERIFY_WRITE, buf, count))\r\nreturn -EFAULT;\r\nif (snd_BUG_ON(!client))\r\nreturn -ENXIO;\r\nif (!client->accept_input || (fifo = client->data.user.fifo) == NULL)\r\nreturn -ENXIO;\r\nif (atomic_read(&fifo->overflow) > 0) {\r\nsnd_seq_fifo_clear(fifo);\r\nreturn -ENOSPC;\r\n}\r\ncell = NULL;\r\nerr = 0;\r\nsnd_seq_fifo_lock(fifo);\r\nwhile (count >= sizeof(struct snd_seq_event)) {\r\nint nonblock;\r\nnonblock = (file->f_flags & O_NONBLOCK) || result > 0;\r\nif ((err = snd_seq_fifo_cell_out(fifo, &cell, nonblock)) < 0) {\r\nbreak;\r\n}\r\nif (snd_seq_ev_is_variable(&cell->event)) {\r\nstruct snd_seq_event tmpev;\r\ntmpev = cell->event;\r\ntmpev.data.ext.len &= ~SNDRV_SEQ_EXT_MASK;\r\nif (copy_to_user(buf, &tmpev, sizeof(struct snd_seq_event))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\ncount -= sizeof(struct snd_seq_event);\r\nbuf += sizeof(struct snd_seq_event);\r\nerr = snd_seq_expand_var_event(&cell->event, count,\r\n(char __force *)buf, 0,\r\nsizeof(struct snd_seq_event));\r\nif (err < 0)\r\nbreak;\r\nresult += err;\r\ncount -= err;\r\nbuf += err;\r\n} else {\r\nif (copy_to_user(buf, &cell->event, sizeof(struct snd_seq_event))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\ncount -= sizeof(struct snd_seq_event);\r\nbuf += sizeof(struct snd_seq_event);\r\n}\r\nsnd_seq_cell_free(cell);\r\ncell = NULL;\r\nresult += sizeof(struct snd_seq_event);\r\n}\r\nif (err < 0) {\r\nif (cell)\r\nsnd_seq_fifo_cell_putback(fifo, cell);\r\nif (err == -EAGAIN && result > 0)\r\nerr = 0;\r\n}\r\nsnd_seq_fifo_unlock(fifo);\r\nreturn (err < 0) ? err : result;\r\n}\r\nstatic int check_port_perm(struct snd_seq_client_port *port, unsigned int flags)\r\n{\r\nif ((port->capability & flags) != flags)\r\nreturn 0;\r\nreturn flags;\r\n}\r\nstatic struct snd_seq_client *get_event_dest_client(struct snd_seq_event *event,\r\nint filter)\r\n{\r\nstruct snd_seq_client *dest;\r\ndest = snd_seq_client_use_ptr(event->dest.client);\r\nif (dest == NULL)\r\nreturn NULL;\r\nif (! dest->accept_input)\r\ngoto __not_avail;\r\nif ((dest->filter & SNDRV_SEQ_FILTER_USE_EVENT) &&\r\n! test_bit(event->type, dest->event_filter))\r\ngoto __not_avail;\r\nif (filter && !(dest->filter & filter))\r\ngoto __not_avail;\r\nreturn dest;\r\n__not_avail:\r\nsnd_seq_client_unlock(dest);\r\nreturn NULL;\r\n}\r\nstatic int bounce_error_event(struct snd_seq_client *client,\r\nstruct snd_seq_event *event,\r\nint err, int atomic, int hop)\r\n{\r\nstruct snd_seq_event bounce_ev;\r\nint result;\r\nif (client == NULL ||\r\n! (client->filter & SNDRV_SEQ_FILTER_BOUNCE) ||\r\n! client->accept_input)\r\nreturn 0;\r\nmemset(&bounce_ev, 0, sizeof(bounce_ev));\r\nbounce_ev.type = SNDRV_SEQ_EVENT_KERNEL_ERROR;\r\nbounce_ev.flags = SNDRV_SEQ_EVENT_LENGTH_FIXED;\r\nbounce_ev.queue = SNDRV_SEQ_QUEUE_DIRECT;\r\nbounce_ev.source.client = SNDRV_SEQ_CLIENT_SYSTEM;\r\nbounce_ev.source.port = SNDRV_SEQ_PORT_SYSTEM_ANNOUNCE;\r\nbounce_ev.dest.client = client->number;\r\nbounce_ev.dest.port = event->source.port;\r\nbounce_ev.data.quote.origin = event->dest;\r\nbounce_ev.data.quote.event = event;\r\nbounce_ev.data.quote.value = -err;\r\nresult = snd_seq_deliver_single_event(NULL, &bounce_ev, 0, atomic, hop + 1);\r\nif (result < 0) {\r\nclient->event_lost++;\r\nreturn result;\r\n}\r\nreturn result;\r\n}\r\nstatic int update_timestamp_of_queue(struct snd_seq_event *event,\r\nint queue, int real_time)\r\n{\r\nstruct snd_seq_queue *q;\r\nq = queueptr(queue);\r\nif (! q)\r\nreturn 0;\r\nevent->queue = queue;\r\nevent->flags &= ~SNDRV_SEQ_TIME_STAMP_MASK;\r\nif (real_time) {\r\nevent->time.time = snd_seq_timer_get_cur_time(q->timer);\r\nevent->flags |= SNDRV_SEQ_TIME_STAMP_REAL;\r\n} else {\r\nevent->time.tick = snd_seq_timer_get_cur_tick(q->timer);\r\nevent->flags |= SNDRV_SEQ_TIME_STAMP_TICK;\r\n}\r\nqueuefree(q);\r\nreturn 1;\r\n}\r\nstatic int snd_seq_deliver_single_event(struct snd_seq_client *client,\r\nstruct snd_seq_event *event,\r\nint filter, int atomic, int hop)\r\n{\r\nstruct snd_seq_client *dest = NULL;\r\nstruct snd_seq_client_port *dest_port = NULL;\r\nint result = -ENOENT;\r\nint direct;\r\ndirect = snd_seq_ev_is_direct(event);\r\ndest = get_event_dest_client(event, filter);\r\nif (dest == NULL)\r\ngoto __skip;\r\ndest_port = snd_seq_port_use_ptr(dest, event->dest.port);\r\nif (dest_port == NULL)\r\ngoto __skip;\r\nif (! check_port_perm(dest_port, SNDRV_SEQ_PORT_CAP_WRITE)) {\r\nresult = -EPERM;\r\ngoto __skip;\r\n}\r\nif (dest_port->timestamping)\r\nupdate_timestamp_of_queue(event, dest_port->time_queue,\r\ndest_port->time_real);\r\nswitch (dest->type) {\r\ncase USER_CLIENT:\r\nif (dest->data.user.fifo)\r\nresult = snd_seq_fifo_event_in(dest->data.user.fifo, event);\r\nbreak;\r\ncase KERNEL_CLIENT:\r\nif (dest_port->event_input == NULL)\r\nbreak;\r\nresult = dest_port->event_input(event, direct,\r\ndest_port->private_data,\r\natomic, hop);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n__skip:\r\nif (dest_port)\r\nsnd_seq_port_unlock(dest_port);\r\nif (dest)\r\nsnd_seq_client_unlock(dest);\r\nif (result < 0 && !direct) {\r\nresult = bounce_error_event(client, event, result, atomic, hop);\r\n}\r\nreturn result;\r\n}\r\nstatic int deliver_to_subscribers(struct snd_seq_client *client,\r\nstruct snd_seq_event *event,\r\nint atomic, int hop)\r\n{\r\nstruct snd_seq_subscribers *subs;\r\nint err = 0, num_ev = 0;\r\nstruct snd_seq_event event_saved;\r\nstruct snd_seq_client_port *src_port;\r\nstruct snd_seq_port_subs_info *grp;\r\nsrc_port = snd_seq_port_use_ptr(client, event->source.port);\r\nif (src_port == NULL)\r\nreturn -EINVAL;\r\nevent_saved = *event;\r\ngrp = &src_port->c_src;\r\nif (atomic)\r\nread_lock(&grp->list_lock);\r\nelse\r\ndown_read(&grp->list_mutex);\r\nlist_for_each_entry(subs, &grp->list_head, src_list) {\r\nevent->dest = subs->info.dest;\r\nif (subs->info.flags & SNDRV_SEQ_PORT_SUBS_TIMESTAMP)\r\nupdate_timestamp_of_queue(event, subs->info.queue,\r\nsubs->info.flags & SNDRV_SEQ_PORT_SUBS_TIME_REAL);\r\nerr = snd_seq_deliver_single_event(client, event,\r\n0, atomic, hop);\r\nif (err < 0)\r\nbreak;\r\nnum_ev++;\r\n*event = event_saved;\r\n}\r\nif (atomic)\r\nread_unlock(&grp->list_lock);\r\nelse\r\nup_read(&grp->list_mutex);\r\n*event = event_saved;\r\nsnd_seq_port_unlock(src_port);\r\nreturn (err < 0) ? err : num_ev;\r\n}\r\nstatic int port_broadcast_event(struct snd_seq_client *client,\r\nstruct snd_seq_event *event,\r\nint atomic, int hop)\r\n{\r\nint num_ev = 0, err = 0;\r\nstruct snd_seq_client *dest_client;\r\nstruct snd_seq_client_port *port;\r\ndest_client = get_event_dest_client(event, SNDRV_SEQ_FILTER_BROADCAST);\r\nif (dest_client == NULL)\r\nreturn 0;\r\nread_lock(&dest_client->ports_lock);\r\nlist_for_each_entry(port, &dest_client->ports_list_head, list) {\r\nevent->dest.port = port->addr.port;\r\nerr = snd_seq_deliver_single_event(NULL, event,\r\nSNDRV_SEQ_FILTER_BROADCAST,\r\natomic, hop);\r\nif (err < 0)\r\nbreak;\r\nnum_ev++;\r\n}\r\nread_unlock(&dest_client->ports_lock);\r\nsnd_seq_client_unlock(dest_client);\r\nevent->dest.port = SNDRV_SEQ_ADDRESS_BROADCAST;\r\nreturn (err < 0) ? err : num_ev;\r\n}\r\nstatic int broadcast_event(struct snd_seq_client *client,\r\nstruct snd_seq_event *event, int atomic, int hop)\r\n{\r\nint err = 0, num_ev = 0;\r\nint dest;\r\nstruct snd_seq_addr addr;\r\naddr = event->dest;\r\nfor (dest = 0; dest < SNDRV_SEQ_MAX_CLIENTS; dest++) {\r\nif (dest == client->number)\r\ncontinue;\r\nevent->dest.client = dest;\r\nevent->dest.port = addr.port;\r\nif (addr.port == SNDRV_SEQ_ADDRESS_BROADCAST)\r\nerr = port_broadcast_event(client, event, atomic, hop);\r\nelse\r\nerr = snd_seq_deliver_single_event(NULL, event,\r\nSNDRV_SEQ_FILTER_BROADCAST,\r\natomic, hop);\r\nif (err < 0)\r\nbreak;\r\nnum_ev += err;\r\n}\r\nevent->dest = addr;\r\nreturn (err < 0) ? err : num_ev;\r\n}\r\nstatic int multicast_event(struct snd_seq_client *client, struct snd_seq_event *event,\r\nint atomic, int hop)\r\n{\r\nsnd_printd("seq: multicast not supported yet.\n");\r\nreturn 0;\r\n}\r\nstatic int snd_seq_deliver_event(struct snd_seq_client *client, struct snd_seq_event *event,\r\nint atomic, int hop)\r\n{\r\nint result;\r\nhop++;\r\nif (hop >= SNDRV_SEQ_MAX_HOPS) {\r\nsnd_printd("too long delivery path (%d:%d->%d:%d)\n",\r\nevent->source.client, event->source.port,\r\nevent->dest.client, event->dest.port);\r\nreturn -EMLINK;\r\n}\r\nif (event->queue == SNDRV_SEQ_ADDRESS_SUBSCRIBERS ||\r\nevent->dest.client == SNDRV_SEQ_ADDRESS_SUBSCRIBERS)\r\nresult = deliver_to_subscribers(client, event, atomic, hop);\r\n#ifdef SUPPORT_BROADCAST\r\nelse if (event->queue == SNDRV_SEQ_ADDRESS_BROADCAST ||\r\nevent->dest.client == SNDRV_SEQ_ADDRESS_BROADCAST)\r\nresult = broadcast_event(client, event, atomic, hop);\r\nelse if (event->dest.client >= SNDRV_SEQ_MAX_CLIENTS)\r\nresult = multicast_event(client, event, atomic, hop);\r\nelse if (event->dest.port == SNDRV_SEQ_ADDRESS_BROADCAST)\r\nresult = port_broadcast_event(client, event, atomic, hop);\r\n#endif\r\nelse\r\nresult = snd_seq_deliver_single_event(client, event, 0, atomic, hop);\r\nreturn result;\r\n}\r\nint snd_seq_dispatch_event(struct snd_seq_event_cell *cell, int atomic, int hop)\r\n{\r\nstruct snd_seq_client *client;\r\nint result;\r\nif (snd_BUG_ON(!cell))\r\nreturn -EINVAL;\r\nclient = snd_seq_client_use_ptr(cell->event.source.client);\r\nif (client == NULL) {\r\nsnd_seq_cell_free(cell);\r\nreturn -EINVAL;\r\n}\r\nif (cell->event.type == SNDRV_SEQ_EVENT_NOTE) {\r\nstruct snd_seq_event tmpev, *ev;\r\ntmpev = cell->event;\r\ntmpev.type = SNDRV_SEQ_EVENT_NOTEON;\r\nresult = snd_seq_deliver_event(client, &tmpev, atomic, hop);\r\nev = &cell->event;\r\nev->type = SNDRV_SEQ_EVENT_NOTEOFF;\r\nev->flags |= SNDRV_SEQ_PRIORITY_HIGH;\r\nswitch (ev->flags & SNDRV_SEQ_TIME_STAMP_MASK) {\r\ncase SNDRV_SEQ_TIME_STAMP_TICK:\r\nev->time.tick += ev->data.note.duration;\r\nbreak;\r\ncase SNDRV_SEQ_TIME_STAMP_REAL:\r\nev->time.time.tv_nsec += 1000000 * (ev->data.note.duration % 1000);\r\nev->time.time.tv_sec += ev->data.note.duration / 1000 +\r\nev->time.time.tv_nsec / 1000000000;\r\nev->time.time.tv_nsec %= 1000000000;\r\nbreak;\r\n}\r\nev->data.note.velocity = ev->data.note.off_velocity;\r\nif (snd_seq_enqueue_event(cell, atomic, hop) < 0)\r\nsnd_seq_cell_free(cell);\r\n} else {\r\nresult = snd_seq_deliver_event(client, &cell->event, atomic, hop);\r\nsnd_seq_cell_free(cell);\r\n}\r\nsnd_seq_client_unlock(client);\r\nreturn result;\r\n}\r\nstatic int snd_seq_client_enqueue_event(struct snd_seq_client *client,\r\nstruct snd_seq_event *event,\r\nstruct file *file, int blocking,\r\nint atomic, int hop)\r\n{\r\nstruct snd_seq_event_cell *cell;\r\nint err;\r\nif (event->queue == SNDRV_SEQ_ADDRESS_SUBSCRIBERS) {\r\nevent->dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;\r\nevent->queue = SNDRV_SEQ_QUEUE_DIRECT;\r\n} else\r\n#ifdef SUPPORT_BROADCAST\r\nif (event->queue == SNDRV_SEQ_ADDRESS_BROADCAST) {\r\nevent->dest.client = SNDRV_SEQ_ADDRESS_BROADCAST;\r\nevent->queue = SNDRV_SEQ_QUEUE_DIRECT;\r\n}\r\n#endif\r\nif (event->dest.client == SNDRV_SEQ_ADDRESS_SUBSCRIBERS) {\r\nstruct snd_seq_client_port *src_port = snd_seq_port_use_ptr(client, event->source.port);\r\nif (src_port == NULL)\r\nreturn -EINVAL;\r\nsnd_seq_port_unlock(src_port);\r\n}\r\nif (snd_seq_ev_is_direct(event)) {\r\nif (event->type == SNDRV_SEQ_EVENT_NOTE)\r\nreturn -EINVAL;\r\nreturn snd_seq_deliver_event(client, event, atomic, hop);\r\n}\r\nif (snd_seq_queue_is_used(event->queue, client->number) <= 0)\r\nreturn -EINVAL;\r\nif (! snd_seq_write_pool_allocated(client))\r\nreturn -ENXIO;\r\nerr = snd_seq_event_dup(client->pool, event, &cell, !blocking || atomic, file);\r\nif (err < 0)\r\nreturn err;\r\nif ((err = snd_seq_enqueue_event(cell, atomic, hop)) < 0) {\r\nsnd_seq_cell_free(cell);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_event_type_and_length(struct snd_seq_event *ev)\r\n{\r\nswitch (snd_seq_ev_length_type(ev)) {\r\ncase SNDRV_SEQ_EVENT_LENGTH_FIXED:\r\nif (snd_seq_ev_is_variable_type(ev))\r\nreturn -EINVAL;\r\nbreak;\r\ncase SNDRV_SEQ_EVENT_LENGTH_VARIABLE:\r\nif (! snd_seq_ev_is_variable_type(ev) ||\r\n(ev->data.ext.len & ~SNDRV_SEQ_EXT_MASK) >= SNDRV_SEQ_MAX_EVENT_LEN)\r\nreturn -EINVAL;\r\nbreak;\r\ncase SNDRV_SEQ_EVENT_LENGTH_VARUSR:\r\nif (! snd_seq_ev_is_direct(ev))\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t snd_seq_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *offset)\r\n{\r\nstruct snd_seq_client *client = file->private_data;\r\nint written = 0, len;\r\nint err = -EINVAL;\r\nstruct snd_seq_event event;\r\nif (!(snd_seq_file_flags(file) & SNDRV_SEQ_LFLG_OUTPUT))\r\nreturn -ENXIO;\r\nif (snd_BUG_ON(!client))\r\nreturn -ENXIO;\r\nif (!client->accept_output || client->pool == NULL)\r\nreturn -ENXIO;\r\nif (client->pool->size > 0 && !snd_seq_write_pool_allocated(client)) {\r\nif (snd_seq_pool_init(client->pool) < 0)\r\nreturn -ENOMEM;\r\n}\r\nwhile (count >= sizeof(struct snd_seq_event)) {\r\nlen = sizeof(event);\r\nif (copy_from_user(&event, buf, len)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nevent.source.client = client->number;\r\nif (check_event_type_and_length(&event)) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (event.type == SNDRV_SEQ_EVENT_NONE)\r\ngoto __skip_event;\r\nelse if (snd_seq_ev_is_reserved(&event)) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (snd_seq_ev_is_variable(&event)) {\r\nint extlen = event.data.ext.len & ~SNDRV_SEQ_EXT_MASK;\r\nif ((size_t)(extlen + len) > count) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nevent.data.ext.len = extlen | SNDRV_SEQ_EXT_USRPTR;\r\nevent.data.ext.ptr = (char __force *)buf\r\n+ sizeof(struct snd_seq_event);\r\nlen += extlen;\r\n} else {\r\n#ifdef CONFIG_COMPAT\r\nif (client->convert32 && snd_seq_ev_is_varusr(&event)) {\r\nvoid *ptr = (void __force *)compat_ptr(event.data.raw32.d[1]);\r\nevent.data.ext.ptr = ptr;\r\n}\r\n#endif\r\n}\r\nerr = snd_seq_client_enqueue_event(client, &event, file,\r\n!(file->f_flags & O_NONBLOCK),\r\n0, 0);\r\nif (err < 0)\r\nbreak;\r\n__skip_event:\r\ncount -= len;\r\nbuf += len;\r\nwritten += len;\r\n}\r\nreturn written ? written : err;\r\n}\r\nstatic unsigned int snd_seq_poll(struct file *file, poll_table * wait)\r\n{\r\nstruct snd_seq_client *client = file->private_data;\r\nunsigned int mask = 0;\r\nif (snd_BUG_ON(!client))\r\nreturn -ENXIO;\r\nif ((snd_seq_file_flags(file) & SNDRV_SEQ_LFLG_INPUT) &&\r\nclient->data.user.fifo) {\r\nif (snd_seq_fifo_poll_wait(client->data.user.fifo, file, wait))\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\nif (snd_seq_file_flags(file) & SNDRV_SEQ_LFLG_OUTPUT) {\r\nif (!snd_seq_write_pool_allocated(client) ||\r\nsnd_seq_pool_poll_wait(client->pool, file, wait))\r\nmask |= POLLOUT | POLLWRNORM;\r\n}\r\nreturn mask;\r\n}\r\nstatic int snd_seq_ioctl_system_info(struct snd_seq_client *client, void __user *arg)\r\n{\r\nstruct snd_seq_system_info info;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.queues = SNDRV_SEQ_MAX_QUEUES;\r\ninfo.clients = SNDRV_SEQ_MAX_CLIENTS;\r\ninfo.ports = 256;\r\ninfo.channels = 256;\r\ninfo.cur_clients = client_usage.cur;\r\ninfo.cur_queues = snd_seq_queue_get_cur_queues();\r\nif (copy_to_user(arg, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void __user *arg)\r\n{\r\nstruct snd_seq_running_info info;\r\nstruct snd_seq_client *cptr;\r\nint err = 0;\r\nif (copy_from_user(&info, arg, sizeof(info)))\r\nreturn -EFAULT;\r\ncptr = snd_seq_client_use_ptr(info.client);\r\nif (cptr == NULL)\r\nreturn -ENOENT;\r\n#ifdef SNDRV_BIG_ENDIAN\r\nif (! info.big_endian) {\r\nerr = -EINVAL;\r\ngoto __err;\r\n}\r\n#else\r\nif (info.big_endian) {\r\nerr = -EINVAL;\r\ngoto __err;\r\n}\r\n#endif\r\nif (info.cpu_mode > sizeof(long)) {\r\nerr = -EINVAL;\r\ngoto __err;\r\n}\r\ncptr->convert32 = (info.cpu_mode < sizeof(long));\r\n__err:\r\nsnd_seq_client_unlock(cptr);\r\nreturn err;\r\n}\r\nstatic void get_client_info(struct snd_seq_client *cptr,\r\nstruct snd_seq_client_info *info)\r\n{\r\ninfo->client = cptr->number;\r\ninfo->type = cptr->type;\r\nstrcpy(info->name, cptr->name);\r\ninfo->filter = cptr->filter;\r\ninfo->event_lost = cptr->event_lost;\r\nmemcpy(info->event_filter, cptr->event_filter, 32);\r\ninfo->num_ports = cptr->num_ports;\r\nmemset(info->reserved, 0, sizeof(info->reserved));\r\n}\r\nstatic int snd_seq_ioctl_get_client_info(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nstruct snd_seq_client *cptr;\r\nstruct snd_seq_client_info client_info;\r\nif (copy_from_user(&client_info, arg, sizeof(client_info)))\r\nreturn -EFAULT;\r\ncptr = snd_seq_client_use_ptr(client_info.client);\r\nif (cptr == NULL)\r\nreturn -ENOENT;\r\nget_client_info(cptr, &client_info);\r\nsnd_seq_client_unlock(cptr);\r\nif (copy_to_user(arg, &client_info, sizeof(client_info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_seq_ioctl_set_client_info(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nstruct snd_seq_client_info client_info;\r\nif (copy_from_user(&client_info, arg, sizeof(client_info)))\r\nreturn -EFAULT;\r\nif (client->number != client_info.client)\r\nreturn -EPERM;\r\nif (client->type != client_info.type)\r\nreturn -EINVAL;\r\nif (client_info.name[0])\r\nstrlcpy(client->name, client_info.name, sizeof(client->name));\r\nclient->filter = client_info.filter;\r\nclient->event_lost = client_info.event_lost;\r\nmemcpy(client->event_filter, client_info.event_filter, 32);\r\nreturn 0;\r\n}\r\nstatic int snd_seq_ioctl_create_port(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nstruct snd_seq_client_port *port;\r\nstruct snd_seq_port_info info;\r\nstruct snd_seq_port_callback *callback;\r\nif (copy_from_user(&info, arg, sizeof(info)))\r\nreturn -EFAULT;\r\nif (info.addr.client != client->number)\r\nreturn -EPERM;\r\nport = snd_seq_create_port(client, (info.flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info.addr.port : -1);\r\nif (port == NULL)\r\nreturn -ENOMEM;\r\nif (client->type == USER_CLIENT && info.kernel) {\r\nsnd_seq_delete_port(client, port->addr.port);\r\nreturn -EINVAL;\r\n}\r\nif (client->type == KERNEL_CLIENT) {\r\nif ((callback = info.kernel) != NULL) {\r\nif (callback->owner)\r\nport->owner = callback->owner;\r\nport->private_data = callback->private_data;\r\nport->private_free = callback->private_free;\r\nport->callback_all = callback->callback_all;\r\nport->event_input = callback->event_input;\r\nport->c_src.open = callback->subscribe;\r\nport->c_src.close = callback->unsubscribe;\r\nport->c_dest.open = callback->use;\r\nport->c_dest.close = callback->unuse;\r\n}\r\n}\r\ninfo.addr = port->addr;\r\nsnd_seq_set_port_info(port, &info);\r\nsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\r\nif (copy_to_user(arg, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_seq_ioctl_delete_port(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nstruct snd_seq_port_info info;\r\nint err;\r\nif (copy_from_user(&info, arg, sizeof(info)))\r\nreturn -EFAULT;\r\nif (info.addr.client != client->number)\r\nreturn -EPERM;\r\nerr = snd_seq_delete_port(client, info.addr.port);\r\nif (err >= 0)\r\nsnd_seq_system_client_ev_port_exit(client->number, info.addr.port);\r\nreturn err;\r\n}\r\nstatic int snd_seq_ioctl_get_port_info(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nstruct snd_seq_client *cptr;\r\nstruct snd_seq_client_port *port;\r\nstruct snd_seq_port_info info;\r\nif (copy_from_user(&info, arg, sizeof(info)))\r\nreturn -EFAULT;\r\ncptr = snd_seq_client_use_ptr(info.addr.client);\r\nif (cptr == NULL)\r\nreturn -ENXIO;\r\nport = snd_seq_port_use_ptr(cptr, info.addr.port);\r\nif (port == NULL) {\r\nsnd_seq_client_unlock(cptr);\r\nreturn -ENOENT;\r\n}\r\nsnd_seq_get_port_info(port, &info);\r\nsnd_seq_port_unlock(port);\r\nsnd_seq_client_unlock(cptr);\r\nif (copy_to_user(arg, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_seq_ioctl_set_port_info(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nstruct snd_seq_client_port *port;\r\nstruct snd_seq_port_info info;\r\nif (copy_from_user(&info, arg, sizeof(info)))\r\nreturn -EFAULT;\r\nif (info.addr.client != client->number)\r\nreturn -EPERM;\r\nport = snd_seq_port_use_ptr(client, info.addr.port);\r\nif (port) {\r\nsnd_seq_set_port_info(port, &info);\r\nsnd_seq_port_unlock(port);\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_subscription_permission(struct snd_seq_client *client,\r\nstruct snd_seq_client_port *sport,\r\nstruct snd_seq_client_port *dport,\r\nstruct snd_seq_port_subscribe *subs)\r\n{\r\nif (client->number != subs->sender.client &&\r\nclient->number != subs->dest.client) {\r\nif (check_port_perm(sport, SNDRV_SEQ_PORT_CAP_NO_EXPORT))\r\nreturn -EPERM;\r\nif (check_port_perm(dport, SNDRV_SEQ_PORT_CAP_NO_EXPORT))\r\nreturn -EPERM;\r\n}\r\nif (client->number != subs->sender.client) {\r\nif (! check_port_perm(sport, PERM_RD))\r\nreturn -EPERM;\r\n}\r\nif (client->number != subs->dest.client) {\r\nif (! check_port_perm(dport, PERM_WR))\r\nreturn -EPERM;\r\n}\r\nreturn 0;\r\n}\r\nint snd_seq_client_notify_subscription(int client, int port,\r\nstruct snd_seq_port_subscribe *info,\r\nint evtype)\r\n{\r\nstruct snd_seq_event event;\r\nmemset(&event, 0, sizeof(event));\r\nevent.type = evtype;\r\nevent.data.connect.dest = info->dest;\r\nevent.data.connect.sender = info->sender;\r\nreturn snd_seq_system_notify(client, port, &event);\r\n}\r\nstatic int snd_seq_ioctl_subscribe_port(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nint result = -EINVAL;\r\nstruct snd_seq_client *receiver = NULL, *sender = NULL;\r\nstruct snd_seq_client_port *sport = NULL, *dport = NULL;\r\nstruct snd_seq_port_subscribe subs;\r\nif (copy_from_user(&subs, arg, sizeof(subs)))\r\nreturn -EFAULT;\r\nif ((receiver = snd_seq_client_use_ptr(subs.dest.client)) == NULL)\r\ngoto __end;\r\nif ((sender = snd_seq_client_use_ptr(subs.sender.client)) == NULL)\r\ngoto __end;\r\nif ((sport = snd_seq_port_use_ptr(sender, subs.sender.port)) == NULL)\r\ngoto __end;\r\nif ((dport = snd_seq_port_use_ptr(receiver, subs.dest.port)) == NULL)\r\ngoto __end;\r\nresult = check_subscription_permission(client, sport, dport, &subs);\r\nif (result < 0)\r\ngoto __end;\r\nresult = snd_seq_port_connect(client, sender, sport, receiver, dport, &subs);\r\nif (! result)\r\nsnd_seq_client_notify_subscription(SNDRV_SEQ_ADDRESS_SUBSCRIBERS, 0,\r\n&subs, SNDRV_SEQ_EVENT_PORT_SUBSCRIBED);\r\n__end:\r\nif (sport)\r\nsnd_seq_port_unlock(sport);\r\nif (dport)\r\nsnd_seq_port_unlock(dport);\r\nif (sender)\r\nsnd_seq_client_unlock(sender);\r\nif (receiver)\r\nsnd_seq_client_unlock(receiver);\r\nreturn result;\r\n}\r\nstatic int snd_seq_ioctl_unsubscribe_port(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nint result = -ENXIO;\r\nstruct snd_seq_client *receiver = NULL, *sender = NULL;\r\nstruct snd_seq_client_port *sport = NULL, *dport = NULL;\r\nstruct snd_seq_port_subscribe subs;\r\nif (copy_from_user(&subs, arg, sizeof(subs)))\r\nreturn -EFAULT;\r\nif ((receiver = snd_seq_client_use_ptr(subs.dest.client)) == NULL)\r\ngoto __end;\r\nif ((sender = snd_seq_client_use_ptr(subs.sender.client)) == NULL)\r\ngoto __end;\r\nif ((sport = snd_seq_port_use_ptr(sender, subs.sender.port)) == NULL)\r\ngoto __end;\r\nif ((dport = snd_seq_port_use_ptr(receiver, subs.dest.port)) == NULL)\r\ngoto __end;\r\nresult = check_subscription_permission(client, sport, dport, &subs);\r\nif (result < 0)\r\ngoto __end;\r\nresult = snd_seq_port_disconnect(client, sender, sport, receiver, dport, &subs);\r\nif (! result)\r\nsnd_seq_client_notify_subscription(SNDRV_SEQ_ADDRESS_SUBSCRIBERS, 0,\r\n&subs, SNDRV_SEQ_EVENT_PORT_UNSUBSCRIBED);\r\n__end:\r\nif (sport)\r\nsnd_seq_port_unlock(sport);\r\nif (dport)\r\nsnd_seq_port_unlock(dport);\r\nif (sender)\r\nsnd_seq_client_unlock(sender);\r\nif (receiver)\r\nsnd_seq_client_unlock(receiver);\r\nreturn result;\r\n}\r\nstatic int snd_seq_ioctl_create_queue(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nstruct snd_seq_queue_info info;\r\nint result;\r\nstruct snd_seq_queue *q;\r\nif (copy_from_user(&info, arg, sizeof(info)))\r\nreturn -EFAULT;\r\nresult = snd_seq_queue_alloc(client->number, info.locked, info.flags);\r\nif (result < 0)\r\nreturn result;\r\nq = queueptr(result);\r\nif (q == NULL)\r\nreturn -EINVAL;\r\ninfo.queue = q->queue;\r\ninfo.locked = q->locked;\r\ninfo.owner = q->owner;\r\nif (! info.name[0])\r\nsnprintf(info.name, sizeof(info.name), "Queue-%d", q->queue);\r\nstrlcpy(q->name, info.name, sizeof(q->name));\r\nqueuefree(q);\r\nif (copy_to_user(arg, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_seq_ioctl_delete_queue(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nstruct snd_seq_queue_info info;\r\nif (copy_from_user(&info, arg, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn snd_seq_queue_delete(client->number, info.queue);\r\n}\r\nstatic int snd_seq_ioctl_get_queue_info(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nstruct snd_seq_queue_info info;\r\nstruct snd_seq_queue *q;\r\nif (copy_from_user(&info, arg, sizeof(info)))\r\nreturn -EFAULT;\r\nq = queueptr(info.queue);\r\nif (q == NULL)\r\nreturn -EINVAL;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.queue = q->queue;\r\ninfo.owner = q->owner;\r\ninfo.locked = q->locked;\r\nstrlcpy(info.name, q->name, sizeof(info.name));\r\nqueuefree(q);\r\nif (copy_to_user(arg, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_seq_ioctl_set_queue_info(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nstruct snd_seq_queue_info info;\r\nstruct snd_seq_queue *q;\r\nif (copy_from_user(&info, arg, sizeof(info)))\r\nreturn -EFAULT;\r\nif (info.owner != client->number)\r\nreturn -EINVAL;\r\nif (snd_seq_queue_check_access(info.queue, client->number)) {\r\nif (snd_seq_queue_set_owner(info.queue, client->number, info.locked) < 0)\r\nreturn -EPERM;\r\nif (info.locked)\r\nsnd_seq_queue_use(info.queue, client->number, 1);\r\n} else {\r\nreturn -EPERM;\r\n}\r\nq = queueptr(info.queue);\r\nif (! q)\r\nreturn -EINVAL;\r\nif (q->owner != client->number) {\r\nqueuefree(q);\r\nreturn -EPERM;\r\n}\r\nstrlcpy(q->name, info.name, sizeof(q->name));\r\nqueuefree(q);\r\nreturn 0;\r\n}\r\nstatic int snd_seq_ioctl_get_named_queue(struct snd_seq_client *client, void __user *arg)\r\n{\r\nstruct snd_seq_queue_info info;\r\nstruct snd_seq_queue *q;\r\nif (copy_from_user(&info, arg, sizeof(info)))\r\nreturn -EFAULT;\r\nq = snd_seq_queue_find_name(info.name);\r\nif (q == NULL)\r\nreturn -EINVAL;\r\ninfo.queue = q->queue;\r\ninfo.owner = q->owner;\r\ninfo.locked = q->locked;\r\nqueuefree(q);\r\nif (copy_to_user(arg, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_seq_ioctl_get_queue_status(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nstruct snd_seq_queue_status status;\r\nstruct snd_seq_queue *queue;\r\nstruct snd_seq_timer *tmr;\r\nif (copy_from_user(&status, arg, sizeof(status)))\r\nreturn -EFAULT;\r\nqueue = queueptr(status.queue);\r\nif (queue == NULL)\r\nreturn -EINVAL;\r\nmemset(&status, 0, sizeof(status));\r\nstatus.queue = queue->queue;\r\ntmr = queue->timer;\r\nstatus.events = queue->tickq->cells + queue->timeq->cells;\r\nstatus.time = snd_seq_timer_get_cur_time(tmr);\r\nstatus.tick = snd_seq_timer_get_cur_tick(tmr);\r\nstatus.running = tmr->running;\r\nstatus.flags = queue->flags;\r\nqueuefree(queue);\r\nif (copy_to_user(arg, &status, sizeof(status)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_seq_ioctl_get_queue_tempo(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nstruct snd_seq_queue_tempo tempo;\r\nstruct snd_seq_queue *queue;\r\nstruct snd_seq_timer *tmr;\r\nif (copy_from_user(&tempo, arg, sizeof(tempo)))\r\nreturn -EFAULT;\r\nqueue = queueptr(tempo.queue);\r\nif (queue == NULL)\r\nreturn -EINVAL;\r\nmemset(&tempo, 0, sizeof(tempo));\r\ntempo.queue = queue->queue;\r\ntmr = queue->timer;\r\ntempo.tempo = tmr->tempo;\r\ntempo.ppq = tmr->ppq;\r\ntempo.skew_value = tmr->skew;\r\ntempo.skew_base = tmr->skew_base;\r\nqueuefree(queue);\r\nif (copy_to_user(arg, &tempo, sizeof(tempo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nint snd_seq_set_queue_tempo(int client, struct snd_seq_queue_tempo *tempo)\r\n{\r\nif (!snd_seq_queue_check_access(tempo->queue, client))\r\nreturn -EPERM;\r\nreturn snd_seq_queue_timer_set_tempo(tempo->queue, client, tempo);\r\n}\r\nstatic int snd_seq_ioctl_set_queue_tempo(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nint result;\r\nstruct snd_seq_queue_tempo tempo;\r\nif (copy_from_user(&tempo, arg, sizeof(tempo)))\r\nreturn -EFAULT;\r\nresult = snd_seq_set_queue_tempo(client->number, &tempo);\r\nreturn result < 0 ? result : 0;\r\n}\r\nstatic int snd_seq_ioctl_get_queue_timer(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nstruct snd_seq_queue_timer timer;\r\nstruct snd_seq_queue *queue;\r\nstruct snd_seq_timer *tmr;\r\nif (copy_from_user(&timer, arg, sizeof(timer)))\r\nreturn -EFAULT;\r\nqueue = queueptr(timer.queue);\r\nif (queue == NULL)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&queue->timer_mutex)) {\r\nqueuefree(queue);\r\nreturn -ERESTARTSYS;\r\n}\r\ntmr = queue->timer;\r\nmemset(&timer, 0, sizeof(timer));\r\ntimer.queue = queue->queue;\r\ntimer.type = tmr->type;\r\nif (tmr->type == SNDRV_SEQ_TIMER_ALSA) {\r\ntimer.u.alsa.id = tmr->alsa_id;\r\ntimer.u.alsa.resolution = tmr->preferred_resolution;\r\n}\r\nmutex_unlock(&queue->timer_mutex);\r\nqueuefree(queue);\r\nif (copy_to_user(arg, &timer, sizeof(timer)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_seq_ioctl_set_queue_timer(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nint result = 0;\r\nstruct snd_seq_queue_timer timer;\r\nif (copy_from_user(&timer, arg, sizeof(timer)))\r\nreturn -EFAULT;\r\nif (timer.type != SNDRV_SEQ_TIMER_ALSA)\r\nreturn -EINVAL;\r\nif (snd_seq_queue_check_access(timer.queue, client->number)) {\r\nstruct snd_seq_queue *q;\r\nstruct snd_seq_timer *tmr;\r\nq = queueptr(timer.queue);\r\nif (q == NULL)\r\nreturn -ENXIO;\r\nif (mutex_lock_interruptible(&q->timer_mutex)) {\r\nqueuefree(q);\r\nreturn -ERESTARTSYS;\r\n}\r\ntmr = q->timer;\r\nsnd_seq_queue_timer_close(timer.queue);\r\ntmr->type = timer.type;\r\nif (tmr->type == SNDRV_SEQ_TIMER_ALSA) {\r\ntmr->alsa_id = timer.u.alsa.id;\r\ntmr->preferred_resolution = timer.u.alsa.resolution;\r\n}\r\nresult = snd_seq_queue_timer_open(timer.queue);\r\nmutex_unlock(&q->timer_mutex);\r\nqueuefree(q);\r\n} else {\r\nreturn -EPERM;\r\n}\r\nreturn result;\r\n}\r\nstatic int snd_seq_ioctl_get_queue_client(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nstruct snd_seq_queue_client info;\r\nint used;\r\nif (copy_from_user(&info, arg, sizeof(info)))\r\nreturn -EFAULT;\r\nused = snd_seq_queue_is_used(info.queue, client->number);\r\nif (used < 0)\r\nreturn -EINVAL;\r\ninfo.used = used;\r\ninfo.client = client->number;\r\nif (copy_to_user(arg, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_seq_ioctl_set_queue_client(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nint err;\r\nstruct snd_seq_queue_client info;\r\nif (copy_from_user(&info, arg, sizeof(info)))\r\nreturn -EFAULT;\r\nif (info.used >= 0) {\r\nerr = snd_seq_queue_use(info.queue, client->number, info.used);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn snd_seq_ioctl_get_queue_client(client, arg);\r\n}\r\nstatic int snd_seq_ioctl_get_client_pool(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nstruct snd_seq_client_pool info;\r\nstruct snd_seq_client *cptr;\r\nif (copy_from_user(&info, arg, sizeof(info)))\r\nreturn -EFAULT;\r\ncptr = snd_seq_client_use_ptr(info.client);\r\nif (cptr == NULL)\r\nreturn -ENOENT;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.output_pool = cptr->pool->size;\r\ninfo.output_room = cptr->pool->room;\r\ninfo.output_free = info.output_pool;\r\ninfo.output_free = snd_seq_unused_cells(cptr->pool);\r\nif (cptr->type == USER_CLIENT) {\r\ninfo.input_pool = cptr->data.user.fifo_pool_size;\r\ninfo.input_free = info.input_pool;\r\nif (cptr->data.user.fifo)\r\ninfo.input_free = snd_seq_unused_cells(cptr->data.user.fifo->pool);\r\n} else {\r\ninfo.input_pool = 0;\r\ninfo.input_free = 0;\r\n}\r\nsnd_seq_client_unlock(cptr);\r\nif (copy_to_user(arg, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_seq_ioctl_set_client_pool(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nstruct snd_seq_client_pool info;\r\nint rc;\r\nif (copy_from_user(&info, arg, sizeof(info)))\r\nreturn -EFAULT;\r\nif (client->number != info.client)\r\nreturn -EINVAL;\r\nif (info.output_pool >= 1 && info.output_pool <= SNDRV_SEQ_MAX_EVENTS &&\r\n(! snd_seq_write_pool_allocated(client) ||\r\ninfo.output_pool != client->pool->size)) {\r\nif (snd_seq_write_pool_allocated(client)) {\r\nsnd_seq_queue_client_leave_cells(client->number);\r\nsnd_seq_pool_done(client->pool);\r\n}\r\nclient->pool->size = info.output_pool;\r\nrc = snd_seq_pool_init(client->pool);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nif (client->type == USER_CLIENT && client->data.user.fifo != NULL &&\r\ninfo.input_pool >= 1 &&\r\ninfo.input_pool <= SNDRV_SEQ_MAX_CLIENT_EVENTS &&\r\ninfo.input_pool != client->data.user.fifo_pool_size) {\r\nrc = snd_seq_fifo_resize(client->data.user.fifo, info.input_pool);\r\nif (rc < 0)\r\nreturn rc;\r\nclient->data.user.fifo_pool_size = info.input_pool;\r\n}\r\nif (info.output_room >= 1 &&\r\ninfo.output_room <= client->pool->size) {\r\nclient->pool->room = info.output_room;\r\n}\r\nreturn snd_seq_ioctl_get_client_pool(client, arg);\r\n}\r\nstatic int snd_seq_ioctl_remove_events(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nstruct snd_seq_remove_events info;\r\nif (copy_from_user(&info, arg, sizeof(info)))\r\nreturn -EFAULT;\r\nif (info.remove_mode & SNDRV_SEQ_REMOVE_INPUT) {\r\nif (client->type == USER_CLIENT)\r\nsnd_seq_fifo_clear(client->data.user.fifo);\r\n}\r\nif (info.remove_mode & SNDRV_SEQ_REMOVE_OUTPUT)\r\nsnd_seq_queue_remove_cells(client->number, &info);\r\nreturn 0;\r\n}\r\nstatic int snd_seq_ioctl_get_subscription(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nint result;\r\nstruct snd_seq_client *sender = NULL;\r\nstruct snd_seq_client_port *sport = NULL;\r\nstruct snd_seq_port_subscribe subs;\r\nstruct snd_seq_subscribers *p;\r\nif (copy_from_user(&subs, arg, sizeof(subs)))\r\nreturn -EFAULT;\r\nresult = -EINVAL;\r\nif ((sender = snd_seq_client_use_ptr(subs.sender.client)) == NULL)\r\ngoto __end;\r\nif ((sport = snd_seq_port_use_ptr(sender, subs.sender.port)) == NULL)\r\ngoto __end;\r\np = snd_seq_port_get_subscription(&sport->c_src, &subs.dest);\r\nif (p) {\r\nresult = 0;\r\nsubs = p->info;\r\n} else\r\nresult = -ENOENT;\r\n__end:\r\nif (sport)\r\nsnd_seq_port_unlock(sport);\r\nif (sender)\r\nsnd_seq_client_unlock(sender);\r\nif (result >= 0) {\r\nif (copy_to_user(arg, &subs, sizeof(subs)))\r\nreturn -EFAULT;\r\n}\r\nreturn result;\r\n}\r\nstatic int snd_seq_ioctl_query_subs(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nint result = -ENXIO;\r\nstruct snd_seq_client *cptr = NULL;\r\nstruct snd_seq_client_port *port = NULL;\r\nstruct snd_seq_query_subs subs;\r\nstruct snd_seq_port_subs_info *group;\r\nstruct list_head *p;\r\nint i;\r\nif (copy_from_user(&subs, arg, sizeof(subs)))\r\nreturn -EFAULT;\r\nif ((cptr = snd_seq_client_use_ptr(subs.root.client)) == NULL)\r\ngoto __end;\r\nif ((port = snd_seq_port_use_ptr(cptr, subs.root.port)) == NULL)\r\ngoto __end;\r\nswitch (subs.type) {\r\ncase SNDRV_SEQ_QUERY_SUBS_READ:\r\ngroup = &port->c_src;\r\nbreak;\r\ncase SNDRV_SEQ_QUERY_SUBS_WRITE:\r\ngroup = &port->c_dest;\r\nbreak;\r\ndefault:\r\ngoto __end;\r\n}\r\ndown_read(&group->list_mutex);\r\nsubs.num_subs = group->count;\r\ni = 0;\r\nresult = -ENOENT;\r\nlist_for_each(p, &group->list_head) {\r\nif (i++ == subs.index) {\r\nstruct snd_seq_subscribers *s;\r\nif (subs.type == SNDRV_SEQ_QUERY_SUBS_READ) {\r\ns = list_entry(p, struct snd_seq_subscribers, src_list);\r\nsubs.addr = s->info.dest;\r\n} else {\r\ns = list_entry(p, struct snd_seq_subscribers, dest_list);\r\nsubs.addr = s->info.sender;\r\n}\r\nsubs.flags = s->info.flags;\r\nsubs.queue = s->info.queue;\r\nresult = 0;\r\nbreak;\r\n}\r\n}\r\nup_read(&group->list_mutex);\r\n__end:\r\nif (port)\r\nsnd_seq_port_unlock(port);\r\nif (cptr)\r\nsnd_seq_client_unlock(cptr);\r\nif (result >= 0) {\r\nif (copy_to_user(arg, &subs, sizeof(subs)))\r\nreturn -EFAULT;\r\n}\r\nreturn result;\r\n}\r\nstatic int snd_seq_ioctl_query_next_client(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nstruct snd_seq_client *cptr = NULL;\r\nstruct snd_seq_client_info info;\r\nif (copy_from_user(&info, arg, sizeof(info)))\r\nreturn -EFAULT;\r\ninfo.client++;\r\nif (info.client < 0)\r\ninfo.client = 0;\r\nfor (; info.client < SNDRV_SEQ_MAX_CLIENTS; info.client++) {\r\ncptr = snd_seq_client_use_ptr(info.client);\r\nif (cptr)\r\nbreak;\r\n}\r\nif (cptr == NULL)\r\nreturn -ENOENT;\r\nget_client_info(cptr, &info);\r\nsnd_seq_client_unlock(cptr);\r\nif (copy_to_user(arg, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_seq_ioctl_query_next_port(struct snd_seq_client *client,\r\nvoid __user *arg)\r\n{\r\nstruct snd_seq_client *cptr;\r\nstruct snd_seq_client_port *port = NULL;\r\nstruct snd_seq_port_info info;\r\nif (copy_from_user(&info, arg, sizeof(info)))\r\nreturn -EFAULT;\r\ncptr = snd_seq_client_use_ptr(info.addr.client);\r\nif (cptr == NULL)\r\nreturn -ENXIO;\r\ninfo.addr.port++;\r\nport = snd_seq_port_query_nearest(cptr, &info);\r\nif (port == NULL) {\r\nsnd_seq_client_unlock(cptr);\r\nreturn -ENOENT;\r\n}\r\ninfo.addr = port->addr;\r\nsnd_seq_get_port_info(port, &info);\r\nsnd_seq_port_unlock(port);\r\nsnd_seq_client_unlock(cptr);\r\nif (copy_to_user(arg, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_seq_do_ioctl(struct snd_seq_client *client, unsigned int cmd,\r\nvoid __user *arg)\r\n{\r\nstruct seq_ioctl_table *p;\r\nswitch (cmd) {\r\ncase SNDRV_SEQ_IOCTL_PVERSION:\r\nreturn put_user(SNDRV_SEQ_VERSION, (int __user *)arg) ? -EFAULT : 0;\r\ncase SNDRV_SEQ_IOCTL_CLIENT_ID:\r\nreturn put_user(client->number, (int __user *)arg) ? -EFAULT : 0;\r\n}\r\nif (! arg)\r\nreturn -EFAULT;\r\nfor (p = ioctl_tables; p->cmd; p++) {\r\nif (p->cmd == cmd)\r\nreturn p->func(client, arg);\r\n}\r\nsnd_printd("seq unknown ioctl() 0x%x (type='%c', number=0x%02x)\n",\r\ncmd, _IOC_TYPE(cmd), _IOC_NR(cmd));\r\nreturn -ENOTTY;\r\n}\r\nstatic long snd_seq_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct snd_seq_client *client = file->private_data;\r\nif (snd_BUG_ON(!client))\r\nreturn -ENXIO;\r\nreturn snd_seq_do_ioctl(client, cmd, (void __user *) arg);\r\n}\r\nint snd_seq_create_kernel_client(struct snd_card *card, int client_index,\r\nconst char *name_fmt, ...)\r\n{\r\nstruct snd_seq_client *client;\r\nva_list args;\r\nif (snd_BUG_ON(in_interrupt()))\r\nreturn -EBUSY;\r\nif (card && client_index >= SNDRV_SEQ_CLIENTS_PER_CARD)\r\nreturn -EINVAL;\r\nif (card == NULL && client_index >= SNDRV_SEQ_GLOBAL_CLIENTS)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&register_mutex))\r\nreturn -ERESTARTSYS;\r\nif (card) {\r\nclient_index += SNDRV_SEQ_GLOBAL_CLIENTS\r\n+ card->number * SNDRV_SEQ_CLIENTS_PER_CARD;\r\nif (client_index >= SNDRV_SEQ_DYNAMIC_CLIENTS_BEGIN)\r\nclient_index = -1;\r\n}\r\nclient = seq_create_client1(client_index, 0);\r\nif (client == NULL) {\r\nmutex_unlock(&register_mutex);\r\nreturn -EBUSY;\r\n}\r\nusage_alloc(&client_usage, 1);\r\nclient->accept_input = 1;\r\nclient->accept_output = 1;\r\nva_start(args, name_fmt);\r\nvsnprintf(client->name, sizeof(client->name), name_fmt, args);\r\nva_end(args);\r\nclient->type = KERNEL_CLIENT;\r\nmutex_unlock(&register_mutex);\r\nsnd_seq_system_client_ev_client_start(client->number);\r\nreturn client->number;\r\n}\r\nint snd_seq_delete_kernel_client(int client)\r\n{\r\nstruct snd_seq_client *ptr;\r\nif (snd_BUG_ON(in_interrupt()))\r\nreturn -EBUSY;\r\nptr = clientptr(client);\r\nif (ptr == NULL)\r\nreturn -EINVAL;\r\nseq_free_client(ptr);\r\nkfree(ptr);\r\nreturn 0;\r\n}\r\nstatic int kernel_client_enqueue(int client, struct snd_seq_event *ev,\r\nstruct file *file, int blocking,\r\nint atomic, int hop)\r\n{\r\nstruct snd_seq_client *cptr;\r\nint result;\r\nif (snd_BUG_ON(!ev))\r\nreturn -EINVAL;\r\nif (ev->type == SNDRV_SEQ_EVENT_NONE)\r\nreturn 0;\r\nif (ev->type == SNDRV_SEQ_EVENT_KERNEL_ERROR)\r\nreturn -EINVAL;\r\nev->source.client = client;\r\nif (check_event_type_and_length(ev))\r\nreturn -EINVAL;\r\ncptr = snd_seq_client_use_ptr(client);\r\nif (cptr == NULL)\r\nreturn -EINVAL;\r\nif (! cptr->accept_output)\r\nresult = -EPERM;\r\nelse\r\nresult = snd_seq_client_enqueue_event(cptr, ev, file, blocking, atomic, hop);\r\nsnd_seq_client_unlock(cptr);\r\nreturn result;\r\n}\r\nint snd_seq_kernel_client_enqueue(int client, struct snd_seq_event * ev,\r\nint atomic, int hop)\r\n{\r\nreturn kernel_client_enqueue(client, ev, NULL, 0, atomic, hop);\r\n}\r\nint snd_seq_kernel_client_enqueue_blocking(int client, struct snd_seq_event * ev,\r\nstruct file *file,\r\nint atomic, int hop)\r\n{\r\nreturn kernel_client_enqueue(client, ev, file, 1, atomic, hop);\r\n}\r\nint snd_seq_kernel_client_dispatch(int client, struct snd_seq_event * ev,\r\nint atomic, int hop)\r\n{\r\nstruct snd_seq_client *cptr;\r\nint result;\r\nif (snd_BUG_ON(!ev))\r\nreturn -EINVAL;\r\nev->queue = SNDRV_SEQ_QUEUE_DIRECT;\r\nev->source.client = client;\r\nif (check_event_type_and_length(ev))\r\nreturn -EINVAL;\r\ncptr = snd_seq_client_use_ptr(client);\r\nif (cptr == NULL)\r\nreturn -EINVAL;\r\nif (!cptr->accept_output)\r\nresult = -EPERM;\r\nelse\r\nresult = snd_seq_deliver_event(cptr, ev, atomic, hop);\r\nsnd_seq_client_unlock(cptr);\r\nreturn result;\r\n}\r\nint snd_seq_kernel_client_ctl(int clientid, unsigned int cmd, void *arg)\r\n{\r\nstruct snd_seq_client *client;\r\nmm_segment_t fs;\r\nint result;\r\nclient = clientptr(clientid);\r\nif (client == NULL)\r\nreturn -ENXIO;\r\nfs = snd_enter_user();\r\nresult = snd_seq_do_ioctl(client, cmd, (void __force __user *)arg);\r\nsnd_leave_user(fs);\r\nreturn result;\r\n}\r\nint snd_seq_kernel_client_write_poll(int clientid, struct file *file, poll_table *wait)\r\n{\r\nstruct snd_seq_client *client;\r\nclient = clientptr(clientid);\r\nif (client == NULL)\r\nreturn -ENXIO;\r\nif (! snd_seq_write_pool_allocated(client))\r\nreturn 1;\r\nif (snd_seq_pool_poll_wait(client->pool, file, wait))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void snd_seq_info_dump_subscribers(struct snd_info_buffer *buffer,\r\nstruct snd_seq_port_subs_info *group,\r\nint is_src, char *msg)\r\n{\r\nstruct list_head *p;\r\nstruct snd_seq_subscribers *s;\r\nint count = 0;\r\ndown_read(&group->list_mutex);\r\nif (list_empty(&group->list_head)) {\r\nup_read(&group->list_mutex);\r\nreturn;\r\n}\r\nsnd_iprintf(buffer, msg);\r\nlist_for_each(p, &group->list_head) {\r\nif (is_src)\r\ns = list_entry(p, struct snd_seq_subscribers, src_list);\r\nelse\r\ns = list_entry(p, struct snd_seq_subscribers, dest_list);\r\nif (count++)\r\nsnd_iprintf(buffer, ", ");\r\nsnd_iprintf(buffer, "%d:%d",\r\nis_src ? s->info.dest.client : s->info.sender.client,\r\nis_src ? s->info.dest.port : s->info.sender.port);\r\nif (s->info.flags & SNDRV_SEQ_PORT_SUBS_TIMESTAMP)\r\nsnd_iprintf(buffer, "[%c:%d]", ((s->info.flags & SNDRV_SEQ_PORT_SUBS_TIME_REAL) ? 'r' : 't'), s->info.queue);\r\nif (group->exclusive)\r\nsnd_iprintf(buffer, "[ex]");\r\n}\r\nup_read(&group->list_mutex);\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nstatic void snd_seq_info_dump_ports(struct snd_info_buffer *buffer,\r\nstruct snd_seq_client *client)\r\n{\r\nstruct snd_seq_client_port *p;\r\nmutex_lock(&client->ports_mutex);\r\nlist_for_each_entry(p, &client->ports_list_head, list) {\r\nsnd_iprintf(buffer, " Port %3d : \"%s\" (%c%c%c%c)\n",\r\np->addr.port, p->name,\r\nFLAG_PERM_RD(p->capability),\r\nFLAG_PERM_WR(p->capability),\r\nFLAG_PERM_EX(p->capability),\r\nFLAG_PERM_DUPLEX(p->capability));\r\nsnd_seq_info_dump_subscribers(buffer, &p->c_src, 1, " Connecting To: ");\r\nsnd_seq_info_dump_subscribers(buffer, &p->c_dest, 0, " Connected From: ");\r\n}\r\nmutex_unlock(&client->ports_mutex);\r\n}\r\nvoid snd_seq_info_clients_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nint c;\r\nstruct snd_seq_client *client;\r\nsnd_iprintf(buffer, "Client info\n");\r\nsnd_iprintf(buffer, " cur clients : %d\n", client_usage.cur);\r\nsnd_iprintf(buffer, " peak clients : %d\n", client_usage.peak);\r\nsnd_iprintf(buffer, " max clients : %d\n", SNDRV_SEQ_MAX_CLIENTS);\r\nsnd_iprintf(buffer, "\n");\r\nfor (c = 0; c < SNDRV_SEQ_MAX_CLIENTS; c++) {\r\nclient = snd_seq_client_use_ptr(c);\r\nif (client == NULL)\r\ncontinue;\r\nif (client->type == NO_CLIENT) {\r\nsnd_seq_client_unlock(client);\r\ncontinue;\r\n}\r\nsnd_iprintf(buffer, "Client %3d : \"%s\" [%s]\n",\r\nc, client->name,\r\nclient->type == USER_CLIENT ? "User" : "Kernel");\r\nsnd_seq_info_dump_ports(buffer, client);\r\nif (snd_seq_write_pool_allocated(client)) {\r\nsnd_iprintf(buffer, " Output pool :\n");\r\nsnd_seq_info_pool(buffer, client->pool, " ");\r\n}\r\nif (client->type == USER_CLIENT && client->data.user.fifo &&\r\nclient->data.user.fifo->pool) {\r\nsnd_iprintf(buffer, " Input pool :\n");\r\nsnd_seq_info_pool(buffer, client->data.user.fifo->pool, " ");\r\n}\r\nsnd_seq_client_unlock(client);\r\n}\r\n}\r\nint __init snd_sequencer_device_init(void)\r\n{\r\nint err;\r\nif (mutex_lock_interruptible(&register_mutex))\r\nreturn -ERESTARTSYS;\r\nif ((err = snd_register_device(SNDRV_DEVICE_TYPE_SEQUENCER, NULL, 0,\r\n&snd_seq_f_ops, NULL, "seq")) < 0) {\r\nmutex_unlock(&register_mutex);\r\nreturn err;\r\n}\r\nmutex_unlock(&register_mutex);\r\nreturn 0;\r\n}\r\nvoid __exit snd_sequencer_device_done(void)\r\n{\r\nsnd_unregister_device(SNDRV_DEVICE_TYPE_SEQUENCER, NULL, 0);\r\n}
