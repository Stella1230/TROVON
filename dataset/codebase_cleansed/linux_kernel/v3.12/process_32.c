void arch_cpu_idle(void)\r\n{\r\nif (sparc_idle)\r\n(*sparc_idle)();\r\nlocal_irq_enable();\r\n}\r\nvoid machine_halt(void)\r\n{\r\nlocal_irq_enable();\r\nmdelay(8);\r\nlocal_irq_disable();\r\nprom_halt();\r\npanic("Halt failed!");\r\n}\r\nvoid machine_restart(char * cmd)\r\n{\r\nchar *p;\r\nlocal_irq_enable();\r\nmdelay(8);\r\nlocal_irq_disable();\r\np = strchr (reboot_command, '\n');\r\nif (p) *p = 0;\r\nif (cmd)\r\nprom_reboot(cmd);\r\nif (*reboot_command)\r\nprom_reboot(reboot_command);\r\nprom_feval ("reset");\r\npanic("Reboot failed!");\r\n}\r\nvoid machine_power_off(void)\r\n{\r\nif (auxio_power_register &&\r\n(strcmp(of_console_device->type, "serial") || scons_pwroff))\r\n*auxio_power_register |= AUXIO_POWER_OFF;\r\nmachine_halt();\r\n}\r\nvoid show_regs(struct pt_regs *r)\r\n{\r\nstruct reg_window32 *rw = (struct reg_window32 *) r->u_regs[14];\r\nshow_regs_print_info(KERN_DEFAULT);\r\nprintk("PSR: %08lx PC: %08lx NPC: %08lx Y: %08lx %s\n",\r\nr->psr, r->pc, r->npc, r->y, print_tainted());\r\nprintk("PC: <%pS>\n", (void *) r->pc);\r\nprintk("%%G: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",\r\nr->u_regs[0], r->u_regs[1], r->u_regs[2], r->u_regs[3],\r\nr->u_regs[4], r->u_regs[5], r->u_regs[6], r->u_regs[7]);\r\nprintk("%%O: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",\r\nr->u_regs[8], r->u_regs[9], r->u_regs[10], r->u_regs[11],\r\nr->u_regs[12], r->u_regs[13], r->u_regs[14], r->u_regs[15]);\r\nprintk("RPC: <%pS>\n", (void *) r->u_regs[15]);\r\nprintk("%%L: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",\r\nrw->locals[0], rw->locals[1], rw->locals[2], rw->locals[3],\r\nrw->locals[4], rw->locals[5], rw->locals[6], rw->locals[7]);\r\nprintk("%%I: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",\r\nrw->ins[0], rw->ins[1], rw->ins[2], rw->ins[3],\r\nrw->ins[4], rw->ins[5], rw->ins[6], rw->ins[7]);\r\n}\r\nvoid show_stack(struct task_struct *tsk, unsigned long *_ksp)\r\n{\r\nunsigned long pc, fp;\r\nunsigned long task_base;\r\nstruct reg_window32 *rw;\r\nint count = 0;\r\nif (!tsk)\r\ntsk = current;\r\nif (tsk == current && !_ksp)\r\n__asm__ __volatile__("mov %%fp, %0" : "=r" (_ksp));\r\ntask_base = (unsigned long) task_stack_page(tsk);\r\nfp = (unsigned long) _ksp;\r\ndo {\r\nif (fp < (task_base + sizeof(struct thread_info)) ||\r\nfp >= (task_base + (PAGE_SIZE << 1)))\r\nbreak;\r\nrw = (struct reg_window32 *) fp;\r\npc = rw->ins[7];\r\nprintk("[%08lx : ", pc);\r\nprintk("%pS ] ", (void *) pc);\r\nfp = rw->ins[6];\r\n} while (++count < 16);\r\nprintk("\n");\r\n}\r\nunsigned long thread_saved_pc(struct task_struct *tsk)\r\n{\r\nreturn task_thread_info(tsk)->kpc;\r\n}\r\nstatic inline struct sparc_stackf __user *\r\nclone_stackframe(struct sparc_stackf __user *dst,\r\nstruct sparc_stackf __user *src)\r\n{\r\nunsigned long size, fp;\r\nstruct sparc_stackf *tmp;\r\nstruct sparc_stackf __user *sp;\r\nif (get_user(tmp, &src->fp))\r\nreturn NULL;\r\nfp = (unsigned long) tmp;\r\nsize = (fp - ((unsigned long) src));\r\nfp = (unsigned long) dst;\r\nsp = (struct sparc_stackf __user *)(fp - size);\r\nif (__copy_user(sp, src, size))\r\nsp = NULL;\r\nelse if (put_user(fp, &sp->fp))\r\nsp = NULL;\r\nreturn sp;\r\n}\r\nasmlinkage int sparc_do_fork(unsigned long clone_flags,\r\nunsigned long stack_start,\r\nstruct pt_regs *regs,\r\nunsigned long stack_size)\r\n{\r\nunsigned long parent_tid_ptr, child_tid_ptr;\r\nunsigned long orig_i1 = regs->u_regs[UREG_I1];\r\nlong ret;\r\nparent_tid_ptr = regs->u_regs[UREG_I2];\r\nchild_tid_ptr = regs->u_regs[UREG_I4];\r\nret = do_fork(clone_flags, stack_start, stack_size,\r\n(int __user *) parent_tid_ptr,\r\n(int __user *) child_tid_ptr);\r\nif ((unsigned long)ret >= -ERESTART_RESTARTBLOCK)\r\nregs->u_regs[UREG_I1] = orig_i1;\r\nreturn ret;\r\n}\r\nint dump_fpu (struct pt_regs * regs, elf_fpregset_t * fpregs)\r\n{\r\nif (used_math()) {\r\nmemset(fpregs, 0, sizeof(*fpregs));\r\nfpregs->pr_q_entrysize = 8;\r\nreturn 1;\r\n}\r\n#ifdef CONFIG_SMP\r\nif (test_thread_flag(TIF_USEDFPU)) {\r\nput_psr(get_psr() | PSR_EF);\r\nfpsave(&current->thread.float_regs[0], &current->thread.fsr,\r\n&current->thread.fpqueue[0], &current->thread.fpqdepth);\r\nif (regs != NULL) {\r\nregs->psr &= ~(PSR_EF);\r\nclear_thread_flag(TIF_USEDFPU);\r\n}\r\n}\r\n#else\r\nif (current == last_task_used_math) {\r\nput_psr(get_psr() | PSR_EF);\r\nfpsave(&current->thread.float_regs[0], &current->thread.fsr,\r\n&current->thread.fpqueue[0], &current->thread.fpqdepth);\r\nif (regs != NULL) {\r\nregs->psr &= ~(PSR_EF);\r\nlast_task_used_math = NULL;\r\n}\r\n}\r\n#endif\r\nmemcpy(&fpregs->pr_fr.pr_regs[0],\r\n&current->thread.float_regs[0],\r\n(sizeof(unsigned long) * 32));\r\nfpregs->pr_fsr = current->thread.fsr;\r\nfpregs->pr_qcnt = current->thread.fpqdepth;\r\nfpregs->pr_q_entrysize = 8;\r\nfpregs->pr_en = 1;\r\nif(fpregs->pr_qcnt != 0) {\r\nmemcpy(&fpregs->pr_q[0],\r\n&current->thread.fpqueue[0],\r\nsizeof(struct fpq) * fpregs->pr_qcnt);\r\n}\r\nmemset(&fpregs->pr_q[fpregs->pr_qcnt], 0,\r\nsizeof(struct fpq) * (32 - fpregs->pr_qcnt));\r\nreturn 1;\r\n}\r\nunsigned long get_wchan(struct task_struct *task)\r\n{\r\nunsigned long pc, fp, bias = 0;\r\nunsigned long task_base = (unsigned long) task;\r\nunsigned long ret = 0;\r\nstruct reg_window32 *rw;\r\nint count = 0;\r\nif (!task || task == current ||\r\ntask->state == TASK_RUNNING)\r\ngoto out;\r\nfp = task_thread_info(task)->ksp + bias;\r\ndo {\r\nif (fp < (task_base + sizeof(struct thread_info)) ||\r\nfp >= (task_base + (2 * PAGE_SIZE)))\r\nbreak;\r\nrw = (struct reg_window32 *) fp;\r\npc = rw->ins[7];\r\nif (!in_sched_functions(pc)) {\r\nret = pc;\r\ngoto out;\r\n}\r\nfp = rw->ins[6] + bias;\r\n} while (++count < 16);\r\nout:\r\nreturn ret;\r\n}
