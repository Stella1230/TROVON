static int ipt_init_target(struct xt_entry_target *t, char *table, unsigned int hook)\r\n{\r\nstruct xt_tgchk_param par;\r\nstruct xt_target *target;\r\nint ret = 0;\r\ntarget = xt_request_find_target(AF_INET, t->u.user.name,\r\nt->u.user.revision);\r\nif (IS_ERR(target))\r\nreturn PTR_ERR(target);\r\nt->u.kernel.target = target;\r\npar.table = table;\r\npar.entryinfo = NULL;\r\npar.target = target;\r\npar.targinfo = t->data;\r\npar.hook_mask = hook;\r\npar.family = NFPROTO_IPV4;\r\nret = xt_check_target(&par, t->u.target_size - sizeof(*t), 0, false);\r\nif (ret < 0) {\r\nmodule_put(t->u.kernel.target->me);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ipt_destroy_target(struct xt_entry_target *t)\r\n{\r\nstruct xt_tgdtor_param par = {\r\n.target = t->u.kernel.target,\r\n.targinfo = t->data,\r\n};\r\nif (par.target->destroy != NULL)\r\npar.target->destroy(&par);\r\nmodule_put(par.target->me);\r\n}\r\nstatic int tcf_ipt_release(struct tcf_ipt *ipt, int bind)\r\n{\r\nint ret = 0;\r\nif (ipt) {\r\nif (bind)\r\nipt->tcf_bindcnt--;\r\nipt->tcf_refcnt--;\r\nif (ipt->tcf_bindcnt <= 0 && ipt->tcf_refcnt <= 0) {\r\nipt_destroy_target(ipt->tcfi_t);\r\nkfree(ipt->tcfi_tname);\r\nkfree(ipt->tcfi_t);\r\ntcf_hash_destroy(&ipt->common, &ipt_hash_info);\r\nret = ACT_P_DELETED;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int tcf_ipt_init(struct net *net, struct nlattr *nla, struct nlattr *est,\r\nstruct tc_action *a, int ovr, int bind)\r\n{\r\nstruct nlattr *tb[TCA_IPT_MAX + 1];\r\nstruct tcf_ipt *ipt;\r\nstruct tcf_common *pc;\r\nstruct xt_entry_target *td, *t;\r\nchar *tname;\r\nint ret = 0, err;\r\nu32 hook = 0;\r\nu32 index = 0;\r\nif (nla == NULL)\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(tb, TCA_IPT_MAX, nla, ipt_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[TCA_IPT_HOOK] == NULL)\r\nreturn -EINVAL;\r\nif (tb[TCA_IPT_TARG] == NULL)\r\nreturn -EINVAL;\r\ntd = (struct xt_entry_target *)nla_data(tb[TCA_IPT_TARG]);\r\nif (nla_len(tb[TCA_IPT_TARG]) < td->u.target_size)\r\nreturn -EINVAL;\r\nif (tb[TCA_IPT_INDEX] != NULL)\r\nindex = nla_get_u32(tb[TCA_IPT_INDEX]);\r\npc = tcf_hash_check(index, a, bind, &ipt_hash_info);\r\nif (!pc) {\r\npc = tcf_hash_create(index, est, a, sizeof(*ipt), bind,\r\n&ipt_idx_gen, &ipt_hash_info);\r\nif (IS_ERR(pc))\r\nreturn PTR_ERR(pc);\r\nret = ACT_P_CREATED;\r\n} else {\r\nif (!ovr) {\r\ntcf_ipt_release(to_ipt(pc), bind);\r\nreturn -EEXIST;\r\n}\r\n}\r\nipt = to_ipt(pc);\r\nhook = nla_get_u32(tb[TCA_IPT_HOOK]);\r\nerr = -ENOMEM;\r\ntname = kmalloc(IFNAMSIZ, GFP_KERNEL);\r\nif (unlikely(!tname))\r\ngoto err1;\r\nif (tb[TCA_IPT_TABLE] == NULL ||\r\nnla_strlcpy(tname, tb[TCA_IPT_TABLE], IFNAMSIZ) >= IFNAMSIZ)\r\nstrcpy(tname, "mangle");\r\nt = kmemdup(td, td->u.target_size, GFP_KERNEL);\r\nif (unlikely(!t))\r\ngoto err2;\r\nerr = ipt_init_target(t, tname, hook);\r\nif (err < 0)\r\ngoto err3;\r\nspin_lock_bh(&ipt->tcf_lock);\r\nif (ret != ACT_P_CREATED) {\r\nipt_destroy_target(ipt->tcfi_t);\r\nkfree(ipt->tcfi_tname);\r\nkfree(ipt->tcfi_t);\r\n}\r\nipt->tcfi_tname = tname;\r\nipt->tcfi_t = t;\r\nipt->tcfi_hook = hook;\r\nspin_unlock_bh(&ipt->tcf_lock);\r\nif (ret == ACT_P_CREATED)\r\ntcf_hash_insert(pc, &ipt_hash_info);\r\nreturn ret;\r\nerr3:\r\nkfree(t);\r\nerr2:\r\nkfree(tname);\r\nerr1:\r\nif (ret == ACT_P_CREATED) {\r\nif (est)\r\ngen_kill_estimator(&pc->tcfc_bstats,\r\n&pc->tcfc_rate_est);\r\nkfree_rcu(pc, tcfc_rcu);\r\n}\r\nreturn err;\r\n}\r\nstatic int tcf_ipt_cleanup(struct tc_action *a, int bind)\r\n{\r\nstruct tcf_ipt *ipt = a->priv;\r\nreturn tcf_ipt_release(ipt, bind);\r\n}\r\nstatic int tcf_ipt(struct sk_buff *skb, const struct tc_action *a,\r\nstruct tcf_result *res)\r\n{\r\nint ret = 0, result = 0;\r\nstruct tcf_ipt *ipt = a->priv;\r\nstruct xt_action_param par;\r\nif (skb_unclone(skb, GFP_ATOMIC))\r\nreturn TC_ACT_UNSPEC;\r\nspin_lock(&ipt->tcf_lock);\r\nipt->tcf_tm.lastuse = jiffies;\r\nbstats_update(&ipt->tcf_bstats, skb);\r\npar.in = skb->dev;\r\npar.out = NULL;\r\npar.hooknum = ipt->tcfi_hook;\r\npar.target = ipt->tcfi_t->u.kernel.target;\r\npar.targinfo = ipt->tcfi_t->data;\r\nret = par.target->target(skb, &par);\r\nswitch (ret) {\r\ncase NF_ACCEPT:\r\nresult = TC_ACT_OK;\r\nbreak;\r\ncase NF_DROP:\r\nresult = TC_ACT_SHOT;\r\nipt->tcf_qstats.drops++;\r\nbreak;\r\ncase XT_CONTINUE:\r\nresult = TC_ACT_PIPE;\r\nbreak;\r\ndefault:\r\nnet_notice_ratelimited("tc filter: Bogus netfilter code %d assume ACCEPT\n",\r\nret);\r\nresult = TC_POLICE_OK;\r\nbreak;\r\n}\r\nspin_unlock(&ipt->tcf_lock);\r\nreturn result;\r\n}\r\nstatic int tcf_ipt_dump(struct sk_buff *skb, struct tc_action *a, int bind, int ref)\r\n{\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct tcf_ipt *ipt = a->priv;\r\nstruct xt_entry_target *t;\r\nstruct tcf_t tm;\r\nstruct tc_cnt c;\r\nt = kmemdup(ipt->tcfi_t, ipt->tcfi_t->u.user.target_size, GFP_ATOMIC);\r\nif (unlikely(!t))\r\ngoto nla_put_failure;\r\nc.bindcnt = ipt->tcf_bindcnt - bind;\r\nc.refcnt = ipt->tcf_refcnt - ref;\r\nstrcpy(t->u.user.name, ipt->tcfi_t->u.kernel.target->name);\r\nif (nla_put(skb, TCA_IPT_TARG, ipt->tcfi_t->u.user.target_size, t) ||\r\nnla_put_u32(skb, TCA_IPT_INDEX, ipt->tcf_index) ||\r\nnla_put_u32(skb, TCA_IPT_HOOK, ipt->tcfi_hook) ||\r\nnla_put(skb, TCA_IPT_CNT, sizeof(struct tc_cnt), &c) ||\r\nnla_put_string(skb, TCA_IPT_TABLE, ipt->tcfi_tname))\r\ngoto nla_put_failure;\r\ntm.install = jiffies_to_clock_t(jiffies - ipt->tcf_tm.install);\r\ntm.lastuse = jiffies_to_clock_t(jiffies - ipt->tcf_tm.lastuse);\r\ntm.expires = jiffies_to_clock_t(ipt->tcf_tm.expires);\r\nif (nla_put(skb, TCA_IPT_TM, sizeof (tm), &tm))\r\ngoto nla_put_failure;\r\nkfree(t);\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nkfree(t);\r\nreturn -1;\r\n}\r\nstatic int __init ipt_init_module(void)\r\n{\r\nint ret1, ret2;\r\nret1 = tcf_register_action(&act_xt_ops);\r\nif (ret1 < 0)\r\nprintk("Failed to load xt action\n");\r\nret2 = tcf_register_action(&act_ipt_ops);\r\nif (ret2 < 0)\r\nprintk("Failed to load ipt action\n");\r\nif (ret1 < 0 && ret2 < 0)\r\nreturn ret1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void __exit ipt_cleanup_module(void)\r\n{\r\ntcf_unregister_action(&act_xt_ops);\r\ntcf_unregister_action(&act_ipt_ops);\r\n}
