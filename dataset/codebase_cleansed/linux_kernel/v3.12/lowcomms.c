static void cbuf_add(struct cbuf *cb, int n)\r\n{\r\ncb->len += n;\r\n}\r\nstatic int cbuf_data(struct cbuf *cb)\r\n{\r\nreturn ((cb->base + cb->len) & cb->mask);\r\n}\r\nstatic void cbuf_init(struct cbuf *cb, int size)\r\n{\r\ncb->base = cb->len = 0;\r\ncb->mask = size-1;\r\n}\r\nstatic void cbuf_eat(struct cbuf *cb, int n)\r\n{\r\ncb->len -= n;\r\ncb->base += n;\r\ncb->base &= cb->mask;\r\n}\r\nstatic bool cbuf_empty(struct cbuf *cb)\r\n{\r\nreturn cb->len == 0;\r\n}\r\nstatic inline int nodeid_hash(int nodeid)\r\n{\r\nreturn nodeid & (CONN_HASH_SIZE-1);\r\n}\r\nstatic struct connection *__find_con(int nodeid)\r\n{\r\nint r;\r\nstruct connection *con;\r\nr = nodeid_hash(nodeid);\r\nhlist_for_each_entry(con, &connection_hash[r], list) {\r\nif (con->nodeid == nodeid)\r\nreturn con;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct connection *__nodeid2con(int nodeid, gfp_t alloc)\r\n{\r\nstruct connection *con = NULL;\r\nint r;\r\ncon = __find_con(nodeid);\r\nif (con || !alloc)\r\nreturn con;\r\ncon = kmem_cache_zalloc(con_cache, alloc);\r\nif (!con)\r\nreturn NULL;\r\nr = nodeid_hash(nodeid);\r\nhlist_add_head(&con->list, &connection_hash[r]);\r\ncon->nodeid = nodeid;\r\nmutex_init(&con->sock_mutex);\r\nINIT_LIST_HEAD(&con->writequeue);\r\nspin_lock_init(&con->writequeue_lock);\r\nINIT_WORK(&con->swork, process_send_sockets);\r\nINIT_WORK(&con->rwork, process_recv_sockets);\r\nif (con->nodeid) {\r\nstruct connection *zerocon = __find_con(0);\r\ncon->connect_action = zerocon->connect_action;\r\nif (!con->rx_action)\r\ncon->rx_action = zerocon->rx_action;\r\n}\r\nreturn con;\r\n}\r\nstatic void foreach_conn(void (*conn_func)(struct connection *c))\r\n{\r\nint i;\r\nstruct hlist_node *n;\r\nstruct connection *con;\r\nfor (i = 0; i < CONN_HASH_SIZE; i++) {\r\nhlist_for_each_entry_safe(con, n, &connection_hash[i], list)\r\nconn_func(con);\r\n}\r\n}\r\nstatic struct connection *nodeid2con(int nodeid, gfp_t allocation)\r\n{\r\nstruct connection *con;\r\nmutex_lock(&connections_lock);\r\ncon = __nodeid2con(nodeid, allocation);\r\nmutex_unlock(&connections_lock);\r\nreturn con;\r\n}\r\nstatic struct connection *assoc2con(int assoc_id)\r\n{\r\nint i;\r\nstruct connection *con;\r\nmutex_lock(&connections_lock);\r\nfor (i = 0 ; i < CONN_HASH_SIZE; i++) {\r\nhlist_for_each_entry(con, &connection_hash[i], list) {\r\nif (con->sctp_assoc == assoc_id) {\r\nmutex_unlock(&connections_lock);\r\nreturn con;\r\n}\r\n}\r\n}\r\nmutex_unlock(&connections_lock);\r\nreturn NULL;\r\n}\r\nstatic struct dlm_node_addr *find_node_addr(int nodeid)\r\n{\r\nstruct dlm_node_addr *na;\r\nlist_for_each_entry(na, &dlm_node_addrs, list) {\r\nif (na->nodeid == nodeid)\r\nreturn na;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int addr_compare(struct sockaddr_storage *x, struct sockaddr_storage *y)\r\n{\r\nswitch (x->ss_family) {\r\ncase AF_INET: {\r\nstruct sockaddr_in *sinx = (struct sockaddr_in *)x;\r\nstruct sockaddr_in *siny = (struct sockaddr_in *)y;\r\nif (sinx->sin_addr.s_addr != siny->sin_addr.s_addr)\r\nreturn 0;\r\nif (sinx->sin_port != siny->sin_port)\r\nreturn 0;\r\nbreak;\r\n}\r\ncase AF_INET6: {\r\nstruct sockaddr_in6 *sinx = (struct sockaddr_in6 *)x;\r\nstruct sockaddr_in6 *siny = (struct sockaddr_in6 *)y;\r\nif (!ipv6_addr_equal(&sinx->sin6_addr, &siny->sin6_addr))\r\nreturn 0;\r\nif (sinx->sin6_port != siny->sin6_port)\r\nreturn 0;\r\nbreak;\r\n}\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int nodeid_to_addr(int nodeid, struct sockaddr_storage *sas_out,\r\nstruct sockaddr *sa_out, bool try_new_addr)\r\n{\r\nstruct sockaddr_storage sas;\r\nstruct dlm_node_addr *na;\r\nif (!dlm_local_count)\r\nreturn -1;\r\nspin_lock(&dlm_node_addrs_spin);\r\nna = find_node_addr(nodeid);\r\nif (na && na->addr_count) {\r\nif (try_new_addr) {\r\nna->curr_addr_index++;\r\nif (na->curr_addr_index == na->addr_count)\r\nna->curr_addr_index = 0;\r\n}\r\nmemcpy(&sas, na->addr[na->curr_addr_index ],\r\nsizeof(struct sockaddr_storage));\r\n}\r\nspin_unlock(&dlm_node_addrs_spin);\r\nif (!na)\r\nreturn -EEXIST;\r\nif (!na->addr_count)\r\nreturn -ENOENT;\r\nif (sas_out)\r\nmemcpy(sas_out, &sas, sizeof(struct sockaddr_storage));\r\nif (!sa_out)\r\nreturn 0;\r\nif (dlm_local_addr[0]->ss_family == AF_INET) {\r\nstruct sockaddr_in *in4 = (struct sockaddr_in *) &sas;\r\nstruct sockaddr_in *ret4 = (struct sockaddr_in *) sa_out;\r\nret4->sin_addr.s_addr = in4->sin_addr.s_addr;\r\n} else {\r\nstruct sockaddr_in6 *in6 = (struct sockaddr_in6 *) &sas;\r\nstruct sockaddr_in6 *ret6 = (struct sockaddr_in6 *) sa_out;\r\nret6->sin6_addr = in6->sin6_addr;\r\n}\r\nreturn 0;\r\n}\r\nstatic int addr_to_nodeid(struct sockaddr_storage *addr, int *nodeid)\r\n{\r\nstruct dlm_node_addr *na;\r\nint rv = -EEXIST;\r\nint addr_i;\r\nspin_lock(&dlm_node_addrs_spin);\r\nlist_for_each_entry(na, &dlm_node_addrs, list) {\r\nif (!na->addr_count)\r\ncontinue;\r\nfor (addr_i = 0; addr_i < na->addr_count; addr_i++) {\r\nif (addr_compare(na->addr[addr_i], addr)) {\r\n*nodeid = na->nodeid;\r\nrv = 0;\r\ngoto unlock;\r\n}\r\n}\r\n}\r\nunlock:\r\nspin_unlock(&dlm_node_addrs_spin);\r\nreturn rv;\r\n}\r\nint dlm_lowcomms_addr(int nodeid, struct sockaddr_storage *addr, int len)\r\n{\r\nstruct sockaddr_storage *new_addr;\r\nstruct dlm_node_addr *new_node, *na;\r\nnew_node = kzalloc(sizeof(struct dlm_node_addr), GFP_NOFS);\r\nif (!new_node)\r\nreturn -ENOMEM;\r\nnew_addr = kzalloc(sizeof(struct sockaddr_storage), GFP_NOFS);\r\nif (!new_addr) {\r\nkfree(new_node);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(new_addr, addr, len);\r\nspin_lock(&dlm_node_addrs_spin);\r\nna = find_node_addr(nodeid);\r\nif (!na) {\r\nnew_node->nodeid = nodeid;\r\nnew_node->addr[0] = new_addr;\r\nnew_node->addr_count = 1;\r\nlist_add(&new_node->list, &dlm_node_addrs);\r\nspin_unlock(&dlm_node_addrs_spin);\r\nreturn 0;\r\n}\r\nif (na->addr_count >= DLM_MAX_ADDR_COUNT) {\r\nspin_unlock(&dlm_node_addrs_spin);\r\nkfree(new_addr);\r\nkfree(new_node);\r\nreturn -ENOSPC;\r\n}\r\nna->addr[na->addr_count++] = new_addr;\r\nspin_unlock(&dlm_node_addrs_spin);\r\nkfree(new_node);\r\nreturn 0;\r\n}\r\nstatic void lowcomms_data_ready(struct sock *sk, int count_unused)\r\n{\r\nstruct connection *con = sock2con(sk);\r\nif (con && !test_and_set_bit(CF_READ_PENDING, &con->flags))\r\nqueue_work(recv_workqueue, &con->rwork);\r\n}\r\nstatic void lowcomms_write_space(struct sock *sk)\r\n{\r\nstruct connection *con = sock2con(sk);\r\nif (!con)\r\nreturn;\r\nclear_bit(SOCK_NOSPACE, &con->sock->flags);\r\nif (test_and_clear_bit(CF_APP_LIMITED, &con->flags)) {\r\ncon->sock->sk->sk_write_pending--;\r\nclear_bit(SOCK_ASYNC_NOSPACE, &con->sock->flags);\r\n}\r\nif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags))\r\nqueue_work(send_workqueue, &con->swork);\r\n}\r\nstatic inline void lowcomms_connect_sock(struct connection *con)\r\n{\r\nif (test_bit(CF_CLOSE, &con->flags))\r\nreturn;\r\nif (!test_and_set_bit(CF_CONNECT_PENDING, &con->flags))\r\nqueue_work(send_workqueue, &con->swork);\r\n}\r\nstatic void lowcomms_state_change(struct sock *sk)\r\n{\r\nif (sk->sk_state == TCP_ESTABLISHED)\r\nlowcomms_write_space(sk);\r\n}\r\nint dlm_lowcomms_connect_node(int nodeid)\r\n{\r\nstruct connection *con;\r\nif (dlm_config.ci_protocol != 0)\r\nreturn 0;\r\nif (nodeid == dlm_our_nodeid())\r\nreturn 0;\r\ncon = nodeid2con(nodeid, GFP_NOFS);\r\nif (!con)\r\nreturn -ENOMEM;\r\nlowcomms_connect_sock(con);\r\nreturn 0;\r\n}\r\nstatic void add_sock(struct socket *sock, struct connection *con)\r\n{\r\ncon->sock = sock;\r\ncon->sock->sk->sk_data_ready = lowcomms_data_ready;\r\ncon->sock->sk->sk_write_space = lowcomms_write_space;\r\ncon->sock->sk->sk_state_change = lowcomms_state_change;\r\ncon->sock->sk->sk_user_data = con;\r\ncon->sock->sk->sk_allocation = GFP_NOFS;\r\n}\r\nstatic void make_sockaddr(struct sockaddr_storage *saddr, uint16_t port,\r\nint *addr_len)\r\n{\r\nsaddr->ss_family = dlm_local_addr[0]->ss_family;\r\nif (saddr->ss_family == AF_INET) {\r\nstruct sockaddr_in *in4_addr = (struct sockaddr_in *)saddr;\r\nin4_addr->sin_port = cpu_to_be16(port);\r\n*addr_len = sizeof(struct sockaddr_in);\r\nmemset(&in4_addr->sin_zero, 0, sizeof(in4_addr->sin_zero));\r\n} else {\r\nstruct sockaddr_in6 *in6_addr = (struct sockaddr_in6 *)saddr;\r\nin6_addr->sin6_port = cpu_to_be16(port);\r\n*addr_len = sizeof(struct sockaddr_in6);\r\n}\r\nmemset((char *)saddr + *addr_len, 0, sizeof(struct sockaddr_storage) - *addr_len);\r\n}\r\nstatic void close_connection(struct connection *con, bool and_other)\r\n{\r\nmutex_lock(&con->sock_mutex);\r\nif (con->sock) {\r\nsock_release(con->sock);\r\ncon->sock = NULL;\r\n}\r\nif (con->othercon && and_other) {\r\nclose_connection(con->othercon, false);\r\n}\r\nif (con->rx_page) {\r\n__free_page(con->rx_page);\r\ncon->rx_page = NULL;\r\n}\r\ncon->retries = 0;\r\nmutex_unlock(&con->sock_mutex);\r\n}\r\nstatic void sctp_send_shutdown(sctp_assoc_t associd)\r\n{\r\nstatic char outcmsg[CMSG_SPACE(sizeof(struct sctp_sndrcvinfo))];\r\nstruct msghdr outmessage;\r\nstruct cmsghdr *cmsg;\r\nstruct sctp_sndrcvinfo *sinfo;\r\nint ret;\r\nstruct connection *con;\r\ncon = nodeid2con(0,0);\r\nBUG_ON(con == NULL);\r\noutmessage.msg_name = NULL;\r\noutmessage.msg_namelen = 0;\r\noutmessage.msg_control = outcmsg;\r\noutmessage.msg_controllen = sizeof(outcmsg);\r\noutmessage.msg_flags = MSG_EOR;\r\ncmsg = CMSG_FIRSTHDR(&outmessage);\r\ncmsg->cmsg_level = IPPROTO_SCTP;\r\ncmsg->cmsg_type = SCTP_SNDRCV;\r\ncmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndrcvinfo));\r\noutmessage.msg_controllen = cmsg->cmsg_len;\r\nsinfo = CMSG_DATA(cmsg);\r\nmemset(sinfo, 0x00, sizeof(struct sctp_sndrcvinfo));\r\nsinfo->sinfo_flags |= MSG_EOF;\r\nsinfo->sinfo_assoc_id = associd;\r\nret = kernel_sendmsg(con->sock, &outmessage, NULL, 0, 0);\r\nif (ret != 0)\r\nlog_print("send EOF to node failed: %d", ret);\r\n}\r\nstatic void sctp_init_failed_foreach(struct connection *con)\r\n{\r\nif (!con->nodeid || con->sctp_assoc)\r\nreturn;\r\nlog_print("Retrying SCTP association init for node %d\n", con->nodeid);\r\ncon->try_new_addr = true;\r\ncon->sctp_assoc = 0;\r\nif (test_and_clear_bit(CF_INIT_PENDING, &con->flags)) {\r\nif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags))\r\nqueue_work(send_workqueue, &con->swork);\r\n}\r\n}\r\nstatic void sctp_init_failed(void)\r\n{\r\nmutex_lock(&connections_lock);\r\nforeach_conn(sctp_init_failed_foreach);\r\nmutex_unlock(&connections_lock);\r\n}\r\nstatic void retry_failed_sctp_send(struct connection *recv_con,\r\nstruct sctp_send_failed *sn_send_failed,\r\nchar *buf)\r\n{\r\nint len = sn_send_failed->ssf_length - sizeof(struct sctp_send_failed);\r\nstruct dlm_mhandle *mh;\r\nstruct connection *con;\r\nchar *retry_buf;\r\nint nodeid = sn_send_failed->ssf_info.sinfo_ppid;\r\nlog_print("Retry sending %d bytes to node id %d", len, nodeid);\r\ncon = nodeid2con(nodeid, 0);\r\nif (!con) {\r\nlog_print("Could not look up con for nodeid %d\n",\r\nnodeid);\r\nreturn;\r\n}\r\nmh = dlm_lowcomms_get_buffer(nodeid, len, GFP_NOFS, &retry_buf);\r\nif (!mh) {\r\nlog_print("Could not allocate buf for retry.");\r\nreturn;\r\n}\r\nmemcpy(retry_buf, buf + sizeof(struct sctp_send_failed), len);\r\ndlm_lowcomms_commit_buffer(mh);\r\nif (con->sctp_assoc) {\r\nif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags))\r\nqueue_work(send_workqueue, &con->swork);\r\n} else\r\nsctp_init_failed_foreach(con);\r\n}\r\nstatic void process_sctp_notification(struct connection *con,\r\nstruct msghdr *msg, char *buf)\r\n{\r\nunion sctp_notification *sn = (union sctp_notification *)buf;\r\nswitch (sn->sn_header.sn_type) {\r\ncase SCTP_SEND_FAILED:\r\nretry_failed_sctp_send(con, &sn->sn_send_failed, buf);\r\nbreak;\r\ncase SCTP_ASSOC_CHANGE:\r\nswitch (sn->sn_assoc_change.sac_state) {\r\ncase SCTP_COMM_UP:\r\ncase SCTP_RESTART:\r\n{\r\nstruct sctp_prim prim;\r\nint nodeid;\r\nint prim_len, ret;\r\nint addr_len;\r\nstruct connection *new_con;\r\nif ((int)sn->sn_assoc_change.sac_assoc_id <= 0) {\r\nlog_print("COMM_UP for invalid assoc ID %d",\r\n(int)sn->sn_assoc_change.sac_assoc_id);\r\nsctp_init_failed();\r\nreturn;\r\n}\r\nmemset(&prim, 0, sizeof(struct sctp_prim));\r\nprim_len = sizeof(struct sctp_prim);\r\nprim.ssp_assoc_id = sn->sn_assoc_change.sac_assoc_id;\r\nret = kernel_getsockopt(con->sock,\r\nIPPROTO_SCTP,\r\nSCTP_PRIMARY_ADDR,\r\n(char*)&prim,\r\n&prim_len);\r\nif (ret < 0) {\r\nlog_print("getsockopt/sctp_primary_addr on "\r\n"new assoc %d failed : %d",\r\n(int)sn->sn_assoc_change.sac_assoc_id,\r\nret);\r\nnew_con = assoc2con(sn->sn_assoc_change.sac_assoc_id);\r\nif (new_con)\r\nclear_bit(CF_CONNECT_PENDING, &con->flags);\r\nreturn;\r\n}\r\nmake_sockaddr(&prim.ssp_addr, 0, &addr_len);\r\nif (addr_to_nodeid(&prim.ssp_addr, &nodeid)) {\r\nunsigned char *b=(unsigned char *)&prim.ssp_addr;\r\nlog_print("reject connect from unknown addr");\r\nprint_hex_dump_bytes("ss: ", DUMP_PREFIX_NONE,\r\nb, sizeof(struct sockaddr_storage));\r\nsctp_send_shutdown(prim.ssp_assoc_id);\r\nreturn;\r\n}\r\nnew_con = nodeid2con(nodeid, GFP_NOFS);\r\nif (!new_con)\r\nreturn;\r\nsctp_lock_sock(con->sock->sk);\r\nret = sctp_do_peeloff(con->sock->sk,\r\nsn->sn_assoc_change.sac_assoc_id,\r\n&new_con->sock);\r\nsctp_release_sock(con->sock->sk);\r\nif (ret < 0) {\r\nlog_print("Can't peel off a socket for "\r\n"connection %d to node %d: err=%d",\r\n(int)sn->sn_assoc_change.sac_assoc_id,\r\nnodeid, ret);\r\nreturn;\r\n}\r\nadd_sock(new_con->sock, new_con);\r\nlog_print("connecting to %d sctp association %d",\r\nnodeid, (int)sn->sn_assoc_change.sac_assoc_id);\r\nnew_con->sctp_assoc = sn->sn_assoc_change.sac_assoc_id;\r\nnew_con->try_new_addr = false;\r\nclear_bit(CF_CONNECT_PENDING, &new_con->flags);\r\nclear_bit(CF_INIT_PENDING, &new_con->flags);\r\nif (!test_and_set_bit(CF_WRITE_PENDING, &new_con->flags)) {\r\nqueue_work(send_workqueue, &new_con->swork);\r\n}\r\nif (!test_and_set_bit(CF_READ_PENDING, &new_con->flags))\r\nqueue_work(recv_workqueue, &new_con->rwork);\r\n}\r\nbreak;\r\ncase SCTP_COMM_LOST:\r\ncase SCTP_SHUTDOWN_COMP:\r\n{\r\ncon = assoc2con(sn->sn_assoc_change.sac_assoc_id);\r\nif (con) {\r\ncon->sctp_assoc = 0;\r\n}\r\n}\r\nbreak;\r\ncase SCTP_CANT_STR_ASSOC:\r\n{\r\nlog_print("Can't start SCTP association - retrying");\r\n}\r\nbreak;\r\ndefault:\r\nlog_print("unexpected SCTP assoc change id=%d state=%d",\r\n(int)sn->sn_assoc_change.sac_assoc_id,\r\nsn->sn_assoc_change.sac_state);\r\n}\r\ndefault:\r\n;\r\n}\r\n}\r\nstatic int receive_from_sock(struct connection *con)\r\n{\r\nint ret = 0;\r\nstruct msghdr msg = {};\r\nstruct kvec iov[2];\r\nunsigned len;\r\nint r;\r\nint call_again_soon = 0;\r\nint nvec;\r\nchar incmsg[CMSG_SPACE(sizeof(struct sctp_sndrcvinfo))];\r\nmutex_lock(&con->sock_mutex);\r\nif (con->sock == NULL) {\r\nret = -EAGAIN;\r\ngoto out_close;\r\n}\r\nif (con->rx_page == NULL) {\r\ncon->rx_page = alloc_page(GFP_ATOMIC);\r\nif (con->rx_page == NULL)\r\ngoto out_resched;\r\ncbuf_init(&con->cb, PAGE_CACHE_SIZE);\r\n}\r\nmemset(&incmsg, 0, sizeof(incmsg));\r\nmsg.msg_control = incmsg;\r\nmsg.msg_controllen = sizeof(incmsg);\r\niov[0].iov_len = con->cb.base - cbuf_data(&con->cb);\r\niov[0].iov_base = page_address(con->rx_page) + cbuf_data(&con->cb);\r\niov[1].iov_len = 0;\r\nnvec = 1;\r\nif (cbuf_data(&con->cb) >= con->cb.base) {\r\niov[0].iov_len = PAGE_CACHE_SIZE - cbuf_data(&con->cb);\r\niov[1].iov_len = con->cb.base;\r\niov[1].iov_base = page_address(con->rx_page);\r\nnvec = 2;\r\n}\r\nlen = iov[0].iov_len + iov[1].iov_len;\r\nr = ret = kernel_recvmsg(con->sock, &msg, iov, nvec, len,\r\nMSG_DONTWAIT | MSG_NOSIGNAL);\r\nif (ret <= 0)\r\ngoto out_close;\r\nif (msg.msg_flags & MSG_NOTIFICATION) {\r\nmsg.msg_control = incmsg;\r\nmsg.msg_controllen = sizeof(incmsg);\r\nprocess_sctp_notification(con, &msg,\r\npage_address(con->rx_page) + con->cb.base);\r\nmutex_unlock(&con->sock_mutex);\r\nreturn 0;\r\n}\r\nBUG_ON(con->nodeid == 0);\r\nif (ret == len)\r\ncall_again_soon = 1;\r\ncbuf_add(&con->cb, ret);\r\nret = dlm_process_incoming_buffer(con->nodeid,\r\npage_address(con->rx_page),\r\ncon->cb.base, con->cb.len,\r\nPAGE_CACHE_SIZE);\r\nif (ret == -EBADMSG) {\r\nlog_print("lowcomms: addr=%p, base=%u, len=%u, "\r\n"iov_len=%u, iov_base[0]=%p, read=%d",\r\npage_address(con->rx_page), con->cb.base, con->cb.len,\r\nlen, iov[0].iov_base, r);\r\n}\r\nif (ret < 0)\r\ngoto out_close;\r\ncbuf_eat(&con->cb, ret);\r\nif (cbuf_empty(&con->cb) && !call_again_soon) {\r\n__free_page(con->rx_page);\r\ncon->rx_page = NULL;\r\n}\r\nif (call_again_soon)\r\ngoto out_resched;\r\nmutex_unlock(&con->sock_mutex);\r\nreturn 0;\r\nout_resched:\r\nif (!test_and_set_bit(CF_READ_PENDING, &con->flags))\r\nqueue_work(recv_workqueue, &con->rwork);\r\nmutex_unlock(&con->sock_mutex);\r\nreturn -EAGAIN;\r\nout_close:\r\nmutex_unlock(&con->sock_mutex);\r\nif (ret != -EAGAIN) {\r\nclose_connection(con, false);\r\n}\r\nif (ret == 0)\r\nret = -EAGAIN;\r\nreturn ret;\r\n}\r\nstatic int tcp_accept_from_sock(struct connection *con)\r\n{\r\nint result;\r\nstruct sockaddr_storage peeraddr;\r\nstruct socket *newsock;\r\nint len;\r\nint nodeid;\r\nstruct connection *newcon;\r\nstruct connection *addcon;\r\nmutex_lock(&connections_lock);\r\nif (!dlm_allow_conn) {\r\nmutex_unlock(&connections_lock);\r\nreturn -1;\r\n}\r\nmutex_unlock(&connections_lock);\r\nmemset(&peeraddr, 0, sizeof(peeraddr));\r\nresult = sock_create_kern(dlm_local_addr[0]->ss_family, SOCK_STREAM,\r\nIPPROTO_TCP, &newsock);\r\nif (result < 0)\r\nreturn -ENOMEM;\r\nmutex_lock_nested(&con->sock_mutex, 0);\r\nresult = -ENOTCONN;\r\nif (con->sock == NULL)\r\ngoto accept_err;\r\nnewsock->type = con->sock->type;\r\nnewsock->ops = con->sock->ops;\r\nresult = con->sock->ops->accept(con->sock, newsock, O_NONBLOCK);\r\nif (result < 0)\r\ngoto accept_err;\r\nmemset(&peeraddr, 0, sizeof(peeraddr));\r\nif (newsock->ops->getname(newsock, (struct sockaddr *)&peeraddr,\r\n&len, 2)) {\r\nresult = -ECONNABORTED;\r\ngoto accept_err;\r\n}\r\nmake_sockaddr(&peeraddr, 0, &len);\r\nif (addr_to_nodeid(&peeraddr, &nodeid)) {\r\nunsigned char *b=(unsigned char *)&peeraddr;\r\nlog_print("connect from non cluster node");\r\nprint_hex_dump_bytes("ss: ", DUMP_PREFIX_NONE,\r\nb, sizeof(struct sockaddr_storage));\r\nsock_release(newsock);\r\nmutex_unlock(&con->sock_mutex);\r\nreturn -1;\r\n}\r\nlog_print("got connection from %d", nodeid);\r\nnewcon = nodeid2con(nodeid, GFP_NOFS);\r\nif (!newcon) {\r\nresult = -ENOMEM;\r\ngoto accept_err;\r\n}\r\nmutex_lock_nested(&newcon->sock_mutex, 1);\r\nif (newcon->sock) {\r\nstruct connection *othercon = newcon->othercon;\r\nif (!othercon) {\r\nothercon = kmem_cache_zalloc(con_cache, GFP_NOFS);\r\nif (!othercon) {\r\nlog_print("failed to allocate incoming socket");\r\nmutex_unlock(&newcon->sock_mutex);\r\nresult = -ENOMEM;\r\ngoto accept_err;\r\n}\r\nothercon->nodeid = nodeid;\r\nothercon->rx_action = receive_from_sock;\r\nmutex_init(&othercon->sock_mutex);\r\nINIT_WORK(&othercon->swork, process_send_sockets);\r\nINIT_WORK(&othercon->rwork, process_recv_sockets);\r\nset_bit(CF_IS_OTHERCON, &othercon->flags);\r\n}\r\nif (!othercon->sock) {\r\nnewcon->othercon = othercon;\r\nothercon->sock = newsock;\r\nnewsock->sk->sk_user_data = othercon;\r\nadd_sock(newsock, othercon);\r\naddcon = othercon;\r\n}\r\nelse {\r\nprintk("Extra connection from node %d attempted\n", nodeid);\r\nresult = -EAGAIN;\r\nmutex_unlock(&newcon->sock_mutex);\r\ngoto accept_err;\r\n}\r\n}\r\nelse {\r\nnewsock->sk->sk_user_data = newcon;\r\nnewcon->rx_action = receive_from_sock;\r\nadd_sock(newsock, newcon);\r\naddcon = newcon;\r\n}\r\nmutex_unlock(&newcon->sock_mutex);\r\nif (!test_and_set_bit(CF_READ_PENDING, &addcon->flags))\r\nqueue_work(recv_workqueue, &addcon->rwork);\r\nmutex_unlock(&con->sock_mutex);\r\nreturn 0;\r\naccept_err:\r\nmutex_unlock(&con->sock_mutex);\r\nsock_release(newsock);\r\nif (result != -EAGAIN)\r\nlog_print("error accepting connection from node: %d", result);\r\nreturn result;\r\n}\r\nstatic void free_entry(struct writequeue_entry *e)\r\n{\r\n__free_page(e->page);\r\nkfree(e);\r\n}\r\nstatic void writequeue_entry_complete(struct writequeue_entry *e, int completed)\r\n{\r\ne->offset += completed;\r\ne->len -= completed;\r\nif (e->len == 0 && e->users == 0) {\r\nlist_del(&e->list);\r\nfree_entry(e);\r\n}\r\n}\r\nstatic void sctp_init_assoc(struct connection *con)\r\n{\r\nstruct sockaddr_storage rem_addr;\r\nchar outcmsg[CMSG_SPACE(sizeof(struct sctp_sndrcvinfo))];\r\nstruct msghdr outmessage;\r\nstruct cmsghdr *cmsg;\r\nstruct sctp_sndrcvinfo *sinfo;\r\nstruct connection *base_con;\r\nstruct writequeue_entry *e;\r\nint len, offset;\r\nint ret;\r\nint addrlen;\r\nstruct kvec iov[1];\r\nmutex_lock(&con->sock_mutex);\r\nif (test_and_set_bit(CF_INIT_PENDING, &con->flags))\r\ngoto unlock;\r\nif (nodeid_to_addr(con->nodeid, NULL, (struct sockaddr *)&rem_addr,\r\ncon->try_new_addr)) {\r\nlog_print("no address for nodeid %d", con->nodeid);\r\ngoto unlock;\r\n}\r\nbase_con = nodeid2con(0, 0);\r\nBUG_ON(base_con == NULL);\r\nmake_sockaddr(&rem_addr, dlm_config.ci_tcp_port, &addrlen);\r\noutmessage.msg_name = &rem_addr;\r\noutmessage.msg_namelen = addrlen;\r\noutmessage.msg_control = outcmsg;\r\noutmessage.msg_controllen = sizeof(outcmsg);\r\noutmessage.msg_flags = MSG_EOR;\r\nspin_lock(&con->writequeue_lock);\r\nif (list_empty(&con->writequeue)) {\r\nspin_unlock(&con->writequeue_lock);\r\nlog_print("writequeue empty for nodeid %d", con->nodeid);\r\ngoto unlock;\r\n}\r\ne = list_first_entry(&con->writequeue, struct writequeue_entry, list);\r\nlen = e->len;\r\noffset = e->offset;\r\niov[0].iov_base = page_address(e->page)+offset;\r\niov[0].iov_len = len;\r\nspin_unlock(&con->writequeue_lock);\r\nif (rem_addr.ss_family == AF_INET) {\r\nstruct sockaddr_in *sin = (struct sockaddr_in *)&rem_addr;\r\nlog_print("Trying to connect to %pI4", &sin->sin_addr.s_addr);\r\n} else {\r\nstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&rem_addr;\r\nlog_print("Trying to connect to %pI6", &sin6->sin6_addr);\r\n}\r\ncmsg = CMSG_FIRSTHDR(&outmessage);\r\ncmsg->cmsg_level = IPPROTO_SCTP;\r\ncmsg->cmsg_type = SCTP_SNDRCV;\r\ncmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndrcvinfo));\r\nsinfo = CMSG_DATA(cmsg);\r\nmemset(sinfo, 0x00, sizeof(struct sctp_sndrcvinfo));\r\nsinfo->sinfo_ppid = cpu_to_le32(con->nodeid);\r\noutmessage.msg_controllen = cmsg->cmsg_len;\r\nsinfo->sinfo_flags |= SCTP_ADDR_OVER;\r\nret = kernel_sendmsg(base_con->sock, &outmessage, iov, 1, len);\r\nif (ret < 0) {\r\nlog_print("Send first packet to node %d failed: %d",\r\ncon->nodeid, ret);\r\nclear_bit(CF_CONNECT_PENDING, &con->flags);\r\nclear_bit(CF_INIT_PENDING, &con->flags);\r\n}\r\nelse {\r\nspin_lock(&con->writequeue_lock);\r\nwritequeue_entry_complete(e, ret);\r\nspin_unlock(&con->writequeue_lock);\r\n}\r\nunlock:\r\nmutex_unlock(&con->sock_mutex);\r\n}\r\nstatic void tcp_connect_to_sock(struct connection *con)\r\n{\r\nstruct sockaddr_storage saddr, src_addr;\r\nint addr_len;\r\nstruct socket *sock = NULL;\r\nint one = 1;\r\nint result;\r\nif (con->nodeid == 0) {\r\nlog_print("attempt to connect sock 0 foiled");\r\nreturn;\r\n}\r\nmutex_lock(&con->sock_mutex);\r\nif (con->retries++ > MAX_CONNECT_RETRIES)\r\ngoto out;\r\nif (con->sock)\r\ngoto out;\r\nresult = sock_create_kern(dlm_local_addr[0]->ss_family, SOCK_STREAM,\r\nIPPROTO_TCP, &sock);\r\nif (result < 0)\r\ngoto out_err;\r\nmemset(&saddr, 0, sizeof(saddr));\r\nresult = nodeid_to_addr(con->nodeid, &saddr, NULL, false);\r\nif (result < 0) {\r\nlog_print("no address for nodeid %d", con->nodeid);\r\ngoto out_err;\r\n}\r\nsock->sk->sk_user_data = con;\r\ncon->rx_action = receive_from_sock;\r\ncon->connect_action = tcp_connect_to_sock;\r\nadd_sock(sock, con);\r\nmemcpy(&src_addr, dlm_local_addr[0], sizeof(src_addr));\r\nmake_sockaddr(&src_addr, 0, &addr_len);\r\nresult = sock->ops->bind(sock, (struct sockaddr *) &src_addr,\r\naddr_len);\r\nif (result < 0) {\r\nlog_print("could not bind for connect: %d", result);\r\n}\r\nmake_sockaddr(&saddr, dlm_config.ci_tcp_port, &addr_len);\r\nlog_print("connecting to %d", con->nodeid);\r\nkernel_setsockopt(sock, SOL_TCP, TCP_NODELAY, (char *)&one,\r\nsizeof(one));\r\nresult = sock->ops->connect(sock, (struct sockaddr *)&saddr, addr_len,\r\nO_NONBLOCK);\r\nif (result == -EINPROGRESS)\r\nresult = 0;\r\nif (result == 0)\r\ngoto out;\r\nout_err:\r\nif (con->sock) {\r\nsock_release(con->sock);\r\ncon->sock = NULL;\r\n} else if (sock) {\r\nsock_release(sock);\r\n}\r\nif (result != -EHOSTUNREACH &&\r\nresult != -ENETUNREACH &&\r\nresult != -ENETDOWN &&\r\nresult != -EINVAL &&\r\nresult != -EPROTONOSUPPORT) {\r\nlog_print("connect %d try %d error %d", con->nodeid,\r\ncon->retries, result);\r\nmutex_unlock(&con->sock_mutex);\r\nmsleep(1000);\r\nlowcomms_connect_sock(con);\r\nreturn;\r\n}\r\nout:\r\nmutex_unlock(&con->sock_mutex);\r\nreturn;\r\n}\r\nstatic struct socket *tcp_create_listen_sock(struct connection *con,\r\nstruct sockaddr_storage *saddr)\r\n{\r\nstruct socket *sock = NULL;\r\nint result = 0;\r\nint one = 1;\r\nint addr_len;\r\nif (dlm_local_addr[0]->ss_family == AF_INET)\r\naddr_len = sizeof(struct sockaddr_in);\r\nelse\r\naddr_len = sizeof(struct sockaddr_in6);\r\nresult = sock_create_kern(dlm_local_addr[0]->ss_family, SOCK_STREAM,\r\nIPPROTO_TCP, &sock);\r\nif (result < 0) {\r\nlog_print("Can't create listening comms socket");\r\ngoto create_out;\r\n}\r\nkernel_setsockopt(sock, SOL_TCP, TCP_NODELAY, (char *)&one,\r\nsizeof(one));\r\nresult = kernel_setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,\r\n(char *)&one, sizeof(one));\r\nif (result < 0) {\r\nlog_print("Failed to set SO_REUSEADDR on socket: %d", result);\r\n}\r\ncon->rx_action = tcp_accept_from_sock;\r\ncon->connect_action = tcp_connect_to_sock;\r\nmake_sockaddr(saddr, dlm_config.ci_tcp_port, &addr_len);\r\nresult = sock->ops->bind(sock, (struct sockaddr *) saddr, addr_len);\r\nif (result < 0) {\r\nlog_print("Can't bind to port %d", dlm_config.ci_tcp_port);\r\nsock_release(sock);\r\nsock = NULL;\r\ncon->sock = NULL;\r\ngoto create_out;\r\n}\r\nresult = kernel_setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE,\r\n(char *)&one, sizeof(one));\r\nif (result < 0) {\r\nlog_print("Set keepalive failed: %d", result);\r\n}\r\nresult = sock->ops->listen(sock, 5);\r\nif (result < 0) {\r\nlog_print("Can't listen on port %d", dlm_config.ci_tcp_port);\r\nsock_release(sock);\r\nsock = NULL;\r\ngoto create_out;\r\n}\r\ncreate_out:\r\nreturn sock;\r\n}\r\nstatic void init_local(void)\r\n{\r\nstruct sockaddr_storage sas, *addr;\r\nint i;\r\ndlm_local_count = 0;\r\nfor (i = 0; i < DLM_MAX_ADDR_COUNT; i++) {\r\nif (dlm_our_addr(&sas, i))\r\nbreak;\r\naddr = kmalloc(sizeof(*addr), GFP_NOFS);\r\nif (!addr)\r\nbreak;\r\nmemcpy(addr, &sas, sizeof(*addr));\r\ndlm_local_addr[dlm_local_count++] = addr;\r\n}\r\n}\r\nstatic int add_sctp_bind_addr(struct connection *sctp_con,\r\nstruct sockaddr_storage *addr,\r\nint addr_len, int num)\r\n{\r\nint result = 0;\r\nif (num == 1)\r\nresult = kernel_bind(sctp_con->sock,\r\n(struct sockaddr *) addr,\r\naddr_len);\r\nelse\r\nresult = kernel_setsockopt(sctp_con->sock, SOL_SCTP,\r\nSCTP_SOCKOPT_BINDX_ADD,\r\n(char *)addr, addr_len);\r\nif (result < 0)\r\nlog_print("Can't bind to port %d addr number %d",\r\ndlm_config.ci_tcp_port, num);\r\nreturn result;\r\n}\r\nstatic int sctp_listen_for_all(void)\r\n{\r\nstruct socket *sock = NULL;\r\nstruct sockaddr_storage localaddr;\r\nstruct sctp_event_subscribe subscribe;\r\nint result = -EINVAL, num = 1, i, addr_len;\r\nstruct connection *con = nodeid2con(0, GFP_NOFS);\r\nint bufsize = NEEDED_RMEM;\r\nint one = 1;\r\nif (!con)\r\nreturn -ENOMEM;\r\nlog_print("Using SCTP for communications");\r\nresult = sock_create_kern(dlm_local_addr[0]->ss_family, SOCK_SEQPACKET,\r\nIPPROTO_SCTP, &sock);\r\nif (result < 0) {\r\nlog_print("Can't create comms socket, check SCTP is loaded");\r\ngoto out;\r\n}\r\nmemset(&subscribe, 0, sizeof(subscribe));\r\nsubscribe.sctp_data_io_event = 1;\r\nsubscribe.sctp_association_event = 1;\r\nsubscribe.sctp_send_failure_event = 1;\r\nsubscribe.sctp_shutdown_event = 1;\r\nsubscribe.sctp_partial_delivery_event = 1;\r\nresult = kernel_setsockopt(sock, SOL_SOCKET, SO_RCVBUFFORCE,\r\n(char *)&bufsize, sizeof(bufsize));\r\nif (result)\r\nlog_print("Error increasing buffer space on socket %d", result);\r\nresult = kernel_setsockopt(sock, SOL_SCTP, SCTP_EVENTS,\r\n(char *)&subscribe, sizeof(subscribe));\r\nif (result < 0) {\r\nlog_print("Failed to set SCTP_EVENTS on socket: result=%d",\r\nresult);\r\ngoto create_delsock;\r\n}\r\nresult = kernel_setsockopt(sock, SOL_SCTP, SCTP_NODELAY, (char *)&one,\r\nsizeof(one));\r\nif (result < 0)\r\nlog_print("Could not set SCTP NODELAY error %d\n", result);\r\nsock->sk->sk_user_data = con;\r\ncon->sock = sock;\r\ncon->sock->sk->sk_data_ready = lowcomms_data_ready;\r\ncon->rx_action = receive_from_sock;\r\ncon->connect_action = sctp_init_assoc;\r\nfor (i = 0; i < dlm_local_count; i++) {\r\nmemcpy(&localaddr, dlm_local_addr[i], sizeof(localaddr));\r\nmake_sockaddr(&localaddr, dlm_config.ci_tcp_port, &addr_len);\r\nresult = add_sctp_bind_addr(con, &localaddr, addr_len, num);\r\nif (result)\r\ngoto create_delsock;\r\n++num;\r\n}\r\nresult = sock->ops->listen(sock, 5);\r\nif (result < 0) {\r\nlog_print("Can't set socket listening");\r\ngoto create_delsock;\r\n}\r\nreturn 0;\r\ncreate_delsock:\r\nsock_release(sock);\r\ncon->sock = NULL;\r\nout:\r\nreturn result;\r\n}\r\nstatic int tcp_listen_for_all(void)\r\n{\r\nstruct socket *sock = NULL;\r\nstruct connection *con = nodeid2con(0, GFP_NOFS);\r\nint result = -EINVAL;\r\nif (!con)\r\nreturn -ENOMEM;\r\nif (dlm_local_addr[1] != NULL) {\r\nlog_print("TCP protocol can't handle multi-homed hosts, "\r\n"try SCTP");\r\nreturn -EINVAL;\r\n}\r\nlog_print("Using TCP for communications");\r\nsock = tcp_create_listen_sock(con, dlm_local_addr[0]);\r\nif (sock) {\r\nadd_sock(sock, con);\r\nresult = 0;\r\n}\r\nelse {\r\nresult = -EADDRINUSE;\r\n}\r\nreturn result;\r\n}\r\nstatic struct writequeue_entry *new_writequeue_entry(struct connection *con,\r\ngfp_t allocation)\r\n{\r\nstruct writequeue_entry *entry;\r\nentry = kmalloc(sizeof(struct writequeue_entry), allocation);\r\nif (!entry)\r\nreturn NULL;\r\nentry->page = alloc_page(allocation);\r\nif (!entry->page) {\r\nkfree(entry);\r\nreturn NULL;\r\n}\r\nentry->offset = 0;\r\nentry->len = 0;\r\nentry->end = 0;\r\nentry->users = 0;\r\nentry->con = con;\r\nreturn entry;\r\n}\r\nvoid *dlm_lowcomms_get_buffer(int nodeid, int len, gfp_t allocation, char **ppc)\r\n{\r\nstruct connection *con;\r\nstruct writequeue_entry *e;\r\nint offset = 0;\r\ncon = nodeid2con(nodeid, allocation);\r\nif (!con)\r\nreturn NULL;\r\nspin_lock(&con->writequeue_lock);\r\ne = list_entry(con->writequeue.prev, struct writequeue_entry, list);\r\nif ((&e->list == &con->writequeue) ||\r\n(PAGE_CACHE_SIZE - e->end < len)) {\r\ne = NULL;\r\n} else {\r\noffset = e->end;\r\ne->end += len;\r\ne->users++;\r\n}\r\nspin_unlock(&con->writequeue_lock);\r\nif (e) {\r\ngot_one:\r\n*ppc = page_address(e->page) + offset;\r\nreturn e;\r\n}\r\ne = new_writequeue_entry(con, allocation);\r\nif (e) {\r\nspin_lock(&con->writequeue_lock);\r\noffset = e->end;\r\ne->end += len;\r\ne->users++;\r\nlist_add_tail(&e->list, &con->writequeue);\r\nspin_unlock(&con->writequeue_lock);\r\ngoto got_one;\r\n}\r\nreturn NULL;\r\n}\r\nvoid dlm_lowcomms_commit_buffer(void *mh)\r\n{\r\nstruct writequeue_entry *e = (struct writequeue_entry *)mh;\r\nstruct connection *con = e->con;\r\nint users;\r\nspin_lock(&con->writequeue_lock);\r\nusers = --e->users;\r\nif (users)\r\ngoto out;\r\ne->len = e->end - e->offset;\r\nspin_unlock(&con->writequeue_lock);\r\nif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags)) {\r\nqueue_work(send_workqueue, &con->swork);\r\n}\r\nreturn;\r\nout:\r\nspin_unlock(&con->writequeue_lock);\r\nreturn;\r\n}\r\nstatic void send_to_sock(struct connection *con)\r\n{\r\nint ret = 0;\r\nconst int msg_flags = MSG_DONTWAIT | MSG_NOSIGNAL;\r\nstruct writequeue_entry *e;\r\nint len, offset;\r\nint count = 0;\r\nmutex_lock(&con->sock_mutex);\r\nif (con->sock == NULL)\r\ngoto out_connect;\r\nspin_lock(&con->writequeue_lock);\r\nfor (;;) {\r\ne = list_entry(con->writequeue.next, struct writequeue_entry,\r\nlist);\r\nif ((struct list_head *) e == &con->writequeue)\r\nbreak;\r\nlen = e->len;\r\noffset = e->offset;\r\nBUG_ON(len == 0 && e->users == 0);\r\nspin_unlock(&con->writequeue_lock);\r\nret = 0;\r\nif (len) {\r\nret = kernel_sendpage(con->sock, e->page, offset, len,\r\nmsg_flags);\r\nif (ret == -EAGAIN || ret == 0) {\r\nif (ret == -EAGAIN &&\r\ntest_bit(SOCK_ASYNC_NOSPACE, &con->sock->flags) &&\r\n!test_and_set_bit(CF_APP_LIMITED, &con->flags)) {\r\nset_bit(SOCK_NOSPACE, &con->sock->flags);\r\ncon->sock->sk->sk_write_pending++;\r\n}\r\ncond_resched();\r\ngoto out;\r\n} else if (ret < 0)\r\ngoto send_error;\r\n}\r\nif (++count >= MAX_SEND_MSG_COUNT) {\r\ncond_resched();\r\ncount = 0;\r\n}\r\nspin_lock(&con->writequeue_lock);\r\nwritequeue_entry_complete(e, ret);\r\n}\r\nspin_unlock(&con->writequeue_lock);\r\nout:\r\nmutex_unlock(&con->sock_mutex);\r\nreturn;\r\nsend_error:\r\nmutex_unlock(&con->sock_mutex);\r\nclose_connection(con, false);\r\nlowcomms_connect_sock(con);\r\nreturn;\r\nout_connect:\r\nmutex_unlock(&con->sock_mutex);\r\nif (!test_bit(CF_INIT_PENDING, &con->flags))\r\nlowcomms_connect_sock(con);\r\n}\r\nstatic void clean_one_writequeue(struct connection *con)\r\n{\r\nstruct writequeue_entry *e, *safe;\r\nspin_lock(&con->writequeue_lock);\r\nlist_for_each_entry_safe(e, safe, &con->writequeue, list) {\r\nlist_del(&e->list);\r\nfree_entry(e);\r\n}\r\nspin_unlock(&con->writequeue_lock);\r\n}\r\nint dlm_lowcomms_close(int nodeid)\r\n{\r\nstruct connection *con;\r\nstruct dlm_node_addr *na;\r\nlog_print("closing connection to node %d", nodeid);\r\ncon = nodeid2con(nodeid, 0);\r\nif (con) {\r\nclear_bit(CF_CONNECT_PENDING, &con->flags);\r\nclear_bit(CF_WRITE_PENDING, &con->flags);\r\nset_bit(CF_CLOSE, &con->flags);\r\nif (cancel_work_sync(&con->swork))\r\nlog_print("canceled swork for node %d", nodeid);\r\nif (cancel_work_sync(&con->rwork))\r\nlog_print("canceled rwork for node %d", nodeid);\r\nclean_one_writequeue(con);\r\nclose_connection(con, true);\r\n}\r\nspin_lock(&dlm_node_addrs_spin);\r\nna = find_node_addr(nodeid);\r\nif (na) {\r\nlist_del(&na->list);\r\nwhile (na->addr_count--)\r\nkfree(na->addr[na->addr_count]);\r\nkfree(na);\r\n}\r\nspin_unlock(&dlm_node_addrs_spin);\r\nreturn 0;\r\n}\r\nstatic void process_recv_sockets(struct work_struct *work)\r\n{\r\nstruct connection *con = container_of(work, struct connection, rwork);\r\nint err;\r\nclear_bit(CF_READ_PENDING, &con->flags);\r\ndo {\r\nerr = con->rx_action(con);\r\n} while (!err);\r\n}\r\nstatic void process_send_sockets(struct work_struct *work)\r\n{\r\nstruct connection *con = container_of(work, struct connection, swork);\r\nif (test_and_clear_bit(CF_CONNECT_PENDING, &con->flags)) {\r\ncon->connect_action(con);\r\nset_bit(CF_WRITE_PENDING, &con->flags);\r\n}\r\nif (test_and_clear_bit(CF_WRITE_PENDING, &con->flags))\r\nsend_to_sock(con);\r\n}\r\nstatic void clean_writequeues(void)\r\n{\r\nforeach_conn(clean_one_writequeue);\r\n}\r\nstatic void work_stop(void)\r\n{\r\ndestroy_workqueue(recv_workqueue);\r\ndestroy_workqueue(send_workqueue);\r\n}\r\nstatic int work_start(void)\r\n{\r\nrecv_workqueue = alloc_workqueue("dlm_recv",\r\nWQ_UNBOUND | WQ_MEM_RECLAIM, 1);\r\nif (!recv_workqueue) {\r\nlog_print("can't start dlm_recv");\r\nreturn -ENOMEM;\r\n}\r\nsend_workqueue = alloc_workqueue("dlm_send",\r\nWQ_UNBOUND | WQ_MEM_RECLAIM, 1);\r\nif (!send_workqueue) {\r\nlog_print("can't start dlm_send");\r\ndestroy_workqueue(recv_workqueue);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void stop_conn(struct connection *con)\r\n{\r\ncon->flags |= 0x0F;\r\nif (con->sock && con->sock->sk)\r\ncon->sock->sk->sk_user_data = NULL;\r\n}\r\nstatic void free_conn(struct connection *con)\r\n{\r\nclose_connection(con, true);\r\nif (con->othercon)\r\nkmem_cache_free(con_cache, con->othercon);\r\nhlist_del(&con->list);\r\nkmem_cache_free(con_cache, con);\r\n}\r\nvoid dlm_lowcomms_stop(void)\r\n{\r\nmutex_lock(&connections_lock);\r\ndlm_allow_conn = 0;\r\nforeach_conn(stop_conn);\r\nmutex_unlock(&connections_lock);\r\nwork_stop();\r\nmutex_lock(&connections_lock);\r\nclean_writequeues();\r\nforeach_conn(free_conn);\r\nmutex_unlock(&connections_lock);\r\nkmem_cache_destroy(con_cache);\r\n}\r\nint dlm_lowcomms_start(void)\r\n{\r\nint error = -EINVAL;\r\nstruct connection *con;\r\nint i;\r\nfor (i = 0; i < CONN_HASH_SIZE; i++)\r\nINIT_HLIST_HEAD(&connection_hash[i]);\r\ninit_local();\r\nif (!dlm_local_count) {\r\nerror = -ENOTCONN;\r\nlog_print("no local IP address has been set");\r\ngoto fail;\r\n}\r\nerror = -ENOMEM;\r\ncon_cache = kmem_cache_create("dlm_conn", sizeof(struct connection),\r\n__alignof__(struct connection), 0,\r\nNULL);\r\nif (!con_cache)\r\ngoto fail;\r\nerror = work_start();\r\nif (error)\r\ngoto fail_destroy;\r\ndlm_allow_conn = 1;\r\nif (dlm_config.ci_protocol == 0)\r\nerror = tcp_listen_for_all();\r\nelse\r\nerror = sctp_listen_for_all();\r\nif (error)\r\ngoto fail_unlisten;\r\nreturn 0;\r\nfail_unlisten:\r\ndlm_allow_conn = 0;\r\ncon = nodeid2con(0,0);\r\nif (con) {\r\nclose_connection(con, false);\r\nkmem_cache_free(con_cache, con);\r\n}\r\nfail_destroy:\r\nkmem_cache_destroy(con_cache);\r\nfail:\r\nreturn error;\r\n}\r\nvoid dlm_lowcomms_exit(void)\r\n{\r\nstruct dlm_node_addr *na, *safe;\r\nspin_lock(&dlm_node_addrs_spin);\r\nlist_for_each_entry_safe(na, safe, &dlm_node_addrs, list) {\r\nlist_del(&na->list);\r\nwhile (na->addr_count--)\r\nkfree(na->addr[na->addr_count]);\r\nkfree(na);\r\n}\r\nspin_unlock(&dlm_node_addrs_spin);\r\n}
