static void usb_mixer_elem_free(struct snd_kcontrol *kctl)\r\n{\r\nkfree(kctl->private_data);\r\nkctl->private_data = NULL;\r\n}\r\nstatic int snd_create_std_mono_ctl_offset(struct usb_mixer_interface *mixer,\r\nunsigned int unitid,\r\nunsigned int control,\r\nunsigned int cmask,\r\nint val_type,\r\nunsigned int idx_off,\r\nconst char *name,\r\nsnd_kcontrol_tlv_rw_t *tlv_callback)\r\n{\r\nint err;\r\nstruct usb_mixer_elem_info *cval;\r\nstruct snd_kcontrol *kctl;\r\ncval = kzalloc(sizeof(*cval), GFP_KERNEL);\r\nif (!cval)\r\nreturn -ENOMEM;\r\ncval->id = unitid;\r\ncval->mixer = mixer;\r\ncval->val_type = val_type;\r\ncval->channels = 1;\r\ncval->control = control;\r\ncval->cmask = cmask;\r\ncval->idx_off = idx_off;\r\ncval->min = 0;\r\ncval->max = 1;\r\ncval->res = 0;\r\ncval->dBmin = 0;\r\ncval->dBmax = 0;\r\nkctl = snd_ctl_new1(snd_usb_feature_unit_ctl, cval);\r\nif (!kctl) {\r\nkfree(cval);\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(kctl->id.name, sizeof(kctl->id.name), name);\r\nkctl->private_free = usb_mixer_elem_free;\r\nif (tlv_callback) {\r\nkctl->tlv.c = tlv_callback;\r\nkctl->vd[0].access |=\r\nSNDRV_CTL_ELEM_ACCESS_TLV_READ |\r\nSNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\r\n}\r\nerr = snd_usb_mixer_add_control(mixer, kctl);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_create_std_mono_ctl(struct usb_mixer_interface *mixer,\r\nunsigned int unitid,\r\nunsigned int control,\r\nunsigned int cmask,\r\nint val_type,\r\nconst char *name,\r\nsnd_kcontrol_tlv_rw_t *tlv_callback)\r\n{\r\nreturn snd_create_std_mono_ctl_offset(mixer, unitid, control, cmask,\r\nval_type, 0 , name, tlv_callback);\r\n}\r\nstatic int snd_create_std_mono_table(struct usb_mixer_interface *mixer,\r\nstruct std_mono_table *t)\r\n{\r\nint err;\r\nwhile (t->name != NULL) {\r\nerr = snd_create_std_mono_ctl(mixer, t->unitid, t->control,\r\nt->cmask, t->val_type, t->name, t->tlv_callback);\r\nif (err < 0)\r\nreturn err;\r\nt++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_usb_soundblaster_remote_complete(struct urb *urb)\r\n{\r\nstruct usb_mixer_interface *mixer = urb->context;\r\nconst struct rc_config *rc = mixer->rc_cfg;\r\nu32 code;\r\nif (urb->status < 0 || urb->actual_length < rc->min_packet_length)\r\nreturn;\r\ncode = mixer->rc_buffer[rc->offset];\r\nif (rc->length == 2)\r\ncode |= mixer->rc_buffer[rc->offset + 1] << 8;\r\nif (code == rc->mute_code)\r\nsnd_usb_mixer_notify_id(mixer, rc->mute_mixer_id);\r\nmixer->rc_code = code;\r\nwmb();\r\nwake_up(&mixer->rc_waitq);\r\n}\r\nstatic long snd_usb_sbrc_hwdep_read(struct snd_hwdep *hw, char __user *buf,\r\nlong count, loff_t *offset)\r\n{\r\nstruct usb_mixer_interface *mixer = hw->private_data;\r\nint err;\r\nu32 rc_code;\r\nif (count != 1 && count != 4)\r\nreturn -EINVAL;\r\nerr = wait_event_interruptible(mixer->rc_waitq,\r\n(rc_code = xchg(&mixer->rc_code, 0)) != 0);\r\nif (err == 0) {\r\nif (count == 1)\r\nerr = put_user(rc_code, buf);\r\nelse\r\nerr = put_user(rc_code, (u32 __user *)buf);\r\n}\r\nreturn err < 0 ? err : count;\r\n}\r\nstatic unsigned int snd_usb_sbrc_hwdep_poll(struct snd_hwdep *hw, struct file *file,\r\npoll_table *wait)\r\n{\r\nstruct usb_mixer_interface *mixer = hw->private_data;\r\npoll_wait(file, &mixer->rc_waitq, wait);\r\nreturn mixer->rc_code ? POLLIN | POLLRDNORM : 0;\r\n}\r\nstatic int snd_usb_soundblaster_remote_init(struct usb_mixer_interface *mixer)\r\n{\r\nstruct snd_hwdep *hwdep;\r\nint err, len, i;\r\nfor (i = 0; i < ARRAY_SIZE(rc_configs); ++i)\r\nif (rc_configs[i].usb_id == mixer->chip->usb_id)\r\nbreak;\r\nif (i >= ARRAY_SIZE(rc_configs))\r\nreturn 0;\r\nmixer->rc_cfg = &rc_configs[i];\r\nlen = mixer->rc_cfg->packet_length;\r\ninit_waitqueue_head(&mixer->rc_waitq);\r\nerr = snd_hwdep_new(mixer->chip->card, "SB remote control", 0, &hwdep);\r\nif (err < 0)\r\nreturn err;\r\nsnprintf(hwdep->name, sizeof(hwdep->name),\r\n"%s remote control", mixer->chip->card->shortname);\r\nhwdep->iface = SNDRV_HWDEP_IFACE_SB_RC;\r\nhwdep->private_data = mixer;\r\nhwdep->ops.read = snd_usb_sbrc_hwdep_read;\r\nhwdep->ops.poll = snd_usb_sbrc_hwdep_poll;\r\nhwdep->exclusive = 1;\r\nmixer->rc_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!mixer->rc_urb)\r\nreturn -ENOMEM;\r\nmixer->rc_setup_packet = kmalloc(sizeof(*mixer->rc_setup_packet), GFP_KERNEL);\r\nif (!mixer->rc_setup_packet) {\r\nusb_free_urb(mixer->rc_urb);\r\nmixer->rc_urb = NULL;\r\nreturn -ENOMEM;\r\n}\r\nmixer->rc_setup_packet->bRequestType =\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE;\r\nmixer->rc_setup_packet->bRequest = UAC_GET_MEM;\r\nmixer->rc_setup_packet->wValue = cpu_to_le16(0);\r\nmixer->rc_setup_packet->wIndex = cpu_to_le16(0);\r\nmixer->rc_setup_packet->wLength = cpu_to_le16(len);\r\nusb_fill_control_urb(mixer->rc_urb, mixer->chip->dev,\r\nusb_rcvctrlpipe(mixer->chip->dev, 0),\r\n(u8*)mixer->rc_setup_packet, mixer->rc_buffer, len,\r\nsnd_usb_soundblaster_remote_complete, mixer);\r\nreturn 0;\r\n}\r\nstatic int snd_audigy2nx_led_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_interface *mixer = snd_kcontrol_chip(kcontrol);\r\nint index = kcontrol->private_value;\r\nucontrol->value.integer.value[0] = mixer->audigy2nx_leds[index];\r\nreturn 0;\r\n}\r\nstatic int snd_audigy2nx_led_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_interface *mixer = snd_kcontrol_chip(kcontrol);\r\nint index = kcontrol->private_value;\r\nint value = ucontrol->value.integer.value[0];\r\nint err, changed;\r\nif (value > 1)\r\nreturn -EINVAL;\r\nchanged = value != mixer->audigy2nx_leds[index];\r\ndown_read(&mixer->chip->shutdown_rwsem);\r\nif (mixer->chip->shutdown) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nif (mixer->chip->usb_id == USB_ID(0x041e, 0x3042))\r\nerr = snd_usb_ctl_msg(mixer->chip->dev,\r\nusb_sndctrlpipe(mixer->chip->dev, 0), 0x24,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\r\n!value, 0, NULL, 0);\r\nif (mixer->chip->usb_id == USB_ID(0x041e, 0x30df))\r\nerr = snd_usb_ctl_msg(mixer->chip->dev,\r\nusb_sndctrlpipe(mixer->chip->dev, 0), 0x24,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\r\n!value, 0, NULL, 0);\r\nelse\r\nerr = snd_usb_ctl_msg(mixer->chip->dev,\r\nusb_sndctrlpipe(mixer->chip->dev, 0), 0x24,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\r\nvalue, index + 2, NULL, 0);\r\nout:\r\nup_read(&mixer->chip->shutdown_rwsem);\r\nif (err < 0)\r\nreturn err;\r\nmixer->audigy2nx_leds[index] = value;\r\nreturn changed;\r\n}\r\nstatic int snd_audigy2nx_controls_create(struct usb_mixer_interface *mixer)\r\n{\r\nint i, err;\r\nfor (i = 0; i < ARRAY_SIZE(snd_audigy2nx_controls); ++i) {\r\nif ((mixer->chip->usb_id == USB_ID(0x041e, 0x3042)) && i == 0)\r\ncontinue;\r\nif ((mixer->chip->usb_id == USB_ID(0x041e, 0x30df)) && i == 0)\r\ncontinue;\r\nif (i > 1 &&\r\n(mixer->chip->usb_id == USB_ID(0x041e, 0x3040) ||\r\nmixer->chip->usb_id == USB_ID(0x041e, 0x3042) ||\r\nmixer->chip->usb_id == USB_ID(0x041e, 0x30df) ||\r\nmixer->chip->usb_id == USB_ID(0x041e, 0x3048)))\r\nbreak;\r\nerr = snd_ctl_add(mixer->chip->card,\r\nsnd_ctl_new1(&snd_audigy2nx_controls[i], mixer));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nmixer->audigy2nx_leds[1] = 1;\r\nreturn 0;\r\n}\r\nstatic void snd_audigy2nx_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstatic const struct sb_jack {\r\nint unitid;\r\nconst char *name;\r\n} jacks_audigy2nx[] = {\r\n{4, "dig in "},\r\n{7, "line in"},\r\n{19, "spk out"},\r\n{20, "hph out"},\r\n{-1, NULL}\r\n}, jacks_live24ext[] = {\r\n{4, "line in"},\r\n{3, "hph out"},\r\n{0, "RC "},\r\n{-1, NULL}\r\n};\r\nconst struct sb_jack *jacks;\r\nstruct usb_mixer_interface *mixer = entry->private_data;\r\nint i, err;\r\nu8 buf[3];\r\nsnd_iprintf(buffer, "%s jacks\n\n", mixer->chip->card->shortname);\r\nif (mixer->chip->usb_id == USB_ID(0x041e, 0x3020))\r\njacks = jacks_audigy2nx;\r\nelse if (mixer->chip->usb_id == USB_ID(0x041e, 0x3040) ||\r\nmixer->chip->usb_id == USB_ID(0x041e, 0x3048))\r\njacks = jacks_live24ext;\r\nelse\r\nreturn;\r\nfor (i = 0; jacks[i].name; ++i) {\r\nsnd_iprintf(buffer, "%s: ", jacks[i].name);\r\ndown_read(&mixer->chip->shutdown_rwsem);\r\nif (mixer->chip->shutdown)\r\nerr = 0;\r\nelse\r\nerr = snd_usb_ctl_msg(mixer->chip->dev,\r\nusb_rcvctrlpipe(mixer->chip->dev, 0),\r\nUAC_GET_MEM, USB_DIR_IN | USB_TYPE_CLASS |\r\nUSB_RECIP_INTERFACE, 0,\r\njacks[i].unitid << 8, buf, 3);\r\nup_read(&mixer->chip->shutdown_rwsem);\r\nif (err == 3 && (buf[0] == 3 || buf[0] == 6))\r\nsnd_iprintf(buffer, "%02x %02x\n", buf[1], buf[2]);\r\nelse\r\nsnd_iprintf(buffer, "?\n");\r\n}\r\n}\r\nstatic int snd_xonar_u1_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_interface *mixer = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = !!(mixer->xonar_u1_status & 0x02);\r\nreturn 0;\r\n}\r\nstatic int snd_xonar_u1_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_interface *mixer = snd_kcontrol_chip(kcontrol);\r\nu8 old_status, new_status;\r\nint err, changed;\r\nold_status = mixer->xonar_u1_status;\r\nif (ucontrol->value.integer.value[0])\r\nnew_status = old_status | 0x02;\r\nelse\r\nnew_status = old_status & ~0x02;\r\nchanged = new_status != old_status;\r\ndown_read(&mixer->chip->shutdown_rwsem);\r\nif (mixer->chip->shutdown)\r\nerr = -ENODEV;\r\nelse\r\nerr = snd_usb_ctl_msg(mixer->chip->dev,\r\nusb_sndctrlpipe(mixer->chip->dev, 0), 0x08,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\r\n50, 0, &new_status, 1);\r\nup_read(&mixer->chip->shutdown_rwsem);\r\nif (err < 0)\r\nreturn err;\r\nmixer->xonar_u1_status = new_status;\r\nreturn changed;\r\n}\r\nstatic int snd_xonar_u1_controls_create(struct usb_mixer_interface *mixer)\r\n{\r\nint err;\r\nerr = snd_ctl_add(mixer->chip->card,\r\nsnd_ctl_new1(&snd_xonar_u1_output_switch, mixer));\r\nif (err < 0)\r\nreturn err;\r\nmixer->xonar_u1_status = 0x05;\r\nreturn 0;\r\n}\r\nstatic int snd_nativeinstruments_control_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_interface *mixer = snd_kcontrol_chip(kcontrol);\r\nstruct usb_device *dev = mixer->chip->dev;\r\nu8 bRequest = (kcontrol->private_value >> 16) & 0xff;\r\nu16 wIndex = kcontrol->private_value & 0xffff;\r\nu8 tmp;\r\nint ret;\r\ndown_read(&mixer->chip->shutdown_rwsem);\r\nif (mixer->chip->shutdown)\r\nret = -ENODEV;\r\nelse\r\nret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), bRequest,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n0, wIndex,\r\n&tmp, sizeof(tmp), 1000);\r\nup_read(&mixer->chip->shutdown_rwsem);\r\nif (ret < 0) {\r\nsnd_printk(KERN_ERR\r\n"unable to issue vendor read request (ret = %d)", ret);\r\nreturn ret;\r\n}\r\nucontrol->value.integer.value[0] = tmp;\r\nreturn 0;\r\n}\r\nstatic int snd_nativeinstruments_control_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_interface *mixer = snd_kcontrol_chip(kcontrol);\r\nstruct usb_device *dev = mixer->chip->dev;\r\nu8 bRequest = (kcontrol->private_value >> 16) & 0xff;\r\nu16 wIndex = kcontrol->private_value & 0xffff;\r\nu16 wValue = ucontrol->value.integer.value[0];\r\nint ret;\r\ndown_read(&mixer->chip->shutdown_rwsem);\r\nif (mixer->chip->shutdown)\r\nret = -ENODEV;\r\nelse\r\nret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), bRequest,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\r\nwValue, wIndex,\r\nNULL, 0, 1000);\r\nup_read(&mixer->chip->shutdown_rwsem);\r\nif (ret < 0) {\r\nsnd_printk(KERN_ERR\r\n"unable to issue vendor write request (ret = %d)", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_nativeinstruments_create_mixer(struct usb_mixer_interface *mixer,\r\nconst struct snd_kcontrol_new *kc,\r\nunsigned int count)\r\n{\r\nint i, err = 0;\r\nstruct snd_kcontrol_new template = {\r\n.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\r\n.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\r\n.get = snd_nativeinstruments_control_get,\r\n.put = snd_nativeinstruments_control_put,\r\n.info = snd_ctl_boolean_mono_info,\r\n};\r\nfor (i = 0; i < count; i++) {\r\nstruct snd_kcontrol *c;\r\ntemplate.name = kc[i].name;\r\ntemplate.private_value = kc[i].private_value;\r\nc = snd_ctl_new1(&template, mixer);\r\nerr = snd_ctl_add(mixer->chip->card, c);\r\nif (err < 0)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int snd_ftu_eff_switch_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char *texts[8] = {"Room 1",\r\n"Room 2",\r\n"Room 3",\r\n"Hall 1",\r\n"Hall 2",\r\n"Plate",\r\n"Delay",\r\n"Echo"\r\n};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 8;\r\nif (uinfo->value.enumerated.item > 7)\r\nuinfo->value.enumerated.item = 7;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_ftu_eff_switch_get(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_usb_audio *chip;\r\nstruct usb_mixer_interface *mixer;\r\nstruct snd_ftu_eff_switch_priv_val *pval;\r\nint err;\r\nunsigned char value[2];\r\nint id, validx;\r\nconst int val_len = 2;\r\nvalue[0] = 0x00;\r\nvalue[1] = 0x00;\r\npval = (struct snd_ftu_eff_switch_priv_val *)\r\nkctl->private_value;\r\nif (pval->is_cached) {\r\nucontrol->value.enumerated.item[0] = pval->cached_value;\r\nreturn 0;\r\n}\r\nmixer = (struct usb_mixer_interface *) pval->mixer;\r\nif (snd_BUG_ON(!mixer))\r\nreturn -EINVAL;\r\nchip = (struct snd_usb_audio *) mixer->chip;\r\nif (snd_BUG_ON(!chip))\r\nreturn -EINVAL;\r\nid = pval->bUnitID;\r\nvalidx = pval->validx;\r\ndown_read(&mixer->chip->shutdown_rwsem);\r\nif (mixer->chip->shutdown)\r\nerr = -ENODEV;\r\nelse\r\nerr = snd_usb_ctl_msg(chip->dev,\r\nusb_rcvctrlpipe(chip->dev, 0), UAC_GET_CUR,\r\nUSB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\r\nvalidx << 8, snd_usb_ctrl_intf(chip) | (id << 8),\r\nvalue, val_len);\r\nup_read(&mixer->chip->shutdown_rwsem);\r\nif (err < 0)\r\nreturn err;\r\nucontrol->value.enumerated.item[0] = value[0];\r\npval->cached_value = value[0];\r\npval->is_cached = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_ftu_eff_switch_put(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_usb_audio *chip;\r\nstruct snd_ftu_eff_switch_priv_val *pval;\r\nstruct usb_mixer_interface *mixer;\r\nint changed, cur_val, err, new_val;\r\nunsigned char value[2];\r\nint id, validx;\r\nconst int val_len = 2;\r\nchanged = 0;\r\npval = (struct snd_ftu_eff_switch_priv_val *)\r\nkctl->private_value;\r\ncur_val = pval->cached_value;\r\nnew_val = ucontrol->value.enumerated.item[0];\r\nmixer = (struct usb_mixer_interface *) pval->mixer;\r\nif (snd_BUG_ON(!mixer))\r\nreturn -EINVAL;\r\nchip = (struct snd_usb_audio *) mixer->chip;\r\nif (snd_BUG_ON(!chip))\r\nreturn -EINVAL;\r\nid = pval->bUnitID;\r\nvalidx = pval->validx;\r\nif (!pval->is_cached) {\r\ndown_read(&mixer->chip->shutdown_rwsem);\r\nif (mixer->chip->shutdown)\r\nerr = -ENODEV;\r\nelse\r\nerr = snd_usb_ctl_msg(chip->dev,\r\nusb_rcvctrlpipe(chip->dev, 0), UAC_GET_CUR,\r\nUSB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\r\nvalidx << 8, snd_usb_ctrl_intf(chip) | (id << 8),\r\nvalue, val_len);\r\nup_read(&mixer->chip->shutdown_rwsem);\r\nif (err < 0)\r\nreturn err;\r\ncur_val = value[0];\r\npval->cached_value = cur_val;\r\npval->is_cached = 1;\r\n}\r\nif (cur_val != new_val) {\r\nvalue[0] = new_val;\r\nvalue[1] = 0;\r\ndown_read(&mixer->chip->shutdown_rwsem);\r\nif (mixer->chip->shutdown)\r\nerr = -ENODEV;\r\nelse\r\nerr = snd_usb_ctl_msg(chip->dev,\r\nusb_sndctrlpipe(chip->dev, 0), UAC_SET_CUR,\r\nUSB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,\r\nvalidx << 8, snd_usb_ctrl_intf(chip) | (id << 8),\r\nvalue, val_len);\r\nup_read(&mixer->chip->shutdown_rwsem);\r\nif (err < 0)\r\nreturn err;\r\npval->cached_value = new_val;\r\npval->is_cached = 1;\r\nchanged = 1;\r\n}\r\nreturn changed;\r\n}\r\nstatic int snd_ftu_create_effect_switch(struct usb_mixer_interface *mixer,\r\nint validx, int bUnitID)\r\n{\r\nstatic struct snd_kcontrol_new template = {\r\n.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\r\n.name = "Effect Program Switch",\r\n.index = 0,\r\n.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\r\n.info = snd_ftu_eff_switch_info,\r\n.get = snd_ftu_eff_switch_get,\r\n.put = snd_ftu_eff_switch_put\r\n};\r\nint err;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_ftu_eff_switch_priv_val *pval;\r\npval = kzalloc(sizeof(*pval), GFP_KERNEL);\r\nif (!pval)\r\nreturn -ENOMEM;\r\npval->cached_value = 0;\r\npval->is_cached = 0;\r\npval->mixer = mixer;\r\npval->bUnitID = bUnitID;\r\npval->validx = validx;\r\ntemplate.private_value = (unsigned long) pval;\r\nkctl = snd_ctl_new1(&template, mixer->chip);\r\nif (!kctl) {\r\nkfree(pval);\r\nreturn -ENOMEM;\r\n}\r\nerr = snd_ctl_add(mixer->chip->card, kctl);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_ftu_create_volume_ctls(struct usb_mixer_interface *mixer)\r\n{\r\nchar name[64];\r\nunsigned int control, cmask;\r\nint in, out, err;\r\nconst unsigned int id = 5;\r\nconst int val_type = USB_MIXER_S16;\r\nfor (out = 0; out < 8; out++) {\r\ncontrol = out + 1;\r\nfor (in = 0; in < 8; in++) {\r\ncmask = 1 << in;\r\nsnprintf(name, sizeof(name),\r\n"AIn%d - Out%d Capture Volume",\r\nin + 1, out + 1);\r\nerr = snd_create_std_mono_ctl(mixer, id, control,\r\ncmask, val_type, name,\r\n&snd_usb_mixer_vol_tlv);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (in = 8; in < 16; in++) {\r\ncmask = 1 << in;\r\nsnprintf(name, sizeof(name),\r\n"DIn%d - Out%d Playback Volume",\r\nin - 7, out + 1);\r\nerr = snd_create_std_mono_ctl(mixer, id, control,\r\ncmask, val_type, name,\r\n&snd_usb_mixer_vol_tlv);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ftu_create_effect_volume_ctl(struct usb_mixer_interface *mixer)\r\n{\r\nstatic const char name[] = "Effect Volume";\r\nconst unsigned int id = 6;\r\nconst int val_type = USB_MIXER_U8;\r\nconst unsigned int control = 2;\r\nconst unsigned int cmask = 0;\r\nreturn snd_create_std_mono_ctl(mixer, id, control, cmask, val_type,\r\nname, snd_usb_mixer_vol_tlv);\r\n}\r\nstatic int snd_ftu_create_effect_duration_ctl(struct usb_mixer_interface *mixer)\r\n{\r\nstatic const char name[] = "Effect Duration";\r\nconst unsigned int id = 6;\r\nconst int val_type = USB_MIXER_S16;\r\nconst unsigned int control = 3;\r\nconst unsigned int cmask = 0;\r\nreturn snd_create_std_mono_ctl(mixer, id, control, cmask, val_type,\r\nname, snd_usb_mixer_vol_tlv);\r\n}\r\nstatic int snd_ftu_create_effect_feedback_ctl(struct usb_mixer_interface *mixer)\r\n{\r\nstatic const char name[] = "Effect Feedback Volume";\r\nconst unsigned int id = 6;\r\nconst int val_type = USB_MIXER_U8;\r\nconst unsigned int control = 4;\r\nconst unsigned int cmask = 0;\r\nreturn snd_create_std_mono_ctl(mixer, id, control, cmask, val_type,\r\nname, NULL);\r\n}\r\nstatic int snd_ftu_create_effect_return_ctls(struct usb_mixer_interface *mixer)\r\n{\r\nunsigned int cmask;\r\nint err, ch;\r\nchar name[48];\r\nconst unsigned int id = 7;\r\nconst int val_type = USB_MIXER_S16;\r\nconst unsigned int control = 7;\r\nfor (ch = 0; ch < 4; ++ch) {\r\ncmask = 1 << ch;\r\nsnprintf(name, sizeof(name),\r\n"Effect Return %d Volume", ch + 1);\r\nerr = snd_create_std_mono_ctl(mixer, id, control,\r\ncmask, val_type, name,\r\nsnd_usb_mixer_vol_tlv);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ftu_create_effect_send_ctls(struct usb_mixer_interface *mixer)\r\n{\r\nunsigned int cmask;\r\nint err, ch;\r\nchar name[48];\r\nconst unsigned int id = 5;\r\nconst int val_type = USB_MIXER_S16;\r\nconst unsigned int control = 9;\r\nfor (ch = 0; ch < 8; ++ch) {\r\ncmask = 1 << ch;\r\nsnprintf(name, sizeof(name),\r\n"Effect Send AIn%d Volume", ch + 1);\r\nerr = snd_create_std_mono_ctl(mixer, id, control, cmask,\r\nval_type, name,\r\nsnd_usb_mixer_vol_tlv);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (ch = 8; ch < 16; ++ch) {\r\ncmask = 1 << ch;\r\nsnprintf(name, sizeof(name),\r\n"Effect Send DIn%d Volume", ch - 7);\r\nerr = snd_create_std_mono_ctl(mixer, id, control, cmask,\r\nval_type, name,\r\nsnd_usb_mixer_vol_tlv);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ftu_create_mixer(struct usb_mixer_interface *mixer)\r\n{\r\nint err;\r\nerr = snd_ftu_create_volume_ctls(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ftu_create_effect_switch(mixer, 1, 6);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ftu_create_effect_volume_ctl(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ftu_create_effect_duration_ctl(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ftu_create_effect_feedback_ctl(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ftu_create_effect_return_ctls(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ftu_create_effect_send_ctls(mixer);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nvoid snd_emuusb_set_samplerate(struct snd_usb_audio *chip,\r\nunsigned char samplerate_id)\r\n{\r\nstruct usb_mixer_interface *mixer;\r\nstruct usb_mixer_elem_info *cval;\r\nint unitid = 12;\r\nlist_for_each_entry(mixer, &chip->mixer_list, list) {\r\ncval = mixer->id_elems[unitid];\r\nif (cval) {\r\nsnd_usb_mixer_set_ctl_value(cval, UAC_SET_CUR,\r\ncval->control << 8,\r\nsamplerate_id);\r\nsnd_usb_mixer_notify_id(mixer, unitid);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int snd_c400_create_vol_ctls(struct usb_mixer_interface *mixer)\r\n{\r\nchar name[64];\r\nunsigned int cmask, offset;\r\nint out, chan, err;\r\nint num_outs = 0;\r\nint num_ins = 0;\r\nconst unsigned int id = 0x40;\r\nconst int val_type = USB_MIXER_S16;\r\nconst int control = 1;\r\nswitch (mixer->chip->usb_id) {\r\ncase USB_ID(0x0763, 0x2030):\r\nnum_outs = 6;\r\nnum_ins = 4;\r\nbreak;\r\ncase USB_ID(0x0763, 0x2031):\r\nnum_outs = 8;\r\nnum_ins = 6;\r\nbreak;\r\n}\r\nfor (chan = 0; chan < num_outs + num_ins; chan++) {\r\nfor (out = 0; out < num_outs; out++) {\r\nif (chan < num_outs) {\r\nsnprintf(name, sizeof(name),\r\n"PCM%d-Out%d Playback Volume",\r\nchan + 1, out + 1);\r\n} else {\r\nsnprintf(name, sizeof(name),\r\n"In%d-Out%d Playback Volume",\r\nchan - num_outs + 1, out + 1);\r\n}\r\ncmask = (out == 0) ? 0 : 1 << (out - 1);\r\noffset = chan * num_outs;\r\nerr = snd_create_std_mono_ctl_offset(mixer, id, control,\r\ncmask, val_type, offset, name,\r\n&snd_usb_mixer_vol_tlv);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_c400_create_effect_volume_ctl(struct usb_mixer_interface *mixer)\r\n{\r\nstatic const char name[] = "Effect Volume";\r\nconst unsigned int id = 0x43;\r\nconst int val_type = USB_MIXER_U8;\r\nconst unsigned int control = 3;\r\nconst unsigned int cmask = 0;\r\nreturn snd_create_std_mono_ctl(mixer, id, control, cmask, val_type,\r\nname, snd_usb_mixer_vol_tlv);\r\n}\r\nstatic int snd_c400_create_effect_duration_ctl(struct usb_mixer_interface *mixer)\r\n{\r\nstatic const char name[] = "Effect Duration";\r\nconst unsigned int id = 0x43;\r\nconst int val_type = USB_MIXER_S16;\r\nconst unsigned int control = 4;\r\nconst unsigned int cmask = 0;\r\nreturn snd_create_std_mono_ctl(mixer, id, control, cmask, val_type,\r\nname, snd_usb_mixer_vol_tlv);\r\n}\r\nstatic int snd_c400_create_effect_feedback_ctl(struct usb_mixer_interface *mixer)\r\n{\r\nstatic const char name[] = "Effect Feedback Volume";\r\nconst unsigned int id = 0x43;\r\nconst int val_type = USB_MIXER_U8;\r\nconst unsigned int control = 5;\r\nconst unsigned int cmask = 0;\r\nreturn snd_create_std_mono_ctl(mixer, id, control, cmask, val_type,\r\nname, NULL);\r\n}\r\nstatic int snd_c400_create_effect_vol_ctls(struct usb_mixer_interface *mixer)\r\n{\r\nchar name[64];\r\nunsigned int cmask;\r\nint chan, err;\r\nint num_outs = 0;\r\nint num_ins = 0;\r\nconst unsigned int id = 0x42;\r\nconst int val_type = USB_MIXER_S16;\r\nconst int control = 1;\r\nswitch (mixer->chip->usb_id) {\r\ncase USB_ID(0x0763, 0x2030):\r\nnum_outs = 6;\r\nnum_ins = 4;\r\nbreak;\r\ncase USB_ID(0x0763, 0x2031):\r\nnum_outs = 8;\r\nnum_ins = 6;\r\nbreak;\r\n}\r\nfor (chan = 0; chan < num_outs + num_ins; chan++) {\r\nif (chan < num_outs) {\r\nsnprintf(name, sizeof(name),\r\n"Effect Send DOut%d",\r\nchan + 1);\r\n} else {\r\nsnprintf(name, sizeof(name),\r\n"Effect Send AIn%d",\r\nchan - num_outs + 1);\r\n}\r\ncmask = (chan == 0) ? 0 : 1 << (chan - 1);\r\nerr = snd_create_std_mono_ctl(mixer, id, control,\r\ncmask, val_type, name,\r\n&snd_usb_mixer_vol_tlv);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_c400_create_effect_ret_vol_ctls(struct usb_mixer_interface *mixer)\r\n{\r\nchar name[64];\r\nunsigned int cmask;\r\nint chan, err;\r\nint num_outs = 0;\r\nint offset = 0;\r\nconst unsigned int id = 0x40;\r\nconst int val_type = USB_MIXER_S16;\r\nconst int control = 1;\r\nswitch (mixer->chip->usb_id) {\r\ncase USB_ID(0x0763, 0x2030):\r\nnum_outs = 6;\r\noffset = 0x3c;\r\nbreak;\r\ncase USB_ID(0x0763, 0x2031):\r\nnum_outs = 8;\r\noffset = 0x70;\r\nbreak;\r\n}\r\nfor (chan = 0; chan < num_outs; chan++) {\r\nsnprintf(name, sizeof(name),\r\n"Effect Return %d",\r\nchan + 1);\r\ncmask = (chan == 0) ? 0 :\r\n1 << (chan + (chan % 2) * num_outs - 1);\r\nerr = snd_create_std_mono_ctl_offset(mixer, id, control,\r\ncmask, val_type, offset, name,\r\n&snd_usb_mixer_vol_tlv);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_c400_create_mixer(struct usb_mixer_interface *mixer)\r\n{\r\nint err;\r\nerr = snd_c400_create_vol_ctls(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_c400_create_effect_vol_ctls(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_c400_create_effect_ret_vol_ctls(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ftu_create_effect_switch(mixer, 2, 0x43);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_c400_create_effect_volume_ctl(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_c400_create_effect_duration_ctl(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_c400_create_effect_feedback_ctl(mixer);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_microii_spdif_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_microii_spdif_default_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_interface *mixer = snd_kcontrol_chip(kcontrol);\r\nint err;\r\nstruct usb_interface *iface;\r\nstruct usb_host_interface *alts;\r\nunsigned int ep;\r\nunsigned char data[3];\r\nint rate;\r\nucontrol->value.iec958.status[0] = kcontrol->private_value & 0xff;\r\nucontrol->value.iec958.status[1] = (kcontrol->private_value >> 8) & 0xff;\r\nucontrol->value.iec958.status[2] = 0x00;\r\niface = usb_ifnum_to_if(mixer->chip->dev, 1);\r\nalts = &iface->altsetting[1];\r\nep = get_endpoint(alts, 0)->bEndpointAddress;\r\nerr = snd_usb_ctl_msg(mixer->chip->dev,\r\nusb_rcvctrlpipe(mixer->chip->dev, 0),\r\nUAC_GET_CUR,\r\nUSB_TYPE_CLASS | USB_RECIP_ENDPOINT | USB_DIR_IN,\r\nUAC_EP_CS_ATTR_SAMPLE_RATE << 8,\r\nep,\r\ndata,\r\nsizeof(data));\r\nif (err < 0)\r\ngoto end;\r\nrate = data[0] | (data[1] << 8) | (data[2] << 16);\r\nucontrol->value.iec958.status[3] = (rate == 48000) ?\r\nIEC958_AES3_CON_FS_48000 : IEC958_AES3_CON_FS_44100;\r\nerr = 0;\r\nend:\r\nreturn err;\r\n}\r\nstatic int snd_microii_spdif_default_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_interface *mixer = snd_kcontrol_chip(kcontrol);\r\nint err;\r\nu8 reg;\r\nunsigned long priv_backup = kcontrol->private_value;\r\nreg = ((ucontrol->value.iec958.status[1] & 0x0f) << 4) |\r\n(ucontrol->value.iec958.status[0] & 0x0f);\r\nerr = snd_usb_ctl_msg(mixer->chip->dev,\r\nusb_sndctrlpipe(mixer->chip->dev, 0),\r\nUAC_SET_CUR,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\r\nreg,\r\n2,\r\nNULL,\r\n0);\r\nif (err < 0)\r\ngoto end;\r\nkcontrol->private_value &= 0xfffff0f0;\r\nkcontrol->private_value |= (ucontrol->value.iec958.status[1] & 0x0f) << 8;\r\nkcontrol->private_value |= (ucontrol->value.iec958.status[0] & 0x0f);\r\nreg = (ucontrol->value.iec958.status[0] & IEC958_AES0_NONAUDIO) ?\r\n0xa0 : 0x20;\r\nreg |= (ucontrol->value.iec958.status[1] >> 4) & 0x0f;\r\nerr = snd_usb_ctl_msg(mixer->chip->dev,\r\nusb_sndctrlpipe(mixer->chip->dev, 0),\r\nUAC_SET_CUR,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\r\nreg,\r\n3,\r\nNULL,\r\n0);\r\nif (err < 0)\r\ngoto end;\r\nkcontrol->private_value &= 0xffff0fff;\r\nkcontrol->private_value |= (ucontrol->value.iec958.status[1] & 0xf0) << 8;\r\nerr = (priv_backup != kcontrol->private_value);\r\nend:\r\nreturn err;\r\n}\r\nstatic int snd_microii_spdif_mask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = 0x0f;\r\nucontrol->value.iec958.status[1] = 0xff;\r\nucontrol->value.iec958.status[2] = 0x00;\r\nucontrol->value.iec958.status[3] = 0x00;\r\nreturn 0;\r\n}\r\nstatic int snd_microii_spdif_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.integer.value[0] = !(kcontrol->private_value & 0x02);\r\nreturn 0;\r\n}\r\nstatic int snd_microii_spdif_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_interface *mixer = snd_kcontrol_chip(kcontrol);\r\nint err;\r\nu8 reg = ucontrol->value.integer.value[0] ? 0x28 : 0x2a;\r\nerr = snd_usb_ctl_msg(mixer->chip->dev,\r\nusb_sndctrlpipe(mixer->chip->dev, 0),\r\nUAC_SET_CUR,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\r\nreg,\r\n9,\r\nNULL,\r\n0);\r\nif (!err) {\r\nerr = (reg != (kcontrol->private_value & 0x0ff));\r\nif (err)\r\nkcontrol->private_value = reg;\r\n}\r\nreturn err;\r\n}\r\nstatic int snd_microii_controls_create(struct usb_mixer_interface *mixer)\r\n{\r\nint err, i;\r\nfor (i = 0; i < ARRAY_SIZE(snd_microii_mixer_spdif); ++i) {\r\nerr = snd_ctl_add(mixer->chip->card,\r\nsnd_ctl_new1(&snd_microii_mixer_spdif[i], mixer));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nint snd_usb_mixer_apply_create_quirk(struct usb_mixer_interface *mixer)\r\n{\r\nint err = 0;\r\nstruct snd_info_entry *entry;\r\nif ((err = snd_usb_soundblaster_remote_init(mixer)) < 0)\r\nreturn err;\r\nswitch (mixer->chip->usb_id) {\r\ncase USB_ID(0x041e, 0x3020):\r\ncase USB_ID(0x041e, 0x3040):\r\ncase USB_ID(0x041e, 0x3042):\r\ncase USB_ID(0x041e, 0x30df):\r\ncase USB_ID(0x041e, 0x3048):\r\nerr = snd_audigy2nx_controls_create(mixer);\r\nif (err < 0)\r\nbreak;\r\nif (!snd_card_proc_new(mixer->chip->card, "audigy2nx", &entry))\r\nsnd_info_set_text_ops(entry, mixer,\r\nsnd_audigy2nx_proc_read);\r\nbreak;\r\ncase USB_ID(0x0763, 0x2030):\r\ncase USB_ID(0x0763, 0x2031):\r\nerr = snd_c400_create_mixer(mixer);\r\nbreak;\r\ncase USB_ID(0x0763, 0x2080):\r\ncase USB_ID(0x0763, 0x2081):\r\nerr = snd_ftu_create_mixer(mixer);\r\nbreak;\r\ncase USB_ID(0x0b05, 0x1739):\r\ncase USB_ID(0x0b05, 0x1743):\r\ncase USB_ID(0x0b05, 0x17a0):\r\nerr = snd_xonar_u1_controls_create(mixer);\r\nbreak;\r\ncase USB_ID(0x0d8c, 0x0103):\r\nerr = snd_microii_controls_create(mixer);\r\nbreak;\r\ncase USB_ID(0x17cc, 0x1011):\r\nerr = snd_nativeinstruments_create_mixer(mixer,\r\nsnd_nativeinstruments_ta6_mixers,\r\nARRAY_SIZE(snd_nativeinstruments_ta6_mixers));\r\nbreak;\r\ncase USB_ID(0x17cc, 0x1021):\r\nerr = snd_nativeinstruments_create_mixer(mixer,\r\nsnd_nativeinstruments_ta10_mixers,\r\nARRAY_SIZE(snd_nativeinstruments_ta10_mixers));\r\nbreak;\r\ncase USB_ID(0x200c, 0x1018):\r\nerr = snd_create_std_mono_table(mixer, ebox44_table);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nvoid snd_usb_mixer_rc_memory_change(struct usb_mixer_interface *mixer,\r\nint unitid)\r\n{\r\nif (!mixer->rc_cfg)\r\nreturn;\r\nswitch (unitid) {\r\ncase 0:\r\nmixer->rc_urb->dev = mixer->chip->dev;\r\nusb_submit_urb(mixer->rc_urb, GFP_ATOMIC);\r\nbreak;\r\ncase 4:\r\ncase 7:\r\ncase 19:\r\ncase 20:\r\nbreak;\r\ncase 3:\r\nif (mixer->chip->usb_id == USB_ID(0x041e, 0x3040) ||\r\nmixer->chip->usb_id == USB_ID(0x041e, 0x3048))\r\nsnd_usb_mixer_notify_id(mixer, mixer->rc_cfg->mute_mixer_id);\r\nbreak;\r\ndefault:\r\nsnd_printd(KERN_DEBUG "memory change in unknown unit %d\n", unitid);\r\nbreak;\r\n}\r\n}
