static int integrator_verify_policy(struct cpufreq_policy *policy)\r\n{\r\nstruct icst_vco vco;\r\ncpufreq_verify_within_limits(policy,\r\npolicy->cpuinfo.min_freq,\r\npolicy->cpuinfo.max_freq);\r\nvco = icst_hz_to_vco(&cclk_params, policy->max * 1000);\r\npolicy->max = icst_hz(&cclk_params, vco) / 1000;\r\nvco = icst_hz_to_vco(&cclk_params, policy->min * 1000);\r\npolicy->min = icst_hz(&cclk_params, vco) / 1000;\r\ncpufreq_verify_within_limits(policy,\r\npolicy->cpuinfo.min_freq,\r\npolicy->cpuinfo.max_freq);\r\nreturn 0;\r\n}\r\nstatic int integrator_set_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\ncpumask_t cpus_allowed;\r\nint cpu = policy->cpu;\r\nstruct icst_vco vco;\r\nstruct cpufreq_freqs freqs;\r\nu_int cm_osc;\r\ncpus_allowed = current->cpus_allowed;\r\nset_cpus_allowed(current, cpumask_of_cpu(cpu));\r\nBUG_ON(cpu != smp_processor_id());\r\ncm_osc = __raw_readl(CM_OSC);\r\nif (machine_is_integrator()) {\r\nvco.s = (cm_osc >> 8) & 7;\r\n} else if (machine_is_cintegrator()) {\r\nvco.s = 1;\r\n}\r\nvco.v = cm_osc & 255;\r\nvco.r = 22;\r\nfreqs.old = icst_hz(&cclk_params, vco) / 1000;\r\nif (relation == CPUFREQ_RELATION_L)\r\ntarget_freq += 999;\r\nif (target_freq > policy->max)\r\ntarget_freq = policy->max;\r\nvco = icst_hz_to_vco(&cclk_params, target_freq * 1000);\r\nfreqs.new = icst_hz(&cclk_params, vco) / 1000;\r\nif (freqs.old == freqs.new) {\r\nset_cpus_allowed(current, cpus_allowed);\r\nreturn 0;\r\n}\r\ncpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);\r\ncm_osc = __raw_readl(CM_OSC);\r\nif (machine_is_integrator()) {\r\ncm_osc &= 0xfffff800;\r\ncm_osc |= vco.s << 8;\r\n} else if (machine_is_cintegrator()) {\r\ncm_osc &= 0xffffff00;\r\n}\r\ncm_osc |= vco.v;\r\n__raw_writel(0xa05f, CM_LOCK);\r\n__raw_writel(cm_osc, CM_OSC);\r\n__raw_writel(0, CM_LOCK);\r\nset_cpus_allowed(current, cpus_allowed);\r\ncpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);\r\nreturn 0;\r\n}\r\nstatic unsigned int integrator_get(unsigned int cpu)\r\n{\r\ncpumask_t cpus_allowed;\r\nunsigned int current_freq;\r\nu_int cm_osc;\r\nstruct icst_vco vco;\r\ncpus_allowed = current->cpus_allowed;\r\nset_cpus_allowed(current, cpumask_of_cpu(cpu));\r\nBUG_ON(cpu != smp_processor_id());\r\ncm_osc = __raw_readl(CM_OSC);\r\nif (machine_is_integrator()) {\r\nvco.s = (cm_osc >> 8) & 7;\r\n} else {\r\nvco.s = 1;\r\n}\r\nvco.v = cm_osc & 255;\r\nvco.r = 22;\r\ncurrent_freq = icst_hz(&cclk_params, vco) / 1000;\r\nset_cpus_allowed(current, cpus_allowed);\r\nreturn current_freq;\r\n}\r\nstatic int integrator_cpufreq_init(struct cpufreq_policy *policy)\r\n{\r\npolicy->cpuinfo.max_freq = 160000;\r\npolicy->cpuinfo.min_freq = 12000;\r\npolicy->cpuinfo.transition_latency = 1000000;\r\npolicy->cur = policy->min = policy->max = integrator_get(policy->cpu);\r\nreturn 0;\r\n}\r\nstatic int __init integrator_cpu_init(void)\r\n{\r\nreturn cpufreq_register_driver(&integrator_driver);\r\n}\r\nstatic void __exit integrator_cpu_exit(void)\r\n{\r\ncpufreq_unregister_driver(&integrator_driver);\r\n}
