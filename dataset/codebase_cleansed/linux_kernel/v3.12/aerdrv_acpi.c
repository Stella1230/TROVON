static inline int hest_match_pci(struct acpi_hest_aer_common *p,\r\nstruct pci_dev *pci)\r\n{\r\nreturn (0 == pci_domain_nr(pci->bus) &&\r\np->bus == pci->bus->number &&\r\np->device == PCI_SLOT(pci->devfn) &&\r\np->function == PCI_FUNC(pci->devfn));\r\n}\r\nstatic inline bool hest_match_type(struct acpi_hest_header *hest_hdr,\r\nstruct pci_dev *dev)\r\n{\r\nu16 hest_type = hest_hdr->type;\r\nu8 pcie_type = pci_pcie_type(dev);\r\nif ((hest_type == ACPI_HEST_TYPE_AER_ROOT_PORT &&\r\npcie_type == PCI_EXP_TYPE_ROOT_PORT) ||\r\n(hest_type == ACPI_HEST_TYPE_AER_ENDPOINT &&\r\npcie_type == PCI_EXP_TYPE_ENDPOINT) ||\r\n(hest_type == ACPI_HEST_TYPE_AER_BRIDGE &&\r\n(dev->class >> 16) == PCI_BASE_CLASS_BRIDGE))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int aer_hest_parse(struct acpi_hest_header *hest_hdr, void *data)\r\n{\r\nstruct aer_hest_parse_info *info = data;\r\nstruct acpi_hest_aer_common *p;\r\nint ff;\r\np = (struct acpi_hest_aer_common *)(hest_hdr + 1);\r\nff = !!(p->flags & ACPI_HEST_FIRMWARE_FIRST);\r\nif (p->flags & ACPI_HEST_GLOBAL) {\r\nif (hest_match_type(hest_hdr, info->pci_dev))\r\ninfo->firmware_first = ff;\r\n} else\r\nif (hest_match_pci(p, info->pci_dev))\r\ninfo->firmware_first = ff;\r\nreturn 0;\r\n}\r\nstatic void aer_set_firmware_first(struct pci_dev *pci_dev)\r\n{\r\nint rc;\r\nstruct aer_hest_parse_info info = {\r\n.pci_dev = pci_dev,\r\n.firmware_first = 0,\r\n};\r\nrc = apei_hest_parse(aer_hest_parse, &info);\r\nif (rc)\r\npci_dev->__aer_firmware_first = 0;\r\nelse\r\npci_dev->__aer_firmware_first = info.firmware_first;\r\npci_dev->__aer_firmware_first_valid = 1;\r\n}\r\nint pcie_aer_get_firmware_first(struct pci_dev *dev)\r\n{\r\nif (!pci_is_pcie(dev))\r\nreturn 0;\r\nif (!dev->__aer_firmware_first_valid)\r\naer_set_firmware_first(dev);\r\nreturn dev->__aer_firmware_first;\r\n}\r\nstatic int aer_hest_parse_aff(struct acpi_hest_header *hest_hdr, void *data)\r\n{\r\nstruct acpi_hest_aer_common *p;\r\nif (aer_firmware_first)\r\nreturn 0;\r\nswitch (hest_hdr->type) {\r\ncase ACPI_HEST_TYPE_AER_ROOT_PORT:\r\ncase ACPI_HEST_TYPE_AER_ENDPOINT:\r\ncase ACPI_HEST_TYPE_AER_BRIDGE:\r\np = (struct acpi_hest_aer_common *)(hest_hdr + 1);\r\naer_firmware_first = !!(p->flags & ACPI_HEST_FIRMWARE_FIRST);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nbool aer_acpi_firmware_first(void)\r\n{\r\nstatic bool parsed = false;\r\nif (!parsed) {\r\napei_hest_parse(aer_hest_parse_aff, NULL);\r\nparsed = true;\r\n}\r\nreturn aer_firmware_first;\r\n}
