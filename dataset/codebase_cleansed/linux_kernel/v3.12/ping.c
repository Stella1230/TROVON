static int dummy_ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len)\r\n{\r\nreturn -EAFNOSUPPORT;\r\n}\r\nstatic int dummy_ip6_datagram_recv_ctl(struct sock *sk, struct msghdr *msg,\r\nstruct sk_buff *skb)\r\n{\r\nreturn -EAFNOSUPPORT;\r\n}\r\nstatic int dummy_icmpv6_err_convert(u8 type, u8 code, int *err)\r\n{\r\nreturn -EAFNOSUPPORT;\r\n}\r\nstatic void dummy_ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err,\r\n__be16 port, u32 info, u8 *payload) {}\r\nstatic int dummy_ipv6_chk_addr(struct net *net, const struct in6_addr *addr,\r\nconst struct net_device *dev, int strict)\r\n{\r\nreturn 0;\r\n}\r\nint ping_v6_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\r\nsize_t len)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct icmp6hdr user_icmph;\r\nint addr_type;\r\nstruct in6_addr *daddr;\r\nint iif = 0;\r\nstruct flowi6 fl6;\r\nint err;\r\nint hlimit;\r\nstruct dst_entry *dst;\r\nstruct rt6_info *rt;\r\nstruct pingfakehdr pfh;\r\npr_debug("ping_v6_sendmsg(sk=%p,sk->num=%u)\n", inet, inet->inet_num);\r\nerr = ping_common_sendmsg(AF_INET6, msg, len, &user_icmph,\r\nsizeof(user_icmph));\r\nif (err)\r\nreturn err;\r\nif (msg->msg_name) {\r\nstruct sockaddr_in6 *u = (struct sockaddr_in6 *) msg->msg_name;\r\nif (msg->msg_namelen < sizeof(struct sockaddr_in6) ||\r\nu->sin6_family != AF_INET6) {\r\nreturn -EINVAL;\r\n}\r\nif (sk->sk_bound_dev_if &&\r\nsk->sk_bound_dev_if != u->sin6_scope_id) {\r\nreturn -EINVAL;\r\n}\r\ndaddr = &(u->sin6_addr);\r\niif = u->sin6_scope_id;\r\n} else {\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\nreturn -EDESTADDRREQ;\r\ndaddr = &np->daddr;\r\n}\r\nif (!iif)\r\niif = sk->sk_bound_dev_if;\r\naddr_type = ipv6_addr_type(daddr);\r\nif (__ipv6_addr_needs_scope_id(addr_type) && !iif)\r\nreturn -EINVAL;\r\nif (addr_type & IPV6_ADDR_MAPPED)\r\nreturn -EINVAL;\r\nmemset(&fl6, 0, sizeof(fl6));\r\nfl6.flowi6_proto = IPPROTO_ICMPV6;\r\nfl6.saddr = np->saddr;\r\nfl6.daddr = *daddr;\r\nfl6.fl6_icmp_type = user_icmph.icmp6_type;\r\nfl6.fl6_icmp_code = user_icmph.icmp6_code;\r\nsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\r\nif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\r\nfl6.flowi6_oif = np->mcast_oif;\r\nelse if (!fl6.flowi6_oif)\r\nfl6.flowi6_oif = np->ucast_oif;\r\ndst = ip6_sk_dst_lookup_flow(sk, &fl6, daddr, 1);\r\nif (IS_ERR(dst))\r\nreturn PTR_ERR(dst);\r\nrt = (struct rt6_info *) dst;\r\nnp = inet6_sk(sk);\r\nif (!np)\r\nreturn -EBADF;\r\nif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\r\nfl6.flowi6_oif = np->mcast_oif;\r\nelse if (!fl6.flowi6_oif)\r\nfl6.flowi6_oif = np->ucast_oif;\r\npfh.icmph.type = user_icmph.icmp6_type;\r\npfh.icmph.code = user_icmph.icmp6_code;\r\npfh.icmph.checksum = 0;\r\npfh.icmph.un.echo.id = inet->inet_sport;\r\npfh.icmph.un.echo.sequence = user_icmph.icmp6_sequence;\r\npfh.iov = msg->msg_iov;\r\npfh.wcheck = 0;\r\npfh.family = AF_INET6;\r\nif (ipv6_addr_is_multicast(&fl6.daddr))\r\nhlimit = np->mcast_hops;\r\nelse\r\nhlimit = np->hop_limit;\r\nif (hlimit < 0)\r\nhlimit = ip6_dst_hoplimit(dst);\r\nlock_sock(sk);\r\nerr = ip6_append_data(sk, ping_getfrag, &pfh, len,\r\n0, hlimit,\r\nnp->tclass, NULL, &fl6, rt,\r\nMSG_DONTWAIT, np->dontfrag);\r\nif (err) {\r\nICMP6_INC_STATS_BH(sock_net(sk), rt->rt6i_idev,\r\nICMP6_MIB_OUTERRORS);\r\nip6_flush_pending_frames(sk);\r\n} else {\r\nerr = icmpv6_push_pending_frames(sk, &fl6,\r\n(struct icmp6hdr *) &pfh.icmph,\r\nlen);\r\n}\r\nrelease_sock(sk);\r\nif (err)\r\nreturn err;\r\nreturn len;\r\n}\r\nstatic void *ping_v6_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nreturn ping_seq_start(seq, pos, AF_INET6);\r\n}\r\nstatic int ping_v6_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq, IPV6_SEQ_DGRAM_HEADER);\r\n} else {\r\nint bucket = ((struct ping_iter_state *) seq->private)->bucket;\r\nstruct inet_sock *inet = inet_sk(v);\r\n__u16 srcp = ntohs(inet->inet_sport);\r\n__u16 destp = ntohs(inet->inet_dport);\r\nip6_dgram_sock_seq_show(seq, v, srcp, destp, bucket);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __net_init ping_v6_proc_init_net(struct net *net)\r\n{\r\nreturn ping_proc_register(net, &ping_v6_seq_afinfo);\r\n}\r\nstatic void __net_init ping_v6_proc_exit_net(struct net *net)\r\n{\r\nreturn ping_proc_unregister(net, &ping_v6_seq_afinfo);\r\n}\r\nint __init pingv6_init(void)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\nint ret = register_pernet_subsys(&ping_v6_net_ops);\r\nif (ret)\r\nreturn ret;\r\n#endif\r\npingv6_ops.ipv6_recv_error = ipv6_recv_error;\r\npingv6_ops.ip6_datagram_recv_ctl = ip6_datagram_recv_ctl;\r\npingv6_ops.icmpv6_err_convert = icmpv6_err_convert;\r\npingv6_ops.ipv6_icmp_error = ipv6_icmp_error;\r\npingv6_ops.ipv6_chk_addr = ipv6_chk_addr;\r\nreturn inet6_register_protosw(&pingv6_protosw);\r\n}\r\nvoid pingv6_exit(void)\r\n{\r\npingv6_ops.ipv6_recv_error = dummy_ipv6_recv_error;\r\npingv6_ops.ip6_datagram_recv_ctl = dummy_ip6_datagram_recv_ctl;\r\npingv6_ops.icmpv6_err_convert = dummy_icmpv6_err_convert;\r\npingv6_ops.ipv6_icmp_error = dummy_ipv6_icmp_error;\r\npingv6_ops.ipv6_chk_addr = dummy_ipv6_chk_addr;\r\n#ifdef CONFIG_PROC_FS\r\nunregister_pernet_subsys(&ping_v6_net_ops);\r\n#endif\r\ninet6_unregister_protosw(&pingv6_protosw);\r\n}
