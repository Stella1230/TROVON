static u8 clk_sp810_timerclken_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_sp810_timerclken *timerclken = to_clk_sp810_timerclken(hw);\r\nu32 val = readl(timerclken->sp810->base + SCCTRL);\r\nreturn !!(val & (1 << SCCTRL_TIMERENnSEL_SHIFT(timerclken->channel)));\r\n}\r\nstatic int clk_sp810_timerclken_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_sp810_timerclken *timerclken = to_clk_sp810_timerclken(hw);\r\nstruct clk_sp810 *sp810 = timerclken->sp810;\r\nu32 val, shift = SCCTRL_TIMERENnSEL_SHIFT(timerclken->channel);\r\nunsigned long flags = 0;\r\nif (WARN_ON(index > 1))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&sp810->lock, flags);\r\nval = readl(sp810->base + SCCTRL);\r\nval &= ~(1 << shift);\r\nval |= index << shift;\r\nwritel(val, sp810->base + SCCTRL);\r\nspin_unlock_irqrestore(&sp810->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int clk_sp810_timerclken_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_sp810_timerclken *timerclken = to_clk_sp810_timerclken(hw);\r\nstruct clk_sp810 *sp810 = timerclken->sp810;\r\nstruct clk *old_parent = __clk_get_parent(hw->clk);\r\nstruct clk *new_parent;\r\nif (!sp810->refclk)\r\nsp810->refclk = of_clk_get(sp810->node, sp810->refclk_index);\r\nif (!sp810->timclk)\r\nsp810->timclk = of_clk_get(sp810->node, sp810->timclk_index);\r\nif (WARN_ON(IS_ERR(sp810->refclk) || IS_ERR(sp810->timclk)))\r\nreturn -ENOENT;\r\nif (clk_get_rate(sp810->refclk) > clk_get_rate(sp810->timclk))\r\nnew_parent = sp810->refclk;\r\nelse\r\nnew_parent = sp810->timclk;\r\nif (old_parent != new_parent) {\r\nclk_prepare(new_parent);\r\nclk_set_parent(hw->clk, new_parent);\r\nclk_unprepare(old_parent);\r\n}\r\nreturn 0;\r\n}\r\nstatic void clk_sp810_timerclken_unprepare(struct clk_hw *hw)\r\n{\r\nstruct clk_sp810_timerclken *timerclken = to_clk_sp810_timerclken(hw);\r\nstruct clk_sp810 *sp810 = timerclken->sp810;\r\nclk_put(sp810->timclk);\r\nclk_put(sp810->refclk);\r\n}\r\nstruct clk *clk_sp810_timerclken_of_get(struct of_phandle_args *clkspec,\r\nvoid *data)\r\n{\r\nstruct clk_sp810 *sp810 = data;\r\nif (WARN_ON(clkspec->args_count != 1 || clkspec->args[0] >\r\nARRAY_SIZE(sp810->timerclken)))\r\nreturn NULL;\r\nreturn sp810->timerclken[clkspec->args[0]].clk;\r\n}\r\nvoid __init clk_sp810_of_setup(struct device_node *node)\r\n{\r\nstruct clk_sp810 *sp810 = kzalloc(sizeof(*sp810), GFP_KERNEL);\r\nconst char *parent_names[2];\r\nchar name[12];\r\nstruct clk_init_data init;\r\nint i;\r\nif (!sp810) {\r\npr_err("Failed to allocate memory for SP810!\n");\r\nreturn;\r\n}\r\nsp810->refclk_index = of_property_match_string(node, "clock-names",\r\n"refclk");\r\nparent_names[0] = of_clk_get_parent_name(node, sp810->refclk_index);\r\nsp810->timclk_index = of_property_match_string(node, "clock-names",\r\n"timclk");\r\nparent_names[1] = of_clk_get_parent_name(node, sp810->timclk_index);\r\nif (parent_names[0] <= 0 || parent_names[1] <= 0) {\r\npr_warn("Failed to obtain parent clocks for SP810!\n");\r\nreturn;\r\n}\r\nsp810->node = node;\r\nsp810->base = of_iomap(node, 0);\r\nspin_lock_init(&sp810->lock);\r\ninit.name = name;\r\ninit.ops = &clk_sp810_timerclken_ops;\r\ninit.flags = CLK_IS_BASIC;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = ARRAY_SIZE(parent_names);\r\nfor (i = 0; i < ARRAY_SIZE(sp810->timerclken); i++) {\r\nsnprintf(name, ARRAY_SIZE(name), "timerclken%d", i);\r\nsp810->timerclken[i].sp810 = sp810;\r\nsp810->timerclken[i].channel = i;\r\nsp810->timerclken[i].hw.init = &init;\r\nsp810->timerclken[i].clk = clk_register(NULL,\r\n&sp810->timerclken[i].hw);\r\nWARN_ON(IS_ERR(sp810->timerclken[i].clk));\r\n}\r\nof_clk_add_provider(node, clk_sp810_timerclken_of_get, sp810);\r\n}
