static bool is_batt_present(struct charger_manager *cm)\r\n{\r\nunion power_supply_propval val;\r\nbool present = false;\r\nint i, ret;\r\nswitch (cm->desc->battery_present) {\r\ncase CM_BATTERY_PRESENT:\r\npresent = true;\r\nbreak;\r\ncase CM_NO_BATTERY:\r\nbreak;\r\ncase CM_FUEL_GAUGE:\r\nret = cm->fuel_gauge->get_property(cm->fuel_gauge,\r\nPOWER_SUPPLY_PROP_PRESENT, &val);\r\nif (ret == 0 && val.intval)\r\npresent = true;\r\nbreak;\r\ncase CM_CHARGER_STAT:\r\nfor (i = 0; cm->charger_stat[i]; i++) {\r\nret = cm->charger_stat[i]->get_property(\r\ncm->charger_stat[i],\r\nPOWER_SUPPLY_PROP_PRESENT, &val);\r\nif (ret == 0 && val.intval) {\r\npresent = true;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\nreturn present;\r\n}\r\nstatic bool is_ext_pwr_online(struct charger_manager *cm)\r\n{\r\nunion power_supply_propval val;\r\nbool online = false;\r\nint i, ret;\r\nfor (i = 0; cm->charger_stat[i]; i++) {\r\nret = cm->charger_stat[i]->get_property(\r\ncm->charger_stat[i],\r\nPOWER_SUPPLY_PROP_ONLINE, &val);\r\nif (ret == 0 && val.intval) {\r\nonline = true;\r\nbreak;\r\n}\r\n}\r\nreturn online;\r\n}\r\nstatic int get_batt_uV(struct charger_manager *cm, int *uV)\r\n{\r\nunion power_supply_propval val;\r\nint ret;\r\nif (!cm->fuel_gauge)\r\nreturn -ENODEV;\r\nret = cm->fuel_gauge->get_property(cm->fuel_gauge,\r\nPOWER_SUPPLY_PROP_VOLTAGE_NOW, &val);\r\nif (ret)\r\nreturn ret;\r\n*uV = val.intval;\r\nreturn 0;\r\n}\r\nstatic bool is_charging(struct charger_manager *cm)\r\n{\r\nint i, ret;\r\nbool charging = false;\r\nunion power_supply_propval val;\r\nif (!is_batt_present(cm))\r\nreturn false;\r\nfor (i = 0; cm->charger_stat[i]; i++) {\r\nif (cm->emergency_stop)\r\ncontinue;\r\nif (!cm->charger_enabled)\r\ncontinue;\r\nret = cm->charger_stat[i]->get_property(\r\ncm->charger_stat[i],\r\nPOWER_SUPPLY_PROP_ONLINE, &val);\r\nif (ret) {\r\ndev_warn(cm->dev, "Cannot read ONLINE value from %s\n",\r\ncm->desc->psy_charger_stat[i]);\r\ncontinue;\r\n}\r\nif (val.intval == 0)\r\ncontinue;\r\nret = cm->charger_stat[i]->get_property(\r\ncm->charger_stat[i],\r\nPOWER_SUPPLY_PROP_STATUS, &val);\r\nif (ret) {\r\ndev_warn(cm->dev, "Cannot read STATUS value from %s\n",\r\ncm->desc->psy_charger_stat[i]);\r\ncontinue;\r\n}\r\nif (val.intval == POWER_SUPPLY_STATUS_FULL ||\r\nval.intval == POWER_SUPPLY_STATUS_DISCHARGING ||\r\nval.intval == POWER_SUPPLY_STATUS_NOT_CHARGING)\r\ncontinue;\r\ncharging = true;\r\nbreak;\r\n}\r\nreturn charging;\r\n}\r\nstatic bool is_full_charged(struct charger_manager *cm)\r\n{\r\nstruct charger_desc *desc = cm->desc;\r\nunion power_supply_propval val;\r\nint ret = 0;\r\nint uV;\r\nif (!is_batt_present(cm))\r\nreturn false;\r\nif (cm->fuel_gauge && desc->fullbatt_full_capacity > 0) {\r\nval.intval = 0;\r\nret = cm->fuel_gauge->get_property(cm->fuel_gauge,\r\nPOWER_SUPPLY_PROP_CHARGE_FULL, &val);\r\nif (!ret && val.intval > desc->fullbatt_full_capacity)\r\nreturn true;\r\n}\r\nif (desc->fullbatt_uV > 0) {\r\nret = get_batt_uV(cm, &uV);\r\nif (!ret && uV >= desc->fullbatt_uV)\r\nreturn true;\r\n}\r\nif (cm->fuel_gauge && desc->fullbatt_soc > 0) {\r\nval.intval = 0;\r\nret = cm->fuel_gauge->get_property(cm->fuel_gauge,\r\nPOWER_SUPPLY_PROP_CAPACITY, &val);\r\nif (!ret && val.intval >= desc->fullbatt_soc)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool is_polling_required(struct charger_manager *cm)\r\n{\r\nswitch (cm->desc->polling_mode) {\r\ncase CM_POLL_DISABLE:\r\nreturn false;\r\ncase CM_POLL_ALWAYS:\r\nreturn true;\r\ncase CM_POLL_EXTERNAL_POWER_ONLY:\r\nreturn is_ext_pwr_online(cm);\r\ncase CM_POLL_CHARGING_ONLY:\r\nreturn is_charging(cm);\r\ndefault:\r\ndev_warn(cm->dev, "Incorrect polling_mode (%d)\n",\r\ncm->desc->polling_mode);\r\n}\r\nreturn false;\r\n}\r\nstatic int try_charger_enable(struct charger_manager *cm, bool enable)\r\n{\r\nint err = 0, i;\r\nstruct charger_desc *desc = cm->desc;\r\nif (enable == cm->charger_enabled)\r\nreturn 0;\r\nif (enable) {\r\nif (cm->emergency_stop)\r\nreturn -EAGAIN;\r\ncm->charging_start_time = ktime_to_ms(ktime_get());\r\ncm->charging_end_time = 0;\r\nfor (i = 0 ; i < desc->num_charger_regulators ; i++) {\r\nif (desc->charger_regulators[i].externally_control)\r\ncontinue;\r\nerr = regulator_enable(desc->charger_regulators[i].consumer);\r\nif (err < 0) {\r\ndev_warn(cm->dev, "Cannot enable %s regulator\n",\r\ndesc->charger_regulators[i].regulator_name);\r\n}\r\n}\r\n} else {\r\ncm->charging_start_time = 0;\r\ncm->charging_end_time = ktime_to_ms(ktime_get());\r\nfor (i = 0 ; i < desc->num_charger_regulators ; i++) {\r\nif (desc->charger_regulators[i].externally_control)\r\ncontinue;\r\nerr = regulator_disable(desc->charger_regulators[i].consumer);\r\nif (err < 0) {\r\ndev_warn(cm->dev, "Cannot disable %s regulator\n",\r\ndesc->charger_regulators[i].regulator_name);\r\n}\r\n}\r\nfor (i = 0; i < desc->num_charger_regulators; i++) {\r\nif (regulator_is_enabled(\r\ndesc->charger_regulators[i].consumer)) {\r\nregulator_force_disable(\r\ndesc->charger_regulators[i].consumer);\r\ndev_warn(cm->dev, "Disable regulator(%s) forcibly\n",\r\ndesc->charger_regulators[i].regulator_name);\r\n}\r\n}\r\n}\r\nif (!err)\r\ncm->charger_enabled = enable;\r\nreturn err;\r\n}\r\nstatic int try_charger_restart(struct charger_manager *cm)\r\n{\r\nint err;\r\nif (cm->emergency_stop)\r\nreturn -EAGAIN;\r\nerr = try_charger_enable(cm, false);\r\nif (err)\r\nreturn err;\r\nreturn try_charger_enable(cm, true);\r\n}\r\nstatic void uevent_notify(struct charger_manager *cm, const char *event)\r\n{\r\nstatic char env_str[UEVENT_BUF_SIZE + 1] = "";\r\nstatic char env_str_save[UEVENT_BUF_SIZE + 1] = "";\r\nif (cm_suspended) {\r\nif (env_str_save[0] == 0) {\r\nif (!strncmp(env_str, event, UEVENT_BUF_SIZE))\r\nreturn;\r\nstrncpy(env_str_save, event, UEVENT_BUF_SIZE);\r\nreturn;\r\n}\r\nif (!strncmp(env_str_save, event, UEVENT_BUF_SIZE))\r\nreturn;\r\nstrncpy(env_str_save, event, UEVENT_BUF_SIZE);\r\nreturn;\r\n}\r\nif (event == NULL) {\r\nif (!env_str_save[0])\r\nreturn;\r\nstrncpy(env_str, env_str_save, UEVENT_BUF_SIZE);\r\nkobject_uevent(&cm->dev->kobj, KOBJ_CHANGE);\r\nenv_str_save[0] = 0;\r\nreturn;\r\n}\r\nif (!strncmp(env_str, event, UEVENT_BUF_SIZE))\r\nreturn;\r\nstrncpy(env_str, event, UEVENT_BUF_SIZE);\r\nkobject_uevent(&cm->dev->kobj, KOBJ_CHANGE);\r\ndev_info(cm->dev, "%s\n", event);\r\n}\r\nstatic void fullbatt_vchk(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct charger_manager *cm = container_of(dwork,\r\nstruct charger_manager, fullbatt_vchk_work);\r\nstruct charger_desc *desc = cm->desc;\r\nint batt_uV, err, diff;\r\ncm->fullbatt_vchk_jiffies_at = 0;\r\nif (!desc->fullbatt_vchkdrop_uV || !desc->fullbatt_vchkdrop_ms)\r\nreturn;\r\nerr = get_batt_uV(cm, &batt_uV);\r\nif (err) {\r\ndev_err(cm->dev, "%s: get_batt_uV error(%d)\n", __func__, err);\r\nreturn;\r\n}\r\ndiff = desc->fullbatt_uV - batt_uV;\r\nif (diff < 0)\r\nreturn;\r\ndev_info(cm->dev, "VBATT dropped %duV after full-batt\n", diff);\r\nif (diff > desc->fullbatt_vchkdrop_uV) {\r\ntry_charger_restart(cm);\r\nuevent_notify(cm, "Recharging");\r\n}\r\n}\r\nstatic int check_charging_duration(struct charger_manager *cm)\r\n{\r\nstruct charger_desc *desc = cm->desc;\r\nu64 curr = ktime_to_ms(ktime_get());\r\nu64 duration;\r\nint ret = false;\r\nif (!desc->charging_max_duration_ms &&\r\n!desc->discharging_max_duration_ms)\r\nreturn ret;\r\nif (cm->charger_enabled) {\r\nduration = curr - cm->charging_start_time;\r\nif (duration > desc->charging_max_duration_ms) {\r\ndev_info(cm->dev, "Charging duration exceed %lldms\n",\r\ndesc->charging_max_duration_ms);\r\nuevent_notify(cm, "Discharging");\r\ntry_charger_enable(cm, false);\r\nret = true;\r\n}\r\n} else if (is_ext_pwr_online(cm) && !cm->charger_enabled) {\r\nduration = curr - cm->charging_end_time;\r\nif (duration > desc->charging_max_duration_ms &&\r\nis_ext_pwr_online(cm)) {\r\ndev_info(cm->dev, "Discharging duration exceed %lldms\n",\r\ndesc->discharging_max_duration_ms);\r\nuevent_notify(cm, "Recharging");\r\ntry_charger_enable(cm, true);\r\nret = true;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic bool _cm_monitor(struct charger_manager *cm)\r\n{\r\nstruct charger_desc *desc = cm->desc;\r\nint temp = desc->temperature_out_of_range(&cm->last_temp_mC);\r\ndev_dbg(cm->dev, "monitoring (%2.2d.%3.3dC)\n",\r\ncm->last_temp_mC / 1000, cm->last_temp_mC % 1000);\r\nif (temp && cm->emergency_stop)\r\nreturn false;\r\nif (temp) {\r\ncm->emergency_stop = temp;\r\nif (!try_charger_enable(cm, false)) {\r\nif (temp > 0)\r\nuevent_notify(cm, "OVERHEAT");\r\nelse\r\nuevent_notify(cm, "COLD");\r\n}\r\n} else if (!cm->emergency_stop && check_charging_duration(cm)) {\r\ndev_dbg(cm->dev,\r\n"Charging/Discharging duration is out of range\n");\r\n} else if (!cm->emergency_stop && is_ext_pwr_online(cm) &&\r\n!cm->charger_enabled) {\r\nfullbatt_vchk(&cm->fullbatt_vchk_work.work);\r\n} else if (!cm->emergency_stop && is_full_charged(cm) &&\r\ncm->charger_enabled) {\r\ndev_info(cm->dev, "EVENT_HANDLE: Battery Fully Charged\n");\r\nuevent_notify(cm, default_event_names[CM_EVENT_BATT_FULL]);\r\ntry_charger_enable(cm, false);\r\nfullbatt_vchk(&cm->fullbatt_vchk_work.work);\r\n} else {\r\ncm->emergency_stop = 0;\r\nif (is_ext_pwr_online(cm)) {\r\nif (!try_charger_enable(cm, true))\r\nuevent_notify(cm, "CHARGING");\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic bool cm_monitor(void)\r\n{\r\nbool stop = false;\r\nstruct charger_manager *cm;\r\nmutex_lock(&cm_list_mtx);\r\nlist_for_each_entry(cm, &cm_list, entry) {\r\nif (_cm_monitor(cm))\r\nstop = true;\r\n}\r\nmutex_unlock(&cm_list_mtx);\r\nreturn stop;\r\n}\r\nstatic void _setup_polling(struct work_struct *work)\r\n{\r\nunsigned long min = ULONG_MAX;\r\nstruct charger_manager *cm;\r\nbool keep_polling = false;\r\nunsigned long _next_polling;\r\nmutex_lock(&cm_list_mtx);\r\nlist_for_each_entry(cm, &cm_list, entry) {\r\nif (is_polling_required(cm) && cm->desc->polling_interval_ms) {\r\nkeep_polling = true;\r\nif (min > cm->desc->polling_interval_ms)\r\nmin = cm->desc->polling_interval_ms;\r\n}\r\n}\r\npolling_jiffy = msecs_to_jiffies(min);\r\nif (polling_jiffy <= CM_JIFFIES_SMALL)\r\npolling_jiffy = CM_JIFFIES_SMALL + 1;\r\nif (!keep_polling)\r\npolling_jiffy = ULONG_MAX;\r\nif (polling_jiffy == ULONG_MAX)\r\ngoto out;\r\nWARN(cm_wq == NULL, "charger-manager: workqueue not initialized"\r\n". try it later. %s\n", __func__);\r\n_next_polling = jiffies + polling_jiffy;\r\nif (time_before(_next_polling, next_polling)) {\r\nmod_delayed_work(cm_wq, &cm_monitor_work, polling_jiffy);\r\nnext_polling = _next_polling;\r\n} else {\r\nif (queue_delayed_work(cm_wq, &cm_monitor_work, polling_jiffy))\r\nnext_polling = _next_polling;\r\n}\r\nout:\r\nmutex_unlock(&cm_list_mtx);\r\n}\r\nstatic void cm_monitor_poller(struct work_struct *work)\r\n{\r\ncm_monitor();\r\nschedule_work(&setup_polling);\r\n}\r\nstatic void fullbatt_handler(struct charger_manager *cm)\r\n{\r\nstruct charger_desc *desc = cm->desc;\r\nif (!desc->fullbatt_vchkdrop_uV || !desc->fullbatt_vchkdrop_ms)\r\ngoto out;\r\nif (cm_suspended)\r\ndevice_set_wakeup_capable(cm->dev, true);\r\nmod_delayed_work(cm_wq, &cm->fullbatt_vchk_work,\r\nmsecs_to_jiffies(desc->fullbatt_vchkdrop_ms));\r\ncm->fullbatt_vchk_jiffies_at = jiffies + msecs_to_jiffies(\r\ndesc->fullbatt_vchkdrop_ms);\r\nif (cm->fullbatt_vchk_jiffies_at == 0)\r\ncm->fullbatt_vchk_jiffies_at = 1;\r\nout:\r\ndev_info(cm->dev, "EVENT_HANDLE: Battery Fully Charged\n");\r\nuevent_notify(cm, default_event_names[CM_EVENT_BATT_FULL]);\r\n}\r\nstatic void battout_handler(struct charger_manager *cm)\r\n{\r\nif (cm_suspended)\r\ndevice_set_wakeup_capable(cm->dev, true);\r\nif (!is_batt_present(cm)) {\r\ndev_emerg(cm->dev, "Battery Pulled Out!\n");\r\nuevent_notify(cm, default_event_names[CM_EVENT_BATT_OUT]);\r\n} else {\r\nuevent_notify(cm, "Battery Reinserted?");\r\n}\r\n}\r\nstatic void misc_event_handler(struct charger_manager *cm,\r\nenum cm_event_types type)\r\n{\r\nif (cm_suspended)\r\ndevice_set_wakeup_capable(cm->dev, true);\r\nif (is_polling_required(cm) && cm->desc->polling_interval_ms)\r\nschedule_work(&setup_polling);\r\nuevent_notify(cm, default_event_names[type]);\r\n}\r\nstatic int charger_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct charger_manager *cm = container_of(psy,\r\nstruct charger_manager, charger_psy);\r\nstruct charger_desc *desc = cm->desc;\r\nint ret = 0;\r\nint uV;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nif (is_charging(cm))\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nelse if (is_ext_pwr_online(cm))\r\nval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nif (cm->emergency_stop > 0)\r\nval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\r\nelse if (cm->emergency_stop < 0)\r\nval->intval = POWER_SUPPLY_HEALTH_COLD;\r\nelse\r\nval->intval = POWER_SUPPLY_HEALTH_GOOD;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nif (is_batt_present(cm))\r\nval->intval = 1;\r\nelse\r\nval->intval = 0;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nret = get_batt_uV(cm, &val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nret = cm->fuel_gauge->get_property(cm->fuel_gauge,\r\nPOWER_SUPPLY_PROP_CURRENT_NOW, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nif (cm->last_temp_mC == INT_MIN)\r\ndesc->temperature_out_of_range(&cm->last_temp_mC);\r\nval->intval = cm->last_temp_mC / 100;\r\nif (!desc->measure_battery_temp)\r\nret = -ENODEV;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP_AMBIENT:\r\nif (cm->last_temp_mC == INT_MIN)\r\ndesc->temperature_out_of_range(&cm->last_temp_mC);\r\nval->intval = cm->last_temp_mC / 100;\r\nif (desc->measure_battery_temp)\r\nret = -ENODEV;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nif (!cm->fuel_gauge) {\r\nret = -ENODEV;\r\nbreak;\r\n}\r\nif (!is_batt_present(cm)) {\r\nval->intval = 100;\r\nbreak;\r\n}\r\nret = cm->fuel_gauge->get_property(cm->fuel_gauge,\r\nPOWER_SUPPLY_PROP_CAPACITY, val);\r\nif (ret)\r\nbreak;\r\nif (val->intval > 100) {\r\nval->intval = 100;\r\nbreak;\r\n}\r\nif (val->intval < 0)\r\nval->intval = 0;\r\nif (is_charging(cm))\r\nbreak;\r\nret = get_batt_uV(cm, &uV);\r\nif (ret) {\r\nret = 0;\r\nbreak;\r\n}\r\nif (desc->fullbatt_uV > 0 && uV >= desc->fullbatt_uV &&\r\n!is_charging(cm)) {\r\nval->intval = 100;\r\nbreak;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nif (is_ext_pwr_online(cm))\r\nval->intval = 1;\r\nelse\r\nval->intval = 0;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL:\r\nif (is_full_charged(cm))\r\nval->intval = 1;\r\nelse\r\nval->intval = 0;\r\nret = 0;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\nif (is_charging(cm)) {\r\nret = cm->fuel_gauge->get_property(cm->fuel_gauge,\r\nPOWER_SUPPLY_PROP_CHARGE_NOW,\r\nval);\r\nif (ret) {\r\nval->intval = 1;\r\nret = 0;\r\n} else {\r\nval->intval = (val->intval > 0) ?\r\nval->intval : 1;\r\n}\r\n} else {\r\nval->intval = 0;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool cm_setup_timer(void)\r\n{\r\nstruct charger_manager *cm;\r\nunsigned int wakeup_ms = UINT_MAX;\r\nbool ret = false;\r\nmutex_lock(&cm_list_mtx);\r\nlist_for_each_entry(cm, &cm_list, entry) {\r\nunsigned int fbchk_ms = 0;\r\nif (cm->fullbatt_vchk_jiffies_at) {\r\nfbchk_ms = jiffies_to_msecs(cm->fullbatt_vchk_jiffies_at\r\n- jiffies);\r\nif (time_is_before_eq_jiffies(\r\ncm->fullbatt_vchk_jiffies_at) ||\r\nmsecs_to_jiffies(fbchk_ms) < CM_JIFFIES_SMALL) {\r\nfullbatt_vchk(&cm->fullbatt_vchk_work.work);\r\nfbchk_ms = 0;\r\n}\r\n}\r\nCM_MIN_VALID(wakeup_ms, fbchk_ms);\r\nif (!is_polling_required(cm) && !cm->emergency_stop)\r\ncontinue;\r\nif (cm->desc->polling_interval_ms == 0)\r\ncontinue;\r\nCM_MIN_VALID(wakeup_ms, cm->desc->polling_interval_ms);\r\n}\r\nmutex_unlock(&cm_list_mtx);\r\nif (wakeup_ms < UINT_MAX && wakeup_ms > 0) {\r\npr_info("Charger Manager wakeup timer: %u ms\n", wakeup_ms);\r\nif (rtc_dev) {\r\nstruct rtc_wkalrm tmp;\r\nunsigned long time, now;\r\nunsigned long add = DIV_ROUND_UP(wakeup_ms, 1000);\r\ntmp.enabled = 1;\r\nrtc_read_time(rtc_dev, &tmp.time);\r\nrtc_tm_to_time(&tmp.time, &now);\r\nif (add < CM_RTC_SMALL)\r\nadd = CM_RTC_SMALL;\r\ntime = now + add;\r\nret = true;\r\nif (rtc_wkalarm_save.enabled &&\r\nrtc_wkalarm_save_time &&\r\nrtc_wkalarm_save_time < time) {\r\nif (rtc_wkalarm_save_time < now + CM_RTC_SMALL)\r\ntime = now + CM_RTC_SMALL;\r\nelse\r\ntime = rtc_wkalarm_save_time;\r\nret = false;\r\n}\r\npr_info("Waking up after %lu secs\n", time - now);\r\nrtc_time_to_tm(time, &tmp.time);\r\nrtc_set_alarm(rtc_dev, &tmp);\r\ncm_suspend_duration_ms += wakeup_ms;\r\nreturn ret;\r\n}\r\n}\r\nif (rtc_dev)\r\nrtc_set_alarm(rtc_dev, &rtc_wkalarm_save);\r\nreturn false;\r\n}\r\nstatic void _cm_fbchk_in_suspend(struct charger_manager *cm)\r\n{\r\nunsigned long jiffy_now = jiffies;\r\nif (!cm->fullbatt_vchk_jiffies_at)\r\nreturn;\r\nif (g_desc && g_desc->assume_timer_stops_in_suspend)\r\njiffy_now += msecs_to_jiffies(cm_suspend_duration_ms);\r\njiffy_now += CM_JIFFIES_SMALL;\r\nif (time_after_eq(jiffy_now, cm->fullbatt_vchk_jiffies_at))\r\nfullbatt_vchk(&cm->fullbatt_vchk_work.work);\r\n}\r\nbool cm_suspend_again(void)\r\n{\r\nstruct charger_manager *cm;\r\nbool ret = false;\r\nif (!g_desc || !g_desc->rtc_only_wakeup || !g_desc->rtc_only_wakeup() ||\r\n!cm_rtc_set)\r\nreturn false;\r\nif (cm_monitor())\r\ngoto out;\r\nret = true;\r\nmutex_lock(&cm_list_mtx);\r\nlist_for_each_entry(cm, &cm_list, entry) {\r\n_cm_fbchk_in_suspend(cm);\r\nif (cm->status_save_ext_pwr_inserted != is_ext_pwr_online(cm) ||\r\ncm->status_save_batt != is_batt_present(cm)) {\r\nret = false;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&cm_list_mtx);\r\ncm_rtc_set = cm_setup_timer();\r\nout:\r\nif (rtc_wkalarm_save.enabled) {\r\nunsigned long now;\r\nstruct rtc_time tmp;\r\nrtc_read_time(rtc_dev, &tmp);\r\nrtc_tm_to_time(&tmp, &now);\r\nif (rtc_wkalarm_save_time &&\r\nnow + CM_RTC_SMALL >= rtc_wkalarm_save_time)\r\nreturn false;\r\n}\r\nreturn ret;\r\n}\r\nint setup_charger_manager(struct charger_global_desc *gd)\r\n{\r\nif (!gd)\r\nreturn -EINVAL;\r\nif (rtc_dev)\r\nrtc_class_close(rtc_dev);\r\nrtc_dev = NULL;\r\ng_desc = NULL;\r\nif (!gd->rtc_only_wakeup) {\r\npr_err("The callback rtc_only_wakeup is not given\n");\r\nreturn -EINVAL;\r\n}\r\nif (gd->rtc_name) {\r\nrtc_dev = rtc_class_open(gd->rtc_name);\r\nif (IS_ERR_OR_NULL(rtc_dev)) {\r\nrtc_dev = NULL;\r\n}\r\n} else {\r\npr_warn("No wakeup timer is given for charger manager. "\r\n"In-suspend monitoring won't work.\n");\r\n}\r\ng_desc = gd;\r\nreturn 0;\r\n}\r\nstatic void charger_extcon_work(struct work_struct *work)\r\n{\r\nstruct charger_cable *cable =\r\ncontainer_of(work, struct charger_cable, wq);\r\nint ret;\r\nif (cable->attached && cable->min_uA != 0 && cable->max_uA != 0) {\r\nret = regulator_set_current_limit(cable->charger->consumer,\r\ncable->min_uA, cable->max_uA);\r\nif (ret < 0) {\r\npr_err("Cannot set current limit of %s (%s)\n",\r\ncable->charger->regulator_name, cable->name);\r\nreturn;\r\n}\r\npr_info("Set current limit of %s : %duA ~ %duA\n",\r\ncable->charger->regulator_name,\r\ncable->min_uA, cable->max_uA);\r\n}\r\ntry_charger_enable(cable->cm, cable->attached);\r\n}\r\nstatic int charger_extcon_notifier(struct notifier_block *self,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct charger_cable *cable =\r\ncontainer_of(self, struct charger_cable, nb);\r\ncable->attached = event;\r\nif (cable->attached && is_polling_required(cable->cm)) {\r\ncancel_work_sync(&setup_polling);\r\nschedule_work(&setup_polling);\r\n}\r\nschedule_work(&cable->wq);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int charger_extcon_init(struct charger_manager *cm,\r\nstruct charger_cable *cable)\r\n{\r\nint ret = 0;\r\nINIT_WORK(&cable->wq, charger_extcon_work);\r\ncable->nb.notifier_call = charger_extcon_notifier;\r\nret = extcon_register_interest(&cable->extcon_dev,\r\ncable->extcon_name, cable->name, &cable->nb);\r\nif (ret < 0) {\r\npr_info("Cannot register extcon_dev for %s(cable: %s)\n",\r\ncable->extcon_name, cable->name);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int charger_manager_register_extcon(struct charger_manager *cm)\r\n{\r\nstruct charger_desc *desc = cm->desc;\r\nstruct charger_regulator *charger;\r\nint ret = 0;\r\nint i;\r\nint j;\r\nfor (i = 0; i < desc->num_charger_regulators; i++) {\r\ncharger = &desc->charger_regulators[i];\r\ncharger->consumer = regulator_get(cm->dev,\r\ncharger->regulator_name);\r\nif (IS_ERR(charger->consumer)) {\r\ndev_err(cm->dev, "Cannot find charger(%s)\n",\r\ncharger->regulator_name);\r\nreturn PTR_ERR(charger->consumer);\r\n}\r\ncharger->cm = cm;\r\nfor (j = 0; j < charger->num_cables; j++) {\r\nstruct charger_cable *cable = &charger->cables[j];\r\nret = charger_extcon_init(cm, cable);\r\nif (ret < 0) {\r\ndev_err(cm->dev, "Cannot initialize charger(%s)\n",\r\ncharger->regulator_name);\r\ngoto err;\r\n}\r\ncable->charger = charger;\r\ncable->cm = cm;\r\n}\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic ssize_t charger_name_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct charger_regulator *charger\r\n= container_of(attr, struct charger_regulator, attr_name);\r\nreturn sprintf(buf, "%s\n", charger->regulator_name);\r\n}\r\nstatic ssize_t charger_state_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct charger_regulator *charger\r\n= container_of(attr, struct charger_regulator, attr_state);\r\nint state = 0;\r\nif (!charger->externally_control)\r\nstate = regulator_is_enabled(charger->consumer);\r\nreturn sprintf(buf, "%s\n", state ? "enabled" : "disabled");\r\n}\r\nstatic ssize_t charger_externally_control_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct charger_regulator *charger = container_of(attr,\r\nstruct charger_regulator, attr_externally_control);\r\nreturn sprintf(buf, "%d\n", charger->externally_control);\r\n}\r\nstatic ssize_t charger_externally_control_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct charger_regulator *charger\r\n= container_of(attr, struct charger_regulator,\r\nattr_externally_control);\r\nstruct charger_manager *cm = charger->cm;\r\nstruct charger_desc *desc = cm->desc;\r\nint i;\r\nint ret;\r\nint externally_control;\r\nint chargers_externally_control = 1;\r\nret = sscanf(buf, "%d", &externally_control);\r\nif (ret == 0) {\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nif (!externally_control) {\r\ncharger->externally_control = 0;\r\nreturn count;\r\n}\r\nfor (i = 0; i < desc->num_charger_regulators; i++) {\r\nif (&desc->charger_regulators[i] != charger &&\r\n!desc->charger_regulators[i].externally_control) {\r\nchargers_externally_control = 0;\r\nbreak;\r\n}\r\n}\r\nif (!chargers_externally_control) {\r\nif (cm->charger_enabled) {\r\ntry_charger_enable(charger->cm, false);\r\ncharger->externally_control = externally_control;\r\ntry_charger_enable(charger->cm, true);\r\n} else {\r\ncharger->externally_control = externally_control;\r\n}\r\n} else {\r\ndev_warn(cm->dev,\r\n"'%s' regulator should be controlled in charger-manager because charger-manager must need at least one charger for charging\n",\r\ncharger->regulator_name);\r\n}\r\nreturn count;\r\n}\r\nstatic int charger_manager_register_sysfs(struct charger_manager *cm)\r\n{\r\nstruct charger_desc *desc = cm->desc;\r\nstruct charger_regulator *charger;\r\nint chargers_externally_control = 1;\r\nchar buf[11];\r\nchar *str;\r\nint ret = 0;\r\nint i;\r\nfor (i = 0; i < desc->num_charger_regulators; i++) {\r\ncharger = &desc->charger_regulators[i];\r\nsnprintf(buf, 10, "charger.%d", i);\r\nstr = kzalloc(sizeof(char) * (strlen(buf) + 1), GFP_KERNEL);\r\nif (!str) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nstrcpy(str, buf);\r\ncharger->attrs[0] = &charger->attr_name.attr;\r\ncharger->attrs[1] = &charger->attr_state.attr;\r\ncharger->attrs[2] = &charger->attr_externally_control.attr;\r\ncharger->attrs[3] = NULL;\r\ncharger->attr_g.name = str;\r\ncharger->attr_g.attrs = charger->attrs;\r\nsysfs_attr_init(&charger->attr_name.attr);\r\ncharger->attr_name.attr.name = "name";\r\ncharger->attr_name.attr.mode = 0444;\r\ncharger->attr_name.show = charger_name_show;\r\nsysfs_attr_init(&charger->attr_state.attr);\r\ncharger->attr_state.attr.name = "state";\r\ncharger->attr_state.attr.mode = 0444;\r\ncharger->attr_state.show = charger_state_show;\r\nsysfs_attr_init(&charger->attr_externally_control.attr);\r\ncharger->attr_externally_control.attr.name\r\n= "externally_control";\r\ncharger->attr_externally_control.attr.mode = 0644;\r\ncharger->attr_externally_control.show\r\n= charger_externally_control_show;\r\ncharger->attr_externally_control.store\r\n= charger_externally_control_store;\r\nif (!desc->charger_regulators[i].externally_control ||\r\n!chargers_externally_control)\r\nchargers_externally_control = 0;\r\ndev_info(cm->dev, "'%s' regulator's externally_control is %d\n",\r\ncharger->regulator_name, charger->externally_control);\r\nret = sysfs_create_group(&cm->charger_psy.dev->kobj,\r\n&charger->attr_g);\r\nif (ret < 0) {\r\ndev_err(cm->dev, "Cannot create sysfs entry of %s regulator\n",\r\ncharger->regulator_name);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\n}\r\nif (chargers_externally_control) {\r\ndev_err(cm->dev, "Cannot register regulator because charger-manager must need at least one charger for charging battery\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int charger_manager_probe(struct platform_device *pdev)\r\n{\r\nstruct charger_desc *desc = dev_get_platdata(&pdev->dev);\r\nstruct charger_manager *cm;\r\nint ret = 0, i = 0;\r\nint j = 0;\r\nunion power_supply_propval val;\r\nif (g_desc && !rtc_dev && g_desc->rtc_name) {\r\nrtc_dev = rtc_class_open(g_desc->rtc_name);\r\nif (IS_ERR_OR_NULL(rtc_dev)) {\r\nrtc_dev = NULL;\r\ndev_err(&pdev->dev, "Cannot get RTC %s\n",\r\ng_desc->rtc_name);\r\nret = -ENODEV;\r\ngoto err_alloc;\r\n}\r\n}\r\nif (!desc) {\r\ndev_err(&pdev->dev, "No platform data (desc) found\n");\r\nret = -ENODEV;\r\ngoto err_alloc;\r\n}\r\ncm = kzalloc(sizeof(struct charger_manager), GFP_KERNEL);\r\nif (!cm) {\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\ncm->dev = &pdev->dev;\r\ncm->desc = kmemdup(desc, sizeof(struct charger_desc), GFP_KERNEL);\r\nif (!cm->desc) {\r\nret = -ENOMEM;\r\ngoto err_alloc_desc;\r\n}\r\ncm->last_temp_mC = INT_MIN;\r\nif (desc->fullbatt_uV == 0) {\r\ndev_info(&pdev->dev, "Ignoring full-battery voltage threshold as it is not supplied\n");\r\n}\r\nif (!desc->fullbatt_vchkdrop_ms || !desc->fullbatt_vchkdrop_uV) {\r\ndev_info(&pdev->dev, "Disabling full-battery voltage drop checking mechanism as it is not supplied\n");\r\ndesc->fullbatt_vchkdrop_ms = 0;\r\ndesc->fullbatt_vchkdrop_uV = 0;\r\n}\r\nif (desc->fullbatt_soc == 0) {\r\ndev_info(&pdev->dev, "Ignoring full-battery soc(state of charge) threshold as it is not supplied\n");\r\n}\r\nif (desc->fullbatt_full_capacity == 0) {\r\ndev_info(&pdev->dev, "Ignoring full-battery full capacity threshold as it is not supplied\n");\r\n}\r\nif (!desc->charger_regulators || desc->num_charger_regulators < 1) {\r\nret = -EINVAL;\r\ndev_err(&pdev->dev, "charger_regulators undefined\n");\r\ngoto err_no_charger;\r\n}\r\nif (!desc->psy_charger_stat || !desc->psy_charger_stat[0]) {\r\ndev_err(&pdev->dev, "No power supply defined\n");\r\nret = -EINVAL;\r\ngoto err_no_charger_stat;\r\n}\r\nwhile (desc->psy_charger_stat[i])\r\ni++;\r\ncm->charger_stat = kzalloc(sizeof(struct power_supply *) * (i + 1),\r\nGFP_KERNEL);\r\nif (!cm->charger_stat) {\r\nret = -ENOMEM;\r\ngoto err_no_charger_stat;\r\n}\r\nfor (i = 0; desc->psy_charger_stat[i]; i++) {\r\ncm->charger_stat[i] = power_supply_get_by_name(\r\ndesc->psy_charger_stat[i]);\r\nif (!cm->charger_stat[i]) {\r\ndev_err(&pdev->dev, "Cannot find power supply \"%s\"\n",\r\ndesc->psy_charger_stat[i]);\r\nret = -ENODEV;\r\ngoto err_chg_stat;\r\n}\r\n}\r\ncm->fuel_gauge = power_supply_get_by_name(desc->psy_fuel_gauge);\r\nif (!cm->fuel_gauge) {\r\ndev_err(&pdev->dev, "Cannot find power supply \"%s\"\n",\r\ndesc->psy_fuel_gauge);\r\nret = -ENODEV;\r\ngoto err_chg_stat;\r\n}\r\nif (desc->polling_interval_ms == 0 ||\r\nmsecs_to_jiffies(desc->polling_interval_ms) <= CM_JIFFIES_SMALL) {\r\ndev_err(&pdev->dev, "polling_interval_ms is too small\n");\r\nret = -EINVAL;\r\ngoto err_chg_stat;\r\n}\r\nif (!desc->temperature_out_of_range) {\r\ndev_err(&pdev->dev, "there is no temperature_out_of_range\n");\r\nret = -EINVAL;\r\ngoto err_chg_stat;\r\n}\r\nif (!desc->charging_max_duration_ms ||\r\n!desc->discharging_max_duration_ms) {\r\ndev_info(&pdev->dev, "Cannot limit charging duration checking mechanism to prevent overcharge/overheat and control discharging duration\n");\r\ndesc->charging_max_duration_ms = 0;\r\ndesc->discharging_max_duration_ms = 0;\r\n}\r\nplatform_set_drvdata(pdev, cm);\r\nmemcpy(&cm->charger_psy, &psy_default, sizeof(psy_default));\r\nif (!desc->psy_name)\r\nstrncpy(cm->psy_name_buf, psy_default.name, PSY_NAME_MAX);\r\nelse\r\nstrncpy(cm->psy_name_buf, desc->psy_name, PSY_NAME_MAX);\r\ncm->charger_psy.name = cm->psy_name_buf;\r\ncm->charger_psy.properties = kzalloc(sizeof(enum power_supply_property)\r\n* (ARRAY_SIZE(default_charger_props) +\r\nNUM_CHARGER_PSY_OPTIONAL),\r\nGFP_KERNEL);\r\nif (!cm->charger_psy.properties) {\r\nret = -ENOMEM;\r\ngoto err_chg_stat;\r\n}\r\nmemcpy(cm->charger_psy.properties, default_charger_props,\r\nsizeof(enum power_supply_property) *\r\nARRAY_SIZE(default_charger_props));\r\ncm->charger_psy.num_properties = psy_default.num_properties;\r\nif (!cm->fuel_gauge->get_property(cm->fuel_gauge,\r\nPOWER_SUPPLY_PROP_CHARGE_NOW, &val)) {\r\ncm->charger_psy.properties[cm->charger_psy.num_properties] =\r\nPOWER_SUPPLY_PROP_CHARGE_NOW;\r\ncm->charger_psy.num_properties++;\r\n}\r\nif (!cm->fuel_gauge->get_property(cm->fuel_gauge,\r\nPOWER_SUPPLY_PROP_CURRENT_NOW,\r\n&val)) {\r\ncm->charger_psy.properties[cm->charger_psy.num_properties] =\r\nPOWER_SUPPLY_PROP_CURRENT_NOW;\r\ncm->charger_psy.num_properties++;\r\n}\r\nif (desc->measure_battery_temp) {\r\ncm->charger_psy.properties[cm->charger_psy.num_properties] =\r\nPOWER_SUPPLY_PROP_TEMP;\r\ncm->charger_psy.num_properties++;\r\n} else {\r\ncm->charger_psy.properties[cm->charger_psy.num_properties] =\r\nPOWER_SUPPLY_PROP_TEMP_AMBIENT;\r\ncm->charger_psy.num_properties++;\r\n}\r\nINIT_DELAYED_WORK(&cm->fullbatt_vchk_work, fullbatt_vchk);\r\nret = power_supply_register(NULL, &cm->charger_psy);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Cannot register charger-manager with name \"%s\"\n",\r\ncm->charger_psy.name);\r\ngoto err_register;\r\n}\r\nret = charger_manager_register_extcon(cm);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Cannot initialize extcon device\n");\r\ngoto err_reg_extcon;\r\n}\r\nret = charger_manager_register_sysfs(cm);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"Cannot initialize sysfs entry of regulator\n");\r\ngoto err_reg_sysfs;\r\n}\r\nmutex_lock(&cm_list_mtx);\r\nlist_add(&cm->entry, &cm_list);\r\nmutex_unlock(&cm_list_mtx);\r\ndevice_init_wakeup(&pdev->dev, true);\r\ndevice_set_wakeup_capable(&pdev->dev, false);\r\nschedule_work(&setup_polling);\r\nreturn 0;\r\nerr_reg_sysfs:\r\nfor (i = 0; i < desc->num_charger_regulators; i++) {\r\nstruct charger_regulator *charger;\r\ncharger = &desc->charger_regulators[i];\r\nsysfs_remove_group(&cm->charger_psy.dev->kobj,\r\n&charger->attr_g);\r\nkfree(charger->attr_g.name);\r\n}\r\nerr_reg_extcon:\r\nfor (i = 0; i < desc->num_charger_regulators; i++) {\r\nstruct charger_regulator *charger;\r\ncharger = &desc->charger_regulators[i];\r\nfor (j = 0; j < charger->num_cables; j++) {\r\nstruct charger_cable *cable = &charger->cables[j];\r\nif (cable->extcon_dev.edev)\r\nextcon_unregister_interest(&cable->extcon_dev);\r\n}\r\nregulator_put(desc->charger_regulators[i].consumer);\r\n}\r\npower_supply_unregister(&cm->charger_psy);\r\nerr_register:\r\nkfree(cm->charger_psy.properties);\r\nerr_chg_stat:\r\nkfree(cm->charger_stat);\r\nerr_no_charger_stat:\r\nerr_no_charger:\r\nkfree(cm->desc);\r\nerr_alloc_desc:\r\nkfree(cm);\r\nerr_alloc:\r\nreturn ret;\r\n}\r\nstatic int charger_manager_remove(struct platform_device *pdev)\r\n{\r\nstruct charger_manager *cm = platform_get_drvdata(pdev);\r\nstruct charger_desc *desc = cm->desc;\r\nint i = 0;\r\nint j = 0;\r\nmutex_lock(&cm_list_mtx);\r\nlist_del(&cm->entry);\r\nmutex_unlock(&cm_list_mtx);\r\ncancel_work_sync(&setup_polling);\r\ncancel_delayed_work_sync(&cm_monitor_work);\r\nfor (i = 0 ; i < desc->num_charger_regulators ; i++) {\r\nstruct charger_regulator *charger\r\n= &desc->charger_regulators[i];\r\nfor (j = 0 ; j < charger->num_cables ; j++) {\r\nstruct charger_cable *cable = &charger->cables[j];\r\nextcon_unregister_interest(&cable->extcon_dev);\r\n}\r\n}\r\nfor (i = 0 ; i < desc->num_charger_regulators ; i++)\r\nregulator_put(desc->charger_regulators[i].consumer);\r\npower_supply_unregister(&cm->charger_psy);\r\ntry_charger_enable(cm, false);\r\nkfree(cm->charger_psy.properties);\r\nkfree(cm->charger_stat);\r\nkfree(cm->desc);\r\nkfree(cm);\r\nreturn 0;\r\n}\r\nstatic int cm_suspend_noirq(struct device *dev)\r\n{\r\nint ret = 0;\r\nif (device_may_wakeup(dev)) {\r\ndevice_set_wakeup_capable(dev, false);\r\nret = -EAGAIN;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cm_suspend_prepare(struct device *dev)\r\n{\r\nstruct charger_manager *cm = dev_get_drvdata(dev);\r\nif (!cm_suspended) {\r\nif (rtc_dev) {\r\nstruct rtc_time tmp;\r\nunsigned long now;\r\nrtc_read_alarm(rtc_dev, &rtc_wkalarm_save);\r\nrtc_read_time(rtc_dev, &tmp);\r\nif (rtc_wkalarm_save.enabled) {\r\nrtc_tm_to_time(&rtc_wkalarm_save.time,\r\n&rtc_wkalarm_save_time);\r\nrtc_tm_to_time(&tmp, &now);\r\nif (now > rtc_wkalarm_save_time)\r\nrtc_wkalarm_save_time = 0;\r\n} else {\r\nrtc_wkalarm_save_time = 0;\r\n}\r\n}\r\ncm_suspended = true;\r\n}\r\ncancel_delayed_work(&cm->fullbatt_vchk_work);\r\ncm->status_save_ext_pwr_inserted = is_ext_pwr_online(cm);\r\ncm->status_save_batt = is_batt_present(cm);\r\nif (!cm_rtc_set) {\r\ncm_suspend_duration_ms = 0;\r\ncm_rtc_set = cm_setup_timer();\r\n}\r\nreturn 0;\r\n}\r\nstatic void cm_suspend_complete(struct device *dev)\r\n{\r\nstruct charger_manager *cm = dev_get_drvdata(dev);\r\nif (cm_suspended) {\r\nif (rtc_dev) {\r\nstruct rtc_wkalrm tmp;\r\nrtc_read_alarm(rtc_dev, &tmp);\r\nrtc_wkalarm_save.pending = tmp.pending;\r\nrtc_set_alarm(rtc_dev, &rtc_wkalarm_save);\r\n}\r\ncm_suspended = false;\r\ncm_rtc_set = false;\r\n}\r\nif (cm->fullbatt_vchk_jiffies_at) {\r\nunsigned long delay = 0;\r\nunsigned long now = jiffies + CM_JIFFIES_SMALL;\r\nif (time_after_eq(now, cm->fullbatt_vchk_jiffies_at)) {\r\ndelay = (unsigned long)((long)now\r\n- (long)(cm->fullbatt_vchk_jiffies_at));\r\ndelay = jiffies_to_msecs(delay);\r\n} else {\r\ndelay = 0;\r\n}\r\nif (g_desc && g_desc->assume_timer_stops_in_suspend) {\r\nif (delay > cm_suspend_duration_ms)\r\ndelay -= cm_suspend_duration_ms;\r\nelse\r\ndelay = 0;\r\n}\r\nqueue_delayed_work(cm_wq, &cm->fullbatt_vchk_work,\r\nmsecs_to_jiffies(delay));\r\n}\r\ndevice_set_wakeup_capable(cm->dev, false);\r\nuevent_notify(cm, NULL);\r\n}\r\nstatic int __init charger_manager_init(void)\r\n{\r\ncm_wq = create_freezable_workqueue("charger_manager");\r\nINIT_DELAYED_WORK(&cm_monitor_work, cm_monitor_poller);\r\nreturn platform_driver_register(&charger_manager_driver);\r\n}\r\nstatic void __exit charger_manager_cleanup(void)\r\n{\r\ndestroy_workqueue(cm_wq);\r\ncm_wq = NULL;\r\nplatform_driver_unregister(&charger_manager_driver);\r\n}\r\nstatic bool find_power_supply(struct charger_manager *cm,\r\nstruct power_supply *psy)\r\n{\r\nint i;\r\nbool found = false;\r\nfor (i = 0; cm->charger_stat[i]; i++) {\r\nif (psy == cm->charger_stat[i]) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nreturn found;\r\n}\r\nvoid cm_notify_event(struct power_supply *psy, enum cm_event_types type,\r\nchar *msg)\r\n{\r\nstruct charger_manager *cm;\r\nbool found_power_supply = false;\r\nif (psy == NULL)\r\nreturn;\r\nmutex_lock(&cm_list_mtx);\r\nlist_for_each_entry(cm, &cm_list, entry) {\r\nfound_power_supply = find_power_supply(cm, psy);\r\nif (found_power_supply)\r\nbreak;\r\n}\r\nmutex_unlock(&cm_list_mtx);\r\nif (!found_power_supply)\r\nreturn;\r\nswitch (type) {\r\ncase CM_EVENT_BATT_FULL:\r\nfullbatt_handler(cm);\r\nbreak;\r\ncase CM_EVENT_BATT_OUT:\r\nbattout_handler(cm);\r\nbreak;\r\ncase CM_EVENT_BATT_IN:\r\ncase CM_EVENT_EXT_PWR_IN_OUT ... CM_EVENT_CHG_START_STOP:\r\nmisc_event_handler(cm, type);\r\nbreak;\r\ncase CM_EVENT_UNKNOWN:\r\ncase CM_EVENT_OTHERS:\r\nuevent_notify(cm, msg ? msg : default_event_names[type]);\r\nbreak;\r\ndefault:\r\ndev_err(cm->dev, "%s: type not specified\n", __func__);\r\nbreak;\r\n}\r\n}
