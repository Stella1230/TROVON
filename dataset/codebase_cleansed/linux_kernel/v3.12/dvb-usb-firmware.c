static int usb_cypress_writemem(struct usb_device *udev,u16 addr,u8 *data, u8 len)\r\n{\r\nreturn usb_control_msg(udev, usb_sndctrlpipe(udev,0),\r\n0xa0, USB_TYPE_VENDOR, addr, 0x00, data, len, 5000);\r\n}\r\nint usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\r\n{\r\nstruct hexline hx;\r\nu8 reset;\r\nint ret,pos=0;\r\nreset = 1;\r\nif ((ret = usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1)) != 1)\r\nerr("could not stop the USB controller CPU.");\r\nwhile ((ret = dvb_usb_get_hexline(fw,&hx,&pos)) > 0) {\r\ndeb_fw("writing to address 0x%04x (buffer: 0x%02x %02x)\n",hx.addr,hx.len,hx.chk);\r\nret = usb_cypress_writemem(udev,hx.addr,hx.data,hx.len);\r\nif (ret != hx.len) {\r\nerr("error while transferring firmware "\r\n"(transferred size: %d, block size: %d)",\r\nret,hx.len);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nif (ret < 0) {\r\nerr("firmware download failed at %d with %d",pos,ret);\r\nreturn ret;\r\n}\r\nif (ret == 0) {\r\nreset = 0;\r\nif (ret || usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1) != 1) {\r\nerr("could not restart the USB controller CPU.");\r\nret = -EINVAL;\r\n}\r\n} else\r\nret = -EIO;\r\nreturn ret;\r\n}\r\nint dvb_usb_download_firmware(struct usb_device *udev, struct dvb_usb_device_properties *props)\r\n{\r\nint ret;\r\nconst struct firmware *fw = NULL;\r\nif ((ret = request_firmware(&fw, props->firmware, &udev->dev)) != 0) {\r\nerr("did not find the firmware file. (%s) "\r\n"Please see linux/Documentation/dvb/ for more details on firmware-problems. (%d)",\r\nprops->firmware,ret);\r\nreturn ret;\r\n}\r\ninfo("downloading firmware from file '%s'",props->firmware);\r\nswitch (props->usb_ctrl) {\r\ncase CYPRESS_AN2135:\r\ncase CYPRESS_AN2235:\r\ncase CYPRESS_FX2:\r\nret = usb_cypress_load_firmware(udev, fw, props->usb_ctrl);\r\nbreak;\r\ncase DEVICE_SPECIFIC:\r\nif (props->download_firmware)\r\nret = props->download_firmware(udev,fw);\r\nelse {\r\nerr("BUG: driver didn't specified a download_firmware-callback, although it claims to have a DEVICE_SPECIFIC one.");\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nint dvb_usb_get_hexline(const struct firmware *fw, struct hexline *hx,\r\nint *pos)\r\n{\r\nu8 *b = (u8 *) &fw->data[*pos];\r\nint data_offs = 4;\r\nif (*pos >= fw->size)\r\nreturn 0;\r\nmemset(hx,0,sizeof(struct hexline));\r\nhx->len = b[0];\r\nif ((*pos + hx->len + 4) >= fw->size)\r\nreturn -EINVAL;\r\nhx->addr = b[1] | (b[2] << 8);\r\nhx->type = b[3];\r\nif (hx->type == 0x04) {\r\nhx->addr |= (b[4] << 24) | (b[5] << 16);\r\n}\r\nmemcpy(hx->data,&b[data_offs],hx->len);\r\nhx->chk = b[hx->len + data_offs];\r\n*pos += hx->len + 5;\r\nreturn *pos;\r\n}
