static void kgdb_nmi_console_write(struct console *co, const char *s, uint c)\r\n{\r\nint i;\r\nif (!kgdb_nmi_tty_enabled || atomic_read(&kgdb_active) >= 0)\r\nreturn;\r\nfor (i = 0; i < c; i++)\r\ndbg_io_ops->write_char(s[i]);\r\n}\r\nstatic struct tty_driver *kgdb_nmi_console_device(struct console *co, int *idx)\r\n{\r\n*idx = co->index;\r\nreturn kgdb_nmi_tty_driver;\r\n}\r\nstatic struct kgdb_nmi_tty_priv *kgdb_nmi_port_to_priv(struct tty_port *port)\r\n{\r\nreturn container_of(port, struct kgdb_nmi_tty_priv, port);\r\n}\r\nstatic void kgdb_tty_poke(void)\r\n{\r\ntick_program_event(ktime_get(), 0);\r\n}\r\nstatic inline void kgdb_tty_poke(void) {}\r\nstatic void kgdb_tty_recv(int ch)\r\n{\r\nstruct kgdb_nmi_tty_priv *priv;\r\nchar c = ch;\r\nif (!kgdb_nmi_port || ch < 0)\r\nreturn;\r\npriv = kgdb_nmi_port_to_priv(kgdb_nmi_port);\r\nkfifo_in(&priv->fifo, &c, 1);\r\nkgdb_tty_poke();\r\n}\r\nstatic int kgdb_nmi_poll_one_knock(void)\r\n{\r\nstatic int n;\r\nint c = -1;\r\nconst char *magic = kgdb_nmi_magic;\r\nsize_t m = strlen(magic);\r\nbool printch = 0;\r\nc = dbg_io_ops->read_char();\r\nif (c == NO_POLL_CHAR)\r\nreturn c;\r\nif (!kgdb_nmi_knock && (c == '\r' || c == '\n')) {\r\nreturn 1;\r\n} else if (c == magic[n]) {\r\nn = (n + 1) % m;\r\nif (!n)\r\nreturn 1;\r\nprintch = 1;\r\n} else {\r\nn = 0;\r\n}\r\nif (kgdb_nmi_tty_enabled) {\r\nkgdb_tty_recv(c);\r\nreturn 0;\r\n}\r\nif (printch) {\r\nkdb_printf("%c", c);\r\nreturn 0;\r\n}\r\nkdb_printf("\r%s %s to enter the debugger> %*s",\r\nkgdb_nmi_knock ? "Type" : "Hit",\r\nkgdb_nmi_knock ? magic : "<return>", (int)m, "");\r\nwhile (m--)\r\nkdb_printf("\b");\r\nreturn 0;\r\n}\r\nbool kgdb_nmi_poll_knock(void)\r\n{\r\nif (kgdb_nmi_knock < 0)\r\nreturn 1;\r\nwhile (1) {\r\nint ret;\r\nret = kgdb_nmi_poll_one_knock();\r\nif (ret == NO_POLL_CHAR)\r\nreturn 0;\r\nelse if (ret == 1)\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nstatic void kgdb_nmi_tty_receiver(unsigned long data)\r\n{\r\nstruct kgdb_nmi_tty_priv *priv = (void *)data;\r\nchar ch;\r\ntasklet_schedule(&priv->tlet);\r\nif (likely(!kgdb_nmi_tty_enabled || !kfifo_len(&priv->fifo)))\r\nreturn;\r\nwhile (kfifo_out(&priv->fifo, &ch, 1))\r\ntty_insert_flip_char(&priv->port, ch, TTY_NORMAL);\r\ntty_flip_buffer_push(&priv->port);\r\n}\r\nstatic int kgdb_nmi_tty_activate(struct tty_port *port, struct tty_struct *tty)\r\n{\r\nstruct kgdb_nmi_tty_priv *priv = tty->driver_data;\r\nkgdb_nmi_port = port;\r\ntasklet_schedule(&priv->tlet);\r\nreturn 0;\r\n}\r\nstatic void kgdb_nmi_tty_shutdown(struct tty_port *port)\r\n{\r\nstruct kgdb_nmi_tty_priv *priv = port->tty->driver_data;\r\ntasklet_kill(&priv->tlet);\r\nkgdb_nmi_port = NULL;\r\n}\r\nstatic int kgdb_nmi_tty_install(struct tty_driver *drv, struct tty_struct *tty)\r\n{\r\nstruct kgdb_nmi_tty_priv *priv;\r\nint ret;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nINIT_KFIFO(priv->fifo);\r\ntasklet_init(&priv->tlet, kgdb_nmi_tty_receiver, (unsigned long)priv);\r\ntty_port_init(&priv->port);\r\npriv->port.ops = &kgdb_nmi_tty_port_ops;\r\ntty->driver_data = priv;\r\nret = tty_port_install(&priv->port, drv, tty);\r\nif (ret) {\r\npr_err("%s: can't install tty port: %d\n", __func__, ret);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ntty_port_destroy(&priv->port);\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nstatic void kgdb_nmi_tty_cleanup(struct tty_struct *tty)\r\n{\r\nstruct kgdb_nmi_tty_priv *priv = tty->driver_data;\r\ntty->driver_data = NULL;\r\ntty_port_destroy(&priv->port);\r\nkfree(priv);\r\n}\r\nstatic int kgdb_nmi_tty_open(struct tty_struct *tty, struct file *file)\r\n{\r\nstruct kgdb_nmi_tty_priv *priv = tty->driver_data;\r\nreturn tty_port_open(&priv->port, tty, file);\r\n}\r\nstatic void kgdb_nmi_tty_close(struct tty_struct *tty, struct file *file)\r\n{\r\nstruct kgdb_nmi_tty_priv *priv = tty->driver_data;\r\ntty_port_close(&priv->port, tty, file);\r\n}\r\nstatic void kgdb_nmi_tty_hangup(struct tty_struct *tty)\r\n{\r\nstruct kgdb_nmi_tty_priv *priv = tty->driver_data;\r\ntty_port_hangup(&priv->port);\r\n}\r\nstatic int kgdb_nmi_tty_write_room(struct tty_struct *tty)\r\n{\r\nreturn 2048;\r\n}\r\nstatic int kgdb_nmi_tty_write(struct tty_struct *tty, const unchar *buf, int c)\r\n{\r\nint i;\r\nfor (i = 0; i < c; i++)\r\ndbg_io_ops->write_char(buf[i]);\r\nreturn c;\r\n}\r\nstatic int kgdb_nmi_enable_console(int argc, const char *argv[])\r\n{\r\nkgdb_nmi_tty_enabled = !(argc == 1 && !strcmp(argv[1], "off"));\r\nreturn 0;\r\n}\r\nint kgdb_register_nmi_console(void)\r\n{\r\nint ret;\r\nif (!arch_kgdb_ops.enable_nmi)\r\nreturn 0;\r\nkgdb_nmi_tty_driver = alloc_tty_driver(1);\r\nif (!kgdb_nmi_tty_driver) {\r\npr_err("%s: cannot allocate tty\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nkgdb_nmi_tty_driver->driver_name = "ttyNMI";\r\nkgdb_nmi_tty_driver->name = "ttyNMI";\r\nkgdb_nmi_tty_driver->num = 1;\r\nkgdb_nmi_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nkgdb_nmi_tty_driver->subtype = SERIAL_TYPE_NORMAL;\r\nkgdb_nmi_tty_driver->flags = TTY_DRIVER_REAL_RAW;\r\nkgdb_nmi_tty_driver->init_termios = tty_std_termios;\r\ntty_termios_encode_baud_rate(&kgdb_nmi_tty_driver->init_termios,\r\nKGDB_NMI_BAUD, KGDB_NMI_BAUD);\r\ntty_set_operations(kgdb_nmi_tty_driver, &kgdb_nmi_tty_ops);\r\nret = tty_register_driver(kgdb_nmi_tty_driver);\r\nif (ret) {\r\npr_err("%s: can't register tty driver: %d\n", __func__, ret);\r\ngoto err_drv_reg;\r\n}\r\nret = kdb_register("nmi_console", kgdb_nmi_enable_console, "[off]",\r\n"switch to Linux NMI console", 0);\r\nif (ret) {\r\npr_err("%s: can't register kdb command: %d\n", __func__, ret);\r\ngoto err_kdb_reg;\r\n}\r\nregister_console(&kgdb_nmi_console);\r\narch_kgdb_ops.enable_nmi(1);\r\nreturn 0;\r\nerr_kdb_reg:\r\ntty_unregister_driver(kgdb_nmi_tty_driver);\r\nerr_drv_reg:\r\nput_tty_driver(kgdb_nmi_tty_driver);\r\nreturn ret;\r\n}\r\nint kgdb_unregister_nmi_console(void)\r\n{\r\nint ret;\r\nif (!arch_kgdb_ops.enable_nmi)\r\nreturn 0;\r\narch_kgdb_ops.enable_nmi(0);\r\nkdb_unregister("nmi_console");\r\nret = unregister_console(&kgdb_nmi_console);\r\nif (ret)\r\nreturn ret;\r\nret = tty_unregister_driver(kgdb_nmi_tty_driver);\r\nif (ret)\r\nreturn ret;\r\nput_tty_driver(kgdb_nmi_tty_driver);\r\nreturn 0;\r\n}
