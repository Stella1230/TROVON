static int tlclk_open(struct inode *inode, struct file *filp)\r\n{\r\nint result;\r\nmutex_lock(&tlclk_mutex);\r\nif (test_and_set_bit(0, &useflags)) {\r\nresult = -EBUSY;\r\ngoto out;\r\n}\r\ninb(TLCLK_REG6);\r\nresult = request_irq(telclk_interrupt, &tlclk_interrupt,\r\nIRQF_DISABLED, "telco_clock", tlclk_interrupt);\r\nif (result == -EBUSY)\r\nprintk(KERN_ERR "tlclk: Interrupt can't be reserved.\n");\r\nelse\r\ninb(TLCLK_REG6);\r\nout:\r\nmutex_unlock(&tlclk_mutex);\r\nreturn result;\r\n}\r\nstatic int tlclk_release(struct inode *inode, struct file *filp)\r\n{\r\nfree_irq(telclk_interrupt, tlclk_interrupt);\r\nclear_bit(0, &useflags);\r\nreturn 0;\r\n}\r\nstatic ssize_t tlclk_read(struct file *filp, char __user *buf, size_t count,\r\nloff_t *f_pos)\r\n{\r\nif (count < sizeof(struct tlclk_alarms))\r\nreturn -EIO;\r\nif (mutex_lock_interruptible(&tlclk_mutex))\r\nreturn -EINTR;\r\nwait_event_interruptible(wq, got_event);\r\nif (copy_to_user(buf, alarm_events, sizeof(struct tlclk_alarms))) {\r\nmutex_unlock(&tlclk_mutex);\r\nreturn -EFAULT;\r\n}\r\nmemset(alarm_events, 0, sizeof(struct tlclk_alarms));\r\ngot_event = 0;\r\nmutex_unlock(&tlclk_mutex);\r\nreturn sizeof(struct tlclk_alarms);\r\n}\r\nstatic ssize_t show_current_ref(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long ret_val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&event_lock, flags);\r\nret_val = ((inb(TLCLK_REG1) & 0x08) >> 3);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn sprintf(buf, "0x%lX\n", ret_val);\r\n}\r\nstatic ssize_t show_telclock_version(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long ret_val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&event_lock, flags);\r\nret_val = inb(TLCLK_REG5);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn sprintf(buf, "0x%lX\n", ret_val);\r\n}\r\nstatic ssize_t show_alarms(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long ret_val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&event_lock, flags);\r\nret_val = (inb(TLCLK_REG2) & 0xf0);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn sprintf(buf, "0x%lX\n", ret_val);\r\n}\r\nstatic ssize_t store_received_ref_clk3a(struct device *d,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long tmp;\r\nunsigned char val;\r\nunsigned long flags;\r\nsscanf(buf, "%lX", &tmp);\r\ndev_dbg(d, ": tmp = 0x%lX\n", tmp);\r\nval = (unsigned char)tmp;\r\nspin_lock_irqsave(&event_lock, flags);\r\nSET_PORT_BITS(TLCLK_REG1, 0xef, val);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_received_ref_clk3b(struct device *d,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long tmp;\r\nunsigned char val;\r\nunsigned long flags;\r\nsscanf(buf, "%lX", &tmp);\r\ndev_dbg(d, ": tmp = 0x%lX\n", tmp);\r\nval = (unsigned char)tmp;\r\nspin_lock_irqsave(&event_lock, flags);\r\nSET_PORT_BITS(TLCLK_REG1, 0xdf, val << 1);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_enable_clk3b_output(struct device *d,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long tmp;\r\nunsigned char val;\r\nunsigned long flags;\r\nsscanf(buf, "%lX", &tmp);\r\ndev_dbg(d, ": tmp = 0x%lX\n", tmp);\r\nval = (unsigned char)tmp;\r\nspin_lock_irqsave(&event_lock, flags);\r\nSET_PORT_BITS(TLCLK_REG3, 0x7f, val << 7);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_enable_clk3a_output(struct device *d,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long flags;\r\nunsigned long tmp;\r\nunsigned char val;\r\nsscanf(buf, "%lX", &tmp);\r\ndev_dbg(d, "tmp = 0x%lX\n", tmp);\r\nval = (unsigned char)tmp;\r\nspin_lock_irqsave(&event_lock, flags);\r\nSET_PORT_BITS(TLCLK_REG3, 0xbf, val << 6);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_enable_clkb1_output(struct device *d,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long flags;\r\nunsigned long tmp;\r\nunsigned char val;\r\nsscanf(buf, "%lX", &tmp);\r\ndev_dbg(d, "tmp = 0x%lX\n", tmp);\r\nval = (unsigned char)tmp;\r\nspin_lock_irqsave(&event_lock, flags);\r\nSET_PORT_BITS(TLCLK_REG2, 0xf7, val << 3);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_enable_clka1_output(struct device *d,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long flags;\r\nunsigned long tmp;\r\nunsigned char val;\r\nsscanf(buf, "%lX", &tmp);\r\ndev_dbg(d, "tmp = 0x%lX\n", tmp);\r\nval = (unsigned char)tmp;\r\nspin_lock_irqsave(&event_lock, flags);\r\nSET_PORT_BITS(TLCLK_REG2, 0xfb, val << 2);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_enable_clkb0_output(struct device *d,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long flags;\r\nunsigned long tmp;\r\nunsigned char val;\r\nsscanf(buf, "%lX", &tmp);\r\ndev_dbg(d, "tmp = 0x%lX\n", tmp);\r\nval = (unsigned char)tmp;\r\nspin_lock_irqsave(&event_lock, flags);\r\nSET_PORT_BITS(TLCLK_REG2, 0xfd, val << 1);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_enable_clka0_output(struct device *d,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long flags;\r\nunsigned long tmp;\r\nunsigned char val;\r\nsscanf(buf, "%lX", &tmp);\r\ndev_dbg(d, "tmp = 0x%lX\n", tmp);\r\nval = (unsigned char)tmp;\r\nspin_lock_irqsave(&event_lock, flags);\r\nSET_PORT_BITS(TLCLK_REG2, 0xfe, val);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_select_amcb2_transmit_clock(struct device *d,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long flags;\r\nunsigned long tmp;\r\nunsigned char val;\r\nsscanf(buf, "%lX", &tmp);\r\ndev_dbg(d, "tmp = 0x%lX\n", tmp);\r\nval = (unsigned char)tmp;\r\nspin_lock_irqsave(&event_lock, flags);\r\nif ((val == CLK_8kHz) || (val == CLK_16_384MHz)) {\r\nSET_PORT_BITS(TLCLK_REG3, 0xc7, 0x28);\r\nSET_PORT_BITS(TLCLK_REG1, 0xfb, ~val);\r\n} else if (val >= CLK_8_592MHz) {\r\nSET_PORT_BITS(TLCLK_REG3, 0xc7, 0x38);\r\nswitch (val) {\r\ncase CLK_8_592MHz:\r\nSET_PORT_BITS(TLCLK_REG0, 0xfc, 2);\r\nbreak;\r\ncase CLK_11_184MHz:\r\nSET_PORT_BITS(TLCLK_REG0, 0xfc, 0);\r\nbreak;\r\ncase CLK_34_368MHz:\r\nSET_PORT_BITS(TLCLK_REG0, 0xfc, 3);\r\nbreak;\r\ncase CLK_44_736MHz:\r\nSET_PORT_BITS(TLCLK_REG0, 0xfc, 1);\r\nbreak;\r\n}\r\n} else\r\nSET_PORT_BITS(TLCLK_REG3, 0xc7, val << 3);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_select_amcb1_transmit_clock(struct device *d,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long tmp;\r\nunsigned char val;\r\nunsigned long flags;\r\nsscanf(buf, "%lX", &tmp);\r\ndev_dbg(d, "tmp = 0x%lX\n", tmp);\r\nval = (unsigned char)tmp;\r\nspin_lock_irqsave(&event_lock, flags);\r\nif ((val == CLK_8kHz) || (val == CLK_16_384MHz)) {\r\nSET_PORT_BITS(TLCLK_REG3, 0xf8, 0x5);\r\nSET_PORT_BITS(TLCLK_REG1, 0xfb, ~val);\r\n} else if (val >= CLK_8_592MHz) {\r\nSET_PORT_BITS(TLCLK_REG3, 0xf8, 0x7);\r\nswitch (val) {\r\ncase CLK_8_592MHz:\r\nSET_PORT_BITS(TLCLK_REG0, 0xfc, 2);\r\nbreak;\r\ncase CLK_11_184MHz:\r\nSET_PORT_BITS(TLCLK_REG0, 0xfc, 0);\r\nbreak;\r\ncase CLK_34_368MHz:\r\nSET_PORT_BITS(TLCLK_REG0, 0xfc, 3);\r\nbreak;\r\ncase CLK_44_736MHz:\r\nSET_PORT_BITS(TLCLK_REG0, 0xfc, 1);\r\nbreak;\r\n}\r\n} else\r\nSET_PORT_BITS(TLCLK_REG3, 0xf8, val);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_select_redundant_clock(struct device *d,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long tmp;\r\nunsigned char val;\r\nunsigned long flags;\r\nsscanf(buf, "%lX", &tmp);\r\ndev_dbg(d, "tmp = 0x%lX\n", tmp);\r\nval = (unsigned char)tmp;\r\nspin_lock_irqsave(&event_lock, flags);\r\nSET_PORT_BITS(TLCLK_REG1, 0xfe, val);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_select_ref_frequency(struct device *d,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long tmp;\r\nunsigned char val;\r\nunsigned long flags;\r\nsscanf(buf, "%lX", &tmp);\r\ndev_dbg(d, "tmp = 0x%lX\n", tmp);\r\nval = (unsigned char)tmp;\r\nspin_lock_irqsave(&event_lock, flags);\r\nSET_PORT_BITS(TLCLK_REG1, 0xfd, val);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_filter_select(struct device *d,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long tmp;\r\nunsigned char val;\r\nunsigned long flags;\r\nsscanf(buf, "%lX", &tmp);\r\ndev_dbg(d, "tmp = 0x%lX\n", tmp);\r\nval = (unsigned char)tmp;\r\nspin_lock_irqsave(&event_lock, flags);\r\nSET_PORT_BITS(TLCLK_REG0, 0xfb, val);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_hardware_switching_mode(struct device *d,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long tmp;\r\nunsigned char val;\r\nunsigned long flags;\r\nsscanf(buf, "%lX", &tmp);\r\ndev_dbg(d, "tmp = 0x%lX\n", tmp);\r\nval = (unsigned char)tmp;\r\nspin_lock_irqsave(&event_lock, flags);\r\nSET_PORT_BITS(TLCLK_REG0, 0xbf, val);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_hardware_switching(struct device *d,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long tmp;\r\nunsigned char val;\r\nunsigned long flags;\r\nsscanf(buf, "%lX", &tmp);\r\ndev_dbg(d, "tmp = 0x%lX\n", tmp);\r\nval = (unsigned char)tmp;\r\nspin_lock_irqsave(&event_lock, flags);\r\nSET_PORT_BITS(TLCLK_REG0, 0x7f, val);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_refalign (struct device *d,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long tmp;\r\nunsigned long flags;\r\nsscanf(buf, "%lX", &tmp);\r\ndev_dbg(d, "tmp = 0x%lX\n", tmp);\r\nspin_lock_irqsave(&event_lock, flags);\r\nSET_PORT_BITS(TLCLK_REG0, 0xf7, 0);\r\nSET_PORT_BITS(TLCLK_REG0, 0xf7, 0x08);\r\nSET_PORT_BITS(TLCLK_REG0, 0xf7, 0);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_mode_select (struct device *d,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long tmp;\r\nunsigned char val;\r\nunsigned long flags;\r\nsscanf(buf, "%lX", &tmp);\r\ndev_dbg(d, "tmp = 0x%lX\n", tmp);\r\nval = (unsigned char)tmp;\r\nspin_lock_irqsave(&event_lock, flags);\r\nSET_PORT_BITS(TLCLK_REG0, 0xcf, val);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_reset (struct device *d,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long tmp;\r\nunsigned char val;\r\nunsigned long flags;\r\nsscanf(buf, "%lX", &tmp);\r\ndev_dbg(d, "tmp = 0x%lX\n", tmp);\r\nval = (unsigned char)tmp;\r\nspin_lock_irqsave(&event_lock, flags);\r\nSET_PORT_BITS(TLCLK_REG4, 0xfd, val);\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic int __init tlclk_init(void)\r\n{\r\nint ret;\r\nret = register_chrdev(tlclk_major, "telco_clock", &tlclk_fops);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "tlclk: can't get major %d.\n", tlclk_major);\r\nreturn ret;\r\n}\r\ntlclk_major = ret;\r\nalarm_events = kzalloc( sizeof(struct tlclk_alarms), GFP_KERNEL);\r\nif (!alarm_events) {\r\nret = -ENOMEM;\r\ngoto out1;\r\n}\r\nif (!request_region(TLCLK_BASE, 8, "telco_clock")) {\r\nprintk(KERN_ERR "tlclk: request_region 0x%X failed.\n",\r\nTLCLK_BASE);\r\nret = -EBUSY;\r\ngoto out2;\r\n}\r\ntelclk_interrupt = (inb(TLCLK_REG7) & 0x0f);\r\nif (0x0F == telclk_interrupt ) {\r\nprintk(KERN_ERR "telclk_interrupt = 0x%x non-mcpbl0010 hw.\n",\r\ntelclk_interrupt);\r\nret = -ENXIO;\r\ngoto out3;\r\n}\r\ninit_timer(&switchover_timer);\r\nret = misc_register(&tlclk_miscdev);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "tlclk: misc_register returns %d.\n", ret);\r\ngoto out3;\r\n}\r\ntlclk_device = platform_device_register_simple("telco_clock",\r\n-1, NULL, 0);\r\nif (IS_ERR(tlclk_device)) {\r\nprintk(KERN_ERR "tlclk: platform_device_register failed.\n");\r\nret = PTR_ERR(tlclk_device);\r\ngoto out4;\r\n}\r\nret = sysfs_create_group(&tlclk_device->dev.kobj,\r\n&tlclk_attribute_group);\r\nif (ret) {\r\nprintk(KERN_ERR "tlclk: failed to create sysfs device attributes.\n");\r\ngoto out5;\r\n}\r\nreturn 0;\r\nout5:\r\nplatform_device_unregister(tlclk_device);\r\nout4:\r\nmisc_deregister(&tlclk_miscdev);\r\nout3:\r\nrelease_region(TLCLK_BASE, 8);\r\nout2:\r\nkfree(alarm_events);\r\nout1:\r\nunregister_chrdev(tlclk_major, "telco_clock");\r\nreturn ret;\r\n}\r\nstatic void __exit tlclk_cleanup(void)\r\n{\r\nsysfs_remove_group(&tlclk_device->dev.kobj, &tlclk_attribute_group);\r\nplatform_device_unregister(tlclk_device);\r\nmisc_deregister(&tlclk_miscdev);\r\nunregister_chrdev(tlclk_major, "telco_clock");\r\nrelease_region(TLCLK_BASE, 8);\r\ndel_timer_sync(&switchover_timer);\r\nkfree(alarm_events);\r\n}\r\nstatic void switchover_timeout(unsigned long data)\r\n{\r\nunsigned long flags = *(unsigned long *) data;\r\nif ((flags & 1)) {\r\nif ((inb(TLCLK_REG1) & 0x08) != (flags & 0x08))\r\nalarm_events->switchover_primary++;\r\n} else {\r\nif ((inb(TLCLK_REG1) & 0x08) != (flags & 0x08))\r\nalarm_events->switchover_secondary++;\r\n}\r\ndel_timer(&switchover_timer);\r\ngot_event = 1;\r\nwake_up(&wq);\r\n}\r\nstatic irqreturn_t tlclk_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&event_lock, flags);\r\nint_events = inb(TLCLK_REG6);\r\nif (int_events & PRI_LOS_01_MASK) {\r\nif (inb(TLCLK_REG2) & SEC_LOST_MASK)\r\nalarm_events->lost_clocks++;\r\nelse\r\nalarm_events->lost_primary_clock++;\r\n}\r\nif (int_events & PRI_LOS_10_MASK) {\r\nalarm_events->primary_clock_back++;\r\nSET_PORT_BITS(TLCLK_REG1, 0xFE, 1);\r\n}\r\nif (int_events & SEC_LOS_01_MASK) {\r\nif (inb(TLCLK_REG2) & PRI_LOST_MASK)\r\nalarm_events->lost_clocks++;\r\nelse\r\nalarm_events->lost_secondary_clock++;\r\n}\r\nif (int_events & SEC_LOS_10_MASK) {\r\nalarm_events->secondary_clock_back++;\r\nSET_PORT_BITS(TLCLK_REG1, 0xFE, 0);\r\n}\r\nif (int_events & HOLDOVER_10_MASK)\r\nalarm_events->pll_end_holdover++;\r\nif (int_events & UNLOCK_01_MASK)\r\nalarm_events->pll_lost_sync++;\r\nif (int_events & UNLOCK_10_MASK)\r\nalarm_events->pll_sync++;\r\nif (int_events & HOLDOVER_01_MASK) {\r\nalarm_events->pll_holdover++;\r\nswitchover_timer.expires = jiffies + msecs_to_jiffies(10);\r\ntlclk_timer_data = inb(TLCLK_REG1);\r\nswitchover_timer.data = (unsigned long) &tlclk_timer_data;\r\nmod_timer(&switchover_timer, switchover_timer.expires);\r\n} else {\r\ngot_event = 1;\r\nwake_up(&wq);\r\n}\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}
