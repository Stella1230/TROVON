static unsigned long ctl_page_to_phys(struct mem_ctl_info *mci,\r\nunsigned long page)\r\n{\r\nu32 remap;\r\nstruct e752x_pvt *pvt = (struct e752x_pvt *)mci->pvt_info;\r\nedac_dbg(3, "\n");\r\nif (page < pvt->tolm)\r\nreturn page;\r\nif ((page >= 0x100000) && (page < pvt->remapbase))\r\nreturn page;\r\nremap = (page - pvt->tolm) + pvt->remapbase;\r\nif (remap < pvt->remaplimit)\r\nreturn remap;\r\ne752x_printk(KERN_ERR, "Invalid page %lx - out of range\n", page);\r\nreturn pvt->tolm - 1;\r\n}\r\nstatic void do_process_ce(struct mem_ctl_info *mci, u16 error_one,\r\nu32 sec1_add, u16 sec1_syndrome)\r\n{\r\nu32 page;\r\nint row;\r\nint channel;\r\nint i;\r\nstruct e752x_pvt *pvt = (struct e752x_pvt *)mci->pvt_info;\r\nedac_dbg(3, "\n");\r\npage = sec1_add >> (PAGE_SHIFT - 4);\r\nif (pvt->mc_symmetric) {\r\nrow = ((page >> 1) & 3);\r\ne752x_printk(KERN_WARNING,\r\n"Test row %d Table %d %d %d %d %d %d %d %d\n", row,\r\npvt->map[0], pvt->map[1], pvt->map[2], pvt->map[3],\r\npvt->map[4], pvt->map[5], pvt->map[6],\r\npvt->map[7]);\r\nfor (i = 0; i < 8; i++) {\r\nif (pvt->map[i] == row)\r\nbreak;\r\n}\r\ne752x_printk(KERN_WARNING, "Test computed row %d\n", i);\r\nif (i < 8)\r\nrow = i;\r\nelse\r\ne752x_mc_printk(mci, KERN_WARNING,\r\n"row %d not found in remap table\n",\r\nrow);\r\n} else\r\nrow = edac_mc_find_csrow_by_page(mci, page);\r\nchannel = !(error_one & 1);\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\npage, offset_in_page(sec1_add << 4), sec1_syndrome,\r\nrow, channel, -1,\r\n"e752x CE", "");\r\n}\r\nstatic inline void process_ce(struct mem_ctl_info *mci, u16 error_one,\r\nu32 sec1_add, u16 sec1_syndrome, int *error_found,\r\nint handle_error)\r\n{\r\n*error_found = 1;\r\nif (handle_error)\r\ndo_process_ce(mci, error_one, sec1_add, sec1_syndrome);\r\n}\r\nstatic void do_process_ue(struct mem_ctl_info *mci, u16 error_one,\r\nu32 ded_add, u32 scrb_add)\r\n{\r\nu32 error_2b, block_page;\r\nint row;\r\nstruct e752x_pvt *pvt = (struct e752x_pvt *)mci->pvt_info;\r\nedac_dbg(3, "\n");\r\nif (error_one & 0x0202) {\r\nerror_2b = ded_add;\r\nblock_page = error_2b >> (PAGE_SHIFT - 4);\r\nrow = pvt->mc_symmetric ?\r\n((block_page >> 1) & 3) :\r\nedac_mc_find_csrow_by_page(mci, block_page);\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\r\nblock_page,\r\noffset_in_page(error_2b << 4), 0,\r\nrow, -1, -1,\r\n"e752x UE from Read", "");\r\n}\r\nif (error_one & 0x0404) {\r\nerror_2b = scrb_add;\r\nblock_page = error_2b >> (PAGE_SHIFT - 4);\r\nrow = pvt->mc_symmetric ?\r\n((block_page >> 1) & 3) :\r\nedac_mc_find_csrow_by_page(mci, block_page);\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\r\nblock_page,\r\noffset_in_page(error_2b << 4), 0,\r\nrow, -1, -1,\r\n"e752x UE from Scruber", "");\r\n}\r\n}\r\nstatic inline void process_ue(struct mem_ctl_info *mci, u16 error_one,\r\nu32 ded_add, u32 scrb_add, int *error_found,\r\nint handle_error)\r\n{\r\n*error_found = 1;\r\nif (handle_error)\r\ndo_process_ue(mci, error_one, ded_add, scrb_add);\r\n}\r\nstatic inline void process_ue_no_info_wr(struct mem_ctl_info *mci,\r\nint *error_found, int handle_error)\r\n{\r\n*error_found = 1;\r\nif (!handle_error)\r\nreturn;\r\nedac_dbg(3, "\n");\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,\r\n-1, -1, -1,\r\n"e752x UE log memory write", "");\r\n}\r\nstatic void do_process_ded_retry(struct mem_ctl_info *mci, u16 error,\r\nu32 retry_add)\r\n{\r\nu32 error_1b, page;\r\nint row;\r\nstruct e752x_pvt *pvt = (struct e752x_pvt *)mci->pvt_info;\r\nerror_1b = retry_add;\r\npage = error_1b >> (PAGE_SHIFT - 4);\r\nrow = pvt->mc_symmetric ? ((page >> 1) & 3) :\r\nedac_mc_find_csrow_by_page(mci, page);\r\ne752x_mc_printk(mci, KERN_WARNING,\r\n"CE page 0x%lx, row %d : Memory read retry\n",\r\n(long unsigned int)page, row);\r\n}\r\nstatic inline void process_ded_retry(struct mem_ctl_info *mci, u16 error,\r\nu32 retry_add, int *error_found,\r\nint handle_error)\r\n{\r\n*error_found = 1;\r\nif (handle_error)\r\ndo_process_ded_retry(mci, error, retry_add);\r\n}\r\nstatic inline void process_threshold_ce(struct mem_ctl_info *mci, u16 error,\r\nint *error_found, int handle_error)\r\n{\r\n*error_found = 1;\r\nif (handle_error)\r\ne752x_mc_printk(mci, KERN_WARNING, "Memory threshold CE\n");\r\n}\r\nstatic void do_global_error(int fatal, u32 errors)\r\n{\r\nint i;\r\nfor (i = 0; i < 11; i++) {\r\nif (errors & (1 << i)) {\r\nif ((i == DRAM_ENTRY) || report_non_memory_errors)\r\ne752x_printk(KERN_WARNING, "%sError %s\n",\r\nfatal_message[fatal],\r\nglobal_message[i]);\r\n}\r\n}\r\n}\r\nstatic inline void global_error(int fatal, u32 errors, int *error_found,\r\nint handle_error)\r\n{\r\n*error_found = 1;\r\nif (handle_error)\r\ndo_global_error(fatal, errors);\r\n}\r\nstatic void do_hub_error(int fatal, u8 errors)\r\n{\r\nint i;\r\nfor (i = 0; i < 7; i++) {\r\nif (errors & (1 << i))\r\ne752x_printk(KERN_WARNING, "%sError %s\n",\r\nfatal_message[fatal], hub_message[i]);\r\n}\r\n}\r\nstatic inline void hub_error(int fatal, u8 errors, int *error_found,\r\nint handle_error)\r\n{\r\n*error_found = 1;\r\nif (handle_error)\r\ndo_hub_error(fatal, errors);\r\n}\r\nstatic void do_nsi_error(int fatal, u32 errors)\r\n{\r\nint i;\r\nfor (i = 0; i < 30; i++) {\r\nif (errors & (1 << i))\r\nprintk(KERN_WARNING "%sError %s\n",\r\nfatal_message[fatal], nsi_message[i]);\r\n}\r\n}\r\nstatic inline void nsi_error(int fatal, u32 errors, int *error_found,\r\nint handle_error)\r\n{\r\n*error_found = 1;\r\nif (handle_error)\r\ndo_nsi_error(fatal, errors);\r\n}\r\nstatic void do_membuf_error(u8 errors)\r\n{\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nif (errors & (1 << i))\r\ne752x_printk(KERN_WARNING, "Non-Fatal Error %s\n",\r\nmembuf_message[i]);\r\n}\r\n}\r\nstatic inline void membuf_error(u8 errors, int *error_found, int handle_error)\r\n{\r\n*error_found = 1;\r\nif (handle_error)\r\ndo_membuf_error(errors);\r\n}\r\nstatic void do_sysbus_error(int fatal, u32 errors)\r\n{\r\nint i;\r\nfor (i = 0; i < 10; i++) {\r\nif (errors & (1 << i))\r\ne752x_printk(KERN_WARNING, "%sError System Bus %s\n",\r\nfatal_message[fatal], sysbus_message[i]);\r\n}\r\n}\r\nstatic inline void sysbus_error(int fatal, u32 errors, int *error_found,\r\nint handle_error)\r\n{\r\n*error_found = 1;\r\nif (handle_error)\r\ndo_sysbus_error(fatal, errors);\r\n}\r\nstatic void e752x_check_hub_interface(struct e752x_error_info *info,\r\nint *error_found, int handle_error)\r\n{\r\nu8 stat8;\r\nstat8 = info->hi_ferr;\r\nif (stat8 & 0x7f) {\r\nstat8 &= 0x7f;\r\nif (stat8 & 0x2b)\r\nhub_error(1, stat8 & 0x2b, error_found, handle_error);\r\nif (stat8 & 0x54)\r\nhub_error(0, stat8 & 0x54, error_found, handle_error);\r\n}\r\nstat8 = info->hi_nerr;\r\nif (stat8 & 0x7f) {\r\nstat8 &= 0x7f;\r\nif (stat8 & 0x2b)\r\nhub_error(1, stat8 & 0x2b, error_found, handle_error);\r\nif (stat8 & 0x54)\r\nhub_error(0, stat8 & 0x54, error_found, handle_error);\r\n}\r\n}\r\nstatic void e752x_check_ns_interface(struct e752x_error_info *info,\r\nint *error_found, int handle_error)\r\n{\r\nu32 stat32;\r\nstat32 = info->nsi_ferr;\r\nif (stat32 & NSI_ERR_MASK) {\r\nif (stat32 & NSI_FATAL_MASK)\r\nnsi_error(1, stat32 & NSI_FATAL_MASK, error_found,\r\nhandle_error);\r\nif (stat32 & NSI_NON_FATAL_MASK)\r\nnsi_error(0, stat32 & NSI_NON_FATAL_MASK, error_found,\r\nhandle_error);\r\n}\r\nstat32 = info->nsi_nerr;\r\nif (stat32 & NSI_ERR_MASK) {\r\nif (stat32 & NSI_FATAL_MASK)\r\nnsi_error(1, stat32 & NSI_FATAL_MASK, error_found,\r\nhandle_error);\r\nif (stat32 & NSI_NON_FATAL_MASK)\r\nnsi_error(0, stat32 & NSI_NON_FATAL_MASK, error_found,\r\nhandle_error);\r\n}\r\n}\r\nstatic void e752x_check_sysbus(struct e752x_error_info *info,\r\nint *error_found, int handle_error)\r\n{\r\nu32 stat32, error32;\r\nstat32 = info->sysbus_ferr + (info->sysbus_nerr << 16);\r\nif (stat32 == 0)\r\nreturn;\r\nerror32 = (stat32 >> 16) & 0x3ff;\r\nstat32 = stat32 & 0x3ff;\r\nif (stat32 & 0x087)\r\nsysbus_error(1, stat32 & 0x087, error_found, handle_error);\r\nif (stat32 & 0x378)\r\nsysbus_error(0, stat32 & 0x378, error_found, handle_error);\r\nif (error32 & 0x087)\r\nsysbus_error(1, error32 & 0x087, error_found, handle_error);\r\nif (error32 & 0x378)\r\nsysbus_error(0, error32 & 0x378, error_found, handle_error);\r\n}\r\nstatic void e752x_check_membuf(struct e752x_error_info *info,\r\nint *error_found, int handle_error)\r\n{\r\nu8 stat8;\r\nstat8 = info->buf_ferr;\r\nif (stat8 & 0x0f) {\r\nstat8 &= 0x0f;\r\nmembuf_error(stat8, error_found, handle_error);\r\n}\r\nstat8 = info->buf_nerr;\r\nif (stat8 & 0x0f) {\r\nstat8 &= 0x0f;\r\nmembuf_error(stat8, error_found, handle_error);\r\n}\r\n}\r\nstatic void e752x_check_dram(struct mem_ctl_info *mci,\r\nstruct e752x_error_info *info, int *error_found,\r\nint handle_error)\r\n{\r\nu16 error_one, error_next;\r\nerror_one = info->dram_ferr;\r\nerror_next = info->dram_nerr;\r\nif (error_one & 0x0101)\r\nprocess_ce(mci, error_one, info->dram_sec1_add,\r\ninfo->dram_sec1_syndrome, error_found, handle_error);\r\nif (error_next & 0x0101)\r\nprocess_ce(mci, error_next, info->dram_sec2_add,\r\ninfo->dram_sec2_syndrome, error_found, handle_error);\r\nif (error_one & 0x4040)\r\nprocess_ue_no_info_wr(mci, error_found, handle_error);\r\nif (error_next & 0x4040)\r\nprocess_ue_no_info_wr(mci, error_found, handle_error);\r\nif (error_one & 0x2020)\r\nprocess_ded_retry(mci, error_one, info->dram_retr_add,\r\nerror_found, handle_error);\r\nif (error_next & 0x2020)\r\nprocess_ded_retry(mci, error_next, info->dram_retr_add,\r\nerror_found, handle_error);\r\nif (error_one & 0x0808)\r\nprocess_threshold_ce(mci, error_one, error_found, handle_error);\r\nif (error_next & 0x0808)\r\nprocess_threshold_ce(mci, error_next, error_found,\r\nhandle_error);\r\nif (error_one & 0x0606)\r\nprocess_ue(mci, error_one, info->dram_ded_add,\r\ninfo->dram_scrb_add, error_found, handle_error);\r\nif (error_next & 0x0606)\r\nprocess_ue(mci, error_next, info->dram_ded_add,\r\ninfo->dram_scrb_add, error_found, handle_error);\r\n}\r\nstatic void e752x_get_error_info(struct mem_ctl_info *mci,\r\nstruct e752x_error_info *info)\r\n{\r\nstruct pci_dev *dev;\r\nstruct e752x_pvt *pvt;\r\nmemset(info, 0, sizeof(*info));\r\npvt = (struct e752x_pvt *)mci->pvt_info;\r\ndev = pvt->dev_d0f1;\r\npci_read_config_dword(dev, E752X_FERR_GLOBAL, &info->ferr_global);\r\nif (info->ferr_global) {\r\nif (pvt->dev_info->err_dev == PCI_DEVICE_ID_INTEL_3100_1_ERR) {\r\npci_read_config_dword(dev, I3100_NSI_FERR,\r\n&info->nsi_ferr);\r\ninfo->hi_ferr = 0;\r\n} else {\r\npci_read_config_byte(dev, E752X_HI_FERR,\r\n&info->hi_ferr);\r\ninfo->nsi_ferr = 0;\r\n}\r\npci_read_config_word(dev, E752X_SYSBUS_FERR,\r\n&info->sysbus_ferr);\r\npci_read_config_byte(dev, E752X_BUF_FERR, &info->buf_ferr);\r\npci_read_config_word(dev, E752X_DRAM_FERR, &info->dram_ferr);\r\npci_read_config_dword(dev, E752X_DRAM_SEC1_ADD,\r\n&info->dram_sec1_add);\r\npci_read_config_word(dev, E752X_DRAM_SEC1_SYNDROME,\r\n&info->dram_sec1_syndrome);\r\npci_read_config_dword(dev, E752X_DRAM_DED_ADD,\r\n&info->dram_ded_add);\r\npci_read_config_dword(dev, E752X_DRAM_SCRB_ADD,\r\n&info->dram_scrb_add);\r\npci_read_config_dword(dev, E752X_DRAM_RETR_ADD,\r\n&info->dram_retr_add);\r\nif (info->hi_ferr & 0x7f)\r\npci_write_config_byte(dev, E752X_HI_FERR,\r\ninfo->hi_ferr);\r\nif (info->nsi_ferr & NSI_ERR_MASK)\r\npci_write_config_dword(dev, I3100_NSI_FERR,\r\ninfo->nsi_ferr);\r\nif (info->sysbus_ferr)\r\npci_write_config_word(dev, E752X_SYSBUS_FERR,\r\ninfo->sysbus_ferr);\r\nif (info->buf_ferr & 0x0f)\r\npci_write_config_byte(dev, E752X_BUF_FERR,\r\ninfo->buf_ferr);\r\nif (info->dram_ferr)\r\npci_write_bits16(pvt->bridge_ck, E752X_DRAM_FERR,\r\ninfo->dram_ferr, info->dram_ferr);\r\npci_write_config_dword(dev, E752X_FERR_GLOBAL,\r\ninfo->ferr_global);\r\n}\r\npci_read_config_dword(dev, E752X_NERR_GLOBAL, &info->nerr_global);\r\nif (info->nerr_global) {\r\nif (pvt->dev_info->err_dev == PCI_DEVICE_ID_INTEL_3100_1_ERR) {\r\npci_read_config_dword(dev, I3100_NSI_NERR,\r\n&info->nsi_nerr);\r\ninfo->hi_nerr = 0;\r\n} else {\r\npci_read_config_byte(dev, E752X_HI_NERR,\r\n&info->hi_nerr);\r\ninfo->nsi_nerr = 0;\r\n}\r\npci_read_config_word(dev, E752X_SYSBUS_NERR,\r\n&info->sysbus_nerr);\r\npci_read_config_byte(dev, E752X_BUF_NERR, &info->buf_nerr);\r\npci_read_config_word(dev, E752X_DRAM_NERR, &info->dram_nerr);\r\npci_read_config_dword(dev, E752X_DRAM_SEC2_ADD,\r\n&info->dram_sec2_add);\r\npci_read_config_word(dev, E752X_DRAM_SEC2_SYNDROME,\r\n&info->dram_sec2_syndrome);\r\nif (info->hi_nerr & 0x7f)\r\npci_write_config_byte(dev, E752X_HI_NERR,\r\ninfo->hi_nerr);\r\nif (info->nsi_nerr & NSI_ERR_MASK)\r\npci_write_config_dword(dev, I3100_NSI_NERR,\r\ninfo->nsi_nerr);\r\nif (info->sysbus_nerr)\r\npci_write_config_word(dev, E752X_SYSBUS_NERR,\r\ninfo->sysbus_nerr);\r\nif (info->buf_nerr & 0x0f)\r\npci_write_config_byte(dev, E752X_BUF_NERR,\r\ninfo->buf_nerr);\r\nif (info->dram_nerr)\r\npci_write_bits16(pvt->bridge_ck, E752X_DRAM_NERR,\r\ninfo->dram_nerr, info->dram_nerr);\r\npci_write_config_dword(dev, E752X_NERR_GLOBAL,\r\ninfo->nerr_global);\r\n}\r\n}\r\nstatic int e752x_process_error_info(struct mem_ctl_info *mci,\r\nstruct e752x_error_info *info,\r\nint handle_errors)\r\n{\r\nu32 error32, stat32;\r\nint error_found;\r\nerror_found = 0;\r\nerror32 = (info->ferr_global >> 18) & 0x3ff;\r\nstat32 = (info->ferr_global >> 4) & 0x7ff;\r\nif (error32)\r\nglobal_error(1, error32, &error_found, handle_errors);\r\nif (stat32)\r\nglobal_error(0, stat32, &error_found, handle_errors);\r\nerror32 = (info->nerr_global >> 18) & 0x3ff;\r\nstat32 = (info->nerr_global >> 4) & 0x7ff;\r\nif (error32)\r\nglobal_error(1, error32, &error_found, handle_errors);\r\nif (stat32)\r\nglobal_error(0, stat32, &error_found, handle_errors);\r\ne752x_check_hub_interface(info, &error_found, handle_errors);\r\ne752x_check_ns_interface(info, &error_found, handle_errors);\r\ne752x_check_sysbus(info, &error_found, handle_errors);\r\ne752x_check_membuf(info, &error_found, handle_errors);\r\ne752x_check_dram(mci, info, &error_found, handle_errors);\r\nreturn error_found;\r\n}\r\nstatic void e752x_check(struct mem_ctl_info *mci)\r\n{\r\nstruct e752x_error_info info;\r\nedac_dbg(3, "\n");\r\ne752x_get_error_info(mci, &info);\r\ne752x_process_error_info(mci, &info, 1);\r\n}\r\nstatic int set_sdram_scrub_rate(struct mem_ctl_info *mci, u32 new_bw)\r\n{\r\nconst struct scrubrate *scrubrates;\r\nstruct e752x_pvt *pvt = (struct e752x_pvt *) mci->pvt_info;\r\nstruct pci_dev *pdev = pvt->dev_d0f0;\r\nint i;\r\nif (pvt->dev_info->ctl_dev == PCI_DEVICE_ID_INTEL_3100_0)\r\nscrubrates = scrubrates_i3100;\r\nelse\r\nscrubrates = scrubrates_e752x;\r\nfor (i = 0; scrubrates[i].bandwidth != SDRATE_EOT; i++)\r\nif (scrubrates[i].bandwidth >= new_bw)\r\nbreak;\r\nif (scrubrates[i].bandwidth == SDRATE_EOT)\r\nreturn -1;\r\npci_write_config_word(pdev, E752X_MCHSCRB, scrubrates[i].scrubval);\r\nreturn scrubrates[i].bandwidth;\r\n}\r\nstatic int get_sdram_scrub_rate(struct mem_ctl_info *mci)\r\n{\r\nconst struct scrubrate *scrubrates;\r\nstruct e752x_pvt *pvt = (struct e752x_pvt *) mci->pvt_info;\r\nstruct pci_dev *pdev = pvt->dev_d0f0;\r\nu16 scrubval;\r\nint i;\r\nif (pvt->dev_info->ctl_dev == PCI_DEVICE_ID_INTEL_3100_0)\r\nscrubrates = scrubrates_i3100;\r\nelse\r\nscrubrates = scrubrates_e752x;\r\npci_read_config_word(pdev, E752X_MCHSCRB, &scrubval);\r\nscrubval = scrubval & 0x0f;\r\nfor (i = 0; scrubrates[i].bandwidth != SDRATE_EOT; i++)\r\nif (scrubrates[i].scrubval == scrubval)\r\nbreak;\r\nif (scrubrates[i].bandwidth == SDRATE_EOT) {\r\ne752x_printk(KERN_WARNING,\r\n"Invalid sdram scrub control value: 0x%x\n", scrubval);\r\nreturn -1;\r\n}\r\nreturn scrubrates[i].bandwidth;\r\n}\r\nstatic inline int dual_channel_active(u16 ddrcsr)\r\n{\r\nreturn (((ddrcsr >> 12) & 3) == 3);\r\n}\r\nstatic inline int remap_csrow_index(struct mem_ctl_info *mci, int index)\r\n{\r\nstruct e752x_pvt *pvt = mci->pvt_info;\r\nif (!pvt->map_type)\r\nreturn (7 - index);\r\nreturn (index);\r\n}\r\nstatic void e752x_init_csrows(struct mem_ctl_info *mci, struct pci_dev *pdev,\r\nu16 ddrcsr)\r\n{\r\nstruct csrow_info *csrow;\r\nenum edac_type edac_mode;\r\nunsigned long last_cumul_size;\r\nint index, mem_dev, drc_chan;\r\nint drc_drbg;\r\nint drc_ddim;\r\nu8 value;\r\nu32 dra, drc, cumul_size, i, nr_pages;\r\ndra = 0;\r\nfor (index = 0; index < 4; index++) {\r\nu8 dra_reg;\r\npci_read_config_byte(pdev, E752X_DRA + index, &dra_reg);\r\ndra |= dra_reg << (index * 8);\r\n}\r\npci_read_config_dword(pdev, E752X_DRC, &drc);\r\ndrc_chan = dual_channel_active(ddrcsr) ? 1 : 0;\r\ndrc_drbg = drc_chan + 1;\r\ndrc_ddim = (drc >> 20) & 0x3;\r\nfor (last_cumul_size = index = 0; index < mci->nr_csrows; index++) {\r\nmem_dev = (dra >> (index * 4 + 2)) & 0x3;\r\ncsrow = mci->csrows[remap_csrow_index(mci, index)];\r\nmem_dev = (mem_dev == 2);\r\npci_read_config_byte(pdev, E752X_DRB + index, &value);\r\ncumul_size = value << (25 + drc_drbg - PAGE_SHIFT);\r\nedac_dbg(3, "(%d) cumul_size 0x%x\n", index, cumul_size);\r\nif (cumul_size == last_cumul_size)\r\ncontinue;\r\ncsrow->first_page = last_cumul_size;\r\ncsrow->last_page = cumul_size - 1;\r\nnr_pages = cumul_size - last_cumul_size;\r\nlast_cumul_size = cumul_size;\r\nif (drc_ddim) {\r\nif (drc_chan && mem_dev) {\r\nedac_mode = EDAC_S4ECD4ED;\r\nmci->edac_cap |= EDAC_FLAG_S4ECD4ED;\r\n} else {\r\nedac_mode = EDAC_SECDED;\r\nmci->edac_cap |= EDAC_FLAG_SECDED;\r\n}\r\n} else\r\nedac_mode = EDAC_NONE;\r\nfor (i = 0; i < csrow->nr_channels; i++) {\r\nstruct dimm_info *dimm = csrow->channels[i]->dimm;\r\nedac_dbg(3, "Initializing rank at (%i,%i)\n", index, i);\r\ndimm->nr_pages = nr_pages / csrow->nr_channels;\r\ndimm->grain = 1 << 12;\r\ndimm->mtype = MEM_RDDR;\r\ndimm->dtype = mem_dev ? DEV_X4 : DEV_X8;\r\ndimm->edac_mode = edac_mode;\r\n}\r\n}\r\n}\r\nstatic void e752x_init_mem_map_table(struct pci_dev *pdev,\r\nstruct e752x_pvt *pvt)\r\n{\r\nint index;\r\nu8 value, last, row;\r\nlast = 0;\r\nrow = 0;\r\nfor (index = 0; index < 8; index += 2) {\r\npci_read_config_byte(pdev, E752X_DRB + index, &value);\r\nif (value == last) {\r\npvt->map[index] = 0xff;\r\npvt->map[index + 1] = 0xff;\r\n} else {\r\npvt->map[index] = row;\r\nrow++;\r\nlast = value;\r\npci_read_config_byte(pdev, E752X_DRB + index + 1,\r\n&value);\r\npvt->map[index + 1] = (value == last) ? 0xff : row;\r\nrow++;\r\nlast = value;\r\n}\r\n}\r\n}\r\nstatic int e752x_get_devs(struct pci_dev *pdev, int dev_idx,\r\nstruct e752x_pvt *pvt)\r\n{\r\nstruct pci_dev *dev;\r\npvt->bridge_ck = pci_get_device(PCI_VENDOR_ID_INTEL,\r\npvt->dev_info->err_dev, pvt->bridge_ck);\r\nif (pvt->bridge_ck == NULL)\r\npvt->bridge_ck = pci_scan_single_device(pdev->bus,\r\nPCI_DEVFN(0, 1));\r\nif (pvt->bridge_ck == NULL) {\r\ne752x_printk(KERN_ERR, "error reporting device not found:"\r\n"vendor %x device 0x%x (broken BIOS?)\n",\r\nPCI_VENDOR_ID_INTEL, e752x_devs[dev_idx].err_dev);\r\nreturn 1;\r\n}\r\ndev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\ne752x_devs[dev_idx].ctl_dev,\r\nNULL);\r\nif (dev == NULL)\r\ngoto fail;\r\npvt->dev_d0f0 = dev;\r\npvt->dev_d0f1 = pci_dev_get(pvt->bridge_ck);\r\nreturn 0;\r\nfail:\r\npci_dev_put(pvt->bridge_ck);\r\nreturn 1;\r\n}\r\nstatic void e752x_init_sysbus_parity_mask(struct e752x_pvt *pvt)\r\n{\r\nchar *cpu_id = cpu_data(0).x86_model_id;\r\nstruct pci_dev *dev = pvt->dev_d0f1;\r\nint enable = 1;\r\nif (sysbus_parity != -1) {\r\nenable = sysbus_parity;\r\n} else if (cpu_id[0] && !strstr(cpu_id, "Xeon")) {\r\ne752x_printk(KERN_INFO, "System Bus Parity not "\r\n"supported by CPU, disabling\n");\r\nenable = 0;\r\n}\r\nif (enable)\r\npci_write_config_word(dev, E752X_SYSBUS_ERRMASK, 0x0000);\r\nelse\r\npci_write_config_word(dev, E752X_SYSBUS_ERRMASK, 0x0309);\r\n}\r\nstatic void e752x_init_error_reporting_regs(struct e752x_pvt *pvt)\r\n{\r\nstruct pci_dev *dev;\r\ndev = pvt->dev_d0f1;\r\nif (pvt->dev_info->err_dev == PCI_DEVICE_ID_INTEL_3100_1_ERR) {\r\npci_write_config_dword(dev, I3100_NSI_EMASK, 0);\r\npci_write_config_dword(dev, I3100_NSI_SMICMD, 0);\r\n} else {\r\npci_write_config_byte(dev, E752X_HI_ERRMASK, 0x00);\r\npci_write_config_byte(dev, E752X_HI_SMICMD, 0x00);\r\n}\r\ne752x_init_sysbus_parity_mask(pvt);\r\npci_write_config_word(dev, E752X_SYSBUS_SMICMD, 0x00);\r\npci_write_config_byte(dev, E752X_BUF_ERRMASK, 0x00);\r\npci_write_config_byte(dev, E752X_BUF_SMICMD, 0x00);\r\npci_write_config_byte(dev, E752X_DRAM_ERRMASK, 0x00);\r\npci_write_config_byte(dev, E752X_DRAM_SMICMD, 0x00);\r\n}\r\nstatic int e752x_probe1(struct pci_dev *pdev, int dev_idx)\r\n{\r\nu16 pci_data;\r\nu8 stat8;\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[2];\r\nstruct e752x_pvt *pvt;\r\nu16 ddrcsr;\r\nint drc_chan;\r\nstruct e752x_error_info discard;\r\nedac_dbg(0, "mci\n");\r\nedac_dbg(0, "Starting Probe1\n");\r\npci_read_config_byte(pdev, E752X_DEVPRES1, &stat8);\r\nif (!force_function_unhide && !(stat8 & (1 << 5))) {\r\nprintk(KERN_INFO "Contact your BIOS vendor to see if the "\r\n"E752x error registers can be safely un-hidden\n");\r\nreturn -ENODEV;\r\n}\r\nstat8 |= (1 << 5);\r\npci_write_config_byte(pdev, E752X_DEVPRES1, stat8);\r\npci_read_config_word(pdev, E752X_DDRCSR, &ddrcsr);\r\ndrc_chan = dual_channel_active(ddrcsr);\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = E752X_NR_CSROWS;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = drc_chan + 1;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(*pvt));\r\nif (mci == NULL)\r\nreturn -ENOMEM;\r\nedac_dbg(3, "init mci\n");\r\nmci->mtype_cap = MEM_FLAG_RDDR;\r\nmci->edac_ctl_cap = (dev_idx == I3100) ? EDAC_FLAG_SECDED :\r\n(EDAC_FLAG_NONE | EDAC_FLAG_SECDED | EDAC_FLAG_S4ECD4ED);\r\nmci->mod_name = EDAC_MOD_STR;\r\nmci->mod_ver = E752X_REVISION;\r\nmci->pdev = &pdev->dev;\r\nedac_dbg(3, "init pvt\n");\r\npvt = (struct e752x_pvt *)mci->pvt_info;\r\npvt->dev_info = &e752x_devs[dev_idx];\r\npvt->mc_symmetric = ((ddrcsr & 0x10) != 0);\r\nif (e752x_get_devs(pdev, dev_idx, pvt)) {\r\nedac_mc_free(mci);\r\nreturn -ENODEV;\r\n}\r\nedac_dbg(3, "more mci init\n");\r\nmci->ctl_name = pvt->dev_info->ctl_name;\r\nmci->dev_name = pci_name(pdev);\r\nmci->edac_check = e752x_check;\r\nmci->ctl_page_to_phys = ctl_page_to_phys;\r\nmci->set_sdram_scrub_rate = set_sdram_scrub_rate;\r\nmci->get_sdram_scrub_rate = get_sdram_scrub_rate;\r\npci_read_config_byte(pdev, E752X_DRM, &stat8);\r\npvt->map_type = ((stat8 & 0x0f) > ((stat8 >> 4) & 0x0f));\r\ne752x_init_csrows(mci, pdev, ddrcsr);\r\ne752x_init_mem_map_table(pdev, pvt);\r\nif (dev_idx == I3100)\r\nmci->edac_cap = EDAC_FLAG_SECDED;\r\nelse\r\nmci->edac_cap |= EDAC_FLAG_NONE;\r\nedac_dbg(3, "tolm, remapbase, remaplimit\n");\r\npci_read_config_word(pdev, E752X_TOLM, &pci_data);\r\npvt->tolm = ((u32) pci_data) << 4;\r\npci_read_config_word(pdev, E752X_REMAPBASE, &pci_data);\r\npvt->remapbase = ((u32) pci_data) << 14;\r\npci_read_config_word(pdev, E752X_REMAPLIMIT, &pci_data);\r\npvt->remaplimit = ((u32) pci_data) << 14;\r\ne752x_printk(KERN_INFO,\r\n"tolm = %x, remapbase = %x, remaplimit = %x\n",\r\npvt->tolm, pvt->remapbase, pvt->remaplimit);\r\nif (edac_mc_add_mc(mci)) {\r\nedac_dbg(3, "failed edac_mc_add_mc()\n");\r\ngoto fail;\r\n}\r\ne752x_init_error_reporting_regs(pvt);\r\ne752x_get_error_info(mci, &discard);\r\ne752x_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\r\nif (!e752x_pci) {\r\nprintk(KERN_WARNING\r\n"%s(): Unable to create PCI control\n", __func__);\r\nprintk(KERN_WARNING\r\n"%s(): PCI error report via EDAC not setup\n",\r\n__func__);\r\n}\r\nedac_dbg(3, "success\n");\r\nreturn 0;\r\nfail:\r\npci_dev_put(pvt->dev_d0f0);\r\npci_dev_put(pvt->dev_d0f1);\r\npci_dev_put(pvt->bridge_ck);\r\nedac_mc_free(mci);\r\nreturn -ENODEV;\r\n}\r\nstatic int e752x_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nedac_dbg(0, "\n");\r\nif (pci_enable_device(pdev) < 0)\r\nreturn -EIO;\r\nreturn e752x_probe1(pdev, ent->driver_data);\r\n}\r\nstatic void e752x_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct e752x_pvt *pvt;\r\nedac_dbg(0, "\n");\r\nif (e752x_pci)\r\nedac_pci_release_generic_ctl(e752x_pci);\r\nif ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)\r\nreturn;\r\npvt = (struct e752x_pvt *)mci->pvt_info;\r\npci_dev_put(pvt->dev_d0f0);\r\npci_dev_put(pvt->dev_d0f1);\r\npci_dev_put(pvt->bridge_ck);\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init e752x_init(void)\r\n{\r\nint pci_rc;\r\nedac_dbg(3, "\n");\r\nopstate_init();\r\npci_rc = pci_register_driver(&e752x_driver);\r\nreturn (pci_rc < 0) ? pci_rc : 0;\r\n}\r\nstatic void __exit e752x_exit(void)\r\n{\r\nedac_dbg(3, "\n");\r\npci_unregister_driver(&e752x_driver);\r\n}
