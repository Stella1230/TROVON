static void radeon_fence_write(struct radeon_device *rdev, u32 seq, int ring)\r\n{\r\nstruct radeon_fence_driver *drv = &rdev->fence_drv[ring];\r\nif (likely(rdev->wb.enabled || !drv->scratch_reg)) {\r\nif (drv->cpu_addr) {\r\n*drv->cpu_addr = cpu_to_le32(seq);\r\n}\r\n} else {\r\nWREG32(drv->scratch_reg, seq);\r\n}\r\n}\r\nstatic u32 radeon_fence_read(struct radeon_device *rdev, int ring)\r\n{\r\nstruct radeon_fence_driver *drv = &rdev->fence_drv[ring];\r\nu32 seq = 0;\r\nif (likely(rdev->wb.enabled || !drv->scratch_reg)) {\r\nif (drv->cpu_addr) {\r\nseq = le32_to_cpu(*drv->cpu_addr);\r\n} else {\r\nseq = lower_32_bits(atomic64_read(&drv->last_seq));\r\n}\r\n} else {\r\nseq = RREG32(drv->scratch_reg);\r\n}\r\nreturn seq;\r\n}\r\nint radeon_fence_emit(struct radeon_device *rdev,\r\nstruct radeon_fence **fence,\r\nint ring)\r\n{\r\n*fence = kmalloc(sizeof(struct radeon_fence), GFP_KERNEL);\r\nif ((*fence) == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nkref_init(&((*fence)->kref));\r\n(*fence)->rdev = rdev;\r\n(*fence)->seq = ++rdev->fence_drv[ring].sync_seq[ring];\r\n(*fence)->ring = ring;\r\nradeon_fence_ring_emit(rdev, ring, *fence);\r\ntrace_radeon_fence_emit(rdev->ddev, (*fence)->seq);\r\nreturn 0;\r\n}\r\nvoid radeon_fence_process(struct radeon_device *rdev, int ring)\r\n{\r\nuint64_t seq, last_seq, last_emitted;\r\nunsigned count_loop = 0;\r\nbool wake = false;\r\nlast_seq = atomic64_read(&rdev->fence_drv[ring].last_seq);\r\ndo {\r\nlast_emitted = rdev->fence_drv[ring].sync_seq[ring];\r\nseq = radeon_fence_read(rdev, ring);\r\nseq |= last_seq & 0xffffffff00000000LL;\r\nif (seq < last_seq) {\r\nseq &= 0xffffffff;\r\nseq |= last_emitted & 0xffffffff00000000LL;\r\n}\r\nif (seq <= last_seq || seq > last_emitted) {\r\nbreak;\r\n}\r\nwake = true;\r\nlast_seq = seq;\r\nif ((count_loop++) > 10) {\r\nbreak;\r\n}\r\n} while (atomic64_xchg(&rdev->fence_drv[ring].last_seq, seq) > seq);\r\nif (wake) {\r\nrdev->fence_drv[ring].last_activity = jiffies;\r\nwake_up_all(&rdev->fence_queue);\r\n}\r\n}\r\nstatic void radeon_fence_destroy(struct kref *kref)\r\n{\r\nstruct radeon_fence *fence;\r\nfence = container_of(kref, struct radeon_fence, kref);\r\nkfree(fence);\r\n}\r\nstatic bool radeon_fence_seq_signaled(struct radeon_device *rdev,\r\nu64 seq, unsigned ring)\r\n{\r\nif (atomic64_read(&rdev->fence_drv[ring].last_seq) >= seq) {\r\nreturn true;\r\n}\r\nradeon_fence_process(rdev, ring);\r\nif (atomic64_read(&rdev->fence_drv[ring].last_seq) >= seq) {\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nbool radeon_fence_signaled(struct radeon_fence *fence)\r\n{\r\nif (!fence) {\r\nreturn true;\r\n}\r\nif (fence->seq == RADEON_FENCE_SIGNALED_SEQ) {\r\nreturn true;\r\n}\r\nif (radeon_fence_seq_signaled(fence->rdev, fence->seq, fence->ring)) {\r\nfence->seq = RADEON_FENCE_SIGNALED_SEQ;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int radeon_fence_wait_seq(struct radeon_device *rdev, u64 target_seq,\r\nunsigned ring, bool intr, bool lock_ring)\r\n{\r\nunsigned long timeout, last_activity;\r\nuint64_t seq;\r\nunsigned i;\r\nbool signaled;\r\nint r;\r\nwhile (target_seq > atomic64_read(&rdev->fence_drv[ring].last_seq)) {\r\nif (!rdev->ring[ring].ready) {\r\nreturn -EBUSY;\r\n}\r\ntimeout = jiffies - RADEON_FENCE_JIFFIES_TIMEOUT;\r\nif (time_after(rdev->fence_drv[ring].last_activity, timeout)) {\r\ntimeout = rdev->fence_drv[ring].last_activity - timeout;\r\n} else {\r\ntimeout = 1;\r\n}\r\nseq = atomic64_read(&rdev->fence_drv[ring].last_seq);\r\nlast_activity = rdev->fence_drv[ring].last_activity;\r\ntrace_radeon_fence_wait_begin(rdev->ddev, seq);\r\nradeon_irq_kms_sw_irq_get(rdev, ring);\r\nif (intr) {\r\nr = wait_event_interruptible_timeout(rdev->fence_queue,\r\n(signaled = radeon_fence_seq_signaled(rdev, target_seq, ring)),\r\ntimeout);\r\n} else {\r\nr = wait_event_timeout(rdev->fence_queue,\r\n(signaled = radeon_fence_seq_signaled(rdev, target_seq, ring)),\r\ntimeout);\r\n}\r\nradeon_irq_kms_sw_irq_put(rdev, ring);\r\nif (unlikely(r < 0)) {\r\nreturn r;\r\n}\r\ntrace_radeon_fence_wait_end(rdev->ddev, seq);\r\nif (unlikely(!signaled)) {\r\nif (r) {\r\ncontinue;\r\n}\r\nif (seq != atomic64_read(&rdev->fence_drv[ring].last_seq)) {\r\ncontinue;\r\n}\r\nif (lock_ring) {\r\nmutex_lock(&rdev->ring_lock);\r\n}\r\nif (last_activity != rdev->fence_drv[ring].last_activity) {\r\nif (lock_ring) {\r\nmutex_unlock(&rdev->ring_lock);\r\n}\r\ncontinue;\r\n}\r\nif (radeon_ring_is_lockup(rdev, ring, &rdev->ring[ring])) {\r\ndev_warn(rdev->dev, "GPU lockup (waiting for 0x%016llx last fence id 0x%016llx)\n",\r\ntarget_seq, seq);\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nrdev->fence_drv[i].last_activity = jiffies;\r\n}\r\nrdev->ring[ring].ready = false;\r\nif (lock_ring) {\r\nmutex_unlock(&rdev->ring_lock);\r\n}\r\nreturn -EDEADLK;\r\n}\r\nif (lock_ring) {\r\nmutex_unlock(&rdev->ring_lock);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint radeon_fence_wait(struct radeon_fence *fence, bool intr)\r\n{\r\nint r;\r\nif (fence == NULL) {\r\nWARN(1, "Querying an invalid fence : %p !\n", fence);\r\nreturn -EINVAL;\r\n}\r\nr = radeon_fence_wait_seq(fence->rdev, fence->seq,\r\nfence->ring, intr, true);\r\nif (r) {\r\nreturn r;\r\n}\r\nfence->seq = RADEON_FENCE_SIGNALED_SEQ;\r\nreturn 0;\r\n}\r\nstatic bool radeon_fence_any_seq_signaled(struct radeon_device *rdev, u64 *seq)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nif (seq[i] && radeon_fence_seq_signaled(rdev, seq[i], i)) {\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic int radeon_fence_wait_any_seq(struct radeon_device *rdev,\r\nu64 *target_seq, bool intr)\r\n{\r\nunsigned long timeout, last_activity, tmp;\r\nunsigned i, ring = RADEON_NUM_RINGS;\r\nbool signaled;\r\nint r;\r\nfor (i = 0, last_activity = 0; i < RADEON_NUM_RINGS; ++i) {\r\nif (!target_seq[i]) {\r\ncontinue;\r\n}\r\nif (time_after(rdev->fence_drv[i].last_activity, last_activity)) {\r\nlast_activity = rdev->fence_drv[i].last_activity;\r\n}\r\nif (i < ring) {\r\nring = i;\r\n}\r\n}\r\nif (ring == RADEON_NUM_RINGS) {\r\nreturn -ENOENT;\r\n}\r\nwhile (!radeon_fence_any_seq_signaled(rdev, target_seq)) {\r\ntimeout = jiffies - RADEON_FENCE_JIFFIES_TIMEOUT;\r\nif (time_after(last_activity, timeout)) {\r\ntimeout = last_activity - timeout;\r\n} else {\r\ntimeout = 1;\r\n}\r\ntrace_radeon_fence_wait_begin(rdev->ddev, target_seq[ring]);\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nif (target_seq[i]) {\r\nradeon_irq_kms_sw_irq_get(rdev, i);\r\n}\r\n}\r\nif (intr) {\r\nr = wait_event_interruptible_timeout(rdev->fence_queue,\r\n(signaled = radeon_fence_any_seq_signaled(rdev, target_seq)),\r\ntimeout);\r\n} else {\r\nr = wait_event_timeout(rdev->fence_queue,\r\n(signaled = radeon_fence_any_seq_signaled(rdev, target_seq)),\r\ntimeout);\r\n}\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nif (target_seq[i]) {\r\nradeon_irq_kms_sw_irq_put(rdev, i);\r\n}\r\n}\r\nif (unlikely(r < 0)) {\r\nreturn r;\r\n}\r\ntrace_radeon_fence_wait_end(rdev->ddev, target_seq[ring]);\r\nif (unlikely(!signaled)) {\r\nif (r) {\r\ncontinue;\r\n}\r\nmutex_lock(&rdev->ring_lock);\r\nfor (i = 0, tmp = 0; i < RADEON_NUM_RINGS; ++i) {\r\nif (time_after(rdev->fence_drv[i].last_activity, tmp)) {\r\ntmp = rdev->fence_drv[i].last_activity;\r\n}\r\n}\r\nif (last_activity != tmp) {\r\nlast_activity = tmp;\r\nmutex_unlock(&rdev->ring_lock);\r\ncontinue;\r\n}\r\nif (radeon_ring_is_lockup(rdev, ring, &rdev->ring[ring])) {\r\ndev_warn(rdev->dev, "GPU lockup (waiting for 0x%016llx)\n",\r\ntarget_seq[ring]);\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nrdev->fence_drv[i].last_activity = jiffies;\r\n}\r\nrdev->ring[ring].ready = false;\r\nmutex_unlock(&rdev->ring_lock);\r\nreturn -EDEADLK;\r\n}\r\nmutex_unlock(&rdev->ring_lock);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint radeon_fence_wait_any(struct radeon_device *rdev,\r\nstruct radeon_fence **fences,\r\nbool intr)\r\n{\r\nuint64_t seq[RADEON_NUM_RINGS];\r\nunsigned i;\r\nint r;\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nseq[i] = 0;\r\nif (!fences[i]) {\r\ncontinue;\r\n}\r\nif (fences[i]->seq == RADEON_FENCE_SIGNALED_SEQ) {\r\nreturn 0;\r\n}\r\nseq[i] = fences[i]->seq;\r\n}\r\nr = radeon_fence_wait_any_seq(rdev, seq, intr);\r\nif (r) {\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nint radeon_fence_wait_next_locked(struct radeon_device *rdev, int ring)\r\n{\r\nuint64_t seq;\r\nseq = atomic64_read(&rdev->fence_drv[ring].last_seq) + 1ULL;\r\nif (seq >= rdev->fence_drv[ring].sync_seq[ring]) {\r\nreturn -ENOENT;\r\n}\r\nreturn radeon_fence_wait_seq(rdev, seq, ring, false, false);\r\n}\r\nint radeon_fence_wait_empty_locked(struct radeon_device *rdev, int ring)\r\n{\r\nuint64_t seq = rdev->fence_drv[ring].sync_seq[ring];\r\nint r;\r\nr = radeon_fence_wait_seq(rdev, seq, ring, false, false);\r\nif (r) {\r\nif (r == -EDEADLK) {\r\nreturn -EDEADLK;\r\n}\r\ndev_err(rdev->dev, "error waiting for ring[%d] to become idle (%d)\n",\r\nring, r);\r\n}\r\nreturn 0;\r\n}\r\nstruct radeon_fence *radeon_fence_ref(struct radeon_fence *fence)\r\n{\r\nkref_get(&fence->kref);\r\nreturn fence;\r\n}\r\nvoid radeon_fence_unref(struct radeon_fence **fence)\r\n{\r\nstruct radeon_fence *tmp = *fence;\r\n*fence = NULL;\r\nif (tmp) {\r\nkref_put(&tmp->kref, radeon_fence_destroy);\r\n}\r\n}\r\nunsigned radeon_fence_count_emitted(struct radeon_device *rdev, int ring)\r\n{\r\nuint64_t emitted;\r\nradeon_fence_process(rdev, ring);\r\nemitted = rdev->fence_drv[ring].sync_seq[ring]\r\n- atomic64_read(&rdev->fence_drv[ring].last_seq);\r\nif (emitted > 0x10000000) {\r\nemitted = 0x10000000;\r\n}\r\nreturn (unsigned)emitted;\r\n}\r\nbool radeon_fence_need_sync(struct radeon_fence *fence, int dst_ring)\r\n{\r\nstruct radeon_fence_driver *fdrv;\r\nif (!fence) {\r\nreturn false;\r\n}\r\nif (fence->ring == dst_ring) {\r\nreturn false;\r\n}\r\nfdrv = &fence->rdev->fence_drv[dst_ring];\r\nif (fence->seq <= fdrv->sync_seq[fence->ring]) {\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nvoid radeon_fence_note_sync(struct radeon_fence *fence, int dst_ring)\r\n{\r\nstruct radeon_fence_driver *dst, *src;\r\nunsigned i;\r\nif (!fence) {\r\nreturn;\r\n}\r\nif (fence->ring == dst_ring) {\r\nreturn;\r\n}\r\nsrc = &fence->rdev->fence_drv[fence->ring];\r\ndst = &fence->rdev->fence_drv[dst_ring];\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nif (i == dst_ring) {\r\ncontinue;\r\n}\r\ndst->sync_seq[i] = max(dst->sync_seq[i], src->sync_seq[i]);\r\n}\r\n}\r\nint radeon_fence_driver_start_ring(struct radeon_device *rdev, int ring)\r\n{\r\nuint64_t index;\r\nint r;\r\nradeon_scratch_free(rdev, rdev->fence_drv[ring].scratch_reg);\r\nif (rdev->wb.use_event || !radeon_ring_supports_scratch_reg(rdev, &rdev->ring[ring])) {\r\nrdev->fence_drv[ring].scratch_reg = 0;\r\nif (ring != R600_RING_TYPE_UVD_INDEX) {\r\nindex = R600_WB_EVENT_OFFSET + ring * 4;\r\nrdev->fence_drv[ring].cpu_addr = &rdev->wb.wb[index/4];\r\nrdev->fence_drv[ring].gpu_addr = rdev->wb.gpu_addr +\r\nindex;\r\n} else {\r\nindex = ALIGN(rdev->uvd_fw->size, 8);\r\nrdev->fence_drv[ring].cpu_addr = rdev->uvd.cpu_addr + index;\r\nrdev->fence_drv[ring].gpu_addr = rdev->uvd.gpu_addr + index;\r\n}\r\n} else {\r\nr = radeon_scratch_get(rdev, &rdev->fence_drv[ring].scratch_reg);\r\nif (r) {\r\ndev_err(rdev->dev, "fence failed to get scratch register\n");\r\nreturn r;\r\n}\r\nindex = RADEON_WB_SCRATCH_OFFSET +\r\nrdev->fence_drv[ring].scratch_reg -\r\nrdev->scratch.reg_base;\r\nrdev->fence_drv[ring].cpu_addr = &rdev->wb.wb[index/4];\r\nrdev->fence_drv[ring].gpu_addr = rdev->wb.gpu_addr + index;\r\n}\r\nradeon_fence_write(rdev, atomic64_read(&rdev->fence_drv[ring].last_seq), ring);\r\nrdev->fence_drv[ring].initialized = true;\r\ndev_info(rdev->dev, "fence driver on ring %d use gpu addr 0x%016llx and cpu addr 0x%p\n",\r\nring, rdev->fence_drv[ring].gpu_addr, rdev->fence_drv[ring].cpu_addr);\r\nreturn 0;\r\n}\r\nstatic void radeon_fence_driver_init_ring(struct radeon_device *rdev, int ring)\r\n{\r\nint i;\r\nrdev->fence_drv[ring].scratch_reg = -1;\r\nrdev->fence_drv[ring].cpu_addr = NULL;\r\nrdev->fence_drv[ring].gpu_addr = 0;\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i)\r\nrdev->fence_drv[ring].sync_seq[i] = 0;\r\natomic64_set(&rdev->fence_drv[ring].last_seq, 0);\r\nrdev->fence_drv[ring].last_activity = jiffies;\r\nrdev->fence_drv[ring].initialized = false;\r\n}\r\nint radeon_fence_driver_init(struct radeon_device *rdev)\r\n{\r\nint ring;\r\ninit_waitqueue_head(&rdev->fence_queue);\r\nfor (ring = 0; ring < RADEON_NUM_RINGS; ring++) {\r\nradeon_fence_driver_init_ring(rdev, ring);\r\n}\r\nif (radeon_debugfs_fence_init(rdev)) {\r\ndev_err(rdev->dev, "fence debugfs file creation failed\n");\r\n}\r\nreturn 0;\r\n}\r\nvoid radeon_fence_driver_fini(struct radeon_device *rdev)\r\n{\r\nint ring, r;\r\nmutex_lock(&rdev->ring_lock);\r\nfor (ring = 0; ring < RADEON_NUM_RINGS; ring++) {\r\nif (!rdev->fence_drv[ring].initialized)\r\ncontinue;\r\nr = radeon_fence_wait_empty_locked(rdev, ring);\r\nif (r) {\r\nradeon_fence_driver_force_completion(rdev);\r\n}\r\nwake_up_all(&rdev->fence_queue);\r\nradeon_scratch_free(rdev, rdev->fence_drv[ring].scratch_reg);\r\nrdev->fence_drv[ring].initialized = false;\r\n}\r\nmutex_unlock(&rdev->ring_lock);\r\n}\r\nvoid radeon_fence_driver_force_completion(struct radeon_device *rdev)\r\n{\r\nint ring;\r\nfor (ring = 0; ring < RADEON_NUM_RINGS; ring++) {\r\nif (!rdev->fence_drv[ring].initialized)\r\ncontinue;\r\nradeon_fence_write(rdev, rdev->fence_drv[ring].sync_seq[ring], ring);\r\n}\r\n}\r\nstatic int radeon_debugfs_fence_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *)m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nint i, j;\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nif (!rdev->fence_drv[i].initialized)\r\ncontinue;\r\nseq_printf(m, "--- ring %d ---\n", i);\r\nseq_printf(m, "Last signaled fence 0x%016llx\n",\r\n(unsigned long long)atomic64_read(&rdev->fence_drv[i].last_seq));\r\nseq_printf(m, "Last emitted 0x%016llx\n",\r\nrdev->fence_drv[i].sync_seq[i]);\r\nfor (j = 0; j < RADEON_NUM_RINGS; ++j) {\r\nif (i != j && rdev->fence_drv[j].initialized)\r\nseq_printf(m, "Last sync to ring %d 0x%016llx\n",\r\nj, rdev->fence_drv[i].sync_seq[j]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint radeon_debugfs_fence_init(struct radeon_device *rdev)\r\n{\r\n#if defined(CONFIG_DEBUG_FS)\r\nreturn radeon_debugfs_add_files(rdev, radeon_debugfs_fence_list, 1);\r\n#else\r\nreturn 0;\r\n#endif\r\n}
