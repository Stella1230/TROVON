static inline void ablkcipher_buffer_write(struct ablkcipher_buffer *p)\r\n{\r\nscatterwalk_copychunks(p->data, &p->dst, p->len, 1);\r\n}\r\nvoid __ablkcipher_walk_complete(struct ablkcipher_walk *walk)\r\n{\r\nstruct ablkcipher_buffer *p, *tmp;\r\nlist_for_each_entry_safe(p, tmp, &walk->buffers, entry) {\r\nablkcipher_buffer_write(p);\r\nlist_del(&p->entry);\r\nkfree(p);\r\n}\r\n}\r\nstatic inline void ablkcipher_queue_write(struct ablkcipher_walk *walk,\r\nstruct ablkcipher_buffer *p)\r\n{\r\np->dst = walk->out;\r\nlist_add_tail(&p->entry, &walk->buffers);\r\n}\r\nstatic inline u8 *ablkcipher_get_spot(u8 *start, unsigned int len)\r\n{\r\nu8 *end_page = (u8 *)(((unsigned long)(start + len - 1)) & PAGE_MASK);\r\nreturn max(start, end_page);\r\n}\r\nstatic inline unsigned int ablkcipher_done_slow(struct ablkcipher_walk *walk,\r\nunsigned int bsize)\r\n{\r\nunsigned int n = bsize;\r\nfor (;;) {\r\nunsigned int len_this_page = scatterwalk_pagelen(&walk->out);\r\nif (len_this_page > n)\r\nlen_this_page = n;\r\nscatterwalk_advance(&walk->out, n);\r\nif (n == len_this_page)\r\nbreak;\r\nn -= len_this_page;\r\nscatterwalk_start(&walk->out, scatterwalk_sg_next(walk->out.sg));\r\n}\r\nreturn bsize;\r\n}\r\nstatic inline unsigned int ablkcipher_done_fast(struct ablkcipher_walk *walk,\r\nunsigned int n)\r\n{\r\nscatterwalk_advance(&walk->in, n);\r\nscatterwalk_advance(&walk->out, n);\r\nreturn n;\r\n}\r\nint ablkcipher_walk_done(struct ablkcipher_request *req,\r\nstruct ablkcipher_walk *walk, int err)\r\n{\r\nstruct crypto_tfm *tfm = req->base.tfm;\r\nunsigned int nbytes = 0;\r\nif (likely(err >= 0)) {\r\nunsigned int n = walk->nbytes - err;\r\nif (likely(!(walk->flags & ABLKCIPHER_WALK_SLOW)))\r\nn = ablkcipher_done_fast(walk, n);\r\nelse if (WARN_ON(err)) {\r\nerr = -EINVAL;\r\ngoto err;\r\n} else\r\nn = ablkcipher_done_slow(walk, n);\r\nnbytes = walk->total - n;\r\nerr = 0;\r\n}\r\nscatterwalk_done(&walk->in, 0, nbytes);\r\nscatterwalk_done(&walk->out, 1, nbytes);\r\nerr:\r\nwalk->total = nbytes;\r\nwalk->nbytes = nbytes;\r\nif (nbytes) {\r\ncrypto_yield(req->base.flags);\r\nreturn ablkcipher_walk_next(req, walk);\r\n}\r\nif (walk->iv != req->info)\r\nmemcpy(req->info, walk->iv, tfm->crt_ablkcipher.ivsize);\r\nkfree(walk->iv_buffer);\r\nreturn err;\r\n}\r\nstatic inline int ablkcipher_next_slow(struct ablkcipher_request *req,\r\nstruct ablkcipher_walk *walk,\r\nunsigned int bsize,\r\nunsigned int alignmask,\r\nvoid **src_p, void **dst_p)\r\n{\r\nunsigned aligned_bsize = ALIGN(bsize, alignmask + 1);\r\nstruct ablkcipher_buffer *p;\r\nvoid *src, *dst, *base;\r\nunsigned int n;\r\nn = ALIGN(sizeof(struct ablkcipher_buffer), alignmask + 1);\r\nn += (aligned_bsize * 3 - (alignmask + 1) +\r\n(alignmask & ~(crypto_tfm_ctx_alignment() - 1)));\r\np = kmalloc(n, GFP_ATOMIC);\r\nif (!p)\r\nreturn ablkcipher_walk_done(req, walk, -ENOMEM);\r\nbase = p + 1;\r\ndst = (u8 *)ALIGN((unsigned long)base, alignmask + 1);\r\nsrc = dst = ablkcipher_get_spot(dst, bsize);\r\np->len = bsize;\r\np->data = dst;\r\nscatterwalk_copychunks(src, &walk->in, bsize, 0);\r\nablkcipher_queue_write(walk, p);\r\nwalk->nbytes = bsize;\r\nwalk->flags |= ABLKCIPHER_WALK_SLOW;\r\n*src_p = src;\r\n*dst_p = dst;\r\nreturn 0;\r\n}\r\nstatic inline int ablkcipher_copy_iv(struct ablkcipher_walk *walk,\r\nstruct crypto_tfm *tfm,\r\nunsigned int alignmask)\r\n{\r\nunsigned bs = walk->blocksize;\r\nunsigned int ivsize = tfm->crt_ablkcipher.ivsize;\r\nunsigned aligned_bs = ALIGN(bs, alignmask + 1);\r\nunsigned int size = aligned_bs * 2 + ivsize + max(aligned_bs, ivsize) -\r\n(alignmask + 1);\r\nu8 *iv;\r\nsize += alignmask & ~(crypto_tfm_ctx_alignment() - 1);\r\nwalk->iv_buffer = kmalloc(size, GFP_ATOMIC);\r\nif (!walk->iv_buffer)\r\nreturn -ENOMEM;\r\niv = (u8 *)ALIGN((unsigned long)walk->iv_buffer, alignmask + 1);\r\niv = ablkcipher_get_spot(iv, bs) + aligned_bs;\r\niv = ablkcipher_get_spot(iv, bs) + aligned_bs;\r\niv = ablkcipher_get_spot(iv, ivsize);\r\nwalk->iv = memcpy(iv, walk->iv, ivsize);\r\nreturn 0;\r\n}\r\nstatic inline int ablkcipher_next_fast(struct ablkcipher_request *req,\r\nstruct ablkcipher_walk *walk)\r\n{\r\nwalk->src.page = scatterwalk_page(&walk->in);\r\nwalk->src.offset = offset_in_page(walk->in.offset);\r\nwalk->dst.page = scatterwalk_page(&walk->out);\r\nwalk->dst.offset = offset_in_page(walk->out.offset);\r\nreturn 0;\r\n}\r\nstatic int ablkcipher_walk_next(struct ablkcipher_request *req,\r\nstruct ablkcipher_walk *walk)\r\n{\r\nstruct crypto_tfm *tfm = req->base.tfm;\r\nunsigned int alignmask, bsize, n;\r\nvoid *src, *dst;\r\nint err;\r\nalignmask = crypto_tfm_alg_alignmask(tfm);\r\nn = walk->total;\r\nif (unlikely(n < crypto_tfm_alg_blocksize(tfm))) {\r\nreq->base.flags |= CRYPTO_TFM_RES_BAD_BLOCK_LEN;\r\nreturn ablkcipher_walk_done(req, walk, -EINVAL);\r\n}\r\nwalk->flags &= ~ABLKCIPHER_WALK_SLOW;\r\nsrc = dst = NULL;\r\nbsize = min(walk->blocksize, n);\r\nn = scatterwalk_clamp(&walk->in, n);\r\nn = scatterwalk_clamp(&walk->out, n);\r\nif (n < bsize ||\r\n!scatterwalk_aligned(&walk->in, alignmask) ||\r\n!scatterwalk_aligned(&walk->out, alignmask)) {\r\nerr = ablkcipher_next_slow(req, walk, bsize, alignmask,\r\n&src, &dst);\r\ngoto set_phys_lowmem;\r\n}\r\nwalk->nbytes = n;\r\nreturn ablkcipher_next_fast(req, walk);\r\nset_phys_lowmem:\r\nif (err >= 0) {\r\nwalk->src.page = virt_to_page(src);\r\nwalk->dst.page = virt_to_page(dst);\r\nwalk->src.offset = ((unsigned long)src & (PAGE_SIZE - 1));\r\nwalk->dst.offset = ((unsigned long)dst & (PAGE_SIZE - 1));\r\n}\r\nreturn err;\r\n}\r\nstatic int ablkcipher_walk_first(struct ablkcipher_request *req,\r\nstruct ablkcipher_walk *walk)\r\n{\r\nstruct crypto_tfm *tfm = req->base.tfm;\r\nunsigned int alignmask;\r\nalignmask = crypto_tfm_alg_alignmask(tfm);\r\nif (WARN_ON_ONCE(in_irq()))\r\nreturn -EDEADLK;\r\nwalk->nbytes = walk->total;\r\nif (unlikely(!walk->total))\r\nreturn 0;\r\nwalk->iv_buffer = NULL;\r\nwalk->iv = req->info;\r\nif (unlikely(((unsigned long)walk->iv & alignmask))) {\r\nint err = ablkcipher_copy_iv(walk, tfm, alignmask);\r\nif (err)\r\nreturn err;\r\n}\r\nscatterwalk_start(&walk->in, walk->in.sg);\r\nscatterwalk_start(&walk->out, walk->out.sg);\r\nreturn ablkcipher_walk_next(req, walk);\r\n}\r\nint ablkcipher_walk_phys(struct ablkcipher_request *req,\r\nstruct ablkcipher_walk *walk)\r\n{\r\nwalk->blocksize = crypto_tfm_alg_blocksize(req->base.tfm);\r\nreturn ablkcipher_walk_first(req, walk);\r\n}\r\nstatic int setkey_unaligned(struct crypto_ablkcipher *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct ablkcipher_alg *cipher = crypto_ablkcipher_alg(tfm);\r\nunsigned long alignmask = crypto_ablkcipher_alignmask(tfm);\r\nint ret;\r\nu8 *buffer, *alignbuffer;\r\nunsigned long absize;\r\nabsize = keylen + alignmask;\r\nbuffer = kmalloc(absize, GFP_ATOMIC);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nalignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);\r\nmemcpy(alignbuffer, key, keylen);\r\nret = cipher->setkey(tfm, alignbuffer, keylen);\r\nmemset(alignbuffer, 0, keylen);\r\nkfree(buffer);\r\nreturn ret;\r\n}\r\nstatic int setkey(struct crypto_ablkcipher *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct ablkcipher_alg *cipher = crypto_ablkcipher_alg(tfm);\r\nunsigned long alignmask = crypto_ablkcipher_alignmask(tfm);\r\nif (keylen < cipher->min_keysize || keylen > cipher->max_keysize) {\r\ncrypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nif ((unsigned long)key & alignmask)\r\nreturn setkey_unaligned(tfm, key, keylen);\r\nreturn cipher->setkey(tfm, key, keylen);\r\n}\r\nstatic unsigned int crypto_ablkcipher_ctxsize(struct crypto_alg *alg, u32 type,\r\nu32 mask)\r\n{\r\nreturn alg->cra_ctxsize;\r\n}\r\nint skcipher_null_givencrypt(struct skcipher_givcrypt_request *req)\r\n{\r\nreturn crypto_ablkcipher_encrypt(&req->creq);\r\n}\r\nint skcipher_null_givdecrypt(struct skcipher_givcrypt_request *req)\r\n{\r\nreturn crypto_ablkcipher_decrypt(&req->creq);\r\n}\r\nstatic int crypto_init_ablkcipher_ops(struct crypto_tfm *tfm, u32 type,\r\nu32 mask)\r\n{\r\nstruct ablkcipher_alg *alg = &tfm->__crt_alg->cra_ablkcipher;\r\nstruct ablkcipher_tfm *crt = &tfm->crt_ablkcipher;\r\nif (alg->ivsize > PAGE_SIZE / 8)\r\nreturn -EINVAL;\r\ncrt->setkey = setkey;\r\ncrt->encrypt = alg->encrypt;\r\ncrt->decrypt = alg->decrypt;\r\nif (!alg->ivsize) {\r\ncrt->givencrypt = skcipher_null_givencrypt;\r\ncrt->givdecrypt = skcipher_null_givdecrypt;\r\n}\r\ncrt->base = __crypto_ablkcipher_cast(tfm);\r\ncrt->ivsize = alg->ivsize;\r\nreturn 0;\r\n}\r\nstatic int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nstruct crypto_report_blkcipher rblkcipher;\r\nstrncpy(rblkcipher.type, "ablkcipher", sizeof(rblkcipher.type));\r\nstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: "<default>",\r\nsizeof(rblkcipher.geniv));\r\nrblkcipher.blocksize = alg->cra_blocksize;\r\nrblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\r\nrblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\r\nrblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\r\nif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\r\nsizeof(struct crypto_report_blkcipher), &rblkcipher))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic void crypto_ablkcipher_show(struct seq_file *m, struct crypto_alg *alg)\r\n{\r\nstruct ablkcipher_alg *ablkcipher = &alg->cra_ablkcipher;\r\nseq_printf(m, "type : ablkcipher\n");\r\nseq_printf(m, "async : %s\n", alg->cra_flags & CRYPTO_ALG_ASYNC ?\r\n"yes" : "no");\r\nseq_printf(m, "blocksize : %u\n", alg->cra_blocksize);\r\nseq_printf(m, "min keysize : %u\n", ablkcipher->min_keysize);\r\nseq_printf(m, "max keysize : %u\n", ablkcipher->max_keysize);\r\nseq_printf(m, "ivsize : %u\n", ablkcipher->ivsize);\r\nseq_printf(m, "geniv : %s\n", ablkcipher->geniv ?: "<default>");\r\n}\r\nstatic int no_givdecrypt(struct skcipher_givcrypt_request *req)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int crypto_init_givcipher_ops(struct crypto_tfm *tfm, u32 type,\r\nu32 mask)\r\n{\r\nstruct ablkcipher_alg *alg = &tfm->__crt_alg->cra_ablkcipher;\r\nstruct ablkcipher_tfm *crt = &tfm->crt_ablkcipher;\r\nif (alg->ivsize > PAGE_SIZE / 8)\r\nreturn -EINVAL;\r\ncrt->setkey = tfm->__crt_alg->cra_flags & CRYPTO_ALG_GENIV ?\r\nalg->setkey : setkey;\r\ncrt->encrypt = alg->encrypt;\r\ncrt->decrypt = alg->decrypt;\r\ncrt->givencrypt = alg->givencrypt;\r\ncrt->givdecrypt = alg->givdecrypt ?: no_givdecrypt;\r\ncrt->base = __crypto_ablkcipher_cast(tfm);\r\ncrt->ivsize = alg->ivsize;\r\nreturn 0;\r\n}\r\nstatic int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nstruct crypto_report_blkcipher rblkcipher;\r\nstrncpy(rblkcipher.type, "givcipher", sizeof(rblkcipher.type));\r\nstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: "<built-in>",\r\nsizeof(rblkcipher.geniv));\r\nrblkcipher.blocksize = alg->cra_blocksize;\r\nrblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\r\nrblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\r\nrblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\r\nif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\r\nsizeof(struct crypto_report_blkcipher), &rblkcipher))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic void crypto_givcipher_show(struct seq_file *m, struct crypto_alg *alg)\r\n{\r\nstruct ablkcipher_alg *ablkcipher = &alg->cra_ablkcipher;\r\nseq_printf(m, "type : givcipher\n");\r\nseq_printf(m, "async : %s\n", alg->cra_flags & CRYPTO_ALG_ASYNC ?\r\n"yes" : "no");\r\nseq_printf(m, "blocksize : %u\n", alg->cra_blocksize);\r\nseq_printf(m, "min keysize : %u\n", ablkcipher->min_keysize);\r\nseq_printf(m, "max keysize : %u\n", ablkcipher->max_keysize);\r\nseq_printf(m, "ivsize : %u\n", ablkcipher->ivsize);\r\nseq_printf(m, "geniv : %s\n", ablkcipher->geniv ?: "<built-in>");\r\n}\r\nconst char *crypto_default_geniv(const struct crypto_alg *alg)\r\n{\r\nif (((alg->cra_flags & CRYPTO_ALG_TYPE_MASK) ==\r\nCRYPTO_ALG_TYPE_BLKCIPHER ? alg->cra_blkcipher.ivsize :\r\nalg->cra_ablkcipher.ivsize) !=\r\nalg->cra_blocksize)\r\nreturn "chainiv";\r\nreturn alg->cra_flags & CRYPTO_ALG_ASYNC ?\r\n"eseqiv" : skcipher_default_geniv;\r\n}\r\nstatic int crypto_givcipher_default(struct crypto_alg *alg, u32 type, u32 mask)\r\n{\r\nstruct rtattr *tb[3];\r\nstruct {\r\nstruct rtattr attr;\r\nstruct crypto_attr_type data;\r\n} ptype;\r\nstruct {\r\nstruct rtattr attr;\r\nstruct crypto_attr_alg data;\r\n} palg;\r\nstruct crypto_template *tmpl;\r\nstruct crypto_instance *inst;\r\nstruct crypto_alg *larval;\r\nconst char *geniv;\r\nint err;\r\nlarval = crypto_larval_lookup(alg->cra_driver_name,\r\n(type & ~CRYPTO_ALG_TYPE_MASK) |\r\nCRYPTO_ALG_TYPE_GIVCIPHER,\r\nmask | CRYPTO_ALG_TYPE_MASK);\r\nerr = PTR_ERR(larval);\r\nif (IS_ERR(larval))\r\ngoto out;\r\nerr = -EAGAIN;\r\nif (!crypto_is_larval(larval))\r\ngoto drop_larval;\r\nptype.attr.rta_len = sizeof(ptype);\r\nptype.attr.rta_type = CRYPTOA_TYPE;\r\nptype.data.type = type | CRYPTO_ALG_GENIV;\r\nptype.data.mask = mask | CRYPTO_ALG_GENIV;\r\ntb[0] = &ptype.attr;\r\npalg.attr.rta_len = sizeof(palg);\r\npalg.attr.rta_type = CRYPTOA_ALG;\r\nmemcpy(palg.data.name, alg->cra_driver_name, CRYPTO_MAX_ALG_NAME);\r\ntb[1] = &palg.attr;\r\ntb[2] = NULL;\r\nif ((alg->cra_flags & CRYPTO_ALG_TYPE_MASK) ==\r\nCRYPTO_ALG_TYPE_BLKCIPHER)\r\ngeniv = alg->cra_blkcipher.geniv;\r\nelse\r\ngeniv = alg->cra_ablkcipher.geniv;\r\nif (!geniv)\r\ngeniv = crypto_default_geniv(alg);\r\ntmpl = crypto_lookup_template(geniv);\r\nerr = -ENOENT;\r\nif (!tmpl)\r\ngoto kill_larval;\r\ninst = tmpl->alloc(tb);\r\nerr = PTR_ERR(inst);\r\nif (IS_ERR(inst))\r\ngoto put_tmpl;\r\nif ((err = crypto_register_instance(tmpl, inst))) {\r\ntmpl->free(inst);\r\ngoto put_tmpl;\r\n}\r\nerr = -EAGAIN;\r\nput_tmpl:\r\ncrypto_tmpl_put(tmpl);\r\nkill_larval:\r\ncrypto_larval_kill(larval);\r\ndrop_larval:\r\ncrypto_mod_put(larval);\r\nout:\r\ncrypto_mod_put(alg);\r\nreturn err;\r\n}\r\nstruct crypto_alg *crypto_lookup_skcipher(const char *name, u32 type, u32 mask)\r\n{\r\nstruct crypto_alg *alg;\r\nalg = crypto_alg_mod_lookup(name, type, mask);\r\nif (IS_ERR(alg))\r\nreturn alg;\r\nif ((alg->cra_flags & CRYPTO_ALG_TYPE_MASK) ==\r\nCRYPTO_ALG_TYPE_GIVCIPHER)\r\nreturn alg;\r\nif (!((alg->cra_flags & CRYPTO_ALG_TYPE_MASK) ==\r\nCRYPTO_ALG_TYPE_BLKCIPHER ? alg->cra_blkcipher.ivsize :\r\nalg->cra_ablkcipher.ivsize))\r\nreturn alg;\r\ncrypto_mod_put(alg);\r\nalg = crypto_alg_mod_lookup(name, type | CRYPTO_ALG_TESTED,\r\nmask & ~CRYPTO_ALG_TESTED);\r\nif (IS_ERR(alg))\r\nreturn alg;\r\nif ((alg->cra_flags & CRYPTO_ALG_TYPE_MASK) ==\r\nCRYPTO_ALG_TYPE_GIVCIPHER) {\r\nif ((alg->cra_flags ^ type ^ ~mask) & CRYPTO_ALG_TESTED) {\r\ncrypto_mod_put(alg);\r\nalg = ERR_PTR(-ENOENT);\r\n}\r\nreturn alg;\r\n}\r\nBUG_ON(!((alg->cra_flags & CRYPTO_ALG_TYPE_MASK) ==\r\nCRYPTO_ALG_TYPE_BLKCIPHER ? alg->cra_blkcipher.ivsize :\r\nalg->cra_ablkcipher.ivsize));\r\nreturn ERR_PTR(crypto_givcipher_default(alg, type, mask));\r\n}\r\nint crypto_grab_skcipher(struct crypto_skcipher_spawn *spawn, const char *name,\r\nu32 type, u32 mask)\r\n{\r\nstruct crypto_alg *alg;\r\nint err;\r\ntype = crypto_skcipher_type(type);\r\nmask = crypto_skcipher_mask(mask);\r\nalg = crypto_lookup_skcipher(name, type, mask);\r\nif (IS_ERR(alg))\r\nreturn PTR_ERR(alg);\r\nerr = crypto_init_spawn(&spawn->base, alg, spawn->base.inst, mask);\r\ncrypto_mod_put(alg);\r\nreturn err;\r\n}\r\nstruct crypto_ablkcipher *crypto_alloc_ablkcipher(const char *alg_name,\r\nu32 type, u32 mask)\r\n{\r\nstruct crypto_tfm *tfm;\r\nint err;\r\ntype = crypto_skcipher_type(type);\r\nmask = crypto_skcipher_mask(mask);\r\nfor (;;) {\r\nstruct crypto_alg *alg;\r\nalg = crypto_lookup_skcipher(alg_name, type, mask);\r\nif (IS_ERR(alg)) {\r\nerr = PTR_ERR(alg);\r\ngoto err;\r\n}\r\ntfm = __crypto_alloc_tfm(alg, type, mask);\r\nif (!IS_ERR(tfm))\r\nreturn __crypto_ablkcipher_cast(tfm);\r\ncrypto_mod_put(alg);\r\nerr = PTR_ERR(tfm);\r\nerr:\r\nif (err != -EAGAIN)\r\nbreak;\r\nif (signal_pending(current)) {\r\nerr = -EINTR;\r\nbreak;\r\n}\r\n}\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init skcipher_module_init(void)\r\n{\r\nskcipher_default_geniv = num_possible_cpus() > 1 ?\r\n"eseqiv" : "chainiv";\r\nreturn 0;\r\n}\r\nstatic void skcipher_module_exit(void)\r\n{\r\n}
