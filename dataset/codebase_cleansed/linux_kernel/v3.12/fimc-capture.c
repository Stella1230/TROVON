static int fimc_capture_hw_init(struct fimc_dev *fimc)\r\n{\r\nstruct fimc_source_info *si = &fimc->vid_cap.source_config;\r\nstruct fimc_ctx *ctx = fimc->vid_cap.ctx;\r\nint ret;\r\nunsigned long flags;\r\nif (ctx == NULL || ctx->s_frame.fmt == NULL)\r\nreturn -EINVAL;\r\nif (si->fimc_bus_type == FIMC_BUS_TYPE_ISP_WRITEBACK) {\r\nret = fimc_hw_camblk_cfg_writeback(fimc);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nfimc_prepare_dma_offset(ctx, &ctx->d_frame);\r\nfimc_set_yuv_order(ctx);\r\nfimc_hw_set_camera_polarity(fimc, si);\r\nfimc_hw_set_camera_type(fimc, si);\r\nfimc_hw_set_camera_source(fimc, si);\r\nfimc_hw_set_camera_offset(fimc, &ctx->s_frame);\r\nret = fimc_set_scaler_info(ctx);\r\nif (!ret) {\r\nfimc_hw_set_input_path(ctx);\r\nfimc_hw_set_prescaler(ctx);\r\nfimc_hw_set_mainscaler(ctx);\r\nfimc_hw_set_target_format(ctx);\r\nfimc_hw_set_rotation(ctx);\r\nfimc_hw_set_effect(ctx);\r\nfimc_hw_set_output_path(ctx);\r\nfimc_hw_set_out_dma(ctx);\r\nif (fimc->drv_data->alpha_color)\r\nfimc_hw_set_rgb_alpha(ctx);\r\nclear_bit(ST_CAPT_APPLY_CFG, &fimc->state);\r\n}\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\nreturn ret;\r\n}\r\nstatic int fimc_capture_state_cleanup(struct fimc_dev *fimc, bool suspend)\r\n{\r\nstruct fimc_vid_cap *cap = &fimc->vid_cap;\r\nstruct fimc_vid_buffer *buf;\r\nunsigned long flags;\r\nbool streaming;\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nstreaming = fimc->state & (1 << ST_CAPT_ISP_STREAM);\r\nfimc->state &= ~(1 << ST_CAPT_RUN | 1 << ST_CAPT_SHUT |\r\n1 << ST_CAPT_STREAM | 1 << ST_CAPT_ISP_STREAM);\r\nif (suspend)\r\nfimc->state |= (1 << ST_CAPT_SUSPENDED);\r\nelse\r\nfimc->state &= ~(1 << ST_CAPT_PEND | 1 << ST_CAPT_SUSPENDED);\r\nwhile (!suspend && !list_empty(&cap->pending_buf_q)) {\r\nbuf = fimc_pending_queue_pop(cap);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\n}\r\nwhile (!list_empty(&cap->active_buf_q)) {\r\nbuf = fimc_active_queue_pop(cap);\r\nif (suspend)\r\nfimc_pending_queue_add(cap, buf);\r\nelse\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\n}\r\nfimc_hw_reset(fimc);\r\ncap->buf_index = 0;\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\nif (streaming)\r\nreturn fimc_pipeline_call(&cap->ve, set_stream, 0);\r\nelse\r\nreturn 0;\r\n}\r\nstatic int fimc_stop_capture(struct fimc_dev *fimc, bool suspend)\r\n{\r\nunsigned long flags;\r\nif (!fimc_capture_active(fimc))\r\nreturn 0;\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nset_bit(ST_CAPT_SHUT, &fimc->state);\r\nfimc_deactivate_capture(fimc);\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\nwait_event_timeout(fimc->irq_queue,\r\n!test_bit(ST_CAPT_SHUT, &fimc->state),\r\n(2*HZ/10));\r\nreturn fimc_capture_state_cleanup(fimc, suspend);\r\n}\r\nstatic int fimc_capture_config_update(struct fimc_ctx *ctx)\r\n{\r\nstruct fimc_dev *fimc = ctx->fimc_dev;\r\nint ret;\r\nfimc_hw_set_camera_offset(fimc, &ctx->s_frame);\r\nret = fimc_set_scaler_info(ctx);\r\nif (ret)\r\nreturn ret;\r\nfimc_hw_set_prescaler(ctx);\r\nfimc_hw_set_mainscaler(ctx);\r\nfimc_hw_set_target_format(ctx);\r\nfimc_hw_set_rotation(ctx);\r\nfimc_hw_set_effect(ctx);\r\nfimc_prepare_dma_offset(ctx, &ctx->d_frame);\r\nfimc_hw_set_out_dma(ctx);\r\nif (fimc->drv_data->alpha_color)\r\nfimc_hw_set_rgb_alpha(ctx);\r\nclear_bit(ST_CAPT_APPLY_CFG, &fimc->state);\r\nreturn ret;\r\n}\r\nvoid fimc_capture_irq_handler(struct fimc_dev *fimc, int deq_buf)\r\n{\r\nstruct fimc_vid_cap *cap = &fimc->vid_cap;\r\nstruct fimc_pipeline *p = to_fimc_pipeline(cap->ve.pipe);\r\nstruct v4l2_subdev *csis = p->subdevs[IDX_CSIS];\r\nstruct fimc_frame *f = &cap->ctx->d_frame;\r\nstruct fimc_vid_buffer *v_buf;\r\nstruct timeval *tv;\r\nstruct timespec ts;\r\nif (test_and_clear_bit(ST_CAPT_SHUT, &fimc->state)) {\r\nwake_up(&fimc->irq_queue);\r\ngoto done;\r\n}\r\nif (!list_empty(&cap->active_buf_q) &&\r\ntest_bit(ST_CAPT_RUN, &fimc->state) && deq_buf) {\r\nktime_get_real_ts(&ts);\r\nv_buf = fimc_active_queue_pop(cap);\r\ntv = &v_buf->vb.v4l2_buf.timestamp;\r\ntv->tv_sec = ts.tv_sec;\r\ntv->tv_usec = ts.tv_nsec / NSEC_PER_USEC;\r\nv_buf->vb.v4l2_buf.sequence = cap->frame_count++;\r\nvb2_buffer_done(&v_buf->vb, VB2_BUF_STATE_DONE);\r\n}\r\nif (!list_empty(&cap->pending_buf_q)) {\r\nv_buf = fimc_pending_queue_pop(cap);\r\nfimc_hw_set_output_addr(fimc, &v_buf->paddr, cap->buf_index);\r\nv_buf->index = cap->buf_index;\r\nfimc_active_queue_add(cap, v_buf);\r\ndbg("next frame: %d, done frame: %d",\r\nfimc_hw_get_frame_index(fimc), v_buf->index);\r\nif (++cap->buf_index >= FIMC_MAX_OUT_BUFS)\r\ncap->buf_index = 0;\r\n}\r\nif (f->fmt->mdataplanes && !list_empty(&cap->active_buf_q)) {\r\nunsigned int plane = ffs(f->fmt->mdataplanes) - 1;\r\nunsigned int size = f->payload[plane];\r\ns32 index = fimc_hw_get_frame_index(fimc);\r\nvoid *vaddr;\r\nlist_for_each_entry(v_buf, &cap->active_buf_q, list) {\r\nif (v_buf->index != index)\r\ncontinue;\r\nvaddr = vb2_plane_vaddr(&v_buf->vb, plane);\r\nv4l2_subdev_call(csis, video, s_rx_buffer,\r\nvaddr, &size);\r\nbreak;\r\n}\r\n}\r\nif (cap->active_buf_cnt == 0) {\r\nif (deq_buf)\r\nclear_bit(ST_CAPT_RUN, &fimc->state);\r\nif (++cap->buf_index >= FIMC_MAX_OUT_BUFS)\r\ncap->buf_index = 0;\r\n} else {\r\nset_bit(ST_CAPT_RUN, &fimc->state);\r\n}\r\nif (test_bit(ST_CAPT_APPLY_CFG, &fimc->state))\r\nfimc_capture_config_update(cap->ctx);\r\ndone:\r\nif (cap->active_buf_cnt == 1) {\r\nfimc_deactivate_capture(fimc);\r\nclear_bit(ST_CAPT_STREAM, &fimc->state);\r\n}\r\ndbg("frame: %d, active_buf_cnt: %d",\r\nfimc_hw_get_frame_index(fimc), cap->active_buf_cnt);\r\n}\r\nstatic int start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct fimc_ctx *ctx = q->drv_priv;\r\nstruct fimc_dev *fimc = ctx->fimc_dev;\r\nstruct fimc_vid_cap *vid_cap = &fimc->vid_cap;\r\nint min_bufs;\r\nint ret;\r\nvid_cap->frame_count = 0;\r\nret = fimc_capture_hw_init(fimc);\r\nif (ret) {\r\nfimc_capture_state_cleanup(fimc, false);\r\nreturn ret;\r\n}\r\nset_bit(ST_CAPT_PEND, &fimc->state);\r\nmin_bufs = fimc->vid_cap.reqbufs_count > 1 ? 2 : 1;\r\nif (vid_cap->active_buf_cnt >= min_bufs &&\r\n!test_and_set_bit(ST_CAPT_STREAM, &fimc->state)) {\r\nfimc_activate_capture(ctx);\r\nif (!test_and_set_bit(ST_CAPT_ISP_STREAM, &fimc->state))\r\nreturn fimc_pipeline_call(&vid_cap->ve, set_stream, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct fimc_ctx *ctx = q->drv_priv;\r\nstruct fimc_dev *fimc = ctx->fimc_dev;\r\nif (!fimc_capture_active(fimc))\r\nreturn -EINVAL;\r\nreturn fimc_stop_capture(fimc, false);\r\n}\r\nint fimc_capture_suspend(struct fimc_dev *fimc)\r\n{\r\nbool suspend = fimc_capture_busy(fimc);\r\nint ret = fimc_stop_capture(fimc, suspend);\r\nif (ret)\r\nreturn ret;\r\nreturn fimc_pipeline_call(&fimc->vid_cap.ve, close);\r\n}\r\nint fimc_capture_resume(struct fimc_dev *fimc)\r\n{\r\nstruct fimc_vid_cap *vid_cap = &fimc->vid_cap;\r\nstruct exynos_video_entity *ve = &vid_cap->ve;\r\nstruct fimc_vid_buffer *buf;\r\nint i;\r\nif (!test_and_clear_bit(ST_CAPT_SUSPENDED, &fimc->state))\r\nreturn 0;\r\nINIT_LIST_HEAD(&fimc->vid_cap.active_buf_q);\r\nvid_cap->buf_index = 0;\r\nfimc_pipeline_call(ve, open, &ve->vdev.entity, false);\r\nfimc_capture_hw_init(fimc);\r\nclear_bit(ST_CAPT_SUSPENDED, &fimc->state);\r\nfor (i = 0; i < vid_cap->reqbufs_count; i++) {\r\nif (list_empty(&vid_cap->pending_buf_q))\r\nbreak;\r\nbuf = fimc_pending_queue_pop(vid_cap);\r\nbuffer_queue(&buf->vb);\r\n}\r\nreturn 0;\r\n}\r\nstatic int queue_setup(struct vb2_queue *vq, const struct v4l2_format *pfmt,\r\nunsigned int *num_buffers, unsigned int *num_planes,\r\nunsigned int sizes[], void *allocators[])\r\n{\r\nconst struct v4l2_pix_format_mplane *pixm = NULL;\r\nstruct fimc_ctx *ctx = vq->drv_priv;\r\nstruct fimc_frame *frame = &ctx->d_frame;\r\nstruct fimc_fmt *fmt = frame->fmt;\r\nunsigned long wh;\r\nint i;\r\nif (pfmt) {\r\npixm = &pfmt->fmt.pix_mp;\r\nfmt = fimc_find_format(&pixm->pixelformat, NULL,\r\nFMT_FLAGS_CAM | FMT_FLAGS_M2M, -1);\r\nwh = pixm->width * pixm->height;\r\n} else {\r\nwh = frame->f_width * frame->f_height;\r\n}\r\nif (fmt == NULL)\r\nreturn -EINVAL;\r\n*num_planes = fmt->memplanes;\r\nfor (i = 0; i < fmt->memplanes; i++) {\r\nunsigned int size = (wh * fmt->depth[i]) / 8;\r\nif (pixm)\r\nsizes[i] = max(size, pixm->plane_fmt[i].sizeimage);\r\nelse if (fimc_fmt_is_user_defined(fmt->color))\r\nsizes[i] = frame->payload[i];\r\nelse\r\nsizes[i] = max_t(u32, size, frame->payload[i]);\r\nallocators[i] = ctx->fimc_dev->alloc_ctx;\r\n}\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *vq = vb->vb2_queue;\r\nstruct fimc_ctx *ctx = vq->drv_priv;\r\nint i;\r\nif (ctx->d_frame.fmt == NULL)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ctx->d_frame.fmt->memplanes; i++) {\r\nunsigned long size = ctx->d_frame.payload[i];\r\nif (vb2_plane_size(vb, i) < size) {\r\nv4l2_err(&ctx->fimc_dev->vid_cap.ve.vdev,\r\n"User buffer too small (%ld < %ld)\n",\r\nvb2_plane_size(vb, i), size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, i, size);\r\n}\r\nreturn 0;\r\n}\r\nstatic void buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct fimc_vid_buffer *buf\r\n= container_of(vb, struct fimc_vid_buffer, vb);\r\nstruct fimc_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct fimc_dev *fimc = ctx->fimc_dev;\r\nstruct fimc_vid_cap *vid_cap = &fimc->vid_cap;\r\nstruct exynos_video_entity *ve = &vid_cap->ve;\r\nunsigned long flags;\r\nint min_bufs;\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nfimc_prepare_addr(ctx, &buf->vb, &ctx->d_frame, &buf->paddr);\r\nif (!test_bit(ST_CAPT_SUSPENDED, &fimc->state) &&\r\n!test_bit(ST_CAPT_STREAM, &fimc->state) &&\r\nvid_cap->active_buf_cnt < FIMC_MAX_OUT_BUFS) {\r\nint buf_id = (vid_cap->reqbufs_count == 1) ? -1 :\r\nvid_cap->buf_index;\r\nfimc_hw_set_output_addr(fimc, &buf->paddr, buf_id);\r\nbuf->index = vid_cap->buf_index;\r\nfimc_active_queue_add(vid_cap, buf);\r\nif (++vid_cap->buf_index >= FIMC_MAX_OUT_BUFS)\r\nvid_cap->buf_index = 0;\r\n} else {\r\nfimc_pending_queue_add(vid_cap, buf);\r\n}\r\nmin_bufs = vid_cap->reqbufs_count > 1 ? 2 : 1;\r\nif (vb2_is_streaming(&vid_cap->vbq) &&\r\nvid_cap->active_buf_cnt >= min_bufs &&\r\n!test_and_set_bit(ST_CAPT_STREAM, &fimc->state)) {\r\nint ret;\r\nfimc_activate_capture(ctx);\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\nif (test_and_set_bit(ST_CAPT_ISP_STREAM, &fimc->state))\r\nreturn;\r\nret = fimc_pipeline_call(ve, set_stream, 1);\r\nif (ret < 0)\r\nv4l2_err(&ve->vdev, "stream on failed: %d\n", ret);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\n}\r\nstatic int fimc_capture_open(struct file *file)\r\n{\r\nstruct fimc_dev *fimc = video_drvdata(file);\r\nstruct fimc_vid_cap *vc = &fimc->vid_cap;\r\nstruct exynos_video_entity *ve = &vc->ve;\r\nint ret = -EBUSY;\r\ndbg("pid: %d, state: 0x%lx", task_pid_nr(current), fimc->state);\r\nmutex_lock(&fimc->lock);\r\nif (fimc_m2m_active(fimc))\r\ngoto unlock;\r\nset_bit(ST_CAPT_BUSY, &fimc->state);\r\nret = pm_runtime_get_sync(&fimc->pdev->dev);\r\nif (ret < 0)\r\ngoto unlock;\r\nret = v4l2_fh_open(file);\r\nif (ret) {\r\npm_runtime_put_sync(&fimc->pdev->dev);\r\ngoto unlock;\r\n}\r\nif (v4l2_fh_is_singular_file(file)) {\r\nfimc_md_graph_lock(ve);\r\nret = fimc_pipeline_call(ve, open, &ve->vdev.entity, true);\r\nif (ret == 0 && vc->user_subdev_api && vc->inh_sensor_ctrls) {\r\nfimc_ctrls_delete(vc->ctx);\r\nret = fimc_ctrls_create(vc->ctx);\r\nif (ret == 0)\r\nvc->inh_sensor_ctrls = false;\r\n}\r\nif (ret == 0)\r\nve->vdev.entity.use_count++;\r\nfimc_md_graph_unlock(ve);\r\nif (ret == 0)\r\nret = fimc_capture_set_default_format(fimc);\r\nif (ret < 0) {\r\nclear_bit(ST_CAPT_BUSY, &fimc->state);\r\npm_runtime_put_sync(&fimc->pdev->dev);\r\nv4l2_fh_release(file);\r\n}\r\n}\r\nunlock:\r\nmutex_unlock(&fimc->lock);\r\nreturn ret;\r\n}\r\nstatic int fimc_capture_release(struct file *file)\r\n{\r\nstruct fimc_dev *fimc = video_drvdata(file);\r\nstruct fimc_vid_cap *vc = &fimc->vid_cap;\r\nbool close = v4l2_fh_is_singular_file(file);\r\nint ret;\r\ndbg("pid: %d, state: 0x%lx", task_pid_nr(current), fimc->state);\r\nmutex_lock(&fimc->lock);\r\nif (close && vc->streaming) {\r\nmedia_entity_pipeline_stop(&vc->ve.vdev.entity);\r\nvc->streaming = false;\r\n}\r\nret = vb2_fop_release(file);\r\nif (close) {\r\nclear_bit(ST_CAPT_BUSY, &fimc->state);\r\nfimc_pipeline_call(&vc->ve, close);\r\nclear_bit(ST_CAPT_SUSPENDED, &fimc->state);\r\nfimc_md_graph_lock(&vc->ve);\r\nvc->ve.vdev.entity.use_count--;\r\nfimc_md_graph_unlock(&vc->ve);\r\n}\r\npm_runtime_put_sync(&fimc->pdev->dev);\r\nmutex_unlock(&fimc->lock);\r\nreturn ret;\r\n}\r\nstatic struct fimc_fmt *fimc_capture_try_format(struct fimc_ctx *ctx,\r\nu32 *width, u32 *height,\r\nu32 *code, u32 *fourcc, int pad)\r\n{\r\nbool rotation = ctx->rotation == 90 || ctx->rotation == 270;\r\nstruct fimc_dev *fimc = ctx->fimc_dev;\r\nconst struct fimc_variant *var = fimc->variant;\r\nconst struct fimc_pix_limit *pl = var->pix_limit;\r\nstruct fimc_frame *dst = &ctx->d_frame;\r\nu32 depth, min_w, max_w, min_h, align_h = 3;\r\nu32 mask = FMT_FLAGS_CAM;\r\nstruct fimc_fmt *ffmt;\r\nif (code && ctx->s_frame.fmt && pad == FIMC_SD_PAD_SOURCE &&\r\nfimc_fmt_is_user_defined(ctx->s_frame.fmt->color))\r\n*code = ctx->s_frame.fmt->mbus_code;\r\nif (fourcc && *fourcc != V4L2_PIX_FMT_JPEG && pad == FIMC_SD_PAD_SOURCE)\r\nmask |= FMT_FLAGS_M2M;\r\nif (pad == FIMC_SD_PAD_SINK_FIFO)\r\nmask = FMT_FLAGS_WRITEBACK;\r\nffmt = fimc_find_format(fourcc, code, mask, 0);\r\nif (WARN_ON(!ffmt))\r\nreturn NULL;\r\nif (code)\r\n*code = ffmt->mbus_code;\r\nif (fourcc)\r\n*fourcc = ffmt->fourcc;\r\nif (pad != FIMC_SD_PAD_SOURCE) {\r\nmax_w = fimc_fmt_is_user_defined(ffmt->color) ?\r\npl->scaler_dis_w : pl->scaler_en_w;\r\nv4l_bound_align_image(width, max_t(u32, *width, 32), max_w, 4,\r\nheight, max_t(u32, *height, 32),\r\nFIMC_CAMIF_MAX_HEIGHT,\r\nfimc_fmt_is_user_defined(ffmt->color) ?\r\n3 : 1,\r\n0);\r\nreturn ffmt;\r\n}\r\nif (fimc_fmt_is_user_defined(ffmt->color)) {\r\n*width = ctx->s_frame.f_width;\r\n*height = ctx->s_frame.f_height;\r\nreturn ffmt;\r\n}\r\nmax_w = rotation ? pl->out_rot_en_w : pl->out_rot_dis_w;\r\nif (ctx->state & FIMC_COMPOSE) {\r\nmin_w = dst->offs_h + dst->width;\r\nmin_h = dst->offs_v + dst->height;\r\n} else {\r\nmin_w = var->min_out_pixsize;\r\nmin_h = var->min_out_pixsize;\r\n}\r\nif (var->min_vsize_align == 1 && !rotation)\r\nalign_h = fimc_fmt_is_rgb(ffmt->color) ? 0 : 1;\r\ndepth = fimc_get_format_depth(ffmt);\r\nv4l_bound_align_image(width, min_w, max_w,\r\nffs(var->min_out_pixsize) - 1,\r\nheight, min_h, FIMC_CAMIF_MAX_HEIGHT,\r\nalign_h,\r\n64/(ALIGN(depth, 8)));\r\ndbg("pad%d: code: 0x%x, %dx%d. dst fmt: %dx%d",\r\npad, code ? *code : 0, *width, *height,\r\ndst->f_width, dst->f_height);\r\nreturn ffmt;\r\n}\r\nstatic void fimc_capture_try_selection(struct fimc_ctx *ctx,\r\nstruct v4l2_rect *r,\r\nint target)\r\n{\r\nbool rotate = ctx->rotation == 90 || ctx->rotation == 270;\r\nstruct fimc_dev *fimc = ctx->fimc_dev;\r\nconst struct fimc_variant *var = fimc->variant;\r\nconst struct fimc_pix_limit *pl = var->pix_limit;\r\nstruct fimc_frame *sink = &ctx->s_frame;\r\nu32 max_w, max_h, min_w = 0, min_h = 0, min_sz;\r\nu32 align_sz = 0, align_h = 4;\r\nu32 max_sc_h, max_sc_v;\r\nif (fimc_fmt_is_user_defined(ctx->d_frame.fmt->color)) {\r\nr->width = sink->f_width;\r\nr->height = sink->f_height;\r\nr->left = r->top = 0;\r\nreturn;\r\n}\r\nif (target == V4L2_SEL_TGT_COMPOSE) {\r\nif (ctx->rotation != 90 && ctx->rotation != 270)\r\nalign_h = 1;\r\nmax_sc_h = min(SCALER_MAX_HRATIO, 1 << (ffs(sink->width) - 3));\r\nmax_sc_v = min(SCALER_MAX_VRATIO, 1 << (ffs(sink->height) - 1));\r\nmin_sz = var->min_out_pixsize;\r\n} else {\r\nu32 depth = fimc_get_format_depth(sink->fmt);\r\nalign_sz = 64/ALIGN(depth, 8);\r\nmin_sz = var->min_inp_pixsize;\r\nmin_w = min_h = min_sz;\r\nmax_sc_h = max_sc_v = 1;\r\n}\r\nmax_w = min_t(u32,\r\nrotate ? pl->out_rot_en_w : pl->out_rot_dis_w,\r\nrotate ? sink->f_height : sink->f_width);\r\nmax_h = min_t(u32, FIMC_CAMIF_MAX_HEIGHT, sink->f_height);\r\nif (target == V4L2_SEL_TGT_COMPOSE) {\r\nmin_w = min_t(u32, max_w, sink->f_width / max_sc_h);\r\nmin_h = min_t(u32, max_h, sink->f_height / max_sc_v);\r\nif (rotate) {\r\nswap(max_sc_h, max_sc_v);\r\nswap(min_w, min_h);\r\n}\r\n}\r\nv4l_bound_align_image(&r->width, min_w, max_w, ffs(min_sz) - 1,\r\n&r->height, min_h, max_h, align_h,\r\nalign_sz);\r\nr->left = clamp_t(u32, r->left, 0, sink->f_width - r->width);\r\nr->top = clamp_t(u32, r->top, 0, sink->f_height - r->height);\r\nr->left = round_down(r->left, var->hor_offs_align);\r\ndbg("target %#x: (%d,%d)/%dx%d, sink fmt: %dx%d",\r\ntarget, r->left, r->top, r->width, r->height,\r\nsink->f_width, sink->f_height);\r\n}\r\nstatic int fimc_cap_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct fimc_dev *fimc = video_drvdata(file);\r\n__fimc_vidioc_querycap(&fimc->pdev->dev, cap, V4L2_CAP_STREAMING |\r\nV4L2_CAP_VIDEO_CAPTURE_MPLANE);\r\nreturn 0;\r\n}\r\nstatic int fimc_cap_enum_fmt_mplane(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct fimc_fmt *fmt;\r\nfmt = fimc_find_format(NULL, NULL, FMT_FLAGS_CAM | FMT_FLAGS_M2M,\r\nf->index);\r\nif (!fmt)\r\nreturn -EINVAL;\r\nstrncpy(f->description, fmt->name, sizeof(f->description) - 1);\r\nf->pixelformat = fmt->fourcc;\r\nif (fmt->fourcc == V4L2_MBUS_FMT_JPEG_1X8)\r\nf->flags |= V4L2_FMT_FLAG_COMPRESSED;\r\nreturn 0;\r\n}\r\nstatic struct media_entity *fimc_pipeline_get_head(struct media_entity *me)\r\n{\r\nstruct media_pad *pad = &me->pads[0];\r\nwhile (!(pad->flags & MEDIA_PAD_FL_SOURCE)) {\r\npad = media_entity_remote_pad(pad);\r\nif (!pad)\r\nbreak;\r\nme = pad->entity;\r\npad = &me->pads[0];\r\n}\r\nreturn me;\r\n}\r\nstatic int fimc_pipeline_try_format(struct fimc_ctx *ctx,\r\nstruct v4l2_mbus_framefmt *tfmt,\r\nstruct fimc_fmt **fmt_id,\r\nbool set)\r\n{\r\nstruct fimc_dev *fimc = ctx->fimc_dev;\r\nstruct fimc_pipeline *p = to_fimc_pipeline(fimc->vid_cap.ve.pipe);\r\nstruct v4l2_subdev *sd = p->subdevs[IDX_SENSOR];\r\nstruct v4l2_subdev_format sfmt;\r\nstruct v4l2_mbus_framefmt *mf = &sfmt.format;\r\nstruct media_entity *me;\r\nstruct fimc_fmt *ffmt;\r\nstruct media_pad *pad;\r\nint ret, i = 1;\r\nu32 fcc;\r\nif (WARN_ON(!sd || !tfmt))\r\nreturn -EINVAL;\r\nmemset(&sfmt, 0, sizeof(sfmt));\r\nsfmt.format = *tfmt;\r\nsfmt.which = set ? V4L2_SUBDEV_FORMAT_ACTIVE : V4L2_SUBDEV_FORMAT_TRY;\r\nme = fimc_pipeline_get_head(&sd->entity);\r\nwhile (1) {\r\nffmt = fimc_find_format(NULL, mf->code != 0 ? &mf->code : NULL,\r\nFMT_FLAGS_CAM, i++);\r\nif (ffmt == NULL) {\r\nreturn -EINVAL;\r\n}\r\nmf->code = tfmt->code = ffmt->mbus_code;\r\nwhile (me != &fimc->vid_cap.subdev.entity) {\r\nsd = media_entity_to_v4l2_subdev(me);\r\nsfmt.pad = 0;\r\nret = v4l2_subdev_call(sd, pad, set_fmt, NULL, &sfmt);\r\nif (ret)\r\nreturn ret;\r\nif (me->pads[0].flags & MEDIA_PAD_FL_SINK) {\r\nsfmt.pad = me->num_pads - 1;\r\nmf->code = tfmt->code;\r\nret = v4l2_subdev_call(sd, pad, set_fmt, NULL,\r\n&sfmt);\r\nif (ret)\r\nreturn ret;\r\n}\r\npad = media_entity_remote_pad(&me->pads[sfmt.pad]);\r\nif (!pad)\r\nreturn -EINVAL;\r\nme = pad->entity;\r\n}\r\nif (mf->code != tfmt->code)\r\ncontinue;\r\nfcc = ffmt->fourcc;\r\ntfmt->width = mf->width;\r\ntfmt->height = mf->height;\r\nffmt = fimc_capture_try_format(ctx, &tfmt->width, &tfmt->height,\r\nNULL, &fcc, FIMC_SD_PAD_SINK_CAM);\r\nffmt = fimc_capture_try_format(ctx, &tfmt->width, &tfmt->height,\r\nNULL, &fcc, FIMC_SD_PAD_SOURCE);\r\nif (ffmt && ffmt->mbus_code)\r\nmf->code = ffmt->mbus_code;\r\nif (mf->width != tfmt->width || mf->height != tfmt->height)\r\ncontinue;\r\ntfmt->code = mf->code;\r\nbreak;\r\n}\r\nif (fmt_id && ffmt)\r\n*fmt_id = ffmt;\r\n*tfmt = *mf;\r\nreturn 0;\r\n}\r\nstatic int fimc_get_sensor_frame_desc(struct v4l2_subdev *sensor,\r\nstruct v4l2_plane_pix_format *plane_fmt,\r\nunsigned int num_planes, bool try)\r\n{\r\nstruct v4l2_mbus_frame_desc fd;\r\nint i, ret;\r\nint pad;\r\nfor (i = 0; i < num_planes; i++)\r\nfd.entry[i].length = plane_fmt[i].sizeimage;\r\npad = sensor->entity.num_pads - 1;\r\nif (try)\r\nret = v4l2_subdev_call(sensor, pad, set_frame_desc, pad, &fd);\r\nelse\r\nret = v4l2_subdev_call(sensor, pad, get_frame_desc, pad, &fd);\r\nif (ret < 0)\r\nreturn ret;\r\nif (num_planes != fd.num_entries)\r\nreturn -EINVAL;\r\nfor (i = 0; i < num_planes; i++)\r\nplane_fmt[i].sizeimage = fd.entry[i].length;\r\nif (fd.entry[0].length > FIMC_MAX_JPEG_BUF_SIZE) {\r\nv4l2_err(sensor->v4l2_dev, "Unsupported buffer size: %u\n",\r\nfd.entry[0].length);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fimc_cap_g_fmt_mplane(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct fimc_dev *fimc = video_drvdata(file);\r\n__fimc_get_format(&fimc->vid_cap.ctx->d_frame, f);\r\nreturn 0;\r\n}\r\nstatic int __video_try_or_set_format(struct fimc_dev *fimc,\r\nstruct v4l2_format *f, bool try,\r\nstruct fimc_fmt **inp_fmt,\r\nstruct fimc_fmt **out_fmt)\r\n{\r\nstruct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;\r\nstruct fimc_vid_cap *vc = &fimc->vid_cap;\r\nstruct exynos_video_entity *ve = &vc->ve;\r\nstruct fimc_ctx *ctx = vc->ctx;\r\nunsigned int width = 0, height = 0;\r\nint ret = 0;\r\nif (fimc_jpeg_fourcc(pix->pixelformat)) {\r\nfimc_capture_try_format(ctx, &pix->width, &pix->height,\r\nNULL, &pix->pixelformat,\r\nFIMC_SD_PAD_SINK_CAM);\r\nif (try) {\r\nwidth = pix->width;\r\nheight = pix->height;\r\n} else {\r\nctx->s_frame.f_width = pix->width;\r\nctx->s_frame.f_height = pix->height;\r\n}\r\n}\r\n*out_fmt = fimc_capture_try_format(ctx, &pix->width, &pix->height,\r\nNULL, &pix->pixelformat,\r\nFIMC_SD_PAD_SOURCE);\r\nif (*out_fmt == NULL)\r\nreturn -EINVAL;\r\nif (try && fimc_jpeg_fourcc(pix->pixelformat)) {\r\npix->width = width;\r\npix->height = height;\r\n}\r\nif (!vc->user_subdev_api) {\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nstruct v4l2_mbus_framefmt *mf;\r\nmf = try ? &mbus_fmt : &fimc->vid_cap.ci_fmt;\r\nmf->code = (*out_fmt)->mbus_code;\r\nmf->width = pix->width;\r\nmf->height = pix->height;\r\nfimc_md_graph_lock(ve);\r\nret = fimc_pipeline_try_format(ctx, mf, inp_fmt, try);\r\nfimc_md_graph_unlock(ve);\r\nif (ret < 0)\r\nreturn ret;\r\npix->width = mf->width;\r\npix->height = mf->height;\r\n}\r\nfimc_adjust_mplane_format(*out_fmt, pix->width, pix->height, pix);\r\nif ((*out_fmt)->flags & FMT_FLAGS_COMPRESSED) {\r\nstruct v4l2_subdev *sensor;\r\nfimc_md_graph_lock(ve);\r\nsensor = __fimc_md_get_subdev(ve->pipe, IDX_SENSOR);\r\nif (sensor)\r\nfimc_get_sensor_frame_desc(sensor, pix->plane_fmt,\r\n(*out_fmt)->memplanes, try);\r\nelse\r\nret = -EPIPE;\r\nfimc_md_graph_unlock(ve);\r\n}\r\nreturn ret;\r\n}\r\nstatic int fimc_cap_try_fmt_mplane(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct fimc_dev *fimc = video_drvdata(file);\r\nstruct fimc_fmt *out_fmt = NULL, *inp_fmt = NULL;\r\nreturn __video_try_or_set_format(fimc, f, true, &inp_fmt, &out_fmt);\r\n}\r\nstatic void fimc_capture_mark_jpeg_xfer(struct fimc_ctx *ctx,\r\nenum fimc_color_fmt color)\r\n{\r\nbool jpeg = fimc_fmt_is_user_defined(color);\r\nctx->scaler.enabled = !jpeg;\r\nfimc_ctrls_activate(ctx, !jpeg);\r\nif (jpeg)\r\nset_bit(ST_CAPT_JPEG, &ctx->fimc_dev->state);\r\nelse\r\nclear_bit(ST_CAPT_JPEG, &ctx->fimc_dev->state);\r\n}\r\nstatic int __fimc_capture_set_format(struct fimc_dev *fimc,\r\nstruct v4l2_format *f)\r\n{\r\nstruct fimc_vid_cap *vc = &fimc->vid_cap;\r\nstruct fimc_ctx *ctx = vc->ctx;\r\nstruct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;\r\nstruct fimc_frame *ff = &ctx->d_frame;\r\nstruct fimc_fmt *inp_fmt = NULL;\r\nint ret, i;\r\nif (vb2_is_busy(&fimc->vid_cap.vbq))\r\nreturn -EBUSY;\r\nret = __video_try_or_set_format(fimc, f, false, &inp_fmt, &ff->fmt);\r\nif (ret < 0)\r\nreturn ret;\r\nfimc_alpha_ctrl_update(ctx);\r\nfor (i = 0; i < ff->fmt->memplanes; i++) {\r\nff->bytesperline[i] = pix->plane_fmt[i].bytesperline;\r\nff->payload[i] = pix->plane_fmt[i].sizeimage;\r\n}\r\nset_frame_bounds(ff, pix->width, pix->height);\r\nif (!(ctx->state & FIMC_COMPOSE))\r\nset_frame_crop(ff, 0, 0, pix->width, pix->height);\r\nfimc_capture_mark_jpeg_xfer(ctx, ff->fmt->color);\r\nif (!vc->user_subdev_api) {\r\nctx->s_frame.fmt = inp_fmt;\r\nset_frame_bounds(&ctx->s_frame, pix->width, pix->height);\r\nset_frame_crop(&ctx->s_frame, 0, 0, pix->width, pix->height);\r\n}\r\nreturn ret;\r\n}\r\nstatic int fimc_cap_s_fmt_mplane(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct fimc_dev *fimc = video_drvdata(file);\r\nreturn __fimc_capture_set_format(fimc, f);\r\n}\r\nstatic int fimc_cap_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct fimc_dev *fimc = video_drvdata(file);\r\nstruct exynos_video_entity *ve = &fimc->vid_cap.ve;\r\nstruct v4l2_subdev *sd;\r\nif (i->index != 0)\r\nreturn -EINVAL;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nfimc_md_graph_lock(ve);\r\nsd = __fimc_md_get_subdev(ve->pipe, IDX_SENSOR);\r\nfimc_md_graph_unlock(ve);\r\nif (sd)\r\nstrlcpy(i->name, sd->name, sizeof(i->name));\r\nreturn 0;\r\n}\r\nstatic int fimc_cap_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nreturn i == 0 ? i : -EINVAL;\r\n}\r\nstatic int fimc_cap_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int fimc_pipeline_validate(struct fimc_dev *fimc)\r\n{\r\nstruct v4l2_subdev_format sink_fmt, src_fmt;\r\nstruct fimc_vid_cap *vc = &fimc->vid_cap;\r\nstruct v4l2_subdev *sd = &vc->subdev;\r\nstruct fimc_pipeline *p = to_fimc_pipeline(vc->ve.pipe);\r\nstruct media_pad *sink_pad, *src_pad;\r\nint i, ret;\r\nwhile (1) {\r\nsrc_pad = NULL;\r\nfor (i = 0; i < sd->entity.num_pads; i++) {\r\nstruct media_pad *p = &sd->entity.pads[i];\r\nif (p->flags & MEDIA_PAD_FL_SINK) {\r\nsink_pad = p;\r\nsrc_pad = media_entity_remote_pad(sink_pad);\r\nif (src_pad)\r\nbreak;\r\n}\r\n}\r\nif (src_pad == NULL ||\r\nmedia_entity_type(src_pad->entity) != MEDIA_ENT_T_V4L2_SUBDEV)\r\nbreak;\r\nif (sd == &vc->subdev) {\r\nstruct fimc_frame *ff = &vc->ctx->s_frame;\r\nsink_fmt.format.width = ff->f_width;\r\nsink_fmt.format.height = ff->f_height;\r\nsink_fmt.format.code = ff->fmt ? ff->fmt->mbus_code : 0;\r\n} else {\r\nsink_fmt.pad = sink_pad->index;\r\nsink_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &sink_fmt);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn -EPIPE;\r\n}\r\nsd = media_entity_to_v4l2_subdev(src_pad->entity);\r\nsrc_fmt.pad = src_pad->index;\r\nsrc_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &src_fmt);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn -EPIPE;\r\nif (src_fmt.format.width != sink_fmt.format.width ||\r\nsrc_fmt.format.height != sink_fmt.format.height ||\r\nsrc_fmt.format.code != sink_fmt.format.code)\r\nreturn -EPIPE;\r\nif (sd == p->subdevs[IDX_SENSOR] &&\r\nfimc_user_defined_mbus_fmt(src_fmt.format.code)) {\r\nstruct v4l2_plane_pix_format plane_fmt[FIMC_MAX_PLANES];\r\nstruct fimc_frame *frame = &vc->ctx->d_frame;\r\nunsigned int i;\r\nret = fimc_get_sensor_frame_desc(sd, plane_fmt,\r\nframe->fmt->memplanes,\r\nfalse);\r\nif (ret < 0)\r\nreturn -EPIPE;\r\nfor (i = 0; i < frame->fmt->memplanes; i++)\r\nif (frame->payload[i] < plane_fmt[i].sizeimage)\r\nreturn -EPIPE;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int fimc_cap_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct fimc_dev *fimc = video_drvdata(file);\r\nstruct fimc_vid_cap *vc = &fimc->vid_cap;\r\nstruct media_entity *entity = &vc->ve.vdev.entity;\r\nstruct fimc_source_info *si = NULL;\r\nstruct v4l2_subdev *sd;\r\nint ret;\r\nif (fimc_capture_active(fimc))\r\nreturn -EBUSY;\r\nret = media_entity_pipeline_start(entity, &vc->ve.pipe->mp);\r\nif (ret < 0)\r\nreturn ret;\r\nsd = __fimc_md_get_subdev(vc->ve.pipe, IDX_SENSOR);\r\nif (sd)\r\nsi = v4l2_get_subdev_hostdata(sd);\r\nif (si == NULL) {\r\nret = -EPIPE;\r\ngoto err_p_stop;\r\n}\r\nvc->source_config = *si;\r\nif (vc->input == GRP_ID_FIMC_IS)\r\nvc->source_config.fimc_bus_type = FIMC_BUS_TYPE_ISP_WRITEBACK;\r\nif (vc->user_subdev_api) {\r\nret = fimc_pipeline_validate(fimc);\r\nif (ret < 0)\r\ngoto err_p_stop;\r\n}\r\nret = vb2_ioctl_streamon(file, priv, type);\r\nif (!ret) {\r\nvc->streaming = true;\r\nreturn ret;\r\n}\r\nerr_p_stop:\r\nmedia_entity_pipeline_stop(entity);\r\nreturn ret;\r\n}\r\nstatic int fimc_cap_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct fimc_dev *fimc = video_drvdata(file);\r\nstruct fimc_vid_cap *vc = &fimc->vid_cap;\r\nint ret;\r\nret = vb2_ioctl_streamoff(file, priv, type);\r\nif (ret < 0)\r\nreturn ret;\r\nmedia_entity_pipeline_stop(&vc->ve.vdev.entity);\r\nvc->streaming = false;\r\nreturn 0;\r\n}\r\nstatic int fimc_cap_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *reqbufs)\r\n{\r\nstruct fimc_dev *fimc = video_drvdata(file);\r\nint ret;\r\nret = vb2_ioctl_reqbufs(file, priv, reqbufs);\r\nif (!ret)\r\nfimc->vid_cap.reqbufs_count = reqbufs->count;\r\nreturn ret;\r\n}\r\nstatic int fimc_cap_g_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct fimc_dev *fimc = video_drvdata(file);\r\nstruct fimc_ctx *ctx = fimc->vid_cap.ctx;\r\nstruct fimc_frame *f = &ctx->s_frame;\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\nreturn -EINVAL;\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\nf = &ctx->d_frame;\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\ns->r.left = 0;\r\ns->r.top = 0;\r\ns->r.width = f->o_width;\r\ns->r.height = f->o_height;\r\nreturn 0;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\nf = &ctx->d_frame;\r\ncase V4L2_SEL_TGT_CROP:\r\ns->r.left = f->offs_h;\r\ns->r.top = f->offs_v;\r\ns->r.width = f->width;\r\ns->r.height = f->height;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int enclosed_rectangle(struct v4l2_rect *a, struct v4l2_rect *b)\r\n{\r\nif (a->left < b->left || a->top < b->top)\r\nreturn 0;\r\nif (a->left + a->width > b->left + b->width)\r\nreturn 0;\r\nif (a->top + a->height > b->top + b->height)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int fimc_cap_s_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct fimc_dev *fimc = video_drvdata(file);\r\nstruct fimc_ctx *ctx = fimc->vid_cap.ctx;\r\nstruct v4l2_rect rect = s->r;\r\nstruct fimc_frame *f;\r\nunsigned long flags;\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\nreturn -EINVAL;\r\nif (s->target == V4L2_SEL_TGT_COMPOSE)\r\nf = &ctx->d_frame;\r\nelse if (s->target == V4L2_SEL_TGT_CROP)\r\nf = &ctx->s_frame;\r\nelse\r\nreturn -EINVAL;\r\nfimc_capture_try_selection(ctx, &rect, s->target);\r\nif (s->flags & V4L2_SEL_FLAG_LE &&\r\n!enclosed_rectangle(&rect, &s->r))\r\nreturn -ERANGE;\r\nif (s->flags & V4L2_SEL_FLAG_GE &&\r\n!enclosed_rectangle(&s->r, &rect))\r\nreturn -ERANGE;\r\ns->r = rect;\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nset_frame_crop(f, s->r.left, s->r.top, s->r.width,\r\ns->r.height);\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\nset_bit(ST_CAPT_APPLY_CFG, &fimc->state);\r\nreturn 0;\r\n}\r\nstatic int fimc_link_setup(struct media_entity *entity,\r\nconst struct media_pad *local,\r\nconst struct media_pad *remote, u32 flags)\r\n{\r\nstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\r\nstruct fimc_dev *fimc = v4l2_get_subdevdata(sd);\r\nstruct fimc_vid_cap *vc = &fimc->vid_cap;\r\nstruct v4l2_subdev *sensor;\r\nif (media_entity_type(remote->entity) != MEDIA_ENT_T_V4L2_SUBDEV)\r\nreturn -EINVAL;\r\nif (WARN_ON(fimc == NULL))\r\nreturn 0;\r\ndbg("%s --> %s, flags: 0x%x. input: 0x%x",\r\nlocal->entity->name, remote->entity->name, flags,\r\nfimc->vid_cap.input);\r\nif (!(flags & MEDIA_LNK_FL_ENABLED)) {\r\nfimc->vid_cap.input = 0;\r\nreturn 0;\r\n}\r\nif (vc->input != 0)\r\nreturn -EBUSY;\r\nvc->input = sd->grp_id;\r\nif (vc->user_subdev_api || vc->inh_sensor_ctrls)\r\nreturn 0;\r\nsensor = fimc_find_remote_sensor(&vc->subdev.entity);\r\nif (sensor == NULL)\r\nreturn 0;\r\nreturn v4l2_ctrl_add_handler(&vc->ctx->ctrls.handler,\r\nsensor->ctrl_handler, NULL);\r\n}\r\nvoid fimc_sensor_notify(struct v4l2_subdev *sd, unsigned int notification,\r\nvoid *arg)\r\n{\r\nstruct fimc_source_info *si;\r\nstruct fimc_vid_buffer *buf;\r\nstruct fimc_md *fmd;\r\nstruct fimc_dev *fimc;\r\nunsigned long flags;\r\nif (sd == NULL)\r\nreturn;\r\nsi = v4l2_get_subdev_hostdata(sd);\r\nfmd = entity_to_fimc_mdev(&sd->entity);\r\nspin_lock_irqsave(&fmd->slock, flags);\r\nfimc = si ? source_to_sensor_info(si)->host : NULL;\r\nif (fimc && arg && notification == S5P_FIMC_TX_END_NOTIFY &&\r\ntest_bit(ST_CAPT_PEND, &fimc->state)) {\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&fimc->slock, irq_flags);\r\nif (!list_empty(&fimc->vid_cap.active_buf_q)) {\r\nbuf = list_entry(fimc->vid_cap.active_buf_q.next,\r\nstruct fimc_vid_buffer, list);\r\nvb2_set_plane_payload(&buf->vb, 0, *((u32 *)arg));\r\n}\r\nfimc_capture_irq_handler(fimc, 1);\r\nfimc_deactivate_capture(fimc);\r\nspin_unlock_irqrestore(&fimc->slock, irq_flags);\r\n}\r\nspin_unlock_irqrestore(&fmd->slock, flags);\r\n}\r\nstatic int fimc_subdev_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstruct fimc_fmt *fmt;\r\nfmt = fimc_find_format(NULL, NULL, FMT_FLAGS_CAM, code->index);\r\nif (!fmt)\r\nreturn -EINVAL;\r\ncode->code = fmt->mbus_code;\r\nreturn 0;\r\n}\r\nstatic int fimc_subdev_get_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct fimc_dev *fimc = v4l2_get_subdevdata(sd);\r\nstruct fimc_ctx *ctx = fimc->vid_cap.ctx;\r\nstruct fimc_frame *ff = &ctx->s_frame;\r\nstruct v4l2_mbus_framefmt *mf;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nmf = v4l2_subdev_get_try_format(fh, fmt->pad);\r\nfmt->format = *mf;\r\nreturn 0;\r\n}\r\nmf = &fmt->format;\r\nmutex_lock(&fimc->lock);\r\nswitch (fmt->pad) {\r\ncase FIMC_SD_PAD_SOURCE:\r\nif (!WARN_ON(ff->fmt == NULL))\r\nmf->code = ff->fmt->mbus_code;\r\nmf->width = ff->width;\r\nmf->height = ff->height;\r\nbreak;\r\ncase FIMC_SD_PAD_SINK_FIFO:\r\n*mf = fimc->vid_cap.wb_fmt;\r\nbreak;\r\ncase FIMC_SD_PAD_SINK_CAM:\r\ndefault:\r\n*mf = fimc->vid_cap.ci_fmt;\r\nbreak;\r\n}\r\nmutex_unlock(&fimc->lock);\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\nreturn 0;\r\n}\r\nstatic int fimc_subdev_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct fimc_dev *fimc = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *mf = &fmt->format;\r\nstruct fimc_vid_cap *vc = &fimc->vid_cap;\r\nstruct fimc_ctx *ctx = vc->ctx;\r\nstruct fimc_frame *ff;\r\nstruct fimc_fmt *ffmt;\r\ndbg("pad%d: code: 0x%x, %dx%d",\r\nfmt->pad, mf->code, mf->width, mf->height);\r\nif (fmt->pad == FIMC_SD_PAD_SOURCE && vb2_is_busy(&vc->vbq))\r\nreturn -EBUSY;\r\nmutex_lock(&fimc->lock);\r\nffmt = fimc_capture_try_format(ctx, &mf->width, &mf->height,\r\n&mf->code, NULL, fmt->pad);\r\nmutex_unlock(&fimc->lock);\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nmf = v4l2_subdev_get_try_format(fh, fmt->pad);\r\n*mf = fmt->format;\r\nreturn 0;\r\n}\r\nif (WARN_ON(ffmt == NULL))\r\nreturn -EINVAL;\r\nfimc_alpha_ctrl_update(ctx);\r\nfimc_capture_mark_jpeg_xfer(ctx, ffmt->color);\r\nif (fmt->pad == FIMC_SD_PAD_SOURCE) {\r\nff = &ctx->d_frame;\r\nmf->width = ctx->s_frame.width;\r\nmf->height = ctx->s_frame.height;\r\n} else {\r\nff = &ctx->s_frame;\r\n}\r\nmutex_lock(&fimc->lock);\r\nset_frame_bounds(ff, mf->width, mf->height);\r\nif (fmt->pad == FIMC_SD_PAD_SINK_FIFO)\r\nvc->wb_fmt = *mf;\r\nelse if (fmt->pad == FIMC_SD_PAD_SINK_CAM)\r\nvc->ci_fmt = *mf;\r\nff->fmt = ffmt;\r\nif (!(fmt->pad == FIMC_SD_PAD_SOURCE && (ctx->state & FIMC_COMPOSE)))\r\nset_frame_crop(ff, 0, 0, mf->width, mf->height);\r\nif (fmt->pad != FIMC_SD_PAD_SOURCE)\r\nctx->state &= ~FIMC_COMPOSE;\r\nmutex_unlock(&fimc->lock);\r\nreturn 0;\r\n}\r\nstatic int fimc_subdev_get_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct fimc_dev *fimc = v4l2_get_subdevdata(sd);\r\nstruct fimc_ctx *ctx = fimc->vid_cap.ctx;\r\nstruct fimc_frame *f = &ctx->s_frame;\r\nstruct v4l2_rect *r = &sel->r;\r\nstruct v4l2_rect *try_sel;\r\nif (sel->pad == FIMC_SD_PAD_SOURCE)\r\nreturn -EINVAL;\r\nmutex_lock(&fimc->lock);\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\nf = &ctx->d_frame;\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\nr->width = f->o_width;\r\nr->height = f->o_height;\r\nr->left = 0;\r\nr->top = 0;\r\nmutex_unlock(&fimc->lock);\r\nreturn 0;\r\ncase V4L2_SEL_TGT_CROP:\r\ntry_sel = v4l2_subdev_get_try_crop(fh, sel->pad);\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\ntry_sel = v4l2_subdev_get_try_compose(fh, sel->pad);\r\nf = &ctx->d_frame;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&fimc->lock);\r\nreturn -EINVAL;\r\n}\r\nif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nsel->r = *try_sel;\r\n} else {\r\nr->left = f->offs_h;\r\nr->top = f->offs_v;\r\nr->width = f->width;\r\nr->height = f->height;\r\n}\r\ndbg("target %#x: l:%d, t:%d, %dx%d, f_w: %d, f_h: %d",\r\nsel->pad, r->left, r->top, r->width, r->height,\r\nf->f_width, f->f_height);\r\nmutex_unlock(&fimc->lock);\r\nreturn 0;\r\n}\r\nstatic int fimc_subdev_set_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct fimc_dev *fimc = v4l2_get_subdevdata(sd);\r\nstruct fimc_ctx *ctx = fimc->vid_cap.ctx;\r\nstruct fimc_frame *f = &ctx->s_frame;\r\nstruct v4l2_rect *r = &sel->r;\r\nstruct v4l2_rect *try_sel;\r\nunsigned long flags;\r\nif (sel->pad == FIMC_SD_PAD_SOURCE)\r\nreturn -EINVAL;\r\nmutex_lock(&fimc->lock);\r\nfimc_capture_try_selection(ctx, r, V4L2_SEL_TGT_CROP);\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP:\r\ntry_sel = v4l2_subdev_get_try_crop(fh, sel->pad);\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\ntry_sel = v4l2_subdev_get_try_compose(fh, sel->pad);\r\nf = &ctx->d_frame;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&fimc->lock);\r\nreturn -EINVAL;\r\n}\r\nif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\r\n*try_sel = sel->r;\r\n} else {\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nset_frame_crop(f, r->left, r->top, r->width, r->height);\r\nset_bit(ST_CAPT_APPLY_CFG, &fimc->state);\r\nif (sel->target == V4L2_SEL_TGT_COMPOSE)\r\nctx->state |= FIMC_COMPOSE;\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\n}\r\ndbg("target %#x: (%d,%d)/%dx%d", sel->target, r->left, r->top,\r\nr->width, r->height);\r\nmutex_unlock(&fimc->lock);\r\nreturn 0;\r\n}\r\nstatic int fimc_capture_set_default_format(struct fimc_dev *fimc)\r\n{\r\nstruct v4l2_format fmt = {\r\n.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,\r\n.fmt.pix_mp = {\r\n.width = FIMC_DEFAULT_WIDTH,\r\n.height = FIMC_DEFAULT_HEIGHT,\r\n.pixelformat = V4L2_PIX_FMT_YUYV,\r\n.field = V4L2_FIELD_NONE,\r\n.colorspace = V4L2_COLORSPACE_JPEG,\r\n},\r\n};\r\nreturn __fimc_capture_set_format(fimc, &fmt);\r\n}\r\nstatic int fimc_register_capture_device(struct fimc_dev *fimc,\r\nstruct v4l2_device *v4l2_dev)\r\n{\r\nstruct video_device *vfd = &fimc->vid_cap.ve.vdev;\r\nstruct vb2_queue *q = &fimc->vid_cap.vbq;\r\nstruct fimc_ctx *ctx;\r\nstruct fimc_vid_cap *vid_cap;\r\nstruct fimc_fmt *fmt;\r\nint ret = -ENOMEM;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->fimc_dev = fimc;\r\nctx->in_path = FIMC_IO_CAMERA;\r\nctx->out_path = FIMC_IO_DMA;\r\nctx->state = FIMC_CTX_CAP;\r\nctx->s_frame.fmt = fimc_find_format(NULL, NULL, FMT_FLAGS_CAM, 0);\r\nctx->d_frame.fmt = ctx->s_frame.fmt;\r\nmemset(vfd, 0, sizeof(*vfd));\r\nsnprintf(vfd->name, sizeof(vfd->name), "fimc.%d.capture", fimc->id);\r\nvfd->fops = &fimc_capture_fops;\r\nvfd->ioctl_ops = &fimc_capture_ioctl_ops;\r\nvfd->v4l2_dev = v4l2_dev;\r\nvfd->minor = -1;\r\nvfd->release = video_device_release_empty;\r\nvfd->queue = q;\r\nvfd->lock = &fimc->lock;\r\nvideo_set_drvdata(vfd, fimc);\r\nvid_cap = &fimc->vid_cap;\r\nvid_cap->active_buf_cnt = 0;\r\nvid_cap->reqbufs_count = 0;\r\nvid_cap->ctx = ctx;\r\nINIT_LIST_HEAD(&vid_cap->pending_buf_q);\r\nINIT_LIST_HEAD(&vid_cap->active_buf_q);\r\nmemset(q, 0, sizeof(*q));\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\nq->drv_priv = ctx;\r\nq->ops = &fimc_capture_qops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->buf_struct_size = sizeof(struct fimc_vid_buffer);\r\nq->timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->lock = &fimc->lock;\r\nret = vb2_queue_init(q);\r\nif (ret)\r\ngoto err_free_ctx;\r\nfmt = fimc_find_format(NULL, NULL, FMT_FLAGS_CAM, 0);\r\nvid_cap->ci_fmt.width = FIMC_DEFAULT_WIDTH;\r\nvid_cap->ci_fmt.height = FIMC_DEFAULT_HEIGHT;\r\nvid_cap->ci_fmt.code = fmt->mbus_code;\r\nctx->s_frame.width = FIMC_DEFAULT_WIDTH;\r\nctx->s_frame.height = FIMC_DEFAULT_HEIGHT;\r\nctx->s_frame.fmt = fmt;\r\nfmt = fimc_find_format(NULL, NULL, FMT_FLAGS_WRITEBACK, 0);\r\nvid_cap->wb_fmt = vid_cap->ci_fmt;\r\nvid_cap->wb_fmt.code = fmt->mbus_code;\r\nvid_cap->vd_pad.flags = MEDIA_PAD_FL_SINK;\r\nret = media_entity_init(&vfd->entity, 1, &vid_cap->vd_pad, 0);\r\nif (ret)\r\ngoto err_free_ctx;\r\nret = fimc_ctrls_create(ctx);\r\nif (ret)\r\ngoto err_me_cleanup;\r\nret = video_register_device(vfd, VFL_TYPE_GRABBER, -1);\r\nif (ret)\r\ngoto err_ctrl_free;\r\nv4l2_info(v4l2_dev, "Registered %s as /dev/%s\n",\r\nvfd->name, video_device_node_name(vfd));\r\nvfd->ctrl_handler = &ctx->ctrls.handler;\r\nreturn 0;\r\nerr_ctrl_free:\r\nfimc_ctrls_delete(ctx);\r\nerr_me_cleanup:\r\nmedia_entity_cleanup(&vfd->entity);\r\nerr_free_ctx:\r\nkfree(ctx);\r\nreturn ret;\r\n}\r\nstatic int fimc_capture_subdev_registered(struct v4l2_subdev *sd)\r\n{\r\nstruct fimc_dev *fimc = v4l2_get_subdevdata(sd);\r\nint ret;\r\nif (fimc == NULL)\r\nreturn -ENXIO;\r\nret = fimc_register_m2m_device(fimc, sd->v4l2_dev);\r\nif (ret)\r\nreturn ret;\r\nfimc->vid_cap.ve.pipe = v4l2_get_subdev_hostdata(sd);\r\nret = fimc_register_capture_device(fimc, sd->v4l2_dev);\r\nif (ret) {\r\nfimc_unregister_m2m_device(fimc);\r\nfimc->vid_cap.ve.pipe = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void fimc_capture_subdev_unregistered(struct v4l2_subdev *sd)\r\n{\r\nstruct fimc_dev *fimc = v4l2_get_subdevdata(sd);\r\nstruct video_device *vdev;\r\nif (fimc == NULL)\r\nreturn;\r\nmutex_lock(&fimc->lock);\r\nfimc_unregister_m2m_device(fimc);\r\nvdev = &fimc->vid_cap.ve.vdev;\r\nif (video_is_registered(vdev)) {\r\nvideo_unregister_device(vdev);\r\nmedia_entity_cleanup(&vdev->entity);\r\nfimc_ctrls_delete(fimc->vid_cap.ctx);\r\nfimc->vid_cap.ve.pipe = NULL;\r\n}\r\nkfree(fimc->vid_cap.ctx);\r\nfimc->vid_cap.ctx = NULL;\r\nmutex_unlock(&fimc->lock);\r\n}\r\nint fimc_initialize_capture_subdev(struct fimc_dev *fimc)\r\n{\r\nstruct v4l2_subdev *sd = &fimc->vid_cap.subdev;\r\nint ret;\r\nv4l2_subdev_init(sd, &fimc_subdev_ops);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nsnprintf(sd->name, sizeof(sd->name), "FIMC.%d", fimc->id);\r\nfimc->vid_cap.sd_pads[FIMC_SD_PAD_SINK_CAM].flags = MEDIA_PAD_FL_SINK;\r\nfimc->vid_cap.sd_pads[FIMC_SD_PAD_SINK_FIFO].flags = MEDIA_PAD_FL_SINK;\r\nfimc->vid_cap.sd_pads[FIMC_SD_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_init(&sd->entity, FIMC_SD_PADS_NUM,\r\nfimc->vid_cap.sd_pads, 0);\r\nif (ret)\r\nreturn ret;\r\nsd->entity.ops = &fimc_sd_media_ops;\r\nsd->internal_ops = &fimc_capture_sd_internal_ops;\r\nv4l2_set_subdevdata(sd, fimc);\r\nreturn 0;\r\n}\r\nvoid fimc_unregister_capture_subdev(struct fimc_dev *fimc)\r\n{\r\nstruct v4l2_subdev *sd = &fimc->vid_cap.subdev;\r\nv4l2_device_unregister_subdev(sd);\r\nmedia_entity_cleanup(&sd->entity);\r\nv4l2_set_subdevdata(sd, NULL);\r\n}
