int PHSTransmit(struct bcm_mini_adapter *Adapter,\r\nstruct sk_buff **pPacket,\r\nUSHORT Vcid,\r\nB_UINT16 uiClassifierRuleID,\r\nBOOLEAN bHeaderSuppressionEnabled,\r\nUINT *PacketLen,\r\nUCHAR bEthCSSupport)\r\n{\r\nUINT unPHSPktHdrBytesCopied = 0;\r\nUINT unPhsOldHdrSize = 0;\r\nUINT unPHSNewPktHeaderLen = 0;\r\nPUCHAR pucPHSPktHdrInBuf = Adapter->stPhsTxContextInfo.ucaHdrSuppressionInBuf;\r\nPUCHAR pucPHSPktHdrOutBuf = Adapter->stPhsTxContextInfo.ucaHdrSuppressionOutBuf;\r\nUINT usPacketType;\r\nUINT BytesToRemove = 0;\r\nBOOLEAN bPHSI = 0;\r\nLONG ulPhsStatus = 0;\r\nUINT numBytesCompressed = 0;\r\nstruct sk_buff *newPacket = NULL;\r\nstruct sk_buff *Packet = *pPacket;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL, "In PHSTransmit");\r\nif (!bEthCSSupport)\r\nBytesToRemove = ETH_HLEN;\r\nusPacketType = ((struct ethhdr *)(Packet->data))->h_proto;\r\npucPHSPktHdrInBuf = Packet->data + BytesToRemove;\r\nif ((*PacketLen - BytesToRemove) < MAX_PHS_LENGTHS)\r\nunPHSPktHdrBytesCopied = (*PacketLen - BytesToRemove);\r\nelse\r\nunPHSPktHdrBytesCopied = MAX_PHS_LENGTHS;\r\nif ((unPHSPktHdrBytesCopied > 0) &&\r\n(unPHSPktHdrBytesCopied <= MAX_PHS_LENGTHS)) {\r\nif (((usPacketType == ETHERNET_FRAMETYPE_IPV4) ||\r\n(usPacketType == ETHERNET_FRAMETYPE_IPV6)) &&\r\n(bHeaderSuppressionEnabled)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL, "\nTrying to PHS Compress Using Classifier rule 0x%X", uiClassifierRuleID);\r\nunPHSNewPktHeaderLen = unPHSPktHdrBytesCopied;\r\nulPhsStatus = PhsCompress(&Adapter->stBCMPhsContext,\r\nVcid,\r\nuiClassifierRuleID,\r\npucPHSPktHdrInBuf,\r\npucPHSPktHdrOutBuf,\r\n&unPhsOldHdrSize,\r\n&unPHSNewPktHeaderLen);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL, "\nPHS Old header Size : %d New Header Size %d\n", unPhsOldHdrSize, unPHSNewPktHeaderLen);\r\nif (unPHSNewPktHeaderLen == unPhsOldHdrSize) {\r\nif (ulPhsStatus == STATUS_PHS_COMPRESSED)\r\nbPHSI = *pucPHSPktHdrOutBuf;\r\nulPhsStatus = STATUS_PHS_NOCOMPRESSION;\r\n}\r\nif (ulPhsStatus == STATUS_PHS_COMPRESSED) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL, "PHS Sending packet Compressed");\r\nif (skb_cloned(Packet)) {\r\nnewPacket = skb_copy(Packet, GFP_ATOMIC);\r\nif (newPacket == NULL)\r\nreturn STATUS_FAILURE;\r\ndev_kfree_skb(Packet);\r\n*pPacket = Packet = newPacket;\r\npucPHSPktHdrInBuf = Packet->data + BytesToRemove;\r\n}\r\nnumBytesCompressed = unPhsOldHdrSize - (unPHSNewPktHeaderLen + PHSI_LEN);\r\nmemcpy(pucPHSPktHdrInBuf + numBytesCompressed, pucPHSPktHdrOutBuf, unPHSNewPktHeaderLen + PHSI_LEN);\r\nmemcpy(Packet->data + numBytesCompressed, Packet->data, BytesToRemove);\r\nskb_pull(Packet, numBytesCompressed);\r\nreturn STATUS_SUCCESS;\r\n} else {\r\nif (!(skb_headroom(Packet) > 0)) {\r\nif (skb_cow(Packet, 1)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "SKB Cow Failed\n");\r\nreturn STATUS_FAILURE;\r\n}\r\n}\r\nskb_push(Packet, 1);\r\n*(Packet->data + BytesToRemove) = bPHSI;\r\nreturn STATUS_SUCCESS;\r\n}\r\n} else {\r\nif (!bHeaderSuppressionEnabled)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL, "\nHeader Suppression Disabled For SF: No PHS\n");\r\nreturn STATUS_SUCCESS;\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint PHSReceive(struct bcm_mini_adapter *Adapter,\r\nUSHORT usVcid,\r\nstruct sk_buff *packet,\r\nUINT *punPacketLen,\r\nUCHAR *pucEthernetHdr,\r\nUINT bHeaderSuppressionEnabled)\r\n{\r\nu32 nStandardPktHdrLen = 0;\r\nu32 nTotalsuppressedPktHdrBytes = 0;\r\nint ulPhsStatus = 0;\r\nPUCHAR pucInBuff = NULL;\r\nUINT TotalBytesAdded = 0;\r\nif (!bHeaderSuppressionEnabled) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_RECEIVE, DBG_LVL_ALL, "\nPhs Disabled for incoming packet");\r\nreturn ulPhsStatus;\r\n}\r\npucInBuff = packet->data;\r\nnStandardPktHdrLen = packet->len;\r\nulPhsStatus = PhsDeCompress(&Adapter->stBCMPhsContext,\r\nusVcid,\r\npucInBuff,\r\nAdapter->ucaPHSPktRestoreBuf,\r\n&nTotalsuppressedPktHdrBytes,\r\n&nStandardPktHdrLen);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_RECEIVE, DBG_LVL_ALL, "\nSuppressed PktHdrLen : 0x%x Restored PktHdrLen : 0x%x",\r\nnTotalsuppressedPktHdrBytes, nStandardPktHdrLen);\r\nif (ulPhsStatus != STATUS_PHS_COMPRESSED) {\r\nskb_pull(packet, 1);\r\nreturn STATUS_SUCCESS;\r\n} else {\r\nTotalBytesAdded = nStandardPktHdrLen - nTotalsuppressedPktHdrBytes - PHSI_LEN;\r\nif (TotalBytesAdded) {\r\nif (skb_headroom(packet) >= (SKB_RESERVE_ETHERNET_HEADER + TotalBytesAdded))\r\nskb_push(packet, TotalBytesAdded);\r\nelse {\r\nif (skb_cow(packet, skb_headroom(packet) + TotalBytesAdded)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "cow failed in receive\n");\r\nreturn STATUS_FAILURE;\r\n}\r\nskb_push(packet, TotalBytesAdded);\r\n}\r\n}\r\nmemcpy(packet->data, Adapter->ucaPHSPktRestoreBuf, nStandardPktHdrLen);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nvoid DumpFullPacket(UCHAR *pBuf, UINT nPktLen)\r\n{\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV4_DBG, DBG_LVL_ALL, "Dumping Data Packet");\r\nBCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_TX, IPV4_DBG, DBG_LVL_ALL, pBuf, nPktLen);\r\n}\r\nint phs_init(struct bcm_phs_extension *pPhsdeviceExtension, struct bcm_mini_adapter *Adapter)\r\n{\r\nint i;\r\nstruct bcm_phs_table *pstServiceFlowTable;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "\nPHS:phs_init function");\r\nif (pPhsdeviceExtension->pstServiceFlowPhsRulesTable)\r\nreturn -EINVAL;\r\npPhsdeviceExtension->pstServiceFlowPhsRulesTable = kzalloc(sizeof(struct bcm_phs_table), GFP_KERNEL);\r\nif (!pPhsdeviceExtension->pstServiceFlowPhsRulesTable) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "\nAllocation ServiceFlowPhsRulesTable failed");\r\nreturn -ENOMEM;\r\n}\r\npstServiceFlowTable = pPhsdeviceExtension->pstServiceFlowPhsRulesTable;\r\nfor (i = 0; i < MAX_SERVICEFLOWS; i++) {\r\nstruct bcm_phs_entry sServiceFlow = pstServiceFlowTable->stSFList[i];\r\nsServiceFlow.pstClassifierTable = kzalloc(sizeof(struct bcm_phs_classifier_table), GFP_KERNEL);\r\nif (!sServiceFlow.pstClassifierTable) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "\nAllocation failed");\r\nfree_phs_serviceflow_rules(pPhsdeviceExtension->pstServiceFlowPhsRulesTable);\r\npPhsdeviceExtension->pstServiceFlowPhsRulesTable = NULL;\r\nreturn -ENOMEM;\r\n}\r\n}\r\npPhsdeviceExtension->CompressedTxBuffer = kmalloc(PHS_BUFFER_SIZE, GFP_KERNEL);\r\nif (pPhsdeviceExtension->CompressedTxBuffer == NULL) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "\nAllocation failed");\r\nfree_phs_serviceflow_rules(pPhsdeviceExtension->pstServiceFlowPhsRulesTable);\r\npPhsdeviceExtension->pstServiceFlowPhsRulesTable = NULL;\r\nreturn -ENOMEM;\r\n}\r\npPhsdeviceExtension->UnCompressedRxBuffer = kmalloc(PHS_BUFFER_SIZE, GFP_KERNEL);\r\nif (pPhsdeviceExtension->UnCompressedRxBuffer == NULL) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "\nAllocation failed");\r\nkfree(pPhsdeviceExtension->CompressedTxBuffer);\r\nfree_phs_serviceflow_rules(pPhsdeviceExtension->pstServiceFlowPhsRulesTable);\r\npPhsdeviceExtension->pstServiceFlowPhsRulesTable = NULL;\r\nreturn -ENOMEM;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "\n phs_init Successful");\r\nreturn STATUS_SUCCESS;\r\n}\r\nint PhsCleanup(IN struct bcm_phs_extension *pPHSDeviceExt)\r\n{\r\nif (pPHSDeviceExt->pstServiceFlowPhsRulesTable) {\r\nfree_phs_serviceflow_rules(pPHSDeviceExt->pstServiceFlowPhsRulesTable);\r\npPHSDeviceExt->pstServiceFlowPhsRulesTable = NULL;\r\n}\r\nkfree(pPHSDeviceExt->CompressedTxBuffer);\r\npPHSDeviceExt->CompressedTxBuffer = NULL;\r\nkfree(pPHSDeviceExt->UnCompressedRxBuffer);\r\npPHSDeviceExt->UnCompressedRxBuffer = NULL;\r\nreturn 0;\r\n}\r\nULONG PhsUpdateClassifierRule(IN void *pvContext,\r\nIN B_UINT16 uiVcid ,\r\nIN B_UINT16 uiClsId ,\r\nIN struct bcm_phs_rule *psPhsRule,\r\nIN B_UINT8 u8AssociatedPHSI)\r\n{\r\nULONG lStatus = 0;\r\nUINT nSFIndex = 0;\r\nstruct bcm_phs_entry *pstServiceFlowEntry = NULL;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nstruct bcm_phs_extension *pDeviceExtension = (struct bcm_phs_extension *)pvContext;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "PHS With Corr2 Changes\n");\r\nif (pDeviceExtension == NULL) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "Invalid Device Extension\n");\r\nreturn ERR_PHS_INVALID_DEVICE_EXETENSION;\r\n}\r\nif (u8AssociatedPHSI == 0)\r\nreturn ERR_PHS_INVALID_PHS_RULE;\r\nnSFIndex = GetServiceFlowEntry(pDeviceExtension->pstServiceFlowPhsRulesTable,\r\nuiVcid, &pstServiceFlowEntry);\r\nif (nSFIndex == PHS_INVALID_TABLE_INDEX) {\r\nlStatus = CreateSFToClassifierRuleMapping(uiVcid, uiClsId,\r\npDeviceExtension->pstServiceFlowPhsRulesTable, psPhsRule, u8AssociatedPHSI);\r\nreturn lStatus;\r\n}\r\nlStatus = CreateClassiferToPHSRuleMapping(uiVcid, uiClsId,\r\npstServiceFlowEntry, psPhsRule, u8AssociatedPHSI);\r\nreturn lStatus;\r\n}\r\nULONG PhsDeletePHSRule(IN void *pvContext, IN B_UINT16 uiVcid, IN B_UINT8 u8PHSI)\r\n{\r\nULONG lStatus = 0;\r\nUINT nSFIndex = 0, nClsidIndex = 0;\r\nstruct bcm_phs_entry *pstServiceFlowEntry = NULL;\r\nstruct bcm_phs_classifier_table *pstClassifierRulesTable = NULL;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nstruct bcm_phs_extension *pDeviceExtension = (struct bcm_phs_extension *)pvContext;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "======>\n");\r\nif (pDeviceExtension) {\r\nnSFIndex = GetServiceFlowEntry(pDeviceExtension->pstServiceFlowPhsRulesTable, uiVcid, &pstServiceFlowEntry);\r\nif (nSFIndex == PHS_INVALID_TABLE_INDEX) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "SFID Match Failed\n");\r\nreturn ERR_SF_MATCH_FAIL;\r\n}\r\npstClassifierRulesTable = pstServiceFlowEntry->pstClassifierTable;\r\nif (pstClassifierRulesTable) {\r\nfor (nClsidIndex = 0; nClsidIndex < MAX_PHSRULE_PER_SF; nClsidIndex++) {\r\nif (pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].bUsed && pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule) {\r\nif (pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule->u8PHSI == u8PHSI) {\r\nif (pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule->u8RefCnt)\r\npstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule->u8RefCnt--;\r\nif (0 == pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule->u8RefCnt)\r\nkfree(pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule);\r\nmemset(&pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex], 0,\r\nsizeof(struct bcm_phs_classifier_entry));\r\n}\r\n}\r\n}\r\n}\r\n}\r\nreturn lStatus;\r\n}\r\nULONG PhsDeleteClassifierRule(IN void *pvContext, IN B_UINT16 uiVcid, IN B_UINT16 uiClsId)\r\n{\r\nULONG lStatus = 0;\r\nUINT nSFIndex = 0, nClsidIndex = 0;\r\nstruct bcm_phs_entry *pstServiceFlowEntry = NULL;\r\nstruct bcm_phs_classifier_entry *pstClassifierEntry = NULL;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nstruct bcm_phs_extension *pDeviceExtension = (struct bcm_phs_extension *)pvContext;\r\nif (pDeviceExtension) {\r\nnSFIndex = GetServiceFlowEntry(pDeviceExtension->pstServiceFlowPhsRulesTable, uiVcid, &pstServiceFlowEntry);\r\nif (nSFIndex == PHS_INVALID_TABLE_INDEX) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "SFID Match Failed\n");\r\nreturn ERR_SF_MATCH_FAIL;\r\n}\r\nnClsidIndex = GetClassifierEntry(pstServiceFlowEntry->pstClassifierTable,\r\nuiClsId, eActiveClassifierRuleContext, &pstClassifierEntry);\r\nif ((nClsidIndex != PHS_INVALID_TABLE_INDEX) && (!pstClassifierEntry->bUnclassifiedPHSRule)) {\r\nif (pstClassifierEntry->pstPhsRule) {\r\nif (pstClassifierEntry->pstPhsRule->u8RefCnt)\r\npstClassifierEntry->pstPhsRule->u8RefCnt--;\r\nif (0 == pstClassifierEntry->pstPhsRule->u8RefCnt)\r\nkfree(pstClassifierEntry->pstPhsRule);\r\n}\r\nmemset(pstClassifierEntry, 0, sizeof(struct bcm_phs_classifier_entry));\r\n}\r\nnClsidIndex = GetClassifierEntry(pstServiceFlowEntry->pstClassifierTable,\r\nuiClsId, eOldClassifierRuleContext, &pstClassifierEntry);\r\nif ((nClsidIndex != PHS_INVALID_TABLE_INDEX) && (!pstClassifierEntry->bUnclassifiedPHSRule)) {\r\nkfree(pstClassifierEntry->pstPhsRule);\r\nmemset(pstClassifierEntry, 0, sizeof(struct bcm_phs_classifier_entry));\r\n}\r\n}\r\nreturn lStatus;\r\n}\r\nULONG PhsDeleteSFRules(IN void *pvContext, IN B_UINT16 uiVcid)\r\n{\r\nULONG lStatus = 0;\r\nUINT nSFIndex = 0, nClsidIndex = 0;\r\nstruct bcm_phs_entry *pstServiceFlowEntry = NULL;\r\nstruct bcm_phs_classifier_table *pstClassifierRulesTable = NULL;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nstruct bcm_phs_extension *pDeviceExtension = (struct bcm_phs_extension *)pvContext;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "====>\n");\r\nif (pDeviceExtension) {\r\nnSFIndex = GetServiceFlowEntry(pDeviceExtension->pstServiceFlowPhsRulesTable,\r\nuiVcid, &pstServiceFlowEntry);\r\nif (nSFIndex == PHS_INVALID_TABLE_INDEX) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "SFID Match Failed\n");\r\nreturn ERR_SF_MATCH_FAIL;\r\n}\r\npstClassifierRulesTable = pstServiceFlowEntry->pstClassifierTable;\r\nif (pstClassifierRulesTable) {\r\nfor (nClsidIndex = 0; nClsidIndex < MAX_PHSRULE_PER_SF; nClsidIndex++) {\r\nif (pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule) {\r\nif (pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule->u8RefCnt)\r\npstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule->u8RefCnt--;\r\nif (0 == pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule->u8RefCnt)\r\nkfree(pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule);\r\npstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule = NULL;\r\n}\r\nmemset(&pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex], 0, sizeof(struct bcm_phs_classifier_entry));\r\nif (pstClassifierRulesTable->stOldPhsRulesList[nClsidIndex].pstPhsRule) {\r\nif (pstClassifierRulesTable->stOldPhsRulesList[nClsidIndex].pstPhsRule->u8RefCnt)\r\npstClassifierRulesTable->stOldPhsRulesList[nClsidIndex].pstPhsRule->u8RefCnt--;\r\nif (0 == pstClassifierRulesTable->stOldPhsRulesList[nClsidIndex].pstPhsRule->u8RefCnt)\r\nkfree(pstClassifierRulesTable->stOldPhsRulesList[nClsidIndex].pstPhsRule);\r\npstClassifierRulesTable->stOldPhsRulesList[nClsidIndex].pstPhsRule = NULL;\r\n}\r\nmemset(&pstClassifierRulesTable->stOldPhsRulesList[nClsidIndex], 0, sizeof(struct bcm_phs_classifier_entry));\r\n}\r\n}\r\npstServiceFlowEntry->bUsed = FALSE;\r\npstServiceFlowEntry->uiVcid = 0;\r\n}\r\nreturn lStatus;\r\n}\r\nULONG PhsCompress(IN void *pvContext,\r\nIN B_UINT16 uiVcid,\r\nIN B_UINT16 uiClsId,\r\nIN void *pvInputBuffer,\r\nOUT void *pvOutputBuffer,\r\nOUT UINT *pOldHeaderSize,\r\nOUT UINT *pNewHeaderSize)\r\n{\r\nUINT nSFIndex = 0, nClsidIndex = 0;\r\nstruct bcm_phs_entry *pstServiceFlowEntry = NULL;\r\nstruct bcm_phs_classifier_entry *pstClassifierEntry = NULL;\r\nstruct bcm_phs_rule *pstPhsRule = NULL;\r\nULONG lStatus = 0;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nstruct bcm_phs_extension *pDeviceExtension = (struct bcm_phs_extension *)pvContext;\r\nif (pDeviceExtension == NULL) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL, "Invalid Device Extension\n");\r\nlStatus = STATUS_PHS_NOCOMPRESSION;\r\nreturn lStatus;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL, "Suppressing header\n");\r\nnSFIndex = GetServiceFlowEntry(pDeviceExtension->pstServiceFlowPhsRulesTable,\r\nuiVcid, &pstServiceFlowEntry);\r\nif (nSFIndex == PHS_INVALID_TABLE_INDEX) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL, "SFID Match Failed\n");\r\nlStatus = STATUS_PHS_NOCOMPRESSION;\r\nreturn lStatus;\r\n}\r\nnClsidIndex = GetClassifierEntry(pstServiceFlowEntry->pstClassifierTable,\r\nuiClsId, eActiveClassifierRuleContext, &pstClassifierEntry);\r\nif (nClsidIndex == PHS_INVALID_TABLE_INDEX) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL, "No PHS Rule Defined For Classifier\n");\r\nlStatus = STATUS_PHS_NOCOMPRESSION;\r\nreturn lStatus;\r\n}\r\npstPhsRule = pstClassifierEntry->pstPhsRule;\r\nif (!ValidatePHSRuleComplete(pstPhsRule)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "PHS Rule Defined For Classifier But Not Complete\n");\r\nlStatus = STATUS_PHS_NOCOMPRESSION;\r\nreturn lStatus;\r\n}\r\nlStatus = phs_compress(pstPhsRule, (PUCHAR)pvInputBuffer,\r\n(PUCHAR)pvOutputBuffer, pOldHeaderSize, pNewHeaderSize);\r\nif (lStatus == STATUS_PHS_COMPRESSED) {\r\npstPhsRule->PHSModifiedBytes += *pOldHeaderSize - *pNewHeaderSize - 1;\r\npstPhsRule->PHSModifiedNumPackets++;\r\n} else\r\npstPhsRule->PHSErrorNumPackets++;\r\nreturn lStatus;\r\n}\r\nULONG PhsDeCompress(IN void *pvContext,\r\nIN B_UINT16 uiVcid,\r\nIN void *pvInputBuffer,\r\nOUT void *pvOutputBuffer,\r\nOUT UINT *pInHeaderSize,\r\nOUT UINT *pOutHeaderSize)\r\n{\r\nUINT nSFIndex = 0, nPhsRuleIndex = 0;\r\nstruct bcm_phs_entry *pstServiceFlowEntry = NULL;\r\nstruct bcm_phs_rule *pstPhsRule = NULL;\r\nUINT phsi;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nstruct bcm_phs_extension *pDeviceExtension = (struct bcm_phs_extension *)pvContext;\r\n*pInHeaderSize = 0;\r\nif (pDeviceExtension == NULL) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_RECEIVE, DBG_LVL_ALL, "Invalid Device Extension\n");\r\nreturn ERR_PHS_INVALID_DEVICE_EXETENSION;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_RECEIVE, DBG_LVL_ALL, "Restoring header\n");\r\nphsi = *((unsigned char *)(pvInputBuffer));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_RECEIVE, DBG_LVL_ALL, "PHSI To Be Used For restore : %x\n", phsi);\r\nif (phsi == UNCOMPRESSED_PACKET)\r\nreturn STATUS_PHS_NOCOMPRESSION;\r\nnSFIndex = GetServiceFlowEntry(pDeviceExtension->pstServiceFlowPhsRulesTable,\r\nuiVcid, &pstServiceFlowEntry);\r\nif (nSFIndex == PHS_INVALID_TABLE_INDEX) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_RECEIVE, DBG_LVL_ALL, "SFID Match Failed During Lookup\n");\r\nreturn ERR_SF_MATCH_FAIL;\r\n}\r\nnPhsRuleIndex = GetPhsRuleEntry(pstServiceFlowEntry->pstClassifierTable, phsi,\r\neActiveClassifierRuleContext, &pstPhsRule);\r\nif (nPhsRuleIndex == PHS_INVALID_TABLE_INDEX) {\r\nnPhsRuleIndex = GetPhsRuleEntry(pstServiceFlowEntry->pstClassifierTable,\r\nphsi, eOldClassifierRuleContext, &pstPhsRule);\r\nif (nPhsRuleIndex == PHS_INVALID_TABLE_INDEX)\r\nreturn ERR_PHSRULE_MATCH_FAIL;\r\n}\r\n*pInHeaderSize = phs_decompress((PUCHAR)pvInputBuffer,\r\n(PUCHAR)pvOutputBuffer, pstPhsRule, pOutHeaderSize);\r\npstPhsRule->PHSModifiedBytes += *pOutHeaderSize - *pInHeaderSize - 1;\r\npstPhsRule->PHSModifiedNumPackets++;\r\nreturn STATUS_PHS_COMPRESSED;\r\n}\r\nstatic void free_phs_serviceflow_rules(struct bcm_phs_table *psServiceFlowRulesTable)\r\n{\r\nint i, j;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "=======>\n");\r\nif (psServiceFlowRulesTable) {\r\nfor (i = 0; i < MAX_SERVICEFLOWS; i++) {\r\nstruct bcm_phs_entry stServiceFlowEntry = psServiceFlowRulesTable->stSFList[i];\r\nstruct bcm_phs_classifier_table *pstClassifierRulesTable = stServiceFlowEntry.pstClassifierTable;\r\nif (pstClassifierRulesTable) {\r\nfor (j = 0; j < MAX_PHSRULE_PER_SF; j++) {\r\nif (pstClassifierRulesTable->stActivePhsRulesList[j].pstPhsRule) {\r\nif (pstClassifierRulesTable->stActivePhsRulesList[j].pstPhsRule->u8RefCnt)\r\npstClassifierRulesTable->stActivePhsRulesList[j].pstPhsRule->u8RefCnt--;\r\nif (0 == pstClassifierRulesTable->stActivePhsRulesList[j].pstPhsRule->u8RefCnt)\r\nkfree(pstClassifierRulesTable->stActivePhsRulesList[j].pstPhsRule);\r\npstClassifierRulesTable->stActivePhsRulesList[j].pstPhsRule = NULL;\r\n}\r\nif (pstClassifierRulesTable->stOldPhsRulesList[j].pstPhsRule) {\r\nif (pstClassifierRulesTable->stOldPhsRulesList[j].pstPhsRule->u8RefCnt)\r\npstClassifierRulesTable->stOldPhsRulesList[j].pstPhsRule->u8RefCnt--;\r\nif (0 == pstClassifierRulesTable->stOldPhsRulesList[j].pstPhsRule->u8RefCnt)\r\nkfree(pstClassifierRulesTable->stOldPhsRulesList[j].pstPhsRule);\r\npstClassifierRulesTable->stOldPhsRulesList[j].pstPhsRule = NULL;\r\n}\r\n}\r\nkfree(pstClassifierRulesTable);\r\nstServiceFlowEntry.pstClassifierTable = pstClassifierRulesTable = NULL;\r\n}\r\n}\r\n}\r\nkfree(psServiceFlowRulesTable);\r\npsServiceFlowRulesTable = NULL;\r\n}\r\nstatic BOOLEAN ValidatePHSRuleComplete(IN struct bcm_phs_rule *psPhsRule)\r\n{\r\nif (psPhsRule) {\r\nif (!psPhsRule->u8PHSI) {\r\nreturn FALSE;\r\n}\r\nif (!psPhsRule->u8PHSS) {\r\nreturn FALSE;\r\n}\r\nif (!psPhsRule->u8PHSFLength)\r\nreturn FALSE;\r\nreturn TRUE;\r\n} else\r\nreturn FALSE;\r\n}\r\nUINT GetServiceFlowEntry(IN struct bcm_phs_table *psServiceFlowTable,\r\nIN B_UINT16 uiVcid,\r\nstruct bcm_phs_entry **ppstServiceFlowEntry)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_SERVICEFLOWS; i++) {\r\nif (psServiceFlowTable->stSFList[i].bUsed) {\r\nif (psServiceFlowTable->stSFList[i].uiVcid == uiVcid) {\r\n*ppstServiceFlowEntry = &psServiceFlowTable->stSFList[i];\r\nreturn i;\r\n}\r\n}\r\n}\r\n*ppstServiceFlowEntry = NULL;\r\nreturn PHS_INVALID_TABLE_INDEX;\r\n}\r\nUINT GetClassifierEntry(IN struct bcm_phs_classifier_table *pstClassifierTable,\r\nIN B_UINT32 uiClsid, enum bcm_phs_classifier_context eClsContext,\r\nOUT struct bcm_phs_classifier_entry **ppstClassifierEntry)\r\n{\r\nint i;\r\nstruct bcm_phs_classifier_entry *psClassifierRules = NULL;\r\nfor (i = 0; i < MAX_PHSRULE_PER_SF; i++) {\r\nif (eClsContext == eActiveClassifierRuleContext)\r\npsClassifierRules = &pstClassifierTable->stActivePhsRulesList[i];\r\nelse\r\npsClassifierRules = &pstClassifierTable->stOldPhsRulesList[i];\r\nif (psClassifierRules->bUsed) {\r\nif (psClassifierRules->uiClassifierRuleId == uiClsid) {\r\n*ppstClassifierEntry = psClassifierRules;\r\nreturn i;\r\n}\r\n}\r\n}\r\n*ppstClassifierEntry = NULL;\r\nreturn PHS_INVALID_TABLE_INDEX;\r\n}\r\nstatic UINT GetPhsRuleEntry(IN struct bcm_phs_classifier_table *pstClassifierTable,\r\nIN B_UINT32 uiPHSI, enum bcm_phs_classifier_context eClsContext,\r\nOUT struct bcm_phs_rule **ppstPhsRule)\r\n{\r\nint i;\r\nstruct bcm_phs_classifier_entry *pstClassifierRule = NULL;\r\nfor (i = 0; i < MAX_PHSRULE_PER_SF; i++) {\r\nif (eClsContext == eActiveClassifierRuleContext)\r\npstClassifierRule = &pstClassifierTable->stActivePhsRulesList[i];\r\nelse\r\npstClassifierRule = &pstClassifierTable->stOldPhsRulesList[i];\r\nif (pstClassifierRule->bUsed) {\r\nif (pstClassifierRule->u8PHSI == uiPHSI) {\r\n*ppstPhsRule = pstClassifierRule->pstPhsRule;\r\nreturn i;\r\n}\r\n}\r\n}\r\n*ppstPhsRule = NULL;\r\nreturn PHS_INVALID_TABLE_INDEX;\r\n}\r\nUINT CreateSFToClassifierRuleMapping(IN B_UINT16 uiVcid, IN B_UINT16 uiClsId,\r\nIN struct bcm_phs_table *psServiceFlowTable,\r\nstruct bcm_phs_rule *psPhsRule,\r\nB_UINT8 u8AssociatedPHSI)\r\n{\r\nstruct bcm_phs_classifier_table *psaClassifiertable = NULL;\r\nUINT uiStatus = 0;\r\nint iSfIndex;\r\nBOOLEAN bFreeEntryFound = FALSE;\r\nfor (iSfIndex = 0; iSfIndex < MAX_SERVICEFLOWS; iSfIndex++) {\r\nif (!psServiceFlowTable->stSFList[iSfIndex].bUsed) {\r\nbFreeEntryFound = TRUE;\r\nbreak;\r\n}\r\n}\r\nif (!bFreeEntryFound)\r\nreturn ERR_SFTABLE_FULL;\r\npsaClassifiertable = psServiceFlowTable->stSFList[iSfIndex].pstClassifierTable;\r\nuiStatus = CreateClassifierPHSRule(uiClsId, psaClassifiertable, psPhsRule,\r\neActiveClassifierRuleContext, u8AssociatedPHSI);\r\nif (uiStatus == PHS_SUCCESS) {\r\npsServiceFlowTable->stSFList[iSfIndex].bUsed = TRUE;\r\npsServiceFlowTable->stSFList[iSfIndex].uiVcid = uiVcid;\r\n}\r\nreturn uiStatus;\r\n}\r\nUINT CreateClassiferToPHSRuleMapping(IN B_UINT16 uiVcid,\r\nIN B_UINT16 uiClsId,\r\nIN struct bcm_phs_entry *pstServiceFlowEntry,\r\nstruct bcm_phs_rule *psPhsRule,\r\nB_UINT8 u8AssociatedPHSI)\r\n{\r\nstruct bcm_phs_classifier_entry *pstClassifierEntry = NULL;\r\nUINT uiStatus = PHS_SUCCESS;\r\nUINT nClassifierIndex = 0;\r\nstruct bcm_phs_classifier_table *psaClassifiertable = NULL;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\npsaClassifiertable = pstServiceFlowEntry->pstClassifierTable;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "==>");\r\nnClassifierIndex = GetClassifierEntry(\r\npstServiceFlowEntry->pstClassifierTable,\r\nuiClsId,\r\neActiveClassifierRuleContext,\r\n&pstClassifierEntry);\r\nif (nClassifierIndex == PHS_INVALID_TABLE_INDEX) {\r\nuiStatus = CreateClassifierPHSRule(uiClsId, psaClassifiertable,\r\npsPhsRule,\r\neActiveClassifierRuleContext,\r\nu8AssociatedPHSI);\r\nreturn uiStatus;\r\n}\r\nif (pstClassifierEntry->u8PHSI == psPhsRule->u8PHSI) {\r\nif (pstClassifierEntry->pstPhsRule == NULL)\r\nreturn ERR_PHS_INVALID_PHS_RULE;\r\nif (psPhsRule->u8PHSFLength) {\r\nmemcpy(pstClassifierEntry->pstPhsRule->u8PHSF,\r\npsPhsRule->u8PHSF, MAX_PHS_LENGTHS);\r\n}\r\nif (psPhsRule->u8PHSFLength) {\r\npstClassifierEntry->pstPhsRule->u8PHSFLength = psPhsRule->u8PHSFLength;\r\n}\r\nif (psPhsRule->u8PHSMLength) {\r\nmemcpy(pstClassifierEntry->pstPhsRule->u8PHSM,\r\npsPhsRule->u8PHSM, MAX_PHS_LENGTHS);\r\n}\r\nif (psPhsRule->u8PHSMLength) {\r\npstClassifierEntry->pstPhsRule->u8PHSMLength =\r\npsPhsRule->u8PHSMLength;\r\n}\r\nif (psPhsRule->u8PHSS) {\r\npstClassifierEntry->pstPhsRule->u8PHSS = psPhsRule->u8PHSS;\r\n}\r\npstClassifierEntry->pstPhsRule->u8PHSV = psPhsRule->u8PHSV;\r\n} else {\r\nuiStatus = UpdateClassifierPHSRule(uiClsId, pstClassifierEntry,\r\npsaClassifiertable, psPhsRule, u8AssociatedPHSI);\r\n}\r\nreturn uiStatus;\r\n}\r\nstatic UINT CreateClassifierPHSRule(IN B_UINT16 uiClsId,\r\nstruct bcm_phs_classifier_table *psaClassifiertable,\r\nstruct bcm_phs_rule *psPhsRule,\r\nenum bcm_phs_classifier_context eClsContext,\r\nB_UINT8 u8AssociatedPHSI)\r\n{\r\nUINT iClassifierIndex = 0;\r\nBOOLEAN bFreeEntryFound = FALSE;\r\nstruct bcm_phs_classifier_entry *psClassifierRules = NULL;\r\nUINT nStatus = PHS_SUCCESS;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "Inside CreateClassifierPHSRule");\r\nif (psaClassifiertable == NULL)\r\nreturn ERR_INVALID_CLASSIFIERTABLE_FOR_SF;\r\nif (eClsContext == eOldClassifierRuleContext) {\r\niClassifierIndex =\r\nGetClassifierEntry(psaClassifiertable, uiClsId,\r\neClsContext, &psClassifierRules);\r\nif (iClassifierIndex != PHS_INVALID_TABLE_INDEX) {\r\nbFreeEntryFound = TRUE;\r\n}\r\n}\r\nif (!bFreeEntryFound) {\r\nfor (iClassifierIndex = 0; iClassifierIndex <\r\nMAX_PHSRULE_PER_SF; iClassifierIndex++) {\r\nif (eClsContext == eActiveClassifierRuleContext)\r\npsClassifierRules = &psaClassifiertable->stActivePhsRulesList[iClassifierIndex];\r\nelse\r\npsClassifierRules = &psaClassifiertable->stOldPhsRulesList[iClassifierIndex];\r\nif (!psClassifierRules->bUsed) {\r\nbFreeEntryFound = TRUE;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!bFreeEntryFound) {\r\nif (eClsContext == eActiveClassifierRuleContext)\r\nreturn ERR_CLSASSIFIER_TABLE_FULL;\r\nelse {\r\nif (psaClassifiertable->uiOldestPhsRuleIndex >= MAX_PHSRULE_PER_SF)\r\npsaClassifiertable->uiOldestPhsRuleIndex = 0;\r\niClassifierIndex = psaClassifiertable->uiOldestPhsRuleIndex;\r\npsClassifierRules = &psaClassifiertable->stOldPhsRulesList[iClassifierIndex];\r\n(psaClassifiertable->uiOldestPhsRuleIndex)++;\r\n}\r\n}\r\nif (eClsContext == eOldClassifierRuleContext) {\r\nif (psClassifierRules->pstPhsRule == NULL) {\r\npsClassifierRules->pstPhsRule = kmalloc(sizeof(struct bcm_phs_rule), GFP_KERNEL);\r\nif (NULL == psClassifierRules->pstPhsRule)\r\nreturn ERR_PHSRULE_MEMALLOC_FAIL;\r\n}\r\npsClassifierRules->bUsed = TRUE;\r\npsClassifierRules->uiClassifierRuleId = uiClsId;\r\npsClassifierRules->u8PHSI = psPhsRule->u8PHSI;\r\npsClassifierRules->bUnclassifiedPHSRule = psPhsRule->bUnclassifiedPHSRule;\r\nmemcpy(psClassifierRules->pstPhsRule, psPhsRule, sizeof(struct bcm_phs_rule));\r\n} else\r\nnStatus = UpdateClassifierPHSRule(uiClsId, psClassifierRules,\r\npsaClassifiertable, psPhsRule, u8AssociatedPHSI);\r\nreturn nStatus;\r\n}\r\nstatic UINT UpdateClassifierPHSRule(IN B_UINT16 uiClsId,\r\nIN struct bcm_phs_classifier_entry *pstClassifierEntry,\r\nstruct bcm_phs_classifier_table *psaClassifiertable,\r\nstruct bcm_phs_rule *psPhsRule,\r\nB_UINT8 u8AssociatedPHSI)\r\n{\r\nstruct bcm_phs_rule *pstAddPhsRule = NULL;\r\nUINT nPhsRuleIndex = 0;\r\nBOOLEAN bPHSRuleOrphaned = FALSE;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\npsPhsRule->u8RefCnt = 0;\r\nbPHSRuleOrphaned = DerefPhsRule(uiClsId, psaClassifiertable,\r\npstClassifierEntry->pstPhsRule);\r\nnPhsRuleIndex = GetPhsRuleEntry(psaClassifiertable, u8AssociatedPHSI,\r\neActiveClassifierRuleContext, &pstAddPhsRule);\r\nif (PHS_INVALID_TABLE_INDEX == nPhsRuleIndex) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "\nAdding New PHSRuleEntry For Classifier");\r\nif (psPhsRule->u8PHSI == 0) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "\nError PHSI is Zero\n");\r\nreturn ERR_PHS_INVALID_PHS_RULE;\r\n}\r\nif (FALSE == bPHSRuleOrphaned) {\r\npstClassifierEntry->pstPhsRule = kmalloc(sizeof(struct bcm_phs_rule), GFP_KERNEL);\r\nif (NULL == pstClassifierEntry->pstPhsRule)\r\nreturn ERR_PHSRULE_MEMALLOC_FAIL;\r\n}\r\nmemcpy(pstClassifierEntry->pstPhsRule, psPhsRule, sizeof(struct bcm_phs_rule));\r\n} else {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "\nTying Classifier to Existing PHS Rule");\r\nif (bPHSRuleOrphaned) {\r\nkfree(pstClassifierEntry->pstPhsRule);\r\npstClassifierEntry->pstPhsRule = NULL;\r\n}\r\npstClassifierEntry->pstPhsRule = pstAddPhsRule;\r\n}\r\npstClassifierEntry->bUsed = TRUE;\r\npstClassifierEntry->u8PHSI = pstClassifierEntry->pstPhsRule->u8PHSI;\r\npstClassifierEntry->uiClassifierRuleId = uiClsId;\r\npstClassifierEntry->pstPhsRule->u8RefCnt++;\r\npstClassifierEntry->bUnclassifiedPHSRule = pstClassifierEntry->pstPhsRule->bUnclassifiedPHSRule;\r\nreturn PHS_SUCCESS;\r\n}\r\nstatic BOOLEAN DerefPhsRule(IN B_UINT16 uiClsId, struct bcm_phs_classifier_table *psaClassifiertable, struct bcm_phs_rule *pstPhsRule)\r\n{\r\nif (pstPhsRule == NULL)\r\nreturn FALSE;\r\nif (pstPhsRule->u8RefCnt)\r\npstPhsRule->u8RefCnt--;\r\nif (0 == pstPhsRule->u8RefCnt) {\r\nreturn TRUE;\r\n} else\r\nreturn FALSE;\r\n}\r\nvoid DumpPhsRules(struct bcm_phs_extension *pDeviceExtension)\r\n{\r\nint i, j, k, l;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_INFO, DBG_LVL_ALL, "\n Dumping PHS Rules :\n");\r\nfor (i = 0; i < MAX_SERVICEFLOWS; i++) {\r\nstruct bcm_phs_entry stServFlowEntry =\r\npDeviceExtension->pstServiceFlowPhsRulesTable->stSFList[i];\r\nif (stServFlowEntry.bUsed) {\r\nfor (j = 0; j < MAX_PHSRULE_PER_SF; j++) {\r\nfor (l = 0; l < 2; l++) {\r\nstruct bcm_phs_classifier_entry stClsEntry;\r\nif (l == 0) {\r\nstClsEntry = stServFlowEntry.pstClassifierTable->stActivePhsRulesList[j];\r\nif (stClsEntry.bUsed)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n Active PHS Rule :\n");\r\n} else {\r\nstClsEntry = stServFlowEntry.pstClassifierTable->stOldPhsRulesList[j];\r\nif (stClsEntry.bUsed)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n Old PHS Rule :\n");\r\n}\r\nif (stClsEntry.bUsed) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_INFO, DBG_LVL_ALL, "\n VCID : %#X", stServFlowEntry.uiVcid);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n ClassifierID : %#X", stClsEntry.uiClassifierRuleId);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSRuleID : %#X", stClsEntry.u8PHSI);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n****************PHS Rule********************\n");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSI : %#X", stClsEntry.pstPhsRule->u8PHSI);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSFLength : %#X ", stClsEntry.pstPhsRule->u8PHSFLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSF : ");\r\nfor (k = 0 ; k < stClsEntry.pstPhsRule->u8PHSFLength; k++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "%#X ", stClsEntry.pstPhsRule->u8PHSF[k]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSMLength : %#X", stClsEntry.pstPhsRule->u8PHSMLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSM :");\r\nfor (k = 0; k < stClsEntry.pstPhsRule->u8PHSMLength; k++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "%#X ", stClsEntry.pstPhsRule->u8PHSM[k]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSS : %#X ", stClsEntry.pstPhsRule->u8PHSS);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSV : %#X", stClsEntry.pstPhsRule->u8PHSV);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_INFO, DBG_LVL_ALL, "\n********************************************\n");\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nint phs_decompress(unsigned char *in_buf,\r\nunsigned char *out_buf,\r\nstruct bcm_phs_rule *decomp_phs_rules,\r\nUINT *header_size)\r\n{\r\nint phss, size = 0;\r\nstruct bcm_phs_rule *tmp_memb;\r\nint bit, i = 0;\r\nunsigned char *phsf, *phsm;\r\nint in_buf_len = *header_size - 1;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nin_buf++;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_RECEIVE, DBG_LVL_ALL, "====>\n");\r\n*header_size = 0;\r\nif ((decomp_phs_rules == NULL))\r\nreturn 0;\r\ntmp_memb = decomp_phs_rules;\r\nphss = tmp_memb->u8PHSS;\r\nphsf = tmp_memb->u8PHSF;\r\nphsm = tmp_memb->u8PHSM;\r\nif (phss > MAX_PHS_LENGTHS)\r\nphss = MAX_PHS_LENGTHS;\r\nwhile ((phss > 0) && (size < in_buf_len)) {\r\nbit = ((*phsm << i) & SUPPRESS);\r\nif (bit == SUPPRESS) {\r\n*out_buf = *phsf;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_RECEIVE, DBG_LVL_ALL, "\nDECOMP:In phss %d phsf %d ouput %d",\r\nphss, *phsf, *out_buf);\r\n} else {\r\n*out_buf = *in_buf;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_RECEIVE, DBG_LVL_ALL, "\nDECOMP:In phss %d input %d ouput %d",\r\nphss, *in_buf, *out_buf);\r\nin_buf++;\r\nsize++;\r\n}\r\nout_buf++;\r\nphsf++;\r\nphss--;\r\ni++;\r\n*header_size = *header_size + 1;\r\nif (i > MAX_NO_BIT) {\r\ni = 0;\r\nphsm++;\r\n}\r\n}\r\nreturn size;\r\n}\r\nstatic int phs_compress(struct bcm_phs_rule *phs_rule,\r\nunsigned char *in_buf,\r\nunsigned char *out_buf,\r\nUINT *header_size,\r\nUINT *new_header_size)\r\n{\r\nunsigned char *old_addr = out_buf;\r\nint suppress = 0;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nif (phs_rule == NULL) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL, "\nphs_compress(): phs_rule null!");\r\n*out_buf = ZERO_PHSI;\r\nreturn STATUS_PHS_NOCOMPRESSION;\r\n}\r\nif (phs_rule->u8PHSS <= *new_header_size)\r\n*header_size = phs_rule->u8PHSS;\r\nelse\r\n*header_size = *new_header_size;\r\nout_buf++;\r\nsuppress = verify_suppress_phsf(in_buf, out_buf, phs_rule->u8PHSF,\r\nphs_rule->u8PHSM, phs_rule->u8PHSS,\r\nphs_rule->u8PHSV, new_header_size);\r\nif (suppress == STATUS_PHS_COMPRESSED) {\r\n*old_addr = (unsigned char)phs_rule->u8PHSI;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL, "\nCOMP:In phs_compress phsi %d", phs_rule->u8PHSI);\r\n} else {\r\n*old_addr = ZERO_PHSI;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL, "\nCOMP:In phs_compress PHSV Verification failed");\r\n}\r\nreturn suppress;\r\n}\r\nstatic int verify_suppress_phsf(unsigned char *in_buffer,\r\nunsigned char *out_buffer,\r\nunsigned char *phsf,\r\nunsigned char *phsm,\r\nunsigned int phss,\r\nunsigned int phsv,\r\nUINT *new_header_size)\r\n{\r\nunsigned int size = 0;\r\nint bit, i = 0;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL, "\nCOMP:In verify_phsf PHSM - 0x%X", *phsm);\r\nif (phss > (*new_header_size))\r\nphss = *new_header_size;\r\nwhile (phss > 0) {\r\nbit = ((*phsm << i) & SUPPRESS);\r\nif (bit == SUPPRESS) {\r\nif (*in_buffer != *phsf) {\r\nif (phsv == VERIFY) {\r\nBCM_DEBUG_PRINT(Adapter,\r\nDBG_TYPE_OTHERS,\r\nPHS_SEND,\r\nDBG_LVL_ALL,\r\n"\nCOMP:In verify_phsf failed for field %d buf %d phsf %d",\r\nphss,\r\n*in_buffer,\r\n*phsf);\r\nreturn STATUS_PHS_NOCOMPRESSION;\r\n}\r\n} else\r\nBCM_DEBUG_PRINT(Adapter,\r\nDBG_TYPE_OTHERS,\r\nPHS_SEND,\r\nDBG_LVL_ALL,\r\n"\nCOMP:In verify_phsf success for field %d buf %d phsf %d",\r\nphss,\r\n*in_buffer,\r\n*phsf);\r\n} else {\r\n*out_buffer = *in_buffer;\r\nBCM_DEBUG_PRINT(Adapter,\r\nDBG_TYPE_OTHERS,\r\nPHS_SEND,\r\nDBG_LVL_ALL,\r\n"\nCOMP:In copying_header input %d out %d",\r\n*in_buffer,\r\n*out_buffer);\r\nout_buffer++;\r\nsize++;\r\n}\r\nin_buffer++;\r\nphsf++;\r\nphss--;\r\ni++;\r\nif (i > MAX_NO_BIT) {\r\ni = 0;\r\nphsm++;\r\n}\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL, "\nCOMP:In verify_phsf success");\r\n*new_header_size = size;\r\nreturn STATUS_PHS_COMPRESSED;\r\n}
