static int fb_try_mode(struct fb_var_screeninfo *var, struct fb_info *info,\r\nconst struct fb_videomode *mode, unsigned int bpp)\r\n{\r\nint err = 0;\r\nDPRINTK("Trying mode %s %dx%d-%d@%d\n",\r\nmode->name ? mode->name : "noname",\r\nmode->xres, mode->yres, bpp, mode->refresh);\r\nvar->xres = mode->xres;\r\nvar->yres = mode->yres;\r\nvar->xres_virtual = mode->xres;\r\nvar->yres_virtual = mode->yres;\r\nvar->xoffset = 0;\r\nvar->yoffset = 0;\r\nvar->bits_per_pixel = bpp;\r\nvar->activate |= FB_ACTIVATE_TEST;\r\nvar->pixclock = mode->pixclock;\r\nvar->left_margin = mode->left_margin;\r\nvar->right_margin = mode->right_margin;\r\nvar->upper_margin = mode->upper_margin;\r\nvar->lower_margin = mode->lower_margin;\r\nvar->hsync_len = mode->hsync_len;\r\nvar->vsync_len = mode->vsync_len;\r\nvar->sync = mode->sync;\r\nvar->vmode = mode->vmode;\r\nif (info->fbops->fb_check_var)\r\nerr = info->fbops->fb_check_var(var, info);\r\nvar->activate &= ~FB_ACTIVATE_TEST;\r\nreturn err;\r\n}\r\nint fb_find_mode(struct fb_var_screeninfo *var,\r\nstruct fb_info *info, const char *mode_option,\r\nconst struct fb_videomode *db, unsigned int dbsize,\r\nconst struct fb_videomode *default_mode,\r\nunsigned int default_bpp)\r\n{\r\nint i;\r\nif (!db) {\r\ndb = modedb;\r\ndbsize = ARRAY_SIZE(modedb);\r\n}\r\nif (!default_mode)\r\ndefault_mode = &db[0];\r\nif (!default_bpp)\r\ndefault_bpp = 8;\r\nif (!mode_option)\r\nmode_option = fb_mode_option;\r\nif (mode_option) {\r\nconst char *name = mode_option;\r\nunsigned int namelen = strlen(name);\r\nint res_specified = 0, bpp_specified = 0, refresh_specified = 0;\r\nunsigned int xres = 0, yres = 0, bpp = default_bpp, refresh = 0;\r\nint yres_specified = 0, cvt = 0, rb = 0, interlace = 0;\r\nint margins = 0;\r\nu32 best, diff, tdiff;\r\nfor (i = namelen-1; i >= 0; i--) {\r\nswitch (name[i]) {\r\ncase '@':\r\nnamelen = i;\r\nif (!refresh_specified && !bpp_specified &&\r\n!yres_specified) {\r\nrefresh = simple_strtol(&name[i+1], NULL,\r\n10);\r\nrefresh_specified = 1;\r\nif (cvt || rb)\r\ncvt = 0;\r\n} else\r\ngoto done;\r\nbreak;\r\ncase '-':\r\nnamelen = i;\r\nif (!bpp_specified && !yres_specified) {\r\nbpp = simple_strtol(&name[i+1], NULL,\r\n10);\r\nbpp_specified = 1;\r\nif (cvt || rb)\r\ncvt = 0;\r\n} else\r\ngoto done;\r\nbreak;\r\ncase 'x':\r\nif (!yres_specified) {\r\nyres = simple_strtol(&name[i+1], NULL,\r\n10);\r\nyres_specified = 1;\r\n} else\r\ngoto done;\r\nbreak;\r\ncase '0' ... '9':\r\nbreak;\r\ncase 'M':\r\nif (!yres_specified)\r\ncvt = 1;\r\nbreak;\r\ncase 'R':\r\nif (!cvt)\r\nrb = 1;\r\nbreak;\r\ncase 'm':\r\nif (!cvt)\r\nmargins = 1;\r\nbreak;\r\ncase 'i':\r\nif (!cvt)\r\ninterlace = 1;\r\nbreak;\r\ndefault:\r\ngoto done;\r\n}\r\n}\r\nif (i < 0 && yres_specified) {\r\nxres = simple_strtol(name, NULL, 10);\r\nres_specified = 1;\r\n}\r\ndone:\r\nif (cvt) {\r\nstruct fb_videomode cvt_mode;\r\nint ret;\r\nDPRINTK("CVT mode %dx%d@%dHz%s%s%s\n", xres, yres,\r\n(refresh) ? refresh : 60,\r\n(rb) ? " reduced blanking" : "",\r\n(margins) ? " with margins" : "",\r\n(interlace) ? " interlaced" : "");\r\nmemset(&cvt_mode, 0, sizeof(cvt_mode));\r\ncvt_mode.xres = xres;\r\ncvt_mode.yres = yres;\r\ncvt_mode.refresh = (refresh) ? refresh : 60;\r\nif (interlace)\r\ncvt_mode.vmode |= FB_VMODE_INTERLACED;\r\nelse\r\ncvt_mode.vmode &= ~FB_VMODE_INTERLACED;\r\nret = fb_find_mode_cvt(&cvt_mode, margins, rb);\r\nif (!ret && !fb_try_mode(var, info, &cvt_mode, bpp)) {\r\nDPRINTK("modedb CVT: CVT mode ok\n");\r\nreturn 1;\r\n}\r\nDPRINTK("CVT mode invalid, getting mode from database\n");\r\n}\r\nDPRINTK("Trying specified video mode%s %ix%i\n",\r\nrefresh_specified ? "" : " (ignoring refresh rate)",\r\nxres, yres);\r\nif (!refresh_specified) {\r\nif (db != modedb &&\r\ninfo->monspecs.vfmin && info->monspecs.vfmax &&\r\ninfo->monspecs.hfmin && info->monspecs.hfmax &&\r\ninfo->monspecs.dclkmax) {\r\nrefresh = 1000;\r\n} else {\r\nrefresh = 60;\r\n}\r\n}\r\ndiff = -1;\r\nbest = -1;\r\nfor (i = 0; i < dbsize; i++) {\r\nif ((name_matches(db[i], name, namelen) ||\r\n(res_specified && res_matches(db[i], xres, yres))) &&\r\n!fb_try_mode(var, info, &db[i], bpp)) {\r\nif (refresh_specified && db[i].refresh == refresh)\r\nreturn 1;\r\nif (abs(db[i].refresh - refresh) < diff) {\r\ndiff = abs(db[i].refresh - refresh);\r\nbest = i;\r\n}\r\n}\r\n}\r\nif (best != -1) {\r\nfb_try_mode(var, info, &db[best], bpp);\r\nreturn (refresh_specified) ? 2 : 1;\r\n}\r\ndiff = 2 * (xres + yres);\r\nbest = -1;\r\nDPRINTK("Trying best-fit modes\n");\r\nfor (i = 0; i < dbsize; i++) {\r\nDPRINTK("Trying %ix%i\n", db[i].xres, db[i].yres);\r\nif (!fb_try_mode(var, info, &db[i], bpp)) {\r\ntdiff = abs(db[i].xres - xres) +\r\nabs(db[i].yres - yres);\r\nif (xres > db[i].xres || yres > db[i].yres)\r\ntdiff += xres + yres;\r\nif (diff > tdiff) {\r\ndiff = tdiff;\r\nbest = i;\r\n}\r\n}\r\n}\r\nif (best != -1) {\r\nfb_try_mode(var, info, &db[best], bpp);\r\nreturn 5;\r\n}\r\n}\r\nDPRINTK("Trying default video mode\n");\r\nif (!fb_try_mode(var, info, default_mode, default_bpp))\r\nreturn 3;\r\nDPRINTK("Trying all modes\n");\r\nfor (i = 0; i < dbsize; i++)\r\nif (!fb_try_mode(var, info, &db[i], default_bpp))\r\nreturn 4;\r\nDPRINTK("No valid mode found\n");\r\nreturn 0;\r\n}\r\nvoid fb_var_to_videomode(struct fb_videomode *mode,\r\nconst struct fb_var_screeninfo *var)\r\n{\r\nu32 pixclock, hfreq, htotal, vtotal;\r\nmode->name = NULL;\r\nmode->xres = var->xres;\r\nmode->yres = var->yres;\r\nmode->pixclock = var->pixclock;\r\nmode->hsync_len = var->hsync_len;\r\nmode->vsync_len = var->vsync_len;\r\nmode->left_margin = var->left_margin;\r\nmode->right_margin = var->right_margin;\r\nmode->upper_margin = var->upper_margin;\r\nmode->lower_margin = var->lower_margin;\r\nmode->sync = var->sync;\r\nmode->vmode = var->vmode & FB_VMODE_MASK;\r\nmode->flag = FB_MODE_IS_FROM_VAR;\r\nmode->refresh = 0;\r\nif (!var->pixclock)\r\nreturn;\r\npixclock = PICOS2KHZ(var->pixclock) * 1000;\r\nhtotal = var->xres + var->right_margin + var->hsync_len +\r\nvar->left_margin;\r\nvtotal = var->yres + var->lower_margin + var->vsync_len +\r\nvar->upper_margin;\r\nif (var->vmode & FB_VMODE_INTERLACED)\r\nvtotal /= 2;\r\nif (var->vmode & FB_VMODE_DOUBLE)\r\nvtotal *= 2;\r\nhfreq = pixclock/htotal;\r\nmode->refresh = hfreq/vtotal;\r\n}\r\nvoid fb_videomode_to_var(struct fb_var_screeninfo *var,\r\nconst struct fb_videomode *mode)\r\n{\r\nvar->xres = mode->xres;\r\nvar->yres = mode->yres;\r\nvar->xres_virtual = mode->xres;\r\nvar->yres_virtual = mode->yres;\r\nvar->xoffset = 0;\r\nvar->yoffset = 0;\r\nvar->pixclock = mode->pixclock;\r\nvar->left_margin = mode->left_margin;\r\nvar->right_margin = mode->right_margin;\r\nvar->upper_margin = mode->upper_margin;\r\nvar->lower_margin = mode->lower_margin;\r\nvar->hsync_len = mode->hsync_len;\r\nvar->vsync_len = mode->vsync_len;\r\nvar->sync = mode->sync;\r\nvar->vmode = mode->vmode & FB_VMODE_MASK;\r\n}\r\nint fb_mode_is_equal(const struct fb_videomode *mode1,\r\nconst struct fb_videomode *mode2)\r\n{\r\nreturn (mode1->xres == mode2->xres &&\r\nmode1->yres == mode2->yres &&\r\nmode1->pixclock == mode2->pixclock &&\r\nmode1->hsync_len == mode2->hsync_len &&\r\nmode1->vsync_len == mode2->vsync_len &&\r\nmode1->left_margin == mode2->left_margin &&\r\nmode1->right_margin == mode2->right_margin &&\r\nmode1->upper_margin == mode2->upper_margin &&\r\nmode1->lower_margin == mode2->lower_margin &&\r\nmode1->sync == mode2->sync &&\r\nmode1->vmode == mode2->vmode);\r\n}\r\nconst struct fb_videomode *fb_find_best_mode(const struct fb_var_screeninfo *var,\r\nstruct list_head *head)\r\n{\r\nstruct list_head *pos;\r\nstruct fb_modelist *modelist;\r\nstruct fb_videomode *mode, *best = NULL;\r\nu32 diff = -1;\r\nlist_for_each(pos, head) {\r\nu32 d;\r\nmodelist = list_entry(pos, struct fb_modelist, list);\r\nmode = &modelist->mode;\r\nif (mode->xres >= var->xres && mode->yres >= var->yres) {\r\nd = (mode->xres - var->xres) +\r\n(mode->yres - var->yres);\r\nif (diff > d) {\r\ndiff = d;\r\nbest = mode;\r\n} else if (diff == d && best &&\r\nmode->refresh > best->refresh)\r\nbest = mode;\r\n}\r\n}\r\nreturn best;\r\n}\r\nconst struct fb_videomode *fb_find_nearest_mode(const struct fb_videomode *mode,\r\nstruct list_head *head)\r\n{\r\nstruct list_head *pos;\r\nstruct fb_modelist *modelist;\r\nstruct fb_videomode *cmode, *best = NULL;\r\nu32 diff = -1, diff_refresh = -1;\r\nlist_for_each(pos, head) {\r\nu32 d;\r\nmodelist = list_entry(pos, struct fb_modelist, list);\r\ncmode = &modelist->mode;\r\nd = abs(cmode->xres - mode->xres) +\r\nabs(cmode->yres - mode->yres);\r\nif (diff > d) {\r\ndiff = d;\r\ndiff_refresh = abs(cmode->refresh - mode->refresh);\r\nbest = cmode;\r\n} else if (diff == d) {\r\nd = abs(cmode->refresh - mode->refresh);\r\nif (diff_refresh > d) {\r\ndiff_refresh = d;\r\nbest = cmode;\r\n}\r\n}\r\n}\r\nreturn best;\r\n}\r\nconst struct fb_videomode *fb_match_mode(const struct fb_var_screeninfo *var,\r\nstruct list_head *head)\r\n{\r\nstruct list_head *pos;\r\nstruct fb_modelist *modelist;\r\nstruct fb_videomode *m, mode;\r\nfb_var_to_videomode(&mode, var);\r\nlist_for_each(pos, head) {\r\nmodelist = list_entry(pos, struct fb_modelist, list);\r\nm = &modelist->mode;\r\nif (fb_mode_is_equal(m, &mode))\r\nreturn m;\r\n}\r\nreturn NULL;\r\n}\r\nint fb_add_videomode(const struct fb_videomode *mode, struct list_head *head)\r\n{\r\nstruct list_head *pos;\r\nstruct fb_modelist *modelist;\r\nstruct fb_videomode *m;\r\nint found = 0;\r\nlist_for_each(pos, head) {\r\nmodelist = list_entry(pos, struct fb_modelist, list);\r\nm = &modelist->mode;\r\nif (fb_mode_is_equal(m, mode)) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nmodelist = kmalloc(sizeof(struct fb_modelist),\r\nGFP_KERNEL);\r\nif (!modelist)\r\nreturn -ENOMEM;\r\nmodelist->mode = *mode;\r\nlist_add(&modelist->list, head);\r\n}\r\nreturn 0;\r\n}\r\nvoid fb_delete_videomode(const struct fb_videomode *mode,\r\nstruct list_head *head)\r\n{\r\nstruct list_head *pos, *n;\r\nstruct fb_modelist *modelist;\r\nstruct fb_videomode *m;\r\nlist_for_each_safe(pos, n, head) {\r\nmodelist = list_entry(pos, struct fb_modelist, list);\r\nm = &modelist->mode;\r\nif (fb_mode_is_equal(m, mode)) {\r\nlist_del(pos);\r\nkfree(pos);\r\n}\r\n}\r\n}\r\nvoid fb_destroy_modelist(struct list_head *head)\r\n{\r\nstruct list_head *pos, *n;\r\nlist_for_each_safe(pos, n, head) {\r\nlist_del(pos);\r\nkfree(pos);\r\n}\r\n}\r\nvoid fb_videomode_to_modelist(const struct fb_videomode *modedb, int num,\r\nstruct list_head *head)\r\n{\r\nint i;\r\nINIT_LIST_HEAD(head);\r\nfor (i = 0; i < num; i++) {\r\nif (fb_add_videomode(&modedb[i], head))\r\nreturn;\r\n}\r\n}\r\nconst struct fb_videomode *fb_find_best_display(const struct fb_monspecs *specs,\r\nstruct list_head *head)\r\n{\r\nstruct list_head *pos;\r\nstruct fb_modelist *modelist;\r\nconst struct fb_videomode *m, *m1 = NULL, *md = NULL, *best = NULL;\r\nint first = 0;\r\nif (!head->prev || !head->next || list_empty(head))\r\ngoto finished;\r\nlist_for_each(pos, head) {\r\nmodelist = list_entry(pos, struct fb_modelist, list);\r\nm = &modelist->mode;\r\nif (!first) {\r\nm1 = m;\r\nfirst = 1;\r\n}\r\nif (m->flag & FB_MODE_IS_FIRST) {\r\nmd = m;\r\nbreak;\r\n}\r\n}\r\nif (specs->misc & FB_MISC_1ST_DETAIL) {\r\nbest = md;\r\ngoto finished;\r\n}\r\nif (specs->max_x && specs->max_y) {\r\nstruct fb_var_screeninfo var;\r\nmemset(&var, 0, sizeof(struct fb_var_screeninfo));\r\nvar.xres = (specs->max_x * 7200)/254;\r\nvar.yres = (specs->max_y * 7200)/254;\r\nm = fb_find_best_mode(&var, head);\r\nif (m) {\r\nbest = m;\r\ngoto finished;\r\n}\r\n}\r\nif (md) {\r\nbest = md;\r\ngoto finished;\r\n}\r\nbest = m1;\r\nfinished:\r\nreturn best;\r\n}
