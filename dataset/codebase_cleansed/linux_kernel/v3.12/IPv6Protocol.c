static UCHAR *GetNextIPV6ChainedHeader(UCHAR **ppucPayload,\r\nUCHAR *pucNextHeader, BOOLEAN *bParseDone, USHORT *pusPayloadLength)\r\n{\r\nUCHAR *pucRetHeaderPtr = NULL;\r\nUCHAR *pucPayloadPtr = NULL;\r\nUSHORT usNextHeaderOffset = 0 ;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nif ((ppucPayload == NULL) || (*pusPayloadLength == 0) ||\r\n(*bParseDone)) {\r\n*bParseDone = TRUE;\r\nreturn NULL;\r\n}\r\npucRetHeaderPtr = *ppucPayload;\r\npucPayloadPtr = *ppucPayload;\r\nif (!pucRetHeaderPtr || !pucPayloadPtr) {\r\n*bParseDone = TRUE;\r\nreturn NULL;\r\n}\r\n*bParseDone = FALSE;\r\nswitch (*pucNextHeader) {\r\ncase IPV6HDR_TYPE_HOPBYHOP:\r\n{\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG,\r\nDBG_LVL_ALL, "\nIPv6 HopByHop Header");\r\nusNextHeaderOffset += sizeof(struct bcm_ipv6_options_hdr);\r\n}\r\nbreak;\r\ncase IPV6HDR_TYPE_ROUTING:\r\n{\r\nstruct bcm_ipv6_routing_hdr *pstIpv6RoutingHeader;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG,\r\nDBG_LVL_ALL, "\nIPv6 Routing Header");\r\npstIpv6RoutingHeader = (struct bcm_ipv6_routing_hdr *)pucPayloadPtr;\r\nusNextHeaderOffset += sizeof(struct bcm_ipv6_routing_hdr);\r\nusNextHeaderOffset += pstIpv6RoutingHeader->ucNumAddresses * IPV6_ADDRESS_SIZEINBYTES;\r\n}\r\nbreak;\r\ncase IPV6HDR_TYPE_FRAGMENTATION:\r\n{\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG,\r\nDBG_LVL_ALL,\r\n"\nIPv6 Fragmentation Header");\r\nusNextHeaderOffset += sizeof(struct bcm_ipv6_fragment_hdr);\r\n}\r\nbreak;\r\ncase IPV6HDR_TYPE_DESTOPTS:\r\n{\r\nstruct bcm_ipv6_dest_options_hdr *pstIpv6DestOptsHdr = (struct bcm_ipv6_dest_options_hdr *)pucPayloadPtr;\r\nint nTotalOptions = pstIpv6DestOptsHdr->ucHdrExtLen;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG,\r\nDBG_LVL_ALL,\r\n"\nIPv6 DestOpts Header Header");\r\nusNextHeaderOffset += sizeof(struct bcm_ipv6_dest_options_hdr);\r\nusNextHeaderOffset += nTotalOptions * IPV6_DESTOPTS_HDR_OPTIONSIZE ;\r\n}\r\nbreak;\r\ncase IPV6HDR_TYPE_AUTHENTICATION:\r\n{\r\nstruct bcm_ipv6_authentication_hdr *pstIpv6AuthHdr = (struct bcm_ipv6_authentication_hdr *)pucPayloadPtr;\r\nint nHdrLen = pstIpv6AuthHdr->ucLength;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG,\r\nDBG_LVL_ALL,\r\n"\nIPv6 Authentication Header");\r\nusNextHeaderOffset += nHdrLen * 4;\r\n}\r\nbreak;\r\ncase IPV6HDR_TYPE_ENCRYPTEDSECURITYPAYLOAD:\r\n{\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG,\r\nDBG_LVL_ALL,\r\n"\nIPv6 Encrypted Security Payload Header");\r\n*bParseDone = TRUE;\r\n}\r\nbreak;\r\ncase IPV6_ICMP_HDR_TYPE:\r\n{\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG,\r\nDBG_LVL_ALL, "\nICMP Header");\r\n*bParseDone = TRUE;\r\n}\r\nbreak;\r\ncase TCP_HEADER_TYPE:\r\n{\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG,\r\nDBG_LVL_ALL, "\nTCP Header");\r\n*bParseDone = TRUE;\r\n}\r\nbreak;\r\ncase UDP_HEADER_TYPE:\r\n{\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG,\r\nDBG_LVL_ALL, "\nUDP Header");\r\n*bParseDone = TRUE;\r\n}\r\nbreak;\r\ndefault:\r\n{\r\n*bParseDone = TRUE;\r\n}\r\nbreak;\r\n}\r\nif (*bParseDone == FALSE) {\r\nif (*pusPayloadLength <= usNextHeaderOffset) {\r\n*bParseDone = TRUE;\r\n} else {\r\n*pucNextHeader = *pucPayloadPtr;\r\npucPayloadPtr += usNextHeaderOffset;\r\n(*pusPayloadLength) -= usNextHeaderOffset;\r\n}\r\n}\r\n*ppucPayload = pucPayloadPtr;\r\nreturn pucRetHeaderPtr;\r\n}\r\nstatic UCHAR GetIpv6ProtocolPorts(UCHAR *pucPayload, USHORT *pusSrcPort,\r\nUSHORT *pusDestPort, USHORT usPayloadLength, UCHAR ucNextHeader)\r\n{\r\nUCHAR *pIpv6HdrScanContext = pucPayload;\r\nBOOLEAN bDone = FALSE;\r\nUCHAR ucHeaderType = 0;\r\nUCHAR *pucNextHeader = NULL;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nif (!pucPayload || (usPayloadLength == 0))\r\nreturn 0;\r\n*pusSrcPort = *pusDestPort = 0;\r\nucHeaderType = ucNextHeader;\r\nwhile (!bDone) {\r\npucNextHeader = GetNextIPV6ChainedHeader(&pIpv6HdrScanContext,\r\n&ucHeaderType, &bDone, &usPayloadLength);\r\nif (bDone) {\r\nif ((ucHeaderType == TCP_HEADER_TYPE) ||\r\n(ucHeaderType == UDP_HEADER_TYPE)) {\r\n*pusSrcPort = *((PUSHORT)(pucNextHeader));\r\n*pusDestPort = *((PUSHORT)(pucNextHeader+2));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG,\r\nDBG_LVL_ALL,\r\n"\nProtocol Ports - Src Port :0x%x Dest Port : 0x%x",\r\nntohs(*pusSrcPort),\r\nntohs(*pusDestPort));\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn ucHeaderType;\r\n}\r\nUSHORT IpVersion6(struct bcm_mini_adapter *Adapter, PVOID pcIpHeader,\r\nstruct bcm_classifier_rule *pstClassifierRule)\r\n{\r\nUSHORT ushDestPort = 0;\r\nUSHORT ushSrcPort = 0;\r\nUCHAR ucNextProtocolAboveIP = 0;\r\nstruct bcm_ipv6_hdr *pstIpv6Header = NULL;\r\nBOOLEAN bClassificationSucceed = FALSE;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG,\r\nDBG_LVL_ALL, "IpVersion6 ==========>\n");\r\npstIpv6Header = (struct bcm_ipv6_hdr *)pcIpHeader;\r\nDumpIpv6Header(pstIpv6Header);\r\nucNextProtocolAboveIP = GetIpv6ProtocolPorts((UCHAR *)(pcIpHeader + sizeof(struct bcm_ipv6_hdr)),\r\n&ushSrcPort,\r\n&ushDestPort,\r\npstIpv6Header->usPayloadLength,\r\npstIpv6Header->ucNextHeader);\r\ndo {\r\nif (pstClassifierRule->ucDirection == 0) {\r\nbreak;\r\n}\r\nif (!pstClassifierRule->bIpv6Protocol) {\r\nbreak;\r\n}\r\nbClassificationSucceed = MatchSrcIpv6Address(pstClassifierRule,\r\npstIpv6Header);\r\nif (!bClassificationSucceed)\r\nbreak;\r\nbClassificationSucceed = MatchDestIpv6Address(pstClassifierRule,\r\npstIpv6Header);\r\nif (!bClassificationSucceed)\r\nbreak;\r\nbClassificationSucceed = MatchProtocol(pstClassifierRule,\r\nucNextProtocolAboveIP);\r\nif (!bClassificationSucceed)\r\nbreak;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG,\r\nDBG_LVL_ALL, "\nIPv6 Protocol Matched");\r\nif ((ucNextProtocolAboveIP == TCP_HEADER_TYPE) ||\r\n(ucNextProtocolAboveIP == UDP_HEADER_TYPE)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG,\r\nDBG_LVL_ALL, "\nIPv6 Source Port:%x\n",\r\nntohs(ushSrcPort));\r\nbClassificationSucceed = MatchSrcPort(pstClassifierRule,\r\nntohs(ushSrcPort));\r\nif (!bClassificationSucceed)\r\nbreak;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG,\r\nDBG_LVL_ALL, "\nIPv6 Src Port Matched");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG,\r\nDBG_LVL_ALL, "\nIPv6 Destination Port:%x\n",\r\nntohs(ushDestPort));\r\nbClassificationSucceed = MatchDestPort(pstClassifierRule,\r\nntohs(ushDestPort));\r\nif (!bClassificationSucceed)\r\nbreak;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG,\r\nDBG_LVL_ALL, "\nIPv6 Dest Port Matched");\r\n}\r\n} while (0);\r\nif (bClassificationSucceed == TRUE) {\r\nINT iMatchedSFQueueIndex = 0;\r\niMatchedSFQueueIndex = SearchSfid(Adapter, pstClassifierRule->ulSFID);\r\nif (iMatchedSFQueueIndex >= NO_OF_QUEUES) {\r\nbClassificationSucceed = FALSE;\r\n} else {\r\nif (Adapter->PackInfo[iMatchedSFQueueIndex].bActive == FALSE)\r\nbClassificationSucceed = FALSE;\r\n}\r\n}\r\nreturn bClassificationSucceed;\r\n}\r\nstatic BOOLEAN MatchSrcIpv6Address(struct bcm_classifier_rule *pstClassifierRule,\r\nstruct bcm_ipv6_hdr *pstIpv6Header)\r\n{\r\nUINT uiLoopIndex = 0;\r\nUINT uiIpv6AddIndex = 0;\r\nUINT uiIpv6AddrNoLongWords = 4;\r\nULONG aulSrcIP[4];\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nUINT uiCountIPSrcAddresses = (UINT)pstClassifierRule->ucIPSourceAddressLength;\r\nif (uiCountIPSrcAddresses == 0)\r\nreturn TRUE;\r\nfor (uiIpv6AddIndex = 0; uiIpv6AddIndex < uiIpv6AddrNoLongWords; uiIpv6AddIndex++)\r\naulSrcIP[uiIpv6AddIndex] = ntohl(pstIpv6Header->ulSrcIpAddress[uiIpv6AddIndex]);\r\nfor (uiLoopIndex = 0; uiLoopIndex < uiCountIPSrcAddresses; uiLoopIndex += uiIpv6AddrNoLongWords) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL,\r\n"\n Src Ipv6 Address In Received Packet :\n ");\r\nDumpIpv6Address(aulSrcIP);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL,\r\n"\n Src Ipv6 Mask In Classifier Rule:\n");\r\nDumpIpv6Address(&pstClassifierRule->stSrcIpAddress.ulIpv6Mask[uiLoopIndex]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL,\r\n"\n Src Ipv6 Address In Classifier Rule :\n");\r\nDumpIpv6Address(&pstClassifierRule->stSrcIpAddress.ulIpv6Addr[uiLoopIndex]);\r\nfor (uiIpv6AddIndex = 0; uiIpv6AddIndex < uiIpv6AddrNoLongWords; uiIpv6AddIndex++) {\r\nif ((pstClassifierRule->stSrcIpAddress.ulIpv6Mask[uiLoopIndex+uiIpv6AddIndex] & aulSrcIP[uiIpv6AddIndex])\r\n!= pstClassifierRule->stSrcIpAddress.ulIpv6Addr[uiLoopIndex+uiIpv6AddIndex]) {\r\nbreak;\r\n}\r\nif (uiIpv6AddIndex == uiIpv6AddrNoLongWords-1) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG,\r\nDBG_LVL_ALL,\r\n"Ipv6 Src Ip Address Matched\n");\r\nreturn TRUE;\r\n}\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nstatic BOOLEAN MatchDestIpv6Address(struct bcm_classifier_rule *pstClassifierRule,\r\nstruct bcm_ipv6_hdr *pstIpv6Header)\r\n{\r\nUINT uiLoopIndex = 0;\r\nUINT uiIpv6AddIndex = 0;\r\nUINT uiIpv6AddrNoLongWords = 4;\r\nULONG aulDestIP[4];\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nUINT uiCountIPDestinationAddresses = (UINT)pstClassifierRule->ucIPDestinationAddressLength;\r\nif (uiCountIPDestinationAddresses == 0)\r\nreturn TRUE;\r\nfor (uiIpv6AddIndex = 0; uiIpv6AddIndex < uiIpv6AddrNoLongWords; uiIpv6AddIndex++)\r\naulDestIP[uiIpv6AddIndex] = ntohl(pstIpv6Header->ulDestIpAddress[uiIpv6AddIndex]);\r\nfor (uiLoopIndex = 0; uiLoopIndex < uiCountIPDestinationAddresses; uiLoopIndex += uiIpv6AddrNoLongWords) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL,\r\n"\n Destination Ipv6 Address In Received Packet :\n ");\r\nDumpIpv6Address(aulDestIP);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL,\r\n"\n Destination Ipv6 Mask In Classifier Rule :\n");\r\nDumpIpv6Address(&pstClassifierRule->stDestIpAddress.ulIpv6Mask[uiLoopIndex]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL,\r\n"\n Destination Ipv6 Address In Classifier Rule :\n");\r\nDumpIpv6Address(&pstClassifierRule->stDestIpAddress.ulIpv6Addr[uiLoopIndex]);\r\nfor (uiIpv6AddIndex = 0; uiIpv6AddIndex < uiIpv6AddrNoLongWords; uiIpv6AddIndex++) {\r\nif ((pstClassifierRule->stDestIpAddress.ulIpv6Mask[uiLoopIndex+uiIpv6AddIndex] & aulDestIP[uiIpv6AddIndex])\r\n!= pstClassifierRule->stDestIpAddress.ulIpv6Addr[uiLoopIndex+uiIpv6AddIndex]) {\r\nbreak;\r\n}\r\nif (uiIpv6AddIndex == uiIpv6AddrNoLongWords-1) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG,\r\nDBG_LVL_ALL,\r\n"Ipv6 Destination Ip Address Matched\n");\r\nreturn TRUE;\r\n}\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nVOID DumpIpv6Address(ULONG *puIpv6Address)\r\n{\r\nUINT uiIpv6AddrNoLongWords = 4;\r\nUINT uiIpv6AddIndex = 0;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nfor (uiIpv6AddIndex = 0; uiIpv6AddIndex < uiIpv6AddrNoLongWords; uiIpv6AddIndex++) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL,\r\n":%lx", puIpv6Address[uiIpv6AddIndex]);\r\n}\r\n}\r\nstatic VOID DumpIpv6Header(struct bcm_ipv6_hdr *pstIpv6Header)\r\n{\r\nUCHAR ucVersion;\r\nUCHAR ucPrio;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL,\r\n"----Ipv6 Header---");\r\nucVersion = pstIpv6Header->ucVersionPrio & 0xf0;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL,\r\n"Version : %x\n", ucVersion);\r\nucPrio = pstIpv6Header->ucVersionPrio & 0x0f;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL,\r\n"Priority : %x\n", ucPrio);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL,\r\n"Payload Length : %x\n",\r\nntohs(pstIpv6Header->usPayloadLength));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL,\r\n"Next Header : %x\n", pstIpv6Header->ucNextHeader);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL,\r\n"Hop Limit : %x\n", pstIpv6Header->ucHopLimit);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL,\r\n"Src Address :\n");\r\nDumpIpv6Address(pstIpv6Header->ulSrcIpAddress);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL,\r\n"Dest Address :\n");\r\nDumpIpv6Address(pstIpv6Header->ulDestIpAddress);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL,\r\n"----Ipv6 Header End---");\r\n}
