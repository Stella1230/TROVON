static void spdif_out_configure(struct spdif_out_dev *host)\r\n{\r\nwritel(SPDIF_OUT_RESET, host->io_base + SPDIF_OUT_SOFT_RST);\r\nmdelay(1);\r\nwritel(readl(host->io_base + SPDIF_OUT_SOFT_RST) & ~SPDIF_OUT_RESET,\r\nhost->io_base + SPDIF_OUT_SOFT_RST);\r\nwritel(SPDIF_OUT_FDMA_TRIG_16 | SPDIF_OUT_MEMFMT_16_16 |\r\nSPDIF_OUT_VALID_HW | SPDIF_OUT_USER_HW |\r\nSPDIF_OUT_CHNLSTA_HW | SPDIF_OUT_PARITY_HW,\r\nhost->io_base + SPDIF_OUT_CFG);\r\nwritel(0x7F, host->io_base + SPDIF_OUT_INT_STA_CLR);\r\nwritel(0x7F, host->io_base + SPDIF_OUT_INT_EN_CLR);\r\n}\r\nstatic int spdif_out_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct spdif_out_dev *host = snd_soc_dai_get_drvdata(cpu_dai);\r\nint ret;\r\nif (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)\r\nreturn -EINVAL;\r\nret = clk_enable(host->clk);\r\nif (ret)\r\nreturn ret;\r\nhost->running = true;\r\nspdif_out_configure(host);\r\nreturn 0;\r\n}\r\nstatic void spdif_out_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct spdif_out_dev *host = snd_soc_dai_get_drvdata(dai);\r\nif (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)\r\nreturn;\r\nclk_disable(host->clk);\r\nhost->running = false;\r\n}\r\nstatic void spdif_out_clock(struct spdif_out_dev *host, u32 core_freq,\r\nu32 rate)\r\n{\r\nu32 divider, ctrl;\r\nclk_set_rate(host->clk, core_freq);\r\ndivider = DIV_ROUND_CLOSEST(clk_get_rate(host->clk), (rate * 128));\r\nctrl = readl(host->io_base + SPDIF_OUT_CTRL);\r\nctrl &= ~SPDIF_DIVIDER_MASK;\r\nctrl |= (divider << SPDIF_DIVIDER_SHIFT) & SPDIF_DIVIDER_MASK;\r\nwritel(ctrl, host->io_base + SPDIF_OUT_CTRL);\r\n}\r\nstatic int spdif_out_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct spdif_out_dev *host = snd_soc_dai_get_drvdata(dai);\r\nu32 rate, core_freq;\r\nif (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)\r\nreturn -EINVAL;\r\nrate = params_rate(params);\r\nswitch (rate) {\r\ncase 8000:\r\ncase 16000:\r\ncase 32000:\r\ncase 64000:\r\ncore_freq = 64000 * 128 * 10;\r\nbreak;\r\ncase 5512:\r\ncase 11025:\r\ncase 22050:\r\ncase 44100:\r\ncase 88200:\r\ncase 176400:\r\ncore_freq = 176400 * 128;\r\nbreak;\r\ncase 48000:\r\ncase 96000:\r\ncase 192000:\r\ndefault:\r\ncore_freq = 192000 * 128;\r\nbreak;\r\n}\r\nspdif_out_clock(host, core_freq, rate);\r\nhost->saved_params.core_freq = core_freq;\r\nhost->saved_params.rate = rate;\r\nreturn 0;\r\n}\r\nstatic int spdif_out_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct spdif_out_dev *host = snd_soc_dai_get_drvdata(dai);\r\nu32 ctrl;\r\nint ret = 0;\r\nif (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nctrl = readl(host->io_base + SPDIF_OUT_CTRL);\r\nctrl &= ~SPDIF_OPMODE_MASK;\r\nif (!host->saved_params.mute)\r\nctrl |= SPDIF_OPMODE_AUD_DATA |\r\nSPDIF_STATE_NORMAL;\r\nelse\r\nctrl |= SPDIF_OPMODE_MUTE_PCM;\r\nwritel(ctrl, host->io_base + SPDIF_OUT_CTRL);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nctrl = readl(host->io_base + SPDIF_OUT_CTRL);\r\nctrl &= ~SPDIF_OPMODE_MASK;\r\nctrl |= SPDIF_OPMODE_OFF;\r\nwritel(ctrl, host->io_base + SPDIF_OUT_CTRL);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int spdif_digital_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct spdif_out_dev *host = snd_soc_dai_get_drvdata(dai);\r\nu32 val;\r\nhost->saved_params.mute = mute;\r\nval = readl(host->io_base + SPDIF_OUT_CTRL);\r\nval &= ~SPDIF_OPMODE_MASK;\r\nif (mute)\r\nval |= SPDIF_OPMODE_MUTE_PCM;\r\nelse {\r\nif (host->running)\r\nval |= SPDIF_OPMODE_AUD_DATA | SPDIF_STATE_NORMAL;\r\nelse\r\nval |= SPDIF_OPMODE_OFF;\r\n}\r\nwritel(val, host->io_base + SPDIF_OUT_CTRL);\r\nreturn 0;\r\n}\r\nstatic int spdif_mute_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct snd_soc_card *card = codec->card;\r\nstruct snd_soc_pcm_runtime *rtd = card->rtd;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct spdif_out_dev *host = snd_soc_dai_get_drvdata(cpu_dai);\r\nucontrol->value.integer.value[0] = host->saved_params.mute;\r\nreturn 0;\r\n}\r\nstatic int spdif_mute_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct snd_soc_card *card = codec->card;\r\nstruct snd_soc_pcm_runtime *rtd = card->rtd;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct spdif_out_dev *host = snd_soc_dai_get_drvdata(cpu_dai);\r\nif (host->saved_params.mute == ucontrol->value.integer.value[0])\r\nreturn 0;\r\nspdif_digital_mute(cpu_dai, ucontrol->value.integer.value[0]);\r\nreturn 1;\r\n}\r\nstatic int spdif_soc_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct spdif_out_dev *host = snd_soc_dai_get_drvdata(dai);\r\ndai->playback_dma_data = &host->dma_params;\r\nreturn snd_soc_add_dai_controls(dai, spdif_out_controls,\r\nARRAY_SIZE(spdif_out_controls));\r\n}\r\nstatic int spdif_out_probe(struct platform_device *pdev)\r\n{\r\nstruct spdif_out_dev *host;\r\nstruct spear_spdif_platform_data *pdata;\r\nstruct resource *res;\r\nint ret;\r\nhost = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);\r\nif (!host) {\r\ndev_warn(&pdev->dev, "kzalloc fail\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhost->io_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(host->io_base))\r\nreturn PTR_ERR(host->io_base);\r\nhost->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(host->clk))\r\nreturn PTR_ERR(host->clk);\r\npdata = dev_get_platdata(&pdev->dev);\r\nhost->dma_params.data = pdata->dma_params;\r\nhost->dma_params.addr = res->start + SPDIF_OUT_FIFO_DATA;\r\nhost->dma_params.max_burst = 16;\r\nhost->dma_params.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nhost->dma_params.filter = pdata->filter;\r\ndev_set_drvdata(&pdev->dev, host);\r\nret = snd_soc_register_component(&pdev->dev, &spdif_out_component,\r\n&spdif_out_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int spdif_out_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_component(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int spdif_out_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct spdif_out_dev *host = dev_get_drvdata(&pdev->dev);\r\nif (host->running)\r\nclk_disable(host->clk);\r\nreturn 0;\r\n}\r\nstatic int spdif_out_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct spdif_out_dev *host = dev_get_drvdata(&pdev->dev);\r\nif (host->running) {\r\nclk_enable(host->clk);\r\nspdif_out_configure(host);\r\nspdif_out_clock(host, host->saved_params.core_freq,\r\nhost->saved_params.rate);\r\n}\r\nreturn 0;\r\n}
