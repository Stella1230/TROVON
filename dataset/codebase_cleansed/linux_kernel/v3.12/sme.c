static void cfg80211_sme_free(struct wireless_dev *wdev)\r\n{\r\nif (!wdev->conn)\r\nreturn;\r\nkfree(wdev->conn->ie);\r\nkfree(wdev->conn);\r\nwdev->conn = NULL;\r\n}\r\nstatic int cfg80211_conn_scan(struct wireless_dev *wdev)\r\n{\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nstruct cfg80211_scan_request *request;\r\nint n_channels, err;\r\nASSERT_RTNL();\r\nASSERT_RDEV_LOCK(rdev);\r\nASSERT_WDEV_LOCK(wdev);\r\nif (rdev->scan_req)\r\nreturn -EBUSY;\r\nif (wdev->conn->params.channel) {\r\nn_channels = 1;\r\n} else {\r\nenum ieee80211_band band;\r\nn_channels = 0;\r\nfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\r\nif (!wdev->wiphy->bands[band])\r\ncontinue;\r\nn_channels += wdev->wiphy->bands[band]->n_channels;\r\n}\r\n}\r\nrequest = kzalloc(sizeof(*request) + sizeof(request->ssids[0]) +\r\nsizeof(request->channels[0]) * n_channels,\r\nGFP_KERNEL);\r\nif (!request)\r\nreturn -ENOMEM;\r\nif (wdev->conn->params.channel)\r\nrequest->channels[0] = wdev->conn->params.channel;\r\nelse {\r\nint i = 0, j;\r\nenum ieee80211_band band;\r\nstruct ieee80211_supported_band *bands;\r\nstruct ieee80211_channel *channel;\r\nfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\r\nbands = wdev->wiphy->bands[band];\r\nif (!bands)\r\ncontinue;\r\nfor (j = 0; j < bands->n_channels; j++) {\r\nchannel = &bands->channels[j];\r\nif (channel->flags & IEEE80211_CHAN_DISABLED)\r\ncontinue;\r\nrequest->channels[i++] = channel;\r\n}\r\nrequest->rates[band] = (1 << bands->n_bitrates) - 1;\r\n}\r\nn_channels = i;\r\n}\r\nrequest->n_channels = n_channels;\r\nrequest->ssids = (void *)&request->channels[n_channels];\r\nrequest->n_ssids = 1;\r\nmemcpy(request->ssids[0].ssid, wdev->conn->params.ssid,\r\nwdev->conn->params.ssid_len);\r\nrequest->ssids[0].ssid_len = wdev->conn->params.ssid_len;\r\nrequest->wdev = wdev;\r\nrequest->wiphy = &rdev->wiphy;\r\nrequest->scan_start = jiffies;\r\nrdev->scan_req = request;\r\nerr = rdev_scan(rdev, request);\r\nif (!err) {\r\nwdev->conn->state = CFG80211_CONN_SCANNING;\r\nnl80211_send_scan_start(rdev, wdev);\r\ndev_hold(wdev->netdev);\r\n} else {\r\nrdev->scan_req = NULL;\r\nkfree(request);\r\n}\r\nreturn err;\r\n}\r\nstatic int cfg80211_conn_do_work(struct wireless_dev *wdev)\r\n{\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nstruct cfg80211_connect_params *params;\r\nstruct cfg80211_assoc_request req = {};\r\nint err;\r\nASSERT_WDEV_LOCK(wdev);\r\nif (!wdev->conn)\r\nreturn 0;\r\nparams = &wdev->conn->params;\r\nswitch (wdev->conn->state) {\r\ncase CFG80211_CONN_SCANNING:\r\nreturn -ENOENT;\r\ncase CFG80211_CONN_SCAN_AGAIN:\r\nreturn cfg80211_conn_scan(wdev);\r\ncase CFG80211_CONN_AUTHENTICATE_NEXT:\r\nBUG_ON(!rdev->ops->auth);\r\nwdev->conn->state = CFG80211_CONN_AUTHENTICATING;\r\nreturn cfg80211_mlme_auth(rdev, wdev->netdev,\r\nparams->channel, params->auth_type,\r\nparams->bssid,\r\nparams->ssid, params->ssid_len,\r\nNULL, 0,\r\nparams->key, params->key_len,\r\nparams->key_idx, NULL, 0);\r\ncase CFG80211_CONN_AUTH_FAILED:\r\nreturn -ENOTCONN;\r\ncase CFG80211_CONN_ASSOCIATE_NEXT:\r\nBUG_ON(!rdev->ops->assoc);\r\nwdev->conn->state = CFG80211_CONN_ASSOCIATING;\r\nif (wdev->conn->prev_bssid_valid)\r\nreq.prev_bssid = wdev->conn->prev_bssid;\r\nreq.ie = params->ie;\r\nreq.ie_len = params->ie_len;\r\nreq.use_mfp = params->mfp != NL80211_MFP_NO;\r\nreq.crypto = params->crypto;\r\nreq.flags = params->flags;\r\nreq.ht_capa = params->ht_capa;\r\nreq.ht_capa_mask = params->ht_capa_mask;\r\nreq.vht_capa = params->vht_capa;\r\nreq.vht_capa_mask = params->vht_capa_mask;\r\nerr = cfg80211_mlme_assoc(rdev, wdev->netdev, params->channel,\r\nparams->bssid, params->ssid,\r\nparams->ssid_len, &req);\r\nif (err)\r\ncfg80211_mlme_deauth(rdev, wdev->netdev, params->bssid,\r\nNULL, 0,\r\nWLAN_REASON_DEAUTH_LEAVING,\r\nfalse);\r\nreturn err;\r\ncase CFG80211_CONN_ASSOC_FAILED:\r\ncfg80211_mlme_deauth(rdev, wdev->netdev, params->bssid,\r\nNULL, 0,\r\nWLAN_REASON_DEAUTH_LEAVING, false);\r\nreturn -ENOTCONN;\r\ncase CFG80211_CONN_DEAUTH:\r\ncfg80211_mlme_deauth(rdev, wdev->netdev, params->bssid,\r\nNULL, 0,\r\nWLAN_REASON_DEAUTH_LEAVING, false);\r\ncfg80211_sme_free(wdev);\r\nreturn 0;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nvoid cfg80211_conn_work(struct work_struct *work)\r\n{\r\nstruct cfg80211_registered_device *rdev =\r\ncontainer_of(work, struct cfg80211_registered_device, conn_work);\r\nstruct wireless_dev *wdev;\r\nu8 bssid_buf[ETH_ALEN], *bssid = NULL;\r\nrtnl_lock();\r\nlist_for_each_entry(wdev, &rdev->wdev_list, list) {\r\nif (!wdev->netdev)\r\ncontinue;\r\nwdev_lock(wdev);\r\nif (!netif_running(wdev->netdev)) {\r\nwdev_unlock(wdev);\r\ncontinue;\r\n}\r\nif (!wdev->conn ||\r\nwdev->conn->state == CFG80211_CONN_CONNECTED) {\r\nwdev_unlock(wdev);\r\ncontinue;\r\n}\r\nif (wdev->conn->params.bssid) {\r\nmemcpy(bssid_buf, wdev->conn->params.bssid, ETH_ALEN);\r\nbssid = bssid_buf;\r\n}\r\nif (cfg80211_conn_do_work(wdev)) {\r\n__cfg80211_connect_result(\r\nwdev->netdev, bssid,\r\nNULL, 0, NULL, 0,\r\nWLAN_STATUS_UNSPECIFIED_FAILURE,\r\nfalse, NULL);\r\ncfg80211_sme_free(wdev);\r\n}\r\nwdev_unlock(wdev);\r\n}\r\nrtnl_unlock();\r\n}\r\nstatic struct cfg80211_bss *cfg80211_get_conn_bss(struct wireless_dev *wdev)\r\n{\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nstruct cfg80211_bss *bss;\r\nu16 capa = WLAN_CAPABILITY_ESS;\r\nASSERT_WDEV_LOCK(wdev);\r\nif (wdev->conn->params.privacy)\r\ncapa |= WLAN_CAPABILITY_PRIVACY;\r\nbss = cfg80211_get_bss(wdev->wiphy, wdev->conn->params.channel,\r\nwdev->conn->params.bssid,\r\nwdev->conn->params.ssid,\r\nwdev->conn->params.ssid_len,\r\nWLAN_CAPABILITY_ESS | WLAN_CAPABILITY_PRIVACY,\r\ncapa);\r\nif (!bss)\r\nreturn NULL;\r\nmemcpy(wdev->conn->bssid, bss->bssid, ETH_ALEN);\r\nwdev->conn->params.bssid = wdev->conn->bssid;\r\nwdev->conn->params.channel = bss->channel;\r\nwdev->conn->state = CFG80211_CONN_AUTHENTICATE_NEXT;\r\nschedule_work(&rdev->conn_work);\r\nreturn bss;\r\n}\r\nstatic void __cfg80211_sme_scan_done(struct net_device *dev)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nstruct cfg80211_bss *bss;\r\nASSERT_WDEV_LOCK(wdev);\r\nif (!wdev->conn)\r\nreturn;\r\nif (wdev->conn->state != CFG80211_CONN_SCANNING &&\r\nwdev->conn->state != CFG80211_CONN_SCAN_AGAIN)\r\nreturn;\r\nbss = cfg80211_get_conn_bss(wdev);\r\nif (bss)\r\ncfg80211_put_bss(&rdev->wiphy, bss);\r\nelse\r\nschedule_work(&rdev->conn_work);\r\n}\r\nvoid cfg80211_sme_scan_done(struct net_device *dev)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nwdev_lock(wdev);\r\n__cfg80211_sme_scan_done(dev);\r\nwdev_unlock(wdev);\r\n}\r\nvoid cfg80211_sme_rx_auth(struct wireless_dev *wdev, const u8 *buf, size_t len)\r\n{\r\nstruct wiphy *wiphy = wdev->wiphy;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);\r\nstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buf;\r\nu16 status_code = le16_to_cpu(mgmt->u.auth.status_code);\r\nASSERT_WDEV_LOCK(wdev);\r\nif (!wdev->conn || wdev->conn->state == CFG80211_CONN_CONNECTED)\r\nreturn;\r\nif (status_code == WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG &&\r\nwdev->conn->auto_auth &&\r\nwdev->conn->params.auth_type != NL80211_AUTHTYPE_NETWORK_EAP) {\r\nswitch (wdev->conn->params.auth_type) {\r\ncase NL80211_AUTHTYPE_OPEN_SYSTEM:\r\nif (wdev->connect_keys)\r\nwdev->conn->params.auth_type =\r\nNL80211_AUTHTYPE_SHARED_KEY;\r\nelse\r\nwdev->conn->params.auth_type =\r\nNL80211_AUTHTYPE_NETWORK_EAP;\r\nbreak;\r\ncase NL80211_AUTHTYPE_SHARED_KEY:\r\nwdev->conn->params.auth_type =\r\nNL80211_AUTHTYPE_NETWORK_EAP;\r\nbreak;\r\ndefault:\r\nwdev->conn->params.auth_type =\r\nNL80211_AUTHTYPE_OPEN_SYSTEM;\r\nbreak;\r\n}\r\nwdev->conn->state = CFG80211_CONN_AUTHENTICATE_NEXT;\r\nschedule_work(&rdev->conn_work);\r\n} else if (status_code != WLAN_STATUS_SUCCESS) {\r\n__cfg80211_connect_result(wdev->netdev, mgmt->bssid,\r\nNULL, 0, NULL, 0,\r\nstatus_code, false, NULL);\r\n} else if (wdev->conn->state == CFG80211_CONN_AUTHENTICATING) {\r\nwdev->conn->state = CFG80211_CONN_ASSOCIATE_NEXT;\r\nschedule_work(&rdev->conn_work);\r\n}\r\n}\r\nbool cfg80211_sme_rx_assoc_resp(struct wireless_dev *wdev, u16 status)\r\n{\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nif (!wdev->conn)\r\nreturn false;\r\nif (status == WLAN_STATUS_SUCCESS) {\r\nwdev->conn->state = CFG80211_CONN_CONNECTED;\r\nreturn false;\r\n}\r\nif (wdev->conn->prev_bssid_valid) {\r\nwdev->conn->prev_bssid_valid = false;\r\nwdev->conn->state = CFG80211_CONN_ASSOCIATE_NEXT;\r\nschedule_work(&rdev->conn_work);\r\nreturn true;\r\n}\r\nwdev->conn->state = CFG80211_CONN_ASSOC_FAILED;\r\nschedule_work(&rdev->conn_work);\r\nreturn false;\r\n}\r\nvoid cfg80211_sme_deauth(struct wireless_dev *wdev)\r\n{\r\ncfg80211_sme_free(wdev);\r\n}\r\nvoid cfg80211_sme_auth_timeout(struct wireless_dev *wdev)\r\n{\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nif (!wdev->conn)\r\nreturn;\r\nwdev->conn->state = CFG80211_CONN_AUTH_FAILED;\r\nschedule_work(&rdev->conn_work);\r\n}\r\nvoid cfg80211_sme_disassoc(struct wireless_dev *wdev)\r\n{\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nif (!wdev->conn)\r\nreturn;\r\nwdev->conn->state = CFG80211_CONN_DEAUTH;\r\nschedule_work(&rdev->conn_work);\r\n}\r\nvoid cfg80211_sme_assoc_timeout(struct wireless_dev *wdev)\r\n{\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nif (!wdev->conn)\r\nreturn;\r\nwdev->conn->state = CFG80211_CONN_ASSOC_FAILED;\r\nschedule_work(&rdev->conn_work);\r\n}\r\nstatic int cfg80211_sme_connect(struct wireless_dev *wdev,\r\nstruct cfg80211_connect_params *connect,\r\nconst u8 *prev_bssid)\r\n{\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nstruct cfg80211_bss *bss;\r\nint err;\r\nif (!rdev->ops->auth || !rdev->ops->assoc)\r\nreturn -EOPNOTSUPP;\r\nif (wdev->current_bss)\r\nreturn -EALREADY;\r\nif (WARN_ON(wdev->conn))\r\nreturn -EINPROGRESS;\r\nwdev->conn = kzalloc(sizeof(*wdev->conn), GFP_KERNEL);\r\nif (!wdev->conn)\r\nreturn -ENOMEM;\r\nmemcpy(&wdev->conn->params, connect, sizeof(*connect));\r\nif (connect->bssid) {\r\nwdev->conn->params.bssid = wdev->conn->bssid;\r\nmemcpy(wdev->conn->bssid, connect->bssid, ETH_ALEN);\r\n}\r\nif (connect->ie) {\r\nwdev->conn->ie = kmemdup(connect->ie, connect->ie_len,\r\nGFP_KERNEL);\r\nwdev->conn->params.ie = wdev->conn->ie;\r\nif (!wdev->conn->ie) {\r\nkfree(wdev->conn);\r\nwdev->conn = NULL;\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (connect->auth_type == NL80211_AUTHTYPE_AUTOMATIC) {\r\nwdev->conn->auto_auth = true;\r\nwdev->conn->params.auth_type =\r\nNL80211_AUTHTYPE_OPEN_SYSTEM;\r\n} else {\r\nwdev->conn->auto_auth = false;\r\n}\r\nwdev->conn->params.ssid = wdev->ssid;\r\nwdev->conn->params.ssid_len = connect->ssid_len;\r\nbss = cfg80211_get_conn_bss(wdev);\r\nif (prev_bssid) {\r\nmemcpy(wdev->conn->prev_bssid, prev_bssid, ETH_ALEN);\r\nwdev->conn->prev_bssid_valid = true;\r\n}\r\nif (bss) {\r\nwdev->conn->state = CFG80211_CONN_AUTHENTICATE_NEXT;\r\nerr = cfg80211_conn_do_work(wdev);\r\ncfg80211_put_bss(wdev->wiphy, bss);\r\n} else {\r\nerr = cfg80211_conn_scan(wdev);\r\nif (err == -EBUSY) {\r\nerr = 0;\r\nwdev->conn->state = CFG80211_CONN_SCAN_AGAIN;\r\n}\r\n}\r\nif (err)\r\ncfg80211_sme_free(wdev);\r\nreturn err;\r\n}\r\nstatic int cfg80211_sme_disconnect(struct wireless_dev *wdev, u16 reason)\r\n{\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nint err;\r\nif (!wdev->conn)\r\nreturn 0;\r\nif (!rdev->ops->deauth)\r\nreturn -EOPNOTSUPP;\r\nif (wdev->conn->state == CFG80211_CONN_SCANNING ||\r\nwdev->conn->state == CFG80211_CONN_SCAN_AGAIN) {\r\nerr = 0;\r\ngoto out;\r\n}\r\nerr = cfg80211_mlme_deauth(rdev, wdev->netdev,\r\nwdev->conn->params.bssid,\r\nNULL, 0, reason, false);\r\nout:\r\ncfg80211_sme_free(wdev);\r\nreturn err;\r\n}\r\nstatic bool cfg80211_is_all_idle(void)\r\n{\r\nstruct cfg80211_registered_device *rdev;\r\nstruct wireless_dev *wdev;\r\nbool is_all_idle = true;\r\nlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\r\nlist_for_each_entry(wdev, &rdev->wdev_list, list) {\r\nwdev_lock(wdev);\r\nif (wdev->conn || wdev->current_bss)\r\nis_all_idle = false;\r\nwdev_unlock(wdev);\r\n}\r\n}\r\nreturn is_all_idle;\r\n}\r\nstatic void disconnect_work(struct work_struct *work)\r\n{\r\nrtnl_lock();\r\nif (cfg80211_is_all_idle())\r\nregulatory_hint_disconnect();\r\nrtnl_unlock();\r\n}\r\nvoid __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,\r\nconst u8 *req_ie, size_t req_ie_len,\r\nconst u8 *resp_ie, size_t resp_ie_len,\r\nu16 status, bool wextev,\r\nstruct cfg80211_bss *bss)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nconst u8 *country_ie;\r\n#ifdef CONFIG_CFG80211_WEXT\r\nunion iwreq_data wrqu;\r\n#endif\r\nASSERT_WDEV_LOCK(wdev);\r\nif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION &&\r\nwdev->iftype != NL80211_IFTYPE_P2P_CLIENT)) {\r\ncfg80211_put_bss(wdev->wiphy, bss);\r\nreturn;\r\n}\r\nnl80211_send_connect_result(wiphy_to_dev(wdev->wiphy), dev,\r\nbssid, req_ie, req_ie_len,\r\nresp_ie, resp_ie_len,\r\nstatus, GFP_KERNEL);\r\n#ifdef CONFIG_CFG80211_WEXT\r\nif (wextev) {\r\nif (req_ie && status == WLAN_STATUS_SUCCESS) {\r\nmemset(&wrqu, 0, sizeof(wrqu));\r\nwrqu.data.length = req_ie_len;\r\nwireless_send_event(dev, IWEVASSOCREQIE, &wrqu, req_ie);\r\n}\r\nif (resp_ie && status == WLAN_STATUS_SUCCESS) {\r\nmemset(&wrqu, 0, sizeof(wrqu));\r\nwrqu.data.length = resp_ie_len;\r\nwireless_send_event(dev, IWEVASSOCRESPIE, &wrqu, resp_ie);\r\n}\r\nmemset(&wrqu, 0, sizeof(wrqu));\r\nwrqu.ap_addr.sa_family = ARPHRD_ETHER;\r\nif (bssid && status == WLAN_STATUS_SUCCESS) {\r\nmemcpy(wrqu.ap_addr.sa_data, bssid, ETH_ALEN);\r\nmemcpy(wdev->wext.prev_bssid, bssid, ETH_ALEN);\r\nwdev->wext.prev_bssid_valid = true;\r\n}\r\nwireless_send_event(dev, SIOCGIWAP, &wrqu, NULL);\r\n}\r\n#endif\r\nif (wdev->current_bss) {\r\ncfg80211_unhold_bss(wdev->current_bss);\r\ncfg80211_put_bss(wdev->wiphy, &wdev->current_bss->pub);\r\nwdev->current_bss = NULL;\r\n}\r\nif (status != WLAN_STATUS_SUCCESS) {\r\nkfree(wdev->connect_keys);\r\nwdev->connect_keys = NULL;\r\nwdev->ssid_len = 0;\r\nif (bss) {\r\ncfg80211_unhold_bss(bss_from_pub(bss));\r\ncfg80211_put_bss(wdev->wiphy, bss);\r\n}\r\nreturn;\r\n}\r\nif (!bss) {\r\nWARN_ON_ONCE(!wiphy_to_dev(wdev->wiphy)->ops->connect);\r\nbss = cfg80211_get_bss(wdev->wiphy, NULL, bssid,\r\nwdev->ssid, wdev->ssid_len,\r\nWLAN_CAPABILITY_ESS,\r\nWLAN_CAPABILITY_ESS);\r\nif (WARN_ON(!bss))\r\nreturn;\r\ncfg80211_hold_bss(bss_from_pub(bss));\r\n}\r\nwdev->current_bss = bss_from_pub(bss);\r\ncfg80211_upload_connect_keys(wdev);\r\nrcu_read_lock();\r\ncountry_ie = ieee80211_bss_get_ie(bss, WLAN_EID_COUNTRY);\r\nif (!country_ie) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\ncountry_ie = kmemdup(country_ie, 2 + country_ie[1], GFP_ATOMIC);\r\nrcu_read_unlock();\r\nif (!country_ie)\r\nreturn;\r\nregulatory_hint_11d(wdev->wiphy, bss->channel->band,\r\ncountry_ie + 2, country_ie[1]);\r\nkfree(country_ie);\r\n}\r\nvoid cfg80211_connect_result(struct net_device *dev, const u8 *bssid,\r\nconst u8 *req_ie, size_t req_ie_len,\r\nconst u8 *resp_ie, size_t resp_ie_len,\r\nu16 status, gfp_t gfp)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nstruct cfg80211_event *ev;\r\nunsigned long flags;\r\nev = kzalloc(sizeof(*ev) + req_ie_len + resp_ie_len, gfp);\r\nif (!ev)\r\nreturn;\r\nev->type = EVENT_CONNECT_RESULT;\r\nif (bssid)\r\nmemcpy(ev->cr.bssid, bssid, ETH_ALEN);\r\nif (req_ie_len) {\r\nev->cr.req_ie = ((u8 *)ev) + sizeof(*ev);\r\nev->cr.req_ie_len = req_ie_len;\r\nmemcpy((void *)ev->cr.req_ie, req_ie, req_ie_len);\r\n}\r\nif (resp_ie_len) {\r\nev->cr.resp_ie = ((u8 *)ev) + sizeof(*ev) + req_ie_len;\r\nev->cr.resp_ie_len = resp_ie_len;\r\nmemcpy((void *)ev->cr.resp_ie, resp_ie, resp_ie_len);\r\n}\r\nev->cr.status = status;\r\nspin_lock_irqsave(&wdev->event_lock, flags);\r\nlist_add_tail(&ev->list, &wdev->event_list);\r\nspin_unlock_irqrestore(&wdev->event_lock, flags);\r\nqueue_work(cfg80211_wq, &rdev->event_work);\r\n}\r\nvoid __cfg80211_roamed(struct wireless_dev *wdev,\r\nstruct cfg80211_bss *bss,\r\nconst u8 *req_ie, size_t req_ie_len,\r\nconst u8 *resp_ie, size_t resp_ie_len)\r\n{\r\n#ifdef CONFIG_CFG80211_WEXT\r\nunion iwreq_data wrqu;\r\n#endif\r\nASSERT_WDEV_LOCK(wdev);\r\nif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION &&\r\nwdev->iftype != NL80211_IFTYPE_P2P_CLIENT))\r\ngoto out;\r\nif (WARN_ON(!wdev->current_bss))\r\ngoto out;\r\ncfg80211_unhold_bss(wdev->current_bss);\r\ncfg80211_put_bss(wdev->wiphy, &wdev->current_bss->pub);\r\nwdev->current_bss = NULL;\r\ncfg80211_hold_bss(bss_from_pub(bss));\r\nwdev->current_bss = bss_from_pub(bss);\r\nnl80211_send_roamed(wiphy_to_dev(wdev->wiphy), wdev->netdev, bss->bssid,\r\nreq_ie, req_ie_len, resp_ie, resp_ie_len,\r\nGFP_KERNEL);\r\n#ifdef CONFIG_CFG80211_WEXT\r\nif (req_ie) {\r\nmemset(&wrqu, 0, sizeof(wrqu));\r\nwrqu.data.length = req_ie_len;\r\nwireless_send_event(wdev->netdev, IWEVASSOCREQIE,\r\n&wrqu, req_ie);\r\n}\r\nif (resp_ie) {\r\nmemset(&wrqu, 0, sizeof(wrqu));\r\nwrqu.data.length = resp_ie_len;\r\nwireless_send_event(wdev->netdev, IWEVASSOCRESPIE,\r\n&wrqu, resp_ie);\r\n}\r\nmemset(&wrqu, 0, sizeof(wrqu));\r\nwrqu.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(wrqu.ap_addr.sa_data, bss->bssid, ETH_ALEN);\r\nmemcpy(wdev->wext.prev_bssid, bss->bssid, ETH_ALEN);\r\nwdev->wext.prev_bssid_valid = true;\r\nwireless_send_event(wdev->netdev, SIOCGIWAP, &wrqu, NULL);\r\n#endif\r\nreturn;\r\nout:\r\ncfg80211_put_bss(wdev->wiphy, bss);\r\n}\r\nvoid cfg80211_roamed(struct net_device *dev,\r\nstruct ieee80211_channel *channel,\r\nconst u8 *bssid,\r\nconst u8 *req_ie, size_t req_ie_len,\r\nconst u8 *resp_ie, size_t resp_ie_len, gfp_t gfp)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_bss *bss;\r\nbss = cfg80211_get_bss(wdev->wiphy, channel, bssid, wdev->ssid,\r\nwdev->ssid_len, WLAN_CAPABILITY_ESS,\r\nWLAN_CAPABILITY_ESS);\r\nif (WARN_ON(!bss))\r\nreturn;\r\ncfg80211_roamed_bss(dev, bss, req_ie, req_ie_len, resp_ie,\r\nresp_ie_len, gfp);\r\n}\r\nvoid cfg80211_roamed_bss(struct net_device *dev,\r\nstruct cfg80211_bss *bss, const u8 *req_ie,\r\nsize_t req_ie_len, const u8 *resp_ie,\r\nsize_t resp_ie_len, gfp_t gfp)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nstruct cfg80211_event *ev;\r\nunsigned long flags;\r\nif (WARN_ON(!bss))\r\nreturn;\r\nev = kzalloc(sizeof(*ev) + req_ie_len + resp_ie_len, gfp);\r\nif (!ev) {\r\ncfg80211_put_bss(wdev->wiphy, bss);\r\nreturn;\r\n}\r\nev->type = EVENT_ROAMED;\r\nev->rm.req_ie = ((u8 *)ev) + sizeof(*ev);\r\nev->rm.req_ie_len = req_ie_len;\r\nmemcpy((void *)ev->rm.req_ie, req_ie, req_ie_len);\r\nev->rm.resp_ie = ((u8 *)ev) + sizeof(*ev) + req_ie_len;\r\nev->rm.resp_ie_len = resp_ie_len;\r\nmemcpy((void *)ev->rm.resp_ie, resp_ie, resp_ie_len);\r\nev->rm.bss = bss;\r\nspin_lock_irqsave(&wdev->event_lock, flags);\r\nlist_add_tail(&ev->list, &wdev->event_list);\r\nspin_unlock_irqrestore(&wdev->event_lock, flags);\r\nqueue_work(cfg80211_wq, &rdev->event_work);\r\n}\r\nvoid __cfg80211_disconnected(struct net_device *dev, const u8 *ie,\r\nsize_t ie_len, u16 reason, bool from_ap)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nint i;\r\n#ifdef CONFIG_CFG80211_WEXT\r\nunion iwreq_data wrqu;\r\n#endif\r\nASSERT_WDEV_LOCK(wdev);\r\nif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION &&\r\nwdev->iftype != NL80211_IFTYPE_P2P_CLIENT))\r\nreturn;\r\nif (wdev->current_bss) {\r\ncfg80211_unhold_bss(wdev->current_bss);\r\ncfg80211_put_bss(wdev->wiphy, &wdev->current_bss->pub);\r\n}\r\nwdev->current_bss = NULL;\r\nwdev->ssid_len = 0;\r\nnl80211_send_disconnected(rdev, dev, reason, ie, ie_len, from_ap);\r\nif (rdev->ops->del_key)\r\nfor (i = 0; i < 6; i++)\r\nrdev_del_key(rdev, dev, i, false, NULL);\r\n#ifdef CONFIG_CFG80211_WEXT\r\nmemset(&wrqu, 0, sizeof(wrqu));\r\nwrqu.ap_addr.sa_family = ARPHRD_ETHER;\r\nwireless_send_event(dev, SIOCGIWAP, &wrqu, NULL);\r\nwdev->wext.connect.ssid_len = 0;\r\n#endif\r\nschedule_work(&cfg80211_disconnect_work);\r\n}\r\nvoid cfg80211_disconnected(struct net_device *dev, u16 reason,\r\nu8 *ie, size_t ie_len, gfp_t gfp)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nstruct cfg80211_event *ev;\r\nunsigned long flags;\r\nev = kzalloc(sizeof(*ev) + ie_len, gfp);\r\nif (!ev)\r\nreturn;\r\nev->type = EVENT_DISCONNECTED;\r\nev->dc.ie = ((u8 *)ev) + sizeof(*ev);\r\nev->dc.ie_len = ie_len;\r\nmemcpy((void *)ev->dc.ie, ie, ie_len);\r\nev->dc.reason = reason;\r\nspin_lock_irqsave(&wdev->event_lock, flags);\r\nlist_add_tail(&ev->list, &wdev->event_list);\r\nspin_unlock_irqrestore(&wdev->event_lock, flags);\r\nqueue_work(cfg80211_wq, &rdev->event_work);\r\n}\r\nint cfg80211_connect(struct cfg80211_registered_device *rdev,\r\nstruct net_device *dev,\r\nstruct cfg80211_connect_params *connect,\r\nstruct cfg80211_cached_keys *connkeys,\r\nconst u8 *prev_bssid)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nint err;\r\nASSERT_WDEV_LOCK(wdev);\r\nif (WARN_ON(wdev->connect_keys)) {\r\nkfree(wdev->connect_keys);\r\nwdev->connect_keys = NULL;\r\n}\r\ncfg80211_oper_and_ht_capa(&connect->ht_capa_mask,\r\nrdev->wiphy.ht_capa_mod_mask);\r\nif (connkeys && connkeys->def >= 0) {\r\nint idx;\r\nu32 cipher;\r\nidx = connkeys->def;\r\ncipher = connkeys->params[idx].cipher;\r\nif (cipher == WLAN_CIPHER_SUITE_WEP40 ||\r\ncipher == WLAN_CIPHER_SUITE_WEP104) {\r\nconnect->key_idx = idx;\r\nconnect->key = connkeys->params[idx].key;\r\nconnect->key_len = connkeys->params[idx].key_len;\r\nif (connect->crypto.cipher_group == 0)\r\nconnect->crypto.cipher_group = cipher;\r\nif (connect->crypto.n_ciphers_pairwise == 0) {\r\nconnect->crypto.n_ciphers_pairwise = 1;\r\nconnect->crypto.ciphers_pairwise[0] = cipher;\r\n}\r\n}\r\n}\r\nwdev->connect_keys = connkeys;\r\nmemcpy(wdev->ssid, connect->ssid, connect->ssid_len);\r\nwdev->ssid_len = connect->ssid_len;\r\nif (!rdev->ops->connect)\r\nerr = cfg80211_sme_connect(wdev, connect, prev_bssid);\r\nelse\r\nerr = rdev_connect(rdev, dev, connect);\r\nif (err) {\r\nwdev->connect_keys = NULL;\r\nwdev->ssid_len = 0;\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint cfg80211_disconnect(struct cfg80211_registered_device *rdev,\r\nstruct net_device *dev, u16 reason, bool wextev)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nint err = 0;\r\nASSERT_WDEV_LOCK(wdev);\r\nkfree(wdev->connect_keys);\r\nwdev->connect_keys = NULL;\r\nif (wdev->conn)\r\nerr = cfg80211_sme_disconnect(wdev, reason);\r\nelse if (!rdev->ops->disconnect)\r\ncfg80211_mlme_down(rdev, dev);\r\nelse if (wdev->current_bss)\r\nerr = rdev_disconnect(rdev, dev, reason);\r\nreturn err;\r\n}
