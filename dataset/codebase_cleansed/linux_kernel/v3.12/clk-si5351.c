static inline u8 si5351_reg_read(struct si5351_driver_data *drvdata, u8 reg)\r\n{\r\nu32 val;\r\nint ret;\r\nret = regmap_read(drvdata->regmap, reg, &val);\r\nif (ret) {\r\ndev_err(&drvdata->client->dev,\r\n"unable to read from reg%02x\n", reg);\r\nreturn 0;\r\n}\r\nreturn (u8)val;\r\n}\r\nstatic inline int si5351_bulk_read(struct si5351_driver_data *drvdata,\r\nu8 reg, u8 count, u8 *buf)\r\n{\r\nreturn regmap_bulk_read(drvdata->regmap, reg, buf, count);\r\n}\r\nstatic inline int si5351_reg_write(struct si5351_driver_data *drvdata,\r\nu8 reg, u8 val)\r\n{\r\nreturn regmap_write(drvdata->regmap, reg, val);\r\n}\r\nstatic inline int si5351_bulk_write(struct si5351_driver_data *drvdata,\r\nu8 reg, u8 count, const u8 *buf)\r\n{\r\nreturn regmap_raw_write(drvdata->regmap, reg, buf, count);\r\n}\r\nstatic inline int si5351_set_bits(struct si5351_driver_data *drvdata,\r\nu8 reg, u8 mask, u8 val)\r\n{\r\nreturn regmap_update_bits(drvdata->regmap, reg, mask, val);\r\n}\r\nstatic inline u8 si5351_msynth_params_address(int num)\r\n{\r\nif (num > 5)\r\nreturn SI5351_CLK6_PARAMETERS + (num - 6);\r\nreturn SI5351_CLK0_PARAMETERS + (SI5351_PARAMETERS_LENGTH * num);\r\n}\r\nstatic void si5351_read_parameters(struct si5351_driver_data *drvdata,\r\nu8 reg, struct si5351_parameters *params)\r\n{\r\nu8 buf[SI5351_PARAMETERS_LENGTH];\r\nswitch (reg) {\r\ncase SI5351_CLK6_PARAMETERS:\r\ncase SI5351_CLK7_PARAMETERS:\r\nbuf[0] = si5351_reg_read(drvdata, reg);\r\nparams->p1 = buf[0];\r\nparams->p2 = 0;\r\nparams->p3 = 1;\r\nbreak;\r\ndefault:\r\nsi5351_bulk_read(drvdata, reg, SI5351_PARAMETERS_LENGTH, buf);\r\nparams->p1 = ((buf[2] & 0x03) << 16) | (buf[3] << 8) | buf[4];\r\nparams->p2 = ((buf[5] & 0x0f) << 16) | (buf[6] << 8) | buf[7];\r\nparams->p3 = ((buf[5] & 0xf0) << 12) | (buf[0] << 8) | buf[1];\r\n}\r\nparams->valid = 1;\r\n}\r\nstatic void si5351_write_parameters(struct si5351_driver_data *drvdata,\r\nu8 reg, struct si5351_parameters *params)\r\n{\r\nu8 buf[SI5351_PARAMETERS_LENGTH];\r\nswitch (reg) {\r\ncase SI5351_CLK6_PARAMETERS:\r\ncase SI5351_CLK7_PARAMETERS:\r\nbuf[0] = params->p1 & 0xff;\r\nsi5351_reg_write(drvdata, reg, buf[0]);\r\nbreak;\r\ndefault:\r\nbuf[0] = ((params->p3 & 0x0ff00) >> 8) & 0xff;\r\nbuf[1] = params->p3 & 0xff;\r\nbuf[2] = si5351_reg_read(drvdata, reg + 2) & ~0x03;\r\nbuf[2] |= ((params->p1 & 0x30000) >> 16) & 0x03;\r\nbuf[3] = ((params->p1 & 0x0ff00) >> 8) & 0xff;\r\nbuf[4] = params->p1 & 0xff;\r\nbuf[5] = ((params->p3 & 0xf0000) >> 12) |\r\n((params->p2 & 0xf0000) >> 16);\r\nbuf[6] = ((params->p2 & 0x0ff00) >> 8) & 0xff;\r\nbuf[7] = params->p2 & 0xff;\r\nsi5351_bulk_write(drvdata, reg, SI5351_PARAMETERS_LENGTH, buf);\r\n}\r\n}\r\nstatic bool si5351_regmap_is_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase SI5351_DEVICE_STATUS:\r\ncase SI5351_INTERRUPT_STATUS:\r\ncase SI5351_PLL_RESET:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool si5351_regmap_is_writeable(struct device *dev, unsigned int reg)\r\n{\r\nif (reg >= 4 && reg <= 8)\r\nreturn false;\r\nif (reg >= 10 && reg <= 14)\r\nreturn false;\r\nif (reg >= 173 && reg <= 176)\r\nreturn false;\r\nif (reg >= 178 && reg <= 182)\r\nreturn false;\r\nif (reg == SI5351_DEVICE_STATUS)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int si5351_xtal_prepare(struct clk_hw *hw)\r\n{\r\nstruct si5351_driver_data *drvdata =\r\ncontainer_of(hw, struct si5351_driver_data, xtal);\r\nsi5351_set_bits(drvdata, SI5351_FANOUT_ENABLE,\r\nSI5351_XTAL_ENABLE, SI5351_XTAL_ENABLE);\r\nreturn 0;\r\n}\r\nstatic void si5351_xtal_unprepare(struct clk_hw *hw)\r\n{\r\nstruct si5351_driver_data *drvdata =\r\ncontainer_of(hw, struct si5351_driver_data, xtal);\r\nsi5351_set_bits(drvdata, SI5351_FANOUT_ENABLE,\r\nSI5351_XTAL_ENABLE, 0);\r\n}\r\nstatic int si5351_clkin_prepare(struct clk_hw *hw)\r\n{\r\nstruct si5351_driver_data *drvdata =\r\ncontainer_of(hw, struct si5351_driver_data, clkin);\r\nsi5351_set_bits(drvdata, SI5351_FANOUT_ENABLE,\r\nSI5351_CLKIN_ENABLE, SI5351_CLKIN_ENABLE);\r\nreturn 0;\r\n}\r\nstatic void si5351_clkin_unprepare(struct clk_hw *hw)\r\n{\r\nstruct si5351_driver_data *drvdata =\r\ncontainer_of(hw, struct si5351_driver_data, clkin);\r\nsi5351_set_bits(drvdata, SI5351_FANOUT_ENABLE,\r\nSI5351_CLKIN_ENABLE, 0);\r\n}\r\nstatic unsigned long si5351_clkin_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct si5351_driver_data *drvdata =\r\ncontainer_of(hw, struct si5351_driver_data, clkin);\r\nunsigned long rate;\r\nunsigned char idiv;\r\nrate = parent_rate;\r\nif (parent_rate > 160000000) {\r\nidiv = SI5351_CLKIN_DIV_8;\r\nrate /= 8;\r\n} else if (parent_rate > 80000000) {\r\nidiv = SI5351_CLKIN_DIV_4;\r\nrate /= 4;\r\n} else if (parent_rate > 40000000) {\r\nidiv = SI5351_CLKIN_DIV_2;\r\nrate /= 2;\r\n} else {\r\nidiv = SI5351_CLKIN_DIV_1;\r\n}\r\nsi5351_set_bits(drvdata, SI5351_PLL_INPUT_SOURCE,\r\nSI5351_CLKIN_DIV_MASK, idiv);\r\ndev_dbg(&drvdata->client->dev, "%s - clkin div = %d, rate = %lu\n",\r\n__func__, (1 << (idiv >> 6)), rate);\r\nreturn rate;\r\n}\r\nstatic int si5351_vxco_prepare(struct clk_hw *hw)\r\n{\r\nstruct si5351_hw_data *hwdata =\r\ncontainer_of(hw, struct si5351_hw_data, hw);\r\ndev_warn(&hwdata->drvdata->client->dev, "VXCO currently unsupported\n");\r\nreturn 0;\r\n}\r\nstatic void si5351_vxco_unprepare(struct clk_hw *hw)\r\n{\r\n}\r\nstatic unsigned long si5351_vxco_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn 0;\r\n}\r\nstatic int si5351_vxco_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent)\r\n{\r\nreturn 0;\r\n}\r\nstatic int _si5351_pll_reparent(struct si5351_driver_data *drvdata,\r\nint num, enum si5351_pll_src parent)\r\n{\r\nu8 mask = (num == 0) ? SI5351_PLLA_SOURCE : SI5351_PLLB_SOURCE;\r\nif (parent == SI5351_PLL_SRC_DEFAULT)\r\nreturn 0;\r\nif (num > 2)\r\nreturn -EINVAL;\r\nif (drvdata->variant != SI5351_VARIANT_C &&\r\nparent != SI5351_PLL_SRC_XTAL)\r\nreturn -EINVAL;\r\nsi5351_set_bits(drvdata, SI5351_PLL_INPUT_SOURCE, mask,\r\n(parent == SI5351_PLL_SRC_XTAL) ? 0 : mask);\r\nreturn 0;\r\n}\r\nstatic unsigned char si5351_pll_get_parent(struct clk_hw *hw)\r\n{\r\nstruct si5351_hw_data *hwdata =\r\ncontainer_of(hw, struct si5351_hw_data, hw);\r\nu8 mask = (hwdata->num == 0) ? SI5351_PLLA_SOURCE : SI5351_PLLB_SOURCE;\r\nu8 val;\r\nval = si5351_reg_read(hwdata->drvdata, SI5351_PLL_INPUT_SOURCE);\r\nreturn (val & mask) ? 1 : 0;\r\n}\r\nstatic int si5351_pll_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct si5351_hw_data *hwdata =\r\ncontainer_of(hw, struct si5351_hw_data, hw);\r\nif (hwdata->drvdata->variant != SI5351_VARIANT_C &&\r\nindex > 0)\r\nreturn -EPERM;\r\nif (index > 1)\r\nreturn -EINVAL;\r\nreturn _si5351_pll_reparent(hwdata->drvdata, hwdata->num,\r\n(index == 0) ? SI5351_PLL_SRC_XTAL :\r\nSI5351_PLL_SRC_CLKIN);\r\n}\r\nstatic unsigned long si5351_pll_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct si5351_hw_data *hwdata =\r\ncontainer_of(hw, struct si5351_hw_data, hw);\r\nu8 reg = (hwdata->num == 0) ? SI5351_PLLA_PARAMETERS :\r\nSI5351_PLLB_PARAMETERS;\r\nunsigned long long rate;\r\nif (!hwdata->params.valid)\r\nsi5351_read_parameters(hwdata->drvdata, reg, &hwdata->params);\r\nif (hwdata->params.p3 == 0)\r\nreturn parent_rate;\r\nrate = hwdata->params.p1 * hwdata->params.p3;\r\nrate += 512 * hwdata->params.p3;\r\nrate += hwdata->params.p2;\r\nrate *= parent_rate;\r\ndo_div(rate, 128 * hwdata->params.p3);\r\ndev_dbg(&hwdata->drvdata->client->dev,\r\n"%s - %s: p1 = %lu, p2 = %lu, p3 = %lu, parent_rate = %lu, rate = %lu\n",\r\n__func__, __clk_get_name(hwdata->hw.clk),\r\nhwdata->params.p1, hwdata->params.p2, hwdata->params.p3,\r\nparent_rate, (unsigned long)rate);\r\nreturn (unsigned long)rate;\r\n}\r\nstatic long si5351_pll_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct si5351_hw_data *hwdata =\r\ncontainer_of(hw, struct si5351_hw_data, hw);\r\nunsigned long rfrac, denom, a, b, c;\r\nunsigned long long lltmp;\r\nif (rate < SI5351_PLL_VCO_MIN)\r\nrate = SI5351_PLL_VCO_MIN;\r\nif (rate > SI5351_PLL_VCO_MAX)\r\nrate = SI5351_PLL_VCO_MAX;\r\na = rate / *parent_rate;\r\nif (a < SI5351_PLL_A_MIN)\r\nrate = *parent_rate * SI5351_PLL_A_MIN;\r\nif (a > SI5351_PLL_A_MAX)\r\nrate = *parent_rate * SI5351_PLL_A_MAX;\r\ndenom = 1000 * 1000;\r\nlltmp = rate % (*parent_rate);\r\nlltmp *= denom;\r\ndo_div(lltmp, *parent_rate);\r\nrfrac = (unsigned long)lltmp;\r\nb = 0;\r\nc = 1;\r\nif (rfrac)\r\nrational_best_approximation(rfrac, denom,\r\nSI5351_PLL_B_MAX, SI5351_PLL_C_MAX, &b, &c);\r\nhwdata->params.p3 = c;\r\nhwdata->params.p2 = (128 * b) % c;\r\nhwdata->params.p1 = 128 * a;\r\nhwdata->params.p1 += (128 * b / c);\r\nhwdata->params.p1 -= 512;\r\nlltmp = *parent_rate;\r\nlltmp *= b;\r\ndo_div(lltmp, c);\r\nrate = (unsigned long)lltmp;\r\nrate += *parent_rate * a;\r\ndev_dbg(&hwdata->drvdata->client->dev,\r\n"%s - %s: a = %lu, b = %lu, c = %lu, parent_rate = %lu, rate = %lu\n",\r\n__func__, __clk_get_name(hwdata->hw.clk), a, b, c,\r\n*parent_rate, rate);\r\nreturn rate;\r\n}\r\nstatic int si5351_pll_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct si5351_hw_data *hwdata =\r\ncontainer_of(hw, struct si5351_hw_data, hw);\r\nu8 reg = (hwdata->num == 0) ? SI5351_PLLA_PARAMETERS :\r\nSI5351_PLLB_PARAMETERS;\r\nsi5351_write_parameters(hwdata->drvdata, reg, &hwdata->params);\r\nsi5351_set_bits(hwdata->drvdata, SI5351_CLK6_CTRL + hwdata->num,\r\nSI5351_CLK_INTEGER_MODE,\r\n(hwdata->params.p2 == 0) ? SI5351_CLK_INTEGER_MODE : 0);\r\ndev_dbg(&hwdata->drvdata->client->dev,\r\n"%s - %s: p1 = %lu, p2 = %lu, p3 = %lu, parent_rate = %lu, rate = %lu\n",\r\n__func__, __clk_get_name(hwdata->hw.clk),\r\nhwdata->params.p1, hwdata->params.p2, hwdata->params.p3,\r\nparent_rate, rate);\r\nreturn 0;\r\n}\r\nstatic int _si5351_msynth_reparent(struct si5351_driver_data *drvdata,\r\nint num, enum si5351_multisynth_src parent)\r\n{\r\nif (parent == SI5351_MULTISYNTH_SRC_DEFAULT)\r\nreturn 0;\r\nif (num > 8)\r\nreturn -EINVAL;\r\nsi5351_set_bits(drvdata, SI5351_CLK0_CTRL + num, SI5351_CLK_PLL_SELECT,\r\n(parent == SI5351_MULTISYNTH_SRC_VCO0) ? 0 :\r\nSI5351_CLK_PLL_SELECT);\r\nreturn 0;\r\n}\r\nstatic unsigned char si5351_msynth_get_parent(struct clk_hw *hw)\r\n{\r\nstruct si5351_hw_data *hwdata =\r\ncontainer_of(hw, struct si5351_hw_data, hw);\r\nu8 val;\r\nval = si5351_reg_read(hwdata->drvdata, SI5351_CLK0_CTRL + hwdata->num);\r\nreturn (val & SI5351_CLK_PLL_SELECT) ? 1 : 0;\r\n}\r\nstatic int si5351_msynth_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct si5351_hw_data *hwdata =\r\ncontainer_of(hw, struct si5351_hw_data, hw);\r\nreturn _si5351_msynth_reparent(hwdata->drvdata, hwdata->num,\r\n(index == 0) ? SI5351_MULTISYNTH_SRC_VCO0 :\r\nSI5351_MULTISYNTH_SRC_VCO1);\r\n}\r\nstatic unsigned long si5351_msynth_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct si5351_hw_data *hwdata =\r\ncontainer_of(hw, struct si5351_hw_data, hw);\r\nu8 reg = si5351_msynth_params_address(hwdata->num);\r\nunsigned long long rate;\r\nunsigned long m;\r\nif (!hwdata->params.valid)\r\nsi5351_read_parameters(hwdata->drvdata, reg, &hwdata->params);\r\nif (hwdata->params.p3 == 0)\r\nreturn parent_rate;\r\nrate = parent_rate;\r\nif (hwdata->num > 5) {\r\nm = hwdata->params.p1;\r\n} else if ((si5351_reg_read(hwdata->drvdata, reg + 2) &\r\nSI5351_OUTPUT_CLK_DIVBY4) == SI5351_OUTPUT_CLK_DIVBY4) {\r\nm = 4;\r\n} else {\r\nrate *= 128 * hwdata->params.p3;\r\nm = hwdata->params.p1 * hwdata->params.p3;\r\nm += hwdata->params.p2;\r\nm += 512 * hwdata->params.p3;\r\n}\r\nif (m == 0)\r\nreturn 0;\r\ndo_div(rate, m);\r\ndev_dbg(&hwdata->drvdata->client->dev,\r\n"%s - %s: p1 = %lu, p2 = %lu, p3 = %lu, m = %lu, parent_rate = %lu, rate = %lu\n",\r\n__func__, __clk_get_name(hwdata->hw.clk),\r\nhwdata->params.p1, hwdata->params.p2, hwdata->params.p3,\r\nm, parent_rate, (unsigned long)rate);\r\nreturn (unsigned long)rate;\r\n}\r\nstatic long si5351_msynth_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct si5351_hw_data *hwdata =\r\ncontainer_of(hw, struct si5351_hw_data, hw);\r\nunsigned long long lltmp;\r\nunsigned long a, b, c;\r\nint divby4;\r\nif (hwdata->num >= 6 && rate > SI5351_MULTISYNTH67_MAX_FREQ)\r\nrate = SI5351_MULTISYNTH67_MAX_FREQ;\r\nif (rate > SI5351_MULTISYNTH_MAX_FREQ)\r\nrate = SI5351_MULTISYNTH_MAX_FREQ;\r\nif (rate < SI5351_MULTISYNTH_MIN_FREQ)\r\nrate = SI5351_MULTISYNTH_MIN_FREQ;\r\ndivby4 = 0;\r\nif (rate > SI5351_MULTISYNTH_DIVBY4_FREQ)\r\ndivby4 = 1;\r\nif (__clk_get_flags(hwdata->hw.clk) & CLK_SET_RATE_PARENT) {\r\nif (divby4 == 0) {\r\nlltmp = SI5351_PLL_VCO_MAX;\r\ndo_div(lltmp, rate);\r\na = (unsigned long)lltmp;\r\n} else\r\na = 4;\r\nb = 0;\r\nc = 1;\r\n*parent_rate = a * rate;\r\n} else {\r\nunsigned long rfrac, denom;\r\nif (divby4) {\r\nrate = SI5351_MULTISYNTH_DIVBY4_FREQ;\r\ndivby4 = 0;\r\n}\r\na = *parent_rate / rate;\r\nif (a < SI5351_MULTISYNTH_A_MIN)\r\na = SI5351_MULTISYNTH_A_MIN;\r\nif (hwdata->num >= 6 && a > SI5351_MULTISYNTH67_A_MAX)\r\na = SI5351_MULTISYNTH67_A_MAX;\r\nelse if (a > SI5351_MULTISYNTH_A_MAX)\r\na = SI5351_MULTISYNTH_A_MAX;\r\ndenom = 1000 * 1000;\r\nlltmp = (*parent_rate) % rate;\r\nlltmp *= denom;\r\ndo_div(lltmp, rate);\r\nrfrac = (unsigned long)lltmp;\r\nb = 0;\r\nc = 1;\r\nif (rfrac)\r\nrational_best_approximation(rfrac, denom,\r\nSI5351_MULTISYNTH_B_MAX, SI5351_MULTISYNTH_C_MAX,\r\n&b, &c);\r\n}\r\nlltmp = *parent_rate;\r\nlltmp *= c;\r\ndo_div(lltmp, a * c + b);\r\nrate = (unsigned long)lltmp;\r\nif (divby4) {\r\nhwdata->params.p3 = 1;\r\nhwdata->params.p2 = 0;\r\nhwdata->params.p1 = 0;\r\n} else {\r\nhwdata->params.p3 = c;\r\nhwdata->params.p2 = (128 * b) % c;\r\nhwdata->params.p1 = 128 * a;\r\nhwdata->params.p1 += (128 * b / c);\r\nhwdata->params.p1 -= 512;\r\n}\r\ndev_dbg(&hwdata->drvdata->client->dev,\r\n"%s - %s: a = %lu, b = %lu, c = %lu, divby4 = %d, parent_rate = %lu, rate = %lu\n",\r\n__func__, __clk_get_name(hwdata->hw.clk), a, b, c, divby4,\r\n*parent_rate, rate);\r\nreturn rate;\r\n}\r\nstatic int si5351_msynth_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct si5351_hw_data *hwdata =\r\ncontainer_of(hw, struct si5351_hw_data, hw);\r\nu8 reg = si5351_msynth_params_address(hwdata->num);\r\nint divby4 = 0;\r\nsi5351_write_parameters(hwdata->drvdata, reg, &hwdata->params);\r\nif (rate > SI5351_MULTISYNTH_DIVBY4_FREQ)\r\ndivby4 = 1;\r\nif (hwdata->num < 6) {\r\nsi5351_set_bits(hwdata->drvdata, reg + 2,\r\nSI5351_OUTPUT_CLK_DIVBY4,\r\n(divby4) ? SI5351_OUTPUT_CLK_DIVBY4 : 0);\r\nsi5351_set_bits(hwdata->drvdata, SI5351_CLK0_CTRL + hwdata->num,\r\nSI5351_CLK_INTEGER_MODE,\r\n(hwdata->params.p2 == 0) ? SI5351_CLK_INTEGER_MODE : 0);\r\n}\r\ndev_dbg(&hwdata->drvdata->client->dev,\r\n"%s - %s: p1 = %lu, p2 = %lu, p3 = %lu, divby4 = %d, parent_rate = %lu, rate = %lu\n",\r\n__func__, __clk_get_name(hwdata->hw.clk),\r\nhwdata->params.p1, hwdata->params.p2, hwdata->params.p3,\r\ndivby4, parent_rate, rate);\r\nreturn 0;\r\n}\r\nstatic int _si5351_clkout_reparent(struct si5351_driver_data *drvdata,\r\nint num, enum si5351_clkout_src parent)\r\n{\r\nu8 val;\r\nif (num > 8)\r\nreturn -EINVAL;\r\nswitch (parent) {\r\ncase SI5351_CLKOUT_SRC_MSYNTH_N:\r\nval = SI5351_CLK_INPUT_MULTISYNTH_N;\r\nbreak;\r\ncase SI5351_CLKOUT_SRC_MSYNTH_0_4:\r\nif (num == 0 || num == 4)\r\nval = SI5351_CLK_INPUT_MULTISYNTH_N;\r\nelse\r\nval = SI5351_CLK_INPUT_MULTISYNTH_0_4;\r\nbreak;\r\ncase SI5351_CLKOUT_SRC_XTAL:\r\nval = SI5351_CLK_INPUT_XTAL;\r\nbreak;\r\ncase SI5351_CLKOUT_SRC_CLKIN:\r\nif (drvdata->variant != SI5351_VARIANT_C)\r\nreturn -EINVAL;\r\nval = SI5351_CLK_INPUT_CLKIN;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nsi5351_set_bits(drvdata, SI5351_CLK0_CTRL + num,\r\nSI5351_CLK_INPUT_MASK, val);\r\nreturn 0;\r\n}\r\nstatic int _si5351_clkout_set_drive_strength(\r\nstruct si5351_driver_data *drvdata, int num,\r\nenum si5351_drive_strength drive)\r\n{\r\nu8 mask;\r\nif (num > 8)\r\nreturn -EINVAL;\r\nswitch (drive) {\r\ncase SI5351_DRIVE_2MA:\r\nmask = SI5351_CLK_DRIVE_STRENGTH_2MA;\r\nbreak;\r\ncase SI5351_DRIVE_4MA:\r\nmask = SI5351_CLK_DRIVE_STRENGTH_4MA;\r\nbreak;\r\ncase SI5351_DRIVE_6MA:\r\nmask = SI5351_CLK_DRIVE_STRENGTH_6MA;\r\nbreak;\r\ncase SI5351_DRIVE_8MA:\r\nmask = SI5351_CLK_DRIVE_STRENGTH_8MA;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nsi5351_set_bits(drvdata, SI5351_CLK0_CTRL + num,\r\nSI5351_CLK_DRIVE_STRENGTH_MASK, mask);\r\nreturn 0;\r\n}\r\nstatic int _si5351_clkout_set_disable_state(\r\nstruct si5351_driver_data *drvdata, int num,\r\nenum si5351_disable_state state)\r\n{\r\nu8 reg = (num < 4) ? SI5351_CLK3_0_DISABLE_STATE :\r\nSI5351_CLK7_4_DISABLE_STATE;\r\nu8 shift = (num < 4) ? (2 * num) : (2 * (num-4));\r\nu8 mask = SI5351_CLK_DISABLE_STATE_MASK << shift;\r\nu8 val;\r\nif (num > 8)\r\nreturn -EINVAL;\r\nswitch (state) {\r\ncase SI5351_DISABLE_LOW:\r\nval = SI5351_CLK_DISABLE_STATE_LOW;\r\nbreak;\r\ncase SI5351_DISABLE_HIGH:\r\nval = SI5351_CLK_DISABLE_STATE_HIGH;\r\nbreak;\r\ncase SI5351_DISABLE_FLOATING:\r\nval = SI5351_CLK_DISABLE_STATE_FLOAT;\r\nbreak;\r\ncase SI5351_DISABLE_NEVER:\r\nval = SI5351_CLK_DISABLE_STATE_NEVER;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nsi5351_set_bits(drvdata, reg, mask, val << shift);\r\nreturn 0;\r\n}\r\nstatic int si5351_clkout_prepare(struct clk_hw *hw)\r\n{\r\nstruct si5351_hw_data *hwdata =\r\ncontainer_of(hw, struct si5351_hw_data, hw);\r\nsi5351_set_bits(hwdata->drvdata, SI5351_CLK0_CTRL + hwdata->num,\r\nSI5351_CLK_POWERDOWN, 0);\r\nsi5351_set_bits(hwdata->drvdata, SI5351_OUTPUT_ENABLE_CTRL,\r\n(1 << hwdata->num), 0);\r\nreturn 0;\r\n}\r\nstatic void si5351_clkout_unprepare(struct clk_hw *hw)\r\n{\r\nstruct si5351_hw_data *hwdata =\r\ncontainer_of(hw, struct si5351_hw_data, hw);\r\nsi5351_set_bits(hwdata->drvdata, SI5351_CLK0_CTRL + hwdata->num,\r\nSI5351_CLK_POWERDOWN, SI5351_CLK_POWERDOWN);\r\nsi5351_set_bits(hwdata->drvdata, SI5351_OUTPUT_ENABLE_CTRL,\r\n(1 << hwdata->num), (1 << hwdata->num));\r\n}\r\nstatic u8 si5351_clkout_get_parent(struct clk_hw *hw)\r\n{\r\nstruct si5351_hw_data *hwdata =\r\ncontainer_of(hw, struct si5351_hw_data, hw);\r\nint index = 0;\r\nunsigned char val;\r\nval = si5351_reg_read(hwdata->drvdata, SI5351_CLK0_CTRL + hwdata->num);\r\nswitch (val & SI5351_CLK_INPUT_MASK) {\r\ncase SI5351_CLK_INPUT_MULTISYNTH_N:\r\nindex = 0;\r\nbreak;\r\ncase SI5351_CLK_INPUT_MULTISYNTH_0_4:\r\nindex = 1;\r\nbreak;\r\ncase SI5351_CLK_INPUT_XTAL:\r\nindex = 2;\r\nbreak;\r\ncase SI5351_CLK_INPUT_CLKIN:\r\nindex = 3;\r\nbreak;\r\n}\r\nreturn index;\r\n}\r\nstatic int si5351_clkout_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct si5351_hw_data *hwdata =\r\ncontainer_of(hw, struct si5351_hw_data, hw);\r\nenum si5351_clkout_src parent = SI5351_CLKOUT_SRC_DEFAULT;\r\nswitch (index) {\r\ncase 0:\r\nparent = SI5351_CLKOUT_SRC_MSYNTH_N;\r\nbreak;\r\ncase 1:\r\nparent = SI5351_CLKOUT_SRC_MSYNTH_0_4;\r\nbreak;\r\ncase 2:\r\nparent = SI5351_CLKOUT_SRC_XTAL;\r\nbreak;\r\ncase 3:\r\nparent = SI5351_CLKOUT_SRC_CLKIN;\r\nbreak;\r\n}\r\nreturn _si5351_clkout_reparent(hwdata->drvdata, hwdata->num, parent);\r\n}\r\nstatic unsigned long si5351_clkout_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct si5351_hw_data *hwdata =\r\ncontainer_of(hw, struct si5351_hw_data, hw);\r\nunsigned char reg;\r\nunsigned char rdiv;\r\nif (hwdata->num <= 5)\r\nreg = si5351_msynth_params_address(hwdata->num) + 2;\r\nelse\r\nreg = SI5351_CLK6_7_OUTPUT_DIVIDER;\r\nrdiv = si5351_reg_read(hwdata->drvdata, reg);\r\nif (hwdata->num == 6) {\r\nrdiv &= SI5351_OUTPUT_CLK6_DIV_MASK;\r\n} else {\r\nrdiv &= SI5351_OUTPUT_CLK_DIV_MASK;\r\nrdiv >>= SI5351_OUTPUT_CLK_DIV_SHIFT;\r\n}\r\nreturn parent_rate >> rdiv;\r\n}\r\nstatic long si5351_clkout_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct si5351_hw_data *hwdata =\r\ncontainer_of(hw, struct si5351_hw_data, hw);\r\nunsigned char rdiv;\r\nif (hwdata->num >= 6 && rate > SI5351_CLKOUT67_MAX_FREQ)\r\nrate = SI5351_CLKOUT67_MAX_FREQ;\r\nif (rate > SI5351_CLKOUT_MAX_FREQ)\r\nrate = SI5351_CLKOUT_MAX_FREQ;\r\nif (rate < SI5351_CLKOUT_MIN_FREQ)\r\nrate = SI5351_CLKOUT_MIN_FREQ;\r\nif (__clk_get_flags(hwdata->hw.clk) & CLK_SET_RATE_PARENT) {\r\nrdiv = SI5351_OUTPUT_CLK_DIV_1;\r\nwhile (rate < SI5351_MULTISYNTH_MIN_FREQ &&\r\nrdiv < SI5351_OUTPUT_CLK_DIV_128) {\r\nrdiv += 1;\r\nrate *= 2;\r\n}\r\n*parent_rate = rate;\r\n} else {\r\nunsigned long new_rate, new_err, err;\r\nrdiv = SI5351_OUTPUT_CLK_DIV_1;\r\nnew_rate = *parent_rate;\r\nerr = abs(new_rate - rate);\r\ndo {\r\nnew_rate >>= 1;\r\nnew_err = abs(new_rate - rate);\r\nif (new_err > err || rdiv == SI5351_OUTPUT_CLK_DIV_128)\r\nbreak;\r\nrdiv++;\r\nerr = new_err;\r\n} while (1);\r\n}\r\nrate = *parent_rate >> rdiv;\r\ndev_dbg(&hwdata->drvdata->client->dev,\r\n"%s - %s: rdiv = %u, parent_rate = %lu, rate = %lu\n",\r\n__func__, __clk_get_name(hwdata->hw.clk), (1 << rdiv),\r\n*parent_rate, rate);\r\nreturn rate;\r\n}\r\nstatic int si5351_clkout_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct si5351_hw_data *hwdata =\r\ncontainer_of(hw, struct si5351_hw_data, hw);\r\nunsigned long new_rate, new_err, err;\r\nunsigned char rdiv;\r\nrdiv = SI5351_OUTPUT_CLK_DIV_1;\r\nnew_rate = parent_rate;\r\nerr = abs(new_rate - rate);\r\ndo {\r\nnew_rate >>= 1;\r\nnew_err = abs(new_rate - rate);\r\nif (new_err > err || rdiv == SI5351_OUTPUT_CLK_DIV_128)\r\nbreak;\r\nrdiv++;\r\nerr = new_err;\r\n} while (1);\r\nswitch (hwdata->num) {\r\ncase 6:\r\nsi5351_set_bits(hwdata->drvdata, SI5351_CLK6_7_OUTPUT_DIVIDER,\r\nSI5351_OUTPUT_CLK6_DIV_MASK, rdiv);\r\nbreak;\r\ncase 7:\r\nsi5351_set_bits(hwdata->drvdata, SI5351_CLK6_7_OUTPUT_DIVIDER,\r\nSI5351_OUTPUT_CLK_DIV_MASK,\r\nrdiv << SI5351_OUTPUT_CLK_DIV_SHIFT);\r\nbreak;\r\ndefault:\r\nsi5351_set_bits(hwdata->drvdata,\r\nsi5351_msynth_params_address(hwdata->num) + 2,\r\nSI5351_OUTPUT_CLK_DIV_MASK,\r\nrdiv << SI5351_OUTPUT_CLK_DIV_SHIFT);\r\n}\r\nsi5351_set_bits(hwdata->drvdata, SI5351_CLK0_CTRL + hwdata->num,\r\nSI5351_CLK_POWERDOWN, 0);\r\ndev_dbg(&hwdata->drvdata->client->dev,\r\n"%s - %s: rdiv = %u, parent_rate = %lu, rate = %lu\n",\r\n__func__, __clk_get_name(hwdata->hw.clk), (1 << rdiv),\r\nparent_rate, rate);\r\nreturn 0;\r\n}\r\nstatic int si5351_dt_parse(struct i2c_client *client)\r\n{\r\nstruct device_node *child, *np = client->dev.of_node;\r\nstruct si5351_platform_data *pdata;\r\nconst struct of_device_id *match;\r\nstruct property *prop;\r\nconst __be32 *p;\r\nint num = 0;\r\nu32 val;\r\nif (np == NULL)\r\nreturn 0;\r\nmatch = of_match_node(si5351_dt_ids, np);\r\nif (match == NULL)\r\nreturn -EINVAL;\r\npdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\npdata->variant = (enum si5351_variant)match->data;\r\npdata->clk_xtal = of_clk_get(np, 0);\r\nif (!IS_ERR(pdata->clk_xtal))\r\nclk_put(pdata->clk_xtal);\r\npdata->clk_clkin = of_clk_get(np, 1);\r\nif (!IS_ERR(pdata->clk_clkin))\r\nclk_put(pdata->clk_clkin);\r\nof_property_for_each_u32(np, "silabs,pll-source", prop, p, num) {\r\nif (num >= 2) {\r\ndev_err(&client->dev,\r\n"invalid pll %d on pll-source prop\n", num);\r\nreturn -EINVAL;\r\n}\r\np = of_prop_next_u32(prop, p, &val);\r\nif (!p) {\r\ndev_err(&client->dev,\r\n"missing pll-source for pll %d\n", num);\r\nreturn -EINVAL;\r\n}\r\nswitch (val) {\r\ncase 0:\r\npdata->pll_src[num] = SI5351_PLL_SRC_XTAL;\r\nbreak;\r\ncase 1:\r\nif (pdata->variant != SI5351_VARIANT_C) {\r\ndev_err(&client->dev,\r\n"invalid parent %d for pll %d\n",\r\nval, num);\r\nreturn -EINVAL;\r\n}\r\npdata->pll_src[num] = SI5351_PLL_SRC_CLKIN;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev,\r\n"invalid parent %d for pll %d\n", val, num);\r\nreturn -EINVAL;\r\n}\r\n}\r\nfor_each_child_of_node(np, child) {\r\nif (of_property_read_u32(child, "reg", &num)) {\r\ndev_err(&client->dev, "missing reg property of %s\n",\r\nchild->name);\r\nreturn -EINVAL;\r\n}\r\nif (num >= 8 ||\r\n(pdata->variant == SI5351_VARIANT_A3 && num >= 3)) {\r\ndev_err(&client->dev, "invalid clkout %d\n", num);\r\nreturn -EINVAL;\r\n}\r\nif (!of_property_read_u32(child, "silabs,multisynth-source",\r\n&val)) {\r\nswitch (val) {\r\ncase 0:\r\npdata->clkout[num].multisynth_src =\r\nSI5351_MULTISYNTH_SRC_VCO0;\r\nbreak;\r\ncase 1:\r\npdata->clkout[num].multisynth_src =\r\nSI5351_MULTISYNTH_SRC_VCO1;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev,\r\n"invalid parent %d for multisynth %d\n",\r\nval, num);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!of_property_read_u32(child, "silabs,clock-source", &val)) {\r\nswitch (val) {\r\ncase 0:\r\npdata->clkout[num].clkout_src =\r\nSI5351_CLKOUT_SRC_MSYNTH_N;\r\nbreak;\r\ncase 1:\r\npdata->clkout[num].clkout_src =\r\nSI5351_CLKOUT_SRC_MSYNTH_0_4;\r\nbreak;\r\ncase 2:\r\npdata->clkout[num].clkout_src =\r\nSI5351_CLKOUT_SRC_XTAL;\r\nbreak;\r\ncase 3:\r\nif (pdata->variant != SI5351_VARIANT_C) {\r\ndev_err(&client->dev,\r\n"invalid parent %d for clkout %d\n",\r\nval, num);\r\nreturn -EINVAL;\r\n}\r\npdata->clkout[num].clkout_src =\r\nSI5351_CLKOUT_SRC_CLKIN;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev,\r\n"invalid parent %d for clkout %d\n",\r\nval, num);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!of_property_read_u32(child, "silabs,drive-strength",\r\n&val)) {\r\nswitch (val) {\r\ncase SI5351_DRIVE_2MA:\r\ncase SI5351_DRIVE_4MA:\r\ncase SI5351_DRIVE_6MA:\r\ncase SI5351_DRIVE_8MA:\r\npdata->clkout[num].drive = val;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev,\r\n"invalid drive strength %d for clkout %d\n",\r\nval, num);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!of_property_read_u32(child, "silabs,disable-state",\r\n&val)) {\r\nswitch (val) {\r\ncase 0:\r\npdata->clkout[num].disable_state =\r\nSI5351_DISABLE_LOW;\r\nbreak;\r\ncase 1:\r\npdata->clkout[num].disable_state =\r\nSI5351_DISABLE_HIGH;\r\nbreak;\r\ncase 2:\r\npdata->clkout[num].disable_state =\r\nSI5351_DISABLE_FLOATING;\r\nbreak;\r\ncase 3:\r\npdata->clkout[num].disable_state =\r\nSI5351_DISABLE_NEVER;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev,\r\n"invalid disable state %d for clkout %d\n",\r\nval, num);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!of_property_read_u32(child, "clock-frequency", &val))\r\npdata->clkout[num].rate = val;\r\npdata->clkout[num].pll_master =\r\nof_property_read_bool(child, "silabs,pll-master");\r\n}\r\nclient->dev.platform_data = pdata;\r\nreturn 0;\r\n}\r\nstatic int si5351_dt_parse(struct i2c_client *client)\r\n{\r\nreturn 0;\r\n}\r\nstatic int si5351_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct si5351_platform_data *pdata;\r\nstruct si5351_driver_data *drvdata;\r\nstruct clk_init_data init;\r\nstruct clk *clk;\r\nconst char *parent_names[4];\r\nu8 num_parents, num_clocks;\r\nint ret, n;\r\nret = si5351_dt_parse(client);\r\nif (ret)\r\nreturn ret;\r\npdata = client->dev.platform_data;\r\nif (!pdata)\r\nreturn -EINVAL;\r\ndrvdata = devm_kzalloc(&client->dev, sizeof(*drvdata), GFP_KERNEL);\r\nif (drvdata == NULL) {\r\ndev_err(&client->dev, "unable to allocate driver data\n");\r\nreturn -ENOMEM;\r\n}\r\ni2c_set_clientdata(client, drvdata);\r\ndrvdata->client = client;\r\ndrvdata->variant = pdata->variant;\r\ndrvdata->pxtal = pdata->clk_xtal;\r\ndrvdata->pclkin = pdata->clk_clkin;\r\ndrvdata->regmap = devm_regmap_init_i2c(client, &si5351_regmap_config);\r\nif (IS_ERR(drvdata->regmap)) {\r\ndev_err(&client->dev, "failed to allocate register map\n");\r\nreturn PTR_ERR(drvdata->regmap);\r\n}\r\nsi5351_reg_write(drvdata, SI5351_INTERRUPT_MASK, 0xf0);\r\nif (drvdata->variant != SI5351_VARIANT_C)\r\nsi5351_set_bits(drvdata, SI5351_PLL_INPUT_SOURCE,\r\nSI5351_PLLA_SOURCE | SI5351_PLLB_SOURCE, 0);\r\nfor (n = 0; n < 2; n++) {\r\nret = _si5351_pll_reparent(drvdata, n, pdata->pll_src[n]);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"failed to reparent pll %d to %d\n",\r\nn, pdata->pll_src[n]);\r\nreturn ret;\r\n}\r\n}\r\nfor (n = 0; n < 8; n++) {\r\nret = _si5351_msynth_reparent(drvdata, n,\r\npdata->clkout[n].multisynth_src);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"failed to reparent multisynth %d to %d\n",\r\nn, pdata->clkout[n].multisynth_src);\r\nreturn ret;\r\n}\r\nret = _si5351_clkout_reparent(drvdata, n,\r\npdata->clkout[n].clkout_src);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"failed to reparent clkout %d to %d\n",\r\nn, pdata->clkout[n].clkout_src);\r\nreturn ret;\r\n}\r\nret = _si5351_clkout_set_drive_strength(drvdata, n,\r\npdata->clkout[n].drive);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"failed set drive strength of clkout%d to %d\n",\r\nn, pdata->clkout[n].drive);\r\nreturn ret;\r\n}\r\nret = _si5351_clkout_set_disable_state(drvdata, n,\r\npdata->clkout[n].disable_state);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"failed set disable state of clkout%d to %d\n",\r\nn, pdata->clkout[n].disable_state);\r\nreturn ret;\r\n}\r\n}\r\nmemset(&init, 0, sizeof(init));\r\ninit.name = si5351_input_names[0];\r\ninit.ops = &si5351_xtal_ops;\r\ninit.flags = 0;\r\nif (!IS_ERR(drvdata->pxtal)) {\r\ndrvdata->pxtal_name = __clk_get_name(drvdata->pxtal);\r\ninit.parent_names = &drvdata->pxtal_name;\r\ninit.num_parents = 1;\r\n}\r\ndrvdata->xtal.init = &init;\r\nclk = devm_clk_register(&client->dev, &drvdata->xtal);\r\nif (IS_ERR(clk)) {\r\ndev_err(&client->dev, "unable to register %s\n", init.name);\r\nreturn PTR_ERR(clk);\r\n}\r\nif (drvdata->variant == SI5351_VARIANT_C) {\r\nmemset(&init, 0, sizeof(init));\r\ninit.name = si5351_input_names[1];\r\ninit.ops = &si5351_clkin_ops;\r\nif (!IS_ERR(drvdata->pclkin)) {\r\ndrvdata->pclkin_name = __clk_get_name(drvdata->pclkin);\r\ninit.parent_names = &drvdata->pclkin_name;\r\ninit.num_parents = 1;\r\n}\r\ndrvdata->clkin.init = &init;\r\nclk = devm_clk_register(&client->dev, &drvdata->clkin);\r\nif (IS_ERR(clk)) {\r\ndev_err(&client->dev, "unable to register %s\n",\r\ninit.name);\r\nreturn PTR_ERR(clk);\r\n}\r\n}\r\nnum_parents = (drvdata->variant == SI5351_VARIANT_C) ? 2 : 1;\r\nparent_names[0] = si5351_input_names[0];\r\nparent_names[1] = si5351_input_names[1];\r\ndrvdata->pll[0].num = 0;\r\ndrvdata->pll[0].drvdata = drvdata;\r\ndrvdata->pll[0].hw.init = &init;\r\nmemset(&init, 0, sizeof(init));\r\ninit.name = si5351_pll_names[0];\r\ninit.ops = &si5351_pll_ops;\r\ninit.flags = 0;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\nclk = devm_clk_register(&client->dev, &drvdata->pll[0].hw);\r\nif (IS_ERR(clk)) {\r\ndev_err(&client->dev, "unable to register %s\n", init.name);\r\nreturn -EINVAL;\r\n}\r\ndrvdata->pll[1].num = 1;\r\ndrvdata->pll[1].drvdata = drvdata;\r\ndrvdata->pll[1].hw.init = &init;\r\nmemset(&init, 0, sizeof(init));\r\nif (drvdata->variant == SI5351_VARIANT_B) {\r\ninit.name = si5351_pll_names[2];\r\ninit.ops = &si5351_vxco_ops;\r\ninit.flags = CLK_IS_ROOT;\r\ninit.parent_names = NULL;\r\ninit.num_parents = 0;\r\n} else {\r\ninit.name = si5351_pll_names[1];\r\ninit.ops = &si5351_pll_ops;\r\ninit.flags = 0;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\n}\r\nclk = devm_clk_register(&client->dev, &drvdata->pll[1].hw);\r\nif (IS_ERR(clk)) {\r\ndev_err(&client->dev, "unable to register %s\n", init.name);\r\nreturn -EINVAL;\r\n}\r\nnum_clocks = (drvdata->variant == SI5351_VARIANT_A3) ? 3 : 8;\r\nparent_names[0] = si5351_pll_names[0];\r\nif (drvdata->variant == SI5351_VARIANT_B)\r\nparent_names[1] = si5351_pll_names[2];\r\nelse\r\nparent_names[1] = si5351_pll_names[1];\r\ndrvdata->msynth = devm_kzalloc(&client->dev, num_clocks *\r\nsizeof(*drvdata->msynth), GFP_KERNEL);\r\ndrvdata->clkout = devm_kzalloc(&client->dev, num_clocks *\r\nsizeof(*drvdata->clkout), GFP_KERNEL);\r\ndrvdata->onecell.clk_num = num_clocks;\r\ndrvdata->onecell.clks = devm_kzalloc(&client->dev,\r\nnum_clocks * sizeof(*drvdata->onecell.clks), GFP_KERNEL);\r\nif (WARN_ON(!drvdata->msynth || !drvdata->clkout ||\r\n!drvdata->onecell.clks))\r\nreturn -ENOMEM;\r\nfor (n = 0; n < num_clocks; n++) {\r\ndrvdata->msynth[n].num = n;\r\ndrvdata->msynth[n].drvdata = drvdata;\r\ndrvdata->msynth[n].hw.init = &init;\r\nmemset(&init, 0, sizeof(init));\r\ninit.name = si5351_msynth_names[n];\r\ninit.ops = &si5351_msynth_ops;\r\ninit.flags = 0;\r\nif (pdata->clkout[n].pll_master)\r\ninit.flags |= CLK_SET_RATE_PARENT;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = 2;\r\nclk = devm_clk_register(&client->dev, &drvdata->msynth[n].hw);\r\nif (IS_ERR(clk)) {\r\ndev_err(&client->dev, "unable to register %s\n",\r\ninit.name);\r\nreturn -EINVAL;\r\n}\r\n}\r\nnum_parents = (drvdata->variant == SI5351_VARIANT_C) ? 4 : 3;\r\nparent_names[2] = si5351_input_names[0];\r\nparent_names[3] = si5351_input_names[1];\r\nfor (n = 0; n < num_clocks; n++) {\r\nparent_names[0] = si5351_msynth_names[n];\r\nparent_names[1] = (n < 4) ? si5351_msynth_names[0] :\r\nsi5351_msynth_names[4];\r\ndrvdata->clkout[n].num = n;\r\ndrvdata->clkout[n].drvdata = drvdata;\r\ndrvdata->clkout[n].hw.init = &init;\r\nmemset(&init, 0, sizeof(init));\r\ninit.name = si5351_clkout_names[n];\r\ninit.ops = &si5351_clkout_ops;\r\ninit.flags = 0;\r\nif (pdata->clkout[n].clkout_src == SI5351_CLKOUT_SRC_MSYNTH_N)\r\ninit.flags |= CLK_SET_RATE_PARENT;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\nclk = devm_clk_register(&client->dev, &drvdata->clkout[n].hw);\r\nif (IS_ERR(clk)) {\r\ndev_err(&client->dev, "unable to register %s\n",\r\ninit.name);\r\nreturn -EINVAL;\r\n}\r\ndrvdata->onecell.clks[n] = clk;\r\nif (pdata->clkout[n].rate != 0) {\r\nint ret;\r\nret = clk_set_rate(clk, pdata->clkout[n].rate);\r\nif (ret != 0) {\r\ndev_err(&client->dev, "Cannot set rate : %d\n",\r\nret);\r\n}\r\n}\r\n}\r\nret = of_clk_add_provider(client->dev.of_node, of_clk_src_onecell_get,\r\n&drvdata->onecell);\r\nif (ret) {\r\ndev_err(&client->dev, "unable to add clk provider\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
