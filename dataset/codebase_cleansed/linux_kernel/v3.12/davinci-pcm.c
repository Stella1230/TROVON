static void print_buf_info(int slot, char *name)\r\n{\r\nstruct edmacc_param p;\r\nif (slot < 0)\r\nreturn;\r\nedma_read_slot(slot, &p);\r\nprintk(KERN_DEBUG "%s: 0x%x, opt=%x, src=%x, a_b_cnt=%x dst=%x\n",\r\nname, slot, p.opt, p.src, p.a_b_cnt, p.dst);\r\nprintk(KERN_DEBUG " src_dst_bidx=%x link_bcntrld=%x src_dst_cidx=%x ccnt=%x\n",\r\np.src_dst_bidx, p.link_bcntrld, p.src_dst_cidx, p.ccnt);\r\n}\r\nstatic void print_buf_info(int slot, char *name)\r\n{\r\n}\r\nstatic void davinci_pcm_period_elapsed(struct snd_pcm_substream *substream)\r\n{\r\nstruct davinci_runtime_data *prtd = substream->runtime->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nprtd->period++;\r\nif (unlikely(prtd->period >= runtime->periods))\r\nprtd->period = 0;\r\n}\r\nstatic void davinci_pcm_period_reset(struct snd_pcm_substream *substream)\r\n{\r\nstruct davinci_runtime_data *prtd = substream->runtime->private_data;\r\nprtd->period = 0;\r\n}\r\nstatic void davinci_pcm_enqueue_dma(struct snd_pcm_substream *substream)\r\n{\r\nstruct davinci_runtime_data *prtd = substream->runtime->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int period_size;\r\nunsigned int dma_offset;\r\ndma_addr_t dma_pos;\r\ndma_addr_t src, dst;\r\nunsigned short src_bidx, dst_bidx;\r\nunsigned short src_cidx, dst_cidx;\r\nunsigned int data_type;\r\nunsigned short acnt;\r\nunsigned int count;\r\nunsigned int fifo_level;\r\nperiod_size = snd_pcm_lib_period_bytes(substream);\r\ndma_offset = prtd->period * period_size;\r\ndma_pos = runtime->dma_addr + dma_offset;\r\nfifo_level = prtd->params->fifo_level;\r\npr_debug("davinci_pcm: audio_set_dma_params_play channel = %d "\r\n"dma_ptr = %x period_size=%x\n", prtd->asp_link[0], dma_pos,\r\nperiod_size);\r\ndata_type = prtd->params->data_type;\r\ncount = period_size / data_type;\r\nif (fifo_level)\r\ncount /= fifo_level;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nsrc = dma_pos;\r\ndst = prtd->params->dma_addr;\r\nsrc_bidx = data_type;\r\ndst_bidx = 4;\r\nsrc_cidx = data_type * fifo_level;\r\ndst_cidx = 0;\r\n} else {\r\nsrc = prtd->params->dma_addr;\r\ndst = dma_pos;\r\nsrc_bidx = 0;\r\ndst_bidx = data_type;\r\nsrc_cidx = 0;\r\ndst_cidx = data_type * fifo_level;\r\n}\r\nacnt = prtd->params->acnt;\r\nedma_set_src(prtd->asp_link[0], src, INCR, W8BIT);\r\nedma_set_dest(prtd->asp_link[0], dst, INCR, W8BIT);\r\nedma_set_src_index(prtd->asp_link[0], src_bidx, src_cidx);\r\nedma_set_dest_index(prtd->asp_link[0], dst_bidx, dst_cidx);\r\nif (!fifo_level)\r\nedma_set_transfer_params(prtd->asp_link[0], acnt, count, 1, 0,\r\nASYNC);\r\nelse\r\nedma_set_transfer_params(prtd->asp_link[0], acnt,\r\nfifo_level,\r\ncount, fifo_level,\r\nABSYNC);\r\n}\r\nstatic void davinci_pcm_dma_irq(unsigned link, u16 ch_status, void *data)\r\n{\r\nstruct snd_pcm_substream *substream = data;\r\nstruct davinci_runtime_data *prtd = substream->runtime->private_data;\r\nprint_buf_info(prtd->ram_channel, "i ram_channel");\r\npr_debug("davinci_pcm: link=%d, status=0x%x\n", link, ch_status);\r\nif (unlikely(ch_status != DMA_COMPLETE))\r\nreturn;\r\nif (snd_pcm_running(substream)) {\r\nspin_lock(&prtd->lock);\r\nif (prtd->ram_channel < 0) {\r\ndavinci_pcm_enqueue_dma(substream);\r\n}\r\ndavinci_pcm_period_elapsed(substream);\r\nspin_unlock(&prtd->lock);\r\nsnd_pcm_period_elapsed(substream);\r\n}\r\n}\r\nstatic int allocate_sram(struct snd_pcm_substream *substream,\r\nstruct gen_pool *sram_pool, unsigned size,\r\nstruct snd_pcm_hardware *ppcm)\r\n{\r\nstruct snd_dma_buffer *buf = &substream->dma_buffer;\r\nstruct snd_dma_buffer *iram_dma = NULL;\r\ndma_addr_t iram_phys = 0;\r\nvoid *iram_virt = NULL;\r\nif (buf->private_data || !size)\r\nreturn 0;\r\nppcm->period_bytes_max = size;\r\niram_virt = (void *)gen_pool_alloc(sram_pool, size);\r\nif (!iram_virt)\r\ngoto exit1;\r\niram_phys = gen_pool_virt_to_phys(sram_pool, (unsigned)iram_virt);\r\niram_dma = kzalloc(sizeof(*iram_dma), GFP_KERNEL);\r\nif (!iram_dma)\r\ngoto exit2;\r\niram_dma->area = iram_virt;\r\niram_dma->addr = iram_phys;\r\nmemset(iram_dma->area, 0, size);\r\niram_dma->bytes = size;\r\nbuf->private_data = iram_dma;\r\nreturn 0;\r\nexit2:\r\nif (iram_virt)\r\ngen_pool_free(sram_pool, (unsigned)iram_virt, size);\r\nexit1:\r\nreturn -ENOMEM;\r\n}\r\nstatic void davinci_free_sram(struct snd_pcm_substream *substream,\r\nstruct snd_dma_buffer *iram_dma)\r\n{\r\nstruct davinci_runtime_data *prtd = substream->runtime->private_data;\r\nstruct gen_pool *sram_pool = prtd->params->sram_pool;\r\ngen_pool_free(sram_pool, (unsigned) iram_dma->area, iram_dma->bytes);\r\n}\r\nstatic int allocate_sram(struct snd_pcm_substream *substream,\r\nstruct gen_pool *sram_pool, unsigned size,\r\nstruct snd_pcm_hardware *ppcm)\r\n{\r\nreturn 0;\r\n}\r\nstatic void davinci_free_sram(struct snd_pcm_substream *substream,\r\nstruct snd_dma_buffer *iram_dma)\r\n{\r\n}\r\nstatic int ping_pong_dma_setup(struct snd_pcm_substream *substream)\r\n{\r\nunsigned short ram_src_cidx, ram_dst_cidx;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct davinci_runtime_data *prtd = runtime->private_data;\r\nstruct snd_dma_buffer *iram_dma =\r\n(struct snd_dma_buffer *)substream->dma_buffer.private_data;\r\nstruct davinci_pcm_dma_params *params = prtd->params;\r\nunsigned int data_type = params->data_type;\r\nunsigned int acnt = params->acnt;\r\nunsigned int ping_size = snd_pcm_lib_period_bytes(substream) >> 1;\r\nunsigned int fifo_level = prtd->params->fifo_level;\r\nunsigned int count;\r\nif ((data_type == 0) || (data_type > 4)) {\r\nprintk(KERN_ERR "%s: data_type=%i\n", __func__, data_type);\r\nreturn -EINVAL;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ndma_addr_t asp_src_pong = iram_dma->addr + ping_size;\r\nram_src_cidx = ping_size;\r\nram_dst_cidx = -ping_size;\r\nedma_set_src(prtd->asp_link[1], asp_src_pong, INCR, W8BIT);\r\nedma_set_src_index(prtd->asp_link[0], data_type,\r\ndata_type * fifo_level);\r\nedma_set_src_index(prtd->asp_link[1], data_type,\r\ndata_type * fifo_level);\r\nedma_set_src(prtd->ram_link, runtime->dma_addr, INCR, W32BIT);\r\n} else {\r\ndma_addr_t asp_dst_pong = iram_dma->addr + ping_size;\r\nram_src_cidx = -ping_size;\r\nram_dst_cidx = ping_size;\r\nedma_set_dest(prtd->asp_link[1], asp_dst_pong, INCR, W8BIT);\r\nedma_set_dest_index(prtd->asp_link[0], data_type,\r\ndata_type * fifo_level);\r\nedma_set_dest_index(prtd->asp_link[1], data_type,\r\ndata_type * fifo_level);\r\nedma_set_dest(prtd->ram_link, runtime->dma_addr, INCR, W32BIT);\r\n}\r\nif (!fifo_level) {\r\ncount = ping_size / data_type;\r\nedma_set_transfer_params(prtd->asp_link[0], acnt, count,\r\n1, 0, ASYNC);\r\nedma_set_transfer_params(prtd->asp_link[1], acnt, count,\r\n1, 0, ASYNC);\r\n} else {\r\ncount = ping_size / (data_type * fifo_level);\r\nedma_set_transfer_params(prtd->asp_link[0], acnt, fifo_level,\r\ncount, fifo_level, ABSYNC);\r\nedma_set_transfer_params(prtd->asp_link[1], acnt, fifo_level,\r\ncount, fifo_level, ABSYNC);\r\n}\r\nedma_set_src_index(prtd->ram_link, ping_size, ram_src_cidx);\r\nedma_set_dest_index(prtd->ram_link, ping_size, ram_dst_cidx);\r\nedma_set_transfer_params(prtd->ram_link, ping_size, 2,\r\nruntime->periods, 2, ASYNC);\r\nedma_read_slot(prtd->asp_link[0], &prtd->asp_params);\r\nedma_read_slot(prtd->ram_link, &prtd->ram_params);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nstruct edmacc_param p_ram;\r\nprtd->ram_params.a_b_cnt = (1 << 16) | (ping_size << 1);\r\nprtd->ram_params.src_dst_bidx = (ping_size << 1);\r\nprtd->ram_params.src_dst_cidx = (ping_size << 1);\r\nprtd->ram_params.ccnt = 1;\r\nedma_read_slot(prtd->ram_link, &p_ram);\r\np_ram.src += (ping_size << 1);\r\np_ram.ccnt -= 1;\r\nedma_write_slot(prtd->ram_link2, &p_ram);\r\nprtd->ram_params.link_bcntrld =\r\nEDMA_CHAN_SLOT(prtd->ram_link2) << 5;\r\n}\r\nreturn 0;\r\n}\r\nstatic int request_ping_pong(struct snd_pcm_substream *substream,\r\nstruct davinci_runtime_data *prtd,\r\nstruct snd_dma_buffer *iram_dma)\r\n{\r\ndma_addr_t asp_src_ping;\r\ndma_addr_t asp_dst_ping;\r\nint ret;\r\nstruct davinci_pcm_dma_params *params = prtd->params;\r\nret = prtd->ram_channel = edma_alloc_channel(EDMA_CHANNEL_ANY,\r\ndavinci_pcm_dma_irq, substream,\r\nprtd->params->ram_chan_q);\r\nif (ret < 0)\r\ngoto exit1;\r\nret = prtd->ram_link = edma_alloc_slot(\r\nEDMA_CTLR(prtd->ram_channel), EDMA_SLOT_ANY);\r\nif (ret < 0)\r\ngoto exit2;\r\nret = prtd->asp_link[1] = edma_alloc_slot(\r\nEDMA_CTLR(prtd->asp_channel), EDMA_SLOT_ANY);\r\nif (ret < 0)\r\ngoto exit3;\r\nprtd->ram_link2 = -1;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nret = prtd->ram_link2 = edma_alloc_slot(\r\nEDMA_CTLR(prtd->ram_channel), EDMA_SLOT_ANY);\r\nif (ret < 0)\r\ngoto exit4;\r\n}\r\nedma_link(prtd->asp_link[0], prtd->asp_link[1]);\r\nedma_link(prtd->asp_link[1], prtd->asp_link[0]);\r\nedma_link(prtd->ram_link, prtd->ram_link);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nasp_src_ping = iram_dma->addr;\r\nasp_dst_ping = params->dma_addr;\r\n} else {\r\nasp_src_ping = params->dma_addr;\r\nasp_dst_ping = iram_dma->addr;\r\n}\r\nedma_set_src(prtd->asp_link[0], asp_src_ping, INCR, W16BIT);\r\nedma_set_dest(prtd->asp_link[0], asp_dst_ping, INCR, W16BIT);\r\nedma_set_src_index(prtd->asp_link[0], 0, 0);\r\nedma_set_dest_index(prtd->asp_link[0], 0, 0);\r\nedma_read_slot(prtd->asp_link[0], &prtd->asp_params);\r\nprtd->asp_params.opt &= ~(TCCMODE | EDMA_TCC(0x3f) | TCINTEN);\r\nprtd->asp_params.opt |= TCCHEN |\r\nEDMA_TCC(prtd->ram_channel & 0x3f);\r\nedma_write_slot(prtd->asp_link[0], &prtd->asp_params);\r\nedma_set_src(prtd->asp_link[1], asp_src_ping, INCR, W16BIT);\r\nedma_set_dest(prtd->asp_link[1], asp_dst_ping, INCR, W16BIT);\r\nedma_set_src_index(prtd->asp_link[1], 0, 0);\r\nedma_set_dest_index(prtd->asp_link[1], 0, 0);\r\nedma_read_slot(prtd->asp_link[1], &prtd->asp_params);\r\nprtd->asp_params.opt &= ~(TCCMODE | EDMA_TCC(0x3f));\r\nprtd->asp_params.opt |= TCINTEN | TCCHEN |\r\nEDMA_TCC(prtd->ram_channel & 0x3f);\r\nedma_write_slot(prtd->asp_link[1], &prtd->asp_params);\r\nedma_set_src(prtd->ram_link, iram_dma->addr, INCR, W32BIT);\r\nedma_set_dest(prtd->ram_link, iram_dma->addr, INCR, W32BIT);\r\npr_debug("%s: audio dma channels/slots in use for ram:%u %u %u,"\r\n"for asp:%u %u %u\n", __func__,\r\nprtd->ram_channel, prtd->ram_link, prtd->ram_link2,\r\nprtd->asp_channel, prtd->asp_link[0],\r\nprtd->asp_link[1]);\r\nreturn 0;\r\nexit4:\r\nedma_free_channel(prtd->asp_link[1]);\r\nprtd->asp_link[1] = -1;\r\nexit3:\r\nedma_free_channel(prtd->ram_link);\r\nprtd->ram_link = -1;\r\nexit2:\r\nedma_free_channel(prtd->ram_channel);\r\nprtd->ram_channel = -1;\r\nexit1:\r\nreturn ret;\r\n}\r\nstatic int davinci_pcm_dma_request(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dma_buffer *iram_dma;\r\nstruct davinci_runtime_data *prtd = substream->runtime->private_data;\r\nstruct davinci_pcm_dma_params *params = prtd->params;\r\nint ret;\r\nif (!params)\r\nreturn -ENODEV;\r\nret = prtd->asp_channel = edma_alloc_channel(params->channel,\r\ndavinci_pcm_dma_irq, substream,\r\nprtd->params->asp_chan_q);\r\nif (ret < 0)\r\ngoto exit1;\r\nret = prtd->asp_link[0] = edma_alloc_slot(\r\nEDMA_CTLR(prtd->asp_channel), EDMA_SLOT_ANY);\r\nif (ret < 0)\r\ngoto exit2;\r\niram_dma = (struct snd_dma_buffer *)substream->dma_buffer.private_data;\r\nif (iram_dma) {\r\nif (request_ping_pong(substream, prtd, iram_dma) == 0)\r\nreturn 0;\r\nprintk(KERN_WARNING "%s: dma channel allocation failed,"\r\n"not using sram\n", __func__);\r\n}\r\nedma_read_slot(prtd->asp_link[0], &prtd->asp_params);\r\nprtd->asp_params.opt |= TCINTEN |\r\nEDMA_TCC(EDMA_CHAN_SLOT(prtd->asp_channel));\r\nprtd->asp_params.link_bcntrld = EDMA_CHAN_SLOT(prtd->asp_link[0]) << 5;\r\nedma_write_slot(prtd->asp_link[0], &prtd->asp_params);\r\nreturn 0;\r\nexit2:\r\nedma_free_channel(prtd->asp_channel);\r\nprtd->asp_channel = -1;\r\nexit1:\r\nreturn ret;\r\n}\r\nstatic int davinci_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct davinci_runtime_data *prtd = substream->runtime->private_data;\r\nint ret = 0;\r\nspin_lock(&prtd->lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nedma_start(prtd->asp_channel);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\r\nprtd->ram_channel >= 0) {\r\nedma_start(prtd->ram_channel);\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nedma_resume(prtd->asp_channel);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nedma_pause(prtd->asp_channel);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock(&prtd->lock);\r\nreturn ret;\r\n}\r\nstatic int davinci_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct davinci_runtime_data *prtd = substream->runtime->private_data;\r\ndavinci_pcm_period_reset(substream);\r\nif (prtd->ram_channel >= 0) {\r\nint ret = ping_pong_dma_setup(substream);\r\nif (ret < 0)\r\nreturn ret;\r\nedma_write_slot(prtd->ram_channel, &prtd->ram_params);\r\nedma_write_slot(prtd->asp_channel, &prtd->asp_params);\r\nprint_buf_info(prtd->ram_channel, "ram_channel");\r\nprint_buf_info(prtd->ram_link, "ram_link");\r\nprint_buf_info(prtd->ram_link2, "ram_link2");\r\nprint_buf_info(prtd->asp_channel, "asp_channel");\r\nprint_buf_info(prtd->asp_link[0], "asp_link[0]");\r\nprint_buf_info(prtd->asp_link[1], "asp_link[1]");\r\ndavinci_pcm_period_elapsed(substream);\r\ndavinci_pcm_period_elapsed(substream);\r\nreturn 0;\r\n}\r\ndavinci_pcm_enqueue_dma(substream);\r\ndavinci_pcm_period_elapsed(substream);\r\nedma_read_slot(prtd->asp_link[0], &prtd->asp_params);\r\nedma_write_slot(prtd->asp_channel, &prtd->asp_params);\r\ndavinci_pcm_enqueue_dma(substream);\r\ndavinci_pcm_period_elapsed(substream);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\ndavinci_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct davinci_runtime_data *prtd = runtime->private_data;\r\nunsigned int offset;\r\nint asp_count;\r\nunsigned int period_size = snd_pcm_lib_period_bytes(substream);\r\nspin_lock(&prtd->lock);\r\nasp_count = prtd->period - 2;\r\nspin_unlock(&prtd->lock);\r\nif (asp_count < 0)\r\nasp_count += runtime->periods;\r\nasp_count *= period_size;\r\noffset = bytes_to_frames(runtime, asp_count);\r\nif (offset >= runtime->buffer_size)\r\noffset = 0;\r\nreturn offset;\r\n}\r\nstatic int davinci_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct davinci_runtime_data *prtd;\r\nstruct snd_pcm_hardware *ppcm;\r\nint ret = 0;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct davinci_pcm_dma_params *pa;\r\nstruct davinci_pcm_dma_params *params;\r\npa = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nif (!pa)\r\nreturn -ENODEV;\r\nparams = &pa[substream->stream];\r\nppcm = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?\r\n&pcm_hardware_playback : &pcm_hardware_capture;\r\nallocate_sram(substream, params->sram_pool, params->sram_size, ppcm);\r\nsnd_soc_set_runtime_hwparams(substream, ppcm);\r\nret = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (ret < 0)\r\nreturn ret;\r\nprtd = kzalloc(sizeof(struct davinci_runtime_data), GFP_KERNEL);\r\nif (prtd == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&prtd->lock);\r\nprtd->params = params;\r\nprtd->asp_channel = -1;\r\nprtd->asp_link[0] = prtd->asp_link[1] = -1;\r\nprtd->ram_channel = -1;\r\nprtd->ram_link = -1;\r\nprtd->ram_link2 = -1;\r\nruntime->private_data = prtd;\r\nret = davinci_pcm_dma_request(substream);\r\nif (ret) {\r\nprintk(KERN_ERR "davinci_pcm: Failed to get dma channels\n");\r\nkfree(prtd);\r\n}\r\nreturn ret;\r\n}\r\nstatic int davinci_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct davinci_runtime_data *prtd = runtime->private_data;\r\nif (prtd->ram_channel >= 0)\r\nedma_stop(prtd->ram_channel);\r\nif (prtd->asp_channel >= 0)\r\nedma_stop(prtd->asp_channel);\r\nif (prtd->asp_link[0] >= 0)\r\nedma_unlink(prtd->asp_link[0]);\r\nif (prtd->asp_link[1] >= 0)\r\nedma_unlink(prtd->asp_link[1]);\r\nif (prtd->ram_link >= 0)\r\nedma_unlink(prtd->ram_link);\r\nif (prtd->asp_link[0] >= 0)\r\nedma_free_slot(prtd->asp_link[0]);\r\nif (prtd->asp_link[1] >= 0)\r\nedma_free_slot(prtd->asp_link[1]);\r\nif (prtd->asp_channel >= 0)\r\nedma_free_channel(prtd->asp_channel);\r\nif (prtd->ram_link >= 0)\r\nedma_free_slot(prtd->ram_link);\r\nif (prtd->ram_link2 >= 0)\r\nedma_free_slot(prtd->ram_link2);\r\nif (prtd->ram_channel >= 0)\r\nedma_free_channel(prtd->ram_channel);\r\nkfree(prtd);\r\nreturn 0;\r\n}\r\nstatic int davinci_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int davinci_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int davinci_pcm_mmap(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nreturn dma_mmap_writecombine(substream->pcm->card->dev, vma,\r\nruntime->dma_area,\r\nruntime->dma_addr,\r\nruntime->dma_bytes);\r\n}\r\nstatic int davinci_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream,\r\nsize_t size)\r\n{\r\nstruct snd_pcm_substream *substream = pcm->streams[stream].substream;\r\nstruct snd_dma_buffer *buf = &substream->dma_buffer;\r\nbuf->dev.type = SNDRV_DMA_TYPE_DEV;\r\nbuf->dev.dev = pcm->card->dev;\r\nbuf->private_data = NULL;\r\nbuf->area = dma_alloc_writecombine(pcm->card->dev, size,\r\n&buf->addr, GFP_KERNEL);\r\npr_debug("davinci_pcm: preallocate_dma_buffer: area=%p, addr=%p, "\r\n"size=%d\n", (void *) buf->area, (void *) buf->addr, size);\r\nif (!buf->area)\r\nreturn -ENOMEM;\r\nbuf->bytes = size;\r\nreturn 0;\r\n}\r\nstatic void davinci_pcm_free(struct snd_pcm *pcm)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_dma_buffer *buf;\r\nint stream;\r\nfor (stream = 0; stream < 2; stream++) {\r\nstruct snd_dma_buffer *iram_dma;\r\nsubstream = pcm->streams[stream].substream;\r\nif (!substream)\r\ncontinue;\r\nbuf = &substream->dma_buffer;\r\nif (!buf->area)\r\ncontinue;\r\ndma_free_writecombine(pcm->card->dev, buf->bytes,\r\nbuf->area, buf->addr);\r\nbuf->area = NULL;\r\niram_dma = buf->private_data;\r\nif (iram_dma) {\r\ndavinci_free_sram(substream, iram_dma);\r\nkfree(iram_dma);\r\n}\r\n}\r\n}\r\nstatic int davinci_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_card *card = rtd->card->snd_card;\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nint ret;\r\nif (!card->dev->dma_mask)\r\ncard->dev->dma_mask = &davinci_pcm_dmamask;\r\nif (!card->dev->coherent_dma_mask)\r\ncard->dev->coherent_dma_mask = DMA_BIT_MASK(32);\r\nif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {\r\nret = davinci_pcm_preallocate_dma_buffer(pcm,\r\nSNDRV_PCM_STREAM_PLAYBACK,\r\npcm_hardware_playback.buffer_bytes_max);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {\r\nret = davinci_pcm_preallocate_dma_buffer(pcm,\r\nSNDRV_PCM_STREAM_CAPTURE,\r\npcm_hardware_capture.buffer_bytes_max);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint davinci_soc_platform_register(struct device *dev)\r\n{\r\nreturn snd_soc_register_platform(dev, &davinci_soc_platform);\r\n}\r\nvoid davinci_soc_platform_unregister(struct device *dev)\r\n{\r\nsnd_soc_unregister_platform(dev);\r\n}
