static struct page *page_chain_del(struct page **head, int n)\r\n{\r\nstruct page *page;\r\nstruct page *tmp;\r\nBUG_ON(!n);\r\nBUG_ON(!head);\r\npage = *head;\r\nif (!page)\r\nreturn NULL;\r\nwhile (page) {\r\ntmp = page_chain_next(page);\r\nif (--n == 0)\r\nbreak;\r\nif (tmp == NULL)\r\nreturn NULL;\r\npage = tmp;\r\n}\r\nset_page_private(page, 0);\r\npage = *head;\r\n*head = tmp;\r\nreturn page;\r\n}\r\nstatic struct page *page_chain_tail(struct page *page, int *len)\r\n{\r\nstruct page *tmp;\r\nint i = 1;\r\nwhile ((tmp = page_chain_next(page)))\r\n++i, page = tmp;\r\nif (len)\r\n*len = i;\r\nreturn page;\r\n}\r\nstatic int page_chain_free(struct page *page)\r\n{\r\nstruct page *tmp;\r\nint i = 0;\r\npage_chain_for_each_safe(page, tmp) {\r\nput_page(page);\r\n++i;\r\n}\r\nreturn i;\r\n}\r\nstatic void page_chain_add(struct page **head,\r\nstruct page *chain_first, struct page *chain_last)\r\n{\r\n#if 1\r\nstruct page *tmp;\r\ntmp = page_chain_tail(chain_first, NULL);\r\nBUG_ON(tmp != chain_last);\r\n#endif\r\nset_page_private(chain_last, (unsigned long)*head);\r\n*head = chain_first;\r\n}\r\nstatic struct page *__drbd_alloc_pages(struct drbd_conf *mdev,\r\nunsigned int number)\r\n{\r\nstruct page *page = NULL;\r\nstruct page *tmp = NULL;\r\nunsigned int i = 0;\r\nif (drbd_pp_vacant >= number) {\r\nspin_lock(&drbd_pp_lock);\r\npage = page_chain_del(&drbd_pp_pool, number);\r\nif (page)\r\ndrbd_pp_vacant -= number;\r\nspin_unlock(&drbd_pp_lock);\r\nif (page)\r\nreturn page;\r\n}\r\nfor (i = 0; i < number; i++) {\r\ntmp = alloc_page(GFP_TRY);\r\nif (!tmp)\r\nbreak;\r\nset_page_private(tmp, (unsigned long)page);\r\npage = tmp;\r\n}\r\nif (i == number)\r\nreturn page;\r\nif (page) {\r\ntmp = page_chain_tail(page, NULL);\r\nspin_lock(&drbd_pp_lock);\r\npage_chain_add(&drbd_pp_pool, page, tmp);\r\ndrbd_pp_vacant += i;\r\nspin_unlock(&drbd_pp_lock);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void reclaim_finished_net_peer_reqs(struct drbd_conf *mdev,\r\nstruct list_head *to_be_freed)\r\n{\r\nstruct drbd_peer_request *peer_req;\r\nstruct list_head *le, *tle;\r\nlist_for_each_safe(le, tle, &mdev->net_ee) {\r\npeer_req = list_entry(le, struct drbd_peer_request, w.list);\r\nif (drbd_peer_req_has_active_page(peer_req))\r\nbreak;\r\nlist_move(le, to_be_freed);\r\n}\r\n}\r\nstatic void drbd_kick_lo_and_reclaim_net(struct drbd_conf *mdev)\r\n{\r\nLIST_HEAD(reclaimed);\r\nstruct drbd_peer_request *peer_req, *t;\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nreclaim_finished_net_peer_reqs(mdev, &reclaimed);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nlist_for_each_entry_safe(peer_req, t, &reclaimed, w.list)\r\ndrbd_free_net_peer_req(mdev, peer_req);\r\n}\r\nstruct page *drbd_alloc_pages(struct drbd_conf *mdev, unsigned int number,\r\nbool retry)\r\n{\r\nstruct page *page = NULL;\r\nstruct net_conf *nc;\r\nDEFINE_WAIT(wait);\r\nint mxb;\r\nrcu_read_lock();\r\nnc = rcu_dereference(mdev->tconn->net_conf);\r\nmxb = nc ? nc->max_buffers : 1000000;\r\nrcu_read_unlock();\r\nif (atomic_read(&mdev->pp_in_use) < mxb)\r\npage = __drbd_alloc_pages(mdev, number);\r\nwhile (page == NULL) {\r\nprepare_to_wait(&drbd_pp_wait, &wait, TASK_INTERRUPTIBLE);\r\ndrbd_kick_lo_and_reclaim_net(mdev);\r\nif (atomic_read(&mdev->pp_in_use) < mxb) {\r\npage = __drbd_alloc_pages(mdev, number);\r\nif (page)\r\nbreak;\r\n}\r\nif (!retry)\r\nbreak;\r\nif (signal_pending(current)) {\r\ndev_warn(DEV, "drbd_alloc_pages interrupted!\n");\r\nbreak;\r\n}\r\nschedule();\r\n}\r\nfinish_wait(&drbd_pp_wait, &wait);\r\nif (page)\r\natomic_add(number, &mdev->pp_in_use);\r\nreturn page;\r\n}\r\nstatic void drbd_free_pages(struct drbd_conf *mdev, struct page *page, int is_net)\r\n{\r\natomic_t *a = is_net ? &mdev->pp_in_use_by_net : &mdev->pp_in_use;\r\nint i;\r\nif (page == NULL)\r\nreturn;\r\nif (drbd_pp_vacant > (DRBD_MAX_BIO_SIZE/PAGE_SIZE) * minor_count)\r\ni = page_chain_free(page);\r\nelse {\r\nstruct page *tmp;\r\ntmp = page_chain_tail(page, &i);\r\nspin_lock(&drbd_pp_lock);\r\npage_chain_add(&drbd_pp_pool, page, tmp);\r\ndrbd_pp_vacant += i;\r\nspin_unlock(&drbd_pp_lock);\r\n}\r\ni = atomic_sub_return(i, a);\r\nif (i < 0)\r\ndev_warn(DEV, "ASSERTION FAILED: %s: %d < 0\n",\r\nis_net ? "pp_in_use_by_net" : "pp_in_use", i);\r\nwake_up(&drbd_pp_wait);\r\n}\r\nstruct drbd_peer_request *\r\ndrbd_alloc_peer_req(struct drbd_conf *mdev, u64 id, sector_t sector,\r\nunsigned int data_size, gfp_t gfp_mask) __must_hold(local)\r\n{\r\nstruct drbd_peer_request *peer_req;\r\nstruct page *page = NULL;\r\nunsigned nr_pages = (data_size + PAGE_SIZE -1) >> PAGE_SHIFT;\r\nif (drbd_insert_fault(mdev, DRBD_FAULT_AL_EE))\r\nreturn NULL;\r\npeer_req = mempool_alloc(drbd_ee_mempool, gfp_mask & ~__GFP_HIGHMEM);\r\nif (!peer_req) {\r\nif (!(gfp_mask & __GFP_NOWARN))\r\ndev_err(DEV, "%s: allocation failed\n", __func__);\r\nreturn NULL;\r\n}\r\nif (data_size) {\r\npage = drbd_alloc_pages(mdev, nr_pages, (gfp_mask & __GFP_WAIT));\r\nif (!page)\r\ngoto fail;\r\n}\r\ndrbd_clear_interval(&peer_req->i);\r\npeer_req->i.size = data_size;\r\npeer_req->i.sector = sector;\r\npeer_req->i.local = false;\r\npeer_req->i.waiting = false;\r\npeer_req->epoch = NULL;\r\npeer_req->w.mdev = mdev;\r\npeer_req->pages = page;\r\natomic_set(&peer_req->pending_bios, 0);\r\npeer_req->flags = 0;\r\npeer_req->block_id = id;\r\nreturn peer_req;\r\nfail:\r\nmempool_free(peer_req, drbd_ee_mempool);\r\nreturn NULL;\r\n}\r\nvoid __drbd_free_peer_req(struct drbd_conf *mdev, struct drbd_peer_request *peer_req,\r\nint is_net)\r\n{\r\nif (peer_req->flags & EE_HAS_DIGEST)\r\nkfree(peer_req->digest);\r\ndrbd_free_pages(mdev, peer_req->pages, is_net);\r\nD_ASSERT(atomic_read(&peer_req->pending_bios) == 0);\r\nD_ASSERT(drbd_interval_empty(&peer_req->i));\r\nmempool_free(peer_req, drbd_ee_mempool);\r\n}\r\nint drbd_free_peer_reqs(struct drbd_conf *mdev, struct list_head *list)\r\n{\r\nLIST_HEAD(work_list);\r\nstruct drbd_peer_request *peer_req, *t;\r\nint count = 0;\r\nint is_net = list == &mdev->net_ee;\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nlist_splice_init(list, &work_list);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nlist_for_each_entry_safe(peer_req, t, &work_list, w.list) {\r\n__drbd_free_peer_req(mdev, peer_req, is_net);\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic int drbd_finish_peer_reqs(struct drbd_conf *mdev)\r\n{\r\nLIST_HEAD(work_list);\r\nLIST_HEAD(reclaimed);\r\nstruct drbd_peer_request *peer_req, *t;\r\nint err = 0;\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nreclaim_finished_net_peer_reqs(mdev, &reclaimed);\r\nlist_splice_init(&mdev->done_ee, &work_list);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nlist_for_each_entry_safe(peer_req, t, &reclaimed, w.list)\r\ndrbd_free_net_peer_req(mdev, peer_req);\r\nlist_for_each_entry_safe(peer_req, t, &work_list, w.list) {\r\nint err2;\r\nerr2 = peer_req->w.cb(&peer_req->w, !!err);\r\nif (!err)\r\nerr = err2;\r\ndrbd_free_peer_req(mdev, peer_req);\r\n}\r\nwake_up(&mdev->ee_wait);\r\nreturn err;\r\n}\r\nstatic void _drbd_wait_ee_list_empty(struct drbd_conf *mdev,\r\nstruct list_head *head)\r\n{\r\nDEFINE_WAIT(wait);\r\nwhile (!list_empty(head)) {\r\nprepare_to_wait(&mdev->ee_wait, &wait, TASK_UNINTERRUPTIBLE);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nio_schedule();\r\nfinish_wait(&mdev->ee_wait, &wait);\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\n}\r\n}\r\nstatic void drbd_wait_ee_list_empty(struct drbd_conf *mdev,\r\nstruct list_head *head)\r\n{\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\n_drbd_wait_ee_list_empty(mdev, head);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\n}\r\nstatic int drbd_recv_short(struct socket *sock, void *buf, size_t size, int flags)\r\n{\r\nmm_segment_t oldfs;\r\nstruct kvec iov = {\r\n.iov_base = buf,\r\n.iov_len = size,\r\n};\r\nstruct msghdr msg = {\r\n.msg_iovlen = 1,\r\n.msg_iov = (struct iovec *)&iov,\r\n.msg_flags = (flags ? flags : MSG_WAITALL | MSG_NOSIGNAL)\r\n};\r\nint rv;\r\noldfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nrv = sock_recvmsg(sock, &msg, size, msg.msg_flags);\r\nset_fs(oldfs);\r\nreturn rv;\r\n}\r\nstatic int drbd_recv(struct drbd_tconn *tconn, void *buf, size_t size)\r\n{\r\nint rv;\r\nrv = drbd_recv_short(tconn->data.socket, buf, size, 0);\r\nif (rv < 0) {\r\nif (rv == -ECONNRESET)\r\nconn_info(tconn, "sock was reset by peer\n");\r\nelse if (rv != -ERESTARTSYS)\r\nconn_err(tconn, "sock_recvmsg returned %d\n", rv);\r\n} else if (rv == 0) {\r\nif (test_bit(DISCONNECT_SENT, &tconn->flags)) {\r\nlong t;\r\nrcu_read_lock();\r\nt = rcu_dereference(tconn->net_conf)->ping_timeo * HZ/10;\r\nrcu_read_unlock();\r\nt = wait_event_timeout(tconn->ping_wait, tconn->cstate < C_WF_REPORT_PARAMS, t);\r\nif (t)\r\ngoto out;\r\n}\r\nconn_info(tconn, "sock was shut down by peer\n");\r\n}\r\nif (rv != size)\r\nconn_request_state(tconn, NS(conn, C_BROKEN_PIPE), CS_HARD);\r\nout:\r\nreturn rv;\r\n}\r\nstatic int drbd_recv_all(struct drbd_tconn *tconn, void *buf, size_t size)\r\n{\r\nint err;\r\nerr = drbd_recv(tconn, buf, size);\r\nif (err != size) {\r\nif (err >= 0)\r\nerr = -EIO;\r\n} else\r\nerr = 0;\r\nreturn err;\r\n}\r\nstatic int drbd_recv_all_warn(struct drbd_tconn *tconn, void *buf, size_t size)\r\n{\r\nint err;\r\nerr = drbd_recv_all(tconn, buf, size);\r\nif (err && !signal_pending(current))\r\nconn_warn(tconn, "short read (expected size %d)\n", (int)size);\r\nreturn err;\r\n}\r\nstatic void drbd_setbufsize(struct socket *sock, unsigned int snd,\r\nunsigned int rcv)\r\n{\r\nif (snd) {\r\nsock->sk->sk_sndbuf = snd;\r\nsock->sk->sk_userlocks |= SOCK_SNDBUF_LOCK;\r\n}\r\nif (rcv) {\r\nsock->sk->sk_rcvbuf = rcv;\r\nsock->sk->sk_userlocks |= SOCK_RCVBUF_LOCK;\r\n}\r\n}\r\nstatic struct socket *drbd_try_connect(struct drbd_tconn *tconn)\r\n{\r\nconst char *what;\r\nstruct socket *sock;\r\nstruct sockaddr_in6 src_in6;\r\nstruct sockaddr_in6 peer_in6;\r\nstruct net_conf *nc;\r\nint err, peer_addr_len, my_addr_len;\r\nint sndbuf_size, rcvbuf_size, connect_int;\r\nint disconnect_on_error = 1;\r\nrcu_read_lock();\r\nnc = rcu_dereference(tconn->net_conf);\r\nif (!nc) {\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nsndbuf_size = nc->sndbuf_size;\r\nrcvbuf_size = nc->rcvbuf_size;\r\nconnect_int = nc->connect_int;\r\nrcu_read_unlock();\r\nmy_addr_len = min_t(int, tconn->my_addr_len, sizeof(src_in6));\r\nmemcpy(&src_in6, &tconn->my_addr, my_addr_len);\r\nif (((struct sockaddr *)&tconn->my_addr)->sa_family == AF_INET6)\r\nsrc_in6.sin6_port = 0;\r\nelse\r\n((struct sockaddr_in *)&src_in6)->sin_port = 0;\r\npeer_addr_len = min_t(int, tconn->peer_addr_len, sizeof(src_in6));\r\nmemcpy(&peer_in6, &tconn->peer_addr, peer_addr_len);\r\nwhat = "sock_create_kern";\r\nerr = sock_create_kern(((struct sockaddr *)&src_in6)->sa_family,\r\nSOCK_STREAM, IPPROTO_TCP, &sock);\r\nif (err < 0) {\r\nsock = NULL;\r\ngoto out;\r\n}\r\nsock->sk->sk_rcvtimeo =\r\nsock->sk->sk_sndtimeo = connect_int * HZ;\r\ndrbd_setbufsize(sock, sndbuf_size, rcvbuf_size);\r\nwhat = "bind before connect";\r\nerr = sock->ops->bind(sock, (struct sockaddr *) &src_in6, my_addr_len);\r\nif (err < 0)\r\ngoto out;\r\ndisconnect_on_error = 0;\r\nwhat = "connect";\r\nerr = sock->ops->connect(sock, (struct sockaddr *) &peer_in6, peer_addr_len, 0);\r\nout:\r\nif (err < 0) {\r\nif (sock) {\r\nsock_release(sock);\r\nsock = NULL;\r\n}\r\nswitch (-err) {\r\ncase ETIMEDOUT: case EAGAIN: case EINPROGRESS:\r\ncase EINTR: case ERESTARTSYS:\r\ncase ECONNREFUSED: case ENETUNREACH:\r\ncase EHOSTDOWN: case EHOSTUNREACH:\r\ndisconnect_on_error = 0;\r\nbreak;\r\ndefault:\r\nconn_err(tconn, "%s failed, err = %d\n", what, err);\r\n}\r\nif (disconnect_on_error)\r\nconn_request_state(tconn, NS(conn, C_DISCONNECTING), CS_HARD);\r\n}\r\nreturn sock;\r\n}\r\nstatic void drbd_incoming_connection(struct sock *sk)\r\n{\r\nstruct accept_wait_data *ad = sk->sk_user_data;\r\nvoid (*state_change)(struct sock *sk);\r\nstate_change = ad->original_sk_state_change;\r\nif (sk->sk_state == TCP_ESTABLISHED)\r\ncomplete(&ad->door_bell);\r\nstate_change(sk);\r\n}\r\nstatic int prepare_listen_socket(struct drbd_tconn *tconn, struct accept_wait_data *ad)\r\n{\r\nint err, sndbuf_size, rcvbuf_size, my_addr_len;\r\nstruct sockaddr_in6 my_addr;\r\nstruct socket *s_listen;\r\nstruct net_conf *nc;\r\nconst char *what;\r\nrcu_read_lock();\r\nnc = rcu_dereference(tconn->net_conf);\r\nif (!nc) {\r\nrcu_read_unlock();\r\nreturn -EIO;\r\n}\r\nsndbuf_size = nc->sndbuf_size;\r\nrcvbuf_size = nc->rcvbuf_size;\r\nrcu_read_unlock();\r\nmy_addr_len = min_t(int, tconn->my_addr_len, sizeof(struct sockaddr_in6));\r\nmemcpy(&my_addr, &tconn->my_addr, my_addr_len);\r\nwhat = "sock_create_kern";\r\nerr = sock_create_kern(((struct sockaddr *)&my_addr)->sa_family,\r\nSOCK_STREAM, IPPROTO_TCP, &s_listen);\r\nif (err) {\r\ns_listen = NULL;\r\ngoto out;\r\n}\r\ns_listen->sk->sk_reuse = SK_CAN_REUSE;\r\ndrbd_setbufsize(s_listen, sndbuf_size, rcvbuf_size);\r\nwhat = "bind before listen";\r\nerr = s_listen->ops->bind(s_listen, (struct sockaddr *)&my_addr, my_addr_len);\r\nif (err < 0)\r\ngoto out;\r\nad->s_listen = s_listen;\r\nwrite_lock_bh(&s_listen->sk->sk_callback_lock);\r\nad->original_sk_state_change = s_listen->sk->sk_state_change;\r\ns_listen->sk->sk_state_change = drbd_incoming_connection;\r\ns_listen->sk->sk_user_data = ad;\r\nwrite_unlock_bh(&s_listen->sk->sk_callback_lock);\r\nwhat = "listen";\r\nerr = s_listen->ops->listen(s_listen, 5);\r\nif (err < 0)\r\ngoto out;\r\nreturn 0;\r\nout:\r\nif (s_listen)\r\nsock_release(s_listen);\r\nif (err < 0) {\r\nif (err != -EAGAIN && err != -EINTR && err != -ERESTARTSYS) {\r\nconn_err(tconn, "%s failed, err = %d\n", what, err);\r\nconn_request_state(tconn, NS(conn, C_DISCONNECTING), CS_HARD);\r\n}\r\n}\r\nreturn -EIO;\r\n}\r\nstatic void unregister_state_change(struct sock *sk, struct accept_wait_data *ad)\r\n{\r\nwrite_lock_bh(&sk->sk_callback_lock);\r\nsk->sk_state_change = ad->original_sk_state_change;\r\nsk->sk_user_data = NULL;\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nstatic struct socket *drbd_wait_for_connect(struct drbd_tconn *tconn, struct accept_wait_data *ad)\r\n{\r\nint timeo, connect_int, err = 0;\r\nstruct socket *s_estab = NULL;\r\nstruct net_conf *nc;\r\nrcu_read_lock();\r\nnc = rcu_dereference(tconn->net_conf);\r\nif (!nc) {\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nconnect_int = nc->connect_int;\r\nrcu_read_unlock();\r\ntimeo = connect_int * HZ;\r\ntimeo += (prandom_u32() & 1) ? timeo / 7 : -timeo / 7;\r\nerr = wait_for_completion_interruptible_timeout(&ad->door_bell, timeo);\r\nif (err <= 0)\r\nreturn NULL;\r\nerr = kernel_accept(ad->s_listen, &s_estab, 0);\r\nif (err < 0) {\r\nif (err != -EAGAIN && err != -EINTR && err != -ERESTARTSYS) {\r\nconn_err(tconn, "accept failed, err = %d\n", err);\r\nconn_request_state(tconn, NS(conn, C_DISCONNECTING), CS_HARD);\r\n}\r\n}\r\nif (s_estab)\r\nunregister_state_change(s_estab->sk, ad);\r\nreturn s_estab;\r\n}\r\nstatic int send_first_packet(struct drbd_tconn *tconn, struct drbd_socket *sock,\r\nenum drbd_packet cmd)\r\n{\r\nif (!conn_prepare_command(tconn, sock))\r\nreturn -EIO;\r\nreturn conn_send_command(tconn, sock, cmd, 0, NULL, 0);\r\n}\r\nstatic int receive_first_packet(struct drbd_tconn *tconn, struct socket *sock)\r\n{\r\nunsigned int header_size = drbd_header_size(tconn);\r\nstruct packet_info pi;\r\nint err;\r\nerr = drbd_recv_short(sock, tconn->data.rbuf, header_size, 0);\r\nif (err != header_size) {\r\nif (err >= 0)\r\nerr = -EIO;\r\nreturn err;\r\n}\r\nerr = decode_header(tconn, tconn->data.rbuf, &pi);\r\nif (err)\r\nreturn err;\r\nreturn pi.cmd;\r\n}\r\nstatic int drbd_socket_okay(struct socket **sock)\r\n{\r\nint rr;\r\nchar tb[4];\r\nif (!*sock)\r\nreturn false;\r\nrr = drbd_recv_short(*sock, tb, 4, MSG_DONTWAIT | MSG_PEEK);\r\nif (rr > 0 || rr == -EAGAIN) {\r\nreturn true;\r\n} else {\r\nsock_release(*sock);\r\n*sock = NULL;\r\nreturn false;\r\n}\r\n}\r\nint drbd_connected(struct drbd_conf *mdev)\r\n{\r\nint err;\r\natomic_set(&mdev->packet_seq, 0);\r\nmdev->peer_seq = 0;\r\nmdev->state_mutex = mdev->tconn->agreed_pro_version < 100 ?\r\n&mdev->tconn->cstate_mutex :\r\n&mdev->own_state_mutex;\r\nerr = drbd_send_sync_param(mdev);\r\nif (!err)\r\nerr = drbd_send_sizes(mdev, 0, 0);\r\nif (!err)\r\nerr = drbd_send_uuids(mdev);\r\nif (!err)\r\nerr = drbd_send_current_state(mdev);\r\nclear_bit(USE_DEGR_WFC_T, &mdev->flags);\r\nclear_bit(RESIZE_PENDING, &mdev->flags);\r\natomic_set(&mdev->ap_in_flight, 0);\r\nmod_timer(&mdev->request_timer, jiffies + HZ);\r\nreturn err;\r\n}\r\nstatic int conn_connect(struct drbd_tconn *tconn)\r\n{\r\nstruct drbd_socket sock, msock;\r\nstruct drbd_conf *mdev;\r\nstruct net_conf *nc;\r\nint vnr, timeout, h, ok;\r\nbool discard_my_data;\r\nenum drbd_state_rv rv;\r\nstruct accept_wait_data ad = {\r\n.tconn = tconn,\r\n.door_bell = COMPLETION_INITIALIZER_ONSTACK(ad.door_bell),\r\n};\r\nclear_bit(DISCONNECT_SENT, &tconn->flags);\r\nif (conn_request_state(tconn, NS(conn, C_WF_CONNECTION), CS_VERBOSE) < SS_SUCCESS)\r\nreturn -2;\r\nmutex_init(&sock.mutex);\r\nsock.sbuf = tconn->data.sbuf;\r\nsock.rbuf = tconn->data.rbuf;\r\nsock.socket = NULL;\r\nmutex_init(&msock.mutex);\r\nmsock.sbuf = tconn->meta.sbuf;\r\nmsock.rbuf = tconn->meta.rbuf;\r\nmsock.socket = NULL;\r\ntconn->agreed_pro_version = 80;\r\nif (prepare_listen_socket(tconn, &ad))\r\nreturn 0;\r\ndo {\r\nstruct socket *s;\r\ns = drbd_try_connect(tconn);\r\nif (s) {\r\nif (!sock.socket) {\r\nsock.socket = s;\r\nsend_first_packet(tconn, &sock, P_INITIAL_DATA);\r\n} else if (!msock.socket) {\r\nclear_bit(RESOLVE_CONFLICTS, &tconn->flags);\r\nmsock.socket = s;\r\nsend_first_packet(tconn, &msock, P_INITIAL_META);\r\n} else {\r\nconn_err(tconn, "Logic error in conn_connect()\n");\r\ngoto out_release_sockets;\r\n}\r\n}\r\nif (sock.socket && msock.socket) {\r\nrcu_read_lock();\r\nnc = rcu_dereference(tconn->net_conf);\r\ntimeout = nc->ping_timeo * HZ / 10;\r\nrcu_read_unlock();\r\nschedule_timeout_interruptible(timeout);\r\nok = drbd_socket_okay(&sock.socket);\r\nok = drbd_socket_okay(&msock.socket) && ok;\r\nif (ok)\r\nbreak;\r\n}\r\nretry:\r\ns = drbd_wait_for_connect(tconn, &ad);\r\nif (s) {\r\nint fp = receive_first_packet(tconn, s);\r\ndrbd_socket_okay(&sock.socket);\r\ndrbd_socket_okay(&msock.socket);\r\nswitch (fp) {\r\ncase P_INITIAL_DATA:\r\nif (sock.socket) {\r\nconn_warn(tconn, "initial packet S crossed\n");\r\nsock_release(sock.socket);\r\nsock.socket = s;\r\ngoto randomize;\r\n}\r\nsock.socket = s;\r\nbreak;\r\ncase P_INITIAL_META:\r\nset_bit(RESOLVE_CONFLICTS, &tconn->flags);\r\nif (msock.socket) {\r\nconn_warn(tconn, "initial packet M crossed\n");\r\nsock_release(msock.socket);\r\nmsock.socket = s;\r\ngoto randomize;\r\n}\r\nmsock.socket = s;\r\nbreak;\r\ndefault:\r\nconn_warn(tconn, "Error receiving initial packet\n");\r\nsock_release(s);\r\nrandomize:\r\nif (prandom_u32() & 1)\r\ngoto retry;\r\n}\r\n}\r\nif (tconn->cstate <= C_DISCONNECTING)\r\ngoto out_release_sockets;\r\nif (signal_pending(current)) {\r\nflush_signals(current);\r\nsmp_rmb();\r\nif (get_t_state(&tconn->receiver) == EXITING)\r\ngoto out_release_sockets;\r\n}\r\nok = drbd_socket_okay(&sock.socket);\r\nok = drbd_socket_okay(&msock.socket) && ok;\r\n} while (!ok);\r\nif (ad.s_listen)\r\nsock_release(ad.s_listen);\r\nsock.socket->sk->sk_reuse = SK_CAN_REUSE;\r\nmsock.socket->sk->sk_reuse = SK_CAN_REUSE;\r\nsock.socket->sk->sk_allocation = GFP_NOIO;\r\nmsock.socket->sk->sk_allocation = GFP_NOIO;\r\nsock.socket->sk->sk_priority = TC_PRIO_INTERACTIVE_BULK;\r\nmsock.socket->sk->sk_priority = TC_PRIO_INTERACTIVE;\r\nrcu_read_lock();\r\nnc = rcu_dereference(tconn->net_conf);\r\nsock.socket->sk->sk_sndtimeo =\r\nsock.socket->sk->sk_rcvtimeo = nc->ping_timeo*4*HZ/10;\r\nmsock.socket->sk->sk_rcvtimeo = nc->ping_int*HZ;\r\ntimeout = nc->timeout * HZ / 10;\r\ndiscard_my_data = nc->discard_my_data;\r\nrcu_read_unlock();\r\nmsock.socket->sk->sk_sndtimeo = timeout;\r\ndrbd_tcp_nodelay(sock.socket);\r\ndrbd_tcp_nodelay(msock.socket);\r\ntconn->data.socket = sock.socket;\r\ntconn->meta.socket = msock.socket;\r\ntconn->last_received = jiffies;\r\nh = drbd_do_features(tconn);\r\nif (h <= 0)\r\nreturn h;\r\nif (tconn->cram_hmac_tfm) {\r\nswitch (drbd_do_auth(tconn)) {\r\ncase -1:\r\nconn_err(tconn, "Authentication of peer failed\n");\r\nreturn -1;\r\ncase 0:\r\nconn_err(tconn, "Authentication of peer failed, trying again.\n");\r\nreturn 0;\r\n}\r\n}\r\ntconn->data.socket->sk->sk_sndtimeo = timeout;\r\ntconn->data.socket->sk->sk_rcvtimeo = MAX_SCHEDULE_TIMEOUT;\r\nif (drbd_send_protocol(tconn) == -EOPNOTSUPP)\r\nreturn -1;\r\nset_bit(STATE_SENT, &tconn->flags);\r\nrcu_read_lock();\r\nidr_for_each_entry(&tconn->volumes, mdev, vnr) {\r\nkref_get(&mdev->kref);\r\nrcu_read_unlock();\r\nmutex_lock(mdev->state_mutex);\r\nmutex_unlock(mdev->state_mutex);\r\nif (discard_my_data)\r\nset_bit(DISCARD_MY_DATA, &mdev->flags);\r\nelse\r\nclear_bit(DISCARD_MY_DATA, &mdev->flags);\r\ndrbd_connected(mdev);\r\nkref_put(&mdev->kref, &drbd_minor_destroy);\r\nrcu_read_lock();\r\n}\r\nrcu_read_unlock();\r\nrv = conn_request_state(tconn, NS(conn, C_WF_REPORT_PARAMS), CS_VERBOSE);\r\nif (rv < SS_SUCCESS || tconn->cstate != C_WF_REPORT_PARAMS) {\r\nclear_bit(STATE_SENT, &tconn->flags);\r\nreturn 0;\r\n}\r\ndrbd_thread_start(&tconn->asender);\r\nmutex_lock(&tconn->conf_update);\r\ntconn->net_conf->discard_my_data = 0;\r\nmutex_unlock(&tconn->conf_update);\r\nreturn h;\r\nout_release_sockets:\r\nif (ad.s_listen)\r\nsock_release(ad.s_listen);\r\nif (sock.socket)\r\nsock_release(sock.socket);\r\nif (msock.socket)\r\nsock_release(msock.socket);\r\nreturn -1;\r\n}\r\nstatic int decode_header(struct drbd_tconn *tconn, void *header, struct packet_info *pi)\r\n{\r\nunsigned int header_size = drbd_header_size(tconn);\r\nif (header_size == sizeof(struct p_header100) &&\r\n*(__be32 *)header == cpu_to_be32(DRBD_MAGIC_100)) {\r\nstruct p_header100 *h = header;\r\nif (h->pad != 0) {\r\nconn_err(tconn, "Header padding is not zero\n");\r\nreturn -EINVAL;\r\n}\r\npi->vnr = be16_to_cpu(h->volume);\r\npi->cmd = be16_to_cpu(h->command);\r\npi->size = be32_to_cpu(h->length);\r\n} else if (header_size == sizeof(struct p_header95) &&\r\n*(__be16 *)header == cpu_to_be16(DRBD_MAGIC_BIG)) {\r\nstruct p_header95 *h = header;\r\npi->cmd = be16_to_cpu(h->command);\r\npi->size = be32_to_cpu(h->length);\r\npi->vnr = 0;\r\n} else if (header_size == sizeof(struct p_header80) &&\r\n*(__be32 *)header == cpu_to_be32(DRBD_MAGIC)) {\r\nstruct p_header80 *h = header;\r\npi->cmd = be16_to_cpu(h->command);\r\npi->size = be16_to_cpu(h->length);\r\npi->vnr = 0;\r\n} else {\r\nconn_err(tconn, "Wrong magic value 0x%08x in protocol version %d\n",\r\nbe32_to_cpu(*(__be32 *)header),\r\ntconn->agreed_pro_version);\r\nreturn -EINVAL;\r\n}\r\npi->data = header + header_size;\r\nreturn 0;\r\n}\r\nstatic int drbd_recv_header(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nvoid *buffer = tconn->data.rbuf;\r\nint err;\r\nerr = drbd_recv_all_warn(tconn, buffer, drbd_header_size(tconn));\r\nif (err)\r\nreturn err;\r\nerr = decode_header(tconn, buffer, pi);\r\ntconn->last_received = jiffies;\r\nreturn err;\r\n}\r\nstatic void drbd_flush(struct drbd_tconn *tconn)\r\n{\r\nint rv;\r\nstruct drbd_conf *mdev;\r\nint vnr;\r\nif (tconn->write_ordering >= WO_bdev_flush) {\r\nrcu_read_lock();\r\nidr_for_each_entry(&tconn->volumes, mdev, vnr) {\r\nif (!get_ldev(mdev))\r\ncontinue;\r\nkref_get(&mdev->kref);\r\nrcu_read_unlock();\r\nrv = blkdev_issue_flush(mdev->ldev->backing_bdev,\r\nGFP_NOIO, NULL);\r\nif (rv) {\r\ndev_info(DEV, "local disk flush failed with status %d\n", rv);\r\ndrbd_bump_write_ordering(tconn, WO_drain_io);\r\n}\r\nput_ldev(mdev);\r\nkref_put(&mdev->kref, &drbd_minor_destroy);\r\nrcu_read_lock();\r\nif (rv)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\n}\r\n}\r\nstatic enum finish_epoch drbd_may_finish_epoch(struct drbd_tconn *tconn,\r\nstruct drbd_epoch *epoch,\r\nenum epoch_event ev)\r\n{\r\nint epoch_size;\r\nstruct drbd_epoch *next_epoch;\r\nenum finish_epoch rv = FE_STILL_LIVE;\r\nspin_lock(&tconn->epoch_lock);\r\ndo {\r\nnext_epoch = NULL;\r\nepoch_size = atomic_read(&epoch->epoch_size);\r\nswitch (ev & ~EV_CLEANUP) {\r\ncase EV_PUT:\r\natomic_dec(&epoch->active);\r\nbreak;\r\ncase EV_GOT_BARRIER_NR:\r\nset_bit(DE_HAVE_BARRIER_NUMBER, &epoch->flags);\r\nbreak;\r\ncase EV_BECAME_LAST:\r\nbreak;\r\n}\r\nif (epoch_size != 0 &&\r\natomic_read(&epoch->active) == 0 &&\r\n(test_bit(DE_HAVE_BARRIER_NUMBER, &epoch->flags) || ev & EV_CLEANUP)) {\r\nif (!(ev & EV_CLEANUP)) {\r\nspin_unlock(&tconn->epoch_lock);\r\ndrbd_send_b_ack(epoch->tconn, epoch->barrier_nr, epoch_size);\r\nspin_lock(&tconn->epoch_lock);\r\n}\r\n#if 0\r\nif (test_bit(DE_HAVE_BARRIER_NUMBER, &epoch->flags))\r\ndec_unacked(epoch->tconn);\r\n#endif\r\nif (tconn->current_epoch != epoch) {\r\nnext_epoch = list_entry(epoch->list.next, struct drbd_epoch, list);\r\nlist_del(&epoch->list);\r\nev = EV_BECAME_LAST | (ev & EV_CLEANUP);\r\ntconn->epochs--;\r\nkfree(epoch);\r\nif (rv == FE_STILL_LIVE)\r\nrv = FE_DESTROYED;\r\n} else {\r\nepoch->flags = 0;\r\natomic_set(&epoch->epoch_size, 0);\r\nif (rv == FE_STILL_LIVE)\r\nrv = FE_RECYCLED;\r\n}\r\n}\r\nif (!next_epoch)\r\nbreak;\r\nepoch = next_epoch;\r\n} while (1);\r\nspin_unlock(&tconn->epoch_lock);\r\nreturn rv;\r\n}\r\nvoid drbd_bump_write_ordering(struct drbd_tconn *tconn, enum write_ordering_e wo)\r\n{\r\nstruct disk_conf *dc;\r\nstruct drbd_conf *mdev;\r\nenum write_ordering_e pwo;\r\nint vnr;\r\nstatic char *write_ordering_str[] = {\r\n[WO_none] = "none",\r\n[WO_drain_io] = "drain",\r\n[WO_bdev_flush] = "flush",\r\n};\r\npwo = tconn->write_ordering;\r\nwo = min(pwo, wo);\r\nrcu_read_lock();\r\nidr_for_each_entry(&tconn->volumes, mdev, vnr) {\r\nif (!get_ldev_if_state(mdev, D_ATTACHING))\r\ncontinue;\r\ndc = rcu_dereference(mdev->ldev->disk_conf);\r\nif (wo == WO_bdev_flush && !dc->disk_flushes)\r\nwo = WO_drain_io;\r\nif (wo == WO_drain_io && !dc->disk_drain)\r\nwo = WO_none;\r\nput_ldev(mdev);\r\n}\r\nrcu_read_unlock();\r\ntconn->write_ordering = wo;\r\nif (pwo != tconn->write_ordering || wo == WO_bdev_flush)\r\nconn_info(tconn, "Method to ensure write ordering: %s\n", write_ordering_str[tconn->write_ordering]);\r\n}\r\nint drbd_submit_peer_request(struct drbd_conf *mdev,\r\nstruct drbd_peer_request *peer_req,\r\nconst unsigned rw, const int fault_type)\r\n{\r\nstruct bio *bios = NULL;\r\nstruct bio *bio;\r\nstruct page *page = peer_req->pages;\r\nsector_t sector = peer_req->i.sector;\r\nunsigned ds = peer_req->i.size;\r\nunsigned n_bios = 0;\r\nunsigned nr_pages = (ds + PAGE_SIZE -1) >> PAGE_SHIFT;\r\nint err = -ENOMEM;\r\nnext_bio:\r\nbio = bio_alloc(GFP_NOIO, nr_pages);\r\nif (!bio) {\r\ndev_err(DEV, "submit_ee: Allocation of a bio failed\n");\r\ngoto fail;\r\n}\r\nbio->bi_sector = sector;\r\nbio->bi_bdev = mdev->ldev->backing_bdev;\r\nbio->bi_rw = rw;\r\nbio->bi_private = peer_req;\r\nbio->bi_end_io = drbd_peer_request_endio;\r\nbio->bi_next = bios;\r\nbios = bio;\r\n++n_bios;\r\npage_chain_for_each(page) {\r\nunsigned len = min_t(unsigned, ds, PAGE_SIZE);\r\nif (!bio_add_page(bio, page, len, 0)) {\r\nif (bio->bi_vcnt == 0) {\r\ndev_err(DEV,\r\n"bio_add_page failed for len=%u, "\r\n"bi_vcnt=0 (bi_sector=%llu)\n",\r\nlen, (unsigned long long)bio->bi_sector);\r\nerr = -ENOSPC;\r\ngoto fail;\r\n}\r\ngoto next_bio;\r\n}\r\nds -= len;\r\nsector += len >> 9;\r\n--nr_pages;\r\n}\r\nD_ASSERT(page == NULL);\r\nD_ASSERT(ds == 0);\r\natomic_set(&peer_req->pending_bios, n_bios);\r\ndo {\r\nbio = bios;\r\nbios = bios->bi_next;\r\nbio->bi_next = NULL;\r\ndrbd_generic_make_request(mdev, fault_type, bio);\r\n} while (bios);\r\nreturn 0;\r\nfail:\r\nwhile (bios) {\r\nbio = bios;\r\nbios = bios->bi_next;\r\nbio_put(bio);\r\n}\r\nreturn err;\r\n}\r\nstatic void drbd_remove_epoch_entry_interval(struct drbd_conf *mdev,\r\nstruct drbd_peer_request *peer_req)\r\n{\r\nstruct drbd_interval *i = &peer_req->i;\r\ndrbd_remove_interval(&mdev->write_requests, i);\r\ndrbd_clear_interval(i);\r\nif (i->waiting)\r\nwake_up(&mdev->misc_wait);\r\n}\r\nvoid conn_wait_active_ee_empty(struct drbd_tconn *tconn)\r\n{\r\nstruct drbd_conf *mdev;\r\nint vnr;\r\nrcu_read_lock();\r\nidr_for_each_entry(&tconn->volumes, mdev, vnr) {\r\nkref_get(&mdev->kref);\r\nrcu_read_unlock();\r\ndrbd_wait_ee_list_empty(mdev, &mdev->active_ee);\r\nkref_put(&mdev->kref, &drbd_minor_destroy);\r\nrcu_read_lock();\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic int receive_Barrier(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nint rv;\r\nstruct p_barrier *p = pi->data;\r\nstruct drbd_epoch *epoch;\r\ntconn->current_epoch->barrier_nr = p->barrier;\r\ntconn->current_epoch->tconn = tconn;\r\nrv = drbd_may_finish_epoch(tconn, tconn->current_epoch, EV_GOT_BARRIER_NR);\r\nswitch (tconn->write_ordering) {\r\ncase WO_none:\r\nif (rv == FE_RECYCLED)\r\nreturn 0;\r\nepoch = kmalloc(sizeof(struct drbd_epoch), GFP_NOIO);\r\nif (epoch)\r\nbreak;\r\nelse\r\nconn_warn(tconn, "Allocation of an epoch failed, slowing down\n");\r\ncase WO_bdev_flush:\r\ncase WO_drain_io:\r\nconn_wait_active_ee_empty(tconn);\r\ndrbd_flush(tconn);\r\nif (atomic_read(&tconn->current_epoch->epoch_size)) {\r\nepoch = kmalloc(sizeof(struct drbd_epoch), GFP_NOIO);\r\nif (epoch)\r\nbreak;\r\n}\r\nreturn 0;\r\ndefault:\r\nconn_err(tconn, "Strangeness in tconn->write_ordering %d\n", tconn->write_ordering);\r\nreturn -EIO;\r\n}\r\nepoch->flags = 0;\r\natomic_set(&epoch->epoch_size, 0);\r\natomic_set(&epoch->active, 0);\r\nspin_lock(&tconn->epoch_lock);\r\nif (atomic_read(&tconn->current_epoch->epoch_size)) {\r\nlist_add(&epoch->list, &tconn->current_epoch->list);\r\ntconn->current_epoch = epoch;\r\ntconn->epochs++;\r\n} else {\r\nkfree(epoch);\r\n}\r\nspin_unlock(&tconn->epoch_lock);\r\nreturn 0;\r\n}\r\nstatic struct drbd_peer_request *\r\nread_in_block(struct drbd_conf *mdev, u64 id, sector_t sector,\r\nint data_size) __must_hold(local)\r\n{\r\nconst sector_t capacity = drbd_get_capacity(mdev->this_bdev);\r\nstruct drbd_peer_request *peer_req;\r\nstruct page *page;\r\nint dgs, ds, err;\r\nvoid *dig_in = mdev->tconn->int_dig_in;\r\nvoid *dig_vv = mdev->tconn->int_dig_vv;\r\nunsigned long *data;\r\ndgs = 0;\r\nif (mdev->tconn->peer_integrity_tfm) {\r\ndgs = crypto_hash_digestsize(mdev->tconn->peer_integrity_tfm);\r\nerr = drbd_recv_all_warn(mdev->tconn, dig_in, dgs);\r\nif (err)\r\nreturn NULL;\r\ndata_size -= dgs;\r\n}\r\nif (!expect(IS_ALIGNED(data_size, 512)))\r\nreturn NULL;\r\nif (!expect(data_size <= DRBD_MAX_BIO_SIZE))\r\nreturn NULL;\r\nif (sector + (data_size>>9) > capacity) {\r\ndev_err(DEV, "request from peer beyond end of local disk: "\r\n"capacity: %llus < sector: %llus + size: %u\n",\r\n(unsigned long long)capacity,\r\n(unsigned long long)sector, data_size);\r\nreturn NULL;\r\n}\r\npeer_req = drbd_alloc_peer_req(mdev, id, sector, data_size, GFP_NOIO);\r\nif (!peer_req)\r\nreturn NULL;\r\nif (!data_size)\r\nreturn peer_req;\r\nds = data_size;\r\npage = peer_req->pages;\r\npage_chain_for_each(page) {\r\nunsigned len = min_t(int, ds, PAGE_SIZE);\r\ndata = kmap(page);\r\nerr = drbd_recv_all_warn(mdev->tconn, data, len);\r\nif (drbd_insert_fault(mdev, DRBD_FAULT_RECEIVE)) {\r\ndev_err(DEV, "Fault injection: Corrupting data on receive\n");\r\ndata[0] = data[0] ^ (unsigned long)-1;\r\n}\r\nkunmap(page);\r\nif (err) {\r\ndrbd_free_peer_req(mdev, peer_req);\r\nreturn NULL;\r\n}\r\nds -= len;\r\n}\r\nif (dgs) {\r\ndrbd_csum_ee(mdev, mdev->tconn->peer_integrity_tfm, peer_req, dig_vv);\r\nif (memcmp(dig_in, dig_vv, dgs)) {\r\ndev_err(DEV, "Digest integrity check FAILED: %llus +%u\n",\r\n(unsigned long long)sector, data_size);\r\ndrbd_free_peer_req(mdev, peer_req);\r\nreturn NULL;\r\n}\r\n}\r\nmdev->recv_cnt += data_size>>9;\r\nreturn peer_req;\r\n}\r\nstatic int drbd_drain_block(struct drbd_conf *mdev, int data_size)\r\n{\r\nstruct page *page;\r\nint err = 0;\r\nvoid *data;\r\nif (!data_size)\r\nreturn 0;\r\npage = drbd_alloc_pages(mdev, 1, 1);\r\ndata = kmap(page);\r\nwhile (data_size) {\r\nunsigned int len = min_t(int, data_size, PAGE_SIZE);\r\nerr = drbd_recv_all_warn(mdev->tconn, data, len);\r\nif (err)\r\nbreak;\r\ndata_size -= len;\r\n}\r\nkunmap(page);\r\ndrbd_free_pages(mdev, page, 0);\r\nreturn err;\r\n}\r\nstatic int recv_dless_read(struct drbd_conf *mdev, struct drbd_request *req,\r\nsector_t sector, int data_size)\r\n{\r\nstruct bio_vec *bvec;\r\nstruct bio *bio;\r\nint dgs, err, i, expect;\r\nvoid *dig_in = mdev->tconn->int_dig_in;\r\nvoid *dig_vv = mdev->tconn->int_dig_vv;\r\ndgs = 0;\r\nif (mdev->tconn->peer_integrity_tfm) {\r\ndgs = crypto_hash_digestsize(mdev->tconn->peer_integrity_tfm);\r\nerr = drbd_recv_all_warn(mdev->tconn, dig_in, dgs);\r\nif (err)\r\nreturn err;\r\ndata_size -= dgs;\r\n}\r\nmdev->recv_cnt += data_size>>9;\r\nbio = req->master_bio;\r\nD_ASSERT(sector == bio->bi_sector);\r\nbio_for_each_segment(bvec, bio, i) {\r\nvoid *mapped = kmap(bvec->bv_page) + bvec->bv_offset;\r\nexpect = min_t(int, data_size, bvec->bv_len);\r\nerr = drbd_recv_all_warn(mdev->tconn, mapped, expect);\r\nkunmap(bvec->bv_page);\r\nif (err)\r\nreturn err;\r\ndata_size -= expect;\r\n}\r\nif (dgs) {\r\ndrbd_csum_bio(mdev, mdev->tconn->peer_integrity_tfm, bio, dig_vv);\r\nif (memcmp(dig_in, dig_vv, dgs)) {\r\ndev_err(DEV, "Digest integrity check FAILED. Broken NICs?\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nD_ASSERT(data_size == 0);\r\nreturn 0;\r\n}\r\nstatic int e_end_resync_block(struct drbd_work *w, int unused)\r\n{\r\nstruct drbd_peer_request *peer_req =\r\ncontainer_of(w, struct drbd_peer_request, w);\r\nstruct drbd_conf *mdev = w->mdev;\r\nsector_t sector = peer_req->i.sector;\r\nint err;\r\nD_ASSERT(drbd_interval_empty(&peer_req->i));\r\nif (likely((peer_req->flags & EE_WAS_ERROR) == 0)) {\r\ndrbd_set_in_sync(mdev, sector, peer_req->i.size);\r\nerr = drbd_send_ack(mdev, P_RS_WRITE_ACK, peer_req);\r\n} else {\r\ndrbd_rs_failed_io(mdev, sector, peer_req->i.size);\r\nerr = drbd_send_ack(mdev, P_NEG_ACK, peer_req);\r\n}\r\ndec_unacked(mdev);\r\nreturn err;\r\n}\r\nstatic int recv_resync_read(struct drbd_conf *mdev, sector_t sector, int data_size) __releases(local)\r\n{\r\nstruct drbd_peer_request *peer_req;\r\npeer_req = read_in_block(mdev, ID_SYNCER, sector, data_size);\r\nif (!peer_req)\r\ngoto fail;\r\ndec_rs_pending(mdev);\r\ninc_unacked(mdev);\r\npeer_req->w.cb = e_end_resync_block;\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nlist_add(&peer_req->w.list, &mdev->sync_ee);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\natomic_add(data_size >> 9, &mdev->rs_sect_ev);\r\nif (drbd_submit_peer_request(mdev, peer_req, WRITE, DRBD_FAULT_RS_WR) == 0)\r\nreturn 0;\r\ndev_err(DEV, "submit failed, triggering re-connect\n");\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nlist_del(&peer_req->w.list);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\ndrbd_free_peer_req(mdev, peer_req);\r\nfail:\r\nput_ldev(mdev);\r\nreturn -EIO;\r\n}\r\nstatic struct drbd_request *\r\nfind_request(struct drbd_conf *mdev, struct rb_root *root, u64 id,\r\nsector_t sector, bool missing_ok, const char *func)\r\n{\r\nstruct drbd_request *req;\r\nreq = (struct drbd_request *)(unsigned long)id;\r\nif (drbd_contains_interval(root, sector, &req->i) && req->i.local)\r\nreturn req;\r\nif (!missing_ok) {\r\ndev_err(DEV, "%s: failed to find request 0x%lx, sector %llus\n", func,\r\n(unsigned long)id, (unsigned long long)sector);\r\n}\r\nreturn NULL;\r\n}\r\nstatic int receive_DataReply(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct drbd_conf *mdev;\r\nstruct drbd_request *req;\r\nsector_t sector;\r\nint err;\r\nstruct p_data *p = pi->data;\r\nmdev = vnr_to_mdev(tconn, pi->vnr);\r\nif (!mdev)\r\nreturn -EIO;\r\nsector = be64_to_cpu(p->sector);\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nreq = find_request(mdev, &mdev->read_requests, p->block_id, sector, false, __func__);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nif (unlikely(!req))\r\nreturn -EIO;\r\nerr = recv_dless_read(mdev, req, sector, pi->size);\r\nif (!err)\r\nreq_mod(req, DATA_RECEIVED);\r\nreturn err;\r\n}\r\nstatic int receive_RSDataReply(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct drbd_conf *mdev;\r\nsector_t sector;\r\nint err;\r\nstruct p_data *p = pi->data;\r\nmdev = vnr_to_mdev(tconn, pi->vnr);\r\nif (!mdev)\r\nreturn -EIO;\r\nsector = be64_to_cpu(p->sector);\r\nD_ASSERT(p->block_id == ID_SYNCER);\r\nif (get_ldev(mdev)) {\r\nerr = recv_resync_read(mdev, sector, pi->size);\r\n} else {\r\nif (__ratelimit(&drbd_ratelimit_state))\r\ndev_err(DEV, "Can not write resync data to local disk.\n");\r\nerr = drbd_drain_block(mdev, pi->size);\r\ndrbd_send_ack_dp(mdev, P_NEG_ACK, p, pi->size);\r\n}\r\natomic_add(pi->size >> 9, &mdev->rs_sect_in);\r\nreturn err;\r\n}\r\nstatic void restart_conflicting_writes(struct drbd_conf *mdev,\r\nsector_t sector, int size)\r\n{\r\nstruct drbd_interval *i;\r\nstruct drbd_request *req;\r\ndrbd_for_each_overlap(i, &mdev->write_requests, sector, size) {\r\nif (!i->local)\r\ncontinue;\r\nreq = container_of(i, struct drbd_request, i);\r\nif (req->rq_state & RQ_LOCAL_PENDING ||\r\n!(req->rq_state & RQ_POSTPONED))\r\ncontinue;\r\n__req_mod(req, CONFLICT_RESOLVED, NULL);\r\n}\r\n}\r\nstatic int e_end_block(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_peer_request *peer_req =\r\ncontainer_of(w, struct drbd_peer_request, w);\r\nstruct drbd_conf *mdev = w->mdev;\r\nsector_t sector = peer_req->i.sector;\r\nint err = 0, pcmd;\r\nif (peer_req->flags & EE_SEND_WRITE_ACK) {\r\nif (likely((peer_req->flags & EE_WAS_ERROR) == 0)) {\r\npcmd = (mdev->state.conn >= C_SYNC_SOURCE &&\r\nmdev->state.conn <= C_PAUSED_SYNC_T &&\r\npeer_req->flags & EE_MAY_SET_IN_SYNC) ?\r\nP_RS_WRITE_ACK : P_WRITE_ACK;\r\nerr = drbd_send_ack(mdev, pcmd, peer_req);\r\nif (pcmd == P_RS_WRITE_ACK)\r\ndrbd_set_in_sync(mdev, sector, peer_req->i.size);\r\n} else {\r\nerr = drbd_send_ack(mdev, P_NEG_ACK, peer_req);\r\n}\r\ndec_unacked(mdev);\r\n}\r\nif (peer_req->flags & EE_IN_INTERVAL_TREE) {\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nD_ASSERT(!drbd_interval_empty(&peer_req->i));\r\ndrbd_remove_epoch_entry_interval(mdev, peer_req);\r\nif (peer_req->flags & EE_RESTART_REQUESTS)\r\nrestart_conflicting_writes(mdev, sector, peer_req->i.size);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\n} else\r\nD_ASSERT(drbd_interval_empty(&peer_req->i));\r\ndrbd_may_finish_epoch(mdev->tconn, peer_req->epoch, EV_PUT + (cancel ? EV_CLEANUP : 0));\r\nreturn err;\r\n}\r\nstatic int e_send_ack(struct drbd_work *w, enum drbd_packet ack)\r\n{\r\nstruct drbd_conf *mdev = w->mdev;\r\nstruct drbd_peer_request *peer_req =\r\ncontainer_of(w, struct drbd_peer_request, w);\r\nint err;\r\nerr = drbd_send_ack(mdev, ack, peer_req);\r\ndec_unacked(mdev);\r\nreturn err;\r\n}\r\nstatic int e_send_superseded(struct drbd_work *w, int unused)\r\n{\r\nreturn e_send_ack(w, P_SUPERSEDED);\r\n}\r\nstatic int e_send_retry_write(struct drbd_work *w, int unused)\r\n{\r\nstruct drbd_tconn *tconn = w->mdev->tconn;\r\nreturn e_send_ack(w, tconn->agreed_pro_version >= 100 ?\r\nP_RETRY_WRITE : P_SUPERSEDED);\r\n}\r\nstatic bool seq_greater(u32 a, u32 b)\r\n{\r\nreturn (s32)a - (s32)b > 0;\r\n}\r\nstatic u32 seq_max(u32 a, u32 b)\r\n{\r\nreturn seq_greater(a, b) ? a : b;\r\n}\r\nstatic bool need_peer_seq(struct drbd_conf *mdev)\r\n{\r\nstruct drbd_tconn *tconn = mdev->tconn;\r\nint tp;\r\nrcu_read_lock();\r\ntp = rcu_dereference(mdev->tconn->net_conf)->two_primaries;\r\nrcu_read_unlock();\r\nreturn tp && test_bit(RESOLVE_CONFLICTS, &tconn->flags);\r\n}\r\nstatic void update_peer_seq(struct drbd_conf *mdev, unsigned int peer_seq)\r\n{\r\nunsigned int newest_peer_seq;\r\nif (need_peer_seq(mdev)) {\r\nspin_lock(&mdev->peer_seq_lock);\r\nnewest_peer_seq = seq_max(mdev->peer_seq, peer_seq);\r\nmdev->peer_seq = newest_peer_seq;\r\nspin_unlock(&mdev->peer_seq_lock);\r\nif (peer_seq == newest_peer_seq)\r\nwake_up(&mdev->seq_wait);\r\n}\r\n}\r\nstatic inline int overlaps(sector_t s1, int l1, sector_t s2, int l2)\r\n{\r\nreturn !((s1 + (l1>>9) <= s2) || (s1 >= s2 + (l2>>9)));\r\n}\r\nstatic bool overlapping_resync_write(struct drbd_conf *mdev, struct drbd_peer_request *peer_req)\r\n{\r\nstruct drbd_peer_request *rs_req;\r\nbool rv = 0;\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nlist_for_each_entry(rs_req, &mdev->sync_ee, w.list) {\r\nif (overlaps(peer_req->i.sector, peer_req->i.size,\r\nrs_req->i.sector, rs_req->i.size)) {\r\nrv = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nreturn rv;\r\n}\r\nstatic int wait_for_and_update_peer_seq(struct drbd_conf *mdev, const u32 peer_seq)\r\n{\r\nDEFINE_WAIT(wait);\r\nlong timeout;\r\nint ret;\r\nif (!need_peer_seq(mdev))\r\nreturn 0;\r\nspin_lock(&mdev->peer_seq_lock);\r\nfor (;;) {\r\nif (!seq_greater(peer_seq - 1, mdev->peer_seq)) {\r\nmdev->peer_seq = seq_max(mdev->peer_seq, peer_seq);\r\nret = 0;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\nprepare_to_wait(&mdev->seq_wait, &wait, TASK_INTERRUPTIBLE);\r\nspin_unlock(&mdev->peer_seq_lock);\r\nrcu_read_lock();\r\ntimeout = rcu_dereference(mdev->tconn->net_conf)->ping_timeo*HZ/10;\r\nrcu_read_unlock();\r\ntimeout = schedule_timeout(timeout);\r\nspin_lock(&mdev->peer_seq_lock);\r\nif (!timeout) {\r\nret = -ETIMEDOUT;\r\ndev_err(DEV, "Timed out waiting for missing ack packets; disconnecting\n");\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&mdev->peer_seq_lock);\r\nfinish_wait(&mdev->seq_wait, &wait);\r\nreturn ret;\r\n}\r\nstatic unsigned long wire_flags_to_bio(struct drbd_conf *mdev, u32 dpf)\r\n{\r\nreturn (dpf & DP_RW_SYNC ? REQ_SYNC : 0) |\r\n(dpf & DP_FUA ? REQ_FUA : 0) |\r\n(dpf & DP_FLUSH ? REQ_FLUSH : 0) |\r\n(dpf & DP_DISCARD ? REQ_DISCARD : 0);\r\n}\r\nstatic void fail_postponed_requests(struct drbd_conf *mdev, sector_t sector,\r\nunsigned int size)\r\n{\r\nstruct drbd_interval *i;\r\nrepeat:\r\ndrbd_for_each_overlap(i, &mdev->write_requests, sector, size) {\r\nstruct drbd_request *req;\r\nstruct bio_and_error m;\r\nif (!i->local)\r\ncontinue;\r\nreq = container_of(i, struct drbd_request, i);\r\nif (!(req->rq_state & RQ_POSTPONED))\r\ncontinue;\r\nreq->rq_state &= ~RQ_POSTPONED;\r\n__req_mod(req, NEG_ACKED, &m);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nif (m.bio)\r\ncomplete_master_bio(mdev, &m);\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\ngoto repeat;\r\n}\r\n}\r\nstatic int handle_write_conflicts(struct drbd_conf *mdev,\r\nstruct drbd_peer_request *peer_req)\r\n{\r\nstruct drbd_tconn *tconn = mdev->tconn;\r\nbool resolve_conflicts = test_bit(RESOLVE_CONFLICTS, &tconn->flags);\r\nsector_t sector = peer_req->i.sector;\r\nconst unsigned int size = peer_req->i.size;\r\nstruct drbd_interval *i;\r\nbool equal;\r\nint err;\r\ndrbd_insert_interval(&mdev->write_requests, &peer_req->i);\r\nrepeat:\r\ndrbd_for_each_overlap(i, &mdev->write_requests, sector, size) {\r\nif (i == &peer_req->i)\r\ncontinue;\r\nif (!i->local) {\r\nerr = drbd_wait_misc(mdev, i);\r\nif (err)\r\ngoto out;\r\ngoto repeat;\r\n}\r\nequal = i->sector == sector && i->size == size;\r\nif (resolve_conflicts) {\r\nbool superseded = i->sector <= sector && i->sector +\r\n(i->size >> 9) >= sector + (size >> 9);\r\nif (!equal)\r\ndev_alert(DEV, "Concurrent writes detected: "\r\n"local=%llus +%u, remote=%llus +%u, "\r\n"assuming %s came first\n",\r\n(unsigned long long)i->sector, i->size,\r\n(unsigned long long)sector, size,\r\nsuperseded ? "local" : "remote");\r\ninc_unacked(mdev);\r\npeer_req->w.cb = superseded ? e_send_superseded :\r\ne_send_retry_write;\r\nlist_add_tail(&peer_req->w.list, &mdev->done_ee);\r\nwake_asender(mdev->tconn);\r\nerr = -ENOENT;\r\ngoto out;\r\n} else {\r\nstruct drbd_request *req =\r\ncontainer_of(i, struct drbd_request, i);\r\nif (!equal)\r\ndev_alert(DEV, "Concurrent writes detected: "\r\n"local=%llus +%u, remote=%llus +%u\n",\r\n(unsigned long long)i->sector, i->size,\r\n(unsigned long long)sector, size);\r\nif (req->rq_state & RQ_LOCAL_PENDING ||\r\n!(req->rq_state & RQ_POSTPONED)) {\r\nerr = drbd_wait_misc(mdev, &req->i);\r\nif (err) {\r\n_conn_request_state(mdev->tconn,\r\nNS(conn, C_TIMEOUT),\r\nCS_HARD);\r\nfail_postponed_requests(mdev, sector, size);\r\ngoto out;\r\n}\r\ngoto repeat;\r\n}\r\npeer_req->flags |= EE_RESTART_REQUESTS;\r\n}\r\n}\r\nerr = 0;\r\nout:\r\nif (err)\r\ndrbd_remove_epoch_entry_interval(mdev, peer_req);\r\nreturn err;\r\n}\r\nstatic int receive_Data(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct drbd_conf *mdev;\r\nsector_t sector;\r\nstruct drbd_peer_request *peer_req;\r\nstruct p_data *p = pi->data;\r\nu32 peer_seq = be32_to_cpu(p->seq_num);\r\nint rw = WRITE;\r\nu32 dp_flags;\r\nint err, tp;\r\nmdev = vnr_to_mdev(tconn, pi->vnr);\r\nif (!mdev)\r\nreturn -EIO;\r\nif (!get_ldev(mdev)) {\r\nint err2;\r\nerr = wait_for_and_update_peer_seq(mdev, peer_seq);\r\ndrbd_send_ack_dp(mdev, P_NEG_ACK, p, pi->size);\r\natomic_inc(&tconn->current_epoch->epoch_size);\r\nerr2 = drbd_drain_block(mdev, pi->size);\r\nif (!err)\r\nerr = err2;\r\nreturn err;\r\n}\r\nsector = be64_to_cpu(p->sector);\r\npeer_req = read_in_block(mdev, p->block_id, sector, pi->size);\r\nif (!peer_req) {\r\nput_ldev(mdev);\r\nreturn -EIO;\r\n}\r\npeer_req->w.cb = e_end_block;\r\ndp_flags = be32_to_cpu(p->dp_flags);\r\nrw |= wire_flags_to_bio(mdev, dp_flags);\r\nif (peer_req->pages == NULL) {\r\nD_ASSERT(peer_req->i.size == 0);\r\nD_ASSERT(dp_flags & DP_FLUSH);\r\n}\r\nif (dp_flags & DP_MAY_SET_IN_SYNC)\r\npeer_req->flags |= EE_MAY_SET_IN_SYNC;\r\nspin_lock(&tconn->epoch_lock);\r\npeer_req->epoch = tconn->current_epoch;\r\natomic_inc(&peer_req->epoch->epoch_size);\r\natomic_inc(&peer_req->epoch->active);\r\nspin_unlock(&tconn->epoch_lock);\r\nrcu_read_lock();\r\ntp = rcu_dereference(mdev->tconn->net_conf)->two_primaries;\r\nrcu_read_unlock();\r\nif (tp) {\r\npeer_req->flags |= EE_IN_INTERVAL_TREE;\r\nerr = wait_for_and_update_peer_seq(mdev, peer_seq);\r\nif (err)\r\ngoto out_interrupted;\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nerr = handle_write_conflicts(mdev, peer_req);\r\nif (err) {\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nif (err == -ENOENT) {\r\nput_ldev(mdev);\r\nreturn 0;\r\n}\r\ngoto out_interrupted;\r\n}\r\n} else\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nlist_add(&peer_req->w.list, &mdev->active_ee);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nif (mdev->state.conn == C_SYNC_TARGET)\r\nwait_event(mdev->ee_wait, !overlapping_resync_write(mdev, peer_req));\r\nif (mdev->tconn->agreed_pro_version < 100) {\r\nrcu_read_lock();\r\nswitch (rcu_dereference(mdev->tconn->net_conf)->wire_protocol) {\r\ncase DRBD_PROT_C:\r\ndp_flags |= DP_SEND_WRITE_ACK;\r\nbreak;\r\ncase DRBD_PROT_B:\r\ndp_flags |= DP_SEND_RECEIVE_ACK;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\n}\r\nif (dp_flags & DP_SEND_WRITE_ACK) {\r\npeer_req->flags |= EE_SEND_WRITE_ACK;\r\ninc_unacked(mdev);\r\n}\r\nif (dp_flags & DP_SEND_RECEIVE_ACK) {\r\ndrbd_send_ack(mdev, P_RECV_ACK, peer_req);\r\n}\r\nif (mdev->state.pdsk < D_INCONSISTENT) {\r\ndrbd_set_out_of_sync(mdev, peer_req->i.sector, peer_req->i.size);\r\npeer_req->flags |= EE_CALL_AL_COMPLETE_IO;\r\npeer_req->flags &= ~EE_MAY_SET_IN_SYNC;\r\ndrbd_al_begin_io(mdev, &peer_req->i, true);\r\n}\r\nerr = drbd_submit_peer_request(mdev, peer_req, rw, DRBD_FAULT_DT_WR);\r\nif (!err)\r\nreturn 0;\r\ndev_err(DEV, "submit failed, triggering re-connect\n");\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nlist_del(&peer_req->w.list);\r\ndrbd_remove_epoch_entry_interval(mdev, peer_req);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nif (peer_req->flags & EE_CALL_AL_COMPLETE_IO)\r\ndrbd_al_complete_io(mdev, &peer_req->i);\r\nout_interrupted:\r\ndrbd_may_finish_epoch(tconn, peer_req->epoch, EV_PUT + EV_CLEANUP);\r\nput_ldev(mdev);\r\ndrbd_free_peer_req(mdev, peer_req);\r\nreturn err;\r\n}\r\nint drbd_rs_should_slow_down(struct drbd_conf *mdev, sector_t sector)\r\n{\r\nstruct gendisk *disk = mdev->ldev->backing_bdev->bd_contains->bd_disk;\r\nunsigned long db, dt, dbdt;\r\nstruct lc_element *tmp;\r\nint curr_events;\r\nint throttle = 0;\r\nunsigned int c_min_rate;\r\nrcu_read_lock();\r\nc_min_rate = rcu_dereference(mdev->ldev->disk_conf)->c_min_rate;\r\nrcu_read_unlock();\r\nif (c_min_rate == 0)\r\nreturn 0;\r\nspin_lock_irq(&mdev->al_lock);\r\ntmp = lc_find(mdev->resync, BM_SECT_TO_EXT(sector));\r\nif (tmp) {\r\nstruct bm_extent *bm_ext = lc_entry(tmp, struct bm_extent, lce);\r\nif (test_bit(BME_PRIORITY, &bm_ext->flags)) {\r\nspin_unlock_irq(&mdev->al_lock);\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock_irq(&mdev->al_lock);\r\ncurr_events = (int)part_stat_read(&disk->part0, sectors[0]) +\r\n(int)part_stat_read(&disk->part0, sectors[1]) -\r\natomic_read(&mdev->rs_sect_ev);\r\nif (!mdev->rs_last_events || curr_events - mdev->rs_last_events > 64) {\r\nunsigned long rs_left;\r\nint i;\r\nmdev->rs_last_events = curr_events;\r\ni = (mdev->rs_last_mark + DRBD_SYNC_MARKS-1) % DRBD_SYNC_MARKS;\r\nif (mdev->state.conn == C_VERIFY_S || mdev->state.conn == C_VERIFY_T)\r\nrs_left = mdev->ov_left;\r\nelse\r\nrs_left = drbd_bm_total_weight(mdev) - mdev->rs_failed;\r\ndt = ((long)jiffies - (long)mdev->rs_mark_time[i]) / HZ;\r\nif (!dt)\r\ndt++;\r\ndb = mdev->rs_mark_left[i] - rs_left;\r\ndbdt = Bit2KB(db/dt);\r\nif (dbdt > c_min_rate)\r\nthrottle = 1;\r\n}\r\nreturn throttle;\r\n}\r\nstatic int receive_DataRequest(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct drbd_conf *mdev;\r\nsector_t sector;\r\nsector_t capacity;\r\nstruct drbd_peer_request *peer_req;\r\nstruct digest_info *di = NULL;\r\nint size, verb;\r\nunsigned int fault_type;\r\nstruct p_block_req *p = pi->data;\r\nmdev = vnr_to_mdev(tconn, pi->vnr);\r\nif (!mdev)\r\nreturn -EIO;\r\ncapacity = drbd_get_capacity(mdev->this_bdev);\r\nsector = be64_to_cpu(p->sector);\r\nsize = be32_to_cpu(p->blksize);\r\nif (size <= 0 || !IS_ALIGNED(size, 512) || size > DRBD_MAX_BIO_SIZE) {\r\ndev_err(DEV, "%s:%d: sector: %llus, size: %u\n", __FILE__, __LINE__,\r\n(unsigned long long)sector, size);\r\nreturn -EINVAL;\r\n}\r\nif (sector + (size>>9) > capacity) {\r\ndev_err(DEV, "%s:%d: sector: %llus, size: %u\n", __FILE__, __LINE__,\r\n(unsigned long long)sector, size);\r\nreturn -EINVAL;\r\n}\r\nif (!get_ldev_if_state(mdev, D_UP_TO_DATE)) {\r\nverb = 1;\r\nswitch (pi->cmd) {\r\ncase P_DATA_REQUEST:\r\ndrbd_send_ack_rp(mdev, P_NEG_DREPLY, p);\r\nbreak;\r\ncase P_RS_DATA_REQUEST:\r\ncase P_CSUM_RS_REQUEST:\r\ncase P_OV_REQUEST:\r\ndrbd_send_ack_rp(mdev, P_NEG_RS_DREPLY , p);\r\nbreak;\r\ncase P_OV_REPLY:\r\nverb = 0;\r\ndec_rs_pending(mdev);\r\ndrbd_send_ack_ex(mdev, P_OV_RESULT, sector, size, ID_IN_SYNC);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (verb && __ratelimit(&drbd_ratelimit_state))\r\ndev_err(DEV, "Can not satisfy peer's read request, "\r\n"no local data.\n");\r\nreturn drbd_drain_block(mdev, pi->size);\r\n}\r\npeer_req = drbd_alloc_peer_req(mdev, p->block_id, sector, size, GFP_NOIO);\r\nif (!peer_req) {\r\nput_ldev(mdev);\r\nreturn -ENOMEM;\r\n}\r\nswitch (pi->cmd) {\r\ncase P_DATA_REQUEST:\r\npeer_req->w.cb = w_e_end_data_req;\r\nfault_type = DRBD_FAULT_DT_RD;\r\ngoto submit;\r\ncase P_RS_DATA_REQUEST:\r\npeer_req->w.cb = w_e_end_rsdata_req;\r\nfault_type = DRBD_FAULT_RS_RD;\r\nmdev->bm_resync_fo = BM_SECT_TO_BIT(sector);\r\nbreak;\r\ncase P_OV_REPLY:\r\ncase P_CSUM_RS_REQUEST:\r\nfault_type = DRBD_FAULT_RS_RD;\r\ndi = kmalloc(sizeof(*di) + pi->size, GFP_NOIO);\r\nif (!di)\r\ngoto out_free_e;\r\ndi->digest_size = pi->size;\r\ndi->digest = (((char *)di)+sizeof(struct digest_info));\r\npeer_req->digest = di;\r\npeer_req->flags |= EE_HAS_DIGEST;\r\nif (drbd_recv_all(mdev->tconn, di->digest, pi->size))\r\ngoto out_free_e;\r\nif (pi->cmd == P_CSUM_RS_REQUEST) {\r\nD_ASSERT(mdev->tconn->agreed_pro_version >= 89);\r\npeer_req->w.cb = w_e_end_csum_rs_req;\r\nmdev->bm_resync_fo = BM_SECT_TO_BIT(sector);\r\n} else if (pi->cmd == P_OV_REPLY) {\r\natomic_add(size >> 9, &mdev->rs_sect_in);\r\npeer_req->w.cb = w_e_end_ov_reply;\r\ndec_rs_pending(mdev);\r\ngoto submit_for_resync;\r\n}\r\nbreak;\r\ncase P_OV_REQUEST:\r\nif (mdev->ov_start_sector == ~(sector_t)0 &&\r\nmdev->tconn->agreed_pro_version >= 90) {\r\nunsigned long now = jiffies;\r\nint i;\r\nmdev->ov_start_sector = sector;\r\nmdev->ov_position = sector;\r\nmdev->ov_left = drbd_bm_bits(mdev) - BM_SECT_TO_BIT(sector);\r\nmdev->rs_total = mdev->ov_left;\r\nfor (i = 0; i < DRBD_SYNC_MARKS; i++) {\r\nmdev->rs_mark_left[i] = mdev->ov_left;\r\nmdev->rs_mark_time[i] = now;\r\n}\r\ndev_info(DEV, "Online Verify start sector: %llu\n",\r\n(unsigned long long)sector);\r\n}\r\npeer_req->w.cb = w_e_end_ov_req;\r\nfault_type = DRBD_FAULT_RS_RD;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (mdev->state.peer != R_PRIMARY && drbd_rs_should_slow_down(mdev, sector))\r\nschedule_timeout_uninterruptible(HZ/10);\r\nif (drbd_rs_begin_io(mdev, sector))\r\ngoto out_free_e;\r\nsubmit_for_resync:\r\natomic_add(size >> 9, &mdev->rs_sect_ev);\r\nsubmit:\r\ninc_unacked(mdev);\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nlist_add_tail(&peer_req->w.list, &mdev->read_ee);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nif (drbd_submit_peer_request(mdev, peer_req, READ, fault_type) == 0)\r\nreturn 0;\r\ndev_err(DEV, "submit failed, triggering re-connect\n");\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nlist_del(&peer_req->w.list);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nout_free_e:\r\nput_ldev(mdev);\r\ndrbd_free_peer_req(mdev, peer_req);\r\nreturn -EIO;\r\n}\r\nstatic int drbd_asb_recover_0p(struct drbd_conf *mdev) __must_hold(local)\r\n{\r\nint self, peer, rv = -100;\r\nunsigned long ch_self, ch_peer;\r\nenum drbd_after_sb_p after_sb_0p;\r\nself = mdev->ldev->md.uuid[UI_BITMAP] & 1;\r\npeer = mdev->p_uuid[UI_BITMAP] & 1;\r\nch_peer = mdev->p_uuid[UI_SIZE];\r\nch_self = mdev->comm_bm_set;\r\nrcu_read_lock();\r\nafter_sb_0p = rcu_dereference(mdev->tconn->net_conf)->after_sb_0p;\r\nrcu_read_unlock();\r\nswitch (after_sb_0p) {\r\ncase ASB_CONSENSUS:\r\ncase ASB_DISCARD_SECONDARY:\r\ncase ASB_CALL_HELPER:\r\ncase ASB_VIOLENTLY:\r\ndev_err(DEV, "Configuration error.\n");\r\nbreak;\r\ncase ASB_DISCONNECT:\r\nbreak;\r\ncase ASB_DISCARD_YOUNGER_PRI:\r\nif (self == 0 && peer == 1) {\r\nrv = -1;\r\nbreak;\r\n}\r\nif (self == 1 && peer == 0) {\r\nrv = 1;\r\nbreak;\r\n}\r\ncase ASB_DISCARD_OLDER_PRI:\r\nif (self == 0 && peer == 1) {\r\nrv = 1;\r\nbreak;\r\n}\r\nif (self == 1 && peer == 0) {\r\nrv = -1;\r\nbreak;\r\n}\r\ndev_warn(DEV, "Discard younger/older primary did not find a decision\n"\r\n"Using discard-least-changes instead\n");\r\ncase ASB_DISCARD_ZERO_CHG:\r\nif (ch_peer == 0 && ch_self == 0) {\r\nrv = test_bit(RESOLVE_CONFLICTS, &mdev->tconn->flags)\r\n? -1 : 1;\r\nbreak;\r\n} else {\r\nif (ch_peer == 0) { rv = 1; break; }\r\nif (ch_self == 0) { rv = -1; break; }\r\n}\r\nif (after_sb_0p == ASB_DISCARD_ZERO_CHG)\r\nbreak;\r\ncase ASB_DISCARD_LEAST_CHG:\r\nif (ch_self < ch_peer)\r\nrv = -1;\r\nelse if (ch_self > ch_peer)\r\nrv = 1;\r\nelse\r\nrv = test_bit(RESOLVE_CONFLICTS, &mdev->tconn->flags)\r\n? -1 : 1;\r\nbreak;\r\ncase ASB_DISCARD_LOCAL:\r\nrv = -1;\r\nbreak;\r\ncase ASB_DISCARD_REMOTE:\r\nrv = 1;\r\n}\r\nreturn rv;\r\n}\r\nstatic int drbd_asb_recover_1p(struct drbd_conf *mdev) __must_hold(local)\r\n{\r\nint hg, rv = -100;\r\nenum drbd_after_sb_p after_sb_1p;\r\nrcu_read_lock();\r\nafter_sb_1p = rcu_dereference(mdev->tconn->net_conf)->after_sb_1p;\r\nrcu_read_unlock();\r\nswitch (after_sb_1p) {\r\ncase ASB_DISCARD_YOUNGER_PRI:\r\ncase ASB_DISCARD_OLDER_PRI:\r\ncase ASB_DISCARD_LEAST_CHG:\r\ncase ASB_DISCARD_LOCAL:\r\ncase ASB_DISCARD_REMOTE:\r\ncase ASB_DISCARD_ZERO_CHG:\r\ndev_err(DEV, "Configuration error.\n");\r\nbreak;\r\ncase ASB_DISCONNECT:\r\nbreak;\r\ncase ASB_CONSENSUS:\r\nhg = drbd_asb_recover_0p(mdev);\r\nif (hg == -1 && mdev->state.role == R_SECONDARY)\r\nrv = hg;\r\nif (hg == 1 && mdev->state.role == R_PRIMARY)\r\nrv = hg;\r\nbreak;\r\ncase ASB_VIOLENTLY:\r\nrv = drbd_asb_recover_0p(mdev);\r\nbreak;\r\ncase ASB_DISCARD_SECONDARY:\r\nreturn mdev->state.role == R_PRIMARY ? 1 : -1;\r\ncase ASB_CALL_HELPER:\r\nhg = drbd_asb_recover_0p(mdev);\r\nif (hg == -1 && mdev->state.role == R_PRIMARY) {\r\nenum drbd_state_rv rv2;\r\nrv2 = drbd_change_state(mdev, CS_VERBOSE, NS(role, R_SECONDARY));\r\nif (rv2 != SS_SUCCESS) {\r\ndrbd_khelper(mdev, "pri-lost-after-sb");\r\n} else {\r\ndev_warn(DEV, "Successfully gave up primary role.\n");\r\nrv = hg;\r\n}\r\n} else\r\nrv = hg;\r\n}\r\nreturn rv;\r\n}\r\nstatic int drbd_asb_recover_2p(struct drbd_conf *mdev) __must_hold(local)\r\n{\r\nint hg, rv = -100;\r\nenum drbd_after_sb_p after_sb_2p;\r\nrcu_read_lock();\r\nafter_sb_2p = rcu_dereference(mdev->tconn->net_conf)->after_sb_2p;\r\nrcu_read_unlock();\r\nswitch (after_sb_2p) {\r\ncase ASB_DISCARD_YOUNGER_PRI:\r\ncase ASB_DISCARD_OLDER_PRI:\r\ncase ASB_DISCARD_LEAST_CHG:\r\ncase ASB_DISCARD_LOCAL:\r\ncase ASB_DISCARD_REMOTE:\r\ncase ASB_CONSENSUS:\r\ncase ASB_DISCARD_SECONDARY:\r\ncase ASB_DISCARD_ZERO_CHG:\r\ndev_err(DEV, "Configuration error.\n");\r\nbreak;\r\ncase ASB_VIOLENTLY:\r\nrv = drbd_asb_recover_0p(mdev);\r\nbreak;\r\ncase ASB_DISCONNECT:\r\nbreak;\r\ncase ASB_CALL_HELPER:\r\nhg = drbd_asb_recover_0p(mdev);\r\nif (hg == -1) {\r\nenum drbd_state_rv rv2;\r\nrv2 = drbd_change_state(mdev, CS_VERBOSE, NS(role, R_SECONDARY));\r\nif (rv2 != SS_SUCCESS) {\r\ndrbd_khelper(mdev, "pri-lost-after-sb");\r\n} else {\r\ndev_warn(DEV, "Successfully gave up primary role.\n");\r\nrv = hg;\r\n}\r\n} else\r\nrv = hg;\r\n}\r\nreturn rv;\r\n}\r\nstatic void drbd_uuid_dump(struct drbd_conf *mdev, char *text, u64 *uuid,\r\nu64 bits, u64 flags)\r\n{\r\nif (!uuid) {\r\ndev_info(DEV, "%s uuid info vanished while I was looking!\n", text);\r\nreturn;\r\n}\r\ndev_info(DEV, "%s %016llX:%016llX:%016llX:%016llX bits:%llu flags:%llX\n",\r\ntext,\r\n(unsigned long long)uuid[UI_CURRENT],\r\n(unsigned long long)uuid[UI_BITMAP],\r\n(unsigned long long)uuid[UI_HISTORY_START],\r\n(unsigned long long)uuid[UI_HISTORY_END],\r\n(unsigned long long)bits,\r\n(unsigned long long)flags);\r\n}\r\nstatic int drbd_uuid_compare(struct drbd_conf *mdev, int *rule_nr) __must_hold(local)\r\n{\r\nu64 self, peer;\r\nint i, j;\r\nself = mdev->ldev->md.uuid[UI_CURRENT] & ~((u64)1);\r\npeer = mdev->p_uuid[UI_CURRENT] & ~((u64)1);\r\n*rule_nr = 10;\r\nif (self == UUID_JUST_CREATED && peer == UUID_JUST_CREATED)\r\nreturn 0;\r\n*rule_nr = 20;\r\nif ((self == UUID_JUST_CREATED || self == (u64)0) &&\r\npeer != UUID_JUST_CREATED)\r\nreturn -2;\r\n*rule_nr = 30;\r\nif (self != UUID_JUST_CREATED &&\r\n(peer == UUID_JUST_CREATED || peer == (u64)0))\r\nreturn 2;\r\nif (self == peer) {\r\nint rct, dc;\r\nif (mdev->p_uuid[UI_BITMAP] == (u64)0 && mdev->ldev->md.uuid[UI_BITMAP] != (u64)0) {\r\nif (mdev->tconn->agreed_pro_version < 91)\r\nreturn -1091;\r\nif ((mdev->ldev->md.uuid[UI_BITMAP] & ~((u64)1)) == (mdev->p_uuid[UI_HISTORY_START] & ~((u64)1)) &&\r\n(mdev->ldev->md.uuid[UI_HISTORY_START] & ~((u64)1)) == (mdev->p_uuid[UI_HISTORY_START + 1] & ~((u64)1))) {\r\ndev_info(DEV, "was SyncSource, missed the resync finished event, corrected myself:\n");\r\ndrbd_uuid_move_history(mdev);\r\nmdev->ldev->md.uuid[UI_HISTORY_START] = mdev->ldev->md.uuid[UI_BITMAP];\r\nmdev->ldev->md.uuid[UI_BITMAP] = 0;\r\ndrbd_uuid_dump(mdev, "self", mdev->ldev->md.uuid,\r\nmdev->state.disk >= D_NEGOTIATING ? drbd_bm_total_weight(mdev) : 0, 0);\r\n*rule_nr = 34;\r\n} else {\r\ndev_info(DEV, "was SyncSource (peer failed to write sync_uuid)\n");\r\n*rule_nr = 36;\r\n}\r\nreturn 1;\r\n}\r\nif (mdev->ldev->md.uuid[UI_BITMAP] == (u64)0 && mdev->p_uuid[UI_BITMAP] != (u64)0) {\r\nif (mdev->tconn->agreed_pro_version < 91)\r\nreturn -1091;\r\nif ((mdev->ldev->md.uuid[UI_HISTORY_START] & ~((u64)1)) == (mdev->p_uuid[UI_BITMAP] & ~((u64)1)) &&\r\n(mdev->ldev->md.uuid[UI_HISTORY_START + 1] & ~((u64)1)) == (mdev->p_uuid[UI_HISTORY_START] & ~((u64)1))) {\r\ndev_info(DEV, "was SyncTarget, peer missed the resync finished event, corrected peer:\n");\r\nmdev->p_uuid[UI_HISTORY_START + 1] = mdev->p_uuid[UI_HISTORY_START];\r\nmdev->p_uuid[UI_HISTORY_START] = mdev->p_uuid[UI_BITMAP];\r\nmdev->p_uuid[UI_BITMAP] = 0UL;\r\ndrbd_uuid_dump(mdev, "peer", mdev->p_uuid, mdev->p_uuid[UI_SIZE], mdev->p_uuid[UI_FLAGS]);\r\n*rule_nr = 35;\r\n} else {\r\ndev_info(DEV, "was SyncTarget (failed to write sync_uuid)\n");\r\n*rule_nr = 37;\r\n}\r\nreturn -1;\r\n}\r\nrct = (test_bit(CRASHED_PRIMARY, &mdev->flags) ? 1 : 0) +\r\n(mdev->p_uuid[UI_FLAGS] & 2);\r\n*rule_nr = 40;\r\nswitch (rct) {\r\ncase 0: return 0;\r\ncase 1: return 1;\r\ncase 2: return -1;\r\ncase 3:\r\ndc = test_bit(RESOLVE_CONFLICTS, &mdev->tconn->flags);\r\nreturn dc ? -1 : 1;\r\n}\r\n}\r\n*rule_nr = 50;\r\npeer = mdev->p_uuid[UI_BITMAP] & ~((u64)1);\r\nif (self == peer)\r\nreturn -1;\r\n*rule_nr = 51;\r\npeer = mdev->p_uuid[UI_HISTORY_START] & ~((u64)1);\r\nif (self == peer) {\r\nif (mdev->tconn->agreed_pro_version < 96 ?\r\n(mdev->ldev->md.uuid[UI_HISTORY_START] & ~((u64)1)) ==\r\n(mdev->p_uuid[UI_HISTORY_START + 1] & ~((u64)1)) :\r\npeer + UUID_NEW_BM_OFFSET == (mdev->p_uuid[UI_BITMAP] & ~((u64)1))) {\r\nif (mdev->tconn->agreed_pro_version < 91)\r\nreturn -1091;\r\nmdev->p_uuid[UI_BITMAP] = mdev->p_uuid[UI_HISTORY_START];\r\nmdev->p_uuid[UI_HISTORY_START] = mdev->p_uuid[UI_HISTORY_START + 1];\r\ndev_info(DEV, "Lost last syncUUID packet, corrected:\n");\r\ndrbd_uuid_dump(mdev, "peer", mdev->p_uuid, mdev->p_uuid[UI_SIZE], mdev->p_uuid[UI_FLAGS]);\r\nreturn -1;\r\n}\r\n}\r\n*rule_nr = 60;\r\nself = mdev->ldev->md.uuid[UI_CURRENT] & ~((u64)1);\r\nfor (i = UI_HISTORY_START; i <= UI_HISTORY_END; i++) {\r\npeer = mdev->p_uuid[i] & ~((u64)1);\r\nif (self == peer)\r\nreturn -2;\r\n}\r\n*rule_nr = 70;\r\nself = mdev->ldev->md.uuid[UI_BITMAP] & ~((u64)1);\r\npeer = mdev->p_uuid[UI_CURRENT] & ~((u64)1);\r\nif (self == peer)\r\nreturn 1;\r\n*rule_nr = 71;\r\nself = mdev->ldev->md.uuid[UI_HISTORY_START] & ~((u64)1);\r\nif (self == peer) {\r\nif (mdev->tconn->agreed_pro_version < 96 ?\r\n(mdev->ldev->md.uuid[UI_HISTORY_START + 1] & ~((u64)1)) ==\r\n(mdev->p_uuid[UI_HISTORY_START] & ~((u64)1)) :\r\nself + UUID_NEW_BM_OFFSET == (mdev->ldev->md.uuid[UI_BITMAP] & ~((u64)1))) {\r\nif (mdev->tconn->agreed_pro_version < 91)\r\nreturn -1091;\r\n__drbd_uuid_set(mdev, UI_BITMAP, mdev->ldev->md.uuid[UI_HISTORY_START]);\r\n__drbd_uuid_set(mdev, UI_HISTORY_START, mdev->ldev->md.uuid[UI_HISTORY_START + 1]);\r\ndev_info(DEV, "Last syncUUID did not get through, corrected:\n");\r\ndrbd_uuid_dump(mdev, "self", mdev->ldev->md.uuid,\r\nmdev->state.disk >= D_NEGOTIATING ? drbd_bm_total_weight(mdev) : 0, 0);\r\nreturn 1;\r\n}\r\n}\r\n*rule_nr = 80;\r\npeer = mdev->p_uuid[UI_CURRENT] & ~((u64)1);\r\nfor (i = UI_HISTORY_START; i <= UI_HISTORY_END; i++) {\r\nself = mdev->ldev->md.uuid[i] & ~((u64)1);\r\nif (self == peer)\r\nreturn 2;\r\n}\r\n*rule_nr = 90;\r\nself = mdev->ldev->md.uuid[UI_BITMAP] & ~((u64)1);\r\npeer = mdev->p_uuid[UI_BITMAP] & ~((u64)1);\r\nif (self == peer && self != ((u64)0))\r\nreturn 100;\r\n*rule_nr = 100;\r\nfor (i = UI_HISTORY_START; i <= UI_HISTORY_END; i++) {\r\nself = mdev->ldev->md.uuid[i] & ~((u64)1);\r\nfor (j = UI_HISTORY_START; j <= UI_HISTORY_END; j++) {\r\npeer = mdev->p_uuid[j] & ~((u64)1);\r\nif (self == peer)\r\nreturn -100;\r\n}\r\n}\r\nreturn -1000;\r\n}\r\nstatic enum drbd_conns drbd_sync_handshake(struct drbd_conf *mdev, enum drbd_role peer_role,\r\nenum drbd_disk_state peer_disk) __must_hold(local)\r\n{\r\nenum drbd_conns rv = C_MASK;\r\nenum drbd_disk_state mydisk;\r\nstruct net_conf *nc;\r\nint hg, rule_nr, rr_conflict, tentative;\r\nmydisk = mdev->state.disk;\r\nif (mydisk == D_NEGOTIATING)\r\nmydisk = mdev->new_state_tmp.disk;\r\ndev_info(DEV, "drbd_sync_handshake:\n");\r\nspin_lock_irq(&mdev->ldev->md.uuid_lock);\r\ndrbd_uuid_dump(mdev, "self", mdev->ldev->md.uuid, mdev->comm_bm_set, 0);\r\ndrbd_uuid_dump(mdev, "peer", mdev->p_uuid,\r\nmdev->p_uuid[UI_SIZE], mdev->p_uuid[UI_FLAGS]);\r\nhg = drbd_uuid_compare(mdev, &rule_nr);\r\nspin_unlock_irq(&mdev->ldev->md.uuid_lock);\r\ndev_info(DEV, "uuid_compare()=%d by rule %d\n", hg, rule_nr);\r\nif (hg == -1000) {\r\ndev_alert(DEV, "Unrelated data, aborting!\n");\r\nreturn C_MASK;\r\n}\r\nif (hg < -1000) {\r\ndev_alert(DEV, "To resolve this both sides have to support at least protocol %d\n", -hg - 1000);\r\nreturn C_MASK;\r\n}\r\nif ((mydisk == D_INCONSISTENT && peer_disk > D_INCONSISTENT) ||\r\n(peer_disk == D_INCONSISTENT && mydisk > D_INCONSISTENT)) {\r\nint f = (hg == -100) || abs(hg) == 2;\r\nhg = mydisk > D_INCONSISTENT ? 1 : -1;\r\nif (f)\r\nhg = hg*2;\r\ndev_info(DEV, "Becoming sync %s due to disk states.\n",\r\nhg > 0 ? "source" : "target");\r\n}\r\nif (abs(hg) == 100)\r\ndrbd_khelper(mdev, "initial-split-brain");\r\nrcu_read_lock();\r\nnc = rcu_dereference(mdev->tconn->net_conf);\r\nif (hg == 100 || (hg == -100 && nc->always_asbp)) {\r\nint pcount = (mdev->state.role == R_PRIMARY)\r\n+ (peer_role == R_PRIMARY);\r\nint forced = (hg == -100);\r\nswitch (pcount) {\r\ncase 0:\r\nhg = drbd_asb_recover_0p(mdev);\r\nbreak;\r\ncase 1:\r\nhg = drbd_asb_recover_1p(mdev);\r\nbreak;\r\ncase 2:\r\nhg = drbd_asb_recover_2p(mdev);\r\nbreak;\r\n}\r\nif (abs(hg) < 100) {\r\ndev_warn(DEV, "Split-Brain detected, %d primaries, "\r\n"automatically solved. Sync from %s node\n",\r\npcount, (hg < 0) ? "peer" : "this");\r\nif (forced) {\r\ndev_warn(DEV, "Doing a full sync, since"\r\n" UUIDs where ambiguous.\n");\r\nhg = hg*2;\r\n}\r\n}\r\n}\r\nif (hg == -100) {\r\nif (test_bit(DISCARD_MY_DATA, &mdev->flags) && !(mdev->p_uuid[UI_FLAGS]&1))\r\nhg = -1;\r\nif (!test_bit(DISCARD_MY_DATA, &mdev->flags) && (mdev->p_uuid[UI_FLAGS]&1))\r\nhg = 1;\r\nif (abs(hg) < 100)\r\ndev_warn(DEV, "Split-Brain detected, manually solved. "\r\n"Sync from %s node\n",\r\n(hg < 0) ? "peer" : "this");\r\n}\r\nrr_conflict = nc->rr_conflict;\r\ntentative = nc->tentative;\r\nrcu_read_unlock();\r\nif (hg == -100) {\r\ndev_alert(DEV, "Split-Brain detected but unresolved, dropping connection!\n");\r\ndrbd_khelper(mdev, "split-brain");\r\nreturn C_MASK;\r\n}\r\nif (hg > 0 && mydisk <= D_INCONSISTENT) {\r\ndev_err(DEV, "I shall become SyncSource, but I am inconsistent!\n");\r\nreturn C_MASK;\r\n}\r\nif (hg < 0 &&\r\nmdev->state.role == R_PRIMARY && mdev->state.disk >= D_CONSISTENT) {\r\nswitch (rr_conflict) {\r\ncase ASB_CALL_HELPER:\r\ndrbd_khelper(mdev, "pri-lost");\r\ncase ASB_DISCONNECT:\r\ndev_err(DEV, "I shall become SyncTarget, but I am primary!\n");\r\nreturn C_MASK;\r\ncase ASB_VIOLENTLY:\r\ndev_warn(DEV, "Becoming SyncTarget, violating the stable-data"\r\n"assumption\n");\r\n}\r\n}\r\nif (tentative || test_bit(CONN_DRY_RUN, &mdev->tconn->flags)) {\r\nif (hg == 0)\r\ndev_info(DEV, "dry-run connect: No resync, would become Connected immediately.\n");\r\nelse\r\ndev_info(DEV, "dry-run connect: Would become %s, doing a %s resync.",\r\ndrbd_conn_str(hg > 0 ? C_SYNC_SOURCE : C_SYNC_TARGET),\r\nabs(hg) >= 2 ? "full" : "bit-map based");\r\nreturn C_MASK;\r\n}\r\nif (abs(hg) >= 2) {\r\ndev_info(DEV, "Writing the whole bitmap, full sync required after drbd_sync_handshake.\n");\r\nif (drbd_bitmap_io(mdev, &drbd_bmio_set_n_write, "set_n_write from sync_handshake",\r\nBM_LOCKED_SET_ALLOWED))\r\nreturn C_MASK;\r\n}\r\nif (hg > 0) {\r\nrv = C_WF_BITMAP_S;\r\n} else if (hg < 0) {\r\nrv = C_WF_BITMAP_T;\r\n} else {\r\nrv = C_CONNECTED;\r\nif (drbd_bm_total_weight(mdev)) {\r\ndev_info(DEV, "No resync, but %lu bits in bitmap!\n",\r\ndrbd_bm_total_weight(mdev));\r\n}\r\n}\r\nreturn rv;\r\n}\r\nstatic enum drbd_after_sb_p convert_after_sb(enum drbd_after_sb_p peer)\r\n{\r\nif (peer == ASB_DISCARD_REMOTE)\r\nreturn ASB_DISCARD_LOCAL;\r\nif (peer == ASB_DISCARD_LOCAL)\r\nreturn ASB_DISCARD_REMOTE;\r\nreturn peer;\r\n}\r\nstatic int receive_protocol(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct p_protocol *p = pi->data;\r\nenum drbd_after_sb_p p_after_sb_0p, p_after_sb_1p, p_after_sb_2p;\r\nint p_proto, p_discard_my_data, p_two_primaries, cf;\r\nstruct net_conf *nc, *old_net_conf, *new_net_conf = NULL;\r\nchar integrity_alg[SHARED_SECRET_MAX] = "";\r\nstruct crypto_hash *peer_integrity_tfm = NULL;\r\nvoid *int_dig_in = NULL, *int_dig_vv = NULL;\r\np_proto = be32_to_cpu(p->protocol);\r\np_after_sb_0p = be32_to_cpu(p->after_sb_0p);\r\np_after_sb_1p = be32_to_cpu(p->after_sb_1p);\r\np_after_sb_2p = be32_to_cpu(p->after_sb_2p);\r\np_two_primaries = be32_to_cpu(p->two_primaries);\r\ncf = be32_to_cpu(p->conn_flags);\r\np_discard_my_data = cf & CF_DISCARD_MY_DATA;\r\nif (tconn->agreed_pro_version >= 87) {\r\nint err;\r\nif (pi->size > sizeof(integrity_alg))\r\nreturn -EIO;\r\nerr = drbd_recv_all(tconn, integrity_alg, pi->size);\r\nif (err)\r\nreturn err;\r\nintegrity_alg[SHARED_SECRET_MAX - 1] = 0;\r\n}\r\nif (pi->cmd != P_PROTOCOL_UPDATE) {\r\nclear_bit(CONN_DRY_RUN, &tconn->flags);\r\nif (cf & CF_DRY_RUN)\r\nset_bit(CONN_DRY_RUN, &tconn->flags);\r\nrcu_read_lock();\r\nnc = rcu_dereference(tconn->net_conf);\r\nif (p_proto != nc->wire_protocol) {\r\nconn_err(tconn, "incompatible %s settings\n", "protocol");\r\ngoto disconnect_rcu_unlock;\r\n}\r\nif (convert_after_sb(p_after_sb_0p) != nc->after_sb_0p) {\r\nconn_err(tconn, "incompatible %s settings\n", "after-sb-0pri");\r\ngoto disconnect_rcu_unlock;\r\n}\r\nif (convert_after_sb(p_after_sb_1p) != nc->after_sb_1p) {\r\nconn_err(tconn, "incompatible %s settings\n", "after-sb-1pri");\r\ngoto disconnect_rcu_unlock;\r\n}\r\nif (convert_after_sb(p_after_sb_2p) != nc->after_sb_2p) {\r\nconn_err(tconn, "incompatible %s settings\n", "after-sb-2pri");\r\ngoto disconnect_rcu_unlock;\r\n}\r\nif (p_discard_my_data && nc->discard_my_data) {\r\nconn_err(tconn, "incompatible %s settings\n", "discard-my-data");\r\ngoto disconnect_rcu_unlock;\r\n}\r\nif (p_two_primaries != nc->two_primaries) {\r\nconn_err(tconn, "incompatible %s settings\n", "allow-two-primaries");\r\ngoto disconnect_rcu_unlock;\r\n}\r\nif (strcmp(integrity_alg, nc->integrity_alg)) {\r\nconn_err(tconn, "incompatible %s settings\n", "data-integrity-alg");\r\ngoto disconnect_rcu_unlock;\r\n}\r\nrcu_read_unlock();\r\n}\r\nif (integrity_alg[0]) {\r\nint hash_size;\r\npeer_integrity_tfm = crypto_alloc_hash(integrity_alg, 0, CRYPTO_ALG_ASYNC);\r\nif (!peer_integrity_tfm) {\r\nconn_err(tconn, "peer data-integrity-alg %s not supported\n",\r\nintegrity_alg);\r\ngoto disconnect;\r\n}\r\nhash_size = crypto_hash_digestsize(peer_integrity_tfm);\r\nint_dig_in = kmalloc(hash_size, GFP_KERNEL);\r\nint_dig_vv = kmalloc(hash_size, GFP_KERNEL);\r\nif (!(int_dig_in && int_dig_vv)) {\r\nconn_err(tconn, "Allocation of buffers for data integrity checking failed\n");\r\ngoto disconnect;\r\n}\r\n}\r\nnew_net_conf = kmalloc(sizeof(struct net_conf), GFP_KERNEL);\r\nif (!new_net_conf) {\r\nconn_err(tconn, "Allocation of new net_conf failed\n");\r\ngoto disconnect;\r\n}\r\nmutex_lock(&tconn->data.mutex);\r\nmutex_lock(&tconn->conf_update);\r\nold_net_conf = tconn->net_conf;\r\n*new_net_conf = *old_net_conf;\r\nnew_net_conf->wire_protocol = p_proto;\r\nnew_net_conf->after_sb_0p = convert_after_sb(p_after_sb_0p);\r\nnew_net_conf->after_sb_1p = convert_after_sb(p_after_sb_1p);\r\nnew_net_conf->after_sb_2p = convert_after_sb(p_after_sb_2p);\r\nnew_net_conf->two_primaries = p_two_primaries;\r\nrcu_assign_pointer(tconn->net_conf, new_net_conf);\r\nmutex_unlock(&tconn->conf_update);\r\nmutex_unlock(&tconn->data.mutex);\r\ncrypto_free_hash(tconn->peer_integrity_tfm);\r\nkfree(tconn->int_dig_in);\r\nkfree(tconn->int_dig_vv);\r\ntconn->peer_integrity_tfm = peer_integrity_tfm;\r\ntconn->int_dig_in = int_dig_in;\r\ntconn->int_dig_vv = int_dig_vv;\r\nif (strcmp(old_net_conf->integrity_alg, integrity_alg))\r\nconn_info(tconn, "peer data-integrity-alg: %s\n",\r\nintegrity_alg[0] ? integrity_alg : "(none)");\r\nsynchronize_rcu();\r\nkfree(old_net_conf);\r\nreturn 0;\r\ndisconnect_rcu_unlock:\r\nrcu_read_unlock();\r\ndisconnect:\r\ncrypto_free_hash(peer_integrity_tfm);\r\nkfree(int_dig_in);\r\nkfree(int_dig_vv);\r\nconn_request_state(tconn, NS(conn, C_DISCONNECTING), CS_HARD);\r\nreturn -EIO;\r\n}\r\nstruct crypto_hash *drbd_crypto_alloc_digest_safe(const struct drbd_conf *mdev,\r\nconst char *alg, const char *name)\r\n{\r\nstruct crypto_hash *tfm;\r\nif (!alg[0])\r\nreturn NULL;\r\ntfm = crypto_alloc_hash(alg, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(tfm)) {\r\ndev_err(DEV, "Can not allocate \"%s\" as %s (reason: %ld)\n",\r\nalg, name, PTR_ERR(tfm));\r\nreturn tfm;\r\n}\r\nreturn tfm;\r\n}\r\nstatic int ignore_remaining_packet(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nvoid *buffer = tconn->data.rbuf;\r\nint size = pi->size;\r\nwhile (size) {\r\nint s = min_t(int, size, DRBD_SOCKET_BUFFER_SIZE);\r\ns = drbd_recv(tconn, buffer, s);\r\nif (s <= 0) {\r\nif (s < 0)\r\nreturn s;\r\nbreak;\r\n}\r\nsize -= s;\r\n}\r\nif (size)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int config_unknown_volume(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nconn_warn(tconn, "%s packet received for volume %u, which is not configured locally\n",\r\ncmdname(pi->cmd), pi->vnr);\r\nreturn ignore_remaining_packet(tconn, pi);\r\n}\r\nstatic int receive_SyncParam(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct drbd_conf *mdev;\r\nstruct p_rs_param_95 *p;\r\nunsigned int header_size, data_size, exp_max_sz;\r\nstruct crypto_hash *verify_tfm = NULL;\r\nstruct crypto_hash *csums_tfm = NULL;\r\nstruct net_conf *old_net_conf, *new_net_conf = NULL;\r\nstruct disk_conf *old_disk_conf = NULL, *new_disk_conf = NULL;\r\nconst int apv = tconn->agreed_pro_version;\r\nstruct fifo_buffer *old_plan = NULL, *new_plan = NULL;\r\nint fifo_size = 0;\r\nint err;\r\nmdev = vnr_to_mdev(tconn, pi->vnr);\r\nif (!mdev)\r\nreturn config_unknown_volume(tconn, pi);\r\nexp_max_sz = apv <= 87 ? sizeof(struct p_rs_param)\r\n: apv == 88 ? sizeof(struct p_rs_param)\r\n+ SHARED_SECRET_MAX\r\n: apv <= 94 ? sizeof(struct p_rs_param_89)\r\n: sizeof(struct p_rs_param_95);\r\nif (pi->size > exp_max_sz) {\r\ndev_err(DEV, "SyncParam packet too long: received %u, expected <= %u bytes\n",\r\npi->size, exp_max_sz);\r\nreturn -EIO;\r\n}\r\nif (apv <= 88) {\r\nheader_size = sizeof(struct p_rs_param);\r\ndata_size = pi->size - header_size;\r\n} else if (apv <= 94) {\r\nheader_size = sizeof(struct p_rs_param_89);\r\ndata_size = pi->size - header_size;\r\nD_ASSERT(data_size == 0);\r\n} else {\r\nheader_size = sizeof(struct p_rs_param_95);\r\ndata_size = pi->size - header_size;\r\nD_ASSERT(data_size == 0);\r\n}\r\np = pi->data;\r\nmemset(p->verify_alg, 0, 2 * SHARED_SECRET_MAX);\r\nerr = drbd_recv_all(mdev->tconn, p, header_size);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&mdev->tconn->conf_update);\r\nold_net_conf = mdev->tconn->net_conf;\r\nif (get_ldev(mdev)) {\r\nnew_disk_conf = kzalloc(sizeof(struct disk_conf), GFP_KERNEL);\r\nif (!new_disk_conf) {\r\nput_ldev(mdev);\r\nmutex_unlock(&mdev->tconn->conf_update);\r\ndev_err(DEV, "Allocation of new disk_conf failed\n");\r\nreturn -ENOMEM;\r\n}\r\nold_disk_conf = mdev->ldev->disk_conf;\r\n*new_disk_conf = *old_disk_conf;\r\nnew_disk_conf->resync_rate = be32_to_cpu(p->resync_rate);\r\n}\r\nif (apv >= 88) {\r\nif (apv == 88) {\r\nif (data_size > SHARED_SECRET_MAX || data_size == 0) {\r\ndev_err(DEV, "verify-alg of wrong size, "\r\n"peer wants %u, accepting only up to %u byte\n",\r\ndata_size, SHARED_SECRET_MAX);\r\nerr = -EIO;\r\ngoto reconnect;\r\n}\r\nerr = drbd_recv_all(mdev->tconn, p->verify_alg, data_size);\r\nif (err)\r\ngoto reconnect;\r\nD_ASSERT(p->verify_alg[data_size-1] == 0);\r\np->verify_alg[data_size-1] = 0;\r\n} else {\r\nD_ASSERT(p->verify_alg[SHARED_SECRET_MAX-1] == 0);\r\nD_ASSERT(p->csums_alg[SHARED_SECRET_MAX-1] == 0);\r\np->verify_alg[SHARED_SECRET_MAX-1] = 0;\r\np->csums_alg[SHARED_SECRET_MAX-1] = 0;\r\n}\r\nif (strcmp(old_net_conf->verify_alg, p->verify_alg)) {\r\nif (mdev->state.conn == C_WF_REPORT_PARAMS) {\r\ndev_err(DEV, "Different verify-alg settings. me=\"%s\" peer=\"%s\"\n",\r\nold_net_conf->verify_alg, p->verify_alg);\r\ngoto disconnect;\r\n}\r\nverify_tfm = drbd_crypto_alloc_digest_safe(mdev,\r\np->verify_alg, "verify-alg");\r\nif (IS_ERR(verify_tfm)) {\r\nverify_tfm = NULL;\r\ngoto disconnect;\r\n}\r\n}\r\nif (apv >= 89 && strcmp(old_net_conf->csums_alg, p->csums_alg)) {\r\nif (mdev->state.conn == C_WF_REPORT_PARAMS) {\r\ndev_err(DEV, "Different csums-alg settings. me=\"%s\" peer=\"%s\"\n",\r\nold_net_conf->csums_alg, p->csums_alg);\r\ngoto disconnect;\r\n}\r\ncsums_tfm = drbd_crypto_alloc_digest_safe(mdev,\r\np->csums_alg, "csums-alg");\r\nif (IS_ERR(csums_tfm)) {\r\ncsums_tfm = NULL;\r\ngoto disconnect;\r\n}\r\n}\r\nif (apv > 94 && new_disk_conf) {\r\nnew_disk_conf->c_plan_ahead = be32_to_cpu(p->c_plan_ahead);\r\nnew_disk_conf->c_delay_target = be32_to_cpu(p->c_delay_target);\r\nnew_disk_conf->c_fill_target = be32_to_cpu(p->c_fill_target);\r\nnew_disk_conf->c_max_rate = be32_to_cpu(p->c_max_rate);\r\nfifo_size = (new_disk_conf->c_plan_ahead * 10 * SLEEP_TIME) / HZ;\r\nif (fifo_size != mdev->rs_plan_s->size) {\r\nnew_plan = fifo_alloc(fifo_size);\r\nif (!new_plan) {\r\ndev_err(DEV, "kmalloc of fifo_buffer failed");\r\nput_ldev(mdev);\r\ngoto disconnect;\r\n}\r\n}\r\n}\r\nif (verify_tfm || csums_tfm) {\r\nnew_net_conf = kzalloc(sizeof(struct net_conf), GFP_KERNEL);\r\nif (!new_net_conf) {\r\ndev_err(DEV, "Allocation of new net_conf failed\n");\r\ngoto disconnect;\r\n}\r\n*new_net_conf = *old_net_conf;\r\nif (verify_tfm) {\r\nstrcpy(new_net_conf->verify_alg, p->verify_alg);\r\nnew_net_conf->verify_alg_len = strlen(p->verify_alg) + 1;\r\ncrypto_free_hash(mdev->tconn->verify_tfm);\r\nmdev->tconn->verify_tfm = verify_tfm;\r\ndev_info(DEV, "using verify-alg: \"%s\"\n", p->verify_alg);\r\n}\r\nif (csums_tfm) {\r\nstrcpy(new_net_conf->csums_alg, p->csums_alg);\r\nnew_net_conf->csums_alg_len = strlen(p->csums_alg) + 1;\r\ncrypto_free_hash(mdev->tconn->csums_tfm);\r\nmdev->tconn->csums_tfm = csums_tfm;\r\ndev_info(DEV, "using csums-alg: \"%s\"\n", p->csums_alg);\r\n}\r\nrcu_assign_pointer(tconn->net_conf, new_net_conf);\r\n}\r\n}\r\nif (new_disk_conf) {\r\nrcu_assign_pointer(mdev->ldev->disk_conf, new_disk_conf);\r\nput_ldev(mdev);\r\n}\r\nif (new_plan) {\r\nold_plan = mdev->rs_plan_s;\r\nrcu_assign_pointer(mdev->rs_plan_s, new_plan);\r\n}\r\nmutex_unlock(&mdev->tconn->conf_update);\r\nsynchronize_rcu();\r\nif (new_net_conf)\r\nkfree(old_net_conf);\r\nkfree(old_disk_conf);\r\nkfree(old_plan);\r\nreturn 0;\r\nreconnect:\r\nif (new_disk_conf) {\r\nput_ldev(mdev);\r\nkfree(new_disk_conf);\r\n}\r\nmutex_unlock(&mdev->tconn->conf_update);\r\nreturn -EIO;\r\ndisconnect:\r\nkfree(new_plan);\r\nif (new_disk_conf) {\r\nput_ldev(mdev);\r\nkfree(new_disk_conf);\r\n}\r\nmutex_unlock(&mdev->tconn->conf_update);\r\ncrypto_free_hash(csums_tfm);\r\ncrypto_free_hash(verify_tfm);\r\nconn_request_state(mdev->tconn, NS(conn, C_DISCONNECTING), CS_HARD);\r\nreturn -EIO;\r\n}\r\nstatic void warn_if_differ_considerably(struct drbd_conf *mdev,\r\nconst char *s, sector_t a, sector_t b)\r\n{\r\nsector_t d;\r\nif (a == 0 || b == 0)\r\nreturn;\r\nd = (a > b) ? (a - b) : (b - a);\r\nif (d > (a>>3) || d > (b>>3))\r\ndev_warn(DEV, "Considerable difference in %s: %llus vs. %llus\n", s,\r\n(unsigned long long)a, (unsigned long long)b);\r\n}\r\nstatic int receive_sizes(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct drbd_conf *mdev;\r\nstruct p_sizes *p = pi->data;\r\nenum determine_dev_size dd = DS_UNCHANGED;\r\nsector_t p_size, p_usize, my_usize;\r\nint ldsc = 0;\r\nenum dds_flags ddsf;\r\nmdev = vnr_to_mdev(tconn, pi->vnr);\r\nif (!mdev)\r\nreturn config_unknown_volume(tconn, pi);\r\np_size = be64_to_cpu(p->d_size);\r\np_usize = be64_to_cpu(p->u_size);\r\nmdev->p_size = p_size;\r\nif (get_ldev(mdev)) {\r\nrcu_read_lock();\r\nmy_usize = rcu_dereference(mdev->ldev->disk_conf)->disk_size;\r\nrcu_read_unlock();\r\nwarn_if_differ_considerably(mdev, "lower level device sizes",\r\np_size, drbd_get_max_capacity(mdev->ldev));\r\nwarn_if_differ_considerably(mdev, "user requested size",\r\np_usize, my_usize);\r\nif (mdev->state.conn == C_WF_REPORT_PARAMS)\r\np_usize = min_not_zero(my_usize, p_usize);\r\nif (drbd_new_dev_size(mdev, mdev->ldev, p_usize, 0) <\r\ndrbd_get_capacity(mdev->this_bdev) &&\r\nmdev->state.disk >= D_OUTDATED &&\r\nmdev->state.conn < C_CONNECTED) {\r\ndev_err(DEV, "The peer's disk size is too small!\n");\r\nconn_request_state(mdev->tconn, NS(conn, C_DISCONNECTING), CS_HARD);\r\nput_ldev(mdev);\r\nreturn -EIO;\r\n}\r\nif (my_usize != p_usize) {\r\nstruct disk_conf *old_disk_conf, *new_disk_conf = NULL;\r\nnew_disk_conf = kzalloc(sizeof(struct disk_conf), GFP_KERNEL);\r\nif (!new_disk_conf) {\r\ndev_err(DEV, "Allocation of new disk_conf failed\n");\r\nput_ldev(mdev);\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&mdev->tconn->conf_update);\r\nold_disk_conf = mdev->ldev->disk_conf;\r\n*new_disk_conf = *old_disk_conf;\r\nnew_disk_conf->disk_size = p_usize;\r\nrcu_assign_pointer(mdev->ldev->disk_conf, new_disk_conf);\r\nmutex_unlock(&mdev->tconn->conf_update);\r\nsynchronize_rcu();\r\nkfree(old_disk_conf);\r\ndev_info(DEV, "Peer sets u_size to %lu sectors\n",\r\n(unsigned long)my_usize);\r\n}\r\nput_ldev(mdev);\r\n}\r\nddsf = be16_to_cpu(p->dds_flags);\r\nif (get_ldev(mdev)) {\r\ndd = drbd_determine_dev_size(mdev, ddsf, NULL);\r\nput_ldev(mdev);\r\nif (dd == DS_ERROR)\r\nreturn -EIO;\r\ndrbd_md_sync(mdev);\r\n} else {\r\ndrbd_set_my_capacity(mdev, p_size);\r\n}\r\nmdev->peer_max_bio_size = be32_to_cpu(p->max_bio_size);\r\ndrbd_reconsider_max_bio_size(mdev);\r\nif (get_ldev(mdev)) {\r\nif (mdev->ldev->known_size != drbd_get_capacity(mdev->ldev->backing_bdev)) {\r\nmdev->ldev->known_size = drbd_get_capacity(mdev->ldev->backing_bdev);\r\nldsc = 1;\r\n}\r\nput_ldev(mdev);\r\n}\r\nif (mdev->state.conn > C_WF_REPORT_PARAMS) {\r\nif (be64_to_cpu(p->c_size) !=\r\ndrbd_get_capacity(mdev->this_bdev) || ldsc) {\r\ndrbd_send_sizes(mdev, 0, ddsf);\r\n}\r\nif (test_and_clear_bit(RESIZE_PENDING, &mdev->flags) ||\r\n(dd == DS_GREW && mdev->state.conn == C_CONNECTED)) {\r\nif (mdev->state.pdsk >= D_INCONSISTENT &&\r\nmdev->state.disk >= D_INCONSISTENT) {\r\nif (ddsf & DDSF_NO_RESYNC)\r\ndev_info(DEV, "Resync of new storage suppressed with --assume-clean\n");\r\nelse\r\nresync_after_online_grow(mdev);\r\n} else\r\nset_bit(RESYNC_AFTER_NEG, &mdev->flags);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int receive_uuids(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct drbd_conf *mdev;\r\nstruct p_uuids *p = pi->data;\r\nu64 *p_uuid;\r\nint i, updated_uuids = 0;\r\nmdev = vnr_to_mdev(tconn, pi->vnr);\r\nif (!mdev)\r\nreturn config_unknown_volume(tconn, pi);\r\np_uuid = kmalloc(sizeof(u64)*UI_EXTENDED_SIZE, GFP_NOIO);\r\nif (!p_uuid) {\r\ndev_err(DEV, "kmalloc of p_uuid failed\n");\r\nreturn false;\r\n}\r\nfor (i = UI_CURRENT; i < UI_EXTENDED_SIZE; i++)\r\np_uuid[i] = be64_to_cpu(p->uuid[i]);\r\nkfree(mdev->p_uuid);\r\nmdev->p_uuid = p_uuid;\r\nif (mdev->state.conn < C_CONNECTED &&\r\nmdev->state.disk < D_INCONSISTENT &&\r\nmdev->state.role == R_PRIMARY &&\r\n(mdev->ed_uuid & ~((u64)1)) != (p_uuid[UI_CURRENT] & ~((u64)1))) {\r\ndev_err(DEV, "Can only connect to data with current UUID=%016llX\n",\r\n(unsigned long long)mdev->ed_uuid);\r\nconn_request_state(mdev->tconn, NS(conn, C_DISCONNECTING), CS_HARD);\r\nreturn -EIO;\r\n}\r\nif (get_ldev(mdev)) {\r\nint skip_initial_sync =\r\nmdev->state.conn == C_CONNECTED &&\r\nmdev->tconn->agreed_pro_version >= 90 &&\r\nmdev->ldev->md.uuid[UI_CURRENT] == UUID_JUST_CREATED &&\r\n(p_uuid[UI_FLAGS] & 8);\r\nif (skip_initial_sync) {\r\ndev_info(DEV, "Accepted new current UUID, preparing to skip initial sync\n");\r\ndrbd_bitmap_io(mdev, &drbd_bmio_clear_n_write,\r\n"clear_n_write from receive_uuids",\r\nBM_LOCKED_TEST_ALLOWED);\r\n_drbd_uuid_set(mdev, UI_CURRENT, p_uuid[UI_CURRENT]);\r\n_drbd_uuid_set(mdev, UI_BITMAP, 0);\r\n_drbd_set_state(_NS2(mdev, disk, D_UP_TO_DATE, pdsk, D_UP_TO_DATE),\r\nCS_VERBOSE, NULL);\r\ndrbd_md_sync(mdev);\r\nupdated_uuids = 1;\r\n}\r\nput_ldev(mdev);\r\n} else if (mdev->state.disk < D_INCONSISTENT &&\r\nmdev->state.role == R_PRIMARY) {\r\nupdated_uuids = drbd_set_ed_uuid(mdev, p_uuid[UI_CURRENT]);\r\n}\r\nmutex_lock(mdev->state_mutex);\r\nmutex_unlock(mdev->state_mutex);\r\nif (mdev->state.conn >= C_CONNECTED && mdev->state.disk < D_INCONSISTENT)\r\nupdated_uuids |= drbd_set_ed_uuid(mdev, p_uuid[UI_CURRENT]);\r\nif (updated_uuids)\r\ndrbd_print_uuids(mdev, "receiver updated UUIDs to");\r\nreturn 0;\r\n}\r\nstatic union drbd_state convert_state(union drbd_state ps)\r\n{\r\nunion drbd_state ms;\r\nstatic enum drbd_conns c_tab[] = {\r\n[C_WF_REPORT_PARAMS] = C_WF_REPORT_PARAMS,\r\n[C_CONNECTED] = C_CONNECTED,\r\n[C_STARTING_SYNC_S] = C_STARTING_SYNC_T,\r\n[C_STARTING_SYNC_T] = C_STARTING_SYNC_S,\r\n[C_DISCONNECTING] = C_TEAR_DOWN,\r\n[C_VERIFY_S] = C_VERIFY_T,\r\n[C_MASK] = C_MASK,\r\n};\r\nms.i = ps.i;\r\nms.conn = c_tab[ps.conn];\r\nms.peer = ps.role;\r\nms.role = ps.peer;\r\nms.pdsk = ps.disk;\r\nms.disk = ps.pdsk;\r\nms.peer_isp = (ps.aftr_isp | ps.user_isp);\r\nreturn ms;\r\n}\r\nstatic int receive_req_state(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct drbd_conf *mdev;\r\nstruct p_req_state *p = pi->data;\r\nunion drbd_state mask, val;\r\nenum drbd_state_rv rv;\r\nmdev = vnr_to_mdev(tconn, pi->vnr);\r\nif (!mdev)\r\nreturn -EIO;\r\nmask.i = be32_to_cpu(p->mask);\r\nval.i = be32_to_cpu(p->val);\r\nif (test_bit(RESOLVE_CONFLICTS, &mdev->tconn->flags) &&\r\nmutex_is_locked(mdev->state_mutex)) {\r\ndrbd_send_sr_reply(mdev, SS_CONCURRENT_ST_CHG);\r\nreturn 0;\r\n}\r\nmask = convert_state(mask);\r\nval = convert_state(val);\r\nrv = drbd_change_state(mdev, CS_VERBOSE, mask, val);\r\ndrbd_send_sr_reply(mdev, rv);\r\ndrbd_md_sync(mdev);\r\nreturn 0;\r\n}\r\nstatic int receive_req_conn_state(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct p_req_state *p = pi->data;\r\nunion drbd_state mask, val;\r\nenum drbd_state_rv rv;\r\nmask.i = be32_to_cpu(p->mask);\r\nval.i = be32_to_cpu(p->val);\r\nif (test_bit(RESOLVE_CONFLICTS, &tconn->flags) &&\r\nmutex_is_locked(&tconn->cstate_mutex)) {\r\nconn_send_sr_reply(tconn, SS_CONCURRENT_ST_CHG);\r\nreturn 0;\r\n}\r\nmask = convert_state(mask);\r\nval = convert_state(val);\r\nrv = conn_request_state(tconn, mask, val, CS_VERBOSE | CS_LOCAL_ONLY | CS_IGN_OUTD_FAIL);\r\nconn_send_sr_reply(tconn, rv);\r\nreturn 0;\r\n}\r\nstatic int receive_state(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct drbd_conf *mdev;\r\nstruct p_state *p = pi->data;\r\nunion drbd_state os, ns, peer_state;\r\nenum drbd_disk_state real_peer_disk;\r\nenum chg_state_flags cs_flags;\r\nint rv;\r\nmdev = vnr_to_mdev(tconn, pi->vnr);\r\nif (!mdev)\r\nreturn config_unknown_volume(tconn, pi);\r\npeer_state.i = be32_to_cpu(p->state);\r\nreal_peer_disk = peer_state.disk;\r\nif (peer_state.disk == D_NEGOTIATING) {\r\nreal_peer_disk = mdev->p_uuid[UI_FLAGS] & 4 ? D_INCONSISTENT : D_CONSISTENT;\r\ndev_info(DEV, "real peer disk state = %s\n", drbd_disk_str(real_peer_disk));\r\n}\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nretry:\r\nos = ns = drbd_read_state(mdev);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nif (os.conn <= C_TEAR_DOWN)\r\nreturn -ECONNRESET;\r\nif ((os.pdsk == D_INCONSISTENT || os.pdsk == D_CONSISTENT) &&\r\nreal_peer_disk == D_UP_TO_DATE &&\r\nos.conn > C_CONNECTED && os.disk == D_UP_TO_DATE) {\r\nif (peer_state.conn > C_CONNECTED &&\r\npeer_state.conn < C_SYNC_SOURCE)\r\nreal_peer_disk = D_INCONSISTENT;\r\nelse if (os.conn >= C_SYNC_SOURCE &&\r\npeer_state.conn == C_CONNECTED) {\r\nif (drbd_bm_total_weight(mdev) <= mdev->rs_failed)\r\ndrbd_resync_finished(mdev);\r\nreturn 0;\r\n}\r\n}\r\nif (os.conn == C_VERIFY_T && os.disk == D_UP_TO_DATE &&\r\npeer_state.conn == C_CONNECTED && real_peer_disk == D_UP_TO_DATE) {\r\nov_out_of_sync_print(mdev);\r\ndrbd_resync_finished(mdev);\r\nreturn 0;\r\n}\r\nif (os.pdsk == D_UP_TO_DATE && real_peer_disk == D_INCONSISTENT &&\r\nos.conn == C_CONNECTED && peer_state.conn > C_SYNC_SOURCE)\r\nreal_peer_disk = D_UP_TO_DATE;\r\nif (ns.conn == C_WF_REPORT_PARAMS)\r\nns.conn = C_CONNECTED;\r\nif (peer_state.conn == C_AHEAD)\r\nns.conn = C_BEHIND;\r\nif (mdev->p_uuid && peer_state.disk >= D_NEGOTIATING &&\r\nget_ldev_if_state(mdev, D_NEGOTIATING)) {\r\nint cr;\r\ncr = (os.conn < C_CONNECTED);\r\ncr |= (os.conn == C_CONNECTED &&\r\n(peer_state.disk == D_NEGOTIATING ||\r\nos.disk == D_NEGOTIATING));\r\ncr |= test_bit(CONSIDER_RESYNC, &mdev->flags);\r\ncr |= (os.conn == C_CONNECTED &&\r\n(peer_state.conn >= C_STARTING_SYNC_S &&\r\npeer_state.conn <= C_WF_BITMAP_T));\r\nif (cr)\r\nns.conn = drbd_sync_handshake(mdev, peer_state.role, real_peer_disk);\r\nput_ldev(mdev);\r\nif (ns.conn == C_MASK) {\r\nns.conn = C_CONNECTED;\r\nif (mdev->state.disk == D_NEGOTIATING) {\r\ndrbd_force_state(mdev, NS(disk, D_FAILED));\r\n} else if (peer_state.disk == D_NEGOTIATING) {\r\ndev_err(DEV, "Disk attach process on the peer node was aborted.\n");\r\npeer_state.disk = D_DISKLESS;\r\nreal_peer_disk = D_DISKLESS;\r\n} else {\r\nif (test_and_clear_bit(CONN_DRY_RUN, &mdev->tconn->flags))\r\nreturn -EIO;\r\nD_ASSERT(os.conn == C_WF_REPORT_PARAMS);\r\nconn_request_state(mdev->tconn, NS(conn, C_DISCONNECTING), CS_HARD);\r\nreturn -EIO;\r\n}\r\n}\r\n}\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nif (os.i != drbd_read_state(mdev).i)\r\ngoto retry;\r\nclear_bit(CONSIDER_RESYNC, &mdev->flags);\r\nns.peer = peer_state.role;\r\nns.pdsk = real_peer_disk;\r\nns.peer_isp = (peer_state.aftr_isp | peer_state.user_isp);\r\nif ((ns.conn == C_CONNECTED || ns.conn == C_WF_BITMAP_S) && ns.disk == D_NEGOTIATING)\r\nns.disk = mdev->new_state_tmp.disk;\r\ncs_flags = CS_VERBOSE + (os.conn < C_CONNECTED && ns.conn >= C_CONNECTED ? 0 : CS_HARD);\r\nif (ns.pdsk == D_CONSISTENT && drbd_suspended(mdev) && ns.conn == C_CONNECTED && os.conn < C_CONNECTED &&\r\ntest_bit(NEW_CUR_UUID, &mdev->flags)) {\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\ndev_err(DEV, "Aborting Connect, can not thaw IO with an only Consistent peer\n");\r\ntl_clear(mdev->tconn);\r\ndrbd_uuid_new_current(mdev);\r\nclear_bit(NEW_CUR_UUID, &mdev->flags);\r\nconn_request_state(mdev->tconn, NS2(conn, C_PROTOCOL_ERROR, susp, 0), CS_HARD);\r\nreturn -EIO;\r\n}\r\nrv = _drbd_set_state(mdev, ns, cs_flags, NULL);\r\nns = drbd_read_state(mdev);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nif (rv < SS_SUCCESS) {\r\nconn_request_state(mdev->tconn, NS(conn, C_DISCONNECTING), CS_HARD);\r\nreturn -EIO;\r\n}\r\nif (os.conn > C_WF_REPORT_PARAMS) {\r\nif (ns.conn > C_CONNECTED && peer_state.conn <= C_CONNECTED &&\r\npeer_state.disk != D_NEGOTIATING ) {\r\ndrbd_send_uuids(mdev);\r\ndrbd_send_current_state(mdev);\r\n}\r\n}\r\nclear_bit(DISCARD_MY_DATA, &mdev->flags);\r\ndrbd_md_sync(mdev);\r\nreturn 0;\r\n}\r\nstatic int receive_sync_uuid(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct drbd_conf *mdev;\r\nstruct p_rs_uuid *p = pi->data;\r\nmdev = vnr_to_mdev(tconn, pi->vnr);\r\nif (!mdev)\r\nreturn -EIO;\r\nwait_event(mdev->misc_wait,\r\nmdev->state.conn == C_WF_SYNC_UUID ||\r\nmdev->state.conn == C_BEHIND ||\r\nmdev->state.conn < C_CONNECTED ||\r\nmdev->state.disk < D_NEGOTIATING);\r\nif (get_ldev_if_state(mdev, D_NEGOTIATING)) {\r\n_drbd_uuid_set(mdev, UI_CURRENT, be64_to_cpu(p->uuid));\r\n_drbd_uuid_set(mdev, UI_BITMAP, 0UL);\r\ndrbd_print_uuids(mdev, "updated sync uuid");\r\ndrbd_start_resync(mdev, C_SYNC_TARGET);\r\nput_ldev(mdev);\r\n} else\r\ndev_err(DEV, "Ignoring SyncUUID packet!\n");\r\nreturn 0;\r\n}\r\nstatic int\r\nreceive_bitmap_plain(struct drbd_conf *mdev, unsigned int size,\r\nunsigned long *p, struct bm_xfer_ctx *c)\r\n{\r\nunsigned int data_size = DRBD_SOCKET_BUFFER_SIZE -\r\ndrbd_header_size(mdev->tconn);\r\nunsigned int num_words = min_t(size_t, data_size / sizeof(*p),\r\nc->bm_words - c->word_offset);\r\nunsigned int want = num_words * sizeof(*p);\r\nint err;\r\nif (want != size) {\r\ndev_err(DEV, "%s:want (%u) != size (%u)\n", __func__, want, size);\r\nreturn -EIO;\r\n}\r\nif (want == 0)\r\nreturn 0;\r\nerr = drbd_recv_all(mdev->tconn, p, want);\r\nif (err)\r\nreturn err;\r\ndrbd_bm_merge_lel(mdev, c->word_offset, num_words, p);\r\nc->word_offset += num_words;\r\nc->bit_offset = c->word_offset * BITS_PER_LONG;\r\nif (c->bit_offset > c->bm_bits)\r\nc->bit_offset = c->bm_bits;\r\nreturn 1;\r\n}\r\nstatic enum drbd_bitmap_code dcbp_get_code(struct p_compressed_bm *p)\r\n{\r\nreturn (enum drbd_bitmap_code)(p->encoding & 0x0f);\r\n}\r\nstatic int dcbp_get_start(struct p_compressed_bm *p)\r\n{\r\nreturn (p->encoding & 0x80) != 0;\r\n}\r\nstatic int dcbp_get_pad_bits(struct p_compressed_bm *p)\r\n{\r\nreturn (p->encoding >> 4) & 0x7;\r\n}\r\nstatic int\r\nrecv_bm_rle_bits(struct drbd_conf *mdev,\r\nstruct p_compressed_bm *p,\r\nstruct bm_xfer_ctx *c,\r\nunsigned int len)\r\n{\r\nstruct bitstream bs;\r\nu64 look_ahead;\r\nu64 rl;\r\nu64 tmp;\r\nunsigned long s = c->bit_offset;\r\nunsigned long e;\r\nint toggle = dcbp_get_start(p);\r\nint have;\r\nint bits;\r\nbitstream_init(&bs, p->code, len, dcbp_get_pad_bits(p));\r\nbits = bitstream_get_bits(&bs, &look_ahead, 64);\r\nif (bits < 0)\r\nreturn -EIO;\r\nfor (have = bits; have > 0; s += rl, toggle = !toggle) {\r\nbits = vli_decode_bits(&rl, look_ahead);\r\nif (bits <= 0)\r\nreturn -EIO;\r\nif (toggle) {\r\ne = s + rl -1;\r\nif (e >= c->bm_bits) {\r\ndev_err(DEV, "bitmap overflow (e:%lu) while decoding bm RLE packet\n", e);\r\nreturn -EIO;\r\n}\r\n_drbd_bm_set_bits(mdev, s, e);\r\n}\r\nif (have < bits) {\r\ndev_err(DEV, "bitmap decoding error: h:%d b:%d la:0x%08llx l:%u/%u\n",\r\nhave, bits, look_ahead,\r\n(unsigned int)(bs.cur.b - p->code),\r\n(unsigned int)bs.buf_len);\r\nreturn -EIO;\r\n}\r\nlook_ahead >>= bits;\r\nhave -= bits;\r\nbits = bitstream_get_bits(&bs, &tmp, 64 - have);\r\nif (bits < 0)\r\nreturn -EIO;\r\nlook_ahead |= tmp << have;\r\nhave += bits;\r\n}\r\nc->bit_offset = s;\r\nbm_xfer_ctx_bit_to_word_offset(c);\r\nreturn (s != c->bm_bits);\r\n}\r\nstatic int\r\ndecode_bitmap_c(struct drbd_conf *mdev,\r\nstruct p_compressed_bm *p,\r\nstruct bm_xfer_ctx *c,\r\nunsigned int len)\r\n{\r\nif (dcbp_get_code(p) == RLE_VLI_Bits)\r\nreturn recv_bm_rle_bits(mdev, p, c, len - sizeof(*p));\r\ndev_err(DEV, "receive_bitmap_c: unknown encoding %u\n", p->encoding);\r\nconn_request_state(mdev->tconn, NS(conn, C_PROTOCOL_ERROR), CS_HARD);\r\nreturn -EIO;\r\n}\r\nvoid INFO_bm_xfer_stats(struct drbd_conf *mdev,\r\nconst char *direction, struct bm_xfer_ctx *c)\r\n{\r\nunsigned int header_size = drbd_header_size(mdev->tconn);\r\nunsigned int data_size = DRBD_SOCKET_BUFFER_SIZE - header_size;\r\nunsigned int plain =\r\nheader_size * (DIV_ROUND_UP(c->bm_words, data_size) + 1) +\r\nc->bm_words * sizeof(unsigned long);\r\nunsigned int total = c->bytes[0] + c->bytes[1];\r\nunsigned int r;\r\nif (total == 0)\r\nreturn;\r\nif (total >= plain)\r\nreturn;\r\nr = (total > UINT_MAX/1000) ? (total / (plain/1000))\r\n: (1000 * total / plain);\r\nif (r > 1000)\r\nr = 1000;\r\nr = 1000 - r;\r\ndev_info(DEV, "%s bitmap stats [Bytes(packets)]: plain %u(%u), RLE %u(%u), "\r\n"total %u; compression: %u.%u%%\n",\r\ndirection,\r\nc->bytes[1], c->packets[1],\r\nc->bytes[0], c->packets[0],\r\ntotal, r/10, r % 10);\r\n}\r\nstatic int receive_bitmap(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct drbd_conf *mdev;\r\nstruct bm_xfer_ctx c;\r\nint err;\r\nmdev = vnr_to_mdev(tconn, pi->vnr);\r\nif (!mdev)\r\nreturn -EIO;\r\ndrbd_bm_lock(mdev, "receive bitmap", BM_LOCKED_SET_ALLOWED);\r\nc = (struct bm_xfer_ctx) {\r\n.bm_bits = drbd_bm_bits(mdev),\r\n.bm_words = drbd_bm_words(mdev),\r\n};\r\nfor(;;) {\r\nif (pi->cmd == P_BITMAP)\r\nerr = receive_bitmap_plain(mdev, pi->size, pi->data, &c);\r\nelse if (pi->cmd == P_COMPRESSED_BITMAP) {\r\nstruct p_compressed_bm *p = pi->data;\r\nif (pi->size > DRBD_SOCKET_BUFFER_SIZE - drbd_header_size(tconn)) {\r\ndev_err(DEV, "ReportCBitmap packet too large\n");\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nif (pi->size <= sizeof(*p)) {\r\ndev_err(DEV, "ReportCBitmap packet too small (l:%u)\n", pi->size);\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nerr = drbd_recv_all(mdev->tconn, p, pi->size);\r\nif (err)\r\ngoto out;\r\nerr = decode_bitmap_c(mdev, p, &c, pi->size);\r\n} else {\r\ndev_warn(DEV, "receive_bitmap: cmd neither ReportBitMap nor ReportCBitMap (is 0x%x)", pi->cmd);\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nc.packets[pi->cmd == P_BITMAP]++;\r\nc.bytes[pi->cmd == P_BITMAP] += drbd_header_size(tconn) + pi->size;\r\nif (err <= 0) {\r\nif (err < 0)\r\ngoto out;\r\nbreak;\r\n}\r\nerr = drbd_recv_header(mdev->tconn, pi);\r\nif (err)\r\ngoto out;\r\n}\r\nINFO_bm_xfer_stats(mdev, "receive", &c);\r\nif (mdev->state.conn == C_WF_BITMAP_T) {\r\nenum drbd_state_rv rv;\r\nerr = drbd_send_bitmap(mdev);\r\nif (err)\r\ngoto out;\r\nrv = _drbd_request_state(mdev, NS(conn, C_WF_SYNC_UUID), CS_VERBOSE);\r\nD_ASSERT(rv == SS_SUCCESS);\r\n} else if (mdev->state.conn != C_WF_BITMAP_S) {\r\ndev_info(DEV, "unexpected cstate (%s) in receive_bitmap\n",\r\ndrbd_conn_str(mdev->state.conn));\r\n}\r\nerr = 0;\r\nout:\r\ndrbd_bm_unlock(mdev);\r\nif (!err && mdev->state.conn == C_WF_BITMAP_S)\r\ndrbd_start_resync(mdev, C_SYNC_SOURCE);\r\nreturn err;\r\n}\r\nstatic int receive_skip(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nconn_warn(tconn, "skipping unknown optional packet type %d, l: %d!\n",\r\npi->cmd, pi->size);\r\nreturn ignore_remaining_packet(tconn, pi);\r\n}\r\nstatic int receive_UnplugRemote(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\ndrbd_tcp_quickack(tconn->data.socket);\r\nreturn 0;\r\n}\r\nstatic int receive_out_of_sync(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct drbd_conf *mdev;\r\nstruct p_block_desc *p = pi->data;\r\nmdev = vnr_to_mdev(tconn, pi->vnr);\r\nif (!mdev)\r\nreturn -EIO;\r\nswitch (mdev->state.conn) {\r\ncase C_WF_SYNC_UUID:\r\ncase C_WF_BITMAP_T:\r\ncase C_BEHIND:\r\nbreak;\r\ndefault:\r\ndev_err(DEV, "ASSERT FAILED cstate = %s, expected: WFSyncUUID|WFBitMapT|Behind\n",\r\ndrbd_conn_str(mdev->state.conn));\r\n}\r\ndrbd_set_out_of_sync(mdev, be64_to_cpu(p->sector), be32_to_cpu(p->blksize));\r\nreturn 0;\r\n}\r\nstatic void drbdd(struct drbd_tconn *tconn)\r\n{\r\nstruct packet_info pi;\r\nsize_t shs;\r\nint err;\r\nwhile (get_t_state(&tconn->receiver) == RUNNING) {\r\nstruct data_cmd *cmd;\r\ndrbd_thread_current_set_cpu(&tconn->receiver);\r\nif (drbd_recv_header(tconn, &pi))\r\ngoto err_out;\r\ncmd = &drbd_cmd_handler[pi.cmd];\r\nif (unlikely(pi.cmd >= ARRAY_SIZE(drbd_cmd_handler) || !cmd->fn)) {\r\nconn_err(tconn, "Unexpected data packet %s (0x%04x)",\r\ncmdname(pi.cmd), pi.cmd);\r\ngoto err_out;\r\n}\r\nshs = cmd->pkt_size;\r\nif (pi.size > shs && !cmd->expect_payload) {\r\nconn_err(tconn, "No payload expected %s l:%d\n",\r\ncmdname(pi.cmd), pi.size);\r\ngoto err_out;\r\n}\r\nif (shs) {\r\nerr = drbd_recv_all_warn(tconn, pi.data, shs);\r\nif (err)\r\ngoto err_out;\r\npi.size -= shs;\r\n}\r\nerr = cmd->fn(tconn, &pi);\r\nif (err) {\r\nconn_err(tconn, "error receiving %s, e: %d l: %d!\n",\r\ncmdname(pi.cmd), err, pi.size);\r\ngoto err_out;\r\n}\r\n}\r\nreturn;\r\nerr_out:\r\nconn_request_state(tconn, NS(conn, C_PROTOCOL_ERROR), CS_HARD);\r\n}\r\nvoid conn_flush_workqueue(struct drbd_tconn *tconn)\r\n{\r\nstruct drbd_wq_barrier barr;\r\nbarr.w.cb = w_prev_work_done;\r\nbarr.w.tconn = tconn;\r\ninit_completion(&barr.done);\r\ndrbd_queue_work(&tconn->sender_work, &barr.w);\r\nwait_for_completion(&barr.done);\r\n}\r\nstatic void conn_disconnect(struct drbd_tconn *tconn)\r\n{\r\nstruct drbd_conf *mdev;\r\nenum drbd_conns oc;\r\nint vnr;\r\nif (tconn->cstate == C_STANDALONE)\r\nreturn;\r\nconn_request_state(tconn, NS(conn, C_NETWORK_FAILURE), CS_HARD);\r\ndrbd_thread_stop(&tconn->asender);\r\ndrbd_free_sock(tconn);\r\nrcu_read_lock();\r\nidr_for_each_entry(&tconn->volumes, mdev, vnr) {\r\nkref_get(&mdev->kref);\r\nrcu_read_unlock();\r\ndrbd_disconnected(mdev);\r\nkref_put(&mdev->kref, &drbd_minor_destroy);\r\nrcu_read_lock();\r\n}\r\nrcu_read_unlock();\r\nif (!list_empty(&tconn->current_epoch->list))\r\nconn_err(tconn, "ASSERTION FAILED: tconn->current_epoch->list not empty\n");\r\natomic_set(&tconn->current_epoch->epoch_size, 0);\r\ntconn->send.seen_any_write_yet = false;\r\nconn_info(tconn, "Connection closed\n");\r\nif (conn_highest_role(tconn) == R_PRIMARY && conn_highest_pdsk(tconn) >= D_UNKNOWN)\r\nconn_try_outdate_peer_async(tconn);\r\nspin_lock_irq(&tconn->req_lock);\r\noc = tconn->cstate;\r\nif (oc >= C_UNCONNECTED)\r\n_conn_request_state(tconn, NS(conn, C_UNCONNECTED), CS_VERBOSE);\r\nspin_unlock_irq(&tconn->req_lock);\r\nif (oc == C_DISCONNECTING)\r\nconn_request_state(tconn, NS(conn, C_STANDALONE), CS_VERBOSE | CS_HARD);\r\n}\r\nstatic int drbd_disconnected(struct drbd_conf *mdev)\r\n{\r\nunsigned int i;\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\n_drbd_wait_ee_list_empty(mdev, &mdev->active_ee);\r\n_drbd_wait_ee_list_empty(mdev, &mdev->sync_ee);\r\n_drbd_wait_ee_list_empty(mdev, &mdev->read_ee);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\ndrbd_rs_cancel_all(mdev);\r\nmdev->rs_total = 0;\r\nmdev->rs_failed = 0;\r\natomic_set(&mdev->rs_pending_cnt, 0);\r\nwake_up(&mdev->misc_wait);\r\ndel_timer_sync(&mdev->resync_timer);\r\nresync_timer_fn((unsigned long)mdev);\r\ndrbd_flush_workqueue(mdev);\r\ndrbd_finish_peer_reqs(mdev);\r\ndrbd_flush_workqueue(mdev);\r\ndrbd_rs_cancel_all(mdev);\r\nkfree(mdev->p_uuid);\r\nmdev->p_uuid = NULL;\r\nif (!drbd_suspended(mdev))\r\ntl_clear(mdev->tconn);\r\ndrbd_md_sync(mdev);\r\nwait_event(mdev->misc_wait, !test_bit(BITMAP_IO, &mdev->flags));\r\ni = drbd_free_peer_reqs(mdev, &mdev->net_ee);\r\nif (i)\r\ndev_info(DEV, "net_ee not empty, killed %u entries\n", i);\r\ni = atomic_read(&mdev->pp_in_use_by_net);\r\nif (i)\r\ndev_info(DEV, "pp_in_use_by_net = %d, expected 0\n", i);\r\ni = atomic_read(&mdev->pp_in_use);\r\nif (i)\r\ndev_info(DEV, "pp_in_use = %d, expected 0\n", i);\r\nD_ASSERT(list_empty(&mdev->read_ee));\r\nD_ASSERT(list_empty(&mdev->active_ee));\r\nD_ASSERT(list_empty(&mdev->sync_ee));\r\nD_ASSERT(list_empty(&mdev->done_ee));\r\nreturn 0;\r\n}\r\nstatic int drbd_send_features(struct drbd_tconn *tconn)\r\n{\r\nstruct drbd_socket *sock;\r\nstruct p_connection_features *p;\r\nsock = &tconn->data;\r\np = conn_prepare_command(tconn, sock);\r\nif (!p)\r\nreturn -EIO;\r\nmemset(p, 0, sizeof(*p));\r\np->protocol_min = cpu_to_be32(PRO_VERSION_MIN);\r\np->protocol_max = cpu_to_be32(PRO_VERSION_MAX);\r\nreturn conn_send_command(tconn, sock, P_CONNECTION_FEATURES, sizeof(*p), NULL, 0);\r\n}\r\nstatic int drbd_do_features(struct drbd_tconn *tconn)\r\n{\r\nstruct p_connection_features *p;\r\nconst int expect = sizeof(struct p_connection_features);\r\nstruct packet_info pi;\r\nint err;\r\nerr = drbd_send_features(tconn);\r\nif (err)\r\nreturn 0;\r\nerr = drbd_recv_header(tconn, &pi);\r\nif (err)\r\nreturn 0;\r\nif (pi.cmd != P_CONNECTION_FEATURES) {\r\nconn_err(tconn, "expected ConnectionFeatures packet, received: %s (0x%04x)\n",\r\ncmdname(pi.cmd), pi.cmd);\r\nreturn -1;\r\n}\r\nif (pi.size != expect) {\r\nconn_err(tconn, "expected ConnectionFeatures length: %u, received: %u\n",\r\nexpect, pi.size);\r\nreturn -1;\r\n}\r\np = pi.data;\r\nerr = drbd_recv_all_warn(tconn, p, expect);\r\nif (err)\r\nreturn 0;\r\np->protocol_min = be32_to_cpu(p->protocol_min);\r\np->protocol_max = be32_to_cpu(p->protocol_max);\r\nif (p->protocol_max == 0)\r\np->protocol_max = p->protocol_min;\r\nif (PRO_VERSION_MAX < p->protocol_min ||\r\nPRO_VERSION_MIN > p->protocol_max)\r\ngoto incompat;\r\ntconn->agreed_pro_version = min_t(int, PRO_VERSION_MAX, p->protocol_max);\r\nconn_info(tconn, "Handshake successful: "\r\n"Agreed network protocol version %d\n", tconn->agreed_pro_version);\r\nreturn 1;\r\nincompat:\r\nconn_err(tconn, "incompatible DRBD dialects: "\r\n"I support %d-%d, peer supports %d-%d\n",\r\nPRO_VERSION_MIN, PRO_VERSION_MAX,\r\np->protocol_min, p->protocol_max);\r\nreturn -1;\r\n}\r\nstatic int drbd_do_auth(struct drbd_tconn *tconn)\r\n{\r\nconn_err(tconn, "This kernel was build without CONFIG_CRYPTO_HMAC.\n");\r\nconn_err(tconn, "You need to disable 'cram-hmac-alg' in drbd.conf.\n");\r\nreturn -1;\r\n}\r\nstatic int drbd_do_auth(struct drbd_tconn *tconn)\r\n{\r\nstruct drbd_socket *sock;\r\nchar my_challenge[CHALLENGE_LEN];\r\nstruct scatterlist sg;\r\nchar *response = NULL;\r\nchar *right_response = NULL;\r\nchar *peers_ch = NULL;\r\nunsigned int key_len;\r\nchar secret[SHARED_SECRET_MAX];\r\nunsigned int resp_size;\r\nstruct hash_desc desc;\r\nstruct packet_info pi;\r\nstruct net_conf *nc;\r\nint err, rv;\r\nrcu_read_lock();\r\nnc = rcu_dereference(tconn->net_conf);\r\nkey_len = strlen(nc->shared_secret);\r\nmemcpy(secret, nc->shared_secret, key_len);\r\nrcu_read_unlock();\r\ndesc.tfm = tconn->cram_hmac_tfm;\r\ndesc.flags = 0;\r\nrv = crypto_hash_setkey(tconn->cram_hmac_tfm, (u8 *)secret, key_len);\r\nif (rv) {\r\nconn_err(tconn, "crypto_hash_setkey() failed with %d\n", rv);\r\nrv = -1;\r\ngoto fail;\r\n}\r\nget_random_bytes(my_challenge, CHALLENGE_LEN);\r\nsock = &tconn->data;\r\nif (!conn_prepare_command(tconn, sock)) {\r\nrv = 0;\r\ngoto fail;\r\n}\r\nrv = !conn_send_command(tconn, sock, P_AUTH_CHALLENGE, 0,\r\nmy_challenge, CHALLENGE_LEN);\r\nif (!rv)\r\ngoto fail;\r\nerr = drbd_recv_header(tconn, &pi);\r\nif (err) {\r\nrv = 0;\r\ngoto fail;\r\n}\r\nif (pi.cmd != P_AUTH_CHALLENGE) {\r\nconn_err(tconn, "expected AuthChallenge packet, received: %s (0x%04x)\n",\r\ncmdname(pi.cmd), pi.cmd);\r\nrv = 0;\r\ngoto fail;\r\n}\r\nif (pi.size > CHALLENGE_LEN * 2) {\r\nconn_err(tconn, "expected AuthChallenge payload too big.\n");\r\nrv = -1;\r\ngoto fail;\r\n}\r\npeers_ch = kmalloc(pi.size, GFP_NOIO);\r\nif (peers_ch == NULL) {\r\nconn_err(tconn, "kmalloc of peers_ch failed\n");\r\nrv = -1;\r\ngoto fail;\r\n}\r\nerr = drbd_recv_all_warn(tconn, peers_ch, pi.size);\r\nif (err) {\r\nrv = 0;\r\ngoto fail;\r\n}\r\nresp_size = crypto_hash_digestsize(tconn->cram_hmac_tfm);\r\nresponse = kmalloc(resp_size, GFP_NOIO);\r\nif (response == NULL) {\r\nconn_err(tconn, "kmalloc of response failed\n");\r\nrv = -1;\r\ngoto fail;\r\n}\r\nsg_init_table(&sg, 1);\r\nsg_set_buf(&sg, peers_ch, pi.size);\r\nrv = crypto_hash_digest(&desc, &sg, sg.length, response);\r\nif (rv) {\r\nconn_err(tconn, "crypto_hash_digest() failed with %d\n", rv);\r\nrv = -1;\r\ngoto fail;\r\n}\r\nif (!conn_prepare_command(tconn, sock)) {\r\nrv = 0;\r\ngoto fail;\r\n}\r\nrv = !conn_send_command(tconn, sock, P_AUTH_RESPONSE, 0,\r\nresponse, resp_size);\r\nif (!rv)\r\ngoto fail;\r\nerr = drbd_recv_header(tconn, &pi);\r\nif (err) {\r\nrv = 0;\r\ngoto fail;\r\n}\r\nif (pi.cmd != P_AUTH_RESPONSE) {\r\nconn_err(tconn, "expected AuthResponse packet, received: %s (0x%04x)\n",\r\ncmdname(pi.cmd), pi.cmd);\r\nrv = 0;\r\ngoto fail;\r\n}\r\nif (pi.size != resp_size) {\r\nconn_err(tconn, "expected AuthResponse payload of wrong size\n");\r\nrv = 0;\r\ngoto fail;\r\n}\r\nerr = drbd_recv_all_warn(tconn, response , resp_size);\r\nif (err) {\r\nrv = 0;\r\ngoto fail;\r\n}\r\nright_response = kmalloc(resp_size, GFP_NOIO);\r\nif (right_response == NULL) {\r\nconn_err(tconn, "kmalloc of right_response failed\n");\r\nrv = -1;\r\ngoto fail;\r\n}\r\nsg_set_buf(&sg, my_challenge, CHALLENGE_LEN);\r\nrv = crypto_hash_digest(&desc, &sg, sg.length, right_response);\r\nif (rv) {\r\nconn_err(tconn, "crypto_hash_digest() failed with %d\n", rv);\r\nrv = -1;\r\ngoto fail;\r\n}\r\nrv = !memcmp(response, right_response, resp_size);\r\nif (rv)\r\nconn_info(tconn, "Peer authenticated using %d bytes HMAC\n",\r\nresp_size);\r\nelse\r\nrv = -1;\r\nfail:\r\nkfree(peers_ch);\r\nkfree(response);\r\nkfree(right_response);\r\nreturn rv;\r\n}\r\nint drbdd_init(struct drbd_thread *thi)\r\n{\r\nstruct drbd_tconn *tconn = thi->tconn;\r\nint h;\r\nconn_info(tconn, "receiver (re)started\n");\r\ndo {\r\nh = conn_connect(tconn);\r\nif (h == 0) {\r\nconn_disconnect(tconn);\r\nschedule_timeout_interruptible(HZ);\r\n}\r\nif (h == -1) {\r\nconn_warn(tconn, "Discarding network configuration.\n");\r\nconn_request_state(tconn, NS(conn, C_DISCONNECTING), CS_HARD);\r\n}\r\n} while (h == 0);\r\nif (h > 0)\r\ndrbdd(tconn);\r\nconn_disconnect(tconn);\r\nconn_info(tconn, "receiver terminated\n");\r\nreturn 0;\r\n}\r\nstatic int got_conn_RqSReply(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct p_req_state_reply *p = pi->data;\r\nint retcode = be32_to_cpu(p->retcode);\r\nif (retcode >= SS_SUCCESS) {\r\nset_bit(CONN_WD_ST_CHG_OKAY, &tconn->flags);\r\n} else {\r\nset_bit(CONN_WD_ST_CHG_FAIL, &tconn->flags);\r\nconn_err(tconn, "Requested state change failed by peer: %s (%d)\n",\r\ndrbd_set_st_err_str(retcode), retcode);\r\n}\r\nwake_up(&tconn->ping_wait);\r\nreturn 0;\r\n}\r\nstatic int got_RqSReply(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct drbd_conf *mdev;\r\nstruct p_req_state_reply *p = pi->data;\r\nint retcode = be32_to_cpu(p->retcode);\r\nmdev = vnr_to_mdev(tconn, pi->vnr);\r\nif (!mdev)\r\nreturn -EIO;\r\nif (test_bit(CONN_WD_ST_CHG_REQ, &tconn->flags)) {\r\nD_ASSERT(tconn->agreed_pro_version < 100);\r\nreturn got_conn_RqSReply(tconn, pi);\r\n}\r\nif (retcode >= SS_SUCCESS) {\r\nset_bit(CL_ST_CHG_SUCCESS, &mdev->flags);\r\n} else {\r\nset_bit(CL_ST_CHG_FAIL, &mdev->flags);\r\ndev_err(DEV, "Requested state change failed by peer: %s (%d)\n",\r\ndrbd_set_st_err_str(retcode), retcode);\r\n}\r\nwake_up(&mdev->state_wait);\r\nreturn 0;\r\n}\r\nstatic int got_Ping(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nreturn drbd_send_ping_ack(tconn);\r\n}\r\nstatic int got_PingAck(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\ntconn->meta.socket->sk->sk_rcvtimeo = tconn->net_conf->ping_int*HZ;\r\nif (!test_and_set_bit(GOT_PING_ACK, &tconn->flags))\r\nwake_up(&tconn->ping_wait);\r\nreturn 0;\r\n}\r\nstatic int got_IsInSync(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct drbd_conf *mdev;\r\nstruct p_block_ack *p = pi->data;\r\nsector_t sector = be64_to_cpu(p->sector);\r\nint blksize = be32_to_cpu(p->blksize);\r\nmdev = vnr_to_mdev(tconn, pi->vnr);\r\nif (!mdev)\r\nreturn -EIO;\r\nD_ASSERT(mdev->tconn->agreed_pro_version >= 89);\r\nupdate_peer_seq(mdev, be32_to_cpu(p->seq_num));\r\nif (get_ldev(mdev)) {\r\ndrbd_rs_complete_io(mdev, sector);\r\ndrbd_set_in_sync(mdev, sector, blksize);\r\nmdev->rs_same_csum += (blksize >> BM_BLOCK_SHIFT);\r\nput_ldev(mdev);\r\n}\r\ndec_rs_pending(mdev);\r\natomic_add(blksize >> 9, &mdev->rs_sect_in);\r\nreturn 0;\r\n}\r\nstatic int\r\nvalidate_req_change_req_state(struct drbd_conf *mdev, u64 id, sector_t sector,\r\nstruct rb_root *root, const char *func,\r\nenum drbd_req_event what, bool missing_ok)\r\n{\r\nstruct drbd_request *req;\r\nstruct bio_and_error m;\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nreq = find_request(mdev, root, id, sector, missing_ok, func);\r\nif (unlikely(!req)) {\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nreturn -EIO;\r\n}\r\n__req_mod(req, what, &m);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nif (m.bio)\r\ncomplete_master_bio(mdev, &m);\r\nreturn 0;\r\n}\r\nstatic int got_BlockAck(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct drbd_conf *mdev;\r\nstruct p_block_ack *p = pi->data;\r\nsector_t sector = be64_to_cpu(p->sector);\r\nint blksize = be32_to_cpu(p->blksize);\r\nenum drbd_req_event what;\r\nmdev = vnr_to_mdev(tconn, pi->vnr);\r\nif (!mdev)\r\nreturn -EIO;\r\nupdate_peer_seq(mdev, be32_to_cpu(p->seq_num));\r\nif (p->block_id == ID_SYNCER) {\r\ndrbd_set_in_sync(mdev, sector, blksize);\r\ndec_rs_pending(mdev);\r\nreturn 0;\r\n}\r\nswitch (pi->cmd) {\r\ncase P_RS_WRITE_ACK:\r\nwhat = WRITE_ACKED_BY_PEER_AND_SIS;\r\nbreak;\r\ncase P_WRITE_ACK:\r\nwhat = WRITE_ACKED_BY_PEER;\r\nbreak;\r\ncase P_RECV_ACK:\r\nwhat = RECV_ACKED_BY_PEER;\r\nbreak;\r\ncase P_SUPERSEDED:\r\nwhat = CONFLICT_RESOLVED;\r\nbreak;\r\ncase P_RETRY_WRITE:\r\nwhat = POSTPONE_WRITE;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn validate_req_change_req_state(mdev, p->block_id, sector,\r\n&mdev->write_requests, __func__,\r\nwhat, false);\r\n}\r\nstatic int got_NegAck(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct drbd_conf *mdev;\r\nstruct p_block_ack *p = pi->data;\r\nsector_t sector = be64_to_cpu(p->sector);\r\nint size = be32_to_cpu(p->blksize);\r\nint err;\r\nmdev = vnr_to_mdev(tconn, pi->vnr);\r\nif (!mdev)\r\nreturn -EIO;\r\nupdate_peer_seq(mdev, be32_to_cpu(p->seq_num));\r\nif (p->block_id == ID_SYNCER) {\r\ndec_rs_pending(mdev);\r\ndrbd_rs_failed_io(mdev, sector, size);\r\nreturn 0;\r\n}\r\nerr = validate_req_change_req_state(mdev, p->block_id, sector,\r\n&mdev->write_requests, __func__,\r\nNEG_ACKED, true);\r\nif (err) {\r\ndrbd_set_out_of_sync(mdev, sector, size);\r\n}\r\nreturn 0;\r\n}\r\nstatic int got_NegDReply(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct drbd_conf *mdev;\r\nstruct p_block_ack *p = pi->data;\r\nsector_t sector = be64_to_cpu(p->sector);\r\nmdev = vnr_to_mdev(tconn, pi->vnr);\r\nif (!mdev)\r\nreturn -EIO;\r\nupdate_peer_seq(mdev, be32_to_cpu(p->seq_num));\r\ndev_err(DEV, "Got NegDReply; Sector %llus, len %u.\n",\r\n(unsigned long long)sector, be32_to_cpu(p->blksize));\r\nreturn validate_req_change_req_state(mdev, p->block_id, sector,\r\n&mdev->read_requests, __func__,\r\nNEG_ACKED, false);\r\n}\r\nstatic int got_NegRSDReply(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct drbd_conf *mdev;\r\nsector_t sector;\r\nint size;\r\nstruct p_block_ack *p = pi->data;\r\nmdev = vnr_to_mdev(tconn, pi->vnr);\r\nif (!mdev)\r\nreturn -EIO;\r\nsector = be64_to_cpu(p->sector);\r\nsize = be32_to_cpu(p->blksize);\r\nupdate_peer_seq(mdev, be32_to_cpu(p->seq_num));\r\ndec_rs_pending(mdev);\r\nif (get_ldev_if_state(mdev, D_FAILED)) {\r\ndrbd_rs_complete_io(mdev, sector);\r\nswitch (pi->cmd) {\r\ncase P_NEG_RS_DREPLY:\r\ndrbd_rs_failed_io(mdev, sector, size);\r\ncase P_RS_CANCEL:\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nput_ldev(mdev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int got_BarrierAck(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct p_barrier_ack *p = pi->data;\r\nstruct drbd_conf *mdev;\r\nint vnr;\r\ntl_release(tconn, p->barrier, be32_to_cpu(p->set_size));\r\nrcu_read_lock();\r\nidr_for_each_entry(&tconn->volumes, mdev, vnr) {\r\nif (mdev->state.conn == C_AHEAD &&\r\natomic_read(&mdev->ap_in_flight) == 0 &&\r\n!test_and_set_bit(AHEAD_TO_SYNC_SOURCE, &mdev->flags)) {\r\nmdev->start_resync_timer.expires = jiffies + HZ;\r\nadd_timer(&mdev->start_resync_timer);\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic int got_OVResult(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nstruct drbd_conf *mdev;\r\nstruct p_block_ack *p = pi->data;\r\nstruct drbd_work *w;\r\nsector_t sector;\r\nint size;\r\nmdev = vnr_to_mdev(tconn, pi->vnr);\r\nif (!mdev)\r\nreturn -EIO;\r\nsector = be64_to_cpu(p->sector);\r\nsize = be32_to_cpu(p->blksize);\r\nupdate_peer_seq(mdev, be32_to_cpu(p->seq_num));\r\nif (be64_to_cpu(p->block_id) == ID_OUT_OF_SYNC)\r\ndrbd_ov_out_of_sync_found(mdev, sector, size);\r\nelse\r\nov_out_of_sync_print(mdev);\r\nif (!get_ldev(mdev))\r\nreturn 0;\r\ndrbd_rs_complete_io(mdev, sector);\r\ndec_rs_pending(mdev);\r\n--mdev->ov_left;\r\nif ((mdev->ov_left & 0x200) == 0x200)\r\ndrbd_advance_rs_marks(mdev, mdev->ov_left);\r\nif (mdev->ov_left == 0) {\r\nw = kmalloc(sizeof(*w), GFP_NOIO);\r\nif (w) {\r\nw->cb = w_ov_finished;\r\nw->mdev = mdev;\r\ndrbd_queue_work(&mdev->tconn->sender_work, w);\r\n} else {\r\ndev_err(DEV, "kmalloc(w) failed.");\r\nov_out_of_sync_print(mdev);\r\ndrbd_resync_finished(mdev);\r\n}\r\n}\r\nput_ldev(mdev);\r\nreturn 0;\r\n}\r\nstatic int got_skip(struct drbd_tconn *tconn, struct packet_info *pi)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tconn_finish_peer_reqs(struct drbd_tconn *tconn)\r\n{\r\nstruct drbd_conf *mdev;\r\nint vnr, not_empty = 0;\r\ndo {\r\nclear_bit(SIGNAL_ASENDER, &tconn->flags);\r\nflush_signals(current);\r\nrcu_read_lock();\r\nidr_for_each_entry(&tconn->volumes, mdev, vnr) {\r\nkref_get(&mdev->kref);\r\nrcu_read_unlock();\r\nif (drbd_finish_peer_reqs(mdev)) {\r\nkref_put(&mdev->kref, &drbd_minor_destroy);\r\nreturn 1;\r\n}\r\nkref_put(&mdev->kref, &drbd_minor_destroy);\r\nrcu_read_lock();\r\n}\r\nset_bit(SIGNAL_ASENDER, &tconn->flags);\r\nspin_lock_irq(&tconn->req_lock);\r\nidr_for_each_entry(&tconn->volumes, mdev, vnr) {\r\nnot_empty = !list_empty(&mdev->done_ee);\r\nif (not_empty)\r\nbreak;\r\n}\r\nspin_unlock_irq(&tconn->req_lock);\r\nrcu_read_unlock();\r\n} while (not_empty);\r\nreturn 0;\r\n}\r\nint drbd_asender(struct drbd_thread *thi)\r\n{\r\nstruct drbd_tconn *tconn = thi->tconn;\r\nstruct asender_cmd *cmd = NULL;\r\nstruct packet_info pi;\r\nint rv;\r\nvoid *buf = tconn->meta.rbuf;\r\nint received = 0;\r\nunsigned int header_size = drbd_header_size(tconn);\r\nint expect = header_size;\r\nbool ping_timeout_active = false;\r\nstruct net_conf *nc;\r\nint ping_timeo, tcp_cork, ping_int;\r\nstruct sched_param param = { .sched_priority = 2 };\r\nrv = sched_setscheduler(current, SCHED_RR, &param);\r\nif (rv < 0)\r\nconn_err(tconn, "drbd_asender: ERROR set priority, ret=%d\n", rv);\r\nwhile (get_t_state(thi) == RUNNING) {\r\ndrbd_thread_current_set_cpu(thi);\r\nrcu_read_lock();\r\nnc = rcu_dereference(tconn->net_conf);\r\nping_timeo = nc->ping_timeo;\r\ntcp_cork = nc->tcp_cork;\r\nping_int = nc->ping_int;\r\nrcu_read_unlock();\r\nif (test_and_clear_bit(SEND_PING, &tconn->flags)) {\r\nif (drbd_send_ping(tconn)) {\r\nconn_err(tconn, "drbd_send_ping has failed\n");\r\ngoto reconnect;\r\n}\r\ntconn->meta.socket->sk->sk_rcvtimeo = ping_timeo * HZ / 10;\r\nping_timeout_active = true;\r\n}\r\nif (tcp_cork)\r\ndrbd_tcp_cork(tconn->meta.socket);\r\nif (tconn_finish_peer_reqs(tconn)) {\r\nconn_err(tconn, "tconn_finish_peer_reqs() failed\n");\r\ngoto reconnect;\r\n}\r\nif (tcp_cork)\r\ndrbd_tcp_uncork(tconn->meta.socket);\r\nif (signal_pending(current))\r\ncontinue;\r\nrv = drbd_recv_short(tconn->meta.socket, buf, expect-received, 0);\r\nclear_bit(SIGNAL_ASENDER, &tconn->flags);\r\nflush_signals(current);\r\nif (likely(rv > 0)) {\r\nreceived += rv;\r\nbuf += rv;\r\n} else if (rv == 0) {\r\nif (test_bit(DISCONNECT_SENT, &tconn->flags)) {\r\nlong t;\r\nrcu_read_lock();\r\nt = rcu_dereference(tconn->net_conf)->ping_timeo * HZ/10;\r\nrcu_read_unlock();\r\nt = wait_event_timeout(tconn->ping_wait,\r\ntconn->cstate < C_WF_REPORT_PARAMS,\r\nt);\r\nif (t)\r\nbreak;\r\n}\r\nconn_err(tconn, "meta connection shut down by peer.\n");\r\ngoto reconnect;\r\n} else if (rv == -EAGAIN) {\r\nif (time_after(tconn->last_received,\r\njiffies - tconn->meta.socket->sk->sk_rcvtimeo))\r\ncontinue;\r\nif (ping_timeout_active) {\r\nconn_err(tconn, "PingAck did not arrive in time.\n");\r\ngoto reconnect;\r\n}\r\nset_bit(SEND_PING, &tconn->flags);\r\ncontinue;\r\n} else if (rv == -EINTR) {\r\ncontinue;\r\n} else {\r\nconn_err(tconn, "sock_recvmsg returned %d\n", rv);\r\ngoto reconnect;\r\n}\r\nif (received == expect && cmd == NULL) {\r\nif (decode_header(tconn, tconn->meta.rbuf, &pi))\r\ngoto reconnect;\r\ncmd = &asender_tbl[pi.cmd];\r\nif (pi.cmd >= ARRAY_SIZE(asender_tbl) || !cmd->fn) {\r\nconn_err(tconn, "Unexpected meta packet %s (0x%04x)\n",\r\ncmdname(pi.cmd), pi.cmd);\r\ngoto disconnect;\r\n}\r\nexpect = header_size + cmd->pkt_size;\r\nif (pi.size != expect - header_size) {\r\nconn_err(tconn, "Wrong packet size on meta (c: %d, l: %d)\n",\r\npi.cmd, pi.size);\r\ngoto reconnect;\r\n}\r\n}\r\nif (received == expect) {\r\nbool err;\r\nerr = cmd->fn(tconn, &pi);\r\nif (err) {\r\nconn_err(tconn, "%pf failed\n", cmd->fn);\r\ngoto reconnect;\r\n}\r\ntconn->last_received = jiffies;\r\nif (cmd == &asender_tbl[P_PING_ACK]) {\r\ntconn->meta.socket->sk->sk_rcvtimeo = ping_int * HZ;\r\nping_timeout_active = false;\r\n}\r\nbuf = tconn->meta.rbuf;\r\nreceived = 0;\r\nexpect = header_size;\r\ncmd = NULL;\r\n}\r\n}\r\nif (0) {\r\nreconnect:\r\nconn_request_state(tconn, NS(conn, C_NETWORK_FAILURE), CS_HARD);\r\nconn_md_sync(tconn);\r\n}\r\nif (0) {\r\ndisconnect:\r\nconn_request_state(tconn, NS(conn, C_DISCONNECTING), CS_HARD);\r\n}\r\nclear_bit(SIGNAL_ASENDER, &tconn->flags);\r\nconn_info(tconn, "asender terminated\n");\r\nreturn 0;\r\n}
