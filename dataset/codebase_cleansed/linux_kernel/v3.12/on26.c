static int on26_read_regr( PIA *pi, int cont, int regr )\r\n{ int a, b, r;\r\nr = (regr<<2) + 1 + cont;\r\nswitch (pi->mode) {\r\ncase 0: w0(1); P1; w0(r); P2; w0(0); P1;\r\nw2(6); a = r1(); w2(4);\r\nw2(6); b = r1(); w2(4);\r\nw2(6); w2(4); w2(6); w2(4);\r\nreturn j44(a,b);\r\ncase 1: w0(1); P1; w0(r); P2; w0(0); P1;\r\nw2(0x26); a = r0(); w2(4); w2(0x26); w2(4);\r\nreturn a;\r\ncase 2:\r\ncase 3:\r\ncase 4: w3(1); w3(1); w2(5); w4(r); w2(4);\r\nw3(0); w3(0); w2(0x24); a = r4(); w2(4);\r\nw2(0x24); (void)r4(); w2(4);\r\nreturn a;\r\n}\r\nreturn -1;\r\n}\r\nstatic void on26_write_regr( PIA *pi, int cont, int regr, int val )\r\n{ int r;\r\nr = (regr<<2) + 1 + cont;\r\nswitch (pi->mode) {\r\ncase 0:\r\ncase 1: w0(1); P1; w0(r); P2; w0(0); P1;\r\nw0(val); P2; w0(val); P2;\r\nbreak;\r\ncase 2:\r\ncase 3:\r\ncase 4: w3(1); w3(1); w2(5); w4(r); w2(4);\r\nw3(0); w3(0);\r\nw2(5); w4(val); w2(4);\r\nw2(5); w4(val); w2(4);\r\nbreak;\r\n}\r\n}\r\nstatic void on26_connect ( PIA *pi )\r\n{ int x;\r\npi->saved_r0 = r0();\r\npi->saved_r2 = r2();\r\nCCP(0x20);\r\nx = 8; if (pi->mode) x = 9;\r\nw0(2); P1; w0(8); P2;\r\nw0(2); P1; w0(x); P2;\r\n}\r\nstatic void on26_disconnect ( PIA *pi )\r\n{ if (pi->mode >= 2) { w3(4); w3(4); w3(4); w3(4); }\r\nelse { w0(4); P1; w0(4); P1; }\r\nCCP(0x30);\r\nw0(pi->saved_r0);\r\nw2(pi->saved_r2);\r\n}\r\nstatic int on26_test_port( PIA *pi)\r\n{ int i, m, d, x=0, y=0;\r\npi->saved_r0 = r0();\r\npi->saved_r2 = r2();\r\nd = pi->delay;\r\nm = pi->mode;\r\npi->delay = 5;\r\npi->mode = 0;\r\nw2(0xc);\r\nCCP(0x30); CCP(0);\r\nw0(0xfe);w0(0xaa);w0(0x55);w0(0);w0(0xff);\r\ni = ((r1() & 0xf0) << 4); w0(0x87);\r\ni |= (r1() & 0xf0); w0(0x78);\r\nw0(0x20);w2(4);w2(5);\r\ni |= ((r1() & 0xf0) >> 4);\r\nw2(4);w0(0xff);\r\nif (i == 0xb5f) {\r\nw0(2); P1; w0(0); P2;\r\nw0(3); P1; w0(0); P2;\r\nw0(2); P1; w0(8); P2; udelay(100);\r\nw0(2); P1; w0(0xa); P2; udelay(100);\r\nw0(2); P1; w0(8); P2; udelay(1000);\r\non26_write_regr(pi,0,6,0xa0);\r\nfor (i=0;i<RESET_WAIT;i++) {\r\non26_write_regr(pi,0,6,0xa0);\r\nx = on26_read_regr(pi,0,7);\r\non26_write_regr(pi,0,6,0xb0);\r\ny = on26_read_regr(pi,0,7);\r\nif (!((x&0x80)||(y&0x80))) break;\r\nmdelay(100);\r\n}\r\nif (i == RESET_WAIT)\r\nprintk("on26: Device reset failed (%x,%x)\n",x,y);\r\nw0(4); P1; w0(4); P1;\r\n}\r\nCCP(0x30);\r\npi->delay = d;\r\npi->mode = m;\r\nw0(pi->saved_r0);\r\nw2(pi->saved_r2);\r\nreturn 5;\r\n}\r\nstatic void on26_read_block( PIA *pi, char * buf, int count )\r\n{ int k, a, b;\r\nswitch (pi->mode) {\r\ncase 0: w0(1); P1; w0(1); P2; w0(2); P1; w0(0x18); P2; w0(0); P1;\r\nudelay(10);\r\nfor (k=0;k<count;k++) {\r\nw2(6); a = r1();\r\nw2(4); b = r1();\r\nbuf[k] = j44(a,b);\r\n}\r\nw0(2); P1; w0(8); P2;\r\nbreak;\r\ncase 1: w0(1); P1; w0(1); P2; w0(2); P1; w0(0x19); P2; w0(0); P1;\r\nudelay(10);\r\nfor (k=0;k<count/2;k++) {\r\nw2(0x26); buf[2*k] = r0();\r\nw2(0x24); buf[2*k+1] = r0();\r\n}\r\nw0(2); P1; w0(9); P2;\r\nbreak;\r\ncase 2: w3(1); w3(1); w2(5); w4(1); w2(4);\r\nw3(0); w3(0); w2(0x24);\r\nudelay(10);\r\nfor (k=0;k<count;k++) buf[k] = r4();\r\nw2(4);\r\nbreak;\r\ncase 3: w3(1); w3(1); w2(5); w4(1); w2(4);\r\nw3(0); w3(0); w2(0x24);\r\nudelay(10);\r\nfor (k=0;k<count/2;k++) ((u16 *)buf)[k] = r4w();\r\nw2(4);\r\nbreak;\r\ncase 4: w3(1); w3(1); w2(5); w4(1); w2(4);\r\nw3(0); w3(0); w2(0x24);\r\nudelay(10);\r\nfor (k=0;k<count/4;k++) ((u32 *)buf)[k] = r4l();\r\nw2(4);\r\nbreak;\r\n}\r\n}\r\nstatic void on26_write_block( PIA *pi, char * buf, int count )\r\n{ int k;\r\nswitch (pi->mode) {\r\ncase 0:\r\ncase 1: w0(1); P1; w0(1); P2;\r\nw0(2); P1; w0(0x18+pi->mode); P2; w0(0); P1;\r\nudelay(10);\r\nfor (k=0;k<count/2;k++) {\r\nw2(5); w0(buf[2*k]);\r\nw2(7); w0(buf[2*k+1]);\r\n}\r\nw2(5); w2(4);\r\nw0(2); P1; w0(8+pi->mode); P2;\r\nbreak;\r\ncase 2: w3(1); w3(1); w2(5); w4(1); w2(4);\r\nw3(0); w3(0); w2(0xc5);\r\nudelay(10);\r\nfor (k=0;k<count;k++) w4(buf[k]);\r\nw2(0xc4);\r\nbreak;\r\ncase 3: w3(1); w3(1); w2(5); w4(1); w2(4);\r\nw3(0); w3(0); w2(0xc5);\r\nudelay(10);\r\nfor (k=0;k<count/2;k++) w4w(((u16 *)buf)[k]);\r\nw2(0xc4);\r\nbreak;\r\ncase 4: w3(1); w3(1); w2(5); w4(1); w2(4);\r\nw3(0); w3(0); w2(0xc5);\r\nudelay(10);\r\nfor (k=0;k<count/4;k++) w4l(((u32 *)buf)[k]);\r\nw2(0xc4);\r\nbreak;\r\n}\r\n}\r\nstatic void on26_log_adapter( PIA *pi, char * scratch, int verbose )\r\n{ char *mode_string[5] = {"4-bit","8-bit","EPP-8",\r\n"EPP-16","EPP-32"};\r\nprintk("%s: on26 %s, OnSpec 90c26 at 0x%x, ",\r\npi->device,ON26_VERSION,pi->port);\r\nprintk("mode %d (%s), delay %d\n",pi->mode,\r\nmode_string[pi->mode],pi->delay);\r\n}\r\nstatic int __init on26_init(void)\r\n{\r\nreturn paride_register(&on26);\r\n}\r\nstatic void __exit on26_exit(void)\r\n{\r\nparide_unregister(&on26);\r\n}
