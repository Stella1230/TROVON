static u32 ug_io_transaction(u32 in)\r\n{\r\nu32 *csr_reg = ug_io_base + EXI_CSR;\r\nu32 *data_reg = ug_io_base + EXI_DATA;\r\nu32 *cr_reg = ug_io_base + EXI_CR;\r\nu32 csr, data, cr;\r\ncsr = EXI_CSR_CLK_32MHZ | EXI_CSR_CS_0;\r\nout_be32(csr_reg, csr);\r\ndata = in;\r\nout_be32(data_reg, data);\r\ncr = EXI_CR_TLEN(2) | EXI_CR_READ_WRITE | EXI_CR_TSTART;\r\nout_be32(cr_reg, cr);\r\nwhile (in_be32(cr_reg) & EXI_CR_TSTART)\r\nbarrier();\r\nout_be32(csr_reg, 0);\r\ndata = in_be32(data_reg);\r\nreturn data;\r\n}\r\nstatic int ug_is_txfifo_ready(void)\r\n{\r\nreturn ug_io_transaction(0xc0000000) & 0x04000000;\r\n}\r\nstatic void ug_raw_putc(char ch)\r\n{\r\nug_io_transaction(0xb0000000 | (ch << 20));\r\n}\r\nstatic void ug_putc(char ch)\r\n{\r\nint count = 16;\r\nif (!ug_io_base)\r\nreturn;\r\nwhile (!ug_is_txfifo_ready() && count--)\r\nbarrier();\r\nif (count >= 0)\r\nug_raw_putc(ch);\r\n}\r\nvoid ug_console_write(const char *buf, int len)\r\n{\r\nchar *b = (char *)buf;\r\nwhile (len--) {\r\nif (*b == '\n')\r\nug_putc('\r');\r\nug_putc(*b++);\r\n}\r\n}\r\nstatic int ug_is_adapter_present(void)\r\n{\r\nif (!ug_io_base)\r\nreturn 0;\r\nreturn ug_io_transaction(0x90000000) == 0x04700000;\r\n}\r\nstatic void *ug_grab_exi_io_base(void)\r\n{\r\nu32 v;\r\nvoid *devp;\r\ndevp = find_node_by_compatible(NULL, "nintendo,flipper-exi");\r\nif (devp == NULL)\r\ngoto err_out;\r\nif (getprop(devp, "virtual-reg", &v, sizeof(v)) != sizeof(v))\r\ngoto err_out;\r\nreturn (void *)v;\r\nerr_out:\r\nreturn NULL;\r\n}\r\nvoid *ug_probe(void)\r\n{\r\nvoid *exi_io_base;\r\nint i;\r\nexi_io_base = ug_grab_exi_io_base();\r\nif (!exi_io_base)\r\nreturn NULL;\r\nfor (i = 0; i < 2; i++) {\r\nug_io_base = exi_io_base + 0x14 * i;\r\nif (ug_is_adapter_present())\r\nbreak;\r\n}\r\nif (i == 2)\r\nug_io_base = NULL;\r\nreturn ug_io_base;\r\n}
