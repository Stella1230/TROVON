static void leo_wait(struct leo_lx_krn __iomem *lx_krn)\r\n{\r\nint i;\r\nfor (i = 0;\r\n(sbus_readl(&lx_krn->krn_csr) & LEO_KRN_CSR_PROGRESS) &&\r\ni < 300000;\r\ni++)\r\nudelay(1);\r\nreturn;\r\n}\r\nstatic void leo_switch_from_graph(struct fb_info *info)\r\n{\r\nstruct leo_par *par = (struct leo_par *) info->par;\r\nstruct leo_ld_ss0 __iomem *ss = par->ld_ss0;\r\nstruct leo_cursor __iomem *cursor = par->cursor;\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&par->lock, flags);\r\npar->extent = ((info->var.xres - 1) |\r\n((info->var.yres - 1) << 16));\r\nsbus_writel(0xffffffff, &ss->wid);\r\nsbus_writel(0xffff, &ss->wmask);\r\nsbus_writel(0, &ss->vclipmin);\r\nsbus_writel(par->extent, &ss->vclipmax);\r\nsbus_writel(0, &ss->fg);\r\nsbus_writel(0xff000000, &ss->planemask);\r\nsbus_writel(0x310850, &ss->rop);\r\nsbus_writel(0, &ss->widclip);\r\nsbus_writel((info->var.xres-1) | ((info->var.yres-1) << 11),\r\n&par->lc_ss0_usr->extent);\r\nsbus_writel(4, &par->lc_ss0_usr->addrspace);\r\nsbus_writel(0x80000000, &par->lc_ss0_usr->fill);\r\nsbus_writel(0, &par->lc_ss0_usr->fontt);\r\ndo {\r\nval = sbus_readl(&par->lc_ss0_usr->csr);\r\n} while (val & 0x20000000);\r\nsbus_writel(1, &ss->wid);\r\nsbus_writel(0x00ffffff, &ss->planemask);\r\nsbus_writel(0x310b90, &ss->rop);\r\nsbus_writel(0, &par->lc_ss0_usr->addrspace);\r\nsbus_writel(sbus_readl(&cursor->cur_misc) & ~LEO_CUR_ENABLE, &cursor->cur_misc);\r\nspin_unlock_irqrestore(&par->lock, flags);\r\n}\r\nstatic int leo_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nleo_switch_from_graph(info);\r\nif (var->xoffset || var->yoffset || var->vmode)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int leo_setcolreg(unsigned regno,\r\nunsigned red, unsigned green, unsigned blue,\r\nunsigned transp, struct fb_info *info)\r\n{\r\nstruct leo_par *par = (struct leo_par *) info->par;\r\nstruct leo_lx_krn __iomem *lx_krn = par->lx_krn;\r\nunsigned long flags;\r\nu32 val;\r\nint i;\r\nif (regno >= 256)\r\nreturn 1;\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\npar->clut_data[regno] = red | (green << 8) | (blue << 16);\r\nspin_lock_irqsave(&par->lock, flags);\r\nleo_wait(lx_krn);\r\nsbus_writel(LEO_KRN_TYPE_CLUTDATA, &lx_krn->krn_type);\r\nfor (i = 0; i < 256; i++)\r\nsbus_writel(par->clut_data[i], &lx_krn->krn_value);\r\nsbus_writel(LEO_KRN_TYPE_CLUT0, &lx_krn->krn_type);\r\nval = sbus_readl(&lx_krn->krn_csr);\r\nval |= (LEO_KRN_CSR_UNK | LEO_KRN_CSR_UNK2);\r\nsbus_writel(val, &lx_krn->krn_csr);\r\nspin_unlock_irqrestore(&par->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int leo_blank(int blank, struct fb_info *info)\r\n{\r\nstruct leo_par *par = (struct leo_par *) info->par;\r\nstruct leo_lx_krn __iomem *lx_krn = par->lx_krn;\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&par->lock, flags);\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\nval = sbus_readl(&lx_krn->krn_csr);\r\nval |= LEO_KRN_CSR_ENABLE;\r\nsbus_writel(val, &lx_krn->krn_csr);\r\npar->flags &= ~LEO_FLAG_BLANKED;\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_POWERDOWN:\r\nval = sbus_readl(&lx_krn->krn_csr);\r\nval &= ~LEO_KRN_CSR_ENABLE;\r\nsbus_writel(val, &lx_krn->krn_csr);\r\npar->flags |= LEO_FLAG_BLANKED;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&par->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int leo_mmap(struct fb_info *info, struct vm_area_struct *vma)\r\n{\r\nstruct leo_par *par = (struct leo_par *)info->par;\r\nreturn sbusfb_mmap_helper(leo_mmap_map,\r\ninfo->fix.smem_start, info->fix.smem_len,\r\npar->which_io, vma);\r\n}\r\nstatic int leo_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)\r\n{\r\nreturn sbusfb_ioctl_helper(cmd, arg, info,\r\nFBTYPE_SUNLEO, 32, info->fix.smem_len);\r\n}\r\nstatic void\r\nleo_init_fix(struct fb_info *info, struct device_node *dp)\r\n{\r\nstrlcpy(info->fix.id, dp->name, sizeof(info->fix.id));\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\ninfo->fix.line_length = 8192;\r\ninfo->fix.accel = FB_ACCEL_SUN_LEO;\r\n}\r\nstatic void leo_wid_put(struct fb_info *info, struct fb_wid_list *wl)\r\n{\r\nstruct leo_par *par = (struct leo_par *) info->par;\r\nstruct leo_lx_krn __iomem *lx_krn = par->lx_krn;\r\nstruct fb_wid_item *wi;\r\nunsigned long flags;\r\nu32 val;\r\nint i, j;\r\nspin_lock_irqsave(&par->lock, flags);\r\nleo_wait(lx_krn);\r\nfor (i = 0, wi = wl->wl_list; i < wl->wl_count; i++, wi++) {\r\nswitch (wi->wi_type) {\r\ncase FB_WID_DBL_8:\r\nj = (wi->wi_index & 0xf) + 0x40;\r\nbreak;\r\ncase FB_WID_DBL_24:\r\nj = wi->wi_index & 0x3f;\r\nbreak;\r\ndefault:\r\ncontinue;\r\n};\r\nsbus_writel(0x5800 + j, &lx_krn->krn_type);\r\nsbus_writel(wi->wi_values[0], &lx_krn->krn_value);\r\n}\r\nsbus_writel(LEO_KRN_TYPE_WID, &lx_krn->krn_type);\r\nval = sbus_readl(&lx_krn->krn_csr);\r\nval |= (LEO_KRN_CSR_UNK | LEO_KRN_CSR_UNK2);\r\nsbus_writel(val, &lx_krn->krn_csr);\r\nspin_unlock_irqrestore(&par->lock, flags);\r\n}\r\nstatic void leo_init_wids(struct fb_info *info)\r\n{\r\nstruct fb_wid_item wi;\r\nstruct fb_wid_list wl;\r\nwl.wl_count = 1;\r\nwl.wl_list = &wi;\r\nwi.wi_type = FB_WID_DBL_8;\r\nwi.wi_index = 0;\r\nwi.wi_values [0] = 0x2c0;\r\nleo_wid_put(info, &wl);\r\nwi.wi_index = 1;\r\nwi.wi_values [0] = 0x30;\r\nleo_wid_put(info, &wl);\r\nwi.wi_index = 2;\r\nwi.wi_values [0] = 0x20;\r\nleo_wid_put(info, &wl);\r\nwi.wi_type = FB_WID_DBL_24;\r\nwi.wi_index = 1;\r\nwi.wi_values [0] = 0x30;\r\nleo_wid_put(info, &wl);\r\n}\r\nstatic void leo_init_hw(struct fb_info *info)\r\n{\r\nstruct leo_par *par = (struct leo_par *) info->par;\r\nu32 val;\r\nval = sbus_readl(&par->ld_ss1->ss1_misc);\r\nval |= LEO_SS1_MISC_ENABLE;\r\nsbus_writel(val, &par->ld_ss1->ss1_misc);\r\nleo_switch_from_graph(info);\r\n}\r\nstatic void leo_fixup_var_rgb(struct fb_var_screeninfo *var)\r\n{\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 16;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\n}\r\nstatic void leo_unmap_regs(struct platform_device *op, struct fb_info *info,\r\nstruct leo_par *par)\r\n{\r\nif (par->lc_ss0_usr)\r\nof_iounmap(&op->resource[0], par->lc_ss0_usr, 0x1000);\r\nif (par->ld_ss0)\r\nof_iounmap(&op->resource[0], par->ld_ss0, 0x1000);\r\nif (par->ld_ss1)\r\nof_iounmap(&op->resource[0], par->ld_ss1, 0x1000);\r\nif (par->lx_krn)\r\nof_iounmap(&op->resource[0], par->lx_krn, 0x1000);\r\nif (par->cursor)\r\nof_iounmap(&op->resource[0],\r\npar->cursor, sizeof(struct leo_cursor));\r\nif (info->screen_base)\r\nof_iounmap(&op->resource[0], info->screen_base, 0x800000);\r\n}\r\nstatic int leo_probe(struct platform_device *op)\r\n{\r\nstruct device_node *dp = op->dev.of_node;\r\nstruct fb_info *info;\r\nstruct leo_par *par;\r\nint linebytes, err;\r\ninfo = framebuffer_alloc(sizeof(struct leo_par), &op->dev);\r\nerr = -ENOMEM;\r\nif (!info)\r\ngoto out_err;\r\npar = info->par;\r\nspin_lock_init(&par->lock);\r\ninfo->fix.smem_start = op->resource[0].start;\r\npar->which_io = op->resource[0].flags & IORESOURCE_BITS;\r\nsbusfb_fill_var(&info->var, dp, 32);\r\nleo_fixup_var_rgb(&info->var);\r\nlinebytes = of_getintprop_default(dp, "linebytes",\r\ninfo->var.xres);\r\ninfo->fix.smem_len = PAGE_ALIGN(linebytes * info->var.yres);\r\npar->lc_ss0_usr =\r\nof_ioremap(&op->resource[0], LEO_OFF_LC_SS0_USR,\r\n0x1000, "leolc ss0usr");\r\npar->ld_ss0 =\r\nof_ioremap(&op->resource[0], LEO_OFF_LD_SS0,\r\n0x1000, "leold ss0");\r\npar->ld_ss1 =\r\nof_ioremap(&op->resource[0], LEO_OFF_LD_SS1,\r\n0x1000, "leold ss1");\r\npar->lx_krn =\r\nof_ioremap(&op->resource[0], LEO_OFF_LX_KRN,\r\n0x1000, "leolx krn");\r\npar->cursor =\r\nof_ioremap(&op->resource[0], LEO_OFF_LX_CURSOR,\r\nsizeof(struct leo_cursor), "leolx cursor");\r\ninfo->screen_base =\r\nof_ioremap(&op->resource[0], LEO_OFF_SS0,\r\n0x800000, "leo ram");\r\nif (!par->lc_ss0_usr ||\r\n!par->ld_ss0 ||\r\n!par->ld_ss1 ||\r\n!par->lx_krn ||\r\n!par->cursor ||\r\n!info->screen_base)\r\ngoto out_unmap_regs;\r\ninfo->flags = FBINFO_DEFAULT;\r\ninfo->fbops = &leo_ops;\r\ninfo->pseudo_palette = par->clut_data;\r\nleo_init_wids(info);\r\nleo_init_hw(info);\r\nleo_blank(FB_BLANK_UNBLANK, info);\r\nif (fb_alloc_cmap(&info->cmap, 256, 0))\r\ngoto out_unmap_regs;\r\nleo_init_fix(info, dp);\r\nerr = register_framebuffer(info);\r\nif (err < 0)\r\ngoto out_dealloc_cmap;\r\ndev_set_drvdata(&op->dev, info);\r\nprintk(KERN_INFO "%s: leo at %lx:%lx\n",\r\ndp->full_name,\r\npar->which_io, info->fix.smem_start);\r\nreturn 0;\r\nout_dealloc_cmap:\r\nfb_dealloc_cmap(&info->cmap);\r\nout_unmap_regs:\r\nleo_unmap_regs(op, info, par);\r\nframebuffer_release(info);\r\nout_err:\r\nreturn err;\r\n}\r\nstatic int leo_remove(struct platform_device *op)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(&op->dev);\r\nstruct leo_par *par = info->par;\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\nleo_unmap_regs(op, info, par);\r\nframebuffer_release(info);\r\ndev_set_drvdata(&op->dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init leo_init(void)\r\n{\r\nif (fb_get_options("leofb", NULL))\r\nreturn -ENODEV;\r\nreturn platform_driver_register(&leo_driver);\r\n}\r\nstatic void __exit leo_exit(void)\r\n{\r\nplatform_driver_unregister(&leo_driver);\r\n}
