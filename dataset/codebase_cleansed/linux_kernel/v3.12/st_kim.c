static struct platform_device *st_get_plat_device(int id)\r\n{\r\nreturn st_kim_devices[id];\r\n}\r\nstatic void validate_firmware_response(struct kim_data_s *kim_gdata)\r\n{\r\nstruct sk_buff *skb = kim_gdata->rx_skb;\r\nif (!skb)\r\nreturn;\r\nif (skb->data[2] == 0x01 && skb->data[3] == 0x01 &&\r\nskb->data[4] == 0x10 && skb->data[5] == 0x00) {\r\nmemcpy(kim_gdata->resp_buffer,\r\nkim_gdata->rx_skb->data,\r\nkim_gdata->rx_skb->len);\r\ncomplete_all(&kim_gdata->kim_rcvd);\r\nkim_gdata->rx_state = ST_W4_PACKET_TYPE;\r\nkim_gdata->rx_skb = NULL;\r\nkim_gdata->rx_count = 0;\r\n} else if (unlikely(skb->data[5] != 0)) {\r\npr_err("no proper response during fw download");\r\npr_err("data6 %x", skb->data[5]);\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\ncomplete_all(&kim_gdata->kim_rcvd);\r\nkfree_skb(skb);\r\n}\r\nstatic inline int kim_check_data_len(struct kim_data_s *kim_gdata, int len)\r\n{\r\nregister int room = skb_tailroom(kim_gdata->rx_skb);\r\npr_debug("len %d room %d", len, room);\r\nif (!len) {\r\nvalidate_firmware_response(kim_gdata);\r\n} else if (len > room) {\r\npr_err("Data length is too large len %d room %d", len,\r\nroom);\r\nkfree_skb(kim_gdata->rx_skb);\r\n} else {\r\nkim_gdata->rx_state = ST_W4_DATA;\r\nkim_gdata->rx_count = len;\r\nreturn len;\r\n}\r\nkim_gdata->rx_state = ST_W4_PACKET_TYPE;\r\nkim_gdata->rx_skb = NULL;\r\nkim_gdata->rx_count = 0;\r\nreturn 0;\r\n}\r\nstatic void kim_int_recv(struct kim_data_s *kim_gdata,\r\nconst unsigned char *data, long count)\r\n{\r\nconst unsigned char *ptr;\r\nint len = 0, type = 0;\r\nunsigned char *plen;\r\npr_debug("%s", __func__);\r\nptr = data;\r\nif (unlikely(ptr == NULL)) {\r\npr_err(" received null from TTY ");\r\nreturn;\r\n}\r\nwhile (count) {\r\nif (kim_gdata->rx_count) {\r\nlen = min_t(unsigned int, kim_gdata->rx_count, count);\r\nmemcpy(skb_put(kim_gdata->rx_skb, len), ptr, len);\r\nkim_gdata->rx_count -= len;\r\ncount -= len;\r\nptr += len;\r\nif (kim_gdata->rx_count)\r\ncontinue;\r\nswitch (kim_gdata->rx_state) {\r\ncase ST_W4_DATA:\r\npr_debug("Complete pkt received");\r\nvalidate_firmware_response(kim_gdata);\r\nkim_gdata->rx_state = ST_W4_PACKET_TYPE;\r\nkim_gdata->rx_skb = NULL;\r\ncontinue;\r\ncase ST_W4_HEADER:\r\nplen =\r\n(unsigned char *)&kim_gdata->rx_skb->data[1];\r\npr_debug("event hdr: plen 0x%02x\n", *plen);\r\nkim_check_data_len(kim_gdata, *plen);\r\ncontinue;\r\n}\r\n}\r\nswitch (*ptr) {\r\ncase 0x04:\r\nkim_gdata->rx_state = ST_W4_HEADER;\r\nkim_gdata->rx_count = 2;\r\ntype = *ptr;\r\nbreak;\r\ndefault:\r\npr_info("unknown packet");\r\nptr++;\r\ncount--;\r\ncontinue;\r\n}\r\nptr++;\r\ncount--;\r\nkim_gdata->rx_skb =\r\nalloc_skb(1024+8, GFP_ATOMIC);\r\nif (!kim_gdata->rx_skb) {\r\npr_err("can't allocate mem for new packet");\r\nkim_gdata->rx_state = ST_W4_PACKET_TYPE;\r\nkim_gdata->rx_count = 0;\r\nreturn;\r\n}\r\nskb_reserve(kim_gdata->rx_skb, 8);\r\nkim_gdata->rx_skb->cb[0] = 4;\r\nkim_gdata->rx_skb->cb[1] = 0;\r\n}\r\nreturn;\r\n}\r\nstatic long read_local_version(struct kim_data_s *kim_gdata, char *bts_scr_name)\r\n{\r\nunsigned short version = 0, chip = 0, min_ver = 0, maj_ver = 0;\r\nconst char read_ver_cmd[] = { 0x01, 0x01, 0x10, 0x00 };\r\npr_debug("%s", __func__);\r\nINIT_COMPLETION(kim_gdata->kim_rcvd);\r\nif (4 != st_int_write(kim_gdata->core_data, read_ver_cmd, 4)) {\r\npr_err("kim: couldn't write 4 bytes");\r\nreturn -EIO;\r\n}\r\nif (!wait_for_completion_interruptible_timeout(\r\n&kim_gdata->kim_rcvd, msecs_to_jiffies(CMD_RESP_TIME))) {\r\npr_err(" waiting for ver info- timed out ");\r\nreturn -ETIMEDOUT;\r\n}\r\nINIT_COMPLETION(kim_gdata->kim_rcvd);\r\nversion =\r\nMAKEWORD(kim_gdata->resp_buffer[12],\r\nkim_gdata->resp_buffer[13]);\r\nchip = (version & 0x7C00) >> 10;\r\nmin_ver = (version & 0x007F);\r\nmaj_ver = (version & 0x0380) >> 7;\r\nif (version & 0x8000)\r\nmaj_ver |= 0x0008;\r\nsprintf(bts_scr_name, "TIInit_%d.%d.%d.bts", chip, maj_ver, min_ver);\r\nkim_gdata->version.full = version;\r\nkim_gdata->version.chip = chip;\r\nkim_gdata->version.maj_ver = maj_ver;\r\nkim_gdata->version.min_ver = min_ver;\r\npr_info("%s", bts_scr_name);\r\nreturn 0;\r\n}\r\nstatic void skip_change_remote_baud(unsigned char **ptr, long *len)\r\n{\r\nunsigned char *nxt_action, *cur_action;\r\ncur_action = *ptr;\r\nnxt_action = cur_action + sizeof(struct bts_action) +\r\n((struct bts_action *) cur_action)->size;\r\nif (((struct bts_action *) nxt_action)->type != ACTION_WAIT_EVENT) {\r\npr_err("invalid action after change remote baud command");\r\n} else {\r\n*ptr = *ptr + sizeof(struct bts_action) +\r\n((struct bts_action *)cur_action)->size;\r\n*len = *len - (sizeof(struct bts_action) +\r\n((struct bts_action *)cur_action)->size);\r\npr_warn("skipping the wait event of change remote baud");\r\n}\r\n}\r\nstatic long download_firmware(struct kim_data_s *kim_gdata)\r\n{\r\nlong err = 0;\r\nlong len = 0;\r\nunsigned char *ptr = NULL;\r\nunsigned char *action_ptr = NULL;\r\nunsigned char bts_scr_name[30] = { 0 };\r\nint wr_room_space;\r\nint cmd_size;\r\nunsigned long timeout;\r\nerr = read_local_version(kim_gdata, bts_scr_name);\r\nif (err != 0) {\r\npr_err("kim: failed to read local ver");\r\nreturn err;\r\n}\r\nerr =\r\nrequest_firmware(&kim_gdata->fw_entry, bts_scr_name,\r\n&kim_gdata->kim_pdev->dev);\r\nif (unlikely((err != 0) || (kim_gdata->fw_entry->data == NULL) ||\r\n(kim_gdata->fw_entry->size == 0))) {\r\npr_err(" request_firmware failed(errno %ld) for %s", err,\r\nbts_scr_name);\r\nreturn -EINVAL;\r\n}\r\nptr = (void *)kim_gdata->fw_entry->data;\r\nlen = kim_gdata->fw_entry->size;\r\nptr += sizeof(struct bts_header);\r\nlen -= sizeof(struct bts_header);\r\nwhile (len > 0 && ptr) {\r\npr_debug(" action size %d, type %d ",\r\n((struct bts_action *)ptr)->size,\r\n((struct bts_action *)ptr)->type);\r\nswitch (((struct bts_action *)ptr)->type) {\r\ncase ACTION_SEND_COMMAND:\r\npr_debug("S");\r\naction_ptr = &(((struct bts_action *)ptr)->data[0]);\r\nif (unlikely\r\n(((struct hci_command *)action_ptr)->opcode ==\r\n0xFF36)) {\r\npr_warn("change remote baud"\r\n" rate command in firmware");\r\nskip_change_remote_baud(&ptr, &len);\r\nbreak;\r\n}\r\ncmd_size = ((struct bts_action *)ptr)->size;\r\ntimeout = jiffies + msecs_to_jiffies(CMD_WR_TIME);\r\ndo {\r\nwr_room_space =\r\nst_get_uart_wr_room(kim_gdata->core_data);\r\nif (wr_room_space < 0) {\r\npr_err("Unable to get free "\r\n"space info from uart tx buffer");\r\nrelease_firmware(kim_gdata->fw_entry);\r\nreturn wr_room_space;\r\n}\r\nmdelay(1);\r\n} while ((wr_room_space < cmd_size) &&\r\ntime_before(jiffies, timeout));\r\nif (time_after_eq(jiffies, timeout)) {\r\npr_err("Timeout while waiting for free "\r\n"free space in uart tx buffer");\r\nrelease_firmware(kim_gdata->fw_entry);\r\nreturn -ETIMEDOUT;\r\n}\r\nINIT_COMPLETION(kim_gdata->kim_rcvd);\r\nerr = st_int_write(kim_gdata->core_data,\r\n((struct bts_action_send *)action_ptr)->data,\r\n((struct bts_action *)ptr)->size);\r\nif (unlikely(err < 0)) {\r\nrelease_firmware(kim_gdata->fw_entry);\r\nreturn err;\r\n}\r\nif (err != cmd_size) {\r\npr_err("Number of bytes written to uart "\r\n"tx buffer are not matching with "\r\n"requested cmd write size");\r\nrelease_firmware(kim_gdata->fw_entry);\r\nreturn -EIO;\r\n}\r\nbreak;\r\ncase ACTION_WAIT_EVENT:\r\npr_debug("W");\r\nif (!wait_for_completion_interruptible_timeout(\r\n&kim_gdata->kim_rcvd,\r\nmsecs_to_jiffies(CMD_RESP_TIME))) {\r\npr_err("response timeout during fw download ");\r\nrelease_firmware(kim_gdata->fw_entry);\r\nreturn -ETIMEDOUT;\r\n}\r\nINIT_COMPLETION(kim_gdata->kim_rcvd);\r\nbreak;\r\ncase ACTION_DELAY:\r\npr_info("sleep command in scr");\r\naction_ptr = &(((struct bts_action *)ptr)->data[0]);\r\nmdelay(((struct bts_action_delay *)action_ptr)->msec);\r\nbreak;\r\n}\r\nlen =\r\nlen - (sizeof(struct bts_action) +\r\n((struct bts_action *)ptr)->size);\r\nptr =\r\nptr + sizeof(struct bts_action) +\r\n((struct bts_action *)ptr)->size;\r\n}\r\nrelease_firmware(kim_gdata->fw_entry);\r\nreturn 0;\r\n}\r\nvoid st_kim_recv(void *disc_data, const unsigned char *data, long count)\r\n{\r\nstruct st_data_s *st_gdata = (struct st_data_s *)disc_data;\r\nstruct kim_data_s *kim_gdata = st_gdata->kim_data;\r\nkim_int_recv(kim_gdata, data, count);\r\nreturn;\r\n}\r\nvoid st_kim_complete(void *kim_data)\r\n{\r\nstruct kim_data_s *kim_gdata = (struct kim_data_s *)kim_data;\r\ncomplete(&kim_gdata->ldisc_installed);\r\n}\r\nlong st_kim_start(void *kim_data)\r\n{\r\nlong err = 0;\r\nlong retry = POR_RETRY_COUNT;\r\nstruct ti_st_plat_data *pdata;\r\nstruct kim_data_s *kim_gdata = (struct kim_data_s *)kim_data;\r\npr_info(" %s", __func__);\r\npdata = kim_gdata->kim_pdev->dev.platform_data;\r\ndo {\r\nif (pdata->chip_enable)\r\npdata->chip_enable(kim_gdata);\r\ngpio_set_value(kim_gdata->nshutdown, GPIO_LOW);\r\nmdelay(5);\r\ngpio_set_value(kim_gdata->nshutdown, GPIO_HIGH);\r\nmdelay(100);\r\nINIT_COMPLETION(kim_gdata->ldisc_installed);\r\nkim_gdata->ldisc_install = 1;\r\npr_info("ldisc_install = 1");\r\nsysfs_notify(&kim_gdata->kim_pdev->dev.kobj,\r\nNULL, "install");\r\nerr = wait_for_completion_interruptible_timeout(\r\n&kim_gdata->ldisc_installed, msecs_to_jiffies(LDISC_TIME));\r\nif (!err) {\r\npr_err("ldisc installation timeout");\r\nerr = st_kim_stop(kim_gdata);\r\ncontinue;\r\n} else {\r\npr_info("line discipline installed");\r\nerr = download_firmware(kim_gdata);\r\nif (err != 0) {\r\npr_err("download firmware failed");\r\nerr = st_kim_stop(kim_gdata);\r\ncontinue;\r\n} else {\r\nbreak;\r\n}\r\n}\r\n} while (retry--);\r\nreturn err;\r\n}\r\nlong st_kim_stop(void *kim_data)\r\n{\r\nlong err = 0;\r\nstruct kim_data_s *kim_gdata = (struct kim_data_s *)kim_data;\r\nstruct ti_st_plat_data *pdata =\r\nkim_gdata->kim_pdev->dev.platform_data;\r\nstruct tty_struct *tty = kim_gdata->core_data->tty;\r\nINIT_COMPLETION(kim_gdata->ldisc_installed);\r\nif (tty) {\r\ntty_ldisc_flush(tty);\r\ntty_driver_flush_buffer(tty);\r\ntty->ops->flush_buffer(tty);\r\n}\r\npr_info("ldisc_install = 0");\r\nkim_gdata->ldisc_install = 0;\r\nsysfs_notify(&kim_gdata->kim_pdev->dev.kobj, NULL, "install");\r\nerr = wait_for_completion_interruptible_timeout(\r\n&kim_gdata->ldisc_installed, msecs_to_jiffies(LDISC_TIME));\r\nif (!err) {\r\npr_err(" timed out waiting for ldisc to be un-installed");\r\nerr = -ETIMEDOUT;\r\n}\r\ngpio_set_value(kim_gdata->nshutdown, GPIO_LOW);\r\nmdelay(1);\r\ngpio_set_value(kim_gdata->nshutdown, GPIO_HIGH);\r\nmdelay(1);\r\ngpio_set_value(kim_gdata->nshutdown, GPIO_LOW);\r\nif (pdata->chip_disable)\r\npdata->chip_disable(kim_gdata);\r\nreturn err;\r\n}\r\nstatic int show_version(struct seq_file *s, void *unused)\r\n{\r\nstruct kim_data_s *kim_gdata = (struct kim_data_s *)s->private;\r\nseq_printf(s, "%04X %d.%d.%d\n", kim_gdata->version.full,\r\nkim_gdata->version.chip, kim_gdata->version.maj_ver,\r\nkim_gdata->version.min_ver);\r\nreturn 0;\r\n}\r\nstatic int show_list(struct seq_file *s, void *unused)\r\n{\r\nstruct kim_data_s *kim_gdata = (struct kim_data_s *)s->private;\r\nkim_st_list_protocols(kim_gdata->core_data, s);\r\nreturn 0;\r\n}\r\nstatic ssize_t show_install(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct kim_data_s *kim_data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", kim_data->ldisc_install);\r\n}\r\nstatic ssize_t store_dev_name(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct kim_data_s *kim_data = dev_get_drvdata(dev);\r\npr_debug("storing dev name >%s<", buf);\r\nstrncpy(kim_data->dev_name, buf, count);\r\npr_debug("stored dev name >%s<", kim_data->dev_name);\r\nreturn count;\r\n}\r\nstatic ssize_t store_baud_rate(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct kim_data_s *kim_data = dev_get_drvdata(dev);\r\npr_debug("storing baud rate >%s<", buf);\r\nsscanf(buf, "%ld", &kim_data->baud_rate);\r\npr_debug("stored baud rate >%ld<", kim_data->baud_rate);\r\nreturn count;\r\n}\r\nstatic ssize_t show_dev_name(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct kim_data_s *kim_data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", kim_data->dev_name);\r\n}\r\nstatic ssize_t show_baud_rate(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct kim_data_s *kim_data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%ld\n", kim_data->baud_rate);\r\n}\r\nstatic ssize_t show_flow_cntrl(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct kim_data_s *kim_data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", kim_data->flow_cntrl);\r\n}\r\nvoid st_kim_ref(struct st_data_s **core_data, int id)\r\n{\r\nstruct platform_device *pdev;\r\nstruct kim_data_s *kim_gdata;\r\npdev = st_get_plat_device(id);\r\nif (!pdev) {\r\n*core_data = NULL;\r\nreturn;\r\n}\r\nkim_gdata = platform_get_drvdata(pdev);\r\n*core_data = kim_gdata->core_data;\r\n}\r\nstatic int kim_version_open(struct inode *i, struct file *f)\r\n{\r\nreturn single_open(f, show_version, i->i_private);\r\n}\r\nstatic int kim_list_open(struct inode *i, struct file *f)\r\n{\r\nreturn single_open(f, show_list, i->i_private);\r\n}\r\nstatic int kim_probe(struct platform_device *pdev)\r\n{\r\nstruct kim_data_s *kim_gdata;\r\nstruct ti_st_plat_data *pdata = pdev->dev.platform_data;\r\nint err;\r\nif ((pdev->id != -1) && (pdev->id < MAX_ST_DEVICES)) {\r\nst_kim_devices[pdev->id] = pdev;\r\n} else {\r\nst_kim_devices[0] = pdev;\r\n}\r\nkim_gdata = kzalloc(sizeof(struct kim_data_s), GFP_ATOMIC);\r\nif (!kim_gdata) {\r\npr_err("no mem to allocate");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, kim_gdata);\r\nerr = st_core_init(&kim_gdata->core_data);\r\nif (err != 0) {\r\npr_err(" ST core init failed");\r\nerr = -EIO;\r\ngoto err_core_init;\r\n}\r\nkim_gdata->core_data->kim_data = kim_gdata;\r\nkim_gdata->nshutdown = pdata->nshutdown_gpio;\r\nerr = gpio_request(kim_gdata->nshutdown, "kim");\r\nif (unlikely(err)) {\r\npr_err(" gpio %ld request failed ", kim_gdata->nshutdown);\r\nreturn err;\r\n}\r\nerr = gpio_direction_output(kim_gdata->nshutdown, 0);\r\nif (unlikely(err)) {\r\npr_err(" unable to configure gpio %ld", kim_gdata->nshutdown);\r\nreturn err;\r\n}\r\nkim_gdata->kim_pdev = pdev;\r\ninit_completion(&kim_gdata->kim_rcvd);\r\ninit_completion(&kim_gdata->ldisc_installed);\r\nerr = sysfs_create_group(&pdev->dev.kobj, &uim_attr_grp);\r\nif (err) {\r\npr_err("failed to create sysfs entries");\r\ngoto err_sysfs_group;\r\n}\r\nstrncpy(kim_gdata->dev_name, pdata->dev_name, UART_DEV_NAME_LEN);\r\nkim_gdata->flow_cntrl = pdata->flow_cntrl;\r\nkim_gdata->baud_rate = pdata->baud_rate;\r\npr_info("sysfs entries created\n");\r\nkim_debugfs_dir = debugfs_create_dir("ti-st", NULL);\r\nif (IS_ERR(kim_debugfs_dir)) {\r\npr_err(" debugfs entries creation failed ");\r\nerr = -EIO;\r\ngoto err_debugfs_dir;\r\n}\r\ndebugfs_create_file("version", S_IRUGO, kim_debugfs_dir,\r\nkim_gdata, &version_debugfs_fops);\r\ndebugfs_create_file("protocols", S_IRUGO, kim_debugfs_dir,\r\nkim_gdata, &list_debugfs_fops);\r\npr_info(" debugfs entries created ");\r\nreturn 0;\r\nerr_debugfs_dir:\r\nsysfs_remove_group(&pdev->dev.kobj, &uim_attr_grp);\r\nerr_sysfs_group:\r\nst_core_exit(kim_gdata->core_data);\r\nerr_core_init:\r\nkfree(kim_gdata);\r\nreturn err;\r\n}\r\nstatic int kim_remove(struct platform_device *pdev)\r\n{\r\nstruct ti_st_plat_data *pdata = pdev->dev.platform_data;\r\nstruct kim_data_s *kim_gdata;\r\nkim_gdata = platform_get_drvdata(pdev);\r\ngpio_free(pdata->nshutdown_gpio);\r\npr_info("nshutdown GPIO Freed");\r\ndebugfs_remove_recursive(kim_debugfs_dir);\r\nsysfs_remove_group(&pdev->dev.kobj, &uim_attr_grp);\r\npr_info("sysfs entries removed");\r\nkim_gdata->kim_pdev = NULL;\r\nst_core_exit(kim_gdata->core_data);\r\nkfree(kim_gdata);\r\nkim_gdata = NULL;\r\nreturn 0;\r\n}\r\nstatic int kim_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct ti_st_plat_data *pdata = pdev->dev.platform_data;\r\nif (pdata->suspend)\r\nreturn pdata->suspend(pdev, state);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int kim_resume(struct platform_device *pdev)\r\n{\r\nstruct ti_st_plat_data *pdata = pdev->dev.platform_data;\r\nif (pdata->resume)\r\nreturn pdata->resume(pdev);\r\nreturn -EOPNOTSUPP;\r\n}
