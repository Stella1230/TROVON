static int prepend(char **buffer, int buflen, const char *str, int namelen)\r\n{\r\nbuflen -= namelen;\r\nif (buflen < 0)\r\nreturn -ENAMETOOLONG;\r\n*buffer -= namelen;\r\nmemcpy(*buffer, str, namelen);\r\nreturn 0;\r\n}\r\nstatic int d_namespace_path(struct path *path, char *buf, int buflen,\r\nchar **name, int flags)\r\n{\r\nchar *res;\r\nint error = 0;\r\nint connected = 1;\r\nif (path->mnt->mnt_flags & MNT_INTERNAL) {\r\nres = dentry_path(path->dentry, buf, buflen);\r\n*name = res;\r\nif (IS_ERR(res)) {\r\n*name = buf;\r\nreturn PTR_ERR(res);\r\n}\r\nif (path->dentry->d_sb->s_magic == PROC_SUPER_MAGIC &&\r\nstrncmp(*name, "/sys/", 5) == 0) {\r\nreturn prepend(name, *name - buf, "/proc", 5);\r\n}\r\nreturn 0;\r\n}\r\nif (flags & PATH_CHROOT_REL) {\r\nstruct path root;\r\nget_fs_root(current->fs, &root);\r\nres = __d_path(path, &root, buf, buflen);\r\npath_put(&root);\r\n} else {\r\nres = d_absolute_path(path, buf, buflen);\r\nif (!our_mnt(path->mnt))\r\nconnected = 0;\r\n}\r\nif (!res || IS_ERR(res)) {\r\nif (PTR_ERR(res) == -ENAMETOOLONG)\r\nreturn -ENAMETOOLONG;\r\nconnected = 0;\r\nres = dentry_path_raw(path->dentry, buf, buflen);\r\nif (IS_ERR(res)) {\r\nerror = PTR_ERR(res);\r\n*name = buf;\r\ngoto out;\r\n};\r\n} else if (!our_mnt(path->mnt))\r\nconnected = 0;\r\n*name = res;\r\nif (d_unlinked(path->dentry) && path->dentry->d_inode &&\r\n!(flags & PATH_MEDIATE_DELETED)) {\r\nerror = -ENOENT;\r\ngoto out;\r\n}\r\nif (!connected) {\r\nif (!(flags & PATH_CONNECT_PATH) &&\r\n!(((flags & CHROOT_NSCONNECT) == CHROOT_NSCONNECT) &&\r\nour_mnt(path->mnt))) {\r\nerror = -EACCES;\r\nif (*res == '/')\r\n*name = res + 1;\r\n}\r\n}\r\nout:\r\nreturn error;\r\n}\r\nstatic int get_name_to_buffer(struct path *path, int flags, char *buffer,\r\nint size, char **name, const char **info)\r\n{\r\nint adjust = (flags & PATH_IS_DIR) ? 1 : 0;\r\nint error = d_namespace_path(path, buffer, size - adjust, name, flags);\r\nif (!error && (flags & PATH_IS_DIR) && (*name)[1] != '\0')\r\nstrcpy(&buffer[size - 2], "/");\r\nif (info && error) {\r\nif (error == -ENOENT)\r\n*info = "Failed name lookup - deleted entry";\r\nelse if (error == -EACCES)\r\n*info = "Failed name lookup - disconnected path";\r\nelse if (error == -ENAMETOOLONG)\r\n*info = "Failed name lookup - name too long";\r\nelse\r\n*info = "Failed name lookup";\r\n}\r\nreturn error;\r\n}\r\nint aa_path_name(struct path *path, int flags, char **buffer, const char **name,\r\nconst char **info)\r\n{\r\nchar *buf, *str = NULL;\r\nint size = 256;\r\nint error;\r\n*name = NULL;\r\n*buffer = NULL;\r\nfor (;;) {\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nerror = get_name_to_buffer(path, flags, buf, size, &str, info);\r\nif (error != -ENAMETOOLONG)\r\nbreak;\r\nkfree(buf);\r\nsize <<= 1;\r\nif (size > aa_g_path_max)\r\nreturn -ENAMETOOLONG;\r\n*info = NULL;\r\n}\r\n*buffer = buf;\r\n*name = str;\r\nreturn error;\r\n}
