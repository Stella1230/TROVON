static void wait_till_cmd_acked(struct cs5535audio *cs5535au, unsigned long timeout)\r\n{\r\nunsigned int tmp;\r\ndo {\r\ntmp = cs_readl(cs5535au, ACC_CODEC_CNTL);\r\nif (!(tmp & CMD_NEW))\r\nbreak;\r\nudelay(1);\r\n} while (--timeout);\r\nif (!timeout)\r\nsnd_printk(KERN_ERR "Failure writing to cs5535 codec\n");\r\n}\r\nstatic unsigned short snd_cs5535audio_codec_read(struct cs5535audio *cs5535au,\r\nunsigned short reg)\r\n{\r\nunsigned int regdata;\r\nunsigned int timeout;\r\nunsigned int val;\r\nregdata = ((unsigned int) reg) << 24;\r\nregdata |= ACC_CODEC_CNTL_RD_CMD;\r\nregdata |= CMD_NEW;\r\ncs_writel(cs5535au, ACC_CODEC_CNTL, regdata);\r\nwait_till_cmd_acked(cs5535au, 50);\r\ntimeout = 50;\r\ndo {\r\nval = cs_readl(cs5535au, ACC_CODEC_STATUS);\r\nif ((val & STS_NEW) && reg == (val >> 24))\r\nbreak;\r\nudelay(1);\r\n} while (--timeout);\r\nif (!timeout)\r\nsnd_printk(KERN_ERR "Failure reading codec reg 0x%x,"\r\n"Last value=0x%x\n", reg, val);\r\nreturn (unsigned short) val;\r\n}\r\nstatic void snd_cs5535audio_codec_write(struct cs5535audio *cs5535au,\r\nunsigned short reg, unsigned short val)\r\n{\r\nunsigned int regdata;\r\nregdata = ((unsigned int) reg) << 24;\r\nregdata |= val;\r\nregdata &= CMD_MASK;\r\nregdata |= CMD_NEW;\r\nregdata &= ACC_CODEC_CNTL_WR_CMD;\r\ncs_writel(cs5535au, ACC_CODEC_CNTL, regdata);\r\nwait_till_cmd_acked(cs5535au, 50);\r\n}\r\nstatic void snd_cs5535audio_ac97_codec_write(struct snd_ac97 *ac97,\r\nunsigned short reg, unsigned short val)\r\n{\r\nstruct cs5535audio *cs5535au = ac97->private_data;\r\nsnd_cs5535audio_codec_write(cs5535au, reg, val);\r\n}\r\nstatic unsigned short snd_cs5535audio_ac97_codec_read(struct snd_ac97 *ac97,\r\nunsigned short reg)\r\n{\r\nstruct cs5535audio *cs5535au = ac97->private_data;\r\nreturn snd_cs5535audio_codec_read(cs5535au, reg);\r\n}\r\nstatic int snd_cs5535audio_mixer(struct cs5535audio *cs5535au)\r\n{\r\nstruct snd_card *card = cs5535au->card;\r\nstruct snd_ac97_bus *pbus;\r\nstruct snd_ac97_template ac97;\r\nint err;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_cs5535audio_ac97_codec_write,\r\n.read = snd_cs5535audio_ac97_codec_read,\r\n};\r\nif ((err = snd_ac97_bus(card, 0, &ops, NULL, &pbus)) < 0)\r\nreturn err;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.scaps = AC97_SCAP_AUDIO | AC97_SCAP_SKIP_MODEM\r\n| AC97_SCAP_POWER_SAVE;\r\nac97.private_data = cs5535au;\r\nac97.pci = cs5535au->pci;\r\nolpc_prequirks(card, &ac97);\r\nif ((err = snd_ac97_mixer(pbus, &ac97, &cs5535au->ac97)) < 0) {\r\nsnd_printk(KERN_ERR "mixer failed\n");\r\nreturn err;\r\n}\r\nsnd_ac97_tune_hardware(cs5535au->ac97, ac97_quirks, ac97_quirk);\r\nerr = olpc_quirks(card, cs5535au->ac97);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "olpc quirks failed\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void process_bm0_irq(struct cs5535audio *cs5535au)\r\n{\r\nu8 bm_stat;\r\nspin_lock(&cs5535au->reg_lock);\r\nbm_stat = cs_readb(cs5535au, ACC_BM0_STATUS);\r\nspin_unlock(&cs5535au->reg_lock);\r\nif (bm_stat & EOP) {\r\nstruct cs5535audio_dma *dma;\r\ndma = cs5535au->playback_substream->runtime->private_data;\r\nsnd_pcm_period_elapsed(cs5535au->playback_substream);\r\n} else {\r\nsnd_printk(KERN_ERR "unexpected bm0 irq src, bm_stat=%x\n",\r\nbm_stat);\r\n}\r\n}\r\nstatic void process_bm1_irq(struct cs5535audio *cs5535au)\r\n{\r\nu8 bm_stat;\r\nspin_lock(&cs5535au->reg_lock);\r\nbm_stat = cs_readb(cs5535au, ACC_BM1_STATUS);\r\nspin_unlock(&cs5535au->reg_lock);\r\nif (bm_stat & EOP) {\r\nstruct cs5535audio_dma *dma;\r\ndma = cs5535au->capture_substream->runtime->private_data;\r\nsnd_pcm_period_elapsed(cs5535au->capture_substream);\r\n}\r\n}\r\nstatic irqreturn_t snd_cs5535audio_interrupt(int irq, void *dev_id)\r\n{\r\nu16 acc_irq_stat;\r\nunsigned char count;\r\nstruct cs5535audio *cs5535au = dev_id;\r\nif (cs5535au == NULL)\r\nreturn IRQ_NONE;\r\nacc_irq_stat = cs_readw(cs5535au, ACC_IRQ_STATUS);\r\nif (!acc_irq_stat)\r\nreturn IRQ_NONE;\r\nfor (count = 0; count < 4; count++) {\r\nif (acc_irq_stat & (1 << count)) {\r\nswitch (count) {\r\ncase IRQ_STS:\r\ncs_readl(cs5535au, ACC_GPIO_STATUS);\r\nbreak;\r\ncase WU_IRQ_STS:\r\ncs_readl(cs5535au, ACC_GPIO_STATUS);\r\nbreak;\r\ncase BM0_IRQ_STS:\r\nprocess_bm0_irq(cs5535au);\r\nbreak;\r\ncase BM1_IRQ_STS:\r\nprocess_bm1_irq(cs5535au);\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "Unexpected irq src: "\r\n"0x%x\n", acc_irq_stat);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int snd_cs5535audio_free(struct cs5535audio *cs5535au)\r\n{\r\nsynchronize_irq(cs5535au->irq);\r\npci_set_power_state(cs5535au->pci, 3);\r\nif (cs5535au->irq >= 0)\r\nfree_irq(cs5535au->irq, cs5535au);\r\npci_release_regions(cs5535au->pci);\r\npci_disable_device(cs5535au->pci);\r\nkfree(cs5535au);\r\nreturn 0;\r\n}\r\nstatic int snd_cs5535audio_dev_free(struct snd_device *device)\r\n{\r\nstruct cs5535audio *cs5535au = device->device_data;\r\nreturn snd_cs5535audio_free(cs5535au);\r\n}\r\nstatic int snd_cs5535audio_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nstruct cs5535audio **rcs5535au)\r\n{\r\nstruct cs5535audio *cs5535au;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_cs5535audio_dev_free,\r\n};\r\n*rcs5535au = NULL;\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nif (pci_set_dma_mask(pci, DMA_BIT_MASK(32)) < 0 ||\r\npci_set_consistent_dma_mask(pci, DMA_BIT_MASK(32)) < 0) {\r\nprintk(KERN_WARNING "unable to get 32bit dma\n");\r\nerr = -ENXIO;\r\ngoto pcifail;\r\n}\r\ncs5535au = kzalloc(sizeof(*cs5535au), GFP_KERNEL);\r\nif (cs5535au == NULL) {\r\nerr = -ENOMEM;\r\ngoto pcifail;\r\n}\r\nspin_lock_init(&cs5535au->reg_lock);\r\ncs5535au->card = card;\r\ncs5535au->pci = pci;\r\ncs5535au->irq = -1;\r\nif ((err = pci_request_regions(pci, "CS5535 Audio")) < 0) {\r\nkfree(cs5535au);\r\ngoto pcifail;\r\n}\r\ncs5535au->port = pci_resource_start(pci, 0);\r\nif (request_irq(pci->irq, snd_cs5535audio_interrupt,\r\nIRQF_SHARED, KBUILD_MODNAME, cs5535au)) {\r\nsnd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);\r\nerr = -EBUSY;\r\ngoto sndfail;\r\n}\r\ncs5535au->irq = pci->irq;\r\npci_set_master(pci);\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL,\r\ncs5535au, &ops)) < 0)\r\ngoto sndfail;\r\nsnd_card_set_dev(card, &pci->dev);\r\n*rcs5535au = cs5535au;\r\nreturn 0;\r\nsndfail:\r\nsnd_cs5535audio_free(cs5535au);\r\nreturn err;\r\npcifail:\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nstatic int snd_cs5535audio_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct cs5535audio *cs5535au;\r\nint err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nif ((err = snd_cs5535audio_create(card, pci, &cs5535au)) < 0)\r\ngoto probefail_out;\r\ncard->private_data = cs5535au;\r\nif ((err = snd_cs5535audio_mixer(cs5535au)) < 0)\r\ngoto probefail_out;\r\nif ((err = snd_cs5535audio_pcm(cs5535au)) < 0)\r\ngoto probefail_out;\r\nstrcpy(card->driver, DRIVER_NAME);\r\nstrcpy(card->shortname, "CS5535 Audio");\r\nsprintf(card->longname, "%s %s at 0x%lx, irq %i",\r\ncard->shortname, card->driver,\r\ncs5535au->port, cs5535au->irq);\r\nif ((err = snd_card_register(card)) < 0)\r\ngoto probefail_out;\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\nprobefail_out:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic void snd_cs5535audio_remove(struct pci_dev *pci)\r\n{\r\nolpc_quirks_cleanup();\r\nsnd_card_free(pci_get_drvdata(pci));\r\n}
