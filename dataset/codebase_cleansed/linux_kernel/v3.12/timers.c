static irqreturn_t hw_tick(int irq, void *dummy)\r\n{\r\nTSTAT &= 0;\r\nm68328_tick_cnt += TICKS_PER_JIFFY;\r\nreturn timer_interrupt(irq, dummy);\r\n}\r\nstatic cycle_t m68328_read_clk(struct clocksource *cs)\r\n{\r\nunsigned long flags;\r\nu32 cycles;\r\nlocal_irq_save(flags);\r\ncycles = m68328_tick_cnt + TCN;\r\nlocal_irq_restore(flags);\r\nreturn cycles;\r\n}\r\nvoid hw_timer_init(irq_handler_t handler)\r\n{\r\nTCTL = 0;\r\nsetup_irq(TMR_IRQ_NUM, &m68328_timer_irq);\r\nTCTL = TCTL_OM | TCTL_IRQEN | CLOCK_SOURCE;\r\nTPRER = CLOCK_PRE;\r\nTCMP = TICKS_PER_JIFFY;\r\nTCTL |= TCTL_TEN;\r\nclocksource_register_hz(&m68328_clk, TICKS_PER_JIFFY*HZ);\r\ntimer_interrupt = handler;\r\n}\r\nint m68328_hwclk(int set, struct rtc_time *t)\r\n{\r\nif (!set) {\r\nlong now = RTCTIME;\r\nt->tm_year = t->tm_mon = t->tm_mday = 1;\r\nt->tm_hour = (now >> 24) % 24;\r\nt->tm_min = (now >> 16) % 60;\r\nt->tm_sec = now % 60;\r\n}\r\nreturn 0;\r\n}
