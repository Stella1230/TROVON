static void\r\nxpc_process_connect(struct xpc_channel *ch, unsigned long *irq_flags)\r\n{\r\nenum xp_retval ret;\r\nDBUG_ON(!spin_is_locked(&ch->lock));\r\nif (!(ch->flags & XPC_C_OPENREQUEST) ||\r\n!(ch->flags & XPC_C_ROPENREQUEST)) {\r\nreturn;\r\n}\r\nDBUG_ON(!(ch->flags & XPC_C_CONNECTING));\r\nif (!(ch->flags & XPC_C_SETUP)) {\r\nspin_unlock_irqrestore(&ch->lock, *irq_flags);\r\nret = xpc_arch_ops.setup_msg_structures(ch);\r\nspin_lock_irqsave(&ch->lock, *irq_flags);\r\nif (ret != xpSuccess)\r\nXPC_DISCONNECT_CHANNEL(ch, ret, irq_flags);\r\nelse\r\nch->flags |= XPC_C_SETUP;\r\nif (ch->flags & XPC_C_DISCONNECTING)\r\nreturn;\r\n}\r\nif (!(ch->flags & XPC_C_OPENREPLY)) {\r\nch->flags |= XPC_C_OPENREPLY;\r\nxpc_arch_ops.send_chctl_openreply(ch, irq_flags);\r\n}\r\nif (!(ch->flags & XPC_C_ROPENREPLY))\r\nreturn;\r\nif (!(ch->flags & XPC_C_OPENCOMPLETE)) {\r\nch->flags |= (XPC_C_OPENCOMPLETE | XPC_C_CONNECTED);\r\nxpc_arch_ops.send_chctl_opencomplete(ch, irq_flags);\r\n}\r\nif (!(ch->flags & XPC_C_ROPENCOMPLETE))\r\nreturn;\r\ndev_info(xpc_chan, "channel %d to partition %d connected\n",\r\nch->number, ch->partid);\r\nch->flags = (XPC_C_CONNECTED | XPC_C_SETUP);\r\n}\r\nstatic void\r\nxpc_process_disconnect(struct xpc_channel *ch, unsigned long *irq_flags)\r\n{\r\nstruct xpc_partition *part = &xpc_partitions[ch->partid];\r\nu32 channel_was_connected = (ch->flags & XPC_C_WASCONNECTED);\r\nDBUG_ON(!spin_is_locked(&ch->lock));\r\nif (!(ch->flags & XPC_C_DISCONNECTING))\r\nreturn;\r\nDBUG_ON(!(ch->flags & XPC_C_CLOSEREQUEST));\r\nif (atomic_read(&ch->kthreads_assigned) > 0 ||\r\natomic_read(&ch->references) > 0) {\r\nreturn;\r\n}\r\nDBUG_ON((ch->flags & XPC_C_CONNECTEDCALLOUT_MADE) &&\r\n!(ch->flags & XPC_C_DISCONNECTINGCALLOUT_MADE));\r\nif (part->act_state == XPC_P_AS_DEACTIVATING) {\r\nif (xpc_arch_ops.partition_engaged(ch->partid))\r\nreturn;\r\n} else {\r\nif (!(ch->flags & XPC_C_RCLOSEREQUEST))\r\nreturn;\r\nif (!(ch->flags & XPC_C_CLOSEREPLY)) {\r\nch->flags |= XPC_C_CLOSEREPLY;\r\nxpc_arch_ops.send_chctl_closereply(ch, irq_flags);\r\n}\r\nif (!(ch->flags & XPC_C_RCLOSEREPLY))\r\nreturn;\r\n}\r\nif (atomic_read(&ch->n_to_notify) > 0) {\r\nxpc_arch_ops.notify_senders_of_disconnect(ch);\r\n}\r\nif (ch->flags & XPC_C_DISCONNECTINGCALLOUT_MADE) {\r\nspin_unlock_irqrestore(&ch->lock, *irq_flags);\r\nxpc_disconnect_callout(ch, xpDisconnected);\r\nspin_lock_irqsave(&ch->lock, *irq_flags);\r\n}\r\nDBUG_ON(atomic_read(&ch->n_to_notify) != 0);\r\nxpc_arch_ops.teardown_msg_structures(ch);\r\nch->func = NULL;\r\nch->key = NULL;\r\nch->entry_size = 0;\r\nch->local_nentries = 0;\r\nch->remote_nentries = 0;\r\nch->kthreads_assigned_limit = 0;\r\nch->kthreads_idle_limit = 0;\r\nch->flags = (XPC_C_DISCONNECTED | (ch->flags & XPC_C_WDISCONNECT));\r\natomic_dec(&part->nchannels_active);\r\nif (channel_was_connected) {\r\ndev_info(xpc_chan, "channel %d to partition %d disconnected, "\r\n"reason=%d\n", ch->number, ch->partid, ch->reason);\r\n}\r\nif (ch->flags & XPC_C_WDISCONNECT) {\r\ncomplete(&ch->wdisconnect_wait);\r\n} else if (ch->delayed_chctl_flags) {\r\nif (part->act_state != XPC_P_AS_DEACTIVATING) {\r\nspin_lock(&part->chctl_lock);\r\npart->chctl.flags[ch->number] |=\r\nch->delayed_chctl_flags;\r\nspin_unlock(&part->chctl_lock);\r\n}\r\nch->delayed_chctl_flags = 0;\r\n}\r\n}\r\nstatic void\r\nxpc_process_openclose_chctl_flags(struct xpc_partition *part, int ch_number,\r\nu8 chctl_flags)\r\n{\r\nunsigned long irq_flags;\r\nstruct xpc_openclose_args *args =\r\n&part->remote_openclose_args[ch_number];\r\nstruct xpc_channel *ch = &part->channels[ch_number];\r\nenum xp_retval reason;\r\nenum xp_retval ret;\r\nint create_kthread = 0;\r\nspin_lock_irqsave(&ch->lock, irq_flags);\r\nagain:\r\nif ((ch->flags & XPC_C_DISCONNECTED) &&\r\n(ch->flags & XPC_C_WDISCONNECT)) {\r\nch->delayed_chctl_flags |= chctl_flags;\r\ngoto out;\r\n}\r\nif (chctl_flags & XPC_CHCTL_CLOSEREQUEST) {\r\ndev_dbg(xpc_chan, "XPC_CHCTL_CLOSEREQUEST (reason=%d) received "\r\n"from partid=%d, channel=%d\n", args->reason,\r\nch->partid, ch->number);\r\nif (ch->flags & XPC_C_RCLOSEREQUEST) {\r\nDBUG_ON(!(ch->flags & XPC_C_DISCONNECTING));\r\nDBUG_ON(!(ch->flags & XPC_C_CLOSEREQUEST));\r\nDBUG_ON(!(ch->flags & XPC_C_CLOSEREPLY));\r\nDBUG_ON(ch->flags & XPC_C_RCLOSEREPLY);\r\nDBUG_ON(!(chctl_flags & XPC_CHCTL_CLOSEREPLY));\r\nchctl_flags &= ~XPC_CHCTL_CLOSEREPLY;\r\nch->flags |= XPC_C_RCLOSEREPLY;\r\nxpc_process_disconnect(ch, &irq_flags);\r\nDBUG_ON(!(ch->flags & XPC_C_DISCONNECTED));\r\ngoto again;\r\n}\r\nif (ch->flags & XPC_C_DISCONNECTED) {\r\nif (!(chctl_flags & XPC_CHCTL_OPENREQUEST)) {\r\nif (part->chctl.flags[ch_number] &\r\nXPC_CHCTL_OPENREQUEST) {\r\nDBUG_ON(ch->delayed_chctl_flags != 0);\r\nspin_lock(&part->chctl_lock);\r\npart->chctl.flags[ch_number] |=\r\nXPC_CHCTL_CLOSEREQUEST;\r\nspin_unlock(&part->chctl_lock);\r\n}\r\ngoto out;\r\n}\r\nXPC_SET_REASON(ch, 0, 0);\r\nch->flags &= ~XPC_C_DISCONNECTED;\r\natomic_inc(&part->nchannels_active);\r\nch->flags |= (XPC_C_CONNECTING | XPC_C_ROPENREQUEST);\r\n}\r\nchctl_flags &= ~(XPC_CHCTL_OPENREQUEST | XPC_CHCTL_OPENREPLY |\r\nXPC_CHCTL_OPENCOMPLETE);\r\nch->flags |= XPC_C_RCLOSEREQUEST;\r\nif (!(ch->flags & XPC_C_DISCONNECTING)) {\r\nreason = args->reason;\r\nif (reason <= xpSuccess || reason > xpUnknownReason)\r\nreason = xpUnknownReason;\r\nelse if (reason == xpUnregistering)\r\nreason = xpOtherUnregistering;\r\nXPC_DISCONNECT_CHANNEL(ch, reason, &irq_flags);\r\nDBUG_ON(chctl_flags & XPC_CHCTL_CLOSEREPLY);\r\ngoto out;\r\n}\r\nxpc_process_disconnect(ch, &irq_flags);\r\n}\r\nif (chctl_flags & XPC_CHCTL_CLOSEREPLY) {\r\ndev_dbg(xpc_chan, "XPC_CHCTL_CLOSEREPLY received from partid="\r\n"%d, channel=%d\n", ch->partid, ch->number);\r\nif (ch->flags & XPC_C_DISCONNECTED) {\r\nDBUG_ON(part->act_state != XPC_P_AS_DEACTIVATING);\r\ngoto out;\r\n}\r\nDBUG_ON(!(ch->flags & XPC_C_CLOSEREQUEST));\r\nif (!(ch->flags & XPC_C_RCLOSEREQUEST)) {\r\nif (part->chctl.flags[ch_number] &\r\nXPC_CHCTL_CLOSEREQUEST) {\r\nDBUG_ON(ch->delayed_chctl_flags != 0);\r\nspin_lock(&part->chctl_lock);\r\npart->chctl.flags[ch_number] |=\r\nXPC_CHCTL_CLOSEREPLY;\r\nspin_unlock(&part->chctl_lock);\r\n}\r\ngoto out;\r\n}\r\nch->flags |= XPC_C_RCLOSEREPLY;\r\nif (ch->flags & XPC_C_CLOSEREPLY) {\r\nxpc_process_disconnect(ch, &irq_flags);\r\n}\r\n}\r\nif (chctl_flags & XPC_CHCTL_OPENREQUEST) {\r\ndev_dbg(xpc_chan, "XPC_CHCTL_OPENREQUEST (entry_size=%d, "\r\n"local_nentries=%d) received from partid=%d, "\r\n"channel=%d\n", args->entry_size, args->local_nentries,\r\nch->partid, ch->number);\r\nif (part->act_state == XPC_P_AS_DEACTIVATING ||\r\n(ch->flags & XPC_C_ROPENREQUEST)) {\r\ngoto out;\r\n}\r\nif (ch->flags & (XPC_C_DISCONNECTING | XPC_C_WDISCONNECT)) {\r\nch->delayed_chctl_flags |= XPC_CHCTL_OPENREQUEST;\r\ngoto out;\r\n}\r\nDBUG_ON(!(ch->flags & (XPC_C_DISCONNECTED |\r\nXPC_C_OPENREQUEST)));\r\nDBUG_ON(ch->flags & (XPC_C_ROPENREQUEST | XPC_C_ROPENREPLY |\r\nXPC_C_OPENREPLY | XPC_C_CONNECTED));\r\nif (args->entry_size == 0 || args->local_nentries == 0) {\r\ngoto out;\r\n}\r\nch->flags |= (XPC_C_ROPENREQUEST | XPC_C_CONNECTING);\r\nch->remote_nentries = args->local_nentries;\r\nif (ch->flags & XPC_C_OPENREQUEST) {\r\nif (args->entry_size != ch->entry_size) {\r\nXPC_DISCONNECT_CHANNEL(ch, xpUnequalMsgSizes,\r\n&irq_flags);\r\ngoto out;\r\n}\r\n} else {\r\nch->entry_size = args->entry_size;\r\nXPC_SET_REASON(ch, 0, 0);\r\nch->flags &= ~XPC_C_DISCONNECTED;\r\natomic_inc(&part->nchannels_active);\r\n}\r\nxpc_process_connect(ch, &irq_flags);\r\n}\r\nif (chctl_flags & XPC_CHCTL_OPENREPLY) {\r\ndev_dbg(xpc_chan, "XPC_CHCTL_OPENREPLY (local_msgqueue_pa="\r\n"0x%lx, local_nentries=%d, remote_nentries=%d) "\r\n"received from partid=%d, channel=%d\n",\r\nargs->local_msgqueue_pa, args->local_nentries,\r\nargs->remote_nentries, ch->partid, ch->number);\r\nif (ch->flags & (XPC_C_DISCONNECTING | XPC_C_DISCONNECTED))\r\ngoto out;\r\nif (!(ch->flags & XPC_C_OPENREQUEST)) {\r\nXPC_DISCONNECT_CHANNEL(ch, xpOpenCloseError,\r\n&irq_flags);\r\ngoto out;\r\n}\r\nDBUG_ON(!(ch->flags & XPC_C_ROPENREQUEST));\r\nDBUG_ON(ch->flags & XPC_C_CONNECTED);\r\nDBUG_ON(args->local_msgqueue_pa == 0);\r\nDBUG_ON(args->local_nentries == 0);\r\nDBUG_ON(args->remote_nentries == 0);\r\nret = xpc_arch_ops.save_remote_msgqueue_pa(ch,\r\nargs->local_msgqueue_pa);\r\nif (ret != xpSuccess) {\r\nXPC_DISCONNECT_CHANNEL(ch, ret, &irq_flags);\r\ngoto out;\r\n}\r\nch->flags |= XPC_C_ROPENREPLY;\r\nif (args->local_nentries < ch->remote_nentries) {\r\ndev_dbg(xpc_chan, "XPC_CHCTL_OPENREPLY: new "\r\n"remote_nentries=%d, old remote_nentries=%d, "\r\n"partid=%d, channel=%d\n",\r\nargs->local_nentries, ch->remote_nentries,\r\nch->partid, ch->number);\r\nch->remote_nentries = args->local_nentries;\r\n}\r\nif (args->remote_nentries < ch->local_nentries) {\r\ndev_dbg(xpc_chan, "XPC_CHCTL_OPENREPLY: new "\r\n"local_nentries=%d, old local_nentries=%d, "\r\n"partid=%d, channel=%d\n",\r\nargs->remote_nentries, ch->local_nentries,\r\nch->partid, ch->number);\r\nch->local_nentries = args->remote_nentries;\r\n}\r\nxpc_process_connect(ch, &irq_flags);\r\n}\r\nif (chctl_flags & XPC_CHCTL_OPENCOMPLETE) {\r\ndev_dbg(xpc_chan, "XPC_CHCTL_OPENCOMPLETE received from "\r\n"partid=%d, channel=%d\n", ch->partid, ch->number);\r\nif (ch->flags & (XPC_C_DISCONNECTING | XPC_C_DISCONNECTED))\r\ngoto out;\r\nif (!(ch->flags & XPC_C_OPENREQUEST) ||\r\n!(ch->flags & XPC_C_OPENREPLY)) {\r\nXPC_DISCONNECT_CHANNEL(ch, xpOpenCloseError,\r\n&irq_flags);\r\ngoto out;\r\n}\r\nDBUG_ON(!(ch->flags & XPC_C_ROPENREQUEST));\r\nDBUG_ON(!(ch->flags & XPC_C_ROPENREPLY));\r\nDBUG_ON(!(ch->flags & XPC_C_CONNECTED));\r\nch->flags |= XPC_C_ROPENCOMPLETE;\r\nxpc_process_connect(ch, &irq_flags);\r\ncreate_kthread = 1;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&ch->lock, irq_flags);\r\nif (create_kthread)\r\nxpc_create_kthreads(ch, 1, 0);\r\n}\r\nstatic enum xp_retval\r\nxpc_connect_channel(struct xpc_channel *ch)\r\n{\r\nunsigned long irq_flags;\r\nstruct xpc_registration *registration = &xpc_registrations[ch->number];\r\nif (mutex_trylock(&registration->mutex) == 0)\r\nreturn xpRetry;\r\nif (!XPC_CHANNEL_REGISTERED(ch->number)) {\r\nmutex_unlock(&registration->mutex);\r\nreturn xpUnregistered;\r\n}\r\nspin_lock_irqsave(&ch->lock, irq_flags);\r\nDBUG_ON(ch->flags & XPC_C_CONNECTED);\r\nDBUG_ON(ch->flags & XPC_C_OPENREQUEST);\r\nif (ch->flags & XPC_C_DISCONNECTING) {\r\nspin_unlock_irqrestore(&ch->lock, irq_flags);\r\nmutex_unlock(&registration->mutex);\r\nreturn ch->reason;\r\n}\r\nch->kthreads_assigned_limit = registration->assigned_limit;\r\nch->kthreads_idle_limit = registration->idle_limit;\r\nDBUG_ON(atomic_read(&ch->kthreads_assigned) != 0);\r\nDBUG_ON(atomic_read(&ch->kthreads_idle) != 0);\r\nDBUG_ON(atomic_read(&ch->kthreads_active) != 0);\r\nch->func = registration->func;\r\nDBUG_ON(registration->func == NULL);\r\nch->key = registration->key;\r\nch->local_nentries = registration->nentries;\r\nif (ch->flags & XPC_C_ROPENREQUEST) {\r\nif (registration->entry_size != ch->entry_size) {\r\nmutex_unlock(&registration->mutex);\r\nXPC_DISCONNECT_CHANNEL(ch, xpUnequalMsgSizes,\r\n&irq_flags);\r\nspin_unlock_irqrestore(&ch->lock, irq_flags);\r\nreturn xpUnequalMsgSizes;\r\n}\r\n} else {\r\nch->entry_size = registration->entry_size;\r\nXPC_SET_REASON(ch, 0, 0);\r\nch->flags &= ~XPC_C_DISCONNECTED;\r\natomic_inc(&xpc_partitions[ch->partid].nchannels_active);\r\n}\r\nmutex_unlock(&registration->mutex);\r\nch->flags |= (XPC_C_OPENREQUEST | XPC_C_CONNECTING);\r\nxpc_arch_ops.send_chctl_openrequest(ch, &irq_flags);\r\nxpc_process_connect(ch, &irq_flags);\r\nspin_unlock_irqrestore(&ch->lock, irq_flags);\r\nreturn xpSuccess;\r\n}\r\nvoid\r\nxpc_process_sent_chctl_flags(struct xpc_partition *part)\r\n{\r\nunsigned long irq_flags;\r\nunion xpc_channel_ctl_flags chctl;\r\nstruct xpc_channel *ch;\r\nint ch_number;\r\nu32 ch_flags;\r\nchctl.all_flags = xpc_arch_ops.get_chctl_all_flags(part);\r\nfor (ch_number = 0; ch_number < part->nchannels; ch_number++) {\r\nch = &part->channels[ch_number];\r\nif (chctl.flags[ch_number] & XPC_OPENCLOSE_CHCTL_FLAGS) {\r\nxpc_process_openclose_chctl_flags(part, ch_number,\r\nchctl.flags[ch_number]);\r\n}\r\nch_flags = ch->flags;\r\nif (ch_flags & XPC_C_DISCONNECTING) {\r\nspin_lock_irqsave(&ch->lock, irq_flags);\r\nxpc_process_disconnect(ch, &irq_flags);\r\nspin_unlock_irqrestore(&ch->lock, irq_flags);\r\ncontinue;\r\n}\r\nif (part->act_state == XPC_P_AS_DEACTIVATING)\r\ncontinue;\r\nif (!(ch_flags & XPC_C_CONNECTED)) {\r\nif (!(ch_flags & XPC_C_OPENREQUEST)) {\r\nDBUG_ON(ch_flags & XPC_C_SETUP);\r\n(void)xpc_connect_channel(ch);\r\n}\r\ncontinue;\r\n}\r\nif (chctl.flags[ch_number] & XPC_MSG_CHCTL_FLAGS)\r\nxpc_arch_ops.process_msg_chctl_flags(part, ch_number);\r\n}\r\n}\r\nvoid\r\nxpc_partition_going_down(struct xpc_partition *part, enum xp_retval reason)\r\n{\r\nunsigned long irq_flags;\r\nint ch_number;\r\nstruct xpc_channel *ch;\r\ndev_dbg(xpc_chan, "deactivating partition %d, reason=%d\n",\r\nXPC_PARTID(part), reason);\r\nif (!xpc_part_ref(part)) {\r\nreturn;\r\n}\r\nfor (ch_number = 0; ch_number < part->nchannels; ch_number++) {\r\nch = &part->channels[ch_number];\r\nxpc_msgqueue_ref(ch);\r\nspin_lock_irqsave(&ch->lock, irq_flags);\r\nXPC_DISCONNECT_CHANNEL(ch, reason, &irq_flags);\r\nspin_unlock_irqrestore(&ch->lock, irq_flags);\r\nxpc_msgqueue_deref(ch);\r\n}\r\nxpc_wakeup_channel_mgr(part);\r\nxpc_part_deref(part);\r\n}\r\nvoid\r\nxpc_initiate_connect(int ch_number)\r\n{\r\nshort partid;\r\nstruct xpc_partition *part;\r\nstruct xpc_channel *ch;\r\nDBUG_ON(ch_number < 0 || ch_number >= XPC_MAX_NCHANNELS);\r\nfor (partid = 0; partid < xp_max_npartitions; partid++) {\r\npart = &xpc_partitions[partid];\r\nif (xpc_part_ref(part)) {\r\nch = &part->channels[ch_number];\r\nxpc_wakeup_channel_mgr(part);\r\nxpc_part_deref(part);\r\n}\r\n}\r\n}\r\nvoid\r\nxpc_connected_callout(struct xpc_channel *ch)\r\n{\r\nif (ch->func != NULL) {\r\ndev_dbg(xpc_chan, "ch->func() called, reason=xpConnected, "\r\n"partid=%d, channel=%d\n", ch->partid, ch->number);\r\nch->func(xpConnected, ch->partid, ch->number,\r\n(void *)(u64)ch->local_nentries, ch->key);\r\ndev_dbg(xpc_chan, "ch->func() returned, reason=xpConnected, "\r\n"partid=%d, channel=%d\n", ch->partid, ch->number);\r\n}\r\n}\r\nvoid\r\nxpc_initiate_disconnect(int ch_number)\r\n{\r\nunsigned long irq_flags;\r\nshort partid;\r\nstruct xpc_partition *part;\r\nstruct xpc_channel *ch;\r\nDBUG_ON(ch_number < 0 || ch_number >= XPC_MAX_NCHANNELS);\r\nfor (partid = 0; partid < xp_max_npartitions; partid++) {\r\npart = &xpc_partitions[partid];\r\nif (xpc_part_ref(part)) {\r\nch = &part->channels[ch_number];\r\nxpc_msgqueue_ref(ch);\r\nspin_lock_irqsave(&ch->lock, irq_flags);\r\nif (!(ch->flags & XPC_C_DISCONNECTED)) {\r\nch->flags |= XPC_C_WDISCONNECT;\r\nXPC_DISCONNECT_CHANNEL(ch, xpUnregistering,\r\n&irq_flags);\r\n}\r\nspin_unlock_irqrestore(&ch->lock, irq_flags);\r\nxpc_msgqueue_deref(ch);\r\nxpc_part_deref(part);\r\n}\r\n}\r\nxpc_disconnect_wait(ch_number);\r\n}\r\nvoid\r\nxpc_disconnect_channel(const int line, struct xpc_channel *ch,\r\nenum xp_retval reason, unsigned long *irq_flags)\r\n{\r\nu32 channel_was_connected = (ch->flags & XPC_C_CONNECTED);\r\nDBUG_ON(!spin_is_locked(&ch->lock));\r\nif (ch->flags & (XPC_C_DISCONNECTING | XPC_C_DISCONNECTED))\r\nreturn;\r\nDBUG_ON(!(ch->flags & (XPC_C_CONNECTING | XPC_C_CONNECTED)));\r\ndev_dbg(xpc_chan, "reason=%d, line=%d, partid=%d, channel=%d\n",\r\nreason, line, ch->partid, ch->number);\r\nXPC_SET_REASON(ch, reason, line);\r\nch->flags |= (XPC_C_CLOSEREQUEST | XPC_C_DISCONNECTING);\r\nch->flags &= ~(XPC_C_OPENREQUEST | XPC_C_OPENREPLY |\r\nXPC_C_ROPENREQUEST | XPC_C_ROPENREPLY |\r\nXPC_C_CONNECTING | XPC_C_CONNECTED);\r\nxpc_arch_ops.send_chctl_closerequest(ch, irq_flags);\r\nif (channel_was_connected)\r\nch->flags |= XPC_C_WASCONNECTED;\r\nspin_unlock_irqrestore(&ch->lock, *irq_flags);\r\nif (atomic_read(&ch->kthreads_idle) > 0) {\r\nwake_up_all(&ch->idle_wq);\r\n} else if ((ch->flags & XPC_C_CONNECTEDCALLOUT_MADE) &&\r\n!(ch->flags & XPC_C_DISCONNECTINGCALLOUT)) {\r\nxpc_create_kthreads(ch, 1, 1);\r\n}\r\nif (atomic_read(&ch->n_on_msg_allocate_wq) > 0)\r\nwake_up(&ch->msg_allocate_wq);\r\nspin_lock_irqsave(&ch->lock, *irq_flags);\r\n}\r\nvoid\r\nxpc_disconnect_callout(struct xpc_channel *ch, enum xp_retval reason)\r\n{\r\nif (ch->func != NULL) {\r\ndev_dbg(xpc_chan, "ch->func() called, reason=%d, partid=%d, "\r\n"channel=%d\n", reason, ch->partid, ch->number);\r\nch->func(reason, ch->partid, ch->number, NULL, ch->key);\r\ndev_dbg(xpc_chan, "ch->func() returned, reason=%d, partid=%d, "\r\n"channel=%d\n", reason, ch->partid, ch->number);\r\n}\r\n}\r\nenum xp_retval\r\nxpc_allocate_msg_wait(struct xpc_channel *ch)\r\n{\r\nenum xp_retval ret;\r\nif (ch->flags & XPC_C_DISCONNECTING) {\r\nDBUG_ON(ch->reason == xpInterrupted);\r\nreturn ch->reason;\r\n}\r\natomic_inc(&ch->n_on_msg_allocate_wq);\r\nret = interruptible_sleep_on_timeout(&ch->msg_allocate_wq, 1);\r\natomic_dec(&ch->n_on_msg_allocate_wq);\r\nif (ch->flags & XPC_C_DISCONNECTING) {\r\nret = ch->reason;\r\nDBUG_ON(ch->reason == xpInterrupted);\r\n} else if (ret == 0) {\r\nret = xpTimeout;\r\n} else {\r\nret = xpInterrupted;\r\n}\r\nreturn ret;\r\n}\r\nenum xp_retval\r\nxpc_initiate_send(short partid, int ch_number, u32 flags, void *payload,\r\nu16 payload_size)\r\n{\r\nstruct xpc_partition *part = &xpc_partitions[partid];\r\nenum xp_retval ret = xpUnknownReason;\r\ndev_dbg(xpc_chan, "payload=0x%p, partid=%d, channel=%d\n", payload,\r\npartid, ch_number);\r\nDBUG_ON(partid < 0 || partid >= xp_max_npartitions);\r\nDBUG_ON(ch_number < 0 || ch_number >= part->nchannels);\r\nDBUG_ON(payload == NULL);\r\nif (xpc_part_ref(part)) {\r\nret = xpc_arch_ops.send_payload(&part->channels[ch_number],\r\nflags, payload, payload_size, 0, NULL, NULL);\r\nxpc_part_deref(part);\r\n}\r\nreturn ret;\r\n}\r\nenum xp_retval\r\nxpc_initiate_send_notify(short partid, int ch_number, u32 flags, void *payload,\r\nu16 payload_size, xpc_notify_func func, void *key)\r\n{\r\nstruct xpc_partition *part = &xpc_partitions[partid];\r\nenum xp_retval ret = xpUnknownReason;\r\ndev_dbg(xpc_chan, "payload=0x%p, partid=%d, channel=%d\n", payload,\r\npartid, ch_number);\r\nDBUG_ON(partid < 0 || partid >= xp_max_npartitions);\r\nDBUG_ON(ch_number < 0 || ch_number >= part->nchannels);\r\nDBUG_ON(payload == NULL);\r\nDBUG_ON(func == NULL);\r\nif (xpc_part_ref(part)) {\r\nret = xpc_arch_ops.send_payload(&part->channels[ch_number],\r\nflags, payload, payload_size, XPC_N_CALL, func, key);\r\nxpc_part_deref(part);\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nxpc_deliver_payload(struct xpc_channel *ch)\r\n{\r\nvoid *payload;\r\npayload = xpc_arch_ops.get_deliverable_payload(ch);\r\nif (payload != NULL) {\r\nxpc_msgqueue_ref(ch);\r\natomic_inc(&ch->kthreads_active);\r\nif (ch->func != NULL) {\r\ndev_dbg(xpc_chan, "ch->func() called, payload=0x%p "\r\n"partid=%d channel=%d\n", payload, ch->partid,\r\nch->number);\r\nch->func(xpMsgReceived, ch->partid, ch->number, payload,\r\nch->key);\r\ndev_dbg(xpc_chan, "ch->func() returned, payload=0x%p "\r\n"partid=%d channel=%d\n", payload, ch->partid,\r\nch->number);\r\n}\r\natomic_dec(&ch->kthreads_active);\r\n}\r\n}\r\nvoid\r\nxpc_initiate_received(short partid, int ch_number, void *payload)\r\n{\r\nstruct xpc_partition *part = &xpc_partitions[partid];\r\nstruct xpc_channel *ch;\r\nDBUG_ON(partid < 0 || partid >= xp_max_npartitions);\r\nDBUG_ON(ch_number < 0 || ch_number >= part->nchannels);\r\nch = &part->channels[ch_number];\r\nxpc_arch_ops.received_payload(ch, payload);\r\nxpc_msgqueue_deref(ch);\r\n}
