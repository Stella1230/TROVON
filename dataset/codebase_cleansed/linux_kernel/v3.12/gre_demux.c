int gre_add_protocol(const struct gre_protocol *proto, u8 version)\r\n{\r\nif (version >= GREPROTO_MAX)\r\nreturn -EINVAL;\r\nreturn (cmpxchg((const struct gre_protocol **)&gre_proto[version], NULL, proto) == NULL) ?\r\n0 : -EBUSY;\r\n}\r\nint gre_del_protocol(const struct gre_protocol *proto, u8 version)\r\n{\r\nint ret;\r\nif (version >= GREPROTO_MAX)\r\nreturn -EINVAL;\r\nret = (cmpxchg((const struct gre_protocol **)&gre_proto[version], proto, NULL) == proto) ?\r\n0 : -EBUSY;\r\nif (ret)\r\nreturn ret;\r\nsynchronize_rcu();\r\nreturn 0;\r\n}\r\nvoid gre_build_header(struct sk_buff *skb, const struct tnl_ptk_info *tpi,\r\nint hdr_len)\r\n{\r\nstruct gre_base_hdr *greh;\r\nskb_push(skb, hdr_len);\r\ngreh = (struct gre_base_hdr *)skb->data;\r\ngreh->flags = tnl_flags_to_gre_flags(tpi->flags);\r\ngreh->protocol = tpi->proto;\r\nif (tpi->flags&(TUNNEL_KEY|TUNNEL_CSUM|TUNNEL_SEQ)) {\r\n__be32 *ptr = (__be32 *)(((u8 *)greh) + hdr_len - 4);\r\nif (tpi->flags&TUNNEL_SEQ) {\r\n*ptr = tpi->seq;\r\nptr--;\r\n}\r\nif (tpi->flags&TUNNEL_KEY) {\r\n*ptr = tpi->key;\r\nptr--;\r\n}\r\nif (tpi->flags&TUNNEL_CSUM &&\r\n!(skb_shinfo(skb)->gso_type & SKB_GSO_GRE)) {\r\n*ptr = 0;\r\n*(__sum16 *)ptr = csum_fold(skb_checksum(skb, 0,\r\nskb->len, 0));\r\n}\r\n}\r\n}\r\nstruct sk_buff *gre_handle_offloads(struct sk_buff *skb, bool gre_csum)\r\n{\r\nint err;\r\nif (likely(!skb->encapsulation)) {\r\nskb_reset_inner_headers(skb);\r\nskb->encapsulation = 1;\r\n}\r\nif (skb_is_gso(skb)) {\r\nerr = skb_unclone(skb, GFP_ATOMIC);\r\nif (unlikely(err))\r\ngoto error;\r\nskb_shinfo(skb)->gso_type |= SKB_GSO_GRE;\r\nreturn skb;\r\n} else if (skb->ip_summed == CHECKSUM_PARTIAL && gre_csum) {\r\nerr = skb_checksum_help(skb);\r\nif (unlikely(err))\r\ngoto error;\r\n} else if (skb->ip_summed != CHECKSUM_PARTIAL)\r\nskb->ip_summed = CHECKSUM_NONE;\r\nreturn skb;\r\nerror:\r\nkfree_skb(skb);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic __sum16 check_checksum(struct sk_buff *skb)\r\n{\r\n__sum16 csum = 0;\r\nswitch (skb->ip_summed) {\r\ncase CHECKSUM_COMPLETE:\r\ncsum = csum_fold(skb->csum);\r\nif (!csum)\r\nbreak;\r\ncase CHECKSUM_NONE:\r\nskb->csum = 0;\r\ncsum = __skb_checksum_complete(skb);\r\nskb->ip_summed = CHECKSUM_COMPLETE;\r\nbreak;\r\n}\r\nreturn csum;\r\n}\r\nstatic int parse_gre_header(struct sk_buff *skb, struct tnl_ptk_info *tpi,\r\nbool *csum_err)\r\n{\r\nunsigned int ip_hlen = ip_hdrlen(skb);\r\nconst struct gre_base_hdr *greh;\r\n__be32 *options;\r\nint hdr_len;\r\nif (unlikely(!pskb_may_pull(skb, sizeof(struct gre_base_hdr))))\r\nreturn -EINVAL;\r\ngreh = (struct gre_base_hdr *)(skb_network_header(skb) + ip_hlen);\r\nif (unlikely(greh->flags & (GRE_VERSION | GRE_ROUTING)))\r\nreturn -EINVAL;\r\ntpi->flags = gre_flags_to_tnl_flags(greh->flags);\r\nhdr_len = ip_gre_calc_hlen(tpi->flags);\r\nif (!pskb_may_pull(skb, hdr_len))\r\nreturn -EINVAL;\r\ngreh = (struct gre_base_hdr *)(skb_network_header(skb) + ip_hlen);\r\ntpi->proto = greh->protocol;\r\noptions = (__be32 *)(greh + 1);\r\nif (greh->flags & GRE_CSUM) {\r\nif (check_checksum(skb)) {\r\n*csum_err = true;\r\nreturn -EINVAL;\r\n}\r\noptions++;\r\n}\r\nif (greh->flags & GRE_KEY) {\r\ntpi->key = *options;\r\noptions++;\r\n} else\r\ntpi->key = 0;\r\nif (unlikely(greh->flags & GRE_SEQ)) {\r\ntpi->seq = *options;\r\noptions++;\r\n} else\r\ntpi->seq = 0;\r\nif (greh->flags == 0 && tpi->proto == htons(ETH_P_WCCP)) {\r\ntpi->proto = htons(ETH_P_IP);\r\nif ((*(u8 *)options & 0xF0) != 0x40) {\r\nhdr_len += 4;\r\nif (!pskb_may_pull(skb, hdr_len))\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn iptunnel_pull_header(skb, hdr_len, tpi->proto);\r\n}\r\nstatic int gre_cisco_rcv(struct sk_buff *skb)\r\n{\r\nstruct tnl_ptk_info tpi;\r\nint i;\r\nbool csum_err = false;\r\nif (parse_gre_header(skb, &tpi, &csum_err) < 0)\r\ngoto drop;\r\nrcu_read_lock();\r\nfor (i = 0; i < GRE_IP_PROTO_MAX; i++) {\r\nstruct gre_cisco_protocol *proto;\r\nint ret;\r\nproto = rcu_dereference(gre_cisco_proto_list[i]);\r\nif (!proto)\r\ncontinue;\r\nret = proto->handler(skb, &tpi);\r\nif (ret == PACKET_RCVD) {\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\n}\r\nrcu_read_unlock();\r\nicmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void gre_cisco_err(struct sk_buff *skb, u32 info)\r\n{\r\nconst int type = icmp_hdr(skb)->type;\r\nconst int code = icmp_hdr(skb)->code;\r\nstruct tnl_ptk_info tpi;\r\nbool csum_err = false;\r\nint i;\r\nif (parse_gre_header(skb, &tpi, &csum_err)) {\r\nif (!csum_err)\r\nreturn;\r\n}\r\nif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED) {\r\nipv4_update_pmtu(skb, dev_net(skb->dev), info,\r\nskb->dev->ifindex, 0, IPPROTO_GRE, 0);\r\nreturn;\r\n}\r\nif (type == ICMP_REDIRECT) {\r\nipv4_redirect(skb, dev_net(skb->dev), skb->dev->ifindex, 0,\r\nIPPROTO_GRE, 0);\r\nreturn;\r\n}\r\nrcu_read_lock();\r\nfor (i = 0; i < GRE_IP_PROTO_MAX; i++) {\r\nstruct gre_cisco_protocol *proto;\r\nproto = rcu_dereference(gre_cisco_proto_list[i]);\r\nif (!proto)\r\ncontinue;\r\nif (proto->err_handler(skb, info, &tpi) == PACKET_RCVD)\r\ngoto out;\r\n}\r\nout:\r\nrcu_read_unlock();\r\n}\r\nstatic int gre_rcv(struct sk_buff *skb)\r\n{\r\nconst struct gre_protocol *proto;\r\nu8 ver;\r\nint ret;\r\nif (!pskb_may_pull(skb, 12))\r\ngoto drop;\r\nver = skb->data[1]&0x7f;\r\nif (ver >= GREPROTO_MAX)\r\ngoto drop;\r\nrcu_read_lock();\r\nproto = rcu_dereference(gre_proto[ver]);\r\nif (!proto || !proto->handler)\r\ngoto drop_unlock;\r\nret = proto->handler(skb);\r\nrcu_read_unlock();\r\nreturn ret;\r\ndrop_unlock:\r\nrcu_read_unlock();\r\ndrop:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic void gre_err(struct sk_buff *skb, u32 info)\r\n{\r\nconst struct gre_protocol *proto;\r\nconst struct iphdr *iph = (const struct iphdr *)skb->data;\r\nu8 ver = skb->data[(iph->ihl<<2) + 1]&0x7f;\r\nif (ver >= GREPROTO_MAX)\r\nreturn;\r\nrcu_read_lock();\r\nproto = rcu_dereference(gre_proto[ver]);\r\nif (proto && proto->err_handler)\r\nproto->err_handler(skb, info);\r\nrcu_read_unlock();\r\n}\r\nint gre_cisco_register(struct gre_cisco_protocol *newp)\r\n{\r\nstruct gre_cisco_protocol **proto = (struct gre_cisco_protocol **)\r\n&gre_cisco_proto_list[newp->priority];\r\nreturn (cmpxchg(proto, NULL, newp) == NULL) ? 0 : -EBUSY;\r\n}\r\nint gre_cisco_unregister(struct gre_cisco_protocol *del_proto)\r\n{\r\nstruct gre_cisco_protocol **proto = (struct gre_cisco_protocol **)\r\n&gre_cisco_proto_list[del_proto->priority];\r\nint ret;\r\nret = (cmpxchg(proto, del_proto, NULL) == del_proto) ? 0 : -EINVAL;\r\nif (ret)\r\nreturn ret;\r\nsynchronize_net();\r\nreturn 0;\r\n}\r\nstatic int __init gre_init(void)\r\n{\r\npr_info("GRE over IPv4 demultiplexor driver\n");\r\nif (inet_add_protocol(&net_gre_protocol, IPPROTO_GRE) < 0) {\r\npr_err("can't add protocol\n");\r\ngoto err;\r\n}\r\nif (gre_add_protocol(&ipgre_protocol, GREPROTO_CISCO) < 0) {\r\npr_info("%s: can't add ipgre handler\n", __func__);\r\ngoto err_gre;\r\n}\r\nif (gre_offload_init()) {\r\npr_err("can't add protocol offload\n");\r\ngoto err_gso;\r\n}\r\nreturn 0;\r\nerr_gso:\r\ngre_del_protocol(&ipgre_protocol, GREPROTO_CISCO);\r\nerr_gre:\r\ninet_del_protocol(&net_gre_protocol, IPPROTO_GRE);\r\nerr:\r\nreturn -EAGAIN;\r\n}\r\nstatic void __exit gre_exit(void)\r\n{\r\ngre_offload_exit();\r\ngre_del_protocol(&ipgre_protocol, GREPROTO_CISCO);\r\ninet_del_protocol(&net_gre_protocol, IPPROTO_GRE);\r\n}
