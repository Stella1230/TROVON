static void dispc_dump_irqs(struct seq_file *s)\r\n{\r\nunsigned long flags;\r\nstruct dispc_irq_stats stats;\r\nspin_lock_irqsave(&dispc_compat.irq_stats_lock, flags);\r\nstats = dispc_compat.irq_stats;\r\nmemset(&dispc_compat.irq_stats, 0, sizeof(dispc_compat.irq_stats));\r\ndispc_compat.irq_stats.last_reset = jiffies;\r\nspin_unlock_irqrestore(&dispc_compat.irq_stats_lock, flags);\r\nseq_printf(s, "period %u ms\n",\r\njiffies_to_msecs(jiffies - stats.last_reset));\r\nseq_printf(s, "irqs %d\n", stats.irq_count);\r\n#define PIS(x) \\r\nseq_printf(s, "%-20s %10d\n", #x, stats.irqs[ffs(DISPC_IRQ_##x)-1]);\r\nPIS(FRAMEDONE);\r\nPIS(VSYNC);\r\nPIS(EVSYNC_EVEN);\r\nPIS(EVSYNC_ODD);\r\nPIS(ACBIAS_COUNT_STAT);\r\nPIS(PROG_LINE_NUM);\r\nPIS(GFX_FIFO_UNDERFLOW);\r\nPIS(GFX_END_WIN);\r\nPIS(PAL_GAMMA_MASK);\r\nPIS(OCP_ERR);\r\nPIS(VID1_FIFO_UNDERFLOW);\r\nPIS(VID1_END_WIN);\r\nPIS(VID2_FIFO_UNDERFLOW);\r\nPIS(VID2_END_WIN);\r\nif (dss_feat_get_num_ovls() > 3) {\r\nPIS(VID3_FIFO_UNDERFLOW);\r\nPIS(VID3_END_WIN);\r\n}\r\nPIS(SYNC_LOST);\r\nPIS(SYNC_LOST_DIGIT);\r\nPIS(WAKEUP);\r\nif (dss_has_feature(FEAT_MGR_LCD2)) {\r\nPIS(FRAMEDONE2);\r\nPIS(VSYNC2);\r\nPIS(ACBIAS_COUNT_STAT2);\r\nPIS(SYNC_LOST2);\r\n}\r\nif (dss_has_feature(FEAT_MGR_LCD3)) {\r\nPIS(FRAMEDONE3);\r\nPIS(VSYNC3);\r\nPIS(ACBIAS_COUNT_STAT3);\r\nPIS(SYNC_LOST3);\r\n}\r\n#undef PIS\r\n}\r\nstatic void _omap_dispc_set_irqs(void)\r\n{\r\nu32 mask;\r\nint i;\r\nstruct omap_dispc_isr_data *isr_data;\r\nmask = dispc_compat.irq_error_mask;\r\nfor (i = 0; i < DISPC_MAX_NR_ISRS; i++) {\r\nisr_data = &dispc_compat.registered_isr[i];\r\nif (isr_data->isr == NULL)\r\ncontinue;\r\nmask |= isr_data->mask;\r\n}\r\ndispc_write_irqenable(mask);\r\n}\r\nint omap_dispc_register_isr(omap_dispc_isr_t isr, void *arg, u32 mask)\r\n{\r\nint i;\r\nint ret;\r\nunsigned long flags;\r\nstruct omap_dispc_isr_data *isr_data;\r\nif (isr == NULL)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&dispc_compat.irq_lock, flags);\r\nfor (i = 0; i < DISPC_MAX_NR_ISRS; i++) {\r\nisr_data = &dispc_compat.registered_isr[i];\r\nif (isr_data->isr == isr && isr_data->arg == arg &&\r\nisr_data->mask == mask) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\n}\r\nisr_data = NULL;\r\nret = -EBUSY;\r\nfor (i = 0; i < DISPC_MAX_NR_ISRS; i++) {\r\nisr_data = &dispc_compat.registered_isr[i];\r\nif (isr_data->isr != NULL)\r\ncontinue;\r\nisr_data->isr = isr;\r\nisr_data->arg = arg;\r\nisr_data->mask = mask;\r\nret = 0;\r\nbreak;\r\n}\r\nif (ret)\r\ngoto err;\r\n_omap_dispc_set_irqs();\r\nspin_unlock_irqrestore(&dispc_compat.irq_lock, flags);\r\nreturn 0;\r\nerr:\r\nspin_unlock_irqrestore(&dispc_compat.irq_lock, flags);\r\nreturn ret;\r\n}\r\nint omap_dispc_unregister_isr(omap_dispc_isr_t isr, void *arg, u32 mask)\r\n{\r\nint i;\r\nunsigned long flags;\r\nint ret = -EINVAL;\r\nstruct omap_dispc_isr_data *isr_data;\r\nspin_lock_irqsave(&dispc_compat.irq_lock, flags);\r\nfor (i = 0; i < DISPC_MAX_NR_ISRS; i++) {\r\nisr_data = &dispc_compat.registered_isr[i];\r\nif (isr_data->isr != isr || isr_data->arg != arg ||\r\nisr_data->mask != mask)\r\ncontinue;\r\nisr_data->isr = NULL;\r\nisr_data->arg = NULL;\r\nisr_data->mask = 0;\r\nret = 0;\r\nbreak;\r\n}\r\nif (ret == 0)\r\n_omap_dispc_set_irqs();\r\nspin_unlock_irqrestore(&dispc_compat.irq_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void print_irq_status(u32 status)\r\n{\r\nif ((status & dispc_compat.irq_error_mask) == 0)\r\nreturn;\r\n#define PIS(x) (status & DISPC_IRQ_##x) ? (#x " ") : ""\r\npr_debug("DISPC IRQ: 0x%x: %s%s%s%s%s%s%s%s%s\n",\r\nstatus,\r\nPIS(OCP_ERR),\r\nPIS(GFX_FIFO_UNDERFLOW),\r\nPIS(VID1_FIFO_UNDERFLOW),\r\nPIS(VID2_FIFO_UNDERFLOW),\r\ndss_feat_get_num_ovls() > 3 ? PIS(VID3_FIFO_UNDERFLOW) : "",\r\nPIS(SYNC_LOST),\r\nPIS(SYNC_LOST_DIGIT),\r\ndss_has_feature(FEAT_MGR_LCD2) ? PIS(SYNC_LOST2) : "",\r\ndss_has_feature(FEAT_MGR_LCD3) ? PIS(SYNC_LOST3) : "");\r\n#undef PIS\r\n}\r\nstatic irqreturn_t omap_dispc_irq_handler(int irq, void *arg)\r\n{\r\nint i;\r\nu32 irqstatus, irqenable;\r\nu32 handledirqs = 0;\r\nu32 unhandled_errors;\r\nstruct omap_dispc_isr_data *isr_data;\r\nstruct omap_dispc_isr_data registered_isr[DISPC_MAX_NR_ISRS];\r\nspin_lock(&dispc_compat.irq_lock);\r\nirqstatus = dispc_read_irqstatus();\r\nirqenable = dispc_read_irqenable();\r\nif (!(irqstatus & irqenable)) {\r\nspin_unlock(&dispc_compat.irq_lock);\r\nreturn IRQ_NONE;\r\n}\r\n#ifdef CONFIG_OMAP2_DSS_COLLECT_IRQ_STATS\r\nspin_lock(&dispc_compat.irq_stats_lock);\r\ndispc_compat.irq_stats.irq_count++;\r\ndss_collect_irq_stats(irqstatus, dispc_compat.irq_stats.irqs);\r\nspin_unlock(&dispc_compat.irq_stats_lock);\r\n#endif\r\nprint_irq_status(irqstatus);\r\ndispc_clear_irqstatus(irqstatus);\r\ndispc_read_irqstatus();\r\nmemcpy(registered_isr, dispc_compat.registered_isr,\r\nsizeof(registered_isr));\r\nspin_unlock(&dispc_compat.irq_lock);\r\nfor (i = 0; i < DISPC_MAX_NR_ISRS; i++) {\r\nisr_data = &registered_isr[i];\r\nif (!isr_data->isr)\r\ncontinue;\r\nif (isr_data->mask & irqstatus) {\r\nisr_data->isr(isr_data->arg, irqstatus);\r\nhandledirqs |= isr_data->mask;\r\n}\r\n}\r\nspin_lock(&dispc_compat.irq_lock);\r\nunhandled_errors = irqstatus & ~handledirqs & dispc_compat.irq_error_mask;\r\nif (unhandled_errors) {\r\ndispc_compat.error_irqs |= unhandled_errors;\r\ndispc_compat.irq_error_mask &= ~unhandled_errors;\r\n_omap_dispc_set_irqs();\r\nschedule_work(&dispc_compat.error_work);\r\n}\r\nspin_unlock(&dispc_compat.irq_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void dispc_error_worker(struct work_struct *work)\r\n{\r\nint i;\r\nu32 errors;\r\nunsigned long flags;\r\nstatic const unsigned fifo_underflow_bits[] = {\r\nDISPC_IRQ_GFX_FIFO_UNDERFLOW,\r\nDISPC_IRQ_VID1_FIFO_UNDERFLOW,\r\nDISPC_IRQ_VID2_FIFO_UNDERFLOW,\r\nDISPC_IRQ_VID3_FIFO_UNDERFLOW,\r\n};\r\nspin_lock_irqsave(&dispc_compat.irq_lock, flags);\r\nerrors = dispc_compat.error_irqs;\r\ndispc_compat.error_irqs = 0;\r\nspin_unlock_irqrestore(&dispc_compat.irq_lock, flags);\r\ndispc_runtime_get();\r\nfor (i = 0; i < omap_dss_get_num_overlays(); ++i) {\r\nstruct omap_overlay *ovl;\r\nunsigned bit;\r\novl = omap_dss_get_overlay(i);\r\nbit = fifo_underflow_bits[i];\r\nif (bit & errors) {\r\nDSSERR("FIFO UNDERFLOW on %s, disabling the overlay\n",\r\novl->name);\r\novl->disable(ovl);\r\nmsleep(50);\r\n}\r\n}\r\nfor (i = 0; i < omap_dss_get_num_overlay_managers(); ++i) {\r\nstruct omap_overlay_manager *mgr;\r\nunsigned bit;\r\nmgr = omap_dss_get_overlay_manager(i);\r\nbit = dispc_mgr_get_sync_lost_irq(i);\r\nif (bit & errors) {\r\nint j;\r\nDSSERR("SYNC_LOST on channel %s, restarting the output "\r\n"with video overlays disabled\n",\r\nmgr->name);\r\ndss_mgr_disable(mgr);\r\nfor (j = 0; j < omap_dss_get_num_overlays(); ++j) {\r\nstruct omap_overlay *ovl;\r\novl = omap_dss_get_overlay(j);\r\nif (ovl->id != OMAP_DSS_GFX &&\r\novl->manager == mgr)\r\novl->disable(ovl);\r\n}\r\ndss_mgr_enable(mgr);\r\n}\r\n}\r\nif (errors & DISPC_IRQ_OCP_ERR) {\r\nDSSERR("OCP_ERR\n");\r\nfor (i = 0; i < omap_dss_get_num_overlay_managers(); ++i) {\r\nstruct omap_overlay_manager *mgr;\r\nmgr = omap_dss_get_overlay_manager(i);\r\ndss_mgr_disable(mgr);\r\n}\r\n}\r\nspin_lock_irqsave(&dispc_compat.irq_lock, flags);\r\ndispc_compat.irq_error_mask |= errors;\r\n_omap_dispc_set_irqs();\r\nspin_unlock_irqrestore(&dispc_compat.irq_lock, flags);\r\ndispc_runtime_put();\r\n}\r\nint dss_dispc_initialize_irq(void)\r\n{\r\nint r;\r\n#ifdef CONFIG_OMAP2_DSS_COLLECT_IRQ_STATS\r\nspin_lock_init(&dispc_compat.irq_stats_lock);\r\ndispc_compat.irq_stats.last_reset = jiffies;\r\ndss_debugfs_create_file("dispc_irq", dispc_dump_irqs);\r\n#endif\r\nspin_lock_init(&dispc_compat.irq_lock);\r\nmemset(dispc_compat.registered_isr, 0,\r\nsizeof(dispc_compat.registered_isr));\r\ndispc_compat.irq_error_mask = DISPC_IRQ_MASK_ERROR;\r\nif (dss_has_feature(FEAT_MGR_LCD2))\r\ndispc_compat.irq_error_mask |= DISPC_IRQ_SYNC_LOST2;\r\nif (dss_has_feature(FEAT_MGR_LCD3))\r\ndispc_compat.irq_error_mask |= DISPC_IRQ_SYNC_LOST3;\r\nif (dss_feat_get_num_ovls() > 3)\r\ndispc_compat.irq_error_mask |= DISPC_IRQ_VID3_FIFO_UNDERFLOW;\r\ndispc_clear_irqstatus(dispc_read_irqstatus());\r\nINIT_WORK(&dispc_compat.error_work, dispc_error_worker);\r\n_omap_dispc_set_irqs();\r\nr = dispc_request_irq(omap_dispc_irq_handler, &dispc_compat);\r\nif (r) {\r\nDSSERR("dispc_request_irq failed\n");\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nvoid dss_dispc_uninitialize_irq(void)\r\n{\r\ndispc_free_irq(&dispc_compat);\r\n}\r\nstatic void dispc_mgr_disable_isr(void *data, u32 mask)\r\n{\r\nstruct completion *compl = data;\r\ncomplete(compl);\r\n}\r\nstatic void dispc_mgr_enable_lcd_out(enum omap_channel channel)\r\n{\r\ndispc_mgr_enable(channel, true);\r\n}\r\nstatic void dispc_mgr_disable_lcd_out(enum omap_channel channel)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(framedone_compl);\r\nint r;\r\nu32 irq;\r\nif (dispc_mgr_is_enabled(channel) == false)\r\nreturn;\r\nirq = dispc_mgr_get_framedone_irq(channel);\r\nr = omap_dispc_register_isr(dispc_mgr_disable_isr, &framedone_compl,\r\nirq);\r\nif (r)\r\nDSSERR("failed to register FRAMEDONE isr\n");\r\ndispc_mgr_enable(channel, false);\r\nif (r) {\r\nmsleep(100);\r\nreturn;\r\n}\r\nif (!wait_for_completion_timeout(&framedone_compl,\r\nmsecs_to_jiffies(100)))\r\nDSSERR("timeout waiting for FRAME DONE\n");\r\nr = omap_dispc_unregister_isr(dispc_mgr_disable_isr, &framedone_compl,\r\nirq);\r\nif (r)\r\nDSSERR("failed to unregister FRAMEDONE isr\n");\r\n}\r\nstatic void dispc_digit_out_enable_isr(void *data, u32 mask)\r\n{\r\nstruct completion *compl = data;\r\nif (mask & (DISPC_IRQ_EVSYNC_EVEN | DISPC_IRQ_EVSYNC_ODD))\r\ncomplete(compl);\r\n}\r\nstatic void dispc_mgr_enable_digit_out(void)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(vsync_compl);\r\nint r;\r\nu32 irq_mask;\r\nif (dispc_mgr_is_enabled(OMAP_DSS_CHANNEL_DIGIT) == true)\r\nreturn;\r\nirq_mask = dispc_mgr_get_vsync_irq(OMAP_DSS_CHANNEL_DIGIT) |\r\ndispc_mgr_get_sync_lost_irq(OMAP_DSS_CHANNEL_DIGIT);\r\nr = omap_dispc_register_isr(dispc_digit_out_enable_isr, &vsync_compl,\r\nirq_mask);\r\nif (r) {\r\nDSSERR("failed to register %x isr\n", irq_mask);\r\nreturn;\r\n}\r\ndispc_mgr_enable(OMAP_DSS_CHANNEL_DIGIT, true);\r\nif (!wait_for_completion_timeout(&vsync_compl, msecs_to_jiffies(100)))\r\nDSSERR("timeout waiting for digit out to start\n");\r\nr = omap_dispc_unregister_isr(dispc_digit_out_enable_isr, &vsync_compl,\r\nirq_mask);\r\nif (r)\r\nDSSERR("failed to unregister %x isr\n", irq_mask);\r\n}\r\nstatic void dispc_mgr_disable_digit_out(void)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(framedone_compl);\r\nint r, i;\r\nu32 irq_mask;\r\nint num_irqs;\r\nif (dispc_mgr_is_enabled(OMAP_DSS_CHANNEL_DIGIT) == false)\r\nreturn;\r\nirq_mask = dispc_mgr_get_framedone_irq(OMAP_DSS_CHANNEL_DIGIT);\r\nnum_irqs = 1;\r\nif (!irq_mask) {\r\nirq_mask = dispc_mgr_get_vsync_irq(OMAP_DSS_CHANNEL_DIGIT);\r\nnum_irqs = 2;\r\n}\r\nr = omap_dispc_register_isr(dispc_mgr_disable_isr, &framedone_compl,\r\nirq_mask);\r\nif (r)\r\nDSSERR("failed to register %x isr\n", irq_mask);\r\ndispc_mgr_enable(OMAP_DSS_CHANNEL_DIGIT, false);\r\nif (r) {\r\nmsleep(100);\r\nreturn;\r\n}\r\nfor (i = 0; i < num_irqs; ++i) {\r\nif (!wait_for_completion_timeout(&framedone_compl,\r\nmsecs_to_jiffies(100)))\r\nDSSERR("timeout waiting for digit out to stop\n");\r\n}\r\nr = omap_dispc_unregister_isr(dispc_mgr_disable_isr, &framedone_compl,\r\nirq_mask);\r\nif (r)\r\nDSSERR("failed to unregister %x isr\n", irq_mask);\r\n}\r\nvoid dispc_mgr_enable_sync(enum omap_channel channel)\r\n{\r\nif (dss_mgr_is_lcd(channel))\r\ndispc_mgr_enable_lcd_out(channel);\r\nelse if (channel == OMAP_DSS_CHANNEL_DIGIT)\r\ndispc_mgr_enable_digit_out();\r\nelse\r\nWARN_ON(1);\r\n}\r\nvoid dispc_mgr_disable_sync(enum omap_channel channel)\r\n{\r\nif (dss_mgr_is_lcd(channel))\r\ndispc_mgr_disable_lcd_out(channel);\r\nelse if (channel == OMAP_DSS_CHANNEL_DIGIT)\r\ndispc_mgr_disable_digit_out();\r\nelse\r\nWARN_ON(1);\r\n}\r\nvoid dispc_irq_wait_handler(void *data, u32 mask)\r\n{\r\ncomplete((struct completion *)data);\r\n}
