static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)\r\n{\r\n#define REQ_HDR_LEN 8\r\n#define ACK_HDR_LEN 2\r\nstruct af9015_state *state = d_to_priv(d);\r\nint ret, wlen, rlen;\r\nu8 write = 1;\r\nmutex_lock(&d->usb_mutex);\r\nstate->buf[0] = req->cmd;\r\nstate->buf[1] = state->seq++;\r\nstate->buf[2] = req->i2c_addr;\r\nstate->buf[3] = req->addr >> 8;\r\nstate->buf[4] = req->addr & 0xff;\r\nstate->buf[5] = req->mbox;\r\nstate->buf[6] = req->addr_len;\r\nstate->buf[7] = req->data_len;\r\nswitch (req->cmd) {\r\ncase GET_CONFIG:\r\ncase READ_MEMORY:\r\ncase RECONNECT_USB:\r\nwrite = 0;\r\nbreak;\r\ncase READ_I2C:\r\nwrite = 0;\r\nstate->buf[2] |= 0x01;\r\ncase WRITE_I2C:\r\nstate->buf[0] = READ_WRITE_I2C;\r\nbreak;\r\ncase WRITE_MEMORY:\r\nif (((req->addr & 0xff00) == 0xff00) ||\r\n((req->addr & 0xff00) == 0xae00))\r\nstate->buf[0] = WRITE_VIRTUAL_MEMORY;\r\ncase WRITE_VIRTUAL_MEMORY:\r\ncase COPY_FIRMWARE:\r\ncase DOWNLOAD_FIRMWARE:\r\ncase BOOT:\r\nbreak;\r\ndefault:\r\ndev_err(&d->udev->dev, "%s: unknown command=%d\n",\r\nKBUILD_MODNAME, req->cmd);\r\nret = -EIO;\r\ngoto error;\r\n}\r\nif ((write && (req->data_len > BUF_LEN - REQ_HDR_LEN)) ||\r\n(!write && (req->data_len > BUF_LEN - ACK_HDR_LEN))) {\r\ndev_err(&d->udev->dev, "%s: too much data; cmd=%d len=%d\n",\r\nKBUILD_MODNAME, req->cmd, req->data_len);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nwlen = REQ_HDR_LEN;\r\nrlen = ACK_HDR_LEN;\r\nif (write) {\r\nwlen += req->data_len;\r\nmemcpy(&state->buf[REQ_HDR_LEN], req->data, req->data_len);\r\n} else {\r\nrlen += req->data_len;\r\n}\r\nif (req->cmd == DOWNLOAD_FIRMWARE || req->cmd == RECONNECT_USB)\r\nrlen = 0;\r\nret = dvb_usbv2_generic_rw_locked(d,\r\nstate->buf, wlen, state->buf, rlen);\r\nif (ret)\r\ngoto error;\r\nif (rlen && state->buf[1]) {\r\ndev_err(&d->udev->dev, "%s: command failed=%d\n",\r\nKBUILD_MODNAME, state->buf[1]);\r\nret = -EIO;\r\ngoto error;\r\n}\r\nif (!write)\r\nmemcpy(req->data, &state->buf[ACK_HDR_LEN], req->data_len);\r\nerror:\r\nmutex_unlock(&d->usb_mutex);\r\nreturn ret;\r\n}\r\nstatic int af9015_write_regs(struct dvb_usb_device *d, u16 addr, u8 *val,\r\nu8 len)\r\n{\r\nstruct req_t req = {WRITE_MEMORY, AF9015_I2C_DEMOD, addr, 0, 0, len,\r\nval};\r\nreturn af9015_ctrl_msg(d, &req);\r\n}\r\nstatic int af9015_read_regs(struct dvb_usb_device *d, u16 addr, u8 *val, u8 len)\r\n{\r\nstruct req_t req = {READ_MEMORY, AF9015_I2C_DEMOD, addr, 0, 0, len,\r\nval};\r\nreturn af9015_ctrl_msg(d, &req);\r\n}\r\nstatic int af9015_write_reg(struct dvb_usb_device *d, u16 addr, u8 val)\r\n{\r\nreturn af9015_write_regs(d, addr, &val, 1);\r\n}\r\nstatic int af9015_read_reg(struct dvb_usb_device *d, u16 addr, u8 *val)\r\n{\r\nreturn af9015_read_regs(d, addr, val, 1);\r\n}\r\nstatic int af9015_write_reg_i2c(struct dvb_usb_device *d, u8 addr, u16 reg,\r\nu8 val)\r\n{\r\nstruct af9015_state *state = d_to_priv(d);\r\nstruct req_t req = {WRITE_I2C, addr, reg, 1, 1, 1, &val};\r\nif (addr == state->af9013_config[0].i2c_addr ||\r\naddr == state->af9013_config[1].i2c_addr)\r\nreq.addr_len = 3;\r\nreturn af9015_ctrl_msg(d, &req);\r\n}\r\nstatic int af9015_read_reg_i2c(struct dvb_usb_device *d, u8 addr, u16 reg,\r\nu8 *val)\r\n{\r\nstruct af9015_state *state = d_to_priv(d);\r\nstruct req_t req = {READ_I2C, addr, reg, 0, 1, 1, val};\r\nif (addr == state->af9013_config[0].i2c_addr ||\r\naddr == state->af9013_config[1].i2c_addr)\r\nreq.addr_len = 3;\r\nreturn af9015_ctrl_msg(d, &req);\r\n}\r\nstatic int af9015_do_reg_bit(struct dvb_usb_device *d, u16 addr, u8 bit, u8 op)\r\n{\r\nint ret;\r\nu8 val, mask = 0x01;\r\nret = af9015_read_reg(d, addr, &val);\r\nif (ret)\r\nreturn ret;\r\nmask <<= bit;\r\nif (op) {\r\nval |= mask;\r\n} else {\r\nmask ^= 0xff;\r\nval &= mask;\r\n}\r\nreturn af9015_write_reg(d, addr, val);\r\n}\r\nstatic int af9015_set_reg_bit(struct dvb_usb_device *d, u16 addr, u8 bit)\r\n{\r\nreturn af9015_do_reg_bit(d, addr, bit, 1);\r\n}\r\nstatic int af9015_clear_reg_bit(struct dvb_usb_device *d, u16 addr, u8 bit)\r\n{\r\nreturn af9015_do_reg_bit(d, addr, bit, 0);\r\n}\r\nstatic int af9015_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstruct af9015_state *state = d_to_priv(d);\r\nint ret = 0, i = 0;\r\nu16 addr;\r\nu8 uninitialized_var(mbox), addr_len;\r\nstruct req_t req;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nwhile (i < num) {\r\nif (msg[i].addr == state->af9013_config[0].i2c_addr ||\r\nmsg[i].addr == state->af9013_config[1].i2c_addr) {\r\naddr = msg[i].buf[0] << 8;\r\naddr += msg[i].buf[1];\r\nmbox = msg[i].buf[2];\r\naddr_len = 3;\r\n} else {\r\naddr = msg[i].buf[0];\r\naddr_len = 1;\r\n}\r\nif (num > i + 1 && (msg[i+1].flags & I2C_M_RD)) {\r\nif (msg[i].len > 3 || msg[i+1].len > 61) {\r\nret = -EOPNOTSUPP;\r\ngoto error;\r\n}\r\nif (msg[i].addr == state->af9013_config[0].i2c_addr)\r\nreq.cmd = READ_MEMORY;\r\nelse\r\nreq.cmd = READ_I2C;\r\nreq.i2c_addr = msg[i].addr;\r\nreq.addr = addr;\r\nreq.mbox = mbox;\r\nreq.addr_len = addr_len;\r\nreq.data_len = msg[i+1].len;\r\nreq.data = &msg[i+1].buf[0];\r\nret = af9015_ctrl_msg(d, &req);\r\ni += 2;\r\n} else if (msg[i].flags & I2C_M_RD) {\r\nif (msg[i].len > 61) {\r\nret = -EOPNOTSUPP;\r\ngoto error;\r\n}\r\nif (msg[i].addr == state->af9013_config[0].i2c_addr) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nreq.cmd = READ_I2C;\r\nreq.i2c_addr = msg[i].addr;\r\nreq.addr = addr;\r\nreq.mbox = mbox;\r\nreq.addr_len = addr_len;\r\nreq.data_len = msg[i].len;\r\nreq.data = &msg[i].buf[0];\r\nret = af9015_ctrl_msg(d, &req);\r\ni += 1;\r\n} else {\r\nif (msg[i].len > 21) {\r\nret = -EOPNOTSUPP;\r\ngoto error;\r\n}\r\nif (msg[i].addr == state->af9013_config[0].i2c_addr)\r\nreq.cmd = WRITE_MEMORY;\r\nelse\r\nreq.cmd = WRITE_I2C;\r\nreq.i2c_addr = msg[i].addr;\r\nreq.addr = addr;\r\nreq.mbox = mbox;\r\nreq.addr_len = addr_len;\r\nreq.data_len = msg[i].len-addr_len;\r\nreq.data = &msg[i].buf[addr_len];\r\nret = af9015_ctrl_msg(d, &req);\r\ni += 1;\r\n}\r\nif (ret)\r\ngoto error;\r\n}\r\nret = i;\r\nerror:\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic u32 af9015_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int af9015_identify_state(struct dvb_usb_device *d, const char **name)\r\n{\r\nint ret;\r\nu8 reply;\r\nstruct req_t req = {GET_CONFIG, 0, 0, 0, 0, 1, &reply};\r\nret = af9015_ctrl_msg(d, &req);\r\nif (ret)\r\nreturn ret;\r\ndev_dbg(&d->udev->dev, "%s: reply=%02x\n", __func__, reply);\r\nif (reply == 0x02)\r\nret = WARM;\r\nelse\r\nret = COLD;\r\nreturn ret;\r\n}\r\nstatic int af9015_download_firmware(struct dvb_usb_device *d,\r\nconst struct firmware *fw)\r\n{\r\nstruct af9015_state *state = d_to_priv(d);\r\nint i, len, remaining, ret;\r\nstruct req_t req = {DOWNLOAD_FIRMWARE, 0, 0, 0, 0, 0, NULL};\r\nu16 checksum = 0;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nfor (i = 0; i < fw->size; i++)\r\nchecksum += fw->data[i];\r\nstate->firmware_size = fw->size;\r\nstate->firmware_checksum = checksum;\r\n#define FW_ADDR 0x5100\r\n#define LEN_MAX 55\r\nfor (remaining = fw->size; remaining > 0; remaining -= LEN_MAX) {\r\nlen = remaining;\r\nif (len > LEN_MAX)\r\nlen = LEN_MAX;\r\nreq.data_len = len;\r\nreq.data = (u8 *) &fw->data[fw->size - remaining];\r\nreq.addr = FW_ADDR + fw->size - remaining;\r\nret = af9015_ctrl_msg(d, &req);\r\nif (ret) {\r\ndev_err(&d->udev->dev,\r\n"%s: firmware download failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\ngoto error;\r\n}\r\n}\r\nreq.cmd = BOOT;\r\nreq.data_len = 0;\r\nret = af9015_ctrl_msg(d, &req);\r\nif (ret) {\r\ndev_err(&d->udev->dev, "%s: firmware boot failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\ngoto error;\r\n}\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int af9015_eeprom_hash(struct dvb_usb_device *d)\r\n{\r\nstruct af9015_state *state = d_to_priv(d);\r\nint ret, i;\r\nstatic const unsigned int AF9015_EEPROM_SIZE = 256;\r\nu8 buf[AF9015_EEPROM_SIZE];\r\nstruct req_t req = {READ_I2C, AF9015_I2C_EEPROM, 0, 0, 1, 1, NULL};\r\nfor (i = 0; i < AF9015_EEPROM_SIZE; i++) {\r\nreq.addr = i;\r\nreq.data = &buf[i];\r\nret = af9015_ctrl_msg(d, &req);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nfor (i = 0; i < AF9015_EEPROM_SIZE / sizeof(u32); i++) {\r\nstate->eeprom_sum *= GOLDEN_RATIO_PRIME_32;\r\nstate->eeprom_sum += le32_to_cpu(((u32 *)buf)[i]);\r\n}\r\nfor (i = 0; i < AF9015_EEPROM_SIZE; i += 16)\r\ndev_dbg(&d->udev->dev, "%s: %*ph\n", __func__, 16, buf + i);\r\ndev_dbg(&d->udev->dev, "%s: eeprom sum=%.8x\n",\r\n__func__, state->eeprom_sum);\r\nreturn 0;\r\nerr:\r\ndev_err(&d->udev->dev, "%s: eeprom failed=%d\n", KBUILD_MODNAME, ret);\r\nreturn ret;\r\n}\r\nstatic int af9015_read_config(struct dvb_usb_device *d)\r\n{\r\nstruct af9015_state *state = d_to_priv(d);\r\nint ret;\r\nu8 val, i, offset = 0;\r\nstruct req_t req = {READ_I2C, AF9015_I2C_EEPROM, 0, 0, 1, 1, &val};\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nreq.addr = AF9015_EEPROM_IR_MODE;\r\nfor (i = 0; i < 4; i++) {\r\nret = af9015_ctrl_msg(d, &req);\r\nif (!ret)\r\nbreak;\r\n}\r\nif (ret)\r\ngoto error;\r\nret = af9015_eeprom_hash(d);\r\nif (ret)\r\ngoto error;\r\nstate->ir_mode = val;\r\ndev_dbg(&d->udev->dev, "%s: IR mode=%d\n", __func__, val);\r\nreq.addr = AF9015_EEPROM_TS_MODE;\r\nret = af9015_ctrl_msg(d, &req);\r\nif (ret)\r\ngoto error;\r\nstate->dual_mode = val;\r\ndev_dbg(&d->udev->dev, "%s: TS mode=%d\n", __func__, state->dual_mode);\r\nif (d->udev->speed == USB_SPEED_FULL)\r\nstate->dual_mode = 0;\r\nif (state->dual_mode) {\r\nreq.addr = AF9015_EEPROM_DEMOD2_I2C;\r\nret = af9015_ctrl_msg(d, &req);\r\nif (ret)\r\ngoto error;\r\nstate->af9013_config[1].i2c_addr = val;\r\n}\r\nfor (i = 0; i < state->dual_mode + 1; i++) {\r\nif (i == 1)\r\noffset = AF9015_EEPROM_OFFSET;\r\nreq.addr = AF9015_EEPROM_XTAL_TYPE1 + offset;\r\nret = af9015_ctrl_msg(d, &req);\r\nif (ret)\r\ngoto error;\r\nswitch (val) {\r\ncase 0:\r\nstate->af9013_config[i].clock = 28800000;\r\nbreak;\r\ncase 1:\r\nstate->af9013_config[i].clock = 20480000;\r\nbreak;\r\ncase 2:\r\nstate->af9013_config[i].clock = 28000000;\r\nbreak;\r\ncase 3:\r\nstate->af9013_config[i].clock = 25000000;\r\nbreak;\r\n}\r\ndev_dbg(&d->udev->dev, "%s: [%d] xtal=%d set clock=%d\n",\r\n__func__, i, val,\r\nstate->af9013_config[i].clock);\r\nreq.addr = AF9015_EEPROM_IF1H + offset;\r\nret = af9015_ctrl_msg(d, &req);\r\nif (ret)\r\ngoto error;\r\nstate->af9013_config[i].if_frequency = val << 8;\r\nreq.addr = AF9015_EEPROM_IF1L + offset;\r\nret = af9015_ctrl_msg(d, &req);\r\nif (ret)\r\ngoto error;\r\nstate->af9013_config[i].if_frequency += val;\r\nstate->af9013_config[i].if_frequency *= 1000;\r\ndev_dbg(&d->udev->dev, "%s: [%d] IF frequency=%d\n", __func__,\r\ni, state->af9013_config[i].if_frequency);\r\nreq.addr = AF9015_EEPROM_MT2060_IF1H + offset;\r\nret = af9015_ctrl_msg(d, &req);\r\nif (ret)\r\ngoto error;\r\nstate->mt2060_if1[i] = val << 8;\r\nreq.addr = AF9015_EEPROM_MT2060_IF1L + offset;\r\nret = af9015_ctrl_msg(d, &req);\r\nif (ret)\r\ngoto error;\r\nstate->mt2060_if1[i] += val;\r\ndev_dbg(&d->udev->dev, "%s: [%d] MT2060 IF1=%d\n", __func__, i,\r\nstate->mt2060_if1[i]);\r\nreq.addr = AF9015_EEPROM_TUNER_ID1 + offset;\r\nret = af9015_ctrl_msg(d, &req);\r\nif (ret)\r\ngoto error;\r\nswitch (val) {\r\ncase AF9013_TUNER_ENV77H11D5:\r\ncase AF9013_TUNER_MT2060:\r\ncase AF9013_TUNER_QT1010:\r\ncase AF9013_TUNER_UNKNOWN:\r\ncase AF9013_TUNER_MT2060_2:\r\ncase AF9013_TUNER_TDA18271:\r\ncase AF9013_TUNER_QT1010A:\r\ncase AF9013_TUNER_TDA18218:\r\nstate->af9013_config[i].spec_inv = 1;\r\nbreak;\r\ncase AF9013_TUNER_MXL5003D:\r\ncase AF9013_TUNER_MXL5005D:\r\ncase AF9013_TUNER_MXL5005R:\r\ncase AF9013_TUNER_MXL5007T:\r\nstate->af9013_config[i].spec_inv = 0;\r\nbreak;\r\ncase AF9013_TUNER_MC44S803:\r\nstate->af9013_config[i].gpio[1] = AF9013_GPIO_LO;\r\nstate->af9013_config[i].spec_inv = 1;\r\nbreak;\r\ndefault:\r\ndev_err(&d->udev->dev, "%s: tuner id=%d not " \\r\n"supported, please report!\n",\r\nKBUILD_MODNAME, val);\r\nreturn -ENODEV;\r\n}\r\nstate->af9013_config[i].tuner = val;\r\ndev_dbg(&d->udev->dev, "%s: [%d] tuner id=%d\n",\r\n__func__, i, val);\r\n}\r\nerror:\r\nif (ret)\r\ndev_err(&d->udev->dev, "%s: eeprom read failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\nif (le16_to_cpu(d->udev->descriptor.idVendor) == USB_VID_AVERMEDIA &&\r\n((le16_to_cpu(d->udev->descriptor.idProduct) ==\r\nUSB_PID_AVERMEDIA_A850) ||\r\n(le16_to_cpu(d->udev->descriptor.idProduct) ==\r\nUSB_PID_AVERMEDIA_A850T))) {\r\ndev_dbg(&d->udev->dev,\r\n"%s: AverMedia A850: overriding config\n",\r\n__func__);\r\nstate->dual_mode = 0;\r\nstate->af9013_config[0].if_frequency = 4570000;\r\n}\r\nreturn ret;\r\n}\r\nstatic int af9015_get_stream_config(struct dvb_frontend *fe, u8 *ts_type,\r\nstruct usb_data_stream_properties *stream)\r\n{\r\nstruct dvb_usb_device *d = fe_to_d(fe);\r\ndev_dbg(&d->udev->dev, "%s: adap=%d\n", __func__, fe_to_adap(fe)->id);\r\nif (d->udev->speed == USB_SPEED_FULL)\r\nstream->u.bulk.buffersize = TS_USB11_FRAME_SIZE;\r\nreturn 0;\r\n}\r\nstatic int af9015_get_adapter_count(struct dvb_usb_device *d)\r\n{\r\nstruct af9015_state *state = d_to_priv(d);\r\nreturn state->dual_mode + 1;\r\n}\r\nstatic int af9015_af9013_set_frontend(struct dvb_frontend *fe)\r\n{\r\nint ret;\r\nstruct af9015_state *state = fe_to_priv(fe);\r\nif (mutex_lock_interruptible(&state->fe_mutex))\r\nreturn -EAGAIN;\r\nret = state->set_frontend[fe_to_adap(fe)->id](fe);\r\nmutex_unlock(&state->fe_mutex);\r\nreturn ret;\r\n}\r\nstatic int af9015_af9013_read_status(struct dvb_frontend *fe,\r\nfe_status_t *status)\r\n{\r\nint ret;\r\nstruct af9015_state *state = fe_to_priv(fe);\r\nif (mutex_lock_interruptible(&state->fe_mutex))\r\nreturn -EAGAIN;\r\nret = state->read_status[fe_to_adap(fe)->id](fe, status);\r\nmutex_unlock(&state->fe_mutex);\r\nreturn ret;\r\n}\r\nstatic int af9015_af9013_init(struct dvb_frontend *fe)\r\n{\r\nint ret;\r\nstruct af9015_state *state = fe_to_priv(fe);\r\nif (mutex_lock_interruptible(&state->fe_mutex))\r\nreturn -EAGAIN;\r\nret = state->init[fe_to_adap(fe)->id](fe);\r\nmutex_unlock(&state->fe_mutex);\r\nreturn ret;\r\n}\r\nstatic int af9015_af9013_sleep(struct dvb_frontend *fe)\r\n{\r\nint ret;\r\nstruct af9015_state *state = fe_to_priv(fe);\r\nif (mutex_lock_interruptible(&state->fe_mutex))\r\nreturn -EAGAIN;\r\nret = state->sleep[fe_to_adap(fe)->id](fe);\r\nmutex_unlock(&state->fe_mutex);\r\nreturn ret;\r\n}\r\nstatic int af9015_tuner_init(struct dvb_frontend *fe)\r\n{\r\nint ret;\r\nstruct af9015_state *state = fe_to_priv(fe);\r\nif (mutex_lock_interruptible(&state->fe_mutex))\r\nreturn -EAGAIN;\r\nret = state->tuner_init[fe_to_adap(fe)->id](fe);\r\nmutex_unlock(&state->fe_mutex);\r\nreturn ret;\r\n}\r\nstatic int af9015_tuner_sleep(struct dvb_frontend *fe)\r\n{\r\nint ret;\r\nstruct af9015_state *state = fe_to_priv(fe);\r\nif (mutex_lock_interruptible(&state->fe_mutex))\r\nreturn -EAGAIN;\r\nret = state->tuner_sleep[fe_to_adap(fe)->id](fe);\r\nmutex_unlock(&state->fe_mutex);\r\nreturn ret;\r\n}\r\nstatic int af9015_copy_firmware(struct dvb_usb_device *d)\r\n{\r\nstruct af9015_state *state = d_to_priv(d);\r\nint ret;\r\nu8 fw_params[4];\r\nu8 val, i;\r\nstruct req_t req = {COPY_FIRMWARE, 0, 0x5100, 0, 0, sizeof(fw_params),\r\nfw_params };\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nfw_params[0] = state->firmware_size >> 8;\r\nfw_params[1] = state->firmware_size & 0xff;\r\nfw_params[2] = state->firmware_checksum >> 8;\r\nfw_params[3] = state->firmware_checksum & 0xff;\r\nmsleep(100);\r\nret = af9015_read_reg_i2c(d, state->af9013_config[1].i2c_addr,\r\n0x98be, &val);\r\nif (ret)\r\ngoto error;\r\nelse\r\ndev_dbg(&d->udev->dev, "%s: firmware status=%02x\n",\r\n__func__, val);\r\nif (val == 0x0c)\r\ngoto exit;\r\nret = af9015_write_reg(d, 0xd416, 0x04);\r\nif (ret)\r\ngoto error;\r\nmsleep(50);\r\nret = af9015_ctrl_msg(d, &req);\r\nif (ret)\r\ndev_err(&d->udev->dev, "%s: firmware copy cmd failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\ndev_dbg(&d->udev->dev, "%s: firmware copy done\n", __func__);\r\nret = af9015_write_reg(d, 0xd416, 0x14);\r\nif (ret)\r\ngoto error;\r\nret = af9015_write_reg_i2c(d, state->af9013_config[1].i2c_addr,\r\n0xe205, 1);\r\ndev_dbg(&d->udev->dev, "%s: firmware boot cmd status=%d\n",\r\n__func__, ret);\r\nif (ret)\r\ngoto error;\r\nfor (i = 0; i < 15; i++) {\r\nmsleep(100);\r\nret = af9015_read_reg_i2c(d, state->af9013_config[1].i2c_addr,\r\n0x98be, &val);\r\ndev_dbg(&d->udev->dev, "%s: firmware status cmd status=%d " \\r\n"firmware status=%02x\n", __func__, ret, val);\r\nif (ret)\r\ngoto error;\r\nif (val == 0x0c || val == 0x04)\r\nbreak;\r\n}\r\nif (val == 0x04) {\r\ndev_err(&d->udev->dev, "%s: firmware did not run\n",\r\nKBUILD_MODNAME);\r\nret = -ETIMEDOUT;\r\n} else if (val != 0x0c) {\r\ndev_err(&d->udev->dev, "%s: firmware boot timeout\n",\r\nKBUILD_MODNAME);\r\nret = -ETIMEDOUT;\r\n}\r\nerror:\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int af9015_af9013_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nint ret;\r\nstruct af9015_state *state = adap_to_priv(adap);\r\nif (adap->id == 0) {\r\nstate->af9013_config[0].ts_mode = AF9013_TS_USB;\r\nmemcpy(state->af9013_config[0].api_version, "\x0\x1\x9\x0", 4);\r\nstate->af9013_config[0].gpio[0] = AF9013_GPIO_HI;\r\nstate->af9013_config[0].gpio[3] = AF9013_GPIO_TUNER_ON;\r\n} else if (adap->id == 1) {\r\nstate->af9013_config[1].ts_mode = AF9013_TS_SERIAL;\r\nmemcpy(state->af9013_config[1].api_version, "\x0\x1\x9\x0", 4);\r\nstate->af9013_config[1].gpio[0] = AF9013_GPIO_TUNER_ON;\r\nstate->af9013_config[1].gpio[1] = AF9013_GPIO_LO;\r\nif (state->dual_mode) {\r\nret = af9015_copy_firmware(adap_to_d(adap));\r\nif (ret) {\r\ndev_err(&adap_to_d(adap)->udev->dev,\r\n"%s: firmware copy to 2nd " \\r\n"frontend failed, will " \\r\n"disable it\n", KBUILD_MODNAME);\r\nstate->dual_mode = 0;\r\nreturn -ENODEV;\r\n}\r\n} else {\r\nreturn -ENODEV;\r\n}\r\n}\r\nadap->fe[0] = dvb_attach(af9013_attach,\r\n&state->af9013_config[adap->id], &adap_to_d(adap)->i2c_adap);\r\nif (adap->fe[0]) {\r\nstate->set_frontend[adap->id] =\r\nadap->fe[0]->ops.set_frontend;\r\nadap->fe[0]->ops.set_frontend =\r\naf9015_af9013_set_frontend;\r\nstate->read_status[adap->id] =\r\nadap->fe[0]->ops.read_status;\r\nadap->fe[0]->ops.read_status =\r\naf9015_af9013_read_status;\r\nstate->init[adap->id] = adap->fe[0]->ops.init;\r\nadap->fe[0]->ops.init = af9015_af9013_init;\r\nstate->sleep[adap->id] = adap->fe[0]->ops.sleep;\r\nadap->fe[0]->ops.sleep = af9015_af9013_sleep;\r\n}\r\nreturn adap->fe[0] == NULL ? -ENODEV : 0;\r\n}\r\nstatic int af9015_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct af9015_state *state = d_to_priv(d);\r\nint ret;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nswitch (state->af9013_config[adap->id].tuner) {\r\ncase AF9013_TUNER_MT2060:\r\ncase AF9013_TUNER_MT2060_2:\r\nret = dvb_attach(mt2060_attach, adap->fe[0],\r\n&adap_to_d(adap)->i2c_adap, &af9015_mt2060_config,\r\nstate->mt2060_if1[adap->id])\r\n== NULL ? -ENODEV : 0;\r\nbreak;\r\ncase AF9013_TUNER_QT1010:\r\ncase AF9013_TUNER_QT1010A:\r\nret = dvb_attach(qt1010_attach, adap->fe[0],\r\n&adap_to_d(adap)->i2c_adap,\r\n&af9015_qt1010_config) == NULL ? -ENODEV : 0;\r\nbreak;\r\ncase AF9013_TUNER_TDA18271:\r\nret = dvb_attach(tda18271_attach, adap->fe[0], 0xc0,\r\n&adap_to_d(adap)->i2c_adap,\r\n&af9015_tda18271_config) == NULL ? -ENODEV : 0;\r\nbreak;\r\ncase AF9013_TUNER_TDA18218:\r\nret = dvb_attach(tda18218_attach, adap->fe[0],\r\n&adap_to_d(adap)->i2c_adap,\r\n&af9015_tda18218_config) == NULL ? -ENODEV : 0;\r\nbreak;\r\ncase AF9013_TUNER_MXL5003D:\r\nret = dvb_attach(mxl5005s_attach, adap->fe[0],\r\n&adap_to_d(adap)->i2c_adap,\r\n&af9015_mxl5003_config) == NULL ? -ENODEV : 0;\r\nbreak;\r\ncase AF9013_TUNER_MXL5005D:\r\ncase AF9013_TUNER_MXL5005R:\r\nret = dvb_attach(mxl5005s_attach, adap->fe[0],\r\n&adap_to_d(adap)->i2c_adap,\r\n&af9015_mxl5005_config) == NULL ? -ENODEV : 0;\r\nbreak;\r\ncase AF9013_TUNER_ENV77H11D5:\r\nret = dvb_attach(dvb_pll_attach, adap->fe[0], 0xc0,\r\n&adap_to_d(adap)->i2c_adap,\r\nDVB_PLL_TDA665X) == NULL ? -ENODEV : 0;\r\nbreak;\r\ncase AF9013_TUNER_MC44S803:\r\nret = dvb_attach(mc44s803_attach, adap->fe[0],\r\n&adap_to_d(adap)->i2c_adap,\r\n&af9015_mc44s803_config) == NULL ? -ENODEV : 0;\r\nbreak;\r\ncase AF9013_TUNER_MXL5007T:\r\nret = dvb_attach(mxl5007t_attach, adap->fe[0],\r\n&adap_to_d(adap)->i2c_adap,\r\n0xc0, &af9015_mxl5007t_config) == NULL ? -ENODEV : 0;\r\nbreak;\r\ncase AF9013_TUNER_UNKNOWN:\r\ndefault:\r\ndev_err(&d->udev->dev, "%s: unknown tuner id=%d\n",\r\nKBUILD_MODNAME,\r\nstate->af9013_config[adap->id].tuner);\r\nret = -ENODEV;\r\n}\r\nif (adap->fe[0]->ops.tuner_ops.init) {\r\nstate->tuner_init[adap->id] =\r\nadap->fe[0]->ops.tuner_ops.init;\r\nadap->fe[0]->ops.tuner_ops.init = af9015_tuner_init;\r\n}\r\nif (adap->fe[0]->ops.tuner_ops.sleep) {\r\nstate->tuner_sleep[adap->id] =\r\nadap->fe[0]->ops.tuner_ops.sleep;\r\nadap->fe[0]->ops.tuner_ops.sleep = af9015_tuner_sleep;\r\n}\r\nreturn ret;\r\n}\r\nstatic int af9015_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nint ret;\r\ndev_dbg(&d->udev->dev, "%s: onoff=%d\n", __func__, onoff);\r\nif (onoff)\r\nret = af9015_set_reg_bit(d, 0xd503, 0);\r\nelse\r\nret = af9015_clear_reg_bit(d, 0xd503, 0);\r\nreturn ret;\r\n}\r\nstatic int af9015_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid,\r\nint onoff)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nint ret;\r\nu8 idx;\r\ndev_dbg(&d->udev->dev, "%s: index=%d pid=%04x onoff=%d\n",\r\n__func__, index, pid, onoff);\r\nret = af9015_write_reg(d, 0xd505, (pid & 0xff));\r\nif (ret)\r\ngoto error;\r\nret = af9015_write_reg(d, 0xd506, (pid >> 8));\r\nif (ret)\r\ngoto error;\r\nidx = ((index & 0x1f) | (1 << 5));\r\nret = af9015_write_reg(d, 0xd504, idx);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int af9015_init_endpoint(struct dvb_usb_device *d)\r\n{\r\nstruct af9015_state *state = d_to_priv(d);\r\nint ret;\r\nu16 frame_size;\r\nu8 packet_size;\r\ndev_dbg(&d->udev->dev, "%s: USB speed=%d\n", __func__, d->udev->speed);\r\nif (d->udev->speed == USB_SPEED_FULL) {\r\nframe_size = TS_USB11_FRAME_SIZE/4;\r\npacket_size = TS_USB11_MAX_PACKET_SIZE/4;\r\n} else {\r\nframe_size = TS_USB20_FRAME_SIZE/4;\r\npacket_size = TS_USB20_MAX_PACKET_SIZE/4;\r\n}\r\nret = af9015_set_reg_bit(d, 0xd507, 2);\r\nif (ret)\r\ngoto error;\r\nret = af9015_set_reg_bit(d, 0xd50b, 1);\r\nif (ret)\r\ngoto error;\r\nret = af9015_clear_reg_bit(d, 0xdd11, 5);\r\nif (ret)\r\ngoto error;\r\nret = af9015_clear_reg_bit(d, 0xdd11, 6);\r\nif (ret)\r\ngoto error;\r\nret = af9015_set_reg_bit(d, 0xdd11, 5);\r\nif (ret)\r\ngoto error;\r\nif (state->dual_mode) {\r\nret = af9015_set_reg_bit(d, 0xdd11, 6);\r\nif (ret)\r\ngoto error;\r\n}\r\nret = af9015_clear_reg_bit(d, 0xdd13, 5);\r\nif (ret)\r\ngoto error;\r\nif (state->dual_mode) {\r\nret = af9015_clear_reg_bit(d, 0xdd13, 6);\r\nif (ret)\r\ngoto error;\r\n}\r\nret = af9015_write_reg(d, 0xdd88, frame_size & 0xff);\r\nif (ret)\r\ngoto error;\r\nret = af9015_write_reg(d, 0xdd89, frame_size >> 8);\r\nif (ret)\r\ngoto error;\r\nret = af9015_write_reg(d, 0xdd8a, frame_size & 0xff);\r\nif (ret)\r\ngoto error;\r\nret = af9015_write_reg(d, 0xdd8b, frame_size >> 8);\r\nif (ret)\r\ngoto error;\r\nret = af9015_write_reg(d, 0xdd0c, packet_size);\r\nif (ret)\r\ngoto error;\r\nret = af9015_write_reg(d, 0xdd0d, packet_size);\r\nif (ret)\r\ngoto error;\r\nret = af9015_clear_reg_bit(d, 0xd507, 2);\r\nif (ret)\r\ngoto error;\r\nif (state->dual_mode) {\r\nret = af9015_clear_reg_bit(d, 0xd50b, 1);\r\nif (ret)\r\ngoto error;\r\n}\r\nif (state->dual_mode)\r\nret = af9015_set_reg_bit(d, 0xd50b, 0);\r\nelse\r\nret = af9015_clear_reg_bit(d, 0xd50b, 0);\r\nerror:\r\nif (ret)\r\ndev_err(&d->udev->dev, "%s: endpoint init failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\nreturn ret;\r\n}\r\nstatic int af9015_init(struct dvb_usb_device *d)\r\n{\r\nstruct af9015_state *state = d_to_priv(d);\r\nint ret;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nmutex_init(&state->fe_mutex);\r\nret = af9015_write_reg(d, 0x98e9, 0xff);\r\nif (ret)\r\ngoto error;\r\nret = af9015_init_endpoint(d);\r\nif (ret)\r\ngoto error;\r\nerror:\r\nreturn ret;\r\n}\r\nstatic char *af9015_rc_setup_match(unsigned int id,\r\nconst struct af9015_rc_setup *table)\r\n{\r\nfor (; table->rc_codes; table++)\r\nif (table->id == id)\r\nreturn table->rc_codes;\r\nreturn NULL;\r\n}\r\nstatic int af9015_rc_query(struct dvb_usb_device *d)\r\n{\r\nstruct af9015_state *state = d_to_priv(d);\r\nint ret;\r\nu8 buf[17];\r\nret = af9015_read_regs(d, 0x98d9, buf, sizeof(buf));\r\nif (ret)\r\ngoto error;\r\nif (buf[1] || buf[2] || buf[3]) {\r\ndev_dbg(&d->udev->dev, "%s: invalid data\n", __func__);\r\nreturn ret;\r\n}\r\nif ((state->rc_repeat != buf[6] || buf[0]) &&\r\n!memcmp(&buf[12], state->rc_last, 4)) {\r\ndev_dbg(&d->udev->dev, "%s: key repeated\n", __func__);\r\nrc_keydown(d->rc_dev, state->rc_keycode, 0);\r\nstate->rc_repeat = buf[6];\r\nreturn ret;\r\n}\r\nif (buf[16] != 0xff && buf[0] != 0x01) {\r\ndev_dbg(&d->udev->dev, "%s: key pressed %*ph\n",\r\n__func__, 4, buf + 12);\r\nret = af9015_write_reg(d, 0x98e9, 0xff);\r\nif (ret)\r\ngoto error;\r\nmemcpy(state->rc_last, &buf[12], 4);\r\nif (buf[14] == (u8) ~buf[15]) {\r\nif (buf[12] == (u8) ~buf[13]) {\r\nstate->rc_keycode = buf[12] << 8 | buf[14];\r\n} else {\r\nstate->rc_keycode = buf[12] << 16 |\r\nbuf[13] << 8 | buf[14];\r\n}\r\n} else {\r\nstate->rc_keycode = buf[12] << 24 | buf[13] << 16 |\r\nbuf[14] << 8 | buf[15];\r\n}\r\nrc_keydown(d->rc_dev, state->rc_keycode, 0);\r\n} else {\r\ndev_dbg(&d->udev->dev, "%s: no key press\n", __func__);\r\nstate->rc_last[2] = state->rc_last[3];\r\n}\r\nstate->rc_repeat = buf[6];\r\nstate->rc_failed = false;\r\nerror:\r\nif (ret) {\r\ndev_warn(&d->udev->dev, "%s: rc query failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\nif (!state->rc_failed)\r\nret = 0;\r\nstate->rc_failed = true;\r\n}\r\nreturn ret;\r\n}\r\nstatic int af9015_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)\r\n{\r\nstruct af9015_state *state = d_to_priv(d);\r\nu16 vid = le16_to_cpu(d->udev->descriptor.idVendor);\r\nif (state->ir_mode == AF9015_IR_MODE_DISABLED)\r\nreturn 0;\r\nif (!rc->map_name)\r\nrc->map_name = af9015_rc_setup_match(dvb_usb_af9015_remote,\r\naf9015_rc_setup_modparam);\r\nif (!rc->map_name)\r\nrc->map_name = af9015_rc_setup_match(state->eeprom_sum,\r\naf9015_rc_setup_hashes);\r\nif (!rc->map_name && vid == USB_VID_AFATECH) {\r\nchar manufacturer[10];\r\nmemset(manufacturer, 0, sizeof(manufacturer));\r\nusb_string(d->udev, d->udev->descriptor.iManufacturer,\r\nmanufacturer, sizeof(manufacturer));\r\nif (!strcmp("MSI", manufacturer)) {\r\nrc->map_name = af9015_rc_setup_match(\r\nAF9015_REMOTE_MSI_DIGIVOX_MINI_II_V3,\r\naf9015_rc_setup_modparam);\r\n}\r\n}\r\nif (!rc->map_name)\r\nrc->map_name = RC_MAP_EMPTY;\r\nrc->allowed_protos = RC_BIT_NEC;\r\nrc->query = af9015_rc_query;\r\nrc->interval = 500;\r\nreturn 0;\r\n}\r\nstatic int af9015_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nchar manufacturer[sizeof("ITE Technologies, Inc.")];\r\nmemset(manufacturer, 0, sizeof(manufacturer));\r\nusb_string(udev, udev->descriptor.iManufacturer,\r\nmanufacturer, sizeof(manufacturer));\r\nif ((le16_to_cpu(udev->descriptor.idVendor) == USB_VID_TERRATEC) &&\r\n(le16_to_cpu(udev->descriptor.idProduct) == 0x0099)) {\r\nif (!strcmp("ITE Technologies, Inc.", manufacturer)) {\r\ndev_dbg(&udev->dev, "%s: rejecting device\n", __func__);\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn dvb_usbv2_probe(intf, id);\r\n}
