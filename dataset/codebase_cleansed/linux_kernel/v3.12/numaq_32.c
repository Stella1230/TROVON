static inline void numaq_register_node(int node, struct sys_cfg_data *scd)\r\n{\r\nstruct eachquadmem *eq = scd->eq + node;\r\nu64 start = (u64)(eq->hi_shrd_mem_start - eq->priv_mem_size) << 20;\r\nu64 end = (u64)(eq->hi_shrd_mem_start + eq->hi_shrd_mem_size) << 20;\r\nint ret;\r\nnode_set(node, numa_nodes_parsed);\r\nret = numa_add_memblk(node, start, end);\r\nBUG_ON(ret < 0);\r\n}\r\nstatic void __init smp_dump_qct(void)\r\n{\r\nstruct sys_cfg_data *scd;\r\nint node;\r\nscd = (void *)__va(SYS_CFG_DATA_PRIV_ADDR);\r\nfor_each_node(node) {\r\nif (scd->quads_present31_0 & (1 << node))\r\nnumaq_register_node(node, scd);\r\n}\r\n}\r\nvoid numaq_tsc_disable(void)\r\n{\r\nif (!found_numaq)\r\nreturn;\r\nif (num_online_nodes() > 1) {\r\nprintk(KERN_DEBUG "NUMAQ: disabling TSC\n");\r\nsetup_clear_cpu_cap(X86_FEATURE_TSC);\r\n}\r\n}\r\nstatic void __init numaq_tsc_init(void)\r\n{\r\nnumaq_tsc_disable();\r\n}\r\nstatic inline int generate_logical_apicid(int quad, int phys_apicid)\r\n{\r\nreturn (quad << 4) + (phys_apicid ? phys_apicid << 1 : 1);\r\n}\r\nstatic int mpc_apic_id(struct mpc_cpu *m)\r\n{\r\nint quad = translation_table[mpc_record]->trans_quad;\r\nint logical_apicid = generate_logical_apicid(quad, m->apicid);\r\nprintk(KERN_DEBUG\r\n"Processor #%d %u:%u APIC version %d (quad %d, apic %d)\n",\r\nm->apicid, (m->cpufeature & CPU_FAMILY_MASK) >> 8,\r\n(m->cpufeature & CPU_MODEL_MASK) >> 4,\r\nm->apicver, quad, logical_apicid);\r\nreturn logical_apicid;\r\n}\r\nstatic void mpc_oem_bus_info(struct mpc_bus *m, char *name)\r\n{\r\nint quad = translation_table[mpc_record]->trans_quad;\r\nint local = translation_table[mpc_record]->trans_local;\r\nmp_bus_id_to_node[m->busid] = quad;\r\nmp_bus_id_to_local[m->busid] = local;\r\nprintk(KERN_INFO "Bus #%d is %s (node %d)\n", m->busid, name, quad);\r\n}\r\nstatic void mpc_oem_pci_bus(struct mpc_bus *m)\r\n{\r\nint quad = translation_table[mpc_record]->trans_quad;\r\nint local = translation_table[mpc_record]->trans_local;\r\nquad_local_to_mp_bus_id[quad][local] = m->busid;\r\n}\r\nstatic void numaq_mpc_record(unsigned int mode)\r\n{\r\nif (!mode)\r\nmpc_record = 0;\r\nelse\r\nmpc_record++;\r\n}\r\nstatic void __init MP_translation_info(struct mpc_trans *m)\r\n{\r\nprintk(KERN_INFO\r\n"Translation: record %d, type %d, quad %d, global %d, local %d\n",\r\nmpc_record, m->trans_type, m->trans_quad, m->trans_global,\r\nm->trans_local);\r\nif (mpc_record >= MAX_MPC_ENTRY)\r\nprintk(KERN_ERR "MAX_MPC_ENTRY exceeded!\n");\r\nelse\r\ntranslation_table[mpc_record] = m;\r\nif (m->trans_quad < MAX_NUMNODES && !node_online(m->trans_quad))\r\nnode_set_online(m->trans_quad);\r\n}\r\nstatic int __init mpf_checksum(unsigned char *mp, int len)\r\n{\r\nint sum = 0;\r\nwhile (len--)\r\nsum += *mp++;\r\nreturn sum & 0xFF;\r\n}\r\nstatic void __init smp_read_mpc_oem(struct mpc_table *mpc)\r\n{\r\nstruct mpc_oemtable *oemtable = (void *)(long)mpc->oemptr;\r\nint count = sizeof(*oemtable);\r\nunsigned char *oemptr = ((unsigned char *)oemtable) + count;\r\nmpc_record = 0;\r\nprintk(KERN_INFO\r\n"Found an OEM MPC table at %8p - parsing it...\n", oemtable);\r\nif (memcmp(oemtable->signature, MPC_OEM_SIGNATURE, 4)) {\r\nprintk(KERN_WARNING\r\n"SMP mpc oemtable: bad signature [%c%c%c%c]!\n",\r\noemtable->signature[0], oemtable->signature[1],\r\noemtable->signature[2], oemtable->signature[3]);\r\nreturn;\r\n}\r\nif (mpf_checksum((unsigned char *)oemtable, oemtable->length)) {\r\nprintk(KERN_WARNING "SMP oem mptable: checksum error!\n");\r\nreturn;\r\n}\r\nwhile (count < oemtable->length) {\r\nswitch (*oemptr) {\r\ncase MP_TRANSLATION:\r\n{\r\nstruct mpc_trans *m = (void *)oemptr;\r\nMP_translation_info(m);\r\noemptr += sizeof(*m);\r\ncount += sizeof(*m);\r\n++mpc_record;\r\nbreak;\r\n}\r\ndefault:\r\nprintk(KERN_WARNING\r\n"Unrecognised OEM table entry type! - %d\n",\r\n(int)*oemptr);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic __init void early_check_numaq(void)\r\n{\r\nif (smp_found_config)\r\nearly_get_smp_config();\r\nif (found_numaq) {\r\nx86_init.mpparse.mpc_record = numaq_mpc_record;\r\nx86_init.mpparse.setup_ioapic_ids = x86_init_noop;\r\nx86_init.mpparse.mpc_apic_id = mpc_apic_id;\r\nx86_init.mpparse.smp_read_mpc_oem = smp_read_mpc_oem;\r\nx86_init.mpparse.mpc_oem_pci_bus = mpc_oem_pci_bus;\r\nx86_init.mpparse.mpc_oem_bus_info = mpc_oem_bus_info;\r\nx86_init.timers.tsc_pre_init = numaq_tsc_init;\r\nx86_init.pci.init = pci_numaq_init;\r\n}\r\n}\r\nint __init numaq_numa_init(void)\r\n{\r\nearly_check_numaq();\r\nif (!found_numaq)\r\nreturn -ENOENT;\r\nsmp_dump_qct();\r\nreturn 0;\r\n}\r\nstatic inline unsigned int numaq_get_apic_id(unsigned long x)\r\n{\r\nreturn (x >> 24) & 0x0F;\r\n}\r\nstatic inline void numaq_send_IPI_mask(const struct cpumask *mask, int vector)\r\n{\r\ndefault_send_IPI_mask_sequence_logical(mask, vector);\r\n}\r\nstatic inline void numaq_send_IPI_allbutself(int vector)\r\n{\r\ndefault_send_IPI_mask_allbutself_logical(cpu_online_mask, vector);\r\n}\r\nstatic inline void numaq_send_IPI_all(int vector)\r\n{\r\nnumaq_send_IPI_mask(cpu_online_mask, vector);\r\n}\r\nstatic inline void numaq_smp_callin_clear_local_apic(void)\r\n{\r\nclear_local_APIC();\r\n}\r\nstatic inline const struct cpumask *numaq_target_cpus(void)\r\n{\r\nreturn cpu_all_mask;\r\n}\r\nstatic unsigned long numaq_check_apicid_used(physid_mask_t *map, int apicid)\r\n{\r\nreturn physid_isset(apicid, *map);\r\n}\r\nstatic inline unsigned long numaq_check_apicid_present(int bit)\r\n{\r\nreturn physid_isset(bit, phys_cpu_present_map);\r\n}\r\nstatic inline int numaq_apic_id_registered(void)\r\n{\r\nreturn 1;\r\n}\r\nstatic inline void numaq_init_apic_ldr(void)\r\n{\r\n}\r\nstatic inline void numaq_setup_apic_routing(void)\r\n{\r\nprintk(KERN_INFO\r\n"Enabling APIC mode: NUMA-Q. Using %d I/O APICs\n",\r\nnr_ioapics);\r\n}\r\nstatic inline int numaq_multi_timer_check(int apic, int irq)\r\n{\r\nreturn apic != 0 && irq == 0;\r\n}\r\nstatic inline void numaq_ioapic_phys_id_map(physid_mask_t *phys_map, physid_mask_t *retmap)\r\n{\r\nreturn physids_promote(0xFUL, retmap);\r\n}\r\nstatic inline int numaq_cpu_present_to_apicid(int mps_cpu)\r\n{\r\nif (mps_cpu < 60)\r\nreturn ((mps_cpu >> 2) << 4) | (1 << (mps_cpu & 0x3));\r\nelse\r\nreturn BAD_APICID;\r\n}\r\nstatic inline int numaq_apicid_to_node(int logical_apicid)\r\n{\r\nreturn logical_apicid >> 4;\r\n}\r\nstatic int numaq_numa_cpu_node(int cpu)\r\n{\r\nint logical_apicid = early_per_cpu(x86_cpu_to_logical_apicid, cpu);\r\nif (logical_apicid != BAD_APICID)\r\nreturn numaq_apicid_to_node(logical_apicid);\r\nreturn NUMA_NO_NODE;\r\n}\r\nstatic void numaq_apicid_to_cpu_present(int logical_apicid, physid_mask_t *retmap)\r\n{\r\nint node = numaq_apicid_to_node(logical_apicid);\r\nint cpu = __ffs(logical_apicid & 0xf);\r\nphysid_set_mask_of_physid(cpu + 4*node, retmap);\r\n}\r\nstatic inline int numaq_check_phys_apicid_present(int phys_apicid)\r\n{\r\nreturn 1;\r\n}\r\nstatic int\r\nnumaq_cpu_mask_to_apicid_and(const struct cpumask *cpumask,\r\nconst struct cpumask *andmask,\r\nunsigned int *apicid)\r\n{\r\n*apicid = 0x0F;\r\nreturn 0;\r\n}\r\nstatic inline int numaq_phys_pkg_id(int cpuid_apic, int index_msb)\r\n{\r\nreturn cpuid_apic >> index_msb;\r\n}\r\nstatic int\r\nnumaq_mps_oem_check(struct mpc_table *mpc, char *oem, char *productid)\r\n{\r\nif (strncmp(oem, "IBM NUMA", 8))\r\nprintk(KERN_ERR "Warning! Not a NUMA-Q system!\n");\r\nelse\r\nfound_numaq = 1;\r\nreturn found_numaq;\r\n}\r\nstatic int probe_numaq(void)\r\n{\r\nreturn found_numaq;\r\n}\r\nstatic void numaq_setup_portio_remap(void)\r\n{\r\nint num_quads = num_online_nodes();\r\nif (num_quads <= 1)\r\nreturn;\r\nprintk(KERN_INFO\r\n"Remapping cross-quad port I/O for %d quads\n", num_quads);\r\nxquad_portio = ioremap(XQUAD_PORTIO_BASE, num_quads*XQUAD_PORTIO_QUAD);\r\nprintk(KERN_INFO\r\n"xquad_portio vaddr 0x%08lx, len %08lx\n",\r\n(u_long) xquad_portio, (u_long) num_quads*XQUAD_PORTIO_QUAD);\r\n}
