static int cadet_getstereo(struct cadet *dev)\r\n{\r\nint ret = V4L2_TUNER_SUB_MONO;\r\nif (!dev->is_fm_band)\r\nreturn V4L2_TUNER_SUB_MONO;\r\noutb(7, dev->io);\r\nif ((inb(dev->io + 1) & 0x40) == 0)\r\nret = V4L2_TUNER_SUB_STEREO;\r\nreturn ret;\r\n}\r\nstatic unsigned cadet_gettune(struct cadet *dev)\r\n{\r\nint curvol, i;\r\nunsigned fifo = 0;\r\noutb(7, dev->io);\r\ncurvol = inb(dev->io + 1);\r\noutb(0x00, dev->io + 1);\r\ndev->tunestat = 0xffff;\r\nfor (i = 0; i < 25; i++) {\r\nfifo = (fifo << 1) | ((inb(dev->io + 1) >> 7) & 0x01);\r\nif (i < 24) {\r\noutb(0x01, dev->io + 1);\r\ndev->tunestat &= inb(dev->io + 1);\r\noutb(0x00, dev->io + 1);\r\n}\r\n}\r\noutb(curvol, dev->io + 1);\r\nreturn fifo;\r\n}\r\nstatic unsigned cadet_getfreq(struct cadet *dev)\r\n{\r\nint i;\r\nunsigned freq = 0, test, fifo = 0;\r\nfifo = cadet_gettune(dev);\r\nif (!dev->is_fm_band)\r\nreturn ((fifo & 0x7fff) - 450) * 16;\r\ntest = 12500;\r\nfor (i = 0; i < 14; i++) {\r\nif ((fifo & 0x01) != 0)\r\nfreq += test;\r\ntest = test << 1;\r\nfifo = fifo >> 1;\r\n}\r\nfreq -= 10700000;\r\nfreq = (freq * 16) / 1000;\r\nreturn freq;\r\n}\r\nstatic void cadet_settune(struct cadet *dev, unsigned fifo)\r\n{\r\nint i;\r\nunsigned test;\r\noutb(7, dev->io);\r\ntest = 0;\r\ntest = (fifo >> 23) & 0x02;\r\ntest |= 0x1c;\r\noutb(7, dev->io);\r\noutb(test, dev->io + 1);\r\nfor (i = 0; i < 25; i++) {\r\ntest |= 0x01;\r\noutb(test, dev->io + 1);\r\ntest &= 0xfe;\r\noutb(test, dev->io + 1);\r\nfifo = fifo << 1;\r\ntest = 0x1c | ((fifo >> 23) & 0x02);\r\noutb(test, dev->io + 1);\r\n}\r\n}\r\nstatic void cadet_setfreq(struct cadet *dev, unsigned freq)\r\n{\r\nunsigned fifo;\r\nint i, j, test;\r\nint curvol;\r\nfreq = clamp(freq, bands[dev->is_fm_band].rangelow,\r\nbands[dev->is_fm_band].rangehigh);\r\ndev->curfreq = freq;\r\nfifo = 0;\r\nif (dev->is_fm_band) {\r\ntest = 102400;\r\nfreq = freq / 16;\r\nfreq += 10700;\r\nfor (i = 0; i < 14; i++) {\r\nfifo = fifo << 1;\r\nif (freq >= test) {\r\nfifo |= 0x01;\r\nfreq -= test;\r\n}\r\ntest = test >> 1;\r\n}\r\n} else {\r\nfifo = (freq / 16) + 450;\r\nfifo |= 0x100000;\r\n}\r\noutb(7, dev->io);\r\ncurvol = inb(dev->io + 1);\r\nfor (j = 3; j > -1; j--) {\r\ncadet_settune(dev, fifo | (j << 16));\r\noutb(7, dev->io);\r\noutb(curvol, dev->io + 1);\r\nmsleep(100);\r\ncadet_gettune(dev);\r\nif ((dev->tunestat & 0x40) == 0) {\r\ndev->sigstrength = sigtable[dev->is_fm_band][j];\r\ngoto reset_rds;\r\n}\r\n}\r\ndev->sigstrength = 0;\r\nreset_rds:\r\noutb(3, dev->io);\r\noutb(inb(dev->io + 1) & 0x7f, dev->io + 1);\r\n}\r\nstatic void cadet_handler(unsigned long data)\r\n{\r\nstruct cadet *dev = (void *)data;\r\nif (mutex_trylock(&dev->lock)) {\r\noutb(0x3, dev->io);\r\nif ((inb(dev->io + 1) & 0x20) != 0)\r\nprintk(KERN_CRIT "cadet: RDS fifo overflow\n");\r\noutb(0x80, dev->io);\r\nwhile ((inb(dev->io) & 0x80) != 0) {\r\ndev->rdsbuf[dev->rdsin] = inb(dev->io + 1);\r\nif (dev->rdsin + 1 == dev->rdsout)\r\nprintk(KERN_WARNING "cadet: RDS buffer overflow\n");\r\nelse\r\ndev->rdsin++;\r\n}\r\nmutex_unlock(&dev->lock);\r\n}\r\nif (dev->rdsin != dev->rdsout)\r\nwake_up_interruptible(&dev->read_queue);\r\ninit_timer(&dev->readtimer);\r\ndev->readtimer.function = cadet_handler;\r\ndev->readtimer.data = data;\r\ndev->readtimer.expires = jiffies + msecs_to_jiffies(50);\r\nadd_timer(&dev->readtimer);\r\n}\r\nstatic void cadet_start_rds(struct cadet *dev)\r\n{\r\ndev->rdsstat = 1;\r\noutb(0x80, dev->io);\r\ninit_timer(&dev->readtimer);\r\ndev->readtimer.function = cadet_handler;\r\ndev->readtimer.data = (unsigned long)dev;\r\ndev->readtimer.expires = jiffies + msecs_to_jiffies(50);\r\nadd_timer(&dev->readtimer);\r\n}\r\nstatic ssize_t cadet_read(struct file *file, char __user *data, size_t count, loff_t *ppos)\r\n{\r\nstruct cadet *dev = video_drvdata(file);\r\nunsigned char readbuf[RDS_BUFFER];\r\nint i = 0;\r\nmutex_lock(&dev->lock);\r\nif (dev->rdsstat == 0)\r\ncadet_start_rds(dev);\r\nif (dev->rdsin == dev->rdsout) {\r\nif (file->f_flags & O_NONBLOCK) {\r\ni = -EWOULDBLOCK;\r\ngoto unlock;\r\n}\r\nmutex_unlock(&dev->lock);\r\ninterruptible_sleep_on(&dev->read_queue);\r\nmutex_lock(&dev->lock);\r\n}\r\nwhile (i < count && dev->rdsin != dev->rdsout)\r\nreadbuf[i++] = dev->rdsbuf[dev->rdsout++];\r\nif (i && copy_to_user(data, readbuf, i))\r\ni = -EFAULT;\r\nunlock:\r\nmutex_unlock(&dev->lock);\r\nreturn i;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstrlcpy(v->driver, "ADS Cadet", sizeof(v->driver));\r\nstrlcpy(v->card, "ADS Cadet", sizeof(v->card));\r\nstrlcpy(v->bus_info, "ISA", sizeof(v->bus_info));\r\nv->device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO |\r\nV4L2_CAP_READWRITE | V4L2_CAP_RDS_CAPTURE;\r\nv->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nstruct cadet *dev = video_drvdata(file);\r\nif (v->index)\r\nreturn -EINVAL;\r\nv->type = V4L2_TUNER_RADIO;\r\nstrlcpy(v->name, "Radio", sizeof(v->name));\r\nv->capability = bands[0].capability | bands[1].capability;\r\nv->rangelow = bands[0].rangelow;\r\nv->rangehigh = bands[1].rangehigh;\r\nif (dev->is_fm_band) {\r\nv->rxsubchans = cadet_getstereo(dev);\r\noutb(3, dev->io);\r\noutb(inb(dev->io + 1) & 0x7f, dev->io + 1);\r\nmdelay(100);\r\noutb(3, dev->io);\r\nif (inb(dev->io + 1) & 0x80)\r\nv->rxsubchans |= V4L2_TUNER_SUB_RDS;\r\n} else {\r\nv->rangelow = 8320;\r\nv->rangehigh = 26400;\r\nv->rxsubchans = V4L2_TUNER_SUB_MONO;\r\n}\r\nv->audmode = V4L2_TUNER_MODE_STEREO;\r\nv->signal = dev->sigstrength;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *v)\r\n{\r\nreturn v->index ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_enum_freq_bands(struct file *file, void *priv,\r\nstruct v4l2_frequency_band *band)\r\n{\r\nif (band->tuner)\r\nreturn -EINVAL;\r\nif (band->index >= ARRAY_SIZE(bands))\r\nreturn -EINVAL;\r\n*band = bands[band->index];\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct cadet *dev = video_drvdata(file);\r\nif (f->tuner)\r\nreturn -EINVAL;\r\nf->type = V4L2_TUNER_RADIO;\r\nf->frequency = dev->curfreq;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct cadet *dev = video_drvdata(file);\r\nif (f->tuner)\r\nreturn -EINVAL;\r\ndev->is_fm_band =\r\nf->frequency >= (bands[0].rangehigh + bands[1].rangelow) / 2;\r\ncadet_setfreq(dev, f->frequency);\r\nreturn 0;\r\n}\r\nstatic int cadet_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct cadet *dev = container_of(ctrl->handler, struct cadet, ctrl_handler);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\noutb(7, dev->io);\r\nif (ctrl->val)\r\noutb(0x00, dev->io + 1);\r\nelse\r\noutb(0x20, dev->io + 1);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cadet_open(struct file *file)\r\n{\r\nstruct cadet *dev = video_drvdata(file);\r\nint err;\r\nmutex_lock(&dev->lock);\r\nerr = v4l2_fh_open(file);\r\nif (err)\r\ngoto fail;\r\nif (v4l2_fh_is_singular_file(file))\r\ninit_waitqueue_head(&dev->read_queue);\r\nfail:\r\nmutex_unlock(&dev->lock);\r\nreturn err;\r\n}\r\nstatic int cadet_release(struct file *file)\r\n{\r\nstruct cadet *dev = video_drvdata(file);\r\nmutex_lock(&dev->lock);\r\nif (v4l2_fh_is_singular_file(file) && dev->rdsstat) {\r\ndel_timer_sync(&dev->readtimer);\r\ndev->rdsstat = 0;\r\n}\r\nv4l2_fh_release(file);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic unsigned int cadet_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nstruct cadet *dev = video_drvdata(file);\r\nunsigned long req_events = poll_requested_events(wait);\r\nunsigned int res = v4l2_ctrl_poll(file, wait);\r\npoll_wait(file, &dev->read_queue, wait);\r\nif (dev->rdsstat == 0 && (req_events & (POLLIN | POLLRDNORM))) {\r\nmutex_lock(&dev->lock);\r\nif (dev->rdsstat == 0)\r\ncadet_start_rds(dev);\r\nmutex_unlock(&dev->lock);\r\n}\r\nif (dev->rdsin != dev->rdsout)\r\nres |= POLLIN | POLLRDNORM;\r\nreturn res;\r\n}\r\nstatic int cadet_pnp_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)\r\n{\r\nif (!dev)\r\nreturn -ENODEV;\r\nif (io > 0)\r\nreturn -EBUSY;\r\nif (!pnp_port_valid(dev, 0))\r\nreturn -ENODEV;\r\nio = pnp_port_start(dev, 0);\r\nprintk(KERN_INFO "radio-cadet: PnP reports device at %#x\n", io);\r\nreturn io;\r\n}\r\nstatic void cadet_probe(struct cadet *dev)\r\n{\r\nstatic int iovals[8] = { 0x330, 0x332, 0x334, 0x336, 0x338, 0x33a, 0x33c, 0x33e };\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\ndev->io = iovals[i];\r\nif (request_region(dev->io, 2, "cadet-probe")) {\r\ncadet_setfreq(dev, bands[1].rangelow);\r\nif (cadet_getfreq(dev) == bands[1].rangelow) {\r\nrelease_region(dev->io, 2);\r\nreturn;\r\n}\r\nrelease_region(dev->io, 2);\r\n}\r\n}\r\ndev->io = -1;\r\n}\r\nstatic int __init cadet_init(void)\r\n{\r\nstruct cadet *dev = &cadet_card;\r\nstruct v4l2_device *v4l2_dev = &dev->v4l2_dev;\r\nstruct v4l2_ctrl_handler *hdl;\r\nint res = -ENODEV;\r\nstrlcpy(v4l2_dev->name, "cadet", sizeof(v4l2_dev->name));\r\nmutex_init(&dev->lock);\r\nif (io < 0)\r\npnp_register_driver(&cadet_pnp_driver);\r\ndev->io = io;\r\nif (dev->io < 0)\r\ncadet_probe(dev);\r\nif (dev->io < 0) {\r\n#ifdef MODULE\r\nv4l2_err(v4l2_dev, "you must set an I/O address with io=0x330, 0x332, 0x334,\n");\r\nv4l2_err(v4l2_dev, "0x336, 0x338, 0x33a, 0x33c or 0x33e\n");\r\n#endif\r\ngoto fail;\r\n}\r\nif (!request_region(dev->io, 2, "cadet"))\r\ngoto fail;\r\nres = v4l2_device_register(NULL, v4l2_dev);\r\nif (res < 0) {\r\nrelease_region(dev->io, 2);\r\nv4l2_err(v4l2_dev, "could not register v4l2_device\n");\r\ngoto fail;\r\n}\r\nhdl = &dev->ctrl_handler;\r\nv4l2_ctrl_handler_init(hdl, 2);\r\nv4l2_ctrl_new_std(hdl, &cadet_ctrl_ops,\r\nV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\r\nv4l2_dev->ctrl_handler = hdl;\r\nif (hdl->error) {\r\nres = hdl->error;\r\nv4l2_err(v4l2_dev, "Could not register controls\n");\r\ngoto err_hdl;\r\n}\r\ndev->is_fm_band = true;\r\ndev->curfreq = bands[dev->is_fm_band].rangelow;\r\ncadet_setfreq(dev, dev->curfreq);\r\nstrlcpy(dev->vdev.name, v4l2_dev->name, sizeof(dev->vdev.name));\r\ndev->vdev.v4l2_dev = v4l2_dev;\r\ndev->vdev.fops = &cadet_fops;\r\ndev->vdev.ioctl_ops = &cadet_ioctl_ops;\r\ndev->vdev.release = video_device_release_empty;\r\ndev->vdev.lock = &dev->lock;\r\nset_bit(V4L2_FL_USE_FH_PRIO, &dev->vdev.flags);\r\nvideo_set_drvdata(&dev->vdev, dev);\r\nres = video_register_device(&dev->vdev, VFL_TYPE_RADIO, radio_nr);\r\nif (res < 0)\r\ngoto err_hdl;\r\nv4l2_info(v4l2_dev, "ADS Cadet Radio Card at 0x%x\n", dev->io);\r\nreturn 0;\r\nerr_hdl:\r\nv4l2_ctrl_handler_free(hdl);\r\nv4l2_device_unregister(v4l2_dev);\r\nrelease_region(dev->io, 2);\r\nfail:\r\npnp_unregister_driver(&cadet_pnp_driver);\r\nreturn res;\r\n}\r\nstatic void __exit cadet_exit(void)\r\n{\r\nstruct cadet *dev = &cadet_card;\r\nvideo_unregister_device(&dev->vdev);\r\nv4l2_ctrl_handler_free(&dev->ctrl_handler);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\noutb(7, dev->io);\r\noutb(0x00, dev->io + 1);\r\nrelease_region(dev->io, 2);\r\npnp_unregister_driver(&cadet_pnp_driver);\r\n}
