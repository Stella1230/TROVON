static int lp8788_led_init_device(struct lp8788_led *led,\r\nstruct lp8788_led_platform_data *pdata)\r\n{\r\nstruct lp8788_led_config *cfg = &default_led_config;\r\nu8 addr, mask, val;\r\nint ret;\r\nif (pdata) {\r\ncfg->scale = pdata->scale;\r\ncfg->num = pdata->num;\r\ncfg->iout = pdata->iout_code;\r\n}\r\nled->isink_num = cfg->num;\r\naddr = LP8788_ISINK_CTRL;\r\nmask = 1 << (cfg->num + LP8788_ISINK_SCALE_OFFSET);\r\nval = cfg->scale << (cfg->num + LP8788_ISINK_SCALE_OFFSET);\r\nret = lp8788_update_bits(led->lp, addr, mask, val);\r\nif (ret)\r\nreturn ret;\r\naddr = lp8788_iout_addr[cfg->num];\r\nmask = lp8788_iout_mask[cfg->num];\r\nval = cfg->iout;\r\nreturn lp8788_update_bits(led->lp, addr, mask, val);\r\n}\r\nstatic void lp8788_led_enable(struct lp8788_led *led,\r\nenum lp8788_isink_number num, int on)\r\n{\r\nu8 mask = 1 << num;\r\nu8 val = on << num;\r\nif (lp8788_update_bits(led->lp, LP8788_ISINK_CTRL, mask, val))\r\nreturn;\r\nled->on = on;\r\n}\r\nstatic void lp8788_led_work(struct work_struct *work)\r\n{\r\nstruct lp8788_led *led = container_of(work, struct lp8788_led, work);\r\nenum lp8788_isink_number num = led->isink_num;\r\nint enable;\r\nu8 val = led->brightness;\r\nmutex_lock(&led->lock);\r\nswitch (num) {\r\ncase LP8788_ISINK_1:\r\ncase LP8788_ISINK_2:\r\ncase LP8788_ISINK_3:\r\nlp8788_write_byte(led->lp, lp8788_pwm_addr[num], val);\r\nbreak;\r\ndefault:\r\nmutex_unlock(&led->lock);\r\nreturn;\r\n}\r\nenable = (val > 0) ? 1 : 0;\r\nif (enable != led->on)\r\nlp8788_led_enable(led, num, enable);\r\nmutex_unlock(&led->lock);\r\n}\r\nstatic void lp8788_brightness_set(struct led_classdev *led_cdev,\r\nenum led_brightness brt_val)\r\n{\r\nstruct lp8788_led *led =\r\ncontainer_of(led_cdev, struct lp8788_led, led_dev);\r\nled->brightness = brt_val;\r\nschedule_work(&led->work);\r\n}\r\nstatic int lp8788_led_probe(struct platform_device *pdev)\r\n{\r\nstruct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);\r\nstruct lp8788_led_platform_data *led_pdata;\r\nstruct lp8788_led *led;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\nled = devm_kzalloc(dev, sizeof(struct lp8788_led), GFP_KERNEL);\r\nif (!led)\r\nreturn -ENOMEM;\r\nled->lp = lp;\r\nled->led_dev.max_brightness = MAX_BRIGHTNESS;\r\nled->led_dev.brightness_set = lp8788_brightness_set;\r\nled_pdata = lp->pdata ? lp->pdata->led_pdata : NULL;\r\nif (!led_pdata || !led_pdata->name)\r\nled->led_dev.name = DEFAULT_LED_NAME;\r\nelse\r\nled->led_dev.name = led_pdata->name;\r\nmutex_init(&led->lock);\r\nINIT_WORK(&led->work, lp8788_led_work);\r\nplatform_set_drvdata(pdev, led);\r\nret = lp8788_led_init_device(led, led_pdata);\r\nif (ret) {\r\ndev_err(dev, "led init device err: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = led_classdev_register(dev, &led->led_dev);\r\nif (ret) {\r\ndev_err(dev, "led register err: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lp8788_led_remove(struct platform_device *pdev)\r\n{\r\nstruct lp8788_led *led = platform_get_drvdata(pdev);\r\nled_classdev_unregister(&led->led_dev);\r\nflush_work(&led->work);\r\nreturn 0;\r\n}
