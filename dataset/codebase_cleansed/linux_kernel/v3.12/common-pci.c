static void crp_read(u32 ad_cbe, u32 *data)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&ixp4xx_pci_lock, flags);\r\n*PCI_CRP_AD_CBE = ad_cbe;\r\n*data = *PCI_CRP_RDATA;\r\nraw_spin_unlock_irqrestore(&ixp4xx_pci_lock, flags);\r\n}\r\nstatic void crp_write(u32 ad_cbe, u32 data)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&ixp4xx_pci_lock, flags);\r\n*PCI_CRP_AD_CBE = CRP_AD_CBE_WRITE | ad_cbe;\r\n*PCI_CRP_WDATA = data;\r\nraw_spin_unlock_irqrestore(&ixp4xx_pci_lock, flags);\r\n}\r\nstatic inline int check_master_abort(void)\r\n{\r\nunsigned long isr = *PCI_ISR;\r\nif (isr & PCI_ISR_PFE) {\r\n*PCI_ISR = PCI_ISR_PFE;\r\npr_debug("%s failed\n", __func__);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint ixp4xx_pci_read_errata(u32 addr, u32 cmd, u32* data)\r\n{\r\nunsigned long flags;\r\nint retval = 0;\r\nint i;\r\nraw_spin_lock_irqsave(&ixp4xx_pci_lock, flags);\r\n*PCI_NP_AD = addr;\r\nfor (i = 0; i < 8; i++) {\r\n*PCI_NP_CBE = cmd;\r\n*data = *PCI_NP_RDATA;\r\n*data = *PCI_NP_RDATA;\r\n}\r\nif(check_master_abort())\r\nretval = 1;\r\nraw_spin_unlock_irqrestore(&ixp4xx_pci_lock, flags);\r\nreturn retval;\r\n}\r\nint ixp4xx_pci_read_no_errata(u32 addr, u32 cmd, u32* data)\r\n{\r\nunsigned long flags;\r\nint retval = 0;\r\nraw_spin_lock_irqsave(&ixp4xx_pci_lock, flags);\r\n*PCI_NP_AD = addr;\r\n*PCI_NP_CBE = cmd;\r\n*data = *PCI_NP_RDATA;\r\nif(check_master_abort())\r\nretval = 1;\r\nraw_spin_unlock_irqrestore(&ixp4xx_pci_lock, flags);\r\nreturn retval;\r\n}\r\nint ixp4xx_pci_write(u32 addr, u32 cmd, u32 data)\r\n{\r\nunsigned long flags;\r\nint retval = 0;\r\nraw_spin_lock_irqsave(&ixp4xx_pci_lock, flags);\r\n*PCI_NP_AD = addr;\r\n*PCI_NP_CBE = cmd;\r\n*PCI_NP_WDATA = data;\r\nif(check_master_abort())\r\nretval = 1;\r\nraw_spin_unlock_irqrestore(&ixp4xx_pci_lock, flags);\r\nreturn retval;\r\n}\r\nstatic u32 ixp4xx_config_addr(u8 bus_num, u16 devfn, int where)\r\n{\r\nu32 addr;\r\nif (!bus_num) {\r\naddr = BIT(32-PCI_SLOT(devfn)) | ((PCI_FUNC(devfn)) << 8) |\r\n(where & ~3);\r\n} else {\r\naddr = (bus_num << 16) | ((PCI_SLOT(devfn)) << 11) |\r\n((PCI_FUNC(devfn)) << 8) | (where & ~3) | 1;\r\n}\r\nreturn addr;\r\n}\r\nstatic u32 local_byte_lane_enable_bits(u32 n, int size)\r\n{\r\nif (size == 1)\r\nreturn (0xf & ~BIT(n)) << CRP_AD_CBE_BESL;\r\nif (size == 2)\r\nreturn (0xf & ~(BIT(n) | BIT(n+1))) << CRP_AD_CBE_BESL;\r\nif (size == 4)\r\nreturn 0;\r\nreturn 0xffffffff;\r\n}\r\nstatic int local_read_config(int where, int size, u32 *value)\r\n{\r\nu32 n, data;\r\npr_debug("local_read_config from %d size %d\n", where, size);\r\nn = where % 4;\r\ncrp_read(where & ~3, &data);\r\n*value = (data >> (8*n)) & bytemask[size];\r\npr_debug("local_read_config read %#x\n", *value);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int local_write_config(int where, int size, u32 value)\r\n{\r\nu32 n, byte_enables, data;\r\npr_debug("local_write_config %#x to %d size %d\n", value, where, size);\r\nn = where % 4;\r\nbyte_enables = local_byte_lane_enable_bits(n, size);\r\nif (byte_enables == 0xffffffff)\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\ndata = value << (8*n);\r\ncrp_write((where & ~3) | byte_enables, data);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic u32 byte_lane_enable_bits(u32 n, int size)\r\n{\r\nif (size == 1)\r\nreturn (0xf & ~BIT(n)) << 4;\r\nif (size == 2)\r\nreturn (0xf & ~(BIT(n) | BIT(n+1))) << 4;\r\nif (size == 4)\r\nreturn 0;\r\nreturn 0xffffffff;\r\n}\r\nstatic int ixp4xx_pci_read_config(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 *value)\r\n{\r\nu32 n, byte_enables, addr, data;\r\nu8 bus_num = bus->number;\r\npr_debug("read_config from %d size %d dev %d:%d:%d\n", where, size,\r\nbus_num, PCI_SLOT(devfn), PCI_FUNC(devfn));\r\n*value = 0xffffffff;\r\nn = where % 4;\r\nbyte_enables = byte_lane_enable_bits(n, size);\r\nif (byte_enables == 0xffffffff)\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\naddr = ixp4xx_config_addr(bus_num, devfn, where);\r\nif (ixp4xx_pci_read(addr, byte_enables | NP_CMD_CONFIGREAD, &data))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n*value = (data >> (8*n)) & bytemask[size];\r\npr_debug("read_config_byte read %#x\n", *value);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int ixp4xx_pci_write_config(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 value)\r\n{\r\nu32 n, byte_enables, addr, data;\r\nu8 bus_num = bus->number;\r\npr_debug("write_config_byte %#x to %d size %d dev %d:%d:%d\n", value, where,\r\nsize, bus_num, PCI_SLOT(devfn), PCI_FUNC(devfn));\r\nn = where % 4;\r\nbyte_enables = byte_lane_enable_bits(n, size);\r\nif (byte_enables == 0xffffffff)\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\naddr = ixp4xx_config_addr(bus_num, devfn, where);\r\ndata = value << (8*n);\r\nif (ixp4xx_pci_write(addr, byte_enables | NP_CMD_CONFIGWRITE, data))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int abort_handler(unsigned long addr, unsigned int fsr, struct pt_regs *regs)\r\n{\r\nu32 isr, status;\r\nisr = *PCI_ISR;\r\nlocal_read_config(PCI_STATUS, 2, &status);\r\npr_debug("PCI: abort_handler addr = %#lx, isr = %#x, "\r\n"status = %#x\n", addr, isr, status);\r\n*PCI_ISR = PCI_ISR_PFE;\r\nstatus |= PCI_STATUS_REC_MASTER_ABORT;\r\nlocal_write_config(PCI_STATUS, 2, status);\r\nif (fsr & (1 << 10))\r\nregs->ARM_pc += 4;\r\nreturn 0;\r\n}\r\nstatic int ixp4xx_needs_bounce(struct device *dev, dma_addr_t dma_addr, size_t size)\r\n{\r\nreturn (dma_addr + size) >= SZ_64M;\r\n}\r\nstatic int ixp4xx_pci_platform_notify(struct device *dev)\r\n{\r\nif(dev->bus == &pci_bus_type) {\r\n*dev->dma_mask = SZ_64M - 1;\r\ndev->coherent_dma_mask = SZ_64M - 1;\r\ndmabounce_register_dev(dev, 2048, 4096, ixp4xx_needs_bounce);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ixp4xx_pci_platform_notify_remove(struct device *dev)\r\n{\r\nif(dev->bus == &pci_bus_type) {\r\ndmabounce_unregister_dev(dev);\r\n}\r\nreturn 0;\r\n}\r\nvoid __init ixp4xx_pci_preinit(void)\r\n{\r\nunsigned long cpuid = read_cpuid_id();\r\n#ifdef CONFIG_IXP4XX_INDIRECT_PCI\r\npcibios_min_mem = 0x10000000;\r\n#else\r\npcibios_min_mem = 0x48000000;\r\n#endif\r\nif (!(cpuid & 0xf) && cpu_is_ixp42x()) {\r\nprintk("PCI: IXP42x A0 silicon detected - "\r\n"PCI Non-Prefetch Workaround Enabled\n");\r\nixp4xx_pci_read = ixp4xx_pci_read_errata;\r\n} else\r\nixp4xx_pci_read = ixp4xx_pci_read_no_errata;\r\nhook_fault_code(16+6, abort_handler, SIGBUS, 0,\r\n"imprecise external abort");\r\npr_debug("setup PCI-AHB(inbound) and AHB-PCI(outbound) address mappings\n");\r\n*PCI_PCIMEMBASE = 0x48494A4B;\r\n*PCI_AHBMEMBASE = (PHYS_OFFSET & 0xFF000000) +\r\n((PHYS_OFFSET & 0xFF000000) >> 8) +\r\n((PHYS_OFFSET & 0xFF000000) >> 16) +\r\n((PHYS_OFFSET & 0xFF000000) >> 24) +\r\n0x00010203;\r\nif (*PCI_CSR & PCI_CSR_HOST) {\r\nprintk("PCI: IXP4xx is host\n");\r\npr_debug("setup BARs in controller\n");\r\nlocal_write_config(PCI_BASE_ADDRESS_0, 4, PHYS_OFFSET);\r\nlocal_write_config(PCI_BASE_ADDRESS_1, 4, PHYS_OFFSET + SZ_16M);\r\nlocal_write_config(PCI_BASE_ADDRESS_2, 4, PHYS_OFFSET + SZ_32M);\r\nlocal_write_config(PCI_BASE_ADDRESS_3, 4,\r\nPHYS_OFFSET + SZ_32M + SZ_16M);\r\nlocal_write_config(PCI_BASE_ADDRESS_4, 4, PHYS_OFFSET + SZ_64M);\r\nlocal_write_config(PCI_BASE_ADDRESS_5, 4, 0xfffffc01);\r\nlocal_write_config(0x40, 4, 0x000080FF);\r\n} else {\r\nprintk("PCI: IXP4xx is target - No bus scan performed\n");\r\n}\r\nprintk("PCI: IXP4xx Using %s access for memory space\n",\r\n#ifndef CONFIG_IXP4XX_INDIRECT_PCI\r\n"direct"\r\n#else\r\n"indirect"\r\n#endif\r\n);\r\npr_debug("clear error bits in ISR\n");\r\n*PCI_ISR = PCI_ISR_PSE | PCI_ISR_PFE | PCI_ISR_PPE | PCI_ISR_AHBE;\r\n#ifdef __ARMEB__\r\n*PCI_CSR = PCI_CSR_IC | PCI_CSR_ABE | PCI_CSR_PDS | PCI_CSR_ADS;\r\n#else\r\n*PCI_CSR = PCI_CSR_IC | PCI_CSR_ABE;\r\n#endif\r\npr_debug("DONE\n");\r\n}\r\nint ixp4xx_setup(int nr, struct pci_sys_data *sys)\r\n{\r\nstruct resource *res;\r\nif (nr >= 1)\r\nreturn 0;\r\nres = kzalloc(sizeof(*res) * 2, GFP_KERNEL);\r\nif (res == NULL) {\r\npanic("PCI: unable to allocate resources?\n");\r\n}\r\nlocal_write_config(PCI_COMMAND, 2, PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY);\r\nres[0].name = "PCI I/O Space";\r\nres[0].start = 0x00000000;\r\nres[0].end = 0x0000ffff;\r\nres[0].flags = IORESOURCE_IO;\r\nres[1].name = "PCI Memory Space";\r\nres[1].start = PCIBIOS_MIN_MEM;\r\nres[1].end = PCIBIOS_MAX_MEM;\r\nres[1].flags = IORESOURCE_MEM;\r\nrequest_resource(&ioport_resource, &res[0]);\r\nrequest_resource(&iomem_resource, &res[1]);\r\npci_add_resource_offset(&sys->resources, &res[0], sys->io_offset);\r\npci_add_resource_offset(&sys->resources, &res[1], sys->mem_offset);\r\nplatform_notify = ixp4xx_pci_platform_notify;\r\nplatform_notify_remove = ixp4xx_pci_platform_notify_remove;\r\nreturn 1;\r\n}\r\nint dma_set_coherent_mask(struct device *dev, u64 mask)\r\n{\r\nif (mask >= SZ_64M - 1)\r\nreturn 0;\r\nreturn -EIO;\r\n}
