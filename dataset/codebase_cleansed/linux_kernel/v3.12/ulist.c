void ulist_init(struct ulist *ulist)\r\n{\r\nulist->nnodes = 0;\r\nulist->nodes = ulist->int_nodes;\r\nulist->nodes_alloced = ULIST_SIZE;\r\nulist->root = RB_ROOT;\r\n}\r\nvoid ulist_fini(struct ulist *ulist)\r\n{\r\nif (ulist->nodes_alloced > ULIST_SIZE)\r\nkfree(ulist->nodes);\r\nulist->nodes_alloced = 0;\r\nulist->root = RB_ROOT;\r\n}\r\nvoid ulist_reinit(struct ulist *ulist)\r\n{\r\nulist_fini(ulist);\r\nulist_init(ulist);\r\n}\r\nstruct ulist *ulist_alloc(gfp_t gfp_mask)\r\n{\r\nstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\r\nif (!ulist)\r\nreturn NULL;\r\nulist_init(ulist);\r\nreturn ulist;\r\n}\r\nvoid ulist_free(struct ulist *ulist)\r\n{\r\nif (!ulist)\r\nreturn;\r\nulist_fini(ulist);\r\nkfree(ulist);\r\n}\r\nstatic struct ulist_node *ulist_rbtree_search(struct ulist *ulist, u64 val)\r\n{\r\nstruct rb_node *n = ulist->root.rb_node;\r\nstruct ulist_node *u = NULL;\r\nwhile (n) {\r\nu = rb_entry(n, struct ulist_node, rb_node);\r\nif (u->val < val)\r\nn = n->rb_right;\r\nelse if (u->val > val)\r\nn = n->rb_left;\r\nelse\r\nreturn u;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int ulist_rbtree_insert(struct ulist *ulist, struct ulist_node *ins)\r\n{\r\nstruct rb_node **p = &ulist->root.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct ulist_node *cur = NULL;\r\nwhile (*p) {\r\nparent = *p;\r\ncur = rb_entry(parent, struct ulist_node, rb_node);\r\nif (cur->val < ins->val)\r\np = &(*p)->rb_right;\r\nelse if (cur->val > ins->val)\r\np = &(*p)->rb_left;\r\nelse\r\nreturn -EEXIST;\r\n}\r\nrb_link_node(&ins->rb_node, parent, p);\r\nrb_insert_color(&ins->rb_node, &ulist->root);\r\nreturn 0;\r\n}\r\nint ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask)\r\n{\r\nreturn ulist_add_merge(ulist, val, aux, NULL, gfp_mask);\r\n}\r\nint ulist_add_merge(struct ulist *ulist, u64 val, u64 aux,\r\nu64 *old_aux, gfp_t gfp_mask)\r\n{\r\nint ret = 0;\r\nstruct ulist_node *node = NULL;\r\nnode = ulist_rbtree_search(ulist, val);\r\nif (node) {\r\nif (old_aux)\r\n*old_aux = node->aux;\r\nreturn 0;\r\n}\r\nif (ulist->nnodes >= ulist->nodes_alloced) {\r\nu64 new_alloced = ulist->nodes_alloced + 128;\r\nstruct ulist_node *new_nodes;\r\nvoid *old = NULL;\r\nint i;\r\nfor (i = 0; i < ulist->nnodes; i++)\r\nrb_erase(&ulist->nodes[i].rb_node, &ulist->root);\r\nif (ulist->nodes_alloced > ULIST_SIZE)\r\nold = ulist->nodes;\r\nnew_nodes = krealloc(old, sizeof(*new_nodes) * new_alloced,\r\ngfp_mask);\r\nif (!new_nodes)\r\nreturn -ENOMEM;\r\nif (!old)\r\nmemcpy(new_nodes, ulist->int_nodes,\r\nsizeof(ulist->int_nodes));\r\nulist->nodes = new_nodes;\r\nulist->nodes_alloced = new_alloced;\r\nfor (i = 0; i < ulist->nnodes; i++) {\r\nret = ulist_rbtree_insert(ulist, &ulist->nodes[i]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nulist->nodes[ulist->nnodes].val = val;\r\nulist->nodes[ulist->nnodes].aux = aux;\r\nret = ulist_rbtree_insert(ulist, &ulist->nodes[ulist->nnodes]);\r\nBUG_ON(ret);\r\n++ulist->nnodes;\r\nreturn 1;\r\n}\r\nstruct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\r\n{\r\nif (ulist->nnodes == 0)\r\nreturn NULL;\r\nif (uiter->i < 0 || uiter->i >= ulist->nnodes)\r\nreturn NULL;\r\nreturn &ulist->nodes[uiter->i++];\r\n}
