void __nand_calculate_ecc(const unsigned char *buf, unsigned int eccsize,\r\nunsigned char *code)\r\n{\r\nint i;\r\nconst uint32_t *bp = (uint32_t *)buf;\r\nconst uint32_t eccsize_mult = eccsize >> 8;\r\nuint32_t cur;\r\nuint32_t rp0, rp1, rp2, rp3, rp4, rp5, rp6, rp7;\r\nuint32_t rp8, rp9, rp10, rp11, rp12, rp13, rp14, rp15, rp16;\r\nuint32_t uninitialized_var(rp17);\r\nuint32_t par;\r\nuint32_t tmppar;\r\npar = 0;\r\nrp4 = 0;\r\nrp6 = 0;\r\nrp8 = 0;\r\nrp10 = 0;\r\nrp12 = 0;\r\nrp14 = 0;\r\nrp16 = 0;\r\nfor (i = 0; i < eccsize_mult << 2; i++) {\r\ncur = *bp++;\r\ntmppar = cur;\r\nrp4 ^= cur;\r\ncur = *bp++;\r\ntmppar ^= cur;\r\nrp6 ^= tmppar;\r\ncur = *bp++;\r\ntmppar ^= cur;\r\nrp4 ^= cur;\r\ncur = *bp++;\r\ntmppar ^= cur;\r\nrp8 ^= tmppar;\r\ncur = *bp++;\r\ntmppar ^= cur;\r\nrp4 ^= cur;\r\nrp6 ^= cur;\r\ncur = *bp++;\r\ntmppar ^= cur;\r\nrp6 ^= cur;\r\ncur = *bp++;\r\ntmppar ^= cur;\r\nrp4 ^= cur;\r\ncur = *bp++;\r\ntmppar ^= cur;\r\nrp10 ^= tmppar;\r\ncur = *bp++;\r\ntmppar ^= cur;\r\nrp4 ^= cur;\r\nrp6 ^= cur;\r\nrp8 ^= cur;\r\ncur = *bp++;\r\ntmppar ^= cur;\r\nrp6 ^= cur;\r\nrp8 ^= cur;\r\ncur = *bp++;\r\ntmppar ^= cur;\r\nrp4 ^= cur;\r\nrp8 ^= cur;\r\ncur = *bp++;\r\ntmppar ^= cur;\r\nrp8 ^= cur;\r\ncur = *bp++;\r\ntmppar ^= cur;\r\nrp4 ^= cur;\r\nrp6 ^= cur;\r\ncur = *bp++;\r\ntmppar ^= cur;\r\nrp6 ^= cur;\r\ncur = *bp++;\r\ntmppar ^= cur;\r\nrp4 ^= cur;\r\ncur = *bp++;\r\ntmppar ^= cur;\r\npar ^= tmppar;\r\nif ((i & 0x1) == 0)\r\nrp12 ^= tmppar;\r\nif ((i & 0x2) == 0)\r\nrp14 ^= tmppar;\r\nif (eccsize_mult == 2 && (i & 0x4) == 0)\r\nrp16 ^= tmppar;\r\n}\r\nrp4 ^= (rp4 >> 16);\r\nrp4 ^= (rp4 >> 8);\r\nrp4 &= 0xff;\r\nrp6 ^= (rp6 >> 16);\r\nrp6 ^= (rp6 >> 8);\r\nrp6 &= 0xff;\r\nrp8 ^= (rp8 >> 16);\r\nrp8 ^= (rp8 >> 8);\r\nrp8 &= 0xff;\r\nrp10 ^= (rp10 >> 16);\r\nrp10 ^= (rp10 >> 8);\r\nrp10 &= 0xff;\r\nrp12 ^= (rp12 >> 16);\r\nrp12 ^= (rp12 >> 8);\r\nrp12 &= 0xff;\r\nrp14 ^= (rp14 >> 16);\r\nrp14 ^= (rp14 >> 8);\r\nrp14 &= 0xff;\r\nif (eccsize_mult == 2) {\r\nrp16 ^= (rp16 >> 16);\r\nrp16 ^= (rp16 >> 8);\r\nrp16 &= 0xff;\r\n}\r\n#ifdef __BIG_ENDIAN\r\nrp2 = (par >> 16);\r\nrp2 ^= (rp2 >> 8);\r\nrp2 &= 0xff;\r\nrp3 = par & 0xffff;\r\nrp3 ^= (rp3 >> 8);\r\nrp3 &= 0xff;\r\n#else\r\nrp3 = (par >> 16);\r\nrp3 ^= (rp3 >> 8);\r\nrp3 &= 0xff;\r\nrp2 = par & 0xffff;\r\nrp2 ^= (rp2 >> 8);\r\nrp2 &= 0xff;\r\n#endif\r\npar ^= (par >> 16);\r\n#ifdef __BIG_ENDIAN\r\nrp0 = (par >> 8) & 0xff;\r\nrp1 = (par & 0xff);\r\n#else\r\nrp1 = (par >> 8) & 0xff;\r\nrp0 = (par & 0xff);\r\n#endif\r\npar ^= (par >> 8);\r\npar &= 0xff;\r\nrp5 = (par ^ rp4) & 0xff;\r\nrp7 = (par ^ rp6) & 0xff;\r\nrp9 = (par ^ rp8) & 0xff;\r\nrp11 = (par ^ rp10) & 0xff;\r\nrp13 = (par ^ rp12) & 0xff;\r\nrp15 = (par ^ rp14) & 0xff;\r\nif (eccsize_mult == 2)\r\nrp17 = (par ^ rp16) & 0xff;\r\n#ifdef CONFIG_MTD_NAND_ECC_SMC\r\ncode[0] =\r\n(invparity[rp7] << 7) |\r\n(invparity[rp6] << 6) |\r\n(invparity[rp5] << 5) |\r\n(invparity[rp4] << 4) |\r\n(invparity[rp3] << 3) |\r\n(invparity[rp2] << 2) |\r\n(invparity[rp1] << 1) |\r\n(invparity[rp0]);\r\ncode[1] =\r\n(invparity[rp15] << 7) |\r\n(invparity[rp14] << 6) |\r\n(invparity[rp13] << 5) |\r\n(invparity[rp12] << 4) |\r\n(invparity[rp11] << 3) |\r\n(invparity[rp10] << 2) |\r\n(invparity[rp9] << 1) |\r\n(invparity[rp8]);\r\n#else\r\ncode[1] =\r\n(invparity[rp7] << 7) |\r\n(invparity[rp6] << 6) |\r\n(invparity[rp5] << 5) |\r\n(invparity[rp4] << 4) |\r\n(invparity[rp3] << 3) |\r\n(invparity[rp2] << 2) |\r\n(invparity[rp1] << 1) |\r\n(invparity[rp0]);\r\ncode[0] =\r\n(invparity[rp15] << 7) |\r\n(invparity[rp14] << 6) |\r\n(invparity[rp13] << 5) |\r\n(invparity[rp12] << 4) |\r\n(invparity[rp11] << 3) |\r\n(invparity[rp10] << 2) |\r\n(invparity[rp9] << 1) |\r\n(invparity[rp8]);\r\n#endif\r\nif (eccsize_mult == 1)\r\ncode[2] =\r\n(invparity[par & 0xf0] << 7) |\r\n(invparity[par & 0x0f] << 6) |\r\n(invparity[par & 0xcc] << 5) |\r\n(invparity[par & 0x33] << 4) |\r\n(invparity[par & 0xaa] << 3) |\r\n(invparity[par & 0x55] << 2) |\r\n3;\r\nelse\r\ncode[2] =\r\n(invparity[par & 0xf0] << 7) |\r\n(invparity[par & 0x0f] << 6) |\r\n(invparity[par & 0xcc] << 5) |\r\n(invparity[par & 0x33] << 4) |\r\n(invparity[par & 0xaa] << 3) |\r\n(invparity[par & 0x55] << 2) |\r\n(invparity[rp17] << 1) |\r\n(invparity[rp16] << 0);\r\n}\r\nint nand_calculate_ecc(struct mtd_info *mtd, const unsigned char *buf,\r\nunsigned char *code)\r\n{\r\n__nand_calculate_ecc(buf,\r\n((struct nand_chip *)mtd->priv)->ecc.size, code);\r\nreturn 0;\r\n}\r\nint __nand_correct_data(unsigned char *buf,\r\nunsigned char *read_ecc, unsigned char *calc_ecc,\r\nunsigned int eccsize)\r\n{\r\nunsigned char b0, b1, b2, bit_addr;\r\nunsigned int byte_addr;\r\nconst uint32_t eccsize_mult = eccsize >> 8;\r\n#ifdef CONFIG_MTD_NAND_ECC_SMC\r\nb0 = read_ecc[0] ^ calc_ecc[0];\r\nb1 = read_ecc[1] ^ calc_ecc[1];\r\n#else\r\nb0 = read_ecc[1] ^ calc_ecc[1];\r\nb1 = read_ecc[0] ^ calc_ecc[0];\r\n#endif\r\nb2 = read_ecc[2] ^ calc_ecc[2];\r\nif ((b0 | b1 | b2) == 0)\r\nreturn 0;\r\nif ((((b0 ^ (b0 >> 1)) & 0x55) == 0x55) &&\r\n(((b1 ^ (b1 >> 1)) & 0x55) == 0x55) &&\r\n((eccsize_mult == 1 && ((b2 ^ (b2 >> 1)) & 0x54) == 0x54) ||\r\n(eccsize_mult == 2 && ((b2 ^ (b2 >> 1)) & 0x55) == 0x55))) {\r\nif (eccsize_mult == 1)\r\nbyte_addr = (addressbits[b1] << 4) + addressbits[b0];\r\nelse\r\nbyte_addr = (addressbits[b2 & 0x3] << 8) +\r\n(addressbits[b1] << 4) + addressbits[b0];\r\nbit_addr = addressbits[b2 >> 2];\r\nbuf[byte_addr] ^= (1 << bit_addr);\r\nreturn 1;\r\n}\r\nif ((bitsperbyte[b0] + bitsperbyte[b1] + bitsperbyte[b2]) == 1)\r\nreturn 1;\r\npr_err("%s: uncorrectable ECC error", __func__);\r\nreturn -1;\r\n}\r\nint nand_correct_data(struct mtd_info *mtd, unsigned char *buf,\r\nunsigned char *read_ecc, unsigned char *calc_ecc)\r\n{\r\nreturn __nand_correct_data(buf, read_ecc, calc_ecc,\r\n((struct nand_chip *)mtd->priv)->ecc.size);\r\n}
