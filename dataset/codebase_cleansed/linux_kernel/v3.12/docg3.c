static inline u8 doc_readb(struct docg3 *docg3, u16 reg)\r\n{\r\nu8 val = readb(docg3->cascade->base + reg);\r\ntrace_docg3_io(0, 8, reg, (int)val);\r\nreturn val;\r\n}\r\nstatic inline u16 doc_readw(struct docg3 *docg3, u16 reg)\r\n{\r\nu16 val = readw(docg3->cascade->base + reg);\r\ntrace_docg3_io(0, 16, reg, (int)val);\r\nreturn val;\r\n}\r\nstatic inline void doc_writeb(struct docg3 *docg3, u8 val, u16 reg)\r\n{\r\nwriteb(val, docg3->cascade->base + reg);\r\ntrace_docg3_io(1, 8, reg, val);\r\n}\r\nstatic inline void doc_writew(struct docg3 *docg3, u16 val, u16 reg)\r\n{\r\nwritew(val, docg3->cascade->base + reg);\r\ntrace_docg3_io(1, 16, reg, val);\r\n}\r\nstatic inline void doc_flash_command(struct docg3 *docg3, u8 cmd)\r\n{\r\ndoc_writeb(docg3, cmd, DOC_FLASHCOMMAND);\r\n}\r\nstatic inline void doc_flash_sequence(struct docg3 *docg3, u8 seq)\r\n{\r\ndoc_writeb(docg3, seq, DOC_FLASHSEQUENCE);\r\n}\r\nstatic inline void doc_flash_address(struct docg3 *docg3, u8 addr)\r\n{\r\ndoc_writeb(docg3, addr, DOC_FLASHADDRESS);\r\n}\r\nstatic int doc_register_readb(struct docg3 *docg3, int reg)\r\n{\r\nu8 val;\r\ndoc_writew(docg3, reg, DOC_READADDRESS);\r\nval = doc_readb(docg3, reg);\r\ndoc_vdbg("Read register %04x : %02x\n", reg, val);\r\nreturn val;\r\n}\r\nstatic int doc_register_readw(struct docg3 *docg3, int reg)\r\n{\r\nu16 val;\r\ndoc_writew(docg3, reg, DOC_READADDRESS);\r\nval = doc_readw(docg3, reg);\r\ndoc_vdbg("Read register %04x : %04x\n", reg, val);\r\nreturn val;\r\n}\r\nstatic void doc_delay(struct docg3 *docg3, int nbNOPs)\r\n{\r\nint i;\r\ndoc_vdbg("NOP x %d\n", nbNOPs);\r\nfor (i = 0; i < nbNOPs; i++)\r\ndoc_writeb(docg3, 0, DOC_NOP);\r\n}\r\nstatic int is_prot_seq_error(struct docg3 *docg3)\r\n{\r\nint ctrl;\r\nctrl = doc_register_readb(docg3, DOC_FLASHCONTROL);\r\nreturn ctrl & (DOC_CTRL_PROTECTION_ERROR | DOC_CTRL_SEQUENCE_ERROR);\r\n}\r\nstatic int doc_is_ready(struct docg3 *docg3)\r\n{\r\nint ctrl;\r\nctrl = doc_register_readb(docg3, DOC_FLASHCONTROL);\r\nreturn ctrl & DOC_CTRL_FLASHREADY;\r\n}\r\nstatic int doc_wait_ready(struct docg3 *docg3)\r\n{\r\nint maxWaitCycles = 100;\r\ndo {\r\ndoc_delay(docg3, 4);\r\ncpu_relax();\r\n} while (!doc_is_ready(docg3) && maxWaitCycles--);\r\ndoc_delay(docg3, 2);\r\nif (maxWaitCycles > 0)\r\nreturn 0;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic int doc_reset_seq(struct docg3 *docg3)\r\n{\r\nint ret;\r\ndoc_writeb(docg3, 0x10, DOC_FLASHCONTROL);\r\ndoc_flash_sequence(docg3, DOC_SEQ_RESET);\r\ndoc_flash_command(docg3, DOC_CMD_RESET);\r\ndoc_delay(docg3, 2);\r\nret = doc_wait_ready(docg3);\r\ndoc_dbg("doc_reset_seq() -> isReady=%s\n", ret ? "false" : "true");\r\nreturn ret;\r\n}\r\nstatic void doc_read_data_area(struct docg3 *docg3, void *buf, int len,\r\nint first)\r\n{\r\nint i, cdr, len4;\r\nu16 data16, *dst16;\r\nu8 data8, *dst8;\r\ndoc_dbg("doc_read_data_area(buf=%p, len=%d)\n", buf, len);\r\ncdr = len & 0x1;\r\nlen4 = len - cdr;\r\nif (first)\r\ndoc_writew(docg3, DOC_IOSPACE_DATA, DOC_READADDRESS);\r\ndst16 = buf;\r\nfor (i = 0; i < len4; i += 2) {\r\ndata16 = doc_readw(docg3, DOC_IOSPACE_DATA);\r\nif (dst16) {\r\n*dst16 = data16;\r\ndst16++;\r\n}\r\n}\r\nif (cdr) {\r\ndoc_writew(docg3, DOC_IOSPACE_DATA | DOC_READADDR_ONE_BYTE,\r\nDOC_READADDRESS);\r\ndoc_delay(docg3, 1);\r\ndst8 = (u8 *)dst16;\r\nfor (i = 0; i < cdr; i++) {\r\ndata8 = doc_readb(docg3, DOC_IOSPACE_DATA);\r\nif (dst8) {\r\n*dst8 = data8;\r\ndst8++;\r\n}\r\n}\r\n}\r\n}\r\nstatic void doc_write_data_area(struct docg3 *docg3, const void *buf, int len)\r\n{\r\nint i, cdr, len4;\r\nu16 *src16;\r\nu8 *src8;\r\ndoc_dbg("doc_write_data_area(buf=%p, len=%d)\n", buf, len);\r\ncdr = len & 0x3;\r\nlen4 = len - cdr;\r\ndoc_writew(docg3, DOC_IOSPACE_DATA, DOC_READADDRESS);\r\nsrc16 = (u16 *)buf;\r\nfor (i = 0; i < len4; i += 2) {\r\ndoc_writew(docg3, *src16, DOC_IOSPACE_DATA);\r\nsrc16++;\r\n}\r\nsrc8 = (u8 *)src16;\r\nfor (i = 0; i < cdr; i++) {\r\ndoc_writew(docg3, DOC_IOSPACE_DATA | DOC_READADDR_ONE_BYTE,\r\nDOC_READADDRESS);\r\ndoc_writeb(docg3, *src8, DOC_IOSPACE_DATA);\r\nsrc8++;\r\n}\r\n}\r\nstatic void doc_set_reliable_mode(struct docg3 *docg3)\r\n{\r\nstatic char *strmode[] = { "normal", "fast", "reliable", "invalid" };\r\ndoc_dbg("doc_set_reliable_mode(%s)\n", strmode[docg3->reliable]);\r\nswitch (docg3->reliable) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\ndoc_flash_sequence(docg3, DOC_SEQ_SET_FASTMODE);\r\ndoc_flash_command(docg3, DOC_CMD_FAST_MODE);\r\nbreak;\r\ncase 2:\r\ndoc_flash_sequence(docg3, DOC_SEQ_SET_RELIABLEMODE);\r\ndoc_flash_command(docg3, DOC_CMD_FAST_MODE);\r\ndoc_flash_command(docg3, DOC_CMD_RELIABLE_MODE);\r\nbreak;\r\ndefault:\r\ndoc_err("doc_set_reliable_mode(): invalid mode\n");\r\nbreak;\r\n}\r\ndoc_delay(docg3, 2);\r\n}\r\nstatic void doc_set_asic_mode(struct docg3 *docg3, u8 mode)\r\n{\r\nint i;\r\nfor (i = 0; i < 12; i++)\r\ndoc_readb(docg3, DOC_IOSPACE_IPL);\r\nmode |= DOC_ASICMODE_MDWREN;\r\ndoc_dbg("doc_set_asic_mode(%02x)\n", mode);\r\ndoc_writeb(docg3, mode, DOC_ASICMODE);\r\ndoc_writeb(docg3, ~mode, DOC_ASICMODECONFIRM);\r\ndoc_delay(docg3, 1);\r\n}\r\nstatic void doc_set_device_id(struct docg3 *docg3, int id)\r\n{\r\nu8 ctrl;\r\ndoc_dbg("doc_set_device_id(%d)\n", id);\r\ndoc_writeb(docg3, id, DOC_DEVICESELECT);\r\nctrl = doc_register_readb(docg3, DOC_FLASHCONTROL);\r\nctrl &= ~DOC_CTRL_VIOLATION;\r\nctrl |= DOC_CTRL_CE;\r\ndoc_writeb(docg3, ctrl, DOC_FLASHCONTROL);\r\n}\r\nstatic int doc_set_extra_page_mode(struct docg3 *docg3)\r\n{\r\nint fctrl;\r\ndoc_dbg("doc_set_extra_page_mode()\n");\r\ndoc_flash_sequence(docg3, DOC_SEQ_PAGE_SIZE_532);\r\ndoc_flash_command(docg3, DOC_CMD_PAGE_SIZE_532);\r\ndoc_delay(docg3, 2);\r\nfctrl = doc_register_readb(docg3, DOC_FLASHCONTROL);\r\nif (fctrl & (DOC_CTRL_PROTECTION_ERROR | DOC_CTRL_SEQUENCE_ERROR))\r\nreturn -EIO;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void doc_setup_addr_sector(struct docg3 *docg3, int sector)\r\n{\r\ndoc_delay(docg3, 1);\r\ndoc_flash_address(docg3, sector & 0xff);\r\ndoc_flash_address(docg3, (sector >> 8) & 0xff);\r\ndoc_flash_address(docg3, (sector >> 16) & 0xff);\r\ndoc_delay(docg3, 1);\r\n}\r\nstatic void doc_setup_writeaddr_sector(struct docg3 *docg3, int sector, int ofs)\r\n{\r\nofs = ofs >> 2;\r\ndoc_delay(docg3, 1);\r\ndoc_flash_address(docg3, ofs & 0xff);\r\ndoc_flash_address(docg3, sector & 0xff);\r\ndoc_flash_address(docg3, (sector >> 8) & 0xff);\r\ndoc_flash_address(docg3, (sector >> 16) & 0xff);\r\ndoc_delay(docg3, 1);\r\n}\r\nstatic int doc_read_seek(struct docg3 *docg3, int block0, int block1, int page,\r\nint wear, int ofs)\r\n{\r\nint sector, ret = 0;\r\ndoc_dbg("doc_seek(blocks=(%d,%d), page=%d, ofs=%d, wear=%d)\n",\r\nblock0, block1, page, ofs, wear);\r\nif (!wear && (ofs < 2 * DOC_LAYOUT_PAGE_SIZE)) {\r\ndoc_flash_sequence(docg3, DOC_SEQ_SET_PLANE1);\r\ndoc_flash_command(docg3, DOC_CMD_READ_PLANE1);\r\ndoc_delay(docg3, 2);\r\n} else {\r\ndoc_flash_sequence(docg3, DOC_SEQ_SET_PLANE2);\r\ndoc_flash_command(docg3, DOC_CMD_READ_PLANE2);\r\ndoc_delay(docg3, 2);\r\n}\r\ndoc_set_reliable_mode(docg3);\r\nif (wear)\r\nret = doc_set_extra_page_mode(docg3);\r\nif (ret)\r\ngoto out;\r\ndoc_flash_sequence(docg3, DOC_SEQ_READ);\r\nsector = (block0 << DOC_ADDR_BLOCK_SHIFT) + (page & DOC_ADDR_PAGE_MASK);\r\ndoc_flash_command(docg3, DOC_CMD_PROG_BLOCK_ADDR);\r\ndoc_setup_addr_sector(docg3, sector);\r\nsector = (block1 << DOC_ADDR_BLOCK_SHIFT) + (page & DOC_ADDR_PAGE_MASK);\r\ndoc_flash_command(docg3, DOC_CMD_PROG_BLOCK_ADDR);\r\ndoc_setup_addr_sector(docg3, sector);\r\ndoc_delay(docg3, 1);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int doc_write_seek(struct docg3 *docg3, int block0, int block1, int page,\r\nint ofs)\r\n{\r\nint ret = 0, sector;\r\ndoc_dbg("doc_write_seek(blocks=(%d,%d), page=%d, ofs=%d)\n",\r\nblock0, block1, page, ofs);\r\ndoc_set_reliable_mode(docg3);\r\nif (ofs < 2 * DOC_LAYOUT_PAGE_SIZE) {\r\ndoc_flash_sequence(docg3, DOC_SEQ_SET_PLANE1);\r\ndoc_flash_command(docg3, DOC_CMD_READ_PLANE1);\r\ndoc_delay(docg3, 2);\r\n} else {\r\ndoc_flash_sequence(docg3, DOC_SEQ_SET_PLANE2);\r\ndoc_flash_command(docg3, DOC_CMD_READ_PLANE2);\r\ndoc_delay(docg3, 2);\r\n}\r\ndoc_flash_sequence(docg3, DOC_SEQ_PAGE_SETUP);\r\ndoc_flash_command(docg3, DOC_CMD_PROG_CYCLE1);\r\nsector = (block0 << DOC_ADDR_BLOCK_SHIFT) + (page & DOC_ADDR_PAGE_MASK);\r\ndoc_setup_writeaddr_sector(docg3, sector, ofs);\r\ndoc_flash_command(docg3, DOC_CMD_PROG_CYCLE3);\r\ndoc_delay(docg3, 2);\r\nret = doc_wait_ready(docg3);\r\nif (ret)\r\ngoto out;\r\ndoc_flash_command(docg3, DOC_CMD_PROG_CYCLE1);\r\nsector = (block1 << DOC_ADDR_BLOCK_SHIFT) + (page & DOC_ADDR_PAGE_MASK);\r\ndoc_setup_writeaddr_sector(docg3, sector, ofs);\r\ndoc_delay(docg3, 1);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int doc_read_page_ecc_init(struct docg3 *docg3, int len)\r\n{\r\ndoc_writew(docg3, DOC_ECCCONF0_READ_MODE\r\n| DOC_ECCCONF0_BCH_ENABLE | DOC_ECCCONF0_HAMMING_ENABLE\r\n| (len & DOC_ECCCONF0_DATA_BYTES_MASK),\r\nDOC_ECCCONF0);\r\ndoc_delay(docg3, 4);\r\ndoc_register_readb(docg3, DOC_FLASHCONTROL);\r\nreturn doc_wait_ready(docg3);\r\n}\r\nstatic int doc_write_page_ecc_init(struct docg3 *docg3, int len)\r\n{\r\ndoc_writew(docg3, DOC_ECCCONF0_WRITE_MODE\r\n| DOC_ECCCONF0_BCH_ENABLE | DOC_ECCCONF0_HAMMING_ENABLE\r\n| (len & DOC_ECCCONF0_DATA_BYTES_MASK),\r\nDOC_ECCCONF0);\r\ndoc_delay(docg3, 4);\r\ndoc_register_readb(docg3, DOC_FLASHCONTROL);\r\nreturn doc_wait_ready(docg3);\r\n}\r\nstatic void doc_ecc_disable(struct docg3 *docg3)\r\n{\r\ndoc_writew(docg3, DOC_ECCCONF0_READ_MODE, DOC_ECCCONF0);\r\ndoc_delay(docg3, 4);\r\n}\r\nstatic void doc_hamming_ecc_init(struct docg3 *docg3, int nb_bytes)\r\n{\r\nu8 ecc_conf1;\r\necc_conf1 = doc_register_readb(docg3, DOC_ECCCONF1);\r\necc_conf1 &= ~DOC_ECCCONF1_HAMMING_BITS_MASK;\r\necc_conf1 |= (nb_bytes & DOC_ECCCONF1_HAMMING_BITS_MASK);\r\ndoc_writeb(docg3, ecc_conf1, DOC_ECCCONF1);\r\n}\r\nstatic int doc_ecc_bch_fix_data(struct docg3 *docg3, void *buf, u8 *hwecc)\r\n{\r\nu8 ecc[DOC_ECC_BCH_SIZE];\r\nint errorpos[DOC_ECC_BCH_T], i, numerrs;\r\nfor (i = 0; i < DOC_ECC_BCH_SIZE; i++)\r\necc[i] = bitrev8(hwecc[i]);\r\nnumerrs = decode_bch(docg3->cascade->bch, NULL,\r\nDOC_ECC_BCH_COVERED_BYTES,\r\nNULL, ecc, NULL, errorpos);\r\nBUG_ON(numerrs == -EINVAL);\r\nif (numerrs < 0)\r\ngoto out;\r\nfor (i = 0; i < numerrs; i++)\r\nerrorpos[i] = (errorpos[i] & ~7) | (7 - (errorpos[i] & 7));\r\nfor (i = 0; i < numerrs; i++)\r\nif (errorpos[i] < DOC_ECC_BCH_COVERED_BYTES*8)\r\nchange_bit(errorpos[i], buf);\r\nout:\r\ndoc_dbg("doc_ecc_bch_fix_data: flipped %d bits\n", numerrs);\r\nreturn numerrs;\r\n}\r\nstatic int doc_read_page_prepare(struct docg3 *docg3, int block0, int block1,\r\nint page, int offset)\r\n{\r\nint wear_area = 0, ret = 0;\r\ndoc_dbg("doc_read_page_prepare(blocks=(%d,%d), page=%d, ofsInPage=%d)\n",\r\nblock0, block1, page, offset);\r\nif (offset >= DOC_LAYOUT_WEAR_OFFSET)\r\nwear_area = 1;\r\nif (!wear_area && offset > (DOC_LAYOUT_PAGE_OOB_SIZE * 2))\r\nreturn -EINVAL;\r\ndoc_set_device_id(docg3, docg3->device_id);\r\nret = doc_reset_seq(docg3);\r\nif (ret)\r\ngoto err;\r\nret = doc_read_seek(docg3, block0, block1, page, wear_area, offset);\r\nif (ret)\r\ngoto err;\r\ndoc_flash_command(docg3, DOC_CMD_READ_ALL_PLANES);\r\ndoc_delay(docg3, 2);\r\ndoc_wait_ready(docg3);\r\ndoc_flash_command(docg3, DOC_CMD_SET_ADDR_READ);\r\ndoc_delay(docg3, 1);\r\nif (offset >= DOC_LAYOUT_PAGE_SIZE * 2)\r\noffset -= 2 * DOC_LAYOUT_PAGE_SIZE;\r\ndoc_flash_address(docg3, offset >> 2);\r\ndoc_delay(docg3, 1);\r\ndoc_wait_ready(docg3);\r\ndoc_flash_command(docg3, DOC_CMD_READ_FLASH);\r\nreturn 0;\r\nerr:\r\ndoc_writeb(docg3, 0, DOC_DATAEND);\r\ndoc_delay(docg3, 2);\r\nreturn -EIO;\r\n}\r\nstatic int doc_read_page_getbytes(struct docg3 *docg3, int len, u_char *buf,\r\nint first, int last_odd)\r\n{\r\nif (last_odd && len > 0) {\r\ndoc_read_data_area(docg3, buf, 1, first);\r\ndoc_read_data_area(docg3, buf ? buf + 1 : buf, len - 1, 0);\r\n} else {\r\ndoc_read_data_area(docg3, buf, len, first);\r\n}\r\ndoc_delay(docg3, 2);\r\nreturn len;\r\n}\r\nstatic void doc_write_page_putbytes(struct docg3 *docg3, int len,\r\nconst u_char *buf)\r\n{\r\ndoc_write_data_area(docg3, buf, len);\r\ndoc_delay(docg3, 2);\r\n}\r\nstatic void doc_get_bch_hw_ecc(struct docg3 *docg3, u8 *hwecc)\r\n{\r\nint i;\r\nfor (i = 0; i < DOC_ECC_BCH_SIZE; i++)\r\nhwecc[i] = doc_register_readb(docg3, DOC_BCH_HW_ECC(i));\r\n}\r\nstatic void doc_page_finish(struct docg3 *docg3)\r\n{\r\ndoc_writeb(docg3, 0, DOC_DATAEND);\r\ndoc_delay(docg3, 2);\r\n}\r\nstatic void doc_read_page_finish(struct docg3 *docg3)\r\n{\r\ndoc_page_finish(docg3);\r\ndoc_set_device_id(docg3, 0);\r\n}\r\nstatic void calc_block_sector(loff_t from, int *block0, int *block1, int *page,\r\nint *ofs, int reliable)\r\n{\r\nuint sector, pages_biblock;\r\npages_biblock = DOC_LAYOUT_PAGES_PER_BLOCK * DOC_LAYOUT_NBPLANES;\r\nif (reliable == 1 || reliable == 2)\r\npages_biblock /= 2;\r\nsector = from / DOC_LAYOUT_PAGE_SIZE;\r\n*block0 = sector / pages_biblock * DOC_LAYOUT_NBPLANES;\r\n*block1 = *block0 + 1;\r\n*page = sector % pages_biblock;\r\n*page /= DOC_LAYOUT_NBPLANES;\r\nif (reliable == 1 || reliable == 2)\r\n*page *= 2;\r\nif (sector % 2)\r\n*ofs = DOC_LAYOUT_PAGE_OOB_SIZE;\r\nelse\r\n*ofs = 0;\r\n}\r\nstatic int doc_read_oob(struct mtd_info *mtd, loff_t from,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nstruct docg3 *docg3 = mtd->priv;\r\nint block0, block1, page, ret, skip, ofs = 0;\r\nu8 *oobbuf = ops->oobbuf;\r\nu8 *buf = ops->datbuf;\r\nsize_t len, ooblen, nbdata, nboob;\r\nu8 hwecc[DOC_ECC_BCH_SIZE], eccconf1;\r\nint max_bitflips = 0;\r\nif (buf)\r\nlen = ops->len;\r\nelse\r\nlen = 0;\r\nif (oobbuf)\r\nooblen = ops->ooblen;\r\nelse\r\nooblen = 0;\r\nif (oobbuf && ops->mode == MTD_OPS_PLACE_OOB)\r\noobbuf += ops->ooboffs;\r\ndoc_dbg("doc_read_oob(from=%lld, mode=%d, data=(%p:%zu), oob=(%p:%zu))\n",\r\nfrom, ops->mode, buf, len, oobbuf, ooblen);\r\nif (ooblen % DOC_LAYOUT_OOB_SIZE)\r\nreturn -EINVAL;\r\nif (from + len > mtd->size)\r\nreturn -EINVAL;\r\nops->oobretlen = 0;\r\nops->retlen = 0;\r\nret = 0;\r\nskip = from % DOC_LAYOUT_PAGE_SIZE;\r\nmutex_lock(&docg3->cascade->lock);\r\nwhile (ret >= 0 && (len > 0 || ooblen > 0)) {\r\ncalc_block_sector(from - skip, &block0, &block1, &page, &ofs,\r\ndocg3->reliable);\r\nnbdata = min_t(size_t, len, DOC_LAYOUT_PAGE_SIZE - skip);\r\nnboob = min_t(size_t, ooblen, (size_t)DOC_LAYOUT_OOB_SIZE);\r\nret = doc_read_page_prepare(docg3, block0, block1, page, ofs);\r\nif (ret < 0)\r\ngoto out;\r\nret = doc_read_page_ecc_init(docg3, DOC_ECC_BCH_TOTAL_BYTES);\r\nif (ret < 0)\r\ngoto err_in_read;\r\nret = doc_read_page_getbytes(docg3, skip, NULL, 1, 0);\r\nif (ret < skip)\r\ngoto err_in_read;\r\nret = doc_read_page_getbytes(docg3, nbdata, buf, 0, skip % 2);\r\nif (ret < nbdata)\r\ngoto err_in_read;\r\ndoc_read_page_getbytes(docg3,\r\nDOC_LAYOUT_PAGE_SIZE - nbdata - skip,\r\nNULL, 0, (skip + nbdata) % 2);\r\nret = doc_read_page_getbytes(docg3, nboob, oobbuf, 0, 0);\r\nif (ret < nboob)\r\ngoto err_in_read;\r\ndoc_read_page_getbytes(docg3, DOC_LAYOUT_OOB_SIZE - nboob,\r\nNULL, 0, nboob % 2);\r\ndoc_get_bch_hw_ecc(docg3, hwecc);\r\neccconf1 = doc_register_readb(docg3, DOC_ECCCONF1);\r\nif (nboob >= DOC_LAYOUT_OOB_SIZE) {\r\ndoc_dbg("OOB - INFO: %*phC\n", 7, oobbuf);\r\ndoc_dbg("OOB - HAMMING: %02x\n", oobbuf[7]);\r\ndoc_dbg("OOB - BCH_ECC: %*phC\n", 7, oobbuf + 8);\r\ndoc_dbg("OOB - UNUSED: %02x\n", oobbuf[15]);\r\n}\r\ndoc_dbg("ECC checks: ECCConf1=%x\n", eccconf1);\r\ndoc_dbg("ECC HW_ECC: %*phC\n", 7, hwecc);\r\nret = -EIO;\r\nif (is_prot_seq_error(docg3))\r\ngoto err_in_read;\r\nret = 0;\r\nif ((block0 >= DOC_LAYOUT_BLOCK_FIRST_DATA) &&\r\n(eccconf1 & DOC_ECCCONF1_BCH_SYNDROM_ERR) &&\r\n(eccconf1 & DOC_ECCCONF1_PAGE_IS_WRITTEN) &&\r\n(ops->mode != MTD_OPS_RAW) &&\r\n(nbdata == DOC_LAYOUT_PAGE_SIZE)) {\r\nret = doc_ecc_bch_fix_data(docg3, buf, hwecc);\r\nif (ret < 0) {\r\nmtd->ecc_stats.failed++;\r\nret = -EBADMSG;\r\n}\r\nif (ret > 0) {\r\nmtd->ecc_stats.corrected += ret;\r\nmax_bitflips = max(max_bitflips, ret);\r\nret = max_bitflips;\r\n}\r\n}\r\ndoc_read_page_finish(docg3);\r\nops->retlen += nbdata;\r\nops->oobretlen += nboob;\r\nbuf += nbdata;\r\noobbuf += nboob;\r\nlen -= nbdata;\r\nooblen -= nboob;\r\nfrom += DOC_LAYOUT_PAGE_SIZE;\r\nskip = 0;\r\n}\r\nout:\r\nmutex_unlock(&docg3->cascade->lock);\r\nreturn ret;\r\nerr_in_read:\r\ndoc_read_page_finish(docg3);\r\ngoto out;\r\n}\r\nstatic int doc_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nstruct mtd_oob_ops ops;\r\nsize_t ret;\r\nmemset(&ops, 0, sizeof(ops));\r\nops.datbuf = buf;\r\nops.len = len;\r\nops.mode = MTD_OPS_AUTO_OOB;\r\nret = doc_read_oob(mtd, from, &ops);\r\n*retlen = ops.retlen;\r\nreturn ret;\r\n}\r\nstatic int doc_reload_bbt(struct docg3 *docg3)\r\n{\r\nint block = DOC_LAYOUT_BLOCK_BBT;\r\nint ret = 0, nbpages, page;\r\nu_char *buf = docg3->bbt;\r\nnbpages = DIV_ROUND_UP(docg3->max_block + 1, 8 * DOC_LAYOUT_PAGE_SIZE);\r\nfor (page = 0; !ret && (page < nbpages); page++) {\r\nret = doc_read_page_prepare(docg3, block, block + 1,\r\npage + DOC_LAYOUT_PAGE_BBT, 0);\r\nif (!ret)\r\nret = doc_read_page_ecc_init(docg3,\r\nDOC_LAYOUT_PAGE_SIZE);\r\nif (!ret)\r\ndoc_read_page_getbytes(docg3, DOC_LAYOUT_PAGE_SIZE,\r\nbuf, 1, 0);\r\nbuf += DOC_LAYOUT_PAGE_SIZE;\r\n}\r\ndoc_read_page_finish(docg3);\r\nreturn ret;\r\n}\r\nstatic int doc_block_isbad(struct mtd_info *mtd, loff_t from)\r\n{\r\nstruct docg3 *docg3 = mtd->priv;\r\nint block0, block1, page, ofs, is_good;\r\ncalc_block_sector(from, &block0, &block1, &page, &ofs,\r\ndocg3->reliable);\r\ndoc_dbg("doc_block_isbad(from=%lld) => block=(%d,%d), page=%d, ofs=%d\n",\r\nfrom, block0, block1, page, ofs);\r\nif (block0 < DOC_LAYOUT_BLOCK_FIRST_DATA)\r\nreturn 0;\r\nif (block1 > docg3->max_block)\r\nreturn -EINVAL;\r\nis_good = docg3->bbt[block0 >> 3] & (1 << (block0 & 0x7));\r\nreturn !is_good;\r\n}\r\nstatic int doc_get_op_status(struct docg3 *docg3)\r\n{\r\nu8 status;\r\ndoc_flash_sequence(docg3, DOC_SEQ_PLANES_STATUS);\r\ndoc_flash_command(docg3, DOC_CMD_PLANES_STATUS);\r\ndoc_delay(docg3, 5);\r\ndoc_ecc_disable(docg3);\r\ndoc_read_data_area(docg3, &status, 1, 1);\r\nreturn status;\r\n}\r\nstatic int doc_write_erase_wait_status(struct docg3 *docg3)\r\n{\r\nint i, status, ret = 0;\r\nfor (i = 0; !doc_is_ready(docg3) && i < 5; i++)\r\nmsleep(20);\r\nif (!doc_is_ready(docg3)) {\r\ndoc_dbg("Timeout reached and the chip is still not ready\n");\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nstatus = doc_get_op_status(docg3);\r\nif (status & DOC_PLANES_STATUS_FAIL) {\r\ndoc_dbg("Erase/Write failed on (a) plane(s), status = %x\n",\r\nstatus);\r\nret = -EIO;\r\n}\r\nout:\r\ndoc_page_finish(docg3);\r\nreturn ret;\r\n}\r\nstatic int doc_erase_block(struct docg3 *docg3, int block0, int block1)\r\n{\r\nint ret, sector;\r\ndoc_dbg("doc_erase_block(blocks=(%d,%d))\n", block0, block1);\r\nret = doc_reset_seq(docg3);\r\nif (ret)\r\nreturn -EIO;\r\ndoc_set_reliable_mode(docg3);\r\ndoc_flash_sequence(docg3, DOC_SEQ_ERASE);\r\nsector = block0 << DOC_ADDR_BLOCK_SHIFT;\r\ndoc_flash_command(docg3, DOC_CMD_PROG_BLOCK_ADDR);\r\ndoc_setup_addr_sector(docg3, sector);\r\nsector = block1 << DOC_ADDR_BLOCK_SHIFT;\r\ndoc_flash_command(docg3, DOC_CMD_PROG_BLOCK_ADDR);\r\ndoc_setup_addr_sector(docg3, sector);\r\ndoc_delay(docg3, 1);\r\ndoc_flash_command(docg3, DOC_CMD_ERASECYCLE2);\r\ndoc_delay(docg3, 2);\r\nif (is_prot_seq_error(docg3)) {\r\ndoc_err("Erase blocks %d,%d error\n", block0, block1);\r\nreturn -EIO;\r\n}\r\nreturn doc_write_erase_wait_status(docg3);\r\n}\r\nstatic int doc_erase(struct mtd_info *mtd, struct erase_info *info)\r\n{\r\nstruct docg3 *docg3 = mtd->priv;\r\nuint64_t len;\r\nint block0, block1, page, ret, ofs = 0;\r\ndoc_dbg("doc_erase(from=%lld, len=%lld\n", info->addr, info->len);\r\ninfo->state = MTD_ERASE_PENDING;\r\ncalc_block_sector(info->addr + info->len, &block0, &block1, &page,\r\n&ofs, docg3->reliable);\r\nret = -EINVAL;\r\nif (info->addr + info->len > mtd->size || page || ofs)\r\ngoto reset_err;\r\nret = 0;\r\ncalc_block_sector(info->addr, &block0, &block1, &page, &ofs,\r\ndocg3->reliable);\r\nmutex_lock(&docg3->cascade->lock);\r\ndoc_set_device_id(docg3, docg3->device_id);\r\ndoc_set_reliable_mode(docg3);\r\nfor (len = info->len; !ret && len > 0; len -= mtd->erasesize) {\r\ninfo->state = MTD_ERASING;\r\nret = doc_erase_block(docg3, block0, block1);\r\nblock0 += 2;\r\nblock1 += 2;\r\n}\r\nmutex_unlock(&docg3->cascade->lock);\r\nif (ret)\r\ngoto reset_err;\r\ninfo->state = MTD_ERASE_DONE;\r\nreturn 0;\r\nreset_err:\r\ninfo->state = MTD_ERASE_FAILED;\r\nreturn ret;\r\n}\r\nstatic int doc_write_page(struct docg3 *docg3, loff_t to, const u_char *buf,\r\nconst u_char *oob, int autoecc)\r\n{\r\nint block0, block1, page, ret, ofs = 0;\r\nu8 hwecc[DOC_ECC_BCH_SIZE], hamming;\r\ndoc_dbg("doc_write_page(to=%lld)\n", to);\r\ncalc_block_sector(to, &block0, &block1, &page, &ofs, docg3->reliable);\r\ndoc_set_device_id(docg3, docg3->device_id);\r\nret = doc_reset_seq(docg3);\r\nif (ret)\r\ngoto err;\r\nret = doc_write_seek(docg3, block0, block1, page, ofs);\r\nif (ret)\r\ngoto err;\r\ndoc_write_page_ecc_init(docg3, DOC_ECC_BCH_TOTAL_BYTES);\r\ndoc_delay(docg3, 2);\r\ndoc_write_page_putbytes(docg3, DOC_LAYOUT_PAGE_SIZE, buf);\r\nif (oob && autoecc) {\r\ndoc_write_page_putbytes(docg3, DOC_LAYOUT_OOB_PAGEINFO_SZ, oob);\r\ndoc_delay(docg3, 2);\r\noob += DOC_LAYOUT_OOB_UNUSED_OFS;\r\nhamming = doc_register_readb(docg3, DOC_HAMMINGPARITY);\r\ndoc_delay(docg3, 2);\r\ndoc_write_page_putbytes(docg3, DOC_LAYOUT_OOB_HAMMING_SZ,\r\n&hamming);\r\ndoc_delay(docg3, 2);\r\ndoc_get_bch_hw_ecc(docg3, hwecc);\r\ndoc_write_page_putbytes(docg3, DOC_LAYOUT_OOB_BCH_SZ, hwecc);\r\ndoc_delay(docg3, 2);\r\ndoc_write_page_putbytes(docg3, DOC_LAYOUT_OOB_UNUSED_SZ, oob);\r\n}\r\nif (oob && !autoecc)\r\ndoc_write_page_putbytes(docg3, DOC_LAYOUT_OOB_SIZE, oob);\r\ndoc_delay(docg3, 2);\r\ndoc_page_finish(docg3);\r\ndoc_delay(docg3, 2);\r\ndoc_flash_command(docg3, DOC_CMD_PROG_CYCLE2);\r\ndoc_delay(docg3, 2);\r\nret = doc_write_erase_wait_status(docg3);\r\nreturn ret;\r\nerr:\r\ndoc_read_page_finish(docg3);\r\nreturn ret;\r\n}\r\nstatic int doc_guess_autoecc(struct mtd_oob_ops *ops)\r\n{\r\nint autoecc;\r\nswitch (ops->mode) {\r\ncase MTD_OPS_PLACE_OOB:\r\ncase MTD_OPS_AUTO_OOB:\r\nautoecc = 1;\r\nbreak;\r\ncase MTD_OPS_RAW:\r\nautoecc = 0;\r\nbreak;\r\ndefault:\r\nautoecc = -EINVAL;\r\n}\r\nreturn autoecc;\r\n}\r\nstatic void doc_fill_autooob(u8 *dst, u8 *oobsrc)\r\n{\r\nmemcpy(dst, oobsrc, DOC_LAYOUT_OOB_PAGEINFO_SZ);\r\ndst[DOC_LAYOUT_OOB_UNUSED_OFS] = oobsrc[DOC_LAYOUT_OOB_PAGEINFO_SZ];\r\n}\r\nstatic int doc_backup_oob(struct docg3 *docg3, loff_t to,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nint ooblen = ops->ooblen, autoecc;\r\nif (ooblen != DOC_LAYOUT_OOB_SIZE)\r\nreturn -EINVAL;\r\nautoecc = doc_guess_autoecc(ops);\r\nif (autoecc < 0)\r\nreturn autoecc;\r\ndocg3->oob_write_ofs = to;\r\ndocg3->oob_autoecc = autoecc;\r\nif (ops->mode == MTD_OPS_AUTO_OOB) {\r\ndoc_fill_autooob(docg3->oob_write_buf, ops->oobbuf);\r\nops->oobretlen = 8;\r\n} else {\r\nmemcpy(docg3->oob_write_buf, ops->oobbuf, DOC_LAYOUT_OOB_SIZE);\r\nops->oobretlen = DOC_LAYOUT_OOB_SIZE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int doc_write_oob(struct mtd_info *mtd, loff_t ofs,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nstruct docg3 *docg3 = mtd->priv;\r\nint ret, autoecc, oobdelta;\r\nu8 *oobbuf = ops->oobbuf;\r\nu8 *buf = ops->datbuf;\r\nsize_t len, ooblen;\r\nu8 oob[DOC_LAYOUT_OOB_SIZE];\r\nif (buf)\r\nlen = ops->len;\r\nelse\r\nlen = 0;\r\nif (oobbuf)\r\nooblen = ops->ooblen;\r\nelse\r\nooblen = 0;\r\nif (oobbuf && ops->mode == MTD_OPS_PLACE_OOB)\r\noobbuf += ops->ooboffs;\r\ndoc_dbg("doc_write_oob(from=%lld, mode=%d, data=(%p:%zu), oob=(%p:%zu))\n",\r\nofs, ops->mode, buf, len, oobbuf, ooblen);\r\nswitch (ops->mode) {\r\ncase MTD_OPS_PLACE_OOB:\r\ncase MTD_OPS_RAW:\r\noobdelta = mtd->oobsize;\r\nbreak;\r\ncase MTD_OPS_AUTO_OOB:\r\noobdelta = mtd->ecclayout->oobavail;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((len % DOC_LAYOUT_PAGE_SIZE) || (ooblen % oobdelta) ||\r\n(ofs % DOC_LAYOUT_PAGE_SIZE))\r\nreturn -EINVAL;\r\nif (len && ooblen &&\r\n(len / DOC_LAYOUT_PAGE_SIZE) != (ooblen / oobdelta))\r\nreturn -EINVAL;\r\nif (ofs + len > mtd->size)\r\nreturn -EINVAL;\r\nops->oobretlen = 0;\r\nops->retlen = 0;\r\nret = 0;\r\nif (len == 0 && ooblen == 0)\r\nreturn -EINVAL;\r\nif (len == 0 && ooblen > 0)\r\nreturn doc_backup_oob(docg3, ofs, ops);\r\nautoecc = doc_guess_autoecc(ops);\r\nif (autoecc < 0)\r\nreturn autoecc;\r\nmutex_lock(&docg3->cascade->lock);\r\nwhile (!ret && len > 0) {\r\nmemset(oob, 0, sizeof(oob));\r\nif (ofs == docg3->oob_write_ofs)\r\nmemcpy(oob, docg3->oob_write_buf, DOC_LAYOUT_OOB_SIZE);\r\nelse if (ooblen > 0 && ops->mode == MTD_OPS_AUTO_OOB)\r\ndoc_fill_autooob(oob, oobbuf);\r\nelse if (ooblen > 0)\r\nmemcpy(oob, oobbuf, DOC_LAYOUT_OOB_SIZE);\r\nret = doc_write_page(docg3, ofs, buf, oob, autoecc);\r\nofs += DOC_LAYOUT_PAGE_SIZE;\r\nlen -= DOC_LAYOUT_PAGE_SIZE;\r\nbuf += DOC_LAYOUT_PAGE_SIZE;\r\nif (ooblen) {\r\noobbuf += oobdelta;\r\nooblen -= oobdelta;\r\nops->oobretlen += oobdelta;\r\n}\r\nops->retlen += DOC_LAYOUT_PAGE_SIZE;\r\n}\r\ndoc_set_device_id(docg3, 0);\r\nmutex_unlock(&docg3->cascade->lock);\r\nreturn ret;\r\n}\r\nstatic int doc_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nstruct docg3 *docg3 = mtd->priv;\r\nint ret;\r\nstruct mtd_oob_ops ops;\r\ndoc_dbg("doc_write(to=%lld, len=%zu)\n", to, len);\r\nops.datbuf = (char *)buf;\r\nops.len = len;\r\nops.mode = MTD_OPS_PLACE_OOB;\r\nops.oobbuf = NULL;\r\nops.ooblen = 0;\r\nops.ooboffs = 0;\r\nret = doc_write_oob(mtd, to, &ops);\r\n*retlen = ops.retlen;\r\nreturn ret;\r\n}\r\nstatic struct docg3 *sysfs_dev2docg3(struct device *dev,\r\nstruct device_attribute *attr)\r\n{\r\nint floor;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct mtd_info **docg3_floors = platform_get_drvdata(pdev);\r\nfloor = attr->attr.name[1] - '0';\r\nif (floor < 0 || floor >= DOC_MAX_NBFLOORS)\r\nreturn NULL;\r\nelse\r\nreturn docg3_floors[floor]->priv;\r\n}\r\nstatic ssize_t dps0_is_key_locked(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct docg3 *docg3 = sysfs_dev2docg3(dev, attr);\r\nint dps0;\r\nmutex_lock(&docg3->cascade->lock);\r\ndoc_set_device_id(docg3, docg3->device_id);\r\ndps0 = doc_register_readb(docg3, DOC_DPS0_STATUS);\r\ndoc_set_device_id(docg3, 0);\r\nmutex_unlock(&docg3->cascade->lock);\r\nreturn sprintf(buf, "%d\n", !(dps0 & DOC_DPS_KEY_OK));\r\n}\r\nstatic ssize_t dps1_is_key_locked(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct docg3 *docg3 = sysfs_dev2docg3(dev, attr);\r\nint dps1;\r\nmutex_lock(&docg3->cascade->lock);\r\ndoc_set_device_id(docg3, docg3->device_id);\r\ndps1 = doc_register_readb(docg3, DOC_DPS1_STATUS);\r\ndoc_set_device_id(docg3, 0);\r\nmutex_unlock(&docg3->cascade->lock);\r\nreturn sprintf(buf, "%d\n", !(dps1 & DOC_DPS_KEY_OK));\r\n}\r\nstatic ssize_t dps0_insert_key(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct docg3 *docg3 = sysfs_dev2docg3(dev, attr);\r\nint i;\r\nif (count != DOC_LAYOUT_DPS_KEY_LENGTH)\r\nreturn -EINVAL;\r\nmutex_lock(&docg3->cascade->lock);\r\ndoc_set_device_id(docg3, docg3->device_id);\r\nfor (i = 0; i < DOC_LAYOUT_DPS_KEY_LENGTH; i++)\r\ndoc_writeb(docg3, buf[i], DOC_DPS0_KEY);\r\ndoc_set_device_id(docg3, 0);\r\nmutex_unlock(&docg3->cascade->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t dps1_insert_key(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct docg3 *docg3 = sysfs_dev2docg3(dev, attr);\r\nint i;\r\nif (count != DOC_LAYOUT_DPS_KEY_LENGTH)\r\nreturn -EINVAL;\r\nmutex_lock(&docg3->cascade->lock);\r\ndoc_set_device_id(docg3, docg3->device_id);\r\nfor (i = 0; i < DOC_LAYOUT_DPS_KEY_LENGTH; i++)\r\ndoc_writeb(docg3, buf[i], DOC_DPS1_KEY);\r\ndoc_set_device_id(docg3, 0);\r\nmutex_unlock(&docg3->cascade->lock);\r\nreturn count;\r\n}\r\nstatic int doc_register_sysfs(struct platform_device *pdev,\r\nstruct docg3_cascade *cascade)\r\n{\r\nint ret = 0, floor, i = 0;\r\nstruct device *dev = &pdev->dev;\r\nfor (floor = 0; !ret && floor < DOC_MAX_NBFLOORS &&\r\ncascade->floors[floor]; floor++)\r\nfor (i = 0; !ret && i < 4; i++)\r\nret = device_create_file(dev, &doc_sys_attrs[floor][i]);\r\nif (!ret)\r\nreturn 0;\r\ndo {\r\nwhile (--i >= 0)\r\ndevice_remove_file(dev, &doc_sys_attrs[floor][i]);\r\ni = 4;\r\n} while (--floor >= 0);\r\nreturn ret;\r\n}\r\nstatic void doc_unregister_sysfs(struct platform_device *pdev,\r\nstruct docg3_cascade *cascade)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nint floor, i;\r\nfor (floor = 0; floor < DOC_MAX_NBFLOORS && cascade->floors[floor];\r\nfloor++)\r\nfor (i = 0; i < 4; i++)\r\ndevice_remove_file(dev, &doc_sys_attrs[floor][i]);\r\n}\r\nstatic int dbg_flashctrl_show(struct seq_file *s, void *p)\r\n{\r\nstruct docg3 *docg3 = (struct docg3 *)s->private;\r\nint pos = 0;\r\nu8 fctrl;\r\nmutex_lock(&docg3->cascade->lock);\r\nfctrl = doc_register_readb(docg3, DOC_FLASHCONTROL);\r\nmutex_unlock(&docg3->cascade->lock);\r\npos += seq_printf(s,\r\n"FlashControl : 0x%02x (%s,CE# %s,%s,%s,flash %s)\n",\r\nfctrl,\r\nfctrl & DOC_CTRL_VIOLATION ? "protocol violation" : "-",\r\nfctrl & DOC_CTRL_CE ? "active" : "inactive",\r\nfctrl & DOC_CTRL_PROTECTION_ERROR ? "protection error" : "-",\r\nfctrl & DOC_CTRL_SEQUENCE_ERROR ? "sequence error" : "-",\r\nfctrl & DOC_CTRL_FLASHREADY ? "ready" : "not ready");\r\nreturn pos;\r\n}\r\nstatic int dbg_asicmode_show(struct seq_file *s, void *p)\r\n{\r\nstruct docg3 *docg3 = (struct docg3 *)s->private;\r\nint pos = 0, pctrl, mode;\r\nmutex_lock(&docg3->cascade->lock);\r\npctrl = doc_register_readb(docg3, DOC_ASICMODE);\r\nmode = pctrl & 0x03;\r\nmutex_unlock(&docg3->cascade->lock);\r\npos += seq_printf(s,\r\n"%04x : RAM_WE=%d,RSTIN_RESET=%d,BDETCT_RESET=%d,WRITE_ENABLE=%d,POWERDOWN=%d,MODE=%d%d (",\r\npctrl,\r\npctrl & DOC_ASICMODE_RAM_WE ? 1 : 0,\r\npctrl & DOC_ASICMODE_RSTIN_RESET ? 1 : 0,\r\npctrl & DOC_ASICMODE_BDETCT_RESET ? 1 : 0,\r\npctrl & DOC_ASICMODE_MDWREN ? 1 : 0,\r\npctrl & DOC_ASICMODE_POWERDOWN ? 1 : 0,\r\nmode >> 1, mode & 0x1);\r\nswitch (mode) {\r\ncase DOC_ASICMODE_RESET:\r\npos += seq_printf(s, "reset");\r\nbreak;\r\ncase DOC_ASICMODE_NORMAL:\r\npos += seq_printf(s, "normal");\r\nbreak;\r\ncase DOC_ASICMODE_POWERDOWN:\r\npos += seq_printf(s, "powerdown");\r\nbreak;\r\n}\r\npos += seq_printf(s, ")\n");\r\nreturn pos;\r\n}\r\nstatic int dbg_device_id_show(struct seq_file *s, void *p)\r\n{\r\nstruct docg3 *docg3 = (struct docg3 *)s->private;\r\nint pos = 0;\r\nint id;\r\nmutex_lock(&docg3->cascade->lock);\r\nid = doc_register_readb(docg3, DOC_DEVICESELECT);\r\nmutex_unlock(&docg3->cascade->lock);\r\npos += seq_printf(s, "DeviceId = %d\n", id);\r\nreturn pos;\r\n}\r\nstatic int dbg_protection_show(struct seq_file *s, void *p)\r\n{\r\nstruct docg3 *docg3 = (struct docg3 *)s->private;\r\nint pos = 0;\r\nint protect, dps0, dps0_low, dps0_high, dps1, dps1_low, dps1_high;\r\nmutex_lock(&docg3->cascade->lock);\r\nprotect = doc_register_readb(docg3, DOC_PROTECTION);\r\ndps0 = doc_register_readb(docg3, DOC_DPS0_STATUS);\r\ndps0_low = doc_register_readw(docg3, DOC_DPS0_ADDRLOW);\r\ndps0_high = doc_register_readw(docg3, DOC_DPS0_ADDRHIGH);\r\ndps1 = doc_register_readb(docg3, DOC_DPS1_STATUS);\r\ndps1_low = doc_register_readw(docg3, DOC_DPS1_ADDRLOW);\r\ndps1_high = doc_register_readw(docg3, DOC_DPS1_ADDRHIGH);\r\nmutex_unlock(&docg3->cascade->lock);\r\npos += seq_printf(s, "Protection = 0x%02x (",\r\nprotect);\r\nif (protect & DOC_PROTECT_FOUNDRY_OTP_LOCK)\r\npos += seq_printf(s, "FOUNDRY_OTP_LOCK,");\r\nif (protect & DOC_PROTECT_CUSTOMER_OTP_LOCK)\r\npos += seq_printf(s, "CUSTOMER_OTP_LOCK,");\r\nif (protect & DOC_PROTECT_LOCK_INPUT)\r\npos += seq_printf(s, "LOCK_INPUT,");\r\nif (protect & DOC_PROTECT_STICKY_LOCK)\r\npos += seq_printf(s, "STICKY_LOCK,");\r\nif (protect & DOC_PROTECT_PROTECTION_ENABLED)\r\npos += seq_printf(s, "PROTECTION ON,");\r\nif (protect & DOC_PROTECT_IPL_DOWNLOAD_LOCK)\r\npos += seq_printf(s, "IPL_DOWNLOAD_LOCK,");\r\nif (protect & DOC_PROTECT_PROTECTION_ERROR)\r\npos += seq_printf(s, "PROTECT_ERR,");\r\nelse\r\npos += seq_printf(s, "NO_PROTECT_ERR");\r\npos += seq_printf(s, ")\n");\r\npos += seq_printf(s, "DPS0 = 0x%02x : "\r\n"Protected area [0x%x - 0x%x] : OTP=%d, READ=%d, "\r\n"WRITE=%d, HW_LOCK=%d, KEY_OK=%d\n",\r\ndps0, dps0_low, dps0_high,\r\n!!(dps0 & DOC_DPS_OTP_PROTECTED),\r\n!!(dps0 & DOC_DPS_READ_PROTECTED),\r\n!!(dps0 & DOC_DPS_WRITE_PROTECTED),\r\n!!(dps0 & DOC_DPS_HW_LOCK_ENABLED),\r\n!!(dps0 & DOC_DPS_KEY_OK));\r\npos += seq_printf(s, "DPS1 = 0x%02x : "\r\n"Protected area [0x%x - 0x%x] : OTP=%d, READ=%d, "\r\n"WRITE=%d, HW_LOCK=%d, KEY_OK=%d\n",\r\ndps1, dps1_low, dps1_high,\r\n!!(dps1 & DOC_DPS_OTP_PROTECTED),\r\n!!(dps1 & DOC_DPS_READ_PROTECTED),\r\n!!(dps1 & DOC_DPS_WRITE_PROTECTED),\r\n!!(dps1 & DOC_DPS_HW_LOCK_ENABLED),\r\n!!(dps1 & DOC_DPS_KEY_OK));\r\nreturn pos;\r\n}\r\nstatic int __init doc_dbg_register(struct docg3 *docg3)\r\n{\r\nstruct dentry *root, *entry;\r\nroot = debugfs_create_dir("docg3", NULL);\r\nif (!root)\r\nreturn -ENOMEM;\r\nentry = debugfs_create_file("flashcontrol", S_IRUSR, root, docg3,\r\n&flashcontrol_fops);\r\nif (entry)\r\nentry = debugfs_create_file("asic_mode", S_IRUSR, root,\r\ndocg3, &asic_mode_fops);\r\nif (entry)\r\nentry = debugfs_create_file("device_id", S_IRUSR, root,\r\ndocg3, &device_id_fops);\r\nif (entry)\r\nentry = debugfs_create_file("protection", S_IRUSR, root,\r\ndocg3, &protection_fops);\r\nif (entry) {\r\ndocg3->debugfs_root = root;\r\nreturn 0;\r\n} else {\r\ndebugfs_remove_recursive(root);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nstatic void __exit doc_dbg_unregister(struct docg3 *docg3)\r\n{\r\ndebugfs_remove_recursive(docg3->debugfs_root);\r\n}\r\nstatic void __init doc_set_driver_info(int chip_id, struct mtd_info *mtd)\r\n{\r\nstruct docg3 *docg3 = mtd->priv;\r\nint cfg;\r\ncfg = doc_register_readb(docg3, DOC_CONFIGURATION);\r\ndocg3->if_cfg = (cfg & DOC_CONF_IF_CFG ? 1 : 0);\r\ndocg3->reliable = reliable_mode;\r\nswitch (chip_id) {\r\ncase DOC_CHIPID_G3:\r\nmtd->name = kasprintf(GFP_KERNEL, "docg3.%d",\r\ndocg3->device_id);\r\ndocg3->max_block = 2047;\r\nbreak;\r\n}\r\nmtd->type = MTD_NANDFLASH;\r\nmtd->flags = MTD_CAP_NANDFLASH;\r\nmtd->size = (docg3->max_block + 1) * DOC_LAYOUT_BLOCK_SIZE;\r\nif (docg3->reliable == 2)\r\nmtd->size /= 2;\r\nmtd->erasesize = DOC_LAYOUT_BLOCK_SIZE * DOC_LAYOUT_NBPLANES;\r\nif (docg3->reliable == 2)\r\nmtd->erasesize /= 2;\r\nmtd->writebufsize = mtd->writesize = DOC_LAYOUT_PAGE_SIZE;\r\nmtd->oobsize = DOC_LAYOUT_OOB_SIZE;\r\nmtd->owner = THIS_MODULE;\r\nmtd->_erase = doc_erase;\r\nmtd->_read = doc_read;\r\nmtd->_write = doc_write;\r\nmtd->_read_oob = doc_read_oob;\r\nmtd->_write_oob = doc_write_oob;\r\nmtd->_block_isbad = doc_block_isbad;\r\nmtd->ecclayout = &docg3_oobinfo;\r\nmtd->ecc_strength = DOC_ECC_BCH_T;\r\n}\r\nstatic struct mtd_info * __init\r\ndoc_probe_device(struct docg3_cascade *cascade, int floor, struct device *dev)\r\n{\r\nint ret, bbt_nbpages;\r\nu16 chip_id, chip_id_inv;\r\nstruct docg3 *docg3;\r\nstruct mtd_info *mtd;\r\nret = -ENOMEM;\r\ndocg3 = kzalloc(sizeof(struct docg3), GFP_KERNEL);\r\nif (!docg3)\r\ngoto nomem1;\r\nmtd = kzalloc(sizeof(struct mtd_info), GFP_KERNEL);\r\nif (!mtd)\r\ngoto nomem2;\r\nmtd->priv = docg3;\r\nbbt_nbpages = DIV_ROUND_UP(docg3->max_block + 1,\r\n8 * DOC_LAYOUT_PAGE_SIZE);\r\ndocg3->bbt = kzalloc(bbt_nbpages * DOC_LAYOUT_PAGE_SIZE, GFP_KERNEL);\r\nif (!docg3->bbt)\r\ngoto nomem3;\r\ndocg3->dev = dev;\r\ndocg3->device_id = floor;\r\ndocg3->cascade = cascade;\r\ndoc_set_device_id(docg3, docg3->device_id);\r\nif (!floor)\r\ndoc_set_asic_mode(docg3, DOC_ASICMODE_RESET);\r\ndoc_set_asic_mode(docg3, DOC_ASICMODE_NORMAL);\r\nchip_id = doc_register_readw(docg3, DOC_CHIPID);\r\nchip_id_inv = doc_register_readw(docg3, DOC_CHIPID_INV);\r\nret = 0;\r\nif (chip_id != (u16)(~chip_id_inv)) {\r\ngoto nomem3;\r\n}\r\nswitch (chip_id) {\r\ncase DOC_CHIPID_G3:\r\ndoc_info("Found a G3 DiskOnChip at addr %p, floor %d\n",\r\ndocg3->cascade->base, floor);\r\nbreak;\r\ndefault:\r\ndoc_err("Chip id %04x is not a DiskOnChip G3 chip\n", chip_id);\r\ngoto nomem3;\r\n}\r\ndoc_set_driver_info(chip_id, mtd);\r\ndoc_hamming_ecc_init(docg3, DOC_LAYOUT_OOB_PAGEINFO_SZ);\r\ndoc_reload_bbt(docg3);\r\nreturn mtd;\r\nnomem3:\r\nkfree(mtd);\r\nnomem2:\r\nkfree(docg3);\r\nnomem1:\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void doc_release_device(struct mtd_info *mtd)\r\n{\r\nstruct docg3 *docg3 = mtd->priv;\r\nmtd_device_unregister(mtd);\r\nkfree(docg3->bbt);\r\nkfree(docg3);\r\nkfree(mtd->name);\r\nkfree(mtd);\r\n}\r\nstatic int docg3_resume(struct platform_device *pdev)\r\n{\r\nint i;\r\nstruct docg3_cascade *cascade;\r\nstruct mtd_info **docg3_floors, *mtd;\r\nstruct docg3 *docg3;\r\ncascade = platform_get_drvdata(pdev);\r\ndocg3_floors = cascade->floors;\r\nmtd = docg3_floors[0];\r\ndocg3 = mtd->priv;\r\ndoc_dbg("docg3_resume()\n");\r\nfor (i = 0; i < 12; i++)\r\ndoc_readb(docg3, DOC_IOSPACE_IPL);\r\nreturn 0;\r\n}\r\nstatic int docg3_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nint floor, i;\r\nstruct docg3_cascade *cascade;\r\nstruct mtd_info **docg3_floors, *mtd;\r\nstruct docg3 *docg3;\r\nu8 ctrl, pwr_down;\r\ncascade = platform_get_drvdata(pdev);\r\ndocg3_floors = cascade->floors;\r\nfor (floor = 0; floor < DOC_MAX_NBFLOORS; floor++) {\r\nmtd = docg3_floors[floor];\r\nif (!mtd)\r\ncontinue;\r\ndocg3 = mtd->priv;\r\ndoc_writeb(docg3, floor, DOC_DEVICESELECT);\r\nctrl = doc_register_readb(docg3, DOC_FLASHCONTROL);\r\nctrl &= ~DOC_CTRL_VIOLATION & ~DOC_CTRL_CE;\r\ndoc_writeb(docg3, ctrl, DOC_FLASHCONTROL);\r\nfor (i = 0; i < 10; i++) {\r\nusleep_range(3000, 4000);\r\npwr_down = doc_register_readb(docg3, DOC_POWERMODE);\r\nif (pwr_down & DOC_POWERDOWN_READY)\r\nbreak;\r\n}\r\nif (pwr_down & DOC_POWERDOWN_READY) {\r\ndoc_dbg("docg3_suspend(): floor %d powerdown ok\n",\r\nfloor);\r\n} else {\r\ndoc_err("docg3_suspend(): floor %d powerdown failed\n",\r\nfloor);\r\nreturn -EIO;\r\n}\r\n}\r\nmtd = docg3_floors[0];\r\ndocg3 = mtd->priv;\r\ndoc_set_asic_mode(docg3, DOC_ASICMODE_POWERDOWN);\r\nreturn 0;\r\n}\r\nstatic int __init docg3_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mtd_info *mtd;\r\nstruct resource *ress;\r\nvoid __iomem *base;\r\nint ret, floor, found = 0;\r\nstruct docg3_cascade *cascade;\r\nret = -ENXIO;\r\nress = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!ress) {\r\ndev_err(dev, "No I/O memory resource defined\n");\r\ngoto noress;\r\n}\r\nbase = ioremap(ress->start, DOC_IOSPACE_SIZE);\r\nret = -ENOMEM;\r\ncascade = kzalloc(sizeof(*cascade) * DOC_MAX_NBFLOORS,\r\nGFP_KERNEL);\r\nif (!cascade)\r\ngoto nomem1;\r\ncascade->base = base;\r\nmutex_init(&cascade->lock);\r\ncascade->bch = init_bch(DOC_ECC_BCH_M, DOC_ECC_BCH_T,\r\nDOC_ECC_BCH_PRIMPOLY);\r\nif (!cascade->bch)\r\ngoto nomem2;\r\nfor (floor = 0; floor < DOC_MAX_NBFLOORS; floor++) {\r\nmtd = doc_probe_device(cascade, floor, dev);\r\nif (IS_ERR(mtd)) {\r\nret = PTR_ERR(mtd);\r\ngoto err_probe;\r\n}\r\nif (!mtd) {\r\nif (floor == 0)\r\ngoto notfound;\r\nelse\r\ncontinue;\r\n}\r\ncascade->floors[floor] = mtd;\r\nret = mtd_device_parse_register(mtd, part_probes, NULL, NULL,\r\n0);\r\nif (ret)\r\ngoto err_probe;\r\nfound++;\r\n}\r\nret = doc_register_sysfs(pdev, cascade);\r\nif (ret)\r\ngoto err_probe;\r\nif (!found)\r\ngoto notfound;\r\nplatform_set_drvdata(pdev, cascade);\r\ndoc_dbg_register(cascade->floors[0]->priv);\r\nreturn 0;\r\nnotfound:\r\nret = -ENODEV;\r\ndev_info(dev, "No supported DiskOnChip found\n");\r\nerr_probe:\r\nkfree(cascade->bch);\r\nfor (floor = 0; floor < DOC_MAX_NBFLOORS; floor++)\r\nif (cascade->floors[floor])\r\ndoc_release_device(cascade->floors[floor]);\r\nnomem2:\r\nkfree(cascade);\r\nnomem1:\r\niounmap(base);\r\nnoress:\r\nreturn ret;\r\n}\r\nstatic int __exit docg3_release(struct platform_device *pdev)\r\n{\r\nstruct docg3_cascade *cascade = platform_get_drvdata(pdev);\r\nstruct docg3 *docg3 = cascade->floors[0]->priv;\r\nvoid __iomem *base = cascade->base;\r\nint floor;\r\ndoc_unregister_sysfs(pdev, cascade);\r\ndoc_dbg_unregister(docg3);\r\nfor (floor = 0; floor < DOC_MAX_NBFLOORS; floor++)\r\nif (cascade->floors[floor])\r\ndoc_release_device(cascade->floors[floor]);\r\nfree_bch(docg3->cascade->bch);\r\nkfree(cascade);\r\niounmap(base);\r\nreturn 0;\r\n}
