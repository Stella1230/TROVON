static acpi_status\r\nacpi_tb_check_xsdt(acpi_physical_address address)\r\n{\r\nstruct acpi_table_header *table;\r\nu32 length;\r\nu64 xsdt_entry_address;\r\nu8 *table_entry;\r\nu32 table_count;\r\nint i;\r\ntable = acpi_os_map_memory(address, sizeof(struct acpi_table_header));\r\nif (!table)\r\nreturn AE_NO_MEMORY;\r\nlength = table->length;\r\nacpi_os_unmap_memory(table, sizeof(struct acpi_table_header));\r\nif (length < sizeof(struct acpi_table_header))\r\nreturn AE_INVALID_TABLE_LENGTH;\r\ntable = acpi_os_map_memory(address, length);\r\nif (!table)\r\nreturn AE_NO_MEMORY;\r\ntable_count =\r\n(u32) ((table->length -\r\nsizeof(struct acpi_table_header)) / sizeof(u64));\r\ntable_entry =\r\nACPI_CAST_PTR(u8, table) + sizeof(struct acpi_table_header);\r\nfor (i = 0; i < table_count; i++) {\r\nACPI_MOVE_64_TO_64(&xsdt_entry_address, table_entry);\r\nif (!xsdt_entry_address) {\r\nbreak;\r\n}\r\ntable_entry += sizeof(u64);\r\n}\r\nacpi_os_unmap_memory(table, length);\r\nif (i < table_count)\r\nreturn AE_NULL_ENTRY;\r\nelse\r\nreturn AE_OK;\r\n}\r\nacpi_status acpi_tb_initialize_facs(void)\r\n{\r\nacpi_status status;\r\nif (acpi_gbl_reduced_hardware) {\r\nacpi_gbl_FACS = NULL;\r\nreturn (AE_OK);\r\n}\r\nstatus = acpi_get_table_by_index(ACPI_TABLE_INDEX_FACS,\r\nACPI_CAST_INDIRECT_PTR(struct\r\nacpi_table_header,\r\n&acpi_gbl_FACS));\r\nreturn (status);\r\n}\r\nu8 acpi_tb_tables_loaded(void)\r\n{\r\nif (acpi_gbl_root_table_list.current_table_count >= 3) {\r\nreturn (TRUE);\r\n}\r\nreturn (FALSE);\r\n}\r\nvoid acpi_tb_check_dsdt_header(void)\r\n{\r\nif (acpi_gbl_original_dsdt_header.length != acpi_gbl_DSDT->length ||\r\nacpi_gbl_original_dsdt_header.checksum != acpi_gbl_DSDT->checksum) {\r\nACPI_BIOS_ERROR((AE_INFO,\r\n"The DSDT has been corrupted or replaced - "\r\n"old, new headers below"));\r\nacpi_tb_print_table_header(0, &acpi_gbl_original_dsdt_header);\r\nacpi_tb_print_table_header(0, acpi_gbl_DSDT);\r\nACPI_ERROR((AE_INFO,\r\n"Please send DMI info to linux-acpi@vger.kernel.org\n"\r\n"If system does not work as expected, please boot with acpi=copy_dsdt"));\r\nacpi_gbl_original_dsdt_header.length = acpi_gbl_DSDT->length;\r\nacpi_gbl_original_dsdt_header.checksum =\r\nacpi_gbl_DSDT->checksum;\r\n}\r\n}\r\nstruct acpi_table_header *acpi_tb_copy_dsdt(u32 table_index)\r\n{\r\nstruct acpi_table_header *new_table;\r\nstruct acpi_table_desc *table_desc;\r\ntable_desc = &acpi_gbl_root_table_list.tables[table_index];\r\nnew_table = ACPI_ALLOCATE(table_desc->length);\r\nif (!new_table) {\r\nACPI_ERROR((AE_INFO, "Could not copy DSDT of length 0x%X",\r\ntable_desc->length));\r\nreturn (NULL);\r\n}\r\nACPI_MEMCPY(new_table, table_desc->pointer, table_desc->length);\r\nacpi_tb_delete_table(table_desc);\r\ntable_desc->pointer = new_table;\r\ntable_desc->flags = ACPI_TABLE_ORIGIN_ALLOCATED;\r\nACPI_INFO((AE_INFO,\r\n"Forced DSDT copy: length 0x%05X copied locally, original unmapped",\r\nnew_table->length));\r\nreturn (new_table);\r\n}\r\nvoid\r\nacpi_tb_install_table(acpi_physical_address address,\r\nchar *signature, u32 table_index)\r\n{\r\nstruct acpi_table_header *table;\r\nstruct acpi_table_header *final_table;\r\nstruct acpi_table_desc *table_desc;\r\nif (!address) {\r\nACPI_ERROR((AE_INFO,\r\n"Null physical address for ACPI table [%s]",\r\nsignature));\r\nreturn;\r\n}\r\ntable = acpi_os_map_memory(address, sizeof(struct acpi_table_header));\r\nif (!table) {\r\nACPI_ERROR((AE_INFO,\r\n"Could not map memory for table [%s] at %p",\r\nsignature, ACPI_CAST_PTR(void, address)));\r\nreturn;\r\n}\r\nif (signature && !ACPI_COMPARE_NAME(table->signature, signature)) {\r\nACPI_BIOS_ERROR((AE_INFO,\r\n"Invalid signature 0x%X for ACPI table, expected [%s]",\r\n*ACPI_CAST_PTR(u32, table->signature),\r\nsignature));\r\ngoto unmap_and_exit;\r\n}\r\ntable_desc = &acpi_gbl_root_table_list.tables[table_index];\r\ntable_desc->address = address;\r\ntable_desc->pointer = NULL;\r\ntable_desc->length = table->length;\r\ntable_desc->flags = ACPI_TABLE_ORIGIN_MAPPED;\r\nACPI_MOVE_32_TO_32(table_desc->signature.ascii, table->signature);\r\nfinal_table = acpi_tb_table_override(table, table_desc);\r\nif (!final_table) {\r\nfinal_table = table;\r\n}\r\nacpi_tb_print_table_header(table_desc->address, final_table);\r\nif (table_index == ACPI_TABLE_INDEX_DSDT) {\r\nacpi_ut_set_integer_width(final_table->revision);\r\n}\r\nif (final_table != table) {\r\nacpi_tb_delete_table(table_desc);\r\n}\r\nunmap_and_exit:\r\nacpi_os_unmap_memory(table, sizeof(struct acpi_table_header));\r\n}\r\nstatic acpi_physical_address\r\nacpi_tb_get_root_table_entry(u8 *table_entry, u32 table_entry_size)\r\n{\r\nu64 address64;\r\nif (table_entry_size == sizeof(u32)) {\r\nreturn ((acpi_physical_address)\r\n(*ACPI_CAST_PTR(u32, table_entry)));\r\n} else {\r\nACPI_MOVE_64_TO_64(&address64, table_entry);\r\n#if ACPI_MACHINE_WIDTH == 32\r\nif (address64 > ACPI_UINT32_MAX) {\r\nACPI_BIOS_WARNING((AE_INFO,\r\n"64-bit Physical Address in XSDT is too large (0x%8.8X%8.8X),"\r\n" truncating",\r\nACPI_FORMAT_UINT64(address64)));\r\n}\r\n#endif\r\nreturn ((acpi_physical_address) (address64));\r\n}\r\n}\r\nacpi_status __init\r\nacpi_tb_parse_root_table(acpi_physical_address rsdp_address)\r\n{\r\nstruct acpi_table_rsdp *rsdp;\r\nu32 table_entry_size;\r\nu32 i;\r\nu32 table_count;\r\nstruct acpi_table_header *table;\r\nacpi_physical_address address;\r\nacpi_physical_address uninitialized_var(rsdt_address);\r\nu32 length;\r\nu8 *table_entry;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(tb_parse_root_table);\r\nrsdp = acpi_os_map_memory(rsdp_address, sizeof(struct acpi_table_rsdp));\r\nif (!rsdp) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nacpi_tb_print_table_header(rsdp_address,\r\nACPI_CAST_PTR(struct acpi_table_header,\r\nrsdp));\r\nif (rsdp->revision > 1 && rsdp->xsdt_physical_address\r\n&& !acpi_rsdt_forced) {\r\naddress = (acpi_physical_address) rsdp->xsdt_physical_address;\r\ntable_entry_size = sizeof(u64);\r\nrsdt_address = (acpi_physical_address)\r\nrsdp->rsdt_physical_address;\r\n} else {\r\naddress = (acpi_physical_address) rsdp->rsdt_physical_address;\r\ntable_entry_size = sizeof(u32);\r\n}\r\nacpi_os_unmap_memory(rsdp, sizeof(struct acpi_table_rsdp));\r\nif (table_entry_size == sizeof(u64)) {\r\nif (acpi_tb_check_xsdt(address) == AE_NULL_ENTRY) {\r\naddress = rsdt_address;\r\ntable_entry_size = sizeof(u32);\r\nACPI_WARNING((AE_INFO, "BIOS XSDT has NULL entry, "\r\n"using RSDT"));\r\n}\r\n}\r\ntable = acpi_os_map_memory(address, sizeof(struct acpi_table_header));\r\nif (!table) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nacpi_tb_print_table_header(address, table);\r\nlength = table->length;\r\nacpi_os_unmap_memory(table, sizeof(struct acpi_table_header));\r\nif (length < sizeof(struct acpi_table_header)) {\r\nACPI_BIOS_ERROR((AE_INFO,\r\n"Invalid table length 0x%X in RSDT/XSDT",\r\nlength));\r\nreturn_ACPI_STATUS(AE_INVALID_TABLE_LENGTH);\r\n}\r\ntable = acpi_os_map_memory(address, length);\r\nif (!table) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nstatus = acpi_tb_verify_checksum(table, length);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_unmap_memory(table, length);\r\nreturn_ACPI_STATUS(status);\r\n}\r\ntable_count = (u32)((table->length - sizeof(struct acpi_table_header)) /\r\ntable_entry_size);\r\ntable_entry =\r\nACPI_CAST_PTR(u8, table) + sizeof(struct acpi_table_header);\r\nacpi_gbl_root_table_list.current_table_count = 2;\r\nfor (i = 0; i < table_count; i++) {\r\nif (acpi_gbl_root_table_list.current_table_count >=\r\nacpi_gbl_root_table_list.max_table_count) {\r\nstatus = acpi_tb_resize_root_table_list();\r\nif (ACPI_FAILURE(status)) {\r\nACPI_WARNING((AE_INFO,\r\n"Truncating %u table entries!",\r\n(unsigned) (table_count -\r\n(acpi_gbl_root_table_list.\r\ncurrent_table_count -\r\n2))));\r\nbreak;\r\n}\r\n}\r\nacpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.\r\ncurrent_table_count].address =\r\nacpi_tb_get_root_table_entry(table_entry, table_entry_size);\r\ntable_entry += table_entry_size;\r\nacpi_gbl_root_table_list.current_table_count++;\r\n}\r\nacpi_os_unmap_memory(table, length);\r\nfor (i = 2; i < acpi_gbl_root_table_list.current_table_count; i++) {\r\nacpi_tb_install_table(acpi_gbl_root_table_list.tables[i].\r\naddress, NULL, i);\r\nif (ACPI_COMPARE_NAME\r\n(&acpi_gbl_root_table_list.tables[i].signature,\r\nACPI_SIG_FADT)) {\r\nacpi_tb_parse_fadt(i);\r\n}\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}
