void fsnotify_clear_marks_by_mount(struct vfsmount *mnt)\r\n{\r\nstruct fsnotify_mark *mark, *lmark;\r\nstruct hlist_node *n;\r\nstruct mount *m = real_mount(mnt);\r\nLIST_HEAD(free_list);\r\nspin_lock(&mnt->mnt_root->d_lock);\r\nhlist_for_each_entry_safe(mark, n, &m->mnt_fsnotify_marks, m.m_list) {\r\nlist_add(&mark->m.free_m_list, &free_list);\r\nhlist_del_init_rcu(&mark->m.m_list);\r\nfsnotify_get_mark(mark);\r\n}\r\nspin_unlock(&mnt->mnt_root->d_lock);\r\nlist_for_each_entry_safe(mark, lmark, &free_list, m.free_m_list) {\r\nstruct fsnotify_group *group;\r\nspin_lock(&mark->lock);\r\nfsnotify_get_group(mark->group);\r\ngroup = mark->group;\r\nspin_unlock(&mark->lock);\r\nfsnotify_destroy_mark(mark, group);\r\nfsnotify_put_mark(mark);\r\nfsnotify_put_group(group);\r\n}\r\n}\r\nvoid fsnotify_clear_vfsmount_marks_by_group(struct fsnotify_group *group)\r\n{\r\nfsnotify_clear_marks_by_group_flags(group, FSNOTIFY_MARK_FLAG_VFSMOUNT);\r\n}\r\nstatic void fsnotify_recalc_vfsmount_mask_locked(struct vfsmount *mnt)\r\n{\r\nstruct mount *m = real_mount(mnt);\r\nstruct fsnotify_mark *mark;\r\n__u32 new_mask = 0;\r\nassert_spin_locked(&mnt->mnt_root->d_lock);\r\nhlist_for_each_entry(mark, &m->mnt_fsnotify_marks, m.m_list)\r\nnew_mask |= mark->mask;\r\nm->mnt_fsnotify_mask = new_mask;\r\n}\r\nvoid fsnotify_recalc_vfsmount_mask(struct vfsmount *mnt)\r\n{\r\nspin_lock(&mnt->mnt_root->d_lock);\r\nfsnotify_recalc_vfsmount_mask_locked(mnt);\r\nspin_unlock(&mnt->mnt_root->d_lock);\r\n}\r\nvoid fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark)\r\n{\r\nstruct vfsmount *mnt = mark->m.mnt;\r\nBUG_ON(!mutex_is_locked(&mark->group->mark_mutex));\r\nassert_spin_locked(&mark->lock);\r\nspin_lock(&mnt->mnt_root->d_lock);\r\nhlist_del_init_rcu(&mark->m.m_list);\r\nmark->m.mnt = NULL;\r\nfsnotify_recalc_vfsmount_mask_locked(mnt);\r\nspin_unlock(&mnt->mnt_root->d_lock);\r\n}\r\nstatic struct fsnotify_mark *fsnotify_find_vfsmount_mark_locked(struct fsnotify_group *group,\r\nstruct vfsmount *mnt)\r\n{\r\nstruct mount *m = real_mount(mnt);\r\nstruct fsnotify_mark *mark;\r\nassert_spin_locked(&mnt->mnt_root->d_lock);\r\nhlist_for_each_entry(mark, &m->mnt_fsnotify_marks, m.m_list) {\r\nif (mark->group == group) {\r\nfsnotify_get_mark(mark);\r\nreturn mark;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstruct fsnotify_mark *fsnotify_find_vfsmount_mark(struct fsnotify_group *group,\r\nstruct vfsmount *mnt)\r\n{\r\nstruct fsnotify_mark *mark;\r\nspin_lock(&mnt->mnt_root->d_lock);\r\nmark = fsnotify_find_vfsmount_mark_locked(group, mnt);\r\nspin_unlock(&mnt->mnt_root->d_lock);\r\nreturn mark;\r\n}\r\nint fsnotify_add_vfsmount_mark(struct fsnotify_mark *mark,\r\nstruct fsnotify_group *group, struct vfsmount *mnt,\r\nint allow_dups)\r\n{\r\nstruct mount *m = real_mount(mnt);\r\nstruct fsnotify_mark *lmark, *last = NULL;\r\nint ret = 0;\r\nmark->flags |= FSNOTIFY_MARK_FLAG_VFSMOUNT;\r\nBUG_ON(!mutex_is_locked(&group->mark_mutex));\r\nassert_spin_locked(&mark->lock);\r\nspin_lock(&mnt->mnt_root->d_lock);\r\nmark->m.mnt = mnt;\r\nif (hlist_empty(&m->mnt_fsnotify_marks)) {\r\nhlist_add_head_rcu(&mark->m.m_list, &m->mnt_fsnotify_marks);\r\ngoto out;\r\n}\r\nhlist_for_each_entry(lmark, &m->mnt_fsnotify_marks, m.m_list) {\r\nlast = lmark;\r\nif ((lmark->group == group) && !allow_dups) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\nif (mark->group->priority < lmark->group->priority)\r\ncontinue;\r\nif ((mark->group->priority == lmark->group->priority) &&\r\n(mark->group < lmark->group))\r\ncontinue;\r\nhlist_add_before_rcu(&mark->m.m_list, &lmark->m.m_list);\r\ngoto out;\r\n}\r\nBUG_ON(last == NULL);\r\nhlist_add_after_rcu(&last->m.m_list, &mark->m.m_list);\r\nout:\r\nfsnotify_recalc_vfsmount_mask_locked(mnt);\r\nspin_unlock(&mnt->mnt_root->d_lock);\r\nreturn ret;\r\n}
