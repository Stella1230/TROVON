static unsigned int vmci_resource_hash(struct vmci_handle handle)\r\n{\r\nreturn hash_32(handle.resource, VMCI_RESOURCE_HASH_BITS);\r\n}\r\nstatic struct vmci_resource *vmci_resource_lookup(struct vmci_handle handle,\r\nenum vmci_resource_type type)\r\n{\r\nstruct vmci_resource *r, *resource = NULL;\r\nunsigned int idx = vmci_resource_hash(handle);\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(r,\r\n&vmci_resource_table.entries[idx], node) {\r\nu32 cid = r->handle.context;\r\nu32 rid = r->handle.resource;\r\nif (r->type == type &&\r\nrid == handle.resource &&\r\n(cid == handle.context || cid == VMCI_INVALID_ID)) {\r\nresource = r;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn resource;\r\n}\r\nstatic u32 vmci_resource_find_id(u32 context_id,\r\nenum vmci_resource_type resource_type)\r\n{\r\nstatic u32 resource_id = VMCI_RESERVED_RESOURCE_ID_MAX + 1;\r\nu32 old_rid = resource_id;\r\nu32 current_rid;\r\ndo {\r\nstruct vmci_handle handle;\r\ncurrent_rid = resource_id;\r\nresource_id++;\r\nif (unlikely(resource_id == VMCI_INVALID_ID)) {\r\nresource_id = VMCI_RESERVED_RESOURCE_ID_MAX + 1;\r\n}\r\nhandle = vmci_make_handle(context_id, current_rid);\r\nif (!vmci_resource_lookup(handle, resource_type))\r\nreturn current_rid;\r\n} while (resource_id != old_rid);\r\nreturn VMCI_INVALID_ID;\r\n}\r\nint vmci_resource_add(struct vmci_resource *resource,\r\nenum vmci_resource_type resource_type,\r\nstruct vmci_handle handle)\r\n{\r\nunsigned int idx;\r\nint result;\r\nspin_lock(&vmci_resource_table.lock);\r\nif (handle.resource == VMCI_INVALID_ID) {\r\nhandle.resource = vmci_resource_find_id(handle.context,\r\nresource_type);\r\nif (handle.resource == VMCI_INVALID_ID) {\r\nresult = VMCI_ERROR_NO_HANDLE;\r\ngoto out;\r\n}\r\n} else if (vmci_resource_lookup(handle, resource_type)) {\r\nresult = VMCI_ERROR_ALREADY_EXISTS;\r\ngoto out;\r\n}\r\nresource->handle = handle;\r\nresource->type = resource_type;\r\nINIT_HLIST_NODE(&resource->node);\r\nkref_init(&resource->kref);\r\ninit_completion(&resource->done);\r\nidx = vmci_resource_hash(resource->handle);\r\nhlist_add_head_rcu(&resource->node, &vmci_resource_table.entries[idx]);\r\nresult = VMCI_SUCCESS;\r\nout:\r\nspin_unlock(&vmci_resource_table.lock);\r\nreturn result;\r\n}\r\nvoid vmci_resource_remove(struct vmci_resource *resource)\r\n{\r\nstruct vmci_handle handle = resource->handle;\r\nunsigned int idx = vmci_resource_hash(handle);\r\nstruct vmci_resource *r;\r\nspin_lock(&vmci_resource_table.lock);\r\nhlist_for_each_entry(r, &vmci_resource_table.entries[idx], node) {\r\nif (vmci_handle_is_equal(r->handle, resource->handle)) {\r\nhlist_del_init_rcu(&r->node);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&vmci_resource_table.lock);\r\nsynchronize_rcu();\r\nvmci_resource_put(resource);\r\nwait_for_completion(&resource->done);\r\n}\r\nstruct vmci_resource *\r\nvmci_resource_by_handle(struct vmci_handle resource_handle,\r\nenum vmci_resource_type resource_type)\r\n{\r\nstruct vmci_resource *r, *resource = NULL;\r\nrcu_read_lock();\r\nr = vmci_resource_lookup(resource_handle, resource_type);\r\nif (r &&\r\n(resource_type == r->type ||\r\nresource_type == VMCI_RESOURCE_TYPE_ANY)) {\r\nresource = vmci_resource_get(r);\r\n}\r\nrcu_read_unlock();\r\nreturn resource;\r\n}\r\nstruct vmci_resource *vmci_resource_get(struct vmci_resource *resource)\r\n{\r\nkref_get(&resource->kref);\r\nreturn resource;\r\n}\r\nstatic void vmci_release_resource(struct kref *kref)\r\n{\r\nstruct vmci_resource *resource =\r\ncontainer_of(kref, struct vmci_resource, kref);\r\nWARN_ON(!hlist_unhashed(&resource->node));\r\ncomplete(&resource->done);\r\n}\r\nint vmci_resource_put(struct vmci_resource *resource)\r\n{\r\nreturn kref_put(&resource->kref, vmci_release_resource) ?\r\nVMCI_SUCCESS_ENTRY_DEAD : VMCI_SUCCESS;\r\n}\r\nstruct vmci_handle vmci_resource_handle(struct vmci_resource *resource)\r\n{\r\nreturn resource->handle;\r\n}
