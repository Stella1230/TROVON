static inline bool sdhci_acpi_flag(struct sdhci_acpi_host *c, unsigned int flag)\r\n{\r\nreturn c->slot && (c->slot->flags & flag);\r\n}\r\nstatic int sdhci_acpi_enable_dma(struct sdhci_host *host)\r\n{\r\nreturn 0;\r\n}\r\nstatic void sdhci_acpi_int_hw_reset(struct sdhci_host *host)\r\n{\r\nu8 reg;\r\nreg = sdhci_readb(host, SDHCI_POWER_CONTROL);\r\nreg |= 0x10;\r\nsdhci_writeb(host, reg, SDHCI_POWER_CONTROL);\r\nudelay(9);\r\nreg &= ~0x10;\r\nsdhci_writeb(host, reg, SDHCI_POWER_CONTROL);\r\nusleep_range(300, 1000);\r\n}\r\nstatic const struct sdhci_acpi_slot *sdhci_acpi_get_slot_by_ids(const char *hid,\r\nconst char *uid)\r\n{\r\nconst struct sdhci_acpi_uid_slot *u;\r\nfor (u = sdhci_acpi_uids; u->hid; u++) {\r\nif (strcmp(u->hid, hid))\r\ncontinue;\r\nif (!u->uid)\r\nreturn u->slot;\r\nif (uid && !strcmp(u->uid, uid))\r\nreturn u->slot;\r\n}\r\nreturn NULL;\r\n}\r\nstatic const struct sdhci_acpi_slot *sdhci_acpi_get_slot(acpi_handle handle,\r\nconst char *hid)\r\n{\r\nconst struct sdhci_acpi_slot *slot;\r\nstruct acpi_device_info *info;\r\nconst char *uid = NULL;\r\nacpi_status status;\r\nstatus = acpi_get_object_info(handle, &info);\r\nif (!ACPI_FAILURE(status) && (info->valid & ACPI_VALID_UID))\r\nuid = info->unique_id.string;\r\nslot = sdhci_acpi_get_slot_by_ids(hid, uid);\r\nkfree(info);\r\nreturn slot;\r\n}\r\nstatic irqreturn_t sdhci_acpi_sd_cd(int irq, void *dev_id)\r\n{\r\nmmc_detect_change(dev_id, msecs_to_jiffies(200));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sdhci_acpi_add_own_cd(struct device *dev, int gpio,\r\nstruct mmc_host *mmc)\r\n{\r\nunsigned long flags;\r\nint err, irq;\r\nif (gpio < 0) {\r\nerr = gpio;\r\ngoto out;\r\n}\r\nerr = devm_gpio_request_one(dev, gpio, GPIOF_DIR_IN, "sd_cd");\r\nif (err)\r\ngoto out;\r\nirq = gpio_to_irq(gpio);\r\nif (irq < 0) {\r\nerr = irq;\r\ngoto out_free;\r\n}\r\nflags = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING;\r\nerr = devm_request_irq(dev, irq, sdhci_acpi_sd_cd, flags, "sd_cd", mmc);\r\nif (err)\r\ngoto out_free;\r\nreturn 0;\r\nout_free:\r\ndevm_gpio_free(dev, gpio);\r\nout:\r\ndev_warn(dev, "failed to setup card detect wake up\n");\r\nreturn err;\r\n}\r\nstatic int sdhci_acpi_add_own_cd(struct device *dev, int gpio,\r\nstruct mmc_host *mmc)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sdhci_acpi_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nacpi_handle handle = ACPI_HANDLE(dev);\r\nstruct acpi_device *device;\r\nstruct sdhci_acpi_host *c;\r\nstruct sdhci_host *host;\r\nstruct resource *iomem;\r\nresource_size_t len;\r\nconst char *hid;\r\nint err, gpio;\r\nif (acpi_bus_get_device(handle, &device))\r\nreturn -ENODEV;\r\nif (acpi_bus_get_status(device) || !device->status.present)\r\nreturn -ENODEV;\r\nhid = acpi_device_hid(device);\r\niomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!iomem)\r\nreturn -ENOMEM;\r\nlen = resource_size(iomem);\r\nif (len < 0x100)\r\ndev_err(dev, "Invalid iomem size!\n");\r\nif (!devm_request_mem_region(dev, iomem->start, len, dev_name(dev)))\r\nreturn -ENOMEM;\r\nhost = sdhci_alloc_host(dev, sizeof(struct sdhci_acpi_host));\r\nif (IS_ERR(host))\r\nreturn PTR_ERR(host);\r\ngpio = acpi_get_gpio_by_index(dev, 0, NULL);\r\nc = sdhci_priv(host);\r\nc->host = host;\r\nc->slot = sdhci_acpi_get_slot(handle, hid);\r\nc->pdev = pdev;\r\nc->use_runtime_pm = sdhci_acpi_flag(c, SDHCI_ACPI_RUNTIME_PM);\r\nplatform_set_drvdata(pdev, c);\r\nhost->hw_name = "ACPI";\r\nhost->ops = &sdhci_acpi_ops_dflt;\r\nhost->irq = platform_get_irq(pdev, 0);\r\nhost->ioaddr = devm_ioremap_nocache(dev, iomem->start,\r\nresource_size(iomem));\r\nif (host->ioaddr == NULL) {\r\nerr = -ENOMEM;\r\ngoto err_free;\r\n}\r\nif (!dev->dma_mask) {\r\nu64 dma_mask;\r\nif (sdhci_readl(host, SDHCI_CAPABILITIES) & SDHCI_CAN_64BIT) {\r\ndma_mask = DMA_BIT_MASK(32);\r\n} else {\r\ndma_mask = DMA_BIT_MASK(32);\r\n}\r\ndev->dma_mask = &dev->coherent_dma_mask;\r\ndev->coherent_dma_mask = dma_mask;\r\n}\r\nif (c->slot) {\r\nif (c->slot->chip) {\r\nhost->ops = c->slot->chip->ops;\r\nhost->quirks |= c->slot->chip->quirks;\r\nhost->quirks2 |= c->slot->chip->quirks2;\r\nhost->mmc->caps |= c->slot->chip->caps;\r\nhost->mmc->caps2 |= c->slot->chip->caps2;\r\nhost->mmc->pm_caps |= c->slot->chip->pm_caps;\r\n}\r\nhost->quirks |= c->slot->quirks;\r\nhost->quirks2 |= c->slot->quirks2;\r\nhost->mmc->caps |= c->slot->caps;\r\nhost->mmc->caps2 |= c->slot->caps2;\r\nhost->mmc->pm_caps |= c->slot->pm_caps;\r\n}\r\nhost->mmc->caps2 |= MMC_CAP2_NO_PRESCAN_POWERUP;\r\nerr = sdhci_add_host(host);\r\nif (err)\r\ngoto err_free;\r\nif (sdhci_acpi_flag(c, SDHCI_ACPI_SD_CD)) {\r\nif (sdhci_acpi_add_own_cd(dev, gpio, host->mmc))\r\nc->use_runtime_pm = false;\r\n}\r\nif (c->use_runtime_pm) {\r\npm_runtime_set_active(dev);\r\npm_suspend_ignore_children(dev, 1);\r\npm_runtime_set_autosuspend_delay(dev, 50);\r\npm_runtime_use_autosuspend(dev);\r\npm_runtime_enable(dev);\r\n}\r\nreturn 0;\r\nerr_free:\r\nsdhci_free_host(c->host);\r\nreturn err;\r\n}\r\nstatic int sdhci_acpi_remove(struct platform_device *pdev)\r\n{\r\nstruct sdhci_acpi_host *c = platform_get_drvdata(pdev);\r\nstruct device *dev = &pdev->dev;\r\nint dead;\r\nif (c->use_runtime_pm) {\r\npm_runtime_get_sync(dev);\r\npm_runtime_disable(dev);\r\npm_runtime_put_noidle(dev);\r\n}\r\ndead = (sdhci_readl(c->host, SDHCI_INT_STATUS) == ~0);\r\nsdhci_remove_host(c->host, dead);\r\nsdhci_free_host(c->host);\r\nreturn 0;\r\n}\r\nstatic int sdhci_acpi_suspend(struct device *dev)\r\n{\r\nstruct sdhci_acpi_host *c = dev_get_drvdata(dev);\r\nreturn sdhci_suspend_host(c->host);\r\n}\r\nstatic int sdhci_acpi_resume(struct device *dev)\r\n{\r\nstruct sdhci_acpi_host *c = dev_get_drvdata(dev);\r\nreturn sdhci_resume_host(c->host);\r\n}\r\nstatic int sdhci_acpi_runtime_suspend(struct device *dev)\r\n{\r\nstruct sdhci_acpi_host *c = dev_get_drvdata(dev);\r\nreturn sdhci_runtime_suspend_host(c->host);\r\n}\r\nstatic int sdhci_acpi_runtime_resume(struct device *dev)\r\n{\r\nstruct sdhci_acpi_host *c = dev_get_drvdata(dev);\r\nreturn sdhci_runtime_resume_host(c->host);\r\n}\r\nstatic int sdhci_acpi_runtime_idle(struct device *dev)\r\n{\r\nreturn 0;\r\n}
