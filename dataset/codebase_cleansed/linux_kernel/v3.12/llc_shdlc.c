static bool llc_shdlc_x_lt_y_lteq_z(int x, int y, int z)\r\n{\r\nif (x < z)\r\nreturn ((x < y) && (y <= z)) ? true : false;\r\nelse\r\nreturn ((y > x) || (y <= z)) ? true : false;\r\n}\r\nstatic bool llc_shdlc_x_lteq_y_lt_z(int x, int y, int z)\r\n{\r\nif (x <= z)\r\nreturn ((x <= y) && (y < z)) ? true : false;\r\nelse\r\nreturn ((y >= x) || (y < z)) ? true : false;\r\n}\r\nstatic struct sk_buff *llc_shdlc_alloc_skb(struct llc_shdlc *shdlc,\r\nint payload_len)\r\n{\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(shdlc->tx_headroom + SHDLC_LLC_HEAD_ROOM +\r\nshdlc->tx_tailroom + payload_len, GFP_KERNEL);\r\nif (skb)\r\nskb_reserve(skb, shdlc->tx_headroom + SHDLC_LLC_HEAD_ROOM);\r\nreturn skb;\r\n}\r\nstatic int llc_shdlc_send_s_frame(struct llc_shdlc *shdlc,\r\nenum sframe_type sframe_type, int nr)\r\n{\r\nint r;\r\nstruct sk_buff *skb;\r\npr_debug("sframe_type=%d nr=%d\n", sframe_type, nr);\r\nskb = llc_shdlc_alloc_skb(shdlc, 0);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\n*skb_push(skb, 1) = SHDLC_CONTROL_HEAD_S | (sframe_type << 3) | nr;\r\nr = shdlc->xmit_to_drv(shdlc->hdev, skb);\r\nkfree_skb(skb);\r\nreturn r;\r\n}\r\nstatic int llc_shdlc_send_u_frame(struct llc_shdlc *shdlc,\r\nstruct sk_buff *skb,\r\nenum uframe_modifier uframe_modifier)\r\n{\r\nint r;\r\npr_debug("uframe_modifier=%d\n", uframe_modifier);\r\n*skb_push(skb, 1) = SHDLC_CONTROL_HEAD_U | uframe_modifier;\r\nr = shdlc->xmit_to_drv(shdlc->hdev, skb);\r\nkfree_skb(skb);\r\nreturn r;\r\n}\r\nstatic void llc_shdlc_reset_t2(struct llc_shdlc *shdlc, int y_nr)\r\n{\r\nstruct sk_buff *skb;\r\nint dnr = shdlc->dnr;\r\npr_debug("release ack pending up to frame %d excluded\n", y_nr);\r\nwhile (dnr != y_nr) {\r\npr_debug("release ack pending frame %d\n", dnr);\r\nskb = skb_dequeue(&shdlc->ack_pending_q);\r\nkfree_skb(skb);\r\ndnr = (dnr + 1) % 8;\r\n}\r\nif (skb_queue_empty(&shdlc->ack_pending_q)) {\r\nif (shdlc->t2_active) {\r\ndel_timer_sync(&shdlc->t2_timer);\r\nshdlc->t2_active = false;\r\npr_debug\r\n("All sent frames acked. Stopped T2(retransmit)\n");\r\n}\r\n} else {\r\nskb = skb_peek(&shdlc->ack_pending_q);\r\nmod_timer(&shdlc->t2_timer, *(unsigned long *)skb->cb +\r\nmsecs_to_jiffies(SHDLC_T2_VALUE_MS));\r\nshdlc->t2_active = true;\r\npr_debug\r\n("Start T2(retransmit) for remaining unacked sent frames\n");\r\n}\r\n}\r\nstatic void llc_shdlc_rcv_i_frame(struct llc_shdlc *shdlc,\r\nstruct sk_buff *skb, int ns, int nr)\r\n{\r\nint x_ns = ns;\r\nint y_nr = nr;\r\npr_debug("recvd I-frame %d, remote waiting frame %d\n", ns, nr);\r\nif (shdlc->state != SHDLC_CONNECTED)\r\ngoto exit;\r\nif (x_ns != shdlc->nr) {\r\nllc_shdlc_send_s_frame(shdlc, S_FRAME_REJ, shdlc->nr);\r\ngoto exit;\r\n}\r\nif (shdlc->t1_active == false) {\r\nshdlc->t1_active = true;\r\nmod_timer(&shdlc->t1_timer, jiffies +\r\nmsecs_to_jiffies(SHDLC_T1_VALUE_MS(shdlc->w)));\r\npr_debug("(re)Start T1(send ack)\n");\r\n}\r\nif (skb->len) {\r\nshdlc->rcv_to_hci(shdlc->hdev, skb);\r\nskb = NULL;\r\n}\r\nshdlc->nr = (shdlc->nr + 1) % 8;\r\nif (llc_shdlc_x_lt_y_lteq_z(shdlc->dnr, y_nr, shdlc->ns)) {\r\nllc_shdlc_reset_t2(shdlc, y_nr);\r\nshdlc->dnr = y_nr;\r\n}\r\nexit:\r\nkfree_skb(skb);\r\n}\r\nstatic void llc_shdlc_rcv_ack(struct llc_shdlc *shdlc, int y_nr)\r\n{\r\npr_debug("remote acked up to frame %d excluded\n", y_nr);\r\nif (llc_shdlc_x_lt_y_lteq_z(shdlc->dnr, y_nr, shdlc->ns)) {\r\nllc_shdlc_reset_t2(shdlc, y_nr);\r\nshdlc->dnr = y_nr;\r\n}\r\n}\r\nstatic void llc_shdlc_requeue_ack_pending(struct llc_shdlc *shdlc)\r\n{\r\nstruct sk_buff *skb;\r\npr_debug("ns reset to %d\n", shdlc->dnr);\r\nwhile ((skb = skb_dequeue_tail(&shdlc->ack_pending_q))) {\r\nskb_pull(skb, 1);\r\nskb_queue_head(&shdlc->send_q, skb);\r\n}\r\nshdlc->ns = shdlc->dnr;\r\n}\r\nstatic void llc_shdlc_rcv_rej(struct llc_shdlc *shdlc, int y_nr)\r\n{\r\nstruct sk_buff *skb;\r\npr_debug("remote asks retransmition from frame %d\n", y_nr);\r\nif (llc_shdlc_x_lteq_y_lt_z(shdlc->dnr, y_nr, shdlc->ns)) {\r\nif (shdlc->t2_active) {\r\ndel_timer_sync(&shdlc->t2_timer);\r\nshdlc->t2_active = false;\r\npr_debug("Stopped T2(retransmit)\n");\r\n}\r\nif (shdlc->dnr != y_nr) {\r\nwhile ((shdlc->dnr = ((shdlc->dnr + 1) % 8)) != y_nr) {\r\nskb = skb_dequeue(&shdlc->ack_pending_q);\r\nkfree_skb(skb);\r\n}\r\n}\r\nllc_shdlc_requeue_ack_pending(shdlc);\r\n}\r\n}\r\nstatic void llc_shdlc_rcv_s_frame(struct llc_shdlc *shdlc,\r\nenum sframe_type s_frame_type, int nr)\r\n{\r\nstruct sk_buff *skb;\r\nif (shdlc->state != SHDLC_CONNECTED)\r\nreturn;\r\nswitch (s_frame_type) {\r\ncase S_FRAME_RR:\r\nllc_shdlc_rcv_ack(shdlc, nr);\r\nif (shdlc->rnr == true) {\r\nshdlc->rnr = false;\r\nif (shdlc->send_q.qlen == 0) {\r\nskb = llc_shdlc_alloc_skb(shdlc, 0);\r\nif (skb)\r\nskb_queue_tail(&shdlc->send_q, skb);\r\n}\r\n}\r\nbreak;\r\ncase S_FRAME_REJ:\r\nllc_shdlc_rcv_rej(shdlc, nr);\r\nbreak;\r\ncase S_FRAME_RNR:\r\nllc_shdlc_rcv_ack(shdlc, nr);\r\nshdlc->rnr = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void llc_shdlc_connect_complete(struct llc_shdlc *shdlc, int r)\r\n{\r\npr_debug("result=%d\n", r);\r\ndel_timer_sync(&shdlc->connect_timer);\r\nif (r == 0) {\r\nshdlc->ns = 0;\r\nshdlc->nr = 0;\r\nshdlc->dnr = 0;\r\nshdlc->state = SHDLC_HALF_CONNECTED;\r\n} else {\r\nshdlc->state = SHDLC_DISCONNECTED;\r\n}\r\nshdlc->connect_result = r;\r\nwake_up(shdlc->connect_wq);\r\n}\r\nstatic int llc_shdlc_connect_initiate(struct llc_shdlc *shdlc)\r\n{\r\nstruct sk_buff *skb;\r\npr_debug("\n");\r\nskb = llc_shdlc_alloc_skb(shdlc, 2);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\n*skb_put(skb, 1) = SHDLC_MAX_WINDOW;\r\n*skb_put(skb, 1) = SHDLC_SREJ_SUPPORT ? 1 : 0;\r\nreturn llc_shdlc_send_u_frame(shdlc, skb, U_FRAME_RSET);\r\n}\r\nstatic int llc_shdlc_connect_send_ua(struct llc_shdlc *shdlc)\r\n{\r\nstruct sk_buff *skb;\r\npr_debug("\n");\r\nskb = llc_shdlc_alloc_skb(shdlc, 0);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nreturn llc_shdlc_send_u_frame(shdlc, skb, U_FRAME_UA);\r\n}\r\nstatic void llc_shdlc_rcv_u_frame(struct llc_shdlc *shdlc,\r\nstruct sk_buff *skb,\r\nenum uframe_modifier u_frame_modifier)\r\n{\r\nu8 w = SHDLC_MAX_WINDOW;\r\nbool srej_support = SHDLC_SREJ_SUPPORT;\r\nint r;\r\npr_debug("u_frame_modifier=%d\n", u_frame_modifier);\r\nswitch (u_frame_modifier) {\r\ncase U_FRAME_RSET:\r\nswitch (shdlc->state) {\r\ncase SHDLC_NEGOTIATING:\r\ncase SHDLC_CONNECTING:\r\nif (skb->len > 0)\r\nw = skb->data[0];\r\nif (skb->len > 1)\r\nsrej_support = skb->data[1] & 0x01 ? true :\r\nfalse;\r\nif ((w <= SHDLC_MAX_WINDOW) &&\r\n(SHDLC_SREJ_SUPPORT || (srej_support == false))) {\r\nshdlc->w = w;\r\nshdlc->srej_support = srej_support;\r\nr = llc_shdlc_connect_send_ua(shdlc);\r\nllc_shdlc_connect_complete(shdlc, r);\r\n}\r\nbreak;\r\ncase SHDLC_HALF_CONNECTED:\r\nbreak;\r\ncase SHDLC_CONNECTED:\r\nshdlc->hard_fault = -ECONNRESET;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase U_FRAME_UA:\r\nif ((shdlc->state == SHDLC_CONNECTING &&\r\nshdlc->connect_tries > 0) ||\r\n(shdlc->state == SHDLC_NEGOTIATING)) {\r\nllc_shdlc_connect_complete(shdlc, 0);\r\nshdlc->state = SHDLC_CONNECTED;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nkfree_skb(skb);\r\n}\r\nstatic void llc_shdlc_handle_rcv_queue(struct llc_shdlc *shdlc)\r\n{\r\nstruct sk_buff *skb;\r\nu8 control;\r\nint nr;\r\nint ns;\r\nenum sframe_type s_frame_type;\r\nenum uframe_modifier u_frame_modifier;\r\nif (shdlc->rcv_q.qlen)\r\npr_debug("rcvQlen=%d\n", shdlc->rcv_q.qlen);\r\nwhile ((skb = skb_dequeue(&shdlc->rcv_q)) != NULL) {\r\ncontrol = skb->data[0];\r\nskb_pull(skb, 1);\r\nswitch (control & SHDLC_CONTROL_HEAD_MASK) {\r\ncase SHDLC_CONTROL_HEAD_I:\r\ncase SHDLC_CONTROL_HEAD_I2:\r\nif (shdlc->state == SHDLC_HALF_CONNECTED)\r\nshdlc->state = SHDLC_CONNECTED;\r\nns = (control & SHDLC_CONTROL_NS_MASK) >> 3;\r\nnr = control & SHDLC_CONTROL_NR_MASK;\r\nllc_shdlc_rcv_i_frame(shdlc, skb, ns, nr);\r\nbreak;\r\ncase SHDLC_CONTROL_HEAD_S:\r\nif (shdlc->state == SHDLC_HALF_CONNECTED)\r\nshdlc->state = SHDLC_CONNECTED;\r\ns_frame_type = (control & SHDLC_CONTROL_TYPE_MASK) >> 3;\r\nnr = control & SHDLC_CONTROL_NR_MASK;\r\nllc_shdlc_rcv_s_frame(shdlc, s_frame_type, nr);\r\nkfree_skb(skb);\r\nbreak;\r\ncase SHDLC_CONTROL_HEAD_U:\r\nu_frame_modifier = control & SHDLC_CONTROL_M_MASK;\r\nllc_shdlc_rcv_u_frame(shdlc, skb, u_frame_modifier);\r\nbreak;\r\ndefault:\r\npr_err("UNKNOWN Control=%d\n", control);\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int llc_shdlc_w_used(int ns, int dnr)\r\n{\r\nint unack_count;\r\nif (dnr <= ns)\r\nunack_count = ns - dnr;\r\nelse\r\nunack_count = 8 - dnr + ns;\r\nreturn unack_count;\r\n}\r\nstatic void llc_shdlc_handle_send_queue(struct llc_shdlc *shdlc)\r\n{\r\nstruct sk_buff *skb;\r\nint r;\r\nunsigned long time_sent;\r\nif (shdlc->send_q.qlen)\r\npr_debug\r\n("sendQlen=%d ns=%d dnr=%d rnr=%s w_room=%d unackQlen=%d\n",\r\nshdlc->send_q.qlen, shdlc->ns, shdlc->dnr,\r\nshdlc->rnr == false ? "false" : "true",\r\nshdlc->w - llc_shdlc_w_used(shdlc->ns, shdlc->dnr),\r\nshdlc->ack_pending_q.qlen);\r\nwhile (shdlc->send_q.qlen && shdlc->ack_pending_q.qlen < shdlc->w &&\r\n(shdlc->rnr == false)) {\r\nif (shdlc->t1_active) {\r\ndel_timer_sync(&shdlc->t1_timer);\r\nshdlc->t1_active = false;\r\npr_debug("Stopped T1(send ack)\n");\r\n}\r\nskb = skb_dequeue(&shdlc->send_q);\r\n*skb_push(skb, 1) = SHDLC_CONTROL_HEAD_I | (shdlc->ns << 3) |\r\nshdlc->nr;\r\npr_debug("Sending I-Frame %d, waiting to rcv %d\n", shdlc->ns,\r\nshdlc->nr);\r\nSHDLC_DUMP_SKB("shdlc frame written", skb);\r\nr = shdlc->xmit_to_drv(shdlc->hdev, skb);\r\nif (r < 0) {\r\nshdlc->hard_fault = r;\r\nbreak;\r\n}\r\nshdlc->ns = (shdlc->ns + 1) % 8;\r\ntime_sent = jiffies;\r\n*(unsigned long *)skb->cb = time_sent;\r\nskb_queue_tail(&shdlc->ack_pending_q, skb);\r\nif (shdlc->t2_active == false) {\r\nshdlc->t2_active = true;\r\nmod_timer(&shdlc->t2_timer, time_sent +\r\nmsecs_to_jiffies(SHDLC_T2_VALUE_MS));\r\npr_debug("Started T2 (retransmit)\n");\r\n}\r\n}\r\n}\r\nstatic void llc_shdlc_connect_timeout(unsigned long data)\r\n{\r\nstruct llc_shdlc *shdlc = (struct llc_shdlc *)data;\r\npr_debug("\n");\r\nschedule_work(&shdlc->sm_work);\r\n}\r\nstatic void llc_shdlc_t1_timeout(unsigned long data)\r\n{\r\nstruct llc_shdlc *shdlc = (struct llc_shdlc *)data;\r\npr_debug("SoftIRQ: need to send ack\n");\r\nschedule_work(&shdlc->sm_work);\r\n}\r\nstatic void llc_shdlc_t2_timeout(unsigned long data)\r\n{\r\nstruct llc_shdlc *shdlc = (struct llc_shdlc *)data;\r\npr_debug("SoftIRQ: need to retransmit\n");\r\nschedule_work(&shdlc->sm_work);\r\n}\r\nstatic void llc_shdlc_sm_work(struct work_struct *work)\r\n{\r\nstruct llc_shdlc *shdlc = container_of(work, struct llc_shdlc, sm_work);\r\nint r;\r\npr_debug("\n");\r\nmutex_lock(&shdlc->state_mutex);\r\nswitch (shdlc->state) {\r\ncase SHDLC_DISCONNECTED:\r\nskb_queue_purge(&shdlc->rcv_q);\r\nskb_queue_purge(&shdlc->send_q);\r\nskb_queue_purge(&shdlc->ack_pending_q);\r\nbreak;\r\ncase SHDLC_CONNECTING:\r\nif (shdlc->hard_fault) {\r\nllc_shdlc_connect_complete(shdlc, shdlc->hard_fault);\r\nbreak;\r\n}\r\nif (shdlc->connect_tries++ < 5)\r\nr = llc_shdlc_connect_initiate(shdlc);\r\nelse\r\nr = -ETIME;\r\nif (r < 0) {\r\nllc_shdlc_connect_complete(shdlc, r);\r\n} else {\r\nmod_timer(&shdlc->connect_timer, jiffies +\r\nmsecs_to_jiffies(SHDLC_CONNECT_VALUE_MS));\r\nshdlc->state = SHDLC_NEGOTIATING;\r\n}\r\nbreak;\r\ncase SHDLC_NEGOTIATING:\r\nif (timer_pending(&shdlc->connect_timer) == 0) {\r\nshdlc->state = SHDLC_CONNECTING;\r\nschedule_work(&shdlc->sm_work);\r\n}\r\nllc_shdlc_handle_rcv_queue(shdlc);\r\nif (shdlc->hard_fault) {\r\nllc_shdlc_connect_complete(shdlc, shdlc->hard_fault);\r\nbreak;\r\n}\r\nbreak;\r\ncase SHDLC_HALF_CONNECTED:\r\ncase SHDLC_CONNECTED:\r\nllc_shdlc_handle_rcv_queue(shdlc);\r\nllc_shdlc_handle_send_queue(shdlc);\r\nif (shdlc->t1_active && timer_pending(&shdlc->t1_timer) == 0) {\r\npr_debug\r\n("Handle T1(send ack) elapsed (T1 now inactive)\n");\r\nshdlc->t1_active = false;\r\nr = llc_shdlc_send_s_frame(shdlc, S_FRAME_RR,\r\nshdlc->nr);\r\nif (r < 0)\r\nshdlc->hard_fault = r;\r\n}\r\nif (shdlc->t2_active && timer_pending(&shdlc->t2_timer) == 0) {\r\npr_debug\r\n("Handle T2(retransmit) elapsed (T2 inactive)\n");\r\nshdlc->t2_active = false;\r\nllc_shdlc_requeue_ack_pending(shdlc);\r\nllc_shdlc_handle_send_queue(shdlc);\r\n}\r\nif (shdlc->hard_fault)\r\nshdlc->llc_failure(shdlc->hdev, shdlc->hard_fault);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmutex_unlock(&shdlc->state_mutex);\r\n}\r\nstatic int llc_shdlc_connect(struct llc_shdlc *shdlc)\r\n{\r\nDECLARE_WAIT_QUEUE_HEAD_ONSTACK(connect_wq);\r\npr_debug("\n");\r\nmutex_lock(&shdlc->state_mutex);\r\nshdlc->state = SHDLC_CONNECTING;\r\nshdlc->connect_wq = &connect_wq;\r\nshdlc->connect_tries = 0;\r\nshdlc->connect_result = 1;\r\nmutex_unlock(&shdlc->state_mutex);\r\nschedule_work(&shdlc->sm_work);\r\nwait_event(connect_wq, shdlc->connect_result != 1);\r\nreturn shdlc->connect_result;\r\n}\r\nstatic void llc_shdlc_disconnect(struct llc_shdlc *shdlc)\r\n{\r\npr_debug("\n");\r\nmutex_lock(&shdlc->state_mutex);\r\nshdlc->state = SHDLC_DISCONNECTED;\r\nmutex_unlock(&shdlc->state_mutex);\r\nschedule_work(&shdlc->sm_work);\r\n}\r\nstatic void llc_shdlc_recv_frame(struct llc_shdlc *shdlc, struct sk_buff *skb)\r\n{\r\nif (skb == NULL) {\r\npr_err("NULL Frame -> link is dead\n");\r\nshdlc->hard_fault = -EREMOTEIO;\r\n} else {\r\nSHDLC_DUMP_SKB("incoming frame", skb);\r\nskb_queue_tail(&shdlc->rcv_q, skb);\r\n}\r\nschedule_work(&shdlc->sm_work);\r\n}\r\nstatic void *llc_shdlc_init(struct nfc_hci_dev *hdev, xmit_to_drv_t xmit_to_drv,\r\nrcv_to_hci_t rcv_to_hci, int tx_headroom,\r\nint tx_tailroom, int *rx_headroom, int *rx_tailroom,\r\nllc_failure_t llc_failure)\r\n{\r\nstruct llc_shdlc *shdlc;\r\n*rx_headroom = SHDLC_LLC_HEAD_ROOM;\r\n*rx_tailroom = 0;\r\nshdlc = kzalloc(sizeof(struct llc_shdlc), GFP_KERNEL);\r\nif (shdlc == NULL)\r\nreturn NULL;\r\nmutex_init(&shdlc->state_mutex);\r\nshdlc->state = SHDLC_DISCONNECTED;\r\ninit_timer(&shdlc->connect_timer);\r\nshdlc->connect_timer.data = (unsigned long)shdlc;\r\nshdlc->connect_timer.function = llc_shdlc_connect_timeout;\r\ninit_timer(&shdlc->t1_timer);\r\nshdlc->t1_timer.data = (unsigned long)shdlc;\r\nshdlc->t1_timer.function = llc_shdlc_t1_timeout;\r\ninit_timer(&shdlc->t2_timer);\r\nshdlc->t2_timer.data = (unsigned long)shdlc;\r\nshdlc->t2_timer.function = llc_shdlc_t2_timeout;\r\nshdlc->w = SHDLC_MAX_WINDOW;\r\nshdlc->srej_support = SHDLC_SREJ_SUPPORT;\r\nskb_queue_head_init(&shdlc->rcv_q);\r\nskb_queue_head_init(&shdlc->send_q);\r\nskb_queue_head_init(&shdlc->ack_pending_q);\r\nINIT_WORK(&shdlc->sm_work, llc_shdlc_sm_work);\r\nshdlc->hdev = hdev;\r\nshdlc->xmit_to_drv = xmit_to_drv;\r\nshdlc->rcv_to_hci = rcv_to_hci;\r\nshdlc->tx_headroom = tx_headroom;\r\nshdlc->tx_tailroom = tx_tailroom;\r\nshdlc->llc_failure = llc_failure;\r\nreturn shdlc;\r\n}\r\nstatic void llc_shdlc_deinit(struct nfc_llc *llc)\r\n{\r\nstruct llc_shdlc *shdlc = nfc_llc_get_data(llc);\r\nskb_queue_purge(&shdlc->rcv_q);\r\nskb_queue_purge(&shdlc->send_q);\r\nskb_queue_purge(&shdlc->ack_pending_q);\r\nkfree(shdlc);\r\n}\r\nstatic int llc_shdlc_start(struct nfc_llc *llc)\r\n{\r\nstruct llc_shdlc *shdlc = nfc_llc_get_data(llc);\r\nreturn llc_shdlc_connect(shdlc);\r\n}\r\nstatic int llc_shdlc_stop(struct nfc_llc *llc)\r\n{\r\nstruct llc_shdlc *shdlc = nfc_llc_get_data(llc);\r\nllc_shdlc_disconnect(shdlc);\r\nreturn 0;\r\n}\r\nstatic void llc_shdlc_rcv_from_drv(struct nfc_llc *llc, struct sk_buff *skb)\r\n{\r\nstruct llc_shdlc *shdlc = nfc_llc_get_data(llc);\r\nllc_shdlc_recv_frame(shdlc, skb);\r\n}\r\nstatic int llc_shdlc_xmit_from_hci(struct nfc_llc *llc, struct sk_buff *skb)\r\n{\r\nstruct llc_shdlc *shdlc = nfc_llc_get_data(llc);\r\nskb_queue_tail(&shdlc->send_q, skb);\r\nschedule_work(&shdlc->sm_work);\r\nreturn 0;\r\n}\r\nint nfc_llc_shdlc_register(void)\r\n{\r\nreturn nfc_llc_register(LLC_SHDLC_NAME, &llc_shdlc_ops);\r\n}
