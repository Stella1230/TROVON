void ptrace_disable(struct task_struct *task)\r\n{\r\nclear_tsk_thread_flag(task, TIF_SINGLESTEP);\r\nclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\r\npa_psw(task)->r = 0;\r\npa_psw(task)->t = 0;\r\npa_psw(task)->h = 0;\r\npa_psw(task)->l = 0;\r\n}\r\nvoid user_disable_single_step(struct task_struct *task)\r\n{\r\nptrace_disable(task);\r\n}\r\nvoid user_enable_single_step(struct task_struct *task)\r\n{\r\nclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\r\nset_tsk_thread_flag(task, TIF_SINGLESTEP);\r\nif (pa_psw(task)->n) {\r\nstruct siginfo si;\r\ntask_regs(task)->iaoq[0] = task_regs(task)->iaoq[1];\r\ntask_regs(task)->iasq[0] = task_regs(task)->iasq[1];\r\ntask_regs(task)->iaoq[1] = task_regs(task)->iaoq[0] + 4;\r\npa_psw(task)->n = 0;\r\npa_psw(task)->x = 0;\r\npa_psw(task)->y = 0;\r\npa_psw(task)->z = 0;\r\npa_psw(task)->b = 0;\r\nptrace_disable(task);\r\nsi.si_code = TRAP_TRACE;\r\nsi.si_addr = (void __user *) (task_regs(task)->iaoq[0] & ~3);\r\nsi.si_signo = SIGTRAP;\r\nsi.si_errno = 0;\r\nforce_sig_info(SIGTRAP, &si, task);\r\nreturn;\r\n}\r\npa_psw(task)->r = 1;\r\npa_psw(task)->t = 0;\r\npa_psw(task)->h = 0;\r\npa_psw(task)->l = 0;\r\n}\r\nvoid user_enable_block_step(struct task_struct *task)\r\n{\r\nclear_tsk_thread_flag(task, TIF_SINGLESTEP);\r\nset_tsk_thread_flag(task, TIF_BLOCKSTEP);\r\npa_psw(task)->r = 0;\r\npa_psw(task)->t = 1;\r\npa_psw(task)->h = 0;\r\npa_psw(task)->l = 0;\r\n}\r\nlong arch_ptrace(struct task_struct *child, long request,\r\nunsigned long addr, unsigned long data)\r\n{\r\nunsigned long tmp;\r\nlong ret = -EIO;\r\nswitch (request) {\r\ncase PTRACE_PEEKUSR:\r\nif ((addr & (sizeof(unsigned long)-1)) ||\r\naddr >= sizeof(struct pt_regs))\r\nbreak;\r\ntmp = *(unsigned long *) ((char *) task_regs(child) + addr);\r\nret = put_user(tmp, (unsigned long __user *) data);\r\nbreak;\r\ncase PTRACE_POKEUSR:\r\nif (addr == PT_PSW) {\r\ndata &= USER_PSW_BITS;\r\ntask_regs(child)->gr[0] &= ~USER_PSW_BITS;\r\ntask_regs(child)->gr[0] |= data;\r\nret = 0;\r\nbreak;\r\n}\r\nif ((addr & (sizeof(unsigned long)-1)) ||\r\naddr >= sizeof(struct pt_regs))\r\nbreak;\r\nif ((addr >= PT_GR1 && addr <= PT_GR31) ||\r\naddr == PT_IAOQ0 || addr == PT_IAOQ1 ||\r\n(addr >= PT_FR0 && addr <= PT_FR31 + 4) ||\r\naddr == PT_SAR) {\r\n*(unsigned long *) ((char *) task_regs(child) + addr) = data;\r\nret = 0;\r\n}\r\nbreak;\r\ndefault:\r\nret = ptrace_request(child, request, addr, data);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic compat_ulong_t translate_usr_offset(compat_ulong_t offset)\r\n{\r\nif (offset < 0)\r\nreturn sizeof(struct pt_regs);\r\nelse if (offset <= 32*4)\r\nreturn offset * 2 + 4;\r\nelse if (offset <= 32*4+32*8)\r\nreturn offset + 32*4;\r\nelse if (offset < sizeof(struct pt_regs)/2 + 32*4)\r\nreturn offset * 2 + 4 - 32*8;\r\nelse\r\nreturn sizeof(struct pt_regs);\r\n}\r\nlong compat_arch_ptrace(struct task_struct *child, compat_long_t request,\r\ncompat_ulong_t addr, compat_ulong_t data)\r\n{\r\ncompat_uint_t tmp;\r\nlong ret = -EIO;\r\nswitch (request) {\r\ncase PTRACE_PEEKUSR:\r\nif (addr & (sizeof(compat_uint_t)-1))\r\nbreak;\r\naddr = translate_usr_offset(addr);\r\nif (addr >= sizeof(struct pt_regs))\r\nbreak;\r\ntmp = *(compat_uint_t *) ((char *) task_regs(child) + addr);\r\nret = put_user(tmp, (compat_uint_t *) (unsigned long) data);\r\nbreak;\r\ncase PTRACE_POKEUSR:\r\nif (addr == PT_PSW) {\r\nret = arch_ptrace(child, request, addr, data);\r\n} else {\r\nif (addr & (sizeof(compat_uint_t)-1))\r\nbreak;\r\naddr = translate_usr_offset(addr);\r\nif (addr >= sizeof(struct pt_regs))\r\nbreak;\r\nif (addr >= PT_FR0 && addr <= PT_FR31 + 4) {\r\n*(__u64 *) ((char *) task_regs(child) + addr) = data;\r\nret = 0;\r\n}\r\nelse if ((addr >= PT_GR1+4 && addr <= PT_GR31+4) ||\r\naddr == PT_IAOQ0+4 || addr == PT_IAOQ1+4 ||\r\naddr == PT_SAR+4) {\r\n*(__u32 *) ((char *) task_regs(child) + addr - 4) = 0;\r\n*(__u32 *) ((char *) task_regs(child) + addr) = data;\r\nret = 0;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nret = compat_ptrace_request(child, request, addr, data);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nlong do_syscall_trace_enter(struct pt_regs *regs)\r\n{\r\nif (test_thread_flag(TIF_SYSCALL_TRACE) &&\r\ntracehook_report_syscall_entry(regs))\r\nreturn -1L;\r\nreturn regs->gr[20];\r\n}\r\nvoid do_syscall_trace_exit(struct pt_regs *regs)\r\n{\r\nint stepping = test_thread_flag(TIF_SINGLESTEP) ||\r\ntest_thread_flag(TIF_BLOCKSTEP);\r\nif (stepping || test_thread_flag(TIF_SYSCALL_TRACE))\r\ntracehook_report_syscall_exit(regs, stepping);\r\n}
