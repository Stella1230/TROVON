static inline u32 pci_cfg_read_32bit(struct pci_bus *bus, unsigned int devfn,\r\nint where)\r\n{\r\nu32 data;\r\nu32 *cfgaddr;\r\nwhere &= ~3;\r\nif (bus->number == 0 && PCI_SLOT(devfn) == 1 && where == 0x954)\r\nreturn 0xffffffff;\r\ncfgaddr = (u32 *)(pci_config_base +\r\npci_cfg_addr(bus->number, devfn, where));\r\ndata = *cfgaddr;\r\nreturn data;\r\n}\r\nstatic inline void pci_cfg_write_32bit(struct pci_bus *bus, unsigned int devfn,\r\nint where, u32 data)\r\n{\r\nu32 *cfgaddr;\r\ncfgaddr = (u32 *)(pci_config_base +\r\npci_cfg_addr(bus->number, devfn, where & ~3));\r\n*cfgaddr = data;\r\n}\r\nstatic int nlm_pcibios_read(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nu32 data;\r\nif ((size == 2) && (where & 1))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nelse if ((size == 4) && (where & 3))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\ndata = pci_cfg_read_32bit(bus, devfn, where);\r\nif (size == 1)\r\n*val = (data >> ((where & 3) << 3)) & 0xff;\r\nelse if (size == 2)\r\n*val = (data >> ((where & 3) << 3)) & 0xffff;\r\nelse\r\n*val = data;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int nlm_pcibios_write(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nu32 data;\r\nif ((size == 2) && (where & 1))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nelse if ((size == 4) && (where & 3))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\ndata = pci_cfg_read_32bit(bus, devfn, where);\r\nif (size == 1)\r\ndata = (data & ~(0xff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nelse if (size == 2)\r\ndata = (data & ~(0xffff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nelse\r\ndata = val;\r\npci_cfg_write_32bit(bus, devfn, where, data);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic struct pci_dev *xlp_get_pcie_link(const struct pci_dev *dev)\r\n{\r\nstruct pci_bus *bus, *p;\r\nbus = dev->bus;\r\nfor (p = bus->parent; p && p->number != 0; p = p->parent)\r\nbus = p;\r\nreturn p ? bus->self : NULL;\r\n}\r\nstatic inline int nlm_pci_link_to_irq(int link)\r\n{\r\nreturn PIC_PCIE_LINK_0_IRQ + link;\r\n}\r\nint __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nstruct pci_dev *lnkdev;\r\nint lnkslot, lnkfunc;\r\nlnkdev = xlp_get_pcie_link(dev);\r\nif (lnkdev == NULL)\r\nreturn 0;\r\nlnkfunc = PCI_FUNC(lnkdev->devfn);\r\nlnkslot = PCI_SLOT(lnkdev->devfn);\r\nreturn nlm_irq_to_xirq(lnkslot / 8, nlm_pci_link_to_irq(lnkfunc));\r\n}\r\nint pcibios_plat_dev_init(struct pci_dev *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void xlp_config_pci_bswap(int node, int link)\r\n{\r\nuint64_t nbubase, lnkbase;\r\nu32 reg;\r\nnbubase = nlm_get_bridge_regbase(node);\r\nlnkbase = nlm_get_pcie_base(node, link);\r\nreg = nlm_read_bridge_reg(nbubase, BRIDGE_PCIEMEM_BASE0 + link);\r\nnlm_write_pci_reg(lnkbase, PCIE_BYTE_SWAP_MEM_BASE, reg);\r\nreg = nlm_read_bridge_reg(nbubase, BRIDGE_PCIEMEM_LIMIT0 + link);\r\nnlm_write_pci_reg(lnkbase, PCIE_BYTE_SWAP_MEM_LIM, reg | 0xfff);\r\nreg = nlm_read_bridge_reg(nbubase, BRIDGE_PCIEIO_BASE0 + link);\r\nnlm_write_pci_reg(lnkbase, PCIE_BYTE_SWAP_IO_BASE, reg);\r\nreg = nlm_read_bridge_reg(nbubase, BRIDGE_PCIEIO_LIMIT0 + link);\r\nnlm_write_pci_reg(lnkbase, PCIE_BYTE_SWAP_IO_LIM, reg | 0xfff);\r\n}\r\nstatic inline void xlp_config_pci_bswap(int node, int link) {}\r\nstatic int __init pcibios_init(void)\r\n{\r\nstruct nlm_soc_info *nodep;\r\nuint64_t pciebase;\r\nint link, n;\r\nu32 reg;\r\npci_set_flags(PCI_PROBE_ONLY);\r\npci_config_base = ioremap(XLP_DEFAULT_PCI_ECFG_BASE, 64 << 20);\r\nioport_resource.start = 0;\r\nioport_resource.end = ~0;\r\nfor (n = 0; n < NLM_NR_NODES; n++) {\r\nnodep = nlm_get_node(n);\r\nif (!nodep->coremask)\r\ncontinue;\r\nfor (link = 0; link < 4; link++) {\r\npciebase = nlm_get_pcie_base(n, link);\r\nif (nlm_read_pci_reg(pciebase, 0) == 0xffffffff)\r\ncontinue;\r\nxlp_config_pci_bswap(n, link);\r\nreg = nlm_read_pci_reg(pciebase, 0xf);\r\nreg &= ~0x1fu;\r\nreg |= (1 << 8) | nlm_pci_link_to_irq(link);\r\nnlm_write_pci_reg(pciebase, 0xf, reg);\r\npr_info("XLP PCIe: Link %d-%d initialized.\n", n, link);\r\n}\r\n}\r\nset_io_port_base(CKSEG1);\r\nnlm_pci_controller.io_map_base = CKSEG1;\r\nregister_pci_controller(&nlm_pci_controller);\r\npr_info("XLP PCIe Controller %pR%pR.\n", &nlm_pci_io_resource,\r\n&nlm_pci_mem_resource);\r\nreturn 0;\r\n}
