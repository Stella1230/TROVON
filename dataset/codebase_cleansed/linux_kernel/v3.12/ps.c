void wl1251_elp_work(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork;\r\nstruct wl1251 *wl;\r\ndwork = container_of(work, struct delayed_work, work);\r\nwl = container_of(dwork, struct wl1251, elp_work);\r\nwl1251_debug(DEBUG_PSM, "elp work");\r\nmutex_lock(&wl->mutex);\r\nif (wl->elp || wl->station_mode == STATION_ACTIVE_MODE)\r\ngoto out;\r\nwl1251_debug(DEBUG_PSM, "chip to elp");\r\nwl1251_write_elp(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, ELPCTRL_SLEEP);\r\nwl->elp = true;\r\nout:\r\nmutex_unlock(&wl->mutex);\r\n}\r\nvoid wl1251_ps_elp_sleep(struct wl1251 *wl)\r\n{\r\nunsigned long delay;\r\nif (wl->station_mode != STATION_ACTIVE_MODE) {\r\ndelay = msecs_to_jiffies(ELP_ENTRY_DELAY);\r\nieee80211_queue_delayed_work(wl->hw, &wl->elp_work, delay);\r\n}\r\n}\r\nint wl1251_ps_elp_wakeup(struct wl1251 *wl)\r\n{\r\nunsigned long timeout, start;\r\nu32 elp_reg;\r\ncancel_delayed_work(&wl->elp_work);\r\nif (!wl->elp)\r\nreturn 0;\r\nwl1251_debug(DEBUG_PSM, "waking up chip from elp");\r\nstart = jiffies;\r\ntimeout = jiffies + msecs_to_jiffies(WL1251_WAKEUP_TIMEOUT);\r\nwl1251_write_elp(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, ELPCTRL_WAKE_UP);\r\nelp_reg = wl1251_read_elp(wl, HW_ACCESS_ELP_CTRL_REG_ADDR);\r\nwhile (!(elp_reg & ELPCTRL_WLAN_READY)) {\r\nif (time_after(jiffies, timeout)) {\r\nwl1251_error("elp wakeup timeout");\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\nelp_reg = wl1251_read_elp(wl, HW_ACCESS_ELP_CTRL_REG_ADDR);\r\n}\r\nwl1251_debug(DEBUG_PSM, "wakeup time: %u ms",\r\njiffies_to_msecs(jiffies - start));\r\nwl->elp = false;\r\nreturn 0;\r\n}\r\nint wl1251_ps_set_mode(struct wl1251 *wl, enum wl1251_station_mode mode)\r\n{\r\nint ret;\r\nswitch (mode) {\r\ncase STATION_POWER_SAVE_MODE:\r\nwl1251_debug(DEBUG_PSM, "entering psm");\r\nret = wl1251_acx_beacon_filter_opt(wl, true);\r\nif (ret < 0)\r\nreturn ret;\r\nret = wl1251_acx_wake_up_conditions(wl,\r\nWAKE_UP_EVENT_DTIM_BITMAP,\r\nwl->listen_int);\r\nif (ret < 0)\r\nreturn ret;\r\nret = wl1251_acx_bet_enable(wl, WL1251_ACX_BET_ENABLE,\r\nWL1251_DEFAULT_BET_CONSECUTIVE);\r\nif (ret < 0)\r\nreturn ret;\r\nret = wl1251_cmd_ps_mode(wl, CHIP_POWER_SAVE_MODE);\r\nif (ret < 0)\r\nreturn ret;\r\nret = wl1251_acx_sleep_auth(wl, WL1251_PSM_ELP);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase STATION_IDLE:\r\nwl1251_debug(DEBUG_PSM, "entering idle");\r\nret = wl1251_acx_sleep_auth(wl, WL1251_PSM_ELP);\r\nif (ret < 0)\r\nreturn ret;\r\nret = wl1251_cmd_template_set(wl, CMD_DISCONNECT, NULL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase STATION_ACTIVE_MODE:\r\ndefault:\r\nwl1251_debug(DEBUG_PSM, "leaving psm");\r\nret = wl1251_acx_sleep_auth(wl, WL1251_PSM_CAM);\r\nif (ret < 0)\r\nreturn ret;\r\nret = wl1251_acx_bet_enable(wl, WL1251_ACX_BET_DISABLE,\r\nWL1251_DEFAULT_BET_CONSECUTIVE);\r\nif (ret < 0)\r\nreturn ret;\r\nret = wl1251_acx_beacon_filter_opt(wl, false);\r\nif (ret < 0)\r\nreturn ret;\r\nret = wl1251_acx_wake_up_conditions(wl,\r\nWAKE_UP_EVENT_DTIM_BITMAP,\r\nwl->listen_int);\r\nif (ret < 0)\r\nreturn ret;\r\nret = wl1251_cmd_ps_mode(wl, CHIP_ACTIVE_MODE);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\n}\r\nwl->station_mode = mode;\r\nreturn ret;\r\n}
