static inline void emc_writel(u32 val, unsigned long addr)\r\n{\r\nwritel(val, emc_regbase + addr);\r\n}\r\nstatic inline u32 emc_readl(unsigned long addr)\r\n{\r\nreturn readl(emc_regbase + addr);\r\n}\r\nlong tegra_emc_round_rate(unsigned long rate)\r\n{\r\nstruct tegra_emc_pdata *pdata;\r\nint i;\r\nint best = -1;\r\nunsigned long distance = ULONG_MAX;\r\nif (!emc_pdev)\r\nreturn -EINVAL;\r\npdata = emc_pdev->dev.platform_data;\r\npr_debug("%s: %lu\n", __func__, rate);\r\nrate = rate / 2 / 1000;\r\nfor (i = 0; i < pdata->num_tables; i++) {\r\nif (pdata->tables[i].rate >= rate &&\r\n(pdata->tables[i].rate - rate) < distance) {\r\ndistance = pdata->tables[i].rate - rate;\r\nbest = i;\r\n}\r\n}\r\nif (best < 0)\r\nreturn -EINVAL;\r\npr_debug("%s: using %lu\n", __func__, pdata->tables[best].rate);\r\nreturn pdata->tables[best].rate * 2 * 1000;\r\n}\r\nint tegra_emc_set_rate(unsigned long rate)\r\n{\r\nstruct tegra_emc_pdata *pdata;\r\nint i;\r\nint j;\r\nif (!emc_pdev)\r\nreturn -EINVAL;\r\npdata = emc_pdev->dev.platform_data;\r\nrate = rate / 2 / 1000;\r\nfor (i = 0; i < pdata->num_tables; i++)\r\nif (pdata->tables[i].rate == rate)\r\nbreak;\r\nif (i >= pdata->num_tables)\r\nreturn -EINVAL;\r\npr_debug("%s: setting to %lu\n", __func__, rate);\r\nfor (j = 0; j < TEGRA_EMC_NUM_REGS; j++)\r\nemc_writel(pdata->tables[i].regs[j], emc_reg_addr[j]);\r\nemc_readl(pdata->tables[i].regs[TEGRA_EMC_NUM_REGS - 1]);\r\nreturn 0;\r\n}\r\nstatic struct device_node *tegra_emc_ramcode_devnode(struct device_node *np)\r\n{\r\nstruct device_node *iter;\r\nu32 reg;\r\nfor_each_child_of_node(np, iter) {\r\nif (of_property_read_u32(iter, "nvidia,ram-code", &reg))\r\ncontinue;\r\nif (reg == tegra_bct_strapping)\r\nreturn of_node_get(iter);\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct tegra_emc_pdata *tegra_emc_dt_parse_pdata(\r\nstruct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *tnp, *iter;\r\nstruct tegra_emc_pdata *pdata;\r\nint ret, i, num_tables;\r\nif (!np)\r\nreturn NULL;\r\nif (of_find_property(np, "nvidia,use-ram-code", NULL)) {\r\ntnp = tegra_emc_ramcode_devnode(np);\r\nif (!tnp)\r\ndev_warn(&pdev->dev,\r\n"can't find emc table for ram-code 0x%02x\n",\r\ntegra_bct_strapping);\r\n} else\r\ntnp = of_node_get(np);\r\nif (!tnp)\r\nreturn NULL;\r\nnum_tables = 0;\r\nfor_each_child_of_node(tnp, iter)\r\nif (of_device_is_compatible(iter, "nvidia,tegra20-emc-table"))\r\nnum_tables++;\r\nif (!num_tables) {\r\npdata = NULL;\r\ngoto out;\r\n}\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\npdata->tables = devm_kzalloc(&pdev->dev,\r\nsizeof(*pdata->tables) * num_tables,\r\nGFP_KERNEL);\r\ni = 0;\r\nfor_each_child_of_node(tnp, iter) {\r\nu32 prop;\r\nret = of_property_read_u32(iter, "clock-frequency", &prop);\r\nif (ret) {\r\ndev_err(&pdev->dev, "no clock-frequency in %s\n",\r\niter->full_name);\r\ncontinue;\r\n}\r\npdata->tables[i].rate = prop;\r\nret = of_property_read_u32_array(iter, "nvidia,emc-registers",\r\npdata->tables[i].regs,\r\nTEGRA_EMC_NUM_REGS);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"malformed emc-registers property in %s\n",\r\niter->full_name);\r\ncontinue;\r\n}\r\ni++;\r\n}\r\npdata->num_tables = i;\r\nout:\r\nof_node_put(tnp);\r\nreturn pdata;\r\n}\r\nstatic struct tegra_emc_pdata *tegra_emc_dt_parse_pdata(\r\nstruct platform_device *pdev)\r\n{\r\nreturn NULL;\r\n}\r\nstatic struct tegra_emc_pdata *tegra_emc_fill_pdata(struct platform_device *pdev)\r\n{\r\nstruct clk *c = clk_get_sys(NULL, "emc");\r\nstruct tegra_emc_pdata *pdata;\r\nunsigned long khz;\r\nint i;\r\nWARN_ON(pdev->dev.platform_data);\r\nBUG_ON(IS_ERR(c));\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\npdata->tables = devm_kzalloc(&pdev->dev, sizeof(*pdata->tables),\r\nGFP_KERNEL);\r\npdata->tables[0].rate = clk_get_rate(c) / 2 / 1000;\r\nfor (i = 0; i < TEGRA_EMC_NUM_REGS; i++)\r\npdata->tables[0].regs[i] = emc_readl(emc_reg_addr[i]);\r\npdata->num_tables = 1;\r\nkhz = pdata->tables[0].rate;\r\ndev_info(&pdev->dev, "no tables provided, using %ld kHz emc, "\r\n"%ld kHz mem\n", khz * 2, khz);\r\nreturn pdata;\r\n}\r\nstatic int tegra_emc_probe(struct platform_device *pdev)\r\n{\r\nstruct tegra_emc_pdata *pdata;\r\nstruct resource *res;\r\nif (!emc_enable) {\r\ndev_err(&pdev->dev, "disabled per module parameter\n");\r\nreturn -ENODEV;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nemc_regbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(emc_regbase))\r\nreturn PTR_ERR(emc_regbase);\r\npdata = pdev->dev.platform_data;\r\nif (!pdata)\r\npdata = tegra_emc_dt_parse_pdata(pdev);\r\nif (!pdata)\r\npdata = tegra_emc_fill_pdata(pdev);\r\npdev->dev.platform_data = pdata;\r\nemc_pdev = pdev;\r\nreturn 0;\r\n}\r\nstatic int __init tegra_emc_init(void)\r\n{\r\nreturn platform_driver_register(&tegra_emc_driver);\r\n}
