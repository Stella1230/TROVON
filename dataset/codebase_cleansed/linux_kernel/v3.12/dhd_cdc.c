static int brcmf_proto_cdc_msg(struct brcmf_pub *drvr)\r\n{\r\nstruct brcmf_proto *prot = drvr->prot;\r\nint len = le32_to_cpu(prot->msg.len) +\r\nsizeof(struct brcmf_proto_cdc_dcmd);\r\nbrcmf_dbg(CDC, "Enter\n");\r\nif (len > CDC_MAX_MSG_SIZE)\r\nlen = CDC_MAX_MSG_SIZE;\r\nreturn brcmf_bus_txctl(drvr->bus_if, (unsigned char *)&prot->msg, len);\r\n}\r\nstatic int brcmf_proto_cdc_cmplt(struct brcmf_pub *drvr, u32 id, u32 len)\r\n{\r\nint ret;\r\nstruct brcmf_proto *prot = drvr->prot;\r\nbrcmf_dbg(CDC, "Enter\n");\r\nlen += sizeof(struct brcmf_proto_cdc_dcmd);\r\ndo {\r\nret = brcmf_bus_rxctl(drvr->bus_if, (unsigned char *)&prot->msg,\r\nlen);\r\nif (ret < 0)\r\nbreak;\r\n} while (CDC_DCMD_ID(le32_to_cpu(prot->msg.flags)) != id);\r\nreturn ret;\r\n}\r\nint\r\nbrcmf_proto_cdc_query_dcmd(struct brcmf_pub *drvr, int ifidx, uint cmd,\r\nvoid *buf, uint len)\r\n{\r\nstruct brcmf_proto *prot = drvr->prot;\r\nstruct brcmf_proto_cdc_dcmd *msg = &prot->msg;\r\nvoid *info;\r\nint ret = 0, retries = 0;\r\nu32 id, flags;\r\nbrcmf_dbg(CDC, "Enter, cmd %d len %d\n", cmd, len);\r\nmemset(msg, 0, sizeof(struct brcmf_proto_cdc_dcmd));\r\nmsg->cmd = cpu_to_le32(cmd);\r\nmsg->len = cpu_to_le32(len);\r\nflags = (++prot->reqid << CDC_DCMD_ID_SHIFT);\r\nflags = (flags & ~CDC_DCMD_IF_MASK) |\r\n(ifidx << CDC_DCMD_IF_SHIFT);\r\nmsg->flags = cpu_to_le32(flags);\r\nif (buf)\r\nmemcpy(prot->buf, buf, len);\r\nret = brcmf_proto_cdc_msg(drvr);\r\nif (ret < 0) {\r\nbrcmf_err("brcmf_proto_cdc_msg failed w/status %d\n",\r\nret);\r\ngoto done;\r\n}\r\nretry:\r\nret = brcmf_proto_cdc_cmplt(drvr, prot->reqid, len);\r\nif (ret < 0)\r\ngoto done;\r\nflags = le32_to_cpu(msg->flags);\r\nid = (flags & CDC_DCMD_ID_MASK) >> CDC_DCMD_ID_SHIFT;\r\nif ((id < prot->reqid) && (++retries < RETRIES))\r\ngoto retry;\r\nif (id != prot->reqid) {\r\nbrcmf_err("%s: unexpected request id %d (expected %d)\n",\r\nbrcmf_ifname(drvr, ifidx), id, prot->reqid);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\ninfo = (void *)&msg[1];\r\nif (buf) {\r\nif (ret < (int)len)\r\nlen = ret;\r\nmemcpy(buf, info, len);\r\n}\r\nif (flags & CDC_DCMD_ERROR)\r\nret = le32_to_cpu(msg->status);\r\ndone:\r\nreturn ret;\r\n}\r\nint brcmf_proto_cdc_set_dcmd(struct brcmf_pub *drvr, int ifidx, uint cmd,\r\nvoid *buf, uint len)\r\n{\r\nstruct brcmf_proto *prot = drvr->prot;\r\nstruct brcmf_proto_cdc_dcmd *msg = &prot->msg;\r\nint ret = 0;\r\nu32 flags, id;\r\nbrcmf_dbg(CDC, "Enter, cmd %d len %d\n", cmd, len);\r\nmemset(msg, 0, sizeof(struct brcmf_proto_cdc_dcmd));\r\nmsg->cmd = cpu_to_le32(cmd);\r\nmsg->len = cpu_to_le32(len);\r\nflags = (++prot->reqid << CDC_DCMD_ID_SHIFT) | CDC_DCMD_SET;\r\nflags = (flags & ~CDC_DCMD_IF_MASK) |\r\n(ifidx << CDC_DCMD_IF_SHIFT);\r\nmsg->flags = cpu_to_le32(flags);\r\nif (buf)\r\nmemcpy(prot->buf, buf, len);\r\nret = brcmf_proto_cdc_msg(drvr);\r\nif (ret < 0)\r\ngoto done;\r\nret = brcmf_proto_cdc_cmplt(drvr, prot->reqid, len);\r\nif (ret < 0)\r\ngoto done;\r\nflags = le32_to_cpu(msg->flags);\r\nid = (flags & CDC_DCMD_ID_MASK) >> CDC_DCMD_ID_SHIFT;\r\nif (id != prot->reqid) {\r\nbrcmf_err("%s: unexpected request id %d (expected %d)\n",\r\nbrcmf_ifname(drvr, ifidx), id, prot->reqid);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (flags & CDC_DCMD_ERROR)\r\nret = le32_to_cpu(msg->status);\r\ndone:\r\nreturn ret;\r\n}\r\nstatic bool pkt_sum_needed(struct sk_buff *skb)\r\n{\r\nreturn skb->ip_summed == CHECKSUM_PARTIAL;\r\n}\r\nstatic void pkt_set_sum_good(struct sk_buff *skb, bool x)\r\n{\r\nskb->ip_summed = (x ? CHECKSUM_UNNECESSARY : CHECKSUM_NONE);\r\n}\r\nvoid brcmf_proto_hdrpush(struct brcmf_pub *drvr, int ifidx, u8 offset,\r\nstruct sk_buff *pktbuf)\r\n{\r\nstruct brcmf_proto_bdc_header *h;\r\nbrcmf_dbg(CDC, "Enter\n");\r\nskb_push(pktbuf, BDC_HEADER_LEN);\r\nh = (struct brcmf_proto_bdc_header *)(pktbuf->data);\r\nh->flags = (BDC_PROTO_VER << BDC_FLAG_VER_SHIFT);\r\nif (pkt_sum_needed(pktbuf))\r\nh->flags |= BDC_FLAG_SUM_NEEDED;\r\nh->priority = (pktbuf->priority & BDC_PRIORITY_MASK);\r\nh->flags2 = 0;\r\nh->data_offset = offset;\r\nBDC_SET_IF_IDX(h, ifidx);\r\ntrace_brcmf_bdchdr(pktbuf->data);\r\n}\r\nint brcmf_proto_hdrpull(struct brcmf_pub *drvr, bool do_fws, u8 *ifidx,\r\nstruct sk_buff *pktbuf)\r\n{\r\nstruct brcmf_proto_bdc_header *h;\r\nbrcmf_dbg(CDC, "Enter\n");\r\nif (pktbuf->len <= BDC_HEADER_LEN) {\r\nbrcmf_dbg(INFO, "rx data too short (%d <= %d)\n",\r\npktbuf->len, BDC_HEADER_LEN);\r\nreturn -EBADE;\r\n}\r\ntrace_brcmf_bdchdr(pktbuf->data);\r\nh = (struct brcmf_proto_bdc_header *)(pktbuf->data);\r\n*ifidx = BDC_GET_IF_IDX(h);\r\nif (*ifidx >= BRCMF_MAX_IFS) {\r\nbrcmf_err("rx data ifnum out of range (%d)\n", *ifidx);\r\nreturn -EBADE;\r\n}\r\nif (*ifidx)\r\n(*ifidx)++;\r\nif (((h->flags & BDC_FLAG_VER_MASK) >> BDC_FLAG_VER_SHIFT) !=\r\nBDC_PROTO_VER) {\r\nbrcmf_err("%s: non-BDC packet received, flags 0x%x\n",\r\nbrcmf_ifname(drvr, *ifidx), h->flags);\r\nreturn -EBADE;\r\n}\r\nif (h->flags & BDC_FLAG_SUM_GOOD) {\r\nbrcmf_dbg(CDC, "%s: BDC rcv, good checksum, flags 0x%x\n",\r\nbrcmf_ifname(drvr, *ifidx), h->flags);\r\npkt_set_sum_good(pktbuf, true);\r\n}\r\npktbuf->priority = h->priority & BDC_PRIORITY_MASK;\r\nskb_pull(pktbuf, BDC_HEADER_LEN);\r\nif (do_fws)\r\nbrcmf_fws_hdrpull(drvr, *ifidx, h->data_offset << 2, pktbuf);\r\nelse\r\nskb_pull(pktbuf, h->data_offset << 2);\r\nif (pktbuf->len == 0)\r\nreturn -ENODATA;\r\nreturn 0;\r\n}\r\nint brcmf_proto_attach(struct brcmf_pub *drvr)\r\n{\r\nstruct brcmf_proto *cdc;\r\ncdc = kzalloc(sizeof(struct brcmf_proto), GFP_ATOMIC);\r\nif (!cdc)\r\ngoto fail;\r\nif ((unsigned long)(&cdc->msg + 1) != (unsigned long)cdc->buf) {\r\nbrcmf_err("struct brcmf_proto is not correctly defined\n");\r\ngoto fail;\r\n}\r\ndrvr->prot = cdc;\r\ndrvr->hdrlen += BDC_HEADER_LEN + BRCMF_PROT_FW_SIGNAL_MAX_TXBYTES;\r\ndrvr->bus_if->maxctl = BRCMF_DCMD_MAXLEN +\r\nsizeof(struct brcmf_proto_cdc_dcmd) + ROUND_UP_MARGIN;\r\nreturn 0;\r\nfail:\r\nkfree(cdc);\r\nreturn -ENOMEM;\r\n}\r\nvoid brcmf_proto_detach(struct brcmf_pub *drvr)\r\n{\r\nkfree(drvr->prot);\r\ndrvr->prot = NULL;\r\n}\r\nvoid brcmf_proto_stop(struct brcmf_pub *drvr)\r\n{\r\n}
