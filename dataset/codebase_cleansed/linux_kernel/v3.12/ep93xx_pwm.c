static ssize_t ep93xx_pwm_get_min_freq(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ep93xx_pwm *pwm = platform_get_drvdata(pdev);\r\nunsigned long rate = clk_get_rate(pwm->clk);\r\nreturn sprintf(buf, "%ld\n", rate / (EP93XX_PWM_MAX_COUNT + 1));\r\n}\r\nstatic ssize_t ep93xx_pwm_get_max_freq(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ep93xx_pwm *pwm = platform_get_drvdata(pdev);\r\nunsigned long rate = clk_get_rate(pwm->clk);\r\nreturn sprintf(buf, "%ld\n", rate / 2);\r\n}\r\nstatic ssize_t ep93xx_pwm_get_freq(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ep93xx_pwm *pwm = platform_get_drvdata(pdev);\r\nif (readl(pwm->mmio_base + EP93XX_PWMx_ENABLE) & 0x1) {\r\nunsigned long rate = clk_get_rate(pwm->clk);\r\nu16 term = readl(pwm->mmio_base + EP93XX_PWMx_TERM_COUNT);\r\nreturn sprintf(buf, "%ld\n", rate / (term + 1));\r\n} else {\r\nreturn sprintf(buf, "disabled\n");\r\n}\r\n}\r\nstatic ssize_t ep93xx_pwm_set_freq(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ep93xx_pwm *pwm = platform_get_drvdata(pdev);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn -EINVAL;\r\nif (val == 0) {\r\nwritel(0x0, pwm->mmio_base + EP93XX_PWMx_ENABLE);\r\n} else if (val <= (clk_get_rate(pwm->clk) / 2)) {\r\nu32 term, duty;\r\nval = (clk_get_rate(pwm->clk) / val) - 1;\r\nif (val > EP93XX_PWM_MAX_COUNT)\r\nval = EP93XX_PWM_MAX_COUNT;\r\nif (val < 1)\r\nval = 1;\r\nterm = readl(pwm->mmio_base + EP93XX_PWMx_TERM_COUNT);\r\nduty = ((val + 1) * pwm->duty_percent / 100) - 1;\r\nif (val > term) {\r\nwritel(val, pwm->mmio_base + EP93XX_PWMx_TERM_COUNT);\r\nwritel(duty, pwm->mmio_base + EP93XX_PWMx_DUTY_CYCLE);\r\n} else {\r\nwritel(duty, pwm->mmio_base + EP93XX_PWMx_DUTY_CYCLE);\r\nwritel(val, pwm->mmio_base + EP93XX_PWMx_TERM_COUNT);\r\n}\r\nif (!readl(pwm->mmio_base + EP93XX_PWMx_ENABLE) & 0x1)\r\nwritel(0x1, pwm->mmio_base + EP93XX_PWMx_ENABLE);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t ep93xx_pwm_get_duty_percent(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ep93xx_pwm *pwm = platform_get_drvdata(pdev);\r\nreturn sprintf(buf, "%d\n", pwm->duty_percent);\r\n}\r\nstatic ssize_t ep93xx_pwm_set_duty_percent(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ep93xx_pwm *pwm = platform_get_drvdata(pdev);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn -EINVAL;\r\nif (val > 0 && val < 100) {\r\nu32 term = readl(pwm->mmio_base + EP93XX_PWMx_TERM_COUNT);\r\nu32 duty = ((term + 1) * val / 100) - 1;\r\nwritel(duty, pwm->mmio_base + EP93XX_PWMx_DUTY_CYCLE);\r\npwm->duty_percent = val;\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t ep93xx_pwm_get_invert(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ep93xx_pwm *pwm = platform_get_drvdata(pdev);\r\nint inverted = readl(pwm->mmio_base + EP93XX_PWMx_INVERT) & 0x1;\r\nreturn sprintf(buf, "%d\n", inverted);\r\n}\r\nstatic ssize_t ep93xx_pwm_set_invert(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ep93xx_pwm *pwm = platform_get_drvdata(pdev);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn -EINVAL;\r\nif (val == 0)\r\nwritel(0x0, pwm->mmio_base + EP93XX_PWMx_INVERT);\r\nelse if (val == 1)\r\nwritel(0x1, pwm->mmio_base + EP93XX_PWMx_INVERT);\r\nelse\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic int ep93xx_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct ep93xx_pwm *pwm;\r\nstruct resource *res;\r\nint ret;\r\npwm = devm_kzalloc(&pdev->dev, sizeof(*pwm), GFP_KERNEL);\r\nif (!pwm)\r\nreturn -ENOMEM;\r\npwm->clk = devm_clk_get(&pdev->dev, "pwm_clk");\r\nif (IS_ERR(pwm->clk))\r\nreturn PTR_ERR(pwm->clk);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npwm->mmio_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pwm->mmio_base))\r\nreturn PTR_ERR(pwm->mmio_base);\r\nret = ep93xx_pwm_acquire_gpio(pdev);\r\nif (ret)\r\nreturn ret;\r\nret = sysfs_create_group(&pdev->dev.kobj, &ep93xx_pwm_sysfs_files);\r\nif (ret) {\r\nep93xx_pwm_release_gpio(pdev);\r\nreturn ret;\r\n}\r\npwm->duty_percent = 50;\r\nwritel(0x0, pwm->mmio_base + EP93XX_PWMx_ENABLE);\r\nwritel(EP93XX_PWM_MAX_COUNT, pwm->mmio_base + EP93XX_PWMx_TERM_COUNT);\r\nwritel(EP93XX_PWM_MAX_COUNT/2, pwm->mmio_base + EP93XX_PWMx_DUTY_CYCLE);\r\nclk_enable(pwm->clk);\r\nplatform_set_drvdata(pdev, pwm);\r\nreturn 0;\r\n}\r\nstatic int ep93xx_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct ep93xx_pwm *pwm = platform_get_drvdata(pdev);\r\nwritel(0x0, pwm->mmio_base + EP93XX_PWMx_ENABLE);\r\nclk_disable(pwm->clk);\r\nsysfs_remove_group(&pdev->dev.kobj, &ep93xx_pwm_sysfs_files);\r\nep93xx_pwm_release_gpio(pdev);\r\nreturn 0;\r\n}
