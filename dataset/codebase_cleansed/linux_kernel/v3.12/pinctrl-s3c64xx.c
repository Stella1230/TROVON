static int s3c64xx_irq_get_trigger(unsigned int type)\r\n{\r\nint trigger;\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\ntrigger = EINT_EDGE_RISING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ntrigger = EINT_EDGE_FALLING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\ntrigger = EINT_EDGE_BOTH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ntrigger = EINT_LEVEL_HIGH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ntrigger = EINT_LEVEL_LOW;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn trigger;\r\n}\r\nstatic void s3c64xx_irq_set_handler(unsigned int irq, unsigned int type)\r\n{\r\nif (type & IRQ_TYPE_EDGE_BOTH)\r\n__irq_set_handler_locked(irq, handle_edge_irq);\r\nelse\r\n__irq_set_handler_locked(irq, handle_level_irq);\r\n}\r\nstatic void s3c64xx_irq_set_function(struct samsung_pinctrl_drv_data *d,\r\nstruct samsung_pin_bank *bank, int pin)\r\n{\r\nstruct samsung_pin_bank_type *bank_type = bank->type;\r\nunsigned long flags;\r\nvoid __iomem *reg;\r\nu8 shift;\r\nu32 mask;\r\nu32 val;\r\nreg = d->virt_base + bank->pctl_offset;\r\nshift = pin;\r\nif (bank_type->fld_width[PINCFG_TYPE_FUNC] * shift >= 32) {\r\nreg += 4;\r\nshift -= 8;\r\n}\r\nshift = shift * bank_type->fld_width[PINCFG_TYPE_FUNC];\r\nmask = (1 << bank_type->fld_width[PINCFG_TYPE_FUNC]) - 1;\r\nspin_lock_irqsave(&bank->slock, flags);\r\nval = readl(reg);\r\nval &= ~(mask << shift);\r\nval |= bank->eint_func << shift;\r\nwritel(val, reg);\r\nspin_unlock_irqrestore(&bank->slock, flags);\r\n}\r\nstatic inline void s3c64xx_gpio_irq_set_mask(struct irq_data *irqd, bool mask)\r\n{\r\nstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\r\nstruct samsung_pinctrl_drv_data *d = bank->drvdata;\r\nunsigned char index = EINT_OFFS(bank->eint_offset) + irqd->hwirq;\r\nvoid __iomem *reg = d->virt_base + EINTMASK_REG(bank->eint_offset);\r\nu32 val;\r\nval = readl(reg);\r\nif (mask)\r\nval |= 1 << index;\r\nelse\r\nval &= ~(1 << index);\r\nwritel(val, reg);\r\n}\r\nstatic void s3c64xx_gpio_irq_unmask(struct irq_data *irqd)\r\n{\r\ns3c64xx_gpio_irq_set_mask(irqd, false);\r\n}\r\nstatic void s3c64xx_gpio_irq_mask(struct irq_data *irqd)\r\n{\r\ns3c64xx_gpio_irq_set_mask(irqd, true);\r\n}\r\nstatic void s3c64xx_gpio_irq_ack(struct irq_data *irqd)\r\n{\r\nstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\r\nstruct samsung_pinctrl_drv_data *d = bank->drvdata;\r\nunsigned char index = EINT_OFFS(bank->eint_offset) + irqd->hwirq;\r\nvoid __iomem *reg = d->virt_base + EINTPEND_REG(bank->eint_offset);\r\nwritel(1 << index, reg);\r\n}\r\nstatic int s3c64xx_gpio_irq_set_type(struct irq_data *irqd, unsigned int type)\r\n{\r\nstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\r\nstruct samsung_pinctrl_drv_data *d = bank->drvdata;\r\nvoid __iomem *reg;\r\nint trigger;\r\nu8 shift;\r\nu32 val;\r\ntrigger = s3c64xx_irq_get_trigger(type);\r\nif (trigger < 0) {\r\npr_err("unsupported external interrupt type\n");\r\nreturn -EINVAL;\r\n}\r\ns3c64xx_irq_set_handler(irqd->irq, type);\r\nreg = d->virt_base + EINTCON_REG(bank->eint_offset);\r\nshift = EINT_OFFS(bank->eint_offset) + irqd->hwirq;\r\nshift = 4 * (shift / 4);\r\nval = readl(reg);\r\nval &= ~(EINT_CON_MASK << shift);\r\nval |= trigger << shift;\r\nwritel(val, reg);\r\ns3c64xx_irq_set_function(d, bank, irqd->hwirq);\r\nreturn 0;\r\n}\r\nstatic int s3c64xx_gpio_irq_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct samsung_pin_bank *bank = h->host_data;\r\nif (!(bank->eint_mask & (1 << hw)))\r\nreturn -EINVAL;\r\nirq_set_chip_and_handler(virq,\r\n&s3c64xx_gpio_irq_chip, handle_level_irq);\r\nirq_set_chip_data(virq, bank);\r\nset_irq_flags(virq, IRQF_VALID);\r\nreturn 0;\r\n}\r\nstatic void s3c64xx_eint_gpio_irq(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_get_chip(irq);\r\nstruct s3c64xx_eint_gpio_data *data = irq_get_handler_data(irq);\r\nstruct samsung_pinctrl_drv_data *drvdata = data->drvdata;\r\nchained_irq_enter(chip, desc);\r\ndo {\r\nunsigned int svc;\r\nunsigned int group;\r\nunsigned int pin;\r\nunsigned int virq;\r\nsvc = readl(drvdata->virt_base + SERVICE_REG);\r\ngroup = SVC_GROUP(svc);\r\npin = svc & SVC_NUM_MASK;\r\nif (!group)\r\nbreak;\r\nif (group == 1) {\r\nif (pin < 8)\r\ngroup = 0;\r\nelse\r\npin -= 8;\r\n}\r\nvirq = irq_linear_revmap(data->domains[group], pin);\r\nBUG_ON(!virq);\r\ngeneric_handle_irq(virq);\r\n} while (1);\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int s3c64xx_eint_gpio_init(struct samsung_pinctrl_drv_data *d)\r\n{\r\nstruct s3c64xx_eint_gpio_data *data;\r\nstruct samsung_pin_bank *bank;\r\nstruct device *dev = d->dev;\r\nunsigned int nr_domains;\r\nunsigned int i;\r\nif (!d->irq) {\r\ndev_err(dev, "irq number not available\n");\r\nreturn -EINVAL;\r\n}\r\nnr_domains = 0;\r\nbank = d->ctrl->pin_banks;\r\nfor (i = 0; i < d->ctrl->nr_banks; ++i, ++bank) {\r\nunsigned int nr_eints;\r\nunsigned int mask;\r\nif (bank->eint_type != EINT_TYPE_GPIO)\r\ncontinue;\r\nmask = bank->eint_mask;\r\nnr_eints = fls(mask);\r\nbank->irq_domain = irq_domain_add_linear(bank->of_node,\r\nnr_eints, &s3c64xx_gpio_irqd_ops, bank);\r\nif (!bank->irq_domain) {\r\ndev_err(dev, "gpio irq domain add failed\n");\r\nreturn -ENXIO;\r\n}\r\n++nr_domains;\r\n}\r\ndata = devm_kzalloc(dev, sizeof(*data)\r\n+ nr_domains * sizeof(*data->domains), GFP_KERNEL);\r\nif (!data) {\r\ndev_err(dev, "failed to allocate handler data\n");\r\nreturn -ENOMEM;\r\n}\r\ndata->drvdata = d;\r\nbank = d->ctrl->pin_banks;\r\nnr_domains = 0;\r\nfor (i = 0; i < d->ctrl->nr_banks; ++i, ++bank) {\r\nif (bank->eint_type != EINT_TYPE_GPIO)\r\ncontinue;\r\ndata->domains[nr_domains++] = bank->irq_domain;\r\n}\r\nirq_set_chained_handler(d->irq, s3c64xx_eint_gpio_irq);\r\nirq_set_handler_data(d->irq, data);\r\nreturn 0;\r\n}\r\nstatic inline void s3c64xx_eint0_irq_set_mask(struct irq_data *irqd, bool mask)\r\n{\r\nstruct s3c64xx_eint0_domain_data *ddata =\r\nirq_data_get_irq_chip_data(irqd);\r\nstruct samsung_pinctrl_drv_data *d = ddata->bank->drvdata;\r\nu32 val;\r\nval = readl(d->virt_base + EINT0MASK_REG);\r\nif (mask)\r\nval |= 1 << ddata->eints[irqd->hwirq];\r\nelse\r\nval &= ~(1 << ddata->eints[irqd->hwirq]);\r\nwritel(val, d->virt_base + EINT0MASK_REG);\r\n}\r\nstatic void s3c64xx_eint0_irq_unmask(struct irq_data *irqd)\r\n{\r\ns3c64xx_eint0_irq_set_mask(irqd, false);\r\n}\r\nstatic void s3c64xx_eint0_irq_mask(struct irq_data *irqd)\r\n{\r\ns3c64xx_eint0_irq_set_mask(irqd, true);\r\n}\r\nstatic void s3c64xx_eint0_irq_ack(struct irq_data *irqd)\r\n{\r\nstruct s3c64xx_eint0_domain_data *ddata =\r\nirq_data_get_irq_chip_data(irqd);\r\nstruct samsung_pinctrl_drv_data *d = ddata->bank->drvdata;\r\nwritel(1 << ddata->eints[irqd->hwirq],\r\nd->virt_base + EINT0PEND_REG);\r\n}\r\nstatic int s3c64xx_eint0_irq_set_type(struct irq_data *irqd, unsigned int type)\r\n{\r\nstruct s3c64xx_eint0_domain_data *ddata =\r\nirq_data_get_irq_chip_data(irqd);\r\nstruct samsung_pin_bank *bank = ddata->bank;\r\nstruct samsung_pinctrl_drv_data *d = bank->drvdata;\r\nvoid __iomem *reg;\r\nint trigger;\r\nu8 shift;\r\nu32 val;\r\ntrigger = s3c64xx_irq_get_trigger(type);\r\nif (trigger < 0) {\r\npr_err("unsupported external interrupt type\n");\r\nreturn -EINVAL;\r\n}\r\ns3c64xx_irq_set_handler(irqd->irq, type);\r\nreg = d->virt_base + EINT0CON0_REG;\r\nshift = ddata->eints[irqd->hwirq];\r\nif (shift >= EINT_MAX_PER_REG) {\r\nreg += 4;\r\nshift -= EINT_MAX_PER_REG;\r\n}\r\nshift = EINT_CON_LEN * (shift / 2);\r\nval = readl(reg);\r\nval &= ~(EINT_CON_MASK << shift);\r\nval |= trigger << shift;\r\nwritel(val, reg);\r\ns3c64xx_irq_set_function(d, bank, irqd->hwirq);\r\nreturn 0;\r\n}\r\nstatic inline void s3c64xx_irq_demux_eint(unsigned int irq,\r\nstruct irq_desc *desc, u32 range)\r\n{\r\nstruct irq_chip *chip = irq_get_chip(irq);\r\nstruct s3c64xx_eint0_data *data = irq_get_handler_data(irq);\r\nstruct samsung_pinctrl_drv_data *drvdata = data->drvdata;\r\nunsigned int pend, mask;\r\nchained_irq_enter(chip, desc);\r\npend = readl(drvdata->virt_base + EINT0PEND_REG);\r\nmask = readl(drvdata->virt_base + EINT0MASK_REG);\r\npend = pend & range & ~mask;\r\npend &= range;\r\nwhile (pend) {\r\nunsigned int virq;\r\nirq = fls(pend) - 1;\r\npend &= ~(1 << irq);\r\nvirq = irq_linear_revmap(data->domains[irq], data->pins[irq]);\r\nBUG_ON(!virq);\r\ngeneric_handle_irq(virq);\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void s3c64xx_demux_eint0_3(unsigned int irq, struct irq_desc *desc)\r\n{\r\ns3c64xx_irq_demux_eint(irq, desc, 0xf);\r\n}\r\nstatic void s3c64xx_demux_eint4_11(unsigned int irq, struct irq_desc *desc)\r\n{\r\ns3c64xx_irq_demux_eint(irq, desc, 0xff0);\r\n}\r\nstatic void s3c64xx_demux_eint12_19(unsigned int irq, struct irq_desc *desc)\r\n{\r\ns3c64xx_irq_demux_eint(irq, desc, 0xff000);\r\n}\r\nstatic void s3c64xx_demux_eint20_27(unsigned int irq, struct irq_desc *desc)\r\n{\r\ns3c64xx_irq_demux_eint(irq, desc, 0xff00000);\r\n}\r\nstatic int s3c64xx_eint0_irq_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct s3c64xx_eint0_domain_data *ddata = h->host_data;\r\nstruct samsung_pin_bank *bank = ddata->bank;\r\nif (!(bank->eint_mask & (1 << hw)))\r\nreturn -EINVAL;\r\nirq_set_chip_and_handler(virq,\r\n&s3c64xx_eint0_irq_chip, handle_level_irq);\r\nirq_set_chip_data(virq, ddata);\r\nset_irq_flags(virq, IRQF_VALID);\r\nreturn 0;\r\n}\r\nstatic int s3c64xx_eint_eint0_init(struct samsung_pinctrl_drv_data *d)\r\n{\r\nstruct device *dev = d->dev;\r\nstruct device_node *eint0_np = NULL;\r\nstruct device_node *np;\r\nstruct samsung_pin_bank *bank;\r\nstruct s3c64xx_eint0_data *data;\r\nunsigned int i;\r\nfor_each_child_of_node(dev->of_node, np) {\r\nif (of_match_node(s3c64xx_eint0_irq_ids, np)) {\r\neint0_np = np;\r\nbreak;\r\n}\r\n}\r\nif (!eint0_np)\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data) {\r\ndev_err(dev, "could not allocate memory for wkup eint data\n");\r\nreturn -ENOMEM;\r\n}\r\ndata->drvdata = d;\r\nfor (i = 0; i < NUM_EINT0_IRQ; ++i) {\r\nunsigned int irq;\r\nirq = irq_of_parse_and_map(eint0_np, i);\r\nif (!irq) {\r\ndev_err(dev, "failed to get wakeup EINT IRQ %d\n", i);\r\nreturn -ENXIO;\r\n}\r\nirq_set_chained_handler(irq, s3c64xx_eint0_handlers[i]);\r\nirq_set_handler_data(irq, data);\r\n}\r\nbank = d->ctrl->pin_banks;\r\nfor (i = 0; i < d->ctrl->nr_banks; ++i, ++bank) {\r\nstruct s3c64xx_eint0_domain_data *ddata;\r\nunsigned int nr_eints;\r\nunsigned int mask;\r\nunsigned int irq;\r\nunsigned int pin;\r\nif (bank->eint_type != EINT_TYPE_WKUP)\r\ncontinue;\r\nmask = bank->eint_mask;\r\nnr_eints = fls(mask);\r\nddata = devm_kzalloc(dev,\r\nsizeof(*ddata) + nr_eints, GFP_KERNEL);\r\nif (!ddata) {\r\ndev_err(dev, "failed to allocate domain data\n");\r\nreturn -ENOMEM;\r\n}\r\nddata->bank = bank;\r\nbank->irq_domain = irq_domain_add_linear(bank->of_node,\r\nnr_eints, &s3c64xx_eint0_irqd_ops, ddata);\r\nif (!bank->irq_domain) {\r\ndev_err(dev, "wkup irq domain add failed\n");\r\nreturn -ENXIO;\r\n}\r\nirq = bank->eint_offset;\r\nmask = bank->eint_mask;\r\nfor (pin = 0; mask; ++pin, mask >>= 1) {\r\nif (!(mask & 1))\r\ncontinue;\r\ndata->domains[irq] = bank->irq_domain;\r\ndata->pins[irq] = pin;\r\nddata->eints[pin] = irq;\r\n++irq;\r\n}\r\n}\r\nreturn 0;\r\n}
