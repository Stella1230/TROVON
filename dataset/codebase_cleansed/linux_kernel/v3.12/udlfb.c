static char *dlfb_set_register(char *buf, u8 reg, u8 val)\r\n{\r\n*buf++ = 0xAF;\r\n*buf++ = 0x20;\r\n*buf++ = reg;\r\n*buf++ = val;\r\nreturn buf;\r\n}\r\nstatic char *dlfb_vidreg_lock(char *buf)\r\n{\r\nreturn dlfb_set_register(buf, 0xFF, 0x00);\r\n}\r\nstatic char *dlfb_vidreg_unlock(char *buf)\r\n{\r\nreturn dlfb_set_register(buf, 0xFF, 0xFF);\r\n}\r\nstatic char *dlfb_blanking(char *buf, int fb_blank)\r\n{\r\nu8 reg;\r\nswitch (fb_blank) {\r\ncase FB_BLANK_POWERDOWN:\r\nreg = 0x07;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nreg = 0x05;\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nreg = 0x03;\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\nreg = 0x01;\r\nbreak;\r\ndefault:\r\nreg = 0x00;\r\n}\r\nbuf = dlfb_set_register(buf, 0x1F, reg);\r\nreturn buf;\r\n}\r\nstatic char *dlfb_set_color_depth(char *buf, u8 selection)\r\n{\r\nreturn dlfb_set_register(buf, 0x00, selection);\r\n}\r\nstatic char *dlfb_set_base16bpp(char *wrptr, u32 base)\r\n{\r\nwrptr = dlfb_set_register(wrptr, 0x20, base >> 16);\r\nwrptr = dlfb_set_register(wrptr, 0x21, base >> 8);\r\nreturn dlfb_set_register(wrptr, 0x22, base);\r\n}\r\nstatic char *dlfb_set_base8bpp(char *wrptr, u32 base)\r\n{\r\nwrptr = dlfb_set_register(wrptr, 0x26, base >> 16);\r\nwrptr = dlfb_set_register(wrptr, 0x27, base >> 8);\r\nreturn dlfb_set_register(wrptr, 0x28, base);\r\n}\r\nstatic char *dlfb_set_register_16(char *wrptr, u8 reg, u16 value)\r\n{\r\nwrptr = dlfb_set_register(wrptr, reg, value >> 8);\r\nreturn dlfb_set_register(wrptr, reg+1, value);\r\n}\r\nstatic char *dlfb_set_register_16be(char *wrptr, u8 reg, u16 value)\r\n{\r\nwrptr = dlfb_set_register(wrptr, reg, value);\r\nreturn dlfb_set_register(wrptr, reg+1, value >> 8);\r\n}\r\nstatic u16 dlfb_lfsr16(u16 actual_count)\r\n{\r\nu32 lv = 0xFFFF;\r\nwhile (actual_count--) {\r\nlv = ((lv << 1) |\r\n(((lv >> 15) ^ (lv >> 4) ^ (lv >> 2) ^ (lv >> 1)) & 1))\r\n& 0xFFFF;\r\n}\r\nreturn (u16) lv;\r\n}\r\nstatic char *dlfb_set_register_lfsr16(char *wrptr, u8 reg, u16 value)\r\n{\r\nreturn dlfb_set_register_16(wrptr, reg, dlfb_lfsr16(value));\r\n}\r\nstatic char *dlfb_set_vid_cmds(char *wrptr, struct fb_var_screeninfo *var)\r\n{\r\nu16 xds, yds;\r\nu16 xde, yde;\r\nu16 yec;\r\nxds = var->left_margin + var->hsync_len;\r\nwrptr = dlfb_set_register_lfsr16(wrptr, 0x01, xds);\r\nxde = xds + var->xres;\r\nwrptr = dlfb_set_register_lfsr16(wrptr, 0x03, xde);\r\nyds = var->upper_margin + var->vsync_len;\r\nwrptr = dlfb_set_register_lfsr16(wrptr, 0x05, yds);\r\nyde = yds + var->yres;\r\nwrptr = dlfb_set_register_lfsr16(wrptr, 0x07, yde);\r\nwrptr = dlfb_set_register_lfsr16(wrptr, 0x09,\r\nxde + var->right_margin - 1);\r\nwrptr = dlfb_set_register_lfsr16(wrptr, 0x0B, 1);\r\nwrptr = dlfb_set_register_lfsr16(wrptr, 0x0D, var->hsync_len + 1);\r\nwrptr = dlfb_set_register_16(wrptr, 0x0F, var->xres);\r\nyec = var->yres + var->upper_margin + var->lower_margin +\r\nvar->vsync_len;\r\nwrptr = dlfb_set_register_lfsr16(wrptr, 0x11, yec);\r\nwrptr = dlfb_set_register_lfsr16(wrptr, 0x13, 0);\r\nwrptr = dlfb_set_register_lfsr16(wrptr, 0x15, var->vsync_len);\r\nwrptr = dlfb_set_register_16(wrptr, 0x17, var->yres);\r\nwrptr = dlfb_set_register_16be(wrptr, 0x1B,\r\n200*1000*1000/var->pixclock);\r\nreturn wrptr;\r\n}\r\nstatic int dlfb_set_video_mode(struct dlfb_data *dev,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nchar *buf;\r\nchar *wrptr;\r\nint retval = 0;\r\nint writesize;\r\nstruct urb *urb;\r\nif (!atomic_read(&dev->usb_active))\r\nreturn -EPERM;\r\nurb = dlfb_get_urb(dev);\r\nif (!urb)\r\nreturn -ENOMEM;\r\nbuf = (char *) urb->transfer_buffer;\r\nwrptr = dlfb_vidreg_lock(buf);\r\nwrptr = dlfb_set_color_depth(wrptr, 0x00);\r\nwrptr = dlfb_set_base16bpp(wrptr, 0);\r\nwrptr = dlfb_set_base8bpp(wrptr, dev->info->fix.smem_len);\r\nwrptr = dlfb_set_vid_cmds(wrptr, var);\r\nwrptr = dlfb_blanking(wrptr, FB_BLANK_UNBLANK);\r\nwrptr = dlfb_vidreg_unlock(wrptr);\r\nwritesize = wrptr - buf;\r\nretval = dlfb_submit_urb(dev, urb, writesize);\r\ndev->blank_mode = FB_BLANK_UNBLANK;\r\nreturn retval;\r\n}\r\nstatic int dlfb_ops_mmap(struct fb_info *info, struct vm_area_struct *vma)\r\n{\r\nunsigned long start = vma->vm_start;\r\nunsigned long size = vma->vm_end - vma->vm_start;\r\nunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\r\nunsigned long page, pos;\r\nif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\r\nreturn -EINVAL;\r\nif (size > info->fix.smem_len)\r\nreturn -EINVAL;\r\nif (offset > info->fix.smem_len - size)\r\nreturn -EINVAL;\r\npos = (unsigned long)info->fix.smem_start + offset;\r\npr_notice("mmap() framebuffer addr:%lu size:%lu\n",\r\npos, size);\r\nwhile (size > 0) {\r\npage = vmalloc_to_pfn((void *)pos);\r\nif (remap_pfn_range(vma, start, page, PAGE_SIZE, PAGE_SHARED))\r\nreturn -EAGAIN;\r\nstart += PAGE_SIZE;\r\npos += PAGE_SIZE;\r\nif (size > PAGE_SIZE)\r\nsize -= PAGE_SIZE;\r\nelse\r\nsize = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dlfb_trim_hline(const u8 *bback, const u8 **bfront, int *width_bytes)\r\n{\r\nint j, k;\r\nconst unsigned long *back = (const unsigned long *) bback;\r\nconst unsigned long *front = (const unsigned long *) *bfront;\r\nconst int width = *width_bytes / sizeof(unsigned long);\r\nint identical = width;\r\nint start = width;\r\nint end = width;\r\nprefetch((void *) front);\r\nprefetch((void *) back);\r\nfor (j = 0; j < width; j++) {\r\nif (back[j] != front[j]) {\r\nstart = j;\r\nbreak;\r\n}\r\n}\r\nfor (k = width - 1; k > j; k--) {\r\nif (back[k] != front[k]) {\r\nend = k+1;\r\nbreak;\r\n}\r\n}\r\nidentical = start + (width - end);\r\n*bfront = (u8 *) &front[start];\r\n*width_bytes = (end - start) * sizeof(unsigned long);\r\nreturn identical * sizeof(unsigned long);\r\n}\r\nstatic void dlfb_compress_hline(\r\nconst uint16_t **pixel_start_ptr,\r\nconst uint16_t *const pixel_end,\r\nuint32_t *device_address_ptr,\r\nuint8_t **command_buffer_ptr,\r\nconst uint8_t *const cmd_buffer_end)\r\n{\r\nconst uint16_t *pixel = *pixel_start_ptr;\r\nuint32_t dev_addr = *device_address_ptr;\r\nuint8_t *cmd = *command_buffer_ptr;\r\nconst int bpp = 2;\r\nwhile ((pixel_end > pixel) &&\r\n(cmd_buffer_end - MIN_RLX_CMD_BYTES > cmd)) {\r\nuint8_t *raw_pixels_count_byte = NULL;\r\nuint8_t *cmd_pixels_count_byte = NULL;\r\nconst uint16_t *raw_pixel_start = NULL;\r\nconst uint16_t *cmd_pixel_start, *cmd_pixel_end = NULL;\r\nprefetchw((void *) cmd);\r\n*cmd++ = 0xAF;\r\n*cmd++ = 0x6B;\r\n*cmd++ = (uint8_t) ((dev_addr >> 16) & 0xFF);\r\n*cmd++ = (uint8_t) ((dev_addr >> 8) & 0xFF);\r\n*cmd++ = (uint8_t) ((dev_addr) & 0xFF);\r\ncmd_pixels_count_byte = cmd++;\r\ncmd_pixel_start = pixel;\r\nraw_pixels_count_byte = cmd++;\r\nraw_pixel_start = pixel;\r\ncmd_pixel_end = pixel + min(MAX_CMD_PIXELS + 1,\r\nmin((int)(pixel_end - pixel),\r\n(int)(cmd_buffer_end - cmd) / bpp));\r\nprefetch_range((void *) pixel, (cmd_pixel_end - pixel) * bpp);\r\nwhile (pixel < cmd_pixel_end) {\r\nconst uint16_t * const repeating_pixel = pixel;\r\n*(uint16_t *)cmd = cpu_to_be16p(pixel);\r\ncmd += 2;\r\npixel++;\r\nif (unlikely((pixel < cmd_pixel_end) &&\r\n(*pixel == *repeating_pixel))) {\r\n*raw_pixels_count_byte = ((repeating_pixel -\r\nraw_pixel_start) + 1) & 0xFF;\r\nwhile ((pixel < cmd_pixel_end)\r\n&& (*pixel == *repeating_pixel)) {\r\npixel++;\r\n}\r\n*cmd++ = ((pixel - repeating_pixel) - 1) & 0xFF;\r\nraw_pixel_start = pixel;\r\nraw_pixels_count_byte = cmd++;\r\n}\r\n}\r\nif (pixel > raw_pixel_start) {\r\n*raw_pixels_count_byte = (pixel-raw_pixel_start) & 0xFF;\r\n}\r\n*cmd_pixels_count_byte = (pixel - cmd_pixel_start) & 0xFF;\r\ndev_addr += (pixel - cmd_pixel_start) * bpp;\r\n}\r\nif (cmd_buffer_end <= MIN_RLX_CMD_BYTES + cmd) {\r\nif (cmd_buffer_end > cmd)\r\nmemset(cmd, 0xAF, cmd_buffer_end - cmd);\r\ncmd = (uint8_t *) cmd_buffer_end;\r\n}\r\n*command_buffer_ptr = cmd;\r\n*pixel_start_ptr = pixel;\r\n*device_address_ptr = dev_addr;\r\nreturn;\r\n}\r\nstatic int dlfb_render_hline(struct dlfb_data *dev, struct urb **urb_ptr,\r\nconst char *front, char **urb_buf_ptr,\r\nu32 byte_offset, u32 byte_width,\r\nint *ident_ptr, int *sent_ptr)\r\n{\r\nconst u8 *line_start, *line_end, *next_pixel;\r\nu32 dev_addr = dev->base16 + byte_offset;\r\nstruct urb *urb = *urb_ptr;\r\nu8 *cmd = *urb_buf_ptr;\r\nu8 *cmd_end = (u8 *) urb->transfer_buffer + urb->transfer_buffer_length;\r\nline_start = (u8 *) (front + byte_offset);\r\nnext_pixel = line_start;\r\nline_end = next_pixel + byte_width;\r\nif (dev->backing_buffer) {\r\nint offset;\r\nconst u8 *back_start = (u8 *) (dev->backing_buffer\r\n+ byte_offset);\r\n*ident_ptr += dlfb_trim_hline(back_start, &next_pixel,\r\n&byte_width);\r\noffset = next_pixel - line_start;\r\nline_end = next_pixel + byte_width;\r\ndev_addr += offset;\r\nback_start += offset;\r\nline_start += offset;\r\nmemcpy((char *)back_start, (char *) line_start,\r\nbyte_width);\r\n}\r\nwhile (next_pixel < line_end) {\r\ndlfb_compress_hline((const uint16_t **) &next_pixel,\r\n(const uint16_t *) line_end, &dev_addr,\r\n(u8 **) &cmd, (u8 *) cmd_end);\r\nif (cmd >= cmd_end) {\r\nint len = cmd - (u8 *) urb->transfer_buffer;\r\nif (dlfb_submit_urb(dev, urb, len))\r\nreturn 1;\r\n*sent_ptr += len;\r\nurb = dlfb_get_urb(dev);\r\nif (!urb)\r\nreturn 1;\r\n*urb_ptr = urb;\r\ncmd = urb->transfer_buffer;\r\ncmd_end = &cmd[urb->transfer_buffer_length];\r\n}\r\n}\r\n*urb_buf_ptr = cmd;\r\nreturn 0;\r\n}\r\nstatic int dlfb_handle_damage(struct dlfb_data *dev, int x, int y,\r\nint width, int height, char *data)\r\n{\r\nint i, ret;\r\nchar *cmd;\r\ncycles_t start_cycles, end_cycles;\r\nint bytes_sent = 0;\r\nint bytes_identical = 0;\r\nstruct urb *urb;\r\nint aligned_x;\r\nstart_cycles = get_cycles();\r\naligned_x = DL_ALIGN_DOWN(x, sizeof(unsigned long));\r\nwidth = DL_ALIGN_UP(width + (x-aligned_x), sizeof(unsigned long));\r\nx = aligned_x;\r\nif ((width <= 0) ||\r\n(x + width > dev->info->var.xres) ||\r\n(y + height > dev->info->var.yres))\r\nreturn -EINVAL;\r\nif (!atomic_read(&dev->usb_active))\r\nreturn 0;\r\nurb = dlfb_get_urb(dev);\r\nif (!urb)\r\nreturn 0;\r\ncmd = urb->transfer_buffer;\r\nfor (i = y; i < y + height ; i++) {\r\nconst int line_offset = dev->info->fix.line_length * i;\r\nconst int byte_offset = line_offset + (x * BPP);\r\nif (dlfb_render_hline(dev, &urb,\r\n(char *) dev->info->fix.smem_start,\r\n&cmd, byte_offset, width * BPP,\r\n&bytes_identical, &bytes_sent))\r\ngoto error;\r\n}\r\nif (cmd > (char *) urb->transfer_buffer) {\r\nint len = cmd - (char *) urb->transfer_buffer;\r\nret = dlfb_submit_urb(dev, urb, len);\r\nbytes_sent += len;\r\n} else\r\ndlfb_urb_completion(urb);\r\nerror:\r\natomic_add(bytes_sent, &dev->bytes_sent);\r\natomic_add(bytes_identical, &dev->bytes_identical);\r\natomic_add(width*height*2, &dev->bytes_rendered);\r\nend_cycles = get_cycles();\r\natomic_add(((unsigned int) ((end_cycles - start_cycles)\r\n>> 10)),\r\n&dev->cpu_kcycles_used);\r\nreturn 0;\r\n}\r\nstatic ssize_t dlfb_ops_write(struct fb_info *info, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nssize_t result;\r\nstruct dlfb_data *dev = info->par;\r\nu32 offset = (u32) *ppos;\r\nresult = fb_sys_write(info, buf, count, ppos);\r\nif (result > 0) {\r\nint start = max((int)(offset / info->fix.line_length), 0);\r\nint lines = min((u32)((result / info->fix.line_length) + 1),\r\n(u32)info->var.yres);\r\ndlfb_handle_damage(dev, 0, start, info->var.xres,\r\nlines, info->screen_base);\r\n}\r\nreturn result;\r\n}\r\nstatic void dlfb_ops_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nstruct dlfb_data *dev = info->par;\r\nsys_copyarea(info, area);\r\ndlfb_handle_damage(dev, area->dx, area->dy,\r\narea->width, area->height, info->screen_base);\r\n}\r\nstatic void dlfb_ops_imageblit(struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nstruct dlfb_data *dev = info->par;\r\nsys_imageblit(info, image);\r\ndlfb_handle_damage(dev, image->dx, image->dy,\r\nimage->width, image->height, info->screen_base);\r\n}\r\nstatic void dlfb_ops_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *rect)\r\n{\r\nstruct dlfb_data *dev = info->par;\r\nsys_fillrect(info, rect);\r\ndlfb_handle_damage(dev, rect->dx, rect->dy, rect->width,\r\nrect->height, info->screen_base);\r\n}\r\nstatic void dlfb_dpy_deferred_io(struct fb_info *info,\r\nstruct list_head *pagelist)\r\n{\r\nstruct page *cur;\r\nstruct fb_deferred_io *fbdefio = info->fbdefio;\r\nstruct dlfb_data *dev = info->par;\r\nstruct urb *urb;\r\nchar *cmd;\r\ncycles_t start_cycles, end_cycles;\r\nint bytes_sent = 0;\r\nint bytes_identical = 0;\r\nint bytes_rendered = 0;\r\nif (!fb_defio)\r\nreturn;\r\nif (!atomic_read(&dev->usb_active))\r\nreturn;\r\nstart_cycles = get_cycles();\r\nurb = dlfb_get_urb(dev);\r\nif (!urb)\r\nreturn;\r\ncmd = urb->transfer_buffer;\r\nlist_for_each_entry(cur, &fbdefio->pagelist, lru) {\r\nif (dlfb_render_hline(dev, &urb, (char *) info->fix.smem_start,\r\n&cmd, cur->index << PAGE_SHIFT,\r\nPAGE_SIZE, &bytes_identical, &bytes_sent))\r\ngoto error;\r\nbytes_rendered += PAGE_SIZE;\r\n}\r\nif (cmd > (char *) urb->transfer_buffer) {\r\nint len = cmd - (char *) urb->transfer_buffer;\r\ndlfb_submit_urb(dev, urb, len);\r\nbytes_sent += len;\r\n} else\r\ndlfb_urb_completion(urb);\r\nerror:\r\natomic_add(bytes_sent, &dev->bytes_sent);\r\natomic_add(bytes_identical, &dev->bytes_identical);\r\natomic_add(bytes_rendered, &dev->bytes_rendered);\r\nend_cycles = get_cycles();\r\natomic_add(((unsigned int) ((end_cycles - start_cycles)\r\n>> 10)),\r\n&dev->cpu_kcycles_used);\r\n}\r\nstatic int dlfb_get_edid(struct dlfb_data *dev, char *edid, int len)\r\n{\r\nint i;\r\nint ret;\r\nchar *rbuf;\r\nrbuf = kmalloc(2, GFP_KERNEL);\r\nif (!rbuf)\r\nreturn 0;\r\nfor (i = 0; i < len; i++) {\r\nret = usb_control_msg(dev->udev,\r\nusb_rcvctrlpipe(dev->udev, 0), (0x02),\r\n(0x80 | (0x02 << 5)), i << 8, 0xA1, rbuf, 2,\r\nHZ);\r\nif (ret < 1) {\r\npr_err("Read EDID byte %d failed err %x\n", i, ret);\r\ni--;\r\nbreak;\r\n}\r\nedid[i] = rbuf[1];\r\n}\r\nkfree(rbuf);\r\nreturn i;\r\n}\r\nstatic int dlfb_ops_ioctl(struct fb_info *info, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct dlfb_data *dev = info->par;\r\nif (!atomic_read(&dev->usb_active))\r\nreturn 0;\r\nif (cmd == DLFB_IOCTL_RETURN_EDID) {\r\nvoid __user *edid = (void __user *)arg;\r\nif (copy_to_user(edid, dev->edid, dev->edid_size))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nif (cmd == DLFB_IOCTL_REPORT_DAMAGE) {\r\nstruct dloarea area;\r\nif (copy_from_user(&area, (void __user *)arg,\r\nsizeof(struct dloarea)))\r\nreturn -EFAULT;\r\nif (info->fbdefio)\r\ninfo->fbdefio->delay = DL_DEFIO_WRITE_DISABLE;\r\nif (area.x < 0)\r\narea.x = 0;\r\nif (area.x > info->var.xres)\r\narea.x = info->var.xres;\r\nif (area.y < 0)\r\narea.y = 0;\r\nif (area.y > info->var.yres)\r\narea.y = info->var.yres;\r\ndlfb_handle_damage(dev, area.x, area.y, area.w, area.h,\r\ninfo->screen_base);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ndlfb_ops_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp, struct fb_info *info)\r\n{\r\nint err = 0;\r\nif (regno >= info->cmap.len)\r\nreturn 1;\r\nif (regno < 16) {\r\nif (info->var.red.offset == 10) {\r\n((u32 *) (info->pseudo_palette))[regno] =\r\n((red & 0xf800) >> 1) |\r\n((green & 0xf800) >> 6) | ((blue & 0xf800) >> 11);\r\n} else {\r\n((u32 *) (info->pseudo_palette))[regno] =\r\n((red & 0xf800)) |\r\n((green & 0xfc00) >> 5) | ((blue & 0xf800) >> 11);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int dlfb_ops_open(struct fb_info *info, int user)\r\n{\r\nstruct dlfb_data *dev = info->par;\r\nif ((user == 0) && (!console))\r\nreturn -EBUSY;\r\nif (dev->virtualized)\r\nreturn -ENODEV;\r\ndev->fb_count++;\r\nkref_get(&dev->kref);\r\nif (fb_defio && (info->fbdefio == NULL)) {\r\nstruct fb_deferred_io *fbdefio;\r\nfbdefio = kzalloc(sizeof(struct fb_deferred_io), GFP_KERNEL);\r\nif (fbdefio) {\r\nfbdefio->delay = DL_DEFIO_WRITE_DELAY;\r\nfbdefio->deferred_io = dlfb_dpy_deferred_io;\r\n}\r\ninfo->fbdefio = fbdefio;\r\nfb_deferred_io_init(info);\r\n}\r\npr_notice("open /dev/fb%d user=%d fb_info=%p count=%d\n",\r\ninfo->node, user, info, dev->fb_count);\r\nreturn 0;\r\n}\r\nstatic void dlfb_free(struct kref *kref)\r\n{\r\nstruct dlfb_data *dev = container_of(kref, struct dlfb_data, kref);\r\nif (dev->backing_buffer)\r\nvfree(dev->backing_buffer);\r\nkfree(dev->edid);\r\npr_warn("freeing dlfb_data %p\n", dev);\r\nkfree(dev);\r\n}\r\nstatic void dlfb_release_urb_work(struct work_struct *work)\r\n{\r\nstruct urb_node *unode = container_of(work, struct urb_node,\r\nrelease_urb_work.work);\r\nup(&unode->dev->urbs.limit_sem);\r\n}\r\nstatic void dlfb_free_framebuffer(struct dlfb_data *dev)\r\n{\r\nstruct fb_info *info = dev->info;\r\nif (info) {\r\nint node = info->node;\r\nunregister_framebuffer(info);\r\nif (info->cmap.len != 0)\r\nfb_dealloc_cmap(&info->cmap);\r\nif (info->monspecs.modedb)\r\nfb_destroy_modedb(info->monspecs.modedb);\r\nif (info->screen_base)\r\nvfree(info->screen_base);\r\nfb_destroy_modelist(&info->modelist);\r\ndev->info = NULL;\r\nframebuffer_release(info);\r\npr_warn("fb_info for /dev/fb%d has been freed\n", node);\r\n}\r\nkref_put(&dev->kref, dlfb_free);\r\n}\r\nstatic void dlfb_free_framebuffer_work(struct work_struct *work)\r\n{\r\nstruct dlfb_data *dev = container_of(work, struct dlfb_data,\r\nfree_framebuffer_work.work);\r\ndlfb_free_framebuffer(dev);\r\n}\r\nstatic int dlfb_ops_release(struct fb_info *info, int user)\r\n{\r\nstruct dlfb_data *dev = info->par;\r\ndev->fb_count--;\r\nif (dev->virtualized && (dev->fb_count == 0))\r\nschedule_delayed_work(&dev->free_framebuffer_work, HZ);\r\nif ((dev->fb_count == 0) && (info->fbdefio)) {\r\nfb_deferred_io_cleanup(info);\r\nkfree(info->fbdefio);\r\ninfo->fbdefio = NULL;\r\ninfo->fbops->fb_mmap = dlfb_ops_mmap;\r\n}\r\npr_warn("released /dev/fb%d user=%d count=%d\n",\r\ninfo->node, user, dev->fb_count);\r\nkref_put(&dev->kref, dlfb_free);\r\nreturn 0;\r\n}\r\nstatic int dlfb_is_valid_mode(struct fb_videomode *mode,\r\nstruct fb_info *info)\r\n{\r\nstruct dlfb_data *dev = info->par;\r\nif (mode->xres * mode->yres > dev->sku_pixel_limit) {\r\npr_warn("%dx%d beyond chip capabilities\n",\r\nmode->xres, mode->yres);\r\nreturn 0;\r\n}\r\npr_info("%dx%d @ %d Hz valid mode\n", mode->xres, mode->yres,\r\nmode->refresh);\r\nreturn 1;\r\n}\r\nstatic void dlfb_var_color_format(struct fb_var_screeninfo *var)\r\n{\r\nconst struct fb_bitfield red = { 11, 5, 0 };\r\nconst struct fb_bitfield green = { 5, 6, 0 };\r\nconst struct fb_bitfield blue = { 0, 5, 0 };\r\nvar->bits_per_pixel = 16;\r\nvar->red = red;\r\nvar->green = green;\r\nvar->blue = blue;\r\n}\r\nstatic int dlfb_ops_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct fb_videomode mode;\r\nif ((var->xres * var->yres * 2) > info->fix.smem_len)\r\nreturn -EINVAL;\r\ndlfb_var_color_format(var);\r\nfb_var_to_videomode(&mode, var);\r\nif (!dlfb_is_valid_mode(&mode, info))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int dlfb_ops_set_par(struct fb_info *info)\r\n{\r\nstruct dlfb_data *dev = info->par;\r\nint result;\r\nu16 *pix_framebuffer;\r\nint i;\r\npr_notice("set_par mode %dx%d\n", info->var.xres, info->var.yres);\r\nresult = dlfb_set_video_mode(dev, &info->var);\r\nif ((result == 0) && (dev->fb_count == 0)) {\r\npix_framebuffer = (u16 *) info->screen_base;\r\nfor (i = 0; i < info->fix.smem_len / 2; i++)\r\npix_framebuffer[i] = 0x37e6;\r\ndlfb_handle_damage(dev, 0, 0, info->var.xres, info->var.yres,\r\ninfo->screen_base);\r\n}\r\nreturn result;\r\n}\r\nstatic char *dlfb_dummy_render(char *buf)\r\n{\r\n*buf++ = 0xAF;\r\n*buf++ = 0x6A;\r\n*buf++ = 0x00;\r\n*buf++ = 0x00;\r\n*buf++ = 0x00;\r\n*buf++ = 0x01;\r\n*buf++ = 0x00;\r\n*buf++ = 0x00;\r\n*buf++ = 0x00;\r\nreturn buf;\r\n}\r\nstatic int dlfb_ops_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct dlfb_data *dev = info->par;\r\nchar *bufptr;\r\nstruct urb *urb;\r\npr_info("/dev/fb%d FB_BLANK mode %d --> %d\n",\r\ninfo->node, dev->blank_mode, blank_mode);\r\nif ((dev->blank_mode == FB_BLANK_POWERDOWN) &&\r\n(blank_mode != FB_BLANK_POWERDOWN)) {\r\ndlfb_set_video_mode(dev, &info->var);\r\n}\r\nurb = dlfb_get_urb(dev);\r\nif (!urb)\r\nreturn 0;\r\nbufptr = (char *) urb->transfer_buffer;\r\nbufptr = dlfb_vidreg_lock(bufptr);\r\nbufptr = dlfb_blanking(bufptr, blank_mode);\r\nbufptr = dlfb_vidreg_unlock(bufptr);\r\nbufptr = dlfb_dummy_render(bufptr);\r\ndlfb_submit_urb(dev, urb, bufptr -\r\n(char *) urb->transfer_buffer);\r\ndev->blank_mode = blank_mode;\r\nreturn 0;\r\n}\r\nstatic int dlfb_realloc_framebuffer(struct dlfb_data *dev, struct fb_info *info)\r\n{\r\nint retval = -ENOMEM;\r\nint old_len = info->fix.smem_len;\r\nint new_len;\r\nunsigned char *old_fb = info->screen_base;\r\nunsigned char *new_fb;\r\nunsigned char *new_back = 0;\r\npr_warn("Reallocating framebuffer. Addresses will change!\n");\r\nnew_len = info->fix.line_length * info->var.yres;\r\nif (PAGE_ALIGN(new_len) > old_len) {\r\nnew_fb = vmalloc(new_len);\r\nif (!new_fb) {\r\npr_err("Virtual framebuffer alloc failed\n");\r\ngoto error;\r\n}\r\nif (info->screen_base) {\r\nmemcpy(new_fb, old_fb, old_len);\r\nvfree(info->screen_base);\r\n}\r\ninfo->screen_base = new_fb;\r\ninfo->fix.smem_len = PAGE_ALIGN(new_len);\r\ninfo->fix.smem_start = (unsigned long) new_fb;\r\ninfo->flags = udlfb_info_flags;\r\nif (shadow)\r\nnew_back = vzalloc(new_len);\r\nif (!new_back)\r\npr_info("No shadow/backing buffer allocated\n");\r\nelse {\r\nif (dev->backing_buffer)\r\nvfree(dev->backing_buffer);\r\ndev->backing_buffer = new_back;\r\n}\r\n}\r\nretval = 0;\r\nerror:\r\nreturn retval;\r\n}\r\nstatic int dlfb_setup_modes(struct dlfb_data *dev,\r\nstruct fb_info *info,\r\nchar *default_edid, size_t default_edid_size)\r\n{\r\nint i;\r\nconst struct fb_videomode *default_vmode = NULL;\r\nint result = 0;\r\nchar *edid;\r\nint tries = 3;\r\nif (info->dev)\r\nmutex_lock(&info->lock);\r\nedid = kmalloc(EDID_LENGTH, GFP_KERNEL);\r\nif (!edid) {\r\nresult = -ENOMEM;\r\ngoto error;\r\n}\r\nfb_destroy_modelist(&info->modelist);\r\nmemset(&info->monspecs, 0, sizeof(info->monspecs));\r\nwhile (tries--) {\r\ni = dlfb_get_edid(dev, edid, EDID_LENGTH);\r\nif (i >= EDID_LENGTH)\r\nfb_edid_to_monspecs(edid, &info->monspecs);\r\nif (info->monspecs.modedb_len > 0) {\r\ndev->edid = edid;\r\ndev->edid_size = i;\r\nbreak;\r\n}\r\n}\r\nif (info->monspecs.modedb_len == 0) {\r\npr_err("Unable to get valid EDID from device/display\n");\r\nif (dev->edid) {\r\nfb_edid_to_monspecs(dev->edid, &info->monspecs);\r\nif (info->monspecs.modedb_len > 0)\r\npr_err("Using previously queried EDID\n");\r\n}\r\n}\r\nif (info->monspecs.modedb_len == 0) {\r\nif (default_edid_size >= EDID_LENGTH) {\r\nfb_edid_to_monspecs(default_edid, &info->monspecs);\r\nif (info->monspecs.modedb_len > 0) {\r\nmemcpy(edid, default_edid, default_edid_size);\r\ndev->edid = edid;\r\ndev->edid_size = default_edid_size;\r\npr_err("Using default/backup EDID\n");\r\n}\r\n}\r\n}\r\nif (info->monspecs.modedb_len > 0) {\r\nfor (i = 0; i < info->monspecs.modedb_len; i++) {\r\nif (dlfb_is_valid_mode(&info->monspecs.modedb[i], info))\r\nfb_add_videomode(&info->monspecs.modedb[i],\r\n&info->modelist);\r\nelse {\r\nif (i == 0)\r\ninfo->monspecs.misc\r\n&= ~FB_MISC_1ST_DETAIL;\r\n}\r\n}\r\ndefault_vmode = fb_find_best_display(&info->monspecs,\r\n&info->modelist);\r\n}\r\nif (default_vmode == NULL) {\r\nstruct fb_videomode fb_vmode = {0};\r\nfor (i = 0; i < VESA_MODEDB_SIZE; i++) {\r\nif (dlfb_is_valid_mode((struct fb_videomode *)\r\n&vesa_modes[i], info))\r\nfb_add_videomode(&vesa_modes[i],\r\n&info->modelist);\r\n}\r\nfb_vmode.xres = 800;\r\nfb_vmode.yres = 600;\r\nfb_vmode.refresh = 60;\r\ndefault_vmode = fb_find_nearest_mode(&fb_vmode,\r\n&info->modelist);\r\n}\r\nif ((default_vmode != NULL) && (dev->fb_count == 0)) {\r\nfb_videomode_to_var(&info->var, default_vmode);\r\ndlfb_var_color_format(&info->var);\r\nmemcpy(&info->fix, &dlfb_fix, sizeof(dlfb_fix));\r\ninfo->fix.line_length = info->var.xres *\r\n(info->var.bits_per_pixel / 8);\r\nresult = dlfb_realloc_framebuffer(dev, info);\r\n} else\r\nresult = -EINVAL;\r\nerror:\r\nif (edid && (dev->edid != edid))\r\nkfree(edid);\r\nif (info->dev)\r\nmutex_unlock(&info->lock);\r\nreturn result;\r\n}\r\nstatic ssize_t metrics_bytes_rendered_show(struct device *fbdev,\r\nstruct device_attribute *a, char *buf) {\r\nstruct fb_info *fb_info = dev_get_drvdata(fbdev);\r\nstruct dlfb_data *dev = fb_info->par;\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n",\r\natomic_read(&dev->bytes_rendered));\r\n}\r\nstatic ssize_t metrics_bytes_identical_show(struct device *fbdev,\r\nstruct device_attribute *a, char *buf) {\r\nstruct fb_info *fb_info = dev_get_drvdata(fbdev);\r\nstruct dlfb_data *dev = fb_info->par;\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n",\r\natomic_read(&dev->bytes_identical));\r\n}\r\nstatic ssize_t metrics_bytes_sent_show(struct device *fbdev,\r\nstruct device_attribute *a, char *buf) {\r\nstruct fb_info *fb_info = dev_get_drvdata(fbdev);\r\nstruct dlfb_data *dev = fb_info->par;\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n",\r\natomic_read(&dev->bytes_sent));\r\n}\r\nstatic ssize_t metrics_cpu_kcycles_used_show(struct device *fbdev,\r\nstruct device_attribute *a, char *buf) {\r\nstruct fb_info *fb_info = dev_get_drvdata(fbdev);\r\nstruct dlfb_data *dev = fb_info->par;\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n",\r\natomic_read(&dev->cpu_kcycles_used));\r\n}\r\nstatic ssize_t edid_show(\r\nstruct file *filp,\r\nstruct kobject *kobj, struct bin_attribute *a,\r\nchar *buf, loff_t off, size_t count) {\r\nstruct device *fbdev = container_of(kobj, struct device, kobj);\r\nstruct fb_info *fb_info = dev_get_drvdata(fbdev);\r\nstruct dlfb_data *dev = fb_info->par;\r\nif (dev->edid == NULL)\r\nreturn 0;\r\nif ((off >= dev->edid_size) || (count > dev->edid_size))\r\nreturn 0;\r\nif (off + count > dev->edid_size)\r\ncount = dev->edid_size - off;\r\npr_info("sysfs edid copy %p to %p, %d bytes\n",\r\ndev->edid, buf, (int) count);\r\nmemcpy(buf, dev->edid, count);\r\nreturn count;\r\n}\r\nstatic ssize_t edid_store(\r\nstruct file *filp,\r\nstruct kobject *kobj, struct bin_attribute *a,\r\nchar *src, loff_t src_off, size_t src_size) {\r\nstruct device *fbdev = container_of(kobj, struct device, kobj);\r\nstruct fb_info *fb_info = dev_get_drvdata(fbdev);\r\nstruct dlfb_data *dev = fb_info->par;\r\nint ret;\r\nif ((src_size != EDID_LENGTH) || (src_off != 0))\r\nreturn -EINVAL;\r\nret = dlfb_setup_modes(dev, fb_info, src, src_size);\r\nif (ret)\r\nreturn ret;\r\nif (!dev->edid || memcmp(src, dev->edid, src_size))\r\nreturn -EINVAL;\r\npr_info("sysfs written EDID is new default\n");\r\ndlfb_ops_set_par(fb_info);\r\nreturn src_size;\r\n}\r\nstatic ssize_t metrics_reset_store(struct device *fbdev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fb_info *fb_info = dev_get_drvdata(fbdev);\r\nstruct dlfb_data *dev = fb_info->par;\r\natomic_set(&dev->bytes_rendered, 0);\r\natomic_set(&dev->bytes_identical, 0);\r\natomic_set(&dev->bytes_sent, 0);\r\natomic_set(&dev->cpu_kcycles_used, 0);\r\nreturn count;\r\n}\r\nstatic int dlfb_select_std_channel(struct dlfb_data *dev)\r\n{\r\nint ret;\r\nu8 set_def_chn[] = { 0x57, 0xCD, 0xDC, 0xA7,\r\n0x1C, 0x88, 0x5E, 0x15,\r\n0x60, 0xFE, 0xC6, 0x97,\r\n0x16, 0x3D, 0x47, 0xF2 };\r\nret = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\r\nNR_USB_REQUEST_CHANNEL,\r\n(USB_DIR_OUT | USB_TYPE_VENDOR), 0, 0,\r\nset_def_chn, sizeof(set_def_chn), USB_CTRL_SET_TIMEOUT);\r\nreturn ret;\r\n}\r\nstatic int dlfb_parse_vendor_descriptor(struct dlfb_data *dev,\r\nstruct usb_interface *interface)\r\n{\r\nchar *desc;\r\nchar *buf;\r\nchar *desc_end;\r\nint total_len = 0;\r\nbuf = kzalloc(MAX_VENDOR_DESCRIPTOR_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn false;\r\ndesc = buf;\r\ntotal_len = usb_get_descriptor(interface_to_usbdev(interface),\r\n0x5f,\r\n0, desc, MAX_VENDOR_DESCRIPTOR_SIZE);\r\nif (total_len < 0) {\r\nif (0 == usb_get_extra_descriptor(interface->cur_altsetting,\r\n0x5f, &desc))\r\ntotal_len = (int) desc[0];\r\n}\r\nif (total_len > 5) {\r\npr_info("vendor descriptor length:%x data:%02x %02x %02x %02x" \\r\n"%02x %02x %02x %02x %02x %02x %02x\n",\r\ntotal_len, desc[0],\r\ndesc[1], desc[2], desc[3], desc[4], desc[5], desc[6],\r\ndesc[7], desc[8], desc[9], desc[10]);\r\nif ((desc[0] != total_len) ||\r\n(desc[1] != 0x5f) ||\r\n(desc[2] != 0x01) ||\r\n(desc[3] != 0x00) ||\r\n(desc[4] != total_len - 2))\r\ngoto unrecognized;\r\ndesc_end = desc + total_len;\r\ndesc += 5;\r\nwhile (desc < desc_end) {\r\nu8 length;\r\nu16 key;\r\nkey = le16_to_cpu(*((u16 *) desc));\r\ndesc += sizeof(u16);\r\nlength = *desc;\r\ndesc++;\r\nswitch (key) {\r\ncase 0x0200: {\r\nu32 max_area;\r\nmax_area = le32_to_cpu(*((u32 *)desc));\r\npr_warn("DL chip limited to %d pixel modes\n",\r\nmax_area);\r\ndev->sku_pixel_limit = max_area;\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\ndesc += length;\r\n}\r\n} else {\r\npr_info("vendor descriptor not available (%d)\n", total_len);\r\n}\r\ngoto success;\r\nunrecognized:\r\npr_err("Unrecognized vendor firmware descriptor\n");\r\nsuccess:\r\nkfree(buf);\r\nreturn true;\r\n}\r\nstatic int dlfb_usb_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *usbdev;\r\nstruct dlfb_data *dev = NULL;\r\nint retval = -ENOMEM;\r\nusbdev = interface_to_usbdev(interface);\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\ndev_err(&interface->dev, "dlfb_usb_probe: failed alloc of dev struct\n");\r\ngoto error;\r\n}\r\nkref_init(&dev->kref);\r\ndev->udev = usbdev;\r\ndev->gdev = &usbdev->dev;\r\nusb_set_intfdata(interface, dev);\r\npr_info("%s %s - serial #%s\n",\r\nusbdev->manufacturer, usbdev->product, usbdev->serial);\r\npr_info("vid_%04x&pid_%04x&rev_%04x driver's dlfb_data struct at %p\n",\r\nusbdev->descriptor.idVendor, usbdev->descriptor.idProduct,\r\nusbdev->descriptor.bcdDevice, dev);\r\npr_info("console enable=%d\n", console);\r\npr_info("fb_defio enable=%d\n", fb_defio);\r\npr_info("shadow enable=%d\n", shadow);\r\ndev->sku_pixel_limit = 2048 * 1152;\r\nif (!dlfb_parse_vendor_descriptor(dev, interface)) {\r\npr_err("firmware not recognized. Assume incompatible device\n");\r\ngoto error;\r\n}\r\nif (pixel_limit) {\r\npr_warn("DL chip limit of %d overriden"\r\n" by module param to %d\n",\r\ndev->sku_pixel_limit, pixel_limit);\r\ndev->sku_pixel_limit = pixel_limit;\r\n}\r\nif (!dlfb_alloc_urb_list(dev, WRITES_IN_FLIGHT, MAX_TRANSFER)) {\r\nretval = -ENOMEM;\r\npr_err("dlfb_alloc_urb_list failed\n");\r\ngoto error;\r\n}\r\nkref_get(&dev->kref);\r\nINIT_DELAYED_WORK(&dev->init_framebuffer_work,\r\ndlfb_init_framebuffer_work);\r\nschedule_delayed_work(&dev->init_framebuffer_work, 0);\r\nreturn 0;\r\nerror:\r\nif (dev) {\r\nkref_put(&dev->kref, dlfb_free);\r\nkref_put(&dev->kref, dlfb_free);\r\n}\r\nreturn retval;\r\n}\r\nstatic void dlfb_init_framebuffer_work(struct work_struct *work)\r\n{\r\nstruct dlfb_data *dev = container_of(work, struct dlfb_data,\r\ninit_framebuffer_work.work);\r\nstruct fb_info *info;\r\nint retval;\r\nint i;\r\ninfo = framebuffer_alloc(0, dev->gdev);\r\nif (!info) {\r\nretval = -ENOMEM;\r\npr_err("framebuffer_alloc failed\n");\r\ngoto error;\r\n}\r\ndev->info = info;\r\ninfo->par = dev;\r\ninfo->pseudo_palette = dev->pseudo_palette;\r\ninfo->fbops = &dlfb_ops;\r\nretval = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (retval < 0) {\r\npr_err("fb_alloc_cmap failed %x\n", retval);\r\ngoto error;\r\n}\r\nINIT_DELAYED_WORK(&dev->free_framebuffer_work,\r\ndlfb_free_framebuffer_work);\r\nINIT_LIST_HEAD(&info->modelist);\r\nretval = dlfb_setup_modes(dev, info, NULL, 0);\r\nif (retval != 0) {\r\npr_err("unable to find common mode for display and adapter\n");\r\ngoto error;\r\n}\r\natomic_set(&dev->usb_active, 1);\r\ndlfb_select_std_channel(dev);\r\ndlfb_ops_check_var(&info->var, info);\r\ndlfb_ops_set_par(info);\r\nretval = register_framebuffer(info);\r\nif (retval < 0) {\r\npr_err("register_framebuffer failed %d\n", retval);\r\ngoto error;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(fb_device_attrs); i++) {\r\nretval = device_create_file(info->dev, &fb_device_attrs[i]);\r\nif (retval) {\r\npr_warn("device_create_file failed %d\n", retval);\r\n}\r\n}\r\nretval = device_create_bin_file(info->dev, &edid_attr);\r\nif (retval) {\r\npr_warn("device_create_bin_file failed %d\n", retval);\r\n}\r\npr_info("DisplayLink USB device /dev/fb%d attached. %dx%d resolution."\r\n" Using %dK framebuffer memory\n", info->node,\r\ninfo->var.xres, info->var.yres,\r\n((dev->backing_buffer) ?\r\ninfo->fix.smem_len * 2 : info->fix.smem_len) >> 10);\r\nreturn;\r\nerror:\r\ndlfb_free_framebuffer(dev);\r\n}\r\nstatic void dlfb_usb_disconnect(struct usb_interface *interface)\r\n{\r\nstruct dlfb_data *dev;\r\nstruct fb_info *info;\r\nint i;\r\ndev = usb_get_intfdata(interface);\r\ninfo = dev->info;\r\npr_info("USB disconnect starting\n");\r\ndev->virtualized = true;\r\natomic_set(&dev->usb_active, 0);\r\ndlfb_free_urb_list(dev);\r\nif (info) {\r\nfor (i = 0; i < ARRAY_SIZE(fb_device_attrs); i++)\r\ndevice_remove_file(info->dev, &fb_device_attrs[i]);\r\ndevice_remove_bin_file(info->dev, &edid_attr);\r\nunlink_framebuffer(info);\r\n}\r\nusb_set_intfdata(interface, NULL);\r\ndev->udev = NULL;\r\ndev->gdev = NULL;\r\nif (dev->fb_count == 0)\r\nschedule_delayed_work(&dev->free_framebuffer_work, 0);\r\nkref_put(&dev->kref, dlfb_free);\r\nreturn;\r\n}\r\nstatic void dlfb_urb_completion(struct urb *urb)\r\n{\r\nstruct urb_node *unode = urb->context;\r\nstruct dlfb_data *dev = unode->dev;\r\nunsigned long flags;\r\nif (urb->status) {\r\nif (!(urb->status == -ENOENT ||\r\nurb->status == -ECONNRESET ||\r\nurb->status == -ESHUTDOWN)) {\r\npr_err("%s - nonzero write bulk status received: %d\n",\r\n__func__, urb->status);\r\natomic_set(&dev->lost_pixels, 1);\r\n}\r\n}\r\nurb->transfer_buffer_length = dev->urbs.size;\r\nspin_lock_irqsave(&dev->urbs.lock, flags);\r\nlist_add_tail(&unode->entry, &dev->urbs.list);\r\ndev->urbs.available++;\r\nspin_unlock_irqrestore(&dev->urbs.lock, flags);\r\nif (fb_defio)\r\nschedule_delayed_work(&unode->release_urb_work, 0);\r\nelse\r\nup(&dev->urbs.limit_sem);\r\n}\r\nstatic void dlfb_free_urb_list(struct dlfb_data *dev)\r\n{\r\nint count = dev->urbs.count;\r\nstruct list_head *node;\r\nstruct urb_node *unode;\r\nstruct urb *urb;\r\nint ret;\r\nunsigned long flags;\r\npr_notice("Freeing all render urbs\n");\r\nwhile (count--) {\r\nret = down_interruptible(&dev->urbs.limit_sem);\r\nif (ret)\r\nbreak;\r\nspin_lock_irqsave(&dev->urbs.lock, flags);\r\nnode = dev->urbs.list.next;\r\nlist_del_init(node);\r\nspin_unlock_irqrestore(&dev->urbs.lock, flags);\r\nunode = list_entry(node, struct urb_node, entry);\r\nurb = unode->urb;\r\nusb_free_coherent(urb->dev, dev->urbs.size,\r\nurb->transfer_buffer, urb->transfer_dma);\r\nusb_free_urb(urb);\r\nkfree(node);\r\n}\r\ndev->urbs.count = 0;\r\n}\r\nstatic int dlfb_alloc_urb_list(struct dlfb_data *dev, int count, size_t size)\r\n{\r\nint i = 0;\r\nstruct urb *urb;\r\nstruct urb_node *unode;\r\nchar *buf;\r\nspin_lock_init(&dev->urbs.lock);\r\ndev->urbs.size = size;\r\nINIT_LIST_HEAD(&dev->urbs.list);\r\nwhile (i < count) {\r\nunode = kzalloc(sizeof(struct urb_node), GFP_KERNEL);\r\nif (!unode)\r\nbreak;\r\nunode->dev = dev;\r\nINIT_DELAYED_WORK(&unode->release_urb_work,\r\ndlfb_release_urb_work);\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nkfree(unode);\r\nbreak;\r\n}\r\nunode->urb = urb;\r\nbuf = usb_alloc_coherent(dev->udev, MAX_TRANSFER, GFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (!buf) {\r\nkfree(unode);\r\nusb_free_urb(urb);\r\nbreak;\r\n}\r\nusb_fill_bulk_urb(urb, dev->udev, usb_sndbulkpipe(dev->udev, 1),\r\nbuf, size, dlfb_urb_completion, unode);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nlist_add_tail(&unode->entry, &dev->urbs.list);\r\ni++;\r\n}\r\nsema_init(&dev->urbs.limit_sem, i);\r\ndev->urbs.count = i;\r\ndev->urbs.available = i;\r\npr_notice("allocated %d %d byte urbs\n", i, (int) size);\r\nreturn i;\r\n}\r\nstatic struct urb *dlfb_get_urb(struct dlfb_data *dev)\r\n{\r\nint ret = 0;\r\nstruct list_head *entry;\r\nstruct urb_node *unode;\r\nstruct urb *urb = NULL;\r\nunsigned long flags;\r\nret = down_timeout(&dev->urbs.limit_sem, GET_URB_TIMEOUT);\r\nif (ret) {\r\natomic_set(&dev->lost_pixels, 1);\r\npr_warn("wait for urb interrupted: %x available: %d\n",\r\nret, dev->urbs.available);\r\ngoto error;\r\n}\r\nspin_lock_irqsave(&dev->urbs.lock, flags);\r\nBUG_ON(list_empty(&dev->urbs.list));\r\nentry = dev->urbs.list.next;\r\nlist_del_init(entry);\r\ndev->urbs.available--;\r\nspin_unlock_irqrestore(&dev->urbs.lock, flags);\r\nunode = list_entry(entry, struct urb_node, entry);\r\nurb = unode->urb;\r\nerror:\r\nreturn urb;\r\n}\r\nstatic int dlfb_submit_urb(struct dlfb_data *dev, struct urb *urb, size_t len)\r\n{\r\nint ret;\r\nBUG_ON(len > dev->urbs.size);\r\nurb->transfer_buffer_length = len;\r\nret = usb_submit_urb(urb, GFP_KERNEL);\r\nif (ret) {\r\ndlfb_urb_completion(urb);\r\natomic_set(&dev->lost_pixels, 1);\r\npr_err("usb_submit_urb error %x\n", ret);\r\n}\r\nreturn ret;\r\n}
