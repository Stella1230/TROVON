static int tsi721_lcread(struct rio_mport *mport, int index, u32 offset,\r\nint len, u32 *data)\r\n{\r\nstruct tsi721_device *priv = mport->priv;\r\nif (len != sizeof(u32))\r\nreturn -EINVAL;\r\n*data = ioread32(priv->regs + offset);\r\nreturn 0;\r\n}\r\nstatic int tsi721_lcwrite(struct rio_mport *mport, int index, u32 offset,\r\nint len, u32 data)\r\n{\r\nstruct tsi721_device *priv = mport->priv;\r\nif (len != sizeof(u32))\r\nreturn -EINVAL;\r\niowrite32(data, priv->regs + offset);\r\nreturn 0;\r\n}\r\nstatic int tsi721_maint_dma(struct tsi721_device *priv, u32 sys_size,\r\nu16 destid, u8 hopcount, u32 offset, int len,\r\nu32 *data, int do_wr)\r\n{\r\nvoid __iomem *regs = priv->regs + TSI721_DMAC_BASE(priv->mdma.ch_id);\r\nstruct tsi721_dma_desc *bd_ptr;\r\nu32 rd_count, swr_ptr, ch_stat;\r\nint i, err = 0;\r\nu32 op = do_wr ? MAINT_WR : MAINT_RD;\r\nif (offset > (RIO_MAINT_SPACE_SZ - len) || (len != sizeof(u32)))\r\nreturn -EINVAL;\r\nbd_ptr = priv->mdma.bd_base;\r\nrd_count = ioread32(regs + TSI721_DMAC_DRDCNT);\r\nbd_ptr[0].type_id = cpu_to_le32((DTYPE2 << 29) | (op << 19) | destid);\r\nbd_ptr[0].bcount = cpu_to_le32((sys_size << 26) | 0x04);\r\nbd_ptr[0].raddr_lo = cpu_to_le32((hopcount << 24) | offset);\r\nbd_ptr[0].raddr_hi = 0;\r\nif (do_wr)\r\nbd_ptr[0].data[0] = cpu_to_be32p(data);\r\nelse\r\nbd_ptr[0].data[0] = 0xffffffff;\r\nmb();\r\niowrite32(rd_count + 2, regs + TSI721_DMAC_DWRCNT);\r\nioread32(regs + TSI721_DMAC_DWRCNT);\r\ni = 0;\r\nwhile ((ch_stat = ioread32(regs + TSI721_DMAC_STS))\r\n& TSI721_DMAC_STS_RUN) {\r\nudelay(1);\r\nif (++i >= 5000000) {\r\ndev_dbg(&priv->pdev->dev,\r\n"%s : DMA[%d] read timeout ch_status=%x\n",\r\n__func__, priv->mdma.ch_id, ch_stat);\r\nif (!do_wr)\r\n*data = 0xffffffff;\r\nerr = -EIO;\r\ngoto err_out;\r\n}\r\n}\r\nif (ch_stat & TSI721_DMAC_STS_ABORT) {\r\ndev_dbg(&priv->pdev->dev, "%s : DMA ABORT ch_stat=%x\n",\r\n__func__, ch_stat);\r\ndev_dbg(&priv->pdev->dev, "OP=%d : destid=%x hc=%x off=%x\n",\r\ndo_wr ? MAINT_WR : MAINT_RD, destid, hopcount, offset);\r\niowrite32(TSI721_DMAC_INT_ALL, regs + TSI721_DMAC_INT);\r\niowrite32(TSI721_DMAC_CTL_INIT, regs + TSI721_DMAC_CTL);\r\nudelay(10);\r\niowrite32(0, regs + TSI721_DMAC_DWRCNT);\r\nudelay(1);\r\nif (!do_wr)\r\n*data = 0xffffffff;\r\nerr = -EIO;\r\ngoto err_out;\r\n}\r\nif (!do_wr)\r\n*data = be32_to_cpu(bd_ptr[0].data[0]);\r\nswr_ptr = ioread32(regs + TSI721_DMAC_DSWP);\r\niowrite32(swr_ptr, regs + TSI721_DMAC_DSRP);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic int tsi721_cread_dma(struct rio_mport *mport, int index, u16 destid,\r\nu8 hopcount, u32 offset, int len, u32 *data)\r\n{\r\nstruct tsi721_device *priv = mport->priv;\r\nreturn tsi721_maint_dma(priv, mport->sys_size, destid, hopcount,\r\noffset, len, data, 0);\r\n}\r\nstatic int tsi721_cwrite_dma(struct rio_mport *mport, int index, u16 destid,\r\nu8 hopcount, u32 offset, int len, u32 data)\r\n{\r\nstruct tsi721_device *priv = mport->priv;\r\nu32 temp = data;\r\nreturn tsi721_maint_dma(priv, mport->sys_size, destid, hopcount,\r\noffset, len, &temp, 1);\r\n}\r\nstatic int\r\ntsi721_pw_handler(struct rio_mport *mport)\r\n{\r\nstruct tsi721_device *priv = mport->priv;\r\nu32 pw_stat;\r\nu32 pw_buf[TSI721_RIO_PW_MSG_SIZE/sizeof(u32)];\r\npw_stat = ioread32(priv->regs + TSI721_RIO_PW_RX_STAT);\r\nif (pw_stat & TSI721_RIO_PW_RX_STAT_PW_VAL) {\r\npw_buf[0] = ioread32(priv->regs + TSI721_RIO_PW_RX_CAPT(0));\r\npw_buf[1] = ioread32(priv->regs + TSI721_RIO_PW_RX_CAPT(1));\r\npw_buf[2] = ioread32(priv->regs + TSI721_RIO_PW_RX_CAPT(2));\r\npw_buf[3] = ioread32(priv->regs + TSI721_RIO_PW_RX_CAPT(3));\r\nspin_lock(&priv->pw_fifo_lock);\r\nif (kfifo_avail(&priv->pw_fifo) >= TSI721_RIO_PW_MSG_SIZE)\r\nkfifo_in(&priv->pw_fifo, pw_buf,\r\nTSI721_RIO_PW_MSG_SIZE);\r\nelse\r\npriv->pw_discard_count++;\r\nspin_unlock(&priv->pw_fifo_lock);\r\n}\r\niowrite32(TSI721_RIO_PW_RX_STAT_PW_DISC | TSI721_RIO_PW_RX_STAT_PW_VAL,\r\npriv->regs + TSI721_RIO_PW_RX_STAT);\r\nschedule_work(&priv->pw_work);\r\nreturn 0;\r\n}\r\nstatic void tsi721_pw_dpc(struct work_struct *work)\r\n{\r\nstruct tsi721_device *priv = container_of(work, struct tsi721_device,\r\npw_work);\r\nu32 msg_buffer[RIO_PW_MSG_SIZE/sizeof(u32)];\r\nwhile (kfifo_out_spinlocked(&priv->pw_fifo, (unsigned char *)msg_buffer,\r\nTSI721_RIO_PW_MSG_SIZE, &priv->pw_fifo_lock)) {\r\n#ifdef DEBUG_PW\r\n{\r\nu32 i;\r\npr_debug("%s : Port-Write Message:", __func__);\r\nfor (i = 0; i < RIO_PW_MSG_SIZE/sizeof(u32); ) {\r\npr_debug("0x%02x: %08x %08x %08x %08x", i*4,\r\nmsg_buffer[i], msg_buffer[i + 1],\r\nmsg_buffer[i + 2], msg_buffer[i + 3]);\r\ni += 4;\r\n}\r\npr_debug("\n");\r\n}\r\n#endif\r\nrio_inb_pwrite_handler((union rio_pw_msg *)msg_buffer);\r\n}\r\n}\r\nstatic int tsi721_pw_enable(struct rio_mport *mport, int enable)\r\n{\r\nstruct tsi721_device *priv = mport->priv;\r\nu32 rval;\r\nrval = ioread32(priv->regs + TSI721_RIO_EM_INT_ENABLE);\r\nif (enable)\r\nrval |= TSI721_RIO_EM_INT_ENABLE_PW_RX;\r\nelse\r\nrval &= ~TSI721_RIO_EM_INT_ENABLE_PW_RX;\r\niowrite32(TSI721_RIO_PW_RX_STAT_PW_DISC | TSI721_RIO_PW_RX_STAT_PW_VAL,\r\npriv->regs + TSI721_RIO_PW_RX_STAT);\r\niowrite32(rval, priv->regs + TSI721_RIO_EM_INT_ENABLE);\r\nreturn 0;\r\n}\r\nstatic int tsi721_dsend(struct rio_mport *mport, int index,\r\nu16 destid, u16 data)\r\n{\r\nstruct tsi721_device *priv = mport->priv;\r\nu32 offset;\r\noffset = (((mport->sys_size) ? RIO_TT_CODE_16 : RIO_TT_CODE_8) << 18) |\r\n(destid << 2);\r\ndev_dbg(&priv->pdev->dev,\r\n"Send Doorbell 0x%04x to destID 0x%x\n", data, destid);\r\niowrite16be(data, priv->odb_base + offset);\r\nreturn 0;\r\n}\r\nstatic int\r\ntsi721_dbell_handler(struct rio_mport *mport)\r\n{\r\nstruct tsi721_device *priv = mport->priv;\r\nu32 regval;\r\nregval = ioread32(priv->regs + TSI721_SR_CHINTE(IDB_QUEUE));\r\nregval &= ~TSI721_SR_CHINT_IDBQRCV;\r\niowrite32(regval,\r\npriv->regs + TSI721_SR_CHINTE(IDB_QUEUE));\r\nschedule_work(&priv->idb_work);\r\nreturn 0;\r\n}\r\nstatic void tsi721_db_dpc(struct work_struct *work)\r\n{\r\nstruct tsi721_device *priv = container_of(work, struct tsi721_device,\r\nidb_work);\r\nstruct rio_mport *mport;\r\nstruct rio_dbell *dbell;\r\nint found = 0;\r\nu32 wr_ptr, rd_ptr;\r\nu64 *idb_entry;\r\nu32 regval;\r\nunion {\r\nu64 msg;\r\nu8 bytes[8];\r\n} idb;\r\nmport = priv->mport;\r\nwr_ptr = ioread32(priv->regs + TSI721_IDQ_WP(IDB_QUEUE)) % IDB_QSIZE;\r\nrd_ptr = ioread32(priv->regs + TSI721_IDQ_RP(IDB_QUEUE)) % IDB_QSIZE;\r\nwhile (wr_ptr != rd_ptr) {\r\nidb_entry = (u64 *)(priv->idb_base +\r\n(TSI721_IDB_ENTRY_SIZE * rd_ptr));\r\nrd_ptr++;\r\nrd_ptr %= IDB_QSIZE;\r\nidb.msg = *idb_entry;\r\n*idb_entry = 0;\r\nlist_for_each_entry(dbell, &mport->dbells, node) {\r\nif ((dbell->res->start <= DBELL_INF(idb.bytes)) &&\r\n(dbell->res->end >= DBELL_INF(idb.bytes))) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found) {\r\ndbell->dinb(mport, dbell->dev_id, DBELL_SID(idb.bytes),\r\nDBELL_TID(idb.bytes), DBELL_INF(idb.bytes));\r\n} else {\r\ndev_dbg(&priv->pdev->dev,\r\n"spurious inb doorbell, sid %2.2x tid %2.2x"\r\n" info %4.4x\n", DBELL_SID(idb.bytes),\r\nDBELL_TID(idb.bytes), DBELL_INF(idb.bytes));\r\n}\r\nwr_ptr = ioread32(priv->regs +\r\nTSI721_IDQ_WP(IDB_QUEUE)) % IDB_QSIZE;\r\n}\r\niowrite32(rd_ptr & (IDB_QSIZE - 1),\r\npriv->regs + TSI721_IDQ_RP(IDB_QUEUE));\r\nregval = ioread32(priv->regs + TSI721_SR_CHINTE(IDB_QUEUE));\r\nregval |= TSI721_SR_CHINT_IDBQRCV;\r\niowrite32(regval,\r\npriv->regs + TSI721_SR_CHINTE(IDB_QUEUE));\r\nwr_ptr = ioread32(priv->regs + TSI721_IDQ_WP(IDB_QUEUE)) % IDB_QSIZE;\r\nif (wr_ptr != rd_ptr)\r\nschedule_work(&priv->idb_work);\r\n}\r\nstatic irqreturn_t tsi721_irqhandler(int irq, void *ptr)\r\n{\r\nstruct rio_mport *mport = (struct rio_mport *)ptr;\r\nstruct tsi721_device *priv = mport->priv;\r\nu32 dev_int;\r\nu32 dev_ch_int;\r\nu32 intval;\r\nu32 ch_inte;\r\nif (priv->flags & TSI721_USING_MSI)\r\niowrite32(0, priv->regs + TSI721_DEV_INTE);\r\ndev_int = ioread32(priv->regs + TSI721_DEV_INT);\r\nif (!dev_int)\r\nreturn IRQ_NONE;\r\ndev_ch_int = ioread32(priv->regs + TSI721_DEV_CHAN_INT);\r\nif (dev_int & TSI721_DEV_INT_SR2PC_CH) {\r\nif (dev_ch_int & TSI721_INT_SR2PC_CHAN(IDB_QUEUE)) {\r\nintval = ioread32(priv->regs +\r\nTSI721_SR_CHINT(IDB_QUEUE));\r\nif (intval & TSI721_SR_CHINT_IDBQRCV)\r\ntsi721_dbell_handler(mport);\r\nelse\r\ndev_info(&priv->pdev->dev,\r\n"Unsupported SR_CH_INT %x\n", intval);\r\niowrite32(intval,\r\npriv->regs + TSI721_SR_CHINT(IDB_QUEUE));\r\nioread32(priv->regs + TSI721_SR_CHINT(IDB_QUEUE));\r\n}\r\n}\r\nif (dev_int & TSI721_DEV_INT_SMSG_CH) {\r\nint ch;\r\nif (dev_ch_int & TSI721_INT_IMSG_CHAN_M) {\r\nch_inte = ioread32(priv->regs + TSI721_DEV_CHAN_INTE);\r\nch_inte &= ~(dev_ch_int & TSI721_INT_IMSG_CHAN_M);\r\niowrite32(ch_inte, priv->regs + TSI721_DEV_CHAN_INTE);\r\nfor (ch = 4; ch < RIO_MAX_MBOX + 4; ch++) {\r\nif (!(dev_ch_int & TSI721_INT_IMSG_CHAN(ch)))\r\ncontinue;\r\ntsi721_imsg_handler(priv, ch);\r\n}\r\n}\r\nif (dev_ch_int & TSI721_INT_OMSG_CHAN_M) {\r\nch_inte = ioread32(priv->regs + TSI721_DEV_CHAN_INTE);\r\nch_inte &= ~(dev_ch_int & TSI721_INT_OMSG_CHAN_M);\r\niowrite32(ch_inte, priv->regs + TSI721_DEV_CHAN_INTE);\r\nfor (ch = 0; ch < RIO_MAX_MBOX; ch++) {\r\nif (!(dev_ch_int & TSI721_INT_OMSG_CHAN(ch)))\r\ncontinue;\r\ntsi721_omsg_handler(priv, ch);\r\n}\r\n}\r\n}\r\nif (dev_int & TSI721_DEV_INT_SRIO) {\r\nintval = ioread32(priv->regs + TSI721_RIO_EM_INT_STAT);\r\nif (intval & TSI721_RIO_EM_INT_STAT_PW_RX)\r\ntsi721_pw_handler(mport);\r\n}\r\n#ifdef CONFIG_RAPIDIO_DMA_ENGINE\r\nif (dev_int & TSI721_DEV_INT_BDMA_CH) {\r\nint ch;\r\nif (dev_ch_int & TSI721_INT_BDMA_CHAN_M) {\r\ndev_dbg(&priv->pdev->dev,\r\n"IRQ from DMA channel 0x%08x\n", dev_ch_int);\r\nfor (ch = 0; ch < TSI721_DMA_MAXCH; ch++) {\r\nif (!(dev_ch_int & TSI721_INT_BDMA_CHAN(ch)))\r\ncontinue;\r\ntsi721_bdma_handler(&priv->bdma[ch]);\r\n}\r\n}\r\n}\r\n#endif\r\nif (priv->flags & TSI721_USING_MSI) {\r\ndev_int = TSI721_DEV_INT_SR2PC_CH | TSI721_DEV_INT_SRIO |\r\nTSI721_DEV_INT_SMSG_CH | TSI721_DEV_INT_BDMA_CH;\r\niowrite32(dev_int, priv->regs + TSI721_DEV_INTE);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tsi721_interrupts_init(struct tsi721_device *priv)\r\n{\r\nu32 intr;\r\niowrite32(TSI721_SR_CHINT_ALL,\r\npriv->regs + TSI721_SR_CHINT(IDB_QUEUE));\r\niowrite32(TSI721_SR_CHINT_IDBQRCV,\r\npriv->regs + TSI721_SR_CHINTE(IDB_QUEUE));\r\niowrite32(TSI721_RIO_EM_DEV_INT_EN_INT,\r\npriv->regs + TSI721_RIO_EM_DEV_INT_EN);\r\n#ifdef CONFIG_RAPIDIO_DMA_ENGINE\r\nintr = TSI721_INT_SR2PC_CHAN(IDB_QUEUE) |\r\n(TSI721_INT_BDMA_CHAN_M &\r\n~TSI721_INT_BDMA_CHAN(TSI721_DMACH_MAINT));\r\n#else\r\nintr = TSI721_INT_SR2PC_CHAN(IDB_QUEUE);\r\n#endif\r\niowrite32(intr, priv->regs + TSI721_DEV_CHAN_INTE);\r\nif (priv->flags & TSI721_USING_MSIX)\r\nintr = TSI721_DEV_INT_SRIO;\r\nelse\r\nintr = TSI721_DEV_INT_SR2PC_CH | TSI721_DEV_INT_SRIO |\r\nTSI721_DEV_INT_SMSG_CH | TSI721_DEV_INT_BDMA_CH;\r\niowrite32(intr, priv->regs + TSI721_DEV_INTE);\r\nioread32(priv->regs + TSI721_DEV_INTE);\r\n}\r\nstatic irqreturn_t tsi721_omsg_msix(int irq, void *ptr)\r\n{\r\nstruct tsi721_device *priv = ((struct rio_mport *)ptr)->priv;\r\nint mbox;\r\nmbox = (irq - priv->msix[TSI721_VECT_OMB0_DONE].vector) % RIO_MAX_MBOX;\r\ntsi721_omsg_handler(priv, mbox);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t tsi721_imsg_msix(int irq, void *ptr)\r\n{\r\nstruct tsi721_device *priv = ((struct rio_mport *)ptr)->priv;\r\nint mbox;\r\nmbox = (irq - priv->msix[TSI721_VECT_IMB0_RCV].vector) % RIO_MAX_MBOX;\r\ntsi721_imsg_handler(priv, mbox + 4);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t tsi721_srio_msix(int irq, void *ptr)\r\n{\r\nstruct tsi721_device *priv = ((struct rio_mport *)ptr)->priv;\r\nu32 srio_int;\r\nsrio_int = ioread32(priv->regs + TSI721_RIO_EM_INT_STAT);\r\nif (srio_int & TSI721_RIO_EM_INT_STAT_PW_RX)\r\ntsi721_pw_handler((struct rio_mport *)ptr);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t tsi721_sr2pc_ch_msix(int irq, void *ptr)\r\n{\r\nstruct tsi721_device *priv = ((struct rio_mport *)ptr)->priv;\r\nu32 sr_ch_int;\r\nsr_ch_int = ioread32(priv->regs + TSI721_SR_CHINT(IDB_QUEUE));\r\nif (sr_ch_int & TSI721_SR_CHINT_IDBQRCV)\r\ntsi721_dbell_handler((struct rio_mport *)ptr);\r\niowrite32(sr_ch_int, priv->regs + TSI721_SR_CHINT(IDB_QUEUE));\r\nsr_ch_int = ioread32(priv->regs + TSI721_SR_CHINT(IDB_QUEUE));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tsi721_request_msix(struct rio_mport *mport)\r\n{\r\nstruct tsi721_device *priv = mport->priv;\r\nint err = 0;\r\nerr = request_irq(priv->msix[TSI721_VECT_IDB].vector,\r\ntsi721_sr2pc_ch_msix, 0,\r\npriv->msix[TSI721_VECT_IDB].irq_name, (void *)mport);\r\nif (err)\r\ngoto out;\r\nerr = request_irq(priv->msix[TSI721_VECT_PWRX].vector,\r\ntsi721_srio_msix, 0,\r\npriv->msix[TSI721_VECT_PWRX].irq_name, (void *)mport);\r\nif (err)\r\nfree_irq(\r\npriv->msix[TSI721_VECT_IDB].vector,\r\n(void *)mport);\r\nout:\r\nreturn err;\r\n}\r\nstatic int tsi721_enable_msix(struct tsi721_device *priv)\r\n{\r\nstruct msix_entry entries[TSI721_VECT_MAX];\r\nint err;\r\nint i;\r\nentries[TSI721_VECT_IDB].entry = TSI721_MSIX_SR2PC_IDBQ_RCV(IDB_QUEUE);\r\nentries[TSI721_VECT_PWRX].entry = TSI721_MSIX_SRIO_MAC_INT;\r\nfor (i = 0; i < RIO_MAX_MBOX; i++) {\r\nentries[TSI721_VECT_IMB0_RCV + i].entry =\r\nTSI721_MSIX_IMSG_DQ_RCV(i + 4);\r\nentries[TSI721_VECT_IMB0_INT + i].entry =\r\nTSI721_MSIX_IMSG_INT(i + 4);\r\nentries[TSI721_VECT_OMB0_DONE + i].entry =\r\nTSI721_MSIX_OMSG_DONE(i);\r\nentries[TSI721_VECT_OMB0_INT + i].entry =\r\nTSI721_MSIX_OMSG_INT(i);\r\n}\r\n#ifdef CONFIG_RAPIDIO_DMA_ENGINE\r\nfor (i = 0; i < TSI721_DMA_CHNUM; i++) {\r\nentries[TSI721_VECT_DMA0_DONE + i].entry =\r\nTSI721_MSIX_DMACH_DONE(i);\r\nentries[TSI721_VECT_DMA0_INT + i].entry =\r\nTSI721_MSIX_DMACH_INT(i);\r\n}\r\n#endif\r\nerr = pci_enable_msix(priv->pdev, entries, ARRAY_SIZE(entries));\r\nif (err) {\r\nif (err > 0)\r\ndev_info(&priv->pdev->dev,\r\n"Only %d MSI-X vectors available, "\r\n"not using MSI-X\n", err);\r\nelse\r\ndev_err(&priv->pdev->dev,\r\n"Failed to enable MSI-X (err=%d)\n", err);\r\nreturn err;\r\n}\r\npriv->msix[TSI721_VECT_IDB].vector = entries[TSI721_VECT_IDB].vector;\r\nsnprintf(priv->msix[TSI721_VECT_IDB].irq_name, IRQ_DEVICE_NAME_MAX,\r\nDRV_NAME "-idb@pci:%s", pci_name(priv->pdev));\r\npriv->msix[TSI721_VECT_PWRX].vector = entries[TSI721_VECT_PWRX].vector;\r\nsnprintf(priv->msix[TSI721_VECT_PWRX].irq_name, IRQ_DEVICE_NAME_MAX,\r\nDRV_NAME "-pwrx@pci:%s", pci_name(priv->pdev));\r\nfor (i = 0; i < RIO_MAX_MBOX; i++) {\r\npriv->msix[TSI721_VECT_IMB0_RCV + i].vector =\r\nentries[TSI721_VECT_IMB0_RCV + i].vector;\r\nsnprintf(priv->msix[TSI721_VECT_IMB0_RCV + i].irq_name,\r\nIRQ_DEVICE_NAME_MAX, DRV_NAME "-imbr%d@pci:%s",\r\ni, pci_name(priv->pdev));\r\npriv->msix[TSI721_VECT_IMB0_INT + i].vector =\r\nentries[TSI721_VECT_IMB0_INT + i].vector;\r\nsnprintf(priv->msix[TSI721_VECT_IMB0_INT + i].irq_name,\r\nIRQ_DEVICE_NAME_MAX, DRV_NAME "-imbi%d@pci:%s",\r\ni, pci_name(priv->pdev));\r\npriv->msix[TSI721_VECT_OMB0_DONE + i].vector =\r\nentries[TSI721_VECT_OMB0_DONE + i].vector;\r\nsnprintf(priv->msix[TSI721_VECT_OMB0_DONE + i].irq_name,\r\nIRQ_DEVICE_NAME_MAX, DRV_NAME "-ombd%d@pci:%s",\r\ni, pci_name(priv->pdev));\r\npriv->msix[TSI721_VECT_OMB0_INT + i].vector =\r\nentries[TSI721_VECT_OMB0_INT + i].vector;\r\nsnprintf(priv->msix[TSI721_VECT_OMB0_INT + i].irq_name,\r\nIRQ_DEVICE_NAME_MAX, DRV_NAME "-ombi%d@pci:%s",\r\ni, pci_name(priv->pdev));\r\n}\r\n#ifdef CONFIG_RAPIDIO_DMA_ENGINE\r\nfor (i = 0; i < TSI721_DMA_CHNUM; i++) {\r\npriv->msix[TSI721_VECT_DMA0_DONE + i].vector =\r\nentries[TSI721_VECT_DMA0_DONE + i].vector;\r\nsnprintf(priv->msix[TSI721_VECT_DMA0_DONE + i].irq_name,\r\nIRQ_DEVICE_NAME_MAX, DRV_NAME "-dmad%d@pci:%s",\r\ni, pci_name(priv->pdev));\r\npriv->msix[TSI721_VECT_DMA0_INT + i].vector =\r\nentries[TSI721_VECT_DMA0_INT + i].vector;\r\nsnprintf(priv->msix[TSI721_VECT_DMA0_INT + i].irq_name,\r\nIRQ_DEVICE_NAME_MAX, DRV_NAME "-dmai%d@pci:%s",\r\ni, pci_name(priv->pdev));\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int tsi721_request_irq(struct rio_mport *mport)\r\n{\r\nstruct tsi721_device *priv = mport->priv;\r\nint err;\r\n#ifdef CONFIG_PCI_MSI\r\nif (priv->flags & TSI721_USING_MSIX)\r\nerr = tsi721_request_msix(mport);\r\nelse\r\n#endif\r\nerr = request_irq(priv->pdev->irq, tsi721_irqhandler,\r\n(priv->flags & TSI721_USING_MSI) ? 0 : IRQF_SHARED,\r\nDRV_NAME, (void *)mport);\r\nif (err)\r\ndev_err(&priv->pdev->dev,\r\n"Unable to allocate interrupt, Error: %d\n", err);\r\nreturn err;\r\n}\r\nstatic void tsi721_init_pc2sr_mapping(struct tsi721_device *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < TSI721_OBWIN_NUM; i++)\r\niowrite32(0, priv->regs + TSI721_OBWINLB(i));\r\n}\r\nstatic int tsi721_rio_map_inb_mem(struct rio_mport *mport, dma_addr_t lstart,\r\nu64 rstart, u32 size, u32 flags)\r\n{\r\nstruct tsi721_device *priv = mport->priv;\r\nint i;\r\nu32 regval;\r\nif (!is_power_of_2(size) || size < 0x1000 ||\r\n((u64)lstart & (size - 1)) || (rstart & (size - 1)))\r\nreturn -EINVAL;\r\nfor (i = 0; i < TSI721_IBWIN_NUM; i++) {\r\nregval = ioread32(priv->regs + TSI721_IBWIN_LB(i));\r\nif (!(regval & TSI721_IBWIN_LB_WEN))\r\nbreak;\r\n}\r\nif (i >= TSI721_IBWIN_NUM) {\r\ndev_err(&priv->pdev->dev,\r\n"Unable to find free inbound window\n");\r\nreturn -EBUSY;\r\n}\r\niowrite32(TSI721_IBWIN_SIZE(size) << 8,\r\npriv->regs + TSI721_IBWIN_SZ(i));\r\niowrite32(((u64)lstart >> 32), priv->regs + TSI721_IBWIN_TUA(i));\r\niowrite32(((u64)lstart & TSI721_IBWIN_TLA_ADD),\r\npriv->regs + TSI721_IBWIN_TLA(i));\r\niowrite32(rstart >> 32, priv->regs + TSI721_IBWIN_UB(i));\r\niowrite32((rstart & TSI721_IBWIN_LB_BA) | TSI721_IBWIN_LB_WEN,\r\npriv->regs + TSI721_IBWIN_LB(i));\r\ndev_dbg(&priv->pdev->dev,\r\n"Configured IBWIN%d mapping (RIO_0x%llx -> PCIe_0x%llx)\n",\r\ni, rstart, (unsigned long long)lstart);\r\nreturn 0;\r\n}\r\nstatic void tsi721_rio_unmap_inb_mem(struct rio_mport *mport,\r\ndma_addr_t lstart)\r\n{\r\nstruct tsi721_device *priv = mport->priv;\r\nint i;\r\nu64 addr;\r\nu32 regval;\r\nfor (i = 0; i < TSI721_IBWIN_NUM; i++) {\r\nregval = ioread32(priv->regs + TSI721_IBWIN_LB(i));\r\nif (regval & TSI721_IBWIN_LB_WEN) {\r\nregval = ioread32(priv->regs + TSI721_IBWIN_TUA(i));\r\naddr = (u64)regval << 32;\r\nregval = ioread32(priv->regs + TSI721_IBWIN_TLA(i));\r\naddr |= regval & TSI721_IBWIN_TLA_ADD;\r\nif (addr == (u64)lstart) {\r\niowrite32(0, priv->regs + TSI721_IBWIN_LB(i));\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void tsi721_init_sr2pc_mapping(struct tsi721_device *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < TSI721_IBWIN_NUM; i++)\r\niowrite32(0, priv->regs + TSI721_IBWIN_LB(i));\r\n}\r\nstatic int tsi721_port_write_init(struct tsi721_device *priv)\r\n{\r\npriv->pw_discard_count = 0;\r\nINIT_WORK(&priv->pw_work, tsi721_pw_dpc);\r\nspin_lock_init(&priv->pw_fifo_lock);\r\nif (kfifo_alloc(&priv->pw_fifo,\r\nTSI721_RIO_PW_MSG_SIZE * 32, GFP_KERNEL)) {\r\ndev_err(&priv->pdev->dev, "PW FIFO allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\niowrite32(TSI721_RIO_PW_CTL_PWC_REL, priv->regs + TSI721_RIO_PW_CTL);\r\nreturn 0;\r\n}\r\nstatic int tsi721_doorbell_init(struct tsi721_device *priv)\r\n{\r\npriv->db_discard_count = 0;\r\nINIT_WORK(&priv->idb_work, tsi721_db_dpc);\r\npriv->idb_base = dma_zalloc_coherent(&priv->pdev->dev,\r\nIDB_QSIZE * TSI721_IDB_ENTRY_SIZE,\r\n&priv->idb_dma, GFP_KERNEL);\r\nif (!priv->idb_base)\r\nreturn -ENOMEM;\r\ndev_dbg(&priv->pdev->dev, "Allocated IDB buffer @ %p (phys = %llx)\n",\r\npriv->idb_base, (unsigned long long)priv->idb_dma);\r\niowrite32(TSI721_IDQ_SIZE_VAL(IDB_QSIZE),\r\npriv->regs + TSI721_IDQ_SIZE(IDB_QUEUE));\r\niowrite32(((u64)priv->idb_dma >> 32),\r\npriv->regs + TSI721_IDQ_BASEU(IDB_QUEUE));\r\niowrite32(((u64)priv->idb_dma & TSI721_IDQ_BASEL_ADDR),\r\npriv->regs + TSI721_IDQ_BASEL(IDB_QUEUE));\r\niowrite32(0, priv->regs + TSI721_IDQ_MASK(IDB_QUEUE));\r\niowrite32(TSI721_IDQ_INIT, priv->regs + TSI721_IDQ_CTL(IDB_QUEUE));\r\niowrite32(0, priv->regs + TSI721_IDQ_RP(IDB_QUEUE));\r\nreturn 0;\r\n}\r\nstatic void tsi721_doorbell_free(struct tsi721_device *priv)\r\n{\r\nif (priv->idb_base == NULL)\r\nreturn;\r\ndma_free_coherent(&priv->pdev->dev, IDB_QSIZE * TSI721_IDB_ENTRY_SIZE,\r\npriv->idb_base, priv->idb_dma);\r\npriv->idb_base = NULL;\r\n}\r\nstatic int tsi721_bdma_maint_init(struct tsi721_device *priv)\r\n{\r\nstruct tsi721_dma_desc *bd_ptr;\r\nu64 *sts_ptr;\r\ndma_addr_t bd_phys, sts_phys;\r\nint sts_size;\r\nint bd_num = 2;\r\nvoid __iomem *regs;\r\ndev_dbg(&priv->pdev->dev,\r\n"Init Block DMA Engine for Maintenance requests, CH%d\n",\r\nTSI721_DMACH_MAINT);\r\npriv->mdma.ch_id = TSI721_DMACH_MAINT;\r\nregs = priv->regs + TSI721_DMAC_BASE(TSI721_DMACH_MAINT);\r\nbd_ptr = dma_zalloc_coherent(&priv->pdev->dev,\r\nbd_num * sizeof(struct tsi721_dma_desc),\r\n&bd_phys, GFP_KERNEL);\r\nif (!bd_ptr)\r\nreturn -ENOMEM;\r\npriv->mdma.bd_num = bd_num;\r\npriv->mdma.bd_phys = bd_phys;\r\npriv->mdma.bd_base = bd_ptr;\r\ndev_dbg(&priv->pdev->dev, "DMA descriptors @ %p (phys = %llx)\n",\r\nbd_ptr, (unsigned long long)bd_phys);\r\nsts_size = (bd_num >= TSI721_DMA_MINSTSSZ) ?\r\nbd_num : TSI721_DMA_MINSTSSZ;\r\nsts_size = roundup_pow_of_two(sts_size);\r\nsts_ptr = dma_zalloc_coherent(&priv->pdev->dev,\r\nsts_size * sizeof(struct tsi721_dma_sts),\r\n&sts_phys, GFP_KERNEL);\r\nif (!sts_ptr) {\r\ndma_free_coherent(&priv->pdev->dev,\r\nbd_num * sizeof(struct tsi721_dma_desc),\r\nbd_ptr, bd_phys);\r\npriv->mdma.bd_base = NULL;\r\nreturn -ENOMEM;\r\n}\r\npriv->mdma.sts_phys = sts_phys;\r\npriv->mdma.sts_base = sts_ptr;\r\npriv->mdma.sts_size = sts_size;\r\ndev_dbg(&priv->pdev->dev,\r\n"desc status FIFO @ %p (phys = %llx) size=0x%x\n",\r\nsts_ptr, (unsigned long long)sts_phys, sts_size);\r\nbd_ptr[bd_num - 1].type_id = cpu_to_le32(DTYPE3 << 29);\r\nbd_ptr[bd_num - 1].next_lo = cpu_to_le32((u64)bd_phys &\r\nTSI721_DMAC_DPTRL_MASK);\r\nbd_ptr[bd_num - 1].next_hi = cpu_to_le32((u64)bd_phys >> 32);\r\niowrite32(((u64)bd_phys >> 32), regs + TSI721_DMAC_DPTRH);\r\niowrite32(((u64)bd_phys & TSI721_DMAC_DPTRL_MASK),\r\nregs + TSI721_DMAC_DPTRL);\r\niowrite32(((u64)sts_phys >> 32), regs + TSI721_DMAC_DSBH);\r\niowrite32(((u64)sts_phys & TSI721_DMAC_DSBL_MASK),\r\nregs + TSI721_DMAC_DSBL);\r\niowrite32(TSI721_DMAC_DSSZ_SIZE(sts_size),\r\nregs + TSI721_DMAC_DSSZ);\r\niowrite32(TSI721_DMAC_INT_ALL, regs + TSI721_DMAC_INT);\r\nioread32(regs + TSI721_DMAC_INT);\r\niowrite32(TSI721_DMAC_CTL_INIT, regs + TSI721_DMAC_CTL);\r\nioread32(regs + TSI721_DMAC_CTL);\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic int tsi721_bdma_maint_free(struct tsi721_device *priv)\r\n{\r\nu32 ch_stat;\r\nstruct tsi721_bdma_maint *mdma = &priv->mdma;\r\nvoid __iomem *regs = priv->regs + TSI721_DMAC_BASE(mdma->ch_id);\r\nif (mdma->bd_base == NULL)\r\nreturn 0;\r\nch_stat = ioread32(regs + TSI721_DMAC_STS);\r\nif (ch_stat & TSI721_DMAC_STS_RUN)\r\nreturn -EFAULT;\r\niowrite32(TSI721_DMAC_CTL_INIT, regs + TSI721_DMAC_CTL);\r\ndma_free_coherent(&priv->pdev->dev,\r\nmdma->bd_num * sizeof(struct tsi721_dma_desc),\r\nmdma->bd_base, mdma->bd_phys);\r\nmdma->bd_base = NULL;\r\ndma_free_coherent(&priv->pdev->dev,\r\nmdma->sts_size * sizeof(struct tsi721_dma_sts),\r\nmdma->sts_base, mdma->sts_phys);\r\nmdma->sts_base = NULL;\r\nreturn 0;\r\n}\r\nstatic void\r\ntsi721_imsg_interrupt_enable(struct tsi721_device *priv, int ch,\r\nu32 inte_mask)\r\n{\r\nu32 rval;\r\nif (!inte_mask)\r\nreturn;\r\niowrite32(inte_mask, priv->regs + TSI721_IBDMAC_INT(ch));\r\nrval = ioread32(priv->regs + TSI721_IBDMAC_INTE(ch));\r\niowrite32(rval | inte_mask, priv->regs + TSI721_IBDMAC_INTE(ch));\r\nif (priv->flags & TSI721_USING_MSIX)\r\nreturn;\r\nrval = ioread32(priv->regs + TSI721_DEV_CHAN_INTE);\r\niowrite32(rval | TSI721_INT_IMSG_CHAN(ch),\r\npriv->regs + TSI721_DEV_CHAN_INTE);\r\n}\r\nstatic void\r\ntsi721_imsg_interrupt_disable(struct tsi721_device *priv, int ch,\r\nu32 inte_mask)\r\n{\r\nu32 rval;\r\nif (!inte_mask)\r\nreturn;\r\niowrite32(inte_mask, priv->regs + TSI721_IBDMAC_INT(ch));\r\nrval = ioread32(priv->regs + TSI721_IBDMAC_INTE(ch));\r\nrval &= ~inte_mask;\r\niowrite32(rval, priv->regs + TSI721_IBDMAC_INTE(ch));\r\nif (priv->flags & TSI721_USING_MSIX)\r\nreturn;\r\nrval = ioread32(priv->regs + TSI721_DEV_CHAN_INTE);\r\nrval &= ~TSI721_INT_IMSG_CHAN(ch);\r\niowrite32(rval, priv->regs + TSI721_DEV_CHAN_INTE);\r\n}\r\nstatic void\r\ntsi721_omsg_interrupt_enable(struct tsi721_device *priv, int ch,\r\nu32 inte_mask)\r\n{\r\nu32 rval;\r\nif (!inte_mask)\r\nreturn;\r\niowrite32(inte_mask, priv->regs + TSI721_OBDMAC_INT(ch));\r\nrval = ioread32(priv->regs + TSI721_OBDMAC_INTE(ch));\r\niowrite32(rval | inte_mask, priv->regs + TSI721_OBDMAC_INTE(ch));\r\nif (priv->flags & TSI721_USING_MSIX)\r\nreturn;\r\nrval = ioread32(priv->regs + TSI721_DEV_CHAN_INTE);\r\niowrite32(rval | TSI721_INT_OMSG_CHAN(ch),\r\npriv->regs + TSI721_DEV_CHAN_INTE);\r\n}\r\nstatic void\r\ntsi721_omsg_interrupt_disable(struct tsi721_device *priv, int ch,\r\nu32 inte_mask)\r\n{\r\nu32 rval;\r\nif (!inte_mask)\r\nreturn;\r\niowrite32(inte_mask, priv->regs + TSI721_OBDMAC_INT(ch));\r\nrval = ioread32(priv->regs + TSI721_OBDMAC_INTE(ch));\r\nrval &= ~inte_mask;\r\niowrite32(rval, priv->regs + TSI721_OBDMAC_INTE(ch));\r\nif (priv->flags & TSI721_USING_MSIX)\r\nreturn;\r\nrval = ioread32(priv->regs + TSI721_DEV_CHAN_INTE);\r\nrval &= ~TSI721_INT_OMSG_CHAN(ch);\r\niowrite32(rval, priv->regs + TSI721_DEV_CHAN_INTE);\r\n}\r\nstatic int\r\ntsi721_add_outb_message(struct rio_mport *mport, struct rio_dev *rdev, int mbox,\r\nvoid *buffer, size_t len)\r\n{\r\nstruct tsi721_device *priv = mport->priv;\r\nstruct tsi721_omsg_desc *desc;\r\nu32 tx_slot;\r\nif (!priv->omsg_init[mbox] ||\r\nlen > TSI721_MSG_MAX_SIZE || len < 8)\r\nreturn -EINVAL;\r\ntx_slot = priv->omsg_ring[mbox].tx_slot;\r\nmemcpy(priv->omsg_ring[mbox].omq_base[tx_slot], buffer, len);\r\nif (len & 0x7)\r\nlen += 8;\r\ndesc = priv->omsg_ring[mbox].omd_base;\r\ndesc[tx_slot].type_id = cpu_to_le32((DTYPE4 << 29) | rdev->destid);\r\nif (tx_slot % 4 == 0)\r\ndesc[tx_slot].type_id |= cpu_to_le32(TSI721_OMD_IOF);\r\ndesc[tx_slot].msg_info =\r\ncpu_to_le32((mport->sys_size << 26) | (mbox << 22) |\r\n(0xe << 12) | (len & 0xff8));\r\ndesc[tx_slot].bufptr_lo =\r\ncpu_to_le32((u64)priv->omsg_ring[mbox].omq_phys[tx_slot] &\r\n0xffffffff);\r\ndesc[tx_slot].bufptr_hi =\r\ncpu_to_le32((u64)priv->omsg_ring[mbox].omq_phys[tx_slot] >> 32);\r\npriv->omsg_ring[mbox].wr_count++;\r\nif (++priv->omsg_ring[mbox].tx_slot == priv->omsg_ring[mbox].size) {\r\npriv->omsg_ring[mbox].tx_slot = 0;\r\npriv->omsg_ring[mbox].wr_count++;\r\n}\r\nmb();\r\niowrite32(priv->omsg_ring[mbox].wr_count,\r\npriv->regs + TSI721_OBDMAC_DWRCNT(mbox));\r\nioread32(priv->regs + TSI721_OBDMAC_DWRCNT(mbox));\r\nreturn 0;\r\n}\r\nstatic void tsi721_omsg_handler(struct tsi721_device *priv, int ch)\r\n{\r\nu32 omsg_int;\r\nspin_lock(&priv->omsg_ring[ch].lock);\r\nomsg_int = ioread32(priv->regs + TSI721_OBDMAC_INT(ch));\r\nif (omsg_int & TSI721_OBDMAC_INT_ST_FULL)\r\ndev_info(&priv->pdev->dev,\r\n"OB MBOX%d: Status FIFO is full\n", ch);\r\nif (omsg_int & (TSI721_OBDMAC_INT_DONE | TSI721_OBDMAC_INT_IOF_DONE)) {\r\nu32 srd_ptr;\r\nu64 *sts_ptr, last_ptr = 0, prev_ptr = 0;\r\nint i, j;\r\nu32 tx_slot;\r\nsrd_ptr = priv->omsg_ring[ch].sts_rdptr;\r\nsts_ptr = priv->omsg_ring[ch].sts_base;\r\nj = srd_ptr * 8;\r\nwhile (sts_ptr[j]) {\r\nfor (i = 0; i < 8 && sts_ptr[j]; i++, j++) {\r\nprev_ptr = last_ptr;\r\nlast_ptr = le64_to_cpu(sts_ptr[j]);\r\nsts_ptr[j] = 0;\r\n}\r\n++srd_ptr;\r\nsrd_ptr %= priv->omsg_ring[ch].sts_size;\r\nj = srd_ptr * 8;\r\n}\r\nif (last_ptr == 0)\r\ngoto no_sts_update;\r\npriv->omsg_ring[ch].sts_rdptr = srd_ptr;\r\niowrite32(srd_ptr, priv->regs + TSI721_OBDMAC_DSRP(ch));\r\nif (!priv->mport->outb_msg[ch].mcback)\r\ngoto no_sts_update;\r\ntx_slot = (last_ptr - (u64)priv->omsg_ring[ch].omd_phys)/\r\nsizeof(struct tsi721_omsg_desc);\r\nif (tx_slot == priv->omsg_ring[ch].size) {\r\nif (prev_ptr)\r\ntx_slot = (prev_ptr -\r\n(u64)priv->omsg_ring[ch].omd_phys)/\r\nsizeof(struct tsi721_omsg_desc);\r\nelse\r\ngoto no_sts_update;\r\n}\r\n++tx_slot;\r\nif (tx_slot == priv->omsg_ring[ch].size)\r\ntx_slot = 0;\r\nBUG_ON(tx_slot >= priv->omsg_ring[ch].size);\r\npriv->mport->outb_msg[ch].mcback(priv->mport,\r\npriv->omsg_ring[ch].dev_id, ch,\r\ntx_slot);\r\n}\r\nno_sts_update:\r\nif (omsg_int & TSI721_OBDMAC_INT_ERROR) {\r\ndev_dbg(&priv->pdev->dev, "OB MSG ABORT ch_stat=%x\n",\r\nioread32(priv->regs + TSI721_OBDMAC_STS(ch)));\r\niowrite32(TSI721_OBDMAC_INT_ERROR,\r\npriv->regs + TSI721_OBDMAC_INT(ch));\r\niowrite32(TSI721_OBDMAC_CTL_INIT,\r\npriv->regs + TSI721_OBDMAC_CTL(ch));\r\nioread32(priv->regs + TSI721_OBDMAC_CTL(ch));\r\nif (priv->mport->outb_msg[ch].mcback)\r\npriv->mport->outb_msg[ch].mcback(priv->mport,\r\npriv->omsg_ring[ch].dev_id, ch,\r\npriv->omsg_ring[ch].tx_slot);\r\niowrite32(priv->omsg_ring[ch].tx_slot,\r\npriv->regs + TSI721_OBDMAC_DRDCNT(ch));\r\nioread32(priv->regs + TSI721_OBDMAC_DRDCNT(ch));\r\npriv->omsg_ring[ch].wr_count = priv->omsg_ring[ch].tx_slot;\r\npriv->omsg_ring[ch].sts_rdptr = 0;\r\n}\r\niowrite32(omsg_int, priv->regs + TSI721_OBDMAC_INT(ch));\r\nif (!(priv->flags & TSI721_USING_MSIX)) {\r\nu32 ch_inte;\r\nch_inte = ioread32(priv->regs + TSI721_DEV_CHAN_INTE);\r\nch_inte |= TSI721_INT_OMSG_CHAN(ch);\r\niowrite32(ch_inte, priv->regs + TSI721_DEV_CHAN_INTE);\r\n}\r\nspin_unlock(&priv->omsg_ring[ch].lock);\r\n}\r\nstatic int tsi721_open_outb_mbox(struct rio_mport *mport, void *dev_id,\r\nint mbox, int entries)\r\n{\r\nstruct tsi721_device *priv = mport->priv;\r\nstruct tsi721_omsg_desc *bd_ptr;\r\nint i, rc = 0;\r\nif ((entries < TSI721_OMSGD_MIN_RING_SIZE) ||\r\n(entries > (TSI721_OMSGD_RING_SIZE)) ||\r\n(!is_power_of_2(entries)) || mbox >= RIO_MAX_MBOX) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\npriv->omsg_ring[mbox].dev_id = dev_id;\r\npriv->omsg_ring[mbox].size = entries;\r\npriv->omsg_ring[mbox].sts_rdptr = 0;\r\nspin_lock_init(&priv->omsg_ring[mbox].lock);\r\nfor (i = 0; i < entries; i++) {\r\npriv->omsg_ring[mbox].omq_base[i] =\r\ndma_alloc_coherent(\r\n&priv->pdev->dev, TSI721_MSG_BUFFER_SIZE,\r\n&priv->omsg_ring[mbox].omq_phys[i],\r\nGFP_KERNEL);\r\nif (priv->omsg_ring[mbox].omq_base[i] == NULL) {\r\ndev_dbg(&priv->pdev->dev,\r\n"Unable to allocate OB MSG data buffer for"\r\n" MBOX%d\n", mbox);\r\nrc = -ENOMEM;\r\ngoto out_buf;\r\n}\r\n}\r\npriv->omsg_ring[mbox].omd_base = dma_alloc_coherent(\r\n&priv->pdev->dev,\r\n(entries + 1) * sizeof(struct tsi721_omsg_desc),\r\n&priv->omsg_ring[mbox].omd_phys, GFP_KERNEL);\r\nif (priv->omsg_ring[mbox].omd_base == NULL) {\r\ndev_dbg(&priv->pdev->dev,\r\n"Unable to allocate OB MSG descriptor memory "\r\n"for MBOX%d\n", mbox);\r\nrc = -ENOMEM;\r\ngoto out_buf;\r\n}\r\npriv->omsg_ring[mbox].tx_slot = 0;\r\npriv->omsg_ring[mbox].sts_size = roundup_pow_of_two(entries + 1);\r\npriv->omsg_ring[mbox].sts_base = dma_zalloc_coherent(&priv->pdev->dev,\r\npriv->omsg_ring[mbox].sts_size *\r\nsizeof(struct tsi721_dma_sts),\r\n&priv->omsg_ring[mbox].sts_phys, GFP_KERNEL);\r\nif (priv->omsg_ring[mbox].sts_base == NULL) {\r\ndev_dbg(&priv->pdev->dev,\r\n"Unable to allocate OB MSG descriptor status FIFO "\r\n"for MBOX%d\n", mbox);\r\nrc = -ENOMEM;\r\ngoto out_desc;\r\n}\r\niowrite32(((u64)priv->omsg_ring[mbox].omd_phys >> 32),\r\npriv->regs + TSI721_OBDMAC_DPTRH(mbox));\r\niowrite32(((u64)priv->omsg_ring[mbox].omd_phys &\r\nTSI721_OBDMAC_DPTRL_MASK),\r\npriv->regs + TSI721_OBDMAC_DPTRL(mbox));\r\niowrite32(((u64)priv->omsg_ring[mbox].sts_phys >> 32),\r\npriv->regs + TSI721_OBDMAC_DSBH(mbox));\r\niowrite32(((u64)priv->omsg_ring[mbox].sts_phys &\r\nTSI721_OBDMAC_DSBL_MASK),\r\npriv->regs + TSI721_OBDMAC_DSBL(mbox));\r\niowrite32(TSI721_DMAC_DSSZ_SIZE(priv->omsg_ring[mbox].sts_size),\r\npriv->regs + (u32)TSI721_OBDMAC_DSSZ(mbox));\r\n#ifdef CONFIG_PCI_MSI\r\nif (priv->flags & TSI721_USING_MSIX) {\r\nrc = request_irq(\r\npriv->msix[TSI721_VECT_OMB0_DONE + mbox].vector,\r\ntsi721_omsg_msix, 0,\r\npriv->msix[TSI721_VECT_OMB0_DONE + mbox].irq_name,\r\n(void *)mport);\r\nif (rc) {\r\ndev_dbg(&priv->pdev->dev,\r\n"Unable to allocate MSI-X interrupt for "\r\n"OBOX%d-DONE\n", mbox);\r\ngoto out_stat;\r\n}\r\nrc = request_irq(priv->msix[TSI721_VECT_OMB0_INT + mbox].vector,\r\ntsi721_omsg_msix, 0,\r\npriv->msix[TSI721_VECT_OMB0_INT + mbox].irq_name,\r\n(void *)mport);\r\nif (rc) {\r\ndev_dbg(&priv->pdev->dev,\r\n"Unable to allocate MSI-X interrupt for "\r\n"MBOX%d-INT\n", mbox);\r\nfree_irq(\r\npriv->msix[TSI721_VECT_OMB0_DONE + mbox].vector,\r\n(void *)mport);\r\ngoto out_stat;\r\n}\r\n}\r\n#endif\r\ntsi721_omsg_interrupt_enable(priv, mbox, TSI721_OBDMAC_INT_ALL);\r\nbd_ptr = priv->omsg_ring[mbox].omd_base;\r\nbd_ptr[entries].type_id = cpu_to_le32(DTYPE5 << 29);\r\nbd_ptr[entries].msg_info = 0;\r\nbd_ptr[entries].next_lo =\r\ncpu_to_le32((u64)priv->omsg_ring[mbox].omd_phys &\r\nTSI721_OBDMAC_DPTRL_MASK);\r\nbd_ptr[entries].next_hi =\r\ncpu_to_le32((u64)priv->omsg_ring[mbox].omd_phys >> 32);\r\npriv->omsg_ring[mbox].wr_count = 0;\r\nmb();\r\niowrite32(TSI721_OBDMAC_CTL_INIT, priv->regs + TSI721_OBDMAC_CTL(mbox));\r\nioread32(priv->regs + TSI721_OBDMAC_DWRCNT(mbox));\r\nudelay(10);\r\npriv->omsg_init[mbox] = 1;\r\nreturn 0;\r\n#ifdef CONFIG_PCI_MSI\r\nout_stat:\r\ndma_free_coherent(&priv->pdev->dev,\r\npriv->omsg_ring[mbox].sts_size * sizeof(struct tsi721_dma_sts),\r\npriv->omsg_ring[mbox].sts_base,\r\npriv->omsg_ring[mbox].sts_phys);\r\npriv->omsg_ring[mbox].sts_base = NULL;\r\n#endif\r\nout_desc:\r\ndma_free_coherent(&priv->pdev->dev,\r\n(entries + 1) * sizeof(struct tsi721_omsg_desc),\r\npriv->omsg_ring[mbox].omd_base,\r\npriv->omsg_ring[mbox].omd_phys);\r\npriv->omsg_ring[mbox].omd_base = NULL;\r\nout_buf:\r\nfor (i = 0; i < priv->omsg_ring[mbox].size; i++) {\r\nif (priv->omsg_ring[mbox].omq_base[i]) {\r\ndma_free_coherent(&priv->pdev->dev,\r\nTSI721_MSG_BUFFER_SIZE,\r\npriv->omsg_ring[mbox].omq_base[i],\r\npriv->omsg_ring[mbox].omq_phys[i]);\r\npriv->omsg_ring[mbox].omq_base[i] = NULL;\r\n}\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic void tsi721_close_outb_mbox(struct rio_mport *mport, int mbox)\r\n{\r\nstruct tsi721_device *priv = mport->priv;\r\nu32 i;\r\nif (!priv->omsg_init[mbox])\r\nreturn;\r\npriv->omsg_init[mbox] = 0;\r\ntsi721_omsg_interrupt_disable(priv, mbox, TSI721_OBDMAC_INT_ALL);\r\n#ifdef CONFIG_PCI_MSI\r\nif (priv->flags & TSI721_USING_MSIX) {\r\nfree_irq(priv->msix[TSI721_VECT_OMB0_DONE + mbox].vector,\r\n(void *)mport);\r\nfree_irq(priv->msix[TSI721_VECT_OMB0_INT + mbox].vector,\r\n(void *)mport);\r\n}\r\n#endif\r\ndma_free_coherent(&priv->pdev->dev,\r\npriv->omsg_ring[mbox].sts_size * sizeof(struct tsi721_dma_sts),\r\npriv->omsg_ring[mbox].sts_base,\r\npriv->omsg_ring[mbox].sts_phys);\r\npriv->omsg_ring[mbox].sts_base = NULL;\r\ndma_free_coherent(&priv->pdev->dev,\r\n(priv->omsg_ring[mbox].size + 1) *\r\nsizeof(struct tsi721_omsg_desc),\r\npriv->omsg_ring[mbox].omd_base,\r\npriv->omsg_ring[mbox].omd_phys);\r\npriv->omsg_ring[mbox].omd_base = NULL;\r\nfor (i = 0; i < priv->omsg_ring[mbox].size; i++) {\r\nif (priv->omsg_ring[mbox].omq_base[i]) {\r\ndma_free_coherent(&priv->pdev->dev,\r\nTSI721_MSG_BUFFER_SIZE,\r\npriv->omsg_ring[mbox].omq_base[i],\r\npriv->omsg_ring[mbox].omq_phys[i]);\r\npriv->omsg_ring[mbox].omq_base[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic void tsi721_imsg_handler(struct tsi721_device *priv, int ch)\r\n{\r\nu32 mbox = ch - 4;\r\nu32 imsg_int;\r\nspin_lock(&priv->imsg_ring[mbox].lock);\r\nimsg_int = ioread32(priv->regs + TSI721_IBDMAC_INT(ch));\r\nif (imsg_int & TSI721_IBDMAC_INT_SRTO)\r\ndev_info(&priv->pdev->dev, "IB MBOX%d SRIO timeout\n",\r\nmbox);\r\nif (imsg_int & TSI721_IBDMAC_INT_PC_ERROR)\r\ndev_info(&priv->pdev->dev, "IB MBOX%d PCIe error\n",\r\nmbox);\r\nif (imsg_int & TSI721_IBDMAC_INT_FQ_LOW)\r\ndev_info(&priv->pdev->dev,\r\n"IB MBOX%d IB free queue low\n", mbox);\r\niowrite32(imsg_int, priv->regs + TSI721_IBDMAC_INT(ch));\r\nif (imsg_int & TSI721_IBDMAC_INT_DQ_RCV &&\r\npriv->mport->inb_msg[mbox].mcback)\r\npriv->mport->inb_msg[mbox].mcback(priv->mport,\r\npriv->imsg_ring[mbox].dev_id, mbox, -1);\r\nif (!(priv->flags & TSI721_USING_MSIX)) {\r\nu32 ch_inte;\r\nch_inte = ioread32(priv->regs + TSI721_DEV_CHAN_INTE);\r\nch_inte |= TSI721_INT_IMSG_CHAN(ch);\r\niowrite32(ch_inte, priv->regs + TSI721_DEV_CHAN_INTE);\r\n}\r\nspin_unlock(&priv->imsg_ring[mbox].lock);\r\n}\r\nstatic int tsi721_open_inb_mbox(struct rio_mport *mport, void *dev_id,\r\nint mbox, int entries)\r\n{\r\nstruct tsi721_device *priv = mport->priv;\r\nint ch = mbox + 4;\r\nint i;\r\nu64 *free_ptr;\r\nint rc = 0;\r\nif ((entries < TSI721_IMSGD_MIN_RING_SIZE) ||\r\n(entries > TSI721_IMSGD_RING_SIZE) ||\r\n(!is_power_of_2(entries)) || mbox >= RIO_MAX_MBOX) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\npriv->imsg_ring[mbox].dev_id = dev_id;\r\npriv->imsg_ring[mbox].size = entries;\r\npriv->imsg_ring[mbox].rx_slot = 0;\r\npriv->imsg_ring[mbox].desc_rdptr = 0;\r\npriv->imsg_ring[mbox].fq_wrptr = 0;\r\nfor (i = 0; i < priv->imsg_ring[mbox].size; i++)\r\npriv->imsg_ring[mbox].imq_base[i] = NULL;\r\nspin_lock_init(&priv->imsg_ring[mbox].lock);\r\npriv->imsg_ring[mbox].buf_base =\r\ndma_alloc_coherent(&priv->pdev->dev,\r\nentries * TSI721_MSG_BUFFER_SIZE,\r\n&priv->imsg_ring[mbox].buf_phys,\r\nGFP_KERNEL);\r\nif (priv->imsg_ring[mbox].buf_base == NULL) {\r\ndev_err(&priv->pdev->dev,\r\n"Failed to allocate buffers for IB MBOX%d\n", mbox);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\npriv->imsg_ring[mbox].imfq_base =\r\ndma_alloc_coherent(&priv->pdev->dev,\r\nentries * 8,\r\n&priv->imsg_ring[mbox].imfq_phys,\r\nGFP_KERNEL);\r\nif (priv->imsg_ring[mbox].imfq_base == NULL) {\r\ndev_err(&priv->pdev->dev,\r\n"Failed to allocate free queue for IB MBOX%d\n", mbox);\r\nrc = -ENOMEM;\r\ngoto out_buf;\r\n}\r\npriv->imsg_ring[mbox].imd_base =\r\ndma_alloc_coherent(&priv->pdev->dev,\r\nentries * sizeof(struct tsi721_imsg_desc),\r\n&priv->imsg_ring[mbox].imd_phys, GFP_KERNEL);\r\nif (priv->imsg_ring[mbox].imd_base == NULL) {\r\ndev_err(&priv->pdev->dev,\r\n"Failed to allocate descriptor memory for IB MBOX%d\n",\r\nmbox);\r\nrc = -ENOMEM;\r\ngoto out_dma;\r\n}\r\nfree_ptr = priv->imsg_ring[mbox].imfq_base;\r\nfor (i = 0; i < entries; i++)\r\nfree_ptr[i] = cpu_to_le64(\r\n(u64)(priv->imsg_ring[mbox].buf_phys) +\r\ni * 0x1000);\r\nmb();\r\nif (!(priv->flags & TSI721_IMSGID_SET)) {\r\niowrite32((u32)priv->mport->host_deviceid,\r\npriv->regs + TSI721_IB_DEVID);\r\npriv->flags |= TSI721_IMSGID_SET;\r\n}\r\niowrite32(((u64)priv->imsg_ring[mbox].imfq_phys >> 32),\r\npriv->regs + TSI721_IBDMAC_FQBH(ch));\r\niowrite32(((u64)priv->imsg_ring[mbox].imfq_phys &\r\nTSI721_IBDMAC_FQBL_MASK),\r\npriv->regs+TSI721_IBDMAC_FQBL(ch));\r\niowrite32(TSI721_DMAC_DSSZ_SIZE(entries),\r\npriv->regs + TSI721_IBDMAC_FQSZ(ch));\r\niowrite32(((u64)priv->imsg_ring[mbox].imd_phys >> 32),\r\npriv->regs + TSI721_IBDMAC_DQBH(ch));\r\niowrite32(((u32)priv->imsg_ring[mbox].imd_phys &\r\n(u32)TSI721_IBDMAC_DQBL_MASK),\r\npriv->regs+TSI721_IBDMAC_DQBL(ch));\r\niowrite32(TSI721_DMAC_DSSZ_SIZE(entries),\r\npriv->regs + TSI721_IBDMAC_DQSZ(ch));\r\n#ifdef CONFIG_PCI_MSI\r\nif (priv->flags & TSI721_USING_MSIX) {\r\nrc = request_irq(priv->msix[TSI721_VECT_IMB0_RCV + mbox].vector,\r\ntsi721_imsg_msix, 0,\r\npriv->msix[TSI721_VECT_IMB0_RCV + mbox].irq_name,\r\n(void *)mport);\r\nif (rc) {\r\ndev_dbg(&priv->pdev->dev,\r\n"Unable to allocate MSI-X interrupt for "\r\n"IBOX%d-DONE\n", mbox);\r\ngoto out_desc;\r\n}\r\nrc = request_irq(priv->msix[TSI721_VECT_IMB0_INT + mbox].vector,\r\ntsi721_imsg_msix, 0,\r\npriv->msix[TSI721_VECT_IMB0_INT + mbox].irq_name,\r\n(void *)mport);\r\nif (rc) {\r\ndev_dbg(&priv->pdev->dev,\r\n"Unable to allocate MSI-X interrupt for "\r\n"IBOX%d-INT\n", mbox);\r\nfree_irq(\r\npriv->msix[TSI721_VECT_IMB0_RCV + mbox].vector,\r\n(void *)mport);\r\ngoto out_desc;\r\n}\r\n}\r\n#endif\r\ntsi721_imsg_interrupt_enable(priv, ch, TSI721_IBDMAC_INT_ALL);\r\niowrite32(TSI721_IBDMAC_CTL_INIT, priv->regs + TSI721_IBDMAC_CTL(ch));\r\nioread32(priv->regs + TSI721_IBDMAC_CTL(ch));\r\nudelay(10);\r\npriv->imsg_ring[mbox].fq_wrptr = entries - 1;\r\niowrite32(entries - 1, priv->regs + TSI721_IBDMAC_FQWP(ch));\r\npriv->imsg_init[mbox] = 1;\r\nreturn 0;\r\n#ifdef CONFIG_PCI_MSI\r\nout_desc:\r\ndma_free_coherent(&priv->pdev->dev,\r\npriv->imsg_ring[mbox].size * sizeof(struct tsi721_imsg_desc),\r\npriv->imsg_ring[mbox].imd_base,\r\npriv->imsg_ring[mbox].imd_phys);\r\npriv->imsg_ring[mbox].imd_base = NULL;\r\n#endif\r\nout_dma:\r\ndma_free_coherent(&priv->pdev->dev,\r\npriv->imsg_ring[mbox].size * 8,\r\npriv->imsg_ring[mbox].imfq_base,\r\npriv->imsg_ring[mbox].imfq_phys);\r\npriv->imsg_ring[mbox].imfq_base = NULL;\r\nout_buf:\r\ndma_free_coherent(&priv->pdev->dev,\r\npriv->imsg_ring[mbox].size * TSI721_MSG_BUFFER_SIZE,\r\npriv->imsg_ring[mbox].buf_base,\r\npriv->imsg_ring[mbox].buf_phys);\r\npriv->imsg_ring[mbox].buf_base = NULL;\r\nout:\r\nreturn rc;\r\n}\r\nstatic void tsi721_close_inb_mbox(struct rio_mport *mport, int mbox)\r\n{\r\nstruct tsi721_device *priv = mport->priv;\r\nu32 rx_slot;\r\nint ch = mbox + 4;\r\nif (!priv->imsg_init[mbox])\r\nreturn;\r\npriv->imsg_init[mbox] = 0;\r\ntsi721_imsg_interrupt_disable(priv, ch, TSI721_OBDMAC_INT_MASK);\r\n#ifdef CONFIG_PCI_MSI\r\nif (priv->flags & TSI721_USING_MSIX) {\r\nfree_irq(priv->msix[TSI721_VECT_IMB0_RCV + mbox].vector,\r\n(void *)mport);\r\nfree_irq(priv->msix[TSI721_VECT_IMB0_INT + mbox].vector,\r\n(void *)mport);\r\n}\r\n#endif\r\nfor (rx_slot = 0; rx_slot < priv->imsg_ring[mbox].size; rx_slot++)\r\npriv->imsg_ring[mbox].imq_base[rx_slot] = NULL;\r\ndma_free_coherent(&priv->pdev->dev,\r\npriv->imsg_ring[mbox].size * TSI721_MSG_BUFFER_SIZE,\r\npriv->imsg_ring[mbox].buf_base,\r\npriv->imsg_ring[mbox].buf_phys);\r\npriv->imsg_ring[mbox].buf_base = NULL;\r\ndma_free_coherent(&priv->pdev->dev,\r\npriv->imsg_ring[mbox].size * 8,\r\npriv->imsg_ring[mbox].imfq_base,\r\npriv->imsg_ring[mbox].imfq_phys);\r\npriv->imsg_ring[mbox].imfq_base = NULL;\r\ndma_free_coherent(&priv->pdev->dev,\r\npriv->imsg_ring[mbox].size * sizeof(struct tsi721_imsg_desc),\r\npriv->imsg_ring[mbox].imd_base,\r\npriv->imsg_ring[mbox].imd_phys);\r\npriv->imsg_ring[mbox].imd_base = NULL;\r\n}\r\nstatic int tsi721_add_inb_buffer(struct rio_mport *mport, int mbox, void *buf)\r\n{\r\nstruct tsi721_device *priv = mport->priv;\r\nu32 rx_slot;\r\nint rc = 0;\r\nrx_slot = priv->imsg_ring[mbox].rx_slot;\r\nif (priv->imsg_ring[mbox].imq_base[rx_slot]) {\r\ndev_err(&priv->pdev->dev,\r\n"Error adding inbound buffer %d, buffer exists\n",\r\nrx_slot);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\npriv->imsg_ring[mbox].imq_base[rx_slot] = buf;\r\nif (++priv->imsg_ring[mbox].rx_slot == priv->imsg_ring[mbox].size)\r\npriv->imsg_ring[mbox].rx_slot = 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic void *tsi721_get_inb_message(struct rio_mport *mport, int mbox)\r\n{\r\nstruct tsi721_device *priv = mport->priv;\r\nstruct tsi721_imsg_desc *desc;\r\nu32 rx_slot;\r\nvoid *rx_virt = NULL;\r\nu64 rx_phys;\r\nvoid *buf = NULL;\r\nu64 *free_ptr;\r\nint ch = mbox + 4;\r\nint msg_size;\r\nif (!priv->imsg_init[mbox])\r\nreturn NULL;\r\ndesc = priv->imsg_ring[mbox].imd_base;\r\ndesc += priv->imsg_ring[mbox].desc_rdptr;\r\nif (!(le32_to_cpu(desc->msg_info) & TSI721_IMD_HO))\r\ngoto out;\r\nrx_slot = priv->imsg_ring[mbox].rx_slot;\r\nwhile (priv->imsg_ring[mbox].imq_base[rx_slot] == NULL) {\r\nif (++rx_slot == priv->imsg_ring[mbox].size)\r\nrx_slot = 0;\r\n}\r\nrx_phys = ((u64)le32_to_cpu(desc->bufptr_hi) << 32) |\r\nle32_to_cpu(desc->bufptr_lo);\r\nrx_virt = priv->imsg_ring[mbox].buf_base +\r\n(rx_phys - (u64)priv->imsg_ring[mbox].buf_phys);\r\nbuf = priv->imsg_ring[mbox].imq_base[rx_slot];\r\nmsg_size = le32_to_cpu(desc->msg_info) & TSI721_IMD_BCOUNT;\r\nif (msg_size == 0)\r\nmsg_size = RIO_MAX_MSG_SIZE;\r\nmemcpy(buf, rx_virt, msg_size);\r\npriv->imsg_ring[mbox].imq_base[rx_slot] = NULL;\r\ndesc->msg_info &= cpu_to_le32(~TSI721_IMD_HO);\r\nif (++priv->imsg_ring[mbox].desc_rdptr == priv->imsg_ring[mbox].size)\r\npriv->imsg_ring[mbox].desc_rdptr = 0;\r\niowrite32(priv->imsg_ring[mbox].desc_rdptr,\r\npriv->regs + TSI721_IBDMAC_DQRP(ch));\r\nfree_ptr = priv->imsg_ring[mbox].imfq_base;\r\nfree_ptr[priv->imsg_ring[mbox].fq_wrptr] = cpu_to_le64(rx_phys);\r\nif (++priv->imsg_ring[mbox].fq_wrptr == priv->imsg_ring[mbox].size)\r\npriv->imsg_ring[mbox].fq_wrptr = 0;\r\niowrite32(priv->imsg_ring[mbox].fq_wrptr,\r\npriv->regs + TSI721_IBDMAC_FQWP(ch));\r\nout:\r\nreturn buf;\r\n}\r\nstatic int tsi721_messages_init(struct tsi721_device *priv)\r\n{\r\nint ch;\r\niowrite32(0, priv->regs + TSI721_SMSG_ECC_LOG);\r\niowrite32(0, priv->regs + TSI721_RETRY_GEN_CNT);\r\niowrite32(0, priv->regs + TSI721_RETRY_RX_CNT);\r\niowrite32(TSI721_RQRPTO_VAL, priv->regs + TSI721_RQRPTO);\r\nfor (ch = 0; ch < TSI721_IMSG_CHNUM; ch++) {\r\niowrite32(TSI721_IBDMAC_INT_MASK,\r\npriv->regs + TSI721_IBDMAC_INT(ch));\r\niowrite32(0, priv->regs + TSI721_IBDMAC_STS(ch));\r\niowrite32(TSI721_SMSG_ECC_COR_LOG_MASK,\r\npriv->regs + TSI721_SMSG_ECC_COR_LOG(ch));\r\niowrite32(TSI721_SMSG_ECC_NCOR_MASK,\r\npriv->regs + TSI721_SMSG_ECC_NCOR(ch));\r\n}\r\nreturn 0;\r\n}\r\nstatic void tsi721_disable_ints(struct tsi721_device *priv)\r\n{\r\nint ch;\r\niowrite32(0, priv->regs + TSI721_DEV_INTE);\r\niowrite32(0, priv->regs + TSI721_DEV_CHAN_INTE);\r\nfor (ch = 0; ch < TSI721_IMSG_CHNUM; ch++)\r\niowrite32(0, priv->regs + TSI721_IBDMAC_INTE(ch));\r\nfor (ch = 0; ch < TSI721_OMSG_CHNUM; ch++)\r\niowrite32(0, priv->regs + TSI721_OBDMAC_INTE(ch));\r\niowrite32(0, priv->regs + TSI721_SMSG_INTE);\r\nfor (ch = 0; ch < TSI721_DMA_MAXCH; ch++)\r\niowrite32(0,\r\npriv->regs + TSI721_DMAC_BASE(ch) + TSI721_DMAC_INTE);\r\niowrite32(0, priv->regs + TSI721_BDMA_INTE);\r\nfor (ch = 0; ch < TSI721_SRIO_MAXCH; ch++)\r\niowrite32(0, priv->regs + TSI721_SR_CHINTE(ch));\r\niowrite32(0, priv->regs + TSI721_SR2PC_GEN_INTE);\r\niowrite32(0, priv->regs + TSI721_PC2SR_INTE);\r\niowrite32(0, priv->regs + TSI721_I2C_INT_ENABLE);\r\niowrite32(0, priv->regs + TSI721_RIO_EM_INT_ENABLE);\r\niowrite32(0, priv->regs + TSI721_RIO_EM_DEV_INT_EN);\r\n}\r\nstatic int tsi721_setup_mport(struct tsi721_device *priv)\r\n{\r\nstruct pci_dev *pdev = priv->pdev;\r\nint err = 0;\r\nstruct rio_ops *ops;\r\nstruct rio_mport *mport;\r\nops = kzalloc(sizeof(struct rio_ops), GFP_KERNEL);\r\nif (!ops) {\r\ndev_dbg(&pdev->dev, "Unable to allocate memory for rio_ops\n");\r\nreturn -ENOMEM;\r\n}\r\nops->lcread = tsi721_lcread;\r\nops->lcwrite = tsi721_lcwrite;\r\nops->cread = tsi721_cread_dma;\r\nops->cwrite = tsi721_cwrite_dma;\r\nops->dsend = tsi721_dsend;\r\nops->open_inb_mbox = tsi721_open_inb_mbox;\r\nops->close_inb_mbox = tsi721_close_inb_mbox;\r\nops->open_outb_mbox = tsi721_open_outb_mbox;\r\nops->close_outb_mbox = tsi721_close_outb_mbox;\r\nops->add_outb_message = tsi721_add_outb_message;\r\nops->add_inb_buffer = tsi721_add_inb_buffer;\r\nops->get_inb_message = tsi721_get_inb_message;\r\nops->map_inb = tsi721_rio_map_inb_mem;\r\nops->unmap_inb = tsi721_rio_unmap_inb_mem;\r\nmport = kzalloc(sizeof(struct rio_mport), GFP_KERNEL);\r\nif (!mport) {\r\nkfree(ops);\r\ndev_dbg(&pdev->dev, "Unable to allocate memory for mport\n");\r\nreturn -ENOMEM;\r\n}\r\nmport->ops = ops;\r\nmport->index = 0;\r\nmport->sys_size = 0;\r\nmport->phy_type = RIO_PHY_SERIAL;\r\nmport->priv = (void *)priv;\r\nmport->phys_efptr = 0x100;\r\npriv->mport = mport;\r\nINIT_LIST_HEAD(&mport->dbells);\r\nrio_init_dbell_res(&mport->riores[RIO_DOORBELL_RESOURCE], 0, 0xffff);\r\nrio_init_mbox_res(&mport->riores[RIO_INB_MBOX_RESOURCE], 0, 3);\r\nrio_init_mbox_res(&mport->riores[RIO_OUTB_MBOX_RESOURCE], 0, 3);\r\nsnprintf(mport->name, RIO_MAX_MPORT_NAME, "%s(%s)",\r\ndev_driver_string(&pdev->dev), dev_name(&pdev->dev));\r\n#ifdef CONFIG_PCI_MSI\r\nif (!tsi721_enable_msix(priv))\r\npriv->flags |= TSI721_USING_MSIX;\r\nelse if (!pci_enable_msi(pdev))\r\npriv->flags |= TSI721_USING_MSI;\r\nelse\r\ndev_info(&pdev->dev,\r\n"MSI/MSI-X is not available. Using legacy INTx.\n");\r\n#endif\r\nerr = tsi721_request_irq(mport);\r\nif (!err) {\r\ntsi721_interrupts_init(priv);\r\nops->pwenable = tsi721_pw_enable;\r\n} else {\r\ndev_err(&pdev->dev, "Unable to get assigned PCI IRQ "\r\n"vector %02X err=0x%x\n", pdev->irq, err);\r\ngoto err_exit;\r\n}\r\n#ifdef CONFIG_RAPIDIO_DMA_ENGINE\r\ntsi721_register_dma(priv);\r\n#endif\r\niowrite32(ioread32(priv->regs + TSI721_DEVCTL) |\r\nTSI721_DEVCTL_SRBOOT_CMPL,\r\npriv->regs + TSI721_DEVCTL);\r\nrio_register_mport(mport);\r\nif (mport->host_deviceid >= 0)\r\niowrite32(RIO_PORT_GEN_HOST | RIO_PORT_GEN_MASTER |\r\nRIO_PORT_GEN_DISCOVERED,\r\npriv->regs + (0x100 + RIO_PORT_GEN_CTL_CSR));\r\nelse\r\niowrite32(0, priv->regs + (0x100 + RIO_PORT_GEN_CTL_CSR));\r\nreturn 0;\r\nerr_exit:\r\nkfree(mport);\r\nkfree(ops);\r\nreturn err;\r\n}\r\nstatic int tsi721_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct tsi721_device *priv;\r\nint err;\r\npriv = kzalloc(sizeof(struct tsi721_device), GFP_KERNEL);\r\nif (priv == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate memory for device\n");\r\nerr = -ENOMEM;\r\ngoto err_exit;\r\n}\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to enable PCI device\n");\r\ngoto err_clean;\r\n}\r\npriv->pdev = pdev;\r\n#ifdef DEBUG\r\n{\r\nint i;\r\nfor (i = 0; i <= PCI_STD_RESOURCE_END; i++) {\r\ndev_dbg(&pdev->dev, "res[%d] @ 0x%llx (0x%lx, 0x%lx)\n",\r\ni, (unsigned long long)pci_resource_start(pdev, i),\r\n(unsigned long)pci_resource_len(pdev, i),\r\npci_resource_flags(pdev, i));\r\n}\r\n}\r\n#endif\r\nif (!(pci_resource_flags(pdev, BAR_0) & IORESOURCE_MEM) ||\r\npci_resource_flags(pdev, BAR_0) & IORESOURCE_MEM_64 ||\r\npci_resource_len(pdev, BAR_0) < TSI721_REG_SPACE_SIZE) {\r\ndev_err(&pdev->dev,\r\n"Missing or misconfigured CSR BAR0, aborting.\n");\r\nerr = -ENODEV;\r\ngoto err_disable_pdev;\r\n}\r\nif (!(pci_resource_flags(pdev, BAR_1) & IORESOURCE_MEM) ||\r\npci_resource_flags(pdev, BAR_1) & IORESOURCE_MEM_64 ||\r\npci_resource_len(pdev, BAR_1) < TSI721_DB_WIN_SIZE) {\r\ndev_err(&pdev->dev,\r\n"Missing or misconfigured Doorbell BAR1, aborting.\n");\r\nerr = -ENODEV;\r\ngoto err_disable_pdev;\r\n}\r\nif ((pci_resource_flags(pdev, BAR_2) & IORESOURCE_MEM) &&\r\n(pci_resource_flags(pdev, BAR_2) & IORESOURCE_MEM_64)) {\r\ndev_info(&pdev->dev, "Outbound BAR2 is not used but enabled.\n");\r\n}\r\nif ((pci_resource_flags(pdev, BAR_4) & IORESOURCE_MEM) &&\r\n(pci_resource_flags(pdev, BAR_4) & IORESOURCE_MEM_64)) {\r\ndev_info(&pdev->dev, "Outbound BAR4 is not used but enabled.\n");\r\n}\r\nerr = pci_request_regions(pdev, DRV_NAME);\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot obtain PCI resources, "\r\n"aborting.\n");\r\ngoto err_disable_pdev;\r\n}\r\npci_set_master(pdev);\r\npriv->regs = pci_ioremap_bar(pdev, BAR_0);\r\nif (!priv->regs) {\r\ndev_err(&pdev->dev,\r\n"Unable to map device registers space, aborting\n");\r\nerr = -ENOMEM;\r\ngoto err_free_res;\r\n}\r\npriv->odb_base = pci_ioremap_bar(pdev, BAR_1);\r\nif (!priv->odb_base) {\r\ndev_err(&pdev->dev,\r\n"Unable to map outbound doorbells space, aborting\n");\r\nerr = -ENOMEM;\r\ngoto err_unmap_bars;\r\n}\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(64))) {\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (err) {\r\ndev_info(&pdev->dev, "Unable to set DMA mask\n");\r\ngoto err_unmap_bars;\r\n}\r\nif (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32)))\r\ndev_info(&pdev->dev, "Unable to set consistent DMA mask\n");\r\n} else {\r\nerr = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (err)\r\ndev_info(&pdev->dev, "Unable to set consistent DMA mask\n");\r\n}\r\nBUG_ON(!pci_is_pcie(pdev));\r\npcie_capability_clear_and_set_word(pdev, PCI_EXP_DEVCTL,\r\nPCI_EXP_DEVCTL_READRQ | PCI_EXP_DEVCTL_RELAX_EN |\r\nPCI_EXP_DEVCTL_NOSNOOP_EN,\r\n0x2 << MAX_READ_REQUEST_SZ_SHIFT);\r\npcie_capability_clear_and_set_word(pdev, PCI_EXP_DEVCTL2, 0xf, 0x2);\r\npci_write_config_dword(pdev, TSI721_PCIECFG_EPCTL, 0x01);\r\npci_write_config_dword(pdev, TSI721_PCIECFG_MSIXTBL,\r\nTSI721_MSIXTBL_OFFSET);\r\npci_write_config_dword(pdev, TSI721_PCIECFG_MSIXPBA,\r\nTSI721_MSIXPBA_OFFSET);\r\npci_write_config_dword(pdev, TSI721_PCIECFG_EPCTL, 0);\r\ntsi721_disable_ints(priv);\r\ntsi721_init_pc2sr_mapping(priv);\r\ntsi721_init_sr2pc_mapping(priv);\r\nif (tsi721_bdma_maint_init(priv)) {\r\ndev_err(&pdev->dev, "BDMA initialization failed, aborting\n");\r\nerr = -ENOMEM;\r\ngoto err_unmap_bars;\r\n}\r\nerr = tsi721_doorbell_init(priv);\r\nif (err)\r\ngoto err_free_bdma;\r\ntsi721_port_write_init(priv);\r\nerr = tsi721_messages_init(priv);\r\nif (err)\r\ngoto err_free_consistent;\r\nerr = tsi721_setup_mport(priv);\r\nif (err)\r\ngoto err_free_consistent;\r\nreturn 0;\r\nerr_free_consistent:\r\ntsi721_doorbell_free(priv);\r\nerr_free_bdma:\r\ntsi721_bdma_maint_free(priv);\r\nerr_unmap_bars:\r\nif (priv->regs)\r\niounmap(priv->regs);\r\nif (priv->odb_base)\r\niounmap(priv->odb_base);\r\nerr_free_res:\r\npci_release_regions(pdev);\r\npci_clear_master(pdev);\r\nerr_disable_pdev:\r\npci_disable_device(pdev);\r\nerr_clean:\r\nkfree(priv);\r\nerr_exit:\r\nreturn err;\r\n}\r\nstatic int __init tsi721_init(void)\r\n{\r\nreturn pci_register_driver(&tsi721_driver);\r\n}
