static irqreturn_t atmel_tsadcc_interrupt(int irq, void *dev)\r\n{\r\nstruct atmel_tsadcc *ts_dev = (struct atmel_tsadcc *)dev;\r\nstruct input_dev *input_dev = ts_dev->input;\r\nunsigned int status;\r\nunsigned int reg;\r\nstatus = atmel_tsadcc_read(ATMEL_TSADCC_SR);\r\nstatus &= atmel_tsadcc_read(ATMEL_TSADCC_IMR);\r\nif (status & ATMEL_TSADCC_NOCNT) {\r\nreg = atmel_tsadcc_read(ATMEL_TSADCC_MR) | ATMEL_TSADCC_PENDBC;\r\natmel_tsadcc_write(ATMEL_TSADCC_MR, reg);\r\natmel_tsadcc_write(ATMEL_TSADCC_TRGR, ATMEL_TSADCC_TRGMOD_NONE);\r\natmel_tsadcc_write(ATMEL_TSADCC_IDR,\r\nATMEL_TSADCC_EOC(3) | ATMEL_TSADCC_NOCNT);\r\natmel_tsadcc_write(ATMEL_TSADCC_IER, ATMEL_TSADCC_PENCNT);\r\ninput_report_key(input_dev, BTN_TOUCH, 0);\r\nts_dev->bufferedmeasure = 0;\r\ninput_sync(input_dev);\r\n} else if (status & ATMEL_TSADCC_PENCNT) {\r\nreg = atmel_tsadcc_read(ATMEL_TSADCC_MR);\r\nreg &= ~ATMEL_TSADCC_PENDBC;\r\natmel_tsadcc_write(ATMEL_TSADCC_IDR, ATMEL_TSADCC_PENCNT);\r\natmel_tsadcc_write(ATMEL_TSADCC_MR, reg);\r\natmel_tsadcc_write(ATMEL_TSADCC_IER,\r\nATMEL_TSADCC_EOC(3) | ATMEL_TSADCC_NOCNT);\r\natmel_tsadcc_write(ATMEL_TSADCC_TRGR,\r\nATMEL_TSADCC_TRGMOD_PERIOD | (0x0FFF << 16));\r\n} else if (status & ATMEL_TSADCC_EOC(3)) {\r\nif (ts_dev->bufferedmeasure) {\r\ninput_report_abs(input_dev, ABS_X, ts_dev->prev_absx);\r\ninput_report_abs(input_dev, ABS_Y, ts_dev->prev_absy);\r\ninput_report_key(input_dev, BTN_TOUCH, 1);\r\ninput_sync(input_dev);\r\n} else\r\nts_dev->bufferedmeasure = 1;\r\nts_dev->prev_absx = atmel_tsadcc_read(ATMEL_TSADCC_CDR3) << 10;\r\nts_dev->prev_absx /= atmel_tsadcc_read(ATMEL_TSADCC_CDR2);\r\nts_dev->prev_absy = atmel_tsadcc_read(ATMEL_TSADCC_CDR1) << 10;\r\nts_dev->prev_absy /= atmel_tsadcc_read(ATMEL_TSADCC_CDR0);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int atmel_tsadcc_probe(struct platform_device *pdev)\r\n{\r\nstruct atmel_tsadcc *ts_dev;\r\nstruct input_dev *input_dev;\r\nstruct resource *res;\r\nstruct at91_tsadcc_data *pdata = pdev->dev.platform_data;\r\nint err;\r\nunsigned int prsc;\r\nunsigned int reg;\r\nif (!pdata)\r\nreturn -EINVAL;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no mmio resource defined.\n");\r\nreturn -ENXIO;\r\n}\r\nts_dev = kzalloc(sizeof(struct atmel_tsadcc), GFP_KERNEL);\r\nif (!ts_dev) {\r\ndev_err(&pdev->dev, "failed to allocate memory.\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, ts_dev);\r\ninput_dev = input_allocate_device();\r\nif (!input_dev) {\r\ndev_err(&pdev->dev, "failed to allocate input device.\n");\r\nerr = -EBUSY;\r\ngoto err_free_mem;\r\n}\r\nts_dev->irq = platform_get_irq(pdev, 0);\r\nif (ts_dev->irq < 0) {\r\ndev_err(&pdev->dev, "no irq ID is designated.\n");\r\nerr = -ENODEV;\r\ngoto err_free_dev;\r\n}\r\nif (!request_mem_region(res->start, resource_size(res),\r\n"atmel tsadcc regs")) {\r\ndev_err(&pdev->dev, "resources is unavailable.\n");\r\nerr = -EBUSY;\r\ngoto err_free_dev;\r\n}\r\ntsc_base = ioremap(res->start, resource_size(res));\r\nif (!tsc_base) {\r\ndev_err(&pdev->dev, "failed to map registers.\n");\r\nerr = -ENOMEM;\r\ngoto err_release_mem;\r\n}\r\nerr = request_irq(ts_dev->irq, atmel_tsadcc_interrupt, 0,\r\npdev->dev.driver->name, ts_dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to allocate irq.\n");\r\ngoto err_unmap_regs;\r\n}\r\nts_dev->clk = clk_get(&pdev->dev, "tsc_clk");\r\nif (IS_ERR(ts_dev->clk)) {\r\ndev_err(&pdev->dev, "failed to get ts_clk\n");\r\nerr = PTR_ERR(ts_dev->clk);\r\ngoto err_free_irq;\r\n}\r\nts_dev->input = input_dev;\r\nts_dev->bufferedmeasure = 0;\r\nsnprintf(ts_dev->phys, sizeof(ts_dev->phys),\r\n"%s/input0", dev_name(&pdev->dev));\r\ninput_dev->name = "atmel touch screen controller";\r\ninput_dev->phys = ts_dev->phys;\r\ninput_dev->dev.parent = &pdev->dev;\r\n__set_bit(EV_ABS, input_dev->evbit);\r\ninput_set_abs_params(input_dev, ABS_X, 0, 0x3FF, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, 0x3FF, 0, 0);\r\ninput_set_capability(input_dev, EV_KEY, BTN_TOUCH);\r\nclk_enable(ts_dev->clk);\r\nprsc = clk_get_rate(ts_dev->clk);\r\ndev_info(&pdev->dev, "Master clock is set at: %d Hz\n", prsc);\r\nif (!pdata->adc_clock)\r\npdata->adc_clock = ADC_DEFAULT_CLOCK;\r\nprsc = (prsc / (2 * pdata->adc_clock)) - 1;\r\nif (cpu_is_at91sam9rl()) {\r\nif (prsc > PRESCALER_VAL(ATMEL_TSADCC_PRESCAL))\r\nprsc = PRESCALER_VAL(ATMEL_TSADCC_PRESCAL);\r\n} else {\r\nif (prsc > PRESCALER_VAL(ATMEL_TSADCC_EPRESCAL))\r\nprsc = PRESCALER_VAL(ATMEL_TSADCC_EPRESCAL);\r\n}\r\ndev_info(&pdev->dev, "Prescaler is set at: %d\n", prsc);\r\nreg = ATMEL_TSADCC_TSAMOD_TS_ONLY_MODE |\r\n((0x00 << 5) & ATMEL_TSADCC_SLEEP) |\r\n((0x01 << 6) & ATMEL_TSADCC_PENDET) |\r\n(prsc << 8) |\r\n((0x26 << 16) & ATMEL_TSADCC_STARTUP) |\r\n((pdata->pendet_debounce << 28) & ATMEL_TSADCC_PENDBC);\r\natmel_tsadcc_write(ATMEL_TSADCC_CR, ATMEL_TSADCC_SWRST);\r\natmel_tsadcc_write(ATMEL_TSADCC_MR, reg);\r\natmel_tsadcc_write(ATMEL_TSADCC_TRGR, ATMEL_TSADCC_TRGMOD_NONE);\r\natmel_tsadcc_write(ATMEL_TSADCC_TSR,\r\n(pdata->ts_sample_hold_time << 24) & ATMEL_TSADCC_TSSHTIM);\r\natmel_tsadcc_read(ATMEL_TSADCC_SR);\r\natmel_tsadcc_write(ATMEL_TSADCC_IER, ATMEL_TSADCC_PENCNT);\r\nerr = input_register_device(input_dev);\r\nif (err)\r\ngoto err_fail;\r\nreturn 0;\r\nerr_fail:\r\nclk_disable(ts_dev->clk);\r\nclk_put(ts_dev->clk);\r\nerr_free_irq:\r\nfree_irq(ts_dev->irq, ts_dev);\r\nerr_unmap_regs:\r\niounmap(tsc_base);\r\nerr_release_mem:\r\nrelease_mem_region(res->start, resource_size(res));\r\nerr_free_dev:\r\ninput_free_device(input_dev);\r\nerr_free_mem:\r\nkfree(ts_dev);\r\nreturn err;\r\n}\r\nstatic int atmel_tsadcc_remove(struct platform_device *pdev)\r\n{\r\nstruct atmel_tsadcc *ts_dev = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\nfree_irq(ts_dev->irq, ts_dev);\r\ninput_unregister_device(ts_dev->input);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\niounmap(tsc_base);\r\nrelease_mem_region(res->start, resource_size(res));\r\nclk_disable(ts_dev->clk);\r\nclk_put(ts_dev->clk);\r\nkfree(ts_dev);\r\nreturn 0;\r\n}
