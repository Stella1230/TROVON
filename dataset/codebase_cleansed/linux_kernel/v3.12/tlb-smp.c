void smp_flush_tlb(void *unused)\r\n{\r\nunsigned long cpu_id;\r\ncpu_id = get_cpu();\r\nif (!cpumask_test_cpu(cpu_id, &flush_cpumask))\r\ngoto out;\r\nif (flush_va == FLUSH_ALL)\r\nlocal_flush_tlb();\r\nelse\r\nlocal_flush_tlb_page(flush_mm, flush_va);\r\nsmp_mb__before_clear_bit();\r\ncpumask_clear_cpu(cpu_id, &flush_cpumask);\r\nsmp_mb__after_clear_bit();\r\nout:\r\nput_cpu();\r\n}\r\nstatic void flush_tlb_others(cpumask_t cpumask, struct mm_struct *mm,\r\nunsigned long va)\r\n{\r\ncpumask_t tmp;\r\nBUG_ON(!mm);\r\nBUG_ON(cpumask_empty(&cpumask));\r\nBUG_ON(cpumask_test_cpu(smp_processor_id(), &cpumask));\r\ncpumask_and(&tmp, &cpumask, cpu_online_mask);\r\nBUG_ON(!cpumask_equal(&cpumask, &tmp));\r\nspin_lock(&tlbstate_lock);\r\nflush_mm = mm;\r\nflush_va = va;\r\n#if NR_CPUS <= BITS_PER_LONG\r\natomic_set_mask(cpumask.bits[0], &flush_cpumask.bits[0]);\r\n#else\r\n#error Not supported.\r\n#endif\r\nsmp_call_function(smp_flush_tlb, NULL, 1);\r\nwhile (!cpumask_empty(&flush_cpumask))\r\nsmp_mb();\r\nflush_mm = NULL;\r\nflush_va = 0;\r\nspin_unlock(&tlbstate_lock);\r\n}\r\nvoid flush_tlb_mm(struct mm_struct *mm)\r\n{\r\ncpumask_t cpu_mask;\r\npreempt_disable();\r\ncpumask_copy(&cpu_mask, mm_cpumask(mm));\r\ncpumask_clear_cpu(smp_processor_id(), &cpu_mask);\r\nlocal_flush_tlb();\r\nif (!cpumask_empty(&cpu_mask))\r\nflush_tlb_others(cpu_mask, mm, FLUSH_ALL);\r\npreempt_enable();\r\n}\r\nvoid flush_tlb_current_task(void)\r\n{\r\nstruct mm_struct *mm = current->mm;\r\ncpumask_t cpu_mask;\r\npreempt_disable();\r\ncpumask_copy(&cpu_mask, mm_cpumask(mm));\r\ncpumask_clear_cpu(smp_processor_id(), &cpu_mask);\r\nlocal_flush_tlb();\r\nif (!cpumask_empty(&cpu_mask))\r\nflush_tlb_others(cpu_mask, mm, FLUSH_ALL);\r\npreempt_enable();\r\n}\r\nvoid flush_tlb_page(struct vm_area_struct *vma, unsigned long va)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\ncpumask_t cpu_mask;\r\npreempt_disable();\r\ncpumask_copy(&cpu_mask, mm_cpumask(mm));\r\ncpumask_clear_cpu(smp_processor_id(), &cpu_mask);\r\nlocal_flush_tlb_page(mm, va);\r\nif (!cpumask_empty(&cpu_mask))\r\nflush_tlb_others(cpu_mask, mm, va);\r\npreempt_enable();\r\n}\r\nstatic void do_flush_tlb_all(void *unused)\r\n{\r\nlocal_flush_tlb_all();\r\n}\r\nvoid flush_tlb_all(void)\r\n{\r\non_each_cpu(do_flush_tlb_all, 0, 1);\r\n}
