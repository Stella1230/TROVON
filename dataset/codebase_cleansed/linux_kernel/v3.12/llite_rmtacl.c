static inline __u32 rce_hashfunc(uid_t id)\r\n{\r\nreturn id & (RCE_HASHES - 1);\r\n}\r\nstatic inline __u32 ee_hashfunc(uid_t id)\r\n{\r\nreturn id & (EE_HASHES - 1);\r\n}\r\nobd_valid rce_ops2valid(int ops)\r\n{\r\nswitch (ops) {\r\ncase RMT_LSETFACL:\r\nreturn OBD_MD_FLRMTLSETFACL;\r\ncase RMT_LGETFACL:\r\nreturn OBD_MD_FLRMTLGETFACL;\r\ncase RMT_RSETFACL:\r\nreturn OBD_MD_FLRMTRSETFACL;\r\ncase RMT_RGETFACL:\r\nreturn OBD_MD_FLRMTRGETFACL;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic struct rmtacl_ctl_entry *rce_alloc(pid_t key, int ops)\r\n{\r\nstruct rmtacl_ctl_entry *rce;\r\nOBD_ALLOC_PTR(rce);\r\nif (!rce)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&rce->rce_list);\r\nrce->rce_key = key;\r\nrce->rce_ops = ops;\r\nreturn rce;\r\n}\r\nstatic void rce_free(struct rmtacl_ctl_entry *rce)\r\n{\r\nif (!list_empty(&rce->rce_list))\r\nlist_del(&rce->rce_list);\r\nOBD_FREE_PTR(rce);\r\n}\r\nstatic struct rmtacl_ctl_entry *__rct_search(struct rmtacl_ctl_table *rct,\r\npid_t key)\r\n{\r\nstruct rmtacl_ctl_entry *rce;\r\nstruct list_head *head = &rct->rct_entries[rce_hashfunc(key)];\r\nlist_for_each_entry(rce, head, rce_list)\r\nif (rce->rce_key == key)\r\nreturn rce;\r\nreturn NULL;\r\n}\r\nstruct rmtacl_ctl_entry *rct_search(struct rmtacl_ctl_table *rct, pid_t key)\r\n{\r\nstruct rmtacl_ctl_entry *rce;\r\nspin_lock(&rct->rct_lock);\r\nrce = __rct_search(rct, key);\r\nspin_unlock(&rct->rct_lock);\r\nreturn rce;\r\n}\r\nint rct_add(struct rmtacl_ctl_table *rct, pid_t key, int ops)\r\n{\r\nstruct rmtacl_ctl_entry *rce, *e;\r\nrce = rce_alloc(key, ops);\r\nif (rce == NULL)\r\nreturn -ENOMEM;\r\nspin_lock(&rct->rct_lock);\r\ne = __rct_search(rct, key);\r\nif (unlikely(e != NULL)) {\r\nCWARN("Unexpected stale rmtacl_entry found: "\r\n"[key: %d] [ops: %d]\n", (int)key, ops);\r\nrce_free(e);\r\n}\r\nlist_add_tail(&rce->rce_list, &rct->rct_entries[rce_hashfunc(key)]);\r\nspin_unlock(&rct->rct_lock);\r\nreturn 0;\r\n}\r\nint rct_del(struct rmtacl_ctl_table *rct, pid_t key)\r\n{\r\nstruct rmtacl_ctl_entry *rce;\r\nspin_lock(&rct->rct_lock);\r\nrce = __rct_search(rct, key);\r\nif (rce)\r\nrce_free(rce);\r\nspin_unlock(&rct->rct_lock);\r\nreturn rce ? 0 : -ENOENT;\r\n}\r\nvoid rct_init(struct rmtacl_ctl_table *rct)\r\n{\r\nint i;\r\nspin_lock_init(&rct->rct_lock);\r\nfor (i = 0; i < RCE_HASHES; i++)\r\nINIT_LIST_HEAD(&rct->rct_entries[i]);\r\n}\r\nvoid rct_fini(struct rmtacl_ctl_table *rct)\r\n{\r\nstruct rmtacl_ctl_entry *rce;\r\nint i;\r\nspin_lock(&rct->rct_lock);\r\nfor (i = 0; i < RCE_HASHES; i++)\r\nwhile (!list_empty(&rct->rct_entries[i])) {\r\nrce = list_entry(rct->rct_entries[i].next,\r\nstruct rmtacl_ctl_entry, rce_list);\r\nrce_free(rce);\r\n}\r\nspin_unlock(&rct->rct_lock);\r\n}\r\nstatic struct eacl_entry *ee_alloc(pid_t key, struct lu_fid *fid, int type,\r\next_acl_xattr_header *header)\r\n{\r\nstruct eacl_entry *ee;\r\nOBD_ALLOC_PTR(ee);\r\nif (!ee)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&ee->ee_list);\r\nee->ee_key = key;\r\nee->ee_fid = *fid;\r\nee->ee_type = type;\r\nee->ee_acl = header;\r\nreturn ee;\r\n}\r\nvoid ee_free(struct eacl_entry *ee)\r\n{\r\nif (!list_empty(&ee->ee_list))\r\nlist_del(&ee->ee_list);\r\nif (ee->ee_acl)\r\nlustre_ext_acl_xattr_free(ee->ee_acl);\r\nOBD_FREE_PTR(ee);\r\n}\r\nstatic struct eacl_entry *__et_search_del(struct eacl_table *et, pid_t key,\r\nstruct lu_fid *fid, int type)\r\n{\r\nstruct eacl_entry *ee;\r\nstruct list_head *head = &et->et_entries[ee_hashfunc(key)];\r\nLASSERT(fid != NULL);\r\nlist_for_each_entry(ee, head, ee_list)\r\nif (ee->ee_key == key) {\r\nif (lu_fid_eq(&ee->ee_fid, fid) &&\r\nee->ee_type == type) {\r\nlist_del_init(&ee->ee_list);\r\nreturn ee;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstruct eacl_entry *et_search_del(struct eacl_table *et, pid_t key,\r\nstruct lu_fid *fid, int type)\r\n{\r\nstruct eacl_entry *ee;\r\nspin_lock(&et->et_lock);\r\nee = __et_search_del(et, key, fid, type);\r\nspin_unlock(&et->et_lock);\r\nreturn ee;\r\n}\r\nvoid et_search_free(struct eacl_table *et, pid_t key)\r\n{\r\nstruct eacl_entry *ee, *next;\r\nstruct list_head *head = &et->et_entries[ee_hashfunc(key)];\r\nspin_lock(&et->et_lock);\r\nlist_for_each_entry_safe(ee, next, head, ee_list)\r\nif (ee->ee_key == key)\r\nee_free(ee);\r\nspin_unlock(&et->et_lock);\r\n}\r\nint ee_add(struct eacl_table *et, pid_t key, struct lu_fid *fid, int type,\r\next_acl_xattr_header *header)\r\n{\r\nstruct eacl_entry *ee, *e;\r\nee = ee_alloc(key, fid, type, header);\r\nif (ee == NULL)\r\nreturn -ENOMEM;\r\nspin_lock(&et->et_lock);\r\ne = __et_search_del(et, key, fid, type);\r\nif (unlikely(e != NULL)) {\r\nCWARN("Unexpected stale eacl_entry found: "\r\n"[key: %d] [fid: "DFID"] [type: %d]\n",\r\n(int)key, PFID(fid), type);\r\nee_free(e);\r\n}\r\nlist_add_tail(&ee->ee_list, &et->et_entries[ee_hashfunc(key)]);\r\nspin_unlock(&et->et_lock);\r\nreturn 0;\r\n}\r\nvoid et_init(struct eacl_table *et)\r\n{\r\nint i;\r\nspin_lock_init(&et->et_lock);\r\nfor (i = 0; i < EE_HASHES; i++)\r\nINIT_LIST_HEAD(&et->et_entries[i]);\r\n}\r\nvoid et_fini(struct eacl_table *et)\r\n{\r\nstruct eacl_entry *ee;\r\nint i;\r\nspin_lock(&et->et_lock);\r\nfor (i = 0; i < EE_HASHES; i++)\r\nwhile (!list_empty(&et->et_entries[i])) {\r\nee = list_entry(et->et_entries[i].next,\r\nstruct eacl_entry, ee_list);\r\nee_free(ee);\r\n}\r\nspin_unlock(&et->et_lock);\r\n}
