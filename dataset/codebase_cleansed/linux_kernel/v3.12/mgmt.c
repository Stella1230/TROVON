bool mgmt_valid_hdev(struct hci_dev *hdev)\r\n{\r\nreturn hdev->dev_type == HCI_BREDR;\r\n}\r\nstatic u8 mgmt_status(u8 hci_status)\r\n{\r\nif (hci_status < ARRAY_SIZE(mgmt_status_table))\r\nreturn mgmt_status_table[hci_status];\r\nreturn MGMT_STATUS_FAILED;\r\n}\r\nstatic int cmd_status(struct sock *sk, u16 index, u16 cmd, u8 status)\r\n{\r\nstruct sk_buff *skb;\r\nstruct mgmt_hdr *hdr;\r\nstruct mgmt_ev_cmd_status *ev;\r\nint err;\r\nBT_DBG("sock %p, index %u, cmd %u, status %u", sk, index, cmd, status);\r\nskb = alloc_skb(sizeof(*hdr) + sizeof(*ev), GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nhdr = (void *) skb_put(skb, sizeof(*hdr));\r\nhdr->opcode = __constant_cpu_to_le16(MGMT_EV_CMD_STATUS);\r\nhdr->index = cpu_to_le16(index);\r\nhdr->len = cpu_to_le16(sizeof(*ev));\r\nev = (void *) skb_put(skb, sizeof(*ev));\r\nev->status = status;\r\nev->opcode = cpu_to_le16(cmd);\r\nerr = sock_queue_rcv_skb(sk, skb);\r\nif (err < 0)\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic int cmd_complete(struct sock *sk, u16 index, u16 cmd, u8 status,\r\nvoid *rp, size_t rp_len)\r\n{\r\nstruct sk_buff *skb;\r\nstruct mgmt_hdr *hdr;\r\nstruct mgmt_ev_cmd_complete *ev;\r\nint err;\r\nBT_DBG("sock %p", sk);\r\nskb = alloc_skb(sizeof(*hdr) + sizeof(*ev) + rp_len, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nhdr = (void *) skb_put(skb, sizeof(*hdr));\r\nhdr->opcode = __constant_cpu_to_le16(MGMT_EV_CMD_COMPLETE);\r\nhdr->index = cpu_to_le16(index);\r\nhdr->len = cpu_to_le16(sizeof(*ev) + rp_len);\r\nev = (void *) skb_put(skb, sizeof(*ev) + rp_len);\r\nev->opcode = cpu_to_le16(cmd);\r\nev->status = status;\r\nif (rp)\r\nmemcpy(ev->data, rp, rp_len);\r\nerr = sock_queue_rcv_skb(sk, skb);\r\nif (err < 0)\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic int read_version(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 data_len)\r\n{\r\nstruct mgmt_rp_read_version rp;\r\nBT_DBG("sock %p", sk);\r\nrp.version = MGMT_VERSION;\r\nrp.revision = __constant_cpu_to_le16(MGMT_REVISION);\r\nreturn cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_VERSION, 0, &rp,\r\nsizeof(rp));\r\n}\r\nstatic int read_commands(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 data_len)\r\n{\r\nstruct mgmt_rp_read_commands *rp;\r\nconst u16 num_commands = ARRAY_SIZE(mgmt_commands);\r\nconst u16 num_events = ARRAY_SIZE(mgmt_events);\r\n__le16 *opcode;\r\nsize_t rp_size;\r\nint i, err;\r\nBT_DBG("sock %p", sk);\r\nrp_size = sizeof(*rp) + ((num_commands + num_events) * sizeof(u16));\r\nrp = kmalloc(rp_size, GFP_KERNEL);\r\nif (!rp)\r\nreturn -ENOMEM;\r\nrp->num_commands = __constant_cpu_to_le16(num_commands);\r\nrp->num_events = __constant_cpu_to_le16(num_events);\r\nfor (i = 0, opcode = rp->opcodes; i < num_commands; i++, opcode++)\r\nput_unaligned_le16(mgmt_commands[i], opcode);\r\nfor (i = 0; i < num_events; i++, opcode++)\r\nput_unaligned_le16(mgmt_events[i], opcode);\r\nerr = cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_COMMANDS, 0, rp,\r\nrp_size);\r\nkfree(rp);\r\nreturn err;\r\n}\r\nstatic int read_index_list(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 data_len)\r\n{\r\nstruct mgmt_rp_read_index_list *rp;\r\nstruct hci_dev *d;\r\nsize_t rp_len;\r\nu16 count;\r\nint err;\r\nBT_DBG("sock %p", sk);\r\nread_lock(&hci_dev_list_lock);\r\ncount = 0;\r\nlist_for_each_entry(d, &hci_dev_list, list) {\r\nif (!mgmt_valid_hdev(d))\r\ncontinue;\r\ncount++;\r\n}\r\nrp_len = sizeof(*rp) + (2 * count);\r\nrp = kmalloc(rp_len, GFP_ATOMIC);\r\nif (!rp) {\r\nread_unlock(&hci_dev_list_lock);\r\nreturn -ENOMEM;\r\n}\r\ncount = 0;\r\nlist_for_each_entry(d, &hci_dev_list, list) {\r\nif (test_bit(HCI_SETUP, &d->dev_flags))\r\ncontinue;\r\nif (!mgmt_valid_hdev(d))\r\ncontinue;\r\nrp->index[count++] = cpu_to_le16(d->id);\r\nBT_DBG("Added hci%u", d->id);\r\n}\r\nrp->num_controllers = cpu_to_le16(count);\r\nrp_len = sizeof(*rp) + (2 * count);\r\nread_unlock(&hci_dev_list_lock);\r\nerr = cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_INDEX_LIST, 0, rp,\r\nrp_len);\r\nkfree(rp);\r\nreturn err;\r\n}\r\nstatic u32 get_supported_settings(struct hci_dev *hdev)\r\n{\r\nu32 settings = 0;\r\nsettings |= MGMT_SETTING_POWERED;\r\nsettings |= MGMT_SETTING_PAIRABLE;\r\nif (lmp_ssp_capable(hdev))\r\nsettings |= MGMT_SETTING_SSP;\r\nif (lmp_bredr_capable(hdev)) {\r\nsettings |= MGMT_SETTING_CONNECTABLE;\r\nif (hdev->hci_ver >= BLUETOOTH_VER_1_2)\r\nsettings |= MGMT_SETTING_FAST_CONNECTABLE;\r\nsettings |= MGMT_SETTING_DISCOVERABLE;\r\nsettings |= MGMT_SETTING_BREDR;\r\nsettings |= MGMT_SETTING_LINK_SECURITY;\r\n}\r\nif (enable_hs)\r\nsettings |= MGMT_SETTING_HS;\r\nif (lmp_le_capable(hdev))\r\nsettings |= MGMT_SETTING_LE;\r\nreturn settings;\r\n}\r\nstatic u32 get_current_settings(struct hci_dev *hdev)\r\n{\r\nu32 settings = 0;\r\nif (hdev_is_powered(hdev))\r\nsettings |= MGMT_SETTING_POWERED;\r\nif (test_bit(HCI_CONNECTABLE, &hdev->dev_flags))\r\nsettings |= MGMT_SETTING_CONNECTABLE;\r\nif (test_bit(HCI_FAST_CONNECTABLE, &hdev->dev_flags))\r\nsettings |= MGMT_SETTING_FAST_CONNECTABLE;\r\nif (test_bit(HCI_DISCOVERABLE, &hdev->dev_flags))\r\nsettings |= MGMT_SETTING_DISCOVERABLE;\r\nif (test_bit(HCI_PAIRABLE, &hdev->dev_flags))\r\nsettings |= MGMT_SETTING_PAIRABLE;\r\nif (lmp_bredr_capable(hdev))\r\nsettings |= MGMT_SETTING_BREDR;\r\nif (test_bit(HCI_LE_ENABLED, &hdev->dev_flags))\r\nsettings |= MGMT_SETTING_LE;\r\nif (test_bit(HCI_LINK_SECURITY, &hdev->dev_flags))\r\nsettings |= MGMT_SETTING_LINK_SECURITY;\r\nif (test_bit(HCI_SSP_ENABLED, &hdev->dev_flags))\r\nsettings |= MGMT_SETTING_SSP;\r\nif (test_bit(HCI_HS_ENABLED, &hdev->dev_flags))\r\nsettings |= MGMT_SETTING_HS;\r\nreturn settings;\r\n}\r\nstatic u8 *create_uuid16_list(struct hci_dev *hdev, u8 *data, ptrdiff_t len)\r\n{\r\nu8 *ptr = data, *uuids_start = NULL;\r\nstruct bt_uuid *uuid;\r\nif (len < 4)\r\nreturn ptr;\r\nlist_for_each_entry(uuid, &hdev->uuids, list) {\r\nu16 uuid16;\r\nif (uuid->size != 16)\r\ncontinue;\r\nuuid16 = get_unaligned_le16(&uuid->uuid[12]);\r\nif (uuid16 < 0x1100)\r\ncontinue;\r\nif (uuid16 == PNP_INFO_SVCLASS_ID)\r\ncontinue;\r\nif (!uuids_start) {\r\nuuids_start = ptr;\r\nuuids_start[0] = 1;\r\nuuids_start[1] = EIR_UUID16_ALL;\r\nptr += 2;\r\n}\r\nif ((ptr - data) + sizeof(u16) > len) {\r\nuuids_start[1] = EIR_UUID16_SOME;\r\nbreak;\r\n}\r\n*ptr++ = (uuid16 & 0x00ff);\r\n*ptr++ = (uuid16 & 0xff00) >> 8;\r\nuuids_start[0] += sizeof(uuid16);\r\n}\r\nreturn ptr;\r\n}\r\nstatic u8 *create_uuid32_list(struct hci_dev *hdev, u8 *data, ptrdiff_t len)\r\n{\r\nu8 *ptr = data, *uuids_start = NULL;\r\nstruct bt_uuid *uuid;\r\nif (len < 6)\r\nreturn ptr;\r\nlist_for_each_entry(uuid, &hdev->uuids, list) {\r\nif (uuid->size != 32)\r\ncontinue;\r\nif (!uuids_start) {\r\nuuids_start = ptr;\r\nuuids_start[0] = 1;\r\nuuids_start[1] = EIR_UUID32_ALL;\r\nptr += 2;\r\n}\r\nif ((ptr - data) + sizeof(u32) > len) {\r\nuuids_start[1] = EIR_UUID32_SOME;\r\nbreak;\r\n}\r\nmemcpy(ptr, &uuid->uuid[12], sizeof(u32));\r\nptr += sizeof(u32);\r\nuuids_start[0] += sizeof(u32);\r\n}\r\nreturn ptr;\r\n}\r\nstatic u8 *create_uuid128_list(struct hci_dev *hdev, u8 *data, ptrdiff_t len)\r\n{\r\nu8 *ptr = data, *uuids_start = NULL;\r\nstruct bt_uuid *uuid;\r\nif (len < 18)\r\nreturn ptr;\r\nlist_for_each_entry(uuid, &hdev->uuids, list) {\r\nif (uuid->size != 128)\r\ncontinue;\r\nif (!uuids_start) {\r\nuuids_start = ptr;\r\nuuids_start[0] = 1;\r\nuuids_start[1] = EIR_UUID128_ALL;\r\nptr += 2;\r\n}\r\nif ((ptr - data) + 16 > len) {\r\nuuids_start[1] = EIR_UUID128_SOME;\r\nbreak;\r\n}\r\nmemcpy(ptr, uuid->uuid, 16);\r\nptr += 16;\r\nuuids_start[0] += 16;\r\n}\r\nreturn ptr;\r\n}\r\nstatic void create_eir(struct hci_dev *hdev, u8 *data)\r\n{\r\nu8 *ptr = data;\r\nsize_t name_len;\r\nname_len = strlen(hdev->dev_name);\r\nif (name_len > 0) {\r\nif (name_len > 48) {\r\nname_len = 48;\r\nptr[1] = EIR_NAME_SHORT;\r\n} else\r\nptr[1] = EIR_NAME_COMPLETE;\r\nptr[0] = name_len + 1;\r\nmemcpy(ptr + 2, hdev->dev_name, name_len);\r\nptr += (name_len + 2);\r\n}\r\nif (hdev->inq_tx_power != HCI_TX_POWER_INVALID) {\r\nptr[0] = 2;\r\nptr[1] = EIR_TX_POWER;\r\nptr[2] = (u8) hdev->inq_tx_power;\r\nptr += 3;\r\n}\r\nif (hdev->devid_source > 0) {\r\nptr[0] = 9;\r\nptr[1] = EIR_DEVICE_ID;\r\nput_unaligned_le16(hdev->devid_source, ptr + 2);\r\nput_unaligned_le16(hdev->devid_vendor, ptr + 4);\r\nput_unaligned_le16(hdev->devid_product, ptr + 6);\r\nput_unaligned_le16(hdev->devid_version, ptr + 8);\r\nptr += 10;\r\n}\r\nptr = create_uuid16_list(hdev, ptr, HCI_MAX_EIR_LENGTH - (ptr - data));\r\nptr = create_uuid32_list(hdev, ptr, HCI_MAX_EIR_LENGTH - (ptr - data));\r\nptr = create_uuid128_list(hdev, ptr, HCI_MAX_EIR_LENGTH - (ptr - data));\r\n}\r\nstatic void update_eir(struct hci_request *req)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nstruct hci_cp_write_eir cp;\r\nif (!hdev_is_powered(hdev))\r\nreturn;\r\nif (!lmp_ext_inq_capable(hdev))\r\nreturn;\r\nif (!test_bit(HCI_SSP_ENABLED, &hdev->dev_flags))\r\nreturn;\r\nif (test_bit(HCI_SERVICE_CACHE, &hdev->dev_flags))\r\nreturn;\r\nmemset(&cp, 0, sizeof(cp));\r\ncreate_eir(hdev, cp.data);\r\nif (memcmp(cp.data, hdev->eir, sizeof(cp.data)) == 0)\r\nreturn;\r\nmemcpy(hdev->eir, cp.data, sizeof(cp.data));\r\nhci_req_add(req, HCI_OP_WRITE_EIR, sizeof(cp), &cp);\r\n}\r\nstatic u8 get_service_classes(struct hci_dev *hdev)\r\n{\r\nstruct bt_uuid *uuid;\r\nu8 val = 0;\r\nlist_for_each_entry(uuid, &hdev->uuids, list)\r\nval |= uuid->svc_hint;\r\nreturn val;\r\n}\r\nstatic void update_class(struct hci_request *req)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nu8 cod[3];\r\nBT_DBG("%s", hdev->name);\r\nif (!hdev_is_powered(hdev))\r\nreturn;\r\nif (test_bit(HCI_SERVICE_CACHE, &hdev->dev_flags))\r\nreturn;\r\ncod[0] = hdev->minor_class;\r\ncod[1] = hdev->major_class;\r\ncod[2] = get_service_classes(hdev);\r\nif (memcmp(cod, hdev->dev_class, 3) == 0)\r\nreturn;\r\nhci_req_add(req, HCI_OP_WRITE_CLASS_OF_DEV, sizeof(cod), cod);\r\n}\r\nstatic void service_cache_off(struct work_struct *work)\r\n{\r\nstruct hci_dev *hdev = container_of(work, struct hci_dev,\r\nservice_cache.work);\r\nstruct hci_request req;\r\nif (!test_and_clear_bit(HCI_SERVICE_CACHE, &hdev->dev_flags))\r\nreturn;\r\nhci_req_init(&req, hdev);\r\nhci_dev_lock(hdev);\r\nupdate_eir(&req);\r\nupdate_class(&req);\r\nhci_dev_unlock(hdev);\r\nhci_req_run(&req, NULL);\r\n}\r\nstatic void mgmt_init_hdev(struct sock *sk, struct hci_dev *hdev)\r\n{\r\nif (test_and_set_bit(HCI_MGMT, &hdev->dev_flags))\r\nreturn;\r\nINIT_DELAYED_WORK(&hdev->service_cache, service_cache_off);\r\nclear_bit(HCI_PAIRABLE, &hdev->dev_flags);\r\n}\r\nstatic int read_controller_info(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 data_len)\r\n{\r\nstruct mgmt_rp_read_info rp;\r\nBT_DBG("sock %p %s", sk, hdev->name);\r\nhci_dev_lock(hdev);\r\nmemset(&rp, 0, sizeof(rp));\r\nbacpy(&rp.bdaddr, &hdev->bdaddr);\r\nrp.version = hdev->hci_ver;\r\nrp.manufacturer = cpu_to_le16(hdev->manufacturer);\r\nrp.supported_settings = cpu_to_le32(get_supported_settings(hdev));\r\nrp.current_settings = cpu_to_le32(get_current_settings(hdev));\r\nmemcpy(rp.dev_class, hdev->dev_class, 3);\r\nmemcpy(rp.name, hdev->dev_name, sizeof(hdev->dev_name));\r\nmemcpy(rp.short_name, hdev->short_name, sizeof(hdev->short_name));\r\nhci_dev_unlock(hdev);\r\nreturn cmd_complete(sk, hdev->id, MGMT_OP_READ_INFO, 0, &rp,\r\nsizeof(rp));\r\n}\r\nstatic void mgmt_pending_free(struct pending_cmd *cmd)\r\n{\r\nsock_put(cmd->sk);\r\nkfree(cmd->param);\r\nkfree(cmd);\r\n}\r\nstatic struct pending_cmd *mgmt_pending_add(struct sock *sk, u16 opcode,\r\nstruct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct pending_cmd *cmd;\r\ncmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (!cmd)\r\nreturn NULL;\r\ncmd->opcode = opcode;\r\ncmd->index = hdev->id;\r\ncmd->param = kmalloc(len, GFP_KERNEL);\r\nif (!cmd->param) {\r\nkfree(cmd);\r\nreturn NULL;\r\n}\r\nif (data)\r\nmemcpy(cmd->param, data, len);\r\ncmd->sk = sk;\r\nsock_hold(sk);\r\nlist_add(&cmd->list, &hdev->mgmt_pending);\r\nreturn cmd;\r\n}\r\nstatic void mgmt_pending_foreach(u16 opcode, struct hci_dev *hdev,\r\nvoid (*cb)(struct pending_cmd *cmd,\r\nvoid *data),\r\nvoid *data)\r\n{\r\nstruct pending_cmd *cmd, *tmp;\r\nlist_for_each_entry_safe(cmd, tmp, &hdev->mgmt_pending, list) {\r\nif (opcode > 0 && cmd->opcode != opcode)\r\ncontinue;\r\ncb(cmd, data);\r\n}\r\n}\r\nstatic struct pending_cmd *mgmt_pending_find(u16 opcode, struct hci_dev *hdev)\r\n{\r\nstruct pending_cmd *cmd;\r\nlist_for_each_entry(cmd, &hdev->mgmt_pending, list) {\r\nif (cmd->opcode == opcode)\r\nreturn cmd;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void mgmt_pending_remove(struct pending_cmd *cmd)\r\n{\r\nlist_del(&cmd->list);\r\nmgmt_pending_free(cmd);\r\n}\r\nstatic int send_settings_rsp(struct sock *sk, u16 opcode, struct hci_dev *hdev)\r\n{\r\n__le32 settings = cpu_to_le32(get_current_settings(hdev));\r\nreturn cmd_complete(sk, hdev->id, opcode, 0, &settings,\r\nsizeof(settings));\r\n}\r\nstatic int set_powered(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nstruct pending_cmd *cmd;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nif (cp->val != 0x00 && cp->val != 0x01)\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_POWERED,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nif (test_and_clear_bit(HCI_AUTO_OFF, &hdev->dev_flags)) {\r\ncancel_delayed_work(&hdev->power_off);\r\nif (cp->val) {\r\nmgmt_pending_add(sk, MGMT_OP_SET_POWERED, hdev,\r\ndata, len);\r\nerr = mgmt_powered(hdev, 1);\r\ngoto failed;\r\n}\r\n}\r\nif (!!cp->val == hdev_is_powered(hdev)) {\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_POWERED, hdev);\r\ngoto failed;\r\n}\r\nif (mgmt_pending_find(MGMT_OP_SET_POWERED, hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_SET_POWERED,\r\nMGMT_STATUS_BUSY);\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_POWERED, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nif (cp->val)\r\nqueue_work(hdev->req_workqueue, &hdev->power_on);\r\nelse\r\nqueue_work(hdev->req_workqueue, &hdev->power_off.work);\r\nerr = 0;\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int mgmt_event(u16 event, struct hci_dev *hdev, void *data, u16 data_len,\r\nstruct sock *skip_sk)\r\n{\r\nstruct sk_buff *skb;\r\nstruct mgmt_hdr *hdr;\r\nskb = alloc_skb(sizeof(*hdr) + data_len, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nhdr = (void *) skb_put(skb, sizeof(*hdr));\r\nhdr->opcode = cpu_to_le16(event);\r\nif (hdev)\r\nhdr->index = cpu_to_le16(hdev->id);\r\nelse\r\nhdr->index = __constant_cpu_to_le16(MGMT_INDEX_NONE);\r\nhdr->len = cpu_to_le16(data_len);\r\nif (data)\r\nmemcpy(skb_put(skb, data_len), data, data_len);\r\n__net_timestamp(skb);\r\nhci_send_to_control(skb, skip_sk);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int new_settings(struct hci_dev *hdev, struct sock *skip)\r\n{\r\n__le32 ev;\r\nev = cpu_to_le32(get_current_settings(hdev));\r\nreturn mgmt_event(MGMT_EV_NEW_SETTINGS, hdev, &ev, sizeof(ev), skip);\r\n}\r\nstatic int set_discoverable(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_set_discoverable *cp = data;\r\nstruct pending_cmd *cmd;\r\nu16 timeout;\r\nu8 scan;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nif (!lmp_bredr_capable(hdev))\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nif (cp->val != 0x00 && cp->val != 0x01)\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\r\nMGMT_STATUS_INVALID_PARAMS);\r\ntimeout = __le16_to_cpu(cp->timeout);\r\nif (!cp->val && timeout > 0)\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev) && timeout > 0) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\r\nMGMT_STATUS_NOT_POWERED);\r\ngoto failed;\r\n}\r\nif (mgmt_pending_find(MGMT_OP_SET_DISCOVERABLE, hdev) ||\r\nmgmt_pending_find(MGMT_OP_SET_CONNECTABLE, hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\r\nMGMT_STATUS_BUSY);\r\ngoto failed;\r\n}\r\nif (!test_bit(HCI_CONNECTABLE, &hdev->dev_flags)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\r\nMGMT_STATUS_REJECTED);\r\ngoto failed;\r\n}\r\nif (!hdev_is_powered(hdev)) {\r\nbool changed = false;\r\nif (!!cp->val != test_bit(HCI_DISCOVERABLE, &hdev->dev_flags)) {\r\nchange_bit(HCI_DISCOVERABLE, &hdev->dev_flags);\r\nchanged = true;\r\n}\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_DISCOVERABLE, hdev);\r\nif (err < 0)\r\ngoto failed;\r\nif (changed)\r\nerr = new_settings(hdev, sk);\r\ngoto failed;\r\n}\r\nif (!!cp->val == test_bit(HCI_DISCOVERABLE, &hdev->dev_flags)) {\r\nif (hdev->discov_timeout > 0) {\r\ncancel_delayed_work(&hdev->discov_off);\r\nhdev->discov_timeout = 0;\r\n}\r\nif (cp->val && timeout > 0) {\r\nhdev->discov_timeout = timeout;\r\nqueue_delayed_work(hdev->workqueue, &hdev->discov_off,\r\nmsecs_to_jiffies(hdev->discov_timeout * 1000));\r\n}\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_DISCOVERABLE, hdev);\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_DISCOVERABLE, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nscan = SCAN_PAGE;\r\nif (cp->val)\r\nscan |= SCAN_INQUIRY;\r\nelse\r\ncancel_delayed_work(&hdev->discov_off);\r\nerr = hci_send_cmd(hdev, HCI_OP_WRITE_SCAN_ENABLE, 1, &scan);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nif (cp->val)\r\nhdev->discov_timeout = timeout;\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic void write_fast_connectable(struct hci_request *req, bool enable)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nstruct hci_cp_write_page_scan_activity acp;\r\nu8 type;\r\nif (hdev->hci_ver < BLUETOOTH_VER_1_2)\r\nreturn;\r\nif (enable) {\r\ntype = PAGE_SCAN_TYPE_INTERLACED;\r\nacp.interval = __constant_cpu_to_le16(0x0100);\r\n} else {\r\ntype = PAGE_SCAN_TYPE_STANDARD;\r\nacp.interval = __constant_cpu_to_le16(0x0800);\r\n}\r\nacp.window = __constant_cpu_to_le16(0x0012);\r\nif (__cpu_to_le16(hdev->page_scan_interval) != acp.interval ||\r\n__cpu_to_le16(hdev->page_scan_window) != acp.window)\r\nhci_req_add(req, HCI_OP_WRITE_PAGE_SCAN_ACTIVITY,\r\nsizeof(acp), &acp);\r\nif (hdev->page_scan_type != type)\r\nhci_req_add(req, HCI_OP_WRITE_PAGE_SCAN_TYPE, 1, &type);\r\n}\r\nstatic void set_connectable_complete(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct pending_cmd *cmd;\r\nBT_DBG("status 0x%02x", status);\r\nhci_dev_lock(hdev);\r\ncmd = mgmt_pending_find(MGMT_OP_SET_CONNECTABLE, hdev);\r\nif (!cmd)\r\ngoto unlock;\r\nsend_settings_rsp(cmd->sk, MGMT_OP_SET_CONNECTABLE, hdev);\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic int set_connectable(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nstruct pending_cmd *cmd;\r\nstruct hci_request req;\r\nu8 scan;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nif (!lmp_bredr_capable(hdev))\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_CONNECTABLE,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nif (cp->val != 0x00 && cp->val != 0x01)\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_CONNECTABLE,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nbool changed = false;\r\nif (!!cp->val != test_bit(HCI_CONNECTABLE, &hdev->dev_flags))\r\nchanged = true;\r\nif (cp->val) {\r\nset_bit(HCI_CONNECTABLE, &hdev->dev_flags);\r\n} else {\r\nclear_bit(HCI_CONNECTABLE, &hdev->dev_flags);\r\nclear_bit(HCI_DISCOVERABLE, &hdev->dev_flags);\r\n}\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_CONNECTABLE, hdev);\r\nif (err < 0)\r\ngoto failed;\r\nif (changed)\r\nerr = new_settings(hdev, sk);\r\ngoto failed;\r\n}\r\nif (mgmt_pending_find(MGMT_OP_SET_DISCOVERABLE, hdev) ||\r\nmgmt_pending_find(MGMT_OP_SET_CONNECTABLE, hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_SET_CONNECTABLE,\r\nMGMT_STATUS_BUSY);\r\ngoto failed;\r\n}\r\nif (!!cp->val == test_bit(HCI_PSCAN, &hdev->flags)) {\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_CONNECTABLE, hdev);\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_CONNECTABLE, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nif (cp->val) {\r\nscan = SCAN_PAGE;\r\n} else {\r\nscan = 0;\r\nif (test_bit(HCI_ISCAN, &hdev->flags) &&\r\nhdev->discov_timeout > 0)\r\ncancel_delayed_work(&hdev->discov_off);\r\n}\r\nhci_req_init(&req, hdev);\r\nhci_req_add(&req, HCI_OP_WRITE_SCAN_ENABLE, 1, &scan);\r\nif (cp->val || test_bit(HCI_FAST_CONNECTABLE, &hdev->dev_flags))\r\nwrite_fast_connectable(&req, false);\r\nerr = hci_req_run(&req, set_connectable_complete);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int set_pairable(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nif (cp->val != 0x00 && cp->val != 0x01)\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_PAIRABLE,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nif (cp->val)\r\nset_bit(HCI_PAIRABLE, &hdev->dev_flags);\r\nelse\r\nclear_bit(HCI_PAIRABLE, &hdev->dev_flags);\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_PAIRABLE, hdev);\r\nif (err < 0)\r\ngoto failed;\r\nerr = new_settings(hdev, sk);\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int set_link_security(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nstruct pending_cmd *cmd;\r\nu8 val;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nif (!lmp_bredr_capable(hdev))\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_LINK_SECURITY,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nif (cp->val != 0x00 && cp->val != 0x01)\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_LINK_SECURITY,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nbool changed = false;\r\nif (!!cp->val != test_bit(HCI_LINK_SECURITY,\r\n&hdev->dev_flags)) {\r\nchange_bit(HCI_LINK_SECURITY, &hdev->dev_flags);\r\nchanged = true;\r\n}\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_LINK_SECURITY, hdev);\r\nif (err < 0)\r\ngoto failed;\r\nif (changed)\r\nerr = new_settings(hdev, sk);\r\ngoto failed;\r\n}\r\nif (mgmt_pending_find(MGMT_OP_SET_LINK_SECURITY, hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_SET_LINK_SECURITY,\r\nMGMT_STATUS_BUSY);\r\ngoto failed;\r\n}\r\nval = !!cp->val;\r\nif (test_bit(HCI_AUTH, &hdev->flags) == val) {\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_LINK_SECURITY, hdev);\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_LINK_SECURITY, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nerr = hci_send_cmd(hdev, HCI_OP_WRITE_AUTH_ENABLE, sizeof(val), &val);\r\nif (err < 0) {\r\nmgmt_pending_remove(cmd);\r\ngoto failed;\r\n}\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int set_ssp(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nstruct pending_cmd *cmd;\r\nu8 val;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nif (!lmp_ssp_capable(hdev))\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_SSP,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nif (cp->val != 0x00 && cp->val != 0x01)\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_SSP,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nval = !!cp->val;\r\nif (!hdev_is_powered(hdev)) {\r\nbool changed = false;\r\nif (val != test_bit(HCI_SSP_ENABLED, &hdev->dev_flags)) {\r\nchange_bit(HCI_SSP_ENABLED, &hdev->dev_flags);\r\nchanged = true;\r\n}\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_SSP, hdev);\r\nif (err < 0)\r\ngoto failed;\r\nif (changed)\r\nerr = new_settings(hdev, sk);\r\ngoto failed;\r\n}\r\nif (mgmt_pending_find(MGMT_OP_SET_SSP, hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_SET_SSP,\r\nMGMT_STATUS_BUSY);\r\ngoto failed;\r\n}\r\nif (test_bit(HCI_SSP_ENABLED, &hdev->dev_flags) == val) {\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_SSP, hdev);\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_SSP, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nerr = hci_send_cmd(hdev, HCI_OP_WRITE_SSP_MODE, sizeof(val), &val);\r\nif (err < 0) {\r\nmgmt_pending_remove(cmd);\r\ngoto failed;\r\n}\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int set_hs(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nBT_DBG("request for %s", hdev->name);\r\nif (!enable_hs)\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_HS,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nif (cp->val != 0x00 && cp->val != 0x01)\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_HS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nif (cp->val)\r\nset_bit(HCI_HS_ENABLED, &hdev->dev_flags);\r\nelse\r\nclear_bit(HCI_HS_ENABLED, &hdev->dev_flags);\r\nreturn send_settings_rsp(sk, MGMT_OP_SET_HS, hdev);\r\n}\r\nstatic int set_le(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nstruct hci_cp_write_le_host_supported hci_cp;\r\nstruct pending_cmd *cmd;\r\nint err;\r\nu8 val, enabled;\r\nBT_DBG("request for %s", hdev->name);\r\nif (!lmp_le_capable(hdev))\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_LE,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nif (cp->val != 0x00 && cp->val != 0x01)\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_LE,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nif (!lmp_bredr_capable(hdev))\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_LE,\r\nMGMT_STATUS_REJECTED);\r\nhci_dev_lock(hdev);\r\nval = !!cp->val;\r\nenabled = lmp_host_le_capable(hdev);\r\nif (!hdev_is_powered(hdev) || val == enabled) {\r\nbool changed = false;\r\nif (val != test_bit(HCI_LE_ENABLED, &hdev->dev_flags)) {\r\nchange_bit(HCI_LE_ENABLED, &hdev->dev_flags);\r\nchanged = true;\r\n}\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_LE, hdev);\r\nif (err < 0)\r\ngoto unlock;\r\nif (changed)\r\nerr = new_settings(hdev, sk);\r\ngoto unlock;\r\n}\r\nif (mgmt_pending_find(MGMT_OP_SET_LE, hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_SET_LE,\r\nMGMT_STATUS_BUSY);\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_LE, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\nmemset(&hci_cp, 0, sizeof(hci_cp));\r\nif (val) {\r\nhci_cp.le = val;\r\nhci_cp.simul = lmp_le_br_capable(hdev);\r\n}\r\nerr = hci_send_cmd(hdev, HCI_OP_WRITE_LE_HOST_SUPPORTED, sizeof(hci_cp),\r\n&hci_cp);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic bool pending_eir_or_class(struct hci_dev *hdev)\r\n{\r\nstruct pending_cmd *cmd;\r\nlist_for_each_entry(cmd, &hdev->mgmt_pending, list) {\r\nswitch (cmd->opcode) {\r\ncase MGMT_OP_ADD_UUID:\r\ncase MGMT_OP_REMOVE_UUID:\r\ncase MGMT_OP_SET_DEV_CLASS:\r\ncase MGMT_OP_SET_POWERED:\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic u8 get_uuid_size(const u8 *uuid)\r\n{\r\nu32 val;\r\nif (memcmp(uuid, bluetooth_base_uuid, 12))\r\nreturn 128;\r\nval = get_unaligned_le32(&uuid[12]);\r\nif (val > 0xffff)\r\nreturn 32;\r\nreturn 16;\r\n}\r\nstatic void mgmt_class_complete(struct hci_dev *hdev, u16 mgmt_op, u8 status)\r\n{\r\nstruct pending_cmd *cmd;\r\nhci_dev_lock(hdev);\r\ncmd = mgmt_pending_find(mgmt_op, hdev);\r\nif (!cmd)\r\ngoto unlock;\r\ncmd_complete(cmd->sk, cmd->index, cmd->opcode, mgmt_status(status),\r\nhdev->dev_class, 3);\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void add_uuid_complete(struct hci_dev *hdev, u8 status)\r\n{\r\nBT_DBG("status 0x%02x", status);\r\nmgmt_class_complete(hdev, MGMT_OP_ADD_UUID, status);\r\n}\r\nstatic int add_uuid(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\r\n{\r\nstruct mgmt_cp_add_uuid *cp = data;\r\nstruct pending_cmd *cmd;\r\nstruct hci_request req;\r\nstruct bt_uuid *uuid;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nhci_dev_lock(hdev);\r\nif (pending_eir_or_class(hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_ADD_UUID,\r\nMGMT_STATUS_BUSY);\r\ngoto failed;\r\n}\r\nuuid = kmalloc(sizeof(*uuid), GFP_KERNEL);\r\nif (!uuid) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nmemcpy(uuid->uuid, cp->uuid, 16);\r\nuuid->svc_hint = cp->svc_hint;\r\nuuid->size = get_uuid_size(cp->uuid);\r\nlist_add_tail(&uuid->list, &hdev->uuids);\r\nhci_req_init(&req, hdev);\r\nupdate_class(&req);\r\nupdate_eir(&req);\r\nerr = hci_req_run(&req, add_uuid_complete);\r\nif (err < 0) {\r\nif (err != -ENODATA)\r\ngoto failed;\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_ADD_UUID, 0,\r\nhdev->dev_class, 3);\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_ADD_UUID, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nerr = 0;\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic bool enable_service_cache(struct hci_dev *hdev)\r\n{\r\nif (!hdev_is_powered(hdev))\r\nreturn false;\r\nif (!test_and_set_bit(HCI_SERVICE_CACHE, &hdev->dev_flags)) {\r\nqueue_delayed_work(hdev->workqueue, &hdev->service_cache,\r\nCACHE_TIMEOUT);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void remove_uuid_complete(struct hci_dev *hdev, u8 status)\r\n{\r\nBT_DBG("status 0x%02x", status);\r\nmgmt_class_complete(hdev, MGMT_OP_REMOVE_UUID, status);\r\n}\r\nstatic int remove_uuid(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_remove_uuid *cp = data;\r\nstruct pending_cmd *cmd;\r\nstruct bt_uuid *match, *tmp;\r\nu8 bt_uuid_any[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\r\nstruct hci_request req;\r\nint err, found;\r\nBT_DBG("request for %s", hdev->name);\r\nhci_dev_lock(hdev);\r\nif (pending_eir_or_class(hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_REMOVE_UUID,\r\nMGMT_STATUS_BUSY);\r\ngoto unlock;\r\n}\r\nif (memcmp(cp->uuid, bt_uuid_any, 16) == 0) {\r\nerr = hci_uuids_clear(hdev);\r\nif (enable_service_cache(hdev)) {\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_UUID,\r\n0, hdev->dev_class, 3);\r\ngoto unlock;\r\n}\r\ngoto update_class;\r\n}\r\nfound = 0;\r\nlist_for_each_entry_safe(match, tmp, &hdev->uuids, list) {\r\nif (memcmp(match->uuid, cp->uuid, 16) != 0)\r\ncontinue;\r\nlist_del(&match->list);\r\nkfree(match);\r\nfound++;\r\n}\r\nif (found == 0) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_REMOVE_UUID,\r\nMGMT_STATUS_INVALID_PARAMS);\r\ngoto unlock;\r\n}\r\nupdate_class:\r\nhci_req_init(&req, hdev);\r\nupdate_class(&req);\r\nupdate_eir(&req);\r\nerr = hci_req_run(&req, remove_uuid_complete);\r\nif (err < 0) {\r\nif (err != -ENODATA)\r\ngoto unlock;\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_UUID, 0,\r\nhdev->dev_class, 3);\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_REMOVE_UUID, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\nerr = 0;\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic void set_class_complete(struct hci_dev *hdev, u8 status)\r\n{\r\nBT_DBG("status 0x%02x", status);\r\nmgmt_class_complete(hdev, MGMT_OP_SET_DEV_CLASS, status);\r\n}\r\nstatic int set_dev_class(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_set_dev_class *cp = data;\r\nstruct pending_cmd *cmd;\r\nstruct hci_request req;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nif (!lmp_bredr_capable(hdev))\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_DEV_CLASS,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nhci_dev_lock(hdev);\r\nif (pending_eir_or_class(hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_SET_DEV_CLASS,\r\nMGMT_STATUS_BUSY);\r\ngoto unlock;\r\n}\r\nif ((cp->minor & 0x03) != 0 || (cp->major & 0xe0) != 0) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_SET_DEV_CLASS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\ngoto unlock;\r\n}\r\nhdev->major_class = cp->major;\r\nhdev->minor_class = cp->minor;\r\nif (!hdev_is_powered(hdev)) {\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_SET_DEV_CLASS, 0,\r\nhdev->dev_class, 3);\r\ngoto unlock;\r\n}\r\nhci_req_init(&req, hdev);\r\nif (test_and_clear_bit(HCI_SERVICE_CACHE, &hdev->dev_flags)) {\r\nhci_dev_unlock(hdev);\r\ncancel_delayed_work_sync(&hdev->service_cache);\r\nhci_dev_lock(hdev);\r\nupdate_eir(&req);\r\n}\r\nupdate_class(&req);\r\nerr = hci_req_run(&req, set_class_complete);\r\nif (err < 0) {\r\nif (err != -ENODATA)\r\ngoto unlock;\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_SET_DEV_CLASS, 0,\r\nhdev->dev_class, 3);\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_DEV_CLASS, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\nerr = 0;\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int load_link_keys(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_load_link_keys *cp = data;\r\nu16 key_count, expected_len;\r\nint i;\r\nkey_count = __le16_to_cpu(cp->key_count);\r\nexpected_len = sizeof(*cp) + key_count *\r\nsizeof(struct mgmt_link_key_info);\r\nif (expected_len != len) {\r\nBT_ERR("load_link_keys: expected %u bytes, got %u bytes",\r\nlen, expected_len);\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\n}\r\nif (cp->debug_keys != 0x00 && cp->debug_keys != 0x01)\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nBT_DBG("%s debug_keys %u key_count %u", hdev->name, cp->debug_keys,\r\nkey_count);\r\nfor (i = 0; i < key_count; i++) {\r\nstruct mgmt_link_key_info *key = &cp->keys[i];\r\nif (key->addr.type != BDADDR_BREDR)\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\n}\r\nhci_dev_lock(hdev);\r\nhci_link_keys_clear(hdev);\r\nif (cp->debug_keys)\r\nset_bit(HCI_DEBUG_KEYS, &hdev->dev_flags);\r\nelse\r\nclear_bit(HCI_DEBUG_KEYS, &hdev->dev_flags);\r\nfor (i = 0; i < key_count; i++) {\r\nstruct mgmt_link_key_info *key = &cp->keys[i];\r\nhci_add_link_key(hdev, NULL, 0, &key->addr.bdaddr, key->val,\r\nkey->type, key->pin_len);\r\n}\r\ncmd_complete(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS, 0, NULL, 0);\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int device_unpaired(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 addr_type, struct sock *skip_sk)\r\n{\r\nstruct mgmt_ev_device_unpaired ev;\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = addr_type;\r\nreturn mgmt_event(MGMT_EV_DEVICE_UNPAIRED, hdev, &ev, sizeof(ev),\r\nskip_sk);\r\n}\r\nstatic int unpair_device(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_unpair_device *cp = data;\r\nstruct mgmt_rp_unpair_device rp;\r\nstruct hci_cp_disconnect dc;\r\nstruct pending_cmd *cmd;\r\nstruct hci_conn *conn;\r\nint err;\r\nmemset(&rp, 0, sizeof(rp));\r\nbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\r\nrp.addr.type = cp->addr.type;\r\nif (!bdaddr_type_is_valid(cp->addr.type))\r\nreturn cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&rp, sizeof(rp));\r\nif (cp->disconnect != 0x00 && cp->disconnect != 0x01)\r\nreturn cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&rp, sizeof(rp));\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,\r\nMGMT_STATUS_NOT_POWERED, &rp, sizeof(rp));\r\ngoto unlock;\r\n}\r\nif (cp->addr.type == BDADDR_BREDR)\r\nerr = hci_remove_link_key(hdev, &cp->addr.bdaddr);\r\nelse\r\nerr = hci_remove_ltk(hdev, &cp->addr.bdaddr);\r\nif (err < 0) {\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,\r\nMGMT_STATUS_NOT_PAIRED, &rp, sizeof(rp));\r\ngoto unlock;\r\n}\r\nif (cp->disconnect) {\r\nif (cp->addr.type == BDADDR_BREDR)\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,\r\n&cp->addr.bdaddr);\r\nelse\r\nconn = hci_conn_hash_lookup_ba(hdev, LE_LINK,\r\n&cp->addr.bdaddr);\r\n} else {\r\nconn = NULL;\r\n}\r\nif (!conn) {\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE, 0,\r\n&rp, sizeof(rp));\r\ndevice_unpaired(hdev, &cp->addr.bdaddr, cp->addr.type, sk);\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_UNPAIR_DEVICE, hdev, cp,\r\nsizeof(*cp));\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\ndc.handle = cpu_to_le16(conn->handle);\r\ndc.reason = 0x13;\r\nerr = hci_send_cmd(hdev, HCI_OP_DISCONNECT, sizeof(dc), &dc);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int disconnect(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_disconnect *cp = data;\r\nstruct mgmt_rp_disconnect rp;\r\nstruct hci_cp_disconnect dc;\r\nstruct pending_cmd *cmd;\r\nstruct hci_conn *conn;\r\nint err;\r\nBT_DBG("");\r\nmemset(&rp, 0, sizeof(rp));\r\nbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\r\nrp.addr.type = cp->addr.type;\r\nif (!bdaddr_type_is_valid(cp->addr.type))\r\nreturn cmd_complete(sk, hdev->id, MGMT_OP_DISCONNECT,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&rp, sizeof(rp));\r\nhci_dev_lock(hdev);\r\nif (!test_bit(HCI_UP, &hdev->flags)) {\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_DISCONNECT,\r\nMGMT_STATUS_NOT_POWERED, &rp, sizeof(rp));\r\ngoto failed;\r\n}\r\nif (mgmt_pending_find(MGMT_OP_DISCONNECT, hdev)) {\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_DISCONNECT,\r\nMGMT_STATUS_BUSY, &rp, sizeof(rp));\r\ngoto failed;\r\n}\r\nif (cp->addr.type == BDADDR_BREDR)\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,\r\n&cp->addr.bdaddr);\r\nelse\r\nconn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->addr.bdaddr);\r\nif (!conn || conn->state == BT_OPEN || conn->state == BT_CLOSED) {\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_DISCONNECT,\r\nMGMT_STATUS_NOT_CONNECTED, &rp, sizeof(rp));\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_DISCONNECT, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\ndc.handle = cpu_to_le16(conn->handle);\r\ndc.reason = HCI_ERROR_REMOTE_USER_TERM;\r\nerr = hci_send_cmd(hdev, HCI_OP_DISCONNECT, sizeof(dc), &dc);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic u8 link_to_bdaddr(u8 link_type, u8 addr_type)\r\n{\r\nswitch (link_type) {\r\ncase LE_LINK:\r\nswitch (addr_type) {\r\ncase ADDR_LE_DEV_PUBLIC:\r\nreturn BDADDR_LE_PUBLIC;\r\ndefault:\r\nreturn BDADDR_LE_RANDOM;\r\n}\r\ndefault:\r\nreturn BDADDR_BREDR;\r\n}\r\n}\r\nstatic int get_connections(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 data_len)\r\n{\r\nstruct mgmt_rp_get_connections *rp;\r\nstruct hci_conn *c;\r\nsize_t rp_len;\r\nint err;\r\nu16 i;\r\nBT_DBG("");\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_GET_CONNECTIONS,\r\nMGMT_STATUS_NOT_POWERED);\r\ngoto unlock;\r\n}\r\ni = 0;\r\nlist_for_each_entry(c, &hdev->conn_hash.list, list) {\r\nif (test_bit(HCI_CONN_MGMT_CONNECTED, &c->flags))\r\ni++;\r\n}\r\nrp_len = sizeof(*rp) + (i * sizeof(struct mgmt_addr_info));\r\nrp = kmalloc(rp_len, GFP_KERNEL);\r\nif (!rp) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\ni = 0;\r\nlist_for_each_entry(c, &hdev->conn_hash.list, list) {\r\nif (!test_bit(HCI_CONN_MGMT_CONNECTED, &c->flags))\r\ncontinue;\r\nbacpy(&rp->addr[i].bdaddr, &c->dst);\r\nrp->addr[i].type = link_to_bdaddr(c->type, c->dst_type);\r\nif (c->type == SCO_LINK || c->type == ESCO_LINK)\r\ncontinue;\r\ni++;\r\n}\r\nrp->conn_count = cpu_to_le16(i);\r\nrp_len = sizeof(*rp) + (i * sizeof(struct mgmt_addr_info));\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_GET_CONNECTIONS, 0, rp,\r\nrp_len);\r\nkfree(rp);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int send_pin_code_neg_reply(struct sock *sk, struct hci_dev *hdev,\r\nstruct mgmt_cp_pin_code_neg_reply *cp)\r\n{\r\nstruct pending_cmd *cmd;\r\nint err;\r\ncmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_NEG_REPLY, hdev, cp,\r\nsizeof(*cp));\r\nif (!cmd)\r\nreturn -ENOMEM;\r\nerr = hci_send_cmd(hdev, HCI_OP_PIN_CODE_NEG_REPLY,\r\nsizeof(cp->addr.bdaddr), &cp->addr.bdaddr);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nreturn err;\r\n}\r\nstatic int pin_code_reply(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct hci_conn *conn;\r\nstruct mgmt_cp_pin_code_reply *cp = data;\r\nstruct hci_cp_pin_code_reply reply;\r\nstruct pending_cmd *cmd;\r\nint err;\r\nBT_DBG("");\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,\r\nMGMT_STATUS_NOT_POWERED);\r\ngoto failed;\r\n}\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->addr.bdaddr);\r\nif (!conn) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,\r\nMGMT_STATUS_NOT_CONNECTED);\r\ngoto failed;\r\n}\r\nif (conn->pending_sec_level == BT_SECURITY_HIGH && cp->pin_len != 16) {\r\nstruct mgmt_cp_pin_code_neg_reply ncp;\r\nmemcpy(&ncp.addr, &cp->addr, sizeof(ncp.addr));\r\nBT_ERR("PIN code is not 16 bytes long");\r\nerr = send_pin_code_neg_reply(sk, hdev, &ncp);\r\nif (err >= 0)\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,\r\nMGMT_STATUS_INVALID_PARAMS);\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_REPLY, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nbacpy(&reply.bdaddr, &cp->addr.bdaddr);\r\nreply.pin_len = cp->pin_len;\r\nmemcpy(reply.pin_code, cp->pin_code, sizeof(reply.pin_code));\r\nerr = hci_send_cmd(hdev, HCI_OP_PIN_CODE_REPLY, sizeof(reply), &reply);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int set_io_capability(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_set_io_capability *cp = data;\r\nBT_DBG("");\r\nhci_dev_lock(hdev);\r\nhdev->io_capability = cp->io_capability;\r\nBT_DBG("%s IO capability set to 0x%02x", hdev->name,\r\nhdev->io_capability);\r\nhci_dev_unlock(hdev);\r\nreturn cmd_complete(sk, hdev->id, MGMT_OP_SET_IO_CAPABILITY, 0, NULL,\r\n0);\r\n}\r\nstatic struct pending_cmd *find_pairing(struct hci_conn *conn)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct pending_cmd *cmd;\r\nlist_for_each_entry(cmd, &hdev->mgmt_pending, list) {\r\nif (cmd->opcode != MGMT_OP_PAIR_DEVICE)\r\ncontinue;\r\nif (cmd->user_data != conn)\r\ncontinue;\r\nreturn cmd;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void pairing_complete(struct pending_cmd *cmd, u8 status)\r\n{\r\nstruct mgmt_rp_pair_device rp;\r\nstruct hci_conn *conn = cmd->user_data;\r\nbacpy(&rp.addr.bdaddr, &conn->dst);\r\nrp.addr.type = link_to_bdaddr(conn->type, conn->dst_type);\r\ncmd_complete(cmd->sk, cmd->index, MGMT_OP_PAIR_DEVICE, status,\r\n&rp, sizeof(rp));\r\nconn->connect_cfm_cb = NULL;\r\nconn->security_cfm_cb = NULL;\r\nconn->disconn_cfm_cb = NULL;\r\nhci_conn_drop(conn);\r\nmgmt_pending_remove(cmd);\r\n}\r\nstatic void pairing_complete_cb(struct hci_conn *conn, u8 status)\r\n{\r\nstruct pending_cmd *cmd;\r\nBT_DBG("status %u", status);\r\ncmd = find_pairing(conn);\r\nif (!cmd)\r\nBT_DBG("Unable to find a pending command");\r\nelse\r\npairing_complete(cmd, mgmt_status(status));\r\n}\r\nstatic void le_connect_complete_cb(struct hci_conn *conn, u8 status)\r\n{\r\nstruct pending_cmd *cmd;\r\nBT_DBG("status %u", status);\r\nif (!status)\r\nreturn;\r\ncmd = find_pairing(conn);\r\nif (!cmd)\r\nBT_DBG("Unable to find a pending command");\r\nelse\r\npairing_complete(cmd, mgmt_status(status));\r\n}\r\nstatic int pair_device(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_pair_device *cp = data;\r\nstruct mgmt_rp_pair_device rp;\r\nstruct pending_cmd *cmd;\r\nu8 sec_level, auth_type;\r\nstruct hci_conn *conn;\r\nint err;\r\nBT_DBG("");\r\nmemset(&rp, 0, sizeof(rp));\r\nbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\r\nrp.addr.type = cp->addr.type;\r\nif (!bdaddr_type_is_valid(cp->addr.type))\r\nreturn cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&rp, sizeof(rp));\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\r\nMGMT_STATUS_NOT_POWERED, &rp, sizeof(rp));\r\ngoto unlock;\r\n}\r\nsec_level = BT_SECURITY_MEDIUM;\r\nif (cp->io_cap == 0x03)\r\nauth_type = HCI_AT_DEDICATED_BONDING;\r\nelse\r\nauth_type = HCI_AT_DEDICATED_BONDING_MITM;\r\nif (cp->addr.type == BDADDR_BREDR)\r\nconn = hci_connect(hdev, ACL_LINK, &cp->addr.bdaddr,\r\ncp->addr.type, sec_level, auth_type);\r\nelse\r\nconn = hci_connect(hdev, LE_LINK, &cp->addr.bdaddr,\r\ncp->addr.type, sec_level, auth_type);\r\nif (IS_ERR(conn)) {\r\nint status;\r\nif (PTR_ERR(conn) == -EBUSY)\r\nstatus = MGMT_STATUS_BUSY;\r\nelse\r\nstatus = MGMT_STATUS_CONNECT_FAILED;\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\r\nstatus, &rp,\r\nsizeof(rp));\r\ngoto unlock;\r\n}\r\nif (conn->connect_cfm_cb) {\r\nhci_conn_drop(conn);\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\r\nMGMT_STATUS_BUSY, &rp, sizeof(rp));\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_PAIR_DEVICE, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\nhci_conn_drop(conn);\r\ngoto unlock;\r\n}\r\nif (cp->addr.type == BDADDR_BREDR)\r\nconn->connect_cfm_cb = pairing_complete_cb;\r\nelse\r\nconn->connect_cfm_cb = le_connect_complete_cb;\r\nconn->security_cfm_cb = pairing_complete_cb;\r\nconn->disconn_cfm_cb = pairing_complete_cb;\r\nconn->io_capability = cp->io_cap;\r\ncmd->user_data = conn;\r\nif (conn->state == BT_CONNECTED &&\r\nhci_conn_security(conn, sec_level, auth_type))\r\npairing_complete(cmd, 0);\r\nerr = 0;\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int cancel_pair_device(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_addr_info *addr = data;\r\nstruct pending_cmd *cmd;\r\nstruct hci_conn *conn;\r\nint err;\r\nBT_DBG("");\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE,\r\nMGMT_STATUS_NOT_POWERED);\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_find(MGMT_OP_PAIR_DEVICE, hdev);\r\nif (!cmd) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS);\r\ngoto unlock;\r\n}\r\nconn = cmd->user_data;\r\nif (bacmp(&addr->bdaddr, &conn->dst) != 0) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS);\r\ngoto unlock;\r\n}\r\npairing_complete(cmd, MGMT_STATUS_CANCELLED);\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE, 0,\r\naddr, sizeof(*addr));\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int user_pairing_resp(struct sock *sk, struct hci_dev *hdev,\r\nstruct mgmt_addr_info *addr, u16 mgmt_op,\r\nu16 hci_op, __le32 passkey)\r\n{\r\nstruct pending_cmd *cmd;\r\nstruct hci_conn *conn;\r\nint err;\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = cmd_complete(sk, hdev->id, mgmt_op,\r\nMGMT_STATUS_NOT_POWERED, addr,\r\nsizeof(*addr));\r\ngoto done;\r\n}\r\nif (addr->type == BDADDR_BREDR)\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &addr->bdaddr);\r\nelse\r\nconn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &addr->bdaddr);\r\nif (!conn) {\r\nerr = cmd_complete(sk, hdev->id, mgmt_op,\r\nMGMT_STATUS_NOT_CONNECTED, addr,\r\nsizeof(*addr));\r\ngoto done;\r\n}\r\nif (addr->type == BDADDR_LE_PUBLIC || addr->type == BDADDR_LE_RANDOM) {\r\nerr = smp_user_confirm_reply(conn, mgmt_op, passkey);\r\nif (!err)\r\nerr = cmd_complete(sk, hdev->id, mgmt_op,\r\nMGMT_STATUS_SUCCESS, addr,\r\nsizeof(*addr));\r\nelse\r\nerr = cmd_complete(sk, hdev->id, mgmt_op,\r\nMGMT_STATUS_FAILED, addr,\r\nsizeof(*addr));\r\ngoto done;\r\n}\r\ncmd = mgmt_pending_add(sk, mgmt_op, hdev, addr, sizeof(*addr));\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto done;\r\n}\r\nif (hci_op == HCI_OP_USER_PASSKEY_REPLY) {\r\nstruct hci_cp_user_passkey_reply cp;\r\nbacpy(&cp.bdaddr, &addr->bdaddr);\r\ncp.passkey = passkey;\r\nerr = hci_send_cmd(hdev, hci_op, sizeof(cp), &cp);\r\n} else\r\nerr = hci_send_cmd(hdev, hci_op, sizeof(addr->bdaddr),\r\n&addr->bdaddr);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\ndone:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int pin_code_neg_reply(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_cp_pin_code_neg_reply *cp = data;\r\nBT_DBG("");\r\nreturn user_pairing_resp(sk, hdev, &cp->addr,\r\nMGMT_OP_PIN_CODE_NEG_REPLY,\r\nHCI_OP_PIN_CODE_NEG_REPLY, 0);\r\n}\r\nstatic int user_confirm_reply(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_user_confirm_reply *cp = data;\r\nBT_DBG("");\r\nif (len != sizeof(*cp))\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_USER_CONFIRM_REPLY,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nreturn user_pairing_resp(sk, hdev, &cp->addr,\r\nMGMT_OP_USER_CONFIRM_REPLY,\r\nHCI_OP_USER_CONFIRM_REPLY, 0);\r\n}\r\nstatic int user_confirm_neg_reply(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_cp_user_confirm_neg_reply *cp = data;\r\nBT_DBG("");\r\nreturn user_pairing_resp(sk, hdev, &cp->addr,\r\nMGMT_OP_USER_CONFIRM_NEG_REPLY,\r\nHCI_OP_USER_CONFIRM_NEG_REPLY, 0);\r\n}\r\nstatic int user_passkey_reply(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_user_passkey_reply *cp = data;\r\nBT_DBG("");\r\nreturn user_pairing_resp(sk, hdev, &cp->addr,\r\nMGMT_OP_USER_PASSKEY_REPLY,\r\nHCI_OP_USER_PASSKEY_REPLY, cp->passkey);\r\n}\r\nstatic int user_passkey_neg_reply(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_cp_user_passkey_neg_reply *cp = data;\r\nBT_DBG("");\r\nreturn user_pairing_resp(sk, hdev, &cp->addr,\r\nMGMT_OP_USER_PASSKEY_NEG_REPLY,\r\nHCI_OP_USER_PASSKEY_NEG_REPLY, 0);\r\n}\r\nstatic void update_name(struct hci_request *req)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nstruct hci_cp_write_local_name cp;\r\nmemcpy(cp.name, hdev->dev_name, sizeof(cp.name));\r\nhci_req_add(req, HCI_OP_WRITE_LOCAL_NAME, sizeof(cp), &cp);\r\n}\r\nstatic void set_name_complete(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct mgmt_cp_set_local_name *cp;\r\nstruct pending_cmd *cmd;\r\nBT_DBG("status 0x%02x", status);\r\nhci_dev_lock(hdev);\r\ncmd = mgmt_pending_find(MGMT_OP_SET_LOCAL_NAME, hdev);\r\nif (!cmd)\r\ngoto unlock;\r\ncp = cmd->param;\r\nif (status)\r\ncmd_status(cmd->sk, hdev->id, MGMT_OP_SET_LOCAL_NAME,\r\nmgmt_status(status));\r\nelse\r\ncmd_complete(cmd->sk, hdev->id, MGMT_OP_SET_LOCAL_NAME, 0,\r\ncp, sizeof(*cp));\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic int set_local_name(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_set_local_name *cp = data;\r\nstruct pending_cmd *cmd;\r\nstruct hci_request req;\r\nint err;\r\nBT_DBG("");\r\nhci_dev_lock(hdev);\r\nif (!memcmp(hdev->dev_name, cp->name, sizeof(hdev->dev_name)) &&\r\n!memcmp(hdev->short_name, cp->short_name,\r\nsizeof(hdev->short_name))) {\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_SET_LOCAL_NAME, 0,\r\ndata, len);\r\ngoto failed;\r\n}\r\nmemcpy(hdev->short_name, cp->short_name, sizeof(hdev->short_name));\r\nif (!hdev_is_powered(hdev)) {\r\nmemcpy(hdev->dev_name, cp->name, sizeof(hdev->dev_name));\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_SET_LOCAL_NAME, 0,\r\ndata, len);\r\nif (err < 0)\r\ngoto failed;\r\nerr = mgmt_event(MGMT_EV_LOCAL_NAME_CHANGED, hdev, data, len,\r\nsk);\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_LOCAL_NAME, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nmemcpy(hdev->dev_name, cp->name, sizeof(hdev->dev_name));\r\nhci_req_init(&req, hdev);\r\nif (lmp_bredr_capable(hdev)) {\r\nupdate_name(&req);\r\nupdate_eir(&req);\r\n}\r\nif (lmp_le_capable(hdev))\r\nhci_update_ad(&req);\r\nerr = hci_req_run(&req, set_name_complete);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int read_local_oob_data(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 data_len)\r\n{\r\nstruct pending_cmd *cmd;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,\r\nMGMT_STATUS_NOT_POWERED);\r\ngoto unlock;\r\n}\r\nif (!lmp_ssp_capable(hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\ngoto unlock;\r\n}\r\nif (mgmt_pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,\r\nMGMT_STATUS_BUSY);\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_READ_LOCAL_OOB_DATA, hdev, NULL, 0);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\nerr = hci_send_cmd(hdev, HCI_OP_READ_LOCAL_OOB_DATA, 0, NULL);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int add_remote_oob_data(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_cp_add_remote_oob_data *cp = data;\r\nu8 status;\r\nint err;\r\nBT_DBG("%s ", hdev->name);\r\nhci_dev_lock(hdev);\r\nerr = hci_add_remote_oob_data(hdev, &cp->addr.bdaddr, cp->hash,\r\ncp->randomizer);\r\nif (err < 0)\r\nstatus = MGMT_STATUS_FAILED;\r\nelse\r\nstatus = MGMT_STATUS_SUCCESS;\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_ADD_REMOTE_OOB_DATA, status,\r\n&cp->addr, sizeof(cp->addr));\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int remove_remote_oob_data(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_cp_remove_remote_oob_data *cp = data;\r\nu8 status;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nerr = hci_remove_remote_oob_data(hdev, &cp->addr.bdaddr);\r\nif (err < 0)\r\nstatus = MGMT_STATUS_INVALID_PARAMS;\r\nelse\r\nstatus = MGMT_STATUS_SUCCESS;\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_REMOTE_OOB_DATA,\r\nstatus, &cp->addr, sizeof(cp->addr));\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int mgmt_start_discovery_failed(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct pending_cmd *cmd;\r\nu8 type;\r\nint err;\r\nhci_discovery_set_state(hdev, DISCOVERY_STOPPED);\r\ncmd = mgmt_pending_find(MGMT_OP_START_DISCOVERY, hdev);\r\nif (!cmd)\r\nreturn -ENOENT;\r\ntype = hdev->discovery.type;\r\nerr = cmd_complete(cmd->sk, hdev->id, cmd->opcode, mgmt_status(status),\r\n&type, sizeof(type));\r\nmgmt_pending_remove(cmd);\r\nreturn err;\r\n}\r\nstatic void start_discovery_complete(struct hci_dev *hdev, u8 status)\r\n{\r\nBT_DBG("status %d", status);\r\nif (status) {\r\nhci_dev_lock(hdev);\r\nmgmt_start_discovery_failed(hdev, status);\r\nhci_dev_unlock(hdev);\r\nreturn;\r\n}\r\nhci_dev_lock(hdev);\r\nhci_discovery_set_state(hdev, DISCOVERY_FINDING);\r\nhci_dev_unlock(hdev);\r\nswitch (hdev->discovery.type) {\r\ncase DISCOV_TYPE_LE:\r\nqueue_delayed_work(hdev->workqueue, &hdev->le_scan_disable,\r\nDISCOV_LE_TIMEOUT);\r\nbreak;\r\ncase DISCOV_TYPE_INTERLEAVED:\r\nqueue_delayed_work(hdev->workqueue, &hdev->le_scan_disable,\r\nDISCOV_INTERLEAVED_TIMEOUT);\r\nbreak;\r\ncase DISCOV_TYPE_BREDR:\r\nbreak;\r\ndefault:\r\nBT_ERR("Invalid discovery type %d", hdev->discovery.type);\r\n}\r\n}\r\nstatic int start_discovery(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_cp_start_discovery *cp = data;\r\nstruct pending_cmd *cmd;\r\nstruct hci_cp_le_set_scan_param param_cp;\r\nstruct hci_cp_le_set_scan_enable enable_cp;\r\nstruct hci_cp_inquiry inq_cp;\r\nstruct hci_request req;\r\nu8 lap[3] = { 0x33, 0x8b, 0x9e };\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_START_DISCOVERY,\r\nMGMT_STATUS_NOT_POWERED);\r\ngoto failed;\r\n}\r\nif (test_bit(HCI_PERIODIC_INQ, &hdev->dev_flags)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_START_DISCOVERY,\r\nMGMT_STATUS_BUSY);\r\ngoto failed;\r\n}\r\nif (hdev->discovery.state != DISCOVERY_STOPPED) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_START_DISCOVERY,\r\nMGMT_STATUS_BUSY);\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_START_DISCOVERY, hdev, NULL, 0);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nhdev->discovery.type = cp->type;\r\nhci_req_init(&req, hdev);\r\nswitch (hdev->discovery.type) {\r\ncase DISCOV_TYPE_BREDR:\r\nif (!lmp_bredr_capable(hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_START_DISCOVERY,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nmgmt_pending_remove(cmd);\r\ngoto failed;\r\n}\r\nif (test_bit(HCI_INQUIRY, &hdev->flags)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_START_DISCOVERY,\r\nMGMT_STATUS_BUSY);\r\nmgmt_pending_remove(cmd);\r\ngoto failed;\r\n}\r\nhci_inquiry_cache_flush(hdev);\r\nmemset(&inq_cp, 0, sizeof(inq_cp));\r\nmemcpy(&inq_cp.lap, lap, sizeof(inq_cp.lap));\r\ninq_cp.length = DISCOV_BREDR_INQUIRY_LEN;\r\nhci_req_add(&req, HCI_OP_INQUIRY, sizeof(inq_cp), &inq_cp);\r\nbreak;\r\ncase DISCOV_TYPE_LE:\r\ncase DISCOV_TYPE_INTERLEAVED:\r\nif (!test_bit(HCI_LE_ENABLED, &hdev->dev_flags)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_START_DISCOVERY,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nmgmt_pending_remove(cmd);\r\ngoto failed;\r\n}\r\nif (hdev->discovery.type == DISCOV_TYPE_INTERLEAVED &&\r\n!lmp_bredr_capable(hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_START_DISCOVERY,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nmgmt_pending_remove(cmd);\r\ngoto failed;\r\n}\r\nif (test_bit(HCI_LE_PERIPHERAL, &hdev->dev_flags)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_START_DISCOVERY,\r\nMGMT_STATUS_REJECTED);\r\nmgmt_pending_remove(cmd);\r\ngoto failed;\r\n}\r\nif (test_bit(HCI_LE_SCAN, &hdev->dev_flags)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_START_DISCOVERY,\r\nMGMT_STATUS_BUSY);\r\nmgmt_pending_remove(cmd);\r\ngoto failed;\r\n}\r\nmemset(&param_cp, 0, sizeof(param_cp));\r\nparam_cp.type = LE_SCAN_ACTIVE;\r\nparam_cp.interval = cpu_to_le16(DISCOV_LE_SCAN_INT);\r\nparam_cp.window = cpu_to_le16(DISCOV_LE_SCAN_WIN);\r\nhci_req_add(&req, HCI_OP_LE_SET_SCAN_PARAM, sizeof(param_cp),\r\n&param_cp);\r\nmemset(&enable_cp, 0, sizeof(enable_cp));\r\nenable_cp.enable = LE_SCAN_ENABLE;\r\nenable_cp.filter_dup = LE_SCAN_FILTER_DUP_ENABLE;\r\nhci_req_add(&req, HCI_OP_LE_SET_SCAN_ENABLE, sizeof(enable_cp),\r\n&enable_cp);\r\nbreak;\r\ndefault:\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_START_DISCOVERY,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nmgmt_pending_remove(cmd);\r\ngoto failed;\r\n}\r\nerr = hci_req_run(&req, start_discovery_complete);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nelse\r\nhci_discovery_set_state(hdev, DISCOVERY_STARTING);\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int mgmt_stop_discovery_failed(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct pending_cmd *cmd;\r\nint err;\r\ncmd = mgmt_pending_find(MGMT_OP_STOP_DISCOVERY, hdev);\r\nif (!cmd)\r\nreturn -ENOENT;\r\nerr = cmd_complete(cmd->sk, hdev->id, cmd->opcode, mgmt_status(status),\r\n&hdev->discovery.type, sizeof(hdev->discovery.type));\r\nmgmt_pending_remove(cmd);\r\nreturn err;\r\n}\r\nstatic void stop_discovery_complete(struct hci_dev *hdev, u8 status)\r\n{\r\nBT_DBG("status %d", status);\r\nhci_dev_lock(hdev);\r\nif (status) {\r\nmgmt_stop_discovery_failed(hdev, status);\r\ngoto unlock;\r\n}\r\nhci_discovery_set_state(hdev, DISCOVERY_STOPPED);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic int stop_discovery(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_stop_discovery *mgmt_cp = data;\r\nstruct pending_cmd *cmd;\r\nstruct hci_cp_remote_name_req_cancel cp;\r\nstruct inquiry_entry *e;\r\nstruct hci_request req;\r\nstruct hci_cp_le_set_scan_enable enable_cp;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nif (!hci_discovery_active(hdev)) {\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_STOP_DISCOVERY,\r\nMGMT_STATUS_REJECTED, &mgmt_cp->type,\r\nsizeof(mgmt_cp->type));\r\ngoto unlock;\r\n}\r\nif (hdev->discovery.type != mgmt_cp->type) {\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_STOP_DISCOVERY,\r\nMGMT_STATUS_INVALID_PARAMS, &mgmt_cp->type,\r\nsizeof(mgmt_cp->type));\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_STOP_DISCOVERY, hdev, NULL, 0);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\nhci_req_init(&req, hdev);\r\nswitch (hdev->discovery.state) {\r\ncase DISCOVERY_FINDING:\r\nif (test_bit(HCI_INQUIRY, &hdev->flags)) {\r\nhci_req_add(&req, HCI_OP_INQUIRY_CANCEL, 0, NULL);\r\n} else {\r\ncancel_delayed_work(&hdev->le_scan_disable);\r\nmemset(&enable_cp, 0, sizeof(enable_cp));\r\nenable_cp.enable = LE_SCAN_DISABLE;\r\nhci_req_add(&req, HCI_OP_LE_SET_SCAN_ENABLE,\r\nsizeof(enable_cp), &enable_cp);\r\n}\r\nbreak;\r\ncase DISCOVERY_RESOLVING:\r\ne = hci_inquiry_cache_lookup_resolve(hdev, BDADDR_ANY,\r\nNAME_PENDING);\r\nif (!e) {\r\nmgmt_pending_remove(cmd);\r\nerr = cmd_complete(sk, hdev->id,\r\nMGMT_OP_STOP_DISCOVERY, 0,\r\n&mgmt_cp->type,\r\nsizeof(mgmt_cp->type));\r\nhci_discovery_set_state(hdev, DISCOVERY_STOPPED);\r\ngoto unlock;\r\n}\r\nbacpy(&cp.bdaddr, &e->data.bdaddr);\r\nhci_req_add(&req, HCI_OP_REMOTE_NAME_REQ_CANCEL, sizeof(cp),\r\n&cp);\r\nbreak;\r\ndefault:\r\nBT_DBG("unknown discovery state %u", hdev->discovery.state);\r\nmgmt_pending_remove(cmd);\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_STOP_DISCOVERY,\r\nMGMT_STATUS_FAILED, &mgmt_cp->type,\r\nsizeof(mgmt_cp->type));\r\ngoto unlock;\r\n}\r\nerr = hci_req_run(&req, stop_discovery_complete);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nelse\r\nhci_discovery_set_state(hdev, DISCOVERY_STOPPING);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int confirm_name(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_confirm_name *cp = data;\r\nstruct inquiry_entry *e;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nif (!hci_discovery_active(hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_CONFIRM_NAME,\r\nMGMT_STATUS_FAILED);\r\ngoto failed;\r\n}\r\ne = hci_inquiry_cache_lookup_unknown(hdev, &cp->addr.bdaddr);\r\nif (!e) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_CONFIRM_NAME,\r\nMGMT_STATUS_INVALID_PARAMS);\r\ngoto failed;\r\n}\r\nif (cp->name_known) {\r\ne->name_state = NAME_KNOWN;\r\nlist_del(&e->list);\r\n} else {\r\ne->name_state = NAME_NEEDED;\r\nhci_inquiry_cache_update_resolve(hdev, e);\r\n}\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_CONFIRM_NAME, 0, &cp->addr,\r\nsizeof(cp->addr));\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int block_device(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_block_device *cp = data;\r\nu8 status;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nif (!bdaddr_type_is_valid(cp->addr.type))\r\nreturn cmd_complete(sk, hdev->id, MGMT_OP_BLOCK_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&cp->addr, sizeof(cp->addr));\r\nhci_dev_lock(hdev);\r\nerr = hci_blacklist_add(hdev, &cp->addr.bdaddr, cp->addr.type);\r\nif (err < 0)\r\nstatus = MGMT_STATUS_FAILED;\r\nelse\r\nstatus = MGMT_STATUS_SUCCESS;\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_BLOCK_DEVICE, status,\r\n&cp->addr, sizeof(cp->addr));\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int unblock_device(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_unblock_device *cp = data;\r\nu8 status;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nif (!bdaddr_type_is_valid(cp->addr.type))\r\nreturn cmd_complete(sk, hdev->id, MGMT_OP_UNBLOCK_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&cp->addr, sizeof(cp->addr));\r\nhci_dev_lock(hdev);\r\nerr = hci_blacklist_del(hdev, &cp->addr.bdaddr, cp->addr.type);\r\nif (err < 0)\r\nstatus = MGMT_STATUS_INVALID_PARAMS;\r\nelse\r\nstatus = MGMT_STATUS_SUCCESS;\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_UNBLOCK_DEVICE, status,\r\n&cp->addr, sizeof(cp->addr));\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int set_device_id(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_set_device_id *cp = data;\r\nstruct hci_request req;\r\nint err;\r\n__u16 source;\r\nBT_DBG("%s", hdev->name);\r\nsource = __le16_to_cpu(cp->source);\r\nif (source > 0x0002)\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_DEVICE_ID,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nhdev->devid_source = source;\r\nhdev->devid_vendor = __le16_to_cpu(cp->vendor);\r\nhdev->devid_product = __le16_to_cpu(cp->product);\r\nhdev->devid_version = __le16_to_cpu(cp->version);\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_SET_DEVICE_ID, 0, NULL, 0);\r\nhci_req_init(&req, hdev);\r\nupdate_eir(&req);\r\nhci_req_run(&req, NULL);\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic void fast_connectable_complete(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct pending_cmd *cmd;\r\nBT_DBG("status 0x%02x", status);\r\nhci_dev_lock(hdev);\r\ncmd = mgmt_pending_find(MGMT_OP_SET_FAST_CONNECTABLE, hdev);\r\nif (!cmd)\r\ngoto unlock;\r\nif (status) {\r\ncmd_status(cmd->sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,\r\nmgmt_status(status));\r\n} else {\r\nstruct mgmt_mode *cp = cmd->param;\r\nif (cp->val)\r\nset_bit(HCI_FAST_CONNECTABLE, &hdev->dev_flags);\r\nelse\r\nclear_bit(HCI_FAST_CONNECTABLE, &hdev->dev_flags);\r\nsend_settings_rsp(cmd->sk, MGMT_OP_SET_FAST_CONNECTABLE, hdev);\r\nnew_settings(hdev, cmd->sk);\r\n}\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic int set_fast_connectable(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nstruct pending_cmd *cmd;\r\nstruct hci_request req;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nif (!lmp_bredr_capable(hdev) || hdev->hci_ver < BLUETOOTH_VER_1_2)\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nif (cp->val != 0x00 && cp->val != 0x01)\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nif (!hdev_is_powered(hdev))\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,\r\nMGMT_STATUS_NOT_POWERED);\r\nif (!test_bit(HCI_CONNECTABLE, &hdev->dev_flags))\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,\r\nMGMT_STATUS_REJECTED);\r\nhci_dev_lock(hdev);\r\nif (mgmt_pending_find(MGMT_OP_SET_FAST_CONNECTABLE, hdev)) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,\r\nMGMT_STATUS_BUSY);\r\ngoto unlock;\r\n}\r\nif (!!cp->val == test_bit(HCI_FAST_CONNECTABLE, &hdev->dev_flags)) {\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_FAST_CONNECTABLE,\r\nhdev);\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_FAST_CONNECTABLE, hdev,\r\ndata, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\nhci_req_init(&req, hdev);\r\nwrite_fast_connectable(&req, cp->val);\r\nerr = hci_req_run(&req, fast_connectable_complete);\r\nif (err < 0) {\r\nerr = cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,\r\nMGMT_STATUS_FAILED);\r\nmgmt_pending_remove(cmd);\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic bool ltk_is_valid(struct mgmt_ltk_info *key)\r\n{\r\nif (key->authenticated != 0x00 && key->authenticated != 0x01)\r\nreturn false;\r\nif (key->master != 0x00 && key->master != 0x01)\r\nreturn false;\r\nif (!bdaddr_type_is_le(key->addr.type))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int load_long_term_keys(struct sock *sk, struct hci_dev *hdev,\r\nvoid *cp_data, u16 len)\r\n{\r\nstruct mgmt_cp_load_long_term_keys *cp = cp_data;\r\nu16 key_count, expected_len;\r\nint i, err;\r\nkey_count = __le16_to_cpu(cp->key_count);\r\nexpected_len = sizeof(*cp) + key_count *\r\nsizeof(struct mgmt_ltk_info);\r\nif (expected_len != len) {\r\nBT_ERR("load_keys: expected %u bytes, got %u bytes",\r\nlen, expected_len);\r\nreturn cmd_status(sk, hdev->id, MGMT_OP_LOAD_LONG_TERM_KEYS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\n}\r\nBT_DBG("%s key_count %u", hdev->name, key_count);\r\nfor (i = 0; i < key_count; i++) {\r\nstruct mgmt_ltk_info *key = &cp->keys[i];\r\nif (!ltk_is_valid(key))\r\nreturn cmd_status(sk, hdev->id,\r\nMGMT_OP_LOAD_LONG_TERM_KEYS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\n}\r\nhci_dev_lock(hdev);\r\nhci_smp_ltks_clear(hdev);\r\nfor (i = 0; i < key_count; i++) {\r\nstruct mgmt_ltk_info *key = &cp->keys[i];\r\nu8 type;\r\nif (key->master)\r\ntype = HCI_SMP_LTK;\r\nelse\r\ntype = HCI_SMP_LTK_SLAVE;\r\nhci_add_ltk(hdev, &key->addr.bdaddr,\r\nbdaddr_to_le(key->addr.type),\r\ntype, 0, key->authenticated, key->val,\r\nkey->enc_size, key->ediv, key->rand);\r\n}\r\nerr = cmd_complete(sk, hdev->id, MGMT_OP_LOAD_LONG_TERM_KEYS, 0,\r\nNULL, 0);\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nint mgmt_control(struct sock *sk, struct msghdr *msg, size_t msglen)\r\n{\r\nvoid *buf;\r\nu8 *cp;\r\nstruct mgmt_hdr *hdr;\r\nu16 opcode, index, len;\r\nstruct hci_dev *hdev = NULL;\r\nconst struct mgmt_handler *handler;\r\nint err;\r\nBT_DBG("got %zu bytes", msglen);\r\nif (msglen < sizeof(*hdr))\r\nreturn -EINVAL;\r\nbuf = kmalloc(msglen, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (memcpy_fromiovec(buf, msg->msg_iov, msglen)) {\r\nerr = -EFAULT;\r\ngoto done;\r\n}\r\nhdr = buf;\r\nopcode = __le16_to_cpu(hdr->opcode);\r\nindex = __le16_to_cpu(hdr->index);\r\nlen = __le16_to_cpu(hdr->len);\r\nif (len != msglen - sizeof(*hdr)) {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nif (index != MGMT_INDEX_NONE) {\r\nhdev = hci_dev_get(index);\r\nif (!hdev) {\r\nerr = cmd_status(sk, index, opcode,\r\nMGMT_STATUS_INVALID_INDEX);\r\ngoto done;\r\n}\r\n}\r\nif (opcode >= ARRAY_SIZE(mgmt_handlers) ||\r\nmgmt_handlers[opcode].func == NULL) {\r\nBT_DBG("Unknown op %u", opcode);\r\nerr = cmd_status(sk, index, opcode,\r\nMGMT_STATUS_UNKNOWN_COMMAND);\r\ngoto done;\r\n}\r\nif ((hdev && opcode < MGMT_OP_READ_INFO) ||\r\n(!hdev && opcode >= MGMT_OP_READ_INFO)) {\r\nerr = cmd_status(sk, index, opcode,\r\nMGMT_STATUS_INVALID_INDEX);\r\ngoto done;\r\n}\r\nhandler = &mgmt_handlers[opcode];\r\nif ((handler->var_len && len < handler->data_len) ||\r\n(!handler->var_len && len != handler->data_len)) {\r\nerr = cmd_status(sk, index, opcode,\r\nMGMT_STATUS_INVALID_PARAMS);\r\ngoto done;\r\n}\r\nif (hdev)\r\nmgmt_init_hdev(sk, hdev);\r\ncp = buf + sizeof(*hdr);\r\nerr = handler->func(sk, hdev, cp, len);\r\nif (err < 0)\r\ngoto done;\r\nerr = msglen;\r\ndone:\r\nif (hdev)\r\nhci_dev_put(hdev);\r\nkfree(buf);\r\nreturn err;\r\n}\r\nstatic void cmd_status_rsp(struct pending_cmd *cmd, void *data)\r\n{\r\nu8 *status = data;\r\ncmd_status(cmd->sk, cmd->index, cmd->opcode, *status);\r\nmgmt_pending_remove(cmd);\r\n}\r\nint mgmt_index_added(struct hci_dev *hdev)\r\n{\r\nif (!mgmt_valid_hdev(hdev))\r\nreturn -ENOTSUPP;\r\nreturn mgmt_event(MGMT_EV_INDEX_ADDED, hdev, NULL, 0, NULL);\r\n}\r\nint mgmt_index_removed(struct hci_dev *hdev)\r\n{\r\nu8 status = MGMT_STATUS_INVALID_INDEX;\r\nif (!mgmt_valid_hdev(hdev))\r\nreturn -ENOTSUPP;\r\nmgmt_pending_foreach(0, hdev, cmd_status_rsp, &status);\r\nreturn mgmt_event(MGMT_EV_INDEX_REMOVED, hdev, NULL, 0, NULL);\r\n}\r\nstatic void settings_rsp(struct pending_cmd *cmd, void *data)\r\n{\r\nstruct cmd_lookup *match = data;\r\nsend_settings_rsp(cmd->sk, cmd->opcode, match->hdev);\r\nlist_del(&cmd->list);\r\nif (match->sk == NULL) {\r\nmatch->sk = cmd->sk;\r\nsock_hold(match->sk);\r\n}\r\nmgmt_pending_free(cmd);\r\n}\r\nstatic void set_bredr_scan(struct hci_request *req)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nu8 scan = 0;\r\nwrite_fast_connectable(req, false);\r\nif (test_bit(HCI_CONNECTABLE, &hdev->dev_flags))\r\nscan |= SCAN_PAGE;\r\nif (test_bit(HCI_DISCOVERABLE, &hdev->dev_flags))\r\nscan |= SCAN_INQUIRY;\r\nif (scan)\r\nhci_req_add(req, HCI_OP_WRITE_SCAN_ENABLE, 1, &scan);\r\n}\r\nstatic void powered_complete(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct cmd_lookup match = { NULL, hdev };\r\nBT_DBG("status 0x%02x", status);\r\nhci_dev_lock(hdev);\r\nmgmt_pending_foreach(MGMT_OP_SET_POWERED, hdev, settings_rsp, &match);\r\nnew_settings(hdev, match.sk);\r\nhci_dev_unlock(hdev);\r\nif (match.sk)\r\nsock_put(match.sk);\r\n}\r\nstatic int powered_update_hci(struct hci_dev *hdev)\r\n{\r\nstruct hci_request req;\r\nu8 link_sec;\r\nhci_req_init(&req, hdev);\r\nif (test_bit(HCI_SSP_ENABLED, &hdev->dev_flags) &&\r\n!lmp_host_ssp_capable(hdev)) {\r\nu8 ssp = 1;\r\nhci_req_add(&req, HCI_OP_WRITE_SSP_MODE, 1, &ssp);\r\n}\r\nif (test_bit(HCI_LE_ENABLED, &hdev->dev_flags) &&\r\nlmp_bredr_capable(hdev)) {\r\nstruct hci_cp_write_le_host_supported cp;\r\ncp.le = 1;\r\ncp.simul = lmp_le_br_capable(hdev);\r\nif (cp.le != lmp_host_le_capable(hdev) ||\r\ncp.simul != lmp_host_le_br_capable(hdev))\r\nhci_req_add(&req, HCI_OP_WRITE_LE_HOST_SUPPORTED,\r\nsizeof(cp), &cp);\r\n}\r\nlink_sec = test_bit(HCI_LINK_SECURITY, &hdev->dev_flags);\r\nif (link_sec != test_bit(HCI_AUTH, &hdev->flags))\r\nhci_req_add(&req, HCI_OP_WRITE_AUTH_ENABLE,\r\nsizeof(link_sec), &link_sec);\r\nif (lmp_bredr_capable(hdev)) {\r\nset_bredr_scan(&req);\r\nupdate_class(&req);\r\nupdate_name(&req);\r\nupdate_eir(&req);\r\n}\r\nreturn hci_req_run(&req, powered_complete);\r\n}\r\nint mgmt_powered(struct hci_dev *hdev, u8 powered)\r\n{\r\nstruct cmd_lookup match = { NULL, hdev };\r\nu8 status_not_powered = MGMT_STATUS_NOT_POWERED;\r\nu8 zero_cod[] = { 0, 0, 0 };\r\nint err;\r\nif (!test_bit(HCI_MGMT, &hdev->dev_flags))\r\nreturn 0;\r\nif (powered) {\r\nif (powered_update_hci(hdev) == 0)\r\nreturn 0;\r\nmgmt_pending_foreach(MGMT_OP_SET_POWERED, hdev, settings_rsp,\r\n&match);\r\ngoto new_settings;\r\n}\r\nmgmt_pending_foreach(MGMT_OP_SET_POWERED, hdev, settings_rsp, &match);\r\nmgmt_pending_foreach(0, hdev, cmd_status_rsp, &status_not_powered);\r\nif (memcmp(hdev->dev_class, zero_cod, sizeof(zero_cod)) != 0)\r\nmgmt_event(MGMT_EV_CLASS_OF_DEV_CHANGED, hdev,\r\nzero_cod, sizeof(zero_cod), NULL);\r\nnew_settings:\r\nerr = new_settings(hdev, match.sk);\r\nif (match.sk)\r\nsock_put(match.sk);\r\nreturn err;\r\n}\r\nint mgmt_set_powered_failed(struct hci_dev *hdev, int err)\r\n{\r\nstruct pending_cmd *cmd;\r\nu8 status;\r\ncmd = mgmt_pending_find(MGMT_OP_SET_POWERED, hdev);\r\nif (!cmd)\r\nreturn -ENOENT;\r\nif (err == -ERFKILL)\r\nstatus = MGMT_STATUS_RFKILLED;\r\nelse\r\nstatus = MGMT_STATUS_FAILED;\r\nerr = cmd_status(cmd->sk, hdev->id, MGMT_OP_SET_POWERED, status);\r\nmgmt_pending_remove(cmd);\r\nreturn err;\r\n}\r\nint mgmt_discoverable(struct hci_dev *hdev, u8 discoverable)\r\n{\r\nstruct cmd_lookup match = { NULL, hdev };\r\nbool changed = false;\r\nint err = 0;\r\nif (discoverable) {\r\nif (!test_and_set_bit(HCI_DISCOVERABLE, &hdev->dev_flags))\r\nchanged = true;\r\n} else {\r\nif (test_and_clear_bit(HCI_DISCOVERABLE, &hdev->dev_flags))\r\nchanged = true;\r\n}\r\nmgmt_pending_foreach(MGMT_OP_SET_DISCOVERABLE, hdev, settings_rsp,\r\n&match);\r\nif (changed)\r\nerr = new_settings(hdev, match.sk);\r\nif (match.sk)\r\nsock_put(match.sk);\r\nreturn err;\r\n}\r\nint mgmt_connectable(struct hci_dev *hdev, u8 connectable)\r\n{\r\nstruct pending_cmd *cmd;\r\nbool changed = false;\r\nint err = 0;\r\nif (connectable) {\r\nif (!test_and_set_bit(HCI_CONNECTABLE, &hdev->dev_flags))\r\nchanged = true;\r\n} else {\r\nif (test_and_clear_bit(HCI_CONNECTABLE, &hdev->dev_flags))\r\nchanged = true;\r\n}\r\ncmd = mgmt_pending_find(MGMT_OP_SET_CONNECTABLE, hdev);\r\nif (changed)\r\nerr = new_settings(hdev, cmd ? cmd->sk : NULL);\r\nreturn err;\r\n}\r\nint mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status)\r\n{\r\nu8 mgmt_err = mgmt_status(status);\r\nif (scan & SCAN_PAGE)\r\nmgmt_pending_foreach(MGMT_OP_SET_CONNECTABLE, hdev,\r\ncmd_status_rsp, &mgmt_err);\r\nif (scan & SCAN_INQUIRY)\r\nmgmt_pending_foreach(MGMT_OP_SET_DISCOVERABLE, hdev,\r\ncmd_status_rsp, &mgmt_err);\r\nreturn 0;\r\n}\r\nint mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,\r\nbool persistent)\r\n{\r\nstruct mgmt_ev_new_link_key ev;\r\nmemset(&ev, 0, sizeof(ev));\r\nev.store_hint = persistent;\r\nbacpy(&ev.key.addr.bdaddr, &key->bdaddr);\r\nev.key.addr.type = BDADDR_BREDR;\r\nev.key.type = key->type;\r\nmemcpy(ev.key.val, key->val, HCI_LINK_KEY_SIZE);\r\nev.key.pin_len = key->pin_len;\r\nreturn mgmt_event(MGMT_EV_NEW_LINK_KEY, hdev, &ev, sizeof(ev), NULL);\r\n}\r\nint mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, u8 persistent)\r\n{\r\nstruct mgmt_ev_new_long_term_key ev;\r\nmemset(&ev, 0, sizeof(ev));\r\nev.store_hint = persistent;\r\nbacpy(&ev.key.addr.bdaddr, &key->bdaddr);\r\nev.key.addr.type = link_to_bdaddr(LE_LINK, key->bdaddr_type);\r\nev.key.authenticated = key->authenticated;\r\nev.key.enc_size = key->enc_size;\r\nev.key.ediv = key->ediv;\r\nif (key->type == HCI_SMP_LTK)\r\nev.key.master = 1;\r\nmemcpy(ev.key.rand, key->rand, sizeof(key->rand));\r\nmemcpy(ev.key.val, key->val, sizeof(key->val));\r\nreturn mgmt_event(MGMT_EV_NEW_LONG_TERM_KEY, hdev, &ev, sizeof(ev),\r\nNULL);\r\n}\r\nint mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,\r\nu8 addr_type, u32 flags, u8 *name, u8 name_len,\r\nu8 *dev_class)\r\n{\r\nchar buf[512];\r\nstruct mgmt_ev_device_connected *ev = (void *) buf;\r\nu16 eir_len = 0;\r\nbacpy(&ev->addr.bdaddr, bdaddr);\r\nev->addr.type = link_to_bdaddr(link_type, addr_type);\r\nev->flags = __cpu_to_le32(flags);\r\nif (name_len > 0)\r\neir_len = eir_append_data(ev->eir, 0, EIR_NAME_COMPLETE,\r\nname, name_len);\r\nif (dev_class && memcmp(dev_class, "\0\0\0", 3) != 0)\r\neir_len = eir_append_data(ev->eir, eir_len,\r\nEIR_CLASS_OF_DEV, dev_class, 3);\r\nev->eir_len = cpu_to_le16(eir_len);\r\nreturn mgmt_event(MGMT_EV_DEVICE_CONNECTED, hdev, buf,\r\nsizeof(*ev) + eir_len, NULL);\r\n}\r\nstatic void disconnect_rsp(struct pending_cmd *cmd, void *data)\r\n{\r\nstruct mgmt_cp_disconnect *cp = cmd->param;\r\nstruct sock **sk = data;\r\nstruct mgmt_rp_disconnect rp;\r\nbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\r\nrp.addr.type = cp->addr.type;\r\ncmd_complete(cmd->sk, cmd->index, MGMT_OP_DISCONNECT, 0, &rp,\r\nsizeof(rp));\r\n*sk = cmd->sk;\r\nsock_hold(*sk);\r\nmgmt_pending_remove(cmd);\r\n}\r\nstatic void unpair_device_rsp(struct pending_cmd *cmd, void *data)\r\n{\r\nstruct hci_dev *hdev = data;\r\nstruct mgmt_cp_unpair_device *cp = cmd->param;\r\nstruct mgmt_rp_unpair_device rp;\r\nmemset(&rp, 0, sizeof(rp));\r\nbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\r\nrp.addr.type = cp->addr.type;\r\ndevice_unpaired(hdev, &cp->addr.bdaddr, cp->addr.type, cmd->sk);\r\ncmd_complete(cmd->sk, cmd->index, cmd->opcode, 0, &rp, sizeof(rp));\r\nmgmt_pending_remove(cmd);\r\n}\r\nint mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type, u8 reason)\r\n{\r\nstruct mgmt_ev_device_disconnected ev;\r\nstruct sock *sk = NULL;\r\nint err;\r\nmgmt_pending_foreach(MGMT_OP_DISCONNECT, hdev, disconnect_rsp, &sk);\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = link_to_bdaddr(link_type, addr_type);\r\nev.reason = reason;\r\nerr = mgmt_event(MGMT_EV_DEVICE_DISCONNECTED, hdev, &ev, sizeof(ev),\r\nsk);\r\nif (sk)\r\nsock_put(sk);\r\nmgmt_pending_foreach(MGMT_OP_UNPAIR_DEVICE, hdev, unpair_device_rsp,\r\nhdev);\r\nreturn err;\r\n}\r\nint mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type, u8 status)\r\n{\r\nstruct mgmt_rp_disconnect rp;\r\nstruct pending_cmd *cmd;\r\nint err;\r\nmgmt_pending_foreach(MGMT_OP_UNPAIR_DEVICE, hdev, unpair_device_rsp,\r\nhdev);\r\ncmd = mgmt_pending_find(MGMT_OP_DISCONNECT, hdev);\r\nif (!cmd)\r\nreturn -ENOENT;\r\nbacpy(&rp.addr.bdaddr, bdaddr);\r\nrp.addr.type = link_to_bdaddr(link_type, addr_type);\r\nerr = cmd_complete(cmd->sk, cmd->index, MGMT_OP_DISCONNECT,\r\nmgmt_status(status), &rp, sizeof(rp));\r\nmgmt_pending_remove(cmd);\r\nreturn err;\r\n}\r\nint mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,\r\nu8 addr_type, u8 status)\r\n{\r\nstruct mgmt_ev_connect_failed ev;\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = link_to_bdaddr(link_type, addr_type);\r\nev.status = mgmt_status(status);\r\nreturn mgmt_event(MGMT_EV_CONNECT_FAILED, hdev, &ev, sizeof(ev), NULL);\r\n}\r\nint mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure)\r\n{\r\nstruct mgmt_ev_pin_code_request ev;\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = BDADDR_BREDR;\r\nev.secure = secure;\r\nreturn mgmt_event(MGMT_EV_PIN_CODE_REQUEST, hdev, &ev, sizeof(ev),\r\nNULL);\r\n}\r\nint mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 status)\r\n{\r\nstruct pending_cmd *cmd;\r\nstruct mgmt_rp_pin_code_reply rp;\r\nint err;\r\ncmd = mgmt_pending_find(MGMT_OP_PIN_CODE_REPLY, hdev);\r\nif (!cmd)\r\nreturn -ENOENT;\r\nbacpy(&rp.addr.bdaddr, bdaddr);\r\nrp.addr.type = BDADDR_BREDR;\r\nerr = cmd_complete(cmd->sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,\r\nmgmt_status(status), &rp, sizeof(rp));\r\nmgmt_pending_remove(cmd);\r\nreturn err;\r\n}\r\nint mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 status)\r\n{\r\nstruct pending_cmd *cmd;\r\nstruct mgmt_rp_pin_code_reply rp;\r\nint err;\r\ncmd = mgmt_pending_find(MGMT_OP_PIN_CODE_NEG_REPLY, hdev);\r\nif (!cmd)\r\nreturn -ENOENT;\r\nbacpy(&rp.addr.bdaddr, bdaddr);\r\nrp.addr.type = BDADDR_BREDR;\r\nerr = cmd_complete(cmd->sk, hdev->id, MGMT_OP_PIN_CODE_NEG_REPLY,\r\nmgmt_status(status), &rp, sizeof(rp));\r\nmgmt_pending_remove(cmd);\r\nreturn err;\r\n}\r\nint mgmt_user_confirm_request(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type, __le32 value,\r\nu8 confirm_hint)\r\n{\r\nstruct mgmt_ev_user_confirm_request ev;\r\nBT_DBG("%s", hdev->name);\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = link_to_bdaddr(link_type, addr_type);\r\nev.confirm_hint = confirm_hint;\r\nev.value = value;\r\nreturn mgmt_event(MGMT_EV_USER_CONFIRM_REQUEST, hdev, &ev, sizeof(ev),\r\nNULL);\r\n}\r\nint mgmt_user_passkey_request(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type)\r\n{\r\nstruct mgmt_ev_user_passkey_request ev;\r\nBT_DBG("%s", hdev->name);\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = link_to_bdaddr(link_type, addr_type);\r\nreturn mgmt_event(MGMT_EV_USER_PASSKEY_REQUEST, hdev, &ev, sizeof(ev),\r\nNULL);\r\n}\r\nstatic int user_pairing_resp_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type, u8 status,\r\nu8 opcode)\r\n{\r\nstruct pending_cmd *cmd;\r\nstruct mgmt_rp_user_confirm_reply rp;\r\nint err;\r\ncmd = mgmt_pending_find(opcode, hdev);\r\nif (!cmd)\r\nreturn -ENOENT;\r\nbacpy(&rp.addr.bdaddr, bdaddr);\r\nrp.addr.type = link_to_bdaddr(link_type, addr_type);\r\nerr = cmd_complete(cmd->sk, hdev->id, opcode, mgmt_status(status),\r\n&rp, sizeof(rp));\r\nmgmt_pending_remove(cmd);\r\nreturn err;\r\n}\r\nint mgmt_user_confirm_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type, u8 status)\r\n{\r\nreturn user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,\r\nstatus, MGMT_OP_USER_CONFIRM_REPLY);\r\n}\r\nint mgmt_user_confirm_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type, u8 status)\r\n{\r\nreturn user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,\r\nstatus,\r\nMGMT_OP_USER_CONFIRM_NEG_REPLY);\r\n}\r\nint mgmt_user_passkey_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type, u8 status)\r\n{\r\nreturn user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,\r\nstatus, MGMT_OP_USER_PASSKEY_REPLY);\r\n}\r\nint mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type, u8 status)\r\n{\r\nreturn user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,\r\nstatus,\r\nMGMT_OP_USER_PASSKEY_NEG_REPLY);\r\n}\r\nint mgmt_user_passkey_notify(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type, u32 passkey,\r\nu8 entered)\r\n{\r\nstruct mgmt_ev_passkey_notify ev;\r\nBT_DBG("%s", hdev->name);\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = link_to_bdaddr(link_type, addr_type);\r\nev.passkey = __cpu_to_le32(passkey);\r\nev.entered = entered;\r\nreturn mgmt_event(MGMT_EV_PASSKEY_NOTIFY, hdev, &ev, sizeof(ev), NULL);\r\n}\r\nint mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,\r\nu8 addr_type, u8 status)\r\n{\r\nstruct mgmt_ev_auth_failed ev;\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = link_to_bdaddr(link_type, addr_type);\r\nev.status = mgmt_status(status);\r\nreturn mgmt_event(MGMT_EV_AUTH_FAILED, hdev, &ev, sizeof(ev), NULL);\r\n}\r\nint mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct cmd_lookup match = { NULL, hdev };\r\nbool changed = false;\r\nint err = 0;\r\nif (status) {\r\nu8 mgmt_err = mgmt_status(status);\r\nmgmt_pending_foreach(MGMT_OP_SET_LINK_SECURITY, hdev,\r\ncmd_status_rsp, &mgmt_err);\r\nreturn 0;\r\n}\r\nif (test_bit(HCI_AUTH, &hdev->flags)) {\r\nif (!test_and_set_bit(HCI_LINK_SECURITY, &hdev->dev_flags))\r\nchanged = true;\r\n} else {\r\nif (test_and_clear_bit(HCI_LINK_SECURITY, &hdev->dev_flags))\r\nchanged = true;\r\n}\r\nmgmt_pending_foreach(MGMT_OP_SET_LINK_SECURITY, hdev, settings_rsp,\r\n&match);\r\nif (changed)\r\nerr = new_settings(hdev, match.sk);\r\nif (match.sk)\r\nsock_put(match.sk);\r\nreturn err;\r\n}\r\nstatic void clear_eir(struct hci_request *req)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nstruct hci_cp_write_eir cp;\r\nif (!lmp_ext_inq_capable(hdev))\r\nreturn;\r\nmemset(hdev->eir, 0, sizeof(hdev->eir));\r\nmemset(&cp, 0, sizeof(cp));\r\nhci_req_add(req, HCI_OP_WRITE_EIR, sizeof(cp), &cp);\r\n}\r\nint mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status)\r\n{\r\nstruct cmd_lookup match = { NULL, hdev };\r\nstruct hci_request req;\r\nbool changed = false;\r\nint err = 0;\r\nif (status) {\r\nu8 mgmt_err = mgmt_status(status);\r\nif (enable && test_and_clear_bit(HCI_SSP_ENABLED,\r\n&hdev->dev_flags))\r\nerr = new_settings(hdev, NULL);\r\nmgmt_pending_foreach(MGMT_OP_SET_SSP, hdev, cmd_status_rsp,\r\n&mgmt_err);\r\nreturn err;\r\n}\r\nif (enable) {\r\nif (!test_and_set_bit(HCI_SSP_ENABLED, &hdev->dev_flags))\r\nchanged = true;\r\n} else {\r\nif (test_and_clear_bit(HCI_SSP_ENABLED, &hdev->dev_flags))\r\nchanged = true;\r\n}\r\nmgmt_pending_foreach(MGMT_OP_SET_SSP, hdev, settings_rsp, &match);\r\nif (changed)\r\nerr = new_settings(hdev, match.sk);\r\nif (match.sk)\r\nsock_put(match.sk);\r\nhci_req_init(&req, hdev);\r\nif (test_bit(HCI_SSP_ENABLED, &hdev->dev_flags))\r\nupdate_eir(&req);\r\nelse\r\nclear_eir(&req);\r\nhci_req_run(&req, NULL);\r\nreturn err;\r\n}\r\nstatic void sk_lookup(struct pending_cmd *cmd, void *data)\r\n{\r\nstruct cmd_lookup *match = data;\r\nif (match->sk == NULL) {\r\nmatch->sk = cmd->sk;\r\nsock_hold(match->sk);\r\n}\r\n}\r\nint mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,\r\nu8 status)\r\n{\r\nstruct cmd_lookup match = { NULL, hdev, mgmt_status(status) };\r\nint err = 0;\r\nmgmt_pending_foreach(MGMT_OP_SET_DEV_CLASS, hdev, sk_lookup, &match);\r\nmgmt_pending_foreach(MGMT_OP_ADD_UUID, hdev, sk_lookup, &match);\r\nmgmt_pending_foreach(MGMT_OP_REMOVE_UUID, hdev, sk_lookup, &match);\r\nif (!status)\r\nerr = mgmt_event(MGMT_EV_CLASS_OF_DEV_CHANGED, hdev, dev_class,\r\n3, NULL);\r\nif (match.sk)\r\nsock_put(match.sk);\r\nreturn err;\r\n}\r\nint mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status)\r\n{\r\nstruct mgmt_cp_set_local_name ev;\r\nstruct pending_cmd *cmd;\r\nif (status)\r\nreturn 0;\r\nmemset(&ev, 0, sizeof(ev));\r\nmemcpy(ev.name, name, HCI_MAX_NAME_LENGTH);\r\nmemcpy(ev.short_name, hdev->short_name, HCI_MAX_SHORT_NAME_LENGTH);\r\ncmd = mgmt_pending_find(MGMT_OP_SET_LOCAL_NAME, hdev);\r\nif (!cmd) {\r\nmemcpy(hdev->dev_name, name, sizeof(hdev->dev_name));\r\nif (mgmt_pending_find(MGMT_OP_SET_POWERED, hdev))\r\nreturn 0;\r\n}\r\nreturn mgmt_event(MGMT_EV_LOCAL_NAME_CHANGED, hdev, &ev, sizeof(ev),\r\ncmd ? cmd->sk : NULL);\r\n}\r\nint mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,\r\nu8 *randomizer, u8 status)\r\n{\r\nstruct pending_cmd *cmd;\r\nint err;\r\nBT_DBG("%s status %u", hdev->name, status);\r\ncmd = mgmt_pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, hdev);\r\nif (!cmd)\r\nreturn -ENOENT;\r\nif (status) {\r\nerr = cmd_status(cmd->sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,\r\nmgmt_status(status));\r\n} else {\r\nstruct mgmt_rp_read_local_oob_data rp;\r\nmemcpy(rp.hash, hash, sizeof(rp.hash));\r\nmemcpy(rp.randomizer, randomizer, sizeof(rp.randomizer));\r\nerr = cmd_complete(cmd->sk, hdev->id,\r\nMGMT_OP_READ_LOCAL_OOB_DATA, 0, &rp,\r\nsizeof(rp));\r\n}\r\nmgmt_pending_remove(cmd);\r\nreturn err;\r\n}\r\nint mgmt_le_enable_complete(struct hci_dev *hdev, u8 enable, u8 status)\r\n{\r\nstruct cmd_lookup match = { NULL, hdev };\r\nbool changed = false;\r\nint err = 0;\r\nif (status) {\r\nu8 mgmt_err = mgmt_status(status);\r\nif (enable && test_and_clear_bit(HCI_LE_ENABLED,\r\n&hdev->dev_flags))\r\nerr = new_settings(hdev, NULL);\r\nmgmt_pending_foreach(MGMT_OP_SET_LE, hdev, cmd_status_rsp,\r\n&mgmt_err);\r\nreturn err;\r\n}\r\nif (enable) {\r\nif (!test_and_set_bit(HCI_LE_ENABLED, &hdev->dev_flags))\r\nchanged = true;\r\n} else {\r\nif (test_and_clear_bit(HCI_LE_ENABLED, &hdev->dev_flags))\r\nchanged = true;\r\n}\r\nmgmt_pending_foreach(MGMT_OP_SET_LE, hdev, settings_rsp, &match);\r\nif (changed)\r\nerr = new_settings(hdev, match.sk);\r\nif (match.sk)\r\nsock_put(match.sk);\r\nreturn err;\r\n}\r\nint mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,\r\nu8 addr_type, u8 *dev_class, s8 rssi, u8 cfm_name, u8\r\nssp, u8 *eir, u16 eir_len)\r\n{\r\nchar buf[512];\r\nstruct mgmt_ev_device_found *ev = (void *) buf;\r\nsize_t ev_size;\r\nif (!hci_discovery_active(hdev))\r\nreturn -EPERM;\r\nif (sizeof(*ev) + eir_len + 5 > sizeof(buf))\r\nreturn -EINVAL;\r\nmemset(buf, 0, sizeof(buf));\r\nbacpy(&ev->addr.bdaddr, bdaddr);\r\nev->addr.type = link_to_bdaddr(link_type, addr_type);\r\nev->rssi = rssi;\r\nif (cfm_name)\r\nev->flags |= __constant_cpu_to_le32(MGMT_DEV_FOUND_CONFIRM_NAME);\r\nif (!ssp)\r\nev->flags |= __constant_cpu_to_le32(MGMT_DEV_FOUND_LEGACY_PAIRING);\r\nif (eir_len > 0)\r\nmemcpy(ev->eir, eir, eir_len);\r\nif (dev_class && !eir_has_data_type(ev->eir, eir_len, EIR_CLASS_OF_DEV))\r\neir_len = eir_append_data(ev->eir, eir_len, EIR_CLASS_OF_DEV,\r\ndev_class, 3);\r\nev->eir_len = cpu_to_le16(eir_len);\r\nev_size = sizeof(*ev) + eir_len;\r\nreturn mgmt_event(MGMT_EV_DEVICE_FOUND, hdev, ev, ev_size, NULL);\r\n}\r\nint mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,\r\nu8 addr_type, s8 rssi, u8 *name, u8 name_len)\r\n{\r\nstruct mgmt_ev_device_found *ev;\r\nchar buf[sizeof(*ev) + HCI_MAX_NAME_LENGTH + 2];\r\nu16 eir_len;\r\nev = (struct mgmt_ev_device_found *) buf;\r\nmemset(buf, 0, sizeof(buf));\r\nbacpy(&ev->addr.bdaddr, bdaddr);\r\nev->addr.type = link_to_bdaddr(link_type, addr_type);\r\nev->rssi = rssi;\r\neir_len = eir_append_data(ev->eir, 0, EIR_NAME_COMPLETE, name,\r\nname_len);\r\nev->eir_len = cpu_to_le16(eir_len);\r\nreturn mgmt_event(MGMT_EV_DEVICE_FOUND, hdev, ev,\r\nsizeof(*ev) + eir_len, NULL);\r\n}\r\nint mgmt_discovering(struct hci_dev *hdev, u8 discovering)\r\n{\r\nstruct mgmt_ev_discovering ev;\r\nstruct pending_cmd *cmd;\r\nBT_DBG("%s discovering %u", hdev->name, discovering);\r\nif (discovering)\r\ncmd = mgmt_pending_find(MGMT_OP_START_DISCOVERY, hdev);\r\nelse\r\ncmd = mgmt_pending_find(MGMT_OP_STOP_DISCOVERY, hdev);\r\nif (cmd != NULL) {\r\nu8 type = hdev->discovery.type;\r\ncmd_complete(cmd->sk, hdev->id, cmd->opcode, 0, &type,\r\nsizeof(type));\r\nmgmt_pending_remove(cmd);\r\n}\r\nmemset(&ev, 0, sizeof(ev));\r\nev.type = hdev->discovery.type;\r\nev.discovering = discovering;\r\nreturn mgmt_event(MGMT_EV_DISCOVERING, hdev, &ev, sizeof(ev), NULL);\r\n}\r\nint mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type)\r\n{\r\nstruct pending_cmd *cmd;\r\nstruct mgmt_ev_device_blocked ev;\r\ncmd = mgmt_pending_find(MGMT_OP_BLOCK_DEVICE, hdev);\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = type;\r\nreturn mgmt_event(MGMT_EV_DEVICE_BLOCKED, hdev, &ev, sizeof(ev),\r\ncmd ? cmd->sk : NULL);\r\n}\r\nint mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type)\r\n{\r\nstruct pending_cmd *cmd;\r\nstruct mgmt_ev_device_unblocked ev;\r\ncmd = mgmt_pending_find(MGMT_OP_UNBLOCK_DEVICE, hdev);\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = type;\r\nreturn mgmt_event(MGMT_EV_DEVICE_UNBLOCKED, hdev, &ev, sizeof(ev),\r\ncmd ? cmd->sk : NULL);\r\n}
