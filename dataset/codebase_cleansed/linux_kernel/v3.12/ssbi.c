static inline u32 ssbi_readl(struct ssbi *ssbi, u32 reg)\r\n{\r\nreturn readl(ssbi->base + reg);\r\n}\r\nstatic inline void ssbi_writel(struct ssbi *ssbi, u32 val, u32 reg)\r\n{\r\nwritel(val, ssbi->base + reg);\r\n}\r\nstatic int ssbi_wait_mask(struct ssbi *ssbi, u32 set_mask, u32 clr_mask)\r\n{\r\nu32 timeout = SSBI_TIMEOUT_US;\r\nu32 val;\r\nwhile (timeout--) {\r\nval = ssbi_readl(ssbi, SSBI2_STATUS);\r\nif (((val & set_mask) == set_mask) && ((val & clr_mask) == 0))\r\nreturn 0;\r\nudelay(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int\r\nssbi_read_bytes(struct ssbi *ssbi, u16 addr, u8 *buf, int len)\r\n{\r\nu32 cmd = SSBI_CMD_RDWRN | ((addr & 0xff) << 16);\r\nint ret = 0;\r\nif (ssbi->controller_type == MSM_SBI_CTRL_SSBI2) {\r\nu32 mode2 = ssbi_readl(ssbi, SSBI2_MODE2);\r\nmode2 = SET_SSBI_MODE2_REG_ADDR_15_8(mode2, addr);\r\nssbi_writel(ssbi, mode2, SSBI2_MODE2);\r\n}\r\nwhile (len) {\r\nret = ssbi_wait_mask(ssbi, SSBI_STATUS_READY, 0);\r\nif (ret)\r\ngoto err;\r\nssbi_writel(ssbi, cmd, SSBI2_CMD);\r\nret = ssbi_wait_mask(ssbi, SSBI_STATUS_RD_READY, 0);\r\nif (ret)\r\ngoto err;\r\n*buf++ = ssbi_readl(ssbi, SSBI2_RD) & 0xff;\r\nlen--;\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int\r\nssbi_write_bytes(struct ssbi *ssbi, u16 addr, u8 *buf, int len)\r\n{\r\nint ret = 0;\r\nif (ssbi->controller_type == MSM_SBI_CTRL_SSBI2) {\r\nu32 mode2 = ssbi_readl(ssbi, SSBI2_MODE2);\r\nmode2 = SET_SSBI_MODE2_REG_ADDR_15_8(mode2, addr);\r\nssbi_writel(ssbi, mode2, SSBI2_MODE2);\r\n}\r\nwhile (len) {\r\nret = ssbi_wait_mask(ssbi, SSBI_STATUS_READY, 0);\r\nif (ret)\r\ngoto err;\r\nssbi_writel(ssbi, ((addr & 0xff) << 16) | *buf, SSBI2_CMD);\r\nret = ssbi_wait_mask(ssbi, 0, SSBI_STATUS_MCHN_BUSY);\r\nif (ret)\r\ngoto err;\r\nbuf++;\r\nlen--;\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic inline int\r\nssbi_pa_transfer(struct ssbi *ssbi, u32 cmd, u8 *data)\r\n{\r\nu32 timeout = SSBI_TIMEOUT_US;\r\nu32 rd_status = 0;\r\nssbi_writel(ssbi, cmd, SSBI_PA_CMD);\r\nwhile (timeout--) {\r\nrd_status = ssbi_readl(ssbi, SSBI_PA_RD_STATUS);\r\nif (rd_status & SSBI_PA_RD_STATUS_TRANS_DENIED)\r\nreturn -EPERM;\r\nif (rd_status & SSBI_PA_RD_STATUS_TRANS_DONE) {\r\nif (data)\r\n*data = rd_status & 0xff;\r\nreturn 0;\r\n}\r\nudelay(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int\r\nssbi_pa_read_bytes(struct ssbi *ssbi, u16 addr, u8 *buf, int len)\r\n{\r\nu32 cmd;\r\nint ret = 0;\r\ncmd = SSBI_PA_CMD_RDWRN | (addr & SSBI_PA_CMD_ADDR_MASK) << 8;\r\nwhile (len) {\r\nret = ssbi_pa_transfer(ssbi, cmd, buf);\r\nif (ret)\r\ngoto err;\r\nbuf++;\r\nlen--;\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int\r\nssbi_pa_write_bytes(struct ssbi *ssbi, u16 addr, u8 *buf, int len)\r\n{\r\nu32 cmd;\r\nint ret = 0;\r\nwhile (len) {\r\ncmd = (addr & SSBI_PA_CMD_ADDR_MASK) << 8 | *buf;\r\nret = ssbi_pa_transfer(ssbi, cmd, NULL);\r\nif (ret)\r\ngoto err;\r\nbuf++;\r\nlen--;\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nint ssbi_read(struct device *dev, u16 addr, u8 *buf, int len)\r\n{\r\nstruct ssbi *ssbi = to_ssbi(dev);\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&ssbi->lock, flags);\r\nret = ssbi->read(ssbi, addr, buf, len);\r\nspin_unlock_irqrestore(&ssbi->lock, flags);\r\nreturn ret;\r\n}\r\nint ssbi_write(struct device *dev, u16 addr, u8 *buf, int len)\r\n{\r\nstruct ssbi *ssbi = to_ssbi(dev);\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&ssbi->lock, flags);\r\nret = ssbi->write(ssbi, addr, buf, len);\r\nspin_unlock_irqrestore(&ssbi->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int ssbi_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct resource *mem_res;\r\nstruct ssbi *ssbi;\r\nconst char *type;\r\nssbi = devm_kzalloc(&pdev->dev, sizeof(*ssbi), GFP_KERNEL);\r\nif (!ssbi)\r\nreturn -ENOMEM;\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nssbi->base = devm_ioremap_resource(&pdev->dev, mem_res);\r\nif (IS_ERR(ssbi->base))\r\nreturn PTR_ERR(ssbi->base);\r\nplatform_set_drvdata(pdev, ssbi);\r\ntype = of_get_property(np, "qcom,controller-type", NULL);\r\nif (type == NULL) {\r\ndev_err(&pdev->dev, "Missing qcom,controller-type property\n");\r\nreturn -EINVAL;\r\n}\r\ndev_info(&pdev->dev, "SSBI controller type: '%s'\n", type);\r\nif (strcmp(type, "ssbi") == 0)\r\nssbi->controller_type = MSM_SBI_CTRL_SSBI;\r\nelse if (strcmp(type, "ssbi2") == 0)\r\nssbi->controller_type = MSM_SBI_CTRL_SSBI2;\r\nelse if (strcmp(type, "pmic-arbiter") == 0)\r\nssbi->controller_type = MSM_SBI_CTRL_PMIC_ARBITER;\r\nelse {\r\ndev_err(&pdev->dev, "Unknown qcom,controller-type\n");\r\nreturn -EINVAL;\r\n}\r\nif (ssbi->controller_type == MSM_SBI_CTRL_PMIC_ARBITER) {\r\nssbi->read = ssbi_pa_read_bytes;\r\nssbi->write = ssbi_pa_write_bytes;\r\n} else {\r\nssbi->read = ssbi_read_bytes;\r\nssbi->write = ssbi_write_bytes;\r\n}\r\nspin_lock_init(&ssbi->lock);\r\nreturn of_platform_populate(np, NULL, NULL, &pdev->dev);\r\n}
