void usbhs_pkt_init(struct usbhs_pkt *pkt)\r\n{\r\nINIT_LIST_HEAD(&pkt->node);\r\n}\r\nstatic int usbhsf_null_handle(struct usbhs_pkt *pkt, int *is_done)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pkt->pipe);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\ndev_err(dev, "null handler\n");\r\nreturn -EINVAL;\r\n}\r\nvoid usbhs_pkt_push(struct usbhs_pipe *pipe, struct usbhs_pkt *pkt,\r\nvoid (*done)(struct usbhs_priv *priv,\r\nstruct usbhs_pkt *pkt),\r\nvoid *buf, int len, int zero, int sequence)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nunsigned long flags;\r\nif (!done) {\r\ndev_err(dev, "no done function\n");\r\nreturn;\r\n}\r\nusbhs_lock(priv, flags);\r\nif (!pipe->handler) {\r\ndev_err(dev, "no handler function\n");\r\npipe->handler = &usbhsf_null_handler;\r\n}\r\nlist_move_tail(&pkt->node, &pipe->list);\r\npkt->pipe = pipe;\r\npkt->buf = buf;\r\npkt->handler = pipe->handler;\r\npkt->length = len;\r\npkt->zero = zero;\r\npkt->actual = 0;\r\npkt->done = done;\r\npkt->sequence = sequence;\r\nusbhs_unlock(priv, flags);\r\n}\r\nstatic void __usbhsf_pkt_del(struct usbhs_pkt *pkt)\r\n{\r\nlist_del_init(&pkt->node);\r\n}\r\nstatic struct usbhs_pkt *__usbhsf_pkt_get(struct usbhs_pipe *pipe)\r\n{\r\nif (list_empty(&pipe->list))\r\nreturn NULL;\r\nreturn list_first_entry(&pipe->list, struct usbhs_pkt, node);\r\n}\r\nstruct usbhs_pkt *usbhs_pkt_pop(struct usbhs_pipe *pipe, struct usbhs_pkt *pkt)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nunsigned long flags;\r\nusbhs_lock(priv, flags);\r\nif (!pkt)\r\npkt = __usbhsf_pkt_get(pipe);\r\nif (pkt)\r\n__usbhsf_pkt_del(pkt);\r\nusbhs_unlock(priv, flags);\r\nreturn pkt;\r\n}\r\nstatic int usbhsf_pkt_handler(struct usbhs_pipe *pipe, int type)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nstruct usbhs_pkt *pkt;\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nint (*func)(struct usbhs_pkt *pkt, int *is_done);\r\nunsigned long flags;\r\nint ret = 0;\r\nint is_done = 0;\r\nusbhs_lock(priv, flags);\r\npkt = __usbhsf_pkt_get(pipe);\r\nif (!pkt)\r\ngoto __usbhs_pkt_handler_end;\r\nswitch (type) {\r\ncase USBHSF_PKT_PREPARE:\r\nfunc = pkt->handler->prepare;\r\nbreak;\r\ncase USBHSF_PKT_TRY_RUN:\r\nfunc = pkt->handler->try_run;\r\nbreak;\r\ncase USBHSF_PKT_DMA_DONE:\r\nfunc = pkt->handler->dma_done;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "unknown pkt handler\n");\r\ngoto __usbhs_pkt_handler_end;\r\n}\r\nret = func(pkt, &is_done);\r\nif (is_done)\r\n__usbhsf_pkt_del(pkt);\r\n__usbhs_pkt_handler_end:\r\nusbhs_unlock(priv, flags);\r\nif (is_done) {\r\npkt->done(priv, pkt);\r\nusbhs_pkt_start(pipe);\r\n}\r\nreturn ret;\r\n}\r\nvoid usbhs_pkt_start(struct usbhs_pipe *pipe)\r\n{\r\nusbhsf_pkt_handler(pipe, USBHSF_PKT_PREPARE);\r\n}\r\nstatic void usbhsf_tx_irq_ctrl(struct usbhs_pipe *pipe, int enable)\r\n{\r\nif (usbhs_pipe_is_dcp(pipe))\r\nusbhsf_irq_empty_ctrl(pipe, enable);\r\nelse\r\nusbhsf_irq_ready_ctrl(pipe, enable);\r\n}\r\nstatic void usbhsf_rx_irq_ctrl(struct usbhs_pipe *pipe, int enable)\r\n{\r\nusbhsf_irq_ready_ctrl(pipe, enable);\r\n}\r\nstatic void usbhsf_send_terminator(struct usbhs_pipe *pipe,\r\nstruct usbhs_fifo *fifo)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nusbhs_bset(priv, fifo->ctr, BVAL, BVAL);\r\n}\r\nstatic int usbhsf_fifo_barrier(struct usbhs_priv *priv,\r\nstruct usbhs_fifo *fifo)\r\n{\r\nint timeout = 1024;\r\ndo {\r\nif (usbhs_read(priv, fifo->ctr) & FRDY)\r\nreturn 0;\r\nudelay(10);\r\n} while (timeout--);\r\nreturn -EBUSY;\r\n}\r\nstatic void usbhsf_fifo_clear(struct usbhs_pipe *pipe,\r\nstruct usbhs_fifo *fifo)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nif (!usbhs_pipe_is_dcp(pipe))\r\nusbhsf_fifo_barrier(priv, fifo);\r\nusbhs_write(priv, fifo->ctr, BCLR);\r\n}\r\nstatic int usbhsf_fifo_rcv_len(struct usbhs_priv *priv,\r\nstruct usbhs_fifo *fifo)\r\n{\r\nreturn usbhs_read(priv, fifo->ctr) & DTLN_MASK;\r\n}\r\nstatic void usbhsf_fifo_unselect(struct usbhs_pipe *pipe,\r\nstruct usbhs_fifo *fifo)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nusbhs_pipe_select_fifo(pipe, NULL);\r\nusbhs_write(priv, fifo->sel, 0);\r\n}\r\nstatic int usbhsf_fifo_select(struct usbhs_pipe *pipe,\r\nstruct usbhs_fifo *fifo,\r\nint write)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nint timeout = 1024;\r\nu16 mask = ((1 << 5) | 0xF);\r\nu16 base = usbhs_pipe_number(pipe);\r\nif (usbhs_pipe_is_busy(pipe) ||\r\nusbhsf_fifo_is_busy(fifo))\r\nreturn -EBUSY;\r\nif (usbhs_pipe_is_dcp(pipe)) {\r\nbase |= (1 == write) << 5;\r\nif (usbhs_mod_is_host(priv))\r\nusbhs_dcp_dir_for_host(pipe, write);\r\n}\r\nif (usbhs_get_dparam(priv, has_sudmac) && !usbhsf_is_cfifo(priv, fifo))\r\nusbhs_write(priv, fifo->sel, base);\r\nelse\r\nusbhs_write(priv, fifo->sel, base | MBW_32);\r\nwhile (timeout--) {\r\nif (base == (mask & usbhs_read(priv, fifo->sel))) {\r\nusbhs_pipe_select_fifo(pipe, fifo);\r\nreturn 0;\r\n}\r\nudelay(10);\r\n}\r\ndev_err(dev, "fifo select error\n");\r\nreturn -EIO;\r\n}\r\nstatic int usbhs_dcp_dir_switch_to_write(struct usbhs_pkt *pkt, int *is_done)\r\n{\r\nstruct usbhs_pipe *pipe = pkt->pipe;\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nstruct usbhs_fifo *fifo = usbhsf_get_cfifo(priv);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nint ret;\r\nusbhs_pipe_disable(pipe);\r\nret = usbhsf_fifo_select(pipe, fifo, 1);\r\nif (ret < 0) {\r\ndev_err(dev, "%s() faile\n", __func__);\r\nreturn ret;\r\n}\r\nusbhs_pipe_sequence_data1(pipe);\r\nusbhsf_fifo_clear(pipe, fifo);\r\nusbhsf_send_terminator(pipe, fifo);\r\nusbhsf_fifo_unselect(pipe, fifo);\r\nusbhsf_tx_irq_ctrl(pipe, 1);\r\nusbhs_pipe_enable(pipe);\r\nreturn ret;\r\n}\r\nstatic int usbhs_dcp_dir_switch_to_read(struct usbhs_pkt *pkt, int *is_done)\r\n{\r\nstruct usbhs_pipe *pipe = pkt->pipe;\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nstruct usbhs_fifo *fifo = usbhsf_get_cfifo(priv);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nint ret;\r\nusbhs_pipe_disable(pipe);\r\nret = usbhsf_fifo_select(pipe, fifo, 0);\r\nif (ret < 0) {\r\ndev_err(dev, "%s() fail\n", __func__);\r\nreturn ret;\r\n}\r\nusbhs_pipe_sequence_data1(pipe);\r\nusbhsf_fifo_clear(pipe, fifo);\r\nusbhsf_fifo_unselect(pipe, fifo);\r\nusbhsf_rx_irq_ctrl(pipe, 1);\r\nusbhs_pipe_enable(pipe);\r\nreturn ret;\r\n}\r\nstatic int usbhs_dcp_dir_switch_done(struct usbhs_pkt *pkt, int *is_done)\r\n{\r\nstruct usbhs_pipe *pipe = pkt->pipe;\r\nif (pkt->handler == &usbhs_dcp_status_stage_in_handler)\r\nusbhsf_tx_irq_ctrl(pipe, 0);\r\nelse\r\nusbhsf_rx_irq_ctrl(pipe, 0);\r\npkt->actual = pkt->length;\r\n*is_done = 1;\r\nreturn 0;\r\n}\r\nstatic int usbhsf_dcp_data_stage_try_push(struct usbhs_pkt *pkt, int *is_done)\r\n{\r\nstruct usbhs_pipe *pipe = pkt->pipe;\r\nusbhs_pipe_sequence_data1(pipe);\r\npkt->handler = &usbhs_fifo_pio_push_handler;\r\nreturn pkt->handler->prepare(pkt, is_done);\r\n}\r\nstatic int usbhsf_dcp_data_stage_prepare_pop(struct usbhs_pkt *pkt,\r\nint *is_done)\r\n{\r\nstruct usbhs_pipe *pipe = pkt->pipe;\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nstruct usbhs_fifo *fifo = usbhsf_get_cfifo(priv);\r\nif (usbhs_pipe_is_busy(pipe))\r\nreturn 0;\r\nusbhs_pipe_disable(pipe);\r\nusbhs_pipe_sequence_data1(pipe);\r\nusbhsf_fifo_select(pipe, fifo, 0);\r\nusbhsf_fifo_clear(pipe, fifo);\r\nusbhsf_fifo_unselect(pipe, fifo);\r\npkt->handler = &usbhs_fifo_pio_pop_handler;\r\nreturn pkt->handler->prepare(pkt, is_done);\r\n}\r\nstatic int usbhsf_pio_try_push(struct usbhs_pkt *pkt, int *is_done)\r\n{\r\nstruct usbhs_pipe *pipe = pkt->pipe;\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nstruct usbhs_fifo *fifo = usbhsf_get_cfifo(priv);\r\nvoid __iomem *addr = priv->base + fifo->port;\r\nu8 *buf;\r\nint maxp = usbhs_pipe_get_maxpacket(pipe);\r\nint total_len;\r\nint i, ret, len;\r\nint is_short;\r\nusbhs_pipe_data_sequence(pipe, pkt->sequence);\r\npkt->sequence = -1;\r\nusbhs_pipe_set_trans_count_if_bulk(pipe, pkt->length);\r\nret = usbhsf_fifo_select(pipe, fifo, 1);\r\nif (ret < 0)\r\nreturn 0;\r\nret = usbhs_pipe_is_accessible(pipe);\r\nif (ret < 0) {\r\nret = 0;\r\ngoto usbhs_fifo_write_busy;\r\n}\r\nret = usbhsf_fifo_barrier(priv, fifo);\r\nif (ret < 0)\r\ngoto usbhs_fifo_write_busy;\r\nbuf = pkt->buf + pkt->actual;\r\nlen = pkt->length - pkt->actual;\r\nlen = min(len, maxp);\r\ntotal_len = len;\r\nis_short = total_len < maxp;\r\nif (len >= 4 && !((unsigned long)buf & 0x03)) {\r\niowrite32_rep(addr, buf, len / 4);\r\nlen %= 4;\r\nbuf += total_len - len;\r\n}\r\nfor (i = 0; i < len; i++)\r\niowrite8(buf[i], addr + (0x03 - (i & 0x03)));\r\npkt->actual += total_len;\r\nif (pkt->actual < pkt->length)\r\n*is_done = 0;\r\nelse if (is_short)\r\n*is_done = 1;\r\nelse\r\n*is_done = !pkt->zero;\r\nif (is_short)\r\nusbhsf_send_terminator(pipe, fifo);\r\nusbhsf_tx_irq_ctrl(pipe, !*is_done);\r\nusbhs_pipe_enable(pipe);\r\ndev_dbg(dev, " send %d (%d/ %d/ %d/ %d)\n",\r\nusbhs_pipe_number(pipe),\r\npkt->length, pkt->actual, *is_done, pkt->zero);\r\nif (*is_done) {\r\nif (usbhs_pipe_is_dcp(pipe))\r\nusbhs_dcp_control_transfer_done(pipe);\r\n}\r\nusbhsf_fifo_unselect(pipe, fifo);\r\nreturn 0;\r\nusbhs_fifo_write_busy:\r\nusbhsf_fifo_unselect(pipe, fifo);\r\nusbhsf_tx_irq_ctrl(pipe, 1);\r\nreturn ret;\r\n}\r\nstatic int usbhsf_prepare_pop(struct usbhs_pkt *pkt, int *is_done)\r\n{\r\nstruct usbhs_pipe *pipe = pkt->pipe;\r\nif (usbhs_pipe_is_busy(pipe))\r\nreturn 0;\r\nusbhs_pipe_data_sequence(pipe, pkt->sequence);\r\npkt->sequence = -1;\r\nusbhs_pipe_set_trans_count_if_bulk(pipe, pkt->length);\r\nusbhs_pipe_enable(pipe);\r\nusbhsf_rx_irq_ctrl(pipe, 1);\r\nreturn 0;\r\n}\r\nstatic int usbhsf_pio_try_pop(struct usbhs_pkt *pkt, int *is_done)\r\n{\r\nstruct usbhs_pipe *pipe = pkt->pipe;\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nstruct usbhs_fifo *fifo = usbhsf_get_cfifo(priv);\r\nvoid __iomem *addr = priv->base + fifo->port;\r\nu8 *buf;\r\nu32 data = 0;\r\nint maxp = usbhs_pipe_get_maxpacket(pipe);\r\nint rcv_len, len;\r\nint i, ret;\r\nint total_len = 0;\r\nret = usbhsf_fifo_select(pipe, fifo, 0);\r\nif (ret < 0)\r\nreturn 0;\r\nret = usbhsf_fifo_barrier(priv, fifo);\r\nif (ret < 0)\r\ngoto usbhs_fifo_read_busy;\r\nrcv_len = usbhsf_fifo_rcv_len(priv, fifo);\r\nbuf = pkt->buf + pkt->actual;\r\nlen = pkt->length - pkt->actual;\r\nlen = min(len, rcv_len);\r\ntotal_len = len;\r\npkt->actual += total_len;\r\nif ((pkt->actual == pkt->length) ||\r\n(total_len < maxp)) {\r\n*is_done = 1;\r\nusbhsf_rx_irq_ctrl(pipe, 0);\r\nusbhs_pipe_disable(pipe);\r\n}\r\nif (0 == rcv_len) {\r\npkt->zero = 1;\r\nusbhsf_fifo_clear(pipe, fifo);\r\ngoto usbhs_fifo_read_end;\r\n}\r\nif (len >= 4 && !((unsigned long)buf & 0x03)) {\r\nioread32_rep(addr, buf, len / 4);\r\nlen %= 4;\r\nbuf += total_len - len;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nif (!(i & 0x03))\r\ndata = ioread32(addr);\r\nbuf[i] = (data >> ((i & 0x03) * 8)) & 0xff;\r\n}\r\nusbhs_fifo_read_end:\r\ndev_dbg(dev, " recv %d (%d/ %d/ %d/ %d)\n",\r\nusbhs_pipe_number(pipe),\r\npkt->length, pkt->actual, *is_done, pkt->zero);\r\nusbhs_fifo_read_busy:\r\nusbhsf_fifo_unselect(pipe, fifo);\r\nreturn ret;\r\n}\r\nstatic int usbhsf_ctrl_stage_end(struct usbhs_pkt *pkt, int *is_done)\r\n{\r\nusbhs_dcp_control_transfer_done(pkt->pipe);\r\n*is_done = 1;\r\nreturn 0;\r\n}\r\nstatic struct dma_chan *usbhsf_dma_chan_get(struct usbhs_fifo *fifo,\r\nstruct usbhs_pkt *pkt)\r\n{\r\nif (&usbhs_fifo_dma_push_handler == pkt->handler)\r\nreturn fifo->tx_chan;\r\nif (&usbhs_fifo_dma_pop_handler == pkt->handler)\r\nreturn fifo->rx_chan;\r\nreturn NULL;\r\n}\r\nstatic struct usbhs_fifo *usbhsf_get_dma_fifo(struct usbhs_priv *priv,\r\nstruct usbhs_pkt *pkt)\r\n{\r\nstruct usbhs_fifo *fifo;\r\nfifo = usbhsf_get_d0fifo(priv);\r\nif (usbhsf_dma_chan_get(fifo, pkt) &&\r\n!usbhsf_fifo_is_busy(fifo))\r\nreturn fifo;\r\nfifo = usbhsf_get_d1fifo(priv);\r\nif (usbhsf_dma_chan_get(fifo, pkt) &&\r\n!usbhsf_fifo_is_busy(fifo))\r\nreturn fifo;\r\nreturn NULL;\r\n}\r\nstatic void __usbhsf_dma_ctrl(struct usbhs_pipe *pipe,\r\nstruct usbhs_fifo *fifo,\r\nu16 dreqe)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nusbhs_bset(priv, fifo->sel, DREQE, dreqe);\r\n}\r\nstatic int __usbhsf_dma_map_ctrl(struct usbhs_pkt *pkt, int map)\r\n{\r\nstruct usbhs_pipe *pipe = pkt->pipe;\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nstruct usbhs_pipe_info *info = usbhs_priv_to_pipeinfo(priv);\r\nreturn info->dma_map_ctrl(pkt, map);\r\n}\r\nstatic void xfer_work(struct work_struct *work)\r\n{\r\nstruct usbhs_pkt *pkt = container_of(work, struct usbhs_pkt, work);\r\nstruct usbhs_pipe *pipe = pkt->pipe;\r\nstruct usbhs_fifo *fifo = usbhs_pipe_to_fifo(pipe);\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct dma_chan *chan = usbhsf_dma_chan_get(fifo, pkt);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nenum dma_transfer_direction dir;\r\ndir = usbhs_pipe_is_dir_in(pipe) ? DMA_DEV_TO_MEM : DMA_MEM_TO_DEV;\r\ndesc = dmaengine_prep_slave_single(chan, pkt->dma + pkt->actual,\r\npkt->trans, dir,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc)\r\nreturn;\r\ndesc->callback = usbhsf_dma_complete;\r\ndesc->callback_param = pipe;\r\nif (dmaengine_submit(desc) < 0) {\r\ndev_err(dev, "Failed to submit dma descriptor\n");\r\nreturn;\r\n}\r\ndev_dbg(dev, " %s %d (%d/ %d)\n",\r\nfifo->name, usbhs_pipe_number(pipe), pkt->length, pkt->zero);\r\nusbhs_pipe_set_trans_count_if_bulk(pipe, pkt->trans);\r\nusbhs_pipe_enable(pipe);\r\nusbhsf_dma_start(pipe, fifo);\r\ndma_async_issue_pending(chan);\r\n}\r\nstatic int usbhsf_dma_prepare_push(struct usbhs_pkt *pkt, int *is_done)\r\n{\r\nstruct usbhs_pipe *pipe = pkt->pipe;\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nstruct usbhs_fifo *fifo;\r\nint len = pkt->length - pkt->actual;\r\nint ret;\r\nif (usbhs_pipe_is_busy(pipe))\r\nreturn 0;\r\nif ((len < usbhs_get_dparam(priv, pio_dma_border)) ||\r\nusbhs_pipe_is_dcp(pipe))\r\ngoto usbhsf_pio_prepare_push;\r\nif (len & 0x7)\r\ngoto usbhsf_pio_prepare_push;\r\nif ((uintptr_t)(pkt->buf + pkt->actual) & 0x7)\r\ngoto usbhsf_pio_prepare_push;\r\nfifo = usbhsf_get_dma_fifo(priv, pkt);\r\nif (!fifo)\r\ngoto usbhsf_pio_prepare_push;\r\nif (usbhsf_dma_map(pkt) < 0)\r\ngoto usbhsf_pio_prepare_push;\r\nret = usbhsf_fifo_select(pipe, fifo, 0);\r\nif (ret < 0)\r\ngoto usbhsf_pio_prepare_push_unmap;\r\npkt->trans = len;\r\nINIT_WORK(&pkt->work, xfer_work);\r\nschedule_work(&pkt->work);\r\nreturn 0;\r\nusbhsf_pio_prepare_push_unmap:\r\nusbhsf_dma_unmap(pkt);\r\nusbhsf_pio_prepare_push:\r\npkt->handler = &usbhs_fifo_pio_push_handler;\r\nreturn pkt->handler->prepare(pkt, is_done);\r\n}\r\nstatic int usbhsf_dma_push_done(struct usbhs_pkt *pkt, int *is_done)\r\n{\r\nstruct usbhs_pipe *pipe = pkt->pipe;\r\npkt->actual = pkt->trans;\r\n*is_done = !pkt->zero;\r\nusbhsf_dma_stop(pipe, pipe->fifo);\r\nusbhsf_dma_unmap(pkt);\r\nusbhsf_fifo_unselect(pipe, pipe->fifo);\r\nreturn 0;\r\n}\r\nstatic int usbhsf_dma_try_pop(struct usbhs_pkt *pkt, int *is_done)\r\n{\r\nstruct usbhs_pipe *pipe = pkt->pipe;\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nstruct usbhs_fifo *fifo;\r\nint len, ret;\r\nif (usbhs_pipe_is_busy(pipe))\r\nreturn 0;\r\nif (usbhs_pipe_is_dcp(pipe))\r\ngoto usbhsf_pio_prepare_pop;\r\nfifo = usbhsf_get_dma_fifo(priv, pkt);\r\nif (!fifo)\r\ngoto usbhsf_pio_prepare_pop;\r\nif ((uintptr_t)(pkt->buf + pkt->actual) & 0x7)\r\ngoto usbhsf_pio_prepare_pop;\r\nret = usbhsf_fifo_select(pipe, fifo, 0);\r\nif (ret < 0)\r\ngoto usbhsf_pio_prepare_pop;\r\nlen = usbhsf_fifo_rcv_len(priv, fifo);\r\nlen = min(pkt->length - pkt->actual, len);\r\nif (len & 0x7)\r\ngoto usbhsf_pio_prepare_pop_unselect;\r\nif (len < usbhs_get_dparam(priv, pio_dma_border))\r\ngoto usbhsf_pio_prepare_pop_unselect;\r\nret = usbhsf_fifo_barrier(priv, fifo);\r\nif (ret < 0)\r\ngoto usbhsf_pio_prepare_pop_unselect;\r\nif (usbhsf_dma_map(pkt) < 0)\r\ngoto usbhsf_pio_prepare_pop_unselect;\r\nusbhsf_rx_irq_ctrl(pipe, 0);\r\npkt->trans = len;\r\nINIT_WORK(&pkt->work, xfer_work);\r\nschedule_work(&pkt->work);\r\nreturn 0;\r\nusbhsf_pio_prepare_pop_unselect:\r\nusbhsf_fifo_unselect(pipe, fifo);\r\nusbhsf_pio_prepare_pop:\r\npkt->handler = &usbhs_fifo_pio_pop_handler;\r\nreturn pkt->handler->try_run(pkt, is_done);\r\n}\r\nstatic int usbhsf_dma_pop_done(struct usbhs_pkt *pkt, int *is_done)\r\n{\r\nstruct usbhs_pipe *pipe = pkt->pipe;\r\nint maxp = usbhs_pipe_get_maxpacket(pipe);\r\nusbhsf_dma_stop(pipe, pipe->fifo);\r\nusbhsf_dma_unmap(pkt);\r\nusbhsf_fifo_unselect(pipe, pipe->fifo);\r\npkt->actual += pkt->trans;\r\nif ((pkt->actual == pkt->length) ||\r\n(pkt->trans < maxp)) {\r\n*is_done = 1;\r\n} else {\r\nusbhsf_prepare_pop(pkt, is_done);\r\n}\r\nreturn 0;\r\n}\r\nstatic bool usbhsf_dma_filter(struct dma_chan *chan, void *param)\r\n{\r\nstruct sh_dmae_slave *slave = param;\r\nif (0 == slave->shdma_slave.slave_id)\r\nreturn false;\r\nchan->private = slave;\r\nreturn true;\r\n}\r\nstatic void usbhsf_dma_quit(struct usbhs_priv *priv, struct usbhs_fifo *fifo)\r\n{\r\nif (fifo->tx_chan)\r\ndma_release_channel(fifo->tx_chan);\r\nif (fifo->rx_chan)\r\ndma_release_channel(fifo->rx_chan);\r\nfifo->tx_chan = NULL;\r\nfifo->rx_chan = NULL;\r\n}\r\nstatic void usbhsf_dma_init(struct usbhs_priv *priv,\r\nstruct usbhs_fifo *fifo)\r\n{\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\ndma_cap_mask_t mask;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nfifo->tx_chan = dma_request_channel(mask, usbhsf_dma_filter,\r\n&fifo->tx_slave);\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nfifo->rx_chan = dma_request_channel(mask, usbhsf_dma_filter,\r\n&fifo->rx_slave);\r\nif (fifo->tx_chan || fifo->rx_chan)\r\ndev_dbg(dev, "enable DMAEngine (%s%s%s)\n",\r\nfifo->name,\r\nfifo->tx_chan ? "[TX]" : " ",\r\nfifo->rx_chan ? "[RX]" : " ");\r\n}\r\nstatic int usbhsf_irq_empty(struct usbhs_priv *priv,\r\nstruct usbhs_irq_state *irq_state)\r\n{\r\nstruct usbhs_pipe *pipe;\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nint i, ret;\r\nif (!irq_state->bempsts) {\r\ndev_err(dev, "debug %s !!\n", __func__);\r\nreturn -EIO;\r\n}\r\ndev_dbg(dev, "irq empty [0x%04x]\n", irq_state->bempsts);\r\nusbhs_for_each_pipe_with_dcp(pipe, priv, i) {\r\nif (!(irq_state->bempsts & (1 << i)))\r\ncontinue;\r\nret = usbhsf_pkt_handler(pipe, USBHSF_PKT_TRY_RUN);\r\nif (ret < 0)\r\ndev_err(dev, "irq_empty run_error %d : %d\n", i, ret);\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbhsf_irq_ready(struct usbhs_priv *priv,\r\nstruct usbhs_irq_state *irq_state)\r\n{\r\nstruct usbhs_pipe *pipe;\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nint i, ret;\r\nif (!irq_state->brdysts) {\r\ndev_err(dev, "debug %s !!\n", __func__);\r\nreturn -EIO;\r\n}\r\ndev_dbg(dev, "irq ready [0x%04x]\n", irq_state->brdysts);\r\nusbhs_for_each_pipe_with_dcp(pipe, priv, i) {\r\nif (!(irq_state->brdysts & (1 << i)))\r\ncontinue;\r\nret = usbhsf_pkt_handler(pipe, USBHSF_PKT_TRY_RUN);\r\nif (ret < 0)\r\ndev_err(dev, "irq_ready run_error %d : %d\n", i, ret);\r\n}\r\nreturn 0;\r\n}\r\nstatic void usbhsf_dma_complete(void *arg)\r\n{\r\nstruct usbhs_pipe *pipe = arg;\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nint ret;\r\nret = usbhsf_pkt_handler(pipe, USBHSF_PKT_DMA_DONE);\r\nif (ret < 0)\r\ndev_err(dev, "dma_complete run_error %d : %d\n",\r\nusbhs_pipe_number(pipe), ret);\r\n}\r\nvoid usbhs_fifo_init(struct usbhs_priv *priv)\r\n{\r\nstruct usbhs_mod *mod = usbhs_mod_get_current(priv);\r\nstruct usbhs_fifo *cfifo = usbhsf_get_cfifo(priv);\r\nstruct usbhs_fifo *d0fifo = usbhsf_get_d0fifo(priv);\r\nstruct usbhs_fifo *d1fifo = usbhsf_get_d1fifo(priv);\r\nmod->irq_empty = usbhsf_irq_empty;\r\nmod->irq_ready = usbhsf_irq_ready;\r\nmod->irq_bempsts = 0;\r\nmod->irq_brdysts = 0;\r\ncfifo->pipe = NULL;\r\ncfifo->tx_chan = NULL;\r\ncfifo->rx_chan = NULL;\r\nd0fifo->pipe = NULL;\r\nd0fifo->tx_chan = NULL;\r\nd0fifo->rx_chan = NULL;\r\nd1fifo->pipe = NULL;\r\nd1fifo->tx_chan = NULL;\r\nd1fifo->rx_chan = NULL;\r\nusbhsf_dma_init(priv, usbhsf_get_d0fifo(priv));\r\nusbhsf_dma_init(priv, usbhsf_get_d1fifo(priv));\r\n}\r\nvoid usbhs_fifo_quit(struct usbhs_priv *priv)\r\n{\r\nstruct usbhs_mod *mod = usbhs_mod_get_current(priv);\r\nmod->irq_empty = NULL;\r\nmod->irq_ready = NULL;\r\nmod->irq_bempsts = 0;\r\nmod->irq_brdysts = 0;\r\nusbhsf_dma_quit(priv, usbhsf_get_d0fifo(priv));\r\nusbhsf_dma_quit(priv, usbhsf_get_d1fifo(priv));\r\n}\r\nint usbhs_fifo_probe(struct usbhs_priv *priv)\r\n{\r\nstruct usbhs_fifo *fifo;\r\nfifo = usbhsf_get_cfifo(priv);\r\nfifo->name = "CFIFO";\r\nfifo->port = CFIFO;\r\nfifo->sel = CFIFOSEL;\r\nfifo->ctr = CFIFOCTR;\r\nfifo = usbhsf_get_d0fifo(priv);\r\nfifo->name = "D0FIFO";\r\nfifo->port = D0FIFO;\r\nfifo->sel = D0FIFOSEL;\r\nfifo->ctr = D0FIFOCTR;\r\nfifo->tx_slave.shdma_slave.slave_id = usbhs_get_dparam(priv, d0_tx_id);\r\nfifo->rx_slave.shdma_slave.slave_id = usbhs_get_dparam(priv, d0_rx_id);\r\nfifo = usbhsf_get_d1fifo(priv);\r\nfifo->name = "D1FIFO";\r\nfifo->port = D1FIFO;\r\nfifo->sel = D1FIFOSEL;\r\nfifo->ctr = D1FIFOCTR;\r\nfifo->tx_slave.shdma_slave.slave_id = usbhs_get_dparam(priv, d1_tx_id);\r\nfifo->rx_slave.shdma_slave.slave_id = usbhs_get_dparam(priv, d1_rx_id);\r\nreturn 0;\r\n}\r\nvoid usbhs_fifo_remove(struct usbhs_priv *priv)\r\n{\r\n}
