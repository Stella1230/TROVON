void\r\nflush_data_cache(void)\r\n{\r\non_each_cpu(flush_data_cache_local, NULL, 1);\r\n}\r\nvoid\r\nflush_instruction_cache(void)\r\n{\r\non_each_cpu(flush_instruction_cache_local, NULL, 1);\r\n}\r\nvoid\r\nflush_cache_all_local(void)\r\n{\r\nflush_instruction_cache_local(NULL);\r\nflush_data_cache_local(NULL);\r\n}\r\nvoid\r\nupdate_mmu_cache(struct vm_area_struct *vma, unsigned long address, pte_t *ptep)\r\n{\r\nunsigned long pfn = pte_pfn(*ptep);\r\nstruct page *page;\r\nif (!pfn_valid(pfn))\r\nreturn;\r\npage = pfn_to_page(pfn);\r\nif (page_mapping(page) && test_bit(PG_dcache_dirty, &page->flags)) {\r\nflush_kernel_dcache_page_addr(pfn_va(pfn));\r\nclear_bit(PG_dcache_dirty, &page->flags);\r\n} else if (parisc_requires_coherency())\r\nflush_kernel_dcache_page_addr(pfn_va(pfn));\r\n}\r\nvoid\r\nshow_cache_info(struct seq_file *m)\r\n{\r\nchar buf[32];\r\nseq_printf(m, "I-cache\t\t: %ld KB\n",\r\ncache_info.ic_size/1024 );\r\nif (cache_info.dc_loop != 1)\r\nsnprintf(buf, 32, "%lu-way associative", cache_info.dc_loop);\r\nseq_printf(m, "D-cache\t\t: %ld KB (%s%s, %s)\n",\r\ncache_info.dc_size/1024,\r\n(cache_info.dc_conf.cc_wt ? "WT":"WB"),\r\n(cache_info.dc_conf.cc_sh ? ", shared I/D":""),\r\n((cache_info.dc_loop == 1) ? "direct mapped" : buf));\r\nseq_printf(m, "ITLB entries\t: %ld\n" "DTLB entries\t: %ld%s\n",\r\ncache_info.it_size,\r\ncache_info.dt_size,\r\ncache_info.dt_conf.tc_sh ? " - shared with ITLB":""\r\n);\r\n#ifndef CONFIG_PA20\r\nif (btlb_info.max_size==0) {\r\nseq_printf(m, "BTLB\t\t: not supported\n" );\r\n} else {\r\nseq_printf(m,\r\n"BTLB fixed\t: max. %d pages, pagesize=%d (%dMB)\n"\r\n"BTLB fix-entr.\t: %d instruction, %d data (%d combined)\n"\r\n"BTLB var-entr.\t: %d instruction, %d data (%d combined)\n",\r\nbtlb_info.max_size, (int)4096,\r\nbtlb_info.max_size>>8,\r\nbtlb_info.fixed_range_info.num_i,\r\nbtlb_info.fixed_range_info.num_d,\r\nbtlb_info.fixed_range_info.num_comb,\r\nbtlb_info.variable_range_info.num_i,\r\nbtlb_info.variable_range_info.num_d,\r\nbtlb_info.variable_range_info.num_comb\r\n);\r\n}\r\n#endif\r\n}\r\nvoid __init\r\nparisc_cache_init(void)\r\n{\r\nif (pdc_cache_info(&cache_info) < 0)\r\npanic("parisc_cache_init: pdc_cache_info failed");\r\n#if 0\r\nprintk("ic_size %lx dc_size %lx it_size %lx\n",\r\ncache_info.ic_size,\r\ncache_info.dc_size,\r\ncache_info.it_size);\r\nprintk("DC base 0x%lx stride 0x%lx count 0x%lx loop 0x%lx\n",\r\ncache_info.dc_base,\r\ncache_info.dc_stride,\r\ncache_info.dc_count,\r\ncache_info.dc_loop);\r\nprintk("dc_conf = 0x%lx alias %d blk %d line %d shift %d\n",\r\n*(unsigned long *) (&cache_info.dc_conf),\r\ncache_info.dc_conf.cc_alias,\r\ncache_info.dc_conf.cc_block,\r\ncache_info.dc_conf.cc_line,\r\ncache_info.dc_conf.cc_shift);\r\nprintk(" wt %d sh %d cst %d hv %d\n",\r\ncache_info.dc_conf.cc_wt,\r\ncache_info.dc_conf.cc_sh,\r\ncache_info.dc_conf.cc_cst,\r\ncache_info.dc_conf.cc_hv);\r\nprintk("IC base 0x%lx stride 0x%lx count 0x%lx loop 0x%lx\n",\r\ncache_info.ic_base,\r\ncache_info.ic_stride,\r\ncache_info.ic_count,\r\ncache_info.ic_loop);\r\nprintk("ic_conf = 0x%lx alias %d blk %d line %d shift %d\n",\r\n*(unsigned long *) (&cache_info.ic_conf),\r\ncache_info.ic_conf.cc_alias,\r\ncache_info.ic_conf.cc_block,\r\ncache_info.ic_conf.cc_line,\r\ncache_info.ic_conf.cc_shift);\r\nprintk(" wt %d sh %d cst %d hv %d\n",\r\ncache_info.ic_conf.cc_wt,\r\ncache_info.ic_conf.cc_sh,\r\ncache_info.ic_conf.cc_cst,\r\ncache_info.ic_conf.cc_hv);\r\nprintk("D-TLB conf: sh %d page %d cst %d aid %d pad1 %d\n",\r\ncache_info.dt_conf.tc_sh,\r\ncache_info.dt_conf.tc_page,\r\ncache_info.dt_conf.tc_cst,\r\ncache_info.dt_conf.tc_aid,\r\ncache_info.dt_conf.tc_pad1);\r\nprintk("I-TLB conf: sh %d page %d cst %d aid %d pad1 %d\n",\r\ncache_info.it_conf.tc_sh,\r\ncache_info.it_conf.tc_page,\r\ncache_info.it_conf.tc_cst,\r\ncache_info.it_conf.tc_aid,\r\ncache_info.it_conf.tc_pad1);\r\n#endif\r\nsplit_tlb = 0;\r\nif (cache_info.dt_conf.tc_sh == 0 || cache_info.dt_conf.tc_sh == 2) {\r\nif (cache_info.dt_conf.tc_sh == 2)\r\nprintk(KERN_WARNING "Unexpected TLB configuration. "\r\n"Will flush I/D separately (could be optimized).\n");\r\nsplit_tlb = 1;\r\n}\r\n#define CAFL_STRIDE(cnf) (cnf.cc_line << (3 + cnf.cc_block + cnf.cc_shift))\r\ndcache_stride = CAFL_STRIDE(cache_info.dc_conf);\r\nicache_stride = CAFL_STRIDE(cache_info.ic_conf);\r\n#undef CAFL_STRIDE\r\n#ifndef CONFIG_PA20\r\nif (pdc_btlb_info(&btlb_info) < 0) {\r\nmemset(&btlb_info, 0, sizeof btlb_info);\r\n}\r\n#endif\r\nif ((boot_cpu_data.pdc.capabilities & PDC_MODEL_NVA_MASK) ==\r\nPDC_MODEL_NVA_UNSUPPORTED) {\r\nprintk(KERN_WARNING "parisc_cache_init: Only equivalent aliasing supported!\n");\r\n#if 0\r\npanic("SMP kernel required to avoid non-equivalent aliasing");\r\n#endif\r\n}\r\n}\r\nvoid disable_sr_hashing(void)\r\n{\r\nint srhash_type, retval;\r\nunsigned long space_bits;\r\nswitch (boot_cpu_data.cpu_type) {\r\ncase pcx:\r\nBUG();\r\nreturn;\r\ncase pcxs:\r\ncase pcxt:\r\ncase pcxt_:\r\nsrhash_type = SRHASH_PCXST;\r\nbreak;\r\ncase pcxl:\r\nsrhash_type = SRHASH_PCXL;\r\nbreak;\r\ncase pcxl2:\r\nreturn;\r\ndefault:\r\nsrhash_type = SRHASH_PA20;\r\nbreak;\r\n}\r\ndisable_sr_hashing_asm(srhash_type);\r\nretval = pdc_spaceid_bits(&space_bits);\r\nif (retval < 0 && retval != PDC_BAD_OPTION)\r\npanic("pdc_spaceid_bits call failed.\n");\r\nif (space_bits != 0)\r\npanic("SpaceID hashing is still on!\n");\r\n}\r\nstatic inline void\r\n__flush_cache_page(struct vm_area_struct *vma, unsigned long vmaddr,\r\nunsigned long physaddr)\r\n{\r\npreempt_disable();\r\nflush_dcache_page_asm(physaddr, vmaddr);\r\nif (vma->vm_flags & VM_EXEC)\r\nflush_icache_page_asm(physaddr, vmaddr);\r\npreempt_enable();\r\n}\r\nvoid flush_dcache_page(struct page *page)\r\n{\r\nstruct address_space *mapping = page_mapping(page);\r\nstruct vm_area_struct *mpnt;\r\nunsigned long offset;\r\nunsigned long addr, old_addr = 0;\r\npgoff_t pgoff;\r\nif (mapping && !mapping_mapped(mapping)) {\r\nset_bit(PG_dcache_dirty, &page->flags);\r\nreturn;\r\n}\r\nflush_kernel_dcache_page(page);\r\nif (!mapping)\r\nreturn;\r\npgoff = page->index << (PAGE_CACHE_SHIFT - PAGE_SHIFT);\r\nflush_dcache_mmap_lock(mapping);\r\nvma_interval_tree_foreach(mpnt, &mapping->i_mmap, pgoff, pgoff) {\r\noffset = (pgoff - mpnt->vm_pgoff) << PAGE_SHIFT;\r\naddr = mpnt->vm_start + offset;\r\nflush_tlb_page(mpnt, addr);\r\nif (old_addr == 0 || (old_addr & (SHMLBA - 1)) != (addr & (SHMLBA - 1))) {\r\n__flush_cache_page(mpnt, addr, page_to_phys(page));\r\nif (old_addr)\r\nprintk(KERN_ERR "INEQUIVALENT ALIASES 0x%lx and 0x%lx in file %s\n", old_addr, addr, mpnt->vm_file ? (char *)mpnt->vm_file->f_path.dentry->d_name.name : "(null)");\r\nold_addr = addr;\r\n}\r\n}\r\nflush_dcache_mmap_unlock(mapping);\r\n}\r\nvoid __init parisc_setup_cache_timing(void)\r\n{\r\nunsigned long rangetime, alltime;\r\nunsigned long size;\r\nalltime = mfctl(16);\r\nflush_data_cache();\r\nalltime = mfctl(16) - alltime;\r\nsize = (unsigned long)(_end - _text);\r\nrangetime = mfctl(16);\r\nflush_kernel_dcache_range((unsigned long)_text, size);\r\nrangetime = mfctl(16) - rangetime;\r\nprintk(KERN_DEBUG "Whole cache flush %lu cycles, flushing %lu bytes %lu cycles\n",\r\nalltime, size, rangetime);\r\nparisc_cache_flush_threshold = size * alltime / rangetime;\r\nparisc_cache_flush_threshold = (parisc_cache_flush_threshold + L1_CACHE_BYTES - 1) &~ (L1_CACHE_BYTES - 1);\r\nif (!parisc_cache_flush_threshold)\r\nparisc_cache_flush_threshold = FLUSH_THRESHOLD;\r\nif (parisc_cache_flush_threshold > cache_info.dc_size)\r\nparisc_cache_flush_threshold = cache_info.dc_size;\r\nprintk(KERN_INFO "Setting cache flush threshold to %x (%d CPUs online)\n", parisc_cache_flush_threshold, num_online_cpus());\r\n}\r\nvoid flush_kernel_dcache_page_addr(void *addr)\r\n{\r\nunsigned long flags;\r\nflush_kernel_dcache_page_asm(addr);\r\npurge_tlb_start(flags);\r\npdtlb_kernel(addr);\r\npurge_tlb_end(flags);\r\n}\r\nvoid clear_user_page(void *vto, unsigned long vaddr, struct page *page)\r\n{\r\nclear_page_asm(vto);\r\nif (!parisc_requires_coherency())\r\nflush_kernel_dcache_page_asm(vto);\r\n}\r\nvoid copy_user_page(void *vto, void *vfrom, unsigned long vaddr,\r\nstruct page *pg)\r\n{\r\npreempt_disable();\r\nflush_dcache_page_asm(__pa(vfrom), vaddr);\r\npreempt_enable();\r\ncopy_page_asm(vto, vfrom);\r\nif (!parisc_requires_coherency())\r\nflush_kernel_dcache_page_asm(vto);\r\n}\r\nvoid kunmap_parisc(void *addr)\r\n{\r\nif (parisc_requires_coherency())\r\nflush_kernel_dcache_page_addr(addr);\r\n}\r\nvoid purge_tlb_entries(struct mm_struct *mm, unsigned long addr)\r\n{\r\nunsigned long flags;\r\npurge_tlb_start(flags);\r\nmtsp(mm->context, 1);\r\npdtlb(addr);\r\npitlb(addr);\r\npurge_tlb_end(flags);\r\n}\r\nvoid __flush_tlb_range(unsigned long sid, unsigned long start,\r\nunsigned long end)\r\n{\r\nunsigned long npages;\r\nnpages = ((end - (start & PAGE_MASK)) + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\r\nif (npages >= 512)\r\nflush_tlb_all();\r\nelse {\r\nunsigned long flags;\r\npurge_tlb_start(flags);\r\nmtsp(sid, 1);\r\nif (split_tlb) {\r\nwhile (npages--) {\r\npdtlb(start);\r\npitlb(start);\r\nstart += PAGE_SIZE;\r\n}\r\n} else {\r\nwhile (npages--) {\r\npdtlb(start);\r\nstart += PAGE_SIZE;\r\n}\r\n}\r\npurge_tlb_end(flags);\r\n}\r\n}\r\nstatic void cacheflush_h_tmp_function(void *dummy)\r\n{\r\nflush_cache_all_local();\r\n}\r\nvoid flush_cache_all(void)\r\n{\r\non_each_cpu(cacheflush_h_tmp_function, NULL, 1);\r\n}\r\nstatic inline unsigned long mm_total_size(struct mm_struct *mm)\r\n{\r\nstruct vm_area_struct *vma;\r\nunsigned long usize = 0;\r\nfor (vma = mm->mmap; vma; vma = vma->vm_next)\r\nusize += vma->vm_end - vma->vm_start;\r\nreturn usize;\r\n}\r\nstatic inline pte_t *get_ptep(pgd_t *pgd, unsigned long addr)\r\n{\r\npte_t *ptep = NULL;\r\nif (!pgd_none(*pgd)) {\r\npud_t *pud = pud_offset(pgd, addr);\r\nif (!pud_none(*pud)) {\r\npmd_t *pmd = pmd_offset(pud, addr);\r\nif (!pmd_none(*pmd))\r\nptep = pte_offset_map(pmd, addr);\r\n}\r\n}\r\nreturn ptep;\r\n}\r\nvoid flush_cache_mm(struct mm_struct *mm)\r\n{\r\nstruct vm_area_struct *vma;\r\npgd_t *pgd;\r\nif (mm_total_size(mm) >= parisc_cache_flush_threshold) {\r\nflush_cache_all();\r\nreturn;\r\n}\r\nif (mm->context == mfsp(3)) {\r\nfor (vma = mm->mmap; vma; vma = vma->vm_next) {\r\nflush_user_dcache_range_asm(vma->vm_start, vma->vm_end);\r\nif ((vma->vm_flags & VM_EXEC) == 0)\r\ncontinue;\r\nflush_user_icache_range_asm(vma->vm_start, vma->vm_end);\r\n}\r\nreturn;\r\n}\r\npgd = mm->pgd;\r\nfor (vma = mm->mmap; vma; vma = vma->vm_next) {\r\nunsigned long addr;\r\nfor (addr = vma->vm_start; addr < vma->vm_end;\r\naddr += PAGE_SIZE) {\r\nunsigned long pfn;\r\npte_t *ptep = get_ptep(pgd, addr);\r\nif (!ptep)\r\ncontinue;\r\npfn = pte_pfn(*ptep);\r\nif (!pfn_valid(pfn))\r\ncontinue;\r\n__flush_cache_page(vma, addr, PFN_PHYS(pfn));\r\n}\r\n}\r\n}\r\nvoid\r\nflush_user_dcache_range(unsigned long start, unsigned long end)\r\n{\r\nif ((end - start) < parisc_cache_flush_threshold)\r\nflush_user_dcache_range_asm(start,end);\r\nelse\r\nflush_data_cache();\r\n}\r\nvoid\r\nflush_user_icache_range(unsigned long start, unsigned long end)\r\n{\r\nif ((end - start) < parisc_cache_flush_threshold)\r\nflush_user_icache_range_asm(start,end);\r\nelse\r\nflush_instruction_cache();\r\n}\r\nvoid flush_cache_range(struct vm_area_struct *vma,\r\nunsigned long start, unsigned long end)\r\n{\r\nunsigned long addr;\r\npgd_t *pgd;\r\nBUG_ON(!vma->vm_mm->context);\r\nif ((end - start) >= parisc_cache_flush_threshold) {\r\nflush_cache_all();\r\nreturn;\r\n}\r\nif (vma->vm_mm->context == mfsp(3)) {\r\nflush_user_dcache_range_asm(start, end);\r\nif (vma->vm_flags & VM_EXEC)\r\nflush_user_icache_range_asm(start, end);\r\nreturn;\r\n}\r\npgd = vma->vm_mm->pgd;\r\nfor (addr = start & PAGE_MASK; addr < end; addr += PAGE_SIZE) {\r\nunsigned long pfn;\r\npte_t *ptep = get_ptep(pgd, addr);\r\nif (!ptep)\r\ncontinue;\r\npfn = pte_pfn(*ptep);\r\nif (pfn_valid(pfn))\r\n__flush_cache_page(vma, addr, PFN_PHYS(pfn));\r\n}\r\n}\r\nvoid\r\nflush_cache_page(struct vm_area_struct *vma, unsigned long vmaddr, unsigned long pfn)\r\n{\r\nBUG_ON(!vma->vm_mm->context);\r\nif (pfn_valid(pfn)) {\r\nflush_tlb_page(vma, vmaddr);\r\n__flush_cache_page(vma, vmaddr, PFN_PHYS(pfn));\r\n}\r\n}\r\nvoid clear_user_highpage(struct page *page, unsigned long vaddr)\r\n{\r\nvoid *vto;\r\nunsigned long flags;\r\nvto = kmap_atomic(page);\r\npurge_kernel_dcache_page_asm((unsigned long)vto);\r\npurge_tlb_start(flags);\r\npdtlb_kernel(vto);\r\npurge_tlb_end(flags);\r\npreempt_disable();\r\nclear_user_page_asm(vto, vaddr);\r\npreempt_enable();\r\npagefault_enable();\r\n}\r\nvoid copy_user_highpage(struct page *to, struct page *from,\r\nunsigned long vaddr, struct vm_area_struct *vma)\r\n{\r\nvoid *vfrom, *vto;\r\nunsigned long flags;\r\nvfrom = kmap_atomic(from);\r\nvto = kmap_atomic(to);\r\npurge_kernel_dcache_page_asm((unsigned long)vto);\r\npurge_tlb_start(flags);\r\npdtlb_kernel(vto);\r\npdtlb_kernel(vfrom);\r\npurge_tlb_end(flags);\r\npreempt_disable();\r\ncopy_user_page_asm(vto, vfrom, vaddr);\r\nflush_dcache_page_asm(__pa(vto), vaddr);\r\npreempt_enable();\r\npagefault_enable();\r\npagefault_enable();\r\n}
