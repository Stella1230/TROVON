static u32\r\nread_pll_1(struct drm_device *dev, u32 reg)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nu32 ctrl = nv_rd32(device, reg + 0x00);\r\nint P = (ctrl & 0x00070000) >> 16;\r\nint N = (ctrl & 0x0000ff00) >> 8;\r\nint M = (ctrl & 0x000000ff) >> 0;\r\nu32 ref = 27000, clk = 0;\r\nif (ctrl & 0x80000000)\r\nclk = ref * N / M;\r\nreturn clk >> P;\r\n}\r\nstatic u32\r\nread_pll_2(struct drm_device *dev, u32 reg)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nu32 ctrl = nv_rd32(device, reg + 0x00);\r\nu32 coef = nv_rd32(device, reg + 0x04);\r\nint N2 = (coef & 0xff000000) >> 24;\r\nint M2 = (coef & 0x00ff0000) >> 16;\r\nint N1 = (coef & 0x0000ff00) >> 8;\r\nint M1 = (coef & 0x000000ff) >> 0;\r\nint P = (ctrl & 0x00070000) >> 16;\r\nu32 ref = 27000, clk = 0;\r\nif ((ctrl & 0x80000000) && M1) {\r\nclk = ref * N1 / M1;\r\nif ((ctrl & 0x40000100) == 0x40000000) {\r\nif (M2)\r\nclk = clk * N2 / M2;\r\nelse\r\nclk = 0;\r\n}\r\n}\r\nreturn clk >> P;\r\n}\r\nstatic u32\r\nread_clk(struct drm_device *dev, u32 src)\r\n{\r\nswitch (src) {\r\ncase 3:\r\nreturn read_pll_2(dev, 0x004000);\r\ncase 2:\r\nreturn read_pll_1(dev, 0x004008);\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnv40_pm_clocks_get(struct drm_device *dev, struct nouveau_pm_level *perflvl)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nu32 ctrl = nv_rd32(device, 0x00c040);\r\nperflvl->core = read_clk(dev, (ctrl & 0x00000003) >> 0);\r\nperflvl->shader = read_clk(dev, (ctrl & 0x00000030) >> 4);\r\nperflvl->memory = read_pll_2(dev, 0x4020);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv40_calc_pll(struct drm_device *dev, u32 reg, struct nvbios_pll *pll,\r\nu32 clk, int *N1, int *M1, int *N2, int *M2, int *log2P)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nstruct nouveau_bios *bios = nouveau_bios(device);\r\nstruct nouveau_clock *pclk = nouveau_clock(device);\r\nstruct nouveau_pll_vals coef;\r\nint ret;\r\nret = nvbios_pll_parse(bios, reg, pll);\r\nif (ret)\r\nreturn ret;\r\nif (clk < pll->vco1.max_freq)\r\npll->vco2.max_freq = 0;\r\nret = pclk->pll_calc(pclk, pll, clk, &coef);\r\nif (ret == 0)\r\nreturn -ERANGE;\r\n*N1 = coef.N1;\r\n*M1 = coef.M1;\r\nif (N2 && M2) {\r\nif (pll->vco2.max_freq) {\r\n*N2 = coef.N2;\r\n*M2 = coef.M2;\r\n} else {\r\n*N2 = 1;\r\n*M2 = 1;\r\n}\r\n}\r\n*log2P = coef.log2P;\r\nreturn 0;\r\n}\r\nvoid *\r\nnv40_pm_clocks_pre(struct drm_device *dev, struct nouveau_pm_level *perflvl)\r\n{\r\nstruct nv40_pm_state *info;\r\nstruct nvbios_pll pll;\r\nint N1, N2, M1, M2, log2P;\r\nint ret;\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = nv40_calc_pll(dev, 0x004000, &pll, perflvl->core,\r\n&N1, &M1, &N2, &M2, &log2P);\r\nif (ret < 0)\r\ngoto out;\r\nif (N2 == M2) {\r\ninfo->npll_ctrl = 0x80000100 | (log2P << 16);\r\ninfo->npll_coef = (N1 << 8) | M1;\r\n} else {\r\ninfo->npll_ctrl = 0xc0000000 | (log2P << 16);\r\ninfo->npll_coef = (N2 << 24) | (M2 << 16) | (N1 << 8) | M1;\r\n}\r\nif (perflvl->shader && perflvl->shader != perflvl->core) {\r\nret = nv40_calc_pll(dev, 0x004008, &pll, perflvl->shader,\r\n&N1, &M1, NULL, NULL, &log2P);\r\nif (ret < 0)\r\ngoto out;\r\ninfo->spll = 0xc0000000 | (log2P << 16) | (N1 << 8) | M1;\r\ninfo->ctrl = 0x00000223;\r\n} else {\r\ninfo->spll = 0x00000000;\r\ninfo->ctrl = 0x00000333;\r\n}\r\nif (!perflvl->memory) {\r\ninfo->mpll_ctrl = 0x00000000;\r\ngoto out;\r\n}\r\nret = nv40_calc_pll(dev, 0x004020, &pll, perflvl->memory,\r\n&N1, &M1, &N2, &M2, &log2P);\r\nif (ret < 0)\r\ngoto out;\r\ninfo->mpll_ctrl = 0x80000000 | (log2P << 16);\r\ninfo->mpll_ctrl |= min2(pll.bias_p + log2P, pll.max_p) << 20;\r\nif (N2 == M2) {\r\ninfo->mpll_ctrl |= 0x00000100;\r\ninfo->mpll_coef = (N1 << 8) | M1;\r\n} else {\r\ninfo->mpll_ctrl |= 0x40000000;\r\ninfo->mpll_coef = (N2 << 24) | (M2 << 16) | (N1 << 8) | M1;\r\n}\r\nout:\r\nif (ret < 0) {\r\nkfree(info);\r\ninfo = ERR_PTR(ret);\r\n}\r\nreturn info;\r\n}\r\nstatic bool\r\nnv40_pm_gr_idle(void *data)\r\n{\r\nstruct drm_device *dev = data;\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nif ((nv_rd32(device, 0x400760) & 0x000000f0) >> 4 !=\r\n(nv_rd32(device, 0x400760) & 0x0000000f))\r\nreturn false;\r\nif (nv_rd32(device, 0x400700))\r\nreturn false;\r\nreturn true;\r\n}\r\nint\r\nnv40_pm_clocks_set(struct drm_device *dev, void *pre_state)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nstruct nouveau_fifo *pfifo = nouveau_fifo(device);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nv40_pm_state *info = pre_state;\r\nunsigned long flags;\r\nstruct bit_entry M;\r\nu32 crtc_mask = 0;\r\nu8 sr1[2];\r\nint i, ret = -EAGAIN;\r\nfor (i = 0; i < 2; i++) {\r\nu32 vbl = nv_rd32(device, 0x600808 + (i * 0x2000));\r\nu32 cnt = 0;\r\ndo {\r\nif (vbl != nv_rd32(device, 0x600808 + (i * 0x2000))) {\r\nnv_wr08(device, 0x0c03c4 + (i * 0x2000), 0x01);\r\nsr1[i] = nv_rd08(device, 0x0c03c5 + (i * 0x2000));\r\nif (!(sr1[i] & 0x20))\r\ncrtc_mask |= (1 << i);\r\nbreak;\r\n}\r\nudelay(1);\r\n} while (cnt++ < 32);\r\n}\r\npfifo->pause(pfifo, &flags);\r\nif (!nv_wait_cb(device, nv40_pm_gr_idle, dev))\r\ngoto resume;\r\nret = 0;\r\nnv_mask(device, 0x00c040, 0x00000333, 0x00000000);\r\nnv_wr32(device, 0x004004, info->npll_coef);\r\nnv_mask(device, 0x004000, 0xc0070100, info->npll_ctrl);\r\nnv_mask(device, 0x004008, 0xc007ffff, info->spll);\r\nmdelay(5);\r\nnv_mask(device, 0x00c040, 0x00000333, info->ctrl);\r\nif (!info->mpll_ctrl)\r\ngoto resume;\r\nfor (i = 0; i < 2; i++) {\r\nif (!(crtc_mask & (1 << i)))\r\ncontinue;\r\nnv_wait(device, 0x600808 + (i * 0x2000), 0x00010000, 0x00000000);\r\nnv_wait(device, 0x600808 + (i * 0x2000), 0x00010000, 0x00010000);\r\nnv_wr08(device, 0x0c03c4 + (i * 0x2000), 0x01);\r\nnv_wr08(device, 0x0c03c5 + (i * 0x2000), sr1[i] | 0x20);\r\n}\r\nnv_wr32(device, 0x1002d4, 0x00000001);\r\nnv_wr32(device, 0x1002d0, 0x00000001);\r\nnv_wr32(device, 0x1002d0, 0x00000001);\r\nnv_mask(device, 0x100210, 0x80000000, 0x00000000);\r\nnv_wr32(device, 0x1002dc, 0x00000001);\r\nnv_mask(device, 0x00c040, 0x0000c000, 0x00000000);\r\nswitch (nv_device(drm->device)->chipset) {\r\ncase 0x40:\r\ncase 0x45:\r\ncase 0x41:\r\ncase 0x42:\r\ncase 0x47:\r\nnv_mask(device, 0x004044, 0xc0771100, info->mpll_ctrl);\r\nnv_mask(device, 0x00402c, 0xc0771100, info->mpll_ctrl);\r\nnv_wr32(device, 0x004048, info->mpll_coef);\r\nnv_wr32(device, 0x004030, info->mpll_coef);\r\ncase 0x43:\r\ncase 0x49:\r\ncase 0x4b:\r\nnv_mask(device, 0x004038, 0xc0771100, info->mpll_ctrl);\r\nnv_wr32(device, 0x00403c, info->mpll_coef);\r\ndefault:\r\nnv_mask(device, 0x004020, 0xc0771100, info->mpll_ctrl);\r\nnv_wr32(device, 0x004024, info->mpll_coef);\r\nbreak;\r\n}\r\nudelay(100);\r\nnv_mask(device, 0x00c040, 0x0000c000, 0x0000c000);\r\nnv_wr32(device, 0x1002dc, 0x00000000);\r\nnv_mask(device, 0x100210, 0x80000000, 0x80000000);\r\nudelay(100);\r\nif (!bit_table(dev, 'M', &M))\r\nnouveau_bios_run_init_table(dev, ROM16(M.data[0]), NULL, 0);\r\nfor (i = 0; i < 2; i++) {\r\nif (!(crtc_mask & (1 << i)))\r\ncontinue;\r\nnv_wait(device, 0x600808 + (i * 0x2000), 0x00010000, 0x00010000);\r\nnv_wr08(device, 0x0c03c4 + (i * 0x2000), 0x01);\r\nnv_wr08(device, 0x0c03c5 + (i * 0x2000), sr1[i]);\r\n}\r\nresume:\r\npfifo->start(pfifo, &flags);\r\nkfree(info);\r\nreturn ret;\r\n}
