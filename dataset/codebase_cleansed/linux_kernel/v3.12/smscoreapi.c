char *smscore_translate_msg(enum msg_types msgtype)\r\n{\r\nint i = msgtype - MSG_TYPE_BASE_VAL;\r\nchar *msg;\r\nif (i < 0 || i >= ARRAY_SIZE(siano_msgs))\r\nreturn "Unknown msg type";\r\nmsg = siano_msgs[i];\r\nif (!*msg)\r\nreturn "Unknown msg type";\r\nreturn msg;\r\n}\r\nvoid smscore_set_board_id(struct smscore_device_t *core, int id)\r\n{\r\ncore->board_id = id;\r\n}\r\nint smscore_led_state(struct smscore_device_t *core, int led)\r\n{\r\nif (led >= 0)\r\ncore->led_state = led;\r\nreturn core->led_state;\r\n}\r\nint smscore_get_board_id(struct smscore_device_t *core)\r\n{\r\nreturn core->board_id;\r\n}\r\nstatic struct smscore_registry_entry_t *smscore_find_registry(char *devpath)\r\n{\r\nstruct smscore_registry_entry_t *entry;\r\nstruct list_head *next;\r\nkmutex_lock(&g_smscore_registrylock);\r\nfor (next = g_smscore_registry.next;\r\nnext != &g_smscore_registry;\r\nnext = next->next) {\r\nentry = (struct smscore_registry_entry_t *) next;\r\nif (!strcmp(entry->devpath, devpath)) {\r\nkmutex_unlock(&g_smscore_registrylock);\r\nreturn entry;\r\n}\r\n}\r\nentry = kmalloc(sizeof(struct smscore_registry_entry_t), GFP_KERNEL);\r\nif (entry) {\r\nentry->mode = default_mode;\r\nstrcpy(entry->devpath, devpath);\r\nlist_add(&entry->entry, &g_smscore_registry);\r\n} else\r\nsms_err("failed to create smscore_registry.");\r\nkmutex_unlock(&g_smscore_registrylock);\r\nreturn entry;\r\n}\r\nint smscore_registry_getmode(char *devpath)\r\n{\r\nstruct smscore_registry_entry_t *entry;\r\nentry = smscore_find_registry(devpath);\r\nif (entry)\r\nreturn entry->mode;\r\nelse\r\nsms_err("No registry found.");\r\nreturn default_mode;\r\n}\r\nstatic enum sms_device_type_st smscore_registry_gettype(char *devpath)\r\n{\r\nstruct smscore_registry_entry_t *entry;\r\nentry = smscore_find_registry(devpath);\r\nif (entry)\r\nreturn entry->type;\r\nelse\r\nsms_err("No registry found.");\r\nreturn -EINVAL;\r\n}\r\nstatic void smscore_registry_setmode(char *devpath, int mode)\r\n{\r\nstruct smscore_registry_entry_t *entry;\r\nentry = smscore_find_registry(devpath);\r\nif (entry)\r\nentry->mode = mode;\r\nelse\r\nsms_err("No registry found.");\r\n}\r\nstatic void smscore_registry_settype(char *devpath,\r\nenum sms_device_type_st type)\r\n{\r\nstruct smscore_registry_entry_t *entry;\r\nentry = smscore_find_registry(devpath);\r\nif (entry)\r\nentry->type = type;\r\nelse\r\nsms_err("No registry found.");\r\n}\r\nstatic void list_add_locked(struct list_head *new, struct list_head *head,\r\nspinlock_t *lock)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(lock, flags);\r\nlist_add(new, head);\r\nspin_unlock_irqrestore(lock, flags);\r\n}\r\nint smscore_register_hotplug(hotplug_t hotplug)\r\n{\r\nstruct smscore_device_notifyee_t *notifyee;\r\nstruct list_head *next, *first;\r\nint rc = 0;\r\nkmutex_lock(&g_smscore_deviceslock);\r\nnotifyee = kmalloc(sizeof(struct smscore_device_notifyee_t),\r\nGFP_KERNEL);\r\nif (notifyee) {\r\nfirst = &g_smscore_devices;\r\nfor (next = first->next;\r\nnext != first && !rc;\r\nnext = next->next) {\r\nstruct smscore_device_t *coredev =\r\n(struct smscore_device_t *) next;\r\nrc = hotplug(coredev, coredev->device, 1);\r\n}\r\nif (rc >= 0) {\r\nnotifyee->hotplug = hotplug;\r\nlist_add(&notifyee->entry, &g_smscore_notifyees);\r\n} else\r\nkfree(notifyee);\r\n} else\r\nrc = -ENOMEM;\r\nkmutex_unlock(&g_smscore_deviceslock);\r\nreturn rc;\r\n}\r\nvoid smscore_unregister_hotplug(hotplug_t hotplug)\r\n{\r\nstruct list_head *next, *first;\r\nkmutex_lock(&g_smscore_deviceslock);\r\nfirst = &g_smscore_notifyees;\r\nfor (next = first->next; next != first;) {\r\nstruct smscore_device_notifyee_t *notifyee =\r\n(struct smscore_device_notifyee_t *) next;\r\nnext = next->next;\r\nif (notifyee->hotplug == hotplug) {\r\nlist_del(&notifyee->entry);\r\nkfree(notifyee);\r\n}\r\n}\r\nkmutex_unlock(&g_smscore_deviceslock);\r\n}\r\nstatic void smscore_notify_clients(struct smscore_device_t *coredev)\r\n{\r\nstruct smscore_client_t *client;\r\nwhile (!list_empty(&coredev->clients)) {\r\nclient = (struct smscore_client_t *) coredev->clients.next;\r\nclient->onremove_handler(client->context);\r\n}\r\n}\r\nstatic int smscore_notify_callbacks(struct smscore_device_t *coredev,\r\nstruct device *device, int arrival)\r\n{\r\nstruct smscore_device_notifyee_t *elem;\r\nint rc = 0;\r\nlist_for_each_entry(elem, &g_smscore_notifyees, entry) {\r\nrc = elem->hotplug(coredev, device, arrival);\r\nif (rc < 0)\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic struct\r\nsmscore_buffer_t *smscore_createbuffer(u8 *buffer, void *common_buffer,\r\ndma_addr_t common_buffer_phys)\r\n{\r\nstruct smscore_buffer_t *cb;\r\ncb = kzalloc(sizeof(struct smscore_buffer_t), GFP_KERNEL);\r\nif (!cb) {\r\nsms_info("kzalloc(...) failed");\r\nreturn NULL;\r\n}\r\ncb->p = buffer;\r\ncb->offset_in_common = buffer - (u8 *) common_buffer;\r\ncb->phys = common_buffer_phys + cb->offset_in_common;\r\nreturn cb;\r\n}\r\nint smscore_register_device(struct smsdevice_params_t *params,\r\nstruct smscore_device_t **coredev)\r\n{\r\nstruct smscore_device_t *dev;\r\nu8 *buffer;\r\ndev = kzalloc(sizeof(struct smscore_device_t), GFP_KERNEL);\r\nif (!dev) {\r\nsms_info("kzalloc(...) failed");\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&dev->entry);\r\nINIT_LIST_HEAD(&dev->clients);\r\nINIT_LIST_HEAD(&dev->buffers);\r\nspin_lock_init(&dev->clientslock);\r\nspin_lock_init(&dev->bufferslock);\r\ninit_completion(&dev->version_ex_done);\r\ninit_completion(&dev->data_download_done);\r\ninit_completion(&dev->data_validity_done);\r\ninit_completion(&dev->trigger_done);\r\ninit_completion(&dev->init_device_done);\r\ninit_completion(&dev->reload_start_done);\r\ninit_completion(&dev->resume_done);\r\ninit_completion(&dev->gpio_configuration_done);\r\ninit_completion(&dev->gpio_set_level_done);\r\ninit_completion(&dev->gpio_get_level_done);\r\ninit_completion(&dev->ir_init_done);\r\ninit_waitqueue_head(&dev->buffer_mng_waitq);\r\ndev->common_buffer_size = params->buffer_size * params->num_buffers;\r\ndev->common_buffer = dma_alloc_coherent(NULL, dev->common_buffer_size,\r\n&dev->common_buffer_phys,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!dev->common_buffer) {\r\nsmscore_unregister_device(dev);\r\nreturn -ENOMEM;\r\n}\r\nfor (buffer = dev->common_buffer;\r\ndev->num_buffers < params->num_buffers;\r\ndev->num_buffers++, buffer += params->buffer_size) {\r\nstruct smscore_buffer_t *cb;\r\ncb = smscore_createbuffer(buffer, dev->common_buffer,\r\ndev->common_buffer_phys);\r\nif (!cb) {\r\nsmscore_unregister_device(dev);\r\nreturn -ENOMEM;\r\n}\r\nsmscore_putbuffer(dev, cb);\r\n}\r\nsms_info("allocated %d buffers", dev->num_buffers);\r\ndev->mode = DEVICE_MODE_NONE;\r\ndev->board_id = SMS_BOARD_UNKNOWN;\r\ndev->context = params->context;\r\ndev->device = params->device;\r\ndev->setmode_handler = params->setmode_handler;\r\ndev->detectmode_handler = params->detectmode_handler;\r\ndev->sendrequest_handler = params->sendrequest_handler;\r\ndev->preload_handler = params->preload_handler;\r\ndev->postload_handler = params->postload_handler;\r\ndev->device_flags = params->flags;\r\nstrcpy(dev->devpath, params->devpath);\r\nsmscore_registry_settype(dev->devpath, params->device_type);\r\nkmutex_lock(&g_smscore_deviceslock);\r\nlist_add(&dev->entry, &g_smscore_devices);\r\nkmutex_unlock(&g_smscore_deviceslock);\r\n*coredev = dev;\r\nsms_info("device %p created", dev);\r\nreturn 0;\r\n}\r\nstatic int smscore_sendrequest_and_wait(struct smscore_device_t *coredev,\r\nvoid *buffer, size_t size, struct completion *completion) {\r\nint rc;\r\nif (completion == NULL)\r\nreturn -EINVAL;\r\ninit_completion(completion);\r\nrc = coredev->sendrequest_handler(coredev->context, buffer, size);\r\nif (rc < 0) {\r\nsms_info("sendrequest returned error %d", rc);\r\nreturn rc;\r\n}\r\nreturn wait_for_completion_timeout(completion,\r\nmsecs_to_jiffies(SMS_PROTOCOL_MAX_RAOUNDTRIP_MS)) ?\r\n0 : -ETIME;\r\n}\r\nstatic int smscore_init_ir(struct smscore_device_t *coredev)\r\n{\r\nint ir_io;\r\nint rc;\r\nvoid *buffer;\r\ncoredev->ir.dev = NULL;\r\nir_io = sms_get_board(smscore_get_board_id(coredev))->board_cfg.ir;\r\nif (ir_io) {\r\nsms_info("IR loading");\r\nrc = sms_ir_init(coredev);\r\nif (rc != 0)\r\nsms_err("Error initialization DTV IR sub-module");\r\nelse {\r\nbuffer = kmalloc(sizeof(struct sms_msg_data2) +\r\nSMS_DMA_ALIGNMENT,\r\nGFP_KERNEL | GFP_DMA);\r\nif (buffer) {\r\nstruct sms_msg_data2 *msg =\r\n(struct sms_msg_data2 *)\r\nSMS_ALIGN_ADDRESS(buffer);\r\nSMS_INIT_MSG(&msg->x_msg_header,\r\nMSG_SMS_START_IR_REQ,\r\nsizeof(struct sms_msg_data2));\r\nmsg->msg_data[0] = coredev->ir.controller;\r\nmsg->msg_data[1] = coredev->ir.timeout;\r\nrc = smscore_sendrequest_and_wait(coredev, msg,\r\nmsg->x_msg_header. msg_length,\r\n&coredev->ir_init_done);\r\nkfree(buffer);\r\n} else\r\nsms_err\r\n("Sending IR initialization message failed");\r\n}\r\n} else\r\nsms_info("IR port has not been detected");\r\nreturn 0;\r\n}\r\nstatic int smscore_configure_board(struct smscore_device_t *coredev)\r\n{\r\nstruct sms_board *board;\r\nboard = sms_get_board(coredev->board_id);\r\nif (!board) {\r\nsms_err("no board configuration exist.");\r\nreturn -EINVAL;\r\n}\r\nif (board->mtu) {\r\nstruct sms_msg_data mtu_msg;\r\nsms_debug("set max transmit unit %d", board->mtu);\r\nmtu_msg.x_msg_header.msg_src_id = 0;\r\nmtu_msg.x_msg_header.msg_dst_id = HIF_TASK;\r\nmtu_msg.x_msg_header.msg_flags = 0;\r\nmtu_msg.x_msg_header.msg_type = MSG_SMS_SET_MAX_TX_MSG_LEN_REQ;\r\nmtu_msg.x_msg_header.msg_length = sizeof(mtu_msg);\r\nmtu_msg.msg_data[0] = board->mtu;\r\ncoredev->sendrequest_handler(coredev->context, &mtu_msg,\r\nsizeof(mtu_msg));\r\n}\r\nif (board->crystal) {\r\nstruct sms_msg_data crys_msg;\r\nsms_debug("set crystal value %d", board->crystal);\r\nSMS_INIT_MSG(&crys_msg.x_msg_header,\r\nMSG_SMS_NEW_CRYSTAL_REQ,\r\nsizeof(crys_msg));\r\ncrys_msg.msg_data[0] = board->crystal;\r\ncoredev->sendrequest_handler(coredev->context, &crys_msg,\r\nsizeof(crys_msg));\r\n}\r\nreturn 0;\r\n}\r\nint smscore_start_device(struct smscore_device_t *coredev)\r\n{\r\nint rc;\r\nint board_id = smscore_get_board_id(coredev);\r\nint mode = smscore_registry_getmode(coredev->devpath);\r\nif (board_id != SMS_BOARD_UNKNOWN && mode == DEVICE_MODE_NONE)\r\nmode = sms_get_board(board_id)->default_mode;\r\nrc = smscore_set_device_mode(coredev, mode);\r\nif (rc < 0) {\r\nsms_info("set device mode faile , rc %d", rc);\r\nreturn rc;\r\n}\r\nrc = smscore_configure_board(coredev);\r\nif (rc < 0) {\r\nsms_info("configure board failed , rc %d", rc);\r\nreturn rc;\r\n}\r\nkmutex_lock(&g_smscore_deviceslock);\r\nrc = smscore_notify_callbacks(coredev, coredev->device, 1);\r\nsmscore_init_ir(coredev);\r\nsms_info("device %p started, rc %d", coredev, rc);\r\nkmutex_unlock(&g_smscore_deviceslock);\r\nreturn rc;\r\n}\r\nstatic int smscore_load_firmware_family2(struct smscore_device_t *coredev,\r\nvoid *buffer, size_t size)\r\n{\r\nstruct sms_firmware *firmware = (struct sms_firmware *) buffer;\r\nstruct sms_msg_data4 *msg;\r\nu32 mem_address, calc_checksum = 0;\r\nu32 i, *ptr;\r\nu8 *payload = firmware->payload;\r\nint rc = 0;\r\nfirmware->start_address = le32_to_cpu(firmware->start_address);\r\nfirmware->length = le32_to_cpu(firmware->length);\r\nmem_address = firmware->start_address;\r\nsms_info("loading FW to addr 0x%x size %d",\r\nmem_address, firmware->length);\r\nif (coredev->preload_handler) {\r\nrc = coredev->preload_handler(coredev->context);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nmsg = kmalloc(PAGE_SIZE, GFP_KERNEL | GFP_DMA);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nif (coredev->mode != DEVICE_MODE_NONE) {\r\nsms_debug("sending reload command.");\r\nSMS_INIT_MSG(&msg->x_msg_header, MSG_SW_RELOAD_START_REQ,\r\nsizeof(struct sms_msg_hdr));\r\nrc = smscore_sendrequest_and_wait(coredev, msg,\r\nmsg->x_msg_header.msg_length,\r\n&coredev->reload_start_done);\r\nif (rc < 0) {\r\nsms_err("device reload failed, rc %d", rc);\r\ngoto exit_fw_download;\r\n}\r\nmem_address = *(u32 *) &payload[20];\r\n}\r\nfor (i = 0, ptr = (u32 *)firmware->payload; i < firmware->length/4 ;\r\ni++, ptr++)\r\ncalc_checksum += *ptr;\r\nwhile (size && rc >= 0) {\r\nstruct sms_data_download *data_msg =\r\n(struct sms_data_download *) msg;\r\nint payload_size = min_t(int, size, SMS_MAX_PAYLOAD_SIZE);\r\nSMS_INIT_MSG(&msg->x_msg_header, MSG_SMS_DATA_DOWNLOAD_REQ,\r\n(u16)(sizeof(struct sms_msg_hdr) +\r\nsizeof(u32) + payload_size));\r\ndata_msg->mem_addr = mem_address;\r\nmemcpy(data_msg->payload, payload, payload_size);\r\nrc = smscore_sendrequest_and_wait(coredev, data_msg,\r\ndata_msg->x_msg_header.msg_length,\r\n&coredev->data_download_done);\r\npayload += payload_size;\r\nsize -= payload_size;\r\nmem_address += payload_size;\r\n}\r\nif (rc < 0)\r\ngoto exit_fw_download;\r\nsms_err("sending MSG_SMS_DATA_VALIDITY_REQ expecting 0x%x",\r\ncalc_checksum);\r\nSMS_INIT_MSG(&msg->x_msg_header, MSG_SMS_DATA_VALIDITY_REQ,\r\nsizeof(msg->x_msg_header) +\r\nsizeof(u32) * 3);\r\nmsg->msg_data[0] = firmware->start_address;\r\nmsg->msg_data[1] = firmware->length;\r\nmsg->msg_data[2] = 0;\r\nrc = smscore_sendrequest_and_wait(coredev, msg,\r\nmsg->x_msg_header.msg_length,\r\n&coredev->data_validity_done);\r\nif (rc < 0)\r\ngoto exit_fw_download;\r\nif (coredev->mode == DEVICE_MODE_NONE) {\r\nstruct sms_msg_data *trigger_msg =\r\n(struct sms_msg_data *) msg;\r\nsms_debug("sending MSG_SMS_SWDOWNLOAD_TRIGGER_REQ");\r\nSMS_INIT_MSG(&msg->x_msg_header,\r\nMSG_SMS_SWDOWNLOAD_TRIGGER_REQ,\r\nsizeof(struct sms_msg_hdr) +\r\nsizeof(u32) * 5);\r\ntrigger_msg->msg_data[0] = firmware->start_address;\r\ntrigger_msg->msg_data[1] = 6;\r\ntrigger_msg->msg_data[2] = 0x200;\r\ntrigger_msg->msg_data[3] = 0;\r\ntrigger_msg->msg_data[4] = 4;\r\nrc = smscore_sendrequest_and_wait(coredev, trigger_msg,\r\ntrigger_msg->x_msg_header.msg_length,\r\n&coredev->trigger_done);\r\n} else {\r\nSMS_INIT_MSG(&msg->x_msg_header, MSG_SW_RELOAD_EXEC_REQ,\r\nsizeof(struct sms_msg_hdr));\r\nrc = coredev->sendrequest_handler(coredev->context, msg,\r\nmsg->x_msg_header.msg_length);\r\n}\r\nif (rc < 0)\r\ngoto exit_fw_download;\r\nmsleep(400);\r\nexit_fw_download:\r\nkfree(msg);\r\nif (coredev->postload_handler) {\r\nsms_debug("rc=%d, postload=0x%p", rc, coredev->postload_handler);\r\nif (rc >= 0)\r\nreturn coredev->postload_handler(coredev->context);\r\n}\r\nsms_debug("rc=%d", rc);\r\nreturn rc;\r\n}\r\nstatic char *smscore_get_fw_filename(struct smscore_device_t *coredev,\r\nint mode)\r\n{\r\nchar **fw;\r\nint board_id = smscore_get_board_id(coredev);\r\nenum sms_device_type_st type;\r\ntype = smscore_registry_gettype(coredev->devpath);\r\nif (type <= SMS_UNKNOWN_TYPE || type >= SMS_NUM_OF_DEVICE_TYPES)\r\nreturn NULL;\r\nif (mode <= DEVICE_MODE_NONE || mode >= DEVICE_MODE_MAX)\r\nreturn NULL;\r\nsms_debug("trying to get fw name from sms_boards board_id %d mode %d",\r\nboard_id, mode);\r\nfw = sms_get_board(board_id)->fw;\r\nif (!fw || !fw[mode]) {\r\nsms_debug("cannot find fw name in sms_boards, getting from lookup table mode %d type %d",\r\nmode, type);\r\nreturn smscore_fw_lkup[type][mode];\r\n}\r\nreturn fw[mode];\r\n}\r\nstatic int smscore_load_firmware_from_file(struct smscore_device_t *coredev,\r\nint mode,\r\nloadfirmware_t loadfirmware_handler)\r\n{\r\nint rc = -ENOENT;\r\nu8 *fw_buf;\r\nu32 fw_buf_size;\r\nconst struct firmware *fw;\r\nchar *fw_filename = smscore_get_fw_filename(coredev, mode);\r\nif (!fw_filename) {\r\nsms_err("mode %d not supported on this device", mode);\r\nreturn -ENOENT;\r\n}\r\nsms_debug("Firmware name: %s", fw_filename);\r\nif (loadfirmware_handler == NULL && !(coredev->device_flags\r\n& SMS_DEVICE_FAMILY2))\r\nreturn -EINVAL;\r\nrc = request_firmware(&fw, fw_filename, coredev->device);\r\nif (rc < 0) {\r\nsms_err("failed to open firmware file \"%s\"", fw_filename);\r\nreturn rc;\r\n}\r\nsms_info("read fw %s, buffer size=0x%zx", fw_filename, fw->size);\r\nfw_buf = kmalloc(ALIGN(fw->size, SMS_ALLOC_ALIGNMENT),\r\nGFP_KERNEL | GFP_DMA);\r\nif (!fw_buf) {\r\nsms_err("failed to allocate firmware buffer");\r\nrc = -ENOMEM;\r\n} else {\r\nmemcpy(fw_buf, fw->data, fw->size);\r\nfw_buf_size = fw->size;\r\nrc = (coredev->device_flags & SMS_DEVICE_FAMILY2) ?\r\nsmscore_load_firmware_family2(coredev, fw_buf, fw_buf_size)\r\n: loadfirmware_handler(coredev->context, fw_buf,\r\nfw_buf_size);\r\n}\r\nkfree(fw_buf);\r\nrelease_firmware(fw);\r\nreturn rc;\r\n}\r\nvoid smscore_unregister_device(struct smscore_device_t *coredev)\r\n{\r\nstruct smscore_buffer_t *cb;\r\nint num_buffers = 0;\r\nint retry = 0;\r\nkmutex_lock(&g_smscore_deviceslock);\r\nsms_ir_exit(coredev);\r\nsmscore_notify_clients(coredev);\r\nsmscore_notify_callbacks(coredev, NULL, 0);\r\nwhile (1) {\r\nwhile (!list_empty(&coredev->buffers)) {\r\ncb = (struct smscore_buffer_t *) coredev->buffers.next;\r\nlist_del(&cb->entry);\r\nkfree(cb);\r\nnum_buffers++;\r\n}\r\nif (num_buffers == coredev->num_buffers)\r\nbreak;\r\nif (++retry > 10) {\r\nsms_info("exiting although not all buffers released.");\r\nbreak;\r\n}\r\nsms_info("waiting for %d buffer(s)",\r\ncoredev->num_buffers - num_buffers);\r\nkmutex_unlock(&g_smscore_deviceslock);\r\nmsleep(100);\r\nkmutex_lock(&g_smscore_deviceslock);\r\n}\r\nsms_info("freed %d buffers", num_buffers);\r\nif (coredev->common_buffer)\r\ndma_free_coherent(NULL, coredev->common_buffer_size,\r\ncoredev->common_buffer, coredev->common_buffer_phys);\r\nkfree(coredev->fw_buf);\r\nlist_del(&coredev->entry);\r\nkfree(coredev);\r\nkmutex_unlock(&g_smscore_deviceslock);\r\nsms_info("device %p destroyed", coredev);\r\n}\r\nstatic int smscore_detect_mode(struct smscore_device_t *coredev)\r\n{\r\nvoid *buffer = kmalloc(sizeof(struct sms_msg_hdr) + SMS_DMA_ALIGNMENT,\r\nGFP_KERNEL | GFP_DMA);\r\nstruct sms_msg_hdr *msg =\r\n(struct sms_msg_hdr *) SMS_ALIGN_ADDRESS(buffer);\r\nint rc;\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nSMS_INIT_MSG(msg, MSG_SMS_GET_VERSION_EX_REQ,\r\nsizeof(struct sms_msg_hdr));\r\nrc = smscore_sendrequest_and_wait(coredev, msg, msg->msg_length,\r\n&coredev->version_ex_done);\r\nif (rc == -ETIME) {\r\nsms_err("MSG_SMS_GET_VERSION_EX_REQ failed first try");\r\nif (wait_for_completion_timeout(&coredev->resume_done,\r\nmsecs_to_jiffies(5000))) {\r\nrc = smscore_sendrequest_and_wait(\r\ncoredev, msg, msg->msg_length,\r\n&coredev->version_ex_done);\r\nif (rc < 0)\r\nsms_err("MSG_SMS_GET_VERSION_EX_REQ failed second try, rc %d",\r\nrc);\r\n} else\r\nrc = -ETIME;\r\n}\r\nkfree(buffer);\r\nreturn rc;\r\n}\r\nstatic int smscore_init_device(struct smscore_device_t *coredev, int mode)\r\n{\r\nvoid *buffer;\r\nstruct sms_msg_data *msg;\r\nint rc = 0;\r\nbuffer = kmalloc(sizeof(struct sms_msg_data) +\r\nSMS_DMA_ALIGNMENT, GFP_KERNEL | GFP_DMA);\r\nif (!buffer) {\r\nsms_err("Could not allocate buffer for init device message.");\r\nreturn -ENOMEM;\r\n}\r\nmsg = (struct sms_msg_data *)SMS_ALIGN_ADDRESS(buffer);\r\nSMS_INIT_MSG(&msg->x_msg_header, MSG_SMS_INIT_DEVICE_REQ,\r\nsizeof(struct sms_msg_data));\r\nmsg->msg_data[0] = mode;\r\nrc = smscore_sendrequest_and_wait(coredev, msg,\r\nmsg->x_msg_header. msg_length,\r\n&coredev->init_device_done);\r\nkfree(buffer);\r\nreturn rc;\r\n}\r\nint smscore_set_device_mode(struct smscore_device_t *coredev, int mode)\r\n{\r\nint rc = 0;\r\nsms_debug("set device mode to %d", mode);\r\nif (coredev->device_flags & SMS_DEVICE_FAMILY2) {\r\nif (mode <= DEVICE_MODE_NONE || mode >= DEVICE_MODE_MAX) {\r\nsms_err("invalid mode specified %d", mode);\r\nreturn -EINVAL;\r\n}\r\nsmscore_registry_setmode(coredev->devpath, mode);\r\nif (!(coredev->device_flags & SMS_DEVICE_NOT_READY)) {\r\nrc = smscore_detect_mode(coredev);\r\nif (rc < 0) {\r\nsms_err("mode detect failed %d", rc);\r\nreturn rc;\r\n}\r\n}\r\nif (coredev->mode == mode) {\r\nsms_info("device mode %d already set", mode);\r\nreturn 0;\r\n}\r\nif (!(coredev->modes_supported & (1 << mode))) {\r\nrc = smscore_load_firmware_from_file(coredev,\r\nmode, NULL);\r\nif (rc >= 0)\r\nsms_info("firmware download success");\r\n} else {\r\nsms_info("mode %d is already supported by running firmware",\r\nmode);\r\n}\r\nif (coredev->fw_version >= 0x800) {\r\nrc = smscore_init_device(coredev, mode);\r\nif (rc < 0)\r\nsms_err("device init failed, rc %d.", rc);\r\n}\r\n} else {\r\nif (mode <= DEVICE_MODE_NONE || mode >= DEVICE_MODE_MAX) {\r\nsms_err("invalid mode specified %d", mode);\r\nreturn -EINVAL;\r\n}\r\nsmscore_registry_setmode(coredev->devpath, mode);\r\nif (coredev->detectmode_handler)\r\ncoredev->detectmode_handler(coredev->context,\r\n&coredev->mode);\r\nif (coredev->mode != mode && coredev->setmode_handler)\r\nrc = coredev->setmode_handler(coredev->context, mode);\r\n}\r\nif (rc >= 0) {\r\nchar *buffer;\r\ncoredev->mode = mode;\r\ncoredev->device_flags &= ~SMS_DEVICE_NOT_READY;\r\nbuffer = kmalloc(sizeof(struct sms_msg_data) +\r\nSMS_DMA_ALIGNMENT, GFP_KERNEL | GFP_DMA);\r\nif (buffer) {\r\nstruct sms_msg_data *msg = (struct sms_msg_data *) SMS_ALIGN_ADDRESS(buffer);\r\nSMS_INIT_MSG(&msg->x_msg_header, MSG_SMS_INIT_DEVICE_REQ,\r\nsizeof(struct sms_msg_data));\r\nmsg->msg_data[0] = mode;\r\nrc = smscore_sendrequest_and_wait(\r\ncoredev, msg, msg->x_msg_header.msg_length,\r\n&coredev->init_device_done);\r\nkfree(buffer);\r\n}\r\n}\r\nif (rc < 0)\r\nsms_err("return error code %d.", rc);\r\nelse\r\nsms_debug("Success setting device mode.");\r\nreturn rc;\r\n}\r\nint smscore_get_device_mode(struct smscore_device_t *coredev)\r\n{\r\nreturn coredev->mode;\r\n}\r\nstatic struct\r\nsmscore_client_t *smscore_find_client(struct smscore_device_t *coredev,\r\nint data_type, int id)\r\n{\r\nstruct list_head *first;\r\nstruct smscore_client_t *client;\r\nunsigned long flags;\r\nstruct list_head *firstid;\r\nstruct smscore_idlist_t *client_id;\r\nspin_lock_irqsave(&coredev->clientslock, flags);\r\nfirst = &coredev->clients;\r\nlist_for_each_entry(client, first, entry) {\r\nfirstid = &client->idlist;\r\nlist_for_each_entry(client_id, firstid, entry) {\r\nif ((client_id->id == id) &&\r\n(client_id->data_type == data_type ||\r\n(client_id->data_type == 0)))\r\ngoto found;\r\n}\r\n}\r\nclient = NULL;\r\nfound:\r\nspin_unlock_irqrestore(&coredev->clientslock, flags);\r\nreturn client;\r\n}\r\nvoid smscore_onresponse(struct smscore_device_t *coredev,\r\nstruct smscore_buffer_t *cb) {\r\nstruct sms_msg_hdr *phdr = (struct sms_msg_hdr *) ((u8 *) cb->p\r\n+ cb->offset);\r\nstruct smscore_client_t *client;\r\nint rc = -EBUSY;\r\nstatic unsigned long last_sample_time;\r\nstatic int data_total;\r\nunsigned long time_now = jiffies_to_msecs(jiffies);\r\nif (!last_sample_time)\r\nlast_sample_time = time_now;\r\nif (time_now - last_sample_time > 10000) {\r\nsms_debug("data rate %d bytes/secs",\r\n(int)((data_total * 1000) /\r\n(time_now - last_sample_time)));\r\nlast_sample_time = time_now;\r\ndata_total = 0;\r\n}\r\ndata_total += cb->size;\r\nif ((phdr->msg_type == MSG_SMS_HO_PER_SLICES_IND) ||\r\n(phdr->msg_type == MSG_SMS_TRANSMISSION_IND)) {\r\nif (coredev->mode == DEVICE_MODE_DVBT_BDA)\r\nphdr->msg_dst_id = DVBT_BDA_CONTROL_MSG_ID;\r\n}\r\nclient = smscore_find_client(coredev, phdr->msg_type, phdr->msg_dst_id);\r\nif (client)\r\nrc = client->onresponse_handler(client->context, cb);\r\nif (rc < 0) {\r\nswitch (phdr->msg_type) {\r\ncase MSG_SMS_ISDBT_TUNE_RES:\r\nbreak;\r\ncase MSG_SMS_RF_TUNE_RES:\r\nbreak;\r\ncase MSG_SMS_SIGNAL_DETECTED_IND:\r\nbreak;\r\ncase MSG_SMS_NO_SIGNAL_IND:\r\nbreak;\r\ncase MSG_SMS_SPI_INT_LINE_SET_RES:\r\nbreak;\r\ncase MSG_SMS_INTERFACE_LOCK_IND:\r\nbreak;\r\ncase MSG_SMS_INTERFACE_UNLOCK_IND:\r\nbreak;\r\ncase MSG_SMS_GET_VERSION_EX_RES:\r\n{\r\nstruct sms_version_res *ver =\r\n(struct sms_version_res *) phdr;\r\nsms_debug("Firmware id %d prots 0x%x ver %d.%d",\r\nver->firmware_id, ver->supported_protocols,\r\nver->rom_ver_major, ver->rom_ver_minor);\r\ncoredev->mode = ver->firmware_id == 255 ?\r\nDEVICE_MODE_NONE : ver->firmware_id;\r\ncoredev->modes_supported = ver->supported_protocols;\r\ncoredev->fw_version = ver->rom_ver_major << 8 |\r\nver->rom_ver_minor;\r\ncomplete(&coredev->version_ex_done);\r\nbreak;\r\n}\r\ncase MSG_SMS_INIT_DEVICE_RES:\r\ncomplete(&coredev->init_device_done);\r\nbreak;\r\ncase MSG_SW_RELOAD_START_RES:\r\ncomplete(&coredev->reload_start_done);\r\nbreak;\r\ncase MSG_SMS_DATA_VALIDITY_RES:\r\n{\r\nstruct sms_msg_data *validity = (struct sms_msg_data *) phdr;\r\nsms_err("MSG_SMS_DATA_VALIDITY_RES, checksum = 0x%x",\r\nvalidity->msg_data[0]);\r\ncomplete(&coredev->data_validity_done);\r\nbreak;\r\n}\r\ncase MSG_SMS_DATA_DOWNLOAD_RES:\r\ncomplete(&coredev->data_download_done);\r\nbreak;\r\ncase MSG_SW_RELOAD_EXEC_RES:\r\nbreak;\r\ncase MSG_SMS_SWDOWNLOAD_TRIGGER_RES:\r\ncomplete(&coredev->trigger_done);\r\nbreak;\r\ncase MSG_SMS_SLEEP_RESUME_COMP_IND:\r\ncomplete(&coredev->resume_done);\r\nbreak;\r\ncase MSG_SMS_GPIO_CONFIG_EX_RES:\r\ncomplete(&coredev->gpio_configuration_done);\r\nbreak;\r\ncase MSG_SMS_GPIO_SET_LEVEL_RES:\r\ncomplete(&coredev->gpio_set_level_done);\r\nbreak;\r\ncase MSG_SMS_GPIO_GET_LEVEL_RES:\r\n{\r\nu32 *msgdata = (u32 *) phdr;\r\ncoredev->gpio_get_res = msgdata[1];\r\nsms_debug("gpio level %d",\r\ncoredev->gpio_get_res);\r\ncomplete(&coredev->gpio_get_level_done);\r\nbreak;\r\n}\r\ncase MSG_SMS_START_IR_RES:\r\ncomplete(&coredev->ir_init_done);\r\nbreak;\r\ncase MSG_SMS_IR_SAMPLES_IND:\r\nsms_ir_event(coredev,\r\n(const char *)\r\n((char *)phdr\r\n+ sizeof(struct sms_msg_hdr)),\r\n(int)phdr->msg_length\r\n- sizeof(struct sms_msg_hdr));\r\nbreak;\r\ncase MSG_SMS_DVBT_BDA_DATA:\r\nbreak;\r\ndefault:\r\nsms_debug("message %s(%d) not handled.",\r\nsmscore_translate_msg(phdr->msg_type),\r\nphdr->msg_type);\r\nbreak;\r\n}\r\nsmscore_putbuffer(coredev, cb);\r\n}\r\n}\r\nstatic struct smscore_buffer_t *get_entry(struct smscore_device_t *coredev)\r\n{\r\nstruct smscore_buffer_t *cb = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&coredev->bufferslock, flags);\r\nif (!list_empty(&coredev->buffers)) {\r\ncb = (struct smscore_buffer_t *) coredev->buffers.next;\r\nlist_del(&cb->entry);\r\n}\r\nspin_unlock_irqrestore(&coredev->bufferslock, flags);\r\nreturn cb;\r\n}\r\nstruct smscore_buffer_t *smscore_getbuffer(struct smscore_device_t *coredev)\r\n{\r\nstruct smscore_buffer_t *cb = NULL;\r\nwait_event(coredev->buffer_mng_waitq, (cb = get_entry(coredev)));\r\nreturn cb;\r\n}\r\nvoid smscore_putbuffer(struct smscore_device_t *coredev,\r\nstruct smscore_buffer_t *cb) {\r\nwake_up_interruptible(&coredev->buffer_mng_waitq);\r\nlist_add_locked(&cb->entry, &coredev->buffers, &coredev->bufferslock);\r\n}\r\nstatic int smscore_validate_client(struct smscore_device_t *coredev,\r\nstruct smscore_client_t *client,\r\nint data_type, int id)\r\n{\r\nstruct smscore_idlist_t *listentry;\r\nstruct smscore_client_t *registered_client;\r\nif (!client) {\r\nsms_err("bad parameter.");\r\nreturn -EINVAL;\r\n}\r\nregistered_client = smscore_find_client(coredev, data_type, id);\r\nif (registered_client == client)\r\nreturn 0;\r\nif (registered_client) {\r\nsms_err("The msg ID already registered to another client.");\r\nreturn -EEXIST;\r\n}\r\nlistentry = kzalloc(sizeof(struct smscore_idlist_t), GFP_KERNEL);\r\nif (!listentry) {\r\nsms_err("Can't allocate memory for client id.");\r\nreturn -ENOMEM;\r\n}\r\nlistentry->id = id;\r\nlistentry->data_type = data_type;\r\nlist_add_locked(&listentry->entry, &client->idlist,\r\n&coredev->clientslock);\r\nreturn 0;\r\n}\r\nint smscore_register_client(struct smscore_device_t *coredev,\r\nstruct smsclient_params_t *params,\r\nstruct smscore_client_t **client)\r\n{\r\nstruct smscore_client_t *newclient;\r\nif (smscore_find_client(coredev, params->data_type,\r\nparams->initial_id)) {\r\nsms_err("Client already exist.");\r\nreturn -EEXIST;\r\n}\r\nnewclient = kzalloc(sizeof(struct smscore_client_t), GFP_KERNEL);\r\nif (!newclient) {\r\nsms_err("Failed to allocate memory for client.");\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&newclient->idlist);\r\nnewclient->coredev = coredev;\r\nnewclient->onresponse_handler = params->onresponse_handler;\r\nnewclient->onremove_handler = params->onremove_handler;\r\nnewclient->context = params->context;\r\nlist_add_locked(&newclient->entry, &coredev->clients,\r\n&coredev->clientslock);\r\nsmscore_validate_client(coredev, newclient, params->data_type,\r\nparams->initial_id);\r\n*client = newclient;\r\nsms_debug("%p %d %d", params->context, params->data_type,\r\nparams->initial_id);\r\nreturn 0;\r\n}\r\nvoid smscore_unregister_client(struct smscore_client_t *client)\r\n{\r\nstruct smscore_device_t *coredev = client->coredev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&coredev->clientslock, flags);\r\nwhile (!list_empty(&client->idlist)) {\r\nstruct smscore_idlist_t *identry =\r\n(struct smscore_idlist_t *) client->idlist.next;\r\nlist_del(&identry->entry);\r\nkfree(identry);\r\n}\r\nsms_info("%p", client->context);\r\nlist_del(&client->entry);\r\nkfree(client);\r\nspin_unlock_irqrestore(&coredev->clientslock, flags);\r\n}\r\nint smsclient_sendrequest(struct smscore_client_t *client,\r\nvoid *buffer, size_t size)\r\n{\r\nstruct smscore_device_t *coredev;\r\nstruct sms_msg_hdr *phdr = (struct sms_msg_hdr *) buffer;\r\nint rc;\r\nif (client == NULL) {\r\nsms_err("Got NULL client");\r\nreturn -EINVAL;\r\n}\r\ncoredev = client->coredev;\r\nif (coredev == NULL) {\r\nsms_err("Got NULL coredev");\r\nreturn -EINVAL;\r\n}\r\nrc = smscore_validate_client(client->coredev, client, 0,\r\nphdr->msg_src_id);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn coredev->sendrequest_handler(coredev->context, buffer, size);\r\n}\r\nint smscore_configure_gpio(struct smscore_device_t *coredev, u32 pin,\r\nstruct smscore_config_gpio *pinconfig)\r\n{\r\nstruct {\r\nstruct sms_msg_hdr hdr;\r\nu32 data[6];\r\n} msg;\r\nif (coredev->device_flags & SMS_DEVICE_FAMILY2) {\r\nmsg.hdr.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;\r\nmsg.hdr.msg_dst_id = HIF_TASK;\r\nmsg.hdr.msg_flags = 0;\r\nmsg.hdr.msg_type = MSG_SMS_GPIO_CONFIG_EX_REQ;\r\nmsg.hdr.msg_length = sizeof(msg);\r\nmsg.data[0] = pin;\r\nmsg.data[1] = pinconfig->pullupdown;\r\nmsg.data[2] = pinconfig->outputslewrate == 0 ? 3 : 0;\r\nswitch (pinconfig->outputdriving) {\r\ncase SMS_GPIO_OUTPUTDRIVING_S_16mA:\r\nmsg.data[3] = 7;\r\nbreak;\r\ncase SMS_GPIO_OUTPUTDRIVING_S_12mA:\r\nmsg.data[3] = 5;\r\nbreak;\r\ncase SMS_GPIO_OUTPUTDRIVING_S_8mA:\r\nmsg.data[3] = 3;\r\nbreak;\r\ncase SMS_GPIO_OUTPUTDRIVING_S_4mA:\r\ndefault:\r\nmsg.data[3] = 2;\r\nbreak;\r\n}\r\nmsg.data[4] = pinconfig->direction;\r\nmsg.data[5] = 0;\r\n} else\r\nreturn -EINVAL;\r\nreturn coredev->sendrequest_handler(coredev->context,\r\n&msg, sizeof(msg));\r\n}\r\nint smscore_set_gpio(struct smscore_device_t *coredev, u32 pin, int level)\r\n{\r\nstruct {\r\nstruct sms_msg_hdr hdr;\r\nu32 data[3];\r\n} msg;\r\nif (pin > MAX_GPIO_PIN_NUMBER)\r\nreturn -EINVAL;\r\nmsg.hdr.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;\r\nmsg.hdr.msg_dst_id = HIF_TASK;\r\nmsg.hdr.msg_flags = 0;\r\nmsg.hdr.msg_type = MSG_SMS_GPIO_SET_LEVEL_REQ;\r\nmsg.hdr.msg_length = sizeof(msg);\r\nmsg.data[0] = pin;\r\nmsg.data[1] = level ? 1 : 0;\r\nmsg.data[2] = 0;\r\nreturn coredev->sendrequest_handler(coredev->context,\r\n&msg, sizeof(msg));\r\n}\r\nstatic int get_gpio_pin_params(u32 pin_num, u32 *p_translatedpin_num,\r\nu32 *p_group_num, u32 *p_group_cfg) {\r\n*p_group_cfg = 1;\r\nif (pin_num <= 1) {\r\n*p_translatedpin_num = 0;\r\n*p_group_num = 9;\r\n*p_group_cfg = 2;\r\n} else if (pin_num >= 2 && pin_num <= 6) {\r\n*p_translatedpin_num = 2;\r\n*p_group_num = 0;\r\n*p_group_cfg = 2;\r\n} else if (pin_num >= 7 && pin_num <= 11) {\r\n*p_translatedpin_num = 7;\r\n*p_group_num = 1;\r\n} else if (pin_num >= 12 && pin_num <= 15) {\r\n*p_translatedpin_num = 12;\r\n*p_group_num = 2;\r\n*p_group_cfg = 3;\r\n} else if (pin_num == 16) {\r\n*p_translatedpin_num = 16;\r\n*p_group_num = 23;\r\n} else if (pin_num >= 17 && pin_num <= 24) {\r\n*p_translatedpin_num = 17;\r\n*p_group_num = 3;\r\n} else if (pin_num == 25) {\r\n*p_translatedpin_num = 25;\r\n*p_group_num = 6;\r\n} else if (pin_num >= 26 && pin_num <= 28) {\r\n*p_translatedpin_num = 26;\r\n*p_group_num = 4;\r\n} else if (pin_num == 29) {\r\n*p_translatedpin_num = 29;\r\n*p_group_num = 5;\r\n*p_group_cfg = 2;\r\n} else if (pin_num == 30) {\r\n*p_translatedpin_num = 30;\r\n*p_group_num = 8;\r\n} else if (pin_num == 31) {\r\n*p_translatedpin_num = 31;\r\n*p_group_num = 17;\r\n} else\r\nreturn -1;\r\n*p_group_cfg <<= 24;\r\nreturn 0;\r\n}\r\nint smscore_gpio_configure(struct smscore_device_t *coredev, u8 pin_num,\r\nstruct smscore_config_gpio *p_gpio_config) {\r\nu32 total_len;\r\nu32 translatedpin_num = 0;\r\nu32 group_num = 0;\r\nu32 electric_char;\r\nu32 group_cfg;\r\nvoid *buffer;\r\nint rc;\r\nstruct set_gpio_msg {\r\nstruct sms_msg_hdr x_msg_header;\r\nu32 msg_data[6];\r\n} *p_msg;\r\nif (pin_num > MAX_GPIO_PIN_NUMBER)\r\nreturn -EINVAL;\r\nif (p_gpio_config == NULL)\r\nreturn -EINVAL;\r\ntotal_len = sizeof(struct sms_msg_hdr) + (sizeof(u32) * 6);\r\nbuffer = kmalloc(total_len + SMS_DMA_ALIGNMENT,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\np_msg = (struct set_gpio_msg *) SMS_ALIGN_ADDRESS(buffer);\r\np_msg->x_msg_header.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;\r\np_msg->x_msg_header.msg_dst_id = HIF_TASK;\r\np_msg->x_msg_header.msg_flags = 0;\r\np_msg->x_msg_header.msg_length = (u16) total_len;\r\np_msg->msg_data[0] = pin_num;\r\nif (!(coredev->device_flags & SMS_DEVICE_FAMILY2)) {\r\np_msg->x_msg_header.msg_type = MSG_SMS_GPIO_CONFIG_REQ;\r\nif (get_gpio_pin_params(pin_num, &translatedpin_num, &group_num,\r\n&group_cfg) != 0) {\r\nrc = -EINVAL;\r\ngoto free;\r\n}\r\np_msg->msg_data[1] = translatedpin_num;\r\np_msg->msg_data[2] = group_num;\r\nelectric_char = (p_gpio_config->pullupdown)\r\n| (p_gpio_config->inputcharacteristics << 2)\r\n| (p_gpio_config->outputslewrate << 3)\r\n| (p_gpio_config->outputdriving << 4);\r\np_msg->msg_data[3] = electric_char;\r\np_msg->msg_data[4] = p_gpio_config->direction;\r\np_msg->msg_data[5] = group_cfg;\r\n} else {\r\np_msg->x_msg_header.msg_type = MSG_SMS_GPIO_CONFIG_EX_REQ;\r\np_msg->msg_data[1] = p_gpio_config->pullupdown;\r\np_msg->msg_data[2] = p_gpio_config->outputslewrate;\r\np_msg->msg_data[3] = p_gpio_config->outputdriving;\r\np_msg->msg_data[4] = p_gpio_config->direction;\r\np_msg->msg_data[5] = 0;\r\n}\r\nrc = smscore_sendrequest_and_wait(coredev, p_msg, total_len,\r\n&coredev->gpio_configuration_done);\r\nif (rc != 0) {\r\nif (rc == -ETIME)\r\nsms_err("smscore_gpio_configure timeout");\r\nelse\r\nsms_err("smscore_gpio_configure error");\r\n}\r\nfree:\r\nkfree(buffer);\r\nreturn rc;\r\n}\r\nint smscore_gpio_set_level(struct smscore_device_t *coredev, u8 pin_num,\r\nu8 new_level) {\r\nu32 total_len;\r\nint rc;\r\nvoid *buffer;\r\nstruct set_gpio_msg {\r\nstruct sms_msg_hdr x_msg_header;\r\nu32 msg_data[3];\r\n} *p_msg;\r\nif ((new_level > 1) || (pin_num > MAX_GPIO_PIN_NUMBER))\r\nreturn -EINVAL;\r\ntotal_len = sizeof(struct sms_msg_hdr) +\r\n(3 * sizeof(u32));\r\nbuffer = kmalloc(total_len + SMS_DMA_ALIGNMENT,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\np_msg = (struct set_gpio_msg *) SMS_ALIGN_ADDRESS(buffer);\r\np_msg->x_msg_header.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;\r\np_msg->x_msg_header.msg_dst_id = HIF_TASK;\r\np_msg->x_msg_header.msg_flags = 0;\r\np_msg->x_msg_header.msg_type = MSG_SMS_GPIO_SET_LEVEL_REQ;\r\np_msg->x_msg_header.msg_length = (u16) total_len;\r\np_msg->msg_data[0] = pin_num;\r\np_msg->msg_data[1] = new_level;\r\nrc = smscore_sendrequest_and_wait(coredev, p_msg, total_len,\r\n&coredev->gpio_set_level_done);\r\nif (rc != 0) {\r\nif (rc == -ETIME)\r\nsms_err("smscore_gpio_set_level timeout");\r\nelse\r\nsms_err("smscore_gpio_set_level error");\r\n}\r\nkfree(buffer);\r\nreturn rc;\r\n}\r\nint smscore_gpio_get_level(struct smscore_device_t *coredev, u8 pin_num,\r\nu8 *level) {\r\nu32 total_len;\r\nint rc;\r\nvoid *buffer;\r\nstruct set_gpio_msg {\r\nstruct sms_msg_hdr x_msg_header;\r\nu32 msg_data[2];\r\n} *p_msg;\r\nif (pin_num > MAX_GPIO_PIN_NUMBER)\r\nreturn -EINVAL;\r\ntotal_len = sizeof(struct sms_msg_hdr) + (2 * sizeof(u32));\r\nbuffer = kmalloc(total_len + SMS_DMA_ALIGNMENT,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\np_msg = (struct set_gpio_msg *) SMS_ALIGN_ADDRESS(buffer);\r\np_msg->x_msg_header.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;\r\np_msg->x_msg_header.msg_dst_id = HIF_TASK;\r\np_msg->x_msg_header.msg_flags = 0;\r\np_msg->x_msg_header.msg_type = MSG_SMS_GPIO_GET_LEVEL_REQ;\r\np_msg->x_msg_header.msg_length = (u16) total_len;\r\np_msg->msg_data[0] = pin_num;\r\np_msg->msg_data[1] = 0;\r\nrc = smscore_sendrequest_and_wait(coredev, p_msg, total_len,\r\n&coredev->gpio_get_level_done);\r\nif (rc != 0) {\r\nif (rc == -ETIME)\r\nsms_err("smscore_gpio_get_level timeout");\r\nelse\r\nsms_err("smscore_gpio_get_level error");\r\n}\r\nkfree(buffer);\r\n*level = coredev->gpio_get_res;\r\nreturn rc;\r\n}\r\nstatic int __init smscore_module_init(void)\r\n{\r\nint rc = 0;\r\nINIT_LIST_HEAD(&g_smscore_notifyees);\r\nINIT_LIST_HEAD(&g_smscore_devices);\r\nkmutex_init(&g_smscore_deviceslock);\r\nINIT_LIST_HEAD(&g_smscore_registry);\r\nkmutex_init(&g_smscore_registrylock);\r\nreturn rc;\r\n}\r\nstatic void __exit smscore_module_exit(void)\r\n{\r\nkmutex_lock(&g_smscore_deviceslock);\r\nwhile (!list_empty(&g_smscore_notifyees)) {\r\nstruct smscore_device_notifyee_t *notifyee =\r\n(struct smscore_device_notifyee_t *)\r\ng_smscore_notifyees.next;\r\nlist_del(&notifyee->entry);\r\nkfree(notifyee);\r\n}\r\nkmutex_unlock(&g_smscore_deviceslock);\r\nkmutex_lock(&g_smscore_registrylock);\r\nwhile (!list_empty(&g_smscore_registry)) {\r\nstruct smscore_registry_entry_t *entry =\r\n(struct smscore_registry_entry_t *)\r\ng_smscore_registry.next;\r\nlist_del(&entry->entry);\r\nkfree(entry);\r\n}\r\nkmutex_unlock(&g_smscore_registrylock);\r\nsms_debug("");\r\n}
