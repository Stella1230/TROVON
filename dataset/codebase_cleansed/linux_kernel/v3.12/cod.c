static s32 cod_f_close(struct file *filp)\r\n{\r\nif (!filp)\r\nreturn -EFAULT;\r\nfilp_close(filp, NULL);\r\nreturn 0;\r\n}\r\nstatic struct file *cod_f_open(const char *psz_file_name, const char *sz_mode)\r\n{\r\nmm_segment_t fs;\r\nstruct file *filp;\r\nfs = get_fs();\r\nset_fs(get_ds());\r\nfilp = filp_open(psz_file_name, O_RDONLY, 0);\r\nif (IS_ERR(filp))\r\nfilp = NULL;\r\nset_fs(fs);\r\nreturn filp;\r\n}\r\nstatic s32 cod_f_read(void __user *pbuffer, s32 size, s32 count,\r\nstruct file *filp)\r\n{\r\nif (!filp)\r\nreturn -EFAULT;\r\nif ((size > 0) && (count > 0) && pbuffer) {\r\nu32 dw_bytes_read;\r\nmm_segment_t fs;\r\nfs = get_fs();\r\nset_fs(get_ds());\r\ndw_bytes_read = filp->f_op->read(filp, pbuffer, size * count,\r\n&(filp->f_pos));\r\nset_fs(fs);\r\nif (!dw_bytes_read)\r\nreturn -EBADF;\r\nreturn dw_bytes_read / size;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic s32 cod_f_seek(struct file *filp, s32 offset, s32 origin)\r\n{\r\nloff_t dw_cur_pos;\r\nif (!filp)\r\nreturn -EFAULT;\r\ndw_cur_pos = filp->f_op->llseek(filp, offset, origin);\r\nif ((s32) dw_cur_pos < 0)\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nstatic s32 cod_f_tell(struct file *filp)\r\n{\r\nloff_t dw_cur_pos;\r\nif (!filp)\r\nreturn -EFAULT;\r\ndw_cur_pos = filp->f_op->llseek(filp, 0, SEEK_CUR);\r\nif ((s32) dw_cur_pos < 0)\r\nreturn -EPERM;\r\nreturn dw_cur_pos;\r\n}\r\nvoid cod_close(struct cod_libraryobj *lib)\r\n{\r\nstruct cod_manager *hmgr;\r\nhmgr = lib->cod_mgr;\r\nhmgr->fxns.close_fxn(lib->dbll_lib);\r\nkfree(lib);\r\n}\r\nint cod_create(struct cod_manager **mgr, char *str_zl_file)\r\n{\r\nstruct cod_manager *mgr_new;\r\nstruct dbll_attrs zl_attrs;\r\nint status = 0;\r\n*mgr = NULL;\r\nmgr_new = kzalloc(sizeof(struct cod_manager), GFP_KERNEL);\r\nif (mgr_new == NULL)\r\nreturn -ENOMEM;\r\nmgr_new->fxns = ldr_fxns;\r\nmgr_new->fxns.init_fxn();\r\nzl_attrs.alloc = (dbll_alloc_fxn) no_op;\r\nzl_attrs.free = (dbll_free_fxn) no_op;\r\nzl_attrs.fread = (dbll_read_fxn) cod_f_read;\r\nzl_attrs.fseek = (dbll_seek_fxn) cod_f_seek;\r\nzl_attrs.ftell = (dbll_tell_fxn) cod_f_tell;\r\nzl_attrs.fclose = (dbll_f_close_fxn) cod_f_close;\r\nzl_attrs.fopen = (dbll_f_open_fxn) cod_f_open;\r\nzl_attrs.sym_lookup = NULL;\r\nzl_attrs.base_image = true;\r\nzl_attrs.log_write = NULL;\r\nzl_attrs.log_write_handle = NULL;\r\nzl_attrs.write = NULL;\r\nzl_attrs.rmm_handle = NULL;\r\nzl_attrs.input_params = NULL;\r\nzl_attrs.sym_handle = NULL;\r\nzl_attrs.sym_arg = NULL;\r\nmgr_new->attrs = zl_attrs;\r\nstatus = mgr_new->fxns.create_fxn(&mgr_new->target, &zl_attrs);\r\nif (status) {\r\ncod_delete(mgr_new);\r\nreturn -ESPIPE;\r\n}\r\n*mgr = mgr_new;\r\nreturn 0;\r\n}\r\nvoid cod_delete(struct cod_manager *cod_mgr_obj)\r\n{\r\nif (cod_mgr_obj->base_lib) {\r\nif (cod_mgr_obj->loaded)\r\ncod_mgr_obj->fxns.unload_fxn(cod_mgr_obj->base_lib,\r\n&cod_mgr_obj->attrs);\r\ncod_mgr_obj->fxns.close_fxn(cod_mgr_obj->base_lib);\r\n}\r\nif (cod_mgr_obj->target) {\r\ncod_mgr_obj->fxns.delete_fxn(cod_mgr_obj->target);\r\ncod_mgr_obj->fxns.exit_fxn();\r\n}\r\nkfree(cod_mgr_obj);\r\n}\r\nint cod_get_base_lib(struct cod_manager *cod_mgr_obj,\r\nstruct dbll_library_obj **plib)\r\n{\r\nint status = 0;\r\n*plib = (struct dbll_library_obj *)cod_mgr_obj->base_lib;\r\nreturn status;\r\n}\r\nint cod_get_base_name(struct cod_manager *cod_mgr_obj, char *sz_name,\r\nu32 usize)\r\n{\r\nint status = 0;\r\nif (usize <= COD_MAXPATHLENGTH)\r\nstrlcpy(sz_name, cod_mgr_obj->sz_zl_file, usize);\r\nelse\r\nstatus = -EPERM;\r\nreturn status;\r\n}\r\nint cod_get_entry(struct cod_manager *cod_mgr_obj, u32 *entry_pt)\r\n{\r\n*entry_pt = cod_mgr_obj->entry;\r\nreturn 0;\r\n}\r\nint cod_get_loader(struct cod_manager *cod_mgr_obj,\r\nstruct dbll_tar_obj **loader)\r\n{\r\nint status = 0;\r\n*loader = (struct dbll_tar_obj *)cod_mgr_obj->target;\r\nreturn status;\r\n}\r\nint cod_get_section(struct cod_libraryobj *lib, char *str_sect,\r\nu32 *addr, u32 *len)\r\n{\r\nstruct cod_manager *cod_mgr_obj;\r\nint status = 0;\r\n*addr = 0;\r\n*len = 0;\r\nif (lib != NULL) {\r\ncod_mgr_obj = lib->cod_mgr;\r\nstatus = cod_mgr_obj->fxns.get_sect_fxn(lib->dbll_lib, str_sect,\r\naddr, len);\r\n} else {\r\nstatus = -ESPIPE;\r\n}\r\nreturn status;\r\n}\r\nint cod_get_sym_value(struct cod_manager *cod_mgr_obj, char *str_sym,\r\nu32 *pul_value)\r\n{\r\nstruct dbll_sym_val *dbll_sym;\r\ndev_dbg(bridge, "%s: cod_mgr_obj: %p str_sym: %s pul_value: %p\n",\r\n__func__, cod_mgr_obj, str_sym, pul_value);\r\nif (cod_mgr_obj->base_lib) {\r\nif (!cod_mgr_obj->fxns.\r\nget_addr_fxn(cod_mgr_obj->base_lib, str_sym, &dbll_sym)) {\r\nif (!cod_mgr_obj->fxns.\r\nget_c_addr_fxn(cod_mgr_obj->base_lib, str_sym,\r\n&dbll_sym))\r\nreturn -ESPIPE;\r\n}\r\n} else {\r\nreturn -ESPIPE;\r\n}\r\n*pul_value = dbll_sym->value;\r\nreturn 0;\r\n}\r\nint cod_load_base(struct cod_manager *cod_mgr_obj, u32 num_argc, char *args[],\r\ncod_writefxn pfn_write, void *arb, char *envp[])\r\n{\r\ndbll_flags flags;\r\nstruct dbll_attrs save_attrs;\r\nstruct dbll_attrs new_attrs;\r\nint status;\r\nu32 i;\r\nfor (i = 0; i < num_argc; i++) {\r\nif (args[i] == NULL) {\r\nnum_argc = i;\r\nbreak;\r\n}\r\n}\r\ncod_mgr_obj->fxns.get_attrs_fxn(cod_mgr_obj->target, &save_attrs);\r\nnew_attrs = save_attrs;\r\nnew_attrs.write = (dbll_write_fxn) pfn_write;\r\nnew_attrs.input_params = arb;\r\nnew_attrs.alloc = (dbll_alloc_fxn) no_op;\r\nnew_attrs.free = (dbll_free_fxn) no_op;\r\nnew_attrs.log_write = NULL;\r\nnew_attrs.log_write_handle = NULL;\r\nflags = DBLL_CODE | DBLL_DATA | DBLL_SYMB;\r\nstatus = cod_mgr_obj->fxns.load_fxn(cod_mgr_obj->base_lib, flags,\r\n&new_attrs,\r\n&cod_mgr_obj->entry);\r\nif (status)\r\ncod_mgr_obj->fxns.close_fxn(cod_mgr_obj->base_lib);\r\nif (!status)\r\ncod_mgr_obj->loaded = true;\r\nelse\r\ncod_mgr_obj->base_lib = NULL;\r\nreturn status;\r\n}\r\nint cod_open(struct cod_manager *hmgr, char *sz_coff_path,\r\nu32 flags, struct cod_libraryobj **lib_obj)\r\n{\r\nint status = 0;\r\nstruct cod_libraryobj *lib = NULL;\r\n*lib_obj = NULL;\r\nlib = kzalloc(sizeof(struct cod_libraryobj), GFP_KERNEL);\r\nif (lib == NULL)\r\nstatus = -ENOMEM;\r\nif (!status) {\r\nlib->cod_mgr = hmgr;\r\nstatus = hmgr->fxns.open_fxn(hmgr->target, sz_coff_path, flags,\r\n&lib->dbll_lib);\r\nif (!status)\r\n*lib_obj = lib;\r\n}\r\nif (status)\r\npr_err("%s: error status 0x%x, sz_coff_path: %s flags: 0x%x\n",\r\n__func__, status, sz_coff_path, flags);\r\nreturn status;\r\n}\r\nint cod_open_base(struct cod_manager *hmgr, char *sz_coff_path,\r\ndbll_flags flags)\r\n{\r\nint status = 0;\r\nstruct dbll_library_obj *lib;\r\nif (hmgr->base_lib) {\r\nif (hmgr->loaded) {\r\nhmgr->fxns.unload_fxn(hmgr->base_lib, &hmgr->attrs);\r\nhmgr->loaded = false;\r\n}\r\nhmgr->fxns.close_fxn(hmgr->base_lib);\r\nhmgr->base_lib = NULL;\r\n}\r\nstatus = hmgr->fxns.open_fxn(hmgr->target, sz_coff_path, flags, &lib);\r\nif (!status) {\r\nhmgr->base_lib = lib;\r\nstrncpy(hmgr->sz_zl_file, sz_coff_path, COD_MAXPATHLENGTH - 1);\r\nhmgr->sz_zl_file[COD_MAXPATHLENGTH - 1] = '\0';\r\n}\r\nif (status)\r\npr_err("%s: error status 0x%x sz_coff_path: %s\n", __func__,\r\nstatus, sz_coff_path);\r\nreturn status;\r\n}\r\nint cod_read_section(struct cod_libraryobj *lib, char *str_sect,\r\nchar *str_content, u32 content_size)\r\n{\r\nint status = 0;\r\nif (lib != NULL)\r\nstatus =\r\nlib->cod_mgr->fxns.read_sect_fxn(lib->dbll_lib, str_sect,\r\nstr_content, content_size);\r\nelse\r\nstatus = -ESPIPE;\r\nreturn status;\r\n}\r\nstatic bool no_op(void)\r\n{\r\nreturn true;\r\n}
