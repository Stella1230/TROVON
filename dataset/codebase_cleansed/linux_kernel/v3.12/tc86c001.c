static void tc86c001_set_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nunsigned long scr_port = hwif->config_data + (drive->dn ? 0x02 : 0x00);\r\nu16 mode, scr = inw(scr_port);\r\nconst u8 speed = drive->dma_mode;\r\nswitch (speed) {\r\ncase XFER_UDMA_4: mode = 0x00c0; break;\r\ncase XFER_UDMA_3: mode = 0x00b0; break;\r\ncase XFER_UDMA_2: mode = 0x00a0; break;\r\ncase XFER_UDMA_1: mode = 0x0090; break;\r\ncase XFER_UDMA_0: mode = 0x0080; break;\r\ncase XFER_MW_DMA_2: mode = 0x0070; break;\r\ncase XFER_MW_DMA_1: mode = 0x0060; break;\r\ncase XFER_MW_DMA_0: mode = 0x0050; break;\r\ncase XFER_PIO_4: mode = 0x0400; break;\r\ncase XFER_PIO_3: mode = 0x0300; break;\r\ncase XFER_PIO_2: mode = 0x0200; break;\r\ncase XFER_PIO_1: mode = 0x0100; break;\r\ncase XFER_PIO_0:\r\ndefault: mode = 0x0000; break;\r\n}\r\nscr &= (speed < XFER_MW_DMA_0) ? 0xf8ff : 0xff0f;\r\nscr |= mode;\r\noutw(scr, scr_port);\r\n}\r\nstatic void tc86c001_set_pio_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\ndrive->dma_mode = drive->pio_mode;\r\ntc86c001_set_mode(hwif, drive);\r\n}\r\nstatic int tc86c001_timer_expiry(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nide_expiry_t *expiry = ide_get_hwifdata(hwif);\r\nu8 dma_stat = inb(hwif->dma_base + ATA_DMA_STATUS);\r\nhwif->expiry = expiry;\r\nif ((dma_stat & 5) == 1) {\r\nunsigned long sc_base = hwif->config_data;\r\nunsigned long twcr_port = sc_base + (drive->dn ? 0x06 : 0x04);\r\nu8 dma_cmd = inb(hwif->dma_base + ATA_DMA_CMD);\r\nprintk(KERN_WARNING "%s: DMA interrupt possibly stuck, "\r\n"attempting recovery...\n", drive->name);\r\noutb(dma_cmd & ~0x01, hwif->dma_base + ATA_DMA_CMD);\r\noutw(0, sc_base + 0x0a);\r\noutw(0, twcr_port);\r\noutb(0x00, hwif->dma_base + ATA_DMA_CMD);\r\noutb(0x01, hwif->dma_base + ATA_DMA_CMD);\r\nreturn WAIT_MIN_SLEEP;\r\n}\r\nif (likely(expiry != NULL))\r\nreturn expiry(drive);\r\nreturn -1;\r\n}\r\nstatic void tc86c001_dma_start(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nunsigned long sc_base = hwif->config_data;\r\nunsigned long twcr_port = sc_base + (drive->dn ? 0x06 : 0x04);\r\nunsigned long nsectors = blk_rq_sectors(hwif->rq);\r\noutw(nsectors, sc_base + 0x0a);\r\noutw(SECTOR_SIZE / 2, twcr_port);\r\nide_set_hwifdata(hwif, hwif->expiry);\r\nhwif->expiry = &tc86c001_timer_expiry;\r\nide_dma_start(drive);\r\n}\r\nstatic u8 tc86c001_cable_detect(ide_hwif_t *hwif)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nunsigned long sc_base = pci_resource_start(dev, 5);\r\nu16 scr1 = inw(sc_base + 0x00);\r\nreturn (scr1 & 0x2000) ? ATA_CBL_PATA40 : ATA_CBL_PATA80;\r\n}\r\nstatic void init_hwif_tc86c001(ide_hwif_t *hwif)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nunsigned long sc_base = pci_resource_start(dev, 5);\r\nu16 scr1 = inw(sc_base + 0x00);\r\noutw(scr1 | 0x8000, sc_base + 0x00);\r\noutw(scr1 | 0x4000, sc_base + 0x00);\r\noutw(scr1 & ~0xc000, sc_base + 0x00);\r\nhwif->config_data = sc_base;\r\nif (!hwif->dma_base)\r\nreturn;\r\noutw(0x0003, sc_base + 0x0c);\r\nhwif->rqsize = 0xffff;\r\n}\r\nstatic int tc86c001_init_one(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nint rc;\r\nrc = pci_enable_device(dev);\r\nif (rc)\r\ngoto out;\r\nrc = pci_request_region(dev, 5, DRV_NAME);\r\nif (rc) {\r\nprintk(KERN_ERR DRV_NAME ": system control regs already in use");\r\ngoto out_disable;\r\n}\r\nrc = ide_pci_init_one(dev, &tc86c001_chipset, NULL);\r\nif (rc)\r\ngoto out_release;\r\ngoto out;\r\nout_release:\r\npci_release_region(dev, 5);\r\nout_disable:\r\npci_disable_device(dev);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void tc86c001_remove(struct pci_dev *dev)\r\n{\r\nide_pci_remove(dev);\r\npci_release_region(dev, 5);\r\npci_disable_device(dev);\r\n}\r\nstatic int __init tc86c001_ide_init(void)\r\n{\r\nreturn ide_pci_register_driver(&tc86c001_pci_driver);\r\n}\r\nstatic void __exit tc86c001_ide_exit(void)\r\n{\r\npci_unregister_driver(&tc86c001_pci_driver);\r\n}
