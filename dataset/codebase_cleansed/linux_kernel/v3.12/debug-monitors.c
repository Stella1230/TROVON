u8 debug_monitors_arch(void)\r\n{\r\nreturn read_cpuid(ID_AA64DFR0_EL1) & 0xf;\r\n}\r\nstatic void mdscr_write(u32 mdscr)\r\n{\r\nunsigned long flags;\r\nlocal_dbg_save(flags);\r\nasm volatile("msr mdscr_el1, %0" :: "r" (mdscr));\r\nlocal_dbg_restore(flags);\r\n}\r\nstatic u32 mdscr_read(void)\r\n{\r\nu32 mdscr;\r\nasm volatile("mrs %0, mdscr_el1" : "=r" (mdscr));\r\nreturn mdscr;\r\n}\r\nstatic int create_debug_debugfs_entry(void)\r\n{\r\ndebugfs_create_bool("debug_enabled", 0644, NULL, &debug_enabled);\r\nreturn 0;\r\n}\r\nstatic int __init early_debug_disable(char *buf)\r\n{\r\ndebug_enabled = 0;\r\nreturn 0;\r\n}\r\nvoid enable_debug_monitors(enum debug_el el)\r\n{\r\nu32 mdscr, enable = 0;\r\nWARN_ON(preemptible());\r\nif (local_inc_return(&__get_cpu_var(mde_ref_count)) == 1)\r\nenable = DBG_MDSCR_MDE;\r\nif (el == DBG_ACTIVE_EL1 &&\r\nlocal_inc_return(&__get_cpu_var(kde_ref_count)) == 1)\r\nenable |= DBG_MDSCR_KDE;\r\nif (enable && debug_enabled) {\r\nmdscr = mdscr_read();\r\nmdscr |= enable;\r\nmdscr_write(mdscr);\r\n}\r\n}\r\nvoid disable_debug_monitors(enum debug_el el)\r\n{\r\nu32 mdscr, disable = 0;\r\nWARN_ON(preemptible());\r\nif (local_dec_and_test(&__get_cpu_var(mde_ref_count)))\r\ndisable = ~DBG_MDSCR_MDE;\r\nif (el == DBG_ACTIVE_EL1 &&\r\nlocal_dec_and_test(&__get_cpu_var(kde_ref_count)))\r\ndisable &= ~DBG_MDSCR_KDE;\r\nif (disable) {\r\nmdscr = mdscr_read();\r\nmdscr &= disable;\r\nmdscr_write(mdscr);\r\n}\r\n}\r\nstatic void clear_os_lock(void *unused)\r\n{\r\nasm volatile("msr oslar_el1, %0" : : "r" (0));\r\nisb();\r\n}\r\nstatic int os_lock_notify(struct notifier_block *self,\r\nunsigned long action, void *data)\r\n{\r\nint cpu = (unsigned long)data;\r\nif (action == CPU_ONLINE)\r\nsmp_call_function_single(cpu, clear_os_lock, NULL, 1);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int debug_monitors_init(void)\r\n{\r\nsmp_call_function(clear_os_lock, NULL, 1);\r\nclear_os_lock(NULL);\r\nregister_cpu_notifier(&os_lock_nb);\r\nreturn 0;\r\n}\r\nstatic void set_regs_spsr_ss(struct pt_regs *regs)\r\n{\r\nunsigned long spsr;\r\nspsr = regs->pstate;\r\nspsr &= ~DBG_SPSR_SS;\r\nspsr |= DBG_SPSR_SS;\r\nregs->pstate = spsr;\r\n}\r\nstatic void clear_regs_spsr_ss(struct pt_regs *regs)\r\n{\r\nunsigned long spsr;\r\nspsr = regs->pstate;\r\nspsr &= ~DBG_SPSR_SS;\r\nregs->pstate = spsr;\r\n}\r\nstatic int single_step_handler(unsigned long addr, unsigned int esr,\r\nstruct pt_regs *regs)\r\n{\r\nsiginfo_t info;\r\nif (!reinstall_suspended_bps(regs))\r\nreturn 0;\r\nif (user_mode(regs)) {\r\ninfo.si_signo = SIGTRAP;\r\ninfo.si_errno = 0;\r\ninfo.si_code = TRAP_HWBKPT;\r\ninfo.si_addr = (void __user *)instruction_pointer(regs);\r\nforce_sig_info(SIGTRAP, &info, current);\r\nuser_rewind_single_step(current);\r\n} else {\r\npr_warning("Unexpected kernel single-step exception at EL1\n");\r\nset_regs_spsr_ss(regs);\r\n}\r\nreturn 0;\r\n}\r\nstatic int brk_handler(unsigned long addr, unsigned int esr,\r\nstruct pt_regs *regs)\r\n{\r\nsiginfo_t info;\r\nif (!user_mode(regs))\r\nreturn -EFAULT;\r\ninfo = (siginfo_t) {\r\n.si_signo = SIGTRAP,\r\n.si_errno = 0,\r\n.si_code = TRAP_BRKPT,\r\n.si_addr = (void __user *)instruction_pointer(regs),\r\n};\r\nforce_sig_info(SIGTRAP, &info, current);\r\nreturn 0;\r\n}\r\nint aarch32_break_handler(struct pt_regs *regs)\r\n{\r\nsiginfo_t info;\r\nunsigned int instr;\r\nbool bp = false;\r\nvoid __user *pc = (void __user *)instruction_pointer(regs);\r\nif (!compat_user_mode(regs))\r\nreturn -EFAULT;\r\nif (compat_thumb_mode(regs)) {\r\nget_user(instr, (u16 __user *)pc);\r\nif (instr == AARCH32_BREAK_THUMB2_LO) {\r\nget_user(instr, (u16 __user *)(pc + 2));\r\nbp = instr == AARCH32_BREAK_THUMB2_HI;\r\n} else {\r\nbp = instr == AARCH32_BREAK_THUMB;\r\n}\r\n} else {\r\nget_user(instr, (u32 __user *)pc);\r\nbp = (instr & ~0xf0000000) == AARCH32_BREAK_ARM;\r\n}\r\nif (!bp)\r\nreturn -EFAULT;\r\ninfo = (siginfo_t) {\r\n.si_signo = SIGTRAP,\r\n.si_errno = 0,\r\n.si_code = TRAP_BRKPT,\r\n.si_addr = pc,\r\n};\r\nforce_sig_info(SIGTRAP, &info, current);\r\nreturn 0;\r\n}\r\nstatic int __init debug_traps_init(void)\r\n{\r\nhook_debug_fault_code(DBG_ESR_EVT_HWSS, single_step_handler, SIGTRAP,\r\nTRAP_HWBKPT, "single-step handler");\r\nhook_debug_fault_code(DBG_ESR_EVT_BRK, brk_handler, SIGTRAP,\r\nTRAP_BRKPT, "ptrace BRK handler");\r\nreturn 0;\r\n}\r\nvoid user_rewind_single_step(struct task_struct *task)\r\n{\r\nif (test_ti_thread_flag(task_thread_info(task), TIF_SINGLESTEP))\r\nset_regs_spsr_ss(task_pt_regs(task));\r\n}\r\nvoid user_fastforward_single_step(struct task_struct *task)\r\n{\r\nif (test_ti_thread_flag(task_thread_info(task), TIF_SINGLESTEP))\r\nclear_regs_spsr_ss(task_pt_regs(task));\r\n}\r\nvoid kernel_enable_single_step(struct pt_regs *regs)\r\n{\r\nWARN_ON(!irqs_disabled());\r\nset_regs_spsr_ss(regs);\r\nmdscr_write(mdscr_read() | DBG_MDSCR_SS);\r\nenable_debug_monitors(DBG_ACTIVE_EL1);\r\n}\r\nvoid kernel_disable_single_step(void)\r\n{\r\nWARN_ON(!irqs_disabled());\r\nmdscr_write(mdscr_read() & ~DBG_MDSCR_SS);\r\ndisable_debug_monitors(DBG_ACTIVE_EL1);\r\n}\r\nint kernel_active_single_step(void)\r\n{\r\nWARN_ON(!irqs_disabled());\r\nreturn mdscr_read() & DBG_MDSCR_SS;\r\n}\r\nvoid user_enable_single_step(struct task_struct *task)\r\n{\r\nset_ti_thread_flag(task_thread_info(task), TIF_SINGLESTEP);\r\nset_regs_spsr_ss(task_pt_regs(task));\r\n}\r\nvoid user_disable_single_step(struct task_struct *task)\r\n{\r\nclear_ti_thread_flag(task_thread_info(task), TIF_SINGLESTEP);\r\n}
