static inline int hih6130_temp_ticks_to_millicelsius(int ticks)\r\n{\r\nticks = ticks >> 2;\r\nreturn (DIV_ROUND_CLOSEST(ticks * 1650, 16382) - 400) * 100;\r\n}\r\nstatic inline int hih6130_rh_ticks_to_per_cent_mille(int ticks)\r\n{\r\nticks &= ~0xC000;\r\nreturn DIV_ROUND_CLOSEST(ticks * 1000, 16382) * 100;\r\n}\r\nstatic int hih6130_update_measurements(struct i2c_client *client)\r\n{\r\nint ret = 0;\r\nint t;\r\nstruct hih6130 *hih6130 = i2c_get_clientdata(client);\r\nunsigned char tmp[4];\r\nstruct i2c_msg msgs[1] = {\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = 4,\r\n.buf = tmp,\r\n}\r\n};\r\nmutex_lock(&hih6130->lock);\r\nif (time_after(jiffies, hih6130->last_update + HZ) || !hih6130->valid) {\r\nret = i2c_master_send(client, tmp, 0);\r\nif (ret < 0)\r\ngoto out;\r\nmsleep(40);\r\nret = i2c_transfer(client->adapter, msgs, 1);\r\nif (ret < 0)\r\ngoto out;\r\nif ((tmp[0] & 0xC0) != 0) {\r\ndev_err(&client->dev, "Error while reading measurement result\n");\r\nret = -EIO;\r\ngoto out;\r\n}\r\nt = (tmp[0] << 8) + tmp[1];\r\nhih6130->humidity = hih6130_rh_ticks_to_per_cent_mille(t);\r\nt = (tmp[2] << 8) + tmp[3];\r\nhih6130->temperature = hih6130_temp_ticks_to_millicelsius(t);\r\nhih6130->last_update = jiffies;\r\nhih6130->valid = true;\r\n}\r\nout:\r\nmutex_unlock(&hih6130->lock);\r\nreturn ret >= 0 ? 0 : ret;\r\n}\r\nstatic ssize_t hih6130_show_temperature(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct hih6130 *hih6130 = i2c_get_clientdata(client);\r\nint ret = hih6130_update_measurements(client);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", hih6130->temperature);\r\n}\r\nstatic ssize_t hih6130_show_humidity(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct hih6130 *hih6130 = i2c_get_clientdata(client);\r\nint ret = hih6130_update_measurements(client);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", hih6130->humidity);\r\n}\r\nstatic int hih6130_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct hih6130 *hih6130;\r\nint err;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev, "adapter does not support true I2C\n");\r\nreturn -ENODEV;\r\n}\r\nhih6130 = devm_kzalloc(&client->dev, sizeof(*hih6130), GFP_KERNEL);\r\nif (!hih6130)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, hih6130);\r\nmutex_init(&hih6130->lock);\r\nerr = sysfs_create_group(&client->dev.kobj, &hih6130_attr_group);\r\nif (err) {\r\ndev_dbg(&client->dev, "could not create sysfs files\n");\r\nreturn err;\r\n}\r\nhih6130->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(hih6130->hwmon_dev)) {\r\ndev_dbg(&client->dev, "unable to register hwmon device\n");\r\nerr = PTR_ERR(hih6130->hwmon_dev);\r\ngoto fail_remove_sysfs;\r\n}\r\nreturn 0;\r\nfail_remove_sysfs:\r\nsysfs_remove_group(&client->dev.kobj, &hih6130_attr_group);\r\nreturn err;\r\n}\r\nstatic int hih6130_remove(struct i2c_client *client)\r\n{\r\nstruct hih6130 *hih6130 = i2c_get_clientdata(client);\r\nhwmon_device_unregister(hih6130->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &hih6130_attr_group);\r\nreturn 0;\r\n}
