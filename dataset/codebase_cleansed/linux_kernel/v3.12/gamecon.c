static void gc_n64_send_command(struct gc *gc, unsigned long cmd,\r\nunsigned char target)\r\n{\r\nstruct parport *port = gc->pd->port;\r\nint i;\r\nfor (i = 0; i < GC_N64_LENGTH; i++) {\r\nunsigned char data = (cmd >> i) & 1 ? target : 0;\r\nparport_write_data(port, GC_N64_POWER_W | data);\r\nudelay(GC_N64_DWS);\r\n}\r\n}\r\nstatic void gc_n64_send_stop_bit(struct gc *gc, unsigned char target)\r\n{\r\nstruct parport *port = gc->pd->port;\r\nint i;\r\nfor (i = 0; i < GC_N64_STOP_LENGTH; i++) {\r\nunsigned char data = (GC_N64_STOP_BIT >> i) & 1 ? target : 0;\r\nparport_write_data(port, GC_N64_POWER_W | data);\r\nudelay(GC_N64_DWS);\r\n}\r\n}\r\nstatic void gc_n64_read_packet(struct gc *gc, unsigned char *data)\r\n{\r\nint i;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ngc_n64_send_command(gc, GC_N64_REQUEST_DATA, GC_N64_OUT);\r\ngc_n64_send_stop_bit(gc, GC_N64_OUT);\r\nlocal_irq_restore(flags);\r\nudelay(GC_N64_DELAY);\r\nfor (i = 0; i < GC_N64_LENGTH; i++) {\r\nparport_write_data(gc->pd->port, GC_N64_POWER_R);\r\nudelay(2);\r\ndata[i] = parport_read_status(gc->pd->port);\r\nparport_write_data(gc->pd->port, GC_N64_POWER_R | GC_N64_CLOCK);\r\n}\r\n}\r\nstatic void gc_n64_process_packet(struct gc *gc)\r\n{\r\nunsigned char data[GC_N64_LENGTH];\r\nstruct input_dev *dev;\r\nint i, j, s;\r\nsigned char x, y;\r\ngc_n64_read_packet(gc, data);\r\nfor (i = 0; i < GC_MAX_DEVICES; i++) {\r\nif (gc->pads[i].type != GC_N64)\r\ncontinue;\r\ndev = gc->pads[i].dev;\r\ns = gc_status_bit[i];\r\nif (s & ~(data[8] | data[9])) {\r\nx = y = 0;\r\nfor (j = 0; j < 8; j++) {\r\nif (data[23 - j] & s)\r\nx |= 1 << j;\r\nif (data[31 - j] & s)\r\ny |= 1 << j;\r\n}\r\ninput_report_abs(dev, ABS_X, x);\r\ninput_report_abs(dev, ABS_Y, -y);\r\ninput_report_abs(dev, ABS_HAT0X,\r\n!(s & data[6]) - !(s & data[7]));\r\ninput_report_abs(dev, ABS_HAT0Y,\r\n!(s & data[4]) - !(s & data[5]));\r\nfor (j = 0; j < 10; j++)\r\ninput_report_key(dev, gc_n64_btn[j],\r\ns & data[gc_n64_bytes[j]]);\r\ninput_sync(dev);\r\n}\r\n}\r\n}\r\nstatic int gc_n64_play_effect(struct input_dev *dev, void *data,\r\nstruct ff_effect *effect)\r\n{\r\nint i;\r\nunsigned long flags;\r\nstruct gc *gc = input_get_drvdata(dev);\r\nstruct gc_subdev *sdev = data;\r\nunsigned char target = 1 << sdev->idx;\r\nif (effect->type == FF_RUMBLE) {\r\nstruct ff_rumble_effect *rumble = &effect->u.rumble;\r\nunsigned int cmd =\r\nrumble->strong_magnitude || rumble->weak_magnitude ?\r\nGC_N64_CMD_01 : GC_N64_CMD_00;\r\nlocal_irq_save(flags);\r\ngc_n64_send_command(gc, GC_N64_CMD_03, target);\r\ngc_n64_send_command(gc, GC_N64_CMD_80, target);\r\ngc_n64_send_command(gc, GC_N64_CMD_01, target);\r\nfor (i = 0; i < 32; i++)\r\ngc_n64_send_command(gc, GC_N64_CMD_80, target);\r\ngc_n64_send_stop_bit(gc, target);\r\nudelay(GC_N64_DELAY);\r\ngc_n64_send_command(gc, GC_N64_CMD_03, target);\r\ngc_n64_send_command(gc, GC_N64_CMD_c0, target);\r\ngc_n64_send_command(gc, GC_N64_CMD_1b, target);\r\nfor (i = 0; i < 32; i++)\r\ngc_n64_send_command(gc, cmd, target);\r\ngc_n64_send_stop_bit(gc, target);\r\nlocal_irq_restore(flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init gc_n64_init_ff(struct input_dev *dev, int i)\r\n{\r\nstruct gc_subdev *sdev;\r\nint err;\r\nsdev = kmalloc(sizeof(*sdev), GFP_KERNEL);\r\nif (!sdev)\r\nreturn -ENOMEM;\r\nsdev->idx = i;\r\ninput_set_capability(dev, EV_FF, FF_RUMBLE);\r\nerr = input_ff_create_memless(dev, sdev, gc_n64_play_effect);\r\nif (err) {\r\nkfree(sdev);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void gc_nes_read_packet(struct gc *gc, int length, unsigned char *data)\r\n{\r\nint i;\r\nparport_write_data(gc->pd->port, GC_NES_POWER | GC_NES_CLOCK | GC_NES_LATCH);\r\nudelay(GC_NES_DELAY * 2);\r\nparport_write_data(gc->pd->port, GC_NES_POWER | GC_NES_CLOCK);\r\nfor (i = 0; i < length; i++) {\r\nudelay(GC_NES_DELAY);\r\nparport_write_data(gc->pd->port, GC_NES_POWER);\r\ndata[i] = parport_read_status(gc->pd->port) ^ 0x7f;\r\nudelay(GC_NES_DELAY);\r\nparport_write_data(gc->pd->port, GC_NES_POWER | GC_NES_CLOCK);\r\n}\r\n}\r\nstatic void gc_nes_process_packet(struct gc *gc)\r\n{\r\nunsigned char data[GC_SNESMOUSE_LENGTH];\r\nstruct gc_pad *pad;\r\nstruct input_dev *dev;\r\nint i, j, s, len;\r\nchar x_rel, y_rel;\r\nlen = gc->pad_count[GC_SNESMOUSE] ? GC_SNESMOUSE_LENGTH :\r\n(gc->pad_count[GC_SNES] ? GC_SNES_LENGTH : GC_NES_LENGTH);\r\ngc_nes_read_packet(gc, len, data);\r\nfor (i = 0; i < GC_MAX_DEVICES; i++) {\r\npad = &gc->pads[i];\r\ndev = pad->dev;\r\ns = gc_status_bit[i];\r\nswitch (pad->type) {\r\ncase GC_NES:\r\ninput_report_abs(dev, ABS_X, !(s & data[6]) - !(s & data[7]));\r\ninput_report_abs(dev, ABS_Y, !(s & data[4]) - !(s & data[5]));\r\nfor (j = 0; j < 4; j++)\r\ninput_report_key(dev, gc_snes_btn[j],\r\ns & data[gc_nes_bytes[j]]);\r\ninput_sync(dev);\r\nbreak;\r\ncase GC_SNES:\r\ninput_report_abs(dev, ABS_X, !(s & data[6]) - !(s & data[7]));\r\ninput_report_abs(dev, ABS_Y, !(s & data[4]) - !(s & data[5]));\r\nfor (j = 0; j < 8; j++)\r\ninput_report_key(dev, gc_snes_btn[j],\r\ns & data[gc_snes_bytes[j]]);\r\ninput_sync(dev);\r\nbreak;\r\ncase GC_SNESMOUSE:\r\nif (!(s & data[12]) && !(s & data[13]) &&\r\n!(s & data[14]) && (s & data[15])) {\r\ninput_report_key(dev, BTN_LEFT, s & data[9]);\r\ninput_report_key(dev, BTN_RIGHT, s & data[8]);\r\nx_rel = y_rel = 0;\r\nfor (j = 0; j < 7; j++) {\r\nx_rel <<= 1;\r\nif (data[25 + j] & s)\r\nx_rel |= 1;\r\ny_rel <<= 1;\r\nif (data[17 + j] & s)\r\ny_rel |= 1;\r\n}\r\nif (x_rel) {\r\nif (data[24] & s)\r\nx_rel = -x_rel;\r\ninput_report_rel(dev, REL_X, x_rel);\r\n}\r\nif (y_rel) {\r\nif (data[16] & s)\r\ny_rel = -y_rel;\r\ninput_report_rel(dev, REL_Y, y_rel);\r\n}\r\ninput_sync(dev);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void gc_multi_read_packet(struct gc *gc, int length, unsigned char *data)\r\n{\r\nint i;\r\nfor (i = 0; i < length; i++) {\r\nparport_write_data(gc->pd->port, ~(1 << i));\r\ndata[i] = parport_read_status(gc->pd->port) ^ 0x7f;\r\n}\r\n}\r\nstatic void gc_multi_process_packet(struct gc *gc)\r\n{\r\nunsigned char data[GC_MULTI2_LENGTH];\r\nint data_len = gc->pad_count[GC_MULTI2] ? GC_MULTI2_LENGTH : GC_MULTI_LENGTH;\r\nstruct gc_pad *pad;\r\nstruct input_dev *dev;\r\nint i, s;\r\ngc_multi_read_packet(gc, data_len, data);\r\nfor (i = 0; i < GC_MAX_DEVICES; i++) {\r\npad = &gc->pads[i];\r\ndev = pad->dev;\r\ns = gc_status_bit[i];\r\nswitch (pad->type) {\r\ncase GC_MULTI2:\r\ninput_report_key(dev, BTN_THUMB, s & data[5]);\r\ncase GC_MULTI:\r\ninput_report_abs(dev, ABS_X,\r\n!(s & data[2]) - !(s & data[3]));\r\ninput_report_abs(dev, ABS_Y,\r\n!(s & data[0]) - !(s & data[1]));\r\ninput_report_key(dev, BTN_TRIGGER, s & data[4]);\r\ninput_sync(dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void gc_psx_command(struct gc *gc, int b, unsigned char *data)\r\n{\r\nstruct parport *port = gc->pd->port;\r\nint i, j, cmd, read;\r\nmemset(data, 0, GC_MAX_DEVICES);\r\nfor (i = 0; i < GC_PSX_LENGTH; i++, b >>= 1) {\r\ncmd = (b & 1) ? GC_PSX_COMMAND : 0;\r\nparport_write_data(port, cmd | GC_PSX_POWER);\r\nudelay(gc_psx_delay);\r\nread = parport_read_status(port) ^ 0x80;\r\nfor (j = 0; j < GC_MAX_DEVICES; j++) {\r\nstruct gc_pad *pad = &gc->pads[j];\r\nif (pad->type == GC_PSX || pad->type == GC_DDR)\r\ndata[j] |= (read & gc_status_bit[j]) ? (1 << i) : 0;\r\n}\r\nparport_write_data(gc->pd->port, cmd | GC_PSX_CLOCK | GC_PSX_POWER);\r\nudelay(gc_psx_delay);\r\n}\r\n}\r\nstatic void gc_psx_read_packet(struct gc *gc,\r\nunsigned char data[GC_MAX_DEVICES][GC_PSX_BYTES],\r\nunsigned char id[GC_MAX_DEVICES])\r\n{\r\nint i, j, max_len = 0;\r\nunsigned long flags;\r\nunsigned char data2[GC_MAX_DEVICES];\r\nparport_write_data(gc->pd->port, GC_PSX_CLOCK | GC_PSX_SELECT | GC_PSX_POWER);\r\nudelay(gc_psx_delay);\r\nparport_write_data(gc->pd->port, GC_PSX_CLOCK | GC_PSX_POWER);\r\nudelay(gc_psx_delay);\r\nlocal_irq_save(flags);\r\ngc_psx_command(gc, 0x01, data2);\r\ngc_psx_command(gc, 0x42, id);\r\ngc_psx_command(gc, 0, data2);\r\nfor (i = 0; i < GC_MAX_DEVICES; i++) {\r\nstruct gc_pad *pad = &gc->pads[i];\r\nif ((pad->type == GC_PSX || pad->type == GC_DDR) &&\r\nGC_PSX_LEN(id[i]) > max_len &&\r\nGC_PSX_LEN(id[i]) <= GC_PSX_BYTES) {\r\nmax_len = GC_PSX_LEN(id[i]);\r\n}\r\n}\r\nfor (i = 0; i < max_len; i++) {\r\ngc_psx_command(gc, 0, data2);\r\nfor (j = 0; j < GC_MAX_DEVICES; j++)\r\ndata[j][i] = data2[j];\r\n}\r\nlocal_irq_restore(flags);\r\nparport_write_data(gc->pd->port, GC_PSX_CLOCK | GC_PSX_SELECT | GC_PSX_POWER);\r\nfor (i = 0; i < GC_MAX_DEVICES; i++)\r\nid[i] = GC_PSX_ID(id[i]);\r\n}\r\nstatic void gc_psx_report_one(struct gc_pad *pad, unsigned char psx_type,\r\nunsigned char *data)\r\n{\r\nstruct input_dev *dev = pad->dev;\r\nint i;\r\nswitch (psx_type) {\r\ncase GC_PSX_RUMBLE:\r\ninput_report_key(dev, BTN_THUMBL, ~data[0] & 0x04);\r\ninput_report_key(dev, BTN_THUMBR, ~data[0] & 0x02);\r\ncase GC_PSX_NEGCON:\r\ncase GC_PSX_ANALOG:\r\nif (pad->type == GC_DDR) {\r\nfor (i = 0; i < 4; i++)\r\ninput_report_key(dev, gc_psx_ddr_btn[i],\r\n~data[0] & (0x10 << i));\r\n} else {\r\nfor (i = 0; i < 4; i++)\r\ninput_report_abs(dev, gc_psx_abs[i + 2],\r\ndata[i + 2]);\r\ninput_report_abs(dev, ABS_X,\r\n!!(data[0] & 0x80) * 128 + !(data[0] & 0x20) * 127);\r\ninput_report_abs(dev, ABS_Y,\r\n!!(data[0] & 0x10) * 128 + !(data[0] & 0x40) * 127);\r\n}\r\nfor (i = 0; i < 8; i++)\r\ninput_report_key(dev, gc_psx_btn[i], ~data[1] & (1 << i));\r\ninput_report_key(dev, BTN_START, ~data[0] & 0x08);\r\ninput_report_key(dev, BTN_SELECT, ~data[0] & 0x01);\r\ninput_sync(dev);\r\nbreak;\r\ncase GC_PSX_NORMAL:\r\nif (pad->type == GC_DDR) {\r\nfor (i = 0; i < 4; i++)\r\ninput_report_key(dev, gc_psx_ddr_btn[i],\r\n~data[0] & (0x10 << i));\r\n} else {\r\ninput_report_abs(dev, ABS_X,\r\n!!(data[0] & 0x80) * 128 + !(data[0] & 0x20) * 127);\r\ninput_report_abs(dev, ABS_Y,\r\n!!(data[0] & 0x10) * 128 + !(data[0] & 0x40) * 127);\r\n}\r\nfor (i = 0; i < 8; i++)\r\ninput_report_key(dev, gc_psx_btn[i], ~data[1] & (1 << i));\r\ninput_report_key(dev, BTN_START, ~data[0] & 0x08);\r\ninput_report_key(dev, BTN_SELECT, ~data[0] & 0x01);\r\ninput_sync(dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void gc_psx_process_packet(struct gc *gc)\r\n{\r\nunsigned char data[GC_MAX_DEVICES][GC_PSX_BYTES];\r\nunsigned char id[GC_MAX_DEVICES];\r\nstruct gc_pad *pad;\r\nint i;\r\ngc_psx_read_packet(gc, data, id);\r\nfor (i = 0; i < GC_MAX_DEVICES; i++) {\r\npad = &gc->pads[i];\r\nif (pad->type == GC_PSX || pad->type == GC_DDR)\r\ngc_psx_report_one(pad, id[i], data[i]);\r\n}\r\n}\r\nstatic void gc_timer(unsigned long private)\r\n{\r\nstruct gc *gc = (void *) private;\r\nif (gc->pad_count[GC_N64])\r\ngc_n64_process_packet(gc);\r\nif (gc->pad_count[GC_NES] ||\r\ngc->pad_count[GC_SNES] ||\r\ngc->pad_count[GC_SNESMOUSE]) {\r\ngc_nes_process_packet(gc);\r\n}\r\nif (gc->pad_count[GC_MULTI] || gc->pad_count[GC_MULTI2])\r\ngc_multi_process_packet(gc);\r\nif (gc->pad_count[GC_PSX] || gc->pad_count[GC_DDR])\r\ngc_psx_process_packet(gc);\r\nmod_timer(&gc->timer, jiffies + GC_REFRESH_TIME);\r\n}\r\nstatic int gc_open(struct input_dev *dev)\r\n{\r\nstruct gc *gc = input_get_drvdata(dev);\r\nint err;\r\nerr = mutex_lock_interruptible(&gc->mutex);\r\nif (err)\r\nreturn err;\r\nif (!gc->used++) {\r\nparport_claim(gc->pd);\r\nparport_write_control(gc->pd->port, 0x04);\r\nmod_timer(&gc->timer, jiffies + GC_REFRESH_TIME);\r\n}\r\nmutex_unlock(&gc->mutex);\r\nreturn 0;\r\n}\r\nstatic void gc_close(struct input_dev *dev)\r\n{\r\nstruct gc *gc = input_get_drvdata(dev);\r\nmutex_lock(&gc->mutex);\r\nif (!--gc->used) {\r\ndel_timer_sync(&gc->timer);\r\nparport_write_control(gc->pd->port, 0x00);\r\nparport_release(gc->pd);\r\n}\r\nmutex_unlock(&gc->mutex);\r\n}\r\nstatic int __init gc_setup_pad(struct gc *gc, int idx, int pad_type)\r\n{\r\nstruct gc_pad *pad = &gc->pads[idx];\r\nstruct input_dev *input_dev;\r\nint i;\r\nint err;\r\nif (pad_type < 1 || pad_type >= GC_MAX) {\r\npr_err("Pad type %d unknown\n", pad_type);\r\nreturn -EINVAL;\r\n}\r\npad->dev = input_dev = input_allocate_device();\r\nif (!input_dev) {\r\npr_err("Not enough memory for input device\n");\r\nreturn -ENOMEM;\r\n}\r\npad->type = pad_type;\r\nsnprintf(pad->phys, sizeof(pad->phys),\r\n"%s/input%d", gc->pd->port->name, idx);\r\ninput_dev->name = gc_names[pad_type];\r\ninput_dev->phys = pad->phys;\r\ninput_dev->id.bustype = BUS_PARPORT;\r\ninput_dev->id.vendor = 0x0001;\r\ninput_dev->id.product = pad_type;\r\ninput_dev->id.version = 0x0100;\r\ninput_set_drvdata(input_dev, gc);\r\ninput_dev->open = gc_open;\r\ninput_dev->close = gc_close;\r\nif (pad_type != GC_SNESMOUSE) {\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nfor (i = 0; i < 2; i++)\r\ninput_set_abs_params(input_dev, ABS_X + i, -1, 1, 0, 0);\r\n} else\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\r\ngc->pad_count[pad_type]++;\r\nswitch (pad_type) {\r\ncase GC_N64:\r\nfor (i = 0; i < 10; i++)\r\n__set_bit(gc_n64_btn[i], input_dev->keybit);\r\nfor (i = 0; i < 2; i++) {\r\ninput_set_abs_params(input_dev, ABS_X + i, -127, 126, 0, 2);\r\ninput_set_abs_params(input_dev, ABS_HAT0X + i, -1, 1, 0, 0);\r\n}\r\nerr = gc_n64_init_ff(input_dev, idx);\r\nif (err) {\r\npr_warning("Failed to initiate rumble for N64 device %d\n", idx);\r\ngoto err_free_dev;\r\n}\r\nbreak;\r\ncase GC_SNESMOUSE:\r\n__set_bit(BTN_LEFT, input_dev->keybit);\r\n__set_bit(BTN_RIGHT, input_dev->keybit);\r\n__set_bit(REL_X, input_dev->relbit);\r\n__set_bit(REL_Y, input_dev->relbit);\r\nbreak;\r\ncase GC_SNES:\r\nfor (i = 4; i < 8; i++)\r\n__set_bit(gc_snes_btn[i], input_dev->keybit);\r\ncase GC_NES:\r\nfor (i = 0; i < 4; i++)\r\n__set_bit(gc_snes_btn[i], input_dev->keybit);\r\nbreak;\r\ncase GC_MULTI2:\r\n__set_bit(BTN_THUMB, input_dev->keybit);\r\ncase GC_MULTI:\r\n__set_bit(BTN_TRIGGER, input_dev->keybit);\r\nbreak;\r\ncase GC_PSX:\r\nfor (i = 0; i < 6; i++)\r\ninput_set_abs_params(input_dev,\r\ngc_psx_abs[i], 4, 252, 0, 2);\r\nfor (i = 0; i < 12; i++)\r\n__set_bit(gc_psx_btn[i], input_dev->keybit);\r\nbreak;\r\ncase GC_DDR:\r\nfor (i = 0; i < 4; i++)\r\n__set_bit(gc_psx_ddr_btn[i], input_dev->keybit);\r\nfor (i = 0; i < 12; i++)\r\n__set_bit(gc_psx_btn[i], input_dev->keybit);\r\nbreak;\r\n}\r\nerr = input_register_device(pad->dev);\r\nif (err)\r\ngoto err_free_dev;\r\nreturn 0;\r\nerr_free_dev:\r\ninput_free_device(pad->dev);\r\npad->dev = NULL;\r\nreturn err;\r\n}\r\nstatic struct gc __init *gc_probe(int parport, int *pads, int n_pads)\r\n{\r\nstruct gc *gc;\r\nstruct parport *pp;\r\nstruct pardevice *pd;\r\nint i;\r\nint count = 0;\r\nint err;\r\npp = parport_find_number(parport);\r\nif (!pp) {\r\npr_err("no such parport %d\n", parport);\r\nerr = -EINVAL;\r\ngoto err_out;\r\n}\r\npd = parport_register_device(pp, "gamecon", NULL, NULL, NULL, PARPORT_DEV_EXCL, NULL);\r\nif (!pd) {\r\npr_err("parport busy already - lp.o loaded?\n");\r\nerr = -EBUSY;\r\ngoto err_put_pp;\r\n}\r\ngc = kzalloc(sizeof(struct gc), GFP_KERNEL);\r\nif (!gc) {\r\npr_err("Not enough memory\n");\r\nerr = -ENOMEM;\r\ngoto err_unreg_pardev;\r\n}\r\nmutex_init(&gc->mutex);\r\ngc->pd = pd;\r\nsetup_timer(&gc->timer, gc_timer, (long) gc);\r\nfor (i = 0; i < n_pads && i < GC_MAX_DEVICES; i++) {\r\nif (!pads[i])\r\ncontinue;\r\nerr = gc_setup_pad(gc, i, pads[i]);\r\nif (err)\r\ngoto err_unreg_devs;\r\ncount++;\r\n}\r\nif (count == 0) {\r\npr_err("No valid devices specified\n");\r\nerr = -EINVAL;\r\ngoto err_free_gc;\r\n}\r\nparport_put_port(pp);\r\nreturn gc;\r\nerr_unreg_devs:\r\nwhile (--i >= 0)\r\nif (gc->pads[i].dev)\r\ninput_unregister_device(gc->pads[i].dev);\r\nerr_free_gc:\r\nkfree(gc);\r\nerr_unreg_pardev:\r\nparport_unregister_device(pd);\r\nerr_put_pp:\r\nparport_put_port(pp);\r\nerr_out:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void gc_remove(struct gc *gc)\r\n{\r\nint i;\r\nfor (i = 0; i < GC_MAX_DEVICES; i++)\r\nif (gc->pads[i].dev)\r\ninput_unregister_device(gc->pads[i].dev);\r\nparport_unregister_device(gc->pd);\r\nkfree(gc);\r\n}\r\nstatic int __init gc_init(void)\r\n{\r\nint i;\r\nint have_dev = 0;\r\nint err = 0;\r\nfor (i = 0; i < GC_MAX_PORTS; i++) {\r\nif (gc_cfg[i].nargs == 0 || gc_cfg[i].args[0] < 0)\r\ncontinue;\r\nif (gc_cfg[i].nargs < 2) {\r\npr_err("at least one device must be specified\n");\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\ngc_base[i] = gc_probe(gc_cfg[i].args[0],\r\ngc_cfg[i].args + 1, gc_cfg[i].nargs - 1);\r\nif (IS_ERR(gc_base[i])) {\r\nerr = PTR_ERR(gc_base[i]);\r\nbreak;\r\n}\r\nhave_dev = 1;\r\n}\r\nif (err) {\r\nwhile (--i >= 0)\r\nif (gc_base[i])\r\ngc_remove(gc_base[i]);\r\nreturn err;\r\n}\r\nreturn have_dev ? 0 : -ENODEV;\r\n}\r\nstatic void __exit gc_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < GC_MAX_PORTS; i++)\r\nif (gc_base[i])\r\ngc_remove(gc_base[i]);\r\n}
