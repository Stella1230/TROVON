static void read_main_config_table(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nvoid __iomem *address = pm8001_ha->main_cfg_tbl_addr;\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.signature =\r\npm8001_mr32(address, MAIN_SIGNATURE_OFFSET);\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.interface_rev =\r\npm8001_mr32(address, MAIN_INTERFACE_REVISION);\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.firmware_rev =\r\npm8001_mr32(address, MAIN_FW_REVISION);\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.max_out_io =\r\npm8001_mr32(address, MAIN_MAX_OUTSTANDING_IO_OFFSET);\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.max_sgl =\r\npm8001_mr32(address, MAIN_MAX_SGL_OFFSET);\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.ctrl_cap_flag =\r\npm8001_mr32(address, MAIN_CNTRL_CAP_OFFSET);\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.gst_offset =\r\npm8001_mr32(address, MAIN_GST_OFFSET);\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.inbound_queue_offset =\r\npm8001_mr32(address, MAIN_IBQ_OFFSET);\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.outbound_queue_offset =\r\npm8001_mr32(address, MAIN_OBQ_OFFSET);\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.fatal_err_dump_offset0 =\r\npm8001_mr32(address, MAIN_FATAL_ERROR_RDUMP0_OFFSET);\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.fatal_err_dump_length0 =\r\npm8001_mr32(address, MAIN_FATAL_ERROR_RDUMP0_LENGTH);\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.fatal_err_dump_offset1 =\r\npm8001_mr32(address, MAIN_FATAL_ERROR_RDUMP1_OFFSET);\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.fatal_err_dump_length1 =\r\npm8001_mr32(address, MAIN_FATAL_ERROR_RDUMP1_LENGTH);\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.gpio_led_mapping =\r\npm8001_mr32(address, MAIN_GPIO_LED_FLAGS_OFFSET);\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.analog_setup_table_offset =\r\npm8001_mr32(address, MAIN_ANALOG_SETUP_OFFSET);\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.int_vec_table_offset =\r\npm8001_mr32(address, MAIN_INT_VECTOR_TABLE_OFFSET);\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.phy_attr_table_offset =\r\npm8001_mr32(address, MAIN_SAS_PHY_ATTR_TABLE_OFFSET);\r\n}\r\nstatic void read_general_status_table(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nvoid __iomem *address = pm8001_ha->general_stat_tbl_addr;\r\npm8001_ha->gs_tbl.pm80xx_tbl.gst_len_mpistate =\r\npm8001_mr32(address, GST_GSTLEN_MPIS_OFFSET);\r\npm8001_ha->gs_tbl.pm80xx_tbl.iq_freeze_state0 =\r\npm8001_mr32(address, GST_IQ_FREEZE_STATE0_OFFSET);\r\npm8001_ha->gs_tbl.pm80xx_tbl.iq_freeze_state1 =\r\npm8001_mr32(address, GST_IQ_FREEZE_STATE1_OFFSET);\r\npm8001_ha->gs_tbl.pm80xx_tbl.msgu_tcnt =\r\npm8001_mr32(address, GST_MSGUTCNT_OFFSET);\r\npm8001_ha->gs_tbl.pm80xx_tbl.iop_tcnt =\r\npm8001_mr32(address, GST_IOPTCNT_OFFSET);\r\npm8001_ha->gs_tbl.pm80xx_tbl.gpio_input_val =\r\npm8001_mr32(address, GST_GPIO_INPUT_VAL);\r\npm8001_ha->gs_tbl.pm80xx_tbl.recover_err_info[0] =\r\npm8001_mr32(address, GST_RERRINFO_OFFSET0);\r\npm8001_ha->gs_tbl.pm80xx_tbl.recover_err_info[1] =\r\npm8001_mr32(address, GST_RERRINFO_OFFSET1);\r\npm8001_ha->gs_tbl.pm80xx_tbl.recover_err_info[2] =\r\npm8001_mr32(address, GST_RERRINFO_OFFSET2);\r\npm8001_ha->gs_tbl.pm80xx_tbl.recover_err_info[3] =\r\npm8001_mr32(address, GST_RERRINFO_OFFSET3);\r\npm8001_ha->gs_tbl.pm80xx_tbl.recover_err_info[4] =\r\npm8001_mr32(address, GST_RERRINFO_OFFSET4);\r\npm8001_ha->gs_tbl.pm80xx_tbl.recover_err_info[5] =\r\npm8001_mr32(address, GST_RERRINFO_OFFSET5);\r\npm8001_ha->gs_tbl.pm80xx_tbl.recover_err_info[6] =\r\npm8001_mr32(address, GST_RERRINFO_OFFSET6);\r\npm8001_ha->gs_tbl.pm80xx_tbl.recover_err_info[7] =\r\npm8001_mr32(address, GST_RERRINFO_OFFSET7);\r\n}\r\nstatic void read_phy_attr_table(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nvoid __iomem *address = pm8001_ha->pspa_q_tbl_addr;\r\npm8001_ha->phy_attr_table.phystart1_16[0] =\r\npm8001_mr32(address, PSPA_PHYSTATE0_OFFSET);\r\npm8001_ha->phy_attr_table.phystart1_16[1] =\r\npm8001_mr32(address, PSPA_PHYSTATE1_OFFSET);\r\npm8001_ha->phy_attr_table.phystart1_16[2] =\r\npm8001_mr32(address, PSPA_PHYSTATE2_OFFSET);\r\npm8001_ha->phy_attr_table.phystart1_16[3] =\r\npm8001_mr32(address, PSPA_PHYSTATE3_OFFSET);\r\npm8001_ha->phy_attr_table.phystart1_16[4] =\r\npm8001_mr32(address, PSPA_PHYSTATE4_OFFSET);\r\npm8001_ha->phy_attr_table.phystart1_16[5] =\r\npm8001_mr32(address, PSPA_PHYSTATE5_OFFSET);\r\npm8001_ha->phy_attr_table.phystart1_16[6] =\r\npm8001_mr32(address, PSPA_PHYSTATE6_OFFSET);\r\npm8001_ha->phy_attr_table.phystart1_16[7] =\r\npm8001_mr32(address, PSPA_PHYSTATE7_OFFSET);\r\npm8001_ha->phy_attr_table.phystart1_16[8] =\r\npm8001_mr32(address, PSPA_PHYSTATE8_OFFSET);\r\npm8001_ha->phy_attr_table.phystart1_16[9] =\r\npm8001_mr32(address, PSPA_PHYSTATE9_OFFSET);\r\npm8001_ha->phy_attr_table.phystart1_16[10] =\r\npm8001_mr32(address, PSPA_PHYSTATE10_OFFSET);\r\npm8001_ha->phy_attr_table.phystart1_16[11] =\r\npm8001_mr32(address, PSPA_PHYSTATE11_OFFSET);\r\npm8001_ha->phy_attr_table.phystart1_16[12] =\r\npm8001_mr32(address, PSPA_PHYSTATE12_OFFSET);\r\npm8001_ha->phy_attr_table.phystart1_16[13] =\r\npm8001_mr32(address, PSPA_PHYSTATE13_OFFSET);\r\npm8001_ha->phy_attr_table.phystart1_16[14] =\r\npm8001_mr32(address, PSPA_PHYSTATE14_OFFSET);\r\npm8001_ha->phy_attr_table.phystart1_16[15] =\r\npm8001_mr32(address, PSPA_PHYSTATE15_OFFSET);\r\npm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[0] =\r\npm8001_mr32(address, PSPA_OB_HW_EVENT_PID0_OFFSET);\r\npm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[1] =\r\npm8001_mr32(address, PSPA_OB_HW_EVENT_PID1_OFFSET);\r\npm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[2] =\r\npm8001_mr32(address, PSPA_OB_HW_EVENT_PID2_OFFSET);\r\npm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[3] =\r\npm8001_mr32(address, PSPA_OB_HW_EVENT_PID3_OFFSET);\r\npm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[4] =\r\npm8001_mr32(address, PSPA_OB_HW_EVENT_PID4_OFFSET);\r\npm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[5] =\r\npm8001_mr32(address, PSPA_OB_HW_EVENT_PID5_OFFSET);\r\npm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[6] =\r\npm8001_mr32(address, PSPA_OB_HW_EVENT_PID6_OFFSET);\r\npm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[7] =\r\npm8001_mr32(address, PSPA_OB_HW_EVENT_PID7_OFFSET);\r\npm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[8] =\r\npm8001_mr32(address, PSPA_OB_HW_EVENT_PID8_OFFSET);\r\npm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[9] =\r\npm8001_mr32(address, PSPA_OB_HW_EVENT_PID9_OFFSET);\r\npm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[10] =\r\npm8001_mr32(address, PSPA_OB_HW_EVENT_PID10_OFFSET);\r\npm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[11] =\r\npm8001_mr32(address, PSPA_OB_HW_EVENT_PID11_OFFSET);\r\npm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[12] =\r\npm8001_mr32(address, PSPA_OB_HW_EVENT_PID12_OFFSET);\r\npm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[13] =\r\npm8001_mr32(address, PSPA_OB_HW_EVENT_PID13_OFFSET);\r\npm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[14] =\r\npm8001_mr32(address, PSPA_OB_HW_EVENT_PID14_OFFSET);\r\npm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[15] =\r\npm8001_mr32(address, PSPA_OB_HW_EVENT_PID15_OFFSET);\r\n}\r\nstatic void read_inbnd_queue_table(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nint i;\r\nvoid __iomem *address = pm8001_ha->inbnd_q_tbl_addr;\r\nfor (i = 0; i < PM8001_MAX_SPCV_INB_NUM; i++) {\r\nu32 offset = i * 0x20;\r\npm8001_ha->inbnd_q_tbl[i].pi_pci_bar =\r\nget_pci_bar_index(pm8001_mr32(address,\r\n(offset + IB_PIPCI_BAR)));\r\npm8001_ha->inbnd_q_tbl[i].pi_offset =\r\npm8001_mr32(address, (offset + IB_PIPCI_BAR_OFFSET));\r\n}\r\n}\r\nstatic void read_outbnd_queue_table(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nint i;\r\nvoid __iomem *address = pm8001_ha->outbnd_q_tbl_addr;\r\nfor (i = 0; i < PM8001_MAX_SPCV_OUTB_NUM; i++) {\r\nu32 offset = i * 0x24;\r\npm8001_ha->outbnd_q_tbl[i].ci_pci_bar =\r\nget_pci_bar_index(pm8001_mr32(address,\r\n(offset + OB_CIPCI_BAR)));\r\npm8001_ha->outbnd_q_tbl[i].ci_offset =\r\npm8001_mr32(address, (offset + OB_CIPCI_BAR_OFFSET));\r\n}\r\n}\r\nstatic void init_default_table_values(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nint i;\r\nu32 offsetib, offsetob;\r\nvoid __iomem *addressib = pm8001_ha->inbnd_q_tbl_addr;\r\nvoid __iomem *addressob = pm8001_ha->outbnd_q_tbl_addr;\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.upper_event_log_addr =\r\npm8001_ha->memoryMap.region[AAP1].phys_addr_hi;\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.lower_event_log_addr =\r\npm8001_ha->memoryMap.region[AAP1].phys_addr_lo;\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.event_log_size =\r\nPM8001_EVENT_LOG_SIZE;\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.event_log_severity = 0x01;\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.upper_pcs_event_log_addr =\r\npm8001_ha->memoryMap.region[IOP].phys_addr_hi;\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.lower_pcs_event_log_addr =\r\npm8001_ha->memoryMap.region[IOP].phys_addr_lo;\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.pcs_event_log_size =\r\nPM8001_EVENT_LOG_SIZE;\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.pcs_event_log_severity = 0x01;\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.fatal_err_interrupt = 0x01;\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.crc_core_dump = (0x1 << 16);\r\nfor (i = 0; i < PM8001_MAX_SPCV_INB_NUM; i++) {\r\npm8001_ha->inbnd_q_tbl[i].element_pri_size_cnt =\r\nPM8001_MPI_QUEUE | (pm8001_ha->iomb_size << 16) | (0x00<<30);\r\npm8001_ha->inbnd_q_tbl[i].upper_base_addr =\r\npm8001_ha->memoryMap.region[IB + i].phys_addr_hi;\r\npm8001_ha->inbnd_q_tbl[i].lower_base_addr =\r\npm8001_ha->memoryMap.region[IB + i].phys_addr_lo;\r\npm8001_ha->inbnd_q_tbl[i].base_virt =\r\n(u8 *)pm8001_ha->memoryMap.region[IB + i].virt_ptr;\r\npm8001_ha->inbnd_q_tbl[i].total_length =\r\npm8001_ha->memoryMap.region[IB + i].total_len;\r\npm8001_ha->inbnd_q_tbl[i].ci_upper_base_addr =\r\npm8001_ha->memoryMap.region[CI + i].phys_addr_hi;\r\npm8001_ha->inbnd_q_tbl[i].ci_lower_base_addr =\r\npm8001_ha->memoryMap.region[CI + i].phys_addr_lo;\r\npm8001_ha->inbnd_q_tbl[i].ci_virt =\r\npm8001_ha->memoryMap.region[CI + i].virt_ptr;\r\noffsetib = i * 0x20;\r\npm8001_ha->inbnd_q_tbl[i].pi_pci_bar =\r\nget_pci_bar_index(pm8001_mr32(addressib,\r\n(offsetib + 0x14)));\r\npm8001_ha->inbnd_q_tbl[i].pi_offset =\r\npm8001_mr32(addressib, (offsetib + 0x18));\r\npm8001_ha->inbnd_q_tbl[i].producer_idx = 0;\r\npm8001_ha->inbnd_q_tbl[i].consumer_index = 0;\r\n}\r\nfor (i = 0; i < PM8001_MAX_SPCV_OUTB_NUM; i++) {\r\npm8001_ha->outbnd_q_tbl[i].element_size_cnt =\r\nPM8001_MPI_QUEUE | (pm8001_ha->iomb_size << 16) | (0x01<<30);\r\npm8001_ha->outbnd_q_tbl[i].upper_base_addr =\r\npm8001_ha->memoryMap.region[OB + i].phys_addr_hi;\r\npm8001_ha->outbnd_q_tbl[i].lower_base_addr =\r\npm8001_ha->memoryMap.region[OB + i].phys_addr_lo;\r\npm8001_ha->outbnd_q_tbl[i].base_virt =\r\n(u8 *)pm8001_ha->memoryMap.region[OB + i].virt_ptr;\r\npm8001_ha->outbnd_q_tbl[i].total_length =\r\npm8001_ha->memoryMap.region[OB + i].total_len;\r\npm8001_ha->outbnd_q_tbl[i].pi_upper_base_addr =\r\npm8001_ha->memoryMap.region[PI + i].phys_addr_hi;\r\npm8001_ha->outbnd_q_tbl[i].pi_lower_base_addr =\r\npm8001_ha->memoryMap.region[PI + i].phys_addr_lo;\r\npm8001_ha->outbnd_q_tbl[i].interrup_vec_cnt_delay = (i << 24);\r\npm8001_ha->outbnd_q_tbl[i].pi_virt =\r\npm8001_ha->memoryMap.region[PI + i].virt_ptr;\r\noffsetob = i * 0x24;\r\npm8001_ha->outbnd_q_tbl[i].ci_pci_bar =\r\nget_pci_bar_index(pm8001_mr32(addressob,\r\noffsetob + 0x14));\r\npm8001_ha->outbnd_q_tbl[i].ci_offset =\r\npm8001_mr32(addressob, (offsetob + 0x18));\r\npm8001_ha->outbnd_q_tbl[i].consumer_idx = 0;\r\npm8001_ha->outbnd_q_tbl[i].producer_index = 0;\r\n}\r\n}\r\nstatic void update_main_config_table(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nvoid __iomem *address = pm8001_ha->main_cfg_tbl_addr;\r\npm8001_mw32(address, MAIN_IQNPPD_HPPD_OFFSET,\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.inbound_q_nppd_hppd);\r\npm8001_mw32(address, MAIN_EVENT_LOG_ADDR_HI,\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.upper_event_log_addr);\r\npm8001_mw32(address, MAIN_EVENT_LOG_ADDR_LO,\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.lower_event_log_addr);\r\npm8001_mw32(address, MAIN_EVENT_LOG_BUFF_SIZE,\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.event_log_size);\r\npm8001_mw32(address, MAIN_EVENT_LOG_OPTION,\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.event_log_severity);\r\npm8001_mw32(address, MAIN_PCS_EVENT_LOG_ADDR_HI,\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.upper_pcs_event_log_addr);\r\npm8001_mw32(address, MAIN_PCS_EVENT_LOG_ADDR_LO,\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.lower_pcs_event_log_addr);\r\npm8001_mw32(address, MAIN_PCS_EVENT_LOG_BUFF_SIZE,\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.pcs_event_log_size);\r\npm8001_mw32(address, MAIN_PCS_EVENT_LOG_OPTION,\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.pcs_event_log_severity);\r\npm8001_mw32(address, MAIN_FATAL_ERROR_INTERRUPT,\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.fatal_err_interrupt);\r\npm8001_mw32(address, MAIN_EVENT_CRC_CHECK,\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.crc_core_dump);\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.gpio_led_mapping &= 0xCFFFFFFF;\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.gpio_led_mapping |= 0x20000000;\r\npm8001_mw32(address, MAIN_GPIO_LED_FLAGS_OFFSET,\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.gpio_led_mapping);\r\npm8001_mw32(address, MAIN_PORT_RECOVERY_TIMER,\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.port_recovery_timer);\r\npm8001_mw32(address, MAIN_INT_REASSERTION_DELAY,\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.interrupt_reassertion_delay);\r\n}\r\nstatic void update_inbnd_queue_table(struct pm8001_hba_info *pm8001_ha,\r\nint number)\r\n{\r\nvoid __iomem *address = pm8001_ha->inbnd_q_tbl_addr;\r\nu16 offset = number * 0x20;\r\npm8001_mw32(address, offset + IB_PROPERITY_OFFSET,\r\npm8001_ha->inbnd_q_tbl[number].element_pri_size_cnt);\r\npm8001_mw32(address, offset + IB_BASE_ADDR_HI_OFFSET,\r\npm8001_ha->inbnd_q_tbl[number].upper_base_addr);\r\npm8001_mw32(address, offset + IB_BASE_ADDR_LO_OFFSET,\r\npm8001_ha->inbnd_q_tbl[number].lower_base_addr);\r\npm8001_mw32(address, offset + IB_CI_BASE_ADDR_HI_OFFSET,\r\npm8001_ha->inbnd_q_tbl[number].ci_upper_base_addr);\r\npm8001_mw32(address, offset + IB_CI_BASE_ADDR_LO_OFFSET,\r\npm8001_ha->inbnd_q_tbl[number].ci_lower_base_addr);\r\n}\r\nstatic void update_outbnd_queue_table(struct pm8001_hba_info *pm8001_ha,\r\nint number)\r\n{\r\nvoid __iomem *address = pm8001_ha->outbnd_q_tbl_addr;\r\nu16 offset = number * 0x24;\r\npm8001_mw32(address, offset + OB_PROPERITY_OFFSET,\r\npm8001_ha->outbnd_q_tbl[number].element_size_cnt);\r\npm8001_mw32(address, offset + OB_BASE_ADDR_HI_OFFSET,\r\npm8001_ha->outbnd_q_tbl[number].upper_base_addr);\r\npm8001_mw32(address, offset + OB_BASE_ADDR_LO_OFFSET,\r\npm8001_ha->outbnd_q_tbl[number].lower_base_addr);\r\npm8001_mw32(address, offset + OB_PI_BASE_ADDR_HI_OFFSET,\r\npm8001_ha->outbnd_q_tbl[number].pi_upper_base_addr);\r\npm8001_mw32(address, offset + OB_PI_BASE_ADDR_LO_OFFSET,\r\npm8001_ha->outbnd_q_tbl[number].pi_lower_base_addr);\r\npm8001_mw32(address, offset + OB_INTERRUPT_COALES_OFFSET,\r\npm8001_ha->outbnd_q_tbl[number].interrup_vec_cnt_delay);\r\n}\r\nstatic int mpi_init_check(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu32 max_wait_count;\r\nu32 value;\r\nu32 gst_len_mpistate;\r\npm8001_cw32(pm8001_ha, 0, MSGU_IBDB_SET, SPCv_MSGU_CFG_TABLE_UPDATE);\r\nmax_wait_count = 2 * 1000 * 1000;\r\ndo {\r\nudelay(1);\r\nvalue = pm8001_cr32(pm8001_ha, 0, MSGU_IBDB_SET);\r\nvalue &= SPCv_MSGU_CFG_TABLE_UPDATE;\r\n} while ((value != 0) && (--max_wait_count));\r\nif (!max_wait_count)\r\nreturn -1;\r\nmax_wait_count = 100 * 1000;\r\ndo {\r\nudelay(1);\r\ngst_len_mpistate =\r\npm8001_mr32(pm8001_ha->general_stat_tbl_addr,\r\nGST_GSTLEN_MPIS_OFFSET);\r\n} while ((GST_MPI_STATE_INIT !=\r\n(gst_len_mpistate & GST_MPI_STATE_MASK)) && (--max_wait_count));\r\nif (!max_wait_count)\r\nreturn -1;\r\ngst_len_mpistate = gst_len_mpistate >> 16;\r\nif (0x0000 != gst_len_mpistate)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int check_fw_ready(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu32 value;\r\nu32 max_wait_count;\r\nu32 max_wait_time;\r\nint ret = 0;\r\nmax_wait_time = max_wait_count = 100 * 1000;\r\ndo {\r\nudelay(1);\r\nvalue = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1);\r\n} while ((value == 0xFFFFFFFF) && (--max_wait_count));\r\nmax_wait_time = max_wait_count = 1000 * 1000;\r\ndo {\r\nudelay(1);\r\nvalue = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1);\r\n} while (((value & SCRATCH_PAD_ILA_READY) !=\r\nSCRATCH_PAD_ILA_READY) && (--max_wait_count));\r\nif (!max_wait_count)\r\nret = -1;\r\nelse {\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" ila ready status in %d millisec\n",\r\n(max_wait_time - max_wait_count)));\r\n}\r\nmax_wait_time = max_wait_count = 1800 * 1000;\r\ndo {\r\nudelay(1);\r\nvalue = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1);\r\n} while (((value & SCRATCH_PAD_RAAE_READY) !=\r\nSCRATCH_PAD_RAAE_READY) && (--max_wait_count));\r\nif (!max_wait_count)\r\nret = -1;\r\nelse {\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" raae ready status in %d millisec\n",\r\n(max_wait_time - max_wait_count)));\r\n}\r\nmax_wait_time = max_wait_count = 600 * 1000;\r\ndo {\r\nudelay(1);\r\nvalue = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1);\r\n} while (((value & SCRATCH_PAD_IOP0_READY) != SCRATCH_PAD_IOP0_READY) &&\r\n(--max_wait_count));\r\nif (!max_wait_count)\r\nret = -1;\r\nelse {\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" iop0 ready status in %d millisec\n",\r\n(max_wait_time - max_wait_count)));\r\n}\r\nif ((pm8001_ha->chip_id != chip_8008) &&\r\n(pm8001_ha->chip_id != chip_8009)) {\r\nmax_wait_time = max_wait_count = 200 * 1000;\r\ndo {\r\nudelay(1);\r\nvalue = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1);\r\n} while (((value & SCRATCH_PAD_IOP1_READY) !=\r\nSCRATCH_PAD_IOP1_READY) && (--max_wait_count));\r\nif (!max_wait_count)\r\nret = -1;\r\nelse {\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"iop1 ready status in %d millisec\n",\r\n(max_wait_time - max_wait_count)));\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void init_pci_device_addresses(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nvoid __iomem *base_addr;\r\nu32 value;\r\nu32 offset;\r\nu32 pcibar;\r\nu32 pcilogic;\r\nvalue = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_0);\r\noffset = value & 0x03FFFFFF;\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("Scratchpad 0 Offset: 0x%x value 0x%x\n",\r\noffset, value));\r\npcilogic = (value & 0xFC000000) >> 26;\r\npcibar = get_pci_bar_index(pcilogic);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("Scratchpad 0 PCI BAR: %d\n", pcibar));\r\npm8001_ha->main_cfg_tbl_addr = base_addr =\r\npm8001_ha->io_mem[pcibar].memvirtaddr + offset;\r\npm8001_ha->general_stat_tbl_addr =\r\nbase_addr + (pm8001_cr32(pm8001_ha, pcibar, offset + 0x18) &\r\n0xFFFFFF);\r\npm8001_ha->inbnd_q_tbl_addr =\r\nbase_addr + (pm8001_cr32(pm8001_ha, pcibar, offset + 0x1C) &\r\n0xFFFFFF);\r\npm8001_ha->outbnd_q_tbl_addr =\r\nbase_addr + (pm8001_cr32(pm8001_ha, pcibar, offset + 0x20) &\r\n0xFFFFFF);\r\npm8001_ha->ivt_tbl_addr =\r\nbase_addr + (pm8001_cr32(pm8001_ha, pcibar, offset + 0x8C) &\r\n0xFFFFFF);\r\npm8001_ha->pspa_q_tbl_addr =\r\nbase_addr + (pm8001_cr32(pm8001_ha, pcibar, offset + 0x90) &\r\n0xFFFFFF);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("GST OFFSET 0x%x\n",\r\npm8001_cr32(pm8001_ha, pcibar, offset + 0x18)));\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("INBND OFFSET 0x%x\n",\r\npm8001_cr32(pm8001_ha, pcibar, offset + 0x1C)));\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("OBND OFFSET 0x%x\n",\r\npm8001_cr32(pm8001_ha, pcibar, offset + 0x20)));\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("IVT OFFSET 0x%x\n",\r\npm8001_cr32(pm8001_ha, pcibar, offset + 0x8C)));\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("PSPA OFFSET 0x%x\n",\r\npm8001_cr32(pm8001_ha, pcibar, offset + 0x90)));\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("addr - main cfg %p general status %p\n",\r\npm8001_ha->main_cfg_tbl_addr,\r\npm8001_ha->general_stat_tbl_addr));\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("addr - inbnd %p obnd %p\n",\r\npm8001_ha->inbnd_q_tbl_addr,\r\npm8001_ha->outbnd_q_tbl_addr));\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("addr - pspa %p ivt %p\n",\r\npm8001_ha->pspa_q_tbl_addr,\r\npm8001_ha->ivt_tbl_addr));\r\n}\r\nint\r\npm80xx_set_thermal_config(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nstruct set_ctrl_cfg_req payload;\r\nstruct inbound_queue_table *circularQ;\r\nint rc;\r\nu32 tag;\r\nu32 opc = OPC_INB_SET_CONTROLLER_CONFIG;\r\nmemset(&payload, 0, sizeof(struct set_ctrl_cfg_req));\r\nrc = pm8001_tag_alloc(pm8001_ha, &tag);\r\nif (rc)\r\nreturn -1;\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\npayload.tag = cpu_to_le32(tag);\r\npayload.cfg_pg[0] = (THERMAL_LOG_ENABLE << 9) |\r\n(THERMAL_ENABLE << 8) | THERMAL_OP_CODE;\r\npayload.cfg_pg[1] = (LTEMPHIL << 24) | (RTEMPHIL << 8);\r\nrc = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &payload, 0);\r\nreturn rc;\r\n}\r\nstatic int\r\npm80xx_set_sas_protocol_timer_config(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nstruct set_ctrl_cfg_req payload;\r\nstruct inbound_queue_table *circularQ;\r\nSASProtocolTimerConfig_t SASConfigPage;\r\nint rc;\r\nu32 tag;\r\nu32 opc = OPC_INB_SET_CONTROLLER_CONFIG;\r\nmemset(&payload, 0, sizeof(struct set_ctrl_cfg_req));\r\nmemset(&SASConfigPage, 0, sizeof(SASProtocolTimerConfig_t));\r\nrc = pm8001_tag_alloc(pm8001_ha, &tag);\r\nif (rc)\r\nreturn -1;\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\npayload.tag = cpu_to_le32(tag);\r\nSASConfigPage.pageCode = SAS_PROTOCOL_TIMER_CONFIG_PAGE;\r\nSASConfigPage.MST_MSI = 3 << 15;\r\nSASConfigPage.STP_SSP_MCT_TMO = (STP_MCT_TMO << 16) | SSP_MCT_TMO;\r\nSASConfigPage.STP_FRM_TMO = (SAS_MAX_OPEN_TIME << 24) |\r\n(SMP_MAX_CONN_TIMER << 16) | STP_FRM_TIMER;\r\nSASConfigPage.STP_IDLE_TMO = STP_IDLE_TIME;\r\nif (SASConfigPage.STP_IDLE_TMO > 0x3FFFFFF)\r\nSASConfigPage.STP_IDLE_TMO = 0x3FFFFFF;\r\nSASConfigPage.OPNRJT_RTRY_INTVL = (SAS_MFD << 16) |\r\nSAS_OPNRJT_RTRY_INTVL;\r\nSASConfigPage.Data_Cmd_OPNRJT_RTRY_TMO = (SAS_DOPNRJT_RTRY_TMO << 16)\r\n| SAS_COPNRJT_RTRY_TMO;\r\nSASConfigPage.Data_Cmd_OPNRJT_RTRY_THR = (SAS_DOPNRJT_RTRY_THR << 16)\r\n| SAS_COPNRJT_RTRY_THR;\r\nSASConfigPage.MAX_AIP = SAS_MAX_AIP;\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("SASConfigPage.pageCode "\r\n"0x%08x\n", SASConfigPage.pageCode));\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("SASConfigPage.MST_MSI "\r\n" 0x%08x\n", SASConfigPage.MST_MSI));\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("SASConfigPage.STP_SSP_MCT_TMO "\r\n" 0x%08x\n", SASConfigPage.STP_SSP_MCT_TMO));\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("SASConfigPage.STP_FRM_TMO "\r\n" 0x%08x\n", SASConfigPage.STP_FRM_TMO));\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("SASConfigPage.STP_IDLE_TMO "\r\n" 0x%08x\n", SASConfigPage.STP_IDLE_TMO));\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("SASConfigPage.OPNRJT_RTRY_INTVL "\r\n" 0x%08x\n", SASConfigPage.OPNRJT_RTRY_INTVL));\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("SASConfigPage.Data_Cmd_OPNRJT_RTRY_TMO "\r\n" 0x%08x\n", SASConfigPage.Data_Cmd_OPNRJT_RTRY_TMO));\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("SASConfigPage.Data_Cmd_OPNRJT_RTRY_THR "\r\n" 0x%08x\n", SASConfigPage.Data_Cmd_OPNRJT_RTRY_THR));\r\nPM8001_INIT_DBG(pm8001_ha, pm8001_printk("SASConfigPage.MAX_AIP "\r\n" 0x%08x\n", SASConfigPage.MAX_AIP));\r\nmemcpy(&payload.cfg_pg, &SASConfigPage,\r\nsizeof(SASProtocolTimerConfig_t));\r\nrc = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &payload, 0);\r\nreturn rc;\r\n}\r\nstatic int\r\npm80xx_get_encrypt_info(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu32 scratch3_value;\r\nint ret;\r\nscratch3_value = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_3);\r\nif ((scratch3_value & SCRATCH_PAD3_ENC_MASK) ==\r\nSCRATCH_PAD3_ENC_READY) {\r\nif (scratch3_value & SCRATCH_PAD3_XTS_ENABLED)\r\npm8001_ha->encrypt_info.cipher_mode = CIPHER_MODE_XTS;\r\nif ((scratch3_value & SCRATCH_PAD3_SM_MASK) ==\r\nSCRATCH_PAD3_SMF_ENABLED)\r\npm8001_ha->encrypt_info.sec_mode = SEC_MODE_SMF;\r\nif ((scratch3_value & SCRATCH_PAD3_SM_MASK) ==\r\nSCRATCH_PAD3_SMA_ENABLED)\r\npm8001_ha->encrypt_info.sec_mode = SEC_MODE_SMA;\r\nif ((scratch3_value & SCRATCH_PAD3_SM_MASK) ==\r\nSCRATCH_PAD3_SMB_ENABLED)\r\npm8001_ha->encrypt_info.sec_mode = SEC_MODE_SMB;\r\npm8001_ha->encrypt_info.status = 0;\r\nPM8001_INIT_DBG(pm8001_ha, pm8001_printk(\r\n"Encryption: SCRATCH_PAD3_ENC_READY 0x%08X."\r\n"Cipher mode 0x%x Sec mode 0x%x status 0x%x\n",\r\nscratch3_value, pm8001_ha->encrypt_info.cipher_mode,\r\npm8001_ha->encrypt_info.sec_mode,\r\npm8001_ha->encrypt_info.status));\r\nret = 0;\r\n} else if ((scratch3_value & SCRATCH_PAD3_ENC_READY) ==\r\nSCRATCH_PAD3_ENC_DISABLED) {\r\nPM8001_INIT_DBG(pm8001_ha, pm8001_printk(\r\n"Encryption: SCRATCH_PAD3_ENC_DISABLED 0x%08X\n",\r\nscratch3_value));\r\npm8001_ha->encrypt_info.status = 0xFFFFFFFF;\r\npm8001_ha->encrypt_info.cipher_mode = 0;\r\npm8001_ha->encrypt_info.sec_mode = 0;\r\nreturn 0;\r\n} else if ((scratch3_value & SCRATCH_PAD3_ENC_MASK) ==\r\nSCRATCH_PAD3_ENC_DIS_ERR) {\r\npm8001_ha->encrypt_info.status =\r\n(scratch3_value & SCRATCH_PAD3_ERR_CODE) >> 16;\r\nif (scratch3_value & SCRATCH_PAD3_XTS_ENABLED)\r\npm8001_ha->encrypt_info.cipher_mode = CIPHER_MODE_XTS;\r\nif ((scratch3_value & SCRATCH_PAD3_SM_MASK) ==\r\nSCRATCH_PAD3_SMF_ENABLED)\r\npm8001_ha->encrypt_info.sec_mode = SEC_MODE_SMF;\r\nif ((scratch3_value & SCRATCH_PAD3_SM_MASK) ==\r\nSCRATCH_PAD3_SMA_ENABLED)\r\npm8001_ha->encrypt_info.sec_mode = SEC_MODE_SMA;\r\nif ((scratch3_value & SCRATCH_PAD3_SM_MASK) ==\r\nSCRATCH_PAD3_SMB_ENABLED)\r\npm8001_ha->encrypt_info.sec_mode = SEC_MODE_SMB;\r\nPM8001_INIT_DBG(pm8001_ha, pm8001_printk(\r\n"Encryption: SCRATCH_PAD3_DIS_ERR 0x%08X."\r\n"Cipher mode 0x%x sec mode 0x%x status 0x%x\n",\r\nscratch3_value, pm8001_ha->encrypt_info.cipher_mode,\r\npm8001_ha->encrypt_info.sec_mode,\r\npm8001_ha->encrypt_info.status));\r\nret = -1;\r\n} else if ((scratch3_value & SCRATCH_PAD3_ENC_MASK) ==\r\nSCRATCH_PAD3_ENC_ENA_ERR) {\r\npm8001_ha->encrypt_info.status =\r\n(scratch3_value & SCRATCH_PAD3_ERR_CODE) >> 16;\r\nif (scratch3_value & SCRATCH_PAD3_XTS_ENABLED)\r\npm8001_ha->encrypt_info.cipher_mode = CIPHER_MODE_XTS;\r\nif ((scratch3_value & SCRATCH_PAD3_SM_MASK) ==\r\nSCRATCH_PAD3_SMF_ENABLED)\r\npm8001_ha->encrypt_info.sec_mode = SEC_MODE_SMF;\r\nif ((scratch3_value & SCRATCH_PAD3_SM_MASK) ==\r\nSCRATCH_PAD3_SMA_ENABLED)\r\npm8001_ha->encrypt_info.sec_mode = SEC_MODE_SMA;\r\nif ((scratch3_value & SCRATCH_PAD3_SM_MASK) ==\r\nSCRATCH_PAD3_SMB_ENABLED)\r\npm8001_ha->encrypt_info.sec_mode = SEC_MODE_SMB;\r\nPM8001_INIT_DBG(pm8001_ha, pm8001_printk(\r\n"Encryption: SCRATCH_PAD3_ENA_ERR 0x%08X."\r\n"Cipher mode 0x%x sec mode 0x%x status 0x%x\n",\r\nscratch3_value, pm8001_ha->encrypt_info.cipher_mode,\r\npm8001_ha->encrypt_info.sec_mode,\r\npm8001_ha->encrypt_info.status));\r\nret = -1;\r\n}\r\nreturn ret;\r\n}\r\nstatic int pm80xx_encrypt_update(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nstruct kek_mgmt_req payload;\r\nstruct inbound_queue_table *circularQ;\r\nint rc;\r\nu32 tag;\r\nu32 opc = OPC_INB_KEK_MANAGEMENT;\r\nmemset(&payload, 0, sizeof(struct kek_mgmt_req));\r\nrc = pm8001_tag_alloc(pm8001_ha, &tag);\r\nif (rc)\r\nreturn -1;\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\npayload.tag = cpu_to_le32(tag);\r\npayload.new_curidx_ksop = ((1 << 24) | (1 << 16) | (1 << 8) |\r\nKEK_MGMT_SUBOP_KEYCARDUPDATE);\r\nrc = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &payload, 0);\r\nreturn rc;\r\n}\r\nstatic int pm80xx_chip_init(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nint ret;\r\nu8 i = 0;\r\nif (-1 == check_fw_ready(pm8001_ha)) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Firmware is not ready!\n"));\r\nreturn -EBUSY;\r\n}\r\ninit_pci_device_addresses(pm8001_ha);\r\ninit_default_table_values(pm8001_ha);\r\nread_main_config_table(pm8001_ha);\r\nread_general_status_table(pm8001_ha);\r\nread_inbnd_queue_table(pm8001_ha);\r\nread_outbnd_queue_table(pm8001_ha);\r\nread_phy_attr_table(pm8001_ha);\r\nupdate_main_config_table(pm8001_ha);\r\nfor (i = 0; i < PM8001_MAX_SPCV_INB_NUM; i++)\r\nupdate_inbnd_queue_table(pm8001_ha, i);\r\nfor (i = 0; i < PM8001_MAX_SPCV_OUTB_NUM; i++)\r\nupdate_outbnd_queue_table(pm8001_ha, i);\r\nif (0 == mpi_init_check(pm8001_ha)) {\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("MPI initialize successful!\n"));\r\n} else\r\nreturn -EBUSY;\r\nret = pm80xx_set_sas_protocol_timer_config(pm8001_ha);\r\nif (pm8001_ha->chip->encrypt) {\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("Checking for encryption\n"));\r\nret = pm80xx_get_encrypt_info(pm8001_ha);\r\nif (ret == -1) {\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("Encryption error !!\n"));\r\nif (pm8001_ha->encrypt_info.status == 0x81) {\r\nPM8001_INIT_DBG(pm8001_ha, pm8001_printk(\r\n"Encryption enabled with error."\r\n"Saving encryption key to flash\n"));\r\npm80xx_encrypt_update(pm8001_ha);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpi_uninit_check(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu32 max_wait_count;\r\nu32 value;\r\nu32 gst_len_mpistate;\r\ninit_pci_device_addresses(pm8001_ha);\r\npm8001_cw32(pm8001_ha, 0, MSGU_IBDB_SET, SPCv_MSGU_CFG_TABLE_RESET);\r\nmax_wait_count = 2 * 1000 * 1000;\r\ndo {\r\nudelay(1);\r\nvalue = pm8001_cr32(pm8001_ha, 0, MSGU_IBDB_SET);\r\nvalue &= SPCv_MSGU_CFG_TABLE_RESET;\r\n} while ((value != 0) && (--max_wait_count));\r\nif (!max_wait_count) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("TIMEOUT:IBDB value/=%x\n", value));\r\nreturn -1;\r\n}\r\nmax_wait_count = 2 * 1000 * 1000;\r\ndo {\r\nudelay(1);\r\ngst_len_mpistate =\r\npm8001_mr32(pm8001_ha->general_stat_tbl_addr,\r\nGST_GSTLEN_MPIS_OFFSET);\r\nif (GST_MPI_STATE_UNINIT ==\r\n(gst_len_mpistate & GST_MPI_STATE_MASK))\r\nbreak;\r\n} while (--max_wait_count);\r\nif (!max_wait_count) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk(" TIME OUT MPI State = 0x%x\n",\r\ngst_len_mpistate & GST_MPI_STATE_MASK));\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\npm80xx_chip_soft_rst(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu32 regval;\r\nu32 bootloader_state;\r\nif (mpi_uninit_check(pm8001_ha) != 0) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("MPI state is not ready\n"));\r\nreturn -1;\r\n}\r\nregval = pm8001_cr32(pm8001_ha, 0, SPC_REG_SOFT_RESET);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("reset register before write : 0x%x\n", regval));\r\npm8001_cw32(pm8001_ha, 0, SPC_REG_SOFT_RESET, SPCv_NORMAL_RESET_VALUE);\r\nmdelay(500);\r\nregval = pm8001_cr32(pm8001_ha, 0, SPC_REG_SOFT_RESET);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("reset register after write 0x%x\n", regval));\r\nif ((regval & SPCv_SOFT_RESET_READ_MASK) ==\r\nSPCv_SOFT_RESET_NORMAL_RESET_OCCURED) {\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" soft reset successful [regval: 0x%x]\n",\r\nregval));\r\n} else {\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" soft reset failed [regval: 0x%x]\n",\r\nregval));\r\nbootloader_state =\r\npm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1) &\r\nSCRATCH_PAD1_BOOTSTATE_MASK;\r\nif (bootloader_state == SCRATCH_PAD1_BOOTSTATE_HDA_SEEPROM) {\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"Bootloader state - HDA mode SEEPROM\n"));\r\n} else if (bootloader_state ==\r\nSCRATCH_PAD1_BOOTSTATE_HDA_BOOTSTRAP) {\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"Bootloader state - HDA mode Bootstrap Pin\n"));\r\n} else if (bootloader_state ==\r\nSCRATCH_PAD1_BOOTSTATE_HDA_SOFTRESET) {\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"Bootloader state - HDA mode soft reset\n"));\r\n} else if (bootloader_state ==\r\nSCRATCH_PAD1_BOOTSTATE_CRIT_ERROR) {\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"Bootloader state-HDA mode critical error\n"));\r\n}\r\nreturn -EBUSY;\r\n}\r\nif (-1 == check_fw_ready(pm8001_ha)) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Firmware is not ready!\n"));\r\nreturn -EBUSY;\r\n}\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("SPCv soft reset Complete\n"));\r\nreturn 0;\r\n}\r\nstatic void pm80xx_hw_chip_rst(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu32 i;\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("chip reset start\n"));\r\npm8001_cw32(pm8001_ha, 0, SPC_REG_SOFT_RESET, 0x11);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("SPC soft reset Complete\n"));\r\nudelay(10);\r\ni = 20;\r\ndo {\r\nmdelay(1);\r\n} while ((--i) != 0);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("chip reset finished\n"));\r\n}\r\nstatic void\r\npm80xx_chip_intx_interrupt_enable(struct pm8001_hba_info *pm8001_ha)\r\n{\r\npm8001_cw32(pm8001_ha, 0, MSGU_ODMR, ODMR_CLEAR_ALL);\r\npm8001_cw32(pm8001_ha, 0, MSGU_ODCR, ODCR_CLEAR_ALL);\r\n}\r\nstatic void\r\npm80xx_chip_intx_interrupt_disable(struct pm8001_hba_info *pm8001_ha)\r\n{\r\npm8001_cw32(pm8001_ha, 0, MSGU_ODMR_CLR, ODMR_MASK_ALL);\r\n}\r\nstatic void\r\npm80xx_chip_interrupt_enable(struct pm8001_hba_info *pm8001_ha, u8 vec)\r\n{\r\n#ifdef PM8001_USE_MSIX\r\nu32 mask;\r\nmask = (u32)(1 << vec);\r\npm8001_cw32(pm8001_ha, 0, MSGU_ODMR_CLR, (u32)(mask & 0xFFFFFFFF));\r\nreturn;\r\n#endif\r\npm80xx_chip_intx_interrupt_enable(pm8001_ha);\r\n}\r\nstatic void\r\npm80xx_chip_interrupt_disable(struct pm8001_hba_info *pm8001_ha, u8 vec)\r\n{\r\n#ifdef PM8001_USE_MSIX\r\nu32 mask;\r\nif (vec == 0xFF)\r\nmask = 0xFFFFFFFF;\r\nelse\r\nmask = (u32)(1 << vec);\r\npm8001_cw32(pm8001_ha, 0, MSGU_ODMR, (u32)(mask & 0xFFFFFFFF));\r\nreturn;\r\n#endif\r\npm80xx_chip_intx_interrupt_disable(pm8001_ha);\r\n}\r\nstatic void pm80xx_send_abort_all(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_device *pm8001_ha_dev)\r\n{\r\nint res;\r\nu32 ccb_tag;\r\nstruct pm8001_ccb_info *ccb;\r\nstruct sas_task *task = NULL;\r\nstruct task_abort_req task_abort;\r\nstruct inbound_queue_table *circularQ;\r\nu32 opc = OPC_INB_SATA_ABORT;\r\nint ret;\r\nif (!pm8001_ha_dev) {\r\nPM8001_FAIL_DBG(pm8001_ha, pm8001_printk("dev is null\n"));\r\nreturn;\r\n}\r\ntask = sas_alloc_slow_task(GFP_ATOMIC);\r\nif (!task) {\r\nPM8001_FAIL_DBG(pm8001_ha, pm8001_printk("cannot "\r\n"allocate task\n"));\r\nreturn;\r\n}\r\ntask->task_done = pm8001_task_done;\r\nres = pm8001_tag_alloc(pm8001_ha, &ccb_tag);\r\nif (res)\r\nreturn;\r\nccb = &pm8001_ha->ccb_info[ccb_tag];\r\nccb->device = pm8001_ha_dev;\r\nccb->ccb_tag = ccb_tag;\r\nccb->task = task;\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nmemset(&task_abort, 0, sizeof(task_abort));\r\ntask_abort.abort_all = cpu_to_le32(1);\r\ntask_abort.device_id = cpu_to_le32(pm8001_ha_dev->device_id);\r\ntask_abort.tag = cpu_to_le32(ccb_tag);\r\nret = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &task_abort, 0);\r\n}\r\nstatic void pm80xx_send_read_log(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_device *pm8001_ha_dev)\r\n{\r\nstruct sata_start_req sata_cmd;\r\nint res;\r\nu32 ccb_tag;\r\nstruct pm8001_ccb_info *ccb;\r\nstruct sas_task *task = NULL;\r\nstruct host_to_dev_fis fis;\r\nstruct domain_device *dev;\r\nstruct inbound_queue_table *circularQ;\r\nu32 opc = OPC_INB_SATA_HOST_OPSTART;\r\ntask = sas_alloc_slow_task(GFP_ATOMIC);\r\nif (!task) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("cannot allocate task !!!\n"));\r\nreturn;\r\n}\r\ntask->task_done = pm8001_task_done;\r\nres = pm8001_tag_alloc(pm8001_ha, &ccb_tag);\r\nif (res) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("cannot allocate tag !!!\n"));\r\nreturn;\r\n}\r\ndev = kzalloc(sizeof(struct domain_device), GFP_ATOMIC);\r\nif (!dev) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Domain device cannot be allocated\n"));\r\nsas_free_task(task);\r\nreturn;\r\n} else {\r\ntask->dev = dev;\r\ntask->dev->lldd_dev = pm8001_ha_dev;\r\n}\r\nccb = &pm8001_ha->ccb_info[ccb_tag];\r\nccb->device = pm8001_ha_dev;\r\nccb->ccb_tag = ccb_tag;\r\nccb->task = task;\r\npm8001_ha_dev->id |= NCQ_READ_LOG_FLAG;\r\npm8001_ha_dev->id |= NCQ_2ND_RLE_FLAG;\r\nmemset(&sata_cmd, 0, sizeof(sata_cmd));\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nmemset(&fis, 0, sizeof(struct host_to_dev_fis));\r\nfis.fis_type = 0x27;\r\nfis.flags = 0x80;\r\nfis.command = ATA_CMD_READ_LOG_EXT;\r\nfis.lbal = 0x10;\r\nfis.sector_count = 0x1;\r\nsata_cmd.tag = cpu_to_le32(ccb_tag);\r\nsata_cmd.device_id = cpu_to_le32(pm8001_ha_dev->device_id);\r\nsata_cmd.ncqtag_atap_dir_m_dad |= ((0x1 << 7) | (0x5 << 9));\r\nmemcpy(&sata_cmd.sata_fis, &fis, sizeof(struct host_to_dev_fis));\r\nres = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &sata_cmd, 0);\r\n}\r\nstatic void\r\nmpi_ssp_completion(struct pm8001_hba_info *pm8001_ha , void *piomb)\r\n{\r\nstruct sas_task *t;\r\nstruct pm8001_ccb_info *ccb;\r\nunsigned long flags;\r\nu32 status;\r\nu32 param;\r\nu32 tag;\r\nstruct ssp_completion_resp *psspPayload;\r\nstruct task_status_struct *ts;\r\nstruct ssp_response_iu *iu;\r\nstruct pm8001_device *pm8001_dev;\r\npsspPayload = (struct ssp_completion_resp *)(piomb + 4);\r\nstatus = le32_to_cpu(psspPayload->status);\r\ntag = le32_to_cpu(psspPayload->tag);\r\nccb = &pm8001_ha->ccb_info[tag];\r\nif ((status == IO_ABORTED) && ccb->open_retry) {\r\nccb->open_retry = 0;\r\nreturn;\r\n}\r\npm8001_dev = ccb->device;\r\nparam = le32_to_cpu(psspPayload->param);\r\nt = ccb->task;\r\nif (status && status != IO_UNDERFLOW)\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("sas IO status 0x%x\n", status));\r\nif (unlikely(!t || !t->lldd_task || !t->dev))\r\nreturn;\r\nts = &t->task_status;\r\nswitch (status) {\r\ncase IO_SUCCESS:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_SUCCESS ,param = 0x%x\n",\r\nparam));\r\nif (param == 0) {\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAM_STAT_GOOD;\r\n} else {\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_PROTO_RESPONSE;\r\nts->residual = param;\r\niu = &psspPayload->ssp_resp_iu;\r\nsas_ssp_task_response(pm8001_ha->dev, t, iu);\r\n}\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nbreak;\r\ncase IO_ABORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_ABORTED IOMB Tag\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_ABORTED_TASK;\r\nbreak;\r\ncase IO_UNDERFLOW:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_UNDERFLOW ,param = 0x%x\n",\r\nparam));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_UNDERRUN;\r\nts->residual = param;\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nbreak;\r\ncase IO_NO_DEVICE:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_NO_DEVICE\n"));\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_PHY_DOWN;\r\nbreak;\r\ncase IO_XFER_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_BREAK\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_XFER_ERROR_PHY_NOT_READY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_PHY_NOT_READY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_EPROTO;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_ZONE_VIOLATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BREAK\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\r\ncase IO_XFER_OPEN_RETRY_BACKOFF_THRESHOLD_REACHED:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_TMO:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_NO_DEST:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_COLLIDE:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_PATHWAY_BLOCKED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\nif (!t->uldd_task)\r\npm8001_handle_event(pm8001_ha,\r\npm8001_dev,\r\nIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BAD_DESTINATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_BAD_DEST;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_CONN_RATE;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_WRONG_DESTINATION\n"));\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_WRONG_DEST;\r\nbreak;\r\ncase IO_XFER_ERROR_NAK_RECEIVED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_NAK_RECEIVED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_XFER_ERROR_ACK_NAK_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_ACK_NAK_TIMEOUT\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_NAK_R_ERR;\r\nbreak;\r\ncase IO_XFER_ERROR_DMA:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_DMA\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nbreak;\r\ncase IO_XFER_OPEN_RETRY_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_OPEN_RETRY_TIMEOUT\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_XFER_ERROR_OFFSET_MISMATCH:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_OFFSET_MISMATCH\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nbreak;\r\ncase IO_PORT_IN_RESET:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_PORT_IN_RESET\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nbreak;\r\ncase IO_DS_NON_OPERATIONAL:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_DS_NON_OPERATIONAL\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nif (!t->uldd_task)\r\npm8001_handle_event(pm8001_ha,\r\npm8001_dev,\r\nIO_DS_NON_OPERATIONAL);\r\nbreak;\r\ncase IO_DS_IN_RECOVERY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_DS_IN_RECOVERY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nbreak;\r\ncase IO_TM_TAG_NOT_FOUND:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_TM_TAG_NOT_FOUND\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nbreak;\r\ncase IO_SSP_EXT_IU_ZERO_LEN_ERROR:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_SSP_EXT_IU_ZERO_LEN_ERROR\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ndefault:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("Unknown status 0x%x\n", status));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nbreak;\r\n}\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("scsi_status = 0x%x\n ",\r\npsspPayload->ssp_resp_iu.status));\r\nspin_lock_irqsave(&t->task_state_lock, flags);\r\nt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\r\nt->task_state_flags &= ~SAS_TASK_AT_INITIATOR;\r\nt->task_state_flags |= SAS_TASK_STATE_DONE;\r\nif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\nPM8001_FAIL_DBG(pm8001_ha, pm8001_printk(\r\n"task 0x%p done with io_status 0x%x resp 0x%x "\r\n"stat 0x%x but aborted by upper layer!\n",\r\nt, status, ts->resp, ts->stat));\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\n} else {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nt->task_done(t);\r\n}\r\n}\r\nstatic void mpi_ssp_event(struct pm8001_hba_info *pm8001_ha , void *piomb)\r\n{\r\nstruct sas_task *t;\r\nunsigned long flags;\r\nstruct task_status_struct *ts;\r\nstruct pm8001_ccb_info *ccb;\r\nstruct pm8001_device *pm8001_dev;\r\nstruct ssp_event_resp *psspPayload =\r\n(struct ssp_event_resp *)(piomb + 4);\r\nu32 event = le32_to_cpu(psspPayload->event);\r\nu32 tag = le32_to_cpu(psspPayload->tag);\r\nu32 port_id = le32_to_cpu(psspPayload->port_id);\r\nccb = &pm8001_ha->ccb_info[tag];\r\nt = ccb->task;\r\npm8001_dev = ccb->device;\r\nif (event)\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("sas IO status 0x%x\n", event));\r\nif (unlikely(!t || !t->lldd_task || !t->dev))\r\nreturn;\r\nts = &t->task_status;\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("port_id:0x%x, tag:0x%x, event:0x%x\n",\r\nport_id, tag, event));\r\nswitch (event) {\r\ncase IO_OVERFLOW:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("IO_UNDERFLOW\n");)\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nts->residual = 0;\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nbreak;\r\ncase IO_XFER_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_BREAK\n"));\r\npm8001_handle_event(pm8001_ha, t, IO_XFER_ERROR_BREAK);\r\nreturn;\r\ncase IO_XFER_ERROR_PHY_NOT_READY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_PHY_NOT_READY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_EPROTO;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_ZONE_VIOLATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BREAK\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\r\ncase IO_XFER_OPEN_RETRY_BACKOFF_THRESHOLD_REACHED:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_TMO:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_NO_DEST:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_COLLIDE:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_PATHWAY_BLOCKED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\nif (!t->uldd_task)\r\npm8001_handle_event(pm8001_ha,\r\npm8001_dev,\r\nIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BAD_DESTINATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_BAD_DEST;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_CONN_RATE;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_WRONG_DESTINATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_WRONG_DEST;\r\nbreak;\r\ncase IO_XFER_ERROR_NAK_RECEIVED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_NAK_RECEIVED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_XFER_ERROR_ACK_NAK_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_ACK_NAK_TIMEOUT\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_NAK_R_ERR;\r\nbreak;\r\ncase IO_XFER_OPEN_RETRY_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_OPEN_RETRY_TIMEOUT\n"));\r\npm8001_handle_event(pm8001_ha, t, IO_XFER_OPEN_RETRY_TIMEOUT);\r\nreturn;\r\ncase IO_XFER_ERROR_UNEXPECTED_PHASE:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_UNEXPECTED_PHASE\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nbreak;\r\ncase IO_XFER_ERROR_XFER_RDY_OVERRUN:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_XFER_RDY_OVERRUN\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nbreak;\r\ncase IO_XFER_ERROR_XFER_RDY_NOT_EXPECTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_XFER_RDY_NOT_EXPECTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nbreak;\r\ncase IO_XFER_ERROR_CMD_ISSUE_ACK_NAK_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_CMD_ISSUE_ACK_NAK_TIMEOUT\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nbreak;\r\ncase IO_XFER_ERROR_OFFSET_MISMATCH:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_OFFSET_MISMATCH\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nbreak;\r\ncase IO_XFER_ERROR_XFER_ZERO_DATA_LEN:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_XFER_ZERO_DATA_LEN\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nbreak;\r\ncase IO_XFER_ERROR_INTERNAL_CRC_ERROR:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFR_ERROR_INTERNAL_CRC_ERROR\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nbreak;\r\ncase IO_XFER_CMD_FRAME_ISSUED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_CMD_FRAME_ISSUED\n"));\r\nreturn;\r\ndefault:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("Unknown status 0x%x\n", event));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&t->task_state_lock, flags);\r\nt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\r\nt->task_state_flags &= ~SAS_TASK_AT_INITIATOR;\r\nt->task_state_flags |= SAS_TASK_STATE_DONE;\r\nif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\nPM8001_FAIL_DBG(pm8001_ha, pm8001_printk(\r\n"task 0x%p done with event 0x%x resp 0x%x "\r\n"stat 0x%x but aborted by upper layer!\n",\r\nt, event, ts->resp, ts->stat));\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\n} else {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nt->task_done(t);\r\n}\r\n}\r\nstatic void\r\nmpi_sata_completion(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nstruct sas_task *t;\r\nstruct pm8001_ccb_info *ccb;\r\nu32 param;\r\nu32 status;\r\nu32 tag;\r\nstruct sata_completion_resp *psataPayload;\r\nstruct task_status_struct *ts;\r\nstruct ata_task_resp *resp ;\r\nu32 *sata_resp;\r\nstruct pm8001_device *pm8001_dev;\r\nunsigned long flags;\r\npsataPayload = (struct sata_completion_resp *)(piomb + 4);\r\nstatus = le32_to_cpu(psataPayload->status);\r\ntag = le32_to_cpu(psataPayload->tag);\r\nif (!tag) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("tag null\n"));\r\nreturn;\r\n}\r\nccb = &pm8001_ha->ccb_info[tag];\r\nparam = le32_to_cpu(psataPayload->param);\r\nif (ccb) {\r\nt = ccb->task;\r\npm8001_dev = ccb->device;\r\n} else {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("ccb null\n"));\r\nreturn;\r\n}\r\nif (t) {\r\nif (t->dev && (t->dev->lldd_dev))\r\npm8001_dev = t->dev->lldd_dev;\r\n} else {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("task null\n"));\r\nreturn;\r\n}\r\nif ((pm8001_dev && !(pm8001_dev->id & NCQ_READ_LOG_FLAG))\r\n&& unlikely(!t || !t->lldd_task || !t->dev)) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("task or dev null\n"));\r\nreturn;\r\n}\r\nts = &t->task_status;\r\nif (!ts) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("ts null\n"));\r\nreturn;\r\n}\r\nswitch (status) {\r\ncase IO_SUCCESS:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("IO_SUCCESS\n"));\r\nif (param == 0) {\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAM_STAT_GOOD;\r\nif (pm8001_dev &&\r\n(pm8001_dev->id & NCQ_READ_LOG_FLAG)) {\r\npm8001_dev->id |= NCQ_ABORT_ALL_FLAG;\r\npm8001_dev->id = pm8001_dev->id & 0x7FFFFFFF;\r\npm80xx_send_abort_all(pm8001_ha, pm8001_dev);\r\npm8001_tag_free(pm8001_ha, tag);\r\nsas_free_task(t);\r\nreturn;\r\n}\r\n} else {\r\nu8 len;\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_PROTO_RESPONSE;\r\nts->residual = param;\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("SAS_PROTO_RESPONSE len = %d\n",\r\nparam));\r\nsata_resp = &psataPayload->sata_resp[0];\r\nresp = (struct ata_task_resp *)ts->buf;\r\nif (t->ata_task.dma_xfer == 0 &&\r\nt->data_dir == PCI_DMA_FROMDEVICE) {\r\nlen = sizeof(struct pio_setup_fis);\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("PIO read len = %d\n", len));\r\n} else if (t->ata_task.use_ncq) {\r\nlen = sizeof(struct set_dev_bits_fis);\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("FPDMA len = %d\n", len));\r\n} else {\r\nlen = sizeof(struct dev_to_host_fis);\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("other len = %d\n", len));\r\n}\r\nif (SAS_STATUS_BUF_SIZE >= sizeof(*resp)) {\r\nresp->frame_len = len;\r\nmemcpy(&resp->ending_fis[0], sata_resp, len);\r\nts->buf_valid_size = sizeof(*resp);\r\n} else\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("response to large\n"));\r\n}\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nbreak;\r\ncase IO_ABORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_ABORTED IOMB Tag\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_ABORTED_TASK;\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nbreak;\r\ncase IO_UNDERFLOW:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_UNDERFLOW param = %d\n", param));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_UNDERRUN;\r\nts->residual = param;\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nbreak;\r\ncase IO_NO_DEVICE:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_NO_DEVICE\n"));\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_PHY_DOWN;\r\nbreak;\r\ncase IO_XFER_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_BREAK\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_INTERRUPTED;\r\nbreak;\r\ncase IO_XFER_ERROR_PHY_NOT_READY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_PHY_NOT_READY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_EPROTO;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_ZONE_VIOLATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BREAK\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_CONT0;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\r\ncase IO_XFER_OPEN_RETRY_BACKOFF_THRESHOLD_REACHED:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_TMO:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_NO_DEST:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_COLLIDE:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_PATHWAY_BLOCKED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nif (!t->uldd_task) {\r\npm8001_handle_event(pm8001_ha,\r\npm8001_dev,\r\nIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_QUEUE_FULL;\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\nreturn;\r\n}\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BAD_DESTINATION\n"));\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_BAD_DEST;\r\nif (!t->uldd_task) {\r\npm8001_handle_event(pm8001_ha,\r\npm8001_dev,\r\nIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_QUEUE_FULL;\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\nreturn;\r\n}\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_CONN_RATE;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_STP_RESOURCES_BUSY:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"IO_OPEN_CNX_ERROR_STP_RESOURCES_BUSY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nif (!t->uldd_task) {\r\npm8001_handle_event(pm8001_ha,\r\npm8001_dev,\r\nIO_OPEN_CNX_ERROR_STP_RESOURCES_BUSY);\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_QUEUE_FULL;\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\nreturn;\r\n}\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_WRONG_DESTINATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_WRONG_DEST;\r\nbreak;\r\ncase IO_XFER_ERROR_NAK_RECEIVED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_NAK_RECEIVED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_NAK_R_ERR;\r\nbreak;\r\ncase IO_XFER_ERROR_ACK_NAK_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_ACK_NAK_TIMEOUT\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_NAK_R_ERR;\r\nbreak;\r\ncase IO_XFER_ERROR_DMA:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_DMA\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_ABORTED_TASK;\r\nbreak;\r\ncase IO_XFER_ERROR_SATA_LINK_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_SATA_LINK_TIMEOUT\n"));\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nbreak;\r\ncase IO_XFER_ERROR_REJECTED_NCQ_MODE:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_REJECTED_NCQ_MODE\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_UNDERRUN;\r\nbreak;\r\ncase IO_XFER_OPEN_RETRY_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_OPEN_RETRY_TIMEOUT\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\ncase IO_PORT_IN_RESET:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_PORT_IN_RESET\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nbreak;\r\ncase IO_DS_NON_OPERATIONAL:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_DS_NON_OPERATIONAL\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nif (!t->uldd_task) {\r\npm8001_handle_event(pm8001_ha, pm8001_dev,\r\nIO_DS_NON_OPERATIONAL);\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_QUEUE_FULL;\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\nreturn;\r\n}\r\nbreak;\r\ncase IO_DS_IN_RECOVERY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_DS_IN_RECOVERY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nbreak;\r\ncase IO_DS_IN_ERROR:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_DS_IN_ERROR\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nif (!t->uldd_task) {\r\npm8001_handle_event(pm8001_ha, pm8001_dev,\r\nIO_DS_IN_ERROR);\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_QUEUE_FULL;\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\nreturn;\r\n}\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\ndefault:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("Unknown status 0x%x\n", status));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&t->task_state_lock, flags);\r\nt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\r\nt->task_state_flags &= ~SAS_TASK_AT_INITIATOR;\r\nt->task_state_flags |= SAS_TASK_STATE_DONE;\r\nif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("task 0x%p done with io_status 0x%x"\r\n" resp 0x%x stat 0x%x but aborted by upper layer!\n",\r\nt, status, ts->resp, ts->stat));\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\n} else if (t->uldd_task) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\n} else if (!t->uldd_task) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\n}\r\n}\r\nstatic void mpi_sata_event(struct pm8001_hba_info *pm8001_ha , void *piomb)\r\n{\r\nstruct sas_task *t;\r\nstruct task_status_struct *ts;\r\nstruct pm8001_ccb_info *ccb;\r\nstruct pm8001_device *pm8001_dev;\r\nstruct sata_event_resp *psataPayload =\r\n(struct sata_event_resp *)(piomb + 4);\r\nu32 event = le32_to_cpu(psataPayload->event);\r\nu32 tag = le32_to_cpu(psataPayload->tag);\r\nu32 port_id = le32_to_cpu(psataPayload->port_id);\r\nu32 dev_id = le32_to_cpu(psataPayload->device_id);\r\nunsigned long flags;\r\nccb = &pm8001_ha->ccb_info[tag];\r\nif (ccb) {\r\nt = ccb->task;\r\npm8001_dev = ccb->device;\r\n} else {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("No CCB !!!. returning\n"));\r\nreturn;\r\n}\r\nif (event)\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("SATA EVENT 0x%x\n", event));\r\nif (event == IO_XFER_ERROR_ABORTED_NCQ_MODE) {\r\npm8001_dev = pm8001_find_dev(pm8001_ha, dev_id);\r\nif (pm8001_dev)\r\npm80xx_send_read_log(pm8001_ha, pm8001_dev);\r\nreturn;\r\n}\r\nif (unlikely(!t || !t->lldd_task || !t->dev)) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("task or dev null\n"));\r\nreturn;\r\n}\r\nts = &t->task_status;\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("port_id:0x%x, tag:0x%x, event:0x%x\n",\r\nport_id, tag, event));\r\nswitch (event) {\r\ncase IO_OVERFLOW:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("IO_UNDERFLOW\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nts->residual = 0;\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nbreak;\r\ncase IO_XFER_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_BREAK\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_INTERRUPTED;\r\nbreak;\r\ncase IO_XFER_ERROR_PHY_NOT_READY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_PHY_NOT_READY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_EPROTO;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_ZONE_VIOLATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BREAK\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_CONT0;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\r\ncase IO_XFER_OPEN_RETRY_BACKOFF_THRESHOLD_REACHED:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_TMO:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_NO_DEST:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_COLLIDE:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_PATHWAY_BLOCKED:\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\n"));\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nif (!t->uldd_task) {\r\npm8001_handle_event(pm8001_ha,\r\npm8001_dev,\r\nIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_QUEUE_FULL;\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\nreturn;\r\n}\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BAD_DESTINATION\n"));\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_BAD_DEST;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_CONN_RATE;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_WRONG_DESTINATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_WRONG_DEST;\r\nbreak;\r\ncase IO_XFER_ERROR_NAK_RECEIVED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_NAK_RECEIVED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_NAK_R_ERR;\r\nbreak;\r\ncase IO_XFER_ERROR_PEER_ABORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_PEER_ABORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_NAK_R_ERR;\r\nbreak;\r\ncase IO_XFER_ERROR_REJECTED_NCQ_MODE:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_REJECTED_NCQ_MODE\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_UNDERRUN;\r\nbreak;\r\ncase IO_XFER_OPEN_RETRY_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_OPEN_RETRY_TIMEOUT\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\ncase IO_XFER_ERROR_UNEXPECTED_PHASE:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_UNEXPECTED_PHASE\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\ncase IO_XFER_ERROR_XFER_RDY_OVERRUN:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_XFER_RDY_OVERRUN\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\ncase IO_XFER_ERROR_XFER_RDY_NOT_EXPECTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_XFER_RDY_NOT_EXPECTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\ncase IO_XFER_ERROR_OFFSET_MISMATCH:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_OFFSET_MISMATCH\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\ncase IO_XFER_ERROR_XFER_ZERO_DATA_LEN:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_XFER_ZERO_DATA_LEN\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\ncase IO_XFER_CMD_FRAME_ISSUED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_CMD_FRAME_ISSUED\n"));\r\nbreak;\r\ncase IO_XFER_PIO_SETUP_ERROR:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_PIO_SETUP_ERROR\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\ncase IO_XFER_ERROR_INTERNAL_CRC_ERROR:\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("IO_XFR_ERROR_INTERNAL_CRC_ERROR\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\ncase IO_XFER_DMA_ACTIVATE_TIMEOUT:\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("IO_XFR_DMA_ACTIVATE_TIMEOUT\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\ndefault:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("Unknown status 0x%x\n", event));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&t->task_state_lock, flags);\r\nt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\r\nt->task_state_flags &= ~SAS_TASK_AT_INITIATOR;\r\nt->task_state_flags |= SAS_TASK_STATE_DONE;\r\nif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("task 0x%p done with io_status 0x%x"\r\n" resp 0x%x stat 0x%x but aborted by upper layer!\n",\r\nt, event, ts->resp, ts->stat));\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\n} else if (t->uldd_task) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\n} else if (!t->uldd_task) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\nt->task_done(t);\r\nspin_lock_irq(&pm8001_ha->lock);\r\n}\r\n}\r\nstatic void\r\nmpi_smp_completion(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nu32 param, i;\r\nstruct sas_task *t;\r\nstruct pm8001_ccb_info *ccb;\r\nunsigned long flags;\r\nu32 status;\r\nu32 tag;\r\nstruct smp_completion_resp *psmpPayload;\r\nstruct task_status_struct *ts;\r\nstruct pm8001_device *pm8001_dev;\r\nchar *pdma_respaddr = NULL;\r\npsmpPayload = (struct smp_completion_resp *)(piomb + 4);\r\nstatus = le32_to_cpu(psmpPayload->status);\r\ntag = le32_to_cpu(psmpPayload->tag);\r\nccb = &pm8001_ha->ccb_info[tag];\r\nparam = le32_to_cpu(psmpPayload->param);\r\nt = ccb->task;\r\nts = &t->task_status;\r\npm8001_dev = ccb->device;\r\nif (status)\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("smp IO status 0x%x\n", status));\r\nif (unlikely(!t || !t->lldd_task || !t->dev))\r\nreturn;\r\nswitch (status) {\r\ncase IO_SUCCESS:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("IO_SUCCESS\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAM_STAT_GOOD;\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nif (pm8001_ha->smp_exp_mode == SMP_DIRECT) {\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("DIRECT RESPONSE Length:%d\n",\r\nparam));\r\npdma_respaddr = (char *)(phys_to_virt(cpu_to_le64\r\n((u64)sg_dma_address\r\n(&t->smp_task.smp_resp))));\r\nfor (i = 0; i < param; i++) {\r\n*(pdma_respaddr+i) = psmpPayload->_r_a[i];\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"SMP Byte%d DMA data 0x%x psmp 0x%x\n",\r\ni, *(pdma_respaddr+i),\r\npsmpPayload->_r_a[i]));\r\n}\r\n}\r\nbreak;\r\ncase IO_ABORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_ABORTED IOMB\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_ABORTED_TASK;\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nbreak;\r\ncase IO_OVERFLOW:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("IO_UNDERFLOW\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nts->residual = 0;\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nbreak;\r\ncase IO_NO_DEVICE:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("IO_NO_DEVICE\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_PHY_DOWN;\r\nbreak;\r\ncase IO_ERROR_HW_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_ERROR_HW_TIMEOUT\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAM_STAT_BUSY;\r\nbreak;\r\ncase IO_XFER_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_BREAK\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAM_STAT_BUSY;\r\nbreak;\r\ncase IO_XFER_ERROR_PHY_NOT_READY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_PHY_NOT_READY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAM_STAT_BUSY;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_ZONE_VIOLATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BREAK:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BREAK\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_CONT0;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\r\ncase IO_XFER_OPEN_RETRY_BACKOFF_THRESHOLD_REACHED:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_TMO:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_NO_DEST:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_COLLIDE:\r\ncase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_PATHWAY_BLOCKED:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\npm8001_handle_event(pm8001_ha,\r\npm8001_dev,\r\nIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_BAD_DESTINATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_BAD_DEST;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\\r\n"IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_CONN_RATE;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_WRONG_DESTINATION\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_WRONG_DEST;\r\nbreak;\r\ncase IO_XFER_ERROR_RX_FRAME:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_ERROR_RX_FRAME\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nbreak;\r\ncase IO_XFER_OPEN_RETRY_TIMEOUT:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_XFER_OPEN_RETRY_TIMEOUT\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_ERROR_INTERNAL_SMP_RESOURCE:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_ERROR_INTERNAL_SMP_RESOURCE\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_QUEUE_FULL;\r\nbreak;\r\ncase IO_PORT_IN_RESET:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_PORT_IN_RESET\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_DS_NON_OPERATIONAL:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_DS_NON_OPERATIONAL\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nbreak;\r\ncase IO_DS_IN_RECOVERY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_DS_IN_RECOVERY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ncase IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY\n"));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nbreak;\r\ndefault:\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("Unknown status 0x%x\n", status));\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&t->task_state_lock, flags);\r\nt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\r\nt->task_state_flags &= ~SAS_TASK_AT_INITIATOR;\r\nt->task_state_flags |= SAS_TASK_STATE_DONE;\r\nif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\nPM8001_FAIL_DBG(pm8001_ha, pm8001_printk(\r\n"task 0x%p done with io_status 0x%x resp 0x%x"\r\n"stat 0x%x but aborted by upper layer!\n",\r\nt, status, ts->resp, ts->stat));\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\n} else {\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\npm8001_ccb_task_free(pm8001_ha, t, ccb, tag);\r\nmb();\r\nt->task_done(t);\r\n}\r\n}\r\nstatic void pm80xx_hw_event_ack_req(struct pm8001_hba_info *pm8001_ha,\r\nu32 Qnum, u32 SEA, u32 port_id, u32 phyId, u32 param0, u32 param1)\r\n{\r\nstruct hw_event_ack_req payload;\r\nu32 opc = OPC_INB_SAS_HW_EVENT_ACK;\r\nstruct inbound_queue_table *circularQ;\r\nmemset((u8 *)&payload, 0, sizeof(payload));\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[Qnum];\r\npayload.tag = cpu_to_le32(1);\r\npayload.phyid_sea_portid = cpu_to_le32(((SEA & 0xFFFF) << 8) |\r\n((phyId & 0xFF) << 24) | (port_id & 0xFF));\r\npayload.param0 = cpu_to_le32(param0);\r\npayload.param1 = cpu_to_le32(param1);\r\npm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &payload, 0);\r\n}\r\nstatic void\r\nhw_event_sas_phy_up(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nstruct hw_event_resp *pPayload =\r\n(struct hw_event_resp *)(piomb + 4);\r\nu32 lr_status_evt_portid =\r\nle32_to_cpu(pPayload->lr_status_evt_portid);\r\nu32 phyid_npip_portstate = le32_to_cpu(pPayload->phyid_npip_portstate);\r\nu8 link_rate =\r\n(u8)((lr_status_evt_portid & 0xF0000000) >> 28);\r\nu8 port_id = (u8)(lr_status_evt_portid & 0x000000FF);\r\nu8 phy_id =\r\n(u8)((phyid_npip_portstate & 0xFF0000) >> 16);\r\nu8 portstate = (u8)(phyid_npip_portstate & 0x0000000F);\r\nstruct pm8001_port *port = &pm8001_ha->port[port_id];\r\nstruct sas_ha_struct *sas_ha = pm8001_ha->sas;\r\nstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\r\nunsigned long flags;\r\nu8 deviceType = pPayload->sas_identify.dev_type;\r\nport->port_state = portstate;\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"portid:%d; phyid:%d; linkrate:%d; "\r\n"portstate:%x; devicetype:%x\n",\r\nport_id, phy_id, link_rate, portstate, deviceType));\r\nswitch (deviceType) {\r\ncase SAS_PHY_UNUSED:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("device type no device.\n"));\r\nbreak;\r\ncase SAS_END_DEVICE:\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk("end device.\n"));\r\npm80xx_chip_phy_ctl_req(pm8001_ha, phy_id,\r\nPHY_NOTIFY_ENABLE_SPINUP);\r\nport->port_attached = 1;\r\npm8001_get_lrate_mode(phy, link_rate);\r\nbreak;\r\ncase SAS_EDGE_EXPANDER_DEVICE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("expander device.\n"));\r\nport->port_attached = 1;\r\npm8001_get_lrate_mode(phy, link_rate);\r\nbreak;\r\ncase SAS_FANOUT_EXPANDER_DEVICE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("fanout expander device.\n"));\r\nport->port_attached = 1;\r\npm8001_get_lrate_mode(phy, link_rate);\r\nbreak;\r\ndefault:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("unknown device type(%x)\n", deviceType));\r\nbreak;\r\n}\r\nphy->phy_type |= PORT_TYPE_SAS;\r\nphy->identify.device_type = deviceType;\r\nphy->phy_attached = 1;\r\nif (phy->identify.device_type == SAS_END_DEVICE)\r\nphy->identify.target_port_protocols = SAS_PROTOCOL_SSP;\r\nelse if (phy->identify.device_type != SAS_PHY_UNUSED)\r\nphy->identify.target_port_protocols = SAS_PROTOCOL_SMP;\r\nphy->sas_phy.oob_mode = SAS_OOB_MODE;\r\nsas_ha->notify_phy_event(&phy->sas_phy, PHYE_OOB_DONE);\r\nspin_lock_irqsave(&phy->sas_phy.frame_rcvd_lock, flags);\r\nmemcpy(phy->frame_rcvd, &pPayload->sas_identify,\r\nsizeof(struct sas_identify_frame)-4);\r\nphy->frame_rcvd_size = sizeof(struct sas_identify_frame) - 4;\r\npm8001_get_attached_sas_addr(phy, phy->sas_phy.attached_sas_addr);\r\nspin_unlock_irqrestore(&phy->sas_phy.frame_rcvd_lock, flags);\r\nif (pm8001_ha->flags == PM8001F_RUN_TIME)\r\nmdelay(200);\r\npm8001_bytes_dmaed(pm8001_ha, phy_id);\r\n}\r\nstatic void\r\nhw_event_sata_phy_up(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nstruct hw_event_resp *pPayload =\r\n(struct hw_event_resp *)(piomb + 4);\r\nu32 phyid_npip_portstate = le32_to_cpu(pPayload->phyid_npip_portstate);\r\nu32 lr_status_evt_portid =\r\nle32_to_cpu(pPayload->lr_status_evt_portid);\r\nu8 link_rate =\r\n(u8)((lr_status_evt_portid & 0xF0000000) >> 28);\r\nu8 port_id = (u8)(lr_status_evt_portid & 0x000000FF);\r\nu8 phy_id =\r\n(u8)((phyid_npip_portstate & 0xFF0000) >> 16);\r\nu8 portstate = (u8)(phyid_npip_portstate & 0x0000000F);\r\nstruct pm8001_port *port = &pm8001_ha->port[port_id];\r\nstruct sas_ha_struct *sas_ha = pm8001_ha->sas;\r\nstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\r\nunsigned long flags;\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"port id %d, phy id %d link_rate %d portstate 0x%x\n",\r\nport_id, phy_id, link_rate, portstate));\r\nport->port_state = portstate;\r\nport->port_attached = 1;\r\npm8001_get_lrate_mode(phy, link_rate);\r\nphy->phy_type |= PORT_TYPE_SATA;\r\nphy->phy_attached = 1;\r\nphy->sas_phy.oob_mode = SATA_OOB_MODE;\r\nsas_ha->notify_phy_event(&phy->sas_phy, PHYE_OOB_DONE);\r\nspin_lock_irqsave(&phy->sas_phy.frame_rcvd_lock, flags);\r\nmemcpy(phy->frame_rcvd, ((u8 *)&pPayload->sata_fis - 4),\r\nsizeof(struct dev_to_host_fis));\r\nphy->frame_rcvd_size = sizeof(struct dev_to_host_fis);\r\nphy->identify.target_port_protocols = SAS_PROTOCOL_SATA;\r\nphy->identify.device_type = SAS_SATA_DEV;\r\npm8001_get_attached_sas_addr(phy, phy->sas_phy.attached_sas_addr);\r\nspin_unlock_irqrestore(&phy->sas_phy.frame_rcvd_lock, flags);\r\npm8001_bytes_dmaed(pm8001_ha, phy_id);\r\n}\r\nstatic void\r\nhw_event_phy_down(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nstruct hw_event_resp *pPayload =\r\n(struct hw_event_resp *)(piomb + 4);\r\nu32 lr_status_evt_portid =\r\nle32_to_cpu(pPayload->lr_status_evt_portid);\r\nu8 port_id = (u8)(lr_status_evt_portid & 0x000000FF);\r\nu32 phyid_npip_portstate = le32_to_cpu(pPayload->phyid_npip_portstate);\r\nu8 phy_id =\r\n(u8)((phyid_npip_portstate & 0xFF0000) >> 16);\r\nu8 portstate = (u8)(phyid_npip_portstate & 0x0000000F);\r\nstruct pm8001_port *port = &pm8001_ha->port[port_id];\r\nstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\r\nport->port_state = portstate;\r\nphy->phy_type = 0;\r\nphy->identify.device_type = 0;\r\nphy->phy_attached = 0;\r\nmemset(&phy->dev_sas_addr, 0, SAS_ADDR_SIZE);\r\nswitch (portstate) {\r\ncase PORT_VALID:\r\nbreak;\r\ncase PORT_INVALID:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" PortInvalid portID %d\n", port_id));\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" Last phy Down and port invalid\n"));\r\nport->port_attached = 0;\r\npm80xx_hw_event_ack_req(pm8001_ha, 0, HW_EVENT_PHY_DOWN,\r\nport_id, phy_id, 0, 0);\r\nbreak;\r\ncase PORT_IN_RESET:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" Port In Reset portID %d\n", port_id));\r\nbreak;\r\ncase PORT_NOT_ESTABLISHED:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" phy Down and PORT_NOT_ESTABLISHED\n"));\r\nport->port_attached = 0;\r\nbreak;\r\ncase PORT_LOSTCOMM:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" phy Down and PORT_LOSTCOMM\n"));\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" Last phy Down and port invalid\n"));\r\nport->port_attached = 0;\r\npm80xx_hw_event_ack_req(pm8001_ha, 0, HW_EVENT_PHY_DOWN,\r\nport_id, phy_id, 0, 0);\r\nbreak;\r\ndefault:\r\nport->port_attached = 0;\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" phy Down and(default) = 0x%x\n",\r\nportstate));\r\nbreak;\r\n}\r\n}\r\nstatic int mpi_phy_start_resp(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nstruct phy_start_resp *pPayload =\r\n(struct phy_start_resp *)(piomb + 4);\r\nu32 status =\r\nle32_to_cpu(pPayload->status);\r\nu32 phy_id =\r\nle32_to_cpu(pPayload->phyid);\r\nstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("phy start resp status:0x%x, phyid:0x%x\n",\r\nstatus, phy_id));\r\nif (status == 0) {\r\nphy->phy_state = 1;\r\nif (pm8001_ha->flags == PM8001F_RUN_TIME)\r\ncomplete(phy->enable_completion);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpi_thermal_hw_event(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nstruct thermal_hw_event *pPayload =\r\n(struct thermal_hw_event *)(piomb + 4);\r\nu32 thermal_event = le32_to_cpu(pPayload->thermal_event);\r\nu32 rht_lht = le32_to_cpu(pPayload->rht_lht);\r\nif (thermal_event & 0x40) {\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"Thermal Event: Local high temperature violated!\n"));\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"Thermal Event: Measured local high temperature %d\n",\r\n((rht_lht & 0xFF00) >> 8)));\r\n}\r\nif (thermal_event & 0x10) {\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"Thermal Event: Remote high temperature violated!\n"));\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"Thermal Event: Measured remote high temperature %d\n",\r\n((rht_lht & 0xFF000000) >> 24)));\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpi_hw_event(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nunsigned long flags;\r\nstruct hw_event_resp *pPayload =\r\n(struct hw_event_resp *)(piomb + 4);\r\nu32 lr_status_evt_portid =\r\nle32_to_cpu(pPayload->lr_status_evt_portid);\r\nu32 phyid_npip_portstate = le32_to_cpu(pPayload->phyid_npip_portstate);\r\nu8 port_id = (u8)(lr_status_evt_portid & 0x000000FF);\r\nu8 phy_id =\r\n(u8)((phyid_npip_portstate & 0xFF0000) >> 16);\r\nu16 eventType =\r\n(u16)((lr_status_evt_portid & 0x00FFFF00) >> 8);\r\nu8 status =\r\n(u8)((lr_status_evt_portid & 0x0F000000) >> 24);\r\nstruct sas_ha_struct *sas_ha = pm8001_ha->sas;\r\nstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\r\nstruct asd_sas_phy *sas_phy = sas_ha->sas_phy[phy_id];\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("portid:%d phyid:%d event:0x%x status:0x%x\n",\r\nport_id, phy_id, eventType, status));\r\nswitch (eventType) {\r\ncase HW_EVENT_SAS_PHY_UP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_PHY_START_STATUS\n"));\r\nhw_event_sas_phy_up(pm8001_ha, piomb);\r\nbreak;\r\ncase HW_EVENT_SATA_PHY_UP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_SATA_PHY_UP\n"));\r\nhw_event_sata_phy_up(pm8001_ha, piomb);\r\nbreak;\r\ncase HW_EVENT_SATA_SPINUP_HOLD:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_SATA_SPINUP_HOLD\n"));\r\nsas_ha->notify_phy_event(&phy->sas_phy, PHYE_SPINUP_HOLD);\r\nbreak;\r\ncase HW_EVENT_PHY_DOWN:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_PHY_DOWN\n"));\r\nsas_ha->notify_phy_event(&phy->sas_phy, PHYE_LOSS_OF_SIGNAL);\r\nphy->phy_attached = 0;\r\nphy->phy_state = 0;\r\nhw_event_phy_down(pm8001_ha, piomb);\r\nbreak;\r\ncase HW_EVENT_PORT_INVALID:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_PORT_INVALID\n"));\r\nsas_phy_disconnected(sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_port_event(sas_phy, PORTE_LINK_RESET_ERR);\r\nbreak;\r\ncase HW_EVENT_BROADCAST_CHANGE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_BROADCAST_CHANGE\n"));\r\npm80xx_hw_event_ack_req(pm8001_ha, 0, HW_EVENT_BROADCAST_CHANGE,\r\nport_id, phy_id, 1, 0);\r\nspin_lock_irqsave(&sas_phy->sas_prim_lock, flags);\r\nsas_phy->sas_prim = HW_EVENT_BROADCAST_CHANGE;\r\nspin_unlock_irqrestore(&sas_phy->sas_prim_lock, flags);\r\nsas_ha->notify_port_event(sas_phy, PORTE_BROADCAST_RCVD);\r\nbreak;\r\ncase HW_EVENT_PHY_ERROR:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_PHY_ERROR\n"));\r\nsas_phy_disconnected(&phy->sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_phy_event(&phy->sas_phy, PHYE_OOB_ERROR);\r\nbreak;\r\ncase HW_EVENT_BROADCAST_EXP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_BROADCAST_EXP\n"));\r\nspin_lock_irqsave(&sas_phy->sas_prim_lock, flags);\r\nsas_phy->sas_prim = HW_EVENT_BROADCAST_EXP;\r\nspin_unlock_irqrestore(&sas_phy->sas_prim_lock, flags);\r\nsas_ha->notify_port_event(sas_phy, PORTE_BROADCAST_RCVD);\r\nbreak;\r\ncase HW_EVENT_LINK_ERR_INVALID_DWORD:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_LINK_ERR_INVALID_DWORD\n"));\r\npm80xx_hw_event_ack_req(pm8001_ha, 0,\r\nHW_EVENT_LINK_ERR_INVALID_DWORD, port_id, phy_id, 0, 0);\r\nsas_phy_disconnected(sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_port_event(sas_phy, PORTE_LINK_RESET_ERR);\r\nbreak;\r\ncase HW_EVENT_LINK_ERR_DISPARITY_ERROR:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_LINK_ERR_DISPARITY_ERROR\n"));\r\npm80xx_hw_event_ack_req(pm8001_ha, 0,\r\nHW_EVENT_LINK_ERR_DISPARITY_ERROR,\r\nport_id, phy_id, 0, 0);\r\nsas_phy_disconnected(sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_port_event(sas_phy, PORTE_LINK_RESET_ERR);\r\nbreak;\r\ncase HW_EVENT_LINK_ERR_CODE_VIOLATION:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_LINK_ERR_CODE_VIOLATION\n"));\r\npm80xx_hw_event_ack_req(pm8001_ha, 0,\r\nHW_EVENT_LINK_ERR_CODE_VIOLATION,\r\nport_id, phy_id, 0, 0);\r\nsas_phy_disconnected(sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_port_event(sas_phy, PORTE_LINK_RESET_ERR);\r\nbreak;\r\ncase HW_EVENT_LINK_ERR_LOSS_OF_DWORD_SYNCH:\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"HW_EVENT_LINK_ERR_LOSS_OF_DWORD_SYNCH\n"));\r\npm80xx_hw_event_ack_req(pm8001_ha, 0,\r\nHW_EVENT_LINK_ERR_LOSS_OF_DWORD_SYNCH,\r\nport_id, phy_id, 0, 0);\r\nsas_phy_disconnected(sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_port_event(sas_phy, PORTE_LINK_RESET_ERR);\r\nbreak;\r\ncase HW_EVENT_MALFUNCTION:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_MALFUNCTION\n"));\r\nbreak;\r\ncase HW_EVENT_BROADCAST_SES:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_BROADCAST_SES\n"));\r\nspin_lock_irqsave(&sas_phy->sas_prim_lock, flags);\r\nsas_phy->sas_prim = HW_EVENT_BROADCAST_SES;\r\nspin_unlock_irqrestore(&sas_phy->sas_prim_lock, flags);\r\nsas_ha->notify_port_event(sas_phy, PORTE_BROADCAST_RCVD);\r\nbreak;\r\ncase HW_EVENT_INBOUND_CRC_ERROR:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_INBOUND_CRC_ERROR\n"));\r\npm80xx_hw_event_ack_req(pm8001_ha, 0,\r\nHW_EVENT_INBOUND_CRC_ERROR,\r\nport_id, phy_id, 0, 0);\r\nbreak;\r\ncase HW_EVENT_HARD_RESET_RECEIVED:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_HARD_RESET_RECEIVED\n"));\r\nsas_ha->notify_port_event(sas_phy, PORTE_HARD_RESET);\r\nbreak;\r\ncase HW_EVENT_ID_FRAME_TIMEOUT:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_ID_FRAME_TIMEOUT\n"));\r\nsas_phy_disconnected(sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_port_event(sas_phy, PORTE_LINK_RESET_ERR);\r\nbreak;\r\ncase HW_EVENT_LINK_ERR_PHY_RESET_FAILED:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_LINK_ERR_PHY_RESET_FAILED\n"));\r\npm80xx_hw_event_ack_req(pm8001_ha, 0,\r\nHW_EVENT_LINK_ERR_PHY_RESET_FAILED,\r\nport_id, phy_id, 0, 0);\r\nsas_phy_disconnected(sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_port_event(sas_phy, PORTE_LINK_RESET_ERR);\r\nbreak;\r\ncase HW_EVENT_PORT_RESET_TIMER_TMO:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_PORT_RESET_TIMER_TMO\n"));\r\nsas_phy_disconnected(sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_port_event(sas_phy, PORTE_LINK_RESET_ERR);\r\nbreak;\r\ncase HW_EVENT_PORT_RECOVERY_TIMER_TMO:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_PORT_RECOVERY_TIMER_TMO\n"));\r\npm80xx_hw_event_ack_req(pm8001_ha, 0,\r\nHW_EVENT_PORT_RECOVERY_TIMER_TMO,\r\nport_id, phy_id, 0, 0);\r\nsas_phy_disconnected(sas_phy);\r\nphy->phy_attached = 0;\r\nsas_ha->notify_port_event(sas_phy, PORTE_LINK_RESET_ERR);\r\nbreak;\r\ncase HW_EVENT_PORT_RECOVER:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_PORT_RECOVER\n"));\r\nbreak;\r\ncase HW_EVENT_PORT_RESET_COMPLETE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("HW_EVENT_PORT_RESET_COMPLETE\n"));\r\nbreak;\r\ncase EVENT_BROADCAST_ASYNCH_EVENT:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("EVENT_BROADCAST_ASYNCH_EVENT\n"));\r\nbreak;\r\ndefault:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("Unknown event type 0x%x\n", eventType));\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpi_phy_stop_resp(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nstruct phy_stop_resp *pPayload =\r\n(struct phy_stop_resp *)(piomb + 4);\r\nu32 status =\r\nle32_to_cpu(pPayload->status);\r\nu32 phyid =\r\nle32_to_cpu(pPayload->phyid);\r\nstruct pm8001_phy *phy = &pm8001_ha->phy[phyid];\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("phy:0x%x status:0x%x\n",\r\nphyid, status));\r\nif (status == 0)\r\nphy->phy_state = 0;\r\nreturn 0;\r\n}\r\nstatic int mpi_set_controller_config_resp(struct pm8001_hba_info *pm8001_ha,\r\nvoid *piomb)\r\n{\r\nstruct set_ctrl_cfg_resp *pPayload =\r\n(struct set_ctrl_cfg_resp *)(piomb + 4);\r\nu32 status = le32_to_cpu(pPayload->status);\r\nu32 err_qlfr_pgcd = le32_to_cpu(pPayload->err_qlfr_pgcd);\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"SET CONTROLLER RESP: status 0x%x qlfr_pgcd 0x%x\n",\r\nstatus, err_qlfr_pgcd));\r\nreturn 0;\r\n}\r\nstatic int mpi_get_controller_config_resp(struct pm8001_hba_info *pm8001_ha,\r\nvoid *piomb)\r\n{\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" pm80xx_addition_functionality\n"));\r\nreturn 0;\r\n}\r\nstatic int mpi_get_phy_profile_resp(struct pm8001_hba_info *pm8001_ha,\r\nvoid *piomb)\r\n{\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" pm80xx_addition_functionality\n"));\r\nreturn 0;\r\n}\r\nstatic int mpi_flash_op_ext_resp(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" pm80xx_addition_functionality\n"));\r\nreturn 0;\r\n}\r\nstatic int mpi_set_phy_profile_resp(struct pm8001_hba_info *pm8001_ha,\r\nvoid *piomb)\r\n{\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" pm80xx_addition_functionality\n"));\r\nreturn 0;\r\n}\r\nstatic int mpi_kek_management_resp(struct pm8001_hba_info *pm8001_ha,\r\nvoid *piomb)\r\n{\r\nstruct kek_mgmt_resp *pPayload = (struct kek_mgmt_resp *)(piomb + 4);\r\nu32 status = le32_to_cpu(pPayload->status);\r\nu32 kidx_new_curr_ksop = le32_to_cpu(pPayload->kidx_new_curr_ksop);\r\nu32 err_qlfr = le32_to_cpu(pPayload->err_qlfr);\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"KEK MGMT RESP. Status 0x%x idx_ksop 0x%x err_qlfr 0x%x\n",\r\nstatus, kidx_new_curr_ksop, err_qlfr));\r\nreturn 0;\r\n}\r\nstatic int mpi_dek_management_resp(struct pm8001_hba_info *pm8001_ha,\r\nvoid *piomb)\r\n{\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" pm80xx_addition_functionality\n"));\r\nreturn 0;\r\n}\r\nstatic int ssp_coalesced_comp_resp(struct pm8001_hba_info *pm8001_ha,\r\nvoid *piomb)\r\n{\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk(" pm80xx_addition_functionality\n"));\r\nreturn 0;\r\n}\r\nstatic void process_one_iomb(struct pm8001_hba_info *pm8001_ha, void *piomb)\r\n{\r\n__le32 pHeader = *(__le32 *)piomb;\r\nu32 opc = (u32)((le32_to_cpu(pHeader)) & 0xFFF);\r\nswitch (opc) {\r\ncase OPC_OUB_ECHO:\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk("OPC_OUB_ECHO\n"));\r\nbreak;\r\ncase OPC_OUB_HW_EVENT:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_HW_EVENT\n"));\r\nmpi_hw_event(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_THERM_HW_EVENT:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_THERMAL_EVENT\n"));\r\nmpi_thermal_hw_event(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_SSP_COMP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SSP_COMP\n"));\r\nmpi_ssp_completion(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_SMP_COMP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SMP_COMP\n"));\r\nmpi_smp_completion(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_LOCAL_PHY_CNTRL:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_LOCAL_PHY_CNTRL\n"));\r\npm8001_mpi_local_phy_ctl(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_DEV_REGIST:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_DEV_REGIST\n"));\r\npm8001_mpi_reg_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_DEREG_DEV:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("unregister the device\n"));\r\npm8001_mpi_dereg_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_GET_DEV_HANDLE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_GET_DEV_HANDLE\n"));\r\nbreak;\r\ncase OPC_OUB_SATA_COMP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SATA_COMP\n"));\r\nmpi_sata_completion(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_SATA_EVENT:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SATA_EVENT\n"));\r\nmpi_sata_event(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_SSP_EVENT:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SSP_EVENT\n"));\r\nmpi_ssp_event(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_DEV_HANDLE_ARRIV:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_DEV_HANDLE_ARRIV\n"));\r\nbreak;\r\ncase OPC_OUB_SSP_RECV_EVENT:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SSP_RECV_EVENT\n"));\r\nbreak;\r\ncase OPC_OUB_FW_FLASH_UPDATE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_FW_FLASH_UPDATE\n"));\r\npm8001_mpi_fw_flash_update_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_GPIO_RESPONSE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_GPIO_RESPONSE\n"));\r\nbreak;\r\ncase OPC_OUB_GPIO_EVENT:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_GPIO_EVENT\n"));\r\nbreak;\r\ncase OPC_OUB_GENERAL_EVENT:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_GENERAL_EVENT\n"));\r\npm8001_mpi_general_event(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_SSP_ABORT_RSP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SSP_ABORT_RSP\n"));\r\npm8001_mpi_task_abort_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_SATA_ABORT_RSP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SATA_ABORT_RSP\n"));\r\npm8001_mpi_task_abort_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_SAS_DIAG_MODE_START_END:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SAS_DIAG_MODE_START_END\n"));\r\nbreak;\r\ncase OPC_OUB_SAS_DIAG_EXECUTE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SAS_DIAG_EXECUTE\n"));\r\nbreak;\r\ncase OPC_OUB_GET_TIME_STAMP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_GET_TIME_STAMP\n"));\r\nbreak;\r\ncase OPC_OUB_SAS_HW_EVENT_ACK:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SAS_HW_EVENT_ACK\n"));\r\nbreak;\r\ncase OPC_OUB_PORT_CONTROL:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_PORT_CONTROL\n"));\r\nbreak;\r\ncase OPC_OUB_SMP_ABORT_RSP:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SMP_ABORT_RSP\n"));\r\npm8001_mpi_task_abort_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_GET_NVMD_DATA:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_GET_NVMD_DATA\n"));\r\npm8001_mpi_get_nvmd_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_SET_NVMD_DATA:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SET_NVMD_DATA\n"));\r\npm8001_mpi_set_nvmd_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_DEVICE_HANDLE_REMOVAL:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_DEVICE_HANDLE_REMOVAL\n"));\r\nbreak;\r\ncase OPC_OUB_SET_DEVICE_STATE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SET_DEVICE_STATE\n"));\r\npm8001_mpi_set_dev_state_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_GET_DEVICE_STATE:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_GET_DEVICE_STATE\n"));\r\nbreak;\r\ncase OPC_OUB_SET_DEV_INFO:\r\nPM8001_MSG_DBG(pm8001_ha,\r\npm8001_printk("OPC_OUB_SET_DEV_INFO\n"));\r\nbreak;\r\ncase OPC_OUB_PHY_START_RESP:\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"OPC_OUB_PHY_START_RESP opcode:%x\n", opc));\r\nmpi_phy_start_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_PHY_STOP_RESP:\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"OPC_OUB_PHY_STOP_RESP opcode:%x\n", opc));\r\nmpi_phy_stop_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_SET_CONTROLLER_CONFIG:\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"OPC_OUB_SET_CONTROLLER_CONFIG opcode:%x\n", opc));\r\nmpi_set_controller_config_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_GET_CONTROLLER_CONFIG:\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"OPC_OUB_GET_CONTROLLER_CONFIG opcode:%x\n", opc));\r\nmpi_get_controller_config_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_GET_PHY_PROFILE:\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"OPC_OUB_GET_PHY_PROFILE opcode:%x\n", opc));\r\nmpi_get_phy_profile_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_FLASH_OP_EXT:\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"OPC_OUB_FLASH_OP_EXT opcode:%x\n", opc));\r\nmpi_flash_op_ext_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_SET_PHY_PROFILE:\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"OPC_OUB_SET_PHY_PROFILE opcode:%x\n", opc));\r\nmpi_set_phy_profile_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_KEK_MANAGEMENT_RESP:\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"OPC_OUB_KEK_MANAGEMENT_RESP opcode:%x\n", opc));\r\nmpi_kek_management_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_DEK_MANAGEMENT_RESP:\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"OPC_OUB_DEK_MANAGEMENT_RESP opcode:%x\n", opc));\r\nmpi_dek_management_resp(pm8001_ha, piomb);\r\nbreak;\r\ncase OPC_OUB_SSP_COALESCED_COMP_RESP:\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"OPC_OUB_SSP_COALESCED_COMP_RESP opcode:%x\n", opc));\r\nssp_coalesced_comp_resp(pm8001_ha, piomb);\r\nbreak;\r\ndefault:\r\nPM8001_MSG_DBG(pm8001_ha, pm8001_printk(\r\n"Unknown outbound Queue IOMB OPC = 0x%x\n", opc));\r\nbreak;\r\n}\r\n}\r\nstatic int process_oq(struct pm8001_hba_info *pm8001_ha, u8 vec)\r\n{\r\nstruct outbound_queue_table *circularQ;\r\nvoid *pMsg1 = NULL;\r\nu8 uninitialized_var(bc);\r\nu32 ret = MPI_IO_STATUS_FAIL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pm8001_ha->lock, flags);\r\ncircularQ = &pm8001_ha->outbnd_q_tbl[vec];\r\ndo {\r\nret = pm8001_mpi_msg_consume(pm8001_ha, circularQ, &pMsg1, &bc);\r\nif (MPI_IO_STATUS_SUCCESS == ret) {\r\nprocess_one_iomb(pm8001_ha, (void *)(pMsg1 - 4));\r\npm8001_mpi_msg_free_set(pm8001_ha, pMsg1,\r\ncircularQ, bc);\r\n}\r\nif (MPI_IO_STATUS_BUSY == ret) {\r\ncircularQ->producer_index =\r\ncpu_to_le32(pm8001_read_32(circularQ->pi_virt));\r\nif (le32_to_cpu(circularQ->producer_index) ==\r\ncircularQ->consumer_idx)\r\nbreak;\r\n}\r\n} while (1);\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void build_smp_cmd(u32 deviceID, __le32 hTag,\r\nstruct smp_req *psmp_cmd, int mode, int length)\r\n{\r\npsmp_cmd->tag = hTag;\r\npsmp_cmd->device_id = cpu_to_le32(deviceID);\r\nif (mode == SMP_DIRECT) {\r\nlength = length - 4;\r\npsmp_cmd->len_ip_ir = cpu_to_le32(length << 16);\r\n} else {\r\npsmp_cmd->len_ip_ir = cpu_to_le32(1|(1 << 1));\r\n}\r\n}\r\nstatic int pm80xx_chip_smp_req(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_ccb_info *ccb)\r\n{\r\nint elem, rc;\r\nstruct sas_task *task = ccb->task;\r\nstruct domain_device *dev = task->dev;\r\nstruct pm8001_device *pm8001_dev = dev->lldd_dev;\r\nstruct scatterlist *sg_req, *sg_resp;\r\nu32 req_len, resp_len;\r\nstruct smp_req smp_cmd;\r\nu32 opc;\r\nstruct inbound_queue_table *circularQ;\r\nchar *preq_dma_addr = NULL;\r\n__le64 tmp_addr;\r\nu32 i, length;\r\nmemset(&smp_cmd, 0, sizeof(smp_cmd));\r\nsg_req = &task->smp_task.smp_req;\r\nelem = dma_map_sg(pm8001_ha->dev, sg_req, 1, PCI_DMA_TODEVICE);\r\nif (!elem)\r\nreturn -ENOMEM;\r\nreq_len = sg_dma_len(sg_req);\r\nsg_resp = &task->smp_task.smp_resp;\r\nelem = dma_map_sg(pm8001_ha->dev, sg_resp, 1, PCI_DMA_FROMDEVICE);\r\nif (!elem) {\r\nrc = -ENOMEM;\r\ngoto err_out;\r\n}\r\nresp_len = sg_dma_len(sg_resp);\r\nif ((req_len & 0x3) || (resp_len & 0x3)) {\r\nrc = -EINVAL;\r\ngoto err_out_2;\r\n}\r\nopc = OPC_INB_SMP_REQUEST;\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nsmp_cmd.tag = cpu_to_le32(ccb->ccb_tag);\r\nlength = sg_req->length;\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("SMP Frame Length %d\n", sg_req->length));\r\nif (!(length - 8))\r\npm8001_ha->smp_exp_mode = SMP_DIRECT;\r\nelse\r\npm8001_ha->smp_exp_mode = SMP_INDIRECT;\r\npm8001_ha->smp_exp_mode = SMP_DIRECT;\r\ntmp_addr = cpu_to_le64((u64)sg_dma_address(&task->smp_task.smp_req));\r\npreq_dma_addr = (char *)phys_to_virt(tmp_addr);\r\nif (pm8001_ha->smp_exp_mode == SMP_INDIRECT) {\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("SMP REQUEST INDIRECT MODE\n"));\r\nfor (i = 0; i < 4; i++)\r\nsmp_cmd.smp_req16[i] = *(preq_dma_addr + i);\r\nsmp_cmd.long_smp_req.long_req_addr =\r\ncpu_to_le64((u64)sg_dma_address\r\n(&task->smp_task.smp_req) - 4);\r\nsmp_cmd.long_smp_req.long_req_size =\r\ncpu_to_le32((u32)sg_dma_len(&task->smp_task.smp_req)-8);\r\nsmp_cmd.long_smp_req.long_resp_addr =\r\ncpu_to_le64((u64)sg_dma_address\r\n(&task->smp_task.smp_resp));\r\nsmp_cmd.long_smp_req.long_resp_size =\r\ncpu_to_le32((u32)sg_dma_len\r\n(&task->smp_task.smp_resp)-4);\r\n} else {\r\nsmp_cmd.long_smp_req.long_req_addr =\r\ncpu_to_le64((u64)sg_dma_address\r\n(&task->smp_task.smp_req));\r\nsmp_cmd.long_smp_req.long_req_size =\r\ncpu_to_le32((u32)sg_dma_len(&task->smp_task.smp_req)-4);\r\nsmp_cmd.long_smp_req.long_resp_addr =\r\ncpu_to_le64((u64)sg_dma_address\r\n(&task->smp_task.smp_resp));\r\nsmp_cmd.long_smp_req.long_resp_size =\r\ncpu_to_le32\r\n((u32)sg_dma_len(&task->smp_task.smp_resp)-4);\r\n}\r\nif (pm8001_ha->smp_exp_mode == SMP_DIRECT) {\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("SMP REQUEST DIRECT MODE\n"));\r\nfor (i = 0; i < length; i++)\r\nif (i < 16) {\r\nsmp_cmd.smp_req16[i] = *(preq_dma_addr+i);\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"Byte[%d]:%x (DMA data:%x)\n",\r\ni, smp_cmd.smp_req16[i],\r\n*(preq_dma_addr)));\r\n} else {\r\nsmp_cmd.smp_req[i] = *(preq_dma_addr+i);\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"Byte[%d]:%x (DMA data:%x)\n",\r\ni, smp_cmd.smp_req[i],\r\n*(preq_dma_addr)));\r\n}\r\n}\r\nbuild_smp_cmd(pm8001_dev->device_id, smp_cmd.tag,\r\n&smp_cmd, pm8001_ha->smp_exp_mode, length);\r\npm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, (u32 *)&smp_cmd, 0);\r\nreturn 0;\r\nerr_out_2:\r\ndma_unmap_sg(pm8001_ha->dev, &ccb->task->smp_task.smp_resp, 1,\r\nPCI_DMA_FROMDEVICE);\r\nerr_out:\r\ndma_unmap_sg(pm8001_ha->dev, &ccb->task->smp_task.smp_req, 1,\r\nPCI_DMA_TODEVICE);\r\nreturn rc;\r\n}\r\nstatic int check_enc_sas_cmd(struct sas_task *task)\r\n{\r\nu8 cmd = task->ssp_task.cmd->cmnd[0];\r\nif (cmd == READ_10 || cmd == WRITE_10 || cmd == WRITE_VERIFY)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int check_enc_sat_cmd(struct sas_task *task)\r\n{\r\nint ret = 0;\r\nswitch (task->ata_task.fis.command) {\r\ncase ATA_CMD_FPDMA_READ:\r\ncase ATA_CMD_READ_EXT:\r\ncase ATA_CMD_READ:\r\ncase ATA_CMD_FPDMA_WRITE:\r\ncase ATA_CMD_WRITE_EXT:\r\ncase ATA_CMD_WRITE:\r\ncase ATA_CMD_PIO_READ:\r\ncase ATA_CMD_PIO_READ_EXT:\r\ncase ATA_CMD_PIO_WRITE:\r\ncase ATA_CMD_PIO_WRITE_EXT:\r\nret = 1;\r\nbreak;\r\ndefault:\r\nret = 0;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int pm80xx_chip_ssp_io_req(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_ccb_info *ccb)\r\n{\r\nstruct sas_task *task = ccb->task;\r\nstruct domain_device *dev = task->dev;\r\nstruct pm8001_device *pm8001_dev = dev->lldd_dev;\r\nstruct ssp_ini_io_start_req ssp_cmd;\r\nu32 tag = ccb->ccb_tag;\r\nint ret;\r\nu64 phys_addr;\r\nstruct inbound_queue_table *circularQ;\r\nstatic u32 inb;\r\nstatic u32 outb;\r\nu32 opc = OPC_INB_SSPINIIOSTART;\r\nmemset(&ssp_cmd, 0, sizeof(ssp_cmd));\r\nmemcpy(ssp_cmd.ssp_iu.lun, task->ssp_task.LUN, 8);\r\nssp_cmd.dad_dir_m_tlr =\r\ncpu_to_le32(data_dir_flags[task->data_dir] << 8 | 0x0);\r\nssp_cmd.data_len = cpu_to_le32(task->total_xfer_len);\r\nssp_cmd.device_id = cpu_to_le32(pm8001_dev->device_id);\r\nssp_cmd.tag = cpu_to_le32(tag);\r\nif (task->ssp_task.enable_first_burst)\r\nssp_cmd.ssp_iu.efb_prio_attr |= 0x80;\r\nssp_cmd.ssp_iu.efb_prio_attr |= (task->ssp_task.task_prio << 3);\r\nssp_cmd.ssp_iu.efb_prio_attr |= (task->ssp_task.task_attr & 7);\r\nmemcpy(ssp_cmd.ssp_iu.cdb, task->ssp_task.cmd->cmnd,\r\ntask->ssp_task.cmd->cmd_len);\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nif (pm8001_ha->chip->encrypt &&\r\n!(pm8001_ha->encrypt_info.status) && check_enc_sas_cmd(task)) {\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"Encryption enabled.Sending Encrypt SAS command 0x%x\n",\r\ntask->ssp_task.cmd->cmnd[0]));\r\nopc = OPC_INB_SSP_INI_DIF_ENC_IO;\r\nssp_cmd.dad_dir_m_tlr = cpu_to_le32\r\n((data_dir_flags[task->data_dir] << 8) | 0x20 | 0x0);\r\nif (task->num_scatter > 1) {\r\npm8001_chip_make_sg(task->scatter,\r\nccb->n_elem, ccb->buf_prd);\r\nphys_addr = ccb->ccb_dma_handle +\r\noffsetof(struct pm8001_ccb_info, buf_prd[0]);\r\nssp_cmd.enc_addr_low =\r\ncpu_to_le32(lower_32_bits(phys_addr));\r\nssp_cmd.enc_addr_high =\r\ncpu_to_le32(upper_32_bits(phys_addr));\r\nssp_cmd.enc_esgl = cpu_to_le32(1<<31);\r\n} else if (task->num_scatter == 1) {\r\nu64 dma_addr = sg_dma_address(task->scatter);\r\nssp_cmd.enc_addr_low =\r\ncpu_to_le32(lower_32_bits(dma_addr));\r\nssp_cmd.enc_addr_high =\r\ncpu_to_le32(upper_32_bits(dma_addr));\r\nssp_cmd.enc_len = cpu_to_le32(task->total_xfer_len);\r\nssp_cmd.enc_esgl = 0;\r\n} else if (task->num_scatter == 0) {\r\nssp_cmd.enc_addr_low = 0;\r\nssp_cmd.enc_addr_high = 0;\r\nssp_cmd.enc_len = cpu_to_le32(task->total_xfer_len);\r\nssp_cmd.enc_esgl = 0;\r\n}\r\nssp_cmd.key_cmode = 0x6 << 4;\r\nssp_cmd.twk_val0 = cpu_to_le32((task->ssp_task.cmd->cmnd[2] << 24) |\r\n(task->ssp_task.cmd->cmnd[3] << 16) |\r\n(task->ssp_task.cmd->cmnd[4] << 8) |\r\n(task->ssp_task.cmd->cmnd[5]));\r\n} else {\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"Sending Normal SAS command 0x%x inb q %x\n",\r\ntask->ssp_task.cmd->cmnd[0], inb));\r\nif (task->num_scatter > 1) {\r\npm8001_chip_make_sg(task->scatter, ccb->n_elem,\r\nccb->buf_prd);\r\nphys_addr = ccb->ccb_dma_handle +\r\noffsetof(struct pm8001_ccb_info, buf_prd[0]);\r\nssp_cmd.addr_low =\r\ncpu_to_le32(lower_32_bits(phys_addr));\r\nssp_cmd.addr_high =\r\ncpu_to_le32(upper_32_bits(phys_addr));\r\nssp_cmd.esgl = cpu_to_le32(1<<31);\r\n} else if (task->num_scatter == 1) {\r\nu64 dma_addr = sg_dma_address(task->scatter);\r\nssp_cmd.addr_low = cpu_to_le32(lower_32_bits(dma_addr));\r\nssp_cmd.addr_high =\r\ncpu_to_le32(upper_32_bits(dma_addr));\r\nssp_cmd.len = cpu_to_le32(task->total_xfer_len);\r\nssp_cmd.esgl = 0;\r\n} else if (task->num_scatter == 0) {\r\nssp_cmd.addr_low = 0;\r\nssp_cmd.addr_high = 0;\r\nssp_cmd.len = cpu_to_le32(task->total_xfer_len);\r\nssp_cmd.esgl = 0;\r\n}\r\n}\r\nret = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &ssp_cmd, outb++);\r\noutb = outb%PM8001_MAX_SPCV_OUTB_NUM;\r\nreturn ret;\r\n}\r\nstatic int pm80xx_chip_sata_req(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_ccb_info *ccb)\r\n{\r\nstruct sas_task *task = ccb->task;\r\nstruct domain_device *dev = task->dev;\r\nstruct pm8001_device *pm8001_ha_dev = dev->lldd_dev;\r\nu32 tag = ccb->ccb_tag;\r\nint ret;\r\nstatic u32 inb;\r\nstatic u32 outb;\r\nstruct sata_start_req sata_cmd;\r\nu32 hdr_tag, ncg_tag = 0;\r\nu64 phys_addr;\r\nu32 ATAP = 0x0;\r\nu32 dir;\r\nstruct inbound_queue_table *circularQ;\r\nunsigned long flags;\r\nu32 opc = OPC_INB_SATA_HOST_OPSTART;\r\nmemset(&sata_cmd, 0, sizeof(sata_cmd));\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nif (task->data_dir == PCI_DMA_NONE) {\r\nATAP = 0x04;\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("no data\n"));\r\n} else if (likely(!task->ata_task.device_control_reg_update)) {\r\nif (task->ata_task.dma_xfer) {\r\nATAP = 0x06;\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("DMA\n"));\r\n} else {\r\nATAP = 0x05;\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("PIO\n"));\r\n}\r\nif (task->ata_task.use_ncq &&\r\ndev->sata_dev.command_set != ATAPI_COMMAND_SET) {\r\nATAP = 0x07;\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("FPDMA\n"));\r\n}\r\n}\r\nif (task->ata_task.use_ncq && pm8001_get_ncq_tag(task, &hdr_tag)) {\r\ntask->ata_task.fis.sector_count |= (u8) (hdr_tag << 3);\r\nncg_tag = hdr_tag;\r\n}\r\ndir = data_dir_flags[task->data_dir] << 8;\r\nsata_cmd.tag = cpu_to_le32(tag);\r\nsata_cmd.device_id = cpu_to_le32(pm8001_ha_dev->device_id);\r\nsata_cmd.data_len = cpu_to_le32(task->total_xfer_len);\r\nsata_cmd.sata_fis = task->ata_task.fis;\r\nif (likely(!task->ata_task.device_control_reg_update))\r\nsata_cmd.sata_fis.flags |= 0x80;\r\nsata_cmd.sata_fis.flags &= 0xF0;\r\nif (pm8001_ha->chip->encrypt &&\r\n!(pm8001_ha->encrypt_info.status) && check_enc_sat_cmd(task)) {\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"Encryption enabled.Sending Encrypt SATA cmd 0x%x\n",\r\nsata_cmd.sata_fis.command));\r\nopc = OPC_INB_SATA_DIF_ENC_IO;\r\nsata_cmd.ncqtag_atap_dir_m_dad =\r\ncpu_to_le32(((ncg_tag & 0xff)<<16)|\r\n((ATAP & 0x3f) << 10) | 0x20 | dir);\r\nif (task->num_scatter > 1) {\r\npm8001_chip_make_sg(task->scatter,\r\nccb->n_elem, ccb->buf_prd);\r\nphys_addr = ccb->ccb_dma_handle +\r\noffsetof(struct pm8001_ccb_info, buf_prd[0]);\r\nsata_cmd.enc_addr_low = lower_32_bits(phys_addr);\r\nsata_cmd.enc_addr_high = upper_32_bits(phys_addr);\r\nsata_cmd.enc_esgl = cpu_to_le32(1 << 31);\r\n} else if (task->num_scatter == 1) {\r\nu64 dma_addr = sg_dma_address(task->scatter);\r\nsata_cmd.enc_addr_low = lower_32_bits(dma_addr);\r\nsata_cmd.enc_addr_high = upper_32_bits(dma_addr);\r\nsata_cmd.enc_len = cpu_to_le32(task->total_xfer_len);\r\nsata_cmd.enc_esgl = 0;\r\n} else if (task->num_scatter == 0) {\r\nsata_cmd.enc_addr_low = 0;\r\nsata_cmd.enc_addr_high = 0;\r\nsata_cmd.enc_len = cpu_to_le32(task->total_xfer_len);\r\nsata_cmd.enc_esgl = 0;\r\n}\r\nsata_cmd.key_index_mode = 0x6 << 4;\r\nsata_cmd.twk_val0 =\r\ncpu_to_le32((sata_cmd.sata_fis.lbal_exp << 24) |\r\n(sata_cmd.sata_fis.lbah << 16) |\r\n(sata_cmd.sata_fis.lbam << 8) |\r\n(sata_cmd.sata_fis.lbal));\r\nsata_cmd.twk_val1 =\r\ncpu_to_le32((sata_cmd.sata_fis.lbah_exp << 8) |\r\n(sata_cmd.sata_fis.lbam_exp));\r\n} else {\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk(\r\n"Sending Normal SATA command 0x%x inb %x\n",\r\nsata_cmd.sata_fis.command, inb));\r\nsata_cmd.ncqtag_atap_dir_m_dad =\r\ncpu_to_le32(((ncg_tag & 0xff)<<16) |\r\n((ATAP & 0x3f) << 10) | dir);\r\nif (task->num_scatter > 1) {\r\npm8001_chip_make_sg(task->scatter,\r\nccb->n_elem, ccb->buf_prd);\r\nphys_addr = ccb->ccb_dma_handle +\r\noffsetof(struct pm8001_ccb_info, buf_prd[0]);\r\nsata_cmd.addr_low = lower_32_bits(phys_addr);\r\nsata_cmd.addr_high = upper_32_bits(phys_addr);\r\nsata_cmd.esgl = cpu_to_le32(1 << 31);\r\n} else if (task->num_scatter == 1) {\r\nu64 dma_addr = sg_dma_address(task->scatter);\r\nsata_cmd.addr_low = lower_32_bits(dma_addr);\r\nsata_cmd.addr_high = upper_32_bits(dma_addr);\r\nsata_cmd.len = cpu_to_le32(task->total_xfer_len);\r\nsata_cmd.esgl = 0;\r\n} else if (task->num_scatter == 0) {\r\nsata_cmd.addr_low = 0;\r\nsata_cmd.addr_high = 0;\r\nsata_cmd.len = cpu_to_le32(task->total_xfer_len);\r\nsata_cmd.esgl = 0;\r\n}\r\nsata_cmd.atapi_scsi_cdb[0] =\r\ncpu_to_le32(((task->ata_task.atapi_packet[0]) |\r\n(task->ata_task.atapi_packet[1] << 8) |\r\n(task->ata_task.atapi_packet[2] << 16) |\r\n(task->ata_task.atapi_packet[3] << 24)));\r\nsata_cmd.atapi_scsi_cdb[1] =\r\ncpu_to_le32(((task->ata_task.atapi_packet[4]) |\r\n(task->ata_task.atapi_packet[5] << 8) |\r\n(task->ata_task.atapi_packet[6] << 16) |\r\n(task->ata_task.atapi_packet[7] << 24)));\r\nsata_cmd.atapi_scsi_cdb[2] =\r\ncpu_to_le32(((task->ata_task.atapi_packet[8]) |\r\n(task->ata_task.atapi_packet[9] << 8) |\r\n(task->ata_task.atapi_packet[10] << 16) |\r\n(task->ata_task.atapi_packet[11] << 24)));\r\nsata_cmd.atapi_scsi_cdb[3] =\r\ncpu_to_le32(((task->ata_task.atapi_packet[12]) |\r\n(task->ata_task.atapi_packet[13] << 8) |\r\n(task->ata_task.atapi_packet[14] << 16) |\r\n(task->ata_task.atapi_packet[15] << 24)));\r\n}\r\nif (sata_cmd.sata_fis.command == 0x2f) {\r\nif (pm8001_ha_dev && ((pm8001_ha_dev->id & NCQ_READ_LOG_FLAG) ||\r\n(pm8001_ha_dev->id & NCQ_ABORT_ALL_FLAG) ||\r\n(pm8001_ha_dev->id & NCQ_2ND_RLE_FLAG))) {\r\nstruct task_status_struct *ts;\r\npm8001_ha_dev->id &= 0xDFFFFFFF;\r\nts = &task->task_status;\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAM_STAT_GOOD;\r\ntask->task_state_flags &= ~SAS_TASK_STATE_PENDING;\r\ntask->task_state_flags &= ~SAS_TASK_AT_INITIATOR;\r\ntask->task_state_flags |= SAS_TASK_STATE_DONE;\r\nif (unlikely((task->task_state_flags &\r\nSAS_TASK_STATE_ABORTED))) {\r\nspin_unlock_irqrestore(&task->task_state_lock,\r\nflags);\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("task 0x%p resp 0x%x "\r\n" stat 0x%x but aborted by upper layer "\r\n"\n", task, ts->resp, ts->stat));\r\npm8001_ccb_task_free(pm8001_ha, task, ccb, tag);\r\nreturn 0;\r\n} else if (task->uldd_task) {\r\nspin_unlock_irqrestore(&task->task_state_lock,\r\nflags);\r\npm8001_ccb_task_free(pm8001_ha, task, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\ntask->task_done(task);\r\nspin_lock_irq(&pm8001_ha->lock);\r\nreturn 0;\r\n} else if (!task->uldd_task) {\r\nspin_unlock_irqrestore(&task->task_state_lock,\r\nflags);\r\npm8001_ccb_task_free(pm8001_ha, task, ccb, tag);\r\nmb();\r\nspin_unlock_irq(&pm8001_ha->lock);\r\ntask->task_done(task);\r\nspin_lock_irq(&pm8001_ha->lock);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nret = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc,\r\n&sata_cmd, outb++);\r\noutb = outb%PM8001_MAX_SPCV_OUTB_NUM;\r\nreturn ret;\r\n}\r\nstatic int\r\npm80xx_chip_phy_start_req(struct pm8001_hba_info *pm8001_ha, u8 phy_id)\r\n{\r\nstruct phy_start_req payload;\r\nstruct inbound_queue_table *circularQ;\r\nint ret;\r\nu32 tag = 0x01;\r\nu32 opcode = OPC_INB_PHYSTART;\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nmemset(&payload, 0, sizeof(payload));\r\npayload.tag = cpu_to_le32(tag);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("PHY START REQ for phy_id %d\n", phy_id));\r\npayload.ase_sh_lm_slr_phyid = cpu_to_le32(SPINHOLD_DISABLE |\r\nLINKMODE_AUTO | LINKRATE_15 |\r\nLINKRATE_30 | LINKRATE_60 | phy_id);\r\npayload.sas_identify.dev_type = SAS_END_DEVICE;\r\npayload.sas_identify.initiator_bits = SAS_PROTOCOL_ALL;\r\nmemcpy(payload.sas_identify.sas_addr,\r\npm8001_ha->sas_addr, SAS_ADDR_SIZE);\r\npayload.sas_identify.phy_id = phy_id;\r\nret = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opcode, &payload, 0);\r\nreturn ret;\r\n}\r\nstatic int pm80xx_chip_phy_stop_req(struct pm8001_hba_info *pm8001_ha,\r\nu8 phy_id)\r\n{\r\nstruct phy_stop_req payload;\r\nstruct inbound_queue_table *circularQ;\r\nint ret;\r\nu32 tag = 0x01;\r\nu32 opcode = OPC_INB_PHYSTOP;\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nmemset(&payload, 0, sizeof(payload));\r\npayload.tag = cpu_to_le32(tag);\r\npayload.phy_id = cpu_to_le32(phy_id);\r\nret = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opcode, &payload, 0);\r\nreturn ret;\r\n}\r\nstatic int pm80xx_chip_reg_dev_req(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_device *pm8001_dev, u32 flag)\r\n{\r\nstruct reg_dev_req payload;\r\nu32 opc;\r\nu32 stp_sspsmp_sata = 0x4;\r\nstruct inbound_queue_table *circularQ;\r\nu32 linkrate, phy_id;\r\nint rc, tag = 0xdeadbeef;\r\nstruct pm8001_ccb_info *ccb;\r\nu8 retryFlag = 0x1;\r\nu16 firstBurstSize = 0;\r\nu16 ITNT = 2000;\r\nstruct domain_device *dev = pm8001_dev->sas_device;\r\nstruct domain_device *parent_dev = dev->parent;\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\nmemset(&payload, 0, sizeof(payload));\r\nrc = pm8001_tag_alloc(pm8001_ha, &tag);\r\nif (rc)\r\nreturn rc;\r\nccb = &pm8001_ha->ccb_info[tag];\r\nccb->device = pm8001_dev;\r\nccb->ccb_tag = tag;\r\npayload.tag = cpu_to_le32(tag);\r\nif (flag == 1) {\r\nstp_sspsmp_sata = 0x02;\r\n} else {\r\nif (pm8001_dev->dev_type == SAS_SATA_DEV)\r\nstp_sspsmp_sata = 0x00;\r\nelse if (pm8001_dev->dev_type == SAS_END_DEVICE ||\r\npm8001_dev->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\r\npm8001_dev->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\r\nstp_sspsmp_sata = 0x01;\r\n}\r\nif (parent_dev && DEV_IS_EXPANDER(parent_dev->dev_type))\r\nphy_id = parent_dev->ex_dev.ex_phy->phy_id;\r\nelse\r\nphy_id = pm8001_dev->attached_phy;\r\nopc = OPC_INB_REG_DEV;\r\nlinkrate = (pm8001_dev->sas_device->linkrate < dev->port->linkrate) ?\r\npm8001_dev->sas_device->linkrate : dev->port->linkrate;\r\npayload.phyid_portid =\r\ncpu_to_le32(((pm8001_dev->sas_device->port->id) & 0xFF) |\r\n((phy_id & 0xFF) << 8));\r\npayload.dtype_dlr_mcn_ir_retry = cpu_to_le32((retryFlag & 0x01) |\r\n((linkrate & 0x0F) << 24) |\r\n((stp_sspsmp_sata & 0x03) << 28));\r\npayload.firstburstsize_ITNexustimeout =\r\ncpu_to_le32(ITNT | (firstBurstSize * 0x10000));\r\nmemcpy(payload.sas_addr, pm8001_dev->sas_device->sas_addr,\r\nSAS_ADDR_SIZE);\r\nrc = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &payload, 0);\r\nreturn rc;\r\n}\r\nstatic int pm80xx_chip_phy_ctl_req(struct pm8001_hba_info *pm8001_ha,\r\nu32 phyId, u32 phy_op)\r\n{\r\nstruct local_phy_ctl_req payload;\r\nstruct inbound_queue_table *circularQ;\r\nint ret;\r\nu32 opc = OPC_INB_LOCAL_PHY_CONTROL;\r\nmemset(&payload, 0, sizeof(payload));\r\ncircularQ = &pm8001_ha->inbnd_q_tbl[0];\r\npayload.tag = cpu_to_le32(1);\r\npayload.phyop_phyid =\r\ncpu_to_le32(((phy_op & 0xFF) << 8) | (phyId & 0xFF));\r\nret = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &payload, 0);\r\nreturn ret;\r\n}\r\nstatic u32 pm80xx_chip_is_our_interupt(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu32 value;\r\n#ifdef PM8001_USE_MSIX\r\nreturn 1;\r\n#endif\r\nvalue = pm8001_cr32(pm8001_ha, 0, MSGU_ODR);\r\nif (value)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t\r\npm80xx_chip_isr(struct pm8001_hba_info *pm8001_ha, u8 vec)\r\n{\r\npm80xx_chip_interrupt_disable(pm8001_ha, vec);\r\nprocess_oq(pm8001_ha, vec);\r\npm80xx_chip_interrupt_enable(pm8001_ha, vec);\r\nreturn IRQ_HANDLED;\r\n}
