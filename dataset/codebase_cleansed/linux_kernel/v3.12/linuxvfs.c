static int\r\nbefs_readpage(struct file *file, struct page *page)\r\n{\r\nreturn block_read_full_page(page, befs_get_block);\r\n}\r\nstatic sector_t\r\nbefs_bmap(struct address_space *mapping, sector_t block)\r\n{\r\nreturn generic_block_bmap(mapping, block, befs_get_block);\r\n}\r\nstatic int\r\nbefs_get_block(struct inode *inode, sector_t block,\r\nstruct buffer_head *bh_result, int create)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nbefs_data_stream *ds = &BEFS_I(inode)->i_data.ds;\r\nbefs_block_run run = BAD_IADDR;\r\nint res = 0;\r\nulong disk_off;\r\nbefs_debug(sb, "---> befs_get_block() for inode %lu, block %ld",\r\ninode->i_ino, block);\r\nif (block < 0) {\r\nbefs_error(sb, "befs_get_block() was asked for a block "\r\n"number less than zero: block %ld in inode %lu",\r\nblock, inode->i_ino);\r\nreturn -EIO;\r\n}\r\nif (create) {\r\nbefs_error(sb, "befs_get_block() was asked to write to "\r\n"block %ld in inode %lu", block, inode->i_ino);\r\nreturn -EPERM;\r\n}\r\nres = befs_fblock2brun(sb, ds, block, &run);\r\nif (res != BEFS_OK) {\r\nbefs_error(sb,\r\n"<--- befs_get_block() for inode %lu, block "\r\n"%ld ERROR", inode->i_ino, block);\r\nreturn -EFBIG;\r\n}\r\ndisk_off = (ulong) iaddr2blockno(sb, &run);\r\nmap_bh(bh_result, inode->i_sb, disk_off);\r\nbefs_debug(sb, "<--- befs_get_block() for inode %lu, block %ld, "\r\n"disk address %lu", inode->i_ino, block, disk_off);\r\nreturn 0;\r\n}\r\nstatic struct dentry *\r\nbefs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\r\n{\r\nstruct inode *inode = NULL;\r\nstruct super_block *sb = dir->i_sb;\r\nbefs_data_stream *ds = &BEFS_I(dir)->i_data.ds;\r\nbefs_off_t offset;\r\nint ret;\r\nint utfnamelen;\r\nchar *utfname;\r\nconst char *name = dentry->d_name.name;\r\nbefs_debug(sb, "---> befs_lookup() "\r\n"name %s inode %ld", dentry->d_name.name, dir->i_ino);\r\nif (BEFS_SB(sb)->nls) {\r\nret =\r\nbefs_nls2utf(sb, name, strlen(name), &utfname, &utfnamelen);\r\nif (ret < 0) {\r\nbefs_debug(sb, "<--- befs_lookup() ERROR");\r\nreturn ERR_PTR(ret);\r\n}\r\nret = befs_btree_find(sb, ds, utfname, &offset);\r\nkfree(utfname);\r\n} else {\r\nret = befs_btree_find(sb, ds, dentry->d_name.name, &offset);\r\n}\r\nif (ret == BEFS_BT_NOT_FOUND) {\r\nbefs_debug(sb, "<--- befs_lookup() %s not found",\r\ndentry->d_name.name);\r\nreturn ERR_PTR(-ENOENT);\r\n} else if (ret != BEFS_OK || offset == 0) {\r\nbefs_warning(sb, "<--- befs_lookup() Error");\r\nreturn ERR_PTR(-ENODATA);\r\n}\r\ninode = befs_iget(dir->i_sb, (ino_t) offset);\r\nif (IS_ERR(inode))\r\nreturn ERR_CAST(inode);\r\nd_add(dentry, inode);\r\nbefs_debug(sb, "<--- befs_lookup()");\r\nreturn NULL;\r\n}\r\nstatic int\r\nbefs_readdir(struct file *file, struct dir_context *ctx)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nstruct super_block *sb = inode->i_sb;\r\nbefs_data_stream *ds = &BEFS_I(inode)->i_data.ds;\r\nbefs_off_t value;\r\nint result;\r\nsize_t keysize;\r\nunsigned char d_type;\r\nchar keybuf[BEFS_NAME_LEN + 1];\r\nconst char *dirname = file->f_path.dentry->d_name.name;\r\nbefs_debug(sb, "---> befs_readdir() "\r\n"name %s, inode %ld, ctx->pos %Ld",\r\ndirname, inode->i_ino, ctx->pos);\r\nmore:\r\nresult = befs_btree_read(sb, ds, ctx->pos, BEFS_NAME_LEN + 1,\r\nkeybuf, &keysize, &value);\r\nif (result == BEFS_ERR) {\r\nbefs_debug(sb, "<--- befs_readdir() ERROR");\r\nbefs_error(sb, "IO error reading %s (inode %lu)",\r\ndirname, inode->i_ino);\r\nreturn -EIO;\r\n} else if (result == BEFS_BT_END) {\r\nbefs_debug(sb, "<--- befs_readdir() END");\r\nreturn 0;\r\n} else if (result == BEFS_BT_EMPTY) {\r\nbefs_debug(sb, "<--- befs_readdir() Empty directory");\r\nreturn 0;\r\n}\r\nd_type = DT_UNKNOWN;\r\nif (BEFS_SB(sb)->nls) {\r\nchar *nlsname;\r\nint nlsnamelen;\r\nresult =\r\nbefs_utf2nls(sb, keybuf, keysize, &nlsname, &nlsnamelen);\r\nif (result < 0) {\r\nbefs_debug(sb, "<--- befs_readdir() ERROR");\r\nreturn result;\r\n}\r\nif (!dir_emit(ctx, nlsname, nlsnamelen,\r\n(ino_t) value, d_type)) {\r\nkfree(nlsname);\r\nreturn 0;\r\n}\r\nkfree(nlsname);\r\n} else {\r\nif (!dir_emit(ctx, keybuf, keysize,\r\n(ino_t) value, d_type))\r\nreturn 0;\r\n}\r\nctx->pos++;\r\ngoto more;\r\nbefs_debug(sb, "<--- befs_readdir() pos %Ld", ctx->pos);\r\nreturn 0;\r\n}\r\nstatic struct inode *\r\nbefs_alloc_inode(struct super_block *sb)\r\n{\r\nstruct befs_inode_info *bi;\r\nbi = (struct befs_inode_info *)kmem_cache_alloc(befs_inode_cachep,\r\nGFP_KERNEL);\r\nif (!bi)\r\nreturn NULL;\r\nreturn &bi->vfs_inode;\r\n}\r\nstatic void befs_i_callback(struct rcu_head *head)\r\n{\r\nstruct inode *inode = container_of(head, struct inode, i_rcu);\r\nkmem_cache_free(befs_inode_cachep, BEFS_I(inode));\r\n}\r\nstatic void befs_destroy_inode(struct inode *inode)\r\n{\r\ncall_rcu(&inode->i_rcu, befs_i_callback);\r\n}\r\nstatic void init_once(void *foo)\r\n{\r\nstruct befs_inode_info *bi = (struct befs_inode_info *) foo;\r\ninode_init_once(&bi->vfs_inode);\r\n}\r\nstatic struct inode *befs_iget(struct super_block *sb, unsigned long ino)\r\n{\r\nstruct buffer_head *bh = NULL;\r\nbefs_inode *raw_inode = NULL;\r\nbefs_sb_info *befs_sb = BEFS_SB(sb);\r\nbefs_inode_info *befs_ino = NULL;\r\nstruct inode *inode;\r\nlong ret = -EIO;\r\nbefs_debug(sb, "---> befs_read_inode() " "inode = %lu", ino);\r\ninode = iget_locked(sb, ino);\r\nif (IS_ERR(inode))\r\nreturn inode;\r\nif (!(inode->i_state & I_NEW))\r\nreturn inode;\r\nbefs_ino = BEFS_I(inode);\r\nbefs_ino->i_inode_num = blockno2iaddr(sb, inode->i_ino);\r\nbefs_debug(sb, " real inode number [%u, %hu, %hu]",\r\nbefs_ino->i_inode_num.allocation_group,\r\nbefs_ino->i_inode_num.start, befs_ino->i_inode_num.len);\r\nbh = befs_bread(sb, inode->i_ino);\r\nif (!bh) {\r\nbefs_error(sb, "unable to read inode block - "\r\n"inode = %lu", inode->i_ino);\r\ngoto unacquire_none;\r\n}\r\nraw_inode = (befs_inode *) bh->b_data;\r\nbefs_dump_inode(sb, raw_inode);\r\nif (befs_check_inode(sb, raw_inode, inode->i_ino) != BEFS_OK) {\r\nbefs_error(sb, "Bad inode: %lu", inode->i_ino);\r\ngoto unacquire_bh;\r\n}\r\ninode->i_mode = (umode_t) fs32_to_cpu(sb, raw_inode->mode);\r\ninode->i_uid = befs_sb->mount_opts.use_uid ?\r\nbefs_sb->mount_opts.uid :\r\nmake_kuid(&init_user_ns, fs32_to_cpu(sb, raw_inode->uid));\r\ninode->i_gid = befs_sb->mount_opts.use_gid ?\r\nbefs_sb->mount_opts.gid :\r\nmake_kgid(&init_user_ns, fs32_to_cpu(sb, raw_inode->gid));\r\nset_nlink(inode, 1);\r\ninode->i_mtime.tv_sec =\r\nfs64_to_cpu(sb, raw_inode->last_modified_time) >> 16;\r\ninode->i_mtime.tv_nsec = 0;\r\ninode->i_ctime = inode->i_mtime;\r\ninode->i_atime = inode->i_mtime;\r\nbefs_ino->i_inode_num = fsrun_to_cpu(sb, raw_inode->inode_num);\r\nbefs_ino->i_parent = fsrun_to_cpu(sb, raw_inode->parent);\r\nbefs_ino->i_attribute = fsrun_to_cpu(sb, raw_inode->attributes);\r\nbefs_ino->i_flags = fs32_to_cpu(sb, raw_inode->flags);\r\nif (S_ISLNK(inode->i_mode) && !(befs_ino->i_flags & BEFS_LONG_SYMLINK)){\r\ninode->i_size = 0;\r\ninode->i_blocks = befs_sb->block_size / VFS_BLOCK_SIZE;\r\nstrncpy(befs_ino->i_data.symlink, raw_inode->data.symlink,\r\nBEFS_SYMLINK_LEN - 1);\r\nbefs_ino->i_data.symlink[BEFS_SYMLINK_LEN - 1] = '\0';\r\n} else {\r\nint num_blks;\r\nbefs_ino->i_data.ds =\r\nfsds_to_cpu(sb, &raw_inode->data.datastream);\r\nnum_blks = befs_count_blocks(sb, &befs_ino->i_data.ds);\r\ninode->i_blocks =\r\nnum_blks * (befs_sb->block_size / VFS_BLOCK_SIZE);\r\ninode->i_size = befs_ino->i_data.ds.size;\r\n}\r\ninode->i_mapping->a_ops = &befs_aops;\r\nif (S_ISREG(inode->i_mode)) {\r\ninode->i_fop = &generic_ro_fops;\r\n} else if (S_ISDIR(inode->i_mode)) {\r\ninode->i_op = &befs_dir_inode_operations;\r\ninode->i_fop = &befs_dir_operations;\r\n} else if (S_ISLNK(inode->i_mode)) {\r\ninode->i_op = &befs_symlink_inode_operations;\r\n} else {\r\nbefs_error(sb, "Inode %lu is not a regular file, "\r\n"directory or symlink. THAT IS WRONG! BeFS has no "\r\n"on disk special files", inode->i_ino);\r\ngoto unacquire_bh;\r\n}\r\nbrelse(bh);\r\nbefs_debug(sb, "<--- befs_read_inode()");\r\nunlock_new_inode(inode);\r\nreturn inode;\r\nunacquire_bh:\r\nbrelse(bh);\r\nunacquire_none:\r\niget_failed(inode);\r\nbefs_debug(sb, "<--- befs_read_inode() - Bad inode");\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int\r\nbefs_init_inodecache(void)\r\n{\r\nbefs_inode_cachep = kmem_cache_create("befs_inode_cache",\r\nsizeof (struct befs_inode_info),\r\n0, (SLAB_RECLAIM_ACCOUNT|\r\nSLAB_MEM_SPREAD),\r\ninit_once);\r\nif (befs_inode_cachep == NULL) {\r\nprintk(KERN_ERR "befs_init_inodecache: "\r\n"Couldn't initialize inode slabcache\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nbefs_destroy_inodecache(void)\r\n{\r\nrcu_barrier();\r\nkmem_cache_destroy(befs_inode_cachep);\r\n}\r\nstatic void *\r\nbefs_follow_link(struct dentry *dentry, struct nameidata *nd)\r\n{\r\nbefs_inode_info *befs_ino = BEFS_I(dentry->d_inode);\r\nchar *link;\r\nif (befs_ino->i_flags & BEFS_LONG_SYMLINK) {\r\nstruct super_block *sb = dentry->d_sb;\r\nbefs_data_stream *data = &befs_ino->i_data.ds;\r\nbefs_off_t len = data->size;\r\nif (len == 0) {\r\nbefs_error(sb, "Long symlink with illegal length");\r\nlink = ERR_PTR(-EIO);\r\n} else {\r\nbefs_debug(sb, "Follow long symlink");\r\nlink = kmalloc(len, GFP_NOFS);\r\nif (!link) {\r\nlink = ERR_PTR(-ENOMEM);\r\n} else if (befs_read_lsymlink(sb, data, link, len) != len) {\r\nkfree(link);\r\nbefs_error(sb, "Failed to read entire long symlink");\r\nlink = ERR_PTR(-EIO);\r\n} else {\r\nlink[len - 1] = '\0';\r\n}\r\n}\r\n} else {\r\nlink = befs_ino->i_data.symlink;\r\n}\r\nnd_set_link(nd, link);\r\nreturn NULL;\r\n}\r\nstatic void befs_put_link(struct dentry *dentry, struct nameidata *nd, void *p)\r\n{\r\nbefs_inode_info *befs_ino = BEFS_I(dentry->d_inode);\r\nif (befs_ino->i_flags & BEFS_LONG_SYMLINK) {\r\nchar *link = nd_get_link(nd);\r\nif (!IS_ERR(link))\r\nkfree(link);\r\n}\r\n}\r\nstatic int\r\nbefs_utf2nls(struct super_block *sb, const char *in,\r\nint in_len, char **out, int *out_len)\r\n{\r\nstruct nls_table *nls = BEFS_SB(sb)->nls;\r\nint i, o;\r\nunicode_t uni;\r\nint unilen, utflen;\r\nchar *result;\r\nint maxlen = in_len + 1;\r\nbefs_debug(sb, "---> utf2nls()");\r\nif (!nls) {\r\nbefs_error(sb, "befs_utf2nls called with no NLS table loaded");\r\nreturn -EINVAL;\r\n}\r\n*out = result = kmalloc(maxlen, GFP_NOFS);\r\nif (!*out) {\r\nbefs_error(sb, "befs_utf2nls() cannot allocate memory");\r\n*out_len = 0;\r\nreturn -ENOMEM;\r\n}\r\nfor (i = o = 0; i < in_len; i += utflen, o += unilen) {\r\nutflen = utf8_to_utf32(&in[i], in_len - i, &uni);\r\nif (utflen < 0)\r\ngoto conv_err;\r\nif (uni > MAX_WCHAR_T)\r\ngoto conv_err;\r\nunilen = nls->uni2char(uni, &result[o], in_len - o);\r\nif (unilen < 0)\r\ngoto conv_err;\r\n}\r\nresult[o] = '\0';\r\n*out_len = o;\r\nbefs_debug(sb, "<--- utf2nls()");\r\nreturn o;\r\nconv_err:\r\nbefs_error(sb, "Name using character set %s contains a character that "\r\n"cannot be converted to unicode.", nls->charset);\r\nbefs_debug(sb, "<--- utf2nls()");\r\nkfree(result);\r\nreturn -EILSEQ;\r\n}\r\nstatic int\r\nbefs_nls2utf(struct super_block *sb, const char *in,\r\nint in_len, char **out, int *out_len)\r\n{\r\nstruct nls_table *nls = BEFS_SB(sb)->nls;\r\nint i, o;\r\nwchar_t uni;\r\nint unilen, utflen;\r\nchar *result;\r\nint maxlen = (3 * in_len) + 1;\r\nbefs_debug(sb, "---> nls2utf()\n");\r\nif (!nls) {\r\nbefs_error(sb, "befs_nls2utf called with no NLS table loaded.");\r\nreturn -EINVAL;\r\n}\r\n*out = result = kmalloc(maxlen, GFP_NOFS);\r\nif (!*out) {\r\nbefs_error(sb, "befs_nls2utf() cannot allocate memory");\r\n*out_len = 0;\r\nreturn -ENOMEM;\r\n}\r\nfor (i = o = 0; i < in_len; i += unilen, o += utflen) {\r\nunilen = nls->char2uni(&in[i], in_len - i, &uni);\r\nif (unilen < 0)\r\ngoto conv_err;\r\nutflen = utf32_to_utf8(uni, &result[o], 3);\r\nif (utflen <= 0)\r\ngoto conv_err;\r\n}\r\nresult[o] = '\0';\r\n*out_len = o;\r\nbefs_debug(sb, "<--- nls2utf()");\r\nreturn i;\r\nconv_err:\r\nbefs_error(sb, "Name using charecter set %s contains a charecter that "\r\n"cannot be converted to unicode.", nls->charset);\r\nbefs_debug(sb, "<--- nls2utf()");\r\nkfree(result);\r\nreturn -EILSEQ;\r\n}\r\nstatic int\r\nparse_options(char *options, befs_mount_options * opts)\r\n{\r\nchar *p;\r\nsubstring_t args[MAX_OPT_ARGS];\r\nint option;\r\nkuid_t uid;\r\nkgid_t gid;\r\nopts->uid = GLOBAL_ROOT_UID;\r\nopts->gid = GLOBAL_ROOT_GID;\r\nopts->use_uid = 0;\r\nopts->use_gid = 0;\r\nopts->iocharset = NULL;\r\nopts->debug = 0;\r\nif (!options)\r\nreturn 1;\r\nwhile ((p = strsep(&options, ",")) != NULL) {\r\nint token;\r\nif (!*p)\r\ncontinue;\r\ntoken = match_token(p, befs_tokens, args);\r\nswitch (token) {\r\ncase Opt_uid:\r\nif (match_int(&args[0], &option))\r\nreturn 0;\r\nuid = INVALID_UID;\r\nif (option >= 0)\r\nuid = make_kuid(current_user_ns(), option);\r\nif (!uid_valid(uid)) {\r\nprintk(KERN_ERR "BeFS: Invalid uid %d, "\r\n"using default\n", option);\r\nbreak;\r\n}\r\nopts->uid = uid;\r\nopts->use_uid = 1;\r\nbreak;\r\ncase Opt_gid:\r\nif (match_int(&args[0], &option))\r\nreturn 0;\r\ngid = INVALID_GID;\r\nif (option >= 0)\r\ngid = make_kgid(current_user_ns(), option);\r\nif (!gid_valid(gid)) {\r\nprintk(KERN_ERR "BeFS: Invalid gid %d, "\r\n"using default\n", option);\r\nbreak;\r\n}\r\nopts->gid = gid;\r\nopts->use_gid = 1;\r\nbreak;\r\ncase Opt_charset:\r\nkfree(opts->iocharset);\r\nopts->iocharset = match_strdup(&args[0]);\r\nif (!opts->iocharset) {\r\nprintk(KERN_ERR "BeFS: allocation failure for "\r\n"iocharset string\n");\r\nreturn 0;\r\n}\r\nbreak;\r\ncase Opt_debug:\r\nopts->debug = 1;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "BeFS: Unrecognized mount option \"%s\" "\r\n"or missing value\n", p);\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void\r\nbefs_put_super(struct super_block *sb)\r\n{\r\nkfree(BEFS_SB(sb)->mount_opts.iocharset);\r\nBEFS_SB(sb)->mount_opts.iocharset = NULL;\r\nunload_nls(BEFS_SB(sb)->nls);\r\nkfree(sb->s_fs_info);\r\nsb->s_fs_info = NULL;\r\n}\r\nstatic int\r\nbefs_fill_super(struct super_block *sb, void *data, int silent)\r\n{\r\nstruct buffer_head *bh;\r\nbefs_sb_info *befs_sb;\r\nbefs_super_block *disk_sb;\r\nstruct inode *root;\r\nlong ret = -EINVAL;\r\nconst unsigned long sb_block = 0;\r\nconst off_t x86_sb_off = 512;\r\nsave_mount_options(sb, data);\r\nsb->s_fs_info = kmalloc(sizeof (*befs_sb), GFP_KERNEL);\r\nif (sb->s_fs_info == NULL) {\r\nprintk(KERN_ERR\r\n"BeFS(%s): Unable to allocate memory for private "\r\n"portion of superblock. Bailing.\n", sb->s_id);\r\ngoto unacquire_none;\r\n}\r\nbefs_sb = BEFS_SB(sb);\r\nmemset(befs_sb, 0, sizeof(befs_sb_info));\r\nif (!parse_options((char *) data, &befs_sb->mount_opts)) {\r\nbefs_error(sb, "cannot parse mount options");\r\ngoto unacquire_priv_sbp;\r\n}\r\nbefs_debug(sb, "---> befs_fill_super()");\r\n#ifndef CONFIG_BEFS_RW\r\nif (!(sb->s_flags & MS_RDONLY)) {\r\nbefs_warning(sb,\r\n"No write support. Marking filesystem read-only");\r\nsb->s_flags |= MS_RDONLY;\r\n}\r\n#endif\r\nsb_min_blocksize(sb, 1024);\r\nif (!(bh = sb_bread(sb, sb_block))) {\r\nbefs_error(sb, "unable to read superblock");\r\ngoto unacquire_priv_sbp;\r\n}\r\ndisk_sb = (befs_super_block *) bh->b_data;\r\nif ((disk_sb->magic1 == BEFS_SUPER_MAGIC1_LE) ||\r\n(disk_sb->magic1 == BEFS_SUPER_MAGIC1_BE)) {\r\nbefs_debug(sb, "Using PPC superblock location");\r\n} else {\r\nbefs_debug(sb, "Using x86 superblock location");\r\ndisk_sb =\r\n(befs_super_block *) ((void *) bh->b_data + x86_sb_off);\r\n}\r\nif (befs_load_sb(sb, disk_sb) != BEFS_OK)\r\ngoto unacquire_bh;\r\nbefs_dump_super_block(sb, disk_sb);\r\nbrelse(bh);\r\nif (befs_check_sb(sb) != BEFS_OK)\r\ngoto unacquire_priv_sbp;\r\nif( befs_sb->num_blocks > ~((sector_t)0) ) {\r\nbefs_error(sb, "blocks count: %Lu "\r\n"is larger than the host can use",\r\nbefs_sb->num_blocks);\r\ngoto unacquire_priv_sbp;\r\n}\r\nsb->s_magic = BEFS_SUPER_MAGIC;\r\nsb_set_blocksize(sb, (ulong) befs_sb->block_size);\r\nsb->s_op = &befs_sops;\r\nroot = befs_iget(sb, iaddr2blockno(sb, &(befs_sb->root_dir)));\r\nif (IS_ERR(root)) {\r\nret = PTR_ERR(root);\r\ngoto unacquire_priv_sbp;\r\n}\r\nsb->s_root = d_make_root(root);\r\nif (!sb->s_root) {\r\nbefs_error(sb, "get root inode failed");\r\ngoto unacquire_priv_sbp;\r\n}\r\nif (befs_sb->mount_opts.iocharset) {\r\nbefs_debug(sb, "Loading nls: %s",\r\nbefs_sb->mount_opts.iocharset);\r\nbefs_sb->nls = load_nls(befs_sb->mount_opts.iocharset);\r\nif (!befs_sb->nls) {\r\nbefs_warning(sb, "Cannot load nls %s"\r\n" loading default nls",\r\nbefs_sb->mount_opts.iocharset);\r\nbefs_sb->nls = load_nls_default();\r\n}\r\n} else {\r\nbefs_debug(sb, "Loading default nls");\r\nbefs_sb->nls = load_nls_default();\r\n}\r\nreturn 0;\r\nunacquire_bh:\r\nbrelse(bh);\r\nunacquire_priv_sbp:\r\nkfree(befs_sb->mount_opts.iocharset);\r\nkfree(sb->s_fs_info);\r\nunacquire_none:\r\nsb->s_fs_info = NULL;\r\nreturn ret;\r\n}\r\nstatic int\r\nbefs_remount(struct super_block *sb, int *flags, char *data)\r\n{\r\nif (!(*flags & MS_RDONLY))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nbefs_statfs(struct dentry *dentry, struct kstatfs *buf)\r\n{\r\nstruct super_block *sb = dentry->d_sb;\r\nu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\r\nbefs_debug(sb, "---> befs_statfs()");\r\nbuf->f_type = BEFS_SUPER_MAGIC;\r\nbuf->f_bsize = sb->s_blocksize;\r\nbuf->f_blocks = BEFS_SB(sb)->num_blocks;\r\nbuf->f_bfree = BEFS_SB(sb)->num_blocks - BEFS_SB(sb)->used_blocks;\r\nbuf->f_bavail = buf->f_bfree;\r\nbuf->f_files = 0;\r\nbuf->f_ffree = 0;\r\nbuf->f_fsid.val[0] = (u32)id;\r\nbuf->f_fsid.val[1] = (u32)(id >> 32);\r\nbuf->f_namelen = BEFS_NAME_LEN;\r\nbefs_debug(sb, "<--- befs_statfs()");\r\nreturn 0;\r\n}\r\nstatic struct dentry *\r\nbefs_mount(struct file_system_type *fs_type, int flags, const char *dev_name,\r\nvoid *data)\r\n{\r\nreturn mount_bdev(fs_type, flags, dev_name, data, befs_fill_super);\r\n}\r\nstatic int __init\r\ninit_befs_fs(void)\r\n{\r\nint err;\r\nprintk(KERN_INFO "BeFS version: %s\n", BEFS_VERSION);\r\nerr = befs_init_inodecache();\r\nif (err)\r\ngoto unacquire_none;\r\nerr = register_filesystem(&befs_fs_type);\r\nif (err)\r\ngoto unacquire_inodecache;\r\nreturn 0;\r\nunacquire_inodecache:\r\nbefs_destroy_inodecache();\r\nunacquire_none:\r\nreturn err;\r\n}\r\nstatic void __exit\r\nexit_befs_fs(void)\r\n{\r\nbefs_destroy_inodecache();\r\nunregister_filesystem(&befs_fs_type);\r\n}
