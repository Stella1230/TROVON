static u8 *pcan_msg_init(struct pcan_usb_pro_msg *pm, void *buffer_addr,\r\nint buffer_size)\r\n{\r\nif (buffer_size < PCAN_USBPRO_MSG_HEADER_LEN)\r\nreturn NULL;\r\npm->u.rec_buffer = (u8 *)buffer_addr;\r\npm->rec_buffer_size = pm->rec_buffer_len = buffer_size;\r\npm->rec_ptr = pm->u.rec_buffer + PCAN_USBPRO_MSG_HEADER_LEN;\r\nreturn pm->rec_ptr;\r\n}\r\nstatic u8 *pcan_msg_init_empty(struct pcan_usb_pro_msg *pm,\r\nvoid *buffer_addr, int buffer_size)\r\n{\r\nu8 *pr = pcan_msg_init(pm, buffer_addr, buffer_size);\r\nif (pr) {\r\npm->rec_buffer_len = PCAN_USBPRO_MSG_HEADER_LEN;\r\n*pm->u.rec_cnt = 0;\r\n}\r\nreturn pr;\r\n}\r\nstatic int pcan_msg_add_rec(struct pcan_usb_pro_msg *pm, u8 id, ...)\r\n{\r\nint len, i;\r\nu8 *pc;\r\nva_list ap;\r\nva_start(ap, id);\r\npc = pm->rec_ptr + 1;\r\ni = 0;\r\nswitch (id) {\r\ncase PCAN_USBPRO_TXMSG8:\r\ni += 4;\r\ncase PCAN_USBPRO_TXMSG4:\r\ni += 4;\r\ncase PCAN_USBPRO_TXMSG0:\r\n*pc++ = va_arg(ap, int);\r\n*pc++ = va_arg(ap, int);\r\n*pc++ = va_arg(ap, int);\r\n*(u32 *)pc = cpu_to_le32(va_arg(ap, u32));\r\npc += 4;\r\nmemcpy(pc, va_arg(ap, int *), i);\r\npc += i;\r\nbreak;\r\ncase PCAN_USBPRO_SETBTR:\r\ncase PCAN_USBPRO_GETDEVID:\r\n*pc++ = va_arg(ap, int);\r\npc += 2;\r\n*(u32 *)pc = cpu_to_le32(va_arg(ap, u32));\r\npc += 4;\r\nbreak;\r\ncase PCAN_USBPRO_SETFILTR:\r\ncase PCAN_USBPRO_SETBUSACT:\r\ncase PCAN_USBPRO_SETSILENT:\r\n*pc++ = va_arg(ap, int);\r\n*(u16 *)pc = cpu_to_le16(va_arg(ap, int));\r\npc += 2;\r\nbreak;\r\ncase PCAN_USBPRO_SETLED:\r\n*pc++ = va_arg(ap, int);\r\n*(u16 *)pc = cpu_to_le16(va_arg(ap, int));\r\npc += 2;\r\n*(u32 *)pc = cpu_to_le32(va_arg(ap, u32));\r\npc += 4;\r\nbreak;\r\ncase PCAN_USBPRO_SETTS:\r\npc++;\r\n*(u16 *)pc = cpu_to_le16(va_arg(ap, int));\r\npc += 2;\r\nbreak;\r\ndefault:\r\npr_err("%s: %s(): unknown data type %02Xh (%d)\n",\r\nPCAN_USB_DRIVER_NAME, __func__, id, id);\r\npc--;\r\nbreak;\r\n}\r\nlen = pc - pm->rec_ptr;\r\nif (len > 0) {\r\n*pm->u.rec_cnt = cpu_to_le32(*pm->u.rec_cnt+1);\r\n*pm->rec_ptr = id;\r\npm->rec_ptr = pc;\r\npm->rec_buffer_len += len;\r\n}\r\nva_end(ap);\r\nreturn len;\r\n}\r\nstatic int pcan_usb_pro_send_cmd(struct peak_usb_device *dev,\r\nstruct pcan_usb_pro_msg *pum)\r\n{\r\nint actual_length;\r\nint err;\r\nif (!(dev->state & PCAN_USB_STATE_CONNECTED))\r\nreturn 0;\r\nerr = usb_bulk_msg(dev->udev,\r\nusb_sndbulkpipe(dev->udev, PCAN_USBPRO_EP_CMDOUT),\r\npum->u.rec_buffer, pum->rec_buffer_len,\r\n&actual_length, PCAN_USBPRO_COMMAND_TIMEOUT);\r\nif (err)\r\nnetdev_err(dev->netdev, "sending command failure: %d\n", err);\r\nreturn err;\r\n}\r\nstatic int pcan_usb_pro_wait_rsp(struct peak_usb_device *dev,\r\nstruct pcan_usb_pro_msg *pum)\r\n{\r\nu8 req_data_type, req_channel;\r\nint actual_length;\r\nint i, err = 0;\r\nif (!(dev->state & PCAN_USB_STATE_CONNECTED))\r\nreturn 0;\r\nreq_data_type = pum->u.rec_buffer[4];\r\nreq_channel = pum->u.rec_buffer[5];\r\n*pum->u.rec_cnt = 0;\r\nfor (i = 0; !err && i < PCAN_USBPRO_RSP_SUBMIT_MAX; i++) {\r\nstruct pcan_usb_pro_msg rsp;\r\nunion pcan_usb_pro_rec *pr;\r\nu32 r, rec_cnt;\r\nu16 rec_len;\r\nu8 *pc;\r\nerr = usb_bulk_msg(dev->udev,\r\nusb_rcvbulkpipe(dev->udev, PCAN_USBPRO_EP_CMDIN),\r\npum->u.rec_buffer, pum->rec_buffer_len,\r\n&actual_length, PCAN_USBPRO_COMMAND_TIMEOUT);\r\nif (err) {\r\nnetdev_err(dev->netdev, "waiting rsp error %d\n", err);\r\nbreak;\r\n}\r\nif (actual_length == 0)\r\ncontinue;\r\nerr = -EBADMSG;\r\nif (actual_length < PCAN_USBPRO_MSG_HEADER_LEN) {\r\nnetdev_err(dev->netdev,\r\n"got abnormal too small rsp (len=%d)\n",\r\nactual_length);\r\nbreak;\r\n}\r\npc = pcan_msg_init(&rsp, pum->u.rec_buffer,\r\nactual_length);\r\nrec_cnt = le32_to_cpu(*rsp.u.rec_cnt);\r\nfor (r = 0; r < rec_cnt; r++) {\r\npr = (union pcan_usb_pro_rec *)pc;\r\nrec_len = pcan_usb_pro_sizeof_rec[pr->data_type];\r\nif (!rec_len) {\r\nnetdev_err(dev->netdev,\r\n"got unprocessed record in msg\n");\r\npcan_dump_mem("rcvd rsp msg", pum->u.rec_buffer,\r\nactual_length);\r\nbreak;\r\n}\r\nif (pr->data_type != req_data_type)\r\nnetdev_err(dev->netdev,\r\n"got unwanted rsp %xh: ignored\n",\r\npr->data_type);\r\nelse if ((req_channel != 0xff) && \\r\n(pr->bus_act.channel != req_channel))\r\nnetdev_err(dev->netdev,\r\n"got rsp %xh but on chan%u: ignored\n",\r\nreq_data_type, pr->bus_act.channel);\r\nelse\r\nreturn 0;\r\npc += rec_len;\r\n}\r\n}\r\nreturn (i >= PCAN_USBPRO_RSP_SUBMIT_MAX) ? -ERANGE : err;\r\n}\r\nstatic int pcan_usb_pro_send_req(struct peak_usb_device *dev, int req_id,\r\nint req_value, void *req_addr, int req_size)\r\n{\r\nint err;\r\nu8 req_type;\r\nunsigned int p;\r\nif (!(dev->state & PCAN_USB_STATE_CONNECTED))\r\nreturn 0;\r\nmemset(req_addr, '\0', req_size);\r\nreq_type = USB_TYPE_VENDOR | USB_RECIP_OTHER;\r\nswitch (req_id) {\r\ncase PCAN_USBPRO_REQ_FCT:\r\np = usb_sndctrlpipe(dev->udev, 0);\r\nbreak;\r\ndefault:\r\np = usb_rcvctrlpipe(dev->udev, 0);\r\nreq_type |= USB_DIR_IN;\r\nbreak;\r\n}\r\nerr = usb_control_msg(dev->udev, p, req_id, req_type, req_value, 0,\r\nreq_addr, req_size, 2 * USB_CTRL_GET_TIMEOUT);\r\nif (err < 0) {\r\nnetdev_info(dev->netdev,\r\n"unable to request usb[type=%d value=%d] err=%d\n",\r\nreq_id, req_value, err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcan_usb_pro_set_ts(struct peak_usb_device *dev, u16 onoff)\r\n{\r\nstruct pcan_usb_pro_msg um;\r\npcan_msg_init_empty(&um, dev->cmd_buf, PCAN_USB_MAX_CMD_LEN);\r\npcan_msg_add_rec(&um, PCAN_USBPRO_SETTS, onoff);\r\nreturn pcan_usb_pro_send_cmd(dev, &um);\r\n}\r\nstatic int pcan_usb_pro_set_bitrate(struct peak_usb_device *dev, u32 ccbt)\r\n{\r\nstruct pcan_usb_pro_device *pdev =\r\ncontainer_of(dev, struct pcan_usb_pro_device, dev);\r\nstruct pcan_usb_pro_msg um;\r\npcan_msg_init_empty(&um, dev->cmd_buf, PCAN_USB_MAX_CMD_LEN);\r\npcan_msg_add_rec(&um, PCAN_USBPRO_SETBTR, dev->ctrl_idx, ccbt);\r\npdev->cached_ccbt = ccbt;\r\nreturn pcan_usb_pro_send_cmd(dev, &um);\r\n}\r\nstatic int pcan_usb_pro_set_bus(struct peak_usb_device *dev, u8 onoff)\r\n{\r\nstruct pcan_usb_pro_msg um;\r\nif (onoff) {\r\nstruct pcan_usb_pro_device *pdev =\r\ncontainer_of(dev, struct pcan_usb_pro_device, dev);\r\npcan_usb_pro_set_bitrate(dev, pdev->cached_ccbt);\r\n}\r\npcan_msg_init_empty(&um, dev->cmd_buf, PCAN_USB_MAX_CMD_LEN);\r\npcan_msg_add_rec(&um, PCAN_USBPRO_SETBUSACT, dev->ctrl_idx, onoff);\r\nreturn pcan_usb_pro_send_cmd(dev, &um);\r\n}\r\nstatic int pcan_usb_pro_set_silent(struct peak_usb_device *dev, u8 onoff)\r\n{\r\nstruct pcan_usb_pro_msg um;\r\npcan_msg_init_empty(&um, dev->cmd_buf, PCAN_USB_MAX_CMD_LEN);\r\npcan_msg_add_rec(&um, PCAN_USBPRO_SETSILENT, dev->ctrl_idx, onoff);\r\nreturn pcan_usb_pro_send_cmd(dev, &um);\r\n}\r\nstatic int pcan_usb_pro_set_filter(struct peak_usb_device *dev, u16 filter_mode)\r\n{\r\nstruct pcan_usb_pro_msg um;\r\npcan_msg_init_empty(&um, dev->cmd_buf, PCAN_USB_MAX_CMD_LEN);\r\npcan_msg_add_rec(&um, PCAN_USBPRO_SETFILTR, dev->ctrl_idx, filter_mode);\r\nreturn pcan_usb_pro_send_cmd(dev, &um);\r\n}\r\nstatic int pcan_usb_pro_set_led(struct peak_usb_device *dev, u8 mode,\r\nu32 timeout)\r\n{\r\nstruct pcan_usb_pro_msg um;\r\npcan_msg_init_empty(&um, dev->cmd_buf, PCAN_USB_MAX_CMD_LEN);\r\npcan_msg_add_rec(&um, PCAN_USBPRO_SETLED, dev->ctrl_idx, mode, timeout);\r\nreturn pcan_usb_pro_send_cmd(dev, &um);\r\n}\r\nstatic int pcan_usb_pro_get_device_id(struct peak_usb_device *dev,\r\nu32 *device_id)\r\n{\r\nstruct pcan_usb_pro_devid *pdn;\r\nstruct pcan_usb_pro_msg um;\r\nint err;\r\nu8 *pc;\r\npc = pcan_msg_init_empty(&um, dev->cmd_buf, PCAN_USB_MAX_CMD_LEN);\r\npcan_msg_add_rec(&um, PCAN_USBPRO_GETDEVID, dev->ctrl_idx);\r\nerr = pcan_usb_pro_send_cmd(dev, &um);\r\nif (err)\r\nreturn err;\r\nerr = pcan_usb_pro_wait_rsp(dev, &um);\r\nif (err)\r\nreturn err;\r\npdn = (struct pcan_usb_pro_devid *)pc;\r\nif (device_id)\r\n*device_id = le32_to_cpu(pdn->serial_num);\r\nreturn err;\r\n}\r\nstatic int pcan_usb_pro_set_bittiming(struct peak_usb_device *dev,\r\nstruct can_bittiming *bt)\r\n{\r\nu32 ccbt;\r\nccbt = (dev->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES) ? 0x00800000 : 0;\r\nccbt |= (bt->sjw - 1) << 24;\r\nccbt |= (bt->phase_seg2 - 1) << 20;\r\nccbt |= (bt->prop_seg + bt->phase_seg1 - 1) << 16;\r\nccbt |= bt->brp - 1;\r\nnetdev_info(dev->netdev, "setting ccbt=0x%08x\n", ccbt);\r\nreturn pcan_usb_pro_set_bitrate(dev, ccbt);\r\n}\r\nstatic void pcan_usb_pro_restart_complete(struct urb *urb)\r\n{\r\npeak_usb_async_complete(urb);\r\npeak_usb_restart_complete(urb->context);\r\n}\r\nstatic int pcan_usb_pro_restart_async(struct peak_usb_device *dev,\r\nstruct urb *urb, u8 *buf)\r\n{\r\nstruct pcan_usb_pro_msg um;\r\npcan_msg_init_empty(&um, buf, PCAN_USB_MAX_CMD_LEN);\r\npcan_msg_add_rec(&um, PCAN_USBPRO_SETBUSACT, dev->ctrl_idx, 1);\r\nusb_fill_bulk_urb(urb, dev->udev,\r\nusb_sndbulkpipe(dev->udev, PCAN_USBPRO_EP_CMDOUT),\r\nbuf, PCAN_USB_MAX_CMD_LEN,\r\npcan_usb_pro_restart_complete, dev);\r\nreturn usb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nstatic int pcan_usb_pro_drv_loaded(struct peak_usb_device *dev, int loaded)\r\n{\r\nu8 *buffer;\r\nint err;\r\nbuffer = kmalloc(PCAN_USBPRO_FCT_DRVLD_REQ_LEN, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nbuffer[0] = 0;\r\nbuffer[1] = !!loaded;\r\nerr = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_FCT,\r\nPCAN_USBPRO_FCT_DRVLD, buffer,\r\nPCAN_USBPRO_FCT_DRVLD_REQ_LEN);\r\nkfree(buffer);\r\nreturn err;\r\n}\r\nstatic inline\r\nstruct pcan_usb_pro_interface *pcan_usb_pro_dev_if(struct peak_usb_device *dev)\r\n{\r\nstruct pcan_usb_pro_device *pdev =\r\ncontainer_of(dev, struct pcan_usb_pro_device, dev);\r\nreturn pdev->usb_if;\r\n}\r\nstatic int pcan_usb_pro_handle_canmsg(struct pcan_usb_pro_interface *usb_if,\r\nstruct pcan_usb_pro_rxmsg *rx)\r\n{\r\nconst unsigned int ctrl_idx = (rx->len >> 4) & 0x0f;\r\nstruct peak_usb_device *dev = usb_if->dev[ctrl_idx];\r\nstruct net_device *netdev = dev->netdev;\r\nstruct can_frame *can_frame;\r\nstruct sk_buff *skb;\r\nstruct timeval tv;\r\nstruct skb_shared_hwtstamps *hwts;\r\nskb = alloc_can_skb(netdev, &can_frame);\r\nif (!skb)\r\nreturn -ENOMEM;\r\ncan_frame->can_id = le32_to_cpu(rx->id);\r\ncan_frame->can_dlc = rx->len & 0x0f;\r\nif (rx->flags & PCAN_USBPRO_EXT)\r\ncan_frame->can_id |= CAN_EFF_FLAG;\r\nif (rx->flags & PCAN_USBPRO_RTR)\r\ncan_frame->can_id |= CAN_RTR_FLAG;\r\nelse\r\nmemcpy(can_frame->data, rx->data, can_frame->can_dlc);\r\npeak_usb_get_ts_tv(&usb_if->time_ref, le32_to_cpu(rx->ts32), &tv);\r\nhwts = skb_hwtstamps(skb);\r\nhwts->hwtstamp = timeval_to_ktime(tv);\r\nnetif_rx(skb);\r\nnetdev->stats.rx_packets++;\r\nnetdev->stats.rx_bytes += can_frame->can_dlc;\r\nreturn 0;\r\n}\r\nstatic int pcan_usb_pro_handle_error(struct pcan_usb_pro_interface *usb_if,\r\nstruct pcan_usb_pro_rxstatus *er)\r\n{\r\nconst u32 raw_status = le32_to_cpu(er->status);\r\nconst unsigned int ctrl_idx = (er->channel >> 4) & 0x0f;\r\nstruct peak_usb_device *dev = usb_if->dev[ctrl_idx];\r\nstruct net_device *netdev = dev->netdev;\r\nstruct can_frame *can_frame;\r\nenum can_state new_state = CAN_STATE_ERROR_ACTIVE;\r\nu8 err_mask = 0;\r\nstruct sk_buff *skb;\r\nstruct timeval tv;\r\nstruct skb_shared_hwtstamps *hwts;\r\nif (dev->can.state == CAN_STATE_BUS_OFF)\r\nreturn 0;\r\nif (!raw_status) {\r\ndev->can.state = CAN_STATE_ERROR_ACTIVE;\r\nreturn 0;\r\n}\r\nif (raw_status & (PCAN_USBPRO_STATUS_OVERRUN |\r\nPCAN_USBPRO_STATUS_QOVERRUN)) {\r\nnew_state = CAN_STATE_MAX;\r\n}\r\nif (raw_status & PCAN_USBPRO_STATUS_BUS) {\r\nnew_state = CAN_STATE_BUS_OFF;\r\n} else if (raw_status & PCAN_USBPRO_STATUS_ERROR) {\r\nu32 rx_err_cnt = (le32_to_cpu(er->err_frm) & 0x00ff0000) >> 16;\r\nu32 tx_err_cnt = (le32_to_cpu(er->err_frm) & 0xff000000) >> 24;\r\nif (rx_err_cnt > 127)\r\nerr_mask |= CAN_ERR_CRTL_RX_PASSIVE;\r\nelse if (rx_err_cnt > 96)\r\nerr_mask |= CAN_ERR_CRTL_RX_WARNING;\r\nif (tx_err_cnt > 127)\r\nerr_mask |= CAN_ERR_CRTL_TX_PASSIVE;\r\nelse if (tx_err_cnt > 96)\r\nerr_mask |= CAN_ERR_CRTL_TX_WARNING;\r\nif (err_mask & (CAN_ERR_CRTL_RX_WARNING |\r\nCAN_ERR_CRTL_TX_WARNING))\r\nnew_state = CAN_STATE_ERROR_WARNING;\r\nelse if (err_mask & (CAN_ERR_CRTL_RX_PASSIVE |\r\nCAN_ERR_CRTL_TX_PASSIVE))\r\nnew_state = CAN_STATE_ERROR_PASSIVE;\r\n}\r\nif (dev->can.state == new_state)\r\nreturn 0;\r\nskb = alloc_can_err_skb(netdev, &can_frame);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nswitch (new_state) {\r\ncase CAN_STATE_BUS_OFF:\r\ncan_frame->can_id |= CAN_ERR_BUSOFF;\r\ncan_bus_off(netdev);\r\nbreak;\r\ncase CAN_STATE_ERROR_PASSIVE:\r\ncan_frame->can_id |= CAN_ERR_CRTL;\r\ncan_frame->data[1] |= err_mask;\r\ndev->can.can_stats.error_passive++;\r\nbreak;\r\ncase CAN_STATE_ERROR_WARNING:\r\ncan_frame->can_id |= CAN_ERR_CRTL;\r\ncan_frame->data[1] |= err_mask;\r\ndev->can.can_stats.error_warning++;\r\nbreak;\r\ncase CAN_STATE_ERROR_ACTIVE:\r\nbreak;\r\ndefault:\r\nif (raw_status & PCAN_USBPRO_STATUS_OVERRUN) {\r\ncan_frame->can_id |= CAN_ERR_PROT;\r\ncan_frame->data[2] |= CAN_ERR_PROT_OVERLOAD;\r\nnetdev->stats.rx_over_errors++;\r\nnetdev->stats.rx_errors++;\r\n}\r\nif (raw_status & PCAN_USBPRO_STATUS_QOVERRUN) {\r\ncan_frame->can_id |= CAN_ERR_CRTL;\r\ncan_frame->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;\r\nnetdev->stats.rx_over_errors++;\r\nnetdev->stats.rx_errors++;\r\n}\r\nnew_state = CAN_STATE_ERROR_ACTIVE;\r\nbreak;\r\n}\r\ndev->can.state = new_state;\r\npeak_usb_get_ts_tv(&usb_if->time_ref, le32_to_cpu(er->ts32), &tv);\r\nhwts = skb_hwtstamps(skb);\r\nhwts->hwtstamp = timeval_to_ktime(tv);\r\nnetif_rx(skb);\r\nnetdev->stats.rx_packets++;\r\nnetdev->stats.rx_bytes += can_frame->can_dlc;\r\nreturn 0;\r\n}\r\nstatic void pcan_usb_pro_handle_ts(struct pcan_usb_pro_interface *usb_if,\r\nstruct pcan_usb_pro_rxts *ts)\r\n{\r\nif (usb_if->cm_ignore_count > 0)\r\nusb_if->cm_ignore_count--;\r\nelse\r\npeak_usb_set_ts_now(&usb_if->time_ref,\r\nle32_to_cpu(ts->ts64[1]));\r\n}\r\nstatic int pcan_usb_pro_decode_buf(struct peak_usb_device *dev, struct urb *urb)\r\n{\r\nstruct pcan_usb_pro_interface *usb_if = pcan_usb_pro_dev_if(dev);\r\nstruct net_device *netdev = dev->netdev;\r\nstruct pcan_usb_pro_msg usb_msg;\r\nu8 *rec_ptr, *msg_end;\r\nu16 rec_cnt;\r\nint err = 0;\r\nrec_ptr = pcan_msg_init(&usb_msg, urb->transfer_buffer,\r\nurb->actual_length);\r\nif (!rec_ptr) {\r\nnetdev_err(netdev, "bad msg hdr len %d\n", urb->actual_length);\r\nreturn -EINVAL;\r\n}\r\nmsg_end = urb->transfer_buffer + urb->actual_length;\r\nrec_cnt = le16_to_cpu(*usb_msg.u.rec_cnt_rd);\r\nfor (; rec_cnt > 0; rec_cnt--) {\r\nunion pcan_usb_pro_rec *pr = (union pcan_usb_pro_rec *)rec_ptr;\r\nu16 sizeof_rec = pcan_usb_pro_sizeof_rec[pr->data_type];\r\nif (!sizeof_rec) {\r\nnetdev_err(netdev,\r\n"got unsupported rec in usb msg:\n");\r\nerr = -ENOTSUPP;\r\nbreak;\r\n}\r\nif (rec_ptr + sizeof_rec > msg_end) {\r\nnetdev_err(netdev,\r\n"got frag rec: should inc usb rx buf size\n");\r\nerr = -EBADMSG;\r\nbreak;\r\n}\r\nswitch (pr->data_type) {\r\ncase PCAN_USBPRO_RXMSG8:\r\ncase PCAN_USBPRO_RXMSG4:\r\ncase PCAN_USBPRO_RXMSG0:\r\ncase PCAN_USBPRO_RXRTR:\r\nerr = pcan_usb_pro_handle_canmsg(usb_if, &pr->rx_msg);\r\nif (err < 0)\r\ngoto fail;\r\nbreak;\r\ncase PCAN_USBPRO_RXSTATUS:\r\nerr = pcan_usb_pro_handle_error(usb_if, &pr->rx_status);\r\nif (err < 0)\r\ngoto fail;\r\nbreak;\r\ncase PCAN_USBPRO_RXTS:\r\npcan_usb_pro_handle_ts(usb_if, &pr->rx_ts);\r\nbreak;\r\ndefault:\r\nnetdev_err(netdev,\r\n"unhandled rec type 0x%02x (%d): ignored\n",\r\npr->data_type, pr->data_type);\r\nbreak;\r\n}\r\nrec_ptr += sizeof_rec;\r\n}\r\nfail:\r\nif (err)\r\npcan_dump_mem("received msg",\r\nurb->transfer_buffer, urb->actual_length);\r\nreturn err;\r\n}\r\nstatic int pcan_usb_pro_encode_msg(struct peak_usb_device *dev,\r\nstruct sk_buff *skb, u8 *obuf, size_t *size)\r\n{\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nu8 data_type, len, flags;\r\nstruct pcan_usb_pro_msg usb_msg;\r\npcan_msg_init_empty(&usb_msg, obuf, *size);\r\nif ((cf->can_id & CAN_RTR_FLAG) || (cf->can_dlc == 0))\r\ndata_type = PCAN_USBPRO_TXMSG0;\r\nelse if (cf->can_dlc <= 4)\r\ndata_type = PCAN_USBPRO_TXMSG4;\r\nelse\r\ndata_type = PCAN_USBPRO_TXMSG8;\r\nlen = (dev->ctrl_idx << 4) | (cf->can_dlc & 0x0f);\r\nflags = 0;\r\nif (cf->can_id & CAN_EFF_FLAG)\r\nflags |= 0x02;\r\nif (cf->can_id & CAN_RTR_FLAG)\r\nflags |= 0x01;\r\npcan_msg_add_rec(&usb_msg, data_type, 0, flags, len, cf->can_id,\r\ncf->data);\r\n*size = usb_msg.rec_buffer_len;\r\nreturn 0;\r\n}\r\nstatic int pcan_usb_pro_start(struct peak_usb_device *dev)\r\n{\r\nstruct pcan_usb_pro_device *pdev =\r\ncontainer_of(dev, struct pcan_usb_pro_device, dev);\r\nint err;\r\nerr = pcan_usb_pro_set_silent(dev,\r\ndev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY);\r\nif (err)\r\nreturn err;\r\nerr = pcan_usb_pro_set_filter(dev, 1);\r\nif (err)\r\nreturn err;\r\nif (pdev->usb_if->dev_opened_count == 0) {\r\npeak_usb_init_time_ref(&pdev->usb_if->time_ref, &pcan_usb_pro);\r\nerr = pcan_usb_pro_set_ts(dev, 1);\r\n}\r\npdev->usb_if->dev_opened_count++;\r\nreturn err;\r\n}\r\nstatic int pcan_usb_pro_stop(struct peak_usb_device *dev)\r\n{\r\nstruct pcan_usb_pro_device *pdev =\r\ncontainer_of(dev, struct pcan_usb_pro_device, dev);\r\nif (pdev->usb_if->dev_opened_count == 1)\r\npcan_usb_pro_set_ts(dev, 0);\r\npdev->usb_if->dev_opened_count--;\r\nreturn 0;\r\n}\r\nstatic int pcan_usb_pro_init(struct peak_usb_device *dev)\r\n{\r\nstruct pcan_usb_pro_device *pdev =\r\ncontainer_of(dev, struct pcan_usb_pro_device, dev);\r\nstruct pcan_usb_pro_interface *usb_if = NULL;\r\nstruct pcan_usb_pro_fwinfo *fi = NULL;\r\nstruct pcan_usb_pro_blinfo *bi = NULL;\r\nint err;\r\nif (!dev->prev_siblings) {\r\nusb_if = kzalloc(sizeof(struct pcan_usb_pro_interface),\r\nGFP_KERNEL);\r\nfi = kmalloc(sizeof(struct pcan_usb_pro_fwinfo), GFP_KERNEL);\r\nbi = kmalloc(sizeof(struct pcan_usb_pro_blinfo), GFP_KERNEL);\r\nif (!usb_if || !fi || !bi) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nusb_if->cm_ignore_count = 5;\r\nerr = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_INFO,\r\nPCAN_USBPRO_INFO_FW,\r\nfi, sizeof(*fi));\r\nif (err) {\r\ndev_err(dev->netdev->dev.parent,\r\n"unable to read %s firmware info (err %d)\n",\r\npcan_usb_pro.name, err);\r\ngoto err_out;\r\n}\r\nerr = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_INFO,\r\nPCAN_USBPRO_INFO_BL,\r\nbi, sizeof(*bi));\r\nif (err) {\r\ndev_err(dev->netdev->dev.parent,\r\n"unable to read %s bootloader info (err %d)\n",\r\npcan_usb_pro.name, err);\r\ngoto err_out;\r\n}\r\nerr = pcan_usb_pro_drv_loaded(dev, 1);\r\nif (err)\r\ngoto err_out;\r\ndev_info(dev->netdev->dev.parent,\r\n"PEAK-System %s hwrev %u serial %08X.%08X (%u channels)\n",\r\npcan_usb_pro.name,\r\nbi->hw_rev, bi->serial_num_hi, bi->serial_num_lo,\r\npcan_usb_pro.ctrl_count);\r\n} else {\r\nusb_if = pcan_usb_pro_dev_if(dev->prev_siblings);\r\n}\r\npdev->usb_if = usb_if;\r\nusb_if->dev[dev->ctrl_idx] = dev;\r\npcan_usb_pro_set_led(dev, 0, 1);\r\nreturn 0;\r\nerr_out:\r\nkfree(bi);\r\nkfree(fi);\r\nkfree(usb_if);\r\nreturn err;\r\n}\r\nstatic void pcan_usb_pro_exit(struct peak_usb_device *dev)\r\n{\r\nstruct pcan_usb_pro_device *pdev =\r\ncontainer_of(dev, struct pcan_usb_pro_device, dev);\r\nif (dev->can.state != CAN_STATE_STOPPED) {\r\npcan_usb_pro_set_bus(dev, 0);\r\n}\r\nif (dev->ctrl_idx == 0) {\r\nif (pdev->usb_if->dev_opened_count > 0)\r\npcan_usb_pro_set_ts(dev, 0);\r\npcan_usb_pro_drv_loaded(dev, 0);\r\n}\r\n}\r\nstatic void pcan_usb_pro_free(struct peak_usb_device *dev)\r\n{\r\nif (!dev->prev_siblings && !dev->next_siblings)\r\nkfree(pcan_usb_pro_dev_if(dev));\r\n}\r\nstatic int pcan_usb_pro_probe(struct usb_interface *intf)\r\n{\r\nstruct usb_host_interface *if_desc;\r\nint i;\r\nif_desc = intf->altsetting;\r\nfor (i = 0; i < if_desc->desc.bNumEndpoints; i++) {\r\nstruct usb_endpoint_descriptor *ep = &if_desc->endpoint[i].desc;\r\nswitch (ep->bEndpointAddress) {\r\ncase PCAN_USBPRO_EP_CMDOUT:\r\ncase PCAN_USBPRO_EP_CMDIN:\r\ncase PCAN_USBPRO_EP_MSGOUT_0:\r\ncase PCAN_USBPRO_EP_MSGOUT_1:\r\ncase PCAN_USBPRO_EP_MSGIN:\r\ncase PCAN_USBPRO_EP_UNUSED:\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn 0;\r\n}
