static void irda_usb_build_header(struct irda_usb_cb *self,\r\n__u8 *header,\r\nint force)\r\n{\r\nif (self->capability & IUC_STIR421X &&\r\n((self->new_speed != -1) || (self->new_xbofs != -1))) {\r\nif (self->new_speed == -1)\r\nself->new_speed = self->speed ;\r\nif (self->new_xbofs == -1)\r\nself->new_xbofs = self->xbofs ;\r\n}\r\nif (self->new_speed != -1) {\r\nif ((self->capability & IUC_SPEED_BUG) &&\r\n(!force) && (self->speed != -1)) {\r\nIRDA_DEBUG(2, "%s(), not changing speed yet\n", __func__);\r\n*header = 0;\r\nreturn;\r\n}\r\nIRDA_DEBUG(2, "%s(), changing speed to %d\n", __func__, self->new_speed);\r\nself->speed = self->new_speed;\r\nswitch (self->speed) {\r\ncase 2400:\r\n*header = SPEED_2400;\r\nbreak;\r\ndefault:\r\ncase 9600:\r\n*header = SPEED_9600;\r\nbreak;\r\ncase 19200:\r\n*header = SPEED_19200;\r\nbreak;\r\ncase 38400:\r\n*header = SPEED_38400;\r\nbreak;\r\ncase 57600:\r\n*header = SPEED_57600;\r\nbreak;\r\ncase 115200:\r\n*header = SPEED_115200;\r\nbreak;\r\ncase 576000:\r\n*header = SPEED_576000;\r\nbreak;\r\ncase 1152000:\r\n*header = SPEED_1152000;\r\nbreak;\r\ncase 4000000:\r\n*header = SPEED_4000000;\r\nself->new_xbofs = 0;\r\nbreak;\r\ncase 16000000:\r\n*header = SPEED_16000000;\r\nself->new_xbofs = 0;\r\nbreak;\r\n}\r\n} else\r\n*header = 0;\r\nif (self->new_xbofs != -1) {\r\nIRDA_DEBUG(2, "%s(), changing xbofs to %d\n", __func__, self->new_xbofs);\r\nself->xbofs = self->new_xbofs;\r\nswitch (self->xbofs) {\r\ncase 48:\r\n*header |= 0x10;\r\nbreak;\r\ncase 28:\r\ncase 24:\r\n*header |= 0x20;\r\nbreak;\r\ndefault:\r\ncase 12:\r\n*header |= 0x30;\r\nbreak;\r\ncase 5:\r\ncase 6:\r\n*header |= 0x40;\r\nbreak;\r\ncase 3:\r\n*header |= 0x50;\r\nbreak;\r\ncase 2:\r\n*header |= 0x60;\r\nbreak;\r\ncase 1:\r\n*header |= 0x70;\r\nbreak;\r\ncase 0:\r\n*header |= 0x80;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic __u8 get_turnaround_time(struct sk_buff *skb)\r\n{\r\nint turnaround_time = irda_get_mtt(skb);\r\nif ( turnaround_time == 0 )\r\nreturn 0;\r\nelse if ( turnaround_time <= 10 )\r\nreturn 1;\r\nelse if ( turnaround_time <= 50 )\r\nreturn 2;\r\nelse if ( turnaround_time <= 100 )\r\nreturn 3;\r\nelse if ( turnaround_time <= 500 )\r\nreturn 4;\r\nelse if ( turnaround_time <= 1000 )\r\nreturn 5;\r\nelse if ( turnaround_time <= 5000 )\r\nreturn 6;\r\nelse\r\nreturn 7;\r\n}\r\nstatic void irda_usb_change_speed_xbofs(struct irda_usb_cb *self)\r\n{\r\n__u8 *frame;\r\nstruct urb *urb;\r\nint ret;\r\nIRDA_DEBUG(2, "%s(), speed=%d, xbofs=%d\n", __func__,\r\nself->new_speed, self->new_xbofs);\r\nurb = self->speed_urb;\r\nif (urb->status != 0) {\r\nIRDA_WARNING("%s(), URB still in use!\n", __func__);\r\nreturn;\r\n}\r\nframe = self->speed_buff;\r\nirda_usb_build_header(self, frame, 1);\r\nif (self->capability & IUC_STIR421X) {\r\nif (frame[0] == 0) return ;\r\nframe[1] = 0;\r\nframe[2] = 0;\r\n}\r\nusb_fill_bulk_urb(urb, self->usbdev,\r\nusb_sndbulkpipe(self->usbdev, self->bulk_out_ep),\r\nframe, IRDA_USB_SPEED_MTU,\r\nspeed_bulk_callback, self);\r\nurb->transfer_buffer_length = self->header_length;\r\nurb->transfer_flags = 0;\r\nif ((ret = usb_submit_urb(urb, GFP_ATOMIC))) {\r\nIRDA_WARNING("%s(), failed Speed URB\n", __func__);\r\n}\r\n}\r\nstatic void speed_bulk_callback(struct urb *urb)\r\n{\r\nstruct irda_usb_cb *self = urb->context;\r\nIRDA_DEBUG(2, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(urb == self->speed_urb, return;);\r\nif (urb->status != 0) {\r\nIRDA_DEBUG(0, "%s(), URB complete status %d, transfer_flags 0x%04X\n", __func__, urb->status, urb->transfer_flags);\r\nreturn;\r\n}\r\nself->new_speed = -1;\r\nself->new_xbofs = -1;\r\nnetif_wake_queue(self->netdev);\r\n}\r\nstatic netdev_tx_t irda_usb_hard_xmit(struct sk_buff *skb,\r\nstruct net_device *netdev)\r\n{\r\nstruct irda_usb_cb *self = netdev_priv(netdev);\r\nstruct urb *urb = self->tx_urb;\r\nunsigned long flags;\r\ns32 speed;\r\ns16 xbofs;\r\nint res, mtt;\r\nIRDA_DEBUG(4, "%s() on %s\n", __func__, netdev->name);\r\nnetif_stop_queue(netdev);\r\nspin_lock_irqsave(&self->lock, flags);\r\nif (!self->present) {\r\nIRDA_DEBUG(0, "%s(), Device is gone...\n", __func__);\r\ngoto drop;\r\n}\r\nxbofs = irda_get_next_xbofs(skb);\r\nif ((xbofs != self->xbofs) && (xbofs != -1)) {\r\nself->new_xbofs = xbofs;\r\n}\r\nspeed = irda_get_next_speed(skb);\r\nif ((speed != self->speed) && (speed != -1)) {\r\nself->new_speed = speed;\r\nif (!skb->len) {\r\nirda_usb_change_speed_xbofs(self);\r\nnetdev->trans_start = jiffies;\r\ngoto drop;\r\n}\r\n}\r\nif (urb->status != 0) {\r\nIRDA_WARNING("%s(), URB still in use!\n", __func__);\r\ngoto drop;\r\n}\r\nskb_copy_from_linear_data(skb, self->tx_buff + self->header_length, skb->len);\r\nif (self->capability & IUC_STIR421X) {\r\n__u8 turnaround_time;\r\n__u8* frame = self->tx_buff;\r\nturnaround_time = get_turnaround_time( skb );\r\nirda_usb_build_header(self, frame, 0);\r\nframe[2] = turnaround_time;\r\nif ((skb->len != 0) &&\r\n((skb->len % 128) == 0) &&\r\n((skb->len % 512) != 0)) {\r\nframe[1] = 1;\r\nskb_put(skb, 1);\r\n} else {\r\nframe[1] = 0;\r\n}\r\n} else {\r\nirda_usb_build_header(self, self->tx_buff, 0);\r\n}\r\n((struct irda_skb_cb *)skb->cb)->context = self;\r\nusb_fill_bulk_urb(urb, self->usbdev,\r\nusb_sndbulkpipe(self->usbdev, self->bulk_out_ep),\r\nself->tx_buff, skb->len + self->header_length,\r\nwrite_bulk_callback, skb);\r\nurb->transfer_flags = URB_ZERO_PACKET;\r\nif (self->capability & IUC_NO_TURN) {\r\nmtt = irda_get_mtt(skb);\r\nif (mtt) {\r\nint diff;\r\ndo_gettimeofday(&self->now);\r\ndiff = self->now.tv_usec - self->stamp.tv_usec;\r\n#ifdef IU_USB_MIN_RTT\r\ndiff += IU_USB_MIN_RTT;\r\n#endif\r\nif (diff < 0)\r\ndiff += 1000000;\r\nif (mtt > diff) {\r\nmtt -= diff;\r\nif (mtt > 1000)\r\nmdelay(mtt/1000);\r\nelse\r\nudelay(mtt);\r\n}\r\n}\r\n}\r\nif ((res = usb_submit_urb(urb, GFP_ATOMIC))) {\r\nIRDA_WARNING("%s(), failed Tx URB\n", __func__);\r\nnetdev->stats.tx_errors++;\r\n} else {\r\nnetdev->stats.tx_packets++;\r\nnetdev->stats.tx_bytes += skb->len;\r\nnetdev->trans_start = jiffies;\r\n}\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nreturn NETDEV_TX_OK;\r\ndrop:\r\ndev_kfree_skb(skb);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void write_bulk_callback(struct urb *urb)\r\n{\r\nunsigned long flags;\r\nstruct sk_buff *skb = urb->context;\r\nstruct irda_usb_cb *self = ((struct irda_skb_cb *) skb->cb)->context;\r\nIRDA_DEBUG(2, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(urb == self->tx_urb, return;);\r\ndev_kfree_skb_any(skb);\r\nurb->context = NULL;\r\nif (urb->status != 0) {\r\nIRDA_DEBUG(0, "%s(), URB complete status %d, transfer_flags 0x%04X\n", __func__, urb->status, urb->transfer_flags);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&self->lock, flags);\r\nif ((!self->netopen) || (!self->present)) {\r\nIRDA_DEBUG(0, "%s(), Network is gone...\n", __func__);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nreturn;\r\n}\r\nif ((self->new_speed != -1) || (self->new_xbofs != -1)) {\r\nif ((self->new_speed != self->speed) ||\r\n(self->new_xbofs != self->xbofs)) {\r\nIRDA_DEBUG(1, "%s(), Changing speed now...\n", __func__);\r\nirda_usb_change_speed_xbofs(self);\r\n} else {\r\nself->new_speed = -1;\r\nself->new_xbofs = -1;\r\nnetif_wake_queue(self->netdev);\r\n}\r\n} else {\r\nnetif_wake_queue(self->netdev);\r\n}\r\nspin_unlock_irqrestore(&self->lock, flags);\r\n}\r\nstatic void irda_usb_net_timeout(struct net_device *netdev)\r\n{\r\nunsigned long flags;\r\nstruct irda_usb_cb *self = netdev_priv(netdev);\r\nstruct urb *urb;\r\nint done = 0;\r\nIRDA_DEBUG(0, "%s(), Network layer thinks we timed out!\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nspin_lock_irqsave(&self->lock, flags);\r\nif (!self->present) {\r\nIRDA_WARNING("%s(), device not present!\n", __func__);\r\nnetif_stop_queue(netdev);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nreturn;\r\n}\r\nurb = self->speed_urb;\r\nif (urb->status != 0) {\r\nIRDA_DEBUG(0, "%s: Speed change timed out, urb->status=%d, urb->transfer_flags=0x%04X\n", netdev->name, urb->status, urb->transfer_flags);\r\nswitch (urb->status) {\r\ncase -EINPROGRESS:\r\nusb_unlink_urb(urb);\r\ndone = 1;\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ndefault:\r\nurb->status = 0;\r\nnetif_wake_queue(self->netdev);\r\ndone = 1;\r\nbreak;\r\n}\r\n}\r\nurb = self->tx_urb;\r\nif (urb->status != 0) {\r\nstruct sk_buff *skb = urb->context;\r\nIRDA_DEBUG(0, "%s: Tx timed out, urb->status=%d, urb->transfer_flags=0x%04X\n", netdev->name, urb->status, urb->transfer_flags);\r\nnetdev->stats.tx_errors++;\r\n#ifdef IU_BUG_KICK_TIMEOUT\r\nif(self->new_speed == -1)\r\nself->new_speed = self->speed;\r\nif(self->new_xbofs == -1)\r\nself->new_xbofs = self->xbofs;\r\nirda_usb_change_speed_xbofs(self);\r\n#endif\r\nswitch (urb->status) {\r\ncase -EINPROGRESS:\r\nusb_unlink_urb(urb);\r\ndone = 1;\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ndefault:\r\nif(skb != NULL) {\r\ndev_kfree_skb_any(skb);\r\nurb->context = NULL;\r\n}\r\nurb->status = 0;\r\nnetif_wake_queue(self->netdev);\r\ndone = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&self->lock, flags);\r\n}\r\nstatic void irda_usb_submit(struct irda_usb_cb *self, struct sk_buff *skb, struct urb *urb)\r\n{\r\nstruct irda_skb_cb *cb;\r\nint ret;\r\nIRDA_DEBUG(2, "%s()\n", __func__);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nIRDA_ASSERT(urb != NULL, return;);\r\ncb = (struct irda_skb_cb *) skb->cb;\r\ncb->context = self;\r\nusb_fill_bulk_urb(urb, self->usbdev,\r\nusb_rcvbulkpipe(self->usbdev, self->bulk_in_ep),\r\nskb->data, IRDA_SKB_MAX_MTU,\r\nirda_usb_receive, skb);\r\nurb->status = 0;\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret) {\r\nIRDA_WARNING("%s(), Failed to submit Rx URB %d\n",\r\n__func__, ret);\r\n}\r\n}\r\nstatic void irda_usb_receive(struct urb *urb)\r\n{\r\nstruct sk_buff *skb = (struct sk_buff *) urb->context;\r\nstruct irda_usb_cb *self;\r\nstruct irda_skb_cb *cb;\r\nstruct sk_buff *newskb;\r\nstruct sk_buff *dataskb;\r\nstruct urb *next_urb;\r\nunsigned int len, docopy;\r\nIRDA_DEBUG(2, "%s(), len=%d\n", __func__, urb->actual_length);\r\ncb = (struct irda_skb_cb *) skb->cb;\r\nIRDA_ASSERT(cb != NULL, return;);\r\nself = (struct irda_usb_cb *) cb->context;\r\nIRDA_ASSERT(self != NULL, return;);\r\nif ((!self->netopen) || (!self->present)) {\r\nIRDA_DEBUG(0, "%s(), Network is gone!\n", __func__);\r\nreturn;\r\n}\r\nif (urb->status != 0) {\r\nswitch (urb->status) {\r\ncase -EILSEQ:\r\nself->netdev->stats.rx_crc_errors++;\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\ncase -ETIME:\r\ndefault:\r\nself->netdev->stats.rx_errors++;\r\nIRDA_DEBUG(0, "%s(), RX status %d, transfer_flags 0x%04X\n", __func__, urb->status, urb->transfer_flags);\r\nbreak;\r\n}\r\nself->rx_defer_timer.function = irda_usb_rx_defer_expired;\r\nself->rx_defer_timer.data = (unsigned long) urb;\r\nmod_timer(&self->rx_defer_timer, jiffies + (10 * HZ / 1000));\r\nreturn;\r\n}\r\nif (urb->actual_length <= self->header_length) {\r\nIRDA_WARNING("%s(), empty frame!\n", __func__);\r\ngoto done;\r\n}\r\ndo_gettimeofday(&self->stamp);\r\ndocopy = (urb->actual_length < IRDA_RX_COPY_THRESHOLD);\r\nif (self->capability & IUC_STIR421X)\r\nnewskb = dev_alloc_skb(docopy ? urb->actual_length :\r\nIRDA_SKB_MAX_MTU +\r\nUSB_IRDA_STIR421X_HEADER);\r\nelse\r\nnewskb = dev_alloc_skb(docopy ? urb->actual_length :\r\nIRDA_SKB_MAX_MTU);\r\nif (!newskb) {\r\nself->netdev->stats.rx_dropped++;\r\ngoto done;\r\n}\r\nif(docopy) {\r\nskb_copy_from_linear_data(skb, newskb->data, urb->actual_length);\r\ndataskb = newskb;\r\n} else {\r\ndataskb = skb;\r\nskb = newskb;\r\n}\r\nskb_put(dataskb, urb->actual_length);\r\nskb_pull(dataskb, self->header_length);\r\ndataskb->dev = self->netdev;\r\nskb_reset_mac_header(dataskb);\r\ndataskb->protocol = htons(ETH_P_IRDA);\r\nlen = dataskb->len;\r\nnetif_rx(dataskb);\r\nself->netdev->stats.rx_bytes += len;\r\nself->netdev->stats.rx_packets++;\r\ndone:\r\nnext_urb = self->idle_rx_urb;\r\nurb->context = NULL;\r\nself->idle_rx_urb = urb;\r\nirda_usb_submit(self, skb, next_urb);\r\n}\r\nstatic void irda_usb_rx_defer_expired(unsigned long data)\r\n{\r\nstruct urb *urb = (struct urb *) data;\r\nstruct sk_buff *skb = (struct sk_buff *) urb->context;\r\nstruct irda_usb_cb *self;\r\nstruct irda_skb_cb *cb;\r\nstruct urb *next_urb;\r\nIRDA_DEBUG(2, "%s()\n", __func__);\r\ncb = (struct irda_skb_cb *) skb->cb;\r\nIRDA_ASSERT(cb != NULL, return;);\r\nself = (struct irda_usb_cb *) cb->context;\r\nIRDA_ASSERT(self != NULL, return;);\r\nnext_urb = self->idle_rx_urb;\r\nurb->context = NULL;\r\nself->idle_rx_urb = urb;\r\nirda_usb_submit(self, skb, next_urb);\r\n}\r\nstatic int irda_usb_is_receiving(struct irda_usb_cb *self)\r\n{\r\nreturn 0;\r\n}\r\nstatic int stir421x_fw_upload(struct irda_usb_cb *self,\r\nconst unsigned char *patch,\r\nconst unsigned int patch_len)\r\n{\r\nint ret = -ENOMEM;\r\nint actual_len = 0;\r\nunsigned int i;\r\nunsigned int block_size = 0;\r\nunsigned char *patch_block;\r\npatch_block = kzalloc(STIR421X_PATCH_BLOCK_SIZE, GFP_KERNEL);\r\nif (patch_block == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < patch_len; i += block_size) {\r\nblock_size = patch_len - i;\r\nif (block_size > STIR421X_PATCH_BLOCK_SIZE)\r\nblock_size = STIR421X_PATCH_BLOCK_SIZE;\r\nmemcpy(patch_block, patch + i, block_size);\r\nret = usb_bulk_msg(self->usbdev,\r\nusb_sndbulkpipe(self->usbdev,\r\nself->bulk_out_ep),\r\npatch_block, block_size,\r\n&actual_len, msecs_to_jiffies(500));\r\nIRDA_DEBUG(3,"%s(): Bulk send %u bytes, ret=%d\n",\r\n__func__, actual_len, ret);\r\nif (ret < 0)\r\nbreak;\r\nmdelay(10);\r\n}\r\nkfree(patch_block);\r\nreturn ret;\r\n}\r\nstatic int stir421x_patch_device(struct irda_usb_cb *self)\r\n{\r\nunsigned int i;\r\nint ret;\r\nchar stir421x_fw_name[12];\r\nconst struct firmware *fw;\r\nconst unsigned char *fw_version_ptr;\r\nunsigned long fw_version = 0;\r\nsprintf(stir421x_fw_name, "4210%4X.sb",\r\nself->usbdev->descriptor.bcdDevice);\r\nret = request_firmware(&fw, stir421x_fw_name, &self->usbdev->dev);\r\nif (ret < 0)\r\nreturn ret;\r\nIRDA_MESSAGE("%s(): Received firmware %s (%zu bytes)\n",\r\n__func__, stir421x_fw_name, fw->size);\r\nret = -EINVAL;\r\nif (!memcmp(fw->data, STIR421X_PATCH_PRODUCT_VER,\r\nsizeof(STIR421X_PATCH_PRODUCT_VER) - 1)) {\r\nfw_version_ptr = fw->data +\r\nsizeof(STIR421X_PATCH_PRODUCT_VER) - 1;\r\nif (fw_version_ptr[3] == '.' &&\r\nfw_version_ptr[7] == '.') {\r\nunsigned long major, minor, build;\r\nmajor = simple_strtoul(fw_version_ptr, NULL, 10);\r\nminor = simple_strtoul(fw_version_ptr + 4, NULL, 10);\r\nbuild = simple_strtoul(fw_version_ptr + 8, NULL, 10);\r\nfw_version = (major << 12)\r\n+ (minor << 8)\r\n+ ((build / 10) << 4)\r\n+ (build % 10);\r\nIRDA_DEBUG(3, "%s(): Firmware Product version %ld\n",\r\n__func__, fw_version);\r\n}\r\n}\r\nif (self->usbdev->descriptor.bcdDevice == cpu_to_le16(fw_version)) {\r\nfor (i = 0; i < fw->size && fw->data[i] !=\r\nSTIR421X_PATCH_END_OF_HDR_TAG; i++) ;\r\nif (i < STIR421X_PATCH_CODE_OFFSET && i < fw->size &&\r\nSTIR421X_PATCH_END_OF_HDR_TAG == fw->data[i]) {\r\nif (!memcmp(fw->data + i + 1, STIR421X_PATCH_STMP_TAG,\r\nsizeof(STIR421X_PATCH_STMP_TAG) - 1)) {\r\ni += sizeof(STIR421X_PATCH_STMP_TAG);\r\nret = stir421x_fw_upload(self, &fw->data[i],\r\nfw->size - i);\r\n}\r\n}\r\n}\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic int irda_usb_net_open(struct net_device *netdev)\r\n{\r\nstruct irda_usb_cb *self;\r\nunsigned long flags;\r\nchar hwname[16];\r\nint i;\r\nIRDA_DEBUG(1, "%s()\n", __func__);\r\nIRDA_ASSERT(netdev != NULL, return -1;);\r\nself = netdev_priv(netdev);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nspin_lock_irqsave(&self->lock, flags);\r\nif(!self->present) {\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nIRDA_WARNING("%s(), device not present!\n", __func__);\r\nreturn -1;\r\n}\r\nif(self->needspatch) {\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nIRDA_WARNING("%s(), device needs patch\n", __func__) ;\r\nreturn -EIO ;\r\n}\r\nself->speed = -1;\r\nself->xbofs = -1;\r\nself->new_speed = -1;\r\nself->new_xbofs = -1;\r\nself->netopen = 1;\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nsprintf(hwname, "usb#%d", self->usbdev->devnum);\r\nself->irlap = irlap_open(netdev, &self->qos, hwname);\r\nIRDA_ASSERT(self->irlap != NULL, return -1;);\r\nnetif_start_queue(netdev);\r\nself->idle_rx_urb = self->rx_urb[IU_MAX_ACTIVE_RX_URBS];\r\nself->idle_rx_urb->context = NULL;\r\nfor (i = 0; i < IU_MAX_ACTIVE_RX_URBS; i++) {\r\nstruct sk_buff *skb = dev_alloc_skb(IRDA_SKB_MAX_MTU);\r\nif (!skb) {\r\nIRDA_WARNING("%s(), Failed to allocate Rx skb\n",\r\n__func__);\r\nreturn -1;\r\n}\r\nirda_usb_submit(self, skb, self->rx_urb[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int irda_usb_net_close(struct net_device *netdev)\r\n{\r\nstruct irda_usb_cb *self;\r\nint i;\r\nIRDA_DEBUG(1, "%s()\n", __func__);\r\nIRDA_ASSERT(netdev != NULL, return -1;);\r\nself = netdev_priv(netdev);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nself->netopen = 0;\r\nnetif_stop_queue(netdev);\r\ndel_timer(&self->rx_defer_timer);\r\nfor (i = 0; i < self->max_rx_urb; i++) {\r\nstruct urb *urb = self->rx_urb[i];\r\nstruct sk_buff *skb = (struct sk_buff *) urb->context;\r\nusb_kill_urb(urb);\r\nif(skb) {\r\ndev_kfree_skb(skb);\r\nurb->context = NULL;\r\n}\r\n}\r\nusb_kill_urb(self->tx_urb);\r\nusb_kill_urb(self->speed_urb);\r\nif (self->irlap)\r\nirlap_close(self->irlap);\r\nself->irlap = NULL;\r\nreturn 0;\r\n}\r\nstatic int irda_usb_net_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nunsigned long flags;\r\nstruct if_irda_req *irq = (struct if_irda_req *) rq;\r\nstruct irda_usb_cb *self;\r\nint ret = 0;\r\nIRDA_ASSERT(dev != NULL, return -1;);\r\nself = netdev_priv(dev);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_DEBUG(2, "%s(), %s, (cmd=0x%X)\n", __func__, dev->name, cmd);\r\nswitch (cmd) {\r\ncase SIOCSBANDWIDTH:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nspin_lock_irqsave(&self->lock, flags);\r\nif(self->present) {\r\nself->new_speed = irq->ifr_baudrate;\r\nirda_usb_change_speed_xbofs(self);\r\n}\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nbreak;\r\ncase SIOCSMEDIABUSY:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif(self->netopen)\r\nirda_device_set_media_busy(self->netdev, TRUE);\r\nbreak;\r\ncase SIOCGRECEIVING:\r\nirq->ifr_receiving = irda_usb_is_receiving(self);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline void irda_usb_init_qos(struct irda_usb_cb *self)\r\n{\r\nstruct irda_class_desc *desc;\r\nIRDA_DEBUG(3, "%s()\n", __func__);\r\ndesc = self->irda_desc;\r\nirda_init_max_qos_capabilies(&self->qos);\r\nself->qos.baud_rate.bits = le16_to_cpu(desc->wBaudRate);\r\nself->qos.min_turn_time.bits = desc->bmMinTurnaroundTime;\r\nself->qos.additional_bofs.bits = desc->bmAdditionalBOFs;\r\nself->qos.window_size.bits = desc->bmWindowSize;\r\nself->qos.data_size.bits = desc->bmDataSize;\r\nIRDA_DEBUG(0, "%s(), dongle says speed=0x%X, size=0x%X, window=0x%X, bofs=0x%X, turn=0x%X\n",\r\n__func__, self->qos.baud_rate.bits, self->qos.data_size.bits, self->qos.window_size.bits, self->qos.additional_bofs.bits, self->qos.min_turn_time.bits);\r\nif(self->capability & IUC_SIR_ONLY)\r\nself->qos.baud_rate.bits &= 0x00ff;\r\nif(self->capability & IUC_SMALL_PKT)\r\nself->qos.data_size.bits = 0x07;\r\nif(self->capability & IUC_NO_WINDOW)\r\nself->qos.window_size.bits = 0x01;\r\nif(self->capability & IUC_MAX_WINDOW)\r\nself->qos.window_size.bits = 0x7f;\r\nif(self->capability & IUC_MAX_XBOFS)\r\nself->qos.additional_bofs.bits = 0x01;\r\n#if 1\r\nif (qos_mtt_bits)\r\nself->qos.min_turn_time.bits = qos_mtt_bits;\r\n#endif\r\nirda_qos_bits_to_value(&self->qos);\r\n}\r\nstatic inline int irda_usb_open(struct irda_usb_cb *self)\r\n{\r\nstruct net_device *netdev = self->netdev;\r\nIRDA_DEBUG(1, "%s()\n", __func__);\r\nnetdev->netdev_ops = &irda_usb_netdev_ops;\r\nirda_usb_init_qos(self);\r\nreturn register_netdev(netdev);\r\n}\r\nstatic inline void irda_usb_close(struct irda_usb_cb *self)\r\n{\r\nIRDA_DEBUG(1, "%s()\n", __func__);\r\nunregister_netdev(self->netdev);\r\nkfree(self->speed_buff);\r\nself->speed_buff = NULL;\r\nkfree(self->tx_buff);\r\nself->tx_buff = NULL;\r\n}\r\nstatic inline int irda_usb_parse_endpoints(struct irda_usb_cb *self, struct usb_host_endpoint *endpoint, int ennum)\r\n{\r\nint i;\r\nself->bulk_in_ep = 0;\r\nself->bulk_out_ep = 0;\r\nself->bulk_int_ep = 0;\r\nfor(i = 0; i < ennum; i++) {\r\n__u8 ep;\r\n__u8 dir;\r\n__u8 attr;\r\n__u16 psize;\r\nep = endpoint[i].desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;\r\ndir = endpoint[i].desc.bEndpointAddress & USB_ENDPOINT_DIR_MASK;\r\nattr = endpoint[i].desc.bmAttributes;\r\npsize = le16_to_cpu(endpoint[i].desc.wMaxPacketSize);\r\nif(attr == USB_ENDPOINT_XFER_BULK) {\r\nif(dir == USB_DIR_IN) {\r\nself->bulk_in_ep = ep;\r\n} else {\r\nself->bulk_out_ep = ep;\r\nself->bulk_out_mtu = psize;\r\n}\r\n} else {\r\nif((attr == USB_ENDPOINT_XFER_INT) &&\r\n(dir == USB_DIR_IN)) {\r\nself->bulk_int_ep = ep;\r\n} else {\r\nIRDA_ERROR("%s(), Unrecognised endpoint %02X.\n", __func__, ep);\r\n}\r\n}\r\n}\r\nIRDA_DEBUG(0, "%s(), And our endpoints are : in=%02X, out=%02X (%d), int=%02X\n",\r\n__func__, self->bulk_in_ep, self->bulk_out_ep, self->bulk_out_mtu, self->bulk_int_ep);\r\nreturn (self->bulk_in_ep != 0) && (self->bulk_out_ep != 0);\r\n}\r\nstatic inline void irda_usb_dump_class_desc(struct irda_class_desc *desc)\r\n{\r\nprintk("bLength=%x\n", desc->bLength);\r\nprintk("bDescriptorType=%x\n", desc->bDescriptorType);\r\nprintk("bcdSpecRevision=%x\n", le16_to_cpu(desc->bcdSpecRevision));\r\nprintk("bmDataSize=%x\n", desc->bmDataSize);\r\nprintk("bmWindowSize=%x\n", desc->bmWindowSize);\r\nprintk("bmMinTurnaroundTime=%d\n", desc->bmMinTurnaroundTime);\r\nprintk("wBaudRate=%x\n", le16_to_cpu(desc->wBaudRate));\r\nprintk("bmAdditionalBOFs=%x\n", desc->bmAdditionalBOFs);\r\nprintk("bIrdaRateSniff=%x\n", desc->bIrdaRateSniff);\r\nprintk("bMaxUnicastList=%x\n", desc->bMaxUnicastList);\r\n}\r\nstatic inline struct irda_class_desc *irda_usb_find_class_desc(struct usb_interface *intf)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev (intf);\r\nstruct irda_class_desc *desc;\r\nint ret;\r\ndesc = kzalloc(sizeof(*desc), GFP_KERNEL);\r\nif (!desc)\r\nreturn NULL;\r\nret = usb_control_msg(dev, usb_rcvctrlpipe(dev,0),\r\nIU_REQ_GET_CLASS_DESC,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, intf->altsetting->desc.bInterfaceNumber, desc,\r\nsizeof(*desc), 500);\r\nIRDA_DEBUG(1, "%s(), ret=%d\n", __func__, ret);\r\nif (ret < sizeof(*desc)) {\r\nIRDA_WARNING("usb-irda: class_descriptor read %s (%d)\n",\r\n(ret<0) ? "failed" : "too short", ret);\r\n}\r\nelse if (desc->bDescriptorType != USB_DT_IRDA) {\r\nIRDA_WARNING("usb-irda: bad class_descriptor type\n");\r\n}\r\nelse {\r\n#ifdef IU_DUMP_CLASS_DESC\r\nirda_usb_dump_class_desc(desc);\r\n#endif\r\nreturn desc;\r\n}\r\nkfree(desc);\r\nreturn NULL;\r\n}\r\nstatic int irda_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct net_device *net;\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nstruct irda_usb_cb *self;\r\nstruct usb_host_interface *interface;\r\nstruct irda_class_desc *irda_desc;\r\nint ret = -ENOMEM;\r\nint i;\r\nIRDA_MESSAGE("IRDA-USB found at address %d, Vendor: %x, Product: %x\n",\r\ndev->devnum, le16_to_cpu(dev->descriptor.idVendor),\r\nle16_to_cpu(dev->descriptor.idProduct));\r\nnet = alloc_irdadev(sizeof(*self));\r\nif (!net)\r\ngoto err_out;\r\nSET_NETDEV_DEV(net, &intf->dev);\r\nself = netdev_priv(net);\r\nself->netdev = net;\r\nspin_lock_init(&self->lock);\r\ninit_timer(&self->rx_defer_timer);\r\nself->capability = id->driver_info;\r\nself->needspatch = ((self->capability & IUC_STIR421X) != 0);\r\nif (self->capability & IUC_STIR421X) {\r\nself->max_rx_urb = IU_SIGMATEL_MAX_RX_URBS;\r\nself->header_length = USB_IRDA_STIR421X_HEADER;\r\n} else {\r\nself->max_rx_urb = IU_MAX_RX_URBS;\r\nself->header_length = USB_IRDA_HEADER;\r\n}\r\nself->rx_urb = kcalloc(self->max_rx_urb, sizeof(struct urb *),\r\nGFP_KERNEL);\r\nif (!self->rx_urb)\r\ngoto err_free_net;\r\nfor (i = 0; i < self->max_rx_urb; i++) {\r\nself->rx_urb[i] = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!self->rx_urb[i]) {\r\ngoto err_out_1;\r\n}\r\n}\r\nself->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!self->tx_urb) {\r\ngoto err_out_1;\r\n}\r\nself->speed_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!self->speed_urb) {\r\ngoto err_out_2;\r\n}\r\nif (usb_reset_configuration (dev) < 0) {\r\ndev_err(&intf->dev, "reset_configuration failed\n");\r\nret = -EIO;\r\ngoto err_out_3;\r\n}\r\nret = usb_set_interface(dev, intf->altsetting->desc.bInterfaceNumber, 0);\r\nIRDA_DEBUG(1, "usb-irda: set interface %d result %d\n", intf->altsetting->desc.bInterfaceNumber, ret);\r\nswitch (ret) {\r\ncase 0:\r\nbreak;\r\ncase -EPIPE:\r\nIRDA_DEBUG(0, "%s(), Received -EPIPE, ignoring...\n", __func__);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(0, "%s(), Unknown error %d\n", __func__, ret);\r\nret = -EIO;\r\ngoto err_out_3;\r\n}\r\ninterface = intf->cur_altsetting;\r\nif(!irda_usb_parse_endpoints(self, interface->endpoint,\r\ninterface->desc.bNumEndpoints)) {\r\nIRDA_ERROR("%s(), Bogus endpoints...\n", __func__);\r\nret = -EIO;\r\ngoto err_out_3;\r\n}\r\nself->usbdev = dev;\r\nirda_desc = irda_usb_find_class_desc(intf);\r\nret = -ENODEV;\r\nif (!irda_desc)\r\ngoto err_out_3;\r\nif (self->needspatch) {\r\nret = usb_control_msg (self->usbdev, usb_sndctrlpipe (self->usbdev, 0),\r\n0x02, 0x40, 0, 0, NULL, 0, 500);\r\nif (ret < 0) {\r\nIRDA_DEBUG (0, "usb_control_msg failed %d\n", ret);\r\ngoto err_out_3;\r\n} else {\r\nmdelay(10);\r\n}\r\n}\r\nself->irda_desc = irda_desc;\r\nself->present = 1;\r\nself->netopen = 0;\r\nself->usbintf = intf;\r\nself->speed_buff = kzalloc(IRDA_USB_SPEED_MTU, GFP_KERNEL);\r\nif (!self->speed_buff)\r\ngoto err_out_3;\r\nself->tx_buff = kzalloc(IRDA_SKB_MAX_MTU + self->header_length,\r\nGFP_KERNEL);\r\nif (!self->tx_buff)\r\ngoto err_out_4;\r\nret = irda_usb_open(self);\r\nif (ret)\r\ngoto err_out_5;\r\nIRDA_MESSAGE("IrDA: Registered device %s\n", net->name);\r\nusb_set_intfdata(intf, self);\r\nif (self->needspatch) {\r\nret = stir421x_patch_device(self);\r\nself->needspatch = (ret < 0);\r\nif (self->needspatch) {\r\nIRDA_ERROR("STIR421X: Couldn't upload patch\n");\r\ngoto err_out_6;\r\n}\r\nirda_desc = irda_usb_find_class_desc (self->usbintf);\r\nif (!irda_desc) {\r\nret = -ENODEV;\r\ngoto err_out_6;\r\n}\r\nkfree(self->irda_desc);\r\nself->irda_desc = irda_desc;\r\nirda_usb_init_qos(self);\r\n}\r\nreturn 0;\r\nerr_out_6:\r\nunregister_netdev(self->netdev);\r\nerr_out_5:\r\nkfree(self->tx_buff);\r\nerr_out_4:\r\nkfree(self->speed_buff);\r\nerr_out_3:\r\nusb_free_urb(self->speed_urb);\r\nerr_out_2:\r\nusb_free_urb(self->tx_urb);\r\nerr_out_1:\r\nfor (i = 0; i < self->max_rx_urb; i++)\r\nusb_free_urb(self->rx_urb[i]);\r\nkfree(self->rx_urb);\r\nerr_free_net:\r\nfree_netdev(net);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic void irda_usb_disconnect(struct usb_interface *intf)\r\n{\r\nunsigned long flags;\r\nstruct irda_usb_cb *self = usb_get_intfdata(intf);\r\nint i;\r\nIRDA_DEBUG(1, "%s()\n", __func__);\r\nusb_set_intfdata(intf, NULL);\r\nif (!self)\r\nreturn;\r\nspin_lock_irqsave(&self->lock, flags);\r\nself->present = 0;\r\ndel_timer(&self->rx_defer_timer);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nif((self->netopen) || (self->irlap)) {\r\nnetif_stop_queue(self->netdev);\r\nfor (i = 0; i < self->max_rx_urb; i++)\r\nusb_kill_urb(self->rx_urb[i]);\r\nusb_kill_urb(self->tx_urb);\r\nusb_kill_urb(self->speed_urb);\r\n}\r\nirda_usb_close(self);\r\nself->usbdev = NULL;\r\nself->usbintf = NULL;\r\nfor (i = 0; i < self->max_rx_urb; i++)\r\nusb_free_urb(self->rx_urb[i]);\r\nkfree(self->rx_urb);\r\nusb_free_urb(self->tx_urb);\r\nusb_free_urb(self->speed_urb);\r\nfree_netdev(self->netdev);\r\nIRDA_DEBUG(0, "%s(), USB IrDA Disconnected\n", __func__);\r\n}\r\nstatic int irda_usb_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct irda_usb_cb *self = usb_get_intfdata(intf);\r\nint i;\r\nnetif_device_detach(self->netdev);\r\nif (self->tx_urb != NULL)\r\nusb_kill_urb(self->tx_urb);\r\nif (self->speed_urb != NULL)\r\nusb_kill_urb(self->speed_urb);\r\nfor (i = 0; i < self->max_rx_urb; i++) {\r\nif (self->rx_urb[i] != NULL)\r\nusb_kill_urb(self->rx_urb[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int irda_usb_resume(struct usb_interface *intf)\r\n{\r\nstruct irda_usb_cb *self = usb_get_intfdata(intf);\r\nint i;\r\nfor (i = 0; i < self->max_rx_urb; i++) {\r\nif (self->rx_urb[i] != NULL)\r\nusb_submit_urb(self->rx_urb[i], GFP_KERNEL);\r\n}\r\nnetif_device_attach(self->netdev);\r\nreturn 0;\r\n}
