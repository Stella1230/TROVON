static u32\r\nread_vco(struct drm_device *dev, int clk)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nu32 sctl = nv_rd32(device, 0x4120 + (clk * 4));\r\nif ((sctl & 0x00000030) != 0x00000030)\r\nreturn read_pll(dev, 0x41, 0x00e820);\r\nreturn read_pll(dev, 0x42, 0x00e8a0);\r\n}\r\nstatic u32\r\nread_clk(struct drm_device *dev, int clk, bool ignore_en)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nu32 sctl, sdiv, sclk;\r\nif (clk >= 0x40) {\r\nif (nv_device(drm->device)->chipset == 0xaf) {\r\nreturn nv_rd32(device, 0x00471c) * 1000;\r\n}\r\nreturn device->crystal;\r\n}\r\nsctl = nv_rd32(device, 0x4120 + (clk * 4));\r\nif (!ignore_en && !(sctl & 0x00000100))\r\nreturn 0;\r\nswitch (sctl & 0x00003000) {\r\ncase 0x00000000:\r\nreturn device->crystal;\r\ncase 0x00002000:\r\nif (sctl & 0x00000040)\r\nreturn 108000;\r\nreturn 100000;\r\ncase 0x00003000:\r\nsclk = read_vco(dev, clk);\r\nsdiv = ((sctl & 0x003f0000) >> 16) + 2;\r\nreturn (sclk * 2) / sdiv;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic u32\r\nread_pll(struct drm_device *dev, int clk, u32 pll)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nu32 ctrl = nv_rd32(device, pll + 0);\r\nu32 sclk = 0, P = 1, N = 1, M = 1;\r\nif (!(ctrl & 0x00000008)) {\r\nif (ctrl & 0x00000001) {\r\nu32 coef = nv_rd32(device, pll + 4);\r\nM = (coef & 0x000000ff) >> 0;\r\nN = (coef & 0x0000ff00) >> 8;\r\nP = (coef & 0x003f0000) >> 16;\r\nif ((pll & 0x00ff00) == 0x00e800)\r\nP = 1;\r\nsclk = read_clk(dev, 0x00 + clk, false);\r\n}\r\n} else {\r\nsclk = read_clk(dev, 0x10 + clk, false);\r\n}\r\nif (M * P)\r\nreturn sclk * N / (M * P);\r\nreturn 0;\r\n}\r\nstatic int\r\ncalc_clk(struct drm_device *dev, int clk, u32 pll, u32 khz, struct creg *reg)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nstruct nouveau_bios *bios = nouveau_bios(device);\r\nstruct nvbios_pll limits;\r\nu32 oclk, sclk, sdiv;\r\nint P, N, M, diff;\r\nint ret;\r\nreg->pll = 0;\r\nreg->clk = 0;\r\nif (!khz) {\r\nNV_DEBUG(drm, "no clock for 0x%04x/0x%02x\n", pll, clk);\r\nreturn 0;\r\n}\r\nswitch (khz) {\r\ncase 27000:\r\nreg->clk = 0x00000100;\r\nreturn khz;\r\ncase 100000:\r\nreg->clk = 0x00002100;\r\nreturn khz;\r\ncase 108000:\r\nreg->clk = 0x00002140;\r\nreturn khz;\r\ndefault:\r\nsclk = read_vco(dev, clk);\r\nsdiv = min((sclk * 2) / (khz - 2999), (u32)65);\r\nif (sdiv > 4) {\r\noclk = (sclk * 2) / sdiv;\r\ndiff = khz - oclk;\r\nif (!pll || (diff >= -2000 && diff < 3000)) {\r\nreg->clk = (((sdiv - 2) << 16) | 0x00003100);\r\nreturn oclk;\r\n}\r\n}\r\nif (!pll) {\r\nNV_ERROR(drm, "bad freq %02x: %d %d\n", clk, khz, sclk);\r\nreturn -ERANGE;\r\n}\r\nbreak;\r\n}\r\nret = nvbios_pll_parse(bios, pll, &limits);\r\nif (ret)\r\nreturn ret;\r\nlimits.refclk = read_clk(dev, clk - 0x10, true);\r\nif (!limits.refclk)\r\nreturn -EINVAL;\r\nret = nva3_calc_pll(dev, &limits, khz, &N, NULL, &M, &P);\r\nif (ret >= 0) {\r\nreg->clk = nv_rd32(device, 0x4120 + (clk * 4));\r\nreg->pll = (P << 16) | (N << 8) | M;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nprog_pll(struct drm_device *dev, int clk, u32 pll, struct creg *reg)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nconst u32 src0 = 0x004120 + (clk * 4);\r\nconst u32 src1 = 0x004160 + (clk * 4);\r\nconst u32 ctrl = pll + 0;\r\nconst u32 coef = pll + 4;\r\nif (!reg->clk && !reg->pll) {\r\nNV_DEBUG(drm, "no clock for %02x\n", clk);\r\nreturn;\r\n}\r\nif (reg->pll) {\r\nnv_mask(device, src0, 0x00000101, 0x00000101);\r\nnv_wr32(device, coef, reg->pll);\r\nnv_mask(device, ctrl, 0x00000015, 0x00000015);\r\nnv_mask(device, ctrl, 0x00000010, 0x00000000);\r\nnv_wait(device, ctrl, 0x00020000, 0x00020000);\r\nnv_mask(device, ctrl, 0x00000010, 0x00000010);\r\nnv_mask(device, ctrl, 0x00000008, 0x00000000);\r\nnv_mask(device, src1, 0x00000100, 0x00000000);\r\nnv_mask(device, src1, 0x00000001, 0x00000000);\r\n} else {\r\nnv_mask(device, src1, 0x003f3141, 0x00000101 | reg->clk);\r\nnv_mask(device, ctrl, 0x00000018, 0x00000018);\r\nudelay(20);\r\nnv_mask(device, ctrl, 0x00000001, 0x00000000);\r\nnv_mask(device, src0, 0x00000100, 0x00000000);\r\nnv_mask(device, src0, 0x00000001, 0x00000000);\r\n}\r\n}\r\nstatic void\r\nprog_clk(struct drm_device *dev, int clk, struct creg *reg)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nif (!reg->clk) {\r\nNV_DEBUG(drm, "no clock for %02x\n", clk);\r\nreturn;\r\n}\r\nnv_mask(device, 0x004120 + (clk * 4), 0x003f3141, 0x00000101 | reg->clk);\r\n}\r\nint\r\nnva3_pm_clocks_get(struct drm_device *dev, struct nouveau_pm_level *perflvl)\r\n{\r\nperflvl->core = read_pll(dev, 0x00, 0x4200);\r\nperflvl->shader = read_pll(dev, 0x01, 0x4220);\r\nperflvl->memory = read_pll(dev, 0x02, 0x4000);\r\nperflvl->unka0 = read_clk(dev, 0x20, false);\r\nperflvl->vdec = read_clk(dev, 0x21, false);\r\nperflvl->daemon = read_clk(dev, 0x25, false);\r\nperflvl->copy = perflvl->core;\r\nreturn 0;\r\n}\r\nvoid *\r\nnva3_pm_clocks_pre(struct drm_device *dev, struct nouveau_pm_level *perflvl)\r\n{\r\nstruct nva3_pm_state *info;\r\nu8 ramcfg_cnt;\r\nint ret;\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = calc_clk(dev, 0x10, 0x4200, perflvl->core, &info->nclk);\r\nif (ret < 0)\r\ngoto out;\r\nret = calc_clk(dev, 0x11, 0x4220, perflvl->shader, &info->sclk);\r\nif (ret < 0)\r\ngoto out;\r\nret = calc_clk(dev, 0x12, 0x4000, perflvl->memory, &info->mclk);\r\nif (ret < 0)\r\ngoto out;\r\nret = calc_clk(dev, 0x20, 0x0000, perflvl->unka0, &info->unka0);\r\nif (ret < 0)\r\ngoto out;\r\nret = calc_clk(dev, 0x21, 0x0000, perflvl->vdec, &info->vdec);\r\nif (ret < 0)\r\ngoto out;\r\ninfo->rammap = nouveau_perf_rammap(dev, perflvl->memory,\r\n&info->rammap_ver,\r\n&info->rammap_len,\r\n&ramcfg_cnt, &info->ramcfg_len);\r\nif (info->rammap_ver != 0x10 || info->rammap_len < 5)\r\ninfo->rammap = NULL;\r\ninfo->ramcfg = nouveau_perf_ramcfg(dev, perflvl->memory,\r\n&info->rammap_ver,\r\n&info->ramcfg_len);\r\nif (info->rammap_ver != 0x10)\r\ninfo->ramcfg = NULL;\r\ninfo->perflvl = perflvl;\r\nout:\r\nif (ret < 0) {\r\nkfree(info);\r\ninfo = ERR_PTR(ret);\r\n}\r\nreturn info;\r\n}\r\nstatic bool\r\nnva3_pm_grcp_idle(void *data)\r\n{\r\nstruct drm_device *dev = data;\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nif (!(nv_rd32(device, 0x400304) & 0x00000001))\r\nreturn true;\r\nif (nv_rd32(device, 0x400308) == 0x0050001c)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void\r\nmclk_precharge(struct nouveau_mem_exec_func *exec)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(exec->dev);\r\nnv_wr32(device, 0x1002d4, 0x00000001);\r\n}\r\nstatic void\r\nmclk_refresh(struct nouveau_mem_exec_func *exec)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(exec->dev);\r\nnv_wr32(device, 0x1002d0, 0x00000001);\r\n}\r\nstatic void\r\nmclk_refresh_auto(struct nouveau_mem_exec_func *exec, bool enable)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(exec->dev);\r\nnv_wr32(device, 0x100210, enable ? 0x80000000 : 0x00000000);\r\n}\r\nstatic void\r\nmclk_refresh_self(struct nouveau_mem_exec_func *exec, bool enable)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(exec->dev);\r\nnv_wr32(device, 0x1002dc, enable ? 0x00000001 : 0x00000000);\r\n}\r\nstatic void\r\nmclk_wait(struct nouveau_mem_exec_func *exec, u32 nsec)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(exec->dev);\r\nvolatile u32 post = nv_rd32(device, 0); (void)post;\r\nudelay((nsec + 500) / 1000);\r\n}\r\nstatic u32\r\nmclk_mrg(struct nouveau_mem_exec_func *exec, int mr)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(exec->dev);\r\nif (mr <= 1)\r\nreturn nv_rd32(device, 0x1002c0 + ((mr - 0) * 4));\r\nif (mr <= 3)\r\nreturn nv_rd32(device, 0x1002e0 + ((mr - 2) * 4));\r\nreturn 0;\r\n}\r\nstatic void\r\nmclk_mrs(struct nouveau_mem_exec_func *exec, int mr, u32 data)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(exec->dev);\r\nstruct nouveau_fb *pfb = nouveau_fb(device);\r\nif (mr <= 1) {\r\nif (pfb->ram->ranks > 1)\r\nnv_wr32(device, 0x1002c8 + ((mr - 0) * 4), data);\r\nnv_wr32(device, 0x1002c0 + ((mr - 0) * 4), data);\r\n} else\r\nif (mr <= 3) {\r\nif (pfb->ram->ranks > 1)\r\nnv_wr32(device, 0x1002e8 + ((mr - 2) * 4), data);\r\nnv_wr32(device, 0x1002e0 + ((mr - 2) * 4), data);\r\n}\r\n}\r\nstatic void\r\nmclk_clock_set(struct nouveau_mem_exec_func *exec)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(exec->dev);\r\nstruct nva3_pm_state *info = exec->priv;\r\nu32 ctrl;\r\nctrl = nv_rd32(device, 0x004000);\r\nif (!(ctrl & 0x00000008) && info->mclk.pll) {\r\nnv_wr32(device, 0x004000, (ctrl |= 0x00000008));\r\nnv_mask(device, 0x1110e0, 0x00088000, 0x00088000);\r\nnv_wr32(device, 0x004018, 0x00001000);\r\nnv_wr32(device, 0x004000, (ctrl &= ~0x00000001));\r\nnv_wr32(device, 0x004004, info->mclk.pll);\r\nnv_wr32(device, 0x004000, (ctrl |= 0x00000001));\r\nudelay(64);\r\nnv_wr32(device, 0x004018, 0x00005000 | info->r004018);\r\nudelay(20);\r\n} else\r\nif (!info->mclk.pll) {\r\nnv_mask(device, 0x004168, 0x003f3040, info->mclk.clk);\r\nnv_wr32(device, 0x004000, (ctrl |= 0x00000008));\r\nnv_mask(device, 0x1110e0, 0x00088000, 0x00088000);\r\nnv_wr32(device, 0x004018, 0x0000d000 | info->r004018);\r\n}\r\nif (info->rammap) {\r\nif (info->ramcfg && (info->rammap[4] & 0x08)) {\r\nu32 unk5a0 = (ROM16(info->ramcfg[5]) << 8) |\r\ninfo->ramcfg[5];\r\nu32 unk5a4 = ROM16(info->ramcfg[7]);\r\nu32 unk804 = (info->ramcfg[9] & 0xf0) << 16 |\r\n(info->ramcfg[3] & 0x0f) << 16 |\r\n(info->ramcfg[9] & 0x0f) |\r\n0x80000000;\r\nnv_wr32(device, 0x1005a0, unk5a0);\r\nnv_wr32(device, 0x1005a4, unk5a4);\r\nnv_wr32(device, 0x10f804, unk804);\r\nnv_mask(device, 0x10053c, 0x00001000, 0x00000000);\r\n} else {\r\nnv_mask(device, 0x10053c, 0x00001000, 0x00001000);\r\nnv_mask(device, 0x10f804, 0x80000000, 0x00000000);\r\nnv_mask(device, 0x100760, 0x22222222, info->r100760);\r\nnv_mask(device, 0x1007a0, 0x22222222, info->r100760);\r\nnv_mask(device, 0x1007e0, 0x22222222, info->r100760);\r\n}\r\n}\r\nif (info->mclk.pll) {\r\nnv_mask(device, 0x1110e0, 0x00088000, 0x00011000);\r\nnv_wr32(device, 0x004000, (ctrl &= ~0x00000008));\r\n}\r\n}\r\nstatic void\r\nmclk_timing_set(struct nouveau_mem_exec_func *exec)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(exec->dev);\r\nstruct nva3_pm_state *info = exec->priv;\r\nstruct nouveau_pm_level *perflvl = info->perflvl;\r\nint i;\r\nfor (i = 0; i < 9; i++)\r\nnv_wr32(device, 0x100220 + (i * 4), perflvl->timing.reg[i]);\r\nif (info->ramcfg) {\r\nu32 data = (info->ramcfg[2] & 0x08) ? 0x00000000 : 0x00001000;\r\nnv_mask(device, 0x100200, 0x00001000, data);\r\n}\r\nif (info->ramcfg) {\r\nu32 unk714 = nv_rd32(device, 0x100714) & ~0xf0000010;\r\nu32 unk718 = nv_rd32(device, 0x100718) & ~0x00000100;\r\nu32 unk71c = nv_rd32(device, 0x10071c) & ~0x00000100;\r\nif ( (info->ramcfg[2] & 0x20))\r\nunk714 |= 0xf0000000;\r\nif (!(info->ramcfg[2] & 0x04))\r\nunk714 |= 0x00000010;\r\nnv_wr32(device, 0x100714, unk714);\r\nif (info->ramcfg[2] & 0x01)\r\nunk71c |= 0x00000100;\r\nnv_wr32(device, 0x10071c, unk71c);\r\nif (info->ramcfg[2] & 0x02)\r\nunk718 |= 0x00000100;\r\nnv_wr32(device, 0x100718, unk718);\r\nif (info->ramcfg[2] & 0x10)\r\nnv_wr32(device, 0x111100, 0x48000000);\r\n}\r\n}\r\nstatic void\r\nprog_mem(struct drm_device *dev, struct nva3_pm_state *info)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nstruct nouveau_mem_exec_func exec = {\r\n.dev = dev,\r\n.precharge = mclk_precharge,\r\n.refresh = mclk_refresh,\r\n.refresh_auto = mclk_refresh_auto,\r\n.refresh_self = mclk_refresh_self,\r\n.wait = mclk_wait,\r\n.mrg = mclk_mrg,\r\n.mrs = mclk_mrs,\r\n.clock_set = mclk_clock_set,\r\n.timing_set = mclk_timing_set,\r\n.priv = info\r\n};\r\nu32 ctrl;\r\nif (info->perflvl->memory <= 750000) {\r\ninfo->r004018 = 0x10000000;\r\ninfo->r100760 = 0x22222222;\r\n}\r\nctrl = nv_rd32(device, 0x004000);\r\nif (ctrl & 0x00000008) {\r\nif (info->mclk.pll) {\r\nnv_mask(device, 0x004128, 0x00000101, 0x00000101);\r\nnv_wr32(device, 0x004004, info->mclk.pll);\r\nnv_wr32(device, 0x004000, (ctrl |= 0x00000001));\r\nnv_wr32(device, 0x004000, (ctrl &= 0xffffffef));\r\nnv_wait(device, 0x004000, 0x00020000, 0x00020000);\r\nnv_wr32(device, 0x004000, (ctrl |= 0x00000010));\r\nnv_wr32(device, 0x004018, 0x00005000 | info->r004018);\r\nnv_wr32(device, 0x004000, (ctrl |= 0x00000004));\r\n}\r\n} else {\r\nu32 ssel = 0x00000101;\r\nif (info->mclk.clk)\r\nssel |= info->mclk.clk;\r\nelse\r\nssel |= 0x00080000;\r\nnv_mask(device, 0x004168, 0x003f3141, ctrl);\r\n}\r\nif (info->ramcfg) {\r\nif (info->ramcfg[2] & 0x10) {\r\nnv_mask(device, 0x111104, 0x00000600, 0x00000000);\r\n} else {\r\nnv_mask(device, 0x111100, 0x40000000, 0x40000000);\r\nnv_mask(device, 0x111104, 0x00000180, 0x00000000);\r\n}\r\n}\r\nif (info->rammap && !(info->rammap[4] & 0x02))\r\nnv_mask(device, 0x100200, 0x00000800, 0x00000000);\r\nnv_wr32(device, 0x611200, 0x00003300);\r\nif (!(info->ramcfg[2] & 0x10))\r\nnv_wr32(device, 0x111100, 0x4c020000);\r\nnouveau_mem_exec(&exec, info->perflvl);\r\nnv_wr32(device, 0x611200, 0x00003330);\r\nif (info->rammap && (info->rammap[4] & 0x02))\r\nnv_mask(device, 0x100200, 0x00000800, 0x00000800);\r\nif (info->ramcfg) {\r\nif (info->ramcfg[2] & 0x10) {\r\nnv_mask(device, 0x111104, 0x00000180, 0x00000180);\r\nnv_mask(device, 0x111100, 0x40000000, 0x00000000);\r\n} else {\r\nnv_mask(device, 0x111104, 0x00000600, 0x00000600);\r\n}\r\n}\r\nif (info->mclk.pll) {\r\nnv_mask(device, 0x004168, 0x00000001, 0x00000000);\r\nnv_mask(device, 0x004168, 0x00000100, 0x00000000);\r\n} else {\r\nnv_mask(device, 0x004000, 0x00000001, 0x00000000);\r\nnv_mask(device, 0x004128, 0x00000001, 0x00000000);\r\nnv_mask(device, 0x004128, 0x00000100, 0x00000000);\r\n}\r\n}\r\nint\r\nnva3_pm_clocks_set(struct drm_device *dev, void *pre_state)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nva3_pm_state *info = pre_state;\r\nint ret = -EAGAIN;\r\nnv_wr32(device, 0x400324, 0x00000000);\r\nnv_wr32(device, 0x400328, 0x0050001c);\r\nif (!nv_wait_cb(device, nva3_pm_grcp_idle, dev)) {\r\nNV_ERROR(drm, "pm: ctxprog didn't go idle\n");\r\ngoto cleanup;\r\n}\r\nnv_mask(device, 0x002504, 0x00000001, 0x00000001);\r\nif (!nv_wait(device, 0x002504, 0x00000010, 0x00000010)) {\r\nNV_ERROR(drm, "pm: fifo didn't go idle\n");\r\ngoto cleanup;\r\n}\r\nprog_pll(dev, 0x00, 0x004200, &info->nclk);\r\nprog_pll(dev, 0x01, 0x004220, &info->sclk);\r\nprog_clk(dev, 0x20, &info->unka0);\r\nprog_clk(dev, 0x21, &info->vdec);\r\nif (info->mclk.clk || info->mclk.pll)\r\nprog_mem(dev, info);\r\nret = 0;\r\ncleanup:\r\nnv_mask(device, 0x002504, 0x00000001, 0x00000000);\r\nnv_wr32(device, 0x400324, 0x00000000);\r\nnv_wr32(device, 0x400328, 0x0070009c);\r\nif (nv_rd32(device, 0x400308) == 0x0050001c)\r\nnv_mask(device, 0x400824, 0x10000000, 0x10000000);\r\nkfree(info);\r\nreturn ret;\r\n}
