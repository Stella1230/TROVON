static void ctrl_write(unsigned int i, unsigned int val)\r\n{\r\nunsigned int tmp = 0;\r\nunsigned long shift = 0, mask = 0;\r\ndbg("ctrl_write %d %x\n", i, val);\r\nswitch(i) {\r\ncase 0:\r\ntmp = mfspr(SPRN_MMCR0);\r\nshift = 6;\r\nmask = 0x7F;\r\nbreak;\r\ncase 1:\r\ntmp = mfspr(SPRN_MMCR0);\r\nshift = 0;\r\nmask = 0x3F;\r\nbreak;\r\ncase 2:\r\ntmp = mfspr(SPRN_MMCR1);\r\nshift = 31 - 4;\r\nmask = 0x1F;\r\nbreak;\r\ncase 3:\r\ntmp = mfspr(SPRN_MMCR1);\r\nshift = 31 - 9;\r\nmask = 0x1F;\r\nbreak;\r\ncase 4:\r\ntmp = mfspr(SPRN_MMCR1);\r\nshift = 31 - 14;\r\nmask = 0x1F;\r\nbreak;\r\ncase 5:\r\ntmp = mfspr(SPRN_MMCR1);\r\nshift = 31 - 19;\r\nmask = 0x1F;\r\nbreak;\r\ncase 6:\r\ntmp = mfspr(SPRN_MMCR1);\r\nshift = 31 - 24;\r\nmask = 0x1F;\r\nbreak;\r\ncase 7:\r\ntmp = mfspr(SPRN_MMCR1);\r\nshift = 31 - 28;\r\nmask = 0xF;\r\nbreak;\r\n}\r\ntmp = tmp & ~(mask << shift);\r\ntmp |= val << shift;\r\nswitch(i) {\r\ncase 0:\r\ncase 1:\r\nmtspr(SPRN_MMCR0, tmp);\r\nbreak;\r\ndefault:\r\nmtspr(SPRN_MMCR1, tmp);\r\n}\r\ndbg("ctrl_write mmcr0 %lx mmcr1 %lx\n", mfspr(SPRN_MMCR0),\r\nmfspr(SPRN_MMCR1));\r\n}\r\nstatic int rs64_reg_setup(struct op_counter_config *ctr,\r\nstruct op_system_config *sys,\r\nint num_ctrs)\r\n{\r\nint i;\r\nnum_counters = num_ctrs;\r\nfor (i = 0; i < num_counters; ++i)\r\nreset_value[i] = 0x80000000UL - ctr[i].count;\r\nreturn 0;\r\n}\r\nstatic int rs64_cpu_setup(struct op_counter_config *ctr)\r\n{\r\nunsigned int mmcr0;\r\nmmcr0 = MMCR0_FC;\r\nmtspr(SPRN_MMCR0, mmcr0);\r\nmtspr(SPRN_MMCR1, 0);\r\nif (cpu_has_feature(CPU_FTR_MMCRA))\r\nmtspr(SPRN_MMCRA, 0);\r\nmmcr0 |= MMCR0_FCM1|MMCR0_PMXE|MMCR0_FCECE;\r\nmmcr0 |= MMCR0_PMC1CE|MMCR0_PMCjCE;\r\nmtspr(SPRN_MMCR0, mmcr0);\r\ndbg("setup on cpu %d, mmcr0 %lx\n", smp_processor_id(),\r\nmfspr(SPRN_MMCR0));\r\ndbg("setup on cpu %d, mmcr1 %lx\n", smp_processor_id(),\r\nmfspr(SPRN_MMCR1));\r\nreturn 0;\r\n}\r\nstatic int rs64_start(struct op_counter_config *ctr)\r\n{\r\nint i;\r\nunsigned int mmcr0;\r\nmtmsrd(mfmsr() | MSR_PMM);\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (ctr[i].enabled) {\r\nclassic_ctr_write(i, reset_value[i]);\r\nctrl_write(i, ctr[i].event);\r\n} else {\r\nclassic_ctr_write(i, 0);\r\n}\r\n}\r\nmmcr0 = mfspr(SPRN_MMCR0);\r\nmmcr0 &= ~MMCR0_FC;\r\nmtspr(SPRN_MMCR0, mmcr0);\r\ndbg("start on cpu %d, mmcr0 %x\n", smp_processor_id(), mmcr0);\r\nreturn 0;\r\n}\r\nstatic void rs64_stop(void)\r\n{\r\nunsigned int mmcr0;\r\nmmcr0 = mfspr(SPRN_MMCR0);\r\nmmcr0 |= MMCR0_FC;\r\nmtspr(SPRN_MMCR0, mmcr0);\r\ndbg("stop on cpu %d, mmcr0 %x\n", smp_processor_id(), mmcr0);\r\nmb();\r\n}\r\nstatic void rs64_handle_interrupt(struct pt_regs *regs,\r\nstruct op_counter_config *ctr)\r\n{\r\nunsigned int mmcr0;\r\nint is_kernel;\r\nint val;\r\nint i;\r\nunsigned long pc = mfspr(SPRN_SIAR);\r\nis_kernel = is_kernel_addr(pc);\r\nmtmsrd(mfmsr() | MSR_PMM);\r\nfor (i = 0; i < num_counters; ++i) {\r\nval = classic_ctr_read(i);\r\nif (val < 0) {\r\nif (ctr[i].enabled) {\r\noprofile_add_ext_sample(pc, regs, i, is_kernel);\r\nclassic_ctr_write(i, reset_value[i]);\r\n} else {\r\nclassic_ctr_write(i, 0);\r\n}\r\n}\r\n}\r\nmmcr0 = mfspr(SPRN_MMCR0);\r\nmmcr0 |= MMCR0_PMXE;\r\nmmcr0 &= ~MMCR0_FC;\r\nmtspr(SPRN_MMCR0, mmcr0);\r\n}
