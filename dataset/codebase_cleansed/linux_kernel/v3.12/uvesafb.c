static void uvesafb_cn_callback(struct cn_msg *msg, struct netlink_skb_parms *nsp)\r\n{\r\nstruct uvesafb_task *utask;\r\nstruct uvesafb_ktask *task;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn;\r\nif (msg->seq >= UVESAFB_TASKS_MAX)\r\nreturn;\r\nmutex_lock(&uvfb_lock);\r\ntask = uvfb_tasks[msg->seq];\r\nif (!task || msg->ack != task->ack) {\r\nmutex_unlock(&uvfb_lock);\r\nreturn;\r\n}\r\nutask = (struct uvesafb_task *)msg->data;\r\nif (task->t.buf_len < utask->buf_len ||\r\nutask->buf_len > msg->len - sizeof(*utask)) {\r\nmutex_unlock(&uvfb_lock);\r\nreturn;\r\n}\r\nuvfb_tasks[msg->seq] = NULL;\r\nmutex_unlock(&uvfb_lock);\r\nmemcpy(&task->t, utask, sizeof(*utask));\r\nif (task->t.buf_len && task->buf)\r\nmemcpy(task->buf, utask + 1, task->t.buf_len);\r\ncomplete(task->done);\r\nreturn;\r\n}\r\nstatic int uvesafb_helper_start(void)\r\n{\r\nchar *envp[] = {\r\n"HOME=/",\r\n"PATH=/sbin:/bin",\r\nNULL,\r\n};\r\nchar *argv[] = {\r\nv86d_path,\r\nNULL,\r\n};\r\nreturn call_usermodehelper(v86d_path, argv, envp, UMH_WAIT_PROC);\r\n}\r\nstatic int uvesafb_exec(struct uvesafb_ktask *task)\r\n{\r\nstatic int seq;\r\nstruct cn_msg *m;\r\nint err;\r\nint len = sizeof(task->t) + task->t.buf_len;\r\nif (sizeof(*m) + len > CONNECTOR_MAX_MSG_SIZE) {\r\nprintk(KERN_WARNING "uvesafb: message too long (%d), "\r\n"can't execute task\n", (int)(sizeof(*m) + len));\r\nreturn -E2BIG;\r\n}\r\nm = kzalloc(sizeof(*m) + len, GFP_KERNEL);\r\nif (!m)\r\nreturn -ENOMEM;\r\ninit_completion(task->done);\r\nmemcpy(&m->id, &uvesafb_cn_id, sizeof(m->id));\r\nm->seq = seq;\r\nm->len = len;\r\nm->ack = prandom_u32();\r\nmemcpy(m + 1, &task->t, sizeof(task->t));\r\nmemcpy((u8 *)(m + 1) + sizeof(task->t), task->buf, task->t.buf_len);\r\ntask->ack = m->ack;\r\nmutex_lock(&uvfb_lock);\r\nif (uvfb_tasks[seq]) {\r\nmutex_unlock(&uvfb_lock);\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nuvfb_tasks[seq] = task;\r\nmutex_unlock(&uvfb_lock);\r\nerr = cn_netlink_send(m, 0, GFP_KERNEL);\r\nif (err == -ESRCH) {\r\nerr = uvesafb_helper_start();\r\nif (err) {\r\nprintk(KERN_ERR "uvesafb: failed to execute %s\n",\r\nv86d_path);\r\nprintk(KERN_ERR "uvesafb: make sure that the v86d "\r\n"helper is installed and executable\n");\r\n} else {\r\nv86d_started = 1;\r\nerr = cn_netlink_send(m, 0, gfp_any());\r\nif (err == -ENOBUFS)\r\nerr = 0;\r\n}\r\n} else if (err == -ENOBUFS)\r\nerr = 0;\r\nif (!err && !(task->t.flags & TF_EXIT))\r\nerr = !wait_for_completion_timeout(task->done,\r\nmsecs_to_jiffies(UVESAFB_TIMEOUT));\r\nmutex_lock(&uvfb_lock);\r\nuvfb_tasks[seq] = NULL;\r\nmutex_unlock(&uvfb_lock);\r\nseq++;\r\nif (seq >= UVESAFB_TASKS_MAX)\r\nseq = 0;\r\nout:\r\nkfree(m);\r\nreturn err;\r\n}\r\nstatic void uvesafb_free(struct uvesafb_ktask *task)\r\n{\r\nif (task) {\r\nif (task->done)\r\nkfree(task->done);\r\nkfree(task);\r\n}\r\n}\r\nstatic void uvesafb_reset(struct uvesafb_ktask *task)\r\n{\r\nstruct completion *cpl = task->done;\r\nmemset(task, 0, sizeof(*task));\r\ntask->done = cpl;\r\n}\r\nstatic struct uvesafb_ktask *uvesafb_prep(void)\r\n{\r\nstruct uvesafb_ktask *task;\r\ntask = kzalloc(sizeof(*task), GFP_KERNEL);\r\nif (task) {\r\ntask->done = kzalloc(sizeof(*task->done), GFP_KERNEL);\r\nif (!task->done) {\r\nkfree(task);\r\ntask = NULL;\r\n}\r\n}\r\nreturn task;\r\n}\r\nstatic void uvesafb_setup_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info, struct vbe_mode_ib *mode)\r\n{\r\nstruct uvesafb_par *par = info->par;\r\nvar->vmode = FB_VMODE_NONINTERLACED;\r\nvar->sync = FB_SYNC_VERT_HIGH_ACT;\r\nvar->xres = mode->x_res;\r\nvar->yres = mode->y_res;\r\nvar->xres_virtual = mode->x_res;\r\nvar->yres_virtual = (par->ypan) ?\r\ninfo->fix.smem_len / mode->bytes_per_scan_line :\r\nmode->y_res;\r\nvar->xoffset = 0;\r\nvar->yoffset = 0;\r\nvar->bits_per_pixel = mode->bits_per_pixel;\r\nif (var->bits_per_pixel == 15)\r\nvar->bits_per_pixel = 16;\r\nif (var->bits_per_pixel > 8) {\r\nvar->red.offset = mode->red_off;\r\nvar->red.length = mode->red_len;\r\nvar->green.offset = mode->green_off;\r\nvar->green.length = mode->green_len;\r\nvar->blue.offset = mode->blue_off;\r\nvar->blue.length = mode->blue_len;\r\nvar->transp.offset = mode->rsvd_off;\r\nvar->transp.length = mode->rsvd_len;\r\n} else {\r\nvar->red.offset = 0;\r\nvar->green.offset = 0;\r\nvar->blue.offset = 0;\r\nvar->transp.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nvar->transp.length = 0;\r\n}\r\n}\r\nstatic int uvesafb_vbe_find_mode(struct uvesafb_par *par,\r\nint xres, int yres, int depth, unsigned char flags)\r\n{\r\nint i, match = -1, h = 0, d = 0x7fffffff;\r\nfor (i = 0; i < par->vbe_modes_cnt; i++) {\r\nh = abs(par->vbe_modes[i].x_res - xres) +\r\nabs(par->vbe_modes[i].y_res - yres) +\r\nabs(depth - par->vbe_modes[i].depth);\r\nif (h == 0)\r\nreturn i;\r\nif (h < d || (h == d && par->vbe_modes[i].depth > depth)) {\r\nd = h;\r\nmatch = i;\r\n}\r\n}\r\ni = 1;\r\nif (flags & UVESAFB_EXACT_DEPTH &&\r\npar->vbe_modes[match].depth != depth)\r\ni = 0;\r\nif (flags & UVESAFB_EXACT_RES && d > 24)\r\ni = 0;\r\nif (i != 0)\r\nreturn match;\r\nelse\r\nreturn -1;\r\n}\r\nstatic u8 *uvesafb_vbe_state_save(struct uvesafb_par *par)\r\n{\r\nstruct uvesafb_ktask *task;\r\nu8 *state;\r\nint err;\r\nif (!par->vbe_state_size)\r\nreturn NULL;\r\nstate = kmalloc(par->vbe_state_size, GFP_KERNEL);\r\nif (!state)\r\nreturn ERR_PTR(-ENOMEM);\r\ntask = uvesafb_prep();\r\nif (!task) {\r\nkfree(state);\r\nreturn NULL;\r\n}\r\ntask->t.regs.eax = 0x4f04;\r\ntask->t.regs.ecx = 0x000f;\r\ntask->t.regs.edx = 0x0001;\r\ntask->t.flags = TF_BUF_RET | TF_BUF_ESBX;\r\ntask->t.buf_len = par->vbe_state_size;\r\ntask->buf = state;\r\nerr = uvesafb_exec(task);\r\nif (err || (task->t.regs.eax & 0xffff) != 0x004f) {\r\nprintk(KERN_WARNING "uvesafb: VBE get state call "\r\n"failed (eax=0x%x, err=%d)\n",\r\ntask->t.regs.eax, err);\r\nkfree(state);\r\nstate = NULL;\r\n}\r\nuvesafb_free(task);\r\nreturn state;\r\n}\r\nstatic void uvesafb_vbe_state_restore(struct uvesafb_par *par, u8 *state_buf)\r\n{\r\nstruct uvesafb_ktask *task;\r\nint err;\r\nif (!state_buf)\r\nreturn;\r\ntask = uvesafb_prep();\r\nif (!task)\r\nreturn;\r\ntask->t.regs.eax = 0x4f04;\r\ntask->t.regs.ecx = 0x000f;\r\ntask->t.regs.edx = 0x0002;\r\ntask->t.buf_len = par->vbe_state_size;\r\ntask->t.flags = TF_BUF_ESBX;\r\ntask->buf = state_buf;\r\nerr = uvesafb_exec(task);\r\nif (err || (task->t.regs.eax & 0xffff) != 0x004f)\r\nprintk(KERN_WARNING "uvesafb: VBE state restore call "\r\n"failed (eax=0x%x, err=%d)\n",\r\ntask->t.regs.eax, err);\r\nuvesafb_free(task);\r\n}\r\nstatic int uvesafb_vbe_getinfo(struct uvesafb_ktask *task,\r\nstruct uvesafb_par *par)\r\n{\r\nint err;\r\ntask->t.regs.eax = 0x4f00;\r\ntask->t.flags = TF_VBEIB;\r\ntask->t.buf_len = sizeof(struct vbe_ib);\r\ntask->buf = &par->vbe_ib;\r\nstrncpy(par->vbe_ib.vbe_signature, "VBE2", 4);\r\nerr = uvesafb_exec(task);\r\nif (err || (task->t.regs.eax & 0xffff) != 0x004f) {\r\nprintk(KERN_ERR "uvesafb: Getting VBE info block failed "\r\n"(eax=0x%x, err=%d)\n", (u32)task->t.regs.eax,\r\nerr);\r\nreturn -EINVAL;\r\n}\r\nif (par->vbe_ib.vbe_version < 0x0200) {\r\nprintk(KERN_ERR "uvesafb: Sorry, pre-VBE 2.0 cards are "\r\n"not supported.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!par->vbe_ib.mode_list_ptr) {\r\nprintk(KERN_ERR "uvesafb: Missing mode list!\n");\r\nreturn -EINVAL;\r\n}\r\nprintk(KERN_INFO "uvesafb: ");\r\nif (par->vbe_ib.oem_vendor_name_ptr)\r\nprintk("%s, ",\r\n((char *)task->buf) + par->vbe_ib.oem_vendor_name_ptr);\r\nif (par->vbe_ib.oem_product_name_ptr)\r\nprintk("%s, ",\r\n((char *)task->buf) + par->vbe_ib.oem_product_name_ptr);\r\nif (par->vbe_ib.oem_product_rev_ptr)\r\nprintk("%s, ",\r\n((char *)task->buf) + par->vbe_ib.oem_product_rev_ptr);\r\nif (par->vbe_ib.oem_string_ptr)\r\nprintk("OEM: %s, ",\r\n((char *)task->buf) + par->vbe_ib.oem_string_ptr);\r\nprintk("VBE v%d.%d\n", ((par->vbe_ib.vbe_version & 0xff00) >> 8),\r\npar->vbe_ib.vbe_version & 0xff);\r\nreturn 0;\r\n}\r\nstatic int uvesafb_vbe_getmodes(struct uvesafb_ktask *task,\r\nstruct uvesafb_par *par)\r\n{\r\nint off = 0, err;\r\nu16 *mode;\r\npar->vbe_modes_cnt = 0;\r\nmode = (u16 *) (((u8 *)&par->vbe_ib) + par->vbe_ib.mode_list_ptr);\r\nwhile (*mode != 0xffff) {\r\npar->vbe_modes_cnt++;\r\nmode++;\r\n}\r\npar->vbe_modes = kzalloc(sizeof(struct vbe_mode_ib) *\r\npar->vbe_modes_cnt, GFP_KERNEL);\r\nif (!par->vbe_modes)\r\nreturn -ENOMEM;\r\nmode = (u16 *) (((u8 *)&par->vbe_ib) + par->vbe_ib.mode_list_ptr);\r\nwhile (*mode != 0xffff) {\r\nstruct vbe_mode_ib *mib;\r\nuvesafb_reset(task);\r\ntask->t.regs.eax = 0x4f01;\r\ntask->t.regs.ecx = (u32) *mode;\r\ntask->t.flags = TF_BUF_RET | TF_BUF_ESDI;\r\ntask->t.buf_len = sizeof(struct vbe_mode_ib);\r\ntask->buf = par->vbe_modes + off;\r\nerr = uvesafb_exec(task);\r\nif (err || (task->t.regs.eax & 0xffff) != 0x004f) {\r\nprintk(KERN_WARNING "uvesafb: Getting mode info block "\r\n"for mode 0x%x failed (eax=0x%x, err=%d)\n",\r\n*mode, (u32)task->t.regs.eax, err);\r\nmode++;\r\npar->vbe_modes_cnt--;\r\ncontinue;\r\n}\r\nmib = task->buf;\r\nmib->mode_id = *mode;\r\nif ((mib->mode_attr & VBE_MODE_MASK) == VBE_MODE_MASK &&\r\nmib->bits_per_pixel >= 8)\r\noff++;\r\nelse\r\npar->vbe_modes_cnt--;\r\nmode++;\r\nmib->depth = mib->red_len + mib->green_len + mib->blue_len;\r\nif (mib->depth == 0 || (mib->depth == 24 &&\r\nmib->bits_per_pixel == 32))\r\nmib->depth = mib->bits_per_pixel;\r\n}\r\nif (par->vbe_modes_cnt > 0)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int uvesafb_vbe_getpmi(struct uvesafb_ktask *task,\r\nstruct uvesafb_par *par)\r\n{\r\nint i, err;\r\nuvesafb_reset(task);\r\ntask->t.regs.eax = 0x4f0a;\r\ntask->t.regs.ebx = 0x0;\r\nerr = uvesafb_exec(task);\r\nif ((task->t.regs.eax & 0xffff) != 0x4f || task->t.regs.es < 0xc000) {\r\npar->pmi_setpal = par->ypan = 0;\r\n} else {\r\npar->pmi_base = (u16 *)phys_to_virt(((u32)task->t.regs.es << 4)\r\n+ task->t.regs.edi);\r\npar->pmi_start = (u8 *)par->pmi_base + par->pmi_base[1];\r\npar->pmi_pal = (u8 *)par->pmi_base + par->pmi_base[2];\r\nprintk(KERN_INFO "uvesafb: protected mode interface info at "\r\n"%04x:%04x\n",\r\n(u16)task->t.regs.es, (u16)task->t.regs.edi);\r\nprintk(KERN_INFO "uvesafb: pmi: set display start = %p, "\r\n"set palette = %p\n", par->pmi_start,\r\npar->pmi_pal);\r\nif (par->pmi_base[3]) {\r\nprintk(KERN_INFO "uvesafb: pmi: ports = ");\r\nfor (i = par->pmi_base[3]/2;\r\npar->pmi_base[i] != 0xffff; i++)\r\nprintk("%x ", par->pmi_base[i]);\r\nprintk("\n");\r\nif (par->pmi_base[i] != 0xffff) {\r\nprintk(KERN_INFO "uvesafb: can't handle memory"\r\n" requests, pmi disabled\n");\r\npar->ypan = par->pmi_setpal = 0;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int uvesafb_is_valid_mode(struct fb_videomode *mode,\r\nstruct fb_info *info)\r\n{\r\nif (info->monspecs.gtf) {\r\nfb_videomode_to_var(&info->var, mode);\r\nif (fb_validate_mode(&info->var, info))\r\nreturn 0;\r\n}\r\nif (uvesafb_vbe_find_mode(info->par, mode->xres, mode->yres, 8,\r\nUVESAFB_EXACT_RES) == -1)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int uvesafb_vbe_getedid(struct uvesafb_ktask *task, struct fb_info *info)\r\n{\r\nstruct uvesafb_par *par = info->par;\r\nint err = 0;\r\nif (noedid || par->vbe_ib.vbe_version < 0x0300)\r\nreturn -EINVAL;\r\ntask->t.regs.eax = 0x4f15;\r\ntask->t.regs.ebx = 0;\r\ntask->t.regs.ecx = 0;\r\ntask->t.buf_len = 0;\r\ntask->t.flags = 0;\r\nerr = uvesafb_exec(task);\r\nif ((task->t.regs.eax & 0xffff) != 0x004f || err)\r\nreturn -EINVAL;\r\nif ((task->t.regs.ebx & 0x3) == 3) {\r\nprintk(KERN_INFO "uvesafb: VBIOS/hardware supports both "\r\n"DDC1 and DDC2 transfers\n");\r\n} else if ((task->t.regs.ebx & 0x3) == 2) {\r\nprintk(KERN_INFO "uvesafb: VBIOS/hardware supports DDC2 "\r\n"transfers\n");\r\n} else if ((task->t.regs.ebx & 0x3) == 1) {\r\nprintk(KERN_INFO "uvesafb: VBIOS/hardware supports DDC1 "\r\n"transfers\n");\r\n} else {\r\nprintk(KERN_INFO "uvesafb: VBIOS/hardware doesn't support "\r\n"DDC transfers\n");\r\nreturn -EINVAL;\r\n}\r\ntask->t.regs.eax = 0x4f15;\r\ntask->t.regs.ebx = 1;\r\ntask->t.regs.ecx = task->t.regs.edx = 0;\r\ntask->t.flags = TF_BUF_RET | TF_BUF_ESDI;\r\ntask->t.buf_len = EDID_LENGTH;\r\ntask->buf = kzalloc(EDID_LENGTH, GFP_KERNEL);\r\nif (!task->buf)\r\nreturn -ENOMEM;\r\nerr = uvesafb_exec(task);\r\nif ((task->t.regs.eax & 0xffff) == 0x004f && !err) {\r\nfb_edid_to_monspecs(task->buf, &info->monspecs);\r\nif (info->monspecs.vfmax && info->monspecs.hfmax) {\r\nif (info->monspecs.dclkmax == 0)\r\ninfo->monspecs.dclkmax = 300 * 1000000;\r\ninfo->monspecs.gtf = 1;\r\n}\r\n} else {\r\nerr = -EINVAL;\r\n}\r\nkfree(task->buf);\r\nreturn err;\r\n}\r\nstatic void uvesafb_vbe_getmonspecs(struct uvesafb_ktask *task,\r\nstruct fb_info *info)\r\n{\r\nstruct uvesafb_par *par = info->par;\r\nint i;\r\nmemset(&info->monspecs, 0, sizeof(info->monspecs));\r\nif (uvesafb_vbe_getedid(task, info)) {\r\ninfo->monspecs.gtf = 0;\r\npar->nocrtc = 1;\r\n}\r\nif (maxclk)\r\ninfo->monspecs.dclkmax = maxclk * 1000000;\r\nif (maxvf)\r\ninfo->monspecs.vfmax = maxvf;\r\nif (maxhf)\r\ninfo->monspecs.hfmax = maxhf * 1000;\r\nif (info->monspecs.gtf == 0 && maxclk && maxvf && maxhf) {\r\ninfo->monspecs.dclkmin = 0;\r\ninfo->monspecs.vfmin = 60;\r\ninfo->monspecs.hfmin = 29000;\r\ninfo->monspecs.gtf = 1;\r\npar->nocrtc = 0;\r\n}\r\nif (info->monspecs.gtf)\r\nprintk(KERN_INFO\r\n"uvesafb: monitor limits: vf = %d Hz, hf = %d kHz, "\r\n"clk = %d MHz\n", info->monspecs.vfmax,\r\n(int)(info->monspecs.hfmax / 1000),\r\n(int)(info->monspecs.dclkmax / 1000000));\r\nelse\r\nprintk(KERN_INFO "uvesafb: no monitor limits have been set, "\r\n"default refresh rate will be used\n");\r\nfor (i = 0; i < par->vbe_modes_cnt; i++) {\r\nstruct fb_var_screeninfo var;\r\nstruct vbe_mode_ib *mode;\r\nstruct fb_videomode vmode;\r\nmode = &par->vbe_modes[i];\r\nmemset(&var, 0, sizeof(var));\r\nvar.xres = mode->x_res;\r\nvar.yres = mode->y_res;\r\nfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON, 60, &var, info);\r\nfb_var_to_videomode(&vmode, &var);\r\nfb_add_videomode(&vmode, &info->modelist);\r\n}\r\nfor (i = 0; i < VESA_MODEDB_SIZE; i++) {\r\nif (uvesafb_is_valid_mode((struct fb_videomode *)\r\n&vesa_modes[i], info))\r\nfb_add_videomode(&vesa_modes[i], &info->modelist);\r\n}\r\nfor (i = 0; i < info->monspecs.modedb_len; i++) {\r\nif (uvesafb_is_valid_mode(&info->monspecs.modedb[i], info))\r\nfb_add_videomode(&info->monspecs.modedb[i],\r\n&info->modelist);\r\n}\r\nreturn;\r\n}\r\nstatic void uvesafb_vbe_getstatesize(struct uvesafb_ktask *task,\r\nstruct uvesafb_par *par)\r\n{\r\nint err;\r\nuvesafb_reset(task);\r\ntask->t.regs.eax = 0x4f04;\r\ntask->t.regs.ecx = 0x000f;\r\ntask->t.regs.edx = 0x0000;\r\ntask->t.flags = 0;\r\nerr = uvesafb_exec(task);\r\nif (err || (task->t.regs.eax & 0xffff) != 0x004f) {\r\nprintk(KERN_WARNING "uvesafb: VBE state buffer size "\r\n"cannot be determined (eax=0x%x, err=%d)\n",\r\ntask->t.regs.eax, err);\r\npar->vbe_state_size = 0;\r\nreturn;\r\n}\r\npar->vbe_state_size = 64 * (task->t.regs.ebx & 0xffff);\r\n}\r\nstatic int uvesafb_vbe_init(struct fb_info *info)\r\n{\r\nstruct uvesafb_ktask *task = NULL;\r\nstruct uvesafb_par *par = info->par;\r\nint err;\r\ntask = uvesafb_prep();\r\nif (!task)\r\nreturn -ENOMEM;\r\nerr = uvesafb_vbe_getinfo(task, par);\r\nif (err)\r\ngoto out;\r\nerr = uvesafb_vbe_getmodes(task, par);\r\nif (err)\r\ngoto out;\r\npar->nocrtc = nocrtc;\r\n#ifdef CONFIG_X86_32\r\npar->pmi_setpal = pmi_setpal;\r\npar->ypan = ypan;\r\nif (par->pmi_setpal || par->ypan) {\r\nif (__supported_pte_mask & _PAGE_NX) {\r\npar->pmi_setpal = par->ypan = 0;\r\nprintk(KERN_WARNING "uvesafb: NX protection is active, "\r\n"better not use the PMI.\n");\r\n} else {\r\nuvesafb_vbe_getpmi(task, par);\r\n}\r\n}\r\n#else\r\npar->pmi_setpal = par->ypan = 0;\r\n#endif\r\nINIT_LIST_HEAD(&info->modelist);\r\nuvesafb_vbe_getmonspecs(task, info);\r\nuvesafb_vbe_getstatesize(task, par);\r\nout: uvesafb_free(task);\r\nreturn err;\r\n}\r\nstatic int uvesafb_vbe_init_mode(struct fb_info *info)\r\n{\r\nstruct list_head *pos;\r\nstruct fb_modelist *modelist;\r\nstruct fb_videomode *mode;\r\nstruct uvesafb_par *par = info->par;\r\nint i, modeid;\r\nif (vbemode) {\r\nfor (i = 0; i < par->vbe_modes_cnt; i++) {\r\nif (par->vbe_modes[i].mode_id == vbemode) {\r\nmodeid = i;\r\nuvesafb_setup_var(&info->var, info,\r\n&par->vbe_modes[modeid]);\r\nfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON, 60,\r\n&info->var, info);\r\ninfo->var.pixclock = 0;\r\ngoto gotmode;\r\n}\r\n}\r\nprintk(KERN_INFO "uvesafb: requested VBE mode 0x%x is "\r\n"unavailable\n", vbemode);\r\nvbemode = 0;\r\n}\r\ni = 0;\r\nlist_for_each(pos, &info->modelist)\r\ni++;\r\nmode = kzalloc(i * sizeof(*mode), GFP_KERNEL);\r\nif (mode) {\r\ni = 0;\r\nlist_for_each(pos, &info->modelist) {\r\nmodelist = list_entry(pos, struct fb_modelist, list);\r\nmode[i] = modelist->mode;\r\ni++;\r\n}\r\nif (!mode_option)\r\nmode_option = UVESAFB_DEFAULT_MODE;\r\ni = fb_find_mode(&info->var, info, mode_option, mode, i,\r\nNULL, 8);\r\nkfree(mode);\r\n}\r\nif (i == 0) {\r\ninfo->var.xres = 640;\r\ninfo->var.yres = 480;\r\nmode = (struct fb_videomode *)\r\nfb_find_best_mode(&info->var, &info->modelist);\r\nif (mode) {\r\nfb_videomode_to_var(&info->var, mode);\r\n} else {\r\nmodeid = par->vbe_modes[0].mode_id;\r\nuvesafb_setup_var(&info->var, info,\r\n&par->vbe_modes[modeid]);\r\nfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON, 60,\r\n&info->var, info);\r\ngoto gotmode;\r\n}\r\n}\r\nmodeid = uvesafb_vbe_find_mode(par, info->var.xres, info->var.yres,\r\ninfo->var.bits_per_pixel, UVESAFB_EXACT_RES);\r\nif (modeid == -1)\r\nreturn -EINVAL;\r\nuvesafb_setup_var(&info->var, info, &par->vbe_modes[modeid]);\r\ngotmode:\r\nif (par->vbe_ib.vbe_version < 0x0300 || par->nocrtc)\r\nfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON, 60,\r\n&info->var, info);\r\nreturn modeid;\r\n}\r\nstatic int uvesafb_setpalette(struct uvesafb_pal_entry *entries, int count,\r\nint start, struct fb_info *info)\r\n{\r\nstruct uvesafb_ktask *task;\r\n#ifdef CONFIG_X86\r\nstruct uvesafb_par *par = info->par;\r\nint i = par->mode_idx;\r\n#endif\r\nint err = 0;\r\nif (start + count > 256)\r\nreturn -EINVAL;\r\n#ifdef CONFIG_X86\r\nif (i >= 0 && i < par->vbe_modes_cnt &&\r\npar->vbe_modes[i].mode_attr & VBE_MODE_VGACOMPAT) {\r\nfor (i = 0; i < count; i++) {\r\noutb_p(start + i, dac_reg);\r\noutb_p(entries[i].red, dac_val);\r\noutb_p(entries[i].green, dac_val);\r\noutb_p(entries[i].blue, dac_val);\r\n}\r\n}\r\n#ifdef CONFIG_X86_32\r\nelse if (par->pmi_setpal) {\r\n__asm__ __volatile__(\r\n"call *(%%esi)"\r\n:\r\n: "a" (0x4f09),\r\n"b" (0),\r\n"c" (count),\r\n"d" (start),\r\n"D" (entries),\r\n"S" (&par->pmi_pal));\r\n}\r\n#endif\r\nelse\r\n#endif\r\n{\r\ntask = uvesafb_prep();\r\nif (!task)\r\nreturn -ENOMEM;\r\ntask->t.regs.eax = 0x4f09;\r\ntask->t.regs.ebx = 0x0;\r\ntask->t.regs.ecx = count;\r\ntask->t.regs.edx = start;\r\ntask->t.flags = TF_BUF_ESDI;\r\ntask->t.buf_len = sizeof(struct uvesafb_pal_entry) * count;\r\ntask->buf = entries;\r\nerr = uvesafb_exec(task);\r\nif ((task->t.regs.eax & 0xffff) != 0x004f)\r\nerr = 1;\r\nuvesafb_free(task);\r\n}\r\nreturn err;\r\n}\r\nstatic int uvesafb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct uvesafb_pal_entry entry;\r\nint shift = 16 - dac_width;\r\nint err = 0;\r\nif (regno >= info->cmap.len)\r\nreturn -EINVAL;\r\nif (info->var.bits_per_pixel == 8) {\r\nentry.red = red >> shift;\r\nentry.green = green >> shift;\r\nentry.blue = blue >> shift;\r\nentry.pad = 0;\r\nerr = uvesafb_setpalette(&entry, 1, regno, info);\r\n} else if (regno < 16) {\r\nswitch (info->var.bits_per_pixel) {\r\ncase 16:\r\nif (info->var.red.offset == 10) {\r\n((u32 *) (info->pseudo_palette))[regno] =\r\n((red & 0xf800) >> 1) |\r\n((green & 0xf800) >> 6) |\r\n((blue & 0xf800) >> 11);\r\n} else {\r\n((u32 *) (info->pseudo_palette))[regno] =\r\n((red & 0xf800) ) |\r\n((green & 0xfc00) >> 5) |\r\n((blue & 0xf800) >> 11);\r\n}\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\n((u32 *)(info->pseudo_palette))[regno] =\r\n(red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset);\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\r\n{\r\nstruct uvesafb_pal_entry *entries;\r\nint shift = 16 - dac_width;\r\nint i, err = 0;\r\nif (info->var.bits_per_pixel == 8) {\r\nif (cmap->start + cmap->len > info->cmap.start +\r\ninfo->cmap.len || cmap->start < info->cmap.start)\r\nreturn -EINVAL;\r\nentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\r\nif (!entries)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < cmap->len; i++) {\r\nentries[i].red = cmap->red[i] >> shift;\r\nentries[i].green = cmap->green[i] >> shift;\r\nentries[i].blue = cmap->blue[i] >> shift;\r\nentries[i].pad = 0;\r\n}\r\nerr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\r\nkfree(entries);\r\n} else {\r\nfor (i = 0; i < cmap->len; i++) {\r\nerr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\r\ncmap->green[i], cmap->blue[i],\r\n0, info);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int uvesafb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\n#ifdef CONFIG_X86_32\r\nint offset;\r\nstruct uvesafb_par *par = info->par;\r\noffset = (var->yoffset * info->fix.line_length + var->xoffset) / 4;\r\nif (par->pmi_start) {\r\n__asm__ __volatile__(\r\n"call *(%%edi)"\r\n:\r\n: "a" (0x4f07),\r\n"b" (0),\r\n"c" (offset),\r\n"d" (offset >> 16),\r\n"D" (&par->pmi_start));\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int uvesafb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct uvesafb_ktask *task;\r\nint err = 1;\r\n#ifdef CONFIG_X86\r\nstruct uvesafb_par *par = info->par;\r\nif (par->vbe_ib.capabilities & VBE_CAP_VGACOMPAT) {\r\nint loop = 10000;\r\nu8 seq = 0, crtc17 = 0;\r\nif (blank == FB_BLANK_POWERDOWN) {\r\nseq = 0x20;\r\ncrtc17 = 0x00;\r\nerr = 0;\r\n} else {\r\nseq = 0x00;\r\ncrtc17 = 0x80;\r\nerr = (blank == FB_BLANK_UNBLANK) ? 0 : -EINVAL;\r\n}\r\nvga_wseq(NULL, 0x00, 0x01);\r\nseq |= vga_rseq(NULL, 0x01) & ~0x20;\r\nvga_wseq(NULL, 0x00, seq);\r\ncrtc17 |= vga_rcrt(NULL, 0x17) & ~0x80;\r\nwhile (loop--);\r\nvga_wcrt(NULL, 0x17, crtc17);\r\nvga_wseq(NULL, 0x00, 0x03);\r\n} else\r\n#endif\r\n{\r\ntask = uvesafb_prep();\r\nif (!task)\r\nreturn -ENOMEM;\r\ntask->t.regs.eax = 0x4f10;\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\ntask->t.regs.ebx = 0x0001;\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\ntask->t.regs.ebx = 0x0101;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\ntask->t.regs.ebx = 0x0401;\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nerr = uvesafb_exec(task);\r\nif (err || (task->t.regs.eax & 0xffff) != 0x004f)\r\nerr = 1;\r\nout: uvesafb_free(task);\r\n}\r\nreturn err;\r\n}\r\nstatic int uvesafb_open(struct fb_info *info, int user)\r\n{\r\nstruct uvesafb_par *par = info->par;\r\nint cnt = atomic_read(&par->ref_count);\r\nu8 *buf = NULL;\r\nif (!cnt && par->vbe_state_size) {\r\nbuf = uvesafb_vbe_state_save(par);\r\nif (IS_ERR(buf)) {\r\nprintk(KERN_WARNING "uvesafb: save hardware state"\r\n"failed, error code is %ld!\n", PTR_ERR(buf));\r\n} else {\r\npar->vbe_state_orig = buf;\r\n}\r\n}\r\natomic_inc(&par->ref_count);\r\nreturn 0;\r\n}\r\nstatic int uvesafb_release(struct fb_info *info, int user)\r\n{\r\nstruct uvesafb_ktask *task = NULL;\r\nstruct uvesafb_par *par = info->par;\r\nint cnt = atomic_read(&par->ref_count);\r\nif (!cnt)\r\nreturn -EINVAL;\r\nif (cnt != 1)\r\ngoto out;\r\ntask = uvesafb_prep();\r\nif (!task)\r\ngoto out;\r\ntask->t.regs.eax = 0x0003;\r\nuvesafb_exec(task);\r\nuvesafb_vbe_state_restore(par, par->vbe_state_orig);\r\nout:\r\natomic_dec(&par->ref_count);\r\nif (task)\r\nuvesafb_free(task);\r\nreturn 0;\r\n}\r\nstatic int uvesafb_set_par(struct fb_info *info)\r\n{\r\nstruct uvesafb_par *par = info->par;\r\nstruct uvesafb_ktask *task = NULL;\r\nstruct vbe_crtc_ib *crtc = NULL;\r\nstruct vbe_mode_ib *mode = NULL;\r\nint i, err = 0, depth = info->var.bits_per_pixel;\r\nif (depth > 8 && depth != 32)\r\ndepth = info->var.red.length + info->var.green.length +\r\ninfo->var.blue.length;\r\ni = uvesafb_vbe_find_mode(par, info->var.xres, info->var.yres, depth,\r\nUVESAFB_EXACT_RES | UVESAFB_EXACT_DEPTH);\r\nif (i >= 0)\r\nmode = &par->vbe_modes[i];\r\nelse\r\nreturn -EINVAL;\r\ntask = uvesafb_prep();\r\nif (!task)\r\nreturn -ENOMEM;\r\nsetmode:\r\ntask->t.regs.eax = 0x4f02;\r\ntask->t.regs.ebx = mode->mode_id | 0x4000;\r\nif (par->vbe_ib.vbe_version >= 0x0300 && !par->nocrtc &&\r\ninfo->var.pixclock != 0) {\r\ntask->t.regs.ebx |= 0x0800;\r\ntask->t.flags = TF_BUF_ESDI;\r\ncrtc = kzalloc(sizeof(struct vbe_crtc_ib), GFP_KERNEL);\r\nif (!crtc) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\ncrtc->horiz_start = info->var.xres + info->var.right_margin;\r\ncrtc->horiz_end = crtc->horiz_start + info->var.hsync_len;\r\ncrtc->horiz_total = crtc->horiz_end + info->var.left_margin;\r\ncrtc->vert_start = info->var.yres + info->var.lower_margin;\r\ncrtc->vert_end = crtc->vert_start + info->var.vsync_len;\r\ncrtc->vert_total = crtc->vert_end + info->var.upper_margin;\r\ncrtc->pixel_clock = PICOS2KHZ(info->var.pixclock) * 1000;\r\ncrtc->refresh_rate = (u16)(100 * (crtc->pixel_clock /\r\n(crtc->vert_total * crtc->horiz_total)));\r\nif (info->var.vmode & FB_VMODE_DOUBLE)\r\ncrtc->flags |= 0x1;\r\nif (info->var.vmode & FB_VMODE_INTERLACED)\r\ncrtc->flags |= 0x2;\r\nif (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))\r\ncrtc->flags |= 0x4;\r\nif (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))\r\ncrtc->flags |= 0x8;\r\nmemcpy(&par->crtc, crtc, sizeof(*crtc));\r\n} else {\r\nmemset(&par->crtc, 0, sizeof(*crtc));\r\n}\r\ntask->t.buf_len = sizeof(struct vbe_crtc_ib);\r\ntask->buf = &par->crtc;\r\nerr = uvesafb_exec(task);\r\nif (err || (task->t.regs.eax & 0xffff) != 0x004f) {\r\nif (crtc != NULL) {\r\nprintk(KERN_WARNING "uvesafb: mode switch failed "\r\n"(eax=0x%x, err=%d). Trying again with "\r\n"default timings.\n", task->t.regs.eax, err);\r\nuvesafb_reset(task);\r\nkfree(crtc);\r\ncrtc = NULL;\r\ninfo->var.pixclock = 0;\r\ngoto setmode;\r\n} else {\r\nprintk(KERN_ERR "uvesafb: mode switch failed (eax="\r\n"0x%x, err=%d)\n", task->t.regs.eax, err);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\npar->mode_idx = i;\r\nif (par->vbe_ib.capabilities & VBE_CAP_CAN_SWITCH_DAC &&\r\nmode->bits_per_pixel <= 8) {\r\nuvesafb_reset(task);\r\ntask->t.regs.eax = 0x4f08;\r\ntask->t.regs.ebx = 0x0800;\r\nerr = uvesafb_exec(task);\r\nif (err || (task->t.regs.eax & 0xffff) != 0x004f ||\r\n((task->t.regs.ebx & 0xff00) >> 8) != 8) {\r\ndac_width = 6;\r\n} else {\r\ndac_width = 8;\r\n}\r\n}\r\ninfo->fix.visual = (info->var.bits_per_pixel == 8) ?\r\nFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\r\ninfo->fix.line_length = mode->bytes_per_scan_line;\r\nout: if (crtc != NULL)\r\nkfree(crtc);\r\nuvesafb_free(task);\r\nreturn err;\r\n}\r\nstatic void uvesafb_check_limits(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nconst struct fb_videomode *mode;\r\nstruct uvesafb_par *par = info->par;\r\nif (!var->pixclock)\r\nreturn;\r\nif (par->vbe_ib.vbe_version < 0x0300) {\r\nfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON, 60, var, info);\r\nreturn;\r\n}\r\nif (!fb_validate_mode(var, info))\r\nreturn;\r\nmode = fb_find_best_mode(var, &info->modelist);\r\nif (mode) {\r\nif (mode->xres == var->xres && mode->yres == var->yres &&\r\n!(mode->vmode & (FB_VMODE_INTERLACED | FB_VMODE_DOUBLE))) {\r\nfb_videomode_to_var(var, mode);\r\nreturn;\r\n}\r\n}\r\nif (info->monspecs.gtf && !fb_get_mode(FB_MAXTIMINGS, 0, var, info))\r\nreturn;\r\nvar->pixclock = 0;\r\n}\r\nstatic int uvesafb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct uvesafb_par *par = info->par;\r\nstruct vbe_mode_ib *mode = NULL;\r\nint match = -1;\r\nint depth = var->red.length + var->green.length + var->blue.length;\r\nif (depth == 0 || abs(depth - var->bits_per_pixel) >= 8)\r\ndepth = var->bits_per_pixel;\r\nmatch = uvesafb_vbe_find_mode(par, var->xres, var->yres, depth,\r\nUVESAFB_EXACT_RES);\r\nif (match == -1)\r\nreturn -EINVAL;\r\nmode = &par->vbe_modes[match];\r\nuvesafb_setup_var(var, info, mode);\r\nif (var->yres * mode->bytes_per_scan_line > info->fix.smem_len\r\n&& info->fix.smem_len)\r\nreturn -EINVAL;\r\nif ((var->vmode & FB_VMODE_DOUBLE) &&\r\n!(par->vbe_modes[match].mode_attr & 0x100))\r\nvar->vmode &= ~FB_VMODE_DOUBLE;\r\nif ((var->vmode & FB_VMODE_INTERLACED) &&\r\n!(par->vbe_modes[match].mode_attr & 0x200))\r\nvar->vmode &= ~FB_VMODE_INTERLACED;\r\nuvesafb_check_limits(var, info);\r\nvar->xres_virtual = var->xres;\r\nvar->yres_virtual = (par->ypan) ?\r\ninfo->fix.smem_len / mode->bytes_per_scan_line :\r\nvar->yres;\r\nreturn 0;\r\n}\r\nstatic void uvesafb_init_info(struct fb_info *info, struct vbe_mode_ib *mode)\r\n{\r\nunsigned int size_vmode;\r\nunsigned int size_remap;\r\nunsigned int size_total;\r\nstruct uvesafb_par *par = info->par;\r\nint i, h;\r\ninfo->pseudo_palette = ((u8 *)info->par + sizeof(struct uvesafb_par));\r\ninfo->fix = uvesafb_fix;\r\ninfo->fix.ypanstep = par->ypan ? 1 : 0;\r\ninfo->fix.ywrapstep = (par->ypan > 1) ? 1 : 0;\r\nif (!blank)\r\ninfo->fbops->fb_blank = NULL;\r\nsize_remap = 0;\r\nfor (i = 0; i < par->vbe_modes_cnt; i++) {\r\nh = par->vbe_modes[i].bytes_per_scan_line *\r\npar->vbe_modes[i].y_res;\r\nif (h > size_remap)\r\nsize_remap = h;\r\n}\r\nsize_remap *= 2;\r\nif (mode != NULL) {\r\nsize_vmode = info->var.yres * mode->bytes_per_scan_line;\r\n} else {\r\nsize_vmode = info->var.yres * info->var.xres *\r\n((info->var.bits_per_pixel + 7) >> 3);\r\n}\r\nsize_total = par->vbe_ib.total_memory * 65536;\r\nif (vram_total)\r\nsize_total = vram_total * 1024 * 1024;\r\nif (size_total < size_vmode)\r\nsize_total = size_vmode;\r\nif (vram_remap)\r\nsize_remap = vram_remap * 1024 * 1024;\r\nif (size_remap < size_vmode)\r\nsize_remap = size_vmode;\r\nif (size_remap > size_total)\r\nsize_remap = size_total;\r\ninfo->fix.smem_len = size_remap;\r\ninfo->fix.smem_start = mode->phys_base_ptr;\r\ninfo->var.yres_virtual = info->fix.smem_len /\r\nmode->bytes_per_scan_line;\r\nif (par->ypan && info->var.yres_virtual > info->var.yres) {\r\nprintk(KERN_INFO "uvesafb: scrolling: %s "\r\n"using protected mode interface, "\r\n"yres_virtual=%d\n",\r\n(par->ypan > 1) ? "ywrap" : "ypan",\r\ninfo->var.yres_virtual);\r\n} else {\r\nprintk(KERN_INFO "uvesafb: scrolling: redraw\n");\r\ninfo->var.yres_virtual = info->var.yres;\r\npar->ypan = 0;\r\n}\r\ninfo->flags = FBINFO_FLAG_DEFAULT |\r\n(par->ypan ? FBINFO_HWACCEL_YPAN : 0);\r\nif (!par->ypan)\r\ninfo->fbops->fb_pan_display = NULL;\r\n}\r\nstatic void uvesafb_init_mtrr(struct fb_info *info)\r\n{\r\nstruct uvesafb_par *par = info->par;\r\nif (mtrr && !(info->fix.smem_start & (PAGE_SIZE - 1))) {\r\nint temp_size = info->fix.smem_len;\r\nint rc;\r\ntemp_size = roundup_pow_of_two(temp_size);\r\ndo {\r\nrc = arch_phys_wc_add(info->fix.smem_start, temp_size);\r\ntemp_size >>= 1;\r\n} while (temp_size >= PAGE_SIZE && rc == -EINVAL);\r\nif (rc >= 0)\r\npar->mtrr_handle = rc;\r\n}\r\n}\r\nstatic void uvesafb_ioremap(struct fb_info *info)\r\n{\r\ninfo->screen_base = ioremap_wc(info->fix.smem_start, info->fix.smem_len);\r\n}\r\nstatic ssize_t uvesafb_show_vbe_ver(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\r\nstruct uvesafb_par *par = info->par;\r\nreturn snprintf(buf, PAGE_SIZE, "%.4x\n", par->vbe_ib.vbe_version);\r\n}\r\nstatic ssize_t uvesafb_show_vbe_modes(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\r\nstruct uvesafb_par *par = info->par;\r\nint ret = 0, i;\r\nfor (i = 0; i < par->vbe_modes_cnt && ret < PAGE_SIZE; i++) {\r\nret += snprintf(buf + ret, PAGE_SIZE - ret,\r\n"%dx%d-%d, 0x%.4x\n",\r\npar->vbe_modes[i].x_res, par->vbe_modes[i].y_res,\r\npar->vbe_modes[i].depth, par->vbe_modes[i].mode_id);\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t uvesafb_show_vendor(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\r\nstruct uvesafb_par *par = info->par;\r\nif (par->vbe_ib.oem_vendor_name_ptr)\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", (char *)\r\n(&par->vbe_ib) + par->vbe_ib.oem_vendor_name_ptr);\r\nelse\r\nreturn 0;\r\n}\r\nstatic ssize_t uvesafb_show_product_name(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\r\nstruct uvesafb_par *par = info->par;\r\nif (par->vbe_ib.oem_product_name_ptr)\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", (char *)\r\n(&par->vbe_ib) + par->vbe_ib.oem_product_name_ptr);\r\nelse\r\nreturn 0;\r\n}\r\nstatic ssize_t uvesafb_show_product_rev(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\r\nstruct uvesafb_par *par = info->par;\r\nif (par->vbe_ib.oem_product_rev_ptr)\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", (char *)\r\n(&par->vbe_ib) + par->vbe_ib.oem_product_rev_ptr);\r\nelse\r\nreturn 0;\r\n}\r\nstatic ssize_t uvesafb_show_oem_string(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\r\nstruct uvesafb_par *par = info->par;\r\nif (par->vbe_ib.oem_string_ptr)\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\n(char *)(&par->vbe_ib) + par->vbe_ib.oem_string_ptr);\r\nelse\r\nreturn 0;\r\n}\r\nstatic ssize_t uvesafb_show_nocrtc(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\r\nstruct uvesafb_par *par = info->par;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", par->nocrtc);\r\n}\r\nstatic ssize_t uvesafb_store_nocrtc(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\r\nstruct uvesafb_par *par = info->par;\r\nif (count > 0) {\r\nif (buf[0] == '0')\r\npar->nocrtc = 0;\r\nelse\r\npar->nocrtc = 1;\r\n}\r\nreturn count;\r\n}\r\nstatic int uvesafb_probe(struct platform_device *dev)\r\n{\r\nstruct fb_info *info;\r\nstruct vbe_mode_ib *mode = NULL;\r\nstruct uvesafb_par *par;\r\nint err = 0, i;\r\ninfo = framebuffer_alloc(sizeof(*par) + sizeof(u32) * 256, &dev->dev);\r\nif (!info)\r\nreturn -ENOMEM;\r\npar = info->par;\r\nerr = uvesafb_vbe_init(info);\r\nif (err) {\r\nprintk(KERN_ERR "uvesafb: vbe_init() failed with %d\n", err);\r\ngoto out;\r\n}\r\ninfo->fbops = &uvesafb_ops;\r\ni = uvesafb_vbe_init_mode(info);\r\nif (i < 0) {\r\nerr = -EINVAL;\r\ngoto out;\r\n} else {\r\nmode = &par->vbe_modes[i];\r\n}\r\nif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\r\nerr = -ENXIO;\r\ngoto out;\r\n}\r\nuvesafb_init_info(info, mode);\r\nif (!request_region(0x3c0, 32, "uvesafb")) {\r\nprintk(KERN_ERR "uvesafb: request region 0x3c0-0x3e0 failed\n");\r\nerr = -EIO;\r\ngoto out_mode;\r\n}\r\nif (!request_mem_region(info->fix.smem_start, info->fix.smem_len,\r\n"uvesafb")) {\r\nprintk(KERN_ERR "uvesafb: cannot reserve video memory at "\r\n"0x%lx\n", info->fix.smem_start);\r\nerr = -EIO;\r\ngoto out_reg;\r\n}\r\nuvesafb_init_mtrr(info);\r\nuvesafb_ioremap(info);\r\nif (!info->screen_base) {\r\nprintk(KERN_ERR\r\n"uvesafb: abort, cannot ioremap 0x%x bytes of video "\r\n"memory at 0x%lx\n",\r\ninfo->fix.smem_len, info->fix.smem_start);\r\nerr = -EIO;\r\ngoto out_mem;\r\n}\r\nplatform_set_drvdata(dev, info);\r\nif (register_framebuffer(info) < 0) {\r\nprintk(KERN_ERR\r\n"uvesafb: failed to register framebuffer device\n");\r\nerr = -EINVAL;\r\ngoto out_unmap;\r\n}\r\nprintk(KERN_INFO "uvesafb: framebuffer at 0x%lx, mapped to 0x%p, "\r\n"using %dk, total %dk\n", info->fix.smem_start,\r\ninfo->screen_base, info->fix.smem_len/1024,\r\npar->vbe_ib.total_memory * 64);\r\nprintk(KERN_INFO "fb%d: %s frame buffer device\n", info->node,\r\ninfo->fix.id);\r\nerr = sysfs_create_group(&dev->dev.kobj, &uvesafb_dev_attgrp);\r\nif (err != 0)\r\nprintk(KERN_WARNING "fb%d: failed to register attributes\n",\r\ninfo->node);\r\nreturn 0;\r\nout_unmap:\r\niounmap(info->screen_base);\r\nout_mem:\r\nrelease_mem_region(info->fix.smem_start, info->fix.smem_len);\r\nout_reg:\r\nrelease_region(0x3c0, 32);\r\nout_mode:\r\nif (!list_empty(&info->modelist))\r\nfb_destroy_modelist(&info->modelist);\r\nfb_destroy_modedb(info->monspecs.modedb);\r\nfb_dealloc_cmap(&info->cmap);\r\nout:\r\nif (par->vbe_modes)\r\nkfree(par->vbe_modes);\r\nframebuffer_release(info);\r\nreturn err;\r\n}\r\nstatic int uvesafb_remove(struct platform_device *dev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nif (info) {\r\nstruct uvesafb_par *par = info->par;\r\nsysfs_remove_group(&dev->dev.kobj, &uvesafb_dev_attgrp);\r\nunregister_framebuffer(info);\r\nrelease_region(0x3c0, 32);\r\niounmap(info->screen_base);\r\narch_phys_wc_del(par->mtrr_handle);\r\nrelease_mem_region(info->fix.smem_start, info->fix.smem_len);\r\nfb_destroy_modedb(info->monspecs.modedb);\r\nfb_dealloc_cmap(&info->cmap);\r\nif (par) {\r\nif (par->vbe_modes)\r\nkfree(par->vbe_modes);\r\nif (par->vbe_state_orig)\r\nkfree(par->vbe_state_orig);\r\nif (par->vbe_state_saved)\r\nkfree(par->vbe_state_saved);\r\n}\r\nframebuffer_release(info);\r\n}\r\nreturn 0;\r\n}\r\nstatic int uvesafb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!*this_opt) continue;\r\nif (!strcmp(this_opt, "redraw"))\r\nypan = 0;\r\nelse if (!strcmp(this_opt, "ypan"))\r\nypan = 1;\r\nelse if (!strcmp(this_opt, "ywrap"))\r\nypan = 2;\r\nelse if (!strcmp(this_opt, "vgapal"))\r\npmi_setpal = 0;\r\nelse if (!strcmp(this_opt, "pmipal"))\r\npmi_setpal = 1;\r\nelse if (!strncmp(this_opt, "mtrr:", 5))\r\nmtrr = simple_strtoul(this_opt+5, NULL, 0);\r\nelse if (!strcmp(this_opt, "nomtrr"))\r\nmtrr = 0;\r\nelse if (!strcmp(this_opt, "nocrtc"))\r\nnocrtc = 1;\r\nelse if (!strcmp(this_opt, "noedid"))\r\nnoedid = 1;\r\nelse if (!strcmp(this_opt, "noblank"))\r\nblank = 0;\r\nelse if (!strncmp(this_opt, "vtotal:", 7))\r\nvram_total = simple_strtoul(this_opt + 7, NULL, 0);\r\nelse if (!strncmp(this_opt, "vremap:", 7))\r\nvram_remap = simple_strtoul(this_opt + 7, NULL, 0);\r\nelse if (!strncmp(this_opt, "maxhf:", 6))\r\nmaxhf = simple_strtoul(this_opt + 6, NULL, 0);\r\nelse if (!strncmp(this_opt, "maxvf:", 6))\r\nmaxvf = simple_strtoul(this_opt + 6, NULL, 0);\r\nelse if (!strncmp(this_opt, "maxclk:", 7))\r\nmaxclk = simple_strtoul(this_opt + 7, NULL, 0);\r\nelse if (!strncmp(this_opt, "vbemode:", 8))\r\nvbemode = simple_strtoul(this_opt + 8, NULL, 0);\r\nelse if (this_opt[0] >= '0' && this_opt[0] <= '9') {\r\nmode_option = this_opt;\r\n} else {\r\nprintk(KERN_WARNING\r\n"uvesafb: unrecognized option %s\n", this_opt);\r\n}\r\n}\r\nif (mtrr != 3 && mtrr != 0)\r\npr_warn("uvesafb: mtrr should be set to 0 or 3; %d is unsupported", mtrr);\r\nreturn 0;\r\n}\r\nstatic ssize_t show_v86d(struct device_driver *dev, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", v86d_path);\r\n}\r\nstatic ssize_t store_v86d(struct device_driver *dev, const char *buf,\r\nsize_t count)\r\n{\r\nstrncpy(v86d_path, buf, PATH_MAX);\r\nreturn count;\r\n}\r\nstatic int uvesafb_init(void)\r\n{\r\nint err;\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("uvesafb", &option))\r\nreturn -ENODEV;\r\nuvesafb_setup(option);\r\n#endif\r\nerr = cn_add_callback(&uvesafb_cn_id, "uvesafb", uvesafb_cn_callback);\r\nif (err)\r\nreturn err;\r\nerr = platform_driver_register(&uvesafb_driver);\r\nif (!err) {\r\nuvesafb_device = platform_device_alloc("uvesafb", 0);\r\nif (uvesafb_device)\r\nerr = platform_device_add(uvesafb_device);\r\nelse\r\nerr = -ENOMEM;\r\nif (err) {\r\nif (uvesafb_device)\r\nplatform_device_put(uvesafb_device);\r\nplatform_driver_unregister(&uvesafb_driver);\r\ncn_del_callback(&uvesafb_cn_id);\r\nreturn err;\r\n}\r\nerr = driver_create_file(&uvesafb_driver.driver,\r\n&driver_attr_v86d);\r\nif (err) {\r\nprintk(KERN_WARNING "uvesafb: failed to register "\r\n"attributes\n");\r\nerr = 0;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic void uvesafb_exit(void)\r\n{\r\nstruct uvesafb_ktask *task;\r\nif (v86d_started) {\r\ntask = uvesafb_prep();\r\nif (task) {\r\ntask->t.flags = TF_EXIT;\r\nuvesafb_exec(task);\r\nuvesafb_free(task);\r\n}\r\n}\r\ncn_del_callback(&uvesafb_cn_id);\r\ndriver_remove_file(&uvesafb_driver.driver, &driver_attr_v86d);\r\nplatform_device_unregister(uvesafb_device);\r\nplatform_driver_unregister(&uvesafb_driver);\r\n}\r\nstatic int param_set_scroll(const char *val, const struct kernel_param *kp)\r\n{\r\nypan = 0;\r\nif (!strcmp(val, "redraw"))\r\nypan = 0;\r\nelse if (!strcmp(val, "ypan"))\r\nypan = 1;\r\nelse if (!strcmp(val, "ywrap"))\r\nypan = 2;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}
