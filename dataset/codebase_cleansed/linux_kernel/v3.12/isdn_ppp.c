static void\r\nisdn_ppp_frame_log(char *info, char *data, int len, int maxlen, int unit, int slot)\r\n{\r\nint cnt,\r\nj,\r\ni;\r\nchar buf[80];\r\nif (len < maxlen)\r\nmaxlen = len;\r\nfor (i = 0, cnt = 0; cnt < maxlen; i++) {\r\nfor (j = 0; j < 16 && cnt < maxlen; j++, cnt++)\r\nsprintf(buf + j * 3, "%02x ", (unsigned char)data[cnt]);\r\nprintk(KERN_DEBUG "[%d/%d].%s[%d]: %s\n", unit, slot, info, i, buf);\r\n}\r\n}\r\nint\r\nisdn_ppp_free(isdn_net_local *lp)\r\n{\r\nstruct ippp_struct *is;\r\nif (lp->ppp_slot < 0 || lp->ppp_slot >= ISDN_MAX_CHANNELS) {\r\nprintk(KERN_ERR "%s: ppp_slot(%d) out of range\n",\r\n__func__, lp->ppp_slot);\r\nreturn 0;\r\n}\r\n#ifdef CONFIG_ISDN_MPP\r\nspin_lock(&lp->netdev->pb->lock);\r\n#endif\r\nisdn_net_rm_from_bundle(lp);\r\n#ifdef CONFIG_ISDN_MPP\r\nif (lp->netdev->pb->ref_ct == 1)\r\nisdn_ppp_mp_cleanup(lp);\r\nlp->netdev->pb->ref_ct--;\r\nspin_unlock(&lp->netdev->pb->lock);\r\n#endif\r\nif (lp->ppp_slot < 0 || lp->ppp_slot >= ISDN_MAX_CHANNELS) {\r\nprintk(KERN_ERR "%s: ppp_slot(%d) now invalid\n",\r\n__func__, lp->ppp_slot);\r\nreturn 0;\r\n}\r\nis = ippp_table[lp->ppp_slot];\r\nif ((is->state & IPPP_CONNECT))\r\nisdn_ppp_closewait(lp->ppp_slot);\r\nelse if (is->state & IPPP_ASSIGNED)\r\nis->state = IPPP_OPEN;\r\nif (is->debug & 0x1)\r\nprintk(KERN_DEBUG "isdn_ppp_free %d %lx %lx\n", lp->ppp_slot, (long) lp, (long) is->lp);\r\nis->lp = NULL;\r\nlp->ppp_slot = -1;\r\nreturn 0;\r\n}\r\nint\r\nisdn_ppp_bind(isdn_net_local *lp)\r\n{\r\nint i;\r\nint unit = 0;\r\nstruct ippp_struct *is;\r\nint retval;\r\nif (lp->pppbind < 0) {\r\nisdn_net_dev *net_dev = dev->netdev;\r\nchar exclusive[ISDN_MAX_CHANNELS];\r\nmemset(exclusive, 0, ISDN_MAX_CHANNELS);\r\nwhile (net_dev) {\r\nisdn_net_local *lp = net_dev->local;\r\nif (lp->pppbind >= 0)\r\nexclusive[lp->pppbind] = 1;\r\nnet_dev = net_dev->next;\r\n}\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\r\nif (ippp_table[i]->state == IPPP_OPEN && !exclusive[ippp_table[i]->minor]) {\r\nbreak;\r\n}\r\n}\r\n} else {\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\r\nif (ippp_table[i]->minor == lp->pppbind &&\r\n(ippp_table[i]->state & IPPP_OPEN) == IPPP_OPEN)\r\nbreak;\r\n}\r\n}\r\nif (i >= ISDN_MAX_CHANNELS) {\r\nprintk(KERN_WARNING "isdn_ppp_bind: Can't find a (free) connection to the ipppd daemon.\n");\r\nretval = -1;\r\ngoto out;\r\n}\r\nunit = isdn_ppp_if_get_unit(lp->netdev->dev->name);\r\nif (unit < 0) {\r\nprintk(KERN_ERR "isdn_ppp_bind: illegal interface name %s.\n",\r\nlp->netdev->dev->name);\r\nretval = -1;\r\ngoto out;\r\n}\r\nlp->ppp_slot = i;\r\nis = ippp_table[i];\r\nis->lp = lp;\r\nis->unit = unit;\r\nis->state = IPPP_OPEN | IPPP_ASSIGNED;\r\n#ifdef CONFIG_ISDN_MPP\r\nretval = isdn_ppp_mp_init(lp, NULL);\r\nif (retval < 0)\r\ngoto out;\r\n#endif\r\nretval = lp->ppp_slot;\r\nout:\r\nreturn retval;\r\n}\r\nvoid\r\nisdn_ppp_wakeup_daemon(isdn_net_local *lp)\r\n{\r\nif (lp->ppp_slot < 0 || lp->ppp_slot >= ISDN_MAX_CHANNELS) {\r\nprintk(KERN_ERR "%s: ppp_slot(%d) out of range\n",\r\n__func__, lp->ppp_slot);\r\nreturn;\r\n}\r\nippp_table[lp->ppp_slot]->state = IPPP_OPEN | IPPP_CONNECT | IPPP_NOBLOCK;\r\nwake_up_interruptible(&ippp_table[lp->ppp_slot]->wq);\r\n}\r\nstatic int\r\nisdn_ppp_closewait(int slot)\r\n{\r\nstruct ippp_struct *is;\r\nif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\r\nprintk(KERN_ERR "%s: slot(%d) out of range\n",\r\n__func__, slot);\r\nreturn 0;\r\n}\r\nis = ippp_table[slot];\r\nif (is->state)\r\nwake_up_interruptible(&is->wq);\r\nis->state = IPPP_CLOSEWAIT;\r\nreturn 1;\r\n}\r\nstatic int\r\nisdn_ppp_get_slot(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\r\nif (!ippp_table[i]->state)\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nint\r\nisdn_ppp_open(int min, struct file *file)\r\n{\r\nint slot;\r\nstruct ippp_struct *is;\r\nif (min < 0 || min >= ISDN_MAX_CHANNELS)\r\nreturn -ENODEV;\r\nslot = isdn_ppp_get_slot();\r\nif (slot < 0) {\r\nreturn -EBUSY;\r\n}\r\nis = file->private_data = ippp_table[slot];\r\nprintk(KERN_DEBUG "ippp, open, slot: %d, minor: %d, state: %04x\n",\r\nslot, min, is->state);\r\nis->link_compressor = is->compressor = NULL;\r\nis->link_decompressor = is->decompressor = NULL;\r\nis->link_comp_stat = is->comp_stat = NULL;\r\nis->link_decomp_stat = is->decomp_stat = NULL;\r\nis->compflags = 0;\r\nis->reset = isdn_ppp_ccp_reset_alloc(is);\r\nis->lp = NULL;\r\nis->mp_seqno = 0;\r\nis->pppcfg = 0;\r\nis->mpppcfg = 0;\r\nis->last_link_seqno = -1;\r\nis->unit = -1;\r\nis->mru = 1524;\r\nis->maxcid = 16;\r\nis->tk = current;\r\ninit_waitqueue_head(&is->wq);\r\nis->first = is->rq + NUM_RCV_BUFFS - 1;\r\nis->last = is->rq;\r\nis->minor = min;\r\n#ifdef CONFIG_ISDN_PPP_VJ\r\nis->slcomp = slhc_init(16, 16);\r\n#endif\r\n#ifdef CONFIG_IPPP_FILTER\r\nis->pass_filter = NULL;\r\nis->active_filter = NULL;\r\n#endif\r\nis->state = IPPP_OPEN;\r\nreturn 0;\r\n}\r\nvoid\r\nisdn_ppp_release(int min, struct file *file)\r\n{\r\nint i;\r\nstruct ippp_struct *is;\r\nif (min < 0 || min >= ISDN_MAX_CHANNELS)\r\nreturn;\r\nis = file->private_data;\r\nif (!is) {\r\nprintk(KERN_ERR "%s: no file->private_data\n", __func__);\r\nreturn;\r\n}\r\nif (is->debug & 0x1)\r\nprintk(KERN_DEBUG "ippp: release, minor: %d %lx\n", min, (long) is->lp);\r\nif (is->lp) {\r\nisdn_net_dev *p = is->lp->netdev;\r\nif (!p) {\r\nprintk(KERN_ERR "%s: no lp->netdev\n", __func__);\r\nreturn;\r\n}\r\nis->state &= ~IPPP_CONNECT;\r\nisdn_net_hangup(p->dev);\r\n}\r\nfor (i = 0; i < NUM_RCV_BUFFS; i++) {\r\nkfree(is->rq[i].buf);\r\nis->rq[i].buf = NULL;\r\n}\r\nis->first = is->rq + NUM_RCV_BUFFS - 1;\r\nis->last = is->rq;\r\n#ifdef CONFIG_ISDN_PPP_VJ\r\nslhc_free(is->slcomp);\r\nis->slcomp = NULL;\r\n#endif\r\n#ifdef CONFIG_IPPP_FILTER\r\nkfree(is->pass_filter);\r\nis->pass_filter = NULL;\r\nkfree(is->active_filter);\r\nis->active_filter = NULL;\r\n#endif\r\nif (is->comp_stat)\r\nis->compressor->free(is->comp_stat);\r\nif (is->link_comp_stat)\r\nis->link_compressor->free(is->link_comp_stat);\r\nif (is->link_decomp_stat)\r\nis->link_decompressor->free(is->link_decomp_stat);\r\nif (is->decomp_stat)\r\nis->decompressor->free(is->decomp_stat);\r\nis->compressor = is->link_compressor = NULL;\r\nis->decompressor = is->link_decompressor = NULL;\r\nis->comp_stat = is->link_comp_stat = NULL;\r\nis->decomp_stat = is->link_decomp_stat = NULL;\r\nif (is->reset)\r\nisdn_ppp_ccp_reset_free(is);\r\nis->state = 0;\r\n}\r\nstatic int\r\nget_arg(void __user *b, void *val, int len)\r\n{\r\nif (len <= 0)\r\nlen = sizeof(void *);\r\nif (copy_from_user(val, b, len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\nset_arg(void __user *b, void *val, int len)\r\n{\r\nif (len <= 0)\r\nlen = sizeof(void *);\r\nif (copy_to_user(b, val, len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int get_filter(void __user *arg, struct sock_filter **p)\r\n{\r\nstruct sock_fprog uprog;\r\nstruct sock_filter *code = NULL;\r\nint len, err;\r\nif (copy_from_user(&uprog, arg, sizeof(uprog)))\r\nreturn -EFAULT;\r\nif (!uprog.len) {\r\n*p = NULL;\r\nreturn 0;\r\n}\r\nlen = uprog.len * sizeof(struct sock_filter);\r\ncode = memdup_user(uprog.filter, len);\r\nif (IS_ERR(code))\r\nreturn PTR_ERR(code);\r\nerr = sk_chk_filter(code, uprog.len);\r\nif (err) {\r\nkfree(code);\r\nreturn err;\r\n}\r\n*p = code;\r\nreturn uprog.len;\r\n}\r\nint\r\nisdn_ppp_ioctl(int min, struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nunsigned long val;\r\nint r, i, j;\r\nstruct ippp_struct *is;\r\nisdn_net_local *lp;\r\nstruct isdn_ppp_comp_data data;\r\nvoid __user *argp = (void __user *)arg;\r\nis = file->private_data;\r\nlp = is->lp;\r\nif (is->debug & 0x1)\r\nprintk(KERN_DEBUG "isdn_ppp_ioctl: minor: %d cmd: %x state: %x\n", min, cmd, is->state);\r\nif (!(is->state & IPPP_OPEN))\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase PPPIOCBUNDLE:\r\n#ifdef CONFIG_ISDN_MPP\r\nif (!(is->state & IPPP_CONNECT))\r\nreturn -EINVAL;\r\nif ((r = get_arg(argp, &val, sizeof(val))))\r\nreturn r;\r\nprintk(KERN_DEBUG "iPPP-bundle: minor: %d, slave unit: %d, master unit: %d\n",\r\n(int) min, (int) is->unit, (int) val);\r\nreturn isdn_ppp_bundle(is, val);\r\n#else\r\nreturn -1;\r\n#endif\r\nbreak;\r\ncase PPPIOCGUNIT:\r\nif ((r = set_arg(argp, &is->unit, sizeof(is->unit))))\r\nreturn r;\r\nbreak;\r\ncase PPPIOCGIFNAME:\r\nif (!lp)\r\nreturn -EINVAL;\r\nif ((r = set_arg(argp, lp->netdev->dev->name,\r\nstrlen(lp->netdev->dev->name))))\r\nreturn r;\r\nbreak;\r\ncase PPPIOCGMPFLAGS:\r\nif ((r = set_arg(argp, &is->mpppcfg, sizeof(is->mpppcfg))))\r\nreturn r;\r\nbreak;\r\ncase PPPIOCSMPFLAGS:\r\nif ((r = get_arg(argp, &val, sizeof(val))))\r\nreturn r;\r\nis->mpppcfg = val;\r\nbreak;\r\ncase PPPIOCGFLAGS:\r\nif ((r = set_arg(argp, &is->pppcfg, sizeof(is->pppcfg))))\r\nreturn r;\r\nbreak;\r\ncase PPPIOCSFLAGS:\r\nif ((r = get_arg(argp, &val, sizeof(val)))) {\r\nreturn r;\r\n}\r\nif (val & SC_ENABLE_IP && !(is->pppcfg & SC_ENABLE_IP) && (is->state & IPPP_CONNECT)) {\r\nif (lp) {\r\nis->pppcfg = val;\r\nnetif_wake_queue(lp->netdev->dev);\r\nbreak;\r\n}\r\n}\r\nis->pppcfg = val;\r\nbreak;\r\ncase PPPIOCGIDLE:\r\nif (lp) {\r\nstruct ppp_idle pidle;\r\npidle.xmit_idle = pidle.recv_idle = lp->huptimer;\r\nif ((r = set_arg(argp, &pidle, sizeof(struct ppp_idle))))\r\nreturn r;\r\n}\r\nbreak;\r\ncase PPPIOCSMRU:\r\nif ((r = get_arg(argp, &val, sizeof(val))))\r\nreturn r;\r\nis->mru = val;\r\nbreak;\r\ncase PPPIOCSMPMRU:\r\nbreak;\r\ncase PPPIOCSMPMTU:\r\nbreak;\r\ncase PPPIOCSMAXCID:\r\nif ((r = get_arg(argp, &val, sizeof(val))))\r\nreturn r;\r\nval++;\r\nif (is->maxcid != val) {\r\n#ifdef CONFIG_ISDN_PPP_VJ\r\nstruct slcompress *sltmp;\r\n#endif\r\nif (is->debug & 0x1)\r\nprintk(KERN_DEBUG "ippp, ioctl: changed MAXCID to %ld\n", val);\r\nis->maxcid = val;\r\n#ifdef CONFIG_ISDN_PPP_VJ\r\nsltmp = slhc_init(16, val);\r\nif (!sltmp) {\r\nprintk(KERN_ERR "ippp, can't realloc slhc struct\n");\r\nreturn -ENOMEM;\r\n}\r\nif (is->slcomp)\r\nslhc_free(is->slcomp);\r\nis->slcomp = sltmp;\r\n#endif\r\n}\r\nbreak;\r\ncase PPPIOCGDEBUG:\r\nif ((r = set_arg(argp, &is->debug, sizeof(is->debug))))\r\nreturn r;\r\nbreak;\r\ncase PPPIOCSDEBUG:\r\nif ((r = get_arg(argp, &val, sizeof(val))))\r\nreturn r;\r\nis->debug = val;\r\nbreak;\r\ncase PPPIOCGCOMPRESSORS:\r\n{\r\nunsigned long protos[8] = {0,};\r\nstruct isdn_ppp_compressor *ipc = ipc_head;\r\nwhile (ipc) {\r\nj = ipc->num / (sizeof(long) * 8);\r\ni = ipc->num % (sizeof(long) * 8);\r\nif (j < 8)\r\nprotos[j] |= (1UL << i);\r\nipc = ipc->next;\r\n}\r\nif ((r = set_arg(argp, protos, 8 * sizeof(long))))\r\nreturn r;\r\n}\r\nbreak;\r\ncase PPPIOCSCOMPRESSOR:\r\nif ((r = get_arg(argp, &data, sizeof(struct isdn_ppp_comp_data))))\r\nreturn r;\r\nreturn isdn_ppp_set_compressor(is, &data);\r\ncase PPPIOCGCALLINFO:\r\n{\r\nstruct pppcallinfo pci;\r\nmemset((char *)&pci, 0, sizeof(struct pppcallinfo));\r\nif (lp)\r\n{\r\nstrncpy(pci.local_num, lp->msn, 63);\r\nif (lp->dial) {\r\nstrncpy(pci.remote_num, lp->dial->num, 63);\r\n}\r\npci.charge_units = lp->charge;\r\nif (lp->outgoing)\r\npci.calltype = CALLTYPE_OUTGOING;\r\nelse\r\npci.calltype = CALLTYPE_INCOMING;\r\nif (lp->flags & ISDN_NET_CALLBACK)\r\npci.calltype |= CALLTYPE_CALLBACK;\r\n}\r\nreturn set_arg(argp, &pci, sizeof(struct pppcallinfo));\r\n}\r\n#ifdef CONFIG_IPPP_FILTER\r\ncase PPPIOCSPASS:\r\n{\r\nstruct sock_filter *code;\r\nint len = get_filter(argp, &code);\r\nif (len < 0)\r\nreturn len;\r\nkfree(is->pass_filter);\r\nis->pass_filter = code;\r\nis->pass_len = len;\r\nbreak;\r\n}\r\ncase PPPIOCSACTIVE:\r\n{\r\nstruct sock_filter *code;\r\nint len = get_filter(argp, &code);\r\nif (len < 0)\r\nreturn len;\r\nkfree(is->active_filter);\r\nis->active_filter = code;\r\nis->active_len = len;\r\nbreak;\r\n}\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nunsigned int\r\nisdn_ppp_poll(struct file *file, poll_table *wait)\r\n{\r\nu_int mask;\r\nstruct ippp_buf_queue *bf, *bl;\r\nu_long flags;\r\nstruct ippp_struct *is;\r\nis = file->private_data;\r\nif (is->debug & 0x2)\r\nprintk(KERN_DEBUG "isdn_ppp_poll: minor: %d\n",\r\niminor(file_inode(file)));\r\npoll_wait(file, &is->wq, wait);\r\nif (!(is->state & IPPP_OPEN)) {\r\nif (is->state == IPPP_CLOSEWAIT)\r\nreturn POLLHUP;\r\nprintk(KERN_DEBUG "isdn_ppp: device not open\n");\r\nreturn POLLERR;\r\n}\r\nmask = POLLOUT | POLLWRNORM;\r\nspin_lock_irqsave(&is->buflock, flags);\r\nbl = is->last;\r\nbf = is->first;\r\nif (bf->next != bl || (is->state & IPPP_NOBLOCK)) {\r\nis->state &= ~IPPP_NOBLOCK;\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\nspin_unlock_irqrestore(&is->buflock, flags);\r\nreturn mask;\r\n}\r\nstatic int\r\nisdn_ppp_fill_rq(unsigned char *buf, int len, int proto, int slot)\r\n{\r\nstruct ippp_buf_queue *bf, *bl;\r\nu_long flags;\r\nu_char *nbuf;\r\nstruct ippp_struct *is;\r\nif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\r\nprintk(KERN_WARNING "ippp: illegal slot(%d).\n", slot);\r\nreturn 0;\r\n}\r\nis = ippp_table[slot];\r\nif (!(is->state & IPPP_CONNECT)) {\r\nprintk(KERN_DEBUG "ippp: device not activated.\n");\r\nreturn 0;\r\n}\r\nnbuf = kmalloc(len + 4, GFP_ATOMIC);\r\nif (!nbuf) {\r\nprintk(KERN_WARNING "ippp: Can't alloc buf\n");\r\nreturn 0;\r\n}\r\nnbuf[0] = PPP_ALLSTATIONS;\r\nnbuf[1] = PPP_UI;\r\nnbuf[2] = proto >> 8;\r\nnbuf[3] = proto & 0xff;\r\nmemcpy(nbuf + 4, buf, len);\r\nspin_lock_irqsave(&is->buflock, flags);\r\nbf = is->first;\r\nbl = is->last;\r\nif (bf == bl) {\r\nprintk(KERN_WARNING "ippp: Queue is full; discarding first buffer\n");\r\nbf = bf->next;\r\nkfree(bf->buf);\r\nis->first = bf;\r\n}\r\nbl->buf = (char *) nbuf;\r\nbl->len = len + 4;\r\nis->last = bl->next;\r\nspin_unlock_irqrestore(&is->buflock, flags);\r\nwake_up_interruptible(&is->wq);\r\nreturn len;\r\n}\r\nint\r\nisdn_ppp_read(int min, struct file *file, char __user *buf, int count)\r\n{\r\nstruct ippp_struct *is;\r\nstruct ippp_buf_queue *b;\r\nu_long flags;\r\nu_char *save_buf;\r\nis = file->private_data;\r\nif (!(is->state & IPPP_OPEN))\r\nreturn 0;\r\nif (!access_ok(VERIFY_WRITE, buf, count))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&is->buflock, flags);\r\nb = is->first->next;\r\nsave_buf = b->buf;\r\nif (!save_buf) {\r\nspin_unlock_irqrestore(&is->buflock, flags);\r\nreturn -EAGAIN;\r\n}\r\nif (b->len < count)\r\ncount = b->len;\r\nb->buf = NULL;\r\nis->first = b;\r\nspin_unlock_irqrestore(&is->buflock, flags);\r\nif (copy_to_user(buf, save_buf, count))\r\ncount = -EFAULT;\r\nkfree(save_buf);\r\nreturn count;\r\n}\r\nint\r\nisdn_ppp_write(int min, struct file *file, const char __user *buf, int count)\r\n{\r\nisdn_net_local *lp;\r\nstruct ippp_struct *is;\r\nint proto;\r\nunsigned char protobuf[4];\r\nis = file->private_data;\r\nif (!(is->state & IPPP_CONNECT))\r\nreturn 0;\r\nlp = is->lp;\r\nif (!lp)\r\nprintk(KERN_DEBUG "isdn_ppp_write: lp == NULL\n");\r\nelse {\r\nif (copy_from_user(protobuf, buf, 4))\r\nreturn -EFAULT;\r\nproto = PPP_PROTOCOL(protobuf);\r\nif (proto != PPP_LCP)\r\nlp->huptimer = 0;\r\nif (lp->isdn_device < 0 || lp->isdn_channel < 0)\r\nreturn 0;\r\nif ((dev->drv[lp->isdn_device]->flags & DRV_FLAG_RUNNING) &&\r\nlp->dialstate == 0 &&\r\n(lp->flags & ISDN_NET_CONNECTED)) {\r\nunsigned short hl;\r\nstruct sk_buff *skb;\r\nhl = dev->drv[lp->isdn_device]->interface->hl_hdrlen;\r\nskb = alloc_skb(hl + count, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_WARNING "isdn_ppp_write: out of memory!\n");\r\nreturn count;\r\n}\r\nskb_reserve(skb, hl);\r\nif (copy_from_user(skb_put(skb, count), buf, count))\r\n{\r\nkfree_skb(skb);\r\nreturn -EFAULT;\r\n}\r\nif (is->debug & 0x40) {\r\nprintk(KERN_DEBUG "ppp xmit: len %d\n", (int) skb->len);\r\nisdn_ppp_frame_log("xmit", skb->data, skb->len, 32, is->unit, lp->ppp_slot);\r\n}\r\nisdn_ppp_send_ccp(lp->netdev, lp, skb);\r\nisdn_net_write_super(lp, skb);\r\n}\r\n}\r\nreturn count;\r\n}\r\nint\r\nisdn_ppp_init(void)\r\n{\r\nint i,\r\nj;\r\n#ifdef CONFIG_ISDN_MPP\r\nif (isdn_ppp_mp_bundle_array_init() < 0)\r\nreturn -ENOMEM;\r\n#endif\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\r\nif (!(ippp_table[i] = kzalloc(sizeof(struct ippp_struct), GFP_KERNEL))) {\r\nprintk(KERN_WARNING "isdn_ppp_init: Could not alloc ippp_table\n");\r\nfor (j = 0; j < i; j++)\r\nkfree(ippp_table[j]);\r\nreturn -1;\r\n}\r\nspin_lock_init(&ippp_table[i]->buflock);\r\nippp_table[i]->state = 0;\r\nippp_table[i]->first = ippp_table[i]->rq + NUM_RCV_BUFFS - 1;\r\nippp_table[i]->last = ippp_table[i]->rq;\r\nfor (j = 0; j < NUM_RCV_BUFFS; j++) {\r\nippp_table[i]->rq[j].buf = NULL;\r\nippp_table[i]->rq[j].last = ippp_table[i]->rq +\r\n(NUM_RCV_BUFFS + j - 1) % NUM_RCV_BUFFS;\r\nippp_table[i]->rq[j].next = ippp_table[i]->rq + (j + 1) % NUM_RCV_BUFFS;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nisdn_ppp_cleanup(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++)\r\nkfree(ippp_table[i]);\r\n#ifdef CONFIG_ISDN_MPP\r\nkfree(isdn_ppp_bundle_arr);\r\n#endif\r\n}\r\nstatic int isdn_ppp_skip_ac(struct ippp_struct *is, struct sk_buff *skb)\r\n{\r\nif (skb->len < 1)\r\nreturn -1;\r\nif (skb->data[0] == 0xff) {\r\nif (skb->len < 2)\r\nreturn -1;\r\nif (skb->data[1] != 0x03)\r\nreturn -1;\r\nskb_pull(skb, 2);\r\n} else {\r\nif (is->pppcfg & SC_REJ_COMP_AC)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int isdn_ppp_strip_proto(struct sk_buff *skb)\r\n{\r\nint proto;\r\nif (skb->len < 1)\r\nreturn -1;\r\nif (skb->data[0] & 0x1) {\r\nproto = skb->data[0];\r\nskb_pull(skb, 1);\r\n} else {\r\nif (skb->len < 2)\r\nreturn -1;\r\nproto = ((int) skb->data[0] << 8) + skb->data[1];\r\nskb_pull(skb, 2);\r\n}\r\nreturn proto;\r\n}\r\nvoid isdn_ppp_receive(isdn_net_dev *net_dev, isdn_net_local *lp, struct sk_buff *skb)\r\n{\r\nstruct ippp_struct *is;\r\nint slot;\r\nint proto;\r\nBUG_ON(net_dev->local->master);\r\nslot = lp->ppp_slot;\r\nif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\r\nprintk(KERN_ERR "isdn_ppp_receive: lp->ppp_slot(%d)\n",\r\nlp->ppp_slot);\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nis = ippp_table[slot];\r\nif (is->debug & 0x4) {\r\nprintk(KERN_DEBUG "ippp_receive: is:%08lx lp:%08lx slot:%d unit:%d len:%d\n",\r\n(long)is, (long)lp, lp->ppp_slot, is->unit, (int)skb->len);\r\nisdn_ppp_frame_log("receive", skb->data, skb->len, 32, is->unit, lp->ppp_slot);\r\n}\r\nif (isdn_ppp_skip_ac(is, skb) < 0) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nproto = isdn_ppp_strip_proto(skb);\r\nif (proto < 0) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\n#ifdef CONFIG_ISDN_MPP\r\nif (is->compflags & SC_LINK_DECOMP_ON) {\r\nskb = isdn_ppp_decompress(skb, is, NULL, &proto);\r\nif (!skb)\r\nreturn;\r\n}\r\nif (!(is->mpppcfg & SC_REJ_MP_PROT)) {\r\nif (proto == PPP_MP) {\r\nisdn_ppp_mp_receive(net_dev, lp, skb);\r\nreturn;\r\n}\r\n}\r\n#endif\r\nisdn_ppp_push_higher(net_dev, lp, skb, proto);\r\n}\r\nstatic void\r\nisdn_ppp_push_higher(isdn_net_dev *net_dev, isdn_net_local *lp, struct sk_buff *skb, int proto)\r\n{\r\nstruct net_device *dev = net_dev->dev;\r\nstruct ippp_struct *is, *mis;\r\nisdn_net_local *mlp = NULL;\r\nint slot;\r\nslot = lp->ppp_slot;\r\nif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\r\nprintk(KERN_ERR "isdn_ppp_push_higher: lp->ppp_slot(%d)\n",\r\nlp->ppp_slot);\r\ngoto drop_packet;\r\n}\r\nis = ippp_table[slot];\r\nif (lp->master) {\r\nmlp = ISDN_MASTER_PRIV(lp);\r\nslot = mlp->ppp_slot;\r\nif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\r\nprintk(KERN_ERR "isdn_ppp_push_higher: master->ppp_slot(%d)\n",\r\nlp->ppp_slot);\r\ngoto drop_packet;\r\n}\r\n}\r\nmis = ippp_table[slot];\r\nif (is->debug & 0x10) {\r\nprintk(KERN_DEBUG "push, skb %d %04x\n", (int) skb->len, proto);\r\nisdn_ppp_frame_log("rpush", skb->data, skb->len, 32, is->unit, lp->ppp_slot);\r\n}\r\nif (mis->compflags & SC_DECOMP_ON) {\r\nskb = isdn_ppp_decompress(skb, is, mis, &proto);\r\nif (!skb)\r\nreturn;\r\n}\r\nswitch (proto) {\r\ncase PPP_IPX:\r\nif (is->debug & 0x20)\r\nprintk(KERN_DEBUG "isdn_ppp: IPX\n");\r\nskb->protocol = htons(ETH_P_IPX);\r\nbreak;\r\ncase PPP_IP:\r\nif (is->debug & 0x20)\r\nprintk(KERN_DEBUG "isdn_ppp: IP\n");\r\nskb->protocol = htons(ETH_P_IP);\r\nbreak;\r\ncase PPP_COMP:\r\ncase PPP_COMPFRAG:\r\nprintk(KERN_INFO "isdn_ppp: unexpected compressed frame dropped\n");\r\ngoto drop_packet;\r\n#ifdef CONFIG_ISDN_PPP_VJ\r\ncase PPP_VJC_UNCOMP:\r\nif (is->debug & 0x20)\r\nprintk(KERN_DEBUG "isdn_ppp: VJC_UNCOMP\n");\r\nif (net_dev->local->ppp_slot < 0) {\r\nprintk(KERN_ERR "%s: net_dev->local->ppp_slot(%d) out of range\n",\r\n__func__, net_dev->local->ppp_slot);\r\ngoto drop_packet;\r\n}\r\nif (slhc_remember(ippp_table[net_dev->local->ppp_slot]->slcomp, skb->data, skb->len) <= 0) {\r\nprintk(KERN_WARNING "isdn_ppp: received illegal VJC_UNCOMP frame!\n");\r\ngoto drop_packet;\r\n}\r\nskb->protocol = htons(ETH_P_IP);\r\nbreak;\r\ncase PPP_VJC_COMP:\r\nif (is->debug & 0x20)\r\nprintk(KERN_DEBUG "isdn_ppp: VJC_COMP\n");\r\n{\r\nstruct sk_buff *skb_old = skb;\r\nint pkt_len;\r\nskb = dev_alloc_skb(skb_old->len + 128);\r\nif (!skb) {\r\nprintk(KERN_WARNING "%s: Memory squeeze, dropping packet.\n", dev->name);\r\nskb = skb_old;\r\ngoto drop_packet;\r\n}\r\nskb_put(skb, skb_old->len + 128);\r\nskb_copy_from_linear_data(skb_old, skb->data,\r\nskb_old->len);\r\nif (net_dev->local->ppp_slot < 0) {\r\nprintk(KERN_ERR "%s: net_dev->local->ppp_slot(%d) out of range\n",\r\n__func__, net_dev->local->ppp_slot);\r\ngoto drop_packet;\r\n}\r\npkt_len = slhc_uncompress(ippp_table[net_dev->local->ppp_slot]->slcomp,\r\nskb->data, skb_old->len);\r\nkfree_skb(skb_old);\r\nif (pkt_len < 0)\r\ngoto drop_packet;\r\nskb_trim(skb, pkt_len);\r\nskb->protocol = htons(ETH_P_IP);\r\n}\r\nbreak;\r\n#endif\r\ncase PPP_CCP:\r\ncase PPP_CCPFRAG:\r\nisdn_ppp_receive_ccp(net_dev, lp, skb, proto);\r\nif (skb->data[0] == CCP_RESETREQ ||\r\nskb->data[0] == CCP_RESETACK)\r\nbreak;\r\ndefault:\r\nisdn_ppp_fill_rq(skb->data, skb->len, proto, lp->ppp_slot);\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\n#ifdef CONFIG_IPPP_FILTER\r\nskb_push(skb, 4);\r\n{\r\nu_int16_t *p = (u_int16_t *) skb->data;\r\n*p = 0;\r\n}\r\nif (is->pass_filter\r\n&& sk_run_filter(skb, is->pass_filter) == 0) {\r\nif (is->debug & 0x2)\r\nprintk(KERN_DEBUG "IPPP: inbound frame filtered.\n");\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (!(is->active_filter\r\n&& sk_run_filter(skb, is->active_filter) == 0)) {\r\nif (is->debug & 0x2)\r\nprintk(KERN_DEBUG "IPPP: link-active filter: resetting huptimer.\n");\r\nlp->huptimer = 0;\r\nif (mlp)\r\nmlp->huptimer = 0;\r\n}\r\nskb_pull(skb, 4);\r\n#else\r\nlp->huptimer = 0;\r\nif (mlp)\r\nmlp->huptimer = 0;\r\n#endif\r\nskb->dev = dev;\r\nskb_reset_mac_header(skb);\r\nnetif_rx(skb);\r\nreturn;\r\ndrop_packet:\r\nnet_dev->local->stats.rx_dropped++;\r\nkfree_skb(skb);\r\n}\r\nstatic unsigned char *isdn_ppp_skb_push(struct sk_buff **skb_p, int len)\r\n{\r\nstruct sk_buff *skb = *skb_p;\r\nif (skb_headroom(skb) < len) {\r\nstruct sk_buff *nskb = skb_realloc_headroom(skb, len);\r\nif (!nskb) {\r\nprintk(KERN_ERR "isdn_ppp_skb_push: can't realloc headroom!\n");\r\ndev_kfree_skb(skb);\r\nreturn NULL;\r\n}\r\nprintk(KERN_DEBUG "isdn_ppp_skb_push:under %d %d\n", skb_headroom(skb), len);\r\ndev_kfree_skb(skb);\r\n*skb_p = nskb;\r\nreturn skb_push(nskb, len);\r\n}\r\nreturn skb_push(skb, len);\r\n}\r\nint\r\nisdn_ppp_xmit(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nisdn_net_local *lp, *mlp;\r\nisdn_net_dev *nd;\r\nunsigned int proto = PPP_IP;\r\nstruct ippp_struct *ipt, *ipts;\r\nint slot, retval = NETDEV_TX_OK;\r\nmlp = netdev_priv(netdev);\r\nnd = mlp->netdev;\r\nslot = mlp->ppp_slot;\r\nif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\r\nprintk(KERN_ERR "isdn_ppp_xmit: lp->ppp_slot(%d)\n",\r\nmlp->ppp_slot);\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nipts = ippp_table[slot];\r\nif (!(ipts->pppcfg & SC_ENABLE_IP)) {\r\nif (ipts->debug & 0x1)\r\nprintk(KERN_INFO "%s: IP frame delayed.\n", netdev->name);\r\nretval = NETDEV_TX_BUSY;\r\ngoto out;\r\n}\r\nswitch (ntohs(skb->protocol)) {\r\ncase ETH_P_IP:\r\nproto = PPP_IP;\r\nbreak;\r\ncase ETH_P_IPX:\r\nproto = PPP_IPX;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "isdn_ppp: skipped unsupported protocol: %#x.\n",\r\nskb->protocol);\r\ndev_kfree_skb(skb);\r\ngoto out;\r\n}\r\nlp = isdn_net_get_locked_lp(nd);\r\nif (!lp) {\r\nprintk(KERN_WARNING "%s: all channels busy - requeuing!\n", netdev->name);\r\nretval = NETDEV_TX_BUSY;\r\ngoto out;\r\n}\r\nslot = lp->ppp_slot;\r\nif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\r\nprintk(KERN_ERR "isdn_ppp_xmit: lp->ppp_slot(%d)\n",\r\nlp->ppp_slot);\r\nkfree_skb(skb);\r\ngoto unlock;\r\n}\r\nipt = ippp_table[slot];\r\nskb_pull(skb, IPPP_MAX_HEADER);\r\n#ifdef CONFIG_IPPP_FILTER\r\n*skb_push(skb, 4) = 1;\r\n{\r\n__be16 *p = (__be16 *)skb->data;\r\np++;\r\n*p = htons(proto);\r\n}\r\nif (ipt->pass_filter\r\n&& sk_run_filter(skb, ipt->pass_filter) == 0) {\r\nif (ipt->debug & 0x4)\r\nprintk(KERN_DEBUG "IPPP: outbound frame filtered.\n");\r\nkfree_skb(skb);\r\ngoto unlock;\r\n}\r\nif (!(ipt->active_filter\r\n&& sk_run_filter(skb, ipt->active_filter) == 0)) {\r\nif (ipt->debug & 0x4)\r\nprintk(KERN_DEBUG "IPPP: link-active filter: resetting huptimer.\n");\r\nlp->huptimer = 0;\r\n}\r\nskb_pull(skb, 4);\r\n#else\r\nlp->huptimer = 0;\r\n#endif\r\nif (ipt->debug & 0x4)\r\nprintk(KERN_DEBUG "xmit skb, len %d\n", (int) skb->len);\r\nif (ipts->debug & 0x40)\r\nisdn_ppp_frame_log("xmit0", skb->data, skb->len, 32, ipts->unit, lp->ppp_slot);\r\n#ifdef CONFIG_ISDN_PPP_VJ\r\nif (proto == PPP_IP && ipts->pppcfg & SC_COMP_TCP) {\r\nstruct sk_buff *new_skb;\r\nunsigned short hl;\r\nhl = dev->drv[lp->isdn_device]->interface->hl_hdrlen + IPPP_MAX_HEADER;\r\nnew_skb = alloc_skb(hl + skb->len, GFP_ATOMIC);\r\nif (new_skb) {\r\nu_char *buf;\r\nint pktlen;\r\nskb_reserve(new_skb, hl);\r\nnew_skb->dev = skb->dev;\r\nskb_put(new_skb, skb->len);\r\nbuf = skb->data;\r\npktlen = slhc_compress(ipts->slcomp, skb->data, skb->len, new_skb->data,\r\n&buf, !(ipts->pppcfg & SC_NO_TCP_CCID));\r\nif (buf != skb->data) {\r\nif (new_skb->data != buf)\r\nprintk(KERN_ERR "isdn_ppp: FATAL error after slhc_compress!!\n");\r\ndev_kfree_skb(skb);\r\nskb = new_skb;\r\n} else {\r\ndev_kfree_skb(new_skb);\r\n}\r\nskb_trim(skb, pktlen);\r\nif (skb->data[0] & SL_TYPE_COMPRESSED_TCP) {\r\nproto = PPP_VJC_COMP;\r\nskb->data[0] ^= SL_TYPE_COMPRESSED_TCP;\r\n} else {\r\nif (skb->data[0] >= SL_TYPE_UNCOMPRESSED_TCP)\r\nproto = PPP_VJC_UNCOMP;\r\nskb->data[0] = (skb->data[0] & 0x0f) | 0x40;\r\n}\r\n}\r\n}\r\n#endif\r\nif (ipts->compflags & SC_COMP_ON) {\r\nif (ipts->compflags & SC_DECOMP_ON) {\r\nskb = isdn_ppp_compress(skb, &proto, ipt, ipts, 0);\r\n} else {\r\nprintk(KERN_DEBUG "isdn_ppp: CCP not yet up - sending as-is\n");\r\n}\r\n}\r\nif (ipt->debug & 0x24)\r\nprintk(KERN_DEBUG "xmit2 skb, len %d, proto %04x\n", (int) skb->len, proto);\r\n#ifdef CONFIG_ISDN_MPP\r\nif (ipt->mpppcfg & SC_MP_PROT) {\r\nlong mp_seqno = ipts->mp_seqno;\r\nipts->mp_seqno++;\r\nif (ipt->mpppcfg & SC_OUT_SHORT_SEQ) {\r\nunsigned char *data = isdn_ppp_skb_push(&skb, 3);\r\nif (!data)\r\ngoto unlock;\r\nmp_seqno &= 0xfff;\r\ndata[0] = MP_BEGIN_FRAG | MP_END_FRAG | ((mp_seqno >> 8) & 0xf);\r\ndata[1] = mp_seqno & 0xff;\r\ndata[2] = proto;\r\n} else {\r\nunsigned char *data = isdn_ppp_skb_push(&skb, 5);\r\nif (!data)\r\ngoto unlock;\r\ndata[0] = MP_BEGIN_FRAG | MP_END_FRAG;\r\ndata[1] = (mp_seqno >> 16) & 0xff;\r\ndata[2] = (mp_seqno >> 8) & 0xff;\r\ndata[3] = (mp_seqno >> 0) & 0xff;\r\ndata[4] = proto;\r\n}\r\nproto = PPP_MP;\r\n}\r\n#endif\r\nif (ipt->compflags & SC_LINK_COMP_ON)\r\nskb = isdn_ppp_compress(skb, &proto, ipt, ipts, 1);\r\nif ((ipt->pppcfg & SC_COMP_PROT) && (proto <= 0xff)) {\r\nunsigned char *data = isdn_ppp_skb_push(&skb, 1);\r\nif (!data)\r\ngoto unlock;\r\ndata[0] = proto & 0xff;\r\n}\r\nelse {\r\nunsigned char *data = isdn_ppp_skb_push(&skb, 2);\r\nif (!data)\r\ngoto unlock;\r\ndata[0] = (proto >> 8) & 0xff;\r\ndata[1] = proto & 0xff;\r\n}\r\nif (!(ipt->pppcfg & SC_COMP_AC)) {\r\nunsigned char *data = isdn_ppp_skb_push(&skb, 2);\r\nif (!data)\r\ngoto unlock;\r\ndata[0] = 0xff;\r\ndata[1] = 0x03;\r\n}\r\nif (ipts->debug & 0x40) {\r\nprintk(KERN_DEBUG "skb xmit: len: %d\n", (int) skb->len);\r\nisdn_ppp_frame_log("xmit", skb->data, skb->len, 32, ipt->unit, lp->ppp_slot);\r\n}\r\nisdn_net_writebuf_skb(lp, skb);\r\nunlock:\r\nspin_unlock_bh(&lp->xmit_lock);\r\nout:\r\nreturn retval;\r\n}\r\nint isdn_ppp_autodial_filter(struct sk_buff *skb, isdn_net_local *lp)\r\n{\r\nstruct ippp_struct *is = ippp_table[lp->ppp_slot];\r\nu_int16_t proto;\r\nint drop = 0;\r\nswitch (ntohs(skb->protocol)) {\r\ncase ETH_P_IP:\r\nproto = PPP_IP;\r\nbreak;\r\ncase ETH_P_IPX:\r\nproto = PPP_IPX;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "isdn_ppp_autodial_filter: unsupported protocol 0x%x.\n",\r\nskb->protocol);\r\nreturn 1;\r\n}\r\n*skb_pull(skb, IPPP_MAX_HEADER - 4) = 1;\r\n{\r\n__be16 *p = (__be16 *)skb->data;\r\np++;\r\n*p = htons(proto);\r\n}\r\ndrop |= is->pass_filter\r\n&& sk_run_filter(skb, is->pass_filter) == 0;\r\ndrop |= is->active_filter\r\n&& sk_run_filter(skb, is->active_filter) == 0;\r\nskb_push(skb, IPPP_MAX_HEADER - 4);\r\nreturn drop;\r\n}\r\nstatic int isdn_ppp_mp_bundle_array_init(void)\r\n{\r\nint i;\r\nint sz = ISDN_MAX_CHANNELS * sizeof(ippp_bundle);\r\nif ((isdn_ppp_bundle_arr = kzalloc(sz, GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++)\r\nspin_lock_init(&isdn_ppp_bundle_arr[i].lock);\r\nreturn 0;\r\n}\r\nstatic ippp_bundle *isdn_ppp_mp_bundle_alloc(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++)\r\nif (isdn_ppp_bundle_arr[i].ref_ct <= 0)\r\nreturn (isdn_ppp_bundle_arr + i);\r\nreturn NULL;\r\n}\r\nstatic int isdn_ppp_mp_init(isdn_net_local *lp, ippp_bundle *add_to)\r\n{\r\nstruct ippp_struct *is;\r\nif (lp->ppp_slot < 0) {\r\nprintk(KERN_ERR "%s: lp->ppp_slot(%d) out of range\n",\r\n__func__, lp->ppp_slot);\r\nreturn (-EINVAL);\r\n}\r\nis = ippp_table[lp->ppp_slot];\r\nif (add_to) {\r\nif (lp->netdev->pb)\r\nlp->netdev->pb->ref_ct--;\r\nlp->netdev->pb = add_to;\r\n} else {\r\nis->mp_seqno = 0;\r\nif ((lp->netdev->pb = isdn_ppp_mp_bundle_alloc()) == NULL)\r\nreturn -ENOMEM;\r\nlp->next = lp->last = lp;\r\nlp->netdev->pb->frags = NULL;\r\nlp->netdev->pb->frames = 0;\r\nlp->netdev->pb->seq = UINT_MAX;\r\n}\r\nlp->netdev->pb->ref_ct++;\r\nis->last_link_seqno = 0;\r\nreturn 0;\r\n}\r\nstatic void isdn_ppp_mp_receive(isdn_net_dev *net_dev, isdn_net_local *lp,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ippp_struct *is;\r\nisdn_net_local *lpq;\r\nippp_bundle *mp;\r\nisdn_mppp_stats *stats;\r\nstruct sk_buff *newfrag, *frag, *start, *nextf;\r\nu32 newseq, minseq, thisseq;\r\nunsigned long flags;\r\nint slot;\r\nspin_lock_irqsave(&net_dev->pb->lock, flags);\r\nmp = net_dev->pb;\r\nstats = &mp->stats;\r\nslot = lp->ppp_slot;\r\nif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\r\nprintk(KERN_ERR "%s: lp->ppp_slot(%d)\n",\r\n__func__, lp->ppp_slot);\r\nstats->frame_drops++;\r\ndev_kfree_skb(skb);\r\nspin_unlock_irqrestore(&mp->lock, flags);\r\nreturn;\r\n}\r\nis = ippp_table[slot];\r\nif (++mp->frames > stats->max_queue_len)\r\nstats->max_queue_len = mp->frames;\r\nif (is->debug & 0x8)\r\nisdn_ppp_mp_print_recv_pkt(lp->ppp_slot, skb);\r\nnewseq = isdn_ppp_mp_get_seq(is->mpppcfg & SC_IN_SHORT_SEQ,\r\nskb, is->last_link_seqno);\r\nif (mp->seq > MP_LONGSEQ_MAX && (newseq & MP_LONGSEQ_MAXBIT)) {\r\nmp->seq = newseq;\r\n} else if (MP_LT(newseq, mp->seq)) {\r\nstats->frame_drops++;\r\nisdn_ppp_mp_free_skb(mp, skb);\r\nspin_unlock_irqrestore(&mp->lock, flags);\r\nreturn;\r\n}\r\nis->last_link_seqno = minseq = newseq;\r\nfor (lpq = net_dev->queue;;) {\r\nslot = lpq->ppp_slot;\r\nif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\r\nprintk(KERN_ERR "%s: lpq->ppp_slot(%d)\n",\r\n__func__, lpq->ppp_slot);\r\n} else {\r\nu32 lls = ippp_table[slot]->last_link_seqno;\r\nif (MP_LT(lls, minseq))\r\nminseq = lls;\r\n}\r\nif ((lpq = lpq->next) == net_dev->queue)\r\nbreak;\r\n}\r\nif (MP_LT(minseq, mp->seq))\r\nminseq = mp->seq;\r\nnewfrag = skb;\r\nif ((frag = mp->frags) == NULL || MP_LT(newseq, MP_SEQ(frag))) {\r\nnewfrag->next = frag;\r\nmp->frags = frag = newfrag;\r\nnewfrag = NULL;\r\n}\r\nstart = MP_FLAGS(frag) & MP_BEGIN_FRAG &&\r\nMP_SEQ(frag) == mp->seq ? frag : NULL;\r\nwhile (start != NULL || newfrag != NULL) {\r\nthisseq = MP_SEQ(frag);\r\nnextf = frag->next;\r\nif (newfrag != NULL && thisseq == newseq) {\r\nisdn_ppp_mp_free_skb(mp, newfrag);\r\nnewfrag = NULL;\r\n}\r\nif (newfrag != NULL && (nextf == NULL ||\r\nMP_LT(newseq, MP_SEQ(nextf)))) {\r\nnewfrag->next = nextf;\r\nfrag->next = nextf = newfrag;\r\nnewfrag = NULL;\r\n}\r\nif (start != NULL) {\r\nif (start != frag && (MP_FLAGS(frag) & MP_BEGIN_FRAG)) {\r\nprintk(KERN_WARNING"isdn_mppp(seq %d): new "\r\n"BEGIN flag with no prior END", thisseq);\r\nstats->seqerrs++;\r\nstats->frame_drops++;\r\nstart = isdn_ppp_mp_discard(mp, start, frag);\r\nnextf = frag->next;\r\n}\r\n} else if (MP_LE(thisseq, minseq)) {\r\nif (MP_FLAGS(frag) & MP_BEGIN_FRAG)\r\nstart = frag;\r\nelse {\r\nif (MP_FLAGS(frag) & MP_END_FRAG)\r\nstats->frame_drops++;\r\nif (mp->frags == frag)\r\nmp->frags = nextf;\r\nisdn_ppp_mp_free_skb(mp, frag);\r\nfrag = nextf;\r\ncontinue;\r\n}\r\n}\r\nif (start != NULL && (MP_FLAGS(frag) & MP_END_FRAG)) {\r\nminseq = mp->seq = (thisseq + 1) & MP_LONGSEQ_MASK;\r\nisdn_ppp_mp_reassembly(net_dev, lp, start, nextf);\r\nstart = NULL;\r\nfrag = NULL;\r\nmp->frags = nextf;\r\n}\r\nif (nextf != NULL &&\r\n((thisseq + 1) & MP_LONGSEQ_MASK) == MP_SEQ(nextf)) {\r\nif (frag == NULL) {\r\nif (MP_FLAGS(nextf) & MP_BEGIN_FRAG)\r\nstart = nextf;\r\nelse\r\n{\r\nprintk(KERN_WARNING"isdn_mppp(seq %d):"\r\n" END flag with no following "\r\n"BEGIN", thisseq);\r\nstats->seqerrs++;\r\n}\r\n}\r\n} else {\r\nif (nextf != NULL && frag != NULL &&\r\nMP_LT(thisseq, minseq)) {\r\nstats->frame_drops++;\r\nmp->frags = isdn_ppp_mp_discard(mp, start, nextf);\r\n}\r\nstart = NULL;\r\n}\r\nfrag = nextf;\r\n}\r\nif (mp->frags == NULL)\r\nmp->frags = frag;\r\nif (mp->frames > MP_MAX_QUEUE_LEN) {\r\nstats->overflows++;\r\nwhile (mp->frames > MP_MAX_QUEUE_LEN) {\r\nfrag = mp->frags->next;\r\nisdn_ppp_mp_free_skb(mp, mp->frags);\r\nmp->frags = frag;\r\n}\r\n}\r\nspin_unlock_irqrestore(&mp->lock, flags);\r\n}\r\nstatic void isdn_ppp_mp_cleanup(isdn_net_local *lp)\r\n{\r\nstruct sk_buff *frag = lp->netdev->pb->frags;\r\nstruct sk_buff *nextfrag;\r\nwhile (frag) {\r\nnextfrag = frag->next;\r\nisdn_ppp_mp_free_skb(lp->netdev->pb, frag);\r\nfrag = nextfrag;\r\n}\r\nlp->netdev->pb->frags = NULL;\r\n}\r\nstatic u32 isdn_ppp_mp_get_seq(int short_seq,\r\nstruct sk_buff *skb, u32 last_seq)\r\n{\r\nu32 seq;\r\nint flags = skb->data[0] & (MP_BEGIN_FRAG | MP_END_FRAG);\r\nif (!short_seq)\r\n{\r\nseq = ntohl(*(__be32 *)skb->data) & MP_LONGSEQ_MASK;\r\nskb_push(skb, 1);\r\n}\r\nelse\r\n{\r\nseq = ntohs(*(__be16 *)skb->data) & MP_SHORTSEQ_MASK;\r\nif (!(seq & MP_SHORTSEQ_MAXBIT) &&\r\n(last_seq & MP_SHORTSEQ_MAXBIT) &&\r\n(unsigned long)last_seq <= MP_LONGSEQ_MAX)\r\nseq |= (last_seq + MP_SHORTSEQ_MAX + 1) &\r\n(~MP_SHORTSEQ_MASK & MP_LONGSEQ_MASK);\r\nelse\r\nseq |= last_seq & (~MP_SHORTSEQ_MASK & MP_LONGSEQ_MASK);\r\nskb_push(skb, 3);\r\n}\r\n*(u32 *)(skb->data + 1) = seq;\r\nskb->data[0] = flags;\r\nreturn seq;\r\n}\r\nstruct sk_buff *isdn_ppp_mp_discard(ippp_bundle *mp,\r\nstruct sk_buff *from, struct sk_buff *to)\r\n{\r\nif (from)\r\nwhile (from != to) {\r\nstruct sk_buff *next = from->next;\r\nisdn_ppp_mp_free_skb(mp, from);\r\nfrom = next;\r\n}\r\nreturn from;\r\n}\r\nvoid isdn_ppp_mp_reassembly(isdn_net_dev *net_dev, isdn_net_local *lp,\r\nstruct sk_buff *from, struct sk_buff *to)\r\n{\r\nippp_bundle *mp = net_dev->pb;\r\nint proto;\r\nstruct sk_buff *skb;\r\nunsigned int tot_len;\r\nif (lp->ppp_slot < 0 || lp->ppp_slot >= ISDN_MAX_CHANNELS) {\r\nprintk(KERN_ERR "%s: lp->ppp_slot(%d) out of range\n",\r\n__func__, lp->ppp_slot);\r\nreturn;\r\n}\r\nif (MP_FLAGS(from) == (MP_BEGIN_FRAG | MP_END_FRAG)) {\r\nif (ippp_table[lp->ppp_slot]->debug & 0x40)\r\nprintk(KERN_DEBUG "isdn_mppp: reassembly: frame %d, "\r\n"len %d\n", MP_SEQ(from), from->len);\r\nskb = from;\r\nskb_pull(skb, MP_HEADER_LEN);\r\nmp->frames--;\r\n} else {\r\nstruct sk_buff *frag;\r\nint n;\r\nfor (tot_len = n = 0, frag = from; frag != to; frag = frag->next, n++)\r\ntot_len += frag->len - MP_HEADER_LEN;\r\nif (ippp_table[lp->ppp_slot]->debug & 0x40)\r\nprintk(KERN_DEBUG"isdn_mppp: reassembling frames %d "\r\n"to %d, len %d\n", MP_SEQ(from),\r\n(MP_SEQ(from) + n - 1) & MP_LONGSEQ_MASK, tot_len);\r\nif ((skb = dev_alloc_skb(tot_len)) == NULL) {\r\nprintk(KERN_ERR "isdn_mppp: cannot allocate sk buff "\r\n"of size %d\n", tot_len);\r\nisdn_ppp_mp_discard(mp, from, to);\r\nreturn;\r\n}\r\nwhile (from != to) {\r\nunsigned int len = from->len - MP_HEADER_LEN;\r\nskb_copy_from_linear_data_offset(from, MP_HEADER_LEN,\r\nskb_put(skb, len),\r\nlen);\r\nfrag = from->next;\r\nisdn_ppp_mp_free_skb(mp, from);\r\nfrom = frag;\r\n}\r\n}\r\nproto = isdn_ppp_strip_proto(skb);\r\nisdn_ppp_push_higher(net_dev, lp, skb, proto);\r\n}\r\nstatic void isdn_ppp_mp_free_skb(ippp_bundle *mp, struct sk_buff *skb)\r\n{\r\ndev_kfree_skb(skb);\r\nmp->frames--;\r\n}\r\nstatic void isdn_ppp_mp_print_recv_pkt(int slot, struct sk_buff *skb)\r\n{\r\nprintk(KERN_DEBUG "mp_recv: %d/%d -> %02x %02x %02x %02x %02x %02x\n",\r\nslot, (int) skb->len,\r\n(int) skb->data[0], (int) skb->data[1], (int) skb->data[2],\r\n(int) skb->data[3], (int) skb->data[4], (int) skb->data[5]);\r\n}\r\nstatic int\r\nisdn_ppp_bundle(struct ippp_struct *is, int unit)\r\n{\r\nchar ifn[IFNAMSIZ + 1];\r\nisdn_net_dev *p;\r\nisdn_net_local *lp, *nlp;\r\nint rc;\r\nunsigned long flags;\r\nsprintf(ifn, "ippp%d", unit);\r\np = isdn_net_findif(ifn);\r\nif (!p) {\r\nprintk(KERN_ERR "ippp_bundle: cannot find %s\n", ifn);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&p->pb->lock, flags);\r\nnlp = is->lp;\r\nlp = p->queue;\r\nif (nlp->ppp_slot < 0 || nlp->ppp_slot >= ISDN_MAX_CHANNELS ||\r\nlp->ppp_slot < 0 || lp->ppp_slot >= ISDN_MAX_CHANNELS) {\r\nprintk(KERN_ERR "ippp_bundle: binding to invalid slot %d\n",\r\nnlp->ppp_slot < 0 || nlp->ppp_slot >= ISDN_MAX_CHANNELS ?\r\nnlp->ppp_slot : lp->ppp_slot);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nisdn_net_add_to_bundle(p, nlp);\r\nippp_table[nlp->ppp_slot]->unit = ippp_table[lp->ppp_slot]->unit;\r\nippp_table[nlp->ppp_slot]->pppcfg |= ippp_table[lp->ppp_slot]->pppcfg &\r\n(SC_ENABLE_IP | SC_NO_TCP_CCID | SC_REJ_COMP_TCP);\r\nippp_table[nlp->ppp_slot]->mpppcfg |= ippp_table[lp->ppp_slot]->mpppcfg &\r\n(SC_MP_PROT | SC_REJ_MP_PROT | SC_OUT_SHORT_SEQ | SC_IN_SHORT_SEQ);\r\nrc = isdn_ppp_mp_init(nlp, p->pb);\r\nout:\r\nspin_unlock_irqrestore(&p->pb->lock, flags);\r\nreturn rc;\r\n}\r\nstatic int\r\nisdn_ppp_dev_ioctl_stats(int slot, struct ifreq *ifr, struct net_device *dev)\r\n{\r\nstruct ppp_stats __user *res = ifr->ifr_data;\r\nstruct ppp_stats t;\r\nisdn_net_local *lp = netdev_priv(dev);\r\nif (!access_ok(VERIFY_WRITE, res, sizeof(struct ppp_stats)))\r\nreturn -EFAULT;\r\nmemset(&t, 0, sizeof(struct ppp_stats));\r\nif (dev->flags & IFF_UP) {\r\nt.p.ppp_ipackets = lp->stats.rx_packets;\r\nt.p.ppp_ibytes = lp->stats.rx_bytes;\r\nt.p.ppp_ierrors = lp->stats.rx_errors;\r\nt.p.ppp_opackets = lp->stats.tx_packets;\r\nt.p.ppp_obytes = lp->stats.tx_bytes;\r\nt.p.ppp_oerrors = lp->stats.tx_errors;\r\n#ifdef CONFIG_ISDN_PPP_VJ\r\nif (slot >= 0 && ippp_table[slot]->slcomp) {\r\nstruct slcompress *slcomp = ippp_table[slot]->slcomp;\r\nt.vj.vjs_packets = slcomp->sls_o_compressed + slcomp->sls_o_uncompressed;\r\nt.vj.vjs_compressed = slcomp->sls_o_compressed;\r\nt.vj.vjs_searches = slcomp->sls_o_searches;\r\nt.vj.vjs_misses = slcomp->sls_o_misses;\r\nt.vj.vjs_errorin = slcomp->sls_i_error;\r\nt.vj.vjs_tossed = slcomp->sls_i_tossed;\r\nt.vj.vjs_uncompressedin = slcomp->sls_i_uncompressed;\r\nt.vj.vjs_compressedin = slcomp->sls_i_compressed;\r\n}\r\n#endif\r\n}\r\nif (copy_to_user(res, &t, sizeof(struct ppp_stats)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nint\r\nisdn_ppp_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nint error = 0;\r\nint len;\r\nisdn_net_local *lp = netdev_priv(dev);\r\nif (lp->p_encap != ISDN_NET_ENCAP_SYNCPPP)\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\n#define PPP_VERSION "2.3.7"\r\ncase SIOCGPPPVER:\r\nlen = strlen(PPP_VERSION) + 1;\r\nif (copy_to_user(ifr->ifr_data, PPP_VERSION, len))\r\nerror = -EFAULT;\r\nbreak;\r\ncase SIOCGPPPSTATS:\r\nerror = isdn_ppp_dev_ioctl_stats(lp->ppp_slot, ifr, dev);\r\nbreak;\r\ndefault:\r\nerror = -EINVAL;\r\nbreak;\r\n}\r\nreturn error;\r\n}\r\nstatic int\r\nisdn_ppp_if_get_unit(char *name)\r\n{\r\nint len,\r\ni,\r\nunit = 0,\r\ndeci;\r\nlen = strlen(name);\r\nif (strncmp("ippp", name, 4) || len > 8)\r\nreturn -1;\r\nfor (i = 0, deci = 1; i < len; i++, deci *= 10) {\r\nchar a = name[len - i - 1];\r\nif (a >= '0' && a <= '9')\r\nunit += (a - '0') * deci;\r\nelse\r\nbreak;\r\n}\r\nif (!i || len - i != 4)\r\nunit = -1;\r\nreturn unit;\r\n}\r\nint\r\nisdn_ppp_dial_slave(char *name)\r\n{\r\n#ifdef CONFIG_ISDN_MPP\r\nisdn_net_dev *ndev;\r\nisdn_net_local *lp;\r\nstruct net_device *sdev;\r\nif (!(ndev = isdn_net_findif(name)))\r\nreturn 1;\r\nlp = ndev->local;\r\nif (!(lp->flags & ISDN_NET_CONNECTED))\r\nreturn 5;\r\nsdev = lp->slave;\r\nwhile (sdev) {\r\nisdn_net_local *mlp = netdev_priv(sdev);\r\nif (!(mlp->flags & ISDN_NET_CONNECTED))\r\nbreak;\r\nsdev = mlp->slave;\r\n}\r\nif (!sdev)\r\nreturn 2;\r\nisdn_net_dial_req(netdev_priv(sdev));\r\nreturn 0;\r\n#else\r\nreturn -1;\r\n#endif\r\n}\r\nint\r\nisdn_ppp_hangup_slave(char *name)\r\n{\r\n#ifdef CONFIG_ISDN_MPP\r\nisdn_net_dev *ndev;\r\nisdn_net_local *lp;\r\nstruct net_device *sdev;\r\nif (!(ndev = isdn_net_findif(name)))\r\nreturn 1;\r\nlp = ndev->local;\r\nif (!(lp->flags & ISDN_NET_CONNECTED))\r\nreturn 5;\r\nsdev = lp->slave;\r\nwhile (sdev) {\r\nisdn_net_local *mlp = netdev_priv(sdev);\r\nif (mlp->slave) {\r\nisdn_net_local *nlp = ISDN_SLAVE_PRIV(mlp);\r\nif (!(nlp->flags & ISDN_NET_CONNECTED))\r\nbreak;\r\n} else if (mlp->flags & ISDN_NET_CONNECTED)\r\nbreak;\r\nsdev = mlp->slave;\r\n}\r\nif (!sdev)\r\nreturn 2;\r\nisdn_net_hangup(sdev);\r\nreturn 0;\r\n#else\r\nreturn -1;\r\n#endif\r\n}\r\nstatic void isdn_ppp_ccp_kickup(struct ippp_struct *is)\r\n{\r\nisdn_ppp_fill_rq(NULL, 0, PPP_COMP, is->lp->ppp_slot);\r\n}\r\nstatic void isdn_ppp_ccp_xmit_reset(struct ippp_struct *is, int proto,\r\nunsigned char code, unsigned char id,\r\nunsigned char *data, int len)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned char *p;\r\nint hl;\r\nint cnt = 0;\r\nisdn_net_local *lp = is->lp;\r\nhl = dev->drv[lp->isdn_device]->interface->hl_hdrlen;\r\nskb = alloc_skb(len + hl + 16, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_WARNING\r\n"ippp: CCP cannot send reset - out of memory\n");\r\nreturn;\r\n}\r\nskb_reserve(skb, hl);\r\nif (!(is->pppcfg & SC_COMP_AC)) {\r\np = skb_put(skb, 2);\r\n*p++ = 0xff;\r\n*p++ = 0x03;\r\n}\r\np = skb_put(skb, 6);\r\n*p++ = (proto >> 8);\r\n*p++ = (proto & 0xff);\r\n*p++ = code;\r\n*p++ = id;\r\ncnt = 4 + len;\r\n*p++ = (cnt >> 8);\r\n*p++ = (cnt & 0xff);\r\nif (len) {\r\np = skb_put(skb, len);\r\nmemcpy(p, data, len);\r\n}\r\nprintk(KERN_DEBUG "Sending CCP Frame:\n");\r\nisdn_ppp_frame_log("ccp-xmit", skb->data, skb->len, 32, is->unit, lp->ppp_slot);\r\nisdn_net_write_super(lp, skb);\r\n}\r\nstatic struct ippp_ccp_reset *isdn_ppp_ccp_reset_alloc(struct ippp_struct *is)\r\n{\r\nstruct ippp_ccp_reset *r;\r\nr = kzalloc(sizeof(struct ippp_ccp_reset), GFP_KERNEL);\r\nif (!r) {\r\nprintk(KERN_ERR "ippp_ccp: failed to allocate reset data"\r\n" structure - no mem\n");\r\nreturn NULL;\r\n}\r\nprintk(KERN_DEBUG "ippp_ccp: allocated reset data structure %p\n", r);\r\nis->reset = r;\r\nreturn r;\r\n}\r\nstatic void isdn_ppp_ccp_reset_free(struct ippp_struct *is)\r\n{\r\nunsigned int id;\r\nprintk(KERN_DEBUG "ippp_ccp: freeing reset data structure %p\n",\r\nis->reset);\r\nfor (id = 0; id < 256; id++) {\r\nif (is->reset->rs[id]) {\r\nisdn_ppp_ccp_reset_free_state(is, (unsigned char)id);\r\n}\r\n}\r\nkfree(is->reset);\r\nis->reset = NULL;\r\n}\r\nstatic void isdn_ppp_ccp_reset_free_state(struct ippp_struct *is,\r\nunsigned char id)\r\n{\r\nstruct ippp_ccp_reset_state *rs;\r\nif (is->reset->rs[id]) {\r\nprintk(KERN_DEBUG "ippp_ccp: freeing state for id %d\n", id);\r\nrs = is->reset->rs[id];\r\nif (rs->ta)\r\ndel_timer(&rs->timer);\r\nis->reset->rs[id] = NULL;\r\nkfree(rs);\r\n} else {\r\nprintk(KERN_WARNING "ippp_ccp: id %d is not allocated\n", id);\r\n}\r\n}\r\nstatic void isdn_ppp_ccp_timer_callback(unsigned long closure)\r\n{\r\nstruct ippp_ccp_reset_state *rs =\r\n(struct ippp_ccp_reset_state *)closure;\r\nif (!rs) {\r\nprintk(KERN_ERR "ippp_ccp: timer cb with zero closure.\n");\r\nreturn;\r\n}\r\nif (rs->ta && rs->state == CCPResetSentReq) {\r\nif (!rs->expra) {\r\nrs->ta = 0;\r\nisdn_ppp_ccp_reset_free_state(rs->is, rs->id);\r\nreturn;\r\n}\r\nprintk(KERN_DEBUG "ippp_ccp: CCP Reset timed out for id %d\n",\r\nrs->id);\r\nisdn_ppp_ccp_xmit_reset(rs->is, PPP_CCP, CCP_RESETREQ, rs->id,\r\nrs->data, rs->dlen);\r\nrs->timer.expires = jiffies + HZ * 5;\r\nadd_timer(&rs->timer);\r\n} else {\r\nprintk(KERN_WARNING "ippp_ccp: timer cb in wrong state %d\n",\r\nrs->state);\r\n}\r\n}\r\nstatic struct ippp_ccp_reset_state *isdn_ppp_ccp_reset_alloc_state(struct ippp_struct *is,\r\nunsigned char id)\r\n{\r\nstruct ippp_ccp_reset_state *rs;\r\nif (is->reset->rs[id]) {\r\nprintk(KERN_WARNING "ippp_ccp: old state exists for id %d\n",\r\nid);\r\nreturn NULL;\r\n} else {\r\nrs = kzalloc(sizeof(struct ippp_ccp_reset_state), GFP_KERNEL);\r\nif (!rs)\r\nreturn NULL;\r\nrs->state = CCPResetIdle;\r\nrs->is = is;\r\nrs->id = id;\r\ninit_timer(&rs->timer);\r\nrs->timer.data = (unsigned long)rs;\r\nrs->timer.function = isdn_ppp_ccp_timer_callback;\r\nis->reset->rs[id] = rs;\r\n}\r\nreturn rs;\r\n}\r\nstatic void isdn_ppp_ccp_reset_trans(struct ippp_struct *is,\r\nstruct isdn_ppp_resetparams *rp)\r\n{\r\nstruct ippp_ccp_reset_state *rs;\r\nif (rp->valid) {\r\nif (rp->rsend) {\r\nif (!(rp->idval)) {\r\nprintk(KERN_ERR "ippp_ccp: decompressor must"\r\n" specify reset id\n");\r\nreturn;\r\n}\r\nif (is->reset->rs[rp->id]) {\r\nrs = is->reset->rs[rp->id];\r\nif (rs->state == CCPResetSentReq && rs->ta) {\r\nprintk(KERN_DEBUG "ippp_ccp: reset"\r\n" trans still in progress"\r\n" for id %d\n", rp->id);\r\n} else {\r\nprintk(KERN_WARNING "ippp_ccp: reset"\r\n" trans in wrong state %d for"\r\n" id %d\n", rs->state, rp->id);\r\n}\r\n} else {\r\nprintk(KERN_DEBUG "ippp_ccp: new trans for id"\r\n" %d to be started\n", rp->id);\r\nrs = isdn_ppp_ccp_reset_alloc_state(is, rp->id);\r\nif (!rs) {\r\nprintk(KERN_ERR "ippp_ccp: out of mem"\r\n" allocing ccp trans\n");\r\nreturn;\r\n}\r\nrs->state = CCPResetSentReq;\r\nrs->expra = rp->expra;\r\nif (rp->dtval) {\r\nrs->dlen = rp->dlen;\r\nmemcpy(rs->data, rp->data, rp->dlen);\r\n}\r\nisdn_ppp_ccp_xmit_reset(is, PPP_CCP,\r\nCCP_RESETREQ, rs->id,\r\nrs->data, rs->dlen);\r\nrs->timer.expires = jiffies + 5 * HZ;\r\nadd_timer(&rs->timer);\r\nrs->ta = 1;\r\n}\r\n} else {\r\nprintk(KERN_DEBUG "ippp_ccp: no reset sent\n");\r\n}\r\n} else {\r\nif (is->reset->rs[is->reset->lastid]) {\r\nrs = is->reset->rs[is->reset->lastid];\r\nif (rs->state == CCPResetSentReq && rs->ta) {\r\nprintk(KERN_DEBUG "ippp_ccp: reset"\r\n" trans still in progress"\r\n" for id %d\n", rp->id);\r\n} else {\r\nprintk(KERN_WARNING "ippp_ccp: reset"\r\n" trans in wrong state %d for"\r\n" id %d\n", rs->state, rp->id);\r\n}\r\n} else {\r\nprintk(KERN_DEBUG "ippp_ccp: new trans for id"\r\n" %d to be started\n", is->reset->lastid);\r\nrs = isdn_ppp_ccp_reset_alloc_state(is,\r\nis->reset->lastid);\r\nif (!rs) {\r\nprintk(KERN_ERR "ippp_ccp: out of mem"\r\n" allocing ccp trans\n");\r\nreturn;\r\n}\r\nrs->state = CCPResetSentReq;\r\nrs->expra = 1;\r\nrs->dlen = 0;\r\nisdn_ppp_ccp_xmit_reset(is, PPP_CCP, CCP_RESETREQ,\r\nrs->id, NULL, 0);\r\nrs->timer.expires = jiffies + 5 * HZ;\r\nadd_timer(&rs->timer);\r\nrs->ta = 1;\r\n}\r\n}\r\n}\r\nstatic void isdn_ppp_ccp_reset_ack_rcvd(struct ippp_struct *is,\r\nunsigned char id)\r\n{\r\nstruct ippp_ccp_reset_state *rs = is->reset->rs[id];\r\nif (rs) {\r\nif (rs->ta && rs->state == CCPResetSentReq) {\r\nif (!rs->expra)\r\nprintk(KERN_DEBUG "ippp_ccp: ResetAck received"\r\n" for id %d but not expected\n", id);\r\n} else {\r\nprintk(KERN_INFO "ippp_ccp: ResetAck received out of"\r\n"sync for id %d\n", id);\r\n}\r\nif (rs->ta) {\r\nrs->ta = 0;\r\ndel_timer(&rs->timer);\r\n}\r\nisdn_ppp_ccp_reset_free_state(is, id);\r\n} else {\r\nprintk(KERN_INFO "ippp_ccp: ResetAck received for unknown id"\r\n" %d\n", id);\r\n}\r\nis->reset->lastid++;\r\n}\r\nstatic struct sk_buff *isdn_ppp_decompress(struct sk_buff *skb, struct ippp_struct *is, struct ippp_struct *master,\r\nint *proto)\r\n{\r\nvoid *stat = NULL;\r\nstruct isdn_ppp_compressor *ipc = NULL;\r\nstruct sk_buff *skb_out;\r\nint len;\r\nstruct ippp_struct *ri;\r\nstruct isdn_ppp_resetparams rsparm;\r\nunsigned char rsdata[IPPP_RESET_MAXDATABYTES];\r\nif (!master) {\r\nstat = is->link_decomp_stat;\r\nipc = is->link_decompressor;\r\nri = is;\r\n} else {\r\nstat = master->decomp_stat;\r\nipc = master->decompressor;\r\nri = master;\r\n}\r\nif (!ipc) {\r\nprintk(KERN_DEBUG "ippp: no decompressor defined!\n");\r\nreturn skb;\r\n}\r\nBUG_ON(!stat);\r\nif ((master && *proto == PPP_COMP) || (!master && *proto == PPP_COMPFRAG)) {\r\nmemset(&rsparm, 0, sizeof(rsparm));\r\nrsparm.data = rsdata;\r\nrsparm.maxdlen = IPPP_RESET_MAXDATABYTES;\r\nskb_out = dev_alloc_skb(is->mru + PPP_HDRLEN);\r\nif (!skb_out) {\r\nkfree_skb(skb);\r\nprintk(KERN_ERR "ippp: decomp memory allocation failure\n");\r\nreturn NULL;\r\n}\r\nlen = ipc->decompress(stat, skb, skb_out, &rsparm);\r\nkfree_skb(skb);\r\nif (len <= 0) {\r\nswitch (len) {\r\ncase DECOMP_ERROR:\r\nprintk(KERN_INFO "ippp: decomp wants reset %s params\n",\r\nrsparm.valid ? "with" : "without");\r\nisdn_ppp_ccp_reset_trans(ri, &rsparm);\r\nbreak;\r\ncase DECOMP_FATALERROR:\r\nri->pppcfg |= SC_DC_FERROR;\r\nisdn_ppp_ccp_kickup(ri);\r\nbreak;\r\n}\r\nkfree_skb(skb_out);\r\nreturn NULL;\r\n}\r\n*proto = isdn_ppp_strip_proto(skb_out);\r\nif (*proto < 0) {\r\nkfree_skb(skb_out);\r\nreturn NULL;\r\n}\r\nreturn skb_out;\r\n} else {\r\nipc->incomp(stat, skb, *proto);\r\nreturn skb;\r\n}\r\n}\r\nstatic struct sk_buff *isdn_ppp_compress(struct sk_buff *skb_in, int *proto,\r\nstruct ippp_struct *is, struct ippp_struct *master, int type)\r\n{\r\nint ret;\r\nint new_proto;\r\nstruct isdn_ppp_compressor *compressor;\r\nvoid *stat;\r\nstruct sk_buff *skb_out;\r\nif (*proto < 0 || *proto > 0x3fff) {\r\nreturn skb_in;\r\n}\r\nif (type) {\r\nreturn skb_in;\r\n}\r\nelse {\r\nif (!master) {\r\ncompressor = is->compressor;\r\nstat = is->comp_stat;\r\n}\r\nelse {\r\ncompressor = master->compressor;\r\nstat = master->comp_stat;\r\n}\r\nnew_proto = PPP_COMP;\r\n}\r\nif (!compressor) {\r\nprintk(KERN_ERR "isdn_ppp: No compressor set!\n");\r\nreturn skb_in;\r\n}\r\nif (!stat) {\r\nprintk(KERN_ERR "isdn_ppp: Compressor not initialized?\n");\r\nreturn skb_in;\r\n}\r\nskb_out = alloc_skb(skb_in->len + skb_in->len / 2 + 32 +\r\nskb_headroom(skb_in), GFP_ATOMIC);\r\nif (!skb_out)\r\nreturn skb_in;\r\nskb_reserve(skb_out, skb_headroom(skb_in));\r\nret = (compressor->compress)(stat, skb_in, skb_out, *proto);\r\nif (!ret) {\r\ndev_kfree_skb(skb_out);\r\nreturn skb_in;\r\n}\r\ndev_kfree_skb(skb_in);\r\n*proto = new_proto;\r\nreturn skb_out;\r\n}\r\nstatic void isdn_ppp_receive_ccp(isdn_net_dev *net_dev, isdn_net_local *lp,\r\nstruct sk_buff *skb, int proto)\r\n{\r\nstruct ippp_struct *is;\r\nstruct ippp_struct *mis;\r\nint len;\r\nstruct isdn_ppp_resetparams rsparm;\r\nunsigned char rsdata[IPPP_RESET_MAXDATABYTES];\r\nprintk(KERN_DEBUG "Received CCP frame from peer slot(%d)\n",\r\nlp->ppp_slot);\r\nif (lp->ppp_slot < 0 || lp->ppp_slot >= ISDN_MAX_CHANNELS) {\r\nprintk(KERN_ERR "%s: lp->ppp_slot(%d) out of range\n",\r\n__func__, lp->ppp_slot);\r\nreturn;\r\n}\r\nis = ippp_table[lp->ppp_slot];\r\nisdn_ppp_frame_log("ccp-rcv", skb->data, skb->len, 32, is->unit, lp->ppp_slot);\r\nif (lp->master) {\r\nint slot = ISDN_MASTER_PRIV(lp)->ppp_slot;\r\nif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\r\nprintk(KERN_ERR "%s: slot(%d) out of range\n",\r\n__func__, slot);\r\nreturn;\r\n}\r\nmis = ippp_table[slot];\r\n} else\r\nmis = is;\r\nswitch (skb->data[0]) {\r\ncase CCP_CONFREQ:\r\nif (is->debug & 0x10)\r\nprintk(KERN_DEBUG "Disable compression here!\n");\r\nif (proto == PPP_CCP)\r\nmis->compflags &= ~SC_COMP_ON;\r\nelse\r\nis->compflags &= ~SC_LINK_COMP_ON;\r\nbreak;\r\ncase CCP_TERMREQ:\r\ncase CCP_TERMACK:\r\nif (is->debug & 0x10)\r\nprintk(KERN_DEBUG "Disable (de)compression here!\n");\r\nif (proto == PPP_CCP)\r\nmis->compflags &= ~(SC_DECOMP_ON | SC_COMP_ON);\r\nelse\r\nis->compflags &= ~(SC_LINK_DECOMP_ON | SC_LINK_COMP_ON);\r\nbreak;\r\ncase CCP_CONFACK:\r\nif (is->debug & 0x10)\r\nprintk(KERN_DEBUG "Enable decompression here!\n");\r\nif (proto == PPP_CCP) {\r\nif (!mis->decompressor)\r\nbreak;\r\nmis->compflags |= SC_DECOMP_ON;\r\n} else {\r\nif (!is->decompressor)\r\nbreak;\r\nis->compflags |= SC_LINK_DECOMP_ON;\r\n}\r\nbreak;\r\ncase CCP_RESETACK:\r\nprintk(KERN_DEBUG "Received ResetAck from peer\n");\r\nlen = (skb->data[2] << 8) | skb->data[3];\r\nlen -= 4;\r\nif (proto == PPP_CCP) {\r\nisdn_ppp_ccp_reset_ack_rcvd(mis, skb->data[1]);\r\nif (mis->decompressor && mis->decomp_stat)\r\nmis->decompressor->\r\nreset(mis->decomp_stat,\r\nskb->data[0],\r\nskb->data[1],\r\nlen ? &skb->data[4] : NULL,\r\nlen, NULL);\r\nmis->compflags &= ~SC_DECOMP_DISCARD;\r\n}\r\nelse {\r\nisdn_ppp_ccp_reset_ack_rcvd(is, skb->data[1]);\r\nif (is->link_decompressor && is->link_decomp_stat)\r\nis->link_decompressor->\r\nreset(is->link_decomp_stat,\r\nskb->data[0],\r\nskb->data[1],\r\nlen ? &skb->data[4] : NULL,\r\nlen, NULL);\r\nis->compflags &= ~SC_LINK_DECOMP_DISCARD;\r\n}\r\nbreak;\r\ncase CCP_RESETREQ:\r\nprintk(KERN_DEBUG "Received ResetReq from peer\n");\r\nmemset(&rsparm, 0, sizeof(rsparm));\r\nrsparm.data = rsdata;\r\nrsparm.maxdlen = IPPP_RESET_MAXDATABYTES;\r\nlen = (skb->data[2] << 8) | skb->data[3];\r\nlen -= 4;\r\nif (proto == PPP_CCP) {\r\nif (mis->compressor && mis->comp_stat)\r\nmis->compressor->\r\nreset(mis->comp_stat,\r\nskb->data[0],\r\nskb->data[1],\r\nlen ? &skb->data[4] : NULL,\r\nlen, &rsparm);\r\n}\r\nelse {\r\nif (is->link_compressor && is->link_comp_stat)\r\nis->link_compressor->\r\nreset(is->link_comp_stat,\r\nskb->data[0],\r\nskb->data[1],\r\nlen ? &skb->data[4] : NULL,\r\nlen, &rsparm);\r\n}\r\nif (rsparm.valid) {\r\nif (rsparm.rsend) {\r\nisdn_ppp_ccp_xmit_reset(is, proto, CCP_RESETACK,\r\nrsparm.idval ? rsparm.id\r\n: skb->data[1],\r\nrsparm.dtval ?\r\nrsparm.data : NULL,\r\nrsparm.dtval ?\r\nrsparm.dlen : 0);\r\n} else {\r\nprintk(KERN_DEBUG "ResetAck suppressed\n");\r\n}\r\n} else {\r\nisdn_ppp_ccp_xmit_reset(is, proto, CCP_RESETACK,\r\nskb->data[1],\r\nlen ? &skb->data[4] : NULL,\r\nlen);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void isdn_ppp_send_ccp(isdn_net_dev *net_dev, isdn_net_local *lp, struct sk_buff *skb)\r\n{\r\nstruct ippp_struct *mis, *is;\r\nint proto, slot = lp->ppp_slot;\r\nunsigned char *data;\r\nif (!skb || skb->len < 3)\r\nreturn;\r\nif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\r\nprintk(KERN_ERR "%s: lp->ppp_slot(%d) out of range\n",\r\n__func__, slot);\r\nreturn;\r\n}\r\nis = ippp_table[slot];\r\ndata = skb->data;\r\nif (!(is->pppcfg & SC_COMP_AC) && data[0] == 0xff && data[1] == 0x03) {\r\ndata += 2;\r\nif (skb->len < 5)\r\nreturn;\r\n}\r\nproto = ((int)data[0]<<8) + data[1];\r\nif (proto != PPP_CCP && proto != PPP_CCPFRAG)\r\nreturn;\r\nprintk(KERN_DEBUG "Received CCP frame from daemon:\n");\r\nisdn_ppp_frame_log("ccp-xmit", skb->data, skb->len, 32, is->unit, lp->ppp_slot);\r\nif (lp->master) {\r\nslot = ISDN_MASTER_PRIV(lp)->ppp_slot;\r\nif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\r\nprintk(KERN_ERR "%s: slot(%d) out of range\n",\r\n__func__, slot);\r\nreturn;\r\n}\r\nmis = ippp_table[slot];\r\n} else\r\nmis = is;\r\nif (mis != is)\r\nprintk(KERN_DEBUG "isdn_ppp: Ouch! Master CCP sends on slave slot!\n");\r\nswitch (data[2]) {\r\ncase CCP_CONFREQ:\r\nif (is->debug & 0x10)\r\nprintk(KERN_DEBUG "Disable decompression here!\n");\r\nif (proto == PPP_CCP)\r\nis->compflags &= ~SC_DECOMP_ON;\r\nelse\r\nis->compflags &= ~SC_LINK_DECOMP_ON;\r\nbreak;\r\ncase CCP_TERMREQ:\r\ncase CCP_TERMACK:\r\nif (is->debug & 0x10)\r\nprintk(KERN_DEBUG "Disable (de)compression here!\n");\r\nif (proto == PPP_CCP)\r\nis->compflags &= ~(SC_DECOMP_ON | SC_COMP_ON);\r\nelse\r\nis->compflags &= ~(SC_LINK_DECOMP_ON | SC_LINK_COMP_ON);\r\nbreak;\r\ncase CCP_CONFACK:\r\nif (is->debug & 0x10)\r\nprintk(KERN_DEBUG "Enable compression here!\n");\r\nif (proto == PPP_CCP) {\r\nif (!is->compressor)\r\nbreak;\r\nis->compflags |= SC_COMP_ON;\r\n} else {\r\nif (!is->compressor)\r\nbreak;\r\nis->compflags |= SC_LINK_COMP_ON;\r\n}\r\nbreak;\r\ncase CCP_RESETACK:\r\nif (is->debug & 0x10)\r\nprintk(KERN_DEBUG "Reset decompression state here!\n");\r\nprintk(KERN_DEBUG "ResetAck from daemon passed by\n");\r\nif (proto == PPP_CCP) {\r\nif (is->compressor && is->comp_stat)\r\nis->compressor->reset(is->comp_stat, 0, 0,\r\nNULL, 0, NULL);\r\nis->compflags &= ~SC_COMP_DISCARD;\r\n}\r\nelse {\r\nif (is->link_compressor && is->link_comp_stat)\r\nis->link_compressor->reset(is->link_comp_stat,\r\n0, 0, NULL, 0, NULL);\r\nis->compflags &= ~SC_LINK_COMP_DISCARD;\r\n}\r\nbreak;\r\ncase CCP_RESETREQ:\r\nprintk(KERN_DEBUG "ResetReq from daemon passed by\n");\r\nbreak;\r\n}\r\n}\r\nint isdn_ppp_register_compressor(struct isdn_ppp_compressor *ipc)\r\n{\r\nipc->next = ipc_head;\r\nipc->prev = NULL;\r\nif (ipc_head) {\r\nipc_head->prev = ipc;\r\n}\r\nipc_head = ipc;\r\nreturn 0;\r\n}\r\nint isdn_ppp_unregister_compressor(struct isdn_ppp_compressor *ipc)\r\n{\r\nif (ipc->prev)\r\nipc->prev->next = ipc->next;\r\nelse\r\nipc_head = ipc->next;\r\nif (ipc->next)\r\nipc->next->prev = ipc->prev;\r\nipc->prev = ipc->next = NULL;\r\nreturn 0;\r\n}\r\nstatic int isdn_ppp_set_compressor(struct ippp_struct *is, struct isdn_ppp_comp_data *data)\r\n{\r\nstruct isdn_ppp_compressor *ipc = ipc_head;\r\nint ret;\r\nvoid *stat;\r\nint num = data->num;\r\nif (is->debug & 0x10)\r\nprintk(KERN_DEBUG "[%d] Set %s type %d\n", is->unit,\r\n(data->flags & IPPP_COMP_FLAG_XMIT) ? "compressor" : "decompressor", num);\r\nif (!(data->flags & IPPP_COMP_FLAG_XMIT) && !is->reset) {\r\nprintk(KERN_ERR "ippp_ccp: no reset data structure - can't"\r\n" allow decompression.\n");\r\nreturn -ENOMEM;\r\n}\r\nwhile (ipc) {\r\nif (ipc->num == num) {\r\nstat = ipc->alloc(data);\r\nif (stat) {\r\nret = ipc->init(stat, data, is->unit, 0);\r\nif (!ret) {\r\nprintk(KERN_ERR "Can't init (de)compression!\n");\r\nipc->free(stat);\r\nstat = NULL;\r\nbreak;\r\n}\r\n}\r\nelse {\r\nprintk(KERN_ERR "Can't alloc (de)compression!\n");\r\nbreak;\r\n}\r\nif (data->flags & IPPP_COMP_FLAG_XMIT) {\r\nif (data->flags & IPPP_COMP_FLAG_LINK) {\r\nif (is->link_comp_stat)\r\nis->link_compressor->free(is->link_comp_stat);\r\nis->link_comp_stat = stat;\r\nis->link_compressor = ipc;\r\n}\r\nelse {\r\nif (is->comp_stat)\r\nis->compressor->free(is->comp_stat);\r\nis->comp_stat = stat;\r\nis->compressor = ipc;\r\n}\r\n}\r\nelse {\r\nif (data->flags & IPPP_COMP_FLAG_LINK) {\r\nif (is->link_decomp_stat)\r\nis->link_decompressor->free(is->link_decomp_stat);\r\nis->link_decomp_stat = stat;\r\nis->link_decompressor = ipc;\r\n}\r\nelse {\r\nif (is->decomp_stat)\r\nis->decompressor->free(is->decomp_stat);\r\nis->decomp_stat = stat;\r\nis->decompressor = ipc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nipc = ipc->next;\r\n}\r\nreturn -EINVAL;\r\n}
