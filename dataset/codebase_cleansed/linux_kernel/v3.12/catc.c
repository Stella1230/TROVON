static void catc_rx_done(struct urb *urb)\r\n{\r\nstruct catc *catc = urb->context;\r\nu8 *pkt_start = urb->transfer_buffer;\r\nstruct sk_buff *skb;\r\nint pkt_len, pkt_offset = 0;\r\nint status = urb->status;\r\nif (!catc->is_f5u011) {\r\nclear_bit(RX_RUNNING, &catc->flags);\r\npkt_offset = 2;\r\n}\r\nif (status) {\r\ndev_dbg(&urb->dev->dev, "rx_done, status %d, length %d\n",\r\nstatus, urb->actual_length);\r\nreturn;\r\n}\r\ndo {\r\nif(!catc->is_f5u011) {\r\npkt_len = le16_to_cpup((__le16*)pkt_start);\r\nif (pkt_len > urb->actual_length) {\r\ncatc->netdev->stats.rx_length_errors++;\r\ncatc->netdev->stats.rx_errors++;\r\nbreak;\r\n}\r\n} else {\r\npkt_len = urb->actual_length;\r\n}\r\nif (!(skb = dev_alloc_skb(pkt_len)))\r\nreturn;\r\nskb_copy_to_linear_data(skb, pkt_start + pkt_offset, pkt_len);\r\nskb_put(skb, pkt_len);\r\nskb->protocol = eth_type_trans(skb, catc->netdev);\r\nnetif_rx(skb);\r\ncatc->netdev->stats.rx_packets++;\r\ncatc->netdev->stats.rx_bytes += pkt_len;\r\nif (catc->is_f5u011)\r\nbreak;\r\npkt_start += (((pkt_len + 1) >> 6) + 1) << 6;\r\n} while (pkt_start - (u8 *) urb->transfer_buffer < urb->actual_length);\r\nif (catc->is_f5u011) {\r\nif (atomic_read(&catc->recq_sz)) {\r\nint state;\r\natomic_dec(&catc->recq_sz);\r\nnetdev_dbg(catc->netdev, "getting extra packet\n");\r\nurb->dev = catc->usbdev;\r\nif ((state = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {\r\nnetdev_dbg(catc->netdev,\r\n"submit(rx_urb) status %d\n", state);\r\n}\r\n} else {\r\nclear_bit(RX_RUNNING, &catc->flags);\r\n}\r\n}\r\n}\r\nstatic void catc_irq_done(struct urb *urb)\r\n{\r\nstruct catc *catc = urb->context;\r\nu8 *data = urb->transfer_buffer;\r\nint status = urb->status;\r\nunsigned int hasdata = 0, linksts = LinkNoChange;\r\nint res;\r\nif (!catc->is_f5u011) {\r\nhasdata = data[1] & 0x80;\r\nif (data[1] & 0x40)\r\nlinksts = LinkGood;\r\nelse if (data[1] & 0x20)\r\nlinksts = LinkBad;\r\n} else {\r\nhasdata = (unsigned int)(be16_to_cpup((__be16*)data) & 0x0fff);\r\nif (data[0] == 0x90)\r\nlinksts = LinkGood;\r\nelse if (data[0] == 0xA0)\r\nlinksts = LinkBad;\r\n}\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ndev_dbg(&urb->dev->dev,\r\n"irq_done, status %d, data %02x %02x.\n",\r\nstatus, data[0], data[1]);\r\ngoto resubmit;\r\n}\r\nif (linksts == LinkGood) {\r\nnetif_carrier_on(catc->netdev);\r\nnetdev_dbg(catc->netdev, "link ok\n");\r\n}\r\nif (linksts == LinkBad) {\r\nnetif_carrier_off(catc->netdev);\r\nnetdev_dbg(catc->netdev, "link bad\n");\r\n}\r\nif (hasdata) {\r\nif (test_and_set_bit(RX_RUNNING, &catc->flags)) {\r\nif (catc->is_f5u011)\r\natomic_inc(&catc->recq_sz);\r\n} else {\r\ncatc->rx_urb->dev = catc->usbdev;\r\nif ((res = usb_submit_urb(catc->rx_urb, GFP_ATOMIC)) < 0) {\r\ndev_err(&catc->usbdev->dev,\r\n"submit(rx_urb) status %d\n", res);\r\n}\r\n}\r\n}\r\nresubmit:\r\nres = usb_submit_urb (urb, GFP_ATOMIC);\r\nif (res)\r\ndev_err(&catc->usbdev->dev,\r\n"can't resubmit intr, %s-%s, status %d\n",\r\ncatc->usbdev->bus->bus_name,\r\ncatc->usbdev->devpath, res);\r\n}\r\nstatic int catc_tx_run(struct catc *catc)\r\n{\r\nint status;\r\nif (catc->is_f5u011)\r\ncatc->tx_ptr = (catc->tx_ptr + 63) & ~63;\r\ncatc->tx_urb->transfer_buffer_length = catc->tx_ptr;\r\ncatc->tx_urb->transfer_buffer = catc->tx_buf[catc->tx_idx];\r\ncatc->tx_urb->dev = catc->usbdev;\r\nif ((status = usb_submit_urb(catc->tx_urb, GFP_ATOMIC)) < 0)\r\ndev_err(&catc->usbdev->dev, "submit(tx_urb), status %d\n",\r\nstatus);\r\ncatc->tx_idx = !catc->tx_idx;\r\ncatc->tx_ptr = 0;\r\ncatc->netdev->trans_start = jiffies;\r\nreturn status;\r\n}\r\nstatic void catc_tx_done(struct urb *urb)\r\n{\r\nstruct catc *catc = urb->context;\r\nunsigned long flags;\r\nint r, status = urb->status;\r\nif (status == -ECONNRESET) {\r\ndev_dbg(&urb->dev->dev, "Tx Reset.\n");\r\nurb->status = 0;\r\ncatc->netdev->trans_start = jiffies;\r\ncatc->netdev->stats.tx_errors++;\r\nclear_bit(TX_RUNNING, &catc->flags);\r\nnetif_wake_queue(catc->netdev);\r\nreturn;\r\n}\r\nif (status) {\r\ndev_dbg(&urb->dev->dev, "tx_done, status %d, length %d\n",\r\nstatus, urb->actual_length);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&catc->tx_lock, flags);\r\nif (catc->tx_ptr) {\r\nr = catc_tx_run(catc);\r\nif (unlikely(r < 0))\r\nclear_bit(TX_RUNNING, &catc->flags);\r\n} else {\r\nclear_bit(TX_RUNNING, &catc->flags);\r\n}\r\nnetif_wake_queue(catc->netdev);\r\nspin_unlock_irqrestore(&catc->tx_lock, flags);\r\n}\r\nstatic netdev_tx_t catc_start_xmit(struct sk_buff *skb,\r\nstruct net_device *netdev)\r\n{\r\nstruct catc *catc = netdev_priv(netdev);\r\nunsigned long flags;\r\nint r = 0;\r\nchar *tx_buf;\r\nspin_lock_irqsave(&catc->tx_lock, flags);\r\ncatc->tx_ptr = (((catc->tx_ptr - 1) >> 6) + 1) << 6;\r\ntx_buf = catc->tx_buf[catc->tx_idx] + catc->tx_ptr;\r\nif (catc->is_f5u011)\r\n*(__be16 *)tx_buf = cpu_to_be16(skb->len);\r\nelse\r\n*(__le16 *)tx_buf = cpu_to_le16(skb->len);\r\nskb_copy_from_linear_data(skb, tx_buf + 2, skb->len);\r\ncatc->tx_ptr += skb->len + 2;\r\nif (!test_and_set_bit(TX_RUNNING, &catc->flags)) {\r\nr = catc_tx_run(catc);\r\nif (r < 0)\r\nclear_bit(TX_RUNNING, &catc->flags);\r\n}\r\nif ((catc->is_f5u011 && catc->tx_ptr) ||\r\n(catc->tx_ptr >= ((TX_MAX_BURST - 1) * (PKT_SZ + 2))))\r\nnetif_stop_queue(netdev);\r\nspin_unlock_irqrestore(&catc->tx_lock, flags);\r\nif (r >= 0) {\r\ncatc->netdev->stats.tx_bytes += skb->len;\r\ncatc->netdev->stats.tx_packets++;\r\n}\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void catc_tx_timeout(struct net_device *netdev)\r\n{\r\nstruct catc *catc = netdev_priv(netdev);\r\ndev_warn(&netdev->dev, "Transmit timed out.\n");\r\nusb_unlink_urb(catc->tx_urb);\r\n}\r\nstatic int catc_ctrl_msg(struct catc *catc, u8 dir, u8 request, u16 value, u16 index, void *buf, int len)\r\n{\r\nint retval = usb_control_msg(catc->usbdev,\r\ndir ? usb_rcvctrlpipe(catc->usbdev, 0) : usb_sndctrlpipe(catc->usbdev, 0),\r\nrequest, 0x40 | dir, value, index, buf, len, 1000);\r\nreturn retval < 0 ? retval : 0;\r\n}\r\nstatic void catc_ctrl_run(struct catc *catc)\r\n{\r\nstruct ctrl_queue *q = catc->ctrl_queue + catc->ctrl_tail;\r\nstruct usb_device *usbdev = catc->usbdev;\r\nstruct urb *urb = catc->ctrl_urb;\r\nstruct usb_ctrlrequest *dr = &catc->ctrl_dr;\r\nint status;\r\ndr->bRequest = q->request;\r\ndr->bRequestType = 0x40 | q->dir;\r\ndr->wValue = cpu_to_le16(q->value);\r\ndr->wIndex = cpu_to_le16(q->index);\r\ndr->wLength = cpu_to_le16(q->len);\r\nurb->pipe = q->dir ? usb_rcvctrlpipe(usbdev, 0) : usb_sndctrlpipe(usbdev, 0);\r\nurb->transfer_buffer_length = q->len;\r\nurb->transfer_buffer = catc->ctrl_buf;\r\nurb->setup_packet = (void *) dr;\r\nurb->dev = usbdev;\r\nif (!q->dir && q->buf && q->len)\r\nmemcpy(catc->ctrl_buf, q->buf, q->len);\r\nif ((status = usb_submit_urb(catc->ctrl_urb, GFP_ATOMIC)))\r\ndev_err(&catc->usbdev->dev, "submit(ctrl_urb) status %d\n",\r\nstatus);\r\n}\r\nstatic void catc_ctrl_done(struct urb *urb)\r\n{\r\nstruct catc *catc = urb->context;\r\nstruct ctrl_queue *q;\r\nunsigned long flags;\r\nint status = urb->status;\r\nif (status)\r\ndev_dbg(&urb->dev->dev, "ctrl_done, status %d, len %d.\n",\r\nstatus, urb->actual_length);\r\nspin_lock_irqsave(&catc->ctrl_lock, flags);\r\nq = catc->ctrl_queue + catc->ctrl_tail;\r\nif (q->dir) {\r\nif (q->buf && q->len)\r\nmemcpy(q->buf, catc->ctrl_buf, q->len);\r\nelse\r\nq->buf = catc->ctrl_buf;\r\n}\r\nif (q->callback)\r\nq->callback(catc, q);\r\ncatc->ctrl_tail = (catc->ctrl_tail + 1) & (CTRL_QUEUE - 1);\r\nif (catc->ctrl_head != catc->ctrl_tail)\r\ncatc_ctrl_run(catc);\r\nelse\r\nclear_bit(CTRL_RUNNING, &catc->flags);\r\nspin_unlock_irqrestore(&catc->ctrl_lock, flags);\r\n}\r\nstatic int catc_ctrl_async(struct catc *catc, u8 dir, u8 request, u16 value,\r\nu16 index, void *buf, int len, void (*callback)(struct catc *catc, struct ctrl_queue *q))\r\n{\r\nstruct ctrl_queue *q;\r\nint retval = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&catc->ctrl_lock, flags);\r\nq = catc->ctrl_queue + catc->ctrl_head;\r\nq->dir = dir;\r\nq->request = request;\r\nq->value = value;\r\nq->index = index;\r\nq->buf = buf;\r\nq->len = len;\r\nq->callback = callback;\r\ncatc->ctrl_head = (catc->ctrl_head + 1) & (CTRL_QUEUE - 1);\r\nif (catc->ctrl_head == catc->ctrl_tail) {\r\ndev_err(&catc->usbdev->dev, "ctrl queue full\n");\r\ncatc->ctrl_tail = (catc->ctrl_tail + 1) & (CTRL_QUEUE - 1);\r\nretval = -1;\r\n}\r\nif (!test_and_set_bit(CTRL_RUNNING, &catc->flags))\r\ncatc_ctrl_run(catc);\r\nspin_unlock_irqrestore(&catc->ctrl_lock, flags);\r\nreturn retval;\r\n}\r\nstatic void catc_stats_done(struct catc *catc, struct ctrl_queue *q)\r\n{\r\nint index = q->index - EthStats;\r\nu16 data, last;\r\ncatc->stats_buf[index] = *((char *)q->buf);\r\nif (index & 1)\r\nreturn;\r\ndata = ((u16)catc->stats_buf[index] << 8) | catc->stats_buf[index + 1];\r\nlast = catc->stats_vals[index >> 1];\r\nswitch (index) {\r\ncase TxSingleColl:\r\ncase TxMultiColl:\r\ncatc->netdev->stats.collisions += data - last;\r\nbreak;\r\ncase TxExcessColl:\r\ncatc->netdev->stats.tx_aborted_errors += data - last;\r\ncatc->netdev->stats.tx_errors += data - last;\r\nbreak;\r\ncase RxFramErr:\r\ncatc->netdev->stats.rx_frame_errors += data - last;\r\ncatc->netdev->stats.rx_errors += data - last;\r\nbreak;\r\n}\r\ncatc->stats_vals[index >> 1] = data;\r\n}\r\nstatic void catc_stats_timer(unsigned long data)\r\n{\r\nstruct catc *catc = (void *) data;\r\nint i;\r\nfor (i = 0; i < 8; i++)\r\ncatc_get_reg_async(catc, EthStats + 7 - i, catc_stats_done);\r\nmod_timer(&catc->timer, jiffies + STATS_UPDATE);\r\n}\r\nstatic void catc_multicast(unsigned char *addr, u8 *multicast)\r\n{\r\nu32 crc;\r\ncrc = ether_crc_le(6, addr);\r\nmulticast[(crc >> 3) & 0x3f] |= 1 << (crc & 7);\r\n}\r\nstatic void catc_set_multicast_list(struct net_device *netdev)\r\n{\r\nstruct catc *catc = netdev_priv(netdev);\r\nstruct netdev_hw_addr *ha;\r\nu8 broadcast[6];\r\nu8 rx = RxEnable | RxPolarity | RxMultiCast;\r\nmemset(broadcast, 0xff, 6);\r\nmemset(catc->multicast, 0, 64);\r\ncatc_multicast(broadcast, catc->multicast);\r\ncatc_multicast(netdev->dev_addr, catc->multicast);\r\nif (netdev->flags & IFF_PROMISC) {\r\nmemset(catc->multicast, 0xff, 64);\r\nrx |= (!catc->is_f5u011) ? RxPromisc : AltRxPromisc;\r\n}\r\nif (netdev->flags & IFF_ALLMULTI) {\r\nmemset(catc->multicast, 0xff, 64);\r\n} else {\r\nnetdev_for_each_mc_addr(ha, netdev) {\r\nu32 crc = ether_crc_le(6, ha->addr);\r\nif (!catc->is_f5u011) {\r\ncatc->multicast[(crc >> 3) & 0x3f] |= 1 << (crc & 7);\r\n} else {\r\ncatc->multicast[7-(crc >> 29)] |= 1 << ((crc >> 26) & 7);\r\n}\r\n}\r\n}\r\nif (!catc->is_f5u011) {\r\ncatc_set_reg_async(catc, RxUnit, rx);\r\ncatc_write_mem_async(catc, 0xfa80, catc->multicast, 64);\r\n} else {\r\nf5u011_mchash_async(catc, catc->multicast);\r\nif (catc->rxmode[0] != rx) {\r\ncatc->rxmode[0] = rx;\r\nnetdev_dbg(catc->netdev,\r\n"Setting RX mode to %2.2X %2.2X\n",\r\ncatc->rxmode[0], catc->rxmode[1]);\r\nf5u011_rxmode_async(catc, catc->rxmode);\r\n}\r\n}\r\n}\r\nstatic void catc_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct catc *catc = netdev_priv(dev);\r\nstrlcpy(info->driver, driver_name, sizeof(info->driver));\r\nstrlcpy(info->version, DRIVER_VERSION, sizeof(info->version));\r\nusb_make_path(catc->usbdev, info->bus_info, sizeof(info->bus_info));\r\n}\r\nstatic int catc_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct catc *catc = netdev_priv(dev);\r\nif (!catc->is_f5u011)\r\nreturn -EOPNOTSUPP;\r\ncmd->supported = SUPPORTED_10baseT_Half | SUPPORTED_TP;\r\ncmd->advertising = ADVERTISED_10baseT_Half | ADVERTISED_TP;\r\nethtool_cmd_speed_set(cmd, SPEED_10);\r\ncmd->duplex = DUPLEX_HALF;\r\ncmd->port = PORT_TP;\r\ncmd->phy_address = 0;\r\ncmd->transceiver = XCVR_INTERNAL;\r\ncmd->autoneg = AUTONEG_DISABLE;\r\ncmd->maxtxpkt = 1;\r\ncmd->maxrxpkt = 1;\r\nreturn 0;\r\n}\r\nstatic int catc_open(struct net_device *netdev)\r\n{\r\nstruct catc *catc = netdev_priv(netdev);\r\nint status;\r\ncatc->irq_urb->dev = catc->usbdev;\r\nif ((status = usb_submit_urb(catc->irq_urb, GFP_KERNEL)) < 0) {\r\ndev_err(&catc->usbdev->dev, "submit(irq_urb) status %d\n",\r\nstatus);\r\nreturn -1;\r\n}\r\nnetif_start_queue(netdev);\r\nif (!catc->is_f5u011)\r\nmod_timer(&catc->timer, jiffies + STATS_UPDATE);\r\nreturn 0;\r\n}\r\nstatic int catc_stop(struct net_device *netdev)\r\n{\r\nstruct catc *catc = netdev_priv(netdev);\r\nnetif_stop_queue(netdev);\r\nif (!catc->is_f5u011)\r\ndel_timer_sync(&catc->timer);\r\nusb_kill_urb(catc->rx_urb);\r\nusb_kill_urb(catc->tx_urb);\r\nusb_kill_urb(catc->irq_urb);\r\nusb_kill_urb(catc->ctrl_urb);\r\nreturn 0;\r\n}\r\nstatic int catc_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct device *dev = &intf->dev;\r\nstruct usb_device *usbdev = interface_to_usbdev(intf);\r\nstruct net_device *netdev;\r\nstruct catc *catc;\r\nu8 broadcast[6];\r\nint i, pktsz;\r\nif (usb_set_interface(usbdev,\r\nintf->altsetting->desc.bInterfaceNumber, 1)) {\r\ndev_err(dev, "Can't set altsetting 1.\n");\r\nreturn -EIO;\r\n}\r\nnetdev = alloc_etherdev(sizeof(struct catc));\r\nif (!netdev)\r\nreturn -ENOMEM;\r\ncatc = netdev_priv(netdev);\r\nnetdev->netdev_ops = &catc_netdev_ops;\r\nnetdev->watchdog_timeo = TX_TIMEOUT;\r\nSET_ETHTOOL_OPS(netdev, &ops);\r\ncatc->usbdev = usbdev;\r\ncatc->netdev = netdev;\r\nspin_lock_init(&catc->tx_lock);\r\nspin_lock_init(&catc->ctrl_lock);\r\ninit_timer(&catc->timer);\r\ncatc->timer.data = (long) catc;\r\ncatc->timer.function = catc_stats_timer;\r\ncatc->ctrl_urb = usb_alloc_urb(0, GFP_KERNEL);\r\ncatc->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\ncatc->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\ncatc->irq_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif ((!catc->ctrl_urb) || (!catc->tx_urb) ||\r\n(!catc->rx_urb) || (!catc->irq_urb)) {\r\ndev_err(&intf->dev, "No free urbs available.\n");\r\nusb_free_urb(catc->ctrl_urb);\r\nusb_free_urb(catc->tx_urb);\r\nusb_free_urb(catc->rx_urb);\r\nusb_free_urb(catc->irq_urb);\r\nfree_netdev(netdev);\r\nreturn -ENOMEM;\r\n}\r\nif (le16_to_cpu(usbdev->descriptor.idVendor) == 0x0423 &&\r\nle16_to_cpu(usbdev->descriptor.idProduct) == 0xa &&\r\nle16_to_cpu(catc->usbdev->descriptor.bcdDevice) == 0x0130) {\r\ndev_dbg(dev, "Testing for f5u011\n");\r\ncatc->is_f5u011 = 1;\r\natomic_set(&catc->recq_sz, 0);\r\npktsz = RX_PKT_SZ;\r\n} else {\r\npktsz = RX_MAX_BURST * (PKT_SZ + 2);\r\n}\r\nusb_fill_control_urb(catc->ctrl_urb, usbdev, usb_sndctrlpipe(usbdev, 0),\r\nNULL, NULL, 0, catc_ctrl_done, catc);\r\nusb_fill_bulk_urb(catc->tx_urb, usbdev, usb_sndbulkpipe(usbdev, 1),\r\nNULL, 0, catc_tx_done, catc);\r\nusb_fill_bulk_urb(catc->rx_urb, usbdev, usb_rcvbulkpipe(usbdev, 1),\r\ncatc->rx_buf, pktsz, catc_rx_done, catc);\r\nusb_fill_int_urb(catc->irq_urb, usbdev, usb_rcvintpipe(usbdev, 2),\r\ncatc->irq_buf, 2, catc_irq_done, catc, 1);\r\nif (!catc->is_f5u011) {\r\ndev_dbg(dev, "Checking memory size\n");\r\ni = 0x12345678;\r\ncatc_write_mem(catc, 0x7a80, &i, 4);\r\ni = 0x87654321;\r\ncatc_write_mem(catc, 0xfa80, &i, 4);\r\ncatc_read_mem(catc, 0x7a80, &i, 4);\r\nswitch (i) {\r\ncase 0x12345678:\r\ncatc_set_reg(catc, TxBufCount, 8);\r\ncatc_set_reg(catc, RxBufCount, 32);\r\ndev_dbg(dev, "64k Memory\n");\r\nbreak;\r\ndefault:\r\ndev_warn(&intf->dev,\r\n"Couldn't detect memory size, assuming 32k\n");\r\ncase 0x87654321:\r\ncatc_set_reg(catc, TxBufCount, 4);\r\ncatc_set_reg(catc, RxBufCount, 16);\r\ndev_dbg(dev, "32k Memory\n");\r\nbreak;\r\n}\r\ndev_dbg(dev, "Getting MAC from SEEROM.\n");\r\ncatc_get_mac(catc, netdev->dev_addr);\r\ndev_dbg(dev, "Setting MAC into registers.\n");\r\nfor (i = 0; i < 6; i++)\r\ncatc_set_reg(catc, StationAddr0 - i, netdev->dev_addr[i]);\r\ndev_dbg(dev, "Filling the multicast list.\n");\r\nmemset(broadcast, 0xff, 6);\r\ncatc_multicast(broadcast, catc->multicast);\r\ncatc_multicast(netdev->dev_addr, catc->multicast);\r\ncatc_write_mem(catc, 0xfa80, catc->multicast, 64);\r\ndev_dbg(dev, "Clearing error counters.\n");\r\nfor (i = 0; i < 8; i++)\r\ncatc_set_reg(catc, EthStats + i, 0);\r\ncatc->last_stats = jiffies;\r\ndev_dbg(dev, "Enabling.\n");\r\ncatc_set_reg(catc, MaxBurst, RX_MAX_BURST);\r\ncatc_set_reg(catc, OpModes, OpTxMerge | OpRxMerge | OpLenInclude | Op3MemWaits);\r\ncatc_set_reg(catc, LEDCtrl, LEDLink);\r\ncatc_set_reg(catc, RxUnit, RxEnable | RxPolarity | RxMultiCast);\r\n} else {\r\ndev_dbg(dev, "Performing reset\n");\r\ncatc_reset(catc);\r\ncatc_get_mac(catc, netdev->dev_addr);\r\ndev_dbg(dev, "Setting RX Mode\n");\r\ncatc->rxmode[0] = RxEnable | RxPolarity | RxMultiCast;\r\ncatc->rxmode[1] = 0;\r\nf5u011_rxmode(catc, catc->rxmode);\r\n}\r\ndev_dbg(dev, "Init done.\n");\r\nprintk(KERN_INFO "%s: %s USB Ethernet at usb-%s-%s, %pM.\n",\r\nnetdev->name, (catc->is_f5u011) ? "Belkin F5U011" : "CATC EL1210A NetMate",\r\nusbdev->bus->bus_name, usbdev->devpath, netdev->dev_addr);\r\nusb_set_intfdata(intf, catc);\r\nSET_NETDEV_DEV(netdev, &intf->dev);\r\nif (register_netdev(netdev) != 0) {\r\nusb_set_intfdata(intf, NULL);\r\nusb_free_urb(catc->ctrl_urb);\r\nusb_free_urb(catc->tx_urb);\r\nusb_free_urb(catc->rx_urb);\r\nusb_free_urb(catc->irq_urb);\r\nfree_netdev(netdev);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void catc_disconnect(struct usb_interface *intf)\r\n{\r\nstruct catc *catc = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nif (catc) {\r\nunregister_netdev(catc->netdev);\r\nusb_free_urb(catc->ctrl_urb);\r\nusb_free_urb(catc->tx_urb);\r\nusb_free_urb(catc->rx_urb);\r\nusb_free_urb(catc->irq_urb);\r\nfree_netdev(catc->netdev);\r\n}\r\n}
