static inline void ab_irqctl_writereg(struct irq_chip_generic *gc, u32 reg,\r\nu32 val)\r\n{\r\nirq_reg_writel(val, gc->reg_base + reg);\r\n}\r\nstatic inline u32 ab_irqctl_readreg(struct irq_chip_generic *gc, u32 reg)\r\n{\r\nreturn irq_reg_readl(gc->reg_base + reg);\r\n}\r\nstatic int tb10x_irq_set_type(struct irq_data *data, unsigned int flow_type)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(data);\r\nuint32_t im, mod, pol;\r\nim = data->mask;\r\nirq_gc_lock(gc);\r\nmod = ab_irqctl_readreg(gc, AB_IRQCTL_SRC_MODE) | im;\r\npol = ab_irqctl_readreg(gc, AB_IRQCTL_SRC_POLARITY) | im;\r\nswitch (flow_type & IRQF_TRIGGER_MASK) {\r\ncase IRQ_TYPE_EDGE_FALLING:\r\npol ^= im;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nmod ^= im;\r\nbreak;\r\ncase IRQ_TYPE_NONE:\r\nflow_type = IRQ_TYPE_LEVEL_LOW;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nmod ^= im;\r\npol ^= im;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\nbreak;\r\ndefault:\r\nirq_gc_unlock(gc);\r\npr_err("%s: Cannot assign multiple trigger modes to IRQ %d.\n",\r\n__func__, data->irq);\r\nreturn -EBADR;\r\n}\r\nirqd_set_trigger_type(data, flow_type);\r\nirq_setup_alt_chip(data, flow_type);\r\nab_irqctl_writereg(gc, AB_IRQCTL_SRC_MODE, mod);\r\nab_irqctl_writereg(gc, AB_IRQCTL_SRC_POLARITY, pol);\r\nab_irqctl_writereg(gc, AB_IRQCTL_INT_STATUS, im);\r\nirq_gc_unlock(gc);\r\nreturn IRQ_SET_MASK_OK;\r\n}\r\nstatic void tb10x_irq_cascade(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct irq_domain *domain = irq_desc_get_handler_data(desc);\r\ngeneric_handle_irq(irq_find_mapping(domain, irq));\r\n}\r\nstatic int __init of_tb10x_init_irq(struct device_node *ictl,\r\nstruct device_node *parent)\r\n{\r\nint i, ret, nrirqs = of_irq_count(ictl);\r\nstruct resource mem;\r\nstruct irq_chip_generic *gc;\r\nstruct irq_domain *domain;\r\nvoid __iomem *reg_base;\r\nif (of_address_to_resource(ictl, 0, &mem)) {\r\npr_err("%s: No registers declared in DeviceTree.\n",\r\nictl->name);\r\nreturn -EINVAL;\r\n}\r\nif (!request_mem_region(mem.start, resource_size(&mem),\r\nictl->name)) {\r\npr_err("%s: Request mem region failed.\n", ictl->name);\r\nreturn -EBUSY;\r\n}\r\nreg_base = ioremap(mem.start, resource_size(&mem));\r\nif (!reg_base) {\r\nret = -EBUSY;\r\npr_err("%s: ioremap failed.\n", ictl->name);\r\ngoto ioremap_fail;\r\n}\r\ndomain = irq_domain_add_linear(ictl, AB_IRQCTL_MAXIRQ,\r\n&irq_generic_chip_ops, NULL);\r\nif (!domain) {\r\nret = -ENOMEM;\r\npr_err("%s: Could not register interrupt domain.\n",\r\nictl->name);\r\ngoto irq_domain_add_fail;\r\n}\r\nret = irq_alloc_domain_generic_chips(domain, AB_IRQCTL_MAXIRQ,\r\n2, ictl->name, handle_level_irq,\r\nIRQ_NOREQUEST, IRQ_NOPROBE,\r\nIRQ_GC_INIT_MASK_CACHE);\r\nif (ret) {\r\npr_err("%s: Could not allocate generic interrupt chip.\n",\r\nictl->name);\r\ngoto gc_alloc_fail;\r\n}\r\ngc = domain->gc->gc[0];\r\ngc->reg_base = reg_base;\r\ngc->chip_types[0].type = IRQ_TYPE_LEVEL_MASK;\r\ngc->chip_types[0].chip.irq_mask = irq_gc_mask_clr_bit;\r\ngc->chip_types[0].chip.irq_unmask = irq_gc_mask_set_bit;\r\ngc->chip_types[0].chip.irq_set_type = tb10x_irq_set_type;\r\ngc->chip_types[0].regs.mask = AB_IRQCTL_INT_ENABLE;\r\ngc->chip_types[1].type = IRQ_TYPE_EDGE_BOTH;\r\ngc->chip_types[1].chip.name = gc->chip_types[0].chip.name;\r\ngc->chip_types[1].chip.irq_ack = irq_gc_ack_set_bit;\r\ngc->chip_types[1].chip.irq_mask = irq_gc_mask_clr_bit;\r\ngc->chip_types[1].chip.irq_unmask = irq_gc_mask_set_bit;\r\ngc->chip_types[1].chip.irq_set_type = tb10x_irq_set_type;\r\ngc->chip_types[1].regs.ack = AB_IRQCTL_INT_STATUS;\r\ngc->chip_types[1].regs.mask = AB_IRQCTL_INT_ENABLE;\r\ngc->chip_types[1].handler = handle_edge_irq;\r\nfor (i = 0; i < nrirqs; i++) {\r\nunsigned int irq = irq_of_parse_and_map(ictl, i);\r\nirq_set_handler_data(irq, domain);\r\nirq_set_chained_handler(irq, tb10x_irq_cascade);\r\n}\r\nab_irqctl_writereg(gc, AB_IRQCTL_INT_ENABLE, 0);\r\nab_irqctl_writereg(gc, AB_IRQCTL_INT_MODE, 0);\r\nab_irqctl_writereg(gc, AB_IRQCTL_INT_POLARITY, 0);\r\nab_irqctl_writereg(gc, AB_IRQCTL_INT_STATUS, ~0UL);\r\nreturn 0;\r\ngc_alloc_fail:\r\nirq_domain_remove(domain);\r\nirq_domain_add_fail:\r\niounmap(reg_base);\r\nioremap_fail:\r\nrelease_mem_region(mem.start, resource_size(&mem));\r\nreturn ret;\r\n}
