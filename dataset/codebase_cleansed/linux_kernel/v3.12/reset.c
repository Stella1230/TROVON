int mlx4_reset(struct mlx4_dev *dev)\r\n{\r\nvoid __iomem *reset;\r\nu32 *hca_header = NULL;\r\nint pcie_cap;\r\nu16 devctl;\r\nu16 linkctl;\r\nu16 vendor;\r\nunsigned long end;\r\nu32 sem;\r\nint i;\r\nint err = 0;\r\n#define MLX4_RESET_BASE 0xf0000\r\n#define MLX4_RESET_SIZE 0x400\r\n#define MLX4_SEM_OFFSET 0x3fc\r\n#define MLX4_RESET_OFFSET 0x10\r\n#define MLX4_RESET_VALUE swab32(1)\r\n#define MLX4_SEM_TIMEOUT_JIFFIES (10 * HZ)\r\n#define MLX4_RESET_TIMEOUT_JIFFIES (2 * HZ)\r\nhca_header = kmalloc(256, GFP_KERNEL);\r\nif (!hca_header) {\r\nerr = -ENOMEM;\r\nmlx4_err(dev, "Couldn't allocate memory to save HCA "\r\n"PCI header, aborting.\n");\r\ngoto out;\r\n}\r\npcie_cap = pci_pcie_cap(dev->pdev);\r\nfor (i = 0; i < 64; ++i) {\r\nif (i == 22 || i == 23)\r\ncontinue;\r\nif (pci_read_config_dword(dev->pdev, i * 4, hca_header + i)) {\r\nerr = -ENODEV;\r\nmlx4_err(dev, "Couldn't save HCA "\r\n"PCI header, aborting.\n");\r\ngoto out;\r\n}\r\n}\r\nreset = ioremap(pci_resource_start(dev->pdev, 0) + MLX4_RESET_BASE,\r\nMLX4_RESET_SIZE);\r\nif (!reset) {\r\nerr = -ENOMEM;\r\nmlx4_err(dev, "Couldn't map HCA reset register, aborting.\n");\r\ngoto out;\r\n}\r\nend = jiffies + MLX4_SEM_TIMEOUT_JIFFIES;\r\ndo {\r\nsem = readl(reset + MLX4_SEM_OFFSET);\r\nif (!sem)\r\nbreak;\r\nmsleep(1);\r\n} while (time_before(jiffies, end));\r\nif (sem) {\r\nmlx4_err(dev, "Failed to obtain HW semaphore, aborting\n");\r\nerr = -EAGAIN;\r\niounmap(reset);\r\ngoto out;\r\n}\r\nwritel(MLX4_RESET_VALUE, reset + MLX4_RESET_OFFSET);\r\niounmap(reset);\r\nmsleep(1000);\r\nend = jiffies + MLX4_RESET_TIMEOUT_JIFFIES;\r\ndo {\r\nif (!pci_read_config_word(dev->pdev, PCI_VENDOR_ID, &vendor) &&\r\nvendor != 0xffff)\r\nbreak;\r\nmsleep(1);\r\n} while (time_before(jiffies, end));\r\nif (vendor == 0xffff) {\r\nerr = -ENODEV;\r\nmlx4_err(dev, "PCI device did not come back after reset, "\r\n"aborting.\n");\r\ngoto out;\r\n}\r\nif (pcie_cap) {\r\ndevctl = hca_header[(pcie_cap + PCI_EXP_DEVCTL) / 4];\r\nif (pcie_capability_write_word(dev->pdev, PCI_EXP_DEVCTL,\r\ndevctl)) {\r\nerr = -ENODEV;\r\nmlx4_err(dev, "Couldn't restore HCA PCI Express "\r\n"Device Control register, aborting.\n");\r\ngoto out;\r\n}\r\nlinkctl = hca_header[(pcie_cap + PCI_EXP_LNKCTL) / 4];\r\nif (pcie_capability_write_word(dev->pdev, PCI_EXP_LNKCTL,\r\nlinkctl)) {\r\nerr = -ENODEV;\r\nmlx4_err(dev, "Couldn't restore HCA PCI Express "\r\n"Link control register, aborting.\n");\r\ngoto out;\r\n}\r\n}\r\nfor (i = 0; i < 16; ++i) {\r\nif (i * 4 == PCI_COMMAND)\r\ncontinue;\r\nif (pci_write_config_dword(dev->pdev, i * 4, hca_header[i])) {\r\nerr = -ENODEV;\r\nmlx4_err(dev, "Couldn't restore HCA reg %x, "\r\n"aborting.\n", i);\r\ngoto out;\r\n}\r\n}\r\nif (pci_write_config_dword(dev->pdev, PCI_COMMAND,\r\nhca_header[PCI_COMMAND / 4])) {\r\nerr = -ENODEV;\r\nmlx4_err(dev, "Couldn't restore HCA COMMAND, "\r\n"aborting.\n");\r\ngoto out;\r\n}\r\nout:\r\nkfree(hca_header);\r\nreturn err;\r\n}
