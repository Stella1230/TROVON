static int preallocate_pcm_pages(struct snd_pcm_substream *substream, size_t size)\r\n{\r\nstruct snd_dma_buffer *dmab = &substream->dma_buffer;\r\nint err;\r\nif (snd_dma_get_reserved_buf(dmab, substream->dma_buf_id) > 0) {\r\nif (dmab->bytes >= size)\r\nreturn 0;\r\nsnd_dma_free_pages(dmab);\r\ndmab->bytes = 0;\r\n}\r\ndo {\r\nif ((err = snd_dma_alloc_pages(dmab->dev.type, dmab->dev.dev,\r\nsize, dmab)) < 0) {\r\nif (err != -ENOMEM)\r\nreturn err;\r\n} else\r\nreturn 0;\r\nsize >>= 1;\r\n} while (size >= snd_minimum_buffer);\r\ndmab->bytes = 0;\r\nreturn 0;\r\n}\r\nstatic void snd_pcm_lib_preallocate_dma_free(struct snd_pcm_substream *substream)\r\n{\r\nif (substream->dma_buffer.area == NULL)\r\nreturn;\r\nif (substream->dma_buf_id)\r\nsnd_dma_reserve_buf(&substream->dma_buffer, substream->dma_buf_id);\r\nelse\r\nsnd_dma_free_pages(&substream->dma_buffer);\r\nsubstream->dma_buffer.area = NULL;\r\n}\r\nint snd_pcm_lib_preallocate_free(struct snd_pcm_substream *substream)\r\n{\r\nsnd_pcm_lib_preallocate_dma_free(substream);\r\n#ifdef CONFIG_SND_VERBOSE_PROCFS\r\nsnd_info_free_entry(substream->proc_prealloc_max_entry);\r\nsubstream->proc_prealloc_max_entry = NULL;\r\nsnd_info_free_entry(substream->proc_prealloc_entry);\r\nsubstream->proc_prealloc_entry = NULL;\r\n#endif\r\nreturn 0;\r\n}\r\nint snd_pcm_lib_preallocate_free_for_all(struct snd_pcm *pcm)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nint stream;\r\nfor (stream = 0; stream < 2; stream++)\r\nfor (substream = pcm->streams[stream].substream; substream; substream = substream->next)\r\nsnd_pcm_lib_preallocate_free(substream);\r\nreturn 0;\r\n}\r\nstatic void snd_pcm_lib_preallocate_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_pcm_substream *substream = entry->private_data;\r\nsnd_iprintf(buffer, "%lu\n", (unsigned long) substream->dma_buffer.bytes / 1024);\r\n}\r\nstatic void snd_pcm_lib_preallocate_max_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_pcm_substream *substream = entry->private_data;\r\nsnd_iprintf(buffer, "%lu\n", (unsigned long) substream->dma_max / 1024);\r\n}\r\nstatic void snd_pcm_lib_preallocate_proc_write(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_pcm_substream *substream = entry->private_data;\r\nchar line[64], str[64];\r\nsize_t size;\r\nstruct snd_dma_buffer new_dmab;\r\nif (substream->runtime) {\r\nbuffer->error = -EBUSY;\r\nreturn;\r\n}\r\nif (!snd_info_get_line(buffer, line, sizeof(line))) {\r\nsnd_info_get_str(str, line, sizeof(str));\r\nsize = simple_strtoul(str, NULL, 10) * 1024;\r\nif ((size != 0 && size < 8192) || size > substream->dma_max) {\r\nbuffer->error = -EINVAL;\r\nreturn;\r\n}\r\nif (substream->dma_buffer.bytes == size)\r\nreturn;\r\nmemset(&new_dmab, 0, sizeof(new_dmab));\r\nnew_dmab.dev = substream->dma_buffer.dev;\r\nif (size > 0) {\r\nif (snd_dma_alloc_pages(substream->dma_buffer.dev.type,\r\nsubstream->dma_buffer.dev.dev,\r\nsize, &new_dmab) < 0) {\r\nbuffer->error = -ENOMEM;\r\nreturn;\r\n}\r\nsubstream->buffer_bytes_max = size;\r\n} else {\r\nsubstream->buffer_bytes_max = UINT_MAX;\r\n}\r\nif (substream->dma_buffer.area)\r\nsnd_dma_free_pages(&substream->dma_buffer);\r\nsubstream->dma_buffer = new_dmab;\r\n} else {\r\nbuffer->error = -EINVAL;\r\n}\r\n}\r\nstatic inline void preallocate_info_init(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_info_entry *entry;\r\nif ((entry = snd_info_create_card_entry(substream->pcm->card, "prealloc", substream->proc_root)) != NULL) {\r\nentry->c.text.read = snd_pcm_lib_preallocate_proc_read;\r\nentry->c.text.write = snd_pcm_lib_preallocate_proc_write;\r\nentry->mode |= S_IWUSR;\r\nentry->private_data = substream;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nentry = NULL;\r\n}\r\n}\r\nsubstream->proc_prealloc_entry = entry;\r\nif ((entry = snd_info_create_card_entry(substream->pcm->card, "prealloc_max", substream->proc_root)) != NULL) {\r\nentry->c.text.read = snd_pcm_lib_preallocate_max_proc_read;\r\nentry->private_data = substream;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nentry = NULL;\r\n}\r\n}\r\nsubstream->proc_prealloc_max_entry = entry;\r\n}\r\nstatic int snd_pcm_lib_preallocate_pages1(struct snd_pcm_substream *substream,\r\nsize_t size, size_t max)\r\n{\r\nif (size > 0 && preallocate_dma && substream->number < maximum_substreams)\r\npreallocate_pcm_pages(substream, size);\r\nif (substream->dma_buffer.bytes > 0)\r\nsubstream->buffer_bytes_max = substream->dma_buffer.bytes;\r\nsubstream->dma_max = max;\r\npreallocate_info_init(substream);\r\nreturn 0;\r\n}\r\nint snd_pcm_lib_preallocate_pages(struct snd_pcm_substream *substream,\r\nint type, struct device *data,\r\nsize_t size, size_t max)\r\n{\r\nsubstream->dma_buffer.dev.type = type;\r\nsubstream->dma_buffer.dev.dev = data;\r\nreturn snd_pcm_lib_preallocate_pages1(substream, size, max);\r\n}\r\nint snd_pcm_lib_preallocate_pages_for_all(struct snd_pcm *pcm,\r\nint type, void *data,\r\nsize_t size, size_t max)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nint stream, err;\r\nfor (stream = 0; stream < 2; stream++)\r\nfor (substream = pcm->streams[stream].substream; substream; substream = substream->next)\r\nif ((err = snd_pcm_lib_preallocate_pages(substream, type, data, size, max)) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstruct page *snd_pcm_sgbuf_ops_page(struct snd_pcm_substream *substream, unsigned long offset)\r\n{\r\nstruct snd_sg_buf *sgbuf = snd_pcm_substream_sgbuf(substream);\r\nunsigned int idx = offset >> PAGE_SHIFT;\r\nif (idx >= (unsigned int)sgbuf->pages)\r\nreturn NULL;\r\nreturn sgbuf->page_table[idx];\r\n}\r\nint snd_pcm_lib_malloc_pages(struct snd_pcm_substream *substream, size_t size)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nstruct snd_dma_buffer *dmab = NULL;\r\nif (PCM_RUNTIME_CHECK(substream))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(substream->dma_buffer.dev.type ==\r\nSNDRV_DMA_TYPE_UNKNOWN))\r\nreturn -EINVAL;\r\nruntime = substream->runtime;\r\nif (runtime->dma_buffer_p) {\r\nif (runtime->dma_buffer_p->bytes >= size) {\r\nruntime->dma_bytes = size;\r\nreturn 0;\r\n}\r\nsnd_pcm_lib_free_pages(substream);\r\n}\r\nif (substream->dma_buffer.area != NULL &&\r\nsubstream->dma_buffer.bytes >= size) {\r\ndmab = &substream->dma_buffer;\r\n} else {\r\ndmab = kzalloc(sizeof(*dmab), GFP_KERNEL);\r\nif (! dmab)\r\nreturn -ENOMEM;\r\ndmab->dev = substream->dma_buffer.dev;\r\nif (snd_dma_alloc_pages(substream->dma_buffer.dev.type,\r\nsubstream->dma_buffer.dev.dev,\r\nsize, dmab) < 0) {\r\nkfree(dmab);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nsnd_pcm_set_runtime_buffer(substream, dmab);\r\nruntime->dma_bytes = size;\r\nreturn 1;\r\n}\r\nint snd_pcm_lib_free_pages(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nif (PCM_RUNTIME_CHECK(substream))\r\nreturn -EINVAL;\r\nruntime = substream->runtime;\r\nif (runtime->dma_area == NULL)\r\nreturn 0;\r\nif (runtime->dma_buffer_p != &substream->dma_buffer) {\r\nsnd_dma_free_pages(runtime->dma_buffer_p);\r\nkfree(runtime->dma_buffer_p);\r\n}\r\nsnd_pcm_set_runtime_buffer(substream, NULL);\r\nreturn 0;\r\n}\r\nint _snd_pcm_lib_alloc_vmalloc_buffer(struct snd_pcm_substream *substream,\r\nsize_t size, gfp_t gfp_flags)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nif (PCM_RUNTIME_CHECK(substream))\r\nreturn -EINVAL;\r\nruntime = substream->runtime;\r\nif (runtime->dma_area) {\r\nif (runtime->dma_bytes >= size)\r\nreturn 0;\r\nvfree(runtime->dma_area);\r\n}\r\nruntime->dma_area = __vmalloc(size, gfp_flags, PAGE_KERNEL);\r\nif (!runtime->dma_area)\r\nreturn -ENOMEM;\r\nruntime->dma_bytes = size;\r\nreturn 1;\r\n}\r\nint snd_pcm_lib_free_vmalloc_buffer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nif (PCM_RUNTIME_CHECK(substream))\r\nreturn -EINVAL;\r\nruntime = substream->runtime;\r\nvfree(runtime->dma_area);\r\nruntime->dma_area = NULL;\r\nreturn 0;\r\n}\r\nstruct page *snd_pcm_lib_get_vmalloc_page(struct snd_pcm_substream *substream,\r\nunsigned long offset)\r\n{\r\nreturn vmalloc_to_page(substream->runtime->dma_area + offset);\r\n}
