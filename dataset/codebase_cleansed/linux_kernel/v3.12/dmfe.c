static int dmfe_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct dmfe_board_info *db;\r\nstruct net_device *dev;\r\nu32 pci_pmr;\r\nint i, err;\r\nDMFE_DBUG(0, "dmfe_init_one()", 0);\r\nif (!printed_version++)\r\npr_info("%s\n", version);\r\n#ifdef CONFIG_TULIP_DM910X\r\nif ((ent->driver_data == PCI_DM9100_ID && pdev->revision >= 0x30) ||\r\nent->driver_data == PCI_DM9102_ID) {\r\nstruct device_node *dp = pci_device_to_OF_node(pdev);\r\nif (dp && of_get_property(dp, "local-mac-address", NULL)) {\r\npr_info("skipping on-board DM910x (use tulip)\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\n#endif\r\ndev = alloc_etherdev(sizeof(*db));\r\nif (dev == NULL)\r\nreturn -ENOMEM;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\npr_warn("32-bit PCI DMA not available\n");\r\nerr = -ENODEV;\r\ngoto err_out_free;\r\n}\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\ngoto err_out_free;\r\nif (!pci_resource_start(pdev, 0)) {\r\npr_err("I/O base is zero\n");\r\nerr = -ENODEV;\r\ngoto err_out_disable;\r\n}\r\nif (pci_resource_len(pdev, 0) < (CHK_IO_SIZE(pdev)) ) {\r\npr_err("Allocated I/O size too small\n");\r\nerr = -ENODEV;\r\ngoto err_out_disable;\r\n}\r\n#if 0\r\npci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x80);\r\n#endif\r\nif (pci_request_regions(pdev, DRV_NAME)) {\r\npr_err("Failed to request PCI regions\n");\r\nerr = -ENODEV;\r\ngoto err_out_disable;\r\n}\r\ndb = netdev_priv(dev);\r\ndb->desc_pool_ptr = pci_alloc_consistent(pdev, sizeof(struct tx_desc) *\r\nDESC_ALL_CNT + 0x20, &db->desc_pool_dma_ptr);\r\nif (!db->desc_pool_ptr) {\r\nerr = -ENOMEM;\r\ngoto err_out_res;\r\n}\r\ndb->buf_pool_ptr = pci_alloc_consistent(pdev, TX_BUF_ALLOC *\r\nTX_DESC_CNT + 4, &db->buf_pool_dma_ptr);\r\nif (!db->buf_pool_ptr) {\r\nerr = -ENOMEM;\r\ngoto err_out_free_desc;\r\n}\r\ndb->first_tx_desc = (struct tx_desc *) db->desc_pool_ptr;\r\ndb->first_tx_desc_dma = db->desc_pool_dma_ptr;\r\ndb->buf_pool_start = db->buf_pool_ptr;\r\ndb->buf_pool_dma_start = db->buf_pool_dma_ptr;\r\ndb->chip_id = ent->driver_data;\r\ndb->ioaddr = pci_iomap(pdev, 0, 0);\r\nif (!db->ioaddr) {\r\nerr = -ENOMEM;\r\ngoto err_out_free_buf;\r\n}\r\ndb->chip_revision = pdev->revision;\r\ndb->wol_mode = 0;\r\ndb->pdev = pdev;\r\npci_set_drvdata(pdev, dev);\r\ndev->netdev_ops = &netdev_ops;\r\ndev->ethtool_ops = &netdev_ethtool_ops;\r\nnetif_carrier_off(dev);\r\nspin_lock_init(&db->lock);\r\npci_read_config_dword(pdev, 0x50, &pci_pmr);\r\npci_pmr &= 0x70000;\r\nif ( (pci_pmr == 0x10000) && (db->chip_revision == 0x31) )\r\ndb->chip_type = 1;\r\nelse\r\ndb->chip_type = 0;\r\nfor (i = 0; i < 64; i++) {\r\n((__le16 *) db->srom)[i] =\r\ncpu_to_le16(read_srom_word(db->ioaddr, i));\r\n}\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = db->srom[20 + i];\r\nerr = register_netdev (dev);\r\nif (err)\r\ngoto err_out_unmap;\r\ndev_info(&dev->dev, "Davicom DM%04lx at pci%s, %pM, irq %d\n",\r\nent->driver_data >> 16,\r\npci_name(pdev), dev->dev_addr, pdev->irq);\r\npci_set_master(pdev);\r\nreturn 0;\r\nerr_out_unmap:\r\npci_iounmap(pdev, db->ioaddr);\r\nerr_out_free_buf:\r\npci_free_consistent(pdev, TX_BUF_ALLOC * TX_DESC_CNT + 4,\r\ndb->buf_pool_ptr, db->buf_pool_dma_ptr);\r\nerr_out_free_desc:\r\npci_free_consistent(pdev, sizeof(struct tx_desc) * DESC_ALL_CNT + 0x20,\r\ndb->desc_pool_ptr, db->desc_pool_dma_ptr);\r\nerr_out_res:\r\npci_release_regions(pdev);\r\nerr_out_disable:\r\npci_disable_device(pdev);\r\nerr_out_free:\r\npci_set_drvdata(pdev, NULL);\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nstatic void dmfe_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct dmfe_board_info *db = netdev_priv(dev);\r\nDMFE_DBUG(0, "dmfe_remove_one()", 0);\r\nif (dev) {\r\nunregister_netdev(dev);\r\npci_iounmap(db->pdev, db->ioaddr);\r\npci_free_consistent(db->pdev, sizeof(struct tx_desc) *\r\nDESC_ALL_CNT + 0x20, db->desc_pool_ptr,\r\ndb->desc_pool_dma_ptr);\r\npci_free_consistent(db->pdev, TX_BUF_ALLOC * TX_DESC_CNT + 4,\r\ndb->buf_pool_ptr, db->buf_pool_dma_ptr);\r\npci_release_regions(pdev);\r\nfree_netdev(dev);\r\npci_set_drvdata(pdev, NULL);\r\n}\r\nDMFE_DBUG(0, "dmfe_remove_one() exit", 0);\r\n}\r\nstatic int dmfe_open(struct DEVICE *dev)\r\n{\r\nstruct dmfe_board_info *db = netdev_priv(dev);\r\nconst int irq = db->pdev->irq;\r\nint ret;\r\nDMFE_DBUG(0, "dmfe_open", 0);\r\nret = request_irq(irq, dmfe_interrupt, IRQF_SHARED, dev->name, dev);\r\nif (ret)\r\nreturn ret;\r\ndb->cr6_data = CR6_DEFAULT | dmfe_cr6_user_set;\r\ndb->tx_packet_cnt = 0;\r\ndb->tx_queue_cnt = 0;\r\ndb->rx_avail_cnt = 0;\r\ndb->wait_reset = 0;\r\ndb->first_in_callback = 0;\r\ndb->NIC_capability = 0xf;\r\ndb->PHY_reg4 = 0x1e0;\r\nif ( !chkmode || (db->chip_id == PCI_DM9132_ID) ||\r\n(db->chip_revision >= 0x30) ) {\r\ndb->cr6_data |= DMFE_TXTH_256;\r\ndb->cr0_data = CR0_DEFAULT;\r\ndb->dm910x_chk_mode=4;\r\n} else {\r\ndb->cr6_data |= CR6_SFT;\r\ndb->cr0_data = 0;\r\ndb->dm910x_chk_mode = 1;\r\n}\r\ndmfe_init_dm910x(dev);\r\nnetif_wake_queue(dev);\r\ninit_timer(&db->timer);\r\ndb->timer.expires = DMFE_TIMER_WUT + HZ * 2;\r\ndb->timer.data = (unsigned long)dev;\r\ndb->timer.function = dmfe_timer;\r\nadd_timer(&db->timer);\r\nreturn 0;\r\n}\r\nstatic void dmfe_init_dm910x(struct DEVICE *dev)\r\n{\r\nstruct dmfe_board_info *db = netdev_priv(dev);\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nDMFE_DBUG(0, "dmfe_init_dm910x()", 0);\r\ndw32(DCR0, DM910X_RESET);\r\nudelay(100);\r\ndw32(DCR0, db->cr0_data);\r\nudelay(5);\r\ndb->phy_addr = 1;\r\ndmfe_parse_srom(db);\r\ndb->media_mode = dmfe_media_mode;\r\ndw32(DCR12, 0x180);\r\nif (db->chip_id == PCI_DM9009_ID) {\r\ndw32(DCR12, 0x80);\r\nmdelay(300);\r\n}\r\ndw32(DCR12, 0x0);\r\nif ( !(db->media_mode & 0x10) )\r\ndmfe_set_phyxcer(db);\r\nif ( !(db->media_mode & DMFE_AUTO) )\r\ndb->op_mode = db->media_mode;\r\ndmfe_descriptor_init(dev);\r\nupdate_cr6(db->cr6_data, ioaddr);\r\nif (db->chip_id == PCI_DM9132_ID)\r\ndm9132_id_table(dev);\r\nelse\r\nsend_filter_frame(dev);\r\ndb->cr7_data = CR7_DEFAULT;\r\ndw32(DCR7, db->cr7_data);\r\ndw32(DCR15, db->cr15_data);\r\ndb->cr6_data |= CR6_RXSC | CR6_TXSC | 0x40000;\r\nupdate_cr6(db->cr6_data, ioaddr);\r\n}\r\nstatic netdev_tx_t dmfe_start_xmit(struct sk_buff *skb,\r\nstruct DEVICE *dev)\r\n{\r\nstruct dmfe_board_info *db = netdev_priv(dev);\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nstruct tx_desc *txptr;\r\nunsigned long flags;\r\nDMFE_DBUG(0, "dmfe_start_xmit", 0);\r\nif (skb->len > MAX_PACKET_SIZE) {\r\npr_err("big packet = %d\n", (u16)skb->len);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nnetif_stop_queue(dev);\r\nspin_lock_irqsave(&db->lock, flags);\r\nif (db->tx_queue_cnt >= TX_FREE_DESC_CNT) {\r\nspin_unlock_irqrestore(&db->lock, flags);\r\npr_err("No Tx resource %ld\n", db->tx_queue_cnt);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\ndw32(DCR7, 0);\r\ntxptr = db->tx_insert_ptr;\r\nskb_copy_from_linear_data(skb, txptr->tx_buf_ptr, skb->len);\r\ntxptr->tdes1 = cpu_to_le32(0xe1000000 | skb->len);\r\ndb->tx_insert_ptr = txptr->next_tx_desc;\r\nif ( (!db->tx_queue_cnt) && (db->tx_packet_cnt < TX_MAX_SEND_CNT) ) {\r\ntxptr->tdes0 = cpu_to_le32(0x80000000);\r\ndb->tx_packet_cnt++;\r\ndw32(DCR1, 0x1);\r\ndev->trans_start = jiffies;\r\n} else {\r\ndb->tx_queue_cnt++;\r\ndw32(DCR1, 0x1);\r\n}\r\nif ( db->tx_queue_cnt < TX_FREE_DESC_CNT )\r\nnetif_wake_queue(dev);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\ndw32(DCR7, db->cr7_data);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int dmfe_stop(struct DEVICE *dev)\r\n{\r\nstruct dmfe_board_info *db = netdev_priv(dev);\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nDMFE_DBUG(0, "dmfe_stop", 0);\r\nnetif_stop_queue(dev);\r\ndel_timer_sync(&db->timer);\r\ndw32(DCR0, DM910X_RESET);\r\nudelay(100);\r\nphy_write(ioaddr, db->phy_addr, 0, 0x8000, db->chip_id);\r\nfree_irq(db->pdev->irq, dev);\r\ndmfe_free_rxbuffer(db);\r\n#if 0\r\nprintk("FU:%lx EC:%lx LC:%lx NC:%lx LOC:%lx TXJT:%lx RESET:%lx RCR8:%lx FAL:%lx TT:%lx\n",\r\ndb->tx_fifo_underrun, db->tx_excessive_collision,\r\ndb->tx_late_collision, db->tx_no_carrier, db->tx_loss_carrier,\r\ndb->tx_jabber_timeout, db->reset_count, db->reset_cr8,\r\ndb->reset_fatal, db->reset_TXtimeout);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic irqreturn_t dmfe_interrupt(int irq, void *dev_id)\r\n{\r\nstruct DEVICE *dev = dev_id;\r\nstruct dmfe_board_info *db = netdev_priv(dev);\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nunsigned long flags;\r\nDMFE_DBUG(0, "dmfe_interrupt()", 0);\r\nspin_lock_irqsave(&db->lock, flags);\r\ndb->cr5_data = dr32(DCR5);\r\ndw32(DCR5, db->cr5_data);\r\nif ( !(db->cr5_data & 0xc1) ) {\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\ndw32(DCR7, 0);\r\nif (db->cr5_data & 0x2000) {\r\nDMFE_DBUG(1, "System bus error happen. CR5=", db->cr5_data);\r\ndb->reset_fatal++;\r\ndb->wait_reset = 1;\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nif ( (db->cr5_data & 0x40) && db->rx_avail_cnt )\r\ndmfe_rx_packet(dev, db);\r\nif (db->rx_avail_cnt<RX_DESC_CNT)\r\nallocate_rx_buffer(dev);\r\nif ( db->cr5_data & 0x01)\r\ndmfe_free_tx_pkt(dev, db);\r\nif (db->dm910x_chk_mode & 0x2) {\r\ndb->dm910x_chk_mode = 0x4;\r\ndb->cr6_data |= 0x100;\r\nupdate_cr6(db->cr6_data, ioaddr);\r\n}\r\ndw32(DCR7, db->cr7_data);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void poll_dmfe (struct net_device *dev)\r\n{\r\nstruct dmfe_board_info *db = netdev_priv(dev);\r\nconst int irq = db->pdev->irq;\r\ndisable_irq(irq);\r\ndmfe_interrupt (irq, dev);\r\nenable_irq(irq);\r\n}\r\nstatic void dmfe_free_tx_pkt(struct DEVICE *dev, struct dmfe_board_info * db)\r\n{\r\nstruct tx_desc *txptr;\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nu32 tdes0;\r\ntxptr = db->tx_remove_ptr;\r\nwhile(db->tx_packet_cnt) {\r\ntdes0 = le32_to_cpu(txptr->tdes0);\r\nif (tdes0 & 0x80000000)\r\nbreak;\r\ndb->tx_packet_cnt--;\r\ndev->stats.tx_packets++;\r\nif ( tdes0 != 0x7fffffff ) {\r\ndev->stats.collisions += (tdes0 >> 3) & 0xf;\r\ndev->stats.tx_bytes += le32_to_cpu(txptr->tdes1) & 0x7ff;\r\nif (tdes0 & TDES0_ERR_MASK) {\r\ndev->stats.tx_errors++;\r\nif (tdes0 & 0x0002) {\r\ndb->tx_fifo_underrun++;\r\nif ( !(db->cr6_data & CR6_SFT) ) {\r\ndb->cr6_data = db->cr6_data | CR6_SFT;\r\nupdate_cr6(db->cr6_data, ioaddr);\r\n}\r\n}\r\nif (tdes0 & 0x0100)\r\ndb->tx_excessive_collision++;\r\nif (tdes0 & 0x0200)\r\ndb->tx_late_collision++;\r\nif (tdes0 & 0x0400)\r\ndb->tx_no_carrier++;\r\nif (tdes0 & 0x0800)\r\ndb->tx_loss_carrier++;\r\nif (tdes0 & 0x4000)\r\ndb->tx_jabber_timeout++;\r\n}\r\n}\r\ntxptr = txptr->next_tx_desc;\r\n}\r\ndb->tx_remove_ptr = txptr;\r\nif ( (db->tx_packet_cnt < TX_MAX_SEND_CNT) && db->tx_queue_cnt ) {\r\ntxptr->tdes0 = cpu_to_le32(0x80000000);\r\ndb->tx_packet_cnt++;\r\ndb->tx_queue_cnt--;\r\ndw32(DCR1, 0x1);\r\ndev->trans_start = jiffies;\r\n}\r\nif ( db->tx_queue_cnt < TX_WAKE_DESC_CNT )\r\nnetif_wake_queue(dev);\r\n}\r\nstatic inline u32 cal_CRC(unsigned char * Data, unsigned int Len, u8 flag)\r\n{\r\nu32 crc = crc32(~0, Data, Len);\r\nif (flag) crc = ~crc;\r\nreturn crc;\r\n}\r\nstatic void dmfe_rx_packet(struct DEVICE *dev, struct dmfe_board_info * db)\r\n{\r\nstruct rx_desc *rxptr;\r\nstruct sk_buff *skb, *newskb;\r\nint rxlen;\r\nu32 rdes0;\r\nrxptr = db->rx_ready_ptr;\r\nwhile(db->rx_avail_cnt) {\r\nrdes0 = le32_to_cpu(rxptr->rdes0);\r\nif (rdes0 & 0x80000000)\r\nbreak;\r\ndb->rx_avail_cnt--;\r\ndb->interval_rx_cnt++;\r\npci_unmap_single(db->pdev, le32_to_cpu(rxptr->rdes2),\r\nRX_ALLOC_SIZE, PCI_DMA_FROMDEVICE);\r\nif ( (rdes0 & 0x300) != 0x300) {\r\nDMFE_DBUG(0, "Reuse SK buffer, rdes0", rdes0);\r\ndmfe_reuse_skb(db, rxptr->rx_skb_ptr);\r\n} else {\r\nrxlen = ( (rdes0 >> 16) & 0x3fff) - 4;\r\nif (rdes0 & 0x8000) {\r\ndev->stats.rx_errors++;\r\nif (rdes0 & 1)\r\ndev->stats.rx_fifo_errors++;\r\nif (rdes0 & 2)\r\ndev->stats.rx_crc_errors++;\r\nif (rdes0 & 0x80)\r\ndev->stats.rx_length_errors++;\r\n}\r\nif ( !(rdes0 & 0x8000) ||\r\n((db->cr6_data & CR6_PM) && (rxlen>6)) ) {\r\nskb = rxptr->rx_skb_ptr;\r\nif ( (db->dm910x_chk_mode & 1) &&\r\n(cal_CRC(skb->data, rxlen, 1) !=\r\n(*(u32 *) (skb->data+rxlen) ))) {\r\ndmfe_reuse_skb(db, rxptr->rx_skb_ptr);\r\ndb->dm910x_chk_mode = 3;\r\n} else {\r\nif ((rxlen < RX_COPY_SIZE) &&\r\n((newskb = netdev_alloc_skb(dev, rxlen + 2))\r\n!= NULL)) {\r\nskb = newskb;\r\nskb_reserve(skb, 2);\r\nskb_copy_from_linear_data(rxptr->rx_skb_ptr,\r\nskb_put(skb, rxlen),\r\nrxlen);\r\ndmfe_reuse_skb(db, rxptr->rx_skb_ptr);\r\n} else\r\nskb_put(skb, rxlen);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += rxlen;\r\n}\r\n} else {\r\nDMFE_DBUG(0, "Reuse SK buffer, rdes0", rdes0);\r\ndmfe_reuse_skb(db, rxptr->rx_skb_ptr);\r\n}\r\n}\r\nrxptr = rxptr->next_rx_desc;\r\n}\r\ndb->rx_ready_ptr = rxptr;\r\n}\r\nstatic void dmfe_set_filter_mode(struct DEVICE * dev)\r\n{\r\nstruct dmfe_board_info *db = netdev_priv(dev);\r\nunsigned long flags;\r\nint mc_count = netdev_mc_count(dev);\r\nDMFE_DBUG(0, "dmfe_set_filter_mode()", 0);\r\nspin_lock_irqsave(&db->lock, flags);\r\nif (dev->flags & IFF_PROMISC) {\r\nDMFE_DBUG(0, "Enable PROM Mode", 0);\r\ndb->cr6_data |= CR6_PM | CR6_PBF;\r\nupdate_cr6(db->cr6_data, db->ioaddr);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nreturn;\r\n}\r\nif (dev->flags & IFF_ALLMULTI || mc_count > DMFE_MAX_MULTICAST) {\r\nDMFE_DBUG(0, "Pass all multicast address", mc_count);\r\ndb->cr6_data &= ~(CR6_PM | CR6_PBF);\r\ndb->cr6_data |= CR6_PAM;\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nreturn;\r\n}\r\nDMFE_DBUG(0, "Set multicast address", mc_count);\r\nif (db->chip_id == PCI_DM9132_ID)\r\ndm9132_id_table(dev);\r\nelse\r\nsend_filter_frame(dev);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\n}\r\nstatic void dmfe_ethtool_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct dmfe_board_info *np = netdev_priv(dev);\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(np->pdev), sizeof(info->bus_info));\r\n}\r\nstatic int dmfe_ethtool_set_wol(struct net_device *dev,\r\nstruct ethtool_wolinfo *wolinfo)\r\n{\r\nstruct dmfe_board_info *db = netdev_priv(dev);\r\nif (wolinfo->wolopts & (WAKE_UCAST | WAKE_MCAST | WAKE_BCAST |\r\nWAKE_ARP | WAKE_MAGICSECURE))\r\nreturn -EOPNOTSUPP;\r\ndb->wol_mode = wolinfo->wolopts;\r\nreturn 0;\r\n}\r\nstatic void dmfe_ethtool_get_wol(struct net_device *dev,\r\nstruct ethtool_wolinfo *wolinfo)\r\n{\r\nstruct dmfe_board_info *db = netdev_priv(dev);\r\nwolinfo->supported = WAKE_PHY | WAKE_MAGIC;\r\nwolinfo->wolopts = db->wol_mode;\r\n}\r\nstatic void dmfe_timer(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *)data;\r\nstruct dmfe_board_info *db = netdev_priv(dev);\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nu32 tmp_cr8;\r\nunsigned char tmp_cr12;\r\nunsigned long flags;\r\nint link_ok, link_ok_phy;\r\nDMFE_DBUG(0, "dmfe_timer()", 0);\r\nspin_lock_irqsave(&db->lock, flags);\r\nif (db->first_in_callback == 0) {\r\ndb->first_in_callback = 1;\r\nif (db->chip_type && (db->chip_id==PCI_DM9102_ID)) {\r\ndb->cr6_data &= ~0x40000;\r\nupdate_cr6(db->cr6_data, ioaddr);\r\nphy_write(ioaddr, db->phy_addr, 0, 0x1000, db->chip_id);\r\ndb->cr6_data |= 0x40000;\r\nupdate_cr6(db->cr6_data, ioaddr);\r\ndb->timer.expires = DMFE_TIMER_WUT + HZ * 2;\r\nadd_timer(&db->timer);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nreturn;\r\n}\r\n}\r\nif ( (db->dm910x_chk_mode & 0x1) &&\r\n(dev->stats.rx_packets > MAX_CHECK_PACKET) )\r\ndb->dm910x_chk_mode = 0x4;\r\ntmp_cr8 = dr32(DCR8);\r\nif ( (db->interval_rx_cnt==0) && (tmp_cr8) ) {\r\ndb->reset_cr8++;\r\ndb->wait_reset = 1;\r\n}\r\ndb->interval_rx_cnt = 0;\r\nif ( db->tx_packet_cnt &&\r\ntime_after(jiffies, dev_trans_start(dev) + DMFE_TX_KICK) ) {\r\ndw32(DCR1, 0x1);\r\nif (time_after(jiffies, dev_trans_start(dev) + DMFE_TX_TIMEOUT) ) {\r\ndb->reset_TXtimeout++;\r\ndb->wait_reset = 1;\r\ndev_warn(&dev->dev, "Tx timeout - resetting\n");\r\n}\r\n}\r\nif (db->wait_reset) {\r\nDMFE_DBUG(0, "Dynamic Reset device", db->tx_packet_cnt);\r\ndb->reset_count++;\r\ndmfe_dynamic_reset(dev);\r\ndb->first_in_callback = 0;\r\ndb->timer.expires = DMFE_TIMER_WUT;\r\nadd_timer(&db->timer);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nreturn;\r\n}\r\nif (db->chip_id == PCI_DM9132_ID)\r\ntmp_cr12 = dr8(DCR9 + 3);\r\nelse\r\ntmp_cr12 = dr8(DCR12);\r\nif ( ((db->chip_id == PCI_DM9102_ID) &&\r\n(db->chip_revision == 0x30)) ||\r\n((db->chip_id == PCI_DM9132_ID) &&\r\n(db->chip_revision == 0x10)) ) {\r\nif (tmp_cr12 & 2)\r\nlink_ok = 0;\r\nelse\r\nlink_ok = 1;\r\n}\r\nelse\r\nlink_ok = (tmp_cr12 & 0x43) ? 1 : 0;\r\nphy_read (db->ioaddr, db->phy_addr, 1, db->chip_id);\r\nlink_ok_phy = (phy_read (db->ioaddr,\r\ndb->phy_addr, 1, db->chip_id) & 0x4) ? 1 : 0;\r\nif (link_ok_phy != link_ok) {\r\nDMFE_DBUG (0, "PHY and chip report different link status", 0);\r\nlink_ok = link_ok | link_ok_phy;\r\n}\r\nif ( !link_ok && netif_carrier_ok(dev)) {\r\nDMFE_DBUG(0, "Link Failed", tmp_cr12);\r\nnetif_carrier_off(dev);\r\nif ( !(db->media_mode & 0x38) )\r\nphy_write(db->ioaddr, db->phy_addr,\r\n0, 0x1000, db->chip_id);\r\nif (db->media_mode & DMFE_AUTO) {\r\ndb->cr6_data|=0x00040000;\r\ndb->cr6_data&=~0x00000200;\r\nupdate_cr6(db->cr6_data, ioaddr);\r\n}\r\n} else if (!netif_carrier_ok(dev)) {\r\nDMFE_DBUG(0, "Link link OK", tmp_cr12);\r\nif ( !(db->media_mode & DMFE_AUTO) || !dmfe_sense_speed(db)) {\r\nnetif_carrier_on(dev);\r\nSHOW_MEDIA_TYPE(db->op_mode);\r\n}\r\ndmfe_process_mode(db);\r\n}\r\nif (db->HPNA_command & 0xf00) {\r\ndb->HPNA_timer--;\r\nif (!db->HPNA_timer)\r\ndmfe_HPNA_remote_cmd_chk(db);\r\n}\r\ndb->timer.expires = DMFE_TIMER_WUT;\r\nadd_timer(&db->timer);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\n}\r\nstatic void dmfe_dynamic_reset(struct net_device *dev)\r\n{\r\nstruct dmfe_board_info *db = netdev_priv(dev);\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nDMFE_DBUG(0, "dmfe_dynamic_reset()", 0);\r\ndb->cr6_data &= ~(CR6_RXSC | CR6_TXSC);\r\nupdate_cr6(db->cr6_data, ioaddr);\r\ndw32(DCR7, 0);\r\ndw32(DCR5, dr32(DCR5));\r\nnetif_stop_queue(dev);\r\ndmfe_free_rxbuffer(db);\r\ndb->tx_packet_cnt = 0;\r\ndb->tx_queue_cnt = 0;\r\ndb->rx_avail_cnt = 0;\r\nnetif_carrier_off(dev);\r\ndb->wait_reset = 0;\r\ndmfe_init_dm910x(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void dmfe_free_rxbuffer(struct dmfe_board_info * db)\r\n{\r\nDMFE_DBUG(0, "dmfe_free_rxbuffer()", 0);\r\nwhile (db->rx_avail_cnt) {\r\ndev_kfree_skb(db->rx_ready_ptr->rx_skb_ptr);\r\ndb->rx_ready_ptr = db->rx_ready_ptr->next_rx_desc;\r\ndb->rx_avail_cnt--;\r\n}\r\n}\r\nstatic void dmfe_reuse_skb(struct dmfe_board_info *db, struct sk_buff * skb)\r\n{\r\nstruct rx_desc *rxptr = db->rx_insert_ptr;\r\nif (!(rxptr->rdes0 & cpu_to_le32(0x80000000))) {\r\nrxptr->rx_skb_ptr = skb;\r\nrxptr->rdes2 = cpu_to_le32( pci_map_single(db->pdev,\r\nskb->data, RX_ALLOC_SIZE, PCI_DMA_FROMDEVICE) );\r\nwmb();\r\nrxptr->rdes0 = cpu_to_le32(0x80000000);\r\ndb->rx_avail_cnt++;\r\ndb->rx_insert_ptr = rxptr->next_rx_desc;\r\n} else\r\nDMFE_DBUG(0, "SK Buffer reuse method error", db->rx_avail_cnt);\r\n}\r\nstatic void dmfe_descriptor_init(struct net_device *dev)\r\n{\r\nstruct dmfe_board_info *db = netdev_priv(dev);\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nstruct tx_desc *tmp_tx;\r\nstruct rx_desc *tmp_rx;\r\nunsigned char *tmp_buf;\r\ndma_addr_t tmp_tx_dma, tmp_rx_dma;\r\ndma_addr_t tmp_buf_dma;\r\nint i;\r\nDMFE_DBUG(0, "dmfe_descriptor_init()", 0);\r\ndb->tx_insert_ptr = db->first_tx_desc;\r\ndb->tx_remove_ptr = db->first_tx_desc;\r\ndw32(DCR4, db->first_tx_desc_dma);\r\ndb->first_rx_desc = (void *)db->first_tx_desc +\r\nsizeof(struct tx_desc) * TX_DESC_CNT;\r\ndb->first_rx_desc_dma = db->first_tx_desc_dma +\r\nsizeof(struct tx_desc) * TX_DESC_CNT;\r\ndb->rx_insert_ptr = db->first_rx_desc;\r\ndb->rx_ready_ptr = db->first_rx_desc;\r\ndw32(DCR3, db->first_rx_desc_dma);\r\ntmp_buf = db->buf_pool_start;\r\ntmp_buf_dma = db->buf_pool_dma_start;\r\ntmp_tx_dma = db->first_tx_desc_dma;\r\nfor (tmp_tx = db->first_tx_desc, i = 0; i < TX_DESC_CNT; i++, tmp_tx++) {\r\ntmp_tx->tx_buf_ptr = tmp_buf;\r\ntmp_tx->tdes0 = cpu_to_le32(0);\r\ntmp_tx->tdes1 = cpu_to_le32(0x81000000);\r\ntmp_tx->tdes2 = cpu_to_le32(tmp_buf_dma);\r\ntmp_tx_dma += sizeof(struct tx_desc);\r\ntmp_tx->tdes3 = cpu_to_le32(tmp_tx_dma);\r\ntmp_tx->next_tx_desc = tmp_tx + 1;\r\ntmp_buf = tmp_buf + TX_BUF_ALLOC;\r\ntmp_buf_dma = tmp_buf_dma + TX_BUF_ALLOC;\r\n}\r\n(--tmp_tx)->tdes3 = cpu_to_le32(db->first_tx_desc_dma);\r\ntmp_tx->next_tx_desc = db->first_tx_desc;\r\ntmp_rx_dma=db->first_rx_desc_dma;\r\nfor (tmp_rx = db->first_rx_desc, i = 0; i < RX_DESC_CNT; i++, tmp_rx++) {\r\ntmp_rx->rdes0 = cpu_to_le32(0);\r\ntmp_rx->rdes1 = cpu_to_le32(0x01000600);\r\ntmp_rx_dma += sizeof(struct rx_desc);\r\ntmp_rx->rdes3 = cpu_to_le32(tmp_rx_dma);\r\ntmp_rx->next_rx_desc = tmp_rx + 1;\r\n}\r\n(--tmp_rx)->rdes3 = cpu_to_le32(db->first_rx_desc_dma);\r\ntmp_rx->next_rx_desc = db->first_rx_desc;\r\nallocate_rx_buffer(dev);\r\n}\r\nstatic void update_cr6(u32 cr6_data, void __iomem *ioaddr)\r\n{\r\nu32 cr6_tmp;\r\ncr6_tmp = cr6_data & ~0x2002;\r\ndw32(DCR6, cr6_tmp);\r\nudelay(5);\r\ndw32(DCR6, cr6_data);\r\nudelay(5);\r\n}\r\nstatic void dm9132_id_table(struct net_device *dev)\r\n{\r\nstruct dmfe_board_info *db = netdev_priv(dev);\r\nvoid __iomem *ioaddr = db->ioaddr + 0xc0;\r\nu16 *addrptr = (u16 *)dev->dev_addr;\r\nstruct netdev_hw_addr *ha;\r\nu16 i, hash_table[4];\r\nfor (i = 0; i < 3; i++) {\r\ndw16(0, addrptr[i]);\r\nioaddr += 4;\r\n}\r\nmemset(hash_table, 0, sizeof(hash_table));\r\nhash_table[3] = 0x8000;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nu32 hash_val = cal_CRC((char *)ha->addr, 6, 0) & 0x3f;\r\nhash_table[hash_val / 16] |= (u16) 1 << (hash_val % 16);\r\n}\r\nfor (i = 0; i < 4; i++, ioaddr += 4)\r\ndw16(0, hash_table[i]);\r\n}\r\nstatic void send_filter_frame(struct net_device *dev)\r\n{\r\nstruct dmfe_board_info *db = netdev_priv(dev);\r\nstruct netdev_hw_addr *ha;\r\nstruct tx_desc *txptr;\r\nu16 * addrptr;\r\nu32 * suptr;\r\nint i;\r\nDMFE_DBUG(0, "send_filter_frame()", 0);\r\ntxptr = db->tx_insert_ptr;\r\nsuptr = (u32 *) txptr->tx_buf_ptr;\r\naddrptr = (u16 *) dev->dev_addr;\r\n*suptr++ = addrptr[0];\r\n*suptr++ = addrptr[1];\r\n*suptr++ = addrptr[2];\r\n*suptr++ = 0xffff;\r\n*suptr++ = 0xffff;\r\n*suptr++ = 0xffff;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\naddrptr = (u16 *) ha->addr;\r\n*suptr++ = addrptr[0];\r\n*suptr++ = addrptr[1];\r\n*suptr++ = addrptr[2];\r\n}\r\nfor (i = netdev_mc_count(dev); i < 14; i++) {\r\n*suptr++ = 0xffff;\r\n*suptr++ = 0xffff;\r\n*suptr++ = 0xffff;\r\n}\r\ndb->tx_insert_ptr = txptr->next_tx_desc;\r\ntxptr->tdes1 = cpu_to_le32(0x890000c0);\r\nif (!db->tx_packet_cnt) {\r\nvoid __iomem *ioaddr = db->ioaddr;\r\ndb->tx_packet_cnt++;\r\ntxptr->tdes0 = cpu_to_le32(0x80000000);\r\nupdate_cr6(db->cr6_data | 0x2000, ioaddr);\r\ndw32(DCR1, 0x1);\r\nupdate_cr6(db->cr6_data, ioaddr);\r\ndev->trans_start = jiffies;\r\n} else\r\ndb->tx_queue_cnt++;\r\n}\r\nstatic void allocate_rx_buffer(struct net_device *dev)\r\n{\r\nstruct dmfe_board_info *db = netdev_priv(dev);\r\nstruct rx_desc *rxptr;\r\nstruct sk_buff *skb;\r\nrxptr = db->rx_insert_ptr;\r\nwhile(db->rx_avail_cnt < RX_DESC_CNT) {\r\nif ( ( skb = netdev_alloc_skb(dev, RX_ALLOC_SIZE) ) == NULL )\r\nbreak;\r\nrxptr->rx_skb_ptr = skb;\r\nrxptr->rdes2 = cpu_to_le32( pci_map_single(db->pdev, skb->data,\r\nRX_ALLOC_SIZE, PCI_DMA_FROMDEVICE) );\r\nwmb();\r\nrxptr->rdes0 = cpu_to_le32(0x80000000);\r\nrxptr = rxptr->next_rx_desc;\r\ndb->rx_avail_cnt++;\r\n}\r\ndb->rx_insert_ptr = rxptr;\r\n}\r\nstatic void srom_clk_write(void __iomem *ioaddr, u32 data)\r\n{\r\nstatic const u32 cmd[] = {\r\nCR9_SROM_READ | CR9_SRCS,\r\nCR9_SROM_READ | CR9_SRCS | CR9_SRCLK,\r\nCR9_SROM_READ | CR9_SRCS\r\n};\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cmd); i++) {\r\ndw32(DCR9, data | cmd[i]);\r\nudelay(5);\r\n}\r\n}\r\nstatic u16 read_srom_word(void __iomem *ioaddr, int offset)\r\n{\r\nu16 srom_data;\r\nint i;\r\ndw32(DCR9, CR9_SROM_READ);\r\nudelay(5);\r\ndw32(DCR9, CR9_SROM_READ | CR9_SRCS);\r\nudelay(5);\r\nsrom_clk_write(ioaddr, SROM_DATA_1);\r\nsrom_clk_write(ioaddr, SROM_DATA_1);\r\nsrom_clk_write(ioaddr, SROM_DATA_0);\r\nfor (i = 5; i >= 0; i--) {\r\nsrom_data = (offset & (1 << i)) ? SROM_DATA_1 : SROM_DATA_0;\r\nsrom_clk_write(ioaddr, srom_data);\r\n}\r\ndw32(DCR9, CR9_SROM_READ | CR9_SRCS);\r\nudelay(5);\r\nfor (i = 16; i > 0; i--) {\r\ndw32(DCR9, CR9_SROM_READ | CR9_SRCS | CR9_SRCLK);\r\nudelay(5);\r\nsrom_data = (srom_data << 1) |\r\n((dr32(DCR9) & CR9_CRDOUT) ? 1 : 0);\r\ndw32(DCR9, CR9_SROM_READ | CR9_SRCS);\r\nudelay(5);\r\n}\r\ndw32(DCR9, CR9_SROM_READ);\r\nudelay(5);\r\nreturn srom_data;\r\n}\r\nstatic u8 dmfe_sense_speed(struct dmfe_board_info *db)\r\n{\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nu8 ErrFlag = 0;\r\nu16 phy_mode;\r\nupdate_cr6(db->cr6_data & ~0x40000, ioaddr);\r\nphy_mode = phy_read(db->ioaddr, db->phy_addr, 1, db->chip_id);\r\nphy_mode = phy_read(db->ioaddr, db->phy_addr, 1, db->chip_id);\r\nif ( (phy_mode & 0x24) == 0x24 ) {\r\nif (db->chip_id == PCI_DM9132_ID)\r\nphy_mode = phy_read(db->ioaddr,\r\ndb->phy_addr, 7, db->chip_id) & 0xf000;\r\nelse\r\nphy_mode = phy_read(db->ioaddr,\r\ndb->phy_addr, 17, db->chip_id) & 0xf000;\r\nswitch (phy_mode) {\r\ncase 0x1000: db->op_mode = DMFE_10MHF; break;\r\ncase 0x2000: db->op_mode = DMFE_10MFD; break;\r\ncase 0x4000: db->op_mode = DMFE_100MHF; break;\r\ncase 0x8000: db->op_mode = DMFE_100MFD; break;\r\ndefault: db->op_mode = DMFE_10MHF;\r\nErrFlag = 1;\r\nbreak;\r\n}\r\n} else {\r\ndb->op_mode = DMFE_10MHF;\r\nDMFE_DBUG(0, "Link Failed :", phy_mode);\r\nErrFlag = 1;\r\n}\r\nreturn ErrFlag;\r\n}\r\nstatic void dmfe_set_phyxcer(struct dmfe_board_info *db)\r\n{\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nu16 phy_reg;\r\ndb->cr6_data &= ~0x40000;\r\nupdate_cr6(db->cr6_data, ioaddr);\r\nif (db->chip_id == PCI_DM9009_ID) {\r\nphy_reg = phy_read(db->ioaddr,\r\ndb->phy_addr, 18, db->chip_id) & ~0x1000;\r\nphy_write(db->ioaddr,\r\ndb->phy_addr, 18, phy_reg, db->chip_id);\r\n}\r\nphy_reg = phy_read(db->ioaddr, db->phy_addr, 4, db->chip_id) & ~0x01e0;\r\nif (db->media_mode & DMFE_AUTO) {\r\nphy_reg |= db->PHY_reg4;\r\n} else {\r\nswitch(db->media_mode) {\r\ncase DMFE_10MHF: phy_reg |= 0x20; break;\r\ncase DMFE_10MFD: phy_reg |= 0x40; break;\r\ncase DMFE_100MHF: phy_reg |= 0x80; break;\r\ncase DMFE_100MFD: phy_reg |= 0x100; break;\r\n}\r\nif (db->chip_id == PCI_DM9009_ID) phy_reg &= 0x61;\r\n}\r\nif ( !(phy_reg & 0x01e0)) {\r\nphy_reg|=db->PHY_reg4;\r\ndb->media_mode|=DMFE_AUTO;\r\n}\r\nphy_write(db->ioaddr, db->phy_addr, 4, phy_reg, db->chip_id);\r\nif ( db->chip_type && (db->chip_id == PCI_DM9102_ID) )\r\nphy_write(db->ioaddr, db->phy_addr, 0, 0x1800, db->chip_id);\r\nif ( !db->chip_type )\r\nphy_write(db->ioaddr, db->phy_addr, 0, 0x1200, db->chip_id);\r\n}\r\nstatic void dmfe_process_mode(struct dmfe_board_info *db)\r\n{\r\nu16 phy_reg;\r\nif (db->op_mode & 0x4)\r\ndb->cr6_data |= CR6_FDM;\r\nelse\r\ndb->cr6_data &= ~CR6_FDM;\r\nif (db->op_mode & 0x10)\r\ndb->cr6_data |= 0x40000;\r\nelse\r\ndb->cr6_data &= ~0x40000;\r\nupdate_cr6(db->cr6_data, db->ioaddr);\r\nif ( !(db->media_mode & 0x18)) {\r\nphy_reg = phy_read(db->ioaddr, db->phy_addr, 6, db->chip_id);\r\nif ( !(phy_reg & 0x1) ) {\r\nphy_reg = 0x0;\r\nswitch(db->op_mode) {\r\ncase DMFE_10MHF: phy_reg = 0x0; break;\r\ncase DMFE_10MFD: phy_reg = 0x100; break;\r\ncase DMFE_100MHF: phy_reg = 0x2000; break;\r\ncase DMFE_100MFD: phy_reg = 0x2100; break;\r\n}\r\nphy_write(db->ioaddr,\r\ndb->phy_addr, 0, phy_reg, db->chip_id);\r\nif ( db->chip_type && (db->chip_id == PCI_DM9102_ID) )\r\nmdelay(20);\r\nphy_write(db->ioaddr,\r\ndb->phy_addr, 0, phy_reg, db->chip_id);\r\n}\r\n}\r\n}\r\nstatic void phy_write(void __iomem *ioaddr, u8 phy_addr, u8 offset,\r\nu16 phy_data, u32 chip_id)\r\n{\r\nu16 i;\r\nif (chip_id == PCI_DM9132_ID) {\r\ndw16(0x80 + offset * 4, phy_data);\r\n} else {\r\nfor (i = 0; i < 35; i++)\r\nphy_write_1bit(ioaddr, PHY_DATA_1);\r\nphy_write_1bit(ioaddr, PHY_DATA_0);\r\nphy_write_1bit(ioaddr, PHY_DATA_1);\r\nphy_write_1bit(ioaddr, PHY_DATA_0);\r\nphy_write_1bit(ioaddr, PHY_DATA_1);\r\nfor (i = 0x10; i > 0; i = i >> 1)\r\nphy_write_1bit(ioaddr,\r\nphy_addr & i ? PHY_DATA_1 : PHY_DATA_0);\r\nfor (i = 0x10; i > 0; i = i >> 1)\r\nphy_write_1bit(ioaddr,\r\noffset & i ? PHY_DATA_1 : PHY_DATA_0);\r\nphy_write_1bit(ioaddr, PHY_DATA_1);\r\nphy_write_1bit(ioaddr, PHY_DATA_0);\r\nfor ( i = 0x8000; i > 0; i >>= 1)\r\nphy_write_1bit(ioaddr,\r\nphy_data & i ? PHY_DATA_1 : PHY_DATA_0);\r\n}\r\n}\r\nstatic u16 phy_read(void __iomem *ioaddr, u8 phy_addr, u8 offset, u32 chip_id)\r\n{\r\nint i;\r\nu16 phy_data;\r\nif (chip_id == PCI_DM9132_ID) {\r\nphy_data = dr16(0x80 + offset * 4);\r\n} else {\r\nfor (i = 0; i < 35; i++)\r\nphy_write_1bit(ioaddr, PHY_DATA_1);\r\nphy_write_1bit(ioaddr, PHY_DATA_0);\r\nphy_write_1bit(ioaddr, PHY_DATA_1);\r\nphy_write_1bit(ioaddr, PHY_DATA_1);\r\nphy_write_1bit(ioaddr, PHY_DATA_0);\r\nfor (i = 0x10; i > 0; i = i >> 1)\r\nphy_write_1bit(ioaddr,\r\nphy_addr & i ? PHY_DATA_1 : PHY_DATA_0);\r\nfor (i = 0x10; i > 0; i = i >> 1)\r\nphy_write_1bit(ioaddr,\r\noffset & i ? PHY_DATA_1 : PHY_DATA_0);\r\nphy_read_1bit(ioaddr);\r\nfor (phy_data = 0, i = 0; i < 16; i++) {\r\nphy_data <<= 1;\r\nphy_data |= phy_read_1bit(ioaddr);\r\n}\r\n}\r\nreturn phy_data;\r\n}\r\nstatic void phy_write_1bit(void __iomem *ioaddr, u32 phy_data)\r\n{\r\ndw32(DCR9, phy_data);\r\nudelay(1);\r\ndw32(DCR9, phy_data | MDCLKH);\r\nudelay(1);\r\ndw32(DCR9, phy_data);\r\nudelay(1);\r\n}\r\nstatic u16 phy_read_1bit(void __iomem *ioaddr)\r\n{\r\nu16 phy_data;\r\ndw32(DCR9, 0x50000);\r\nudelay(1);\r\nphy_data = (dr32(DCR9) >> 19) & 0x1;\r\ndw32(DCR9, 0x40000);\r\nudelay(1);\r\nreturn phy_data;\r\n}\r\nstatic void dmfe_parse_srom(struct dmfe_board_info * db)\r\n{\r\nchar * srom = db->srom;\r\nint dmfe_mode, tmp_reg;\r\nDMFE_DBUG(0, "dmfe_parse_srom() ", 0);\r\ndb->cr15_data = CR15_DEFAULT;\r\nif ( ( (int) srom[18] & 0xff) == SROM_V41_CODE) {\r\ndb->NIC_capability = le16_to_cpup((__le16 *) (srom + 34));\r\ndb->PHY_reg4 = 0;\r\nfor (tmp_reg = 1; tmp_reg < 0x10; tmp_reg <<= 1) {\r\nswitch( db->NIC_capability & tmp_reg ) {\r\ncase 0x1: db->PHY_reg4 |= 0x0020; break;\r\ncase 0x2: db->PHY_reg4 |= 0x0040; break;\r\ncase 0x4: db->PHY_reg4 |= 0x0080; break;\r\ncase 0x8: db->PHY_reg4 |= 0x0100; break;\r\n}\r\n}\r\ndmfe_mode = (le32_to_cpup((__le32 *) (srom + 34)) &\r\nle32_to_cpup((__le32 *) (srom + 36)));\r\nswitch(dmfe_mode) {\r\ncase 0x4: dmfe_media_mode = DMFE_100MHF; break;\r\ncase 0x2: dmfe_media_mode = DMFE_10MFD; break;\r\ncase 0x8: dmfe_media_mode = DMFE_100MFD; break;\r\ncase 0x100:\r\ncase 0x200: dmfe_media_mode = DMFE_1M_HPNA; break;\r\n}\r\nif ( (SF_mode & 0x1) || (srom[43] & 0x80) )\r\ndb->cr15_data |= 0x40;\r\nif ( (SF_mode & 0x2) || (srom[40] & 0x1) )\r\ndb->cr15_data |= 0x400;\r\nif ( (SF_mode & 0x4) || (srom[40] & 0xe) )\r\ndb->cr15_data |= 0x9800;\r\n}\r\ndb->HPNA_command = 1;\r\nif (HPNA_rx_cmd == 0)\r\ndb->HPNA_command |= 0x8000;\r\nif (HPNA_tx_cmd == 1)\r\nswitch(HPNA_mode) {\r\ncase 0: db->HPNA_command |= 0x0904; break;\r\ncase 1: db->HPNA_command |= 0x0a00; break;\r\ncase 2: db->HPNA_command |= 0x0506; break;\r\ncase 3: db->HPNA_command |= 0x0602; break;\r\n}\r\nelse\r\nswitch(HPNA_mode) {\r\ncase 0: db->HPNA_command |= 0x0004; break;\r\ncase 1: db->HPNA_command |= 0x0000; break;\r\ncase 2: db->HPNA_command |= 0x0006; break;\r\ncase 3: db->HPNA_command |= 0x0002; break;\r\n}\r\ndb->HPNA_present = 0;\r\nupdate_cr6(db->cr6_data | 0x40000, db->ioaddr);\r\ntmp_reg = phy_read(db->ioaddr, db->phy_addr, 3, db->chip_id);\r\nif ( ( tmp_reg & 0xfff0 ) == 0xb900 ) {\r\ndb->HPNA_timer = 8;\r\nif ( phy_read(db->ioaddr, db->phy_addr, 31, db->chip_id) == 0x4404) {\r\ndb->HPNA_present = 1;\r\ndmfe_program_DM9801(db, tmp_reg);\r\n} else {\r\ndb->HPNA_present = 2;\r\ndmfe_program_DM9802(db);\r\n}\r\n}\r\n}\r\nstatic void dmfe_program_DM9801(struct dmfe_board_info * db, int HPNA_rev)\r\n{\r\nuint reg17, reg25;\r\nif ( !HPNA_NoiseFloor ) HPNA_NoiseFloor = DM9801_NOISE_FLOOR;\r\nswitch(HPNA_rev) {\r\ncase 0xb900:\r\ndb->HPNA_command |= 0x1000;\r\nreg25 = phy_read(db->ioaddr, db->phy_addr, 24, db->chip_id);\r\nreg25 = ( (reg25 + HPNA_NoiseFloor) & 0xff) | 0xf000;\r\nreg17 = phy_read(db->ioaddr, db->phy_addr, 17, db->chip_id);\r\nbreak;\r\ncase 0xb901:\r\nreg25 = phy_read(db->ioaddr, db->phy_addr, 25, db->chip_id);\r\nreg25 = (reg25 & 0xff00) + HPNA_NoiseFloor;\r\nreg17 = phy_read(db->ioaddr, db->phy_addr, 17, db->chip_id);\r\nreg17 = (reg17 & 0xfff0) + HPNA_NoiseFloor + 3;\r\nbreak;\r\ncase 0xb902:\r\ncase 0xb903:\r\ndefault:\r\ndb->HPNA_command |= 0x1000;\r\nreg25 = phy_read(db->ioaddr, db->phy_addr, 25, db->chip_id);\r\nreg25 = (reg25 & 0xff00) + HPNA_NoiseFloor - 5;\r\nreg17 = phy_read(db->ioaddr, db->phy_addr, 17, db->chip_id);\r\nreg17 = (reg17 & 0xfff0) + HPNA_NoiseFloor;\r\nbreak;\r\n}\r\nphy_write(db->ioaddr, db->phy_addr, 16, db->HPNA_command, db->chip_id);\r\nphy_write(db->ioaddr, db->phy_addr, 17, reg17, db->chip_id);\r\nphy_write(db->ioaddr, db->phy_addr, 25, reg25, db->chip_id);\r\n}\r\nstatic void dmfe_program_DM9802(struct dmfe_board_info * db)\r\n{\r\nuint phy_reg;\r\nif ( !HPNA_NoiseFloor ) HPNA_NoiseFloor = DM9802_NOISE_FLOOR;\r\nphy_write(db->ioaddr, db->phy_addr, 16, db->HPNA_command, db->chip_id);\r\nphy_reg = phy_read(db->ioaddr, db->phy_addr, 25, db->chip_id);\r\nphy_reg = ( phy_reg & 0xff00) + HPNA_NoiseFloor;\r\nphy_write(db->ioaddr, db->phy_addr, 25, phy_reg, db->chip_id);\r\n}\r\nstatic void dmfe_HPNA_remote_cmd_chk(struct dmfe_board_info * db)\r\n{\r\nuint phy_reg;\r\nphy_reg = phy_read(db->ioaddr, db->phy_addr, 17, db->chip_id) & 0x60;\r\nswitch(phy_reg) {\r\ncase 0x00: phy_reg = 0x0a00;break;\r\ncase 0x20: phy_reg = 0x0900;break;\r\ncase 0x40: phy_reg = 0x0600;break;\r\ncase 0x60: phy_reg = 0x0500;break;\r\n}\r\nif ( phy_reg != (db->HPNA_command & 0x0f00) ) {\r\nphy_write(db->ioaddr, db->phy_addr, 16, db->HPNA_command,\r\ndb->chip_id);\r\ndb->HPNA_timer=8;\r\n} else\r\ndb->HPNA_timer=600;\r\n}\r\nstatic int dmfe_suspend(struct pci_dev *pci_dev, pm_message_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pci_dev);\r\nstruct dmfe_board_info *db = netdev_priv(dev);\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nu32 tmp;\r\nnetif_device_detach(dev);\r\ndb->cr6_data &= ~(CR6_RXSC | CR6_TXSC);\r\nupdate_cr6(db->cr6_data, ioaddr);\r\ndw32(DCR7, 0);\r\ndw32(DCR5, dr32(DCR5));\r\ndmfe_free_rxbuffer(db);\r\npci_read_config_dword(pci_dev, 0x40, &tmp);\r\ntmp &= ~(DMFE_WOL_LINKCHANGE|DMFE_WOL_MAGICPACKET);\r\nif (db->wol_mode & WAKE_PHY)\r\ntmp |= DMFE_WOL_LINKCHANGE;\r\nif (db->wol_mode & WAKE_MAGIC)\r\ntmp |= DMFE_WOL_MAGICPACKET;\r\npci_write_config_dword(pci_dev, 0x40, tmp);\r\npci_enable_wake(pci_dev, PCI_D3hot, 1);\r\npci_enable_wake(pci_dev, PCI_D3cold, 1);\r\npci_save_state(pci_dev);\r\npci_set_power_state(pci_dev, pci_choose_state (pci_dev, state));\r\nreturn 0;\r\n}\r\nstatic int dmfe_resume(struct pci_dev *pci_dev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pci_dev);\r\nu32 tmp;\r\npci_set_power_state(pci_dev, PCI_D0);\r\npci_restore_state(pci_dev);\r\ndmfe_init_dm910x(dev);\r\npci_read_config_dword(pci_dev, 0x40, &tmp);\r\ntmp &= ~(DMFE_WOL_LINKCHANGE | DMFE_WOL_MAGICPACKET);\r\npci_write_config_dword(pci_dev, 0x40, tmp);\r\npci_enable_wake(pci_dev, PCI_D3hot, 0);\r\npci_enable_wake(pci_dev, PCI_D3cold, 0);\r\nnetif_device_attach(dev);\r\nreturn 0;\r\n}\r\nstatic int __init dmfe_init_module(void)\r\n{\r\nint rc;\r\npr_info("%s\n", version);\r\nprinted_version = 1;\r\nDMFE_DBUG(0, "init_module() ", debug);\r\nif (debug)\r\ndmfe_debug = debug;\r\nif (cr6set)\r\ndmfe_cr6_user_set = cr6set;\r\nswitch(mode) {\r\ncase DMFE_10MHF:\r\ncase DMFE_100MHF:\r\ncase DMFE_10MFD:\r\ncase DMFE_100MFD:\r\ncase DMFE_1M_HPNA:\r\ndmfe_media_mode = mode;\r\nbreak;\r\ndefault:dmfe_media_mode = DMFE_AUTO;\r\nbreak;\r\n}\r\nif (HPNA_mode > 4)\r\nHPNA_mode = 0;\r\nif (HPNA_rx_cmd > 1)\r\nHPNA_rx_cmd = 0;\r\nif (HPNA_tx_cmd > 1)\r\nHPNA_tx_cmd = 0;\r\nif (HPNA_NoiseFloor > 15)\r\nHPNA_NoiseFloor = 0;\r\nrc = pci_register_driver(&dmfe_driver);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic void __exit dmfe_cleanup_module(void)\r\n{\r\nDMFE_DBUG(0, "dmfe_clean_module() ", debug);\r\npci_unregister_driver(&dmfe_driver);\r\n}
