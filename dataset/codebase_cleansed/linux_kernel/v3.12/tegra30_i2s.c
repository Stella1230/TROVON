static int tegra30_i2s_runtime_suspend(struct device *dev)\r\n{\r\nstruct tegra30_i2s *i2s = dev_get_drvdata(dev);\r\nregcache_cache_only(i2s->regmap, true);\r\nclk_disable_unprepare(i2s->clk_i2s);\r\nreturn 0;\r\n}\r\nstatic int tegra30_i2s_runtime_resume(struct device *dev)\r\n{\r\nstruct tegra30_i2s *i2s = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_prepare_enable(i2s->clk_i2s);\r\nif (ret) {\r\ndev_err(dev, "clk_enable failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nregcache_cache_only(i2s->regmap, false);\r\nreturn 0;\r\n}\r\nstatic int tegra30_i2s_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct tegra30_i2s *i2s = snd_soc_dai_get_drvdata(dai);\r\nint ret;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nret = tegra30_ahub_allocate_tx_fifo(&i2s->playback_fifo_cif,\r\n&i2s->playback_dma_data.addr,\r\n&i2s->playback_dma_data.slave_id);\r\ni2s->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ni2s->playback_dma_data.maxburst = 4;\r\ntegra30_ahub_set_rx_cif_source(i2s->playback_i2s_cif,\r\ni2s->playback_fifo_cif);\r\n} else {\r\nret = tegra30_ahub_allocate_rx_fifo(&i2s->capture_fifo_cif,\r\n&i2s->capture_dma_data.addr,\r\n&i2s->capture_dma_data.slave_id);\r\ni2s->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ni2s->capture_dma_data.maxburst = 4;\r\ntegra30_ahub_set_rx_cif_source(i2s->capture_fifo_cif,\r\ni2s->capture_i2s_cif);\r\n}\r\nreturn ret;\r\n}\r\nstatic void tegra30_i2s_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct tegra30_i2s *i2s = snd_soc_dai_get_drvdata(dai);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ntegra30_ahub_unset_rx_cif_source(i2s->playback_i2s_cif);\r\ntegra30_ahub_free_tx_fifo(i2s->playback_fifo_cif);\r\n} else {\r\ntegra30_ahub_unset_rx_cif_source(i2s->capture_fifo_cif);\r\ntegra30_ahub_free_rx_fifo(i2s->capture_fifo_cif);\r\n}\r\n}\r\nstatic int tegra30_i2s_set_fmt(struct snd_soc_dai *dai,\r\nunsigned int fmt)\r\n{\r\nstruct tegra30_i2s *i2s = snd_soc_dai_get_drvdata(dai);\r\nunsigned int mask, val;\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmask = TEGRA30_I2S_CTRL_MASTER_ENABLE;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nval = TEGRA30_I2S_CTRL_MASTER_ENABLE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmask |= TEGRA30_I2S_CTRL_FRAME_FORMAT_MASK |\r\nTEGRA30_I2S_CTRL_LRCK_MASK;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nval |= TEGRA30_I2S_CTRL_FRAME_FORMAT_FSYNC;\r\nval |= TEGRA30_I2S_CTRL_LRCK_L_LOW;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nval |= TEGRA30_I2S_CTRL_FRAME_FORMAT_FSYNC;\r\nval |= TEGRA30_I2S_CTRL_LRCK_R_LOW;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nval |= TEGRA30_I2S_CTRL_FRAME_FORMAT_LRCK;\r\nval |= TEGRA30_I2S_CTRL_LRCK_L_LOW;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nval |= TEGRA30_I2S_CTRL_FRAME_FORMAT_LRCK;\r\nval |= TEGRA30_I2S_CTRL_LRCK_L_LOW;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nval |= TEGRA30_I2S_CTRL_FRAME_FORMAT_LRCK;\r\nval |= TEGRA30_I2S_CTRL_LRCK_L_LOW;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npm_runtime_get_sync(dai->dev);\r\nregmap_update_bits(i2s->regmap, TEGRA30_I2S_CTRL, mask, val);\r\npm_runtime_put(dai->dev);\r\nreturn 0;\r\n}\r\nstatic int tegra30_i2s_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct device *dev = dai->dev;\r\nstruct tegra30_i2s *i2s = snd_soc_dai_get_drvdata(dai);\r\nunsigned int mask, val, reg;\r\nint ret, sample_size, srate, i2sclock, bitcnt;\r\nif (params_channels(params) != 2)\r\nreturn -EINVAL;\r\nmask = TEGRA30_I2S_CTRL_BIT_SIZE_MASK;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nval = TEGRA30_I2S_CTRL_BIT_SIZE_16;\r\nsample_size = 16;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(i2s->regmap, TEGRA30_I2S_CTRL, mask, val);\r\nsrate = params_rate(params);\r\ni2sclock = srate * params_channels(params) * sample_size * 2;\r\nbitcnt = (i2sclock / (2 * srate)) - 1;\r\nif (bitcnt < 0 || bitcnt > TEGRA30_I2S_TIMING_CHANNEL_BIT_COUNT_MASK_US)\r\nreturn -EINVAL;\r\nret = clk_set_rate(i2s->clk_i2s, i2sclock);\r\nif (ret) {\r\ndev_err(dev, "Can't set I2S clock rate: %d\n", ret);\r\nreturn ret;\r\n}\r\nval = bitcnt << TEGRA30_I2S_TIMING_CHANNEL_BIT_COUNT_SHIFT;\r\nif (i2sclock % (2 * srate))\r\nval |= TEGRA30_I2S_TIMING_NON_SYM_ENABLE;\r\nregmap_write(i2s->regmap, TEGRA30_I2S_TIMING, val);\r\nval = (0 << TEGRA30_AUDIOCIF_CTRL_FIFO_THRESHOLD_SHIFT) |\r\n(1 << TEGRA30_AUDIOCIF_CTRL_AUDIO_CHANNELS_SHIFT) |\r\n(1 << TEGRA30_AUDIOCIF_CTRL_CLIENT_CHANNELS_SHIFT) |\r\nTEGRA30_AUDIOCIF_CTRL_AUDIO_BITS_16 |\r\nTEGRA30_AUDIOCIF_CTRL_CLIENT_BITS_16;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nval |= TEGRA30_AUDIOCIF_CTRL_DIRECTION_RX;\r\nreg = TEGRA30_I2S_CIF_RX_CTRL;\r\n} else {\r\nval |= TEGRA30_AUDIOCIF_CTRL_DIRECTION_TX;\r\nreg = TEGRA30_I2S_CIF_TX_CTRL;\r\n}\r\nregmap_write(i2s->regmap, reg, val);\r\nval = (1 << TEGRA30_I2S_OFFSET_RX_DATA_OFFSET_SHIFT) |\r\n(1 << TEGRA30_I2S_OFFSET_TX_DATA_OFFSET_SHIFT);\r\nregmap_write(i2s->regmap, TEGRA30_I2S_OFFSET, val);\r\nreturn 0;\r\n}\r\nstatic void tegra30_i2s_start_playback(struct tegra30_i2s *i2s)\r\n{\r\ntegra30_ahub_enable_tx_fifo(i2s->playback_fifo_cif);\r\nregmap_update_bits(i2s->regmap, TEGRA30_I2S_CTRL,\r\nTEGRA30_I2S_CTRL_XFER_EN_TX,\r\nTEGRA30_I2S_CTRL_XFER_EN_TX);\r\n}\r\nstatic void tegra30_i2s_stop_playback(struct tegra30_i2s *i2s)\r\n{\r\ntegra30_ahub_disable_tx_fifo(i2s->playback_fifo_cif);\r\nregmap_update_bits(i2s->regmap, TEGRA30_I2S_CTRL,\r\nTEGRA30_I2S_CTRL_XFER_EN_TX, 0);\r\n}\r\nstatic void tegra30_i2s_start_capture(struct tegra30_i2s *i2s)\r\n{\r\ntegra30_ahub_enable_rx_fifo(i2s->capture_fifo_cif);\r\nregmap_update_bits(i2s->regmap, TEGRA30_I2S_CTRL,\r\nTEGRA30_I2S_CTRL_XFER_EN_RX,\r\nTEGRA30_I2S_CTRL_XFER_EN_RX);\r\n}\r\nstatic void tegra30_i2s_stop_capture(struct tegra30_i2s *i2s)\r\n{\r\ntegra30_ahub_disable_rx_fifo(i2s->capture_fifo_cif);\r\nregmap_update_bits(i2s->regmap, TEGRA30_I2S_CTRL,\r\nTEGRA30_I2S_CTRL_XFER_EN_RX, 0);\r\n}\r\nstatic int tegra30_i2s_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct tegra30_i2s *i2s = snd_soc_dai_get_drvdata(dai);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ntegra30_i2s_start_playback(i2s);\r\nelse\r\ntegra30_i2s_start_capture(i2s);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ntegra30_i2s_stop_playback(i2s);\r\nelse\r\ntegra30_i2s_stop_capture(i2s);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra30_i2s_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct tegra30_i2s *i2s = snd_soc_dai_get_drvdata(dai);\r\ndai->capture_dma_data = &i2s->capture_dma_data;\r\ndai->playback_dma_data = &i2s->playback_dma_data;\r\nreturn 0;\r\n}\r\nstatic bool tegra30_i2s_wr_rd_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase TEGRA30_I2S_CTRL:\r\ncase TEGRA30_I2S_TIMING:\r\ncase TEGRA30_I2S_OFFSET:\r\ncase TEGRA30_I2S_CH_CTRL:\r\ncase TEGRA30_I2S_SLOT_CTRL:\r\ncase TEGRA30_I2S_CIF_RX_CTRL:\r\ncase TEGRA30_I2S_CIF_TX_CTRL:\r\ncase TEGRA30_I2S_FLOWCTL:\r\ncase TEGRA30_I2S_TX_STEP:\r\ncase TEGRA30_I2S_FLOW_STATUS:\r\ncase TEGRA30_I2S_FLOW_TOTAL:\r\ncase TEGRA30_I2S_FLOW_OVER:\r\ncase TEGRA30_I2S_FLOW_UNDER:\r\ncase TEGRA30_I2S_LCOEF_1_4_0:\r\ncase TEGRA30_I2S_LCOEF_1_4_1:\r\ncase TEGRA30_I2S_LCOEF_1_4_2:\r\ncase TEGRA30_I2S_LCOEF_1_4_3:\r\ncase TEGRA30_I2S_LCOEF_1_4_4:\r\ncase TEGRA30_I2S_LCOEF_1_4_5:\r\ncase TEGRA30_I2S_LCOEF_2_4_0:\r\ncase TEGRA30_I2S_LCOEF_2_4_1:\r\ncase TEGRA30_I2S_LCOEF_2_4_2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n};\r\n}\r\nstatic bool tegra30_i2s_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase TEGRA30_I2S_FLOW_STATUS:\r\ncase TEGRA30_I2S_FLOW_TOTAL:\r\ncase TEGRA30_I2S_FLOW_OVER:\r\ncase TEGRA30_I2S_FLOW_UNDER:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n};\r\n}\r\nstatic int tegra30_i2s_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct tegra30_i2s *i2s;\r\nu32 cif_ids[2];\r\nstruct resource *mem, *memregion;\r\nvoid __iomem *regs;\r\nint ret;\r\ni2s = devm_kzalloc(&pdev->dev, sizeof(struct tegra30_i2s), GFP_KERNEL);\r\nif (!i2s) {\r\ndev_err(&pdev->dev, "Can't allocate tegra30_i2s\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev_set_drvdata(&pdev->dev, i2s);\r\ni2s->dai = tegra30_i2s_dai_template;\r\ni2s->dai.name = dev_name(&pdev->dev);\r\nret = of_property_read_u32_array(pdev->dev.of_node,\r\n"nvidia,ahub-cif-ids", cif_ids,\r\nARRAY_SIZE(cif_ids));\r\nif (ret < 0)\r\ngoto err;\r\ni2s->playback_i2s_cif = cif_ids[0];\r\ni2s->capture_i2s_cif = cif_ids[1];\r\ni2s->clk_i2s = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(i2s->clk_i2s)) {\r\ndev_err(&pdev->dev, "Can't retrieve i2s clock\n");\r\nret = PTR_ERR(i2s->clk_i2s);\r\ngoto err;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(&pdev->dev, "No memory resource\n");\r\nret = -ENODEV;\r\ngoto err_clk_put;\r\n}\r\nmemregion = devm_request_mem_region(&pdev->dev, mem->start,\r\nresource_size(mem), DRV_NAME);\r\nif (!memregion) {\r\ndev_err(&pdev->dev, "Memory region already claimed\n");\r\nret = -EBUSY;\r\ngoto err_clk_put;\r\n}\r\nregs = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));\r\nif (!regs) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err_clk_put;\r\n}\r\ni2s->regmap = devm_regmap_init_mmio(&pdev->dev, regs,\r\n&tegra30_i2s_regmap_config);\r\nif (IS_ERR(i2s->regmap)) {\r\ndev_err(&pdev->dev, "regmap init failed\n");\r\nret = PTR_ERR(i2s->regmap);\r\ngoto err_clk_put;\r\n}\r\nregcache_cache_only(i2s->regmap, true);\r\npm_runtime_enable(&pdev->dev);\r\nif (!pm_runtime_enabled(&pdev->dev)) {\r\nret = tegra30_i2s_runtime_resume(&pdev->dev);\r\nif (ret)\r\ngoto err_pm_disable;\r\n}\r\nret = snd_soc_register_component(&pdev->dev, &tegra30_i2s_component,\r\n&i2s->dai, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not register DAI: %d\n", ret);\r\nret = -ENOMEM;\r\ngoto err_suspend;\r\n}\r\nret = tegra_pcm_platform_register(&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not register PCM: %d\n", ret);\r\ngoto err_unregister_component;\r\n}\r\nreturn 0;\r\nerr_unregister_component:\r\nsnd_soc_unregister_component(&pdev->dev);\r\nerr_suspend:\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\ntegra30_i2s_runtime_suspend(&pdev->dev);\r\nerr_pm_disable:\r\npm_runtime_disable(&pdev->dev);\r\nerr_clk_put:\r\nclk_put(i2s->clk_i2s);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int tegra30_i2s_platform_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra30_i2s *i2s = dev_get_drvdata(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\ntegra30_i2s_runtime_suspend(&pdev->dev);\r\ntegra_pcm_platform_unregister(&pdev->dev);\r\nsnd_soc_unregister_component(&pdev->dev);\r\nclk_put(i2s->clk_i2s);\r\nreturn 0;\r\n}\r\nstatic int tegra30_i2s_suspend(struct device *dev)\r\n{\r\nstruct tegra30_i2s *i2s = dev_get_drvdata(dev);\r\nregcache_mark_dirty(i2s->regmap);\r\nreturn 0;\r\n}\r\nstatic int tegra30_i2s_resume(struct device *dev)\r\n{\r\nstruct tegra30_i2s *i2s = dev_get_drvdata(dev);\r\nint ret;\r\nret = pm_runtime_get_sync(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regcache_sync(i2s->regmap);\r\npm_runtime_put(dev);\r\nreturn ret;\r\n}
