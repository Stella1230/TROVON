static int piix_port_start(struct ata_port *ap)\r\n{\r\nif (!(ap->flags & PIIX_FLAG_PIO16))\r\nap->pflags |= ATA_PFLAG_PIO32 | ATA_PFLAG_PIO32CHANGE;\r\nreturn ata_bmdma_port_start(ap);\r\n}\r\nstatic int ich_pata_cable_detect(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstruct piix_host_priv *hpriv = ap->host->private_data;\r\nconst struct ich_laptop *lap = &ich_laptop[0];\r\nu8 mask;\r\nwhile (lap->device) {\r\nif (lap->device == pdev->device &&\r\nlap->subvendor == pdev->subsystem_vendor &&\r\nlap->subdevice == pdev->subsystem_device)\r\nreturn ATA_CBL_PATA40_SHORT;\r\nlap++;\r\n}\r\nmask = ap->port_no == 0 ? PIIX_80C_PRI : PIIX_80C_SEC;\r\nif ((hpriv->saved_iocfg & mask) == 0)\r\nreturn ATA_CBL_PATA40;\r\nreturn ATA_CBL_PATA80;\r\n}\r\nstatic int piix_pata_prereset(struct ata_link *link, unsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nif (!pci_test_config_bits(pdev, &piix_enable_bits[ap->port_no]))\r\nreturn -ENOENT;\r\nreturn ata_sff_prereset(link, deadline);\r\n}\r\nstatic void piix_set_timings(struct ata_port *ap, struct ata_device *adev,\r\nu8 pio)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(ap->host->dev);\r\nunsigned long flags;\r\nunsigned int is_slave = (adev->devno != 0);\r\nunsigned int master_port= ap->port_no ? 0x42 : 0x40;\r\nunsigned int slave_port = 0x44;\r\nu16 master_data;\r\nu8 slave_data;\r\nu8 udma_enable;\r\nint control = 0;\r\nstatic const\r\nu8 timings[][2] = { { 0, 0 },\r\n{ 0, 0 },\r\n{ 1, 0 },\r\n{ 2, 1 },\r\n{ 2, 3 }, };\r\nif (pio >= 2)\r\ncontrol |= 1;\r\nif (ata_pio_need_iordy(adev))\r\ncontrol |= 2;\r\nif (adev->class == ATA_DEV_ATA)\r\ncontrol |= 4;\r\nif (adev->pio_mode < XFER_PIO_0 + pio)\r\ncontrol |= 8;\r\nspin_lock_irqsave(&piix_lock, flags);\r\npci_read_config_word(dev, master_port, &master_data);\r\nif (is_slave) {\r\nmaster_data &= 0xff0f;\r\nmaster_data |= (control << 4);\r\npci_read_config_byte(dev, slave_port, &slave_data);\r\nslave_data &= (ap->port_no ? 0x0f : 0xf0);\r\nslave_data |= ((timings[pio][0] << 2) | timings[pio][1])\r\n<< (ap->port_no ? 4 : 0);\r\n} else {\r\nmaster_data &= 0xccf0;\r\nmaster_data |= control;\r\nmaster_data |=\r\n(timings[pio][0] << 12) |\r\n(timings[pio][1] << 8);\r\n}\r\nmaster_data |= 0x4000;\r\npci_write_config_word(dev, master_port, master_data);\r\nif (is_slave)\r\npci_write_config_byte(dev, slave_port, slave_data);\r\nif (ap->udma_mask) {\r\npci_read_config_byte(dev, 0x48, &udma_enable);\r\nudma_enable &= ~(1 << (2 * ap->port_no + adev->devno));\r\npci_write_config_byte(dev, 0x48, udma_enable);\r\n}\r\nspin_unlock_irqrestore(&piix_lock, flags);\r\n}\r\nstatic void piix_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\npiix_set_timings(ap, adev, adev->pio_mode - XFER_PIO_0);\r\n}\r\nstatic void do_pata_set_dmamode(struct ata_port *ap, struct ata_device *adev, int isich)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(ap->host->dev);\r\nunsigned long flags;\r\nu8 speed = adev->dma_mode;\r\nint devid = adev->devno + 2 * ap->port_no;\r\nu8 udma_enable = 0;\r\nif (speed >= XFER_UDMA_0) {\r\nunsigned int udma = speed - XFER_UDMA_0;\r\nu16 udma_timing;\r\nu16 ideconf;\r\nint u_clock, u_speed;\r\nspin_lock_irqsave(&piix_lock, flags);\r\npci_read_config_byte(dev, 0x48, &udma_enable);\r\nu_speed = min(2 - (udma & 1), udma);\r\nif (udma == 5)\r\nu_clock = 0x1000;\r\nelse if (udma > 2)\r\nu_clock = 1;\r\nelse\r\nu_clock = 0;\r\nudma_enable |= (1 << devid);\r\npci_read_config_word(dev, 0x4A, &udma_timing);\r\nudma_timing &= ~(3 << (4 * devid));\r\nudma_timing |= u_speed << (4 * devid);\r\npci_write_config_word(dev, 0x4A, udma_timing);\r\nif (isich) {\r\npci_read_config_word(dev, 0x54, &ideconf);\r\nideconf &= ~(0x1001 << devid);\r\nideconf |= u_clock << devid;\r\npci_write_config_word(dev, 0x54, ideconf);\r\n}\r\npci_write_config_byte(dev, 0x48, udma_enable);\r\nspin_unlock_irqrestore(&piix_lock, flags);\r\n} else {\r\nunsigned int mwdma = speed - XFER_MW_DMA_0;\r\nconst unsigned int needed_pio[3] = {\r\nXFER_PIO_0, XFER_PIO_3, XFER_PIO_4\r\n};\r\nint pio = needed_pio[mwdma] - XFER_PIO_0;\r\npiix_set_timings(ap, adev, pio);\r\n}\r\n}\r\nstatic void piix_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\ndo_pata_set_dmamode(ap, adev, 0);\r\n}\r\nstatic void ich_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\ndo_pata_set_dmamode(ap, adev, 1);\r\n}\r\nstatic void piix_sidpr_sel(struct ata_link *link, unsigned int reg)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct piix_host_priv *hpriv = ap->host->private_data;\r\niowrite32(((ap->port_no * 2 + link->pmp) << 8) | piix_sidx_map[reg],\r\nhpriv->sidpr + PIIX_SIDPR_IDX);\r\n}\r\nstatic int piix_sidpr_scr_read(struct ata_link *link,\r\nunsigned int reg, u32 *val)\r\n{\r\nstruct piix_host_priv *hpriv = link->ap->host->private_data;\r\nif (reg >= ARRAY_SIZE(piix_sidx_map))\r\nreturn -EINVAL;\r\npiix_sidpr_sel(link, reg);\r\n*val = ioread32(hpriv->sidpr + PIIX_SIDPR_DATA);\r\nreturn 0;\r\n}\r\nstatic int piix_sidpr_scr_write(struct ata_link *link,\r\nunsigned int reg, u32 val)\r\n{\r\nstruct piix_host_priv *hpriv = link->ap->host->private_data;\r\nif (reg >= ARRAY_SIZE(piix_sidx_map))\r\nreturn -EINVAL;\r\npiix_sidpr_sel(link, reg);\r\niowrite32(val, hpriv->sidpr + PIIX_SIDPR_DATA);\r\nreturn 0;\r\n}\r\nstatic int piix_sidpr_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,\r\nunsigned hints)\r\n{\r\nreturn sata_link_scr_lpm(link, policy, false);\r\n}\r\nstatic bool piix_irq_check(struct ata_port *ap)\r\n{\r\nif (unlikely(!ap->ioaddr.bmdma_addr))\r\nreturn false;\r\nreturn ap->ops->bmdma_status(ap) & ATA_DMA_INTR;\r\n}\r\nstatic int piix_broken_suspend(void)\r\n{\r\nstatic const struct dmi_system_id sysids[] = {\r\n{\r\n.ident = "TECRA M3",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "TECRA M3"),\r\n},\r\n},\r\n{\r\n.ident = "TECRA M3",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "Tecra M3"),\r\n},\r\n},\r\n{\r\n.ident = "TECRA M4",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "Tecra M4"),\r\n},\r\n},\r\n{\r\n.ident = "TECRA M4",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "TECRA M4"),\r\n},\r\n},\r\n{\r\n.ident = "TECRA M5",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "TECRA M5"),\r\n},\r\n},\r\n{\r\n.ident = "TECRA M6",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "TECRA M6"),\r\n},\r\n},\r\n{\r\n.ident = "TECRA M7",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "TECRA M7"),\r\n},\r\n},\r\n{\r\n.ident = "TECRA A8",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "TECRA A8"),\r\n},\r\n},\r\n{\r\n.ident = "Satellite R20",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "Satellite R20"),\r\n},\r\n},\r\n{\r\n.ident = "Satellite R25",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "Satellite R25"),\r\n},\r\n},\r\n{\r\n.ident = "Satellite U200",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "Satellite U200"),\r\n},\r\n},\r\n{\r\n.ident = "Satellite U200",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "SATELLITE U200"),\r\n},\r\n},\r\n{\r\n.ident = "Satellite Pro U200",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "SATELLITE PRO U200"),\r\n},\r\n},\r\n{\r\n.ident = "Satellite U205",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "Satellite U205"),\r\n},\r\n},\r\n{\r\n.ident = "SATELLITE U205",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "SATELLITE U205"),\r\n},\r\n},\r\n{\r\n.ident = "Satellite Pro A120",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "Satellite Pro A120"),\r\n},\r\n},\r\n{\r\n.ident = "Portege M500",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "PORTEGE M500"),\r\n},\r\n},\r\n{\r\n.ident = "VGN-BX297XP",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "VGN-BX297XP"),\r\n},\r\n},\r\n{ }\r\n};\r\nstatic const char *oemstrs[] = {\r\n"Tecra M3,",\r\n};\r\nint i;\r\nif (dmi_check_system(sysids))\r\nreturn 1;\r\nfor (i = 0; i < ARRAY_SIZE(oemstrs); i++)\r\nif (dmi_find_device(DMI_DEV_TYPE_OEM_STRING, oemstrs[i], NULL))\r\nreturn 1;\r\nif (dmi_match(DMI_SYS_VENDOR, "TOSHIBA") &&\r\ndmi_match(DMI_PRODUCT_NAME, "000000") &&\r\ndmi_match(DMI_PRODUCT_VERSION, "000000") &&\r\ndmi_match(DMI_PRODUCT_SERIAL, "000000") &&\r\ndmi_match(DMI_BOARD_VENDOR, "TOSHIBA") &&\r\ndmi_match(DMI_BOARD_NAME, "Portable PC") &&\r\ndmi_match(DMI_BOARD_VERSION, "Version A0"))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int piix_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)\r\n{\r\nstruct ata_host *host = pci_get_drvdata(pdev);\r\nunsigned long flags;\r\nint rc = 0;\r\nrc = ata_host_suspend(host, mesg);\r\nif (rc)\r\nreturn rc;\r\nif (piix_broken_suspend() && (mesg.event & PM_EVENT_SLEEP)) {\r\npci_save_state(pdev);\r\nif (pdev->current_state == PCI_D0)\r\npdev->current_state = PCI_UNKNOWN;\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->flags |= PIIX_HOST_BROKEN_SUSPEND;\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n} else\r\nata_pci_device_do_suspend(pdev, mesg);\r\nreturn 0;\r\n}\r\nstatic int piix_pci_device_resume(struct pci_dev *pdev)\r\n{\r\nstruct ata_host *host = pci_get_drvdata(pdev);\r\nunsigned long flags;\r\nint rc;\r\nif (host->flags & PIIX_HOST_BROKEN_SUSPEND) {\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->flags &= ~PIIX_HOST_BROKEN_SUSPEND;\r\nspin_unlock_irqrestore(&host->lock, flags);\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nrc = pci_reenable_device(pdev);\r\nif (rc)\r\ndev_err(&pdev->dev,\r\n"failed to enable device after resume (%d)\n",\r\nrc);\r\n} else\r\nrc = ata_pci_device_do_resume(pdev);\r\nif (rc == 0)\r\nata_host_resume(host);\r\nreturn rc;\r\n}\r\nstatic u8 piix_vmw_bmdma_status(struct ata_port *ap)\r\n{\r\nreturn ata_bmdma_status(ap) & ~ATA_DMA_ERR;\r\n}\r\nstatic int piix_disable_ahci(struct pci_dev *pdev)\r\n{\r\nvoid __iomem *mmio;\r\nu32 tmp;\r\nint rc = 0;\r\nif (!pci_resource_start(pdev, AHCI_PCI_BAR) ||\r\n!pci_resource_len(pdev, AHCI_PCI_BAR))\r\nreturn 0;\r\nmmio = pci_iomap(pdev, AHCI_PCI_BAR, 64);\r\nif (!mmio)\r\nreturn -ENOMEM;\r\ntmp = ioread32(mmio + AHCI_GLOBAL_CTL);\r\nif (tmp & AHCI_ENABLE) {\r\ntmp &= ~AHCI_ENABLE;\r\niowrite32(tmp, mmio + AHCI_GLOBAL_CTL);\r\ntmp = ioread32(mmio + AHCI_GLOBAL_CTL);\r\nif (tmp & AHCI_ENABLE)\r\nrc = -EIO;\r\n}\r\npci_iounmap(pdev, mmio);\r\nreturn rc;\r\n}\r\nstatic int piix_check_450nx_errata(struct pci_dev *ata_dev)\r\n{\r\nstruct pci_dev *pdev = NULL;\r\nu16 cfg;\r\nint no_piix_dma = 0;\r\nwhile ((pdev = pci_get_device(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82454NX, pdev)) != NULL) {\r\npci_read_config_word(pdev, 0x41, &cfg);\r\nif (pdev->revision == 0x00)\r\nno_piix_dma = 1;\r\nelse if (cfg & (1<<14) && pdev->revision < 5)\r\nno_piix_dma = 2;\r\n}\r\nif (no_piix_dma)\r\ndev_warn(&ata_dev->dev,\r\n"450NX errata present, disabling IDE DMA%s\n",\r\nno_piix_dma == 2 ? " - a BIOS update may resolve this"\r\n: "");\r\nreturn no_piix_dma;\r\n}\r\nstatic void piix_init_pcs(struct ata_host *host,\r\nconst struct piix_map_db *map_db)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(host->dev);\r\nu16 pcs, new_pcs;\r\npci_read_config_word(pdev, ICH5_PCS, &pcs);\r\nnew_pcs = pcs | map_db->port_enable;\r\nif (new_pcs != pcs) {\r\nDPRINTK("updating PCS from 0x%x to 0x%x\n", pcs, new_pcs);\r\npci_write_config_word(pdev, ICH5_PCS, new_pcs);\r\nmsleep(150);\r\n}\r\n}\r\nstatic const int *piix_init_sata_map(struct pci_dev *pdev,\r\nstruct ata_port_info *pinfo,\r\nconst struct piix_map_db *map_db)\r\n{\r\nconst int *map;\r\nint i, invalid_map = 0;\r\nu8 map_value;\r\npci_read_config_byte(pdev, ICH5_PMR, &map_value);\r\nmap = map_db->map[map_value & map_db->mask];\r\ndev_info(&pdev->dev, "MAP [");\r\nfor (i = 0; i < 4; i++) {\r\nswitch (map[i]) {\r\ncase RV:\r\ninvalid_map = 1;\r\npr_cont(" XX");\r\nbreak;\r\ncase NA:\r\npr_cont(" --");\r\nbreak;\r\ncase IDE:\r\nWARN_ON((i & 1) || map[i + 1] != IDE);\r\npinfo[i / 2] = piix_port_info[ich_pata_100];\r\ni++;\r\npr_cont(" IDE IDE");\r\nbreak;\r\ndefault:\r\npr_cont(" P%d", map[i]);\r\nif (i & 1)\r\npinfo[i / 2].flags |= ATA_FLAG_SLAVE_POSS;\r\nbreak;\r\n}\r\n}\r\npr_cont(" ]\n");\r\nif (invalid_map)\r\ndev_err(&pdev->dev, "invalid MAP value %u\n", map_value);\r\nreturn map;\r\n}\r\nstatic bool piix_no_sidpr(struct ata_host *host)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(host->dev);\r\nif (pdev->vendor == PCI_VENDOR_ID_INTEL && pdev->device == 0x2920 &&\r\npdev->subsystem_vendor == PCI_VENDOR_ID_SAMSUNG &&\r\npdev->subsystem_device == 0xb049) {\r\ndev_warn(host->dev,\r\n"Samsung DB-P70 detected, disabling SIDPR\n");\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int piix_init_sidpr(struct ata_host *host)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(host->dev);\r\nstruct piix_host_priv *hpriv = host->private_data;\r\nstruct ata_link *link0 = &host->ports[0]->link;\r\nu32 scontrol;\r\nint i, rc;\r\nfor (i = 0; i < 4; i++)\r\nif (hpriv->map[i] == IDE)\r\nreturn 0;\r\nif (piix_no_sidpr(host))\r\nreturn 0;\r\nif (!(host->ports[0]->flags & PIIX_FLAG_SIDPR))\r\nreturn 0;\r\nif (pci_resource_start(pdev, PIIX_SIDPR_BAR) == 0 ||\r\npci_resource_len(pdev, PIIX_SIDPR_BAR) != PIIX_SIDPR_LEN)\r\nreturn 0;\r\nif (pcim_iomap_regions(pdev, 1 << PIIX_SIDPR_BAR, DRV_NAME))\r\nreturn 0;\r\nhpriv->sidpr = pcim_iomap_table(pdev)[PIIX_SIDPR_BAR];\r\npiix_sidpr_scr_read(link0, SCR_CONTROL, &scontrol);\r\nif ((scontrol & 0xf00) != 0x300) {\r\nscontrol |= 0x300;\r\npiix_sidpr_scr_write(link0, SCR_CONTROL, scontrol);\r\npiix_sidpr_scr_read(link0, SCR_CONTROL, &scontrol);\r\nif ((scontrol & 0xf00) != 0x300) {\r\ndev_info(host->dev,\r\n"SCR access via SIDPR is available but doesn't work\n");\r\nreturn 0;\r\n}\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nap->ops = &piix_sidpr_sata_ops;\r\nif (ap->flags & ATA_FLAG_SLAVE_POSS) {\r\nrc = ata_slave_link_init(ap);\r\nif (rc)\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void piix_iocfg_bit18_quirk(struct ata_host *host)\r\n{\r\nstatic const struct dmi_system_id sysids[] = {\r\n{\r\n.ident = "M570U",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "Clevo Co."),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "M570U"),\r\n},\r\n},\r\n{ }\r\n};\r\nstruct pci_dev *pdev = to_pci_dev(host->dev);\r\nstruct piix_host_priv *hpriv = host->private_data;\r\nif (!dmi_check_system(sysids))\r\nreturn;\r\nif (hpriv->saved_iocfg & (1 << 18)) {\r\ndev_info(&pdev->dev, "applying IOCFG bit18 quirk\n");\r\npci_write_config_dword(pdev, PIIX_IOCFG,\r\nhpriv->saved_iocfg & ~(1 << 18));\r\n}\r\n}\r\nstatic bool piix_broken_system_poweroff(struct pci_dev *pdev)\r\n{\r\nstatic const struct dmi_system_id broken_systems[] = {\r\n{\r\n.ident = "HP Compaq 2510p",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "HP Compaq 2510p"),\r\n},\r\n.driver_data = (void *)0x1FUL,\r\n},\r\n{\r\n.ident = "HP Compaq nc6000",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "HP Compaq nc6000"),\r\n},\r\n.driver_data = (void *)0x1FUL,\r\n},\r\n{ }\r\n};\r\nconst struct dmi_system_id *dmi = dmi_first_match(broken_systems);\r\nif (dmi) {\r\nunsigned long slot = (unsigned long)dmi->driver_data;\r\nreturn slot == PCI_SLOT(pdev->devfn);\r\n}\r\nreturn false;\r\n}\r\nstatic void piix_ignore_devices_quirk(struct ata_host *host)\r\n{\r\n#if IS_ENABLED(CONFIG_HYPERV_STORAGE)\r\nstatic const struct dmi_system_id ignore_hyperv[] = {\r\n{\r\n.ident = "Hyper-V Virtual Machine",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR,\r\n"Microsoft Corporation"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "Virtual Machine"),\r\n},\r\n},\r\n{ }\r\n};\r\nstatic const struct dmi_system_id allow_virtual_pc[] = {\r\n{\r\n.ident = "MS Virtual PC 2007",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR,\r\n"Microsoft Corporation"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "Virtual Machine"),\r\nDMI_MATCH(DMI_PRODUCT_VERSION, "VS2005R2"),\r\n},\r\n},\r\n{ }\r\n};\r\nconst struct dmi_system_id *ignore = dmi_first_match(ignore_hyperv);\r\nconst struct dmi_system_id *allow = dmi_first_match(allow_virtual_pc);\r\nif (ignore && !allow && prefer_ms_hyperv) {\r\nhost->flags |= ATA_HOST_IGNORE_ATA;\r\ndev_info(host->dev, "%s detected, ATA device ignore set\n",\r\nignore->ident);\r\n}\r\n#endif\r\n}\r\nstatic int piix_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ata_port_info port_info[2];\r\nconst struct ata_port_info *ppi[] = { &port_info[0], &port_info[1] };\r\nstruct scsi_host_template *sht = &piix_sht;\r\nunsigned long port_flags;\r\nstruct ata_host *host;\r\nstruct piix_host_priv *hpriv;\r\nint rc;\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nif (!in_module_init && ent->driver_data >= ich5_sata)\r\nreturn -ENODEV;\r\nif (piix_broken_system_poweroff(pdev)) {\r\npiix_port_info[ent->driver_data].flags |=\r\nATA_FLAG_NO_POWEROFF_SPINDOWN |\r\nATA_FLAG_NO_HIBERNATE_SPINDOWN;\r\ndev_info(&pdev->dev, "quirky BIOS, skipping spindown "\r\n"on poweroff and hibernation\n");\r\n}\r\nport_info[0] = piix_port_info[ent->driver_data];\r\nport_info[1] = piix_port_info[ent->driver_data];\r\nport_flags = port_info[0].flags;\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nhpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);\r\nif (!hpriv)\r\nreturn -ENOMEM;\r\npci_read_config_dword(pdev, PIIX_IOCFG, &hpriv->saved_iocfg);\r\nif (pdev->vendor == PCI_VENDOR_ID_INTEL && pdev->device == 0x2652) {\r\nrc = piix_disable_ahci(pdev);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (port_flags & ATA_FLAG_SATA)\r\nhpriv->map = piix_init_sata_map(pdev, port_info,\r\npiix_map_db_table[ent->driver_data]);\r\nrc = ata_pci_bmdma_prepare_host(pdev, ppi, &host);\r\nif (rc)\r\nreturn rc;\r\nhost->private_data = hpriv;\r\nif (port_flags & ATA_FLAG_SATA) {\r\npiix_init_pcs(host, piix_map_db_table[ent->driver_data]);\r\nrc = piix_init_sidpr(host);\r\nif (rc)\r\nreturn rc;\r\nif (host->ports[0]->ops == &piix_sidpr_sata_ops)\r\nsht = &piix_sidpr_sht;\r\n}\r\npiix_iocfg_bit18_quirk(host);\r\nif (port_flags & PIIX_FLAG_CHECKINTR)\r\npci_intx(pdev, 1);\r\nif (piix_check_450nx_errata(pdev)) {\r\nhost->ports[0]->mwdma_mask = 0;\r\nhost->ports[0]->udma_mask = 0;\r\nhost->ports[1]->mwdma_mask = 0;\r\nhost->ports[1]->udma_mask = 0;\r\n}\r\nhost->flags |= ATA_HOST_PARALLEL_SCAN;\r\npiix_ignore_devices_quirk(host);\r\npci_set_master(pdev);\r\nreturn ata_pci_sff_activate_host(host, ata_bmdma_interrupt, sht);\r\n}\r\nstatic void piix_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct ata_host *host = pci_get_drvdata(pdev);\r\nstruct piix_host_priv *hpriv = host->private_data;\r\npci_write_config_dword(pdev, PIIX_IOCFG, hpriv->saved_iocfg);\r\nata_pci_remove_one(pdev);\r\n}\r\nstatic int __init piix_init(void)\r\n{\r\nint rc;\r\nDPRINTK("pci_register_driver\n");\r\nrc = pci_register_driver(&piix_pci_driver);\r\nif (rc)\r\nreturn rc;\r\nin_module_init = 0;\r\nDPRINTK("done\n");\r\nreturn 0;\r\n}\r\nstatic void __exit piix_exit(void)\r\n{\r\npci_unregister_driver(&piix_pci_driver);\r\n}
