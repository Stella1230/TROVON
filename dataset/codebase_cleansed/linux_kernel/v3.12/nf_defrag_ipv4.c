static int nf_ct_ipv4_gather_frags(struct sk_buff *skb, u_int32_t user)\r\n{\r\nint err;\r\nskb_orphan(skb);\r\nlocal_bh_disable();\r\nerr = ip_defrag(skb, user);\r\nlocal_bh_enable();\r\nif (!err)\r\nip_send_check(ip_hdr(skb));\r\nreturn err;\r\n}\r\nstatic enum ip_defrag_users nf_ct_defrag_user(unsigned int hooknum,\r\nstruct sk_buff *skb)\r\n{\r\nu16 zone = NF_CT_DEFAULT_ZONE;\r\n#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)\r\nif (skb->nfct)\r\nzone = nf_ct_zone((struct nf_conn *)skb->nfct);\r\n#endif\r\n#ifdef CONFIG_BRIDGE_NETFILTER\r\nif (skb->nf_bridge &&\r\nskb->nf_bridge->mask & BRNF_NF_BRIDGE_PREROUTING)\r\nreturn IP_DEFRAG_CONNTRACK_BRIDGE_IN + zone;\r\n#endif\r\nif (hooknum == NF_INET_PRE_ROUTING)\r\nreturn IP_DEFRAG_CONNTRACK_IN + zone;\r\nelse\r\nreturn IP_DEFRAG_CONNTRACK_OUT + zone;\r\n}\r\nstatic unsigned int ipv4_conntrack_defrag(unsigned int hooknum,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nstruct sock *sk = skb->sk;\r\nstruct inet_sock *inet = inet_sk(skb->sk);\r\nif (sk && (sk->sk_family == PF_INET) &&\r\ninet->nodefrag)\r\nreturn NF_ACCEPT;\r\n#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)\r\n#if !defined(CONFIG_NF_NAT) && !defined(CONFIG_NF_NAT_MODULE)\r\nif (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))\r\nreturn NF_ACCEPT;\r\n#endif\r\n#endif\r\nif (ip_is_fragment(ip_hdr(skb))) {\r\nenum ip_defrag_users user = nf_ct_defrag_user(hooknum, skb);\r\nif (nf_ct_ipv4_gather_frags(skb, user))\r\nreturn NF_STOLEN;\r\n}\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int __init nf_defrag_init(void)\r\n{\r\nreturn nf_register_hooks(ipv4_defrag_ops, ARRAY_SIZE(ipv4_defrag_ops));\r\n}\r\nstatic void __exit nf_defrag_fini(void)\r\n{\r\nnf_unregister_hooks(ipv4_defrag_ops, ARRAY_SIZE(ipv4_defrag_ops));\r\n}\r\nvoid nf_defrag_ipv4_enable(void)\r\n{\r\n}
