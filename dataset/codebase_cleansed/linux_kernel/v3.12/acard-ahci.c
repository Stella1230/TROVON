static int acard_ahci_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)\r\n{\r\nstruct ata_host *host = pci_get_drvdata(pdev);\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nvoid __iomem *mmio = hpriv->mmio;\r\nu32 ctl;\r\nif (mesg.event & PM_EVENT_SUSPEND &&\r\nhpriv->flags & AHCI_HFLAG_NO_SUSPEND) {\r\ndev_err(&pdev->dev,\r\n"BIOS update required for suspend/resume\n");\r\nreturn -EIO;\r\n}\r\nif (mesg.event & PM_EVENT_SLEEP) {\r\nctl = readl(mmio + HOST_CTL);\r\nctl &= ~HOST_IRQ_EN;\r\nwritel(ctl, mmio + HOST_CTL);\r\nreadl(mmio + HOST_CTL);\r\n}\r\nreturn ata_pci_device_suspend(pdev, mesg);\r\n}\r\nstatic int acard_ahci_pci_device_resume(struct pci_dev *pdev)\r\n{\r\nstruct ata_host *host = pci_get_drvdata(pdev);\r\nint rc;\r\nrc = ata_pci_device_do_resume(pdev);\r\nif (rc)\r\nreturn rc;\r\nif (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND) {\r\nrc = ahci_reset_controller(host);\r\nif (rc)\r\nreturn rc;\r\nahci_init_controller(host);\r\n}\r\nata_host_resume(host);\r\nreturn 0;\r\n}\r\nstatic int acard_ahci_configure_dma_masks(struct pci_dev *pdev, int using_dac)\r\n{\r\nint rc;\r\nif (using_dac &&\r\n!pci_set_dma_mask(pdev, DMA_BIT_MASK(64))) {\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (rc) {\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_err(&pdev->dev,\r\n"64-bit DMA enable failed\n");\r\nreturn rc;\r\n}\r\n}\r\n} else {\r\nrc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_err(&pdev->dev, "32-bit DMA enable failed\n");\r\nreturn rc;\r\n}\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_err(&pdev->dev,\r\n"32-bit consistent DMA enable failed\n");\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void acard_ahci_pci_print_info(struct ata_host *host)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(host->dev);\r\nu16 cc;\r\nconst char *scc_s;\r\npci_read_config_word(pdev, 0x0a, &cc);\r\nif (cc == PCI_CLASS_STORAGE_IDE)\r\nscc_s = "IDE";\r\nelse if (cc == PCI_CLASS_STORAGE_SATA)\r\nscc_s = "SATA";\r\nelse if (cc == PCI_CLASS_STORAGE_RAID)\r\nscc_s = "RAID";\r\nelse\r\nscc_s = "unknown";\r\nahci_print_info(host, scc_s);\r\n}\r\nstatic unsigned int acard_ahci_fill_sg(struct ata_queued_cmd *qc, void *cmd_tbl)\r\n{\r\nstruct scatterlist *sg;\r\nstruct acard_sg *acard_sg = cmd_tbl + AHCI_CMD_TBL_HDR_SZ;\r\nunsigned int si, last_si = 0;\r\nVPRINTK("ENTER\n");\r\nfor_each_sg(qc->sg, sg, qc->n_elem, si) {\r\ndma_addr_t addr = sg_dma_address(sg);\r\nu32 sg_len = sg_dma_len(sg);\r\nacard_sg[si].addr = cpu_to_le32(addr & 0xffffffff);\r\nacard_sg[si].addr_hi = cpu_to_le32((addr >> 16) >> 16);\r\nacard_sg[si].size = cpu_to_le32(sg_len);\r\nlast_si = si;\r\n}\r\nacard_sg[last_si].size |= cpu_to_le32(1 << 31);\r\nreturn si;\r\n}\r\nstatic void acard_ahci_qc_prep(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nint is_atapi = ata_is_atapi(qc->tf.protocol);\r\nvoid *cmd_tbl;\r\nu32 opts;\r\nconst u32 cmd_fis_len = 5;\r\nunsigned int n_elem;\r\ncmd_tbl = pp->cmd_tbl + qc->tag * AHCI_CMD_TBL_SZ;\r\nata_tf_to_fis(&qc->tf, qc->dev->link->pmp, 1, cmd_tbl);\r\nif (is_atapi) {\r\nmemset(cmd_tbl + AHCI_CMD_TBL_CDB, 0, 32);\r\nmemcpy(cmd_tbl + AHCI_CMD_TBL_CDB, qc->cdb, qc->dev->cdb_len);\r\n}\r\nn_elem = 0;\r\nif (qc->flags & ATA_QCFLAG_DMAMAP)\r\nn_elem = acard_ahci_fill_sg(qc, cmd_tbl);\r\nopts = cmd_fis_len | (qc->dev->link->pmp << 12);\r\nif (qc->tf.flags & ATA_TFLAG_WRITE)\r\nopts |= AHCI_CMD_WRITE;\r\nif (is_atapi)\r\nopts |= AHCI_CMD_ATAPI | AHCI_CMD_PREFETCH;\r\nahci_fill_cmd_slot(pp, qc->tag, opts);\r\n}\r\nstatic bool acard_ahci_qc_fill_rtf(struct ata_queued_cmd *qc)\r\n{\r\nstruct ahci_port_priv *pp = qc->ap->private_data;\r\nu8 *rx_fis = pp->rx_fis;\r\nif (pp->fbs_enabled)\r\nrx_fis += qc->dev->link->pmp * ACARD_AHCI_RX_FIS_SZ;\r\nif (qc->tf.protocol == ATA_PROT_PIO && qc->dma_dir == DMA_FROM_DEVICE &&\r\n!(qc->flags & ATA_QCFLAG_FAILED)) {\r\nata_tf_from_fis(rx_fis + RX_FIS_PIO_SETUP, &qc->result_tf);\r\nqc->result_tf.command = (rx_fis + RX_FIS_PIO_SETUP)[15];\r\n} else\r\nata_tf_from_fis(rx_fis + RX_FIS_D2H_REG, &qc->result_tf);\r\nreturn true;\r\n}\r\nstatic int acard_ahci_port_start(struct ata_port *ap)\r\n{\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nstruct device *dev = ap->host->dev;\r\nstruct ahci_port_priv *pp;\r\nvoid *mem;\r\ndma_addr_t mem_dma;\r\nsize_t dma_sz, rx_fis_sz;\r\npp = devm_kzalloc(dev, sizeof(*pp), GFP_KERNEL);\r\nif (!pp)\r\nreturn -ENOMEM;\r\nif ((hpriv->cap & HOST_CAP_FBS) && sata_pmp_supported(ap)) {\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nu32 cmd = readl(port_mmio + PORT_CMD);\r\nif (cmd & PORT_CMD_FBSCP)\r\npp->fbs_supported = true;\r\nelse if (hpriv->flags & AHCI_HFLAG_YES_FBS) {\r\ndev_info(dev, "port %d can do FBS, forcing FBSCP\n",\r\nap->port_no);\r\npp->fbs_supported = true;\r\n} else\r\ndev_warn(dev, "port %d is not capable of FBS\n",\r\nap->port_no);\r\n}\r\nif (pp->fbs_supported) {\r\ndma_sz = AHCI_PORT_PRIV_FBS_DMA_SZ;\r\nrx_fis_sz = ACARD_AHCI_RX_FIS_SZ * 16;\r\n} else {\r\ndma_sz = AHCI_PORT_PRIV_DMA_SZ;\r\nrx_fis_sz = ACARD_AHCI_RX_FIS_SZ;\r\n}\r\nmem = dmam_alloc_coherent(dev, dma_sz, &mem_dma, GFP_KERNEL);\r\nif (!mem)\r\nreturn -ENOMEM;\r\nmemset(mem, 0, dma_sz);\r\npp->cmd_slot = mem;\r\npp->cmd_slot_dma = mem_dma;\r\nmem += AHCI_CMD_SLOT_SZ;\r\nmem_dma += AHCI_CMD_SLOT_SZ;\r\npp->rx_fis = mem;\r\npp->rx_fis_dma = mem_dma;\r\nmem += rx_fis_sz;\r\nmem_dma += rx_fis_sz;\r\npp->cmd_tbl = mem;\r\npp->cmd_tbl_dma = mem_dma;\r\npp->intr_mask = DEF_PORT_IRQ;\r\nap->private_data = pp;\r\nreturn ahci_port_resume(ap);\r\n}\r\nstatic int acard_ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nunsigned int board_id = ent->driver_data;\r\nstruct ata_port_info pi = acard_ahci_port_info[board_id];\r\nconst struct ata_port_info *ppi[] = { &pi, NULL };\r\nstruct device *dev = &pdev->dev;\r\nstruct ahci_host_priv *hpriv;\r\nstruct ata_host *host;\r\nint n_ports, i, rc;\r\nVPRINTK("ENTER\n");\r\nWARN_ON((int)ATA_MAX_QUEUE > AHCI_MAX_CMDS);\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nrc = pcim_iomap_regions_request_all(pdev, 1 << AHCI_PCI_BAR, DRV_NAME);\r\nif (rc == -EBUSY)\r\npcim_pin_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nhpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);\r\nif (!hpriv)\r\nreturn -ENOMEM;\r\nhpriv->flags |= (unsigned long)pi.private_data;\r\nif (!(hpriv->flags & AHCI_HFLAG_NO_MSI))\r\npci_enable_msi(pdev);\r\nhpriv->mmio = pcim_iomap_table(pdev)[AHCI_PCI_BAR];\r\nahci_save_initial_config(&pdev->dev, hpriv, 0, 0);\r\nif (hpriv->cap & HOST_CAP_NCQ)\r\npi.flags |= ATA_FLAG_NCQ;\r\nif (hpriv->cap & HOST_CAP_PMP)\r\npi.flags |= ATA_FLAG_PMP;\r\nahci_set_em_messages(hpriv, &pi);\r\nn_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));\r\nhost = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);\r\nif (!host)\r\nreturn -ENOMEM;\r\nhost->private_data = hpriv;\r\nif (!(hpriv->cap & HOST_CAP_SSS) || ahci_ignore_sss)\r\nhost->flags |= ATA_HOST_PARALLEL_SCAN;\r\nelse\r\nprintk(KERN_INFO "ahci: SSS flag set, parallel bus scan disabled\n");\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nata_port_pbar_desc(ap, AHCI_PCI_BAR, -1, "abar");\r\nata_port_pbar_desc(ap, AHCI_PCI_BAR,\r\n0x100 + ap->port_no * 0x80, "port");\r\nif (!(hpriv->port_map & (1 << i)))\r\nap->ops = &ata_dummy_port_ops;\r\n}\r\nrc = acard_ahci_configure_dma_masks(pdev, hpriv->cap & HOST_CAP_64);\r\nif (rc)\r\nreturn rc;\r\nrc = ahci_reset_controller(host);\r\nif (rc)\r\nreturn rc;\r\nahci_init_controller(host);\r\nacard_ahci_pci_print_info(host);\r\npci_set_master(pdev);\r\nreturn ata_host_activate(host, pdev->irq, ahci_interrupt, IRQF_SHARED,\r\n&acard_ahci_sht);\r\n}
