void\r\n__nv50_ram_put(struct nouveau_fb *pfb, struct nouveau_mem *mem)\r\n{\r\nstruct nouveau_mm_node *this;\r\nwhile (!list_empty(&mem->regions)) {\r\nthis = list_first_entry(&mem->regions, typeof(*this), rl_entry);\r\nlist_del(&this->rl_entry);\r\nnouveau_mm_free(&pfb->vram, &this);\r\n}\r\nnouveau_mm_free(&pfb->tags, &mem->tag);\r\n}\r\nvoid\r\nnv50_ram_put(struct nouveau_fb *pfb, struct nouveau_mem **pmem)\r\n{\r\nstruct nouveau_mem *mem = *pmem;\r\n*pmem = NULL;\r\nif (unlikely(mem == NULL))\r\nreturn;\r\nmutex_lock(&pfb->base.mutex);\r\n__nv50_ram_put(pfb, mem);\r\nmutex_unlock(&pfb->base.mutex);\r\nkfree(mem);\r\n}\r\nstatic int\r\nnv50_ram_get(struct nouveau_fb *pfb, u64 size, u32 align, u32 ncmin,\r\nu32 memtype, struct nouveau_mem **pmem)\r\n{\r\nstruct nouveau_mm *heap = &pfb->vram;\r\nstruct nouveau_mm *tags = &pfb->tags;\r\nstruct nouveau_mm_node *r;\r\nstruct nouveau_mem *mem;\r\nint comp = (memtype & 0x300) >> 8;\r\nint type = (memtype & 0x07f);\r\nint back = (memtype & 0x800);\r\nint min, max, ret;\r\nmax = (size >> 12);\r\nmin = ncmin ? (ncmin >> 12) : max;\r\nalign >>= 12;\r\nmem = kzalloc(sizeof(*mem), GFP_KERNEL);\r\nif (!mem)\r\nreturn -ENOMEM;\r\nmutex_lock(&pfb->base.mutex);\r\nif (comp) {\r\nif (align == 16) {\r\nint n = (max >> 4) * comp;\r\nret = nouveau_mm_head(tags, 1, n, n, 1, &mem->tag);\r\nif (ret)\r\nmem->tag = NULL;\r\n}\r\nif (unlikely(!mem->tag))\r\ncomp = 0;\r\n}\r\nINIT_LIST_HEAD(&mem->regions);\r\nmem->memtype = (comp << 7) | type;\r\nmem->size = max;\r\ntype = nv50_fb_memtype[type];\r\ndo {\r\nif (back)\r\nret = nouveau_mm_tail(heap, type, max, min, align, &r);\r\nelse\r\nret = nouveau_mm_head(heap, type, max, min, align, &r);\r\nif (ret) {\r\nmutex_unlock(&pfb->base.mutex);\r\npfb->ram->put(pfb, &mem);\r\nreturn ret;\r\n}\r\nlist_add_tail(&r->rl_entry, &mem->regions);\r\nmax -= r->length;\r\n} while (max);\r\nmutex_unlock(&pfb->base.mutex);\r\nr = list_first_entry(&mem->regions, struct nouveau_mm_node, rl_entry);\r\nmem->offset = (u64)r->offset << 12;\r\n*pmem = mem;\r\nreturn 0;\r\n}\r\nstatic u32\r\nnv50_fb_vram_rblock(struct nouveau_fb *pfb, struct nouveau_ram *ram)\r\n{\r\nint i, parts, colbits, rowbitsa, rowbitsb, banks;\r\nu64 rowsize, predicted;\r\nu32 r0, r4, rt, ru, rblock_size;\r\nr0 = nv_rd32(pfb, 0x100200);\r\nr4 = nv_rd32(pfb, 0x100204);\r\nrt = nv_rd32(pfb, 0x100250);\r\nru = nv_rd32(pfb, 0x001540);\r\nnv_debug(pfb, "memcfg 0x%08x 0x%08x 0x%08x 0x%08x\n", r0, r4, rt, ru);\r\nfor (i = 0, parts = 0; i < 8; i++) {\r\nif (ru & (0x00010000 << i))\r\nparts++;\r\n}\r\ncolbits = (r4 & 0x0000f000) >> 12;\r\nrowbitsa = ((r4 & 0x000f0000) >> 16) + 8;\r\nrowbitsb = ((r4 & 0x00f00000) >> 20) + 8;\r\nbanks = 1 << (((r4 & 0x03000000) >> 24) + 2);\r\nrowsize = parts * banks * (1 << colbits) * 8;\r\npredicted = rowsize << rowbitsa;\r\nif (r0 & 0x00000004)\r\npredicted += rowsize << rowbitsb;\r\nif (predicted != ram->size) {\r\nnv_warn(pfb, "memory controller reports %d MiB VRAM\n",\r\n(u32)(ram->size >> 20));\r\n}\r\nrblock_size = rowsize;\r\nif (rt & 1)\r\nrblock_size *= 3;\r\nnv_debug(pfb, "rblock %d bytes\n", rblock_size);\r\nreturn rblock_size;\r\n}\r\nstatic int\r\nnv50_ram_create(struct nouveau_object *parent, struct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass, void *data, u32 datasize,\r\nstruct nouveau_object **pobject)\r\n{\r\nstruct nouveau_fb *pfb = nouveau_fb(parent);\r\nstruct nouveau_device *device = nv_device(pfb);\r\nstruct nouveau_bios *bios = nouveau_bios(device);\r\nstruct nouveau_ram *ram;\r\nconst u32 rsvd_head = ( 256 * 1024) >> 12;\r\nconst u32 rsvd_tail = (1024 * 1024) >> 12;\r\nu32 size;\r\nint ret;\r\nret = nouveau_ram_create(parent, engine, oclass, &ram);\r\n*pobject = nv_object(ram);\r\nif (ret)\r\nreturn ret;\r\nram->size = nv_rd32(pfb, 0x10020c);\r\nram->size = (ram->size & 0xffffff00) |\r\n((ram->size & 0x000000ff) << 32);\r\nsize = (ram->size >> 12) - rsvd_head - rsvd_tail;\r\nswitch (device->chipset) {\r\ncase 0xaa:\r\ncase 0xac:\r\ncase 0xaf:\r\nret = nouveau_mm_init(&pfb->vram, rsvd_head, size, 1);\r\nif (ret)\r\nreturn ret;\r\nram->type = NV_MEM_TYPE_STOLEN;\r\nram->stolen = (u64)nv_rd32(pfb, 0x100e10) << 12;\r\nbreak;\r\ndefault:\r\nswitch (nv_rd32(pfb, 0x100714) & 0x00000007) {\r\ncase 0: ram->type = NV_MEM_TYPE_DDR1; break;\r\ncase 1:\r\nif (nouveau_fb_bios_memtype(bios) == NV_MEM_TYPE_DDR3)\r\nram->type = NV_MEM_TYPE_DDR3;\r\nelse\r\nram->type = NV_MEM_TYPE_DDR2;\r\nbreak;\r\ncase 2: ram->type = NV_MEM_TYPE_GDDR3; break;\r\ncase 3: ram->type = NV_MEM_TYPE_GDDR4; break;\r\ncase 4: ram->type = NV_MEM_TYPE_GDDR5; break;\r\ndefault:\r\nbreak;\r\n}\r\nret = nouveau_mm_init(&pfb->vram, rsvd_head, size,\r\nnv50_fb_vram_rblock(pfb, ram) >> 12);\r\nif (ret)\r\nreturn ret;\r\nram->ranks = (nv_rd32(pfb, 0x100200) & 0x4) ? 2 : 1;\r\nram->tags = nv_rd32(pfb, 0x100320);\r\nbreak;\r\n}\r\nram->get = nv50_ram_get;\r\nram->put = nv50_ram_put;\r\nreturn 0;\r\n}
