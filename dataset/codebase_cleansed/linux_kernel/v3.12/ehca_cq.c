int ehca_cq_assign_qp(struct ehca_cq *cq, struct ehca_qp *qp)\r\n{\r\nunsigned int qp_num = qp->real_qp_num;\r\nunsigned int key = qp_num & (QP_HASHTAB_LEN-1);\r\nunsigned long flags;\r\nspin_lock_irqsave(&cq->spinlock, flags);\r\nhlist_add_head(&qp->list_entries, &cq->qp_hashtab[key]);\r\nspin_unlock_irqrestore(&cq->spinlock, flags);\r\nehca_dbg(cq->ib_cq.device, "cq_num=%x real_qp_num=%x",\r\ncq->cq_number, qp_num);\r\nreturn 0;\r\n}\r\nint ehca_cq_unassign_qp(struct ehca_cq *cq, unsigned int real_qp_num)\r\n{\r\nint ret = -EINVAL;\r\nunsigned int key = real_qp_num & (QP_HASHTAB_LEN-1);\r\nstruct hlist_node *iter;\r\nstruct ehca_qp *qp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cq->spinlock, flags);\r\nhlist_for_each(iter, &cq->qp_hashtab[key]) {\r\nqp = hlist_entry(iter, struct ehca_qp, list_entries);\r\nif (qp->real_qp_num == real_qp_num) {\r\nhlist_del(iter);\r\nehca_dbg(cq->ib_cq.device,\r\n"removed qp from cq .cq_num=%x real_qp_num=%x",\r\ncq->cq_number, real_qp_num);\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&cq->spinlock, flags);\r\nif (ret)\r\nehca_err(cq->ib_cq.device,\r\n"qp not found cq_num=%x real_qp_num=%x",\r\ncq->cq_number, real_qp_num);\r\nreturn ret;\r\n}\r\nstruct ehca_qp *ehca_cq_get_qp(struct ehca_cq *cq, int real_qp_num)\r\n{\r\nstruct ehca_qp *ret = NULL;\r\nunsigned int key = real_qp_num & (QP_HASHTAB_LEN-1);\r\nstruct hlist_node *iter;\r\nstruct ehca_qp *qp;\r\nhlist_for_each(iter, &cq->qp_hashtab[key]) {\r\nqp = hlist_entry(iter, struct ehca_qp, list_entries);\r\nif (qp->real_qp_num == real_qp_num) {\r\nret = qp;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstruct ib_cq *ehca_create_cq(struct ib_device *device, int cqe, int comp_vector,\r\nstruct ib_ucontext *context,\r\nstruct ib_udata *udata)\r\n{\r\nstatic const u32 additional_cqe = 20;\r\nstruct ib_cq *cq;\r\nstruct ehca_cq *my_cq;\r\nstruct ehca_shca *shca =\r\ncontainer_of(device, struct ehca_shca, ib_device);\r\nstruct ipz_adapter_handle adapter_handle;\r\nstruct ehca_alloc_cq_parms param;\r\nstruct h_galpa gal;\r\nvoid *vpage;\r\nu32 counter;\r\nu64 rpage, cqx_fec, h_ret;\r\nint ipz_rc, i;\r\nunsigned long flags;\r\nif (cqe >= 0xFFFFFFFF - 64 - additional_cqe)\r\nreturn ERR_PTR(-EINVAL);\r\nif (!atomic_add_unless(&shca->num_cqs, 1, shca->max_num_cqs)) {\r\nehca_err(device, "Unable to create CQ, max number of %i "\r\n"CQs reached.", shca->max_num_cqs);\r\nehca_err(device, "To increase the maximum number of CQs "\r\n"use the number_of_cqs module parameter.\n");\r\nreturn ERR_PTR(-ENOSPC);\r\n}\r\nmy_cq = kmem_cache_zalloc(cq_cache, GFP_KERNEL);\r\nif (!my_cq) {\r\nehca_err(device, "Out of memory for ehca_cq struct device=%p",\r\ndevice);\r\natomic_dec(&shca->num_cqs);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nmemset(&param, 0, sizeof(struct ehca_alloc_cq_parms));\r\nspin_lock_init(&my_cq->spinlock);\r\nspin_lock_init(&my_cq->cb_lock);\r\nspin_lock_init(&my_cq->task_lock);\r\natomic_set(&my_cq->nr_events, 0);\r\ninit_waitqueue_head(&my_cq->wait_completion);\r\ncq = &my_cq->ib_cq;\r\nadapter_handle = shca->ipz_hca_handle;\r\nparam.eq_handle = shca->eq.ipz_eq_handle;\r\nidr_preload(GFP_KERNEL);\r\nwrite_lock_irqsave(&ehca_cq_idr_lock, flags);\r\nmy_cq->token = idr_alloc(&ehca_cq_idr, my_cq, 0, 0x2000000, GFP_NOWAIT);\r\nwrite_unlock_irqrestore(&ehca_cq_idr_lock, flags);\r\nidr_preload_end();\r\nif (my_cq->token < 0) {\r\ncq = ERR_PTR(-ENOMEM);\r\nehca_err(device, "Can't allocate new idr entry. device=%p",\r\ndevice);\r\ngoto create_cq_exit1;\r\n}\r\nparam.nr_cqe = cqe + additional_cqe;\r\nh_ret = hipz_h_alloc_resource_cq(adapter_handle, my_cq, &param);\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(device, "hipz_h_alloc_resource_cq() failed "\r\n"h_ret=%lli device=%p", h_ret, device);\r\ncq = ERR_PTR(ehca2ib_return_code(h_ret));\r\ngoto create_cq_exit2;\r\n}\r\nipz_rc = ipz_queue_ctor(NULL, &my_cq->ipz_queue, param.act_pages,\r\nEHCA_PAGESIZE, sizeof(struct ehca_cqe), 0, 0);\r\nif (!ipz_rc) {\r\nehca_err(device, "ipz_queue_ctor() failed ipz_rc=%i device=%p",\r\nipz_rc, device);\r\ncq = ERR_PTR(-EINVAL);\r\ngoto create_cq_exit3;\r\n}\r\nfor (counter = 0; counter < param.act_pages; counter++) {\r\nvpage = ipz_qpageit_get_inc(&my_cq->ipz_queue);\r\nif (!vpage) {\r\nehca_err(device, "ipz_qpageit_get_inc() "\r\n"returns NULL device=%p", device);\r\ncq = ERR_PTR(-EAGAIN);\r\ngoto create_cq_exit4;\r\n}\r\nrpage = __pa(vpage);\r\nh_ret = hipz_h_register_rpage_cq(adapter_handle,\r\nmy_cq->ipz_cq_handle,\r\n&my_cq->pf,\r\n0,\r\n0,\r\nrpage,\r\n1,\r\nmy_cq->galpas.\r\nkernel);\r\nif (h_ret < H_SUCCESS) {\r\nehca_err(device, "hipz_h_register_rpage_cq() failed "\r\n"ehca_cq=%p cq_num=%x h_ret=%lli counter=%i "\r\n"act_pages=%i", my_cq, my_cq->cq_number,\r\nh_ret, counter, param.act_pages);\r\ncq = ERR_PTR(-EINVAL);\r\ngoto create_cq_exit4;\r\n}\r\nif (counter == (param.act_pages - 1)) {\r\nvpage = ipz_qpageit_get_inc(&my_cq->ipz_queue);\r\nif ((h_ret != H_SUCCESS) || vpage) {\r\nehca_err(device, "Registration of pages not "\r\n"complete ehca_cq=%p cq_num=%x "\r\n"h_ret=%lli", my_cq, my_cq->cq_number,\r\nh_ret);\r\ncq = ERR_PTR(-EAGAIN);\r\ngoto create_cq_exit4;\r\n}\r\n} else {\r\nif (h_ret != H_PAGE_REGISTERED) {\r\nehca_err(device, "Registration of page failed "\r\n"ehca_cq=%p cq_num=%x h_ret=%lli "\r\n"counter=%i act_pages=%i",\r\nmy_cq, my_cq->cq_number,\r\nh_ret, counter, param.act_pages);\r\ncq = ERR_PTR(-ENOMEM);\r\ngoto create_cq_exit4;\r\n}\r\n}\r\n}\r\nipz_qeit_reset(&my_cq->ipz_queue);\r\ngal = my_cq->galpas.kernel;\r\ncqx_fec = hipz_galpa_load(gal, CQTEMM_OFFSET(cqx_fec));\r\nehca_dbg(device, "ehca_cq=%p cq_num=%x CQX_FEC=%llx",\r\nmy_cq, my_cq->cq_number, cqx_fec);\r\nmy_cq->ib_cq.cqe = my_cq->nr_of_entries =\r\nparam.act_nr_of_entries - additional_cqe;\r\nmy_cq->cq_number = (my_cq->ipz_cq_handle.handle) & 0xffff;\r\nfor (i = 0; i < QP_HASHTAB_LEN; i++)\r\nINIT_HLIST_HEAD(&my_cq->qp_hashtab[i]);\r\nINIT_LIST_HEAD(&my_cq->sqp_err_list);\r\nINIT_LIST_HEAD(&my_cq->rqp_err_list);\r\nif (context) {\r\nstruct ipz_queue *ipz_queue = &my_cq->ipz_queue;\r\nstruct ehca_create_cq_resp resp;\r\nmemset(&resp, 0, sizeof(resp));\r\nresp.cq_number = my_cq->cq_number;\r\nresp.token = my_cq->token;\r\nresp.ipz_queue.qe_size = ipz_queue->qe_size;\r\nresp.ipz_queue.act_nr_of_sg = ipz_queue->act_nr_of_sg;\r\nresp.ipz_queue.queue_length = ipz_queue->queue_length;\r\nresp.ipz_queue.pagesize = ipz_queue->pagesize;\r\nresp.ipz_queue.toggle_state = ipz_queue->toggle_state;\r\nresp.fw_handle_ofs = (u32)\r\n(my_cq->galpas.user.fw_handle & (PAGE_SIZE - 1));\r\nif (ib_copy_to_udata(udata, &resp, sizeof(resp))) {\r\nehca_err(device, "Copy to udata failed.");\r\ngoto create_cq_exit4;\r\n}\r\n}\r\nreturn cq;\r\ncreate_cq_exit4:\r\nipz_queue_dtor(NULL, &my_cq->ipz_queue);\r\ncreate_cq_exit3:\r\nh_ret = hipz_h_destroy_cq(adapter_handle, my_cq, 1);\r\nif (h_ret != H_SUCCESS)\r\nehca_err(device, "hipz_h_destroy_cq() failed ehca_cq=%p "\r\n"cq_num=%x h_ret=%lli", my_cq, my_cq->cq_number, h_ret);\r\ncreate_cq_exit2:\r\nwrite_lock_irqsave(&ehca_cq_idr_lock, flags);\r\nidr_remove(&ehca_cq_idr, my_cq->token);\r\nwrite_unlock_irqrestore(&ehca_cq_idr_lock, flags);\r\ncreate_cq_exit1:\r\nkmem_cache_free(cq_cache, my_cq);\r\natomic_dec(&shca->num_cqs);\r\nreturn cq;\r\n}\r\nint ehca_destroy_cq(struct ib_cq *cq)\r\n{\r\nu64 h_ret;\r\nstruct ehca_cq *my_cq = container_of(cq, struct ehca_cq, ib_cq);\r\nint cq_num = my_cq->cq_number;\r\nstruct ib_device *device = cq->device;\r\nstruct ehca_shca *shca = container_of(device, struct ehca_shca,\r\nib_device);\r\nstruct ipz_adapter_handle adapter_handle = shca->ipz_hca_handle;\r\nunsigned long flags;\r\nif (cq->uobject) {\r\nif (my_cq->mm_count_galpa || my_cq->mm_count_queue) {\r\nehca_err(device, "Resources still referenced in "\r\n"user space cq_num=%x", my_cq->cq_number);\r\nreturn -EINVAL;\r\n}\r\n}\r\nwrite_lock_irqsave(&ehca_cq_idr_lock, flags);\r\nidr_remove(&ehca_cq_idr, my_cq->token);\r\nwrite_unlock_irqrestore(&ehca_cq_idr_lock, flags);\r\nwait_event(my_cq->wait_completion, !atomic_read(&my_cq->nr_events));\r\nh_ret = hipz_h_destroy_cq(adapter_handle, my_cq, 0);\r\nif (h_ret == H_R_STATE) {\r\nehca_dbg(device, "ehca_cq=%p cq_num=%x resource=%llx in err "\r\n"state. Try to delete it forcibly.",\r\nmy_cq, cq_num, my_cq->ipz_cq_handle.handle);\r\nehca_error_data(shca, my_cq, my_cq->ipz_cq_handle.handle);\r\nh_ret = hipz_h_destroy_cq(adapter_handle, my_cq, 1);\r\nif (h_ret == H_SUCCESS)\r\nehca_dbg(device, "cq_num=%x deleted successfully.",\r\ncq_num);\r\n}\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(device, "hipz_h_destroy_cq() failed h_ret=%lli "\r\n"ehca_cq=%p cq_num=%x", h_ret, my_cq, cq_num);\r\nreturn ehca2ib_return_code(h_ret);\r\n}\r\nipz_queue_dtor(NULL, &my_cq->ipz_queue);\r\nkmem_cache_free(cq_cache, my_cq);\r\natomic_dec(&shca->num_cqs);\r\nreturn 0;\r\n}\r\nint ehca_resize_cq(struct ib_cq *cq, int cqe, struct ib_udata *udata)\r\n{\r\nehca_err(cq->device, "not implemented yet");\r\nreturn -EFAULT;\r\n}\r\nint ehca_init_cq_cache(void)\r\n{\r\ncq_cache = kmem_cache_create("ehca_cache_cq",\r\nsizeof(struct ehca_cq), 0,\r\nSLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (!cq_cache)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid ehca_cleanup_cq_cache(void)\r\n{\r\nif (cq_cache)\r\nkmem_cache_destroy(cq_cache);\r\n}
