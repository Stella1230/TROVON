void tty_port_init(struct tty_port *port)\r\n{\r\nmemset(port, 0, sizeof(*port));\r\ntty_buffer_init(port);\r\ninit_waitqueue_head(&port->open_wait);\r\ninit_waitqueue_head(&port->close_wait);\r\ninit_waitqueue_head(&port->delta_msr_wait);\r\nmutex_init(&port->mutex);\r\nmutex_init(&port->buf_mutex);\r\nspin_lock_init(&port->lock);\r\nport->close_delay = (50 * HZ) / 100;\r\nport->closing_wait = (3000 * HZ) / 100;\r\nkref_init(&port->kref);\r\n}\r\nvoid tty_port_link_device(struct tty_port *port,\r\nstruct tty_driver *driver, unsigned index)\r\n{\r\nif (WARN_ON(index >= driver->num))\r\nreturn;\r\ndriver->ports[index] = port;\r\n}\r\nstruct device *tty_port_register_device(struct tty_port *port,\r\nstruct tty_driver *driver, unsigned index,\r\nstruct device *device)\r\n{\r\ntty_port_link_device(port, driver, index);\r\nreturn tty_register_device(driver, index, device);\r\n}\r\nstruct device *tty_port_register_device_attr(struct tty_port *port,\r\nstruct tty_driver *driver, unsigned index,\r\nstruct device *device, void *drvdata,\r\nconst struct attribute_group **attr_grp)\r\n{\r\ntty_port_link_device(port, driver, index);\r\nreturn tty_register_device_attr(driver, index, device, drvdata,\r\nattr_grp);\r\n}\r\nint tty_port_alloc_xmit_buf(struct tty_port *port)\r\n{\r\nmutex_lock(&port->buf_mutex);\r\nif (port->xmit_buf == NULL)\r\nport->xmit_buf = (unsigned char *)get_zeroed_page(GFP_KERNEL);\r\nmutex_unlock(&port->buf_mutex);\r\nif (port->xmit_buf == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid tty_port_free_xmit_buf(struct tty_port *port)\r\n{\r\nmutex_lock(&port->buf_mutex);\r\nif (port->xmit_buf != NULL) {\r\nfree_page((unsigned long)port->xmit_buf);\r\nport->xmit_buf = NULL;\r\n}\r\nmutex_unlock(&port->buf_mutex);\r\n}\r\nvoid tty_port_destroy(struct tty_port *port)\r\n{\r\ncancel_work_sync(&port->buf.work);\r\ntty_buffer_free_all(port);\r\n}\r\nstatic void tty_port_destructor(struct kref *kref)\r\n{\r\nstruct tty_port *port = container_of(kref, struct tty_port, kref);\r\nif (port->xmit_buf)\r\nfree_page((unsigned long)port->xmit_buf);\r\ntty_port_destroy(port);\r\nif (port->ops && port->ops->destruct)\r\nport->ops->destruct(port);\r\nelse\r\nkfree(port);\r\n}\r\nvoid tty_port_put(struct tty_port *port)\r\n{\r\nif (port)\r\nkref_put(&port->kref, tty_port_destructor);\r\n}\r\nstruct tty_struct *tty_port_tty_get(struct tty_port *port)\r\n{\r\nunsigned long flags;\r\nstruct tty_struct *tty;\r\nspin_lock_irqsave(&port->lock, flags);\r\ntty = tty_kref_get(port->tty);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn tty;\r\n}\r\nvoid tty_port_tty_set(struct tty_port *port, struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (port->tty)\r\ntty_kref_put(port->tty);\r\nport->tty = tty_kref_get(tty);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void tty_port_shutdown(struct tty_port *port, struct tty_struct *tty)\r\n{\r\nmutex_lock(&port->mutex);\r\nif (port->console)\r\ngoto out;\r\nif (test_and_clear_bit(ASYNCB_INITIALIZED, &port->flags)) {\r\nif (tty && C_HUPCL(tty))\r\ntty_port_lower_dtr_rts(port);\r\nif (port->ops->shutdown)\r\nport->ops->shutdown(port);\r\n}\r\nout:\r\nmutex_unlock(&port->mutex);\r\n}\r\nvoid tty_port_hangup(struct tty_port *port)\r\n{\r\nstruct tty_struct *tty;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nport->count = 0;\r\nport->flags &= ~ASYNC_NORMAL_ACTIVE;\r\ntty = port->tty;\r\nif (tty)\r\nset_bit(TTY_IO_ERROR, &tty->flags);\r\nport->tty = NULL;\r\nspin_unlock_irqrestore(&port->lock, flags);\r\ntty_port_shutdown(port, tty);\r\ntty_kref_put(tty);\r\nwake_up_interruptible(&port->open_wait);\r\nwake_up_interruptible(&port->delta_msr_wait);\r\n}\r\nvoid tty_port_tty_hangup(struct tty_port *port, bool check_clocal)\r\n{\r\nstruct tty_struct *tty = tty_port_tty_get(port);\r\nif (tty && (!check_clocal || !C_CLOCAL(tty)))\r\ntty_hangup(tty);\r\ntty_kref_put(tty);\r\n}\r\nvoid tty_port_tty_wakeup(struct tty_port *port)\r\n{\r\nstruct tty_struct *tty = tty_port_tty_get(port);\r\nif (tty) {\r\ntty_wakeup(tty);\r\ntty_kref_put(tty);\r\n}\r\n}\r\nint tty_port_carrier_raised(struct tty_port *port)\r\n{\r\nif (port->ops->carrier_raised == NULL)\r\nreturn 1;\r\nreturn port->ops->carrier_raised(port);\r\n}\r\nvoid tty_port_raise_dtr_rts(struct tty_port *port)\r\n{\r\nif (port->ops->dtr_rts)\r\nport->ops->dtr_rts(port, 1);\r\n}\r\nvoid tty_port_lower_dtr_rts(struct tty_port *port)\r\n{\r\nif (port->ops->dtr_rts)\r\nport->ops->dtr_rts(port, 0);\r\n}\r\nint tty_port_block_til_ready(struct tty_port *port,\r\nstruct tty_struct *tty, struct file *filp)\r\n{\r\nint do_clocal = 0, retval;\r\nunsigned long flags;\r\nDEFINE_WAIT(wait);\r\nif (tty_hung_up_p(filp) || port->flags & ASYNC_CLOSING) {\r\nwait_event_interruptible_tty(tty, port->close_wait,\r\n!(port->flags & ASYNC_CLOSING));\r\nif (port->flags & ASYNC_HUP_NOTIFY)\r\nreturn -EAGAIN;\r\nelse\r\nreturn -ERESTARTSYS;\r\n}\r\nif (tty->flags & (1 << TTY_IO_ERROR)) {\r\nport->flags |= ASYNC_NORMAL_ACTIVE;\r\nreturn 0;\r\n}\r\nif (filp->f_flags & O_NONBLOCK) {\r\nif (tty->termios.c_cflag & CBAUD)\r\ntty_port_raise_dtr_rts(port);\r\nport->flags |= ASYNC_NORMAL_ACTIVE;\r\nreturn 0;\r\n}\r\nif (C_CLOCAL(tty))\r\ndo_clocal = 1;\r\nretval = 0;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (!tty_hung_up_p(filp))\r\nport->count--;\r\nport->blocked_open++;\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nwhile (1) {\r\nif (C_BAUD(tty) && test_bit(ASYNCB_INITIALIZED, &port->flags))\r\ntty_port_raise_dtr_rts(port);\r\nprepare_to_wait(&port->open_wait, &wait, TASK_INTERRUPTIBLE);\r\nif (tty_hung_up_p(filp) || !(port->flags & ASYNC_INITIALIZED)) {\r\nif (port->flags & ASYNC_HUP_NOTIFY)\r\nretval = -EAGAIN;\r\nelse\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (!(port->flags & ASYNC_CLOSING) &&\r\n(do_clocal || tty_port_carrier_raised(port)))\r\nbreak;\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\ntty_unlock(tty);\r\nschedule();\r\ntty_lock(tty);\r\n}\r\nfinish_wait(&port->open_wait, &wait);\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (!tty_hung_up_p(filp))\r\nport->count++;\r\nport->blocked_open--;\r\nif (retval == 0)\r\nport->flags |= ASYNC_NORMAL_ACTIVE;\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn retval;\r\n}\r\nstatic void tty_port_drain_delay(struct tty_port *port, struct tty_struct *tty)\r\n{\r\nunsigned int bps = tty_get_baud_rate(tty);\r\nlong timeout;\r\nif (bps > 1200) {\r\ntimeout = (HZ * 10 * port->drain_delay) / bps;\r\ntimeout = max_t(long, timeout, HZ / 10);\r\n} else {\r\ntimeout = 2 * HZ;\r\n}\r\nschedule_timeout_interruptible(timeout);\r\n}\r\nint tty_port_close_start(struct tty_port *port,\r\nstruct tty_struct *tty, struct file *filp)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (tty_hung_up_p(filp)) {\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn 0;\r\n}\r\nif (tty->count == 1 && port->count != 1) {\r\nprintk(KERN_WARNING\r\n"tty_port_close_start: tty->count = 1 port count = %d.\n",\r\nport->count);\r\nport->count = 1;\r\n}\r\nif (--port->count < 0) {\r\nprintk(KERN_WARNING "tty_port_close_start: count = %d\n",\r\nport->count);\r\nport->count = 0;\r\n}\r\nif (port->count) {\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif (port->ops->drop)\r\nport->ops->drop(port);\r\nreturn 0;\r\n}\r\nset_bit(ASYNCB_CLOSING, &port->flags);\r\ntty->closing = 1;\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif (test_bit(ASYNCB_INITIALIZED, &port->flags)) {\r\nif (tty->flow_stopped)\r\ntty_driver_flush_buffer(tty);\r\nif (port->closing_wait != ASYNC_CLOSING_WAIT_NONE)\r\ntty_wait_until_sent_from_close(tty, port->closing_wait);\r\nif (port->drain_delay)\r\ntty_port_drain_delay(port, tty);\r\n}\r\ntty_ldisc_flush(tty);\r\nreturn 1;\r\n}\r\nvoid tty_port_close_end(struct tty_port *port, struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\ntty->closing = 0;\r\nif (port->blocked_open) {\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif (port->close_delay) {\r\nmsleep_interruptible(\r\njiffies_to_msecs(port->close_delay));\r\n}\r\nspin_lock_irqsave(&port->lock, flags);\r\nwake_up_interruptible(&port->open_wait);\r\n}\r\nport->flags &= ~(ASYNC_NORMAL_ACTIVE | ASYNC_CLOSING);\r\nwake_up_interruptible(&port->close_wait);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nvoid tty_port_close(struct tty_port *port, struct tty_struct *tty,\r\nstruct file *filp)\r\n{\r\nif (tty_port_close_start(port, tty, filp) == 0)\r\nreturn;\r\ntty_port_shutdown(port, tty);\r\nset_bit(TTY_IO_ERROR, &tty->flags);\r\ntty_port_close_end(port, tty);\r\ntty_port_tty_set(port, NULL);\r\n}\r\nint tty_port_install(struct tty_port *port, struct tty_driver *driver,\r\nstruct tty_struct *tty)\r\n{\r\ntty->port = port;\r\nreturn tty_standard_install(driver, tty);\r\n}\r\nint tty_port_open(struct tty_port *port, struct tty_struct *tty,\r\nstruct file *filp)\r\n{\r\nspin_lock_irq(&port->lock);\r\nif (!tty_hung_up_p(filp))\r\n++port->count;\r\nspin_unlock_irq(&port->lock);\r\ntty_port_tty_set(port, tty);\r\nmutex_lock(&port->mutex);\r\nif (!test_bit(ASYNCB_INITIALIZED, &port->flags)) {\r\nclear_bit(TTY_IO_ERROR, &tty->flags);\r\nif (port->ops->activate) {\r\nint retval = port->ops->activate(port, tty);\r\nif (retval) {\r\nmutex_unlock(&port->mutex);\r\nreturn retval;\r\n}\r\n}\r\nset_bit(ASYNCB_INITIALIZED, &port->flags);\r\n}\r\nmutex_unlock(&port->mutex);\r\nreturn tty_port_block_til_ready(port, tty, filp);\r\n}
