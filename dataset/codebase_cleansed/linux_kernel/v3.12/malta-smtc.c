static void msmtc_send_ipi_single(int cpu, unsigned int action)\r\n{\r\nsmtc_send_ipi(cpu, LINUX_SMP_IPI, action);\r\n}\r\nstatic void msmtc_send_ipi_mask(const struct cpumask *mask, unsigned int action)\r\n{\r\nunsigned int i;\r\nfor_each_cpu(i, mask)\r\nmsmtc_send_ipi_single(i, action);\r\n}\r\nstatic void msmtc_init_secondary(void)\r\n{\r\nint myvpe;\r\nmyvpe = read_c0_tcbind() & TCBIND_CURVPE;\r\nif (myvpe != 0) {\r\nclear_c0_status(ST0_IM);\r\nset_c0_status((0x100 << cp0_compare_irq)\r\n| (0x100 << MIPS_CPU_IPI_IRQ));\r\nif (cp0_perfcount_irq >= 0)\r\nset_c0_status(0x100 << cp0_perfcount_irq);\r\n}\r\nsmtc_init_secondary();\r\n}\r\nstatic void msmtc_boot_secondary(int cpu, struct task_struct *idle)\r\n{\r\nsmtc_boot_secondary(cpu, idle);\r\n}\r\nstatic void msmtc_smp_finish(void)\r\n{\r\nsmtc_smp_finish();\r\n}\r\nstatic void msmtc_cpus_done(void)\r\n{\r\n}\r\nstatic void __init msmtc_smp_setup(void)\r\n{\r\nsmp_num_siblings = smtc_build_cpu_map(0);\r\n}\r\nstatic void __init msmtc_prepare_cpus(unsigned int max_cpus)\r\n{\r\nsmtc_prepare_cpus(max_cpus);\r\n}\r\nint plat_set_irq_affinity(struct irq_data *d, const struct cpumask *affinity,\r\nbool force)\r\n{\r\ncpumask_t tmask;\r\nint cpu = 0;\r\nvoid smtc_set_irq_affinity(unsigned int irq, cpumask_t aff);\r\ncpumask_copy(&tmask, affinity);\r\nfor_each_cpu(cpu, affinity) {\r\nif ((cpu_data[cpu].vpe_id != 0) || !cpu_online(cpu))\r\ncpu_clear(cpu, tmask);\r\n}\r\ncpumask_copy(d->affinity, &tmask);\r\nif (cpus_empty(tmask))\r\nprintk(KERN_WARNING\r\n"IRQ affinity leaves no legal CPU for IRQ %d\n", d->irq);\r\nsmtc_set_irq_affinity(d->irq, tmask);\r\nreturn IRQ_SET_MASK_OK_NOCOPY;\r\n}
