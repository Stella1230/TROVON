static void ax25_free_sock(struct sock *sk)\r\n{\r\nax25_cb_put(ax25_sk(sk));\r\n}\r\nstatic void ax25_cb_del(ax25_cb *ax25)\r\n{\r\nif (!hlist_unhashed(&ax25->ax25_node)) {\r\nspin_lock_bh(&ax25_list_lock);\r\nhlist_del_init(&ax25->ax25_node);\r\nspin_unlock_bh(&ax25_list_lock);\r\nax25_cb_put(ax25);\r\n}\r\n}\r\nstatic void ax25_kill_by_device(struct net_device *dev)\r\n{\r\nax25_dev *ax25_dev;\r\nax25_cb *s;\r\nif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\r\nreturn;\r\nspin_lock_bh(&ax25_list_lock);\r\nagain:\r\nax25_for_each(s, &ax25_list) {\r\nif (s->ax25_dev == ax25_dev) {\r\ns->ax25_dev = NULL;\r\nspin_unlock_bh(&ax25_list_lock);\r\nax25_disconnect(s, ENETUNREACH);\r\nspin_lock_bh(&ax25_list_lock);\r\ngoto again;\r\n}\r\n}\r\nspin_unlock_bh(&ax25_list_lock);\r\n}\r\nstatic int ax25_device_event(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nif (!net_eq(dev_net(dev), &init_net))\r\nreturn NOTIFY_DONE;\r\nif (dev->type != ARPHRD_AX25)\r\nreturn NOTIFY_DONE;\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nax25_dev_device_up(dev);\r\nbreak;\r\ncase NETDEV_DOWN:\r\nax25_kill_by_device(dev);\r\nax25_rt_device_down(dev);\r\nax25_dev_device_down(dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nvoid ax25_cb_add(ax25_cb *ax25)\r\n{\r\nspin_lock_bh(&ax25_list_lock);\r\nax25_cb_hold(ax25);\r\nhlist_add_head(&ax25->ax25_node, &ax25_list);\r\nspin_unlock_bh(&ax25_list_lock);\r\n}\r\nstruct sock *ax25_find_listener(ax25_address *addr, int digi,\r\nstruct net_device *dev, int type)\r\n{\r\nax25_cb *s;\r\nspin_lock(&ax25_list_lock);\r\nax25_for_each(s, &ax25_list) {\r\nif ((s->iamdigi && !digi) || (!s->iamdigi && digi))\r\ncontinue;\r\nif (s->sk && !ax25cmp(&s->source_addr, addr) &&\r\ns->sk->sk_type == type && s->sk->sk_state == TCP_LISTEN) {\r\nif (s->ax25_dev == NULL || s->ax25_dev->dev == dev) {\r\nsock_hold(s->sk);\r\nspin_unlock(&ax25_list_lock);\r\nreturn s->sk;\r\n}\r\n}\r\n}\r\nspin_unlock(&ax25_list_lock);\r\nreturn NULL;\r\n}\r\nstruct sock *ax25_get_socket(ax25_address *my_addr, ax25_address *dest_addr,\r\nint type)\r\n{\r\nstruct sock *sk = NULL;\r\nax25_cb *s;\r\nspin_lock(&ax25_list_lock);\r\nax25_for_each(s, &ax25_list) {\r\nif (s->sk && !ax25cmp(&s->source_addr, my_addr) &&\r\n!ax25cmp(&s->dest_addr, dest_addr) &&\r\ns->sk->sk_type == type) {\r\nsk = s->sk;\r\nsock_hold(sk);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&ax25_list_lock);\r\nreturn sk;\r\n}\r\nax25_cb *ax25_find_cb(ax25_address *src_addr, ax25_address *dest_addr,\r\nax25_digi *digi, struct net_device *dev)\r\n{\r\nax25_cb *s;\r\nspin_lock_bh(&ax25_list_lock);\r\nax25_for_each(s, &ax25_list) {\r\nif (s->sk && s->sk->sk_type != SOCK_SEQPACKET)\r\ncontinue;\r\nif (s->ax25_dev == NULL)\r\ncontinue;\r\nif (ax25cmp(&s->source_addr, src_addr) == 0 && ax25cmp(&s->dest_addr, dest_addr) == 0 && s->ax25_dev->dev == dev) {\r\nif (digi != NULL && digi->ndigi != 0) {\r\nif (s->digipeat == NULL)\r\ncontinue;\r\nif (ax25digicmp(s->digipeat, digi) != 0)\r\ncontinue;\r\n} else {\r\nif (s->digipeat != NULL && s->digipeat->ndigi != 0)\r\ncontinue;\r\n}\r\nax25_cb_hold(s);\r\nspin_unlock_bh(&ax25_list_lock);\r\nreturn s;\r\n}\r\n}\r\nspin_unlock_bh(&ax25_list_lock);\r\nreturn NULL;\r\n}\r\nvoid ax25_send_to_raw(ax25_address *addr, struct sk_buff *skb, int proto)\r\n{\r\nax25_cb *s;\r\nstruct sk_buff *copy;\r\nspin_lock(&ax25_list_lock);\r\nax25_for_each(s, &ax25_list) {\r\nif (s->sk != NULL && ax25cmp(&s->source_addr, addr) == 0 &&\r\ns->sk->sk_type == SOCK_RAW &&\r\ns->sk->sk_protocol == proto &&\r\ns->ax25_dev->dev == skb->dev &&\r\natomic_read(&s->sk->sk_rmem_alloc) <= s->sk->sk_rcvbuf) {\r\nif ((copy = skb_clone(skb, GFP_ATOMIC)) == NULL)\r\ncontinue;\r\nif (sock_queue_rcv_skb(s->sk, copy) != 0)\r\nkfree_skb(copy);\r\n}\r\n}\r\nspin_unlock(&ax25_list_lock);\r\n}\r\nstatic void ax25_destroy_timer(unsigned long data)\r\n{\r\nax25_cb *ax25=(ax25_cb *)data;\r\nstruct sock *sk;\r\nsk=ax25->sk;\r\nbh_lock_sock(sk);\r\nsock_hold(sk);\r\nax25_destroy_socket(ax25);\r\nbh_unlock_sock(sk);\r\nsock_put(sk);\r\n}\r\nvoid ax25_destroy_socket(ax25_cb *ax25)\r\n{\r\nstruct sk_buff *skb;\r\nax25_cb_del(ax25);\r\nax25_stop_heartbeat(ax25);\r\nax25_stop_t1timer(ax25);\r\nax25_stop_t2timer(ax25);\r\nax25_stop_t3timer(ax25);\r\nax25_stop_idletimer(ax25);\r\nax25_clear_queues(ax25);\r\nif (ax25->sk != NULL) {\r\nwhile ((skb = skb_dequeue(&ax25->sk->sk_receive_queue)) != NULL) {\r\nif (skb->sk != ax25->sk) {\r\nax25_cb *sax25 = ax25_sk(skb->sk);\r\nsock_orphan(skb->sk);\r\nskb->sk->sk_state = TCP_LISTEN;\r\nax25_start_heartbeat(sax25);\r\nsax25->state = AX25_STATE_0;\r\n}\r\nkfree_skb(skb);\r\n}\r\nskb_queue_purge(&ax25->sk->sk_write_queue);\r\n}\r\nif (ax25->sk != NULL) {\r\nif (sk_has_allocations(ax25->sk)) {\r\nsetup_timer(&ax25->dtimer, ax25_destroy_timer,\r\n(unsigned long)ax25);\r\nax25->dtimer.expires = jiffies + 2 * HZ;\r\nadd_timer(&ax25->dtimer);\r\n} else {\r\nstruct sock *sk=ax25->sk;\r\nax25->sk=NULL;\r\nsock_put(sk);\r\n}\r\n} else {\r\nax25_cb_put(ax25);\r\n}\r\n}\r\nstatic int ax25_ctl_ioctl(const unsigned int cmd, void __user *arg)\r\n{\r\nstruct ax25_ctl_struct ax25_ctl;\r\nax25_digi digi;\r\nax25_dev *ax25_dev;\r\nax25_cb *ax25;\r\nunsigned int k;\r\nint ret = 0;\r\nif (copy_from_user(&ax25_ctl, arg, sizeof(ax25_ctl)))\r\nreturn -EFAULT;\r\nif ((ax25_dev = ax25_addr_ax25dev(&ax25_ctl.port_addr)) == NULL)\r\nreturn -ENODEV;\r\nif (ax25_ctl.digi_count > AX25_MAX_DIGIS)\r\nreturn -EINVAL;\r\nif (ax25_ctl.arg > ULONG_MAX / HZ && ax25_ctl.cmd != AX25_KILL)\r\nreturn -EINVAL;\r\ndigi.ndigi = ax25_ctl.digi_count;\r\nfor (k = 0; k < digi.ndigi; k++)\r\ndigi.calls[k] = ax25_ctl.digi_addr[k];\r\nif ((ax25 = ax25_find_cb(&ax25_ctl.source_addr, &ax25_ctl.dest_addr, &digi, ax25_dev->dev)) == NULL)\r\nreturn -ENOTCONN;\r\nswitch (ax25_ctl.cmd) {\r\ncase AX25_KILL:\r\nax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\r\n#ifdef CONFIG_AX25_DAMA_SLAVE\r\nif (ax25_dev->dama.slave && ax25->ax25_dev->values[AX25_VALUES_PROTOCOL] == AX25_PROTO_DAMA_SLAVE)\r\nax25_dama_off(ax25);\r\n#endif\r\nax25_disconnect(ax25, ENETRESET);\r\nbreak;\r\ncase AX25_WINDOW:\r\nif (ax25->modulus == AX25_MODULUS) {\r\nif (ax25_ctl.arg < 1 || ax25_ctl.arg > 7)\r\ngoto einval_put;\r\n} else {\r\nif (ax25_ctl.arg < 1 || ax25_ctl.arg > 63)\r\ngoto einval_put;\r\n}\r\nax25->window = ax25_ctl.arg;\r\nbreak;\r\ncase AX25_T1:\r\nif (ax25_ctl.arg < 1 || ax25_ctl.arg > ULONG_MAX / HZ)\r\ngoto einval_put;\r\nax25->rtt = (ax25_ctl.arg * HZ) / 2;\r\nax25->t1 = ax25_ctl.arg * HZ;\r\nbreak;\r\ncase AX25_T2:\r\nif (ax25_ctl.arg < 1 || ax25_ctl.arg > ULONG_MAX / HZ)\r\ngoto einval_put;\r\nax25->t2 = ax25_ctl.arg * HZ;\r\nbreak;\r\ncase AX25_N2:\r\nif (ax25_ctl.arg < 1 || ax25_ctl.arg > 31)\r\ngoto einval_put;\r\nax25->n2count = 0;\r\nax25->n2 = ax25_ctl.arg;\r\nbreak;\r\ncase AX25_T3:\r\nif (ax25_ctl.arg > ULONG_MAX / HZ)\r\ngoto einval_put;\r\nax25->t3 = ax25_ctl.arg * HZ;\r\nbreak;\r\ncase AX25_IDLE:\r\nif (ax25_ctl.arg > ULONG_MAX / (60 * HZ))\r\ngoto einval_put;\r\nax25->idle = ax25_ctl.arg * 60 * HZ;\r\nbreak;\r\ncase AX25_PACLEN:\r\nif (ax25_ctl.arg < 16 || ax25_ctl.arg > 65535)\r\ngoto einval_put;\r\nax25->paclen = ax25_ctl.arg;\r\nbreak;\r\ndefault:\r\ngoto einval_put;\r\n}\r\nout_put:\r\nax25_cb_put(ax25);\r\nreturn ret;\r\neinval_put:\r\nret = -EINVAL;\r\ngoto out_put;\r\n}\r\nstatic void ax25_fillin_cb_from_dev(ax25_cb *ax25, ax25_dev *ax25_dev)\r\n{\r\nax25->rtt = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_T1]) / 2;\r\nax25->t1 = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_T1]);\r\nax25->t2 = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_T2]);\r\nax25->t3 = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_T3]);\r\nax25->n2 = ax25_dev->values[AX25_VALUES_N2];\r\nax25->paclen = ax25_dev->values[AX25_VALUES_PACLEN];\r\nax25->idle = msecs_to_jiffies(ax25_dev->values[AX25_VALUES_IDLE]);\r\nax25->backoff = ax25_dev->values[AX25_VALUES_BACKOFF];\r\nif (ax25_dev->values[AX25_VALUES_AXDEFMODE]) {\r\nax25->modulus = AX25_EMODULUS;\r\nax25->window = ax25_dev->values[AX25_VALUES_EWINDOW];\r\n} else {\r\nax25->modulus = AX25_MODULUS;\r\nax25->window = ax25_dev->values[AX25_VALUES_WINDOW];\r\n}\r\n}\r\nvoid ax25_fillin_cb(ax25_cb *ax25, ax25_dev *ax25_dev)\r\n{\r\nax25->ax25_dev = ax25_dev;\r\nif (ax25->ax25_dev != NULL) {\r\nax25_fillin_cb_from_dev(ax25, ax25_dev);\r\nreturn;\r\n}\r\nax25->rtt = msecs_to_jiffies(AX25_DEF_T1) / 2;\r\nax25->t1 = msecs_to_jiffies(AX25_DEF_T1);\r\nax25->t2 = msecs_to_jiffies(AX25_DEF_T2);\r\nax25->t3 = msecs_to_jiffies(AX25_DEF_T3);\r\nax25->n2 = AX25_DEF_N2;\r\nax25->paclen = AX25_DEF_PACLEN;\r\nax25->idle = msecs_to_jiffies(AX25_DEF_IDLE);\r\nax25->backoff = AX25_DEF_BACKOFF;\r\nif (AX25_DEF_AXDEFMODE) {\r\nax25->modulus = AX25_EMODULUS;\r\nax25->window = AX25_DEF_EWINDOW;\r\n} else {\r\nax25->modulus = AX25_MODULUS;\r\nax25->window = AX25_DEF_WINDOW;\r\n}\r\n}\r\nax25_cb *ax25_create_cb(void)\r\n{\r\nax25_cb *ax25;\r\nif ((ax25 = kzalloc(sizeof(*ax25), GFP_ATOMIC)) == NULL)\r\nreturn NULL;\r\natomic_set(&ax25->refcount, 1);\r\nskb_queue_head_init(&ax25->write_queue);\r\nskb_queue_head_init(&ax25->frag_queue);\r\nskb_queue_head_init(&ax25->ack_queue);\r\nskb_queue_head_init(&ax25->reseq_queue);\r\nax25_setup_timers(ax25);\r\nax25_fillin_cb(ax25, NULL);\r\nax25->state = AX25_STATE_0;\r\nreturn ax25;\r\n}\r\nstatic int ax25_setsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nax25_cb *ax25;\r\nstruct net_device *dev;\r\nchar devname[IFNAMSIZ];\r\nunsigned long opt;\r\nint res = 0;\r\nif (level != SOL_AX25)\r\nreturn -ENOPROTOOPT;\r\nif (optlen < sizeof(unsigned int))\r\nreturn -EINVAL;\r\nif (get_user(opt, (unsigned int __user *)optval))\r\nreturn -EFAULT;\r\nlock_sock(sk);\r\nax25 = ax25_sk(sk);\r\nswitch (optname) {\r\ncase AX25_WINDOW:\r\nif (ax25->modulus == AX25_MODULUS) {\r\nif (opt < 1 || opt > 7) {\r\nres = -EINVAL;\r\nbreak;\r\n}\r\n} else {\r\nif (opt < 1 || opt > 63) {\r\nres = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nax25->window = opt;\r\nbreak;\r\ncase AX25_T1:\r\nif (opt < 1 || opt > ULONG_MAX / HZ) {\r\nres = -EINVAL;\r\nbreak;\r\n}\r\nax25->rtt = (opt * HZ) >> 1;\r\nax25->t1 = opt * HZ;\r\nbreak;\r\ncase AX25_T2:\r\nif (opt < 1 || opt > ULONG_MAX / HZ) {\r\nres = -EINVAL;\r\nbreak;\r\n}\r\nax25->t2 = opt * HZ;\r\nbreak;\r\ncase AX25_N2:\r\nif (opt < 1 || opt > 31) {\r\nres = -EINVAL;\r\nbreak;\r\n}\r\nax25->n2 = opt;\r\nbreak;\r\ncase AX25_T3:\r\nif (opt < 1 || opt > ULONG_MAX / HZ) {\r\nres = -EINVAL;\r\nbreak;\r\n}\r\nax25->t3 = opt * HZ;\r\nbreak;\r\ncase AX25_IDLE:\r\nif (opt > ULONG_MAX / (60 * HZ)) {\r\nres = -EINVAL;\r\nbreak;\r\n}\r\nax25->idle = opt * 60 * HZ;\r\nbreak;\r\ncase AX25_BACKOFF:\r\nif (opt > 2) {\r\nres = -EINVAL;\r\nbreak;\r\n}\r\nax25->backoff = opt;\r\nbreak;\r\ncase AX25_EXTSEQ:\r\nax25->modulus = opt ? AX25_EMODULUS : AX25_MODULUS;\r\nbreak;\r\ncase AX25_PIDINCL:\r\nax25->pidincl = opt ? 1 : 0;\r\nbreak;\r\ncase AX25_IAMDIGI:\r\nax25->iamdigi = opt ? 1 : 0;\r\nbreak;\r\ncase AX25_PACLEN:\r\nif (opt < 16 || opt > 65535) {\r\nres = -EINVAL;\r\nbreak;\r\n}\r\nax25->paclen = opt;\r\nbreak;\r\ncase SO_BINDTODEVICE:\r\nif (optlen > IFNAMSIZ)\r\noptlen = IFNAMSIZ;\r\nif (copy_from_user(devname, optval, optlen)) {\r\nres = -EFAULT;\r\nbreak;\r\n}\r\nif (sk->sk_type == SOCK_SEQPACKET &&\r\n(sock->state != SS_UNCONNECTED ||\r\nsk->sk_state == TCP_LISTEN)) {\r\nres = -EADDRNOTAVAIL;\r\nbreak;\r\n}\r\ndev = dev_get_by_name(&init_net, devname);\r\nif (!dev) {\r\nres = -ENODEV;\r\nbreak;\r\n}\r\nax25->ax25_dev = ax25_dev_ax25dev(dev);\r\nax25_fillin_cb(ax25, ax25->ax25_dev);\r\ndev_put(dev);\r\nbreak;\r\ndefault:\r\nres = -ENOPROTOOPT;\r\n}\r\nrelease_sock(sk);\r\nreturn res;\r\n}\r\nstatic int ax25_getsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nax25_cb *ax25;\r\nstruct ax25_dev *ax25_dev;\r\nchar devname[IFNAMSIZ];\r\nvoid *valptr;\r\nint val = 0;\r\nint maxlen, length;\r\nif (level != SOL_AX25)\r\nreturn -ENOPROTOOPT;\r\nif (get_user(maxlen, optlen))\r\nreturn -EFAULT;\r\nif (maxlen < 1)\r\nreturn -EFAULT;\r\nvalptr = (void *) &val;\r\nlength = min_t(unsigned int, maxlen, sizeof(int));\r\nlock_sock(sk);\r\nax25 = ax25_sk(sk);\r\nswitch (optname) {\r\ncase AX25_WINDOW:\r\nval = ax25->window;\r\nbreak;\r\ncase AX25_T1:\r\nval = ax25->t1 / HZ;\r\nbreak;\r\ncase AX25_T2:\r\nval = ax25->t2 / HZ;\r\nbreak;\r\ncase AX25_N2:\r\nval = ax25->n2;\r\nbreak;\r\ncase AX25_T3:\r\nval = ax25->t3 / HZ;\r\nbreak;\r\ncase AX25_IDLE:\r\nval = ax25->idle / (60 * HZ);\r\nbreak;\r\ncase AX25_BACKOFF:\r\nval = ax25->backoff;\r\nbreak;\r\ncase AX25_EXTSEQ:\r\nval = (ax25->modulus == AX25_EMODULUS);\r\nbreak;\r\ncase AX25_PIDINCL:\r\nval = ax25->pidincl;\r\nbreak;\r\ncase AX25_IAMDIGI:\r\nval = ax25->iamdigi;\r\nbreak;\r\ncase AX25_PACLEN:\r\nval = ax25->paclen;\r\nbreak;\r\ncase SO_BINDTODEVICE:\r\nax25_dev = ax25->ax25_dev;\r\nif (ax25_dev != NULL && ax25_dev->dev != NULL) {\r\nstrlcpy(devname, ax25_dev->dev->name, sizeof(devname));\r\nlength = strlen(devname) + 1;\r\n} else {\r\n*devname = '\0';\r\nlength = 1;\r\n}\r\nvalptr = (void *) devname;\r\nbreak;\r\ndefault:\r\nrelease_sock(sk);\r\nreturn -ENOPROTOOPT;\r\n}\r\nrelease_sock(sk);\r\nif (put_user(length, optlen))\r\nreturn -EFAULT;\r\nreturn copy_to_user(optval, valptr, length) ? -EFAULT : 0;\r\n}\r\nstatic int ax25_listen(struct socket *sock, int backlog)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint res = 0;\r\nlock_sock(sk);\r\nif (sk->sk_type == SOCK_SEQPACKET && sk->sk_state != TCP_LISTEN) {\r\nsk->sk_max_ack_backlog = backlog;\r\nsk->sk_state = TCP_LISTEN;\r\ngoto out;\r\n}\r\nres = -EOPNOTSUPP;\r\nout:\r\nrelease_sock(sk);\r\nreturn res;\r\n}\r\nstatic int ax25_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct sock *sk;\r\nax25_cb *ax25;\r\nif (!net_eq(net, &init_net))\r\nreturn -EAFNOSUPPORT;\r\nswitch (sock->type) {\r\ncase SOCK_DGRAM:\r\nif (protocol == 0 || protocol == PF_AX25)\r\nprotocol = AX25_P_TEXT;\r\nbreak;\r\ncase SOCK_SEQPACKET:\r\nswitch (protocol) {\r\ncase 0:\r\ncase PF_AX25:\r\nprotocol = AX25_P_TEXT;\r\nbreak;\r\ncase AX25_P_SEGMENT:\r\n#ifdef CONFIG_INET\r\ncase AX25_P_ARP:\r\ncase AX25_P_IP:\r\n#endif\r\n#ifdef CONFIG_NETROM\r\ncase AX25_P_NETROM:\r\n#endif\r\n#ifdef CONFIG_ROSE\r\ncase AX25_P_ROSE:\r\n#endif\r\nreturn -ESOCKTNOSUPPORT;\r\n#ifdef CONFIG_NETROM_MODULE\r\ncase AX25_P_NETROM:\r\nif (ax25_protocol_is_registered(AX25_P_NETROM))\r\nreturn -ESOCKTNOSUPPORT;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_ROSE_MODULE\r\ncase AX25_P_ROSE:\r\nif (ax25_protocol_is_registered(AX25_P_ROSE))\r\nreturn -ESOCKTNOSUPPORT;\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase SOCK_RAW:\r\nbreak;\r\ndefault:\r\nreturn -ESOCKTNOSUPPORT;\r\n}\r\nsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto);\r\nif (sk == NULL)\r\nreturn -ENOMEM;\r\nax25 = sk->sk_protinfo = ax25_create_cb();\r\nif (!ax25) {\r\nsk_free(sk);\r\nreturn -ENOMEM;\r\n}\r\nsock_init_data(sock, sk);\r\nsk->sk_destruct = ax25_free_sock;\r\nsock->ops = &ax25_proto_ops;\r\nsk->sk_protocol = protocol;\r\nax25->sk = sk;\r\nreturn 0;\r\n}\r\nstruct sock *ax25_make_new(struct sock *osk, struct ax25_dev *ax25_dev)\r\n{\r\nstruct sock *sk;\r\nax25_cb *ax25, *oax25;\r\nsk = sk_alloc(sock_net(osk), PF_AX25, GFP_ATOMIC, osk->sk_prot);\r\nif (sk == NULL)\r\nreturn NULL;\r\nif ((ax25 = ax25_create_cb()) == NULL) {\r\nsk_free(sk);\r\nreturn NULL;\r\n}\r\nswitch (osk->sk_type) {\r\ncase SOCK_DGRAM:\r\nbreak;\r\ncase SOCK_SEQPACKET:\r\nbreak;\r\ndefault:\r\nsk_free(sk);\r\nax25_cb_put(ax25);\r\nreturn NULL;\r\n}\r\nsock_init_data(NULL, sk);\r\nsk->sk_type = osk->sk_type;\r\nsk->sk_priority = osk->sk_priority;\r\nsk->sk_protocol = osk->sk_protocol;\r\nsk->sk_rcvbuf = osk->sk_rcvbuf;\r\nsk->sk_sndbuf = osk->sk_sndbuf;\r\nsk->sk_state = TCP_ESTABLISHED;\r\nsock_copy_flags(sk, osk);\r\noax25 = ax25_sk(osk);\r\nax25->modulus = oax25->modulus;\r\nax25->backoff = oax25->backoff;\r\nax25->pidincl = oax25->pidincl;\r\nax25->iamdigi = oax25->iamdigi;\r\nax25->rtt = oax25->rtt;\r\nax25->t1 = oax25->t1;\r\nax25->t2 = oax25->t2;\r\nax25->t3 = oax25->t3;\r\nax25->n2 = oax25->n2;\r\nax25->idle = oax25->idle;\r\nax25->paclen = oax25->paclen;\r\nax25->window = oax25->window;\r\nax25->ax25_dev = ax25_dev;\r\nax25->source_addr = oax25->source_addr;\r\nif (oax25->digipeat != NULL) {\r\nax25->digipeat = kmemdup(oax25->digipeat, sizeof(ax25_digi),\r\nGFP_ATOMIC);\r\nif (ax25->digipeat == NULL) {\r\nsk_free(sk);\r\nax25_cb_put(ax25);\r\nreturn NULL;\r\n}\r\n}\r\nsk->sk_protinfo = ax25;\r\nsk->sk_destruct = ax25_free_sock;\r\nax25->sk = sk;\r\nreturn sk;\r\n}\r\nstatic int ax25_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nax25_cb *ax25;\r\nif (sk == NULL)\r\nreturn 0;\r\nsock_hold(sk);\r\nsock_orphan(sk);\r\nlock_sock(sk);\r\nax25 = ax25_sk(sk);\r\nif (sk->sk_type == SOCK_SEQPACKET) {\r\nswitch (ax25->state) {\r\ncase AX25_STATE_0:\r\nrelease_sock(sk);\r\nax25_disconnect(ax25, 0);\r\nlock_sock(sk);\r\nax25_destroy_socket(ax25);\r\nbreak;\r\ncase AX25_STATE_1:\r\ncase AX25_STATE_2:\r\nax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\r\nrelease_sock(sk);\r\nax25_disconnect(ax25, 0);\r\nlock_sock(sk);\r\nax25_destroy_socket(ax25);\r\nbreak;\r\ncase AX25_STATE_3:\r\ncase AX25_STATE_4:\r\nax25_clear_queues(ax25);\r\nax25->n2count = 0;\r\nswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\r\ncase AX25_PROTO_STD_SIMPLEX:\r\ncase AX25_PROTO_STD_DUPLEX:\r\nax25_send_control(ax25,\r\nAX25_DISC,\r\nAX25_POLLON,\r\nAX25_COMMAND);\r\nax25_stop_t2timer(ax25);\r\nax25_stop_t3timer(ax25);\r\nax25_stop_idletimer(ax25);\r\nbreak;\r\n#ifdef CONFIG_AX25_DAMA_SLAVE\r\ncase AX25_PROTO_DAMA_SLAVE:\r\nax25_stop_t3timer(ax25);\r\nax25_stop_idletimer(ax25);\r\nbreak;\r\n#endif\r\n}\r\nax25_calculate_t1(ax25);\r\nax25_start_t1timer(ax25);\r\nax25->state = AX25_STATE_2;\r\nsk->sk_state = TCP_CLOSE;\r\nsk->sk_shutdown |= SEND_SHUTDOWN;\r\nsk->sk_state_change(sk);\r\nsock_set_flag(sk, SOCK_DESTROY);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nsk->sk_state = TCP_CLOSE;\r\nsk->sk_shutdown |= SEND_SHUTDOWN;\r\nsk->sk_state_change(sk);\r\nax25_destroy_socket(ax25);\r\n}\r\nsock->sk = NULL;\r\nrelease_sock(sk);\r\nsock_put(sk);\r\nreturn 0;\r\n}\r\nstatic int ax25_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct full_sockaddr_ax25 *addr = (struct full_sockaddr_ax25 *)uaddr;\r\nax25_dev *ax25_dev = NULL;\r\nax25_uid_assoc *user;\r\nax25_address call;\r\nax25_cb *ax25;\r\nint err = 0;\r\nif (addr_len != sizeof(struct sockaddr_ax25) &&\r\naddr_len != sizeof(struct full_sockaddr_ax25))\r\nif ((addr_len < sizeof(struct sockaddr_ax25) + sizeof(ax25_address) * 6) ||\r\n(addr_len > sizeof(struct full_sockaddr_ax25)))\r\nreturn -EINVAL;\r\nif (addr->fsa_ax25.sax25_family != AF_AX25)\r\nreturn -EINVAL;\r\nuser = ax25_findbyuid(current_euid());\r\nif (user) {\r\ncall = user->call;\r\nax25_uid_put(user);\r\n} else {\r\nif (ax25_uid_policy && !capable(CAP_NET_ADMIN))\r\nreturn -EACCES;\r\ncall = addr->fsa_ax25.sax25_call;\r\n}\r\nlock_sock(sk);\r\nax25 = ax25_sk(sk);\r\nif (!sock_flag(sk, SOCK_ZAPPED)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nax25->source_addr = call;\r\nif (ax25->ax25_dev != NULL)\r\ngoto done;\r\nif (addr_len > sizeof(struct sockaddr_ax25) && addr->fsa_ax25.sax25_ndigis == 1) {\r\nif (ax25cmp(&addr->fsa_digipeater[0], &null_ax25_address) != 0 &&\r\n(ax25_dev = ax25_addr_ax25dev(&addr->fsa_digipeater[0])) == NULL) {\r\nerr = -EADDRNOTAVAIL;\r\ngoto out;\r\n}\r\n} else {\r\nif ((ax25_dev = ax25_addr_ax25dev(&addr->fsa_ax25.sax25_call)) == NULL) {\r\nerr = -EADDRNOTAVAIL;\r\ngoto out;\r\n}\r\n}\r\nif (ax25_dev != NULL)\r\nax25_fillin_cb(ax25, ax25_dev);\r\ndone:\r\nax25_cb_add(ax25);\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int __must_check ax25_connect(struct socket *sock,\r\nstruct sockaddr *uaddr, int addr_len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nax25_cb *ax25 = ax25_sk(sk), *ax25t;\r\nstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;\r\nax25_digi *digi = NULL;\r\nint ct = 0, err = 0;\r\nif (addr_len == sizeof(struct sockaddr_ax25))\r\n;\r\nelse if (addr_len != sizeof(struct full_sockaddr_ax25))\r\nif ((addr_len < sizeof(struct sockaddr_ax25) + sizeof(ax25_address) * 6) ||\r\n(addr_len > sizeof(struct full_sockaddr_ax25)))\r\nreturn -EINVAL;\r\nif (fsa->fsa_ax25.sax25_family != AF_AX25)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nif (sock->state == SS_CONNECTING) {\r\nswitch (sk->sk_state) {\r\ncase TCP_SYN_SENT:\r\nerr = -EINPROGRESS;\r\ngoto out_release;\r\ncase TCP_ESTABLISHED:\r\nsock->state = SS_CONNECTED;\r\ngoto out_release;\r\ncase TCP_CLOSE:\r\nsock->state = SS_UNCONNECTED;\r\nerr = -ECONNREFUSED;\r\ngoto out_release;\r\n}\r\n}\r\nif (sk->sk_state == TCP_ESTABLISHED && sk->sk_type == SOCK_SEQPACKET) {\r\nerr = -EISCONN;\r\ngoto out_release;\r\n}\r\nsk->sk_state = TCP_CLOSE;\r\nsock->state = SS_UNCONNECTED;\r\nkfree(ax25->digipeat);\r\nax25->digipeat = NULL;\r\nif (addr_len > sizeof(struct sockaddr_ax25) &&\r\nfsa->fsa_ax25.sax25_ndigis != 0) {\r\nif (fsa->fsa_ax25.sax25_ndigis < 1 || fsa->fsa_ax25.sax25_ndigis > AX25_MAX_DIGIS) {\r\nerr = -EINVAL;\r\ngoto out_release;\r\n}\r\nif ((digi = kmalloc(sizeof(ax25_digi), GFP_KERNEL)) == NULL) {\r\nerr = -ENOBUFS;\r\ngoto out_release;\r\n}\r\ndigi->ndigi = fsa->fsa_ax25.sax25_ndigis;\r\ndigi->lastrepeat = -1;\r\nwhile (ct < fsa->fsa_ax25.sax25_ndigis) {\r\nif ((fsa->fsa_digipeater[ct].ax25_call[6] &\r\nAX25_HBIT) && ax25->iamdigi) {\r\ndigi->repeated[ct] = 1;\r\ndigi->lastrepeat = ct;\r\n} else {\r\ndigi->repeated[ct] = 0;\r\n}\r\ndigi->calls[ct] = fsa->fsa_digipeater[ct];\r\nct++;\r\n}\r\n}\r\nif (sock_flag(sk, SOCK_ZAPPED)) {\r\nprintk(KERN_WARNING "ax25_connect(): %s uses autobind, please contact jreuter@yaina.de\n",\r\ncurrent->comm);\r\nif ((err = ax25_rt_autobind(ax25, &fsa->fsa_ax25.sax25_call)) < 0) {\r\nkfree(digi);\r\ngoto out_release;\r\n}\r\nax25_fillin_cb(ax25, ax25->ax25_dev);\r\nax25_cb_add(ax25);\r\n} else {\r\nif (ax25->ax25_dev == NULL) {\r\nkfree(digi);\r\nerr = -EHOSTUNREACH;\r\ngoto out_release;\r\n}\r\n}\r\nif (sk->sk_type == SOCK_SEQPACKET &&\r\n(ax25t=ax25_find_cb(&ax25->source_addr, &fsa->fsa_ax25.sax25_call, digi,\r\nax25->ax25_dev->dev))) {\r\nkfree(digi);\r\nerr = -EADDRINUSE;\r\nax25_cb_put(ax25t);\r\ngoto out_release;\r\n}\r\nax25->dest_addr = fsa->fsa_ax25.sax25_call;\r\nax25->digipeat = digi;\r\nif (sk->sk_type != SOCK_SEQPACKET) {\r\nsock->state = SS_CONNECTED;\r\nsk->sk_state = TCP_ESTABLISHED;\r\ngoto out_release;\r\n}\r\nsock->state = SS_CONNECTING;\r\nsk->sk_state = TCP_SYN_SENT;\r\nswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\r\ncase AX25_PROTO_STD_SIMPLEX:\r\ncase AX25_PROTO_STD_DUPLEX:\r\nax25_std_establish_data_link(ax25);\r\nbreak;\r\n#ifdef CONFIG_AX25_DAMA_SLAVE\r\ncase AX25_PROTO_DAMA_SLAVE:\r\nax25->modulus = AX25_MODULUS;\r\nax25->window = ax25->ax25_dev->values[AX25_VALUES_WINDOW];\r\nif (ax25->ax25_dev->dama.slave)\r\nax25_ds_establish_data_link(ax25);\r\nelse\r\nax25_std_establish_data_link(ax25);\r\nbreak;\r\n#endif\r\n}\r\nax25->state = AX25_STATE_1;\r\nax25_start_heartbeat(ax25);\r\nif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK)) {\r\nerr = -EINPROGRESS;\r\ngoto out_release;\r\n}\r\nif (sk->sk_state == TCP_SYN_SENT) {\r\nDEFINE_WAIT(wait);\r\nfor (;;) {\r\nprepare_to_wait(sk_sleep(sk), &wait,\r\nTASK_INTERRUPTIBLE);\r\nif (sk->sk_state != TCP_SYN_SENT)\r\nbreak;\r\nif (!signal_pending(current)) {\r\nrelease_sock(sk);\r\nschedule();\r\nlock_sock(sk);\r\ncontinue;\r\n}\r\nerr = -ERESTARTSYS;\r\nbreak;\r\n}\r\nfinish_wait(sk_sleep(sk), &wait);\r\nif (err)\r\ngoto out_release;\r\n}\r\nif (sk->sk_state != TCP_ESTABLISHED) {\r\nsock->state = SS_UNCONNECTED;\r\nerr = sock_error(sk);\r\ngoto out_release;\r\n}\r\nsock->state = SS_CONNECTED;\r\nerr = 0;\r\nout_release:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int ax25_accept(struct socket *sock, struct socket *newsock, int flags)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sock *newsk;\r\nDEFINE_WAIT(wait);\r\nstruct sock *sk;\r\nint err = 0;\r\nif (sock->state != SS_UNCONNECTED)\r\nreturn -EINVAL;\r\nif ((sk = sock->sk) == NULL)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nif (sk->sk_type != SOCK_SEQPACKET) {\r\nerr = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (sk->sk_state != TCP_LISTEN) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nfor (;;) {\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\nskb = skb_dequeue(&sk->sk_receive_queue);\r\nif (skb)\r\nbreak;\r\nif (flags & O_NONBLOCK) {\r\nerr = -EWOULDBLOCK;\r\nbreak;\r\n}\r\nif (!signal_pending(current)) {\r\nrelease_sock(sk);\r\nschedule();\r\nlock_sock(sk);\r\ncontinue;\r\n}\r\nerr = -ERESTARTSYS;\r\nbreak;\r\n}\r\nfinish_wait(sk_sleep(sk), &wait);\r\nif (err)\r\ngoto out;\r\nnewsk = skb->sk;\r\nsock_graft(newsk, newsock);\r\nkfree_skb(skb);\r\nsk->sk_ack_backlog--;\r\nnewsock->state = SS_CONNECTED;\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int ax25_getname(struct socket *sock, struct sockaddr *uaddr,\r\nint *uaddr_len, int peer)\r\n{\r\nstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;\r\nstruct sock *sk = sock->sk;\r\nunsigned char ndigi, i;\r\nax25_cb *ax25;\r\nint err = 0;\r\nmemset(fsa, 0, sizeof(*fsa));\r\nlock_sock(sk);\r\nax25 = ax25_sk(sk);\r\nif (peer != 0) {\r\nif (sk->sk_state != TCP_ESTABLISHED) {\r\nerr = -ENOTCONN;\r\ngoto out;\r\n}\r\nfsa->fsa_ax25.sax25_family = AF_AX25;\r\nfsa->fsa_ax25.sax25_call = ax25->dest_addr;\r\nif (ax25->digipeat != NULL) {\r\nndigi = ax25->digipeat->ndigi;\r\nfsa->fsa_ax25.sax25_ndigis = ndigi;\r\nfor (i = 0; i < ndigi; i++)\r\nfsa->fsa_digipeater[i] =\r\nax25->digipeat->calls[i];\r\n}\r\n} else {\r\nfsa->fsa_ax25.sax25_family = AF_AX25;\r\nfsa->fsa_ax25.sax25_call = ax25->source_addr;\r\nfsa->fsa_ax25.sax25_ndigis = 1;\r\nif (ax25->ax25_dev != NULL) {\r\nmemcpy(&fsa->fsa_digipeater[0],\r\nax25->ax25_dev->dev->dev_addr, AX25_ADDR_LEN);\r\n} else {\r\nfsa->fsa_digipeater[0] = null_ax25_address;\r\n}\r\n}\r\n*uaddr_len = sizeof (struct full_sockaddr_ax25);\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int ax25_sendmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nstruct sockaddr_ax25 *usax = (struct sockaddr_ax25 *)msg->msg_name;\r\nstruct sock *sk = sock->sk;\r\nstruct sockaddr_ax25 sax;\r\nstruct sk_buff *skb;\r\nax25_digi dtmp, *dp;\r\nax25_cb *ax25;\r\nsize_t size;\r\nint lv, err, addr_len = msg->msg_namelen;\r\nif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_CMSG_COMPAT))\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nax25 = ax25_sk(sk);\r\nif (sock_flag(sk, SOCK_ZAPPED)) {\r\nerr = -EADDRNOTAVAIL;\r\ngoto out;\r\n}\r\nif (sk->sk_shutdown & SEND_SHUTDOWN) {\r\nsend_sig(SIGPIPE, current, 0);\r\nerr = -EPIPE;\r\ngoto out;\r\n}\r\nif (ax25->ax25_dev == NULL) {\r\nerr = -ENETUNREACH;\r\ngoto out;\r\n}\r\nif (len > ax25->ax25_dev->dev->mtu) {\r\nerr = -EMSGSIZE;\r\ngoto out;\r\n}\r\nif (usax != NULL) {\r\nif (usax->sax25_family != AF_AX25) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (addr_len == sizeof(struct sockaddr_ax25))\r\n;\r\nelse if (addr_len != sizeof(struct full_sockaddr_ax25))\r\nif ((addr_len < sizeof(struct sockaddr_ax25) + sizeof(ax25_address) * 6) ||\r\n(addr_len > sizeof(struct full_sockaddr_ax25))) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (addr_len > sizeof(struct sockaddr_ax25) && usax->sax25_ndigis != 0) {\r\nint ct = 0;\r\nstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)usax;\r\nif (usax->sax25_ndigis < 1 || usax->sax25_ndigis > AX25_MAX_DIGIS) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\ndtmp.ndigi = usax->sax25_ndigis;\r\nwhile (ct < usax->sax25_ndigis) {\r\ndtmp.repeated[ct] = 0;\r\ndtmp.calls[ct] = fsa->fsa_digipeater[ct];\r\nct++;\r\n}\r\ndtmp.lastrepeat = 0;\r\n}\r\nsax = *usax;\r\nif (sk->sk_type == SOCK_SEQPACKET &&\r\nax25cmp(&ax25->dest_addr, &sax.sax25_call)) {\r\nerr = -EISCONN;\r\ngoto out;\r\n}\r\nif (usax->sax25_ndigis == 0)\r\ndp = NULL;\r\nelse\r\ndp = &dtmp;\r\n} else {\r\nif (sk->sk_state != TCP_ESTABLISHED) {\r\nerr = -ENOTCONN;\r\ngoto out;\r\n}\r\nsax.sax25_family = AF_AX25;\r\nsax.sax25_call = ax25->dest_addr;\r\ndp = ax25->digipeat;\r\n}\r\nsize = len + ax25->ax25_dev->dev->hard_header_len;\r\nskb = sock_alloc_send_skb(sk, size, msg->msg_flags&MSG_DONTWAIT, &err);\r\nif (skb == NULL)\r\ngoto out;\r\nskb_reserve(skb, size - len);\r\nif (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {\r\nerr = -EFAULT;\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nskb_reset_network_header(skb);\r\nif (!ax25->pidincl)\r\n*skb_push(skb, 1) = sk->sk_protocol;\r\nif (sk->sk_type == SOCK_SEQPACKET) {\r\nif (sk->sk_state != TCP_ESTABLISHED) {\r\nkfree_skb(skb);\r\nerr = -ENOTCONN;\r\ngoto out;\r\n}\r\nax25_output(ax25, ax25->paclen, skb);\r\nerr = len;\r\ngoto out;\r\n}\r\nskb_push(skb, 1 + ax25_addr_size(dp));\r\nlv = ax25_addr_build(skb->data, &ax25->source_addr, &sax.sax25_call,\r\ndp, AX25_COMMAND, AX25_MODULUS);\r\nskb_set_transport_header(skb, lv);\r\n*skb_transport_header(skb) = AX25_UI;\r\nax25_queue_xmit(skb, ax25->ax25_dev->dev);\r\nerr = len;\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t size, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sk_buff *skb;\r\nint copied;\r\nint err = 0;\r\nlock_sock(sk);\r\nif (sk->sk_type == SOCK_SEQPACKET && sk->sk_state != TCP_ESTABLISHED) {\r\nerr = -ENOTCONN;\r\ngoto out;\r\n}\r\nskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\r\nflags & MSG_DONTWAIT, &err);\r\nif (skb == NULL)\r\ngoto out;\r\nif (!ax25_sk(sk)->pidincl)\r\nskb_pull(skb, 1);\r\nskb_reset_transport_header(skb);\r\ncopied = skb->len;\r\nif (copied > size) {\r\ncopied = size;\r\nmsg->msg_flags |= MSG_TRUNC;\r\n}\r\nskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\r\nif (msg->msg_namelen != 0) {\r\nstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\r\nax25_digi digi;\r\nax25_address src;\r\nconst unsigned char *mac = skb_mac_header(skb);\r\nmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\r\nax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\r\n&digi, NULL, NULL);\r\nsax->sax25_family = AF_AX25;\r\nsax->sax25_ndigis = digi.ndigi;\r\nsax->sax25_call = src;\r\nif (sax->sax25_ndigis != 0) {\r\nint ct;\r\nstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)sax;\r\nfor (ct = 0; ct < digi.ndigi; ct++)\r\nfsa->fsa_digipeater[ct] = digi.calls[ct];\r\n}\r\nmsg->msg_namelen = sizeof(struct full_sockaddr_ax25);\r\n}\r\nskb_free_datagram(sk, skb);\r\nerr = copied;\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int ax25_shutdown(struct socket *sk, int how)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int ax25_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct sock *sk = sock->sk;\r\nvoid __user *argp = (void __user *)arg;\r\nint res = 0;\r\nlock_sock(sk);\r\nswitch (cmd) {\r\ncase TIOCOUTQ: {\r\nlong amount;\r\namount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\r\nif (amount < 0)\r\namount = 0;\r\nres = put_user(amount, (int __user *)argp);\r\nbreak;\r\n}\r\ncase TIOCINQ: {\r\nstruct sk_buff *skb;\r\nlong amount = 0L;\r\nif ((skb = skb_peek(&sk->sk_receive_queue)) != NULL)\r\namount = skb->len;\r\nres = put_user(amount, (int __user *) argp);\r\nbreak;\r\n}\r\ncase SIOCGSTAMP:\r\nres = sock_get_timestamp(sk, argp);\r\nbreak;\r\ncase SIOCGSTAMPNS:\r\nres = sock_get_timestampns(sk, argp);\r\nbreak;\r\ncase SIOCAX25ADDUID:\r\ncase SIOCAX25DELUID:\r\ncase SIOCAX25GETUID: {\r\nstruct sockaddr_ax25 sax25;\r\nif (copy_from_user(&sax25, argp, sizeof(sax25))) {\r\nres = -EFAULT;\r\nbreak;\r\n}\r\nres = ax25_uid_ioctl(cmd, &sax25);\r\nbreak;\r\n}\r\ncase SIOCAX25NOUID: {\r\nlong amount;\r\nif (!capable(CAP_NET_ADMIN)) {\r\nres = -EPERM;\r\nbreak;\r\n}\r\nif (get_user(amount, (long __user *)argp)) {\r\nres = -EFAULT;\r\nbreak;\r\n}\r\nif (amount > AX25_NOUID_BLOCK) {\r\nres = -EINVAL;\r\nbreak;\r\n}\r\nax25_uid_policy = amount;\r\nres = 0;\r\nbreak;\r\n}\r\ncase SIOCADDRT:\r\ncase SIOCDELRT:\r\ncase SIOCAX25OPTRT:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nres = -EPERM;\r\nbreak;\r\n}\r\nres = ax25_rt_ioctl(cmd, argp);\r\nbreak;\r\ncase SIOCAX25CTLCON:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nres = -EPERM;\r\nbreak;\r\n}\r\nres = ax25_ctl_ioctl(cmd, argp);\r\nbreak;\r\ncase SIOCAX25GETINFO:\r\ncase SIOCAX25GETINFOOLD: {\r\nax25_cb *ax25 = ax25_sk(sk);\r\nstruct ax25_info_struct ax25_info;\r\nax25_info.t1 = ax25->t1 / HZ;\r\nax25_info.t2 = ax25->t2 / HZ;\r\nax25_info.t3 = ax25->t3 / HZ;\r\nax25_info.idle = ax25->idle / (60 * HZ);\r\nax25_info.n2 = ax25->n2;\r\nax25_info.t1timer = ax25_display_timer(&ax25->t1timer) / HZ;\r\nax25_info.t2timer = ax25_display_timer(&ax25->t2timer) / HZ;\r\nax25_info.t3timer = ax25_display_timer(&ax25->t3timer) / HZ;\r\nax25_info.idletimer = ax25_display_timer(&ax25->idletimer) / (60 * HZ);\r\nax25_info.n2count = ax25->n2count;\r\nax25_info.state = ax25->state;\r\nax25_info.rcv_q = sk_rmem_alloc_get(sk);\r\nax25_info.snd_q = sk_wmem_alloc_get(sk);\r\nax25_info.vs = ax25->vs;\r\nax25_info.vr = ax25->vr;\r\nax25_info.va = ax25->va;\r\nax25_info.vs_max = ax25->vs;\r\nax25_info.paclen = ax25->paclen;\r\nax25_info.window = ax25->window;\r\nif (cmd == SIOCAX25GETINFOOLD) {\r\nstatic int warned = 0;\r\nif (!warned) {\r\nprintk(KERN_INFO "%s uses old SIOCAX25GETINFO\n",\r\ncurrent->comm);\r\nwarned=1;\r\n}\r\nif (copy_to_user(argp, &ax25_info, sizeof(struct ax25_info_struct_deprecated))) {\r\nres = -EFAULT;\r\nbreak;\r\n}\r\n} else {\r\nif (copy_to_user(argp, &ax25_info, sizeof(struct ax25_info_struct))) {\r\nres = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nres = 0;\r\nbreak;\r\n}\r\ncase SIOCAX25ADDFWD:\r\ncase SIOCAX25DELFWD: {\r\nstruct ax25_fwd_struct ax25_fwd;\r\nif (!capable(CAP_NET_ADMIN)) {\r\nres = -EPERM;\r\nbreak;\r\n}\r\nif (copy_from_user(&ax25_fwd, argp, sizeof(ax25_fwd))) {\r\nres = -EFAULT;\r\nbreak;\r\n}\r\nres = ax25_fwd_ioctl(cmd, &ax25_fwd);\r\nbreak;\r\n}\r\ncase SIOCGIFADDR:\r\ncase SIOCSIFADDR:\r\ncase SIOCGIFDSTADDR:\r\ncase SIOCSIFDSTADDR:\r\ncase SIOCGIFBRDADDR:\r\ncase SIOCSIFBRDADDR:\r\ncase SIOCGIFNETMASK:\r\ncase SIOCSIFNETMASK:\r\ncase SIOCGIFMETRIC:\r\ncase SIOCSIFMETRIC:\r\nres = -EINVAL;\r\nbreak;\r\ndefault:\r\nres = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nreturn res;\r\n}\r\nstatic void *ax25_info_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(ax25_list_lock)\r\n{\r\nspin_lock_bh(&ax25_list_lock);\r\nreturn seq_hlist_start(&ax25_list, *pos);\r\n}\r\nstatic void *ax25_info_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nreturn seq_hlist_next(v, &ax25_list, pos);\r\n}\r\nstatic void ax25_info_stop(struct seq_file *seq, void *v)\r\n__releases(ax25_list_lock)\r\n{\r\nspin_unlock_bh(&ax25_list_lock);\r\n}\r\nstatic int ax25_info_show(struct seq_file *seq, void *v)\r\n{\r\nax25_cb *ax25 = hlist_entry(v, struct ax25_cb, ax25_node);\r\nchar buf[11];\r\nint k;\r\nseq_printf(seq, "%8.8lx %s %s%s ",\r\n(long) ax25,\r\nax25->ax25_dev == NULL? "???" : ax25->ax25_dev->dev->name,\r\nax2asc(buf, &ax25->source_addr),\r\nax25->iamdigi? "*":"");\r\nseq_printf(seq, "%s", ax2asc(buf, &ax25->dest_addr));\r\nfor (k=0; (ax25->digipeat != NULL) && (k < ax25->digipeat->ndigi); k++) {\r\nseq_printf(seq, ",%s%s",\r\nax2asc(buf, &ax25->digipeat->calls[k]),\r\nax25->digipeat->repeated[k]? "*":"");\r\n}\r\nseq_printf(seq, " %d %d %d %d %lu %lu %lu %lu %lu %lu %lu %lu %d %d %lu %d %d",\r\nax25->state,\r\nax25->vs, ax25->vr, ax25->va,\r\nax25_display_timer(&ax25->t1timer) / HZ, ax25->t1 / HZ,\r\nax25_display_timer(&ax25->t2timer) / HZ, ax25->t2 / HZ,\r\nax25_display_timer(&ax25->t3timer) / HZ, ax25->t3 / HZ,\r\nax25_display_timer(&ax25->idletimer) / (60 * HZ),\r\nax25->idle / (60 * HZ),\r\nax25->n2count, ax25->n2,\r\nax25->rtt / HZ,\r\nax25->window,\r\nax25->paclen);\r\nif (ax25->sk != NULL) {\r\nseq_printf(seq, " %d %d %lu\n",\r\nsk_wmem_alloc_get(ax25->sk),\r\nsk_rmem_alloc_get(ax25->sk),\r\nsock_i_ino(ax25->sk));\r\n} else {\r\nseq_puts(seq, " * * *\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int ax25_info_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &ax25_info_seqops);\r\n}\r\nstatic int __init ax25_init(void)\r\n{\r\nint rc = proto_register(&ax25_proto, 0);\r\nif (rc != 0)\r\ngoto out;\r\nsock_register(&ax25_family_ops);\r\ndev_add_pack(&ax25_packet_type);\r\nregister_netdevice_notifier(&ax25_dev_notifier);\r\nproc_create("ax25_route", S_IRUGO, init_net.proc_net,\r\n&ax25_route_fops);\r\nproc_create("ax25", S_IRUGO, init_net.proc_net, &ax25_info_fops);\r\nproc_create("ax25_calls", S_IRUGO, init_net.proc_net, &ax25_uid_fops);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void __exit ax25_exit(void)\r\n{\r\nremove_proc_entry("ax25_route", init_net.proc_net);\r\nremove_proc_entry("ax25", init_net.proc_net);\r\nremove_proc_entry("ax25_calls", init_net.proc_net);\r\nunregister_netdevice_notifier(&ax25_dev_notifier);\r\ndev_remove_pack(&ax25_packet_type);\r\nsock_unregister(PF_AX25);\r\nproto_unregister(&ax25_proto);\r\nax25_rt_free();\r\nax25_uid_free();\r\nax25_dev_free();\r\n}
