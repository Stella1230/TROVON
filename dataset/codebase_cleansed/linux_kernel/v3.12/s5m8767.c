static int s5m8767_get_register(struct regulator_dev *rdev, int *reg,\r\nint *enable_ctrl)\r\n{\r\nint i, reg_id = rdev_get_id(rdev);\r\nunsigned int mode;\r\nstruct s5m8767_info *s5m8767 = rdev_get_drvdata(rdev);\r\nswitch (reg_id) {\r\ncase S5M8767_LDO1 ... S5M8767_LDO2:\r\n*reg = S5M8767_REG_LDO1CTRL + (reg_id - S5M8767_LDO1);\r\nbreak;\r\ncase S5M8767_LDO3 ... S5M8767_LDO28:\r\n*reg = S5M8767_REG_LDO3CTRL + (reg_id - S5M8767_LDO3);\r\nbreak;\r\ncase S5M8767_BUCK1:\r\n*reg = S5M8767_REG_BUCK1CTRL1;\r\nbreak;\r\ncase S5M8767_BUCK2 ... S5M8767_BUCK4:\r\n*reg = S5M8767_REG_BUCK2CTRL + (reg_id - S5M8767_BUCK2) * 9;\r\nbreak;\r\ncase S5M8767_BUCK5:\r\n*reg = S5M8767_REG_BUCK5CTRL1;\r\nbreak;\r\ncase S5M8767_BUCK6 ... S5M8767_BUCK9:\r\n*reg = S5M8767_REG_BUCK6CTRL1 + (reg_id - S5M8767_BUCK6) * 2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < s5m8767->num_regulators; i++) {\r\nif (s5m8767->opmode[i].id == reg_id) {\r\nmode = s5m8767->opmode[i].mode;\r\nbreak;\r\n}\r\n}\r\nif (i < s5m8767->num_regulators)\r\n*enable_ctrl =\r\ns5m8767_opmode_reg[reg_id][mode] << S5M8767_ENCTRL_SHIFT;\r\nreturn 0;\r\n}\r\nstatic int s5m8767_reg_is_enabled(struct regulator_dev *rdev)\r\n{\r\nstruct s5m8767_info *s5m8767 = rdev_get_drvdata(rdev);\r\nint ret, reg;\r\nint mask = 0xc0, enable_ctrl;\r\nunsigned int val;\r\nret = s5m8767_get_register(rdev, &reg, &enable_ctrl);\r\nif (ret == -EINVAL)\r\nreturn 1;\r\nelse if (ret)\r\nreturn ret;\r\nret = sec_reg_read(s5m8767->iodev, reg, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn (val & mask) == enable_ctrl;\r\n}\r\nstatic int s5m8767_reg_enable(struct regulator_dev *rdev)\r\n{\r\nstruct s5m8767_info *s5m8767 = rdev_get_drvdata(rdev);\r\nint ret, reg;\r\nint mask = 0xc0, enable_ctrl;\r\nret = s5m8767_get_register(rdev, &reg, &enable_ctrl);\r\nif (ret)\r\nreturn ret;\r\nreturn sec_reg_update(s5m8767->iodev, reg, enable_ctrl, mask);\r\n}\r\nstatic int s5m8767_reg_disable(struct regulator_dev *rdev)\r\n{\r\nstruct s5m8767_info *s5m8767 = rdev_get_drvdata(rdev);\r\nint ret, reg;\r\nint mask = 0xc0, enable_ctrl;\r\nret = s5m8767_get_register(rdev, &reg, &enable_ctrl);\r\nif (ret)\r\nreturn ret;\r\nreturn sec_reg_update(s5m8767->iodev, reg, ~mask, mask);\r\n}\r\nstatic int s5m8767_get_vsel_reg(int reg_id, struct s5m8767_info *s5m8767)\r\n{\r\nint reg;\r\nswitch (reg_id) {\r\ncase S5M8767_LDO1 ... S5M8767_LDO2:\r\nreg = S5M8767_REG_LDO1CTRL + (reg_id - S5M8767_LDO1);\r\nbreak;\r\ncase S5M8767_LDO3 ... S5M8767_LDO28:\r\nreg = S5M8767_REG_LDO3CTRL + (reg_id - S5M8767_LDO3);\r\nbreak;\r\ncase S5M8767_BUCK1:\r\nreg = S5M8767_REG_BUCK1CTRL2;\r\nbreak;\r\ncase S5M8767_BUCK2:\r\nreg = S5M8767_REG_BUCK2DVS1;\r\nif (s5m8767->buck2_gpiodvs)\r\nreg += s5m8767->buck_gpioindex;\r\nbreak;\r\ncase S5M8767_BUCK3:\r\nreg = S5M8767_REG_BUCK3DVS1;\r\nif (s5m8767->buck3_gpiodvs)\r\nreg += s5m8767->buck_gpioindex;\r\nbreak;\r\ncase S5M8767_BUCK4:\r\nreg = S5M8767_REG_BUCK4DVS1;\r\nif (s5m8767->buck4_gpiodvs)\r\nreg += s5m8767->buck_gpioindex;\r\nbreak;\r\ncase S5M8767_BUCK5:\r\nreg = S5M8767_REG_BUCK5CTRL2;\r\nbreak;\r\ncase S5M8767_BUCK6 ... S5M8767_BUCK9:\r\nreg = S5M8767_REG_BUCK6CTRL2 + (reg_id - S5M8767_BUCK6) * 2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn reg;\r\n}\r\nstatic int s5m8767_convert_voltage_to_sel(const struct sec_voltage_desc *desc,\r\nint min_vol)\r\n{\r\nint selector = 0;\r\nif (desc == NULL)\r\nreturn -EINVAL;\r\nif (min_vol > desc->max)\r\nreturn -EINVAL;\r\nif (min_vol < desc->min)\r\nmin_vol = desc->min;\r\nselector = DIV_ROUND_UP(min_vol - desc->min, desc->step);\r\nif (desc->min + desc->step * selector > desc->max)\r\nreturn -EINVAL;\r\nreturn selector;\r\n}\r\nstatic inline int s5m8767_set_high(struct s5m8767_info *s5m8767)\r\n{\r\nint temp_index = s5m8767->buck_gpioindex;\r\ngpio_set_value(s5m8767->buck_gpios[0], (temp_index >> 2) & 0x1);\r\ngpio_set_value(s5m8767->buck_gpios[1], (temp_index >> 1) & 0x1);\r\ngpio_set_value(s5m8767->buck_gpios[2], temp_index & 0x1);\r\nreturn 0;\r\n}\r\nstatic inline int s5m8767_set_low(struct s5m8767_info *s5m8767)\r\n{\r\nint temp_index = s5m8767->buck_gpioindex;\r\ngpio_set_value(s5m8767->buck_gpios[2], temp_index & 0x1);\r\ngpio_set_value(s5m8767->buck_gpios[1], (temp_index >> 1) & 0x1);\r\ngpio_set_value(s5m8767->buck_gpios[0], (temp_index >> 2) & 0x1);\r\nreturn 0;\r\n}\r\nstatic int s5m8767_set_voltage_sel(struct regulator_dev *rdev,\r\nunsigned selector)\r\n{\r\nstruct s5m8767_info *s5m8767 = rdev_get_drvdata(rdev);\r\nint reg_id = rdev_get_id(rdev);\r\nint old_index, index = 0;\r\nu8 *buck234_vol = NULL;\r\nswitch (reg_id) {\r\ncase S5M8767_LDO1 ... S5M8767_LDO28:\r\nbreak;\r\ncase S5M8767_BUCK1 ... S5M8767_BUCK6:\r\nif (reg_id == S5M8767_BUCK2 && s5m8767->buck2_gpiodvs)\r\nbuck234_vol = &s5m8767->buck2_vol[0];\r\nelse if (reg_id == S5M8767_BUCK3 && s5m8767->buck3_gpiodvs)\r\nbuck234_vol = &s5m8767->buck3_vol[0];\r\nelse if (reg_id == S5M8767_BUCK4 && s5m8767->buck4_gpiodvs)\r\nbuck234_vol = &s5m8767->buck4_vol[0];\r\nbreak;\r\ncase S5M8767_BUCK7 ... S5M8767_BUCK8:\r\nreturn -EINVAL;\r\ncase S5M8767_BUCK9:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (buck234_vol) {\r\nwhile (*buck234_vol != selector) {\r\nbuck234_vol++;\r\nindex++;\r\n}\r\nold_index = s5m8767->buck_gpioindex;\r\ns5m8767->buck_gpioindex = index;\r\nif (index > old_index)\r\nreturn s5m8767_set_high(s5m8767);\r\nelse\r\nreturn s5m8767_set_low(s5m8767);\r\n} else {\r\nreturn regulator_set_voltage_sel_regmap(rdev, selector);\r\n}\r\n}\r\nstatic int s5m8767_set_voltage_time_sel(struct regulator_dev *rdev,\r\nunsigned int old_sel,\r\nunsigned int new_sel)\r\n{\r\nstruct s5m8767_info *s5m8767 = rdev_get_drvdata(rdev);\r\nconst struct sec_voltage_desc *desc;\r\nint reg_id = rdev_get_id(rdev);\r\ndesc = reg_voltage_map[reg_id];\r\nif ((old_sel < new_sel) && s5m8767->ramp_delay)\r\nreturn DIV_ROUND_UP(desc->step * (new_sel - old_sel),\r\ns5m8767->ramp_delay * 1000);\r\nreturn 0;\r\n}\r\nstatic int s5m8767_pmic_dt_parse_dvs_gpio(struct sec_pmic_dev *iodev,\r\nstruct sec_platform_data *pdata,\r\nstruct device_node *pmic_np)\r\n{\r\nint i, gpio;\r\nfor (i = 0; i < 3; i++) {\r\ngpio = of_get_named_gpio(pmic_np,\r\n"s5m8767,pmic-buck-dvs-gpios", i);\r\nif (!gpio_is_valid(gpio)) {\r\ndev_err(iodev->dev, "invalid gpio[%d]: %d\n", i, gpio);\r\nreturn -EINVAL;\r\n}\r\npdata->buck_gpios[i] = gpio;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5m8767_pmic_dt_parse_ds_gpio(struct sec_pmic_dev *iodev,\r\nstruct sec_platform_data *pdata,\r\nstruct device_node *pmic_np)\r\n{\r\nint i, gpio;\r\nfor (i = 0; i < 3; i++) {\r\ngpio = of_get_named_gpio(pmic_np,\r\n"s5m8767,pmic-buck-ds-gpios", i);\r\nif (!gpio_is_valid(gpio)) {\r\ndev_err(iodev->dev, "invalid gpio[%d]: %d\n", i, gpio);\r\nreturn -EINVAL;\r\n}\r\npdata->buck_ds[i] = gpio;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5m8767_pmic_dt_parse_pdata(struct platform_device *pdev,\r\nstruct sec_platform_data *pdata)\r\n{\r\nstruct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);\r\nstruct device_node *pmic_np, *regulators_np, *reg_np;\r\nstruct sec_regulator_data *rdata;\r\nstruct sec_opmode_data *rmode;\r\nunsigned int i, dvs_voltage_nr = 1, ret;\r\npmic_np = iodev->dev->of_node;\r\nif (!pmic_np) {\r\ndev_err(iodev->dev, "could not find pmic sub-node\n");\r\nreturn -ENODEV;\r\n}\r\nregulators_np = of_find_node_by_name(pmic_np, "regulators");\r\nif (!regulators_np) {\r\ndev_err(iodev->dev, "could not find regulators sub-node\n");\r\nreturn -EINVAL;\r\n}\r\npdata->num_regulators = of_get_child_count(regulators_np);\r\nrdata = devm_kzalloc(&pdev->dev, sizeof(*rdata) *\r\npdata->num_regulators, GFP_KERNEL);\r\nif (!rdata) {\r\ndev_err(iodev->dev,\r\n"could not allocate memory for regulator data\n");\r\nreturn -ENOMEM;\r\n}\r\nrmode = devm_kzalloc(&pdev->dev, sizeof(*rmode) *\r\npdata->num_regulators, GFP_KERNEL);\r\nif (!rmode) {\r\ndev_err(iodev->dev,\r\n"could not allocate memory for regulator mode\n");\r\nreturn -ENOMEM;\r\n}\r\npdata->regulators = rdata;\r\npdata->opmode = rmode;\r\nfor_each_child_of_node(regulators_np, reg_np) {\r\nfor (i = 0; i < ARRAY_SIZE(regulators); i++)\r\nif (!of_node_cmp(reg_np->name, regulators[i].name))\r\nbreak;\r\nif (i == ARRAY_SIZE(regulators)) {\r\ndev_warn(iodev->dev,\r\n"don't know how to configure regulator %s\n",\r\nreg_np->name);\r\ncontinue;\r\n}\r\nrdata->id = i;\r\nrdata->initdata = of_get_regulator_init_data(\r\n&pdev->dev, reg_np);\r\nrdata->reg_node = reg_np;\r\nrdata++;\r\nrmode->id = i;\r\nif (of_property_read_u32(reg_np, "op_mode",\r\n&rmode->mode)) {\r\ndev_warn(iodev->dev,\r\n"no op_mode property property at %s\n",\r\nreg_np->full_name);\r\nrmode->mode = S5M8767_OPMODE_NORMAL_MODE;\r\n}\r\nrmode++;\r\n}\r\nif (of_get_property(pmic_np, "s5m8767,pmic-buck2-uses-gpio-dvs", NULL))\r\npdata->buck2_gpiodvs = true;\r\nif (of_get_property(pmic_np, "s5m8767,pmic-buck3-uses-gpio-dvs", NULL))\r\npdata->buck3_gpiodvs = true;\r\nif (of_get_property(pmic_np, "s5m8767,pmic-buck4-uses-gpio-dvs", NULL))\r\npdata->buck4_gpiodvs = true;\r\nif (pdata->buck2_gpiodvs || pdata->buck3_gpiodvs ||\r\npdata->buck4_gpiodvs) {\r\nret = s5m8767_pmic_dt_parse_dvs_gpio(iodev, pdata, pmic_np);\r\nif (ret)\r\nreturn -EINVAL;\r\nif (of_property_read_u32(pmic_np,\r\n"s5m8767,pmic-buck-default-dvs-idx",\r\n&pdata->buck_default_idx)) {\r\npdata->buck_default_idx = 0;\r\n} else {\r\nif (pdata->buck_default_idx >= 8) {\r\npdata->buck_default_idx = 0;\r\ndev_info(iodev->dev,\r\n"invalid value for default dvs index, use 0\n");\r\n}\r\n}\r\ndvs_voltage_nr = 8;\r\n}\r\nret = s5m8767_pmic_dt_parse_ds_gpio(iodev, pdata, pmic_np);\r\nif (ret)\r\nreturn -EINVAL;\r\nif (of_property_read_u32_array(pmic_np,\r\n"s5m8767,pmic-buck2-dvs-voltage",\r\npdata->buck2_voltage, dvs_voltage_nr)) {\r\ndev_err(iodev->dev, "buck2 voltages not specified\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_u32_array(pmic_np,\r\n"s5m8767,pmic-buck3-dvs-voltage",\r\npdata->buck3_voltage, dvs_voltage_nr)) {\r\ndev_err(iodev->dev, "buck3 voltages not specified\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_u32_array(pmic_np,\r\n"s5m8767,pmic-buck4-dvs-voltage",\r\npdata->buck4_voltage, dvs_voltage_nr)) {\r\ndev_err(iodev->dev, "buck4 voltages not specified\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5m8767_pmic_dt_parse_pdata(struct platform_device *pdev,\r\nstruct sec_platform_data *pdata)\r\n{\r\nreturn 0;\r\n}\r\nstatic int s5m8767_pmic_probe(struct platform_device *pdev)\r\n{\r\nstruct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);\r\nstruct sec_platform_data *pdata = iodev->pdata;\r\nstruct regulator_config config = { };\r\nstruct regulator_dev **rdev;\r\nstruct s5m8767_info *s5m8767;\r\nint i, ret, size, buck_init;\r\nif (!pdata) {\r\ndev_err(pdev->dev.parent, "Platform data not supplied\n");\r\nreturn -ENODEV;\r\n}\r\nif (iodev->dev->of_node) {\r\nret = s5m8767_pmic_dt_parse_pdata(pdev, pdata);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (pdata->buck2_gpiodvs) {\r\nif (pdata->buck3_gpiodvs || pdata->buck4_gpiodvs) {\r\ndev_err(&pdev->dev, "S5M8767 GPIO DVS NOT VALID\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (pdata->buck3_gpiodvs) {\r\nif (pdata->buck2_gpiodvs || pdata->buck4_gpiodvs) {\r\ndev_err(&pdev->dev, "S5M8767 GPIO DVS NOT VALID\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (pdata->buck4_gpiodvs) {\r\nif (pdata->buck2_gpiodvs || pdata->buck3_gpiodvs) {\r\ndev_err(&pdev->dev, "S5M8767 GPIO DVS NOT VALID\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\ns5m8767 = devm_kzalloc(&pdev->dev, sizeof(struct s5m8767_info),\r\nGFP_KERNEL);\r\nif (!s5m8767)\r\nreturn -ENOMEM;\r\nsize = sizeof(struct regulator_dev *) * (S5M8767_REG_MAX - 2);\r\ns5m8767->rdev = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);\r\nif (!s5m8767->rdev)\r\nreturn -ENOMEM;\r\nrdev = s5m8767->rdev;\r\ns5m8767->dev = &pdev->dev;\r\ns5m8767->iodev = iodev;\r\ns5m8767->num_regulators = pdata->num_regulators;\r\nplatform_set_drvdata(pdev, s5m8767);\r\ns5m8767->buck_gpioindex = pdata->buck_default_idx;\r\ns5m8767->buck2_gpiodvs = pdata->buck2_gpiodvs;\r\ns5m8767->buck3_gpiodvs = pdata->buck3_gpiodvs;\r\ns5m8767->buck4_gpiodvs = pdata->buck4_gpiodvs;\r\ns5m8767->buck_gpios[0] = pdata->buck_gpios[0];\r\ns5m8767->buck_gpios[1] = pdata->buck_gpios[1];\r\ns5m8767->buck_gpios[2] = pdata->buck_gpios[2];\r\ns5m8767->buck_ds[0] = pdata->buck_ds[0];\r\ns5m8767->buck_ds[1] = pdata->buck_ds[1];\r\ns5m8767->buck_ds[2] = pdata->buck_ds[2];\r\ns5m8767->ramp_delay = pdata->buck_ramp_delay;\r\ns5m8767->buck2_ramp = pdata->buck2_ramp_enable;\r\ns5m8767->buck3_ramp = pdata->buck3_ramp_enable;\r\ns5m8767->buck4_ramp = pdata->buck4_ramp_enable;\r\ns5m8767->opmode = pdata->opmode;\r\nbuck_init = s5m8767_convert_voltage_to_sel(&buck_voltage_val2,\r\npdata->buck2_init);\r\nsec_reg_write(s5m8767->iodev, S5M8767_REG_BUCK2DVS2, buck_init);\r\nbuck_init = s5m8767_convert_voltage_to_sel(&buck_voltage_val2,\r\npdata->buck3_init);\r\nsec_reg_write(s5m8767->iodev, S5M8767_REG_BUCK3DVS2, buck_init);\r\nbuck_init = s5m8767_convert_voltage_to_sel(&buck_voltage_val2,\r\npdata->buck4_init);\r\nsec_reg_write(s5m8767->iodev, S5M8767_REG_BUCK4DVS2, buck_init);\r\nfor (i = 0; i < 8; i++) {\r\nif (s5m8767->buck2_gpiodvs) {\r\ns5m8767->buck2_vol[i] =\r\ns5m8767_convert_voltage_to_sel(\r\n&buck_voltage_val2,\r\npdata->buck2_voltage[i]);\r\n}\r\nif (s5m8767->buck3_gpiodvs) {\r\ns5m8767->buck3_vol[i] =\r\ns5m8767_convert_voltage_to_sel(\r\n&buck_voltage_val2,\r\npdata->buck3_voltage[i]);\r\n}\r\nif (s5m8767->buck4_gpiodvs) {\r\ns5m8767->buck4_vol[i] =\r\ns5m8767_convert_voltage_to_sel(\r\n&buck_voltage_val2,\r\npdata->buck4_voltage[i]);\r\n}\r\n}\r\nif (pdata->buck2_gpiodvs || pdata->buck3_gpiodvs ||\r\npdata->buck4_gpiodvs) {\r\nif (!gpio_is_valid(pdata->buck_gpios[0]) ||\r\n!gpio_is_valid(pdata->buck_gpios[1]) ||\r\n!gpio_is_valid(pdata->buck_gpios[2])) {\r\ndev_err(&pdev->dev, "GPIO NOT VALID\n");\r\nreturn -EINVAL;\r\n}\r\nret = devm_gpio_request(&pdev->dev, pdata->buck_gpios[0],\r\n"S5M8767 SET1");\r\nif (ret)\r\nreturn ret;\r\nret = devm_gpio_request(&pdev->dev, pdata->buck_gpios[1],\r\n"S5M8767 SET2");\r\nif (ret)\r\nreturn ret;\r\nret = devm_gpio_request(&pdev->dev, pdata->buck_gpios[2],\r\n"S5M8767 SET3");\r\nif (ret)\r\nreturn ret;\r\ngpio_direction_output(pdata->buck_gpios[0],\r\n(s5m8767->buck_gpioindex >> 2) & 0x1);\r\ngpio_direction_output(pdata->buck_gpios[1],\r\n(s5m8767->buck_gpioindex >> 1) & 0x1);\r\ngpio_direction_output(pdata->buck_gpios[2],\r\n(s5m8767->buck_gpioindex >> 0) & 0x1);\r\n}\r\nret = devm_gpio_request(&pdev->dev, pdata->buck_ds[0], "S5M8767 DS2");\r\nif (ret)\r\nreturn ret;\r\nret = devm_gpio_request(&pdev->dev, pdata->buck_ds[1], "S5M8767 DS3");\r\nif (ret)\r\nreturn ret;\r\nret = devm_gpio_request(&pdev->dev, pdata->buck_ds[2], "S5M8767 DS4");\r\nif (ret)\r\nreturn ret;\r\ngpio_direction_output(pdata->buck_ds[0], 0x0);\r\ngpio_direction_output(pdata->buck_ds[1], 0x0);\r\ngpio_direction_output(pdata->buck_ds[2], 0x0);\r\nif (pdata->buck2_gpiodvs || pdata->buck3_gpiodvs ||\r\npdata->buck4_gpiodvs) {\r\nsec_reg_update(s5m8767->iodev, S5M8767_REG_BUCK2CTRL,\r\n(pdata->buck2_gpiodvs) ? (1 << 1) : (0 << 1),\r\n1 << 1);\r\nsec_reg_update(s5m8767->iodev, S5M8767_REG_BUCK3CTRL,\r\n(pdata->buck3_gpiodvs) ? (1 << 1) : (0 << 1),\r\n1 << 1);\r\nsec_reg_update(s5m8767->iodev, S5M8767_REG_BUCK4CTRL,\r\n(pdata->buck4_gpiodvs) ? (1 << 1) : (0 << 1),\r\n1 << 1);\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nif (s5m8767->buck2_gpiodvs) {\r\nsec_reg_write(s5m8767->iodev, S5M8767_REG_BUCK2DVS1 + i,\r\ns5m8767->buck2_vol[i]);\r\n}\r\nif (s5m8767->buck3_gpiodvs) {\r\nsec_reg_write(s5m8767->iodev, S5M8767_REG_BUCK3DVS1 + i,\r\ns5m8767->buck3_vol[i]);\r\n}\r\nif (s5m8767->buck4_gpiodvs) {\r\nsec_reg_write(s5m8767->iodev, S5M8767_REG_BUCK4DVS1 + i,\r\ns5m8767->buck4_vol[i]);\r\n}\r\n}\r\nif (s5m8767->buck2_ramp)\r\nsec_reg_update(s5m8767->iodev, S5M8767_REG_DVSRAMP, 0x08, 0x08);\r\nif (s5m8767->buck3_ramp)\r\nsec_reg_update(s5m8767->iodev, S5M8767_REG_DVSRAMP, 0x04, 0x04);\r\nif (s5m8767->buck4_ramp)\r\nsec_reg_update(s5m8767->iodev, S5M8767_REG_DVSRAMP, 0x02, 0x02);\r\nif (s5m8767->buck2_ramp || s5m8767->buck3_ramp\r\n|| s5m8767->buck4_ramp) {\r\nswitch (s5m8767->ramp_delay) {\r\ncase 5:\r\nsec_reg_update(s5m8767->iodev, S5M8767_REG_DVSRAMP,\r\n0x40, 0xf0);\r\nbreak;\r\ncase 10:\r\nsec_reg_update(s5m8767->iodev, S5M8767_REG_DVSRAMP,\r\n0x90, 0xf0);\r\nbreak;\r\ncase 25:\r\nsec_reg_update(s5m8767->iodev, S5M8767_REG_DVSRAMP,\r\n0xd0, 0xf0);\r\nbreak;\r\ncase 50:\r\nsec_reg_update(s5m8767->iodev, S5M8767_REG_DVSRAMP,\r\n0xe0, 0xf0);\r\nbreak;\r\ncase 100:\r\nsec_reg_update(s5m8767->iodev, S5M8767_REG_DVSRAMP,\r\n0xf0, 0xf0);\r\nbreak;\r\ndefault:\r\nsec_reg_update(s5m8767->iodev, S5M8767_REG_DVSRAMP,\r\n0x90, 0xf0);\r\n}\r\n}\r\nfor (i = 0; i < pdata->num_regulators; i++) {\r\nconst struct sec_voltage_desc *desc;\r\nint id = pdata->regulators[i].id;\r\ndesc = reg_voltage_map[id];\r\nif (desc) {\r\nregulators[id].n_voltages =\r\n(desc->max - desc->min) / desc->step + 1;\r\nregulators[id].min_uV = desc->min;\r\nregulators[id].uV_step = desc->step;\r\nregulators[id].vsel_reg =\r\ns5m8767_get_vsel_reg(id, s5m8767);\r\nif (id < S5M8767_BUCK1)\r\nregulators[id].vsel_mask = 0x3f;\r\nelse\r\nregulators[id].vsel_mask = 0xff;\r\n}\r\nconfig.dev = s5m8767->dev;\r\nconfig.init_data = pdata->regulators[i].initdata;\r\nconfig.driver_data = s5m8767;\r\nconfig.regmap = iodev->regmap;\r\nconfig.of_node = pdata->regulators[i].reg_node;\r\nrdev[i] = regulator_register(&regulators[id], &config);\r\nif (IS_ERR(rdev[i])) {\r\nret = PTR_ERR(rdev[i]);\r\ndev_err(s5m8767->dev, "regulator init failed for %d\n",\r\nid);\r\nrdev[i] = NULL;\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nfor (i = 0; i < s5m8767->num_regulators; i++)\r\nregulator_unregister(rdev[i]);\r\nreturn ret;\r\n}\r\nstatic int s5m8767_pmic_remove(struct platform_device *pdev)\r\n{\r\nstruct s5m8767_info *s5m8767 = platform_get_drvdata(pdev);\r\nstruct regulator_dev **rdev = s5m8767->rdev;\r\nint i;\r\nfor (i = 0; i < s5m8767->num_regulators; i++)\r\nregulator_unregister(rdev[i]);\r\nreturn 0;\r\n}\r\nstatic int __init s5m8767_pmic_init(void)\r\n{\r\nreturn platform_driver_register(&s5m8767_pmic_driver);\r\n}\r\nstatic void __exit s5m8767_pmic_exit(void)\r\n{\r\nplatform_driver_unregister(&s5m8767_pmic_driver);\r\n}
