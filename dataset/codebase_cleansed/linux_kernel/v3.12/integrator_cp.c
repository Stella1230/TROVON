static void __init intcp_map_io(void)\r\n{\r\niotable_init(intcp_io_desc, ARRAY_SIZE(intcp_io_desc));\r\n}\r\nstatic int intcp_flash_init(struct platform_device *dev)\r\n{\r\nu32 val;\r\nval = readl(intcp_con_base + INTCP_FLASHPROG);\r\nval |= CINTEGRATOR_FLASHPROG_FLWREN;\r\nwritel(val, intcp_con_base + INTCP_FLASHPROG);\r\nreturn 0;\r\n}\r\nstatic void intcp_flash_exit(struct platform_device *dev)\r\n{\r\nu32 val;\r\nval = readl(intcp_con_base + INTCP_FLASHPROG);\r\nval &= ~(CINTEGRATOR_FLASHPROG_FLVPPEN|CINTEGRATOR_FLASHPROG_FLWREN);\r\nwritel(val, intcp_con_base + INTCP_FLASHPROG);\r\n}\r\nstatic void intcp_flash_set_vpp(struct platform_device *pdev, int on)\r\n{\r\nu32 val;\r\nval = readl(intcp_con_base + INTCP_FLASHPROG);\r\nif (on)\r\nval |= CINTEGRATOR_FLASHPROG_FLVPPEN;\r\nelse\r\nval &= ~CINTEGRATOR_FLASHPROG_FLVPPEN;\r\nwritel(val, intcp_con_base + INTCP_FLASHPROG);\r\n}\r\nstatic unsigned int mmc_status(struct device *dev)\r\n{\r\nunsigned int status = readl(__io_address(0xca000000 + 4));\r\nwritel(8, intcp_con_base + 8);\r\nreturn status & 8;\r\n}\r\nstatic void cp_clcd_enable(struct clcd_fb *fb)\r\n{\r\nstruct fb_var_screeninfo *var = &fb->fb.var;\r\nu32 val = CM_CTRL_STATIC1 | CM_CTRL_STATIC2;\r\nif (var->bits_per_pixel <= 8 ||\r\n(var->bits_per_pixel == 16 && var->green.length == 5))\r\nval |= CM_CTRL_LCDMUXSEL_VGA555_TFT555;\r\nelse if (fb->fb.var.bits_per_pixel <= 16)\r\nval |= CM_CTRL_LCDMUXSEL_VGA565_TFT555;\r\nelse\r\nval = 0;\r\ncm_control(CM_CTRL_LCDMUXSEL_MASK|\r\nCM_CTRL_LCDEN0|\r\nCM_CTRL_LCDEN1|\r\nCM_CTRL_STATIC1|\r\nCM_CTRL_STATIC2|\r\nCM_CTRL_STATIC|\r\nCM_CTRL_n24BITEN, val);\r\n}\r\nstatic int cp_clcd_setup(struct clcd_fb *fb)\r\n{\r\nfb->panel = versatile_clcd_get_panel("VGA");\r\nif (!fb->panel)\r\nreturn -EINVAL;\r\nreturn versatile_clcd_setup_dma(fb, SZ_1M);\r\n}\r\nstatic void __init intcp_init_early(void)\r\n{\r\n#ifdef CONFIG_PLAT_VERSATILE_SCHED_CLOCK\r\nversatile_sched_clock_init(REFCOUNTER, 24000000);\r\n#endif\r\n}\r\nstatic void __init intcp_init_irq_of(void)\r\n{\r\nof_irq_init(fpga_irq_of_match);\r\nintegrator_clk_init(true);\r\n}\r\nstatic void __init intcp_init_of(void)\r\n{\r\nstruct device_node *root;\r\nstruct device_node *cpcon;\r\nstruct device *parent;\r\nstruct soc_device *soc_dev;\r\nstruct soc_device_attribute *soc_dev_attr;\r\nu32 intcp_sc_id;\r\nint err;\r\nroot = of_find_node_by_path("/");\r\nif (!root)\r\nreturn;\r\ncpcon = of_find_node_by_path("/cpcon");\r\nif (!cpcon)\r\nreturn;\r\nintcp_con_base = of_iomap(cpcon, 0);\r\nif (!intcp_con_base)\r\nreturn;\r\nintcp_sc_id = readl(intcp_con_base);\r\nsoc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);\r\nif (!soc_dev_attr)\r\nreturn;\r\nerr = of_property_read_string(root, "compatible",\r\n&soc_dev_attr->soc_id);\r\nif (err)\r\nreturn;\r\nerr = of_property_read_string(root, "model", &soc_dev_attr->machine);\r\nif (err)\r\nreturn;\r\nsoc_dev_attr->family = "Integrator";\r\nsoc_dev_attr->revision = kasprintf(GFP_KERNEL, "%c",\r\n'A' + (intcp_sc_id & 0x0f));\r\nsoc_dev = soc_device_register(soc_dev_attr);\r\nif (IS_ERR(soc_dev)) {\r\nkfree(soc_dev_attr->revision);\r\nkfree(soc_dev_attr);\r\nreturn;\r\n}\r\nparent = soc_device_to_device(soc_dev);\r\nintegrator_init_sysfs(parent, intcp_sc_id);\r\nof_platform_populate(root, of_default_bus_match_table,\r\nintcp_auxdata_lookup, parent);\r\n}\r\nstatic void __init intcp_map_io_atag(void)\r\n{\r\niotable_init(intcp_io_desc_atag, ARRAY_SIZE(intcp_io_desc_atag));\r\nintcp_con_base = __io_address(INTEGRATOR_CP_CTL_BASE);\r\nintcp_map_io();\r\n}\r\nstatic void __init intcp_init_irq(void)\r\n{\r\nu32 pic_mask, cic_mask, sic_mask;\r\npic_mask = ~((~0u) << (11 - 0));\r\npic_mask |= (~((~0u) << (29 - 22))) << 22;\r\ncic_mask = ~((~0u) << (1 + IRQ_CIC_END - IRQ_CIC_START));\r\nsic_mask = ~((~0u) << (1 + IRQ_SIC_END - IRQ_SIC_START));\r\nwritel(0xffffffff, INTCP_VA_PIC_BASE + IRQ_ENABLE_CLEAR);\r\nwritel(0xffffffff, INTCP_VA_PIC_BASE + FIQ_ENABLE_CLEAR);\r\nwritel(0xffffffff, INTCP_VA_CIC_BASE + IRQ_ENABLE_CLEAR);\r\nwritel(0xffffffff, INTCP_VA_CIC_BASE + FIQ_ENABLE_CLEAR);\r\nwritel(sic_mask, INTCP_VA_SIC_BASE + IRQ_ENABLE_CLEAR);\r\nwritel(sic_mask, INTCP_VA_SIC_BASE + FIQ_ENABLE_CLEAR);\r\nfpga_irq_init(INTCP_VA_PIC_BASE, "PIC", IRQ_PIC_START,\r\n-1, pic_mask, NULL);\r\nfpga_irq_init(INTCP_VA_CIC_BASE, "CIC", IRQ_CIC_START,\r\n-1, cic_mask, NULL);\r\nfpga_irq_init(INTCP_VA_SIC_BASE, "SIC", IRQ_SIC_START,\r\nIRQ_CP_CPPLDINT, sic_mask, NULL);\r\nintegrator_clk_init(true);\r\n}\r\nstatic void __init cp_timer_init(void)\r\n{\r\nwritel(0, TIMER0_VA_BASE + TIMER_CTRL);\r\nwritel(0, TIMER1_VA_BASE + TIMER_CTRL);\r\nwritel(0, TIMER2_VA_BASE + TIMER_CTRL);\r\nsp804_clocksource_init(TIMER2_VA_BASE, "timer2");\r\nsp804_clockevents_init(TIMER1_VA_BASE, IRQ_TIMERINT1, "timer1");\r\n}\r\nstatic void __init intcp_init(void)\r\n{\r\nint i;\r\nplatform_add_devices(intcp_devs, ARRAY_SIZE(intcp_devs));\r\nfor (i = 0; i < ARRAY_SIZE(amba_devs); i++) {\r\nstruct amba_device *d = amba_devs[i];\r\namba_device_register(d, &iomem_resource);\r\n}\r\nintegrator_init(true);\r\n}
