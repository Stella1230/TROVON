static void mei_wd_set_start_timeout(struct mei_device *dev, u16 timeout)\r\n{\r\ndev_dbg(&dev->pdev->dev, "wd: set timeout=%d.\n", timeout);\r\nmemcpy(dev->wd_data, mei_start_wd_params, MEI_WD_HDR_SIZE);\r\nmemcpy(dev->wd_data + MEI_WD_HDR_SIZE, &timeout, sizeof(u16));\r\n}\r\nint mei_wd_host_init(struct mei_device *dev)\r\n{\r\nstruct mei_cl *cl = &dev->wd_cl;\r\nint i;\r\nint ret;\r\nmei_cl_init(cl, dev);\r\ndev->wd_timeout = MEI_WD_DEFAULT_TIMEOUT;\r\ndev->wd_state = MEI_WD_IDLE;\r\ni = mei_me_cl_by_uuid(dev, &mei_wd_guid);\r\nif (i < 0) {\r\ndev_info(&dev->pdev->dev, "wd: failed to find the client\n");\r\nreturn -ENOENT;\r\n}\r\ncl->me_client_id = dev->me_clients[i].client_id;\r\nret = mei_cl_link(cl, MEI_WD_HOST_CLIENT_ID);\r\nif (ret < 0) {\r\ndev_info(&dev->pdev->dev, "wd: failed link client\n");\r\nreturn -ENOENT;\r\n}\r\ncl->state = MEI_FILE_CONNECTING;\r\nif (mei_hbm_cl_connect_req(dev, cl)) {\r\ndev_err(&dev->pdev->dev, "wd: failed to connect to the client\n");\r\ncl->state = MEI_FILE_DISCONNECTED;\r\ncl->host_client_id = 0;\r\nreturn -EIO;\r\n}\r\ncl->timer_count = MEI_CONNECT_TIMEOUT;\r\nreturn 0;\r\n}\r\nint mei_wd_send(struct mei_device *dev)\r\n{\r\nstruct mei_msg_hdr hdr;\r\nhdr.host_addr = dev->wd_cl.host_client_id;\r\nhdr.me_addr = dev->wd_cl.me_client_id;\r\nhdr.msg_complete = 1;\r\nhdr.reserved = 0;\r\nif (!memcmp(dev->wd_data, mei_start_wd_params, MEI_WD_HDR_SIZE))\r\nhdr.length = MEI_WD_START_MSG_SIZE;\r\nelse if (!memcmp(dev->wd_data, mei_stop_wd_params, MEI_WD_HDR_SIZE))\r\nhdr.length = MEI_WD_STOP_MSG_SIZE;\r\nelse\r\nreturn -EINVAL;\r\nreturn mei_write_message(dev, &hdr, dev->wd_data);\r\n}\r\nint mei_wd_stop(struct mei_device *dev)\r\n{\r\nint ret;\r\nif (dev->wd_cl.state != MEI_FILE_CONNECTED ||\r\ndev->wd_state != MEI_WD_RUNNING)\r\nreturn 0;\r\nmemcpy(dev->wd_data, mei_stop_wd_params, MEI_WD_STOP_MSG_SIZE);\r\ndev->wd_state = MEI_WD_STOPPING;\r\nret = mei_cl_flow_ctrl_creds(&dev->wd_cl);\r\nif (ret < 0)\r\ngoto out;\r\nif (ret && dev->hbuf_is_ready) {\r\nret = 0;\r\ndev->hbuf_is_ready = false;\r\nif (!mei_wd_send(dev)) {\r\nret = mei_cl_flow_ctrl_reduce(&dev->wd_cl);\r\nif (ret)\r\ngoto out;\r\n} else {\r\ndev_err(&dev->pdev->dev, "wd: send stop failed\n");\r\n}\r\ndev->wd_pending = false;\r\n} else {\r\ndev->wd_pending = true;\r\n}\r\nmutex_unlock(&dev->device_lock);\r\nret = wait_event_interruptible_timeout(dev->wait_stop_wd,\r\ndev->wd_state == MEI_WD_IDLE,\r\nmsecs_to_jiffies(MEI_WD_STOP_TIMEOUT));\r\nmutex_lock(&dev->device_lock);\r\nif (dev->wd_state == MEI_WD_IDLE) {\r\ndev_dbg(&dev->pdev->dev, "wd: stop completed ret=%d.\n", ret);\r\nret = 0;\r\n} else {\r\nif (!ret)\r\nret = -ETIMEDOUT;\r\ndev_warn(&dev->pdev->dev,\r\n"wd: stop failed to complete ret=%d.\n", ret);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int mei_wd_ops_start(struct watchdog_device *wd_dev)\r\n{\r\nint err = -ENODEV;\r\nstruct mei_device *dev;\r\ndev = watchdog_get_drvdata(wd_dev);\r\nif (!dev)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->device_lock);\r\nif (dev->dev_state != MEI_DEV_ENABLED) {\r\ndev_dbg(&dev->pdev->dev,\r\n"wd: dev_state != MEI_DEV_ENABLED dev_state = %s\n",\r\nmei_dev_state_str(dev->dev_state));\r\ngoto end_unlock;\r\n}\r\nif (dev->wd_cl.state != MEI_FILE_CONNECTED) {\r\ndev_dbg(&dev->pdev->dev,\r\n"MEI Driver is not connected to Watchdog Client\n");\r\ngoto end_unlock;\r\n}\r\nmei_wd_set_start_timeout(dev, dev->wd_timeout);\r\nerr = 0;\r\nend_unlock:\r\nmutex_unlock(&dev->device_lock);\r\nreturn err;\r\n}\r\nstatic int mei_wd_ops_stop(struct watchdog_device *wd_dev)\r\n{\r\nstruct mei_device *dev;\r\ndev = watchdog_get_drvdata(wd_dev);\r\nif (!dev)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->device_lock);\r\nmei_wd_stop(dev);\r\nmutex_unlock(&dev->device_lock);\r\nreturn 0;\r\n}\r\nstatic int mei_wd_ops_ping(struct watchdog_device *wd_dev)\r\n{\r\nint ret = 0;\r\nstruct mei_device *dev;\r\ndev = watchdog_get_drvdata(wd_dev);\r\nif (!dev)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->device_lock);\r\nif (dev->wd_cl.state != MEI_FILE_CONNECTED) {\r\ndev_err(&dev->pdev->dev, "wd: not connected.\n");\r\nret = -ENODEV;\r\ngoto end;\r\n}\r\ndev->wd_state = MEI_WD_RUNNING;\r\nif (dev->hbuf_is_ready && mei_cl_flow_ctrl_creds(&dev->wd_cl) > 0) {\r\ndev->hbuf_is_ready = false;\r\ndev_dbg(&dev->pdev->dev, "wd: sending ping\n");\r\nif (mei_wd_send(dev)) {\r\ndev_err(&dev->pdev->dev, "wd: send failed.\n");\r\nret = -EIO;\r\ngoto end;\r\n}\r\nif (mei_cl_flow_ctrl_reduce(&dev->wd_cl)) {\r\ndev_err(&dev->pdev->dev,\r\n"wd: mei_cl_flow_ctrl_reduce() failed.\n");\r\nret = -EIO;\r\ngoto end;\r\n}\r\n} else {\r\ndev->wd_pending = true;\r\n}\r\nend:\r\nmutex_unlock(&dev->device_lock);\r\nreturn ret;\r\n}\r\nstatic int mei_wd_ops_set_timeout(struct watchdog_device *wd_dev,\r\nunsigned int timeout)\r\n{\r\nstruct mei_device *dev;\r\ndev = watchdog_get_drvdata(wd_dev);\r\nif (!dev)\r\nreturn -ENODEV;\r\nif (timeout < MEI_WD_MIN_TIMEOUT || timeout > MEI_WD_MAX_TIMEOUT)\r\nreturn -EINVAL;\r\nmutex_lock(&dev->device_lock);\r\ndev->wd_timeout = timeout;\r\nwd_dev->timeout = timeout;\r\nmei_wd_set_start_timeout(dev, dev->wd_timeout);\r\nmutex_unlock(&dev->device_lock);\r\nreturn 0;\r\n}\r\nvoid mei_watchdog_register(struct mei_device *dev)\r\n{\r\nif (watchdog_register_device(&amt_wd_dev)) {\r\ndev_err(&dev->pdev->dev,\r\n"wd: unable to register watchdog device.\n");\r\nreturn;\r\n}\r\ndev_dbg(&dev->pdev->dev,\r\n"wd: successfully register watchdog interface.\n");\r\nwatchdog_set_drvdata(&amt_wd_dev, dev);\r\n}\r\nvoid mei_watchdog_unregister(struct mei_device *dev)\r\n{\r\nif (watchdog_get_drvdata(&amt_wd_dev) == NULL)\r\nreturn;\r\nwatchdog_set_drvdata(&amt_wd_dev, NULL);\r\nwatchdog_unregister_device(&amt_wd_dev);\r\n}
