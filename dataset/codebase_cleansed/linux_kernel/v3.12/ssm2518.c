static unsigned int ssm2518_lookup_mcs(struct ssm2518 *ssm2518,\r\nunsigned int rate)\r\n{\r\nconst unsigned int *sysclks = NULL;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ssm2518_mcs_lut); i++) {\r\nif (ssm2518_mcs_lut[i].rate == rate) {\r\nsysclks = ssm2518_mcs_lut[i].sysclks;\r\nbreak;\r\n}\r\n}\r\nif (!sysclks)\r\nreturn -EINVAL;\r\nfor (i = 0; sysclks[i]; i++) {\r\nif (sysclks[i] == ssm2518->sysclk)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ssm2518_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct ssm2518 *ssm2518 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int rate = params_rate(params);\r\nunsigned int ctrl1, ctrl1_mask;\r\nint mcs;\r\nint ret;\r\nmcs = ssm2518_lookup_mcs(ssm2518, rate);\r\nif (mcs < 0)\r\nreturn mcs;\r\nctrl1_mask = SSM2518_SAI_CTRL1_FS_MASK;\r\nif (rate >= 8000 && rate <= 12000)\r\nctrl1 = SSM2518_SAI_CTRL1_FS_8000_12000;\r\nelse if (rate >= 16000 && rate <= 24000)\r\nctrl1 = SSM2518_SAI_CTRL1_FS_16000_24000;\r\nelse if (rate >= 32000 && rate <= 48000)\r\nctrl1 = SSM2518_SAI_CTRL1_FS_32000_48000;\r\nelse if (rate >= 64000 && rate <= 96000)\r\nctrl1 = SSM2518_SAI_CTRL1_FS_64000_96000;\r\nelse\r\nreturn -EINVAL;\r\nif (ssm2518->right_j) {\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nctrl1 |= SSM2518_SAI_CTRL1_FMT_RJ_16BIT;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nctrl1 |= SSM2518_SAI_CTRL1_FMT_RJ_24BIT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nctrl1_mask |= SSM2518_SAI_CTRL1_FMT_MASK;\r\n}\r\nret = regmap_update_bits(ssm2518->regmap, SSM2518_REG_CLOCK,\r\nSSM2518_CLOCK_ASR, SSM2518_CLOCK_ASR);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_update_bits(ssm2518->regmap, SSM2518_REG_SAI_CTRL1,\r\nctrl1_mask, ctrl1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn regmap_update_bits(ssm2518->regmap, SSM2518_REG_POWER1,\r\nSSM2518_POWER1_MCS_MASK, mcs << 1);\r\n}\r\nstatic int ssm2518_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct ssm2518 *ssm2518 = snd_soc_codec_get_drvdata(dai->codec);\r\nunsigned int val;\r\nif (mute)\r\nval = SSM2518_MUTE_CTRL_MUTE_MASTER;\r\nelse\r\nval = 0;\r\nreturn regmap_update_bits(ssm2518->regmap, SSM2518_REG_MUTE_CTRL,\r\nSSM2518_MUTE_CTRL_MUTE_MASTER, val);\r\n}\r\nstatic int ssm2518_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct ssm2518 *ssm2518 = snd_soc_codec_get_drvdata(dai->codec);\r\nunsigned int ctrl1 = 0, ctrl2 = 0;\r\nbool invert_fclk;\r\nint ret;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\ninvert_fclk = false;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nctrl2 |= SSM2518_SAI_CTRL2_BCLK_INVERT;\r\ninvert_fclk = false;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\ninvert_fclk = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nctrl2 |= SSM2518_SAI_CTRL2_BCLK_INVERT;\r\ninvert_fclk = true;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nssm2518->right_j = false;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nctrl1 |= SSM2518_SAI_CTRL1_FMT_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nctrl1 |= SSM2518_SAI_CTRL1_FMT_LJ;\r\ninvert_fclk = !invert_fclk;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nctrl1 |= SSM2518_SAI_CTRL1_FMT_RJ_24BIT;\r\nssm2518->right_j = true;\r\ninvert_fclk = !invert_fclk;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nctrl2 |= SSM2518_SAI_CTRL2_LRCLK_PULSE;\r\nctrl1 |= SSM2518_SAI_CTRL1_FMT_I2S;\r\ninvert_fclk = false;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nctrl2 |= SSM2518_SAI_CTRL2_LRCLK_PULSE;\r\nctrl1 |= SSM2518_SAI_CTRL1_FMT_LJ;\r\ninvert_fclk = false;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (invert_fclk)\r\nctrl2 |= SSM2518_SAI_CTRL2_LRCLK_INVERT;\r\nret = regmap_write(ssm2518->regmap, SSM2518_REG_SAI_CTRL1, ctrl1);\r\nif (ret)\r\nreturn ret;\r\nreturn regmap_write(ssm2518->regmap, SSM2518_REG_SAI_CTRL2, ctrl2);\r\n}\r\nstatic int ssm2518_set_power(struct ssm2518 *ssm2518, bool enable)\r\n{\r\nint ret = 0;\r\nif (!enable) {\r\nret = regmap_update_bits(ssm2518->regmap, SSM2518_REG_POWER1,\r\nSSM2518_POWER1_SPWDN, SSM2518_POWER1_SPWDN);\r\nregcache_mark_dirty(ssm2518->regmap);\r\n}\r\nif (gpio_is_valid(ssm2518->enable_gpio))\r\ngpio_set_value(ssm2518->enable_gpio, enable);\r\nregcache_cache_only(ssm2518->regmap, !enable);\r\nif (enable) {\r\nret = regmap_update_bits(ssm2518->regmap, SSM2518_REG_POWER1,\r\nSSM2518_POWER1_SPWDN | SSM2518_POWER1_RESET, 0x00);\r\nregcache_sync(ssm2518->regmap);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ssm2518_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct ssm2518 *ssm2518 = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF)\r\nret = ssm2518_set_power(ssm2518, true);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nret = ssm2518_set_power(ssm2518, false);\r\nbreak;\r\n}\r\nif (ret)\r\nreturn ret;\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int ssm2518_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\r\nunsigned int rx_mask, int slots, int width)\r\n{\r\nstruct ssm2518 *ssm2518 = snd_soc_codec_get_drvdata(dai->codec);\r\nunsigned int ctrl1, ctrl2;\r\nint left_slot, right_slot;\r\nint ret;\r\nif (slots == 0)\r\nreturn regmap_update_bits(ssm2518->regmap,\r\nSSM2518_REG_SAI_CTRL1, SSM2518_SAI_CTRL1_SAI_MASK,\r\nSSM2518_SAI_CTRL1_SAI_I2S);\r\nif (tx_mask == 0 || rx_mask != 0)\r\nreturn -EINVAL;\r\nif (slots == 1) {\r\nif (tx_mask != 1)\r\nreturn -EINVAL;\r\nleft_slot = 0;\r\nright_slot = 0;\r\n} else {\r\nleft_slot = ffs(tx_mask);\r\ntx_mask &= ~(1 << tx_mask);\r\nif (tx_mask == 0) {\r\nright_slot = left_slot;\r\n} else {\r\nright_slot = ffs(tx_mask);\r\ntx_mask &= ~(1 << tx_mask);\r\n}\r\n}\r\nif (tx_mask != 0 || left_slot >= slots || right_slot >= slots)\r\nreturn -EINVAL;\r\nswitch (width) {\r\ncase 16:\r\nctrl2 = SSM2518_SAI_CTRL2_SLOT_WIDTH_16;\r\nbreak;\r\ncase 24:\r\nctrl2 = SSM2518_SAI_CTRL2_SLOT_WIDTH_24;\r\nbreak;\r\ncase 32:\r\nctrl2 = SSM2518_SAI_CTRL2_SLOT_WIDTH_32;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (slots) {\r\ncase 1:\r\nctrl1 = SSM2518_SAI_CTRL1_SAI_MONO;\r\nbreak;\r\ncase 2:\r\nctrl1 = SSM2518_SAI_CTRL1_SAI_TDM_2;\r\nbreak;\r\ncase 4:\r\nctrl1 = SSM2518_SAI_CTRL1_SAI_TDM_4;\r\nbreak;\r\ncase 8:\r\nctrl1 = SSM2518_SAI_CTRL1_SAI_TDM_8;\r\nbreak;\r\ncase 16:\r\nctrl1 = SSM2518_SAI_CTRL1_SAI_TDM_16;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = regmap_write(ssm2518->regmap, SSM2518_REG_CHAN_MAP,\r\n(left_slot << SSM2518_CHAN_MAP_LEFT_SLOT_OFFSET) |\r\n(right_slot << SSM2518_CHAN_MAP_RIGHT_SLOT_OFFSET));\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(ssm2518->regmap, SSM2518_REG_SAI_CTRL1,\r\nSSM2518_SAI_CTRL1_SAI_MASK, ctrl1);\r\nif (ret)\r\nreturn ret;\r\nreturn regmap_update_bits(ssm2518->regmap, SSM2518_REG_SAI_CTRL2,\r\nSSM2518_SAI_CTRL2_SLOT_WIDTH_MASK, ctrl2);\r\n}\r\nstatic int ssm2518_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct ssm2518 *ssm2518 = snd_soc_codec_get_drvdata(dai->codec);\r\nif (ssm2518->constraints)\r\nsnd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE, ssm2518->constraints);\r\nreturn 0;\r\n}\r\nstatic int ssm2518_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct ssm2518 *ssm2518 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\ncodec->control_data = ssm2518->regmap;\r\nret = snd_soc_codec_set_cache_io(codec, 0, 0, SND_SOC_REGMAP);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn ssm2518_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\n}\r\nstatic int ssm2518_remove(struct snd_soc_codec *codec)\r\n{\r\nssm2518_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int ssm2518_set_sysclk(struct snd_soc_codec *codec, int clk_id,\r\nint source, unsigned int freq, int dir)\r\n{\r\nstruct ssm2518 *ssm2518 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val;\r\nif (clk_id != SSM2518_SYSCLK)\r\nreturn -EINVAL;\r\nswitch (source) {\r\ncase SSM2518_SYSCLK_SRC_MCLK:\r\nval = 0;\r\nbreak;\r\ncase SSM2518_SYSCLK_SRC_BCLK:\r\nval = SSM2518_POWER1_NO_BCLK;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (freq) {\r\ncase 0:\r\nssm2518->constraints = NULL;\r\nbreak;\r\ncase 2048000:\r\ncase 4096000:\r\ncase 8192000:\r\ncase 3200000:\r\ncase 6400000:\r\ncase 12800000:\r\nssm2518->constraints = &ssm2518_constraints_2048000;\r\nbreak;\r\ncase 2822000:\r\ncase 5644800:\r\ncase 11289600:\r\ncase 16934400:\r\ncase 22579200:\r\ncase 33868800:\r\ncase 4410000:\r\ncase 8820000:\r\ncase 17640000:\r\nssm2518->constraints = &ssm2518_constraints_2822000;\r\nbreak;\r\ncase 3072000:\r\ncase 6144000:\r\ncase 38864000:\r\ncase 4800000:\r\ncase 9600000:\r\ncase 19200000:\r\nssm2518->constraints = &ssm2518_constraints_3072000;\r\nbreak;\r\ncase 12288000:\r\ncase 16384000:\r\ncase 24576000:\r\nssm2518->constraints = &ssm2518_constraints_12288000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nssm2518->sysclk = freq;\r\nreturn regmap_update_bits(ssm2518->regmap, SSM2518_REG_POWER1,\r\nSSM2518_POWER1_NO_BCLK, val);\r\n}\r\nstatic bool ssm2518_register_volatile(struct device *dev, unsigned int reg)\r\n{\r\nreturn false;\r\n}\r\nstatic int ssm2518_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ssm2518_platform_data *pdata = i2c->dev.platform_data;\r\nstruct ssm2518 *ssm2518;\r\nint ret;\r\nssm2518 = devm_kzalloc(&i2c->dev, sizeof(*ssm2518), GFP_KERNEL);\r\nif (ssm2518 == NULL)\r\nreturn -ENOMEM;\r\nif (pdata) {\r\nssm2518->enable_gpio = pdata->enable_gpio;\r\n} else if (i2c->dev.of_node) {\r\nssm2518->enable_gpio = of_get_gpio(i2c->dev.of_node, 0);\r\nif (ssm2518->enable_gpio < 0 && ssm2518->enable_gpio != -ENOENT)\r\nreturn ssm2518->enable_gpio;\r\n} else {\r\nssm2518->enable_gpio = -1;\r\n}\r\nif (gpio_is_valid(ssm2518->enable_gpio)) {\r\nret = devm_gpio_request_one(&i2c->dev, ssm2518->enable_gpio,\r\nGPIOF_OUT_INIT_HIGH, "SSM2518 nSD");\r\nif (ret)\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(i2c, ssm2518);\r\nssm2518->regmap = devm_regmap_init_i2c(i2c, &ssm2518_regmap_config);\r\nif (IS_ERR(ssm2518->regmap))\r\nreturn PTR_ERR(ssm2518->regmap);\r\nregcache_cache_bypass(ssm2518->regmap, true);\r\nret = regmap_write(ssm2518->regmap, SSM2518_REG_POWER1,\r\nSSM2518_POWER1_RESET);\r\nregcache_cache_bypass(ssm2518->regmap, false);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(ssm2518->regmap, SSM2518_REG_POWER2,\r\nSSM2518_POWER2_APWDN, 0x00);\r\nif (ret)\r\nreturn ret;\r\nret = ssm2518_set_power(ssm2518, false);\r\nif (ret)\r\nreturn ret;\r\nreturn snd_soc_register_codec(&i2c->dev, &ssm2518_codec_driver,\r\n&ssm2518_dai, 1);\r\n}\r\nstatic int ssm2518_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
