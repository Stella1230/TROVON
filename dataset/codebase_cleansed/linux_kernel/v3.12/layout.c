int req_layout_init(void)\r\n{\r\nint i;\r\nint j;\r\nint k;\r\nstruct req_format *rf = NULL;\r\nfor (i = 0; i < ARRAY_SIZE(req_formats); ++i) {\r\nrf = req_formats[i];\r\nrf->rf_idx = i;\r\nfor (j = 0; j < RCL_NR; ++j) {\r\nLASSERT(rf->rf_fields[j].nr <= REQ_MAX_FIELD_NR);\r\nfor (k = 0; k < rf->rf_fields[j].nr; ++k) {\r\nstruct req_msg_field *field;\r\nfield = (typeof(field))rf->rf_fields[j].d[k];\r\nLASSERT(!(field->rmf_flags & RMF_F_STRUCT_ARRAY)\r\n|| field->rmf_size > 0);\r\nLASSERT(field->rmf_offset[i][j] == 0);\r\nfield->rmf_offset[i][j] = k + 1;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid req_layout_fini(void)\r\n{\r\n}\r\nvoid req_capsule_init_area(struct req_capsule *pill)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(pill->rc_area[RCL_CLIENT]); i++) {\r\npill->rc_area[RCL_CLIENT][i] = -1;\r\npill->rc_area[RCL_SERVER][i] = -1;\r\n}\r\n}\r\nvoid req_capsule_init(struct req_capsule *pill,\r\nstruct ptlrpc_request *req,\r\nenum req_location location)\r\n{\r\nLASSERT(location == RCL_SERVER || location == RCL_CLIENT);\r\nif (req != NULL && pill == &req->rq_pill && req->rq_pill_init)\r\nreturn;\r\nmemset(pill, 0, sizeof *pill);\r\npill->rc_req = req;\r\npill->rc_loc = location;\r\nreq_capsule_init_area(pill);\r\nif (req != NULL && pill == &req->rq_pill)\r\nreq->rq_pill_init = 1;\r\n}\r\nvoid req_capsule_fini(struct req_capsule *pill)\r\n{\r\n}\r\nstatic int __req_format_is_sane(const struct req_format *fmt)\r\n{\r\nreturn\r\n0 <= fmt->rf_idx && fmt->rf_idx < ARRAY_SIZE(req_formats) &&\r\nreq_formats[fmt->rf_idx] == fmt;\r\n}\r\nstatic struct lustre_msg *__req_msg(const struct req_capsule *pill,\r\nenum req_location loc)\r\n{\r\nstruct ptlrpc_request *req;\r\nreq = pill->rc_req;\r\nreturn loc == RCL_CLIENT ? req->rq_reqmsg : req->rq_repmsg;\r\n}\r\nvoid req_capsule_set(struct req_capsule *pill, const struct req_format *fmt)\r\n{\r\nLASSERT(pill->rc_fmt == NULL || pill->rc_fmt == fmt);\r\nLASSERT(__req_format_is_sane(fmt));\r\npill->rc_fmt = fmt;\r\n}\r\nint req_capsule_filled_sizes(struct req_capsule *pill,\r\nenum req_location loc)\r\n{\r\nconst struct req_format *fmt = pill->rc_fmt;\r\nint i;\r\nLASSERT(fmt != NULL);\r\nfor (i = 0; i < fmt->rf_fields[loc].nr; ++i) {\r\nif (pill->rc_area[loc][i] == -1) {\r\npill->rc_area[loc][i] =\r\nfmt->rf_fields[loc].d[i]->rmf_size;\r\nif (pill->rc_area[loc][i] == -1) {\r\nLASSERT(loc != RCL_SERVER);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn i;\r\n}\r\nint req_capsule_server_pack(struct req_capsule *pill)\r\n{\r\nconst struct req_format *fmt;\r\nint count;\r\nint rc;\r\nLASSERT(pill->rc_loc == RCL_SERVER);\r\nfmt = pill->rc_fmt;\r\nLASSERT(fmt != NULL);\r\ncount = req_capsule_filled_sizes(pill, RCL_SERVER);\r\nrc = lustre_pack_reply(pill->rc_req, count,\r\npill->rc_area[RCL_SERVER], NULL);\r\nif (rc != 0) {\r\nDEBUG_REQ(D_ERROR, pill->rc_req,\r\n"Cannot pack %d fields in format `%s': ",\r\ncount, fmt->rf_name);\r\n}\r\nreturn rc;\r\n}\r\nstatic int __req_capsule_offset(const struct req_capsule *pill,\r\nconst struct req_msg_field *field,\r\nenum req_location loc)\r\n{\r\nint offset;\r\noffset = field->rmf_offset[pill->rc_fmt->rf_idx][loc];\r\nLASSERTF(offset > 0, "%s:%s, off=%d, loc=%d\n",\r\npill->rc_fmt->rf_name,\r\nfield->rmf_name, offset, loc);\r\noffset --;\r\nLASSERT(0 <= offset && offset < REQ_MAX_FIELD_NR);\r\nreturn offset;\r\n}\r\nstatic\r\nvoid\r\nswabber_dumper_helper(struct req_capsule *pill,\r\nconst struct req_msg_field *field,\r\nenum req_location loc,\r\nint offset,\r\nvoid *value, int len, int dump, void (*swabber)( void *))\r\n{\r\nvoid *p;\r\nint i;\r\nint n;\r\nint do_swab;\r\nint inout = loc == RCL_CLIENT;\r\nswabber = swabber ?: field->rmf_swabber;\r\nif (ptlrpc_buf_need_swab(pill->rc_req, inout, offset) &&\r\nswabber != NULL && value != NULL)\r\ndo_swab = 1;\r\nelse\r\ndo_swab = 0;\r\nif (!(field->rmf_flags & RMF_F_STRUCT_ARRAY)) {\r\nif (dump && field->rmf_dumper) {\r\nCDEBUG(D_RPCTRACE, "Dump of %sfield %s follows\n",\r\ndo_swab ? "unswabbed " : "", field->rmf_name);\r\nfield->rmf_dumper(value);\r\n}\r\nif (!do_swab)\r\nreturn;\r\nswabber(value);\r\nptlrpc_buf_set_swabbed(pill->rc_req, inout, offset);\r\nif (dump) {\r\nCDEBUG(D_RPCTRACE, "Dump of swabbed field %s "\r\n"follows\n", field->rmf_name);\r\nfield->rmf_dumper(value);\r\n}\r\nreturn;\r\n}\r\nLASSERT((len % field->rmf_size) == 0);\r\nfor (p = value, i = 0, n = len / field->rmf_size;\r\ni < n;\r\ni++, p += field->rmf_size) {\r\nif (dump && field->rmf_dumper) {\r\nCDEBUG(D_RPCTRACE, "Dump of %sarray field %s, "\r\n"element %d follows\n",\r\ndo_swab ? "unswabbed " : "", field->rmf_name, i);\r\nfield->rmf_dumper(p);\r\n}\r\nif (!do_swab)\r\ncontinue;\r\nswabber(p);\r\nif (dump && field->rmf_dumper) {\r\nCDEBUG(D_RPCTRACE, "Dump of swabbed array field %s, "\r\n"element %d follows\n", field->rmf_name, i);\r\nfield->rmf_dumper(value);\r\n}\r\n}\r\nif (do_swab)\r\nptlrpc_buf_set_swabbed(pill->rc_req, inout, offset);\r\n}\r\nstatic void *__req_capsule_get(struct req_capsule *pill,\r\nconst struct req_msg_field *field,\r\nenum req_location loc,\r\nvoid (*swabber)( void *),\r\nint dump)\r\n{\r\nconst struct req_format *fmt;\r\nstruct lustre_msg *msg;\r\nvoid *value;\r\nint len;\r\nint offset;\r\nvoid *(*getter)(struct lustre_msg *m, int n, int minlen);\r\nstatic const char *rcl_names[RCL_NR] = {\r\n[RCL_CLIENT] = "client",\r\n[RCL_SERVER] = "server"\r\n};\r\nLASSERT(pill != NULL);\r\nLASSERT(pill != LP_POISON);\r\nfmt = pill->rc_fmt;\r\nLASSERT(fmt != NULL);\r\nLASSERT(fmt != LP_POISON);\r\nLASSERT(__req_format_is_sane(fmt));\r\noffset = __req_capsule_offset(pill, field, loc);\r\nmsg = __req_msg(pill, loc);\r\nLASSERT(msg != NULL);\r\ngetter = (field->rmf_flags & RMF_F_STRING) ?\r\n(typeof(getter))lustre_msg_string : lustre_msg_buf;\r\nif (field->rmf_flags & RMF_F_STRUCT_ARRAY) {\r\nlen = lustre_msg_buflen(msg, offset);\r\nif ((len % field->rmf_size) != 0) {\r\nCERROR("%s: array field size mismatch "\r\n"%d modulo %d != 0 (%d)\n",\r\nfield->rmf_name, len, field->rmf_size, loc);\r\nreturn NULL;\r\n}\r\n} else if (pill->rc_area[loc][offset] != -1) {\r\nlen = pill->rc_area[loc][offset];\r\n} else {\r\nlen = max(field->rmf_size, 0);\r\n}\r\nvalue = getter(msg, offset, len);\r\nif (value == NULL) {\r\nDEBUG_REQ(D_ERROR, pill->rc_req,\r\n"Wrong buffer for field `%s' (%d of %d) "\r\n"in format `%s': %d vs. %d (%s)\n",\r\nfield->rmf_name, offset, lustre_msg_bufcount(msg),\r\nfmt->rf_name, lustre_msg_buflen(msg, offset), len,\r\nrcl_names[loc]);\r\n} else {\r\nswabber_dumper_helper(pill, field, loc, offset, value, len,\r\ndump, swabber);\r\n}\r\nreturn value;\r\n}\r\nvoid __req_capsule_dump(struct req_capsule *pill, enum req_location loc)\r\n{\r\nconst struct req_format *fmt;\r\nconst struct req_msg_field *field;\r\nint len;\r\nint i;\r\nfmt = pill->rc_fmt;\r\nDEBUG_REQ(D_RPCTRACE, pill->rc_req, "BEGIN REQ CAPSULE DUMP\n");\r\nfor (i = 0; i < fmt->rf_fields[loc].nr; ++i) {\r\nfield = FMT_FIELD(fmt, loc, i);\r\nif (field->rmf_dumper == NULL) {\r\nlen = req_capsule_get_size(pill, field, loc);\r\nCDEBUG(D_RPCTRACE, "Field %s has no dumper function;"\r\n"field size is %d\n", field->rmf_name, len);\r\n} else {\r\n(void) __req_capsule_get(pill, field, loc, NULL, 1);\r\n}\r\n}\r\nCDEBUG(D_RPCTRACE, "END REQ CAPSULE DUMP\n");\r\n}\r\nvoid req_capsule_client_dump(struct req_capsule *pill)\r\n{\r\n__req_capsule_dump(pill, RCL_CLIENT);\r\n}\r\nvoid req_capsule_server_dump(struct req_capsule *pill)\r\n{\r\n__req_capsule_dump(pill, RCL_SERVER);\r\n}\r\nvoid *req_capsule_client_get(struct req_capsule *pill,\r\nconst struct req_msg_field *field)\r\n{\r\nreturn __req_capsule_get(pill, field, RCL_CLIENT, NULL, 0);\r\n}\r\nvoid *req_capsule_client_swab_get(struct req_capsule *pill,\r\nconst struct req_msg_field *field,\r\nvoid *swabber)\r\n{\r\nreturn __req_capsule_get(pill, field, RCL_CLIENT, swabber, 0);\r\n}\r\nvoid *req_capsule_client_sized_get(struct req_capsule *pill,\r\nconst struct req_msg_field *field,\r\nint len)\r\n{\r\nreq_capsule_set_size(pill, field, RCL_CLIENT, len);\r\nreturn __req_capsule_get(pill, field, RCL_CLIENT, NULL, 0);\r\n}\r\nvoid *req_capsule_server_get(struct req_capsule *pill,\r\nconst struct req_msg_field *field)\r\n{\r\nreturn __req_capsule_get(pill, field, RCL_SERVER, NULL, 0);\r\n}\r\nvoid *req_capsule_server_swab_get(struct req_capsule *pill,\r\nconst struct req_msg_field *field,\r\nvoid *swabber)\r\n{\r\nreturn __req_capsule_get(pill, field, RCL_SERVER, swabber, 0);\r\n}\r\nvoid *req_capsule_server_sized_get(struct req_capsule *pill,\r\nconst struct req_msg_field *field,\r\nint len)\r\n{\r\nreq_capsule_set_size(pill, field, RCL_SERVER, len);\r\nreturn __req_capsule_get(pill, field, RCL_SERVER, NULL, 0);\r\n}\r\nvoid *req_capsule_server_sized_swab_get(struct req_capsule *pill,\r\nconst struct req_msg_field *field,\r\nint len, void *swabber)\r\n{\r\nreq_capsule_set_size(pill, field, RCL_SERVER, len);\r\nreturn __req_capsule_get(pill, field, RCL_SERVER, swabber, 0);\r\n}\r\nconst void *req_capsule_other_get(struct req_capsule *pill,\r\nconst struct req_msg_field *field)\r\n{\r\nreturn __req_capsule_get(pill, field, pill->rc_loc ^ 1, NULL, 0);\r\n}\r\nvoid req_capsule_set_size(struct req_capsule *pill,\r\nconst struct req_msg_field *field,\r\nenum req_location loc, int size)\r\n{\r\nLASSERT(loc == RCL_SERVER || loc == RCL_CLIENT);\r\nif ((size != field->rmf_size) &&\r\n(field->rmf_size != -1) &&\r\n!(field->rmf_flags & RMF_F_NO_SIZE_CHECK) &&\r\n(size > 0)) {\r\nif ((field->rmf_flags & RMF_F_STRUCT_ARRAY) &&\r\n(size % field->rmf_size != 0)) {\r\nCERROR("%s: array field size mismatch "\r\n"%d %% %d != 0 (%d)\n",\r\nfield->rmf_name, size, field->rmf_size, loc);\r\nLBUG();\r\n} else if (!(field->rmf_flags & RMF_F_STRUCT_ARRAY) &&\r\nsize < field->rmf_size) {\r\nCERROR("%s: field size mismatch %d != %d (%d)\n",\r\nfield->rmf_name, size, field->rmf_size, loc);\r\nLBUG();\r\n}\r\n}\r\npill->rc_area[loc][__req_capsule_offset(pill, field, loc)] = size;\r\n}\r\nint req_capsule_get_size(const struct req_capsule *pill,\r\nconst struct req_msg_field *field,\r\nenum req_location loc)\r\n{\r\nLASSERT(loc == RCL_SERVER || loc == RCL_CLIENT);\r\nreturn lustre_msg_buflen(__req_msg(pill, loc),\r\n__req_capsule_offset(pill, field, loc));\r\n}\r\nint req_capsule_msg_size(struct req_capsule *pill, enum req_location loc)\r\n{\r\nreturn lustre_msg_size(pill->rc_req->rq_import->imp_msg_magic,\r\npill->rc_fmt->rf_fields[loc].nr,\r\npill->rc_area[loc]);\r\n}\r\nint req_capsule_fmt_size(__u32 magic, const struct req_format *fmt,\r\nenum req_location loc)\r\n{\r\nint size, i = 0;\r\nsize = lustre_msg_hdr_size(magic, fmt->rf_fields[loc].nr);\r\nif (size < 0)\r\nreturn size;\r\nfor (; i < fmt->rf_fields[loc].nr; ++i)\r\nif (fmt->rf_fields[loc].d[i]->rmf_size != -1)\r\nsize += cfs_size_round(fmt->rf_fields[loc].d[i]->\r\nrmf_size);\r\nreturn size;\r\n}\r\nvoid req_capsule_extend(struct req_capsule *pill, const struct req_format *fmt)\r\n{\r\nint i;\r\nint j;\r\nconst struct req_format *old;\r\nLASSERT(pill->rc_fmt != NULL);\r\nLASSERT(__req_format_is_sane(fmt));\r\nold = pill->rc_fmt;\r\nfor (i = 0; i < RCL_NR; ++i) {\r\nLASSERT(fmt->rf_fields[i].nr >= old->rf_fields[i].nr);\r\nfor (j = 0; j < old->rf_fields[i].nr - 1; ++j) {\r\nconst struct req_msg_field *ofield = FMT_FIELD(old, i, j);\r\nif (ofield->rmf_swabber == NULL &&\r\n(ofield->rmf_flags & ~RMF_F_NO_SIZE_CHECK) == 0 &&\r\n(ofield->rmf_size == -1 ||\r\nofield->rmf_flags == RMF_F_NO_SIZE_CHECK))\r\ncontinue;\r\nLASSERT(FMT_FIELD(fmt, i, j) == FMT_FIELD(old, i, j));\r\n}\r\nLASSERT(FMT_FIELD(fmt, i, j)->rmf_size >=\r\nFMT_FIELD(old, i, j)->rmf_size);\r\n}\r\npill->rc_fmt = fmt;\r\n}\r\nint req_capsule_has_field(const struct req_capsule *pill,\r\nconst struct req_msg_field *field,\r\nenum req_location loc)\r\n{\r\nLASSERT(loc == RCL_SERVER || loc == RCL_CLIENT);\r\nreturn field->rmf_offset[pill->rc_fmt->rf_idx][loc];\r\n}\r\nint req_capsule_field_present(const struct req_capsule *pill,\r\nconst struct req_msg_field *field,\r\nenum req_location loc)\r\n{\r\nint offset;\r\nLASSERT(loc == RCL_SERVER || loc == RCL_CLIENT);\r\nLASSERT(req_capsule_has_field(pill, field, loc));\r\noffset = __req_capsule_offset(pill, field, loc);\r\nreturn lustre_msg_bufcount(__req_msg(pill, loc)) > offset;\r\n}\r\nvoid req_capsule_shrink(struct req_capsule *pill,\r\nconst struct req_msg_field *field,\r\nunsigned int newlen,\r\nenum req_location loc)\r\n{\r\nconst struct req_format *fmt;\r\nstruct lustre_msg *msg;\r\nint len;\r\nint offset;\r\nfmt = pill->rc_fmt;\r\nLASSERT(fmt != NULL);\r\nLASSERT(__req_format_is_sane(fmt));\r\nLASSERT(req_capsule_has_field(pill, field, loc));\r\nLASSERT(req_capsule_field_present(pill, field, loc));\r\noffset = __req_capsule_offset(pill, field, loc);\r\nmsg = __req_msg(pill, loc);\r\nlen = lustre_msg_buflen(msg, offset);\r\nLASSERTF(newlen <= len, "%s:%s, oldlen=%d, newlen=%d\n",\r\nfmt->rf_name, field->rmf_name, len, newlen);\r\nif (loc == RCL_CLIENT)\r\npill->rc_req->rq_reqlen = lustre_shrink_msg(msg, offset, newlen,\r\n1);\r\nelse\r\npill->rc_req->rq_replen = lustre_shrink_msg(msg, offset, newlen,\r\n1);\r\n}\r\nint req_capsule_server_grow(struct req_capsule *pill,\r\nconst struct req_msg_field *field,\r\nunsigned int newlen)\r\n{\r\nstruct ptlrpc_reply_state *rs = pill->rc_req->rq_reply_state, *nrs;\r\nchar *from, *to;\r\nint offset, len, rc;\r\nLASSERT(pill->rc_fmt != NULL);\r\nLASSERT(__req_format_is_sane(pill->rc_fmt));\r\nLASSERT(req_capsule_has_field(pill, field, RCL_SERVER));\r\nLASSERT(req_capsule_field_present(pill, field, RCL_SERVER));\r\nlen = req_capsule_get_size(pill, field, RCL_SERVER);\r\noffset = __req_capsule_offset(pill, field, RCL_SERVER);\r\nif (pill->rc_req->rq_repbuf_len >=\r\nlustre_packed_msg_size(pill->rc_req->rq_repmsg) - len + newlen)\r\nCERROR("Inplace repack might be done\n");\r\npill->rc_req->rq_reply_state = NULL;\r\nreq_capsule_set_size(pill, field, RCL_SERVER, newlen);\r\nrc = req_capsule_server_pack(pill);\r\nif (rc) {\r\npill->rc_req->rq_reply_state = rs;\r\nreturn rc;\r\n}\r\nnrs = pill->rc_req->rq_reply_state;\r\nto = lustre_msg_buf(nrs->rs_msg, 0, 0);\r\nfrom = lustre_msg_buf(rs->rs_msg, 0, 0);\r\nlen = (char *)lustre_msg_buf(rs->rs_msg, offset, 0) - from;\r\nmemcpy(to, from, len);\r\nif (rs->rs_msg->lm_bufcount > offset + 1) {\r\nto = lustre_msg_buf(nrs->rs_msg, offset + 1, 0);\r\nfrom = lustre_msg_buf(rs->rs_msg, offset + 1, 0);\r\noffset = rs->rs_msg->lm_bufcount - 1;\r\nlen = (char *)lustre_msg_buf(rs->rs_msg, offset, 0) +\r\ncfs_size_round(rs->rs_msg->lm_buflens[offset]) - from;\r\nmemcpy(to, from, len);\r\n}\r\nif (rs->rs_difficult) {\r\nint i;\r\nnrs->rs_difficult = 1;\r\nnrs->rs_no_ack = rs->rs_no_ack;\r\nfor (i = 0; i < rs->rs_nlocks; i++) {\r\nnrs->rs_locks[i] = rs->rs_locks[i];\r\nnrs->rs_modes[i] = rs->rs_modes[i];\r\nnrs->rs_nlocks++;\r\n}\r\nrs->rs_nlocks = 0;\r\nrs->rs_difficult = 0;\r\nrs->rs_no_ack = 0;\r\n}\r\nptlrpc_rs_decref(rs);\r\nreturn 0;\r\n}
