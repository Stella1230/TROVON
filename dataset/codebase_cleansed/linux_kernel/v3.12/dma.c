static void dbg_showchan(struct s3c2410_dma_chan *chan)\r\n{\r\npr_debug("DMA%d: %08x->%08x L %08x C %08x,%08x S %08x\n",\r\nchan->number,\r\nreadl(chan->regs + PL080_CH_SRC_ADDR),\r\nreadl(chan->regs + PL080_CH_DST_ADDR),\r\nreadl(chan->regs + PL080_CH_LLI),\r\nreadl(chan->regs + PL080_CH_CONTROL),\r\nreadl(chan->regs + PL080S_CH_CONTROL2),\r\nreadl(chan->regs + PL080S_CH_CONFIG));\r\n}\r\nstatic void show_lli(struct pl080s_lli *lli)\r\n{\r\npr_debug("LLI[%p] %08x->%08x, NL %08x C %08x,%08x\n",\r\nlli, lli->src_addr, lli->dst_addr, lli->next_lli,\r\nlli->control0, lli->control1);\r\n}\r\nstatic void dbg_showbuffs(struct s3c2410_dma_chan *chan)\r\n{\r\nstruct s3c64xx_dma_buff *ptr;\r\nstruct s3c64xx_dma_buff *end;\r\npr_debug("DMA%d: buffs next %p, curr %p, end %p\n",\r\nchan->number, chan->next, chan->curr, chan->end);\r\nptr = chan->next;\r\nend = chan->end;\r\nif (debug_show_buffs) {\r\nfor (; ptr != NULL; ptr = ptr->next) {\r\npr_debug("DMA%d: %08x ",\r\nchan->number, ptr->lli_dma);\r\nshow_lli(ptr->lli);\r\n}\r\n}\r\n}\r\nstatic struct s3c2410_dma_chan *s3c64xx_dma_map_channel(unsigned int channel)\r\n{\r\nstruct s3c2410_dma_chan *chan;\r\nunsigned int start, offs;\r\nstart = 0;\r\nif (channel >= DMACH_PCM1_TX)\r\nstart = 8;\r\nfor (offs = 0; offs < 8; offs++) {\r\nchan = &s3c2410_chans[start + offs];\r\nif (!chan->in_use)\r\ngoto found;\r\n}\r\nreturn NULL;\r\nfound:\r\ns3c_dma_chan_map[channel] = chan;\r\nreturn chan;\r\n}\r\nint s3c2410_dma_config(enum dma_ch channel, int xferunit)\r\n{\r\nstruct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);\r\nif (chan == NULL)\r\nreturn -EINVAL;\r\nswitch (xferunit) {\r\ncase 1:\r\nchan->hw_width = 0;\r\nbreak;\r\ncase 2:\r\nchan->hw_width = 1;\r\nbreak;\r\ncase 4:\r\nchan->hw_width = 2;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: illegal width %d\n", __func__, xferunit);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void s3c64xx_dma_fill_lli(struct s3c2410_dma_chan *chan,\r\nstruct pl080s_lli *lli,\r\ndma_addr_t data, int size)\r\n{\r\ndma_addr_t src, dst;\r\nu32 control0, control1;\r\nswitch (chan->source) {\r\ncase DMA_FROM_DEVICE:\r\nsrc = chan->dev_addr;\r\ndst = data;\r\ncontrol0 = PL080_CONTROL_SRC_AHB2;\r\ncontrol0 |= PL080_CONTROL_DST_INCR;\r\nbreak;\r\ncase DMA_TO_DEVICE:\r\nsrc = data;\r\ndst = chan->dev_addr;\r\ncontrol0 = PL080_CONTROL_DST_AHB2;\r\ncontrol0 |= PL080_CONTROL_SRC_INCR;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\ncontrol1 = size >> chan->hw_width;\r\ncontrol0 |= PL080_CONTROL_PROT_SYS;\r\ncontrol0 |= PL080_CONTROL_TC_IRQ_EN;\r\ncontrol0 |= (u32)chan->hw_width << PL080_CONTROL_DWIDTH_SHIFT;\r\ncontrol0 |= (u32)chan->hw_width << PL080_CONTROL_SWIDTH_SHIFT;\r\nlli->src_addr = src;\r\nlli->dst_addr = dst;\r\nlli->next_lli = 0;\r\nlli->control0 = control0;\r\nlli->control1 = control1;\r\n}\r\nstatic void s3c64xx_lli_to_regs(struct s3c2410_dma_chan *chan,\r\nstruct pl080s_lli *lli)\r\n{\r\nvoid __iomem *regs = chan->regs;\r\npr_debug("%s: LLI %p => regs\n", __func__, lli);\r\nshow_lli(lli);\r\nwritel(lli->src_addr, regs + PL080_CH_SRC_ADDR);\r\nwritel(lli->dst_addr, regs + PL080_CH_DST_ADDR);\r\nwritel(lli->next_lli, regs + PL080_CH_LLI);\r\nwritel(lli->control0, regs + PL080_CH_CONTROL);\r\nwritel(lli->control1, regs + PL080S_CH_CONTROL2);\r\n}\r\nstatic int s3c64xx_dma_start(struct s3c2410_dma_chan *chan)\r\n{\r\nstruct s3c64xx_dmac *dmac = chan->dmac;\r\nu32 config;\r\nu32 bit = chan->bit;\r\ndbg_showchan(chan);\r\npr_debug("%s: clearing interrupts\n", __func__);\r\nwritel(bit, dmac->regs + PL080_TC_CLEAR);\r\nwritel(bit, dmac->regs + PL080_ERR_CLEAR);\r\npr_debug("%s: starting channel\n", __func__);\r\nconfig = readl(chan->regs + PL080S_CH_CONFIG);\r\nconfig |= PL080_CONFIG_ENABLE;\r\nconfig &= ~PL080_CONFIG_HALT;\r\npr_debug("%s: writing config %08x\n", __func__, config);\r\nwritel(config, chan->regs + PL080S_CH_CONFIG);\r\nreturn 0;\r\n}\r\nstatic int s3c64xx_dma_stop(struct s3c2410_dma_chan *chan)\r\n{\r\nu32 config;\r\nint timeout;\r\npr_debug("%s: stopping channel\n", __func__);\r\ndbg_showchan(chan);\r\nconfig = readl(chan->regs + PL080S_CH_CONFIG);\r\nconfig |= PL080_CONFIG_HALT;\r\nwritel(config, chan->regs + PL080S_CH_CONFIG);\r\ntimeout = 1000;\r\ndo {\r\nconfig = readl(chan->regs + PL080S_CH_CONFIG);\r\npr_debug("%s: %d - config %08x\n", __func__, timeout, config);\r\nif (config & PL080_CONFIG_ACTIVE)\r\nudelay(10);\r\nelse\r\nbreak;\r\n} while (--timeout > 0);\r\nif (config & PL080_CONFIG_ACTIVE) {\r\nprintk(KERN_ERR "%s: channel still active\n", __func__);\r\nreturn -EFAULT;\r\n}\r\nconfig = readl(chan->regs + PL080S_CH_CONFIG);\r\nconfig &= ~PL080_CONFIG_ENABLE;\r\nwritel(config, chan->regs + PL080S_CH_CONFIG);\r\nreturn 0;\r\n}\r\nstatic inline void s3c64xx_dma_bufffdone(struct s3c2410_dma_chan *chan,\r\nstruct s3c64xx_dma_buff *buf,\r\nenum s3c2410_dma_buffresult result)\r\n{\r\nif (chan->callback_fn != NULL)\r\n(chan->callback_fn)(chan, buf->pw, 0, result);\r\n}\r\nstatic void s3c64xx_dma_freebuff(struct s3c64xx_dma_buff *buff)\r\n{\r\ndma_pool_free(dma_pool, buff->lli, buff->lli_dma);\r\nkfree(buff);\r\n}\r\nstatic int s3c64xx_dma_flush(struct s3c2410_dma_chan *chan)\r\n{\r\nstruct s3c64xx_dma_buff *buff, *next;\r\nu32 config;\r\ndbg_showchan(chan);\r\npr_debug("%s: flushing channel\n", __func__);\r\nconfig = readl(chan->regs + PL080S_CH_CONFIG);\r\nconfig &= ~PL080_CONFIG_ENABLE;\r\nwritel(config, chan->regs + PL080S_CH_CONFIG);\r\nfor (buff = chan->curr; buff != NULL; buff = next) {\r\nnext = buff->next;\r\npr_debug("%s: buff %p (next %p)\n", __func__, buff, buff->next);\r\ns3c64xx_dma_bufffdone(chan, buff, S3C2410_RES_ABORT);\r\ns3c64xx_dma_freebuff(buff);\r\n}\r\nchan->curr = chan->next = chan->end = NULL;\r\nreturn 0;\r\n}\r\nint s3c2410_dma_ctrl(enum dma_ch channel, enum s3c2410_chan_op op)\r\n{\r\nstruct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);\r\nWARN_ON(!chan);\r\nif (!chan)\r\nreturn -EINVAL;\r\nswitch (op) {\r\ncase S3C2410_DMAOP_START:\r\nreturn s3c64xx_dma_start(chan);\r\ncase S3C2410_DMAOP_STOP:\r\nreturn s3c64xx_dma_stop(chan);\r\ncase S3C2410_DMAOP_FLUSH:\r\nreturn s3c64xx_dma_flush(chan);\r\ncase S3C2410_DMAOP_PAUSE:\r\ncase S3C2410_DMAOP_RESUME:\r\ncase S3C2410_DMAOP_STARTED:\r\ncase S3C2410_DMAOP_TIMEOUT:\r\nreturn 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nint s3c2410_dma_enqueue(enum dma_ch channel, void *id,\r\ndma_addr_t data, int size)\r\n{\r\nstruct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);\r\nstruct s3c64xx_dma_buff *next;\r\nstruct s3c64xx_dma_buff *buff;\r\nstruct pl080s_lli *lli;\r\nunsigned long flags;\r\nint ret;\r\nWARN_ON(!chan);\r\nif (!chan)\r\nreturn -EINVAL;\r\nbuff = kzalloc(sizeof(struct s3c64xx_dma_buff), GFP_ATOMIC);\r\nif (!buff) {\r\nprintk(KERN_ERR "%s: no memory for buffer\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nlli = dma_pool_alloc(dma_pool, GFP_ATOMIC, &buff->lli_dma);\r\nif (!lli) {\r\nprintk(KERN_ERR "%s: no memory for lli\n", __func__);\r\nret = -ENOMEM;\r\ngoto err_buff;\r\n}\r\npr_debug("%s: buff %p, dp %08x lli (%p, %08x) %d\n",\r\n__func__, buff, data, lli, (u32)buff->lli_dma, size);\r\nbuff->lli = lli;\r\nbuff->pw = id;\r\ns3c64xx_dma_fill_lli(chan, lli, data, size);\r\nlocal_irq_save(flags);\r\nif ((next = chan->next) != NULL) {\r\nstruct s3c64xx_dma_buff *end = chan->end;\r\nstruct pl080s_lli *endlli = end->lli;\r\npr_debug("enquing onto channel\n");\r\nend->next = buff;\r\nendlli->next_lli = buff->lli_dma;\r\nif (chan->flags & S3C2410_DMAF_CIRCULAR) {\r\nstruct s3c64xx_dma_buff *curr = chan->curr;\r\nlli->next_lli = curr->lli_dma;\r\n}\r\nif (next == chan->curr) {\r\nwritel(buff->lli_dma, chan->regs + PL080_CH_LLI);\r\nchan->next = buff;\r\n}\r\nshow_lli(endlli);\r\nchan->end = buff;\r\n} else {\r\npr_debug("enquing onto empty channel\n");\r\nchan->curr = buff;\r\nchan->next = buff;\r\nchan->end = buff;\r\ns3c64xx_lli_to_regs(chan, lli);\r\n}\r\nlocal_irq_restore(flags);\r\nshow_lli(lli);\r\ndbg_showchan(chan);\r\ndbg_showbuffs(chan);\r\nreturn 0;\r\nerr_buff:\r\nkfree(buff);\r\nreturn ret;\r\n}\r\nint s3c2410_dma_devconfig(enum dma_ch channel,\r\nenum dma_data_direction source,\r\nunsigned long devaddr)\r\n{\r\nstruct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);\r\nu32 peripheral;\r\nu32 config = 0;\r\npr_debug("%s: channel %d, source %d, dev %08lx, chan %p\n",\r\n__func__, channel, source, devaddr, chan);\r\nWARN_ON(!chan);\r\nif (!chan)\r\nreturn -EINVAL;\r\nperipheral = (chan->peripheral & 0xf);\r\nchan->source = source;\r\nchan->dev_addr = devaddr;\r\npr_debug("%s: peripheral %d\n", __func__, peripheral);\r\nswitch (source) {\r\ncase DMA_FROM_DEVICE:\r\nconfig = 2 << PL080_CONFIG_FLOW_CONTROL_SHIFT;\r\nconfig |= peripheral << PL080_CONFIG_SRC_SEL_SHIFT;\r\nbreak;\r\ncase DMA_TO_DEVICE:\r\nconfig = 1 << PL080_CONFIG_FLOW_CONTROL_SHIFT;\r\nconfig |= peripheral << PL080_CONFIG_DST_SEL_SHIFT;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: bad source\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nconfig |= PL080_CONFIG_TC_IRQ_MASK;\r\nconfig |= PL080_CONFIG_ERR_IRQ_MASK;\r\npr_debug("%s: config %08x\n", __func__, config);\r\nwritel(config, chan->regs + PL080S_CH_CONFIG);\r\nreturn 0;\r\n}\r\nint s3c2410_dma_getposition(enum dma_ch channel,\r\ndma_addr_t *src, dma_addr_t *dst)\r\n{\r\nstruct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);\r\nWARN_ON(!chan);\r\nif (!chan)\r\nreturn -EINVAL;\r\nif (src != NULL)\r\n*src = readl(chan->regs + PL080_CH_SRC_ADDR);\r\nif (dst != NULL)\r\n*dst = readl(chan->regs + PL080_CH_DST_ADDR);\r\nreturn 0;\r\n}\r\nint s3c2410_dma_request(enum dma_ch channel,\r\nstruct s3c2410_dma_client *client,\r\nvoid *dev)\r\n{\r\nstruct s3c2410_dma_chan *chan;\r\nunsigned long flags;\r\npr_debug("dma%d: s3c2410_request_dma: client=%s, dev=%p\n",\r\nchannel, client->name, dev);\r\nlocal_irq_save(flags);\r\nchan = s3c64xx_dma_map_channel(channel);\r\nif (chan == NULL) {\r\nlocal_irq_restore(flags);\r\nreturn -EBUSY;\r\n}\r\ndbg_showchan(chan);\r\nchan->client = client;\r\nchan->in_use = 1;\r\nchan->peripheral = channel;\r\nchan->flags = 0;\r\nlocal_irq_restore(flags);\r\npr_debug("%s: channel initialised, %p\n", __func__, chan);\r\nreturn chan->number | DMACH_LOW_LEVEL;\r\n}\r\nint s3c2410_dma_free(enum dma_ch channel, struct s3c2410_dma_client *client)\r\n{\r\nstruct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);\r\nunsigned long flags;\r\nif (chan == NULL)\r\nreturn -EINVAL;\r\nlocal_irq_save(flags);\r\nif (chan->client != client) {\r\nprintk(KERN_WARNING "dma%d: possible free from different client (channel %p, passed %p)\n",\r\nchannel, chan->client, client);\r\n}\r\nchan->client = NULL;\r\nchan->in_use = 0;\r\nif (!(channel & DMACH_LOW_LEVEL))\r\ns3c_dma_chan_map[channel] = NULL;\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t s3c64xx_dma_irq(int irq, void *pw)\r\n{\r\nstruct s3c64xx_dmac *dmac = pw;\r\nstruct s3c2410_dma_chan *chan;\r\nenum s3c2410_dma_buffresult res;\r\nu32 tcstat, errstat;\r\nu32 bit;\r\nint offs;\r\ntcstat = readl(dmac->regs + PL080_TC_STATUS);\r\nerrstat = readl(dmac->regs + PL080_ERR_STATUS);\r\nfor (offs = 0, bit = 1; offs < 8; offs++, bit <<= 1) {\r\nstruct s3c64xx_dma_buff *buff;\r\nif (!(errstat & bit) && !(tcstat & bit))\r\ncontinue;\r\nchan = dmac->channels + offs;\r\nres = S3C2410_RES_ERR;\r\nif (tcstat & bit) {\r\nwritel(bit, dmac->regs + PL080_TC_CLEAR);\r\nres = S3C2410_RES_OK;\r\n}\r\nif (errstat & bit)\r\nwritel(bit, dmac->regs + PL080_ERR_CLEAR);\r\nbuff = chan->curr;\r\nwhile (buff && buff != chan->next\r\n&& buff->next != chan->next)\r\nbuff = buff->next;\r\nif (!buff)\r\nBUG();\r\nif (buff == chan->next)\r\nbuff = chan->end;\r\ns3c64xx_dma_bufffdone(chan, buff, res);\r\nif (!(chan->flags & S3C2410_DMAF_CIRCULAR)) {\r\nchan->curr = buff->next;\r\ns3c64xx_dma_freebuff(buff);\r\n}\r\nbuff = chan->next;\r\nif (chan->next == chan->end) {\r\nchan->next = chan->curr;\r\nif (!(chan->flags & S3C2410_DMAF_CIRCULAR))\r\nchan->end = NULL;\r\n} else {\r\nchan->next = buff->next;\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s3c64xx_dma_init1(int chno, enum dma_ch chbase,\r\nint irq, unsigned int base)\r\n{\r\nstruct s3c2410_dma_chan *chptr = &s3c2410_chans[chno];\r\nstruct s3c64xx_dmac *dmac;\r\nchar clkname[16];\r\nvoid __iomem *regs;\r\nvoid __iomem *regptr;\r\nint err, ch;\r\ndmac = kzalloc(sizeof(struct s3c64xx_dmac), GFP_KERNEL);\r\nif (!dmac) {\r\nprintk(KERN_ERR "%s: failed to alloc mem\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\ndmac->dev.id = chno / 8;\r\ndmac->dev.bus = &dma_subsys;\r\nerr = device_register(&dmac->dev);\r\nif (err) {\r\nprintk(KERN_ERR "%s: failed to register device\n", __func__);\r\ngoto err_alloc;\r\n}\r\nregs = ioremap(base, 0x200);\r\nif (!regs) {\r\nprintk(KERN_ERR "%s: failed to ioremap()\n", __func__);\r\nerr = -ENXIO;\r\ngoto err_dev;\r\n}\r\nsnprintf(clkname, sizeof(clkname), "dma%d", dmac->dev.id);\r\ndmac->clk = clk_get(NULL, clkname);\r\nif (IS_ERR(dmac->clk)) {\r\nprintk(KERN_ERR "%s: failed to get clock %s\n", __func__, clkname);\r\nerr = PTR_ERR(dmac->clk);\r\ngoto err_map;\r\n}\r\nclk_enable(dmac->clk);\r\ndmac->regs = regs;\r\ndmac->chanbase = chbase;\r\ndmac->channels = chptr;\r\nerr = request_irq(irq, s3c64xx_dma_irq, 0, "DMA", dmac);\r\nif (err < 0) {\r\nprintk(KERN_ERR "%s: failed to get irq\n", __func__);\r\ngoto err_clk;\r\n}\r\nregptr = regs + PL080_Cx_BASE(0);\r\nfor (ch = 0; ch < 8; ch++, chptr++) {\r\npr_debug("%s: registering DMA %d (%p)\n",\r\n__func__, chno + ch, regptr);\r\nchptr->bit = 1 << ch;\r\nchptr->number = chno + ch;\r\nchptr->dmac = dmac;\r\nchptr->regs = regptr;\r\nregptr += PL080_Cx_STRIDE;\r\n}\r\nwritel(PL080_CONFIG_ENABLE, regs + PL080_CONFIG);\r\nprintk(KERN_INFO "PL080: IRQ %d, at %p, channels %d..%d\n",\r\nirq, regs, chno, chno+8);\r\nreturn 0;\r\nerr_clk:\r\nclk_disable(dmac->clk);\r\nclk_put(dmac->clk);\r\nerr_map:\r\niounmap(regs);\r\nerr_dev:\r\ndevice_unregister(&dmac->dev);\r\nerr_alloc:\r\nkfree(dmac);\r\nreturn err;\r\n}\r\nstatic int __init s3c64xx_dma_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "%s: Registering DMA channels\n", __func__);\r\ndma_pool = dma_pool_create("DMA-LLI", NULL, sizeof(struct pl080s_lli), 16, 0);\r\nif (!dma_pool) {\r\nprintk(KERN_ERR "%s: failed to create pool\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nret = subsys_system_register(&dma_subsys, NULL);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: failed to create subsys\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nwritel(0xffffff, S3C64XX_SDMA_SEL);\r\ns3c64xx_dma_init1(0, DMACH_UART0, IRQ_DMA0, 0x75000000);\r\ns3c64xx_dma_init1(8, DMACH_PCM1_TX, IRQ_DMA1, 0x75100000);\r\nreturn 0;\r\n}
