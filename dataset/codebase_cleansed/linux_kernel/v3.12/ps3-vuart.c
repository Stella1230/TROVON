static struct ps3_vuart_port_priv *to_port_priv(\r\nstruct ps3_system_bus_device *dev)\r\n{\r\nBUG_ON(!dev);\r\nBUG_ON(!dev->driver_priv);\r\nreturn (struct ps3_vuart_port_priv *)dev->driver_priv;\r\n}\r\nstatic void __maybe_unused _dump_ports_bmp(\r\nconst struct ports_bmp *bmp, const char *func, int line)\r\n{\r\npr_debug("%s:%d: ports_bmp: %016llxh\n", func, line, bmp->status);\r\n}\r\nstatic void __maybe_unused _dump_port_params(unsigned int port_number,\r\nconst char *func, int line)\r\n{\r\n#if defined(DEBUG)\r\nstatic const char *strings[] = {\r\n"tx_trigger ",\r\n"rx_trigger ",\r\n"interrupt_mask ",\r\n"rx_buf_size ",\r\n"rx_bytes ",\r\n"tx_buf_size ",\r\n"tx_bytes ",\r\n"interrupt_status",\r\n};\r\nint result;\r\nunsigned int i;\r\nu64 value;\r\nfor (i = 0; i < ARRAY_SIZE(strings); i++) {\r\nresult = lv1_get_virtual_uart_param(port_number, i, &value);\r\nif (result) {\r\npr_debug("%s:%d: port_%u: %s failed: %s\n", func, line,\r\nport_number, strings[i], ps3_result(result));\r\ncontinue;\r\n}\r\npr_debug("%s:%d: port_%u: %s = %lxh\n",\r\nfunc, line, port_number, strings[i], value);\r\n}\r\n#endif\r\n}\r\nint ps3_vuart_get_triggers(struct ps3_system_bus_device *dev,\r\nstruct vuart_triggers *trig)\r\n{\r\nint result;\r\nu64 size;\r\nu64 val;\r\nu64 tx;\r\nresult = lv1_get_virtual_uart_param(dev->port_number,\r\nPARAM_TX_TRIGGER, &tx);\r\ntrig->tx = tx;\r\nif (result) {\r\ndev_dbg(&dev->core, "%s:%d: tx_trigger failed: %s\n",\r\n__func__, __LINE__, ps3_result(result));\r\nreturn result;\r\n}\r\nresult = lv1_get_virtual_uart_param(dev->port_number,\r\nPARAM_RX_BUF_SIZE, &size);\r\nif (result) {\r\ndev_dbg(&dev->core, "%s:%d: tx_buf_size failed: %s\n",\r\n__func__, __LINE__, ps3_result(result));\r\nreturn result;\r\n}\r\nresult = lv1_get_virtual_uart_param(dev->port_number,\r\nPARAM_RX_TRIGGER, &val);\r\nif (result) {\r\ndev_dbg(&dev->core, "%s:%d: rx_trigger failed: %s\n",\r\n__func__, __LINE__, ps3_result(result));\r\nreturn result;\r\n}\r\ntrig->rx = size - val;\r\ndev_dbg(&dev->core, "%s:%d: tx %lxh, rx %lxh\n", __func__, __LINE__,\r\ntrig->tx, trig->rx);\r\nreturn result;\r\n}\r\nint ps3_vuart_set_triggers(struct ps3_system_bus_device *dev, unsigned int tx,\r\nunsigned int rx)\r\n{\r\nint result;\r\nu64 size;\r\nresult = lv1_set_virtual_uart_param(dev->port_number,\r\nPARAM_TX_TRIGGER, tx);\r\nif (result) {\r\ndev_dbg(&dev->core, "%s:%d: tx_trigger failed: %s\n",\r\n__func__, __LINE__, ps3_result(result));\r\nreturn result;\r\n}\r\nresult = lv1_get_virtual_uart_param(dev->port_number,\r\nPARAM_RX_BUF_SIZE, &size);\r\nif (result) {\r\ndev_dbg(&dev->core, "%s:%d: tx_buf_size failed: %s\n",\r\n__func__, __LINE__, ps3_result(result));\r\nreturn result;\r\n}\r\nresult = lv1_set_virtual_uart_param(dev->port_number,\r\nPARAM_RX_TRIGGER, size - rx);\r\nif (result) {\r\ndev_dbg(&dev->core, "%s:%d: rx_trigger failed: %s\n",\r\n__func__, __LINE__, ps3_result(result));\r\nreturn result;\r\n}\r\ndev_dbg(&dev->core, "%s:%d: tx %xh, rx %xh\n", __func__, __LINE__,\r\ntx, rx);\r\nreturn result;\r\n}\r\nstatic int ps3_vuart_get_rx_bytes_waiting(struct ps3_system_bus_device *dev,\r\nu64 *bytes_waiting)\r\n{\r\nint result;\r\nresult = lv1_get_virtual_uart_param(dev->port_number,\r\nPARAM_RX_BYTES, bytes_waiting);\r\nif (result)\r\ndev_dbg(&dev->core, "%s:%d: rx_bytes failed: %s\n",\r\n__func__, __LINE__, ps3_result(result));\r\ndev_dbg(&dev->core, "%s:%d: %llxh\n", __func__, __LINE__,\r\n*bytes_waiting);\r\nreturn result;\r\n}\r\nstatic int ps3_vuart_set_interrupt_mask(struct ps3_system_bus_device *dev,\r\nunsigned long mask)\r\n{\r\nint result;\r\nstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\r\ndev_dbg(&dev->core, "%s:%d: %lxh\n", __func__, __LINE__, mask);\r\npriv->interrupt_mask = mask;\r\nresult = lv1_set_virtual_uart_param(dev->port_number,\r\nPARAM_INTERRUPT_MASK, priv->interrupt_mask);\r\nif (result)\r\ndev_dbg(&dev->core, "%s:%d: interrupt_mask failed: %s\n",\r\n__func__, __LINE__, ps3_result(result));\r\nreturn result;\r\n}\r\nstatic int ps3_vuart_get_interrupt_status(struct ps3_system_bus_device *dev,\r\nunsigned long *status)\r\n{\r\nint result;\r\nstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\r\nu64 tmp;\r\nresult = lv1_get_virtual_uart_param(dev->port_number,\r\nPARAM_INTERRUPT_STATUS, &tmp);\r\nif (result)\r\ndev_dbg(&dev->core, "%s:%d: interrupt_status failed: %s\n",\r\n__func__, __LINE__, ps3_result(result));\r\n*status = tmp & priv->interrupt_mask;\r\ndev_dbg(&dev->core, "%s:%d: m %llxh, s %llxh, m&s %lxh\n",\r\n__func__, __LINE__, priv->interrupt_mask, tmp, *status);\r\nreturn result;\r\n}\r\nint ps3_vuart_enable_interrupt_tx(struct ps3_system_bus_device *dev)\r\n{\r\nstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\r\nreturn (priv->interrupt_mask & INTERRUPT_MASK_TX) ? 0\r\n: ps3_vuart_set_interrupt_mask(dev, priv->interrupt_mask\r\n| INTERRUPT_MASK_TX);\r\n}\r\nint ps3_vuart_enable_interrupt_rx(struct ps3_system_bus_device *dev)\r\n{\r\nstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\r\nreturn (priv->interrupt_mask & INTERRUPT_MASK_RX) ? 0\r\n: ps3_vuart_set_interrupt_mask(dev, priv->interrupt_mask\r\n| INTERRUPT_MASK_RX);\r\n}\r\nint ps3_vuart_enable_interrupt_disconnect(struct ps3_system_bus_device *dev)\r\n{\r\nstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\r\nreturn (priv->interrupt_mask & INTERRUPT_MASK_DISCONNECT) ? 0\r\n: ps3_vuart_set_interrupt_mask(dev, priv->interrupt_mask\r\n| INTERRUPT_MASK_DISCONNECT);\r\n}\r\nint ps3_vuart_disable_interrupt_tx(struct ps3_system_bus_device *dev)\r\n{\r\nstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\r\nreturn (priv->interrupt_mask & INTERRUPT_MASK_TX)\r\n? ps3_vuart_set_interrupt_mask(dev, priv->interrupt_mask\r\n& ~INTERRUPT_MASK_TX) : 0;\r\n}\r\nint ps3_vuart_disable_interrupt_rx(struct ps3_system_bus_device *dev)\r\n{\r\nstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\r\nreturn (priv->interrupt_mask & INTERRUPT_MASK_RX)\r\n? ps3_vuart_set_interrupt_mask(dev, priv->interrupt_mask\r\n& ~INTERRUPT_MASK_RX) : 0;\r\n}\r\nint ps3_vuart_disable_interrupt_disconnect(struct ps3_system_bus_device *dev)\r\n{\r\nstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\r\nreturn (priv->interrupt_mask & INTERRUPT_MASK_DISCONNECT)\r\n? ps3_vuart_set_interrupt_mask(dev, priv->interrupt_mask\r\n& ~INTERRUPT_MASK_DISCONNECT) : 0;\r\n}\r\nstatic int ps3_vuart_raw_write(struct ps3_system_bus_device *dev,\r\nconst void *buf, unsigned int bytes, u64 *bytes_written)\r\n{\r\nint result;\r\nstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\r\nresult = lv1_write_virtual_uart(dev->port_number,\r\nps3_mm_phys_to_lpar(__pa(buf)), bytes, bytes_written);\r\nif (result) {\r\ndev_dbg(&dev->core, "%s:%d: lv1_write_virtual_uart failed: "\r\n"%s\n", __func__, __LINE__, ps3_result(result));\r\nreturn result;\r\n}\r\npriv->stats.bytes_written += *bytes_written;\r\ndev_dbg(&dev->core, "%s:%d: wrote %llxh/%xh=>%lxh\n", __func__, __LINE__,\r\n*bytes_written, bytes, priv->stats.bytes_written);\r\nreturn result;\r\n}\r\nstatic int ps3_vuart_raw_read(struct ps3_system_bus_device *dev, void *buf,\r\nunsigned int bytes, u64 *bytes_read)\r\n{\r\nint result;\r\nstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\r\ndev_dbg(&dev->core, "%s:%d: %xh\n", __func__, __LINE__, bytes);\r\nresult = lv1_read_virtual_uart(dev->port_number,\r\nps3_mm_phys_to_lpar(__pa(buf)), bytes, bytes_read);\r\nif (result) {\r\ndev_dbg(&dev->core, "%s:%d: lv1_read_virtual_uart failed: %s\n",\r\n__func__, __LINE__, ps3_result(result));\r\nreturn result;\r\n}\r\npriv->stats.bytes_read += *bytes_read;\r\ndev_dbg(&dev->core, "%s:%d: read %llxh/%xh=>%lxh\n", __func__, __LINE__,\r\n*bytes_read, bytes, priv->stats.bytes_read);\r\nreturn result;\r\n}\r\nvoid ps3_vuart_clear_rx_bytes(struct ps3_system_bus_device *dev,\r\nunsigned int bytes)\r\n{\r\nint result;\r\nstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\r\nu64 bytes_waiting;\r\nvoid *tmp;\r\nresult = ps3_vuart_get_rx_bytes_waiting(dev, &bytes_waiting);\r\nBUG_ON(result);\r\nbytes = bytes ? min(bytes, (unsigned int)bytes_waiting) : bytes_waiting;\r\ndev_dbg(&dev->core, "%s:%d: %u\n", __func__, __LINE__, bytes);\r\nif (!bytes)\r\nreturn;\r\nbytes += 128;\r\ntmp = kmalloc(bytes, GFP_KERNEL);\r\nif (!tmp)\r\nreturn;\r\nps3_vuart_raw_read(dev, tmp, bytes, &bytes_waiting);\r\nkfree(tmp);\r\npriv->stats.bytes_read -= bytes_waiting;\r\n}\r\nint ps3_vuart_write(struct ps3_system_bus_device *dev, const void *buf,\r\nunsigned int bytes)\r\n{\r\nstatic unsigned long dbg_number;\r\nint result;\r\nstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\r\nunsigned long flags;\r\nstruct list_buffer *lb;\r\ndev_dbg(&dev->core, "%s:%d: %u(%xh) bytes\n", __func__, __LINE__,\r\nbytes, bytes);\r\nspin_lock_irqsave(&priv->tx_list.lock, flags);\r\nif (list_empty(&priv->tx_list.head)) {\r\nu64 bytes_written;\r\nresult = ps3_vuart_raw_write(dev, buf, bytes, &bytes_written);\r\nspin_unlock_irqrestore(&priv->tx_list.lock, flags);\r\nif (result) {\r\ndev_dbg(&dev->core,\r\n"%s:%d: ps3_vuart_raw_write failed\n",\r\n__func__, __LINE__);\r\nreturn result;\r\n}\r\nif (bytes_written == bytes) {\r\ndev_dbg(&dev->core, "%s:%d: wrote %xh bytes\n",\r\n__func__, __LINE__, bytes);\r\nreturn 0;\r\n}\r\nbytes -= bytes_written;\r\nbuf += bytes_written;\r\n} else\r\nspin_unlock_irqrestore(&priv->tx_list.lock, flags);\r\nlb = kmalloc(sizeof(struct list_buffer) + bytes, GFP_KERNEL);\r\nif (!lb)\r\nreturn -ENOMEM;\r\nmemcpy(lb->data, buf, bytes);\r\nlb->head = lb->data;\r\nlb->tail = lb->data + bytes;\r\nlb->dbg_number = ++dbg_number;\r\nspin_lock_irqsave(&priv->tx_list.lock, flags);\r\nlist_add_tail(&lb->link, &priv->tx_list.head);\r\nps3_vuart_enable_interrupt_tx(dev);\r\nspin_unlock_irqrestore(&priv->tx_list.lock, flags);\r\ndev_dbg(&dev->core, "%s:%d: queued buf_%lu, %xh bytes\n",\r\n__func__, __LINE__, lb->dbg_number, bytes);\r\nreturn 0;\r\n}\r\nstatic int ps3_vuart_queue_rx_bytes(struct ps3_system_bus_device *dev,\r\nu64 *bytes_queued)\r\n{\r\nstatic unsigned long dbg_number;\r\nint result;\r\nstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\r\nstruct list_buffer *lb;\r\nu64 bytes;\r\n*bytes_queued = 0;\r\nresult = ps3_vuart_get_rx_bytes_waiting(dev, &bytes);\r\nBUG_ON(result);\r\nif (result)\r\nreturn -EIO;\r\nif (!bytes)\r\nreturn 0;\r\nbytes += 128;\r\nlb = kmalloc(sizeof(struct list_buffer) + bytes, GFP_ATOMIC);\r\nif (!lb)\r\nreturn -ENOMEM;\r\nps3_vuart_raw_read(dev, lb->data, bytes, &bytes);\r\nlb->head = lb->data;\r\nlb->tail = lb->data + bytes;\r\nlb->dbg_number = ++dbg_number;\r\nlist_add_tail(&lb->link, &priv->rx_list.head);\r\npriv->rx_list.bytes_held += bytes;\r\ndev_dbg(&dev->core, "%s:%d: buf_%lu: queued %llxh bytes\n",\r\n__func__, __LINE__, lb->dbg_number, bytes);\r\n*bytes_queued = bytes;\r\nreturn 0;\r\n}\r\nint ps3_vuart_read(struct ps3_system_bus_device *dev, void *buf,\r\nunsigned int bytes)\r\n{\r\nint result;\r\nstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\r\nunsigned long flags;\r\nstruct list_buffer *lb, *n;\r\nunsigned long bytes_read;\r\ndev_dbg(&dev->core, "%s:%d: %u(%xh) bytes\n", __func__, __LINE__,\r\nbytes, bytes);\r\nspin_lock_irqsave(&priv->rx_list.lock, flags);\r\nwhile (priv->rx_list.bytes_held < bytes) {\r\nu64 tmp;\r\nresult = ps3_vuart_queue_rx_bytes(dev, &tmp);\r\nif (result || !tmp) {\r\ndev_dbg(&dev->core, "%s:%d: starved for %lxh bytes\n",\r\n__func__, __LINE__,\r\nbytes - priv->rx_list.bytes_held);\r\nspin_unlock_irqrestore(&priv->rx_list.lock, flags);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nlist_for_each_entry_safe(lb, n, &priv->rx_list.head, link) {\r\nbytes_read = min((unsigned int)(lb->tail - lb->head), bytes);\r\nmemcpy(buf, lb->head, bytes_read);\r\nbuf += bytes_read;\r\nbytes -= bytes_read;\r\npriv->rx_list.bytes_held -= bytes_read;\r\nif (bytes_read < lb->tail - lb->head) {\r\nlb->head += bytes_read;\r\ndev_dbg(&dev->core, "%s:%d: buf_%lu: dequeued %lxh "\r\n"bytes\n", __func__, __LINE__, lb->dbg_number,\r\nbytes_read);\r\nspin_unlock_irqrestore(&priv->rx_list.lock, flags);\r\nreturn 0;\r\n}\r\ndev_dbg(&dev->core, "%s:%d: buf_%lu: free, dequeued %lxh "\r\n"bytes\n", __func__, __LINE__, lb->dbg_number,\r\nbytes_read);\r\nlist_del(&lb->link);\r\nkfree(lb);\r\n}\r\nspin_unlock_irqrestore(&priv->rx_list.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void ps3_vuart_work(struct work_struct *work)\r\n{\r\nstruct ps3_system_bus_device *dev =\r\nps3_vuart_work_to_system_bus_dev(work);\r\nstruct ps3_vuart_port_driver *drv =\r\nps3_system_bus_dev_to_vuart_drv(dev);\r\nBUG_ON(!drv);\r\ndrv->work(dev);\r\n}\r\nint ps3_vuart_read_async(struct ps3_system_bus_device *dev, unsigned int bytes)\r\n{\r\nstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\r\nunsigned long flags;\r\nif (priv->rx_list.work.trigger) {\r\ndev_dbg(&dev->core, "%s:%d: warning, multiple calls\n",\r\n__func__, __LINE__);\r\nreturn -EAGAIN;\r\n}\r\nBUG_ON(!bytes);\r\nPREPARE_WORK(&priv->rx_list.work.work, ps3_vuart_work);\r\nspin_lock_irqsave(&priv->rx_list.lock, flags);\r\nif (priv->rx_list.bytes_held >= bytes) {\r\ndev_dbg(&dev->core, "%s:%d: schedule_work %xh bytes\n",\r\n__func__, __LINE__, bytes);\r\nschedule_work(&priv->rx_list.work.work);\r\nspin_unlock_irqrestore(&priv->rx_list.lock, flags);\r\nreturn 0;\r\n}\r\npriv->rx_list.work.trigger = bytes;\r\nspin_unlock_irqrestore(&priv->rx_list.lock, flags);\r\ndev_dbg(&dev->core, "%s:%d: waiting for %u(%xh) bytes\n", __func__,\r\n__LINE__, bytes, bytes);\r\nreturn 0;\r\n}\r\nvoid ps3_vuart_cancel_async(struct ps3_system_bus_device *dev)\r\n{\r\nto_port_priv(dev)->rx_list.work.trigger = 0;\r\n}\r\nstatic int ps3_vuart_handle_interrupt_tx(struct ps3_system_bus_device *dev)\r\n{\r\nint result = 0;\r\nstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\r\nunsigned long flags;\r\nstruct list_buffer *lb, *n;\r\nunsigned long bytes_total = 0;\r\ndev_dbg(&dev->core, "%s:%d\n", __func__, __LINE__);\r\nspin_lock_irqsave(&priv->tx_list.lock, flags);\r\nlist_for_each_entry_safe(lb, n, &priv->tx_list.head, link) {\r\nu64 bytes_written;\r\nresult = ps3_vuart_raw_write(dev, lb->head, lb->tail - lb->head,\r\n&bytes_written);\r\nif (result) {\r\ndev_dbg(&dev->core,\r\n"%s:%d: ps3_vuart_raw_write failed\n",\r\n__func__, __LINE__);\r\nbreak;\r\n}\r\nbytes_total += bytes_written;\r\nif (bytes_written < lb->tail - lb->head) {\r\nlb->head += bytes_written;\r\ndev_dbg(&dev->core,\r\n"%s:%d cleared buf_%lu, %llxh bytes\n",\r\n__func__, __LINE__, lb->dbg_number,\r\nbytes_written);\r\ngoto port_full;\r\n}\r\ndev_dbg(&dev->core, "%s:%d free buf_%lu\n", __func__, __LINE__,\r\nlb->dbg_number);\r\nlist_del(&lb->link);\r\nkfree(lb);\r\n}\r\nps3_vuart_disable_interrupt_tx(dev);\r\nport_full:\r\nspin_unlock_irqrestore(&priv->tx_list.lock, flags);\r\ndev_dbg(&dev->core, "%s:%d wrote %lxh bytes total\n",\r\n__func__, __LINE__, bytes_total);\r\nreturn result;\r\n}\r\nstatic int ps3_vuart_handle_interrupt_rx(struct ps3_system_bus_device *dev)\r\n{\r\nint result;\r\nstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\r\nunsigned long flags;\r\nu64 bytes;\r\ndev_dbg(&dev->core, "%s:%d\n", __func__, __LINE__);\r\nspin_lock_irqsave(&priv->rx_list.lock, flags);\r\nresult = ps3_vuart_queue_rx_bytes(dev, &bytes);\r\nif (result) {\r\nspin_unlock_irqrestore(&priv->rx_list.lock, flags);\r\nreturn result;\r\n}\r\nif (priv->rx_list.work.trigger && priv->rx_list.bytes_held\r\n>= priv->rx_list.work.trigger) {\r\ndev_dbg(&dev->core, "%s:%d: schedule_work %lxh bytes\n",\r\n__func__, __LINE__, priv->rx_list.work.trigger);\r\npriv->rx_list.work.trigger = 0;\r\nschedule_work(&priv->rx_list.work.work);\r\n}\r\nspin_unlock_irqrestore(&priv->rx_list.lock, flags);\r\nreturn result;\r\n}\r\nstatic int ps3_vuart_handle_interrupt_disconnect(\r\nstruct ps3_system_bus_device *dev)\r\n{\r\ndev_dbg(&dev->core, "%s:%d\n", __func__, __LINE__);\r\nBUG_ON("no support");\r\nreturn -1;\r\n}\r\nstatic int ps3_vuart_handle_port_interrupt(struct ps3_system_bus_device *dev)\r\n{\r\nint result;\r\nstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\r\nunsigned long status;\r\nresult = ps3_vuart_get_interrupt_status(dev, &status);\r\nif (result)\r\nreturn result;\r\ndev_dbg(&dev->core, "%s:%d: status: %lxh\n", __func__, __LINE__,\r\nstatus);\r\nif (status & INTERRUPT_MASK_DISCONNECT) {\r\npriv->stats.disconnect_interrupts++;\r\nresult = ps3_vuart_handle_interrupt_disconnect(dev);\r\nif (result)\r\nps3_vuart_disable_interrupt_disconnect(dev);\r\n}\r\nif (status & INTERRUPT_MASK_TX) {\r\npriv->stats.tx_interrupts++;\r\nresult = ps3_vuart_handle_interrupt_tx(dev);\r\nif (result)\r\nps3_vuart_disable_interrupt_tx(dev);\r\n}\r\nif (status & INTERRUPT_MASK_RX) {\r\npriv->stats.rx_interrupts++;\r\nresult = ps3_vuart_handle_interrupt_rx(dev);\r\nif (result)\r\nps3_vuart_disable_interrupt_rx(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ps3_vuart_irq_handler(int irq, void *_private)\r\n{\r\nstruct vuart_bus_priv *bus_priv = _private;\r\nBUG_ON(!bus_priv);\r\nwhile (1) {\r\nunsigned int port;\r\ndump_ports_bmp(bus_priv->bmp);\r\nport = (BITS_PER_LONG - 1) - __ilog2(bus_priv->bmp->status);\r\nif (port == BITS_PER_LONG)\r\nbreak;\r\nBUG_ON(port >= PORT_COUNT);\r\nBUG_ON(!bus_priv->devices[port]);\r\nps3_vuart_handle_port_interrupt(bus_priv->devices[port]);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ps3_vuart_bus_interrupt_get(void)\r\n{\r\nint result;\r\npr_debug(" -> %s:%d\n", __func__, __LINE__);\r\nvuart_bus_priv.use_count++;\r\nBUG_ON(vuart_bus_priv.use_count > 2);\r\nif (vuart_bus_priv.use_count != 1)\r\nreturn 0;\r\nBUG_ON(vuart_bus_priv.bmp);\r\nvuart_bus_priv.bmp = kzalloc(sizeof(struct ports_bmp), GFP_KERNEL);\r\nif (!vuart_bus_priv.bmp) {\r\npr_debug("%s:%d: kzalloc failed.\n", __func__, __LINE__);\r\nresult = -ENOMEM;\r\ngoto fail_bmp_malloc;\r\n}\r\nresult = ps3_vuart_irq_setup(PS3_BINDING_CPU_ANY, vuart_bus_priv.bmp,\r\n&vuart_bus_priv.virq);\r\nif (result) {\r\npr_debug("%s:%d: ps3_vuart_irq_setup failed (%d)\n",\r\n__func__, __LINE__, result);\r\nresult = -EPERM;\r\ngoto fail_alloc_irq;\r\n}\r\nresult = request_irq(vuart_bus_priv.virq, ps3_vuart_irq_handler,\r\n0, "vuart", &vuart_bus_priv);\r\nif (result) {\r\npr_debug("%s:%d: request_irq failed (%d)\n",\r\n__func__, __LINE__, result);\r\ngoto fail_request_irq;\r\n}\r\npr_debug(" <- %s:%d: ok\n", __func__, __LINE__);\r\nreturn result;\r\nfail_request_irq:\r\nps3_vuart_irq_destroy(vuart_bus_priv.virq);\r\nvuart_bus_priv.virq = NO_IRQ;\r\nfail_alloc_irq:\r\nkfree(vuart_bus_priv.bmp);\r\nvuart_bus_priv.bmp = NULL;\r\nfail_bmp_malloc:\r\nvuart_bus_priv.use_count--;\r\npr_debug(" <- %s:%d: failed\n", __func__, __LINE__);\r\nreturn result;\r\n}\r\nstatic int ps3_vuart_bus_interrupt_put(void)\r\n{\r\npr_debug(" -> %s:%d\n", __func__, __LINE__);\r\nvuart_bus_priv.use_count--;\r\nBUG_ON(vuart_bus_priv.use_count < 0);\r\nif (vuart_bus_priv.use_count != 0)\r\nreturn 0;\r\nfree_irq(vuart_bus_priv.virq, &vuart_bus_priv);\r\nps3_vuart_irq_destroy(vuart_bus_priv.virq);\r\nvuart_bus_priv.virq = NO_IRQ;\r\nkfree(vuart_bus_priv.bmp);\r\nvuart_bus_priv.bmp = NULL;\r\npr_debug(" <- %s:%d\n", __func__, __LINE__);\r\nreturn 0;\r\n}\r\nstatic int ps3_vuart_probe(struct ps3_system_bus_device *dev)\r\n{\r\nint result;\r\nstruct ps3_vuart_port_driver *drv;\r\nstruct ps3_vuart_port_priv *priv = NULL;\r\ndev_dbg(&dev->core, "%s:%d\n", __func__, __LINE__);\r\ndrv = ps3_system_bus_dev_to_vuart_drv(dev);\r\ndev_dbg(&dev->core, "%s:%d: (%s)\n", __func__, __LINE__,\r\ndrv->core.core.name);\r\nBUG_ON(!drv);\r\nif (dev->port_number >= PORT_COUNT) {\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&vuart_bus_priv.probe_mutex);\r\nresult = ps3_vuart_bus_interrupt_get();\r\nif (result)\r\ngoto fail_setup_interrupt;\r\nif (vuart_bus_priv.devices[dev->port_number]) {\r\ndev_dbg(&dev->core, "%s:%d: port busy (%d)\n", __func__,\r\n__LINE__, dev->port_number);\r\nresult = -EBUSY;\r\ngoto fail_busy;\r\n}\r\nvuart_bus_priv.devices[dev->port_number] = dev;\r\ndev->driver_priv = kzalloc(sizeof(struct ps3_vuart_port_priv),\r\nGFP_KERNEL);\r\nif (!dev->driver_priv) {\r\nresult = -ENOMEM;\r\ngoto fail_dev_malloc;\r\n}\r\npriv = to_port_priv(dev);\r\nINIT_LIST_HEAD(&priv->tx_list.head);\r\nspin_lock_init(&priv->tx_list.lock);\r\nINIT_LIST_HEAD(&priv->rx_list.head);\r\nspin_lock_init(&priv->rx_list.lock);\r\nINIT_WORK(&priv->rx_list.work.work, NULL);\r\npriv->rx_list.work.trigger = 0;\r\npriv->rx_list.work.dev = dev;\r\nps3_vuart_clear_rx_bytes(dev, 0);\r\nps3_vuart_set_interrupt_mask(dev, INTERRUPT_MASK_RX);\r\nps3_vuart_set_triggers(dev, 1, 1);\r\nif (drv->probe)\r\nresult = drv->probe(dev);\r\nelse {\r\nresult = 0;\r\ndev_info(&dev->core, "%s:%d: no probe method\n", __func__,\r\n__LINE__);\r\n}\r\nif (result) {\r\ndev_dbg(&dev->core, "%s:%d: drv->probe failed\n",\r\n__func__, __LINE__);\r\ngoto fail_probe;\r\n}\r\nmutex_unlock(&vuart_bus_priv.probe_mutex);\r\nreturn result;\r\nfail_probe:\r\nps3_vuart_set_interrupt_mask(dev, 0);\r\nkfree(dev->driver_priv);\r\ndev->driver_priv = NULL;\r\nfail_dev_malloc:\r\nvuart_bus_priv.devices[dev->port_number] = NULL;\r\nfail_busy:\r\nps3_vuart_bus_interrupt_put();\r\nfail_setup_interrupt:\r\nmutex_unlock(&vuart_bus_priv.probe_mutex);\r\ndev_dbg(&dev->core, "%s:%d: failed\n", __func__, __LINE__);\r\nreturn result;\r\n}\r\nstatic int ps3_vuart_cleanup(struct ps3_system_bus_device *dev)\r\n{\r\ndev_dbg(&dev->core, "%s:%d\n", __func__, __LINE__);\r\nps3_vuart_cancel_async(dev);\r\nps3_vuart_set_interrupt_mask(dev, 0);\r\nps3_vuart_bus_interrupt_put();\r\nreturn 0;\r\n}\r\nstatic int ps3_vuart_remove(struct ps3_system_bus_device *dev)\r\n{\r\nstruct ps3_vuart_port_priv *priv = to_port_priv(dev);\r\nstruct ps3_vuart_port_driver *drv;\r\nBUG_ON(!dev);\r\nmutex_lock(&vuart_bus_priv.probe_mutex);\r\ndev_dbg(&dev->core, " -> %s:%d: match_id %d\n", __func__, __LINE__,\r\ndev->match_id);\r\nif (!dev->core.driver) {\r\ndev_dbg(&dev->core, "%s:%d: no driver bound\n", __func__,\r\n__LINE__);\r\nmutex_unlock(&vuart_bus_priv.probe_mutex);\r\nreturn 0;\r\n}\r\ndrv = ps3_system_bus_dev_to_vuart_drv(dev);\r\nBUG_ON(!drv);\r\nif (drv->remove) {\r\ndrv->remove(dev);\r\n} else {\r\ndev_dbg(&dev->core, "%s:%d: no remove method\n", __func__,\r\n__LINE__);\r\nBUG();\r\n}\r\nps3_vuart_cleanup(dev);\r\nvuart_bus_priv.devices[dev->port_number] = NULL;\r\nkfree(priv);\r\npriv = NULL;\r\ndev_dbg(&dev->core, " <- %s:%d\n", __func__, __LINE__);\r\nmutex_unlock(&vuart_bus_priv.probe_mutex);\r\nreturn 0;\r\n}\r\nstatic int ps3_vuart_shutdown(struct ps3_system_bus_device *dev)\r\n{\r\nstruct ps3_vuart_port_driver *drv;\r\nBUG_ON(!dev);\r\nmutex_lock(&vuart_bus_priv.probe_mutex);\r\ndev_dbg(&dev->core, " -> %s:%d: match_id %d\n", __func__, __LINE__,\r\ndev->match_id);\r\nif (!dev->core.driver) {\r\ndev_dbg(&dev->core, "%s:%d: no driver bound\n", __func__,\r\n__LINE__);\r\nmutex_unlock(&vuart_bus_priv.probe_mutex);\r\nreturn 0;\r\n}\r\ndrv = ps3_system_bus_dev_to_vuart_drv(dev);\r\nBUG_ON(!drv);\r\nif (drv->shutdown)\r\ndrv->shutdown(dev);\r\nelse if (drv->remove) {\r\ndev_dbg(&dev->core, "%s:%d: no shutdown, calling remove\n",\r\n__func__, __LINE__);\r\ndrv->remove(dev);\r\n} else {\r\ndev_dbg(&dev->core, "%s:%d: no shutdown method\n", __func__,\r\n__LINE__);\r\nBUG();\r\n}\r\nps3_vuart_cleanup(dev);\r\ndev_dbg(&dev->core, " <- %s:%d\n", __func__, __LINE__);\r\nmutex_unlock(&vuart_bus_priv.probe_mutex);\r\nreturn 0;\r\n}\r\nstatic int __init ps3_vuart_bus_init(void)\r\n{\r\npr_debug("%s:%d:\n", __func__, __LINE__);\r\nif (!firmware_has_feature(FW_FEATURE_PS3_LV1))\r\nreturn -ENODEV;\r\nmutex_init(&vuart_bus_priv.probe_mutex);\r\nreturn 0;\r\n}\r\nstatic void __exit ps3_vuart_bus_exit(void)\r\n{\r\npr_debug("%s:%d:\n", __func__, __LINE__);\r\n}\r\nint ps3_vuart_port_driver_register(struct ps3_vuart_port_driver *drv)\r\n{\r\nint result;\r\npr_debug("%s:%d: (%s)\n", __func__, __LINE__, drv->core.core.name);\r\nBUG_ON(!drv->core.match_id);\r\nBUG_ON(!drv->core.core.name);\r\ndrv->core.probe = ps3_vuart_probe;\r\ndrv->core.remove = ps3_vuart_remove;\r\ndrv->core.shutdown = ps3_vuart_shutdown;\r\nresult = ps3_system_bus_driver_register(&drv->core);\r\nreturn result;\r\n}\r\nvoid ps3_vuart_port_driver_unregister(struct ps3_vuart_port_driver *drv)\r\n{\r\npr_debug("%s:%d: (%s)\n", __func__, __LINE__, drv->core.core.name);\r\nps3_system_bus_driver_unregister(&drv->core);\r\n}
