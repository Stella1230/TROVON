static struct ltc4261_data *ltc4261_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct ltc4261_data *data = i2c_get_clientdata(client);\r\nstruct ltc4261_data *ret = data;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ / 4) || !data->valid) {\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(data->regs); i++) {\r\nint val;\r\nval = i2c_smbus_read_byte_data(client, i);\r\nif (unlikely(val < 0)) {\r\ndev_dbg(dev,\r\n"Failed to read ADC value: error %d\n",\r\nval);\r\nret = ERR_PTR(val);\r\ndata->valid = 0;\r\ngoto abort;\r\n}\r\ndata->regs[i] = val;\r\n}\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nabort:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic int ltc4261_get_value(struct ltc4261_data *data, u8 reg)\r\n{\r\nu32 val;\r\nval = (data->regs[reg] << 2) + (data->regs[reg + 1] >> 6);\r\nswitch (reg) {\r\ncase LTC4261_ADIN_H:\r\ncase LTC4261_ADIN2_H:\r\nval = val * 25 / 10;\r\nbreak;\r\ncase LTC4261_SENSE_H:\r\nval = val * 625 / 10;\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nval = 0;\r\nbreak;\r\n}\r\nreturn val;\r\n}\r\nstatic ssize_t ltc4261_show_value(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct ltc4261_data *data = ltc4261_update_device(dev);\r\nint value;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nvalue = ltc4261_get_value(data, attr->index);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", value);\r\n}\r\nstatic ssize_t ltc4261_show_bool(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct ltc4261_data *data = ltc4261_update_device(dev);\r\nu8 fault;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nfault = data->regs[LTC4261_FAULT] & attr->index;\r\nif (fault)\r\ni2c_smbus_write_byte_data(client, LTC4261_FAULT, ~fault);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", fault ? 1 : 0);\r\n}\r\nstatic int ltc4261_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct ltc4261_data *data;\r\nint ret;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nif (i2c_smbus_read_byte_data(client, LTC4261_STATUS) < 0) {\r\ndev_err(&client->dev, "Failed to read status register\n");\r\nreturn -ENODEV;\r\n}\r\ndata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\ni2c_smbus_write_byte_data(client, LTC4261_FAULT, 0x00);\r\nret = sysfs_create_group(&client->dev.kobj, &ltc4261_group);\r\nif (ret)\r\nreturn ret;\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nret = PTR_ERR(data->hwmon_dev);\r\ngoto out_hwmon_device_register;\r\n}\r\nreturn 0;\r\nout_hwmon_device_register:\r\nsysfs_remove_group(&client->dev.kobj, &ltc4261_group);\r\nreturn ret;\r\n}\r\nstatic int ltc4261_remove(struct i2c_client *client)\r\n{\r\nstruct ltc4261_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &ltc4261_group);\r\nreturn 0;\r\n}
