static void set_prot_desc_tx(struct ux500_msp *msp,\r\nstruct msp_protdesc *protdesc,\r\nenum msp_data_size data_size)\r\n{\r\nu32 temp_reg = 0;\r\ntemp_reg |= MSP_P2_ENABLE_BIT(protdesc->tx_phase_mode);\r\ntemp_reg |= MSP_P2_START_MODE_BIT(protdesc->tx_phase2_start_mode);\r\ntemp_reg |= MSP_P1_FRAME_LEN_BITS(protdesc->tx_frame_len_1);\r\ntemp_reg |= MSP_P2_FRAME_LEN_BITS(protdesc->tx_frame_len_2);\r\nif (msp->def_elem_len) {\r\ntemp_reg |= MSP_P1_ELEM_LEN_BITS(protdesc->tx_elem_len_1);\r\ntemp_reg |= MSP_P2_ELEM_LEN_BITS(protdesc->tx_elem_len_2);\r\n} else {\r\ntemp_reg |= MSP_P1_ELEM_LEN_BITS(data_size);\r\ntemp_reg |= MSP_P2_ELEM_LEN_BITS(data_size);\r\n}\r\ntemp_reg |= MSP_DATA_DELAY_BITS(protdesc->tx_data_delay);\r\ntemp_reg |= MSP_SET_ENDIANNES_BIT(protdesc->tx_byte_order);\r\ntemp_reg |= MSP_FSYNC_POL(protdesc->tx_fsync_pol);\r\ntemp_reg |= MSP_DATA_WORD_SWAP(protdesc->tx_half_word_swap);\r\ntemp_reg |= MSP_SET_COMPANDING_MODE(protdesc->compression_mode);\r\ntemp_reg |= MSP_SET_FSYNC_IGNORE(protdesc->frame_sync_ignore);\r\nwritel(temp_reg, msp->registers + MSP_TCF);\r\n}\r\nstatic void set_prot_desc_rx(struct ux500_msp *msp,\r\nstruct msp_protdesc *protdesc,\r\nenum msp_data_size data_size)\r\n{\r\nu32 temp_reg = 0;\r\ntemp_reg |= MSP_P2_ENABLE_BIT(protdesc->rx_phase_mode);\r\ntemp_reg |= MSP_P2_START_MODE_BIT(protdesc->rx_phase2_start_mode);\r\ntemp_reg |= MSP_P1_FRAME_LEN_BITS(protdesc->rx_frame_len_1);\r\ntemp_reg |= MSP_P2_FRAME_LEN_BITS(protdesc->rx_frame_len_2);\r\nif (msp->def_elem_len) {\r\ntemp_reg |= MSP_P1_ELEM_LEN_BITS(protdesc->rx_elem_len_1);\r\ntemp_reg |= MSP_P2_ELEM_LEN_BITS(protdesc->rx_elem_len_2);\r\n} else {\r\ntemp_reg |= MSP_P1_ELEM_LEN_BITS(data_size);\r\ntemp_reg |= MSP_P2_ELEM_LEN_BITS(data_size);\r\n}\r\ntemp_reg |= MSP_DATA_DELAY_BITS(protdesc->rx_data_delay);\r\ntemp_reg |= MSP_SET_ENDIANNES_BIT(protdesc->rx_byte_order);\r\ntemp_reg |= MSP_FSYNC_POL(protdesc->rx_fsync_pol);\r\ntemp_reg |= MSP_DATA_WORD_SWAP(protdesc->rx_half_word_swap);\r\ntemp_reg |= MSP_SET_COMPANDING_MODE(protdesc->expansion_mode);\r\ntemp_reg |= MSP_SET_FSYNC_IGNORE(protdesc->frame_sync_ignore);\r\nwritel(temp_reg, msp->registers + MSP_RCF);\r\n}\r\nstatic int configure_protocol(struct ux500_msp *msp,\r\nstruct ux500_msp_config *config)\r\n{\r\nstruct msp_protdesc *protdesc;\r\nenum msp_data_size data_size;\r\nu32 temp_reg = 0;\r\ndata_size = config->data_size;\r\nmsp->def_elem_len = config->def_elem_len;\r\nif (config->default_protdesc == 1) {\r\nif (config->protocol >= MSP_INVALID_PROTOCOL) {\r\ndev_err(msp->dev, "%s: ERROR: Invalid protocol!\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nprotdesc =\r\n(struct msp_protdesc *)&prot_descs[config->protocol];\r\n} else {\r\nprotdesc = (struct msp_protdesc *)&config->protdesc;\r\n}\r\nif (data_size < MSP_DATA_BITS_DEFAULT || data_size > MSP_DATA_BITS_32) {\r\ndev_err(msp->dev,\r\n"%s: ERROR: Invalid data-size requested (data_size = %d)!\n",\r\n__func__, data_size);\r\nreturn -EINVAL;\r\n}\r\nif (config->direction & MSP_DIR_TX)\r\nset_prot_desc_tx(msp, protdesc, data_size);\r\nif (config->direction & MSP_DIR_RX)\r\nset_prot_desc_rx(msp, protdesc, data_size);\r\ntemp_reg = readl(msp->registers + MSP_GCR) & ~TX_CLK_POL_RISING;\r\ntemp_reg |= MSP_TX_CLKPOL_BIT(~protdesc->tx_clk_pol);\r\nwritel(temp_reg, msp->registers + MSP_GCR);\r\ntemp_reg = readl(msp->registers + MSP_GCR) & ~RX_CLK_POL_RISING;\r\ntemp_reg |= MSP_RX_CLKPOL_BIT(protdesc->rx_clk_pol);\r\nwritel(temp_reg, msp->registers + MSP_GCR);\r\nreturn 0;\r\n}\r\nstatic int setup_bitclk(struct ux500_msp *msp, struct ux500_msp_config *config)\r\n{\r\nu32 reg_val_GCR;\r\nu32 frame_per = 0;\r\nu32 sck_div = 0;\r\nu32 frame_width = 0;\r\nu32 temp_reg = 0;\r\nstruct msp_protdesc *protdesc = NULL;\r\nreg_val_GCR = readl(msp->registers + MSP_GCR);\r\nwritel(reg_val_GCR & ~SRG_ENABLE, msp->registers + MSP_GCR);\r\nif (config->default_protdesc)\r\nprotdesc =\r\n(struct msp_protdesc *)&prot_descs[config->protocol];\r\nelse\r\nprotdesc = (struct msp_protdesc *)&config->protdesc;\r\nswitch (config->protocol) {\r\ncase MSP_PCM_PROTOCOL:\r\ncase MSP_PCM_COMPAND_PROTOCOL:\r\nframe_width = protdesc->frame_width;\r\nsck_div = config->f_inputclk / (config->frame_freq *\r\n(protdesc->clocks_per_frame));\r\nframe_per = protdesc->frame_period;\r\nbreak;\r\ncase MSP_I2S_PROTOCOL:\r\nframe_width = protdesc->frame_width;\r\nsck_div = config->f_inputclk / (config->frame_freq *\r\n(protdesc->clocks_per_frame));\r\nframe_per = protdesc->frame_period;\r\nbreak;\r\ndefault:\r\ndev_err(msp->dev, "%s: ERROR: Unknown protocol (%d)!\n",\r\n__func__,\r\nconfig->protocol);\r\nreturn -EINVAL;\r\n}\r\ntemp_reg = (sck_div - 1) & SCK_DIV_MASK;\r\ntemp_reg |= FRAME_WIDTH_BITS(frame_width);\r\ntemp_reg |= FRAME_PERIOD_BITS(frame_per);\r\nwritel(temp_reg, msp->registers + MSP_SRG);\r\nmsp->f_bitclk = (config->f_inputclk)/(sck_div + 1);\r\nudelay(100);\r\nreg_val_GCR = readl(msp->registers + MSP_GCR);\r\nwritel(reg_val_GCR | SRG_ENABLE, msp->registers + MSP_GCR);\r\nudelay(100);\r\nreturn 0;\r\n}\r\nstatic int configure_multichannel(struct ux500_msp *msp,\r\nstruct ux500_msp_config *config)\r\n{\r\nstruct msp_protdesc *protdesc;\r\nstruct msp_multichannel_config *mcfg;\r\nu32 reg_val_MCR;\r\nif (config->default_protdesc == 1) {\r\nif (config->protocol >= MSP_INVALID_PROTOCOL) {\r\ndev_err(msp->dev,\r\n"%s: ERROR: Invalid protocol (%d)!\n",\r\n__func__, config->protocol);\r\nreturn -EINVAL;\r\n}\r\nprotdesc = (struct msp_protdesc *)\r\n&prot_descs[config->protocol];\r\n} else {\r\nprotdesc = (struct msp_protdesc *)&config->protdesc;\r\n}\r\nmcfg = &config->multichannel_config;\r\nif (mcfg->tx_multichannel_enable) {\r\nif (protdesc->tx_phase_mode == MSP_SINGLE_PHASE) {\r\nreg_val_MCR = readl(msp->registers + MSP_MCR);\r\nwritel(reg_val_MCR | (mcfg->tx_multichannel_enable ?\r\n1 << TMCEN_BIT : 0),\r\nmsp->registers + MSP_MCR);\r\nwritel(mcfg->tx_channel_0_enable,\r\nmsp->registers + MSP_TCE0);\r\nwritel(mcfg->tx_channel_1_enable,\r\nmsp->registers + MSP_TCE1);\r\nwritel(mcfg->tx_channel_2_enable,\r\nmsp->registers + MSP_TCE2);\r\nwritel(mcfg->tx_channel_3_enable,\r\nmsp->registers + MSP_TCE3);\r\n} else {\r\ndev_err(msp->dev,\r\n"%s: ERROR: Only single-phase supported (TX-mode: %d)!\n",\r\n__func__, protdesc->tx_phase_mode);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (mcfg->rx_multichannel_enable) {\r\nif (protdesc->rx_phase_mode == MSP_SINGLE_PHASE) {\r\nreg_val_MCR = readl(msp->registers + MSP_MCR);\r\nwritel(reg_val_MCR | (mcfg->rx_multichannel_enable ?\r\n1 << RMCEN_BIT : 0),\r\nmsp->registers + MSP_MCR);\r\nwritel(mcfg->rx_channel_0_enable,\r\nmsp->registers + MSP_RCE0);\r\nwritel(mcfg->rx_channel_1_enable,\r\nmsp->registers + MSP_RCE1);\r\nwritel(mcfg->rx_channel_2_enable,\r\nmsp->registers + MSP_RCE2);\r\nwritel(mcfg->rx_channel_3_enable,\r\nmsp->registers + MSP_RCE3);\r\n} else {\r\ndev_err(msp->dev,\r\n"%s: ERROR: Only single-phase supported (RX-mode: %d)!\n",\r\n__func__, protdesc->rx_phase_mode);\r\nreturn -EINVAL;\r\n}\r\nif (mcfg->rx_comparison_enable_mode) {\r\nreg_val_MCR = readl(msp->registers + MSP_MCR);\r\nwritel(reg_val_MCR |\r\n(mcfg->rx_comparison_enable_mode << RCMPM_BIT),\r\nmsp->registers + MSP_MCR);\r\nwritel(mcfg->comparison_mask,\r\nmsp->registers + MSP_RCM);\r\nwritel(mcfg->comparison_value,\r\nmsp->registers + MSP_RCV);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int enable_msp(struct ux500_msp *msp, struct ux500_msp_config *config)\r\n{\r\nint status = 0;\r\nu32 reg_val_DMACR, reg_val_GCR;\r\nconfigure_protocol(msp, config);\r\nsetup_bitclk(msp, config);\r\nif (config->multichannel_configured == 1) {\r\nstatus = configure_multichannel(msp, config);\r\nif (status)\r\ndev_warn(msp->dev,\r\n"%s: WARN: configure_multichannel failed (%d)!\n",\r\n__func__, status);\r\n}\r\nif ((config->direction & MSP_DIR_RX) &&\r\n!msp->capture_dma_data.dma_cfg) {\r\ndev_err(msp->dev, "%s: ERROR: MSP RX-mode is not configured!",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif ((config->direction == MSP_DIR_TX) &&\r\n!msp->playback_dma_data.dma_cfg) {\r\ndev_err(msp->dev, "%s: ERROR: MSP TX-mode is not configured!",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nreg_val_DMACR = readl(msp->registers + MSP_DMACR);\r\nif (config->direction & MSP_DIR_RX)\r\nreg_val_DMACR |= RX_DMA_ENABLE;\r\nif (config->direction & MSP_DIR_TX)\r\nreg_val_DMACR |= TX_DMA_ENABLE;\r\nwritel(reg_val_DMACR, msp->registers + MSP_DMACR);\r\nwritel(config->iodelay, msp->registers + MSP_IODLY);\r\nreg_val_GCR = readl(msp->registers + MSP_GCR);\r\nwritel(reg_val_GCR | FRAME_GEN_ENABLE, msp->registers + MSP_GCR);\r\nreturn status;\r\n}\r\nstatic void flush_fifo_rx(struct ux500_msp *msp)\r\n{\r\nu32 reg_val_DR, reg_val_GCR, reg_val_FLR;\r\nu32 limit = 32;\r\nreg_val_GCR = readl(msp->registers + MSP_GCR);\r\nwritel(reg_val_GCR | RX_ENABLE, msp->registers + MSP_GCR);\r\nreg_val_FLR = readl(msp->registers + MSP_FLR);\r\nwhile (!(reg_val_FLR & RX_FIFO_EMPTY) && limit--) {\r\nreg_val_DR = readl(msp->registers + MSP_DR);\r\nreg_val_FLR = readl(msp->registers + MSP_FLR);\r\n}\r\nwritel(reg_val_GCR, msp->registers + MSP_GCR);\r\n}\r\nstatic void flush_fifo_tx(struct ux500_msp *msp)\r\n{\r\nu32 reg_val_TSTDR, reg_val_GCR, reg_val_FLR;\r\nu32 limit = 32;\r\nreg_val_GCR = readl(msp->registers + MSP_GCR);\r\nwritel(reg_val_GCR | TX_ENABLE, msp->registers + MSP_GCR);\r\nwritel(MSP_ITCR_ITEN | MSP_ITCR_TESTFIFO, msp->registers + MSP_ITCR);\r\nreg_val_FLR = readl(msp->registers + MSP_FLR);\r\nwhile (!(reg_val_FLR & TX_FIFO_EMPTY) && limit--) {\r\nreg_val_TSTDR = readl(msp->registers + MSP_TSTDR);\r\nreg_val_FLR = readl(msp->registers + MSP_FLR);\r\n}\r\nwritel(0x0, msp->registers + MSP_ITCR);\r\nwritel(reg_val_GCR, msp->registers + MSP_GCR);\r\n}\r\nint ux500_msp_i2s_open(struct ux500_msp *msp,\r\nstruct ux500_msp_config *config)\r\n{\r\nu32 old_reg, new_reg, mask;\r\nint res;\r\nunsigned int tx_sel, rx_sel, tx_busy, rx_busy;\r\nif (in_interrupt()) {\r\ndev_err(msp->dev,\r\n"%s: ERROR: Open called in interrupt context!\n",\r\n__func__);\r\nreturn -1;\r\n}\r\ntx_sel = (config->direction & MSP_DIR_TX) > 0;\r\nrx_sel = (config->direction & MSP_DIR_RX) > 0;\r\nif (!tx_sel && !rx_sel) {\r\ndev_err(msp->dev, "%s: Error: No direction selected!\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\ntx_busy = (msp->dir_busy & MSP_DIR_TX) > 0;\r\nrx_busy = (msp->dir_busy & MSP_DIR_RX) > 0;\r\nif (tx_busy && tx_sel) {\r\ndev_err(msp->dev, "%s: Error: TX is in use!\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nif (rx_busy && rx_sel) {\r\ndev_err(msp->dev, "%s: Error: RX is in use!\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nmsp->dir_busy |= (tx_sel ? MSP_DIR_TX : 0) | (rx_sel ? MSP_DIR_RX : 0);\r\nmask = RX_CLK_SEL_MASK | TX_CLK_SEL_MASK | RX_FSYNC_MASK |\r\nTX_FSYNC_MASK | RX_SYNC_SEL_MASK | TX_SYNC_SEL_MASK |\r\nRX_FIFO_ENABLE_MASK | TX_FIFO_ENABLE_MASK | SRG_CLK_SEL_MASK |\r\nLOOPBACK_MASK | TX_EXTRA_DELAY_MASK;\r\nnew_reg = (config->tx_clk_sel | config->rx_clk_sel |\r\nconfig->rx_fsync_pol | config->tx_fsync_pol |\r\nconfig->rx_fsync_sel | config->tx_fsync_sel |\r\nconfig->rx_fifo_config | config->tx_fifo_config |\r\nconfig->srg_clk_sel | config->loopback_enable |\r\nconfig->tx_data_enable);\r\nold_reg = readl(msp->registers + MSP_GCR);\r\nold_reg &= ~mask;\r\nnew_reg |= old_reg;\r\nwritel(new_reg, msp->registers + MSP_GCR);\r\nres = enable_msp(msp, config);\r\nif (res < 0) {\r\ndev_err(msp->dev, "%s: ERROR: enable_msp failed (%d)!\n",\r\n__func__, res);\r\nreturn -EBUSY;\r\n}\r\nif (config->loopback_enable & 0x80)\r\nmsp->loopback_enable = 1;\r\nflush_fifo_tx(msp);\r\nflush_fifo_rx(msp);\r\nmsp->msp_state = MSP_STATE_CONFIGURED;\r\nreturn 0;\r\n}\r\nstatic void disable_msp_rx(struct ux500_msp *msp)\r\n{\r\nu32 reg_val_GCR, reg_val_DMACR, reg_val_IMSC;\r\nreg_val_GCR = readl(msp->registers + MSP_GCR);\r\nwritel(reg_val_GCR & ~RX_ENABLE, msp->registers + MSP_GCR);\r\nreg_val_DMACR = readl(msp->registers + MSP_DMACR);\r\nwritel(reg_val_DMACR & ~RX_DMA_ENABLE, msp->registers + MSP_DMACR);\r\nreg_val_IMSC = readl(msp->registers + MSP_IMSC);\r\nwritel(reg_val_IMSC &\r\n~(RX_SERVICE_INT | RX_OVERRUN_ERROR_INT),\r\nmsp->registers + MSP_IMSC);\r\nmsp->dir_busy &= ~MSP_DIR_RX;\r\n}\r\nstatic void disable_msp_tx(struct ux500_msp *msp)\r\n{\r\nu32 reg_val_GCR, reg_val_DMACR, reg_val_IMSC;\r\nreg_val_GCR = readl(msp->registers + MSP_GCR);\r\nwritel(reg_val_GCR & ~TX_ENABLE, msp->registers + MSP_GCR);\r\nreg_val_DMACR = readl(msp->registers + MSP_DMACR);\r\nwritel(reg_val_DMACR & ~TX_DMA_ENABLE, msp->registers + MSP_DMACR);\r\nreg_val_IMSC = readl(msp->registers + MSP_IMSC);\r\nwritel(reg_val_IMSC &\r\n~(TX_SERVICE_INT | TX_UNDERRUN_ERR_INT),\r\nmsp->registers + MSP_IMSC);\r\nmsp->dir_busy &= ~MSP_DIR_TX;\r\n}\r\nstatic int disable_msp(struct ux500_msp *msp, unsigned int dir)\r\n{\r\nu32 reg_val_GCR;\r\nint status = 0;\r\nunsigned int disable_tx, disable_rx;\r\nreg_val_GCR = readl(msp->registers + MSP_GCR);\r\ndisable_tx = dir & MSP_DIR_TX;\r\ndisable_rx = dir & MSP_DIR_TX;\r\nif (disable_tx && disable_rx) {\r\nreg_val_GCR = readl(msp->registers + MSP_GCR);\r\nwritel(reg_val_GCR | LOOPBACK_MASK,\r\nmsp->registers + MSP_GCR);\r\nflush_fifo_tx(msp);\r\nwritel((readl(msp->registers + MSP_GCR) &\r\n(~TX_ENABLE)), msp->registers + MSP_GCR);\r\nflush_fifo_rx(msp);\r\nwritel((readl(msp->registers + MSP_GCR) &\r\n(~(RX_ENABLE | LOOPBACK_MASK))),\r\nmsp->registers + MSP_GCR);\r\ndisable_msp_tx(msp);\r\ndisable_msp_rx(msp);\r\n} else if (disable_tx)\r\ndisable_msp_tx(msp);\r\nelse if (disable_rx)\r\ndisable_msp_rx(msp);\r\nreturn status;\r\n}\r\nint ux500_msp_i2s_trigger(struct ux500_msp *msp, int cmd, int direction)\r\n{\r\nu32 reg_val_GCR, enable_bit;\r\nif (msp->msp_state == MSP_STATE_IDLE) {\r\ndev_err(msp->dev, "%s: ERROR: MSP is not configured!\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (direction == SNDRV_PCM_STREAM_PLAYBACK)\r\nenable_bit = TX_ENABLE;\r\nelse\r\nenable_bit = RX_ENABLE;\r\nreg_val_GCR = readl(msp->registers + MSP_GCR);\r\nwritel(reg_val_GCR | enable_bit, msp->registers + MSP_GCR);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (direction == SNDRV_PCM_STREAM_PLAYBACK)\r\ndisable_msp_tx(msp);\r\nelse\r\ndisable_msp_rx(msp);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint ux500_msp_i2s_close(struct ux500_msp *msp, unsigned int dir)\r\n{\r\nint status = 0;\r\ndev_dbg(msp->dev, "%s: Enter (dir = 0x%01x).\n", __func__, dir);\r\nstatus = disable_msp(msp, dir);\r\nif (msp->dir_busy == 0) {\r\nmsp->msp_state = MSP_STATE_IDLE;\r\nwritel((readl(msp->registers + MSP_GCR) &\r\n(~(FRAME_GEN_ENABLE | SRG_ENABLE))),\r\nmsp->registers + MSP_GCR);\r\nwritel(0, msp->registers + MSP_GCR);\r\nwritel(0, msp->registers + MSP_TCF);\r\nwritel(0, msp->registers + MSP_RCF);\r\nwritel(0, msp->registers + MSP_DMACR);\r\nwritel(0, msp->registers + MSP_SRG);\r\nwritel(0, msp->registers + MSP_MCR);\r\nwritel(0, msp->registers + MSP_RCM);\r\nwritel(0, msp->registers + MSP_RCV);\r\nwritel(0, msp->registers + MSP_TCE0);\r\nwritel(0, msp->registers + MSP_TCE1);\r\nwritel(0, msp->registers + MSP_TCE2);\r\nwritel(0, msp->registers + MSP_TCE3);\r\nwritel(0, msp->registers + MSP_RCE0);\r\nwritel(0, msp->registers + MSP_RCE1);\r\nwritel(0, msp->registers + MSP_RCE2);\r\nwritel(0, msp->registers + MSP_RCE3);\r\n}\r\nreturn status;\r\n}\r\nint ux500_msp_i2s_init_msp(struct platform_device *pdev,\r\nstruct ux500_msp **msp_p,\r\nstruct msp_i2s_platform_data *platform_data)\r\n{\r\nstruct resource *res = NULL;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct ux500_msp *msp;\r\n*msp_p = devm_kzalloc(&pdev->dev, sizeof(struct ux500_msp), GFP_KERNEL);\r\nmsp = *msp_p;\r\nif (!msp)\r\nreturn -ENOMEM;\r\nif (np) {\r\nif (!platform_data) {\r\nplatform_data = devm_kzalloc(&pdev->dev,\r\nsizeof(struct msp_i2s_platform_data), GFP_KERNEL);\r\nif (!platform_data)\r\nreturn -ENOMEM;\r\n}\r\n} else\r\nif (!platform_data)\r\nreturn -EINVAL;\r\ndev_dbg(&pdev->dev, "%s: Enter (name: %s, id: %d).\n", __func__,\r\npdev->name, platform_data->id);\r\nmsp->id = platform_data->id;\r\nmsp->dev = &pdev->dev;\r\nmsp->playback_dma_data.dma_cfg = platform_data->msp_i2s_dma_tx;\r\nmsp->capture_dma_data.dma_cfg = platform_data->msp_i2s_dma_rx;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "%s: ERROR: Unable to get resource!\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nmsp->playback_dma_data.tx_rx_addr = res->start + MSP_DR;\r\nmsp->capture_dma_data.tx_rx_addr = res->start + MSP_DR;\r\nmsp->registers = devm_ioremap(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (msp->registers == NULL) {\r\ndev_err(&pdev->dev, "%s: ERROR: ioremap failed!\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nmsp->msp_state = MSP_STATE_IDLE;\r\nmsp->loopback_enable = 0;\r\nreturn 0;\r\n}\r\nvoid ux500_msp_i2s_cleanup_msp(struct platform_device *pdev,\r\nstruct ux500_msp *msp)\r\n{\r\ndev_dbg(msp->dev, "%s: Enter (id = %d).\n", __func__, msp->id);\r\n}
