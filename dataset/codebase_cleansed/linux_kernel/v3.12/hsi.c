static ssize_t modalias_show(struct device *dev,\r\nstruct device_attribute *a __maybe_unused, char *buf)\r\n{\r\nreturn sprintf(buf, "hsi:%s\n", dev_name(dev));\r\n}\r\nstatic int hsi_bus_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nadd_uevent_var(env, "MODALIAS=hsi:%s", dev_name(dev));\r\nreturn 0;\r\n}\r\nstatic int hsi_bus_match(struct device *dev, struct device_driver *driver)\r\n{\r\nreturn strcmp(dev_name(dev), driver->name) == 0;\r\n}\r\nstatic void hsi_client_release(struct device *dev)\r\n{\r\nkfree(to_hsi_client(dev));\r\n}\r\nstatic void hsi_new_client(struct hsi_port *port, struct hsi_board_info *info)\r\n{\r\nstruct hsi_client *cl;\r\ncl = kzalloc(sizeof(*cl), GFP_KERNEL);\r\nif (!cl)\r\nreturn;\r\ncl->tx_cfg = info->tx_cfg;\r\ncl->rx_cfg = info->rx_cfg;\r\ncl->device.bus = &hsi_bus_type;\r\ncl->device.parent = &port->device;\r\ncl->device.release = hsi_client_release;\r\ndev_set_name(&cl->device, "%s", info->name);\r\ncl->device.platform_data = info->platform_data;\r\nif (info->archdata)\r\ncl->device.archdata = *info->archdata;\r\nif (device_register(&cl->device) < 0) {\r\npr_err("hsi: failed to register client: %s\n", info->name);\r\nput_device(&cl->device);\r\n}\r\n}\r\nstatic void hsi_scan_board_info(struct hsi_controller *hsi)\r\n{\r\nstruct hsi_cl_info *cl_info;\r\nstruct hsi_port *p;\r\nlist_for_each_entry(cl_info, &hsi_board_list, list)\r\nif (cl_info->info.hsi_id == hsi->id) {\r\np = hsi_find_port_num(hsi, cl_info->info.port);\r\nif (!p)\r\ncontinue;\r\nhsi_new_client(p, &cl_info->info);\r\n}\r\n}\r\nstatic int hsi_remove_client(struct device *dev, void *data __maybe_unused)\r\n{\r\ndevice_unregister(dev);\r\nreturn 0;\r\n}\r\nstatic int hsi_remove_port(struct device *dev, void *data __maybe_unused)\r\n{\r\ndevice_for_each_child(dev, NULL, hsi_remove_client);\r\ndevice_unregister(dev);\r\nreturn 0;\r\n}\r\nstatic void hsi_controller_release(struct device *dev)\r\n{\r\nstruct hsi_controller *hsi = to_hsi_controller(dev);\r\nkfree(hsi->port);\r\nkfree(hsi);\r\n}\r\nstatic void hsi_port_release(struct device *dev)\r\n{\r\nkfree(to_hsi_port(dev));\r\n}\r\nvoid hsi_unregister_controller(struct hsi_controller *hsi)\r\n{\r\ndevice_for_each_child(&hsi->device, NULL, hsi_remove_port);\r\ndevice_unregister(&hsi->device);\r\n}\r\nint hsi_register_controller(struct hsi_controller *hsi)\r\n{\r\nunsigned int i;\r\nint err;\r\nerr = device_add(&hsi->device);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < hsi->num_ports; i++) {\r\nhsi->port[i]->device.parent = &hsi->device;\r\nerr = device_add(&hsi->port[i]->device);\r\nif (err < 0)\r\ngoto out;\r\n}\r\nhsi_scan_board_info(hsi);\r\nreturn 0;\r\nout:\r\nwhile (i-- > 0)\r\ndevice_del(&hsi->port[i]->device);\r\ndevice_del(&hsi->device);\r\nreturn err;\r\n}\r\nint hsi_register_client_driver(struct hsi_client_driver *drv)\r\n{\r\ndrv->driver.bus = &hsi_bus_type;\r\nreturn driver_register(&drv->driver);\r\n}\r\nstatic inline int hsi_dummy_msg(struct hsi_msg *msg __maybe_unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int hsi_dummy_cl(struct hsi_client *cl __maybe_unused)\r\n{\r\nreturn 0;\r\n}\r\nvoid hsi_put_controller(struct hsi_controller *hsi)\r\n{\r\nunsigned int i;\r\nif (!hsi)\r\nreturn;\r\nfor (i = 0; i < hsi->num_ports; i++)\r\nif (hsi->port && hsi->port[i])\r\nput_device(&hsi->port[i]->device);\r\nput_device(&hsi->device);\r\n}\r\nstruct hsi_controller *hsi_alloc_controller(unsigned int n_ports, gfp_t flags)\r\n{\r\nstruct hsi_controller *hsi;\r\nstruct hsi_port **port;\r\nunsigned int i;\r\nif (!n_ports)\r\nreturn NULL;\r\nhsi = kzalloc(sizeof(*hsi), flags);\r\nif (!hsi)\r\nreturn NULL;\r\nport = kzalloc(sizeof(*port)*n_ports, flags);\r\nif (!port) {\r\nkfree(hsi);\r\nreturn NULL;\r\n}\r\nhsi->num_ports = n_ports;\r\nhsi->port = port;\r\nhsi->device.release = hsi_controller_release;\r\ndevice_initialize(&hsi->device);\r\nfor (i = 0; i < n_ports; i++) {\r\nport[i] = kzalloc(sizeof(**port), flags);\r\nif (port[i] == NULL)\r\ngoto out;\r\nport[i]->num = i;\r\nport[i]->async = hsi_dummy_msg;\r\nport[i]->setup = hsi_dummy_cl;\r\nport[i]->flush = hsi_dummy_cl;\r\nport[i]->start_tx = hsi_dummy_cl;\r\nport[i]->stop_tx = hsi_dummy_cl;\r\nport[i]->release = hsi_dummy_cl;\r\nmutex_init(&port[i]->lock);\r\nATOMIC_INIT_NOTIFIER_HEAD(&port[i]->n_head);\r\ndev_set_name(&port[i]->device, "port%d", i);\r\nhsi->port[i]->device.release = hsi_port_release;\r\ndevice_initialize(&hsi->port[i]->device);\r\n}\r\nreturn hsi;\r\nout:\r\nhsi_put_controller(hsi);\r\nreturn NULL;\r\n}\r\nvoid hsi_free_msg(struct hsi_msg *msg)\r\n{\r\nif (!msg)\r\nreturn;\r\nsg_free_table(&msg->sgt);\r\nkfree(msg);\r\n}\r\nstruct hsi_msg *hsi_alloc_msg(unsigned int nents, gfp_t flags)\r\n{\r\nstruct hsi_msg *msg;\r\nint err;\r\nmsg = kzalloc(sizeof(*msg), flags);\r\nif (!msg)\r\nreturn NULL;\r\nif (!nents)\r\nreturn msg;\r\nerr = sg_alloc_table(&msg->sgt, nents, flags);\r\nif (unlikely(err)) {\r\nkfree(msg);\r\nmsg = NULL;\r\n}\r\nreturn msg;\r\n}\r\nint hsi_async(struct hsi_client *cl, struct hsi_msg *msg)\r\n{\r\nstruct hsi_port *port = hsi_get_port(cl);\r\nif (!hsi_port_claimed(cl))\r\nreturn -EACCES;\r\nWARN_ON_ONCE(!msg->destructor || !msg->complete);\r\nmsg->cl = cl;\r\nreturn port->async(msg);\r\n}\r\nint hsi_claim_port(struct hsi_client *cl, unsigned int share)\r\n{\r\nstruct hsi_port *port = hsi_get_port(cl);\r\nint err = 0;\r\nmutex_lock(&port->lock);\r\nif ((port->claimed) && (!port->shared || !share)) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nif (!try_module_get(to_hsi_controller(port->device.parent)->owner)) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nport->claimed++;\r\nport->shared = !!share;\r\ncl->pclaimed = 1;\r\nout:\r\nmutex_unlock(&port->lock);\r\nreturn err;\r\n}\r\nvoid hsi_release_port(struct hsi_client *cl)\r\n{\r\nstruct hsi_port *port = hsi_get_port(cl);\r\nmutex_lock(&port->lock);\r\nport->release(cl);\r\nif (cl->pclaimed)\r\nport->claimed--;\r\nBUG_ON(port->claimed < 0);\r\ncl->pclaimed = 0;\r\nif (!port->claimed)\r\nport->shared = 0;\r\nmodule_put(to_hsi_controller(port->device.parent)->owner);\r\nmutex_unlock(&port->lock);\r\n}\r\nstatic int hsi_event_notifier_call(struct notifier_block *nb,\r\nunsigned long event, void *data __maybe_unused)\r\n{\r\nstruct hsi_client *cl = container_of(nb, struct hsi_client, nb);\r\n(*cl->ehandler)(cl, event);\r\nreturn 0;\r\n}\r\nint hsi_register_port_event(struct hsi_client *cl,\r\nvoid (*handler)(struct hsi_client *, unsigned long))\r\n{\r\nstruct hsi_port *port = hsi_get_port(cl);\r\nif (!handler || cl->ehandler)\r\nreturn -EINVAL;\r\nif (!hsi_port_claimed(cl))\r\nreturn -EACCES;\r\ncl->ehandler = handler;\r\ncl->nb.notifier_call = hsi_event_notifier_call;\r\nreturn atomic_notifier_chain_register(&port->n_head, &cl->nb);\r\n}\r\nint hsi_unregister_port_event(struct hsi_client *cl)\r\n{\r\nstruct hsi_port *port = hsi_get_port(cl);\r\nint err;\r\nWARN_ON(!hsi_port_claimed(cl));\r\nerr = atomic_notifier_chain_unregister(&port->n_head, &cl->nb);\r\nif (!err)\r\ncl->ehandler = NULL;\r\nreturn err;\r\n}\r\nint hsi_event(struct hsi_port *port, unsigned long event)\r\n{\r\nreturn atomic_notifier_call_chain(&port->n_head, event, NULL);\r\n}\r\nstatic int __init hsi_init(void)\r\n{\r\nreturn bus_register(&hsi_bus_type);\r\n}\r\nstatic void __exit hsi_exit(void)\r\n{\r\nbus_unregister(&hsi_bus_type);\r\n}
