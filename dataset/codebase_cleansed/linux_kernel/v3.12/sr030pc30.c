static inline struct sr030pc30_info *to_sr030pc30(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct sr030pc30_info, sd);\r\n}\r\nstatic inline int set_i2c_page(struct sr030pc30_info *info,\r\nstruct i2c_client *client, unsigned int reg)\r\n{\r\nint ret = 0;\r\nu32 page = reg >> 8 & 0xFF;\r\nif (info->i2c_reg_page != page && (reg & 0xFF) != 0x03) {\r\nret = i2c_smbus_write_byte_data(client, PAGEMODE_REG, page);\r\nif (!ret)\r\ninfo->i2c_reg_page = page;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cam_i2c_read(struct v4l2_subdev *sd, u32 reg_addr)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct sr030pc30_info *info = to_sr030pc30(sd);\r\nint ret = set_i2c_page(info, client, reg_addr);\r\nif (!ret)\r\nret = i2c_smbus_read_byte_data(client, reg_addr & 0xFF);\r\nreturn ret;\r\n}\r\nstatic int cam_i2c_write(struct v4l2_subdev *sd, u32 reg_addr, u32 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct sr030pc30_info *info = to_sr030pc30(sd);\r\nint ret = set_i2c_page(info, client, reg_addr);\r\nif (!ret)\r\nret = i2c_smbus_write_byte_data(\r\nclient, reg_addr & 0xFF, val);\r\nreturn ret;\r\n}\r\nstatic inline int sr030pc30_bulk_write_reg(struct v4l2_subdev *sd,\r\nconst struct i2c_regval *msg)\r\n{\r\nwhile (msg->addr != REG_TERM) {\r\nint ret = cam_i2c_write(sd, msg->addr, msg->val);\r\nif (ret)\r\nreturn ret;\r\nmsg++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sr030pc30_pwr_ctrl(struct v4l2_subdev *sd,\r\nbool reset, bool sleep)\r\n{\r\nstruct sr030pc30_info *info = to_sr030pc30(sd);\r\nu8 reg = sleep ? 0xF1 : 0xF0;\r\nint ret = 0;\r\nif (reset)\r\nret = cam_i2c_write(sd, POWER_CTRL_REG, reg | 0x02);\r\nif (!ret) {\r\nret = cam_i2c_write(sd, POWER_CTRL_REG, reg);\r\nif (!ret) {\r\ninfo->sleep = sleep;\r\nif (reset)\r\ninfo->i2c_reg_page = -1;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int sr030pc30_set_flip(struct v4l2_subdev *sd)\r\n{\r\nstruct sr030pc30_info *info = to_sr030pc30(sd);\r\ns32 reg = cam_i2c_read(sd, VDO_CTL2_REG);\r\nif (reg < 0)\r\nreturn reg;\r\nreg &= 0x7C;\r\nif (info->hflip)\r\nreg |= 0x01;\r\nif (info->vflip)\r\nreg |= 0x02;\r\nreturn cam_i2c_write(sd, VDO_CTL2_REG, reg | 0x80);\r\n}\r\nstatic int sr030pc30_set_params(struct v4l2_subdev *sd)\r\n{\r\nstruct sr030pc30_info *info = to_sr030pc30(sd);\r\nint ret;\r\nif (!info->curr_win)\r\nreturn -EINVAL;\r\nret = cam_i2c_write(sd, VDO_CTL1_REG,\r\ninfo->curr_win->vid_ctl1);\r\nif (!ret && info->curr_fmt)\r\nret = cam_i2c_write(sd, ISP_CTL_REG(0),\r\ninfo->curr_fmt->ispctl1_reg);\r\nif (!ret)\r\nret = sr030pc30_set_flip(sd);\r\nreturn ret;\r\n}\r\nstatic int sr030pc30_try_frame_size(struct v4l2_mbus_framefmt *mf)\r\n{\r\nunsigned int min_err = ~0;\r\nint i = ARRAY_SIZE(sr030pc30_sizes);\r\nconst struct sr030pc30_frmsize *fsize = &sr030pc30_sizes[0],\r\n*match = NULL;\r\nwhile (i--) {\r\nint err = abs(fsize->width - mf->width)\r\n+ abs(fsize->height - mf->height);\r\nif (err < min_err) {\r\nmin_err = err;\r\nmatch = fsize;\r\n}\r\nfsize++;\r\n}\r\nif (match) {\r\nmf->width = match->width;\r\nmf->height = match->height;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sr030pc30_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct sr030pc30_info *info =\r\ncontainer_of(ctrl->handler, struct sr030pc30_info, hdl);\r\nstruct v4l2_subdev *sd = &info->sd;\r\nint ret = 0;\r\nv4l2_dbg(1, debug, sd, "%s: ctrl_id: %d, value: %d\n",\r\n__func__, ctrl->id, ctrl->val);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTO_WHITE_BALANCE:\r\nif (ctrl->is_new) {\r\nret = cam_i2c_write(sd, AWB_CTL2_REG,\r\nctrl->val ? 0x2E : 0x2F);\r\nif (!ret)\r\nret = cam_i2c_write(sd, AWB_CTL1_REG,\r\nctrl->val ? 0xFB : 0x7B);\r\n}\r\nif (!ret && info->blue->is_new)\r\nret = cam_i2c_write(sd, MWB_BGAIN_REG, info->blue->val);\r\nif (!ret && info->red->is_new)\r\nret = cam_i2c_write(sd, MWB_RGAIN_REG, info->red->val);\r\nreturn ret;\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nif (ctrl->is_new)\r\nret = cam_i2c_write(sd, AE_CTL1_REG,\r\nctrl->val == V4L2_EXPOSURE_AUTO ? 0xDC : 0x0C);\r\nif (info->exp->is_new) {\r\nunsigned long expos = info->exp->val;\r\nexpos = expos * info->pdata->clk_rate / (8 * 1000);\r\nif (!ret)\r\nret = cam_i2c_write(sd, EXP_TIMEH_REG,\r\nexpos >> 16 & 0xFF);\r\nif (!ret)\r\nret = cam_i2c_write(sd, EXP_TIMEM_REG,\r\nexpos >> 8 & 0xFF);\r\nif (!ret)\r\nret = cam_i2c_write(sd, EXP_TIMEL_REG,\r\nexpos & 0xFF);\r\n}\r\nreturn ret;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sr030pc30_enum_fmt(struct v4l2_subdev *sd, unsigned int index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif (!code || index >= ARRAY_SIZE(sr030pc30_formats))\r\nreturn -EINVAL;\r\n*code = sr030pc30_formats[index].code;\r\nreturn 0;\r\n}\r\nstatic int sr030pc30_g_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct sr030pc30_info *info = to_sr030pc30(sd);\r\nint ret;\r\nif (!mf)\r\nreturn -EINVAL;\r\nif (!info->curr_win || !info->curr_fmt) {\r\nret = sr030pc30_set_params(sd);\r\nif (ret)\r\nreturn ret;\r\n}\r\nmf->width = info->curr_win->width;\r\nmf->height = info->curr_win->height;\r\nmf->code = info->curr_fmt->code;\r\nmf->colorspace = info->curr_fmt->colorspace;\r\nmf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic const struct sr030pc30_format *try_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nint i = ARRAY_SIZE(sr030pc30_formats);\r\nsr030pc30_try_frame_size(mf);\r\nwhile (i--)\r\nif (mf->code == sr030pc30_formats[i].code)\r\nbreak;\r\nmf->code = sr030pc30_formats[i].code;\r\nreturn &sr030pc30_formats[i];\r\n}\r\nstatic int sr030pc30_try_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nif (!sd || !mf)\r\nreturn -EINVAL;\r\ntry_fmt(sd, mf);\r\nreturn 0;\r\n}\r\nstatic int sr030pc30_s_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct sr030pc30_info *info = to_sr030pc30(sd);\r\nif (!sd || !mf)\r\nreturn -EINVAL;\r\ninfo->curr_fmt = try_fmt(sd, mf);\r\nreturn sr030pc30_set_params(sd);\r\n}\r\nstatic int sr030pc30_base_config(struct v4l2_subdev *sd)\r\n{\r\nstruct sr030pc30_info *info = to_sr030pc30(sd);\r\nint ret;\r\nunsigned long expmin, expmax;\r\nret = sr030pc30_bulk_write_reg(sd, sr030pc30_base_regs);\r\nif (!ret) {\r\ninfo->curr_fmt = &sr030pc30_formats[0];\r\ninfo->curr_win = &sr030pc30_sizes[0];\r\nret = sr030pc30_set_params(sd);\r\n}\r\nif (!ret)\r\nret = sr030pc30_pwr_ctrl(sd, false, false);\r\nif (!ret && !info->pdata)\r\nreturn ret;\r\nexpmin = EXPOS_MIN_MS * info->pdata->clk_rate / (8 * 1000);\r\nexpmax = EXPOS_MAX_MS * info->pdata->clk_rate / (8 * 1000);\r\nv4l2_dbg(1, debug, sd, "%s: expmin= %lx, expmax= %lx", __func__,\r\nexpmin, expmax);\r\nret = cam_i2c_write(sd, EXP_MMINH_REG, expmin >> 8 & 0xFF);\r\nif (!ret)\r\nret = cam_i2c_write(sd, EXP_MMINL_REG, expmin & 0xFF);\r\nif (!ret)\r\nret = cam_i2c_write(sd, EXP_MMAXH_REG, expmax >> 16 & 0xFF);\r\nif (!ret)\r\nret = cam_i2c_write(sd, EXP_MMAXM_REG, expmax >> 8 & 0xFF);\r\nif (!ret)\r\nret = cam_i2c_write(sd, EXP_MMAXL_REG, expmax & 0xFF);\r\nreturn ret;\r\n}\r\nstatic int sr030pc30_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct sr030pc30_info *info = to_sr030pc30(sd);\r\nconst struct sr030pc30_platform_data *pdata = info->pdata;\r\nint ret;\r\nif (pdata == NULL) {\r\nWARN(1, "No platform data!\n");\r\nreturn -EINVAL;\r\n}\r\nif (!on)\r\nsr030pc30_pwr_ctrl(sd, false, true);\r\nif (pdata->set_power) {\r\nret = pdata->set_power(&client->dev, on);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (on) {\r\nret = sr030pc30_base_config(sd);\r\n} else {\r\nret = 0;\r\ninfo->curr_win = NULL;\r\ninfo->curr_fmt = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sr030pc30_detect(struct i2c_client *client)\r\n{\r\nconst struct sr030pc30_platform_data *pdata\r\n= client->dev.platform_data;\r\nint ret;\r\nif (pdata->set_power) {\r\nret = pdata->set_power(&client->dev, 1);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = i2c_smbus_read_byte_data(client, DEVICE_ID_REG);\r\nif (pdata->set_power)\r\npdata->set_power(&client->dev, 0);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "%s: I2C read failed\n", __func__);\r\nreturn ret;\r\n}\r\nreturn ret == SR030PC30_ID ? 0 : -ENODEV;\r\n}\r\nstatic int sr030pc30_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct sr030pc30_info *info;\r\nstruct v4l2_subdev *sd;\r\nstruct v4l2_ctrl_handler *hdl;\r\nconst struct sr030pc30_platform_data *pdata\r\n= client->dev.platform_data;\r\nint ret;\r\nif (!pdata) {\r\ndev_err(&client->dev, "No platform data!");\r\nreturn -EIO;\r\n}\r\nret = sr030pc30_detect(client);\r\nif (ret)\r\nreturn ret;\r\ninfo = devm_kzalloc(&client->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nsd = &info->sd;\r\nstrcpy(sd->name, MODULE_NAME);\r\ninfo->pdata = client->dev.platform_data;\r\nv4l2_i2c_subdev_init(sd, client, &sr030pc30_ops);\r\nhdl = &info->hdl;\r\nv4l2_ctrl_handler_init(hdl, 6);\r\ninfo->awb = v4l2_ctrl_new_std(hdl, &sr030pc30_ctrl_ops,\r\nV4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, 1);\r\ninfo->red = v4l2_ctrl_new_std(hdl, &sr030pc30_ctrl_ops,\r\nV4L2_CID_RED_BALANCE, 0, 127, 1, 64);\r\ninfo->blue = v4l2_ctrl_new_std(hdl, &sr030pc30_ctrl_ops,\r\nV4L2_CID_BLUE_BALANCE, 0, 127, 1, 64);\r\ninfo->autoexp = v4l2_ctrl_new_std(hdl, &sr030pc30_ctrl_ops,\r\nV4L2_CID_EXPOSURE_AUTO, 0, 1, 1, 1);\r\ninfo->exp = v4l2_ctrl_new_std(hdl, &sr030pc30_ctrl_ops,\r\nV4L2_CID_EXPOSURE, EXPOS_MIN_MS, EXPOS_MAX_MS, 1, 30);\r\nsd->ctrl_handler = hdl;\r\nif (hdl->error) {\r\nint err = hdl->error;\r\nv4l2_ctrl_handler_free(hdl);\r\nreturn err;\r\n}\r\nv4l2_ctrl_auto_cluster(3, &info->awb, 0, false);\r\nv4l2_ctrl_auto_cluster(2, &info->autoexp, V4L2_EXPOSURE_MANUAL, false);\r\nv4l2_ctrl_handler_setup(hdl);\r\ninfo->i2c_reg_page = -1;\r\ninfo->hflip = 1;\r\nreturn 0;\r\n}\r\nstatic int sr030pc30_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(sd->ctrl_handler);\r\nreturn 0;\r\n}
