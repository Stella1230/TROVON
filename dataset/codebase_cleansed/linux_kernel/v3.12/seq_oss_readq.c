struct seq_oss_readq *\r\nsnd_seq_oss_readq_new(struct seq_oss_devinfo *dp, int maxlen)\r\n{\r\nstruct seq_oss_readq *q;\r\nif ((q = kzalloc(sizeof(*q), GFP_KERNEL)) == NULL) {\r\nsnd_printk(KERN_ERR "can't malloc read queue\n");\r\nreturn NULL;\r\n}\r\nif ((q->q = kcalloc(maxlen, sizeof(union evrec), GFP_KERNEL)) == NULL) {\r\nsnd_printk(KERN_ERR "can't malloc read queue buffer\n");\r\nkfree(q);\r\nreturn NULL;\r\n}\r\nq->maxlen = maxlen;\r\nq->qlen = 0;\r\nq->head = q->tail = 0;\r\ninit_waitqueue_head(&q->midi_sleep);\r\nspin_lock_init(&q->lock);\r\nq->pre_event_timeout = SNDRV_SEQ_OSS_MAX_TIMEOUT;\r\nq->input_time = (unsigned long)-1;\r\nreturn q;\r\n}\r\nvoid\r\nsnd_seq_oss_readq_delete(struct seq_oss_readq *q)\r\n{\r\nif (q) {\r\nkfree(q->q);\r\nkfree(q);\r\n}\r\n}\r\nvoid\r\nsnd_seq_oss_readq_clear(struct seq_oss_readq *q)\r\n{\r\nif (q->qlen) {\r\nq->qlen = 0;\r\nq->head = q->tail = 0;\r\n}\r\nif (waitqueue_active(&q->midi_sleep))\r\nwake_up(&q->midi_sleep);\r\nq->input_time = (unsigned long)-1;\r\n}\r\nint\r\nsnd_seq_oss_readq_puts(struct seq_oss_readq *q, int dev, unsigned char *data, int len)\r\n{\r\nunion evrec rec;\r\nint result;\r\nmemset(&rec, 0, sizeof(rec));\r\nrec.c[0] = SEQ_MIDIPUTC;\r\nrec.c[2] = dev;\r\nwhile (len-- > 0) {\r\nrec.c[1] = *data++;\r\nresult = snd_seq_oss_readq_put_event(q, &rec);\r\nif (result < 0)\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nsnd_seq_oss_readq_put_event(struct seq_oss_readq *q, union evrec *ev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&q->lock, flags);\r\nif (q->qlen >= q->maxlen - 1) {\r\nspin_unlock_irqrestore(&q->lock, flags);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(&q->q[q->tail], ev, sizeof(*ev));\r\nq->tail = (q->tail + 1) % q->maxlen;\r\nq->qlen++;\r\nif (waitqueue_active(&q->midi_sleep))\r\nwake_up(&q->midi_sleep);\r\nspin_unlock_irqrestore(&q->lock, flags);\r\nreturn 0;\r\n}\r\nint\r\nsnd_seq_oss_readq_pick(struct seq_oss_readq *q, union evrec *rec)\r\n{\r\nif (q->qlen == 0)\r\nreturn -EAGAIN;\r\nmemcpy(rec, &q->q[q->head], sizeof(*rec));\r\nreturn 0;\r\n}\r\nvoid\r\nsnd_seq_oss_readq_wait(struct seq_oss_readq *q)\r\n{\r\nwait_event_interruptible_timeout(q->midi_sleep,\r\n(q->qlen > 0 || q->head == q->tail),\r\nq->pre_event_timeout);\r\n}\r\nvoid\r\nsnd_seq_oss_readq_free(struct seq_oss_readq *q)\r\n{\r\nif (q->qlen > 0) {\r\nq->head = (q->head + 1) % q->maxlen;\r\nq->qlen--;\r\n}\r\n}\r\nunsigned int\r\nsnd_seq_oss_readq_poll(struct seq_oss_readq *q, struct file *file, poll_table *wait)\r\n{\r\npoll_wait(file, &q->midi_sleep, wait);\r\nreturn q->qlen;\r\n}\r\nint\r\nsnd_seq_oss_readq_put_timestamp(struct seq_oss_readq *q, unsigned long curt, int seq_mode)\r\n{\r\nif (curt != q->input_time) {\r\nunion evrec rec;\r\nmemset(&rec, 0, sizeof(rec));\r\nswitch (seq_mode) {\r\ncase SNDRV_SEQ_OSS_MODE_SYNTH:\r\nrec.echo = (curt << 8) | SEQ_WAIT;\r\nsnd_seq_oss_readq_put_event(q, &rec);\r\nbreak;\r\ncase SNDRV_SEQ_OSS_MODE_MUSIC:\r\nrec.t.code = EV_TIMING;\r\nrec.t.cmd = TMR_WAIT_ABS;\r\nrec.t.time = curt;\r\nsnd_seq_oss_readq_put_event(q, &rec);\r\nbreak;\r\n}\r\nq->input_time = curt;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nsnd_seq_oss_readq_info_read(struct seq_oss_readq *q, struct snd_info_buffer *buf)\r\n{\r\nsnd_iprintf(buf, " read queue [%s] length = %d : tick = %ld\n",\r\n(waitqueue_active(&q->midi_sleep) ? "sleeping":"running"),\r\nq->qlen, q->input_time);\r\n}
