u8\r\nbrcmf_sdio_chip_getinfidx(struct chip_info *ci, u16 coreid)\r\n{\r\nu8 idx;\r\nfor (idx = 0; idx < BRCMF_MAX_CORENUM; idx++)\r\nif (coreid == ci->c_inf[idx].id)\r\nreturn idx;\r\nreturn BRCMF_MAX_CORENUM;\r\n}\r\nstatic u32\r\nbrcmf_sdio_sb_corerev(struct brcmf_sdio_dev *sdiodev,\r\nstruct chip_info *ci, u16 coreid)\r\n{\r\nu32 regdata;\r\nu8 idx;\r\nidx = brcmf_sdio_chip_getinfidx(ci, coreid);\r\nregdata = brcmf_sdio_regrl(sdiodev,\r\nCORE_SB(ci->c_inf[idx].base, sbidhigh),\r\nNULL);\r\nreturn SBCOREREV(regdata);\r\n}\r\nstatic u32\r\nbrcmf_sdio_ai_corerev(struct brcmf_sdio_dev *sdiodev,\r\nstruct chip_info *ci, u16 coreid)\r\n{\r\nu8 idx;\r\nidx = brcmf_sdio_chip_getinfidx(ci, coreid);\r\nreturn (ci->c_inf[idx].cib & CIB_REV_MASK) >> CIB_REV_SHIFT;\r\n}\r\nstatic bool\r\nbrcmf_sdio_sb_iscoreup(struct brcmf_sdio_dev *sdiodev,\r\nstruct chip_info *ci, u16 coreid)\r\n{\r\nu32 regdata;\r\nu8 idx;\r\nidx = brcmf_sdio_chip_getinfidx(ci, coreid);\r\nregdata = brcmf_sdio_regrl(sdiodev,\r\nCORE_SB(ci->c_inf[idx].base, sbtmstatelow),\r\nNULL);\r\nregdata &= (SSB_TMSLOW_RESET | SSB_TMSLOW_REJECT |\r\nSSB_IMSTATE_REJECT | SSB_TMSLOW_CLOCK);\r\nreturn (SSB_TMSLOW_CLOCK == regdata);\r\n}\r\nstatic bool\r\nbrcmf_sdio_ai_iscoreup(struct brcmf_sdio_dev *sdiodev,\r\nstruct chip_info *ci, u16 coreid)\r\n{\r\nu32 regdata;\r\nu8 idx;\r\nbool ret;\r\nidx = brcmf_sdio_chip_getinfidx(ci, coreid);\r\nregdata = brcmf_sdio_regrl(sdiodev, ci->c_inf[idx].wrapbase+BCMA_IOCTL,\r\nNULL);\r\nret = (regdata & (BCMA_IOCTL_FGC | BCMA_IOCTL_CLK)) == BCMA_IOCTL_CLK;\r\nregdata = brcmf_sdio_regrl(sdiodev,\r\nci->c_inf[idx].wrapbase+BCMA_RESET_CTL,\r\nNULL);\r\nret = ret && ((regdata & BCMA_RESET_CTL_RESET) == 0);\r\nreturn ret;\r\n}\r\nstatic void\r\nbrcmf_sdio_sb_coredisable(struct brcmf_sdio_dev *sdiodev,\r\nstruct chip_info *ci, u16 coreid, u32 core_bits)\r\n{\r\nu32 regdata, base;\r\nu8 idx;\r\nidx = brcmf_sdio_chip_getinfidx(ci, coreid);\r\nbase = ci->c_inf[idx].base;\r\nregdata = brcmf_sdio_regrl(sdiodev, CORE_SB(base, sbtmstatelow), NULL);\r\nif (regdata & SSB_TMSLOW_RESET)\r\nreturn;\r\nregdata = brcmf_sdio_regrl(sdiodev, CORE_SB(base, sbtmstatelow), NULL);\r\nif ((regdata & SSB_TMSLOW_CLOCK) != 0) {\r\nregdata = brcmf_sdio_regrl(sdiodev, CORE_SB(base, sbtmstatelow),\r\nNULL);\r\nbrcmf_sdio_regwl(sdiodev, CORE_SB(base, sbtmstatelow),\r\nregdata | SSB_TMSLOW_REJECT, NULL);\r\nregdata = brcmf_sdio_regrl(sdiodev, CORE_SB(base, sbtmstatelow),\r\nNULL);\r\nudelay(1);\r\nSPINWAIT((brcmf_sdio_regrl(sdiodev,\r\nCORE_SB(base, sbtmstatehigh),\r\nNULL) &\r\nSSB_TMSHIGH_BUSY), 100000);\r\nregdata = brcmf_sdio_regrl(sdiodev,\r\nCORE_SB(base, sbtmstatehigh),\r\nNULL);\r\nif (regdata & SSB_TMSHIGH_BUSY)\r\nbrcmf_err("core state still busy\n");\r\nregdata = brcmf_sdio_regrl(sdiodev, CORE_SB(base, sbidlow),\r\nNULL);\r\nif (regdata & SSB_IDLOW_INITIATOR) {\r\nregdata = brcmf_sdio_regrl(sdiodev,\r\nCORE_SB(base, sbimstate),\r\nNULL);\r\nregdata |= SSB_IMSTATE_REJECT;\r\nbrcmf_sdio_regwl(sdiodev, CORE_SB(base, sbimstate),\r\nregdata, NULL);\r\nregdata = brcmf_sdio_regrl(sdiodev,\r\nCORE_SB(base, sbimstate),\r\nNULL);\r\nudelay(1);\r\nSPINWAIT((brcmf_sdio_regrl(sdiodev,\r\nCORE_SB(base, sbimstate),\r\nNULL) &\r\nSSB_IMSTATE_BUSY), 100000);\r\n}\r\nregdata = SSB_TMSLOW_FGC | SSB_TMSLOW_CLOCK |\r\nSSB_TMSLOW_REJECT | SSB_TMSLOW_RESET;\r\nbrcmf_sdio_regwl(sdiodev, CORE_SB(base, sbtmstatelow),\r\nregdata, NULL);\r\nregdata = brcmf_sdio_regrl(sdiodev, CORE_SB(base, sbtmstatelow),\r\nNULL);\r\nudelay(10);\r\nregdata = brcmf_sdio_regrl(sdiodev, CORE_SB(base, sbidlow),\r\nNULL);\r\nif (regdata & SSB_IDLOW_INITIATOR) {\r\nregdata = brcmf_sdio_regrl(sdiodev,\r\nCORE_SB(base, sbimstate),\r\nNULL);\r\nregdata &= ~SSB_IMSTATE_REJECT;\r\nbrcmf_sdio_regwl(sdiodev, CORE_SB(base, sbimstate),\r\nregdata, NULL);\r\n}\r\n}\r\nbrcmf_sdio_regwl(sdiodev, CORE_SB(base, sbtmstatelow),\r\n(SSB_TMSLOW_REJECT | SSB_TMSLOW_RESET), NULL);\r\nudelay(1);\r\n}\r\nstatic void\r\nbrcmf_sdio_ai_coredisable(struct brcmf_sdio_dev *sdiodev,\r\nstruct chip_info *ci, u16 coreid, u32 core_bits)\r\n{\r\nu8 idx;\r\nu32 regdata;\r\nidx = brcmf_sdio_chip_getinfidx(ci, coreid);\r\nregdata = brcmf_sdio_regrl(sdiodev,\r\nci->c_inf[idx].wrapbase+BCMA_RESET_CTL,\r\nNULL);\r\nif ((regdata & BCMA_RESET_CTL_RESET) != 0)\r\nreturn;\r\nSPINWAIT(brcmf_sdio_regrl(sdiodev,\r\nci->c_inf[idx].wrapbase+BCMA_RESET_ST,\r\nNULL), 10300);\r\nregdata = brcmf_sdio_regrl(sdiodev,\r\nci->c_inf[idx].wrapbase+BCMA_RESET_ST,\r\nNULL);\r\nif (regdata)\r\nbrcmf_err("disabling core 0x%x with reset status %x\n",\r\ncoreid, regdata);\r\nbrcmf_sdio_regwl(sdiodev, ci->c_inf[idx].wrapbase+BCMA_RESET_CTL,\r\nBCMA_RESET_CTL_RESET, NULL);\r\nudelay(1);\r\nbrcmf_sdio_regwl(sdiodev, ci->c_inf[idx].wrapbase+BCMA_IOCTL,\r\ncore_bits, NULL);\r\nregdata = brcmf_sdio_regrl(sdiodev, ci->c_inf[idx].wrapbase+BCMA_IOCTL,\r\nNULL);\r\nusleep_range(10, 20);\r\n}\r\nstatic void\r\nbrcmf_sdio_sb_resetcore(struct brcmf_sdio_dev *sdiodev,\r\nstruct chip_info *ci, u16 coreid, u32 core_bits)\r\n{\r\nu32 regdata;\r\nu8 idx;\r\nidx = brcmf_sdio_chip_getinfidx(ci, coreid);\r\nbrcmf_sdio_sb_coredisable(sdiodev, ci, coreid, 0);\r\nbrcmf_sdio_regwl(sdiodev,\r\nCORE_SB(ci->c_inf[idx].base, sbtmstatelow),\r\nSSB_TMSLOW_FGC | SSB_TMSLOW_CLOCK | SSB_TMSLOW_RESET,\r\nNULL);\r\nregdata = brcmf_sdio_regrl(sdiodev,\r\nCORE_SB(ci->c_inf[idx].base, sbtmstatelow),\r\nNULL);\r\nudelay(1);\r\nregdata = brcmf_sdio_regrl(sdiodev,\r\nCORE_SB(ci->c_inf[idx].base, sbtmstatehigh),\r\nNULL);\r\nif (regdata & SSB_TMSHIGH_SERR)\r\nbrcmf_sdio_regwl(sdiodev,\r\nCORE_SB(ci->c_inf[idx].base, sbtmstatehigh),\r\n0, NULL);\r\nregdata = brcmf_sdio_regrl(sdiodev,\r\nCORE_SB(ci->c_inf[idx].base, sbimstate),\r\nNULL);\r\nif (regdata & (SSB_IMSTATE_IBE | SSB_IMSTATE_TO))\r\nbrcmf_sdio_regwl(sdiodev,\r\nCORE_SB(ci->c_inf[idx].base, sbimstate),\r\nregdata & ~(SSB_IMSTATE_IBE | SSB_IMSTATE_TO),\r\nNULL);\r\nbrcmf_sdio_regwl(sdiodev, CORE_SB(ci->c_inf[idx].base, sbtmstatelow),\r\nSSB_TMSLOW_FGC | SSB_TMSLOW_CLOCK, NULL);\r\nregdata = brcmf_sdio_regrl(sdiodev,\r\nCORE_SB(ci->c_inf[idx].base, sbtmstatelow),\r\nNULL);\r\nudelay(1);\r\nbrcmf_sdio_regwl(sdiodev, CORE_SB(ci->c_inf[idx].base, sbtmstatelow),\r\nSSB_TMSLOW_CLOCK, NULL);\r\nregdata = brcmf_sdio_regrl(sdiodev,\r\nCORE_SB(ci->c_inf[idx].base, sbtmstatelow),\r\nNULL);\r\nudelay(1);\r\n}\r\nstatic void\r\nbrcmf_sdio_ai_resetcore(struct brcmf_sdio_dev *sdiodev,\r\nstruct chip_info *ci, u16 coreid, u32 core_bits)\r\n{\r\nu8 idx;\r\nu32 regdata;\r\nidx = brcmf_sdio_chip_getinfidx(ci, coreid);\r\nbrcmf_sdio_ai_coredisable(sdiodev, ci, coreid, core_bits);\r\nbrcmf_sdio_regwl(sdiodev, ci->c_inf[idx].wrapbase+BCMA_IOCTL,\r\ncore_bits | BCMA_IOCTL_FGC | BCMA_IOCTL_CLK, NULL);\r\nregdata = brcmf_sdio_regrl(sdiodev, ci->c_inf[idx].wrapbase+BCMA_IOCTL,\r\nNULL);\r\nbrcmf_sdio_regwl(sdiodev, ci->c_inf[idx].wrapbase+BCMA_RESET_CTL,\r\n0, NULL);\r\nregdata = brcmf_sdio_regrl(sdiodev,\r\nci->c_inf[idx].wrapbase+BCMA_RESET_CTL,\r\nNULL);\r\nudelay(1);\r\nbrcmf_sdio_regwl(sdiodev, ci->c_inf[idx].wrapbase+BCMA_IOCTL,\r\ncore_bits | BCMA_IOCTL_CLK, NULL);\r\nregdata = brcmf_sdio_regrl(sdiodev, ci->c_inf[idx].wrapbase+BCMA_IOCTL,\r\nNULL);\r\nudelay(1);\r\n}\r\nstatic int brcmf_sdio_chip_cichk(struct chip_info *ci)\r\n{\r\nu8 core_idx;\r\ncore_idx = brcmf_sdio_chip_getinfidx(ci, BCMA_CORE_ARM_CM3);\r\nif (BRCMF_MAX_CORENUM != core_idx) {\r\ncore_idx = brcmf_sdio_chip_getinfidx(ci,\r\nBCMA_CORE_INTERNAL_MEM);\r\nif (BRCMF_MAX_CORENUM == core_idx) {\r\nbrcmf_err("RAM core not provided with ARM CM3 core\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\ncore_idx = brcmf_sdio_chip_getinfidx(ci, BCMA_CORE_ARM_CR4);\r\nif (BRCMF_MAX_CORENUM != core_idx) {\r\nif (ci->rambase == 0) {\r\nbrcmf_err("RAM base not provided with ARM CR4 core\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int brcmf_sdio_chip_cichk(struct chip_info *ci)\r\n{\r\nreturn 0;\r\n}\r\nstatic int brcmf_sdio_chip_recognition(struct brcmf_sdio_dev *sdiodev,\r\nstruct chip_info *ci, u32 regs)\r\n{\r\nu32 regdata;\r\nint ret;\r\nci->c_inf[0].id = BCMA_CORE_CHIPCOMMON;\r\nci->c_inf[0].base = regs;\r\nregdata = brcmf_sdio_regrl(sdiodev,\r\nCORE_CC_REG(ci->c_inf[0].base, chipid),\r\nNULL);\r\nci->chip = regdata & CID_ID_MASK;\r\nci->chiprev = (regdata & CID_REV_MASK) >> CID_REV_SHIFT;\r\nci->socitype = (regdata & CID_TYPE_MASK) >> CID_TYPE_SHIFT;\r\nbrcmf_dbg(INFO, "chipid=0x%x chiprev=%d\n", ci->chip, ci->chiprev);\r\nswitch (ci->chip) {\r\ncase BCM43143_CHIP_ID:\r\nci->c_inf[0].wrapbase = ci->c_inf[0].base + 0x00100000;\r\nci->c_inf[0].cib = 0x2b000000;\r\nci->c_inf[1].id = BCMA_CORE_SDIO_DEV;\r\nci->c_inf[1].base = BCM43143_CORE_BUS_BASE;\r\nci->c_inf[1].wrapbase = ci->c_inf[1].base + 0x00100000;\r\nci->c_inf[1].cib = 0x18000000;\r\nci->c_inf[2].id = BCMA_CORE_INTERNAL_MEM;\r\nci->c_inf[2].base = BCM43143_CORE_SOCRAM_BASE;\r\nci->c_inf[2].wrapbase = ci->c_inf[2].base + 0x00100000;\r\nci->c_inf[2].cib = 0x14000000;\r\nci->c_inf[3].id = BCMA_CORE_ARM_CM3;\r\nci->c_inf[3].base = BCM43143_CORE_ARM_BASE;\r\nci->c_inf[3].wrapbase = ci->c_inf[3].base + 0x00100000;\r\nci->c_inf[3].cib = 0x07000000;\r\nci->ramsize = BCM43143_RAMSIZE;\r\nbreak;\r\ncase BCM43241_CHIP_ID:\r\nci->c_inf[0].wrapbase = 0x18100000;\r\nci->c_inf[0].cib = 0x2a084411;\r\nci->c_inf[1].id = BCMA_CORE_SDIO_DEV;\r\nci->c_inf[1].base = 0x18002000;\r\nci->c_inf[1].wrapbase = 0x18102000;\r\nci->c_inf[1].cib = 0x0e004211;\r\nci->c_inf[2].id = BCMA_CORE_INTERNAL_MEM;\r\nci->c_inf[2].base = 0x18004000;\r\nci->c_inf[2].wrapbase = 0x18104000;\r\nci->c_inf[2].cib = 0x14080401;\r\nci->c_inf[3].id = BCMA_CORE_ARM_CM3;\r\nci->c_inf[3].base = 0x18003000;\r\nci->c_inf[3].wrapbase = 0x18103000;\r\nci->c_inf[3].cib = 0x07004211;\r\nci->ramsize = 0x90000;\r\nbreak;\r\ncase BCM4329_CHIP_ID:\r\nci->c_inf[1].id = BCMA_CORE_SDIO_DEV;\r\nci->c_inf[1].base = BCM4329_CORE_BUS_BASE;\r\nci->c_inf[2].id = BCMA_CORE_INTERNAL_MEM;\r\nci->c_inf[2].base = BCM4329_CORE_SOCRAM_BASE;\r\nci->c_inf[3].id = BCMA_CORE_ARM_CM3;\r\nci->c_inf[3].base = BCM4329_CORE_ARM_BASE;\r\nci->ramsize = BCM4329_RAMSIZE;\r\nbreak;\r\ncase BCM4330_CHIP_ID:\r\nci->c_inf[0].wrapbase = 0x18100000;\r\nci->c_inf[0].cib = 0x27004211;\r\nci->c_inf[1].id = BCMA_CORE_SDIO_DEV;\r\nci->c_inf[1].base = 0x18002000;\r\nci->c_inf[1].wrapbase = 0x18102000;\r\nci->c_inf[1].cib = 0x07004211;\r\nci->c_inf[2].id = BCMA_CORE_INTERNAL_MEM;\r\nci->c_inf[2].base = 0x18004000;\r\nci->c_inf[2].wrapbase = 0x18104000;\r\nci->c_inf[2].cib = 0x0d080401;\r\nci->c_inf[3].id = BCMA_CORE_ARM_CM3;\r\nci->c_inf[3].base = 0x18003000;\r\nci->c_inf[3].wrapbase = 0x18103000;\r\nci->c_inf[3].cib = 0x03004211;\r\nci->ramsize = 0x48000;\r\nbreak;\r\ncase BCM4334_CHIP_ID:\r\nci->c_inf[0].wrapbase = 0x18100000;\r\nci->c_inf[0].cib = 0x29004211;\r\nci->c_inf[1].id = BCMA_CORE_SDIO_DEV;\r\nci->c_inf[1].base = 0x18002000;\r\nci->c_inf[1].wrapbase = 0x18102000;\r\nci->c_inf[1].cib = 0x0d004211;\r\nci->c_inf[2].id = BCMA_CORE_INTERNAL_MEM;\r\nci->c_inf[2].base = 0x18004000;\r\nci->c_inf[2].wrapbase = 0x18104000;\r\nci->c_inf[2].cib = 0x13080401;\r\nci->c_inf[3].id = BCMA_CORE_ARM_CM3;\r\nci->c_inf[3].base = 0x18003000;\r\nci->c_inf[3].wrapbase = 0x18103000;\r\nci->c_inf[3].cib = 0x07004211;\r\nci->ramsize = 0x80000;\r\nbreak;\r\ncase BCM4335_CHIP_ID:\r\nci->c_inf[0].wrapbase = 0x18100000;\r\nci->c_inf[0].cib = 0x2b084411;\r\nci->c_inf[1].id = BCMA_CORE_SDIO_DEV;\r\nci->c_inf[1].base = 0x18005000;\r\nci->c_inf[1].wrapbase = 0x18105000;\r\nci->c_inf[1].cib = 0x0f004211;\r\nci->c_inf[2].id = BCMA_CORE_ARM_CR4;\r\nci->c_inf[2].base = 0x18002000;\r\nci->c_inf[2].wrapbase = 0x18102000;\r\nci->c_inf[2].cib = 0x01084411;\r\nci->ramsize = 0xc0000;\r\nci->rambase = 0x180000;\r\nbreak;\r\ndefault:\r\nbrcmf_err("chipid 0x%x is not supported\n", ci->chip);\r\nreturn -ENODEV;\r\n}\r\nret = brcmf_sdio_chip_cichk(ci);\r\nif (ret)\r\nreturn ret;\r\nswitch (ci->socitype) {\r\ncase SOCI_SB:\r\nci->iscoreup = brcmf_sdio_sb_iscoreup;\r\nci->corerev = brcmf_sdio_sb_corerev;\r\nci->coredisable = brcmf_sdio_sb_coredisable;\r\nci->resetcore = brcmf_sdio_sb_resetcore;\r\nbreak;\r\ncase SOCI_AI:\r\nci->iscoreup = brcmf_sdio_ai_iscoreup;\r\nci->corerev = brcmf_sdio_ai_corerev;\r\nci->coredisable = brcmf_sdio_ai_coredisable;\r\nci->resetcore = brcmf_sdio_ai_resetcore;\r\nbreak;\r\ndefault:\r\nbrcmf_err("socitype %u not supported\n", ci->socitype);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbrcmf_sdio_chip_buscoreprep(struct brcmf_sdio_dev *sdiodev)\r\n{\r\nint err = 0;\r\nu8 clkval, clkset;\r\nclkset = SBSDIO_FORCE_HW_CLKREQ_OFF | SBSDIO_ALP_AVAIL_REQ;\r\nbrcmf_sdio_regwb(sdiodev, SBSDIO_FUNC1_CHIPCLKCSR, clkset, &err);\r\nif (err) {\r\nbrcmf_err("error writing for HT off\n");\r\nreturn err;\r\n}\r\nclkval = brcmf_sdio_regrb(sdiodev,\r\nSBSDIO_FUNC1_CHIPCLKCSR, NULL);\r\nif ((clkval & ~SBSDIO_AVBITS) != clkset) {\r\nbrcmf_err("ChipClkCSR access: wrote 0x%02x read 0x%02x\n",\r\nclkset, clkval);\r\nreturn -EACCES;\r\n}\r\nSPINWAIT(((clkval = brcmf_sdio_regrb(sdiodev,\r\nSBSDIO_FUNC1_CHIPCLKCSR, NULL)),\r\n!SBSDIO_ALPAV(clkval)),\r\nPMU_MAX_TRANSITION_DLY);\r\nif (!SBSDIO_ALPAV(clkval)) {\r\nbrcmf_err("timeout on ALPAV wait, clkval 0x%02x\n",\r\nclkval);\r\nreturn -EBUSY;\r\n}\r\nclkset = SBSDIO_FORCE_HW_CLKREQ_OFF | SBSDIO_FORCE_ALP;\r\nbrcmf_sdio_regwb(sdiodev, SBSDIO_FUNC1_CHIPCLKCSR, clkset, &err);\r\nudelay(65);\r\nbrcmf_sdio_regwb(sdiodev, SBSDIO_FUNC1_SDIOPULLUP, 0, NULL);\r\nreturn 0;\r\n}\r\nstatic void\r\nbrcmf_sdio_chip_buscoresetup(struct brcmf_sdio_dev *sdiodev,\r\nstruct chip_info *ci)\r\n{\r\nu32 base = ci->c_inf[0].base;\r\nci->c_inf[0].rev = ci->corerev(sdiodev, ci, ci->c_inf[0].id);\r\nci->c_inf[0].caps = brcmf_sdio_regrl(sdiodev,\r\nCORE_CC_REG(base, capabilities),\r\nNULL);\r\nif (ci->c_inf[0].caps & CC_CAP_PMU) {\r\nci->pmucaps =\r\nbrcmf_sdio_regrl(sdiodev,\r\nCORE_CC_REG(base, pmucapabilities),\r\nNULL);\r\nci->pmurev = ci->pmucaps & PCAP_REV_MASK;\r\n}\r\nci->c_inf[1].rev = ci->corerev(sdiodev, ci, ci->c_inf[1].id);\r\nbrcmf_dbg(INFO, "ccrev=%d, pmurev=%d, buscore rev/type=%d/0x%x\n",\r\nci->c_inf[0].rev, ci->pmurev,\r\nci->c_inf[1].rev, ci->c_inf[1].id);\r\nci->coredisable(sdiodev, ci, BCMA_CORE_ARM_CM3, 0);\r\n}\r\nint brcmf_sdio_chip_attach(struct brcmf_sdio_dev *sdiodev,\r\nstruct chip_info **ci_ptr, u32 regs)\r\n{\r\nint ret;\r\nstruct chip_info *ci;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nci = kzalloc(sizeof(struct chip_info), GFP_ATOMIC);\r\nif (!ci)\r\nreturn -ENOMEM;\r\nret = brcmf_sdio_chip_buscoreprep(sdiodev);\r\nif (ret != 0)\r\ngoto err;\r\nret = brcmf_sdio_chip_recognition(sdiodev, ci, regs);\r\nif (ret != 0)\r\ngoto err;\r\nbrcmf_sdio_chip_buscoresetup(sdiodev, ci);\r\nbrcmf_sdio_regwl(sdiodev, CORE_CC_REG(ci->c_inf[0].base, gpiopullup),\r\n0, NULL);\r\nbrcmf_sdio_regwl(sdiodev, CORE_CC_REG(ci->c_inf[0].base, gpiopulldown),\r\n0, NULL);\r\n*ci_ptr = ci;\r\nreturn 0;\r\nerr:\r\nkfree(ci);\r\nreturn ret;\r\n}\r\nvoid\r\nbrcmf_sdio_chip_detach(struct chip_info **ci_ptr)\r\n{\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nkfree(*ci_ptr);\r\n*ci_ptr = NULL;\r\n}\r\nstatic char *brcmf_sdio_chip_name(uint chipid, char *buf, uint len)\r\n{\r\nconst char *fmt;\r\nfmt = ((chipid > 0xa000) || (chipid < 0x4000)) ? "%d" : "%x";\r\nsnprintf(buf, len, fmt, chipid);\r\nreturn buf;\r\n}\r\nvoid\r\nbrcmf_sdio_chip_drivestrengthinit(struct brcmf_sdio_dev *sdiodev,\r\nstruct chip_info *ci, u32 drivestrength)\r\n{\r\nconst struct sdiod_drive_str *str_tab = NULL;\r\nu32 str_mask;\r\nu32 str_shift;\r\nchar chn[8];\r\nu32 base = ci->c_inf[0].base;\r\nu32 i;\r\nu32 drivestrength_sel = 0;\r\nu32 cc_data_temp;\r\nu32 addr;\r\nif (!(ci->c_inf[0].caps & CC_CAP_PMU))\r\nreturn;\r\nswitch (SDIOD_DRVSTR_KEY(ci->chip, ci->pmurev)) {\r\ncase SDIOD_DRVSTR_KEY(BCM4330_CHIP_ID, 12):\r\nstr_tab = sdiod_drvstr_tab1_1v8;\r\nstr_mask = 0x00003800;\r\nstr_shift = 11;\r\nbreak;\r\ncase SDIOD_DRVSTR_KEY(BCM43143_CHIP_ID, 17):\r\ni = ARRAY_SIZE(sdiod_drvstr_tab2_3v3) - 1;\r\nif (drivestrength >= sdiod_drvstr_tab2_3v3[i].strength) {\r\nstr_tab = sdiod_drvstr_tab2_3v3;\r\nstr_mask = 0x00000007;\r\nstr_shift = 0;\r\n} else\r\nbrcmf_err("Invalid SDIO Drive strength for chip %s, strength=%d\n",\r\nbrcmf_sdio_chip_name(ci->chip, chn, 8),\r\ndrivestrength);\r\nbreak;\r\ndefault:\r\nbrcmf_err("No SDIO Drive strength init done for chip %s rev %d pmurev %d\n",\r\nbrcmf_sdio_chip_name(ci->chip, chn, 8),\r\nci->chiprev, ci->pmurev);\r\nbreak;\r\n}\r\nif (str_tab != NULL) {\r\nfor (i = 0; str_tab[i].strength != 0; i++) {\r\nif (drivestrength >= str_tab[i].strength) {\r\ndrivestrength_sel = str_tab[i].sel;\r\nbreak;\r\n}\r\n}\r\naddr = CORE_CC_REG(base, chipcontrol_addr);\r\nbrcmf_sdio_regwl(sdiodev, addr, 1, NULL);\r\ncc_data_temp = brcmf_sdio_regrl(sdiodev, addr, NULL);\r\ncc_data_temp &= ~str_mask;\r\ndrivestrength_sel <<= str_shift;\r\ncc_data_temp |= drivestrength_sel;\r\nbrcmf_sdio_regwl(sdiodev, addr, cc_data_temp, NULL);\r\nbrcmf_dbg(INFO, "SDIO: %d mA (req=%d mA) drive strength selected, set to 0x%08x\n",\r\nstr_tab[i].strength, drivestrength, cc_data_temp);\r\n}\r\n}\r\nstatic bool\r\nbrcmf_sdio_chip_verifynvram(struct brcmf_sdio_dev *sdiodev, u32 nvram_addr,\r\nchar *nvram_dat, uint nvram_sz)\r\n{\r\nchar *nvram_ularray;\r\nint err;\r\nbool ret = true;\r\nbrcmf_dbg(INFO, "Compare NVRAM dl & ul; size=%d\n", nvram_sz);\r\nnvram_ularray = kmalloc(nvram_sz, GFP_KERNEL);\r\nif (!nvram_ularray)\r\nreturn true;\r\nmemset(nvram_ularray, 0xaa, nvram_sz);\r\nerr = brcmf_sdio_ramrw(sdiodev, false, nvram_addr, nvram_ularray,\r\nnvram_sz);\r\nif (err) {\r\nbrcmf_err("error %d on reading %d nvram bytes at 0x%08x\n",\r\nerr, nvram_sz, nvram_addr);\r\n} else if (memcmp(nvram_dat, nvram_ularray, nvram_sz)) {\r\nbrcmf_err("Downloaded NVRAM image is corrupted\n");\r\nret = false;\r\n}\r\nkfree(nvram_ularray);\r\nreturn ret;\r\n}\r\nstatic inline bool\r\nbrcmf_sdio_chip_verifynvram(struct brcmf_sdio_dev *sdiodev, u32 nvram_addr,\r\nchar *nvram_dat, uint nvram_sz)\r\n{\r\nreturn true;\r\n}\r\nstatic bool brcmf_sdio_chip_writenvram(struct brcmf_sdio_dev *sdiodev,\r\nstruct chip_info *ci,\r\nchar *nvram_dat, uint nvram_sz)\r\n{\r\nint err;\r\nu32 nvram_addr;\r\nu32 token;\r\n__le32 token_le;\r\nnvram_addr = (ci->ramsize - 4) - nvram_sz + ci->rambase;\r\nerr = brcmf_sdio_ramrw(sdiodev, true, nvram_addr, nvram_dat, nvram_sz);\r\nif (err) {\r\nbrcmf_err("error %d on writing %d nvram bytes at 0x%08x\n",\r\nerr, nvram_sz, nvram_addr);\r\nreturn false;\r\n}\r\nif (!brcmf_sdio_chip_verifynvram(sdiodev, nvram_addr,\r\nnvram_dat, nvram_sz))\r\nreturn false;\r\ntoken = nvram_sz / 4;\r\ntoken = (~token << 16) | (token & 0x0000FFFF);\r\ntoken_le = cpu_to_le32(token);\r\nbrcmf_dbg(INFO, "RAM size: %d\n", ci->ramsize);\r\nbrcmf_dbg(INFO, "nvram is placed at %d, size %d, token=0x%08x\n",\r\nnvram_addr, nvram_sz, token);\r\nif (brcmf_sdio_ramrw(sdiodev, true, (ci->ramsize - 4 + ci->rambase),\r\n(u8 *)&token_le, 4))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void\r\nbrcmf_sdio_chip_cm3_enterdl(struct brcmf_sdio_dev *sdiodev,\r\nstruct chip_info *ci)\r\n{\r\nu32 zeros = 0;\r\nci->coredisable(sdiodev, ci, BCMA_CORE_ARM_CM3, 0);\r\nci->resetcore(sdiodev, ci, BCMA_CORE_INTERNAL_MEM, 0);\r\nbrcmf_sdio_ramrw(sdiodev, true, ci->ramsize - 4, (u8 *)&zeros, 4);\r\n}\r\nstatic bool\r\nbrcmf_sdio_chip_cm3_exitdl(struct brcmf_sdio_dev *sdiodev, struct chip_info *ci,\r\nchar *nvram_dat, uint nvram_sz)\r\n{\r\nu8 core_idx;\r\nu32 reg_addr;\r\nif (!ci->iscoreup(sdiodev, ci, BCMA_CORE_INTERNAL_MEM)) {\r\nbrcmf_err("SOCRAM core is down after reset?\n");\r\nreturn false;\r\n}\r\nif (!brcmf_sdio_chip_writenvram(sdiodev, ci, nvram_dat, nvram_sz))\r\nreturn false;\r\ncore_idx = brcmf_sdio_chip_getinfidx(ci, BCMA_CORE_SDIO_DEV);\r\nreg_addr = ci->c_inf[core_idx].base;\r\nreg_addr += offsetof(struct sdpcmd_regs, intstatus);\r\nbrcmf_sdio_regwl(sdiodev, reg_addr, 0xFFFFFFFF, NULL);\r\nci->resetcore(sdiodev, ci, BCMA_CORE_ARM_CM3, 0);\r\nreturn true;\r\n}\r\nstatic inline void\r\nbrcmf_sdio_chip_cr4_enterdl(struct brcmf_sdio_dev *sdiodev,\r\nstruct chip_info *ci)\r\n{\r\nci->resetcore(sdiodev, ci, BCMA_CORE_ARM_CR4,\r\nARMCR4_BCMA_IOCTL_CPUHALT);\r\n}\r\nstatic bool\r\nbrcmf_sdio_chip_cr4_exitdl(struct brcmf_sdio_dev *sdiodev, struct chip_info *ci,\r\nchar *nvram_dat, uint nvram_sz)\r\n{\r\nu8 core_idx;\r\nu32 reg_addr;\r\nif (!brcmf_sdio_chip_writenvram(sdiodev, ci, nvram_dat, nvram_sz))\r\nreturn false;\r\ncore_idx = brcmf_sdio_chip_getinfidx(ci, BCMA_CORE_SDIO_DEV);\r\nreg_addr = ci->c_inf[core_idx].base;\r\nreg_addr += offsetof(struct sdpcmd_regs, intstatus);\r\nbrcmf_sdio_regwl(sdiodev, reg_addr, 0xFFFFFFFF, NULL);\r\nbrcmf_sdio_ramrw(sdiodev, true, 0, (void *)&ci->rst_vec,\r\nsizeof(ci->rst_vec));\r\nci->resetcore(sdiodev, ci, BCMA_CORE_ARM_CR4, 0);\r\nreturn true;\r\n}\r\nvoid brcmf_sdio_chip_enter_download(struct brcmf_sdio_dev *sdiodev,\r\nstruct chip_info *ci)\r\n{\r\nu8 arm_core_idx;\r\narm_core_idx = brcmf_sdio_chip_getinfidx(ci, BCMA_CORE_ARM_CM3);\r\nif (BRCMF_MAX_CORENUM != arm_core_idx) {\r\nbrcmf_sdio_chip_cm3_enterdl(sdiodev, ci);\r\nreturn;\r\n}\r\nbrcmf_sdio_chip_cr4_enterdl(sdiodev, ci);\r\n}\r\nbool brcmf_sdio_chip_exit_download(struct brcmf_sdio_dev *sdiodev,\r\nstruct chip_info *ci, char *nvram_dat,\r\nuint nvram_sz)\r\n{\r\nu8 arm_core_idx;\r\narm_core_idx = brcmf_sdio_chip_getinfidx(ci, BCMA_CORE_ARM_CM3);\r\nif (BRCMF_MAX_CORENUM != arm_core_idx)\r\nreturn brcmf_sdio_chip_cm3_exitdl(sdiodev, ci, nvram_dat,\r\nnvram_sz);\r\nreturn brcmf_sdio_chip_cr4_exitdl(sdiodev, ci, nvram_dat, nvram_sz);\r\n}
