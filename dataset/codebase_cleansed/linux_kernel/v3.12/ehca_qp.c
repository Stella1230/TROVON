static inline enum ehca_qp_state ib2ehca_qp_state(enum ib_qp_state ib_qp_state)\r\n{\r\nswitch (ib_qp_state) {\r\ncase IB_QPS_RESET:\r\nreturn EHCA_QPS_RESET;\r\ncase IB_QPS_INIT:\r\nreturn EHCA_QPS_INIT;\r\ncase IB_QPS_RTR:\r\nreturn EHCA_QPS_RTR;\r\ncase IB_QPS_RTS:\r\nreturn EHCA_QPS_RTS;\r\ncase IB_QPS_SQD:\r\nreturn EHCA_QPS_SQD;\r\ncase IB_QPS_SQE:\r\nreturn EHCA_QPS_SQE;\r\ncase IB_QPS_ERR:\r\nreturn EHCA_QPS_ERR;\r\ndefault:\r\nehca_gen_err("invalid ib_qp_state=%x", ib_qp_state);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic inline enum ib_qp_state ehca2ib_qp_state(enum ehca_qp_state\r\nehca_qp_state)\r\n{\r\nswitch (ehca_qp_state) {\r\ncase EHCA_QPS_RESET:\r\nreturn IB_QPS_RESET;\r\ncase EHCA_QPS_INIT:\r\nreturn IB_QPS_INIT;\r\ncase EHCA_QPS_RTR:\r\nreturn IB_QPS_RTR;\r\ncase EHCA_QPS_RTS:\r\nreturn IB_QPS_RTS;\r\ncase EHCA_QPS_SQD:\r\nreturn IB_QPS_SQD;\r\ncase EHCA_QPS_SQE:\r\nreturn IB_QPS_SQE;\r\ncase EHCA_QPS_ERR:\r\nreturn IB_QPS_ERR;\r\ndefault:\r\nehca_gen_err("invalid ehca_qp_state=%x", ehca_qp_state);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic inline enum ehca_qp_type ib2ehcaqptype(enum ib_qp_type ibqptype)\r\n{\r\nswitch (ibqptype) {\r\ncase IB_QPT_SMI:\r\ncase IB_QPT_GSI:\r\nreturn QPT_SQP;\r\ncase IB_QPT_RC:\r\nreturn QPT_RC;\r\ncase IB_QPT_UC:\r\nreturn QPT_UC;\r\ncase IB_QPT_UD:\r\nreturn QPT_UD;\r\ndefault:\r\nehca_gen_err("Invalid ibqptype=%x", ibqptype);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic inline enum ib_qp_statetrans get_modqp_statetrans(int ib_fromstate,\r\nint ib_tostate)\r\n{\r\nint index = -EINVAL;\r\nswitch (ib_tostate) {\r\ncase IB_QPS_RESET:\r\nindex = IB_QPST_ANY2RESET;\r\nbreak;\r\ncase IB_QPS_INIT:\r\nswitch (ib_fromstate) {\r\ncase IB_QPS_RESET:\r\nindex = IB_QPST_RESET2INIT;\r\nbreak;\r\ncase IB_QPS_INIT:\r\nindex = IB_QPST_INIT2INIT;\r\nbreak;\r\n}\r\nbreak;\r\ncase IB_QPS_RTR:\r\nif (ib_fromstate == IB_QPS_INIT)\r\nindex = IB_QPST_INIT2RTR;\r\nbreak;\r\ncase IB_QPS_RTS:\r\nswitch (ib_fromstate) {\r\ncase IB_QPS_RTR:\r\nindex = IB_QPST_RTR2RTS;\r\nbreak;\r\ncase IB_QPS_RTS:\r\nindex = IB_QPST_RTS2RTS;\r\nbreak;\r\ncase IB_QPS_SQD:\r\nindex = IB_QPST_SQD2RTS;\r\nbreak;\r\ncase IB_QPS_SQE:\r\nindex = IB_QPST_SQE2RTS;\r\nbreak;\r\n}\r\nbreak;\r\ncase IB_QPS_SQD:\r\nif (ib_fromstate == IB_QPS_RTS)\r\nindex = IB_QPST_RTS2SQD;\r\nbreak;\r\ncase IB_QPS_SQE:\r\nbreak;\r\ncase IB_QPS_ERR:\r\nindex = IB_QPST_ANY2ERR;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn index;\r\n}\r\nstatic inline int ibqptype2servicetype(enum ib_qp_type ibqptype)\r\n{\r\nswitch (ibqptype) {\r\ncase IB_QPT_SMI:\r\ncase IB_QPT_GSI:\r\nreturn ST_UD;\r\ncase IB_QPT_RC:\r\nreturn ST_RC;\r\ncase IB_QPT_UC:\r\nreturn ST_UC;\r\ncase IB_QPT_UD:\r\nreturn ST_UD;\r\ncase IB_QPT_RAW_IPV6:\r\nreturn -EINVAL;\r\ncase IB_QPT_RAW_ETHERTYPE:\r\nreturn -EINVAL;\r\ndefault:\r\nehca_gen_err("Invalid ibqptype=%x", ibqptype);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic inline void queue2resp(struct ipzu_queue_resp *resp,\r\nstruct ipz_queue *queue)\r\n{\r\nresp->qe_size = queue->qe_size;\r\nresp->act_nr_of_sg = queue->act_nr_of_sg;\r\nresp->queue_length = queue->queue_length;\r\nresp->pagesize = queue->pagesize;\r\nresp->toggle_state = queue->toggle_state;\r\nresp->offset = queue->offset;\r\n}\r\nstatic inline int init_qp_queue(struct ehca_shca *shca,\r\nstruct ehca_pd *pd,\r\nstruct ehca_qp *my_qp,\r\nstruct ipz_queue *queue,\r\nint q_type,\r\nu64 expected_hret,\r\nstruct ehca_alloc_queue_parms *parms,\r\nint wqe_size)\r\n{\r\nint ret, cnt, ipz_rc, nr_q_pages;\r\nvoid *vpage;\r\nu64 rpage, h_ret;\r\nstruct ib_device *ib_dev = &shca->ib_device;\r\nstruct ipz_adapter_handle ipz_hca_handle = shca->ipz_hca_handle;\r\nif (!parms->queue_size)\r\nreturn 0;\r\nif (parms->is_small) {\r\nnr_q_pages = 1;\r\nipz_rc = ipz_queue_ctor(pd, queue, nr_q_pages,\r\n128 << parms->page_size,\r\nwqe_size, parms->act_nr_sges, 1);\r\n} else {\r\nnr_q_pages = parms->queue_size;\r\nipz_rc = ipz_queue_ctor(pd, queue, nr_q_pages,\r\nEHCA_PAGESIZE, wqe_size,\r\nparms->act_nr_sges, 0);\r\n}\r\nif (!ipz_rc) {\r\nehca_err(ib_dev, "Cannot allocate page for queue. ipz_rc=%i",\r\nipz_rc);\r\nreturn -EBUSY;\r\n}\r\nfor (cnt = 0; cnt < nr_q_pages; cnt++) {\r\nvpage = ipz_qpageit_get_inc(queue);\r\nif (!vpage) {\r\nehca_err(ib_dev, "ipz_qpageit_get_inc() "\r\n"failed p_vpage= %p", vpage);\r\nret = -EINVAL;\r\ngoto init_qp_queue1;\r\n}\r\nrpage = __pa(vpage);\r\nh_ret = hipz_h_register_rpage_qp(ipz_hca_handle,\r\nmy_qp->ipz_qp_handle,\r\nNULL, 0, q_type,\r\nrpage, parms->is_small ? 0 : 1,\r\nmy_qp->galpas.kernel);\r\nif (cnt == (nr_q_pages - 1)) {\r\nif (h_ret != expected_hret) {\r\nehca_err(ib_dev, "hipz_qp_register_rpage() "\r\n"h_ret=%lli", h_ret);\r\nret = ehca2ib_return_code(h_ret);\r\ngoto init_qp_queue1;\r\n}\r\nvpage = ipz_qpageit_get_inc(&my_qp->ipz_rqueue);\r\nif (vpage) {\r\nehca_err(ib_dev, "ipz_qpageit_get_inc() "\r\n"should not succeed vpage=%p", vpage);\r\nret = -EINVAL;\r\ngoto init_qp_queue1;\r\n}\r\n} else {\r\nif (h_ret != H_PAGE_REGISTERED) {\r\nehca_err(ib_dev, "hipz_qp_register_rpage() "\r\n"h_ret=%lli", h_ret);\r\nret = ehca2ib_return_code(h_ret);\r\ngoto init_qp_queue1;\r\n}\r\n}\r\n}\r\nipz_qeit_reset(queue);\r\nreturn 0;\r\ninit_qp_queue1:\r\nipz_queue_dtor(pd, queue);\r\nreturn ret;\r\n}\r\nstatic inline int ehca_calc_wqe_size(int act_nr_sge, int is_llqp)\r\n{\r\nif (is_llqp)\r\nreturn 128 << act_nr_sge;\r\nelse\r\nreturn offsetof(struct ehca_wqe,\r\nu.nud.sg_list[act_nr_sge]);\r\n}\r\nstatic void ehca_determine_small_queue(struct ehca_alloc_queue_parms *queue,\r\nint req_nr_sge, int is_llqp)\r\n{\r\nu32 wqe_size, q_size;\r\nint act_nr_sge = req_nr_sge;\r\nif (!is_llqp)\r\nfor (act_nr_sge = 4; act_nr_sge <= 252;\r\nact_nr_sge = 4 + 2 * act_nr_sge)\r\nif (act_nr_sge >= req_nr_sge)\r\nbreak;\r\nwqe_size = ehca_calc_wqe_size(act_nr_sge, is_llqp);\r\nq_size = wqe_size * (queue->max_wr + 1);\r\nif (q_size <= 512)\r\nqueue->page_size = 2;\r\nelse if (q_size <= 1024)\r\nqueue->page_size = 3;\r\nelse\r\nqueue->page_size = 0;\r\nqueue->is_small = (queue->page_size != 0);\r\n}\r\nvoid ehca_add_to_err_list(struct ehca_qp *qp, int on_sq)\r\n{\r\nstruct list_head *list, *node;\r\nif (qp->ext_type == EQPT_LLQP)\r\nreturn;\r\nif (on_sq) {\r\nlist = &qp->send_cq->sqp_err_list;\r\nnode = &qp->sq_err_node;\r\n} else {\r\nlist = &qp->recv_cq->rqp_err_list;\r\nnode = &qp->rq_err_node;\r\n}\r\nif (list_empty(node))\r\nlist_add_tail(node, list);\r\nreturn;\r\n}\r\nstatic void del_from_err_list(struct ehca_cq *cq, struct list_head *node)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cq->spinlock, flags);\r\nif (!list_empty(node))\r\nlist_del_init(node);\r\nspin_unlock_irqrestore(&cq->spinlock, flags);\r\n}\r\nstatic void reset_queue_map(struct ehca_queue_map *qmap)\r\n{\r\nint i;\r\nqmap->tail = qmap->entries - 1;\r\nqmap->left_to_poll = 0;\r\nqmap->next_wqe_idx = 0;\r\nfor (i = 0; i < qmap->entries; i++) {\r\nqmap->map[i].reported = 1;\r\nqmap->map[i].cqe_req = 0;\r\n}\r\n}\r\nstatic struct ehca_qp *internal_create_qp(\r\nstruct ib_pd *pd,\r\nstruct ib_qp_init_attr *init_attr,\r\nstruct ib_srq_init_attr *srq_init_attr,\r\nstruct ib_udata *udata, int is_srq)\r\n{\r\nstruct ehca_qp *my_qp, *my_srq = NULL;\r\nstruct ehca_pd *my_pd = container_of(pd, struct ehca_pd, ib_pd);\r\nstruct ehca_shca *shca = container_of(pd->device, struct ehca_shca,\r\nib_device);\r\nstruct ib_ucontext *context = NULL;\r\nu64 h_ret;\r\nint is_llqp = 0, has_srq = 0, is_user = 0;\r\nint qp_type, max_send_sge, max_recv_sge, ret;\r\nstruct ehca_alloc_qp_parms parms;\r\nu32 swqe_size = 0, rwqe_size = 0, ib_qp_num;\r\nunsigned long flags;\r\nif (!atomic_add_unless(&shca->num_qps, 1, shca->max_num_qps)) {\r\nehca_err(pd->device, "Unable to create QP, max number of %i "\r\n"QPs reached.", shca->max_num_qps);\r\nehca_err(pd->device, "To increase the maximum number of QPs "\r\n"use the number_of_qps module parameter.\n");\r\nreturn ERR_PTR(-ENOSPC);\r\n}\r\nif (init_attr->create_flags) {\r\natomic_dec(&shca->num_qps);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nmemset(&parms, 0, sizeof(parms));\r\nqp_type = init_attr->qp_type;\r\nif (init_attr->sq_sig_type != IB_SIGNAL_REQ_WR &&\r\ninit_attr->sq_sig_type != IB_SIGNAL_ALL_WR) {\r\nehca_err(pd->device, "init_attr->sg_sig_type=%x not allowed",\r\ninit_attr->sq_sig_type);\r\natomic_dec(&shca->num_qps);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (qp_type & 0x80) {\r\nis_llqp = 1;\r\nparms.ext_type = EQPT_LLQP;\r\nparms.ll_comp_flags = qp_type & LLQP_COMP_MASK;\r\n}\r\nqp_type &= 0x1F;\r\ninit_attr->qp_type &= 0x1F;\r\nif (init_attr->srq) {\r\nmy_srq = container_of(init_attr->srq, struct ehca_qp, ib_srq);\r\nif (qp_type == IB_QPT_UC) {\r\nehca_err(pd->device, "UC with SRQ not supported");\r\natomic_dec(&shca->num_qps);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nhas_srq = 1;\r\nparms.ext_type = EQPT_SRQBASE;\r\nparms.srq_qpn = my_srq->real_qp_num;\r\n}\r\nif (is_llqp && has_srq) {\r\nehca_err(pd->device, "LLQPs can't have an SRQ");\r\natomic_dec(&shca->num_qps);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (is_srq) {\r\nparms.ext_type = EQPT_SRQ;\r\nparms.srq_limit = srq_init_attr->attr.srq_limit;\r\nif (init_attr->cap.max_recv_sge > 3) {\r\nehca_err(pd->device, "no more than three SGEs "\r\n"supported for SRQ pd=%p max_sge=%x",\r\npd, init_attr->cap.max_recv_sge);\r\natomic_dec(&shca->num_qps);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n}\r\nif (qp_type != IB_QPT_UD &&\r\nqp_type != IB_QPT_UC &&\r\nqp_type != IB_QPT_RC &&\r\nqp_type != IB_QPT_SMI &&\r\nqp_type != IB_QPT_GSI) {\r\nehca_err(pd->device, "wrong QP Type=%x", qp_type);\r\natomic_dec(&shca->num_qps);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (is_llqp) {\r\nswitch (qp_type) {\r\ncase IB_QPT_RC:\r\nif ((init_attr->cap.max_send_wr > 255) ||\r\n(init_attr->cap.max_recv_wr > 255)) {\r\nehca_err(pd->device,\r\n"Invalid Number of max_sq_wr=%x "\r\n"or max_rq_wr=%x for RC LLQP",\r\ninit_attr->cap.max_send_wr,\r\ninit_attr->cap.max_recv_wr);\r\natomic_dec(&shca->num_qps);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nbreak;\r\ncase IB_QPT_UD:\r\nif (!EHCA_BMASK_GET(HCA_CAP_UD_LL_QP, shca->hca_cap)) {\r\nehca_err(pd->device, "UD LLQP not supported "\r\n"by this adapter");\r\natomic_dec(&shca->num_qps);\r\nreturn ERR_PTR(-ENOSYS);\r\n}\r\nif (!(init_attr->cap.max_send_sge <= 5\r\n&& init_attr->cap.max_send_sge >= 1\r\n&& init_attr->cap.max_recv_sge <= 5\r\n&& init_attr->cap.max_recv_sge >= 1)) {\r\nehca_err(pd->device,\r\n"Invalid Number of max_send_sge=%x "\r\n"or max_recv_sge=%x for UD LLQP",\r\ninit_attr->cap.max_send_sge,\r\ninit_attr->cap.max_recv_sge);\r\natomic_dec(&shca->num_qps);\r\nreturn ERR_PTR(-EINVAL);\r\n} else if (init_attr->cap.max_send_wr > 255) {\r\nehca_err(pd->device,\r\n"Invalid Number of "\r\n"max_send_wr=%x for UD QP_TYPE=%x",\r\ninit_attr->cap.max_send_wr, qp_type);\r\natomic_dec(&shca->num_qps);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nbreak;\r\ndefault:\r\nehca_err(pd->device, "unsupported LL QP Type=%x",\r\nqp_type);\r\natomic_dec(&shca->num_qps);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n} else {\r\nint max_sge = (qp_type == IB_QPT_UD || qp_type == IB_QPT_SMI\r\n|| qp_type == IB_QPT_GSI) ? 250 : 252;\r\nif (init_attr->cap.max_send_sge > max_sge\r\n|| init_attr->cap.max_recv_sge > max_sge) {\r\nehca_err(pd->device, "Invalid number of SGEs requested "\r\n"send_sge=%x recv_sge=%x max_sge=%x",\r\ninit_attr->cap.max_send_sge,\r\ninit_attr->cap.max_recv_sge, max_sge);\r\natomic_dec(&shca->num_qps);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n}\r\nmy_qp = kmem_cache_zalloc(qp_cache, GFP_KERNEL);\r\nif (!my_qp) {\r\nehca_err(pd->device, "pd=%p not enough memory to alloc qp", pd);\r\natomic_dec(&shca->num_qps);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nif (pd->uobject && udata) {\r\nis_user = 1;\r\ncontext = pd->uobject->context;\r\n}\r\natomic_set(&my_qp->nr_events, 0);\r\ninit_waitqueue_head(&my_qp->wait_completion);\r\nspin_lock_init(&my_qp->spinlock_s);\r\nspin_lock_init(&my_qp->spinlock_r);\r\nmy_qp->qp_type = qp_type;\r\nmy_qp->ext_type = parms.ext_type;\r\nmy_qp->state = IB_QPS_RESET;\r\nif (init_attr->recv_cq)\r\nmy_qp->recv_cq =\r\ncontainer_of(init_attr->recv_cq, struct ehca_cq, ib_cq);\r\nif (init_attr->send_cq)\r\nmy_qp->send_cq =\r\ncontainer_of(init_attr->send_cq, struct ehca_cq, ib_cq);\r\nidr_preload(GFP_KERNEL);\r\nwrite_lock_irqsave(&ehca_qp_idr_lock, flags);\r\nret = idr_alloc(&ehca_qp_idr, my_qp, 0, 0x2000000, GFP_NOWAIT);\r\nif (ret >= 0)\r\nmy_qp->token = ret;\r\nwrite_unlock_irqrestore(&ehca_qp_idr_lock, flags);\r\nidr_preload_end();\r\nif (ret < 0) {\r\nif (ret == -ENOSPC) {\r\nret = -EINVAL;\r\nehca_err(pd->device, "Invalid number of qp");\r\n} else {\r\nret = -ENOMEM;\r\nehca_err(pd->device, "Can't allocate new idr entry.");\r\n}\r\ngoto create_qp_exit0;\r\n}\r\nif (has_srq)\r\nparms.srq_token = my_qp->token;\r\nparms.servicetype = ibqptype2servicetype(qp_type);\r\nif (parms.servicetype < 0) {\r\nret = -EINVAL;\r\nehca_err(pd->device, "Invalid qp_type=%x", qp_type);\r\ngoto create_qp_exit1;\r\n}\r\nparms.sigtype = HCALL_SIGT_BY_WQE;\r\nmax_send_sge = init_attr->cap.max_send_sge;\r\nmax_recv_sge = init_attr->cap.max_recv_sge;\r\nif (parms.servicetype == ST_UD && !is_llqp) {\r\nmax_send_sge += 2;\r\nmax_recv_sge += 2;\r\n}\r\nparms.token = my_qp->token;\r\nparms.eq_handle = shca->eq.ipz_eq_handle;\r\nparms.pd = my_pd->fw_pd;\r\nif (my_qp->send_cq)\r\nparms.send_cq_handle = my_qp->send_cq->ipz_cq_handle;\r\nif (my_qp->recv_cq)\r\nparms.recv_cq_handle = my_qp->recv_cq->ipz_cq_handle;\r\nparms.squeue.max_wr = init_attr->cap.max_send_wr;\r\nparms.rqueue.max_wr = init_attr->cap.max_recv_wr;\r\nparms.squeue.max_sge = max_send_sge;\r\nparms.rqueue.max_sge = max_recv_sge;\r\nif (qp_type == IB_QPT_RC)\r\nparms.squeue.max_wr++;\r\nif (EHCA_BMASK_GET(HCA_CAP_MINI_QP, shca->hca_cap)) {\r\nif (HAS_SQ(my_qp))\r\nehca_determine_small_queue(\r\n&parms.squeue, max_send_sge, is_llqp);\r\nif (HAS_RQ(my_qp))\r\nehca_determine_small_queue(\r\n&parms.rqueue, max_recv_sge, is_llqp);\r\nparms.qp_storage =\r\n(parms.squeue.is_small || parms.rqueue.is_small);\r\n}\r\nh_ret = hipz_h_alloc_resource_qp(shca->ipz_hca_handle, &parms, is_user);\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(pd->device, "h_alloc_resource_qp() failed h_ret=%lli",\r\nh_ret);\r\nret = ehca2ib_return_code(h_ret);\r\ngoto create_qp_exit1;\r\n}\r\nib_qp_num = my_qp->real_qp_num = parms.real_qp_num;\r\nmy_qp->ipz_qp_handle = parms.qp_handle;\r\nmy_qp->galpas = parms.galpas;\r\nswqe_size = ehca_calc_wqe_size(parms.squeue.act_nr_sges, is_llqp);\r\nrwqe_size = ehca_calc_wqe_size(parms.rqueue.act_nr_sges, is_llqp);\r\nswitch (qp_type) {\r\ncase IB_QPT_RC:\r\nif (is_llqp) {\r\nparms.squeue.act_nr_sges = 1;\r\nparms.rqueue.act_nr_sges = 1;\r\n}\r\nparms.squeue.act_nr_wqes--;\r\nbreak;\r\ncase IB_QPT_UD:\r\ncase IB_QPT_GSI:\r\ncase IB_QPT_SMI:\r\nif (is_llqp) {\r\nparms.squeue.act_nr_sges = 1;\r\nparms.rqueue.act_nr_sges = 1;\r\n} else {\r\nparms.squeue.act_nr_sges -= 2;\r\nparms.rqueue.act_nr_sges -= 2;\r\n}\r\nif (IB_QPT_GSI == qp_type || IB_QPT_SMI == qp_type) {\r\nparms.squeue.act_nr_wqes = init_attr->cap.max_send_wr;\r\nparms.rqueue.act_nr_wqes = init_attr->cap.max_recv_wr;\r\nparms.squeue.act_nr_sges = init_attr->cap.max_send_sge;\r\nparms.rqueue.act_nr_sges = init_attr->cap.max_recv_sge;\r\nib_qp_num = (qp_type == IB_QPT_SMI) ? 0 : 1;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (HAS_SQ(my_qp)) {\r\nret = init_qp_queue(\r\nshca, my_pd, my_qp, &my_qp->ipz_squeue, 0,\r\nHAS_RQ(my_qp) ? H_PAGE_REGISTERED : H_SUCCESS,\r\n&parms.squeue, swqe_size);\r\nif (ret) {\r\nehca_err(pd->device, "Couldn't initialize squeue "\r\n"and pages ret=%i", ret);\r\ngoto create_qp_exit2;\r\n}\r\nif (!is_user) {\r\nmy_qp->sq_map.entries = my_qp->ipz_squeue.queue_length /\r\nmy_qp->ipz_squeue.qe_size;\r\nmy_qp->sq_map.map = vmalloc(my_qp->sq_map.entries *\r\nsizeof(struct ehca_qmap_entry));\r\nif (!my_qp->sq_map.map) {\r\nehca_err(pd->device, "Couldn't allocate squeue "\r\n"map ret=%i", ret);\r\ngoto create_qp_exit3;\r\n}\r\nINIT_LIST_HEAD(&my_qp->sq_err_node);\r\nreset_queue_map(&my_qp->sq_map);\r\n}\r\n}\r\nif (HAS_RQ(my_qp)) {\r\nret = init_qp_queue(\r\nshca, my_pd, my_qp, &my_qp->ipz_rqueue, 1,\r\nH_SUCCESS, &parms.rqueue, rwqe_size);\r\nif (ret) {\r\nehca_err(pd->device, "Couldn't initialize rqueue "\r\n"and pages ret=%i", ret);\r\ngoto create_qp_exit4;\r\n}\r\nif (!is_user) {\r\nmy_qp->rq_map.entries = my_qp->ipz_rqueue.queue_length /\r\nmy_qp->ipz_rqueue.qe_size;\r\nmy_qp->rq_map.map = vmalloc(my_qp->rq_map.entries *\r\nsizeof(struct ehca_qmap_entry));\r\nif (!my_qp->rq_map.map) {\r\nehca_err(pd->device, "Couldn't allocate squeue "\r\n"map ret=%i", ret);\r\ngoto create_qp_exit5;\r\n}\r\nINIT_LIST_HEAD(&my_qp->rq_err_node);\r\nreset_queue_map(&my_qp->rq_map);\r\n}\r\n} else if (init_attr->srq && !is_user) {\r\nmy_qp->rq_map = my_srq->rq_map;\r\nINIT_LIST_HEAD(&my_qp->rq_err_node);\r\nmy_qp->ipz_rqueue = my_srq->ipz_rqueue;\r\n}\r\nif (is_srq) {\r\nmy_qp->ib_srq.pd = &my_pd->ib_pd;\r\nmy_qp->ib_srq.device = my_pd->ib_pd.device;\r\nmy_qp->ib_srq.srq_context = init_attr->qp_context;\r\nmy_qp->ib_srq.event_handler = init_attr->event_handler;\r\n} else {\r\nmy_qp->ib_qp.qp_num = ib_qp_num;\r\nmy_qp->ib_qp.pd = &my_pd->ib_pd;\r\nmy_qp->ib_qp.device = my_pd->ib_pd.device;\r\nmy_qp->ib_qp.recv_cq = init_attr->recv_cq;\r\nmy_qp->ib_qp.send_cq = init_attr->send_cq;\r\nmy_qp->ib_qp.qp_type = qp_type;\r\nmy_qp->ib_qp.srq = init_attr->srq;\r\nmy_qp->ib_qp.qp_context = init_attr->qp_context;\r\nmy_qp->ib_qp.event_handler = init_attr->event_handler;\r\n}\r\ninit_attr->cap.max_inline_data = 0;\r\ninit_attr->cap.max_recv_sge = parms.rqueue.act_nr_sges;\r\ninit_attr->cap.max_recv_wr = parms.rqueue.act_nr_wqes;\r\ninit_attr->cap.max_send_sge = parms.squeue.act_nr_sges;\r\ninit_attr->cap.max_send_wr = parms.squeue.act_nr_wqes;\r\nmy_qp->init_attr = *init_attr;\r\nif (qp_type == IB_QPT_SMI || qp_type == IB_QPT_GSI) {\r\nshca->sport[init_attr->port_num - 1].ibqp_sqp[qp_type] =\r\n&my_qp->ib_qp;\r\nif (ehca_nr_ports < 0) {\r\nmy_qp->mod_qp_parm =\r\nkzalloc(EHCA_MOD_QP_PARM_MAX *\r\nsizeof(*my_qp->mod_qp_parm),\r\nGFP_KERNEL);\r\nif (!my_qp->mod_qp_parm) {\r\nehca_err(pd->device,\r\n"Could not alloc mod_qp_parm");\r\ngoto create_qp_exit5;\r\n}\r\n}\r\n}\r\nif (qp_type == IB_QPT_GSI) {\r\nh_ret = ehca_define_sqp(shca, my_qp, init_attr);\r\nif (h_ret != H_SUCCESS) {\r\nkfree(my_qp->mod_qp_parm);\r\nmy_qp->mod_qp_parm = NULL;\r\nshca->sport[init_attr->port_num - 1].ibqp_sqp[qp_type] =\r\nNULL;\r\nret = ehca2ib_return_code(h_ret);\r\ngoto create_qp_exit6;\r\n}\r\n}\r\nif (my_qp->send_cq) {\r\nret = ehca_cq_assign_qp(my_qp->send_cq, my_qp);\r\nif (ret) {\r\nehca_err(pd->device,\r\n"Couldn't assign qp to send_cq ret=%i", ret);\r\ngoto create_qp_exit7;\r\n}\r\n}\r\nif (context && udata) {\r\nstruct ehca_create_qp_resp resp;\r\nmemset(&resp, 0, sizeof(resp));\r\nresp.qp_num = my_qp->real_qp_num;\r\nresp.token = my_qp->token;\r\nresp.qp_type = my_qp->qp_type;\r\nresp.ext_type = my_qp->ext_type;\r\nresp.qkey = my_qp->qkey;\r\nresp.real_qp_num = my_qp->real_qp_num;\r\nif (HAS_SQ(my_qp))\r\nqueue2resp(&resp.ipz_squeue, &my_qp->ipz_squeue);\r\nif (HAS_RQ(my_qp))\r\nqueue2resp(&resp.ipz_rqueue, &my_qp->ipz_rqueue);\r\nresp.fw_handle_ofs = (u32)\r\n(my_qp->galpas.user.fw_handle & (PAGE_SIZE - 1));\r\nif (ib_copy_to_udata(udata, &resp, sizeof resp)) {\r\nehca_err(pd->device, "Copy to udata failed");\r\nret = -EINVAL;\r\ngoto create_qp_exit8;\r\n}\r\n}\r\nreturn my_qp;\r\ncreate_qp_exit8:\r\nehca_cq_unassign_qp(my_qp->send_cq, my_qp->real_qp_num);\r\ncreate_qp_exit7:\r\nkfree(my_qp->mod_qp_parm);\r\ncreate_qp_exit6:\r\nif (HAS_RQ(my_qp) && !is_user)\r\nvfree(my_qp->rq_map.map);\r\ncreate_qp_exit5:\r\nif (HAS_RQ(my_qp))\r\nipz_queue_dtor(my_pd, &my_qp->ipz_rqueue);\r\ncreate_qp_exit4:\r\nif (HAS_SQ(my_qp) && !is_user)\r\nvfree(my_qp->sq_map.map);\r\ncreate_qp_exit3:\r\nif (HAS_SQ(my_qp))\r\nipz_queue_dtor(my_pd, &my_qp->ipz_squeue);\r\ncreate_qp_exit2:\r\nhipz_h_destroy_qp(shca->ipz_hca_handle, my_qp);\r\ncreate_qp_exit1:\r\nwrite_lock_irqsave(&ehca_qp_idr_lock, flags);\r\nidr_remove(&ehca_qp_idr, my_qp->token);\r\nwrite_unlock_irqrestore(&ehca_qp_idr_lock, flags);\r\ncreate_qp_exit0:\r\nkmem_cache_free(qp_cache, my_qp);\r\natomic_dec(&shca->num_qps);\r\nreturn ERR_PTR(ret);\r\n}\r\nstruct ib_qp *ehca_create_qp(struct ib_pd *pd,\r\nstruct ib_qp_init_attr *qp_init_attr,\r\nstruct ib_udata *udata)\r\n{\r\nstruct ehca_qp *ret;\r\nret = internal_create_qp(pd, qp_init_attr, NULL, udata, 0);\r\nreturn IS_ERR(ret) ? (struct ib_qp *)ret : &ret->ib_qp;\r\n}\r\nstruct ib_srq *ehca_create_srq(struct ib_pd *pd,\r\nstruct ib_srq_init_attr *srq_init_attr,\r\nstruct ib_udata *udata)\r\n{\r\nstruct ib_qp_init_attr qp_init_attr;\r\nstruct ehca_qp *my_qp;\r\nstruct ib_srq *ret;\r\nstruct ehca_shca *shca = container_of(pd->device, struct ehca_shca,\r\nib_device);\r\nstruct hcp_modify_qp_control_block *mqpcb;\r\nu64 hret, update_mask;\r\nif (srq_init_attr->srq_type != IB_SRQT_BASIC)\r\nreturn ERR_PTR(-ENOSYS);\r\nmemset(&qp_init_attr, 0, sizeof(qp_init_attr));\r\nqp_init_attr.event_handler = srq_init_attr->event_handler;\r\nqp_init_attr.qp_context = srq_init_attr->srq_context;\r\nqp_init_attr.sq_sig_type = IB_SIGNAL_ALL_WR;\r\nqp_init_attr.qp_type = IB_QPT_RC;\r\nqp_init_attr.cap.max_recv_wr = srq_init_attr->attr.max_wr;\r\nqp_init_attr.cap.max_recv_sge = srq_init_attr->attr.max_sge;\r\nmy_qp = internal_create_qp(pd, &qp_init_attr, srq_init_attr, udata, 1);\r\nif (IS_ERR(my_qp))\r\nreturn (struct ib_srq *)my_qp;\r\nsrq_init_attr->attr.max_wr = qp_init_attr.cap.max_recv_wr;\r\nsrq_init_attr->attr.max_sge = 3;\r\nmqpcb = ehca_alloc_fw_ctrlblock(GFP_KERNEL);\r\nif (!mqpcb) {\r\nehca_err(pd->device, "Could not get zeroed page for mqpcb "\r\n"ehca_qp=%p qp_num=%x ", my_qp, my_qp->real_qp_num);\r\nret = ERR_PTR(-ENOMEM);\r\ngoto create_srq1;\r\n}\r\nmqpcb->qp_state = EHCA_QPS_INIT;\r\nmqpcb->prim_phys_port = 1;\r\nupdate_mask = EHCA_BMASK_SET(MQPCB_MASK_QP_STATE, 1);\r\nhret = hipz_h_modify_qp(shca->ipz_hca_handle,\r\nmy_qp->ipz_qp_handle,\r\n&my_qp->pf,\r\nupdate_mask,\r\nmqpcb, my_qp->galpas.kernel);\r\nif (hret != H_SUCCESS) {\r\nehca_err(pd->device, "Could not modify SRQ to INIT "\r\n"ehca_qp=%p qp_num=%x h_ret=%lli",\r\nmy_qp, my_qp->real_qp_num, hret);\r\ngoto create_srq2;\r\n}\r\nmqpcb->qp_enable = 1;\r\nupdate_mask = EHCA_BMASK_SET(MQPCB_MASK_QP_ENABLE, 1);\r\nhret = hipz_h_modify_qp(shca->ipz_hca_handle,\r\nmy_qp->ipz_qp_handle,\r\n&my_qp->pf,\r\nupdate_mask,\r\nmqpcb, my_qp->galpas.kernel);\r\nif (hret != H_SUCCESS) {\r\nehca_err(pd->device, "Could not enable SRQ "\r\n"ehca_qp=%p qp_num=%x h_ret=%lli",\r\nmy_qp, my_qp->real_qp_num, hret);\r\ngoto create_srq2;\r\n}\r\nmqpcb->qp_state = EHCA_QPS_RTR;\r\nupdate_mask = EHCA_BMASK_SET(MQPCB_MASK_QP_STATE, 1);\r\nhret = hipz_h_modify_qp(shca->ipz_hca_handle,\r\nmy_qp->ipz_qp_handle,\r\n&my_qp->pf,\r\nupdate_mask,\r\nmqpcb, my_qp->galpas.kernel);\r\nif (hret != H_SUCCESS) {\r\nehca_err(pd->device, "Could not modify SRQ to RTR "\r\n"ehca_qp=%p qp_num=%x h_ret=%lli",\r\nmy_qp, my_qp->real_qp_num, hret);\r\ngoto create_srq2;\r\n}\r\nehca_free_fw_ctrlblock(mqpcb);\r\nreturn &my_qp->ib_srq;\r\ncreate_srq2:\r\nret = ERR_PTR(ehca2ib_return_code(hret));\r\nehca_free_fw_ctrlblock(mqpcb);\r\ncreate_srq1:\r\ninternal_destroy_qp(pd->device, my_qp, my_qp->ib_srq.uobject);\r\nreturn ret;\r\n}\r\nstatic int prepare_sqe_rts(struct ehca_qp *my_qp, struct ehca_shca *shca,\r\nint *bad_wqe_cnt)\r\n{\r\nu64 h_ret;\r\nstruct ipz_queue *squeue;\r\nvoid *bad_send_wqe_p, *bad_send_wqe_v;\r\nu64 q_ofs;\r\nstruct ehca_wqe *wqe;\r\nint qp_num = my_qp->ib_qp.qp_num;\r\nh_ret = hipz_h_disable_and_get_wqe(shca->ipz_hca_handle,\r\nmy_qp->ipz_qp_handle, &my_qp->pf,\r\n&bad_send_wqe_p, NULL, 2);\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(&shca->ib_device, "hipz_h_disable_and_get_wqe() failed"\r\n" ehca_qp=%p qp_num=%x h_ret=%lli",\r\nmy_qp, qp_num, h_ret);\r\nreturn ehca2ib_return_code(h_ret);\r\n}\r\nbad_send_wqe_p = (void *)((u64)bad_send_wqe_p & (~(1L << 63)));\r\nehca_dbg(&shca->ib_device, "qp_num=%x bad_send_wqe_p=%p",\r\nqp_num, bad_send_wqe_p);\r\nbad_send_wqe_v = __va((u64)bad_send_wqe_p);\r\nif (ehca_debug_level >= 2)\r\nehca_dmp(bad_send_wqe_v, 32, "qp_num=%x bad_wqe", qp_num);\r\nsqueue = &my_qp->ipz_squeue;\r\nif (ipz_queue_abs_to_offset(squeue, (u64)bad_send_wqe_p, &q_ofs)) {\r\nehca_err(&shca->ib_device, "failed to get wqe offset qp_num=%x"\r\n" bad_send_wqe_p=%p", qp_num, bad_send_wqe_p);\r\nreturn -EFAULT;\r\n}\r\nwqe = (struct ehca_wqe *)ipz_qeit_calc(squeue, q_ofs);\r\n*bad_wqe_cnt = 0;\r\nwhile (wqe->optype != 0xff && wqe->wqef != 0xff) {\r\nif (ehca_debug_level >= 2)\r\nehca_dmp(wqe, 32, "qp_num=%x wqe", qp_num);\r\nwqe->nr_of_data_seg = 0;\r\nwqe->wqef = WQEF_PURGE;\r\nq_ofs = ipz_queue_advance_offset(squeue, q_ofs);\r\nwqe = (struct ehca_wqe *)ipz_qeit_calc(squeue, q_ofs);\r\n*bad_wqe_cnt = (*bad_wqe_cnt)+1;\r\n}\r\nehca_dbg(&shca->ib_device, "qp_num=%x flusherr_wqe_cnt=%x",\r\nqp_num, (*bad_wqe_cnt)-1);\r\nwqe->wqef = 0;\r\nreturn 0;\r\n}\r\nstatic int calc_left_cqes(u64 wqe_p, struct ipz_queue *ipz_queue,\r\nstruct ehca_queue_map *qmap)\r\n{\r\nvoid *wqe_v;\r\nu64 q_ofs;\r\nu32 wqe_idx;\r\nunsigned int tail_idx;\r\nwqe_p = wqe_p & (~(1UL << 63));\r\nwqe_v = __va(wqe_p);\r\nif (ipz_queue_abs_to_offset(ipz_queue, wqe_p, &q_ofs)) {\r\nehca_gen_err("Invalid offset for calculating left cqes "\r\n"wqe_p=%#llx wqe_v=%p\n", wqe_p, wqe_v);\r\nreturn -EFAULT;\r\n}\r\ntail_idx = next_index(qmap->tail, qmap->entries);\r\nwqe_idx = q_ofs / ipz_queue->qe_size;\r\nwhile (tail_idx != wqe_idx) {\r\nif (qmap->map[tail_idx].cqe_req)\r\nqmap->left_to_poll++;\r\ntail_idx = next_index(tail_idx, qmap->entries);\r\n}\r\nqmap->next_wqe_idx = wqe_idx;\r\nreturn 0;\r\n}\r\nstatic int check_for_left_cqes(struct ehca_qp *my_qp, struct ehca_shca *shca)\r\n{\r\nu64 h_ret;\r\nvoid *send_wqe_p, *recv_wqe_p;\r\nint ret;\r\nunsigned long flags;\r\nint qp_num = my_qp->ib_qp.qp_num;\r\nif (my_qp->ext_type != EQPT_SRQBASE) {\r\nh_ret = hipz_h_disable_and_get_wqe(shca->ipz_hca_handle,\r\nmy_qp->ipz_qp_handle, &my_qp->pf,\r\n&send_wqe_p, &recv_wqe_p, 4);\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(&shca->ib_device, "disable_and_get_wqe() "\r\n"failed ehca_qp=%p qp_num=%x h_ret=%lli",\r\nmy_qp, qp_num, h_ret);\r\nreturn ehca2ib_return_code(h_ret);\r\n}\r\nspin_lock_irqsave(&my_qp->send_cq->spinlock, flags);\r\nret = calc_left_cqes((u64)send_wqe_p, &my_qp->ipz_squeue,\r\n&my_qp->sq_map);\r\nspin_unlock_irqrestore(&my_qp->send_cq->spinlock, flags);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&my_qp->recv_cq->spinlock, flags);\r\nret = calc_left_cqes((u64)recv_wqe_p, &my_qp->ipz_rqueue,\r\n&my_qp->rq_map);\r\nspin_unlock_irqrestore(&my_qp->recv_cq->spinlock, flags);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nspin_lock_irqsave(&my_qp->send_cq->spinlock, flags);\r\nmy_qp->sq_map.left_to_poll = 0;\r\nmy_qp->sq_map.next_wqe_idx = next_index(my_qp->sq_map.tail,\r\nmy_qp->sq_map.entries);\r\nspin_unlock_irqrestore(&my_qp->send_cq->spinlock, flags);\r\nspin_lock_irqsave(&my_qp->recv_cq->spinlock, flags);\r\nmy_qp->rq_map.left_to_poll = 0;\r\nmy_qp->rq_map.next_wqe_idx = next_index(my_qp->rq_map.tail,\r\nmy_qp->rq_map.entries);\r\nspin_unlock_irqrestore(&my_qp->recv_cq->spinlock, flags);\r\n}\r\nif ((my_qp->sq_map.left_to_poll == 0) &&\r\n(my_qp->rq_map.left_to_poll == 0)) {\r\nspin_lock_irqsave(&my_qp->send_cq->spinlock, flags);\r\nehca_add_to_err_list(my_qp, 1);\r\nspin_unlock_irqrestore(&my_qp->send_cq->spinlock, flags);\r\nif (HAS_RQ(my_qp)) {\r\nspin_lock_irqsave(&my_qp->recv_cq->spinlock, flags);\r\nehca_add_to_err_list(my_qp, 0);\r\nspin_unlock_irqrestore(&my_qp->recv_cq->spinlock,\r\nflags);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int internal_modify_qp(struct ib_qp *ibqp,\r\nstruct ib_qp_attr *attr,\r\nint attr_mask, int smi_reset2init)\r\n{\r\nenum ib_qp_state qp_cur_state, qp_new_state;\r\nint cnt, qp_attr_idx, ret = 0;\r\nenum ib_qp_statetrans statetrans;\r\nstruct hcp_modify_qp_control_block *mqpcb;\r\nstruct ehca_qp *my_qp = container_of(ibqp, struct ehca_qp, ib_qp);\r\nstruct ehca_shca *shca =\r\ncontainer_of(ibqp->pd->device, struct ehca_shca, ib_device);\r\nu64 update_mask;\r\nu64 h_ret;\r\nint bad_wqe_cnt = 0;\r\nint is_user = 0;\r\nint squeue_locked = 0;\r\nunsigned long flags = 0;\r\nmqpcb = ehca_alloc_fw_ctrlblock(GFP_ATOMIC);\r\nif (!mqpcb) {\r\nehca_err(ibqp->device, "Could not get zeroed page for mqpcb "\r\n"ehca_qp=%p qp_num=%x ", my_qp, ibqp->qp_num);\r\nreturn -ENOMEM;\r\n}\r\nh_ret = hipz_h_query_qp(shca->ipz_hca_handle,\r\nmy_qp->ipz_qp_handle,\r\n&my_qp->pf,\r\nmqpcb, my_qp->galpas.kernel);\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(ibqp->device, "hipz_h_query_qp() failed "\r\n"ehca_qp=%p qp_num=%x h_ret=%lli",\r\nmy_qp, ibqp->qp_num, h_ret);\r\nret = ehca2ib_return_code(h_ret);\r\ngoto modify_qp_exit1;\r\n}\r\nif (ibqp->uobject)\r\nis_user = 1;\r\nqp_cur_state = ehca2ib_qp_state(mqpcb->qp_state);\r\nif (qp_cur_state == -EINVAL) {\r\nret = -EINVAL;\r\nehca_err(ibqp->device, "Invalid current ehca_qp_state=%x "\r\n"ehca_qp=%p qp_num=%x",\r\nmqpcb->qp_state, my_qp, ibqp->qp_num);\r\ngoto modify_qp_exit1;\r\n}\r\nif (smi_reset2init == 0 &&\r\nibqp->qp_type == IB_QPT_SMI &&\r\nqp_cur_state == IB_QPS_RESET &&\r\n(attr_mask & IB_QP_STATE) &&\r\nattr->qp_state == IB_QPS_INIT) {\r\nstruct ib_qp_attr smiqp_attr = {\r\n.qp_state = IB_QPS_INIT,\r\n.port_num = my_qp->init_attr.port_num,\r\n.pkey_index = 0,\r\n.qkey = 0\r\n};\r\nint smiqp_attr_mask = IB_QP_STATE | IB_QP_PORT |\r\nIB_QP_PKEY_INDEX | IB_QP_QKEY;\r\nint smirc = internal_modify_qp(\r\nibqp, &smiqp_attr, smiqp_attr_mask, 1);\r\nif (smirc) {\r\nehca_err(ibqp->device, "SMI RESET -> INIT failed. "\r\n"ehca_modify_qp() rc=%i", smirc);\r\nret = H_PARAMETER;\r\ngoto modify_qp_exit1;\r\n}\r\nqp_cur_state = IB_QPS_INIT;\r\nehca_dbg(ibqp->device, "SMI RESET -> INIT succeeded");\r\n}\r\nif ((attr_mask & IB_QP_CUR_STATE) &&\r\nqp_cur_state != attr->cur_qp_state) {\r\nret = -EINVAL;\r\nehca_err(ibqp->device,\r\n"Invalid IB_QP_CUR_STATE attr->curr_qp_state=%x <>"\r\n" actual cur_qp_state=%x. ehca_qp=%p qp_num=%x",\r\nattr->cur_qp_state, qp_cur_state, my_qp, ibqp->qp_num);\r\ngoto modify_qp_exit1;\r\n}\r\nehca_dbg(ibqp->device, "ehca_qp=%p qp_num=%x current qp_state=%x "\r\n"new qp_state=%x attribute_mask=%x",\r\nmy_qp, ibqp->qp_num, qp_cur_state, attr->qp_state, attr_mask);\r\nqp_new_state = attr_mask & IB_QP_STATE ? attr->qp_state : qp_cur_state;\r\nif (!smi_reset2init &&\r\n!ib_modify_qp_is_ok(qp_cur_state, qp_new_state, ibqp->qp_type,\r\nattr_mask)) {\r\nret = -EINVAL;\r\nehca_err(ibqp->device,\r\n"Invalid qp transition new_state=%x cur_state=%x "\r\n"ehca_qp=%p qp_num=%x attr_mask=%x", qp_new_state,\r\nqp_cur_state, my_qp, ibqp->qp_num, attr_mask);\r\ngoto modify_qp_exit1;\r\n}\r\nmqpcb->qp_state = ib2ehca_qp_state(qp_new_state);\r\nif (mqpcb->qp_state)\r\nupdate_mask = EHCA_BMASK_SET(MQPCB_MASK_QP_STATE, 1);\r\nelse {\r\nret = -EINVAL;\r\nehca_err(ibqp->device, "Invalid new qp state=%x "\r\n"ehca_qp=%p qp_num=%x",\r\nqp_new_state, my_qp, ibqp->qp_num);\r\ngoto modify_qp_exit1;\r\n}\r\nstatetrans = get_modqp_statetrans(qp_cur_state, qp_new_state);\r\nif (statetrans < 0) {\r\nret = -EINVAL;\r\nehca_err(ibqp->device, "<INVALID STATE CHANGE> qp_cur_state=%x "\r\n"new_qp_state=%x State_xsition=%x ehca_qp=%p "\r\n"qp_num=%x", qp_cur_state, qp_new_state,\r\nstatetrans, my_qp, ibqp->qp_num);\r\ngoto modify_qp_exit1;\r\n}\r\nqp_attr_idx = ib2ehcaqptype(ibqp->qp_type);\r\nif (qp_attr_idx < 0) {\r\nret = qp_attr_idx;\r\nehca_err(ibqp->device,\r\n"Invalid QP type=%x ehca_qp=%p qp_num=%x",\r\nibqp->qp_type, my_qp, ibqp->qp_num);\r\ngoto modify_qp_exit1;\r\n}\r\nehca_dbg(ibqp->device,\r\n"ehca_qp=%p qp_num=%x <VALID STATE CHANGE> qp_state_xsit=%x",\r\nmy_qp, ibqp->qp_num, statetrans);\r\nif ((my_qp->qp_type == IB_QPT_UD) &&\r\n(my_qp->ext_type != EQPT_LLQP) &&\r\n(statetrans == IB_QPST_INIT2RTR) &&\r\n(shca->hw_level >= 0x22)) {\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_SEND_GRH_FLAG, 1);\r\nmqpcb->send_grh_flag = 1;\r\n}\r\nif ((my_qp->qp_type == IB_QPT_UD ||\r\nmy_qp->qp_type == IB_QPT_GSI ||\r\nmy_qp->qp_type == IB_QPT_SMI) &&\r\nstatetrans == IB_QPST_SQE2RTS) {\r\nif (!ibqp->uobject) {\r\nstruct ehca_wqe *wqe;\r\nspin_lock_irqsave(&my_qp->spinlock_s, flags);\r\nsqueue_locked = 1;\r\nwqe = (struct ehca_wqe *)\r\nipz_qeit_get(&my_qp->ipz_squeue);\r\nwqe->optype = wqe->wqef = 0xff;\r\nehca_dbg(ibqp->device, "qp_num=%x next_free_wqe=%p",\r\nibqp->qp_num, wqe);\r\n}\r\nret = prepare_sqe_rts(my_qp, shca, &bad_wqe_cnt);\r\nif (ret) {\r\nehca_err(ibqp->device, "prepare_sqe_rts() failed "\r\n"ehca_qp=%p qp_num=%x ret=%i",\r\nmy_qp, ibqp->qp_num, ret);\r\ngoto modify_qp_exit2;\r\n}\r\n}\r\nif (statetrans == IB_QPST_RESET2INIT &&\r\n(ibqp->qp_type == IB_QPT_RC || ibqp->qp_type == IB_QPT_UC)) {\r\nmqpcb->rdma_atomic_ctrl = 3;\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_RDMA_ATOMIC_CTRL, 1);\r\n}\r\nif (statetrans == IB_QPST_INIT2RTR &&\r\n(ibqp->qp_type == IB_QPT_UC) &&\r\n!(attr_mask & IB_QP_MAX_DEST_RD_ATOMIC)) {\r\nmqpcb->rdma_nr_atomic_resp_res = 1;\r\nupdate_mask |=\r\nEHCA_BMASK_SET(MQPCB_MASK_RDMA_NR_ATOMIC_RESP_RES, 1);\r\n}\r\nif (attr_mask & IB_QP_PKEY_INDEX) {\r\nif (attr->pkey_index >= 16) {\r\nret = -EINVAL;\r\nehca_err(ibqp->device, "Invalid pkey_index=%x. "\r\n"ehca_qp=%p qp_num=%x max_pkey_index=f",\r\nattr->pkey_index, my_qp, ibqp->qp_num);\r\ngoto modify_qp_exit2;\r\n}\r\nmqpcb->prim_p_key_idx = attr->pkey_index;\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_PRIM_P_KEY_IDX, 1);\r\n}\r\nif (attr_mask & IB_QP_PORT) {\r\nstruct ehca_sport *sport;\r\nstruct ehca_qp *aqp1;\r\nif (attr->port_num < 1 || attr->port_num > shca->num_ports) {\r\nret = -EINVAL;\r\nehca_err(ibqp->device, "Invalid port=%x. "\r\n"ehca_qp=%p qp_num=%x num_ports=%x",\r\nattr->port_num, my_qp, ibqp->qp_num,\r\nshca->num_ports);\r\ngoto modify_qp_exit2;\r\n}\r\nsport = &shca->sport[attr->port_num - 1];\r\nif (!sport->ibqp_sqp[IB_QPT_GSI]) {\r\nret = -EFAULT;\r\nehca_err(ibqp->device, "AQP1 was not created for "\r\n"port=%x", attr->port_num);\r\ngoto modify_qp_exit2;\r\n}\r\naqp1 = container_of(sport->ibqp_sqp[IB_QPT_GSI],\r\nstruct ehca_qp, ib_qp);\r\nif (ibqp->qp_type != IB_QPT_GSI &&\r\nibqp->qp_type != IB_QPT_SMI &&\r\naqp1->mod_qp_parm) {\r\nret = -EFAULT;\r\nehca_warn(ibqp->device, "Couldn't modify qp port=%x: "\r\n"either port is being activated (try again) "\r\n"or cabling issue", attr->port_num);\r\ngoto modify_qp_exit2;\r\n}\r\nmqpcb->prim_phys_port = attr->port_num;\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_PRIM_PHYS_PORT, 1);\r\n}\r\nif (attr_mask & IB_QP_QKEY) {\r\nmqpcb->qkey = attr->qkey;\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_QKEY, 1);\r\n}\r\nif (attr_mask & IB_QP_AV) {\r\nmqpcb->dlid = attr->ah_attr.dlid;\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_DLID, 1);\r\nmqpcb->source_path_bits = attr->ah_attr.src_path_bits;\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_SOURCE_PATH_BITS, 1);\r\nmqpcb->service_level = attr->ah_attr.sl;\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_SERVICE_LEVEL, 1);\r\nif (ehca_calc_ipd(shca, mqpcb->prim_phys_port,\r\nattr->ah_attr.static_rate,\r\n&mqpcb->max_static_rate)) {\r\nret = -EINVAL;\r\ngoto modify_qp_exit2;\r\n}\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_MAX_STATIC_RATE, 1);\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_SEND_GRH_FLAG, 1);\r\nif (attr->ah_attr.ah_flags == IB_AH_GRH) {\r\nmqpcb->send_grh_flag = 1;\r\nmqpcb->source_gid_idx = attr->ah_attr.grh.sgid_index;\r\nupdate_mask |=\r\nEHCA_BMASK_SET(MQPCB_MASK_SOURCE_GID_IDX, 1);\r\nfor (cnt = 0; cnt < 16; cnt++)\r\nmqpcb->dest_gid.byte[cnt] =\r\nattr->ah_attr.grh.dgid.raw[cnt];\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_DEST_GID, 1);\r\nmqpcb->flow_label = attr->ah_attr.grh.flow_label;\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_FLOW_LABEL, 1);\r\nmqpcb->hop_limit = attr->ah_attr.grh.hop_limit;\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_HOP_LIMIT, 1);\r\nmqpcb->traffic_class = attr->ah_attr.grh.traffic_class;\r\nupdate_mask |=\r\nEHCA_BMASK_SET(MQPCB_MASK_TRAFFIC_CLASS, 1);\r\n}\r\n}\r\nif (attr_mask & IB_QP_PATH_MTU) {\r\nmy_qp->mtu_shift = attr->path_mtu + 7;\r\nmqpcb->path_mtu = attr->path_mtu;\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_PATH_MTU, 1);\r\n}\r\nif (attr_mask & IB_QP_TIMEOUT) {\r\nmqpcb->timeout = attr->timeout;\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_TIMEOUT, 1);\r\n}\r\nif (attr_mask & IB_QP_RETRY_CNT) {\r\nmqpcb->retry_count = attr->retry_cnt;\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_RETRY_COUNT, 1);\r\n}\r\nif (attr_mask & IB_QP_RNR_RETRY) {\r\nmqpcb->rnr_retry_count = attr->rnr_retry;\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_RNR_RETRY_COUNT, 1);\r\n}\r\nif (attr_mask & IB_QP_RQ_PSN) {\r\nmqpcb->receive_psn = attr->rq_psn;\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_RECEIVE_PSN, 1);\r\n}\r\nif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC) {\r\nmqpcb->rdma_nr_atomic_resp_res = attr->max_dest_rd_atomic < 3 ?\r\nattr->max_dest_rd_atomic : 2;\r\nupdate_mask |=\r\nEHCA_BMASK_SET(MQPCB_MASK_RDMA_NR_ATOMIC_RESP_RES, 1);\r\n}\r\nif (attr_mask & IB_QP_MAX_QP_RD_ATOMIC) {\r\nmqpcb->rdma_atomic_outst_dest_qp = attr->max_rd_atomic < 3 ?\r\nattr->max_rd_atomic : 2;\r\nupdate_mask |=\r\nEHCA_BMASK_SET\r\n(MQPCB_MASK_RDMA_ATOMIC_OUTST_DEST_QP, 1);\r\n}\r\nif (attr_mask & IB_QP_ALT_PATH) {\r\nif (attr->alt_port_num < 1\r\n|| attr->alt_port_num > shca->num_ports) {\r\nret = -EINVAL;\r\nehca_err(ibqp->device, "Invalid alt_port=%x. "\r\n"ehca_qp=%p qp_num=%x num_ports=%x",\r\nattr->alt_port_num, my_qp, ibqp->qp_num,\r\nshca->num_ports);\r\ngoto modify_qp_exit2;\r\n}\r\nmqpcb->alt_phys_port = attr->alt_port_num;\r\nif (attr->alt_pkey_index >= 16) {\r\nret = -EINVAL;\r\nehca_err(ibqp->device, "Invalid alt_pkey_index=%x. "\r\n"ehca_qp=%p qp_num=%x max_pkey_index=f",\r\nattr->pkey_index, my_qp, ibqp->qp_num);\r\ngoto modify_qp_exit2;\r\n}\r\nmqpcb->alt_p_key_idx = attr->alt_pkey_index;\r\nmqpcb->timeout_al = attr->alt_timeout;\r\nmqpcb->dlid_al = attr->alt_ah_attr.dlid;\r\nmqpcb->source_path_bits_al = attr->alt_ah_attr.src_path_bits;\r\nmqpcb->service_level_al = attr->alt_ah_attr.sl;\r\nif (ehca_calc_ipd(shca, mqpcb->alt_phys_port,\r\nattr->alt_ah_attr.static_rate,\r\n&mqpcb->max_static_rate_al)) {\r\nret = -EINVAL;\r\ngoto modify_qp_exit2;\r\n}\r\nmqpcb->retry_count_al = mqpcb->retry_count;\r\nmqpcb->rnr_retry_count_al = mqpcb->rnr_retry_count;\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_ALT_PHYS_PORT, 1)\r\n| EHCA_BMASK_SET(MQPCB_MASK_ALT_P_KEY_IDX, 1)\r\n| EHCA_BMASK_SET(MQPCB_MASK_TIMEOUT_AL, 1)\r\n| EHCA_BMASK_SET(MQPCB_MASK_DLID_AL, 1)\r\n| EHCA_BMASK_SET(MQPCB_MASK_SOURCE_PATH_BITS_AL, 1)\r\n| EHCA_BMASK_SET(MQPCB_MASK_SERVICE_LEVEL_AL, 1)\r\n| EHCA_BMASK_SET(MQPCB_MASK_MAX_STATIC_RATE_AL, 1)\r\n| EHCA_BMASK_SET(MQPCB_MASK_RETRY_COUNT_AL, 1)\r\n| EHCA_BMASK_SET(MQPCB_MASK_RNR_RETRY_COUNT_AL, 1);\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_SEND_GRH_FLAG_AL, 1);\r\nif (attr->alt_ah_attr.ah_flags == IB_AH_GRH) {\r\nmqpcb->send_grh_flag_al = 1;\r\nfor (cnt = 0; cnt < 16; cnt++)\r\nmqpcb->dest_gid_al.byte[cnt] =\r\nattr->alt_ah_attr.grh.dgid.raw[cnt];\r\nmqpcb->source_gid_idx_al =\r\nattr->alt_ah_attr.grh.sgid_index;\r\nmqpcb->flow_label_al = attr->alt_ah_attr.grh.flow_label;\r\nmqpcb->hop_limit_al = attr->alt_ah_attr.grh.hop_limit;\r\nmqpcb->traffic_class_al =\r\nattr->alt_ah_attr.grh.traffic_class;\r\nupdate_mask |=\r\nEHCA_BMASK_SET(MQPCB_MASK_SOURCE_GID_IDX_AL, 1)\r\n| EHCA_BMASK_SET(MQPCB_MASK_DEST_GID_AL, 1)\r\n| EHCA_BMASK_SET(MQPCB_MASK_FLOW_LABEL_AL, 1)\r\n| EHCA_BMASK_SET(MQPCB_MASK_HOP_LIMIT_AL, 1) |\r\nEHCA_BMASK_SET(MQPCB_MASK_TRAFFIC_CLASS_AL, 1);\r\n}\r\n}\r\nif (attr_mask & IB_QP_MIN_RNR_TIMER) {\r\nmqpcb->min_rnr_nak_timer_field = attr->min_rnr_timer;\r\nupdate_mask |=\r\nEHCA_BMASK_SET(MQPCB_MASK_MIN_RNR_NAK_TIMER_FIELD, 1);\r\n}\r\nif (attr_mask & IB_QP_SQ_PSN) {\r\nmqpcb->send_psn = attr->sq_psn;\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_SEND_PSN, 1);\r\n}\r\nif (attr_mask & IB_QP_DEST_QPN) {\r\nmqpcb->dest_qp_nr = attr->dest_qp_num;\r\nupdate_mask |= EHCA_BMASK_SET(MQPCB_MASK_DEST_QP_NR, 1);\r\n}\r\nif (attr_mask & IB_QP_PATH_MIG_STATE) {\r\nif (attr->path_mig_state != IB_MIG_REARM\r\n&& attr->path_mig_state != IB_MIG_MIGRATED) {\r\nret = -EINVAL;\r\nehca_err(ibqp->device, "Invalid mig_state=%x",\r\nattr->path_mig_state);\r\ngoto modify_qp_exit2;\r\n}\r\nmqpcb->path_migration_state = attr->path_mig_state + 1;\r\nif (attr->path_mig_state == IB_MIG_REARM)\r\nmy_qp->mig_armed = 1;\r\nupdate_mask |=\r\nEHCA_BMASK_SET(MQPCB_MASK_PATH_MIGRATION_STATE, 1);\r\n}\r\nif (attr_mask & IB_QP_CAP) {\r\nmqpcb->max_nr_outst_send_wr = attr->cap.max_send_wr+1;\r\nupdate_mask |=\r\nEHCA_BMASK_SET(MQPCB_MASK_MAX_NR_OUTST_SEND_WR, 1);\r\nmqpcb->max_nr_outst_recv_wr = attr->cap.max_recv_wr+1;\r\nupdate_mask |=\r\nEHCA_BMASK_SET(MQPCB_MASK_MAX_NR_OUTST_RECV_WR, 1);\r\n}\r\nif (ehca_debug_level >= 2)\r\nehca_dmp(mqpcb, 4*70, "qp_num=%x", ibqp->qp_num);\r\nh_ret = hipz_h_modify_qp(shca->ipz_hca_handle,\r\nmy_qp->ipz_qp_handle,\r\n&my_qp->pf,\r\nupdate_mask,\r\nmqpcb, my_qp->galpas.kernel);\r\nif (h_ret != H_SUCCESS) {\r\nret = ehca2ib_return_code(h_ret);\r\nehca_err(ibqp->device, "hipz_h_modify_qp() failed h_ret=%lli "\r\n"ehca_qp=%p qp_num=%x", h_ret, my_qp, ibqp->qp_num);\r\ngoto modify_qp_exit2;\r\n}\r\nif ((my_qp->qp_type == IB_QPT_UD ||\r\nmy_qp->qp_type == IB_QPT_GSI ||\r\nmy_qp->qp_type == IB_QPT_SMI) &&\r\nstatetrans == IB_QPST_SQE2RTS) {\r\niosync();\r\nhipz_update_sqa(my_qp, bad_wqe_cnt-1);\r\nehca_gen_dbg("doorbell for %x wqes", bad_wqe_cnt);\r\n}\r\nif (statetrans == IB_QPST_RESET2INIT ||\r\nstatetrans == IB_QPST_INIT2INIT) {\r\nmqpcb->qp_enable = 1;\r\nmqpcb->qp_state = EHCA_QPS_INIT;\r\nupdate_mask = 0;\r\nupdate_mask = EHCA_BMASK_SET(MQPCB_MASK_QP_ENABLE, 1);\r\nh_ret = hipz_h_modify_qp(shca->ipz_hca_handle,\r\nmy_qp->ipz_qp_handle,\r\n&my_qp->pf,\r\nupdate_mask,\r\nmqpcb,\r\nmy_qp->galpas.kernel);\r\nif (h_ret != H_SUCCESS) {\r\nret = ehca2ib_return_code(h_ret);\r\nehca_err(ibqp->device, "ENABLE in context of "\r\n"RESET_2_INIT failed! Maybe you didn't get "\r\n"a LID h_ret=%lli ehca_qp=%p qp_num=%x",\r\nh_ret, my_qp, ibqp->qp_num);\r\ngoto modify_qp_exit2;\r\n}\r\n}\r\nif ((qp_new_state == IB_QPS_ERR) && (qp_cur_state != IB_QPS_ERR)\r\n&& !is_user) {\r\nret = check_for_left_cqes(my_qp, shca);\r\nif (ret)\r\ngoto modify_qp_exit2;\r\n}\r\nif (statetrans == IB_QPST_ANY2RESET) {\r\nipz_qeit_reset(&my_qp->ipz_rqueue);\r\nipz_qeit_reset(&my_qp->ipz_squeue);\r\nif (qp_cur_state == IB_QPS_ERR && !is_user) {\r\ndel_from_err_list(my_qp->send_cq, &my_qp->sq_err_node);\r\nif (HAS_RQ(my_qp))\r\ndel_from_err_list(my_qp->recv_cq,\r\n&my_qp->rq_err_node);\r\n}\r\nif (!is_user)\r\nreset_queue_map(&my_qp->sq_map);\r\nif (HAS_RQ(my_qp) && !is_user)\r\nreset_queue_map(&my_qp->rq_map);\r\n}\r\nif (attr_mask & IB_QP_QKEY)\r\nmy_qp->qkey = attr->qkey;\r\nmodify_qp_exit2:\r\nif (squeue_locked) {\r\nspin_unlock_irqrestore(&my_qp->spinlock_s, flags);\r\nmy_qp->sqerr_purgeflag = 1;\r\n}\r\nmodify_qp_exit1:\r\nehca_free_fw_ctrlblock(mqpcb);\r\nreturn ret;\r\n}\r\nint ehca_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr, int attr_mask,\r\nstruct ib_udata *udata)\r\n{\r\nint ret = 0;\r\nstruct ehca_shca *shca = container_of(ibqp->device, struct ehca_shca,\r\nib_device);\r\nstruct ehca_qp *my_qp = container_of(ibqp, struct ehca_qp, ib_qp);\r\nif (ibqp->qp_type == IB_QPT_GSI || ibqp->qp_type == IB_QPT_SMI) {\r\nint port = my_qp->init_attr.port_num;\r\nstruct ehca_sport *sport = &shca->sport[port - 1];\r\nunsigned long flags;\r\nspin_lock_irqsave(&sport->mod_sqp_lock, flags);\r\nif (my_qp->mod_qp_parm) {\r\nstruct ehca_mod_qp_parm *p;\r\nif (my_qp->mod_qp_parm_idx >= EHCA_MOD_QP_PARM_MAX) {\r\nehca_err(&shca->ib_device,\r\n"mod_qp_parm overflow state=%x port=%x"\r\n" type=%x", attr->qp_state,\r\nmy_qp->init_attr.port_num,\r\nibqp->qp_type);\r\nspin_unlock_irqrestore(&sport->mod_sqp_lock,\r\nflags);\r\nreturn -EINVAL;\r\n}\r\np = &my_qp->mod_qp_parm[my_qp->mod_qp_parm_idx];\r\np->mask = attr_mask;\r\np->attr = *attr;\r\nmy_qp->mod_qp_parm_idx++;\r\nehca_dbg(&shca->ib_device,\r\n"Saved qp_attr for state=%x port=%x type=%x",\r\nattr->qp_state, my_qp->init_attr.port_num,\r\nibqp->qp_type);\r\nspin_unlock_irqrestore(&sport->mod_sqp_lock, flags);\r\ngoto out;\r\n}\r\nspin_unlock_irqrestore(&sport->mod_sqp_lock, flags);\r\n}\r\nret = internal_modify_qp(ibqp, attr, attr_mask, 0);\r\nout:\r\nif ((ret == 0) && (attr_mask & IB_QP_STATE))\r\nmy_qp->state = attr->qp_state;\r\nreturn ret;\r\n}\r\nvoid ehca_recover_sqp(struct ib_qp *sqp)\r\n{\r\nstruct ehca_qp *my_sqp = container_of(sqp, struct ehca_qp, ib_qp);\r\nint port = my_sqp->init_attr.port_num;\r\nstruct ib_qp_attr attr;\r\nstruct ehca_mod_qp_parm *qp_parm;\r\nint i, qp_parm_idx, ret;\r\nunsigned long flags, wr_cnt;\r\nif (!my_sqp->mod_qp_parm)\r\nreturn;\r\nehca_dbg(sqp->device, "SQP port=%x qp_num=%x", port, sqp->qp_num);\r\nqp_parm = my_sqp->mod_qp_parm;\r\nqp_parm_idx = my_sqp->mod_qp_parm_idx;\r\nfor (i = 0; i < qp_parm_idx; i++) {\r\nattr = qp_parm[i].attr;\r\nret = internal_modify_qp(sqp, &attr, qp_parm[i].mask, 0);\r\nif (ret) {\r\nehca_err(sqp->device, "Could not modify SQP port=%x "\r\n"qp_num=%x ret=%x", port, sqp->qp_num, ret);\r\ngoto free_qp_parm;\r\n}\r\nehca_dbg(sqp->device, "SQP port=%x qp_num=%x in state=%x",\r\nport, sqp->qp_num, attr.qp_state);\r\n}\r\nwr_cnt = my_sqp->ipz_rqueue.current_q_offset /\r\nmy_sqp->ipz_rqueue.qe_size;\r\nif (wr_cnt) {\r\nspin_lock_irqsave(&my_sqp->spinlock_r, flags);\r\nhipz_update_rqa(my_sqp, wr_cnt);\r\nspin_unlock_irqrestore(&my_sqp->spinlock_r, flags);\r\nehca_dbg(sqp->device, "doorbell port=%x qp_num=%x wr_cnt=%lx",\r\nport, sqp->qp_num, wr_cnt);\r\n}\r\nfree_qp_parm:\r\nkfree(qp_parm);\r\nmy_sqp->mod_qp_parm = NULL;\r\n}\r\nint ehca_query_qp(struct ib_qp *qp,\r\nstruct ib_qp_attr *qp_attr,\r\nint qp_attr_mask, struct ib_qp_init_attr *qp_init_attr)\r\n{\r\nstruct ehca_qp *my_qp = container_of(qp, struct ehca_qp, ib_qp);\r\nstruct ehca_shca *shca = container_of(qp->device, struct ehca_shca,\r\nib_device);\r\nstruct ipz_adapter_handle adapter_handle = shca->ipz_hca_handle;\r\nstruct hcp_modify_qp_control_block *qpcb;\r\nint cnt, ret = 0;\r\nu64 h_ret;\r\nif (qp_attr_mask & QP_ATTR_QUERY_NOT_SUPPORTED) {\r\nehca_err(qp->device, "Invalid attribute mask "\r\n"ehca_qp=%p qp_num=%x qp_attr_mask=%x ",\r\nmy_qp, qp->qp_num, qp_attr_mask);\r\nreturn -EINVAL;\r\n}\r\nqpcb = ehca_alloc_fw_ctrlblock(GFP_KERNEL);\r\nif (!qpcb) {\r\nehca_err(qp->device, "Out of memory for qpcb "\r\n"ehca_qp=%p qp_num=%x", my_qp, qp->qp_num);\r\nreturn -ENOMEM;\r\n}\r\nh_ret = hipz_h_query_qp(adapter_handle,\r\nmy_qp->ipz_qp_handle,\r\n&my_qp->pf,\r\nqpcb, my_qp->galpas.kernel);\r\nif (h_ret != H_SUCCESS) {\r\nret = ehca2ib_return_code(h_ret);\r\nehca_err(qp->device, "hipz_h_query_qp() failed "\r\n"ehca_qp=%p qp_num=%x h_ret=%lli",\r\nmy_qp, qp->qp_num, h_ret);\r\ngoto query_qp_exit1;\r\n}\r\nqp_attr->cur_qp_state = ehca2ib_qp_state(qpcb->qp_state);\r\nqp_attr->qp_state = qp_attr->cur_qp_state;\r\nif (qp_attr->cur_qp_state == -EINVAL) {\r\nret = -EINVAL;\r\nehca_err(qp->device, "Got invalid ehca_qp_state=%x "\r\n"ehca_qp=%p qp_num=%x",\r\nqpcb->qp_state, my_qp, qp->qp_num);\r\ngoto query_qp_exit1;\r\n}\r\nif (qp_attr->qp_state == IB_QPS_SQD)\r\nqp_attr->sq_draining = 1;\r\nqp_attr->qkey = qpcb->qkey;\r\nqp_attr->path_mtu = qpcb->path_mtu;\r\nqp_attr->path_mig_state = qpcb->path_migration_state - 1;\r\nqp_attr->rq_psn = qpcb->receive_psn;\r\nqp_attr->sq_psn = qpcb->send_psn;\r\nqp_attr->min_rnr_timer = qpcb->min_rnr_nak_timer_field;\r\nqp_attr->cap.max_send_wr = qpcb->max_nr_outst_send_wr-1;\r\nqp_attr->cap.max_recv_wr = qpcb->max_nr_outst_recv_wr-1;\r\nif (my_qp->qp_type == IB_QPT_UD) {\r\nqp_attr->cap.max_send_sge =\r\nqpcb->actual_nr_sges_in_sq_wqe - 2;\r\nqp_attr->cap.max_recv_sge =\r\nqpcb->actual_nr_sges_in_rq_wqe - 2;\r\n} else {\r\nqp_attr->cap.max_send_sge =\r\nqpcb->actual_nr_sges_in_sq_wqe;\r\nqp_attr->cap.max_recv_sge =\r\nqpcb->actual_nr_sges_in_rq_wqe;\r\n}\r\nqp_attr->cap.max_inline_data = my_qp->sq_max_inline_data_size;\r\nqp_attr->dest_qp_num = qpcb->dest_qp_nr;\r\nqp_attr->pkey_index = qpcb->prim_p_key_idx;\r\nqp_attr->port_num = qpcb->prim_phys_port;\r\nqp_attr->timeout = qpcb->timeout;\r\nqp_attr->retry_cnt = qpcb->retry_count;\r\nqp_attr->rnr_retry = qpcb->rnr_retry_count;\r\nqp_attr->alt_pkey_index = qpcb->alt_p_key_idx;\r\nqp_attr->alt_port_num = qpcb->alt_phys_port;\r\nqp_attr->alt_timeout = qpcb->timeout_al;\r\nqp_attr->max_dest_rd_atomic = qpcb->rdma_nr_atomic_resp_res;\r\nqp_attr->max_rd_atomic = qpcb->rdma_atomic_outst_dest_qp;\r\nqp_attr->ah_attr.sl = qpcb->service_level;\r\nif (qpcb->send_grh_flag) {\r\nqp_attr->ah_attr.ah_flags = IB_AH_GRH;\r\n}\r\nqp_attr->ah_attr.static_rate = qpcb->max_static_rate;\r\nqp_attr->ah_attr.dlid = qpcb->dlid;\r\nqp_attr->ah_attr.src_path_bits = qpcb->source_path_bits;\r\nqp_attr->ah_attr.port_num = qp_attr->port_num;\r\nqp_attr->ah_attr.grh.traffic_class = qpcb->traffic_class;\r\nqp_attr->ah_attr.grh.hop_limit = qpcb->hop_limit;\r\nqp_attr->ah_attr.grh.sgid_index = qpcb->source_gid_idx;\r\nqp_attr->ah_attr.grh.flow_label = qpcb->flow_label;\r\nfor (cnt = 0; cnt < 16; cnt++)\r\nqp_attr->ah_attr.grh.dgid.raw[cnt] =\r\nqpcb->dest_gid.byte[cnt];\r\nqp_attr->alt_ah_attr.sl = qpcb->service_level_al;\r\nif (qpcb->send_grh_flag_al) {\r\nqp_attr->alt_ah_attr.ah_flags = IB_AH_GRH;\r\n}\r\nqp_attr->alt_ah_attr.static_rate = qpcb->max_static_rate_al;\r\nqp_attr->alt_ah_attr.dlid = qpcb->dlid_al;\r\nqp_attr->alt_ah_attr.src_path_bits = qpcb->source_path_bits_al;\r\nqp_attr->alt_ah_attr.grh.traffic_class = qpcb->traffic_class_al;\r\nqp_attr->alt_ah_attr.grh.hop_limit = qpcb->hop_limit_al;\r\nqp_attr->alt_ah_attr.grh.sgid_index = qpcb->source_gid_idx_al;\r\nqp_attr->alt_ah_attr.grh.flow_label = qpcb->flow_label_al;\r\nfor (cnt = 0; cnt < 16; cnt++)\r\nqp_attr->alt_ah_attr.grh.dgid.raw[cnt] =\r\nqpcb->dest_gid_al.byte[cnt];\r\nif (qp_init_attr)\r\n*qp_init_attr = my_qp->init_attr;\r\nif (ehca_debug_level >= 2)\r\nehca_dmp(qpcb, 4*70, "qp_num=%x", qp->qp_num);\r\nquery_qp_exit1:\r\nehca_free_fw_ctrlblock(qpcb);\r\nreturn ret;\r\n}\r\nint ehca_modify_srq(struct ib_srq *ibsrq, struct ib_srq_attr *attr,\r\nenum ib_srq_attr_mask attr_mask, struct ib_udata *udata)\r\n{\r\nstruct ehca_qp *my_qp =\r\ncontainer_of(ibsrq, struct ehca_qp, ib_srq);\r\nstruct ehca_shca *shca =\r\ncontainer_of(ibsrq->pd->device, struct ehca_shca, ib_device);\r\nstruct hcp_modify_qp_control_block *mqpcb;\r\nu64 update_mask;\r\nu64 h_ret;\r\nint ret = 0;\r\nmqpcb = ehca_alloc_fw_ctrlblock(GFP_KERNEL);\r\nif (!mqpcb) {\r\nehca_err(ibsrq->device, "Could not get zeroed page for mqpcb "\r\n"ehca_qp=%p qp_num=%x ", my_qp, my_qp->real_qp_num);\r\nreturn -ENOMEM;\r\n}\r\nupdate_mask = 0;\r\nif (attr_mask & IB_SRQ_LIMIT) {\r\nattr_mask &= ~IB_SRQ_LIMIT;\r\nupdate_mask |=\r\nEHCA_BMASK_SET(MQPCB_MASK_CURR_SRQ_LIMIT, 1)\r\n| EHCA_BMASK_SET(MQPCB_MASK_QP_AFF_ASYN_EV_LOG_REG, 1);\r\nmqpcb->curr_srq_limit = attr->srq_limit;\r\nmqpcb->qp_aff_asyn_ev_log_reg =\r\nEHCA_BMASK_SET(QPX_AAELOG_RESET_SRQ_LIMIT, 1);\r\n}\r\nif (attr_mask) {\r\nehca_err(ibsrq->device, "invalid attribute mask bits set "\r\n"attr_mask=%x", attr_mask);\r\nret = -EINVAL;\r\ngoto modify_srq_exit0;\r\n}\r\nif (ehca_debug_level >= 2)\r\nehca_dmp(mqpcb, 4*70, "qp_num=%x", my_qp->real_qp_num);\r\nh_ret = hipz_h_modify_qp(shca->ipz_hca_handle, my_qp->ipz_qp_handle,\r\nNULL, update_mask, mqpcb,\r\nmy_qp->galpas.kernel);\r\nif (h_ret != H_SUCCESS) {\r\nret = ehca2ib_return_code(h_ret);\r\nehca_err(ibsrq->device, "hipz_h_modify_qp() failed h_ret=%lli "\r\n"ehca_qp=%p qp_num=%x",\r\nh_ret, my_qp, my_qp->real_qp_num);\r\n}\r\nmodify_srq_exit0:\r\nehca_free_fw_ctrlblock(mqpcb);\r\nreturn ret;\r\n}\r\nint ehca_query_srq(struct ib_srq *srq, struct ib_srq_attr *srq_attr)\r\n{\r\nstruct ehca_qp *my_qp = container_of(srq, struct ehca_qp, ib_srq);\r\nstruct ehca_shca *shca = container_of(srq->device, struct ehca_shca,\r\nib_device);\r\nstruct ipz_adapter_handle adapter_handle = shca->ipz_hca_handle;\r\nstruct hcp_modify_qp_control_block *qpcb;\r\nint ret = 0;\r\nu64 h_ret;\r\nqpcb = ehca_alloc_fw_ctrlblock(GFP_KERNEL);\r\nif (!qpcb) {\r\nehca_err(srq->device, "Out of memory for qpcb "\r\n"ehca_qp=%p qp_num=%x", my_qp, my_qp->real_qp_num);\r\nreturn -ENOMEM;\r\n}\r\nh_ret = hipz_h_query_qp(adapter_handle, my_qp->ipz_qp_handle,\r\nNULL, qpcb, my_qp->galpas.kernel);\r\nif (h_ret != H_SUCCESS) {\r\nret = ehca2ib_return_code(h_ret);\r\nehca_err(srq->device, "hipz_h_query_qp() failed "\r\n"ehca_qp=%p qp_num=%x h_ret=%lli",\r\nmy_qp, my_qp->real_qp_num, h_ret);\r\ngoto query_srq_exit1;\r\n}\r\nsrq_attr->max_wr = qpcb->max_nr_outst_recv_wr - 1;\r\nsrq_attr->max_sge = 3;\r\nsrq_attr->srq_limit = qpcb->curr_srq_limit;\r\nif (ehca_debug_level >= 2)\r\nehca_dmp(qpcb, 4*70, "qp_num=%x", my_qp->real_qp_num);\r\nquery_srq_exit1:\r\nehca_free_fw_ctrlblock(qpcb);\r\nreturn ret;\r\n}\r\nstatic int internal_destroy_qp(struct ib_device *dev, struct ehca_qp *my_qp,\r\nstruct ib_uobject *uobject)\r\n{\r\nstruct ehca_shca *shca = container_of(dev, struct ehca_shca, ib_device);\r\nstruct ehca_pd *my_pd = container_of(my_qp->ib_qp.pd, struct ehca_pd,\r\nib_pd);\r\nstruct ehca_sport *sport = &shca->sport[my_qp->init_attr.port_num - 1];\r\nu32 qp_num = my_qp->real_qp_num;\r\nint ret;\r\nu64 h_ret;\r\nu8 port_num;\r\nint is_user = 0;\r\nenum ib_qp_type qp_type;\r\nunsigned long flags;\r\nif (uobject) {\r\nis_user = 1;\r\nif (my_qp->mm_count_galpa ||\r\nmy_qp->mm_count_rqueue || my_qp->mm_count_squeue) {\r\nehca_err(dev, "Resources still referenced in "\r\n"user space qp_num=%x", qp_num);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (my_qp->send_cq) {\r\nret = ehca_cq_unassign_qp(my_qp->send_cq, qp_num);\r\nif (ret) {\r\nehca_err(dev, "Couldn't unassign qp from "\r\n"send_cq ret=%i qp_num=%x cq_num=%x", ret,\r\nqp_num, my_qp->send_cq->cq_number);\r\nreturn ret;\r\n}\r\n}\r\nwrite_lock_irqsave(&ehca_qp_idr_lock, flags);\r\nidr_remove(&ehca_qp_idr, my_qp->token);\r\nwrite_unlock_irqrestore(&ehca_qp_idr_lock, flags);\r\nif (HAS_RQ(my_qp) && !IS_SRQ(my_qp) && !is_user)\r\ndel_from_err_list(my_qp->recv_cq, &my_qp->rq_err_node);\r\nif (HAS_SQ(my_qp) && !is_user)\r\ndel_from_err_list(my_qp->send_cq, &my_qp->sq_err_node);\r\nwait_event(my_qp->wait_completion, !atomic_read(&my_qp->nr_events));\r\nh_ret = hipz_h_destroy_qp(shca->ipz_hca_handle, my_qp);\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(dev, "hipz_h_destroy_qp() failed h_ret=%lli "\r\n"ehca_qp=%p qp_num=%x", h_ret, my_qp, qp_num);\r\nreturn ehca2ib_return_code(h_ret);\r\n}\r\nport_num = my_qp->init_attr.port_num;\r\nqp_type = my_qp->init_attr.qp_type;\r\nif (qp_type == IB_QPT_SMI || qp_type == IB_QPT_GSI) {\r\nspin_lock_irqsave(&sport->mod_sqp_lock, flags);\r\nkfree(my_qp->mod_qp_parm);\r\nmy_qp->mod_qp_parm = NULL;\r\nshca->sport[port_num - 1].ibqp_sqp[qp_type] = NULL;\r\nspin_unlock_irqrestore(&sport->mod_sqp_lock, flags);\r\n}\r\nif (qp_type == IB_QPT_GSI) {\r\nstruct ib_event event;\r\nehca_info(dev, "device %s: port %x is inactive.",\r\nshca->ib_device.name, port_num);\r\nevent.device = &shca->ib_device;\r\nevent.event = IB_EVENT_PORT_ERR;\r\nevent.element.port_num = port_num;\r\nshca->sport[port_num - 1].port_state = IB_PORT_DOWN;\r\nib_dispatch_event(&event);\r\n}\r\nif (HAS_RQ(my_qp)) {\r\nipz_queue_dtor(my_pd, &my_qp->ipz_rqueue);\r\nif (!is_user)\r\nvfree(my_qp->rq_map.map);\r\n}\r\nif (HAS_SQ(my_qp)) {\r\nipz_queue_dtor(my_pd, &my_qp->ipz_squeue);\r\nif (!is_user)\r\nvfree(my_qp->sq_map.map);\r\n}\r\nkmem_cache_free(qp_cache, my_qp);\r\natomic_dec(&shca->num_qps);\r\nreturn 0;\r\n}\r\nint ehca_destroy_qp(struct ib_qp *qp)\r\n{\r\nreturn internal_destroy_qp(qp->device,\r\ncontainer_of(qp, struct ehca_qp, ib_qp),\r\nqp->uobject);\r\n}\r\nint ehca_destroy_srq(struct ib_srq *srq)\r\n{\r\nreturn internal_destroy_qp(srq->device,\r\ncontainer_of(srq, struct ehca_qp, ib_srq),\r\nsrq->uobject);\r\n}\r\nint ehca_init_qp_cache(void)\r\n{\r\nqp_cache = kmem_cache_create("ehca_cache_qp",\r\nsizeof(struct ehca_qp), 0,\r\nSLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (!qp_cache)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid ehca_cleanup_qp_cache(void)\r\n{\r\nif (qp_cache)\r\nkmem_cache_destroy(qp_cache);\r\n}
