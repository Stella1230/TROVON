static inline struct gr2d *to_gr2d(struct host1x_client *client)\r\n{\r\nreturn container_of(client, struct gr2d, client);\r\n}\r\nstatic int gr2d_client_init(struct host1x_client *client,\r\nstruct drm_device *drm)\r\n{\r\nreturn 0;\r\n}\r\nstatic int gr2d_client_exit(struct host1x_client *client)\r\n{\r\nreturn 0;\r\n}\r\nstatic int gr2d_open_channel(struct host1x_client *client,\r\nstruct host1x_drm_context *context)\r\n{\r\nstruct gr2d *gr2d = to_gr2d(client);\r\ncontext->channel = host1x_channel_get(gr2d->channel);\r\nif (!context->channel)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void gr2d_close_channel(struct host1x_drm_context *context)\r\n{\r\nhost1x_channel_put(context->channel);\r\n}\r\nstatic struct host1x_bo *host1x_bo_lookup(struct drm_device *drm,\r\nstruct drm_file *file,\r\nu32 handle)\r\n{\r\nstruct drm_gem_object *gem;\r\nstruct tegra_bo *bo;\r\ngem = drm_gem_object_lookup(drm, file, handle);\r\nif (!gem)\r\nreturn NULL;\r\nmutex_lock(&drm->struct_mutex);\r\ndrm_gem_object_unreference(gem);\r\nmutex_unlock(&drm->struct_mutex);\r\nbo = to_tegra_bo(gem);\r\nreturn &bo->base;\r\n}\r\nstatic int gr2d_submit(struct host1x_drm_context *context,\r\nstruct drm_tegra_submit *args, struct drm_device *drm,\r\nstruct drm_file *file)\r\n{\r\nstruct host1x_job *job;\r\nunsigned int num_cmdbufs = args->num_cmdbufs;\r\nunsigned int num_relocs = args->num_relocs;\r\nunsigned int num_waitchks = args->num_waitchks;\r\nstruct drm_tegra_cmdbuf __user *cmdbufs =\r\n(void * __user)(uintptr_t)args->cmdbufs;\r\nstruct drm_tegra_reloc __user *relocs =\r\n(void * __user)(uintptr_t)args->relocs;\r\nstruct drm_tegra_waitchk __user *waitchks =\r\n(void * __user)(uintptr_t)args->waitchks;\r\nstruct drm_tegra_syncpt syncpt;\r\nint err;\r\nif (args->num_syncpts != 1)\r\nreturn -EINVAL;\r\njob = host1x_job_alloc(context->channel, args->num_cmdbufs,\r\nargs->num_relocs, args->num_waitchks);\r\nif (!job)\r\nreturn -ENOMEM;\r\njob->num_relocs = args->num_relocs;\r\njob->num_waitchk = args->num_waitchks;\r\njob->client = (u32)args->context;\r\njob->class = context->client->class;\r\njob->serialize = true;\r\nwhile (num_cmdbufs) {\r\nstruct drm_tegra_cmdbuf cmdbuf;\r\nstruct host1x_bo *bo;\r\nerr = copy_from_user(&cmdbuf, cmdbufs, sizeof(cmdbuf));\r\nif (err)\r\ngoto fail;\r\nbo = host1x_bo_lookup(drm, file, cmdbuf.handle);\r\nif (!bo) {\r\nerr = -ENOENT;\r\ngoto fail;\r\n}\r\nhost1x_job_add_gather(job, bo, cmdbuf.words, cmdbuf.offset);\r\nnum_cmdbufs--;\r\ncmdbufs++;\r\n}\r\nerr = copy_from_user(job->relocarray, relocs,\r\nsizeof(*relocs) * num_relocs);\r\nif (err)\r\ngoto fail;\r\nwhile (num_relocs--) {\r\nstruct host1x_reloc *reloc = &job->relocarray[num_relocs];\r\nstruct host1x_bo *cmdbuf, *target;\r\ncmdbuf = host1x_bo_lookup(drm, file, (u32)reloc->cmdbuf);\r\ntarget = host1x_bo_lookup(drm, file, (u32)reloc->target);\r\nreloc->cmdbuf = cmdbuf;\r\nreloc->target = target;\r\nif (!reloc->target || !reloc->cmdbuf) {\r\nerr = -ENOENT;\r\ngoto fail;\r\n}\r\n}\r\nerr = copy_from_user(job->waitchk, waitchks,\r\nsizeof(*waitchks) * num_waitchks);\r\nif (err)\r\ngoto fail;\r\nerr = copy_from_user(&syncpt, (void * __user)(uintptr_t)args->syncpts,\r\nsizeof(syncpt));\r\nif (err)\r\ngoto fail;\r\njob->syncpt_id = syncpt.id;\r\njob->syncpt_incrs = syncpt.incrs;\r\njob->timeout = 10000;\r\njob->is_addr_reg = gr2d_is_addr_reg;\r\nif (args->timeout && args->timeout < 10000)\r\njob->timeout = args->timeout;\r\nerr = host1x_job_pin(job, context->client->dev);\r\nif (err)\r\ngoto fail;\r\nerr = host1x_job_submit(job);\r\nif (err)\r\ngoto fail_submit;\r\nargs->fence = job->syncpt_end;\r\nhost1x_job_put(job);\r\nreturn 0;\r\nfail_submit:\r\nhost1x_job_unpin(job);\r\nfail:\r\nhost1x_job_put(job);\r\nreturn err;\r\n}\r\nstatic void gr2d_init_addr_reg_map(struct device *dev, struct gr2d *gr2d)\r\n{\r\nconst u32 gr2d_addr_regs[] = {0x1a, 0x1b, 0x26, 0x2b, 0x2c, 0x2d, 0x31,\r\n0x32, 0x48, 0x49, 0x4a, 0x4b, 0x4c};\r\nunsigned long *bitmap;\r\nint i;\r\nbitmap = devm_kzalloc(dev, DIV_ROUND_UP(256, BITS_PER_BYTE),\r\nGFP_KERNEL);\r\nfor (i = 0; i < ARRAY_SIZE(gr2d_addr_regs); ++i) {\r\nu32 reg = gr2d_addr_regs[i];\r\nbitmap[BIT_WORD(reg)] |= BIT_MASK(reg);\r\n}\r\ngr2d->addr_regs = bitmap;\r\n}\r\nstatic int gr2d_is_addr_reg(struct device *dev, u32 class, u32 reg)\r\n{\r\nstruct gr2d *gr2d = dev_get_drvdata(dev);\r\nswitch (class) {\r\ncase HOST1X_CLASS_HOST1X:\r\nreturn reg == 0x2b;\r\ncase HOST1X_CLASS_GR2D:\r\ncase HOST1X_CLASS_GR2D_SB:\r\nreg &= 0xff;\r\nif (gr2d->addr_regs[BIT_WORD(reg)] & BIT_MASK(reg))\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int gr2d_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct host1x_drm *host1x = host1x_get_drm_data(dev->parent);\r\nint err;\r\nstruct gr2d *gr2d = NULL;\r\nstruct host1x_syncpt **syncpts;\r\ngr2d = devm_kzalloc(dev, sizeof(*gr2d), GFP_KERNEL);\r\nif (!gr2d)\r\nreturn -ENOMEM;\r\nsyncpts = devm_kzalloc(dev, sizeof(*syncpts), GFP_KERNEL);\r\nif (!syncpts)\r\nreturn -ENOMEM;\r\ngr2d->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(gr2d->clk)) {\r\ndev_err(dev, "cannot get clock\n");\r\nreturn PTR_ERR(gr2d->clk);\r\n}\r\nerr = clk_prepare_enable(gr2d->clk);\r\nif (err) {\r\ndev_err(dev, "cannot turn on clock\n");\r\nreturn err;\r\n}\r\ngr2d->channel = host1x_channel_request(dev);\r\nif (!gr2d->channel)\r\nreturn -ENOMEM;\r\n*syncpts = host1x_syncpt_request(dev, false);\r\nif (!(*syncpts)) {\r\nhost1x_channel_free(gr2d->channel);\r\nreturn -ENOMEM;\r\n}\r\ngr2d->client.ops = &gr2d_client_ops;\r\ngr2d->client.dev = dev;\r\ngr2d->client.class = HOST1X_CLASS_GR2D;\r\ngr2d->client.syncpts = syncpts;\r\ngr2d->client.num_syncpts = 1;\r\nerr = host1x_register_client(host1x, &gr2d->client);\r\nif (err < 0) {\r\ndev_err(dev, "failed to register host1x client: %d\n", err);\r\nreturn err;\r\n}\r\ngr2d_init_addr_reg_map(dev, gr2d);\r\nplatform_set_drvdata(pdev, gr2d);\r\nreturn 0;\r\n}\r\nstatic int __exit gr2d_remove(struct platform_device *pdev)\r\n{\r\nstruct host1x_drm *host1x = host1x_get_drm_data(pdev->dev.parent);\r\nstruct gr2d *gr2d = platform_get_drvdata(pdev);\r\nunsigned int i;\r\nint err;\r\nerr = host1x_unregister_client(host1x, &gr2d->client);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to unregister client: %d\n", err);\r\nreturn err;\r\n}\r\nfor (i = 0; i < gr2d->client.num_syncpts; i++)\r\nhost1x_syncpt_free(gr2d->client.syncpts[i]);\r\nhost1x_channel_free(gr2d->channel);\r\nclk_disable_unprepare(gr2d->clk);\r\nreturn 0;\r\n}
