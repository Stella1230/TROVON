static struct mcast_group *mcast_find(struct mcast_port *port,\r\nunion ib_gid *mgid)\r\n{\r\nstruct rb_node *node = port->table.rb_node;\r\nstruct mcast_group *group;\r\nint ret;\r\nwhile (node) {\r\ngroup = rb_entry(node, struct mcast_group, node);\r\nret = memcmp(mgid->raw, group->rec.mgid.raw, sizeof *mgid);\r\nif (!ret)\r\nreturn group;\r\nif (ret < 0)\r\nnode = node->rb_left;\r\nelse\r\nnode = node->rb_right;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mcast_group *mcast_insert(struct mcast_port *port,\r\nstruct mcast_group *group,\r\nint allow_duplicates)\r\n{\r\nstruct rb_node **link = &port->table.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct mcast_group *cur_group;\r\nint ret;\r\nwhile (*link) {\r\nparent = *link;\r\ncur_group = rb_entry(parent, struct mcast_group, node);\r\nret = memcmp(group->rec.mgid.raw, cur_group->rec.mgid.raw,\r\nsizeof group->rec.mgid);\r\nif (ret < 0)\r\nlink = &(*link)->rb_left;\r\nelse if (ret > 0)\r\nlink = &(*link)->rb_right;\r\nelse if (allow_duplicates)\r\nlink = &(*link)->rb_left;\r\nelse\r\nreturn cur_group;\r\n}\r\nrb_link_node(&group->node, parent, link);\r\nrb_insert_color(&group->node, &port->table);\r\nreturn NULL;\r\n}\r\nstatic void deref_port(struct mcast_port *port)\r\n{\r\nif (atomic_dec_and_test(&port->refcount))\r\ncomplete(&port->comp);\r\n}\r\nstatic void release_group(struct mcast_group *group)\r\n{\r\nstruct mcast_port *port = group->port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (atomic_dec_and_test(&group->refcount)) {\r\nrb_erase(&group->node, &port->table);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nkfree(group);\r\nderef_port(port);\r\n} else\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void deref_member(struct mcast_member *member)\r\n{\r\nif (atomic_dec_and_test(&member->refcount))\r\ncomplete(&member->comp);\r\n}\r\nstatic void queue_join(struct mcast_member *member)\r\n{\r\nstruct mcast_group *group = member->group;\r\nunsigned long flags;\r\nspin_lock_irqsave(&group->lock, flags);\r\nlist_add_tail(&member->list, &group->pending_list);\r\nif (group->state == MCAST_IDLE) {\r\ngroup->state = MCAST_BUSY;\r\natomic_inc(&group->refcount);\r\nqueue_work(mcast_wq, &group->work);\r\n}\r\nspin_unlock_irqrestore(&group->lock, flags);\r\n}\r\nstatic void adjust_membership(struct mcast_group *group, u8 join_state, int inc)\r\n{\r\nint i;\r\nfor (i = 0; i < 3; i++, join_state >>= 1)\r\nif (join_state & 0x1)\r\ngroup->members[i] += inc;\r\n}\r\nstatic u8 get_leave_state(struct mcast_group *group)\r\n{\r\nu8 leave_state = 0;\r\nint i;\r\nfor (i = 0; i < 3; i++)\r\nif (!group->members[i])\r\nleave_state |= (0x1 << i);\r\nreturn leave_state & group->rec.join_state;\r\n}\r\nstatic int check_selector(ib_sa_comp_mask comp_mask,\r\nib_sa_comp_mask selector_mask,\r\nib_sa_comp_mask value_mask,\r\nu8 selector, u8 src_value, u8 dst_value)\r\n{\r\nint err;\r\nif (!(comp_mask & selector_mask) || !(comp_mask & value_mask))\r\nreturn 0;\r\nswitch (selector) {\r\ncase IB_SA_GT:\r\nerr = (src_value <= dst_value);\r\nbreak;\r\ncase IB_SA_LT:\r\nerr = (src_value >= dst_value);\r\nbreak;\r\ncase IB_SA_EQ:\r\nerr = (src_value != dst_value);\r\nbreak;\r\ndefault:\r\nerr = 0;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int cmp_rec(struct ib_sa_mcmember_rec *src,\r\nstruct ib_sa_mcmember_rec *dst, ib_sa_comp_mask comp_mask)\r\n{\r\nif (comp_mask & IB_SA_MCMEMBER_REC_PORT_GID &&\r\nmemcmp(&src->port_gid, &dst->port_gid, sizeof src->port_gid))\r\nreturn -EINVAL;\r\nif (comp_mask & IB_SA_MCMEMBER_REC_QKEY && src->qkey != dst->qkey)\r\nreturn -EINVAL;\r\nif (comp_mask & IB_SA_MCMEMBER_REC_MLID && src->mlid != dst->mlid)\r\nreturn -EINVAL;\r\nif (check_selector(comp_mask, IB_SA_MCMEMBER_REC_MTU_SELECTOR,\r\nIB_SA_MCMEMBER_REC_MTU, dst->mtu_selector,\r\nsrc->mtu, dst->mtu))\r\nreturn -EINVAL;\r\nif (comp_mask & IB_SA_MCMEMBER_REC_TRAFFIC_CLASS &&\r\nsrc->traffic_class != dst->traffic_class)\r\nreturn -EINVAL;\r\nif (comp_mask & IB_SA_MCMEMBER_REC_PKEY && src->pkey != dst->pkey)\r\nreturn -EINVAL;\r\nif (check_selector(comp_mask, IB_SA_MCMEMBER_REC_RATE_SELECTOR,\r\nIB_SA_MCMEMBER_REC_RATE, dst->rate_selector,\r\nsrc->rate, dst->rate))\r\nreturn -EINVAL;\r\nif (check_selector(comp_mask,\r\nIB_SA_MCMEMBER_REC_PACKET_LIFE_TIME_SELECTOR,\r\nIB_SA_MCMEMBER_REC_PACKET_LIFE_TIME,\r\ndst->packet_life_time_selector,\r\nsrc->packet_life_time, dst->packet_life_time))\r\nreturn -EINVAL;\r\nif (comp_mask & IB_SA_MCMEMBER_REC_SL && src->sl != dst->sl)\r\nreturn -EINVAL;\r\nif (comp_mask & IB_SA_MCMEMBER_REC_FLOW_LABEL &&\r\nsrc->flow_label != dst->flow_label)\r\nreturn -EINVAL;\r\nif (comp_mask & IB_SA_MCMEMBER_REC_HOP_LIMIT &&\r\nsrc->hop_limit != dst->hop_limit)\r\nreturn -EINVAL;\r\nif (comp_mask & IB_SA_MCMEMBER_REC_SCOPE && src->scope != dst->scope)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int send_join(struct mcast_group *group, struct mcast_member *member)\r\n{\r\nstruct mcast_port *port = group->port;\r\nint ret;\r\ngroup->last_join = member;\r\nret = ib_sa_mcmember_rec_query(&sa_client, port->dev->device,\r\nport->port_num, IB_MGMT_METHOD_SET,\r\n&member->multicast.rec,\r\nmember->multicast.comp_mask,\r\n3000, GFP_KERNEL, join_handler, group,\r\n&group->query);\r\nif (ret >= 0) {\r\ngroup->query_id = ret;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int send_leave(struct mcast_group *group, u8 leave_state)\r\n{\r\nstruct mcast_port *port = group->port;\r\nstruct ib_sa_mcmember_rec rec;\r\nint ret;\r\nrec = group->rec;\r\nrec.join_state = leave_state;\r\ngroup->leave_state = leave_state;\r\nret = ib_sa_mcmember_rec_query(&sa_client, port->dev->device,\r\nport->port_num, IB_SA_METHOD_DELETE, &rec,\r\nIB_SA_MCMEMBER_REC_MGID |\r\nIB_SA_MCMEMBER_REC_PORT_GID |\r\nIB_SA_MCMEMBER_REC_JOIN_STATE,\r\n3000, GFP_KERNEL, leave_handler,\r\ngroup, &group->query);\r\nif (ret >= 0) {\r\ngroup->query_id = ret;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void join_group(struct mcast_group *group, struct mcast_member *member,\r\nu8 join_state)\r\n{\r\nmember->state = MCAST_MEMBER;\r\nadjust_membership(group, join_state, 1);\r\ngroup->rec.join_state |= join_state;\r\nmember->multicast.rec = group->rec;\r\nmember->multicast.rec.join_state = join_state;\r\nlist_move(&member->list, &group->active_list);\r\n}\r\nstatic int fail_join(struct mcast_group *group, struct mcast_member *member,\r\nint status)\r\n{\r\nspin_lock_irq(&group->lock);\r\nlist_del_init(&member->list);\r\nspin_unlock_irq(&group->lock);\r\nreturn member->multicast.callback(status, &member->multicast);\r\n}\r\nstatic void process_group_error(struct mcast_group *group)\r\n{\r\nstruct mcast_member *member;\r\nint ret = 0;\r\nu16 pkey_index;\r\nif (group->state == MCAST_PKEY_EVENT)\r\nret = ib_find_pkey(group->port->dev->device,\r\ngroup->port->port_num,\r\nbe16_to_cpu(group->rec.pkey), &pkey_index);\r\nspin_lock_irq(&group->lock);\r\nif (group->state == MCAST_PKEY_EVENT && !ret &&\r\ngroup->pkey_index == pkey_index)\r\ngoto out;\r\nwhile (!list_empty(&group->active_list)) {\r\nmember = list_entry(group->active_list.next,\r\nstruct mcast_member, list);\r\natomic_inc(&member->refcount);\r\nlist_del_init(&member->list);\r\nadjust_membership(group, member->multicast.rec.join_state, -1);\r\nmember->state = MCAST_ERROR;\r\nspin_unlock_irq(&group->lock);\r\nret = member->multicast.callback(-ENETRESET,\r\n&member->multicast);\r\nderef_member(member);\r\nif (ret)\r\nib_sa_free_multicast(&member->multicast);\r\nspin_lock_irq(&group->lock);\r\n}\r\ngroup->rec.join_state = 0;\r\nout:\r\ngroup->state = MCAST_BUSY;\r\nspin_unlock_irq(&group->lock);\r\n}\r\nstatic void mcast_work_handler(struct work_struct *work)\r\n{\r\nstruct mcast_group *group;\r\nstruct mcast_member *member;\r\nstruct ib_sa_multicast *multicast;\r\nint status, ret;\r\nu8 join_state;\r\ngroup = container_of(work, typeof(*group), work);\r\nretest:\r\nspin_lock_irq(&group->lock);\r\nwhile (!list_empty(&group->pending_list) ||\r\n(group->state != MCAST_BUSY)) {\r\nif (group->state != MCAST_BUSY) {\r\nspin_unlock_irq(&group->lock);\r\nprocess_group_error(group);\r\ngoto retest;\r\n}\r\nmember = list_entry(group->pending_list.next,\r\nstruct mcast_member, list);\r\nmulticast = &member->multicast;\r\njoin_state = multicast->rec.join_state;\r\natomic_inc(&member->refcount);\r\nif (join_state == (group->rec.join_state & join_state)) {\r\nstatus = cmp_rec(&group->rec, &multicast->rec,\r\nmulticast->comp_mask);\r\nif (!status)\r\njoin_group(group, member, join_state);\r\nelse\r\nlist_del_init(&member->list);\r\nspin_unlock_irq(&group->lock);\r\nret = multicast->callback(status, multicast);\r\n} else {\r\nspin_unlock_irq(&group->lock);\r\nstatus = send_join(group, member);\r\nif (!status) {\r\nderef_member(member);\r\nreturn;\r\n}\r\nret = fail_join(group, member, status);\r\n}\r\nderef_member(member);\r\nif (ret)\r\nib_sa_free_multicast(&member->multicast);\r\nspin_lock_irq(&group->lock);\r\n}\r\njoin_state = get_leave_state(group);\r\nif (join_state) {\r\ngroup->rec.join_state &= ~join_state;\r\nspin_unlock_irq(&group->lock);\r\nif (send_leave(group, join_state))\r\ngoto retest;\r\n} else {\r\ngroup->state = MCAST_IDLE;\r\nspin_unlock_irq(&group->lock);\r\nrelease_group(group);\r\n}\r\n}\r\nstatic void process_join_error(struct mcast_group *group, int status)\r\n{\r\nstruct mcast_member *member;\r\nint ret;\r\nspin_lock_irq(&group->lock);\r\nmember = list_entry(group->pending_list.next,\r\nstruct mcast_member, list);\r\nif (group->last_join == member) {\r\natomic_inc(&member->refcount);\r\nlist_del_init(&member->list);\r\nspin_unlock_irq(&group->lock);\r\nret = member->multicast.callback(status, &member->multicast);\r\nderef_member(member);\r\nif (ret)\r\nib_sa_free_multicast(&member->multicast);\r\n} else\r\nspin_unlock_irq(&group->lock);\r\n}\r\nstatic void join_handler(int status, struct ib_sa_mcmember_rec *rec,\r\nvoid *context)\r\n{\r\nstruct mcast_group *group = context;\r\nu16 pkey_index = MCAST_INVALID_PKEY_INDEX;\r\nif (status)\r\nprocess_join_error(group, status);\r\nelse {\r\nib_find_pkey(group->port->dev->device, group->port->port_num,\r\nbe16_to_cpu(rec->pkey), &pkey_index);\r\nspin_lock_irq(&group->port->lock);\r\ngroup->rec = *rec;\r\nif (group->state == MCAST_BUSY &&\r\ngroup->pkey_index == MCAST_INVALID_PKEY_INDEX)\r\ngroup->pkey_index = pkey_index;\r\nif (!memcmp(&mgid0, &group->rec.mgid, sizeof mgid0)) {\r\nrb_erase(&group->node, &group->port->table);\r\nmcast_insert(group->port, group, 1);\r\n}\r\nspin_unlock_irq(&group->port->lock);\r\n}\r\nmcast_work_handler(&group->work);\r\n}\r\nstatic void leave_handler(int status, struct ib_sa_mcmember_rec *rec,\r\nvoid *context)\r\n{\r\nstruct mcast_group *group = context;\r\nif (status && group->retries > 0 &&\r\n!send_leave(group, group->leave_state))\r\ngroup->retries--;\r\nelse\r\nmcast_work_handler(&group->work);\r\n}\r\nstatic struct mcast_group *acquire_group(struct mcast_port *port,\r\nunion ib_gid *mgid, gfp_t gfp_mask)\r\n{\r\nstruct mcast_group *group, *cur_group;\r\nunsigned long flags;\r\nint is_mgid0;\r\nis_mgid0 = !memcmp(&mgid0, mgid, sizeof mgid0);\r\nif (!is_mgid0) {\r\nspin_lock_irqsave(&port->lock, flags);\r\ngroup = mcast_find(port, mgid);\r\nif (group)\r\ngoto found;\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\ngroup = kzalloc(sizeof *group, gfp_mask);\r\nif (!group)\r\nreturn NULL;\r\ngroup->retries = 3;\r\ngroup->port = port;\r\ngroup->rec.mgid = *mgid;\r\ngroup->pkey_index = MCAST_INVALID_PKEY_INDEX;\r\nINIT_LIST_HEAD(&group->pending_list);\r\nINIT_LIST_HEAD(&group->active_list);\r\nINIT_WORK(&group->work, mcast_work_handler);\r\nspin_lock_init(&group->lock);\r\nspin_lock_irqsave(&port->lock, flags);\r\ncur_group = mcast_insert(port, group, is_mgid0);\r\nif (cur_group) {\r\nkfree(group);\r\ngroup = cur_group;\r\n} else\r\natomic_inc(&port->refcount);\r\nfound:\r\natomic_inc(&group->refcount);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn group;\r\n}\r\nstruct ib_sa_multicast *\r\nib_sa_join_multicast(struct ib_sa_client *client,\r\nstruct ib_device *device, u8 port_num,\r\nstruct ib_sa_mcmember_rec *rec,\r\nib_sa_comp_mask comp_mask, gfp_t gfp_mask,\r\nint (*callback)(int status,\r\nstruct ib_sa_multicast *multicast),\r\nvoid *context)\r\n{\r\nstruct mcast_device *dev;\r\nstruct mcast_member *member;\r\nstruct ib_sa_multicast *multicast;\r\nint ret;\r\ndev = ib_get_client_data(device, &mcast_client);\r\nif (!dev)\r\nreturn ERR_PTR(-ENODEV);\r\nmember = kmalloc(sizeof *member, gfp_mask);\r\nif (!member)\r\nreturn ERR_PTR(-ENOMEM);\r\nib_sa_client_get(client);\r\nmember->client = client;\r\nmember->multicast.rec = *rec;\r\nmember->multicast.comp_mask = comp_mask;\r\nmember->multicast.callback = callback;\r\nmember->multicast.context = context;\r\ninit_completion(&member->comp);\r\natomic_set(&member->refcount, 1);\r\nmember->state = MCAST_JOINING;\r\nmember->group = acquire_group(&dev->port[port_num - dev->start_port],\r\n&rec->mgid, gfp_mask);\r\nif (!member->group) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nmulticast = &member->multicast;\r\nqueue_join(member);\r\nreturn multicast;\r\nerr:\r\nib_sa_client_put(client);\r\nkfree(member);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid ib_sa_free_multicast(struct ib_sa_multicast *multicast)\r\n{\r\nstruct mcast_member *member;\r\nstruct mcast_group *group;\r\nmember = container_of(multicast, struct mcast_member, multicast);\r\ngroup = member->group;\r\nspin_lock_irq(&group->lock);\r\nif (member->state == MCAST_MEMBER)\r\nadjust_membership(group, multicast->rec.join_state, -1);\r\nlist_del_init(&member->list);\r\nif (group->state == MCAST_IDLE) {\r\ngroup->state = MCAST_BUSY;\r\nspin_unlock_irq(&group->lock);\r\nqueue_work(mcast_wq, &group->work);\r\n} else {\r\nspin_unlock_irq(&group->lock);\r\nrelease_group(group);\r\n}\r\nderef_member(member);\r\nwait_for_completion(&member->comp);\r\nib_sa_client_put(member->client);\r\nkfree(member);\r\n}\r\nint ib_sa_get_mcmember_rec(struct ib_device *device, u8 port_num,\r\nunion ib_gid *mgid, struct ib_sa_mcmember_rec *rec)\r\n{\r\nstruct mcast_device *dev;\r\nstruct mcast_port *port;\r\nstruct mcast_group *group;\r\nunsigned long flags;\r\nint ret = 0;\r\ndev = ib_get_client_data(device, &mcast_client);\r\nif (!dev)\r\nreturn -ENODEV;\r\nport = &dev->port[port_num - dev->start_port];\r\nspin_lock_irqsave(&port->lock, flags);\r\ngroup = mcast_find(port, mgid);\r\nif (group)\r\n*rec = group->rec;\r\nelse\r\nret = -EADDRNOTAVAIL;\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn ret;\r\n}\r\nint ib_init_ah_from_mcmember(struct ib_device *device, u8 port_num,\r\nstruct ib_sa_mcmember_rec *rec,\r\nstruct ib_ah_attr *ah_attr)\r\n{\r\nint ret;\r\nu16 gid_index;\r\nu8 p;\r\nret = ib_find_cached_gid(device, &rec->port_gid, &p, &gid_index);\r\nif (ret)\r\nreturn ret;\r\nmemset(ah_attr, 0, sizeof *ah_attr);\r\nah_attr->dlid = be16_to_cpu(rec->mlid);\r\nah_attr->sl = rec->sl;\r\nah_attr->port_num = port_num;\r\nah_attr->static_rate = rec->rate;\r\nah_attr->ah_flags = IB_AH_GRH;\r\nah_attr->grh.dgid = rec->mgid;\r\nah_attr->grh.sgid_index = (u8) gid_index;\r\nah_attr->grh.flow_label = be32_to_cpu(rec->flow_label);\r\nah_attr->grh.hop_limit = rec->hop_limit;\r\nah_attr->grh.traffic_class = rec->traffic_class;\r\nreturn 0;\r\n}\r\nstatic void mcast_groups_event(struct mcast_port *port,\r\nenum mcast_group_state state)\r\n{\r\nstruct mcast_group *group;\r\nstruct rb_node *node;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nfor (node = rb_first(&port->table); node; node = rb_next(node)) {\r\ngroup = rb_entry(node, struct mcast_group, node);\r\nspin_lock(&group->lock);\r\nif (group->state == MCAST_IDLE) {\r\natomic_inc(&group->refcount);\r\nqueue_work(mcast_wq, &group->work);\r\n}\r\nif (group->state != MCAST_GROUP_ERROR)\r\ngroup->state = state;\r\nspin_unlock(&group->lock);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void mcast_event_handler(struct ib_event_handler *handler,\r\nstruct ib_event *event)\r\n{\r\nstruct mcast_device *dev;\r\nint index;\r\ndev = container_of(handler, struct mcast_device, event_handler);\r\nif (rdma_port_get_link_layer(dev->device, event->element.port_num) !=\r\nIB_LINK_LAYER_INFINIBAND)\r\nreturn;\r\nindex = event->element.port_num - dev->start_port;\r\nswitch (event->event) {\r\ncase IB_EVENT_PORT_ERR:\r\ncase IB_EVENT_LID_CHANGE:\r\ncase IB_EVENT_SM_CHANGE:\r\ncase IB_EVENT_CLIENT_REREGISTER:\r\nmcast_groups_event(&dev->port[index], MCAST_GROUP_ERROR);\r\nbreak;\r\ncase IB_EVENT_PKEY_CHANGE:\r\nmcast_groups_event(&dev->port[index], MCAST_PKEY_EVENT);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void mcast_add_one(struct ib_device *device)\r\n{\r\nstruct mcast_device *dev;\r\nstruct mcast_port *port;\r\nint i;\r\nint count = 0;\r\nif (rdma_node_get_transport(device->node_type) != RDMA_TRANSPORT_IB)\r\nreturn;\r\ndev = kmalloc(sizeof *dev + device->phys_port_cnt * sizeof *port,\r\nGFP_KERNEL);\r\nif (!dev)\r\nreturn;\r\nif (device->node_type == RDMA_NODE_IB_SWITCH)\r\ndev->start_port = dev->end_port = 0;\r\nelse {\r\ndev->start_port = 1;\r\ndev->end_port = device->phys_port_cnt;\r\n}\r\nfor (i = 0; i <= dev->end_port - dev->start_port; i++) {\r\nif (rdma_port_get_link_layer(device, dev->start_port + i) !=\r\nIB_LINK_LAYER_INFINIBAND)\r\ncontinue;\r\nport = &dev->port[i];\r\nport->dev = dev;\r\nport->port_num = dev->start_port + i;\r\nspin_lock_init(&port->lock);\r\nport->table = RB_ROOT;\r\ninit_completion(&port->comp);\r\natomic_set(&port->refcount, 1);\r\n++count;\r\n}\r\nif (!count) {\r\nkfree(dev);\r\nreturn;\r\n}\r\ndev->device = device;\r\nib_set_client_data(device, &mcast_client, dev);\r\nINIT_IB_EVENT_HANDLER(&dev->event_handler, device, mcast_event_handler);\r\nib_register_event_handler(&dev->event_handler);\r\n}\r\nstatic void mcast_remove_one(struct ib_device *device)\r\n{\r\nstruct mcast_device *dev;\r\nstruct mcast_port *port;\r\nint i;\r\ndev = ib_get_client_data(device, &mcast_client);\r\nif (!dev)\r\nreturn;\r\nib_unregister_event_handler(&dev->event_handler);\r\nflush_workqueue(mcast_wq);\r\nfor (i = 0; i <= dev->end_port - dev->start_port; i++) {\r\nif (rdma_port_get_link_layer(device, dev->start_port + i) ==\r\nIB_LINK_LAYER_INFINIBAND) {\r\nport = &dev->port[i];\r\nderef_port(port);\r\nwait_for_completion(&port->comp);\r\n}\r\n}\r\nkfree(dev);\r\n}\r\nint mcast_init(void)\r\n{\r\nint ret;\r\nmcast_wq = create_singlethread_workqueue("ib_mcast");\r\nif (!mcast_wq)\r\nreturn -ENOMEM;\r\nib_sa_register_client(&sa_client);\r\nret = ib_register_client(&mcast_client);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nib_sa_unregister_client(&sa_client);\r\ndestroy_workqueue(mcast_wq);\r\nreturn ret;\r\n}\r\nvoid mcast_cleanup(void)\r\n{\r\nib_unregister_client(&mcast_client);\r\nib_sa_unregister_client(&sa_client);\r\ndestroy_workqueue(mcast_wq);\r\n}
