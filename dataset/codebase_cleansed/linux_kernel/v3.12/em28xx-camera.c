static int em28xx_initialize_mt9m111(struct em28xx *dev)\r\n{\r\nint i;\r\nunsigned char regs[][3] = {\r\n{ 0x0d, 0x00, 0x01, },\r\n{ 0x0d, 0x00, 0x00, },\r\n{ 0x0a, 0x00, 0x21, },\r\n{ 0x21, 0x04, 0x00, },\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(regs); i++)\r\ni2c_master_send(&dev->i2c_client[dev->def_i2c_bus],\r\n&regs[i][0], 3);\r\nreturn 0;\r\n}\r\nstatic int em28xx_initialize_mt9m001(struct em28xx *dev)\r\n{\r\nint i;\r\nunsigned char regs[][3] = {\r\n{ 0x0d, 0x00, 0x01, },\r\n{ 0x0d, 0x00, 0x00, },\r\n{ 0x04, 0x05, 0x00, },\r\n{ 0x03, 0x04, 0x00, },\r\n{ 0x20, 0x11, 0x00, },\r\n{ 0x06, 0x00, 0x10, },\r\n{ 0x2b, 0x00, 0x24, },\r\n{ 0x2e, 0x00, 0x24, },\r\n{ 0x35, 0x00, 0x24, },\r\n{ 0x2d, 0x00, 0x20, },\r\n{ 0x2c, 0x00, 0x20, },\r\n{ 0x09, 0x0a, 0xd4, },\r\n{ 0x35, 0x00, 0x57, },\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(regs); i++)\r\ni2c_master_send(&dev->i2c_client[dev->def_i2c_bus],\r\n&regs[i][0], 3);\r\nreturn 0;\r\n}\r\nstatic int em28xx_probe_sensor_micron(struct em28xx *dev)\r\n{\r\nint ret, i;\r\nchar *name;\r\nu8 reg;\r\n__be16 id_be;\r\nu16 id;\r\nstruct i2c_client client = dev->i2c_client[dev->def_i2c_bus];\r\ndev->em28xx_sensor = EM28XX_NOSENSOR;\r\nfor (i = 0; micron_sensor_addrs[i] != I2C_CLIENT_END; i++) {\r\nclient.addr = micron_sensor_addrs[i];\r\nreg = 0x00;\r\nret = i2c_master_send(&client, &reg, 1);\r\nif (ret < 0) {\r\nif (ret != -ENODEV)\r\nem28xx_errdev("couldn't read from i2c device 0x%02x: error %i\n",\r\nclient.addr << 1, ret);\r\ncontinue;\r\n}\r\nret = i2c_master_recv(&client, (u8 *)&id_be, 2);\r\nif (ret < 0) {\r\nem28xx_errdev("couldn't read from i2c device 0x%02x: error %i\n",\r\nclient.addr << 1, ret);\r\ncontinue;\r\n}\r\nid = be16_to_cpu(id_be);\r\nreg = 0xff;\r\nret = i2c_master_send(&client, &reg, 1);\r\nif (ret < 0) {\r\nem28xx_errdev("couldn't read from i2c device 0x%02x: error %i\n",\r\nclient.addr << 1, ret);\r\ncontinue;\r\n}\r\nret = i2c_master_recv(&client, (u8 *)&id_be, 2);\r\nif (ret < 0) {\r\nem28xx_errdev("couldn't read from i2c device 0x%02x: error %i\n",\r\nclient.addr << 1, ret);\r\ncontinue;\r\n}\r\nif (id != be16_to_cpu(id_be))\r\ncontinue;\r\nid = be16_to_cpu(id_be);\r\nswitch (id) {\r\ncase 0x1222:\r\nname = "MT9V012";\r\nbreak;\r\ncase 0x1229:\r\nname = "MT9V112";\r\nbreak;\r\ncase 0x1433:\r\nname = "MT9M011";\r\nbreak;\r\ncase 0x143a:\r\nname = "MT9M111";\r\ndev->em28xx_sensor = EM28XX_MT9M111;\r\nbreak;\r\ncase 0x148c:\r\nname = "MT9M112";\r\nbreak;\r\ncase 0x1511:\r\nname = "MT9D011";\r\nbreak;\r\ncase 0x8232:\r\ncase 0x8243:\r\nname = "MT9V011";\r\ndev->em28xx_sensor = EM28XX_MT9V011;\r\nbreak;\r\ncase 0x8431:\r\nname = "MT9M001";\r\ndev->em28xx_sensor = EM28XX_MT9M001;\r\nbreak;\r\ndefault:\r\nem28xx_info("unknown Micron sensor detected: 0x%04x\n",\r\nid);\r\nreturn 0;\r\n}\r\nif (dev->em28xx_sensor == EM28XX_NOSENSOR)\r\nem28xx_info("unsupported sensor detected: %s\n", name);\r\nelse\r\nem28xx_info("sensor %s detected\n", name);\r\ndev->i2c_client[dev->def_i2c_bus].addr = client.addr;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int em28xx_probe_sensor_omnivision(struct em28xx *dev)\r\n{\r\nint ret, i;\r\nchar *name;\r\nu8 reg;\r\nu16 id;\r\nstruct i2c_client client = dev->i2c_client[dev->def_i2c_bus];\r\ndev->em28xx_sensor = EM28XX_NOSENSOR;\r\nfor (i = 0; omnivision_sensor_addrs[i] != I2C_CLIENT_END; i++) {\r\nclient.addr = omnivision_sensor_addrs[i];\r\nreg = 0x1c;\r\nret = i2c_smbus_read_byte_data(&client, reg);\r\nif (ret < 0) {\r\nif (ret != -ENODEV)\r\nem28xx_errdev("couldn't read from i2c device 0x%02x: error %i\n",\r\nclient.addr << 1, ret);\r\ncontinue;\r\n}\r\nid = ret << 8;\r\nreg = 0x1d;\r\nret = i2c_smbus_read_byte_data(&client, reg);\r\nif (ret < 0) {\r\nem28xx_errdev("couldn't read from i2c device 0x%02x: error %i\n",\r\nclient.addr << 1, ret);\r\ncontinue;\r\n}\r\nid += ret;\r\nif (id != 0x7fa2)\r\ncontinue;\r\nreg = 0x0a;\r\nret = i2c_smbus_read_byte_data(&client, reg);\r\nif (ret < 0) {\r\nem28xx_errdev("couldn't read from i2c device 0x%02x: error %i\n",\r\nclient.addr << 1, ret);\r\ncontinue;\r\n}\r\nid = ret << 8;\r\nreg = 0x0b;\r\nret = i2c_smbus_read_byte_data(&client, reg);\r\nif (ret < 0) {\r\nem28xx_errdev("couldn't read from i2c device 0x%02x: error %i\n",\r\nclient.addr << 1, ret);\r\ncontinue;\r\n}\r\nid += ret;\r\nswitch (id) {\r\ncase 0x2642:\r\nname = "OV2640";\r\ndev->em28xx_sensor = EM28XX_OV2640;\r\nbreak;\r\ncase 0x7648:\r\nname = "OV7648";\r\nbreak;\r\ncase 0x7660:\r\nname = "OV7660";\r\nbreak;\r\ncase 0x7673:\r\nname = "OV7670";\r\nbreak;\r\ncase 0x7720:\r\nname = "OV7720";\r\nbreak;\r\ncase 0x7721:\r\nname = "OV7725";\r\nbreak;\r\ncase 0x9648:\r\ncase 0x9649:\r\nname = "OV9640";\r\nbreak;\r\ncase 0x9650:\r\ncase 0x9652:\r\nname = "OV9650";\r\nbreak;\r\ncase 0x9656:\r\ncase 0x9657:\r\nname = "OV9655";\r\nbreak;\r\ndefault:\r\nem28xx_info("unknown OmniVision sensor detected: 0x%04x\n",\r\nid);\r\nreturn 0;\r\n}\r\nif (dev->em28xx_sensor == EM28XX_NOSENSOR)\r\nem28xx_info("unsupported sensor detected: %s\n", name);\r\nelse\r\nem28xx_info("sensor %s detected\n", name);\r\ndev->i2c_client[dev->def_i2c_bus].addr = client.addr;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nint em28xx_detect_sensor(struct em28xx *dev)\r\n{\r\nint ret;\r\nret = em28xx_probe_sensor_micron(dev);\r\nif (dev->em28xx_sensor == EM28XX_NOSENSOR && ret < 0)\r\nret = em28xx_probe_sensor_omnivision(dev);\r\nif (dev->em28xx_sensor == EM28XX_NOSENSOR && ret < 0) {\r\nem28xx_info("No sensor detected\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nint em28xx_init_camera(struct em28xx *dev)\r\n{\r\nswitch (dev->em28xx_sensor) {\r\ncase EM28XX_MT9V011:\r\n{\r\nstruct mt9v011_platform_data pdata;\r\nstruct i2c_board_info mt9v011_info = {\r\n.type = "mt9v011",\r\n.addr = dev->i2c_client[dev->def_i2c_bus].addr,\r\n.platform_data = &pdata,\r\n};\r\ndev->sensor_xres = 640;\r\ndev->sensor_yres = 480;\r\ndev->board.xclk = EM28XX_XCLK_FREQUENCY_4_3MHZ;\r\nem28xx_write_reg(dev, EM28XX_R0F_XCLK, dev->board.xclk);\r\ndev->sensor_xtal = 4300000;\r\npdata.xtal = dev->sensor_xtal;\r\nif (NULL ==\r\nv4l2_i2c_new_subdev_board(&dev->v4l2_dev,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n&mt9v011_info, NULL))\r\nreturn -ENODEV;\r\ndev->vinmode = 0x0d;\r\ndev->vinctl = 0x00;\r\nbreak;\r\n}\r\ncase EM28XX_MT9M001:\r\ndev->sensor_xres = 1280;\r\ndev->sensor_yres = 1024;\r\nem28xx_initialize_mt9m001(dev);\r\ndev->vinmode = 0x0c;\r\ndev->vinctl = 0x00;\r\nbreak;\r\ncase EM28XX_MT9M111:\r\ndev->sensor_xres = 640;\r\ndev->sensor_yres = 512;\r\ndev->board.xclk = EM28XX_XCLK_FREQUENCY_48MHZ;\r\nem28xx_write_reg(dev, EM28XX_R0F_XCLK, dev->board.xclk);\r\nem28xx_initialize_mt9m111(dev);\r\ndev->vinmode = 0x0a;\r\ndev->vinctl = 0x00;\r\nbreak;\r\ncase EM28XX_OV2640:\r\n{\r\nstruct v4l2_subdev *subdev;\r\nstruct i2c_board_info ov2640_info = {\r\n.type = "ov2640",\r\n.flags = I2C_CLIENT_SCCB,\r\n.addr = dev->i2c_client[dev->def_i2c_bus].addr,\r\n.platform_data = &camlink,\r\n};\r\nstruct v4l2_mbus_framefmt fmt;\r\ndev->sensor_xres = 640;\r\ndev->sensor_yres = 480;\r\nsubdev =\r\nv4l2_i2c_new_subdev_board(&dev->v4l2_dev,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n&ov2640_info, NULL);\r\nfmt.code = V4L2_MBUS_FMT_YUYV8_2X8;\r\nfmt.width = 640;\r\nfmt.height = 480;\r\nv4l2_subdev_call(subdev, video, s_mbus_fmt, &fmt);\r\ndev->board.xclk = EM28XX_XCLK_FREQUENCY_24MHZ;\r\nem28xx_write_reg(dev, EM28XX_R0F_XCLK, dev->board.xclk);\r\ndev->vinmode = 0x08;\r\ndev->vinctl = 0x00;\r\nbreak;\r\n}\r\ncase EM28XX_NOSENSOR:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}
