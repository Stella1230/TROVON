static int phase22_init(struct snd_ice1712 *ice)\r\n{\r\nstruct snd_akm4xxx *ak;\r\nint err;\r\nswitch (ice->eeprom.subvendor) {\r\ncase VT1724_SUBDEVICE_PHASE22:\r\ncase VT1724_SUBDEVICE_TS22:\r\nice->num_total_dacs = 2;\r\nice->num_total_adcs = 2;\r\nice->vt1720 = 1;\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nreturn -EINVAL;\r\n}\r\nice->akm = kzalloc(sizeof(struct snd_akm4xxx), GFP_KERNEL);\r\nak = ice->akm;\r\nif (!ak)\r\nreturn -ENOMEM;\r\nice->akm_codecs = 1;\r\nswitch (ice->eeprom.subvendor) {\r\ncase VT1724_SUBDEVICE_PHASE22:\r\ncase VT1724_SUBDEVICE_TS22:\r\nerr = snd_ice1712_akm4xxx_init(ak, &akm_phase22,\r\n&akm_phase22_priv, ice);\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int phase22_add_controls(struct snd_ice1712 *ice)\r\n{\r\nint err = 0;\r\nswitch (ice->eeprom.subvendor) {\r\ncase VT1724_SUBDEVICE_PHASE22:\r\ncase VT1724_SUBDEVICE_TS22:\r\nerr = snd_ice1712_akm4xxx_build_controls(ice);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void phase28_spi_write(struct snd_ice1712 *ice, unsigned int cs,\r\nunsigned int data, int bits)\r\n{\r\nunsigned int tmp;\r\nint i;\r\ntmp = snd_ice1712_gpio_read(ice);\r\nsnd_ice1712_gpio_set_mask(ice, ~(PHASE28_WM_RW|PHASE28_SPI_MOSI|\r\nPHASE28_SPI_CLK|PHASE28_WM_CS));\r\ntmp |= PHASE28_WM_RW;\r\ntmp &= ~cs;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\nfor (i = bits - 1; i >= 0; i--) {\r\ntmp &= ~PHASE28_SPI_CLK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\nif (data & (1 << i))\r\ntmp |= PHASE28_SPI_MOSI;\r\nelse\r\ntmp &= ~PHASE28_SPI_MOSI;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\ntmp |= PHASE28_SPI_CLK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\n}\r\ntmp &= ~PHASE28_SPI_CLK;\r\ntmp |= cs;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\ntmp |= PHASE28_SPI_CLK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\n}\r\nstatic unsigned short wm_get(struct snd_ice1712 *ice, int reg)\r\n{\r\nreg <<= 1;\r\nreturn ((unsigned short)ice->akm[0].images[reg] << 8) |\r\nice->akm[0].images[reg + 1];\r\n}\r\nstatic void wm_put_nocache(struct snd_ice1712 *ice, int reg, unsigned short val)\r\n{\r\nphase28_spi_write(ice, PHASE28_WM_CS, (reg << 9) | (val & 0x1ff), 16);\r\n}\r\nstatic void wm_put(struct snd_ice1712 *ice, int reg, unsigned short val)\r\n{\r\nwm_put_nocache(ice, reg, val);\r\nreg <<= 1;\r\nice->akm[0].images[reg] = val >> 8;\r\nice->akm[0].images[reg + 1] = val;\r\n}\r\nstatic void wm_set_vol(struct snd_ice1712 *ice, unsigned int index,\r\nunsigned short vol, unsigned short master)\r\n{\r\nunsigned char nvol;\r\nif ((master & WM_VOL_MUTE) || (vol & WM_VOL_MUTE))\r\nnvol = 0;\r\nelse\r\nnvol = 127 - wm_vol[(((vol & ~WM_VOL_MUTE) *\r\n(master & ~WM_VOL_MUTE)) / 127) & WM_VOL_MAX];\r\nwm_put(ice, index, nvol);\r\nwm_put_nocache(ice, index, 0x180 | nvol);\r\n}\r\nstatic int wm_pcm_mute_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&ice->gpio_mutex);\r\nucontrol->value.integer.value[0] = (wm_get(ice, WM_MUTE) & 0x10) ?\r\n0 : 1;\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn 0;\r\n}\r\nstatic int wm_pcm_mute_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short nval, oval;\r\nint change;\r\nsnd_ice1712_save_gpio_status(ice);\r\noval = wm_get(ice, WM_MUTE);\r\nnval = (oval & ~0x10) | (ucontrol->value.integer.value[0] ? 0 : 0x10);\r\nchange = (nval != oval);\r\nif (change)\r\nwm_put(ice, WM_MUTE, nval);\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic int wm_master_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = WM_VOL_MAX;\r\nreturn 0;\r\n}\r\nstatic int wm_master_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct phase28_spec *spec = ice->spec;\r\nint i;\r\nfor (i = 0; i < 2; i++)\r\nucontrol->value.integer.value[i] = spec->master[i] &\r\n~WM_VOL_MUTE;\r\nreturn 0;\r\n}\r\nstatic int wm_master_vol_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct phase28_spec *spec = ice->spec;\r\nint ch, change = 0;\r\nsnd_ice1712_save_gpio_status(ice);\r\nfor (ch = 0; ch < 2; ch++) {\r\nunsigned int vol = ucontrol->value.integer.value[ch];\r\nif (vol > WM_VOL_MAX)\r\ncontinue;\r\nvol |= spec->master[ch] & WM_VOL_MUTE;\r\nif (vol != spec->master[ch]) {\r\nint dac;\r\nspec->master[ch] = vol;\r\nfor (dac = 0; dac < ice->num_total_dacs; dac += 2)\r\nwm_set_vol(ice, WM_DAC_ATTEN + dac + ch,\r\nspec->vol[dac + ch],\r\nspec->master[ch]);\r\nchange = 1;\r\n}\r\n}\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic int phase28_init(struct snd_ice1712 *ice)\r\n{\r\nstatic const unsigned short wm_inits_phase28[] = {\r\n0x1b, 0x044,\r\n0x1c, 0x00B,\r\n0x1d, 0x009,\r\n0x18, 0x000,\r\n0x16, 0x122,\r\n0x17, 0x022,\r\n0x00, 0,\r\n0x01, 0,\r\n0x02, 0,\r\n0x03, 0,\r\n0x04, 0,\r\n0x05, 0,\r\n0x06, 0,\r\n0x07, 0,\r\n0x08, 0x100,\r\n0x09, 0xff,\r\n0x0a, 0xff,\r\n0x0b, 0xff,\r\n0x0c, 0xff,\r\n0x0d, 0xff,\r\n0x0e, 0xff,\r\n0x0f, 0xff,\r\n0x10, 0xff,\r\n0x11, 0x1ff,\r\n0x12, 0x000,\r\n0x13, 0x090,\r\n0x14, 0x000,\r\n0x15, 0x000,\r\n0x19, 0x000,\r\n0x1a, 0x000,\r\n(unsigned short)-1\r\n};\r\nunsigned int tmp;\r\nstruct snd_akm4xxx *ak;\r\nstruct phase28_spec *spec;\r\nconst unsigned short *p;\r\nint i;\r\nice->num_total_dacs = 8;\r\nice->num_total_adcs = 2;\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\nice->spec = spec;\r\nice->akm = kzalloc(sizeof(struct snd_akm4xxx), GFP_KERNEL);\r\nak = ice->akm;\r\nif (!ak)\r\nreturn -ENOMEM;\r\nice->akm_codecs = 1;\r\nsnd_ice1712_gpio_set_dir(ice, 0x5fffff);\r\nsnd_ice1712_save_gpio_status(ice);\r\nsnd_ice1712_gpio_set_mask(ice, ~(PHASE28_WM_RESET|PHASE28_WM_CS|\r\nPHASE28_HP_SEL));\r\ntmp = snd_ice1712_gpio_read(ice);\r\ntmp &= ~PHASE28_WM_RESET;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\ntmp |= PHASE28_WM_CS;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\ntmp |= PHASE28_WM_RESET;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\np = wm_inits_phase28;\r\nfor (; *p != (unsigned short)-1; p += 2)\r\nwm_put(ice, p[0], p[1]);\r\nsnd_ice1712_restore_gpio_status(ice);\r\nspec->master[0] = WM_VOL_MUTE;\r\nspec->master[1] = WM_VOL_MUTE;\r\nfor (i = 0; i < ice->num_total_dacs; i++) {\r\nspec->vol[i] = WM_VOL_MUTE;\r\nwm_set_vol(ice, i, spec->vol[i], spec->master[i % 2]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint voices = kcontrol->private_value >> 8;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = voices;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 0x7F;\r\nreturn 0;\r\n}\r\nstatic int wm_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct phase28_spec *spec = ice->spec;\r\nint i, ofs, voices;\r\nvoices = kcontrol->private_value >> 8;\r\nofs = kcontrol->private_value & 0xff;\r\nfor (i = 0; i < voices; i++)\r\nucontrol->value.integer.value[i] =\r\nspec->vol[ofs+i] & ~WM_VOL_MUTE;\r\nreturn 0;\r\n}\r\nstatic int wm_vol_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct phase28_spec *spec = ice->spec;\r\nint i, idx, ofs, voices;\r\nint change = 0;\r\nvoices = kcontrol->private_value >> 8;\r\nofs = kcontrol->private_value & 0xff;\r\nsnd_ice1712_save_gpio_status(ice);\r\nfor (i = 0; i < voices; i++) {\r\nunsigned int vol;\r\nvol = ucontrol->value.integer.value[i];\r\nif (vol > 0x7f)\r\ncontinue;\r\nvol |= spec->vol[ofs+i] & WM_VOL_MUTE;\r\nif (vol != spec->vol[ofs+i]) {\r\nspec->vol[ofs+i] = vol;\r\nidx = WM_DAC_ATTEN + ofs + i;\r\nwm_set_vol(ice, idx, spec->vol[ofs+i],\r\nspec->master[i]);\r\nchange = 1;\r\n}\r\n}\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic int wm_mute_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo) {\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = kcontrol->private_value >> 8;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int wm_mute_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct phase28_spec *spec = ice->spec;\r\nint voices, ofs, i;\r\nvoices = kcontrol->private_value >> 8;\r\nofs = kcontrol->private_value & 0xFF;\r\nfor (i = 0; i < voices; i++)\r\nucontrol->value.integer.value[i] =\r\n(spec->vol[ofs+i] & WM_VOL_MUTE) ? 0 : 1;\r\nreturn 0;\r\n}\r\nstatic int wm_mute_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct phase28_spec *spec = ice->spec;\r\nint change = 0, voices, ofs, i;\r\nvoices = kcontrol->private_value >> 8;\r\nofs = kcontrol->private_value & 0xFF;\r\nsnd_ice1712_save_gpio_status(ice);\r\nfor (i = 0; i < voices; i++) {\r\nint val = (spec->vol[ofs + i] & WM_VOL_MUTE) ? 0 : 1;\r\nif (ucontrol->value.integer.value[i] != val) {\r\nspec->vol[ofs + i] &= ~WM_VOL_MUTE;\r\nspec->vol[ofs + i] |=\r\nucontrol->value.integer.value[i] ? 0 :\r\nWM_VOL_MUTE;\r\nwm_set_vol(ice, ofs + i, spec->vol[ofs + i],\r\nspec->master[i]);\r\nchange = 1;\r\n}\r\n}\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic int wm_master_mute_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct phase28_spec *spec = ice->spec;\r\nucontrol->value.integer.value[0] =\r\n(spec->master[0] & WM_VOL_MUTE) ? 0 : 1;\r\nucontrol->value.integer.value[1] =\r\n(spec->master[1] & WM_VOL_MUTE) ? 0 : 1;\r\nreturn 0;\r\n}\r\nstatic int wm_master_mute_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct phase28_spec *spec = ice->spec;\r\nint change = 0, i;\r\nsnd_ice1712_save_gpio_status(ice);\r\nfor (i = 0; i < 2; i++) {\r\nint val = (spec->master[i] & WM_VOL_MUTE) ? 0 : 1;\r\nif (ucontrol->value.integer.value[i] != val) {\r\nint dac;\r\nspec->master[i] &= ~WM_VOL_MUTE;\r\nspec->master[i] |=\r\nucontrol->value.integer.value[i] ? 0 :\r\nWM_VOL_MUTE;\r\nfor (dac = 0; dac < ice->num_total_dacs; dac += 2)\r\nwm_set_vol(ice, WM_DAC_ATTEN + dac + i,\r\nspec->vol[dac + i],\r\nspec->master[i]);\r\nchange = 1;\r\n}\r\n}\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic int wm_pcm_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = PCM_RES;\r\nreturn 0;\r\n}\r\nstatic int wm_pcm_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short val;\r\nmutex_lock(&ice->gpio_mutex);\r\nval = wm_get(ice, WM_DAC_DIG_MASTER_ATTEN) & 0xff;\r\nval = val > PCM_MIN ? (val - PCM_MIN) : 0;\r\nucontrol->value.integer.value[0] = val;\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn 0;\r\n}\r\nstatic int wm_pcm_vol_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short ovol, nvol;\r\nint change = 0;\r\nnvol = ucontrol->value.integer.value[0];\r\nif (nvol > PCM_RES)\r\nreturn -EINVAL;\r\nsnd_ice1712_save_gpio_status(ice);\r\nnvol = (nvol ? (nvol + PCM_MIN) : 0) & 0xff;\r\novol = wm_get(ice, WM_DAC_DIG_MASTER_ATTEN) & 0xff;\r\nif (ovol != nvol) {\r\nwm_put(ice, WM_DAC_DIG_MASTER_ATTEN, nvol);\r\nwm_put_nocache(ice, WM_DAC_DIG_MASTER_ATTEN, nvol | 0x100);\r\nchange = 1;\r\n}\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic int phase28_deemp_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = (wm_get(ice, WM_DAC_CTRL2) & 0xf) ==\r\n0xf;\r\nreturn 0;\r\n}\r\nstatic int phase28_deemp_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint temp, temp2;\r\ntemp = wm_get(ice, WM_DAC_CTRL2);\r\ntemp2 = temp;\r\nif (ucontrol->value.integer.value[0])\r\ntemp |= 0xf;\r\nelse\r\ntemp &= ~0xf;\r\nif (temp != temp2) {\r\nwm_put(ice, WM_DAC_CTRL2, temp);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int phase28_oversampling_info(struct snd_kcontrol *k,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[2] = { "128x", "64x" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 2;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items -\r\n1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int phase28_oversampling_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = (wm_get(ice, WM_MASTER) & 0x8) ==\r\n0x8;\r\nreturn 0;\r\n}\r\nstatic int phase28_oversampling_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint temp, temp2;\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\ntemp = wm_get(ice, WM_MASTER);\r\ntemp2 = temp;\r\nif (ucontrol->value.enumerated.item[0])\r\ntemp |= 0x8;\r\nelse\r\ntemp &= ~0x8;\r\nif (temp != temp2) {\r\nwm_put(ice, WM_MASTER, temp);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int phase28_add_controls(struct snd_ice1712 *ice)\r\n{\r\nunsigned int i, counts;\r\nint err;\r\ncounts = ARRAY_SIZE(phase28_dac_controls);\r\nfor (i = 0; i < counts; i++) {\r\nerr = snd_ctl_add(ice->card,\r\nsnd_ctl_new1(&phase28_dac_controls[i],\r\nice));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(wm_controls); i++) {\r\nerr = snd_ctl_add(ice->card,\r\nsnd_ctl_new1(&wm_controls[i], ice));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
