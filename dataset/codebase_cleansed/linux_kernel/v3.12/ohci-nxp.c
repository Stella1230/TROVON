static void isp1301_configure_lpc32xx(void)\r\n{\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\n(ISP1301_I2C_MODE_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR),\r\nMC1_UART_EN);\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\n(ISP1301_I2C_MODE_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR),\r\n~MC1_SPEED_REG);\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\nISP1301_I2C_MODE_CONTROL_1, MC1_SPEED_REG);\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\n(ISP1301_I2C_MODE_CONTROL_2 | ISP1301_I2C_REG_CLEAR_ADDR),\r\n~0);\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\nISP1301_I2C_MODE_CONTROL_2,\r\n(MC2_BI_DI | MC2_PSW_EN | MC2_SPD_SUSP_CTRL));\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\n(ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR), ~0);\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\nISP1301_I2C_MODE_CONTROL_1, MC1_DAT_SE0);\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\nISP1301_I2C_OTG_CONTROL_1,\r\n(OTG1_DM_PULLDOWN | OTG1_DP_PULLDOWN));\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\n(ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR),\r\n(OTG1_DM_PULLUP | OTG1_DP_PULLUP));\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\nISP1301_I2C_INTERRUPT_LATCH | ISP1301_I2C_REG_CLEAR_ADDR, ~0);\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\nISP1301_I2C_INTERRUPT_FALLING | ISP1301_I2C_REG_CLEAR_ADDR,\r\n~0);\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\nISP1301_I2C_INTERRUPT_RISING | ISP1301_I2C_REG_CLEAR_ADDR, ~0);\r\n__raw_writel(__raw_readl(USB_CTRL) | USB_HOST_NEED_CLK_EN, USB_CTRL);\r\nprintk(KERN_INFO "ISP1301 Vendor ID : 0x%04x\n",\r\ni2c_smbus_read_word_data(isp1301_i2c_client, 0x00));\r\nprintk(KERN_INFO "ISP1301 Product ID : 0x%04x\n",\r\ni2c_smbus_read_word_data(isp1301_i2c_client, 0x02));\r\nprintk(KERN_INFO "ISP1301 Version ID : 0x%04x\n",\r\ni2c_smbus_read_word_data(isp1301_i2c_client, 0x14));\r\n}\r\nstatic void isp1301_configure(void)\r\n{\r\nisp1301_configure_lpc32xx();\r\n}\r\nstatic inline void isp1301_vbus_on(void)\r\n{\r\ni2c_smbus_write_byte_data(isp1301_i2c_client, ISP1301_I2C_OTG_CONTROL_1,\r\nOTG1_VBUS_DRV);\r\n}\r\nstatic inline void isp1301_vbus_off(void)\r\n{\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\nISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR,\r\nOTG1_VBUS_DRV);\r\n}\r\nstatic void nxp_start_hc(void)\r\n{\r\nunsigned long tmp = __raw_readl(USB_OTG_STAT_CONTROL) | HOST_EN;\r\n__raw_writel(tmp, USB_OTG_STAT_CONTROL);\r\nisp1301_vbus_on();\r\n}\r\nstatic void nxp_stop_hc(void)\r\n{\r\nunsigned long tmp;\r\nisp1301_vbus_off();\r\ntmp = __raw_readl(USB_OTG_STAT_CONTROL) & ~HOST_EN;\r\n__raw_writel(tmp, USB_OTG_STAT_CONTROL);\r\n}\r\nstatic int ohci_nxp_start(struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nint ret;\r\nif ((ret = ohci_init(ohci)) < 0)\r\nreturn ret;\r\nif ((ret = ohci_run(ohci)) < 0) {\r\ndev_err(hcd->self.controller, "can't start\n");\r\nohci_stop(hcd);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usb_hcd_nxp_probe(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = 0;\r\nstruct ohci_hcd *ohci;\r\nconst struct hc_driver *driver = &ohci_nxp_hc_driver;\r\nstruct resource *res;\r\nint ret = 0, irq;\r\nstruct device_node *isp1301_node;\r\nif (pdev->dev.of_node) {\r\nisp1301_node = of_parse_phandle(pdev->dev.of_node,\r\n"transceiver", 0);\r\n} else {\r\nisp1301_node = NULL;\r\n}\r\nisp1301_i2c_client = isp1301_get_client(isp1301_node);\r\nif (!isp1301_i2c_client) {\r\nreturn -EPROBE_DEFER;\r\n}\r\npdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);\r\npdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;\r\ndev_dbg(&pdev->dev, "%s: " DRIVER_DESC " (nxp)\n", hcd_name);\r\nif (usb_disabled()) {\r\ndev_err(&pdev->dev, "USB is disabled\n");\r\nret = -ENODEV;\r\ngoto fail_disable;\r\n}\r\n__raw_writel(USB_SLAVE_HCLK_EN | PAD_CONTROL_LAST_DRIVEN, USB_CTRL);\r\nusb_pll_clk = clk_get(&pdev->dev, "ck_pll5");\r\nif (IS_ERR(usb_pll_clk)) {\r\ndev_err(&pdev->dev, "failed to acquire USB PLL\n");\r\nret = PTR_ERR(usb_pll_clk);\r\ngoto fail_pll;\r\n}\r\nret = clk_enable(usb_pll_clk);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to start USB PLL\n");\r\ngoto fail_pllen;\r\n}\r\nret = clk_set_rate(usb_pll_clk, 48000);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to set USB clock rate\n");\r\ngoto fail_rate;\r\n}\r\nusb_dev_clk = clk_get(&pdev->dev, "ck_usbd");\r\nif (IS_ERR(usb_dev_clk)) {\r\ndev_err(&pdev->dev, "failed to acquire USB DEV Clock\n");\r\nret = PTR_ERR(usb_dev_clk);\r\ngoto fail_dev;\r\n}\r\nret = clk_enable(usb_dev_clk);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to start USB DEV Clock\n");\r\ngoto fail_deven;\r\n}\r\nusb_otg_clk = clk_get(&pdev->dev, "ck_usb_otg");\r\nif (IS_ERR(usb_otg_clk)) {\r\ndev_err(&pdev->dev, "failed to acquire USB DEV Clock\n");\r\nret = PTR_ERR(usb_otg_clk);\r\ngoto fail_otg;\r\n}\r\n__raw_writel(__raw_readl(USB_CTRL) | USB_HOST_NEED_CLK_EN, USB_CTRL);\r\nret = clk_enable(usb_otg_clk);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to start USB DEV Clock\n");\r\ngoto fail_otgen;\r\n}\r\nisp1301_configure();\r\nhcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));\r\nif (!hcd) {\r\ndev_err(&pdev->dev, "Failed to allocate HC buffer\n");\r\nret = -ENOMEM;\r\ngoto fail_hcd;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhcd->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(hcd->regs)) {\r\nret = PTR_ERR(hcd->regs);\r\ngoto fail_resource;\r\n}\r\nhcd->rsrc_start = res->start;\r\nhcd->rsrc_len = resource_size(res);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nret = -ENXIO;\r\ngoto fail_resource;\r\n}\r\nnxp_start_hc();\r\nplatform_set_drvdata(pdev, hcd);\r\nohci = hcd_to_ohci(hcd);\r\nohci_hcd_init(ohci);\r\ndev_info(&pdev->dev, "at 0x%p, irq %d\n", hcd->regs, hcd->irq);\r\nret = usb_add_hcd(hcd, irq, 0);\r\nif (ret == 0)\r\nreturn ret;\r\nnxp_stop_hc();\r\nfail_resource:\r\nusb_put_hcd(hcd);\r\nfail_hcd:\r\nclk_disable(usb_otg_clk);\r\nfail_otgen:\r\nclk_put(usb_otg_clk);\r\nfail_otg:\r\nclk_disable(usb_dev_clk);\r\nfail_deven:\r\nclk_put(usb_dev_clk);\r\nfail_dev:\r\nfail_rate:\r\nclk_disable(usb_pll_clk);\r\nfail_pllen:\r\nclk_put(usb_pll_clk);\r\nfail_pll:\r\nfail_disable:\r\nisp1301_i2c_client = NULL;\r\nreturn ret;\r\n}\r\nstatic int usb_hcd_nxp_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nusb_remove_hcd(hcd);\r\nnxp_stop_hc();\r\nusb_put_hcd(hcd);\r\nclk_disable(usb_pll_clk);\r\nclk_put(usb_pll_clk);\r\nclk_disable(usb_dev_clk);\r\nclk_put(usb_dev_clk);\r\ni2c_unregister_device(isp1301_i2c_client);\r\nisp1301_i2c_client = NULL;\r\nreturn 0;\r\n}
