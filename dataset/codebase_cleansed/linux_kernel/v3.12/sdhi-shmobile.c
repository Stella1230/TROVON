static inline u16 sd_ctrl_read16(void __iomem *base, int addr)\r\n{\r\nreturn __raw_readw(base + addr);\r\n}\r\nstatic inline u32 sd_ctrl_read32(void __iomem *base, int addr)\r\n{\r\nreturn __raw_readw(base + addr) |\r\n__raw_readw(base + addr + 2) << 16;\r\n}\r\nstatic inline void sd_ctrl_write16(void __iomem *base, int addr, u16 val)\r\n{\r\n__raw_writew(val, base + addr);\r\n}\r\nstatic inline void sd_ctrl_write32(void __iomem *base, int addr, u32 val)\r\n{\r\n__raw_writew(val, base + addr);\r\n__raw_writew(val >> 16, base + addr + 2);\r\n}\r\nstatic int sdhi_intr(void __iomem *base)\r\n{\r\nunsigned long state = sd_ctrl_read32(base, CTL_STATUS);\r\nif (state & ALL_ERROR) {\r\nsd_ctrl_write32(base, CTL_STATUS, ~ALL_ERROR);\r\nsd_ctrl_write32(base, CTL_IRQ_MASK,\r\nALL_ERROR |\r\nsd_ctrl_read32(base, CTL_IRQ_MASK));\r\nreturn -EINVAL;\r\n}\r\nif (state & TMIO_STAT_CMDRESPEND) {\r\nsd_ctrl_write32(base, CTL_STATUS, ~TMIO_STAT_CMDRESPEND);\r\nsd_ctrl_write32(base, CTL_IRQ_MASK,\r\nTMIO_STAT_CMDRESPEND |\r\nsd_ctrl_read32(base, CTL_IRQ_MASK));\r\nreturn 0;\r\n}\r\nif (state & TMIO_STAT_RXRDY) {\r\nsd_ctrl_write32(base, CTL_STATUS, ~TMIO_STAT_RXRDY);\r\nsd_ctrl_write32(base, CTL_IRQ_MASK,\r\nTMIO_STAT_RXRDY | TMIO_STAT_TXUNDERRUN |\r\nsd_ctrl_read32(base, CTL_IRQ_MASK));\r\nreturn 0;\r\n}\r\nif (state & TMIO_STAT_DATAEND) {\r\nsd_ctrl_write32(base, CTL_STATUS, ~TMIO_STAT_DATAEND);\r\nsd_ctrl_write32(base, CTL_IRQ_MASK,\r\nTMIO_STAT_DATAEND |\r\nsd_ctrl_read32(base, CTL_IRQ_MASK));\r\nreturn 0;\r\n}\r\nreturn -EAGAIN;\r\n}\r\nstatic int sdhi_boot_wait_resp_end(void __iomem *base)\r\n{\r\nint err = -EAGAIN, timeout = 10000000;\r\nwhile (timeout--) {\r\nerr = sdhi_intr(base);\r\nif (err != -EAGAIN)\r\nbreak;\r\nudelay(1);\r\n}\r\nreturn err;\r\n}\r\nstatic void sdhi_boot_mmc_clk_stop(void __iomem *base)\r\n{\r\nsd_ctrl_write16(base, CTL_CLK_AND_WAIT_CTL, 0x0000);\r\nmsleep(10);\r\nsd_ctrl_write16(base, CTL_SD_CARD_CLK_CTL, ~CLK_MMC_ENABLE &\r\nsd_ctrl_read16(base, CTL_SD_CARD_CLK_CTL));\r\nmsleep(10);\r\n}\r\nstatic void sdhi_boot_mmc_clk_start(void __iomem *base)\r\n{\r\nsd_ctrl_write16(base, CTL_SD_CARD_CLK_CTL, CLK_MMC_ENABLE |\r\nsd_ctrl_read16(base, CTL_SD_CARD_CLK_CTL));\r\nmsleep(10);\r\nsd_ctrl_write16(base, CTL_CLK_AND_WAIT_CTL, CLK_MMC_ENABLE);\r\nmsleep(10);\r\n}\r\nstatic void sdhi_boot_reset(void __iomem *base)\r\n{\r\nsd_ctrl_write16(base, CTL_RESET_SD, 0x0000);\r\nmsleep(10);\r\nsd_ctrl_write16(base, CTL_RESET_SD, 0x0001);\r\nmsleep(10);\r\n}\r\nstatic int sdhi_boot_mmc_set_ios(void __iomem *base, struct mmc_ios *ios)\r\n{\r\nif (sd_ctrl_read32(base, CTL_STATUS) & TMIO_STAT_CMD_BUSY)\r\nreturn -EBUSY;\r\nif (ios->clock)\r\nsd_ctrl_write16(base, CTL_SD_CARD_CLK_CTL,\r\nios->clock | CLK_MMC_ENABLE);\r\nswitch (ios->power_mode) {\r\ncase MMC_POWER_OFF:\r\nsdhi_boot_mmc_clk_stop(base);\r\nbreak;\r\ncase MMC_POWER_ON:\r\nbreak;\r\ncase MMC_POWER_UP:\r\nsdhi_boot_mmc_clk_start(base);\r\nbreak;\r\n}\r\nswitch (ios->bus_width) {\r\ncase MMC_BUS_WIDTH_1:\r\nsd_ctrl_write16(base, CTL_SD_MEM_CARD_OPT, 0x80e0);\r\nbreak;\r\ncase MMC_BUS_WIDTH_4:\r\nsd_ctrl_write16(base, CTL_SD_MEM_CARD_OPT, 0x00e0);\r\nbreak;\r\n}\r\nudelay(140);\r\nreturn 0;\r\n}\r\nstatic int sdhi_boot_request(void __iomem *base, struct mmc_command *cmd)\r\n{\r\nint err, c = cmd->opcode;\r\nswitch (mmc_resp_type(cmd)) {\r\ncase MMC_RSP_NONE: c |= RESP_NONE; break;\r\ncase MMC_RSP_R1: c |= RESP_R1; break;\r\ncase MMC_RSP_R1B: c |= RESP_R1B; break;\r\ncase MMC_RSP_R2: c |= RESP_R2; break;\r\ncase MMC_RSP_R3: c |= RESP_R3; break;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsd_ctrl_write32(base, CTL_STATUS, ~TMIO_STAT_CMDRESPEND);\r\nsd_ctrl_write32(base, CTL_IRQ_MASK, TMIO_STAT_CMDRESPEND |\r\nsd_ctrl_read32(base, CTL_IRQ_MASK));\r\nsd_ctrl_write32(base, CTL_ARG_REG, cmd->arg);\r\nsd_ctrl_write16(base, CTL_SD_CMD, c);\r\nsd_ctrl_write32(base, CTL_IRQ_MASK,\r\n~(TMIO_STAT_CMDRESPEND | ALL_ERROR) &\r\nsd_ctrl_read32(base, CTL_IRQ_MASK));\r\nerr = sdhi_boot_wait_resp_end(base);\r\nif (err)\r\nreturn err;\r\ncmd->resp[0] = sd_ctrl_read32(base, CTL_RESPONSE);\r\nreturn 0;\r\n}\r\nstatic int sdhi_boot_do_read_single(void __iomem *base, int high_capacity,\r\nunsigned long block, unsigned short *buf)\r\n{\r\nint err, i;\r\n{\r\nstruct mmc_command cmd;\r\ncmd.opcode = MMC_READ_SINGLE_BLOCK | \\r\nTRANSFER_READ | DATA_PRESENT;\r\nif (high_capacity)\r\ncmd.arg = block;\r\nelse\r\ncmd.arg = block * TMIO_BBS;\r\ncmd.flags = MMC_RSP_R1;\r\nerr = sdhi_boot_request(base, &cmd);\r\nif (err)\r\nreturn err;\r\n}\r\nsd_ctrl_write32(base, CTL_IRQ_MASK,\r\n~(TMIO_STAT_DATAEND | TMIO_STAT_RXRDY |\r\nTMIO_STAT_TXUNDERRUN) &\r\nsd_ctrl_read32(base, CTL_IRQ_MASK));\r\nerr = sdhi_boot_wait_resp_end(base);\r\nif (err)\r\nreturn err;\r\nsd_ctrl_write16(base, CTL_SD_XFER_LEN, TMIO_BBS);\r\nfor (i = 0; i < TMIO_BBS / sizeof(*buf); i++)\r\n*buf++ = sd_ctrl_read16(base, RESP_CMD12);\r\nerr = sdhi_boot_wait_resp_end(base);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint sdhi_boot_do_read(void __iomem *base, int high_capacity,\r\nunsigned long offset, unsigned short count,\r\nunsigned short *buf)\r\n{\r\nunsigned long i;\r\nint err = 0;\r\nfor (i = 0; i < count; i++) {\r\nerr = sdhi_boot_do_read_single(base, high_capacity, offset + i,\r\nbuf + (i * TMIO_BBS /\r\nsizeof(*buf)));\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint sdhi_boot_init(void __iomem *base)\r\n{\r\nbool sd_v2 = false, sd_v1_0 = false;\r\nunsigned short cid;\r\nint err, high_capacity = 0;\r\nsdhi_boot_mmc_clk_stop(base);\r\nsdhi_boot_reset(base);\r\n{\r\nstruct mmc_ios ios;\r\nios.power_mode = MMC_POWER_ON;\r\nios.bus_width = MMC_BUS_WIDTH_1;\r\nios.clock = CLK_MMC_INIT;\r\nerr = sdhi_boot_mmc_set_ios(base, &ios);\r\nif (err)\r\nreturn err;\r\n}\r\n{\r\nstruct mmc_command cmd;\r\nmsleep(1);\r\ncmd.opcode = MMC_GO_IDLE_STATE;\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_NONE;\r\nerr = sdhi_boot_request(base, &cmd);\r\nif (err)\r\nreturn err;\r\nmsleep(2);\r\n}\r\n{\r\nstruct mmc_command cmd;\r\ncmd.opcode = SD_SEND_IF_COND;\r\ncmd.arg = (VOLTAGES != 0) << 8 | 0xaa;\r\ncmd.flags = MMC_RSP_R1;\r\nerr = sdhi_boot_request(base, &cmd);\r\nif ((cmd.resp[0] & 0xff) == 0xaa)\r\nsd_v2 = true;\r\n}\r\n{\r\nint timeout = 1000;\r\nstruct mmc_command cmd;\r\ncmd.arg = 0;\r\ndo {\r\ncmd.opcode = MMC_APP_CMD;\r\ncmd.flags = MMC_RSP_R1;\r\ncmd.arg = 0;\r\nerr = sdhi_boot_request(base, &cmd);\r\nif (err)\r\nbreak;\r\ncmd.opcode = SD_APP_OP_COND;\r\ncmd.flags = MMC_RSP_R3;\r\ncmd.arg = (VOLTAGES & 0xff8000);\r\nif (sd_v2)\r\ncmd.arg |= OCR_HCS;\r\ncmd.arg |= OCR_FASTBOOT;\r\nerr = sdhi_boot_request(base, &cmd);\r\nif (err)\r\nbreak;\r\nmsleep(1);\r\n} while((!(cmd.resp[0] & OCR_BUSY)) && --timeout);\r\nif (!err && timeout) {\r\nif (!sd_v2)\r\nsd_v1_0 = true;\r\nhigh_capacity = (cmd.resp[0] & OCR_HCS) == OCR_HCS;\r\n}\r\n}\r\nif (!sd_v2 && !sd_v1_0) {\r\nint timeout = 1000;\r\nstruct mmc_command cmd;\r\ndo {\r\ncmd.opcode = MMC_SEND_OP_COND;\r\ncmd.arg = VOLTAGES | OCR_HCS;\r\ncmd.flags = MMC_RSP_R3;\r\nerr = sdhi_boot_request(base, &cmd);\r\nif (err)\r\nreturn err;\r\nmsleep(1);\r\n} while((!(cmd.resp[0] & OCR_BUSY)) && --timeout);\r\nif (!timeout)\r\nreturn -EAGAIN;\r\nhigh_capacity = (cmd.resp[0] & OCR_HCS) == OCR_HCS;\r\n}\r\n{\r\nstruct mmc_command cmd;\r\ncmd.opcode = MMC_ALL_SEND_CID;\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_R2;\r\nerr = sdhi_boot_request(base, &cmd);\r\nif (err)\r\nreturn err;\r\n}\r\n{\r\nstruct mmc_command cmd;\r\ncmd.opcode = MMC_SET_RELATIVE_ADDR;\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_R1;\r\nerr = sdhi_boot_request(base, &cmd);\r\nif (err)\r\nreturn err;\r\ncid = cmd.resp[0] >> 16;\r\n}\r\n{\r\nstruct mmc_command cmd;\r\ncmd.opcode = MMC_SEND_CSD;\r\ncmd.arg = cid << 16;\r\ncmd.flags = MMC_RSP_R2;\r\nerr = sdhi_boot_request(base, &cmd);\r\nif (err)\r\nreturn err;\r\n}\r\n{\r\nstruct mmc_command cmd;\r\ncmd.opcode = MMC_SELECT_CARD;\r\ncmd.arg = cid << 16;\r\ncmd.flags = MMC_RSP_R1;\r\nerr = sdhi_boot_request(base, &cmd);\r\nif (err)\r\nreturn err;\r\n}\r\n{\r\nstruct mmc_command cmd;\r\ncmd.opcode = MMC_SET_BLOCKLEN;\r\ncmd.arg = TMIO_BBS;\r\ncmd.flags = MMC_RSP_R1;\r\nerr = sdhi_boot_request(base, &cmd);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn high_capacity;\r\n}
