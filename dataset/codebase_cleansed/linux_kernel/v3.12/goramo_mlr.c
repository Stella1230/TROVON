static void set_scl(u8 value)\r\n{\r\ngpio_line_set(GPIO_SCL, !!value);\r\nudelay(3);\r\n}\r\nstatic void set_sda(u8 value)\r\n{\r\ngpio_line_set(GPIO_SDA, !!value);\r\nudelay(3);\r\n}\r\nstatic void set_str(u8 value)\r\n{\r\ngpio_line_set(GPIO_STR, !!value);\r\nudelay(3);\r\n}\r\nstatic inline void set_control(int line, int value)\r\n{\r\nif (value)\r\ncontrol_value |= (1 << line);\r\nelse\r\ncontrol_value &= ~(1 << line);\r\n}\r\nstatic void output_control(void)\r\n{\r\nint i;\r\ngpio_line_config(GPIO_SCL, IXP4XX_GPIO_OUT);\r\ngpio_line_config(GPIO_SDA, IXP4XX_GPIO_OUT);\r\nfor (i = 0; i < 8; i++) {\r\nset_scl(0);\r\nset_sda(control_value & (0x80 >> i));\r\nset_scl(1);\r\n}\r\nset_str(1);\r\nset_str(0);\r\nset_scl(0);\r\nset_sda(1);\r\nset_scl(1);\r\n}\r\nstatic int hss_set_clock(int port, unsigned int clock_type)\r\n{\r\nint ctrl_int = port ? CONTROL_HSS1_CLK_INT : CONTROL_HSS0_CLK_INT;\r\nswitch (clock_type) {\r\ncase CLOCK_DEFAULT:\r\ncase CLOCK_EXT:\r\nset_control(ctrl_int, 0);\r\noutput_control();\r\nreturn CLOCK_EXT;\r\ncase CLOCK_INT:\r\nset_control(ctrl_int, 1);\r\noutput_control();\r\nreturn CLOCK_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic irqreturn_t hss_dcd_irq(int irq, void *pdev)\r\n{\r\nint i, port = (irq == IXP4XX_GPIO_IRQ(GPIO_HSS1_DCD_N));\r\ngpio_line_get(port ? GPIO_HSS1_DCD_N : GPIO_HSS0_DCD_N, &i);\r\nset_carrier_cb_tab[port](pdev, !i);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int hss_open(int port, void *pdev,\r\nvoid (*set_carrier_cb)(void *pdev, int carrier))\r\n{\r\nint i, irq;\r\nif (!port)\r\nirq = IXP4XX_GPIO_IRQ(GPIO_HSS0_DCD_N);\r\nelse\r\nirq = IXP4XX_GPIO_IRQ(GPIO_HSS1_DCD_N);\r\ngpio_line_get(port ? GPIO_HSS1_DCD_N : GPIO_HSS0_DCD_N, &i);\r\nset_carrier_cb(pdev, !i);\r\nset_carrier_cb_tab[!!port] = set_carrier_cb;\r\nif ((i = request_irq(irq, hss_dcd_irq, 0, "IXP4xx HSS", pdev)) != 0) {\r\nprintk(KERN_ERR "ixp4xx_hss: failed to request IRQ%i (%i)\n",\r\nirq, i);\r\nreturn i;\r\n}\r\nset_control(port ? CONTROL_HSS1_DTR_N : CONTROL_HSS0_DTR_N, 0);\r\noutput_control();\r\ngpio_line_set(port ? GPIO_HSS1_RTS_N : GPIO_HSS0_RTS_N, 0);\r\nreturn 0;\r\n}\r\nstatic void hss_close(int port, void *pdev)\r\n{\r\nfree_irq(port ? IXP4XX_GPIO_IRQ(GPIO_HSS1_DCD_N) :\r\nIXP4XX_GPIO_IRQ(GPIO_HSS0_DCD_N), pdev);\r\nset_carrier_cb_tab[!!port] = NULL;\r\nset_control(port ? CONTROL_HSS1_DTR_N : CONTROL_HSS0_DTR_N, 1);\r\noutput_control();\r\ngpio_line_set(port ? GPIO_HSS1_RTS_N : GPIO_HSS0_RTS_N, 1);\r\n}\r\nstatic inline u8 __init flash_readb(u8 __iomem *flash, u32 addr)\r\n{\r\n#ifdef __ARMEB__\r\nreturn __raw_readb(flash + addr);\r\n#else\r\nreturn __raw_readb(flash + (addr ^ 3));\r\n#endif\r\n}\r\nstatic inline u16 __init flash_readw(u8 __iomem *flash, u32 addr)\r\n{\r\n#ifdef __ARMEB__\r\nreturn __raw_readw(flash + addr);\r\n#else\r\nreturn __raw_readw(flash + (addr ^ 2));\r\n#endif\r\n}\r\nstatic void __init gmlr_init(void)\r\n{\r\nu8 __iomem *flash;\r\nint i, devices = 1;\r\nixp4xx_sys_init();\r\nif ((flash = ioremap(IXP4XX_EXP_BUS_BASE_PHYS, 0x80)) == NULL)\r\nprintk(KERN_ERR "goramo-mlr: unable to access system"\r\n" configuration data\n");\r\nelse {\r\nsystem_rev = __raw_readl(flash + CFG_REV);\r\nhw_bits = __raw_readl(flash + CFG_HW_BITS);\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\neth_plat[0].hwaddr[i] =\r\nflash_readb(flash, CFG_ETH0_ADDRESS + i);\r\neth_plat[1].hwaddr[i] =\r\nflash_readb(flash, CFG_ETH1_ADDRESS + i);\r\n}\r\n__raw_writew(FLASH_CMD_READ_ID, flash);\r\nsystem_serial_high = flash_readw(flash, FLASH_SER_OFF);\r\nsystem_serial_high <<= 16;\r\nsystem_serial_high |= flash_readw(flash, FLASH_SER_OFF + 2);\r\nsystem_serial_low = flash_readw(flash, FLASH_SER_OFF + 4);\r\nsystem_serial_low <<= 16;\r\nsystem_serial_low |= flash_readw(flash, FLASH_SER_OFF + 6);\r\n__raw_writew(FLASH_CMD_READ_ARRAY, flash);\r\niounmap(flash);\r\n}\r\nswitch (hw_bits & (CFG_HW_HAS_UART0 | CFG_HW_HAS_UART1)) {\r\ncase CFG_HW_HAS_UART0:\r\nmemset(&uart_data[1], 0, sizeof(uart_data[1]));\r\ndevice_uarts.num_resources = 1;\r\nbreak;\r\ncase CFG_HW_HAS_UART1:\r\ndevice_uarts.dev.platform_data = &uart_data[1];\r\ndevice_uarts.resource = &uart_resources[1];\r\ndevice_uarts.num_resources = 1;\r\nbreak;\r\n}\r\nif (hw_bits & (CFG_HW_HAS_UART0 | CFG_HW_HAS_UART1))\r\ndevice_tab[devices++] = &device_uarts;\r\nif (hw_bits & CFG_HW_HAS_ETH0)\r\ndevice_tab[devices++] = &device_eth_tab[0];\r\nif (hw_bits & CFG_HW_HAS_ETH1)\r\ndevice_tab[devices++] = &device_eth_tab[1];\r\nif (hw_bits & CFG_HW_HAS_HSS0)\r\ndevice_tab[devices++] = &device_hss_tab[0];\r\nif (hw_bits & CFG_HW_HAS_HSS1)\r\ndevice_tab[devices++] = &device_hss_tab[1];\r\nif (hw_bits & CFG_HW_HAS_EEPROM)\r\ndevice_tab[devices++] = &device_i2c;\r\ngpio_line_config(GPIO_SCL, IXP4XX_GPIO_OUT);\r\ngpio_line_config(GPIO_SDA, IXP4XX_GPIO_OUT);\r\ngpio_line_config(GPIO_STR, IXP4XX_GPIO_OUT);\r\ngpio_line_config(GPIO_HSS0_RTS_N, IXP4XX_GPIO_OUT);\r\ngpio_line_config(GPIO_HSS1_RTS_N, IXP4XX_GPIO_OUT);\r\ngpio_line_config(GPIO_HSS0_DCD_N, IXP4XX_GPIO_IN);\r\ngpio_line_config(GPIO_HSS1_DCD_N, IXP4XX_GPIO_IN);\r\nirq_set_irq_type(IXP4XX_GPIO_IRQ(GPIO_HSS0_DCD_N), IRQ_TYPE_EDGE_BOTH);\r\nirq_set_irq_type(IXP4XX_GPIO_IRQ(GPIO_HSS1_DCD_N), IRQ_TYPE_EDGE_BOTH);\r\nset_control(CONTROL_HSS0_DTR_N, 1);\r\nset_control(CONTROL_HSS1_DTR_N, 1);\r\nset_control(CONTROL_EEPROM_WC_N, 1);\r\nset_control(CONTROL_PCI_RESET_N, 1);\r\noutput_control();\r\nmsleep(1);\r\nflash_resource.start = IXP4XX_EXP_BUS_BASE(0);\r\nflash_resource.end = IXP4XX_EXP_BUS_BASE(0) + ixp4xx_exp_bus_size - 1;\r\nplatform_add_devices(device_tab, devices);\r\n}\r\nstatic void __init gmlr_pci_preinit(void)\r\n{\r\nirq_set_irq_type(IXP4XX_GPIO_IRQ(GPIO_IRQ_ETHA), IRQ_TYPE_LEVEL_LOW);\r\nirq_set_irq_type(IXP4XX_GPIO_IRQ(GPIO_IRQ_ETHB), IRQ_TYPE_LEVEL_LOW);\r\nirq_set_irq_type(IXP4XX_GPIO_IRQ(GPIO_IRQ_NEC), IRQ_TYPE_LEVEL_LOW);\r\nirq_set_irq_type(IXP4XX_GPIO_IRQ(GPIO_IRQ_MPCI), IRQ_TYPE_LEVEL_LOW);\r\nixp4xx_pci_preinit();\r\n}\r\nstatic void __init gmlr_pci_postinit(void)\r\n{\r\nif ((hw_bits & CFG_HW_USB_PORTS) >= 2 &&\r\n(hw_bits & CFG_HW_USB_PORTS) < 5) {\r\nu32 value, addr = BIT(32 - SLOT_NEC) | 0xE0;\r\nif (!ixp4xx_pci_read(addr, NP_CMD_CONFIGREAD, &value)) {\r\nvalue &= ~7;\r\nvalue |= (hw_bits & CFG_HW_USB_PORTS);\r\nixp4xx_pci_write(addr, NP_CMD_CONFIGWRITE, value);\r\n}\r\n}\r\n}\r\nstatic int __init gmlr_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nswitch(slot) {\r\ncase SLOT_ETHA: return IXP4XX_GPIO_IRQ(GPIO_IRQ_ETHA);\r\ncase SLOT_ETHB: return IXP4XX_GPIO_IRQ(GPIO_IRQ_ETHB);\r\ncase SLOT_NEC: return IXP4XX_GPIO_IRQ(GPIO_IRQ_NEC);\r\ndefault: return IXP4XX_GPIO_IRQ(GPIO_IRQ_MPCI);\r\n}\r\n}\r\nstatic int __init gmlr_pci_init(void)\r\n{\r\nif (machine_is_goramo_mlr() &&\r\n(hw_bits & (CFG_HW_USB_PORTS | CFG_HW_HAS_PCI_SLOT)))\r\npci_common_init(&gmlr_hw_pci);\r\nreturn 0;\r\n}
