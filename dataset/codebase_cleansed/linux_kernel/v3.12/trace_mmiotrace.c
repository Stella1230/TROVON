static void mmio_reset_data(struct trace_array *tr)\r\n{\r\noverrun_detected = false;\r\nprev_overruns = 0;\r\ntracing_reset_online_cpus(&tr->trace_buffer);\r\n}\r\nstatic int mmio_trace_init(struct trace_array *tr)\r\n{\r\npr_debug("in %s\n", __func__);\r\nmmio_trace_array = tr;\r\nmmio_reset_data(tr);\r\nenable_mmiotrace();\r\nreturn 0;\r\n}\r\nstatic void mmio_trace_reset(struct trace_array *tr)\r\n{\r\npr_debug("in %s\n", __func__);\r\ndisable_mmiotrace();\r\nmmio_reset_data(tr);\r\nmmio_trace_array = NULL;\r\n}\r\nstatic void mmio_trace_start(struct trace_array *tr)\r\n{\r\npr_debug("in %s\n", __func__);\r\nmmio_reset_data(tr);\r\n}\r\nstatic int mmio_print_pcidev(struct trace_seq *s, const struct pci_dev *dev)\r\n{\r\nint ret = 0;\r\nint i;\r\nresource_size_t start, end;\r\nconst struct pci_driver *drv = pci_dev_driver(dev);\r\nret += trace_seq_printf(s, "PCIDEV %02x%02x %04x%04x %x",\r\ndev->bus->number, dev->devfn,\r\ndev->vendor, dev->device, dev->irq);\r\nfor (i = 0; i < 7; i++) {\r\npci_resource_to_user(dev, i, &dev->resource[i], &start, &end);\r\nret += trace_seq_printf(s, " %llx",\r\n(unsigned long long)(start |\r\n(dev->resource[i].flags & PCI_REGION_FLAG_MASK)));\r\n}\r\nfor (i = 0; i < 7; i++) {\r\npci_resource_to_user(dev, i, &dev->resource[i], &start, &end);\r\nret += trace_seq_printf(s, " %llx",\r\ndev->resource[i].start < dev->resource[i].end ?\r\n(unsigned long long)(end - start) + 1 : 0);\r\n}\r\nif (drv)\r\nret += trace_seq_printf(s, " %s\n", drv->name);\r\nelse\r\nret += trace_seq_puts(s, " \n");\r\nreturn ret;\r\n}\r\nstatic void destroy_header_iter(struct header_iter *hiter)\r\n{\r\nif (!hiter)\r\nreturn;\r\npci_dev_put(hiter->dev);\r\nkfree(hiter);\r\n}\r\nstatic void mmio_pipe_open(struct trace_iterator *iter)\r\n{\r\nstruct header_iter *hiter;\r\nstruct trace_seq *s = &iter->seq;\r\ntrace_seq_puts(s, "VERSION 20070824\n");\r\nhiter = kzalloc(sizeof(*hiter), GFP_KERNEL);\r\nif (!hiter)\r\nreturn;\r\nhiter->dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);\r\niter->private = hiter;\r\n}\r\nstatic void mmio_close(struct trace_iterator *iter)\r\n{\r\nstruct header_iter *hiter = iter->private;\r\ndestroy_header_iter(hiter);\r\niter->private = NULL;\r\n}\r\nstatic unsigned long count_overruns(struct trace_iterator *iter)\r\n{\r\nunsigned long cnt = atomic_xchg(&dropped_count, 0);\r\nunsigned long over = ring_buffer_overruns(iter->trace_buffer->buffer);\r\nif (over > prev_overruns)\r\ncnt += over - prev_overruns;\r\nprev_overruns = over;\r\nreturn cnt;\r\n}\r\nstatic ssize_t mmio_read(struct trace_iterator *iter, struct file *filp,\r\nchar __user *ubuf, size_t cnt, loff_t *ppos)\r\n{\r\nssize_t ret;\r\nstruct header_iter *hiter = iter->private;\r\nstruct trace_seq *s = &iter->seq;\r\nunsigned long n;\r\nn = count_overruns(iter);\r\nif (n) {\r\ntrace_seq_printf(s, "MARK 0.000000 Lost %lu events.\n", n);\r\nif (!overrun_detected)\r\npr_warning("mmiotrace has lost events.\n");\r\noverrun_detected = true;\r\ngoto print_out;\r\n}\r\nif (!hiter)\r\nreturn 0;\r\nmmio_print_pcidev(s, hiter->dev);\r\nhiter->dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, hiter->dev);\r\nif (!hiter->dev) {\r\ndestroy_header_iter(hiter);\r\niter->private = NULL;\r\n}\r\nprint_out:\r\nret = trace_seq_to_user(s, ubuf, cnt);\r\nreturn (ret == -EBUSY) ? 0 : ret;\r\n}\r\nstatic enum print_line_t mmio_print_rw(struct trace_iterator *iter)\r\n{\r\nstruct trace_entry *entry = iter->ent;\r\nstruct trace_mmiotrace_rw *field;\r\nstruct mmiotrace_rw *rw;\r\nstruct trace_seq *s = &iter->seq;\r\nunsigned long long t = ns2usecs(iter->ts);\r\nunsigned long usec_rem = do_div(t, USEC_PER_SEC);\r\nunsigned secs = (unsigned long)t;\r\nint ret = 1;\r\ntrace_assign_type(field, entry);\r\nrw = &field->rw;\r\nswitch (rw->opcode) {\r\ncase MMIO_READ:\r\nret = trace_seq_printf(s,\r\n"R %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\n",\r\nrw->width, secs, usec_rem, rw->map_id,\r\n(unsigned long long)rw->phys,\r\nrw->value, rw->pc, 0);\r\nbreak;\r\ncase MMIO_WRITE:\r\nret = trace_seq_printf(s,\r\n"W %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\n",\r\nrw->width, secs, usec_rem, rw->map_id,\r\n(unsigned long long)rw->phys,\r\nrw->value, rw->pc, 0);\r\nbreak;\r\ncase MMIO_UNKNOWN_OP:\r\nret = trace_seq_printf(s,\r\n"UNKNOWN %u.%06lu %d 0x%llx %02lx,%02lx,"\r\n"%02lx 0x%lx %d\n",\r\nsecs, usec_rem, rw->map_id,\r\n(unsigned long long)rw->phys,\r\n(rw->value >> 16) & 0xff, (rw->value >> 8) & 0xff,\r\n(rw->value >> 0) & 0xff, rw->pc, 0);\r\nbreak;\r\ndefault:\r\nret = trace_seq_puts(s, "rw what?\n");\r\nbreak;\r\n}\r\nif (ret)\r\nreturn TRACE_TYPE_HANDLED;\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\n}\r\nstatic enum print_line_t mmio_print_map(struct trace_iterator *iter)\r\n{\r\nstruct trace_entry *entry = iter->ent;\r\nstruct trace_mmiotrace_map *field;\r\nstruct mmiotrace_map *m;\r\nstruct trace_seq *s = &iter->seq;\r\nunsigned long long t = ns2usecs(iter->ts);\r\nunsigned long usec_rem = do_div(t, USEC_PER_SEC);\r\nunsigned secs = (unsigned long)t;\r\nint ret;\r\ntrace_assign_type(field, entry);\r\nm = &field->map;\r\nswitch (m->opcode) {\r\ncase MMIO_PROBE:\r\nret = trace_seq_printf(s,\r\n"MAP %u.%06lu %d 0x%llx 0x%lx 0x%lx 0x%lx %d\n",\r\nsecs, usec_rem, m->map_id,\r\n(unsigned long long)m->phys, m->virt, m->len,\r\n0UL, 0);\r\nbreak;\r\ncase MMIO_UNPROBE:\r\nret = trace_seq_printf(s,\r\n"UNMAP %u.%06lu %d 0x%lx %d\n",\r\nsecs, usec_rem, m->map_id, 0UL, 0);\r\nbreak;\r\ndefault:\r\nret = trace_seq_puts(s, "map what?\n");\r\nbreak;\r\n}\r\nif (ret)\r\nreturn TRACE_TYPE_HANDLED;\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\n}\r\nstatic enum print_line_t mmio_print_mark(struct trace_iterator *iter)\r\n{\r\nstruct trace_entry *entry = iter->ent;\r\nstruct print_entry *print = (struct print_entry *)entry;\r\nconst char *msg = print->buf;\r\nstruct trace_seq *s = &iter->seq;\r\nunsigned long long t = ns2usecs(iter->ts);\r\nunsigned long usec_rem = do_div(t, USEC_PER_SEC);\r\nunsigned secs = (unsigned long)t;\r\nint ret;\r\nret = trace_seq_printf(s, "MARK %u.%06lu %s", secs, usec_rem, msg);\r\nif (!ret)\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\nreturn TRACE_TYPE_HANDLED;\r\n}\r\nstatic enum print_line_t mmio_print_line(struct trace_iterator *iter)\r\n{\r\nswitch (iter->ent->type) {\r\ncase TRACE_MMIO_RW:\r\nreturn mmio_print_rw(iter);\r\ncase TRACE_MMIO_MAP:\r\nreturn mmio_print_map(iter);\r\ncase TRACE_PRINT:\r\nreturn mmio_print_mark(iter);\r\ndefault:\r\nreturn TRACE_TYPE_HANDLED;\r\n}\r\n}\r\n__init static int init_mmio_trace(void)\r\n{\r\nreturn register_tracer(&mmio_tracer);\r\n}\r\nstatic void __trace_mmiotrace_rw(struct trace_array *tr,\r\nstruct trace_array_cpu *data,\r\nstruct mmiotrace_rw *rw)\r\n{\r\nstruct ftrace_event_call *call = &event_mmiotrace_rw;\r\nstruct ring_buffer *buffer = tr->trace_buffer.buffer;\r\nstruct ring_buffer_event *event;\r\nstruct trace_mmiotrace_rw *entry;\r\nint pc = preempt_count();\r\nevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_RW,\r\nsizeof(*entry), 0, pc);\r\nif (!event) {\r\natomic_inc(&dropped_count);\r\nreturn;\r\n}\r\nentry = ring_buffer_event_data(event);\r\nentry->rw = *rw;\r\nif (!filter_check_discard(call, entry, buffer, event))\r\ntrace_buffer_unlock_commit(buffer, event, 0, pc);\r\n}\r\nvoid mmio_trace_rw(struct mmiotrace_rw *rw)\r\n{\r\nstruct trace_array *tr = mmio_trace_array;\r\nstruct trace_array_cpu *data = per_cpu_ptr(tr->trace_buffer.data, smp_processor_id());\r\n__trace_mmiotrace_rw(tr, data, rw);\r\n}\r\nstatic void __trace_mmiotrace_map(struct trace_array *tr,\r\nstruct trace_array_cpu *data,\r\nstruct mmiotrace_map *map)\r\n{\r\nstruct ftrace_event_call *call = &event_mmiotrace_map;\r\nstruct ring_buffer *buffer = tr->trace_buffer.buffer;\r\nstruct ring_buffer_event *event;\r\nstruct trace_mmiotrace_map *entry;\r\nint pc = preempt_count();\r\nevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_MAP,\r\nsizeof(*entry), 0, pc);\r\nif (!event) {\r\natomic_inc(&dropped_count);\r\nreturn;\r\n}\r\nentry = ring_buffer_event_data(event);\r\nentry->map = *map;\r\nif (!filter_check_discard(call, entry, buffer, event))\r\ntrace_buffer_unlock_commit(buffer, event, 0, pc);\r\n}\r\nvoid mmio_trace_mapping(struct mmiotrace_map *map)\r\n{\r\nstruct trace_array *tr = mmio_trace_array;\r\nstruct trace_array_cpu *data;\r\npreempt_disable();\r\ndata = per_cpu_ptr(tr->trace_buffer.data, smp_processor_id());\r\n__trace_mmiotrace_map(tr, data, map);\r\npreempt_enable();\r\n}\r\nint mmio_trace_printk(const char *fmt, va_list args)\r\n{\r\nreturn trace_vprintk(0, fmt, args);\r\n}
