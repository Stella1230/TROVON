static u32 rtc_read_lp_counter(void __iomem *ioaddr)\r\n{\r\nu64 read1, read2;\r\ndo {\r\nread1 = readl(ioaddr + SNVS_LPSRTCMR);\r\nread1 <<= 32;\r\nread1 |= readl(ioaddr + SNVS_LPSRTCLR);\r\nread2 = readl(ioaddr + SNVS_LPSRTCMR);\r\nread2 <<= 32;\r\nread2 |= readl(ioaddr + SNVS_LPSRTCLR);\r\n} while (read1 != read2);\r\nreturn (u32) (read1 >> CNTR_TO_SECS_SH);\r\n}\r\nstatic void rtc_write_sync_lp(void __iomem *ioaddr)\r\n{\r\nu32 count1, count2, count3;\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\ndo {\r\ncount1 = readl(ioaddr + SNVS_LPSRTCLR);\r\ncount2 = readl(ioaddr + SNVS_LPSRTCLR);\r\n} while (count1 != count2);\r\ndo {\r\ndo {\r\ncount2 = readl(ioaddr + SNVS_LPSRTCLR);\r\ncount3 = readl(ioaddr + SNVS_LPSRTCLR);\r\n} while (count2 != count3);\r\n} while (count3 == count1);\r\n}\r\n}\r\nstatic int snvs_rtc_enable(struct snvs_rtc_data *data, bool enable)\r\n{\r\nunsigned long flags;\r\nint timeout = 1000;\r\nu32 lpcr;\r\nspin_lock_irqsave(&data->lock, flags);\r\nlpcr = readl(data->ioaddr + SNVS_LPCR);\r\nif (enable)\r\nlpcr |= SNVS_LPCR_SRTC_ENV;\r\nelse\r\nlpcr &= ~SNVS_LPCR_SRTC_ENV;\r\nwritel(lpcr, data->ioaddr + SNVS_LPCR);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nwhile (--timeout) {\r\nlpcr = readl(data->ioaddr + SNVS_LPCR);\r\nif (enable) {\r\nif (lpcr & SNVS_LPCR_SRTC_ENV)\r\nbreak;\r\n} else {\r\nif (!(lpcr & SNVS_LPCR_SRTC_ENV))\r\nbreak;\r\n}\r\n}\r\nif (!timeout)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int snvs_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct snvs_rtc_data *data = dev_get_drvdata(dev);\r\nunsigned long time = rtc_read_lp_counter(data->ioaddr);\r\nrtc_time_to_tm(time, tm);\r\nreturn 0;\r\n}\r\nstatic int snvs_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct snvs_rtc_data *data = dev_get_drvdata(dev);\r\nunsigned long time;\r\nrtc_tm_to_time(tm, &time);\r\nsnvs_rtc_enable(data, false);\r\nwritel(time << CNTR_TO_SECS_SH, data->ioaddr + SNVS_LPSRTCLR);\r\nwritel(time >> (32 - CNTR_TO_SECS_SH), data->ioaddr + SNVS_LPSRTCMR);\r\nsnvs_rtc_enable(data, true);\r\nreturn 0;\r\n}\r\nstatic int snvs_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct snvs_rtc_data *data = dev_get_drvdata(dev);\r\nu32 lptar, lpsr;\r\nlptar = readl(data->ioaddr + SNVS_LPTAR);\r\nrtc_time_to_tm(lptar, &alrm->time);\r\nlpsr = readl(data->ioaddr + SNVS_LPSR);\r\nalrm->pending = (lpsr & SNVS_LPSR_LPTA) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int snvs_rtc_alarm_irq_enable(struct device *dev, unsigned int enable)\r\n{\r\nstruct snvs_rtc_data *data = dev_get_drvdata(dev);\r\nu32 lpcr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&data->lock, flags);\r\nlpcr = readl(data->ioaddr + SNVS_LPCR);\r\nif (enable)\r\nlpcr |= (SNVS_LPCR_LPTA_EN | SNVS_LPCR_LPWUI_EN);\r\nelse\r\nlpcr &= ~(SNVS_LPCR_LPTA_EN | SNVS_LPCR_LPWUI_EN);\r\nwritel(lpcr, data->ioaddr + SNVS_LPCR);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nrtc_write_sync_lp(data->ioaddr);\r\nreturn 0;\r\n}\r\nstatic int snvs_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct snvs_rtc_data *data = dev_get_drvdata(dev);\r\nstruct rtc_time *alrm_tm = &alrm->time;\r\nunsigned long time;\r\nunsigned long flags;\r\nu32 lpcr;\r\nrtc_tm_to_time(alrm_tm, &time);\r\nspin_lock_irqsave(&data->lock, flags);\r\nlpcr = readl(data->ioaddr + SNVS_LPCR);\r\nlpcr &= ~SNVS_LPCR_LPTA_EN;\r\nwritel(lpcr, data->ioaddr + SNVS_LPCR);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nwritel(time, data->ioaddr + SNVS_LPTAR);\r\nwritel(SNVS_LPSR_LPTA, data->ioaddr + SNVS_LPSR);\r\nreturn snvs_rtc_alarm_irq_enable(dev, alrm->enabled);\r\n}\r\nstatic irqreturn_t snvs_rtc_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct device *dev = dev_id;\r\nstruct snvs_rtc_data *data = dev_get_drvdata(dev);\r\nu32 lpsr;\r\nu32 events = 0;\r\nlpsr = readl(data->ioaddr + SNVS_LPSR);\r\nif (lpsr & SNVS_LPSR_LPTA) {\r\nevents |= (RTC_AF | RTC_IRQF);\r\nsnvs_rtc_alarm_irq_enable(dev, 0);\r\nrtc_update_irq(data->rtc, 1, events);\r\n}\r\nwritel(lpsr, data->ioaddr + SNVS_LPSR);\r\nreturn events ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int snvs_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct snvs_rtc_data *data;\r\nstruct resource *res;\r\nint ret;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndata->ioaddr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(data->ioaddr))\r\nreturn PTR_ERR(data->ioaddr);\r\ndata->irq = platform_get_irq(pdev, 0);\r\nif (data->irq < 0)\r\nreturn data->irq;\r\nplatform_set_drvdata(pdev, data);\r\nspin_lock_init(&data->lock);\r\nwritel(SNVS_LPPGDR_INIT, data->ioaddr + SNVS_LPPGDR);\r\nwritel(0xffffffff, data->ioaddr + SNVS_LPSR);\r\nsnvs_rtc_enable(data, true);\r\ndevice_init_wakeup(&pdev->dev, true);\r\nret = devm_request_irq(&pdev->dev, data->irq, snvs_rtc_irq_handler,\r\nIRQF_SHARED, "rtc alarm", &pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request irq %d: %d\n",\r\ndata->irq, ret);\r\nreturn ret;\r\n}\r\ndata->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,\r\n&snvs_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(data->rtc)) {\r\nret = PTR_ERR(data->rtc);\r\ndev_err(&pdev->dev, "failed to register rtc: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snvs_rtc_suspend(struct device *dev)\r\n{\r\nstruct snvs_rtc_data *data = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(data->irq);\r\nreturn 0;\r\n}\r\nstatic int snvs_rtc_resume(struct device *dev)\r\n{\r\nstruct snvs_rtc_data *data = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(data->irq);\r\nreturn 0;\r\n}
