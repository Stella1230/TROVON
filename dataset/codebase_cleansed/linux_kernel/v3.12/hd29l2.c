static int hd29l2_wr_regs(struct hd29l2_priv *priv, u8 reg, u8 *val, int len)\r\n{\r\nint ret;\r\nu8 buf[2 + len];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = priv->cfg.i2c_addr,\r\n.flags = 0,\r\n.len = sizeof(buf),\r\n.buf = buf,\r\n}\r\n};\r\nbuf[0] = 0x00;\r\nbuf[1] = reg;\r\nmemcpy(&buf[2], val, len);\r\nret = i2c_transfer(priv->i2c, msg, 1);\r\nif (ret == 1) {\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c wr failed=%d reg=%02x len=%d\n",\r\nKBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int hd29l2_rd_regs(struct hd29l2_priv *priv, u8 reg, u8 *val, int len)\r\n{\r\nint ret;\r\nu8 buf[2] = { 0x00, reg };\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = priv->cfg.i2c_addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = buf,\r\n}, {\r\n.addr = priv->cfg.i2c_addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = val,\r\n}\r\n};\r\nret = i2c_transfer(priv->i2c, msg, 2);\r\nif (ret == 2) {\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c rd failed=%d reg=%02x len=%d\n",\r\nKBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int hd29l2_wr_reg(struct hd29l2_priv *priv, u8 reg, u8 val)\r\n{\r\nreturn hd29l2_wr_regs(priv, reg, &val, 1);\r\n}\r\nstatic int hd29l2_rd_reg(struct hd29l2_priv *priv, u8 reg, u8 *val)\r\n{\r\nreturn hd29l2_rd_regs(priv, reg, val, 1);\r\n}\r\nstatic int hd29l2_wr_reg_mask(struct hd29l2_priv *priv, u8 reg, u8 val, u8 mask)\r\n{\r\nint ret;\r\nu8 tmp;\r\nif (mask != 0xff) {\r\nret = hd29l2_rd_regs(priv, reg, &tmp, 1);\r\nif (ret)\r\nreturn ret;\r\nval &= mask;\r\ntmp &= ~mask;\r\nval |= tmp;\r\n}\r\nreturn hd29l2_wr_regs(priv, reg, &val, 1);\r\n}\r\nint hd29l2_rd_reg_mask(struct hd29l2_priv *priv, u8 reg, u8 *val, u8 mask)\r\n{\r\nint ret, i;\r\nu8 tmp;\r\nret = hd29l2_rd_regs(priv, reg, &tmp, 1);\r\nif (ret)\r\nreturn ret;\r\ntmp &= mask;\r\nfor (i = 0; i < 8; i++) {\r\nif ((mask >> i) & 0x01)\r\nbreak;\r\n}\r\n*val = tmp >> i;\r\nreturn 0;\r\n}\r\nstatic int hd29l2_soft_reset(struct hd29l2_priv *priv)\r\n{\r\nint ret;\r\nu8 tmp;\r\nret = hd29l2_rd_reg(priv, 0x26, &tmp);\r\nif (ret)\r\ngoto err;\r\nret = hd29l2_wr_reg(priv, 0x26, 0x0d);\r\nif (ret)\r\ngoto err;\r\nusleep_range(10000, 20000);\r\nret = hd29l2_wr_reg(priv, 0x26, tmp);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int hd29l2_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nint ret, i;\r\nstruct hd29l2_priv *priv = fe->demodulator_priv;\r\nu8 tmp;\r\ndev_dbg(&priv->i2c->dev, "%s: enable=%d\n", __func__, enable);\r\nif (!priv->tuner_i2c_addr_programmed && enable) {\r\nret = hd29l2_wr_reg(priv, 0x9d, priv->cfg.tuner_i2c_addr << 1);\r\nif (ret)\r\ngoto err;\r\npriv->tuner_i2c_addr_programmed = true;\r\n}\r\nret = hd29l2_wr_reg(priv, 0x9f, enable);\r\nif (ret)\r\ngoto err;\r\nfor (i = 10; i; i--) {\r\nret = hd29l2_rd_reg(priv, 0x9e, &tmp);\r\nif (ret)\r\ngoto err;\r\nif (tmp == enable)\r\nbreak;\r\nusleep_range(5000, 10000);\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s: loop=%d\n", __func__, i);\r\nreturn ret;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int hd29l2_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nint ret;\r\nstruct hd29l2_priv *priv = fe->demodulator_priv;\r\nu8 buf[2];\r\n*status = 0;\r\nret = hd29l2_rd_reg(priv, 0x05, &buf[0]);\r\nif (ret)\r\ngoto err;\r\nif (buf[0] & 0x01) {\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI |\r\nFE_HAS_SYNC | FE_HAS_LOCK;\r\n} else {\r\nret = hd29l2_rd_reg(priv, 0x0d, &buf[1]);\r\nif (ret)\r\ngoto err;\r\nif ((buf[1] & 0xfe) == 0x78)\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC;\r\n}\r\npriv->fe_status = *status;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int hd29l2_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nint ret;\r\nstruct hd29l2_priv *priv = fe->demodulator_priv;\r\nu8 buf[2];\r\nu16 tmp;\r\nif (!(priv->fe_status & FE_HAS_LOCK)) {\r\n*snr = 0;\r\nret = 0;\r\ngoto err;\r\n}\r\nret = hd29l2_rd_regs(priv, 0x0b, buf, 2);\r\nif (ret)\r\ngoto err;\r\ntmp = (buf[0] << 8) | buf[1];\r\n#define LOG10_20736_24 72422627\r\nif (tmp)\r\n*snr = (LOG10_20736_24 - intlog10(tmp)) / ((1 << 24) / 100);\r\nelse\r\n*snr = 0;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int hd29l2_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nint ret;\r\nstruct hd29l2_priv *priv = fe->demodulator_priv;\r\nu8 buf[2];\r\nu16 tmp;\r\n*strength = 0;\r\nret = hd29l2_rd_regs(priv, 0xd5, buf, 2);\r\nif (ret)\r\ngoto err;\r\ntmp = buf[0] << 8 | buf[1];\r\ntmp = ~tmp & 0x0fff;\r\n*strength = tmp * 0xffff / 0x0fff;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int hd29l2_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nint ret;\r\nstruct hd29l2_priv *priv = fe->demodulator_priv;\r\nu8 buf[2];\r\nif (!(priv->fe_status & FE_HAS_SYNC)) {\r\n*ber = 0;\r\nret = 0;\r\ngoto err;\r\n}\r\nret = hd29l2_rd_regs(priv, 0xd9, buf, 2);\r\nif (ret) {\r\n*ber = 0;\r\ngoto err;\r\n}\r\n*ber = ((buf[0] & 0x0f) << 8) | buf[1];\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int hd29l2_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\n*ucblocks = 0;\r\nreturn 0;\r\n}\r\nstatic enum dvbfe_search hd29l2_search(struct dvb_frontend *fe)\r\n{\r\nint ret, i;\r\nstruct hd29l2_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu8 tmp, buf[3];\r\nu8 modulation, carrier, guard_interval, interleave, code_rate;\r\nu64 num64;\r\nu32 if_freq, if_ctl;\r\nbool auto_mode;\r\ndev_dbg(&priv->i2c->dev, "%s: delivery_system=%d frequency=%d " \\r\n"bandwidth_hz=%d modulation=%d inversion=%d " \\r\n"fec_inner=%d guard_interval=%d\n", __func__,\r\nc->delivery_system, c->frequency, c->bandwidth_hz,\r\nc->modulation, c->inversion, c->fec_inner,\r\nc->guard_interval);\r\nauto_mode = true;\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.tuner_ops.get_if_frequency)\r\nfe->ops.tuner_ops.get_if_frequency(fe, &if_freq);\r\nelse\r\nif_freq = 0;\r\nif (if_freq) {\r\nnum64 = if_freq;\r\nnum64 *= 0x800000;\r\nnum64 = div_u64(num64, HD29L2_XTAL);\r\nnum64 -= 0x800000;\r\nif_ctl = num64;\r\ntmp = 0xfc;\r\n} else {\r\nif_ctl = 0;\r\ntmp = 0xfe;\r\n}\r\nbuf[0] = ((if_ctl >> 0) & 0xff);\r\nbuf[1] = ((if_ctl >> 8) & 0xff);\r\nbuf[2] = ((if_ctl >> 16) & 0xff);\r\nret = hd29l2_wr_regs(priv, 0x14, buf, 3);\r\nif (ret)\r\ngoto err;\r\nret = hd29l2_wr_reg(priv, 0xab, tmp);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&priv->i2c->dev, "%s: if_freq=%d if_ctl=%x\n",\r\n__func__, if_freq, if_ctl);\r\nif (auto_mode) {\r\nret = hd29l2_wr_reg_mask(priv, 0xac, 0 << 7, 0x80);\r\nif (ret)\r\ngoto err;\r\nret = hd29l2_wr_reg_mask(priv, 0x82, 1 << 1, 0x02);\r\nif (ret)\r\ngoto err;\r\nret = hd29l2_wr_reg_mask(priv, 0x7d, 1 << 6, 0x40);\r\nif (ret)\r\ngoto err;\r\nret = hd29l2_wr_reg_mask(priv, 0x81, 1 << 3, 0x08);\r\nif (ret)\r\ngoto err;\r\nret = hd29l2_soft_reset(priv);\r\nif (ret)\r\ngoto err;\r\nfor (i = 30; i; i--) {\r\nmsleep(100);\r\nret = hd29l2_rd_reg(priv, 0x0d, &tmp);\r\nif (ret)\r\ngoto err;\r\nif ((((tmp & 0xf0) >= 0x10) &&\r\n((tmp & 0x0f) == 0x08)) || (tmp >= 0x2c))\r\nbreak;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s: loop=%d\n", __func__, i);\r\nif (i == 0)\r\nreturn DVBFE_ALGO_SEARCH_FAILED;\r\nret = hd29l2_rd_reg_mask(priv, 0x7d, &modulation, 0x07);\r\nif (ret)\r\ngoto err;\r\n} else {\r\nmodulation = HD29L2_QAM64;\r\ncarrier = HD29L2_CARRIER_MULTI;\r\nguard_interval = HD29L2_PN945;\r\ninterleave = HD29L2_INTERLEAVER_420;\r\ncode_rate = HD29L2_CODE_RATE_08;\r\ntmp = (code_rate << 3) | modulation;\r\nret = hd29l2_wr_reg_mask(priv, 0x7d, tmp, 0x5f);\r\nif (ret)\r\ngoto err;\r\ntmp = (carrier << 2) | guard_interval;\r\nret = hd29l2_wr_reg_mask(priv, 0x81, tmp, 0x0f);\r\nif (ret)\r\ngoto err;\r\ntmp = interleave;\r\nret = hd29l2_wr_reg_mask(priv, 0x82, tmp, 0x03);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (modulation > (ARRAY_SIZE(reg_mod_vals_tab[0].val) - 1)) {\r\ndev_dbg(&priv->i2c->dev, "%s: modulation=%d not valid\n",\r\n__func__, modulation);\r\ngoto err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(reg_mod_vals_tab); i++) {\r\nret = hd29l2_wr_reg(priv, reg_mod_vals_tab[i].reg,\r\nreg_mod_vals_tab[i].val[modulation]);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = hd29l2_rd_reg_mask(priv, 0x81, &guard_interval, 0x03);\r\nif (ret)\r\ngoto err;\r\nret = hd29l2_rd_reg_mask(priv, 0x81, &carrier, 0x04);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&priv->i2c->dev,\r\n"%s: modulation=%d guard_interval=%d carrier=%d\n",\r\n__func__, modulation, guard_interval, carrier);\r\nif ((carrier == HD29L2_CARRIER_MULTI) && (modulation == HD29L2_QAM64) &&\r\n(guard_interval == HD29L2_PN945)) {\r\ndev_dbg(&priv->i2c->dev, "%s: C=3780 && QAM64 && PN945\n",\r\n__func__);\r\nret = hd29l2_wr_reg(priv, 0x42, 0x33);\r\nif (ret)\r\ngoto err;\r\nret = hd29l2_wr_reg(priv, 0xdd, 0x01);\r\nif (ret)\r\ngoto err;\r\n}\r\nusleep_range(10000, 20000);\r\nret = hd29l2_soft_reset(priv);\r\nif (ret)\r\ngoto err;\r\nfor (i = 30; i; i--) {\r\nmsleep(100);\r\nret = hd29l2_rd_reg_mask(priv, 0x05, &tmp, 0x01);\r\nif (ret)\r\ngoto err;\r\nif (tmp)\r\nbreak;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s: loop=%d\n", __func__, i);\r\nif (i == 0)\r\nreturn DVBFE_ALGO_SEARCH_AGAIN;\r\nreturn DVBFE_ALGO_SEARCH_SUCCESS;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn DVBFE_ALGO_SEARCH_ERROR;\r\n}\r\nstatic int hd29l2_get_frontend_algo(struct dvb_frontend *fe)\r\n{\r\nreturn DVBFE_ALGO_CUSTOM;\r\n}\r\nstatic int hd29l2_get_frontend(struct dvb_frontend *fe)\r\n{\r\nint ret;\r\nstruct hd29l2_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu8 buf[3];\r\nu32 if_ctl;\r\nchar *str_constellation, *str_code_rate, *str_constellation_code_rate,\r\n*str_guard_interval, *str_carrier, *str_guard_interval_carrier,\r\n*str_interleave, *str_interleave_;\r\nret = hd29l2_rd_reg(priv, 0x7d, &buf[0]);\r\nif (ret)\r\ngoto err;\r\nret = hd29l2_rd_regs(priv, 0x81, &buf[1], 2);\r\nif (ret)\r\ngoto err;\r\nswitch ((buf[0] >> 0) & 0x07) {\r\ncase 0:\r\nstr_constellation = "QAM4NR";\r\nc->modulation = QAM_AUTO;\r\nbreak;\r\ncase 1:\r\nstr_constellation = "QAM4";\r\nc->modulation = QPSK;\r\nbreak;\r\ncase 2:\r\nstr_constellation = "QAM16";\r\nc->modulation = QAM_16;\r\nbreak;\r\ncase 3:\r\nstr_constellation = "QAM32";\r\nc->modulation = QAM_32;\r\nbreak;\r\ncase 4:\r\nstr_constellation = "QAM64";\r\nc->modulation = QAM_64;\r\nbreak;\r\ndefault:\r\nstr_constellation = "?";\r\n}\r\nswitch ((buf[0] >> 3) & 0x03) {\r\ncase 0:\r\nstr_code_rate = "0.4";\r\nc->fec_inner = FEC_AUTO;\r\nbreak;\r\ncase 1:\r\nstr_code_rate = "0.6";\r\nc->fec_inner = FEC_3_5;\r\nbreak;\r\ncase 2:\r\nstr_code_rate = "0.8";\r\nc->fec_inner = FEC_4_5;\r\nbreak;\r\ndefault:\r\nstr_code_rate = "?";\r\n}\r\nswitch ((buf[0] >> 6) & 0x01) {\r\ncase 0:\r\nstr_constellation_code_rate = "manual";\r\nbreak;\r\ncase 1:\r\nstr_constellation_code_rate = "auto";\r\nbreak;\r\ndefault:\r\nstr_constellation_code_rate = "?";\r\n}\r\nswitch ((buf[1] >> 0) & 0x03) {\r\ncase 0:\r\nstr_guard_interval = "PN945";\r\nc->guard_interval = GUARD_INTERVAL_AUTO;\r\nbreak;\r\ncase 1:\r\nstr_guard_interval = "PN595";\r\nc->guard_interval = GUARD_INTERVAL_AUTO;\r\nbreak;\r\ncase 2:\r\nstr_guard_interval = "PN420";\r\nc->guard_interval = GUARD_INTERVAL_AUTO;\r\nbreak;\r\ndefault:\r\nstr_guard_interval = "?";\r\n}\r\nswitch ((buf[1] >> 2) & 0x01) {\r\ncase 0:\r\nstr_carrier = "C=1";\r\nbreak;\r\ncase 1:\r\nstr_carrier = "C=3780";\r\nbreak;\r\ndefault:\r\nstr_carrier = "?";\r\n}\r\nswitch ((buf[1] >> 3) & 0x01) {\r\ncase 0:\r\nstr_guard_interval_carrier = "manual";\r\nbreak;\r\ncase 1:\r\nstr_guard_interval_carrier = "auto";\r\nbreak;\r\ndefault:\r\nstr_guard_interval_carrier = "?";\r\n}\r\nswitch ((buf[2] >> 0) & 0x01) {\r\ncase 0:\r\nstr_interleave = "M=720";\r\nbreak;\r\ncase 1:\r\nstr_interleave = "M=240";\r\nbreak;\r\ndefault:\r\nstr_interleave = "?";\r\n}\r\nswitch ((buf[2] >> 1) & 0x01) {\r\ncase 0:\r\nstr_interleave_ = "manual";\r\nbreak;\r\ncase 1:\r\nstr_interleave_ = "auto";\r\nbreak;\r\ndefault:\r\nstr_interleave_ = "?";\r\n}\r\nret = hd29l2_rd_regs(priv, 0xb1, &buf[0], 3);\r\nif (ret)\r\ngoto err;\r\nif_ctl = (buf[0] << 16) | ((buf[1] - 7) << 8) | buf[2];\r\ndev_dbg(&priv->i2c->dev, "%s: %s %s %s | %s %s %s | %s %s | NCO=%06x\n",\r\n__func__, str_constellation, str_code_rate,\r\nstr_constellation_code_rate, str_guard_interval,\r\nstr_carrier, str_guard_interval_carrier, str_interleave,\r\nstr_interleave_, if_ctl);\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int hd29l2_init(struct dvb_frontend *fe)\r\n{\r\nint ret, i;\r\nstruct hd29l2_priv *priv = fe->demodulator_priv;\r\nu8 tmp;\r\nstatic const struct reg_val tab[] = {\r\n{ 0x3a, 0x06 },\r\n{ 0x3b, 0x03 },\r\n{ 0x3c, 0x04 },\r\n{ 0xaf, 0x06 },\r\n{ 0xb0, 0x1b },\r\n{ 0x80, 0x64 },\r\n{ 0x10, 0x38 },\r\n};\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\nif (fe->callback) {\r\nret = fe->callback(fe, DVB_FRONTEND_COMPONENT_DEMOD, 0, 0);\r\nif (ret)\r\ngoto err;\r\npriv->tuner_i2c_addr_programmed = false;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(tab); i++) {\r\nret = hd29l2_wr_reg(priv, tab[i].reg, tab[i].val);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = hd29l2_rd_reg(priv, 0x36, &tmp);\r\nif (ret)\r\ngoto err;\r\ntmp &= 0x1b;\r\ntmp |= priv->cfg.ts_mode;\r\nret = hd29l2_wr_reg(priv, 0x36, tmp);\r\nif (ret)\r\ngoto err;\r\nret = hd29l2_rd_reg(priv, 0x31, &tmp);\r\ntmp &= 0xef;\r\nif (!(priv->cfg.ts_mode >> 7))\r\ntmp |= 0x10;\r\nret = hd29l2_wr_reg(priv, 0x31, tmp);\r\nif (ret)\r\ngoto err;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic void hd29l2_release(struct dvb_frontend *fe)\r\n{\r\nstruct hd29l2_priv *priv = fe->demodulator_priv;\r\nkfree(priv);\r\n}\r\nstruct dvb_frontend *hd29l2_attach(const struct hd29l2_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nint ret;\r\nstruct hd29l2_priv *priv = NULL;\r\nu8 tmp;\r\npriv = kzalloc(sizeof(struct hd29l2_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\ngoto err;\r\npriv->i2c = i2c;\r\nmemcpy(&priv->cfg, config, sizeof(struct hd29l2_config));\r\nret = hd29l2_rd_reg(priv, 0x00, &tmp);\r\nif (ret)\r\ngoto err;\r\nmemcpy(&priv->fe.ops, &hd29l2_ops, sizeof(struct dvb_frontend_ops));\r\npriv->fe.demodulator_priv = priv;\r\nreturn &priv->fe;\r\nerr:\r\nkfree(priv);\r\nreturn NULL;\r\n}
