void batadv_hardif_free_rcu(struct rcu_head *rcu)\r\n{\r\nstruct batadv_hard_iface *hard_iface;\r\nhard_iface = container_of(rcu, struct batadv_hard_iface, rcu);\r\ndev_put(hard_iface->net_dev);\r\nkfree(hard_iface);\r\n}\r\nstruct batadv_hard_iface *\r\nbatadv_hardif_get_by_netdev(const struct net_device *net_dev)\r\n{\r\nstruct batadv_hard_iface *hard_iface;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\r\nif (hard_iface->net_dev == net_dev &&\r\natomic_inc_not_zero(&hard_iface->refcount))\r\ngoto out;\r\n}\r\nhard_iface = NULL;\r\nout:\r\nrcu_read_unlock();\r\nreturn hard_iface;\r\n}\r\nstatic bool batadv_is_on_batman_iface(const struct net_device *net_dev)\r\n{\r\nstruct net_device *parent_dev;\r\nbool ret;\r\nif (batadv_softif_is_valid(net_dev))\r\nreturn true;\r\nif (net_dev->iflink == net_dev->ifindex)\r\nreturn false;\r\nparent_dev = dev_get_by_index(&init_net, net_dev->iflink);\r\nif (WARN(!parent_dev, "Cannot find parent device"))\r\nreturn false;\r\nret = batadv_is_on_batman_iface(parent_dev);\r\nif (parent_dev)\r\ndev_put(parent_dev);\r\nreturn ret;\r\n}\r\nstatic int batadv_is_valid_iface(const struct net_device *net_dev)\r\n{\r\nif (net_dev->flags & IFF_LOOPBACK)\r\nreturn 0;\r\nif (net_dev->type != ARPHRD_ETHER)\r\nreturn 0;\r\nif (net_dev->addr_len != ETH_ALEN)\r\nreturn 0;\r\nif (batadv_is_on_batman_iface(net_dev))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic bool batadv_is_wifi_netdev(struct net_device *net_device)\r\n{\r\n#ifdef CONFIG_WIRELESS_EXT\r\nif (net_device->wireless_handlers)\r\nreturn true;\r\n#endif\r\nif (net_device->ieee80211_ptr)\r\nreturn true;\r\nreturn false;\r\n}\r\nbool batadv_is_wifi_iface(int ifindex)\r\n{\r\nstruct net_device *net_device = NULL;\r\nbool ret = false;\r\nif (ifindex == BATADV_NULL_IFINDEX)\r\ngoto out;\r\nnet_device = dev_get_by_index(&init_net, ifindex);\r\nif (!net_device)\r\ngoto out;\r\nret = batadv_is_wifi_netdev(net_device);\r\nout:\r\nif (net_device)\r\ndev_put(net_device);\r\nreturn ret;\r\n}\r\nstatic struct batadv_hard_iface *\r\nbatadv_hardif_get_active(const struct net_device *soft_iface)\r\n{\r\nstruct batadv_hard_iface *hard_iface;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\r\nif (hard_iface->soft_iface != soft_iface)\r\ncontinue;\r\nif (hard_iface->if_status == BATADV_IF_ACTIVE &&\r\natomic_inc_not_zero(&hard_iface->refcount))\r\ngoto out;\r\n}\r\nhard_iface = NULL;\r\nout:\r\nrcu_read_unlock();\r\nreturn hard_iface;\r\n}\r\nstatic void batadv_primary_if_update_addr(struct batadv_priv *bat_priv,\r\nstruct batadv_hard_iface *oldif)\r\n{\r\nstruct batadv_vis_packet *vis_packet;\r\nstruct batadv_hard_iface *primary_if;\r\nstruct sk_buff *skb;\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto out;\r\nbatadv_dat_init_own_addr(bat_priv, primary_if);\r\nskb = bat_priv->vis.my_info->skb_packet;\r\nvis_packet = (struct batadv_vis_packet *)skb->data;\r\nmemcpy(vis_packet->vis_orig, primary_if->net_dev->dev_addr, ETH_ALEN);\r\nmemcpy(vis_packet->sender_orig,\r\nprimary_if->net_dev->dev_addr, ETH_ALEN);\r\nbatadv_bla_update_orig_address(bat_priv, primary_if, oldif);\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_free_ref(primary_if);\r\n}\r\nstatic void batadv_primary_if_select(struct batadv_priv *bat_priv,\r\nstruct batadv_hard_iface *new_hard_iface)\r\n{\r\nstruct batadv_hard_iface *curr_hard_iface;\r\nASSERT_RTNL();\r\nif (new_hard_iface && !atomic_inc_not_zero(&new_hard_iface->refcount))\r\nnew_hard_iface = NULL;\r\ncurr_hard_iface = rcu_dereference_protected(bat_priv->primary_if, 1);\r\nrcu_assign_pointer(bat_priv->primary_if, new_hard_iface);\r\nif (!new_hard_iface)\r\ngoto out;\r\nbat_priv->bat_algo_ops->bat_primary_iface_set(new_hard_iface);\r\nbatadv_primary_if_update_addr(bat_priv, curr_hard_iface);\r\nout:\r\nif (curr_hard_iface)\r\nbatadv_hardif_free_ref(curr_hard_iface);\r\n}\r\nstatic bool\r\nbatadv_hardif_is_iface_up(const struct batadv_hard_iface *hard_iface)\r\n{\r\nif (hard_iface->net_dev->flags & IFF_UP)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void batadv_check_known_mac_addr(const struct net_device *net_dev)\r\n{\r\nconst struct batadv_hard_iface *hard_iface;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\r\nif ((hard_iface->if_status != BATADV_IF_ACTIVE) &&\r\n(hard_iface->if_status != BATADV_IF_TO_BE_ACTIVATED))\r\ncontinue;\r\nif (hard_iface->net_dev == net_dev)\r\ncontinue;\r\nif (!batadv_compare_eth(hard_iface->net_dev->dev_addr,\r\nnet_dev->dev_addr))\r\ncontinue;\r\npr_warn("The newly added mac address (%pM) already exists on: %s\n",\r\nnet_dev->dev_addr, hard_iface->net_dev->name);\r\npr_warn("It is strongly recommended to keep mac addresses unique to avoid problems!\n");\r\n}\r\nrcu_read_unlock();\r\n}\r\nint batadv_hardif_min_mtu(struct net_device *soft_iface)\r\n{\r\nconst struct batadv_priv *bat_priv = netdev_priv(soft_iface);\r\nconst struct batadv_hard_iface *hard_iface;\r\nint min_mtu = ETH_DATA_LEN;\r\nif (atomic_read(&bat_priv->fragmentation))\r\ngoto out;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\r\nif ((hard_iface->if_status != BATADV_IF_ACTIVE) &&\r\n(hard_iface->if_status != BATADV_IF_TO_BE_ACTIVATED))\r\ncontinue;\r\nif (hard_iface->soft_iface != soft_iface)\r\ncontinue;\r\nmin_mtu = min_t(int,\r\nhard_iface->net_dev->mtu - BATADV_HEADER_LEN,\r\nmin_mtu);\r\n}\r\nrcu_read_unlock();\r\nout:\r\nreturn min_mtu;\r\n}\r\nvoid batadv_update_min_mtu(struct net_device *soft_iface)\r\n{\r\nint min_mtu;\r\nmin_mtu = batadv_hardif_min_mtu(soft_iface);\r\nif (soft_iface->mtu != min_mtu)\r\nsoft_iface->mtu = min_mtu;\r\n}\r\nstatic void\r\nbatadv_hardif_activate_interface(struct batadv_hard_iface *hard_iface)\r\n{\r\nstruct batadv_priv *bat_priv;\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nif (hard_iface->if_status != BATADV_IF_INACTIVE)\r\ngoto out;\r\nbat_priv = netdev_priv(hard_iface->soft_iface);\r\nbat_priv->bat_algo_ops->bat_iface_update_mac(hard_iface);\r\nhard_iface->if_status = BATADV_IF_TO_BE_ACTIVATED;\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\nbatadv_primary_if_select(bat_priv, hard_iface);\r\nbatadv_info(hard_iface->soft_iface, "Interface activated: %s\n",\r\nhard_iface->net_dev->name);\r\nbatadv_update_min_mtu(hard_iface->soft_iface);\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_free_ref(primary_if);\r\n}\r\nstatic void\r\nbatadv_hardif_deactivate_interface(struct batadv_hard_iface *hard_iface)\r\n{\r\nif ((hard_iface->if_status != BATADV_IF_ACTIVE) &&\r\n(hard_iface->if_status != BATADV_IF_TO_BE_ACTIVATED))\r\nreturn;\r\nhard_iface->if_status = BATADV_IF_INACTIVE;\r\nbatadv_info(hard_iface->soft_iface, "Interface deactivated: %s\n",\r\nhard_iface->net_dev->name);\r\nbatadv_update_min_mtu(hard_iface->soft_iface);\r\n}\r\nstatic int batadv_master_del_slave(struct batadv_hard_iface *slave,\r\nstruct net_device *master)\r\n{\r\nint ret;\r\nif (!master)\r\nreturn 0;\r\nret = -EBUSY;\r\nif (master->netdev_ops->ndo_del_slave)\r\nret = master->netdev_ops->ndo_del_slave(master, slave->net_dev);\r\nreturn ret;\r\n}\r\nint batadv_hardif_enable_interface(struct batadv_hard_iface *hard_iface,\r\nconst char *iface_name)\r\n{\r\nstruct batadv_priv *bat_priv;\r\nstruct net_device *soft_iface, *master;\r\n__be16 ethertype = __constant_htons(ETH_P_BATMAN);\r\nint ret;\r\nif (hard_iface->if_status != BATADV_IF_NOT_IN_USE)\r\ngoto out;\r\nif (!atomic_inc_not_zero(&hard_iface->refcount))\r\ngoto out;\r\nsoft_iface = dev_get_by_name(&init_net, iface_name);\r\nif (!soft_iface) {\r\nsoft_iface = batadv_softif_create(iface_name);\r\nif (!soft_iface) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev_hold(soft_iface);\r\n}\r\nif (!batadv_softif_is_valid(soft_iface)) {\r\npr_err("Can't create batman mesh interface %s: already exists as regular interface\n",\r\nsoft_iface->name);\r\nret = -EINVAL;\r\ngoto err_dev;\r\n}\r\nmaster = netdev_master_upper_dev_get(hard_iface->net_dev);\r\nret = batadv_master_del_slave(hard_iface, master);\r\nif (ret)\r\ngoto err_dev;\r\nhard_iface->soft_iface = soft_iface;\r\nbat_priv = netdev_priv(hard_iface->soft_iface);\r\nret = netdev_master_upper_dev_link(hard_iface->net_dev, soft_iface);\r\nif (ret)\r\ngoto err_dev;\r\nret = bat_priv->bat_algo_ops->bat_iface_enable(hard_iface);\r\nif (ret < 0)\r\ngoto err_upper;\r\nhard_iface->if_num = bat_priv->num_ifaces;\r\nbat_priv->num_ifaces++;\r\nhard_iface->if_status = BATADV_IF_INACTIVE;\r\nret = batadv_orig_hash_add_if(hard_iface, bat_priv->num_ifaces);\r\nif (ret < 0) {\r\nbat_priv->bat_algo_ops->bat_iface_disable(hard_iface);\r\nbat_priv->num_ifaces--;\r\nhard_iface->if_status = BATADV_IF_NOT_IN_USE;\r\ngoto err_upper;\r\n}\r\nhard_iface->batman_adv_ptype.type = ethertype;\r\nhard_iface->batman_adv_ptype.func = batadv_batman_skb_recv;\r\nhard_iface->batman_adv_ptype.dev = hard_iface->net_dev;\r\ndev_add_pack(&hard_iface->batman_adv_ptype);\r\natomic_set(&hard_iface->frag_seqno, 1);\r\nbatadv_info(hard_iface->soft_iface, "Adding interface: %s\n",\r\nhard_iface->net_dev->name);\r\nif (atomic_read(&bat_priv->fragmentation) &&\r\nhard_iface->net_dev->mtu < ETH_DATA_LEN + BATADV_HEADER_LEN)\r\nbatadv_info(hard_iface->soft_iface,\r\n"The MTU of interface %s is too small (%i) to handle the transport of batman-adv packets. Packets going over this interface will be fragmented on layer2 which could impact the performance. Setting the MTU to %zi would solve the problem.\n",\r\nhard_iface->net_dev->name, hard_iface->net_dev->mtu,\r\nETH_DATA_LEN + BATADV_HEADER_LEN);\r\nif (!atomic_read(&bat_priv->fragmentation) &&\r\nhard_iface->net_dev->mtu < ETH_DATA_LEN + BATADV_HEADER_LEN)\r\nbatadv_info(hard_iface->soft_iface,\r\n"The MTU of interface %s is too small (%i) to handle the transport of batman-adv packets. If you experience problems getting traffic through try increasing the MTU to %zi.\n",\r\nhard_iface->net_dev->name, hard_iface->net_dev->mtu,\r\nETH_DATA_LEN + BATADV_HEADER_LEN);\r\nif (batadv_hardif_is_iface_up(hard_iface))\r\nbatadv_hardif_activate_interface(hard_iface);\r\nelse\r\nbatadv_err(hard_iface->soft_iface,\r\n"Not using interface %s (retrying later): interface not active\n",\r\nhard_iface->net_dev->name);\r\nbatadv_schedule_bat_ogm(hard_iface);\r\nout:\r\nreturn 0;\r\nerr_upper:\r\nnetdev_upper_dev_unlink(hard_iface->net_dev, soft_iface);\r\nerr_dev:\r\nhard_iface->soft_iface = NULL;\r\ndev_put(soft_iface);\r\nerr:\r\nbatadv_hardif_free_ref(hard_iface);\r\nreturn ret;\r\n}\r\nvoid batadv_hardif_disable_interface(struct batadv_hard_iface *hard_iface,\r\nenum batadv_hard_if_cleanup autodel)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nif (hard_iface->if_status == BATADV_IF_ACTIVE)\r\nbatadv_hardif_deactivate_interface(hard_iface);\r\nif (hard_iface->if_status != BATADV_IF_INACTIVE)\r\ngoto out;\r\nbatadv_info(hard_iface->soft_iface, "Removing interface: %s\n",\r\nhard_iface->net_dev->name);\r\ndev_remove_pack(&hard_iface->batman_adv_ptype);\r\nbat_priv->num_ifaces--;\r\nbatadv_orig_hash_del_if(hard_iface, bat_priv->num_ifaces);\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (hard_iface == primary_if) {\r\nstruct batadv_hard_iface *new_if;\r\nnew_if = batadv_hardif_get_active(hard_iface->soft_iface);\r\nbatadv_primary_if_select(bat_priv, new_if);\r\nif (new_if)\r\nbatadv_hardif_free_ref(new_if);\r\n}\r\nbat_priv->bat_algo_ops->bat_iface_disable(hard_iface);\r\nhard_iface->if_status = BATADV_IF_NOT_IN_USE;\r\nbatadv_purge_orig_ref(bat_priv);\r\nbatadv_purge_outstanding_packets(bat_priv, hard_iface);\r\ndev_put(hard_iface->soft_iface);\r\nif (!bat_priv->num_ifaces && autodel == BATADV_IF_CLEANUP_AUTO)\r\nbatadv_softif_destroy_sysfs(hard_iface->soft_iface);\r\nnetdev_upper_dev_unlink(hard_iface->net_dev, hard_iface->soft_iface);\r\nhard_iface->soft_iface = NULL;\r\nbatadv_hardif_free_ref(hard_iface);\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_free_ref(primary_if);\r\n}\r\nstatic void batadv_hardif_remove_interface_finish(struct work_struct *work)\r\n{\r\nstruct batadv_hard_iface *hard_iface;\r\nhard_iface = container_of(work, struct batadv_hard_iface,\r\ncleanup_work);\r\nbatadv_sysfs_del_hardif(&hard_iface->hardif_obj);\r\nbatadv_hardif_free_ref(hard_iface);\r\n}\r\nstatic struct batadv_hard_iface *\r\nbatadv_hardif_add_interface(struct net_device *net_dev)\r\n{\r\nstruct batadv_hard_iface *hard_iface;\r\nint ret;\r\nASSERT_RTNL();\r\nret = batadv_is_valid_iface(net_dev);\r\nif (ret != 1)\r\ngoto out;\r\ndev_hold(net_dev);\r\nhard_iface = kzalloc(sizeof(*hard_iface), GFP_ATOMIC);\r\nif (!hard_iface)\r\ngoto release_dev;\r\nret = batadv_sysfs_add_hardif(&hard_iface->hardif_obj, net_dev);\r\nif (ret)\r\ngoto free_if;\r\nhard_iface->if_num = -1;\r\nhard_iface->net_dev = net_dev;\r\nhard_iface->soft_iface = NULL;\r\nhard_iface->if_status = BATADV_IF_NOT_IN_USE;\r\nINIT_LIST_HEAD(&hard_iface->list);\r\nINIT_WORK(&hard_iface->cleanup_work,\r\nbatadv_hardif_remove_interface_finish);\r\nhard_iface->num_bcasts = BATADV_NUM_BCASTS_DEFAULT;\r\nif (batadv_is_wifi_netdev(net_dev))\r\nhard_iface->num_bcasts = BATADV_NUM_BCASTS_WIRELESS;\r\natomic_set(&hard_iface->refcount, 2);\r\nbatadv_check_known_mac_addr(hard_iface->net_dev);\r\nlist_add_tail_rcu(&hard_iface->list, &batadv_hardif_list);\r\nreturn hard_iface;\r\nfree_if:\r\nkfree(hard_iface);\r\nrelease_dev:\r\ndev_put(net_dev);\r\nout:\r\nreturn NULL;\r\n}\r\nstatic void batadv_hardif_remove_interface(struct batadv_hard_iface *hard_iface)\r\n{\r\nASSERT_RTNL();\r\nif (hard_iface->if_status != BATADV_IF_NOT_IN_USE)\r\nbatadv_hardif_disable_interface(hard_iface,\r\nBATADV_IF_CLEANUP_AUTO);\r\nif (hard_iface->if_status != BATADV_IF_NOT_IN_USE)\r\nreturn;\r\nhard_iface->if_status = BATADV_IF_TO_BE_REMOVED;\r\nqueue_work(batadv_event_workqueue, &hard_iface->cleanup_work);\r\n}\r\nvoid batadv_hardif_remove_interfaces(void)\r\n{\r\nstruct batadv_hard_iface *hard_iface, *hard_iface_tmp;\r\nrtnl_lock();\r\nlist_for_each_entry_safe(hard_iface, hard_iface_tmp,\r\n&batadv_hardif_list, list) {\r\nlist_del_rcu(&hard_iface->list);\r\nbatadv_hardif_remove_interface(hard_iface);\r\n}\r\nrtnl_unlock();\r\n}\r\nstatic int batadv_hard_if_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *net_dev = netdev_notifier_info_to_dev(ptr);\r\nstruct batadv_hard_iface *hard_iface;\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nstruct batadv_priv *bat_priv;\r\nif (batadv_softif_is_valid(net_dev) && event == NETDEV_REGISTER) {\r\nbatadv_sysfs_add_meshif(net_dev);\r\nreturn NOTIFY_DONE;\r\n}\r\nhard_iface = batadv_hardif_get_by_netdev(net_dev);\r\nif (!hard_iface && event == NETDEV_REGISTER)\r\nhard_iface = batadv_hardif_add_interface(net_dev);\r\nif (!hard_iface)\r\ngoto out;\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nbatadv_hardif_activate_interface(hard_iface);\r\nbreak;\r\ncase NETDEV_GOING_DOWN:\r\ncase NETDEV_DOWN:\r\nbatadv_hardif_deactivate_interface(hard_iface);\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nlist_del_rcu(&hard_iface->list);\r\nbatadv_hardif_remove_interface(hard_iface);\r\nbreak;\r\ncase NETDEV_CHANGEMTU:\r\nif (hard_iface->soft_iface)\r\nbatadv_update_min_mtu(hard_iface->soft_iface);\r\nbreak;\r\ncase NETDEV_CHANGEADDR:\r\nif (hard_iface->if_status == BATADV_IF_NOT_IN_USE)\r\ngoto hardif_put;\r\nbatadv_check_known_mac_addr(hard_iface->net_dev);\r\nbat_priv = netdev_priv(hard_iface->soft_iface);\r\nbat_priv->bat_algo_ops->bat_iface_update_mac(hard_iface);\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto hardif_put;\r\nif (hard_iface == primary_if)\r\nbatadv_primary_if_update_addr(bat_priv, NULL);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nhardif_put:\r\nbatadv_hardif_free_ref(hard_iface);\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_free_ref(primary_if);\r\nreturn NOTIFY_DONE;\r\n}
