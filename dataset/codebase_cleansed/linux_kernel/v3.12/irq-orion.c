static asmlinkage void\r\n__exception_irq_entry orion_handle_irq(struct pt_regs *regs)\r\n{\r\nstruct irq_domain_chip_generic *dgc = orion_irq_domain->gc;\r\nint n, base = 0;\r\nfor (n = 0; n < dgc->num_chips; n++, base += ORION_IRQS_PER_CHIP) {\r\nstruct irq_chip_generic *gc =\r\nirq_get_domain_generic_chip(orion_irq_domain, base);\r\nu32 stat = readl_relaxed(gc->reg_base + ORION_IRQ_CAUSE) &\r\ngc->mask_cache;\r\nwhile (stat) {\r\nu32 hwirq = ffs(stat) - 1;\r\nu32 irq = irq_find_mapping(orion_irq_domain,\r\ngc->irq_base + hwirq);\r\nhandle_IRQ(irq, regs);\r\nstat &= ~(1 << hwirq);\r\n}\r\n}\r\n}\r\nstatic int __init orion_irq_init(struct device_node *np,\r\nstruct device_node *parent)\r\n{\r\nunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\r\nint n, ret, base, num_chips = 0;\r\nstruct resource r;\r\nwhile (of_address_to_resource(np, num_chips, &r) == 0)\r\nnum_chips++;\r\norion_irq_domain = irq_domain_add_linear(np,\r\nnum_chips * ORION_IRQS_PER_CHIP,\r\n&irq_generic_chip_ops, NULL);\r\nif (!orion_irq_domain)\r\npanic("%s: unable to add irq domain\n", np->name);\r\nret = irq_alloc_domain_generic_chips(orion_irq_domain,\r\nORION_IRQS_PER_CHIP, 1, np->name,\r\nhandle_level_irq, clr, 0,\r\nIRQ_GC_INIT_MASK_CACHE);\r\nif (ret)\r\npanic("%s: unable to alloc irq domain gc\n", np->name);\r\nfor (n = 0, base = 0; n < num_chips; n++, base += ORION_IRQS_PER_CHIP) {\r\nstruct irq_chip_generic *gc =\r\nirq_get_domain_generic_chip(orion_irq_domain, base);\r\nof_address_to_resource(np, n, &r);\r\nif (!request_mem_region(r.start, resource_size(&r), np->name))\r\npanic("%s: unable to request mem region %d",\r\nnp->name, n);\r\ngc->reg_base = ioremap(r.start, resource_size(&r));\r\nif (!gc->reg_base)\r\npanic("%s: unable to map resource %d", np->name, n);\r\ngc->chip_types[0].regs.mask = ORION_IRQ_MASK;\r\ngc->chip_types[0].chip.irq_mask = irq_gc_mask_clr_bit;\r\ngc->chip_types[0].chip.irq_unmask = irq_gc_mask_set_bit;\r\nwritel(0, gc->reg_base + ORION_IRQ_MASK);\r\n}\r\nset_handle_irq(orion_handle_irq);\r\nreturn 0;\r\n}\r\nstatic void orion_bridge_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct irq_domain *d = irq_get_handler_data(irq);\r\nstruct irq_chip_generic *gc = irq_get_domain_generic_chip(d, irq);\r\nu32 stat = readl_relaxed(gc->reg_base + ORION_BRIDGE_IRQ_CAUSE) &\r\ngc->mask_cache;\r\nwhile (stat) {\r\nu32 hwirq = ffs(stat) - 1;\r\ngeneric_handle_irq(irq_find_mapping(d, gc->irq_base + hwirq));\r\nstat &= ~(1 << hwirq);\r\n}\r\n}\r\nstatic int __init orion_bridge_irq_init(struct device_node *np,\r\nstruct device_node *parent)\r\n{\r\nunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\r\nstruct resource r;\r\nstruct irq_domain *domain;\r\nstruct irq_chip_generic *gc;\r\nint ret, irq, nrirqs = 32;\r\nof_property_read_u32(np, "marvell,#interrupts", &nrirqs);\r\ndomain = irq_domain_add_linear(np, nrirqs,\r\n&irq_generic_chip_ops, NULL);\r\nif (!domain) {\r\npr_err("%s: unable to add irq domain\n", np->name);\r\nreturn -ENOMEM;\r\n}\r\nret = irq_alloc_domain_generic_chips(domain, nrirqs, 1, np->name,\r\nhandle_level_irq, clr, 0, IRQ_GC_INIT_MASK_CACHE);\r\nif (ret) {\r\npr_err("%s: unable to alloc irq domain gc\n", np->name);\r\nreturn ret;\r\n}\r\nret = of_address_to_resource(np, 0, &r);\r\nif (ret) {\r\npr_err("%s: unable to get resource\n", np->name);\r\nreturn ret;\r\n}\r\nif (!request_mem_region(r.start, resource_size(&r), np->name)) {\r\npr_err("%s: unable to request mem region\n", np->name);\r\nreturn -ENOMEM;\r\n}\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (irq <= 0) {\r\npr_err("%s: unable to parse irq\n", np->name);\r\nreturn -EINVAL;\r\n}\r\ngc = irq_get_domain_generic_chip(domain, 0);\r\ngc->reg_base = ioremap(r.start, resource_size(&r));\r\nif (!gc->reg_base) {\r\npr_err("%s: unable to map resource\n", np->name);\r\nreturn -ENOMEM;\r\n}\r\ngc->chip_types[0].regs.ack = ORION_BRIDGE_IRQ_CAUSE;\r\ngc->chip_types[0].regs.mask = ORION_BRIDGE_IRQ_MASK;\r\ngc->chip_types[0].chip.irq_ack = irq_gc_ack_clr_bit;\r\ngc->chip_types[0].chip.irq_mask = irq_gc_mask_clr_bit;\r\ngc->chip_types[0].chip.irq_unmask = irq_gc_mask_set_bit;\r\nwritel(0, gc->reg_base + ORION_BRIDGE_IRQ_MASK);\r\nirq_set_handler_data(irq, domain);\r\nirq_set_chained_handler(irq, orion_bridge_irq_handler);\r\nreturn 0;\r\n}
