static void dbg_td(struct c67x00_hcd *c67x00, struct c67x00_td *td, char *msg)\r\n{\r\nstruct device *dev = c67x00_hcd_dev(c67x00);\r\ndev_dbg(dev, "### %s at 0x%04x\n", msg, td->td_addr);\r\ndev_dbg(dev, "urb: 0x%p\n", td->urb);\r\ndev_dbg(dev, "endpoint: %4d\n", usb_pipeendpoint(td->pipe));\r\ndev_dbg(dev, "pipeout: %4d\n", usb_pipeout(td->pipe));\r\ndev_dbg(dev, "ly_base_addr: 0x%04x\n", td_ly_base_addr(td));\r\ndev_dbg(dev, "port_length: 0x%04x\n", td_port_length(td));\r\ndev_dbg(dev, "pid_ep: 0x%02x\n", td->pid_ep);\r\ndev_dbg(dev, "dev_addr: 0x%02x\n", td->dev_addr);\r\ndev_dbg(dev, "ctrl_reg: 0x%02x\n", td->ctrl_reg);\r\ndev_dbg(dev, "status: 0x%02x\n", td->status);\r\ndev_dbg(dev, "retry_cnt: 0x%02x\n", td->retry_cnt);\r\ndev_dbg(dev, "residue: 0x%02x\n", td->residue);\r\ndev_dbg(dev, "next_td_addr: 0x%04x\n", td_next_td_addr(td));\r\ndev_dbg(dev, "data:");\r\nprint_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 16, 1,\r\ntd->data, td_length(td), 1);\r\n}\r\nstatic inline void\r\ndbg_td(struct c67x00_hcd *c67x00, struct c67x00_td *td, char *msg) { }\r\nstatic inline u16 c67x00_get_current_frame_number(struct c67x00_hcd *c67x00)\r\n{\r\nreturn c67x00_ll_husb_get_frame(c67x00->sie) & HOST_FRAME_MASK;\r\n}\r\nstatic inline u16 frame_add(u16 a, u16 b)\r\n{\r\nreturn (a + b) & HOST_FRAME_MASK;\r\n}\r\nstatic inline int frame_after(u16 a, u16 b)\r\n{\r\nreturn ((HOST_FRAME_MASK + a - b) & HOST_FRAME_MASK) <\r\n(HOST_FRAME_MASK / 2);\r\n}\r\nstatic inline int frame_after_eq(u16 a, u16 b)\r\n{\r\nreturn ((HOST_FRAME_MASK + 1 + a - b) & HOST_FRAME_MASK) <\r\n(HOST_FRAME_MASK / 2);\r\n}\r\nstatic void c67x00_release_urb(struct c67x00_hcd *c67x00, struct urb *urb)\r\n{\r\nstruct c67x00_td *td;\r\nstruct c67x00_urb_priv *urbp;\r\nBUG_ON(!urb);\r\nc67x00->urb_count--;\r\nif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\r\nc67x00->urb_iso_count--;\r\nif (c67x00->urb_iso_count == 0)\r\nc67x00->max_frame_bw = MAX_FRAME_BW_STD;\r\n}\r\nlist_for_each_entry(td, &c67x00->td_list, td_list)\r\nif (urb == td->urb)\r\ntd->urb = NULL;\r\nurbp = urb->hcpriv;\r\nurb->hcpriv = NULL;\r\nlist_del(&urbp->hep_node);\r\nkfree(urbp);\r\n}\r\nstatic struct c67x00_ep_data *\r\nc67x00_ep_data_alloc(struct c67x00_hcd *c67x00, struct urb *urb)\r\n{\r\nstruct usb_host_endpoint *hep = urb->ep;\r\nstruct c67x00_ep_data *ep_data;\r\nint type;\r\nc67x00->current_frame = c67x00_get_current_frame_number(c67x00);\r\nif (hep->hcpriv) {\r\nep_data = hep->hcpriv;\r\nif (frame_after(c67x00->current_frame, ep_data->next_frame))\r\nep_data->next_frame =\r\nframe_add(c67x00->current_frame, 1);\r\nreturn hep->hcpriv;\r\n}\r\nep_data = kzalloc(sizeof(*ep_data), GFP_ATOMIC);\r\nif (!ep_data)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&ep_data->queue);\r\nINIT_LIST_HEAD(&ep_data->node);\r\nep_data->hep = hep;\r\nep_data->dev = usb_get_dev(urb->dev);\r\nhep->hcpriv = ep_data;\r\nep_data->next_frame = frame_add(c67x00->current_frame, 1);\r\ntype = usb_pipetype(urb->pipe);\r\nif (list_empty(&ep_data->node)) {\r\nlist_add(&ep_data->node, &c67x00->list[type]);\r\n} else {\r\nstruct c67x00_ep_data *prev;\r\nlist_for_each_entry(prev, &c67x00->list[type], node) {\r\nif (prev->hep->desc.bEndpointAddress >\r\nhep->desc.bEndpointAddress) {\r\nlist_add(&ep_data->node, prev->node.prev);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn ep_data;\r\n}\r\nstatic int c67x00_ep_data_free(struct usb_host_endpoint *hep)\r\n{\r\nstruct c67x00_ep_data *ep_data = hep->hcpriv;\r\nif (!ep_data)\r\nreturn 0;\r\nif (!list_empty(&ep_data->queue))\r\nreturn -EBUSY;\r\nusb_put_dev(ep_data->dev);\r\nlist_del(&ep_data->queue);\r\nlist_del(&ep_data->node);\r\nkfree(ep_data);\r\nhep->hcpriv = NULL;\r\nreturn 0;\r\n}\r\nvoid c67x00_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep)\r\n{\r\nstruct c67x00_hcd *c67x00 = hcd_to_c67x00_hcd(hcd);\r\nunsigned long flags;\r\nif (!list_empty(&ep->urb_list))\r\ndev_warn(c67x00_hcd_dev(c67x00), "error: urb list not empty\n");\r\nspin_lock_irqsave(&c67x00->lock, flags);\r\nwhile (c67x00_ep_data_free(ep)) {\r\nspin_unlock_irqrestore(&c67x00->lock, flags);\r\nINIT_COMPLETION(c67x00->endpoint_disable);\r\nc67x00_sched_kick(c67x00);\r\nwait_for_completion_timeout(&c67x00->endpoint_disable, 1 * HZ);\r\nspin_lock_irqsave(&c67x00->lock, flags);\r\n}\r\nspin_unlock_irqrestore(&c67x00->lock, flags);\r\n}\r\nstatic inline int get_root_port(struct usb_device *dev)\r\n{\r\nwhile (dev->parent->parent)\r\ndev = dev->parent;\r\nreturn dev->portnum;\r\n}\r\nint c67x00_urb_enqueue(struct usb_hcd *hcd,\r\nstruct urb *urb, gfp_t mem_flags)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nstruct c67x00_urb_priv *urbp;\r\nstruct c67x00_hcd *c67x00 = hcd_to_c67x00_hcd(hcd);\r\nint port = get_root_port(urb->dev)-1;\r\nspin_lock_irqsave(&c67x00->lock, flags);\r\nif (!HC_IS_RUNNING(hcd->state)) {\r\nret = -ENODEV;\r\ngoto err_not_linked;\r\n}\r\nret = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (ret)\r\ngoto err_not_linked;\r\nurbp = kzalloc(sizeof(*urbp), mem_flags);\r\nif (!urbp) {\r\nret = -ENOMEM;\r\ngoto err_urbp;\r\n}\r\nINIT_LIST_HEAD(&urbp->hep_node);\r\nurbp->urb = urb;\r\nurbp->port = port;\r\nurbp->ep_data = c67x00_ep_data_alloc(c67x00, urb);\r\nif (!urbp->ep_data) {\r\nret = -ENOMEM;\r\ngoto err_epdata;\r\n}\r\nurb->hcpriv = urbp;\r\nurb->actual_length = 0;\r\nswitch (usb_pipetype(urb->pipe)) {\r\ncase PIPE_CONTROL:\r\nurb->interval = SETUP_STAGE;\r\nbreak;\r\ncase PIPE_INTERRUPT:\r\nbreak;\r\ncase PIPE_BULK:\r\nbreak;\r\ncase PIPE_ISOCHRONOUS:\r\nif (c67x00->urb_iso_count == 0)\r\nc67x00->max_frame_bw = MAX_FRAME_BW_ISO;\r\nc67x00->urb_iso_count++;\r\nif (list_empty(&urbp->ep_data->queue))\r\nurb->start_frame = urbp->ep_data->next_frame;\r\nelse {\r\nstruct urb *last_urb;\r\nlast_urb = list_entry(urbp->ep_data->queue.prev,\r\nstruct c67x00_urb_priv,\r\nhep_node)->urb;\r\nurb->start_frame =\r\nframe_add(last_urb->start_frame,\r\nlast_urb->number_of_packets *\r\nlast_urb->interval);\r\n}\r\nurbp->cnt = 0;\r\nbreak;\r\n}\r\nlist_add_tail(&urbp->hep_node, &urbp->ep_data->queue);\r\nif (!c67x00->urb_count++)\r\nc67x00_ll_hpi_enable_sofeop(c67x00->sie);\r\nc67x00_sched_kick(c67x00);\r\nspin_unlock_irqrestore(&c67x00->lock, flags);\r\nreturn 0;\r\nerr_epdata:\r\nkfree(urbp);\r\nerr_urbp:\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nerr_not_linked:\r\nspin_unlock_irqrestore(&c67x00->lock, flags);\r\nreturn ret;\r\n}\r\nint c67x00_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nstruct c67x00_hcd *c67x00 = hcd_to_c67x00_hcd(hcd);\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&c67x00->lock, flags);\r\nrc = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif (rc)\r\ngoto done;\r\nc67x00_release_urb(c67x00, urb);\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nspin_unlock(&c67x00->lock);\r\nusb_hcd_giveback_urb(hcd, urb, status);\r\nspin_lock(&c67x00->lock);\r\nspin_unlock_irqrestore(&c67x00->lock, flags);\r\nreturn 0;\r\ndone:\r\nspin_unlock_irqrestore(&c67x00->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void\r\nc67x00_giveback_urb(struct c67x00_hcd *c67x00, struct urb *urb, int status)\r\n{\r\nstruct c67x00_urb_priv *urbp;\r\nif (!urb)\r\nreturn;\r\nurbp = urb->hcpriv;\r\nurbp->status = status;\r\nlist_del_init(&urbp->hep_node);\r\nc67x00_release_urb(c67x00, urb);\r\nusb_hcd_unlink_urb_from_ep(c67x00_hcd_to_hcd(c67x00), urb);\r\nspin_unlock(&c67x00->lock);\r\nusb_hcd_giveback_urb(c67x00_hcd_to_hcd(c67x00), urb, urbp->status);\r\nspin_lock(&c67x00->lock);\r\n}\r\nstatic int c67x00_claim_frame_bw(struct c67x00_hcd *c67x00, struct urb *urb,\r\nint len, int periodic)\r\n{\r\nstruct c67x00_urb_priv *urbp = urb->hcpriv;\r\nint bit_time;\r\nif (urbp->ep_data->dev->speed == USB_SPEED_LOW) {\r\nif (usb_pipein(urb->pipe))\r\nbit_time = 80240 + 7578*len;\r\nelse\r\nbit_time = 80260 + 7467*len;\r\n} else {\r\nif (usb_pipeisoc(urb->pipe))\r\nbit_time = usb_pipein(urb->pipe) ? 9050 : 7840;\r\nelse\r\nbit_time = 11250;\r\nbit_time += 936*len;\r\n}\r\nbit_time = ((bit_time+50) / 100) + 106;\r\nif (unlikely(bit_time + c67x00->bandwidth_allocated >=\r\nc67x00->max_frame_bw))\r\nreturn -EMSGSIZE;\r\nif (unlikely(c67x00->next_td_addr + CY_TD_SIZE >=\r\nc67x00->td_base_addr + SIE_TD_SIZE))\r\nreturn -EMSGSIZE;\r\nif (unlikely(c67x00->next_buf_addr + len >=\r\nc67x00->buf_base_addr + SIE_TD_BUF_SIZE))\r\nreturn -EMSGSIZE;\r\nif (periodic) {\r\nif (unlikely(bit_time + c67x00->periodic_bw_allocated >=\r\nMAX_PERIODIC_BW(c67x00->max_frame_bw)))\r\nreturn -EMSGSIZE;\r\nc67x00->periodic_bw_allocated += bit_time;\r\n}\r\nc67x00->bandwidth_allocated += bit_time;\r\nreturn 0;\r\n}\r\nstatic int c67x00_create_td(struct c67x00_hcd *c67x00, struct urb *urb,\r\nvoid *data, int len, int pid, int toggle,\r\nunsigned long privdata)\r\n{\r\nstruct c67x00_td *td;\r\nstruct c67x00_urb_priv *urbp = urb->hcpriv;\r\nconst __u8 active_flag = 1, retry_cnt = 3;\r\n__u8 cmd = 0;\r\nint tt = 0;\r\nif (c67x00_claim_frame_bw(c67x00, urb, len, usb_pipeisoc(urb->pipe)\r\n|| usb_pipeint(urb->pipe)))\r\nreturn -EMSGSIZE;\r\ntd = kzalloc(sizeof(*td), GFP_ATOMIC);\r\nif (!td)\r\nreturn -ENOMEM;\r\ntd->pipe = urb->pipe;\r\ntd->ep_data = urbp->ep_data;\r\nif ((td_udev(td)->speed == USB_SPEED_LOW) &&\r\n!(c67x00->low_speed_ports & (1 << urbp->port)))\r\ncmd |= PREAMBLE_EN;\r\nswitch (usb_pipetype(td->pipe)) {\r\ncase PIPE_ISOCHRONOUS:\r\ntt = TT_ISOCHRONOUS;\r\ncmd |= ISO_EN;\r\nbreak;\r\ncase PIPE_CONTROL:\r\ntt = TT_CONTROL;\r\nbreak;\r\ncase PIPE_BULK:\r\ntt = TT_BULK;\r\nbreak;\r\ncase PIPE_INTERRUPT:\r\ntt = TT_INTERRUPT;\r\nbreak;\r\n}\r\nif (toggle)\r\ncmd |= SEQ_SEL;\r\ncmd |= ARM_EN;\r\ntd->td_addr = c67x00->next_td_addr;\r\nc67x00->next_td_addr = c67x00->next_td_addr + CY_TD_SIZE;\r\ntd->ly_base_addr = __cpu_to_le16(c67x00->next_buf_addr);\r\ntd->port_length = __cpu_to_le16((c67x00->sie->sie_num << 15) |\r\n(urbp->port << 14) | (len & 0x3FF));\r\ntd->pid_ep = ((pid & 0xF) << TD_PIDEP_OFFSET) |\r\n(usb_pipeendpoint(td->pipe) & 0xF);\r\ntd->dev_addr = usb_pipedevice(td->pipe) & 0x7F;\r\ntd->ctrl_reg = cmd;\r\ntd->status = 0;\r\ntd->retry_cnt = (tt << TT_OFFSET) | (active_flag << 4) | retry_cnt;\r\ntd->residue = 0;\r\ntd->next_td_addr = __cpu_to_le16(c67x00->next_td_addr);\r\ntd->data = data;\r\ntd->urb = urb;\r\ntd->privdata = privdata;\r\nc67x00->next_buf_addr += (len + 1) & ~0x01;\r\nlist_add_tail(&td->td_list, &c67x00->td_list);\r\nreturn 0;\r\n}\r\nstatic inline void c67x00_release_td(struct c67x00_td *td)\r\n{\r\nlist_del_init(&td->td_list);\r\nkfree(td);\r\n}\r\nstatic int c67x00_add_data_urb(struct c67x00_hcd *c67x00, struct urb *urb)\r\n{\r\nint remaining;\r\nint toggle;\r\nint pid;\r\nint ret = 0;\r\nint maxps;\r\nint need_empty;\r\ntoggle = usb_gettoggle(urb->dev, usb_pipeendpoint(urb->pipe),\r\nusb_pipeout(urb->pipe));\r\nremaining = urb->transfer_buffer_length - urb->actual_length;\r\nmaxps = usb_maxpacket(urb->dev, urb->pipe, usb_pipeout(urb->pipe));\r\nneed_empty = (urb->transfer_flags & URB_ZERO_PACKET) &&\r\nusb_pipeout(urb->pipe) && !(remaining % maxps);\r\nwhile (remaining || need_empty) {\r\nint len;\r\nchar *td_buf;\r\nlen = (remaining > maxps) ? maxps : remaining;\r\nif (!len)\r\nneed_empty = 0;\r\npid = usb_pipeout(urb->pipe) ? USB_PID_OUT : USB_PID_IN;\r\ntd_buf = urb->transfer_buffer + urb->transfer_buffer_length -\r\nremaining;\r\nret = c67x00_create_td(c67x00, urb, td_buf, len, pid, toggle,\r\nDATA_STAGE);\r\nif (ret)\r\nreturn ret;\r\ntoggle ^= 1;\r\nremaining -= len;\r\nif (usb_pipecontrol(urb->pipe))\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int c67x00_add_ctrl_urb(struct c67x00_hcd *c67x00, struct urb *urb)\r\n{\r\nint ret;\r\nint pid;\r\nswitch (urb->interval) {\r\ndefault:\r\ncase SETUP_STAGE:\r\nret = c67x00_create_td(c67x00, urb, urb->setup_packet,\r\n8, USB_PID_SETUP, 0, SETUP_STAGE);\r\nif (ret)\r\nreturn ret;\r\nurb->interval = SETUP_STAGE;\r\nusb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),\r\nusb_pipeout(urb->pipe), 1);\r\nbreak;\r\ncase DATA_STAGE:\r\nif (urb->transfer_buffer_length) {\r\nret = c67x00_add_data_urb(c67x00, urb);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\n}\r\ncase STATUS_STAGE:\r\npid = !usb_pipeout(urb->pipe) ? USB_PID_OUT : USB_PID_IN;\r\nret = c67x00_create_td(c67x00, urb, NULL, 0, pid, 1,\r\nSTATUS_STAGE);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int c67x00_add_int_urb(struct c67x00_hcd *c67x00, struct urb *urb)\r\n{\r\nstruct c67x00_urb_priv *urbp = urb->hcpriv;\r\nif (frame_after_eq(c67x00->current_frame, urbp->ep_data->next_frame)) {\r\nurbp->ep_data->next_frame =\r\nframe_add(urbp->ep_data->next_frame, urb->interval);\r\nreturn c67x00_add_data_urb(c67x00, urb);\r\n}\r\nreturn 0;\r\n}\r\nstatic int c67x00_add_iso_urb(struct c67x00_hcd *c67x00, struct urb *urb)\r\n{\r\nstruct c67x00_urb_priv *urbp = urb->hcpriv;\r\nif (frame_after_eq(c67x00->current_frame, urbp->ep_data->next_frame)) {\r\nchar *td_buf;\r\nint len, pid, ret;\r\nBUG_ON(urbp->cnt >= urb->number_of_packets);\r\ntd_buf = urb->transfer_buffer +\r\nurb->iso_frame_desc[urbp->cnt].offset;\r\nlen = urb->iso_frame_desc[urbp->cnt].length;\r\npid = usb_pipeout(urb->pipe) ? USB_PID_OUT : USB_PID_IN;\r\nret = c67x00_create_td(c67x00, urb, td_buf, len, pid, 0,\r\nurbp->cnt);\r\nif (ret) {\r\nprintk(KERN_DEBUG "create failed: %d\n", ret);\r\nurb->iso_frame_desc[urbp->cnt].actual_length = 0;\r\nurb->iso_frame_desc[urbp->cnt].status = ret;\r\nif (urbp->cnt + 1 == urb->number_of_packets)\r\nc67x00_giveback_urb(c67x00, urb, 0);\r\n}\r\nurbp->ep_data->next_frame =\r\nframe_add(urbp->ep_data->next_frame, urb->interval);\r\nurbp->cnt++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void c67x00_fill_from_list(struct c67x00_hcd *c67x00, int type,\r\nint (*add)(struct c67x00_hcd *, struct urb *))\r\n{\r\nstruct c67x00_ep_data *ep_data;\r\nstruct urb *urb;\r\nlist_for_each_entry(ep_data, &c67x00->list[type], node) {\r\nif (!list_empty(&ep_data->queue)) {\r\nurb = list_entry(ep_data->queue.next,\r\nstruct c67x00_urb_priv,\r\nhep_node)->urb;\r\nadd(c67x00, urb);\r\n}\r\n}\r\n}\r\nstatic void c67x00_fill_frame(struct c67x00_hcd *c67x00)\r\n{\r\nstruct c67x00_td *td, *ttd;\r\nif (!list_empty(&c67x00->td_list)) {\r\ndev_warn(c67x00_hcd_dev(c67x00),\r\n"TD list not empty! This should not happen!\n");\r\nlist_for_each_entry_safe(td, ttd, &c67x00->td_list, td_list) {\r\ndbg_td(c67x00, td, "Unprocessed td");\r\nc67x00_release_td(td);\r\n}\r\n}\r\nc67x00->bandwidth_allocated = 0;\r\nc67x00->periodic_bw_allocated = 0;\r\nc67x00->next_td_addr = c67x00->td_base_addr;\r\nc67x00->next_buf_addr = c67x00->buf_base_addr;\r\nc67x00_fill_from_list(c67x00, PIPE_ISOCHRONOUS, c67x00_add_iso_urb);\r\nc67x00_fill_from_list(c67x00, PIPE_INTERRUPT, c67x00_add_int_urb);\r\nc67x00_fill_from_list(c67x00, PIPE_CONTROL, c67x00_add_ctrl_urb);\r\nc67x00_fill_from_list(c67x00, PIPE_BULK, c67x00_add_data_urb);\r\n}\r\nstatic inline void\r\nc67x00_parse_td(struct c67x00_hcd *c67x00, struct c67x00_td *td)\r\n{\r\nc67x00_ll_read_mem_le16(c67x00->sie->dev,\r\ntd->td_addr, td, CY_TD_SIZE);\r\nif (usb_pipein(td->pipe) && td_actual_bytes(td))\r\nc67x00_ll_read_mem_le16(c67x00->sie->dev, td_ly_base_addr(td),\r\ntd->data, td_actual_bytes(td));\r\n}\r\nstatic int c67x00_td_to_error(struct c67x00_hcd *c67x00, struct c67x00_td *td)\r\n{\r\nif (td->status & TD_STATUSMASK_ERR) {\r\ndbg_td(c67x00, td, "ERROR_FLAG");\r\nreturn -EILSEQ;\r\n}\r\nif (td->status & TD_STATUSMASK_STALL) {\r\nreturn -EPIPE;\r\n}\r\nif (td->status & TD_STATUSMASK_TMOUT) {\r\ndbg_td(c67x00, td, "TIMEOUT");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int c67x00_end_of_data(struct c67x00_td *td)\r\n{\r\nint maxps, need_empty, remaining;\r\nstruct urb *urb = td->urb;\r\nint act_bytes;\r\nact_bytes = td_actual_bytes(td);\r\nif (unlikely(!act_bytes))\r\nreturn 1;\r\nmaxps = usb_maxpacket(td_udev(td), td->pipe, usb_pipeout(td->pipe));\r\nif (unlikely(act_bytes < maxps))\r\nreturn 1;\r\nremaining = urb->transfer_buffer_length - urb->actual_length;\r\nneed_empty = (urb->transfer_flags & URB_ZERO_PACKET) &&\r\nusb_pipeout(urb->pipe) && !(remaining % maxps);\r\nif (unlikely(!remaining && !need_empty))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline void c67x00_clear_pipe(struct c67x00_hcd *c67x00,\r\nstruct c67x00_td *last_td)\r\n{\r\nstruct c67x00_td *td, *tmp;\r\ntd = last_td;\r\ntmp = last_td;\r\nwhile (td->td_list.next != &c67x00->td_list) {\r\ntd = list_entry(td->td_list.next, struct c67x00_td, td_list);\r\nif (td->pipe == last_td->pipe) {\r\nc67x00_release_td(td);\r\ntd = tmp;\r\n}\r\ntmp = td;\r\n}\r\n}\r\nstatic void c67x00_handle_successful_td(struct c67x00_hcd *c67x00,\r\nstruct c67x00_td *td)\r\n{\r\nstruct urb *urb = td->urb;\r\nif (!urb)\r\nreturn;\r\nurb->actual_length += td_actual_bytes(td);\r\nswitch (usb_pipetype(td->pipe)) {\r\ncase PIPE_CONTROL:\r\nswitch (td->privdata) {\r\ncase SETUP_STAGE:\r\nurb->interval =\r\nurb->transfer_buffer_length ?\r\nDATA_STAGE : STATUS_STAGE;\r\nurb->actual_length = 0;\r\nbreak;\r\ncase DATA_STAGE:\r\nif (c67x00_end_of_data(td)) {\r\nurb->interval = STATUS_STAGE;\r\nc67x00_clear_pipe(c67x00, td);\r\n}\r\nbreak;\r\ncase STATUS_STAGE:\r\nurb->interval = 0;\r\nc67x00_giveback_urb(c67x00, urb, 0);\r\nbreak;\r\n}\r\nbreak;\r\ncase PIPE_INTERRUPT:\r\ncase PIPE_BULK:\r\nif (unlikely(c67x00_end_of_data(td))) {\r\nc67x00_clear_pipe(c67x00, td);\r\nc67x00_giveback_urb(c67x00, urb, 0);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void c67x00_handle_isoc(struct c67x00_hcd *c67x00, struct c67x00_td *td)\r\n{\r\nstruct urb *urb = td->urb;\r\nstruct c67x00_urb_priv *urbp;\r\nint cnt;\r\nif (!urb)\r\nreturn;\r\nurbp = urb->hcpriv;\r\ncnt = td->privdata;\r\nif (td->status & TD_ERROR_MASK)\r\nurb->error_count++;\r\nurb->iso_frame_desc[cnt].actual_length = td_actual_bytes(td);\r\nurb->iso_frame_desc[cnt].status = c67x00_td_to_error(c67x00, td);\r\nif (cnt + 1 == urb->number_of_packets)\r\nc67x00_giveback_urb(c67x00, urb, 0);\r\n}\r\nstatic inline void c67x00_check_td_list(struct c67x00_hcd *c67x00)\r\n{\r\nstruct c67x00_td *td, *tmp;\r\nstruct urb *urb;\r\nint ack_ok;\r\nint clear_endpoint;\r\nlist_for_each_entry_safe(td, tmp, &c67x00->td_list, td_list) {\r\nc67x00_parse_td(c67x00, td);\r\nurb = td->urb;\r\nack_ok = 0;\r\nclear_endpoint = 1;\r\nif (usb_pipeisoc(td->pipe)) {\r\nclear_endpoint = 0;\r\nc67x00_handle_isoc(c67x00, td);\r\ngoto cont;\r\n}\r\nif (td->status & TD_ERROR_MASK) {\r\nc67x00_giveback_urb(c67x00, urb,\r\nc67x00_td_to_error(c67x00, td));\r\ngoto cont;\r\n}\r\nif ((td->status & TD_STATUSMASK_NAK) || !td_sequence_ok(td) ||\r\n!td_acked(td))\r\ngoto cont;\r\nack_ok = 1;\r\nif (unlikely(td->status & TD_STATUSMASK_OVF)) {\r\nif (td_residue(td) & TD_RESIDUE_OVERFLOW) {\r\nc67x00_giveback_urb(c67x00, urb, -EOVERFLOW);\r\ngoto cont;\r\n}\r\n}\r\nclear_endpoint = 0;\r\nc67x00_handle_successful_td(c67x00, td);\r\ncont:\r\nif (clear_endpoint)\r\nc67x00_clear_pipe(c67x00, td);\r\nif (ack_ok)\r\nusb_settoggle(td_udev(td), usb_pipeendpoint(td->pipe),\r\nusb_pipeout(td->pipe),\r\n!(td->ctrl_reg & SEQ_SEL));\r\ntmp = list_entry(td->td_list.next, typeof(*td), td_list);\r\nc67x00_release_td(td);\r\n}\r\n}\r\nstatic inline int c67x00_all_tds_processed(struct c67x00_hcd *c67x00)\r\n{\r\nreturn !c67x00_ll_husb_get_current_td(c67x00->sie);\r\n}\r\nstatic void c67x00_send_td(struct c67x00_hcd *c67x00, struct c67x00_td *td)\r\n{\r\nint len = td_length(td);\r\nif (len && ((td->pid_ep & TD_PIDEPMASK_PID) != TD_PID_IN))\r\nc67x00_ll_write_mem_le16(c67x00->sie->dev, td_ly_base_addr(td),\r\ntd->data, len);\r\nc67x00_ll_write_mem_le16(c67x00->sie->dev,\r\ntd->td_addr, td, CY_TD_SIZE);\r\n}\r\nstatic void c67x00_send_frame(struct c67x00_hcd *c67x00)\r\n{\r\nstruct c67x00_td *td;\r\nif (list_empty(&c67x00->td_list))\r\ndev_warn(c67x00_hcd_dev(c67x00),\r\n"%s: td list should not be empty here!\n",\r\n__func__);\r\nlist_for_each_entry(td, &c67x00->td_list, td_list) {\r\nif (td->td_list.next == &c67x00->td_list)\r\ntd->next_td_addr = 0;\r\nc67x00_send_td(c67x00, td);\r\n}\r\nc67x00_ll_husb_set_current_td(c67x00->sie, c67x00->td_base_addr);\r\n}\r\nstatic void c67x00_do_work(struct c67x00_hcd *c67x00)\r\n{\r\nspin_lock(&c67x00->lock);\r\nif (!c67x00_all_tds_processed(c67x00))\r\ngoto out;\r\nc67x00_check_td_list(c67x00);\r\ncomplete(&c67x00->endpoint_disable);\r\nif (!list_empty(&c67x00->td_list))\r\ngoto out;\r\nc67x00->current_frame = c67x00_get_current_frame_number(c67x00);\r\nif (c67x00->current_frame == c67x00->last_frame)\r\ngoto out;\r\nc67x00->last_frame = c67x00->current_frame;\r\nif (!c67x00->urb_count) {\r\nc67x00_ll_hpi_disable_sofeop(c67x00->sie);\r\ngoto out;\r\n}\r\nc67x00_fill_frame(c67x00);\r\nif (!list_empty(&c67x00->td_list))\r\nc67x00_send_frame(c67x00);\r\nout:\r\nspin_unlock(&c67x00->lock);\r\n}\r\nstatic void c67x00_sched_tasklet(unsigned long __c67x00)\r\n{\r\nstruct c67x00_hcd *c67x00 = (struct c67x00_hcd *)__c67x00;\r\nc67x00_do_work(c67x00);\r\n}\r\nvoid c67x00_sched_kick(struct c67x00_hcd *c67x00)\r\n{\r\ntasklet_hi_schedule(&c67x00->tasklet);\r\n}\r\nint c67x00_sched_start_scheduler(struct c67x00_hcd *c67x00)\r\n{\r\ntasklet_init(&c67x00->tasklet, c67x00_sched_tasklet,\r\n(unsigned long)c67x00);\r\nreturn 0;\r\n}\r\nvoid c67x00_sched_stop_scheduler(struct c67x00_hcd *c67x00)\r\n{\r\ntasklet_kill(&c67x00->tasklet);\r\n}
