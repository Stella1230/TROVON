static int mcs7830_get_reg(struct usbnet *dev, u16 index, u16 size, void *data)\r\n{\r\nreturn usbnet_read_cmd(dev, MCS7830_RD_BREQ, MCS7830_RD_BMREQ,\r\n0x0000, index, data, size);\r\n}\r\nstatic int mcs7830_set_reg(struct usbnet *dev, u16 index, u16 size, const void *data)\r\n{\r\nreturn usbnet_write_cmd(dev, MCS7830_WR_BREQ, MCS7830_WR_BMREQ,\r\n0x0000, index, data, size);\r\n}\r\nstatic void mcs7830_set_reg_async(struct usbnet *dev, u16 index, u16 size, void *data)\r\n{\r\nusbnet_write_cmd_async(dev, MCS7830_WR_BREQ, MCS7830_WR_BMREQ,\r\n0x0000, index, data, size);\r\n}\r\nstatic int mcs7830_hif_get_mac_address(struct usbnet *dev, unsigned char *addr)\r\n{\r\nint ret = mcs7830_get_reg(dev, HIF_REG_ETHERNET_ADDR, ETH_ALEN, addr);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int mcs7830_hif_set_mac_address(struct usbnet *dev, unsigned char *addr)\r\n{\r\nint ret = mcs7830_set_reg(dev, HIF_REG_ETHERNET_ADDR, ETH_ALEN, addr);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int mcs7830_set_mac_address(struct net_device *netdev, void *p)\r\n{\r\nint ret;\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nstruct sockaddr *addr = p;\r\nif (netif_running(netdev))\r\nreturn -EBUSY;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nret = mcs7830_hif_set_mac_address(dev, addr->sa_data);\r\nif (ret < 0)\r\nreturn ret;\r\nmemcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);\r\nreturn 0;\r\n}\r\nstatic int mcs7830_read_phy(struct usbnet *dev, u8 index)\r\n{\r\nint ret;\r\nint i;\r\n__le16 val;\r\nu8 cmd[2] = {\r\nHIF_REG_PHY_CMD1_READ | HIF_REG_PHY_CMD1_PHYADDR,\r\nHIF_REG_PHY_CMD2_PEND_FLAG_BIT | index,\r\n};\r\nmutex_lock(&dev->phy_mutex);\r\nret = mcs7830_set_reg(dev, HIF_REG_PHY_CMD1, 2, cmd);\r\nif (ret < 0)\r\ngoto out;\r\nfor (i = 0; i < 10; i++) {\r\nret = mcs7830_get_reg(dev, HIF_REG_PHY_CMD1, 2, cmd);\r\nif ((ret < 0) || (cmd[1] & HIF_REG_PHY_CMD2_READY_FLAG_BIT))\r\nbreak;\r\nret = -EIO;\r\nmsleep(1);\r\n}\r\nif (ret < 0)\r\ngoto out;\r\nret = mcs7830_get_reg(dev, HIF_REG_PHY_DATA, 2, &val);\r\nif (ret < 0)\r\ngoto out;\r\nret = le16_to_cpu(val);\r\ndev_dbg(&dev->udev->dev, "read PHY reg %02x: %04x (%d tries)\n",\r\nindex, val, i);\r\nout:\r\nmutex_unlock(&dev->phy_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcs7830_write_phy(struct usbnet *dev, u8 index, u16 val)\r\n{\r\nint ret;\r\nint i;\r\n__le16 le_val;\r\nu8 cmd[2] = {\r\nHIF_REG_PHY_CMD1_WRITE | HIF_REG_PHY_CMD1_PHYADDR,\r\nHIF_REG_PHY_CMD2_PEND_FLAG_BIT | (index & 0x1F),\r\n};\r\nmutex_lock(&dev->phy_mutex);\r\nle_val = cpu_to_le16(val);\r\nret = mcs7830_set_reg(dev, HIF_REG_PHY_DATA, 2, &le_val);\r\nif (ret < 0)\r\ngoto out;\r\nret = mcs7830_set_reg(dev, HIF_REG_PHY_CMD1, 2, cmd);\r\nif (ret < 0)\r\ngoto out;\r\nfor (i = 0; i < 10; i++) {\r\nret = mcs7830_get_reg(dev, HIF_REG_PHY_CMD1, 2, cmd);\r\nif ((ret < 0) || (cmd[1] & HIF_REG_PHY_CMD2_READY_FLAG_BIT))\r\nbreak;\r\nret = -EIO;\r\nmsleep(1);\r\n}\r\nif (ret < 0)\r\ngoto out;\r\nret = 0;\r\ndev_dbg(&dev->udev->dev, "write PHY reg %02x: %04x (%d tries)\n",\r\nindex, val, i);\r\nout:\r\nmutex_unlock(&dev->phy_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcs7830_set_autoneg(struct usbnet *dev, int ptrUserPhyMode)\r\n{\r\nint ret;\r\nret = mcs7830_write_phy(dev, MII_ADVERTISE, MCS7830_MII_ADVERTISE);\r\nif (!ret)\r\nret = mcs7830_write_phy(dev, MII_BMCR, 0x0000);\r\nif (!ret)\r\nret = mcs7830_write_phy(dev, MII_BMCR, BMCR_ANENABLE);\r\nif (!ret)\r\nret = mcs7830_write_phy(dev, MII_BMCR,\r\nBMCR_ANENABLE | BMCR_ANRESTART );\r\nreturn ret;\r\n}\r\nstatic int mcs7830_get_rev(struct usbnet *dev)\r\n{\r\nu8 dummy[2];\r\nint ret;\r\nret = mcs7830_get_reg(dev, HIF_REG_FRAME_DROP_COUNTER, 2, dummy);\r\nif (ret > 0)\r\nreturn 2;\r\nreturn 1;\r\n}\r\nstatic void mcs7830_rev_C_fixup(struct usbnet *dev)\r\n{\r\nu8 pause_threshold = HIF_REG_PAUSE_THRESHOLD_DEFAULT;\r\nint retry;\r\nfor (retry = 0; retry < 2; retry++) {\r\nif (mcs7830_get_rev(dev) == 2) {\r\ndev_info(&dev->udev->dev, "applying rev.C fixup\n");\r\nmcs7830_set_reg(dev, HIF_REG_PAUSE_THRESHOLD,\r\n1, &pause_threshold);\r\n}\r\nmsleep(1);\r\n}\r\n}\r\nstatic int mcs7830_mdio_read(struct net_device *netdev, int phy_id,\r\nint location)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nreturn mcs7830_read_phy(dev, location);\r\n}\r\nstatic void mcs7830_mdio_write(struct net_device *netdev, int phy_id,\r\nint location, int val)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nmcs7830_write_phy(dev, location, val);\r\n}\r\nstatic int mcs7830_ioctl(struct net_device *net, struct ifreq *rq, int cmd)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nreturn generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);\r\n}\r\nstatic inline struct mcs7830_data *mcs7830_get_data(struct usbnet *dev)\r\n{\r\nreturn (struct mcs7830_data *)&dev->data;\r\n}\r\nstatic void mcs7830_hif_update_multicast_hash(struct usbnet *dev)\r\n{\r\nstruct mcs7830_data *data = mcs7830_get_data(dev);\r\nmcs7830_set_reg_async(dev, HIF_REG_MULTICAST_HASH,\r\nsizeof data->multi_filter,\r\ndata->multi_filter);\r\n}\r\nstatic void mcs7830_hif_update_config(struct usbnet *dev)\r\n{\r\nstruct mcs7830_data *data = mcs7830_get_data(dev);\r\nmcs7830_set_reg_async(dev, HIF_REG_CONFIG, 1, &data->config);\r\n}\r\nstatic void mcs7830_data_set_multicast(struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstruct mcs7830_data *data = mcs7830_get_data(dev);\r\nmemset(data->multi_filter, 0, sizeof data->multi_filter);\r\ndata->config = HIF_REG_CONFIG_TXENABLE;\r\ndata->config |= HIF_REG_CONFIG_ALLMULTICAST;\r\nif (net->flags & IFF_PROMISC) {\r\ndata->config |= HIF_REG_CONFIG_PROMISCUOUS;\r\n} else if (net->flags & IFF_ALLMULTI ||\r\nnetdev_mc_count(net) > MCS7830_MAX_MCAST) {\r\ndata->config |= HIF_REG_CONFIG_ALLMULTICAST;\r\n} else if (netdev_mc_empty(net)) {\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nu32 crc_bits;\r\nnetdev_for_each_mc_addr(ha, net) {\r\ncrc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\ndata->multi_filter[crc_bits >> 3] |= 1 << (crc_bits & 7);\r\n}\r\n}\r\n}\r\nstatic int mcs7830_apply_base_config(struct usbnet *dev)\r\n{\r\nint ret;\r\nret = mcs7830_hif_set_mac_address(dev, dev->net->dev_addr);\r\nif (ret) {\r\ndev_info(&dev->udev->dev, "Cannot set MAC address\n");\r\ngoto out;\r\n}\r\nret = mcs7830_set_autoneg(dev, 0);\r\nif (ret) {\r\ndev_info(&dev->udev->dev, "Cannot set autoneg\n");\r\ngoto out;\r\n}\r\nmcs7830_hif_update_multicast_hash(dev);\r\nmcs7830_hif_update_config(dev);\r\nmcs7830_rev_C_fixup(dev);\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void mcs7830_set_multicast(struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nmcs7830_data_set_multicast(net);\r\nmcs7830_hif_update_multicast_hash(dev);\r\nmcs7830_hif_update_config(dev);\r\n}\r\nstatic int mcs7830_get_regs_len(struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nswitch (mcs7830_get_rev(dev)) {\r\ncase 1:\r\nreturn 21;\r\ncase 2:\r\nreturn 32;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mcs7830_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *drvinfo)\r\n{\r\nusbnet_get_drvinfo(net, drvinfo);\r\ndrvinfo->regdump_len = mcs7830_get_regs_len(net);\r\n}\r\nstatic void mcs7830_get_regs(struct net_device *net, struct ethtool_regs *regs, void *data)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nregs->version = mcs7830_get_rev(dev);\r\nmcs7830_get_reg(dev, 0, regs->len, data);\r\n}\r\nstatic int mcs7830_bind(struct usbnet *dev, struct usb_interface *udev)\r\n{\r\nstruct net_device *net = dev->net;\r\nint ret;\r\nint retry;\r\nret = -EINVAL;\r\nfor (retry = 0; retry < 5 && ret; retry++)\r\nret = mcs7830_hif_get_mac_address(dev, net->dev_addr);\r\nif (ret) {\r\ndev_warn(&dev->udev->dev, "Cannot read MAC address\n");\r\ngoto out;\r\n}\r\nmcs7830_data_set_multicast(net);\r\nret = mcs7830_apply_base_config(dev);\r\nif (ret)\r\ngoto out;\r\nnet->ethtool_ops = &mcs7830_ethtool_ops;\r\nnet->netdev_ops = &mcs7830_netdev_ops;\r\ndev->rx_urb_size = ETH_FRAME_LEN + 1;\r\ndev->mii.mdio_read = mcs7830_mdio_read;\r\ndev->mii.mdio_write = mcs7830_mdio_write;\r\ndev->mii.dev = net;\r\ndev->mii.phy_id_mask = 0x3f;\r\ndev->mii.reg_num_mask = 0x1f;\r\ndev->mii.phy_id = *((u8 *) net->dev_addr + 1);\r\nret = usbnet_get_endpoints(dev, udev);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int mcs7830_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nu8 status;\r\nif (skb->len == 0) {\r\ndev_err(&dev->udev->dev, "unexpected empty rx frame\n");\r\nreturn 0;\r\n}\r\nskb_trim(skb, skb->len - 1);\r\nstatus = skb->data[skb->len];\r\nif (status != MCS7830_RX_FRAME_CORRECT) {\r\ndev_dbg(&dev->udev->dev, "rx fixup status %x\n", status);\r\ndev->net->stats.rx_errors++;\r\nif (status & (MCS7830_RX_SHORT_FRAME\r\n|MCS7830_RX_LENGTH_ERROR\r\n|MCS7830_RX_LARGE_FRAME))\r\ndev->net->stats.rx_length_errors++;\r\nif (status & MCS7830_RX_ALIGNMENT_ERROR)\r\ndev->net->stats.rx_frame_errors++;\r\nif (status & MCS7830_RX_CRC_ERROR)\r\ndev->net->stats.rx_crc_errors++;\r\n}\r\nreturn skb->len > 0;\r\n}\r\nstatic void mcs7830_status(struct usbnet *dev, struct urb *urb)\r\n{\r\nu8 *buf = urb->transfer_buffer;\r\nbool link, link_changed;\r\nstruct mcs7830_data *data = mcs7830_get_data(dev);\r\nif (urb->actual_length < 16)\r\nreturn;\r\nlink = !(buf[1] & 0x20);\r\nlink_changed = netif_carrier_ok(dev->net) != link;\r\nif (link_changed) {\r\ndata->link_counter++;\r\nif (data->link_counter > 20) {\r\ndata->link_counter = 0;\r\nusbnet_link_change(dev, link, 0);\r\nnetdev_dbg(dev->net, "Link Status is: %d\n", link);\r\n}\r\n} else\r\ndata->link_counter = 0;\r\n}\r\nstatic int mcs7830_reset_resume (struct usb_interface *intf)\r\n{\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nmcs7830_apply_base_config(dev);\r\nusbnet_resume(intf);\r\nreturn 0;\r\n}
