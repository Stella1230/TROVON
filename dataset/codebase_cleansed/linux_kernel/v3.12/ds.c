static void pcmcia_check_driver(struct pcmcia_driver *p_drv)\r\n{\r\nconst struct pcmcia_device_id *did = p_drv->id_table;\r\nunsigned int i;\r\nu32 hash;\r\nif (!p_drv->probe || !p_drv->remove)\r\nprintk(KERN_DEBUG "pcmcia: %s lacks a requisite callback "\r\n"function\n", p_drv->name);\r\nwhile (did && did->match_flags) {\r\nfor (i = 0; i < 4; i++) {\r\nif (!did->prod_id[i])\r\ncontinue;\r\nhash = crc32(0, did->prod_id[i], strlen(did->prod_id[i]));\r\nif (hash == did->prod_id_hash[i])\r\ncontinue;\r\nprintk(KERN_DEBUG "pcmcia: %s: invalid hash for "\r\n"product string \"%s\": is 0x%x, should "\r\n"be 0x%x\n", p_drv->name, did->prod_id[i],\r\ndid->prod_id_hash[i], hash);\r\nprintk(KERN_DEBUG "pcmcia: see "\r\n"Documentation/pcmcia/devicetable.txt for "\r\n"details\n");\r\n}\r\ndid++;\r\n}\r\nreturn;\r\n}\r\nstatic ssize_t\r\npcmcia_store_new_id(struct device_driver *driver, const char *buf, size_t count)\r\n{\r\nstruct pcmcia_dynid *dynid;\r\nstruct pcmcia_driver *pdrv = to_pcmcia_drv(driver);\r\n__u16 match_flags, manf_id, card_id;\r\n__u8 func_id, function, device_no;\r\n__u32 prod_id_hash[4] = {0, 0, 0, 0};\r\nint fields = 0;\r\nint retval = 0;\r\nfields = sscanf(buf, "%hx %hx %hx %hhx %hhx %hhx %x %x %x %x",\r\n&match_flags, &manf_id, &card_id, &func_id, &function, &device_no,\r\n&prod_id_hash[0], &prod_id_hash[1], &prod_id_hash[2], &prod_id_hash[3]);\r\nif (fields < 6)\r\nreturn -EINVAL;\r\ndynid = kzalloc(sizeof(struct pcmcia_dynid), GFP_KERNEL);\r\nif (!dynid)\r\nreturn -ENOMEM;\r\ndynid->id.match_flags = match_flags;\r\ndynid->id.manf_id = manf_id;\r\ndynid->id.card_id = card_id;\r\ndynid->id.func_id = func_id;\r\ndynid->id.function = function;\r\ndynid->id.device_no = device_no;\r\nmemcpy(dynid->id.prod_id_hash, prod_id_hash, sizeof(__u32) * 4);\r\nmutex_lock(&pdrv->dynids.lock);\r\nlist_add_tail(&dynid->node, &pdrv->dynids.list);\r\nmutex_unlock(&pdrv->dynids.lock);\r\nretval = driver_attach(&pdrv->drv);\r\nif (retval)\r\nreturn retval;\r\nreturn count;\r\n}\r\nstatic void\r\npcmcia_free_dynids(struct pcmcia_driver *drv)\r\n{\r\nstruct pcmcia_dynid *dynid, *n;\r\nmutex_lock(&drv->dynids.lock);\r\nlist_for_each_entry_safe(dynid, n, &drv->dynids.list, node) {\r\nlist_del(&dynid->node);\r\nkfree(dynid);\r\n}\r\nmutex_unlock(&drv->dynids.lock);\r\n}\r\nstatic int\r\npcmcia_create_newid_file(struct pcmcia_driver *drv)\r\n{\r\nint error = 0;\r\nif (drv->probe != NULL)\r\nerror = driver_create_file(&drv->drv, &driver_attr_new_id);\r\nreturn error;\r\n}\r\nstatic void\r\npcmcia_remove_newid_file(struct pcmcia_driver *drv)\r\n{\r\ndriver_remove_file(&drv->drv, &driver_attr_new_id);\r\n}\r\nint pcmcia_register_driver(struct pcmcia_driver *driver)\r\n{\r\nint error;\r\nif (!driver)\r\nreturn -EINVAL;\r\npcmcia_check_driver(driver);\r\ndriver->drv.bus = &pcmcia_bus_type;\r\ndriver->drv.owner = driver->owner;\r\ndriver->drv.name = driver->name;\r\nmutex_init(&driver->dynids.lock);\r\nINIT_LIST_HEAD(&driver->dynids.list);\r\npr_debug("registering driver %s\n", driver->name);\r\nerror = driver_register(&driver->drv);\r\nif (error < 0)\r\nreturn error;\r\nerror = pcmcia_create_newid_file(driver);\r\nif (error)\r\ndriver_unregister(&driver->drv);\r\nreturn error;\r\n}\r\nvoid pcmcia_unregister_driver(struct pcmcia_driver *driver)\r\n{\r\npr_debug("unregistering driver %s\n", driver->name);\r\npcmcia_remove_newid_file(driver);\r\ndriver_unregister(&driver->drv);\r\npcmcia_free_dynids(driver);\r\n}\r\nstatic struct pcmcia_device *pcmcia_get_dev(struct pcmcia_device *p_dev)\r\n{\r\nstruct device *tmp_dev;\r\ntmp_dev = get_device(&p_dev->dev);\r\nif (!tmp_dev)\r\nreturn NULL;\r\nreturn to_pcmcia_dev(tmp_dev);\r\n}\r\nstatic void pcmcia_put_dev(struct pcmcia_device *p_dev)\r\n{\r\nif (p_dev)\r\nput_device(&p_dev->dev);\r\n}\r\nstatic void pcmcia_release_function(struct kref *ref)\r\n{\r\nstruct config_t *c = container_of(ref, struct config_t, ref);\r\npr_debug("releasing config_t\n");\r\nkfree(c);\r\n}\r\nstatic void pcmcia_release_dev(struct device *dev)\r\n{\r\nstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\r\nint i;\r\ndev_dbg(dev, "releasing device\n");\r\npcmcia_put_socket(p_dev->socket);\r\nfor (i = 0; i < 4; i++)\r\nkfree(p_dev->prod_id[i]);\r\nkfree(p_dev->devname);\r\nkref_put(&p_dev->function_config->ref, pcmcia_release_function);\r\nkfree(p_dev);\r\n}\r\nstatic int pcmcia_device_probe(struct device *dev)\r\n{\r\nstruct pcmcia_device *p_dev;\r\nstruct pcmcia_driver *p_drv;\r\nstruct pcmcia_socket *s;\r\ncistpl_config_t cis_config;\r\nint ret = 0;\r\ndev = get_device(dev);\r\nif (!dev)\r\nreturn -ENODEV;\r\np_dev = to_pcmcia_dev(dev);\r\np_drv = to_pcmcia_drv(dev->driver);\r\ns = p_dev->socket;\r\ndev_dbg(dev, "trying to bind to %s\n", p_drv->name);\r\nif ((!p_drv->probe) || (!p_dev->function_config) ||\r\n(!try_module_get(p_drv->owner))) {\r\nret = -EINVAL;\r\ngoto put_dev;\r\n}\r\nret = pccard_read_tuple(p_dev->socket, p_dev->func, CISTPL_CONFIG,\r\n&cis_config);\r\nif (!ret) {\r\np_dev->config_base = cis_config.base;\r\np_dev->config_regs = cis_config.rmask[0];\r\ndev_dbg(dev, "base %x, regs %x", p_dev->config_base,\r\np_dev->config_regs);\r\n} else {\r\ndev_printk(KERN_INFO, dev,\r\n"pcmcia: could not parse base and rmask0 of CIS\n");\r\np_dev->config_base = 0;\r\np_dev->config_regs = 0;\r\n}\r\nret = p_drv->probe(p_dev);\r\nif (ret) {\r\ndev_dbg(dev, "binding to %s failed with %d\n",\r\np_drv->name, ret);\r\ngoto put_module;\r\n}\r\ndev_dbg(dev, "%s bound: Vpp %d.%d, idx %x, IRQ %d", p_drv->name,\r\np_dev->vpp/10, p_dev->vpp%10, p_dev->config_index, p_dev->irq);\r\ndev_dbg(dev, "resources: ioport %pR %pR iomem %pR %pR %pR",\r\np_dev->resource[0], p_dev->resource[1], p_dev->resource[2],\r\np_dev->resource[3], p_dev->resource[4]);\r\nmutex_lock(&s->ops_mutex);\r\nif ((s->pcmcia_pfc) &&\r\n(p_dev->socket->device_count == 1) && (p_dev->device_no == 0))\r\npcmcia_parse_uevents(s, PCMCIA_UEVENT_REQUERY);\r\nmutex_unlock(&s->ops_mutex);\r\nput_module:\r\nif (ret)\r\nmodule_put(p_drv->owner);\r\nput_dev:\r\nif (ret)\r\nput_device(dev);\r\nreturn ret;\r\n}\r\nstatic void pcmcia_card_remove(struct pcmcia_socket *s, struct pcmcia_device *leftover)\r\n{\r\nstruct pcmcia_device *p_dev;\r\nstruct pcmcia_device *tmp;\r\ndev_dbg(leftover ? &leftover->dev : &s->dev,\r\n"pcmcia_card_remove(%d) %s\n", s->sock,\r\nleftover ? leftover->devname : "");\r\nmutex_lock(&s->ops_mutex);\r\nif (!leftover)\r\ns->device_count = 0;\r\nelse\r\ns->device_count = 1;\r\nmutex_unlock(&s->ops_mutex);\r\nlist_for_each_entry_safe(p_dev, tmp, &s->devices_list, socket_device_list) {\r\nif (p_dev == leftover)\r\ncontinue;\r\nmutex_lock(&s->ops_mutex);\r\nlist_del(&p_dev->socket_device_list);\r\nmutex_unlock(&s->ops_mutex);\r\ndev_dbg(&p_dev->dev, "unregistering device\n");\r\ndevice_unregister(&p_dev->dev);\r\n}\r\nreturn;\r\n}\r\nstatic int pcmcia_device_remove(struct device *dev)\r\n{\r\nstruct pcmcia_device *p_dev;\r\nstruct pcmcia_driver *p_drv;\r\nint i;\r\np_dev = to_pcmcia_dev(dev);\r\np_drv = to_pcmcia_drv(dev->driver);\r\ndev_dbg(dev, "removing device\n");\r\nif ((p_dev->socket->pcmcia_pfc) &&\r\n(p_dev->socket->device_count > 0) &&\r\n(p_dev->device_no == 0))\r\npcmcia_card_remove(p_dev->socket, p_dev);\r\nif (!p_drv)\r\nreturn 0;\r\nif (p_drv->remove)\r\np_drv->remove(p_dev);\r\nif (p_dev->_irq || p_dev->_io || p_dev->_locked)\r\ndev_printk(KERN_INFO, dev,\r\n"pcmcia: driver %s did not release config properly\n",\r\np_drv->name);\r\nfor (i = 0; i < MAX_WIN; i++)\r\nif (p_dev->_win & CLIENT_WIN_REQ(i))\r\ndev_printk(KERN_INFO, dev,\r\n"pcmcia: driver %s did not release window properly\n",\r\np_drv->name);\r\npcmcia_put_dev(p_dev);\r\nmodule_put(p_drv->owner);\r\nreturn 0;\r\n}\r\nstatic int pcmcia_device_query(struct pcmcia_device *p_dev)\r\n{\r\ncistpl_manfid_t manf_id;\r\ncistpl_funcid_t func_id;\r\ncistpl_vers_1_t *vers1;\r\nunsigned int i;\r\nvers1 = kmalloc(sizeof(*vers1), GFP_KERNEL);\r\nif (!vers1)\r\nreturn -ENOMEM;\r\nif (!pccard_read_tuple(p_dev->socket, BIND_FN_ALL,\r\nCISTPL_MANFID, &manf_id)) {\r\nmutex_lock(&p_dev->socket->ops_mutex);\r\np_dev->manf_id = manf_id.manf;\r\np_dev->card_id = manf_id.card;\r\np_dev->has_manf_id = 1;\r\np_dev->has_card_id = 1;\r\nmutex_unlock(&p_dev->socket->ops_mutex);\r\n}\r\nif (!pccard_read_tuple(p_dev->socket, p_dev->func,\r\nCISTPL_FUNCID, &func_id)) {\r\nmutex_lock(&p_dev->socket->ops_mutex);\r\np_dev->func_id = func_id.func;\r\np_dev->has_func_id = 1;\r\nmutex_unlock(&p_dev->socket->ops_mutex);\r\n} else {\r\ncistpl_device_geo_t *devgeo;\r\ndevgeo = kmalloc(sizeof(*devgeo), GFP_KERNEL);\r\nif (!devgeo) {\r\nkfree(vers1);\r\nreturn -ENOMEM;\r\n}\r\nif (!pccard_read_tuple(p_dev->socket, p_dev->func,\r\nCISTPL_DEVICE_GEO, devgeo)) {\r\ndev_dbg(&p_dev->dev,\r\n"mem device geometry probably means "\r\n"FUNCID_MEMORY\n");\r\nmutex_lock(&p_dev->socket->ops_mutex);\r\np_dev->func_id = CISTPL_FUNCID_MEMORY;\r\np_dev->has_func_id = 1;\r\nmutex_unlock(&p_dev->socket->ops_mutex);\r\n}\r\nkfree(devgeo);\r\n}\r\nif (!pccard_read_tuple(p_dev->socket, BIND_FN_ALL, CISTPL_VERS_1,\r\nvers1)) {\r\nmutex_lock(&p_dev->socket->ops_mutex);\r\nfor (i = 0; i < min_t(unsigned int, 4, vers1->ns); i++) {\r\nchar *tmp;\r\nunsigned int length;\r\nchar *new;\r\ntmp = vers1->str + vers1->ofs[i];\r\nlength = strlen(tmp) + 1;\r\nif ((length < 2) || (length > 255))\r\ncontinue;\r\nnew = kmalloc(sizeof(char) * length, GFP_KERNEL);\r\nif (!new)\r\ncontinue;\r\nnew = strncpy(new, tmp, length);\r\ntmp = p_dev->prod_id[i];\r\np_dev->prod_id[i] = new;\r\nkfree(tmp);\r\n}\r\nmutex_unlock(&p_dev->socket->ops_mutex);\r\n}\r\nkfree(vers1);\r\nreturn 0;\r\n}\r\nstatic struct pcmcia_device *pcmcia_device_add(struct pcmcia_socket *s,\r\nunsigned int function)\r\n{\r\nstruct pcmcia_device *p_dev, *tmp_dev;\r\nint i;\r\ns = pcmcia_get_socket(s);\r\nif (!s)\r\nreturn NULL;\r\npr_debug("adding device to %d, function %d\n", s->sock, function);\r\np_dev = kzalloc(sizeof(struct pcmcia_device), GFP_KERNEL);\r\nif (!p_dev)\r\ngoto err_put;\r\nmutex_lock(&s->ops_mutex);\r\np_dev->device_no = (s->device_count++);\r\nmutex_unlock(&s->ops_mutex);\r\nif ((p_dev->device_no >= 2) && (function == 0))\r\ngoto err_free;\r\nif (p_dev->device_no >= 4)\r\ngoto err_free;\r\np_dev->socket = s;\r\np_dev->func = function;\r\np_dev->dev.bus = &pcmcia_bus_type;\r\np_dev->dev.parent = s->dev.parent;\r\np_dev->dev.release = pcmcia_release_dev;\r\np_dev->dma_mask = DMA_MASK_NONE;\r\np_dev->dev.dma_mask = &p_dev->dma_mask;\r\ndev_set_name(&p_dev->dev, "%d.%d", p_dev->socket->sock, p_dev->device_no);\r\nif (!dev_name(&p_dev->dev))\r\ngoto err_free;\r\np_dev->devname = kasprintf(GFP_KERNEL, "pcmcia%s", dev_name(&p_dev->dev));\r\nif (!p_dev->devname)\r\ngoto err_free;\r\ndev_dbg(&p_dev->dev, "devname is %s\n", p_dev->devname);\r\nmutex_lock(&s->ops_mutex);\r\nlist_for_each_entry(tmp_dev, &s->devices_list, socket_device_list)\r\nif (p_dev->func == tmp_dev->func) {\r\np_dev->function_config = tmp_dev->function_config;\r\np_dev->irq = tmp_dev->irq;\r\nkref_get(&p_dev->function_config->ref);\r\n}\r\nlist_add(&p_dev->socket_device_list, &s->devices_list);\r\nif (pcmcia_setup_irq(p_dev))\r\ndev_warn(&p_dev->dev,\r\n"IRQ setup failed -- device might not work\n");\r\nif (!p_dev->function_config) {\r\nconfig_t *c;\r\ndev_dbg(&p_dev->dev, "creating config_t\n");\r\nc = kzalloc(sizeof(struct config_t), GFP_KERNEL);\r\nif (!c) {\r\nmutex_unlock(&s->ops_mutex);\r\ngoto err_unreg;\r\n}\r\np_dev->function_config = c;\r\nkref_init(&c->ref);\r\nfor (i = 0; i < MAX_IO_WIN; i++) {\r\nc->io[i].name = p_dev->devname;\r\nc->io[i].flags = IORESOURCE_IO;\r\n}\r\nfor (i = 0; i< MAX_WIN; i++) {\r\nc->mem[i].name = p_dev->devname;\r\nc->mem[i].flags = IORESOURCE_MEM;\r\n}\r\n}\r\nfor (i = 0; i < MAX_IO_WIN; i++)\r\np_dev->resource[i] = &p_dev->function_config->io[i];\r\nfor (; i < (MAX_IO_WIN + MAX_WIN); i++)\r\np_dev->resource[i] = &p_dev->function_config->mem[i-MAX_IO_WIN];\r\nmutex_unlock(&s->ops_mutex);\r\ndev_printk(KERN_NOTICE, &p_dev->dev,\r\n"pcmcia: registering new device %s (IRQ: %d)\n",\r\np_dev->devname, p_dev->irq);\r\npcmcia_device_query(p_dev);\r\nif (device_register(&p_dev->dev))\r\ngoto err_unreg;\r\nreturn p_dev;\r\nerr_unreg:\r\nmutex_lock(&s->ops_mutex);\r\nlist_del(&p_dev->socket_device_list);\r\nmutex_unlock(&s->ops_mutex);\r\nerr_free:\r\nmutex_lock(&s->ops_mutex);\r\ns->device_count--;\r\nmutex_unlock(&s->ops_mutex);\r\nfor (i = 0; i < 4; i++)\r\nkfree(p_dev->prod_id[i]);\r\nkfree(p_dev->devname);\r\nkfree(p_dev);\r\nerr_put:\r\npcmcia_put_socket(s);\r\nreturn NULL;\r\n}\r\nstatic int pcmcia_card_add(struct pcmcia_socket *s)\r\n{\r\ncistpl_longlink_mfc_t mfc;\r\nunsigned int no_funcs, i, no_chains;\r\nint ret = -EAGAIN;\r\nmutex_lock(&s->ops_mutex);\r\nif (!(s->resource_setup_done)) {\r\ndev_dbg(&s->dev,\r\n"no resources available, delaying card_add\n");\r\nmutex_unlock(&s->ops_mutex);\r\nreturn -EAGAIN;\r\n}\r\nif (pcmcia_validate_mem(s)) {\r\ndev_dbg(&s->dev, "validating mem resources failed, "\r\n"delaying card_add\n");\r\nmutex_unlock(&s->ops_mutex);\r\nreturn -EAGAIN;\r\n}\r\nmutex_unlock(&s->ops_mutex);\r\nret = pccard_validate_cis(s, &no_chains);\r\nif (ret || !no_chains) {\r\ndev_dbg(&s->dev, "invalid CIS or invalid resources\n");\r\nreturn -ENODEV;\r\n}\r\nif (!pccard_read_tuple(s, BIND_FN_ALL, CISTPL_LONGLINK_MFC, &mfc))\r\nno_funcs = mfc.nfn;\r\nelse\r\nno_funcs = 1;\r\ns->functions = no_funcs;\r\nfor (i = 0; i < no_funcs; i++)\r\npcmcia_device_add(s, i);\r\nreturn ret;\r\n}\r\nstatic int pcmcia_requery_callback(struct device *dev, void * _data)\r\n{\r\nstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\r\nif (!p_dev->dev.driver) {\r\ndev_dbg(dev, "update device information\n");\r\npcmcia_device_query(p_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcmcia_requery(struct pcmcia_socket *s)\r\n{\r\nint has_pfc;\r\nif (s->functions == 0) {\r\npcmcia_card_add(s);\r\nreturn;\r\n}\r\nbus_for_each_dev(&pcmcia_bus_type, NULL, NULL, pcmcia_requery_callback);\r\nif (s->fake_cis) {\r\nint old_funcs, new_funcs;\r\ncistpl_longlink_mfc_t mfc;\r\nold_funcs = s->functions;\r\nif (!pccard_read_tuple(s, BIND_FN_ALL, CISTPL_LONGLINK_MFC,\r\n&mfc))\r\nnew_funcs = mfc.nfn;\r\nelse\r\nnew_funcs = 1;\r\nif (old_funcs != new_funcs) {\r\npcmcia_card_remove(s, NULL);\r\ns->functions = 0;\r\npcmcia_card_add(s);\r\n}\r\n}\r\nmutex_lock(&s->ops_mutex);\r\nhas_pfc = s->pcmcia_pfc;\r\nmutex_unlock(&s->ops_mutex);\r\nif (has_pfc)\r\npcmcia_device_add(s, 0);\r\nif (bus_rescan_devices(&pcmcia_bus_type))\r\ndev_warn(&s->dev, "rescanning the bus failed\n");\r\n}\r\nstatic int pcmcia_load_firmware(struct pcmcia_device *dev, char * filename)\r\n{\r\nstruct pcmcia_socket *s = dev->socket;\r\nconst struct firmware *fw;\r\nint ret = -ENOMEM;\r\ncistpl_longlink_mfc_t mfc;\r\nint old_funcs, new_funcs = 1;\r\nif (!filename)\r\nreturn -EINVAL;\r\ndev_dbg(&dev->dev, "trying to load CIS file %s\n", filename);\r\nif (request_firmware(&fw, filename, &dev->dev) == 0) {\r\nif (fw->size >= CISTPL_MAX_CIS_SIZE) {\r\nret = -EINVAL;\r\ndev_printk(KERN_ERR, &dev->dev,\r\n"pcmcia: CIS override is too big\n");\r\ngoto release;\r\n}\r\nif (!pcmcia_replace_cis(s, fw->data, fw->size))\r\nret = 0;\r\nelse {\r\ndev_printk(KERN_ERR, &dev->dev,\r\n"pcmcia: CIS override failed\n");\r\ngoto release;\r\n}\r\nold_funcs = s->functions;\r\nif (!pccard_read_tuple(s, BIND_FN_ALL, CISTPL_LONGLINK_MFC,\r\n&mfc))\r\nnew_funcs = mfc.nfn;\r\nif (old_funcs != new_funcs)\r\nret = -EBUSY;\r\npcmcia_device_query(dev);\r\npcmcia_parse_uevents(s, PCMCIA_UEVENT_REQUERY);\r\n}\r\nrelease:\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic inline int pcmcia_load_firmware(struct pcmcia_device *dev, char * filename)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic inline int pcmcia_devmatch(struct pcmcia_device *dev,\r\nconst struct pcmcia_device_id *did)\r\n{\r\nif (did->match_flags & PCMCIA_DEV_ID_MATCH_MANF_ID) {\r\nif ((!dev->has_manf_id) || (dev->manf_id != did->manf_id))\r\nreturn 0;\r\n}\r\nif (did->match_flags & PCMCIA_DEV_ID_MATCH_CARD_ID) {\r\nif ((!dev->has_card_id) || (dev->card_id != did->card_id))\r\nreturn 0;\r\n}\r\nif (did->match_flags & PCMCIA_DEV_ID_MATCH_FUNCTION) {\r\nif (dev->func != did->function)\r\nreturn 0;\r\n}\r\nif (did->match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID1) {\r\nif (!dev->prod_id[0])\r\nreturn 0;\r\nif (strcmp(did->prod_id[0], dev->prod_id[0]))\r\nreturn 0;\r\n}\r\nif (did->match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID2) {\r\nif (!dev->prod_id[1])\r\nreturn 0;\r\nif (strcmp(did->prod_id[1], dev->prod_id[1]))\r\nreturn 0;\r\n}\r\nif (did->match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID3) {\r\nif (!dev->prod_id[2])\r\nreturn 0;\r\nif (strcmp(did->prod_id[2], dev->prod_id[2]))\r\nreturn 0;\r\n}\r\nif (did->match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID4) {\r\nif (!dev->prod_id[3])\r\nreturn 0;\r\nif (strcmp(did->prod_id[3], dev->prod_id[3]))\r\nreturn 0;\r\n}\r\nif (did->match_flags & PCMCIA_DEV_ID_MATCH_DEVICE_NO) {\r\ndev_dbg(&dev->dev, "this is a pseudo-multi-function device\n");\r\nmutex_lock(&dev->socket->ops_mutex);\r\ndev->socket->pcmcia_pfc = 1;\r\nmutex_unlock(&dev->socket->ops_mutex);\r\nif (dev->device_no != did->device_no)\r\nreturn 0;\r\n}\r\nif (did->match_flags & PCMCIA_DEV_ID_MATCH_FUNC_ID) {\r\nint ret;\r\nif ((!dev->has_func_id) || (dev->func_id != did->func_id))\r\nreturn 0;\r\nif (dev->socket->pcmcia_pfc)\r\nreturn 0;\r\nif (dev->device_no)\r\nreturn 0;\r\nmutex_lock(&dev->socket->ops_mutex);\r\nret = dev->allow_func_id_match;\r\nmutex_unlock(&dev->socket->ops_mutex);\r\nif (!ret) {\r\ndev_dbg(&dev->dev,\r\n"skipping FUNC_ID match until userspace ACK\n");\r\nreturn 0;\r\n}\r\n}\r\nif (did->match_flags & PCMCIA_DEV_ID_MATCH_FAKE_CIS) {\r\ndev_dbg(&dev->dev, "device needs a fake CIS\n");\r\nif (!dev->socket->fake_cis)\r\nif (pcmcia_load_firmware(dev, did->cisfile))\r\nreturn 0;\r\n}\r\nif (did->match_flags & PCMCIA_DEV_ID_MATCH_ANONYMOUS) {\r\nint i;\r\nfor (i = 0; i < 4; i++)\r\nif (dev->prod_id[i])\r\nreturn 0;\r\nif (dev->has_manf_id || dev->has_card_id || dev->has_func_id)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int pcmcia_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\r\nstruct pcmcia_driver *p_drv = to_pcmcia_drv(drv);\r\nconst struct pcmcia_device_id *did = p_drv->id_table;\r\nstruct pcmcia_dynid *dynid;\r\nmutex_lock(&p_drv->dynids.lock);\r\nlist_for_each_entry(dynid, &p_drv->dynids.list, node) {\r\ndev_dbg(dev, "trying to match to %s\n", drv->name);\r\nif (pcmcia_devmatch(p_dev, &dynid->id)) {\r\ndev_dbg(dev, "matched to %s\n", drv->name);\r\nmutex_unlock(&p_drv->dynids.lock);\r\nreturn 1;\r\n}\r\n}\r\nmutex_unlock(&p_drv->dynids.lock);\r\nwhile (did && did->match_flags) {\r\ndev_dbg(dev, "trying to match to %s\n", drv->name);\r\nif (pcmcia_devmatch(p_dev, did)) {\r\ndev_dbg(dev, "matched to %s\n", drv->name);\r\nreturn 1;\r\n}\r\ndid++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcmcia_bus_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct pcmcia_device *p_dev;\r\nint i;\r\nu32 hash[4] = { 0, 0, 0, 0};\r\nif (!dev)\r\nreturn -ENODEV;\r\np_dev = to_pcmcia_dev(dev);\r\nfor (i = 0; i < 4; i++) {\r\nif (!p_dev->prod_id[i])\r\ncontinue;\r\nhash[i] = crc32(0, p_dev->prod_id[i], strlen(p_dev->prod_id[i]));\r\n}\r\nif (add_uevent_var(env, "SOCKET_NO=%u", p_dev->socket->sock))\r\nreturn -ENOMEM;\r\nif (add_uevent_var(env, "DEVICE_NO=%02X", p_dev->device_no))\r\nreturn -ENOMEM;\r\nif (add_uevent_var(env, "MODALIAS=pcmcia:m%04Xc%04Xf%02Xfn%02Xpfn%02X"\r\n"pa%08Xpb%08Xpc%08Xpd%08X",\r\np_dev->has_manf_id ? p_dev->manf_id : 0,\r\np_dev->has_card_id ? p_dev->card_id : 0,\r\np_dev->has_func_id ? p_dev->func_id : 0,\r\np_dev->func,\r\np_dev->device_no,\r\nhash[0],\r\nhash[1],\r\nhash[2],\r\nhash[3]))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int runtime_suspend(struct device *dev)\r\n{\r\nint rc;\r\ndevice_lock(dev);\r\nrc = pcmcia_dev_suspend(dev, PMSG_SUSPEND);\r\ndevice_unlock(dev);\r\nreturn rc;\r\n}\r\nstatic int runtime_resume(struct device *dev)\r\n{\r\nint rc;\r\ndevice_lock(dev);\r\nrc = pcmcia_dev_resume(dev);\r\ndevice_unlock(dev);\r\nreturn rc;\r\n}\r\nstatic ssize_t pcmcia_show_resources(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\r\nchar *str = buf;\r\nint i;\r\nfor (i = 0; i < PCMCIA_NUM_RESOURCES; i++)\r\nstr += sprintf(str, "%pr\n", p_dev->resource[i]);\r\nreturn str - buf;\r\n}\r\nstatic ssize_t pcmcia_show_pm_state(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\r\nif (p_dev->suspended)\r\nreturn sprintf(buf, "off\n");\r\nelse\r\nreturn sprintf(buf, "on\n");\r\n}\r\nstatic ssize_t pcmcia_store_pm_state(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\r\nint ret = 0;\r\nif (!count)\r\nreturn -EINVAL;\r\nif ((!p_dev->suspended) && !strncmp(buf, "off", 3))\r\nret = runtime_suspend(dev);\r\nelse if (p_dev->suspended && !strncmp(buf, "on", 2))\r\nret = runtime_resume(dev);\r\nreturn ret ? ret : count;\r\n}\r\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\r\nint i;\r\nu32 hash[4] = { 0, 0, 0, 0};\r\nfor (i = 0; i < 4; i++) {\r\nif (!p_dev->prod_id[i])\r\ncontinue;\r\nhash[i] = crc32(0, p_dev->prod_id[i],\r\nstrlen(p_dev->prod_id[i]));\r\n}\r\nreturn sprintf(buf, "pcmcia:m%04Xc%04Xf%02Xfn%02Xpfn%02X"\r\n"pa%08Xpb%08Xpc%08Xpd%08X\n",\r\np_dev->has_manf_id ? p_dev->manf_id : 0,\r\np_dev->has_card_id ? p_dev->card_id : 0,\r\np_dev->has_func_id ? p_dev->func_id : 0,\r\np_dev->func, p_dev->device_no,\r\nhash[0], hash[1], hash[2], hash[3]);\r\n}\r\nstatic ssize_t pcmcia_store_allow_func_id_match(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\r\nif (!count)\r\nreturn -EINVAL;\r\nmutex_lock(&p_dev->socket->ops_mutex);\r\np_dev->allow_func_id_match = 1;\r\nmutex_unlock(&p_dev->socket->ops_mutex);\r\npcmcia_parse_uevents(p_dev->socket, PCMCIA_UEVENT_REQUERY);\r\nreturn count;\r\n}\r\nstatic int pcmcia_dev_suspend(struct device *dev, pm_message_t state)\r\n{\r\nstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\r\nstruct pcmcia_driver *p_drv = NULL;\r\nint ret = 0;\r\nmutex_lock(&p_dev->socket->ops_mutex);\r\nif (p_dev->suspended) {\r\nmutex_unlock(&p_dev->socket->ops_mutex);\r\nreturn 0;\r\n}\r\np_dev->suspended = 1;\r\nmutex_unlock(&p_dev->socket->ops_mutex);\r\ndev_dbg(dev, "suspending\n");\r\nif (dev->driver)\r\np_drv = to_pcmcia_drv(dev->driver);\r\nif (!p_drv)\r\ngoto out;\r\nif (p_drv->suspend) {\r\nret = p_drv->suspend(p_dev);\r\nif (ret) {\r\ndev_printk(KERN_ERR, dev,\r\n"pcmcia: device %s (driver %s) did "\r\n"not want to go to sleep (%d)\n",\r\np_dev->devname, p_drv->name, ret);\r\nmutex_lock(&p_dev->socket->ops_mutex);\r\np_dev->suspended = 0;\r\nmutex_unlock(&p_dev->socket->ops_mutex);\r\ngoto out;\r\n}\r\n}\r\nif (p_dev->device_no == p_dev->func) {\r\ndev_dbg(dev, "releasing configuration\n");\r\npcmcia_release_configuration(p_dev);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int pcmcia_dev_resume(struct device *dev)\r\n{\r\nstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\r\nstruct pcmcia_driver *p_drv = NULL;\r\nint ret = 0;\r\nmutex_lock(&p_dev->socket->ops_mutex);\r\nif (!p_dev->suspended) {\r\nmutex_unlock(&p_dev->socket->ops_mutex);\r\nreturn 0;\r\n}\r\np_dev->suspended = 0;\r\nmutex_unlock(&p_dev->socket->ops_mutex);\r\ndev_dbg(dev, "resuming\n");\r\nif (dev->driver)\r\np_drv = to_pcmcia_drv(dev->driver);\r\nif (!p_drv)\r\ngoto out;\r\nif (p_dev->device_no == p_dev->func) {\r\ndev_dbg(dev, "requesting configuration\n");\r\nret = pcmcia_enable_device(p_dev);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (p_drv->resume)\r\nret = p_drv->resume(p_dev);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int pcmcia_bus_suspend_callback(struct device *dev, void * _data)\r\n{\r\nstruct pcmcia_socket *skt = _data;\r\nstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\r\nif (p_dev->socket != skt || p_dev->suspended)\r\nreturn 0;\r\nreturn runtime_suspend(dev);\r\n}\r\nstatic int pcmcia_bus_resume_callback(struct device *dev, void * _data)\r\n{\r\nstruct pcmcia_socket *skt = _data;\r\nstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\r\nif (p_dev->socket != skt || !p_dev->suspended)\r\nreturn 0;\r\nruntime_resume(dev);\r\nreturn 0;\r\n}\r\nstatic int pcmcia_bus_resume(struct pcmcia_socket *skt)\r\n{\r\ndev_dbg(&skt->dev, "resuming socket %d\n", skt->sock);\r\nbus_for_each_dev(&pcmcia_bus_type, NULL, skt, pcmcia_bus_resume_callback);\r\nreturn 0;\r\n}\r\nstatic int pcmcia_bus_suspend(struct pcmcia_socket *skt)\r\n{\r\ndev_dbg(&skt->dev, "suspending socket %d\n", skt->sock);\r\nif (bus_for_each_dev(&pcmcia_bus_type, NULL, skt,\r\npcmcia_bus_suspend_callback)) {\r\npcmcia_bus_resume(skt);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcmcia_bus_remove(struct pcmcia_socket *skt)\r\n{\r\natomic_set(&skt->present, 0);\r\npcmcia_card_remove(skt, NULL);\r\nmutex_lock(&skt->ops_mutex);\r\ndestroy_cis_cache(skt);\r\npcmcia_cleanup_irq(skt);\r\nmutex_unlock(&skt->ops_mutex);\r\nreturn 0;\r\n}\r\nstatic int pcmcia_bus_add(struct pcmcia_socket *skt)\r\n{\r\natomic_set(&skt->present, 1);\r\nmutex_lock(&skt->ops_mutex);\r\nskt->pcmcia_pfc = 0;\r\ndestroy_cis_cache(skt);\r\nmutex_unlock(&skt->ops_mutex);\r\npcmcia_card_add(skt);\r\nreturn 0;\r\n}\r\nstatic int pcmcia_bus_early_resume(struct pcmcia_socket *skt)\r\n{\r\nif (!verify_cis_cache(skt))\r\nreturn 0;\r\ndev_dbg(&skt->dev, "cis mismatch - different card\n");\r\npcmcia_bus_remove(skt);\r\nmutex_lock(&skt->ops_mutex);\r\ndestroy_cis_cache(skt);\r\nkfree(skt->fake_cis);\r\nskt->fake_cis = NULL;\r\nskt->functions = 0;\r\nmutex_unlock(&skt->ops_mutex);\r\npcmcia_bus_add(skt);\r\nreturn 0;\r\n}\r\nstruct pcmcia_device *pcmcia_dev_present(struct pcmcia_device *_p_dev)\r\n{\r\nstruct pcmcia_device *p_dev;\r\nstruct pcmcia_device *ret = NULL;\r\np_dev = pcmcia_get_dev(_p_dev);\r\nif (!p_dev)\r\nreturn NULL;\r\nif (atomic_read(&p_dev->socket->present) != 0)\r\nret = p_dev;\r\npcmcia_put_dev(p_dev);\r\nreturn ret;\r\n}\r\nstatic int pcmcia_bus_add_socket(struct device *dev,\r\nstruct class_interface *class_intf)\r\n{\r\nstruct pcmcia_socket *socket = dev_get_drvdata(dev);\r\nint ret;\r\nsocket = pcmcia_get_socket(socket);\r\nif (!socket) {\r\ndev_printk(KERN_ERR, dev,\r\n"PCMCIA obtaining reference to socket failed\n");\r\nreturn -ENODEV;\r\n}\r\nret = sysfs_create_bin_file(&dev->kobj, &pccard_cis_attr);\r\nif (ret) {\r\ndev_printk(KERN_ERR, dev, "PCMCIA registration failed\n");\r\npcmcia_put_socket(socket);\r\nreturn ret;\r\n}\r\nINIT_LIST_HEAD(&socket->devices_list);\r\nsocket->pcmcia_pfc = 0;\r\nsocket->device_count = 0;\r\natomic_set(&socket->present, 0);\r\nret = pccard_register_pcmcia(socket, &pcmcia_bus_callback);\r\nif (ret) {\r\ndev_printk(KERN_ERR, dev, "PCMCIA registration failed\n");\r\npcmcia_put_socket(socket);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcmcia_bus_remove_socket(struct device *dev,\r\nstruct class_interface *class_intf)\r\n{\r\nstruct pcmcia_socket *socket = dev_get_drvdata(dev);\r\nif (!socket)\r\nreturn;\r\npccard_register_pcmcia(socket, NULL);\r\nmutex_lock(&socket->skt_mutex);\r\npcmcia_card_remove(socket, NULL);\r\nrelease_cis_mem(socket);\r\nmutex_unlock(&socket->skt_mutex);\r\nsysfs_remove_bin_file(&dev->kobj, &pccard_cis_attr);\r\npcmcia_put_socket(socket);\r\nreturn;\r\n}\r\nstatic int __init init_pcmcia_bus(void)\r\n{\r\nint ret;\r\nret = bus_register(&pcmcia_bus_type);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "pcmcia: bus_register error: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = class_interface_register(&pcmcia_bus_interface);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING\r\n"pcmcia: class_interface_register error: %d\n", ret);\r\nbus_unregister(&pcmcia_bus_type);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit exit_pcmcia_bus(void)\r\n{\r\nclass_interface_unregister(&pcmcia_bus_interface);\r\nbus_unregister(&pcmcia_bus_type);\r\n}
