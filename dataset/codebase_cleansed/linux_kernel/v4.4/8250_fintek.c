static int fintek_8250_enter_key(u16 base_port, u8 key)\r\n{\r\nif (!request_muxed_region(base_port, 2, DRIVER_NAME))\r\nreturn -EBUSY;\r\noutb(key, base_port + ADDR_PORT);\r\noutb(key, base_port + ADDR_PORT);\r\nreturn 0;\r\n}\r\nstatic void fintek_8250_exit_key(u16 base_port)\r\n{\r\noutb(EXIT_KEY, base_port + ADDR_PORT);\r\nrelease_region(base_port + ADDR_PORT, 2);\r\n}\r\nstatic int fintek_8250_check_id(u16 base_port)\r\n{\r\nu16 chip;\r\noutb(VENDOR_ID1, base_port + ADDR_PORT);\r\nif (inb(base_port + DATA_PORT) != VENDOR_ID1_VAL)\r\nreturn -ENODEV;\r\noutb(VENDOR_ID2, base_port + ADDR_PORT);\r\nif (inb(base_port + DATA_PORT) != VENDOR_ID2_VAL)\r\nreturn -ENODEV;\r\noutb(CHIP_ID1, base_port + ADDR_PORT);\r\nchip = inb(base_port + DATA_PORT);\r\noutb(CHIP_ID2, base_port + ADDR_PORT);\r\nchip |= inb(base_port + DATA_PORT) << 8;\r\nif (chip != CHIP_ID_0 && chip != CHIP_ID_1)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int fintek_8250_rs485_config(struct uart_port *port,\r\nstruct serial_rs485 *rs485)\r\n{\r\nuint8_t config = 0;\r\nstruct fintek_8250 *pdata = port->private_data;\r\nif (!pdata)\r\nreturn -EINVAL;\r\nif (rs485->flags & SER_RS485_ENABLED)\r\nmemset(rs485->padding, 0, sizeof(rs485->padding));\r\nelse\r\nmemset(rs485, 0, sizeof(*rs485));\r\nrs485->flags &= SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND |\r\nSER_RS485_RTS_AFTER_SEND;\r\nif (rs485->delay_rts_before_send) {\r\nrs485->delay_rts_before_send = 1;\r\nconfig |= TXW4C_IRA;\r\n}\r\nif (rs485->delay_rts_after_send) {\r\nrs485->delay_rts_after_send = 1;\r\nconfig |= RXW4C_IRA;\r\n}\r\nif ((!!(rs485->flags & SER_RS485_RTS_ON_SEND)) ==\r\n(!!(rs485->flags & SER_RS485_RTS_AFTER_SEND)))\r\nrs485->flags &= SER_RS485_ENABLED;\r\nelse\r\nconfig |= RS485_URA;\r\nif (rs485->flags & SER_RS485_RTS_ON_SEND)\r\nconfig |= RTS_INVERT;\r\nif (fintek_8250_enter_key(pdata->base_port, pdata->key))\r\nreturn -EBUSY;\r\noutb(LDN, pdata->base_port + ADDR_PORT);\r\noutb(pdata->index, pdata->base_port + DATA_PORT);\r\noutb(RS485, pdata->base_port + ADDR_PORT);\r\noutb(config, pdata->base_port + DATA_PORT);\r\nfintek_8250_exit_key(pdata->base_port);\r\nport->rs485 = *rs485;\r\nreturn 0;\r\n}\r\nstatic int fintek_8250_base_port(u16 io_address, u8 *key, u8 *index)\r\n{\r\nstatic const u16 addr[] = {0x4e, 0x2e};\r\nstatic const u8 keys[] = {0x77, 0xa0, 0x87, 0x67};\r\nint i, j, k;\r\nfor (i = 0; i < ARRAY_SIZE(addr); i++) {\r\nfor (j = 0; j < ARRAY_SIZE(keys); j++) {\r\nif (fintek_8250_enter_key(addr[i], keys[j]))\r\ncontinue;\r\nif (fintek_8250_check_id(addr[i])) {\r\nfintek_8250_exit_key(addr[i]);\r\ncontinue;\r\n}\r\nfor (k = 0; k < 4; k++) {\r\nu16 aux;\r\noutb(LDN, addr[i] + ADDR_PORT);\r\noutb(k, addr[i] + DATA_PORT);\r\noutb(IO_ADDR1, addr[i] + ADDR_PORT);\r\naux = inb(addr[i] + DATA_PORT);\r\noutb(IO_ADDR2, addr[i] + ADDR_PORT);\r\naux |= inb(addr[i] + DATA_PORT) << 8;\r\nif (aux != io_address)\r\ncontinue;\r\nfintek_8250_exit_key(addr[i]);\r\n*key = keys[j];\r\n*index = k;\r\nreturn addr[i];\r\n}\r\nfintek_8250_exit_key(addr[i]);\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nfintek_8250_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)\r\n{\r\nstruct uart_8250_port uart;\r\nstruct fintek_8250 *pdata;\r\nint base_port;\r\nu8 key;\r\nu8 index;\r\nif (!pnp_port_valid(dev, 0))\r\nreturn -ENODEV;\r\nbase_port = fintek_8250_base_port(pnp_port_start(dev, 0), &key, &index);\r\nif (base_port < 0)\r\nreturn -ENODEV;\r\nmemset(&uart, 0, sizeof(uart));\r\npdata = devm_kzalloc(&dev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nuart.port.private_data = pdata;\r\nif (!pnp_irq_valid(dev, 0))\r\nreturn -ENODEV;\r\nuart.port.irq = pnp_irq(dev, 0);\r\nuart.port.iobase = pnp_port_start(dev, 0);\r\nuart.port.iotype = UPIO_PORT;\r\nuart.port.rs485_config = fintek_8250_rs485_config;\r\nuart.port.flags |= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF;\r\nif (pnp_irq_flags(dev, 0) & IORESOURCE_IRQ_SHAREABLE)\r\nuart.port.flags |= UPF_SHARE_IRQ;\r\nuart.port.uartclk = 1843200;\r\nuart.port.dev = &dev->dev;\r\npdata->key = key;\r\npdata->base_port = base_port;\r\npdata->index = index;\r\npdata->line = serial8250_register_8250_port(&uart);\r\nif (pdata->line < 0)\r\nreturn -ENODEV;\r\npnp_set_drvdata(dev, pdata);\r\nreturn 0;\r\n}\r\nstatic void fintek_8250_remove(struct pnp_dev *dev)\r\n{\r\nstruct fintek_8250 *pdata = pnp_get_drvdata(dev);\r\nif (pdata)\r\nserial8250_unregister_port(pdata->line);\r\n}\r\nstatic int fintek_8250_suspend(struct pnp_dev *dev, pm_message_t state)\r\n{\r\nstruct fintek_8250 *pdata = pnp_get_drvdata(dev);\r\nif (!pdata)\r\nreturn -ENODEV;\r\nserial8250_suspend_port(pdata->line);\r\nreturn 0;\r\n}\r\nstatic int fintek_8250_resume(struct pnp_dev *dev)\r\n{\r\nstruct fintek_8250 *pdata = pnp_get_drvdata(dev);\r\nif (!pdata)\r\nreturn -ENODEV;\r\nserial8250_resume_port(pdata->line);\r\nreturn 0;\r\n}
