static int pxa27x_keypad_matrix_key_parse_dt(struct pxa27x_keypad *keypad,\r\nstruct pxa27x_keypad_platform_data *pdata)\r\n{\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nstruct device *dev = input_dev->dev.parent;\r\nu32 rows, cols;\r\nint error;\r\nerror = matrix_keypad_parse_of_params(dev, &rows, &cols);\r\nif (error)\r\nreturn error;\r\nif (rows > MAX_MATRIX_KEY_ROWS || cols > MAX_MATRIX_KEY_COLS) {\r\ndev_err(dev, "rows or cols exceeds maximum value\n");\r\nreturn -EINVAL;\r\n}\r\npdata->matrix_key_rows = rows;\r\npdata->matrix_key_cols = cols;\r\nerror = matrix_keypad_build_keymap(NULL, NULL,\r\npdata->matrix_key_rows,\r\npdata->matrix_key_cols,\r\nkeypad->keycodes, input_dev);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic int pxa27x_keypad_direct_key_parse_dt(struct pxa27x_keypad *keypad,\r\nstruct pxa27x_keypad_platform_data *pdata)\r\n{\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nstruct device *dev = input_dev->dev.parent;\r\nstruct device_node *np = dev->of_node;\r\nconst __be16 *prop;\r\nunsigned short code;\r\nunsigned int proplen, size;\r\nint i;\r\nint error;\r\nerror = of_property_read_u32(np, "marvell,direct-key-count",\r\n&pdata->direct_key_num);\r\nif (error) {\r\nreturn error == -EINVAL ? 0 : error;\r\n}\r\nerror = of_property_read_u32(np, "marvell,direct-key-mask",\r\n&pdata->direct_key_mask);\r\nif (error) {\r\nif (error != -EINVAL)\r\nreturn error;\r\npdata->direct_key_mask = 0;\r\n}\r\npdata->direct_key_low_active = of_property_read_bool(np,\r\n"marvell,direct-key-low-active");\r\nprop = of_get_property(np, "marvell,direct-key-map", &proplen);\r\nif (!prop)\r\nreturn -EINVAL;\r\nif (proplen % sizeof(u16))\r\nreturn -EINVAL;\r\nsize = proplen / sizeof(u16);\r\nif (size > MAX_DIRECT_KEY_NUM)\r\nreturn -EINVAL;\r\nfor (i = 0; i < size; i++) {\r\ncode = be16_to_cpup(prop + i);\r\nkeypad->keycodes[MAX_MATRIX_KEY_NUM + i] = code;\r\n__set_bit(code, input_dev->keybit);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pxa27x_keypad_rotary_parse_dt(struct pxa27x_keypad *keypad,\r\nstruct pxa27x_keypad_platform_data *pdata)\r\n{\r\nconst __be32 *prop;\r\nint i, relkey_ret;\r\nunsigned int code, proplen;\r\nconst char *rotaryname[2] = {\r\n"marvell,rotary0", "marvell,rotary1"};\r\nconst char relkeyname[] = {"marvell,rotary-rel-key"};\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nstruct device *dev = input_dev->dev.parent;\r\nstruct device_node *np = dev->of_node;\r\nrelkey_ret = of_property_read_u32(np, relkeyname, &code);\r\nif (relkey_ret == 0) {\r\nunsigned short relcode;\r\nrelcode = code & 0xffff;\r\npdata->rotary0_rel_code = (code & 0xffff);\r\n__set_bit(relcode, input_dev->relbit);\r\nrelcode = code >> 16;\r\npdata->rotary1_rel_code = relcode;\r\n__set_bit(relcode, input_dev->relbit);\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nprop = of_get_property(np, rotaryname[i], &proplen);\r\nif (!prop)\r\ncontinue;\r\ncode = be32_to_cpup(prop);\r\nif ((!(code & 0xffff) || !(code >> 16)) && relkey_ret) {\r\nreturn relkey_ret;\r\n} else {\r\nunsigned int n = MAX_MATRIX_KEY_NUM + (i << 1);\r\nunsigned short keycode;\r\nkeycode = code & 0xffff;\r\nkeypad->keycodes[n] = keycode;\r\n__set_bit(keycode, input_dev->keybit);\r\nkeycode = code >> 16;\r\nkeypad->keycodes[n + 1] = keycode;\r\n__set_bit(keycode, input_dev->keybit);\r\nif (i == 0)\r\npdata->rotary0_rel_code = -1;\r\nelse\r\npdata->rotary1_rel_code = -1;\r\n}\r\nif (i == 0)\r\npdata->enable_rotary0 = 1;\r\nelse\r\npdata->enable_rotary1 = 1;\r\n}\r\nkeypad->rotary_rel_code[0] = pdata->rotary0_rel_code;\r\nkeypad->rotary_rel_code[1] = pdata->rotary1_rel_code;\r\nreturn 0;\r\n}\r\nstatic int pxa27x_keypad_build_keycode_from_dt(struct pxa27x_keypad *keypad)\r\n{\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nstruct device *dev = input_dev->dev.parent;\r\nstruct device_node *np = dev->of_node;\r\nstruct pxa27x_keypad_platform_data *pdata;\r\nint error;\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata) {\r\ndev_err(dev, "failed to allocate memory for pdata\n");\r\nreturn -ENOMEM;\r\n}\r\nerror = pxa27x_keypad_matrix_key_parse_dt(keypad, pdata);\r\nif (error) {\r\ndev_err(dev, "failed to parse matrix key\n");\r\nreturn error;\r\n}\r\nerror = pxa27x_keypad_direct_key_parse_dt(keypad, pdata);\r\nif (error) {\r\ndev_err(dev, "failed to parse direct key\n");\r\nreturn error;\r\n}\r\nerror = pxa27x_keypad_rotary_parse_dt(keypad, pdata);\r\nif (error) {\r\ndev_err(dev, "failed to parse rotary key\n");\r\nreturn error;\r\n}\r\nerror = of_property_read_u32(np, "marvell,debounce-interval",\r\n&pdata->debounce_interval);\r\nif (error) {\r\ndev_err(dev, "failed to parse debpunce-interval\n");\r\nreturn error;\r\n}\r\ninput_dev->keycodemax = ARRAY_SIZE(keypad->keycodes);\r\nkeypad->pdata = pdata;\r\nreturn 0;\r\n}\r\nstatic int pxa27x_keypad_build_keycode_from_dt(struct pxa27x_keypad *keypad)\r\n{\r\ndev_info(keypad->input_dev->dev.parent, "missing platform data\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int pxa27x_keypad_build_keycode(struct pxa27x_keypad *keypad)\r\n{\r\nconst struct pxa27x_keypad_platform_data *pdata = keypad->pdata;\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nunsigned short keycode;\r\nint i;\r\nint error;\r\nerror = matrix_keypad_build_keymap(pdata->matrix_keymap_data, NULL,\r\npdata->matrix_key_rows,\r\npdata->matrix_key_cols,\r\nkeypad->keycodes, input_dev);\r\nif (error)\r\nreturn error;\r\ninput_dev->keycodemax = ARRAY_SIZE(keypad->keycodes);\r\nfor (i = 0; i < pdata->direct_key_num; i++) {\r\nkeycode = pdata->direct_key_map[i];\r\nkeypad->keycodes[MAX_MATRIX_KEY_NUM + i] = keycode;\r\n__set_bit(keycode, input_dev->keybit);\r\n}\r\nif (pdata->enable_rotary0) {\r\nif (pdata->rotary0_up_key && pdata->rotary0_down_key) {\r\nkeycode = pdata->rotary0_up_key;\r\nkeypad->keycodes[MAX_MATRIX_KEY_NUM + 0] = keycode;\r\n__set_bit(keycode, input_dev->keybit);\r\nkeycode = pdata->rotary0_down_key;\r\nkeypad->keycodes[MAX_MATRIX_KEY_NUM + 1] = keycode;\r\n__set_bit(keycode, input_dev->keybit);\r\nkeypad->rotary_rel_code[0] = -1;\r\n} else {\r\nkeypad->rotary_rel_code[0] = pdata->rotary0_rel_code;\r\n__set_bit(pdata->rotary0_rel_code, input_dev->relbit);\r\n}\r\n}\r\nif (pdata->enable_rotary1) {\r\nif (pdata->rotary1_up_key && pdata->rotary1_down_key) {\r\nkeycode = pdata->rotary1_up_key;\r\nkeypad->keycodes[MAX_MATRIX_KEY_NUM + 2] = keycode;\r\n__set_bit(keycode, input_dev->keybit);\r\nkeycode = pdata->rotary1_down_key;\r\nkeypad->keycodes[MAX_MATRIX_KEY_NUM + 3] = keycode;\r\n__set_bit(keycode, input_dev->keybit);\r\nkeypad->rotary_rel_code[1] = -1;\r\n} else {\r\nkeypad->rotary_rel_code[1] = pdata->rotary1_rel_code;\r\n__set_bit(pdata->rotary1_rel_code, input_dev->relbit);\r\n}\r\n}\r\n__clear_bit(KEY_RESERVED, input_dev->keybit);\r\nreturn 0;\r\n}\r\nstatic void pxa27x_keypad_scan_matrix(struct pxa27x_keypad *keypad)\r\n{\r\nconst struct pxa27x_keypad_platform_data *pdata = keypad->pdata;\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nint row, col, num_keys_pressed = 0;\r\nuint32_t new_state[MAX_MATRIX_KEY_COLS];\r\nuint32_t kpas = keypad_readl(KPAS);\r\nnum_keys_pressed = KPAS_MUKP(kpas);\r\nmemset(new_state, 0, sizeof(new_state));\r\nif (num_keys_pressed == 0)\r\ngoto scan;\r\nif (num_keys_pressed == 1) {\r\ncol = KPAS_CP(kpas);\r\nrow = KPAS_RP(kpas);\r\nif (col >= pdata->matrix_key_cols ||\r\nrow >= pdata->matrix_key_rows)\r\ngoto scan;\r\nnew_state[col] = (1 << row);\r\ngoto scan;\r\n}\r\nif (num_keys_pressed > 1) {\r\nuint32_t kpasmkp0 = keypad_readl(KPASMKP0);\r\nuint32_t kpasmkp1 = keypad_readl(KPASMKP1);\r\nuint32_t kpasmkp2 = keypad_readl(KPASMKP2);\r\nuint32_t kpasmkp3 = keypad_readl(KPASMKP3);\r\nnew_state[0] = kpasmkp0 & KPASMKP_MKC_MASK;\r\nnew_state[1] = (kpasmkp0 >> 16) & KPASMKP_MKC_MASK;\r\nnew_state[2] = kpasmkp1 & KPASMKP_MKC_MASK;\r\nnew_state[3] = (kpasmkp1 >> 16) & KPASMKP_MKC_MASK;\r\nnew_state[4] = kpasmkp2 & KPASMKP_MKC_MASK;\r\nnew_state[5] = (kpasmkp2 >> 16) & KPASMKP_MKC_MASK;\r\nnew_state[6] = kpasmkp3 & KPASMKP_MKC_MASK;\r\nnew_state[7] = (kpasmkp3 >> 16) & KPASMKP_MKC_MASK;\r\n}\r\nscan:\r\nfor (col = 0; col < pdata->matrix_key_cols; col++) {\r\nuint32_t bits_changed;\r\nint code;\r\nbits_changed = keypad->matrix_key_state[col] ^ new_state[col];\r\nif (bits_changed == 0)\r\ncontinue;\r\nfor (row = 0; row < pdata->matrix_key_rows; row++) {\r\nif ((bits_changed & (1 << row)) == 0)\r\ncontinue;\r\ncode = MATRIX_SCAN_CODE(row, col, keypad->row_shift);\r\ninput_event(input_dev, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(input_dev, keypad->keycodes[code],\r\nnew_state[col] & (1 << row));\r\n}\r\n}\r\ninput_sync(input_dev);\r\nmemcpy(keypad->matrix_key_state, new_state, sizeof(new_state));\r\n}\r\nstatic inline int rotary_delta(uint32_t kprec)\r\n{\r\nif (kprec & KPREC_OF0)\r\nreturn (kprec & 0xff) + 0x7f;\r\nelse if (kprec & KPREC_UF0)\r\nreturn (kprec & 0xff) - 0x7f - 0xff;\r\nelse\r\nreturn (kprec & 0xff) - 0x7f;\r\n}\r\nstatic void report_rotary_event(struct pxa27x_keypad *keypad, int r, int delta)\r\n{\r\nstruct input_dev *dev = keypad->input_dev;\r\nif (delta == 0)\r\nreturn;\r\nif (keypad->rotary_rel_code[r] == -1) {\r\nint code = MAX_MATRIX_KEY_NUM + 2 * r + (delta > 0 ? 0 : 1);\r\nunsigned char keycode = keypad->keycodes[code];\r\ninput_event(dev, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(dev, keycode, 1);\r\ninput_sync(dev);\r\ninput_event(dev, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(dev, keycode, 0);\r\ninput_sync(dev);\r\n} else {\r\ninput_report_rel(dev, keypad->rotary_rel_code[r], delta);\r\ninput_sync(dev);\r\n}\r\n}\r\nstatic void pxa27x_keypad_scan_rotary(struct pxa27x_keypad *keypad)\r\n{\r\nconst struct pxa27x_keypad_platform_data *pdata = keypad->pdata;\r\nuint32_t kprec;\r\nkprec = keypad_readl(KPREC);\r\nkeypad_writel(KPREC, DEFAULT_KPREC);\r\nif (pdata->enable_rotary0)\r\nreport_rotary_event(keypad, 0, rotary_delta(kprec));\r\nif (pdata->enable_rotary1)\r\nreport_rotary_event(keypad, 1, rotary_delta(kprec >> 16));\r\n}\r\nstatic void pxa27x_keypad_scan_direct(struct pxa27x_keypad *keypad)\r\n{\r\nconst struct pxa27x_keypad_platform_data *pdata = keypad->pdata;\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nunsigned int new_state;\r\nuint32_t kpdk, bits_changed;\r\nint i;\r\nkpdk = keypad_readl(KPDK);\r\nif (pdata->enable_rotary0 || pdata->enable_rotary1)\r\npxa27x_keypad_scan_rotary(keypad);\r\nif (pdata->direct_key_low_active)\r\nnew_state = ~KPDK_DK(kpdk) & keypad->direct_key_mask;\r\nelse\r\nnew_state = KPDK_DK(kpdk) & keypad->direct_key_mask;\r\nbits_changed = keypad->direct_key_state ^ new_state;\r\nif (bits_changed == 0)\r\nreturn;\r\nfor (i = 0; i < pdata->direct_key_num; i++) {\r\nif (bits_changed & (1 << i)) {\r\nint code = MAX_MATRIX_KEY_NUM + i;\r\ninput_event(input_dev, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(input_dev, keypad->keycodes[code],\r\nnew_state & (1 << i));\r\n}\r\n}\r\ninput_sync(input_dev);\r\nkeypad->direct_key_state = new_state;\r\n}\r\nstatic void clear_wakeup_event(struct pxa27x_keypad *keypad)\r\n{\r\nconst struct pxa27x_keypad_platform_data *pdata = keypad->pdata;\r\nif (pdata->clear_wakeup_event)\r\n(pdata->clear_wakeup_event)();\r\n}\r\nstatic irqreturn_t pxa27x_keypad_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct pxa27x_keypad *keypad = dev_id;\r\nunsigned long kpc = keypad_readl(KPC);\r\nclear_wakeup_event(keypad);\r\nif (kpc & KPC_DI)\r\npxa27x_keypad_scan_direct(keypad);\r\nif (kpc & KPC_MI)\r\npxa27x_keypad_scan_matrix(keypad);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pxa27x_keypad_config(struct pxa27x_keypad *keypad)\r\n{\r\nconst struct pxa27x_keypad_platform_data *pdata = keypad->pdata;\r\nunsigned int mask = 0, direct_key_num = 0;\r\nunsigned long kpc = 0;\r\nkeypad_readl(KPC);\r\nif (pdata->matrix_key_rows && pdata->matrix_key_cols) {\r\nkpc |= KPC_ASACT | KPC_MIE | KPC_ME | KPC_MS_ALL;\r\nkpc |= KPC_MKRN(pdata->matrix_key_rows) |\r\nKPC_MKCN(pdata->matrix_key_cols);\r\n}\r\nif (pdata->enable_rotary0) {\r\nmask |= 0x03;\r\ndirect_key_num = 2;\r\nkpc |= KPC_REE0;\r\n}\r\nif (pdata->enable_rotary1) {\r\nmask |= 0x0c;\r\ndirect_key_num = 4;\r\nkpc |= KPC_REE1;\r\n}\r\nif (pdata->direct_key_num > direct_key_num)\r\ndirect_key_num = pdata->direct_key_num;\r\nif (pdata->direct_key_mask)\r\nkeypad->direct_key_mask = pdata->direct_key_mask;\r\nelse\r\nkeypad->direct_key_mask = ((1 << direct_key_num) - 1) & ~mask;\r\nif (direct_key_num)\r\nkpc |= KPC_DE | KPC_DIE | KPC_DKN(direct_key_num);\r\nkeypad_writel(KPC, kpc | KPC_RE_ZERO_DEB);\r\nkeypad_writel(KPREC, DEFAULT_KPREC);\r\nkeypad_writel(KPKDI, pdata->debounce_interval);\r\n}\r\nstatic int pxa27x_keypad_open(struct input_dev *dev)\r\n{\r\nstruct pxa27x_keypad *keypad = input_get_drvdata(dev);\r\nclk_prepare_enable(keypad->clk);\r\npxa27x_keypad_config(keypad);\r\nreturn 0;\r\n}\r\nstatic void pxa27x_keypad_close(struct input_dev *dev)\r\n{\r\nstruct pxa27x_keypad *keypad = input_get_drvdata(dev);\r\nclk_disable_unprepare(keypad->clk);\r\n}\r\nstatic int pxa27x_keypad_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct pxa27x_keypad *keypad = platform_get_drvdata(pdev);\r\nif (device_may_wakeup(&pdev->dev))\r\nenable_irq_wake(keypad->irq);\r\nelse\r\nclk_disable_unprepare(keypad->clk);\r\nreturn 0;\r\n}\r\nstatic int pxa27x_keypad_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct pxa27x_keypad *keypad = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nif (device_may_wakeup(&pdev->dev)) {\r\ndisable_irq_wake(keypad->irq);\r\n} else {\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users) {\r\nclk_prepare_enable(keypad->clk);\r\npxa27x_keypad_config(keypad);\r\n}\r\nmutex_unlock(&input_dev->mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pxa27x_keypad_probe(struct platform_device *pdev)\r\n{\r\nconst struct pxa27x_keypad_platform_data *pdata =\r\ndev_get_platdata(&pdev->dev);\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct pxa27x_keypad *keypad;\r\nstruct input_dev *input_dev;\r\nstruct resource *res;\r\nint irq, error;\r\nif (!np && !pdata)\r\nreturn -EINVAL;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "failed to get keypad irq\n");\r\nreturn -ENXIO;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "failed to get I/O memory\n");\r\nreturn -ENXIO;\r\n}\r\nkeypad = devm_kzalloc(&pdev->dev, sizeof(*keypad),\r\nGFP_KERNEL);\r\nif (!keypad)\r\nreturn -ENOMEM;\r\ninput_dev = devm_input_allocate_device(&pdev->dev);\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\nkeypad->pdata = pdata;\r\nkeypad->input_dev = input_dev;\r\nkeypad->irq = irq;\r\nkeypad->mmio_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(keypad->mmio_base))\r\nreturn PTR_ERR(keypad->mmio_base);\r\nkeypad->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(keypad->clk)) {\r\ndev_err(&pdev->dev, "failed to get keypad clock\n");\r\nreturn PTR_ERR(keypad->clk);\r\n}\r\ninput_dev->name = pdev->name;\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->open = pxa27x_keypad_open;\r\ninput_dev->close = pxa27x_keypad_close;\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_dev->keycode = keypad->keycodes;\r\ninput_dev->keycodesize = sizeof(keypad->keycodes[0]);\r\ninput_dev->keycodemax = ARRAY_SIZE(keypad->keycodes);\r\ninput_set_drvdata(input_dev, keypad);\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);\r\ninput_set_capability(input_dev, EV_MSC, MSC_SCAN);\r\nif (pdata) {\r\nerror = pxa27x_keypad_build_keycode(keypad);\r\n} else {\r\nerror = pxa27x_keypad_build_keycode_from_dt(keypad);\r\npdata = keypad->pdata;\r\n}\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to build keycode\n");\r\nreturn error;\r\n}\r\nkeypad->row_shift = get_count_order(pdata->matrix_key_cols);\r\nif ((pdata->enable_rotary0 && keypad->rotary_rel_code[0] != -1) ||\r\n(pdata->enable_rotary1 && keypad->rotary_rel_code[1] != -1)) {\r\ninput_dev->evbit[0] |= BIT_MASK(EV_REL);\r\n}\r\nerror = devm_request_irq(&pdev->dev, irq, pxa27x_keypad_irq_handler,\r\n0, pdev->name, keypad);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to request IRQ\n");\r\nreturn error;\r\n}\r\nerror = input_register_device(input_dev);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to register input device\n");\r\nreturn error;\r\n}\r\nplatform_set_drvdata(pdev, keypad);\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nreturn 0;\r\n}
