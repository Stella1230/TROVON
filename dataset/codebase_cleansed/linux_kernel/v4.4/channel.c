static void vmbus_setevent(struct vmbus_channel *channel)\r\n{\r\nstruct hv_monitor_page *monitorpage;\r\nif (channel->offermsg.monitor_allocated) {\r\nsync_set_bit(channel->offermsg.child_relid & 31,\r\n(unsigned long *) vmbus_connection.send_int_page +\r\n(channel->offermsg.child_relid >> 5));\r\nmonitorpage = vmbus_connection.monitor_pages[1];\r\nsync_set_bit(channel->monitor_bit,\r\n(unsigned long *)&monitorpage->trigger_group\r\n[channel->monitor_grp].pending);\r\n} else {\r\nvmbus_set_event(channel);\r\n}\r\n}\r\nint vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,\r\nu32 recv_ringbuffer_size, void *userdata, u32 userdatalen,\r\nvoid (*onchannelcallback)(void *context), void *context)\r\n{\r\nstruct vmbus_channel_open_channel *open_msg;\r\nstruct vmbus_channel_msginfo *open_info = NULL;\r\nvoid *in, *out;\r\nunsigned long flags;\r\nint ret, err = 0;\r\nunsigned long t;\r\nstruct page *page;\r\nspin_lock_irqsave(&newchannel->lock, flags);\r\nif (newchannel->state == CHANNEL_OPEN_STATE) {\r\nnewchannel->state = CHANNEL_OPENING_STATE;\r\n} else {\r\nspin_unlock_irqrestore(&newchannel->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nspin_unlock_irqrestore(&newchannel->lock, flags);\r\nnewchannel->onchannel_callback = onchannelcallback;\r\nnewchannel->channel_callback_context = context;\r\npage = alloc_pages_node(cpu_to_node(newchannel->target_cpu),\r\nGFP_KERNEL|__GFP_ZERO,\r\nget_order(send_ringbuffer_size +\r\nrecv_ringbuffer_size));\r\nif (!page)\r\nout = (void *)__get_free_pages(GFP_KERNEL|__GFP_ZERO,\r\nget_order(send_ringbuffer_size +\r\nrecv_ringbuffer_size));\r\nelse\r\nout = (void *)page_address(page);\r\nif (!out) {\r\nerr = -ENOMEM;\r\ngoto error0;\r\n}\r\nin = (void *)((unsigned long)out + send_ringbuffer_size);\r\nnewchannel->ringbuffer_pages = out;\r\nnewchannel->ringbuffer_pagecount = (send_ringbuffer_size +\r\nrecv_ringbuffer_size) >> PAGE_SHIFT;\r\nret = hv_ringbuffer_init(\r\n&newchannel->outbound, out, send_ringbuffer_size);\r\nif (ret != 0) {\r\nerr = ret;\r\ngoto error0;\r\n}\r\nret = hv_ringbuffer_init(\r\n&newchannel->inbound, in, recv_ringbuffer_size);\r\nif (ret != 0) {\r\nerr = ret;\r\ngoto error0;\r\n}\r\nnewchannel->ringbuffer_gpadlhandle = 0;\r\nret = vmbus_establish_gpadl(newchannel,\r\nnewchannel->outbound.ring_buffer,\r\nsend_ringbuffer_size +\r\nrecv_ringbuffer_size,\r\n&newchannel->ringbuffer_gpadlhandle);\r\nif (ret != 0) {\r\nerr = ret;\r\ngoto error0;\r\n}\r\nopen_info = kmalloc(sizeof(*open_info) +\r\nsizeof(struct vmbus_channel_open_channel),\r\nGFP_KERNEL);\r\nif (!open_info) {\r\nerr = -ENOMEM;\r\ngoto error_gpadl;\r\n}\r\ninit_completion(&open_info->waitevent);\r\nopen_msg = (struct vmbus_channel_open_channel *)open_info->msg;\r\nopen_msg->header.msgtype = CHANNELMSG_OPENCHANNEL;\r\nopen_msg->openid = newchannel->offermsg.child_relid;\r\nopen_msg->child_relid = newchannel->offermsg.child_relid;\r\nopen_msg->ringbuffer_gpadlhandle = newchannel->ringbuffer_gpadlhandle;\r\nopen_msg->downstream_ringbuffer_pageoffset = send_ringbuffer_size >>\r\nPAGE_SHIFT;\r\nopen_msg->target_vp = newchannel->target_vp;\r\nif (userdatalen > MAX_USER_DEFINED_BYTES) {\r\nerr = -EINVAL;\r\ngoto error_gpadl;\r\n}\r\nif (userdatalen)\r\nmemcpy(open_msg->userdata, userdata, userdatalen);\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_add_tail(&open_info->msglistentry,\r\n&vmbus_connection.chn_msg_list);\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\nret = vmbus_post_msg(open_msg,\r\nsizeof(struct vmbus_channel_open_channel));\r\nif (ret != 0) {\r\nerr = ret;\r\ngoto error1;\r\n}\r\nt = wait_for_completion_timeout(&open_info->waitevent, 5*HZ);\r\nif (t == 0) {\r\nerr = -ETIMEDOUT;\r\ngoto error1;\r\n}\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_del(&open_info->msglistentry);\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\nif (open_info->response.open_result.status) {\r\nerr = -EAGAIN;\r\ngoto error_gpadl;\r\n}\r\nnewchannel->state = CHANNEL_OPENED_STATE;\r\nkfree(open_info);\r\nreturn 0;\r\nerror1:\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_del(&open_info->msglistentry);\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\nerror_gpadl:\r\nvmbus_teardown_gpadl(newchannel, newchannel->ringbuffer_gpadlhandle);\r\nerror0:\r\nfree_pages((unsigned long)out,\r\nget_order(send_ringbuffer_size + recv_ringbuffer_size));\r\nkfree(open_info);\r\nnewchannel->state = CHANNEL_OPEN_STATE;\r\nreturn err;\r\n}\r\nstatic int create_gpadl_header(void *kbuffer, u32 size,\r\nstruct vmbus_channel_msginfo **msginfo,\r\nu32 *messagecount)\r\n{\r\nint i;\r\nint pagecount;\r\nstruct vmbus_channel_gpadl_header *gpadl_header;\r\nstruct vmbus_channel_gpadl_body *gpadl_body;\r\nstruct vmbus_channel_msginfo *msgheader;\r\nstruct vmbus_channel_msginfo *msgbody = NULL;\r\nu32 msgsize;\r\nint pfnsum, pfncount, pfnleft, pfncurr, pfnsize;\r\npagecount = size >> PAGE_SHIFT;\r\npfnsize = MAX_SIZE_CHANNEL_MESSAGE -\r\nsizeof(struct vmbus_channel_gpadl_header) -\r\nsizeof(struct gpa_range);\r\npfncount = pfnsize / sizeof(u64);\r\nif (pagecount > pfncount) {\r\nmsgsize = sizeof(struct vmbus_channel_msginfo) +\r\nsizeof(struct vmbus_channel_gpadl_header) +\r\nsizeof(struct gpa_range) + pfncount * sizeof(u64);\r\nmsgheader = kzalloc(msgsize, GFP_KERNEL);\r\nif (!msgheader)\r\ngoto nomem;\r\nINIT_LIST_HEAD(&msgheader->submsglist);\r\nmsgheader->msgsize = msgsize;\r\ngpadl_header = (struct vmbus_channel_gpadl_header *)\r\nmsgheader->msg;\r\ngpadl_header->rangecount = 1;\r\ngpadl_header->range_buflen = sizeof(struct gpa_range) +\r\npagecount * sizeof(u64);\r\ngpadl_header->range[0].byte_offset = 0;\r\ngpadl_header->range[0].byte_count = size;\r\nfor (i = 0; i < pfncount; i++)\r\ngpadl_header->range[0].pfn_array[i] = slow_virt_to_phys(\r\nkbuffer + PAGE_SIZE * i) >> PAGE_SHIFT;\r\n*msginfo = msgheader;\r\n*messagecount = 1;\r\npfnsum = pfncount;\r\npfnleft = pagecount - pfncount;\r\npfnsize = MAX_SIZE_CHANNEL_MESSAGE -\r\nsizeof(struct vmbus_channel_gpadl_body);\r\npfncount = pfnsize / sizeof(u64);\r\nwhile (pfnleft) {\r\nif (pfnleft > pfncount)\r\npfncurr = pfncount;\r\nelse\r\npfncurr = pfnleft;\r\nmsgsize = sizeof(struct vmbus_channel_msginfo) +\r\nsizeof(struct vmbus_channel_gpadl_body) +\r\npfncurr * sizeof(u64);\r\nmsgbody = kzalloc(msgsize, GFP_KERNEL);\r\nif (!msgbody) {\r\nstruct vmbus_channel_msginfo *pos = NULL;\r\nstruct vmbus_channel_msginfo *tmp = NULL;\r\nlist_for_each_entry_safe(pos, tmp,\r\n&msgheader->submsglist,\r\nmsglistentry) {\r\nlist_del(&pos->msglistentry);\r\nkfree(pos);\r\n}\r\ngoto nomem;\r\n}\r\nmsgbody->msgsize = msgsize;\r\n(*messagecount)++;\r\ngpadl_body =\r\n(struct vmbus_channel_gpadl_body *)msgbody->msg;\r\nfor (i = 0; i < pfncurr; i++)\r\ngpadl_body->pfn[i] = slow_virt_to_phys(\r\nkbuffer + PAGE_SIZE * (pfnsum + i)) >>\r\nPAGE_SHIFT;\r\nlist_add_tail(&msgbody->msglistentry,\r\n&msgheader->submsglist);\r\npfnsum += pfncurr;\r\npfnleft -= pfncurr;\r\n}\r\n} else {\r\nmsgsize = sizeof(struct vmbus_channel_msginfo) +\r\nsizeof(struct vmbus_channel_gpadl_header) +\r\nsizeof(struct gpa_range) + pagecount * sizeof(u64);\r\nmsgheader = kzalloc(msgsize, GFP_KERNEL);\r\nif (msgheader == NULL)\r\ngoto nomem;\r\nmsgheader->msgsize = msgsize;\r\ngpadl_header = (struct vmbus_channel_gpadl_header *)\r\nmsgheader->msg;\r\ngpadl_header->rangecount = 1;\r\ngpadl_header->range_buflen = sizeof(struct gpa_range) +\r\npagecount * sizeof(u64);\r\ngpadl_header->range[0].byte_offset = 0;\r\ngpadl_header->range[0].byte_count = size;\r\nfor (i = 0; i < pagecount; i++)\r\ngpadl_header->range[0].pfn_array[i] = slow_virt_to_phys(\r\nkbuffer + PAGE_SIZE * i) >> PAGE_SHIFT;\r\n*msginfo = msgheader;\r\n*messagecount = 1;\r\n}\r\nreturn 0;\r\nnomem:\r\nkfree(msgheader);\r\nkfree(msgbody);\r\nreturn -ENOMEM;\r\n}\r\nint vmbus_establish_gpadl(struct vmbus_channel *channel, void *kbuffer,\r\nu32 size, u32 *gpadl_handle)\r\n{\r\nstruct vmbus_channel_gpadl_header *gpadlmsg;\r\nstruct vmbus_channel_gpadl_body *gpadl_body;\r\nstruct vmbus_channel_msginfo *msginfo = NULL;\r\nstruct vmbus_channel_msginfo *submsginfo;\r\nu32 msgcount;\r\nstruct list_head *curr;\r\nu32 next_gpadl_handle;\r\nunsigned long flags;\r\nint ret = 0;\r\nnext_gpadl_handle =\r\n(atomic_inc_return(&vmbus_connection.next_gpadl_handle) - 1);\r\nret = create_gpadl_header(kbuffer, size, &msginfo, &msgcount);\r\nif (ret)\r\nreturn ret;\r\ninit_completion(&msginfo->waitevent);\r\ngpadlmsg = (struct vmbus_channel_gpadl_header *)msginfo->msg;\r\ngpadlmsg->header.msgtype = CHANNELMSG_GPADL_HEADER;\r\ngpadlmsg->child_relid = channel->offermsg.child_relid;\r\ngpadlmsg->gpadl = next_gpadl_handle;\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_add_tail(&msginfo->msglistentry,\r\n&vmbus_connection.chn_msg_list);\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\nret = vmbus_post_msg(gpadlmsg, msginfo->msgsize -\r\nsizeof(*msginfo));\r\nif (ret != 0)\r\ngoto cleanup;\r\nif (msgcount > 1) {\r\nlist_for_each(curr, &msginfo->submsglist) {\r\nsubmsginfo = (struct vmbus_channel_msginfo *)curr;\r\ngpadl_body =\r\n(struct vmbus_channel_gpadl_body *)submsginfo->msg;\r\ngpadl_body->header.msgtype =\r\nCHANNELMSG_GPADL_BODY;\r\ngpadl_body->gpadl = next_gpadl_handle;\r\nret = vmbus_post_msg(gpadl_body,\r\nsubmsginfo->msgsize -\r\nsizeof(*submsginfo));\r\nif (ret != 0)\r\ngoto cleanup;\r\n}\r\n}\r\nwait_for_completion(&msginfo->waitevent);\r\n*gpadl_handle = gpadlmsg->gpadl;\r\ncleanup:\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_del(&msginfo->msglistentry);\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\nkfree(msginfo);\r\nreturn ret;\r\n}\r\nint vmbus_teardown_gpadl(struct vmbus_channel *channel, u32 gpadl_handle)\r\n{\r\nstruct vmbus_channel_gpadl_teardown *msg;\r\nstruct vmbus_channel_msginfo *info;\r\nunsigned long flags;\r\nint ret;\r\ninfo = kmalloc(sizeof(*info) +\r\nsizeof(struct vmbus_channel_gpadl_teardown), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninit_completion(&info->waitevent);\r\nmsg = (struct vmbus_channel_gpadl_teardown *)info->msg;\r\nmsg->header.msgtype = CHANNELMSG_GPADL_TEARDOWN;\r\nmsg->child_relid = channel->offermsg.child_relid;\r\nmsg->gpadl = gpadl_handle;\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_add_tail(&info->msglistentry,\r\n&vmbus_connection.chn_msg_list);\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\nret = vmbus_post_msg(msg,\r\nsizeof(struct vmbus_channel_gpadl_teardown));\r\nif (ret)\r\ngoto post_msg_err;\r\nwait_for_completion(&info->waitevent);\r\npost_msg_err:\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_del(&info->msglistentry);\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\nkfree(info);\r\nreturn ret;\r\n}\r\nstatic void reset_channel_cb(void *arg)\r\n{\r\nstruct vmbus_channel *channel = arg;\r\nchannel->onchannel_callback = NULL;\r\n}\r\nstatic int vmbus_close_internal(struct vmbus_channel *channel)\r\n{\r\nstruct vmbus_channel_close_channel *msg;\r\nint ret;\r\nchannel->state = CHANNEL_OPEN_STATE;\r\nchannel->sc_creation_callback = NULL;\r\nif (channel->target_cpu != get_cpu()) {\r\nput_cpu();\r\nsmp_call_function_single(channel->target_cpu, reset_channel_cb,\r\nchannel, true);\r\n} else {\r\nreset_channel_cb(channel);\r\nput_cpu();\r\n}\r\nmsg = &channel->close_msg.msg;\r\nmsg->header.msgtype = CHANNELMSG_CLOSECHANNEL;\r\nmsg->child_relid = channel->offermsg.child_relid;\r\nret = vmbus_post_msg(msg, sizeof(struct vmbus_channel_close_channel));\r\nif (ret) {\r\npr_err("Close failed: close post msg return is %d\n", ret);\r\nreturn ret;\r\n}\r\nif (channel->ringbuffer_gpadlhandle) {\r\nret = vmbus_teardown_gpadl(channel,\r\nchannel->ringbuffer_gpadlhandle);\r\nif (ret) {\r\npr_err("Close failed: teardown gpadl return %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nhv_ringbuffer_cleanup(&channel->outbound);\r\nhv_ringbuffer_cleanup(&channel->inbound);\r\nfree_pages((unsigned long)channel->ringbuffer_pages,\r\nget_order(channel->ringbuffer_pagecount * PAGE_SIZE));\r\nif (channel->rescind)\r\nhv_process_channel_removal(channel,\r\nchannel->offermsg.child_relid);\r\nreturn ret;\r\n}\r\nvoid vmbus_close(struct vmbus_channel *channel)\r\n{\r\nstruct list_head *cur, *tmp;\r\nstruct vmbus_channel *cur_channel;\r\nif (channel->primary_channel != NULL) {\r\nreturn;\r\n}\r\nlist_for_each_safe(cur, tmp, &channel->sc_list) {\r\ncur_channel = list_entry(cur, struct vmbus_channel, sc_list);\r\nif (cur_channel->state != CHANNEL_OPENED_STATE)\r\ncontinue;\r\nvmbus_close_internal(cur_channel);\r\n}\r\nvmbus_close_internal(channel);\r\n}\r\nint vmbus_sendpacket_ctl(struct vmbus_channel *channel, void *buffer,\r\nu32 bufferlen, u64 requestid,\r\nenum vmbus_packet_type type, u32 flags, bool kick_q)\r\n{\r\nstruct vmpacket_descriptor desc;\r\nu32 packetlen = sizeof(struct vmpacket_descriptor) + bufferlen;\r\nu32 packetlen_aligned = ALIGN(packetlen, sizeof(u64));\r\nstruct kvec bufferlist[3];\r\nu64 aligned_data = 0;\r\nint ret;\r\nbool signal = false;\r\nint num_vecs = ((bufferlen != 0) ? 3 : 1);\r\ndesc.type = type;\r\ndesc.flags = flags;\r\ndesc.offset8 = sizeof(struct vmpacket_descriptor) >> 3;\r\ndesc.len8 = (u16)(packetlen_aligned >> 3);\r\ndesc.trans_id = requestid;\r\nbufferlist[0].iov_base = &desc;\r\nbufferlist[0].iov_len = sizeof(struct vmpacket_descriptor);\r\nbufferlist[1].iov_base = buffer;\r\nbufferlist[1].iov_len = bufferlen;\r\nbufferlist[2].iov_base = &aligned_data;\r\nbufferlist[2].iov_len = (packetlen_aligned - packetlen);\r\nret = hv_ringbuffer_write(&channel->outbound, bufferlist, num_vecs,\r\n&signal);\r\nif (((ret == 0) && kick_q && signal) || (ret))\r\nvmbus_setevent(channel);\r\nreturn ret;\r\n}\r\nint vmbus_sendpacket(struct vmbus_channel *channel, void *buffer,\r\nu32 bufferlen, u64 requestid,\r\nenum vmbus_packet_type type, u32 flags)\r\n{\r\nreturn vmbus_sendpacket_ctl(channel, buffer, bufferlen, requestid,\r\ntype, flags, true);\r\n}\r\nint vmbus_sendpacket_pagebuffer_ctl(struct vmbus_channel *channel,\r\nstruct hv_page_buffer pagebuffers[],\r\nu32 pagecount, void *buffer, u32 bufferlen,\r\nu64 requestid,\r\nu32 flags,\r\nbool kick_q)\r\n{\r\nint ret;\r\nint i;\r\nstruct vmbus_channel_packet_page_buffer desc;\r\nu32 descsize;\r\nu32 packetlen;\r\nu32 packetlen_aligned;\r\nstruct kvec bufferlist[3];\r\nu64 aligned_data = 0;\r\nbool signal = false;\r\nif (pagecount > MAX_PAGE_BUFFER_COUNT)\r\nreturn -EINVAL;\r\ndescsize = sizeof(struct vmbus_channel_packet_page_buffer) -\r\n((MAX_PAGE_BUFFER_COUNT - pagecount) *\r\nsizeof(struct hv_page_buffer));\r\npacketlen = descsize + bufferlen;\r\npacketlen_aligned = ALIGN(packetlen, sizeof(u64));\r\ndesc.type = VM_PKT_DATA_USING_GPA_DIRECT;\r\ndesc.flags = flags;\r\ndesc.dataoffset8 = descsize >> 3;\r\ndesc.length8 = (u16)(packetlen_aligned >> 3);\r\ndesc.transactionid = requestid;\r\ndesc.rangecount = pagecount;\r\nfor (i = 0; i < pagecount; i++) {\r\ndesc.range[i].len = pagebuffers[i].len;\r\ndesc.range[i].offset = pagebuffers[i].offset;\r\ndesc.range[i].pfn = pagebuffers[i].pfn;\r\n}\r\nbufferlist[0].iov_base = &desc;\r\nbufferlist[0].iov_len = descsize;\r\nbufferlist[1].iov_base = buffer;\r\nbufferlist[1].iov_len = bufferlen;\r\nbufferlist[2].iov_base = &aligned_data;\r\nbufferlist[2].iov_len = (packetlen_aligned - packetlen);\r\nret = hv_ringbuffer_write(&channel->outbound, bufferlist, 3, &signal);\r\nif (((ret == 0) && kick_q && signal) || (ret))\r\nvmbus_setevent(channel);\r\nreturn ret;\r\n}\r\nint vmbus_sendpacket_pagebuffer(struct vmbus_channel *channel,\r\nstruct hv_page_buffer pagebuffers[],\r\nu32 pagecount, void *buffer, u32 bufferlen,\r\nu64 requestid)\r\n{\r\nu32 flags = VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED;\r\nreturn vmbus_sendpacket_pagebuffer_ctl(channel, pagebuffers, pagecount,\r\nbuffer, bufferlen, requestid,\r\nflags, true);\r\n}\r\nint vmbus_sendpacket_mpb_desc(struct vmbus_channel *channel,\r\nstruct vmbus_packet_mpb_array *desc,\r\nu32 desc_size,\r\nvoid *buffer, u32 bufferlen, u64 requestid)\r\n{\r\nint ret;\r\nu32 packetlen;\r\nu32 packetlen_aligned;\r\nstruct kvec bufferlist[3];\r\nu64 aligned_data = 0;\r\nbool signal = false;\r\npacketlen = desc_size + bufferlen;\r\npacketlen_aligned = ALIGN(packetlen, sizeof(u64));\r\ndesc->type = VM_PKT_DATA_USING_GPA_DIRECT;\r\ndesc->flags = VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED;\r\ndesc->dataoffset8 = desc_size >> 3;\r\ndesc->length8 = (u16)(packetlen_aligned >> 3);\r\ndesc->transactionid = requestid;\r\ndesc->rangecount = 1;\r\nbufferlist[0].iov_base = desc;\r\nbufferlist[0].iov_len = desc_size;\r\nbufferlist[1].iov_base = buffer;\r\nbufferlist[1].iov_len = bufferlen;\r\nbufferlist[2].iov_base = &aligned_data;\r\nbufferlist[2].iov_len = (packetlen_aligned - packetlen);\r\nret = hv_ringbuffer_write(&channel->outbound, bufferlist, 3, &signal);\r\nif (ret == 0 && signal)\r\nvmbus_setevent(channel);\r\nreturn ret;\r\n}\r\nint vmbus_sendpacket_multipagebuffer(struct vmbus_channel *channel,\r\nstruct hv_multipage_buffer *multi_pagebuffer,\r\nvoid *buffer, u32 bufferlen, u64 requestid)\r\n{\r\nint ret;\r\nstruct vmbus_channel_packet_multipage_buffer desc;\r\nu32 descsize;\r\nu32 packetlen;\r\nu32 packetlen_aligned;\r\nstruct kvec bufferlist[3];\r\nu64 aligned_data = 0;\r\nbool signal = false;\r\nu32 pfncount = NUM_PAGES_SPANNED(multi_pagebuffer->offset,\r\nmulti_pagebuffer->len);\r\nif (pfncount > MAX_MULTIPAGE_BUFFER_COUNT)\r\nreturn -EINVAL;\r\ndescsize = sizeof(struct vmbus_channel_packet_multipage_buffer) -\r\n((MAX_MULTIPAGE_BUFFER_COUNT - pfncount) *\r\nsizeof(u64));\r\npacketlen = descsize + bufferlen;\r\npacketlen_aligned = ALIGN(packetlen, sizeof(u64));\r\ndesc.type = VM_PKT_DATA_USING_GPA_DIRECT;\r\ndesc.flags = VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED;\r\ndesc.dataoffset8 = descsize >> 3;\r\ndesc.length8 = (u16)(packetlen_aligned >> 3);\r\ndesc.transactionid = requestid;\r\ndesc.rangecount = 1;\r\ndesc.range.len = multi_pagebuffer->len;\r\ndesc.range.offset = multi_pagebuffer->offset;\r\nmemcpy(desc.range.pfn_array, multi_pagebuffer->pfn_array,\r\npfncount * sizeof(u64));\r\nbufferlist[0].iov_base = &desc;\r\nbufferlist[0].iov_len = descsize;\r\nbufferlist[1].iov_base = buffer;\r\nbufferlist[1].iov_len = bufferlen;\r\nbufferlist[2].iov_base = &aligned_data;\r\nbufferlist[2].iov_len = (packetlen_aligned - packetlen);\r\nret = hv_ringbuffer_write(&channel->outbound, bufferlist, 3, &signal);\r\nif (ret == 0 && signal)\r\nvmbus_setevent(channel);\r\nreturn ret;\r\n}\r\nint vmbus_recvpacket(struct vmbus_channel *channel, void *buffer,\r\nu32 bufferlen, u32 *buffer_actual_len, u64 *requestid)\r\n{\r\nstruct vmpacket_descriptor desc;\r\nu32 packetlen;\r\nu32 userlen;\r\nint ret;\r\nbool signal = false;\r\n*buffer_actual_len = 0;\r\n*requestid = 0;\r\nret = hv_ringbuffer_peek(&channel->inbound, &desc,\r\nsizeof(struct vmpacket_descriptor));\r\nif (ret != 0)\r\nreturn 0;\r\npacketlen = desc.len8 << 3;\r\nuserlen = packetlen - (desc.offset8 << 3);\r\n*buffer_actual_len = userlen;\r\nif (userlen > bufferlen) {\r\npr_err("Buffer too small - got %d needs %d\n",\r\nbufferlen, userlen);\r\nreturn -ETOOSMALL;\r\n}\r\n*requestid = desc.trans_id;\r\nret = hv_ringbuffer_read(&channel->inbound, buffer, userlen,\r\n(desc.offset8 << 3), &signal);\r\nif (signal)\r\nvmbus_setevent(channel);\r\nreturn 0;\r\n}\r\nint vmbus_recvpacket_raw(struct vmbus_channel *channel, void *buffer,\r\nu32 bufferlen, u32 *buffer_actual_len,\r\nu64 *requestid)\r\n{\r\nstruct vmpacket_descriptor desc;\r\nu32 packetlen;\r\nint ret;\r\nbool signal = false;\r\n*buffer_actual_len = 0;\r\n*requestid = 0;\r\nret = hv_ringbuffer_peek(&channel->inbound, &desc,\r\nsizeof(struct vmpacket_descriptor));\r\nif (ret != 0)\r\nreturn 0;\r\npacketlen = desc.len8 << 3;\r\n*buffer_actual_len = packetlen;\r\nif (packetlen > bufferlen)\r\nreturn -ENOBUFS;\r\n*requestid = desc.trans_id;\r\nret = hv_ringbuffer_read(&channel->inbound, buffer, packetlen, 0,\r\n&signal);\r\nif (signal)\r\nvmbus_setevent(channel);\r\nreturn ret;\r\n}
