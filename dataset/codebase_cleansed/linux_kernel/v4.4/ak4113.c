static void reg_write(struct ak4113 *ak4113, unsigned char reg,\r\nunsigned char val)\r\n{\r\nak4113->write(ak4113->private_data, reg, val);\r\nif (reg < sizeof(ak4113->regmap))\r\nak4113->regmap[reg] = val;\r\n}\r\nstatic inline unsigned char reg_read(struct ak4113 *ak4113, unsigned char reg)\r\n{\r\nreturn ak4113->read(ak4113->private_data, reg);\r\n}\r\nstatic void snd_ak4113_free(struct ak4113 *chip)\r\n{\r\natomic_inc(&chip->wq_processing);\r\ncancel_delayed_work_sync(&chip->work);\r\nkfree(chip);\r\n}\r\nstatic int snd_ak4113_dev_free(struct snd_device *device)\r\n{\r\nstruct ak4113 *chip = device->device_data;\r\nsnd_ak4113_free(chip);\r\nreturn 0;\r\n}\r\nint snd_ak4113_create(struct snd_card *card, ak4113_read_t *read,\r\nak4113_write_t *write, const unsigned char *pgm,\r\nvoid *private_data, struct ak4113 **r_ak4113)\r\n{\r\nstruct ak4113 *chip;\r\nint err;\r\nunsigned char reg;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_ak4113_dev_free,\r\n};\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&chip->lock);\r\nchip->card = card;\r\nchip->read = read;\r\nchip->write = write;\r\nchip->private_data = private_data;\r\nINIT_DELAYED_WORK(&chip->work, ak4113_stats);\r\natomic_set(&chip->wq_processing, 0);\r\nmutex_init(&chip->reinit_mutex);\r\nfor (reg = 0; reg < AK4113_WRITABLE_REGS ; reg++)\r\nchip->regmap[reg] = pgm[reg];\r\nak4113_init_regs(chip);\r\nchip->rcs0 = reg_read(chip, AK4113_REG_RCS0) & ~(AK4113_QINT |\r\nAK4113_CINT | AK4113_STC);\r\nchip->rcs1 = reg_read(chip, AK4113_REG_RCS1);\r\nchip->rcs2 = reg_read(chip, AK4113_REG_RCS2);\r\nerr = snd_device_new(card, SNDRV_DEV_CODEC, chip, &ops);\r\nif (err < 0)\r\ngoto __fail;\r\nif (r_ak4113)\r\n*r_ak4113 = chip;\r\nreturn 0;\r\n__fail:\r\nsnd_ak4113_free(chip);\r\nreturn err;\r\n}\r\nvoid snd_ak4113_reg_write(struct ak4113 *chip, unsigned char reg,\r\nunsigned char mask, unsigned char val)\r\n{\r\nif (reg >= AK4113_WRITABLE_REGS)\r\nreturn;\r\nreg_write(chip, reg, (chip->regmap[reg] & ~mask) | val);\r\n}\r\nstatic void ak4113_init_regs(struct ak4113 *chip)\r\n{\r\nunsigned char old = chip->regmap[AK4113_REG_PWRDN], reg;\r\nreg_write(chip, AK4113_REG_PWRDN, old & ~(AK4113_RST|AK4113_PWN));\r\nudelay(200);\r\nreg_write(chip, AK4113_REG_PWRDN, (old | AK4113_RST) & ~AK4113_PWN);\r\nudelay(200);\r\nfor (reg = 1; reg < AK4113_WRITABLE_REGS; reg++)\r\nreg_write(chip, reg, chip->regmap[reg]);\r\nreg_write(chip, AK4113_REG_PWRDN, old | AK4113_RST | AK4113_PWN);\r\n}\r\nvoid snd_ak4113_reinit(struct ak4113 *chip)\r\n{\r\nif (atomic_inc_return(&chip->wq_processing) == 1)\r\ncancel_delayed_work_sync(&chip->work);\r\nmutex_lock(&chip->reinit_mutex);\r\nak4113_init_regs(chip);\r\nmutex_unlock(&chip->reinit_mutex);\r\nif (atomic_dec_and_test(&chip->wq_processing))\r\nschedule_delayed_work(&chip->work, HZ / 10);\r\n}\r\nstatic unsigned int external_rate(unsigned char rcs1)\r\n{\r\nswitch (rcs1 & (AK4113_FS0|AK4113_FS1|AK4113_FS2|AK4113_FS3)) {\r\ncase AK4113_FS_8000HZ:\r\nreturn 8000;\r\ncase AK4113_FS_11025HZ:\r\nreturn 11025;\r\ncase AK4113_FS_16000HZ:\r\nreturn 16000;\r\ncase AK4113_FS_22050HZ:\r\nreturn 22050;\r\ncase AK4113_FS_24000HZ:\r\nreturn 24000;\r\ncase AK4113_FS_32000HZ:\r\nreturn 32000;\r\ncase AK4113_FS_44100HZ:\r\nreturn 44100;\r\ncase AK4113_FS_48000HZ:\r\nreturn 48000;\r\ncase AK4113_FS_64000HZ:\r\nreturn 64000;\r\ncase AK4113_FS_88200HZ:\r\nreturn 88200;\r\ncase AK4113_FS_96000HZ:\r\nreturn 96000;\r\ncase AK4113_FS_176400HZ:\r\nreturn 176400;\r\ncase AK4113_FS_192000HZ:\r\nreturn 192000;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int snd_ak4113_in_error_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = LONG_MAX;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4113_in_error_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ak4113 *chip = snd_kcontrol_chip(kcontrol);\r\nlong *ptr;\r\nspin_lock_irq(&chip->lock);\r\nptr = (long *)(((char *)chip) + kcontrol->private_value);\r\nucontrol->value.integer.value[0] = *ptr;\r\n*ptr = 0;\r\nspin_unlock_irq(&chip->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ak4113_in_bit_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ak4113 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned char reg = kcontrol->private_value & 0xff;\r\nunsigned char bit = (kcontrol->private_value >> 8) & 0xff;\r\nunsigned char inv = (kcontrol->private_value >> 31) & 1;\r\nucontrol->value.integer.value[0] =\r\n((reg_read(chip, reg) & (1 << bit)) ? 1 : 0) ^ inv;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4113_rx_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 5;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4113_rx_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ak4113 *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] =\r\n(AK4113_IPS(chip->regmap[AK4113_REG_IO1]));\r\nreturn 0;\r\n}\r\nstatic int snd_ak4113_rx_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ak4113 *chip = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nu8 old_val;\r\nspin_lock_irq(&chip->lock);\r\nold_val = chip->regmap[AK4113_REG_IO1];\r\nchange = ucontrol->value.integer.value[0] != AK4113_IPS(old_val);\r\nif (change)\r\nreg_write(chip, AK4113_REG_IO1,\r\n(old_val & (~AK4113_IPS(0xff))) |\r\n(AK4113_IPS(ucontrol->value.integer.value[0])));\r\nspin_unlock_irq(&chip->lock);\r\nreturn change;\r\n}\r\nstatic int snd_ak4113_rate_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 192000;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4113_rate_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ak4113 *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = external_rate(reg_read(chip,\r\nAK4113_REG_RCS1));\r\nreturn 0;\r\n}\r\nstatic int snd_ak4113_spdif_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4113_spdif_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ak4113 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned i;\r\nfor (i = 0; i < AK4113_REG_RXCSB_SIZE; i++)\r\nucontrol->value.iec958.status[i] = reg_read(chip,\r\nAK4113_REG_RXCSB0 + i);\r\nreturn 0;\r\n}\r\nstatic int snd_ak4113_spdif_mask_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4113_spdif_mask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nmemset(ucontrol->value.iec958.status, 0xff, AK4113_REG_RXCSB_SIZE);\r\nreturn 0;\r\n}\r\nstatic int snd_ak4113_spdif_pinfo(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 0xffff;\r\nuinfo->count = 4;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4113_spdif_pget(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ak4113 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned short tmp;\r\nucontrol->value.integer.value[0] = 0xf8f2;\r\nucontrol->value.integer.value[1] = 0x4e1f;\r\ntmp = reg_read(chip, AK4113_REG_Pc0) |\r\n(reg_read(chip, AK4113_REG_Pc1) << 8);\r\nucontrol->value.integer.value[2] = tmp;\r\ntmp = reg_read(chip, AK4113_REG_Pd0) |\r\n(reg_read(chip, AK4113_REG_Pd1) << 8);\r\nucontrol->value.integer.value[3] = tmp;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4113_spdif_qinfo(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\r\nuinfo->count = AK4113_REG_QSUB_SIZE;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4113_spdif_qget(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ak4113 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned i;\r\nfor (i = 0; i < AK4113_REG_QSUB_SIZE; i++)\r\nucontrol->value.bytes.data[i] = reg_read(chip,\r\nAK4113_REG_QSUB_ADDR + i);\r\nreturn 0;\r\n}\r\nstatic void snd_ak4113_proc_regs_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct ak4113 *ak4113 = entry->private_data;\r\nint reg, val;\r\nfor (reg = 0; reg < 0x1d; reg++) {\r\nval = reg_read(ak4113, reg);\r\nsnd_iprintf(buffer, "0x%02x = 0x%02x\n", reg, val);\r\n}\r\n}\r\nstatic void snd_ak4113_proc_init(struct ak4113 *ak4113)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (!snd_card_proc_new(ak4113->card, "ak4113", &entry))\r\nsnd_info_set_text_ops(entry, ak4113, snd_ak4113_proc_regs_read);\r\n}\r\nint snd_ak4113_build(struct ak4113 *ak4113,\r\nstruct snd_pcm_substream *cap_substream)\r\n{\r\nstruct snd_kcontrol *kctl;\r\nunsigned int idx;\r\nint err;\r\nif (snd_BUG_ON(!cap_substream))\r\nreturn -EINVAL;\r\nak4113->substream = cap_substream;\r\nfor (idx = 0; idx < AK4113_CONTROLS; idx++) {\r\nkctl = snd_ctl_new1(&snd_ak4113_iec958_controls[idx], ak4113);\r\nif (kctl == NULL)\r\nreturn -ENOMEM;\r\nkctl->id.device = cap_substream->pcm->device;\r\nkctl->id.subdevice = cap_substream->number;\r\nerr = snd_ctl_add(ak4113->card, kctl);\r\nif (err < 0)\r\nreturn err;\r\nak4113->kctls[idx] = kctl;\r\n}\r\nsnd_ak4113_proc_init(ak4113);\r\nschedule_delayed_work(&ak4113->work, HZ / 10);\r\nreturn 0;\r\n}\r\nint snd_ak4113_external_rate(struct ak4113 *ak4113)\r\n{\r\nunsigned char rcs1;\r\nrcs1 = reg_read(ak4113, AK4113_REG_RCS1);\r\nreturn external_rate(rcs1);\r\n}\r\nint snd_ak4113_check_rate_and_errors(struct ak4113 *ak4113, unsigned int flags)\r\n{\r\nstruct snd_pcm_runtime *runtime =\r\nak4113->substream ? ak4113->substream->runtime : NULL;\r\nunsigned long _flags;\r\nint res = 0;\r\nunsigned char rcs0, rcs1, rcs2;\r\nunsigned char c0, c1;\r\nrcs1 = reg_read(ak4113, AK4113_REG_RCS1);\r\nif (flags & AK4113_CHECK_NO_STAT)\r\ngoto __rate;\r\nrcs0 = reg_read(ak4113, AK4113_REG_RCS0);\r\nrcs2 = reg_read(ak4113, AK4113_REG_RCS2);\r\nspin_lock_irqsave(&ak4113->lock, _flags);\r\nif (rcs0 & AK4113_PAR)\r\nak4113->parity_errors++;\r\nif (rcs0 & AK4113_V)\r\nak4113->v_bit_errors++;\r\nif (rcs2 & AK4113_CCRC)\r\nak4113->ccrc_errors++;\r\nif (rcs2 & AK4113_QCRC)\r\nak4113->qcrc_errors++;\r\nc0 = (ak4113->rcs0 & (AK4113_QINT | AK4113_CINT | AK4113_STC |\r\nAK4113_AUDION | AK4113_AUTO | AK4113_UNLCK)) ^\r\n(rcs0 & (AK4113_QINT | AK4113_CINT | AK4113_STC |\r\nAK4113_AUDION | AK4113_AUTO | AK4113_UNLCK));\r\nc1 = (ak4113->rcs1 & (AK4113_DTSCD | AK4113_NPCM | AK4113_PEM |\r\nAK4113_DAT | 0xf0)) ^\r\n(rcs1 & (AK4113_DTSCD | AK4113_NPCM | AK4113_PEM |\r\nAK4113_DAT | 0xf0));\r\nak4113->rcs0 = rcs0 & ~(AK4113_QINT | AK4113_CINT | AK4113_STC);\r\nak4113->rcs1 = rcs1;\r\nak4113->rcs2 = rcs2;\r\nspin_unlock_irqrestore(&ak4113->lock, _flags);\r\nif (rcs0 & AK4113_PAR)\r\nsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4113->kctls[0]->id);\r\nif (rcs0 & AK4113_V)\r\nsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4113->kctls[1]->id);\r\nif (rcs2 & AK4113_CCRC)\r\nsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4113->kctls[2]->id);\r\nif (rcs2 & AK4113_QCRC)\r\nsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4113->kctls[3]->id);\r\nif (c1 & 0xf0)\r\nsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4113->kctls[4]->id);\r\nif ((c1 & AK4113_PEM) | (c0 & AK4113_CINT))\r\nsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4113->kctls[6]->id);\r\nif (c0 & AK4113_QINT)\r\nsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4113->kctls[8]->id);\r\nif (c0 & AK4113_AUDION)\r\nsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4113->kctls[9]->id);\r\nif (c1 & AK4113_NPCM)\r\nsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4113->kctls[10]->id);\r\nif (c1 & AK4113_DTSCD)\r\nsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4113->kctls[11]->id);\r\nif (ak4113->change_callback && (c0 | c1) != 0)\r\nak4113->change_callback(ak4113, c0, c1);\r\n__rate:\r\nres = external_rate(rcs1);\r\nif (!(flags & AK4113_CHECK_NO_RATE) && runtime &&\r\n(runtime->rate != res)) {\r\nsnd_pcm_stream_lock_irqsave(ak4113->substream, _flags);\r\nif (snd_pcm_running(ak4113->substream)) {\r\nsnd_pcm_stop(ak4113->substream,\r\nSNDRV_PCM_STATE_DRAINING);\r\nwake_up(&runtime->sleep);\r\nres = 1;\r\n}\r\nsnd_pcm_stream_unlock_irqrestore(ak4113->substream, _flags);\r\n}\r\nreturn res;\r\n}\r\nstatic void ak4113_stats(struct work_struct *work)\r\n{\r\nstruct ak4113 *chip = container_of(work, struct ak4113, work.work);\r\nif (atomic_inc_return(&chip->wq_processing) == 1)\r\nsnd_ak4113_check_rate_and_errors(chip, chip->check_flags);\r\nif (atomic_dec_and_test(&chip->wq_processing))\r\nschedule_delayed_work(&chip->work, HZ / 10);\r\n}\r\nvoid snd_ak4113_suspend(struct ak4113 *chip)\r\n{\r\natomic_inc(&chip->wq_processing);\r\ncancel_delayed_work_sync(&chip->work);\r\n}\r\nvoid snd_ak4113_resume(struct ak4113 *chip)\r\n{\r\natomic_dec(&chip->wq_processing);\r\nsnd_ak4113_reinit(chip);\r\n}
