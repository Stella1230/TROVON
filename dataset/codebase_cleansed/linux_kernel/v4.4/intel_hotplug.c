bool intel_hpd_pin_to_port(enum hpd_pin pin, enum port *port)\r\n{\r\nswitch (pin) {\r\ncase HPD_PORT_A:\r\n*port = PORT_A;\r\nreturn true;\r\ncase HPD_PORT_B:\r\n*port = PORT_B;\r\nreturn true;\r\ncase HPD_PORT_C:\r\n*port = PORT_C;\r\nreturn true;\r\ncase HPD_PORT_D:\r\n*port = PORT_D;\r\nreturn true;\r\ncase HPD_PORT_E:\r\n*port = PORT_E;\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool intel_hpd_irq_storm_detect(struct drm_i915_private *dev_priv,\r\nenum hpd_pin pin)\r\n{\r\nunsigned long start = dev_priv->hotplug.stats[pin].last_jiffies;\r\nunsigned long end = start + msecs_to_jiffies(HPD_STORM_DETECT_PERIOD);\r\nbool storm = false;\r\nif (!time_in_range(jiffies, start, end)) {\r\ndev_priv->hotplug.stats[pin].last_jiffies = jiffies;\r\ndev_priv->hotplug.stats[pin].count = 0;\r\nDRM_DEBUG_KMS("Received HPD interrupt on PIN %d - cnt: 0\n", pin);\r\n} else if (dev_priv->hotplug.stats[pin].count > HPD_STORM_THRESHOLD) {\r\ndev_priv->hotplug.stats[pin].state = HPD_MARK_DISABLED;\r\nDRM_DEBUG_KMS("HPD interrupt storm detected on PIN %d\n", pin);\r\nstorm = true;\r\n} else {\r\ndev_priv->hotplug.stats[pin].count++;\r\nDRM_DEBUG_KMS("Received HPD interrupt on PIN %d - cnt: %d\n", pin,\r\ndev_priv->hotplug.stats[pin].count);\r\n}\r\nreturn storm;\r\n}\r\nstatic void intel_hpd_irq_storm_disable(struct drm_i915_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nstruct intel_connector *intel_connector;\r\nstruct intel_encoder *intel_encoder;\r\nstruct drm_connector *connector;\r\nenum hpd_pin pin;\r\nbool hpd_disabled = false;\r\nassert_spin_locked(&dev_priv->irq_lock);\r\nlist_for_each_entry(connector, &mode_config->connector_list, head) {\r\nif (connector->polled != DRM_CONNECTOR_POLL_HPD)\r\ncontinue;\r\nintel_connector = to_intel_connector(connector);\r\nintel_encoder = intel_connector->encoder;\r\nif (!intel_encoder)\r\ncontinue;\r\npin = intel_encoder->hpd_pin;\r\nif (pin == HPD_NONE ||\r\ndev_priv->hotplug.stats[pin].state != HPD_MARK_DISABLED)\r\ncontinue;\r\nDRM_INFO("HPD interrupt storm detected on connector %s: "\r\n"switching from hotplug detection to polling\n",\r\nconnector->name);\r\ndev_priv->hotplug.stats[pin].state = HPD_DISABLED;\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT\r\n| DRM_CONNECTOR_POLL_DISCONNECT;\r\nhpd_disabled = true;\r\n}\r\nif (hpd_disabled) {\r\ndrm_kms_helper_poll_enable_locked(dev);\r\nmod_delayed_work(system_wq, &dev_priv->hotplug.reenable_work,\r\nmsecs_to_jiffies(HPD_STORM_REENABLE_DELAY));\r\n}\r\n}\r\nstatic void intel_hpd_irq_storm_reenable_work(struct work_struct *work)\r\n{\r\nstruct drm_i915_private *dev_priv =\r\ncontainer_of(work, typeof(*dev_priv),\r\nhotplug.reenable_work.work);\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nint i;\r\nintel_runtime_pm_get(dev_priv);\r\nspin_lock_irq(&dev_priv->irq_lock);\r\nfor_each_hpd_pin(i) {\r\nstruct drm_connector *connector;\r\nif (dev_priv->hotplug.stats[i].state != HPD_DISABLED)\r\ncontinue;\r\ndev_priv->hotplug.stats[i].state = HPD_ENABLED;\r\nlist_for_each_entry(connector, &mode_config->connector_list, head) {\r\nstruct intel_connector *intel_connector = to_intel_connector(connector);\r\nif (intel_connector->encoder->hpd_pin == i) {\r\nif (connector->polled != intel_connector->polled)\r\nDRM_DEBUG_DRIVER("Reenabling HPD on connector %s\n",\r\nconnector->name);\r\nconnector->polled = intel_connector->polled;\r\nif (!connector->polled)\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\n}\r\n}\r\n}\r\nif (dev_priv->display.hpd_irq_setup)\r\ndev_priv->display.hpd_irq_setup(dev);\r\nspin_unlock_irq(&dev_priv->irq_lock);\r\nintel_runtime_pm_put(dev_priv);\r\n}\r\nstatic bool intel_hpd_irq_event(struct drm_device *dev,\r\nstruct drm_connector *connector)\r\n{\r\nenum drm_connector_status old_status;\r\nWARN_ON(!mutex_is_locked(&dev->mode_config.mutex));\r\nold_status = connector->status;\r\nconnector->status = connector->funcs->detect(connector, false);\r\nif (old_status == connector->status)\r\nreturn false;\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %s to %s\n",\r\nconnector->base.id,\r\nconnector->name,\r\ndrm_get_connector_status_name(old_status),\r\ndrm_get_connector_status_name(connector->status));\r\nreturn true;\r\n}\r\nstatic void i915_digport_work_func(struct work_struct *work)\r\n{\r\nstruct drm_i915_private *dev_priv =\r\ncontainer_of(work, struct drm_i915_private, hotplug.dig_port_work);\r\nu32 long_port_mask, short_port_mask;\r\nstruct intel_digital_port *intel_dig_port;\r\nint i;\r\nu32 old_bits = 0;\r\nspin_lock_irq(&dev_priv->irq_lock);\r\nlong_port_mask = dev_priv->hotplug.long_port_mask;\r\ndev_priv->hotplug.long_port_mask = 0;\r\nshort_port_mask = dev_priv->hotplug.short_port_mask;\r\ndev_priv->hotplug.short_port_mask = 0;\r\nspin_unlock_irq(&dev_priv->irq_lock);\r\nfor (i = 0; i < I915_MAX_PORTS; i++) {\r\nbool valid = false;\r\nbool long_hpd = false;\r\nintel_dig_port = dev_priv->hotplug.irq_port[i];\r\nif (!intel_dig_port || !intel_dig_port->hpd_pulse)\r\ncontinue;\r\nif (long_port_mask & (1 << i)) {\r\nvalid = true;\r\nlong_hpd = true;\r\n} else if (short_port_mask & (1 << i))\r\nvalid = true;\r\nif (valid) {\r\nenum irqreturn ret;\r\nret = intel_dig_port->hpd_pulse(intel_dig_port, long_hpd);\r\nif (ret == IRQ_NONE) {\r\nold_bits |= (1 << intel_dig_port->base.hpd_pin);\r\n}\r\n}\r\n}\r\nif (old_bits) {\r\nspin_lock_irq(&dev_priv->irq_lock);\r\ndev_priv->hotplug.event_bits |= old_bits;\r\nspin_unlock_irq(&dev_priv->irq_lock);\r\nschedule_work(&dev_priv->hotplug.hotplug_work);\r\n}\r\n}\r\nstatic void i915_hotplug_work_func(struct work_struct *work)\r\n{\r\nstruct drm_i915_private *dev_priv =\r\ncontainer_of(work, struct drm_i915_private, hotplug.hotplug_work);\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nstruct intel_connector *intel_connector;\r\nstruct intel_encoder *intel_encoder;\r\nstruct drm_connector *connector;\r\nbool changed = false;\r\nu32 hpd_event_bits;\r\nmutex_lock(&mode_config->mutex);\r\nDRM_DEBUG_KMS("running encoder hotplug functions\n");\r\nspin_lock_irq(&dev_priv->irq_lock);\r\nhpd_event_bits = dev_priv->hotplug.event_bits;\r\ndev_priv->hotplug.event_bits = 0;\r\nintel_hpd_irq_storm_disable(dev_priv);\r\nspin_unlock_irq(&dev_priv->irq_lock);\r\nlist_for_each_entry(connector, &mode_config->connector_list, head) {\r\nintel_connector = to_intel_connector(connector);\r\nif (!intel_connector->encoder)\r\ncontinue;\r\nintel_encoder = intel_connector->encoder;\r\nif (hpd_event_bits & (1 << intel_encoder->hpd_pin)) {\r\nDRM_DEBUG_KMS("Connector %s (pin %i) received hotplug event.\n",\r\nconnector->name, intel_encoder->hpd_pin);\r\nif (intel_encoder->hot_plug)\r\nintel_encoder->hot_plug(intel_encoder);\r\nif (intel_hpd_irq_event(dev, connector))\r\nchanged = true;\r\n}\r\n}\r\nmutex_unlock(&mode_config->mutex);\r\nif (changed)\r\ndrm_kms_helper_hotplug_event(dev);\r\n}\r\nvoid intel_hpd_irq_handler(struct drm_device *dev,\r\nu32 pin_mask, u32 long_mask)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nint i;\r\nenum port port;\r\nbool storm_detected = false;\r\nbool queue_dig = false, queue_hp = false;\r\nbool is_dig_port;\r\nif (!pin_mask)\r\nreturn;\r\nspin_lock(&dev_priv->irq_lock);\r\nfor_each_hpd_pin(i) {\r\nif (!(BIT(i) & pin_mask))\r\ncontinue;\r\nis_dig_port = intel_hpd_pin_to_port(i, &port) &&\r\ndev_priv->hotplug.irq_port[port];\r\nif (is_dig_port) {\r\nbool long_hpd = long_mask & BIT(i);\r\nDRM_DEBUG_DRIVER("digital hpd port %c - %s\n", port_name(port),\r\nlong_hpd ? "long" : "short");\r\nqueue_dig = true;\r\nif (long_hpd) {\r\ndev_priv->hotplug.long_port_mask |= (1 << port);\r\n} else {\r\ndev_priv->hotplug.short_port_mask |= (1 << port);\r\ncontinue;\r\n}\r\n}\r\nif (dev_priv->hotplug.stats[i].state == HPD_DISABLED) {\r\nWARN_ONCE(INTEL_INFO(dev)->gen >= 5 && !IS_VALLEYVIEW(dev),\r\n"Received HPD interrupt on pin %d although disabled\n", i);\r\ncontinue;\r\n}\r\nif (dev_priv->hotplug.stats[i].state != HPD_ENABLED)\r\ncontinue;\r\nif (!is_dig_port) {\r\ndev_priv->hotplug.event_bits |= BIT(i);\r\nqueue_hp = true;\r\n}\r\nif (intel_hpd_irq_storm_detect(dev_priv, i)) {\r\ndev_priv->hotplug.event_bits &= ~BIT(i);\r\nstorm_detected = true;\r\n}\r\n}\r\nif (storm_detected)\r\ndev_priv->display.hpd_irq_setup(dev);\r\nspin_unlock(&dev_priv->irq_lock);\r\nif (queue_dig)\r\nqueue_work(dev_priv->hotplug.dp_wq, &dev_priv->hotplug.dig_port_work);\r\nif (queue_hp)\r\nschedule_work(&dev_priv->hotplug.hotplug_work);\r\n}\r\nvoid intel_hpd_init(struct drm_i915_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nstruct drm_connector *connector;\r\nint i;\r\nfor_each_hpd_pin(i) {\r\ndev_priv->hotplug.stats[i].count = 0;\r\ndev_priv->hotplug.stats[i].state = HPD_ENABLED;\r\n}\r\nlist_for_each_entry(connector, &mode_config->connector_list, head) {\r\nstruct intel_connector *intel_connector = to_intel_connector(connector);\r\nconnector->polled = intel_connector->polled;\r\nif (connector->encoder && !connector->polled && I915_HAS_HOTPLUG(dev) && intel_connector->encoder->hpd_pin > HPD_NONE)\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\nif (intel_connector->mst_port)\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\n}\r\nspin_lock_irq(&dev_priv->irq_lock);\r\nif (dev_priv->display.hpd_irq_setup)\r\ndev_priv->display.hpd_irq_setup(dev);\r\nspin_unlock_irq(&dev_priv->irq_lock);\r\n}\r\nvoid intel_hpd_init_work(struct drm_i915_private *dev_priv)\r\n{\r\nINIT_WORK(&dev_priv->hotplug.hotplug_work, i915_hotplug_work_func);\r\nINIT_WORK(&dev_priv->hotplug.dig_port_work, i915_digport_work_func);\r\nINIT_DELAYED_WORK(&dev_priv->hotplug.reenable_work,\r\nintel_hpd_irq_storm_reenable_work);\r\n}\r\nvoid intel_hpd_cancel_work(struct drm_i915_private *dev_priv)\r\n{\r\nspin_lock_irq(&dev_priv->irq_lock);\r\ndev_priv->hotplug.long_port_mask = 0;\r\ndev_priv->hotplug.short_port_mask = 0;\r\ndev_priv->hotplug.event_bits = 0;\r\nspin_unlock_irq(&dev_priv->irq_lock);\r\ncancel_work_sync(&dev_priv->hotplug.dig_port_work);\r\ncancel_work_sync(&dev_priv->hotplug.hotplug_work);\r\ncancel_delayed_work_sync(&dev_priv->hotplug.reenable_work);\r\n}
