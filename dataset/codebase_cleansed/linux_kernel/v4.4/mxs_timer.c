static inline void timrot_irq_disable(void)\r\n{\r\n__raw_writel(BM_TIMROT_TIMCTRLn_IRQ_EN, mxs_timrot_base +\r\nHW_TIMROT_TIMCTRLn(0) + STMP_OFFSET_REG_CLR);\r\n}\r\nstatic inline void timrot_irq_enable(void)\r\n{\r\n__raw_writel(BM_TIMROT_TIMCTRLn_IRQ_EN, mxs_timrot_base +\r\nHW_TIMROT_TIMCTRLn(0) + STMP_OFFSET_REG_SET);\r\n}\r\nstatic void timrot_irq_acknowledge(void)\r\n{\r\n__raw_writel(BM_TIMROT_TIMCTRLn_IRQ, mxs_timrot_base +\r\nHW_TIMROT_TIMCTRLn(0) + STMP_OFFSET_REG_CLR);\r\n}\r\nstatic cycle_t timrotv1_get_cycles(struct clocksource *cs)\r\n{\r\nreturn ~((__raw_readl(mxs_timrot_base + HW_TIMROT_TIMCOUNTn(1))\r\n& 0xffff0000) >> 16);\r\n}\r\nstatic int timrotv1_set_next_event(unsigned long evt,\r\nstruct clock_event_device *dev)\r\n{\r\n__raw_writel(evt, mxs_timrot_base + HW_TIMROT_TIMCOUNTn(0));\r\nreturn 0;\r\n}\r\nstatic int timrotv2_set_next_event(unsigned long evt,\r\nstruct clock_event_device *dev)\r\n{\r\n__raw_writel(evt, mxs_timrot_base + HW_TIMROT_FIXED_COUNTn(0));\r\nreturn 0;\r\n}\r\nstatic irqreturn_t mxs_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\ntimrot_irq_acknowledge();\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mxs_irq_clear(char *state)\r\n{\r\ntimrot_irq_disable();\r\nif (timrot_is_v1())\r\n__raw_writel(0xffff, mxs_timrot_base + HW_TIMROT_TIMCOUNTn(1));\r\nelse\r\n__raw_writel(0xffffffff,\r\nmxs_timrot_base + HW_TIMROT_FIXED_COUNTn(1));\r\ntimrot_irq_acknowledge();\r\n#ifdef DEBUG\r\npr_info("%s: changing mode to %s\n", __func__, state)\r\n#endif\r\n}\r\nstatic int mxs_shutdown(struct clock_event_device *evt)\r\n{\r\nmxs_irq_clear("shutdown");\r\nreturn 0;\r\n}\r\nstatic int mxs_set_oneshot(struct clock_event_device *evt)\r\n{\r\nif (clockevent_state_oneshot(evt))\r\nmxs_irq_clear("oneshot");\r\ntimrot_irq_enable();\r\nreturn 0;\r\n}\r\nstatic int __init mxs_clockevent_init(struct clk *timer_clk)\r\n{\r\nif (timrot_is_v1())\r\nmxs_clockevent_device.set_next_event = timrotv1_set_next_event;\r\nmxs_clockevent_device.cpumask = cpumask_of(0);\r\nclockevents_config_and_register(&mxs_clockevent_device,\r\nclk_get_rate(timer_clk),\r\ntimrot_is_v1() ? 0xf : 0x2,\r\ntimrot_is_v1() ? 0xfffe : 0xfffffffe);\r\nreturn 0;\r\n}\r\nstatic u64 notrace mxs_read_sched_clock_v2(void)\r\n{\r\nreturn ~readl_relaxed(mxs_timrot_base + HW_TIMROT_RUNNING_COUNTn(1));\r\n}\r\nstatic int __init mxs_clocksource_init(struct clk *timer_clk)\r\n{\r\nunsigned int c = clk_get_rate(timer_clk);\r\nif (timrot_is_v1())\r\nclocksource_register_hz(&clocksource_mxs, c);\r\nelse {\r\nclocksource_mmio_init(mxs_timrot_base + HW_TIMROT_RUNNING_COUNTn(1),\r\n"mxs_timer", c, 200, 32, clocksource_mmio_readl_down);\r\nsched_clock_register(mxs_read_sched_clock_v2, 32, c);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init mxs_timer_init(struct device_node *np)\r\n{\r\nstruct clk *timer_clk;\r\nint irq;\r\nmxs_timrot_base = of_iomap(np, 0);\r\nWARN_ON(!mxs_timrot_base);\r\ntimer_clk = of_clk_get(np, 0);\r\nif (IS_ERR(timer_clk)) {\r\npr_err("%s: failed to get clk\n", __func__);\r\nreturn;\r\n}\r\nclk_prepare_enable(timer_clk);\r\nstmp_reset_block(mxs_timrot_base + HW_TIMROT_ROTCTRL);\r\ntimrot_major_version = __raw_readl(mxs_timrot_base +\r\n(of_device_is_compatible(np, "fsl,imx23-timrot") ?\r\nMX23_TIMROT_VERSION_OFFSET :\r\nMX28_TIMROT_VERSION_OFFSET));\r\ntimrot_major_version >>= BP_TIMROT_MAJOR_VERSION;\r\n__raw_writel((timrot_is_v1() ?\r\nBV_TIMROTv1_TIMCTRLn_SELECT__32KHZ_XTAL :\r\nBV_TIMROTv2_TIMCTRLn_SELECT__TICK_ALWAYS) |\r\nBM_TIMROT_TIMCTRLn_UPDATE |\r\nBM_TIMROT_TIMCTRLn_IRQ_EN,\r\nmxs_timrot_base + HW_TIMROT_TIMCTRLn(0));\r\n__raw_writel((timrot_is_v1() ?\r\nBV_TIMROTv1_TIMCTRLn_SELECT__32KHZ_XTAL :\r\nBV_TIMROTv2_TIMCTRLn_SELECT__TICK_ALWAYS) |\r\nBM_TIMROT_TIMCTRLn_RELOAD,\r\nmxs_timrot_base + HW_TIMROT_TIMCTRLn(1));\r\nif (timrot_is_v1())\r\n__raw_writel(0xffff,\r\nmxs_timrot_base + HW_TIMROT_TIMCOUNTn(1));\r\nelse\r\n__raw_writel(0xffffffff,\r\nmxs_timrot_base + HW_TIMROT_FIXED_COUNTn(1));\r\nmxs_clocksource_init(timer_clk);\r\nmxs_clockevent_init(timer_clk);\r\nirq = irq_of_parse_and_map(np, 0);\r\nsetup_irq(irq, &mxs_timer_irq);\r\n}
