static u8 reg_r(struct gspca_dev *gspca_dev,\r\n__u16 index)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn 0;\r\nret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\n0x00,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x00,\r\nindex,\r\ngspca_dev->usb_buf, 1,\r\n500);\r\nif (ret < 0) {\r\npr_err("reg_r err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\nreturn 0;\r\n}\r\nreturn gspca_dev->usb_buf[0];\r\n}\r\nstatic void reg_w(struct gspca_dev *gspca_dev,\r\n__u16 index, __u16 value)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\n0x01,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue,\r\nindex,\r\nNULL,\r\n0,\r\n500);\r\nif (ret < 0) {\r\npr_err("reg_w err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void rcv_val(struct gspca_dev *gspca_dev,\r\nint ads)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\nint alen, ret;\r\nreg_w(gspca_dev, 0x634, (ads >> 16) & 0xff);\r\nreg_w(gspca_dev, 0x635, (ads >> 8) & 0xff);\r\nreg_w(gspca_dev, 0x636, ads & 0xff);\r\nreg_w(gspca_dev, 0x637, 0);\r\nreg_w(gspca_dev, 0x638, 4);\r\nreg_w(gspca_dev, 0x639, 0);\r\nreg_w(gspca_dev, 0x63a, 0);\r\nreg_w(gspca_dev, 0x63b, 0);\r\nreg_w(gspca_dev, 0x630, 5);\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nret = usb_bulk_msg(dev,\r\nusb_rcvbulkpipe(dev, 0x05),\r\ngspca_dev->usb_buf,\r\n4,\r\n&alen,\r\n500);\r\nif (ret < 0) {\r\npr_err("rcv_val err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void snd_val(struct gspca_dev *gspca_dev,\r\nint ads,\r\nunsigned int val)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\nint alen, ret;\r\n__u8 seq = 0;\r\nif (ads == 0x003f08) {\r\nreg_r(gspca_dev, 0x0704);\r\nseq = reg_r(gspca_dev, 0x0705);\r\nreg_r(gspca_dev, 0x0650);\r\nreg_w(gspca_dev, 0x654, seq);\r\n} else {\r\nreg_w(gspca_dev, 0x654, (ads >> 16) & 0xff);\r\n}\r\nreg_w(gspca_dev, 0x655, (ads >> 8) & 0xff);\r\nreg_w(gspca_dev, 0x656, ads & 0xff);\r\nreg_w(gspca_dev, 0x657, 0);\r\nreg_w(gspca_dev, 0x658, 0x04);\r\nreg_w(gspca_dev, 0x659, 0);\r\nreg_w(gspca_dev, 0x65a, 0);\r\nreg_w(gspca_dev, 0x65b, 0);\r\nreg_w(gspca_dev, 0x650, 5);\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\ngspca_dev->usb_buf[0] = val >> 24;\r\ngspca_dev->usb_buf[1] = val >> 16;\r\ngspca_dev->usb_buf[2] = val >> 8;\r\ngspca_dev->usb_buf[3] = val;\r\nret = usb_bulk_msg(dev,\r\nusb_sndbulkpipe(dev, 6),\r\ngspca_dev->usb_buf,\r\n4,\r\n&alen,\r\n500);\r\nif (ret < 0) {\r\npr_err("snd_val err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n} else {\r\nif (ads == 0x003f08) {\r\nseq += 4;\r\nseq &= 0x3f;\r\nreg_w(gspca_dev, 0x705, seq);\r\n}\r\n}\r\n}\r\nstatic void set_par(struct gspca_dev *gspca_dev,\r\nint parval)\r\n{\r\nsnd_val(gspca_dev, 0x003f08, parval);\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nint parval;\r\nparval = 0x06000000\r\n+ (val << 16);\r\nset_par(gspca_dev, parval);\r\n}\r\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nint parval;\r\nparval = 0x07000000\r\n+ (val << 16);\r\nset_par(gspca_dev, parval);\r\n}\r\nstatic void setcolors(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nint parval;\r\nparval = 0x08000000\r\n+ (val << 16);\r\nset_par(gspca_dev, parval);\r\n}\r\nstatic void setlightfreq(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nset_par(gspca_dev, val == 1\r\n? 0x33640000\r\n: 0x33780000);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\ngspca_dev->cam.cam_mode = vga_mode;\r\ngspca_dev->cam.nmodes = ARRAY_SIZE(vga_mode);\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nu8 ret;\r\nusb_set_interface(gspca_dev->dev, gspca_dev->iface, 1);\r\nret = reg_r(gspca_dev, 0x0740);\r\nif (gspca_dev->usb_err >= 0) {\r\nif (ret != 0xff) {\r\npr_err("init reg: 0x%02x\n", ret);\r\ngspca_dev->usb_err = -EIO;\r\n}\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint ret, value;\r\njpeg_define(sd->jpeg_hdr, gspca_dev->pixfmt.height,\r\ngspca_dev->pixfmt.width,\r\n0x22);\r\njpeg_set_qual(sd->jpeg_hdr, QUALITY);\r\nusb_set_interface(gspca_dev->dev, gspca_dev->iface, 1);\r\nset_par(gspca_dev, 0x10000000);\r\nset_par(gspca_dev, 0x00000000);\r\nset_par(gspca_dev, 0x8002e001);\r\nset_par(gspca_dev, 0x14000000);\r\nif (gspca_dev->pixfmt.width > 320)\r\nvalue = 0x8002e001;\r\nelse\r\nvalue = 0x4001f000;\r\nset_par(gspca_dev, value);\r\nret = usb_set_interface(gspca_dev->dev,\r\ngspca_dev->iface,\r\ngspca_dev->alt);\r\nif (ret < 0) {\r\npr_err("set intf %d %d failed\n",\r\ngspca_dev->iface, gspca_dev->alt);\r\ngspca_dev->usb_err = ret;\r\ngoto out;\r\n}\r\nreg_r(gspca_dev, 0x0630);\r\nrcv_val(gspca_dev, 0x000020);\r\nreg_r(gspca_dev, 0x0650);\r\nsnd_val(gspca_dev, 0x000020, 0xffffffff);\r\nreg_w(gspca_dev, 0x0620, 0);\r\nreg_w(gspca_dev, 0x0630, 0);\r\nreg_w(gspca_dev, 0x0640, 0);\r\nreg_w(gspca_dev, 0x0650, 0);\r\nreg_w(gspca_dev, 0x0660, 0);\r\nset_par(gspca_dev, 0x09800000);\r\nset_par(gspca_dev, 0x0a800000);\r\nset_par(gspca_dev, 0x0b800000);\r\nset_par(gspca_dev, 0x0d030000);\r\nset_par(gspca_dev, 0x01000000);\r\nset_par(gspca_dev, 0x01000000);\r\nif (gspca_dev->usb_err >= 0)\r\nPDEBUG(D_STREAM, "camera started alt: 0x%02x",\r\ngspca_dev->alt);\r\nout:\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\nset_par(gspca_dev, 0x02000000);\r\nset_par(gspca_dev, 0x02000000);\r\nusb_set_interface(dev, gspca_dev->iface, 1);\r\nreg_r(gspca_dev, 0x0630);\r\nrcv_val(gspca_dev, 0x000020);\r\nreg_r(gspca_dev, 0x0650);\r\nsnd_val(gspca_dev, 0x000020, 0xffffffff);\r\nreg_w(gspca_dev, 0x0620, 0);\r\nreg_w(gspca_dev, 0x0630, 0);\r\nreg_w(gspca_dev, 0x0640, 0);\r\nreg_w(gspca_dev, 0x0650, 0);\r\nreg_w(gspca_dev, 0x0660, 0);\r\nPDEBUG(D_STREAM, "camera stopped");\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstatic unsigned char ffd9[] = {0xff, 0xd9};\r\nif (data[0] == 0xff && data[1] == 0xfe) {\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\nffd9, 2);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\nsd->jpeg_hdr, JPEG_HDR_SZ);\r\n#define STKHDRSZ 12\r\ndata += STKHDRSZ;\r\nlen -= STKHDRSZ;\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\ngspca_dev->usb_err = 0;\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsetbrightness(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nsetcontrast(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nsetcolors(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\nsetlightfreq(gspca_dev, ctrl->val);\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 4);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 127);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 127);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 127);\r\nv4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\r\nV4L2_CID_POWER_LINE_FREQUENCY,\r\nV4L2_CID_POWER_LINE_FREQUENCY_60HZ, 1,\r\nV4L2_CID_POWER_LINE_FREQUENCY_50HZ);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
