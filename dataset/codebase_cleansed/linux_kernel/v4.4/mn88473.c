static int mn88473_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *s)\r\n{\r\ns->min_delay_ms = 1000;\r\nreturn 0;\r\n}\r\nstatic int mn88473_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nstruct mn88473_dev *dev = i2c_get_clientdata(client);\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i;\r\nu32 if_frequency;\r\nu64 tmp;\r\nu8 delivery_system_val, if_val[3], bw_val[7];\r\ndev_dbg(&client->dev,\r\n"delivery_system=%u modulation=%u frequency=%u bandwidth_hz=%u symbol_rate=%u inversion=%d stream_id=%d\n",\r\nc->delivery_system,\r\nc->modulation,\r\nc->frequency,\r\nc->bandwidth_hz,\r\nc->symbol_rate,\r\nc->inversion,\r\nc->stream_id);\r\nif (!dev->warm) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBT:\r\ndelivery_system_val = 0x02;\r\nbreak;\r\ncase SYS_DVBT2:\r\ndelivery_system_val = 0x03;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\ndelivery_system_val = 0x04;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (c->bandwidth_hz <= 6000000) {\r\nmemcpy(bw_val, "\xe9\x55\x55\x1c\x29\x1c\x29", 7);\r\n} else if (c->bandwidth_hz <= 7000000) {\r\nmemcpy(bw_val, "\xc8\x00\x00\x17\x0a\x17\x0a", 7);\r\n} else if (c->bandwidth_hz <= 8000000) {\r\nmemcpy(bw_val, "\xaf\x00\x00\x11\xec\x11\xec", 7);\r\n} else {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (fe->ops.tuner_ops.set_params) {\r\nret = fe->ops.tuner_ops.set_params(fe);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (fe->ops.tuner_ops.get_if_frequency) {\r\nret = fe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&client->dev, "get_if_frequency=%d\n", if_frequency);\r\n} else {\r\nif_frequency = 0;\r\n}\r\ntmp = div_u64(if_frequency * (u64)(1<<24) + (dev->xtal / 2),\r\ndev->xtal);\r\nif_val[0] = ((tmp >> 16) & 0xff);\r\nif_val[1] = ((tmp >> 8) & 0xff);\r\nif_val[2] = ((tmp >> 0) & 0xff);\r\nret = regmap_write(dev->regmap[2], 0x05, 0x00);\r\nret = regmap_write(dev->regmap[2], 0xfb, 0x13);\r\nret = regmap_write(dev->regmap[2], 0xef, 0x13);\r\nret = regmap_write(dev->regmap[2], 0xf9, 0x13);\r\nret = regmap_write(dev->regmap[2], 0x00, 0x18);\r\nret = regmap_write(dev->regmap[2], 0x01, 0x01);\r\nret = regmap_write(dev->regmap[2], 0x02, 0x21);\r\nret = regmap_write(dev->regmap[2], 0x03, delivery_system_val);\r\nret = regmap_write(dev->regmap[2], 0x0b, 0x00);\r\nfor (i = 0; i < sizeof(if_val); i++) {\r\nret = regmap_write(dev->regmap[2], 0x10 + i, if_val[i]);\r\nif (ret)\r\ngoto err;\r\n}\r\nfor (i = 0; i < sizeof(bw_val); i++) {\r\nret = regmap_write(dev->regmap[2], 0x13 + i, bw_val[i]);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = regmap_write(dev->regmap[2], 0x2d, 0x3b);\r\nret = regmap_write(dev->regmap[2], 0x2e, 0x00);\r\nret = regmap_write(dev->regmap[2], 0x56, 0x0d);\r\nret = regmap_write(dev->regmap[0], 0x01, 0xba);\r\nret = regmap_write(dev->regmap[0], 0x02, 0x13);\r\nret = regmap_write(dev->regmap[0], 0x03, 0x80);\r\nret = regmap_write(dev->regmap[0], 0x04, 0xba);\r\nret = regmap_write(dev->regmap[0], 0x05, 0x91);\r\nret = regmap_write(dev->regmap[0], 0x07, 0xe7);\r\nret = regmap_write(dev->regmap[0], 0x08, 0x28);\r\nret = regmap_write(dev->regmap[0], 0x0a, 0x1a);\r\nret = regmap_write(dev->regmap[0], 0x13, 0x1f);\r\nret = regmap_write(dev->regmap[0], 0x19, 0x03);\r\nret = regmap_write(dev->regmap[0], 0x1d, 0xb0);\r\nret = regmap_write(dev->regmap[0], 0x2a, 0x72);\r\nret = regmap_write(dev->regmap[0], 0x2d, 0x00);\r\nret = regmap_write(dev->regmap[0], 0x3c, 0x00);\r\nret = regmap_write(dev->regmap[0], 0x3f, 0xf8);\r\nret = regmap_write(dev->regmap[0], 0x40, 0xf4);\r\nret = regmap_write(dev->regmap[0], 0x41, 0x08);\r\nret = regmap_write(dev->regmap[0], 0xd2, 0x29);\r\nret = regmap_write(dev->regmap[0], 0xd4, 0x55);\r\nret = regmap_write(dev->regmap[1], 0x10, 0x10);\r\nret = regmap_write(dev->regmap[1], 0x11, 0xab);\r\nret = regmap_write(dev->regmap[1], 0x12, 0x0d);\r\nret = regmap_write(dev->regmap[1], 0x13, 0xae);\r\nret = regmap_write(dev->regmap[1], 0x14, 0x1d);\r\nret = regmap_write(dev->regmap[1], 0x15, 0x9d);\r\nret = regmap_write(dev->regmap[1], 0xbe, 0x08);\r\nret = regmap_write(dev->regmap[2], 0x09, 0x08);\r\nret = regmap_write(dev->regmap[2], 0x08, 0x1d);\r\nret = regmap_write(dev->regmap[0], 0xb2, 0x37);\r\nret = regmap_write(dev->regmap[0], 0xd7, 0x04);\r\nret = regmap_write(dev->regmap[2], 0x32, 0x80);\r\nret = regmap_write(dev->regmap[2], 0x36, 0x00);\r\nret = regmap_write(dev->regmap[2], 0xf8, 0x9f);\r\nif (ret)\r\ngoto err;\r\ndev->delivery_system = c->delivery_system;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mn88473_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nstruct mn88473_dev *dev = i2c_get_clientdata(client);\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\nunsigned int utmp;\r\nint lock = 0;\r\n*status = 0;\r\nif (!dev->warm) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBT:\r\nret = regmap_read(dev->regmap[0], 0x62, &utmp);\r\nif (ret)\r\ngoto err;\r\nif (!(utmp & 0xA0)) {\r\nif ((utmp & 0xF) >= 0x03)\r\n*status |= FE_HAS_SIGNAL;\r\nif ((utmp & 0xF) >= 0x09)\r\nlock = 1;\r\n}\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = regmap_read(dev->regmap[2], 0x8B, &utmp);\r\nif (ret)\r\ngoto err;\r\nif (!(utmp & 0x40)) {\r\nif ((utmp & 0xF) >= 0x07)\r\n*status |= FE_HAS_SIGNAL;\r\nif ((utmp & 0xF) >= 0x0a)\r\n*status |= FE_HAS_CARRIER;\r\nif ((utmp & 0xF) >= 0x0d)\r\n*status |= FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\r\n}\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = regmap_read(dev->regmap[1], 0x85, &utmp);\r\nif (ret)\r\ngoto err;\r\nif (!(utmp & 0x40)) {\r\nret = regmap_read(dev->regmap[1], 0x89, &utmp);\r\nif (ret)\r\ngoto err;\r\nif (utmp & 0x01)\r\nlock = 1;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (lock)\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI |\r\nFE_HAS_SYNC | FE_HAS_LOCK;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mn88473_init(struct dvb_frontend *fe)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nstruct mn88473_dev *dev = i2c_get_clientdata(client);\r\nint ret, len, remaining;\r\nconst struct firmware *fw = NULL;\r\nu8 *fw_file = MN88473_FIRMWARE;\r\nunsigned int tmp;\r\ndev_dbg(&client->dev, "\n");\r\ndev->warm = false;\r\nret = regmap_read(dev->regmap[0], 0xf5, &tmp);\r\nif (ret)\r\ngoto err;\r\nif (!(tmp & 0x1)) {\r\ndev_info(&client->dev, "firmware already running\n");\r\ndev->warm = true;\r\nreturn 0;\r\n}\r\nret = request_firmware(&fw, fw_file, &client->dev);\r\nif (ret) {\r\ndev_err(&client->dev, "firmare file '%s' not found\n", fw_file);\r\ngoto err_request_firmware;\r\n}\r\ndev_info(&client->dev, "downloading firmware from file '%s'\n",\r\nfw_file);\r\nret = regmap_write(dev->regmap[0], 0xf5, 0x03);\r\nif (ret)\r\ngoto err;\r\nfor (remaining = fw->size; remaining > 0;\r\nremaining -= (dev->i2c_wr_max - 1)) {\r\nlen = remaining;\r\nif (len > (dev->i2c_wr_max - 1))\r\nlen = dev->i2c_wr_max - 1;\r\nret = regmap_bulk_write(dev->regmap[0], 0xf6,\r\n&fw->data[fw->size - remaining], len);\r\nif (ret) {\r\ndev_err(&client->dev, "firmware download failed=%d\n",\r\nret);\r\ngoto err;\r\n}\r\n}\r\nret = regmap_read(dev->regmap[0], 0xf8, &tmp);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"parity reg read failed=%d\n", ret);\r\ngoto err;\r\n}\r\nif (tmp & 0x10) {\r\ndev_err(&client->dev,\r\n"firmware parity check failed=0x%x\n", tmp);\r\ngoto err;\r\n}\r\ndev_err(&client->dev, "firmware parity check succeeded=0x%x\n", tmp);\r\nret = regmap_write(dev->regmap[0], 0xf5, 0x00);\r\nif (ret)\r\ngoto err;\r\nrelease_firmware(fw);\r\nfw = NULL;\r\ndev->warm = true;\r\nreturn 0;\r\nerr:\r\nrelease_firmware(fw);\r\nerr_request_firmware:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mn88473_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nstruct mn88473_dev *dev = i2c_get_clientdata(client);\r\nint ret;\r\ndev_dbg(&client->dev, "\n");\r\nret = regmap_write(dev->regmap[2], 0x05, 0x3e);\r\nif (ret)\r\ngoto err;\r\ndev->delivery_system = SYS_UNDEFINED;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mn88473_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct mn88473_config *config = client->dev.platform_data;\r\nstruct mn88473_dev *dev;\r\nint ret;\r\nunsigned int utmp;\r\nstatic const struct regmap_config regmap_config = {\r\n.reg_bits = 8,\r\n.val_bits = 8,\r\n};\r\ndev_dbg(&client->dev, "\n");\r\nif (config->fe == NULL) {\r\ndev_err(&client->dev, "frontend pointer not defined\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev->i2c_wr_max = config->i2c_wr_max;\r\nif (!config->xtal)\r\ndev->xtal = 25000000;\r\nelse\r\ndev->xtal = config->xtal;\r\ndev->client[0] = client;\r\ndev->regmap[0] = regmap_init_i2c(dev->client[0], &regmap_config);\r\nif (IS_ERR(dev->regmap[0])) {\r\nret = PTR_ERR(dev->regmap[0]);\r\ngoto err_kfree;\r\n}\r\nret = regmap_read(dev->regmap[0], 0x00, &utmp);\r\nif (ret)\r\ngoto err_regmap_0_regmap_exit;\r\ndev->client[1] = i2c_new_dummy(client->adapter, 0x1a);\r\nif (dev->client[1] == NULL) {\r\nret = -ENODEV;\r\ndev_err(&client->dev, "I2C registration failed\n");\r\nif (ret)\r\ngoto err_regmap_0_regmap_exit;\r\n}\r\ndev->regmap[1] = regmap_init_i2c(dev->client[1], &regmap_config);\r\nif (IS_ERR(dev->regmap[1])) {\r\nret = PTR_ERR(dev->regmap[1]);\r\ngoto err_client_1_i2c_unregister_device;\r\n}\r\ni2c_set_clientdata(dev->client[1], dev);\r\ndev->client[2] = i2c_new_dummy(client->adapter, 0x1c);\r\nif (dev->client[2] == NULL) {\r\nret = -ENODEV;\r\ndev_err(&client->dev, "2nd I2C registration failed\n");\r\nif (ret)\r\ngoto err_regmap_1_regmap_exit;\r\n}\r\ndev->regmap[2] = regmap_init_i2c(dev->client[2], &regmap_config);\r\nif (IS_ERR(dev->regmap[2])) {\r\nret = PTR_ERR(dev->regmap[2]);\r\ngoto err_client_2_i2c_unregister_device;\r\n}\r\ni2c_set_clientdata(dev->client[2], dev);\r\nmemcpy(&dev->fe.ops, &mn88473_ops, sizeof(struct dvb_frontend_ops));\r\ndev->fe.demodulator_priv = client;\r\n*config->fe = &dev->fe;\r\ni2c_set_clientdata(client, dev);\r\ndev_info(&dev->client[0]->dev, "Panasonic MN88473 successfully attached\n");\r\nreturn 0;\r\nerr_client_2_i2c_unregister_device:\r\ni2c_unregister_device(dev->client[2]);\r\nerr_regmap_1_regmap_exit:\r\nregmap_exit(dev->regmap[1]);\r\nerr_client_1_i2c_unregister_device:\r\ni2c_unregister_device(dev->client[1]);\r\nerr_regmap_0_regmap_exit:\r\nregmap_exit(dev->regmap[0]);\r\nerr_kfree:\r\nkfree(dev);\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mn88473_remove(struct i2c_client *client)\r\n{\r\nstruct mn88473_dev *dev = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\nregmap_exit(dev->regmap[2]);\r\ni2c_unregister_device(dev->client[2]);\r\nregmap_exit(dev->regmap[1]);\r\ni2c_unregister_device(dev->client[1]);\r\nregmap_exit(dev->regmap[0]);\r\nkfree(dev);\r\nreturn 0;\r\n}
