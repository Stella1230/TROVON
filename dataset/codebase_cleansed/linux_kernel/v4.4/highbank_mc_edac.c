static irqreturn_t highbank_mc_err_handler(int irq, void *dev_id)\r\n{\r\nstruct mem_ctl_info *mci = dev_id;\r\nstruct hb_mc_drvdata *drvdata = mci->pvt_info;\r\nu32 status, err_addr;\r\nstatus = readl(drvdata->mc_int_base + HB_DDR_ECC_INT_STATUS);\r\nif (status & HB_DDR_ECC_INT_STAT_UE) {\r\nerr_addr = readl(drvdata->mc_err_base + HB_DDR_ECC_U_ERR_ADDR);\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\r\nerr_addr >> PAGE_SHIFT,\r\nerr_addr & ~PAGE_MASK, 0,\r\n0, 0, -1,\r\nmci->ctl_name, "");\r\n}\r\nif (status & HB_DDR_ECC_INT_STAT_CE) {\r\nu32 syndrome = readl(drvdata->mc_err_base + HB_DDR_ECC_C_ERR_STAT);\r\nsyndrome = (syndrome >> 8) & 0xff;\r\nerr_addr = readl(drvdata->mc_err_base + HB_DDR_ECC_C_ERR_ADDR);\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\nerr_addr >> PAGE_SHIFT,\r\nerr_addr & ~PAGE_MASK, syndrome,\r\n0, 0, -1,\r\nmci->ctl_name, "");\r\n}\r\nwritel(status, drvdata->mc_int_base + HB_DDR_ECC_INT_ACK);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void highbank_mc_err_inject(struct mem_ctl_info *mci, u8 synd)\r\n{\r\nstruct hb_mc_drvdata *pdata = mci->pvt_info;\r\nu32 reg;\r\nreg = readl(pdata->mc_err_base + HB_DDR_ECC_OPT);\r\nreg &= HB_DDR_ECC_OPT_MODE_MASK;\r\nreg |= (synd << HB_DDR_ECC_OPT_XOR_SHIFT) | HB_DDR_ECC_OPT_FWC;\r\nwritel(reg, pdata->mc_err_base + HB_DDR_ECC_OPT);\r\n}\r\nstatic ssize_t highbank_mc_inject_ctrl(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nu8 synd;\r\nif (kstrtou8(buf, 16, &synd))\r\nreturn -EINVAL;\r\nhighbank_mc_err_inject(mci, synd);\r\nreturn count;\r\n}\r\nstatic int highbank_mc_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *id;\r\nconst struct hb_mc_settings *settings;\r\nstruct edac_mc_layer layers[2];\r\nstruct mem_ctl_info *mci;\r\nstruct hb_mc_drvdata *drvdata;\r\nstruct dimm_info *dimm;\r\nstruct resource *r;\r\nvoid __iomem *base;\r\nu32 control;\r\nint irq;\r\nint res = 0;\r\nid = of_match_device(hb_ddr_ctrl_of_match, &pdev->dev);\r\nif (!id)\r\nreturn -ENODEV;\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = 1;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = 1;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers,\r\nsizeof(struct hb_mc_drvdata));\r\nif (!mci)\r\nreturn -ENOMEM;\r\nmci->pdev = &pdev->dev;\r\ndrvdata = mci->pvt_info;\r\nplatform_set_drvdata(pdev, mci);\r\nif (!devres_open_group(&pdev->dev, NULL, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(&pdev->dev, "Unable to get mem resource\n");\r\nres = -ENODEV;\r\ngoto err;\r\n}\r\nif (!devm_request_mem_region(&pdev->dev, r->start,\r\nresource_size(r), dev_name(&pdev->dev))) {\r\ndev_err(&pdev->dev, "Error while requesting mem region\n");\r\nres = -EBUSY;\r\ngoto err;\r\n}\r\nbase = devm_ioremap(&pdev->dev, r->start, resource_size(r));\r\nif (!base) {\r\ndev_err(&pdev->dev, "Unable to map regs\n");\r\nres = -ENOMEM;\r\ngoto err;\r\n}\r\nsettings = id->data;\r\ndrvdata->mc_err_base = base + settings->err_offset;\r\ndrvdata->mc_int_base = base + settings->int_offset;\r\ncontrol = readl(drvdata->mc_err_base + HB_DDR_ECC_OPT) & 0x3;\r\nif (!control || (control == 0x2)) {\r\ndev_err(&pdev->dev, "No ECC present, or ECC disabled\n");\r\nres = -ENODEV;\r\ngoto err;\r\n}\r\nmci->mtype_cap = MEM_FLAG_DDR3;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_SECDED;\r\nmci->mod_name = pdev->dev.driver->name;\r\nmci->mod_ver = "1";\r\nmci->ctl_name = id->compatible;\r\nmci->dev_name = dev_name(&pdev->dev);\r\nmci->scrub_mode = SCRUB_SW_SRC;\r\ndimm = *mci->dimms;\r\ndimm->nr_pages = (~0UL >> PAGE_SHIFT) + 1;\r\ndimm->grain = 8;\r\ndimm->dtype = DEV_X8;\r\ndimm->mtype = MEM_DDR3;\r\ndimm->edac_mode = EDAC_SECDED;\r\nres = edac_mc_add_mc_with_groups(mci, highbank_dev_groups);\r\nif (res < 0)\r\ngoto err;\r\nirq = platform_get_irq(pdev, 0);\r\nres = devm_request_irq(&pdev->dev, irq, highbank_mc_err_handler,\r\n0, dev_name(&pdev->dev), mci);\r\nif (res < 0) {\r\ndev_err(&pdev->dev, "Unable to request irq %d\n", irq);\r\ngoto err2;\r\n}\r\ndevres_close_group(&pdev->dev, NULL);\r\nreturn 0;\r\nerr2:\r\nedac_mc_del_mc(&pdev->dev);\r\nerr:\r\ndevres_release_group(&pdev->dev, NULL);\r\nedac_mc_free(mci);\r\nreturn res;\r\n}\r\nstatic int highbank_mc_remove(struct platform_device *pdev)\r\n{\r\nstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\r\nedac_mc_del_mc(&pdev->dev);\r\nedac_mc_free(mci);\r\nreturn 0;\r\n}
