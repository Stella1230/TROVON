static inline void inc_wptr(unsigned int *wptr, unsigned int increment_bytes,\r\nunsigned int buffer_size_bytes)\r\n{\r\nunsigned int temp = *wptr + increment_bytes / sizeof(uint32_t);\r\nBUG_ON((temp * sizeof(uint32_t)) > buffer_size_bytes);\r\n*wptr = temp;\r\n}\r\nstatic unsigned int build_pm4_header(unsigned int opcode, size_t packet_size)\r\n{\r\nunion PM4_MES_TYPE_3_HEADER header;\r\nheader.u32all = 0;\r\nheader.opcode = opcode;\r\nheader.count = packet_size/sizeof(uint32_t) - 2;\r\nheader.type = PM4_TYPE_3;\r\nreturn header.u32all;\r\n}\r\nstatic void pm_calc_rlib_size(struct packet_manager *pm,\r\nunsigned int *rlib_size,\r\nbool *over_subscription)\r\n{\r\nunsigned int process_count, queue_count;\r\nunsigned int map_queue_size;\r\nBUG_ON(!pm || !rlib_size || !over_subscription);\r\nprocess_count = pm->dqm->processes_count;\r\nqueue_count = pm->dqm->queue_count;\r\n*over_subscription = false;\r\nif ((process_count > 1) ||\r\nqueue_count > PIPE_PER_ME_CP_SCHEDULING * QUEUES_PER_PIPE) {\r\n*over_subscription = true;\r\npr_debug("kfd: over subscribed runlist\n");\r\n}\r\nmap_queue_size =\r\n(pm->dqm->dev->device_info->asic_family == CHIP_CARRIZO) ?\r\nsizeof(struct pm4_mes_map_queues) :\r\nsizeof(struct pm4_map_queues);\r\n*rlib_size = process_count * sizeof(struct pm4_map_process) +\r\nqueue_count * map_queue_size;\r\nif (*over_subscription)\r\n*rlib_size += sizeof(struct pm4_runlist);\r\npr_debug("kfd: runlist ib size %d\n", *rlib_size);\r\n}\r\nstatic int pm_allocate_runlist_ib(struct packet_manager *pm,\r\nunsigned int **rl_buffer,\r\nuint64_t *rl_gpu_buffer,\r\nunsigned int *rl_buffer_size,\r\nbool *is_over_subscription)\r\n{\r\nint retval;\r\nBUG_ON(!pm);\r\nBUG_ON(pm->allocated == true);\r\nBUG_ON(is_over_subscription == NULL);\r\npm_calc_rlib_size(pm, rl_buffer_size, is_over_subscription);\r\nretval = kfd_gtt_sa_allocate(pm->dqm->dev, *rl_buffer_size,\r\n&pm->ib_buffer_obj);\r\nif (retval != 0) {\r\npr_err("kfd: failed to allocate runlist IB\n");\r\nreturn retval;\r\n}\r\n*(void **)rl_buffer = pm->ib_buffer_obj->cpu_ptr;\r\n*rl_gpu_buffer = pm->ib_buffer_obj->gpu_addr;\r\nmemset(*rl_buffer, 0, *rl_buffer_size);\r\npm->allocated = true;\r\nreturn retval;\r\n}\r\nstatic int pm_create_runlist(struct packet_manager *pm, uint32_t *buffer,\r\nuint64_t ib, size_t ib_size_in_dwords, bool chain)\r\n{\r\nstruct pm4_runlist *packet;\r\nBUG_ON(!pm || !buffer || !ib);\r\npacket = (struct pm4_runlist *)buffer;\r\nmemset(buffer, 0, sizeof(struct pm4_runlist));\r\npacket->header.u32all = build_pm4_header(IT_RUN_LIST,\r\nsizeof(struct pm4_runlist));\r\npacket->bitfields4.ib_size = ib_size_in_dwords;\r\npacket->bitfields4.chain = chain ? 1 : 0;\r\npacket->bitfields4.offload_polling = 0;\r\npacket->bitfields4.valid = 1;\r\npacket->ordinal2 = lower_32_bits(ib);\r\npacket->bitfields3.ib_base_hi = upper_32_bits(ib);\r\nreturn 0;\r\n}\r\nstatic int pm_create_map_process(struct packet_manager *pm, uint32_t *buffer,\r\nstruct qcm_process_device *qpd)\r\n{\r\nstruct pm4_map_process *packet;\r\nstruct queue *cur;\r\nuint32_t num_queues;\r\nBUG_ON(!pm || !buffer || !qpd);\r\npacket = (struct pm4_map_process *)buffer;\r\npr_debug("kfd: In func %s\n", __func__);\r\nmemset(buffer, 0, sizeof(struct pm4_map_process));\r\npacket->header.u32all = build_pm4_header(IT_MAP_PROCESS,\r\nsizeof(struct pm4_map_process));\r\npacket->bitfields2.diq_enable = (qpd->is_debug) ? 1 : 0;\r\npacket->bitfields2.process_quantum = 1;\r\npacket->bitfields2.pasid = qpd->pqm->process->pasid;\r\npacket->bitfields3.page_table_base = qpd->page_table_base;\r\npacket->bitfields10.gds_size = qpd->gds_size;\r\npacket->bitfields10.num_gws = qpd->num_gws;\r\npacket->bitfields10.num_oac = qpd->num_oac;\r\nnum_queues = 0;\r\nlist_for_each_entry(cur, &qpd->queues_list, list)\r\nnum_queues++;\r\npacket->bitfields10.num_queues = (qpd->is_debug) ? 0 : num_queues;\r\npacket->sh_mem_config = qpd->sh_mem_config;\r\npacket->sh_mem_bases = qpd->sh_mem_bases;\r\npacket->sh_mem_ape1_base = qpd->sh_mem_ape1_base;\r\npacket->sh_mem_ape1_limit = qpd->sh_mem_ape1_limit;\r\npacket->gds_addr_lo = lower_32_bits(qpd->gds_context_area);\r\npacket->gds_addr_hi = upper_32_bits(qpd->gds_context_area);\r\nreturn 0;\r\n}\r\nstatic int pm_create_map_queue_vi(struct packet_manager *pm, uint32_t *buffer,\r\nstruct queue *q, bool is_static)\r\n{\r\nstruct pm4_mes_map_queues *packet;\r\nbool use_static = is_static;\r\nBUG_ON(!pm || !buffer || !q);\r\npr_debug("kfd: In func %s\n", __func__);\r\npacket = (struct pm4_mes_map_queues *)buffer;\r\nmemset(buffer, 0, sizeof(struct pm4_map_queues));\r\npacket->header.u32all = build_pm4_header(IT_MAP_QUEUES,\r\nsizeof(struct pm4_map_queues));\r\npacket->bitfields2.alloc_format =\r\nalloc_format__mes_map_queues__one_per_pipe_vi;\r\npacket->bitfields2.num_queues = 1;\r\npacket->bitfields2.queue_sel =\r\nqueue_sel__mes_map_queues__map_to_hws_determined_queue_slots_vi;\r\npacket->bitfields2.engine_sel =\r\nengine_sel__mes_map_queues__compute_vi;\r\npacket->bitfields2.queue_type =\r\nqueue_type__mes_map_queues__normal_compute_vi;\r\nswitch (q->properties.type) {\r\ncase KFD_QUEUE_TYPE_COMPUTE:\r\nif (use_static)\r\npacket->bitfields2.queue_type =\r\nqueue_type__mes_map_queues__normal_latency_static_queue_vi;\r\nbreak;\r\ncase KFD_QUEUE_TYPE_DIQ:\r\npacket->bitfields2.queue_type =\r\nqueue_type__mes_map_queues__debug_interface_queue_vi;\r\nbreak;\r\ncase KFD_QUEUE_TYPE_SDMA:\r\npacket->bitfields2.engine_sel =\r\nengine_sel__mes_map_queues__sdma0_vi;\r\nuse_static = false;\r\nbreak;\r\ndefault:\r\npr_err("kfd: in %s queue type %d\n", __func__,\r\nq->properties.type);\r\nBUG();\r\nbreak;\r\n}\r\npacket->bitfields3.doorbell_offset =\r\nq->properties.doorbell_off;\r\npacket->mqd_addr_lo =\r\nlower_32_bits(q->gart_mqd_addr);\r\npacket->mqd_addr_hi =\r\nupper_32_bits(q->gart_mqd_addr);\r\npacket->wptr_addr_lo =\r\nlower_32_bits((uint64_t)q->properties.write_ptr);\r\npacket->wptr_addr_hi =\r\nupper_32_bits((uint64_t)q->properties.write_ptr);\r\nreturn 0;\r\n}\r\nstatic int pm_create_map_queue(struct packet_manager *pm, uint32_t *buffer,\r\nstruct queue *q, bool is_static)\r\n{\r\nstruct pm4_map_queues *packet;\r\nbool use_static = is_static;\r\nBUG_ON(!pm || !buffer || !q);\r\npr_debug("kfd: In func %s\n", __func__);\r\npacket = (struct pm4_map_queues *)buffer;\r\nmemset(buffer, 0, sizeof(struct pm4_map_queues));\r\npacket->header.u32all = build_pm4_header(IT_MAP_QUEUES,\r\nsizeof(struct pm4_map_queues));\r\npacket->bitfields2.alloc_format =\r\nalloc_format__mes_map_queues__one_per_pipe;\r\npacket->bitfields2.num_queues = 1;\r\npacket->bitfields2.queue_sel =\r\nqueue_sel__mes_map_queues__map_to_hws_determined_queue_slots;\r\npacket->bitfields2.vidmem = (q->properties.is_interop) ?\r\nvidmem__mes_map_queues__uses_video_memory :\r\nvidmem__mes_map_queues__uses_no_video_memory;\r\nswitch (q->properties.type) {\r\ncase KFD_QUEUE_TYPE_COMPUTE:\r\ncase KFD_QUEUE_TYPE_DIQ:\r\npacket->bitfields2.engine_sel =\r\nengine_sel__mes_map_queues__compute;\r\nbreak;\r\ncase KFD_QUEUE_TYPE_SDMA:\r\npacket->bitfields2.engine_sel =\r\nengine_sel__mes_map_queues__sdma0;\r\nuse_static = false;\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\npacket->mes_map_queues_ordinals[0].bitfields3.doorbell_offset =\r\nq->properties.doorbell_off;\r\npacket->mes_map_queues_ordinals[0].bitfields3.is_static =\r\n(use_static == true) ? 1 : 0;\r\npacket->mes_map_queues_ordinals[0].mqd_addr_lo =\r\nlower_32_bits(q->gart_mqd_addr);\r\npacket->mes_map_queues_ordinals[0].mqd_addr_hi =\r\nupper_32_bits(q->gart_mqd_addr);\r\npacket->mes_map_queues_ordinals[0].wptr_addr_lo =\r\nlower_32_bits((uint64_t)q->properties.write_ptr);\r\npacket->mes_map_queues_ordinals[0].wptr_addr_hi =\r\nupper_32_bits((uint64_t)q->properties.write_ptr);\r\nreturn 0;\r\n}\r\nstatic int pm_create_runlist_ib(struct packet_manager *pm,\r\nstruct list_head *queues,\r\nuint64_t *rl_gpu_addr,\r\nsize_t *rl_size_bytes)\r\n{\r\nunsigned int alloc_size_bytes;\r\nunsigned int *rl_buffer, rl_wptr, i;\r\nint retval, proccesses_mapped;\r\nstruct device_process_node *cur;\r\nstruct qcm_process_device *qpd;\r\nstruct queue *q;\r\nstruct kernel_queue *kq;\r\nbool is_over_subscription;\r\nBUG_ON(!pm || !queues || !rl_size_bytes || !rl_gpu_addr);\r\nrl_wptr = retval = proccesses_mapped = 0;\r\nretval = pm_allocate_runlist_ib(pm, &rl_buffer, rl_gpu_addr,\r\n&alloc_size_bytes, &is_over_subscription);\r\nif (retval != 0)\r\nreturn retval;\r\n*rl_size_bytes = alloc_size_bytes;\r\npr_debug("kfd: In func %s\n", __func__);\r\npr_debug("kfd: building runlist ib process count: %d queues count %d\n",\r\npm->dqm->processes_count, pm->dqm->queue_count);\r\nlist_for_each_entry(cur, queues, list) {\r\nqpd = cur->qpd;\r\nif (proccesses_mapped >= pm->dqm->processes_count) {\r\npr_debug("kfd: not enough space left in runlist IB\n");\r\npm_release_ib(pm);\r\nreturn -ENOMEM;\r\n}\r\nretval = pm_create_map_process(pm, &rl_buffer[rl_wptr], qpd);\r\nif (retval != 0)\r\nreturn retval;\r\nproccesses_mapped++;\r\ninc_wptr(&rl_wptr, sizeof(struct pm4_map_process),\r\nalloc_size_bytes);\r\nlist_for_each_entry(kq, &qpd->priv_queue_list, list) {\r\nif (kq->queue->properties.is_active != true)\r\ncontinue;\r\npr_debug("kfd: static_queue, mapping kernel q %d, is debug status %d\n",\r\nkq->queue->queue, qpd->is_debug);\r\nif (pm->dqm->dev->device_info->asic_family ==\r\nCHIP_CARRIZO)\r\nretval = pm_create_map_queue_vi(pm,\r\n&rl_buffer[rl_wptr],\r\nkq->queue,\r\nqpd->is_debug);\r\nelse\r\nretval = pm_create_map_queue(pm,\r\n&rl_buffer[rl_wptr],\r\nkq->queue,\r\nqpd->is_debug);\r\nif (retval != 0)\r\nreturn retval;\r\ninc_wptr(&rl_wptr,\r\nsizeof(struct pm4_map_queues),\r\nalloc_size_bytes);\r\n}\r\nlist_for_each_entry(q, &qpd->queues_list, list) {\r\nif (q->properties.is_active != true)\r\ncontinue;\r\npr_debug("kfd: static_queue, mapping user queue %d, is debug status %d\n",\r\nq->queue, qpd->is_debug);\r\nif (pm->dqm->dev->device_info->asic_family ==\r\nCHIP_CARRIZO)\r\nretval = pm_create_map_queue_vi(pm,\r\n&rl_buffer[rl_wptr],\r\nq,\r\nqpd->is_debug);\r\nelse\r\nretval = pm_create_map_queue(pm,\r\n&rl_buffer[rl_wptr],\r\nq,\r\nqpd->is_debug);\r\nif (retval != 0)\r\nreturn retval;\r\ninc_wptr(&rl_wptr,\r\nsizeof(struct pm4_map_queues),\r\nalloc_size_bytes);\r\n}\r\n}\r\npr_debug("kfd: finished map process and queues to runlist\n");\r\nif (is_over_subscription)\r\npm_create_runlist(pm, &rl_buffer[rl_wptr], *rl_gpu_addr,\r\nalloc_size_bytes / sizeof(uint32_t), true);\r\nfor (i = 0; i < alloc_size_bytes / sizeof(uint32_t); i++)\r\npr_debug("0x%2X ", rl_buffer[i]);\r\npr_debug("\n");\r\nreturn 0;\r\n}\r\nint pm_init(struct packet_manager *pm, struct device_queue_manager *dqm)\r\n{\r\nBUG_ON(!dqm);\r\npm->dqm = dqm;\r\nmutex_init(&pm->lock);\r\npm->priv_queue = kernel_queue_init(dqm->dev, KFD_QUEUE_TYPE_HIQ);\r\nif (pm->priv_queue == NULL) {\r\nmutex_destroy(&pm->lock);\r\nreturn -ENOMEM;\r\n}\r\npm->allocated = false;\r\nreturn 0;\r\n}\r\nvoid pm_uninit(struct packet_manager *pm)\r\n{\r\nBUG_ON(!pm);\r\nmutex_destroy(&pm->lock);\r\nkernel_queue_uninit(pm->priv_queue);\r\n}\r\nint pm_send_set_resources(struct packet_manager *pm,\r\nstruct scheduling_resources *res)\r\n{\r\nstruct pm4_set_resources *packet;\r\nBUG_ON(!pm || !res);\r\npr_debug("kfd: In func %s\n", __func__);\r\nmutex_lock(&pm->lock);\r\npm->priv_queue->ops.acquire_packet_buffer(pm->priv_queue,\r\nsizeof(*packet) / sizeof(uint32_t),\r\n(unsigned int **)&packet);\r\nif (packet == NULL) {\r\nmutex_unlock(&pm->lock);\r\npr_err("kfd: failed to allocate buffer on kernel queue\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(packet, 0, sizeof(struct pm4_set_resources));\r\npacket->header.u32all = build_pm4_header(IT_SET_RESOURCES,\r\nsizeof(struct pm4_set_resources));\r\npacket->bitfields2.queue_type =\r\nqueue_type__mes_set_resources__hsa_interface_queue_hiq;\r\npacket->bitfields2.vmid_mask = res->vmid_mask;\r\npacket->bitfields2.unmap_latency = KFD_UNMAP_LATENCY;\r\npacket->bitfields7.oac_mask = res->oac_mask;\r\npacket->bitfields8.gds_heap_base = res->gds_heap_base;\r\npacket->bitfields8.gds_heap_size = res->gds_heap_size;\r\npacket->gws_mask_lo = lower_32_bits(res->gws_mask);\r\npacket->gws_mask_hi = upper_32_bits(res->gws_mask);\r\npacket->queue_mask_lo = lower_32_bits(res->queue_mask);\r\npacket->queue_mask_hi = upper_32_bits(res->queue_mask);\r\npm->priv_queue->ops.submit_packet(pm->priv_queue);\r\nmutex_unlock(&pm->lock);\r\nreturn 0;\r\n}\r\nint pm_send_runlist(struct packet_manager *pm, struct list_head *dqm_queues)\r\n{\r\nuint64_t rl_gpu_ib_addr;\r\nuint32_t *rl_buffer;\r\nsize_t rl_ib_size, packet_size_dwords;\r\nint retval;\r\nBUG_ON(!pm || !dqm_queues);\r\nretval = pm_create_runlist_ib(pm, dqm_queues, &rl_gpu_ib_addr,\r\n&rl_ib_size);\r\nif (retval != 0)\r\ngoto fail_create_runlist_ib;\r\npr_debug("kfd: runlist IB address: 0x%llX\n", rl_gpu_ib_addr);\r\npacket_size_dwords = sizeof(struct pm4_runlist) / sizeof(uint32_t);\r\nmutex_lock(&pm->lock);\r\nretval = pm->priv_queue->ops.acquire_packet_buffer(pm->priv_queue,\r\npacket_size_dwords, &rl_buffer);\r\nif (retval != 0)\r\ngoto fail_acquire_packet_buffer;\r\nretval = pm_create_runlist(pm, rl_buffer, rl_gpu_ib_addr,\r\nrl_ib_size / sizeof(uint32_t), false);\r\nif (retval != 0)\r\ngoto fail_create_runlist;\r\npm->priv_queue->ops.submit_packet(pm->priv_queue);\r\nmutex_unlock(&pm->lock);\r\nreturn retval;\r\nfail_create_runlist:\r\npm->priv_queue->ops.rollback_packet(pm->priv_queue);\r\nfail_acquire_packet_buffer:\r\nmutex_unlock(&pm->lock);\r\nfail_create_runlist_ib:\r\nif (pm->allocated == true)\r\npm_release_ib(pm);\r\nreturn retval;\r\n}\r\nint pm_send_query_status(struct packet_manager *pm, uint64_t fence_address,\r\nuint32_t fence_value)\r\n{\r\nint retval;\r\nstruct pm4_query_status *packet;\r\nBUG_ON(!pm || !fence_address);\r\nmutex_lock(&pm->lock);\r\nretval = pm->priv_queue->ops.acquire_packet_buffer(\r\npm->priv_queue,\r\nsizeof(struct pm4_query_status) / sizeof(uint32_t),\r\n(unsigned int **)&packet);\r\nif (retval != 0)\r\ngoto fail_acquire_packet_buffer;\r\npacket->header.u32all = build_pm4_header(IT_QUERY_STATUS,\r\nsizeof(struct pm4_query_status));\r\npacket->bitfields2.context_id = 0;\r\npacket->bitfields2.interrupt_sel =\r\ninterrupt_sel__mes_query_status__completion_status;\r\npacket->bitfields2.command =\r\ncommand__mes_query_status__fence_only_after_write_ack;\r\npacket->addr_hi = upper_32_bits((uint64_t)fence_address);\r\npacket->addr_lo = lower_32_bits((uint64_t)fence_address);\r\npacket->data_hi = upper_32_bits((uint64_t)fence_value);\r\npacket->data_lo = lower_32_bits((uint64_t)fence_value);\r\npm->priv_queue->ops.submit_packet(pm->priv_queue);\r\nmutex_unlock(&pm->lock);\r\nreturn 0;\r\nfail_acquire_packet_buffer:\r\nmutex_unlock(&pm->lock);\r\nreturn retval;\r\n}\r\nint pm_send_unmap_queue(struct packet_manager *pm, enum kfd_queue_type type,\r\nenum kfd_preempt_type_filter mode,\r\nuint32_t filter_param, bool reset,\r\nunsigned int sdma_engine)\r\n{\r\nint retval;\r\nuint32_t *buffer;\r\nstruct pm4_unmap_queues *packet;\r\nBUG_ON(!pm);\r\nmutex_lock(&pm->lock);\r\nretval = pm->priv_queue->ops.acquire_packet_buffer(\r\npm->priv_queue,\r\nsizeof(struct pm4_unmap_queues) / sizeof(uint32_t),\r\n&buffer);\r\nif (retval != 0)\r\ngoto err_acquire_packet_buffer;\r\npacket = (struct pm4_unmap_queues *)buffer;\r\nmemset(buffer, 0, sizeof(struct pm4_unmap_queues));\r\npr_debug("kfd: static_queue: unmapping queues: mode is %d , reset is %d , type is %d\n",\r\nmode, reset, type);\r\npacket->header.u32all = build_pm4_header(IT_UNMAP_QUEUES,\r\nsizeof(struct pm4_unmap_queues));\r\nswitch (type) {\r\ncase KFD_QUEUE_TYPE_COMPUTE:\r\ncase KFD_QUEUE_TYPE_DIQ:\r\npacket->bitfields2.engine_sel =\r\nengine_sel__mes_unmap_queues__compute;\r\nbreak;\r\ncase KFD_QUEUE_TYPE_SDMA:\r\npacket->bitfields2.engine_sel =\r\nengine_sel__mes_unmap_queues__sdma0 + sdma_engine;\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nif (reset)\r\npacket->bitfields2.action =\r\naction__mes_unmap_queues__reset_queues;\r\nelse\r\npacket->bitfields2.action =\r\naction__mes_unmap_queues__preempt_queues;\r\nswitch (mode) {\r\ncase KFD_PREEMPT_TYPE_FILTER_SINGLE_QUEUE:\r\npacket->bitfields2.queue_sel =\r\nqueue_sel__mes_unmap_queues__perform_request_on_specified_queues;\r\npacket->bitfields2.num_queues = 1;\r\npacket->bitfields3b.doorbell_offset0 = filter_param;\r\nbreak;\r\ncase KFD_PREEMPT_TYPE_FILTER_BY_PASID:\r\npacket->bitfields2.queue_sel =\r\nqueue_sel__mes_unmap_queues__perform_request_on_pasid_queues;\r\npacket->bitfields3a.pasid = filter_param;\r\nbreak;\r\ncase KFD_PREEMPT_TYPE_FILTER_ALL_QUEUES:\r\npacket->bitfields2.queue_sel =\r\nqueue_sel__mes_unmap_queues__perform_request_on_all_active_queues;\r\nbreak;\r\ncase KFD_PREEMPT_TYPE_FILTER_DYNAMIC_QUEUES:\r\npacket->bitfields2.queue_sel =\r\nqueue_sel__mes_unmap_queues__perform_request_on_dynamic_queues_only;\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n};\r\npm->priv_queue->ops.submit_packet(pm->priv_queue);\r\nmutex_unlock(&pm->lock);\r\nreturn 0;\r\nerr_acquire_packet_buffer:\r\nmutex_unlock(&pm->lock);\r\nreturn retval;\r\n}\r\nvoid pm_release_ib(struct packet_manager *pm)\r\n{\r\nBUG_ON(!pm);\r\nmutex_lock(&pm->lock);\r\nif (pm->allocated) {\r\nkfd_gtt_sa_free(pm->dqm->dev, pm->ib_buffer_obj);\r\npm->allocated = false;\r\n}\r\nmutex_unlock(&pm->lock);\r\n}
