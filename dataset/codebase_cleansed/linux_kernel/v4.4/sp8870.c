static int sp8870_writereg (struct sp8870_state* state, u16 reg, u16 data)\r\n{\r\nu8 buf [] = { reg >> 8, reg & 0xff, data >> 8, data & 0xff };\r\nstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 4 };\r\nint err;\r\nif ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {\r\ndprintk ("%s: writereg error (err == %i, reg == 0x%02x, data == 0x%02x)\n", __func__, err, reg, data);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sp8870_readreg (struct sp8870_state* state, u16 reg)\r\n{\r\nint ret;\r\nu8 b0 [] = { reg >> 8 , reg & 0xff };\r\nu8 b1 [] = { 0, 0 };\r\nstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 2 },\r\n{ .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 2 } };\r\nret = i2c_transfer (state->i2c, msg, 2);\r\nif (ret != 2) {\r\ndprintk("%s: readreg error (ret == %i)\n", __func__, ret);\r\nreturn -1;\r\n}\r\nreturn (b1[0] << 8 | b1[1]);\r\n}\r\nstatic int sp8870_firmware_upload (struct sp8870_state* state, const struct firmware *fw)\r\n{\r\nstruct i2c_msg msg;\r\nconst char *fw_buf = fw->data;\r\nint fw_pos;\r\nu8 tx_buf[255];\r\nint tx_len;\r\nint err = 0;\r\ndprintk ("%s: ...\n", __func__);\r\nif (fw->size < SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET)\r\nreturn -EINVAL;\r\nsp8870_writereg(state, 0x0F00, 0x0000);\r\nsp8870_writereg(state, 0x8F08, ((SP8870_FIRMWARE_SIZE / 2) & 0xFFFF));\r\nsp8870_writereg(state, 0x8F0A, ((SP8870_FIRMWARE_SIZE / 2) >> 16));\r\nfw_pos = SP8870_FIRMWARE_OFFSET;\r\nwhile (fw_pos < SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET){\r\ntx_len = (fw_pos <= SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET - 252) ? 252 : SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET - fw_pos;\r\ntx_buf[0] = 0xCF;\r\ntx_buf[1] = 0x0A;\r\nmemcpy(&tx_buf[2], fw_buf + fw_pos, tx_len);\r\nmsg.addr = state->config->demod_address;\r\nmsg.flags = 0;\r\nmsg.buf = tx_buf;\r\nmsg.len = tx_len + 2;\r\nif ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {\r\nprintk("%s: firmware upload failed!\n", __func__);\r\nprintk ("%s: i2c error (err == %i)\n", __func__, err);\r\nreturn err;\r\n}\r\nfw_pos += tx_len;\r\n}\r\ndprintk ("%s: done!\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void sp8870_microcontroller_stop (struct sp8870_state* state)\r\n{\r\nsp8870_writereg(state, 0x0F08, 0x000);\r\nsp8870_writereg(state, 0x0F09, 0x000);\r\nsp8870_writereg(state, 0x0F00, 0x000);\r\n}\r\nstatic void sp8870_microcontroller_start (struct sp8870_state* state)\r\n{\r\nsp8870_writereg(state, 0x0F08, 0x000);\r\nsp8870_writereg(state, 0x0F09, 0x000);\r\nsp8870_writereg(state, 0x0F00, 0x001);\r\nsp8870_readreg(state, 0x0D01);\r\n}\r\nstatic int sp8870_read_data_valid_signal(struct sp8870_state* state)\r\n{\r\nreturn (sp8870_readreg(state, 0x0D02) > 0);\r\n}\r\nstatic int configure_reg0xc05 (struct dtv_frontend_properties *p, u16 *reg0xc05)\r\n{\r\nint known_parameters = 1;\r\n*reg0xc05 = 0x000;\r\nswitch (p->modulation) {\r\ncase QPSK:\r\nbreak;\r\ncase QAM_16:\r\n*reg0xc05 |= (1 << 10);\r\nbreak;\r\ncase QAM_64:\r\n*reg0xc05 |= (2 << 10);\r\nbreak;\r\ncase QAM_AUTO:\r\nknown_parameters = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (p->hierarchy) {\r\ncase HIERARCHY_NONE:\r\nbreak;\r\ncase HIERARCHY_1:\r\n*reg0xc05 |= (1 << 7);\r\nbreak;\r\ncase HIERARCHY_2:\r\n*reg0xc05 |= (2 << 7);\r\nbreak;\r\ncase HIERARCHY_4:\r\n*reg0xc05 |= (3 << 7);\r\nbreak;\r\ncase HIERARCHY_AUTO:\r\nknown_parameters = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (p->code_rate_HP) {\r\ncase FEC_1_2:\r\nbreak;\r\ncase FEC_2_3:\r\n*reg0xc05 |= (1 << 3);\r\nbreak;\r\ncase FEC_3_4:\r\n*reg0xc05 |= (2 << 3);\r\nbreak;\r\ncase FEC_5_6:\r\n*reg0xc05 |= (3 << 3);\r\nbreak;\r\ncase FEC_7_8:\r\n*reg0xc05 |= (4 << 3);\r\nbreak;\r\ncase FEC_AUTO:\r\nknown_parameters = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (known_parameters)\r\n*reg0xc05 |= (2 << 1);\r\nelse\r\n*reg0xc05 |= (1 << 1);\r\nreturn 0;\r\n}\r\nstatic int sp8870_wake_up(struct sp8870_state* state)\r\n{\r\nreturn sp8870_writereg(state, 0xC18, 0x00D);\r\n}\r\nstatic int sp8870_set_frontend_parameters(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct sp8870_state* state = fe->demodulator_priv;\r\nint err;\r\nu16 reg0xc05;\r\nif ((err = configure_reg0xc05(p, &reg0xc05)))\r\nreturn err;\r\nsp8870_microcontroller_stop(state);\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nsp8870_writereg(state, 0x0319, 0x000A);\r\nsp8870_writereg(state, 0x031A, 0x0AAB);\r\nsp8870_writereg(state, 0x0309, 0x0400);\r\nsp8870_writereg(state, 0x030A, 0x0000);\r\nif (p->bandwidth_hz == 6000000)\r\nsp8870_writereg(state, 0x0311, 0x0002);\r\nelse if (p->bandwidth_hz == 7000000)\r\nsp8870_writereg(state, 0x0311, 0x0001);\r\nelse\r\nsp8870_writereg(state, 0x0311, 0x0000);\r\nif (p->transmission_mode == TRANSMISSION_MODE_2K)\r\nsp8870_writereg(state, 0x0338, 0x0000);\r\nelse\r\nsp8870_writereg(state, 0x0338, 0x0001);\r\nsp8870_writereg(state, 0xc05, reg0xc05);\r\nsp8870_readreg(state, 0x200);\r\nsp8870_microcontroller_start(state);\r\nreturn 0;\r\n}\r\nstatic int sp8870_init (struct dvb_frontend* fe)\r\n{\r\nstruct sp8870_state* state = fe->demodulator_priv;\r\nconst struct firmware *fw = NULL;\r\nsp8870_wake_up(state);\r\nif (state->initialised) return 0;\r\nstate->initialised = 1;\r\ndprintk ("%s\n", __func__);\r\nprintk("sp8870: waiting for firmware upload (%s)...\n", SP8870_DEFAULT_FIRMWARE);\r\nif (state->config->request_firmware(fe, &fw, SP8870_DEFAULT_FIRMWARE)) {\r\nprintk("sp8870: no firmware upload (timeout or file not found?)\n");\r\nreturn -EIO;\r\n}\r\nif (sp8870_firmware_upload(state, fw)) {\r\nprintk("sp8870: writing firmware to device failed\n");\r\nrelease_firmware(fw);\r\nreturn -EIO;\r\n}\r\nrelease_firmware(fw);\r\nprintk("sp8870: firmware upload complete\n");\r\nsp8870_writereg(state, 0xc18, 0x00d);\r\nsp8870_microcontroller_stop(state);\r\nsp8870_writereg(state, 0x0301, 0x0003);\r\nsp8870_writereg(state, 0x0C13, 0x0001);\r\nsp8870_writereg(state, 0x0C14, 0x0001);\r\nsp8870_writereg(state, 0x0D00, 0x010);\r\nsp8870_writereg(state, 0x0D01, 0x000);\r\nreturn 0;\r\n}\r\nstatic int sp8870_read_status(struct dvb_frontend *fe,\r\nenum fe_status *fe_status)\r\n{\r\nstruct sp8870_state* state = fe->demodulator_priv;\r\nint status;\r\nint signal;\r\n*fe_status = 0;\r\nstatus = sp8870_readreg (state, 0x0200);\r\nif (status < 0)\r\nreturn -EIO;\r\nsignal = sp8870_readreg (state, 0x0303);\r\nif (signal < 0)\r\nreturn -EIO;\r\nif (signal > 0x0F)\r\n*fe_status |= FE_HAS_SIGNAL;\r\nif (status & 0x08)\r\n*fe_status |= FE_HAS_SYNC;\r\nif (status & 0x04)\r\n*fe_status |= FE_HAS_LOCK | FE_HAS_CARRIER | FE_HAS_VITERBI;\r\nreturn 0;\r\n}\r\nstatic int sp8870_read_ber (struct dvb_frontend* fe, u32 * ber)\r\n{\r\nstruct sp8870_state* state = fe->demodulator_priv;\r\nint ret;\r\nu32 tmp;\r\n*ber = 0;\r\nret = sp8870_readreg(state, 0xC08);\r\nif (ret < 0)\r\nreturn -EIO;\r\ntmp = ret & 0x3F;\r\nret = sp8870_readreg(state, 0xC07);\r\nif (ret < 0)\r\nreturn -EIO;\r\ntmp = ret << 6;\r\nif (tmp >= 0x3FFF0)\r\ntmp = ~0;\r\n*ber = tmp;\r\nreturn 0;\r\n}\r\nstatic int sp8870_read_signal_strength(struct dvb_frontend* fe, u16 * signal)\r\n{\r\nstruct sp8870_state* state = fe->demodulator_priv;\r\nint ret;\r\nu16 tmp;\r\n*signal = 0;\r\nret = sp8870_readreg (state, 0x306);\r\nif (ret < 0)\r\nreturn -EIO;\r\ntmp = ret << 8;\r\nret = sp8870_readreg (state, 0x303);\r\nif (ret < 0)\r\nreturn -EIO;\r\ntmp |= ret;\r\nif (tmp)\r\n*signal = 0xFFFF - tmp;\r\nreturn 0;\r\n}\r\nstatic int sp8870_read_uncorrected_blocks (struct dvb_frontend* fe, u32* ublocks)\r\n{\r\nstruct sp8870_state* state = fe->demodulator_priv;\r\nint ret;\r\n*ublocks = 0;\r\nret = sp8870_readreg(state, 0xC0C);\r\nif (ret < 0)\r\nreturn -EIO;\r\nif (ret == 0xFFFF)\r\nret = ~0;\r\n*ublocks = ret;\r\nreturn 0;\r\n}\r\nstatic int sp8870_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct sp8870_state* state = fe->demodulator_priv;\r\nint err = 0;\r\nint valid = 0;\r\nint trials = 0;\r\nint check_count = 0;\r\ndprintk("%s: frequency = %i\n", __func__, p->frequency);\r\nfor (trials = 1; trials <= MAXTRIALS; trials++) {\r\nerr = sp8870_set_frontend_parameters(fe);\r\nif (err)\r\nreturn err;\r\nfor (check_count = 0; check_count < MAXCHECKS; check_count++) {\r\nvalid = sp8870_read_data_valid_signal(state);\r\nif (valid) {\r\ndprintk("%s: delay = %i usec\n",\r\n__func__, check_count * 10);\r\nbreak;\r\n}\r\nudelay(10);\r\n}\r\nif (valid)\r\nbreak;\r\n}\r\nif (!valid) {\r\nprintk("%s: firmware crash!!!!!!\n", __func__);\r\nreturn -EIO;\r\n}\r\nif (debug) {\r\nif (valid) {\r\nif (trials > 1) {\r\nprintk("%s: firmware lockup!!!\n", __func__);\r\nprintk("%s: recovered after %i trial(s))\n", __func__, trials - 1);\r\nlockups++;\r\n}\r\n}\r\nswitches++;\r\nprintk("%s: switches = %i lockups = %i\n", __func__, switches, lockups);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sp8870_sleep(struct dvb_frontend* fe)\r\n{\r\nstruct sp8870_state* state = fe->demodulator_priv;\r\nreturn sp8870_writereg(state, 0xC18, 0x000);\r\n}\r\nstatic int sp8870_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)\r\n{\r\nfesettings->min_delay_ms = 350;\r\nfesettings->step_size = 0;\r\nfesettings->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic int sp8870_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\r\n{\r\nstruct sp8870_state* state = fe->demodulator_priv;\r\nif (enable) {\r\nreturn sp8870_writereg(state, 0x206, 0x001);\r\n} else {\r\nreturn sp8870_writereg(state, 0x206, 0x000);\r\n}\r\n}\r\nstatic void sp8870_release(struct dvb_frontend* fe)\r\n{\r\nstruct sp8870_state* state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend* sp8870_attach(const struct sp8870_config* config,\r\nstruct i2c_adapter* i2c)\r\n{\r\nstruct sp8870_state* state = NULL;\r\nstate = kzalloc(sizeof(struct sp8870_state), GFP_KERNEL);\r\nif (state == NULL) goto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->initialised = 0;\r\nif (sp8870_readreg(state, 0x0200) < 0) goto error;\r\nmemcpy(&state->frontend.ops, &sp8870_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
