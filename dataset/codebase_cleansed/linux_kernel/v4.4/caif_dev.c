struct cfcnfg *get_cfcnfg(struct net *net)\r\n{\r\nstruct caif_net *caifn;\r\ncaifn = net_generic(net, caif_net_id);\r\nreturn caifn->cfg;\r\n}\r\nstatic struct caif_device_entry_list *caif_device_list(struct net *net)\r\n{\r\nstruct caif_net *caifn;\r\ncaifn = net_generic(net, caif_net_id);\r\nreturn &caifn->caifdevs;\r\n}\r\nstatic void caifd_put(struct caif_device_entry *e)\r\n{\r\nthis_cpu_dec(*e->pcpu_refcnt);\r\n}\r\nstatic void caifd_hold(struct caif_device_entry *e)\r\n{\r\nthis_cpu_inc(*e->pcpu_refcnt);\r\n}\r\nstatic int caifd_refcnt_read(struct caif_device_entry *e)\r\n{\r\nint i, refcnt = 0;\r\nfor_each_possible_cpu(i)\r\nrefcnt += *per_cpu_ptr(e->pcpu_refcnt, i);\r\nreturn refcnt;\r\n}\r\nstatic struct caif_device_entry *caif_device_alloc(struct net_device *dev)\r\n{\r\nstruct caif_device_entry *caifd;\r\ncaifd = kzalloc(sizeof(*caifd), GFP_KERNEL);\r\nif (!caifd)\r\nreturn NULL;\r\ncaifd->pcpu_refcnt = alloc_percpu(int);\r\nif (!caifd->pcpu_refcnt) {\r\nkfree(caifd);\r\nreturn NULL;\r\n}\r\ncaifd->netdev = dev;\r\ndev_hold(dev);\r\nreturn caifd;\r\n}\r\nstatic struct caif_device_entry *caif_get(struct net_device *dev)\r\n{\r\nstruct caif_device_entry_list *caifdevs =\r\ncaif_device_list(dev_net(dev));\r\nstruct caif_device_entry *caifd;\r\nlist_for_each_entry_rcu(caifd, &caifdevs->list, list) {\r\nif (caifd->netdev == dev)\r\nreturn caifd;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void caif_flow_cb(struct sk_buff *skb)\r\n{\r\nstruct caif_device_entry *caifd;\r\nvoid (*dtor)(struct sk_buff *skb) = NULL;\r\nbool send_xoff;\r\nWARN_ON(skb->dev == NULL);\r\nrcu_read_lock();\r\ncaifd = caif_get(skb->dev);\r\nWARN_ON(caifd == NULL);\r\nif (caifd == NULL)\r\nreturn;\r\ncaifd_hold(caifd);\r\nrcu_read_unlock();\r\nspin_lock_bh(&caifd->flow_lock);\r\nsend_xoff = caifd->xoff;\r\ncaifd->xoff = 0;\r\ndtor = caifd->xoff_skb_dtor;\r\nif (WARN_ON(caifd->xoff_skb != skb))\r\nskb = NULL;\r\ncaifd->xoff_skb = NULL;\r\ncaifd->xoff_skb_dtor = NULL;\r\nspin_unlock_bh(&caifd->flow_lock);\r\nif (dtor && skb)\r\ndtor(skb);\r\nif (send_xoff)\r\ncaifd->layer.up->\r\nctrlcmd(caifd->layer.up,\r\n_CAIF_CTRLCMD_PHYIF_FLOW_ON_IND,\r\ncaifd->layer.id);\r\ncaifd_put(caifd);\r\n}\r\nstatic int transmit(struct cflayer *layer, struct cfpkt *pkt)\r\n{\r\nint err, high = 0, qlen = 0;\r\nstruct caif_device_entry *caifd =\r\ncontainer_of(layer, struct caif_device_entry, layer);\r\nstruct sk_buff *skb;\r\nstruct netdev_queue *txq;\r\nrcu_read_lock_bh();\r\nskb = cfpkt_tonative(pkt);\r\nskb->dev = caifd->netdev;\r\nskb_reset_network_header(skb);\r\nskb->protocol = htons(ETH_P_CAIF);\r\nif (likely(caifd->netdev->priv_flags & IFF_NO_QUEUE))\r\ngoto noxoff;\r\nif (unlikely(caifd->xoff))\r\ngoto noxoff;\r\nif (likely(!netif_queue_stopped(caifd->netdev))) {\r\ntxq = netdev_get_tx_queue(skb->dev, 0);\r\nqlen = qdisc_qlen(rcu_dereference_bh(txq->qdisc));\r\nif (likely(qlen == 0))\r\ngoto noxoff;\r\nhigh = (caifd->netdev->tx_queue_len * q_high) / 100;\r\nif (likely(qlen < high))\r\ngoto noxoff;\r\n}\r\nspin_lock_bh(&caifd->flow_lock);\r\nif (caifd->xoff) {\r\nspin_unlock_bh(&caifd->flow_lock);\r\ngoto noxoff;\r\n}\r\npr_debug("queue has stopped(%d) or is full (%d > %d)\n",\r\nnetif_queue_stopped(caifd->netdev),\r\nqlen, high);\r\ncaifd->xoff = 1;\r\ncaifd->xoff_skb = skb;\r\ncaifd->xoff_skb_dtor = skb->destructor;\r\nskb->destructor = caif_flow_cb;\r\nspin_unlock_bh(&caifd->flow_lock);\r\ncaifd->layer.up->ctrlcmd(caifd->layer.up,\r\n_CAIF_CTRLCMD_PHYIF_FLOW_OFF_IND,\r\ncaifd->layer.id);\r\nnoxoff:\r\nrcu_read_unlock_bh();\r\nerr = dev_queue_xmit(skb);\r\nif (err > 0)\r\nerr = -EIO;\r\nreturn err;\r\n}\r\nstatic int receive(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *pkttype, struct net_device *orig_dev)\r\n{\r\nstruct cfpkt *pkt;\r\nstruct caif_device_entry *caifd;\r\nint err;\r\npkt = cfpkt_fromnative(CAIF_DIR_IN, skb);\r\nrcu_read_lock();\r\ncaifd = caif_get(dev);\r\nif (!caifd || !caifd->layer.up || !caifd->layer.up->receive ||\r\n!netif_oper_up(caifd->netdev)) {\r\nrcu_read_unlock();\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\ncaifd_hold(caifd);\r\nrcu_read_unlock();\r\nerr = caifd->layer.up->receive(caifd->layer.up, pkt);\r\nif (err == -EILSEQ)\r\ncfpkt_destroy(pkt);\r\ncaifd_put(caifd);\r\nif (err != 0)\r\nerr = NET_RX_DROP;\r\nreturn err;\r\n}\r\nstatic void dev_flowctrl(struct net_device *dev, int on)\r\n{\r\nstruct caif_device_entry *caifd;\r\nrcu_read_lock();\r\ncaifd = caif_get(dev);\r\nif (!caifd || !caifd->layer.up || !caifd->layer.up->ctrlcmd) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\ncaifd_hold(caifd);\r\nrcu_read_unlock();\r\ncaifd->layer.up->ctrlcmd(caifd->layer.up,\r\non ?\r\n_CAIF_CTRLCMD_PHYIF_FLOW_ON_IND :\r\n_CAIF_CTRLCMD_PHYIF_FLOW_OFF_IND,\r\ncaifd->layer.id);\r\ncaifd_put(caifd);\r\n}\r\nvoid caif_enroll_dev(struct net_device *dev, struct caif_dev_common *caifdev,\r\nstruct cflayer *link_support, int head_room,\r\nstruct cflayer **layer,\r\nint (**rcv_func)(struct sk_buff *, struct net_device *,\r\nstruct packet_type *,\r\nstruct net_device *))\r\n{\r\nstruct caif_device_entry *caifd;\r\nenum cfcnfg_phy_preference pref;\r\nstruct cfcnfg *cfg = get_cfcnfg(dev_net(dev));\r\nstruct caif_device_entry_list *caifdevs;\r\ncaifdevs = caif_device_list(dev_net(dev));\r\ncaifd = caif_device_alloc(dev);\r\nif (!caifd)\r\nreturn;\r\n*layer = &caifd->layer;\r\nspin_lock_init(&caifd->flow_lock);\r\nswitch (caifdev->link_select) {\r\ncase CAIF_LINK_HIGH_BANDW:\r\npref = CFPHYPREF_HIGH_BW;\r\nbreak;\r\ncase CAIF_LINK_LOW_LATENCY:\r\npref = CFPHYPREF_LOW_LAT;\r\nbreak;\r\ndefault:\r\npref = CFPHYPREF_HIGH_BW;\r\nbreak;\r\n}\r\nmutex_lock(&caifdevs->lock);\r\nlist_add_rcu(&caifd->list, &caifdevs->list);\r\nstrncpy(caifd->layer.name, dev->name,\r\nsizeof(caifd->layer.name) - 1);\r\ncaifd->layer.name[sizeof(caifd->layer.name) - 1] = 0;\r\ncaifd->layer.transmit = transmit;\r\ncfcnfg_add_phy_layer(cfg,\r\ndev,\r\n&caifd->layer,\r\npref,\r\nlink_support,\r\ncaifdev->use_fcs,\r\nhead_room);\r\nmutex_unlock(&caifdevs->lock);\r\nif (rcv_func)\r\n*rcv_func = receive;\r\n}\r\nstatic int caif_device_notify(struct notifier_block *me, unsigned long what,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct caif_device_entry *caifd = NULL;\r\nstruct caif_dev_common *caifdev;\r\nstruct cfcnfg *cfg;\r\nstruct cflayer *layer, *link_support;\r\nint head_room = 0;\r\nstruct caif_device_entry_list *caifdevs;\r\ncfg = get_cfcnfg(dev_net(dev));\r\ncaifdevs = caif_device_list(dev_net(dev));\r\ncaifd = caif_get(dev);\r\nif (caifd == NULL && dev->type != ARPHRD_CAIF)\r\nreturn 0;\r\nswitch (what) {\r\ncase NETDEV_REGISTER:\r\nif (caifd != NULL)\r\nbreak;\r\ncaifdev = netdev_priv(dev);\r\nlink_support = NULL;\r\nif (caifdev->use_frag) {\r\nhead_room = 1;\r\nlink_support = cfserl_create(dev->ifindex,\r\ncaifdev->use_stx);\r\nif (!link_support) {\r\npr_warn("Out of memory\n");\r\nbreak;\r\n}\r\n}\r\ncaif_enroll_dev(dev, caifdev, link_support, head_room,\r\n&layer, NULL);\r\ncaifdev->flowctrl = dev_flowctrl;\r\nbreak;\r\ncase NETDEV_UP:\r\nrcu_read_lock();\r\ncaifd = caif_get(dev);\r\nif (caifd == NULL) {\r\nrcu_read_unlock();\r\nbreak;\r\n}\r\ncaifd->xoff = 0;\r\ncfcnfg_set_phy_state(cfg, &caifd->layer, true);\r\nrcu_read_unlock();\r\nbreak;\r\ncase NETDEV_DOWN:\r\nrcu_read_lock();\r\ncaifd = caif_get(dev);\r\nif (!caifd || !caifd->layer.up || !caifd->layer.up->ctrlcmd) {\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\ncfcnfg_set_phy_state(cfg, &caifd->layer, false);\r\ncaifd_hold(caifd);\r\nrcu_read_unlock();\r\ncaifd->layer.up->ctrlcmd(caifd->layer.up,\r\n_CAIF_CTRLCMD_PHYIF_DOWN_IND,\r\ncaifd->layer.id);\r\nspin_lock_bh(&caifd->flow_lock);\r\nif (caifd->xoff_skb_dtor != NULL && caifd->xoff_skb != NULL)\r\ncaifd->xoff_skb->destructor = caifd->xoff_skb_dtor;\r\ncaifd->xoff = 0;\r\ncaifd->xoff_skb_dtor = NULL;\r\ncaifd->xoff_skb = NULL;\r\nspin_unlock_bh(&caifd->flow_lock);\r\ncaifd_put(caifd);\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nmutex_lock(&caifdevs->lock);\r\ncaifd = caif_get(dev);\r\nif (caifd == NULL) {\r\nmutex_unlock(&caifdevs->lock);\r\nbreak;\r\n}\r\nlist_del_rcu(&caifd->list);\r\nif (caifd_refcnt_read(caifd) != 0 ||\r\ncfcnfg_del_phy_layer(cfg, &caifd->layer) != 0) {\r\npr_info("Wait for device inuse\n");\r\nlist_add_rcu(&caifd->list, &caifdevs->list);\r\nmutex_unlock(&caifdevs->lock);\r\nbreak;\r\n}\r\nsynchronize_rcu();\r\ndev_put(caifd->netdev);\r\nfree_percpu(caifd->pcpu_refcnt);\r\nkfree(caifd);\r\nmutex_unlock(&caifdevs->lock);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int caif_init_net(struct net *net)\r\n{\r\nstruct caif_net *caifn = net_generic(net, caif_net_id);\r\nINIT_LIST_HEAD(&caifn->caifdevs.list);\r\nmutex_init(&caifn->caifdevs.lock);\r\ncaifn->cfg = cfcnfg_create();\r\nif (!caifn->cfg)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void caif_exit_net(struct net *net)\r\n{\r\nstruct caif_device_entry *caifd, *tmp;\r\nstruct caif_device_entry_list *caifdevs =\r\ncaif_device_list(net);\r\nstruct cfcnfg *cfg = get_cfcnfg(net);\r\nrtnl_lock();\r\nmutex_lock(&caifdevs->lock);\r\nlist_for_each_entry_safe(caifd, tmp, &caifdevs->list, list) {\r\nint i = 0;\r\nlist_del_rcu(&caifd->list);\r\ncfcnfg_set_phy_state(cfg, &caifd->layer, false);\r\nwhile (i < 10 &&\r\n(caifd_refcnt_read(caifd) != 0 ||\r\ncfcnfg_del_phy_layer(cfg, &caifd->layer) != 0)) {\r\npr_info("Wait for device inuse\n");\r\nmsleep(250);\r\ni++;\r\n}\r\nsynchronize_rcu();\r\ndev_put(caifd->netdev);\r\nfree_percpu(caifd->pcpu_refcnt);\r\nkfree(caifd);\r\n}\r\ncfcnfg_remove(cfg);\r\nmutex_unlock(&caifdevs->lock);\r\nrtnl_unlock();\r\n}\r\nstatic int __init caif_device_init(void)\r\n{\r\nint result;\r\nresult = register_pernet_subsys(&caif_net_ops);\r\nif (result)\r\nreturn result;\r\nregister_netdevice_notifier(&caif_device_notifier);\r\ndev_add_pack(&caif_packet_type);\r\nreturn result;\r\n}\r\nstatic void __exit caif_device_exit(void)\r\n{\r\nunregister_netdevice_notifier(&caif_device_notifier);\r\ndev_remove_pack(&caif_packet_type);\r\nunregister_pernet_subsys(&caif_net_ops);\r\n}
