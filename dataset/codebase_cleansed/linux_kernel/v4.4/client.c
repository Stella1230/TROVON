static int\r\nnvkm_client_notify(struct nvkm_notify *n)\r\n{\r\nstruct nvkm_client_notify *notify = container_of(n, typeof(*notify), n);\r\nstruct nvkm_client *client = notify->client;\r\nreturn client->ntfy(&notify->rep, notify->size, n->data, n->size);\r\n}\r\nint\r\nnvkm_client_notify_put(struct nvkm_client *client, int index)\r\n{\r\nif (index < ARRAY_SIZE(client->notify)) {\r\nif (client->notify[index]) {\r\nnvkm_notify_put(&client->notify[index]->n);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nint\r\nnvkm_client_notify_get(struct nvkm_client *client, int index)\r\n{\r\nif (index < ARRAY_SIZE(client->notify)) {\r\nif (client->notify[index]) {\r\nnvkm_notify_get(&client->notify[index]->n);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nint\r\nnvkm_client_notify_del(struct nvkm_client *client, int index)\r\n{\r\nif (index < ARRAY_SIZE(client->notify)) {\r\nif (client->notify[index]) {\r\nnvkm_notify_fini(&client->notify[index]->n);\r\nkfree(client->notify[index]);\r\nclient->notify[index] = NULL;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nint\r\nnvkm_client_notify_new(struct nvkm_object *object,\r\nstruct nvkm_event *event, void *data, u32 size)\r\n{\r\nstruct nvkm_client *client = object->client;\r\nstruct nvkm_client_notify *notify;\r\nunion {\r\nstruct nvif_notify_req_v0 v0;\r\n} *req = data;\r\nu8 index, reply;\r\nint ret;\r\nfor (index = 0; index < ARRAY_SIZE(client->notify); index++) {\r\nif (!client->notify[index])\r\nbreak;\r\n}\r\nif (index == ARRAY_SIZE(client->notify))\r\nreturn -ENOSPC;\r\nnotify = kzalloc(sizeof(*notify), GFP_KERNEL);\r\nif (!notify)\r\nreturn -ENOMEM;\r\nnvif_ioctl(object, "notify new size %d\n", size);\r\nif (nvif_unpack(req->v0, 0, 0, true)) {\r\nnvif_ioctl(object, "notify new vers %d reply %d route %02x "\r\n"token %llx\n", req->v0.version,\r\nreq->v0.reply, req->v0.route, req->v0.token);\r\nnotify->version = req->v0.version;\r\nnotify->size = sizeof(notify->rep.v0);\r\nnotify->rep.v0.version = req->v0.version;\r\nnotify->rep.v0.route = req->v0.route;\r\nnotify->rep.v0.token = req->v0.token;\r\nreply = req->v0.reply;\r\n}\r\nif (ret == 0) {\r\nret = nvkm_notify_init(object, event, nvkm_client_notify,\r\nfalse, data, size, reply, &notify->n);\r\nif (ret == 0) {\r\nclient->notify[index] = notify;\r\nnotify->client = client;\r\nreturn index;\r\n}\r\n}\r\nkfree(notify);\r\nreturn ret;\r\n}\r\nstatic int\r\nnvkm_client_mthd_devlist(struct nvkm_object *object, void *data, u32 size)\r\n{\r\nunion {\r\nstruct nv_client_devlist_v0 v0;\r\n} *args = data;\r\nint ret;\r\nnvif_ioctl(object, "client devlist size %d\n", size);\r\nif (nvif_unpack(args->v0, 0, 0, true)) {\r\nnvif_ioctl(object, "client devlist vers %d count %d\n",\r\nargs->v0.version, args->v0.count);\r\nif (size == sizeof(args->v0.device[0]) * args->v0.count) {\r\nret = nvkm_device_list(args->v0.device, args->v0.count);\r\nif (ret >= 0) {\r\nargs->v0.count = ret;\r\nret = 0;\r\n}\r\n} else {\r\nret = -EINVAL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nnvkm_client_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)\r\n{\r\nswitch (mthd) {\r\ncase NV_CLIENT_DEVLIST:\r\nreturn nvkm_client_mthd_devlist(object, data, size);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nnvkm_client_child_new(const struct nvkm_oclass *oclass,\r\nvoid *data, u32 size, struct nvkm_object **pobject)\r\n{\r\nreturn oclass->base.ctor(oclass, data, size, pobject);\r\n}\r\nstatic int\r\nnvkm_client_child_get(struct nvkm_object *object, int index,\r\nstruct nvkm_oclass *oclass)\r\n{\r\nconst struct nvkm_sclass *sclass;\r\nswitch (index) {\r\ncase 0: sclass = &nvkm_udevice_sclass; break;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\noclass->ctor = nvkm_client_child_new;\r\noclass->base = *sclass;\r\nreturn 0;\r\n}\r\nvoid\r\nnvkm_client_remove(struct nvkm_client *client, struct nvkm_object *object)\r\n{\r\nif (!RB_EMPTY_NODE(&object->node))\r\nrb_erase(&object->node, &client->objroot);\r\n}\r\nbool\r\nnvkm_client_insert(struct nvkm_client *client, struct nvkm_object *object)\r\n{\r\nstruct rb_node **ptr = &client->objroot.rb_node;\r\nstruct rb_node *parent = NULL;\r\nwhile (*ptr) {\r\nstruct nvkm_object *this =\r\ncontainer_of(*ptr, typeof(*this), node);\r\nparent = *ptr;\r\nif (object->object < this->object)\r\nptr = &parent->rb_left;\r\nelse\r\nif (object->object > this->object)\r\nptr = &parent->rb_right;\r\nelse\r\nreturn false;\r\n}\r\nrb_link_node(&object->node, parent, ptr);\r\nrb_insert_color(&object->node, &client->objroot);\r\nreturn true;\r\n}\r\nstruct nvkm_object *\r\nnvkm_client_search(struct nvkm_client *client, u64 handle)\r\n{\r\nstruct rb_node *node = client->objroot.rb_node;\r\nwhile (node) {\r\nstruct nvkm_object *object =\r\ncontainer_of(node, typeof(*object), node);\r\nif (handle < object->object)\r\nnode = node->rb_left;\r\nelse\r\nif (handle > object->object)\r\nnode = node->rb_right;\r\nelse\r\nreturn object;\r\n}\r\nreturn NULL;\r\n}\r\nint\r\nnvkm_client_fini(struct nvkm_client *client, bool suspend)\r\n{\r\nstruct nvkm_object *object = &client->object;\r\nconst char *name[2] = { "fini", "suspend" };\r\nint i;\r\nnvif_debug(object, "%s notify\n", name[suspend]);\r\nfor (i = 0; i < ARRAY_SIZE(client->notify); i++)\r\nnvkm_client_notify_put(client, i);\r\nreturn nvkm_object_fini(&client->object, suspend);\r\n}\r\nint\r\nnvkm_client_init(struct nvkm_client *client)\r\n{\r\nreturn nvkm_object_init(&client->object);\r\n}\r\nvoid\r\nnvkm_client_del(struct nvkm_client **pclient)\r\n{\r\nstruct nvkm_client *client = *pclient;\r\nint i;\r\nif (client) {\r\nnvkm_client_fini(client, false);\r\nfor (i = 0; i < ARRAY_SIZE(client->notify); i++)\r\nnvkm_client_notify_del(client, i);\r\nnvkm_object_dtor(&client->object);\r\nkfree(*pclient);\r\n*pclient = NULL;\r\n}\r\n}\r\nint\r\nnvkm_client_new(const char *name, u64 device, const char *cfg,\r\nconst char *dbg, struct nvkm_client **pclient)\r\n{\r\nstruct nvkm_oclass oclass = {};\r\nstruct nvkm_client *client;\r\nif (!(client = *pclient = kzalloc(sizeof(*client), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\noclass.client = client;\r\nnvkm_object_ctor(&nvkm_client_object_func, &oclass, &client->object);\r\nsnprintf(client->name, sizeof(client->name), "%s", name);\r\nclient->device = device;\r\nclient->debug = nvkm_dbgopt(dbg, "CLIENT");\r\nclient->objroot = RB_ROOT;\r\nclient->dmaroot = RB_ROOT;\r\nreturn 0;\r\n}
