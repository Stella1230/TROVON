static inline void omap_i2c_write_reg(struct omap_i2c_dev *omap,\r\nint reg, u16 val)\r\n{\r\nwritew_relaxed(val, omap->base +\r\n(omap->regs[reg] << omap->reg_shift));\r\n}\r\nstatic inline u16 omap_i2c_read_reg(struct omap_i2c_dev *omap, int reg)\r\n{\r\nreturn readw_relaxed(omap->base +\r\n(omap->regs[reg] << omap->reg_shift));\r\n}\r\nstatic void __omap_i2c_init(struct omap_i2c_dev *omap)\r\n{\r\nomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, 0);\r\nomap_i2c_write_reg(omap, OMAP_I2C_PSC_REG, omap->pscstate);\r\nomap_i2c_write_reg(omap, OMAP_I2C_SCLL_REG, omap->scllstate);\r\nomap_i2c_write_reg(omap, OMAP_I2C_SCLH_REG, omap->sclhstate);\r\nif (omap->rev >= OMAP_I2C_REV_ON_3430_3530)\r\nomap_i2c_write_reg(omap, OMAP_I2C_WE_REG, omap->westate);\r\nomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, OMAP_I2C_CON_EN);\r\nif (omap->iestate)\r\nomap_i2c_write_reg(omap, OMAP_I2C_IE_REG, omap->iestate);\r\n}\r\nstatic int omap_i2c_reset(struct omap_i2c_dev *omap)\r\n{\r\nunsigned long timeout;\r\nu16 sysc;\r\nif (omap->rev >= OMAP_I2C_OMAP1_REV_2) {\r\nsysc = omap_i2c_read_reg(omap, OMAP_I2C_SYSC_REG);\r\nomap_i2c_write_reg(omap, OMAP_I2C_CON_REG,\r\nomap_i2c_read_reg(omap, OMAP_I2C_CON_REG) &\r\n~(OMAP_I2C_CON_EN));\r\nomap_i2c_write_reg(omap, OMAP_I2C_SYSC_REG, SYSC_SOFTRESET_MASK);\r\ntimeout = jiffies + OMAP_I2C_TIMEOUT;\r\nomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, OMAP_I2C_CON_EN);\r\nwhile (!(omap_i2c_read_reg(omap, OMAP_I2C_SYSS_REG) &\r\nSYSS_RESETDONE_MASK)) {\r\nif (time_after(jiffies, timeout)) {\r\ndev_warn(omap->dev, "timeout waiting "\r\n"for controller reset\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\nomap_i2c_write_reg(omap, OMAP_I2C_SYSC_REG, sysc);\r\nif (omap->rev > OMAP_I2C_REV_ON_3430_3530) {\r\nomap->bb_valid = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_i2c_init(struct omap_i2c_dev *omap)\r\n{\r\nu16 psc = 0, scll = 0, sclh = 0;\r\nu16 fsscll = 0, fssclh = 0, hsscll = 0, hssclh = 0;\r\nunsigned long fclk_rate = 12000000;\r\nunsigned long internal_clk = 0;\r\nstruct clk *fclk;\r\nif (omap->rev >= OMAP_I2C_REV_ON_3430_3530) {\r\nomap->westate = OMAP_I2C_WE_ALL;\r\n}\r\nif (omap->flags & OMAP_I2C_FLAG_ALWAYS_ARMXOR_CLK) {\r\nfclk = clk_get(omap->dev, "fck");\r\nfclk_rate = clk_get_rate(fclk);\r\nclk_put(fclk);\r\nif (fclk_rate > 12000000)\r\npsc = fclk_rate / 12000000;\r\n}\r\nif (!(omap->flags & OMAP_I2C_FLAG_SIMPLE_CLOCK)) {\r\nif (omap->speed > 400 ||\r\nomap->flags & OMAP_I2C_FLAG_FORCE_19200_INT_CLK)\r\ninternal_clk = 19200;\r\nelse if (omap->speed > 100)\r\ninternal_clk = 9600;\r\nelse\r\ninternal_clk = 4000;\r\nfclk = clk_get(omap->dev, "fck");\r\nfclk_rate = clk_get_rate(fclk) / 1000;\r\nclk_put(fclk);\r\npsc = fclk_rate / internal_clk;\r\npsc = psc - 1;\r\nif (omap->speed > 400) {\r\nunsigned long scl;\r\nscl = internal_clk / 400;\r\nfsscll = scl - (scl / 3) - 7;\r\nfssclh = (scl / 3) - 5;\r\nscl = fclk_rate / omap->speed;\r\nhsscll = scl - (scl / 3) - 7;\r\nhssclh = (scl / 3) - 5;\r\n} else if (omap->speed > 100) {\r\nunsigned long scl;\r\nscl = internal_clk / omap->speed;\r\nfsscll = scl - (scl / 3) - 7;\r\nfssclh = (scl / 3) - 5;\r\n} else {\r\nfsscll = internal_clk / (omap->speed * 2) - 7;\r\nfssclh = internal_clk / (omap->speed * 2) - 5;\r\n}\r\nscll = (hsscll << OMAP_I2C_SCLL_HSSCLL) | fsscll;\r\nsclh = (hssclh << OMAP_I2C_SCLH_HSSCLH) | fssclh;\r\n} else {\r\nfclk_rate /= (psc + 1) * 1000;\r\nif (psc > 2)\r\npsc = 2;\r\nscll = fclk_rate / (omap->speed * 2) - 7 + psc;\r\nsclh = fclk_rate / (omap->speed * 2) - 7 + psc;\r\n}\r\nomap->iestate = (OMAP_I2C_IE_XRDY | OMAP_I2C_IE_RRDY |\r\nOMAP_I2C_IE_ARDY | OMAP_I2C_IE_NACK |\r\nOMAP_I2C_IE_AL) | ((omap->fifo_size) ?\r\n(OMAP_I2C_IE_RDR | OMAP_I2C_IE_XDR) : 0);\r\nomap->pscstate = psc;\r\nomap->scllstate = scll;\r\nomap->sclhstate = sclh;\r\nif (omap->rev <= OMAP_I2C_REV_ON_3430_3530) {\r\nomap->bb_valid = 1;\r\n}\r\n__omap_i2c_init(omap);\r\nreturn 0;\r\n}\r\nstatic int omap_i2c_wait_for_bb(struct omap_i2c_dev *omap)\r\n{\r\nunsigned long timeout;\r\ntimeout = jiffies + OMAP_I2C_TIMEOUT;\r\nwhile (omap_i2c_read_reg(omap, OMAP_I2C_STAT_REG) & OMAP_I2C_STAT_BB) {\r\nif (time_after(jiffies, timeout))\r\nreturn i2c_recover_bus(&omap->adapter);\r\nmsleep(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_i2c_wait_for_bb_valid(struct omap_i2c_dev *omap)\r\n{\r\nunsigned long bus_free_timeout = 0;\r\nunsigned long timeout;\r\nint bus_free = 0;\r\nu16 stat, systest;\r\nif (omap->bb_valid)\r\nreturn 0;\r\ntimeout = jiffies + OMAP_I2C_TIMEOUT;\r\nwhile (1) {\r\nstat = omap_i2c_read_reg(omap, OMAP_I2C_STAT_REG);\r\nif (stat & (OMAP_I2C_STAT_BB | OMAP_I2C_STAT_BF))\r\nbreak;\r\nsystest = omap_i2c_read_reg(omap, OMAP_I2C_SYSTEST_REG);\r\nif ((systest & OMAP_I2C_SYSTEST_SCL_I_FUNC) &&\r\n(systest & OMAP_I2C_SYSTEST_SDA_I_FUNC)) {\r\nif (!bus_free) {\r\nbus_free_timeout = jiffies +\r\nOMAP_I2C_BUS_FREE_TIMEOUT;\r\nbus_free = 1;\r\n}\r\nif (time_after(jiffies, bus_free_timeout))\r\nbreak;\r\n} else {\r\nbus_free = 0;\r\n}\r\nif (time_after(jiffies, timeout)) {\r\ndev_warn(omap->dev, "timeout waiting for bus ready\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\nomap->bb_valid = 1;\r\nreturn 0;\r\n}\r\nstatic void omap_i2c_resize_fifo(struct omap_i2c_dev *omap, u8 size, bool is_rx)\r\n{\r\nu16 buf;\r\nif (omap->flags & OMAP_I2C_FLAG_NO_FIFO)\r\nreturn;\r\nomap->threshold = clamp(size, (u8) 1, omap->fifo_size);\r\nbuf = omap_i2c_read_reg(omap, OMAP_I2C_BUF_REG);\r\nif (is_rx) {\r\nbuf &= ~(0x3f << 8);\r\nbuf |= ((omap->threshold - 1) << 8) | OMAP_I2C_BUF_RXFIF_CLR;\r\n} else {\r\nbuf &= ~0x3f;\r\nbuf |= (omap->threshold - 1) | OMAP_I2C_BUF_TXFIF_CLR;\r\n}\r\nomap_i2c_write_reg(omap, OMAP_I2C_BUF_REG, buf);\r\nif (omap->rev < OMAP_I2C_REV_ON_3630)\r\nomap->b_hw = 1;\r\nif (omap->set_mpu_wkup_lat != NULL)\r\nomap->latency = (1000000 * omap->threshold) /\r\n(1000 * omap->speed / 8);\r\n}\r\nstatic int omap_i2c_xfer_msg(struct i2c_adapter *adap,\r\nstruct i2c_msg *msg, int stop)\r\n{\r\nstruct omap_i2c_dev *omap = i2c_get_adapdata(adap);\r\nunsigned long timeout;\r\nu16 w;\r\ndev_dbg(omap->dev, "addr: 0x%04x, len: %d, flags: 0x%x, stop: %d\n",\r\nmsg->addr, msg->len, msg->flags, stop);\r\nif (msg->len == 0)\r\nreturn -EINVAL;\r\nomap->receiver = !!(msg->flags & I2C_M_RD);\r\nomap_i2c_resize_fifo(omap, msg->len, omap->receiver);\r\nomap_i2c_write_reg(omap, OMAP_I2C_SA_REG, msg->addr);\r\nomap->buf = msg->buf;\r\nomap->buf_len = msg->len;\r\nbarrier();\r\nomap_i2c_write_reg(omap, OMAP_I2C_CNT_REG, omap->buf_len);\r\nw = omap_i2c_read_reg(omap, OMAP_I2C_BUF_REG);\r\nw |= OMAP_I2C_BUF_RXFIF_CLR | OMAP_I2C_BUF_TXFIF_CLR;\r\nomap_i2c_write_reg(omap, OMAP_I2C_BUF_REG, w);\r\nreinit_completion(&omap->cmd_complete);\r\nomap->cmd_err = 0;\r\nw = OMAP_I2C_CON_EN | OMAP_I2C_CON_MST | OMAP_I2C_CON_STT;\r\nif (omap->speed > 400)\r\nw |= OMAP_I2C_CON_OPMODE_HS;\r\nif (msg->flags & I2C_M_STOP)\r\nstop = 1;\r\nif (msg->flags & I2C_M_TEN)\r\nw |= OMAP_I2C_CON_XA;\r\nif (!(msg->flags & I2C_M_RD))\r\nw |= OMAP_I2C_CON_TRX;\r\nif (!omap->b_hw && stop)\r\nw |= OMAP_I2C_CON_STP;\r\nomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, w);\r\nif (omap->b_hw && stop) {\r\nunsigned long delay = jiffies + OMAP_I2C_TIMEOUT;\r\nu16 con = omap_i2c_read_reg(omap, OMAP_I2C_CON_REG);\r\nwhile (con & OMAP_I2C_CON_STT) {\r\ncon = omap_i2c_read_reg(omap, OMAP_I2C_CON_REG);\r\nif (time_after(jiffies, delay)) {\r\ndev_err(omap->dev, "controller timed out "\r\n"waiting for start condition to finish\n");\r\nreturn -ETIMEDOUT;\r\n}\r\ncpu_relax();\r\n}\r\nw |= OMAP_I2C_CON_STP;\r\nw &= ~OMAP_I2C_CON_STT;\r\nomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, w);\r\n}\r\ntimeout = wait_for_completion_timeout(&omap->cmd_complete,\r\nOMAP_I2C_TIMEOUT);\r\nif (timeout == 0) {\r\ndev_err(omap->dev, "controller timed out\n");\r\nomap_i2c_reset(omap);\r\n__omap_i2c_init(omap);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (likely(!omap->cmd_err))\r\nreturn 0;\r\nif (omap->cmd_err & (OMAP_I2C_STAT_ROVR | OMAP_I2C_STAT_XUDF)) {\r\nomap_i2c_reset(omap);\r\n__omap_i2c_init(omap);\r\nreturn -EIO;\r\n}\r\nif (omap->cmd_err & OMAP_I2C_STAT_AL)\r\nreturn -EAGAIN;\r\nif (omap->cmd_err & OMAP_I2C_STAT_NACK) {\r\nif (msg->flags & I2C_M_IGNORE_NAK)\r\nreturn 0;\r\nw = omap_i2c_read_reg(omap, OMAP_I2C_CON_REG);\r\nw |= OMAP_I2C_CON_STP;\r\nomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, w);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int\r\nomap_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\r\n{\r\nstruct omap_i2c_dev *omap = i2c_get_adapdata(adap);\r\nint i;\r\nint r;\r\nr = pm_runtime_get_sync(omap->dev);\r\nif (r < 0)\r\ngoto out;\r\nr = omap_i2c_wait_for_bb_valid(omap);\r\nif (r < 0)\r\ngoto out;\r\nr = omap_i2c_wait_for_bb(omap);\r\nif (r < 0)\r\ngoto out;\r\nif (omap->set_mpu_wkup_lat != NULL)\r\nomap->set_mpu_wkup_lat(omap->dev, omap->latency);\r\nfor (i = 0; i < num; i++) {\r\nr = omap_i2c_xfer_msg(adap, &msgs[i], (i == (num - 1)));\r\nif (r != 0)\r\nbreak;\r\n}\r\nif (r == 0)\r\nr = num;\r\nomap_i2c_wait_for_bb(omap);\r\nif (omap->set_mpu_wkup_lat != NULL)\r\nomap->set_mpu_wkup_lat(omap->dev, -1);\r\nout:\r\npm_runtime_mark_last_busy(omap->dev);\r\npm_runtime_put_autosuspend(omap->dev);\r\nreturn r;\r\n}\r\nstatic u32\r\nomap_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK) |\r\nI2C_FUNC_PROTOCOL_MANGLING;\r\n}\r\nstatic inline void\r\nomap_i2c_complete_cmd(struct omap_i2c_dev *omap, u16 err)\r\n{\r\nomap->cmd_err |= err;\r\ncomplete(&omap->cmd_complete);\r\n}\r\nstatic inline void\r\nomap_i2c_ack_stat(struct omap_i2c_dev *omap, u16 stat)\r\n{\r\nomap_i2c_write_reg(omap, OMAP_I2C_STAT_REG, stat);\r\n}\r\nstatic inline void i2c_omap_errata_i207(struct omap_i2c_dev *omap, u16 stat)\r\n{\r\nif (stat & OMAP_I2C_STAT_RDR) {\r\nomap_i2c_ack_stat(omap, OMAP_I2C_STAT_RDR);\r\nif (!(omap_i2c_read_reg(omap, OMAP_I2C_STAT_REG)\r\n& OMAP_I2C_STAT_BB)) {\r\nif (omap_i2c_read_reg(omap, OMAP_I2C_STAT_REG)\r\n& OMAP_I2C_STAT_RDR) {\r\nomap_i2c_ack_stat(omap, OMAP_I2C_STAT_RDR);\r\ndev_dbg(omap->dev, "RDR when bus is busy.\n");\r\n}\r\n}\r\n}\r\n}\r\nstatic irqreturn_t\r\nomap_i2c_omap1_isr(int this_irq, void *dev_id)\r\n{\r\nstruct omap_i2c_dev *omap = dev_id;\r\nu16 iv, w;\r\nif (pm_runtime_suspended(omap->dev))\r\nreturn IRQ_NONE;\r\niv = omap_i2c_read_reg(omap, OMAP_I2C_IV_REG);\r\nswitch (iv) {\r\ncase 0x00:\r\nbreak;\r\ncase 0x01:\r\ndev_err(omap->dev, "Arbitration lost\n");\r\nomap_i2c_complete_cmd(omap, OMAP_I2C_STAT_AL);\r\nbreak;\r\ncase 0x02:\r\nomap_i2c_complete_cmd(omap, OMAP_I2C_STAT_NACK);\r\nomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, OMAP_I2C_CON_STP);\r\nbreak;\r\ncase 0x03:\r\nomap_i2c_complete_cmd(omap, 0);\r\nbreak;\r\ncase 0x04:\r\nif (omap->buf_len) {\r\nw = omap_i2c_read_reg(omap, OMAP_I2C_DATA_REG);\r\n*omap->buf++ = w;\r\nomap->buf_len--;\r\nif (omap->buf_len) {\r\n*omap->buf++ = w >> 8;\r\nomap->buf_len--;\r\n}\r\n} else\r\ndev_err(omap->dev, "RRDY IRQ while no data requested\n");\r\nbreak;\r\ncase 0x05:\r\nif (omap->buf_len) {\r\nw = *omap->buf++;\r\nomap->buf_len--;\r\nif (omap->buf_len) {\r\nw |= *omap->buf++ << 8;\r\nomap->buf_len--;\r\n}\r\nomap_i2c_write_reg(omap, OMAP_I2C_DATA_REG, w);\r\n} else\r\ndev_err(omap->dev, "XRDY IRQ while no data to send\n");\r\nbreak;\r\ndefault:\r\nreturn IRQ_NONE;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int errata_omap3_i462(struct omap_i2c_dev *omap)\r\n{\r\nunsigned long timeout = 10000;\r\nu16 stat;\r\ndo {\r\nstat = omap_i2c_read_reg(omap, OMAP_I2C_STAT_REG);\r\nif (stat & OMAP_I2C_STAT_XUDF)\r\nbreak;\r\nif (stat & (OMAP_I2C_STAT_NACK | OMAP_I2C_STAT_AL)) {\r\nomap_i2c_ack_stat(omap, (OMAP_I2C_STAT_XRDY |\r\nOMAP_I2C_STAT_XDR));\r\nif (stat & OMAP_I2C_STAT_NACK) {\r\nomap->cmd_err |= OMAP_I2C_STAT_NACK;\r\nomap_i2c_ack_stat(omap, OMAP_I2C_STAT_NACK);\r\n}\r\nif (stat & OMAP_I2C_STAT_AL) {\r\ndev_err(omap->dev, "Arbitration lost\n");\r\nomap->cmd_err |= OMAP_I2C_STAT_AL;\r\nomap_i2c_ack_stat(omap, OMAP_I2C_STAT_AL);\r\n}\r\nreturn -EIO;\r\n}\r\ncpu_relax();\r\n} while (--timeout);\r\nif (!timeout) {\r\ndev_err(omap->dev, "timeout waiting on XUDF bit\n");\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_i2c_receive_data(struct omap_i2c_dev *omap, u8 num_bytes,\r\nbool is_rdr)\r\n{\r\nu16 w;\r\nwhile (num_bytes--) {\r\nw = omap_i2c_read_reg(omap, OMAP_I2C_DATA_REG);\r\n*omap->buf++ = w;\r\nomap->buf_len--;\r\nif (omap->flags & OMAP_I2C_FLAG_16BIT_DATA_REG) {\r\n*omap->buf++ = w >> 8;\r\nomap->buf_len--;\r\n}\r\n}\r\n}\r\nstatic int omap_i2c_transmit_data(struct omap_i2c_dev *omap, u8 num_bytes,\r\nbool is_xdr)\r\n{\r\nu16 w;\r\nwhile (num_bytes--) {\r\nw = *omap->buf++;\r\nomap->buf_len--;\r\nif (omap->flags & OMAP_I2C_FLAG_16BIT_DATA_REG) {\r\nw |= *omap->buf++ << 8;\r\nomap->buf_len--;\r\n}\r\nif (omap->errata & I2C_OMAP_ERRATA_I462) {\r\nint ret;\r\nret = errata_omap3_i462(omap);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nomap_i2c_write_reg(omap, OMAP_I2C_DATA_REG, w);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t\r\nomap_i2c_isr(int irq, void *dev_id)\r\n{\r\nstruct omap_i2c_dev *omap = dev_id;\r\nirqreturn_t ret = IRQ_HANDLED;\r\nu16 mask;\r\nu16 stat;\r\nspin_lock(&omap->lock);\r\nmask = omap_i2c_read_reg(omap, OMAP_I2C_IE_REG);\r\nstat = omap_i2c_read_reg(omap, OMAP_I2C_STAT_REG);\r\nif (stat & mask)\r\nret = IRQ_WAKE_THREAD;\r\nspin_unlock(&omap->lock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t\r\nomap_i2c_isr_thread(int this_irq, void *dev_id)\r\n{\r\nstruct omap_i2c_dev *omap = dev_id;\r\nunsigned long flags;\r\nu16 bits;\r\nu16 stat;\r\nint err = 0, count = 0;\r\nspin_lock_irqsave(&omap->lock, flags);\r\ndo {\r\nbits = omap_i2c_read_reg(omap, OMAP_I2C_IE_REG);\r\nstat = omap_i2c_read_reg(omap, OMAP_I2C_STAT_REG);\r\nstat &= bits;\r\nif (omap->receiver)\r\nstat &= ~(OMAP_I2C_STAT_XDR | OMAP_I2C_STAT_XRDY);\r\nelse\r\nstat &= ~(OMAP_I2C_STAT_RDR | OMAP_I2C_STAT_RRDY);\r\nif (!stat) {\r\ngoto out;\r\n}\r\ndev_dbg(omap->dev, "IRQ (ISR = 0x%04x)\n", stat);\r\nif (count++ == 100) {\r\ndev_warn(omap->dev, "Too much work in one IRQ\n");\r\nbreak;\r\n}\r\nif (stat & OMAP_I2C_STAT_NACK) {\r\nerr |= OMAP_I2C_STAT_NACK;\r\nomap_i2c_ack_stat(omap, OMAP_I2C_STAT_NACK);\r\n}\r\nif (stat & OMAP_I2C_STAT_AL) {\r\ndev_err(omap->dev, "Arbitration lost\n");\r\nerr |= OMAP_I2C_STAT_AL;\r\nomap_i2c_ack_stat(omap, OMAP_I2C_STAT_AL);\r\n}\r\nif (stat & OMAP_I2C_STAT_ARDY)\r\nomap_i2c_ack_stat(omap, OMAP_I2C_STAT_ARDY);\r\nif (stat & (OMAP_I2C_STAT_ARDY | OMAP_I2C_STAT_NACK |\r\nOMAP_I2C_STAT_AL)) {\r\nomap_i2c_ack_stat(omap, (OMAP_I2C_STAT_RRDY |\r\nOMAP_I2C_STAT_RDR |\r\nOMAP_I2C_STAT_XRDY |\r\nOMAP_I2C_STAT_XDR |\r\nOMAP_I2C_STAT_ARDY));\r\nbreak;\r\n}\r\nif (stat & OMAP_I2C_STAT_RDR) {\r\nu8 num_bytes = 1;\r\nif (omap->fifo_size)\r\nnum_bytes = omap->buf_len;\r\nif (omap->errata & I2C_OMAP_ERRATA_I207) {\r\ni2c_omap_errata_i207(omap, stat);\r\nnum_bytes = (omap_i2c_read_reg(omap,\r\nOMAP_I2C_BUFSTAT_REG) >> 8) & 0x3F;\r\n}\r\nomap_i2c_receive_data(omap, num_bytes, true);\r\nomap_i2c_ack_stat(omap, OMAP_I2C_STAT_RDR);\r\ncontinue;\r\n}\r\nif (stat & OMAP_I2C_STAT_RRDY) {\r\nu8 num_bytes = 1;\r\nif (omap->threshold)\r\nnum_bytes = omap->threshold;\r\nomap_i2c_receive_data(omap, num_bytes, false);\r\nomap_i2c_ack_stat(omap, OMAP_I2C_STAT_RRDY);\r\ncontinue;\r\n}\r\nif (stat & OMAP_I2C_STAT_XDR) {\r\nu8 num_bytes = 1;\r\nint ret;\r\nif (omap->fifo_size)\r\nnum_bytes = omap->buf_len;\r\nret = omap_i2c_transmit_data(omap, num_bytes, true);\r\nif (ret < 0)\r\nbreak;\r\nomap_i2c_ack_stat(omap, OMAP_I2C_STAT_XDR);\r\ncontinue;\r\n}\r\nif (stat & OMAP_I2C_STAT_XRDY) {\r\nu8 num_bytes = 1;\r\nint ret;\r\nif (omap->threshold)\r\nnum_bytes = omap->threshold;\r\nret = omap_i2c_transmit_data(omap, num_bytes, false);\r\nif (ret < 0)\r\nbreak;\r\nomap_i2c_ack_stat(omap, OMAP_I2C_STAT_XRDY);\r\ncontinue;\r\n}\r\nif (stat & OMAP_I2C_STAT_ROVR) {\r\ndev_err(omap->dev, "Receive overrun\n");\r\nerr |= OMAP_I2C_STAT_ROVR;\r\nomap_i2c_ack_stat(omap, OMAP_I2C_STAT_ROVR);\r\nbreak;\r\n}\r\nif (stat & OMAP_I2C_STAT_XUDF) {\r\ndev_err(omap->dev, "Transmit underflow\n");\r\nerr |= OMAP_I2C_STAT_XUDF;\r\nomap_i2c_ack_stat(omap, OMAP_I2C_STAT_XUDF);\r\nbreak;\r\n}\r\n} while (stat);\r\nomap_i2c_complete_cmd(omap, err);\r\nout:\r\nspin_unlock_irqrestore(&omap->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int omap_i2c_get_scl(struct i2c_adapter *adap)\r\n{\r\nstruct omap_i2c_dev *dev = i2c_get_adapdata(adap);\r\nu32 reg;\r\nreg = omap_i2c_read_reg(dev, OMAP_I2C_SYSTEST_REG);\r\nreturn reg & OMAP_I2C_SYSTEST_SCL_I_FUNC;\r\n}\r\nstatic int omap_i2c_get_sda(struct i2c_adapter *adap)\r\n{\r\nstruct omap_i2c_dev *dev = i2c_get_adapdata(adap);\r\nu32 reg;\r\nreg = omap_i2c_read_reg(dev, OMAP_I2C_SYSTEST_REG);\r\nreturn reg & OMAP_I2C_SYSTEST_SDA_I_FUNC;\r\n}\r\nstatic void omap_i2c_set_scl(struct i2c_adapter *adap, int val)\r\n{\r\nstruct omap_i2c_dev *dev = i2c_get_adapdata(adap);\r\nu32 reg;\r\nreg = omap_i2c_read_reg(dev, OMAP_I2C_SYSTEST_REG);\r\nif (val)\r\nreg |= OMAP_I2C_SYSTEST_SCL_O;\r\nelse\r\nreg &= ~OMAP_I2C_SYSTEST_SCL_O;\r\nomap_i2c_write_reg(dev, OMAP_I2C_SYSTEST_REG, reg);\r\n}\r\nstatic void omap_i2c_prepare_recovery(struct i2c_adapter *adap)\r\n{\r\nstruct omap_i2c_dev *dev = i2c_get_adapdata(adap);\r\nu32 reg;\r\nreg = omap_i2c_read_reg(dev, OMAP_I2C_SYSTEST_REG);\r\nreg |= OMAP_I2C_SYSTEST_ST_EN;\r\nreg |= 3 << OMAP_I2C_SYSTEST_TMODE_SHIFT;\r\nreg |= OMAP_I2C_SYSTEST_SCL_O;\r\nreg |= OMAP_I2C_SYSTEST_SDA_O;\r\nomap_i2c_write_reg(dev, OMAP_I2C_SYSTEST_REG, reg);\r\n}\r\nstatic void omap_i2c_unprepare_recovery(struct i2c_adapter *adap)\r\n{\r\nstruct omap_i2c_dev *dev = i2c_get_adapdata(adap);\r\nu32 reg;\r\nreg = omap_i2c_read_reg(dev, OMAP_I2C_SYSTEST_REG);\r\nreg &= ~OMAP_I2C_SYSTEST_ST_EN;\r\nreg &= ~OMAP_I2C_SYSTEST_TMODE_MASK;\r\nreg &= ~OMAP_I2C_SYSTEST_SCL_O;\r\nreg &= ~OMAP_I2C_SYSTEST_SDA_O;\r\nomap_i2c_write_reg(dev, OMAP_I2C_SYSTEST_REG, reg);\r\n}\r\nstatic int\r\nomap_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_i2c_dev *omap;\r\nstruct i2c_adapter *adap;\r\nstruct resource *mem;\r\nconst struct omap_i2c_bus_platform_data *pdata =\r\ndev_get_platdata(&pdev->dev);\r\nstruct device_node *node = pdev->dev.of_node;\r\nconst struct of_device_id *match;\r\nint irq;\r\nint r;\r\nu32 rev;\r\nu16 minor, major;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq resource?\n");\r\nreturn irq;\r\n}\r\nomap = devm_kzalloc(&pdev->dev, sizeof(struct omap_i2c_dev), GFP_KERNEL);\r\nif (!omap)\r\nreturn -ENOMEM;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nomap->base = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(omap->base))\r\nreturn PTR_ERR(omap->base);\r\nmatch = of_match_device(of_match_ptr(omap_i2c_of_match), &pdev->dev);\r\nif (match) {\r\nu32 freq = 100000;\r\npdata = match->data;\r\nomap->flags = pdata->flags;\r\nof_property_read_u32(node, "clock-frequency", &freq);\r\nomap->speed = freq / 1000;\r\n} else if (pdata != NULL) {\r\nomap->speed = pdata->clkrate;\r\nomap->flags = pdata->flags;\r\nomap->set_mpu_wkup_lat = pdata->set_mpu_wkup_lat;\r\n}\r\nomap->dev = &pdev->dev;\r\nomap->irq = irq;\r\nspin_lock_init(&omap->lock);\r\nplatform_set_drvdata(pdev, omap);\r\ninit_completion(&omap->cmd_complete);\r\nomap->reg_shift = (omap->flags >> OMAP_I2C_FLAG_BUS_SHIFT__SHIFT) & 3;\r\npm_runtime_enable(omap->dev);\r\npm_runtime_set_autosuspend_delay(omap->dev, OMAP_I2C_PM_TIMEOUT);\r\npm_runtime_use_autosuspend(omap->dev);\r\nr = pm_runtime_get_sync(omap->dev);\r\nif (r < 0)\r\ngoto err_free_mem;\r\nrev = readw_relaxed(omap->base + 0x04);\r\nomap->scheme = OMAP_I2C_SCHEME(rev);\r\nswitch (omap->scheme) {\r\ncase OMAP_I2C_SCHEME_0:\r\nomap->regs = (u8 *)reg_map_ip_v1;\r\nomap->rev = omap_i2c_read_reg(omap, OMAP_I2C_REV_REG);\r\nminor = OMAP_I2C_REV_SCHEME_0_MAJOR(omap->rev);\r\nmajor = OMAP_I2C_REV_SCHEME_0_MAJOR(omap->rev);\r\nbreak;\r\ncase OMAP_I2C_SCHEME_1:\r\ndefault:\r\nomap->regs = (u8 *)reg_map_ip_v2;\r\nrev = (rev << 16) |\r\nomap_i2c_read_reg(omap, OMAP_I2C_IP_V2_REVNB_LO);\r\nminor = OMAP_I2C_REV_SCHEME_1_MINOR(rev);\r\nmajor = OMAP_I2C_REV_SCHEME_1_MAJOR(rev);\r\nomap->rev = rev;\r\n}\r\nomap->errata = 0;\r\nif (omap->rev >= OMAP_I2C_REV_ON_2430 &&\r\nomap->rev < OMAP_I2C_REV_ON_4430_PLUS)\r\nomap->errata |= I2C_OMAP_ERRATA_I207;\r\nif (omap->rev <= OMAP_I2C_REV_ON_3430_3530)\r\nomap->errata |= I2C_OMAP_ERRATA_I462;\r\nif (!(omap->flags & OMAP_I2C_FLAG_NO_FIFO)) {\r\nu16 s;\r\ns = (omap_i2c_read_reg(omap, OMAP_I2C_BUFSTAT_REG) >> 14) & 0x3;\r\nomap->fifo_size = 0x8 << s;\r\nomap->fifo_size = (omap->fifo_size / 2);\r\nif (omap->rev < OMAP_I2C_REV_ON_3630)\r\nomap->b_hw = 1;\r\nif (omap->set_mpu_wkup_lat != NULL)\r\nomap->latency = (1000000 * omap->fifo_size) /\r\n(1000 * omap->speed / 8);\r\n}\r\nomap_i2c_init(omap);\r\nif (omap->rev < OMAP_I2C_OMAP1_REV_2)\r\nr = devm_request_irq(&pdev->dev, omap->irq, omap_i2c_omap1_isr,\r\nIRQF_NO_SUSPEND, pdev->name, omap);\r\nelse\r\nr = devm_request_threaded_irq(&pdev->dev, omap->irq,\r\nomap_i2c_isr, omap_i2c_isr_thread,\r\nIRQF_NO_SUSPEND | IRQF_ONESHOT,\r\npdev->name, omap);\r\nif (r) {\r\ndev_err(omap->dev, "failure requesting irq %i\n", omap->irq);\r\ngoto err_unuse_clocks;\r\n}\r\nadap = &omap->adapter;\r\ni2c_set_adapdata(adap, omap);\r\nadap->owner = THIS_MODULE;\r\nadap->class = I2C_CLASS_DEPRECATED;\r\nstrlcpy(adap->name, "OMAP I2C adapter", sizeof(adap->name));\r\nadap->algo = &omap_i2c_algo;\r\nadap->dev.parent = &pdev->dev;\r\nadap->dev.of_node = pdev->dev.of_node;\r\nadap->bus_recovery_info = &omap_i2c_bus_recovery_info;\r\nadap->nr = pdev->id;\r\nr = i2c_add_numbered_adapter(adap);\r\nif (r) {\r\ndev_err(omap->dev, "failure adding adapter\n");\r\ngoto err_unuse_clocks;\r\n}\r\ndev_info(omap->dev, "bus %d rev%d.%d at %d kHz\n", adap->nr,\r\nmajor, minor, omap->speed);\r\npm_runtime_mark_last_busy(omap->dev);\r\npm_runtime_put_autosuspend(omap->dev);\r\nreturn 0;\r\nerr_unuse_clocks:\r\nomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, 0);\r\npm_runtime_put(omap->dev);\r\npm_runtime_disable(&pdev->dev);\r\nerr_free_mem:\r\nreturn r;\r\n}\r\nstatic int omap_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_i2c_dev *omap = platform_get_drvdata(pdev);\r\nint ret;\r\ni2c_del_adapter(&omap->adapter);\r\nret = pm_runtime_get_sync(&pdev->dev);\r\nif (ret < 0)\r\nreturn ret;\r\nomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, 0);\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int omap_i2c_runtime_suspend(struct device *dev)\r\n{\r\nstruct omap_i2c_dev *omap = dev_get_drvdata(dev);\r\nomap->iestate = omap_i2c_read_reg(omap, OMAP_I2C_IE_REG);\r\nif (omap->scheme == OMAP_I2C_SCHEME_0)\r\nomap_i2c_write_reg(omap, OMAP_I2C_IE_REG, 0);\r\nelse\r\nomap_i2c_write_reg(omap, OMAP_I2C_IP_V2_IRQENABLE_CLR,\r\nOMAP_I2C_IP_V2_INTERRUPTS_MASK);\r\nif (omap->rev < OMAP_I2C_OMAP1_REV_2) {\r\nomap_i2c_read_reg(omap, OMAP_I2C_IV_REG);\r\n} else {\r\nomap_i2c_write_reg(omap, OMAP_I2C_STAT_REG, omap->iestate);\r\nomap_i2c_read_reg(omap, OMAP_I2C_STAT_REG);\r\n}\r\npinctrl_pm_select_sleep_state(dev);\r\nreturn 0;\r\n}\r\nstatic int omap_i2c_runtime_resume(struct device *dev)\r\n{\r\nstruct omap_i2c_dev *omap = dev_get_drvdata(dev);\r\npinctrl_pm_select_default_state(dev);\r\nif (!omap->regs)\r\nreturn 0;\r\n__omap_i2c_init(omap);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nomap_i2c_init_driver(void)\r\n{\r\nreturn platform_driver_register(&omap_i2c_driver);\r\n}\r\nstatic void __exit omap_i2c_exit_driver(void)\r\n{\r\nplatform_driver_unregister(&omap_i2c_driver);\r\n}
