static void nd_btt_release(struct device *dev)\r\n{\r\nstruct nd_region *nd_region = to_nd_region(dev->parent);\r\nstruct nd_btt *nd_btt = to_nd_btt(dev);\r\ndev_dbg(dev, "%s\n", __func__);\r\nnd_detach_ndns(&nd_btt->dev, &nd_btt->ndns);\r\nida_simple_remove(&nd_region->btt_ida, nd_btt->id);\r\nkfree(nd_btt->uuid);\r\nkfree(nd_btt);\r\n}\r\nbool is_nd_btt(struct device *dev)\r\n{\r\nreturn dev->type == &nd_btt_device_type;\r\n}\r\nstruct nd_btt *to_nd_btt(struct device *dev)\r\n{\r\nstruct nd_btt *nd_btt = container_of(dev, struct nd_btt, dev);\r\nWARN_ON(!is_nd_btt(dev));\r\nreturn nd_btt;\r\n}\r\nstatic ssize_t sector_size_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct nd_btt *nd_btt = to_nd_btt(dev);\r\nreturn nd_sector_size_show(nd_btt->lbasize, btt_lbasize_supported, buf);\r\n}\r\nstatic ssize_t sector_size_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct nd_btt *nd_btt = to_nd_btt(dev);\r\nssize_t rc;\r\ndevice_lock(dev);\r\nnvdimm_bus_lock(dev);\r\nrc = nd_sector_size_store(dev, buf, &nd_btt->lbasize,\r\nbtt_lbasize_supported);\r\ndev_dbg(dev, "%s: result: %zd wrote: %s%s", __func__,\r\nrc, buf, buf[len - 1] == '\n' ? "" : "\n");\r\nnvdimm_bus_unlock(dev);\r\ndevice_unlock(dev);\r\nreturn rc ? rc : len;\r\n}\r\nstatic ssize_t uuid_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct nd_btt *nd_btt = to_nd_btt(dev);\r\nif (nd_btt->uuid)\r\nreturn sprintf(buf, "%pUb\n", nd_btt->uuid);\r\nreturn sprintf(buf, "\n");\r\n}\r\nstatic ssize_t uuid_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct nd_btt *nd_btt = to_nd_btt(dev);\r\nssize_t rc;\r\ndevice_lock(dev);\r\nrc = nd_uuid_store(dev, &nd_btt->uuid, buf, len);\r\ndev_dbg(dev, "%s: result: %zd wrote: %s%s", __func__,\r\nrc, buf, buf[len - 1] == '\n' ? "" : "\n");\r\ndevice_unlock(dev);\r\nreturn rc ? rc : len;\r\n}\r\nstatic ssize_t namespace_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct nd_btt *nd_btt = to_nd_btt(dev);\r\nssize_t rc;\r\nnvdimm_bus_lock(dev);\r\nrc = sprintf(buf, "%s\n", nd_btt->ndns\r\n? dev_name(&nd_btt->ndns->dev) : "");\r\nnvdimm_bus_unlock(dev);\r\nreturn rc;\r\n}\r\nstatic ssize_t namespace_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct nd_btt *nd_btt = to_nd_btt(dev);\r\nssize_t rc;\r\ndevice_lock(dev);\r\nnvdimm_bus_lock(dev);\r\nrc = nd_namespace_store(dev, &nd_btt->ndns, buf, len);\r\ndev_dbg(dev, "%s: result: %zd wrote: %s%s", __func__,\r\nrc, buf, buf[len - 1] == '\n' ? "" : "\n");\r\nnvdimm_bus_unlock(dev);\r\ndevice_unlock(dev);\r\nreturn rc;\r\n}\r\nstatic struct device *__nd_btt_create(struct nd_region *nd_region,\r\nunsigned long lbasize, u8 *uuid,\r\nstruct nd_namespace_common *ndns)\r\n{\r\nstruct nd_btt *nd_btt;\r\nstruct device *dev;\r\nnd_btt = kzalloc(sizeof(*nd_btt), GFP_KERNEL);\r\nif (!nd_btt)\r\nreturn NULL;\r\nnd_btt->id = ida_simple_get(&nd_region->btt_ida, 0, 0, GFP_KERNEL);\r\nif (nd_btt->id < 0) {\r\nkfree(nd_btt);\r\nreturn NULL;\r\n}\r\nnd_btt->lbasize = lbasize;\r\nif (uuid)\r\nuuid = kmemdup(uuid, 16, GFP_KERNEL);\r\nnd_btt->uuid = uuid;\r\ndev = &nd_btt->dev;\r\ndev_set_name(dev, "btt%d.%d", nd_region->id, nd_btt->id);\r\ndev->parent = &nd_region->dev;\r\ndev->type = &nd_btt_device_type;\r\ndev->groups = nd_btt_attribute_groups;\r\ndevice_initialize(&nd_btt->dev);\r\nif (ndns && !__nd_attach_ndns(&nd_btt->dev, ndns, &nd_btt->ndns)) {\r\ndev_dbg(&ndns->dev, "%s failed, already claimed by %s\n",\r\n__func__, dev_name(ndns->claim));\r\nput_device(dev);\r\nreturn NULL;\r\n}\r\nreturn dev;\r\n}\r\nstruct device *nd_btt_create(struct nd_region *nd_region)\r\n{\r\nstruct device *dev = __nd_btt_create(nd_region, 0, NULL, NULL);\r\nif (dev)\r\n__nd_device_register(dev);\r\nreturn dev;\r\n}\r\nstatic bool uuid_is_null(u8 *uuid)\r\n{\r\nstatic const u8 null_uuid[16];\r\nreturn (memcmp(uuid, null_uuid, 16) == 0);\r\n}\r\nbool nd_btt_arena_is_valid(struct nd_btt *nd_btt, struct btt_sb *super)\r\n{\r\nconst u8 *parent_uuid = nd_dev_to_uuid(&nd_btt->ndns->dev);\r\nu64 checksum;\r\nif (memcmp(super->signature, BTT_SIG, BTT_SIG_LEN) != 0)\r\nreturn false;\r\nif (!uuid_is_null(super->parent_uuid))\r\nif (memcmp(super->parent_uuid, parent_uuid, 16) != 0)\r\nreturn false;\r\nchecksum = le64_to_cpu(super->checksum);\r\nsuper->checksum = 0;\r\nif (checksum != nd_sb_checksum((struct nd_gen_sb *) super))\r\nreturn false;\r\nsuper->checksum = cpu_to_le64(checksum);\r\nif ((le32_to_cpu(super->flags) & IB_FLAG_ERROR_MASK) != 0)\r\ndev_info(&nd_btt->dev, "Found arena with an error flag\n");\r\nreturn true;\r\n}\r\nstatic int __nd_btt_probe(struct nd_btt *nd_btt,\r\nstruct nd_namespace_common *ndns, struct btt_sb *btt_sb)\r\n{\r\nif (!btt_sb || !ndns || !nd_btt)\r\nreturn -ENODEV;\r\nif (nvdimm_read_bytes(ndns, SZ_4K, btt_sb, sizeof(*btt_sb)))\r\nreturn -ENXIO;\r\nif (nvdimm_namespace_capacity(ndns) < SZ_16M)\r\nreturn -ENXIO;\r\nif (!nd_btt_arena_is_valid(nd_btt, btt_sb))\r\nreturn -ENODEV;\r\nnd_btt->lbasize = le32_to_cpu(btt_sb->external_lbasize);\r\nnd_btt->uuid = kmemdup(btt_sb->uuid, 16, GFP_KERNEL);\r\nif (!nd_btt->uuid)\r\nreturn -ENOMEM;\r\n__nd_device_register(&nd_btt->dev);\r\nreturn 0;\r\n}\r\nint nd_btt_probe(struct nd_namespace_common *ndns, void *drvdata)\r\n{\r\nint rc;\r\nstruct device *dev;\r\nstruct btt_sb *btt_sb;\r\nstruct nd_region *nd_region = to_nd_region(ndns->dev.parent);\r\nif (ndns->force_raw)\r\nreturn -ENODEV;\r\nnvdimm_bus_lock(&ndns->dev);\r\ndev = __nd_btt_create(nd_region, 0, NULL, ndns);\r\nnvdimm_bus_unlock(&ndns->dev);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, drvdata);\r\nbtt_sb = kzalloc(sizeof(*btt_sb), GFP_KERNEL);\r\nrc = __nd_btt_probe(to_nd_btt(dev), ndns, btt_sb);\r\nkfree(btt_sb);\r\ndev_dbg(&ndns->dev, "%s: btt: %s\n", __func__,\r\nrc == 0 ? dev_name(dev) : "<none>");\r\nif (rc < 0) {\r\nstruct nd_btt *nd_btt = to_nd_btt(dev);\r\n__nd_detach_ndns(dev, &nd_btt->ndns);\r\nput_device(dev);\r\n}\r\nreturn rc;\r\n}
