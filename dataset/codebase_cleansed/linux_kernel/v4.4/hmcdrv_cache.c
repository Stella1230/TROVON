static ssize_t hmcdrv_cache_get(const struct hmcdrv_ftp_cmdspec *ftp)\r\n{\r\nloff_t pos;\r\nssize_t len;\r\nif ((ftp->id != hmcdrv_cache_file.id) ||\r\nstrcmp(hmcdrv_cache_file.fname, ftp->fname))\r\nreturn -1;\r\nif (ftp->ofs >= hmcdrv_cache_file.fsize)\r\nreturn 0;\r\nif ((hmcdrv_cache_file.ofs < 0) ||\r\ntime_after(jiffies, hmcdrv_cache_file.timeout))\r\nreturn -1;\r\nlen = hmcdrv_cache_file.fsize - ftp->ofs;\r\nif (len > ftp->len)\r\nlen = ftp->len;\r\npos = ftp->ofs - hmcdrv_cache_file.ofs;\r\nif ((pos >= 0) &&\r\n((pos + len) <= hmcdrv_cache_file.len)) {\r\nmemcpy(ftp->buf,\r\nhmcdrv_cache_file.content + pos,\r\nlen);\r\npr_debug("using cached content of '%s', returning %zd/%zd bytes\n",\r\nhmcdrv_cache_file.fname, len,\r\nhmcdrv_cache_file.fsize);\r\nreturn len;\r\n}\r\nreturn -1;\r\n}\r\nstatic ssize_t hmcdrv_cache_do(const struct hmcdrv_ftp_cmdspec *ftp,\r\nhmcdrv_cache_ftpfunc func)\r\n{\r\nssize_t len;\r\nif ((ftp->len > 0) && (hmcdrv_cache_file.len >= ftp->len)) {\r\nstruct hmcdrv_ftp_cmdspec cftp = *ftp;\r\ncftp.buf = hmcdrv_cache_file.content;\r\ncftp.len = hmcdrv_cache_file.len;\r\nlen = func(&cftp, &hmcdrv_cache_file.fsize);\r\nif (len > 0) {\r\npr_debug("caching %zd bytes content for '%s'\n",\r\nlen, ftp->fname);\r\nif (len > ftp->len)\r\nlen = ftp->len;\r\nhmcdrv_cache_file.ofs = ftp->ofs;\r\nhmcdrv_cache_file.timeout = jiffies +\r\nHMCDRV_CACHE_TIMEOUT * HZ;\r\nmemcpy(ftp->buf, hmcdrv_cache_file.content, len);\r\n}\r\n} else {\r\nlen = func(ftp, &hmcdrv_cache_file.fsize);\r\nhmcdrv_cache_file.ofs = -1;\r\n}\r\nif (len > 0) {\r\nstrlcpy(hmcdrv_cache_file.fname, ftp->fname,\r\nHMCDRV_FTP_FIDENT_MAX);\r\nhmcdrv_cache_file.id = ftp->id;\r\npr_debug("caching cmd %d, file size %zu for '%s'\n",\r\nftp->id, hmcdrv_cache_file.fsize, ftp->fname);\r\n}\r\nreturn len;\r\n}\r\nssize_t hmcdrv_cache_cmd(const struct hmcdrv_ftp_cmdspec *ftp,\r\nhmcdrv_cache_ftpfunc func)\r\n{\r\nssize_t len;\r\nif ((ftp->id == HMCDRV_FTP_DIR) ||\r\n(ftp->id == HMCDRV_FTP_NLIST) ||\r\n(ftp->id == HMCDRV_FTP_GET)) {\r\nlen = hmcdrv_cache_get(ftp);\r\nif (len >= 0)\r\nreturn len;\r\nlen = hmcdrv_cache_do(ftp, func);\r\nif (len >= 0)\r\nreturn len;\r\n} else {\r\nlen = func(ftp, NULL);\r\n}\r\nhmcdrv_cache_file.id = HMCDRV_FTP_NOOP;\r\nhmcdrv_cache_file.fsize = LLONG_MAX;\r\nhmcdrv_cache_file.ofs = -1;\r\nreturn len;\r\n}\r\nint hmcdrv_cache_startup(size_t cachesize)\r\n{\r\nif (cachesize > 0) {\r\nhmcdrv_cache_order = get_order(cachesize);\r\nhmcdrv_cache_file.content =\r\n(void *) __get_free_pages(GFP_KERNEL | GFP_DMA,\r\nhmcdrv_cache_order);\r\nif (!hmcdrv_cache_file.content) {\r\npr_err("Allocating the requested cache size of %zu bytes failed\n",\r\ncachesize);\r\nreturn -ENOMEM;\r\n}\r\npr_debug("content cache enabled, size is %zu bytes\n",\r\ncachesize);\r\n}\r\nhmcdrv_cache_file.len = cachesize;\r\nreturn 0;\r\n}\r\nvoid hmcdrv_cache_shutdown(void)\r\n{\r\nif (hmcdrv_cache_file.content) {\r\nfree_pages((unsigned long) hmcdrv_cache_file.content,\r\nhmcdrv_cache_order);\r\nhmcdrv_cache_file.content = NULL;\r\n}\r\nhmcdrv_cache_file.id = HMCDRV_FTP_NOOP;\r\nhmcdrv_cache_file.fsize = LLONG_MAX;\r\nhmcdrv_cache_file.ofs = -1;\r\nhmcdrv_cache_file.len = 0;\r\n}
