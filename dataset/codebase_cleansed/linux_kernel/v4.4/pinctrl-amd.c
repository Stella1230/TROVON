static inline struct amd_gpio *to_amd_gpio(struct gpio_chip *gc)\r\n{\r\nreturn container_of(gc, struct amd_gpio, gc);\r\n}\r\nstatic int amd_gpio_direction_input(struct gpio_chip *gc, unsigned offset)\r\n{\r\nunsigned long flags;\r\nu32 pin_reg;\r\nstruct amd_gpio *gpio_dev = to_amd_gpio(gc);\r\nspin_lock_irqsave(&gpio_dev->lock, flags);\r\npin_reg = readl(gpio_dev->base + offset * 4);\r\nif ((pin_reg & DB_TMR_OUT_MASK) == 0) {\r\npin_reg |= 0xf;\r\npin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);\r\npin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\r\npin_reg &= ~BIT(DB_TMR_LARGE_OFF);\r\n}\r\npin_reg &= ~BIT(OUTPUT_ENABLE_OFF);\r\nwritel(pin_reg, gpio_dev->base + offset * 4);\r\nspin_unlock_irqrestore(&gpio_dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int amd_gpio_direction_output(struct gpio_chip *gc, unsigned offset,\r\nint value)\r\n{\r\nu32 pin_reg;\r\nunsigned long flags;\r\nstruct amd_gpio *gpio_dev = to_amd_gpio(gc);\r\nspin_lock_irqsave(&gpio_dev->lock, flags);\r\npin_reg = readl(gpio_dev->base + offset * 4);\r\npin_reg |= BIT(OUTPUT_ENABLE_OFF);\r\nif (value)\r\npin_reg |= BIT(OUTPUT_VALUE_OFF);\r\nelse\r\npin_reg &= ~BIT(OUTPUT_VALUE_OFF);\r\nwritel(pin_reg, gpio_dev->base + offset * 4);\r\nspin_unlock_irqrestore(&gpio_dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int amd_gpio_get_value(struct gpio_chip *gc, unsigned offset)\r\n{\r\nu32 pin_reg;\r\nunsigned long flags;\r\nstruct amd_gpio *gpio_dev = to_amd_gpio(gc);\r\nspin_lock_irqsave(&gpio_dev->lock, flags);\r\npin_reg = readl(gpio_dev->base + offset * 4);\r\nspin_unlock_irqrestore(&gpio_dev->lock, flags);\r\nreturn !!(pin_reg & BIT(PIN_STS_OFF));\r\n}\r\nstatic void amd_gpio_set_value(struct gpio_chip *gc, unsigned offset, int value)\r\n{\r\nu32 pin_reg;\r\nunsigned long flags;\r\nstruct amd_gpio *gpio_dev = to_amd_gpio(gc);\r\nspin_lock_irqsave(&gpio_dev->lock, flags);\r\npin_reg = readl(gpio_dev->base + offset * 4);\r\nif (value)\r\npin_reg |= BIT(OUTPUT_VALUE_OFF);\r\nelse\r\npin_reg &= ~BIT(OUTPUT_VALUE_OFF);\r\nwritel(pin_reg, gpio_dev->base + offset * 4);\r\nspin_unlock_irqrestore(&gpio_dev->lock, flags);\r\n}\r\nstatic int amd_gpio_set_debounce(struct gpio_chip *gc, unsigned offset,\r\nunsigned debounce)\r\n{\r\nu32 time;\r\nu32 pin_reg;\r\nint ret = 0;\r\nunsigned long flags;\r\nstruct amd_gpio *gpio_dev = to_amd_gpio(gc);\r\nspin_lock_irqsave(&gpio_dev->lock, flags);\r\npin_reg = readl(gpio_dev->base + offset * 4);\r\nif (debounce) {\r\npin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\r\npin_reg &= ~DB_TMR_OUT_MASK;\r\nif (debounce < 61) {\r\npin_reg |= 1;\r\npin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\r\npin_reg &= ~BIT(DB_TMR_LARGE_OFF);\r\n} else if (debounce < 976) {\r\ntime = debounce / 61;\r\npin_reg |= time & DB_TMR_OUT_MASK;\r\npin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\r\npin_reg &= ~BIT(DB_TMR_LARGE_OFF);\r\n} else if (debounce < 3900) {\r\ntime = debounce / 244;\r\npin_reg |= time & DB_TMR_OUT_MASK;\r\npin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);\r\npin_reg &= ~BIT(DB_TMR_LARGE_OFF);\r\n} else if (debounce < 250000) {\r\ntime = debounce / 15600;\r\npin_reg |= time & DB_TMR_OUT_MASK;\r\npin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\r\npin_reg |= BIT(DB_TMR_LARGE_OFF);\r\n} else if (debounce < 1000000) {\r\ntime = debounce / 62500;\r\npin_reg |= time & DB_TMR_OUT_MASK;\r\npin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);\r\npin_reg |= BIT(DB_TMR_LARGE_OFF);\r\n} else {\r\npin_reg &= ~DB_CNTRl_MASK;\r\nret = -EINVAL;\r\n}\r\n} else {\r\npin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\r\npin_reg &= ~BIT(DB_TMR_LARGE_OFF);\r\npin_reg &= ~DB_TMR_OUT_MASK;\r\npin_reg &= ~DB_CNTRl_MASK;\r\n}\r\nwritel(pin_reg, gpio_dev->base + offset * 4);\r\nspin_unlock_irqrestore(&gpio_dev->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void amd_gpio_dbg_show(struct seq_file *s, struct gpio_chip *gc)\r\n{\r\nu32 pin_reg;\r\nunsigned long flags;\r\nunsigned int bank, i, pin_num;\r\nstruct amd_gpio *gpio_dev = to_amd_gpio(gc);\r\nchar *level_trig;\r\nchar *active_level;\r\nchar *interrupt_enable;\r\nchar *interrupt_mask;\r\nchar *wake_cntrl0;\r\nchar *wake_cntrl1;\r\nchar *wake_cntrl2;\r\nchar *pin_sts;\r\nchar *pull_up_sel;\r\nchar *pull_up_enable;\r\nchar *pull_down_enable;\r\nchar *output_value;\r\nchar *output_enable;\r\nfor (bank = 0; bank < AMD_GPIO_TOTAL_BANKS; bank++) {\r\nseq_printf(s, "GPIO bank%d\t", bank);\r\nswitch (bank) {\r\ncase 0:\r\ni = 0;\r\npin_num = AMD_GPIO_PINS_BANK0;\r\nbreak;\r\ncase 1:\r\ni = 64;\r\npin_num = AMD_GPIO_PINS_BANK1 + i;\r\nbreak;\r\ncase 2:\r\ni = 128;\r\npin_num = AMD_GPIO_PINS_BANK2 + i;\r\nbreak;\r\n}\r\nfor (; i < pin_num; i++) {\r\nseq_printf(s, "pin%d\t", i);\r\nspin_lock_irqsave(&gpio_dev->lock, flags);\r\npin_reg = readl(gpio_dev->base + i * 4);\r\nspin_unlock_irqrestore(&gpio_dev->lock, flags);\r\nif (pin_reg & BIT(INTERRUPT_ENABLE_OFF)) {\r\ninterrupt_enable = "interrupt is enabled|";\r\nif (!(pin_reg & BIT(ACTIVE_LEVEL_OFF))\r\n&& !(pin_reg & BIT(ACTIVE_LEVEL_OFF+1)))\r\nactive_level = "Active low|";\r\nelse if (pin_reg & BIT(ACTIVE_LEVEL_OFF)\r\n&& !(pin_reg & BIT(ACTIVE_LEVEL_OFF+1)))\r\nactive_level = "Active high|";\r\nelse if (!(pin_reg & BIT(ACTIVE_LEVEL_OFF))\r\n&& pin_reg & BIT(ACTIVE_LEVEL_OFF+1))\r\nactive_level = "Active on both|";\r\nelse\r\nactive_level = "Unknow Active level|";\r\nif (pin_reg & BIT(LEVEL_TRIG_OFF))\r\nlevel_trig = "Level trigger|";\r\nelse\r\nlevel_trig = "Edge trigger|";\r\n} else {\r\ninterrupt_enable =\r\n"interrupt is disabled|";\r\nactive_level = " ";\r\nlevel_trig = " ";\r\n}\r\nif (pin_reg & BIT(INTERRUPT_MASK_OFF))\r\ninterrupt_mask =\r\n"interrupt is unmasked|";\r\nelse\r\ninterrupt_mask =\r\n"interrupt is masked|";\r\nif (pin_reg & BIT(WAKE_CNTRL_OFF))\r\nwake_cntrl0 = "enable wakeup in S0i3 state|";\r\nelse\r\nwake_cntrl0 = "disable wakeup in S0i3 state|";\r\nif (pin_reg & BIT(WAKE_CNTRL_OFF))\r\nwake_cntrl1 = "enable wakeup in S3 state|";\r\nelse\r\nwake_cntrl1 = "disable wakeup in S3 state|";\r\nif (pin_reg & BIT(WAKE_CNTRL_OFF))\r\nwake_cntrl2 = "enable wakeup in S4/S5 state|";\r\nelse\r\nwake_cntrl2 = "disable wakeup in S4/S5 state|";\r\nif (pin_reg & BIT(PULL_UP_ENABLE_OFF)) {\r\npull_up_enable = "pull-up is enabled|";\r\nif (pin_reg & BIT(PULL_UP_SEL_OFF))\r\npull_up_sel = "8k pull-up|";\r\nelse\r\npull_up_sel = "4k pull-up|";\r\n} else {\r\npull_up_enable = "pull-up is disabled|";\r\npull_up_sel = " ";\r\n}\r\nif (pin_reg & BIT(PULL_DOWN_ENABLE_OFF))\r\npull_down_enable = "pull-down is enabled|";\r\nelse\r\npull_down_enable = "Pull-down is disabled|";\r\nif (pin_reg & BIT(OUTPUT_ENABLE_OFF)) {\r\npin_sts = " ";\r\noutput_enable = "output is enabled|";\r\nif (pin_reg & BIT(OUTPUT_VALUE_OFF))\r\noutput_value = "output is high|";\r\nelse\r\noutput_value = "output is low|";\r\n} else {\r\noutput_enable = "output is disabled|";\r\noutput_value = " ";\r\nif (pin_reg & BIT(PIN_STS_OFF))\r\npin_sts = "input is high|";\r\nelse\r\npin_sts = "input is low|";\r\n}\r\nseq_printf(s, "%s %s %s %s %s %s\n"\r\n" %s %s %s %s %s %s %s 0x%x\n",\r\nlevel_trig, active_level, interrupt_enable,\r\ninterrupt_mask, wake_cntrl0, wake_cntrl1,\r\nwake_cntrl2, pin_sts, pull_up_sel,\r\npull_up_enable, pull_down_enable,\r\noutput_value, output_enable, pin_reg);\r\n}\r\n}\r\n}\r\nstatic void amd_gpio_irq_enable(struct irq_data *d)\r\n{\r\nu32 pin_reg;\r\nunsigned long flags;\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct amd_gpio *gpio_dev = to_amd_gpio(gc);\r\nspin_lock_irqsave(&gpio_dev->lock, flags);\r\npin_reg = readl(gpio_dev->base + (d->hwirq)*4);\r\nif ((pin_reg & DB_TMR_OUT_MASK) == 0) {\r\npin_reg |= 0xf;\r\npin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);\r\npin_reg &= ~BIT(DB_TMR_LARGE_OFF);\r\n}\r\npin_reg |= BIT(INTERRUPT_ENABLE_OFF);\r\npin_reg |= BIT(INTERRUPT_MASK_OFF);\r\nwritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\r\nspin_unlock_irqrestore(&gpio_dev->lock, flags);\r\n}\r\nstatic void amd_gpio_irq_disable(struct irq_data *d)\r\n{\r\nu32 pin_reg;\r\nunsigned long flags;\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct amd_gpio *gpio_dev = to_amd_gpio(gc);\r\nspin_lock_irqsave(&gpio_dev->lock, flags);\r\npin_reg = readl(gpio_dev->base + (d->hwirq)*4);\r\npin_reg &= ~BIT(INTERRUPT_ENABLE_OFF);\r\npin_reg &= ~BIT(INTERRUPT_MASK_OFF);\r\nwritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\r\nspin_unlock_irqrestore(&gpio_dev->lock, flags);\r\n}\r\nstatic void amd_gpio_irq_mask(struct irq_data *d)\r\n{\r\nu32 pin_reg;\r\nunsigned long flags;\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct amd_gpio *gpio_dev = to_amd_gpio(gc);\r\nspin_lock_irqsave(&gpio_dev->lock, flags);\r\npin_reg = readl(gpio_dev->base + (d->hwirq)*4);\r\npin_reg &= ~BIT(INTERRUPT_MASK_OFF);\r\nwritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\r\nspin_unlock_irqrestore(&gpio_dev->lock, flags);\r\n}\r\nstatic void amd_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nu32 pin_reg;\r\nunsigned long flags;\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct amd_gpio *gpio_dev = to_amd_gpio(gc);\r\nspin_lock_irqsave(&gpio_dev->lock, flags);\r\npin_reg = readl(gpio_dev->base + (d->hwirq)*4);\r\npin_reg |= BIT(INTERRUPT_MASK_OFF);\r\nwritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\r\nspin_unlock_irqrestore(&gpio_dev->lock, flags);\r\n}\r\nstatic void amd_gpio_irq_eoi(struct irq_data *d)\r\n{\r\nu32 reg;\r\nunsigned long flags;\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct amd_gpio *gpio_dev = to_amd_gpio(gc);\r\nspin_lock_irqsave(&gpio_dev->lock, flags);\r\nreg = readl(gpio_dev->base + WAKE_INT_MASTER_REG);\r\nreg |= EOI_MASK;\r\nwritel(reg, gpio_dev->base + WAKE_INT_MASTER_REG);\r\nspin_unlock_irqrestore(&gpio_dev->lock, flags);\r\n}\r\nstatic int amd_gpio_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nint ret = 0;\r\nu32 pin_reg;\r\nunsigned long flags;\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct amd_gpio *gpio_dev = to_amd_gpio(gc);\r\nspin_lock_irqsave(&gpio_dev->lock, flags);\r\npin_reg = readl(gpio_dev->base + (d->hwirq)*4);\r\nswitch (type & IRQ_TYPE_SENSE_MASK) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\npin_reg &= ~BIT(LEVEL_TRIG_OFF);\r\npin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\r\npin_reg |= ACTIVE_HIGH << ACTIVE_LEVEL_OFF;\r\npin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\r\nirq_set_handler_locked(d, handle_edge_irq);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\npin_reg &= ~BIT(LEVEL_TRIG_OFF);\r\npin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\r\npin_reg |= ACTIVE_LOW << ACTIVE_LEVEL_OFF;\r\npin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\r\nirq_set_handler_locked(d, handle_edge_irq);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\npin_reg &= ~BIT(LEVEL_TRIG_OFF);\r\npin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\r\npin_reg |= BOTH_EADGE << ACTIVE_LEVEL_OFF;\r\npin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\r\nirq_set_handler_locked(d, handle_edge_irq);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\npin_reg |= LEVEL_TRIGGER << LEVEL_TRIG_OFF;\r\npin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\r\npin_reg |= ACTIVE_HIGH << ACTIVE_LEVEL_OFF;\r\npin_reg &= ~(DB_CNTRl_MASK << DB_CNTRL_OFF);\r\npin_reg |= DB_TYPE_PRESERVE_LOW_GLITCH << DB_CNTRL_OFF;\r\nirq_set_handler_locked(d, handle_level_irq);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\npin_reg |= LEVEL_TRIGGER << LEVEL_TRIG_OFF;\r\npin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\r\npin_reg |= ACTIVE_LOW << ACTIVE_LEVEL_OFF;\r\npin_reg &= ~(DB_CNTRl_MASK << DB_CNTRL_OFF);\r\npin_reg |= DB_TYPE_PRESERVE_HIGH_GLITCH << DB_CNTRL_OFF;\r\nirq_set_handler_locked(d, handle_level_irq);\r\nbreak;\r\ncase IRQ_TYPE_NONE:\r\nbreak;\r\ndefault:\r\ndev_err(&gpio_dev->pdev->dev, "Invalid type value\n");\r\nret = -EINVAL;\r\n}\r\npin_reg |= CLR_INTR_STAT << INTERRUPT_STS_OFF;\r\nwritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\r\nspin_unlock_irqrestore(&gpio_dev->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void amd_irq_ack(struct irq_data *d)\r\n{\r\n}\r\nstatic void amd_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nu32 i;\r\nu32 off;\r\nu32 reg;\r\nu32 pin_reg;\r\nu64 reg64;\r\nint handled = 0;\r\nunsigned int irq;\r\nunsigned long flags;\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\r\nstruct amd_gpio *gpio_dev = to_amd_gpio(gc);\r\nchained_irq_enter(chip, desc);\r\nspin_lock_irqsave(&gpio_dev->lock, flags);\r\nreg = readl(gpio_dev->base + WAKE_INT_STATUS_REG1);\r\nreg64 = reg;\r\nreg64 = reg64 << 32;\r\nreg = readl(gpio_dev->base + WAKE_INT_STATUS_REG0);\r\nreg64 |= reg;\r\nspin_unlock_irqrestore(&gpio_dev->lock, flags);\r\nfor (off = 0; off < 46 ; off++) {\r\nif (reg64 & BIT(off)) {\r\nfor (i = 0; i < 4; i++) {\r\npin_reg = readl(gpio_dev->base +\r\n(off * 4 + i) * 4);\r\nif ((pin_reg & BIT(INTERRUPT_STS_OFF)) ||\r\n(pin_reg & BIT(WAKE_STS_OFF))) {\r\nirq = irq_find_mapping(gc->irqdomain,\r\noff * 4 + i);\r\ngeneric_handle_irq(irq);\r\nwritel(pin_reg,\r\ngpio_dev->base\r\n+ (off * 4 + i) * 4);\r\nhandled++;\r\n}\r\n}\r\n}\r\n}\r\nif (handled == 0)\r\nhandle_bad_irq(desc);\r\nspin_lock_irqsave(&gpio_dev->lock, flags);\r\nreg = readl(gpio_dev->base + WAKE_INT_MASTER_REG);\r\nreg |= EOI_MASK;\r\nwritel(reg, gpio_dev->base + WAKE_INT_MASTER_REG);\r\nspin_unlock_irqrestore(&gpio_dev->lock, flags);\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int amd_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\r\nreturn gpio_dev->ngroups;\r\n}\r\nstatic const char *amd_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\r\nreturn gpio_dev->groups[group].name;\r\n}\r\nstatic int amd_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = gpio_dev->groups[group].pins;\r\n*num_pins = gpio_dev->groups[group].npins;\r\nreturn 0;\r\n}\r\nstatic int amd_pinconf_get(struct pinctrl_dev *pctldev,\r\nunsigned int pin,\r\nunsigned long *config)\r\n{\r\nu32 pin_reg;\r\nunsigned arg;\r\nunsigned long flags;\r\nstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nspin_lock_irqsave(&gpio_dev->lock, flags);\r\npin_reg = readl(gpio_dev->base + pin*4);\r\nspin_unlock_irqrestore(&gpio_dev->lock, flags);\r\nswitch (param) {\r\ncase PIN_CONFIG_INPUT_DEBOUNCE:\r\narg = pin_reg & DB_TMR_OUT_MASK;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\narg = (pin_reg >> PULL_DOWN_ENABLE_OFF) & BIT(0);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\narg = (pin_reg >> PULL_UP_SEL_OFF) & (BIT(0) | BIT(1));\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\narg = (pin_reg >> DRV_STRENGTH_SEL_OFF) & DRV_STRENGTH_SEL_MASK;\r\nbreak;\r\ndefault:\r\ndev_err(&gpio_dev->pdev->dev, "Invalid config param %04x\n",\r\nparam);\r\nreturn -ENOTSUPP;\r\n}\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int amd_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nint i;\r\nu32 arg;\r\nint ret = 0;\r\nu32 pin_reg;\r\nunsigned long flags;\r\nenum pin_config_param param;\r\nstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\r\nspin_lock_irqsave(&gpio_dev->lock, flags);\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\npin_reg = readl(gpio_dev->base + pin*4);\r\nswitch (param) {\r\ncase PIN_CONFIG_INPUT_DEBOUNCE:\r\npin_reg &= ~DB_TMR_OUT_MASK;\r\npin_reg |= arg & DB_TMR_OUT_MASK;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\npin_reg &= ~BIT(PULL_DOWN_ENABLE_OFF);\r\npin_reg |= (arg & BIT(0)) << PULL_DOWN_ENABLE_OFF;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\npin_reg &= ~BIT(PULL_UP_SEL_OFF);\r\npin_reg |= (arg & BIT(0)) << PULL_UP_SEL_OFF;\r\npin_reg &= ~BIT(PULL_UP_ENABLE_OFF);\r\npin_reg |= ((arg>>1) & BIT(0)) << PULL_UP_ENABLE_OFF;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\npin_reg &= ~(DRV_STRENGTH_SEL_MASK\r\n<< DRV_STRENGTH_SEL_OFF);\r\npin_reg |= (arg & DRV_STRENGTH_SEL_MASK)\r\n<< DRV_STRENGTH_SEL_OFF;\r\nbreak;\r\ndefault:\r\ndev_err(&gpio_dev->pdev->dev,\r\n"Invalid config param %04x\n", param);\r\nret = -ENOTSUPP;\r\n}\r\nwritel(pin_reg, gpio_dev->base + pin*4);\r\n}\r\nspin_unlock_irqrestore(&gpio_dev->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int amd_pinconf_group_get(struct pinctrl_dev *pctldev,\r\nunsigned int group,\r\nunsigned long *config)\r\n{\r\nconst unsigned *pins;\r\nunsigned npins;\r\nint ret;\r\nret = amd_get_group_pins(pctldev, group, &pins, &npins);\r\nif (ret)\r\nreturn ret;\r\nif (amd_pinconf_get(pctldev, pins[0], config))\r\nreturn -ENOTSUPP;\r\nreturn 0;\r\n}\r\nstatic int amd_pinconf_group_set(struct pinctrl_dev *pctldev,\r\nunsigned group, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nconst unsigned *pins;\r\nunsigned npins;\r\nint i, ret;\r\nret = amd_get_group_pins(pctldev, group, &pins, &npins);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < npins; i++) {\r\nif (amd_pinconf_set(pctldev, pins[i], configs, num_configs))\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int amd_gpio_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\nint irq_base;\r\nstruct resource *res;\r\nstruct amd_gpio *gpio_dev;\r\ngpio_dev = devm_kzalloc(&pdev->dev,\r\nsizeof(struct amd_gpio), GFP_KERNEL);\r\nif (!gpio_dev)\r\nreturn -ENOMEM;\r\nspin_lock_init(&gpio_dev->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Failed to get gpio io resource.\n");\r\nreturn -EINVAL;\r\n}\r\ngpio_dev->base = devm_ioremap_nocache(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (IS_ERR(gpio_dev->base))\r\nreturn PTR_ERR(gpio_dev->base);\r\nirq_base = platform_get_irq(pdev, 0);\r\nif (irq_base < 0) {\r\ndev_err(&pdev->dev, "Failed to get gpio IRQ.\n");\r\nreturn -EINVAL;\r\n}\r\ngpio_dev->pdev = pdev;\r\ngpio_dev->gc.direction_input = amd_gpio_direction_input;\r\ngpio_dev->gc.direction_output = amd_gpio_direction_output;\r\ngpio_dev->gc.get = amd_gpio_get_value;\r\ngpio_dev->gc.set = amd_gpio_set_value;\r\ngpio_dev->gc.set_debounce = amd_gpio_set_debounce;\r\ngpio_dev->gc.dbg_show = amd_gpio_dbg_show;\r\ngpio_dev->gc.base = 0;\r\ngpio_dev->gc.label = pdev->name;\r\ngpio_dev->gc.owner = THIS_MODULE;\r\ngpio_dev->gc.dev = &pdev->dev;\r\ngpio_dev->gc.ngpio = TOTAL_NUMBER_OF_PINS;\r\n#if defined(CONFIG_OF_GPIO)\r\ngpio_dev->gc.of_node = pdev->dev.of_node;\r\n#endif\r\ngpio_dev->groups = kerncz_groups;\r\ngpio_dev->ngroups = ARRAY_SIZE(kerncz_groups);\r\namd_pinctrl_desc.name = dev_name(&pdev->dev);\r\ngpio_dev->pctrl = pinctrl_register(&amd_pinctrl_desc,\r\n&pdev->dev, gpio_dev);\r\nif (IS_ERR(gpio_dev->pctrl)) {\r\ndev_err(&pdev->dev, "Couldn't register pinctrl driver\n");\r\nreturn PTR_ERR(gpio_dev->pctrl);\r\n}\r\nret = gpiochip_add(&gpio_dev->gc);\r\nif (ret)\r\ngoto out1;\r\nret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev),\r\n0, 0, TOTAL_NUMBER_OF_PINS);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to add pin range\n");\r\ngoto out2;\r\n}\r\nret = gpiochip_irqchip_add(&gpio_dev->gc,\r\n&amd_gpio_irqchip,\r\n0,\r\nhandle_simple_irq,\r\nIRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not add irqchip\n");\r\nret = -ENODEV;\r\ngoto out2;\r\n}\r\ngpiochip_set_chained_irqchip(&gpio_dev->gc,\r\n&amd_gpio_irqchip,\r\nirq_base,\r\namd_gpio_irq_handler);\r\nplatform_set_drvdata(pdev, gpio_dev);\r\ndev_dbg(&pdev->dev, "amd gpio driver loaded\n");\r\nreturn ret;\r\nout2:\r\ngpiochip_remove(&gpio_dev->gc);\r\nout1:\r\npinctrl_unregister(gpio_dev->pctrl);\r\nreturn ret;\r\n}\r\nstatic int amd_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct amd_gpio *gpio_dev;\r\ngpio_dev = platform_get_drvdata(pdev);\r\ngpiochip_remove(&gpio_dev->gc);\r\npinctrl_unregister(gpio_dev->pctrl);\r\nreturn 0;\r\n}
