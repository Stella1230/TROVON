static inline bool\r\ntype_match(u_int8_t min, u_int8_t max, u_int8_t type, bool invert)\r\n{\r\nreturn (type >= min && type <= max) ^ invert;\r\n}\r\nstatic bool mh_mt6(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nstruct ip6_mh _mh;\r\nconst struct ip6_mh *mh;\r\nconst struct ip6t_mh *mhinfo = par->matchinfo;\r\nif (par->fragoff != 0)\r\nreturn false;\r\nmh = skb_header_pointer(skb, par->thoff, sizeof(_mh), &_mh);\r\nif (mh == NULL) {\r\npr_debug("Dropping evil MH tinygram.\n");\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\nif (mh->ip6mh_proto != IPPROTO_NONE) {\r\npr_debug("Dropping invalid MH Payload Proto: %u\n",\r\nmh->ip6mh_proto);\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\nreturn type_match(mhinfo->types[0], mhinfo->types[1], mh->ip6mh_type,\r\n!!(mhinfo->invflags & IP6T_MH_INV_TYPE));\r\n}\r\nstatic int mh_mt6_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct ip6t_mh *mhinfo = par->matchinfo;\r\nreturn (mhinfo->invflags & ~IP6T_MH_INV_MASK) ? -EINVAL : 0;\r\n}\r\nstatic int __init mh_mt6_init(void)\r\n{\r\nreturn xt_register_match(&mh_mt6_reg);\r\n}\r\nstatic void __exit mh_mt6_exit(void)\r\n{\r\nxt_unregister_match(&mh_mt6_reg);\r\n}
