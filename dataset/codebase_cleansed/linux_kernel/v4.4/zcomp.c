static struct zcomp_backend *find_backend(const char *compress)\r\n{\r\nint i = 0;\r\nwhile (backends[i]) {\r\nif (sysfs_streq(compress, backends[i]->name))\r\nbreak;\r\ni++;\r\n}\r\nreturn backends[i];\r\n}\r\nstatic void zcomp_strm_free(struct zcomp *comp, struct zcomp_strm *zstrm)\r\n{\r\nif (zstrm->private)\r\ncomp->backend->destroy(zstrm->private);\r\nfree_pages((unsigned long)zstrm->buffer, 1);\r\nkfree(zstrm);\r\n}\r\nstatic struct zcomp_strm *zcomp_strm_alloc(struct zcomp *comp)\r\n{\r\nstruct zcomp_strm *zstrm = kmalloc(sizeof(*zstrm), GFP_KERNEL);\r\nif (!zstrm)\r\nreturn NULL;\r\nzstrm->private = comp->backend->create();\r\nzstrm->buffer = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, 1);\r\nif (!zstrm->private || !zstrm->buffer) {\r\nzcomp_strm_free(comp, zstrm);\r\nzstrm = NULL;\r\n}\r\nreturn zstrm;\r\n}\r\nstatic struct zcomp_strm *zcomp_strm_multi_find(struct zcomp *comp)\r\n{\r\nstruct zcomp_strm_multi *zs = comp->stream;\r\nstruct zcomp_strm *zstrm;\r\nwhile (1) {\r\nspin_lock(&zs->strm_lock);\r\nif (!list_empty(&zs->idle_strm)) {\r\nzstrm = list_entry(zs->idle_strm.next,\r\nstruct zcomp_strm, list);\r\nlist_del(&zstrm->list);\r\nspin_unlock(&zs->strm_lock);\r\nreturn zstrm;\r\n}\r\nif (zs->avail_strm >= zs->max_strm) {\r\nspin_unlock(&zs->strm_lock);\r\nwait_event(zs->strm_wait, !list_empty(&zs->idle_strm));\r\ncontinue;\r\n}\r\nzs->avail_strm++;\r\nspin_unlock(&zs->strm_lock);\r\nzstrm = zcomp_strm_alloc(comp);\r\nif (!zstrm) {\r\nspin_lock(&zs->strm_lock);\r\nzs->avail_strm--;\r\nspin_unlock(&zs->strm_lock);\r\nwait_event(zs->strm_wait, !list_empty(&zs->idle_strm));\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nreturn zstrm;\r\n}\r\nstatic void zcomp_strm_multi_release(struct zcomp *comp, struct zcomp_strm *zstrm)\r\n{\r\nstruct zcomp_strm_multi *zs = comp->stream;\r\nspin_lock(&zs->strm_lock);\r\nif (zs->avail_strm <= zs->max_strm) {\r\nlist_add(&zstrm->list, &zs->idle_strm);\r\nspin_unlock(&zs->strm_lock);\r\nwake_up(&zs->strm_wait);\r\nreturn;\r\n}\r\nzs->avail_strm--;\r\nspin_unlock(&zs->strm_lock);\r\nzcomp_strm_free(comp, zstrm);\r\n}\r\nstatic bool zcomp_strm_multi_set_max_streams(struct zcomp *comp, int num_strm)\r\n{\r\nstruct zcomp_strm_multi *zs = comp->stream;\r\nstruct zcomp_strm *zstrm;\r\nspin_lock(&zs->strm_lock);\r\nzs->max_strm = num_strm;\r\nwhile (zs->avail_strm > num_strm && !list_empty(&zs->idle_strm)) {\r\nzstrm = list_entry(zs->idle_strm.next,\r\nstruct zcomp_strm, list);\r\nlist_del(&zstrm->list);\r\nzcomp_strm_free(comp, zstrm);\r\nzs->avail_strm--;\r\n}\r\nspin_unlock(&zs->strm_lock);\r\nreturn true;\r\n}\r\nstatic void zcomp_strm_multi_destroy(struct zcomp *comp)\r\n{\r\nstruct zcomp_strm_multi *zs = comp->stream;\r\nstruct zcomp_strm *zstrm;\r\nwhile (!list_empty(&zs->idle_strm)) {\r\nzstrm = list_entry(zs->idle_strm.next,\r\nstruct zcomp_strm, list);\r\nlist_del(&zstrm->list);\r\nzcomp_strm_free(comp, zstrm);\r\n}\r\nkfree(zs);\r\n}\r\nstatic int zcomp_strm_multi_create(struct zcomp *comp, int max_strm)\r\n{\r\nstruct zcomp_strm *zstrm;\r\nstruct zcomp_strm_multi *zs;\r\ncomp->destroy = zcomp_strm_multi_destroy;\r\ncomp->strm_find = zcomp_strm_multi_find;\r\ncomp->strm_release = zcomp_strm_multi_release;\r\ncomp->set_max_streams = zcomp_strm_multi_set_max_streams;\r\nzs = kmalloc(sizeof(struct zcomp_strm_multi), GFP_KERNEL);\r\nif (!zs)\r\nreturn -ENOMEM;\r\ncomp->stream = zs;\r\nspin_lock_init(&zs->strm_lock);\r\nINIT_LIST_HEAD(&zs->idle_strm);\r\ninit_waitqueue_head(&zs->strm_wait);\r\nzs->max_strm = max_strm;\r\nzs->avail_strm = 1;\r\nzstrm = zcomp_strm_alloc(comp);\r\nif (!zstrm) {\r\nkfree(zs);\r\nreturn -ENOMEM;\r\n}\r\nlist_add(&zstrm->list, &zs->idle_strm);\r\nreturn 0;\r\n}\r\nstatic struct zcomp_strm *zcomp_strm_single_find(struct zcomp *comp)\r\n{\r\nstruct zcomp_strm_single *zs = comp->stream;\r\nmutex_lock(&zs->strm_lock);\r\nreturn zs->zstrm;\r\n}\r\nstatic void zcomp_strm_single_release(struct zcomp *comp,\r\nstruct zcomp_strm *zstrm)\r\n{\r\nstruct zcomp_strm_single *zs = comp->stream;\r\nmutex_unlock(&zs->strm_lock);\r\n}\r\nstatic bool zcomp_strm_single_set_max_streams(struct zcomp *comp, int num_strm)\r\n{\r\nreturn false;\r\n}\r\nstatic void zcomp_strm_single_destroy(struct zcomp *comp)\r\n{\r\nstruct zcomp_strm_single *zs = comp->stream;\r\nzcomp_strm_free(comp, zs->zstrm);\r\nkfree(zs);\r\n}\r\nstatic int zcomp_strm_single_create(struct zcomp *comp)\r\n{\r\nstruct zcomp_strm_single *zs;\r\ncomp->destroy = zcomp_strm_single_destroy;\r\ncomp->strm_find = zcomp_strm_single_find;\r\ncomp->strm_release = zcomp_strm_single_release;\r\ncomp->set_max_streams = zcomp_strm_single_set_max_streams;\r\nzs = kmalloc(sizeof(struct zcomp_strm_single), GFP_KERNEL);\r\nif (!zs)\r\nreturn -ENOMEM;\r\ncomp->stream = zs;\r\nmutex_init(&zs->strm_lock);\r\nzs->zstrm = zcomp_strm_alloc(comp);\r\nif (!zs->zstrm) {\r\nkfree(zs);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nssize_t zcomp_available_show(const char *comp, char *buf)\r\n{\r\nssize_t sz = 0;\r\nint i = 0;\r\nwhile (backends[i]) {\r\nif (!strcmp(comp, backends[i]->name))\r\nsz += scnprintf(buf + sz, PAGE_SIZE - sz - 2,\r\n"[%s] ", backends[i]->name);\r\nelse\r\nsz += scnprintf(buf + sz, PAGE_SIZE - sz - 2,\r\n"%s ", backends[i]->name);\r\ni++;\r\n}\r\nsz += scnprintf(buf + sz, PAGE_SIZE - sz, "\n");\r\nreturn sz;\r\n}\r\nbool zcomp_available_algorithm(const char *comp)\r\n{\r\nreturn find_backend(comp) != NULL;\r\n}\r\nbool zcomp_set_max_streams(struct zcomp *comp, int num_strm)\r\n{\r\nreturn comp->set_max_streams(comp, num_strm);\r\n}\r\nstruct zcomp_strm *zcomp_strm_find(struct zcomp *comp)\r\n{\r\nreturn comp->strm_find(comp);\r\n}\r\nvoid zcomp_strm_release(struct zcomp *comp, struct zcomp_strm *zstrm)\r\n{\r\ncomp->strm_release(comp, zstrm);\r\n}\r\nint zcomp_compress(struct zcomp *comp, struct zcomp_strm *zstrm,\r\nconst unsigned char *src, size_t *dst_len)\r\n{\r\nreturn comp->backend->compress(src, zstrm->buffer, dst_len,\r\nzstrm->private);\r\n}\r\nint zcomp_decompress(struct zcomp *comp, const unsigned char *src,\r\nsize_t src_len, unsigned char *dst)\r\n{\r\nreturn comp->backend->decompress(src, src_len, dst);\r\n}\r\nvoid zcomp_destroy(struct zcomp *comp)\r\n{\r\ncomp->destroy(comp);\r\nkfree(comp);\r\n}\r\nstruct zcomp *zcomp_create(const char *compress, int max_strm)\r\n{\r\nstruct zcomp *comp;\r\nstruct zcomp_backend *backend;\r\nint error;\r\nbackend = find_backend(compress);\r\nif (!backend)\r\nreturn ERR_PTR(-EINVAL);\r\ncomp = kzalloc(sizeof(struct zcomp), GFP_KERNEL);\r\nif (!comp)\r\nreturn ERR_PTR(-ENOMEM);\r\ncomp->backend = backend;\r\nif (max_strm > 1)\r\nerror = zcomp_strm_multi_create(comp, max_strm);\r\nelse\r\nerror = zcomp_strm_single_create(comp);\r\nif (error) {\r\nkfree(comp);\r\nreturn ERR_PTR(error);\r\n}\r\nreturn comp;\r\n}
