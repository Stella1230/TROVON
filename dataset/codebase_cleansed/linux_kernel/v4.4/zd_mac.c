static int zd_reg2alpha2(u8 regdomain, char *alpha2)\r\n{\r\nunsigned int i;\r\nstruct zd_reg_alpha2_map *reg_map;\r\nfor (i = 0; i < ARRAY_SIZE(reg_alpha2_map); i++) {\r\nreg_map = &reg_alpha2_map[i];\r\nif (regdomain == reg_map->reg) {\r\nalpha2[0] = reg_map->alpha2[0];\r\nalpha2[1] = reg_map->alpha2[1];\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int zd_check_signal(struct ieee80211_hw *hw, int signal)\r\n{\r\nstruct zd_mac *mac = zd_hw_mac(hw);\r\ndev_dbg_f_cond(zd_mac_dev(mac), signal < 0 || signal > 100,\r\n"%s: signal value from device not in range 0..100, "\r\n"but %d.\n", __func__, signal);\r\nif (signal < 0)\r\nsignal = 0;\r\nelse if (signal > 100)\r\nsignal = 100;\r\nreturn signal;\r\n}\r\nint zd_mac_preinit_hw(struct ieee80211_hw *hw)\r\n{\r\nint r;\r\nu8 addr[ETH_ALEN];\r\nstruct zd_mac *mac = zd_hw_mac(hw);\r\nr = zd_chip_read_mac_addr_fw(&mac->chip, addr);\r\nif (r)\r\nreturn r;\r\nSET_IEEE80211_PERM_ADDR(hw, addr);\r\nreturn 0;\r\n}\r\nint zd_mac_init_hw(struct ieee80211_hw *hw)\r\n{\r\nint r;\r\nstruct zd_mac *mac = zd_hw_mac(hw);\r\nstruct zd_chip *chip = &mac->chip;\r\nchar alpha2[2];\r\nu8 default_regdomain;\r\nr = zd_chip_enable_int(chip);\r\nif (r)\r\ngoto out;\r\nr = zd_chip_init_hw(chip);\r\nif (r)\r\ngoto disable_int;\r\nZD_ASSERT(!irqs_disabled());\r\nr = zd_read_regdomain(chip, &default_regdomain);\r\nif (r)\r\ngoto disable_int;\r\nspin_lock_irq(&mac->lock);\r\nmac->regdomain = mac->default_regdomain = default_regdomain;\r\nspin_unlock_irq(&mac->lock);\r\nr = zd_set_encryption_type(chip, ENC_SNIFFER);\r\nif (r)\r\ngoto disable_int;\r\nr = zd_reg2alpha2(mac->regdomain, alpha2);\r\nif (r)\r\ngoto disable_int;\r\nr = regulatory_hint(hw->wiphy, alpha2);\r\ndisable_int:\r\nzd_chip_disable_int(chip);\r\nout:\r\nreturn r;\r\n}\r\nvoid zd_mac_clear(struct zd_mac *mac)\r\n{\r\nflush_workqueue(zd_workqueue);\r\nzd_chip_clear(&mac->chip);\r\nZD_ASSERT(!spin_is_locked(&mac->lock));\r\nZD_MEMCLEAR(mac, sizeof(struct zd_mac));\r\n}\r\nstatic int set_rx_filter(struct zd_mac *mac)\r\n{\r\nunsigned long flags;\r\nu32 filter = STA_RX_FILTER;\r\nspin_lock_irqsave(&mac->lock, flags);\r\nif (mac->pass_ctrl)\r\nfilter |= RX_FILTER_CTRL;\r\nspin_unlock_irqrestore(&mac->lock, flags);\r\nreturn zd_iowrite32(&mac->chip, CR_RX_FILTER, filter);\r\n}\r\nstatic int set_mac_and_bssid(struct zd_mac *mac)\r\n{\r\nint r;\r\nif (!mac->vif)\r\nreturn -1;\r\nr = zd_write_mac_addr(&mac->chip, mac->vif->addr);\r\nif (r)\r\nreturn r;\r\nif (mac->type != NL80211_IFTYPE_AP)\r\nreturn set_rx_filter(mac);\r\nelse\r\nreturn zd_write_bssid(&mac->chip, mac->vif->addr);\r\n}\r\nstatic int set_mc_hash(struct zd_mac *mac)\r\n{\r\nstruct zd_mc_hash hash;\r\nzd_mc_clear(&hash);\r\nreturn zd_chip_set_multicast_hash(&mac->chip, &hash);\r\n}\r\nint zd_op_start(struct ieee80211_hw *hw)\r\n{\r\nstruct zd_mac *mac = zd_hw_mac(hw);\r\nstruct zd_chip *chip = &mac->chip;\r\nstruct zd_usb *usb = &chip->usb;\r\nint r;\r\nif (!usb->initialized) {\r\nr = zd_usb_init_hw(usb);\r\nif (r)\r\ngoto out;\r\n}\r\nr = zd_chip_enable_int(chip);\r\nif (r < 0)\r\ngoto out;\r\nr = zd_chip_set_basic_rates(chip, CR_RATES_80211B | CR_RATES_80211G);\r\nif (r < 0)\r\ngoto disable_int;\r\nr = set_rx_filter(mac);\r\nif (r)\r\ngoto disable_int;\r\nr = set_mc_hash(mac);\r\nif (r)\r\ngoto disable_int;\r\nmsleep(10);\r\nr = zd_chip_switch_radio_on(chip);\r\nif (r < 0) {\r\ndev_err(zd_chip_dev(chip),\r\n"%s: failed to set radio on\n", __func__);\r\ngoto disable_int;\r\n}\r\nr = zd_chip_enable_rxtx(chip);\r\nif (r < 0)\r\ngoto disable_radio;\r\nr = zd_chip_enable_hwint(chip);\r\nif (r < 0)\r\ngoto disable_rxtx;\r\nhousekeeping_enable(mac);\r\nbeacon_enable(mac);\r\nset_bit(ZD_DEVICE_RUNNING, &mac->flags);\r\nreturn 0;\r\ndisable_rxtx:\r\nzd_chip_disable_rxtx(chip);\r\ndisable_radio:\r\nzd_chip_switch_radio_off(chip);\r\ndisable_int:\r\nzd_chip_disable_int(chip);\r\nout:\r\nreturn r;\r\n}\r\nvoid zd_op_stop(struct ieee80211_hw *hw)\r\n{\r\nstruct zd_mac *mac = zd_hw_mac(hw);\r\nstruct zd_chip *chip = &mac->chip;\r\nstruct sk_buff *skb;\r\nstruct sk_buff_head *ack_wait_queue = &mac->ack_wait_queue;\r\nclear_bit(ZD_DEVICE_RUNNING, &mac->flags);\r\nzd_chip_disable_rxtx(chip);\r\nbeacon_disable(mac);\r\nhousekeeping_disable(mac);\r\nflush_workqueue(zd_workqueue);\r\nzd_chip_disable_hwint(chip);\r\nzd_chip_switch_radio_off(chip);\r\nzd_chip_disable_int(chip);\r\nwhile ((skb = skb_dequeue(ack_wait_queue)))\r\ndev_kfree_skb_any(skb);\r\n}\r\nint zd_restore_settings(struct zd_mac *mac)\r\n{\r\nstruct sk_buff *beacon;\r\nstruct zd_mc_hash multicast_hash;\r\nunsigned int short_preamble;\r\nint r, beacon_interval, beacon_period;\r\nu8 channel;\r\ndev_dbg_f(zd_mac_dev(mac), "\n");\r\nspin_lock_irq(&mac->lock);\r\nmulticast_hash = mac->multicast_hash;\r\nshort_preamble = mac->short_preamble;\r\nbeacon_interval = mac->beacon.interval;\r\nbeacon_period = mac->beacon.period;\r\nchannel = mac->channel;\r\nspin_unlock_irq(&mac->lock);\r\nr = set_mac_and_bssid(mac);\r\nif (r < 0) {\r\ndev_dbg_f(zd_mac_dev(mac), "set_mac_and_bssid failed, %d\n", r);\r\nreturn r;\r\n}\r\nr = zd_chip_set_channel(&mac->chip, channel);\r\nif (r < 0) {\r\ndev_dbg_f(zd_mac_dev(mac), "zd_chip_set_channel failed, %d\n",\r\nr);\r\nreturn r;\r\n}\r\nset_rts_cts(mac, short_preamble);\r\nr = zd_chip_set_multicast_hash(&mac->chip, &multicast_hash);\r\nif (r < 0) {\r\ndev_dbg_f(zd_mac_dev(mac),\r\n"zd_chip_set_multicast_hash failed, %d\n", r);\r\nreturn r;\r\n}\r\nif (mac->type == NL80211_IFTYPE_MESH_POINT ||\r\nmac->type == NL80211_IFTYPE_ADHOC ||\r\nmac->type == NL80211_IFTYPE_AP) {\r\nif (mac->vif != NULL) {\r\nbeacon = ieee80211_beacon_get(mac->hw, mac->vif);\r\nif (beacon)\r\nzd_mac_config_beacon(mac->hw, beacon, false);\r\n}\r\nzd_set_beacon_interval(&mac->chip, beacon_interval,\r\nbeacon_period, mac->type);\r\nspin_lock_irq(&mac->lock);\r\nmac->beacon.last_update = jiffies;\r\nspin_unlock_irq(&mac->lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic void zd_mac_tx_status(struct ieee80211_hw *hw, struct sk_buff *skb,\r\nint ackssi, struct tx_status *tx_status)\r\n{\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nint i;\r\nint success = 1, retry = 1;\r\nint first_idx;\r\nconst struct tx_retry_rate *retries;\r\nieee80211_tx_info_clear_status(info);\r\nif (tx_status) {\r\nsuccess = !tx_status->failure;\r\nretry = tx_status->retry + success;\r\n}\r\nif (success) {\r\ninfo->flags |= IEEE80211_TX_STAT_ACK;\r\n} else {\r\ninfo->flags &= ~IEEE80211_TX_STAT_ACK;\r\n}\r\nfirst_idx = info->status.rates[0].idx;\r\nZD_ASSERT(0<=first_idx && first_idx<ARRAY_SIZE(zd_retry_rates));\r\nretries = &zd_retry_rates[first_idx];\r\nZD_ASSERT(1 <= retry && retry <= retries->count);\r\ninfo->status.rates[0].idx = retries->rate[0];\r\ninfo->status.rates[0].count = 1;\r\nfor (i=1; i<IEEE80211_TX_MAX_RATES-1 && i<retry; i++) {\r\ninfo->status.rates[i].idx = retries->rate[i];\r\ninfo->status.rates[i].count = 1;\r\n}\r\nfor (; i<IEEE80211_TX_MAX_RATES && i<retry; i++) {\r\ninfo->status.rates[i].idx = retries->rate[retry - 1];\r\ninfo->status.rates[i].count = 1;\r\n}\r\nif (i<IEEE80211_TX_MAX_RATES)\r\ninfo->status.rates[i].idx = -1;\r\ninfo->status.ack_signal = zd_check_signal(hw, ackssi);\r\nieee80211_tx_status_irqsafe(hw, skb);\r\n}\r\nvoid zd_mac_tx_failed(struct urb *urb)\r\n{\r\nstruct ieee80211_hw * hw = zd_usb_to_hw(urb->context);\r\nstruct zd_mac *mac = zd_hw_mac(hw);\r\nstruct sk_buff_head *q = &mac->ack_wait_queue;\r\nstruct sk_buff *skb;\r\nstruct tx_status *tx_status = (struct tx_status *)urb->transfer_buffer;\r\nunsigned long flags;\r\nint success = !tx_status->failure;\r\nint retry = tx_status->retry + success;\r\nint found = 0;\r\nint i, position = 0;\r\nq = &mac->ack_wait_queue;\r\nspin_lock_irqsave(&q->lock, flags);\r\nskb_queue_walk(q, skb) {\r\nstruct ieee80211_hdr *tx_hdr;\r\nstruct ieee80211_tx_info *info;\r\nint first_idx, final_idx;\r\nconst struct tx_retry_rate *retries;\r\nu8 final_rate;\r\nposition ++;\r\nif (tx_status->failure && mac->ack_pending &&\r\nskb_queue_is_first(q, skb)) {\r\ncontinue;\r\n}\r\ntx_hdr = (struct ieee80211_hdr *)skb->data;\r\nif (unlikely(!ether_addr_equal(tx_hdr->addr1, tx_status->mac)))\r\ncontinue;\r\ninfo = IEEE80211_SKB_CB(skb);\r\nfirst_idx = info->status.rates[0].idx;\r\nZD_ASSERT(0<=first_idx && first_idx<ARRAY_SIZE(zd_retry_rates));\r\nretries = &zd_retry_rates[first_idx];\r\nif (retry <= 0 || retry > retries->count)\r\ncontinue;\r\nfinal_idx = retries->rate[retry - 1];\r\nfinal_rate = zd_rates[final_idx].hw_value;\r\nif (final_rate != tx_status->rate) {\r\ncontinue;\r\n}\r\nfound = 1;\r\nbreak;\r\n}\r\nif (found) {\r\nfor (i=1; i<=position; i++) {\r\nskb = __skb_dequeue(q);\r\nzd_mac_tx_status(hw, skb,\r\nmac->ack_pending ? mac->ack_signal : 0,\r\ni == position ? tx_status : NULL);\r\nmac->ack_pending = 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&q->lock, flags);\r\n}\r\nvoid zd_mac_tx_to_dev(struct sk_buff *skb, int error)\r\n{\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_hw *hw = info->rate_driver_data[0];\r\nstruct zd_mac *mac = zd_hw_mac(hw);\r\nieee80211_tx_info_clear_status(info);\r\nskb_pull(skb, sizeof(struct zd_ctrlset));\r\nif (unlikely(error ||\r\n(info->flags & IEEE80211_TX_CTL_NO_ACK))) {\r\nieee80211_tx_status_irqsafe(hw, skb);\r\n} else {\r\nstruct sk_buff_head *q = &mac->ack_wait_queue;\r\nskb_queue_tail(q, skb);\r\nwhile (skb_queue_len(q) > ZD_MAC_MAX_ACK_WAITERS) {\r\nzd_mac_tx_status(hw, skb_dequeue(q),\r\nmac->ack_pending ? mac->ack_signal : 0,\r\nNULL);\r\nmac->ack_pending = 0;\r\n}\r\n}\r\n}\r\nstatic int zd_calc_tx_length_us(u8 *service, u8 zd_rate, u16 tx_length)\r\n{\r\nstatic const u8 rate_divisor[] = {\r\n[ZD_PURE_RATE(ZD_CCK_RATE_1M)] = 1,\r\n[ZD_PURE_RATE(ZD_CCK_RATE_2M)] = 2,\r\n[ZD_PURE_RATE(ZD_CCK_RATE_5_5M)] = 11,\r\n[ZD_PURE_RATE(ZD_CCK_RATE_11M)] = 11,\r\n[ZD_PURE_RATE(ZD_OFDM_RATE_6M)] = 6,\r\n[ZD_PURE_RATE(ZD_OFDM_RATE_9M)] = 9,\r\n[ZD_PURE_RATE(ZD_OFDM_RATE_12M)] = 12,\r\n[ZD_PURE_RATE(ZD_OFDM_RATE_18M)] = 18,\r\n[ZD_PURE_RATE(ZD_OFDM_RATE_24M)] = 24,\r\n[ZD_PURE_RATE(ZD_OFDM_RATE_36M)] = 36,\r\n[ZD_PURE_RATE(ZD_OFDM_RATE_48M)] = 48,\r\n[ZD_PURE_RATE(ZD_OFDM_RATE_54M)] = 54,\r\n};\r\nu32 bits = (u32)tx_length * 8;\r\nu32 divisor;\r\ndivisor = rate_divisor[ZD_PURE_RATE(zd_rate)];\r\nif (divisor == 0)\r\nreturn -EINVAL;\r\nswitch (zd_rate) {\r\ncase ZD_CCK_RATE_5_5M:\r\nbits = (2*bits) + 10;\r\nbreak;\r\ncase ZD_CCK_RATE_11M:\r\nif (service) {\r\nu32 t = bits % 11;\r\n*service &= ~ZD_PLCP_SERVICE_LENGTH_EXTENSION;\r\nif (0 < t && t <= 3) {\r\n*service |= ZD_PLCP_SERVICE_LENGTH_EXTENSION;\r\n}\r\n}\r\nbits += 10;\r\nbreak;\r\n}\r\nreturn bits/divisor;\r\n}\r\nstatic void cs_set_control(struct zd_mac *mac, struct zd_ctrlset *cs,\r\nstruct ieee80211_hdr *header,\r\nstruct ieee80211_tx_info *info)\r\n{\r\ncs->control = 0;\r\nif (info->flags & IEEE80211_TX_CTL_FIRST_FRAGMENT)\r\ncs->control |= ZD_CS_NEED_RANDOM_BACKOFF;\r\nif (info->flags & IEEE80211_TX_CTL_NO_ACK)\r\ncs->control |= ZD_CS_NO_ACK;\r\nif (ieee80211_is_pspoll(header->frame_control))\r\ncs->control |= ZD_CS_PS_POLL_FRAME;\r\nif (info->control.rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS)\r\ncs->control |= ZD_CS_RTS;\r\nif (info->control.rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT)\r\ncs->control |= ZD_CS_SELF_CTS;\r\n}\r\nstatic bool zd_mac_match_cur_beacon(struct zd_mac *mac, struct sk_buff *beacon)\r\n{\r\nif (!mac->beacon.cur_beacon)\r\nreturn false;\r\nif (mac->beacon.cur_beacon->len != beacon->len)\r\nreturn false;\r\nreturn !memcmp(beacon->data, mac->beacon.cur_beacon->data, beacon->len);\r\n}\r\nstatic void zd_mac_free_cur_beacon_locked(struct zd_mac *mac)\r\n{\r\nZD_ASSERT(mutex_is_locked(&mac->chip.mutex));\r\nkfree_skb(mac->beacon.cur_beacon);\r\nmac->beacon.cur_beacon = NULL;\r\n}\r\nstatic void zd_mac_free_cur_beacon(struct zd_mac *mac)\r\n{\r\nmutex_lock(&mac->chip.mutex);\r\nzd_mac_free_cur_beacon_locked(mac);\r\nmutex_unlock(&mac->chip.mutex);\r\n}\r\nstatic int zd_mac_config_beacon(struct ieee80211_hw *hw, struct sk_buff *beacon,\r\nbool in_intr)\r\n{\r\nstruct zd_mac *mac = zd_hw_mac(hw);\r\nint r, ret, num_cmds, req_pos = 0;\r\nu32 tmp, j = 0;\r\nu32 full_len = beacon->len + 4;\r\nunsigned long end_jiffies, message_jiffies;\r\nstruct zd_ioreq32 *ioreqs;\r\nmutex_lock(&mac->chip.mutex);\r\nif (zd_mac_match_cur_beacon(mac, beacon)) {\r\nr = 0;\r\ngoto out_nofree;\r\n}\r\nnum_cmds = 1 + zd_chip_is_zd1211b(&mac->chip) + full_len;\r\nioreqs = kmalloc(num_cmds * sizeof(struct zd_ioreq32), GFP_KERNEL);\r\nif (!ioreqs) {\r\nr = -ENOMEM;\r\ngoto out_nofree;\r\n}\r\nr = zd_iowrite32_locked(&mac->chip, 0, CR_BCN_FIFO_SEMAPHORE);\r\nif (r < 0)\r\ngoto out;\r\nr = zd_ioread32_locked(&mac->chip, &tmp, CR_BCN_FIFO_SEMAPHORE);\r\nif (r < 0)\r\ngoto release_sema;\r\nif (in_intr && tmp & 0x2) {\r\nr = -EBUSY;\r\ngoto release_sema;\r\n}\r\nend_jiffies = jiffies + HZ / 2;\r\nmessage_jiffies = jiffies + HZ / 10;\r\nwhile (tmp & 0x2) {\r\nr = zd_ioread32_locked(&mac->chip, &tmp, CR_BCN_FIFO_SEMAPHORE);\r\nif (r < 0)\r\ngoto release_sema;\r\nif (time_is_before_eq_jiffies(message_jiffies)) {\r\nmessage_jiffies = jiffies + HZ / 10;\r\ndev_err(zd_mac_dev(mac),\r\n"CR_BCN_FIFO_SEMAPHORE not ready\n");\r\nif (time_is_before_eq_jiffies(end_jiffies)) {\r\ndev_err(zd_mac_dev(mac),\r\n"Giving up beacon config.\n");\r\nr = -ETIMEDOUT;\r\ngoto reset_device;\r\n}\r\n}\r\nmsleep(20);\r\n}\r\nioreqs[req_pos].addr = CR_BCN_FIFO;\r\nioreqs[req_pos].value = full_len - 1;\r\nreq_pos++;\r\nif (zd_chip_is_zd1211b(&mac->chip)) {\r\nioreqs[req_pos].addr = CR_BCN_LENGTH;\r\nioreqs[req_pos].value = full_len - 1;\r\nreq_pos++;\r\n}\r\nfor (j = 0 ; j < beacon->len; j++) {\r\nioreqs[req_pos].addr = CR_BCN_FIFO;\r\nioreqs[req_pos].value = *((u8 *)(beacon->data + j));\r\nreq_pos++;\r\n}\r\nfor (j = 0; j < 4; j++) {\r\nioreqs[req_pos].addr = CR_BCN_FIFO;\r\nioreqs[req_pos].value = 0x0;\r\nreq_pos++;\r\n}\r\nBUG_ON(req_pos != num_cmds);\r\nr = zd_iowrite32a_locked(&mac->chip, ioreqs, num_cmds);\r\nrelease_sema:\r\nend_jiffies = jiffies + HZ / 2;\r\nret = zd_iowrite32_locked(&mac->chip, 1, CR_BCN_FIFO_SEMAPHORE);\r\nwhile (ret < 0) {\r\nif (in_intr || time_is_before_eq_jiffies(end_jiffies)) {\r\nret = -ETIMEDOUT;\r\nbreak;\r\n}\r\nmsleep(20);\r\nret = zd_iowrite32_locked(&mac->chip, 1, CR_BCN_FIFO_SEMAPHORE);\r\n}\r\nif (ret < 0)\r\ndev_err(zd_mac_dev(mac), "Could not release "\r\n"CR_BCN_FIFO_SEMAPHORE!\n");\r\nif (r < 0 || ret < 0) {\r\nif (r >= 0)\r\nr = ret;\r\nzd_mac_free_cur_beacon_locked(mac);\r\ngoto out;\r\n}\r\nzd_mac_free_cur_beacon_locked(mac);\r\nmac->beacon.cur_beacon = beacon;\r\nbeacon = NULL;\r\nr = zd_iowrite32_locked(&mac->chip, 0x00000400 | (full_len << 19),\r\nCR_BCN_PLCP_CFG);\r\nout:\r\nkfree(ioreqs);\r\nout_nofree:\r\nkfree_skb(beacon);\r\nmutex_unlock(&mac->chip.mutex);\r\nreturn r;\r\nreset_device:\r\nzd_mac_free_cur_beacon_locked(mac);\r\nkfree_skb(beacon);\r\nmutex_unlock(&mac->chip.mutex);\r\nkfree(ioreqs);\r\ndev_warn(zd_mac_dev(mac), "CR_BCN_FIFO_SEMAPHORE stuck, "\r\n"resetting device...");\r\nusb_queue_reset_device(mac->chip.usb.intf);\r\nreturn r;\r\n}\r\nstatic int fill_ctrlset(struct zd_mac *mac,\r\nstruct sk_buff *skb)\r\n{\r\nint r;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nunsigned int frag_len = skb->len + FCS_LEN;\r\nunsigned int packet_length;\r\nstruct ieee80211_rate *txrate;\r\nstruct zd_ctrlset *cs = (struct zd_ctrlset *)\r\nskb_push(skb, sizeof(struct zd_ctrlset));\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nZD_ASSERT(frag_len <= 0xffff);\r\nif (!ieee80211_is_pspoll(hdr->frame_control))\r\nhdr->duration_id = 0;\r\ntxrate = ieee80211_get_tx_rate(mac->hw, info);\r\ncs->modulation = txrate->hw_value;\r\nif (info->control.rates[0].flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)\r\ncs->modulation = txrate->hw_value_short;\r\ncs->tx_length = cpu_to_le16(frag_len);\r\ncs_set_control(mac, cs, hdr, info);\r\npacket_length = frag_len + sizeof(struct zd_ctrlset) + 10;\r\nZD_ASSERT(packet_length <= 0xffff);\r\ncs->packet_length = cpu_to_le16(zd_chip_is_zd1211b(&mac->chip) ?\r\npacket_length - frag_len : packet_length);\r\ncs->service = 0;\r\nr = zd_calc_tx_length_us(&cs->service, ZD_RATE(cs->modulation),\r\nle16_to_cpu(cs->tx_length));\r\nif (r < 0)\r\nreturn r;\r\ncs->current_length = cpu_to_le16(r);\r\ncs->next_frame_length = 0;\r\nreturn 0;\r\n}\r\nstatic void zd_op_tx(struct ieee80211_hw *hw,\r\nstruct ieee80211_tx_control *control,\r\nstruct sk_buff *skb)\r\n{\r\nstruct zd_mac *mac = zd_hw_mac(hw);\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nint r;\r\nr = fill_ctrlset(mac, skb);\r\nif (r)\r\ngoto fail;\r\ninfo->rate_driver_data[0] = hw;\r\nr = zd_usb_tx(&mac->chip.usb, skb);\r\nif (r)\r\ngoto fail;\r\nreturn;\r\nfail:\r\ndev_kfree_skb(skb);\r\n}\r\nstatic int filter_ack(struct ieee80211_hw *hw, struct ieee80211_hdr *rx_hdr,\r\nstruct ieee80211_rx_status *stats)\r\n{\r\nstruct zd_mac *mac = zd_hw_mac(hw);\r\nstruct sk_buff *skb;\r\nstruct sk_buff_head *q;\r\nunsigned long flags;\r\nint found = 0;\r\nint i, position = 0;\r\nif (!ieee80211_is_ack(rx_hdr->frame_control))\r\nreturn 0;\r\nq = &mac->ack_wait_queue;\r\nspin_lock_irqsave(&q->lock, flags);\r\nskb_queue_walk(q, skb) {\r\nstruct ieee80211_hdr *tx_hdr;\r\nposition ++;\r\nif (mac->ack_pending && skb_queue_is_first(q, skb))\r\ncontinue;\r\ntx_hdr = (struct ieee80211_hdr *)skb->data;\r\nif (likely(ether_addr_equal(tx_hdr->addr2, rx_hdr->addr1)))\r\n{\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found) {\r\nfor (i=1; i<position; i++) {\r\nskb = __skb_dequeue(q);\r\nzd_mac_tx_status(hw, skb,\r\nmac->ack_pending ? mac->ack_signal : 0,\r\nNULL);\r\nmac->ack_pending = 0;\r\n}\r\nmac->ack_pending = 1;\r\nmac->ack_signal = stats->signal;\r\nif (mac->type == NL80211_IFTYPE_AP) {\r\nskb = __skb_dequeue(q);\r\nzd_mac_tx_status(hw, skb, mac->ack_signal, NULL);\r\nmac->ack_pending = 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&q->lock, flags);\r\nreturn 1;\r\n}\r\nint zd_mac_rx(struct ieee80211_hw *hw, const u8 *buffer, unsigned int length)\r\n{\r\nstruct zd_mac *mac = zd_hw_mac(hw);\r\nstruct ieee80211_rx_status stats;\r\nconst struct rx_status *status;\r\nstruct sk_buff *skb;\r\nint bad_frame = 0;\r\n__le16 fc;\r\nint need_padding;\r\nint i;\r\nu8 rate;\r\nif (length < ZD_PLCP_HEADER_SIZE + 10 +\r\nFCS_LEN + sizeof(struct rx_status))\r\nreturn -EINVAL;\r\nmemset(&stats, 0, sizeof(stats));\r\nstatus = (struct rx_status *)\r\n(buffer + (length - sizeof(struct rx_status)));\r\nif (status->frame_status & ZD_RX_ERROR) {\r\nif (mac->pass_failed_fcs &&\r\n(status->frame_status & ZD_RX_CRC32_ERROR)) {\r\nstats.flag |= RX_FLAG_FAILED_FCS_CRC;\r\nbad_frame = 1;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\nstats.freq = zd_channels[_zd_chip_get_channel(&mac->chip) - 1].center_freq;\r\nstats.band = IEEE80211_BAND_2GHZ;\r\nstats.signal = zd_check_signal(hw, status->signal_strength);\r\nrate = zd_rx_rate(buffer, status);\r\nfor (i = 0; i < mac->band.n_bitrates; i++)\r\nif (rate == mac->band.bitrates[i].hw_value)\r\nstats.rate_idx = i;\r\nlength -= ZD_PLCP_HEADER_SIZE + sizeof(struct rx_status);\r\nbuffer += ZD_PLCP_HEADER_SIZE;\r\nif (!bad_frame &&\r\nfilter_ack(hw, (struct ieee80211_hdr *)buffer, &stats)\r\n&& !mac->pass_ctrl)\r\nreturn 0;\r\nfc = get_unaligned((__le16*)buffer);\r\nneed_padding = ieee80211_is_data_qos(fc) ^ ieee80211_has_a4(fc);\r\nskb = dev_alloc_skb(length + (need_padding ? 2 : 0));\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nif (need_padding) {\r\nskb_reserve(skb, 2);\r\n}\r\nmemcpy(skb_put(skb, length), buffer, length);\r\nmemcpy(IEEE80211_SKB_RXCB(skb), &stats, sizeof(stats));\r\nieee80211_rx_irqsafe(hw, skb);\r\nreturn 0;\r\n}\r\nstatic int zd_op_add_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct zd_mac *mac = zd_hw_mac(hw);\r\nif (mac->type != NL80211_IFTYPE_UNSPECIFIED)\r\nreturn -EOPNOTSUPP;\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_MONITOR:\r\ncase NL80211_IFTYPE_MESH_POINT:\r\ncase NL80211_IFTYPE_STATION:\r\ncase NL80211_IFTYPE_ADHOC:\r\ncase NL80211_IFTYPE_AP:\r\nmac->type = vif->type;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nmac->vif = vif;\r\nreturn set_mac_and_bssid(mac);\r\n}\r\nstatic void zd_op_remove_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct zd_mac *mac = zd_hw_mac(hw);\r\nmac->type = NL80211_IFTYPE_UNSPECIFIED;\r\nmac->vif = NULL;\r\nzd_set_beacon_interval(&mac->chip, 0, 0, NL80211_IFTYPE_UNSPECIFIED);\r\nzd_write_mac_addr(&mac->chip, NULL);\r\nzd_mac_free_cur_beacon(mac);\r\n}\r\nstatic int zd_op_config(struct ieee80211_hw *hw, u32 changed)\r\n{\r\nstruct zd_mac *mac = zd_hw_mac(hw);\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nspin_lock_irq(&mac->lock);\r\nmac->channel = conf->chandef.chan->hw_value;\r\nspin_unlock_irq(&mac->lock);\r\nreturn zd_chip_set_channel(&mac->chip, conf->chandef.chan->hw_value);\r\n}\r\nstatic void zd_beacon_done(struct zd_mac *mac)\r\n{\r\nstruct sk_buff *skb, *beacon;\r\nif (!test_bit(ZD_DEVICE_RUNNING, &mac->flags))\r\nreturn;\r\nif (!mac->vif || mac->vif->type != NL80211_IFTYPE_AP)\r\nreturn;\r\nwhile (!ieee80211_queue_stopped(mac->hw, 0)) {\r\nskb = ieee80211_get_buffered_bc(mac->hw, mac->vif);\r\nif (!skb)\r\nbreak;\r\nzd_op_tx(mac->hw, NULL, skb);\r\n}\r\nbeacon = ieee80211_beacon_get(mac->hw, mac->vif);\r\nif (beacon)\r\nzd_mac_config_beacon(mac->hw, beacon, true);\r\nspin_lock_irq(&mac->lock);\r\nmac->beacon.last_update = jiffies;\r\nspin_unlock_irq(&mac->lock);\r\n}\r\nstatic void zd_process_intr(struct work_struct *work)\r\n{\r\nu16 int_status;\r\nunsigned long flags;\r\nstruct zd_mac *mac = container_of(work, struct zd_mac, process_intr);\r\nspin_lock_irqsave(&mac->lock, flags);\r\nint_status = le16_to_cpu(*(__le16 *)(mac->intr_buffer + 4));\r\nspin_unlock_irqrestore(&mac->lock, flags);\r\nif (int_status & INT_CFG_NEXT_BCN) {\r\nzd_beacon_done(mac);\r\n} else {\r\ndev_dbg_f(zd_mac_dev(mac), "Unsupported interrupt\n");\r\n}\r\nzd_chip_enable_hwint(&mac->chip);\r\n}\r\nstatic u64 zd_op_prepare_multicast(struct ieee80211_hw *hw,\r\nstruct netdev_hw_addr_list *mc_list)\r\n{\r\nstruct zd_mac *mac = zd_hw_mac(hw);\r\nstruct zd_mc_hash hash;\r\nstruct netdev_hw_addr *ha;\r\nzd_mc_clear(&hash);\r\nnetdev_hw_addr_list_for_each(ha, mc_list) {\r\ndev_dbg_f(zd_mac_dev(mac), "mc addr %pM\n", ha->addr);\r\nzd_mc_add_addr(&hash, ha->addr);\r\n}\r\nreturn hash.low | ((u64)hash.high << 32);\r\n}\r\nstatic void zd_op_configure_filter(struct ieee80211_hw *hw,\r\nunsigned int changed_flags,\r\nunsigned int *new_flags,\r\nu64 multicast)\r\n{\r\nstruct zd_mc_hash hash = {\r\n.low = multicast,\r\n.high = multicast >> 32,\r\n};\r\nstruct zd_mac *mac = zd_hw_mac(hw);\r\nunsigned long flags;\r\nint r;\r\nchanged_flags &= SUPPORTED_FIF_FLAGS;\r\n*new_flags &= SUPPORTED_FIF_FLAGS;\r\nif (*new_flags & FIF_ALLMULTI)\r\nzd_mc_add_all(&hash);\r\nspin_lock_irqsave(&mac->lock, flags);\r\nmac->pass_failed_fcs = !!(*new_flags & FIF_FCSFAIL);\r\nmac->pass_ctrl = !!(*new_flags & FIF_CONTROL);\r\nmac->multicast_hash = hash;\r\nspin_unlock_irqrestore(&mac->lock, flags);\r\nzd_chip_set_multicast_hash(&mac->chip, &hash);\r\nif (changed_flags & FIF_CONTROL) {\r\nr = set_rx_filter(mac);\r\nif (r)\r\ndev_err(zd_mac_dev(mac), "set_rx_filter error %d\n", r);\r\n}\r\n}\r\nstatic void set_rts_cts(struct zd_mac *mac, unsigned int short_preamble)\r\n{\r\nmutex_lock(&mac->chip.mutex);\r\nzd_chip_set_rts_cts_rate_locked(&mac->chip, short_preamble);\r\nmutex_unlock(&mac->chip.mutex);\r\n}\r\nstatic void zd_op_bss_info_changed(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *bss_conf,\r\nu32 changes)\r\n{\r\nstruct zd_mac *mac = zd_hw_mac(hw);\r\nint associated;\r\ndev_dbg_f(zd_mac_dev(mac), "changes: %x\n", changes);\r\nif (mac->type == NL80211_IFTYPE_MESH_POINT ||\r\nmac->type == NL80211_IFTYPE_ADHOC ||\r\nmac->type == NL80211_IFTYPE_AP) {\r\nassociated = true;\r\nif (changes & BSS_CHANGED_BEACON) {\r\nstruct sk_buff *beacon = ieee80211_beacon_get(hw, vif);\r\nif (beacon) {\r\nzd_chip_disable_hwint(&mac->chip);\r\nzd_mac_config_beacon(hw, beacon, false);\r\nzd_chip_enable_hwint(&mac->chip);\r\n}\r\n}\r\nif (changes & BSS_CHANGED_BEACON_ENABLED) {\r\nu16 interval = 0;\r\nu8 period = 0;\r\nif (bss_conf->enable_beacon) {\r\nperiod = bss_conf->dtim_period;\r\ninterval = bss_conf->beacon_int;\r\n}\r\nspin_lock_irq(&mac->lock);\r\nmac->beacon.period = period;\r\nmac->beacon.interval = interval;\r\nmac->beacon.last_update = jiffies;\r\nspin_unlock_irq(&mac->lock);\r\nzd_set_beacon_interval(&mac->chip, interval, period,\r\nmac->type);\r\n}\r\n} else\r\nassociated = is_valid_ether_addr(bss_conf->bssid);\r\nspin_lock_irq(&mac->lock);\r\nmac->associated = associated;\r\nspin_unlock_irq(&mac->lock);\r\nif (changes & BSS_CHANGED_ERP_PREAMBLE) {\r\nspin_lock_irq(&mac->lock);\r\nmac->short_preamble = bss_conf->use_short_preamble;\r\nspin_unlock_irq(&mac->lock);\r\nset_rts_cts(mac, bss_conf->use_short_preamble);\r\n}\r\n}\r\nstatic u64 zd_op_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\r\n{\r\nstruct zd_mac *mac = zd_hw_mac(hw);\r\nreturn zd_chip_get_tsf(&mac->chip);\r\n}\r\nstruct ieee80211_hw *zd_mac_alloc_hw(struct usb_interface *intf)\r\n{\r\nstruct zd_mac *mac;\r\nstruct ieee80211_hw *hw;\r\nhw = ieee80211_alloc_hw(sizeof(struct zd_mac), &zd_ops);\r\nif (!hw) {\r\ndev_dbg_f(&intf->dev, "out of memory\n");\r\nreturn NULL;\r\n}\r\nmac = zd_hw_mac(hw);\r\nmemset(mac, 0, sizeof(*mac));\r\nspin_lock_init(&mac->lock);\r\nmac->hw = hw;\r\nmac->type = NL80211_IFTYPE_UNSPECIFIED;\r\nmemcpy(mac->channels, zd_channels, sizeof(zd_channels));\r\nmemcpy(mac->rates, zd_rates, sizeof(zd_rates));\r\nmac->band.n_bitrates = ARRAY_SIZE(zd_rates);\r\nmac->band.bitrates = mac->rates;\r\nmac->band.n_channels = ARRAY_SIZE(zd_channels);\r\nmac->band.channels = mac->channels;\r\nhw->wiphy->bands[IEEE80211_BAND_2GHZ] = &mac->band;\r\nieee80211_hw_set(hw, MFP_CAPABLE);\r\nieee80211_hw_set(hw, HOST_BROADCAST_PS_BUFFERING);\r\nieee80211_hw_set(hw, RX_INCLUDES_FCS);\r\nieee80211_hw_set(hw, SIGNAL_UNSPEC);\r\nhw->wiphy->interface_modes =\r\nBIT(NL80211_IFTYPE_MESH_POINT) |\r\nBIT(NL80211_IFTYPE_STATION) |\r\nBIT(NL80211_IFTYPE_ADHOC) |\r\nBIT(NL80211_IFTYPE_AP);\r\nhw->max_signal = 100;\r\nhw->queues = 1;\r\nhw->extra_tx_headroom = sizeof(struct zd_ctrlset);\r\nhw->max_rates = IEEE80211_TX_MAX_RATES;\r\nhw->max_rate_tries = 18;\r\nskb_queue_head_init(&mac->ack_wait_queue);\r\nmac->ack_pending = 0;\r\nzd_chip_init(&mac->chip, hw, intf);\r\nhousekeeping_init(mac);\r\nbeacon_init(mac);\r\nINIT_WORK(&mac->process_intr, zd_process_intr);\r\nSET_IEEE80211_DEV(hw, &intf->dev);\r\nreturn hw;\r\n}\r\nstatic void beacon_watchdog_handler(struct work_struct *work)\r\n{\r\nstruct zd_mac *mac =\r\ncontainer_of(work, struct zd_mac, beacon.watchdog_work.work);\r\nstruct sk_buff *beacon;\r\nunsigned long timeout;\r\nint interval, period;\r\nif (!test_bit(ZD_DEVICE_RUNNING, &mac->flags))\r\ngoto rearm;\r\nif (mac->type != NL80211_IFTYPE_AP || !mac->vif)\r\ngoto rearm;\r\nspin_lock_irq(&mac->lock);\r\ninterval = mac->beacon.interval;\r\nperiod = mac->beacon.period;\r\ntimeout = mac->beacon.last_update +\r\nmsecs_to_jiffies(interval * 1024 / 1000) * 3;\r\nspin_unlock_irq(&mac->lock);\r\nif (interval > 0 && time_is_before_jiffies(timeout)) {\r\ndev_dbg_f(zd_mac_dev(mac), "beacon interrupt stalled, "\r\n"restarting. "\r\n"(interval: %d, dtim: %d)\n",\r\ninterval, period);\r\nzd_chip_disable_hwint(&mac->chip);\r\nbeacon = ieee80211_beacon_get(mac->hw, mac->vif);\r\nif (beacon) {\r\nzd_mac_free_cur_beacon(mac);\r\nzd_mac_config_beacon(mac->hw, beacon, false);\r\n}\r\nzd_set_beacon_interval(&mac->chip, interval, period, mac->type);\r\nzd_chip_enable_hwint(&mac->chip);\r\nspin_lock_irq(&mac->lock);\r\nmac->beacon.last_update = jiffies;\r\nspin_unlock_irq(&mac->lock);\r\n}\r\nrearm:\r\nqueue_delayed_work(zd_workqueue, &mac->beacon.watchdog_work,\r\nBEACON_WATCHDOG_DELAY);\r\n}\r\nstatic void beacon_init(struct zd_mac *mac)\r\n{\r\nINIT_DELAYED_WORK(&mac->beacon.watchdog_work, beacon_watchdog_handler);\r\n}\r\nstatic void beacon_enable(struct zd_mac *mac)\r\n{\r\ndev_dbg_f(zd_mac_dev(mac), "\n");\r\nmac->beacon.last_update = jiffies;\r\nqueue_delayed_work(zd_workqueue, &mac->beacon.watchdog_work,\r\nBEACON_WATCHDOG_DELAY);\r\n}\r\nstatic void beacon_disable(struct zd_mac *mac)\r\n{\r\ndev_dbg_f(zd_mac_dev(mac), "\n");\r\ncancel_delayed_work_sync(&mac->beacon.watchdog_work);\r\nzd_mac_free_cur_beacon(mac);\r\n}\r\nstatic void link_led_handler(struct work_struct *work)\r\n{\r\nstruct zd_mac *mac =\r\ncontainer_of(work, struct zd_mac, housekeeping.link_led_work.work);\r\nstruct zd_chip *chip = &mac->chip;\r\nint is_associated;\r\nint r;\r\nif (!test_bit(ZD_DEVICE_RUNNING, &mac->flags))\r\ngoto requeue;\r\nspin_lock_irq(&mac->lock);\r\nis_associated = mac->associated;\r\nspin_unlock_irq(&mac->lock);\r\nr = zd_chip_control_leds(chip,\r\nis_associated ? ZD_LED_ASSOCIATED : ZD_LED_SCANNING);\r\nif (r)\r\ndev_dbg_f(zd_mac_dev(mac), "zd_chip_control_leds error %d\n", r);\r\nrequeue:\r\nqueue_delayed_work(zd_workqueue, &mac->housekeeping.link_led_work,\r\nLINK_LED_WORK_DELAY);\r\n}\r\nstatic void housekeeping_init(struct zd_mac *mac)\r\n{\r\nINIT_DELAYED_WORK(&mac->housekeeping.link_led_work, link_led_handler);\r\n}\r\nstatic void housekeeping_enable(struct zd_mac *mac)\r\n{\r\ndev_dbg_f(zd_mac_dev(mac), "\n");\r\nqueue_delayed_work(zd_workqueue, &mac->housekeeping.link_led_work,\r\n0);\r\n}\r\nstatic void housekeeping_disable(struct zd_mac *mac)\r\n{\r\ndev_dbg_f(zd_mac_dev(mac), "\n");\r\ncancel_delayed_work_sync(&mac->housekeeping.link_led_work);\r\nzd_chip_control_leds(&mac->chip, ZD_LED_OFF);\r\n}
