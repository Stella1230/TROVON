static struct device_node *__of_find_node_by_full_name(struct device_node *node,\r\nconst char *full_name)\r\n{\r\nstruct device_node *child, *found;\r\nif (node == NULL)\r\nreturn NULL;\r\nif (of_node_cmp(node->full_name, full_name) == 0)\r\nreturn node;\r\nfor_each_child_of_node(node, child) {\r\nfound = __of_find_node_by_full_name(child, full_name);\r\nif (found != NULL)\r\nreturn found;\r\n}\r\nreturn NULL;\r\n}\r\nstatic phandle of_get_tree_max_phandle(void)\r\n{\r\nstruct device_node *node;\r\nphandle phandle;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&devtree_lock, flags);\r\nphandle = 0;\r\nfor_each_of_allnodes(node) {\r\nif (node->phandle != OF_PHANDLE_ILLEGAL &&\r\nnode->phandle > phandle)\r\nphandle = node->phandle;\r\n}\r\nraw_spin_unlock_irqrestore(&devtree_lock, flags);\r\nreturn phandle;\r\n}\r\nstatic void __of_adjust_tree_phandles(struct device_node *node,\r\nint phandle_delta)\r\n{\r\nstruct device_node *child;\r\nstruct property *prop;\r\nphandle phandle;\r\nif (node->phandle != 0 && node->phandle != OF_PHANDLE_ILLEGAL)\r\nnode->phandle += phandle_delta;\r\nfor_each_property_of_node(node, prop) {\r\nif (of_prop_cmp(prop->name, "phandle") != 0 &&\r\nof_prop_cmp(prop->name, "linux,phandle") != 0)\r\ncontinue;\r\nif (prop->length < 4)\r\ncontinue;\r\nphandle = be32_to_cpup(prop->value);\r\nif (phandle == OF_PHANDLE_ILLEGAL)\r\ncontinue;\r\n*(uint32_t *)prop->value = cpu_to_be32(node->phandle);\r\n}\r\nfor_each_child_of_node(node, child)\r\n__of_adjust_tree_phandles(child, phandle_delta);\r\n}\r\nstatic int __of_adjust_phandle_ref(struct device_node *node,\r\nstruct property *rprop, int value)\r\n{\r\nphandle phandle;\r\nstruct device_node *refnode;\r\nstruct property *sprop;\r\nchar *propval, *propcur, *propend, *nodestr, *propstr, *s;\r\nint offset, propcurlen;\r\nint err = 0;\r\npropval = kmalloc(rprop->length, GFP_KERNEL);\r\nif (!propval) {\r\npr_err("%s: Could not copy value of '%s'\n",\r\n__func__, rprop->name);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(propval, rprop->value, rprop->length);\r\npropend = propval + rprop->length;\r\nfor (propcur = propval; propcur < propend; propcur += propcurlen + 1) {\r\npropcurlen = strlen(propcur);\r\nnodestr = propcur;\r\ns = strchr(propcur, ':');\r\nif (!s) {\r\npr_err("%s: Illegal symbol entry '%s' (1)\n",\r\n__func__, propcur);\r\nerr = -EINVAL;\r\ngoto err_fail;\r\n}\r\n*s++ = '\0';\r\npropstr = s;\r\ns = strchr(s, ':');\r\nif (!s) {\r\npr_err("%s: Illegal symbol entry '%s' (2)\n",\r\n__func__, (char *)rprop->value);\r\nerr = -EINVAL;\r\ngoto err_fail;\r\n}\r\n*s++ = '\0';\r\nerr = kstrtoint(s, 10, &offset);\r\nif (err != 0) {\r\npr_err("%s: Could get offset '%s'\n",\r\n__func__, (char *)rprop->value);\r\ngoto err_fail;\r\n}\r\nrefnode = __of_find_node_by_full_name(node, nodestr);\r\nif (!refnode) {\r\npr_warn("%s: Could not find refnode '%s'\n",\r\n__func__, (char *)rprop->value);\r\ncontinue;\r\n}\r\nfor_each_property_of_node(refnode, sprop) {\r\nif (of_prop_cmp(sprop->name, propstr) == 0)\r\nbreak;\r\n}\r\nif (!sprop) {\r\npr_err("%s: Could not find property '%s'\n",\r\n__func__, (char *)rprop->value);\r\nerr = -ENOENT;\r\ngoto err_fail;\r\n}\r\nphandle = value;\r\n*(__be32 *)(sprop->value + offset) = cpu_to_be32(phandle);\r\n}\r\nerr_fail:\r\nkfree(propval);\r\nreturn err;\r\n}\r\nstatic int __of_node_name_cmp(const struct device_node *dn1,\r\nconst struct device_node *dn2)\r\n{\r\nconst char *n1 = strrchr(dn1->full_name, '/') ? : "/";\r\nconst char *n2 = strrchr(dn2->full_name, '/') ? : "/";\r\nreturn of_node_cmp(n1, n2);\r\n}\r\nstatic int __of_adjust_tree_phandle_references(struct device_node *node,\r\nstruct device_node *target, int phandle_delta)\r\n{\r\nstruct device_node *child, *childtarget;\r\nstruct property *rprop, *sprop;\r\nint err, i, count;\r\nunsigned int off;\r\nphandle phandle;\r\nif (node == NULL)\r\nreturn 0;\r\nfor_each_property_of_node(node, rprop) {\r\nif (of_prop_cmp(rprop->name, "name") == 0 ||\r\nof_prop_cmp(rprop->name, "phandle") == 0 ||\r\nof_prop_cmp(rprop->name, "linux,phandle") == 0)\r\ncontinue;\r\nif ((rprop->length % 4) != 0 || rprop->length == 0) {\r\npr_err("%s: Illegal property (size) '%s' @%s\n",\r\n__func__, rprop->name, node->full_name);\r\nreturn -EINVAL;\r\n}\r\ncount = rprop->length / sizeof(__be32);\r\nfor_each_property_of_node(target, sprop) {\r\nif (of_prop_cmp(sprop->name, rprop->name) == 0)\r\nbreak;\r\n}\r\nif (sprop == NULL) {\r\npr_err("%s: Could not find target property '%s' @%s\n",\r\n__func__, rprop->name, node->full_name);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < count; i++) {\r\noff = be32_to_cpu(((__be32 *)rprop->value)[i]);\r\nif (off >= sprop->length ||\r\n(off + 4) > sprop->length) {\r\npr_err("%s: Illegal property '%s' @%s\n",\r\n__func__, rprop->name,\r\nnode->full_name);\r\nreturn -EINVAL;\r\n}\r\nif (phandle_delta) {\r\nphandle = be32_to_cpu(*(__be32 *)(sprop->value + off));\r\nphandle += phandle_delta;\r\n*(__be32 *)(sprop->value + off) = cpu_to_be32(phandle);\r\n}\r\n}\r\n}\r\nfor_each_child_of_node(node, child) {\r\nfor_each_child_of_node(target, childtarget)\r\nif (__of_node_name_cmp(child, childtarget) == 0)\r\nbreak;\r\nif (!childtarget) {\r\npr_err("%s: Could not find target child '%s' @%s\n",\r\n__func__, child->name, node->full_name);\r\nreturn -EINVAL;\r\n}\r\nerr = __of_adjust_tree_phandle_references(child, childtarget,\r\nphandle_delta);\r\nif (err != 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint of_resolve_phandles(struct device_node *resolve)\r\n{\r\nstruct device_node *child, *childroot, *refnode;\r\nstruct device_node *root_sym, *resolve_sym, *resolve_fix;\r\nstruct property *rprop;\r\nconst char *refpath;\r\nphandle phandle, phandle_delta;\r\nint err;\r\nif (!resolve || !of_node_check_flag(resolve, OF_DETACHED))\r\nreturn -EINVAL;\r\nphandle_delta = of_get_tree_max_phandle() + 1;\r\n__of_adjust_tree_phandles(resolve, phandle_delta);\r\nchildroot = NULL;\r\nfor_each_child_of_node(resolve, childroot)\r\nif (of_node_cmp(childroot->name, "__local_fixups__") == 0)\r\nbreak;\r\nif (childroot != NULL) {\r\nerr = __of_adjust_tree_phandle_references(childroot,\r\nresolve, 0);\r\nif (err != 0)\r\nreturn err;\r\nBUG_ON(__of_adjust_tree_phandle_references(childroot,\r\nresolve, phandle_delta));\r\n}\r\nroot_sym = NULL;\r\nresolve_sym = NULL;\r\nresolve_fix = NULL;\r\nroot_sym = of_find_node_by_path("/__symbols__");\r\nfor_each_child_of_node(resolve, child) {\r\nif (!resolve_sym &&\r\nof_node_cmp(child->name, "__symbols__") == 0)\r\nresolve_sym = child;\r\nif (!resolve_fix &&\r\nof_node_cmp(child->name, "__fixups__") == 0)\r\nresolve_fix = child;\r\nif (resolve_sym && resolve_fix)\r\nbreak;\r\n}\r\nif (!resolve_fix) {\r\nerr = 0;\r\ngoto out;\r\n}\r\nif (!root_sym) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nfor_each_property_of_node(resolve_fix, rprop) {\r\nif (of_prop_cmp(rprop->name, "name") == 0)\r\ncontinue;\r\nerr = of_property_read_string(root_sym,\r\nrprop->name, &refpath);\r\nif (err != 0) {\r\npr_err("%s: Could not find symbol '%s'\n",\r\n__func__, rprop->name);\r\ngoto out;\r\n}\r\nrefnode = of_find_node_by_path(refpath);\r\nif (!refnode) {\r\npr_err("%s: Could not find node by path '%s'\n",\r\n__func__, refpath);\r\nerr = -ENOENT;\r\ngoto out;\r\n}\r\nphandle = refnode->phandle;\r\nof_node_put(refnode);\r\npr_debug("%s: %s phandle is 0x%08x\n",\r\n__func__, rprop->name, phandle);\r\nerr = __of_adjust_phandle_ref(resolve, rprop, phandle);\r\nif (err)\r\nbreak;\r\n}\r\nout:\r\nof_node_put(root_sym);\r\nreturn err;\r\n}
