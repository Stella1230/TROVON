static inline int lz4_compressctx(void *ctx,\r\nconst char *source,\r\nchar *dest,\r\nint isize,\r\nint maxoutputsize)\r\n{\r\nHTYPE *hashtable = (HTYPE *)ctx;\r\nconst u8 *ip = (u8 *)source;\r\n#if LZ4_ARCH64\r\nconst BYTE * const base = ip;\r\n#else\r\nconst int base = 0;\r\n#endif\r\nconst u8 *anchor = ip;\r\nconst u8 *const iend = ip + isize;\r\nconst u8 *const mflimit = iend - MFLIMIT;\r\n#define MATCHLIMIT (iend - LASTLITERALS)\r\nu8 *op = (u8 *) dest;\r\nu8 *const oend = op + maxoutputsize;\r\nint length;\r\nconst int skipstrength = SKIPSTRENGTH;\r\nu32 forwardh;\r\nint lastrun;\r\nif (isize < MINLENGTH)\r\ngoto _last_literals;\r\nmemset((void *)hashtable, 0, LZ4_MEM_COMPRESS);\r\nhashtable[LZ4_HASH_VALUE(ip)] = ip - base;\r\nip++;\r\nforwardh = LZ4_HASH_VALUE(ip);\r\nfor (;;) {\r\nint findmatchattempts = (1U << skipstrength) + 3;\r\nconst u8 *forwardip = ip;\r\nconst u8 *ref;\r\nu8 *token;\r\ndo {\r\nu32 h = forwardh;\r\nint step = findmatchattempts++ >> skipstrength;\r\nip = forwardip;\r\nforwardip = ip + step;\r\nif (unlikely(forwardip > mflimit))\r\ngoto _last_literals;\r\nforwardh = LZ4_HASH_VALUE(forwardip);\r\nref = base + hashtable[h];\r\nhashtable[h] = ip - base;\r\n} while ((ref < ip - MAX_DISTANCE) || (A32(ref) != A32(ip)));\r\nwhile ((ip > anchor) && (ref > (u8 *)source) &&\r\nunlikely(ip[-1] == ref[-1])) {\r\nip--;\r\nref--;\r\n}\r\nlength = (int)(ip - anchor);\r\ntoken = op++;\r\nif (unlikely(op + length + (2 + 1 + LASTLITERALS) +\r\n(length >> 8) > oend))\r\nreturn 0;\r\nif (length >= (int)RUN_MASK) {\r\nint len;\r\n*token = (RUN_MASK << ML_BITS);\r\nlen = length - RUN_MASK;\r\nfor (; len > 254 ; len -= 255)\r\n*op++ = 255;\r\n*op++ = (u8)len;\r\n} else\r\n*token = (length << ML_BITS);\r\nLZ4_BLINDCOPY(anchor, op, length);\r\n_next_match:\r\nLZ4_WRITE_LITTLEENDIAN_16(op, (u16)(ip - ref));\r\nip += MINMATCH;\r\nref += MINMATCH;\r\nanchor = ip;\r\nwhile (likely(ip < MATCHLIMIT - (STEPSIZE - 1))) {\r\n#if LZ4_ARCH64\r\nu64 diff = A64(ref) ^ A64(ip);\r\n#else\r\nu32 diff = A32(ref) ^ A32(ip);\r\n#endif\r\nif (!diff) {\r\nip += STEPSIZE;\r\nref += STEPSIZE;\r\ncontinue;\r\n}\r\nip += LZ4_NBCOMMONBYTES(diff);\r\ngoto _endcount;\r\n}\r\n#if LZ4_ARCH64\r\nif ((ip < (MATCHLIMIT - 3)) && (A32(ref) == A32(ip))) {\r\nip += 4;\r\nref += 4;\r\n}\r\n#endif\r\nif ((ip < (MATCHLIMIT - 1)) && (A16(ref) == A16(ip))) {\r\nip += 2;\r\nref += 2;\r\n}\r\nif ((ip < MATCHLIMIT) && (*ref == *ip))\r\nip++;\r\n_endcount:\r\nlength = (int)(ip - anchor);\r\nif (unlikely(op + (1 + LASTLITERALS) + (length >> 8) > oend))\r\nreturn 0;\r\nif (length >= (int)ML_MASK) {\r\n*token += ML_MASK;\r\nlength -= ML_MASK;\r\nfor (; length > 509 ; length -= 510) {\r\n*op++ = 255;\r\n*op++ = 255;\r\n}\r\nif (length > 254) {\r\nlength -= 255;\r\n*op++ = 255;\r\n}\r\n*op++ = (u8)length;\r\n} else\r\n*token += length;\r\nif (ip > mflimit) {\r\nanchor = ip;\r\nbreak;\r\n}\r\nhashtable[LZ4_HASH_VALUE(ip-2)] = ip - 2 - base;\r\nref = base + hashtable[LZ4_HASH_VALUE(ip)];\r\nhashtable[LZ4_HASH_VALUE(ip)] = ip - base;\r\nif ((ref > ip - (MAX_DISTANCE + 1)) && (A32(ref) == A32(ip))) {\r\ntoken = op++;\r\n*token = 0;\r\ngoto _next_match;\r\n}\r\nanchor = ip++;\r\nforwardh = LZ4_HASH_VALUE(ip);\r\n}\r\n_last_literals:\r\nlastrun = (int)(iend - anchor);\r\nif (((char *)op - dest) + lastrun + 1\r\n+ ((lastrun + 255 - RUN_MASK) / 255) > (u32)maxoutputsize)\r\nreturn 0;\r\nif (lastrun >= (int)RUN_MASK) {\r\n*op++ = (RUN_MASK << ML_BITS);\r\nlastrun -= RUN_MASK;\r\nfor (; lastrun > 254 ; lastrun -= 255)\r\n*op++ = 255;\r\n*op++ = (u8)lastrun;\r\n} else\r\n*op++ = (lastrun << ML_BITS);\r\nmemcpy(op, anchor, iend - anchor);\r\nop += iend - anchor;\r\nreturn (int)(((char *)op) - dest);\r\n}\r\nstatic inline int lz4_compress64kctx(void *ctx,\r\nconst char *source,\r\nchar *dest,\r\nint isize,\r\nint maxoutputsize)\r\n{\r\nu16 *hashtable = (u16 *)ctx;\r\nconst u8 *ip = (u8 *) source;\r\nconst u8 *anchor = ip;\r\nconst u8 *const base = ip;\r\nconst u8 *const iend = ip + isize;\r\nconst u8 *const mflimit = iend - MFLIMIT;\r\n#define MATCHLIMIT (iend - LASTLITERALS)\r\nu8 *op = (u8 *) dest;\r\nu8 *const oend = op + maxoutputsize;\r\nint len, length;\r\nconst int skipstrength = SKIPSTRENGTH;\r\nu32 forwardh;\r\nint lastrun;\r\nif (isize < MINLENGTH)\r\ngoto _last_literals;\r\nmemset((void *)hashtable, 0, LZ4_MEM_COMPRESS);\r\nip++;\r\nforwardh = LZ4_HASH64K_VALUE(ip);\r\nfor (;;) {\r\nint findmatchattempts = (1U << skipstrength) + 3;\r\nconst u8 *forwardip = ip;\r\nconst u8 *ref;\r\nu8 *token;\r\ndo {\r\nu32 h = forwardh;\r\nint step = findmatchattempts++ >> skipstrength;\r\nip = forwardip;\r\nforwardip = ip + step;\r\nif (forwardip > mflimit)\r\ngoto _last_literals;\r\nforwardh = LZ4_HASH64K_VALUE(forwardip);\r\nref = base + hashtable[h];\r\nhashtable[h] = (u16)(ip - base);\r\n} while (A32(ref) != A32(ip));\r\nwhile ((ip > anchor) && (ref > (u8 *)source)\r\n&& (ip[-1] == ref[-1])) {\r\nip--;\r\nref--;\r\n}\r\nlength = (int)(ip - anchor);\r\ntoken = op++;\r\nif (unlikely(op + length + (2 + 1 + LASTLITERALS)\r\n+ (length >> 8) > oend))\r\nreturn 0;\r\nif (length >= (int)RUN_MASK) {\r\n*token = (RUN_MASK << ML_BITS);\r\nlen = length - RUN_MASK;\r\nfor (; len > 254 ; len -= 255)\r\n*op++ = 255;\r\n*op++ = (u8)len;\r\n} else\r\n*token = (length << ML_BITS);\r\nLZ4_BLINDCOPY(anchor, op, length);\r\n_next_match:\r\nLZ4_WRITE_LITTLEENDIAN_16(op, (u16)(ip - ref));\r\nip += MINMATCH;\r\nref += MINMATCH;\r\nanchor = ip;\r\nwhile (ip < MATCHLIMIT - (STEPSIZE - 1)) {\r\n#if LZ4_ARCH64\r\nu64 diff = A64(ref) ^ A64(ip);\r\n#else\r\nu32 diff = A32(ref) ^ A32(ip);\r\n#endif\r\nif (!diff) {\r\nip += STEPSIZE;\r\nref += STEPSIZE;\r\ncontinue;\r\n}\r\nip += LZ4_NBCOMMONBYTES(diff);\r\ngoto _endcount;\r\n}\r\n#if LZ4_ARCH64\r\nif ((ip < (MATCHLIMIT - 3)) && (A32(ref) == A32(ip))) {\r\nip += 4;\r\nref += 4;\r\n}\r\n#endif\r\nif ((ip < (MATCHLIMIT - 1)) && (A16(ref) == A16(ip))) {\r\nip += 2;\r\nref += 2;\r\n}\r\nif ((ip < MATCHLIMIT) && (*ref == *ip))\r\nip++;\r\n_endcount:\r\nlen = (int)(ip - anchor);\r\nif (unlikely(op + (1 + LASTLITERALS) + (len >> 8) > oend))\r\nreturn 0;\r\nif (len >= (int)ML_MASK) {\r\n*token += ML_MASK;\r\nlen -= ML_MASK;\r\nfor (; len > 509 ; len -= 510) {\r\n*op++ = 255;\r\n*op++ = 255;\r\n}\r\nif (len > 254) {\r\nlen -= 255;\r\n*op++ = 255;\r\n}\r\n*op++ = (u8)len;\r\n} else\r\n*token += len;\r\nif (ip > mflimit) {\r\nanchor = ip;\r\nbreak;\r\n}\r\nhashtable[LZ4_HASH64K_VALUE(ip-2)] = (u16)(ip - 2 - base);\r\nref = base + hashtable[LZ4_HASH64K_VALUE(ip)];\r\nhashtable[LZ4_HASH64K_VALUE(ip)] = (u16)(ip - base);\r\nif (A32(ref) == A32(ip)) {\r\ntoken = op++;\r\n*token = 0;\r\ngoto _next_match;\r\n}\r\nanchor = ip++;\r\nforwardh = LZ4_HASH64K_VALUE(ip);\r\n}\r\n_last_literals:\r\nlastrun = (int)(iend - anchor);\r\nif (op + lastrun + 1 + (lastrun - RUN_MASK + 255) / 255 > oend)\r\nreturn 0;\r\nif (lastrun >= (int)RUN_MASK) {\r\n*op++ = (RUN_MASK << ML_BITS);\r\nlastrun -= RUN_MASK;\r\nfor (; lastrun > 254 ; lastrun -= 255)\r\n*op++ = 255;\r\n*op++ = (u8)lastrun;\r\n} else\r\n*op++ = (lastrun << ML_BITS);\r\nmemcpy(op, anchor, iend - anchor);\r\nop += iend - anchor;\r\nreturn (int)(((char *)op) - dest);\r\n}\r\nint lz4_compress(const unsigned char *src, size_t src_len,\r\nunsigned char *dst, size_t *dst_len, void *wrkmem)\r\n{\r\nint ret = -1;\r\nint out_len = 0;\r\nif (src_len < LZ4_64KLIMIT)\r\nout_len = lz4_compress64kctx(wrkmem, src, dst, src_len,\r\nlz4_compressbound(src_len));\r\nelse\r\nout_len = lz4_compressctx(wrkmem, src, dst, src_len,\r\nlz4_compressbound(src_len));\r\nif (out_len < 0)\r\ngoto exit;\r\n*dst_len = out_len;\r\nreturn 0;\r\nexit:\r\nreturn ret;\r\n}
