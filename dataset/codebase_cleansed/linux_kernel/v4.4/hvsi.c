static inline int is_console(struct hvsi_struct *hp)\r\n{\r\nreturn hp->flags & HVSI_CONSOLE;\r\n}\r\nstatic inline int is_open(struct hvsi_struct *hp)\r\n{\r\nreturn (hp->state == HVSI_OPEN)\r\n|| (hp->state == HVSI_WAIT_FOR_MCTRL_RESPONSE);\r\n}\r\nstatic inline void print_state(struct hvsi_struct *hp)\r\n{\r\n#ifdef DEBUG\r\nstatic const char *state_names[] = {\r\n"HVSI_CLOSED",\r\n"HVSI_WAIT_FOR_VER_RESPONSE",\r\n"HVSI_WAIT_FOR_VER_QUERY",\r\n"HVSI_OPEN",\r\n"HVSI_WAIT_FOR_MCTRL_RESPONSE",\r\n"HVSI_FSP_DIED",\r\n};\r\nconst char *name = (hp->state < ARRAY_SIZE(state_names))\r\n? state_names[hp->state] : "UNKNOWN";\r\npr_debug("hvsi%i: state = %s\n", hp->index, name);\r\n#endif\r\n}\r\nstatic inline void __set_state(struct hvsi_struct *hp, int state)\r\n{\r\nhp->state = state;\r\nprint_state(hp);\r\nwake_up_all(&hp->stateq);\r\n}\r\nstatic inline void set_state(struct hvsi_struct *hp, int state)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&hp->lock, flags);\r\n__set_state(hp, state);\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\n}\r\nstatic inline int len_packet(const uint8_t *packet)\r\n{\r\nreturn (int)((struct hvsi_header *)packet)->len;\r\n}\r\nstatic inline int is_header(const uint8_t *packet)\r\n{\r\nstruct hvsi_header *header = (struct hvsi_header *)packet;\r\nreturn header->type >= VS_QUERY_RESPONSE_PACKET_HEADER;\r\n}\r\nstatic inline int got_packet(const struct hvsi_struct *hp, uint8_t *packet)\r\n{\r\nif (hp->inbuf_end < packet + sizeof(struct hvsi_header))\r\nreturn 0;\r\nif (hp->inbuf_end < (packet + len_packet(packet)))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void compact_inbuf(struct hvsi_struct *hp, uint8_t *read_to)\r\n{\r\nint remaining = (int)(hp->inbuf_end - read_to);\r\npr_debug("%s: %i chars remain\n", __func__, remaining);\r\nif (read_to != hp->inbuf)\r\nmemmove(hp->inbuf, read_to, remaining);\r\nhp->inbuf_end = hp->inbuf + remaining;\r\n}\r\nstatic void dump_hex(const uint8_t *data, int len)\r\n{\r\nint i;\r\nprintk(" ");\r\nfor (i=0; i < len; i++)\r\nprintk("%.2x", data[i]);\r\nprintk("\n ");\r\nfor (i=0; i < len; i++) {\r\nif (isprint(data[i]))\r\nprintk("%c", data[i]);\r\nelse\r\nprintk(".");\r\n}\r\nprintk("\n");\r\n}\r\nstatic void dump_packet(uint8_t *packet)\r\n{\r\nstruct hvsi_header *header = (struct hvsi_header *)packet;\r\nprintk("type 0x%x, len %i, seqno %i:\n", header->type, header->len,\r\nheader->seqno);\r\ndump_hex(packet, header->len);\r\n}\r\nstatic int hvsi_read(struct hvsi_struct *hp, char *buf, int count)\r\n{\r\nunsigned long got;\r\ngot = hvc_get_chars(hp->vtermno, buf, count);\r\nreturn got;\r\n}\r\nstatic void hvsi_recv_control(struct hvsi_struct *hp, uint8_t *packet,\r\nstruct tty_struct *tty, struct hvsi_struct **to_handshake)\r\n{\r\nstruct hvsi_control *header = (struct hvsi_control *)packet;\r\nswitch (be16_to_cpu(header->verb)) {\r\ncase VSV_MODEM_CTL_UPDATE:\r\nif ((be32_to_cpu(header->word) & HVSI_TSCD) == 0) {\r\npr_debug("hvsi%i: CD dropped\n", hp->index);\r\nhp->mctrl &= TIOCM_CD;\r\nif (tty && !C_CLOCAL(tty))\r\ntty_hangup(tty);\r\n}\r\nbreak;\r\ncase VSV_CLOSE_PROTOCOL:\r\npr_debug("hvsi%i: service processor came back\n", hp->index);\r\nif (hp->state != HVSI_CLOSED) {\r\n*to_handshake = hp;\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "hvsi%i: unknown HVSI control packet: ",\r\nhp->index);\r\ndump_packet(packet);\r\nbreak;\r\n}\r\n}\r\nstatic void hvsi_recv_response(struct hvsi_struct *hp, uint8_t *packet)\r\n{\r\nstruct hvsi_query_response *resp = (struct hvsi_query_response *)packet;\r\nuint32_t mctrl_word;\r\nswitch (hp->state) {\r\ncase HVSI_WAIT_FOR_VER_RESPONSE:\r\n__set_state(hp, HVSI_WAIT_FOR_VER_QUERY);\r\nbreak;\r\ncase HVSI_WAIT_FOR_MCTRL_RESPONSE:\r\nhp->mctrl = 0;\r\nmctrl_word = be32_to_cpu(resp->u.mctrl_word);\r\nif (mctrl_word & HVSI_TSDTR)\r\nhp->mctrl |= TIOCM_DTR;\r\nif (mctrl_word & HVSI_TSCD)\r\nhp->mctrl |= TIOCM_CD;\r\n__set_state(hp, HVSI_OPEN);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "hvsi%i: unexpected query response: ", hp->index);\r\ndump_packet(packet);\r\nbreak;\r\n}\r\n}\r\nstatic int hvsi_version_respond(struct hvsi_struct *hp, uint16_t query_seqno)\r\n{\r\nstruct hvsi_query_response packet __ALIGNED__;\r\nint wrote;\r\npacket.hdr.type = VS_QUERY_RESPONSE_PACKET_HEADER;\r\npacket.hdr.len = sizeof(struct hvsi_query_response);\r\npacket.hdr.seqno = cpu_to_be16(atomic_inc_return(&hp->seqno));\r\npacket.verb = cpu_to_be16(VSV_SEND_VERSION_NUMBER);\r\npacket.u.version = HVSI_VERSION;\r\npacket.query_seqno = cpu_to_be16(query_seqno+1);\r\npr_debug("%s: sending %i bytes\n", __func__, packet.hdr.len);\r\ndbg_dump_hex((uint8_t*)&packet, packet.hdr.len);\r\nwrote = hvc_put_chars(hp->vtermno, (char *)&packet, packet.hdr.len);\r\nif (wrote != packet.hdr.len) {\r\nprintk(KERN_ERR "hvsi%i: couldn't send query response!\n",\r\nhp->index);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hvsi_recv_query(struct hvsi_struct *hp, uint8_t *packet)\r\n{\r\nstruct hvsi_query *query = (struct hvsi_query *)packet;\r\nswitch (hp->state) {\r\ncase HVSI_WAIT_FOR_VER_QUERY:\r\nhvsi_version_respond(hp, be16_to_cpu(query->hdr.seqno));\r\n__set_state(hp, HVSI_OPEN);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "hvsi%i: unexpected query: ", hp->index);\r\ndump_packet(packet);\r\nbreak;\r\n}\r\n}\r\nstatic void hvsi_insert_chars(struct hvsi_struct *hp, const char *buf, int len)\r\n{\r\nint i;\r\nfor (i=0; i < len; i++) {\r\nchar c = buf[i];\r\n#ifdef CONFIG_MAGIC_SYSRQ\r\nif (c == '\0') {\r\nhp->sysrq = 1;\r\ncontinue;\r\n} else if (hp->sysrq) {\r\nhandle_sysrq(c);\r\nhp->sysrq = 0;\r\ncontinue;\r\n}\r\n#endif\r\ntty_insert_flip_char(&hp->port, c, 0);\r\n}\r\n}\r\nstatic bool hvsi_recv_data(struct hvsi_struct *hp, const uint8_t *packet)\r\n{\r\nconst struct hvsi_header *header = (const struct hvsi_header *)packet;\r\nconst uint8_t *data = packet + sizeof(struct hvsi_header);\r\nint datalen = header->len - sizeof(struct hvsi_header);\r\nint overflow = datalen - TTY_THRESHOLD_THROTTLE;\r\npr_debug("queueing %i chars '%.*s'\n", datalen, datalen, data);\r\nif (datalen == 0)\r\nreturn false;\r\nif (overflow > 0) {\r\npr_debug("%s: got >TTY_THRESHOLD_THROTTLE bytes\n", __func__);\r\ndatalen = TTY_THRESHOLD_THROTTLE;\r\n}\r\nhvsi_insert_chars(hp, data, datalen);\r\nif (overflow > 0) {\r\npr_debug("%s: deferring overflow\n", __func__);\r\nmemcpy(hp->throttle_buf, data + TTY_THRESHOLD_THROTTLE, overflow);\r\nhp->n_throttle = overflow;\r\n}\r\nreturn true;\r\n}\r\nstatic int hvsi_load_chunk(struct hvsi_struct *hp, struct tty_struct *tty,\r\nstruct hvsi_struct **handshake)\r\n{\r\nuint8_t *packet = hp->inbuf;\r\nint chunklen;\r\nbool flip = false;\r\n*handshake = NULL;\r\nchunklen = hvsi_read(hp, hp->inbuf_end, HVSI_MAX_READ);\r\nif (chunklen == 0) {\r\npr_debug("%s: 0-length read\n", __func__);\r\nreturn 0;\r\n}\r\npr_debug("%s: got %i bytes\n", __func__, chunklen);\r\ndbg_dump_hex(hp->inbuf_end, chunklen);\r\nhp->inbuf_end += chunklen;\r\nwhile ((packet < hp->inbuf_end) && got_packet(hp, packet)) {\r\nstruct hvsi_header *header = (struct hvsi_header *)packet;\r\nif (!is_header(packet)) {\r\nprintk(KERN_ERR "hvsi%i: got malformed packet\n", hp->index);\r\nwhile ((packet < hp->inbuf_end) && (!is_header(packet)))\r\npacket++;\r\ncontinue;\r\n}\r\npr_debug("%s: handling %i-byte packet\n", __func__,\r\nlen_packet(packet));\r\ndbg_dump_packet(packet);\r\nswitch (header->type) {\r\ncase VS_DATA_PACKET_HEADER:\r\nif (!is_open(hp))\r\nbreak;\r\nflip = hvsi_recv_data(hp, packet);\r\nbreak;\r\ncase VS_CONTROL_PACKET_HEADER:\r\nhvsi_recv_control(hp, packet, tty, handshake);\r\nbreak;\r\ncase VS_QUERY_RESPONSE_PACKET_HEADER:\r\nhvsi_recv_response(hp, packet);\r\nbreak;\r\ncase VS_QUERY_PACKET_HEADER:\r\nhvsi_recv_query(hp, packet);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "hvsi%i: unknown HVSI packet type 0x%x\n",\r\nhp->index, header->type);\r\ndump_packet(packet);\r\nbreak;\r\n}\r\npacket += len_packet(packet);\r\nif (*handshake) {\r\npr_debug("%s: handshake\n", __func__);\r\nbreak;\r\n}\r\n}\r\ncompact_inbuf(hp, packet);\r\nif (flip)\r\ntty_flip_buffer_push(&hp->port);\r\nreturn 1;\r\n}\r\nstatic void hvsi_send_overflow(struct hvsi_struct *hp)\r\n{\r\npr_debug("%s: delivering %i bytes overflow\n", __func__,\r\nhp->n_throttle);\r\nhvsi_insert_chars(hp, hp->throttle_buf, hp->n_throttle);\r\nhp->n_throttle = 0;\r\n}\r\nstatic irqreturn_t hvsi_interrupt(int irq, void *arg)\r\n{\r\nstruct hvsi_struct *hp = (struct hvsi_struct *)arg;\r\nstruct hvsi_struct *handshake;\r\nstruct tty_struct *tty;\r\nunsigned long flags;\r\nint again = 1;\r\npr_debug("%s\n", __func__);\r\ntty = tty_port_tty_get(&hp->port);\r\nwhile (again) {\r\nspin_lock_irqsave(&hp->lock, flags);\r\nagain = hvsi_load_chunk(hp, tty, &handshake);\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\nif (handshake) {\r\npr_debug("hvsi%i: attempting re-handshake\n", handshake->index);\r\nschedule_work(&handshake->handshaker);\r\n}\r\n}\r\nspin_lock_irqsave(&hp->lock, flags);\r\nif (tty && hp->n_throttle && !test_bit(TTY_THROTTLED, &tty->flags)) {\r\nhvsi_send_overflow(hp);\r\ntty_flip_buffer_push(&hp->port);\r\n}\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\ntty_kref_put(tty);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init poll_for_state(struct hvsi_struct *hp, int state)\r\n{\r\nunsigned long end_jiffies = jiffies + HVSI_TIMEOUT;\r\nfor (;;) {\r\nhvsi_interrupt(hp->virq, (void *)hp);\r\nif (hp->state == state)\r\nreturn 0;\r\nmdelay(5);\r\nif (time_after(jiffies, end_jiffies))\r\nreturn -EIO;\r\n}\r\n}\r\nstatic int wait_for_state(struct hvsi_struct *hp, int state)\r\n{\r\nint ret = 0;\r\nif (!wait_event_timeout(hp->stateq, (hp->state == state), HVSI_TIMEOUT))\r\nret = -EIO;\r\nreturn ret;\r\n}\r\nstatic int hvsi_query(struct hvsi_struct *hp, uint16_t verb)\r\n{\r\nstruct hvsi_query packet __ALIGNED__;\r\nint wrote;\r\npacket.hdr.type = VS_QUERY_PACKET_HEADER;\r\npacket.hdr.len = sizeof(struct hvsi_query);\r\npacket.hdr.seqno = cpu_to_be16(atomic_inc_return(&hp->seqno));\r\npacket.verb = cpu_to_be16(verb);\r\npr_debug("%s: sending %i bytes\n", __func__, packet.hdr.len);\r\ndbg_dump_hex((uint8_t*)&packet, packet.hdr.len);\r\nwrote = hvc_put_chars(hp->vtermno, (char *)&packet, packet.hdr.len);\r\nif (wrote != packet.hdr.len) {\r\nprintk(KERN_ERR "hvsi%i: couldn't send query (%i)!\n", hp->index,\r\nwrote);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hvsi_get_mctrl(struct hvsi_struct *hp)\r\n{\r\nint ret;\r\nset_state(hp, HVSI_WAIT_FOR_MCTRL_RESPONSE);\r\nhvsi_query(hp, VSV_SEND_MODEM_CTL_STATUS);\r\nret = hvsi_wait(hp, HVSI_OPEN);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "hvsi%i: didn't get modem flags\n", hp->index);\r\nset_state(hp, HVSI_OPEN);\r\nreturn ret;\r\n}\r\npr_debug("%s: mctrl 0x%x\n", __func__, hp->mctrl);\r\nreturn 0;\r\n}\r\nstatic int hvsi_set_mctrl(struct hvsi_struct *hp, uint16_t mctrl)\r\n{\r\nstruct hvsi_control packet __ALIGNED__;\r\nint wrote;\r\npacket.hdr.type = VS_CONTROL_PACKET_HEADER;\r\npacket.hdr.seqno = cpu_to_be16(atomic_inc_return(&hp->seqno));\r\npacket.hdr.len = sizeof(struct hvsi_control);\r\npacket.verb = cpu_to_be16(VSV_SET_MODEM_CTL);\r\npacket.mask = cpu_to_be32(HVSI_TSDTR);\r\nif (mctrl & TIOCM_DTR)\r\npacket.word = cpu_to_be32(HVSI_TSDTR);\r\npr_debug("%s: sending %i bytes\n", __func__, packet.hdr.len);\r\ndbg_dump_hex((uint8_t*)&packet, packet.hdr.len);\r\nwrote = hvc_put_chars(hp->vtermno, (char *)&packet, packet.hdr.len);\r\nif (wrote != packet.hdr.len) {\r\nprintk(KERN_ERR "hvsi%i: couldn't set DTR!\n", hp->index);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hvsi_drain_input(struct hvsi_struct *hp)\r\n{\r\nuint8_t buf[HVSI_MAX_READ] __ALIGNED__;\r\nunsigned long end_jiffies = jiffies + HVSI_TIMEOUT;\r\nwhile (time_before(end_jiffies, jiffies))\r\nif (0 == hvsi_read(hp, buf, HVSI_MAX_READ))\r\nbreak;\r\n}\r\nstatic int hvsi_handshake(struct hvsi_struct *hp)\r\n{\r\nint ret;\r\nhvsi_drain_input(hp);\r\nset_state(hp, HVSI_WAIT_FOR_VER_RESPONSE);\r\nret = hvsi_query(hp, VSV_SEND_VERSION_NUMBER);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "hvsi%i: couldn't send version query\n", hp->index);\r\nreturn ret;\r\n}\r\nret = hvsi_wait(hp, HVSI_OPEN);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void hvsi_handshaker(struct work_struct *work)\r\n{\r\nstruct hvsi_struct *hp =\r\ncontainer_of(work, struct hvsi_struct, handshaker);\r\nif (hvsi_handshake(hp) >= 0)\r\nreturn;\r\nprintk(KERN_ERR "hvsi%i: re-handshaking failed\n", hp->index);\r\nif (is_console(hp)) {\r\nprintk(KERN_ERR "hvsi%i: lost console!\n", hp->index);\r\n}\r\n}\r\nstatic int hvsi_put_chars(struct hvsi_struct *hp, const char *buf, int count)\r\n{\r\nstruct hvsi_data packet __ALIGNED__;\r\nint ret;\r\nBUG_ON(count > HVSI_MAX_OUTGOING_DATA);\r\npacket.hdr.type = VS_DATA_PACKET_HEADER;\r\npacket.hdr.seqno = cpu_to_be16(atomic_inc_return(&hp->seqno));\r\npacket.hdr.len = count + sizeof(struct hvsi_header);\r\nmemcpy(&packet.data, buf, count);\r\nret = hvc_put_chars(hp->vtermno, (char *)&packet, packet.hdr.len);\r\nif (ret == packet.hdr.len) {\r\nreturn count;\r\n}\r\nreturn ret;\r\n}\r\nstatic void hvsi_close_protocol(struct hvsi_struct *hp)\r\n{\r\nstruct hvsi_control packet __ALIGNED__;\r\npacket.hdr.type = VS_CONTROL_PACKET_HEADER;\r\npacket.hdr.seqno = cpu_to_be16(atomic_inc_return(&hp->seqno));\r\npacket.hdr.len = 6;\r\npacket.verb = cpu_to_be16(VSV_CLOSE_PROTOCOL);\r\npr_debug("%s: sending %i bytes\n", __func__, packet.hdr.len);\r\ndbg_dump_hex((uint8_t*)&packet, packet.hdr.len);\r\nhvc_put_chars(hp->vtermno, (char *)&packet, packet.hdr.len);\r\n}\r\nstatic int hvsi_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct hvsi_struct *hp;\r\nunsigned long flags;\r\nint ret;\r\npr_debug("%s\n", __func__);\r\nhp = &hvsi_ports[tty->index];\r\ntty->driver_data = hp;\r\nmb();\r\nif (hp->state == HVSI_FSP_DIED)\r\nreturn -EIO;\r\ntty_port_tty_set(&hp->port, tty);\r\nspin_lock_irqsave(&hp->lock, flags);\r\nhp->port.count++;\r\natomic_set(&hp->seqno, 0);\r\nh_vio_signal(hp->vtermno, VIO_IRQ_ENABLE);\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\nif (is_console(hp))\r\nreturn 0;\r\nret = hvsi_handshake(hp);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: HVSI handshaking failed\n", tty->name);\r\nreturn ret;\r\n}\r\nret = hvsi_get_mctrl(hp);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: couldn't get initial modem flags\n", tty->name);\r\nreturn ret;\r\n}\r\nret = hvsi_set_mctrl(hp, hp->mctrl | TIOCM_DTR);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: couldn't set DTR\n", tty->name);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hvsi_flush_output(struct hvsi_struct *hp)\r\n{\r\nwait_event_timeout(hp->emptyq, (hp->n_outbuf <= 0), HVSI_TIMEOUT);\r\ncancel_delayed_work_sync(&hp->writer);\r\nflush_work(&hp->handshaker);\r\nhp->n_outbuf = 0;\r\n}\r\nstatic void hvsi_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct hvsi_struct *hp = tty->driver_data;\r\nunsigned long flags;\r\npr_debug("%s\n", __func__);\r\nif (tty_hung_up_p(filp))\r\nreturn;\r\nspin_lock_irqsave(&hp->lock, flags);\r\nif (--hp->port.count == 0) {\r\ntty_port_tty_set(&hp->port, NULL);\r\nhp->inbuf_end = hp->inbuf;\r\nif (!is_console(hp)) {\r\nh_vio_signal(hp->vtermno, VIO_IRQ_DISABLE);\r\n__set_state(hp, HVSI_CLOSED);\r\ntty->closing = 1;\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\nsynchronize_irq(hp->virq);\r\nhvsi_flush_output(hp);\r\nhvsi_close_protocol(hp);\r\nhvsi_drain_input(hp);\r\nspin_lock_irqsave(&hp->lock, flags);\r\n}\r\n} else if (hp->port.count < 0)\r\nprintk(KERN_ERR "hvsi_close %lu: oops, count is %d\n",\r\nhp - hvsi_ports, hp->port.count);\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\n}\r\nstatic void hvsi_hangup(struct tty_struct *tty)\r\n{\r\nstruct hvsi_struct *hp = tty->driver_data;\r\nunsigned long flags;\r\npr_debug("%s\n", __func__);\r\ntty_port_tty_set(&hp->port, NULL);\r\nspin_lock_irqsave(&hp->lock, flags);\r\nhp->port.count = 0;\r\nhp->n_outbuf = 0;\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\n}\r\nstatic void hvsi_push(struct hvsi_struct *hp)\r\n{\r\nint n;\r\nif (hp->n_outbuf <= 0)\r\nreturn;\r\nn = hvsi_put_chars(hp, hp->outbuf, hp->n_outbuf);\r\nif (n > 0) {\r\npr_debug("%s: wrote %i chars\n", __func__, n);\r\nhp->n_outbuf = 0;\r\n} else if (n == -EIO) {\r\n__set_state(hp, HVSI_FSP_DIED);\r\nprintk(KERN_ERR "hvsi%i: service processor died\n", hp->index);\r\n}\r\n}\r\nstatic void hvsi_write_worker(struct work_struct *work)\r\n{\r\nstruct hvsi_struct *hp =\r\ncontainer_of(work, struct hvsi_struct, writer.work);\r\nunsigned long flags;\r\n#ifdef DEBUG\r\nstatic long start_j = 0;\r\nif (start_j == 0)\r\nstart_j = jiffies;\r\n#endif\r\nspin_lock_irqsave(&hp->lock, flags);\r\npr_debug("%s: %i chars in buffer\n", __func__, hp->n_outbuf);\r\nif (!is_open(hp)) {\r\nschedule_delayed_work(&hp->writer, HZ);\r\ngoto out;\r\n}\r\nhvsi_push(hp);\r\nif (hp->n_outbuf > 0)\r\nschedule_delayed_work(&hp->writer, 10);\r\nelse {\r\n#ifdef DEBUG\r\npr_debug("%s: outbuf emptied after %li jiffies\n", __func__,\r\njiffies - start_j);\r\nstart_j = 0;\r\n#endif\r\nwake_up_all(&hp->emptyq);\r\ntty_port_tty_wakeup(&hp->port);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\n}\r\nstatic int hvsi_write_room(struct tty_struct *tty)\r\n{\r\nstruct hvsi_struct *hp = tty->driver_data;\r\nreturn N_OUTBUF - hp->n_outbuf;\r\n}\r\nstatic int hvsi_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct hvsi_struct *hp = tty->driver_data;\r\nreturn hp->n_outbuf;\r\n}\r\nstatic int hvsi_write(struct tty_struct *tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct hvsi_struct *hp = tty->driver_data;\r\nconst char *source = buf;\r\nunsigned long flags;\r\nint total = 0;\r\nint origcount = count;\r\nspin_lock_irqsave(&hp->lock, flags);\r\npr_debug("%s: %i chars in buffer\n", __func__, hp->n_outbuf);\r\nif (!is_open(hp)) {\r\npr_debug("%s: not open\n", __func__);\r\ngoto out;\r\n}\r\nwhile ((count > 0) && (hvsi_write_room(tty) > 0)) {\r\nint chunksize = min(count, hvsi_write_room(tty));\r\nBUG_ON(hp->n_outbuf < 0);\r\nmemcpy(hp->outbuf + hp->n_outbuf, source, chunksize);\r\nhp->n_outbuf += chunksize;\r\ntotal += chunksize;\r\nsource += chunksize;\r\ncount -= chunksize;\r\nhvsi_push(hp);\r\n}\r\nif (hp->n_outbuf > 0) {\r\nschedule_delayed_work(&hp->writer, 10);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\nif (total != origcount)\r\npr_debug("%s: wanted %i, only wrote %i\n", __func__, origcount,\r\ntotal);\r\nreturn total;\r\n}\r\nstatic void hvsi_throttle(struct tty_struct *tty)\r\n{\r\nstruct hvsi_struct *hp = tty->driver_data;\r\npr_debug("%s\n", __func__);\r\nh_vio_signal(hp->vtermno, VIO_IRQ_DISABLE);\r\n}\r\nstatic void hvsi_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct hvsi_struct *hp = tty->driver_data;\r\nunsigned long flags;\r\npr_debug("%s\n", __func__);\r\nspin_lock_irqsave(&hp->lock, flags);\r\nif (hp->n_throttle) {\r\nhvsi_send_overflow(hp);\r\ntty_flip_buffer_push(&hp->port);\r\n}\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\nh_vio_signal(hp->vtermno, VIO_IRQ_ENABLE);\r\n}\r\nstatic int hvsi_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct hvsi_struct *hp = tty->driver_data;\r\nhvsi_get_mctrl(hp);\r\nreturn hp->mctrl;\r\n}\r\nstatic int hvsi_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct hvsi_struct *hp = tty->driver_data;\r\nunsigned long flags;\r\nuint16_t new_mctrl;\r\nclear &= TIOCM_DTR;\r\nset &= TIOCM_DTR;\r\nspin_lock_irqsave(&hp->lock, flags);\r\nnew_mctrl = (hp->mctrl & ~clear) | set;\r\nif (hp->mctrl != new_mctrl) {\r\nhvsi_set_mctrl(hp, new_mctrl);\r\nhp->mctrl = new_mctrl;\r\n}\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __init hvsi_init(void)\r\n{\r\nint i;\r\nhvsi_driver = alloc_tty_driver(hvsi_count);\r\nif (!hvsi_driver)\r\nreturn -ENOMEM;\r\nhvsi_driver->driver_name = "hvsi";\r\nhvsi_driver->name = "hvsi";\r\nhvsi_driver->major = HVSI_MAJOR;\r\nhvsi_driver->minor_start = HVSI_MINOR;\r\nhvsi_driver->type = TTY_DRIVER_TYPE_SYSTEM;\r\nhvsi_driver->init_termios = tty_std_termios;\r\nhvsi_driver->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL;\r\nhvsi_driver->init_termios.c_ispeed = 9600;\r\nhvsi_driver->init_termios.c_ospeed = 9600;\r\nhvsi_driver->flags = TTY_DRIVER_REAL_RAW;\r\ntty_set_operations(hvsi_driver, &hvsi_ops);\r\nfor (i=0; i < hvsi_count; i++) {\r\nstruct hvsi_struct *hp = &hvsi_ports[i];\r\nint ret = 1;\r\ntty_port_link_device(&hp->port, hvsi_driver, i);\r\nret = request_irq(hp->virq, hvsi_interrupt, 0, "hvsi", hp);\r\nif (ret)\r\nprintk(KERN_ERR "HVSI: couldn't reserve irq 0x%x (error %i)\n",\r\nhp->virq, ret);\r\n}\r\nhvsi_wait = wait_for_state;\r\nif (tty_register_driver(hvsi_driver))\r\npanic("Couldn't register hvsi console driver\n");\r\nprintk(KERN_DEBUG "HVSI: registered %i devices\n", hvsi_count);\r\nreturn 0;\r\n}\r\nstatic void hvsi_console_print(struct console *console, const char *buf,\r\nunsigned int count)\r\n{\r\nstruct hvsi_struct *hp = &hvsi_ports[console->index];\r\nchar c[HVSI_MAX_OUTGOING_DATA] __ALIGNED__;\r\nunsigned int i = 0, n = 0;\r\nint ret, donecr = 0;\r\nmb();\r\nif (!is_open(hp))\r\nreturn;\r\nwhile (count > 0 || i > 0) {\r\nif (count > 0 && i < sizeof(c)) {\r\nif (buf[n] == '\n' && !donecr) {\r\nc[i++] = '\r';\r\ndonecr = 1;\r\n} else {\r\nc[i++] = buf[n++];\r\ndonecr = 0;\r\n--count;\r\n}\r\n} else {\r\nret = hvsi_put_chars(hp, c, i);\r\nif (ret < 0)\r\ni = 0;\r\ni -= ret;\r\n}\r\n}\r\n}\r\nstatic struct tty_driver *hvsi_console_device(struct console *console,\r\nint *index)\r\n{\r\n*index = console->index;\r\nreturn hvsi_driver;\r\n}\r\nstatic int __init hvsi_console_setup(struct console *console, char *options)\r\n{\r\nstruct hvsi_struct *hp;\r\nint ret;\r\nif (console->index < 0 || console->index >= hvsi_count)\r\nreturn -1;\r\nhp = &hvsi_ports[console->index];\r\nhvsi_close_protocol(hp);\r\nret = hvsi_handshake(hp);\r\nif (ret < 0)\r\nreturn ret;\r\nret = hvsi_get_mctrl(hp);\r\nif (ret < 0)\r\nreturn ret;\r\nret = hvsi_set_mctrl(hp, hp->mctrl | TIOCM_DTR);\r\nif (ret < 0)\r\nreturn ret;\r\nhp->flags |= HVSI_CONSOLE;\r\nreturn 0;\r\n}\r\nstatic int __init hvsi_console_init(void)\r\n{\r\nstruct device_node *vty;\r\nhvsi_wait = poll_for_state;\r\nfor_each_compatible_node(vty, "serial", "hvterm-protocol") {\r\nstruct hvsi_struct *hp;\r\nconst __be32 *vtermno, *irq;\r\nvtermno = of_get_property(vty, "reg", NULL);\r\nirq = of_get_property(vty, "interrupts", NULL);\r\nif (!vtermno || !irq)\r\ncontinue;\r\nif (hvsi_count >= MAX_NR_HVSI_CONSOLES) {\r\nof_node_put(vty);\r\nbreak;\r\n}\r\nhp = &hvsi_ports[hvsi_count];\r\nINIT_DELAYED_WORK(&hp->writer, hvsi_write_worker);\r\nINIT_WORK(&hp->handshaker, hvsi_handshaker);\r\ninit_waitqueue_head(&hp->emptyq);\r\ninit_waitqueue_head(&hp->stateq);\r\nspin_lock_init(&hp->lock);\r\ntty_port_init(&hp->port);\r\nhp->index = hvsi_count;\r\nhp->inbuf_end = hp->inbuf;\r\nhp->state = HVSI_CLOSED;\r\nhp->vtermno = be32_to_cpup(vtermno);\r\nhp->virq = irq_create_mapping(NULL, be32_to_cpup(irq));\r\nif (hp->virq == 0) {\r\nprintk(KERN_ERR "%s: couldn't create irq mapping for 0x%x\n",\r\n__func__, be32_to_cpup(irq));\r\ntty_port_destroy(&hp->port);\r\ncontinue;\r\n}\r\nhvsi_count++;\r\n}\r\nif (hvsi_count)\r\nregister_console(&hvsi_console);\r\nreturn 0;\r\n}
