static irqreturn_t img_ir_isr(int irq, void *dev_id)\r\n{\r\nstruct img_ir_priv *priv = dev_id;\r\nu32 irq_status;\r\nspin_lock(&priv->lock);\r\nirq_status = img_ir_read(priv, IMG_IR_IRQ_STATUS);\r\nimg_ir_write(priv, IMG_IR_IRQ_CLEAR, irq_status);\r\nirq_status &= img_ir_read(priv, IMG_IR_IRQ_ENABLE);\r\nif (irq_status & IMG_IR_IRQ_EDGE && img_ir_raw_enabled(&priv->raw))\r\nimg_ir_isr_raw(priv, irq_status);\r\nif (irq_status & (IMG_IR_IRQ_DATA_MATCH |\r\nIMG_IR_IRQ_DATA_VALID |\r\nIMG_IR_IRQ_DATA2_VALID) &&\r\nimg_ir_hw_enabled(&priv->hw))\r\nimg_ir_isr_hw(priv, irq_status);\r\nspin_unlock(&priv->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void img_ir_setup(struct img_ir_priv *priv)\r\n{\r\nimg_ir_write(priv, IMG_IR_IRQ_ENABLE, 0);\r\nimg_ir_setup_raw(priv);\r\nimg_ir_setup_hw(priv);\r\nif (!IS_ERR(priv->clk))\r\nclk_prepare_enable(priv->clk);\r\n}\r\nstatic void img_ir_ident(struct img_ir_priv *priv)\r\n{\r\nu32 core_rev = img_ir_read(priv, IMG_IR_CORE_REV);\r\ndev_info(priv->dev,\r\n"IMG IR Decoder (%d.%d.%d.%d) probed successfully\n",\r\n(core_rev & IMG_IR_DESIGNER) >> IMG_IR_DESIGNER_SHIFT,\r\n(core_rev & IMG_IR_MAJOR_REV) >> IMG_IR_MAJOR_REV_SHIFT,\r\n(core_rev & IMG_IR_MINOR_REV) >> IMG_IR_MINOR_REV_SHIFT,\r\n(core_rev & IMG_IR_MAINT_REV) >> IMG_IR_MAINT_REV_SHIFT);\r\ndev_info(priv->dev, "Modes:%s%s\n",\r\nimg_ir_hw_enabled(&priv->hw) ? " hardware" : "",\r\nimg_ir_raw_enabled(&priv->raw) ? " raw" : "");\r\n}\r\nstatic int img_ir_probe(struct platform_device *pdev)\r\n{\r\nstruct img_ir_priv *priv;\r\nstruct resource *res_regs;\r\nint irq, error, error2;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "cannot find IRQ resource\n");\r\nreturn irq;\r\n}\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&pdev->dev, "cannot allocate device data\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\npriv->dev = &pdev->dev;\r\nspin_lock_init(&priv->lock);\r\nres_regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->reg_base = devm_ioremap_resource(&pdev->dev, res_regs);\r\nif (IS_ERR(priv->reg_base))\r\nreturn PTR_ERR(priv->reg_base);\r\npriv->clk = devm_clk_get(&pdev->dev, "core");\r\nif (IS_ERR(priv->clk))\r\ndev_warn(&pdev->dev, "cannot get core clock resource\n");\r\npriv->sys_clk = devm_clk_get(&pdev->dev, "sys");\r\nif (IS_ERR(priv->sys_clk))\r\ndev_warn(&pdev->dev, "cannot get sys clock resource\n");\r\nif (!IS_ERR(priv->sys_clk)) {\r\nerror = clk_prepare_enable(priv->sys_clk);\r\nif (error) {\r\ndev_err(&pdev->dev, "cannot enable sys clock\n");\r\nreturn error;\r\n}\r\n}\r\nerror = img_ir_probe_raw(priv);\r\nerror2 = img_ir_probe_hw(priv);\r\nif (error && error2) {\r\nif (error == -ENODEV)\r\nerror = error2;\r\ngoto err_probe;\r\n}\r\npriv->irq = irq;\r\nerror = request_irq(priv->irq, img_ir_isr, 0, "img-ir", priv);\r\nif (error) {\r\ndev_err(&pdev->dev, "cannot register IRQ %u\n",\r\npriv->irq);\r\nerror = -EIO;\r\ngoto err_irq;\r\n}\r\nimg_ir_ident(priv);\r\nimg_ir_setup(priv);\r\nreturn 0;\r\nerr_irq:\r\nimg_ir_remove_hw(priv);\r\nimg_ir_remove_raw(priv);\r\nerr_probe:\r\nif (!IS_ERR(priv->sys_clk))\r\nclk_disable_unprepare(priv->sys_clk);\r\nreturn error;\r\n}\r\nstatic int img_ir_remove(struct platform_device *pdev)\r\n{\r\nstruct img_ir_priv *priv = platform_get_drvdata(pdev);\r\nfree_irq(priv->irq, priv);\r\nimg_ir_remove_hw(priv);\r\nimg_ir_remove_raw(priv);\r\nif (!IS_ERR(priv->clk))\r\nclk_disable_unprepare(priv->clk);\r\nif (!IS_ERR(priv->sys_clk))\r\nclk_disable_unprepare(priv->sys_clk);\r\nreturn 0;\r\n}
