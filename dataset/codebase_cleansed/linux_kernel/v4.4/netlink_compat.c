static int tipc_skb_tailroom(struct sk_buff *skb)\r\n{\r\nint tailroom;\r\nint limit;\r\ntailroom = skb_tailroom(skb);\r\nlimit = TIPC_SKB_MAX - skb->len;\r\nif (tailroom < limit)\r\nreturn tailroom;\r\nreturn limit;\r\n}\r\nstatic int tipc_add_tlv(struct sk_buff *skb, u16 type, void *data, u16 len)\r\n{\r\nstruct tlv_desc *tlv = (struct tlv_desc *)skb_tail_pointer(skb);\r\nif (tipc_skb_tailroom(skb) < TLV_SPACE(len))\r\nreturn -EMSGSIZE;\r\nskb_put(skb, TLV_SPACE(len));\r\ntlv->tlv_type = htons(type);\r\ntlv->tlv_len = htons(TLV_LENGTH(len));\r\nif (len && data)\r\nmemcpy(TLV_DATA(tlv), data, len);\r\nreturn 0;\r\n}\r\nstatic void tipc_tlv_init(struct sk_buff *skb, u16 type)\r\n{\r\nstruct tlv_desc *tlv = (struct tlv_desc *)skb->data;\r\nTLV_SET_LEN(tlv, 0);\r\nTLV_SET_TYPE(tlv, type);\r\nskb_put(skb, sizeof(struct tlv_desc));\r\n}\r\nstatic int tipc_tlv_sprintf(struct sk_buff *skb, const char *fmt, ...)\r\n{\r\nint n;\r\nu16 len;\r\nu32 rem;\r\nchar *buf;\r\nstruct tlv_desc *tlv;\r\nva_list args;\r\nrem = tipc_skb_tailroom(skb);\r\ntlv = (struct tlv_desc *)skb->data;\r\nlen = TLV_GET_LEN(tlv);\r\nbuf = TLV_DATA(tlv) + len;\r\nva_start(args, fmt);\r\nn = vscnprintf(buf, rem, fmt, args);\r\nva_end(args);\r\nTLV_SET_LEN(tlv, n + len);\r\nskb_put(skb, n);\r\nreturn n;\r\n}\r\nstatic struct sk_buff *tipc_tlv_alloc(int size)\r\n{\r\nint hdr_len;\r\nstruct sk_buff *buf;\r\nsize = TLV_SPACE(size);\r\nhdr_len = nlmsg_total_size(GENL_HDRLEN + TIPC_GENL_HDRLEN);\r\nbuf = alloc_skb(hdr_len + size, GFP_KERNEL);\r\nif (!buf)\r\nreturn NULL;\r\nskb_reserve(buf, hdr_len);\r\nreturn buf;\r\n}\r\nstatic struct sk_buff *tipc_get_err_tlv(char *str)\r\n{\r\nint str_len = strlen(str) + 1;\r\nstruct sk_buff *buf;\r\nbuf = tipc_tlv_alloc(TLV_SPACE(str_len));\r\nif (buf)\r\ntipc_add_tlv(buf, TIPC_TLV_ERROR_STRING, str, str_len);\r\nreturn buf;\r\n}\r\nstatic int __tipc_nl_compat_dumpit(struct tipc_nl_compat_cmd_dump *cmd,\r\nstruct tipc_nl_compat_msg *msg,\r\nstruct sk_buff *arg)\r\n{\r\nint len = 0;\r\nint err;\r\nstruct sk_buff *buf;\r\nstruct nlmsghdr *nlmsg;\r\nstruct netlink_callback cb;\r\nmemset(&cb, 0, sizeof(cb));\r\ncb.nlh = (struct nlmsghdr *)arg->data;\r\ncb.skb = arg;\r\nbuf = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf->sk = msg->dst_sk;\r\ndo {\r\nint rem;\r\nlen = (*cmd->dumpit)(buf, &cb);\r\nnlmsg_for_each_msg(nlmsg, nlmsg_hdr(buf), len, rem) {\r\nstruct nlattr **attrs;\r\nerr = tipc_nlmsg_parse(nlmsg, &attrs);\r\nif (err)\r\ngoto err_out;\r\nerr = (*cmd->format)(msg, attrs);\r\nif (err)\r\ngoto err_out;\r\nif (tipc_skb_tailroom(msg->rep) <= 1) {\r\nerr = -EMSGSIZE;\r\ngoto err_out;\r\n}\r\n}\r\nskb_reset_tail_pointer(buf);\r\nbuf->len = 0;\r\n} while (len);\r\nerr = 0;\r\nerr_out:\r\nkfree_skb(buf);\r\nif (err == -EMSGSIZE) {\r\nif ((TIPC_SKB_MAX - msg->rep->len) <= 1) {\r\nchar *tail = skb_tail_pointer(msg->rep);\r\nif (*tail != '\0')\r\nsprintf(tail - sizeof(REPLY_TRUNCATED) - 1,\r\nREPLY_TRUNCATED);\r\n}\r\nreturn 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int tipc_nl_compat_dumpit(struct tipc_nl_compat_cmd_dump *cmd,\r\nstruct tipc_nl_compat_msg *msg)\r\n{\r\nint err;\r\nstruct sk_buff *arg;\r\nif (msg->req_type && !TLV_CHECK_TYPE(msg->req, msg->req_type))\r\nreturn -EINVAL;\r\nmsg->rep = tipc_tlv_alloc(msg->rep_size);\r\nif (!msg->rep)\r\nreturn -ENOMEM;\r\nif (msg->rep_type)\r\ntipc_tlv_init(msg->rep, msg->rep_type);\r\nif (cmd->header)\r\n(*cmd->header)(msg);\r\narg = nlmsg_new(0, GFP_KERNEL);\r\nif (!arg) {\r\nkfree_skb(msg->rep);\r\nreturn -ENOMEM;\r\n}\r\nerr = __tipc_nl_compat_dumpit(cmd, msg, arg);\r\nif (err)\r\nkfree_skb(msg->rep);\r\nkfree_skb(arg);\r\nreturn err;\r\n}\r\nstatic int __tipc_nl_compat_doit(struct tipc_nl_compat_cmd_doit *cmd,\r\nstruct tipc_nl_compat_msg *msg)\r\n{\r\nint err;\r\nstruct sk_buff *doit_buf;\r\nstruct sk_buff *trans_buf;\r\nstruct nlattr **attrbuf;\r\nstruct genl_info info;\r\ntrans_buf = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!trans_buf)\r\nreturn -ENOMEM;\r\nerr = (*cmd->transcode)(cmd, trans_buf, msg);\r\nif (err)\r\ngoto trans_out;\r\nattrbuf = kmalloc((tipc_genl_family.maxattr + 1) *\r\nsizeof(struct nlattr *), GFP_KERNEL);\r\nif (!attrbuf) {\r\nerr = -ENOMEM;\r\ngoto trans_out;\r\n}\r\nerr = nla_parse(attrbuf, tipc_genl_family.maxattr,\r\n(const struct nlattr *)trans_buf->data,\r\ntrans_buf->len, NULL);\r\nif (err)\r\ngoto parse_out;\r\ndoit_buf = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!doit_buf) {\r\nerr = -ENOMEM;\r\ngoto parse_out;\r\n}\r\ndoit_buf->sk = msg->dst_sk;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.attrs = attrbuf;\r\nerr = (*cmd->doit)(doit_buf, &info);\r\nkfree_skb(doit_buf);\r\nparse_out:\r\nkfree(attrbuf);\r\ntrans_out:\r\nkfree_skb(trans_buf);\r\nreturn err;\r\n}\r\nstatic int tipc_nl_compat_doit(struct tipc_nl_compat_cmd_doit *cmd,\r\nstruct tipc_nl_compat_msg *msg)\r\n{\r\nint err;\r\nif (msg->req_type && !TLV_CHECK_TYPE(msg->req, msg->req_type))\r\nreturn -EINVAL;\r\nerr = __tipc_nl_compat_doit(cmd, msg);\r\nif (err)\r\nreturn err;\r\nmsg->rep = tipc_tlv_alloc(0);\r\nif (!msg->rep)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int tipc_nl_compat_bearer_dump(struct tipc_nl_compat_msg *msg,\r\nstruct nlattr **attrs)\r\n{\r\nstruct nlattr *bearer[TIPC_NLA_BEARER_MAX + 1];\r\nnla_parse_nested(bearer, TIPC_NLA_BEARER_MAX, attrs[TIPC_NLA_BEARER],\r\nNULL);\r\nreturn tipc_add_tlv(msg->rep, TIPC_TLV_BEARER_NAME,\r\nnla_data(bearer[TIPC_NLA_BEARER_NAME]),\r\nnla_len(bearer[TIPC_NLA_BEARER_NAME]));\r\n}\r\nstatic int tipc_nl_compat_bearer_enable(struct tipc_nl_compat_cmd_doit *cmd,\r\nstruct sk_buff *skb,\r\nstruct tipc_nl_compat_msg *msg)\r\n{\r\nstruct nlattr *prop;\r\nstruct nlattr *bearer;\r\nstruct tipc_bearer_config *b;\r\nb = (struct tipc_bearer_config *)TLV_DATA(msg->req);\r\nbearer = nla_nest_start(skb, TIPC_NLA_BEARER);\r\nif (!bearer)\r\nreturn -EMSGSIZE;\r\nif (nla_put_string(skb, TIPC_NLA_BEARER_NAME, b->name))\r\nreturn -EMSGSIZE;\r\nif (nla_put_u32(skb, TIPC_NLA_BEARER_DOMAIN, ntohl(b->disc_domain)))\r\nreturn -EMSGSIZE;\r\nif (ntohl(b->priority) <= TIPC_MAX_LINK_PRI) {\r\nprop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);\r\nif (!prop)\r\nreturn -EMSGSIZE;\r\nif (nla_put_u32(skb, TIPC_NLA_PROP_PRIO, ntohl(b->priority)))\r\nreturn -EMSGSIZE;\r\nnla_nest_end(skb, prop);\r\n}\r\nnla_nest_end(skb, bearer);\r\nreturn 0;\r\n}\r\nstatic int tipc_nl_compat_bearer_disable(struct tipc_nl_compat_cmd_doit *cmd,\r\nstruct sk_buff *skb,\r\nstruct tipc_nl_compat_msg *msg)\r\n{\r\nchar *name;\r\nstruct nlattr *bearer;\r\nname = (char *)TLV_DATA(msg->req);\r\nbearer = nla_nest_start(skb, TIPC_NLA_BEARER);\r\nif (!bearer)\r\nreturn -EMSGSIZE;\r\nif (nla_put_string(skb, TIPC_NLA_BEARER_NAME, name))\r\nreturn -EMSGSIZE;\r\nnla_nest_end(skb, bearer);\r\nreturn 0;\r\n}\r\nstatic inline u32 perc(u32 count, u32 total)\r\n{\r\nreturn (count * 100 + (total / 2)) / total;\r\n}\r\nstatic void __fill_bc_link_stat(struct tipc_nl_compat_msg *msg,\r\nstruct nlattr *prop[], struct nlattr *stats[])\r\n{\r\ntipc_tlv_sprintf(msg->rep, " Window:%u packets\n",\r\nnla_get_u32(prop[TIPC_NLA_PROP_WIN]));\r\ntipc_tlv_sprintf(msg->rep,\r\n" RX packets:%u fragments:%u/%u bundles:%u/%u\n",\r\nnla_get_u32(stats[TIPC_NLA_STATS_RX_INFO]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_RX_FRAGMENTS]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_RX_FRAGMENTED]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_RX_BUNDLES]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_RX_BUNDLED]));\r\ntipc_tlv_sprintf(msg->rep,\r\n" TX packets:%u fragments:%u/%u bundles:%u/%u\n",\r\nnla_get_u32(stats[TIPC_NLA_STATS_TX_INFO]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_TX_FRAGMENTS]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_TX_FRAGMENTED]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_TX_BUNDLES]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_TX_BUNDLED]));\r\ntipc_tlv_sprintf(msg->rep, " RX naks:%u defs:%u dups:%u\n",\r\nnla_get_u32(stats[TIPC_NLA_STATS_RX_NACKS]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_RX_DEFERRED]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_DUPLICATES]));\r\ntipc_tlv_sprintf(msg->rep, " TX naks:%u acks:%u dups:%u\n",\r\nnla_get_u32(stats[TIPC_NLA_STATS_TX_NACKS]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_TX_ACKS]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_RETRANSMITTED]));\r\ntipc_tlv_sprintf(msg->rep,\r\n" Congestion link:%u Send queue max:%u avg:%u",\r\nnla_get_u32(stats[TIPC_NLA_STATS_LINK_CONGS]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_MAX_QUEUE]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_AVG_QUEUE]));\r\n}\r\nstatic int tipc_nl_compat_link_stat_dump(struct tipc_nl_compat_msg *msg,\r\nstruct nlattr **attrs)\r\n{\r\nchar *name;\r\nstruct nlattr *link[TIPC_NLA_LINK_MAX + 1];\r\nstruct nlattr *prop[TIPC_NLA_PROP_MAX + 1];\r\nstruct nlattr *stats[TIPC_NLA_STATS_MAX + 1];\r\nnla_parse_nested(link, TIPC_NLA_LINK_MAX, attrs[TIPC_NLA_LINK], NULL);\r\nnla_parse_nested(prop, TIPC_NLA_PROP_MAX, link[TIPC_NLA_LINK_PROP],\r\nNULL);\r\nnla_parse_nested(stats, TIPC_NLA_STATS_MAX, link[TIPC_NLA_LINK_STATS],\r\nNULL);\r\nname = (char *)TLV_DATA(msg->req);\r\nif (strcmp(name, nla_data(link[TIPC_NLA_LINK_NAME])) != 0)\r\nreturn 0;\r\ntipc_tlv_sprintf(msg->rep, "\nLink <%s>\n",\r\nnla_data(link[TIPC_NLA_LINK_NAME]));\r\nif (link[TIPC_NLA_LINK_BROADCAST]) {\r\n__fill_bc_link_stat(msg, prop, stats);\r\nreturn 0;\r\n}\r\nif (link[TIPC_NLA_LINK_ACTIVE])\r\ntipc_tlv_sprintf(msg->rep, " ACTIVE");\r\nelse if (link[TIPC_NLA_LINK_UP])\r\ntipc_tlv_sprintf(msg->rep, " STANDBY");\r\nelse\r\ntipc_tlv_sprintf(msg->rep, " DEFUNCT");\r\ntipc_tlv_sprintf(msg->rep, " MTU:%u Priority:%u",\r\nnla_get_u32(link[TIPC_NLA_LINK_MTU]),\r\nnla_get_u32(prop[TIPC_NLA_PROP_PRIO]));\r\ntipc_tlv_sprintf(msg->rep, " Tolerance:%u ms Window:%u packets\n",\r\nnla_get_u32(prop[TIPC_NLA_PROP_TOL]),\r\nnla_get_u32(prop[TIPC_NLA_PROP_WIN]));\r\ntipc_tlv_sprintf(msg->rep,\r\n" RX packets:%u fragments:%u/%u bundles:%u/%u\n",\r\nnla_get_u32(link[TIPC_NLA_LINK_RX]) -\r\nnla_get_u32(stats[TIPC_NLA_STATS_RX_INFO]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_RX_FRAGMENTS]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_RX_FRAGMENTED]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_RX_BUNDLES]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_RX_BUNDLED]));\r\ntipc_tlv_sprintf(msg->rep,\r\n" TX packets:%u fragments:%u/%u bundles:%u/%u\n",\r\nnla_get_u32(link[TIPC_NLA_LINK_TX]) -\r\nnla_get_u32(stats[TIPC_NLA_STATS_TX_INFO]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_TX_FRAGMENTS]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_TX_FRAGMENTED]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_TX_BUNDLES]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_TX_BUNDLED]));\r\ntipc_tlv_sprintf(msg->rep,\r\n" TX profile sample:%u packets average:%u octets\n",\r\nnla_get_u32(stats[TIPC_NLA_STATS_MSG_LEN_CNT]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_MSG_LEN_TOT]) /\r\nnla_get_u32(stats[TIPC_NLA_STATS_MSG_PROF_TOT]));\r\ntipc_tlv_sprintf(msg->rep,\r\n" 0-64:%u%% -256:%u%% -1024:%u%% -4096:%u%% ",\r\nperc(nla_get_u32(stats[TIPC_NLA_STATS_MSG_LEN_P0]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_MSG_PROF_TOT])),\r\nperc(nla_get_u32(stats[TIPC_NLA_STATS_MSG_LEN_P1]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_MSG_PROF_TOT])),\r\nperc(nla_get_u32(stats[TIPC_NLA_STATS_MSG_LEN_P2]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_MSG_PROF_TOT])),\r\nperc(nla_get_u32(stats[TIPC_NLA_STATS_MSG_LEN_P3]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_MSG_PROF_TOT])));\r\ntipc_tlv_sprintf(msg->rep, "-16384:%u%% -32768:%u%% -66000:%u%%\n",\r\nperc(nla_get_u32(stats[TIPC_NLA_STATS_MSG_LEN_P4]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_MSG_PROF_TOT])),\r\nperc(nla_get_u32(stats[TIPC_NLA_STATS_MSG_LEN_P5]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_MSG_PROF_TOT])),\r\nperc(nla_get_u32(stats[TIPC_NLA_STATS_MSG_LEN_P6]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_MSG_PROF_TOT])));\r\ntipc_tlv_sprintf(msg->rep,\r\n" RX states:%u probes:%u naks:%u defs:%u dups:%u\n",\r\nnla_get_u32(stats[TIPC_NLA_STATS_RX_STATES]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_RX_PROBES]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_RX_NACKS]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_RX_DEFERRED]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_DUPLICATES]));\r\ntipc_tlv_sprintf(msg->rep,\r\n" TX states:%u probes:%u naks:%u acks:%u dups:%u\n",\r\nnla_get_u32(stats[TIPC_NLA_STATS_TX_STATES]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_TX_PROBES]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_TX_NACKS]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_TX_ACKS]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_RETRANSMITTED]));\r\ntipc_tlv_sprintf(msg->rep,\r\n" Congestion link:%u Send queue max:%u avg:%u",\r\nnla_get_u32(stats[TIPC_NLA_STATS_LINK_CONGS]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_MAX_QUEUE]),\r\nnla_get_u32(stats[TIPC_NLA_STATS_AVG_QUEUE]));\r\nreturn 0;\r\n}\r\nstatic int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg *msg,\r\nstruct nlattr **attrs)\r\n{\r\nstruct nlattr *link[TIPC_NLA_LINK_MAX + 1];\r\nstruct tipc_link_info link_info;\r\nnla_parse_nested(link, TIPC_NLA_LINK_MAX, attrs[TIPC_NLA_LINK], NULL);\r\nlink_info.dest = nla_get_flag(link[TIPC_NLA_LINK_DEST]);\r\nlink_info.up = htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));\r\nstrcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]));\r\nreturn tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO,\r\n&link_info, sizeof(link_info));\r\n}\r\nstatic int __tipc_add_link_prop(struct sk_buff *skb,\r\nstruct tipc_nl_compat_msg *msg,\r\nstruct tipc_link_config *lc)\r\n{\r\nswitch (msg->cmd) {\r\ncase TIPC_CMD_SET_LINK_PRI:\r\nreturn nla_put_u32(skb, TIPC_NLA_PROP_PRIO, ntohl(lc->value));\r\ncase TIPC_CMD_SET_LINK_TOL:\r\nreturn nla_put_u32(skb, TIPC_NLA_PROP_TOL, ntohl(lc->value));\r\ncase TIPC_CMD_SET_LINK_WINDOW:\r\nreturn nla_put_u32(skb, TIPC_NLA_PROP_WIN, ntohl(lc->value));\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int tipc_nl_compat_media_set(struct sk_buff *skb,\r\nstruct tipc_nl_compat_msg *msg)\r\n{\r\nstruct nlattr *prop;\r\nstruct nlattr *media;\r\nstruct tipc_link_config *lc;\r\nlc = (struct tipc_link_config *)TLV_DATA(msg->req);\r\nmedia = nla_nest_start(skb, TIPC_NLA_MEDIA);\r\nif (!media)\r\nreturn -EMSGSIZE;\r\nif (nla_put_string(skb, TIPC_NLA_MEDIA_NAME, lc->name))\r\nreturn -EMSGSIZE;\r\nprop = nla_nest_start(skb, TIPC_NLA_MEDIA_PROP);\r\nif (!prop)\r\nreturn -EMSGSIZE;\r\n__tipc_add_link_prop(skb, msg, lc);\r\nnla_nest_end(skb, prop);\r\nnla_nest_end(skb, media);\r\nreturn 0;\r\n}\r\nstatic int tipc_nl_compat_bearer_set(struct sk_buff *skb,\r\nstruct tipc_nl_compat_msg *msg)\r\n{\r\nstruct nlattr *prop;\r\nstruct nlattr *bearer;\r\nstruct tipc_link_config *lc;\r\nlc = (struct tipc_link_config *)TLV_DATA(msg->req);\r\nbearer = nla_nest_start(skb, TIPC_NLA_BEARER);\r\nif (!bearer)\r\nreturn -EMSGSIZE;\r\nif (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))\r\nreturn -EMSGSIZE;\r\nprop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);\r\nif (!prop)\r\nreturn -EMSGSIZE;\r\n__tipc_add_link_prop(skb, msg, lc);\r\nnla_nest_end(skb, prop);\r\nnla_nest_end(skb, bearer);\r\nreturn 0;\r\n}\r\nstatic int __tipc_nl_compat_link_set(struct sk_buff *skb,\r\nstruct tipc_nl_compat_msg *msg)\r\n{\r\nstruct nlattr *prop;\r\nstruct nlattr *link;\r\nstruct tipc_link_config *lc;\r\nlc = (struct tipc_link_config *)TLV_DATA(msg->req);\r\nlink = nla_nest_start(skb, TIPC_NLA_LINK);\r\nif (!link)\r\nreturn -EMSGSIZE;\r\nif (nla_put_string(skb, TIPC_NLA_LINK_NAME, lc->name))\r\nreturn -EMSGSIZE;\r\nprop = nla_nest_start(skb, TIPC_NLA_LINK_PROP);\r\nif (!prop)\r\nreturn -EMSGSIZE;\r\n__tipc_add_link_prop(skb, msg, lc);\r\nnla_nest_end(skb, prop);\r\nnla_nest_end(skb, link);\r\nreturn 0;\r\n}\r\nstatic int tipc_nl_compat_link_set(struct tipc_nl_compat_cmd_doit *cmd,\r\nstruct sk_buff *skb,\r\nstruct tipc_nl_compat_msg *msg)\r\n{\r\nstruct tipc_link_config *lc;\r\nstruct tipc_bearer *bearer;\r\nstruct tipc_media *media;\r\nlc = (struct tipc_link_config *)TLV_DATA(msg->req);\r\nmedia = tipc_media_find(lc->name);\r\nif (media) {\r\ncmd->doit = &tipc_nl_media_set;\r\nreturn tipc_nl_compat_media_set(skb, msg);\r\n}\r\nbearer = tipc_bearer_find(msg->net, lc->name);\r\nif (bearer) {\r\ncmd->doit = &tipc_nl_bearer_set;\r\nreturn tipc_nl_compat_bearer_set(skb, msg);\r\n}\r\nreturn __tipc_nl_compat_link_set(skb, msg);\r\n}\r\nstatic int tipc_nl_compat_link_reset_stats(struct tipc_nl_compat_cmd_doit *cmd,\r\nstruct sk_buff *skb,\r\nstruct tipc_nl_compat_msg *msg)\r\n{\r\nchar *name;\r\nstruct nlattr *link;\r\nname = (char *)TLV_DATA(msg->req);\r\nlink = nla_nest_start(skb, TIPC_NLA_LINK);\r\nif (!link)\r\nreturn -EMSGSIZE;\r\nif (nla_put_string(skb, TIPC_NLA_LINK_NAME, name))\r\nreturn -EMSGSIZE;\r\nnla_nest_end(skb, link);\r\nreturn 0;\r\n}\r\nstatic int tipc_nl_compat_name_table_dump_header(struct tipc_nl_compat_msg *msg)\r\n{\r\nint i;\r\nu32 depth;\r\nstruct tipc_name_table_query *ntq;\r\nstatic const char * const header[] = {\r\n"Type ",\r\n"Lower Upper ",\r\n"Port Identity ",\r\n"Publication Scope"\r\n};\r\nntq = (struct tipc_name_table_query *)TLV_DATA(msg->req);\r\ndepth = ntohl(ntq->depth);\r\nif (depth > 4)\r\ndepth = 4;\r\nfor (i = 0; i < depth; i++)\r\ntipc_tlv_sprintf(msg->rep, header[i]);\r\ntipc_tlv_sprintf(msg->rep, "\n");\r\nreturn 0;\r\n}\r\nstatic int tipc_nl_compat_name_table_dump(struct tipc_nl_compat_msg *msg,\r\nstruct nlattr **attrs)\r\n{\r\nchar port_str[27];\r\nstruct tipc_name_table_query *ntq;\r\nstruct nlattr *nt[TIPC_NLA_NAME_TABLE_MAX + 1];\r\nstruct nlattr *publ[TIPC_NLA_PUBL_MAX + 1];\r\nu32 node, depth, type, lowbound, upbound;\r\nstatic const char * const scope_str[] = {"", " zone", " cluster",\r\n" node"};\r\nnla_parse_nested(nt, TIPC_NLA_NAME_TABLE_MAX,\r\nattrs[TIPC_NLA_NAME_TABLE], NULL);\r\nnla_parse_nested(publ, TIPC_NLA_PUBL_MAX, nt[TIPC_NLA_NAME_TABLE_PUBL],\r\nNULL);\r\nntq = (struct tipc_name_table_query *)TLV_DATA(msg->req);\r\ndepth = ntohl(ntq->depth);\r\ntype = ntohl(ntq->type);\r\nlowbound = ntohl(ntq->lowbound);\r\nupbound = ntohl(ntq->upbound);\r\nif (!(depth & TIPC_NTQ_ALLTYPES) &&\r\n(type != nla_get_u32(publ[TIPC_NLA_PUBL_TYPE])))\r\nreturn 0;\r\nif (lowbound && (lowbound > nla_get_u32(publ[TIPC_NLA_PUBL_UPPER])))\r\nreturn 0;\r\nif (upbound && (upbound < nla_get_u32(publ[TIPC_NLA_PUBL_LOWER])))\r\nreturn 0;\r\ntipc_tlv_sprintf(msg->rep, "%-10u ",\r\nnla_get_u32(publ[TIPC_NLA_PUBL_TYPE]));\r\nif (depth == 1)\r\ngoto out;\r\ntipc_tlv_sprintf(msg->rep, "%-10u %-10u ",\r\nnla_get_u32(publ[TIPC_NLA_PUBL_LOWER]),\r\nnla_get_u32(publ[TIPC_NLA_PUBL_UPPER]));\r\nif (depth == 2)\r\ngoto out;\r\nnode = nla_get_u32(publ[TIPC_NLA_PUBL_NODE]);\r\nsprintf(port_str, "<%u.%u.%u:%u>", tipc_zone(node), tipc_cluster(node),\r\ntipc_node(node), nla_get_u32(publ[TIPC_NLA_PUBL_REF]));\r\ntipc_tlv_sprintf(msg->rep, "%-26s ", port_str);\r\nif (depth == 3)\r\ngoto out;\r\ntipc_tlv_sprintf(msg->rep, "%-10u %s",\r\nnla_get_u32(publ[TIPC_NLA_PUBL_REF]),\r\nscope_str[nla_get_u32(publ[TIPC_NLA_PUBL_SCOPE])]);\r\nout:\r\ntipc_tlv_sprintf(msg->rep, "\n");\r\nreturn 0;\r\n}\r\nstatic int __tipc_nl_compat_publ_dump(struct tipc_nl_compat_msg *msg,\r\nstruct nlattr **attrs)\r\n{\r\nu32 type, lower, upper;\r\nstruct nlattr *publ[TIPC_NLA_PUBL_MAX + 1];\r\nnla_parse_nested(publ, TIPC_NLA_PUBL_MAX, attrs[TIPC_NLA_PUBL], NULL);\r\ntype = nla_get_u32(publ[TIPC_NLA_PUBL_TYPE]);\r\nlower = nla_get_u32(publ[TIPC_NLA_PUBL_LOWER]);\r\nupper = nla_get_u32(publ[TIPC_NLA_PUBL_UPPER]);\r\nif (lower == upper)\r\ntipc_tlv_sprintf(msg->rep, " {%u,%u}", type, lower);\r\nelse\r\ntipc_tlv_sprintf(msg->rep, " {%u,%u,%u}", type, lower, upper);\r\nreturn 0;\r\n}\r\nstatic int tipc_nl_compat_publ_dump(struct tipc_nl_compat_msg *msg, u32 sock)\r\n{\r\nint err;\r\nvoid *hdr;\r\nstruct nlattr *nest;\r\nstruct sk_buff *args;\r\nstruct tipc_nl_compat_cmd_dump dump;\r\nargs = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!args)\r\nreturn -ENOMEM;\r\nhdr = genlmsg_put(args, 0, 0, &tipc_genl_family, NLM_F_MULTI,\r\nTIPC_NL_PUBL_GET);\r\nnest = nla_nest_start(args, TIPC_NLA_SOCK);\r\nif (!nest) {\r\nkfree_skb(args);\r\nreturn -EMSGSIZE;\r\n}\r\nif (nla_put_u32(args, TIPC_NLA_SOCK_REF, sock)) {\r\nkfree_skb(args);\r\nreturn -EMSGSIZE;\r\n}\r\nnla_nest_end(args, nest);\r\ngenlmsg_end(args, hdr);\r\ndump.dumpit = tipc_nl_publ_dump;\r\ndump.format = __tipc_nl_compat_publ_dump;\r\nerr = __tipc_nl_compat_dumpit(&dump, msg, args);\r\nkfree_skb(args);\r\nreturn err;\r\n}\r\nstatic int tipc_nl_compat_sk_dump(struct tipc_nl_compat_msg *msg,\r\nstruct nlattr **attrs)\r\n{\r\nint err;\r\nu32 sock_ref;\r\nstruct nlattr *sock[TIPC_NLA_SOCK_MAX + 1];\r\nnla_parse_nested(sock, TIPC_NLA_SOCK_MAX, attrs[TIPC_NLA_SOCK], NULL);\r\nsock_ref = nla_get_u32(sock[TIPC_NLA_SOCK_REF]);\r\ntipc_tlv_sprintf(msg->rep, "%u:", sock_ref);\r\nif (sock[TIPC_NLA_SOCK_CON]) {\r\nu32 node;\r\nstruct nlattr *con[TIPC_NLA_CON_MAX + 1];\r\nnla_parse_nested(con, TIPC_NLA_CON_MAX, sock[TIPC_NLA_SOCK_CON],\r\nNULL);\r\nnode = nla_get_u32(con[TIPC_NLA_CON_NODE]);\r\ntipc_tlv_sprintf(msg->rep, " connected to <%u.%u.%u:%u>",\r\ntipc_zone(node),\r\ntipc_cluster(node),\r\ntipc_node(node),\r\nnla_get_u32(con[TIPC_NLA_CON_SOCK]));\r\nif (con[TIPC_NLA_CON_FLAG])\r\ntipc_tlv_sprintf(msg->rep, " via {%u,%u}\n",\r\nnla_get_u32(con[TIPC_NLA_CON_TYPE]),\r\nnla_get_u32(con[TIPC_NLA_CON_INST]));\r\nelse\r\ntipc_tlv_sprintf(msg->rep, "\n");\r\n} else if (sock[TIPC_NLA_SOCK_HAS_PUBL]) {\r\ntipc_tlv_sprintf(msg->rep, " bound to");\r\nerr = tipc_nl_compat_publ_dump(msg, sock_ref);\r\nif (err)\r\nreturn err;\r\n}\r\ntipc_tlv_sprintf(msg->rep, "\n");\r\nreturn 0;\r\n}\r\nstatic int tipc_nl_compat_media_dump(struct tipc_nl_compat_msg *msg,\r\nstruct nlattr **attrs)\r\n{\r\nstruct nlattr *media[TIPC_NLA_MEDIA_MAX + 1];\r\nnla_parse_nested(media, TIPC_NLA_MEDIA_MAX, attrs[TIPC_NLA_MEDIA],\r\nNULL);\r\nreturn tipc_add_tlv(msg->rep, TIPC_TLV_MEDIA_NAME,\r\nnla_data(media[TIPC_NLA_MEDIA_NAME]),\r\nnla_len(media[TIPC_NLA_MEDIA_NAME]));\r\n}\r\nstatic int tipc_nl_compat_node_dump(struct tipc_nl_compat_msg *msg,\r\nstruct nlattr **attrs)\r\n{\r\nstruct tipc_node_info node_info;\r\nstruct nlattr *node[TIPC_NLA_NODE_MAX + 1];\r\nnla_parse_nested(node, TIPC_NLA_NODE_MAX, attrs[TIPC_NLA_NODE], NULL);\r\nnode_info.addr = htonl(nla_get_u32(node[TIPC_NLA_NODE_ADDR]));\r\nnode_info.up = htonl(nla_get_flag(node[TIPC_NLA_NODE_UP]));\r\nreturn tipc_add_tlv(msg->rep, TIPC_TLV_NODE_INFO, &node_info,\r\nsizeof(node_info));\r\n}\r\nstatic int tipc_nl_compat_net_set(struct tipc_nl_compat_cmd_doit *cmd,\r\nstruct sk_buff *skb,\r\nstruct tipc_nl_compat_msg *msg)\r\n{\r\nu32 val;\r\nstruct nlattr *net;\r\nval = ntohl(*(__be32 *)TLV_DATA(msg->req));\r\nnet = nla_nest_start(skb, TIPC_NLA_NET);\r\nif (!net)\r\nreturn -EMSGSIZE;\r\nif (msg->cmd == TIPC_CMD_SET_NODE_ADDR) {\r\nif (nla_put_u32(skb, TIPC_NLA_NET_ADDR, val))\r\nreturn -EMSGSIZE;\r\n} else if (msg->cmd == TIPC_CMD_SET_NETID) {\r\nif (nla_put_u32(skb, TIPC_NLA_NET_ID, val))\r\nreturn -EMSGSIZE;\r\n}\r\nnla_nest_end(skb, net);\r\nreturn 0;\r\n}\r\nstatic int tipc_nl_compat_net_dump(struct tipc_nl_compat_msg *msg,\r\nstruct nlattr **attrs)\r\n{\r\n__be32 id;\r\nstruct nlattr *net[TIPC_NLA_NET_MAX + 1];\r\nnla_parse_nested(net, TIPC_NLA_NET_MAX, attrs[TIPC_NLA_NET], NULL);\r\nid = htonl(nla_get_u32(net[TIPC_NLA_NET_ID]));\r\nreturn tipc_add_tlv(msg->rep, TIPC_TLV_UNSIGNED, &id, sizeof(id));\r\n}\r\nstatic int tipc_cmd_show_stats_compat(struct tipc_nl_compat_msg *msg)\r\n{\r\nmsg->rep = tipc_tlv_alloc(ULTRA_STRING_MAX_LEN);\r\nif (!msg->rep)\r\nreturn -ENOMEM;\r\ntipc_tlv_init(msg->rep, TIPC_TLV_ULTRA_STRING);\r\ntipc_tlv_sprintf(msg->rep, "TIPC version " TIPC_MOD_VER "\n");\r\nreturn 0;\r\n}\r\nstatic int tipc_nl_compat_handle(struct tipc_nl_compat_msg *msg)\r\n{\r\nstruct tipc_nl_compat_cmd_dump dump;\r\nstruct tipc_nl_compat_cmd_doit doit;\r\nmemset(&dump, 0, sizeof(dump));\r\nmemset(&doit, 0, sizeof(doit));\r\nswitch (msg->cmd) {\r\ncase TIPC_CMD_NOOP:\r\nmsg->rep = tipc_tlv_alloc(0);\r\nif (!msg->rep)\r\nreturn -ENOMEM;\r\nreturn 0;\r\ncase TIPC_CMD_GET_BEARER_NAMES:\r\nmsg->rep_size = MAX_BEARERS * TLV_SPACE(TIPC_MAX_BEARER_NAME);\r\ndump.dumpit = tipc_nl_bearer_dump;\r\ndump.format = tipc_nl_compat_bearer_dump;\r\nreturn tipc_nl_compat_dumpit(&dump, msg);\r\ncase TIPC_CMD_ENABLE_BEARER:\r\nmsg->req_type = TIPC_TLV_BEARER_CONFIG;\r\ndoit.doit = tipc_nl_bearer_enable;\r\ndoit.transcode = tipc_nl_compat_bearer_enable;\r\nreturn tipc_nl_compat_doit(&doit, msg);\r\ncase TIPC_CMD_DISABLE_BEARER:\r\nmsg->req_type = TIPC_TLV_BEARER_NAME;\r\ndoit.doit = tipc_nl_bearer_disable;\r\ndoit.transcode = tipc_nl_compat_bearer_disable;\r\nreturn tipc_nl_compat_doit(&doit, msg);\r\ncase TIPC_CMD_SHOW_LINK_STATS:\r\nmsg->req_type = TIPC_TLV_LINK_NAME;\r\nmsg->rep_size = ULTRA_STRING_MAX_LEN;\r\nmsg->rep_type = TIPC_TLV_ULTRA_STRING;\r\ndump.dumpit = tipc_nl_link_dump;\r\ndump.format = tipc_nl_compat_link_stat_dump;\r\nreturn tipc_nl_compat_dumpit(&dump, msg);\r\ncase TIPC_CMD_GET_LINKS:\r\nmsg->req_type = TIPC_TLV_NET_ADDR;\r\nmsg->rep_size = ULTRA_STRING_MAX_LEN;\r\ndump.dumpit = tipc_nl_link_dump;\r\ndump.format = tipc_nl_compat_link_dump;\r\nreturn tipc_nl_compat_dumpit(&dump, msg);\r\ncase TIPC_CMD_SET_LINK_TOL:\r\ncase TIPC_CMD_SET_LINK_PRI:\r\ncase TIPC_CMD_SET_LINK_WINDOW:\r\nmsg->req_type = TIPC_TLV_LINK_CONFIG;\r\ndoit.doit = tipc_nl_link_set;\r\ndoit.transcode = tipc_nl_compat_link_set;\r\nreturn tipc_nl_compat_doit(&doit, msg);\r\ncase TIPC_CMD_RESET_LINK_STATS:\r\nmsg->req_type = TIPC_TLV_LINK_NAME;\r\ndoit.doit = tipc_nl_link_reset_stats;\r\ndoit.transcode = tipc_nl_compat_link_reset_stats;\r\nreturn tipc_nl_compat_doit(&doit, msg);\r\ncase TIPC_CMD_SHOW_NAME_TABLE:\r\nmsg->req_type = TIPC_TLV_NAME_TBL_QUERY;\r\nmsg->rep_size = ULTRA_STRING_MAX_LEN;\r\nmsg->rep_type = TIPC_TLV_ULTRA_STRING;\r\ndump.header = tipc_nl_compat_name_table_dump_header;\r\ndump.dumpit = tipc_nl_name_table_dump;\r\ndump.format = tipc_nl_compat_name_table_dump;\r\nreturn tipc_nl_compat_dumpit(&dump, msg);\r\ncase TIPC_CMD_SHOW_PORTS:\r\nmsg->rep_size = ULTRA_STRING_MAX_LEN;\r\nmsg->rep_type = TIPC_TLV_ULTRA_STRING;\r\ndump.dumpit = tipc_nl_sk_dump;\r\ndump.format = tipc_nl_compat_sk_dump;\r\nreturn tipc_nl_compat_dumpit(&dump, msg);\r\ncase TIPC_CMD_GET_MEDIA_NAMES:\r\nmsg->rep_size = MAX_MEDIA * TLV_SPACE(TIPC_MAX_MEDIA_NAME);\r\ndump.dumpit = tipc_nl_media_dump;\r\ndump.format = tipc_nl_compat_media_dump;\r\nreturn tipc_nl_compat_dumpit(&dump, msg);\r\ncase TIPC_CMD_GET_NODES:\r\nmsg->rep_size = ULTRA_STRING_MAX_LEN;\r\ndump.dumpit = tipc_nl_node_dump;\r\ndump.format = tipc_nl_compat_node_dump;\r\nreturn tipc_nl_compat_dumpit(&dump, msg);\r\ncase TIPC_CMD_SET_NODE_ADDR:\r\nmsg->req_type = TIPC_TLV_NET_ADDR;\r\ndoit.doit = tipc_nl_net_set;\r\ndoit.transcode = tipc_nl_compat_net_set;\r\nreturn tipc_nl_compat_doit(&doit, msg);\r\ncase TIPC_CMD_SET_NETID:\r\nmsg->req_type = TIPC_TLV_UNSIGNED;\r\ndoit.doit = tipc_nl_net_set;\r\ndoit.transcode = tipc_nl_compat_net_set;\r\nreturn tipc_nl_compat_doit(&doit, msg);\r\ncase TIPC_CMD_GET_NETID:\r\nmsg->rep_size = sizeof(u32);\r\ndump.dumpit = tipc_nl_net_dump;\r\ndump.format = tipc_nl_compat_net_dump;\r\nreturn tipc_nl_compat_dumpit(&dump, msg);\r\ncase TIPC_CMD_SHOW_STATS:\r\nreturn tipc_cmd_show_stats_compat(msg);\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int tipc_nl_compat_recv(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nint err;\r\nint len;\r\nstruct tipc_nl_compat_msg msg;\r\nstruct nlmsghdr *req_nlh;\r\nstruct nlmsghdr *rep_nlh;\r\nstruct tipc_genlmsghdr *req_userhdr = info->userhdr;\r\nmemset(&msg, 0, sizeof(msg));\r\nreq_nlh = (struct nlmsghdr *)skb->data;\r\nmsg.req = nlmsg_data(req_nlh) + GENL_HDRLEN + TIPC_GENL_HDRLEN;\r\nmsg.cmd = req_userhdr->cmd;\r\nmsg.dst_sk = info->dst_sk;\r\nmsg.net = genl_info_net(info);\r\nif ((msg.cmd & 0xC000) && (!netlink_net_capable(skb, CAP_NET_ADMIN))) {\r\nmsg.rep = tipc_get_err_tlv(TIPC_CFG_NOT_NET_ADMIN);\r\nerr = -EACCES;\r\ngoto send;\r\n}\r\nlen = nlmsg_attrlen(req_nlh, GENL_HDRLEN + TIPC_GENL_HDRLEN);\r\nif (len && !TLV_OK(msg.req, len)) {\r\nmsg.rep = tipc_get_err_tlv(TIPC_CFG_NOT_SUPPORTED);\r\nerr = -EOPNOTSUPP;\r\ngoto send;\r\n}\r\nerr = tipc_nl_compat_handle(&msg);\r\nif ((err == -EOPNOTSUPP) || (err == -EPERM))\r\nmsg.rep = tipc_get_err_tlv(TIPC_CFG_NOT_SUPPORTED);\r\nelse if (err == -EINVAL)\r\nmsg.rep = tipc_get_err_tlv(TIPC_CFG_TLV_ERROR);\r\nsend:\r\nif (!msg.rep)\r\nreturn err;\r\nlen = nlmsg_total_size(GENL_HDRLEN + TIPC_GENL_HDRLEN);\r\nskb_push(msg.rep, len);\r\nrep_nlh = nlmsg_hdr(msg.rep);\r\nmemcpy(rep_nlh, info->nlhdr, len);\r\nrep_nlh->nlmsg_len = msg.rep->len;\r\ngenlmsg_unicast(msg.net, msg.rep, NETLINK_CB(skb).portid);\r\nreturn err;\r\n}\r\nint tipc_netlink_compat_start(void)\r\n{\r\nint res;\r\nres = genl_register_family_with_ops(&tipc_genl_compat_family,\r\ntipc_genl_compat_ops);\r\nif (res) {\r\npr_err("Failed to register legacy compat interface\n");\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nvoid tipc_netlink_compat_stop(void)\r\n{\r\ngenl_unregister_family(&tipc_genl_compat_family);\r\n}
