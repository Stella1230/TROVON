static void process_frame(struct camera_data *cam)\r\n{\r\nstatic int frame_count;\r\nunsigned char *inbuff = cam->workbuff->data;\r\nDBG("Processing frame #%d, current:%d\n",\r\ncam->workbuff->num, cam->curbuff->num);\r\nif(cam->workbuff->length > cam->workbuff->max_length)\r\ncam->workbuff->max_length = cam->workbuff->length;\r\nif ((inbuff[0] == 0xFF) && (inbuff[1] == 0xD8)) {\r\nframe_count++;\r\n} else {\r\ncam->workbuff->status = FRAME_ERROR;\r\nDBG("Start of frame not found\n");\r\nreturn;\r\n}\r\nif(!cam->first_image_seen) {\r\ncam->first_image_seen = 1;\r\ncam->workbuff->status = FRAME_EMPTY;\r\nreturn;\r\n}\r\nif (cam->workbuff->length > 3) {\r\nif(cam->mmapped &&\r\ncam->workbuff->length < cam->workbuff->max_length) {\r\nmemset(cam->workbuff->data+cam->workbuff->length,\r\n0, cam->workbuff->max_length-\r\ncam->workbuff->length);\r\n}\r\ncam->workbuff->max_length = cam->workbuff->length;\r\ncam->workbuff->status = FRAME_READY;\r\nif(!cam->mmapped && cam->num_frames > 2) {\r\ncam->curbuff->status = FRAME_EMPTY;\r\n}\r\ncam->curbuff = cam->workbuff;\r\ncam->workbuff = cam->workbuff->next;\r\nDBG("Changed buffers, work:%d, current:%d\n",\r\ncam->workbuff->num, cam->curbuff->num);\r\nreturn;\r\n} else {\r\nDBG("Not enough data for an image.\n");\r\n}\r\ncam->workbuff->status = FRAME_ERROR;\r\nreturn;\r\n}\r\nstatic void add_APPn(struct camera_data *cam)\r\n{\r\nif(cam->APP_len > 0) {\r\ncam->workbuff->data[cam->workbuff->length++] = 0xFF;\r\ncam->workbuff->data[cam->workbuff->length++] = 0xE0+cam->APPn;\r\ncam->workbuff->data[cam->workbuff->length++] = 0;\r\ncam->workbuff->data[cam->workbuff->length++] = cam->APP_len+2;\r\nmemcpy(cam->workbuff->data+cam->workbuff->length,\r\ncam->APP_data, cam->APP_len);\r\ncam->workbuff->length += cam->APP_len;\r\n}\r\n}\r\nstatic void add_COM(struct camera_data *cam)\r\n{\r\nif(cam->COM_len > 0) {\r\ncam->workbuff->data[cam->workbuff->length++] = 0xFF;\r\ncam->workbuff->data[cam->workbuff->length++] = 0xFE;\r\ncam->workbuff->data[cam->workbuff->length++] = 0;\r\ncam->workbuff->data[cam->workbuff->length++] = cam->COM_len+2;\r\nmemcpy(cam->workbuff->data+cam->workbuff->length,\r\ncam->COM_data, cam->COM_len);\r\ncam->workbuff->length += cam->COM_len;\r\n}\r\n}\r\nstatic void cpia2_usb_complete(struct urb *urb)\r\n{\r\nint i;\r\nunsigned char *cdata;\r\nstatic bool frame_ready = false;\r\nstruct camera_data *cam = (struct camera_data *) urb->context;\r\nif (urb->status!=0) {\r\nif (!(urb->status == -ENOENT ||\r\nurb->status == -ECONNRESET ||\r\nurb->status == -ESHUTDOWN))\r\n{\r\nDBG("urb->status = %d!\n", urb->status);\r\n}\r\nDBG("Stopping streaming\n");\r\nreturn;\r\n}\r\nif (!cam->streaming || !video_is_registered(&cam->vdev)) {\r\nLOG("Will now stop the streaming: streaming = %d, present=%d\n",\r\ncam->streaming, video_is_registered(&cam->vdev));\r\nreturn;\r\n}\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nu16 checksum, iso_checksum;\r\nint j;\r\nint n = urb->iso_frame_desc[i].actual_length;\r\nint st = urb->iso_frame_desc[i].status;\r\nif(cam->workbuff->status == FRAME_READY) {\r\nstruct framebuf *ptr;\r\nDBG("workbuff full, searching\n");\r\nfor (ptr = cam->workbuff->next;\r\nptr != cam->workbuff;\r\nptr = ptr->next)\r\n{\r\nif (ptr->status == FRAME_EMPTY) {\r\nptr->status = FRAME_READING;\r\nptr->length = 0;\r\nbreak;\r\n}\r\n}\r\nif (ptr == cam->workbuff)\r\nbreak;\r\ncam->workbuff = ptr;\r\n}\r\nif (cam->workbuff->status == FRAME_EMPTY ||\r\ncam->workbuff->status == FRAME_ERROR) {\r\ncam->workbuff->status = FRAME_READING;\r\ncam->workbuff->length = 0;\r\n}\r\ncdata = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\r\nif (st) {\r\nLOG("cpia2 data error: [%d] len=%d, status = %d\n",\r\ni, n, st);\r\nif(!ALLOW_CORRUPT)\r\ncam->workbuff->status = FRAME_ERROR;\r\ncontinue;\r\n}\r\nif(n<=2)\r\ncontinue;\r\nchecksum = 0;\r\nfor(j=0; j<n-2; ++j)\r\nchecksum += cdata[j];\r\niso_checksum = cdata[j] + cdata[j+1]*256;\r\nif(checksum != iso_checksum) {\r\nLOG("checksum mismatch: [%d] len=%d, calculated = %x, checksum = %x\n",\r\ni, n, (int)checksum, (int)iso_checksum);\r\nif(!ALLOW_CORRUPT) {\r\ncam->workbuff->status = FRAME_ERROR;\r\ncontinue;\r\n}\r\n}\r\nn -= 2;\r\nif(cam->workbuff->status != FRAME_READING) {\r\nif((0xFF == cdata[0] && 0xD8 == cdata[1]) ||\r\n(0xD8 == cdata[0] && 0xFF == cdata[1] &&\r\n0 != cdata[2])) {\r\ncam->frame_count++;\r\n}\r\nDBG("workbuff not reading, status=%d\n",\r\ncam->workbuff->status);\r\ncontinue;\r\n}\r\nif (cam->frame_size < cam->workbuff->length + n) {\r\nERR("buffer overflow! length: %d, n: %d\n",\r\ncam->workbuff->length, n);\r\ncam->workbuff->status = FRAME_ERROR;\r\nif(cam->workbuff->length > cam->workbuff->max_length)\r\ncam->workbuff->max_length =\r\ncam->workbuff->length;\r\ncontinue;\r\n}\r\nif (cam->workbuff->length == 0) {\r\nint data_offset;\r\nif ((0xD8 == cdata[0]) && (0xFF == cdata[1])) {\r\ndata_offset = 1;\r\n} else if((0xFF == cdata[0]) && (0xD8 == cdata[1])\r\n&& (0xFF == cdata[2])) {\r\ndata_offset = 2;\r\n} else {\r\nDBG("Ignoring packet, not beginning!\n");\r\ncontinue;\r\n}\r\nDBG("Start of frame pattern found\n");\r\nv4l2_get_timestamp(&cam->workbuff->timestamp);\r\ncam->workbuff->seq = cam->frame_count++;\r\ncam->workbuff->data[0] = 0xFF;\r\ncam->workbuff->data[1] = 0xD8;\r\ncam->workbuff->length = 2;\r\nadd_APPn(cam);\r\nadd_COM(cam);\r\nmemcpy(cam->workbuff->data+cam->workbuff->length,\r\ncdata+data_offset, n-data_offset);\r\ncam->workbuff->length += n-data_offset;\r\n} else if (cam->workbuff->length > 0) {\r\nmemcpy(cam->workbuff->data + cam->workbuff->length,\r\ncdata, n);\r\ncam->workbuff->length += n;\r\n}\r\nif ((cam->workbuff->length >= 3) &&\r\n(cam->workbuff->data[cam->workbuff->length - 3] == 0xFF) &&\r\n(cam->workbuff->data[cam->workbuff->length - 2] == 0xD9) &&\r\n(cam->workbuff->data[cam->workbuff->length - 1] == 0xFF)) {\r\nframe_ready = true;\r\ncam->workbuff->data[cam->workbuff->length - 1] = 0;\r\ncam->workbuff->length -= 1;\r\n} else if ((cam->workbuff->length >= 2) &&\r\n(cam->workbuff->data[cam->workbuff->length - 2] == 0xFF) &&\r\n(cam->workbuff->data[cam->workbuff->length - 1] == 0xD9)) {\r\nframe_ready = true;\r\n}\r\nif (frame_ready) {\r\nDBG("Workbuff image size = %d\n",cam->workbuff->length);\r\nprocess_frame(cam);\r\nframe_ready = false;\r\nif (waitqueue_active(&cam->wq_stream))\r\nwake_up_interruptible(&cam->wq_stream);\r\n}\r\n}\r\nif(cam->streaming) {\r\nurb->dev = cam->dev;\r\nif ((i = usb_submit_urb(urb, GFP_ATOMIC)) != 0)\r\nERR("%s: usb_submit_urb ret %d!\n", __func__, i);\r\n}\r\n}\r\nstatic int configure_transfer_mode(struct camera_data *cam, unsigned int alt)\r\n{\r\nstatic unsigned char iso_regs[8][4] = {\r\n{0x00, 0x00, 0x00, 0x00},\r\n{0x00, 0x00, 0x00, 0x00},\r\n{0xB9, 0x00, 0x00, 0x7E},\r\n{0xB9, 0x00, 0x01, 0x7E},\r\n{0xB9, 0x00, 0x02, 0x7E},\r\n{0xB9, 0x00, 0x02, 0xFE},\r\n{0xB9, 0x00, 0x03, 0x7E},\r\n{0xB9, 0x00, 0x03, 0xFD}\r\n};\r\nstruct cpia2_command cmd;\r\nunsigned char reg;\r\nif (!video_is_registered(&cam->vdev))\r\nreturn -ENODEV;\r\ncmd.direction = TRANSFER_WRITE;\r\ncmd.buffer.block_data[0] = iso_regs[alt][0];\r\ncmd.buffer.block_data[1] = iso_regs[alt][1];\r\ncmd.buffer.block_data[2] = iso_regs[alt][2];\r\ncmd.buffer.block_data[3] = iso_regs[alt][3];\r\ncmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VC;\r\ncmd.start = CPIA2_VC_USB_ISOLIM;\r\ncmd.reg_count = 4;\r\ncpia2_send_command(cam, &cmd);\r\ncmd.direction = TRANSFER_READ;\r\ncmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VC;\r\ncmd.start = CPIA2_VC_USB_STRM;\r\ncmd.reg_count = 1;\r\ncpia2_send_command(cam, &cmd);\r\nreg = cmd.buffer.block_data[0];\r\nreg &= ~(CPIA2_VC_USB_STRM_BLK_ENABLE |\r\nCPIA2_VC_USB_STRM_ISO_ENABLE |\r\nCPIA2_VC_USB_STRM_INT_ENABLE);\r\nif (alt == USBIF_BULK) {\r\nDBG("Enabling bulk xfer\n");\r\nreg |= CPIA2_VC_USB_STRM_BLK_ENABLE;\r\ncam->xfer_mode = XFER_BULK;\r\n} else if (alt >= USBIF_ISO_1) {\r\nDBG("Enabling ISOC xfer\n");\r\nreg |= CPIA2_VC_USB_STRM_ISO_ENABLE;\r\ncam->xfer_mode = XFER_ISOC;\r\n}\r\ncmd.buffer.block_data[0] = reg;\r\ncmd.direction = TRANSFER_WRITE;\r\ncmd.start = CPIA2_VC_USB_STRM;\r\ncmd.reg_count = 1;\r\ncmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VC;\r\ncpia2_send_command(cam, &cmd);\r\nreturn 0;\r\n}\r\nint cpia2_usb_change_streaming_alternate(struct camera_data *cam,\r\nunsigned int alt)\r\n{\r\nint ret = 0;\r\nif(alt < USBIF_ISO_1 || alt > USBIF_ISO_6)\r\nreturn -EINVAL;\r\nif(alt == cam->params.camera_state.stream_mode)\r\nreturn 0;\r\ncpia2_usb_stream_pause(cam);\r\nconfigure_transfer_mode(cam, alt);\r\ncam->params.camera_state.stream_mode = alt;\r\ncpia2_reset_camera(cam);\r\ncpia2_usb_stream_resume(cam);\r\nreturn ret;\r\n}\r\nstatic int set_alternate(struct camera_data *cam, unsigned int alt)\r\n{\r\nint ret = 0;\r\nif(alt == cam->cur_alt)\r\nreturn 0;\r\nif (cam->cur_alt != USBIF_CMDONLY) {\r\nDBG("Changing from alt %d to %d\n", cam->cur_alt, USBIF_CMDONLY);\r\nret = usb_set_interface(cam->dev, cam->iface, USBIF_CMDONLY);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nif (alt != USBIF_CMDONLY) {\r\nDBG("Changing from alt %d to %d\n", USBIF_CMDONLY, alt);\r\nret = usb_set_interface(cam->dev, cam->iface, alt);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\ncam->old_alt = cam->cur_alt;\r\ncam->cur_alt = alt;\r\nreturn ret;\r\n}\r\nstatic void free_sbufs(struct camera_data *cam)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_SBUF; i++) {\r\nif(cam->sbuf[i].urb) {\r\nusb_kill_urb(cam->sbuf[i].urb);\r\nusb_free_urb(cam->sbuf[i].urb);\r\ncam->sbuf[i].urb = NULL;\r\n}\r\nif(cam->sbuf[i].data) {\r\nkfree(cam->sbuf[i].data);\r\ncam->sbuf[i].data = NULL;\r\n}\r\n}\r\n}\r\nstatic int write_packet(struct usb_device *udev,\r\nu8 request, u8 * registers, u16 start, size_t size)\r\n{\r\nif (!registers || size <= 0)\r\nreturn -EINVAL;\r\nreturn usb_control_msg(udev,\r\nusb_sndctrlpipe(udev, 0),\r\nrequest,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nstart,\r\n0,\r\nregisters,\r\nsize,\r\nHZ);\r\n}\r\nstatic int read_packet(struct usb_device *udev,\r\nu8 request, u8 * registers, u16 start, size_t size)\r\n{\r\nif (!registers || size <= 0)\r\nreturn -EINVAL;\r\nreturn usb_control_msg(udev,\r\nusb_rcvctrlpipe(udev, 0),\r\nrequest,\r\nUSB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_DEVICE,\r\nstart,\r\n0,\r\nregisters,\r\nsize,\r\nHZ);\r\n}\r\nint cpia2_usb_transfer_cmd(struct camera_data *cam,\r\nvoid *registers,\r\nu8 request, u8 start, u8 count, u8 direction)\r\n{\r\nint err = 0;\r\nstruct usb_device *udev = cam->dev;\r\nif (!udev) {\r\nERR("%s: Internal driver error: udev is NULL\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (!registers) {\r\nERR("%s: Internal driver error: register array is NULL\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (direction == TRANSFER_READ) {\r\nerr = read_packet(udev, request, (u8 *)registers, start, count);\r\nif (err > 0)\r\nerr = 0;\r\n} else if (direction == TRANSFER_WRITE) {\r\nerr =write_packet(udev, request, (u8 *)registers, start, count);\r\nif (err < 0) {\r\nLOG("Control message failed, err val = %d\n", err);\r\nLOG("Message: request = 0x%0X, start = 0x%0X\n",\r\nrequest, start);\r\nLOG("Message: count = %d, register[0] = 0x%0X\n",\r\ncount, ((unsigned char *) registers)[0]);\r\n} else\r\nerr=0;\r\n} else {\r\nLOG("Unexpected first byte of direction: %d\n",\r\ndirection);\r\nreturn -EINVAL;\r\n}\r\nif(err != 0)\r\nLOG("Unexpected error: %d\n", err);\r\nreturn err;\r\n}\r\nstatic int submit_urbs(struct camera_data *cam)\r\n{\r\nstruct urb *urb;\r\nint fx, err, i, j;\r\nfor(i=0; i<NUM_SBUF; ++i) {\r\nif (cam->sbuf[i].data)\r\ncontinue;\r\ncam->sbuf[i].data =\r\nkmalloc(FRAMES_PER_DESC * FRAME_SIZE_PER_DESC, GFP_KERNEL);\r\nif (!cam->sbuf[i].data) {\r\nwhile (--i >= 0) {\r\nkfree(cam->sbuf[i].data);\r\ncam->sbuf[i].data = NULL;\r\n}\r\nreturn -ENOMEM;\r\n}\r\n}\r\nfor(i=0; i<NUM_SBUF; ++i) {\r\nif(cam->sbuf[i].urb) {\r\ncontinue;\r\n}\r\nurb = usb_alloc_urb(FRAMES_PER_DESC, GFP_KERNEL);\r\nif (!urb) {\r\nERR("%s: usb_alloc_urb error!\n", __func__);\r\nfor (j = 0; j < i; j++)\r\nusb_free_urb(cam->sbuf[j].urb);\r\nreturn -ENOMEM;\r\n}\r\ncam->sbuf[i].urb = urb;\r\nurb->dev = cam->dev;\r\nurb->context = cam;\r\nurb->pipe = usb_rcvisocpipe(cam->dev, 1 );\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->transfer_buffer = cam->sbuf[i].data;\r\nurb->complete = cpia2_usb_complete;\r\nurb->number_of_packets = FRAMES_PER_DESC;\r\nurb->interval = 1;\r\nurb->transfer_buffer_length =\r\nFRAME_SIZE_PER_DESC * FRAMES_PER_DESC;\r\nfor (fx = 0; fx < FRAMES_PER_DESC; fx++) {\r\nurb->iso_frame_desc[fx].offset =\r\nFRAME_SIZE_PER_DESC * fx;\r\nurb->iso_frame_desc[fx].length = FRAME_SIZE_PER_DESC;\r\n}\r\n}\r\nfor(i=0; i<NUM_SBUF; ++i) {\r\nerr = usb_submit_urb(cam->sbuf[i].urb, GFP_KERNEL);\r\nif (err) {\r\nERR("usb_submit_urb[%d]() = %d\n", i, err);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint cpia2_usb_stream_start(struct camera_data *cam, unsigned int alternate)\r\n{\r\nint ret;\r\nint old_alt;\r\nif(cam->streaming)\r\nreturn 0;\r\nif (cam->flush) {\r\nint i;\r\nDBG("Flushing buffers\n");\r\nfor(i=0; i<cam->num_frames; ++i) {\r\ncam->buffers[i].status = FRAME_EMPTY;\r\ncam->buffers[i].length = 0;\r\n}\r\ncam->curbuff = &cam->buffers[0];\r\ncam->workbuff = cam->curbuff->next;\r\ncam->flush = false;\r\n}\r\nold_alt = cam->params.camera_state.stream_mode;\r\ncam->params.camera_state.stream_mode = 0;\r\nret = cpia2_usb_change_streaming_alternate(cam, alternate);\r\nif (ret < 0) {\r\nint ret2;\r\nERR("cpia2_usb_change_streaming_alternate() = %d!\n", ret);\r\ncam->params.camera_state.stream_mode = old_alt;\r\nret2 = set_alternate(cam, USBIF_CMDONLY);\r\nif (ret2 < 0) {\r\nERR("cpia2_usb_change_streaming_alternate(%d) =%d has already "\r\n"failed. Then tried to call "\r\n"set_alternate(USBIF_CMDONLY) = %d.\n",\r\nalternate, ret, ret2);\r\n}\r\n} else {\r\ncam->frame_count = 0;\r\ncam->streaming = 1;\r\nret = cpia2_usb_stream_resume(cam);\r\n}\r\nreturn ret;\r\n}\r\nint cpia2_usb_stream_pause(struct camera_data *cam)\r\n{\r\nint ret = 0;\r\nif(cam->streaming) {\r\nfree_sbufs(cam);\r\nret = set_alternate(cam, USBIF_CMDONLY);\r\n}\r\nreturn ret;\r\n}\r\nint cpia2_usb_stream_resume(struct camera_data *cam)\r\n{\r\nint ret = 0;\r\nif(cam->streaming) {\r\ncam->first_image_seen = 0;\r\nret = set_alternate(cam, cam->params.camera_state.stream_mode);\r\nif(ret == 0) {\r\ncpia2_do_command(cam, CPIA2_CMD_SET_USER_EFFECTS, TRANSFER_WRITE,\r\ncam->params.vp_params.user_effects);\r\nret = submit_urbs(cam);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint cpia2_usb_stream_stop(struct camera_data *cam)\r\n{\r\nint ret;\r\nret = cpia2_usb_stream_pause(cam);\r\ncam->streaming = 0;\r\nconfigure_transfer_mode(cam, 0);\r\nreturn ret;\r\n}\r\nstatic int cpia2_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct usb_interface_descriptor *interface;\r\nstruct camera_data *cam;\r\nint ret;\r\nif (udev->descriptor.bNumConfigurations != 1)\r\nreturn -ENODEV;\r\ninterface = &intf->cur_altsetting->desc;\r\nLOG("CPiA2 USB camera found\n");\r\ncam = cpia2_init_camera_struct(intf);\r\nif (cam == NULL)\r\nreturn -ENOMEM;\r\ncam->dev = udev;\r\ncam->iface = interface->bInterfaceNumber;\r\nret = set_alternate(cam, USBIF_CMDONLY);\r\nif (ret < 0) {\r\nERR("%s: usb_set_interface error (ret = %d)\n", __func__, ret);\r\nkfree(cam);\r\nreturn ret;\r\n}\r\nif((ret = cpia2_init_camera(cam)) < 0) {\r\nERR("%s: failed to initialize cpia2 camera (ret = %d)\n", __func__, ret);\r\nkfree(cam);\r\nreturn ret;\r\n}\r\nLOG(" CPiA Version: %d.%02d (%d.%d)\n",\r\ncam->params.version.firmware_revision_hi,\r\ncam->params.version.firmware_revision_lo,\r\ncam->params.version.asic_id,\r\ncam->params.version.asic_rev);\r\nLOG(" CPiA PnP-ID: %04x:%04x:%04x\n",\r\ncam->params.pnp_id.vendor,\r\ncam->params.pnp_id.product,\r\ncam->params.pnp_id.device_revision);\r\nLOG(" SensorID: %d.(version %d)\n",\r\ncam->params.version.sensor_flags,\r\ncam->params.version.sensor_rev);\r\nusb_set_intfdata(intf, cam);\r\nret = cpia2_register_camera(cam);\r\nif (ret < 0) {\r\nERR("%s: Failed to register cpia2 camera (ret = %d)\n", __func__, ret);\r\nkfree(cam);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cpia2_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct camera_data *cam = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nDBG("Stopping stream\n");\r\ncpia2_usb_stream_stop(cam);\r\nmutex_lock(&cam->v4l2_lock);\r\nDBG("Unregistering camera\n");\r\ncpia2_unregister_camera(cam);\r\nv4l2_device_disconnect(&cam->v4l2_dev);\r\nmutex_unlock(&cam->v4l2_lock);\r\nv4l2_device_put(&cam->v4l2_dev);\r\nif(cam->buffers) {\r\nDBG("Wakeup waiting processes\n");\r\ncam->curbuff->status = FRAME_READY;\r\ncam->curbuff->length = 0;\r\nif (waitqueue_active(&cam->wq_stream))\r\nwake_up_interruptible(&cam->wq_stream);\r\n}\r\nDBG("Releasing interface\n");\r\nusb_driver_release_interface(&cpia2_driver, intf);\r\nLOG("CPiA2 camera disconnected.\n");\r\n}\r\nstatic int cpia2_usb_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct camera_data *cam = usb_get_intfdata(intf);\r\nmutex_lock(&cam->v4l2_lock);\r\nif (cam->streaming) {\r\ncpia2_usb_stream_stop(cam);\r\ncam->streaming = 1;\r\n}\r\nmutex_unlock(&cam->v4l2_lock);\r\ndev_info(&intf->dev, "going into suspend..\n");\r\nreturn 0;\r\n}\r\nstatic int cpia2_usb_resume(struct usb_interface *intf)\r\n{\r\nstruct camera_data *cam = usb_get_intfdata(intf);\r\nmutex_lock(&cam->v4l2_lock);\r\nv4l2_ctrl_handler_setup(&cam->hdl);\r\nif (cam->streaming) {\r\ncam->streaming = 0;\r\ncpia2_usb_stream_start(cam,\r\ncam->params.camera_state.stream_mode);\r\n}\r\nmutex_unlock(&cam->v4l2_lock);\r\ndev_info(&intf->dev, "coming out of suspend..\n");\r\nreturn 0;\r\n}\r\nint cpia2_usb_init(void)\r\n{\r\nreturn usb_register(&cpia2_driver);\r\n}\r\nvoid cpia2_usb_cleanup(void)\r\n{\r\nschedule_timeout(2 * HZ);\r\nusb_deregister(&cpia2_driver);\r\n}
