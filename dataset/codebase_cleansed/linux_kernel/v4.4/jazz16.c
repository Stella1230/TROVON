static irqreturn_t jazz16_interrupt(int irq, void *chip)\r\n{\r\nreturn snd_sb8dsp_interrupt(chip);\r\n}\r\nstatic int jazz16_configure_ports(unsigned long port,\r\nunsigned long mpu_port, int idx)\r\n{\r\nunsigned char val;\r\nif (!request_region(0x201, 1, "jazz16 config")) {\r\nsnd_printk(KERN_ERR "config port region is already in use.\n");\r\nreturn -EBUSY;\r\n}\r\noutb(SB_JAZZ16_WAKEUP - idx, 0x201);\r\nudelay(100);\r\noutb(SB_JAZZ16_SET_PORTS + idx, 0x201);\r\nudelay(100);\r\nval = port & 0x70;\r\nval |= (mpu_port & 0x30) >> 4;\r\noutb(val, 0x201);\r\nrelease_region(0x201, 1);\r\nreturn 0;\r\n}\r\nstatic int jazz16_detect_board(unsigned long port,\r\nunsigned long mpu_port)\r\n{\r\nint err;\r\nint val;\r\nstruct snd_sb chip;\r\nif (!request_region(port, 0x10, "jazz16")) {\r\nsnd_printk(KERN_ERR "I/O port region is already in use.\n");\r\nreturn -EBUSY;\r\n}\r\nchip.port = port;\r\nerr = snd_sbdsp_reset(&chip);\r\nif (err < 0)\r\nfor (val = 0; val < 4; val++) {\r\nerr = jazz16_configure_ports(port, mpu_port, val);\r\nif (err < 0)\r\nbreak;\r\nerr = snd_sbdsp_reset(&chip);\r\nif (!err)\r\nbreak;\r\n}\r\nif (err < 0) {\r\nerr = -ENODEV;\r\ngoto err_unmap;\r\n}\r\nif (!snd_sbdsp_command(&chip, SB_DSP_GET_JAZZ_BRD_REV)) {\r\nerr = -EBUSY;\r\ngoto err_unmap;\r\n}\r\nval = snd_sbdsp_get_byte(&chip);\r\nif (val >= 0x30)\r\nsnd_sbdsp_get_byte(&chip);\r\nif ((val & 0xf0) != 0x10) {\r\nerr = -ENODEV;\r\ngoto err_unmap;\r\n}\r\nif (!snd_sbdsp_command(&chip, SB_DSP_GET_JAZZ_MODEL)) {\r\nerr = -EBUSY;\r\ngoto err_unmap;\r\n}\r\nsnd_sbdsp_get_byte(&chip);\r\nerr = snd_sbdsp_get_byte(&chip);\r\nsnd_printd("Media Vision Jazz16 board detected: rev 0x%x, model 0x%x\n",\r\nval, err);\r\nerr = 0;\r\nerr_unmap:\r\nrelease_region(port, 0x10);\r\nreturn err;\r\n}\r\nstatic int jazz16_configure_board(struct snd_sb *chip, int mpu_irq)\r\n{\r\nstatic unsigned char jazz_irq_bits[] = { 0, 0, 2, 3, 0, 1, 0, 4,\r\n0, 2, 5, 0, 0, 0, 0, 6 };\r\nstatic unsigned char jazz_dma_bits[] = { 0, 1, 0, 2, 0, 3, 0, 4 };\r\nif (jazz_dma_bits[chip->dma8] == 0 ||\r\njazz_dma_bits[chip->dma16] == 0 ||\r\njazz_irq_bits[chip->irq] == 0)\r\nreturn -EINVAL;\r\nif (!snd_sbdsp_command(chip, SB_JAZZ16_SET_DMAINTR))\r\nreturn -EBUSY;\r\nif (!snd_sbdsp_command(chip,\r\njazz_dma_bits[chip->dma8] |\r\n(jazz_dma_bits[chip->dma16] << 4)))\r\nreturn -EBUSY;\r\nif (!snd_sbdsp_command(chip,\r\njazz_irq_bits[chip->irq] |\r\n(jazz_irq_bits[mpu_irq] << 4)))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int snd_jazz16_match(struct device *devptr, unsigned int dev)\r\n{\r\nif (!enable[dev])\r\nreturn 0;\r\nif (port[dev] == SNDRV_AUTO_PORT) {\r\nsnd_printk(KERN_ERR "please specify port\n");\r\nreturn 0;\r\n} else if (port[dev] == 0x200 || (port[dev] & ~0x270)) {\r\nsnd_printk(KERN_ERR "incorrect port specified\n");\r\nreturn 0;\r\n}\r\nif (dma8[dev] != SNDRV_AUTO_DMA &&\r\ndma8[dev] != 1 && dma8[dev] != 3) {\r\nsnd_printk(KERN_ERR "dma8 must be 1 or 3\n");\r\nreturn 0;\r\n}\r\nif (dma16[dev] != SNDRV_AUTO_DMA &&\r\ndma16[dev] != 5 && dma16[dev] != 7) {\r\nsnd_printk(KERN_ERR "dma16 must be 5 or 7\n");\r\nreturn 0;\r\n}\r\nif (mpu_port[dev] != SNDRV_AUTO_PORT &&\r\n(mpu_port[dev] & ~0x030) != 0x300) {\r\nsnd_printk(KERN_ERR "incorrect mpu_port specified\n");\r\nreturn 0;\r\n}\r\nif (mpu_irq[dev] != SNDRV_AUTO_DMA &&\r\nmpu_irq[dev] != 2 && mpu_irq[dev] != 3 &&\r\nmpu_irq[dev] != 5 && mpu_irq[dev] != 7) {\r\nsnd_printk(KERN_ERR "mpu_irq must be 2, 3, 5 or 7\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int snd_jazz16_probe(struct device *devptr, unsigned int dev)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_card_jazz16 *jazz16;\r\nstruct snd_sb *chip;\r\nstruct snd_opl3 *opl3;\r\nstatic int possible_irqs[] = {2, 3, 5, 7, 9, 10, 15, -1};\r\nstatic int possible_dmas8[] = {1, 3, -1};\r\nstatic int possible_dmas16[] = {5, 7, -1};\r\nint err, xirq, xdma8, xdma16, xmpu_port, xmpu_irq;\r\nerr = snd_card_new(devptr, index[dev], id[dev], THIS_MODULE,\r\nsizeof(struct snd_card_jazz16), &card);\r\nif (err < 0)\r\nreturn err;\r\njazz16 = card->private_data;\r\nxirq = irq[dev];\r\nif (xirq == SNDRV_AUTO_IRQ) {\r\nxirq = snd_legacy_find_free_irq(possible_irqs);\r\nif (xirq < 0) {\r\nsnd_printk(KERN_ERR "unable to find a free IRQ\n");\r\nerr = -EBUSY;\r\ngoto err_free;\r\n}\r\n}\r\nxdma8 = dma8[dev];\r\nif (xdma8 == SNDRV_AUTO_DMA) {\r\nxdma8 = snd_legacy_find_free_dma(possible_dmas8);\r\nif (xdma8 < 0) {\r\nsnd_printk(KERN_ERR "unable to find a free DMA8\n");\r\nerr = -EBUSY;\r\ngoto err_free;\r\n}\r\n}\r\nxdma16 = dma16[dev];\r\nif (xdma16 == SNDRV_AUTO_DMA) {\r\nxdma16 = snd_legacy_find_free_dma(possible_dmas16);\r\nif (xdma16 < 0) {\r\nsnd_printk(KERN_ERR "unable to find a free DMA16\n");\r\nerr = -EBUSY;\r\ngoto err_free;\r\n}\r\n}\r\nxmpu_port = mpu_port[dev];\r\nif (xmpu_port == SNDRV_AUTO_PORT)\r\nxmpu_port = 0;\r\nerr = jazz16_detect_board(port[dev], xmpu_port);\r\nif (err < 0) {\r\nprintk(KERN_ERR "Media Vision Jazz16 board not detected\n");\r\ngoto err_free;\r\n}\r\nerr = snd_sbdsp_create(card, port[dev], irq[dev],\r\njazz16_interrupt,\r\ndma8[dev], dma16[dev],\r\nSB_HW_JAZZ16,\r\n&chip);\r\nif (err < 0)\r\ngoto err_free;\r\nxmpu_irq = mpu_irq[dev];\r\nif (xmpu_irq == SNDRV_AUTO_IRQ || mpu_port[dev] == SNDRV_AUTO_PORT)\r\nxmpu_irq = 0;\r\nerr = jazz16_configure_board(chip, xmpu_irq);\r\nif (err < 0) {\r\nprintk(KERN_ERR "Media Vision Jazz16 configuration failed\n");\r\ngoto err_free;\r\n}\r\njazz16->chip = chip;\r\nstrcpy(card->driver, "jazz16");\r\nstrcpy(card->shortname, "Media Vision Jazz16");\r\nsprintf(card->longname,\r\n"Media Vision Jazz16 at 0x%lx, irq %d, dma8 %d, dma16 %d",\r\nport[dev], xirq, xdma8, xdma16);\r\nerr = snd_sb8dsp_pcm(chip, 0);\r\nif (err < 0)\r\ngoto err_free;\r\nerr = snd_sbmixer_new(chip);\r\nif (err < 0)\r\ngoto err_free;\r\nerr = snd_opl3_create(card, chip->port, chip->port + 2,\r\nOPL3_HW_AUTO, 1, &opl3);\r\nif (err < 0)\r\nsnd_printk(KERN_WARNING "no OPL device at 0x%lx-0x%lx\n",\r\nchip->port, chip->port + 2);\r\nelse {\r\nerr = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\r\nif (err < 0)\r\ngoto err_free;\r\n}\r\nif (mpu_port[dev] > 0 && mpu_port[dev] != SNDRV_AUTO_PORT) {\r\nif (mpu_irq[dev] == SNDRV_AUTO_IRQ)\r\nmpu_irq[dev] = -1;\r\nif (snd_mpu401_uart_new(card, 0,\r\nMPU401_HW_MPU401,\r\nmpu_port[dev], 0,\r\nmpu_irq[dev],\r\nNULL) < 0)\r\nsnd_printk(KERN_ERR "no MPU-401 device at 0x%lx\n",\r\nmpu_port[dev]);\r\n}\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto err_free;\r\ndev_set_drvdata(devptr, card);\r\nreturn 0;\r\nerr_free:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic int snd_jazz16_remove(struct device *devptr, unsigned int dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(devptr);\r\nsnd_card_free(card);\r\nreturn 0;\r\n}\r\nstatic int snd_jazz16_suspend(struct device *pdev, unsigned int n,\r\npm_message_t state)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(pdev);\r\nstruct snd_card_jazz16 *acard = card->private_data;\r\nstruct snd_sb *chip = acard->chip;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(chip->pcm);\r\nsnd_sbmixer_suspend(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_jazz16_resume(struct device *pdev, unsigned int n)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(pdev);\r\nstruct snd_card_jazz16 *acard = card->private_data;\r\nstruct snd_sb *chip = acard->chip;\r\nsnd_sbdsp_reset(chip);\r\nsnd_sbmixer_resume(chip);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic int __init alsa_card_jazz16_init(void)\r\n{\r\nreturn isa_register_driver(&snd_jazz16_driver, SNDRV_CARDS);\r\n}\r\nstatic void __exit alsa_card_jazz16_exit(void)\r\n{\r\nisa_unregister_driver(&snd_jazz16_driver);\r\n}
