static inline void i2c_set_bit(void __iomem *reg, u32 mask)\r\n{\r\nwritel(readl(reg) | mask, reg);\r\n}\r\nstatic inline void i2c_clr_bit(void __iomem *reg, u32 mask)\r\n{\r\nwritel(readl(reg) & ~mask, reg);\r\n}\r\nstatic int flush_i2c_fifo(struct nmk_i2c_dev *dev)\r\n{\r\n#define LOOP_ATTEMPTS 10\r\nint i;\r\nunsigned long timeout;\r\nwritel((I2C_CR_FTX | I2C_CR_FRX), dev->virtbase + I2C_CR);\r\nfor (i = 0; i < LOOP_ATTEMPTS; i++) {\r\ntimeout = jiffies + dev->adap.timeout;\r\nwhile (!time_after(jiffies, timeout)) {\r\nif ((readl(dev->virtbase + I2C_CR) &\r\n(I2C_CR_FTX | I2C_CR_FRX)) == 0)\r\nreturn 0;\r\n}\r\n}\r\ndev_err(&dev->adev->dev,\r\n"flushing operation timed out giving up after %d attempts",\r\nLOOP_ATTEMPTS);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void disable_all_interrupts(struct nmk_i2c_dev *dev)\r\n{\r\nu32 mask = IRQ_MASK(0);\r\nwritel(mask, dev->virtbase + I2C_IMSCR);\r\n}\r\nstatic void clear_all_interrupts(struct nmk_i2c_dev *dev)\r\n{\r\nu32 mask;\r\nmask = IRQ_MASK(I2C_CLEAR_ALL_INTS);\r\nwritel(mask, dev->virtbase + I2C_ICR);\r\n}\r\nstatic int init_hw(struct nmk_i2c_dev *dev)\r\n{\r\nint stat;\r\nstat = flush_i2c_fifo(dev);\r\nif (stat)\r\ngoto exit;\r\ni2c_clr_bit(dev->virtbase + I2C_CR , I2C_CR_PE);\r\ndisable_all_interrupts(dev);\r\nclear_all_interrupts(dev);\r\ndev->cli.operation = I2C_NO_OPERATION;\r\nexit:\r\nreturn stat;\r\n}\r\nstatic u32 load_i2c_mcr_reg(struct nmk_i2c_dev *dev, u16 flags)\r\n{\r\nu32 mcr = 0;\r\nunsigned short slave_adr_3msb_bits;\r\nmcr |= GEN_MASK(dev->cli.slave_adr, I2C_MCR_A7, 1);\r\nif (unlikely(flags & I2C_M_TEN)) {\r\nmcr |= GEN_MASK(2, I2C_MCR_AM, 12);\r\nslave_adr_3msb_bits = (dev->cli.slave_adr >> 7) & 0x7;\r\nmcr |= GEN_MASK(slave_adr_3msb_bits, I2C_MCR_EA10, 8);\r\n} else {\r\nmcr |= GEN_MASK(1, I2C_MCR_AM, 12);\r\n}\r\nmcr |= GEN_MASK(0, I2C_MCR_SB, 11);\r\nif (dev->cli.operation == I2C_WRITE)\r\nmcr |= GEN_MASK(I2C_WRITE, I2C_MCR_OP, 0);\r\nelse\r\nmcr |= GEN_MASK(I2C_READ, I2C_MCR_OP, 0);\r\nif (dev->stop)\r\nmcr |= GEN_MASK(1, I2C_MCR_STOP, 14);\r\nelse\r\nmcr &= ~(GEN_MASK(1, I2C_MCR_STOP, 14));\r\nmcr |= GEN_MASK(dev->cli.count, I2C_MCR_LENGTH, 15);\r\nreturn mcr;\r\n}\r\nstatic void setup_i2c_controller(struct nmk_i2c_dev *dev)\r\n{\r\nu32 brcr1, brcr2;\r\nu32 i2c_clk, div;\r\nu32 ns;\r\nu16 slsu;\r\nwritel(0x0, dev->virtbase + I2C_CR);\r\nwritel(0x0, dev->virtbase + I2C_HSMCR);\r\nwritel(0x0, dev->virtbase + I2C_TFTR);\r\nwritel(0x0, dev->virtbase + I2C_RFTR);\r\nwritel(0x0, dev->virtbase + I2C_DMAR);\r\ni2c_clk = clk_get_rate(dev->clk);\r\nns = DIV_ROUND_UP_ULL(1000000000ULL, i2c_clk);\r\nswitch (dev->sm) {\r\ncase I2C_FREQ_MODE_FAST:\r\ncase I2C_FREQ_MODE_FAST_PLUS:\r\nslsu = DIV_ROUND_UP(100, ns);\r\nbreak;\r\ncase I2C_FREQ_MODE_HIGH_SPEED:\r\nslsu = DIV_ROUND_UP(10, ns);\r\nbreak;\r\ncase I2C_FREQ_MODE_STANDARD:\r\ndefault:\r\nslsu = DIV_ROUND_UP(250, ns);\r\nbreak;\r\n}\r\nslsu += 1;\r\ndev_dbg(&dev->adev->dev, "calculated SLSU = %04x\n", slsu);\r\nwritel(slsu << 16, dev->virtbase + I2C_SCR);\r\ndiv = (dev->clk_freq > 100000) ? 3 : 2;\r\nbrcr1 = 0 << 16;\r\nbrcr2 = (i2c_clk/(dev->clk_freq * div)) & 0xffff;\r\nwritel((brcr1 | brcr2), dev->virtbase + I2C_BRCR);\r\nif (dev->sm > I2C_FREQ_MODE_FAST) {\r\ndev_err(&dev->adev->dev,\r\n"do not support this mode defaulting to std. mode\n");\r\nbrcr2 = i2c_clk/(100000 * 2) & 0xffff;\r\nwritel((brcr1 | brcr2), dev->virtbase + I2C_BRCR);\r\nwritel(I2C_FREQ_MODE_STANDARD << 4,\r\ndev->virtbase + I2C_CR);\r\n}\r\nwritel(dev->sm << 4, dev->virtbase + I2C_CR);\r\nwritel(dev->tft, dev->virtbase + I2C_TFTR);\r\nwritel(dev->rft, dev->virtbase + I2C_RFTR);\r\n}\r\nstatic int read_i2c(struct nmk_i2c_dev *dev, u16 flags)\r\n{\r\nint status = 0;\r\nu32 mcr, irq_mask;\r\nunsigned long timeout;\r\nmcr = load_i2c_mcr_reg(dev, flags);\r\nwritel(mcr, dev->virtbase + I2C_MCR);\r\nwritel(readl(dev->virtbase + I2C_CR) | DEFAULT_I2C_REG_CR,\r\ndev->virtbase + I2C_CR);\r\ni2c_set_bit(dev->virtbase + I2C_CR, I2C_CR_PE);\r\ninit_completion(&dev->xfer_complete);\r\nirq_mask = (I2C_IT_RXFNF | I2C_IT_RXFF |\r\nI2C_IT_MAL | I2C_IT_BERR);\r\nif (dev->stop || !dev->vendor->has_mtdws)\r\nirq_mask |= I2C_IT_MTD;\r\nelse\r\nirq_mask |= I2C_IT_MTDWS;\r\nirq_mask = I2C_CLEAR_ALL_INTS & IRQ_MASK(irq_mask);\r\nwritel(readl(dev->virtbase + I2C_IMSCR) | irq_mask,\r\ndev->virtbase + I2C_IMSCR);\r\ntimeout = wait_for_completion_timeout(\r\n&dev->xfer_complete, dev->adap.timeout);\r\nif (timeout == 0) {\r\ndev_err(&dev->adev->dev, "read from slave 0x%x timed out\n",\r\ndev->cli.slave_adr);\r\nstatus = -ETIMEDOUT;\r\n}\r\nreturn status;\r\n}\r\nstatic void fill_tx_fifo(struct nmk_i2c_dev *dev, int no_bytes)\r\n{\r\nint count;\r\nfor (count = (no_bytes - 2);\r\n(count > 0) &&\r\n(dev->cli.count != 0);\r\ncount--) {\r\nwriteb(*dev->cli.buffer,\r\ndev->virtbase + I2C_TFR);\r\ndev->cli.buffer++;\r\ndev->cli.count--;\r\ndev->cli.xfer_bytes++;\r\n}\r\n}\r\nstatic int write_i2c(struct nmk_i2c_dev *dev, u16 flags)\r\n{\r\nu32 status = 0;\r\nu32 mcr, irq_mask;\r\nunsigned long timeout;\r\nmcr = load_i2c_mcr_reg(dev, flags);\r\nwritel(mcr, dev->virtbase + I2C_MCR);\r\nwritel(readl(dev->virtbase + I2C_CR) | DEFAULT_I2C_REG_CR,\r\ndev->virtbase + I2C_CR);\r\ni2c_set_bit(dev->virtbase + I2C_CR , I2C_CR_PE);\r\ninit_completion(&dev->xfer_complete);\r\nirq_mask = (I2C_IT_TXFOVR | I2C_IT_MAL | I2C_IT_BERR);\r\nfill_tx_fifo(dev, MAX_I2C_FIFO_THRESHOLD);\r\nif (dev->cli.count != 0)\r\nirq_mask |= I2C_IT_TXFNE;\r\nif (dev->stop || !dev->vendor->has_mtdws)\r\nirq_mask |= I2C_IT_MTD;\r\nelse\r\nirq_mask |= I2C_IT_MTDWS;\r\nirq_mask = I2C_CLEAR_ALL_INTS & IRQ_MASK(irq_mask);\r\nwritel(readl(dev->virtbase + I2C_IMSCR) | irq_mask,\r\ndev->virtbase + I2C_IMSCR);\r\ntimeout = wait_for_completion_timeout(\r\n&dev->xfer_complete, dev->adap.timeout);\r\nif (timeout == 0) {\r\ndev_err(&dev->adev->dev, "write to slave 0x%x timed out\n",\r\ndev->cli.slave_adr);\r\nstatus = -ETIMEDOUT;\r\n}\r\nreturn status;\r\n}\r\nstatic int nmk_i2c_xfer_one(struct nmk_i2c_dev *dev, u16 flags)\r\n{\r\nint status;\r\nif (flags & I2C_M_RD) {\r\ndev->cli.operation = I2C_READ;\r\nstatus = read_i2c(dev, flags);\r\n} else {\r\ndev->cli.operation = I2C_WRITE;\r\nstatus = write_i2c(dev, flags);\r\n}\r\nif (status || (dev->result)) {\r\nu32 i2c_sr;\r\nu32 cause;\r\ni2c_sr = readl(dev->virtbase + I2C_SR);\r\nif (((i2c_sr >> 2) & 0x3) == 0x3) {\r\ncause = (i2c_sr >> 4) & 0x7;\r\ndev_err(&dev->adev->dev, "%s\n",\r\ncause >= ARRAY_SIZE(abort_causes) ?\r\n"unknown reason" :\r\nabort_causes[cause]);\r\n}\r\n(void) init_hw(dev);\r\nstatus = status ? status : dev->result;\r\n}\r\nreturn status;\r\n}\r\nstatic int nmk_i2c_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msgs[], int num_msgs)\r\n{\r\nint status = 0;\r\nint i;\r\nstruct nmk_i2c_dev *dev = i2c_get_adapdata(i2c_adap);\r\nint j;\r\npm_runtime_get_sync(&dev->adev->dev);\r\nfor (j = 0; j < 3; j++) {\r\nsetup_i2c_controller(dev);\r\nfor (i = 0; i < num_msgs; i++) {\r\ndev->cli.slave_adr = msgs[i].addr;\r\ndev->cli.buffer = msgs[i].buf;\r\ndev->cli.count = msgs[i].len;\r\ndev->stop = (i < (num_msgs - 1)) ? 0 : 1;\r\ndev->result = 0;\r\nstatus = nmk_i2c_xfer_one(dev, msgs[i].flags);\r\nif (status != 0)\r\nbreak;\r\n}\r\nif (status == 0)\r\nbreak;\r\n}\r\npm_runtime_put_sync(&dev->adev->dev);\r\nif (status)\r\nreturn status;\r\nelse\r\nreturn num_msgs;\r\n}\r\nstatic int disable_interrupts(struct nmk_i2c_dev *dev, u32 irq)\r\n{\r\nirq = IRQ_MASK(irq);\r\nwritel(readl(dev->virtbase + I2C_IMSCR) & ~(I2C_CLEAR_ALL_INTS & irq),\r\ndev->virtbase + I2C_IMSCR);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t i2c_irq_handler(int irq, void *arg)\r\n{\r\nstruct nmk_i2c_dev *dev = arg;\r\nu32 tft, rft;\r\nu32 count;\r\nu32 misr, src;\r\ntft = readl(dev->virtbase + I2C_TFTR);\r\nrft = readl(dev->virtbase + I2C_RFTR);\r\nmisr = readl(dev->virtbase + I2C_MISR);\r\nsrc = __ffs(misr);\r\nswitch ((1 << src)) {\r\ncase I2C_IT_TXFNE:\r\n{\r\nif (dev->cli.operation == I2C_READ) {\r\ndisable_interrupts(dev, I2C_IT_TXFNE);\r\n} else {\r\nfill_tx_fifo(dev, (MAX_I2C_FIFO_THRESHOLD - tft));\r\nif (dev->cli.count == 0)\r\ndisable_interrupts(dev, I2C_IT_TXFNE);\r\n}\r\n}\r\nbreak;\r\ncase I2C_IT_RXFNF:\r\nfor (count = rft; count > 0; count--) {\r\n*dev->cli.buffer = readb(dev->virtbase + I2C_RFR);\r\ndev->cli.buffer++;\r\n}\r\ndev->cli.count -= rft;\r\ndev->cli.xfer_bytes += rft;\r\nbreak;\r\ncase I2C_IT_RXFF:\r\nfor (count = MAX_I2C_FIFO_THRESHOLD; count > 0; count--) {\r\n*dev->cli.buffer = readb(dev->virtbase + I2C_RFR);\r\ndev->cli.buffer++;\r\n}\r\ndev->cli.count -= MAX_I2C_FIFO_THRESHOLD;\r\ndev->cli.xfer_bytes += MAX_I2C_FIFO_THRESHOLD;\r\nbreak;\r\ncase I2C_IT_MTD:\r\ncase I2C_IT_MTDWS:\r\nif (dev->cli.operation == I2C_READ) {\r\nwhile (!(readl(dev->virtbase + I2C_RISR)\r\n& I2C_IT_RXFE)) {\r\nif (dev->cli.count == 0)\r\nbreak;\r\n*dev->cli.buffer =\r\nreadb(dev->virtbase + I2C_RFR);\r\ndev->cli.buffer++;\r\ndev->cli.count--;\r\ndev->cli.xfer_bytes++;\r\n}\r\n}\r\ndisable_all_interrupts(dev);\r\nclear_all_interrupts(dev);\r\nif (dev->cli.count) {\r\ndev->result = -EIO;\r\ndev_err(&dev->adev->dev,\r\n"%lu bytes still remain to be xfered\n",\r\ndev->cli.count);\r\n(void) init_hw(dev);\r\n}\r\ncomplete(&dev->xfer_complete);\r\nbreak;\r\ncase I2C_IT_MAL:\r\ndev->result = -EIO;\r\n(void) init_hw(dev);\r\ni2c_set_bit(dev->virtbase + I2C_ICR, I2C_IT_MAL);\r\ncomplete(&dev->xfer_complete);\r\nbreak;\r\ncase I2C_IT_BERR:\r\ndev->result = -EIO;\r\nif (((readl(dev->virtbase + I2C_SR) >> 2) & 0x3) == I2C_ABORT)\r\n(void) init_hw(dev);\r\ni2c_set_bit(dev->virtbase + I2C_ICR, I2C_IT_BERR);\r\ncomplete(&dev->xfer_complete);\r\nbreak;\r\ncase I2C_IT_TXFOVR:\r\ndev->result = -EIO;\r\n(void) init_hw(dev);\r\ndev_err(&dev->adev->dev, "Tx Fifo Over run\n");\r\ncomplete(&dev->xfer_complete);\r\nbreak;\r\ncase I2C_IT_TXFE:\r\ncase I2C_IT_TXFF:\r\ncase I2C_IT_RXFE:\r\ncase I2C_IT_RFSR:\r\ncase I2C_IT_RFSE:\r\ncase I2C_IT_WTSR:\r\ncase I2C_IT_STD:\r\ndev_err(&dev->adev->dev, "unhandled Interrupt\n");\r\nbreak;\r\ndefault:\r\ndev_err(&dev->adev->dev, "spurious Interrupt..\n");\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int nmk_i2c_suspend_late(struct device *dev)\r\n{\r\nint ret;\r\nret = pm_runtime_force_suspend(dev);\r\nif (ret)\r\nreturn ret;\r\npinctrl_pm_select_sleep_state(dev);\r\nreturn 0;\r\n}\r\nstatic int nmk_i2c_resume_early(struct device *dev)\r\n{\r\nreturn pm_runtime_force_resume(dev);\r\n}\r\nstatic int nmk_i2c_runtime_suspend(struct device *dev)\r\n{\r\nstruct amba_device *adev = to_amba_device(dev);\r\nstruct nmk_i2c_dev *nmk_i2c = amba_get_drvdata(adev);\r\nclk_disable_unprepare(nmk_i2c->clk);\r\npinctrl_pm_select_idle_state(dev);\r\nreturn 0;\r\n}\r\nstatic int nmk_i2c_runtime_resume(struct device *dev)\r\n{\r\nstruct amba_device *adev = to_amba_device(dev);\r\nstruct nmk_i2c_dev *nmk_i2c = amba_get_drvdata(adev);\r\nint ret;\r\nret = clk_prepare_enable(nmk_i2c->clk);\r\nif (ret) {\r\ndev_err(dev, "can't prepare_enable clock\n");\r\nreturn ret;\r\n}\r\npinctrl_pm_select_default_state(dev);\r\nret = init_hw(nmk_i2c);\r\nif (ret) {\r\nclk_disable_unprepare(nmk_i2c->clk);\r\npinctrl_pm_select_idle_state(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int nmk_i2c_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR;\r\n}\r\nstatic void nmk_i2c_of_probe(struct device_node *np,\r\nstruct nmk_i2c_dev *nmk)\r\n{\r\nif (of_property_read_u32(np, "clock-frequency", &nmk->clk_freq))\r\nnmk->clk_freq = 100000;\r\nif (nmk->clk_freq <= 100000)\r\nnmk->sm = I2C_FREQ_MODE_STANDARD;\r\nelse\r\nnmk->sm = I2C_FREQ_MODE_FAST;\r\nnmk->tft = 1;\r\nnmk->rft = 8;\r\nnmk->timeout = 200;\r\n}\r\nstatic int nmk_i2c_probe(struct amba_device *adev, const struct amba_id *id)\r\n{\r\nint ret = 0;\r\nstruct device_node *np = adev->dev.of_node;\r\nstruct nmk_i2c_dev *dev;\r\nstruct i2c_adapter *adap;\r\nstruct i2c_vendor_data *vendor = id->data;\r\nu32 max_fifo_threshold = (vendor->fifodepth / 2) - 1;\r\ndev = devm_kzalloc(&adev->dev, sizeof(struct nmk_i2c_dev), GFP_KERNEL);\r\nif (!dev) {\r\ndev_err(&adev->dev, "cannot allocate memory\n");\r\nret = -ENOMEM;\r\ngoto err_no_mem;\r\n}\r\ndev->vendor = vendor;\r\ndev->adev = adev;\r\nnmk_i2c_of_probe(np, dev);\r\nif (dev->tft > max_fifo_threshold) {\r\ndev_warn(&adev->dev, "requested TX FIFO threshold %u, adjusted down to %u\n",\r\ndev->tft, max_fifo_threshold);\r\ndev->tft = max_fifo_threshold;\r\n}\r\nif (dev->rft > max_fifo_threshold) {\r\ndev_warn(&adev->dev, "requested RX FIFO threshold %u, adjusted down to %u\n",\r\ndev->rft, max_fifo_threshold);\r\ndev->rft = max_fifo_threshold;\r\n}\r\namba_set_drvdata(adev, dev);\r\ndev->virtbase = devm_ioremap(&adev->dev, adev->res.start,\r\nresource_size(&adev->res));\r\nif (!dev->virtbase) {\r\nret = -ENOMEM;\r\ngoto err_no_mem;\r\n}\r\ndev->irq = adev->irq[0];\r\nret = devm_request_irq(&adev->dev, dev->irq, i2c_irq_handler, 0,\r\nDRIVER_NAME, dev);\r\nif (ret) {\r\ndev_err(&adev->dev, "cannot claim the irq %d\n", dev->irq);\r\ngoto err_no_mem;\r\n}\r\npm_suspend_ignore_children(&adev->dev, true);\r\ndev->clk = devm_clk_get(&adev->dev, NULL);\r\nif (IS_ERR(dev->clk)) {\r\ndev_err(&adev->dev, "could not get i2c clock\n");\r\nret = PTR_ERR(dev->clk);\r\ngoto err_no_mem;\r\n}\r\nret = clk_prepare_enable(dev->clk);\r\nif (ret) {\r\ndev_err(&adev->dev, "can't prepare_enable clock\n");\r\ngoto err_no_mem;\r\n}\r\ninit_hw(dev);\r\nadap = &dev->adap;\r\nadap->dev.of_node = np;\r\nadap->dev.parent = &adev->dev;\r\nadap->owner = THIS_MODULE;\r\nadap->class = I2C_CLASS_DEPRECATED;\r\nadap->algo = &nmk_i2c_algo;\r\nadap->timeout = msecs_to_jiffies(dev->timeout);\r\nsnprintf(adap->name, sizeof(adap->name),\r\n"Nomadik I2C at %pR", &adev->res);\r\ni2c_set_adapdata(adap, dev);\r\ndev_info(&adev->dev,\r\n"initialize %s on virtual base %p\n",\r\nadap->name, dev->virtbase);\r\nret = i2c_add_adapter(adap);\r\nif (ret) {\r\ndev_err(&adev->dev, "failed to add adapter\n");\r\ngoto err_no_adap;\r\n}\r\npm_runtime_put(&adev->dev);\r\nreturn 0;\r\nerr_no_adap:\r\nclk_disable_unprepare(dev->clk);\r\nerr_no_mem:\r\nreturn ret;\r\n}\r\nstatic int nmk_i2c_remove(struct amba_device *adev)\r\n{\r\nstruct resource *res = &adev->res;\r\nstruct nmk_i2c_dev *dev = amba_get_drvdata(adev);\r\ni2c_del_adapter(&dev->adap);\r\nflush_i2c_fifo(dev);\r\ndisable_all_interrupts(dev);\r\nclear_all_interrupts(dev);\r\ni2c_clr_bit(dev->virtbase + I2C_CR, I2C_CR_PE);\r\nclk_disable_unprepare(dev->clk);\r\nif (res)\r\nrelease_mem_region(res->start, resource_size(res));\r\nreturn 0;\r\n}\r\nstatic int __init nmk_i2c_init(void)\r\n{\r\nreturn amba_driver_register(&nmk_i2c_driver);\r\n}\r\nstatic void __exit nmk_i2c_exit(void)\r\n{\r\namba_driver_unregister(&nmk_i2c_driver);\r\n}
