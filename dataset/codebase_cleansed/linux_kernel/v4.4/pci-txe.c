static inline void mei_txe_set_pm_domain(struct mei_device *dev) {}\r\nstatic inline void mei_txe_unset_pm_domain(struct mei_device *dev) {}\r\nstatic void mei_txe_pci_iounmap(struct pci_dev *pdev, struct mei_txe_hw *hw)\r\n{\r\nint i;\r\nfor (i = SEC_BAR; i < NUM_OF_MEM_BARS; i++) {\r\nif (hw->mem_addr[i]) {\r\npci_iounmap(pdev, hw->mem_addr[i]);\r\nhw->mem_addr[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic int mei_txe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct mei_device *dev;\r\nstruct mei_txe_hw *hw;\r\nint err;\r\nint i;\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to enable pci device.\n");\r\ngoto end;\r\n}\r\npci_set_master(pdev);\r\nerr = pci_request_regions(pdev, KBUILD_MODNAME);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to get pci regions.\n");\r\ngoto disable_device;\r\n}\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(36));\r\nif (err) {\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (err) {\r\ndev_err(&pdev->dev, "No suitable DMA available.\n");\r\ngoto release_regions;\r\n}\r\n}\r\ndev = mei_txe_dev_init(pdev);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto release_regions;\r\n}\r\nhw = to_txe_hw(dev);\r\nfor (i = SEC_BAR; i < NUM_OF_MEM_BARS; i++) {\r\nhw->mem_addr[i] = pci_iomap(pdev, i, 0);\r\nif (!hw->mem_addr[i]) {\r\ndev_err(&pdev->dev, "mapping I/O device memory failure.\n");\r\nerr = -ENOMEM;\r\ngoto free_device;\r\n}\r\n}\r\npci_enable_msi(pdev);\r\nmei_clear_interrupts(dev);\r\nif (pci_dev_msi_enabled(pdev))\r\nerr = request_threaded_irq(pdev->irq,\r\nNULL,\r\nmei_txe_irq_thread_handler,\r\nIRQF_ONESHOT, KBUILD_MODNAME, dev);\r\nelse\r\nerr = request_threaded_irq(pdev->irq,\r\nmei_txe_irq_quick_handler,\r\nmei_txe_irq_thread_handler,\r\nIRQF_SHARED, KBUILD_MODNAME, dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "mei: request_threaded_irq failure. irq = %d\n",\r\npdev->irq);\r\ngoto free_device;\r\n}\r\nif (mei_start(dev)) {\r\ndev_err(&pdev->dev, "init hw failure.\n");\r\nerr = -ENODEV;\r\ngoto release_irq;\r\n}\r\npm_runtime_set_autosuspend_delay(&pdev->dev, MEI_TXI_RPM_TIMEOUT);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\nerr = mei_register(dev, &pdev->dev);\r\nif (err)\r\ngoto release_irq;\r\npci_set_drvdata(pdev, dev);\r\nif (!pci_dev_run_wake(pdev))\r\nmei_txe_set_pm_domain(dev);\r\npm_runtime_put_noidle(&pdev->dev);\r\nreturn 0;\r\nrelease_irq:\r\nmei_cancel_work(dev);\r\nmei_disable_interrupts(dev);\r\nfree_irq(pdev->irq, dev);\r\npci_disable_msi(pdev);\r\nfree_device:\r\nmei_txe_pci_iounmap(pdev, hw);\r\nkfree(dev);\r\nrelease_regions:\r\npci_release_regions(pdev);\r\ndisable_device:\r\npci_disable_device(pdev);\r\nend:\r\ndev_err(&pdev->dev, "initialization failed.\n");\r\nreturn err;\r\n}\r\nstatic void mei_txe_remove(struct pci_dev *pdev)\r\n{\r\nstruct mei_device *dev;\r\nstruct mei_txe_hw *hw;\r\ndev = pci_get_drvdata(pdev);\r\nif (!dev) {\r\ndev_err(&pdev->dev, "mei: dev =NULL\n");\r\nreturn;\r\n}\r\npm_runtime_get_noresume(&pdev->dev);\r\nhw = to_txe_hw(dev);\r\nmei_stop(dev);\r\nif (!pci_dev_run_wake(pdev))\r\nmei_txe_unset_pm_domain(dev);\r\nmei_disable_interrupts(dev);\r\nfree_irq(pdev->irq, dev);\r\npci_disable_msi(pdev);\r\npci_set_drvdata(pdev, NULL);\r\nmei_txe_pci_iounmap(pdev, hw);\r\nmei_deregister(dev);\r\nkfree(dev);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int mei_txe_pci_suspend(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct mei_device *dev = pci_get_drvdata(pdev);\r\nif (!dev)\r\nreturn -ENODEV;\r\ndev_dbg(&pdev->dev, "suspend\n");\r\nmei_stop(dev);\r\nmei_disable_interrupts(dev);\r\nfree_irq(pdev->irq, dev);\r\npci_disable_msi(pdev);\r\nreturn 0;\r\n}\r\nstatic int mei_txe_pci_resume(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct mei_device *dev;\r\nint err;\r\ndev = pci_get_drvdata(pdev);\r\nif (!dev)\r\nreturn -ENODEV;\r\npci_enable_msi(pdev);\r\nmei_clear_interrupts(dev);\r\nif (pci_dev_msi_enabled(pdev))\r\nerr = request_threaded_irq(pdev->irq,\r\nNULL,\r\nmei_txe_irq_thread_handler,\r\nIRQF_ONESHOT, KBUILD_MODNAME, dev);\r\nelse\r\nerr = request_threaded_irq(pdev->irq,\r\nmei_txe_irq_quick_handler,\r\nmei_txe_irq_thread_handler,\r\nIRQF_SHARED, KBUILD_MODNAME, dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "request_threaded_irq failed: irq = %d.\n",\r\npdev->irq);\r\nreturn err;\r\n}\r\nerr = mei_restart(dev);\r\nreturn err;\r\n}\r\nstatic int mei_txe_pm_runtime_idle(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct mei_device *dev;\r\ndev_dbg(&pdev->dev, "rpm: txe: runtime_idle\n");\r\ndev = pci_get_drvdata(pdev);\r\nif (!dev)\r\nreturn -ENODEV;\r\nif (mei_write_is_idle(dev))\r\npm_runtime_autosuspend(device);\r\nreturn -EBUSY;\r\n}\r\nstatic int mei_txe_pm_runtime_suspend(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct mei_device *dev;\r\nint ret;\r\ndev_dbg(&pdev->dev, "rpm: txe: runtime suspend\n");\r\ndev = pci_get_drvdata(pdev);\r\nif (!dev)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->device_lock);\r\nif (mei_write_is_idle(dev))\r\nret = mei_txe_aliveness_set_sync(dev, 0);\r\nelse\r\nret = -EAGAIN;\r\nif (!ret && pci_dev_run_wake(pdev))\r\nmei_disable_interrupts(dev);\r\ndev_dbg(&pdev->dev, "rpm: txe: runtime suspend ret=%d\n", ret);\r\nmutex_unlock(&dev->device_lock);\r\nreturn ret;\r\n}\r\nstatic int mei_txe_pm_runtime_resume(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct mei_device *dev;\r\nint ret;\r\ndev_dbg(&pdev->dev, "rpm: txe: runtime resume\n");\r\ndev = pci_get_drvdata(pdev);\r\nif (!dev)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->device_lock);\r\nmei_enable_interrupts(dev);\r\nret = mei_txe_aliveness_set_sync(dev, 1);\r\nmutex_unlock(&dev->device_lock);\r\ndev_dbg(&pdev->dev, "rpm: txe: runtime resume ret = %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic inline void mei_txe_set_pm_domain(struct mei_device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev->dev);\r\nif (pdev->dev.bus && pdev->dev.bus->pm) {\r\ndev->pg_domain.ops = *pdev->dev.bus->pm;\r\ndev->pg_domain.ops.runtime_suspend = mei_txe_pm_runtime_suspend;\r\ndev->pg_domain.ops.runtime_resume = mei_txe_pm_runtime_resume;\r\ndev->pg_domain.ops.runtime_idle = mei_txe_pm_runtime_idle;\r\npdev->dev.pm_domain = &dev->pg_domain;\r\n}\r\n}\r\nstatic inline void mei_txe_unset_pm_domain(struct mei_device *dev)\r\n{\r\ndev->dev->pm_domain = NULL;\r\n}
