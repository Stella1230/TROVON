static u32 htohl(u32 in, int swap)\r\n{\r\nreturn swap ? swab32(in) : in;\r\n}\r\nstatic void tipc_subscrp_send_event(struct tipc_subscription *sub,\r\nu32 found_lower, u32 found_upper,\r\nu32 event, u32 port_ref, u32 node)\r\n{\r\nstruct tipc_net *tn = net_generic(sub->net, tipc_net_id);\r\nstruct tipc_subscriber *subscriber = sub->subscriber;\r\nstruct kvec msg_sect;\r\nmsg_sect.iov_base = (void *)&sub->evt;\r\nmsg_sect.iov_len = sizeof(struct tipc_event);\r\nsub->evt.event = htohl(event, sub->swap);\r\nsub->evt.found_lower = htohl(found_lower, sub->swap);\r\nsub->evt.found_upper = htohl(found_upper, sub->swap);\r\nsub->evt.port.ref = htohl(port_ref, sub->swap);\r\nsub->evt.port.node = htohl(node, sub->swap);\r\ntipc_conn_sendmsg(tn->topsrv, subscriber->conid, NULL,\r\nmsg_sect.iov_base, msg_sect.iov_len);\r\n}\r\nint tipc_subscrp_check_overlap(struct tipc_subscription *sub, u32 found_lower,\r\nu32 found_upper)\r\n{\r\nif (found_lower < sub->seq.lower)\r\nfound_lower = sub->seq.lower;\r\nif (found_upper > sub->seq.upper)\r\nfound_upper = sub->seq.upper;\r\nif (found_lower > found_upper)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid tipc_subscrp_report_overlap(struct tipc_subscription *sub, u32 found_lower,\r\nu32 found_upper, u32 event, u32 port_ref,\r\nu32 node, int must)\r\n{\r\nif (!tipc_subscrp_check_overlap(sub, found_lower, found_upper))\r\nreturn;\r\nif (!must && !(sub->filter & TIPC_SUB_PORTS))\r\nreturn;\r\ntipc_subscrp_send_event(sub, found_lower, found_upper, event, port_ref,\r\nnode);\r\n}\r\nstatic void tipc_subscrp_timeout(unsigned long data)\r\n{\r\nstruct tipc_subscription *sub = (struct tipc_subscription *)data;\r\nstruct tipc_subscriber *subscriber = sub->subscriber;\r\ntipc_subscrp_send_event(sub, sub->evt.s.seq.lower, sub->evt.s.seq.upper,\r\nTIPC_SUBSCR_TIMEOUT, 0, 0);\r\nspin_lock_bh(&subscriber->lock);\r\ntipc_subscrp_delete(sub);\r\nspin_unlock_bh(&subscriber->lock);\r\ntipc_subscrb_put(subscriber);\r\n}\r\nstatic void tipc_subscrb_kref_release(struct kref *kref)\r\n{\r\nstruct tipc_subscriber *subcriber = container_of(kref,\r\nstruct tipc_subscriber, kref);\r\nkfree(subcriber);\r\n}\r\nstatic void tipc_subscrb_put(struct tipc_subscriber *subscriber)\r\n{\r\nkref_put(&subscriber->kref, tipc_subscrb_kref_release);\r\n}\r\nstatic void tipc_subscrb_get(struct tipc_subscriber *subscriber)\r\n{\r\nkref_get(&subscriber->kref);\r\n}\r\nstatic struct tipc_subscriber *tipc_subscrb_create(int conid)\r\n{\r\nstruct tipc_subscriber *subscriber;\r\nsubscriber = kzalloc(sizeof(*subscriber), GFP_ATOMIC);\r\nif (!subscriber) {\r\npr_warn("Subscriber rejected, no memory\n");\r\nreturn NULL;\r\n}\r\nkref_init(&subscriber->kref);\r\nINIT_LIST_HEAD(&subscriber->subscrp_list);\r\nsubscriber->conid = conid;\r\nspin_lock_init(&subscriber->lock);\r\nreturn subscriber;\r\n}\r\nstatic void tipc_subscrb_delete(struct tipc_subscriber *subscriber)\r\n{\r\nstruct tipc_subscription *sub, *temp;\r\nspin_lock_bh(&subscriber->lock);\r\nlist_for_each_entry_safe(sub, temp, &subscriber->subscrp_list,\r\nsubscrp_list) {\r\nif (del_timer(&sub->timer)) {\r\ntipc_subscrp_delete(sub);\r\ntipc_subscrb_put(subscriber);\r\n}\r\n}\r\nspin_unlock_bh(&subscriber->lock);\r\ntipc_subscrb_put(subscriber);\r\n}\r\nstatic void tipc_subscrp_delete(struct tipc_subscription *sub)\r\n{\r\nstruct tipc_net *tn = net_generic(sub->net, tipc_net_id);\r\ntipc_nametbl_unsubscribe(sub);\r\nlist_del(&sub->subscrp_list);\r\nkfree(sub);\r\natomic_dec(&tn->subscription_count);\r\n}\r\nstatic void tipc_subscrp_cancel(struct tipc_subscr *s,\r\nstruct tipc_subscriber *subscriber)\r\n{\r\nstruct tipc_subscription *sub, *temp;\r\nspin_lock_bh(&subscriber->lock);\r\nlist_for_each_entry_safe(sub, temp, &subscriber->subscrp_list,\r\nsubscrp_list) {\r\nif (!memcmp(s, &sub->evt.s, sizeof(struct tipc_subscr))) {\r\nif (del_timer(&sub->timer)) {\r\ntipc_subscrp_delete(sub);\r\ntipc_subscrb_put(subscriber);\r\n}\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&subscriber->lock);\r\n}\r\nstatic int tipc_subscrp_create(struct net *net, struct tipc_subscr *s,\r\nstruct tipc_subscriber *subscriber,\r\nstruct tipc_subscription **sub_p)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct tipc_subscription *sub;\r\nint swap;\r\nswap = !(s->filter & (TIPC_SUB_PORTS | TIPC_SUB_SERVICE));\r\nif (s->filter & htohl(TIPC_SUB_CANCEL, swap)) {\r\ns->filter &= ~htohl(TIPC_SUB_CANCEL, swap);\r\ntipc_subscrp_cancel(s, subscriber);\r\nreturn 0;\r\n}\r\nif (atomic_read(&tn->subscription_count) >= TIPC_MAX_SUBSCRIPTIONS) {\r\npr_warn("Subscription rejected, limit reached (%u)\n",\r\nTIPC_MAX_SUBSCRIPTIONS);\r\nreturn -EINVAL;\r\n}\r\nsub = kmalloc(sizeof(*sub), GFP_ATOMIC);\r\nif (!sub) {\r\npr_warn("Subscription rejected, no memory\n");\r\nreturn -ENOMEM;\r\n}\r\nsub->net = net;\r\nsub->seq.type = htohl(s->seq.type, swap);\r\nsub->seq.lower = htohl(s->seq.lower, swap);\r\nsub->seq.upper = htohl(s->seq.upper, swap);\r\nsub->timeout = msecs_to_jiffies(htohl(s->timeout, swap));\r\nsub->filter = htohl(s->filter, swap);\r\nif ((!(sub->filter & TIPC_SUB_PORTS) ==\r\n!(sub->filter & TIPC_SUB_SERVICE)) ||\r\n(sub->seq.lower > sub->seq.upper)) {\r\npr_warn("Subscription rejected, illegal request\n");\r\nkfree(sub);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_bh(&subscriber->lock);\r\nlist_add(&sub->subscrp_list, &subscriber->subscrp_list);\r\nspin_unlock_bh(&subscriber->lock);\r\nsub->subscriber = subscriber;\r\nsub->swap = swap;\r\nmemcpy(&sub->evt.s, s, sizeof(*s));\r\natomic_inc(&tn->subscription_count);\r\nsetup_timer(&sub->timer, tipc_subscrp_timeout, (unsigned long)sub);\r\nif (sub->timeout != TIPC_WAIT_FOREVER)\r\nsub->timeout += jiffies;\r\nif (!mod_timer(&sub->timer, sub->timeout))\r\ntipc_subscrb_get(subscriber);\r\n*sub_p = sub;\r\nreturn 0;\r\n}\r\nstatic void tipc_subscrb_shutdown_cb(int conid, void *usr_data)\r\n{\r\ntipc_subscrb_delete((struct tipc_subscriber *)usr_data);\r\n}\r\nstatic void tipc_subscrb_rcv_cb(struct net *net, int conid,\r\nstruct sockaddr_tipc *addr, void *usr_data,\r\nvoid *buf, size_t len)\r\n{\r\nstruct tipc_subscriber *subscriber = usr_data;\r\nstruct tipc_subscription *sub = NULL;\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\ntipc_subscrp_create(net, (struct tipc_subscr *)buf, subscriber, &sub);\r\nif (sub)\r\ntipc_nametbl_subscribe(sub);\r\nelse\r\ntipc_conn_terminate(tn->topsrv, subscriber->conid);\r\n}\r\nstatic void *tipc_subscrb_connect_cb(int conid)\r\n{\r\nreturn (void *)tipc_subscrb_create(conid);\r\n}\r\nint tipc_topsrv_start(struct net *net)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nconst char name[] = "topology_server";\r\nstruct tipc_server *topsrv;\r\nstruct sockaddr_tipc *saddr;\r\nsaddr = kzalloc(sizeof(*saddr), GFP_ATOMIC);\r\nif (!saddr)\r\nreturn -ENOMEM;\r\nsaddr->family = AF_TIPC;\r\nsaddr->addrtype = TIPC_ADDR_NAMESEQ;\r\nsaddr->addr.nameseq.type = TIPC_TOP_SRV;\r\nsaddr->addr.nameseq.lower = TIPC_TOP_SRV;\r\nsaddr->addr.nameseq.upper = TIPC_TOP_SRV;\r\nsaddr->scope = TIPC_NODE_SCOPE;\r\ntopsrv = kzalloc(sizeof(*topsrv), GFP_ATOMIC);\r\nif (!topsrv) {\r\nkfree(saddr);\r\nreturn -ENOMEM;\r\n}\r\ntopsrv->net = net;\r\ntopsrv->saddr = saddr;\r\ntopsrv->imp = TIPC_CRITICAL_IMPORTANCE;\r\ntopsrv->type = SOCK_SEQPACKET;\r\ntopsrv->max_rcvbuf_size = sizeof(struct tipc_subscr);\r\ntopsrv->tipc_conn_recvmsg = tipc_subscrb_rcv_cb;\r\ntopsrv->tipc_conn_new = tipc_subscrb_connect_cb;\r\ntopsrv->tipc_conn_shutdown = tipc_subscrb_shutdown_cb;\r\nstrncpy(topsrv->name, name, strlen(name) + 1);\r\ntn->topsrv = topsrv;\r\natomic_set(&tn->subscription_count, 0);\r\nreturn tipc_server_start(topsrv);\r\n}\r\nvoid tipc_topsrv_stop(struct net *net)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct tipc_server *topsrv = tn->topsrv;\r\ntipc_server_stop(topsrv);\r\nkfree(topsrv->saddr);\r\nkfree(topsrv);\r\n}
