static void palmas_power_button_work(struct work_struct *work)\r\n{\r\nstruct palmas_pwron *pwron = container_of(work,\r\nstruct palmas_pwron,\r\ninput_work.work);\r\nstruct input_dev *input_dev = pwron->input_dev;\r\nunsigned int reg;\r\nint error;\r\nerror = palmas_read(pwron->palmas, PALMAS_INTERRUPT_BASE,\r\nPALMAS_INT1_LINE_STATE, &reg);\r\nif (error) {\r\ndev_err(input_dev->dev.parent,\r\n"Cannot read palmas PWRON status: %d\n", error);\r\n} else if (reg & BIT(1)) {\r\ninput_report_key(input_dev, KEY_POWER, 0);\r\ninput_sync(input_dev);\r\n} else {\r\nschedule_delayed_work(&pwron->input_work,\r\nmsecs_to_jiffies(PALMAS_PWR_KEY_Q_TIME_MS));\r\n}\r\n}\r\nstatic irqreturn_t pwron_irq(int irq, void *palmas_pwron)\r\n{\r\nstruct palmas_pwron *pwron = palmas_pwron;\r\nstruct input_dev *input_dev = pwron->input_dev;\r\ninput_report_key(input_dev, KEY_POWER, 1);\r\npm_wakeup_event(input_dev->dev.parent, 0);\r\ninput_sync(input_dev);\r\nmod_delayed_work(system_wq, &pwron->input_work,\r\nmsecs_to_jiffies(PALMAS_PWR_KEY_Q_TIME_MS));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void palmas_pwron_params_ofinit(struct device *dev,\r\nstruct palmas_pwron_config *config)\r\n{\r\nstruct device_node *np;\r\nu32 val;\r\nint i, error;\r\nu8 lpk_times[] = { 6, 8, 10, 12 };\r\nint pwr_on_deb_ms[] = { 15, 100, 500, 1000 };\r\nmemset(config, 0, sizeof(*config));\r\nconfig->long_press_time_val = ARRAY_SIZE(lpk_times) - 1;\r\nnp = dev->of_node;\r\nif (!np)\r\nreturn;\r\nerror = of_property_read_u32(np, "ti,palmas-long-press-seconds", &val);\r\nif (!error) {\r\nfor (i = 0; i < ARRAY_SIZE(lpk_times); i++) {\r\nif (val <= lpk_times[i]) {\r\nconfig->long_press_time_val = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nerror = of_property_read_u32(np,\r\n"ti,palmas-pwron-debounce-milli-seconds",\r\n&val);\r\nif (!error) {\r\nfor (i = 0; i < ARRAY_SIZE(pwr_on_deb_ms); i++) {\r\nif (val <= pwr_on_deb_ms[i]) {\r\nconfig->pwron_debounce_val = i;\r\nbreak;\r\n}\r\n}\r\n}\r\ndev_info(dev, "h/w controlled shutdown duration=%d seconds\n",\r\nlpk_times[config->long_press_time_val]);\r\n}\r\nstatic int palmas_pwron_probe(struct platform_device *pdev)\r\n{\r\nstruct palmas *palmas = dev_get_drvdata(pdev->dev.parent);\r\nstruct device *dev = &pdev->dev;\r\nstruct input_dev *input_dev;\r\nstruct palmas_pwron *pwron;\r\nstruct palmas_pwron_config config;\r\nint val;\r\nint error;\r\npalmas_pwron_params_ofinit(dev, &config);\r\npwron = kzalloc(sizeof(*pwron), GFP_KERNEL);\r\nif (!pwron)\r\nreturn -ENOMEM;\r\ninput_dev = input_allocate_device();\r\nif (!input_dev) {\r\ndev_err(dev, "Can't allocate power button\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\ninput_dev->name = "palmas_pwron";\r\ninput_dev->phys = "palmas_pwron/input0";\r\ninput_dev->dev.parent = dev;\r\ninput_set_capability(input_dev, EV_KEY, KEY_POWER);\r\nval = config.long_press_time_val << __ffs(PALMAS_LPK_TIME_MASK);\r\nval |= config.pwron_debounce_val << __ffs(PALMAS_PWRON_DEBOUNCE_MASK);\r\nerror = palmas_update_bits(palmas, PALMAS_PMU_CONTROL_BASE,\r\nPALMAS_LONG_PRESS_KEY,\r\nPALMAS_LPK_TIME_MASK |\r\nPALMAS_PWRON_DEBOUNCE_MASK,\r\nval);\r\nif (error) {\r\ndev_err(dev, "LONG_PRESS_KEY_UPDATE failed: %d\n", error);\r\ngoto err_free_input;\r\n}\r\npwron->palmas = palmas;\r\npwron->input_dev = input_dev;\r\nINIT_DELAYED_WORK(&pwron->input_work, palmas_power_button_work);\r\npwron->irq = platform_get_irq(pdev, 0);\r\nerror = request_threaded_irq(pwron->irq, NULL, pwron_irq,\r\nIRQF_TRIGGER_HIGH |\r\nIRQF_TRIGGER_LOW |\r\nIRQF_ONESHOT,\r\ndev_name(dev), pwron);\r\nif (error) {\r\ndev_err(dev, "Can't get IRQ for pwron: %d\n", error);\r\ngoto err_free_input;\r\n}\r\nerror = input_register_device(input_dev);\r\nif (error) {\r\ndev_err(dev, "Can't register power button: %d\n", error);\r\ngoto err_free_irq;\r\n}\r\nplatform_set_drvdata(pdev, pwron);\r\ndevice_init_wakeup(dev, true);\r\nreturn 0;\r\nerr_free_irq:\r\ncancel_delayed_work_sync(&pwron->input_work);\r\nfree_irq(pwron->irq, pwron);\r\nerr_free_input:\r\ninput_free_device(input_dev);\r\nerr_free_mem:\r\nkfree(pwron);\r\nreturn error;\r\n}\r\nstatic int palmas_pwron_remove(struct platform_device *pdev)\r\n{\r\nstruct palmas_pwron *pwron = platform_get_drvdata(pdev);\r\nfree_irq(pwron->irq, pwron);\r\ncancel_delayed_work_sync(&pwron->input_work);\r\ninput_unregister_device(pwron->input_dev);\r\nkfree(pwron);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused palmas_pwron_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct palmas_pwron *pwron = platform_get_drvdata(pdev);\r\ncancel_delayed_work_sync(&pwron->input_work);\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(pwron->irq);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused palmas_pwron_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct palmas_pwron *pwron = platform_get_drvdata(pdev);\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(pwron->irq);\r\nreturn 0;\r\n}
