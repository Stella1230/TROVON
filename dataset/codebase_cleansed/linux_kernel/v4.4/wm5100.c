static int wm5100_alloc_sr(struct snd_soc_codec *codec, int rate)\r\n{\r\nstruct wm5100_priv *wm5100 = snd_soc_codec_get_drvdata(codec);\r\nint sr_code, sr_free, i;\r\nfor (i = 0; i < ARRAY_SIZE(wm5100_sr_code); i++)\r\nif (wm5100_sr_code[i] == rate)\r\nbreak;\r\nif (i == ARRAY_SIZE(wm5100_sr_code)) {\r\ndev_err(codec->dev, "Unsupported sample rate: %dHz\n", rate);\r\nreturn -EINVAL;\r\n}\r\nsr_code = i;\r\nif ((wm5100->sysclk % rate) == 0) {\r\nsr_free = -1;\r\nfor (i = 0; i < ARRAY_SIZE(wm5100_sr_regs); i++) {\r\nif (!wm5100->sr_ref[i] && sr_free == -1) {\r\nsr_free = i;\r\ncontinue;\r\n}\r\nif ((snd_soc_read(codec, wm5100_sr_regs[i]) &\r\nWM5100_SAMPLE_RATE_1_MASK) == sr_code)\r\nbreak;\r\n}\r\nif (i < ARRAY_SIZE(wm5100_sr_regs)) {\r\nwm5100->sr_ref[i]++;\r\ndev_dbg(codec->dev, "SR %dHz, slot %d, ref %d\n",\r\nrate, i, wm5100->sr_ref[i]);\r\nreturn i;\r\n}\r\nif (sr_free == -1) {\r\ndev_err(codec->dev, "All SR slots already in use\n");\r\nreturn -EBUSY;\r\n}\r\ndev_dbg(codec->dev, "Allocating SR slot %d for %dHz\n",\r\nsr_free, rate);\r\nwm5100->sr_ref[sr_free]++;\r\nsnd_soc_update_bits(codec, wm5100_sr_regs[sr_free],\r\nWM5100_SAMPLE_RATE_1_MASK,\r\nsr_code);\r\nreturn sr_free;\r\n} else {\r\ndev_err(codec->dev,\r\n"SR %dHz incompatible with %dHz SYSCLK and %dHz ASYNCCLK\n",\r\nrate, wm5100->sysclk, wm5100->asyncclk);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void wm5100_free_sr(struct snd_soc_codec *codec, int rate)\r\n{\r\nstruct wm5100_priv *wm5100 = snd_soc_codec_get_drvdata(codec);\r\nint i, sr_code;\r\nfor (i = 0; i < ARRAY_SIZE(wm5100_sr_code); i++)\r\nif (wm5100_sr_code[i] == rate)\r\nbreak;\r\nif (i == ARRAY_SIZE(wm5100_sr_code)) {\r\ndev_err(codec->dev, "Unsupported sample rate: %dHz\n", rate);\r\nreturn;\r\n}\r\nsr_code = wm5100_sr_code[i];\r\nfor (i = 0; i < ARRAY_SIZE(wm5100_sr_regs); i++) {\r\nif (!wm5100->sr_ref[i])\r\ncontinue;\r\nif ((snd_soc_read(codec, wm5100_sr_regs[i]) &\r\nWM5100_SAMPLE_RATE_1_MASK) == sr_code)\r\nbreak;\r\n}\r\nif (i < ARRAY_SIZE(wm5100_sr_regs)) {\r\nwm5100->sr_ref[i]--;\r\ndev_dbg(codec->dev, "Dereference SR %dHz, count now %d\n",\r\nrate, wm5100->sr_ref[i]);\r\n} else {\r\ndev_warn(codec->dev, "Freeing unreferenced sample rate %dHz\n",\r\nrate);\r\n}\r\n}\r\nstatic int wm5100_reset(struct wm5100_priv *wm5100)\r\n{\r\nif (wm5100->pdata.reset) {\r\ngpio_set_value_cansleep(wm5100->pdata.reset, 0);\r\ngpio_set_value_cansleep(wm5100->pdata.reset, 1);\r\nreturn 0;\r\n} else {\r\nreturn regmap_write(wm5100->regmap, WM5100_SOFTWARE_RESET, 0);\r\n}\r\n}\r\nstatic void wm5100_seq_notifier(struct snd_soc_dapm_context *dapm,\r\nenum snd_soc_dapm_type event, int subseq)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(dapm);\r\nstruct wm5100_priv *wm5100 = snd_soc_codec_get_drvdata(codec);\r\nu16 val, expect, i;\r\nif (wm5100->out_ena[0]) {\r\nexpect = snd_soc_read(codec, WM5100_CHANNEL_ENABLES_1);\r\nfor (i = 0; i < 200; i++) {\r\nval = snd_soc_read(codec, WM5100_OUTPUT_STATUS_1);\r\nif (val == expect) {\r\nwm5100->out_ena[0] = false;\r\nbreak;\r\n}\r\n}\r\nif (i == 200) {\r\ndev_err(codec->dev, "Timeout waiting for OUTPUT1 %x\n",\r\nexpect);\r\n}\r\n}\r\nif (wm5100->out_ena[1]) {\r\nexpect = snd_soc_read(codec, WM5100_OUTPUT_ENABLES_2);\r\nfor (i = 0; i < 200; i++) {\r\nval = snd_soc_read(codec, WM5100_OUTPUT_STATUS_2);\r\nif (val == expect) {\r\nwm5100->out_ena[1] = false;\r\nbreak;\r\n}\r\n}\r\nif (i == 200) {\r\ndev_err(codec->dev, "Timeout waiting for OUTPUT2 %x\n",\r\nexpect);\r\n}\r\n}\r\n}\r\nstatic int wm5100_out_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol,\r\nint event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct wm5100_priv *wm5100 = snd_soc_codec_get_drvdata(codec);\r\nswitch (w->reg) {\r\ncase WM5100_CHANNEL_ENABLES_1:\r\nwm5100->out_ena[0] = true;\r\nbreak;\r\ncase WM5100_OUTPUT_ENABLES_2:\r\nwm5100->out_ena[0] = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void wm5100_log_status3(struct wm5100_priv *wm5100, int val)\r\n{\r\nif (val & WM5100_SPK_SHUTDOWN_WARN_EINT)\r\ndev_crit(wm5100->dev, "Speaker shutdown warning\n");\r\nif (val & WM5100_SPK_SHUTDOWN_EINT)\r\ndev_crit(wm5100->dev, "Speaker shutdown\n");\r\nif (val & WM5100_CLKGEN_ERR_EINT)\r\ndev_crit(wm5100->dev, "SYSCLK underclocked\n");\r\nif (val & WM5100_CLKGEN_ERR_ASYNC_EINT)\r\ndev_crit(wm5100->dev, "ASYNCCLK underclocked\n");\r\n}\r\nstatic void wm5100_log_status4(struct wm5100_priv *wm5100, int val)\r\n{\r\nif (val & WM5100_AIF3_ERR_EINT)\r\ndev_err(wm5100->dev, "AIF3 configuration error\n");\r\nif (val & WM5100_AIF2_ERR_EINT)\r\ndev_err(wm5100->dev, "AIF2 configuration error\n");\r\nif (val & WM5100_AIF1_ERR_EINT)\r\ndev_err(wm5100->dev, "AIF1 configuration error\n");\r\nif (val & WM5100_CTRLIF_ERR_EINT)\r\ndev_err(wm5100->dev, "Control interface error\n");\r\nif (val & WM5100_ISRC2_UNDERCLOCKED_EINT)\r\ndev_err(wm5100->dev, "ISRC2 underclocked\n");\r\nif (val & WM5100_ISRC1_UNDERCLOCKED_EINT)\r\ndev_err(wm5100->dev, "ISRC1 underclocked\n");\r\nif (val & WM5100_FX_UNDERCLOCKED_EINT)\r\ndev_err(wm5100->dev, "FX underclocked\n");\r\nif (val & WM5100_AIF3_UNDERCLOCKED_EINT)\r\ndev_err(wm5100->dev, "AIF3 underclocked\n");\r\nif (val & WM5100_AIF2_UNDERCLOCKED_EINT)\r\ndev_err(wm5100->dev, "AIF2 underclocked\n");\r\nif (val & WM5100_AIF1_UNDERCLOCKED_EINT)\r\ndev_err(wm5100->dev, "AIF1 underclocked\n");\r\nif (val & WM5100_ASRC_UNDERCLOCKED_EINT)\r\ndev_err(wm5100->dev, "ASRC underclocked\n");\r\nif (val & WM5100_DAC_UNDERCLOCKED_EINT)\r\ndev_err(wm5100->dev, "DAC underclocked\n");\r\nif (val & WM5100_ADC_UNDERCLOCKED_EINT)\r\ndev_err(wm5100->dev, "ADC underclocked\n");\r\nif (val & WM5100_MIXER_UNDERCLOCKED_EINT)\r\ndev_err(wm5100->dev, "Mixer underclocked\n");\r\n}\r\nstatic int wm5100_post_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol,\r\nint event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct wm5100_priv *wm5100 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = snd_soc_read(codec, WM5100_INTERRUPT_RAW_STATUS_3);\r\nret &= WM5100_SPK_SHUTDOWN_WARN_STS |\r\nWM5100_SPK_SHUTDOWN_STS | WM5100_CLKGEN_ERR_STS |\r\nWM5100_CLKGEN_ERR_ASYNC_STS;\r\nwm5100_log_status3(wm5100, ret);\r\nret = snd_soc_read(codec, WM5100_INTERRUPT_RAW_STATUS_4);\r\nwm5100_log_status4(wm5100, ret);\r\nreturn 0;\r\n}\r\nstatic int wm5100_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nint lrclk, bclk, mask, base;\r\nbase = dai->driver->base;\r\nlrclk = 0;\r\nbclk = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nmask = 0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nmask = 2;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unsupported DAI format %d\n",\r\nfmt & SND_SOC_DAIFMT_FORMAT_MASK);\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nlrclk |= WM5100_AIF1TX_LRCLK_MSTR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nbclk |= WM5100_AIF1_BCLK_MSTR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nlrclk |= WM5100_AIF1TX_LRCLK_MSTR;\r\nbclk |= WM5100_AIF1_BCLK_MSTR;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unsupported master mode %d\n",\r\nfmt & SND_SOC_DAIFMT_MASTER_MASK);\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nbclk |= WM5100_AIF1_BCLK_INV;\r\nlrclk |= WM5100_AIF1TX_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nbclk |= WM5100_AIF1_BCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nlrclk |= WM5100_AIF1TX_LRCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, base + 1, WM5100_AIF1_BCLK_MSTR |\r\nWM5100_AIF1_BCLK_INV, bclk);\r\nsnd_soc_update_bits(codec, base + 2, WM5100_AIF1TX_LRCLK_MSTR |\r\nWM5100_AIF1TX_LRCLK_INV, lrclk);\r\nsnd_soc_update_bits(codec, base + 3, WM5100_AIF1TX_LRCLK_MSTR |\r\nWM5100_AIF1TX_LRCLK_INV, lrclk);\r\nsnd_soc_update_bits(codec, base + 5, WM5100_AIF1_FMT_MASK, mask);\r\nreturn 0;\r\n}\r\nstatic int wm5100_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm5100_priv *wm5100 = snd_soc_codec_get_drvdata(codec);\r\nbool async = wm5100->aif_async[dai->id];\r\nint i, base, bclk, aif_rate, lrclk, wl, fl, sr;\r\nint *bclk_rates;\r\nbase = dai->driver->base;\r\nwl = params_width(params);\r\nif (wl < 0)\r\nreturn wl;\r\nfl = snd_soc_params_to_frame_size(params);\r\nif (fl < 0)\r\nreturn fl;\r\ndev_dbg(codec->dev, "Word length %d bits, frame length %d bits\n",\r\nwl, fl);\r\nbclk = snd_soc_params_to_bclk(params);\r\nif (bclk < 0)\r\nreturn bclk;\r\nif (!async) {\r\naif_rate = wm5100->sysclk;\r\nsr = wm5100_alloc_sr(codec, params_rate(params));\r\nif (sr < 0)\r\nreturn sr;\r\n} else {\r\naif_rate = wm5100->asyncclk;\r\nsr = 3;\r\nfor (i = 0; i < ARRAY_SIZE(wm5100_sr_code); i++)\r\nif (params_rate(params) == wm5100_sr_code[i])\r\nbreak;\r\nif (i == ARRAY_SIZE(wm5100_sr_code)) {\r\ndev_err(codec->dev, "Invalid rate %dHzn",\r\nparams_rate(params));\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM5100_CLOCKING_8,\r\nWM5100_ASYNC_SAMPLE_RATE_MASK, i);\r\n}\r\nif (!aif_rate) {\r\ndev_err(codec->dev, "%s has no rate set\n",\r\nasync ? "ASYNCCLK" : "SYSCLK");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(codec->dev, "Target BCLK is %dHz, using %dHz %s\n",\r\nbclk, aif_rate, async ? "ASYNCCLK" : "SYSCLK");\r\nif (aif_rate % 4000)\r\nbclk_rates = wm5100_bclk_rates_cd;\r\nelse\r\nbclk_rates = wm5100_bclk_rates_dat;\r\nfor (i = 0; i < WM5100_NUM_BCLK_RATES; i++)\r\nif (bclk_rates[i] >= bclk && (bclk_rates[i] % bclk == 0))\r\nbreak;\r\nif (i == WM5100_NUM_BCLK_RATES) {\r\ndev_err(codec->dev,\r\n"No valid BCLK for %dHz found from %dHz %s\n",\r\nbclk, aif_rate, async ? "ASYNCCLK" : "SYSCLK");\r\nreturn -EINVAL;\r\n}\r\nbclk = i;\r\ndev_dbg(codec->dev, "Setting %dHz BCLK\n", bclk_rates[bclk]);\r\nsnd_soc_update_bits(codec, base + 1, WM5100_AIF1_BCLK_FREQ_MASK, bclk);\r\nlrclk = bclk_rates[bclk] / params_rate(params);\r\ndev_dbg(codec->dev, "Setting %dHz LRCLK\n", bclk_rates[bclk] / lrclk);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ||\r\nwm5100->aif_symmetric[dai->id])\r\nsnd_soc_update_bits(codec, base + 7,\r\nWM5100_AIF1RX_BCPF_MASK, lrclk);\r\nelse\r\nsnd_soc_update_bits(codec, base + 6,\r\nWM5100_AIF1TX_BCPF_MASK, lrclk);\r\ni = (wl << WM5100_AIF1TX_WL_SHIFT) | fl;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nsnd_soc_update_bits(codec, base + 9,\r\nWM5100_AIF1RX_WL_MASK |\r\nWM5100_AIF1RX_SLOT_LEN_MASK, i);\r\nelse\r\nsnd_soc_update_bits(codec, base + 8,\r\nWM5100_AIF1TX_WL_MASK |\r\nWM5100_AIF1TX_SLOT_LEN_MASK, i);\r\nsnd_soc_update_bits(codec, base + 4, WM5100_AIF1_RATE_MASK, sr);\r\nreturn 0;\r\n}\r\nstatic int wm5100_set_sysclk(struct snd_soc_codec *codec, int clk_id,\r\nint source, unsigned int freq, int dir)\r\n{\r\nstruct wm5100_priv *wm5100 = snd_soc_codec_get_drvdata(codec);\r\nint *rate_store;\r\nint fval, audio_rate, ret, reg;\r\nswitch (clk_id) {\r\ncase WM5100_CLK_SYSCLK:\r\nreg = WM5100_CLOCKING_3;\r\nrate_store = &wm5100->sysclk;\r\nbreak;\r\ncase WM5100_CLK_ASYNCCLK:\r\nreg = WM5100_CLOCKING_7;\r\nrate_store = &wm5100->asyncclk;\r\nbreak;\r\ncase WM5100_CLK_32KHZ:\r\nswitch (source) {\r\ncase WM5100_CLKSRC_MCLK1:\r\ncase WM5100_CLKSRC_MCLK2:\r\ncase WM5100_CLKSRC_SYSCLK:\r\nsnd_soc_update_bits(codec, WM5100_CLOCKING_1,\r\nWM5100_CLK_32K_SRC_MASK,\r\nsource);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\ncase WM5100_CLK_AIF1:\r\ncase WM5100_CLK_AIF2:\r\ncase WM5100_CLK_AIF3:\r\nswitch (source) {\r\ncase WM5100_CLKSRC_SYSCLK:\r\nwm5100->aif_async[clk_id - 1] = false;\r\nbreak;\r\ncase WM5100_CLKSRC_ASYNCCLK:\r\nwm5100->aif_async[clk_id - 1] = true;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid source %d\n", source);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\ncase WM5100_CLK_OPCLK:\r\nswitch (freq) {\r\ncase 5644800:\r\ncase 6144000:\r\nsnd_soc_update_bits(codec, WM5100_MISC_GPIO_1,\r\nWM5100_OPCLK_SEL_MASK, 0);\r\nbreak;\r\ncase 11289600:\r\ncase 12288000:\r\nsnd_soc_update_bits(codec, WM5100_MISC_GPIO_1,\r\nWM5100_OPCLK_SEL_MASK, 0);\r\nbreak;\r\ncase 22579200:\r\ncase 24576000:\r\nsnd_soc_update_bits(codec, WM5100_MISC_GPIO_1,\r\nWM5100_OPCLK_SEL_MASK, 0);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unsupported OPCLK %dHz\n",\r\nfreq);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\ndefault:\r\ndev_err(codec->dev, "Unknown clock %d\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\nswitch (source) {\r\ncase WM5100_CLKSRC_SYSCLK:\r\ncase WM5100_CLKSRC_ASYNCCLK:\r\ndev_err(codec->dev, "Invalid source %d\n", source);\r\nreturn -EINVAL;\r\n}\r\nswitch (freq) {\r\ncase 5644800:\r\ncase 6144000:\r\nfval = 0;\r\nbreak;\r\ncase 11289600:\r\ncase 12288000:\r\nfval = 1;\r\nbreak;\r\ncase 22579200:\r\ncase 24576000:\r\nfval = 2;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid clock rate: %d\n", freq);\r\nreturn -EINVAL;\r\n}\r\nswitch (freq) {\r\ncase 5644800:\r\ncase 11289600:\r\ncase 22579200:\r\naudio_rate = 44100;\r\nbreak;\r\ncase 6144000:\r\ncase 12288000:\r\ncase 24576000:\r\naudio_rate = 48000;\r\nbreak;\r\ndefault:\r\nBUG();\r\naudio_rate = 0;\r\nbreak;\r\n}\r\nsnd_soc_update_bits(codec, reg, WM5100_SYSCLK_FREQ_MASK |\r\nWM5100_SYSCLK_SRC_MASK,\r\nfval << WM5100_SYSCLK_FREQ_SHIFT | source);\r\nif (clk_id == WM5100_CLK_SYSCLK) {\r\ndev_dbg(codec->dev, "Setting primary audio rate to %dHz",\r\naudio_rate);\r\nif (0 && *rate_store)\r\nwm5100_free_sr(codec, audio_rate);\r\nret = wm5100_alloc_sr(codec, audio_rate);\r\nif (ret != 0)\r\ndev_warn(codec->dev, "Primary audio slot is %d\n",\r\nret);\r\n}\r\n*rate_store = freq;\r\nreturn 0;\r\n}\r\nstatic int fll_factors(struct _fll_div *fll_div, unsigned int Fref,\r\nunsigned int Fout)\r\n{\r\nunsigned int target;\r\nunsigned int div;\r\nunsigned int fratio, gcd_fll;\r\nint i;\r\ndiv = 1;\r\nfll_div->fll_refclk_div = 0;\r\nwhile ((Fref / div) > 13500000) {\r\ndiv *= 2;\r\nfll_div->fll_refclk_div++;\r\nif (div > 8) {\r\npr_err("Can't scale %dMHz input down to <=13.5MHz\n",\r\nFref);\r\nreturn -EINVAL;\r\n}\r\n}\r\npr_debug("FLL Fref=%u Fout=%u\n", Fref, Fout);\r\nFref /= div;\r\ndiv = 2;\r\nwhile (Fout * div < 90000000) {\r\ndiv++;\r\nif (div > 64) {\r\npr_err("Unable to find FLL_OUTDIV for Fout=%uHz\n",\r\nFout);\r\nreturn -EINVAL;\r\n}\r\n}\r\ntarget = Fout * div;\r\nfll_div->fll_outdiv = div - 1;\r\npr_debug("FLL Fvco=%dHz\n", target);\r\nfor (i = 0; i < ARRAY_SIZE(fll_fratios); i++) {\r\nif (fll_fratios[i].min <= Fref && Fref <= fll_fratios[i].max) {\r\nfll_div->fll_fratio = fll_fratios[i].fll_fratio;\r\nfratio = fll_fratios[i].ratio;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(fll_fratios)) {\r\npr_err("Unable to find FLL_FRATIO for Fref=%uHz\n", Fref);\r\nreturn -EINVAL;\r\n}\r\nfll_div->n = target / (fratio * Fref);\r\nif (target % Fref == 0) {\r\nfll_div->theta = 0;\r\nfll_div->lambda = 0;\r\n} else {\r\ngcd_fll = gcd(target, fratio * Fref);\r\nfll_div->theta = (target - (fll_div->n * fratio * Fref))\r\n/ gcd_fll;\r\nfll_div->lambda = (fratio * Fref) / gcd_fll;\r\n}\r\npr_debug("FLL N=%x THETA=%x LAMBDA=%x\n",\r\nfll_div->n, fll_div->theta, fll_div->lambda);\r\npr_debug("FLL_FRATIO=%x(%d) FLL_OUTDIV=%x FLL_REFCLK_DIV=%x\n",\r\nfll_div->fll_fratio, fratio, fll_div->fll_outdiv,\r\nfll_div->fll_refclk_div);\r\nreturn 0;\r\n}\r\nstatic int wm5100_set_fll(struct snd_soc_codec *codec, int fll_id, int source,\r\nunsigned int Fref, unsigned int Fout)\r\n{\r\nstruct i2c_client *i2c = to_i2c_client(codec->dev);\r\nstruct wm5100_priv *wm5100 = snd_soc_codec_get_drvdata(codec);\r\nstruct _fll_div factors;\r\nstruct wm5100_fll *fll;\r\nint ret, base, lock, i, timeout;\r\nunsigned long time_left;\r\nswitch (fll_id) {\r\ncase WM5100_FLL1:\r\nfll = &wm5100->fll[0];\r\nbase = WM5100_FLL1_CONTROL_1 - 1;\r\nlock = WM5100_FLL1_LOCK_STS;\r\nbreak;\r\ncase WM5100_FLL2:\r\nfll = &wm5100->fll[1];\r\nbase = WM5100_FLL2_CONTROL_2 - 1;\r\nlock = WM5100_FLL2_LOCK_STS;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unknown FLL %d\n",fll_id);\r\nreturn -EINVAL;\r\n}\r\nif (!Fout) {\r\ndev_dbg(codec->dev, "FLL%d disabled", fll_id);\r\nif (fll->fout)\r\npm_runtime_put(codec->dev);\r\nfll->fout = 0;\r\nsnd_soc_update_bits(codec, base + 1, WM5100_FLL1_ENA, 0);\r\nreturn 0;\r\n}\r\nswitch (source) {\r\ncase WM5100_FLL_SRC_MCLK1:\r\ncase WM5100_FLL_SRC_MCLK2:\r\ncase WM5100_FLL_SRC_FLL1:\r\ncase WM5100_FLL_SRC_FLL2:\r\ncase WM5100_FLL_SRC_AIF1BCLK:\r\ncase WM5100_FLL_SRC_AIF2BCLK:\r\ncase WM5100_FLL_SRC_AIF3BCLK:\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid FLL source %d\n", source);\r\nreturn -EINVAL;\r\n}\r\nret = fll_factors(&factors, Fref, Fout);\r\nif (ret < 0)\r\nreturn ret;\r\nsnd_soc_update_bits(codec, base + 1, WM5100_FLL1_ENA, 0);\r\nsnd_soc_update_bits(codec, base + 2,\r\nWM5100_FLL1_OUTDIV_MASK | WM5100_FLL1_FRATIO_MASK,\r\n(factors.fll_outdiv << WM5100_FLL1_OUTDIV_SHIFT) |\r\nfactors.fll_fratio);\r\nsnd_soc_update_bits(codec, base + 3, WM5100_FLL1_THETA_MASK,\r\nfactors.theta);\r\nsnd_soc_update_bits(codec, base + 5, WM5100_FLL1_N_MASK, factors.n);\r\nsnd_soc_update_bits(codec, base + 6,\r\nWM5100_FLL1_REFCLK_DIV_MASK |\r\nWM5100_FLL1_REFCLK_SRC_MASK,\r\n(factors.fll_refclk_div\r\n<< WM5100_FLL1_REFCLK_DIV_SHIFT) | source);\r\nsnd_soc_update_bits(codec, base + 7, WM5100_FLL1_LAMBDA_MASK,\r\nfactors.lambda);\r\ntry_wait_for_completion(&fll->lock);\r\npm_runtime_get_sync(codec->dev);\r\nsnd_soc_update_bits(codec, base + 1, WM5100_FLL1_ENA, WM5100_FLL1_ENA);\r\nif (i2c->irq)\r\ntimeout = 2;\r\nelse\r\ntimeout = 50;\r\nsnd_soc_update_bits(codec, WM5100_CLOCKING_3, WM5100_SYSCLK_ENA,\r\nWM5100_SYSCLK_ENA);\r\nfor (i = 0; i < timeout; i++) {\r\nif (i2c->irq) {\r\ntime_left = wait_for_completion_timeout(&fll->lock,\r\nmsecs_to_jiffies(25));\r\nif (time_left > 0)\r\nbreak;\r\n} else {\r\nmsleep(1);\r\n}\r\nret = snd_soc_read(codec,\r\nWM5100_INTERRUPT_RAW_STATUS_3);\r\nif (ret < 0) {\r\ndev_err(codec->dev,\r\n"Failed to read FLL status: %d\n",\r\nret);\r\ncontinue;\r\n}\r\nif (ret & lock)\r\nbreak;\r\n}\r\nif (i == timeout) {\r\ndev_err(codec->dev, "FLL%d lock timed out\n", fll_id);\r\npm_runtime_put(codec->dev);\r\nreturn -ETIMEDOUT;\r\n}\r\nfll->src = source;\r\nfll->fref = Fref;\r\nfll->fout = Fout;\r\ndev_dbg(codec->dev, "FLL%d running %dHz->%dHz\n", fll_id,\r\nFref, Fout);\r\nreturn 0;\r\n}\r\nstatic void wm5100_set_detect_mode(struct wm5100_priv *wm5100, int the_mode)\r\n{\r\nstruct wm5100_jack_mode *mode = &wm5100->pdata.jack_modes[the_mode];\r\nif (WARN_ON(the_mode >= ARRAY_SIZE(wm5100->pdata.jack_modes)))\r\nreturn;\r\ngpio_set_value_cansleep(wm5100->pdata.hp_pol, mode->hp_pol);\r\nregmap_update_bits(wm5100->regmap, WM5100_ACCESSORY_DETECT_MODE_1,\r\nWM5100_ACCDET_BIAS_SRC_MASK |\r\nWM5100_ACCDET_SRC,\r\n(mode->bias << WM5100_ACCDET_BIAS_SRC_SHIFT) |\r\nmode->micd_src << WM5100_ACCDET_SRC_SHIFT);\r\nregmap_update_bits(wm5100->regmap, WM5100_MISC_CONTROL,\r\nWM5100_HPCOM_SRC,\r\nmode->micd_src << WM5100_HPCOM_SRC_SHIFT);\r\nwm5100->jack_mode = the_mode;\r\ndev_dbg(wm5100->dev, "Set microphone polarity to %d\n",\r\nwm5100->jack_mode);\r\n}\r\nstatic void wm5100_report_headphone(struct wm5100_priv *wm5100)\r\n{\r\ndev_dbg(wm5100->dev, "Headphone detected\n");\r\nwm5100->jack_detecting = false;\r\nsnd_soc_jack_report(wm5100->jack, SND_JACK_HEADPHONE,\r\nSND_JACK_HEADPHONE);\r\nregmap_update_bits(wm5100->regmap, WM5100_MIC_DETECT_1,\r\nWM5100_ACCDET_RATE_MASK,\r\n7 << WM5100_ACCDET_RATE_SHIFT);\r\n}\r\nstatic void wm5100_micd_irq(struct wm5100_priv *wm5100)\r\n{\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(wm5100->regmap, WM5100_MIC_DETECT_3, &val);\r\nif (ret != 0) {\r\ndev_err(wm5100->dev, "Failed to read micropone status: %d\n",\r\nret);\r\nreturn;\r\n}\r\ndev_dbg(wm5100->dev, "Microphone event: %x\n", val);\r\nif (!(val & WM5100_ACCDET_VALID)) {\r\ndev_warn(wm5100->dev, "Microphone detection state invalid\n");\r\nreturn;\r\n}\r\nif (!(val & WM5100_ACCDET_STS)) {\r\ndev_dbg(wm5100->dev, "Jack removal detected\n");\r\nwm5100->jack_mic = false;\r\nwm5100->jack_detecting = true;\r\nwm5100->jack_flips = 0;\r\nsnd_soc_jack_report(wm5100->jack, 0,\r\nSND_JACK_LINEOUT | SND_JACK_HEADSET |\r\nSND_JACK_BTN_0);\r\nregmap_update_bits(wm5100->regmap, WM5100_MIC_DETECT_1,\r\nWM5100_ACCDET_RATE_MASK,\r\nWM5100_ACCDET_RATE_MASK);\r\nreturn;\r\n}\r\nif (val & 0x400) {\r\nif (wm5100->jack_detecting) {\r\ndev_dbg(wm5100->dev, "Microphone detected\n");\r\nwm5100->jack_mic = true;\r\nwm5100->jack_detecting = false;\r\nsnd_soc_jack_report(wm5100->jack,\r\nSND_JACK_HEADSET,\r\nSND_JACK_HEADSET | SND_JACK_BTN_0);\r\nregmap_update_bits(wm5100->regmap, WM5100_MIC_DETECT_1,\r\nWM5100_ACCDET_RATE_MASK,\r\n5 << WM5100_ACCDET_RATE_SHIFT);\r\n} else {\r\ndev_dbg(wm5100->dev, "Mic button up\n");\r\nsnd_soc_jack_report(wm5100->jack, 0, SND_JACK_BTN_0);\r\n}\r\nreturn;\r\n}\r\nif (wm5100->jack_detecting && (val & 0x3f8)) {\r\nwm5100->jack_flips++;\r\nif (wm5100->jack_flips > 1)\r\nwm5100_report_headphone(wm5100);\r\nelse\r\nwm5100_set_detect_mode(wm5100, !wm5100->jack_mode);\r\nreturn;\r\n}\r\nif (val & 0x3fc) {\r\nif (wm5100->jack_mic) {\r\ndev_dbg(wm5100->dev, "Mic button detected\n");\r\nsnd_soc_jack_report(wm5100->jack, SND_JACK_BTN_0,\r\nSND_JACK_BTN_0);\r\n} else if (wm5100->jack_detecting) {\r\nwm5100_report_headphone(wm5100);\r\n}\r\n}\r\n}\r\nint wm5100_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack)\r\n{\r\nstruct wm5100_priv *wm5100 = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nif (jack) {\r\nwm5100->jack = jack;\r\nwm5100->jack_detecting = true;\r\nwm5100->jack_flips = 0;\r\nwm5100_set_detect_mode(wm5100, 0);\r\nsnd_soc_update_bits(codec, WM5100_MIC_DETECT_1,\r\nWM5100_ACCDET_BIAS_STARTTIME_MASK |\r\nWM5100_ACCDET_RATE_MASK,\r\n(7 << WM5100_ACCDET_BIAS_STARTTIME_SHIFT) |\r\nWM5100_ACCDET_RATE_MASK);\r\nsnd_soc_dapm_mutex_lock(dapm);\r\nsnd_soc_dapm_force_enable_pin_unlocked(dapm, "CP2");\r\nsnd_soc_dapm_force_enable_pin_unlocked(dapm, "SYSCLK");\r\nsnd_soc_dapm_sync_unlocked(dapm);\r\nsnd_soc_dapm_mutex_unlock(dapm);\r\nsnd_soc_update_bits(codec, WM5100_MIC_DETECT_1,\r\nWM5100_ACCDET_ENA, WM5100_ACCDET_ENA);\r\nsnd_soc_update_bits(codec, WM5100_INTERRUPT_STATUS_3_MASK,\r\nWM5100_IM_ACCDET_EINT, 0);\r\n} else {\r\nsnd_soc_update_bits(codec, WM5100_INTERRUPT_STATUS_3_MASK,\r\nWM5100_IM_HPDET_EINT |\r\nWM5100_IM_ACCDET_EINT,\r\nWM5100_IM_HPDET_EINT |\r\nWM5100_IM_ACCDET_EINT);\r\nsnd_soc_update_bits(codec, WM5100_MIC_DETECT_1,\r\nWM5100_ACCDET_ENA, 0);\r\nwm5100->jack = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t wm5100_irq(int irq, void *data)\r\n{\r\nstruct wm5100_priv *wm5100 = data;\r\nirqreturn_t status = IRQ_NONE;\r\nunsigned int irq_val, mask_val;\r\nint ret;\r\nret = regmap_read(wm5100->regmap, WM5100_INTERRUPT_STATUS_3, &irq_val);\r\nif (ret < 0) {\r\ndev_err(wm5100->dev, "Failed to read IRQ status 3: %d\n",\r\nret);\r\nirq_val = 0;\r\n}\r\nret = regmap_read(wm5100->regmap, WM5100_INTERRUPT_STATUS_3_MASK,\r\n&mask_val);\r\nif (ret < 0) {\r\ndev_err(wm5100->dev, "Failed to read IRQ mask 3: %d\n",\r\nret);\r\nmask_val = 0xffff;\r\n}\r\nirq_val &= ~mask_val;\r\nregmap_write(wm5100->regmap, WM5100_INTERRUPT_STATUS_3, irq_val);\r\nif (irq_val)\r\nstatus = IRQ_HANDLED;\r\nwm5100_log_status3(wm5100, irq_val);\r\nif (irq_val & WM5100_FLL1_LOCK_EINT) {\r\ndev_dbg(wm5100->dev, "FLL1 locked\n");\r\ncomplete(&wm5100->fll[0].lock);\r\n}\r\nif (irq_val & WM5100_FLL2_LOCK_EINT) {\r\ndev_dbg(wm5100->dev, "FLL2 locked\n");\r\ncomplete(&wm5100->fll[1].lock);\r\n}\r\nif (irq_val & WM5100_ACCDET_EINT)\r\nwm5100_micd_irq(wm5100);\r\nret = regmap_read(wm5100->regmap, WM5100_INTERRUPT_STATUS_4, &irq_val);\r\nif (ret < 0) {\r\ndev_err(wm5100->dev, "Failed to read IRQ status 4: %d\n",\r\nret);\r\nirq_val = 0;\r\n}\r\nret = regmap_read(wm5100->regmap, WM5100_INTERRUPT_STATUS_4_MASK,\r\n&mask_val);\r\nif (ret < 0) {\r\ndev_err(wm5100->dev, "Failed to read IRQ mask 4: %d\n",\r\nret);\r\nmask_val = 0xffff;\r\n}\r\nirq_val &= ~mask_val;\r\nif (irq_val)\r\nstatus = IRQ_HANDLED;\r\nregmap_write(wm5100->regmap, WM5100_INTERRUPT_STATUS_4, irq_val);\r\nwm5100_log_status4(wm5100, irq_val);\r\nreturn status;\r\n}\r\nstatic irqreturn_t wm5100_edge_irq(int irq, void *data)\r\n{\r\nirqreturn_t ret = IRQ_NONE;\r\nirqreturn_t val;\r\ndo {\r\nval = wm5100_irq(irq, data);\r\nif (val != IRQ_NONE)\r\nret = val;\r\n} while (val != IRQ_NONE);\r\nreturn ret;\r\n}\r\nstatic inline struct wm5100_priv *gpio_to_wm5100(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct wm5100_priv, gpio_chip);\r\n}\r\nstatic void wm5100_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct wm5100_priv *wm5100 = gpio_to_wm5100(chip);\r\nregmap_update_bits(wm5100->regmap, WM5100_GPIO_CTRL_1 + offset,\r\nWM5100_GP1_LVL, !!value << WM5100_GP1_LVL_SHIFT);\r\n}\r\nstatic int wm5100_gpio_direction_out(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct wm5100_priv *wm5100 = gpio_to_wm5100(chip);\r\nint val, ret;\r\nval = (1 << WM5100_GP1_FN_SHIFT) | (!!value << WM5100_GP1_LVL_SHIFT);\r\nret = regmap_update_bits(wm5100->regmap, WM5100_GPIO_CTRL_1 + offset,\r\nWM5100_GP1_FN_MASK | WM5100_GP1_DIR |\r\nWM5100_GP1_LVL, val);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int wm5100_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct wm5100_priv *wm5100 = gpio_to_wm5100(chip);\r\nunsigned int reg;\r\nint ret;\r\nret = regmap_read(wm5100->regmap, WM5100_GPIO_CTRL_1 + offset, &reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn (reg & WM5100_GP1_LVL) != 0;\r\n}\r\nstatic int wm5100_gpio_direction_in(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct wm5100_priv *wm5100 = gpio_to_wm5100(chip);\r\nreturn regmap_update_bits(wm5100->regmap, WM5100_GPIO_CTRL_1 + offset,\r\nWM5100_GP1_FN_MASK | WM5100_GP1_DIR,\r\n(1 << WM5100_GP1_FN_SHIFT) |\r\n(1 << WM5100_GP1_DIR_SHIFT));\r\n}\r\nstatic void wm5100_init_gpio(struct i2c_client *i2c)\r\n{\r\nstruct wm5100_priv *wm5100 = i2c_get_clientdata(i2c);\r\nint ret;\r\nwm5100->gpio_chip = wm5100_template_chip;\r\nwm5100->gpio_chip.ngpio = 6;\r\nwm5100->gpio_chip.dev = &i2c->dev;\r\nif (wm5100->pdata.gpio_base)\r\nwm5100->gpio_chip.base = wm5100->pdata.gpio_base;\r\nelse\r\nwm5100->gpio_chip.base = -1;\r\nret = gpiochip_add(&wm5100->gpio_chip);\r\nif (ret != 0)\r\ndev_err(&i2c->dev, "Failed to add GPIOs: %d\n", ret);\r\n}\r\nstatic void wm5100_free_gpio(struct i2c_client *i2c)\r\n{\r\nstruct wm5100_priv *wm5100 = i2c_get_clientdata(i2c);\r\ngpiochip_remove(&wm5100->gpio_chip);\r\n}\r\nstatic void wm5100_init_gpio(struct i2c_client *i2c)\r\n{\r\n}\r\nstatic void wm5100_free_gpio(struct i2c_client *i2c)\r\n{\r\n}\r\nstatic int wm5100_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct i2c_client *i2c = to_i2c_client(codec->dev);\r\nstruct wm5100_priv *wm5100 = snd_soc_codec_get_drvdata(codec);\r\nint ret, i;\r\nwm5100->codec = codec;\r\nfor (i = 0; i < ARRAY_SIZE(wm5100_dig_vu); i++)\r\nsnd_soc_update_bits(codec, wm5100_dig_vu[i], WM5100_OUT_VU,\r\nWM5100_OUT_VU);\r\nsnd_soc_write(codec, WM5100_IRQ_DEBOUNCE_1, 0);\r\nsnd_soc_write(codec, WM5100_IRQ_DEBOUNCE_2, 0);\r\nif (i2c->irq)\r\nsnd_soc_dapm_new_controls(dapm, wm5100_dapm_widgets_noirq,\r\nARRAY_SIZE(wm5100_dapm_widgets_noirq));\r\nif (wm5100->pdata.hp_pol) {\r\nret = gpio_request_one(wm5100->pdata.hp_pol,\r\nGPIOF_OUT_INIT_HIGH, "WM5100 HP_POL");\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to request HP_POL %d: %d\n",\r\nwm5100->pdata.hp_pol, ret);\r\ngoto err_gpio;\r\n}\r\n}\r\nreturn 0;\r\nerr_gpio:\r\nreturn ret;\r\n}\r\nstatic int wm5100_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct wm5100_priv *wm5100 = snd_soc_codec_get_drvdata(codec);\r\nif (wm5100->pdata.hp_pol) {\r\ngpio_free(wm5100->pdata.hp_pol);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm5100_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm5100_pdata *pdata = dev_get_platdata(&i2c->dev);\r\nstruct wm5100_priv *wm5100;\r\nunsigned int reg;\r\nint ret, i, irq_flags;\r\nwm5100 = devm_kzalloc(&i2c->dev, sizeof(struct wm5100_priv),\r\nGFP_KERNEL);\r\nif (wm5100 == NULL)\r\nreturn -ENOMEM;\r\nwm5100->dev = &i2c->dev;\r\nwm5100->regmap = devm_regmap_init_i2c(i2c, &wm5100_regmap);\r\nif (IS_ERR(wm5100->regmap)) {\r\nret = PTR_ERR(wm5100->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate register map: %d\n",\r\nret);\r\ngoto err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(wm5100->fll); i++)\r\ninit_completion(&wm5100->fll[i].lock);\r\nif (pdata)\r\nwm5100->pdata = *pdata;\r\ni2c_set_clientdata(i2c, wm5100);\r\nfor (i = 0; i < ARRAY_SIZE(wm5100->core_supplies); i++)\r\nwm5100->core_supplies[i].supply = wm5100_core_supply_names[i];\r\nret = devm_regulator_bulk_get(&i2c->dev,\r\nARRAY_SIZE(wm5100->core_supplies),\r\nwm5100->core_supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to request core supplies: %d\n",\r\nret);\r\ngoto err;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm5100->core_supplies),\r\nwm5100->core_supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to enable core supplies: %d\n",\r\nret);\r\ngoto err;\r\n}\r\nif (wm5100->pdata.ldo_ena) {\r\nret = gpio_request_one(wm5100->pdata.ldo_ena,\r\nGPIOF_OUT_INIT_HIGH, "WM5100 LDOENA");\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to request LDOENA %d: %d\n",\r\nwm5100->pdata.ldo_ena, ret);\r\ngoto err_enable;\r\n}\r\nmsleep(2);\r\n}\r\nif (wm5100->pdata.reset) {\r\nret = gpio_request_one(wm5100->pdata.reset,\r\nGPIOF_OUT_INIT_HIGH, "WM5100 /RESET");\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to request /RESET %d: %d\n",\r\nwm5100->pdata.reset, ret);\r\ngoto err_ldo;\r\n}\r\n}\r\nret = regmap_read(wm5100->regmap, WM5100_SOFTWARE_RESET, &reg);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to read ID register: %d\n", ret);\r\ngoto err_reset;\r\n}\r\nswitch (reg) {\r\ncase 0x8997:\r\ncase 0x5100:\r\nbreak;\r\ndefault:\r\ndev_err(&i2c->dev, "Device is not a WM5100, ID is %x\n", reg);\r\nret = -EINVAL;\r\ngoto err_reset;\r\n}\r\nret = regmap_read(wm5100->regmap, WM5100_DEVICE_REVISION, &reg);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to read revision register\n");\r\ngoto err_reset;\r\n}\r\nwm5100->rev = reg & WM5100_DEVICE_REVISION_MASK;\r\ndev_info(&i2c->dev, "revision %c\n", wm5100->rev + 'A');\r\nret = wm5100_reset(wm5100);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to issue reset\n");\r\ngoto err_reset;\r\n}\r\nswitch (wm5100->rev) {\r\ncase 0:\r\nret = regmap_register_patch(wm5100->regmap,\r\nwm5100_reva_patches,\r\nARRAY_SIZE(wm5100_reva_patches));\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to register patches: %d\n",\r\nret);\r\ngoto err_reset;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwm5100_init_gpio(i2c);\r\nfor (i = 0; i < ARRAY_SIZE(wm5100->pdata.gpio_defaults); i++) {\r\nif (!wm5100->pdata.gpio_defaults[i])\r\ncontinue;\r\nregmap_write(wm5100->regmap, WM5100_GPIO_CTRL_1 + i,\r\nwm5100->pdata.gpio_defaults[i]);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(wm5100->pdata.in_mode); i++) {\r\nregmap_update_bits(wm5100->regmap, wm5100_mic_ctrl_reg[i],\r\nWM5100_IN1_MODE_MASK |\r\nWM5100_IN1_DMIC_SUP_MASK,\r\n(wm5100->pdata.in_mode[i] <<\r\nWM5100_IN1_MODE_SHIFT) |\r\n(wm5100->pdata.dmic_sup[i] <<\r\nWM5100_IN1_DMIC_SUP_SHIFT));\r\n}\r\nif (i2c->irq) {\r\nif (wm5100->pdata.irq_flags)\r\nirq_flags = wm5100->pdata.irq_flags;\r\nelse\r\nirq_flags = IRQF_TRIGGER_LOW;\r\nirq_flags |= IRQF_ONESHOT;\r\nif (irq_flags & (IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING))\r\nret = request_threaded_irq(i2c->irq, NULL,\r\nwm5100_edge_irq, irq_flags,\r\n"wm5100", wm5100);\r\nelse\r\nret = request_threaded_irq(i2c->irq, NULL, wm5100_irq,\r\nirq_flags, "wm5100",\r\nwm5100);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to request IRQ %d: %d\n",\r\ni2c->irq, ret);\r\n} else {\r\nregmap_update_bits(wm5100->regmap,\r\nWM5100_INTERRUPT_STATUS_3_MASK,\r\nWM5100_IM_SPK_SHUTDOWN_WARN_EINT |\r\nWM5100_IM_SPK_SHUTDOWN_EINT |\r\nWM5100_IM_ASRC2_LOCK_EINT |\r\nWM5100_IM_ASRC1_LOCK_EINT |\r\nWM5100_IM_FLL2_LOCK_EINT |\r\nWM5100_IM_FLL1_LOCK_EINT |\r\nWM5100_CLKGEN_ERR_EINT |\r\nWM5100_CLKGEN_ERR_ASYNC_EINT, 0);\r\nregmap_update_bits(wm5100->regmap,\r\nWM5100_INTERRUPT_STATUS_4_MASK,\r\nWM5100_AIF3_ERR_EINT |\r\nWM5100_AIF2_ERR_EINT |\r\nWM5100_AIF1_ERR_EINT |\r\nWM5100_CTRLIF_ERR_EINT |\r\nWM5100_ISRC2_UNDERCLOCKED_EINT |\r\nWM5100_ISRC1_UNDERCLOCKED_EINT |\r\nWM5100_FX_UNDERCLOCKED_EINT |\r\nWM5100_AIF3_UNDERCLOCKED_EINT |\r\nWM5100_AIF2_UNDERCLOCKED_EINT |\r\nWM5100_AIF1_UNDERCLOCKED_EINT |\r\nWM5100_ASRC_UNDERCLOCKED_EINT |\r\nWM5100_DAC_UNDERCLOCKED_EINT |\r\nWM5100_ADC_UNDERCLOCKED_EINT |\r\nWM5100_MIXER_UNDERCLOCKED_EINT, 0);\r\n}\r\n}\r\npm_runtime_set_active(&i2c->dev);\r\npm_runtime_enable(&i2c->dev);\r\npm_request_idle(&i2c->dev);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm5100, wm5100_dai,\r\nARRAY_SIZE(wm5100_dai));\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to register WM5100: %d\n", ret);\r\ngoto err_reset;\r\n}\r\nreturn ret;\r\nerr_reset:\r\nif (i2c->irq)\r\nfree_irq(i2c->irq, wm5100);\r\nwm5100_free_gpio(i2c);\r\nif (wm5100->pdata.reset) {\r\ngpio_set_value_cansleep(wm5100->pdata.reset, 0);\r\ngpio_free(wm5100->pdata.reset);\r\n}\r\nerr_ldo:\r\nif (wm5100->pdata.ldo_ena) {\r\ngpio_set_value_cansleep(wm5100->pdata.ldo_ena, 0);\r\ngpio_free(wm5100->pdata.ldo_ena);\r\n}\r\nerr_enable:\r\nregulator_bulk_disable(ARRAY_SIZE(wm5100->core_supplies),\r\nwm5100->core_supplies);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int wm5100_i2c_remove(struct i2c_client *i2c)\r\n{\r\nstruct wm5100_priv *wm5100 = i2c_get_clientdata(i2c);\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nif (i2c->irq)\r\nfree_irq(i2c->irq, wm5100);\r\nwm5100_free_gpio(i2c);\r\nif (wm5100->pdata.reset) {\r\ngpio_set_value_cansleep(wm5100->pdata.reset, 0);\r\ngpio_free(wm5100->pdata.reset);\r\n}\r\nif (wm5100->pdata.ldo_ena) {\r\ngpio_set_value_cansleep(wm5100->pdata.ldo_ena, 0);\r\ngpio_free(wm5100->pdata.ldo_ena);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm5100_runtime_suspend(struct device *dev)\r\n{\r\nstruct wm5100_priv *wm5100 = dev_get_drvdata(dev);\r\nregcache_cache_only(wm5100->regmap, true);\r\nregcache_mark_dirty(wm5100->regmap);\r\nif (wm5100->pdata.ldo_ena)\r\ngpio_set_value_cansleep(wm5100->pdata.ldo_ena, 0);\r\nregulator_bulk_disable(ARRAY_SIZE(wm5100->core_supplies),\r\nwm5100->core_supplies);\r\nreturn 0;\r\n}\r\nstatic int wm5100_runtime_resume(struct device *dev)\r\n{\r\nstruct wm5100_priv *wm5100 = dev_get_drvdata(dev);\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm5100->core_supplies),\r\nwm5100->core_supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (wm5100->pdata.ldo_ena) {\r\ngpio_set_value_cansleep(wm5100->pdata.ldo_ena, 1);\r\nmsleep(2);\r\n}\r\nregcache_cache_only(wm5100->regmap, false);\r\nregcache_sync(wm5100->regmap);\r\nreturn 0;\r\n}
