static unsigned long max_pages(unsigned long min_pages)\r\n{\r\nunsigned long node_free_pages, max;\r\nint node = numa_node_id();\r\nstruct zone *zones = NODE_DATA(node)->node_zones;\r\nint num_cpus_on_node;\r\nnode_free_pages =\r\n#ifdef CONFIG_ZONE_DMA\r\nzone_page_state(&zones[ZONE_DMA], NR_FREE_PAGES) +\r\n#endif\r\n#ifdef CONFIG_ZONE_DMA32\r\nzone_page_state(&zones[ZONE_DMA32], NR_FREE_PAGES) +\r\n#endif\r\nzone_page_state(&zones[ZONE_NORMAL], NR_FREE_PAGES);\r\nmax = node_free_pages / FRACTION_OF_NODE_MEM;\r\nnum_cpus_on_node = cpumask_weight(cpumask_of_node(node));\r\nmax /= num_cpus_on_node;\r\nreturn max(max, min_pages);\r\n}\r\nstatic long min_pages_to_free(struct quicklist *q,\r\nunsigned long min_pages, long max_free)\r\n{\r\nlong pages_to_free;\r\npages_to_free = q->nr_pages - max_pages(min_pages);\r\nreturn min(pages_to_free, max_free);\r\n}\r\nvoid quicklist_trim(int nr, void (*dtor)(void *),\r\nunsigned long min_pages, unsigned long max_free)\r\n{\r\nlong pages_to_free;\r\nstruct quicklist *q;\r\nq = &get_cpu_var(quicklist)[nr];\r\nif (q->nr_pages > min_pages) {\r\npages_to_free = min_pages_to_free(q, min_pages, max_free);\r\nwhile (pages_to_free > 0) {\r\nvoid *p = quicklist_alloc(nr, 0, NULL);\r\nif (dtor)\r\ndtor(p);\r\nfree_page((unsigned long)p);\r\npages_to_free--;\r\n}\r\n}\r\nput_cpu_var(quicklist);\r\n}\r\nunsigned long quicklist_total_size(void)\r\n{\r\nunsigned long count = 0;\r\nint cpu;\r\nstruct quicklist *ql, *q;\r\nfor_each_online_cpu(cpu) {\r\nql = per_cpu(quicklist, cpu);\r\nfor (q = ql; q < ql + CONFIG_NR_QUICK; q++)\r\ncount += q->nr_pages;\r\n}\r\nreturn count;\r\n}
