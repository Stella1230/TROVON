static inline void x25_start_t20timer(struct x25_neigh *nb)\r\n{\r\nmod_timer(&nb->t20timer, jiffies + nb->t20);\r\n}\r\nstatic void x25_t20timer_expiry(unsigned long param)\r\n{\r\nstruct x25_neigh *nb = (struct x25_neigh *)param;\r\nx25_transmit_restart_request(nb);\r\nx25_start_t20timer(nb);\r\n}\r\nstatic inline void x25_stop_t20timer(struct x25_neigh *nb)\r\n{\r\ndel_timer(&nb->t20timer);\r\n}\r\nstatic inline int x25_t20timer_pending(struct x25_neigh *nb)\r\n{\r\nreturn timer_pending(&nb->t20timer);\r\n}\r\nvoid x25_link_control(struct sk_buff *skb, struct x25_neigh *nb,\r\nunsigned short frametype)\r\n{\r\nstruct sk_buff *skbn;\r\nint confirm;\r\nswitch (frametype) {\r\ncase X25_RESTART_REQUEST:\r\nconfirm = !x25_t20timer_pending(nb);\r\nx25_stop_t20timer(nb);\r\nnb->state = X25_LINK_STATE_3;\r\nif (confirm)\r\nx25_transmit_restart_confirmation(nb);\r\nbreak;\r\ncase X25_RESTART_CONFIRMATION:\r\nx25_stop_t20timer(nb);\r\nnb->state = X25_LINK_STATE_3;\r\nbreak;\r\ncase X25_DIAGNOSTIC:\r\nif (!pskb_may_pull(skb, X25_STD_MIN_LEN + 4))\r\nbreak;\r\npr_warn("diagnostic #%d - %02X %02X %02X\n",\r\nskb->data[3], skb->data[4],\r\nskb->data[5], skb->data[6]);\r\nbreak;\r\ndefault:\r\npr_warn("received unknown %02X with LCI 000\n",\r\nframetype);\r\nbreak;\r\n}\r\nif (nb->state == X25_LINK_STATE_3)\r\nwhile ((skbn = skb_dequeue(&nb->queue)) != NULL)\r\nx25_send_frame(skbn, nb);\r\n}\r\nstatic void x25_transmit_restart_request(struct x25_neigh *nb)\r\n{\r\nunsigned char *dptr;\r\nint len = X25_MAX_L2_LEN + X25_STD_MIN_LEN + 2;\r\nstruct sk_buff *skb = alloc_skb(len, GFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, X25_MAX_L2_LEN);\r\ndptr = skb_put(skb, X25_STD_MIN_LEN + 2);\r\n*dptr++ = nb->extended ? X25_GFI_EXTSEQ : X25_GFI_STDSEQ;\r\n*dptr++ = 0x00;\r\n*dptr++ = X25_RESTART_REQUEST;\r\n*dptr++ = 0x00;\r\n*dptr++ = 0;\r\nskb->sk = NULL;\r\nx25_send_frame(skb, nb);\r\n}\r\nstatic void x25_transmit_restart_confirmation(struct x25_neigh *nb)\r\n{\r\nunsigned char *dptr;\r\nint len = X25_MAX_L2_LEN + X25_STD_MIN_LEN;\r\nstruct sk_buff *skb = alloc_skb(len, GFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, X25_MAX_L2_LEN);\r\ndptr = skb_put(skb, X25_STD_MIN_LEN);\r\n*dptr++ = nb->extended ? X25_GFI_EXTSEQ : X25_GFI_STDSEQ;\r\n*dptr++ = 0x00;\r\n*dptr++ = X25_RESTART_CONFIRMATION;\r\nskb->sk = NULL;\r\nx25_send_frame(skb, nb);\r\n}\r\nvoid x25_transmit_clear_request(struct x25_neigh *nb, unsigned int lci,\r\nunsigned char cause)\r\n{\r\nunsigned char *dptr;\r\nint len = X25_MAX_L2_LEN + X25_STD_MIN_LEN + 2;\r\nstruct sk_buff *skb = alloc_skb(len, GFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, X25_MAX_L2_LEN);\r\ndptr = skb_put(skb, X25_STD_MIN_LEN + 2);\r\n*dptr++ = ((lci >> 8) & 0x0F) | (nb->extended ?\r\nX25_GFI_EXTSEQ :\r\nX25_GFI_STDSEQ);\r\n*dptr++ = (lci >> 0) & 0xFF;\r\n*dptr++ = X25_CLEAR_REQUEST;\r\n*dptr++ = cause;\r\n*dptr++ = 0x00;\r\nskb->sk = NULL;\r\nx25_send_frame(skb, nb);\r\n}\r\nvoid x25_transmit_link(struct sk_buff *skb, struct x25_neigh *nb)\r\n{\r\nswitch (nb->state) {\r\ncase X25_LINK_STATE_0:\r\nskb_queue_tail(&nb->queue, skb);\r\nnb->state = X25_LINK_STATE_1;\r\nx25_establish_link(nb);\r\nbreak;\r\ncase X25_LINK_STATE_1:\r\ncase X25_LINK_STATE_2:\r\nskb_queue_tail(&nb->queue, skb);\r\nbreak;\r\ncase X25_LINK_STATE_3:\r\nx25_send_frame(skb, nb);\r\nbreak;\r\n}\r\n}\r\nvoid x25_link_established(struct x25_neigh *nb)\r\n{\r\nswitch (nb->state) {\r\ncase X25_LINK_STATE_0:\r\nnb->state = X25_LINK_STATE_2;\r\nbreak;\r\ncase X25_LINK_STATE_1:\r\nx25_transmit_restart_request(nb);\r\nnb->state = X25_LINK_STATE_2;\r\nx25_start_t20timer(nb);\r\nbreak;\r\n}\r\n}\r\nvoid x25_link_terminated(struct x25_neigh *nb)\r\n{\r\nnb->state = X25_LINK_STATE_0;\r\nx25_kill_by_neigh(nb);\r\n}\r\nvoid x25_link_device_up(struct net_device *dev)\r\n{\r\nstruct x25_neigh *nb = kmalloc(sizeof(*nb), GFP_ATOMIC);\r\nif (!nb)\r\nreturn;\r\nskb_queue_head_init(&nb->queue);\r\nsetup_timer(&nb->t20timer, x25_t20timer_expiry, (unsigned long)nb);\r\ndev_hold(dev);\r\nnb->dev = dev;\r\nnb->state = X25_LINK_STATE_0;\r\nnb->extended = 0;\r\nnb->global_facil_mask = X25_MASK_REVERSE |\r\nX25_MASK_THROUGHPUT |\r\nX25_MASK_PACKET_SIZE |\r\nX25_MASK_WINDOW_SIZE;\r\nnb->t20 = sysctl_x25_restart_request_timeout;\r\natomic_set(&nb->refcnt, 1);\r\nwrite_lock_bh(&x25_neigh_list_lock);\r\nlist_add(&nb->node, &x25_neigh_list);\r\nwrite_unlock_bh(&x25_neigh_list_lock);\r\n}\r\nstatic void __x25_remove_neigh(struct x25_neigh *nb)\r\n{\r\nskb_queue_purge(&nb->queue);\r\nx25_stop_t20timer(nb);\r\nif (nb->node.next) {\r\nlist_del(&nb->node);\r\nx25_neigh_put(nb);\r\n}\r\n}\r\nvoid x25_link_device_down(struct net_device *dev)\r\n{\r\nstruct x25_neigh *nb;\r\nstruct list_head *entry, *tmp;\r\nwrite_lock_bh(&x25_neigh_list_lock);\r\nlist_for_each_safe(entry, tmp, &x25_neigh_list) {\r\nnb = list_entry(entry, struct x25_neigh, node);\r\nif (nb->dev == dev) {\r\n__x25_remove_neigh(nb);\r\ndev_put(dev);\r\n}\r\n}\r\nwrite_unlock_bh(&x25_neigh_list_lock);\r\n}\r\nstruct x25_neigh *x25_get_neigh(struct net_device *dev)\r\n{\r\nstruct x25_neigh *nb, *use = NULL;\r\nstruct list_head *entry;\r\nread_lock_bh(&x25_neigh_list_lock);\r\nlist_for_each(entry, &x25_neigh_list) {\r\nnb = list_entry(entry, struct x25_neigh, node);\r\nif (nb->dev == dev) {\r\nuse = nb;\r\nbreak;\r\n}\r\n}\r\nif (use)\r\nx25_neigh_hold(use);\r\nread_unlock_bh(&x25_neigh_list_lock);\r\nreturn use;\r\n}\r\nint x25_subscr_ioctl(unsigned int cmd, void __user *arg)\r\n{\r\nstruct x25_subscrip_struct x25_subscr;\r\nstruct x25_neigh *nb;\r\nstruct net_device *dev;\r\nint rc = -EINVAL;\r\nif (cmd != SIOCX25GSUBSCRIP && cmd != SIOCX25SSUBSCRIP)\r\ngoto out;\r\nrc = -EFAULT;\r\nif (copy_from_user(&x25_subscr, arg, sizeof(x25_subscr)))\r\ngoto out;\r\nrc = -EINVAL;\r\nif ((dev = x25_dev_get(x25_subscr.device)) == NULL)\r\ngoto out;\r\nif ((nb = x25_get_neigh(dev)) == NULL)\r\ngoto out_dev_put;\r\ndev_put(dev);\r\nif (cmd == SIOCX25GSUBSCRIP) {\r\nread_lock_bh(&x25_neigh_list_lock);\r\nx25_subscr.extended = nb->extended;\r\nx25_subscr.global_facil_mask = nb->global_facil_mask;\r\nread_unlock_bh(&x25_neigh_list_lock);\r\nrc = copy_to_user(arg, &x25_subscr,\r\nsizeof(x25_subscr)) ? -EFAULT : 0;\r\n} else {\r\nrc = -EINVAL;\r\nif (!(x25_subscr.extended && x25_subscr.extended != 1)) {\r\nrc = 0;\r\nwrite_lock_bh(&x25_neigh_list_lock);\r\nnb->extended = x25_subscr.extended;\r\nnb->global_facil_mask = x25_subscr.global_facil_mask;\r\nwrite_unlock_bh(&x25_neigh_list_lock);\r\n}\r\n}\r\nx25_neigh_put(nb);\r\nout:\r\nreturn rc;\r\nout_dev_put:\r\ndev_put(dev);\r\ngoto out;\r\n}\r\nvoid __exit x25_link_free(void)\r\n{\r\nstruct x25_neigh *nb;\r\nstruct list_head *entry, *tmp;\r\nwrite_lock_bh(&x25_neigh_list_lock);\r\nlist_for_each_safe(entry, tmp, &x25_neigh_list) {\r\nstruct net_device *dev;\r\nnb = list_entry(entry, struct x25_neigh, node);\r\ndev = nb->dev;\r\n__x25_remove_neigh(nb);\r\ndev_put(dev);\r\n}\r\nwrite_unlock_bh(&x25_neigh_list_lock);\r\n}
