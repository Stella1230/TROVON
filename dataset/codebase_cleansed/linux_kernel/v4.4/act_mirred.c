static void tcf_mirred_release(struct tc_action *a, int bind)\r\n{\r\nstruct tcf_mirred *m = to_mirred(a);\r\nstruct net_device *dev = rcu_dereference_protected(m->tcfm_dev, 1);\r\nspin_lock_bh(&mirred_list_lock);\r\nlist_del(&m->tcfm_list);\r\nspin_unlock_bh(&mirred_list_lock);\r\nif (dev)\r\ndev_put(dev);\r\n}\r\nstatic int tcf_mirred_init(struct net *net, struct nlattr *nla,\r\nstruct nlattr *est, struct tc_action *a, int ovr,\r\nint bind)\r\n{\r\nstruct nlattr *tb[TCA_MIRRED_MAX + 1];\r\nstruct tc_mirred *parm;\r\nstruct tcf_mirred *m;\r\nstruct net_device *dev;\r\nint ret, ok_push = 0;\r\nif (nla == NULL)\r\nreturn -EINVAL;\r\nret = nla_parse_nested(tb, TCA_MIRRED_MAX, nla, mirred_policy);\r\nif (ret < 0)\r\nreturn ret;\r\nif (tb[TCA_MIRRED_PARMS] == NULL)\r\nreturn -EINVAL;\r\nparm = nla_data(tb[TCA_MIRRED_PARMS]);\r\nswitch (parm->eaction) {\r\ncase TCA_EGRESS_MIRROR:\r\ncase TCA_EGRESS_REDIR:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (parm->ifindex) {\r\ndev = __dev_get_by_index(net, parm->ifindex);\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nswitch (dev->type) {\r\ncase ARPHRD_TUNNEL:\r\ncase ARPHRD_TUNNEL6:\r\ncase ARPHRD_SIT:\r\ncase ARPHRD_IPGRE:\r\ncase ARPHRD_VOID:\r\ncase ARPHRD_NONE:\r\nok_push = 0;\r\nbreak;\r\ndefault:\r\nok_push = 1;\r\nbreak;\r\n}\r\n} else {\r\ndev = NULL;\r\n}\r\nif (!tcf_hash_check(parm->index, a, bind)) {\r\nif (dev == NULL)\r\nreturn -EINVAL;\r\nret = tcf_hash_create(parm->index, est, a, sizeof(*m),\r\nbind, true);\r\nif (ret)\r\nreturn ret;\r\nret = ACT_P_CREATED;\r\n} else {\r\nif (bind)\r\nreturn 0;\r\ntcf_hash_release(a, bind);\r\nif (!ovr)\r\nreturn -EEXIST;\r\n}\r\nm = to_mirred(a);\r\nASSERT_RTNL();\r\nm->tcf_action = parm->action;\r\nm->tcfm_eaction = parm->eaction;\r\nif (dev != NULL) {\r\nm->tcfm_ifindex = parm->ifindex;\r\nif (ret != ACT_P_CREATED)\r\ndev_put(rcu_dereference_protected(m->tcfm_dev, 1));\r\ndev_hold(dev);\r\nrcu_assign_pointer(m->tcfm_dev, dev);\r\nm->tcfm_ok_push = ok_push;\r\n}\r\nif (ret == ACT_P_CREATED) {\r\nspin_lock_bh(&mirred_list_lock);\r\nlist_add(&m->tcfm_list, &mirred_list);\r\nspin_unlock_bh(&mirred_list_lock);\r\ntcf_hash_insert(a);\r\n}\r\nreturn ret;\r\n}\r\nstatic int tcf_mirred(struct sk_buff *skb, const struct tc_action *a,\r\nstruct tcf_result *res)\r\n{\r\nstruct tcf_mirred *m = a->priv;\r\nstruct net_device *dev;\r\nstruct sk_buff *skb2;\r\nint retval, err;\r\nu32 at;\r\ntcf_lastuse_update(&m->tcf_tm);\r\nbstats_cpu_update(this_cpu_ptr(m->common.cpu_bstats), skb);\r\nrcu_read_lock();\r\nretval = READ_ONCE(m->tcf_action);\r\ndev = rcu_dereference(m->tcfm_dev);\r\nif (unlikely(!dev)) {\r\npr_notice_once("tc mirred: target device is gone\n");\r\ngoto out;\r\n}\r\nif (unlikely(!(dev->flags & IFF_UP))) {\r\nnet_notice_ratelimited("tc mirred to Houston: device %s is down\n",\r\ndev->name);\r\ngoto out;\r\n}\r\nat = G_TC_AT(skb->tc_verd);\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (!skb2)\r\ngoto out;\r\nif (!(at & AT_EGRESS)) {\r\nif (m->tcfm_ok_push)\r\nskb_push(skb2, skb->mac_len);\r\n}\r\nif (m->tcfm_eaction != TCA_EGRESS_MIRROR)\r\nskb2->tc_verd = SET_TC_FROM(skb2->tc_verd, at);\r\nskb2->skb_iif = skb->dev->ifindex;\r\nskb2->dev = dev;\r\nskb_sender_cpu_clear(skb2);\r\nerr = dev_queue_xmit(skb2);\r\nif (err) {\r\nout:\r\nqstats_overlimit_inc(this_cpu_ptr(m->common.cpu_qstats));\r\nif (m->tcfm_eaction != TCA_EGRESS_MIRROR)\r\nretval = TC_ACT_SHOT;\r\n}\r\nrcu_read_unlock();\r\nreturn retval;\r\n}\r\nstatic int tcf_mirred_dump(struct sk_buff *skb, struct tc_action *a, int bind, int ref)\r\n{\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct tcf_mirred *m = a->priv;\r\nstruct tc_mirred opt = {\r\n.index = m->tcf_index,\r\n.action = m->tcf_action,\r\n.refcnt = m->tcf_refcnt - ref,\r\n.bindcnt = m->tcf_bindcnt - bind,\r\n.eaction = m->tcfm_eaction,\r\n.ifindex = m->tcfm_ifindex,\r\n};\r\nstruct tcf_t t;\r\nif (nla_put(skb, TCA_MIRRED_PARMS, sizeof(opt), &opt))\r\ngoto nla_put_failure;\r\nt.install = jiffies_to_clock_t(jiffies - m->tcf_tm.install);\r\nt.lastuse = jiffies_to_clock_t(jiffies - m->tcf_tm.lastuse);\r\nt.expires = jiffies_to_clock_t(m->tcf_tm.expires);\r\nif (nla_put(skb, TCA_MIRRED_TM, sizeof(t), &t))\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int mirred_device_event(struct notifier_block *unused,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct tcf_mirred *m;\r\nASSERT_RTNL();\r\nif (event == NETDEV_UNREGISTER) {\r\nspin_lock_bh(&mirred_list_lock);\r\nlist_for_each_entry(m, &mirred_list, tcfm_list) {\r\nif (rcu_access_pointer(m->tcfm_dev) == dev) {\r\ndev_put(dev);\r\nRCU_INIT_POINTER(m->tcfm_dev, NULL);\r\n}\r\n}\r\nspin_unlock_bh(&mirred_list_lock);\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init mirred_init_module(void)\r\n{\r\nint err = register_netdevice_notifier(&mirred_device_notifier);\r\nif (err)\r\nreturn err;\r\npr_info("Mirror/redirect action on\n");\r\nreturn tcf_register_action(&act_mirred_ops, MIRRED_TAB_MASK);\r\n}\r\nstatic void __exit mirred_cleanup_module(void)\r\n{\r\ntcf_unregister_action(&act_mirred_ops);\r\nunregister_netdevice_notifier(&mirred_device_notifier);\r\n}
