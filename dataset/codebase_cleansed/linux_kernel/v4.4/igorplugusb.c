static void igorplugusb_irdata(struct igorplugusb *ir, unsigned len)\r\n{\r\nDEFINE_IR_RAW_EVENT(rawir);\r\nunsigned i, start, overflow;\r\ndev_dbg(ir->dev, "irdata: %*ph (len=%u)", len, ir->buf_in, len);\r\noverflow = ir->buf_in[2];\r\ni = start = overflow + HEADERLEN;\r\nif (start >= len) {\r\ndev_err(ir->dev, "receive overflow invalid: %u", overflow);\r\n} else {\r\nif (overflow > 0)\r\ndev_warn(ir->dev, "receive overflow, at least %u lost",\r\noverflow);\r\ndo {\r\nrawir.duration = ir->buf_in[i] * 85333;\r\nrawir.pulse = i & 1;\r\nir_raw_event_store_with_filter(ir->rc, &rawir);\r\nif (++i == len)\r\ni = HEADERLEN;\r\n} while (i != start);\r\nrawir.duration = ir->rc->timeout;\r\nrawir.pulse = false;\r\nir_raw_event_store_with_filter(ir->rc, &rawir);\r\nir_raw_event_handle(ir->rc);\r\n}\r\nigorplugusb_cmd(ir, SET_INFRABUFFER_EMPTY);\r\n}\r\nstatic void igorplugusb_callback(struct urb *urb)\r\n{\r\nstruct usb_ctrlrequest *req;\r\nstruct igorplugusb *ir = urb->context;\r\nreq = (struct usb_ctrlrequest *)urb->setup_packet;\r\nswitch (urb->status) {\r\ncase 0:\r\nif (req->bRequest == GET_INFRACODE &&\r\nurb->actual_length > HEADERLEN)\r\nigorplugusb_irdata(ir, urb->actual_length);\r\nelse\r\nmod_timer(&ir->timer, jiffies + msecs_to_jiffies(50));\r\nbreak;\r\ncase -EPROTO:\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nusb_unlink_urb(urb);\r\nreturn;\r\ndefault:\r\ndev_warn(ir->dev, "Error: urb status = %d\n", urb->status);\r\nigorplugusb_cmd(ir, SET_INFRABUFFER_EMPTY);\r\nbreak;\r\n}\r\n}\r\nstatic void igorplugusb_cmd(struct igorplugusb *ir, int cmd)\r\n{\r\nint ret;\r\nir->request.bRequest = cmd;\r\nir->urb->transfer_flags = 0;\r\nret = usb_submit_urb(ir->urb, GFP_ATOMIC);\r\nif (ret)\r\ndev_err(ir->dev, "submit urb failed: %d", ret);\r\n}\r\nstatic void igorplugusb_timer(unsigned long data)\r\n{\r\nstruct igorplugusb *ir = (struct igorplugusb *)data;\r\nigorplugusb_cmd(ir, GET_INFRACODE);\r\n}\r\nstatic int igorplugusb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev;\r\nstruct usb_host_interface *idesc;\r\nstruct usb_endpoint_descriptor *ep;\r\nstruct igorplugusb *ir;\r\nstruct rc_dev *rc;\r\nint ret;\r\nudev = interface_to_usbdev(intf);\r\nidesc = intf->cur_altsetting;\r\nif (idesc->desc.bNumEndpoints != 1) {\r\ndev_err(&intf->dev, "incorrect number of endpoints");\r\nreturn -ENODEV;\r\n}\r\nep = &idesc->endpoint[0].desc;\r\nif (!usb_endpoint_dir_in(ep) || !usb_endpoint_xfer_control(ep)) {\r\ndev_err(&intf->dev, "endpoint incorrect");\r\nreturn -ENODEV;\r\n}\r\nir = devm_kzalloc(&intf->dev, sizeof(*ir), GFP_KERNEL);\r\nif (!ir)\r\nreturn -ENOMEM;\r\nir->dev = &intf->dev;\r\nsetup_timer(&ir->timer, igorplugusb_timer, (unsigned long)ir);\r\nir->request.bRequest = GET_INFRACODE;\r\nir->request.bRequestType = USB_TYPE_VENDOR | USB_DIR_IN;\r\nir->request.wLength = cpu_to_le16(sizeof(ir->buf_in));\r\nir->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!ir->urb)\r\nreturn -ENOMEM;\r\nusb_fill_control_urb(ir->urb, udev,\r\nusb_rcvctrlpipe(udev, 0), (uint8_t *)&ir->request,\r\nir->buf_in, sizeof(ir->buf_in), igorplugusb_callback, ir);\r\nusb_make_path(udev, ir->phys, sizeof(ir->phys));\r\nrc = rc_allocate_device();\r\nrc->input_name = DRIVER_DESC;\r\nrc->input_phys = ir->phys;\r\nusb_to_input_id(udev, &rc->input_id);\r\nrc->dev.parent = &intf->dev;\r\nrc->driver_type = RC_DRIVER_IR_RAW;\r\nrc->allowed_protocols = RC_BIT_ALL & ~(RC_BIT_NEC | RC_BIT_RC6_6A_20 |\r\nRC_BIT_RC6_6A_24 | RC_BIT_RC6_6A_32 | RC_BIT_RC6_MCE |\r\nRC_BIT_SONY20 | RC_BIT_MCE_KBD | RC_BIT_SANYO);\r\nrc->priv = ir;\r\nrc->driver_name = DRIVER_NAME;\r\nrc->map_name = RC_MAP_HAUPPAUGE;\r\nrc->timeout = MS_TO_NS(100);\r\nrc->rx_resolution = 85333;\r\nir->rc = rc;\r\nret = rc_register_device(rc);\r\nif (ret) {\r\ndev_err(&intf->dev, "failed to register rc device: %d", ret);\r\nrc_free_device(rc);\r\nusb_free_urb(ir->urb);\r\nreturn ret;\r\n}\r\nusb_set_intfdata(intf, ir);\r\nigorplugusb_cmd(ir, SET_INFRABUFFER_EMPTY);\r\nreturn 0;\r\n}\r\nstatic void igorplugusb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct igorplugusb *ir = usb_get_intfdata(intf);\r\nrc_unregister_device(ir->rc);\r\ndel_timer_sync(&ir->timer);\r\nusb_set_intfdata(intf, NULL);\r\nusb_kill_urb(ir->urb);\r\nusb_free_urb(ir->urb);\r\n}
