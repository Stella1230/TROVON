static void sz_push(struct streamzap_ir *sz, struct ir_raw_event rawir)\r\n{\r\ndev_dbg(sz->dev, "Storing %s with duration %u us\n",\r\n(rawir.pulse ? "pulse" : "space"), rawir.duration);\r\nir_raw_event_store_with_filter(sz->rdev, &rawir);\r\n}\r\nstatic void sz_push_full_pulse(struct streamzap_ir *sz,\r\nunsigned char value)\r\n{\r\nDEFINE_IR_RAW_EVENT(rawir);\r\nif (sz->idle) {\r\nlong deltv;\r\nsz->signal_last = sz->signal_start;\r\ndo_gettimeofday(&sz->signal_start);\r\ndeltv = sz->signal_start.tv_sec - sz->signal_last.tv_sec;\r\nrawir.pulse = false;\r\nif (deltv > 15) {\r\nrawir.duration = IR_MAX_DURATION;\r\n} else {\r\nrawir.duration = (int)(deltv * 1000000 +\r\nsz->signal_start.tv_usec -\r\nsz->signal_last.tv_usec);\r\nrawir.duration -= sz->sum;\r\nrawir.duration = US_TO_NS(rawir.duration);\r\nrawir.duration = (rawir.duration > IR_MAX_DURATION) ?\r\nIR_MAX_DURATION : rawir.duration;\r\n}\r\nsz_push(sz, rawir);\r\nsz->idle = false;\r\nsz->sum = 0;\r\n}\r\nrawir.pulse = true;\r\nrawir.duration = ((int) value) * SZ_RESOLUTION;\r\nrawir.duration += SZ_RESOLUTION / 2;\r\nsz->sum += rawir.duration;\r\nrawir.duration = US_TO_NS(rawir.duration);\r\nrawir.duration = (rawir.duration > IR_MAX_DURATION) ?\r\nIR_MAX_DURATION : rawir.duration;\r\nsz_push(sz, rawir);\r\n}\r\nstatic void sz_push_half_pulse(struct streamzap_ir *sz,\r\nunsigned char value)\r\n{\r\nsz_push_full_pulse(sz, (value & SZ_PULSE_MASK) >> 4);\r\n}\r\nstatic void sz_push_full_space(struct streamzap_ir *sz,\r\nunsigned char value)\r\n{\r\nDEFINE_IR_RAW_EVENT(rawir);\r\nrawir.pulse = false;\r\nrawir.duration = ((int) value) * SZ_RESOLUTION;\r\nrawir.duration += SZ_RESOLUTION / 2;\r\nsz->sum += rawir.duration;\r\nrawir.duration = US_TO_NS(rawir.duration);\r\nsz_push(sz, rawir);\r\n}\r\nstatic void sz_push_half_space(struct streamzap_ir *sz,\r\nunsigned long value)\r\n{\r\nsz_push_full_space(sz, value & SZ_SPACE_MASK);\r\n}\r\nstatic void streamzap_callback(struct urb *urb)\r\n{\r\nstruct streamzap_ir *sz;\r\nunsigned int i;\r\nint len;\r\nif (!urb)\r\nreturn;\r\nsz = urb->context;\r\nlen = urb->actual_length;\r\nswitch (urb->status) {\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_err(sz->dev, "urb terminated, status: %d\n", urb->status);\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\ndev_dbg(sz->dev, "%s: received urb, len %d\n", __func__, len);\r\nfor (i = 0; i < len; i++) {\r\ndev_dbg(sz->dev, "sz->buf_in[%d]: %x\n",\r\ni, (unsigned char)sz->buf_in[i]);\r\nswitch (sz->decoder_state) {\r\ncase PulseSpace:\r\nif ((sz->buf_in[i] & SZ_PULSE_MASK) ==\r\nSZ_PULSE_MASK) {\r\nsz->decoder_state = FullPulse;\r\ncontinue;\r\n} else if ((sz->buf_in[i] & SZ_SPACE_MASK)\r\n== SZ_SPACE_MASK) {\r\nsz_push_half_pulse(sz, sz->buf_in[i]);\r\nsz->decoder_state = FullSpace;\r\ncontinue;\r\n} else {\r\nsz_push_half_pulse(sz, sz->buf_in[i]);\r\nsz_push_half_space(sz, sz->buf_in[i]);\r\n}\r\nbreak;\r\ncase FullPulse:\r\nsz_push_full_pulse(sz, sz->buf_in[i]);\r\nsz->decoder_state = IgnorePulse;\r\nbreak;\r\ncase FullSpace:\r\nif (sz->buf_in[i] == SZ_TIMEOUT) {\r\nDEFINE_IR_RAW_EVENT(rawir);\r\nrawir.pulse = false;\r\nrawir.duration = sz->rdev->timeout;\r\nsz->idle = true;\r\nif (sz->timeout_enabled)\r\nsz_push(sz, rawir);\r\nir_raw_event_handle(sz->rdev);\r\nir_raw_event_reset(sz->rdev);\r\n} else {\r\nsz_push_full_space(sz, sz->buf_in[i]);\r\n}\r\nsz->decoder_state = PulseSpace;\r\nbreak;\r\ncase IgnorePulse:\r\nif ((sz->buf_in[i] & SZ_SPACE_MASK) ==\r\nSZ_SPACE_MASK) {\r\nsz->decoder_state = FullSpace;\r\ncontinue;\r\n}\r\nsz_push_half_space(sz, sz->buf_in[i]);\r\nsz->decoder_state = PulseSpace;\r\nbreak;\r\n}\r\n}\r\nir_raw_event_handle(sz->rdev);\r\nusb_submit_urb(urb, GFP_ATOMIC);\r\nreturn;\r\n}\r\nstatic struct rc_dev *streamzap_init_rc_dev(struct streamzap_ir *sz)\r\n{\r\nstruct rc_dev *rdev;\r\nstruct device *dev = sz->dev;\r\nint ret;\r\nrdev = rc_allocate_device();\r\nif (!rdev) {\r\ndev_err(dev, "remote dev allocation failed\n");\r\ngoto out;\r\n}\r\nsnprintf(sz->name, sizeof(sz->name), "Streamzap PC Remote Infrared "\r\n"Receiver (%04x:%04x)",\r\nle16_to_cpu(sz->usbdev->descriptor.idVendor),\r\nle16_to_cpu(sz->usbdev->descriptor.idProduct));\r\nusb_make_path(sz->usbdev, sz->phys, sizeof(sz->phys));\r\nstrlcat(sz->phys, "/input0", sizeof(sz->phys));\r\nrdev->input_name = sz->name;\r\nrdev->input_phys = sz->phys;\r\nusb_to_input_id(sz->usbdev, &rdev->input_id);\r\nrdev->dev.parent = dev;\r\nrdev->priv = sz;\r\nrdev->driver_type = RC_DRIVER_IR_RAW;\r\nrdev->allowed_protocols = RC_BIT_ALL;\r\nrdev->driver_name = DRIVER_NAME;\r\nrdev->map_name = RC_MAP_STREAMZAP;\r\nret = rc_register_device(rdev);\r\nif (ret < 0) {\r\ndev_err(dev, "remote input device register failed\n");\r\ngoto out;\r\n}\r\nreturn rdev;\r\nout:\r\nrc_free_device(rdev);\r\nreturn NULL;\r\n}\r\nstatic int streamzap_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *usbdev = interface_to_usbdev(intf);\r\nstruct usb_host_interface *iface_host;\r\nstruct streamzap_ir *sz = NULL;\r\nchar buf[63], name[128] = "";\r\nint retval = -ENOMEM;\r\nint pipe, maxp;\r\nsz = kzalloc(sizeof(struct streamzap_ir), GFP_KERNEL);\r\nif (!sz)\r\nreturn -ENOMEM;\r\nsz->usbdev = usbdev;\r\nsz->interface = intf;\r\niface_host = intf->cur_altsetting;\r\nif (iface_host->desc.bNumEndpoints != 1) {\r\ndev_err(&intf->dev, "%s: Unexpected desc.bNumEndpoints (%d)\n",\r\n__func__, iface_host->desc.bNumEndpoints);\r\nretval = -ENODEV;\r\ngoto free_sz;\r\n}\r\nsz->endpoint = &(iface_host->endpoint[0].desc);\r\nif (!usb_endpoint_dir_in(sz->endpoint)) {\r\ndev_err(&intf->dev, "%s: endpoint doesn't match input device "\r\n"02%02x\n", __func__, sz->endpoint->bEndpointAddress);\r\nretval = -ENODEV;\r\ngoto free_sz;\r\n}\r\nif (!usb_endpoint_xfer_int(sz->endpoint)) {\r\ndev_err(&intf->dev, "%s: endpoint attributes don't match xfer "\r\n"02%02x\n", __func__, sz->endpoint->bmAttributes);\r\nretval = -ENODEV;\r\ngoto free_sz;\r\n}\r\npipe = usb_rcvintpipe(usbdev, sz->endpoint->bEndpointAddress);\r\nmaxp = usb_maxpacket(usbdev, pipe, usb_pipeout(pipe));\r\nif (maxp == 0) {\r\ndev_err(&intf->dev, "%s: endpoint Max Packet Size is 0!?!\n",\r\n__func__);\r\nretval = -ENODEV;\r\ngoto free_sz;\r\n}\r\nsz->buf_in = usb_alloc_coherent(usbdev, maxp, GFP_ATOMIC, &sz->dma_in);\r\nif (!sz->buf_in)\r\ngoto free_sz;\r\nsz->urb_in = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!sz->urb_in)\r\ngoto free_buf_in;\r\nsz->dev = &intf->dev;\r\nsz->buf_in_len = maxp;\r\nif (usbdev->descriptor.iManufacturer\r\n&& usb_string(usbdev, usbdev->descriptor.iManufacturer,\r\nbuf, sizeof(buf)) > 0)\r\nstrlcpy(name, buf, sizeof(name));\r\nif (usbdev->descriptor.iProduct\r\n&& usb_string(usbdev, usbdev->descriptor.iProduct,\r\nbuf, sizeof(buf)) > 0)\r\nsnprintf(name + strlen(name), sizeof(name) - strlen(name),\r\n" %s", buf);\r\nsz->rdev = streamzap_init_rc_dev(sz);\r\nif (!sz->rdev)\r\ngoto rc_dev_fail;\r\nsz->idle = true;\r\nsz->decoder_state = PulseSpace;\r\nsz->timeout_enabled = true;\r\nsz->rdev->timeout = ((US_TO_NS(SZ_TIMEOUT * SZ_RESOLUTION) &\r\nIR_MAX_DURATION) | 0x03000000);\r\n#if 0\r\nsz->min_timeout = US_TO_NS(SZ_TIMEOUT * SZ_RESOLUTION);\r\nsz->max_timeout = US_TO_NS(SZ_TIMEOUT * SZ_RESOLUTION);\r\n#endif\r\ndo_gettimeofday(&sz->signal_start);\r\nusb_fill_int_urb(sz->urb_in, usbdev, pipe, sz->buf_in,\r\nmaxp, (usb_complete_t)streamzap_callback,\r\nsz, sz->endpoint->bInterval);\r\nsz->urb_in->transfer_dma = sz->dma_in;\r\nsz->urb_in->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_set_intfdata(intf, sz);\r\nif (usb_submit_urb(sz->urb_in, GFP_ATOMIC))\r\ndev_err(sz->dev, "urb submit failed\n");\r\ndev_info(sz->dev, "Registered %s on usb%d:%d\n", name,\r\nusbdev->bus->busnum, usbdev->devnum);\r\nreturn 0;\r\nrc_dev_fail:\r\nusb_free_urb(sz->urb_in);\r\nfree_buf_in:\r\nusb_free_coherent(usbdev, maxp, sz->buf_in, sz->dma_in);\r\nfree_sz:\r\nkfree(sz);\r\nreturn retval;\r\n}\r\nstatic void streamzap_disconnect(struct usb_interface *interface)\r\n{\r\nstruct streamzap_ir *sz = usb_get_intfdata(interface);\r\nstruct usb_device *usbdev = interface_to_usbdev(interface);\r\nusb_set_intfdata(interface, NULL);\r\nif (!sz)\r\nreturn;\r\nsz->usbdev = NULL;\r\nrc_unregister_device(sz->rdev);\r\nusb_kill_urb(sz->urb_in);\r\nusb_free_urb(sz->urb_in);\r\nusb_free_coherent(usbdev, sz->buf_in_len, sz->buf_in, sz->dma_in);\r\nkfree(sz);\r\n}\r\nstatic int streamzap_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct streamzap_ir *sz = usb_get_intfdata(intf);\r\nusb_kill_urb(sz->urb_in);\r\nreturn 0;\r\n}\r\nstatic int streamzap_resume(struct usb_interface *intf)\r\n{\r\nstruct streamzap_ir *sz = usb_get_intfdata(intf);\r\nif (usb_submit_urb(sz->urb_in, GFP_ATOMIC)) {\r\ndev_err(sz->dev, "Error sumbiting urb\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}
