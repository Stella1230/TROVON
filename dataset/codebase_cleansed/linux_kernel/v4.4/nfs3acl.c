static __be32\r\nnfsd3_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)\r\n{\r\nreturn nfs_ok;\r\n}\r\nstatic __be32 nfsd3_proc_getacl(struct svc_rqst * rqstp,\r\nstruct nfsd3_getaclargs *argp, struct nfsd3_getaclres *resp)\r\n{\r\nstruct posix_acl *acl;\r\nstruct inode *inode;\r\nsvc_fh *fh;\r\n__be32 nfserr = 0;\r\nfh = fh_copy(&resp->fh, &argp->fh);\r\nnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_NOP);\r\nif (nfserr)\r\nRETURN_STATUS(nfserr);\r\ninode = d_inode(fh->fh_dentry);\r\nif (argp->mask & ~NFS_ACL_MASK)\r\nRETURN_STATUS(nfserr_inval);\r\nresp->mask = argp->mask;\r\nif (resp->mask & (NFS_ACL|NFS_ACLCNT)) {\r\nacl = get_acl(inode, ACL_TYPE_ACCESS);\r\nif (acl == NULL) {\r\nacl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\r\n}\r\nif (IS_ERR(acl)) {\r\nnfserr = nfserrno(PTR_ERR(acl));\r\ngoto fail;\r\n}\r\nresp->acl_access = acl;\r\n}\r\nif (resp->mask & (NFS_DFACL|NFS_DFACLCNT)) {\r\nacl = get_acl(inode, ACL_TYPE_DEFAULT);\r\nif (IS_ERR(acl)) {\r\nnfserr = nfserrno(PTR_ERR(acl));\r\ngoto fail;\r\n}\r\nresp->acl_default = acl;\r\n}\r\nRETURN_STATUS(0);\r\nfail:\r\nposix_acl_release(resp->acl_access);\r\nposix_acl_release(resp->acl_default);\r\nRETURN_STATUS(nfserr);\r\n}\r\nstatic __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,\r\nstruct nfsd3_setaclargs *argp,\r\nstruct nfsd3_attrstat *resp)\r\n{\r\nstruct inode *inode;\r\nsvc_fh *fh;\r\n__be32 nfserr = 0;\r\nint error;\r\nfh = fh_copy(&resp->fh, &argp->fh);\r\nnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\r\nif (nfserr)\r\ngoto out;\r\ninode = d_inode(fh->fh_dentry);\r\nif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\r\nerror = -EOPNOTSUPP;\r\ngoto out_errno;\r\n}\r\nerror = fh_want_write(fh);\r\nif (error)\r\ngoto out_errno;\r\nerror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\r\nif (error)\r\ngoto out_drop_write;\r\nerror = inode->i_op->set_acl(inode, argp->acl_default,\r\nACL_TYPE_DEFAULT);\r\nout_drop_write:\r\nfh_drop_write(fh);\r\nout_errno:\r\nnfserr = nfserrno(error);\r\nout:\r\nposix_acl_release(argp->acl_access);\r\nposix_acl_release(argp->acl_default);\r\nRETURN_STATUS(nfserr);\r\n}\r\nstatic int nfs3svc_decode_getaclargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_getaclargs *args)\r\n{\r\np = nfs3svc_decode_fh(p, &args->fh);\r\nif (!p)\r\nreturn 0;\r\nargs->mask = ntohl(*p); p++;\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nstatic int nfs3svc_decode_setaclargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_setaclargs *args)\r\n{\r\nstruct kvec *head = rqstp->rq_arg.head;\r\nunsigned int base;\r\nint n;\r\np = nfs3svc_decode_fh(p, &args->fh);\r\nif (!p)\r\nreturn 0;\r\nargs->mask = ntohl(*p++);\r\nif (args->mask & ~NFS_ACL_MASK ||\r\n!xdr_argsize_check(rqstp, p))\r\nreturn 0;\r\nbase = (char *)p - (char *)head->iov_base;\r\nn = nfsacl_decode(&rqstp->rq_arg, base, NULL,\r\n(args->mask & NFS_ACL) ?\r\n&args->acl_access : NULL);\r\nif (n > 0)\r\nn = nfsacl_decode(&rqstp->rq_arg, base + n, NULL,\r\n(args->mask & NFS_DFACL) ?\r\n&args->acl_default : NULL);\r\nreturn (n > 0);\r\n}\r\nstatic int nfs3svc_encode_getaclres(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_getaclres *resp)\r\n{\r\nstruct dentry *dentry = resp->fh.fh_dentry;\r\np = nfs3svc_encode_post_op_attr(rqstp, p, &resp->fh);\r\nif (resp->status == 0 && dentry && d_really_is_positive(dentry)) {\r\nstruct inode *inode = d_inode(dentry);\r\nstruct kvec *head = rqstp->rq_res.head;\r\nunsigned int base;\r\nint n;\r\nint w;\r\n*p++ = htonl(resp->mask);\r\nif (!xdr_ressize_check(rqstp, p))\r\nreturn 0;\r\nbase = (char *)p - (char *)head->iov_base;\r\nrqstp->rq_res.page_len = w = nfsacl_size(\r\n(resp->mask & NFS_ACL) ? resp->acl_access : NULL,\r\n(resp->mask & NFS_DFACL) ? resp->acl_default : NULL);\r\nwhile (w > 0) {\r\nif (!*(rqstp->rq_next_page++))\r\nreturn 0;\r\nw -= PAGE_SIZE;\r\n}\r\nn = nfsacl_encode(&rqstp->rq_res, base, inode,\r\nresp->acl_access,\r\nresp->mask & NFS_ACL, 0);\r\nif (n > 0)\r\nn = nfsacl_encode(&rqstp->rq_res, base + n, inode,\r\nresp->acl_default,\r\nresp->mask & NFS_DFACL,\r\nNFS_ACL_DEFAULT);\r\nif (n <= 0)\r\nreturn 0;\r\n} else\r\nif (!xdr_ressize_check(rqstp, p))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int nfs3svc_encode_setaclres(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_attrstat *resp)\r\n{\r\np = nfs3svc_encode_post_op_attr(rqstp, p, &resp->fh);\r\nreturn xdr_ressize_check(rqstp, p);\r\n}\r\nstatic int nfs3svc_release_getacl(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_getaclres *resp)\r\n{\r\nfh_put(&resp->fh);\r\nposix_acl_release(resp->acl_access);\r\nposix_acl_release(resp->acl_default);\r\nreturn 1;\r\n}
