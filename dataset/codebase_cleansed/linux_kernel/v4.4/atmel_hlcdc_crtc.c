static inline struct atmel_hlcdc_crtc *\r\ndrm_crtc_to_atmel_hlcdc_crtc(struct drm_crtc *crtc)\r\n{\r\nreturn container_of(crtc, struct atmel_hlcdc_crtc, base);\r\n}\r\nstatic void atmel_hlcdc_crtc_mode_set_nofb(struct drm_crtc *c)\r\n{\r\nstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\r\nstruct regmap *regmap = crtc->dc->hlcdc->regmap;\r\nstruct drm_display_mode *adj = &c->state->adjusted_mode;\r\nunsigned long mode_rate;\r\nstruct videomode vm;\r\nunsigned long prate;\r\nunsigned int cfg;\r\nint div;\r\nvm.vfront_porch = adj->crtc_vsync_start - adj->crtc_vdisplay;\r\nvm.vback_porch = adj->crtc_vtotal - adj->crtc_vsync_end;\r\nvm.vsync_len = adj->crtc_vsync_end - adj->crtc_vsync_start;\r\nvm.hfront_porch = adj->crtc_hsync_start - adj->crtc_hdisplay;\r\nvm.hback_porch = adj->crtc_htotal - adj->crtc_hsync_end;\r\nvm.hsync_len = adj->crtc_hsync_end - adj->crtc_hsync_start;\r\nregmap_write(regmap, ATMEL_HLCDC_CFG(1),\r\n(vm.hsync_len - 1) | ((vm.vsync_len - 1) << 16));\r\nregmap_write(regmap, ATMEL_HLCDC_CFG(2),\r\n(vm.vfront_porch - 1) | (vm.vback_porch << 16));\r\nregmap_write(regmap, ATMEL_HLCDC_CFG(3),\r\n(vm.hfront_porch - 1) | ((vm.hback_porch - 1) << 16));\r\nregmap_write(regmap, ATMEL_HLCDC_CFG(4),\r\n(adj->crtc_hdisplay - 1) |\r\n((adj->crtc_vdisplay - 1) << 16));\r\ncfg = 0;\r\nprate = clk_get_rate(crtc->dc->hlcdc->sys_clk);\r\nmode_rate = adj->crtc_clock * 1000;\r\nif ((prate / 2) < mode_rate) {\r\nprate *= 2;\r\ncfg |= ATMEL_HLCDC_CLKSEL;\r\n}\r\ndiv = DIV_ROUND_UP(prate, mode_rate);\r\nif (div < 2)\r\ndiv = 2;\r\ncfg |= ATMEL_HLCDC_CLKDIV(div);\r\nregmap_update_bits(regmap, ATMEL_HLCDC_CFG(0),\r\nATMEL_HLCDC_CLKSEL | ATMEL_HLCDC_CLKDIV_MASK |\r\nATMEL_HLCDC_CLKPOL, cfg);\r\ncfg = 0;\r\nif (adj->flags & DRM_MODE_FLAG_NVSYNC)\r\ncfg |= ATMEL_HLCDC_VSPOL;\r\nif (adj->flags & DRM_MODE_FLAG_NHSYNC)\r\ncfg |= ATMEL_HLCDC_HSPOL;\r\nregmap_update_bits(regmap, ATMEL_HLCDC_CFG(5),\r\nATMEL_HLCDC_HSPOL | ATMEL_HLCDC_VSPOL |\r\nATMEL_HLCDC_VSPDLYS | ATMEL_HLCDC_VSPDLYE |\r\nATMEL_HLCDC_DISPPOL | ATMEL_HLCDC_DISPDLY |\r\nATMEL_HLCDC_VSPSU | ATMEL_HLCDC_VSPHO |\r\nATMEL_HLCDC_GUARDTIME_MASK,\r\ncfg);\r\n}\r\nstatic bool atmel_hlcdc_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void atmel_hlcdc_crtc_disable(struct drm_crtc *c)\r\n{\r\nstruct drm_device *dev = c->dev;\r\nstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\r\nstruct regmap *regmap = crtc->dc->hlcdc->regmap;\r\nunsigned int status;\r\nif (!crtc->enabled)\r\nreturn;\r\ndrm_crtc_vblank_off(c);\r\npm_runtime_get_sync(dev->dev);\r\nregmap_write(regmap, ATMEL_HLCDC_DIS, ATMEL_HLCDC_DISP);\r\nwhile (!regmap_read(regmap, ATMEL_HLCDC_SR, &status) &&\r\n(status & ATMEL_HLCDC_DISP))\r\ncpu_relax();\r\nregmap_write(regmap, ATMEL_HLCDC_DIS, ATMEL_HLCDC_SYNC);\r\nwhile (!regmap_read(regmap, ATMEL_HLCDC_SR, &status) &&\r\n(status & ATMEL_HLCDC_SYNC))\r\ncpu_relax();\r\nregmap_write(regmap, ATMEL_HLCDC_DIS, ATMEL_HLCDC_PIXEL_CLK);\r\nwhile (!regmap_read(regmap, ATMEL_HLCDC_SR, &status) &&\r\n(status & ATMEL_HLCDC_PIXEL_CLK))\r\ncpu_relax();\r\nclk_disable_unprepare(crtc->dc->hlcdc->sys_clk);\r\npinctrl_pm_select_sleep_state(dev->dev);\r\npm_runtime_allow(dev->dev);\r\npm_runtime_put_sync(dev->dev);\r\ncrtc->enabled = false;\r\n}\r\nstatic void atmel_hlcdc_crtc_enable(struct drm_crtc *c)\r\n{\r\nstruct drm_device *dev = c->dev;\r\nstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\r\nstruct regmap *regmap = crtc->dc->hlcdc->regmap;\r\nunsigned int status;\r\nif (crtc->enabled)\r\nreturn;\r\npm_runtime_get_sync(dev->dev);\r\npm_runtime_forbid(dev->dev);\r\npinctrl_pm_select_default_state(dev->dev);\r\nclk_prepare_enable(crtc->dc->hlcdc->sys_clk);\r\nregmap_write(regmap, ATMEL_HLCDC_EN, ATMEL_HLCDC_PIXEL_CLK);\r\nwhile (!regmap_read(regmap, ATMEL_HLCDC_SR, &status) &&\r\n!(status & ATMEL_HLCDC_PIXEL_CLK))\r\ncpu_relax();\r\nregmap_write(regmap, ATMEL_HLCDC_EN, ATMEL_HLCDC_SYNC);\r\nwhile (!regmap_read(regmap, ATMEL_HLCDC_SR, &status) &&\r\n!(status & ATMEL_HLCDC_SYNC))\r\ncpu_relax();\r\nregmap_write(regmap, ATMEL_HLCDC_EN, ATMEL_HLCDC_DISP);\r\nwhile (!regmap_read(regmap, ATMEL_HLCDC_SR, &status) &&\r\n!(status & ATMEL_HLCDC_DISP))\r\ncpu_relax();\r\npm_runtime_put_sync(dev->dev);\r\ndrm_crtc_vblank_on(c);\r\ncrtc->enabled = true;\r\n}\r\nvoid atmel_hlcdc_crtc_suspend(struct drm_crtc *c)\r\n{\r\nstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\r\nif (crtc->enabled) {\r\natmel_hlcdc_crtc_disable(c);\r\ncrtc->enabled = true;\r\n}\r\n}\r\nvoid atmel_hlcdc_crtc_resume(struct drm_crtc *c)\r\n{\r\nstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\r\nif (crtc->enabled) {\r\ncrtc->enabled = false;\r\natmel_hlcdc_crtc_enable(c);\r\n}\r\n}\r\nstatic int atmel_hlcdc_crtc_atomic_check(struct drm_crtc *c,\r\nstruct drm_crtc_state *s)\r\n{\r\nstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\r\nif (atmel_hlcdc_dc_mode_valid(crtc->dc, &s->adjusted_mode) != MODE_OK)\r\nreturn -EINVAL;\r\nreturn atmel_hlcdc_plane_prepare_disc_area(s);\r\n}\r\nstatic void atmel_hlcdc_crtc_atomic_begin(struct drm_crtc *c,\r\nstruct drm_crtc_state *old_s)\r\n{\r\nstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\r\nif (c->state->event) {\r\nc->state->event->pipe = drm_crtc_index(c);\r\nWARN_ON(drm_crtc_vblank_get(c) != 0);\r\ncrtc->event = c->state->event;\r\nc->state->event = NULL;\r\n}\r\n}\r\nstatic void atmel_hlcdc_crtc_atomic_flush(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *old_s)\r\n{\r\n}\r\nstatic void atmel_hlcdc_crtc_destroy(struct drm_crtc *c)\r\n{\r\nstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\r\ndrm_crtc_cleanup(c);\r\nkfree(crtc);\r\n}\r\nvoid atmel_hlcdc_crtc_cancel_page_flip(struct drm_crtc *c,\r\nstruct drm_file *file)\r\n{\r\nstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\r\nstruct drm_pending_vblank_event *event;\r\nstruct drm_device *dev = c->dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nevent = crtc->event;\r\nif (event && event->base.file_priv == file) {\r\nevent->base.destroy(&event->base);\r\ndrm_vblank_put(dev, crtc->id);\r\ncrtc->event = NULL;\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nstatic void atmel_hlcdc_crtc_finish_page_flip(struct atmel_hlcdc_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->base.dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nif (crtc->event) {\r\ndrm_send_vblank_event(dev, crtc->id, crtc->event);\r\ndrm_vblank_put(dev, crtc->id);\r\ncrtc->event = NULL;\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nvoid atmel_hlcdc_crtc_irq(struct drm_crtc *c)\r\n{\r\ndrm_handle_vblank(c->dev, 0);\r\natmel_hlcdc_crtc_finish_page_flip(drm_crtc_to_atmel_hlcdc_crtc(c));\r\n}\r\nint atmel_hlcdc_crtc_create(struct drm_device *dev)\r\n{\r\nstruct atmel_hlcdc_dc *dc = dev->dev_private;\r\nstruct atmel_hlcdc_planes *planes = dc->planes;\r\nstruct atmel_hlcdc_crtc *crtc;\r\nint ret;\r\nint i;\r\ncrtc = kzalloc(sizeof(*crtc), GFP_KERNEL);\r\nif (!crtc)\r\nreturn -ENOMEM;\r\ncrtc->dc = dc;\r\nret = drm_crtc_init_with_planes(dev, &crtc->base,\r\n&planes->primary->base,\r\nplanes->cursor ? &planes->cursor->base : NULL,\r\n&atmel_hlcdc_crtc_funcs);\r\nif (ret < 0)\r\ngoto fail;\r\ncrtc->id = drm_crtc_index(&crtc->base);\r\nif (planes->cursor)\r\nplanes->cursor->base.possible_crtcs = 1 << crtc->id;\r\nfor (i = 0; i < planes->noverlays; i++)\r\nplanes->overlays[i]->base.possible_crtcs = 1 << crtc->id;\r\ndrm_crtc_helper_add(&crtc->base, &lcdc_crtc_helper_funcs);\r\ndrm_crtc_vblank_reset(&crtc->base);\r\ndc->crtc = &crtc->base;\r\nreturn 0;\r\nfail:\r\natmel_hlcdc_crtc_destroy(&crtc->base);\r\nreturn ret;\r\n}
