static int srm_env_proc_show(struct seq_file *m, void *v)\r\n{\r\nunsigned long ret;\r\nunsigned long id = (unsigned long)m->private;\r\nchar *page;\r\npage = (char *)__get_free_page(GFP_USER);\r\nif (!page)\r\nreturn -ENOMEM;\r\nret = callback_getenv(id, page, PAGE_SIZE);\r\nif ((ret >> 61) == 0) {\r\nseq_write(m, page, ret);\r\nret = 0;\r\n} else\r\nret = -EFAULT;\r\nfree_page((unsigned long)page);\r\nreturn ret;\r\n}\r\nstatic int srm_env_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, srm_env_proc_show, PDE_DATA(inode));\r\n}\r\nstatic ssize_t srm_env_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nint res;\r\nunsigned long id = (unsigned long)PDE_DATA(file_inode(file));\r\nchar *buf = (char *) __get_free_page(GFP_USER);\r\nunsigned long ret1, ret2;\r\nif (!buf)\r\nreturn -ENOMEM;\r\nres = -EINVAL;\r\nif (count >= PAGE_SIZE)\r\ngoto out;\r\nres = -EFAULT;\r\nif (copy_from_user(buf, buffer, count))\r\ngoto out;\r\nbuf[count] = '\0';\r\nret1 = callback_setenv(id, buf, count);\r\nif ((ret1 >> 61) == 0) {\r\ndo\r\nret2 = callback_save_env();\r\nwhile((ret2 >> 61) == 1);\r\nres = (int) ret1;\r\n}\r\nout:\r\nfree_page((unsigned long)buf);\r\nreturn res;\r\n}\r\nstatic int __init\r\nsrm_env_init(void)\r\n{\r\nsrm_env_t *entry;\r\nunsigned long var_num;\r\nif (!alpha_using_srm) {\r\nprintk(KERN_INFO "%s: This Alpha system doesn't "\r\n"know about SRM (or you've booted "\r\n"SRM->MILO->Linux, which gets "\r\n"misdetected)...\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nbase_dir = proc_mkdir(BASE_DIR, NULL);\r\nif (!base_dir) {\r\nprintk(KERN_ERR "Couldn't create base dir /proc/%s\n",\r\nBASE_DIR);\r\nreturn -ENOMEM;\r\n}\r\nnamed_dir = proc_mkdir(NAMED_DIR, base_dir);\r\nif (!named_dir) {\r\nprintk(KERN_ERR "Couldn't create dir /proc/%s/%s\n",\r\nBASE_DIR, NAMED_DIR);\r\ngoto cleanup;\r\n}\r\nnumbered_dir = proc_mkdir(NUMBERED_DIR, base_dir);\r\nif (!numbered_dir) {\r\nprintk(KERN_ERR "Couldn't create dir /proc/%s/%s\n",\r\nBASE_DIR, NUMBERED_DIR);\r\ngoto cleanup;\r\n}\r\nentry = srm_named_entries;\r\nwhile (entry->name && entry->id) {\r\nif (!proc_create_data(entry->name, 0644, named_dir,\r\n&srm_env_proc_fops, (void *)entry->id))\r\ngoto cleanup;\r\nentry++;\r\n}\r\nfor (var_num = 0; var_num <= 255; var_num++) {\r\nchar name[4];\r\nsprintf(name, "%ld", var_num);\r\nif (!proc_create_data(name, 0644, numbered_dir,\r\n&srm_env_proc_fops, (void *)var_num))\r\ngoto cleanup;\r\n}\r\nprintk(KERN_INFO "%s: version %s loaded successfully\n", NAME,\r\nVERSION);\r\nreturn 0;\r\ncleanup:\r\nremove_proc_subtree(BASE_DIR, NULL);\r\nreturn -ENOMEM;\r\n}\r\nstatic void __exit\r\nsrm_env_exit(void)\r\n{\r\nremove_proc_subtree(BASE_DIR, NULL);\r\nprintk(KERN_INFO "%s: unloaded successfully\n", NAME);\r\n}
