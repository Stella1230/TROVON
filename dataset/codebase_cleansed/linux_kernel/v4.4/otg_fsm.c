static ssize_t\r\nget_a_bus_req(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nchar *next;\r\nunsigned size, t;\r\nstruct ci_hdrc *ci = dev_get_drvdata(dev);\r\nnext = buf;\r\nsize = PAGE_SIZE;\r\nt = scnprintf(next, size, "%d\n", ci->fsm.a_bus_req);\r\nsize -= t;\r\nnext += t;\r\nreturn PAGE_SIZE - size;\r\n}\r\nstatic ssize_t\r\nset_a_bus_req(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ci_hdrc *ci = dev_get_drvdata(dev);\r\nif (count > 2)\r\nreturn -1;\r\nmutex_lock(&ci->fsm.lock);\r\nif (buf[0] == '0') {\r\nci->fsm.a_bus_req = 0;\r\n} else if (buf[0] == '1') {\r\nif (ci->fsm.a_bus_drop) {\r\nmutex_unlock(&ci->fsm.lock);\r\nreturn count;\r\n}\r\nci->fsm.a_bus_req = 1;\r\n}\r\nci_otg_queue_work(ci);\r\nmutex_unlock(&ci->fsm.lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nget_a_bus_drop(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nchar *next;\r\nunsigned size, t;\r\nstruct ci_hdrc *ci = dev_get_drvdata(dev);\r\nnext = buf;\r\nsize = PAGE_SIZE;\r\nt = scnprintf(next, size, "%d\n", ci->fsm.a_bus_drop);\r\nsize -= t;\r\nnext += t;\r\nreturn PAGE_SIZE - size;\r\n}\r\nstatic ssize_t\r\nset_a_bus_drop(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ci_hdrc *ci = dev_get_drvdata(dev);\r\nif (count > 2)\r\nreturn -1;\r\nmutex_lock(&ci->fsm.lock);\r\nif (buf[0] == '0') {\r\nci->fsm.a_bus_drop = 0;\r\n} else if (buf[0] == '1') {\r\nci->fsm.a_bus_drop = 1;\r\nci->fsm.a_bus_req = 0;\r\n}\r\nci_otg_queue_work(ci);\r\nmutex_unlock(&ci->fsm.lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nget_b_bus_req(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nchar *next;\r\nunsigned size, t;\r\nstruct ci_hdrc *ci = dev_get_drvdata(dev);\r\nnext = buf;\r\nsize = PAGE_SIZE;\r\nt = scnprintf(next, size, "%d\n", ci->fsm.b_bus_req);\r\nsize -= t;\r\nnext += t;\r\nreturn PAGE_SIZE - size;\r\n}\r\nstatic ssize_t\r\nset_b_bus_req(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ci_hdrc *ci = dev_get_drvdata(dev);\r\nif (count > 2)\r\nreturn -1;\r\nmutex_lock(&ci->fsm.lock);\r\nif (buf[0] == '0')\r\nci->fsm.b_bus_req = 0;\r\nelse if (buf[0] == '1')\r\nci->fsm.b_bus_req = 1;\r\nci_otg_queue_work(ci);\r\nmutex_unlock(&ci->fsm.lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nset_a_clr_err(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ci_hdrc *ci = dev_get_drvdata(dev);\r\nif (count > 2)\r\nreturn -1;\r\nmutex_lock(&ci->fsm.lock);\r\nif (buf[0] == '1')\r\nci->fsm.a_clr_err = 1;\r\nci_otg_queue_work(ci);\r\nmutex_unlock(&ci->fsm.lock);\r\nreturn count;\r\n}\r\nstatic void ci_otg_add_timer(struct ci_hdrc *ci, enum otg_fsm_timer t)\r\n{\r\nunsigned long flags, timer_sec, timer_nsec;\r\nif (t >= NUM_OTG_FSM_TIMERS)\r\nreturn;\r\nspin_lock_irqsave(&ci->lock, flags);\r\ntimer_sec = otg_timer_ms[t] / MSEC_PER_SEC;\r\ntimer_nsec = (otg_timer_ms[t] % MSEC_PER_SEC) * NSEC_PER_MSEC;\r\nci->hr_timeouts[t] = ktime_add(ktime_get(),\r\nktime_set(timer_sec, timer_nsec));\r\nci->enabled_otg_timer_bits |= (1 << t);\r\nif ((ci->next_otg_timer == NUM_OTG_FSM_TIMERS) ||\r\n(ci->hr_timeouts[ci->next_otg_timer].tv64 >\r\nci->hr_timeouts[t].tv64)) {\r\nci->next_otg_timer = t;\r\nhrtimer_start_range_ns(&ci->otg_fsm_hrtimer,\r\nci->hr_timeouts[t], NSEC_PER_MSEC,\r\nHRTIMER_MODE_ABS);\r\n}\r\nspin_unlock_irqrestore(&ci->lock, flags);\r\n}\r\nstatic void ci_otg_del_timer(struct ci_hdrc *ci, enum otg_fsm_timer t)\r\n{\r\nunsigned long flags, enabled_timer_bits;\r\nenum otg_fsm_timer cur_timer, next_timer = NUM_OTG_FSM_TIMERS;\r\nif ((t >= NUM_OTG_FSM_TIMERS) ||\r\n!(ci->enabled_otg_timer_bits & (1 << t)))\r\nreturn;\r\nspin_lock_irqsave(&ci->lock, flags);\r\nci->enabled_otg_timer_bits &= ~(1 << t);\r\nif (ci->next_otg_timer == t) {\r\nif (ci->enabled_otg_timer_bits == 0) {\r\nhrtimer_cancel(&ci->otg_fsm_hrtimer);\r\nci->next_otg_timer = NUM_OTG_FSM_TIMERS;\r\n} else {\r\nenabled_timer_bits = ci->enabled_otg_timer_bits;\r\nfor_each_set_bit(cur_timer, &enabled_timer_bits,\r\nNUM_OTG_FSM_TIMERS) {\r\nif ((next_timer == NUM_OTG_FSM_TIMERS) ||\r\n(ci->hr_timeouts[next_timer].tv64 <\r\nci->hr_timeouts[cur_timer].tv64))\r\nnext_timer = cur_timer;\r\n}\r\n}\r\n}\r\nif (next_timer != NUM_OTG_FSM_TIMERS) {\r\nci->next_otg_timer = next_timer;\r\nhrtimer_start_range_ns(&ci->otg_fsm_hrtimer,\r\nci->hr_timeouts[next_timer], NSEC_PER_MSEC,\r\nHRTIMER_MODE_ABS);\r\n}\r\nspin_unlock_irqrestore(&ci->lock, flags);\r\n}\r\nstatic int a_wait_vrise_tmout(struct ci_hdrc *ci)\r\n{\r\nci->fsm.a_wait_vrise_tmout = 1;\r\nreturn 0;\r\n}\r\nstatic int a_wait_vfall_tmout(struct ci_hdrc *ci)\r\n{\r\nci->fsm.a_wait_vfall_tmout = 1;\r\nreturn 0;\r\n}\r\nstatic int a_wait_bcon_tmout(struct ci_hdrc *ci)\r\n{\r\nci->fsm.a_wait_bcon_tmout = 1;\r\nreturn 0;\r\n}\r\nstatic int a_aidl_bdis_tmout(struct ci_hdrc *ci)\r\n{\r\nci->fsm.a_aidl_bdis_tmout = 1;\r\nreturn 0;\r\n}\r\nstatic int b_ase0_brst_tmout(struct ci_hdrc *ci)\r\n{\r\nci->fsm.b_ase0_brst_tmout = 1;\r\nreturn 0;\r\n}\r\nstatic int a_bidl_adis_tmout(struct ci_hdrc *ci)\r\n{\r\nci->fsm.a_bidl_adis_tmout = 1;\r\nreturn 0;\r\n}\r\nstatic int b_se0_srp_tmout(struct ci_hdrc *ci)\r\n{\r\nci->fsm.b_se0_srp = 1;\r\nreturn 0;\r\n}\r\nstatic int b_srp_fail_tmout(struct ci_hdrc *ci)\r\n{\r\nci->fsm.b_srp_done = 1;\r\nreturn 1;\r\n}\r\nstatic int b_data_pls_tmout(struct ci_hdrc *ci)\r\n{\r\nci->fsm.b_srp_done = 1;\r\nci->fsm.b_bus_req = 0;\r\nif (ci->fsm.power_up)\r\nci->fsm.power_up = 0;\r\nhw_write_otgsc(ci, OTGSC_HABA, 0);\r\npm_runtime_put(ci->dev);\r\nreturn 0;\r\n}\r\nstatic int b_ssend_srp_tmout(struct ci_hdrc *ci)\r\n{\r\nci->fsm.b_ssend_srp = 1;\r\nif (ci->fsm.otg->state == OTG_STATE_B_IDLE)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic enum hrtimer_restart ci_otg_hrtimer_func(struct hrtimer *t)\r\n{\r\nstruct ci_hdrc *ci = container_of(t, struct ci_hdrc, otg_fsm_hrtimer);\r\nktime_t now, *timeout;\r\nunsigned long enabled_timer_bits;\r\nunsigned long flags;\r\nenum otg_fsm_timer cur_timer, next_timer = NUM_OTG_FSM_TIMERS;\r\nint ret = -EINVAL;\r\nspin_lock_irqsave(&ci->lock, flags);\r\nenabled_timer_bits = ci->enabled_otg_timer_bits;\r\nci->next_otg_timer = NUM_OTG_FSM_TIMERS;\r\nnow = ktime_get();\r\nfor_each_set_bit(cur_timer, &enabled_timer_bits, NUM_OTG_FSM_TIMERS) {\r\nif (now.tv64 >= ci->hr_timeouts[cur_timer].tv64) {\r\nci->enabled_otg_timer_bits &= ~(1 << cur_timer);\r\nif (otg_timer_handlers[cur_timer])\r\nret = otg_timer_handlers[cur_timer](ci);\r\n} else {\r\nif ((next_timer == NUM_OTG_FSM_TIMERS) ||\r\n(ci->hr_timeouts[cur_timer].tv64 <\r\nci->hr_timeouts[next_timer].tv64))\r\nnext_timer = cur_timer;\r\n}\r\n}\r\nif (next_timer < NUM_OTG_FSM_TIMERS) {\r\ntimeout = &ci->hr_timeouts[next_timer];\r\nhrtimer_start_range_ns(&ci->otg_fsm_hrtimer, *timeout,\r\nNSEC_PER_MSEC, HRTIMER_MODE_ABS);\r\nci->next_otg_timer = next_timer;\r\n}\r\nspin_unlock_irqrestore(&ci->lock, flags);\r\nif (!ret)\r\nci_otg_queue_work(ci);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic int ci_otg_init_timers(struct ci_hdrc *ci)\r\n{\r\nhrtimer_init(&ci->otg_fsm_hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\r\nci->otg_fsm_hrtimer.function = ci_otg_hrtimer_func;\r\nreturn 0;\r\n}\r\nstatic void ci_otg_fsm_add_timer(struct otg_fsm *fsm, enum otg_fsm_timer t)\r\n{\r\nstruct ci_hdrc *ci = container_of(fsm, struct ci_hdrc, fsm);\r\nif (t < NUM_OTG_FSM_TIMERS)\r\nci_otg_add_timer(ci, t);\r\nreturn;\r\n}\r\nstatic void ci_otg_fsm_del_timer(struct otg_fsm *fsm, enum otg_fsm_timer t)\r\n{\r\nstruct ci_hdrc *ci = container_of(fsm, struct ci_hdrc, fsm);\r\nif (t < NUM_OTG_FSM_TIMERS)\r\nci_otg_del_timer(ci, t);\r\nreturn;\r\n}\r\nstatic void ci_otg_drv_vbus(struct otg_fsm *fsm, int on)\r\n{\r\nint ret;\r\nstruct ci_hdrc *ci = container_of(fsm, struct ci_hdrc, fsm);\r\nif (on) {\r\nhw_write(ci, OP_PORTSC, PORTSC_W1C_BITS | PORTSC_PP,\r\nPORTSC_PP);\r\nif (ci->platdata->reg_vbus) {\r\nret = regulator_enable(ci->platdata->reg_vbus);\r\nif (ret) {\r\ndev_err(ci->dev,\r\n"Failed to enable vbus regulator, ret=%d\n",\r\nret);\r\nreturn;\r\n}\r\n}\r\nhw_write_otgsc(ci, OTGSC_DPIE, 0);\r\nfsm->a_srp_det = 0;\r\nfsm->power_up = 0;\r\n} else {\r\nif (ci->platdata->reg_vbus)\r\nregulator_disable(ci->platdata->reg_vbus);\r\nfsm->a_bus_drop = 1;\r\nfsm->a_bus_req = 0;\r\n}\r\n}\r\nstatic void ci_otg_loc_conn(struct otg_fsm *fsm, int on)\r\n{\r\nstruct ci_hdrc *ci = container_of(fsm, struct ci_hdrc, fsm);\r\nif (on)\r\nhw_write(ci, OP_USBCMD, USBCMD_RS, USBCMD_RS);\r\nelse\r\nhw_write(ci, OP_USBCMD, USBCMD_RS, 0);\r\n}\r\nstatic void ci_otg_loc_sof(struct otg_fsm *fsm, int on)\r\n{\r\nstruct ci_hdrc *ci = container_of(fsm, struct ci_hdrc, fsm);\r\nif (on)\r\nhw_write(ci, OP_PORTSC, PORTSC_W1C_BITS | PORTSC_FPR,\r\nPORTSC_FPR);\r\nelse\r\nhw_write(ci, OP_PORTSC, PORTSC_W1C_BITS | PORTSC_SUSP,\r\nPORTSC_SUSP);\r\n}\r\nstatic void ci_otg_start_pulse(struct otg_fsm *fsm)\r\n{\r\nstruct ci_hdrc *ci = container_of(fsm, struct ci_hdrc, fsm);\r\nhw_write_otgsc(ci, OTGSC_HADP, OTGSC_HADP);\r\npm_runtime_get(ci->dev);\r\nci_otg_add_timer(ci, B_DATA_PLS);\r\n}\r\nstatic int ci_otg_start_host(struct otg_fsm *fsm, int on)\r\n{\r\nstruct ci_hdrc *ci = container_of(fsm, struct ci_hdrc, fsm);\r\nif (on) {\r\nci_role_stop(ci);\r\nci_role_start(ci, CI_ROLE_HOST);\r\n} else {\r\nci_role_stop(ci);\r\nci_role_start(ci, CI_ROLE_GADGET);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_otg_start_gadget(struct otg_fsm *fsm, int on)\r\n{\r\nstruct ci_hdrc *ci = container_of(fsm, struct ci_hdrc, fsm);\r\nif (on)\r\nusb_gadget_vbus_connect(&ci->gadget);\r\nelse\r\nusb_gadget_vbus_disconnect(&ci->gadget);\r\nreturn 0;\r\n}\r\nint ci_otg_fsm_work(struct ci_hdrc *ci)\r\n{\r\nif (ci->fsm.id && !(ci->driver) &&\r\nci->fsm.otg->state < OTG_STATE_A_IDLE)\r\nreturn 0;\r\npm_runtime_get_sync(ci->dev);\r\nif (otg_statemachine(&ci->fsm)) {\r\nif (ci->fsm.otg->state == OTG_STATE_A_IDLE) {\r\nif ((ci->fsm.id) || (ci->id_event) ||\r\n(ci->fsm.power_up)) {\r\nci_otg_queue_work(ci);\r\n} else {\r\nhw_write(ci, OP_PORTSC, PORTSC_W1C_BITS |\r\nPORTSC_PP, 0);\r\nhw_write_otgsc(ci, OTGSC_DPIS, OTGSC_DPIS);\r\nhw_write_otgsc(ci, OTGSC_DPIE, OTGSC_DPIE);\r\n}\r\nif (ci->id_event)\r\nci->id_event = false;\r\n} else if (ci->fsm.otg->state == OTG_STATE_B_IDLE) {\r\nif (ci->fsm.b_sess_vld) {\r\nci->fsm.power_up = 0;\r\nci_otg_queue_work(ci);\r\n}\r\n} else if (ci->fsm.otg->state == OTG_STATE_A_HOST) {\r\npm_runtime_mark_last_busy(ci->dev);\r\npm_runtime_put_autosuspend(ci->dev);\r\nreturn 0;\r\n}\r\n}\r\npm_runtime_put_sync(ci->dev);\r\nreturn 0;\r\n}\r\nstatic void ci_otg_fsm_event(struct ci_hdrc *ci)\r\n{\r\nu32 intr_sts, otg_bsess_vld, port_conn;\r\nstruct otg_fsm *fsm = &ci->fsm;\r\nintr_sts = hw_read_intr_status(ci);\r\notg_bsess_vld = hw_read_otgsc(ci, OTGSC_BSV);\r\nport_conn = hw_read(ci, OP_PORTSC, PORTSC_CCS);\r\nswitch (ci->fsm.otg->state) {\r\ncase OTG_STATE_A_WAIT_BCON:\r\nif (port_conn) {\r\nfsm->b_conn = 1;\r\nfsm->a_bus_req = 1;\r\nci_otg_queue_work(ci);\r\n}\r\nbreak;\r\ncase OTG_STATE_B_IDLE:\r\nif (otg_bsess_vld && (intr_sts & USBi_PCI) && port_conn) {\r\nfsm->b_sess_vld = 1;\r\nci_otg_queue_work(ci);\r\n}\r\nbreak;\r\ncase OTG_STATE_B_PERIPHERAL:\r\nif ((intr_sts & USBi_SLI) && port_conn && otg_bsess_vld) {\r\nfsm->a_bus_suspend = 1;\r\nci_otg_queue_work(ci);\r\n} else if (intr_sts & USBi_PCI) {\r\nif (fsm->a_bus_suspend == 1)\r\nfsm->a_bus_suspend = 0;\r\n}\r\nbreak;\r\ncase OTG_STATE_B_HOST:\r\nif ((intr_sts & USBi_PCI) && !port_conn) {\r\nfsm->a_conn = 0;\r\nfsm->b_bus_req = 0;\r\nci_otg_queue_work(ci);\r\n}\r\nbreak;\r\ncase OTG_STATE_A_PERIPHERAL:\r\nif (intr_sts & USBi_SLI) {\r\nfsm->b_bus_suspend = 1;\r\nci_otg_add_timer(ci, A_BIDL_ADIS);\r\n}\r\nif (intr_sts & USBi_URI)\r\nci_otg_del_timer(ci, A_BIDL_ADIS);\r\nif (intr_sts & USBi_PCI) {\r\nif (fsm->b_bus_suspend == 1) {\r\nci_otg_del_timer(ci, A_BIDL_ADIS);\r\nfsm->b_bus_suspend = 0;\r\n}\r\n}\r\nbreak;\r\ncase OTG_STATE_A_SUSPEND:\r\nif ((intr_sts & USBi_PCI) && !port_conn) {\r\nfsm->b_conn = 0;\r\nif (ci->driver) {\r\nci->gadget.is_a_peripheral = 1;\r\n}\r\nci_otg_queue_work(ci);\r\n}\r\nbreak;\r\ncase OTG_STATE_A_HOST:\r\nif ((intr_sts & USBi_PCI) && !port_conn) {\r\nfsm->b_conn = 0;\r\nci_otg_queue_work(ci);\r\n}\r\nbreak;\r\ncase OTG_STATE_B_WAIT_ACON:\r\nif ((intr_sts & USBi_PCI) && port_conn) {\r\nfsm->a_conn = 1;\r\nci_otg_queue_work(ci);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nirqreturn_t ci_otg_fsm_irq(struct ci_hdrc *ci)\r\n{\r\nirqreturn_t retval = IRQ_NONE;\r\nu32 otgsc, otg_int_src = 0;\r\nstruct otg_fsm *fsm = &ci->fsm;\r\notgsc = hw_read_otgsc(ci, ~0);\r\notg_int_src = otgsc & OTGSC_INT_STATUS_BITS & (otgsc >> 8);\r\nfsm->id = (otgsc & OTGSC_ID) ? 1 : 0;\r\nif (otg_int_src) {\r\nif (otg_int_src & OTGSC_DPIS) {\r\nhw_write_otgsc(ci, OTGSC_DPIS, OTGSC_DPIS);\r\nfsm->a_srp_det = 1;\r\nfsm->a_bus_drop = 0;\r\n} else if (otg_int_src & OTGSC_IDIS) {\r\nhw_write_otgsc(ci, OTGSC_IDIS, OTGSC_IDIS);\r\nif (fsm->id == 0) {\r\nfsm->a_bus_drop = 0;\r\nfsm->a_bus_req = 1;\r\nci->id_event = true;\r\n}\r\n} else if (otg_int_src & OTGSC_BSVIS) {\r\nhw_write_otgsc(ci, OTGSC_BSVIS, OTGSC_BSVIS);\r\nif (otgsc & OTGSC_BSV) {\r\nfsm->b_sess_vld = 1;\r\nci_otg_del_timer(ci, B_SSEND_SRP);\r\nci_otg_del_timer(ci, B_SRP_FAIL);\r\nfsm->b_ssend_srp = 0;\r\n} else {\r\nfsm->b_sess_vld = 0;\r\nif (fsm->id)\r\nci_otg_add_timer(ci, B_SSEND_SRP);\r\n}\r\n} else if (otg_int_src & OTGSC_AVVIS) {\r\nhw_write_otgsc(ci, OTGSC_AVVIS, OTGSC_AVVIS);\r\nif (otgsc & OTGSC_AVV) {\r\nfsm->a_vbus_vld = 1;\r\n} else {\r\nfsm->a_vbus_vld = 0;\r\nfsm->b_conn = 0;\r\n}\r\n}\r\nci_otg_queue_work(ci);\r\nreturn IRQ_HANDLED;\r\n}\r\nci_otg_fsm_event(ci);\r\nreturn retval;\r\n}\r\nvoid ci_hdrc_otg_fsm_start(struct ci_hdrc *ci)\r\n{\r\nci_otg_queue_work(ci);\r\n}\r\nint ci_hdrc_otg_fsm_init(struct ci_hdrc *ci)\r\n{\r\nint retval = 0;\r\nif (ci->phy)\r\nci->otg.phy = ci->phy;\r\nelse\r\nci->otg.usb_phy = ci->usb_phy;\r\nci->otg.gadget = &ci->gadget;\r\nci->fsm.otg = &ci->otg;\r\nci->fsm.power_up = 1;\r\nci->fsm.id = hw_read_otgsc(ci, OTGSC_ID) ? 1 : 0;\r\nci->fsm.otg->state = OTG_STATE_UNDEFINED;\r\nci->fsm.ops = &ci_otg_ops;\r\nmutex_init(&ci->fsm.lock);\r\nretval = ci_otg_init_timers(ci);\r\nif (retval) {\r\ndev_err(ci->dev, "Couldn't init OTG timers\n");\r\nreturn retval;\r\n}\r\nci->enabled_otg_timer_bits = 0;\r\nci->next_otg_timer = NUM_OTG_FSM_TIMERS;\r\nretval = sysfs_create_group(&ci->dev->kobj, &inputs_attr_group);\r\nif (retval < 0) {\r\ndev_dbg(ci->dev,\r\n"Can't register sysfs attr group: %d\n", retval);\r\nreturn retval;\r\n}\r\nhw_write_otgsc(ci, OTGSC_AVVIE, OTGSC_AVVIE);\r\nif (ci->fsm.id) {\r\nci->fsm.b_ssend_srp =\r\nhw_read_otgsc(ci, OTGSC_BSV) ? 0 : 1;\r\nci->fsm.b_sess_vld =\r\nhw_read_otgsc(ci, OTGSC_BSV) ? 1 : 0;\r\nhw_write_otgsc(ci, OTGSC_BSVIE, OTGSC_BSVIE);\r\n}\r\nreturn 0;\r\n}\r\nvoid ci_hdrc_otg_fsm_remove(struct ci_hdrc *ci)\r\n{\r\nsysfs_remove_group(&ci->dev->kobj, &inputs_attr_group);\r\n}
