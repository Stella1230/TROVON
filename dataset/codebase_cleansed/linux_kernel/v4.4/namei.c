static inline int ufs_add_nondir(struct dentry *dentry, struct inode *inode)\r\n{\r\nint err = ufs_add_link(dentry, inode);\r\nif (!err) {\r\nunlock_new_inode(inode);\r\nd_instantiate(dentry, inode);\r\nreturn 0;\r\n}\r\ninode_dec_link_count(inode);\r\nunlock_new_inode(inode);\r\niput(inode);\r\nreturn err;\r\n}\r\nstatic struct dentry *ufs_lookup(struct inode * dir, struct dentry *dentry, unsigned int flags)\r\n{\r\nstruct inode * inode = NULL;\r\nino_t ino;\r\nif (dentry->d_name.len > UFS_MAXNAMLEN)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nino = ufs_inode_by_name(dir, &dentry->d_name);\r\nif (ino)\r\ninode = ufs_iget(dir->i_sb, ino);\r\nreturn d_splice_alias(inode, dentry);\r\n}\r\nstatic int ufs_create (struct inode * dir, struct dentry * dentry, umode_t mode,\r\nbool excl)\r\n{\r\nstruct inode *inode;\r\ninode = ufs_new_inode(dir, mode);\r\nif (IS_ERR(inode))\r\nreturn PTR_ERR(inode);\r\ninode->i_op = &ufs_file_inode_operations;\r\ninode->i_fop = &ufs_file_operations;\r\ninode->i_mapping->a_ops = &ufs_aops;\r\nmark_inode_dirty(inode);\r\nreturn ufs_add_nondir(dentry, inode);\r\n}\r\nstatic int ufs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t rdev)\r\n{\r\nstruct inode *inode;\r\nint err;\r\nif (!old_valid_dev(rdev))\r\nreturn -EINVAL;\r\ninode = ufs_new_inode(dir, mode);\r\nerr = PTR_ERR(inode);\r\nif (!IS_ERR(inode)) {\r\ninit_special_inode(inode, mode, rdev);\r\nufs_set_inode_dev(inode->i_sb, UFS_I(inode), rdev);\r\nmark_inode_dirty(inode);\r\nerr = ufs_add_nondir(dentry, inode);\r\n}\r\nreturn err;\r\n}\r\nstatic int ufs_symlink (struct inode * dir, struct dentry * dentry,\r\nconst char * symname)\r\n{\r\nstruct super_block * sb = dir->i_sb;\r\nint err;\r\nunsigned l = strlen(symname)+1;\r\nstruct inode * inode;\r\nif (l > sb->s_blocksize)\r\nreturn -ENAMETOOLONG;\r\ninode = ufs_new_inode(dir, S_IFLNK | S_IRWXUGO);\r\nerr = PTR_ERR(inode);\r\nif (IS_ERR(inode))\r\nreturn err;\r\nif (l > UFS_SB(sb)->s_uspi->s_maxsymlinklen) {\r\ninode->i_op = &ufs_symlink_inode_operations;\r\ninode->i_mapping->a_ops = &ufs_aops;\r\nerr = page_symlink(inode, symname, l);\r\nif (err)\r\ngoto out_fail;\r\n} else {\r\ninode->i_op = &ufs_fast_symlink_inode_operations;\r\ninode->i_link = (char *)UFS_I(inode)->i_u1.i_symlink;\r\nmemcpy(inode->i_link, symname, l);\r\ninode->i_size = l-1;\r\n}\r\nmark_inode_dirty(inode);\r\nreturn ufs_add_nondir(dentry, inode);\r\nout_fail:\r\ninode_dec_link_count(inode);\r\nunlock_new_inode(inode);\r\niput(inode);\r\nreturn err;\r\n}\r\nstatic int ufs_link (struct dentry * old_dentry, struct inode * dir,\r\nstruct dentry *dentry)\r\n{\r\nstruct inode *inode = d_inode(old_dentry);\r\nint error;\r\ninode->i_ctime = CURRENT_TIME_SEC;\r\ninode_inc_link_count(inode);\r\nihold(inode);\r\nerror = ufs_add_link(dentry, inode);\r\nif (error) {\r\ninode_dec_link_count(inode);\r\niput(inode);\r\n} else\r\nd_instantiate(dentry, inode);\r\nreturn error;\r\n}\r\nstatic int ufs_mkdir(struct inode * dir, struct dentry * dentry, umode_t mode)\r\n{\r\nstruct inode * inode;\r\nint err;\r\ninode_inc_link_count(dir);\r\ninode = ufs_new_inode(dir, S_IFDIR|mode);\r\nerr = PTR_ERR(inode);\r\nif (IS_ERR(inode))\r\ngoto out_dir;\r\ninode->i_op = &ufs_dir_inode_operations;\r\ninode->i_fop = &ufs_dir_operations;\r\ninode->i_mapping->a_ops = &ufs_aops;\r\ninode_inc_link_count(inode);\r\nerr = ufs_make_empty(inode, dir);\r\nif (err)\r\ngoto out_fail;\r\nerr = ufs_add_link(dentry, inode);\r\nif (err)\r\ngoto out_fail;\r\nunlock_new_inode(inode);\r\nd_instantiate(dentry, inode);\r\nreturn 0;\r\nout_fail:\r\ninode_dec_link_count(inode);\r\ninode_dec_link_count(inode);\r\nunlock_new_inode(inode);\r\niput (inode);\r\nout_dir:\r\ninode_dec_link_count(dir);\r\nreturn err;\r\n}\r\nstatic int ufs_unlink(struct inode *dir, struct dentry *dentry)\r\n{\r\nstruct inode * inode = d_inode(dentry);\r\nstruct ufs_dir_entry *de;\r\nstruct page *page;\r\nint err = -ENOENT;\r\nde = ufs_find_entry(dir, &dentry->d_name, &page);\r\nif (!de)\r\ngoto out;\r\nerr = ufs_delete_entry(dir, de, page);\r\nif (err)\r\ngoto out;\r\ninode->i_ctime = dir->i_ctime;\r\ninode_dec_link_count(inode);\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int ufs_rmdir (struct inode * dir, struct dentry *dentry)\r\n{\r\nstruct inode * inode = d_inode(dentry);\r\nint err= -ENOTEMPTY;\r\nif (ufs_empty_dir (inode)) {\r\nerr = ufs_unlink(dir, dentry);\r\nif (!err) {\r\ninode->i_size = 0;\r\ninode_dec_link_count(inode);\r\ninode_dec_link_count(dir);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int ufs_rename(struct inode *old_dir, struct dentry *old_dentry,\r\nstruct inode *new_dir, struct dentry *new_dentry)\r\n{\r\nstruct inode *old_inode = d_inode(old_dentry);\r\nstruct inode *new_inode = d_inode(new_dentry);\r\nstruct page *dir_page = NULL;\r\nstruct ufs_dir_entry * dir_de = NULL;\r\nstruct page *old_page;\r\nstruct ufs_dir_entry *old_de;\r\nint err = -ENOENT;\r\nold_de = ufs_find_entry(old_dir, &old_dentry->d_name, &old_page);\r\nif (!old_de)\r\ngoto out;\r\nif (S_ISDIR(old_inode->i_mode)) {\r\nerr = -EIO;\r\ndir_de = ufs_dotdot(old_inode, &dir_page);\r\nif (!dir_de)\r\ngoto out_old;\r\n}\r\nif (new_inode) {\r\nstruct page *new_page;\r\nstruct ufs_dir_entry *new_de;\r\nerr = -ENOTEMPTY;\r\nif (dir_de && !ufs_empty_dir(new_inode))\r\ngoto out_dir;\r\nerr = -ENOENT;\r\nnew_de = ufs_find_entry(new_dir, &new_dentry->d_name, &new_page);\r\nif (!new_de)\r\ngoto out_dir;\r\nufs_set_link(new_dir, new_de, new_page, old_inode, 1);\r\nnew_inode->i_ctime = CURRENT_TIME_SEC;\r\nif (dir_de)\r\ndrop_nlink(new_inode);\r\ninode_dec_link_count(new_inode);\r\n} else {\r\nerr = ufs_add_link(new_dentry, old_inode);\r\nif (err)\r\ngoto out_dir;\r\nif (dir_de)\r\ninode_inc_link_count(new_dir);\r\n}\r\nold_inode->i_ctime = CURRENT_TIME_SEC;\r\nufs_delete_entry(old_dir, old_de, old_page);\r\nmark_inode_dirty(old_inode);\r\nif (dir_de) {\r\nif (old_dir != new_dir)\r\nufs_set_link(old_inode, dir_de, dir_page, new_dir, 0);\r\nelse {\r\nkunmap(dir_page);\r\npage_cache_release(dir_page);\r\n}\r\ninode_dec_link_count(old_dir);\r\n}\r\nreturn 0;\r\nout_dir:\r\nif (dir_de) {\r\nkunmap(dir_page);\r\npage_cache_release(dir_page);\r\n}\r\nout_old:\r\nkunmap(old_page);\r\npage_cache_release(old_page);\r\nout:\r\nreturn err;\r\n}
