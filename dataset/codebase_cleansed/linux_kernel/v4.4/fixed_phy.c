static int fixed_phy_update_regs(struct fixed_phy *fp)\r\n{\r\nu16 bmsr = BMSR_ANEGCAPABLE;\r\nu16 bmcr = 0;\r\nu16 lpagb = 0;\r\nu16 lpa = 0;\r\nif (gpio_is_valid(fp->link_gpio))\r\nfp->status.link = !!gpio_get_value_cansleep(fp->link_gpio);\r\nif (fp->status.duplex) {\r\nswitch (fp->status.speed) {\r\ncase 1000:\r\nbmsr |= BMSR_ESTATEN;\r\nbreak;\r\ncase 100:\r\nbmsr |= BMSR_100FULL;\r\nbreak;\r\ncase 10:\r\nbmsr |= BMSR_10FULL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nswitch (fp->status.speed) {\r\ncase 1000:\r\nbmsr |= BMSR_ESTATEN;\r\nbreak;\r\ncase 100:\r\nbmsr |= BMSR_100HALF;\r\nbreak;\r\ncase 10:\r\nbmsr |= BMSR_10HALF;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (fp->status.link) {\r\nbmsr |= BMSR_LSTATUS | BMSR_ANEGCOMPLETE;\r\nif (fp->status.duplex) {\r\nbmcr |= BMCR_FULLDPLX;\r\nswitch (fp->status.speed) {\r\ncase 1000:\r\nbmcr |= BMCR_SPEED1000;\r\nlpagb |= LPA_1000FULL;\r\nbreak;\r\ncase 100:\r\nbmcr |= BMCR_SPEED100;\r\nlpa |= LPA_100FULL;\r\nbreak;\r\ncase 10:\r\nlpa |= LPA_10FULL;\r\nbreak;\r\ndefault:\r\npr_warn("fixed phy: unknown speed\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nswitch (fp->status.speed) {\r\ncase 1000:\r\nbmcr |= BMCR_SPEED1000;\r\nlpagb |= LPA_1000HALF;\r\nbreak;\r\ncase 100:\r\nbmcr |= BMCR_SPEED100;\r\nlpa |= LPA_100HALF;\r\nbreak;\r\ncase 10:\r\nlpa |= LPA_10HALF;\r\nbreak;\r\ndefault:\r\npr_warn("fixed phy: unknown speed\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (fp->status.pause)\r\nlpa |= LPA_PAUSE_CAP;\r\nif (fp->status.asym_pause)\r\nlpa |= LPA_PAUSE_ASYM;\r\n}\r\nfp->regs[MII_PHYSID1] = 0;\r\nfp->regs[MII_PHYSID2] = 0;\r\nfp->regs[MII_BMSR] = bmsr;\r\nfp->regs[MII_BMCR] = bmcr;\r\nfp->regs[MII_LPA] = lpa;\r\nfp->regs[MII_STAT1000] = lpagb;\r\nreturn 0;\r\n}\r\nstatic int fixed_mdio_read(struct mii_bus *bus, int phy_addr, int reg_num)\r\n{\r\nstruct fixed_mdio_bus *fmb = bus->priv;\r\nstruct fixed_phy *fp;\r\nif (reg_num >= MII_REGS_NUM)\r\nreturn -1;\r\nswitch (reg_num) {\r\ncase MII_MMD_CTRL:\r\ncase MII_MMD_DATA:\r\nreturn -1;\r\ndefault:\r\nbreak;\r\n}\r\nlist_for_each_entry(fp, &fmb->phys, node) {\r\nif (fp->addr == phy_addr) {\r\nif (fp->link_update) {\r\nfp->link_update(fp->phydev->attached_dev,\r\n&fp->status);\r\nfixed_phy_update_regs(fp);\r\n}\r\nreturn fp->regs[reg_num];\r\n}\r\n}\r\nreturn 0xFFFF;\r\n}\r\nstatic int fixed_mdio_write(struct mii_bus *bus, int phy_addr, int reg_num,\r\nu16 val)\r\n{\r\nreturn 0;\r\n}\r\nint fixed_phy_set_link_update(struct phy_device *phydev,\r\nint (*link_update)(struct net_device *,\r\nstruct fixed_phy_status *))\r\n{\r\nstruct fixed_mdio_bus *fmb = &platform_fmb;\r\nstruct fixed_phy *fp;\r\nif (!phydev || !phydev->bus)\r\nreturn -EINVAL;\r\nlist_for_each_entry(fp, &fmb->phys, node) {\r\nif (fp->addr == phydev->addr) {\r\nfp->link_update = link_update;\r\nfp->phydev = phydev;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nint fixed_phy_update_state(struct phy_device *phydev,\r\nconst struct fixed_phy_status *status,\r\nconst struct fixed_phy_status *changed)\r\n{\r\nstruct fixed_mdio_bus *fmb = &platform_fmb;\r\nstruct fixed_phy *fp;\r\nif (!phydev || phydev->bus != fmb->mii_bus)\r\nreturn -EINVAL;\r\nlist_for_each_entry(fp, &fmb->phys, node) {\r\nif (fp->addr == phydev->addr) {\r\n#define _UPD(x) if (changed->x) \\r\nfp->status.x = status->x\r\n_UPD(link);\r\n_UPD(speed);\r\n_UPD(duplex);\r\n_UPD(pause);\r\n_UPD(asym_pause);\r\n#undef _UPD\r\nfixed_phy_update_regs(fp);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nint fixed_phy_add(unsigned int irq, int phy_addr,\r\nstruct fixed_phy_status *status,\r\nint link_gpio)\r\n{\r\nint ret;\r\nstruct fixed_mdio_bus *fmb = &platform_fmb;\r\nstruct fixed_phy *fp;\r\nfp = kzalloc(sizeof(*fp), GFP_KERNEL);\r\nif (!fp)\r\nreturn -ENOMEM;\r\nmemset(fp->regs, 0xFF, sizeof(fp->regs[0]) * MII_REGS_NUM);\r\nfmb->irqs[phy_addr] = irq;\r\nfp->addr = phy_addr;\r\nfp->status = *status;\r\nfp->link_gpio = link_gpio;\r\nif (gpio_is_valid(fp->link_gpio)) {\r\nret = gpio_request_one(fp->link_gpio, GPIOF_DIR_IN,\r\n"fixed-link-gpio-link");\r\nif (ret)\r\ngoto err_regs;\r\n}\r\nret = fixed_phy_update_regs(fp);\r\nif (ret)\r\ngoto err_gpio;\r\nlist_add_tail(&fp->node, &fmb->phys);\r\nreturn 0;\r\nerr_gpio:\r\nif (gpio_is_valid(fp->link_gpio))\r\ngpio_free(fp->link_gpio);\r\nerr_regs:\r\nkfree(fp);\r\nreturn ret;\r\n}\r\nvoid fixed_phy_del(int phy_addr)\r\n{\r\nstruct fixed_mdio_bus *fmb = &platform_fmb;\r\nstruct fixed_phy *fp, *tmp;\r\nlist_for_each_entry_safe(fp, tmp, &fmb->phys, node) {\r\nif (fp->addr == phy_addr) {\r\nlist_del(&fp->node);\r\nif (gpio_is_valid(fp->link_gpio))\r\ngpio_free(fp->link_gpio);\r\nkfree(fp);\r\nreturn;\r\n}\r\n}\r\n}\r\nstruct phy_device *fixed_phy_register(unsigned int irq,\r\nstruct fixed_phy_status *status,\r\nint link_gpio,\r\nstruct device_node *np)\r\n{\r\nstruct fixed_mdio_bus *fmb = &platform_fmb;\r\nstruct phy_device *phy;\r\nint phy_addr;\r\nint ret;\r\nspin_lock(&phy_fixed_addr_lock);\r\nif (phy_fixed_addr == PHY_MAX_ADDR) {\r\nspin_unlock(&phy_fixed_addr_lock);\r\nreturn ERR_PTR(-ENOSPC);\r\n}\r\nphy_addr = phy_fixed_addr++;\r\nspin_unlock(&phy_fixed_addr_lock);\r\nret = fixed_phy_add(irq, phy_addr, status, link_gpio);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nphy = get_phy_device(fmb->mii_bus, phy_addr, false);\r\nif (!phy || IS_ERR(phy)) {\r\nfixed_phy_del(phy_addr);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nphy->link = status->link;\r\nif (status->link) {\r\nphy->speed = status->speed;\r\nphy->duplex = status->duplex;\r\nphy->pause = status->pause;\r\nphy->asym_pause = status->asym_pause;\r\n}\r\nof_node_get(np);\r\nphy->dev.of_node = np;\r\nphy->is_pseudo_fixed_link = true;\r\nswitch (status->speed) {\r\ncase SPEED_1000:\r\nphy->supported = PHY_1000BT_FEATURES;\r\nbreak;\r\ncase SPEED_100:\r\nphy->supported = PHY_100BT_FEATURES;\r\nbreak;\r\ncase SPEED_10:\r\ndefault:\r\nphy->supported = PHY_10BT_FEATURES;\r\n}\r\nret = phy_device_register(phy);\r\nif (ret) {\r\nphy_device_free(phy);\r\nof_node_put(np);\r\nfixed_phy_del(phy_addr);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn phy;\r\n}\r\nstatic int __init fixed_mdio_bus_init(void)\r\n{\r\nstruct fixed_mdio_bus *fmb = &platform_fmb;\r\nint ret;\r\npdev = platform_device_register_simple("Fixed MDIO bus", 0, NULL, 0);\r\nif (IS_ERR(pdev)) {\r\nret = PTR_ERR(pdev);\r\ngoto err_pdev;\r\n}\r\nfmb->mii_bus = mdiobus_alloc();\r\nif (fmb->mii_bus == NULL) {\r\nret = -ENOMEM;\r\ngoto err_mdiobus_reg;\r\n}\r\nsnprintf(fmb->mii_bus->id, MII_BUS_ID_SIZE, "fixed-0");\r\nfmb->mii_bus->name = "Fixed MDIO Bus";\r\nfmb->mii_bus->priv = fmb;\r\nfmb->mii_bus->parent = &pdev->dev;\r\nfmb->mii_bus->read = &fixed_mdio_read;\r\nfmb->mii_bus->write = &fixed_mdio_write;\r\nfmb->mii_bus->irq = fmb->irqs;\r\nret = mdiobus_register(fmb->mii_bus);\r\nif (ret)\r\ngoto err_mdiobus_alloc;\r\nreturn 0;\r\nerr_mdiobus_alloc:\r\nmdiobus_free(fmb->mii_bus);\r\nerr_mdiobus_reg:\r\nplatform_device_unregister(pdev);\r\nerr_pdev:\r\nreturn ret;\r\n}\r\nstatic void __exit fixed_mdio_bus_exit(void)\r\n{\r\nstruct fixed_mdio_bus *fmb = &platform_fmb;\r\nstruct fixed_phy *fp, *tmp;\r\nmdiobus_unregister(fmb->mii_bus);\r\nmdiobus_free(fmb->mii_bus);\r\nplatform_device_unregister(pdev);\r\nlist_for_each_entry_safe(fp, tmp, &fmb->phys, node) {\r\nlist_del(&fp->node);\r\nkfree(fp);\r\n}\r\n}
