static int __init load_ramdisk(char *str)\r\n{\r\nrd_doload = simple_strtol(str,NULL,0) & 3;\r\nreturn 1;\r\n}\r\nstatic int __init readonly(char *str)\r\n{\r\nif (*str)\r\nreturn 0;\r\nroot_mountflags |= MS_RDONLY;\r\nreturn 1;\r\n}\r\nstatic int __init readwrite(char *str)\r\n{\r\nif (*str)\r\nreturn 0;\r\nroot_mountflags &= ~MS_RDONLY;\r\nreturn 1;\r\n}\r\nstatic int match_dev_by_uuid(struct device *dev, const void *data)\r\n{\r\nconst struct uuidcmp *cmp = data;\r\nstruct hd_struct *part = dev_to_part(dev);\r\nif (!part->info)\r\ngoto no_match;\r\nif (strncasecmp(cmp->uuid, part->info->uuid, cmp->len))\r\ngoto no_match;\r\nreturn 1;\r\nno_match:\r\nreturn 0;\r\n}\r\nstatic dev_t devt_from_partuuid(const char *uuid_str)\r\n{\r\ndev_t res = 0;\r\nstruct uuidcmp cmp;\r\nstruct device *dev = NULL;\r\nstruct gendisk *disk;\r\nstruct hd_struct *part;\r\nint offset = 0;\r\nbool clear_root_wait = false;\r\nchar *slash;\r\ncmp.uuid = uuid_str;\r\nslash = strchr(uuid_str, '/');\r\nif (slash) {\r\nchar c = 0;\r\nif (sscanf(slash + 1,\r\n"PARTNROFF=%d%c", &offset, &c) != 1) {\r\nclear_root_wait = true;\r\ngoto done;\r\n}\r\ncmp.len = slash - uuid_str;\r\n} else {\r\ncmp.len = strlen(uuid_str);\r\n}\r\nif (!cmp.len) {\r\nclear_root_wait = true;\r\ngoto done;\r\n}\r\ndev = class_find_device(&block_class, NULL, &cmp,\r\n&match_dev_by_uuid);\r\nif (!dev)\r\ngoto done;\r\nres = dev->devt;\r\nif (!offset)\r\ngoto no_offset;\r\nres = 0;\r\ndisk = part_to_disk(dev_to_part(dev));\r\npart = disk_get_part(disk, dev_to_part(dev)->partno + offset);\r\nif (part) {\r\nres = part_devt(part);\r\nput_device(part_to_dev(part));\r\n}\r\nno_offset:\r\nput_device(dev);\r\ndone:\r\nif (clear_root_wait) {\r\npr_err("VFS: PARTUUID= is invalid.\n"\r\n"Expected PARTUUID=<valid-uuid-id>[/PARTNROFF=%%d]\n");\r\nif (root_wait)\r\npr_err("Disabling rootwait; root= is invalid.\n");\r\nroot_wait = 0;\r\n}\r\nreturn res;\r\n}\r\ndev_t name_to_dev_t(const char *name)\r\n{\r\nchar s[32];\r\nchar *p;\r\ndev_t res = 0;\r\nint part;\r\n#ifdef CONFIG_BLOCK\r\nif (strncmp(name, "PARTUUID=", 9) == 0) {\r\nname += 9;\r\nres = devt_from_partuuid(name);\r\nif (!res)\r\ngoto fail;\r\ngoto done;\r\n}\r\n#endif\r\nif (strncmp(name, "/dev/", 5) != 0) {\r\nunsigned maj, min, offset;\r\nchar dummy;\r\nif ((sscanf(name, "%u:%u%c", &maj, &min, &dummy) == 2) ||\r\n(sscanf(name, "%u:%u:%u:%c", &maj, &min, &offset, &dummy) == 3)) {\r\nres = MKDEV(maj, min);\r\nif (maj != MAJOR(res) || min != MINOR(res))\r\ngoto fail;\r\n} else {\r\nres = new_decode_dev(simple_strtoul(name, &p, 16));\r\nif (*p)\r\ngoto fail;\r\n}\r\ngoto done;\r\n}\r\nname += 5;\r\nres = Root_NFS;\r\nif (strcmp(name, "nfs") == 0)\r\ngoto done;\r\nres = Root_RAM0;\r\nif (strcmp(name, "ram") == 0)\r\ngoto done;\r\nif (strlen(name) > 31)\r\ngoto fail;\r\nstrcpy(s, name);\r\nfor (p = s; *p; p++)\r\nif (*p == '/')\r\n*p = '!';\r\nres = blk_lookup_devt(s, 0);\r\nif (res)\r\ngoto done;\r\nwhile (p > s && isdigit(p[-1]))\r\np--;\r\nif (p == s || !*p || *p == '0')\r\ngoto fail;\r\npart = simple_strtoul(p, NULL, 10);\r\n*p = '\0';\r\nres = blk_lookup_devt(s, part);\r\nif (res)\r\ngoto done;\r\nif (p < s + 2 || !isdigit(p[-2]) || p[-1] != 'p')\r\ngoto fail;\r\np[-1] = '\0';\r\nres = blk_lookup_devt(s, part);\r\nif (res)\r\ngoto done;\r\nfail:\r\nreturn 0;\r\ndone:\r\nreturn res;\r\n}\r\nstatic int __init root_dev_setup(char *line)\r\n{\r\nstrlcpy(saved_root_name, line, sizeof(saved_root_name));\r\nreturn 1;\r\n}\r\nstatic int __init rootwait_setup(char *str)\r\n{\r\nif (*str)\r\nreturn 0;\r\nroot_wait = 1;\r\nreturn 1;\r\n}\r\nstatic int __init root_data_setup(char *str)\r\n{\r\nroot_mount_data = str;\r\nreturn 1;\r\n}\r\nstatic int __init fs_names_setup(char *str)\r\n{\r\nroot_fs_names = str;\r\nreturn 1;\r\n}\r\nstatic int __init root_delay_setup(char *str)\r\n{\r\nroot_delay = simple_strtoul(str, NULL, 0);\r\nreturn 1;\r\n}\r\nstatic void __init get_fs_names(char *page)\r\n{\r\nchar *s = page;\r\nif (root_fs_names) {\r\nstrcpy(page, root_fs_names);\r\nwhile (*s++) {\r\nif (s[-1] == ',')\r\ns[-1] = '\0';\r\n}\r\n} else {\r\nint len = get_filesystem_list(page);\r\nchar *p, *next;\r\npage[len] = '\0';\r\nfor (p = page-1; p; p = next) {\r\nnext = strchr(++p, '\n');\r\nif (*p++ != '\t')\r\ncontinue;\r\nwhile ((*s++ = *p++) != '\n')\r\n;\r\ns[-1] = '\0';\r\n}\r\n}\r\n*s = '\0';\r\n}\r\nstatic int __init do_mount_root(char *name, char *fs, int flags, void *data)\r\n{\r\nstruct super_block *s;\r\nint err = sys_mount(name, "/root", fs, flags, data);\r\nif (err)\r\nreturn err;\r\nsys_chdir("/root");\r\ns = current->fs->pwd.dentry->d_sb;\r\nROOT_DEV = s->s_dev;\r\nprintk(KERN_INFO\r\n"VFS: Mounted root (%s filesystem)%s on device %u:%u.\n",\r\ns->s_type->name,\r\ns->s_flags & MS_RDONLY ? " readonly" : "",\r\nMAJOR(ROOT_DEV), MINOR(ROOT_DEV));\r\nreturn 0;\r\n}\r\nvoid __init mount_block_root(char *name, int flags)\r\n{\r\nstruct page *page = alloc_page(GFP_KERNEL |\r\n__GFP_NOTRACK_FALSE_POSITIVE);\r\nchar *fs_names = page_address(page);\r\nchar *p;\r\n#ifdef CONFIG_BLOCK\r\nchar b[BDEVNAME_SIZE];\r\n#else\r\nconst char *b = name;\r\n#endif\r\nget_fs_names(fs_names);\r\nretry:\r\nfor (p = fs_names; *p; p += strlen(p)+1) {\r\nint err = do_mount_root(name, p, flags, root_mount_data);\r\nswitch (err) {\r\ncase 0:\r\ngoto out;\r\ncase -EACCES:\r\ncase -EINVAL:\r\ncontinue;\r\n}\r\n#ifdef CONFIG_BLOCK\r\n__bdevname(ROOT_DEV, b);\r\n#endif\r\nprintk("VFS: Cannot open root device \"%s\" or %s: error %d\n",\r\nroot_device_name, b, err);\r\nprintk("Please append a correct \"root=\" boot option; here are the available partitions:\n");\r\nprintk_all_partitions();\r\n#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT\r\nprintk("DEBUG_BLOCK_EXT_DEVT is enabled, you need to specify "\r\n"explicit textual name for \"root=\" boot option.\n");\r\n#endif\r\npanic("VFS: Unable to mount root fs on %s", b);\r\n}\r\nif (!(flags & MS_RDONLY)) {\r\nflags |= MS_RDONLY;\r\ngoto retry;\r\n}\r\nprintk("List of all partitions:\n");\r\nprintk_all_partitions();\r\nprintk("No filesystem could mount root, tried: ");\r\nfor (p = fs_names; *p; p += strlen(p)+1)\r\nprintk(" %s", p);\r\nprintk("\n");\r\n#ifdef CONFIG_BLOCK\r\n__bdevname(ROOT_DEV, b);\r\n#endif\r\npanic("VFS: Unable to mount root fs on %s", b);\r\nout:\r\nput_page(page);\r\n}\r\nstatic int __init mount_nfs_root(void)\r\n{\r\nchar *root_dev, *root_data;\r\nunsigned int timeout;\r\nint try, err;\r\nerr = nfs_root_data(&root_dev, &root_data);\r\nif (err != 0)\r\nreturn 0;\r\ntimeout = NFSROOT_TIMEOUT_MIN;\r\nfor (try = 1; ; try++) {\r\nerr = do_mount_root(root_dev, "nfs",\r\nroot_mountflags, root_data);\r\nif (err == 0)\r\nreturn 1;\r\nif (try > NFSROOT_RETRY_MAX)\r\nbreak;\r\nssleep(timeout);\r\ntimeout <<= 1;\r\nif (timeout > NFSROOT_TIMEOUT_MAX)\r\ntimeout = NFSROOT_TIMEOUT_MAX;\r\n}\r\nreturn 0;\r\n}\r\nvoid __init change_floppy(char *fmt, ...)\r\n{\r\nstruct termios termios;\r\nchar buf[80];\r\nchar c;\r\nint fd;\r\nva_list args;\r\nva_start(args, fmt);\r\nvsprintf(buf, fmt, args);\r\nva_end(args);\r\nfd = sys_open("/dev/root", O_RDWR | O_NDELAY, 0);\r\nif (fd >= 0) {\r\nsys_ioctl(fd, FDEJECT, 0);\r\nsys_close(fd);\r\n}\r\nprintk(KERN_NOTICE "VFS: Insert %s and press ENTER\n", buf);\r\nfd = sys_open("/dev/console", O_RDWR, 0);\r\nif (fd >= 0) {\r\nsys_ioctl(fd, TCGETS, (long)&termios);\r\ntermios.c_lflag &= ~ICANON;\r\nsys_ioctl(fd, TCSETSF, (long)&termios);\r\nsys_read(fd, &c, 1);\r\ntermios.c_lflag |= ICANON;\r\nsys_ioctl(fd, TCSETSF, (long)&termios);\r\nsys_close(fd);\r\n}\r\n}\r\nvoid __init mount_root(void)\r\n{\r\n#ifdef CONFIG_ROOT_NFS\r\nif (ROOT_DEV == Root_NFS) {\r\nif (mount_nfs_root())\r\nreturn;\r\nprintk(KERN_ERR "VFS: Unable to mount root fs via NFS, trying floppy.\n");\r\nROOT_DEV = Root_FD0;\r\n}\r\n#endif\r\n#ifdef CONFIG_BLK_DEV_FD\r\nif (MAJOR(ROOT_DEV) == FLOPPY_MAJOR) {\r\nif (rd_doload==2) {\r\nif (rd_load_disk(1)) {\r\nROOT_DEV = Root_RAM1;\r\nroot_device_name = NULL;\r\n}\r\n} else\r\nchange_floppy("root floppy");\r\n}\r\n#endif\r\n#ifdef CONFIG_BLOCK\r\n{\r\nint err = create_dev("/dev/root", ROOT_DEV);\r\nif (err < 0)\r\npr_emerg("Failed to create /dev/root: %d\n", err);\r\nmount_block_root("/dev/root", root_mountflags);\r\n}\r\n#endif\r\n}\r\nvoid __init prepare_namespace(void)\r\n{\r\nint is_floppy;\r\nif (root_delay) {\r\nprintk(KERN_INFO "Waiting %d sec before mounting root device...\n",\r\nroot_delay);\r\nssleep(root_delay);\r\n}\r\nwait_for_device_probe();\r\nmd_run_setup();\r\nif (saved_root_name[0]) {\r\nroot_device_name = saved_root_name;\r\nif (!strncmp(root_device_name, "mtd", 3) ||\r\n!strncmp(root_device_name, "ubi", 3)) {\r\nmount_block_root(root_device_name, root_mountflags);\r\ngoto out;\r\n}\r\nROOT_DEV = name_to_dev_t(root_device_name);\r\nif (strncmp(root_device_name, "/dev/", 5) == 0)\r\nroot_device_name += 5;\r\n}\r\nif (initrd_load())\r\ngoto out;\r\nif ((ROOT_DEV == 0) && root_wait) {\r\nprintk(KERN_INFO "Waiting for root device %s...\n",\r\nsaved_root_name);\r\nwhile (driver_probe_done() != 0 ||\r\n(ROOT_DEV = name_to_dev_t(saved_root_name)) == 0)\r\nmsleep(100);\r\nasync_synchronize_full();\r\n}\r\nis_floppy = MAJOR(ROOT_DEV) == FLOPPY_MAJOR;\r\nif (is_floppy && rd_doload && rd_load_disk(0))\r\nROOT_DEV = Root_RAM0;\r\nmount_root();\r\nout:\r\ndevtmpfs_mount("dev");\r\nsys_mount(".", "/", NULL, MS_MOVE, NULL);\r\nsys_chroot(".");\r\n}\r\nstatic struct dentry *rootfs_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nstatic unsigned long once;\r\nvoid *fill = ramfs_fill_super;\r\nif (test_and_set_bit(0, &once))\r\nreturn ERR_PTR(-ENODEV);\r\nif (IS_ENABLED(CONFIG_TMPFS) && is_tmpfs)\r\nfill = shmem_fill_super;\r\nreturn mount_nodev(fs_type, flags, data, fill);\r\n}\r\nint __init init_rootfs(void)\r\n{\r\nint err = register_filesystem(&rootfs_fs_type);\r\nif (err)\r\nreturn err;\r\nif (IS_ENABLED(CONFIG_TMPFS) && !saved_root_name[0] &&\r\n(!root_fs_names || strstr(root_fs_names, "tmpfs"))) {\r\nerr = shmem_init();\r\nis_tmpfs = true;\r\n} else {\r\nerr = init_ramfs_fs();\r\n}\r\nif (err)\r\nunregister_filesystem(&rootfs_fs_type);\r\nreturn err;\r\n}
