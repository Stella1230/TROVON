static inline struct cafe_camera *to_cam(struct v4l2_device *dev)\r\n{\r\nstruct mcam_camera *m = container_of(dev, struct mcam_camera, v4l2_dev);\r\nreturn container_of(m, struct cafe_camera, mcam);\r\n}\r\nstatic int cafe_smbus_write_done(struct mcam_camera *mcam)\r\n{\r\nunsigned long flags;\r\nint c1;\r\nudelay(20);\r\nspin_lock_irqsave(&mcam->dev_lock, flags);\r\nc1 = mcam_reg_read(mcam, REG_TWSIC1);\r\nspin_unlock_irqrestore(&mcam->dev_lock, flags);\r\nreturn (c1 & (TWSIC1_WSTAT|TWSIC1_ERROR)) != TWSIC1_WSTAT;\r\n}\r\nstatic int cafe_smbus_write_data(struct cafe_camera *cam,\r\nu16 addr, u8 command, u8 value)\r\n{\r\nunsigned int rval;\r\nunsigned long flags;\r\nstruct mcam_camera *mcam = &cam->mcam;\r\nspin_lock_irqsave(&mcam->dev_lock, flags);\r\nrval = TWSIC0_EN | ((addr << TWSIC0_SID_SHIFT) & TWSIC0_SID);\r\nrval |= TWSIC0_OVMAGIC;\r\nrval |= TWSIC0_CLKDIV;\r\nmcam_reg_write(mcam, REG_TWSIC0, rval);\r\n(void) mcam_reg_read(mcam, REG_TWSIC1);\r\nrval = value | ((command << TWSIC1_ADDR_SHIFT) & TWSIC1_ADDR);\r\nmcam_reg_write(mcam, REG_TWSIC1, rval);\r\nspin_unlock_irqrestore(&mcam->dev_lock, flags);\r\nmdelay(2);\r\nwait_event_timeout(cam->smbus_wait, cafe_smbus_write_done(mcam),\r\nCAFE_SMBUS_TIMEOUT);\r\nspin_lock_irqsave(&mcam->dev_lock, flags);\r\nrval = mcam_reg_read(mcam, REG_TWSIC1);\r\nspin_unlock_irqrestore(&mcam->dev_lock, flags);\r\nif (rval & TWSIC1_WSTAT) {\r\ncam_err(cam, "SMBUS write (%02x/%02x/%02x) timed out\n", addr,\r\ncommand, value);\r\nreturn -EIO;\r\n}\r\nif (rval & TWSIC1_ERROR) {\r\ncam_err(cam, "SMBUS write (%02x/%02x/%02x) error\n", addr,\r\ncommand, value);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cafe_smbus_read_done(struct mcam_camera *mcam)\r\n{\r\nunsigned long flags;\r\nint c1;\r\nudelay(20);\r\nspin_lock_irqsave(&mcam->dev_lock, flags);\r\nc1 = mcam_reg_read(mcam, REG_TWSIC1);\r\nspin_unlock_irqrestore(&mcam->dev_lock, flags);\r\nreturn c1 & (TWSIC1_RVALID|TWSIC1_ERROR);\r\n}\r\nstatic int cafe_smbus_read_data(struct cafe_camera *cam,\r\nu16 addr, u8 command, u8 *value)\r\n{\r\nunsigned int rval;\r\nunsigned long flags;\r\nstruct mcam_camera *mcam = &cam->mcam;\r\nspin_lock_irqsave(&mcam->dev_lock, flags);\r\nrval = TWSIC0_EN | ((addr << TWSIC0_SID_SHIFT) & TWSIC0_SID);\r\nrval |= TWSIC0_OVMAGIC;\r\nrval |= TWSIC0_CLKDIV;\r\nmcam_reg_write(mcam, REG_TWSIC0, rval);\r\n(void) mcam_reg_read(mcam, REG_TWSIC1);\r\nrval = TWSIC1_READ | ((command << TWSIC1_ADDR_SHIFT) & TWSIC1_ADDR);\r\nmcam_reg_write(mcam, REG_TWSIC1, rval);\r\nspin_unlock_irqrestore(&mcam->dev_lock, flags);\r\nwait_event_timeout(cam->smbus_wait,\r\ncafe_smbus_read_done(mcam), CAFE_SMBUS_TIMEOUT);\r\nspin_lock_irqsave(&mcam->dev_lock, flags);\r\nrval = mcam_reg_read(mcam, REG_TWSIC1);\r\nspin_unlock_irqrestore(&mcam->dev_lock, flags);\r\nif (rval & TWSIC1_ERROR) {\r\ncam_err(cam, "SMBUS read (%02x/%02x) error\n", addr, command);\r\nreturn -EIO;\r\n}\r\nif (!(rval & TWSIC1_RVALID)) {\r\ncam_err(cam, "SMBUS read (%02x/%02x) timed out\n", addr,\r\ncommand);\r\nreturn -EIO;\r\n}\r\n*value = rval & 0xff;\r\nreturn 0;\r\n}\r\nstatic int cafe_smbus_xfer(struct i2c_adapter *adapter, u16 addr,\r\nunsigned short flags, char rw, u8 command,\r\nint size, union i2c_smbus_data *data)\r\n{\r\nstruct cafe_camera *cam = i2c_get_adapdata(adapter);\r\nint ret = -EINVAL;\r\nif (size != I2C_SMBUS_BYTE_DATA) {\r\ncam_err(cam, "funky xfer size %d\n", size);\r\nreturn -EINVAL;\r\n}\r\nif (rw == I2C_SMBUS_WRITE)\r\nret = cafe_smbus_write_data(cam, addr, command, data->byte);\r\nelse if (rw == I2C_SMBUS_READ)\r\nret = cafe_smbus_read_data(cam, addr, command, &data->byte);\r\nreturn ret;\r\n}\r\nstatic void cafe_smbus_enable_irq(struct cafe_camera *cam)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cam->mcam.dev_lock, flags);\r\nmcam_reg_set_bit(&cam->mcam, REG_IRQMASK, TWSIIRQS);\r\nspin_unlock_irqrestore(&cam->mcam.dev_lock, flags);\r\n}\r\nstatic u32 cafe_smbus_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_SMBUS_READ_BYTE_DATA |\r\nI2C_FUNC_SMBUS_WRITE_BYTE_DATA;\r\n}\r\nstatic int cafe_smbus_setup(struct cafe_camera *cam)\r\n{\r\nstruct i2c_adapter *adap;\r\nint ret;\r\nadap = kzalloc(sizeof(*adap), GFP_KERNEL);\r\nif (adap == NULL)\r\nreturn -ENOMEM;\r\nadap->owner = THIS_MODULE;\r\nadap->algo = &cafe_smbus_algo;\r\nstrcpy(adap->name, "cafe_ccic");\r\nadap->dev.parent = &cam->pdev->dev;\r\ni2c_set_adapdata(adap, cam);\r\nret = i2c_add_adapter(adap);\r\nif (ret) {\r\nprintk(KERN_ERR "Unable to register cafe i2c adapter\n");\r\nkfree(adap);\r\nreturn ret;\r\n}\r\ncam->mcam.i2c_adapter = adap;\r\ncafe_smbus_enable_irq(cam);\r\nreturn 0;\r\n}\r\nstatic void cafe_smbus_shutdown(struct cafe_camera *cam)\r\n{\r\ni2c_del_adapter(cam->mcam.i2c_adapter);\r\nkfree(cam->mcam.i2c_adapter);\r\n}\r\nstatic void cafe_ctlr_init(struct mcam_camera *mcam)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mcam->dev_lock, flags);\r\nmcam_reg_write(mcam, 0x3038, 0x8);\r\nmcam_reg_write(mcam, 0x315c, 0x80008);\r\nmcam_reg_write(mcam, REG_GL_CSR, GCSR_SRS|GCSR_MRS);\r\nmcam_reg_write(mcam, REG_GL_CSR, GCSR_SRC|GCSR_MRC);\r\nmcam_reg_write(mcam, REG_GL_CSR, GCSR_SRC|GCSR_MRS);\r\nspin_unlock_irqrestore(&mcam->dev_lock, flags);\r\nmsleep(5);\r\nspin_lock_irqsave(&mcam->dev_lock, flags);\r\nmcam_reg_write(mcam, REG_GL_CSR, GCSR_CCIC_EN|GCSR_SRC|GCSR_MRC);\r\nmcam_reg_set_bit(mcam, REG_GL_IMASK, GIMSK_CCIC_EN);\r\nmcam_reg_write(mcam, REG_IRQMASK, 0);\r\nspin_unlock_irqrestore(&mcam->dev_lock, flags);\r\n}\r\nstatic int cafe_ctlr_power_up(struct mcam_camera *mcam)\r\n{\r\nmcam_reg_write(mcam, REG_GL_FCR, GFCR_GPIO_ON);\r\nmcam_reg_write(mcam, REG_GL_GPIOR, GGPIO_OUT|GGPIO_VAL);\r\nmcam_reg_write(mcam, REG_GPR, GPR_C1EN|GPR_C0EN);\r\nmcam_reg_write(mcam, REG_GPR, GPR_C1EN|GPR_C0EN|GPR_C0);\r\nreturn 0;\r\n}\r\nstatic void cafe_ctlr_power_down(struct mcam_camera *mcam)\r\n{\r\nmcam_reg_write(mcam, REG_GPR, GPR_C1EN|GPR_C0EN|GPR_C1);\r\nmcam_reg_write(mcam, REG_GL_FCR, GFCR_GPIO_ON);\r\nmcam_reg_write(mcam, REG_GL_GPIOR, GGPIO_OUT);\r\n}\r\nstatic irqreturn_t cafe_irq(int irq, void *data)\r\n{\r\nstruct cafe_camera *cam = data;\r\nstruct mcam_camera *mcam = &cam->mcam;\r\nunsigned int irqs, handled;\r\nspin_lock(&mcam->dev_lock);\r\nirqs = mcam_reg_read(mcam, REG_IRQSTAT);\r\nhandled = cam->registered && mccic_irq(mcam, irqs);\r\nif (irqs & TWSIIRQS) {\r\nmcam_reg_write(mcam, REG_IRQSTAT, TWSIIRQS);\r\nwake_up(&cam->smbus_wait);\r\nhandled = 1;\r\n}\r\nspin_unlock(&mcam->dev_lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int cafe_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nint ret;\r\nstruct cafe_camera *cam;\r\nstruct mcam_camera *mcam;\r\nret = -ENOMEM;\r\ncam = kzalloc(sizeof(struct cafe_camera), GFP_KERNEL);\r\nif (cam == NULL)\r\ngoto out;\r\ncam->pdev = pdev;\r\nmcam = &cam->mcam;\r\nmcam->chip_id = MCAM_CAFE;\r\nspin_lock_init(&mcam->dev_lock);\r\ninit_waitqueue_head(&cam->smbus_wait);\r\nmcam->plat_power_up = cafe_ctlr_power_up;\r\nmcam->plat_power_down = cafe_ctlr_power_down;\r\nmcam->dev = &pdev->dev;\r\nsnprintf(mcam->bus_info, sizeof(mcam->bus_info), "PCI:%s", pci_name(pdev));\r\nmcam->clock_speed = 45;\r\nmcam->use_smbus = 1;\r\nmcam->buffer_mode = B_vmalloc;\r\nret = pci_enable_device(pdev);\r\nif (ret)\r\ngoto out_free;\r\npci_set_master(pdev);\r\nret = -EIO;\r\nmcam->regs = pci_iomap(pdev, 0, 0);\r\nif (!mcam->regs) {\r\nprintk(KERN_ERR "Unable to ioremap cafe-ccic regs\n");\r\ngoto out_disable;\r\n}\r\nmcam->regs_size = pci_resource_len(pdev, 0);\r\nret = request_irq(pdev->irq, cafe_irq, IRQF_SHARED, "cafe-ccic", cam);\r\nif (ret)\r\ngoto out_iounmap;\r\ncafe_ctlr_init(mcam);\r\ncafe_ctlr_power_up(mcam);\r\nret = cafe_smbus_setup(cam);\r\nif (ret)\r\ngoto out_pdown;\r\nret = mccic_register(mcam);\r\nif (ret == 0) {\r\ncam->registered = 1;\r\nreturn 0;\r\n}\r\ncafe_smbus_shutdown(cam);\r\nout_pdown:\r\ncafe_ctlr_power_down(mcam);\r\nfree_irq(pdev->irq, cam);\r\nout_iounmap:\r\npci_iounmap(pdev, mcam->regs);\r\nout_disable:\r\npci_disable_device(pdev);\r\nout_free:\r\nkfree(cam);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void cafe_shutdown(struct cafe_camera *cam)\r\n{\r\nmccic_shutdown(&cam->mcam);\r\ncafe_smbus_shutdown(cam);\r\nfree_irq(cam->pdev->irq, cam);\r\npci_iounmap(cam->pdev, cam->mcam.regs);\r\n}\r\nstatic void cafe_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct v4l2_device *v4l2_dev = dev_get_drvdata(&pdev->dev);\r\nstruct cafe_camera *cam = to_cam(v4l2_dev);\r\nif (cam == NULL) {\r\nprintk(KERN_WARNING "pci_remove on unknown pdev %p\n", pdev);\r\nreturn;\r\n}\r\ncafe_shutdown(cam);\r\nkfree(cam);\r\n}\r\nstatic int cafe_pci_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct v4l2_device *v4l2_dev = dev_get_drvdata(&pdev->dev);\r\nstruct cafe_camera *cam = to_cam(v4l2_dev);\r\nint ret;\r\nret = pci_save_state(pdev);\r\nif (ret)\r\nreturn ret;\r\nmccic_suspend(&cam->mcam);\r\npci_disable_device(pdev);\r\nreturn 0;\r\n}\r\nstatic int cafe_pci_resume(struct pci_dev *pdev)\r\n{\r\nstruct v4l2_device *v4l2_dev = dev_get_drvdata(&pdev->dev);\r\nstruct cafe_camera *cam = to_cam(v4l2_dev);\r\nint ret = 0;\r\npci_restore_state(pdev);\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\ncam_warn(cam, "Unable to re-enable device on resume!\n");\r\nreturn ret;\r\n}\r\ncafe_ctlr_init(&cam->mcam);\r\nreturn mccic_resume(&cam->mcam);\r\n}\r\nstatic int __init cafe_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_NOTICE "Marvell M88ALP01 'CAFE' Camera Controller version %d\n",\r\nCAFE_VERSION);\r\nret = pci_register_driver(&cafe_pci_driver);\r\nif (ret) {\r\nprintk(KERN_ERR "Unable to register cafe_ccic driver\n");\r\ngoto out;\r\n}\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit cafe_exit(void)\r\n{\r\npci_unregister_driver(&cafe_pci_driver);\r\n}
