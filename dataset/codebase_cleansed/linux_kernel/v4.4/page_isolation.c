static int set_migratetype_isolate(struct page *page,\r\nbool skip_hwpoisoned_pages)\r\n{\r\nstruct zone *zone;\r\nunsigned long flags, pfn;\r\nstruct memory_isolate_notify arg;\r\nint notifier_ret;\r\nint ret = -EBUSY;\r\nzone = page_zone(page);\r\nspin_lock_irqsave(&zone->lock, flags);\r\npfn = page_to_pfn(page);\r\narg.start_pfn = pfn;\r\narg.nr_pages = pageblock_nr_pages;\r\narg.pages_found = 0;\r\nnotifier_ret = memory_isolate_notify(MEM_ISOLATE_COUNT, &arg);\r\nnotifier_ret = notifier_to_errno(notifier_ret);\r\nif (notifier_ret)\r\ngoto out;\r\nif (!has_unmovable_pages(zone, page, arg.pages_found,\r\nskip_hwpoisoned_pages))\r\nret = 0;\r\nout:\r\nif (!ret) {\r\nunsigned long nr_pages;\r\nint migratetype = get_pageblock_migratetype(page);\r\nset_pageblock_migratetype(page, MIGRATE_ISOLATE);\r\nzone->nr_isolate_pageblock++;\r\nnr_pages = move_freepages_block(zone, page, MIGRATE_ISOLATE);\r\n__mod_zone_freepage_state(zone, -nr_pages, migratetype);\r\n}\r\nspin_unlock_irqrestore(&zone->lock, flags);\r\nif (!ret)\r\ndrain_all_pages(zone);\r\nreturn ret;\r\n}\r\nstatic void unset_migratetype_isolate(struct page *page, unsigned migratetype)\r\n{\r\nstruct zone *zone;\r\nunsigned long flags, nr_pages;\r\nstruct page *isolated_page = NULL;\r\nunsigned int order;\r\nunsigned long page_idx, buddy_idx;\r\nstruct page *buddy;\r\nzone = page_zone(page);\r\nspin_lock_irqsave(&zone->lock, flags);\r\nif (get_pageblock_migratetype(page) != MIGRATE_ISOLATE)\r\ngoto out;\r\nif (PageBuddy(page)) {\r\norder = page_order(page);\r\nif (order >= pageblock_order) {\r\npage_idx = page_to_pfn(page) & ((1 << MAX_ORDER) - 1);\r\nbuddy_idx = __find_buddy_index(page_idx, order);\r\nbuddy = page + (buddy_idx - page_idx);\r\nif (pfn_valid_within(page_to_pfn(buddy)) &&\r\n!is_migrate_isolate_page(buddy)) {\r\n__isolate_free_page(page, order);\r\nkernel_map_pages(page, (1 << order), 1);\r\nset_page_refcounted(page);\r\nisolated_page = page;\r\n}\r\n}\r\n}\r\nif (!isolated_page) {\r\nnr_pages = move_freepages_block(zone, page, migratetype);\r\n__mod_zone_freepage_state(zone, nr_pages, migratetype);\r\n}\r\nset_pageblock_migratetype(page, migratetype);\r\nzone->nr_isolate_pageblock--;\r\nout:\r\nspin_unlock_irqrestore(&zone->lock, flags);\r\nif (isolated_page)\r\n__free_pages(isolated_page, order);\r\n}\r\nstatic inline struct page *\r\n__first_valid_page(unsigned long pfn, unsigned long nr_pages)\r\n{\r\nint i;\r\nfor (i = 0; i < nr_pages; i++)\r\nif (pfn_valid_within(pfn + i))\r\nbreak;\r\nif (unlikely(i == nr_pages))\r\nreturn NULL;\r\nreturn pfn_to_page(pfn + i);\r\n}\r\nint start_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,\r\nunsigned migratetype, bool skip_hwpoisoned_pages)\r\n{\r\nunsigned long pfn;\r\nunsigned long undo_pfn;\r\nstruct page *page;\r\nBUG_ON((start_pfn) & (pageblock_nr_pages - 1));\r\nBUG_ON((end_pfn) & (pageblock_nr_pages - 1));\r\nfor (pfn = start_pfn;\r\npfn < end_pfn;\r\npfn += pageblock_nr_pages) {\r\npage = __first_valid_page(pfn, pageblock_nr_pages);\r\nif (page &&\r\nset_migratetype_isolate(page, skip_hwpoisoned_pages)) {\r\nundo_pfn = pfn;\r\ngoto undo;\r\n}\r\n}\r\nreturn 0;\r\nundo:\r\nfor (pfn = start_pfn;\r\npfn < undo_pfn;\r\npfn += pageblock_nr_pages)\r\nunset_migratetype_isolate(pfn_to_page(pfn), migratetype);\r\nreturn -EBUSY;\r\n}\r\nint undo_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,\r\nunsigned migratetype)\r\n{\r\nunsigned long pfn;\r\nstruct page *page;\r\nBUG_ON((start_pfn) & (pageblock_nr_pages - 1));\r\nBUG_ON((end_pfn) & (pageblock_nr_pages - 1));\r\nfor (pfn = start_pfn;\r\npfn < end_pfn;\r\npfn += pageblock_nr_pages) {\r\npage = __first_valid_page(pfn, pageblock_nr_pages);\r\nif (!page || get_pageblock_migratetype(page) != MIGRATE_ISOLATE)\r\ncontinue;\r\nunset_migratetype_isolate(page, migratetype);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\n__test_page_isolated_in_pageblock(unsigned long pfn, unsigned long end_pfn,\r\nbool skip_hwpoisoned_pages)\r\n{\r\nstruct page *page;\r\nwhile (pfn < end_pfn) {\r\nif (!pfn_valid_within(pfn)) {\r\npfn++;\r\ncontinue;\r\n}\r\npage = pfn_to_page(pfn);\r\nif (PageBuddy(page))\r\npfn += 1 << page_order(page);\r\nelse if (skip_hwpoisoned_pages && PageHWPoison(page))\r\npfn++;\r\nelse\r\nbreak;\r\n}\r\nif (pfn < end_pfn)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint test_pages_isolated(unsigned long start_pfn, unsigned long end_pfn,\r\nbool skip_hwpoisoned_pages)\r\n{\r\nunsigned long pfn, flags;\r\nstruct page *page;\r\nstruct zone *zone;\r\nint ret;\r\nfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {\r\npage = __first_valid_page(pfn, pageblock_nr_pages);\r\nif (page && get_pageblock_migratetype(page) != MIGRATE_ISOLATE)\r\nbreak;\r\n}\r\npage = __first_valid_page(start_pfn, end_pfn - start_pfn);\r\nif ((pfn < end_pfn) || !page)\r\nreturn -EBUSY;\r\nzone = page_zone(page);\r\nspin_lock_irqsave(&zone->lock, flags);\r\nret = __test_page_isolated_in_pageblock(start_pfn, end_pfn,\r\nskip_hwpoisoned_pages);\r\nspin_unlock_irqrestore(&zone->lock, flags);\r\nreturn ret ? 0 : -EBUSY;\r\n}\r\nstruct page *alloc_migrate_target(struct page *page, unsigned long private,\r\nint **resultp)\r\n{\r\ngfp_t gfp_mask = GFP_USER | __GFP_MOVABLE;\r\nif (PageHuge(page)) {\r\nnodemask_t src = nodemask_of_node(page_to_nid(page));\r\nnodemask_t dst;\r\nnodes_complement(dst, src);\r\nreturn alloc_huge_page_node(page_hstate(compound_head(page)),\r\nnext_node(page_to_nid(page), dst));\r\n}\r\nif (PageHighMem(page))\r\ngfp_mask |= __GFP_HIGHMEM;\r\nreturn alloc_page(gfp_mask);\r\n}
