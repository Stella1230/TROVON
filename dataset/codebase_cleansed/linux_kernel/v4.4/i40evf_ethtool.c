static int i40evf_get_settings(struct net_device *netdev,\r\nstruct ethtool_cmd *ecmd)\r\n{\r\necmd->supported = 0;\r\necmd->autoneg = AUTONEG_DISABLE;\r\necmd->transceiver = XCVR_DUMMY1;\r\necmd->port = PORT_NONE;\r\nreturn 0;\r\n}\r\nstatic int i40evf_get_sset_count(struct net_device *netdev, int sset)\r\n{\r\nif (sset == ETH_SS_STATS)\r\nreturn I40EVF_STATS_LEN(netdev);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic void i40evf_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct i40evf_adapter *adapter = netdev_priv(netdev);\r\nint i, j;\r\nchar *p;\r\nfor (i = 0; i < I40EVF_GLOBAL_STATS_LEN; i++) {\r\np = (char *)adapter + i40evf_gstrings_stats[i].stat_offset;\r\ndata[i] = *(u64 *)p;\r\n}\r\nfor (j = 0; j < adapter->num_active_queues; j++) {\r\ndata[i++] = adapter->tx_rings[j]->stats.packets;\r\ndata[i++] = adapter->tx_rings[j]->stats.bytes;\r\n}\r\nfor (j = 0; j < adapter->num_active_queues; j++) {\r\ndata[i++] = adapter->rx_rings[j]->stats.packets;\r\ndata[i++] = adapter->rx_rings[j]->stats.bytes;\r\n}\r\n}\r\nstatic void i40evf_get_strings(struct net_device *netdev, u32 sset, u8 *data)\r\n{\r\nstruct i40evf_adapter *adapter = netdev_priv(netdev);\r\nu8 *p = data;\r\nint i;\r\nif (sset == ETH_SS_STATS) {\r\nfor (i = 0; i < I40EVF_GLOBAL_STATS_LEN; i++) {\r\nmemcpy(p, i40evf_gstrings_stats[i].stat_string,\r\nETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\n}\r\nfor (i = 0; i < adapter->num_active_queues; i++) {\r\nsnprintf(p, ETH_GSTRING_LEN, "tx-%u.packets", i);\r\np += ETH_GSTRING_LEN;\r\nsnprintf(p, ETH_GSTRING_LEN, "tx-%u.bytes", i);\r\np += ETH_GSTRING_LEN;\r\n}\r\nfor (i = 0; i < adapter->num_active_queues; i++) {\r\nsnprintf(p, ETH_GSTRING_LEN, "rx-%u.packets", i);\r\np += ETH_GSTRING_LEN;\r\nsnprintf(p, ETH_GSTRING_LEN, "rx-%u.bytes", i);\r\np += ETH_GSTRING_LEN;\r\n}\r\n}\r\n}\r\nstatic u32 i40evf_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct i40evf_adapter *adapter = netdev_priv(netdev);\r\nreturn adapter->msg_enable;\r\n}\r\nstatic void i40evf_set_msglevel(struct net_device *netdev, u32 data)\r\n{\r\nstruct i40evf_adapter *adapter = netdev_priv(netdev);\r\nif (I40E_DEBUG_USER & data)\r\nadapter->hw.debug_mask = data;\r\nadapter->msg_enable = data;\r\n}\r\nstatic void i40evf_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct i40evf_adapter *adapter = netdev_priv(netdev);\r\nstrlcpy(drvinfo->driver, i40evf_driver_name, 32);\r\nstrlcpy(drvinfo->version, i40evf_driver_version, 32);\r\nstrlcpy(drvinfo->fw_version, "N/A", 4);\r\nstrlcpy(drvinfo->bus_info, pci_name(adapter->pdev), 32);\r\n}\r\nstatic void i40evf_get_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct i40evf_adapter *adapter = netdev_priv(netdev);\r\nring->rx_max_pending = I40EVF_MAX_RXD;\r\nring->tx_max_pending = I40EVF_MAX_TXD;\r\nring->rx_pending = adapter->rx_desc_count;\r\nring->tx_pending = adapter->tx_desc_count;\r\n}\r\nstatic int i40evf_set_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct i40evf_adapter *adapter = netdev_priv(netdev);\r\nu32 new_rx_count, new_tx_count;\r\nif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\r\nreturn -EINVAL;\r\nnew_tx_count = clamp_t(u32, ring->tx_pending,\r\nI40EVF_MIN_TXD,\r\nI40EVF_MAX_TXD);\r\nnew_tx_count = ALIGN(new_tx_count, I40EVF_REQ_DESCRIPTOR_MULTIPLE);\r\nnew_rx_count = clamp_t(u32, ring->rx_pending,\r\nI40EVF_MIN_RXD,\r\nI40EVF_MAX_RXD);\r\nnew_rx_count = ALIGN(new_rx_count, I40EVF_REQ_DESCRIPTOR_MULTIPLE);\r\nif ((new_tx_count == adapter->tx_desc_count) &&\r\n(new_rx_count == adapter->rx_desc_count))\r\nreturn 0;\r\nadapter->tx_desc_count = new_tx_count;\r\nadapter->rx_desc_count = new_rx_count;\r\nif (netif_running(netdev)) {\r\nadapter->flags |= I40EVF_FLAG_RESET_NEEDED;\r\nschedule_work(&adapter->reset_task);\r\n}\r\nreturn 0;\r\n}\r\nstatic int i40evf_get_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct i40evf_adapter *adapter = netdev_priv(netdev);\r\nstruct i40e_vsi *vsi = &adapter->vsi;\r\nec->tx_max_coalesced_frames = vsi->work_limit;\r\nec->rx_max_coalesced_frames = vsi->work_limit;\r\nif (ITR_IS_DYNAMIC(vsi->rx_itr_setting))\r\nec->use_adaptive_rx_coalesce = 1;\r\nif (ITR_IS_DYNAMIC(vsi->tx_itr_setting))\r\nec->use_adaptive_tx_coalesce = 1;\r\nec->rx_coalesce_usecs = vsi->rx_itr_setting & ~I40E_ITR_DYNAMIC;\r\nec->tx_coalesce_usecs = vsi->tx_itr_setting & ~I40E_ITR_DYNAMIC;\r\nreturn 0;\r\n}\r\nstatic int i40evf_set_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct i40evf_adapter *adapter = netdev_priv(netdev);\r\nstruct i40e_hw *hw = &adapter->hw;\r\nstruct i40e_vsi *vsi = &adapter->vsi;\r\nstruct i40e_q_vector *q_vector;\r\nint i;\r\nif (ec->tx_max_coalesced_frames_irq || ec->rx_max_coalesced_frames_irq)\r\nvsi->work_limit = ec->tx_max_coalesced_frames_irq;\r\nif ((ec->rx_coalesce_usecs >= (I40E_MIN_ITR << 1)) &&\r\n(ec->rx_coalesce_usecs <= (I40E_MAX_ITR << 1)))\r\nvsi->rx_itr_setting = ec->rx_coalesce_usecs;\r\nelse\r\nreturn -EINVAL;\r\nif ((ec->tx_coalesce_usecs >= (I40E_MIN_ITR << 1)) &&\r\n(ec->tx_coalesce_usecs <= (I40E_MAX_ITR << 1)))\r\nvsi->tx_itr_setting = ec->tx_coalesce_usecs;\r\nelse if (ec->use_adaptive_tx_coalesce)\r\nvsi->tx_itr_setting = (I40E_ITR_DYNAMIC |\r\nITR_REG_TO_USEC(I40E_ITR_RX_DEF));\r\nelse\r\nreturn -EINVAL;\r\nif (ec->use_adaptive_rx_coalesce)\r\nvsi->rx_itr_setting |= I40E_ITR_DYNAMIC;\r\nelse\r\nvsi->rx_itr_setting &= ~I40E_ITR_DYNAMIC;\r\nif (ec->use_adaptive_tx_coalesce)\r\nvsi->tx_itr_setting |= I40E_ITR_DYNAMIC;\r\nelse\r\nvsi->tx_itr_setting &= ~I40E_ITR_DYNAMIC;\r\nfor (i = 0; i < adapter->num_msix_vectors - NONQ_VECS; i++) {\r\nq_vector = adapter->q_vector[i];\r\nq_vector->rx.itr = ITR_TO_REG(vsi->rx_itr_setting);\r\nwr32(hw, I40E_VFINT_ITRN1(0, i), q_vector->rx.itr);\r\nq_vector->tx.itr = ITR_TO_REG(vsi->tx_itr_setting);\r\nwr32(hw, I40E_VFINT_ITRN1(1, i), q_vector->tx.itr);\r\ni40e_flush(hw);\r\n}\r\nreturn 0;\r\n}\r\nstatic int i40evf_get_rss_hash_opts(struct i40evf_adapter *adapter,\r\nstruct ethtool_rxnfc *cmd)\r\n{\r\nstruct i40e_hw *hw = &adapter->hw;\r\nu64 hena = (u64)rd32(hw, I40E_VFQF_HENA(0)) |\r\n((u64)rd32(hw, I40E_VFQF_HENA(1)) << 32);\r\ncmd->data = RXH_IP_SRC | RXH_IP_DST;\r\nswitch (cmd->flow_type) {\r\ncase TCP_V4_FLOW:\r\nif (hena & BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_TCP))\r\ncmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\nbreak;\r\ncase UDP_V4_FLOW:\r\nif (hena & BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_UDP))\r\ncmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\nbreak;\r\ncase SCTP_V4_FLOW:\r\ncase AH_ESP_V4_FLOW:\r\ncase AH_V4_FLOW:\r\ncase ESP_V4_FLOW:\r\ncase IPV4_FLOW:\r\nbreak;\r\ncase TCP_V6_FLOW:\r\nif (hena & BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_TCP))\r\ncmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\nbreak;\r\ncase UDP_V6_FLOW:\r\nif (hena & BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_UDP))\r\ncmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\nbreak;\r\ncase SCTP_V6_FLOW:\r\ncase AH_ESP_V6_FLOW:\r\ncase AH_V6_FLOW:\r\ncase ESP_V6_FLOW:\r\ncase IPV6_FLOW:\r\nbreak;\r\ndefault:\r\ncmd->data = 0;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i40evf_get_rxnfc(struct net_device *netdev,\r\nstruct ethtool_rxnfc *cmd,\r\nu32 *rule_locs)\r\n{\r\nstruct i40evf_adapter *adapter = netdev_priv(netdev);\r\nint ret = -EOPNOTSUPP;\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_GRXRINGS:\r\ncmd->data = adapter->num_active_queues;\r\nret = 0;\r\nbreak;\r\ncase ETHTOOL_GRXFH:\r\nret = i40evf_get_rss_hash_opts(adapter, cmd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int i40evf_set_rss_hash_opt(struct i40evf_adapter *adapter,\r\nstruct ethtool_rxnfc *nfc)\r\n{\r\nstruct i40e_hw *hw = &adapter->hw;\r\nu64 hena = (u64)rd32(hw, I40E_VFQF_HENA(0)) |\r\n((u64)rd32(hw, I40E_VFQF_HENA(1)) << 32);\r\nif (nfc->data & ~(RXH_IP_SRC | RXH_IP_DST |\r\nRXH_L4_B_0_1 | RXH_L4_B_2_3))\r\nreturn -EINVAL;\r\nif (!(nfc->data & RXH_IP_SRC) ||\r\n!(nfc->data & RXH_IP_DST))\r\nreturn -EINVAL;\r\nswitch (nfc->flow_type) {\r\ncase TCP_V4_FLOW:\r\nswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\r\ncase 0:\r\nhena &= ~BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_TCP);\r\nbreak;\r\ncase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\r\nhena |= BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_TCP);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase TCP_V6_FLOW:\r\nswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\r\ncase 0:\r\nhena &= ~BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_TCP);\r\nbreak;\r\ncase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\r\nhena |= BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_TCP);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase UDP_V4_FLOW:\r\nswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\r\ncase 0:\r\nhena &= ~(BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_UDP) |\r\nBIT_ULL(I40E_FILTER_PCTYPE_FRAG_IPV4));\r\nbreak;\r\ncase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\r\nhena |= (BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_UDP) |\r\nBIT_ULL(I40E_FILTER_PCTYPE_FRAG_IPV4));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase UDP_V6_FLOW:\r\nswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\r\ncase 0:\r\nhena &= ~(BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_UDP) |\r\nBIT_ULL(I40E_FILTER_PCTYPE_FRAG_IPV6));\r\nbreak;\r\ncase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\r\nhena |= (BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_UDP) |\r\nBIT_ULL(I40E_FILTER_PCTYPE_FRAG_IPV6));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase AH_ESP_V4_FLOW:\r\ncase AH_V4_FLOW:\r\ncase ESP_V4_FLOW:\r\ncase SCTP_V4_FLOW:\r\nif ((nfc->data & RXH_L4_B_0_1) ||\r\n(nfc->data & RXH_L4_B_2_3))\r\nreturn -EINVAL;\r\nhena |= BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_OTHER);\r\nbreak;\r\ncase AH_ESP_V6_FLOW:\r\ncase AH_V6_FLOW:\r\ncase ESP_V6_FLOW:\r\ncase SCTP_V6_FLOW:\r\nif ((nfc->data & RXH_L4_B_0_1) ||\r\n(nfc->data & RXH_L4_B_2_3))\r\nreturn -EINVAL;\r\nhena |= BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_OTHER);\r\nbreak;\r\ncase IPV4_FLOW:\r\nhena |= (BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_OTHER) |\r\nBIT_ULL(I40E_FILTER_PCTYPE_FRAG_IPV4));\r\nbreak;\r\ncase IPV6_FLOW:\r\nhena |= (BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_OTHER) |\r\nBIT_ULL(I40E_FILTER_PCTYPE_FRAG_IPV6));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwr32(hw, I40E_VFQF_HENA(0), (u32)hena);\r\nwr32(hw, I40E_VFQF_HENA(1), (u32)(hena >> 32));\r\ni40e_flush(hw);\r\nreturn 0;\r\n}\r\nstatic int i40evf_set_rxnfc(struct net_device *netdev,\r\nstruct ethtool_rxnfc *cmd)\r\n{\r\nstruct i40evf_adapter *adapter = netdev_priv(netdev);\r\nint ret = -EOPNOTSUPP;\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_SRXFH:\r\nret = i40evf_set_rss_hash_opt(adapter, cmd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void i40evf_get_channels(struct net_device *netdev,\r\nstruct ethtool_channels *ch)\r\n{\r\nstruct i40evf_adapter *adapter = netdev_priv(netdev);\r\nch->max_combined = adapter->num_active_queues;\r\nch->max_other = NONQ_VECS;\r\nch->other_count = NONQ_VECS;\r\nch->combined_count = adapter->num_active_queues;\r\n}\r\nstatic u32 i40evf_get_rxfh_indir_size(struct net_device *netdev)\r\n{\r\nreturn (I40E_VFQF_HLUT_MAX_INDEX + 1) * 4;\r\n}\r\nstatic int i40evf_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,\r\nu8 *hfunc)\r\n{\r\nstruct i40evf_adapter *adapter = netdev_priv(netdev);\r\nstruct i40e_hw *hw = &adapter->hw;\r\nu32 hlut_val;\r\nint i, j;\r\nif (hfunc)\r\n*hfunc = ETH_RSS_HASH_TOP;\r\nif (!indir)\r\nreturn 0;\r\nif (indir) {\r\nfor (i = 0, j = 0; i <= I40E_VFQF_HLUT_MAX_INDEX; i++) {\r\nhlut_val = rd32(hw, I40E_VFQF_HLUT(i));\r\nindir[j++] = hlut_val & 0xff;\r\nindir[j++] = (hlut_val >> 8) & 0xff;\r\nindir[j++] = (hlut_val >> 16) & 0xff;\r\nindir[j++] = (hlut_val >> 24) & 0xff;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int i40evf_set_rxfh(struct net_device *netdev, const u32 *indir,\r\nconst u8 *key, const u8 hfunc)\r\n{\r\nstruct i40evf_adapter *adapter = netdev_priv(netdev);\r\nstruct i40e_hw *hw = &adapter->hw;\r\nu32 hlut_val;\r\nint i, j;\r\nif (key ||\r\n(hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP))\r\nreturn -EOPNOTSUPP;\r\nif (!indir)\r\nreturn 0;\r\nfor (i = 0, j = 0; i <= I40E_VFQF_HLUT_MAX_INDEX; i++) {\r\nhlut_val = indir[j++];\r\nhlut_val |= indir[j++] << 8;\r\nhlut_val |= indir[j++] << 16;\r\nhlut_val |= indir[j++] << 24;\r\nwr32(hw, I40E_VFQF_HLUT(i), hlut_val);\r\n}\r\nreturn 0;\r\n}\r\nvoid i40evf_set_ethtool_ops(struct net_device *netdev)\r\n{\r\nnetdev->ethtool_ops = &i40evf_ethtool_ops;\r\n}
