static struct gs_tx_context *gs_alloc_tx_context(struct gs_can *dev)\r\n{\r\nint i = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->tx_ctx_lock, flags);\r\nfor (; i < GS_MAX_TX_URBS; i++) {\r\nif (dev->tx_context[i].echo_id == GS_MAX_TX_URBS) {\r\ndev->tx_context[i].echo_id = i;\r\nspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\r\nreturn &dev->tx_context[i];\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\r\nreturn NULL;\r\n}\r\nstatic void gs_free_tx_context(struct gs_tx_context *txc)\r\n{\r\ntxc->echo_id = GS_MAX_TX_URBS;\r\n}\r\nstatic struct gs_tx_context *gs_get_tx_context(struct gs_can *dev, unsigned int id)\r\n{\r\nunsigned long flags;\r\nif (id < GS_MAX_TX_URBS) {\r\nspin_lock_irqsave(&dev->tx_ctx_lock, flags);\r\nif (dev->tx_context[id].echo_id == id) {\r\nspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\r\nreturn &dev->tx_context[id];\r\n}\r\nspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\r\n}\r\nreturn NULL;\r\n}\r\nstatic int gs_cmd_reset(struct gs_usb *gsusb, struct gs_can *gsdev)\r\n{\r\nstruct gs_device_mode *dm;\r\nstruct usb_interface *intf = gsdev->iface;\r\nint rc;\r\ndm = kzalloc(sizeof(*dm), GFP_KERNEL);\r\nif (!dm)\r\nreturn -ENOMEM;\r\ndm->mode = GS_CAN_MODE_RESET;\r\nrc = usb_control_msg(interface_to_usbdev(intf),\r\nusb_sndctrlpipe(interface_to_usbdev(intf), 0),\r\nGS_USB_BREQ_MODE,\r\nUSB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\r\ngsdev->channel,\r\n0,\r\ndm,\r\nsizeof(*dm),\r\n1000);\r\nreturn rc;\r\n}\r\nstatic void gs_update_state(struct gs_can *dev, struct can_frame *cf)\r\n{\r\nstruct can_device_stats *can_stats = &dev->can.can_stats;\r\nif (cf->can_id & CAN_ERR_RESTARTED) {\r\ndev->can.state = CAN_STATE_ERROR_ACTIVE;\r\ncan_stats->restarts++;\r\n} else if (cf->can_id & CAN_ERR_BUSOFF) {\r\ndev->can.state = CAN_STATE_BUS_OFF;\r\ncan_stats->bus_off++;\r\n} else if (cf->can_id & CAN_ERR_CRTL) {\r\nif ((cf->data[1] & CAN_ERR_CRTL_TX_WARNING) ||\r\n(cf->data[1] & CAN_ERR_CRTL_RX_WARNING)) {\r\ndev->can.state = CAN_STATE_ERROR_WARNING;\r\ncan_stats->error_warning++;\r\n} else if ((cf->data[1] & CAN_ERR_CRTL_TX_PASSIVE) ||\r\n(cf->data[1] & CAN_ERR_CRTL_RX_PASSIVE)) {\r\ndev->can.state = CAN_STATE_ERROR_PASSIVE;\r\ncan_stats->error_passive++;\r\n} else {\r\ndev->can.state = CAN_STATE_ERROR_ACTIVE;\r\n}\r\n}\r\n}\r\nstatic void gs_usb_receive_bulk_callback(struct urb *urb)\r\n{\r\nstruct gs_usb *usbcan = urb->context;\r\nstruct gs_can *dev;\r\nstruct net_device *netdev;\r\nint rc;\r\nstruct net_device_stats *stats;\r\nstruct gs_host_frame *hf = urb->transfer_buffer;\r\nstruct gs_tx_context *txc;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nBUG_ON(!usbcan);\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\nreturn;\r\n}\r\nif (hf->channel >= GS_MAX_INTF)\r\ngoto resubmit_urb;\r\ndev = usbcan->canch[hf->channel];\r\nnetdev = dev->netdev;\r\nstats = &netdev->stats;\r\nif (!netif_device_present(netdev))\r\nreturn;\r\nif (hf->echo_id == -1) {\r\nskb = alloc_can_skb(dev->netdev, &cf);\r\nif (!skb)\r\nreturn;\r\ncf->can_id = hf->can_id;\r\ncf->can_dlc = get_can_dlc(hf->can_dlc);\r\nmemcpy(cf->data, hf->data, 8);\r\nif (hf->can_id & CAN_ERR_FLAG)\r\ngs_update_state(dev, cf);\r\nnetdev->stats.rx_packets++;\r\nnetdev->stats.rx_bytes += hf->can_dlc;\r\nnetif_rx(skb);\r\n} else {\r\nif (hf->echo_id >= GS_MAX_TX_URBS) {\r\nnetdev_err(netdev,\r\n"Unexpected out of range echo id %d\n",\r\nhf->echo_id);\r\ngoto resubmit_urb;\r\n}\r\nnetdev->stats.tx_packets++;\r\nnetdev->stats.tx_bytes += hf->can_dlc;\r\ntxc = gs_get_tx_context(dev, hf->echo_id);\r\nif (!txc) {\r\nnetdev_err(netdev,\r\n"Unexpected unused echo id %d\n",\r\nhf->echo_id);\r\ngoto resubmit_urb;\r\n}\r\ncan_get_echo_skb(netdev, hf->echo_id);\r\ngs_free_tx_context(txc);\r\nnetif_wake_queue(netdev);\r\n}\r\nif (hf->flags & GS_CAN_FLAG_OVERFLOW) {\r\nskb = alloc_can_err_skb(netdev, &cf);\r\nif (!skb)\r\ngoto resubmit_urb;\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->can_dlc = CAN_ERR_DLC;\r\ncf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\nstats->rx_over_errors++;\r\nstats->rx_errors++;\r\nnetif_rx(skb);\r\n}\r\nresubmit_urb:\r\nusb_fill_bulk_urb(urb,\r\nusbcan->udev,\r\nusb_rcvbulkpipe(usbcan->udev, GSUSB_ENDPOINT_IN),\r\nhf,\r\nsizeof(struct gs_host_frame),\r\ngs_usb_receive_bulk_callback,\r\nusbcan\r\n);\r\nrc = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (rc == -ENODEV) {\r\nfor (rc = 0; rc < GS_MAX_INTF; rc++) {\r\nif (usbcan->canch[rc])\r\nnetif_device_detach(usbcan->canch[rc]->netdev);\r\n}\r\n}\r\n}\r\nstatic int gs_usb_set_bittiming(struct net_device *netdev)\r\n{\r\nstruct gs_can *dev = netdev_priv(netdev);\r\nstruct can_bittiming *bt = &dev->can.bittiming;\r\nstruct usb_interface *intf = dev->iface;\r\nint rc;\r\nstruct gs_device_bittiming *dbt;\r\ndbt = kmalloc(sizeof(*dbt), GFP_KERNEL);\r\nif (!dbt)\r\nreturn -ENOMEM;\r\ndbt->prop_seg = bt->prop_seg;\r\ndbt->phase_seg1 = bt->phase_seg1;\r\ndbt->phase_seg2 = bt->phase_seg2;\r\ndbt->sjw = bt->sjw;\r\ndbt->brp = bt->brp;\r\nrc = usb_control_msg(interface_to_usbdev(intf),\r\nusb_sndctrlpipe(interface_to_usbdev(intf), 0),\r\nGS_USB_BREQ_BITTIMING,\r\nUSB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\r\ndev->channel,\r\n0,\r\ndbt,\r\nsizeof(*dbt),\r\n1000);\r\nkfree(dbt);\r\nif (rc < 0)\r\ndev_err(netdev->dev.parent, "Couldn't set bittimings (err=%d)",\r\nrc);\r\nreturn rc;\r\n}\r\nstatic void gs_usb_xmit_callback(struct urb *urb)\r\n{\r\nstruct gs_tx_context *txc = urb->context;\r\nstruct gs_can *dev = txc->dev;\r\nstruct net_device *netdev = dev->netdev;\r\nif (urb->status)\r\nnetdev_info(netdev, "usb xmit fail %d\n", txc->echo_id);\r\nusb_free_coherent(urb->dev,\r\nurb->transfer_buffer_length,\r\nurb->transfer_buffer,\r\nurb->transfer_dma);\r\natomic_dec(&dev->active_tx_urbs);\r\nif (!netif_device_present(netdev))\r\nreturn;\r\nif (netif_queue_stopped(netdev))\r\nnetif_wake_queue(netdev);\r\n}\r\nstatic netdev_tx_t gs_can_start_xmit(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nstruct gs_can *dev = netdev_priv(netdev);\r\nstruct net_device_stats *stats = &dev->netdev->stats;\r\nstruct urb *urb;\r\nstruct gs_host_frame *hf;\r\nstruct can_frame *cf;\r\nint rc;\r\nunsigned int idx;\r\nstruct gs_tx_context *txc;\r\nif (can_dropped_invalid_skb(netdev, skb))\r\nreturn NETDEV_TX_OK;\r\ntxc = gs_alloc_tx_context(dev);\r\nif (!txc)\r\nreturn NETDEV_TX_BUSY;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\nnetdev_err(netdev, "No memory left for URB\n");\r\ngoto nomem_urb;\r\n}\r\nhf = usb_alloc_coherent(dev->udev, sizeof(*hf), GFP_ATOMIC,\r\n&urb->transfer_dma);\r\nif (!hf) {\r\nnetdev_err(netdev, "No memory left for USB buffer\n");\r\ngoto nomem_hf;\r\n}\r\nidx = txc->echo_id;\r\nif (idx >= GS_MAX_TX_URBS) {\r\nnetdev_err(netdev, "Invalid tx context %d\n", idx);\r\ngoto badidx;\r\n}\r\nhf->echo_id = idx;\r\nhf->channel = dev->channel;\r\ncf = (struct can_frame *)skb->data;\r\nhf->can_id = cf->can_id;\r\nhf->can_dlc = cf->can_dlc;\r\nmemcpy(hf->data, cf->data, cf->can_dlc);\r\nusb_fill_bulk_urb(urb, dev->udev,\r\nusb_sndbulkpipe(dev->udev, GSUSB_ENDPOINT_OUT),\r\nhf,\r\nsizeof(*hf),\r\ngs_usb_xmit_callback,\r\ntxc);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_anchor_urb(urb, &dev->tx_submitted);\r\ncan_put_echo_skb(skb, netdev, idx);\r\natomic_inc(&dev->active_tx_urbs);\r\nrc = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (unlikely(rc)) {\r\natomic_dec(&dev->active_tx_urbs);\r\ncan_free_echo_skb(netdev, idx);\r\ngs_free_tx_context(txc);\r\nusb_unanchor_urb(urb);\r\nusb_free_coherent(dev->udev,\r\nsizeof(*hf),\r\nhf,\r\nurb->transfer_dma);\r\nif (rc == -ENODEV) {\r\nnetif_device_detach(netdev);\r\n} else {\r\nnetdev_err(netdev, "usb_submit failed (err=%d)\n", rc);\r\nstats->tx_dropped++;\r\n}\r\n} else {\r\nif (atomic_read(&dev->active_tx_urbs) >= GS_MAX_TX_URBS)\r\nnetif_stop_queue(netdev);\r\n}\r\nusb_free_urb(urb);\r\nreturn NETDEV_TX_OK;\r\nbadidx:\r\nusb_free_coherent(dev->udev,\r\nsizeof(*hf),\r\nhf,\r\nurb->transfer_dma);\r\nnomem_hf:\r\nusb_free_urb(urb);\r\nnomem_urb:\r\ngs_free_tx_context(txc);\r\ndev_kfree_skb(skb);\r\nstats->tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int gs_can_open(struct net_device *netdev)\r\n{\r\nstruct gs_can *dev = netdev_priv(netdev);\r\nstruct gs_usb *parent = dev->parent;\r\nint rc, i;\r\nstruct gs_device_mode *dm;\r\nu32 ctrlmode;\r\nrc = open_candev(netdev);\r\nif (rc)\r\nreturn rc;\r\nif (atomic_add_return(1, &parent->active_channels) == 1) {\r\nfor (i = 0; i < GS_MAX_RX_URBS; i++) {\r\nstruct urb *urb;\r\nu8 *buf;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nnetdev_err(netdev,\r\n"No memory left for URB\n");\r\nreturn -ENOMEM;\r\n}\r\nbuf = usb_alloc_coherent(dev->udev,\r\nsizeof(struct gs_host_frame),\r\nGFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (!buf) {\r\nnetdev_err(netdev,\r\n"No memory left for USB buffer\n");\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\nusb_fill_bulk_urb(urb,\r\ndev->udev,\r\nusb_rcvbulkpipe(dev->udev,\r\nGSUSB_ENDPOINT_IN),\r\nbuf,\r\nsizeof(struct gs_host_frame),\r\ngs_usb_receive_bulk_callback,\r\nparent);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_anchor_urb(urb, &parent->rx_submitted);\r\nrc = usb_submit_urb(urb, GFP_KERNEL);\r\nif (rc) {\r\nif (rc == -ENODEV)\r\nnetif_device_detach(dev->netdev);\r\nnetdev_err(netdev,\r\n"usb_submit failed (err=%d)\n",\r\nrc);\r\nusb_unanchor_urb(urb);\r\nbreak;\r\n}\r\nusb_free_urb(urb);\r\n}\r\n}\r\ndm = kmalloc(sizeof(*dm), GFP_KERNEL);\r\nif (!dm)\r\nreturn -ENOMEM;\r\nctrlmode = dev->can.ctrlmode;\r\ndm->flags = 0;\r\nif (ctrlmode & CAN_CTRLMODE_LOOPBACK)\r\ndm->flags |= GS_CAN_MODE_LOOP_BACK;\r\nelse if (ctrlmode & CAN_CTRLMODE_LISTENONLY)\r\ndm->flags |= GS_CAN_MODE_LISTEN_ONLY;\r\nif (ctrlmode & CAN_CTRLMODE_ONE_SHOT)\r\ndm->flags |= GS_CAN_MODE_ONE_SHOT;\r\nif (ctrlmode & CAN_CTRLMODE_3_SAMPLES)\r\ndm->flags |= GS_CAN_MODE_TRIPLE_SAMPLE;\r\ndm->mode = GS_CAN_MODE_START;\r\nrc = usb_control_msg(interface_to_usbdev(dev->iface),\r\nusb_sndctrlpipe(interface_to_usbdev(dev->iface), 0),\r\nGS_USB_BREQ_MODE,\r\nUSB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\r\ndev->channel,\r\n0,\r\ndm,\r\nsizeof(*dm),\r\n1000);\r\nif (rc < 0) {\r\nnetdev_err(netdev, "Couldn't start device (err=%d)\n", rc);\r\nkfree(dm);\r\nreturn rc;\r\n}\r\nkfree(dm);\r\ndev->can.state = CAN_STATE_ERROR_ACTIVE;\r\nif (!(dev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))\r\nnetif_start_queue(netdev);\r\nreturn 0;\r\n}\r\nstatic int gs_can_close(struct net_device *netdev)\r\n{\r\nint rc;\r\nstruct gs_can *dev = netdev_priv(netdev);\r\nstruct gs_usb *parent = dev->parent;\r\nnetif_stop_queue(netdev);\r\nif (atomic_dec_and_test(&parent->active_channels))\r\nusb_kill_anchored_urbs(&parent->rx_submitted);\r\nusb_kill_anchored_urbs(&dev->tx_submitted);\r\natomic_set(&dev->active_tx_urbs, 0);\r\nrc = gs_cmd_reset(parent, dev);\r\nif (rc < 0)\r\nnetdev_warn(netdev, "Couldn't shutdown device (err=%d)", rc);\r\nfor (rc = 0; rc < GS_MAX_TX_URBS; rc++) {\r\ndev->tx_context[rc].dev = dev;\r\ndev->tx_context[rc].echo_id = GS_MAX_TX_URBS;\r\n}\r\nclose_candev(netdev);\r\nreturn 0;\r\n}\r\nstatic struct gs_can *gs_make_candev(unsigned int channel, struct usb_interface *intf)\r\n{\r\nstruct gs_can *dev;\r\nstruct net_device *netdev;\r\nint rc;\r\nstruct gs_device_bt_const *bt_const;\r\nbt_const = kmalloc(sizeof(*bt_const), GFP_KERNEL);\r\nif (!bt_const)\r\nreturn ERR_PTR(-ENOMEM);\r\nrc = usb_control_msg(interface_to_usbdev(intf),\r\nusb_rcvctrlpipe(interface_to_usbdev(intf), 0),\r\nGS_USB_BREQ_BT_CONST,\r\nUSB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\r\nchannel,\r\n0,\r\nbt_const,\r\nsizeof(*bt_const),\r\n1000);\r\nif (rc < 0) {\r\ndev_err(&intf->dev,\r\n"Couldn't get bit timing const for channel (err=%d)\n",\r\nrc);\r\nkfree(bt_const);\r\nreturn ERR_PTR(rc);\r\n}\r\nnetdev = alloc_candev(sizeof(struct gs_can), GS_MAX_TX_URBS);\r\nif (!netdev) {\r\ndev_err(&intf->dev, "Couldn't allocate candev\n");\r\nkfree(bt_const);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ndev = netdev_priv(netdev);\r\nnetdev->netdev_ops = &gs_usb_netdev_ops;\r\nnetdev->flags |= IFF_ECHO;\r\nstrcpy(dev->bt_const.name, "gs_usb");\r\ndev->bt_const.tseg1_min = bt_const->tseg1_min;\r\ndev->bt_const.tseg1_max = bt_const->tseg1_max;\r\ndev->bt_const.tseg2_min = bt_const->tseg2_min;\r\ndev->bt_const.tseg2_max = bt_const->tseg2_max;\r\ndev->bt_const.sjw_max = bt_const->sjw_max;\r\ndev->bt_const.brp_min = bt_const->brp_min;\r\ndev->bt_const.brp_max = bt_const->brp_max;\r\ndev->bt_const.brp_inc = bt_const->brp_inc;\r\ndev->udev = interface_to_usbdev(intf);\r\ndev->iface = intf;\r\ndev->netdev = netdev;\r\ndev->channel = channel;\r\ninit_usb_anchor(&dev->tx_submitted);\r\natomic_set(&dev->active_tx_urbs, 0);\r\nspin_lock_init(&dev->tx_ctx_lock);\r\nfor (rc = 0; rc < GS_MAX_TX_URBS; rc++) {\r\ndev->tx_context[rc].dev = dev;\r\ndev->tx_context[rc].echo_id = GS_MAX_TX_URBS;\r\n}\r\ndev->can.state = CAN_STATE_STOPPED;\r\ndev->can.clock.freq = bt_const->fclk_can;\r\ndev->can.bittiming_const = &dev->bt_const;\r\ndev->can.do_set_bittiming = gs_usb_set_bittiming;\r\ndev->can.ctrlmode_supported = 0;\r\nif (bt_const->feature & GS_CAN_FEATURE_LISTEN_ONLY)\r\ndev->can.ctrlmode_supported |= CAN_CTRLMODE_LISTENONLY;\r\nif (bt_const->feature & GS_CAN_FEATURE_LOOP_BACK)\r\ndev->can.ctrlmode_supported |= CAN_CTRLMODE_LOOPBACK;\r\nif (bt_const->feature & GS_CAN_FEATURE_TRIPLE_SAMPLE)\r\ndev->can.ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;\r\nif (bt_const->feature & GS_CAN_FEATURE_ONE_SHOT)\r\ndev->can.ctrlmode_supported |= CAN_CTRLMODE_ONE_SHOT;\r\nkfree(bt_const);\r\nSET_NETDEV_DEV(netdev, &intf->dev);\r\nrc = register_candev(dev->netdev);\r\nif (rc) {\r\nfree_candev(dev->netdev);\r\ndev_err(&intf->dev, "Couldn't register candev (err=%d)\n", rc);\r\nreturn ERR_PTR(rc);\r\n}\r\nreturn dev;\r\n}\r\nstatic void gs_destroy_candev(struct gs_can *dev)\r\n{\r\nunregister_candev(dev->netdev);\r\nfree_candev(dev->netdev);\r\nusb_kill_anchored_urbs(&dev->tx_submitted);\r\nkfree(dev);\r\n}\r\nstatic int gs_usb_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct gs_usb *dev;\r\nint rc = -ENOMEM;\r\nunsigned int icount, i;\r\nstruct gs_host_config *hconf;\r\nstruct gs_device_config *dconf;\r\nhconf = kmalloc(sizeof(*hconf), GFP_KERNEL);\r\nif (!hconf)\r\nreturn -ENOMEM;\r\nhconf->byte_order = 0x0000beef;\r\nrc = usb_control_msg(interface_to_usbdev(intf),\r\nusb_sndctrlpipe(interface_to_usbdev(intf), 0),\r\nGS_USB_BREQ_HOST_FORMAT,\r\nUSB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\r\n1,\r\nintf->altsetting[0].desc.bInterfaceNumber,\r\nhconf,\r\nsizeof(*hconf),\r\n1000);\r\nkfree(hconf);\r\nif (rc < 0) {\r\ndev_err(&intf->dev, "Couldn't send data format (err=%d)\n",\r\nrc);\r\nreturn rc;\r\n}\r\ndconf = kmalloc(sizeof(*dconf), GFP_KERNEL);\r\nif (!dconf)\r\nreturn -ENOMEM;\r\nrc = usb_control_msg(interface_to_usbdev(intf),\r\nusb_rcvctrlpipe(interface_to_usbdev(intf), 0),\r\nGS_USB_BREQ_DEVICE_CONFIG,\r\nUSB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\r\n1,\r\nintf->altsetting[0].desc.bInterfaceNumber,\r\ndconf,\r\nsizeof(*dconf),\r\n1000);\r\nif (rc < 0) {\r\ndev_err(&intf->dev, "Couldn't get device config: (err=%d)\n",\r\nrc);\r\nkfree(dconf);\r\nreturn rc;\r\n}\r\nicount = dconf->icount+1;\r\nkfree(dconf);\r\ndev_info(&intf->dev, "Configuring for %d interfaces\n", icount);\r\nif (icount > GS_MAX_INTF) {\r\ndev_err(&intf->dev,\r\n"Driver cannot handle more that %d CAN interfaces\n",\r\nGS_MAX_INTF);\r\nreturn -EINVAL;\r\n}\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ninit_usb_anchor(&dev->rx_submitted);\r\natomic_set(&dev->active_channels, 0);\r\nusb_set_intfdata(intf, dev);\r\ndev->udev = interface_to_usbdev(intf);\r\nfor (i = 0; i < icount; i++) {\r\ndev->canch[i] = gs_make_candev(i, intf);\r\nif (IS_ERR_OR_NULL(dev->canch[i])) {\r\nicount = i;\r\nfor (i = 0; i < icount; i++) {\r\ngs_destroy_candev(dev->canch[i]);\r\ndev->canch[i] = NULL;\r\n}\r\nkfree(dev);\r\nreturn rc;\r\n}\r\ndev->canch[i]->parent = dev;\r\n}\r\nreturn 0;\r\n}\r\nstatic void gs_usb_disconnect(struct usb_interface *intf)\r\n{\r\nunsigned i;\r\nstruct gs_usb *dev = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nif (!dev) {\r\ndev_err(&intf->dev, "Disconnect (nodata)\n");\r\nreturn;\r\n}\r\nfor (i = 0; i < GS_MAX_INTF; i++) {\r\nstruct gs_can *can = dev->canch[i];\r\nif (!can)\r\ncontinue;\r\ngs_destroy_candev(can);\r\n}\r\nusb_kill_anchored_urbs(&dev->rx_submitted);\r\n}
