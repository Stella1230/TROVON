static void nd_pfn_release(struct device *dev)\r\n{\r\nstruct nd_region *nd_region = to_nd_region(dev->parent);\r\nstruct nd_pfn *nd_pfn = to_nd_pfn(dev);\r\ndev_dbg(dev, "%s\n", __func__);\r\nnd_detach_ndns(&nd_pfn->dev, &nd_pfn->ndns);\r\nida_simple_remove(&nd_region->pfn_ida, nd_pfn->id);\r\nkfree(nd_pfn->uuid);\r\nkfree(nd_pfn);\r\n}\r\nbool is_nd_pfn(struct device *dev)\r\n{\r\nreturn dev ? dev->type == &nd_pfn_device_type : false;\r\n}\r\nstruct nd_pfn *to_nd_pfn(struct device *dev)\r\n{\r\nstruct nd_pfn *nd_pfn = container_of(dev, struct nd_pfn, dev);\r\nWARN_ON(!is_nd_pfn(dev));\r\nreturn nd_pfn;\r\n}\r\nstatic ssize_t mode_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct nd_pfn *nd_pfn = to_nd_pfn(dev);\r\nswitch (nd_pfn->mode) {\r\ncase PFN_MODE_RAM:\r\nreturn sprintf(buf, "ram\n");\r\ncase PFN_MODE_PMEM:\r\nreturn sprintf(buf, "pmem\n");\r\ndefault:\r\nreturn sprintf(buf, "none\n");\r\n}\r\n}\r\nstatic ssize_t mode_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct nd_pfn *nd_pfn = to_nd_pfn(dev);\r\nssize_t rc = 0;\r\ndevice_lock(dev);\r\nnvdimm_bus_lock(dev);\r\nif (dev->driver)\r\nrc = -EBUSY;\r\nelse {\r\nsize_t n = len - 1;\r\nif (strncmp(buf, "pmem\n", n) == 0\r\n|| strncmp(buf, "pmem", n) == 0) {\r\nrc = -ENOTTY;\r\n} else if (strncmp(buf, "ram\n", n) == 0\r\n|| strncmp(buf, "ram", n) == 0)\r\nnd_pfn->mode = PFN_MODE_RAM;\r\nelse if (strncmp(buf, "none\n", n) == 0\r\n|| strncmp(buf, "none", n) == 0)\r\nnd_pfn->mode = PFN_MODE_NONE;\r\nelse\r\nrc = -EINVAL;\r\n}\r\ndev_dbg(dev, "%s: result: %zd wrote: %s%s", __func__,\r\nrc, buf, buf[len - 1] == '\n' ? "" : "\n");\r\nnvdimm_bus_unlock(dev);\r\ndevice_unlock(dev);\r\nreturn rc ? rc : len;\r\n}\r\nstatic ssize_t uuid_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct nd_pfn *nd_pfn = to_nd_pfn(dev);\r\nif (nd_pfn->uuid)\r\nreturn sprintf(buf, "%pUb\n", nd_pfn->uuid);\r\nreturn sprintf(buf, "\n");\r\n}\r\nstatic ssize_t uuid_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct nd_pfn *nd_pfn = to_nd_pfn(dev);\r\nssize_t rc;\r\ndevice_lock(dev);\r\nrc = nd_uuid_store(dev, &nd_pfn->uuid, buf, len);\r\ndev_dbg(dev, "%s: result: %zd wrote: %s%s", __func__,\r\nrc, buf, buf[len - 1] == '\n' ? "" : "\n");\r\ndevice_unlock(dev);\r\nreturn rc ? rc : len;\r\n}\r\nstatic ssize_t namespace_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct nd_pfn *nd_pfn = to_nd_pfn(dev);\r\nssize_t rc;\r\nnvdimm_bus_lock(dev);\r\nrc = sprintf(buf, "%s\n", nd_pfn->ndns\r\n? dev_name(&nd_pfn->ndns->dev) : "");\r\nnvdimm_bus_unlock(dev);\r\nreturn rc;\r\n}\r\nstatic ssize_t namespace_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct nd_pfn *nd_pfn = to_nd_pfn(dev);\r\nssize_t rc;\r\ndevice_lock(dev);\r\nnvdimm_bus_lock(dev);\r\nrc = nd_namespace_store(dev, &nd_pfn->ndns, buf, len);\r\ndev_dbg(dev, "%s: result: %zd wrote: %s%s", __func__,\r\nrc, buf, buf[len - 1] == '\n' ? "" : "\n");\r\nnvdimm_bus_unlock(dev);\r\ndevice_unlock(dev);\r\nreturn rc;\r\n}\r\nstatic struct device *__nd_pfn_create(struct nd_region *nd_region,\r\nu8 *uuid, enum nd_pfn_mode mode,\r\nstruct nd_namespace_common *ndns)\r\n{\r\nstruct nd_pfn *nd_pfn;\r\nstruct device *dev;\r\nif (!is_nd_pmem(&nd_region->dev))\r\nreturn NULL;\r\nnd_pfn = kzalloc(sizeof(*nd_pfn), GFP_KERNEL);\r\nif (!nd_pfn)\r\nreturn NULL;\r\nnd_pfn->id = ida_simple_get(&nd_region->pfn_ida, 0, 0, GFP_KERNEL);\r\nif (nd_pfn->id < 0) {\r\nkfree(nd_pfn);\r\nreturn NULL;\r\n}\r\nnd_pfn->mode = mode;\r\nif (uuid)\r\nuuid = kmemdup(uuid, 16, GFP_KERNEL);\r\nnd_pfn->uuid = uuid;\r\ndev = &nd_pfn->dev;\r\ndev_set_name(dev, "pfn%d.%d", nd_region->id, nd_pfn->id);\r\ndev->parent = &nd_region->dev;\r\ndev->type = &nd_pfn_device_type;\r\ndev->groups = nd_pfn_attribute_groups;\r\ndevice_initialize(&nd_pfn->dev);\r\nif (ndns && !__nd_attach_ndns(&nd_pfn->dev, ndns, &nd_pfn->ndns)) {\r\ndev_dbg(&ndns->dev, "%s failed, already claimed by %s\n",\r\n__func__, dev_name(ndns->claim));\r\nput_device(dev);\r\nreturn NULL;\r\n}\r\nreturn dev;\r\n}\r\nstruct device *nd_pfn_create(struct nd_region *nd_region)\r\n{\r\nstruct device *dev = __nd_pfn_create(nd_region, NULL, PFN_MODE_NONE,\r\nNULL);\r\nif (dev)\r\n__nd_device_register(dev);\r\nreturn dev;\r\n}\r\nint nd_pfn_validate(struct nd_pfn *nd_pfn)\r\n{\r\nstruct nd_namespace_common *ndns = nd_pfn->ndns;\r\nstruct nd_pfn_sb *pfn_sb = nd_pfn->pfn_sb;\r\nstruct nd_namespace_io *nsio;\r\nu64 checksum, offset;\r\nif (!pfn_sb || !ndns)\r\nreturn -ENODEV;\r\nif (!is_nd_pmem(nd_pfn->dev.parent))\r\nreturn -ENODEV;\r\nif (nvdimm_namespace_capacity(ndns) < ND_PFN_ALIGN)\r\nreturn -ENODEV;\r\nif (nvdimm_read_bytes(ndns, SZ_4K, pfn_sb, sizeof(*pfn_sb)))\r\nreturn -ENXIO;\r\nif (memcmp(pfn_sb->signature, PFN_SIG, PFN_SIG_LEN) != 0)\r\nreturn -ENODEV;\r\nchecksum = le64_to_cpu(pfn_sb->checksum);\r\npfn_sb->checksum = 0;\r\nif (checksum != nd_sb_checksum((struct nd_gen_sb *) pfn_sb))\r\nreturn -ENODEV;\r\npfn_sb->checksum = cpu_to_le64(checksum);\r\nswitch (le32_to_cpu(pfn_sb->mode)) {\r\ncase PFN_MODE_RAM:\r\nbreak;\r\ncase PFN_MODE_PMEM:\r\nreturn -ENOTTY;\r\ndefault:\r\nreturn -ENXIO;\r\n}\r\nif (!nd_pfn->uuid) {\r\nnd_pfn->uuid = kmemdup(pfn_sb->uuid, 16, GFP_KERNEL);\r\nif (!nd_pfn->uuid)\r\nreturn -ENOMEM;\r\n} else {\r\nif (memcmp(nd_pfn->uuid, pfn_sb->uuid, 16) != 0)\r\nreturn -EINVAL;\r\n}\r\noffset = le64_to_cpu(pfn_sb->dataoff);\r\nnsio = to_nd_namespace_io(&ndns->dev);\r\nif (nsio->res.start & ND_PFN_MASK) {\r\ndev_err(&nd_pfn->dev,\r\n"init failed: %s not section aligned\n",\r\ndev_name(&ndns->dev));\r\nreturn -EBUSY;\r\n} else if (offset >= resource_size(&nsio->res)) {\r\ndev_err(&nd_pfn->dev, "pfn array size exceeds capacity of %s\n",\r\ndev_name(&ndns->dev));\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nint nd_pfn_probe(struct nd_namespace_common *ndns, void *drvdata)\r\n{\r\nint rc;\r\nstruct device *dev;\r\nstruct nd_pfn *nd_pfn;\r\nstruct nd_pfn_sb *pfn_sb;\r\nstruct nd_region *nd_region = to_nd_region(ndns->dev.parent);\r\nif (ndns->force_raw)\r\nreturn -ENODEV;\r\nnvdimm_bus_lock(&ndns->dev);\r\ndev = __nd_pfn_create(nd_region, NULL, PFN_MODE_NONE, ndns);\r\nnvdimm_bus_unlock(&ndns->dev);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, drvdata);\r\npfn_sb = kzalloc(sizeof(*pfn_sb), GFP_KERNEL);\r\nnd_pfn = to_nd_pfn(dev);\r\nnd_pfn->pfn_sb = pfn_sb;\r\nrc = nd_pfn_validate(nd_pfn);\r\nnd_pfn->pfn_sb = NULL;\r\nkfree(pfn_sb);\r\ndev_dbg(&ndns->dev, "%s: pfn: %s\n", __func__,\r\nrc == 0 ? dev_name(dev) : "<none>");\r\nif (rc < 0) {\r\n__nd_detach_ndns(dev, &nd_pfn->ndns);\r\nput_device(dev);\r\n} else\r\n__nd_device_register(&nd_pfn->dev);\r\nreturn rc;\r\n}
