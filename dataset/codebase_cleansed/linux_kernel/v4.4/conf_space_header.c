static void *command_init(struct pci_dev *dev, int offset)\r\n{\r\nstruct pci_cmd_info *cmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\r\nint err;\r\nif (!cmd)\r\nreturn ERR_PTR(-ENOMEM);\r\nerr = pci_read_config_word(dev, PCI_COMMAND, &cmd->val);\r\nif (err) {\r\nkfree(cmd);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn cmd;\r\n}\r\nstatic int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)\r\n{\r\nint ret = pci_read_config_word(dev, offset, value);\r\nconst struct pci_cmd_info *cmd = data;\r\n*value &= PCI_COMMAND_GUEST;\r\n*value |= cmd->val & ~PCI_COMMAND_GUEST;\r\nreturn ret;\r\n}\r\nstatic int command_write(struct pci_dev *dev, int offset, u16 value, void *data)\r\n{\r\nstruct xen_pcibk_dev_data *dev_data;\r\nint err;\r\nu16 val;\r\nstruct pci_cmd_info *cmd = data;\r\ndev_data = pci_get_drvdata(dev);\r\nif (!pci_is_enabled(dev) && is_enable_cmd(value)) {\r\nif (unlikely(verbose_request))\r\nprintk(KERN_DEBUG DRV_NAME ": %s: enable\n",\r\npci_name(dev));\r\nerr = pci_enable_device(dev);\r\nif (err)\r\nreturn err;\r\nif (dev_data)\r\ndev_data->enable_intx = 1;\r\n} else if (pci_is_enabled(dev) && !is_enable_cmd(value)) {\r\nif (unlikely(verbose_request))\r\nprintk(KERN_DEBUG DRV_NAME ": %s: disable\n",\r\npci_name(dev));\r\npci_disable_device(dev);\r\nif (dev_data)\r\ndev_data->enable_intx = 0;\r\n}\r\nif (!dev->is_busmaster && is_master_cmd(value)) {\r\nif (unlikely(verbose_request))\r\nprintk(KERN_DEBUG DRV_NAME ": %s: set bus master\n",\r\npci_name(dev));\r\npci_set_master(dev);\r\n} else if (dev->is_busmaster && !is_master_cmd(value)) {\r\nif (unlikely(verbose_request))\r\nprintk(KERN_DEBUG DRV_NAME ": %s: clear bus master\n",\r\npci_name(dev));\r\npci_clear_master(dev);\r\n}\r\nif (!(cmd->val & PCI_COMMAND_INVALIDATE) &&\r\n(value & PCI_COMMAND_INVALIDATE)) {\r\nif (unlikely(verbose_request))\r\nprintk(KERN_DEBUG\r\nDRV_NAME ": %s: enable memory-write-invalidate\n",\r\npci_name(dev));\r\nerr = pci_set_mwi(dev);\r\nif (err) {\r\npr_warn("%s: cannot enable memory-write-invalidate (%d)\n",\r\npci_name(dev), err);\r\nvalue &= ~PCI_COMMAND_INVALIDATE;\r\n}\r\n} else if ((cmd->val & PCI_COMMAND_INVALIDATE) &&\r\n!(value & PCI_COMMAND_INVALIDATE)) {\r\nif (unlikely(verbose_request))\r\nprintk(KERN_DEBUG\r\nDRV_NAME ": %s: disable memory-write-invalidate\n",\r\npci_name(dev));\r\npci_clear_mwi(dev);\r\n}\r\ncmd->val = value;\r\nif (!xen_pcibk_permissive && (!dev_data || !dev_data->permissive))\r\nreturn 0;\r\nerr = pci_read_config_word(dev, offset, &val);\r\nif (err || val == value)\r\nreturn err;\r\nvalue &= PCI_COMMAND_GUEST;\r\nvalue |= val & ~PCI_COMMAND_GUEST;\r\nreturn pci_write_config_word(dev, offset, value);\r\n}\r\nstatic int rom_write(struct pci_dev *dev, int offset, u32 value, void *data)\r\n{\r\nstruct pci_bar_info *bar = data;\r\nif (unlikely(!bar)) {\r\npr_warn(DRV_NAME ": driver data not found for %s\n",\r\npci_name(dev));\r\nreturn XEN_PCI_ERR_op_failed;\r\n}\r\nif (value == ~PCI_ROM_ADDRESS_ENABLE)\r\nbar->which = 1;\r\nelse {\r\nu32 tmpval;\r\npci_read_config_dword(dev, offset, &tmpval);\r\nif (tmpval != bar->val && value == bar->val) {\r\npci_write_config_dword(dev, offset, bar->val);\r\n}\r\nbar->which = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bar_write(struct pci_dev *dev, int offset, u32 value, void *data)\r\n{\r\nstruct pci_bar_info *bar = data;\r\nif (unlikely(!bar)) {\r\npr_warn(DRV_NAME ": driver data not found for %s\n",\r\npci_name(dev));\r\nreturn XEN_PCI_ERR_op_failed;\r\n}\r\nif (value == ~0)\r\nbar->which = 1;\r\nelse {\r\nu32 tmpval;\r\npci_read_config_dword(dev, offset, &tmpval);\r\nif (tmpval != bar->val && value == bar->val) {\r\npci_write_config_dword(dev, offset, bar->val);\r\n}\r\nbar->which = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bar_read(struct pci_dev *dev, int offset, u32 * value, void *data)\r\n{\r\nstruct pci_bar_info *bar = data;\r\nif (unlikely(!bar)) {\r\npr_warn(DRV_NAME ": driver data not found for %s\n",\r\npci_name(dev));\r\nreturn XEN_PCI_ERR_op_failed;\r\n}\r\n*value = bar->which ? bar->len_val : bar->val;\r\nreturn 0;\r\n}\r\nstatic inline void read_dev_bar(struct pci_dev *dev,\r\nstruct pci_bar_info *bar_info, int offset,\r\nu32 len_mask)\r\n{\r\nint pos;\r\nstruct resource *res = dev->resource;\r\nif (offset == PCI_ROM_ADDRESS || offset == PCI_ROM_ADDRESS1)\r\npos = PCI_ROM_RESOURCE;\r\nelse {\r\npos = (offset - PCI_BASE_ADDRESS_0) / 4;\r\nif (pos && ((res[pos - 1].flags & (PCI_BASE_ADDRESS_SPACE |\r\nPCI_BASE_ADDRESS_MEM_TYPE_MASK)) ==\r\n(PCI_BASE_ADDRESS_SPACE_MEMORY |\r\nPCI_BASE_ADDRESS_MEM_TYPE_64))) {\r\nbar_info->val = res[pos - 1].start >> 32;\r\nbar_info->len_val = res[pos - 1].end >> 32;\r\nreturn;\r\n}\r\n}\r\nbar_info->val = res[pos].start |\r\n(res[pos].flags & PCI_REGION_FLAG_MASK);\r\nbar_info->len_val = resource_size(&res[pos]);\r\n}\r\nstatic void *bar_init(struct pci_dev *dev, int offset)\r\n{\r\nstruct pci_bar_info *bar = kmalloc(sizeof(*bar), GFP_KERNEL);\r\nif (!bar)\r\nreturn ERR_PTR(-ENOMEM);\r\nread_dev_bar(dev, bar, offset, ~0);\r\nbar->which = 0;\r\nreturn bar;\r\n}\r\nstatic void *rom_init(struct pci_dev *dev, int offset)\r\n{\r\nstruct pci_bar_info *bar = kmalloc(sizeof(*bar), GFP_KERNEL);\r\nif (!bar)\r\nreturn ERR_PTR(-ENOMEM);\r\nread_dev_bar(dev, bar, offset, ~PCI_ROM_ADDRESS_ENABLE);\r\nbar->which = 0;\r\nreturn bar;\r\n}\r\nstatic void bar_reset(struct pci_dev *dev, int offset, void *data)\r\n{\r\nstruct pci_bar_info *bar = data;\r\nbar->which = 0;\r\n}\r\nstatic void bar_release(struct pci_dev *dev, int offset, void *data)\r\n{\r\nkfree(data);\r\n}\r\nstatic int xen_pcibk_read_vendor(struct pci_dev *dev, int offset,\r\nu16 *value, void *data)\r\n{\r\n*value = dev->vendor;\r\nreturn 0;\r\n}\r\nstatic int xen_pcibk_read_device(struct pci_dev *dev, int offset,\r\nu16 *value, void *data)\r\n{\r\n*value = dev->device;\r\nreturn 0;\r\n}\r\nstatic int interrupt_read(struct pci_dev *dev, int offset, u8 * value,\r\nvoid *data)\r\n{\r\n*value = (u8) dev->irq;\r\nreturn 0;\r\n}\r\nstatic int bist_write(struct pci_dev *dev, int offset, u8 value, void *data)\r\n{\r\nu8 cur_value;\r\nint err;\r\nerr = pci_read_config_byte(dev, offset, &cur_value);\r\nif (err)\r\ngoto out;\r\nif ((cur_value & ~PCI_BIST_START) == (value & ~PCI_BIST_START)\r\n|| value == PCI_BIST_START)\r\nerr = pci_write_config_byte(dev, offset, value);\r\nout:\r\nreturn err;\r\n}\r\nint xen_pcibk_config_header_add_fields(struct pci_dev *dev)\r\n{\r\nint err;\r\nerr = xen_pcibk_config_add_fields(dev, header_common);\r\nif (err)\r\ngoto out;\r\nswitch (dev->hdr_type) {\r\ncase PCI_HEADER_TYPE_NORMAL:\r\nerr = xen_pcibk_config_add_fields(dev, header_0);\r\nbreak;\r\ncase PCI_HEADER_TYPE_BRIDGE:\r\nerr = xen_pcibk_config_add_fields(dev, header_1);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\npr_err("%s: Unsupported header type %d!\n",\r\npci_name(dev), dev->hdr_type);\r\nbreak;\r\n}\r\nout:\r\nreturn err;\r\n}
