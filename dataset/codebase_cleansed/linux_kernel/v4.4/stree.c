inline int B_IS_IN_TREE(const struct buffer_head *bh)\r\n{\r\nRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\r\n"PAP-1010: block (%b) has too big level (%z)", bh, bh);\r\nreturn (B_LEVEL(bh) != FREE_LEVEL);\r\n}\r\ninline void copy_item_head(struct item_head *to,\r\nconst struct item_head *from)\r\n{\r\nmemcpy(to, from, IH_SIZE);\r\n}\r\ninline int comp_short_keys(const struct reiserfs_key *le_key,\r\nconst struct cpu_key *cpu_key)\r\n{\r\n__u32 n;\r\nn = le32_to_cpu(le_key->k_dir_id);\r\nif (n < cpu_key->on_disk_key.k_dir_id)\r\nreturn -1;\r\nif (n > cpu_key->on_disk_key.k_dir_id)\r\nreturn 1;\r\nn = le32_to_cpu(le_key->k_objectid);\r\nif (n < cpu_key->on_disk_key.k_objectid)\r\nreturn -1;\r\nif (n > cpu_key->on_disk_key.k_objectid)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int comp_keys(const struct reiserfs_key *le_key,\r\nconst struct cpu_key *cpu_key)\r\n{\r\nint retval;\r\nretval = comp_short_keys(le_key, cpu_key);\r\nif (retval)\r\nreturn retval;\r\nif (le_key_k_offset(le_key_version(le_key), le_key) <\r\ncpu_key_k_offset(cpu_key))\r\nreturn -1;\r\nif (le_key_k_offset(le_key_version(le_key), le_key) >\r\ncpu_key_k_offset(cpu_key))\r\nreturn 1;\r\nif (cpu_key->key_length == 3)\r\nreturn 0;\r\nif (le_key_k_type(le_key_version(le_key), le_key) <\r\ncpu_key_k_type(cpu_key))\r\nreturn -1;\r\nif (le_key_k_type(le_key_version(le_key), le_key) >\r\ncpu_key_k_type(cpu_key))\r\nreturn 1;\r\nreturn 0;\r\n}\r\ninline int comp_short_le_keys(const struct reiserfs_key *key1,\r\nconst struct reiserfs_key *key2)\r\n{\r\n__u32 *k1_u32, *k2_u32;\r\nint key_length = REISERFS_SHORT_KEY_LEN;\r\nk1_u32 = (__u32 *) key1;\r\nk2_u32 = (__u32 *) key2;\r\nfor (; key_length--; ++k1_u32, ++k2_u32) {\r\nif (le32_to_cpu(*k1_u32) < le32_to_cpu(*k2_u32))\r\nreturn -1;\r\nif (le32_to_cpu(*k1_u32) > le32_to_cpu(*k2_u32))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\ninline void le_key2cpu_key(struct cpu_key *to, const struct reiserfs_key *from)\r\n{\r\nint version;\r\nto->on_disk_key.k_dir_id = le32_to_cpu(from->k_dir_id);\r\nto->on_disk_key.k_objectid = le32_to_cpu(from->k_objectid);\r\nversion = le_key_version(from);\r\nto->version = version;\r\nto->on_disk_key.k_offset = le_key_k_offset(version, from);\r\nto->on_disk_key.k_type = le_key_k_type(version, from);\r\n}\r\ninline int comp_le_keys(const struct reiserfs_key *k1,\r\nconst struct reiserfs_key *k2)\r\n{\r\nreturn memcmp(k1, k2, sizeof(struct reiserfs_key));\r\n}\r\nstatic inline int bin_search(const void *key,\r\nconst void *base,\r\nint num,\r\nint width,\r\nint *pos\r\n)\r\n{\r\nint rbound, lbound, j;\r\nfor (j = ((rbound = num - 1) + (lbound = 0)) / 2;\r\nlbound <= rbound; j = (rbound + lbound) / 2)\r\nswitch (comp_keys\r\n((struct reiserfs_key *)((char *)base + j * width),\r\n(struct cpu_key *)key)) {\r\ncase -1:\r\nlbound = j + 1;\r\ncontinue;\r\ncase 1:\r\nrbound = j - 1;\r\ncontinue;\r\ncase 0:\r\n*pos = j;\r\nreturn ITEM_FOUND;\r\n}\r\n*pos = lbound;\r\nreturn ITEM_NOT_FOUND;\r\n}\r\nstatic inline const struct reiserfs_key *get_lkey(const struct treepath *chk_path,\r\nconst struct super_block *sb)\r\n{\r\nint position, path_offset = chk_path->path_length;\r\nstruct buffer_head *parent;\r\nRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET,\r\n"PAP-5010: invalid offset in the path");\r\nwhile (path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {\r\nRFALSE(!buffer_uptodate\r\n(PATH_OFFSET_PBUFFER(chk_path, path_offset)),\r\n"PAP-5020: parent is not uptodate");\r\nif (!B_IS_IN_TREE\r\n(parent =\r\nPATH_OFFSET_PBUFFER(chk_path, path_offset)))\r\nreturn &MAX_KEY;\r\nif ((position =\r\nPATH_OFFSET_POSITION(chk_path,\r\npath_offset)) >\r\nB_NR_ITEMS(parent))\r\nreturn &MAX_KEY;\r\nif (B_N_CHILD_NUM(parent, position) !=\r\nPATH_OFFSET_PBUFFER(chk_path,\r\npath_offset + 1)->b_blocknr)\r\nreturn &MAX_KEY;\r\nif (position)\r\nreturn internal_key(parent, position - 1);\r\n}\r\nif (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->\r\nb_blocknr == SB_ROOT_BLOCK(sb))\r\nreturn &MIN_KEY;\r\nreturn &MAX_KEY;\r\n}\r\ninline const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\r\nconst struct super_block *sb)\r\n{\r\nint position, path_offset = chk_path->path_length;\r\nstruct buffer_head *parent;\r\nRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET,\r\n"PAP-5030: invalid offset in the path");\r\nwhile (path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {\r\nRFALSE(!buffer_uptodate\r\n(PATH_OFFSET_PBUFFER(chk_path, path_offset)),\r\n"PAP-5040: parent is not uptodate");\r\nif (!B_IS_IN_TREE\r\n(parent =\r\nPATH_OFFSET_PBUFFER(chk_path, path_offset)))\r\nreturn &MIN_KEY;\r\nif ((position =\r\nPATH_OFFSET_POSITION(chk_path,\r\npath_offset)) >\r\nB_NR_ITEMS(parent))\r\nreturn &MIN_KEY;\r\nif (B_N_CHILD_NUM(parent, position) !=\r\nPATH_OFFSET_PBUFFER(chk_path,\r\npath_offset + 1)->b_blocknr)\r\nreturn &MIN_KEY;\r\nif (position != B_NR_ITEMS(parent))\r\nreturn internal_key(parent, position);\r\n}\r\nif (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->\r\nb_blocknr == SB_ROOT_BLOCK(sb))\r\nreturn &MAX_KEY;\r\nreturn &MIN_KEY;\r\n}\r\nstatic inline int key_in_buffer(\r\nstruct treepath *chk_path,\r\nconst struct cpu_key *key,\r\nstruct super_block *sb\r\n)\r\n{\r\nRFALSE(!key || chk_path->path_length < FIRST_PATH_ELEMENT_OFFSET\r\n|| chk_path->path_length > MAX_HEIGHT,\r\n"PAP-5050: pointer to the key(%p) is NULL or invalid path length(%d)",\r\nkey, chk_path->path_length);\r\nRFALSE(!PATH_PLAST_BUFFER(chk_path)->b_bdev,\r\n"PAP-5060: device must not be NODEV");\r\nif (comp_keys(get_lkey(chk_path, sb), key) == 1)\r\nreturn 0;\r\nif (comp_keys(get_rkey(chk_path, sb), key) != 1)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint reiserfs_check_path(struct treepath *p)\r\n{\r\nRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\r\n"path not properly relsed");\r\nreturn 0;\r\n}\r\nvoid pathrelse_and_restore(struct super_block *sb,\r\nstruct treepath *search_path)\r\n{\r\nint path_offset = search_path->path_length;\r\nRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\r\n"clm-4000: invalid path offset");\r\nwhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET) {\r\nstruct buffer_head *bh;\r\nbh = PATH_OFFSET_PBUFFER(search_path, path_offset--);\r\nreiserfs_restore_prepared_buffer(sb, bh);\r\nbrelse(bh);\r\n}\r\nsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\r\n}\r\nvoid pathrelse(struct treepath *search_path)\r\n{\r\nint path_offset = search_path->path_length;\r\nRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\r\n"PAP-5090: invalid path offset");\r\nwhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\r\nbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\r\nsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\r\n}\r\nstatic int is_leaf(char *buf, int blocksize, struct buffer_head *bh)\r\n{\r\nstruct block_head *blkh;\r\nstruct item_head *ih;\r\nint used_space;\r\nint prev_location;\r\nint i;\r\nint nr;\r\nblkh = (struct block_head *)buf;\r\nif (blkh_level(blkh) != DISK_LEAF_NODE_LEVEL) {\r\nreiserfs_warning(NULL, "reiserfs-5080",\r\n"this should be caught earlier");\r\nreturn 0;\r\n}\r\nnr = blkh_nr_item(blkh);\r\nif (nr < 1 || nr > ((blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN))) {\r\nreiserfs_warning(NULL, "reiserfs-5081",\r\n"nr_item seems wrong: %z", bh);\r\nreturn 0;\r\n}\r\nih = (struct item_head *)(buf + BLKH_SIZE) + nr - 1;\r\nused_space = BLKH_SIZE + IH_SIZE * nr + (blocksize - ih_location(ih));\r\nif (used_space != blocksize - blkh_free_space(blkh)) {\r\nreiserfs_warning(NULL, "reiserfs-5082",\r\n"free space seems wrong: %z", bh);\r\nreturn 0;\r\n}\r\nih = (struct item_head *)(buf + BLKH_SIZE);\r\nprev_location = blocksize;\r\nfor (i = 0; i < nr; i++, ih++) {\r\nif (le_ih_k_type(ih) == TYPE_ANY) {\r\nreiserfs_warning(NULL, "reiserfs-5083",\r\n"wrong item type for item %h",\r\nih);\r\nreturn 0;\r\n}\r\nif (ih_location(ih) >= blocksize\r\n|| ih_location(ih) < IH_SIZE * nr) {\r\nreiserfs_warning(NULL, "reiserfs-5084",\r\n"item location seems wrong: %h",\r\nih);\r\nreturn 0;\r\n}\r\nif (ih_item_len(ih) < 1\r\n|| ih_item_len(ih) > MAX_ITEM_LEN(blocksize)) {\r\nreiserfs_warning(NULL, "reiserfs-5085",\r\n"item length seems wrong: %h",\r\nih);\r\nreturn 0;\r\n}\r\nif (prev_location - ih_location(ih) != ih_item_len(ih)) {\r\nreiserfs_warning(NULL, "reiserfs-5086",\r\n"item location seems wrong "\r\n"(second one): %h", ih);\r\nreturn 0;\r\n}\r\nprev_location = ih_location(ih);\r\n}\r\nreturn 1;\r\n}\r\nstatic int is_internal(char *buf, int blocksize, struct buffer_head *bh)\r\n{\r\nstruct block_head *blkh;\r\nint nr;\r\nint used_space;\r\nblkh = (struct block_head *)buf;\r\nnr = blkh_level(blkh);\r\nif (nr <= DISK_LEAF_NODE_LEVEL || nr > MAX_HEIGHT) {\r\nreiserfs_warning(NULL, "reiserfs-5087",\r\n"this should be caught earlier");\r\nreturn 0;\r\n}\r\nnr = blkh_nr_item(blkh);\r\nif (nr > (blocksize - BLKH_SIZE - DC_SIZE) / (KEY_SIZE + DC_SIZE)) {\r\nreiserfs_warning(NULL, "reiserfs-5088",\r\n"number of key seems wrong: %z", bh);\r\nreturn 0;\r\n}\r\nused_space = BLKH_SIZE + KEY_SIZE * nr + DC_SIZE * (nr + 1);\r\nif (used_space != blocksize - blkh_free_space(blkh)) {\r\nreiserfs_warning(NULL, "reiserfs-5089",\r\n"free space seems wrong: %z", bh);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int is_tree_node(struct buffer_head *bh, int level)\r\n{\r\nif (B_LEVEL(bh) != level) {\r\nreiserfs_warning(NULL, "reiserfs-5090", "node level %d does "\r\n"not match to the expected one %d",\r\nB_LEVEL(bh), level);\r\nreturn 0;\r\n}\r\nif (level == DISK_LEAF_NODE_LEVEL)\r\nreturn is_leaf(bh->b_data, bh->b_size, bh);\r\nreturn is_internal(bh->b_data, bh->b_size, bh);\r\n}\r\nstatic int search_by_key_reada(struct super_block *s,\r\nstruct buffer_head **bh,\r\nb_blocknr_t *b, int num)\r\n{\r\nint i, j;\r\nint depth = -1;\r\nfor (i = 0; i < num; i++) {\r\nbh[i] = sb_getblk(s, b[i]);\r\n}\r\nfor (j = 0; j < i; j++) {\r\nif (!buffer_uptodate(bh[j])) {\r\nif (depth == -1)\r\ndepth = reiserfs_write_unlock_nested(s);\r\nll_rw_block(READA, 1, bh + j);\r\n}\r\nbrelse(bh[j]);\r\n}\r\nreturn depth;\r\n}\r\nint search_by_key(struct super_block *sb, const struct cpu_key *key,\r\nstruct treepath *search_path, int stop_level)\r\n{\r\nb_blocknr_t block_number;\r\nint expected_level;\r\nstruct buffer_head *bh;\r\nstruct path_element *last_element;\r\nint node_level, retval;\r\nint right_neighbor_of_leaf_node;\r\nint fs_gen;\r\nstruct buffer_head *reada_bh[SEARCH_BY_KEY_READA];\r\nb_blocknr_t reada_blocks[SEARCH_BY_KEY_READA];\r\nint reada_count = 0;\r\n#ifdef CONFIG_REISERFS_CHECK\r\nint repeat_counter = 0;\r\n#endif\r\nPROC_INFO_INC(sb, search_by_key);\r\npathrelse(search_path);\r\nright_neighbor_of_leaf_node = 0;\r\nblock_number = SB_ROOT_BLOCK(sb);\r\nexpected_level = -1;\r\nwhile (1) {\r\n#ifdef CONFIG_REISERFS_CHECK\r\nif (!(++repeat_counter % 50000))\r\nreiserfs_warning(sb, "PAP-5100",\r\n"%s: there were %d iterations of "\r\n"while loop looking for key %K",\r\ncurrent->comm, repeat_counter,\r\nkey);\r\n#endif\r\nlast_element =\r\nPATH_OFFSET_PELEMENT(search_path,\r\n++search_path->path_length);\r\nfs_gen = get_generation(sb);\r\nif ((bh = last_element->pe_buffer =\r\nsb_getblk(sb, block_number))) {\r\nint depth = -1;\r\nif (!buffer_uptodate(bh) && reada_count > 1)\r\ndepth = search_by_key_reada(sb, reada_bh,\r\nreada_blocks, reada_count);\r\nif (!buffer_uptodate(bh) && depth == -1)\r\ndepth = reiserfs_write_unlock_nested(sb);\r\nll_rw_block(READ, 1, &bh);\r\nwait_on_buffer(bh);\r\nif (depth != -1)\r\nreiserfs_write_lock_nested(sb, depth);\r\nif (!buffer_uptodate(bh))\r\ngoto io_error;\r\n} else {\r\nio_error:\r\nsearch_path->path_length--;\r\npathrelse(search_path);\r\nreturn IO_ERROR;\r\n}\r\nreada_count = 0;\r\nif (expected_level == -1)\r\nexpected_level = SB_TREE_HEIGHT(sb);\r\nexpected_level--;\r\nif (fs_changed(fs_gen, sb) &&\r\n(!B_IS_IN_TREE(bh) ||\r\nB_LEVEL(bh) != expected_level ||\r\n!key_in_buffer(search_path, key, sb))) {\r\nPROC_INFO_INC(sb, search_by_key_fs_changed);\r\nPROC_INFO_INC(sb, search_by_key_restarted);\r\nPROC_INFO_INC(sb,\r\nsbk_restarted[expected_level - 1]);\r\npathrelse(search_path);\r\nblock_number = SB_ROOT_BLOCK(sb);\r\nexpected_level = -1;\r\nright_neighbor_of_leaf_node = 0;\r\ncontinue;\r\n}\r\nRFALSE(comp_keys(&MAX_KEY, key) &&\r\n!key_in_buffer(search_path, key, sb),\r\n"PAP-5130: key is not in the buffer");\r\n#ifdef CONFIG_REISERFS_CHECK\r\nif (REISERFS_SB(sb)->cur_tb) {\r\nprint_cur_tb("5140");\r\nreiserfs_panic(sb, "PAP-5140",\r\n"schedule occurred in do_balance!");\r\n}\r\n#endif\r\nif (!is_tree_node(bh, expected_level)) {\r\nreiserfs_error(sb, "vs-5150",\r\n"invalid format found in block %ld. "\r\n"Fsck?", bh->b_blocknr);\r\npathrelse(search_path);\r\nreturn IO_ERROR;\r\n}\r\nnode_level = B_LEVEL(bh);\r\nPROC_INFO_BH_STAT(sb, bh, node_level - 1);\r\nRFALSE(node_level < stop_level,\r\n"vs-5152: tree level (%d) is less than stop level (%d)",\r\nnode_level, stop_level);\r\nretval = bin_search(key, item_head(bh, 0),\r\nB_NR_ITEMS(bh),\r\n(node_level ==\r\nDISK_LEAF_NODE_LEVEL) ? IH_SIZE :\r\nKEY_SIZE,\r\n&last_element->pe_position);\r\nif (node_level == stop_level) {\r\nreturn retval;\r\n}\r\nif (retval == ITEM_FOUND)\r\nlast_element->pe_position++;\r\nblock_number =\r\nB_N_CHILD_NUM(bh, last_element->pe_position);\r\nif ((search_path->reada & PATH_READA) &&\r\nnode_level == DISK_LEAF_NODE_LEVEL + 1) {\r\nint pos = last_element->pe_position;\r\nint limit = B_NR_ITEMS(bh);\r\nstruct reiserfs_key *le_key;\r\nif (search_path->reada & PATH_READA_BACK)\r\nlimit = 0;\r\nwhile (reada_count < SEARCH_BY_KEY_READA) {\r\nif (pos == limit)\r\nbreak;\r\nreada_blocks[reada_count++] =\r\nB_N_CHILD_NUM(bh, pos);\r\nif (search_path->reada & PATH_READA_BACK)\r\npos--;\r\nelse\r\npos++;\r\nle_key = internal_key(bh, pos);\r\nif (le32_to_cpu(le_key->k_objectid) !=\r\nkey->on_disk_key.k_objectid) {\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nint search_for_position_by_key(struct super_block *sb,\r\nconst struct cpu_key *p_cpu_key,\r\nstruct treepath *search_path)\r\n{\r\nstruct item_head *p_le_ih;\r\nint blk_size;\r\nloff_t item_offset, offset;\r\nstruct reiserfs_dir_entry de;\r\nint retval;\r\nif (is_direntry_cpu_key(p_cpu_key))\r\nreturn search_by_entry_key(sb, p_cpu_key, search_path,\r\n&de);\r\nretval = search_item(sb, p_cpu_key, search_path);\r\nif (retval == IO_ERROR)\r\nreturn retval;\r\nif (retval == ITEM_FOUND) {\r\nRFALSE(!ih_item_len\r\n(item_head\r\n(PATH_PLAST_BUFFER(search_path),\r\nPATH_LAST_POSITION(search_path))),\r\n"PAP-5165: item length equals zero");\r\npos_in_item(search_path) = 0;\r\nreturn POSITION_FOUND;\r\n}\r\nRFALSE(!PATH_LAST_POSITION(search_path),\r\n"PAP-5170: position equals zero");\r\np_le_ih =\r\nitem_head(PATH_PLAST_BUFFER(search_path),\r\n--PATH_LAST_POSITION(search_path));\r\nblk_size = sb->s_blocksize;\r\nif (comp_short_keys(&p_le_ih->ih_key, p_cpu_key))\r\nreturn FILE_NOT_FOUND;\r\nitem_offset = le_ih_k_offset(p_le_ih);\r\noffset = cpu_key_k_offset(p_cpu_key);\r\nif (item_offset <= offset &&\r\nitem_offset + op_bytes_number(p_le_ih, blk_size) > offset) {\r\npos_in_item(search_path) = offset - item_offset;\r\nif (is_indirect_le_ih(p_le_ih)) {\r\npos_in_item(search_path) /= blk_size;\r\n}\r\nreturn POSITION_FOUND;\r\n}\r\nif (is_indirect_le_ih(p_le_ih))\r\npos_in_item(search_path) =\r\nih_item_len(p_le_ih) / UNFM_P_SIZE;\r\nelse\r\npos_in_item(search_path) = ih_item_len(p_le_ih);\r\nreturn POSITION_NOT_FOUND;\r\n}\r\nint comp_items(const struct item_head *stored_ih, const struct treepath *path)\r\n{\r\nstruct buffer_head *bh = PATH_PLAST_BUFFER(path);\r\nstruct item_head *ih;\r\nif (!B_IS_IN_TREE(bh))\r\nreturn 1;\r\nif (PATH_LAST_POSITION(path) >= B_NR_ITEMS(bh))\r\nreturn 1;\r\nih = tp_item_head(path);\r\nreturn memcmp(stored_ih, ih, IH_SIZE);\r\n}\r\nstatic inline int prepare_for_direct_item(struct treepath *path,\r\nstruct item_head *le_ih,\r\nstruct inode *inode,\r\nloff_t new_file_length, int *cut_size)\r\n{\r\nloff_t round_len;\r\nif (new_file_length == max_reiserfs_offset(inode)) {\r\n*cut_size = -(IH_SIZE + ih_item_len(le_ih));\r\nreturn M_DELETE;\r\n}\r\nif (get_inode_item_key_version(inode) == KEY_FORMAT_3_6) {\r\nround_len = ROUND_UP(new_file_length);\r\nif (round_len < le_ih_k_offset(le_ih)) {\r\n*cut_size = -(IH_SIZE + ih_item_len(le_ih));\r\nreturn M_DELETE;\r\n}\r\npos_in_item(path) = round_len - (le_ih_k_offset(le_ih) - 1);\r\n*cut_size = -(ih_item_len(le_ih) - pos_in_item(path));\r\nreturn M_CUT;\r\n}\r\nif (new_file_length < le_ih_k_offset(le_ih)) {\r\n*cut_size = -(IH_SIZE + ih_item_len(le_ih));\r\nreturn M_DELETE;\r\n}\r\n*cut_size = -(ih_item_len(le_ih) -\r\n(pos_in_item(path) =\r\nnew_file_length + 1 - le_ih_k_offset(le_ih)));\r\nreturn M_CUT;\r\n}\r\nstatic inline int prepare_for_direntry_item(struct treepath *path,\r\nstruct item_head *le_ih,\r\nstruct inode *inode,\r\nloff_t new_file_length,\r\nint *cut_size)\r\n{\r\nif (le_ih_k_offset(le_ih) == DOT_OFFSET &&\r\nnew_file_length == max_reiserfs_offset(inode)) {\r\nRFALSE(ih_entry_count(le_ih) != 2,\r\n"PAP-5220: incorrect empty directory item (%h)", le_ih);\r\n*cut_size = -(IH_SIZE + ih_item_len(le_ih));\r\nreturn M_DELETE;\r\n}\r\nif (ih_entry_count(le_ih) == 1) {\r\n*cut_size = -(IH_SIZE + ih_item_len(le_ih));\r\nreturn M_DELETE;\r\n}\r\n*cut_size =\r\n-(DEH_SIZE +\r\nentry_length(get_last_bh(path), le_ih, pos_in_item(path)));\r\nreturn M_CUT;\r\n}\r\nstatic char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th,\r\nstruct inode *inode,\r\nstruct treepath *path,\r\nconst struct cpu_key *item_key,\r\nint *removed,\r\nint *cut_size,\r\nunsigned long long new_file_length\r\n)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct item_head *p_le_ih = tp_item_head(path);\r\nstruct buffer_head *bh = PATH_PLAST_BUFFER(path);\r\nBUG_ON(!th->t_trans_id);\r\nif (is_statdata_le_ih(p_le_ih)) {\r\nRFALSE(new_file_length != max_reiserfs_offset(inode),\r\n"PAP-5210: mode must be M_DELETE");\r\n*cut_size = -(IH_SIZE + ih_item_len(p_le_ih));\r\nreturn M_DELETE;\r\n}\r\nif (is_direntry_le_ih(p_le_ih))\r\nreturn prepare_for_direntry_item(path, p_le_ih, inode,\r\nnew_file_length,\r\ncut_size);\r\nif (is_direct_le_ih(p_le_ih))\r\nreturn prepare_for_direct_item(path, p_le_ih, inode,\r\nnew_file_length, cut_size);\r\n{\r\nint blk_size = sb->s_blocksize;\r\nstruct item_head s_ih;\r\nint need_re_search;\r\nint delete = 0;\r\nint result = M_CUT;\r\nint pos = 0;\r\nif ( new_file_length == max_reiserfs_offset (inode) ) {\r\nnew_file_length = 0;\r\ndelete = 1;\r\n}\r\ndo {\r\nneed_re_search = 0;\r\n*cut_size = 0;\r\nbh = PATH_PLAST_BUFFER(path);\r\ncopy_item_head(&s_ih, tp_item_head(path));\r\npos = I_UNFM_NUM(&s_ih);\r\nwhile (le_ih_k_offset (&s_ih) + (pos - 1) * blk_size > new_file_length) {\r\n__le32 *unfm;\r\n__u32 block;\r\nif (!delete && (*cut_size) != 0 &&\r\nreiserfs_transaction_free_space(th) < JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD)\r\nbreak;\r\nunfm = (__le32 *)ih_item_body(bh, &s_ih) + pos - 1;\r\nblock = get_block_num(unfm, 0);\r\nif (block != 0) {\r\nreiserfs_prepare_for_journal(sb, bh, 1);\r\nput_block_num(unfm, 0, 0);\r\njournal_mark_dirty(th, bh);\r\nreiserfs_free_block(th, inode, block, 1);\r\n}\r\nreiserfs_cond_resched(sb);\r\nif (item_moved (&s_ih, path)) {\r\nneed_re_search = 1;\r\nbreak;\r\n}\r\npos --;\r\n(*removed)++;\r\n(*cut_size) -= UNFM_P_SIZE;\r\nif (pos == 0) {\r\n(*cut_size) -= IH_SIZE;\r\nresult = M_DELETE;\r\nbreak;\r\n}\r\n}\r\nreiserfs_restore_prepared_buffer(sb, bh);\r\n} while (need_re_search &&\r\nsearch_for_position_by_key(sb, item_key, path) == POSITION_FOUND);\r\npos_in_item(path) = pos * UNFM_P_SIZE;\r\nif (*cut_size == 0) {\r\nresult = M_CONVERT;\r\n}\r\nreturn result;\r\n}\r\n}\r\nstatic int calc_deleted_bytes_number(struct tree_balance *tb, char mode)\r\n{\r\nint del_size;\r\nstruct item_head *p_le_ih = tp_item_head(tb->tb_path);\r\nif (is_statdata_le_ih(p_le_ih))\r\nreturn 0;\r\ndel_size =\r\n(mode ==\r\nM_DELETE) ? ih_item_len(p_le_ih) : -tb->insert_size[0];\r\nif (is_direntry_le_ih(p_le_ih)) {\r\nreturn del_size;\r\n}\r\nif (is_indirect_le_ih(p_le_ih))\r\ndel_size = (del_size / UNFM_P_SIZE) *\r\n(PATH_PLAST_BUFFER(tb->tb_path)->b_size);\r\nreturn del_size;\r\n}\r\nstatic void init_tb_struct(struct reiserfs_transaction_handle *th,\r\nstruct tree_balance *tb,\r\nstruct super_block *sb,\r\nstruct treepath *path, int size)\r\n{\r\nBUG_ON(!th->t_trans_id);\r\nmemset(tb, '\0', sizeof(struct tree_balance));\r\ntb->transaction_handle = th;\r\ntb->tb_sb = sb;\r\ntb->tb_path = path;\r\nPATH_OFFSET_PBUFFER(path, ILLEGAL_PATH_ELEMENT_OFFSET) = NULL;\r\nPATH_OFFSET_POSITION(path, ILLEGAL_PATH_ELEMENT_OFFSET) = 0;\r\ntb->insert_size[0] = size;\r\n}\r\nvoid padd_item(char *item, int total_length, int length)\r\n{\r\nint i;\r\nfor (i = total_length; i > length;)\r\nitem[--i] = 0;\r\n}\r\nchar key2type(struct reiserfs_key *ih)\r\n{\r\nif (is_direntry_le_key(2, ih))\r\nreturn 'd';\r\nif (is_direct_le_key(2, ih))\r\nreturn 'D';\r\nif (is_indirect_le_key(2, ih))\r\nreturn 'i';\r\nif (is_statdata_le_key(2, ih))\r\nreturn 's';\r\nreturn 'u';\r\n}\r\nchar head2type(struct item_head *ih)\r\n{\r\nif (is_direntry_le_ih(ih))\r\nreturn 'd';\r\nif (is_direct_le_ih(ih))\r\nreturn 'D';\r\nif (is_indirect_le_ih(ih))\r\nreturn 'i';\r\nif (is_statdata_le_ih(ih))\r\nreturn 's';\r\nreturn 'u';\r\n}\r\nint reiserfs_delete_item(struct reiserfs_transaction_handle *th,\r\nstruct treepath *path, const struct cpu_key *item_key,\r\nstruct inode *inode, struct buffer_head *un_bh)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct tree_balance s_del_balance;\r\nstruct item_head s_ih;\r\nstruct item_head *q_ih;\r\nint quota_cut_bytes;\r\nint ret_value, del_size, removed;\r\nint depth;\r\n#ifdef CONFIG_REISERFS_CHECK\r\nchar mode;\r\nint iter = 0;\r\n#endif\r\nBUG_ON(!th->t_trans_id);\r\ninit_tb_struct(th, &s_del_balance, sb, path,\r\n0 );\r\nwhile (1) {\r\nremoved = 0;\r\n#ifdef CONFIG_REISERFS_CHECK\r\niter++;\r\nmode =\r\n#endif\r\nprepare_for_delete_or_cut(th, inode, path,\r\nitem_key, &removed,\r\n&del_size,\r\nmax_reiserfs_offset(inode));\r\nRFALSE(mode != M_DELETE, "PAP-5320: mode must be M_DELETE");\r\ncopy_item_head(&s_ih, tp_item_head(path));\r\ns_del_balance.insert_size[0] = del_size;\r\nret_value = fix_nodes(M_DELETE, &s_del_balance, NULL, NULL);\r\nif (ret_value != REPEAT_SEARCH)\r\nbreak;\r\nPROC_INFO_INC(sb, delete_item_restarted);\r\nret_value =\r\nsearch_for_position_by_key(sb, item_key, path);\r\nif (ret_value == IO_ERROR)\r\nbreak;\r\nif (ret_value == FILE_NOT_FOUND) {\r\nreiserfs_warning(sb, "vs-5340",\r\n"no items of the file %K found",\r\nitem_key);\r\nbreak;\r\n}\r\n}\r\nif (ret_value != CARRY_ON) {\r\nunfix_nodes(&s_del_balance);\r\nreturn 0;\r\n}\r\nret_value = calc_deleted_bytes_number(&s_del_balance, M_DELETE);\r\nq_ih = tp_item_head(path);\r\nquota_cut_bytes = ih_item_len(q_ih);\r\nif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(q_ih)) {\r\nif ((le_ih_k_offset(q_ih) & (sb->s_blocksize - 1)) == 1) {\r\nquota_cut_bytes = sb->s_blocksize + UNFM_P_SIZE;\r\n} else {\r\nquota_cut_bytes = 0;\r\n}\r\n}\r\nif (un_bh) {\r\nint off;\r\nchar *data;\r\ndata = kmap_atomic(un_bh->b_page);\r\noff = ((le_ih_k_offset(&s_ih) - 1) & (PAGE_CACHE_SIZE - 1));\r\nmemcpy(data + off,\r\nih_item_body(PATH_PLAST_BUFFER(path), &s_ih),\r\nret_value);\r\nkunmap_atomic(data);\r\n}\r\ndo_balance(&s_del_balance, NULL, NULL, M_DELETE);\r\n#ifdef REISERQUOTA_DEBUG\r\nreiserfs_debug(sb, REISERFS_DEBUG_CODE,\r\n"reiserquota delete_item(): freeing %u, id=%u type=%c",\r\nquota_cut_bytes, inode->i_uid, head2type(&s_ih));\r\n#endif\r\ndepth = reiserfs_write_unlock_nested(inode->i_sb);\r\ndquot_free_space_nodirty(inode, quota_cut_bytes);\r\nreiserfs_write_lock_nested(inode->i_sb, depth);\r\nreturn ret_value;\r\n}\r\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\r\nstruct inode *inode, struct reiserfs_key *key)\r\n{\r\nstruct super_block *sb = th->t_super;\r\nstruct tree_balance tb;\r\nINITIALIZE_PATH(path);\r\nint item_len = 0;\r\nint tb_init = 0;\r\nstruct cpu_key cpu_key;\r\nint retval;\r\nint quota_cut_bytes = 0;\r\nBUG_ON(!th->t_trans_id);\r\nle_key2cpu_key(&cpu_key, key);\r\nwhile (1) {\r\nretval = search_item(th->t_super, &cpu_key, &path);\r\nif (retval == IO_ERROR) {\r\nreiserfs_error(th->t_super, "vs-5350",\r\n"i/o failure occurred trying "\r\n"to delete %K", &cpu_key);\r\nbreak;\r\n}\r\nif (retval != ITEM_FOUND) {\r\npathrelse(&path);\r\nif (!\r\n((unsigned long long)\r\nGET_HASH_VALUE(le_key_k_offset\r\n(le_key_version(key), key)) == 0\r\n&& (unsigned long long)\r\nGET_GENERATION_NUMBER(le_key_k_offset\r\n(le_key_version(key),\r\nkey)) == 1))\r\nreiserfs_warning(th->t_super, "vs-5355",\r\n"%k not found", key);\r\nbreak;\r\n}\r\nif (!tb_init) {\r\ntb_init = 1;\r\nitem_len = ih_item_len(tp_item_head(&path));\r\ninit_tb_struct(th, &tb, th->t_super, &path,\r\n-(IH_SIZE + item_len));\r\n}\r\nquota_cut_bytes = ih_item_len(tp_item_head(&path));\r\nretval = fix_nodes(M_DELETE, &tb, NULL, NULL);\r\nif (retval == REPEAT_SEARCH) {\r\nPROC_INFO_INC(th->t_super, delete_solid_item_restarted);\r\ncontinue;\r\n}\r\nif (retval == CARRY_ON) {\r\ndo_balance(&tb, NULL, NULL, M_DELETE);\r\nif (inode) {\r\nint depth;\r\n#ifdef REISERQUOTA_DEBUG\r\nreiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,\r\n"reiserquota delete_solid_item(): freeing %u id=%u type=%c",\r\nquota_cut_bytes, inode->i_uid,\r\nkey2type(key));\r\n#endif\r\ndepth = reiserfs_write_unlock_nested(sb);\r\ndquot_free_space_nodirty(inode,\r\nquota_cut_bytes);\r\nreiserfs_write_lock_nested(sb, depth);\r\n}\r\nbreak;\r\n}\r\nreiserfs_warning(th->t_super, "vs-5360",\r\n"could not delete %K due to fix_nodes failure",\r\n&cpu_key);\r\nunfix_nodes(&tb);\r\nbreak;\r\n}\r\nreiserfs_check_path(&path);\r\n}\r\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\r\nstruct inode *inode)\r\n{\r\nint err;\r\ninode->i_size = 0;\r\nBUG_ON(!th->t_trans_id);\r\nerr =\r\nreiserfs_do_truncate(th, inode, NULL, 0 );\r\nif (err)\r\nreturn err;\r\n#if defined( USE_INODE_GENERATION_COUNTER )\r\nif (!old_format_only(th->t_super)) {\r\n__le32 *inode_generation;\r\ninode_generation =\r\n&REISERFS_SB(th->t_super)->s_rs->s_inode_generation;\r\nle32_add_cpu(inode_generation, 1);\r\n}\r\n#endif\r\nreiserfs_delete_solid_item(th, inode, INODE_PKEY(inode));\r\nreturn err;\r\n}\r\nstatic void unmap_buffers(struct page *page, loff_t pos)\r\n{\r\nstruct buffer_head *bh;\r\nstruct buffer_head *head;\r\nstruct buffer_head *next;\r\nunsigned long tail_index;\r\nunsigned long cur_index;\r\nif (page) {\r\nif (page_has_buffers(page)) {\r\ntail_index = pos & (PAGE_CACHE_SIZE - 1);\r\ncur_index = 0;\r\nhead = page_buffers(page);\r\nbh = head;\r\ndo {\r\nnext = bh->b_this_page;\r\ncur_index += bh->b_size;\r\nif (cur_index > tail_index) {\r\nreiserfs_unmap_buffer(bh);\r\n}\r\nbh = next;\r\n} while (bh != head);\r\n}\r\n}\r\n}\r\nstatic int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,\r\nstruct inode *inode,\r\nstruct page *page,\r\nstruct treepath *path,\r\nconst struct cpu_key *item_key,\r\nloff_t new_file_size, char *mode)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nint block_size = sb->s_blocksize;\r\nint cut_bytes;\r\nBUG_ON(!th->t_trans_id);\r\nBUG_ON(new_file_size != inode->i_size);\r\nif (atomic_read(&inode->i_count) > 1 ||\r\n!tail_has_to_be_packed(inode) ||\r\n!page || (REISERFS_I(inode)->i_flags & i_nopack_mask)) {\r\n*mode = M_SKIP_BALANCING;\r\ncut_bytes =\r\nblock_size - (new_file_size & (block_size - 1));\r\npathrelse(path);\r\nreturn cut_bytes;\r\n}\r\nreturn indirect2direct(th, inode, page, path, item_key,\r\nnew_file_size, mode);\r\n}\r\nstatic void indirect_to_direct_roll_back(struct reiserfs_transaction_handle *th,\r\nstruct inode *inode, struct treepath *path)\r\n{\r\nstruct cpu_key tail_key;\r\nint tail_len;\r\nint removed;\r\nBUG_ON(!th->t_trans_id);\r\nmake_cpu_key(&tail_key, inode, inode->i_size + 1, TYPE_DIRECT, 4);\r\ntail_key.key_length = 4;\r\ntail_len =\r\n(cpu_key_k_offset(&tail_key) & (inode->i_sb->s_blocksize - 1)) - 1;\r\nwhile (tail_len) {\r\nif (search_for_position_by_key(inode->i_sb, &tail_key, path) ==\r\nPOSITION_NOT_FOUND)\r\nreiserfs_panic(inode->i_sb, "vs-5615",\r\n"found invalid item");\r\nRFALSE(path->pos_in_item !=\r\nih_item_len(tp_item_head(path)) - 1,\r\n"vs-5616: appended bytes found");\r\nPATH_LAST_POSITION(path)--;\r\nremoved =\r\nreiserfs_delete_item(th, path, &tail_key, inode,\r\nNULL );\r\nRFALSE(removed <= 0\r\n|| removed > tail_len,\r\n"vs-5617: there was tail %d bytes, removed item length %d bytes",\r\ntail_len, removed);\r\ntail_len -= removed;\r\nset_cpu_key_k_offset(&tail_key,\r\ncpu_key_k_offset(&tail_key) - removed);\r\n}\r\nreiserfs_warning(inode->i_sb, "reiserfs-5091", "indirect_to_direct "\r\n"conversion has been rolled back due to "\r\n"lack of disk space");\r\nmark_inode_dirty(inode);\r\n}\r\nint reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,\r\nstruct treepath *path,\r\nstruct cpu_key *item_key,\r\nstruct inode *inode,\r\nstruct page *page, loff_t new_file_size)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct tree_balance s_cut_balance;\r\nstruct item_head *p_le_ih;\r\nint cut_size = 0;\r\nint ret_value = CARRY_ON;\r\nint removed = 0;\r\nint is_inode_locked = 0;\r\nchar mode;\r\nint retval2 = -1;\r\nint quota_cut_bytes;\r\nloff_t tail_pos = 0;\r\nint depth;\r\nBUG_ON(!th->t_trans_id);\r\ninit_tb_struct(th, &s_cut_balance, inode->i_sb, path,\r\ncut_size);\r\nwhile (1) {\r\nmode =\r\nprepare_for_delete_or_cut(th, inode, path,\r\nitem_key, &removed,\r\n&cut_size, new_file_size);\r\nif (mode == M_CONVERT) {\r\nRFALSE(ret_value != CARRY_ON,\r\n"PAP-5570: can not convert twice");\r\nret_value =\r\nmaybe_indirect_to_direct(th, inode, page,\r\npath, item_key,\r\nnew_file_size, &mode);\r\nif (mode == M_SKIP_BALANCING)\r\nreturn ret_value;\r\nis_inode_locked = 1;\r\nretval2 = ret_value;\r\nset_cpu_key_k_type(item_key, TYPE_INDIRECT);\r\nitem_key->key_length = 4;\r\nnew_file_size -=\r\n(new_file_size & (sb->s_blocksize - 1));\r\ntail_pos = new_file_size;\r\nset_cpu_key_k_offset(item_key, new_file_size + 1);\r\nif (search_for_position_by_key\r\n(sb, item_key,\r\npath) == POSITION_NOT_FOUND) {\r\nprint_block(PATH_PLAST_BUFFER(path), 3,\r\nPATH_LAST_POSITION(path) - 1,\r\nPATH_LAST_POSITION(path) + 1);\r\nreiserfs_panic(sb, "PAP-5580", "item to "\r\n"convert does not exist (%K)",\r\nitem_key);\r\n}\r\ncontinue;\r\n}\r\nif (cut_size == 0) {\r\npathrelse(path);\r\nreturn 0;\r\n}\r\ns_cut_balance.insert_size[0] = cut_size;\r\nret_value = fix_nodes(mode, &s_cut_balance, NULL, NULL);\r\nif (ret_value != REPEAT_SEARCH)\r\nbreak;\r\nPROC_INFO_INC(sb, cut_from_item_restarted);\r\nret_value =\r\nsearch_for_position_by_key(sb, item_key, path);\r\nif (ret_value == POSITION_FOUND)\r\ncontinue;\r\nreiserfs_warning(sb, "PAP-5610", "item %K not found",\r\nitem_key);\r\nunfix_nodes(&s_cut_balance);\r\nreturn (ret_value == IO_ERROR) ? -EIO : -ENOENT;\r\n}\r\nif (ret_value != CARRY_ON) {\r\nif (is_inode_locked) {\r\nindirect_to_direct_roll_back(th, inode, path);\r\n}\r\nif (ret_value == NO_DISK_SPACE)\r\nreiserfs_warning(sb, "reiserfs-5092",\r\n"NO_DISK_SPACE");\r\nunfix_nodes(&s_cut_balance);\r\nreturn -EIO;\r\n}\r\nRFALSE(mode == M_PASTE || mode == M_INSERT, "invalid mode");\r\nquota_cut_bytes =\r\n(mode ==\r\nM_DELETE) ? ih_item_len(tp_item_head(path)) : -s_cut_balance.\r\ninsert_size[0];\r\nif (retval2 == -1)\r\nret_value = calc_deleted_bytes_number(&s_cut_balance, mode);\r\nelse\r\nret_value = retval2;\r\np_le_ih = tp_item_head(s_cut_balance.tb_path);\r\nif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(p_le_ih)) {\r\nif (mode == M_DELETE &&\r\n(le_ih_k_offset(p_le_ih) & (sb->s_blocksize - 1)) ==\r\n1) {\r\nREISERFS_I(inode)->i_first_direct_byte = U32_MAX;\r\nquota_cut_bytes = sb->s_blocksize + UNFM_P_SIZE;\r\n} else {\r\nquota_cut_bytes = 0;\r\n}\r\n}\r\n#ifdef CONFIG_REISERFS_CHECK\r\nif (is_inode_locked) {\r\nstruct item_head *le_ih =\r\ntp_item_head(s_cut_balance.tb_path);\r\nif (!is_indirect_le_ih(le_ih))\r\nreiserfs_panic(sb, "vs-5652",\r\n"item must be indirect %h", le_ih);\r\nif (mode == M_DELETE && ih_item_len(le_ih) != UNFM_P_SIZE)\r\nreiserfs_panic(sb, "vs-5653", "completing "\r\n"indirect2direct conversion indirect "\r\n"item %h being deleted must be of "\r\n"4 byte long", le_ih);\r\nif (mode == M_CUT\r\n&& s_cut_balance.insert_size[0] != -UNFM_P_SIZE) {\r\nreiserfs_panic(sb, "vs-5654", "can not complete "\r\n"indirect2direct conversion of %h "\r\n"(CUT, insert_size==%d)",\r\nle_ih, s_cut_balance.insert_size[0]);\r\n}\r\n}\r\n#endif\r\ndo_balance(&s_cut_balance, NULL, NULL, mode);\r\nif (is_inode_locked) {\r\nunmap_buffers(page, tail_pos);\r\nREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\r\n}\r\n#ifdef REISERQUOTA_DEBUG\r\nreiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\r\n"reiserquota cut_from_item(): freeing %u id=%u type=%c",\r\nquota_cut_bytes, inode->i_uid, '?');\r\n#endif\r\ndepth = reiserfs_write_unlock_nested(sb);\r\ndquot_free_space_nodirty(inode, quota_cut_bytes);\r\nreiserfs_write_lock_nested(sb, depth);\r\nreturn ret_value;\r\n}\r\nstatic void truncate_directory(struct reiserfs_transaction_handle *th,\r\nstruct inode *inode)\r\n{\r\nBUG_ON(!th->t_trans_id);\r\nif (inode->i_nlink)\r\nreiserfs_error(inode->i_sb, "vs-5655", "link count != 0");\r\nset_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), DOT_OFFSET);\r\nset_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_DIRENTRY);\r\nreiserfs_delete_solid_item(th, inode, INODE_PKEY(inode));\r\nreiserfs_update_sd(th, inode);\r\nset_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), SD_OFFSET);\r\nset_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_STAT_DATA);\r\n}\r\nint reiserfs_do_truncate(struct reiserfs_transaction_handle *th,\r\nstruct inode *inode,\r\nstruct page *page,\r\nint update_timestamps\r\n)\r\n{\r\nINITIALIZE_PATH(s_search_path);\r\nstruct item_head *p_le_ih;\r\nstruct cpu_key s_item_key;\r\nloff_t file_size,\r\nnew_file_size;\r\nint deleted;\r\nint retval;\r\nint err = 0;\r\nBUG_ON(!th->t_trans_id);\r\nif (!\r\n(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)\r\n|| S_ISLNK(inode->i_mode)))\r\nreturn 0;\r\nif (S_ISDIR(inode->i_mode)) {\r\ntruncate_directory(th, inode);\r\nreturn 0;\r\n}\r\nnew_file_size = inode->i_size;\r\nmake_cpu_key(&s_item_key, inode, max_reiserfs_offset(inode),\r\nTYPE_DIRECT, 3);\r\nretval =\r\nsearch_for_position_by_key(inode->i_sb, &s_item_key,\r\n&s_search_path);\r\nif (retval == IO_ERROR) {\r\nreiserfs_error(inode->i_sb, "vs-5657",\r\n"i/o failure occurred trying to truncate %K",\r\n&s_item_key);\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nif (retval == POSITION_FOUND || retval == FILE_NOT_FOUND) {\r\nreiserfs_error(inode->i_sb, "PAP-5660",\r\n"wrong result %d of search for %K", retval,\r\n&s_item_key);\r\nerr = -EIO;\r\ngoto out;\r\n}\r\ns_search_path.pos_in_item--;\r\np_le_ih = tp_item_head(&s_search_path);\r\nif (is_statdata_le_ih(p_le_ih))\r\nfile_size = 0;\r\nelse {\r\nloff_t offset = le_ih_k_offset(p_le_ih);\r\nint bytes =\r\nop_bytes_number(p_le_ih, inode->i_sb->s_blocksize);\r\nfile_size = offset + bytes - 1;\r\n}\r\nif (new_file_size == 0)\r\ns_search_path.reada = PATH_READA | PATH_READA_BACK;\r\nif (file_size == 0 || file_size < new_file_size) {\r\ngoto update_and_out;\r\n}\r\nset_cpu_key_k_offset(&s_item_key, file_size);\r\ndo {\r\ndeleted =\r\nreiserfs_cut_from_item(th, &s_search_path, &s_item_key,\r\ninode, page, new_file_size);\r\nif (deleted < 0) {\r\nreiserfs_warning(inode->i_sb, "vs-5665",\r\n"reiserfs_cut_from_item failed");\r\nreiserfs_check_path(&s_search_path);\r\nreturn 0;\r\n}\r\nRFALSE(deleted > file_size,\r\n"PAP-5670: reiserfs_cut_from_item: too many bytes deleted: deleted %d, file_size %lu, item_key %K",\r\ndeleted, file_size, &s_item_key);\r\nfile_size -= deleted;\r\nset_cpu_key_k_offset(&s_item_key, file_size);\r\nif (journal_transaction_should_end(th, 0) ||\r\nreiserfs_transaction_free_space(th) <= JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD) {\r\npathrelse(&s_search_path);\r\nif (update_timestamps) {\r\ninode->i_mtime = CURRENT_TIME_SEC;\r\ninode->i_ctime = CURRENT_TIME_SEC;\r\n}\r\nreiserfs_update_sd(th, inode);\r\nerr = journal_end(th);\r\nif (err)\r\ngoto out;\r\nerr = journal_begin(th, inode->i_sb,\r\nJOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD + JOURNAL_PER_BALANCE_CNT * 4) ;\r\nif (err)\r\ngoto out;\r\nreiserfs_update_inode_transaction(inode);\r\n}\r\n} while (file_size > ROUND_UP(new_file_size) &&\r\nsearch_for_position_by_key(inode->i_sb, &s_item_key,\r\n&s_search_path) == POSITION_FOUND);\r\nRFALSE(file_size > ROUND_UP(new_file_size),\r\n"PAP-5680: truncate did not finish: new_file_size %lld, current %lld, oid %d",\r\nnew_file_size, file_size, s_item_key.on_disk_key.k_objectid);\r\nupdate_and_out:\r\nif (update_timestamps) {\r\ninode->i_mtime = CURRENT_TIME_SEC;\r\ninode->i_ctime = CURRENT_TIME_SEC;\r\n}\r\nreiserfs_update_sd(th, inode);\r\nout:\r\npathrelse(&s_search_path);\r\nreturn err;\r\n}\r\nstatic void check_research_for_paste(struct treepath *path,\r\nconst struct cpu_key *key)\r\n{\r\nstruct item_head *found_ih = tp_item_head(path);\r\nif (is_direct_le_ih(found_ih)) {\r\nif (le_ih_k_offset(found_ih) +\r\nop_bytes_number(found_ih,\r\nget_last_bh(path)->b_size) !=\r\ncpu_key_k_offset(key)\r\n|| op_bytes_number(found_ih,\r\nget_last_bh(path)->b_size) !=\r\npos_in_item(path))\r\nreiserfs_panic(NULL, "PAP-5720", "found direct item "\r\n"%h or position (%d) does not match "\r\n"to key %K", found_ih,\r\npos_in_item(path), key);\r\n}\r\nif (is_indirect_le_ih(found_ih)) {\r\nif (le_ih_k_offset(found_ih) +\r\nop_bytes_number(found_ih,\r\nget_last_bh(path)->b_size) !=\r\ncpu_key_k_offset(key)\r\n|| I_UNFM_NUM(found_ih) != pos_in_item(path)\r\n|| get_ih_free_space(found_ih) != 0)\r\nreiserfs_panic(NULL, "PAP-5730", "found indirect "\r\n"item (%h) or position (%d) does not "\r\n"match to key (%K)",\r\nfound_ih, pos_in_item(path), key);\r\n}\r\n}\r\nint reiserfs_paste_into_item(struct reiserfs_transaction_handle *th,\r\nstruct treepath *search_path,\r\nconst struct cpu_key *key,\r\nstruct inode *inode,\r\nconst char *body,\r\nint pasted_size)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct tree_balance s_paste_balance;\r\nint retval;\r\nint fs_gen;\r\nint depth;\r\nBUG_ON(!th->t_trans_id);\r\nfs_gen = get_generation(inode->i_sb);\r\n#ifdef REISERQUOTA_DEBUG\r\nreiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\r\n"reiserquota paste_into_item(): allocating %u id=%u type=%c",\r\npasted_size, inode->i_uid,\r\nkey2type(&key->on_disk_key));\r\n#endif\r\ndepth = reiserfs_write_unlock_nested(sb);\r\nretval = dquot_alloc_space_nodirty(inode, pasted_size);\r\nreiserfs_write_lock_nested(sb, depth);\r\nif (retval) {\r\npathrelse(search_path);\r\nreturn retval;\r\n}\r\ninit_tb_struct(th, &s_paste_balance, th->t_super, search_path,\r\npasted_size);\r\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\r\ns_paste_balance.key = key->on_disk_key;\r\n#endif\r\nif (fs_changed(fs_gen, inode->i_sb)) {\r\ngoto search_again;\r\n}\r\nwhile ((retval =\r\nfix_nodes(M_PASTE, &s_paste_balance, NULL,\r\nbody)) == REPEAT_SEARCH) {\r\nsearch_again:\r\nPROC_INFO_INC(th->t_super, paste_into_item_restarted);\r\nretval =\r\nsearch_for_position_by_key(th->t_super, key,\r\nsearch_path);\r\nif (retval == IO_ERROR) {\r\nretval = -EIO;\r\ngoto error_out;\r\n}\r\nif (retval == POSITION_FOUND) {\r\nreiserfs_warning(inode->i_sb, "PAP-5710",\r\n"entry or pasted byte (%K) exists",\r\nkey);\r\nretval = -EEXIST;\r\ngoto error_out;\r\n}\r\n#ifdef CONFIG_REISERFS_CHECK\r\ncheck_research_for_paste(search_path, key);\r\n#endif\r\n}\r\nif (retval == CARRY_ON) {\r\ndo_balance(&s_paste_balance, NULL , body, M_PASTE);\r\nreturn 0;\r\n}\r\nretval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;\r\nerror_out:\r\nunfix_nodes(&s_paste_balance);\r\n#ifdef REISERQUOTA_DEBUG\r\nreiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\r\n"reiserquota paste_into_item(): freeing %u id=%u type=%c",\r\npasted_size, inode->i_uid,\r\nkey2type(&key->on_disk_key));\r\n#endif\r\ndepth = reiserfs_write_unlock_nested(sb);\r\ndquot_free_space_nodirty(inode, pasted_size);\r\nreiserfs_write_lock_nested(sb, depth);\r\nreturn retval;\r\n}\r\nint reiserfs_insert_item(struct reiserfs_transaction_handle *th,\r\nstruct treepath *path, const struct cpu_key *key,\r\nstruct item_head *ih, struct inode *inode,\r\nconst char *body)\r\n{\r\nstruct tree_balance s_ins_balance;\r\nint retval;\r\nint fs_gen = 0;\r\nint quota_bytes = 0;\r\nBUG_ON(!th->t_trans_id);\r\nif (inode) {\r\nint depth;\r\nfs_gen = get_generation(inode->i_sb);\r\nquota_bytes = ih_item_len(ih);\r\nif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(ih))\r\nquota_bytes = inode->i_sb->s_blocksize + UNFM_P_SIZE;\r\n#ifdef REISERQUOTA_DEBUG\r\nreiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\r\n"reiserquota insert_item(): allocating %u id=%u type=%c",\r\nquota_bytes, inode->i_uid, head2type(ih));\r\n#endif\r\ndepth = reiserfs_write_unlock_nested(inode->i_sb);\r\nretval = dquot_alloc_space_nodirty(inode, quota_bytes);\r\nreiserfs_write_lock_nested(inode->i_sb, depth);\r\nif (retval) {\r\npathrelse(path);\r\nreturn retval;\r\n}\r\n}\r\ninit_tb_struct(th, &s_ins_balance, th->t_super, path,\r\nIH_SIZE + ih_item_len(ih));\r\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\r\ns_ins_balance.key = key->on_disk_key;\r\n#endif\r\nif (inode && fs_changed(fs_gen, inode->i_sb)) {\r\ngoto search_again;\r\n}\r\nwhile ((retval =\r\nfix_nodes(M_INSERT, &s_ins_balance, ih,\r\nbody)) == REPEAT_SEARCH) {\r\nsearch_again:\r\nPROC_INFO_INC(th->t_super, insert_item_restarted);\r\nretval = search_item(th->t_super, key, path);\r\nif (retval == IO_ERROR) {\r\nretval = -EIO;\r\ngoto error_out;\r\n}\r\nif (retval == ITEM_FOUND) {\r\nreiserfs_warning(th->t_super, "PAP-5760",\r\n"key %K already exists in the tree",\r\nkey);\r\nretval = -EEXIST;\r\ngoto error_out;\r\n}\r\n}\r\nif (retval == CARRY_ON) {\r\ndo_balance(&s_ins_balance, ih, body, M_INSERT);\r\nreturn 0;\r\n}\r\nretval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;\r\nerror_out:\r\nunfix_nodes(&s_ins_balance);\r\n#ifdef REISERQUOTA_DEBUG\r\nreiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,\r\n"reiserquota insert_item(): freeing %u id=%u type=%c",\r\nquota_bytes, inode->i_uid, head2type(ih));\r\n#endif\r\nif (inode) {\r\nint depth = reiserfs_write_unlock_nested(inode->i_sb);\r\ndquot_free_space_nodirty(inode, quota_bytes);\r\nreiserfs_write_lock_nested(inode->i_sb, depth);\r\n}\r\nreturn retval;\r\n}
