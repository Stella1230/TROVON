static inline int find_and_clear_bit_16(unsigned long *field)\r\n{\r\nint rv;\r\nif (*field == 0)\r\npanic("No free mscp");\r\nasm volatile (\r\n"xorl %0,%0\n\t"\r\n"0: bsfw %1,%w0\n\t"\r\n"btr %0,%1\n\t"\r\n"jnc 0b"\r\n: "=&r" (rv), "+m" (*field) :);\r\nreturn rv;\r\n}\r\nstatic inline unsigned char xchgb(unsigned char reg,\r\nvolatile unsigned char *mem)\r\n{\r\n__asm__ ("xchgb %0,%1" : "=q" (reg), "=m" (*mem) : "0" (reg));\r\nreturn reg;\r\n}\r\nstatic void log_ultrastor_abort(struct ultrastor_config *config,\r\nint command)\r\n{\r\nstatic char fmt[80] = "abort %d (%x); MSCP free pool: %x;";\r\nint i;\r\nfor (i = 0; i < ULTRASTOR_MAX_CMDS; i++)\r\n{\r\nfmt[20 + i*2] = ' ';\r\nif (! (config->mscp_free & (1 << i)))\r\nfmt[21 + i*2] = '0' + config->mscp[i].target_id;\r\nelse\r\nfmt[21 + i*2] = '-';\r\n}\r\nfmt[20 + ULTRASTOR_MAX_CMDS * 2] = '\n';\r\nfmt[21 + ULTRASTOR_MAX_CMDS * 2] = 0;\r\nprintk(fmt, command, &config->mscp[command], config->mscp_free);\r\n}\r\nstatic int ultrastor_14f_detect(struct scsi_host_template * tpnt)\r\n{\r\nsize_t i;\r\nunsigned char in_byte, version_byte = 0;\r\nstruct config_1 {\r\nunsigned char bios_segment: 3;\r\nunsigned char removable_disks_as_fixed: 1;\r\nunsigned char interrupt: 2;\r\nunsigned char dma_channel: 2;\r\n} config_1;\r\nstruct config_2 {\r\nunsigned char ha_scsi_id: 3;\r\nunsigned char mapping_mode: 2;\r\nunsigned char bios_drive_number: 1;\r\nunsigned char tfr_port: 2;\r\n} config_2;\r\n#if (ULTRASTOR_DEBUG & UD_DETECT)\r\nprintk("US14F: detect: called\n");\r\n#endif\r\nif (config.bios_segment)\r\nreturn FALSE;\r\n#ifdef PORT_OVERRIDE\r\nif(!request_region(PORT_OVERRIDE, 0xc, "ultrastor")) {\r\nprintk("Ultrastor I/O space already in use\n");\r\nreturn FALSE;\r\n};\r\nconfig.port_address = PORT_OVERRIDE;\r\n#else\r\nfor (i = 0; i < ARRAY_SIZE(ultrastor_ports_14f); i++) {\r\nif(!request_region(ultrastor_ports_14f[i], 0x0c, "ultrastor")) continue;\r\nconfig.port_address = ultrastor_ports_14f[i];\r\n#endif\r\n#if (ULTRASTOR_DEBUG & UD_DETECT)\r\nprintk("US14F: detect: testing port address %03X\n", config.port_address);\r\n#endif\r\nin_byte = inb(U14F_PRODUCT_ID(config.port_address));\r\nif (in_byte != US14F_PRODUCT_ID_0) {\r\n#if (ULTRASTOR_DEBUG & UD_DETECT)\r\n# ifdef PORT_OVERRIDE\r\nprintk("US14F: detect: wrong product ID 0 - %02X\n", in_byte);\r\n# else\r\nprintk("US14F: detect: no adapter at port %03X\n", config.port_address);\r\n# endif\r\n#endif\r\n#ifdef PORT_OVERRIDE\r\ngoto out_release_port;\r\n#else\r\nrelease_region(config.port_address, 0x0c);\r\ncontinue;\r\n#endif\r\n}\r\nin_byte = inb(U14F_PRODUCT_ID(config.port_address) + 1);\r\nif ((in_byte & 0xF0) != US14F_PRODUCT_ID_1) {\r\n#if (ULTRASTOR_DEBUG & UD_DETECT)\r\n# ifdef PORT_OVERRIDE\r\nprintk("US14F: detect: wrong product ID 1 - %02X\n", in_byte);\r\n# else\r\nprintk("US14F: detect: no adapter at port %03X\n", config.port_address);\r\n# endif\r\n#endif\r\n#ifdef PORT_OVERRIDE\r\ngoto out_release_port;\r\n#else\r\nrelease_region(config.port_address, 0x0c);\r\ncontinue;\r\n#endif\r\n}\r\nversion_byte = in_byte;\r\n#ifndef PORT_OVERRIDE\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(ultrastor_ports_14f)) {\r\n# if (ULTRASTOR_DEBUG & UD_DETECT)\r\nprintk("US14F: detect: no port address found!\n");\r\n# endif\r\nreturn FALSE;\r\n}\r\n#endif\r\n#if (ULTRASTOR_DEBUG & UD_DETECT)\r\nprintk("US14F: detect: adapter found at port address %03X\n",\r\nconfig.port_address);\r\n#endif\r\noutb(ultrastor_bus_reset ? 0xc2 : 0x82, LCL_DOORBELL_MASK(config.port_address));\r\n*(char *)&config_1 = inb(CONFIG(config.port_address + 0));\r\n*(char *)&config_2 = inb(CONFIG(config.port_address + 1));\r\nconfig.bios_segment = bios_segment_table[config_1.bios_segment];\r\nconfig.doorbell_address = config.port_address;\r\nconfig.ogm_address = config.port_address + 0x8;\r\nconfig.icm_address = config.port_address + 0xC;\r\nconfig.interrupt = interrupt_table_14f[config_1.interrupt];\r\nconfig.ha_scsi_id = config_2.ha_scsi_id;\r\nconfig.heads = mapping_table[config_2.mapping_mode].heads;\r\nconfig.sectors = mapping_table[config_2.mapping_mode].sectors;\r\nconfig.bios_drive_number = config_2.bios_drive_number;\r\nconfig.subversion = (version_byte & 0x0F);\r\nif (config.subversion == U34F)\r\nconfig.dma_channel = 0;\r\nelse\r\nconfig.dma_channel = dma_channel_table_14f[config_1.dma_channel];\r\nif (!config.bios_segment) {\r\n#if (ULTRASTOR_DEBUG & UD_DETECT)\r\nprintk("US14F: detect: not detected.\n");\r\n#endif\r\ngoto out_release_port;\r\n}\r\nif (config.subversion != U34F)\r\nif (!config.dma_channel || !(config_2.tfr_port & 0x2)) {\r\n#if (ULTRASTOR_DEBUG & UD_DETECT)\r\nprintk("US14F: detect: consistency check failed\n");\r\n#endif\r\ngoto out_release_port;\r\n}\r\n#if (ULTRASTOR_DEBUG & UD_DETECT)\r\nprintk("US14F: detect: detect succeeded\n"\r\n" Port address: %03X\n"\r\n" BIOS segment: %05X\n"\r\n" Interrupt: %u\n"\r\n" DMA channel: %u\n"\r\n" H/A SCSI ID: %u\n"\r\n" Subversion: %u\n",\r\nconfig.port_address, config.bios_segment, config.interrupt,\r\nconfig.dma_channel, config.ha_scsi_id, config.subversion);\r\n#endif\r\ntpnt->this_id = config.ha_scsi_id;\r\ntpnt->unchecked_isa_dma = (config.subversion != U34F);\r\n#if ULTRASTOR_MAX_CMDS > 1\r\nconfig.mscp_free = ~0;\r\n#endif\r\nif (request_irq(config.interrupt, do_ultrastor_interrupt, 0, "Ultrastor", &config.mscp[0].SCint->device->host)) {\r\nprintk("Unable to allocate IRQ%u for UltraStor controller.\n",\r\nconfig.interrupt);\r\ngoto out_release_port;\r\n}\r\nif (config.dma_channel && request_dma(config.dma_channel,"Ultrastor")) {\r\nprintk("Unable to allocate DMA channel %u for UltraStor controller.\n",\r\nconfig.dma_channel);\r\nfree_irq(config.interrupt, NULL);\r\ngoto out_release_port;\r\n}\r\ntpnt->sg_tablesize = ULTRASTOR_14F_MAX_SG;\r\nprintk("UltraStor driver version" VERSION ". Using %d SG lists.\n",\r\nULTRASTOR_14F_MAX_SG);\r\nreturn TRUE;\r\nout_release_port:\r\nrelease_region(config.port_address, 0x0c);\r\nreturn FALSE;\r\n}\r\nstatic int ultrastor_24f_detect(struct scsi_host_template * tpnt)\r\n{\r\nint i;\r\nstruct Scsi_Host * shpnt = NULL;\r\n#if (ULTRASTOR_DEBUG & UD_DETECT)\r\nprintk("US24F: detect");\r\n#endif\r\nfor (i = 1; i < 15; i++)\r\n{\r\nunsigned char config_1, config_2;\r\nunsigned short addr = (i << 12) | ULTRASTOR_24F_PORT;\r\nif (inb(addr) != US24F_PRODUCT_ID_0 &&\r\ninb(addr+1) != US24F_PRODUCT_ID_1 &&\r\ninb(addr+2) != US24F_PRODUCT_ID_2)\r\ncontinue;\r\nconfig.revision = inb(addr+3);\r\nconfig.slot = i;\r\nif (! (inb(addr+4) & 1))\r\n{\r\n#if (ULTRASTOR_DEBUG & UD_DETECT)\r\nprintk("U24F: found disabled card in slot %u\n", i);\r\n#endif\r\ncontinue;\r\n}\r\n#if (ULTRASTOR_DEBUG & UD_DETECT)\r\nprintk("U24F: found card in slot %u\n", i);\r\n#endif\r\nconfig_1 = inb(addr + 5);\r\nconfig.bios_segment = bios_segment_table[config_1 & 7];\r\nswitch(config_1 >> 4)\r\n{\r\ncase 1:\r\nconfig.interrupt = 15;\r\nbreak;\r\ncase 2:\r\nconfig.interrupt = 14;\r\nbreak;\r\ncase 4:\r\nconfig.interrupt = 11;\r\nbreak;\r\ncase 8:\r\nconfig.interrupt = 10;\r\nbreak;\r\ndefault:\r\nprintk("U24F: invalid IRQ\n");\r\nreturn FALSE;\r\n}\r\nconfig.port_address = addr;\r\nconfig.doorbell_address = addr + 12;\r\nconfig.ogm_address = addr + 0x17;\r\nconfig.icm_address = addr + 0x1C;\r\nconfig_2 = inb(addr + 7);\r\nconfig.ha_scsi_id = config_2 & 7;\r\nconfig.heads = mapping_table[(config_2 >> 3) & 3].heads;\r\nconfig.sectors = mapping_table[(config_2 >> 3) & 3].sectors;\r\n#if (ULTRASTOR_DEBUG & UD_DETECT)\r\nprintk("US24F: detect: detect succeeded\n"\r\n" Port address: %03X\n"\r\n" BIOS segment: %05X\n"\r\n" Interrupt: %u\n"\r\n" H/A SCSI ID: %u\n",\r\nconfig.port_address, config.bios_segment,\r\nconfig.interrupt, config.ha_scsi_id);\r\n#endif\r\ntpnt->this_id = config.ha_scsi_id;\r\ntpnt->unchecked_isa_dma = 0;\r\ntpnt->sg_tablesize = ULTRASTOR_24F_MAX_SG;\r\nshpnt = scsi_register(tpnt, 0);\r\nif (!shpnt) {\r\nprintk(KERN_WARNING "(ultrastor:) Could not register scsi device. Aborting registration.\n");\r\nfree_irq(config.interrupt, do_ultrastor_interrupt);\r\nreturn FALSE;\r\n}\r\nif (request_irq(config.interrupt, do_ultrastor_interrupt, 0, "Ultrastor", shpnt))\r\n{\r\nprintk("Unable to allocate IRQ%u for UltraStor controller.\n",\r\nconfig.interrupt);\r\nreturn FALSE;\r\n}\r\nshpnt->irq = config.interrupt;\r\nshpnt->dma_channel = config.dma_channel;\r\nshpnt->io_port = config.port_address;\r\n#if ULTRASTOR_MAX_CMDS > 1\r\nconfig.mscp_free = ~0;\r\n#endif\r\noutb(0, addr + 0x16);\r\noutb(0, addr + 0x1B);\r\noutb(ultrastor_bus_reset ? 0xc2 : 0x82, LCL_DOORBELL_MASK(addr+12));\r\noutb(0x02, SYS_DOORBELL_MASK(addr+12));\r\nprintk("UltraStor driver version " VERSION ". Using %d SG lists.\n",\r\ntpnt->sg_tablesize);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic int ultrastor_detect(struct scsi_host_template * tpnt)\r\n{\r\ntpnt->proc_name = "ultrastor";\r\nreturn ultrastor_14f_detect(tpnt) || ultrastor_24f_detect(tpnt);\r\n}\r\nstatic int ultrastor_release(struct Scsi_Host *shost)\r\n{\r\nif (shost->irq)\r\nfree_irq(shost->irq, NULL);\r\nif (shost->dma_channel != 0xff)\r\nfree_dma(shost->dma_channel);\r\nif (shost->io_port && shost->n_io_port)\r\nrelease_region(shost->io_port, shost->n_io_port);\r\nscsi_unregister(shost);\r\nreturn 0;\r\n}\r\nstatic const char *ultrastor_info(struct Scsi_Host * shpnt)\r\n{\r\nstatic char buf[64];\r\nif (config.slot)\r\nsprintf(buf, "UltraStor 24F SCSI @ Slot %u IRQ%u",\r\nconfig.slot, config.interrupt);\r\nelse if (config.subversion)\r\nsprintf(buf, "UltraStor 34F SCSI @ Port %03X BIOS %05X IRQ%u",\r\nconfig.port_address, (int)config.bios_segment,\r\nconfig.interrupt);\r\nelse\r\nsprintf(buf, "UltraStor 14F SCSI @ Port %03X BIOS %05X IRQ%u DMA%u",\r\nconfig.port_address, (int)config.bios_segment,\r\nconfig.interrupt, config.dma_channel);\r\nreturn buf;\r\n}\r\nstatic inline void build_sg_list(struct mscp *mscp, struct scsi_cmnd *SCpnt)\r\n{\r\nstruct scatterlist *sg;\r\nlong transfer_length = 0;\r\nint i, max;\r\nmax = scsi_sg_count(SCpnt);\r\nscsi_for_each_sg(SCpnt, sg, max, i) {\r\nmscp->sglist[i].address = isa_page_to_bus(sg_page(sg)) + sg->offset;\r\nmscp->sglist[i].num_bytes = sg->length;\r\ntransfer_length += sg->length;\r\n}\r\nmscp->number_of_sg_list = max;\r\nmscp->transfer_data = isa_virt_to_bus(mscp->sglist);\r\nmscp->transfer_data_length = transfer_length;\r\n}\r\nstatic int ultrastor_queuecommand_lck(struct scsi_cmnd *SCpnt,\r\nvoid (*done) (struct scsi_cmnd *))\r\n{\r\nstruct mscp *my_mscp;\r\n#if ULTRASTOR_MAX_CMDS > 1\r\nint mscp_index;\r\n#endif\r\nunsigned int status;\r\nif ((config.mscp_free & ((1U << ULTRASTOR_MAX_CMDS) - 1)) == 0)\r\npanic("ultrastor_queuecommand: no free MSCP\n");\r\nmscp_index = find_and_clear_bit_16(&config.mscp_free);\r\nif (xchgb(0xff, &config.aborted[mscp_index]) != 0)\r\n{\r\nstatus = DID_ABORT << 16;\r\ngoto aborted;\r\n}\r\nmy_mscp = &config.mscp[mscp_index];\r\n*(unsigned char *)my_mscp = OP_SCSI | (DTD_SCSI << 3);\r\nmy_mscp->ca = SCpnt->device->type != TYPE_TAPE;\r\nmy_mscp->target_id = SCpnt->device->id;\r\nmy_mscp->ch_no = 0;\r\nmy_mscp->lun = SCpnt->device->lun;\r\nif (scsi_sg_count(SCpnt)) {\r\nmy_mscp->sg = TRUE;\r\nbuild_sg_list(my_mscp, SCpnt);\r\n} else {\r\nmy_mscp->sg = FALSE;\r\nmy_mscp->transfer_data = isa_virt_to_bus(scsi_sglist(SCpnt));\r\nmy_mscp->transfer_data_length = scsi_bufflen(SCpnt);\r\n}\r\nmy_mscp->command_link = 0;\r\nmy_mscp->scsi_command_link_id = 0;\r\nmy_mscp->length_of_sense_byte = SCSI_SENSE_BUFFERSIZE;\r\nmy_mscp->length_of_scsi_cdbs = SCpnt->cmd_len;\r\nmemcpy(my_mscp->scsi_cdbs, SCpnt->cmnd, my_mscp->length_of_scsi_cdbs);\r\nmy_mscp->adapter_status = 0;\r\nmy_mscp->target_status = 0;\r\nmy_mscp->sense_data = isa_virt_to_bus(&SCpnt->sense_buffer);\r\nmy_mscp->done = done;\r\nmy_mscp->SCint = SCpnt;\r\nSCpnt->host_scribble = (unsigned char *)my_mscp;\r\nretry:\r\nif (config.slot)\r\nwhile (inb(config.ogm_address - 1) != 0 && config.aborted[mscp_index] == 0xff)\r\nbarrier();\r\nwhile ((inb(LCL_DOORBELL_INTR(config.doorbell_address)) & (config.slot ? 2 : 1)) && config.aborted[mscp_index] == 0xff)\r\nbarrier();\r\nif (inb(LCL_DOORBELL_INTR(config.doorbell_address)) & (config.slot ? 2 : 1))\r\ngoto retry;\r\nstatus = xchgb(0, &config.aborted[mscp_index]);\r\nif (status != 0xff) {\r\n#if ULTRASTOR_DEBUG & (UD_COMMAND | UD_ABORT)\r\nprintk("USx4F: queuecommand: aborted\n");\r\n#if ULTRASTOR_MAX_CMDS > 1\r\nlog_ultrastor_abort(&config, mscp_index);\r\n#endif\r\n#endif\r\nstatus <<= 16;\r\naborted:\r\nset_bit(mscp_index, &config.mscp_free);\r\n#if ULTRASTOR_MAX_CMDS > 1\r\nSCpnt->result = status;\r\ndone(SCpnt);\r\nreturn 0;\r\n#else\r\nreturn status;\r\n#endif\r\n}\r\noutl(isa_virt_to_bus(my_mscp), config.ogm_address);\r\nif (config.slot) {\r\noutb(1, config.ogm_address - 1);\r\noutb(0x2, LCL_DOORBELL_INTR(config.doorbell_address));\r\n} else {\r\noutb(0x1, LCL_DOORBELL_INTR(config.doorbell_address));\r\n}\r\n#if (ULTRASTOR_DEBUG & UD_COMMAND)\r\nprintk("USx4F: queuecommand: returning\n");\r\n#endif\r\nreturn 0;\r\n}\r\nint ultrastor_host_reset(struct scsi_cmnd * SCpnt)\r\n{\r\nunsigned long flags;\r\nint i;\r\nstruct Scsi_Host *host = SCpnt->device->host;\r\n#if (ULTRASTOR_DEBUG & UD_RESET)\r\nprintk("US14F: reset: called\n");\r\n#endif\r\nif(config.slot)\r\nreturn FAILED;\r\nspin_lock_irqsave(host->host_lock, flags);\r\noutb(0xc0, LCL_DOORBELL_INTR(config.doorbell_address));\r\nif (config.slot)\r\n{\r\noutb(0, config.ogm_address - 1);\r\noutb(0, config.icm_address - 1);\r\n}\r\n#if ULTRASTOR_MAX_CMDS == 1\r\nif (config.mscp_busy && config.mscp->done && config.mscp->SCint)\r\n{\r\nconfig.mscp->SCint->result = DID_RESET << 16;\r\nconfig.mscp->done(config.mscp->SCint);\r\n}\r\nconfig.mscp->SCint = 0;\r\n#else\r\nfor (i = 0; i < ULTRASTOR_MAX_CMDS; i++)\r\n{\r\nif (! (config.mscp_free & (1 << i)) &&\r\nconfig.mscp[i].done && config.mscp[i].SCint)\r\n{\r\nconfig.mscp[i].SCint->result = DID_RESET << 16;\r\nconfig.mscp[i].done(config.mscp[i].SCint);\r\nconfig.mscp[i].done = NULL;\r\n}\r\nconfig.mscp[i].SCint = NULL;\r\n}\r\n#endif\r\nmemset((unsigned char *)config.aborted, 0, sizeof config.aborted);\r\n#if ULTRASTOR_MAX_CMDS == 1\r\nconfig.mscp_busy = 0;\r\n#else\r\nconfig.mscp_free = ~0;\r\n#endif\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\nreturn SUCCESS;\r\n}\r\nint ultrastor_biosparam(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int * dkinfo)\r\n{\r\nint size = capacity;\r\nunsigned int s = config.heads * config.sectors;\r\ndkinfo[0] = config.heads;\r\ndkinfo[1] = config.sectors;\r\ndkinfo[2] = size / s;\r\n#if 0\r\nif (dkinfo[2] > 1024)\r\ndkinfo[2] = 1024;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void ultrastor_interrupt(void *dev_id)\r\n{\r\nunsigned int status;\r\n#if ULTRASTOR_MAX_CMDS > 1\r\nunsigned int mscp_index;\r\n#endif\r\nstruct mscp *mscp;\r\nvoid (*done) (struct scsi_cmnd *);\r\nstruct scsi_cmnd *SCtmp;\r\n#if ULTRASTOR_MAX_CMDS == 1\r\nmscp = &config.mscp[0];\r\n#else\r\nmscp = (struct mscp *)isa_bus_to_virt(inl(config.icm_address));\r\nmscp_index = mscp - config.mscp;\r\nif (mscp_index >= ULTRASTOR_MAX_CMDS) {\r\nprintk("Ux4F interrupt: bad MSCP address %x\n", (unsigned int) mscp);\r\nultrastor_host_reset(dev_id);\r\nreturn;\r\n}\r\n#endif\r\nif (config.slot) {\r\nunsigned char icm_status = inb(config.icm_address - 1);\r\n#if ULTRASTOR_DEBUG & (UD_INTERRUPT|UD_ERROR|UD_ABORT)\r\nif (icm_status != 1 && icm_status != 2)\r\nprintk("US24F: ICM status %x for MSCP %d (%x)\n", icm_status,\r\nmscp_index, (unsigned int) mscp);\r\n#endif\r\noutb(2, SYS_DOORBELL_INTR(config.doorbell_address));\r\noutb(0, config.icm_address - 1);\r\nif (icm_status == 4) {\r\nprintk("UltraStor abort command failed\n");\r\nreturn;\r\n}\r\nif (icm_status == 3) {\r\nvoid (*done)(struct scsi_cmnd *) = mscp->done;\r\nif (done) {\r\nmscp->done = NULL;\r\nmscp->SCint->result = DID_ABORT << 16;\r\ndone(mscp->SCint);\r\n}\r\nreturn;\r\n}\r\n} else {\r\noutb(1, SYS_DOORBELL_INTR(config.doorbell_address));\r\n}\r\nSCtmp = mscp->SCint;\r\nmscp->SCint = NULL;\r\nif (!SCtmp)\r\n{\r\n#if ULTRASTOR_DEBUG & (UD_ABORT|UD_INTERRUPT)\r\nprintk("MSCP %d (%x): no command\n", mscp_index, (unsigned int) mscp);\r\n#endif\r\n#if ULTRASTOR_MAX_CMDS == 1\r\nconfig.mscp_busy = FALSE;\r\n#else\r\nset_bit(mscp_index, &config.mscp_free);\r\n#endif\r\nconfig.aborted[mscp_index] = 0;\r\nreturn;\r\n}\r\ndone = mscp->done;\r\nmscp->done = NULL;\r\nswitch (mscp->adapter_status)\r\n{\r\ncase 0:\r\nstatus = DID_OK << 16;\r\nbreak;\r\ncase 0x01:\r\ncase 0x02:\r\ncase 0x03:\r\ndefault:\r\nstatus = DID_ERROR << 16;\r\nbreak;\r\ncase 0x84:\r\nstatus = DID_ABORT << 16;\r\nbreak;\r\ncase 0x91:\r\nstatus = DID_TIME_OUT << 16;\r\nbreak;\r\n}\r\nSCtmp->result = status | mscp->target_status;\r\nSCtmp->host_scribble = NULL;\r\n#if ULTRASTOR_MAX_CMDS == 1\r\nconfig.mscp_busy = FALSE;\r\n#else\r\nset_bit(mscp_index, &config.mscp_free);\r\n#endif\r\n#if ULTRASTOR_DEBUG & (UD_ABORT|UD_INTERRUPT)\r\nif (config.aborted[mscp_index])\r\nprintk("Ux4 interrupt: MSCP %d (%x) aborted = %d\n",\r\nmscp_index, (unsigned int) mscp, config.aborted[mscp_index]);\r\n#endif\r\nconfig.aborted[mscp_index] = 0;\r\nif (done)\r\ndone(SCtmp);\r\nelse\r\nprintk("US14F: interrupt: unexpected interrupt\n");\r\nif (config.slot ? inb(config.icm_address - 1) :\r\n(inb(SYS_DOORBELL_INTR(config.doorbell_address)) & 1))\r\n#if (ULTRASTOR_DEBUG & UD_MULTI_CMD)\r\nprintk("Ux4F: multiple commands completed\n");\r\n#else\r\n;\r\n#endif\r\n#if (ULTRASTOR_DEBUG & UD_INTERRUPT)\r\nprintk("USx4F: interrupt: returning\n");\r\n#endif\r\n}\r\nstatic irqreturn_t do_ultrastor_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned long flags;\r\nstruct Scsi_Host *dev = dev_id;\r\nspin_lock_irqsave(dev->host_lock, flags);\r\nultrastor_interrupt(dev_id);\r\nspin_unlock_irqrestore(dev->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}
