static cycle_t cksrc_dc21285_read(struct clocksource *cs)\r\n{\r\nreturn cs->mask - *CSR_TIMER2_VALUE;\r\n}\r\nstatic int cksrc_dc21285_enable(struct clocksource *cs)\r\n{\r\n*CSR_TIMER2_LOAD = cs->mask;\r\n*CSR_TIMER2_CLR = 0;\r\n*CSR_TIMER2_CNTL = TIMER_CNTL_ENABLE | TIMER_CNTL_DIV16;\r\nreturn 0;\r\n}\r\nstatic void cksrc_dc21285_disable(struct clocksource *cs)\r\n{\r\n*CSR_TIMER2_CNTL = 0;\r\n}\r\nstatic int ckevt_dc21285_set_next_event(unsigned long delta,\r\nstruct clock_event_device *c)\r\n{\r\n*CSR_TIMER1_CLR = 0;\r\n*CSR_TIMER1_LOAD = delta;\r\n*CSR_TIMER1_CNTL = TIMER_CNTL_ENABLE | TIMER_CNTL_DIV16;\r\nreturn 0;\r\n}\r\nstatic int ckevt_dc21285_shutdown(struct clock_event_device *c)\r\n{\r\n*CSR_TIMER1_CNTL = 0;\r\nreturn 0;\r\n}\r\nstatic int ckevt_dc21285_set_periodic(struct clock_event_device *c)\r\n{\r\n*CSR_TIMER1_CLR = 0;\r\n*CSR_TIMER1_LOAD = (mem_fclk_21285 + 8 * HZ) / (16 * HZ);\r\n*CSR_TIMER1_CNTL = TIMER_CNTL_ENABLE | TIMER_CNTL_AUTORELOAD |\r\nTIMER_CNTL_DIV16;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t timer1_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *ce = dev_id;\r\n*CSR_TIMER1_CLR = 0;\r\nif (clockevent_state_oneshot(ce))\r\n*CSR_TIMER1_CNTL = 0;\r\nce->event_handler(ce);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid __init footbridge_timer_init(void)\r\n{\r\nstruct clock_event_device *ce = &ckevt_dc21285;\r\nunsigned rate = DIV_ROUND_CLOSEST(mem_fclk_21285, 16);\r\nclocksource_register_hz(&cksrc_dc21285, rate);\r\nsetup_irq(ce->irq, &footbridge_timer_irq);\r\nce->cpumask = cpumask_of(smp_processor_id());\r\nclockevents_config_and_register(ce, rate, 0x4, 0xffffff);\r\n}\r\nstatic u64 notrace footbridge_read_sched_clock(void)\r\n{\r\nreturn ~*CSR_TIMER3_VALUE;\r\n}\r\nvoid __init footbridge_sched_clock(void)\r\n{\r\nunsigned rate = DIV_ROUND_CLOSEST(mem_fclk_21285, 16);\r\n*CSR_TIMER3_LOAD = 0;\r\n*CSR_TIMER3_CLR = 0;\r\n*CSR_TIMER3_CNTL = TIMER_CNTL_ENABLE | TIMER_CNTL_DIV16;\r\nsched_clock_register(footbridge_read_sched_clock, 24, rate);\r\n}
