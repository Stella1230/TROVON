static int fs_enet_fec_mii_read(struct mii_bus *bus , int phy_id, int location)\r\n{\r\nstruct fec_info* fec = bus->priv;\r\nstruct fec __iomem *fecp = fec->fecp;\r\nint i, ret = -1;\r\nBUG_ON((in_be32(&fecp->fec_r_cntrl) & FEC_RCNTRL_MII_MODE) == 0);\r\nout_be32(&fecp->fec_mii_data, (phy_id << 23) | mk_mii_read(location));\r\nfor (i = 0; i < FEC_MII_LOOPS; i++)\r\nif ((in_be32(&fecp->fec_ievent) & FEC_ENET_MII) != 0)\r\nbreak;\r\nif (i < FEC_MII_LOOPS) {\r\nout_be32(&fecp->fec_ievent, FEC_ENET_MII);\r\nret = in_be32(&fecp->fec_mii_data) & 0xffff;\r\n}\r\nreturn ret;\r\n}\r\nstatic int fs_enet_fec_mii_write(struct mii_bus *bus, int phy_id, int location, u16 val)\r\n{\r\nstruct fec_info* fec = bus->priv;\r\nstruct fec __iomem *fecp = fec->fecp;\r\nint i;\r\nBUG_ON((in_be32(&fecp->fec_r_cntrl) & FEC_RCNTRL_MII_MODE) == 0);\r\nout_be32(&fecp->fec_mii_data, (phy_id << 23) | mk_mii_write(location, val));\r\nfor (i = 0; i < FEC_MII_LOOPS; i++)\r\nif ((in_be32(&fecp->fec_ievent) & FEC_ENET_MII) != 0)\r\nbreak;\r\nif (i < FEC_MII_LOOPS)\r\nout_be32(&fecp->fec_ievent, FEC_ENET_MII);\r\nreturn 0;\r\n}\r\nstatic int fs_enet_mdio_probe(struct platform_device *ofdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct resource res;\r\nstruct mii_bus *new_bus;\r\nstruct fec_info *fec;\r\nint (*get_bus_freq)(struct device_node *);\r\nint ret = -ENOMEM, clock, speed;\r\nmatch = of_match_device(fs_enet_mdio_fec_match, &ofdev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nget_bus_freq = match->data;\r\nnew_bus = mdiobus_alloc();\r\nif (!new_bus)\r\ngoto out;\r\nfec = kzalloc(sizeof(struct fec_info), GFP_KERNEL);\r\nif (!fec)\r\ngoto out_mii;\r\nnew_bus->priv = fec;\r\nnew_bus->name = "FEC MII Bus";\r\nnew_bus->read = &fs_enet_fec_mii_read;\r\nnew_bus->write = &fs_enet_fec_mii_write;\r\nret = of_address_to_resource(ofdev->dev.of_node, 0, &res);\r\nif (ret)\r\ngoto out_res;\r\nsnprintf(new_bus->id, MII_BUS_ID_SIZE, "%x", res.start);\r\nfec->fecp = ioremap(res.start, resource_size(&res));\r\nif (!fec->fecp) {\r\nret = -ENOMEM;\r\ngoto out_fec;\r\n}\r\nif (get_bus_freq) {\r\nclock = get_bus_freq(ofdev->dev.of_node);\r\nif (!clock) {\r\ndev_warn(&ofdev->dev, "could not determine IPS clock\n");\r\nclock = 0x3F * 5000000;\r\n}\r\n} else\r\nclock = ppc_proc_freq;\r\nspeed = (clock + 4999999) / 5000000;\r\nif (speed > 0x3F) {\r\nspeed = 0x3F;\r\ndev_err(&ofdev->dev,\r\n"MII clock (%d Hz) exceeds max (2.5 MHz)\n",\r\nclock / speed);\r\n}\r\nfec->mii_speed = speed << 1;\r\nsetbits32(&fec->fecp->fec_r_cntrl, FEC_RCNTRL_MII_MODE);\r\nsetbits32(&fec->fecp->fec_ecntrl, FEC_ECNTRL_PINMUX |\r\nFEC_ECNTRL_ETHER_EN);\r\nout_be32(&fec->fecp->fec_ievent, FEC_ENET_MII);\r\nclrsetbits_be32(&fec->fecp->fec_mii_speed, 0x7E, fec->mii_speed);\r\nnew_bus->phy_mask = ~0;\r\nnew_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);\r\nif (!new_bus->irq) {\r\nret = -ENOMEM;\r\ngoto out_unmap_regs;\r\n}\r\nnew_bus->parent = &ofdev->dev;\r\nplatform_set_drvdata(ofdev, new_bus);\r\nret = of_mdiobus_register(new_bus, ofdev->dev.of_node);\r\nif (ret)\r\ngoto out_free_irqs;\r\nreturn 0;\r\nout_free_irqs:\r\nkfree(new_bus->irq);\r\nout_unmap_regs:\r\niounmap(fec->fecp);\r\nout_res:\r\nout_fec:\r\nkfree(fec);\r\nout_mii:\r\nmdiobus_free(new_bus);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int fs_enet_mdio_remove(struct platform_device *ofdev)\r\n{\r\nstruct mii_bus *bus = platform_get_drvdata(ofdev);\r\nstruct fec_info *fec = bus->priv;\r\nmdiobus_unregister(bus);\r\nkfree(bus->irq);\r\niounmap(fec->fecp);\r\nkfree(fec);\r\nmdiobus_free(bus);\r\nreturn 0;\r\n}
