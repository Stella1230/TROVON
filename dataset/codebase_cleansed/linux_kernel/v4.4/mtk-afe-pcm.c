static snd_pcm_uframes_t mtk_afe_pcm_pointer\r\n(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mtk_afe_memif *memif = &afe->memif[rtd->cpu_dai->id];\r\nreturn bytes_to_frames(substream->runtime, memif->hw_ptr);\r\n}\r\nstatic int mtk_afe_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nsize_t size;\r\nstruct snd_card *card = rtd->card->snd_card;\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nsize = mtk_afe_hardware.buffer_bytes_max;\r\nreturn snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\ncard->dev, size, size);\r\n}\r\nstatic void mtk_afe_pcm_free(struct snd_pcm *pcm)\r\n{\r\nsnd_pcm_lib_preallocate_free_for_all(pcm);\r\n}\r\nstatic int mtk_afe_i2s_fs(unsigned int sample_rate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mtk_afe_i2s_rates); i++)\r\nif (mtk_afe_i2s_rates[i].rate == sample_rate)\r\nreturn mtk_afe_i2s_rates[i].regvalue;\r\nreturn -EINVAL;\r\n}\r\nstatic int mtk_afe_set_i2s(struct mtk_afe *afe, unsigned int rate)\r\n{\r\nunsigned int val;\r\nint fs = mtk_afe_i2s_fs(rate);\r\nif (fs < 0)\r\nreturn -EINVAL;\r\nregmap_update_bits(afe->regmap, AFE_ADDA2_TOP_CON0, 0x1, 0x1);\r\nval = AFE_I2S_CON2_LOW_JITTER_CLK |\r\nAFE_I2S_CON2_RATE(fs) |\r\nAFE_I2S_CON2_FORMAT_I2S;\r\nregmap_update_bits(afe->regmap, AFE_I2S_CON2, ~AFE_I2S_CON2_EN, val);\r\nval = AFE_I2S_CON1_LOW_JITTER_CLK |\r\nAFE_I2S_CON1_RATE(fs) |\r\nAFE_I2S_CON1_FORMAT_I2S;\r\nregmap_update_bits(afe->regmap, AFE_I2S_CON1, ~AFE_I2S_CON1_EN, val);\r\nreturn 0;\r\n}\r\nstatic void mtk_afe_set_i2s_enable(struct mtk_afe *afe, bool enable)\r\n{\r\nunsigned int val;\r\nregmap_read(afe->regmap, AFE_I2S_CON2, &val);\r\nif (!!(val & AFE_I2S_CON2_EN) == enable)\r\nreturn;\r\nregmap_update_bits(afe->regmap, AUDIO_TOP_CON1, 0x4, 0x4);\r\nregmap_update_bits(afe->regmap, AFE_I2S_CON2, 0x1, enable);\r\nregmap_update_bits(afe->regmap, AFE_I2S_CON1, 0x1, enable);\r\nudelay(1);\r\nregmap_update_bits(afe->regmap, AUDIO_TOP_CON1, 0x4, 0);\r\n}\r\nstatic int mtk_afe_dais_enable_clks(struct mtk_afe *afe,\r\nstruct clk *m_ck, struct clk *b_ck)\r\n{\r\nint ret;\r\nif (m_ck) {\r\nret = clk_prepare_enable(m_ck);\r\nif (ret) {\r\ndev_err(afe->dev, "Failed to enable m_ck\n");\r\nreturn ret;\r\n}\r\nregmap_update_bits(afe->regmap, AUDIO_TOP_CON0,\r\nAUD_TCON0_PDN_22M | AUD_TCON0_PDN_24M, 0);\r\n}\r\nif (b_ck) {\r\nret = clk_prepare_enable(b_ck);\r\nif (ret) {\r\ndev_err(afe->dev, "Failed to enable b_ck\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mtk_afe_dais_set_clks(struct mtk_afe *afe,\r\nstruct clk *m_ck, unsigned int mck_rate,\r\nstruct clk *b_ck, unsigned int bck_rate)\r\n{\r\nint ret;\r\nif (m_ck) {\r\nret = clk_set_rate(m_ck, mck_rate);\r\nif (ret) {\r\ndev_err(afe->dev, "Failed to set m_ck rate\n");\r\nreturn ret;\r\n}\r\n}\r\nif (b_ck) {\r\nret = clk_set_rate(b_ck, bck_rate);\r\nif (ret) {\r\ndev_err(afe->dev, "Failed to set b_ck rate\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void mtk_afe_dais_disable_clks(struct mtk_afe *afe,\r\nstruct clk *m_ck, struct clk *b_ck)\r\n{\r\nif (m_ck) {\r\nregmap_update_bits(afe->regmap, AUDIO_TOP_CON0,\r\nAUD_TCON0_PDN_22M | AUD_TCON0_PDN_24M,\r\nAUD_TCON0_PDN_22M | AUD_TCON0_PDN_24M);\r\nclk_disable_unprepare(m_ck);\r\n}\r\nif (b_ck)\r\nclk_disable_unprepare(b_ck);\r\n}\r\nstatic int mtk_afe_i2s_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nif (dai->active)\r\nreturn 0;\r\nmtk_afe_dais_enable_clks(afe, afe->clocks[MTK_CLK_I2S1_M], NULL);\r\nreturn 0;\r\n}\r\nstatic void mtk_afe_i2s_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nif (dai->active)\r\nreturn;\r\nmtk_afe_set_i2s_enable(afe, false);\r\nmtk_afe_dais_disable_clks(afe, afe->clocks[MTK_CLK_I2S1_M], NULL);\r\nregmap_update_bits(afe->regmap, AFE_DAC_CON0, 0x1, 0);\r\n}\r\nstatic int mtk_afe_i2s_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime * const runtime = substream->runtime;\r\nstruct mtk_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nint ret;\r\nmtk_afe_dais_set_clks(afe,\r\nafe->clocks[MTK_CLK_I2S1_M], runtime->rate * 256,\r\nNULL, 0);\r\nret = mtk_afe_set_i2s(afe, substream->runtime->rate);\r\nif (ret)\r\nreturn ret;\r\nmtk_afe_set_i2s_enable(afe, true);\r\nreturn 0;\r\n}\r\nstatic int mtk_afe_hdmi_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nif (dai->active)\r\nreturn 0;\r\nmtk_afe_dais_enable_clks(afe, afe->clocks[MTK_CLK_I2S3_M],\r\nafe->clocks[MTK_CLK_I2S3_B]);\r\nreturn 0;\r\n}\r\nstatic void mtk_afe_hdmi_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nif (dai->active)\r\nreturn;\r\nmtk_afe_dais_disable_clks(afe, afe->clocks[MTK_CLK_I2S3_M],\r\nafe->clocks[MTK_CLK_I2S3_B]);\r\nregmap_update_bits(afe->regmap, AFE_DAC_CON0, 0x1, 0);\r\n}\r\nstatic int mtk_afe_hdmi_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime * const runtime = substream->runtime;\r\nstruct mtk_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nunsigned int val;\r\nmtk_afe_dais_set_clks(afe,\r\nafe->clocks[MTK_CLK_I2S3_M], runtime->rate * 128,\r\nafe->clocks[MTK_CLK_I2S3_B],\r\nruntime->rate * runtime->channels * 32);\r\nval = AFE_TDM_CON1_BCK_INV |\r\nAFE_TDM_CON1_1_BCK_DELAY |\r\nAFE_TDM_CON1_MSB_ALIGNED |\r\nAFE_TDM_CON1_WLEN_32BIT |\r\nAFE_TDM_CON1_32_BCK_CYCLES |\r\nAFE_TDM_CON1_LRCK_WIDTH(32);\r\nregmap_update_bits(afe->regmap, AFE_TDM_CON1, ~AFE_TDM_CON1_EN, val);\r\nswitch (runtime->channels) {\r\ncase 1:\r\ncase 2:\r\nval = AFE_TDM_CH_START_O30_O31;\r\nval |= (AFE_TDM_CH_ZERO << 4);\r\nval |= (AFE_TDM_CH_ZERO << 8);\r\nval |= (AFE_TDM_CH_ZERO << 12);\r\nbreak;\r\ncase 3:\r\ncase 4:\r\nval = AFE_TDM_CH_START_O30_O31;\r\nval |= (AFE_TDM_CH_START_O32_O33 << 4);\r\nval |= (AFE_TDM_CH_ZERO << 8);\r\nval |= (AFE_TDM_CH_ZERO << 12);\r\nbreak;\r\ncase 5:\r\ncase 6:\r\nval = AFE_TDM_CH_START_O30_O31;\r\nval |= (AFE_TDM_CH_START_O32_O33 << 4);\r\nval |= (AFE_TDM_CH_START_O34_O35 << 8);\r\nval |= (AFE_TDM_CH_ZERO << 12);\r\nbreak;\r\ncase 7:\r\ncase 8:\r\nval = AFE_TDM_CH_START_O30_O31;\r\nval |= (AFE_TDM_CH_START_O32_O33 << 4);\r\nval |= (AFE_TDM_CH_START_O34_O35 << 8);\r\nval |= (AFE_TDM_CH_START_O36_O37 << 12);\r\nbreak;\r\ndefault:\r\nval = 0;\r\n}\r\nregmap_update_bits(afe->regmap, AFE_TDM_CON2, 0x0000ffff, val);\r\nregmap_update_bits(afe->regmap, AFE_HDMI_OUT_CON0,\r\n0x000000f0, runtime->channels << 4);\r\nreturn 0;\r\n}\r\nstatic int mtk_afe_hdmi_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\ndev_info(afe->dev, "%s cmd=%d %s\n", __func__, cmd, dai->name);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nregmap_update_bits(afe->regmap, AUDIO_TOP_CON0,\r\nAUD_TCON0_PDN_HDMI | AUD_TCON0_PDN_SPDF, 0);\r\nregmap_write(afe->regmap, AFE_HDMI_CONN0,\r\nAFE_HDMI_CONN0_O30_I30 | AFE_HDMI_CONN0_O31_I31 |\r\nAFE_HDMI_CONN0_O32_I34 | AFE_HDMI_CONN0_O33_I35 |\r\nAFE_HDMI_CONN0_O34_I32 | AFE_HDMI_CONN0_O35_I33 |\r\nAFE_HDMI_CONN0_O36_I36 | AFE_HDMI_CONN0_O37_I37);\r\nregmap_update_bits(afe->regmap, AFE_HDMI_OUT_CON0, 0x1, 0x1);\r\nregmap_update_bits(afe->regmap, AFE_TDM_CON1, 0x1, 0x1);\r\nreturn 0;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nregmap_update_bits(afe->regmap, AFE_TDM_CON1, 0x1, 0);\r\nregmap_update_bits(afe->regmap, AFE_HDMI_OUT_CON0, 0x1, 0);\r\nregmap_update_bits(afe->regmap, AUDIO_TOP_CON0,\r\nAUD_TCON0_PDN_HDMI | AUD_TCON0_PDN_SPDF,\r\nAUD_TCON0_PDN_HDMI | AUD_TCON0_PDN_SPDF);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int mtk_afe_dais_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct mtk_afe_memif *memif = &afe->memif[rtd->cpu_dai->id];\r\nint ret;\r\nmemif->substream = substream;\r\nsnd_soc_set_runtime_hwparams(substream, &mtk_afe_hardware);\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\r\nret = snd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS,\r\n3,\r\nmtk_afe_hardware.periods_max);\r\nif (ret < 0) {\r\ndev_err(afe->dev, "hw_constraint_minmax failed\n");\r\nreturn ret;\r\n}\r\n}\r\nret = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (ret < 0)\r\ndev_err(afe->dev, "snd_pcm_hw_constraint_integer failed\n");\r\nreturn ret;\r\n}\r\nstatic void mtk_afe_dais_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mtk_afe_memif *memif = &afe->memif[rtd->cpu_dai->id];\r\nmemif->substream = NULL;\r\n}\r\nstatic int mtk_afe_dais_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mtk_afe_memif *memif = &afe->memif[rtd->cpu_dai->id];\r\nint ret;\r\ndev_dbg(afe->dev,\r\n"%s period = %u, rate= %u, channels=%u\n",\r\n__func__, params_period_size(params), params_rate(params),\r\nparams_channels(params));\r\nret = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));\r\nif (ret < 0)\r\nreturn ret;\r\nmemif->phys_buf_addr = substream->runtime->dma_addr;\r\nmemif->buffer_size = substream->runtime->dma_bytes;\r\nmemif->hw_ptr = 0;\r\nregmap_write(afe->regmap,\r\nmemif->data->reg_ofs_base, memif->phys_buf_addr);\r\nregmap_write(afe->regmap,\r\nmemif->data->reg_ofs_base + AFE_BASE_END_OFFSET,\r\nmemif->phys_buf_addr + memif->buffer_size - 1);\r\nif (memif->data->mono_shift >= 0) {\r\nunsigned int mono = (params_channels(params) == 1) ? 1 : 0;\r\nregmap_update_bits(afe->regmap, AFE_DAC_CON1,\r\n1 << memif->data->mono_shift,\r\nmono << memif->data->mono_shift);\r\n}\r\nif (memif->data->fs_shift < 0)\r\nreturn 0;\r\nif (memif->data->id == MTK_AFE_MEMIF_DAI ||\r\nmemif->data->id == MTK_AFE_MEMIF_MOD_DAI) {\r\nunsigned int val;\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\nval = 0;\r\nbreak;\r\ncase 16000:\r\nval = 1;\r\nbreak;\r\ncase 32000:\r\nval = 2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (memif->data->id == MTK_AFE_MEMIF_DAI)\r\nregmap_update_bits(afe->regmap, AFE_DAC_CON0,\r\n0x3 << memif->data->fs_shift,\r\nval << memif->data->fs_shift);\r\nelse\r\nregmap_update_bits(afe->regmap, AFE_DAC_CON1,\r\n0x3 << memif->data->fs_shift,\r\nval << memif->data->fs_shift);\r\n} else {\r\nint fs = mtk_afe_i2s_fs(params_rate(params));\r\nif (fs < 0)\r\nreturn -EINVAL;\r\nregmap_update_bits(afe->regmap, AFE_DAC_CON1,\r\n0xf << memif->data->fs_shift,\r\nfs << memif->data->fs_shift);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mtk_afe_dais_hw_free(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int mtk_afe_dais_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nregmap_update_bits(afe->regmap, AFE_DAC_CON0, 0x1, 0x1);\r\nreturn 0;\r\n}\r\nstatic int mtk_afe_dais_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime * const runtime = substream->runtime;\r\nstruct mtk_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mtk_afe_memif *memif = &afe->memif[rtd->cpu_dai->id];\r\nunsigned int counter = runtime->period_size;\r\ndev_info(afe->dev, "%s %s cmd=%d\n", __func__, memif->data->name, cmd);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif (memif->data->enable_shift >= 0)\r\nregmap_update_bits(afe->regmap, AFE_DAC_CON0,\r\n1 << memif->data->enable_shift,\r\n1 << memif->data->enable_shift);\r\nregmap_update_bits(afe->regmap,\r\nmemif->data->irq_reg_cnt,\r\n0x3ffff << memif->data->irq_cnt_shift,\r\ncounter << memif->data->irq_cnt_shift);\r\nif (memif->data->irq_fs_shift >= 0) {\r\nint fs = mtk_afe_i2s_fs(runtime->rate);\r\nif (fs < 0)\r\nreturn -EINVAL;\r\nregmap_update_bits(afe->regmap,\r\nAFE_IRQ_MCU_CON,\r\n0xf << memif->data->irq_fs_shift,\r\nfs << memif->data->irq_fs_shift);\r\n}\r\nregmap_update_bits(afe->regmap, AFE_IRQ_MCU_CON,\r\n1 << memif->data->irq_en_shift,\r\n1 << memif->data->irq_en_shift);\r\nreturn 0;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nif (memif->data->enable_shift >= 0)\r\nregmap_update_bits(afe->regmap, AFE_DAC_CON0,\r\n1 << memif->data->enable_shift, 0);\r\nregmap_update_bits(afe->regmap, AFE_IRQ_MCU_CON,\r\n1 << memif->data->irq_en_shift,\r\n0 << memif->data->irq_en_shift);\r\nregmap_write(afe->regmap, AFE_IRQ_CLR,\r\n1 << memif->data->irq_clr_shift);\r\nmemif->hw_ptr = 0;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int mtk_afe_dai_suspend(struct snd_soc_dai *dai)\r\n{\r\nstruct mtk_afe *afe = snd_soc_dai_get_drvdata(dai);\r\nint i;\r\ndev_dbg(afe->dev, "%s\n", __func__);\r\nif (pm_runtime_status_suspended(afe->dev) || afe->suspended)\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(mtk_afe_backup_list); i++)\r\nregmap_read(afe->regmap, mtk_afe_backup_list[i],\r\n&afe->backup_regs[i]);\r\nafe->suspended = true;\r\nmtk_afe_runtime_suspend(afe->dev);\r\nreturn 0;\r\n}\r\nstatic int mtk_afe_dai_resume(struct snd_soc_dai *dai)\r\n{\r\nstruct mtk_afe *afe = snd_soc_dai_get_drvdata(dai);\r\nint i = 0;\r\ndev_dbg(afe->dev, "%s\n", __func__);\r\nif (pm_runtime_status_suspended(afe->dev) || !afe->suspended)\r\nreturn 0;\r\nmtk_afe_runtime_resume(afe->dev);\r\nfor (i = 0; i < ARRAY_SIZE(mtk_afe_backup_list); i++)\r\nregmap_write(afe->regmap, mtk_afe_backup_list[i],\r\nafe->backup_regs[i]);\r\nafe->suspended = false;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t mtk_afe_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct mtk_afe *afe = dev_id;\r\nunsigned int reg_value, hw_ptr;\r\nint i, ret;\r\nret = regmap_read(afe->regmap, AFE_IRQ_STATUS, &reg_value);\r\nif (ret) {\r\ndev_err(afe->dev, "%s irq status err\n", __func__);\r\nreg_value = AFE_IRQ_STATUS_BITS;\r\ngoto err_irq;\r\n}\r\nfor (i = 0; i < MTK_AFE_MEMIF_NUM; i++) {\r\nstruct mtk_afe_memif *memif = &afe->memif[i];\r\nif (!(reg_value & (1 << memif->data->irq_clr_shift)))\r\ncontinue;\r\nret = regmap_read(afe->regmap, memif->data->reg_ofs_cur,\r\n&hw_ptr);\r\nif (ret || hw_ptr == 0) {\r\ndev_err(afe->dev, "%s hw_ptr err\n", __func__);\r\nhw_ptr = memif->phys_buf_addr;\r\n}\r\nmemif->hw_ptr = hw_ptr - memif->phys_buf_addr;\r\nsnd_pcm_period_elapsed(memif->substream);\r\n}\r\nerr_irq:\r\nregmap_write(afe->regmap, AFE_IRQ_CLR, reg_value & AFE_IRQ_STATUS_BITS);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mtk_afe_runtime_suspend(struct device *dev)\r\n{\r\nstruct mtk_afe *afe = dev_get_drvdata(dev);\r\nregmap_update_bits(afe->regmap, AUDIO_TOP_CON0,\r\nAUD_TCON0_PDN_AFE, AUD_TCON0_PDN_AFE);\r\nclk_disable_unprepare(afe->clocks[MTK_CLK_BCK0]);\r\nclk_disable_unprepare(afe->clocks[MTK_CLK_BCK1]);\r\nclk_disable_unprepare(afe->clocks[MTK_CLK_TOP_PDN_AUD]);\r\nclk_disable_unprepare(afe->clocks[MTK_CLK_TOP_PDN_AUD_BUS]);\r\nclk_disable_unprepare(afe->clocks[MTK_CLK_INFRASYS_AUD]);\r\nreturn 0;\r\n}\r\nstatic int mtk_afe_runtime_resume(struct device *dev)\r\n{\r\nstruct mtk_afe *afe = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_prepare_enable(afe->clocks[MTK_CLK_INFRASYS_AUD]);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(afe->clocks[MTK_CLK_TOP_PDN_AUD_BUS]);\r\nif (ret)\r\ngoto err_infra;\r\nret = clk_prepare_enable(afe->clocks[MTK_CLK_TOP_PDN_AUD]);\r\nif (ret)\r\ngoto err_top_aud_bus;\r\nret = clk_prepare_enable(afe->clocks[MTK_CLK_BCK0]);\r\nif (ret)\r\ngoto err_top_aud;\r\nret = clk_prepare_enable(afe->clocks[MTK_CLK_BCK1]);\r\nif (ret)\r\ngoto err_bck0;\r\nregmap_update_bits(afe->regmap, AUDIO_TOP_CON0, AUD_TCON0_PDN_AFE, 0);\r\nregmap_update_bits(afe->regmap, AFE_CONN_24BIT,\r\nAFE_CONN_24BIT_O03 | AFE_CONN_24BIT_O04, 0);\r\nregmap_update_bits(afe->regmap, AFE_IRQ_MCU_EN, 0xff, 0xff);\r\nreturn 0;\r\nerr_bck0:\r\nclk_disable_unprepare(afe->clocks[MTK_CLK_BCK0]);\r\nerr_top_aud:\r\nclk_disable_unprepare(afe->clocks[MTK_CLK_TOP_PDN_AUD]);\r\nerr_top_aud_bus:\r\nclk_disable_unprepare(afe->clocks[MTK_CLK_TOP_PDN_AUD_BUS]);\r\nerr_infra:\r\nclk_disable_unprepare(afe->clocks[MTK_CLK_INFRASYS_AUD]);\r\nreturn ret;\r\n}\r\nstatic int mtk_afe_init_audio_clk(struct mtk_afe *afe)\r\n{\r\nsize_t i;\r\nfor (i = 0; i < ARRAY_SIZE(aud_clks); i++) {\r\nafe->clocks[i] = devm_clk_get(afe->dev, aud_clks[i]);\r\nif (IS_ERR(afe->clocks[i])) {\r\ndev_err(afe->dev, "%s devm_clk_get %s fail\n",\r\n__func__, aud_clks[i]);\r\nreturn PTR_ERR(afe->clocks[i]);\r\n}\r\n}\r\nclk_set_rate(afe->clocks[MTK_CLK_BCK0], 22579200);\r\nclk_set_rate(afe->clocks[MTK_CLK_BCK1], 24576000);\r\nreturn 0;\r\n}\r\nstatic int mtk_afe_pcm_dev_probe(struct platform_device *pdev)\r\n{\r\nint ret, i;\r\nunsigned int irq_id;\r\nstruct mtk_afe *afe;\r\nstruct resource *res;\r\nafe = devm_kzalloc(&pdev->dev, sizeof(*afe), GFP_KERNEL);\r\nif (!afe)\r\nreturn -ENOMEM;\r\nafe->dev = &pdev->dev;\r\nirq_id = platform_get_irq(pdev, 0);\r\nif (!irq_id) {\r\ndev_err(afe->dev, "np %s no irq\n", afe->dev->of_node->name);\r\nreturn -ENXIO;\r\n}\r\nret = devm_request_irq(afe->dev, irq_id, mtk_afe_irq_handler,\r\n0, "Afe_ISR_Handle", (void *)afe);\r\nif (ret) {\r\ndev_err(afe->dev, "could not request_irq\n");\r\nreturn ret;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nafe->base_addr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(afe->base_addr))\r\nreturn PTR_ERR(afe->base_addr);\r\nafe->regmap = devm_regmap_init_mmio(&pdev->dev, afe->base_addr,\r\n&mtk_afe_regmap_config);\r\nif (IS_ERR(afe->regmap))\r\nreturn PTR_ERR(afe->regmap);\r\nret = mtk_afe_init_audio_clk(afe);\r\nif (ret) {\r\ndev_err(afe->dev, "mtk_afe_init_audio_clk fail\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < MTK_AFE_MEMIF_NUM; i++)\r\nafe->memif[i].data = &memif_data[i];\r\nplatform_set_drvdata(pdev, afe);\r\npm_runtime_enable(&pdev->dev);\r\nif (!pm_runtime_enabled(&pdev->dev)) {\r\nret = mtk_afe_runtime_resume(&pdev->dev);\r\nif (ret)\r\ngoto err_pm_disable;\r\n}\r\nret = snd_soc_register_platform(&pdev->dev, &mtk_afe_pcm_platform);\r\nif (ret)\r\ngoto err_pm_disable;\r\nret = snd_soc_register_component(&pdev->dev,\r\n&mtk_afe_pcm_dai_component,\r\nmtk_afe_pcm_dais,\r\nARRAY_SIZE(mtk_afe_pcm_dais));\r\nif (ret)\r\ngoto err_platform;\r\nret = snd_soc_register_component(&pdev->dev,\r\n&mtk_afe_hdmi_dai_component,\r\nmtk_afe_hdmi_dais,\r\nARRAY_SIZE(mtk_afe_hdmi_dais));\r\nif (ret)\r\ngoto err_comp;\r\ndev_info(&pdev->dev, "MTK AFE driver initialized.\n");\r\nreturn 0;\r\nerr_comp:\r\nsnd_soc_unregister_component(&pdev->dev);\r\nerr_platform:\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nerr_pm_disable:\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int mtk_afe_pcm_dev_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\nmtk_afe_runtime_suspend(&pdev->dev);\r\nsnd_soc_unregister_component(&pdev->dev);\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nreturn 0;\r\n}
