static void wiimod_keys_in_keys(struct wiimote_data *wdata, const __u8 *keys)\r\n{\r\ninput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_LEFT],\r\n!!(keys[0] & 0x01));\r\ninput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_RIGHT],\r\n!!(keys[0] & 0x02));\r\ninput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_DOWN],\r\n!!(keys[0] & 0x04));\r\ninput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_UP],\r\n!!(keys[0] & 0x08));\r\ninput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_PLUS],\r\n!!(keys[0] & 0x10));\r\ninput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_TWO],\r\n!!(keys[1] & 0x01));\r\ninput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_ONE],\r\n!!(keys[1] & 0x02));\r\ninput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_B],\r\n!!(keys[1] & 0x04));\r\ninput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_A],\r\n!!(keys[1] & 0x08));\r\ninput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_MINUS],\r\n!!(keys[1] & 0x10));\r\ninput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_HOME],\r\n!!(keys[1] & 0x80));\r\ninput_sync(wdata->input);\r\n}\r\nstatic int wiimod_keys_probe(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nunsigned int i;\r\nset_bit(EV_KEY, wdata->input->evbit);\r\nfor (i = 0; i < WIIPROTO_KEY_COUNT; ++i)\r\nset_bit(wiimod_keys_map[i], wdata->input->keybit);\r\nreturn 0;\r\n}\r\nstatic void wiimod_rumble_worker(struct work_struct *work)\r\n{\r\nstruct wiimote_data *wdata = container_of(work, struct wiimote_data,\r\nrumble_worker);\r\nspin_lock_irq(&wdata->state.lock);\r\nwiiproto_req_rumble(wdata, wdata->state.cache_rumble);\r\nspin_unlock_irq(&wdata->state.lock);\r\n}\r\nstatic int wiimod_rumble_play(struct input_dev *dev, void *data,\r\nstruct ff_effect *eff)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\n__u8 value;\r\nif (eff->u.rumble.strong_magnitude || eff->u.rumble.weak_magnitude)\r\nvalue = 1;\r\nelse\r\nvalue = 0;\r\nwdata->state.cache_rumble = value;\r\nschedule_work(&wdata->rumble_worker);\r\nreturn 0;\r\n}\r\nstatic int wiimod_rumble_probe(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nINIT_WORK(&wdata->rumble_worker, wiimod_rumble_worker);\r\nset_bit(FF_RUMBLE, wdata->input->ffbit);\r\nif (input_ff_create_memless(wdata->input, NULL, wiimod_rumble_play))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void wiimod_rumble_remove(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nunsigned long flags;\r\ncancel_work_sync(&wdata->rumble_worker);\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwiiproto_req_rumble(wdata, 0);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\n}\r\nstatic int wiimod_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct wiimote_data *wdata = power_supply_get_drvdata(psy);\r\nint ret = 0, state;\r\nunsigned long flags;\r\nif (psp == POWER_SUPPLY_PROP_SCOPE) {\r\nval->intval = POWER_SUPPLY_SCOPE_DEVICE;\r\nreturn 0;\r\n} else if (psp != POWER_SUPPLY_PROP_CAPACITY) {\r\nreturn -EINVAL;\r\n}\r\nret = wiimote_cmd_acquire(wdata);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwiimote_cmd_set(wdata, WIIPROTO_REQ_SREQ, 0);\r\nwiiproto_req_status(wdata);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nwiimote_cmd_wait(wdata);\r\nwiimote_cmd_release(wdata);\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nstate = wdata->state.cmd_battery;\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nval->intval = state * 100 / 255;\r\nreturn ret;\r\n}\r\nstatic int wiimod_battery_probe(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nstruct power_supply_config psy_cfg = { .drv_data = wdata, };\r\nint ret;\r\nwdata->battery_desc.properties = wiimod_battery_props;\r\nwdata->battery_desc.num_properties = ARRAY_SIZE(wiimod_battery_props);\r\nwdata->battery_desc.get_property = wiimod_battery_get_property;\r\nwdata->battery_desc.type = POWER_SUPPLY_TYPE_BATTERY;\r\nwdata->battery_desc.use_for_apm = 0;\r\nwdata->battery_desc.name = kasprintf(GFP_KERNEL, "wiimote_battery_%s",\r\nwdata->hdev->uniq);\r\nif (!wdata->battery_desc.name)\r\nreturn -ENOMEM;\r\nwdata->battery = power_supply_register(&wdata->hdev->dev,\r\n&wdata->battery_desc,\r\n&psy_cfg);\r\nif (IS_ERR(wdata->battery)) {\r\nhid_err(wdata->hdev, "cannot register battery device\n");\r\nret = PTR_ERR(wdata->battery);\r\ngoto err_free;\r\n}\r\npower_supply_powers(wdata->battery, &wdata->hdev->dev);\r\nreturn 0;\r\nerr_free:\r\nkfree(wdata->battery_desc.name);\r\nwdata->battery_desc.name = NULL;\r\nreturn ret;\r\n}\r\nstatic void wiimod_battery_remove(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nif (!wdata->battery_desc.name)\r\nreturn;\r\npower_supply_unregister(wdata->battery);\r\nkfree(wdata->battery_desc.name);\r\nwdata->battery_desc.name = NULL;\r\n}\r\nstatic enum led_brightness wiimod_led_get(struct led_classdev *led_dev)\r\n{\r\nstruct wiimote_data *wdata;\r\nstruct device *dev = led_dev->dev->parent;\r\nint i;\r\nunsigned long flags;\r\nbool value = false;\r\nwdata = hid_get_drvdata(container_of(dev, struct hid_device, dev));\r\nfor (i = 0; i < 4; ++i) {\r\nif (wdata->leds[i] == led_dev) {\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nvalue = wdata->state.flags & WIIPROTO_FLAG_LED(i + 1);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nbreak;\r\n}\r\n}\r\nreturn value ? LED_FULL : LED_OFF;\r\n}\r\nstatic void wiimod_led_set(struct led_classdev *led_dev,\r\nenum led_brightness value)\r\n{\r\nstruct wiimote_data *wdata;\r\nstruct device *dev = led_dev->dev->parent;\r\nint i;\r\nunsigned long flags;\r\n__u8 state, flag;\r\nwdata = hid_get_drvdata(container_of(dev, struct hid_device, dev));\r\nfor (i = 0; i < 4; ++i) {\r\nif (wdata->leds[i] == led_dev) {\r\nflag = WIIPROTO_FLAG_LED(i + 1);\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nstate = wdata->state.flags;\r\nif (value == LED_OFF)\r\nwiiproto_req_leds(wdata, state & ~flag);\r\nelse\r\nwiiproto_req_leds(wdata, state | flag);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int wiimod_led_probe(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nstruct device *dev = &wdata->hdev->dev;\r\nsize_t namesz = strlen(dev_name(dev)) + 9;\r\nstruct led_classdev *led;\r\nunsigned long flags;\r\nchar *name;\r\nint ret;\r\nled = kzalloc(sizeof(struct led_classdev) + namesz, GFP_KERNEL);\r\nif (!led)\r\nreturn -ENOMEM;\r\nname = (void*)&led[1];\r\nsnprintf(name, namesz, "%s:blue:p%lu", dev_name(dev), ops->arg);\r\nled->name = name;\r\nled->brightness = 0;\r\nled->max_brightness = 1;\r\nled->brightness_get = wiimod_led_get;\r\nled->brightness_set = wiimod_led_set;\r\nwdata->leds[ops->arg] = led;\r\nret = led_classdev_register(dev, led);\r\nif (ret)\r\ngoto err_free;\r\nif (ops->arg == 0) {\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwiiproto_req_leds(wdata, WIIPROTO_FLAG_LED1);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\n}\r\nreturn 0;\r\nerr_free:\r\nwdata->leds[ops->arg] = NULL;\r\nkfree(led);\r\nreturn ret;\r\n}\r\nstatic void wiimod_led_remove(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nif (!wdata->leds[ops->arg])\r\nreturn;\r\nled_classdev_unregister(wdata->leds[ops->arg]);\r\nkfree(wdata->leds[ops->arg]);\r\nwdata->leds[ops->arg] = NULL;\r\n}\r\nstatic void wiimod_accel_in_accel(struct wiimote_data *wdata,\r\nconst __u8 *accel)\r\n{\r\n__u16 x, y, z;\r\nif (!(wdata->state.flags & WIIPROTO_FLAG_ACCEL))\r\nreturn;\r\nx = accel[2] << 2;\r\ny = accel[3] << 2;\r\nz = accel[4] << 2;\r\nx |= (accel[0] >> 5) & 0x3;\r\ny |= (accel[1] >> 4) & 0x2;\r\nz |= (accel[1] >> 5) & 0x2;\r\ninput_report_abs(wdata->accel, ABS_RX, x - 0x200);\r\ninput_report_abs(wdata->accel, ABS_RY, y - 0x200);\r\ninput_report_abs(wdata->accel, ABS_RZ, z - 0x200);\r\ninput_sync(wdata->accel);\r\n}\r\nstatic int wiimod_accel_open(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwiiproto_req_accel(wdata, true);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void wiimod_accel_close(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwiiproto_req_accel(wdata, false);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\n}\r\nstatic int wiimod_accel_probe(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nint ret;\r\nwdata->accel = input_allocate_device();\r\nif (!wdata->accel)\r\nreturn -ENOMEM;\r\ninput_set_drvdata(wdata->accel, wdata);\r\nwdata->accel->open = wiimod_accel_open;\r\nwdata->accel->close = wiimod_accel_close;\r\nwdata->accel->dev.parent = &wdata->hdev->dev;\r\nwdata->accel->id.bustype = wdata->hdev->bus;\r\nwdata->accel->id.vendor = wdata->hdev->vendor;\r\nwdata->accel->id.product = wdata->hdev->product;\r\nwdata->accel->id.version = wdata->hdev->version;\r\nwdata->accel->name = WIIMOTE_NAME " Accelerometer";\r\nset_bit(EV_ABS, wdata->accel->evbit);\r\nset_bit(ABS_RX, wdata->accel->absbit);\r\nset_bit(ABS_RY, wdata->accel->absbit);\r\nset_bit(ABS_RZ, wdata->accel->absbit);\r\ninput_set_abs_params(wdata->accel, ABS_RX, -500, 500, 2, 4);\r\ninput_set_abs_params(wdata->accel, ABS_RY, -500, 500, 2, 4);\r\ninput_set_abs_params(wdata->accel, ABS_RZ, -500, 500, 2, 4);\r\nret = input_register_device(wdata->accel);\r\nif (ret) {\r\nhid_err(wdata->hdev, "cannot register input device\n");\r\ngoto err_free;\r\n}\r\nreturn 0;\r\nerr_free:\r\ninput_free_device(wdata->accel);\r\nwdata->accel = NULL;\r\nreturn ret;\r\n}\r\nstatic void wiimod_accel_remove(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nif (!wdata->accel)\r\nreturn;\r\ninput_unregister_device(wdata->accel);\r\nwdata->accel = NULL;\r\n}\r\nstatic void wiimod_ir_in_ir(struct wiimote_data *wdata, const __u8 *ir,\r\nbool packed, unsigned int id)\r\n{\r\n__u16 x, y;\r\n__u8 xid, yid;\r\nbool sync = false;\r\nif (!(wdata->state.flags & WIIPROTO_FLAGS_IR))\r\nreturn;\r\nswitch (id) {\r\ncase 0:\r\nxid = ABS_HAT0X;\r\nyid = ABS_HAT0Y;\r\nbreak;\r\ncase 1:\r\nxid = ABS_HAT1X;\r\nyid = ABS_HAT1Y;\r\nbreak;\r\ncase 2:\r\nxid = ABS_HAT2X;\r\nyid = ABS_HAT2Y;\r\nbreak;\r\ncase 3:\r\nxid = ABS_HAT3X;\r\nyid = ABS_HAT3Y;\r\nsync = true;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (packed) {\r\nx = ir[1] | ((ir[0] & 0x03) << 8);\r\ny = ir[2] | ((ir[0] & 0x0c) << 6);\r\n} else {\r\nx = ir[0] | ((ir[2] & 0x30) << 4);\r\ny = ir[1] | ((ir[2] & 0xc0) << 2);\r\n}\r\ninput_report_abs(wdata->ir, xid, x);\r\ninput_report_abs(wdata->ir, yid, y);\r\nif (sync)\r\ninput_sync(wdata->ir);\r\n}\r\nstatic int wiimod_ir_change(struct wiimote_data *wdata, __u16 mode)\r\n{\r\nint ret;\r\nunsigned long flags;\r\n__u8 format = 0;\r\nstatic const __u8 data_enable[] = { 0x01 };\r\nstatic const __u8 data_sens1[] = { 0x02, 0x00, 0x00, 0x71, 0x01,\r\n0x00, 0xaa, 0x00, 0x64 };\r\nstatic const __u8 data_sens2[] = { 0x63, 0x03 };\r\nstatic const __u8 data_fin[] = { 0x08 };\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nif (mode == (wdata->state.flags & WIIPROTO_FLAGS_IR)) {\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nreturn 0;\r\n}\r\nif (mode == 0) {\r\nwdata->state.flags &= ~WIIPROTO_FLAGS_IR;\r\nwiiproto_req_ir1(wdata, 0);\r\nwiiproto_req_ir2(wdata, 0);\r\nwiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nret = wiimote_cmd_acquire(wdata);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwiimote_cmd_set(wdata, WIIPROTO_REQ_IR1, 0);\r\nwiiproto_req_ir1(wdata, 0x06);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nret = wiimote_cmd_wait(wdata);\r\nif (ret)\r\ngoto unlock;\r\nif (wdata->state.cmd_err) {\r\nret = -EIO;\r\ngoto unlock;\r\n}\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwiimote_cmd_set(wdata, WIIPROTO_REQ_IR2, 0);\r\nwiiproto_req_ir2(wdata, 0x06);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nret = wiimote_cmd_wait(wdata);\r\nif (ret)\r\ngoto unlock;\r\nif (wdata->state.cmd_err) {\r\nret = -EIO;\r\ngoto unlock;\r\n}\r\nret = wiimote_cmd_write(wdata, 0xb00030, data_enable,\r\nsizeof(data_enable));\r\nif (ret)\r\ngoto unlock;\r\nret = wiimote_cmd_write(wdata, 0xb00000, data_sens1,\r\nsizeof(data_sens1));\r\nif (ret)\r\ngoto unlock;\r\nret = wiimote_cmd_write(wdata, 0xb0001a, data_sens2,\r\nsizeof(data_sens2));\r\nif (ret)\r\ngoto unlock;\r\nswitch (mode) {\r\ncase WIIPROTO_FLAG_IR_FULL:\r\nformat = 5;\r\nbreak;\r\ncase WIIPROTO_FLAG_IR_EXT:\r\nformat = 3;\r\nbreak;\r\ncase WIIPROTO_FLAG_IR_BASIC:\r\nformat = 1;\r\nbreak;\r\n}\r\nret = wiimote_cmd_write(wdata, 0xb00033, &format, sizeof(format));\r\nif (ret)\r\ngoto unlock;\r\nret = wiimote_cmd_write(wdata, 0xb00030, data_fin, sizeof(data_fin));\r\nif (ret)\r\ngoto unlock;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.flags &= ~WIIPROTO_FLAGS_IR;\r\nwdata->state.flags |= mode & WIIPROTO_FLAGS_IR;\r\nwiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nunlock:\r\nwiimote_cmd_release(wdata);\r\nreturn ret;\r\n}\r\nstatic int wiimod_ir_open(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nreturn wiimod_ir_change(wdata, WIIPROTO_FLAG_IR_BASIC);\r\n}\r\nstatic void wiimod_ir_close(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nwiimod_ir_change(wdata, 0);\r\n}\r\nstatic int wiimod_ir_probe(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nint ret;\r\nwdata->ir = input_allocate_device();\r\nif (!wdata->ir)\r\nreturn -ENOMEM;\r\ninput_set_drvdata(wdata->ir, wdata);\r\nwdata->ir->open = wiimod_ir_open;\r\nwdata->ir->close = wiimod_ir_close;\r\nwdata->ir->dev.parent = &wdata->hdev->dev;\r\nwdata->ir->id.bustype = wdata->hdev->bus;\r\nwdata->ir->id.vendor = wdata->hdev->vendor;\r\nwdata->ir->id.product = wdata->hdev->product;\r\nwdata->ir->id.version = wdata->hdev->version;\r\nwdata->ir->name = WIIMOTE_NAME " IR";\r\nset_bit(EV_ABS, wdata->ir->evbit);\r\nset_bit(ABS_HAT0X, wdata->ir->absbit);\r\nset_bit(ABS_HAT0Y, wdata->ir->absbit);\r\nset_bit(ABS_HAT1X, wdata->ir->absbit);\r\nset_bit(ABS_HAT1Y, wdata->ir->absbit);\r\nset_bit(ABS_HAT2X, wdata->ir->absbit);\r\nset_bit(ABS_HAT2Y, wdata->ir->absbit);\r\nset_bit(ABS_HAT3X, wdata->ir->absbit);\r\nset_bit(ABS_HAT3Y, wdata->ir->absbit);\r\ninput_set_abs_params(wdata->ir, ABS_HAT0X, 0, 1023, 2, 4);\r\ninput_set_abs_params(wdata->ir, ABS_HAT0Y, 0, 767, 2, 4);\r\ninput_set_abs_params(wdata->ir, ABS_HAT1X, 0, 1023, 2, 4);\r\ninput_set_abs_params(wdata->ir, ABS_HAT1Y, 0, 767, 2, 4);\r\ninput_set_abs_params(wdata->ir, ABS_HAT2X, 0, 1023, 2, 4);\r\ninput_set_abs_params(wdata->ir, ABS_HAT2Y, 0, 767, 2, 4);\r\ninput_set_abs_params(wdata->ir, ABS_HAT3X, 0, 1023, 2, 4);\r\ninput_set_abs_params(wdata->ir, ABS_HAT3Y, 0, 767, 2, 4);\r\nret = input_register_device(wdata->ir);\r\nif (ret) {\r\nhid_err(wdata->hdev, "cannot register input device\n");\r\ngoto err_free;\r\n}\r\nreturn 0;\r\nerr_free:\r\ninput_free_device(wdata->ir);\r\nwdata->ir = NULL;\r\nreturn ret;\r\n}\r\nstatic void wiimod_ir_remove(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nif (!wdata->ir)\r\nreturn;\r\ninput_unregister_device(wdata->ir);\r\nwdata->ir = NULL;\r\n}\r\nstatic void wiimod_nunchuk_in_ext(struct wiimote_data *wdata, const __u8 *ext)\r\n{\r\n__s16 x, y, z, bx, by;\r\nbx = ext[0];\r\nby = ext[1];\r\nbx -= 128;\r\nby -= 128;\r\nx = ext[2] << 2;\r\ny = ext[3] << 2;\r\nz = ext[4] << 2;\r\nif (wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE) {\r\nx |= (ext[5] >> 3) & 0x02;\r\ny |= (ext[5] >> 4) & 0x02;\r\nz &= ~0x4;\r\nz |= (ext[5] >> 5) & 0x06;\r\n} else {\r\nx |= (ext[5] >> 2) & 0x03;\r\ny |= (ext[5] >> 4) & 0x03;\r\nz |= (ext[5] >> 6) & 0x03;\r\n}\r\nx -= 0x200;\r\ny -= 0x200;\r\nz -= 0x200;\r\ninput_report_abs(wdata->extension.input, ABS_HAT0X, bx);\r\ninput_report_abs(wdata->extension.input, ABS_HAT0Y, by);\r\ninput_report_abs(wdata->extension.input, ABS_RX, x);\r\ninput_report_abs(wdata->extension.input, ABS_RY, y);\r\ninput_report_abs(wdata->extension.input, ABS_RZ, z);\r\nif (wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE) {\r\ninput_report_key(wdata->extension.input,\r\nwiimod_nunchuk_map[WIIMOD_NUNCHUK_KEY_Z],\r\n!(ext[5] & 0x04));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_nunchuk_map[WIIMOD_NUNCHUK_KEY_C],\r\n!(ext[5] & 0x08));\r\n} else {\r\ninput_report_key(wdata->extension.input,\r\nwiimod_nunchuk_map[WIIMOD_NUNCHUK_KEY_Z],\r\n!(ext[5] & 0x01));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_nunchuk_map[WIIMOD_NUNCHUK_KEY_C],\r\n!(ext[5] & 0x02));\r\n}\r\ninput_sync(wdata->extension.input);\r\n}\r\nstatic int wiimod_nunchuk_open(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.flags |= WIIPROTO_FLAG_EXT_USED;\r\nwiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void wiimod_nunchuk_close(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.flags &= ~WIIPROTO_FLAG_EXT_USED;\r\nwiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\n}\r\nstatic int wiimod_nunchuk_probe(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nint ret, i;\r\nwdata->extension.input = input_allocate_device();\r\nif (!wdata->extension.input)\r\nreturn -ENOMEM;\r\ninput_set_drvdata(wdata->extension.input, wdata);\r\nwdata->extension.input->open = wiimod_nunchuk_open;\r\nwdata->extension.input->close = wiimod_nunchuk_close;\r\nwdata->extension.input->dev.parent = &wdata->hdev->dev;\r\nwdata->extension.input->id.bustype = wdata->hdev->bus;\r\nwdata->extension.input->id.vendor = wdata->hdev->vendor;\r\nwdata->extension.input->id.product = wdata->hdev->product;\r\nwdata->extension.input->id.version = wdata->hdev->version;\r\nwdata->extension.input->name = WIIMOTE_NAME " Nunchuk";\r\nset_bit(EV_KEY, wdata->extension.input->evbit);\r\nfor (i = 0; i < WIIMOD_NUNCHUK_KEY_NUM; ++i)\r\nset_bit(wiimod_nunchuk_map[i],\r\nwdata->extension.input->keybit);\r\nset_bit(EV_ABS, wdata->extension.input->evbit);\r\nset_bit(ABS_HAT0X, wdata->extension.input->absbit);\r\nset_bit(ABS_HAT0Y, wdata->extension.input->absbit);\r\ninput_set_abs_params(wdata->extension.input,\r\nABS_HAT0X, -120, 120, 2, 4);\r\ninput_set_abs_params(wdata->extension.input,\r\nABS_HAT0Y, -120, 120, 2, 4);\r\nset_bit(ABS_RX, wdata->extension.input->absbit);\r\nset_bit(ABS_RY, wdata->extension.input->absbit);\r\nset_bit(ABS_RZ, wdata->extension.input->absbit);\r\ninput_set_abs_params(wdata->extension.input,\r\nABS_RX, -500, 500, 2, 4);\r\ninput_set_abs_params(wdata->extension.input,\r\nABS_RY, -500, 500, 2, 4);\r\ninput_set_abs_params(wdata->extension.input,\r\nABS_RZ, -500, 500, 2, 4);\r\nret = input_register_device(wdata->extension.input);\r\nif (ret)\r\ngoto err_free;\r\nreturn 0;\r\nerr_free:\r\ninput_free_device(wdata->extension.input);\r\nwdata->extension.input = NULL;\r\nreturn ret;\r\n}\r\nstatic void wiimod_nunchuk_remove(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nif (!wdata->extension.input)\r\nreturn;\r\ninput_unregister_device(wdata->extension.input);\r\nwdata->extension.input = NULL;\r\n}\r\nstatic void wiimod_classic_in_ext(struct wiimote_data *wdata, const __u8 *ext)\r\n{\r\n__s8 rx, ry, lx, ly, lt, rt;\r\nif (wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE) {\r\nlx = ext[0] & 0x3e;\r\nly = ext[1] & 0x3e;\r\n} else {\r\nlx = ext[0] & 0x3f;\r\nly = ext[1] & 0x3f;\r\n}\r\nrx = (ext[0] >> 3) & 0x18;\r\nrx |= (ext[1] >> 5) & 0x06;\r\nrx |= (ext[2] >> 7) & 0x01;\r\nry = ext[2] & 0x1f;\r\nrt = ext[3] & 0x1f;\r\nlt = (ext[2] >> 2) & 0x18;\r\nlt |= (ext[3] >> 5) & 0x07;\r\nrx <<= 1;\r\nry <<= 1;\r\nrt <<= 1;\r\nlt <<= 1;\r\ninput_report_abs(wdata->extension.input, ABS_HAT1X, lx - 0x20);\r\ninput_report_abs(wdata->extension.input, ABS_HAT1Y, ly - 0x20);\r\ninput_report_abs(wdata->extension.input, ABS_HAT2X, rx - 0x20);\r\ninput_report_abs(wdata->extension.input, ABS_HAT2Y, ry - 0x20);\r\ninput_report_abs(wdata->extension.input, ABS_HAT3X, rt);\r\ninput_report_abs(wdata->extension.input, ABS_HAT3Y, lt);\r\ninput_report_key(wdata->extension.input,\r\nwiimod_classic_map[WIIMOD_CLASSIC_KEY_RIGHT],\r\n!(ext[4] & 0x80));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_classic_map[WIIMOD_CLASSIC_KEY_DOWN],\r\n!(ext[4] & 0x40));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_classic_map[WIIMOD_CLASSIC_KEY_LT],\r\n!(ext[4] & 0x20));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_classic_map[WIIMOD_CLASSIC_KEY_MINUS],\r\n!(ext[4] & 0x10));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_classic_map[WIIMOD_CLASSIC_KEY_HOME],\r\n!(ext[4] & 0x08));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_classic_map[WIIMOD_CLASSIC_KEY_PLUS],\r\n!(ext[4] & 0x04));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_classic_map[WIIMOD_CLASSIC_KEY_RT],\r\n!(ext[4] & 0x02));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_classic_map[WIIMOD_CLASSIC_KEY_ZL],\r\n!(ext[5] & 0x80));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_classic_map[WIIMOD_CLASSIC_KEY_B],\r\n!(ext[5] & 0x40));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_classic_map[WIIMOD_CLASSIC_KEY_Y],\r\n!(ext[5] & 0x20));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_classic_map[WIIMOD_CLASSIC_KEY_A],\r\n!(ext[5] & 0x10));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_classic_map[WIIMOD_CLASSIC_KEY_X],\r\n!(ext[5] & 0x08));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_classic_map[WIIMOD_CLASSIC_KEY_ZR],\r\n!(ext[5] & 0x04));\r\nif (wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE) {\r\ninput_report_key(wdata->extension.input,\r\nwiimod_classic_map[WIIMOD_CLASSIC_KEY_LEFT],\r\n!(ext[1] & 0x01));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_classic_map[WIIMOD_CLASSIC_KEY_UP],\r\n!(ext[0] & 0x01));\r\n} else {\r\ninput_report_key(wdata->extension.input,\r\nwiimod_classic_map[WIIMOD_CLASSIC_KEY_LEFT],\r\n!(ext[5] & 0x02));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_classic_map[WIIMOD_CLASSIC_KEY_UP],\r\n!(ext[5] & 0x01));\r\n}\r\ninput_sync(wdata->extension.input);\r\n}\r\nstatic int wiimod_classic_open(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.flags |= WIIPROTO_FLAG_EXT_USED;\r\nwiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void wiimod_classic_close(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.flags &= ~WIIPROTO_FLAG_EXT_USED;\r\nwiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\n}\r\nstatic int wiimod_classic_probe(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nint ret, i;\r\nwdata->extension.input = input_allocate_device();\r\nif (!wdata->extension.input)\r\nreturn -ENOMEM;\r\ninput_set_drvdata(wdata->extension.input, wdata);\r\nwdata->extension.input->open = wiimod_classic_open;\r\nwdata->extension.input->close = wiimod_classic_close;\r\nwdata->extension.input->dev.parent = &wdata->hdev->dev;\r\nwdata->extension.input->id.bustype = wdata->hdev->bus;\r\nwdata->extension.input->id.vendor = wdata->hdev->vendor;\r\nwdata->extension.input->id.product = wdata->hdev->product;\r\nwdata->extension.input->id.version = wdata->hdev->version;\r\nwdata->extension.input->name = WIIMOTE_NAME " Classic Controller";\r\nset_bit(EV_KEY, wdata->extension.input->evbit);\r\nfor (i = 0; i < WIIMOD_CLASSIC_KEY_NUM; ++i)\r\nset_bit(wiimod_classic_map[i],\r\nwdata->extension.input->keybit);\r\nset_bit(EV_ABS, wdata->extension.input->evbit);\r\nset_bit(ABS_HAT1X, wdata->extension.input->absbit);\r\nset_bit(ABS_HAT1Y, wdata->extension.input->absbit);\r\nset_bit(ABS_HAT2X, wdata->extension.input->absbit);\r\nset_bit(ABS_HAT2Y, wdata->extension.input->absbit);\r\nset_bit(ABS_HAT3X, wdata->extension.input->absbit);\r\nset_bit(ABS_HAT3Y, wdata->extension.input->absbit);\r\ninput_set_abs_params(wdata->extension.input,\r\nABS_HAT1X, -30, 30, 1, 1);\r\ninput_set_abs_params(wdata->extension.input,\r\nABS_HAT1Y, -30, 30, 1, 1);\r\ninput_set_abs_params(wdata->extension.input,\r\nABS_HAT2X, -30, 30, 1, 1);\r\ninput_set_abs_params(wdata->extension.input,\r\nABS_HAT2Y, -30, 30, 1, 1);\r\ninput_set_abs_params(wdata->extension.input,\r\nABS_HAT3X, -30, 30, 1, 1);\r\ninput_set_abs_params(wdata->extension.input,\r\nABS_HAT3Y, -30, 30, 1, 1);\r\nret = input_register_device(wdata->extension.input);\r\nif (ret)\r\ngoto err_free;\r\nreturn 0;\r\nerr_free:\r\ninput_free_device(wdata->extension.input);\r\nwdata->extension.input = NULL;\r\nreturn ret;\r\n}\r\nstatic void wiimod_classic_remove(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nif (!wdata->extension.input)\r\nreturn;\r\ninput_unregister_device(wdata->extension.input);\r\nwdata->extension.input = NULL;\r\n}\r\nstatic void wiimod_bboard_in_keys(struct wiimote_data *wdata, const __u8 *keys)\r\n{\r\ninput_report_key(wdata->extension.input, BTN_A,\r\n!!(keys[1] & 0x08));\r\ninput_sync(wdata->extension.input);\r\n}\r\nstatic void wiimod_bboard_in_ext(struct wiimote_data *wdata,\r\nconst __u8 *ext)\r\n{\r\n__s32 val[4], tmp, div;\r\nunsigned int i;\r\nstruct wiimote_state *s = &wdata->state;\r\nval[0] = ext[0];\r\nval[0] <<= 8;\r\nval[0] |= ext[1];\r\nval[1] = ext[2];\r\nval[1] <<= 8;\r\nval[1] |= ext[3];\r\nval[2] = ext[4];\r\nval[2] <<= 8;\r\nval[2] |= ext[5];\r\nval[3] = ext[6];\r\nval[3] <<= 8;\r\nval[3] |= ext[7];\r\nfor (i = 0; i < 4; i++) {\r\nif (val[i] <= s->calib_bboard[i][0]) {\r\ntmp = 0;\r\n} else if (val[i] < s->calib_bboard[i][1]) {\r\ntmp = val[i] - s->calib_bboard[i][0];\r\ntmp *= 1700;\r\ndiv = s->calib_bboard[i][1] - s->calib_bboard[i][0];\r\ntmp /= div ? div : 1;\r\n} else {\r\ntmp = val[i] - s->calib_bboard[i][1];\r\ntmp *= 1700;\r\ndiv = s->calib_bboard[i][2] - s->calib_bboard[i][1];\r\ntmp /= div ? div : 1;\r\ntmp += 1700;\r\n}\r\nval[i] = tmp;\r\n}\r\ninput_report_abs(wdata->extension.input, ABS_HAT0X, val[0]);\r\ninput_report_abs(wdata->extension.input, ABS_HAT0Y, val[1]);\r\ninput_report_abs(wdata->extension.input, ABS_HAT1X, val[2]);\r\ninput_report_abs(wdata->extension.input, ABS_HAT1Y, val[3]);\r\ninput_sync(wdata->extension.input);\r\n}\r\nstatic int wiimod_bboard_open(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.flags |= WIIPROTO_FLAG_EXT_USED;\r\nwiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void wiimod_bboard_close(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.flags &= ~WIIPROTO_FLAG_EXT_USED;\r\nwiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\n}\r\nstatic ssize_t wiimod_bboard_calib_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *out)\r\n{\r\nstruct wiimote_data *wdata = dev_to_wii(dev);\r\nint i, j, ret;\r\n__u16 val;\r\n__u8 buf[24], offs;\r\nret = wiimote_cmd_acquire(wdata);\r\nif (ret)\r\nreturn ret;\r\nret = wiimote_cmd_read(wdata, 0xa40024, buf, 12);\r\nif (ret != 12) {\r\nwiimote_cmd_release(wdata);\r\nreturn ret < 0 ? ret : -EIO;\r\n}\r\nret = wiimote_cmd_read(wdata, 0xa40024 + 12, buf + 12, 12);\r\nif (ret != 12) {\r\nwiimote_cmd_release(wdata);\r\nreturn ret < 0 ? ret : -EIO;\r\n}\r\nwiimote_cmd_release(wdata);\r\nspin_lock_irq(&wdata->state.lock);\r\noffs = 0;\r\nfor (i = 0; i < 3; ++i) {\r\nfor (j = 0; j < 4; ++j) {\r\nwdata->state.calib_bboard[j][i] = buf[offs];\r\nwdata->state.calib_bboard[j][i] <<= 8;\r\nwdata->state.calib_bboard[j][i] |= buf[offs + 1];\r\noffs += 2;\r\n}\r\n}\r\nspin_unlock_irq(&wdata->state.lock);\r\nret = 0;\r\nfor (i = 0; i < 3; ++i) {\r\nfor (j = 0; j < 4; ++j) {\r\nval = wdata->state.calib_bboard[j][i];\r\nif (i == 2 && j == 3)\r\nret += sprintf(&out[ret], "%04x\n", val);\r\nelse\r\nret += sprintf(&out[ret], "%04x:", val);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int wiimod_bboard_probe(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nint ret, i, j;\r\n__u8 buf[24], offs;\r\nwiimote_cmd_acquire_noint(wdata);\r\nret = wiimote_cmd_read(wdata, 0xa40024, buf, 12);\r\nif (ret != 12) {\r\nwiimote_cmd_release(wdata);\r\nreturn ret < 0 ? ret : -EIO;\r\n}\r\nret = wiimote_cmd_read(wdata, 0xa40024 + 12, buf + 12, 12);\r\nif (ret != 12) {\r\nwiimote_cmd_release(wdata);\r\nreturn ret < 0 ? ret : -EIO;\r\n}\r\nwiimote_cmd_release(wdata);\r\noffs = 0;\r\nfor (i = 0; i < 3; ++i) {\r\nfor (j = 0; j < 4; ++j) {\r\nwdata->state.calib_bboard[j][i] = buf[offs];\r\nwdata->state.calib_bboard[j][i] <<= 8;\r\nwdata->state.calib_bboard[j][i] |= buf[offs + 1];\r\noffs += 2;\r\n}\r\n}\r\nwdata->extension.input = input_allocate_device();\r\nif (!wdata->extension.input)\r\nreturn -ENOMEM;\r\nret = device_create_file(&wdata->hdev->dev,\r\n&dev_attr_bboard_calib);\r\nif (ret) {\r\nhid_err(wdata->hdev, "cannot create sysfs attribute\n");\r\ngoto err_free;\r\n}\r\ninput_set_drvdata(wdata->extension.input, wdata);\r\nwdata->extension.input->open = wiimod_bboard_open;\r\nwdata->extension.input->close = wiimod_bboard_close;\r\nwdata->extension.input->dev.parent = &wdata->hdev->dev;\r\nwdata->extension.input->id.bustype = wdata->hdev->bus;\r\nwdata->extension.input->id.vendor = wdata->hdev->vendor;\r\nwdata->extension.input->id.product = wdata->hdev->product;\r\nwdata->extension.input->id.version = wdata->hdev->version;\r\nwdata->extension.input->name = WIIMOTE_NAME " Balance Board";\r\nset_bit(EV_KEY, wdata->extension.input->evbit);\r\nset_bit(BTN_A, wdata->extension.input->keybit);\r\nset_bit(EV_ABS, wdata->extension.input->evbit);\r\nset_bit(ABS_HAT0X, wdata->extension.input->absbit);\r\nset_bit(ABS_HAT0Y, wdata->extension.input->absbit);\r\nset_bit(ABS_HAT1X, wdata->extension.input->absbit);\r\nset_bit(ABS_HAT1Y, wdata->extension.input->absbit);\r\ninput_set_abs_params(wdata->extension.input,\r\nABS_HAT0X, 0, 65535, 2, 4);\r\ninput_set_abs_params(wdata->extension.input,\r\nABS_HAT0Y, 0, 65535, 2, 4);\r\ninput_set_abs_params(wdata->extension.input,\r\nABS_HAT1X, 0, 65535, 2, 4);\r\ninput_set_abs_params(wdata->extension.input,\r\nABS_HAT1Y, 0, 65535, 2, 4);\r\nret = input_register_device(wdata->extension.input);\r\nif (ret)\r\ngoto err_file;\r\nreturn 0;\r\nerr_file:\r\ndevice_remove_file(&wdata->hdev->dev,\r\n&dev_attr_bboard_calib);\r\nerr_free:\r\ninput_free_device(wdata->extension.input);\r\nwdata->extension.input = NULL;\r\nreturn ret;\r\n}\r\nstatic void wiimod_bboard_remove(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nif (!wdata->extension.input)\r\nreturn;\r\ninput_unregister_device(wdata->extension.input);\r\nwdata->extension.input = NULL;\r\ndevice_remove_file(&wdata->hdev->dev,\r\n&dev_attr_bboard_calib);\r\n}\r\nstatic void wiimod_pro_in_ext(struct wiimote_data *wdata, const __u8 *ext)\r\n{\r\n__s16 rx, ry, lx, ly;\r\nlx = (ext[0] & 0xff) | ((ext[1] & 0x0f) << 8);\r\nrx = (ext[2] & 0xff) | ((ext[3] & 0x0f) << 8);\r\nly = (ext[4] & 0xff) | ((ext[5] & 0x0f) << 8);\r\nry = (ext[6] & 0xff) | ((ext[7] & 0x0f) << 8);\r\nlx -= 0x800;\r\nly = 0x800 - ly;\r\nrx -= 0x800;\r\nry = 0x800 - ry;\r\nif (!(wdata->state.flags & WIIPROTO_FLAG_PRO_CALIB_DONE)) {\r\nwdata->state.flags |= WIIPROTO_FLAG_PRO_CALIB_DONE;\r\nif (abs(lx) < 500)\r\nwdata->state.calib_pro_sticks[0] = -lx;\r\nif (abs(ly) < 500)\r\nwdata->state.calib_pro_sticks[1] = -ly;\r\nif (abs(rx) < 500)\r\nwdata->state.calib_pro_sticks[2] = -rx;\r\nif (abs(ry) < 500)\r\nwdata->state.calib_pro_sticks[3] = -ry;\r\n}\r\nlx += wdata->state.calib_pro_sticks[0];\r\nly += wdata->state.calib_pro_sticks[1];\r\nrx += wdata->state.calib_pro_sticks[2];\r\nry += wdata->state.calib_pro_sticks[3];\r\ninput_report_abs(wdata->extension.input, ABS_X, lx);\r\ninput_report_abs(wdata->extension.input, ABS_Y, ly);\r\ninput_report_abs(wdata->extension.input, ABS_RX, rx);\r\ninput_report_abs(wdata->extension.input, ABS_RY, ry);\r\ninput_report_key(wdata->extension.input,\r\nwiimod_pro_map[WIIMOD_PRO_KEY_RIGHT],\r\n!(ext[8] & 0x80));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_pro_map[WIIMOD_PRO_KEY_DOWN],\r\n!(ext[8] & 0x40));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_pro_map[WIIMOD_PRO_KEY_TL],\r\n!(ext[8] & 0x20));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_pro_map[WIIMOD_PRO_KEY_MINUS],\r\n!(ext[8] & 0x10));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_pro_map[WIIMOD_PRO_KEY_HOME],\r\n!(ext[8] & 0x08));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_pro_map[WIIMOD_PRO_KEY_PLUS],\r\n!(ext[8] & 0x04));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_pro_map[WIIMOD_PRO_KEY_TR],\r\n!(ext[8] & 0x02));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_pro_map[WIIMOD_PRO_KEY_ZL],\r\n!(ext[9] & 0x80));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_pro_map[WIIMOD_PRO_KEY_B],\r\n!(ext[9] & 0x40));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_pro_map[WIIMOD_PRO_KEY_Y],\r\n!(ext[9] & 0x20));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_pro_map[WIIMOD_PRO_KEY_A],\r\n!(ext[9] & 0x10));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_pro_map[WIIMOD_PRO_KEY_X],\r\n!(ext[9] & 0x08));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_pro_map[WIIMOD_PRO_KEY_ZR],\r\n!(ext[9] & 0x04));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_pro_map[WIIMOD_PRO_KEY_LEFT],\r\n!(ext[9] & 0x02));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_pro_map[WIIMOD_PRO_KEY_UP],\r\n!(ext[9] & 0x01));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_pro_map[WIIMOD_PRO_KEY_THUMBL],\r\n!(ext[10] & 0x02));\r\ninput_report_key(wdata->extension.input,\r\nwiimod_pro_map[WIIMOD_PRO_KEY_THUMBR],\r\n!(ext[10] & 0x01));\r\ninput_sync(wdata->extension.input);\r\n}\r\nstatic int wiimod_pro_open(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.flags |= WIIPROTO_FLAG_EXT_USED;\r\nwiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void wiimod_pro_close(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.flags &= ~WIIPROTO_FLAG_EXT_USED;\r\nwiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\n}\r\nstatic int wiimod_pro_play(struct input_dev *dev, void *data,\r\nstruct ff_effect *eff)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\n__u8 value;\r\nif (eff->u.rumble.strong_magnitude || eff->u.rumble.weak_magnitude)\r\nvalue = 1;\r\nelse\r\nvalue = 0;\r\nwdata->state.cache_rumble = value;\r\nschedule_work(&wdata->rumble_worker);\r\nreturn 0;\r\n}\r\nstatic ssize_t wiimod_pro_calib_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *out)\r\n{\r\nstruct wiimote_data *wdata = dev_to_wii(dev);\r\nint r;\r\nr = 0;\r\nr += sprintf(&out[r], "%+06hd:", wdata->state.calib_pro_sticks[0]);\r\nr += sprintf(&out[r], "%+06hd ", wdata->state.calib_pro_sticks[1]);\r\nr += sprintf(&out[r], "%+06hd:", wdata->state.calib_pro_sticks[2]);\r\nr += sprintf(&out[r], "%+06hd\n", wdata->state.calib_pro_sticks[3]);\r\nreturn r;\r\n}\r\nstatic ssize_t wiimod_pro_calib_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct wiimote_data *wdata = dev_to_wii(dev);\r\nint r;\r\ns16 x1, y1, x2, y2;\r\nif (!strncmp(buf, "scan\n", 5)) {\r\nspin_lock_irq(&wdata->state.lock);\r\nwdata->state.flags &= ~WIIPROTO_FLAG_PRO_CALIB_DONE;\r\nspin_unlock_irq(&wdata->state.lock);\r\n} else {\r\nr = sscanf(buf, "%hd:%hd %hd:%hd", &x1, &y1, &x2, &y2);\r\nif (r != 4)\r\nreturn -EINVAL;\r\nspin_lock_irq(&wdata->state.lock);\r\nwdata->state.flags |= WIIPROTO_FLAG_PRO_CALIB_DONE;\r\nspin_unlock_irq(&wdata->state.lock);\r\nwdata->state.calib_pro_sticks[0] = x1;\r\nwdata->state.calib_pro_sticks[1] = y1;\r\nwdata->state.calib_pro_sticks[2] = x2;\r\nwdata->state.calib_pro_sticks[3] = y2;\r\n}\r\nreturn strnlen(buf, PAGE_SIZE);\r\n}\r\nstatic int wiimod_pro_probe(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nint ret, i;\r\nunsigned long flags;\r\nINIT_WORK(&wdata->rumble_worker, wiimod_rumble_worker);\r\nwdata->state.calib_pro_sticks[0] = 0;\r\nwdata->state.calib_pro_sticks[1] = 0;\r\nwdata->state.calib_pro_sticks[2] = 0;\r\nwdata->state.calib_pro_sticks[3] = 0;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.flags &= ~WIIPROTO_FLAG_PRO_CALIB_DONE;\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nwdata->extension.input = input_allocate_device();\r\nif (!wdata->extension.input)\r\nreturn -ENOMEM;\r\nset_bit(FF_RUMBLE, wdata->extension.input->ffbit);\r\ninput_set_drvdata(wdata->extension.input, wdata);\r\nif (input_ff_create_memless(wdata->extension.input, NULL,\r\nwiimod_pro_play)) {\r\nret = -ENOMEM;\r\ngoto err_free;\r\n}\r\nret = device_create_file(&wdata->hdev->dev,\r\n&dev_attr_pro_calib);\r\nif (ret) {\r\nhid_err(wdata->hdev, "cannot create sysfs attribute\n");\r\ngoto err_free;\r\n}\r\nwdata->extension.input->open = wiimod_pro_open;\r\nwdata->extension.input->close = wiimod_pro_close;\r\nwdata->extension.input->dev.parent = &wdata->hdev->dev;\r\nwdata->extension.input->id.bustype = wdata->hdev->bus;\r\nwdata->extension.input->id.vendor = wdata->hdev->vendor;\r\nwdata->extension.input->id.product = wdata->hdev->product;\r\nwdata->extension.input->id.version = wdata->hdev->version;\r\nwdata->extension.input->name = WIIMOTE_NAME " Pro Controller";\r\nset_bit(EV_KEY, wdata->extension.input->evbit);\r\nfor (i = 0; i < WIIMOD_PRO_KEY_NUM; ++i)\r\nset_bit(wiimod_pro_map[i],\r\nwdata->extension.input->keybit);\r\nset_bit(EV_ABS, wdata->extension.input->evbit);\r\nset_bit(ABS_X, wdata->extension.input->absbit);\r\nset_bit(ABS_Y, wdata->extension.input->absbit);\r\nset_bit(ABS_RX, wdata->extension.input->absbit);\r\nset_bit(ABS_RY, wdata->extension.input->absbit);\r\ninput_set_abs_params(wdata->extension.input,\r\nABS_X, -0x400, 0x400, 4, 100);\r\ninput_set_abs_params(wdata->extension.input,\r\nABS_Y, -0x400, 0x400, 4, 100);\r\ninput_set_abs_params(wdata->extension.input,\r\nABS_RX, -0x400, 0x400, 4, 100);\r\ninput_set_abs_params(wdata->extension.input,\r\nABS_RY, -0x400, 0x400, 4, 100);\r\nret = input_register_device(wdata->extension.input);\r\nif (ret)\r\ngoto err_file;\r\nreturn 0;\r\nerr_file:\r\ndevice_remove_file(&wdata->hdev->dev,\r\n&dev_attr_pro_calib);\r\nerr_free:\r\ninput_free_device(wdata->extension.input);\r\nwdata->extension.input = NULL;\r\nreturn ret;\r\n}\r\nstatic void wiimod_pro_remove(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nunsigned long flags;\r\nif (!wdata->extension.input)\r\nreturn;\r\ninput_unregister_device(wdata->extension.input);\r\nwdata->extension.input = NULL;\r\ncancel_work_sync(&wdata->rumble_worker);\r\ndevice_remove_file(&wdata->hdev->dev,\r\n&dev_attr_pro_calib);\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwiiproto_req_rumble(wdata, 0);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\n}\r\nstatic int wiimod_builtin_mp_probe(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.flags |= WIIPROTO_FLAG_BUILTIN_MP;\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void wiimod_builtin_mp_remove(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.flags |= WIIPROTO_FLAG_BUILTIN_MP;\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\n}\r\nstatic int wiimod_no_mp_probe(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.flags |= WIIPROTO_FLAG_NO_MP;\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void wiimod_no_mp_remove(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.flags |= WIIPROTO_FLAG_NO_MP;\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\n}\r\nstatic void wiimod_mp_in_mp(struct wiimote_data *wdata, const __u8 *ext)\r\n{\r\n__s32 x, y, z;\r\nx = ext[0];\r\ny = ext[1];\r\nz = ext[2];\r\nx |= (((__u16)ext[3]) << 6) & 0xff00;\r\ny |= (((__u16)ext[4]) << 6) & 0xff00;\r\nz |= (((__u16)ext[5]) << 6) & 0xff00;\r\nx -= 8192;\r\ny -= 8192;\r\nz -= 8192;\r\nif (!(ext[3] & 0x02))\r\nx *= 18;\r\nelse\r\nx *= 9;\r\nif (!(ext[4] & 0x02))\r\ny *= 18;\r\nelse\r\ny *= 9;\r\nif (!(ext[3] & 0x01))\r\nz *= 18;\r\nelse\r\nz *= 9;\r\ninput_report_abs(wdata->mp, ABS_RX, x);\r\ninput_report_abs(wdata->mp, ABS_RY, y);\r\ninput_report_abs(wdata->mp, ABS_RZ, z);\r\ninput_sync(wdata->mp);\r\n}\r\nstatic int wiimod_mp_open(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.flags |= WIIPROTO_FLAG_MP_USED;\r\nwiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\r\n__wiimote_schedule(wdata);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void wiimod_mp_close(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.flags &= ~WIIPROTO_FLAG_MP_USED;\r\nwiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\r\n__wiimote_schedule(wdata);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\n}\r\nstatic int wiimod_mp_probe(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nint ret;\r\nwdata->mp = input_allocate_device();\r\nif (!wdata->mp)\r\nreturn -ENOMEM;\r\ninput_set_drvdata(wdata->mp, wdata);\r\nwdata->mp->open = wiimod_mp_open;\r\nwdata->mp->close = wiimod_mp_close;\r\nwdata->mp->dev.parent = &wdata->hdev->dev;\r\nwdata->mp->id.bustype = wdata->hdev->bus;\r\nwdata->mp->id.vendor = wdata->hdev->vendor;\r\nwdata->mp->id.product = wdata->hdev->product;\r\nwdata->mp->id.version = wdata->hdev->version;\r\nwdata->mp->name = WIIMOTE_NAME " Motion Plus";\r\nset_bit(EV_ABS, wdata->mp->evbit);\r\nset_bit(ABS_RX, wdata->mp->absbit);\r\nset_bit(ABS_RY, wdata->mp->absbit);\r\nset_bit(ABS_RZ, wdata->mp->absbit);\r\ninput_set_abs_params(wdata->mp,\r\nABS_RX, -16000, 16000, 4, 8);\r\ninput_set_abs_params(wdata->mp,\r\nABS_RY, -16000, 16000, 4, 8);\r\ninput_set_abs_params(wdata->mp,\r\nABS_RZ, -16000, 16000, 4, 8);\r\nret = input_register_device(wdata->mp);\r\nif (ret)\r\ngoto err_free;\r\nreturn 0;\r\nerr_free:\r\ninput_free_device(wdata->mp);\r\nwdata->mp = NULL;\r\nreturn ret;\r\n}\r\nstatic void wiimod_mp_remove(const struct wiimod_ops *ops,\r\nstruct wiimote_data *wdata)\r\n{\r\nif (!wdata->mp)\r\nreturn;\r\ninput_unregister_device(wdata->mp);\r\nwdata->mp = NULL;\r\n}
