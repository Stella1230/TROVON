static inline struct grgpio_priv *grgpio_gc_to_priv(struct gpio_chip *gc)\r\n{\r\nstruct bgpio_chip *bgc = to_bgpio_chip(gc);\r\nreturn container_of(bgc, struct grgpio_priv, bgc);\r\n}\r\nstatic void grgpio_set_imask(struct grgpio_priv *priv, unsigned int offset,\r\nint val)\r\n{\r\nstruct bgpio_chip *bgc = &priv->bgc;\r\nunsigned long mask = bgc->pin2mask(bgc, offset);\r\nif (val)\r\npriv->imask |= mask;\r\nelse\r\npriv->imask &= ~mask;\r\nbgc->write_reg(priv->regs + GRGPIO_IMASK, priv->imask);\r\n}\r\nstatic int grgpio_to_irq(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct grgpio_priv *priv = grgpio_gc_to_priv(gc);\r\nif (offset >= gc->ngpio)\r\nreturn -ENXIO;\r\nif (priv->lirqs[offset].index < 0)\r\nreturn -ENXIO;\r\nreturn irq_create_mapping(priv->domain, offset);\r\n}\r\nstatic int grgpio_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct grgpio_priv *priv = irq_data_get_irq_chip_data(d);\r\nunsigned long flags;\r\nu32 mask = BIT(d->hwirq);\r\nu32 ipol;\r\nu32 iedge;\r\nu32 pol;\r\nu32 edge;\r\nswitch (type) {\r\ncase IRQ_TYPE_LEVEL_LOW:\r\npol = 0;\r\nedge = 0;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\npol = mask;\r\nedge = 0;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\npol = 0;\r\nedge = mask;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\npol = mask;\r\nedge = mask;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&priv->bgc.lock, flags);\r\nipol = priv->bgc.read_reg(priv->regs + GRGPIO_IPOL) & ~mask;\r\niedge = priv->bgc.read_reg(priv->regs + GRGPIO_IEDGE) & ~mask;\r\npriv->bgc.write_reg(priv->regs + GRGPIO_IPOL, ipol | pol);\r\npriv->bgc.write_reg(priv->regs + GRGPIO_IEDGE, iedge | edge);\r\nspin_unlock_irqrestore(&priv->bgc.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void grgpio_irq_mask(struct irq_data *d)\r\n{\r\nstruct grgpio_priv *priv = irq_data_get_irq_chip_data(d);\r\nint offset = d->hwirq;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->bgc.lock, flags);\r\ngrgpio_set_imask(priv, offset, 0);\r\nspin_unlock_irqrestore(&priv->bgc.lock, flags);\r\n}\r\nstatic void grgpio_irq_unmask(struct irq_data *d)\r\n{\r\nstruct grgpio_priv *priv = irq_data_get_irq_chip_data(d);\r\nint offset = d->hwirq;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->bgc.lock, flags);\r\ngrgpio_set_imask(priv, offset, 1);\r\nspin_unlock_irqrestore(&priv->bgc.lock, flags);\r\n}\r\nstatic irqreturn_t grgpio_irq_handler(int irq, void *dev)\r\n{\r\nstruct grgpio_priv *priv = dev;\r\nint ngpio = priv->bgc.gc.ngpio;\r\nunsigned long flags;\r\nint i;\r\nint match = 0;\r\nspin_lock_irqsave(&priv->bgc.lock, flags);\r\nfor (i = 0; i < ngpio; i++) {\r\nstruct grgpio_lirq *lirq = &priv->lirqs[i];\r\nif (priv->imask & BIT(i) && lirq->index >= 0 &&\r\npriv->uirqs[lirq->index].uirq == irq) {\r\ngeneric_handle_irq(lirq->irq);\r\nmatch = 1;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->bgc.lock, flags);\r\nif (!match)\r\ndev_warn(priv->dev, "No gpio line matched irq %d\n", irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int grgpio_irq_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct grgpio_priv *priv = d->host_data;\r\nstruct grgpio_lirq *lirq;\r\nstruct grgpio_uirq *uirq;\r\nunsigned long flags;\r\nint offset = hwirq;\r\nint ret = 0;\r\nif (!priv)\r\nreturn -EINVAL;\r\nlirq = &priv->lirqs[offset];\r\nif (lirq->index < 0)\r\nreturn -EINVAL;\r\ndev_dbg(priv->dev, "Mapping irq %d for gpio line %d\n",\r\nirq, offset);\r\nspin_lock_irqsave(&priv->bgc.lock, flags);\r\nlirq->irq = irq;\r\nuirq = &priv->uirqs[lirq->index];\r\nif (uirq->refcnt == 0) {\r\nret = request_irq(uirq->uirq, grgpio_irq_handler, 0,\r\ndev_name(priv->dev), priv);\r\nif (ret) {\r\ndev_err(priv->dev,\r\n"Could not request underlying irq %d\n",\r\nuirq->uirq);\r\nspin_unlock_irqrestore(&priv->bgc.lock, flags);\r\nreturn ret;\r\n}\r\n}\r\nuirq->refcnt++;\r\nspin_unlock_irqrestore(&priv->bgc.lock, flags);\r\nirq_set_chip_data(irq, priv);\r\nirq_set_chip_and_handler(irq, &grgpio_irq_chip,\r\nhandle_simple_irq);\r\nirq_set_noprobe(irq);\r\nreturn ret;\r\n}\r\nstatic void grgpio_irq_unmap(struct irq_domain *d, unsigned int irq)\r\n{\r\nstruct grgpio_priv *priv = d->host_data;\r\nint index;\r\nstruct grgpio_lirq *lirq;\r\nstruct grgpio_uirq *uirq;\r\nunsigned long flags;\r\nint ngpio = priv->bgc.gc.ngpio;\r\nint i;\r\nirq_set_chip_and_handler(irq, NULL, NULL);\r\nirq_set_chip_data(irq, NULL);\r\nspin_lock_irqsave(&priv->bgc.lock, flags);\r\nindex = -1;\r\nfor (i = 0; i < ngpio; i++) {\r\nlirq = &priv->lirqs[i];\r\nif (lirq->irq == irq) {\r\ngrgpio_set_imask(priv, i, 0);\r\nlirq->irq = 0;\r\nindex = lirq->index;\r\nbreak;\r\n}\r\n}\r\nWARN_ON(index < 0);\r\nif (index >= 0) {\r\nuirq = &priv->uirqs[lirq->index];\r\nuirq->refcnt--;\r\nif (uirq->refcnt == 0)\r\nfree_irq(uirq->uirq, priv);\r\n}\r\nspin_unlock_irqrestore(&priv->bgc.lock, flags);\r\n}\r\nstatic int grgpio_probe(struct platform_device *ofdev)\r\n{\r\nstruct device_node *np = ofdev->dev.of_node;\r\nvoid __iomem *regs;\r\nstruct gpio_chip *gc;\r\nstruct bgpio_chip *bgc;\r\nstruct grgpio_priv *priv;\r\nstruct resource *res;\r\nint err;\r\nu32 prop;\r\ns32 *irqmap;\r\nint size;\r\nint i;\r\npriv = devm_kzalloc(&ofdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(ofdev, IORESOURCE_MEM, 0);\r\nregs = devm_ioremap_resource(&ofdev->dev, res);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\nbgc = &priv->bgc;\r\nerr = bgpio_init(bgc, &ofdev->dev, 4, regs + GRGPIO_DATA,\r\nregs + GRGPIO_OUTPUT, NULL, regs + GRGPIO_DIR, NULL,\r\nBGPIOF_BIG_ENDIAN_BYTE_ORDER);\r\nif (err) {\r\ndev_err(&ofdev->dev, "bgpio_init() failed\n");\r\nreturn err;\r\n}\r\npriv->regs = regs;\r\npriv->imask = bgc->read_reg(regs + GRGPIO_IMASK);\r\npriv->dev = &ofdev->dev;\r\ngc = &bgc->gc;\r\ngc->of_node = np;\r\ngc->owner = THIS_MODULE;\r\ngc->to_irq = grgpio_to_irq;\r\ngc->label = np->full_name;\r\ngc->base = -1;\r\nerr = of_property_read_u32(np, "nbits", &prop);\r\nif (err || prop <= 0 || prop > GRGPIO_MAX_NGPIO) {\r\ngc->ngpio = GRGPIO_MAX_NGPIO;\r\ndev_dbg(&ofdev->dev,\r\n"No or invalid nbits property: assume %d\n", gc->ngpio);\r\n} else {\r\ngc->ngpio = prop;\r\n}\r\nirqmap = (s32 *)of_get_property(np, "irqmap", &size);\r\nif (irqmap) {\r\nif (size < gc->ngpio) {\r\ndev_err(&ofdev->dev,\r\n"irqmap shorter than ngpio (%d < %d)\n",\r\nsize, gc->ngpio);\r\nreturn -EINVAL;\r\n}\r\npriv->domain = irq_domain_add_linear(np, gc->ngpio,\r\n&grgpio_irq_domain_ops,\r\npriv);\r\nif (!priv->domain) {\r\ndev_err(&ofdev->dev, "Could not add irq domain\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < gc->ngpio; i++) {\r\nstruct grgpio_lirq *lirq;\r\nint ret;\r\nlirq = &priv->lirqs[i];\r\nlirq->index = irqmap[i];\r\nif (lirq->index < 0)\r\ncontinue;\r\nret = platform_get_irq(ofdev, lirq->index);\r\nif (ret <= 0) {\r\ndev_err(priv->dev,\r\n"Failed to get irq for offset %d\n", i);\r\ncontinue;\r\n}\r\npriv->uirqs[lirq->index].uirq = ret;\r\n}\r\n}\r\nplatform_set_drvdata(ofdev, priv);\r\nerr = gpiochip_add(gc);\r\nif (err) {\r\ndev_err(&ofdev->dev, "Could not add gpiochip\n");\r\nif (priv->domain)\r\nirq_domain_remove(priv->domain);\r\nreturn err;\r\n}\r\ndev_info(&ofdev->dev, "regs=0x%p, base=%d, ngpio=%d, irqs=%s\n",\r\npriv->regs, gc->base, gc->ngpio, priv->domain ? "on" : "off");\r\nreturn 0;\r\n}\r\nstatic int grgpio_remove(struct platform_device *ofdev)\r\n{\r\nstruct grgpio_priv *priv = platform_get_drvdata(ofdev);\r\nunsigned long flags;\r\nint i;\r\nint ret = 0;\r\nspin_lock_irqsave(&priv->bgc.lock, flags);\r\nif (priv->domain) {\r\nfor (i = 0; i < GRGPIO_MAX_NGPIO; i++) {\r\nif (priv->uirqs[i].refcnt != 0) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\n}\r\n}\r\ngpiochip_remove(&priv->bgc.gc);\r\nif (priv->domain)\r\nirq_domain_remove(priv->domain);\r\nout:\r\nspin_unlock_irqrestore(&priv->bgc.lock, flags);\r\nreturn ret;\r\n}
