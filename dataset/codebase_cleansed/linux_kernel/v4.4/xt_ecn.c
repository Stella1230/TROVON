static bool match_tcp(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_ecn_info *einfo = par->matchinfo;\r\nstruct tcphdr _tcph;\r\nconst struct tcphdr *th;\r\nth = skb_header_pointer(skb, par->thoff, sizeof(_tcph), &_tcph);\r\nif (th == NULL)\r\nreturn false;\r\nif (einfo->operation & XT_ECN_OP_MATCH_ECE) {\r\nif (einfo->invert & XT_ECN_OP_MATCH_ECE) {\r\nif (th->ece == 1)\r\nreturn false;\r\n} else {\r\nif (th->ece == 0)\r\nreturn false;\r\n}\r\n}\r\nif (einfo->operation & XT_ECN_OP_MATCH_CWR) {\r\nif (einfo->invert & XT_ECN_OP_MATCH_CWR) {\r\nif (th->cwr == 1)\r\nreturn false;\r\n} else {\r\nif (th->cwr == 0)\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic inline bool match_ip(const struct sk_buff *skb,\r\nconst struct xt_ecn_info *einfo)\r\n{\r\nreturn ((ip_hdr(skb)->tos & XT_ECN_IP_MASK) == einfo->ip_ect) ^\r\n!!(einfo->invert & XT_ECN_OP_MATCH_IP);\r\n}\r\nstatic bool ecn_mt4(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_ecn_info *info = par->matchinfo;\r\nif (info->operation & XT_ECN_OP_MATCH_IP && !match_ip(skb, info))\r\nreturn false;\r\nif (info->operation & (XT_ECN_OP_MATCH_ECE | XT_ECN_OP_MATCH_CWR) &&\r\n!match_tcp(skb, par))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int ecn_mt_check4(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_ecn_info *info = par->matchinfo;\r\nconst struct ipt_ip *ip = par->entryinfo;\r\nif (info->operation & XT_ECN_OP_MATCH_MASK)\r\nreturn -EINVAL;\r\nif (info->invert & XT_ECN_OP_MATCH_MASK)\r\nreturn -EINVAL;\r\nif (info->operation & (XT_ECN_OP_MATCH_ECE | XT_ECN_OP_MATCH_CWR) &&\r\n(ip->proto != IPPROTO_TCP || ip->invflags & IPT_INV_PROTO)) {\r\npr_info("cannot match TCP bits in rule for non-tcp packets\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline bool match_ipv6(const struct sk_buff *skb,\r\nconst struct xt_ecn_info *einfo)\r\n{\r\nreturn (((ipv6_hdr(skb)->flow_lbl[0] >> 4) & XT_ECN_IP_MASK) ==\r\neinfo->ip_ect) ^\r\n!!(einfo->invert & XT_ECN_OP_MATCH_IP);\r\n}\r\nstatic bool ecn_mt6(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_ecn_info *info = par->matchinfo;\r\nif (info->operation & XT_ECN_OP_MATCH_IP && !match_ipv6(skb, info))\r\nreturn false;\r\nif (info->operation & (XT_ECN_OP_MATCH_ECE | XT_ECN_OP_MATCH_CWR) &&\r\n!match_tcp(skb, par))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int ecn_mt_check6(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_ecn_info *info = par->matchinfo;\r\nconst struct ip6t_ip6 *ip = par->entryinfo;\r\nif (info->operation & XT_ECN_OP_MATCH_MASK)\r\nreturn -EINVAL;\r\nif (info->invert & XT_ECN_OP_MATCH_MASK)\r\nreturn -EINVAL;\r\nif (info->operation & (XT_ECN_OP_MATCH_ECE | XT_ECN_OP_MATCH_CWR) &&\r\n(ip->proto != IPPROTO_TCP || ip->invflags & IP6T_INV_PROTO)) {\r\npr_info("cannot match TCP bits in rule for non-tcp packets\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ecn_mt_init(void)\r\n{\r\nreturn xt_register_matches(ecn_mt_reg, ARRAY_SIZE(ecn_mt_reg));\r\n}\r\nstatic void __exit ecn_mt_exit(void)\r\n{\r\nxt_unregister_matches(ecn_mt_reg, ARRAY_SIZE(ecn_mt_reg));\r\n}
