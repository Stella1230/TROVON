static int set_bud_lprops(struct ubifs_info *c, struct bud_entry *b)\r\n{\r\nconst struct ubifs_lprops *lp;\r\nint err = 0, dirty;\r\nubifs_get_lprops(c);\r\nlp = ubifs_lpt_lookup_dirty(c, b->bud->lnum);\r\nif (IS_ERR(lp)) {\r\nerr = PTR_ERR(lp);\r\ngoto out;\r\n}\r\ndirty = lp->dirty;\r\nif (b->bud->start == 0 && (lp->free != c->leb_size || lp->dirty != 0)) {\r\ndbg_mnt("bud LEB %d was GC'd (%d free, %d dirty)", b->bud->lnum,\r\nlp->free, lp->dirty);\r\ndbg_gc("bud LEB %d was GC'd (%d free, %d dirty)", b->bud->lnum,\r\nlp->free, lp->dirty);\r\ndirty -= c->leb_size - lp->free;\r\nif (dirty != 0)\r\ndbg_mnt("LEB %d lp: %d free %d dirty replay: %d free %d dirty",\r\nb->bud->lnum, lp->free, lp->dirty, b->free,\r\nb->dirty);\r\n}\r\nlp = ubifs_change_lp(c, lp, b->free, dirty + b->dirty,\r\nlp->flags | LPROPS_TAKEN, 0);\r\nif (IS_ERR(lp)) {\r\nerr = PTR_ERR(lp);\r\ngoto out;\r\n}\r\nerr = ubifs_wbuf_seek_nolock(&c->jheads[b->bud->jhead].wbuf,\r\nb->bud->lnum, c->leb_size - b->free);\r\nout:\r\nubifs_release_lprops(c);\r\nreturn err;\r\n}\r\nstatic int set_buds_lprops(struct ubifs_info *c)\r\n{\r\nstruct bud_entry *b;\r\nint err;\r\nlist_for_each_entry(b, &c->replay_buds, list) {\r\nerr = set_bud_lprops(c, b);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int trun_remove_range(struct ubifs_info *c, struct replay_entry *r)\r\n{\r\nunsigned min_blk, max_blk;\r\nunion ubifs_key min_key, max_key;\r\nino_t ino;\r\nmin_blk = r->new_size / UBIFS_BLOCK_SIZE;\r\nif (r->new_size & (UBIFS_BLOCK_SIZE - 1))\r\nmin_blk += 1;\r\nmax_blk = r->old_size / UBIFS_BLOCK_SIZE;\r\nif ((r->old_size & (UBIFS_BLOCK_SIZE - 1)) == 0)\r\nmax_blk -= 1;\r\nino = key_inum(c, &r->key);\r\ndata_key_init(c, &min_key, ino, min_blk);\r\ndata_key_init(c, &max_key, ino, max_blk);\r\nreturn ubifs_tnc_remove_range(c, &min_key, &max_key);\r\n}\r\nstatic int apply_replay_entry(struct ubifs_info *c, struct replay_entry *r)\r\n{\r\nint err;\r\ndbg_mntk(&r->key, "LEB %d:%d len %d deletion %d sqnum %llu key ",\r\nr->lnum, r->offs, r->len, r->deletion, r->sqnum);\r\nc->replay_sqnum = r->sqnum;\r\nif (is_hash_key(c, &r->key)) {\r\nif (r->deletion)\r\nerr = ubifs_tnc_remove_nm(c, &r->key, &r->nm);\r\nelse\r\nerr = ubifs_tnc_add_nm(c, &r->key, r->lnum, r->offs,\r\nr->len, &r->nm);\r\n} else {\r\nif (r->deletion)\r\nswitch (key_type(c, &r->key)) {\r\ncase UBIFS_INO_KEY:\r\n{\r\nino_t inum = key_inum(c, &r->key);\r\nerr = ubifs_tnc_remove_ino(c, inum);\r\nbreak;\r\n}\r\ncase UBIFS_TRUN_KEY:\r\nerr = trun_remove_range(c, r);\r\nbreak;\r\ndefault:\r\nerr = ubifs_tnc_remove(c, &r->key);\r\nbreak;\r\n}\r\nelse\r\nerr = ubifs_tnc_add(c, &r->key, r->lnum, r->offs,\r\nr->len);\r\nif (err)\r\nreturn err;\r\nif (c->need_recovery)\r\nerr = ubifs_recover_size_accum(c, &r->key, r->deletion,\r\nr->new_size);\r\n}\r\nreturn err;\r\n}\r\nstatic int replay_entries_cmp(void *priv, struct list_head *a,\r\nstruct list_head *b)\r\n{\r\nstruct replay_entry *ra, *rb;\r\ncond_resched();\r\nif (a == b)\r\nreturn 0;\r\nra = list_entry(a, struct replay_entry, list);\r\nrb = list_entry(b, struct replay_entry, list);\r\nubifs_assert(ra->sqnum != rb->sqnum);\r\nif (ra->sqnum > rb->sqnum)\r\nreturn 1;\r\nreturn -1;\r\n}\r\nstatic int apply_replay_list(struct ubifs_info *c)\r\n{\r\nstruct replay_entry *r;\r\nint err;\r\nlist_sort(c, &c->replay_list, &replay_entries_cmp);\r\nlist_for_each_entry(r, &c->replay_list, list) {\r\ncond_resched();\r\nerr = apply_replay_entry(c, r);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void destroy_replay_list(struct ubifs_info *c)\r\n{\r\nstruct replay_entry *r, *tmp;\r\nlist_for_each_entry_safe(r, tmp, &c->replay_list, list) {\r\nif (is_hash_key(c, &r->key))\r\nkfree(r->nm.name);\r\nlist_del(&r->list);\r\nkfree(r);\r\n}\r\n}\r\nstatic int insert_node(struct ubifs_info *c, int lnum, int offs, int len,\r\nunion ubifs_key *key, unsigned long long sqnum,\r\nint deletion, int *used, loff_t old_size,\r\nloff_t new_size)\r\n{\r\nstruct replay_entry *r;\r\ndbg_mntk(key, "add LEB %d:%d, key ", lnum, offs);\r\nif (key_inum(c, key) >= c->highest_inum)\r\nc->highest_inum = key_inum(c, key);\r\nr = kzalloc(sizeof(struct replay_entry), GFP_KERNEL);\r\nif (!r)\r\nreturn -ENOMEM;\r\nif (!deletion)\r\n*used += ALIGN(len, 8);\r\nr->lnum = lnum;\r\nr->offs = offs;\r\nr->len = len;\r\nr->deletion = !!deletion;\r\nr->sqnum = sqnum;\r\nkey_copy(c, key, &r->key);\r\nr->old_size = old_size;\r\nr->new_size = new_size;\r\nlist_add_tail(&r->list, &c->replay_list);\r\nreturn 0;\r\n}\r\nstatic int insert_dent(struct ubifs_info *c, int lnum, int offs, int len,\r\nunion ubifs_key *key, const char *name, int nlen,\r\nunsigned long long sqnum, int deletion, int *used)\r\n{\r\nstruct replay_entry *r;\r\nchar *nbuf;\r\ndbg_mntk(key, "add LEB %d:%d, key ", lnum, offs);\r\nif (key_inum(c, key) >= c->highest_inum)\r\nc->highest_inum = key_inum(c, key);\r\nr = kzalloc(sizeof(struct replay_entry), GFP_KERNEL);\r\nif (!r)\r\nreturn -ENOMEM;\r\nnbuf = kmalloc(nlen + 1, GFP_KERNEL);\r\nif (!nbuf) {\r\nkfree(r);\r\nreturn -ENOMEM;\r\n}\r\nif (!deletion)\r\n*used += ALIGN(len, 8);\r\nr->lnum = lnum;\r\nr->offs = offs;\r\nr->len = len;\r\nr->deletion = !!deletion;\r\nr->sqnum = sqnum;\r\nkey_copy(c, key, &r->key);\r\nr->nm.len = nlen;\r\nmemcpy(nbuf, name, nlen);\r\nnbuf[nlen] = '\0';\r\nr->nm.name = nbuf;\r\nlist_add_tail(&r->list, &c->replay_list);\r\nreturn 0;\r\n}\r\nint ubifs_validate_entry(struct ubifs_info *c,\r\nconst struct ubifs_dent_node *dent)\r\n{\r\nint key_type = key_type_flash(c, dent->key);\r\nint nlen = le16_to_cpu(dent->nlen);\r\nif (le32_to_cpu(dent->ch.len) != nlen + UBIFS_DENT_NODE_SZ + 1 ||\r\ndent->type >= UBIFS_ITYPES_CNT ||\r\nnlen > UBIFS_MAX_NLEN || dent->name[nlen] != 0 ||\r\nstrnlen(dent->name, nlen) != nlen ||\r\nle64_to_cpu(dent->inum) > MAX_INUM) {\r\nubifs_err(c, "bad %s node", key_type == UBIFS_DENT_KEY ?\r\n"directory entry" : "extended attribute entry");\r\nreturn -EINVAL;\r\n}\r\nif (key_type != UBIFS_DENT_KEY && key_type != UBIFS_XENT_KEY) {\r\nubifs_err(c, "bad key type %d", key_type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int is_last_bud(struct ubifs_info *c, struct ubifs_bud *bud)\r\n{\r\nstruct ubifs_jhead *jh = &c->jheads[bud->jhead];\r\nstruct ubifs_bud *next;\r\nuint32_t data;\r\nint err;\r\nif (list_is_last(&bud->list, &jh->buds_list))\r\nreturn 1;\r\nnext = list_entry(bud->list.next, struct ubifs_bud, list);\r\nif (!list_is_last(&next->list, &jh->buds_list))\r\nreturn 0;\r\nerr = ubifs_leb_read(c, next->lnum, (char *)&data, next->start, 4, 1);\r\nif (err)\r\nreturn 0;\r\nreturn data == 0xFFFFFFFF;\r\n}\r\nstatic int replay_bud(struct ubifs_info *c, struct bud_entry *b)\r\n{\r\nint is_last = is_last_bud(c, b->bud);\r\nint err = 0, used = 0, lnum = b->bud->lnum, offs = b->bud->start;\r\nstruct ubifs_scan_leb *sleb;\r\nstruct ubifs_scan_node *snod;\r\ndbg_mnt("replay bud LEB %d, head %d, offs %d, is_last %d",\r\nlnum, b->bud->jhead, offs, is_last);\r\nif (c->need_recovery && is_last)\r\nsleb = ubifs_recover_leb(c, lnum, offs, c->sbuf, b->bud->jhead);\r\nelse\r\nsleb = ubifs_scan(c, lnum, offs, c->sbuf, 0);\r\nif (IS_ERR(sleb))\r\nreturn PTR_ERR(sleb);\r\nlist_for_each_entry(snod, &sleb->nodes, list) {\r\nint deletion = 0;\r\ncond_resched();\r\nif (snod->sqnum >= SQNUM_WATERMARK) {\r\nubifs_err(c, "file system's life ended");\r\ngoto out_dump;\r\n}\r\nif (snod->sqnum > c->max_sqnum)\r\nc->max_sqnum = snod->sqnum;\r\nswitch (snod->type) {\r\ncase UBIFS_INO_NODE:\r\n{\r\nstruct ubifs_ino_node *ino = snod->node;\r\nloff_t new_size = le64_to_cpu(ino->size);\r\nif (le32_to_cpu(ino->nlink) == 0)\r\ndeletion = 1;\r\nerr = insert_node(c, lnum, snod->offs, snod->len,\r\n&snod->key, snod->sqnum, deletion,\r\n&used, 0, new_size);\r\nbreak;\r\n}\r\ncase UBIFS_DATA_NODE:\r\n{\r\nstruct ubifs_data_node *dn = snod->node;\r\nloff_t new_size = le32_to_cpu(dn->size) +\r\nkey_block(c, &snod->key) *\r\nUBIFS_BLOCK_SIZE;\r\nerr = insert_node(c, lnum, snod->offs, snod->len,\r\n&snod->key, snod->sqnum, deletion,\r\n&used, 0, new_size);\r\nbreak;\r\n}\r\ncase UBIFS_DENT_NODE:\r\ncase UBIFS_XENT_NODE:\r\n{\r\nstruct ubifs_dent_node *dent = snod->node;\r\nerr = ubifs_validate_entry(c, dent);\r\nif (err)\r\ngoto out_dump;\r\nerr = insert_dent(c, lnum, snod->offs, snod->len,\r\n&snod->key, dent->name,\r\nle16_to_cpu(dent->nlen), snod->sqnum,\r\n!le64_to_cpu(dent->inum), &used);\r\nbreak;\r\n}\r\ncase UBIFS_TRUN_NODE:\r\n{\r\nstruct ubifs_trun_node *trun = snod->node;\r\nloff_t old_size = le64_to_cpu(trun->old_size);\r\nloff_t new_size = le64_to_cpu(trun->new_size);\r\nunion ubifs_key key;\r\nif (old_size < 0 || old_size > c->max_inode_sz ||\r\nnew_size < 0 || new_size > c->max_inode_sz ||\r\nold_size <= new_size) {\r\nubifs_err(c, "bad truncation node");\r\ngoto out_dump;\r\n}\r\ntrun_key_init(c, &key, le32_to_cpu(trun->inum));\r\nerr = insert_node(c, lnum, snod->offs, snod->len,\r\n&key, snod->sqnum, 1, &used,\r\nold_size, new_size);\r\nbreak;\r\n}\r\ndefault:\r\nubifs_err(c, "unexpected node type %d in bud LEB %d:%d",\r\nsnod->type, lnum, snod->offs);\r\nerr = -EINVAL;\r\ngoto out_dump;\r\n}\r\nif (err)\r\ngoto out;\r\n}\r\nubifs_assert(ubifs_search_bud(c, lnum));\r\nubifs_assert(sleb->endpt - offs >= used);\r\nubifs_assert(sleb->endpt % c->min_io_size == 0);\r\nb->dirty = sleb->endpt - offs - used;\r\nb->free = c->leb_size - sleb->endpt;\r\ndbg_mnt("bud LEB %d replied: dirty %d, free %d",\r\nlnum, b->dirty, b->free);\r\nout:\r\nubifs_scan_destroy(sleb);\r\nreturn err;\r\nout_dump:\r\nubifs_err(c, "bad node is at LEB %d:%d", lnum, snod->offs);\r\nubifs_dump_node(c, snod->node);\r\nubifs_scan_destroy(sleb);\r\nreturn -EINVAL;\r\n}\r\nstatic int replay_buds(struct ubifs_info *c)\r\n{\r\nstruct bud_entry *b;\r\nint err;\r\nunsigned long long prev_sqnum = 0;\r\nlist_for_each_entry(b, &c->replay_buds, list) {\r\nerr = replay_bud(c, b);\r\nif (err)\r\nreturn err;\r\nubifs_assert(b->sqnum > prev_sqnum);\r\nprev_sqnum = b->sqnum;\r\n}\r\nreturn 0;\r\n}\r\nstatic void destroy_bud_list(struct ubifs_info *c)\r\n{\r\nstruct bud_entry *b;\r\nwhile (!list_empty(&c->replay_buds)) {\r\nb = list_entry(c->replay_buds.next, struct bud_entry, list);\r\nlist_del(&b->list);\r\nkfree(b);\r\n}\r\n}\r\nstatic int add_replay_bud(struct ubifs_info *c, int lnum, int offs, int jhead,\r\nunsigned long long sqnum)\r\n{\r\nstruct ubifs_bud *bud;\r\nstruct bud_entry *b;\r\ndbg_mnt("add replay bud LEB %d:%d, head %d", lnum, offs, jhead);\r\nbud = kmalloc(sizeof(struct ubifs_bud), GFP_KERNEL);\r\nif (!bud)\r\nreturn -ENOMEM;\r\nb = kmalloc(sizeof(struct bud_entry), GFP_KERNEL);\r\nif (!b) {\r\nkfree(bud);\r\nreturn -ENOMEM;\r\n}\r\nbud->lnum = lnum;\r\nbud->start = offs;\r\nbud->jhead = jhead;\r\nubifs_add_bud(c, bud);\r\nb->bud = bud;\r\nb->sqnum = sqnum;\r\nlist_add_tail(&b->list, &c->replay_buds);\r\nreturn 0;\r\n}\r\nstatic int validate_ref(struct ubifs_info *c, const struct ubifs_ref_node *ref)\r\n{\r\nstruct ubifs_bud *bud;\r\nint lnum = le32_to_cpu(ref->lnum);\r\nunsigned int offs = le32_to_cpu(ref->offs);\r\nunsigned int jhead = le32_to_cpu(ref->jhead);\r\nif (jhead >= c->jhead_cnt || lnum >= c->leb_cnt ||\r\nlnum < c->main_first || offs > c->leb_size ||\r\noffs & (c->min_io_size - 1))\r\nreturn -EINVAL;\r\nbud = ubifs_search_bud(c, lnum);\r\nif (bud) {\r\nif (bud->jhead == jhead && bud->start <= offs)\r\nreturn 1;\r\nubifs_err(c, "bud at LEB %d:%d was already referred", lnum, offs);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int replay_log_leb(struct ubifs_info *c, int lnum, int offs, void *sbuf)\r\n{\r\nint err;\r\nstruct ubifs_scan_leb *sleb;\r\nstruct ubifs_scan_node *snod;\r\nconst struct ubifs_cs_node *node;\r\ndbg_mnt("replay log LEB %d:%d", lnum, offs);\r\nsleb = ubifs_scan(c, lnum, offs, sbuf, c->need_recovery);\r\nif (IS_ERR(sleb)) {\r\nif (PTR_ERR(sleb) != -EUCLEAN || !c->need_recovery)\r\nreturn PTR_ERR(sleb);\r\nsleb = ubifs_recover_log_leb(c, lnum, offs, sbuf);\r\nif (IS_ERR(sleb))\r\nreturn PTR_ERR(sleb);\r\n}\r\nif (sleb->nodes_cnt == 0) {\r\nerr = 1;\r\ngoto out;\r\n}\r\nnode = sleb->buf;\r\nsnod = list_entry(sleb->nodes.next, struct ubifs_scan_node, list);\r\nif (c->cs_sqnum == 0) {\r\nif (snod->type != UBIFS_CS_NODE) {\r\nubifs_err(c, "first log node at LEB %d:%d is not CS node",\r\nlnum, offs);\r\ngoto out_dump;\r\n}\r\nif (le64_to_cpu(node->cmt_no) != c->cmt_no) {\r\nubifs_err(c, "first CS node at LEB %d:%d has wrong commit number %llu expected %llu",\r\nlnum, offs,\r\n(unsigned long long)le64_to_cpu(node->cmt_no),\r\nc->cmt_no);\r\ngoto out_dump;\r\n}\r\nc->cs_sqnum = le64_to_cpu(node->ch.sqnum);\r\ndbg_mnt("commit start sqnum %llu", c->cs_sqnum);\r\n}\r\nif (snod->sqnum < c->cs_sqnum) {\r\nerr = 1;\r\ngoto out;\r\n}\r\nif (snod->offs != 0) {\r\nubifs_err(c, "first node is not at zero offset");\r\ngoto out_dump;\r\n}\r\nlist_for_each_entry(snod, &sleb->nodes, list) {\r\ncond_resched();\r\nif (snod->sqnum >= SQNUM_WATERMARK) {\r\nubifs_err(c, "file system's life ended");\r\ngoto out_dump;\r\n}\r\nif (snod->sqnum < c->cs_sqnum) {\r\nubifs_err(c, "bad sqnum %llu, commit sqnum %llu",\r\nsnod->sqnum, c->cs_sqnum);\r\ngoto out_dump;\r\n}\r\nif (snod->sqnum > c->max_sqnum)\r\nc->max_sqnum = snod->sqnum;\r\nswitch (snod->type) {\r\ncase UBIFS_REF_NODE: {\r\nconst struct ubifs_ref_node *ref = snod->node;\r\nerr = validate_ref(c, ref);\r\nif (err == 1)\r\nbreak;\r\nif (err)\r\ngoto out_dump;\r\nerr = add_replay_bud(c, le32_to_cpu(ref->lnum),\r\nle32_to_cpu(ref->offs),\r\nle32_to_cpu(ref->jhead),\r\nsnod->sqnum);\r\nif (err)\r\ngoto out;\r\nbreak;\r\n}\r\ncase UBIFS_CS_NODE:\r\nif (snod->offs != 0) {\r\nubifs_err(c, "unexpected node in log");\r\ngoto out_dump;\r\n}\r\nbreak;\r\ndefault:\r\nubifs_err(c, "unexpected node in log");\r\ngoto out_dump;\r\n}\r\n}\r\nif (sleb->endpt || c->lhead_offs >= c->leb_size) {\r\nc->lhead_lnum = lnum;\r\nc->lhead_offs = sleb->endpt;\r\n}\r\nerr = !sleb->endpt;\r\nout:\r\nubifs_scan_destroy(sleb);\r\nreturn err;\r\nout_dump:\r\nubifs_err(c, "log error detected while replaying the log at LEB %d:%d",\r\nlnum, offs + snod->offs);\r\nubifs_dump_node(c, snod->node);\r\nubifs_scan_destroy(sleb);\r\nreturn -EINVAL;\r\n}\r\nstatic int take_ihead(struct ubifs_info *c)\r\n{\r\nconst struct ubifs_lprops *lp;\r\nint err, free;\r\nubifs_get_lprops(c);\r\nlp = ubifs_lpt_lookup_dirty(c, c->ihead_lnum);\r\nif (IS_ERR(lp)) {\r\nerr = PTR_ERR(lp);\r\ngoto out;\r\n}\r\nfree = lp->free;\r\nlp = ubifs_change_lp(c, lp, LPROPS_NC, LPROPS_NC,\r\nlp->flags | LPROPS_TAKEN, 0);\r\nif (IS_ERR(lp)) {\r\nerr = PTR_ERR(lp);\r\ngoto out;\r\n}\r\nerr = free;\r\nout:\r\nubifs_release_lprops(c);\r\nreturn err;\r\n}\r\nint ubifs_replay_journal(struct ubifs_info *c)\r\n{\r\nint err, lnum, free;\r\nBUILD_BUG_ON(UBIFS_TRUN_KEY > 5);\r\nfree = take_ihead(c);\r\nif (free < 0)\r\nreturn free;\r\nif (c->ihead_offs != c->leb_size - free) {\r\nubifs_err(c, "bad index head LEB %d:%d", c->ihead_lnum,\r\nc->ihead_offs);\r\nreturn -EINVAL;\r\n}\r\ndbg_mnt("start replaying the journal");\r\nc->replaying = 1;\r\nlnum = c->ltail_lnum = c->lhead_lnum;\r\ndo {\r\nerr = replay_log_leb(c, lnum, 0, c->sbuf);\r\nif (err == 1) {\r\nif (lnum != c->lhead_lnum)\r\nbreak;\r\nubifs_err(c, "no UBIFS nodes found at the log head LEB %d:%d, possibly corrupted",\r\nlnum, 0);\r\nerr = -EINVAL;\r\n}\r\nif (err)\r\ngoto out;\r\nlnum = ubifs_next_log_lnum(c, lnum);\r\n} while (lnum != c->ltail_lnum);\r\nerr = replay_buds(c);\r\nif (err)\r\ngoto out;\r\nerr = apply_replay_list(c);\r\nif (err)\r\ngoto out;\r\nerr = set_buds_lprops(c);\r\nif (err)\r\ngoto out;\r\nc->bi.uncommitted_idx = atomic_long_read(&c->dirty_zn_cnt);\r\nc->bi.uncommitted_idx *= c->max_idx_node_sz;\r\nubifs_assert(c->bud_bytes <= c->max_bud_bytes || c->need_recovery);\r\ndbg_mnt("finished, log head LEB %d:%d, max_sqnum %llu, highest_inum %lu",\r\nc->lhead_lnum, c->lhead_offs, c->max_sqnum,\r\n(unsigned long)c->highest_inum);\r\nout:\r\ndestroy_replay_list(c);\r\ndestroy_bud_list(c);\r\nc->replaying = 0;\r\nreturn err;\r\n}
