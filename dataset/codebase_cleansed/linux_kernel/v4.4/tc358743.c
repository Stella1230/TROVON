static inline struct tc358743_state *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct tc358743_state, sd);\r\n}\r\nstatic void i2c_rd(struct v4l2_subdev *sd, u16 reg, u8 *values, u32 n)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nstruct i2c_client *client = state->i2c_client;\r\nint err;\r\nu8 buf[2] = { reg >> 8, reg & 0xff };\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = buf,\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = n,\r\n.buf = values,\r\n},\r\n};\r\nerr = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (err != ARRAY_SIZE(msgs)) {\r\nv4l2_err(sd, "%s: reading register 0x%x from 0x%x failed\n",\r\n__func__, reg, client->addr);\r\n}\r\n}\r\nstatic void i2c_wr(struct v4l2_subdev *sd, u16 reg, u8 *values, u32 n)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nstruct i2c_client *client = state->i2c_client;\r\nu8 *data = state->wr_data;\r\nint err, i;\r\nstruct i2c_msg msg;\r\nif ((2 + n) > sizeof(state->wr_data))\r\nv4l2_warn(sd, "i2c wr reg=%04x: len=%d is too big!\n",\r\nreg, 2 + n);\r\nmsg.addr = client->addr;\r\nmsg.buf = data;\r\nmsg.len = 2 + n;\r\nmsg.flags = 0;\r\ndata[0] = reg >> 8;\r\ndata[1] = reg & 0xff;\r\nfor (i = 0; i < n; i++)\r\ndata[2 + i] = values[i];\r\nerr = i2c_transfer(client->adapter, &msg, 1);\r\nif (err != 1) {\r\nv4l2_err(sd, "%s: writing register 0x%x from 0x%x failed\n",\r\n__func__, reg, client->addr);\r\nreturn;\r\n}\r\nif (debug < 3)\r\nreturn;\r\nswitch (n) {\r\ncase 1:\r\nv4l2_info(sd, "I2C write 0x%04x = 0x%02x",\r\nreg, data[2]);\r\nbreak;\r\ncase 2:\r\nv4l2_info(sd, "I2C write 0x%04x = 0x%02x%02x",\r\nreg, data[3], data[2]);\r\nbreak;\r\ncase 4:\r\nv4l2_info(sd, "I2C write 0x%04x = 0x%02x%02x%02x%02x",\r\nreg, data[5], data[4], data[3], data[2]);\r\nbreak;\r\ndefault:\r\nv4l2_info(sd, "I2C write %d bytes from address 0x%04x\n",\r\nn, reg);\r\n}\r\n}\r\nstatic u8 i2c_rd8(struct v4l2_subdev *sd, u16 reg)\r\n{\r\nu8 val;\r\ni2c_rd(sd, reg, &val, 1);\r\nreturn val;\r\n}\r\nstatic void i2c_wr8(struct v4l2_subdev *sd, u16 reg, u8 val)\r\n{\r\ni2c_wr(sd, reg, &val, 1);\r\n}\r\nstatic void i2c_wr8_and_or(struct v4l2_subdev *sd, u16 reg,\r\nu8 mask, u8 val)\r\n{\r\ni2c_wr8(sd, reg, (i2c_rd8(sd, reg) & mask) | val);\r\n}\r\nstatic u16 i2c_rd16(struct v4l2_subdev *sd, u16 reg)\r\n{\r\nu16 val;\r\ni2c_rd(sd, reg, (u8 *)&val, 2);\r\nreturn val;\r\n}\r\nstatic void i2c_wr16(struct v4l2_subdev *sd, u16 reg, u16 val)\r\n{\r\ni2c_wr(sd, reg, (u8 *)&val, 2);\r\n}\r\nstatic void i2c_wr16_and_or(struct v4l2_subdev *sd, u16 reg, u16 mask, u16 val)\r\n{\r\ni2c_wr16(sd, reg, (i2c_rd16(sd, reg) & mask) | val);\r\n}\r\nstatic u32 i2c_rd32(struct v4l2_subdev *sd, u16 reg)\r\n{\r\nu32 val;\r\ni2c_rd(sd, reg, (u8 *)&val, 4);\r\nreturn val;\r\n}\r\nstatic void i2c_wr32(struct v4l2_subdev *sd, u16 reg, u32 val)\r\n{\r\ni2c_wr(sd, reg, (u8 *)&val, 4);\r\n}\r\nstatic inline bool is_hdmi(struct v4l2_subdev *sd)\r\n{\r\nreturn i2c_rd8(sd, SYS_STATUS) & MASK_S_HDMI;\r\n}\r\nstatic inline bool tx_5v_power_present(struct v4l2_subdev *sd)\r\n{\r\nreturn i2c_rd8(sd, SYS_STATUS) & MASK_S_DDC5V;\r\n}\r\nstatic inline bool no_signal(struct v4l2_subdev *sd)\r\n{\r\nreturn !(i2c_rd8(sd, SYS_STATUS) & MASK_S_TMDS);\r\n}\r\nstatic inline bool no_sync(struct v4l2_subdev *sd)\r\n{\r\nreturn !(i2c_rd8(sd, SYS_STATUS) & MASK_S_SYNC);\r\n}\r\nstatic inline bool audio_present(struct v4l2_subdev *sd)\r\n{\r\nreturn i2c_rd8(sd, AU_STATUS0) & MASK_S_A_SAMPLE;\r\n}\r\nstatic int get_audio_sampling_rate(struct v4l2_subdev *sd)\r\n{\r\nstatic const int code_to_rate[] = {\r\n44100, 0, 48000, 32000, 22050, 384000, 24000, 352800,\r\n88200, 768000, 96000, 705600, 176400, 0, 192000, 0\r\n};\r\nif (no_signal(sd))\r\nreturn 0;\r\nreturn code_to_rate[i2c_rd8(sd, FS_SET) & MASK_FS];\r\n}\r\nstatic unsigned tc358743_num_csi_lanes_in_use(struct v4l2_subdev *sd)\r\n{\r\nreturn ((i2c_rd32(sd, CSI_CONTROL) & MASK_NOL) >> 1) + 1;\r\n}\r\nstatic inline unsigned fps(const struct v4l2_bt_timings *t)\r\n{\r\nif (!V4L2_DV_BT_FRAME_HEIGHT(t) || !V4L2_DV_BT_FRAME_WIDTH(t))\r\nreturn 0;\r\nreturn DIV_ROUND_CLOSEST((unsigned)t->pixelclock,\r\nV4L2_DV_BT_FRAME_HEIGHT(t) * V4L2_DV_BT_FRAME_WIDTH(t));\r\n}\r\nstatic int tc358743_get_detected_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct v4l2_bt_timings *bt = &timings->bt;\r\nunsigned width, height, frame_width, frame_height, frame_interval, fps;\r\nmemset(timings, 0, sizeof(struct v4l2_dv_timings));\r\nif (no_signal(sd)) {\r\nv4l2_dbg(1, debug, sd, "%s: no valid signal\n", __func__);\r\nreturn -ENOLINK;\r\n}\r\nif (no_sync(sd)) {\r\nv4l2_dbg(1, debug, sd, "%s: no sync on signal\n", __func__);\r\nreturn -ENOLCK;\r\n}\r\ntimings->type = V4L2_DV_BT_656_1120;\r\nbt->interlaced = i2c_rd8(sd, VI_STATUS1) & MASK_S_V_INTERLACE ?\r\nV4L2_DV_INTERLACED : V4L2_DV_PROGRESSIVE;\r\nwidth = ((i2c_rd8(sd, DE_WIDTH_H_HI) & 0x1f) << 8) +\r\ni2c_rd8(sd, DE_WIDTH_H_LO);\r\nheight = ((i2c_rd8(sd, DE_WIDTH_V_HI) & 0x1f) << 8) +\r\ni2c_rd8(sd, DE_WIDTH_V_LO);\r\nframe_width = ((i2c_rd8(sd, H_SIZE_HI) & 0x1f) << 8) +\r\ni2c_rd8(sd, H_SIZE_LO);\r\nframe_height = (((i2c_rd8(sd, V_SIZE_HI) & 0x3f) << 8) +\r\ni2c_rd8(sd, V_SIZE_LO)) / 2;\r\nframe_interval = ((i2c_rd8(sd, FV_CNT_HI) & 0x3) << 8) +\r\ni2c_rd8(sd, FV_CNT_LO);\r\nfps = (frame_interval > 0) ?\r\nDIV_ROUND_CLOSEST(10000, frame_interval) : 0;\r\nbt->width = width;\r\nbt->height = height;\r\nbt->vsync = frame_height - height;\r\nbt->hsync = frame_width - width;\r\nbt->pixelclock = frame_width * frame_height * fps;\r\nif (bt->interlaced == V4L2_DV_INTERLACED) {\r\nbt->height *= 2;\r\nbt->il_vsync = bt->vsync + 1;\r\nbt->pixelclock /= 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tc358743_delayed_work_enable_hotplug(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct tc358743_state *state = container_of(dwork,\r\nstruct tc358743_state, delayed_work_enable_hotplug);\r\nstruct v4l2_subdev *sd = &state->sd;\r\nv4l2_dbg(2, debug, sd, "%s:\n", __func__);\r\ni2c_wr8_and_or(sd, HPD_CTL, ~MASK_HPD_OUT0, MASK_HPD_OUT0);\r\n}\r\nstatic void tc358743_set_hdmi_hdcp(struct v4l2_subdev *sd, bool enable)\r\n{\r\nv4l2_dbg(2, debug, sd, "%s: %s\n", __func__, enable ?\r\n"enable" : "disable");\r\ni2c_wr8_and_or(sd, HDCP_REG1,\r\n~(MASK_AUTH_UNAUTH_SEL | MASK_AUTH_UNAUTH),\r\nMASK_AUTH_UNAUTH_SEL_16_FRAMES | MASK_AUTH_UNAUTH_AUTO);\r\ni2c_wr8_and_or(sd, HDCP_REG2, ~MASK_AUTO_P3_RESET,\r\nSET_AUTO_P3_RESET_FRAMES(0x0f));\r\ni2c_wr8_and_or(sd, HDCP_REG3, ~KEY_RD_CMD, enable ? KEY_RD_CMD : 0);\r\ni2c_wr8_and_or(sd, HDCP_MODE, ~(MASK_AUTO_CLR | MASK_MODE_RST_TN),\r\nenable ? (MASK_AUTO_CLR | MASK_MODE_RST_TN) : 0);\r\ni2c_wr8_and_or(sd, BSTATUS1, ~MASK_MAX_EXCED,\r\nenable ? 0 : MASK_MAX_EXCED);\r\ni2c_wr8_and_or(sd, BCAPS, ~(MASK_REPEATER | MASK_READY),\r\nenable ? 0 : MASK_REPEATER | MASK_READY);\r\n}\r\nstatic void tc358743_disable_edid(struct v4l2_subdev *sd)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nv4l2_dbg(2, debug, sd, "%s:\n", __func__);\r\ncancel_delayed_work_sync(&state->delayed_work_enable_hotplug);\r\ni2c_wr8_and_or(sd, HPD_CTL, ~MASK_HPD_OUT0, 0x0);\r\n}\r\nstatic void tc358743_enable_edid(struct v4l2_subdev *sd)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nif (state->edid_blocks_written == 0) {\r\nv4l2_dbg(2, debug, sd, "%s: no EDID -> no hotplug\n", __func__);\r\nreturn;\r\n}\r\nv4l2_dbg(2, debug, sd, "%s:\n", __func__);\r\nqueue_delayed_work(state->work_queues,\r\n&state->delayed_work_enable_hotplug, HZ / 10);\r\ntc358743_enable_interrupts(sd, true);\r\ntc358743_s_ctrl_detect_tx_5v(sd);\r\n}\r\nstatic void tc358743_erase_bksv(struct v4l2_subdev *sd)\r\n{\r\nint i;\r\nfor (i = 0; i < 5; i++)\r\ni2c_wr8(sd, BKSV + i, 0);\r\n}\r\nstatic void print_avi_infoframe(struct v4l2_subdev *sd)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct device *dev = &client->dev;\r\nunion hdmi_infoframe frame;\r\nu8 buffer[HDMI_INFOFRAME_SIZE(AVI)];\r\nif (!is_hdmi(sd)) {\r\nv4l2_info(sd, "DVI-D signal - AVI infoframe not supported\n");\r\nreturn;\r\n}\r\ni2c_rd(sd, PK_AVI_0HEAD, buffer, HDMI_INFOFRAME_SIZE(AVI));\r\nif (hdmi_infoframe_unpack(&frame, buffer) < 0) {\r\nv4l2_err(sd, "%s: unpack of AVI infoframe failed\n", __func__);\r\nreturn;\r\n}\r\nhdmi_infoframe_log(KERN_INFO, dev, &frame);\r\n}\r\nstatic int tc358743_s_ctrl_detect_tx_5v(struct v4l2_subdev *sd)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nreturn v4l2_ctrl_s_ctrl(state->detect_tx_5v_ctrl,\r\ntx_5v_power_present(sd));\r\n}\r\nstatic int tc358743_s_ctrl_audio_sampling_rate(struct v4l2_subdev *sd)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nreturn v4l2_ctrl_s_ctrl(state->audio_sampling_rate_ctrl,\r\nget_audio_sampling_rate(sd));\r\n}\r\nstatic int tc358743_s_ctrl_audio_present(struct v4l2_subdev *sd)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nreturn v4l2_ctrl_s_ctrl(state->audio_present_ctrl,\r\naudio_present(sd));\r\n}\r\nstatic int tc358743_update_controls(struct v4l2_subdev *sd)\r\n{\r\nint ret = 0;\r\nret |= tc358743_s_ctrl_detect_tx_5v(sd);\r\nret |= tc358743_s_ctrl_audio_sampling_rate(sd);\r\nret |= tc358743_s_ctrl_audio_present(sd);\r\nreturn ret;\r\n}\r\nstatic void tc358743_reset_phy(struct v4l2_subdev *sd)\r\n{\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\ni2c_wr8_and_or(sd, PHY_RST, ~MASK_RESET_CTRL, 0);\r\ni2c_wr8_and_or(sd, PHY_RST, ~MASK_RESET_CTRL, MASK_RESET_CTRL);\r\n}\r\nstatic void tc358743_reset(struct v4l2_subdev *sd, uint16_t mask)\r\n{\r\nu16 sysctl = i2c_rd16(sd, SYSCTL);\r\ni2c_wr16(sd, SYSCTL, sysctl | mask);\r\ni2c_wr16(sd, SYSCTL, sysctl & ~mask);\r\n}\r\nstatic inline void tc358743_sleep_mode(struct v4l2_subdev *sd, bool enable)\r\n{\r\ni2c_wr16_and_or(sd, SYSCTL, ~MASK_SLEEP,\r\nenable ? MASK_SLEEP : 0);\r\n}\r\nstatic inline void enable_stream(struct v4l2_subdev *sd, bool enable)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nv4l2_dbg(3, debug, sd, "%s: %sable\n",\r\n__func__, enable ? "en" : "dis");\r\nif (enable) {\r\ni2c_wr32(sd, TXOPTIONCNTRL, 0);\r\ni2c_wr32(sd, TXOPTIONCNTRL, MASK_CONTCLKMODE);\r\ni2c_wr8(sd, VI_MUTE, MASK_AUTO_MUTE);\r\n} else {\r\ni2c_wr8(sd, VI_MUTE, MASK_AUTO_MUTE | MASK_VI_MUTE);\r\n}\r\nmutex_lock(&state->confctl_mutex);\r\ni2c_wr16_and_or(sd, CONFCTL, ~(MASK_VBUFEN | MASK_ABUFEN),\r\nenable ? (MASK_VBUFEN | MASK_ABUFEN) : 0x0);\r\nmutex_unlock(&state->confctl_mutex);\r\n}\r\nstatic void tc358743_set_pll(struct v4l2_subdev *sd)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nstruct tc358743_platform_data *pdata = &state->pdata;\r\nu16 pllctl0 = i2c_rd16(sd, PLLCTL0);\r\nu16 pllctl1 = i2c_rd16(sd, PLLCTL1);\r\nu16 pllctl0_new = SET_PLL_PRD(pdata->pll_prd) |\r\nSET_PLL_FBD(pdata->pll_fbd);\r\nu32 hsck = (pdata->refclk_hz / pdata->pll_prd) * pdata->pll_fbd;\r\nv4l2_dbg(2, debug, sd, "%s:\n", __func__);\r\nif ((pllctl0 != pllctl0_new) || ((pllctl1 & MASK_PLL_EN) == 0)) {\r\nu16 pll_frs;\r\nif (hsck > 500000000)\r\npll_frs = 0x0;\r\nelse if (hsck > 250000000)\r\npll_frs = 0x1;\r\nelse if (hsck > 125000000)\r\npll_frs = 0x2;\r\nelse\r\npll_frs = 0x3;\r\nv4l2_dbg(1, debug, sd, "%s: updating PLL clock\n", __func__);\r\ntc358743_sleep_mode(sd, true);\r\ni2c_wr16(sd, PLLCTL0, pllctl0_new);\r\ni2c_wr16_and_or(sd, PLLCTL1,\r\n~(MASK_PLL_FRS | MASK_RESETB | MASK_PLL_EN),\r\n(SET_PLL_FRS(pll_frs) | MASK_RESETB |\r\nMASK_PLL_EN));\r\nudelay(10);\r\ni2c_wr16_and_or(sd, PLLCTL1, ~MASK_CKEN, MASK_CKEN);\r\ntc358743_sleep_mode(sd, false);\r\n}\r\n}\r\nstatic void tc358743_set_ref_clk(struct v4l2_subdev *sd)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nstruct tc358743_platform_data *pdata = &state->pdata;\r\nu32 sys_freq;\r\nu32 lockdet_ref;\r\nu16 fh_min;\r\nu16 fh_max;\r\nBUG_ON(!(pdata->refclk_hz == 26000000 ||\r\npdata->refclk_hz == 27000000 ||\r\npdata->refclk_hz == 42000000));\r\nsys_freq = pdata->refclk_hz / 10000;\r\ni2c_wr8(sd, SYS_FREQ0, sys_freq & 0x00ff);\r\ni2c_wr8(sd, SYS_FREQ1, (sys_freq & 0xff00) >> 8);\r\ni2c_wr8_and_or(sd, PHY_CTL0, ~MASK_PHY_SYSCLK_IND,\r\n(pdata->refclk_hz == 42000000) ?\r\nMASK_PHY_SYSCLK_IND : 0x0);\r\nfh_min = pdata->refclk_hz / 100000;\r\ni2c_wr8(sd, FH_MIN0, fh_min & 0x00ff);\r\ni2c_wr8(sd, FH_MIN1, (fh_min & 0xff00) >> 8);\r\nfh_max = (fh_min * 66) / 10;\r\ni2c_wr8(sd, FH_MAX0, fh_max & 0x00ff);\r\ni2c_wr8(sd, FH_MAX1, (fh_max & 0xff00) >> 8);\r\nlockdet_ref = pdata->refclk_hz / 100;\r\ni2c_wr8(sd, LOCKDET_REF0, lockdet_ref & 0x0000ff);\r\ni2c_wr8(sd, LOCKDET_REF1, (lockdet_ref & 0x00ff00) >> 8);\r\ni2c_wr8(sd, LOCKDET_REF2, (lockdet_ref & 0x0f0000) >> 16);\r\ni2c_wr8_and_or(sd, NCO_F0_MOD, ~MASK_NCO_F0_MOD,\r\n(pdata->refclk_hz == 27000000) ?\r\nMASK_NCO_F0_MOD_27MHZ : 0x0);\r\n}\r\nstatic void tc358743_set_csi_color_space(struct v4l2_subdev *sd)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nswitch (state->mbus_fmt_code) {\r\ncase MEDIA_BUS_FMT_UYVY8_1X16:\r\nv4l2_dbg(2, debug, sd, "%s: YCbCr 422 16-bit\n", __func__);\r\ni2c_wr8_and_or(sd, VOUT_SET2,\r\n~(MASK_SEL422 | MASK_VOUT_422FIL_100) & 0xff,\r\nMASK_SEL422 | MASK_VOUT_422FIL_100);\r\ni2c_wr8_and_or(sd, VI_REP, ~MASK_VOUT_COLOR_SEL & 0xff,\r\nMASK_VOUT_COLOR_601_YCBCR_LIMITED);\r\nmutex_lock(&state->confctl_mutex);\r\ni2c_wr16_and_or(sd, CONFCTL, ~MASK_YCBCRFMT,\r\nMASK_YCBCRFMT_422_8_BIT);\r\nmutex_unlock(&state->confctl_mutex);\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB888_1X24:\r\nv4l2_dbg(2, debug, sd, "%s: RGB 888 24-bit\n", __func__);\r\ni2c_wr8_and_or(sd, VOUT_SET2,\r\n~(MASK_SEL422 | MASK_VOUT_422FIL_100) & 0xff,\r\n0x00);\r\ni2c_wr8_and_or(sd, VI_REP, ~MASK_VOUT_COLOR_SEL & 0xff,\r\nMASK_VOUT_COLOR_RGB_FULL);\r\nmutex_lock(&state->confctl_mutex);\r\ni2c_wr16_and_or(sd, CONFCTL, ~MASK_YCBCRFMT, 0);\r\nmutex_unlock(&state->confctl_mutex);\r\nbreak;\r\ndefault:\r\nv4l2_dbg(2, debug, sd, "%s: Unsupported format code 0x%x\n",\r\n__func__, state->mbus_fmt_code);\r\n}\r\n}\r\nstatic unsigned tc358743_num_csi_lanes_needed(struct v4l2_subdev *sd)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nstruct v4l2_bt_timings *bt = &state->timings.bt;\r\nstruct tc358743_platform_data *pdata = &state->pdata;\r\nu32 bits_pr_pixel =\r\n(state->mbus_fmt_code == MEDIA_BUS_FMT_UYVY8_1X16) ? 16 : 24;\r\nu32 bps = bt->width * bt->height * fps(bt) * bits_pr_pixel;\r\nu32 bps_pr_lane = (pdata->refclk_hz / pdata->pll_prd) * pdata->pll_fbd;\r\nreturn DIV_ROUND_UP(bps, bps_pr_lane);\r\n}\r\nstatic void tc358743_set_csi(struct v4l2_subdev *sd)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nstruct tc358743_platform_data *pdata = &state->pdata;\r\nunsigned lanes = tc358743_num_csi_lanes_needed(sd);\r\nv4l2_dbg(3, debug, sd, "%s:\n", __func__);\r\ntc358743_reset(sd, MASK_CTXRST);\r\nif (lanes < 1)\r\ni2c_wr32(sd, CLW_CNTRL, MASK_CLW_LANEDISABLE);\r\nif (lanes < 1)\r\ni2c_wr32(sd, D0W_CNTRL, MASK_D0W_LANEDISABLE);\r\nif (lanes < 2)\r\ni2c_wr32(sd, D1W_CNTRL, MASK_D1W_LANEDISABLE);\r\nif (lanes < 3)\r\ni2c_wr32(sd, D2W_CNTRL, MASK_D2W_LANEDISABLE);\r\nif (lanes < 4)\r\ni2c_wr32(sd, D3W_CNTRL, MASK_D3W_LANEDISABLE);\r\ni2c_wr32(sd, LINEINITCNT, pdata->lineinitcnt);\r\ni2c_wr32(sd, LPTXTIMECNT, pdata->lptxtimecnt);\r\ni2c_wr32(sd, TCLK_HEADERCNT, pdata->tclk_headercnt);\r\ni2c_wr32(sd, TCLK_TRAILCNT, pdata->tclk_trailcnt);\r\ni2c_wr32(sd, THS_HEADERCNT, pdata->ths_headercnt);\r\ni2c_wr32(sd, TWAKEUP, pdata->twakeup);\r\ni2c_wr32(sd, TCLK_POSTCNT, pdata->tclk_postcnt);\r\ni2c_wr32(sd, THS_TRAILCNT, pdata->ths_trailcnt);\r\ni2c_wr32(sd, HSTXVREGCNT, pdata->hstxvregcnt);\r\ni2c_wr32(sd, HSTXVREGEN,\r\n((lanes > 0) ? MASK_CLM_HSTXVREGEN : 0x0) |\r\n((lanes > 0) ? MASK_D0M_HSTXVREGEN : 0x0) |\r\n((lanes > 1) ? MASK_D1M_HSTXVREGEN : 0x0) |\r\n((lanes > 2) ? MASK_D2M_HSTXVREGEN : 0x0) |\r\n((lanes > 3) ? MASK_D3M_HSTXVREGEN : 0x0));\r\ni2c_wr32(sd, TXOPTIONCNTRL, (state->bus.flags &\r\nV4L2_MBUS_CSI2_CONTINUOUS_CLOCK) ? MASK_CONTCLKMODE : 0);\r\ni2c_wr32(sd, STARTCNTRL, MASK_START);\r\ni2c_wr32(sd, CSI_START, MASK_STRT);\r\ni2c_wr32(sd, CSI_CONFW, MASK_MODE_SET |\r\nMASK_ADDRESS_CSI_CONTROL |\r\nMASK_CSI_MODE |\r\nMASK_TXHSMD |\r\n((lanes == 4) ? MASK_NOL_4 :\r\n(lanes == 3) ? MASK_NOL_3 :\r\n(lanes == 2) ? MASK_NOL_2 : MASK_NOL_1));\r\ni2c_wr32(sd, CSI_CONFW, MASK_MODE_SET |\r\nMASK_ADDRESS_CSI_ERR_INTENA | MASK_TXBRK | MASK_QUNK |\r\nMASK_WCER | MASK_INER);\r\ni2c_wr32(sd, CSI_CONFW, MASK_MODE_CLEAR |\r\nMASK_ADDRESS_CSI_ERR_HALT | MASK_TXBRK | MASK_QUNK);\r\ni2c_wr32(sd, CSI_CONFW, MASK_MODE_SET |\r\nMASK_ADDRESS_CSI_INT_ENA | MASK_INTER);\r\n}\r\nstatic void tc358743_set_hdmi_phy(struct v4l2_subdev *sd)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nstruct tc358743_platform_data *pdata = &state->pdata;\r\ni2c_wr8_and_or(sd, PHY_EN, ~MASK_ENABLE_PHY, 0x0);\r\ni2c_wr8(sd, PHY_CTL1, SET_PHY_AUTO_RST1_US(1600) |\r\nSET_FREQ_RANGE_MODE_CYCLES(1));\r\ni2c_wr8_and_or(sd, PHY_CTL2, ~MASK_PHY_AUTO_RSTn,\r\n(pdata->hdmi_phy_auto_reset_tmds_detected ?\r\nMASK_PHY_AUTO_RST2 : 0) |\r\n(pdata->hdmi_phy_auto_reset_tmds_in_range ?\r\nMASK_PHY_AUTO_RST3 : 0) |\r\n(pdata->hdmi_phy_auto_reset_tmds_valid ?\r\nMASK_PHY_AUTO_RST4 : 0));\r\ni2c_wr8(sd, PHY_BIAS, 0x40);\r\ni2c_wr8(sd, PHY_CSQ, SET_CSQ_CNT_LEVEL(0x0a));\r\ni2c_wr8(sd, AVM_CTL, 45);\r\ni2c_wr8_and_or(sd, HDMI_DET, ~MASK_HDMI_DET_V,\r\npdata->hdmi_detection_delay << 4);\r\ni2c_wr8_and_or(sd, HV_RST, ~(MASK_H_PI_RST | MASK_V_PI_RST),\r\n(pdata->hdmi_phy_auto_reset_hsync_out_of_range ?\r\nMASK_H_PI_RST : 0) |\r\n(pdata->hdmi_phy_auto_reset_vsync_out_of_range ?\r\nMASK_V_PI_RST : 0));\r\ni2c_wr8_and_or(sd, PHY_EN, ~MASK_ENABLE_PHY, MASK_ENABLE_PHY);\r\n}\r\nstatic void tc358743_set_hdmi_audio(struct v4l2_subdev *sd)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\ni2c_wr8(sd, FORCE_MUTE, 0x00);\r\ni2c_wr8(sd, AUTO_CMD0, MASK_AUTO_MUTE7 | MASK_AUTO_MUTE6 |\r\nMASK_AUTO_MUTE5 | MASK_AUTO_MUTE4 |\r\nMASK_AUTO_MUTE1 | MASK_AUTO_MUTE0);\r\ni2c_wr8(sd, AUTO_CMD1, MASK_AUTO_MUTE9);\r\ni2c_wr8(sd, AUTO_CMD2, MASK_AUTO_PLAY3 | MASK_AUTO_PLAY2);\r\ni2c_wr8(sd, BUFINIT_START, SET_BUFINIT_START_MS(500));\r\ni2c_wr8(sd, FS_MUTE, 0x00);\r\ni2c_wr8(sd, FS_IMODE, MASK_NLPCM_SMODE | MASK_FS_SMODE);\r\ni2c_wr8(sd, ACR_MODE, MASK_CTS_MODE);\r\ni2c_wr8(sd, ACR_MDF0, MASK_ACR_L2MDF_1976_PPM | MASK_ACR_L1MDF_976_PPM);\r\ni2c_wr8(sd, ACR_MDF1, MASK_ACR_L3MDF_3906_PPM);\r\ni2c_wr8(sd, SDO_MODE1, MASK_SDO_FMT_I2S);\r\ni2c_wr8(sd, DIV_MODE, SET_DIV_DLY_MS(100));\r\nmutex_lock(&state->confctl_mutex);\r\ni2c_wr16_and_or(sd, CONFCTL, 0xffff, MASK_AUDCHNUM_2 |\r\nMASK_AUDOUTSEL_I2S | MASK_AUTOINDEX);\r\nmutex_unlock(&state->confctl_mutex);\r\n}\r\nstatic void tc358743_set_hdmi_info_frame_mode(struct v4l2_subdev *sd)\r\n{\r\ni2c_wr8(sd, PK_INT_MODE, MASK_ISRC2_INT_MODE | MASK_ISRC_INT_MODE |\r\nMASK_ACP_INT_MODE | MASK_VS_INT_MODE |\r\nMASK_SPD_INT_MODE | MASK_MS_INT_MODE |\r\nMASK_AUD_INT_MODE | MASK_AVI_INT_MODE);\r\ni2c_wr8(sd, NO_PKT_LIMIT, 0x2c);\r\ni2c_wr8(sd, NO_PKT_CLR, 0x53);\r\ni2c_wr8(sd, ERR_PK_LIMIT, 0x01);\r\ni2c_wr8(sd, NO_PKT_LIMIT2, 0x30);\r\ni2c_wr8(sd, NO_GDB_LIMIT, 0x10);\r\n}\r\nstatic void tc358743_initial_setup(struct v4l2_subdev *sd)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nstruct tc358743_platform_data *pdata = &state->pdata;\r\ni2c_wr16_and_or(sd, SYSCTL, ~(MASK_CECRST | MASK_IRRST),\r\n(MASK_CECRST | MASK_IRRST));\r\ntc358743_reset(sd, MASK_CTXRST | MASK_HDMIRST);\r\ntc358743_sleep_mode(sd, false);\r\ni2c_wr16(sd, FIFOCTL, pdata->fifo_level);\r\ntc358743_set_ref_clk(sd);\r\ni2c_wr8_and_or(sd, DDC_CTL, ~MASK_DDC5V_MODE,\r\npdata->ddc5v_delay & MASK_DDC5V_MODE);\r\ni2c_wr8_and_or(sd, EDID_MODE, ~MASK_EDID_MODE, MASK_EDID_MODE_E_DDC);\r\ntc358743_set_hdmi_phy(sd);\r\ntc358743_set_hdmi_hdcp(sd, pdata->enable_hdcp);\r\ntc358743_set_hdmi_audio(sd);\r\ntc358743_set_hdmi_info_frame_mode(sd);\r\ni2c_wr8_and_or(sd, VI_MODE, ~MASK_RGB_DVI, 0);\r\ni2c_wr8_and_or(sd, VOUT_SET2, ~MASK_VOUTCOLORMODE,\r\nMASK_VOUTCOLORMODE_AUTO);\r\ni2c_wr8(sd, VOUT_SET3, MASK_VOUT_EXTCNT);\r\n}\r\nstatic void tc358743_format_change(struct v4l2_subdev *sd)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nstruct v4l2_dv_timings timings;\r\nconst struct v4l2_event tc358743_ev_fmt = {\r\n.type = V4L2_EVENT_SOURCE_CHANGE,\r\n.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,\r\n};\r\nif (tc358743_get_detected_timings(sd, &timings)) {\r\nenable_stream(sd, false);\r\nv4l2_dbg(1, debug, sd, "%s: Format changed. No signal\n",\r\n__func__);\r\n} else {\r\nif (!v4l2_match_dv_timings(&state->timings, &timings, 0))\r\nenable_stream(sd, false);\r\nv4l2_print_dv_timings(sd->name,\r\n"tc358743_format_change: Format changed. New format: ",\r\n&timings, false);\r\n}\r\nif (sd->devnode)\r\nv4l2_subdev_notify_event(sd, &tc358743_ev_fmt);\r\n}\r\nstatic void tc358743_init_interrupts(struct v4l2_subdev *sd)\r\n{\r\nu16 i;\r\nfor (i = SYS_INT; i <= KEY_INT; i++)\r\ni2c_wr8(sd, i, 0xff);\r\ni2c_wr16(sd, INTSTATUS, 0xffff);\r\n}\r\nstatic void tc358743_enable_interrupts(struct v4l2_subdev *sd,\r\nbool cable_connected)\r\n{\r\nv4l2_dbg(2, debug, sd, "%s: cable connected = %d\n", __func__,\r\ncable_connected);\r\nif (cable_connected) {\r\ni2c_wr8(sd, SYS_INTM, ~(MASK_M_DDC | MASK_M_DVI_DET |\r\nMASK_M_HDMI_DET) & 0xff);\r\ni2c_wr8(sd, CLK_INTM, ~MASK_M_IN_DE_CHG);\r\ni2c_wr8(sd, CBIT_INTM, ~(MASK_M_CBIT_FS | MASK_M_AF_LOCK |\r\nMASK_M_AF_UNLOCK) & 0xff);\r\ni2c_wr8(sd, AUDIO_INTM, ~MASK_M_BUFINIT_END);\r\ni2c_wr8(sd, MISC_INTM, ~MASK_M_SYNC_CHG);\r\n} else {\r\ni2c_wr8(sd, SYS_INTM, ~MASK_M_DDC & 0xff);\r\ni2c_wr8(sd, CLK_INTM, 0xff);\r\ni2c_wr8(sd, CBIT_INTM, 0xff);\r\ni2c_wr8(sd, AUDIO_INTM, 0xff);\r\ni2c_wr8(sd, MISC_INTM, 0xff);\r\n}\r\n}\r\nstatic void tc358743_hdmi_audio_int_handler(struct v4l2_subdev *sd,\r\nbool *handled)\r\n{\r\nu8 audio_int_mask = i2c_rd8(sd, AUDIO_INTM);\r\nu8 audio_int = i2c_rd8(sd, AUDIO_INT) & ~audio_int_mask;\r\ni2c_wr8(sd, AUDIO_INT, audio_int);\r\nv4l2_dbg(3, debug, sd, "%s: AUDIO_INT = 0x%02x\n", __func__, audio_int);\r\ntc358743_s_ctrl_audio_sampling_rate(sd);\r\ntc358743_s_ctrl_audio_present(sd);\r\n}\r\nstatic void tc358743_csi_err_int_handler(struct v4l2_subdev *sd, bool *handled)\r\n{\r\nv4l2_err(sd, "%s: CSI_ERR = 0x%x\n", __func__, i2c_rd32(sd, CSI_ERR));\r\ni2c_wr32(sd, CSI_INT_CLR, MASK_ICRER);\r\n}\r\nstatic void tc358743_hdmi_misc_int_handler(struct v4l2_subdev *sd,\r\nbool *handled)\r\n{\r\nu8 misc_int_mask = i2c_rd8(sd, MISC_INTM);\r\nu8 misc_int = i2c_rd8(sd, MISC_INT) & ~misc_int_mask;\r\ni2c_wr8(sd, MISC_INT, misc_int);\r\nv4l2_dbg(3, debug, sd, "%s: MISC_INT = 0x%02x\n", __func__, misc_int);\r\nif (misc_int & MASK_I_SYNC_CHG) {\r\nif (no_sync(sd) || no_signal(sd)) {\r\ntc358743_reset_phy(sd);\r\ntc358743_erase_bksv(sd);\r\n}\r\ntc358743_format_change(sd);\r\nmisc_int &= ~MASK_I_SYNC_CHG;\r\nif (handled)\r\n*handled = true;\r\n}\r\nif (misc_int) {\r\nv4l2_err(sd, "%s: Unhandled MISC_INT interrupts: 0x%02x\n",\r\n__func__, misc_int);\r\n}\r\n}\r\nstatic void tc358743_hdmi_cbit_int_handler(struct v4l2_subdev *sd,\r\nbool *handled)\r\n{\r\nu8 cbit_int_mask = i2c_rd8(sd, CBIT_INTM);\r\nu8 cbit_int = i2c_rd8(sd, CBIT_INT) & ~cbit_int_mask;\r\ni2c_wr8(sd, CBIT_INT, cbit_int);\r\nv4l2_dbg(3, debug, sd, "%s: CBIT_INT = 0x%02x\n", __func__, cbit_int);\r\nif (cbit_int & MASK_I_CBIT_FS) {\r\nv4l2_dbg(1, debug, sd, "%s: Audio sample rate changed\n",\r\n__func__);\r\ntc358743_s_ctrl_audio_sampling_rate(sd);\r\ncbit_int &= ~MASK_I_CBIT_FS;\r\nif (handled)\r\n*handled = true;\r\n}\r\nif (cbit_int & (MASK_I_AF_LOCK | MASK_I_AF_UNLOCK)) {\r\nv4l2_dbg(1, debug, sd, "%s: Audio present changed\n",\r\n__func__);\r\ntc358743_s_ctrl_audio_present(sd);\r\ncbit_int &= ~(MASK_I_AF_LOCK | MASK_I_AF_UNLOCK);\r\nif (handled)\r\n*handled = true;\r\n}\r\nif (cbit_int) {\r\nv4l2_err(sd, "%s: Unhandled CBIT_INT interrupts: 0x%02x\n",\r\n__func__, cbit_int);\r\n}\r\n}\r\nstatic void tc358743_hdmi_clk_int_handler(struct v4l2_subdev *sd, bool *handled)\r\n{\r\nu8 clk_int_mask = i2c_rd8(sd, CLK_INTM);\r\nu8 clk_int = i2c_rd8(sd, CLK_INT) & ~clk_int_mask;\r\ni2c_wr8(sd, CLK_INT, clk_int | 0x80 | MASK_I_OUT_H_CHG);\r\nv4l2_dbg(3, debug, sd, "%s: CLK_INT = 0x%02x\n", __func__, clk_int);\r\nif (clk_int & (MASK_I_IN_DE_CHG)) {\r\nv4l2_dbg(1, debug, sd, "%s: DE size or position has changed\n",\r\n__func__);\r\nif (!no_signal(sd) && !no_sync(sd))\r\ntc358743_format_change(sd);\r\nclk_int &= ~(MASK_I_IN_DE_CHG);\r\nif (handled)\r\n*handled = true;\r\n}\r\nif (clk_int) {\r\nv4l2_err(sd, "%s: Unhandled CLK_INT interrupts: 0x%02x\n",\r\n__func__, clk_int);\r\n}\r\n}\r\nstatic void tc358743_hdmi_sys_int_handler(struct v4l2_subdev *sd, bool *handled)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nu8 sys_int_mask = i2c_rd8(sd, SYS_INTM);\r\nu8 sys_int = i2c_rd8(sd, SYS_INT) & ~sys_int_mask;\r\ni2c_wr8(sd, SYS_INT, sys_int);\r\nv4l2_dbg(3, debug, sd, "%s: SYS_INT = 0x%02x\n", __func__, sys_int);\r\nif (sys_int & MASK_I_DDC) {\r\nbool tx_5v = tx_5v_power_present(sd);\r\nv4l2_dbg(1, debug, sd, "%s: Tx 5V power present: %s\n",\r\n__func__, tx_5v ? "yes" : "no");\r\nif (tx_5v) {\r\ntc358743_enable_edid(sd);\r\n} else {\r\ntc358743_enable_interrupts(sd, false);\r\ntc358743_disable_edid(sd);\r\nmemset(&state->timings, 0, sizeof(state->timings));\r\ntc358743_erase_bksv(sd);\r\ntc358743_update_controls(sd);\r\n}\r\nsys_int &= ~MASK_I_DDC;\r\nif (handled)\r\n*handled = true;\r\n}\r\nif (sys_int & MASK_I_DVI) {\r\nv4l2_dbg(1, debug, sd, "%s: HDMI->DVI change detected\n",\r\n__func__);\r\nif (no_sync(sd) || no_signal(sd)) {\r\ntc358743_reset_phy(sd);\r\ntc358743_erase_bksv(sd);\r\n}\r\nsys_int &= ~MASK_I_DVI;\r\nif (handled)\r\n*handled = true;\r\n}\r\nif (sys_int & MASK_I_HDMI) {\r\nv4l2_dbg(1, debug, sd, "%s: DVI->HDMI change detected\n",\r\n__func__);\r\ni2c_wr8(sd, ANA_CTL, MASK_APPL_PCSX_NORMAL | MASK_ANALOG_ON);\r\nsys_int &= ~MASK_I_HDMI;\r\nif (handled)\r\n*handled = true;\r\n}\r\nif (sys_int) {\r\nv4l2_err(sd, "%s: Unhandled SYS_INT interrupts: 0x%02x\n",\r\n__func__, sys_int);\r\n}\r\n}\r\nstatic int tc358743_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nstruct v4l2_dv_timings timings;\r\nuint8_t hdmi_sys_status = i2c_rd8(sd, SYS_STATUS);\r\nuint16_t sysctl = i2c_rd16(sd, SYSCTL);\r\nu8 vi_status3 = i2c_rd8(sd, VI_STATUS3);\r\nconst int deep_color_mode[4] = { 8, 10, 12, 16 };\r\nstatic const char * const input_color_space[] = {\r\n"RGB", "YCbCr 601", "Adobe RGB", "YCbCr 709", "NA (4)",\r\n"xvYCC 601", "NA(6)", "xvYCC 709", "NA(8)", "sYCC601",\r\n"NA(10)", "NA(11)", "NA(12)", "Adobe YCC 601"};\r\nv4l2_info(sd, "-----Chip status-----\n");\r\nv4l2_info(sd, "Chip ID: 0x%02x\n",\r\n(i2c_rd16(sd, CHIPID) & MASK_CHIPID) >> 8);\r\nv4l2_info(sd, "Chip revision: 0x%02x\n",\r\ni2c_rd16(sd, CHIPID) & MASK_REVID);\r\nv4l2_info(sd, "Reset: IR: %d, CEC: %d, CSI TX: %d, HDMI: %d\n",\r\n!!(sysctl & MASK_IRRST),\r\n!!(sysctl & MASK_CECRST),\r\n!!(sysctl & MASK_CTXRST),\r\n!!(sysctl & MASK_HDMIRST));\r\nv4l2_info(sd, "Sleep mode: %s\n", sysctl & MASK_SLEEP ? "on" : "off");\r\nv4l2_info(sd, "Cable detected (+5V power): %s\n",\r\nhdmi_sys_status & MASK_S_DDC5V ? "yes" : "no");\r\nv4l2_info(sd, "DDC lines enabled: %s\n",\r\n(i2c_rd8(sd, EDID_MODE) & MASK_EDID_MODE_E_DDC) ?\r\n"yes" : "no");\r\nv4l2_info(sd, "Hotplug enabled: %s\n",\r\n(i2c_rd8(sd, HPD_CTL) & MASK_HPD_OUT0) ?\r\n"yes" : "no");\r\nv4l2_info(sd, "CEC enabled: %s\n",\r\n(i2c_rd16(sd, CECEN) & MASK_CECEN) ? "yes" : "no");\r\nv4l2_info(sd, "-----Signal status-----\n");\r\nv4l2_info(sd, "TMDS signal detected: %s\n",\r\nhdmi_sys_status & MASK_S_TMDS ? "yes" : "no");\r\nv4l2_info(sd, "Stable sync signal: %s\n",\r\nhdmi_sys_status & MASK_S_SYNC ? "yes" : "no");\r\nv4l2_info(sd, "PHY PLL locked: %s\n",\r\nhdmi_sys_status & MASK_S_PHY_PLL ? "yes" : "no");\r\nv4l2_info(sd, "PHY DE detected: %s\n",\r\nhdmi_sys_status & MASK_S_PHY_SCDT ? "yes" : "no");\r\nif (tc358743_get_detected_timings(sd, &timings)) {\r\nv4l2_info(sd, "No video detected\n");\r\n} else {\r\nv4l2_print_dv_timings(sd->name, "Detected format: ", &timings,\r\ntrue);\r\n}\r\nv4l2_print_dv_timings(sd->name, "Configured format: ", &state->timings,\r\ntrue);\r\nv4l2_info(sd, "-----CSI-TX status-----\n");\r\nv4l2_info(sd, "Lanes needed: %d\n",\r\ntc358743_num_csi_lanes_needed(sd));\r\nv4l2_info(sd, "Lanes in use: %d\n",\r\ntc358743_num_csi_lanes_in_use(sd));\r\nv4l2_info(sd, "Waiting for particular sync signal: %s\n",\r\n(i2c_rd16(sd, CSI_STATUS) & MASK_S_WSYNC) ?\r\n"yes" : "no");\r\nv4l2_info(sd, "Transmit mode: %s\n",\r\n(i2c_rd16(sd, CSI_STATUS) & MASK_S_TXACT) ?\r\n"yes" : "no");\r\nv4l2_info(sd, "Receive mode: %s\n",\r\n(i2c_rd16(sd, CSI_STATUS) & MASK_S_RXACT) ?\r\n"yes" : "no");\r\nv4l2_info(sd, "Stopped: %s\n",\r\n(i2c_rd16(sd, CSI_STATUS) & MASK_S_HLT) ?\r\n"yes" : "no");\r\nv4l2_info(sd, "Color space: %s\n",\r\nstate->mbus_fmt_code == MEDIA_BUS_FMT_UYVY8_1X16 ?\r\n"YCbCr 422 16-bit" :\r\nstate->mbus_fmt_code == MEDIA_BUS_FMT_RGB888_1X24 ?\r\n"RGB 888 24-bit" : "Unsupported");\r\nv4l2_info(sd, "-----%s status-----\n", is_hdmi(sd) ? "HDMI" : "DVI-D");\r\nv4l2_info(sd, "HDCP encrypted content: %s\n",\r\nhdmi_sys_status & MASK_S_HDCP ? "yes" : "no");\r\nv4l2_info(sd, "Input color space: %s %s range\n",\r\ninput_color_space[(vi_status3 & MASK_S_V_COLOR) >> 1],\r\n(vi_status3 & MASK_LIMITED) ? "limited" : "full");\r\nif (!is_hdmi(sd))\r\nreturn 0;\r\nv4l2_info(sd, "AV Mute: %s\n", hdmi_sys_status & MASK_S_AVMUTE ? "on" :\r\n"off");\r\nv4l2_info(sd, "Deep color mode: %d-bits per channel\n",\r\ndeep_color_mode[(i2c_rd8(sd, VI_STATUS1) &\r\nMASK_S_DEEPCOLOR) >> 2]);\r\nprint_avi_infoframe(sd);\r\nreturn 0;\r\n}\r\nstatic void tc358743_print_register_map(struct v4l2_subdev *sd)\r\n{\r\nv4l2_info(sd, "0x0000ÃƒÂ¢Ã‚&#8364;Ã‚&#8220;0x00FF: Global Control Register\n");\r\nv4l2_info(sd, "0x0100ÃƒÂ¢Ã‚&#8364;Ã‚&#8220;0x01FF: CSI2-TX PHY Register\n");\r\nv4l2_info(sd, "0x0200ÃƒÂ¢Ã‚&#8364;Ã‚&#8220;0x03FF: CSI2-TX PPI Register\n");\r\nv4l2_info(sd, "0x0400ÃƒÂ¢Ã‚&#8364;Ã‚&#8220;0x05FF: Reserved\n");\r\nv4l2_info(sd, "0x0600ÃƒÂ¢Ã‚&#8364;Ã‚&#8220;0x06FF: CEC Register\n");\r\nv4l2_info(sd, "0x0700ÃƒÂ¢Ã‚&#8364;Ã‚&#8220;0x84FF: Reserved\n");\r\nv4l2_info(sd, "0x8500ÃƒÂ¢Ã‚&#8364;Ã‚&#8220;0x85FF: HDMIRX System Control Register\n");\r\nv4l2_info(sd, "0x8600ÃƒÂ¢Ã‚&#8364;Ã‚&#8220;0x86FF: HDMIRX Audio Control Register\n");\r\nv4l2_info(sd, "0x8700ÃƒÂ¢Ã‚&#8364;Ã‚&#8220;0x87FF: HDMIRX InfoFrame packet data Register\n");\r\nv4l2_info(sd, "0x8800ÃƒÂ¢Ã‚&#8364;Ã‚&#8220;0x88FF: HDMIRX HDCP Port Register\n");\r\nv4l2_info(sd, "0x8900ÃƒÂ¢Ã‚&#8364;Ã‚&#8220;0x89FF: HDMIRX Video Output Port & 3D Register\n");\r\nv4l2_info(sd, "0x8A00ÃƒÂ¢Ã‚&#8364;Ã‚&#8220;0x8BFF: Reserved\n");\r\nv4l2_info(sd, "0x8C00ÃƒÂ¢Ã‚&#8364;Ã‚&#8220;0x8FFF: HDMIRX EDID-RAM (1024bytes)\n");\r\nv4l2_info(sd, "0x9000ÃƒÂ¢Ã‚&#8364;Ã‚&#8220;0x90FF: HDMIRX GBD Extraction Control\n");\r\nv4l2_info(sd, "0x9100ÃƒÂ¢Ã‚&#8364;Ã‚&#8220;0x92FF: HDMIRX GBD RAM read\n");\r\nv4l2_info(sd, "0x9300- : Reserved\n");\r\n}\r\nstatic int tc358743_get_reg_size(u16 address)\r\n{\r\nif (address <= 0x00ff)\r\nreturn 2;\r\nelse if ((address >= 0x0100) && (address <= 0x06FF))\r\nreturn 4;\r\nelse if ((address >= 0x0700) && (address <= 0x84ff))\r\nreturn 2;\r\nelse\r\nreturn 1;\r\n}\r\nstatic int tc358743_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nif (reg->reg > 0xffff) {\r\ntc358743_print_register_map(sd);\r\nreturn -EINVAL;\r\n}\r\nreg->size = tc358743_get_reg_size(reg->reg);\r\ni2c_rd(sd, reg->reg, (u8 *)&reg->val, reg->size);\r\nreturn 0;\r\n}\r\nstatic int tc358743_s_register(struct v4l2_subdev *sd,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nif (reg->reg > 0xffff) {\r\ntc358743_print_register_map(sd);\r\nreturn -EINVAL;\r\n}\r\nif (reg->reg == HDCP_MODE ||\r\nreg->reg == HDCP_REG1 ||\r\nreg->reg == HDCP_REG2 ||\r\nreg->reg == HDCP_REG3 ||\r\nreg->reg == BCAPS)\r\nreturn 0;\r\ni2c_wr(sd, (u16)reg->reg, (u8 *)&reg->val,\r\ntc358743_get_reg_size(reg->reg));\r\nreturn 0;\r\n}\r\nstatic int tc358743_isr(struct v4l2_subdev *sd, u32 status, bool *handled)\r\n{\r\nu16 intstatus = i2c_rd16(sd, INTSTATUS);\r\nv4l2_dbg(1, debug, sd, "%s: IntStatus = 0x%04x\n", __func__, intstatus);\r\nif (intstatus & MASK_HDMI_INT) {\r\nu8 hdmi_int0 = i2c_rd8(sd, HDMI_INT0);\r\nu8 hdmi_int1 = i2c_rd8(sd, HDMI_INT1);\r\nif (hdmi_int0 & MASK_I_MISC)\r\ntc358743_hdmi_misc_int_handler(sd, handled);\r\nif (hdmi_int1 & MASK_I_CBIT)\r\ntc358743_hdmi_cbit_int_handler(sd, handled);\r\nif (hdmi_int1 & MASK_I_CLK)\r\ntc358743_hdmi_clk_int_handler(sd, handled);\r\nif (hdmi_int1 & MASK_I_SYS)\r\ntc358743_hdmi_sys_int_handler(sd, handled);\r\nif (hdmi_int1 & MASK_I_AUD)\r\ntc358743_hdmi_audio_int_handler(sd, handled);\r\ni2c_wr16(sd, INTSTATUS, MASK_HDMI_INT);\r\nintstatus &= ~MASK_HDMI_INT;\r\n}\r\nif (intstatus & MASK_CSI_INT) {\r\nu32 csi_int = i2c_rd32(sd, CSI_INT);\r\nif (csi_int & MASK_INTER)\r\ntc358743_csi_err_int_handler(sd, handled);\r\ni2c_wr16(sd, INTSTATUS, MASK_CSI_INT);\r\nintstatus &= ~MASK_CSI_INT;\r\n}\r\nintstatus = i2c_rd16(sd, INTSTATUS);\r\nif (intstatus) {\r\nv4l2_dbg(1, debug, sd,\r\n"%s: Unhandled IntStatus interrupts: 0x%02x\n",\r\n__func__, intstatus);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t tc358743_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct tc358743_state *state = dev_id;\r\nbool handled;\r\ntc358743_isr(&state->sd, 0, &handled);\r\nreturn handled ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int tc358743_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,\r\nstruct v4l2_event_subscription *sub)\r\n{\r\nswitch (sub->type) {\r\ncase V4L2_EVENT_SOURCE_CHANGE:\r\nreturn v4l2_src_change_event_subdev_subscribe(sd, fh, sub);\r\ncase V4L2_EVENT_CTRL:\r\nreturn v4l2_ctrl_subdev_subscribe_event(sd, fh, sub);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int tc358743_g_input_status(struct v4l2_subdev *sd, u32 *status)\r\n{\r\n*status = 0;\r\n*status |= no_signal(sd) ? V4L2_IN_ST_NO_SIGNAL : 0;\r\n*status |= no_sync(sd) ? V4L2_IN_ST_NO_SYNC : 0;\r\nv4l2_dbg(1, debug, sd, "%s: status = 0x%x\n", __func__, *status);\r\nreturn 0;\r\n}\r\nstatic int tc358743_s_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nif (!timings)\r\nreturn -EINVAL;\r\nif (debug)\r\nv4l2_print_dv_timings(sd->name, "tc358743_s_dv_timings: ",\r\ntimings, false);\r\nif (v4l2_match_dv_timings(&state->timings, timings, 0)) {\r\nv4l2_dbg(1, debug, sd, "%s: no change\n", __func__);\r\nreturn 0;\r\n}\r\nif (!v4l2_valid_dv_timings(timings,\r\n&tc358743_timings_cap, NULL, NULL)) {\r\nv4l2_dbg(1, debug, sd, "%s: timings out of range\n", __func__);\r\nreturn -ERANGE;\r\n}\r\nstate->timings = *timings;\r\nenable_stream(sd, false);\r\ntc358743_set_pll(sd);\r\ntc358743_set_csi(sd);\r\nreturn 0;\r\n}\r\nstatic int tc358743_g_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\n*timings = state->timings;\r\nreturn 0;\r\n}\r\nstatic int tc358743_enum_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nif (timings->pad != 0)\r\nreturn -EINVAL;\r\nreturn v4l2_enum_dv_timings_cap(timings,\r\n&tc358743_timings_cap, NULL, NULL);\r\n}\r\nstatic int tc358743_query_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nint ret;\r\nret = tc358743_get_detected_timings(sd, timings);\r\nif (ret)\r\nreturn ret;\r\nif (debug)\r\nv4l2_print_dv_timings(sd->name, "tc358743_query_dv_timings: ",\r\ntimings, false);\r\nif (!v4l2_valid_dv_timings(timings,\r\n&tc358743_timings_cap, NULL, NULL)) {\r\nv4l2_dbg(1, debug, sd, "%s: timings out of range\n", __func__);\r\nreturn -ERANGE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tc358743_dv_timings_cap(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings_cap *cap)\r\n{\r\nif (cap->pad != 0)\r\nreturn -EINVAL;\r\n*cap = tc358743_timings_cap;\r\nreturn 0;\r\n}\r\nstatic int tc358743_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\ncfg->type = V4L2_MBUS_CSI2;\r\ncfg->flags = V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;\r\nswitch (tc358743_num_csi_lanes_in_use(sd)) {\r\ncase 1:\r\ncfg->flags |= V4L2_MBUS_CSI2_1_LANE;\r\nbreak;\r\ncase 2:\r\ncfg->flags |= V4L2_MBUS_CSI2_2_LANE;\r\nbreak;\r\ncase 3:\r\ncfg->flags |= V4L2_MBUS_CSI2_3_LANE;\r\nbreak;\r\ncase 4:\r\ncfg->flags |= V4L2_MBUS_CSI2_4_LANE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tc358743_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nenable_stream(sd, enable);\r\nreturn 0;\r\n}\r\nstatic int tc358743_get_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nu8 vi_rep = i2c_rd8(sd, VI_REP);\r\nif (format->pad != 0)\r\nreturn -EINVAL;\r\nformat->format.code = state->mbus_fmt_code;\r\nformat->format.width = state->timings.bt.width;\r\nformat->format.height = state->timings.bt.height;\r\nformat->format.field = V4L2_FIELD_NONE;\r\nswitch (vi_rep & MASK_VOUT_COLOR_SEL) {\r\ncase MASK_VOUT_COLOR_RGB_FULL:\r\ncase MASK_VOUT_COLOR_RGB_LIMITED:\r\nformat->format.colorspace = V4L2_COLORSPACE_SRGB;\r\nbreak;\r\ncase MASK_VOUT_COLOR_601_YCBCR_LIMITED:\r\ncase MASK_VOUT_COLOR_601_YCBCR_FULL:\r\nformat->format.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nbreak;\r\ncase MASK_VOUT_COLOR_709_YCBCR_FULL:\r\ncase MASK_VOUT_COLOR_709_YCBCR_LIMITED:\r\nformat->format.colorspace = V4L2_COLORSPACE_REC709;\r\nbreak;\r\ndefault:\r\nformat->format.colorspace = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tc358743_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nu32 code = format->format.code;\r\nint ret = tc358743_get_fmt(sd, cfg, format);\r\nformat->format.code = code;\r\nif (ret)\r\nreturn ret;\r\nswitch (code) {\r\ncase MEDIA_BUS_FMT_RGB888_1X24:\r\ncase MEDIA_BUS_FMT_UYVY8_1X16:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (format->which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn 0;\r\nstate->mbus_fmt_code = format->format.code;\r\nenable_stream(sd, false);\r\ntc358743_set_pll(sd);\r\ntc358743_set_csi(sd);\r\ntc358743_set_csi_color_space(sd);\r\nreturn 0;\r\n}\r\nstatic int tc358743_g_edid(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_edid *edid)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nif (edid->pad != 0)\r\nreturn -EINVAL;\r\nif (edid->start_block == 0 && edid->blocks == 0) {\r\nedid->blocks = state->edid_blocks_written;\r\nreturn 0;\r\n}\r\nif (state->edid_blocks_written == 0)\r\nreturn -ENODATA;\r\nif (edid->start_block >= state->edid_blocks_written ||\r\nedid->blocks == 0)\r\nreturn -EINVAL;\r\nif (edid->start_block + edid->blocks > state->edid_blocks_written)\r\nedid->blocks = state->edid_blocks_written - edid->start_block;\r\ni2c_rd(sd, EDID_RAM + (edid->start_block * EDID_BLOCK_SIZE), edid->edid,\r\nedid->blocks * EDID_BLOCK_SIZE);\r\nreturn 0;\r\n}\r\nstatic int tc358743_s_edid(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_edid *edid)\r\n{\r\nstruct tc358743_state *state = to_state(sd);\r\nu16 edid_len = edid->blocks * EDID_BLOCK_SIZE;\r\nv4l2_dbg(2, debug, sd, "%s, pad %d, start block %d, blocks %d\n",\r\n__func__, edid->pad, edid->start_block, edid->blocks);\r\nif (edid->pad != 0)\r\nreturn -EINVAL;\r\nif (edid->start_block != 0)\r\nreturn -EINVAL;\r\nif (edid->blocks > EDID_NUM_BLOCKS_MAX) {\r\nedid->blocks = EDID_NUM_BLOCKS_MAX;\r\nreturn -E2BIG;\r\n}\r\ntc358743_disable_edid(sd);\r\ni2c_wr8(sd, EDID_LEN1, edid_len & 0xff);\r\ni2c_wr8(sd, EDID_LEN2, edid_len >> 8);\r\nif (edid->blocks == 0) {\r\nstate->edid_blocks_written = 0;\r\nreturn 0;\r\n}\r\ni2c_wr(sd, EDID_RAM, edid->edid, edid_len);\r\nstate->edid_blocks_written = edid->blocks;\r\nif (tx_5v_power_present(sd))\r\ntc358743_enable_edid(sd);\r\nreturn 0;\r\n}\r\nstatic void tc358743_gpio_reset(struct tc358743_state *state)\r\n{\r\nusleep_range(5000, 10000);\r\ngpiod_set_value(state->reset_gpio, 1);\r\nusleep_range(1000, 2000);\r\ngpiod_set_value(state->reset_gpio, 0);\r\nmsleep(20);\r\n}\r\nstatic int tc358743_probe_of(struct tc358743_state *state)\r\n{\r\nstruct device *dev = &state->i2c_client->dev;\r\nstruct v4l2_of_endpoint *endpoint;\r\nstruct device_node *ep;\r\nstruct clk *refclk;\r\nu32 bps_pr_lane;\r\nint ret = -EINVAL;\r\nrefclk = devm_clk_get(dev, "refclk");\r\nif (IS_ERR(refclk)) {\r\nif (PTR_ERR(refclk) != -EPROBE_DEFER)\r\ndev_err(dev, "failed to get refclk: %ld\n",\r\nPTR_ERR(refclk));\r\nreturn PTR_ERR(refclk);\r\n}\r\nep = of_graph_get_next_endpoint(dev->of_node, NULL);\r\nif (!ep) {\r\ndev_err(dev, "missing endpoint node\n");\r\nreturn -EINVAL;\r\n}\r\nendpoint = v4l2_of_alloc_parse_endpoint(ep);\r\nif (IS_ERR(endpoint)) {\r\ndev_err(dev, "failed to parse endpoint\n");\r\nreturn PTR_ERR(endpoint);\r\n}\r\nif (endpoint->bus_type != V4L2_MBUS_CSI2 ||\r\nendpoint->bus.mipi_csi2.num_data_lanes == 0 ||\r\nendpoint->nr_of_link_frequencies == 0) {\r\ndev_err(dev, "missing CSI-2 properties in endpoint\n");\r\ngoto free_endpoint;\r\n}\r\nstate->bus = endpoint->bus.mipi_csi2;\r\nclk_prepare_enable(refclk);\r\nstate->pdata.refclk_hz = clk_get_rate(refclk);\r\nstate->pdata.ddc5v_delay = DDC5V_DELAY_100_MS;\r\nstate->pdata.enable_hdcp = false;\r\nstate->pdata.fifo_level = 16;\r\nswitch (state->pdata.refclk_hz) {\r\ncase 26000000:\r\ncase 27000000:\r\ncase 42000000:\r\nstate->pdata.pll_prd = state->pdata.refclk_hz / 6000000;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "unsupported refclk rate: %u Hz\n",\r\nstate->pdata.refclk_hz);\r\ngoto disable_clk;\r\n}\r\nbps_pr_lane = 2 * endpoint->link_frequencies[0];\r\nif (bps_pr_lane < 62500000U || bps_pr_lane > 1000000000U) {\r\ndev_err(dev, "unsupported bps per lane: %u bps\n", bps_pr_lane);\r\ngoto disable_clk;\r\n}\r\nstate->pdata.pll_fbd = bps_pr_lane /\r\nstate->pdata.refclk_hz * state->pdata.pll_prd;\r\nif (bps_pr_lane != 594000000U)\r\ndev_warn(dev, "untested bps per lane: %u bps\n", bps_pr_lane);\r\nstate->pdata.lineinitcnt = 0xe80;\r\nstate->pdata.lptxtimecnt = 0x003;\r\nstate->pdata.tclk_headercnt = 0x1403;\r\nstate->pdata.tclk_trailcnt = 0x00;\r\nstate->pdata.ths_headercnt = 0x0103;\r\nstate->pdata.twakeup = 0x4882;\r\nstate->pdata.tclk_postcnt = 0x008;\r\nstate->pdata.ths_trailcnt = 0x2;\r\nstate->pdata.hstxvregcnt = 0;\r\nstate->reset_gpio = devm_gpiod_get_optional(dev, "reset",\r\nGPIOD_OUT_LOW);\r\nif (IS_ERR(state->reset_gpio)) {\r\ndev_err(dev, "failed to get reset gpio\n");\r\nret = PTR_ERR(state->reset_gpio);\r\ngoto disable_clk;\r\n}\r\nif (state->reset_gpio)\r\ntc358743_gpio_reset(state);\r\nret = 0;\r\ngoto free_endpoint;\r\ndisable_clk:\r\nclk_disable_unprepare(refclk);\r\nfree_endpoint:\r\nv4l2_of_free_endpoint(endpoint);\r\nreturn ret;\r\n}\r\nstatic inline int tc358743_probe_of(struct tc358743_state *state)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int tc358743_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstatic struct v4l2_dv_timings default_timing =\r\nV4L2_DV_BT_CEA_640X480P59_94;\r\nstruct tc358743_state *state;\r\nstruct tc358743_platform_data *pdata = client->dev.platform_data;\r\nstruct v4l2_subdev *sd;\r\nint err;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nv4l_dbg(1, debug, client, "chip found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nstate = devm_kzalloc(&client->dev, sizeof(struct tc358743_state),\r\nGFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nstate->i2c_client = client;\r\nif (pdata) {\r\nstate->pdata = *pdata;\r\nstate->bus.flags = V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;\r\n} else {\r\nerr = tc358743_probe_of(state);\r\nif (err == -ENODEV)\r\nv4l_err(client, "No platform data!\n");\r\nif (err)\r\nreturn err;\r\n}\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, client, &tc358743_ops);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;\r\nif ((i2c_rd16(sd, CHIPID) & MASK_CHIPID) != 0) {\r\nv4l2_info(sd, "not a TC358743 on address 0x%x\n",\r\nclient->addr << 1);\r\nreturn -ENODEV;\r\n}\r\nv4l2_ctrl_handler_init(&state->hdl, 3);\r\nstate->detect_tx_5v_ctrl = v4l2_ctrl_new_std(&state->hdl, NULL,\r\nV4L2_CID_DV_RX_POWER_PRESENT, 0, 1, 0, 0);\r\nstate->audio_sampling_rate_ctrl = v4l2_ctrl_new_custom(&state->hdl,\r\n&tc358743_ctrl_audio_sampling_rate, NULL);\r\nstate->audio_present_ctrl = v4l2_ctrl_new_custom(&state->hdl,\r\n&tc358743_ctrl_audio_present, NULL);\r\nsd->ctrl_handler = &state->hdl;\r\nif (state->hdl.error) {\r\nerr = state->hdl.error;\r\ngoto err_hdl;\r\n}\r\nif (tc358743_update_controls(sd)) {\r\nerr = -ENODEV;\r\ngoto err_hdl;\r\n}\r\nstate->work_queues = create_singlethread_workqueue(client->name);\r\nif (!state->work_queues) {\r\nv4l2_err(sd, "Could not create work queue\n");\r\nerr = -ENOMEM;\r\ngoto err_hdl;\r\n}\r\nstate->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nerr = media_entity_init(&sd->entity, 1, &state->pad, 0);\r\nif (err < 0)\r\ngoto err_hdl;\r\nsd->dev = &client->dev;\r\nerr = v4l2_async_register_subdev(sd);\r\nif (err < 0)\r\ngoto err_hdl;\r\nmutex_init(&state->confctl_mutex);\r\nINIT_DELAYED_WORK(&state->delayed_work_enable_hotplug,\r\ntc358743_delayed_work_enable_hotplug);\r\ntc358743_initial_setup(sd);\r\ntc358743_s_dv_timings(sd, &default_timing);\r\nstate->mbus_fmt_code = MEDIA_BUS_FMT_RGB888_1X24;\r\ntc358743_set_csi_color_space(sd);\r\ntc358743_init_interrupts(sd);\r\nif (state->i2c_client->irq) {\r\nerr = devm_request_threaded_irq(&client->dev,\r\nstate->i2c_client->irq,\r\nNULL, tc358743_irq_handler,\r\nIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\r\n"tc358743", state);\r\nif (err)\r\ngoto err_work_queues;\r\n}\r\ntc358743_enable_interrupts(sd, tx_5v_power_present(sd));\r\ni2c_wr16(sd, INTMASK, ~(MASK_HDMI_MSK | MASK_CSI_MSK) & 0xffff);\r\nerr = v4l2_ctrl_handler_setup(sd->ctrl_handler);\r\nif (err)\r\ngoto err_work_queues;\r\nv4l2_info(sd, "%s found @ 0x%x (%s)\n", client->name,\r\nclient->addr << 1, client->adapter->name);\r\nreturn 0;\r\nerr_work_queues:\r\ncancel_delayed_work(&state->delayed_work_enable_hotplug);\r\ndestroy_workqueue(state->work_queues);\r\nmutex_destroy(&state->confctl_mutex);\r\nerr_hdl:\r\nmedia_entity_cleanup(&sd->entity);\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nreturn err;\r\n}\r\nstatic int tc358743_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct tc358743_state *state = to_state(sd);\r\ncancel_delayed_work(&state->delayed_work_enable_hotplug);\r\ndestroy_workqueue(state->work_queues);\r\nv4l2_async_unregister_subdev(sd);\r\nv4l2_device_unregister_subdev(sd);\r\nmutex_destroy(&state->confctl_mutex);\r\nmedia_entity_cleanup(&sd->entity);\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nreturn 0;\r\n}
