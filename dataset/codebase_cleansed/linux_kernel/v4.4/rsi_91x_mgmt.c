static void rsi_set_default_parameters(struct rsi_common *common)\r\n{\r\ncommon->band = IEEE80211_BAND_2GHZ;\r\ncommon->channel_width = BW_20MHZ;\r\ncommon->rts_threshold = IEEE80211_MAX_RTS_THRESHOLD;\r\ncommon->channel = 1;\r\ncommon->min_rate = 0xffff;\r\ncommon->fsm_state = FSM_CARD_NOT_READY;\r\ncommon->iface_down = true;\r\ncommon->endpoint = EP_2GHZ_20MHZ;\r\n}\r\nstatic void rsi_set_contention_vals(struct rsi_common *common)\r\n{\r\nu8 ii = 0;\r\nfor (; ii < NUM_EDCA_QUEUES; ii++) {\r\ncommon->tx_qinfo[ii].wme_params =\r\n(((common->edca_params[ii].cw_min / 2) +\r\n(common->edca_params[ii].aifs)) *\r\nWMM_SHORT_SLOT_TIME + SIFS_DURATION);\r\ncommon->tx_qinfo[ii].weight = common->tx_qinfo[ii].wme_params;\r\ncommon->tx_qinfo[ii].pkt_contended = 0;\r\n}\r\n}\r\nstatic int rsi_send_internal_mgmt_frame(struct rsi_common *common,\r\nstruct sk_buff *skb)\r\n{\r\nstruct skb_info *tx_params;\r\nif (skb == NULL) {\r\nrsi_dbg(ERR_ZONE, "%s: Unable to allocate skb\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\ntx_params = (struct skb_info *)&IEEE80211_SKB_CB(skb)->driver_data;\r\ntx_params->flags |= INTERNAL_MGMT_PKT;\r\nskb_queue_tail(&common->tx_queue[MGMT_SOFT_Q], skb);\r\nrsi_set_event(&common->tx_thread.event);\r\nreturn 0;\r\n}\r\nstatic int rsi_load_radio_caps(struct rsi_common *common)\r\n{\r\nstruct rsi_radio_caps *radio_caps;\r\nstruct rsi_hw *adapter = common->priv;\r\nu16 inx = 0;\r\nu8 ii;\r\nu8 radio_id = 0;\r\nu16 gc[20] = {0xf0, 0xf0, 0xf0, 0xf0,\r\n0xf0, 0xf0, 0xf0, 0xf0,\r\n0xf0, 0xf0, 0xf0, 0xf0,\r\n0xf0, 0xf0, 0xf0, 0xf0,\r\n0xf0, 0xf0, 0xf0, 0xf0};\r\nstruct sk_buff *skb;\r\nrsi_dbg(INFO_ZONE, "%s: Sending rate symbol req frame\n", __func__);\r\nskb = dev_alloc_skb(sizeof(struct rsi_radio_caps));\r\nif (!skb) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nmemset(skb->data, 0, sizeof(struct rsi_radio_caps));\r\nradio_caps = (struct rsi_radio_caps *)skb->data;\r\nradio_caps->desc_word[1] = cpu_to_le16(RADIO_CAPABILITIES);\r\nradio_caps->desc_word[4] = cpu_to_le16(RSI_RF_TYPE << 8);\r\nif (common->channel_width == BW_40MHZ) {\r\nradio_caps->desc_word[7] |= cpu_to_le16(RSI_LMAC_CLOCK_80MHZ);\r\nradio_caps->desc_word[7] |= cpu_to_le16(RSI_ENABLE_40MHZ);\r\nif (common->fsm_state == FSM_MAC_INIT_DONE) {\r\nstruct ieee80211_hw *hw = adapter->hw;\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nif (conf_is_ht40_plus(conf)) {\r\nradio_caps->desc_word[5] =\r\ncpu_to_le16(LOWER_20_ENABLE);\r\nradio_caps->desc_word[5] |=\r\ncpu_to_le16(LOWER_20_ENABLE >> 12);\r\n} else if (conf_is_ht40_minus(conf)) {\r\nradio_caps->desc_word[5] =\r\ncpu_to_le16(UPPER_20_ENABLE);\r\nradio_caps->desc_word[5] |=\r\ncpu_to_le16(UPPER_20_ENABLE >> 12);\r\n} else {\r\nradio_caps->desc_word[5] =\r\ncpu_to_le16(BW_40MHZ << 12);\r\nradio_caps->desc_word[5] |=\r\ncpu_to_le16(FULL40M_ENABLE);\r\n}\r\n}\r\n}\r\nradio_caps->sifs_tx_11n = cpu_to_le16(SIFS_TX_11N_VALUE);\r\nradio_caps->sifs_tx_11b = cpu_to_le16(SIFS_TX_11B_VALUE);\r\nradio_caps->slot_rx_11n = cpu_to_le16(SHORT_SLOT_VALUE);\r\nradio_caps->ofdm_ack_tout = cpu_to_le16(OFDM_ACK_TOUT_VALUE);\r\nradio_caps->cck_ack_tout = cpu_to_le16(CCK_ACK_TOUT_VALUE);\r\nradio_caps->preamble_type = cpu_to_le16(LONG_PREAMBLE);\r\nradio_caps->desc_word[7] |= cpu_to_le16(radio_id << 8);\r\nfor (ii = 0; ii < MAX_HW_QUEUES; ii++) {\r\nradio_caps->qos_params[ii].cont_win_min_q = cpu_to_le16(3);\r\nradio_caps->qos_params[ii].cont_win_max_q = cpu_to_le16(0x3f);\r\nradio_caps->qos_params[ii].aifsn_val_q = cpu_to_le16(2);\r\nradio_caps->qos_params[ii].txop_q = 0;\r\n}\r\nfor (ii = 0; ii < MAX_HW_QUEUES - 4; ii++) {\r\nradio_caps->qos_params[ii].cont_win_min_q =\r\ncpu_to_le16(common->edca_params[ii].cw_min);\r\nradio_caps->qos_params[ii].cont_win_max_q =\r\ncpu_to_le16(common->edca_params[ii].cw_max);\r\nradio_caps->qos_params[ii].aifsn_val_q =\r\ncpu_to_le16((common->edca_params[ii].aifs) << 8);\r\nradio_caps->qos_params[ii].txop_q =\r\ncpu_to_le16(common->edca_params[ii].txop);\r\n}\r\nmemcpy(&common->rate_pwr[0], &gc[0], 40);\r\nfor (ii = 0; ii < 20; ii++)\r\nradio_caps->gcpd_per_rate[inx++] =\r\ncpu_to_le16(common->rate_pwr[ii] & 0x00FF);\r\nradio_caps->desc_word[0] = cpu_to_le16((sizeof(struct rsi_radio_caps) -\r\nFRAME_DESC_SZ) |\r\n(RSI_WIFI_MGMT_Q << 12));\r\nskb_put(skb, (sizeof(struct rsi_radio_caps)));\r\nreturn rsi_send_internal_mgmt_frame(common, skb);\r\n}\r\nstatic int rsi_mgmt_pkt_to_core(struct rsi_common *common,\r\nu8 *msg,\r\ns32 msg_len,\r\nu8 type)\r\n{\r\nstruct rsi_hw *adapter = common->priv;\r\nstruct ieee80211_tx_info *info;\r\nstruct skb_info *rx_params;\r\nu8 pad_bytes = msg[4];\r\nu8 pkt_recv;\r\nstruct sk_buff *skb;\r\nchar *buffer;\r\nif (type == RX_DOT11_MGMT) {\r\nif (!adapter->sc_nvifs)\r\nreturn -ENOLINK;\r\nmsg_len -= pad_bytes;\r\nif ((msg_len <= 0) || (!msg)) {\r\nrsi_dbg(MGMT_RX_ZONE,\r\n"%s: Invalid rx msg of len = %d\n",\r\n__func__, msg_len);\r\nreturn -EINVAL;\r\n}\r\nskb = dev_alloc_skb(msg_len);\r\nif (!skb) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed to allocate skb\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nbuffer = skb_put(skb, msg_len);\r\nmemcpy(buffer,\r\n(u8 *)(msg + FRAME_DESC_SZ + pad_bytes),\r\nmsg_len);\r\npkt_recv = buffer[0];\r\ninfo = IEEE80211_SKB_CB(skb);\r\nrx_params = (struct skb_info *)info->driver_data;\r\nrx_params->rssi = rsi_get_rssi(msg);\r\nrx_params->channel = rsi_get_channel(msg);\r\nrsi_indicate_pkt_to_os(common, skb);\r\n} else {\r\nrsi_dbg(MGMT_TX_ZONE, "%s: Internal Packet\n", __func__);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rsi_hal_send_sta_notify_frame(struct rsi_common *common,\r\nu8 opmode,\r\nu8 notify_event,\r\nconst unsigned char *bssid,\r\nu8 qos_enable,\r\nu16 aid)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nstruct rsi_peer_notify *peer_notify;\r\nu16 vap_id = 0;\r\nint status;\r\nrsi_dbg(MGMT_TX_ZONE, "%s: Sending sta notify frame\n", __func__);\r\nskb = dev_alloc_skb(sizeof(struct rsi_peer_notify));\r\nif (!skb) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nmemset(skb->data, 0, sizeof(struct rsi_peer_notify));\r\npeer_notify = (struct rsi_peer_notify *)skb->data;\r\npeer_notify->command = cpu_to_le16(opmode << 1);\r\nswitch (notify_event) {\r\ncase STA_CONNECTED:\r\npeer_notify->command |= cpu_to_le16(RSI_ADD_PEER);\r\nbreak;\r\ncase STA_DISCONNECTED:\r\npeer_notify->command |= cpu_to_le16(RSI_DELETE_PEER);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npeer_notify->command |= cpu_to_le16((aid & 0xfff) << 4);\r\nether_addr_copy(peer_notify->mac_addr, bssid);\r\npeer_notify->sta_flags = cpu_to_le32((qos_enable) ? 1 : 0);\r\npeer_notify->desc_word[0] =\r\ncpu_to_le16((sizeof(struct rsi_peer_notify) - FRAME_DESC_SZ) |\r\n(RSI_WIFI_MGMT_Q << 12));\r\npeer_notify->desc_word[1] = cpu_to_le16(PEER_NOTIFY);\r\npeer_notify->desc_word[7] |= cpu_to_le16(vap_id << 8);\r\nskb_put(skb, sizeof(struct rsi_peer_notify));\r\nstatus = rsi_send_internal_mgmt_frame(common, skb);\r\nif (!status && qos_enable) {\r\nrsi_set_contention_vals(common);\r\nstatus = rsi_load_radio_caps(common);\r\n}\r\nreturn status;\r\n}\r\nint rsi_send_aggregation_params_frame(struct rsi_common *common,\r\nu16 tid,\r\nu16 ssn,\r\nu8 buf_size,\r\nu8 event)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nstruct rsi_mac_frame *mgmt_frame;\r\nu8 peer_id = 0;\r\nskb = dev_alloc_skb(FRAME_DESC_SZ);\r\nif (!skb) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nmemset(skb->data, 0, FRAME_DESC_SZ);\r\nmgmt_frame = (struct rsi_mac_frame *)skb->data;\r\nrsi_dbg(MGMT_TX_ZONE, "%s: Sending AMPDU indication frame\n", __func__);\r\nmgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);\r\nmgmt_frame->desc_word[1] = cpu_to_le16(AMPDU_IND);\r\nif (event == STA_TX_ADDBA_DONE) {\r\nmgmt_frame->desc_word[4] = cpu_to_le16(ssn);\r\nmgmt_frame->desc_word[5] = cpu_to_le16(buf_size);\r\nmgmt_frame->desc_word[7] =\r\ncpu_to_le16((tid | (START_AMPDU_AGGR << 4) | (peer_id << 8)));\r\n} else if (event == STA_RX_ADDBA_DONE) {\r\nmgmt_frame->desc_word[4] = cpu_to_le16(ssn);\r\nmgmt_frame->desc_word[7] = cpu_to_le16(tid |\r\n(START_AMPDU_AGGR << 4) |\r\n(RX_BA_INDICATION << 5) |\r\n(peer_id << 8));\r\n} else if (event == STA_TX_DELBA) {\r\nmgmt_frame->desc_word[7] = cpu_to_le16(tid |\r\n(STOP_AMPDU_AGGR << 4) |\r\n(peer_id << 8));\r\n} else if (event == STA_RX_DELBA) {\r\nmgmt_frame->desc_word[7] = cpu_to_le16(tid |\r\n(STOP_AMPDU_AGGR << 4) |\r\n(RX_BA_INDICATION << 5) |\r\n(peer_id << 8));\r\n}\r\nskb_put(skb, FRAME_DESC_SZ);\r\nreturn rsi_send_internal_mgmt_frame(common, skb);\r\n}\r\nstatic int rsi_program_bb_rf(struct rsi_common *common)\r\n{\r\nstruct sk_buff *skb;\r\nstruct rsi_mac_frame *mgmt_frame;\r\nrsi_dbg(MGMT_TX_ZONE, "%s: Sending program BB/RF frame\n", __func__);\r\nskb = dev_alloc_skb(FRAME_DESC_SZ);\r\nif (!skb) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nmemset(skb->data, 0, FRAME_DESC_SZ);\r\nmgmt_frame = (struct rsi_mac_frame *)skb->data;\r\nmgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);\r\nmgmt_frame->desc_word[1] = cpu_to_le16(BBP_PROG_IN_TA);\r\nmgmt_frame->desc_word[4] = cpu_to_le16(common->endpoint);\r\nif (common->rf_reset) {\r\nmgmt_frame->desc_word[7] = cpu_to_le16(RF_RESET_ENABLE);\r\nrsi_dbg(MGMT_TX_ZONE, "%s: ===> RF RESET REQUEST SENT <===\n",\r\n__func__);\r\ncommon->rf_reset = 0;\r\n}\r\ncommon->bb_rf_prog_count = 1;\r\nmgmt_frame->desc_word[7] |= cpu_to_le16(PUT_BBP_RESET |\r\nBBP_REG_WRITE | (RSI_RF_TYPE << 4));\r\nskb_put(skb, FRAME_DESC_SZ);\r\nreturn rsi_send_internal_mgmt_frame(common, skb);\r\n}\r\nint rsi_set_vap_capabilities(struct rsi_common *common, enum opmode mode)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nstruct rsi_vap_caps *vap_caps;\r\nstruct rsi_hw *adapter = common->priv;\r\nstruct ieee80211_hw *hw = adapter->hw;\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nu16 vap_id = 0;\r\nrsi_dbg(MGMT_TX_ZONE, "%s: Sending VAP capabilities frame\n", __func__);\r\nskb = dev_alloc_skb(sizeof(struct rsi_vap_caps));\r\nif (!skb) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nmemset(skb->data, 0, sizeof(struct rsi_vap_caps));\r\nvap_caps = (struct rsi_vap_caps *)skb->data;\r\nvap_caps->desc_word[0] = cpu_to_le16((sizeof(struct rsi_vap_caps) -\r\nFRAME_DESC_SZ) |\r\n(RSI_WIFI_MGMT_Q << 12));\r\nvap_caps->desc_word[1] = cpu_to_le16(VAP_CAPABILITIES);\r\nvap_caps->desc_word[4] = cpu_to_le16(mode |\r\n(common->channel_width << 8));\r\nvap_caps->desc_word[7] = cpu_to_le16((vap_id << 8) |\r\n(common->mac_id << 4) |\r\ncommon->radio_id);\r\nmemcpy(vap_caps->mac_addr, common->mac_addr, IEEE80211_ADDR_LEN);\r\nvap_caps->keep_alive_period = cpu_to_le16(90);\r\nvap_caps->frag_threshold = cpu_to_le16(IEEE80211_MAX_FRAG_THRESHOLD);\r\nvap_caps->rts_threshold = cpu_to_le16(common->rts_threshold);\r\nvap_caps->default_mgmt_rate = cpu_to_le32(RSI_RATE_6);\r\nif (common->band == IEEE80211_BAND_5GHZ) {\r\nvap_caps->default_ctrl_rate = cpu_to_le32(RSI_RATE_6);\r\nif (conf_is_ht40(&common->priv->hw->conf)) {\r\nvap_caps->default_ctrl_rate |=\r\ncpu_to_le32(FULL40M_ENABLE << 16);\r\n}\r\n} else {\r\nvap_caps->default_ctrl_rate = cpu_to_le32(RSI_RATE_1);\r\nif (conf_is_ht40_minus(conf))\r\nvap_caps->default_ctrl_rate |=\r\ncpu_to_le32(UPPER_20_ENABLE << 16);\r\nelse if (conf_is_ht40_plus(conf))\r\nvap_caps->default_ctrl_rate |=\r\ncpu_to_le32(LOWER_20_ENABLE << 16);\r\n}\r\nvap_caps->default_data_rate = 0;\r\nvap_caps->beacon_interval = cpu_to_le16(200);\r\nvap_caps->dtim_period = cpu_to_le16(4);\r\nskb_put(skb, sizeof(*vap_caps));\r\nreturn rsi_send_internal_mgmt_frame(common, skb);\r\n}\r\nint rsi_hal_load_key(struct rsi_common *common,\r\nu8 *data,\r\nu16 key_len,\r\nu8 key_type,\r\nu8 key_id,\r\nu32 cipher)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nstruct rsi_set_key *set_key;\r\nu16 key_descriptor = 0;\r\nrsi_dbg(MGMT_TX_ZONE, "%s: Sending load key frame\n", __func__);\r\nskb = dev_alloc_skb(sizeof(struct rsi_set_key));\r\nif (!skb) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nmemset(skb->data, 0, sizeof(struct rsi_set_key));\r\nset_key = (struct rsi_set_key *)skb->data;\r\nif ((cipher == WLAN_CIPHER_SUITE_WEP40) ||\r\n(cipher == WLAN_CIPHER_SUITE_WEP104)) {\r\nkey_len += 1;\r\nkey_descriptor |= BIT(2);\r\nif (key_len >= 13)\r\nkey_descriptor |= BIT(3);\r\n} else if (cipher != KEY_TYPE_CLEAR) {\r\nkey_descriptor |= BIT(4);\r\nif (key_type == RSI_PAIRWISE_KEY)\r\nkey_id = 0;\r\nif (cipher == WLAN_CIPHER_SUITE_TKIP)\r\nkey_descriptor |= BIT(5);\r\n}\r\nkey_descriptor |= (key_type | BIT(13) | (key_id << 14));\r\nset_key->desc_word[0] = cpu_to_le16((sizeof(struct rsi_set_key) -\r\nFRAME_DESC_SZ) |\r\n(RSI_WIFI_MGMT_Q << 12));\r\nset_key->desc_word[1] = cpu_to_le16(SET_KEY_REQ);\r\nset_key->desc_word[4] = cpu_to_le16(key_descriptor);\r\nif ((cipher == WLAN_CIPHER_SUITE_WEP40) ||\r\n(cipher == WLAN_CIPHER_SUITE_WEP104)) {\r\nmemcpy(&set_key->key[key_id][1],\r\ndata,\r\nkey_len * 2);\r\n} else {\r\nmemcpy(&set_key->key[0][0], data, key_len);\r\n}\r\nmemcpy(set_key->tx_mic_key, &data[16], 8);\r\nmemcpy(set_key->rx_mic_key, &data[24], 8);\r\nskb_put(skb, sizeof(struct rsi_set_key));\r\nreturn rsi_send_internal_mgmt_frame(common, skb);\r\n}\r\nstatic int rsi_load_bootup_params(struct rsi_common *common)\r\n{\r\nstruct sk_buff *skb;\r\nstruct rsi_boot_params *boot_params;\r\nrsi_dbg(MGMT_TX_ZONE, "%s: Sending boot params frame\n", __func__);\r\nskb = dev_alloc_skb(sizeof(struct rsi_boot_params));\r\nif (!skb) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nmemset(skb->data, 0, sizeof(struct rsi_boot_params));\r\nboot_params = (struct rsi_boot_params *)skb->data;\r\nrsi_dbg(MGMT_TX_ZONE, "%s:\n", __func__);\r\nif (common->channel_width == BW_40MHZ) {\r\nmemcpy(&boot_params->bootup_params,\r\n&boot_params_40,\r\nsizeof(struct bootup_params));\r\nrsi_dbg(MGMT_TX_ZONE, "%s: Packet 40MHZ <=== %d\n", __func__,\r\nUMAC_CLK_40BW);\r\nboot_params->desc_word[7] = cpu_to_le16(UMAC_CLK_40BW);\r\n} else {\r\nmemcpy(&boot_params->bootup_params,\r\n&boot_params_20,\r\nsizeof(struct bootup_params));\r\nif (boot_params_20.valid != cpu_to_le32(VALID_20)) {\r\nboot_params->desc_word[7] = cpu_to_le16(UMAC_CLK_20BW);\r\nrsi_dbg(MGMT_TX_ZONE,\r\n"%s: Packet 20MHZ <=== %d\n", __func__,\r\nUMAC_CLK_20BW);\r\n} else {\r\nboot_params->desc_word[7] = cpu_to_le16(UMAC_CLK_40MHZ);\r\nrsi_dbg(MGMT_TX_ZONE,\r\n"%s: Packet 20MHZ <=== %d\n", __func__,\r\nUMAC_CLK_40MHZ);\r\n}\r\n}\r\nboot_params->desc_word[0] = cpu_to_le16(sizeof(struct bootup_params) |\r\n(RSI_WIFI_MGMT_Q << 12));\r\nboot_params->desc_word[1] = cpu_to_le16(BOOTUP_PARAMS_REQUEST);\r\nskb_put(skb, sizeof(struct rsi_boot_params));\r\nreturn rsi_send_internal_mgmt_frame(common, skb);\r\n}\r\nstatic int rsi_send_reset_mac(struct rsi_common *common)\r\n{\r\nstruct sk_buff *skb;\r\nstruct rsi_mac_frame *mgmt_frame;\r\nrsi_dbg(MGMT_TX_ZONE, "%s: Sending reset MAC frame\n", __func__);\r\nskb = dev_alloc_skb(FRAME_DESC_SZ);\r\nif (!skb) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nmemset(skb->data, 0, FRAME_DESC_SZ);\r\nmgmt_frame = (struct rsi_mac_frame *)skb->data;\r\nmgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);\r\nmgmt_frame->desc_word[1] = cpu_to_le16(RESET_MAC_REQ);\r\nmgmt_frame->desc_word[4] = cpu_to_le16(RETRY_COUNT << 8);\r\nskb_put(skb, FRAME_DESC_SZ);\r\nreturn rsi_send_internal_mgmt_frame(common, skb);\r\n}\r\nint rsi_band_check(struct rsi_common *common)\r\n{\r\nstruct rsi_hw *adapter = common->priv;\r\nstruct ieee80211_hw *hw = adapter->hw;\r\nu8 prev_bw = common->channel_width;\r\nu8 prev_ep = common->endpoint;\r\nstruct ieee80211_channel *curchan = hw->conf.chandef.chan;\r\nint status = 0;\r\nif (common->band != curchan->band) {\r\ncommon->rf_reset = 1;\r\ncommon->band = curchan->band;\r\n}\r\nif ((hw->conf.chandef.width == NL80211_CHAN_WIDTH_20_NOHT) ||\r\n(hw->conf.chandef.width == NL80211_CHAN_WIDTH_20))\r\ncommon->channel_width = BW_20MHZ;\r\nelse\r\ncommon->channel_width = BW_40MHZ;\r\nif (common->band == IEEE80211_BAND_2GHZ) {\r\nif (common->channel_width)\r\ncommon->endpoint = EP_2GHZ_40MHZ;\r\nelse\r\ncommon->endpoint = EP_2GHZ_20MHZ;\r\n} else {\r\nif (common->channel_width)\r\ncommon->endpoint = EP_5GHZ_40MHZ;\r\nelse\r\ncommon->endpoint = EP_5GHZ_20MHZ;\r\n}\r\nif (common->endpoint != prev_ep) {\r\nstatus = rsi_program_bb_rf(common);\r\nif (status)\r\nreturn status;\r\n}\r\nif (common->channel_width != prev_bw) {\r\nstatus = rsi_load_bootup_params(common);\r\nif (status)\r\nreturn status;\r\nstatus = rsi_load_radio_caps(common);\r\nif (status)\r\nreturn status;\r\n}\r\nreturn status;\r\n}\r\nint rsi_set_channel(struct rsi_common *common, u16 channel)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nstruct rsi_mac_frame *mgmt_frame;\r\nrsi_dbg(MGMT_TX_ZONE,\r\n"%s: Sending scan req frame\n", __func__);\r\nskb = dev_alloc_skb(FRAME_DESC_SZ);\r\nif (!skb) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nmemset(skb->data, 0, FRAME_DESC_SZ);\r\nmgmt_frame = (struct rsi_mac_frame *)skb->data;\r\nmgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);\r\nmgmt_frame->desc_word[1] = cpu_to_le16(SCAN_REQUEST);\r\nmgmt_frame->desc_word[4] = cpu_to_le16(channel);\r\nmgmt_frame->desc_word[7] = cpu_to_le16(PUT_BBP_RESET |\r\nBBP_REG_WRITE |\r\n(RSI_RF_TYPE << 4));\r\nmgmt_frame->desc_word[5] = cpu_to_le16(0x01);\r\nmgmt_frame->desc_word[6] = cpu_to_le16(0x12);\r\nif (common->channel_width == BW_40MHZ)\r\nmgmt_frame->desc_word[5] |= cpu_to_le16(0x1 << 8);\r\ncommon->channel = channel;\r\nskb_put(skb, FRAME_DESC_SZ);\r\nreturn rsi_send_internal_mgmt_frame(common, skb);\r\n}\r\nstatic int rsi_compare(const void *a, const void *b)\r\n{\r\nu16 _a = *(const u16 *)(a);\r\nu16 _b = *(const u16 *)(b);\r\nif (_a > _b)\r\nreturn -1;\r\nif (_a < _b)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic bool rsi_map_rates(u16 rate, int *offset)\r\n{\r\nint kk;\r\nfor (kk = 0; kk < ARRAY_SIZE(rsi_mcsrates); kk++) {\r\nif (rate == mcs[kk]) {\r\n*offset = kk;\r\nreturn false;\r\n}\r\n}\r\nfor (kk = 0; kk < ARRAY_SIZE(rsi_rates); kk++) {\r\nif (rate == rsi_rates[kk].bitrate / 5) {\r\n*offset = kk;\r\nbreak;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic int rsi_send_auto_rate_request(struct rsi_common *common)\r\n{\r\nstruct sk_buff *skb;\r\nstruct rsi_auto_rate *auto_rate;\r\nint ii = 0, jj = 0, kk = 0;\r\nstruct ieee80211_hw *hw = common->priv->hw;\r\nu8 band = hw->conf.chandef.chan->band;\r\nu8 num_supported_rates = 0;\r\nu8 rate_table_offset, rate_offset = 0;\r\nu32 rate_bitmap = common->bitrate_mask[band];\r\nu16 *selected_rates, min_rate;\r\nskb = dev_alloc_skb(sizeof(struct rsi_auto_rate));\r\nif (!skb) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nselected_rates = kmalloc(2 * RSI_TBL_SZ, GFP_KERNEL);\r\nif (!selected_rates) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed in allocation of mem\n",\r\n__func__);\r\ndev_kfree_skb(skb);\r\nreturn -ENOMEM;\r\n}\r\nmemset(skb->data, 0, sizeof(struct rsi_auto_rate));\r\nmemset(selected_rates, 0, 2 * RSI_TBL_SZ);\r\nauto_rate = (struct rsi_auto_rate *)skb->data;\r\nauto_rate->aarf_rssi = cpu_to_le16(((u16)3 << 6) | (u16)(18 & 0x3f));\r\nauto_rate->collision_tolerance = cpu_to_le16(3);\r\nauto_rate->failure_limit = cpu_to_le16(3);\r\nauto_rate->initial_boundary = cpu_to_le16(3);\r\nauto_rate->max_threshold_limt = cpu_to_le16(27);\r\nauto_rate->desc_word[1] = cpu_to_le16(AUTO_RATE_IND);\r\nif (common->channel_width == BW_40MHZ)\r\nauto_rate->desc_word[7] |= cpu_to_le16(1);\r\nif (band == IEEE80211_BAND_2GHZ) {\r\nmin_rate = RSI_RATE_1;\r\nrate_table_offset = 0;\r\n} else {\r\nmin_rate = RSI_RATE_6;\r\nrate_table_offset = 4;\r\n}\r\nfor (ii = 0, jj = 0;\r\nii < (ARRAY_SIZE(rsi_rates) - rate_table_offset); ii++) {\r\nif (rate_bitmap & BIT(ii)) {\r\nselected_rates[jj++] =\r\n(rsi_rates[ii + rate_table_offset].bitrate / 5);\r\nrate_offset++;\r\n}\r\n}\r\nnum_supported_rates = jj;\r\nif (common->vif_info[0].is_ht) {\r\nfor (ii = 0; ii < ARRAY_SIZE(mcs); ii++)\r\nselected_rates[jj++] = mcs[ii];\r\nnum_supported_rates += ARRAY_SIZE(mcs);\r\nrate_offset += ARRAY_SIZE(mcs);\r\n}\r\nsort(selected_rates, jj, sizeof(u16), &rsi_compare, NULL);\r\nfor (ii = 0; ii < jj; ii++) {\r\nif (rsi_map_rates(selected_rates[ii], &kk)) {\r\nauto_rate->supported_rates[ii] =\r\ncpu_to_le16(rsi_rates[kk].hw_value);\r\n} else {\r\nauto_rate->supported_rates[ii] =\r\ncpu_to_le16(rsi_mcsrates[kk]);\r\n}\r\n}\r\nif (common->vif_info[0].is_ht) {\r\nfor (ii = rate_offset, kk = ARRAY_SIZE(rsi_mcsrates) - 1;\r\nii < rate_offset + 2 * ARRAY_SIZE(rsi_mcsrates); ii++) {\r\nif (common->vif_info[0].sgi ||\r\nconf_is_ht40(&common->priv->hw->conf))\r\nauto_rate->supported_rates[ii++] =\r\ncpu_to_le16(rsi_mcsrates[kk] | BIT(9));\r\nauto_rate->supported_rates[ii] =\r\ncpu_to_le16(rsi_mcsrates[kk--]);\r\n}\r\nfor (; ii < (RSI_TBL_SZ - 1); ii++) {\r\nauto_rate->supported_rates[ii] =\r\ncpu_to_le16(rsi_mcsrates[0]);\r\n}\r\n}\r\nfor (; ii < RSI_TBL_SZ; ii++)\r\nauto_rate->supported_rates[ii] = cpu_to_le16(min_rate);\r\nauto_rate->num_supported_rates = cpu_to_le16(num_supported_rates * 2);\r\nauto_rate->moderate_rate_inx = cpu_to_le16(num_supported_rates / 2);\r\nauto_rate->desc_word[7] |= cpu_to_le16(0 << 8);\r\nnum_supported_rates *= 2;\r\nauto_rate->desc_word[0] = cpu_to_le16((sizeof(*auto_rate) -\r\nFRAME_DESC_SZ) |\r\n(RSI_WIFI_MGMT_Q << 12));\r\nskb_put(skb,\r\nsizeof(struct rsi_auto_rate));\r\nkfree(selected_rates);\r\nreturn rsi_send_internal_mgmt_frame(common, skb);\r\n}\r\nvoid rsi_inform_bss_status(struct rsi_common *common,\r\nu8 status,\r\nconst unsigned char *bssid,\r\nu8 qos_enable,\r\nu16 aid)\r\n{\r\nif (status) {\r\nrsi_hal_send_sta_notify_frame(common,\r\nRSI_IFTYPE_STATION,\r\nSTA_CONNECTED,\r\nbssid,\r\nqos_enable,\r\naid);\r\nif (common->min_rate == 0xffff)\r\nrsi_send_auto_rate_request(common);\r\n} else {\r\nrsi_hal_send_sta_notify_frame(common,\r\nRSI_IFTYPE_STATION,\r\nSTA_DISCONNECTED,\r\nbssid,\r\nqos_enable,\r\naid);\r\n}\r\n}\r\nstatic int rsi_eeprom_read(struct rsi_common *common)\r\n{\r\nstruct rsi_mac_frame *mgmt_frame;\r\nstruct sk_buff *skb;\r\nrsi_dbg(MGMT_TX_ZONE, "%s: Sending EEPROM read req frame\n", __func__);\r\nskb = dev_alloc_skb(FRAME_DESC_SZ);\r\nif (!skb) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nmemset(skb->data, 0, FRAME_DESC_SZ);\r\nmgmt_frame = (struct rsi_mac_frame *)skb->data;\r\nmgmt_frame->desc_word[1] = cpu_to_le16(EEPROM_READ_TYPE);\r\nmgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);\r\nmgmt_frame->desc_word[3] = cpu_to_le16(ETH_ALEN +\r\nWLAN_MAC_MAGIC_WORD_LEN +\r\nWLAN_HOST_MODE_LEN +\r\nWLAN_FW_VERSION_LEN);\r\nmgmt_frame->desc_word[4] = cpu_to_le16(WLAN_MAC_EEPROM_ADDR);\r\nskb_put(skb, FRAME_DESC_SZ);\r\nreturn rsi_send_internal_mgmt_frame(common, skb);\r\n}\r\nint rsi_send_block_unblock_frame(struct rsi_common *common, bool block_event)\r\n{\r\nstruct rsi_mac_frame *mgmt_frame;\r\nstruct sk_buff *skb;\r\nrsi_dbg(MGMT_TX_ZONE, "%s: Sending block/unblock frame\n", __func__);\r\nskb = dev_alloc_skb(FRAME_DESC_SZ);\r\nif (!skb) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nmemset(skb->data, 0, FRAME_DESC_SZ);\r\nmgmt_frame = (struct rsi_mac_frame *)skb->data;\r\nmgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);\r\nmgmt_frame->desc_word[1] = cpu_to_le16(BLOCK_HW_QUEUE);\r\nif (block_event == true) {\r\nrsi_dbg(INFO_ZONE, "blocking the data qs\n");\r\nmgmt_frame->desc_word[4] = cpu_to_le16(0xf);\r\n} else {\r\nrsi_dbg(INFO_ZONE, "unblocking the data qs\n");\r\nmgmt_frame->desc_word[5] = cpu_to_le16(0xf);\r\n}\r\nskb_put(skb, FRAME_DESC_SZ);\r\nreturn rsi_send_internal_mgmt_frame(common, skb);\r\n}\r\nstatic int rsi_handle_ta_confirm_type(struct rsi_common *common,\r\nu8 *msg)\r\n{\r\nu8 sub_type = (msg[15] & 0xff);\r\nswitch (sub_type) {\r\ncase BOOTUP_PARAMS_REQUEST:\r\nrsi_dbg(FSM_ZONE, "%s: Boot up params confirm received\n",\r\n__func__);\r\nif (common->fsm_state == FSM_BOOT_PARAMS_SENT) {\r\nif (rsi_eeprom_read(common)) {\r\ncommon->fsm_state = FSM_CARD_NOT_READY;\r\ngoto out;\r\n} else {\r\ncommon->fsm_state = FSM_EEPROM_READ_MAC_ADDR;\r\n}\r\n} else {\r\nrsi_dbg(INFO_ZONE,\r\n"%s: Received bootup params cfm in %d state\n",\r\n__func__, common->fsm_state);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase EEPROM_READ_TYPE:\r\nif (common->fsm_state == FSM_EEPROM_READ_MAC_ADDR) {\r\nif (msg[16] == MAGIC_WORD) {\r\nu8 offset = (FRAME_DESC_SZ + WLAN_HOST_MODE_LEN\r\n+ WLAN_MAC_MAGIC_WORD_LEN);\r\nmemcpy(common->mac_addr,\r\n&msg[offset],\r\nETH_ALEN);\r\nmemcpy(&common->fw_ver,\r\n&msg[offset + ETH_ALEN],\r\nsizeof(struct version_info));\r\n} else {\r\ncommon->fsm_state = FSM_CARD_NOT_READY;\r\nbreak;\r\n}\r\nif (rsi_send_reset_mac(common))\r\ngoto out;\r\nelse\r\ncommon->fsm_state = FSM_RESET_MAC_SENT;\r\n} else {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Received eeprom mac addr in %d state\n",\r\n__func__, common->fsm_state);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase RESET_MAC_REQ:\r\nif (common->fsm_state == FSM_RESET_MAC_SENT) {\r\nrsi_dbg(FSM_ZONE, "%s: Reset MAC cfm received\n",\r\n__func__);\r\nif (rsi_load_radio_caps(common))\r\ngoto out;\r\nelse\r\ncommon->fsm_state = FSM_RADIO_CAPS_SENT;\r\n} else {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Received reset mac cfm in %d state\n",\r\n__func__, common->fsm_state);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase RADIO_CAPABILITIES:\r\nif (common->fsm_state == FSM_RADIO_CAPS_SENT) {\r\ncommon->rf_reset = 1;\r\nif (rsi_program_bb_rf(common)) {\r\ngoto out;\r\n} else {\r\ncommon->fsm_state = FSM_BB_RF_PROG_SENT;\r\nrsi_dbg(FSM_ZONE, "%s: Radio cap cfm received\n",\r\n__func__);\r\n}\r\n} else {\r\nrsi_dbg(INFO_ZONE,\r\n"%s: Received radio caps cfm in %d state\n",\r\n__func__, common->fsm_state);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase BB_PROG_VALUES_REQUEST:\r\ncase RF_PROG_VALUES_REQUEST:\r\ncase BBP_PROG_IN_TA:\r\nrsi_dbg(FSM_ZONE, "%s: BB/RF cfm received\n", __func__);\r\nif (common->fsm_state == FSM_BB_RF_PROG_SENT) {\r\ncommon->bb_rf_prog_count--;\r\nif (!common->bb_rf_prog_count) {\r\ncommon->fsm_state = FSM_MAC_INIT_DONE;\r\nreturn rsi_mac80211_attach(common);\r\n}\r\n} else {\r\nrsi_dbg(INFO_ZONE,\r\n"%s: Received bbb_rf cfm in %d state\n",\r\n__func__, common->fsm_state);\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nrsi_dbg(INFO_ZONE, "%s: Invalid TA confirm pkt received\n",\r\n__func__);\r\nbreak;\r\n}\r\nreturn 0;\r\nout:\r\nrsi_dbg(ERR_ZONE, "%s: Unable to send pkt/Invalid frame received\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nint rsi_mgmt_pkt_recv(struct rsi_common *common, u8 *msg)\r\n{\r\ns32 msg_len = (le16_to_cpu(*(__le16 *)&msg[0]) & 0x0fff);\r\nu16 msg_type = (msg[2]);\r\nint ret;\r\nrsi_dbg(FSM_ZONE, "%s: Msg Len: %d, Msg Type: %4x\n",\r\n__func__, msg_len, msg_type);\r\nif (msg_type == TA_CONFIRM_TYPE) {\r\nreturn rsi_handle_ta_confirm_type(common, msg);\r\n} else if (msg_type == CARD_READY_IND) {\r\nrsi_dbg(FSM_ZONE, "%s: Card ready indication received\n",\r\n__func__);\r\nif (common->fsm_state == FSM_CARD_NOT_READY) {\r\nrsi_set_default_parameters(common);\r\nret = rsi_load_bootup_params(common);\r\nif (ret)\r\nreturn ret;\r\nelse\r\ncommon->fsm_state = FSM_BOOT_PARAMS_SENT;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n} else if (msg_type == TX_STATUS_IND) {\r\nif (msg[15] == PROBEREQ_CONFIRM) {\r\ncommon->mgmt_q_block = false;\r\nrsi_dbg(FSM_ZONE, "%s: Probe confirm received\n",\r\n__func__);\r\n}\r\n} else {\r\nreturn rsi_mgmt_pkt_to_core(common, msg, msg_len, msg_type);\r\n}\r\nreturn 0;\r\n}
