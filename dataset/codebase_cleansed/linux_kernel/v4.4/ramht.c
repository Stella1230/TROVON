static u32\r\nnvkm_ramht_hash(struct nvkm_ramht *ramht, int chid, u32 handle)\r\n{\r\nu32 hash = 0;\r\nwhile (handle) {\r\nhash ^= (handle & ((1 << ramht->bits) - 1));\r\nhandle >>= ramht->bits;\r\n}\r\nhash ^= chid << (ramht->bits - 4);\r\nreturn hash;\r\n}\r\nstruct nvkm_gpuobj *\r\nnvkm_ramht_search(struct nvkm_ramht *ramht, int chid, u32 handle)\r\n{\r\nu32 co, ho;\r\nco = ho = nvkm_ramht_hash(ramht, chid, handle);\r\ndo {\r\nif (ramht->data[co].chid == chid) {\r\nif (ramht->data[co].handle == handle)\r\nreturn ramht->data[co].inst;\r\n}\r\nif (++co >= ramht->size)\r\nco = 0;\r\n} while (co != ho);\r\nreturn NULL;\r\n}\r\nstatic int\r\nnvkm_ramht_update(struct nvkm_ramht *ramht, int co, struct nvkm_object *object,\r\nint chid, int addr, u32 handle, u32 context)\r\n{\r\nstruct nvkm_ramht_data *data = &ramht->data[co];\r\nu64 inst = 0x00000040;\r\nint ret;\r\nnvkm_gpuobj_del(&data->inst);\r\ndata->chid = chid;\r\ndata->handle = handle;\r\nif (object) {\r\nret = nvkm_object_bind(object, ramht->parent, 16, &data->inst);\r\nif (ret) {\r\nif (ret != -ENODEV) {\r\ndata->chid = -1;\r\nreturn ret;\r\n}\r\ndata->inst = NULL;\r\n}\r\nif (data->inst) {\r\nif (ramht->device->card_type >= NV_50)\r\ninst = data->inst->node->offset;\r\nelse\r\ninst = data->inst->addr;\r\n}\r\nif (addr < 0) context |= inst << -addr;\r\nelse context |= inst >> addr;\r\n}\r\nnvkm_kmap(ramht->gpuobj);\r\nnvkm_wo32(ramht->gpuobj, (co << 3) + 0, handle);\r\nnvkm_wo32(ramht->gpuobj, (co << 3) + 4, context);\r\nnvkm_done(ramht->gpuobj);\r\nreturn co + 1;\r\n}\r\nvoid\r\nnvkm_ramht_remove(struct nvkm_ramht *ramht, int cookie)\r\n{\r\nif (--cookie >= 0)\r\nnvkm_ramht_update(ramht, cookie, NULL, -1, 0, 0, 0);\r\n}\r\nint\r\nnvkm_ramht_insert(struct nvkm_ramht *ramht, struct nvkm_object *object,\r\nint chid, int addr, u32 handle, u32 context)\r\n{\r\nu32 co, ho;\r\nif (nvkm_ramht_search(ramht, chid, handle))\r\nreturn -EEXIST;\r\nco = ho = nvkm_ramht_hash(ramht, chid, handle);\r\ndo {\r\nif (ramht->data[co].chid < 0) {\r\nreturn nvkm_ramht_update(ramht, co, object, chid,\r\naddr, handle, context);\r\n}\r\nif (++co >= ramht->size)\r\nco = 0;\r\n} while (co != ho);\r\nreturn -ENOSPC;\r\n}\r\nvoid\r\nnvkm_ramht_del(struct nvkm_ramht **pramht)\r\n{\r\nstruct nvkm_ramht *ramht = *pramht;\r\nif (ramht) {\r\nnvkm_gpuobj_del(&ramht->gpuobj);\r\nkfree(*pramht);\r\n*pramht = NULL;\r\n}\r\n}\r\nint\r\nnvkm_ramht_new(struct nvkm_device *device, u32 size, u32 align,\r\nstruct nvkm_gpuobj *parent, struct nvkm_ramht **pramht)\r\n{\r\nstruct nvkm_ramht *ramht;\r\nint ret, i;\r\nif (!(ramht = *pramht = kzalloc(sizeof(*ramht) + (size >> 3) *\r\nsizeof(*ramht->data), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nramht->device = device;\r\nramht->parent = parent;\r\nramht->size = size >> 3;\r\nramht->bits = order_base_2(ramht->size);\r\nfor (i = 0; i < ramht->size; i++)\r\nramht->data[i].chid = -1;\r\nret = nvkm_gpuobj_new(ramht->device, size, align, true,\r\nramht->parent, &ramht->gpuobj);\r\nif (ret)\r\nnvkm_ramht_del(pramht);\r\nreturn ret;\r\n}
