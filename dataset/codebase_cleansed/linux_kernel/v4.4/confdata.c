static void conf_warning(const char *fmt, ...)\r\n{\r\nva_list ap;\r\nva_start(ap, fmt);\r\nfprintf(stderr, "%s:%d:warning: ", conf_filename, conf_lineno);\r\nvfprintf(stderr, fmt, ap);\r\nfprintf(stderr, "\n");\r\nva_end(ap);\r\nconf_warnings++;\r\n}\r\nstatic void conf_default_message_callback(const char *fmt, va_list ap)\r\n{\r\nprintf("#\n# ");\r\nvprintf(fmt, ap);\r\nprintf("\n#\n");\r\n}\r\nvoid conf_set_message_callback(void (*fn) (const char *fmt, va_list ap))\r\n{\r\nconf_message_callback = fn;\r\n}\r\nstatic void conf_message(const char *fmt, ...)\r\n{\r\nva_list ap;\r\nva_start(ap, fmt);\r\nif (conf_message_callback)\r\nconf_message_callback(fmt, ap);\r\nva_end(ap);\r\n}\r\nconst char *conf_get_configname(void)\r\n{\r\nchar *name = getenv("KCONFIG_CONFIG");\r\nreturn name ? name : ".config";\r\n}\r\nconst char *conf_get_autoconfig_name(void)\r\n{\r\nchar *name = getenv("KCONFIG_AUTOCONFIG");\r\nreturn name ? name : "include/config/auto.conf";\r\n}\r\nstatic char *conf_expand_value(const char *in)\r\n{\r\nstruct symbol *sym;\r\nconst char *src;\r\nstatic char res_value[SYMBOL_MAXLENGTH];\r\nchar *dst, name[SYMBOL_MAXLENGTH];\r\nres_value[0] = 0;\r\ndst = name;\r\nwhile ((src = strchr(in, '$'))) {\r\nstrncat(res_value, in, src - in);\r\nsrc++;\r\ndst = name;\r\nwhile (isalnum(*src) || *src == '_')\r\n*dst++ = *src++;\r\n*dst = 0;\r\nsym = sym_lookup(name, 0);\r\nsym_calc_value(sym);\r\nstrcat(res_value, sym_get_string_value(sym));\r\nin = src;\r\n}\r\nstrcat(res_value, in);\r\nreturn res_value;\r\n}\r\nchar *conf_get_default_confname(void)\r\n{\r\nstruct stat buf;\r\nstatic char fullname[PATH_MAX+1];\r\nchar *env, *name;\r\nname = conf_expand_value(conf_defname);\r\nenv = getenv(SRCTREE);\r\nif (env) {\r\nsprintf(fullname, "%s/%s", env, name);\r\nif (!stat(fullname, &buf))\r\nreturn fullname;\r\n}\r\nreturn name;\r\n}\r\nstatic int conf_set_sym_val(struct symbol *sym, int def, int def_flags, char *p)\r\n{\r\nchar *p2;\r\nswitch (sym->type) {\r\ncase S_TRISTATE:\r\nif (p[0] == 'm') {\r\nsym->def[def].tri = mod;\r\nsym->flags |= def_flags;\r\nbreak;\r\n}\r\ncase S_BOOLEAN:\r\nif (p[0] == 'y') {\r\nsym->def[def].tri = yes;\r\nsym->flags |= def_flags;\r\nbreak;\r\n}\r\nif (p[0] == 'n') {\r\nsym->def[def].tri = no;\r\nsym->flags |= def_flags;\r\nbreak;\r\n}\r\nif (def != S_DEF_AUTO)\r\nconf_warning("symbol value '%s' invalid for %s",\r\np, sym->name);\r\nreturn 1;\r\ncase S_OTHER:\r\nif (*p != '"') {\r\nfor (p2 = p; *p2 && !isspace(*p2); p2++)\r\n;\r\nsym->type = S_STRING;\r\ngoto done;\r\n}\r\ncase S_STRING:\r\nif (*p++ != '"')\r\nbreak;\r\nfor (p2 = p; (p2 = strpbrk(p2, "\"\\")); p2++) {\r\nif (*p2 == '"') {\r\n*p2 = 0;\r\nbreak;\r\n}\r\nmemmove(p2, p2 + 1, strlen(p2));\r\n}\r\nif (!p2) {\r\nif (def != S_DEF_AUTO)\r\nconf_warning("invalid string found");\r\nreturn 1;\r\n}\r\ncase S_INT:\r\ncase S_HEX:\r\ndone:\r\nif (sym_string_valid(sym, p)) {\r\nsym->def[def].val = strdup(p);\r\nsym->flags |= def_flags;\r\n} else {\r\nif (def != S_DEF_AUTO)\r\nconf_warning("symbol value '%s' invalid for %s",\r\np, sym->name);\r\nreturn 1;\r\n}\r\nbreak;\r\ndefault:\r\n;\r\n}\r\nreturn 0;\r\n}\r\nstatic int add_byte(int c, char **lineptr, size_t slen, size_t *n)\r\n{\r\nchar *nline;\r\nsize_t new_size = slen + 1;\r\nif (new_size > *n) {\r\nnew_size += LINE_GROWTH - 1;\r\nnew_size *= 2;\r\nnline = realloc(*lineptr, new_size);\r\nif (!nline)\r\nreturn -1;\r\n*lineptr = nline;\r\n*n = new_size;\r\n}\r\n(*lineptr)[slen] = c;\r\nreturn 0;\r\n}\r\nstatic ssize_t compat_getline(char **lineptr, size_t *n, FILE *stream)\r\n{\r\nchar *line = *lineptr;\r\nsize_t slen = 0;\r\nfor (;;) {\r\nint c = getc(stream);\r\nswitch (c) {\r\ncase '\n':\r\nif (add_byte(c, &line, slen, n) < 0)\r\ngoto e_out;\r\nslen++;\r\ncase EOF:\r\nif (add_byte('\0', &line, slen, n) < 0)\r\ngoto e_out;\r\n*lineptr = line;\r\nif (slen == 0)\r\nreturn -1;\r\nreturn slen;\r\ndefault:\r\nif (add_byte(c, &line, slen, n) < 0)\r\ngoto e_out;\r\nslen++;\r\n}\r\n}\r\ne_out:\r\nline[slen-1] = '\0';\r\n*lineptr = line;\r\nreturn -1;\r\n}\r\nint conf_read_simple(const char *name, int def)\r\n{\r\nFILE *in = NULL;\r\nchar *line = NULL;\r\nsize_t line_asize = 0;\r\nchar *p, *p2;\r\nstruct symbol *sym;\r\nint i, def_flags;\r\nif (name) {\r\nin = zconf_fopen(name);\r\n} else {\r\nstruct property *prop;\r\nname = conf_get_configname();\r\nin = zconf_fopen(name);\r\nif (in)\r\ngoto load;\r\nsym_add_change_count(1);\r\nif (!sym_defconfig_list) {\r\nsym_calc_value(modules_sym);\r\nreturn 1;\r\n}\r\nfor_all_defaults(sym_defconfig_list, prop) {\r\nif (expr_calc_value(prop->visible.expr) == no ||\r\nprop->expr->type != E_SYMBOL)\r\ncontinue;\r\nname = conf_expand_value(prop->expr->left.sym->name);\r\nin = zconf_fopen(name);\r\nif (in) {\r\nconf_message(_("using defaults found in %s"),\r\nname);\r\ngoto load;\r\n}\r\n}\r\n}\r\nif (!in)\r\nreturn 1;\r\nload:\r\nconf_filename = name;\r\nconf_lineno = 0;\r\nconf_warnings = 0;\r\nconf_unsaved = 0;\r\ndef_flags = SYMBOL_DEF << def;\r\nfor_all_symbols(i, sym) {\r\nsym->flags |= SYMBOL_CHANGED;\r\nsym->flags &= ~(def_flags|SYMBOL_VALID);\r\nif (sym_is_choice(sym))\r\nsym->flags |= def_flags;\r\nswitch (sym->type) {\r\ncase S_INT:\r\ncase S_HEX:\r\ncase S_STRING:\r\nif (sym->def[def].val)\r\nfree(sym->def[def].val);\r\ndefault:\r\nsym->def[def].val = NULL;\r\nsym->def[def].tri = no;\r\n}\r\n}\r\nwhile (compat_getline(&line, &line_asize, in) != -1) {\r\nconf_lineno++;\r\nsym = NULL;\r\nif (line[0] == '#') {\r\nif (memcmp(line + 2, CONFIG_, strlen(CONFIG_)))\r\ncontinue;\r\np = strchr(line + 2 + strlen(CONFIG_), ' ');\r\nif (!p)\r\ncontinue;\r\n*p++ = 0;\r\nif (strncmp(p, "is not set", 10))\r\ncontinue;\r\nif (def == S_DEF_USER) {\r\nsym = sym_find(line + 2 + strlen(CONFIG_));\r\nif (!sym) {\r\nsym_add_change_count(1);\r\ngoto setsym;\r\n}\r\n} else {\r\nsym = sym_lookup(line + 2 + strlen(CONFIG_), 0);\r\nif (sym->type == S_UNKNOWN)\r\nsym->type = S_BOOLEAN;\r\n}\r\nif (sym->flags & def_flags) {\r\nconf_warning("override: reassigning to symbol %s", sym->name);\r\n}\r\nswitch (sym->type) {\r\ncase S_BOOLEAN:\r\ncase S_TRISTATE:\r\nsym->def[def].tri = no;\r\nsym->flags |= def_flags;\r\nbreak;\r\ndefault:\r\n;\r\n}\r\n} else if (memcmp(line, CONFIG_, strlen(CONFIG_)) == 0) {\r\np = strchr(line + strlen(CONFIG_), '=');\r\nif (!p)\r\ncontinue;\r\n*p++ = 0;\r\np2 = strchr(p, '\n');\r\nif (p2) {\r\n*p2-- = 0;\r\nif (*p2 == '\r')\r\n*p2 = 0;\r\n}\r\nif (def == S_DEF_USER) {\r\nsym = sym_find(line + strlen(CONFIG_));\r\nif (!sym) {\r\nsym_add_change_count(1);\r\ngoto setsym;\r\n}\r\n} else {\r\nsym = sym_lookup(line + strlen(CONFIG_), 0);\r\nif (sym->type == S_UNKNOWN)\r\nsym->type = S_OTHER;\r\n}\r\nif (sym->flags & def_flags) {\r\nconf_warning("override: reassigning to symbol %s", sym->name);\r\n}\r\nif (conf_set_sym_val(sym, def, def_flags, p))\r\ncontinue;\r\n} else {\r\nif (line[0] != '\r' && line[0] != '\n')\r\nconf_warning("unexpected data");\r\ncontinue;\r\n}\r\nsetsym:\r\nif (sym && sym_is_choice_value(sym)) {\r\nstruct symbol *cs = prop_get_symbol(sym_get_choice_prop(sym));\r\nswitch (sym->def[def].tri) {\r\ncase no:\r\nbreak;\r\ncase mod:\r\nif (cs->def[def].tri == yes) {\r\nconf_warning("%s creates inconsistent choice state", sym->name);\r\ncs->flags &= ~def_flags;\r\n}\r\nbreak;\r\ncase yes:\r\nif (cs->def[def].tri != no)\r\nconf_warning("override: %s changes choice state", sym->name);\r\ncs->def[def].val = sym;\r\nbreak;\r\n}\r\ncs->def[def].tri = EXPR_OR(cs->def[def].tri, sym->def[def].tri);\r\n}\r\n}\r\nfree(line);\r\nfclose(in);\r\nsym_calc_value(modules_sym);\r\nreturn 0;\r\n}\r\nint conf_read(const char *name)\r\n{\r\nstruct symbol *sym;\r\nint i;\r\nsym_set_change_count(0);\r\nif (conf_read_simple(name, S_DEF_USER))\r\nreturn 1;\r\nfor_all_symbols(i, sym) {\r\nsym_calc_value(sym);\r\nif (sym_is_choice(sym) || (sym->flags & SYMBOL_AUTO))\r\ncontinue;\r\nif (sym_has_value(sym) && (sym->flags & SYMBOL_WRITE)) {\r\nswitch (sym->type) {\r\ncase S_BOOLEAN:\r\ncase S_TRISTATE:\r\nif (sym->def[S_DEF_USER].tri != sym_get_tristate_value(sym))\r\nbreak;\r\nif (!sym_is_choice(sym))\r\ncontinue;\r\ndefault:\r\nif (!strcmp(sym->curr.val, sym->def[S_DEF_USER].val))\r\ncontinue;\r\nbreak;\r\n}\r\n} else if (!sym_has_value(sym) && !(sym->flags & SYMBOL_WRITE))\r\ncontinue;\r\nconf_unsaved++;\r\n}\r\nfor_all_symbols(i, sym) {\r\nif (sym_has_value(sym) && !sym_is_choice_value(sym)) {\r\nif (sym->visible == no && !conf_unsaved)\r\nsym->flags &= ~SYMBOL_DEF_USER;\r\nswitch (sym->type) {\r\ncase S_STRING:\r\ncase S_INT:\r\ncase S_HEX:\r\nif (sym_string_within_range(sym, sym->def[S_DEF_USER].val))\r\nbreak;\r\nsym->flags &= ~(SYMBOL_VALID|SYMBOL_DEF_USER);\r\nconf_unsaved++;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nsym_add_change_count(conf_warnings || conf_unsaved);\r\nreturn 0;\r\n}\r\nstatic void\r\nkconfig_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)\r\n{\r\nswitch (sym->type) {\r\ncase S_BOOLEAN:\r\ncase S_TRISTATE:\r\nif (*value == 'n') {\r\nbool skip_unset = (arg != NULL);\r\nif (!skip_unset)\r\nfprintf(fp, "# %s%s is not set\n",\r\nCONFIG_, sym->name);\r\nreturn;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfprintf(fp, "%s%s=%s\n", CONFIG_, sym->name, value);\r\n}\r\nstatic void\r\nkconfig_print_comment(FILE *fp, const char *value, void *arg)\r\n{\r\nconst char *p = value;\r\nsize_t l;\r\nfor (;;) {\r\nl = strcspn(p, "\n");\r\nfprintf(fp, "#");\r\nif (l) {\r\nfprintf(fp, " ");\r\nxfwrite(p, l, 1, fp);\r\np += l;\r\n}\r\nfprintf(fp, "\n");\r\nif (*p++ == '\0')\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nheader_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)\r\n{\r\nswitch (sym->type) {\r\ncase S_BOOLEAN:\r\ncase S_TRISTATE: {\r\nconst char *suffix = "";\r\nswitch (*value) {\r\ncase 'n':\r\nbreak;\r\ncase 'm':\r\nsuffix = "_MODULE";\r\ndefault:\r\nfprintf(fp, "#define %s%s%s 1\n",\r\nCONFIG_, sym->name, suffix);\r\n}\r\nbreak;\r\n}\r\ncase S_HEX: {\r\nconst char *prefix = "";\r\nif (value[0] != '0' || (value[1] != 'x' && value[1] != 'X'))\r\nprefix = "0x";\r\nfprintf(fp, "#define %s%s %s%s\n",\r\nCONFIG_, sym->name, prefix, value);\r\nbreak;\r\n}\r\ncase S_STRING:\r\ncase S_INT:\r\nfprintf(fp, "#define %s%s %s\n",\r\nCONFIG_, sym->name, value);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nheader_print_comment(FILE *fp, const char *value, void *arg)\r\n{\r\nconst char *p = value;\r\nsize_t l;\r\nfprintf(fp, "/*\n");\r\nfor (;;) {\r\nl = strcspn(p, "\n");\r\nfprintf(fp, " *");\r\nif (l) {\r\nfprintf(fp, " ");\r\nxfwrite(p, l, 1, fp);\r\np += l;\r\n}\r\nfprintf(fp, "\n");\r\nif (*p++ == '\0')\r\nbreak;\r\n}\r\nfprintf(fp, " */\n");\r\n}\r\nstatic void\r\ntristate_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)\r\n{\r\nif (sym->type == S_TRISTATE && *value != 'n')\r\nfprintf(fp, "%s%s=%c\n", CONFIG_, sym->name, (char)toupper(*value));\r\n}\r\nstatic void conf_write_symbol(FILE *fp, struct symbol *sym,\r\nstruct conf_printer *printer, void *printer_arg)\r\n{\r\nconst char *str;\r\nswitch (sym->type) {\r\ncase S_OTHER:\r\ncase S_UNKNOWN:\r\nbreak;\r\ncase S_STRING:\r\nstr = sym_get_string_value(sym);\r\nstr = sym_escape_string_value(str);\r\nprinter->print_symbol(fp, sym, str, printer_arg);\r\nfree((void *)str);\r\nbreak;\r\ndefault:\r\nstr = sym_get_string_value(sym);\r\nprinter->print_symbol(fp, sym, str, printer_arg);\r\n}\r\n}\r\nstatic void\r\nconf_write_heading(FILE *fp, struct conf_printer *printer, void *printer_arg)\r\n{\r\nchar buf[256];\r\nsnprintf(buf, sizeof(buf),\r\n"\n"\r\n"Automatically generated file; DO NOT EDIT.\n"\r\n"%s\n",\r\nrootmenu.prompt->text);\r\nprinter->print_comment(fp, buf, printer_arg);\r\n}\r\nint conf_write_defconfig(const char *filename)\r\n{\r\nstruct symbol *sym;\r\nstruct menu *menu;\r\nFILE *out;\r\nout = fopen(filename, "w");\r\nif (!out)\r\nreturn 1;\r\nsym_clear_all_valid();\r\nmenu = rootmenu.list;\r\nwhile (menu != NULL)\r\n{\r\nsym = menu->sym;\r\nif (sym == NULL) {\r\nif (!menu_is_visible(menu))\r\ngoto next_menu;\r\n} else if (!sym_is_choice(sym)) {\r\nsym_calc_value(sym);\r\nif (!(sym->flags & SYMBOL_WRITE))\r\ngoto next_menu;\r\nsym->flags &= ~SYMBOL_WRITE;\r\nif (!sym_is_changable(sym))\r\ngoto next_menu;\r\nif (strcmp(sym_get_string_value(sym), sym_get_string_default(sym)) == 0)\r\ngoto next_menu;\r\nif (sym_is_choice_value(sym)) {\r\nstruct symbol *cs;\r\nstruct symbol *ds;\r\ncs = prop_get_symbol(sym_get_choice_prop(sym));\r\nds = sym_choice_default(cs);\r\nif (!sym_is_optional(cs) && sym == ds) {\r\nif ((sym->type == S_BOOLEAN) &&\r\nsym_get_tristate_value(sym) == yes)\r\ngoto next_menu;\r\n}\r\n}\r\nconf_write_symbol(out, sym, &kconfig_printer_cb, NULL);\r\n}\r\nnext_menu:\r\nif (menu->list != NULL) {\r\nmenu = menu->list;\r\n}\r\nelse if (menu->next != NULL) {\r\nmenu = menu->next;\r\n} else {\r\nwhile ((menu = menu->parent)) {\r\nif (menu->next != NULL) {\r\nmenu = menu->next;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nfclose(out);\r\nreturn 0;\r\n}\r\nint conf_write(const char *name)\r\n{\r\nFILE *out;\r\nstruct symbol *sym;\r\nstruct menu *menu;\r\nconst char *basename;\r\nconst char *str;\r\nchar dirname[PATH_MAX+1], tmpname[PATH_MAX+1], newname[PATH_MAX+1];\r\nchar *env;\r\ndirname[0] = 0;\r\nif (name && name[0]) {\r\nstruct stat st;\r\nchar *slash;\r\nif (!stat(name, &st) && S_ISDIR(st.st_mode)) {\r\nstrcpy(dirname, name);\r\nstrcat(dirname, "/");\r\nbasename = conf_get_configname();\r\n} else if ((slash = strrchr(name, '/'))) {\r\nint size = slash - name + 1;\r\nmemcpy(dirname, name, size);\r\ndirname[size] = 0;\r\nif (slash[1])\r\nbasename = slash + 1;\r\nelse\r\nbasename = conf_get_configname();\r\n} else\r\nbasename = name;\r\n} else\r\nbasename = conf_get_configname();\r\nsprintf(newname, "%s%s", dirname, basename);\r\nenv = getenv("KCONFIG_OVERWRITECONFIG");\r\nif (!env || !*env) {\r\nsprintf(tmpname, "%s.tmpconfig.%d", dirname, (int)getpid());\r\nout = fopen(tmpname, "w");\r\n} else {\r\n*tmpname = 0;\r\nout = fopen(newname, "w");\r\n}\r\nif (!out)\r\nreturn 1;\r\nconf_write_heading(out, &kconfig_printer_cb, NULL);\r\nif (!conf_get_changed())\r\nsym_clear_all_valid();\r\nmenu = rootmenu.list;\r\nwhile (menu) {\r\nsym = menu->sym;\r\nif (!sym) {\r\nif (!menu_is_visible(menu))\r\ngoto next;\r\nstr = menu_get_prompt(menu);\r\nfprintf(out, "\n"\r\n"#\n"\r\n"# %s\n"\r\n"#\n", str);\r\n} else if (!(sym->flags & SYMBOL_CHOICE)) {\r\nsym_calc_value(sym);\r\nif (!(sym->flags & SYMBOL_WRITE))\r\ngoto next;\r\nsym->flags &= ~SYMBOL_WRITE;\r\nconf_write_symbol(out, sym, &kconfig_printer_cb, NULL);\r\n}\r\nnext:\r\nif (menu->list) {\r\nmenu = menu->list;\r\ncontinue;\r\n}\r\nif (menu->next)\r\nmenu = menu->next;\r\nelse while ((menu = menu->parent)) {\r\nif (menu->next) {\r\nmenu = menu->next;\r\nbreak;\r\n}\r\n}\r\n}\r\nfclose(out);\r\nif (*tmpname) {\r\nstrcat(dirname, basename);\r\nstrcat(dirname, ".old");\r\nrename(newname, dirname);\r\nif (rename(tmpname, newname))\r\nreturn 1;\r\n}\r\nconf_message(_("configuration written to %s"), newname);\r\nsym_set_change_count(0);\r\nreturn 0;\r\n}\r\nstatic int conf_split_config(void)\r\n{\r\nconst char *name;\r\nchar path[PATH_MAX+1];\r\nchar *s, *d, c;\r\nstruct symbol *sym;\r\nstruct stat sb;\r\nint res, i, fd;\r\nname = conf_get_autoconfig_name();\r\nconf_read_simple(name, S_DEF_AUTO);\r\nif (chdir("include/config"))\r\nreturn 1;\r\nres = 0;\r\nfor_all_symbols(i, sym) {\r\nsym_calc_value(sym);\r\nif ((sym->flags & SYMBOL_AUTO) || !sym->name)\r\ncontinue;\r\nif (sym->flags & SYMBOL_WRITE) {\r\nif (sym->flags & SYMBOL_DEF_AUTO) {\r\nswitch (sym->type) {\r\ncase S_BOOLEAN:\r\ncase S_TRISTATE:\r\nif (sym_get_tristate_value(sym) ==\r\nsym->def[S_DEF_AUTO].tri)\r\ncontinue;\r\nbreak;\r\ncase S_STRING:\r\ncase S_HEX:\r\ncase S_INT:\r\nif (!strcmp(sym_get_string_value(sym),\r\nsym->def[S_DEF_AUTO].val))\r\ncontinue;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nswitch (sym->type) {\r\ncase S_BOOLEAN:\r\ncase S_TRISTATE:\r\nif (sym_get_tristate_value(sym) == no)\r\ncontinue;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n} else if (!(sym->flags & SYMBOL_DEF_AUTO))\r\ncontinue;\r\ns = sym->name;\r\nd = path;\r\nwhile ((c = *s++)) {\r\nc = tolower(c);\r\n*d++ = (c == '_') ? '/' : c;\r\n}\r\nstrcpy(d, ".h");\r\nfd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0644);\r\nif (fd == -1) {\r\nif (errno != ENOENT) {\r\nres = 1;\r\nbreak;\r\n}\r\nd = path;\r\nwhile ((d = strchr(d, '/'))) {\r\n*d = 0;\r\nif (stat(path, &sb) && mkdir(path, 0755)) {\r\nres = 1;\r\ngoto out;\r\n}\r\n*d++ = '/';\r\n}\r\nfd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0644);\r\nif (fd == -1) {\r\nres = 1;\r\nbreak;\r\n}\r\n}\r\nclose(fd);\r\n}\r\nout:\r\nif (chdir("../.."))\r\nreturn 1;\r\nreturn res;\r\n}\r\nint conf_write_autoconf(void)\r\n{\r\nstruct symbol *sym;\r\nconst char *name;\r\nFILE *out, *tristate, *out_h;\r\nint i;\r\nsym_clear_all_valid();\r\nfile_write_dep("include/config/auto.conf.cmd");\r\nif (conf_split_config())\r\nreturn 1;\r\nout = fopen(".tmpconfig", "w");\r\nif (!out)\r\nreturn 1;\r\ntristate = fopen(".tmpconfig_tristate", "w");\r\nif (!tristate) {\r\nfclose(out);\r\nreturn 1;\r\n}\r\nout_h = fopen(".tmpconfig.h", "w");\r\nif (!out_h) {\r\nfclose(out);\r\nfclose(tristate);\r\nreturn 1;\r\n}\r\nconf_write_heading(out, &kconfig_printer_cb, NULL);\r\nconf_write_heading(tristate, &tristate_printer_cb, NULL);\r\nconf_write_heading(out_h, &header_printer_cb, NULL);\r\nfor_all_symbols(i, sym) {\r\nsym_calc_value(sym);\r\nif (!(sym->flags & SYMBOL_WRITE) || !sym->name)\r\ncontinue;\r\nconf_write_symbol(out, sym, &kconfig_printer_cb, (void *)1);\r\nconf_write_symbol(tristate, sym, &tristate_printer_cb, (void *)1);\r\nconf_write_symbol(out_h, sym, &header_printer_cb, NULL);\r\n}\r\nfclose(out);\r\nfclose(tristate);\r\nfclose(out_h);\r\nname = getenv("KCONFIG_AUTOHEADER");\r\nif (!name)\r\nname = "include/generated/autoconf.h";\r\nif (rename(".tmpconfig.h", name))\r\nreturn 1;\r\nname = getenv("KCONFIG_TRISTATE");\r\nif (!name)\r\nname = "include/config/tristate.conf";\r\nif (rename(".tmpconfig_tristate", name))\r\nreturn 1;\r\nname = conf_get_autoconfig_name();\r\nif (rename(".tmpconfig", name))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid sym_set_change_count(int count)\r\n{\r\nint _sym_change_count = sym_change_count;\r\nsym_change_count = count;\r\nif (conf_changed_callback &&\r\n(bool)_sym_change_count != (bool)count)\r\nconf_changed_callback();\r\n}\r\nvoid sym_add_change_count(int count)\r\n{\r\nsym_set_change_count(count + sym_change_count);\r\n}\r\nbool conf_get_changed(void)\r\n{\r\nreturn sym_change_count;\r\n}\r\nvoid conf_set_changed_callback(void (*fn)(void))\r\n{\r\nconf_changed_callback = fn;\r\n}\r\nstatic bool randomize_choice_values(struct symbol *csym)\r\n{\r\nstruct property *prop;\r\nstruct symbol *sym;\r\nstruct expr *e;\r\nint cnt, def;\r\nif (csym->curr.tri != yes)\r\nreturn false;\r\nprop = sym_get_choice_prop(csym);\r\ncnt = 0;\r\nexpr_list_for_each_sym(prop->expr, e, sym)\r\ncnt++;\r\ndef = (rand() % cnt);\r\ncnt = 0;\r\nexpr_list_for_each_sym(prop->expr, e, sym) {\r\nif (def == cnt++) {\r\nsym->def[S_DEF_USER].tri = yes;\r\ncsym->def[S_DEF_USER].val = sym;\r\n}\r\nelse {\r\nsym->def[S_DEF_USER].tri = no;\r\n}\r\nsym->flags |= SYMBOL_DEF_USER;\r\nsym->flags &= ~SYMBOL_VALID;\r\n}\r\ncsym->flags |= SYMBOL_DEF_USER;\r\ncsym->flags &= ~(SYMBOL_VALID);\r\nreturn true;\r\n}\r\nvoid set_all_choice_values(struct symbol *csym)\r\n{\r\nstruct property *prop;\r\nstruct symbol *sym;\r\nstruct expr *e;\r\nprop = sym_get_choice_prop(csym);\r\nexpr_list_for_each_sym(prop->expr, e, sym) {\r\nif (!sym_has_value(sym))\r\nsym->def[S_DEF_USER].tri = no;\r\n}\r\ncsym->flags |= SYMBOL_DEF_USER;\r\ncsym->flags &= ~(SYMBOL_VALID | SYMBOL_NEED_SET_CHOICE_VALUES);\r\n}\r\nbool conf_set_all_new_symbols(enum conf_def_mode mode)\r\n{\r\nstruct symbol *sym, *csym;\r\nint i, cnt, pby, pty, ptm;\r\npby = 50; pty = ptm = 33;\r\nif (mode == def_random) {\r\nint n, p[3];\r\nchar *env = getenv("KCONFIG_PROBABILITY");\r\nn = 0;\r\nwhile( env && *env ) {\r\nchar *endp;\r\nint tmp = strtol( env, &endp, 10 );\r\nif( tmp >= 0 && tmp <= 100 ) {\r\np[n++] = tmp;\r\n} else {\r\nerrno = ERANGE;\r\nperror( "KCONFIG_PROBABILITY" );\r\nexit( 1 );\r\n}\r\nenv = (*endp == ':') ? endp+1 : endp;\r\nif( n >=3 ) {\r\nbreak;\r\n}\r\n}\r\nswitch( n ) {\r\ncase 1:\r\npby = p[0]; ptm = pby/2; pty = pby-ptm;\r\nbreak;\r\ncase 2:\r\npty = p[0]; ptm = p[1]; pby = pty + ptm;\r\nbreak;\r\ncase 3:\r\npby = p[0]; pty = p[1]; ptm = p[2];\r\nbreak;\r\n}\r\nif( pty+ptm > 100 ) {\r\nerrno = ERANGE;\r\nperror( "KCONFIG_PROBABILITY" );\r\nexit( 1 );\r\n}\r\n}\r\nbool has_changed = false;\r\nfor_all_symbols(i, sym) {\r\nif (sym_has_value(sym) || (sym->flags & SYMBOL_VALID))\r\ncontinue;\r\nswitch (sym_get_type(sym)) {\r\ncase S_BOOLEAN:\r\ncase S_TRISTATE:\r\nhas_changed = true;\r\nswitch (mode) {\r\ncase def_yes:\r\nsym->def[S_DEF_USER].tri = yes;\r\nbreak;\r\ncase def_mod:\r\nsym->def[S_DEF_USER].tri = mod;\r\nbreak;\r\ncase def_no:\r\nif (sym->flags & SYMBOL_ALLNOCONFIG_Y)\r\nsym->def[S_DEF_USER].tri = yes;\r\nelse\r\nsym->def[S_DEF_USER].tri = no;\r\nbreak;\r\ncase def_random:\r\nsym->def[S_DEF_USER].tri = no;\r\ncnt = rand() % 100;\r\nif (sym->type == S_TRISTATE) {\r\nif (cnt < pty)\r\nsym->def[S_DEF_USER].tri = yes;\r\nelse if (cnt < (pty+ptm))\r\nsym->def[S_DEF_USER].tri = mod;\r\n} else if (cnt < pby)\r\nsym->def[S_DEF_USER].tri = yes;\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nif (!(sym_is_choice(sym) && mode == def_random))\r\nsym->flags |= SYMBOL_DEF_USER;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nsym_clear_all_valid();\r\nif (mode != def_random) {\r\nfor_all_symbols(i, csym) {\r\nif ((sym_is_choice(csym) && !sym_has_value(csym)) ||\r\nsym_is_choice_value(csym))\r\ncsym->flags |= SYMBOL_NEED_SET_CHOICE_VALUES;\r\n}\r\n}\r\nfor_all_symbols(i, csym) {\r\nif (sym_has_value(csym) || !sym_is_choice(csym))\r\ncontinue;\r\nsym_calc_value(csym);\r\nif (mode == def_random)\r\nhas_changed = randomize_choice_values(csym);\r\nelse {\r\nset_all_choice_values(csym);\r\nhas_changed = true;\r\n}\r\n}\r\nreturn has_changed;\r\n}
