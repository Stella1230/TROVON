static inline struct crystalcove_gpio *to_cg(struct gpio_chip *gc)\r\n{\r\nreturn container_of(gc, struct crystalcove_gpio, chip);\r\n}\r\nstatic inline int to_reg(int gpio, enum ctrl_register reg_type)\r\n{\r\nint reg;\r\nif (gpio == 94)\r\nreturn GPIOPANELCTL;\r\nif (reg_type == CTRL_IN) {\r\nif (gpio < 8)\r\nreg = GPIO0P0CTLI;\r\nelse\r\nreg = GPIO1P0CTLI;\r\n} else {\r\nif (gpio < 8)\r\nreg = GPIO0P0CTLO;\r\nelse\r\nreg = GPIO1P0CTLO;\r\n}\r\nreturn reg + gpio % 8;\r\n}\r\nstatic void crystalcove_update_irq_mask(struct crystalcove_gpio *cg,\r\nint gpio)\r\n{\r\nu8 mirqs0 = gpio < 8 ? MGPIO0IRQS0 : MGPIO1IRQS0;\r\nint mask = BIT(gpio % 8);\r\nif (cg->set_irq_mask)\r\nregmap_update_bits(cg->regmap, mirqs0, mask, mask);\r\nelse\r\nregmap_update_bits(cg->regmap, mirqs0, mask, 0);\r\n}\r\nstatic void crystalcove_update_irq_ctrl(struct crystalcove_gpio *cg, int gpio)\r\n{\r\nint reg = to_reg(gpio, CTRL_IN);\r\nregmap_update_bits(cg->regmap, reg, CTLI_INTCNT_BE, cg->intcnt_value);\r\n}\r\nstatic int crystalcove_gpio_dir_in(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nstruct crystalcove_gpio *cg = to_cg(chip);\r\nif (gpio > CRYSTALCOVE_VGPIO_NUM)\r\nreturn 0;\r\nreturn regmap_write(cg->regmap, to_reg(gpio, CTRL_OUT),\r\nCTLO_INPUT_SET);\r\n}\r\nstatic int crystalcove_gpio_dir_out(struct gpio_chip *chip, unsigned gpio,\r\nint value)\r\n{\r\nstruct crystalcove_gpio *cg = to_cg(chip);\r\nif (gpio > CRYSTALCOVE_VGPIO_NUM)\r\nreturn 0;\r\nreturn regmap_write(cg->regmap, to_reg(gpio, CTRL_OUT),\r\nCTLO_OUTPUT_SET | value);\r\n}\r\nstatic int crystalcove_gpio_get(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nstruct crystalcove_gpio *cg = to_cg(chip);\r\nint ret;\r\nunsigned int val;\r\nif (gpio > CRYSTALCOVE_VGPIO_NUM)\r\nreturn 0;\r\nret = regmap_read(cg->regmap, to_reg(gpio, CTRL_IN), &val);\r\nif (ret)\r\nreturn ret;\r\nreturn val & 0x1;\r\n}\r\nstatic void crystalcove_gpio_set(struct gpio_chip *chip,\r\nunsigned gpio, int value)\r\n{\r\nstruct crystalcove_gpio *cg = to_cg(chip);\r\nif (gpio > CRYSTALCOVE_VGPIO_NUM)\r\nreturn;\r\nif (value)\r\nregmap_update_bits(cg->regmap, to_reg(gpio, CTRL_OUT), 1, 1);\r\nelse\r\nregmap_update_bits(cg->regmap, to_reg(gpio, CTRL_OUT), 1, 0);\r\n}\r\nstatic int crystalcove_irq_type(struct irq_data *data, unsigned type)\r\n{\r\nstruct crystalcove_gpio *cg = to_cg(irq_data_get_irq_chip_data(data));\r\nswitch (type) {\r\ncase IRQ_TYPE_NONE:\r\ncg->intcnt_value = CTLI_INTCNT_DIS;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\ncg->intcnt_value = CTLI_INTCNT_BE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\ncg->intcnt_value = CTLI_INTCNT_PE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ncg->intcnt_value = CTLI_INTCNT_NE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncg->update |= UPDATE_IRQ_TYPE;\r\nreturn 0;\r\n}\r\nstatic void crystalcove_bus_lock(struct irq_data *data)\r\n{\r\nstruct crystalcove_gpio *cg = to_cg(irq_data_get_irq_chip_data(data));\r\nmutex_lock(&cg->buslock);\r\n}\r\nstatic void crystalcove_bus_sync_unlock(struct irq_data *data)\r\n{\r\nstruct crystalcove_gpio *cg = to_cg(irq_data_get_irq_chip_data(data));\r\nint gpio = data->hwirq;\r\nif (cg->update & UPDATE_IRQ_TYPE)\r\ncrystalcove_update_irq_ctrl(cg, gpio);\r\nif (cg->update & UPDATE_IRQ_MASK)\r\ncrystalcove_update_irq_mask(cg, gpio);\r\ncg->update = 0;\r\nmutex_unlock(&cg->buslock);\r\n}\r\nstatic void crystalcove_irq_unmask(struct irq_data *data)\r\n{\r\nstruct crystalcove_gpio *cg = to_cg(irq_data_get_irq_chip_data(data));\r\ncg->set_irq_mask = false;\r\ncg->update |= UPDATE_IRQ_MASK;\r\n}\r\nstatic void crystalcove_irq_mask(struct irq_data *data)\r\n{\r\nstruct crystalcove_gpio *cg = to_cg(irq_data_get_irq_chip_data(data));\r\ncg->set_irq_mask = true;\r\ncg->update |= UPDATE_IRQ_MASK;\r\n}\r\nstatic irqreturn_t crystalcove_gpio_irq_handler(int irq, void *data)\r\n{\r\nstruct crystalcove_gpio *cg = data;\r\nunsigned int p0, p1;\r\nint pending;\r\nint gpio;\r\nunsigned int virq;\r\nif (regmap_read(cg->regmap, GPIO0IRQ, &p0) ||\r\nregmap_read(cg->regmap, GPIO1IRQ, &p1))\r\nreturn IRQ_NONE;\r\nregmap_write(cg->regmap, GPIO0IRQ, p0);\r\nregmap_write(cg->regmap, GPIO1IRQ, p1);\r\npending = p0 | p1 << 8;\r\nfor (gpio = 0; gpio < CRYSTALCOVE_GPIO_NUM; gpio++) {\r\nif (pending & BIT(gpio)) {\r\nvirq = irq_find_mapping(cg->chip.irqdomain, gpio);\r\nhandle_nested_irq(virq);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void crystalcove_gpio_dbg_show(struct seq_file *s,\r\nstruct gpio_chip *chip)\r\n{\r\nstruct crystalcove_gpio *cg = to_cg(chip);\r\nint gpio, offset;\r\nunsigned int ctlo, ctli, mirqs0, mirqsx, irq;\r\nfor (gpio = 0; gpio < CRYSTALCOVE_GPIO_NUM; gpio++) {\r\nregmap_read(cg->regmap, to_reg(gpio, CTRL_OUT), &ctlo);\r\nregmap_read(cg->regmap, to_reg(gpio, CTRL_IN), &ctli);\r\nregmap_read(cg->regmap, gpio < 8 ? MGPIO0IRQS0 : MGPIO1IRQS0,\r\n&mirqs0);\r\nregmap_read(cg->regmap, gpio < 8 ? MGPIO0IRQSX : MGPIO1IRQSX,\r\n&mirqsx);\r\nregmap_read(cg->regmap, gpio < 8 ? GPIO0IRQ : GPIO1IRQ,\r\n&irq);\r\noffset = gpio % 8;\r\nseq_printf(s, " gpio-%-2d %s %s %s %s ctlo=%2x,%s %s %s\n",\r\ngpio, ctlo & CTLO_DIR_OUT ? "out" : "in ",\r\nctli & 0x1 ? "hi" : "lo",\r\nctli & CTLI_INTCNT_NE ? "fall" : " ",\r\nctli & CTLI_INTCNT_PE ? "rise" : " ",\r\nctlo,\r\nmirqs0 & BIT(offset) ? "s0 mask " : "s0 unmask",\r\nmirqsx & BIT(offset) ? "sx mask " : "sx unmask",\r\nirq & BIT(offset) ? "pending" : " ");\r\n}\r\n}\r\nstatic int crystalcove_gpio_probe(struct platform_device *pdev)\r\n{\r\nint irq = platform_get_irq(pdev, 0);\r\nstruct crystalcove_gpio *cg;\r\nint retval;\r\nstruct device *dev = pdev->dev.parent;\r\nstruct intel_soc_pmic *pmic = dev_get_drvdata(dev);\r\nif (irq < 0)\r\nreturn irq;\r\ncg = devm_kzalloc(&pdev->dev, sizeof(*cg), GFP_KERNEL);\r\nif (!cg)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, cg);\r\nmutex_init(&cg->buslock);\r\ncg->chip.label = KBUILD_MODNAME;\r\ncg->chip.direction_input = crystalcove_gpio_dir_in;\r\ncg->chip.direction_output = crystalcove_gpio_dir_out;\r\ncg->chip.get = crystalcove_gpio_get;\r\ncg->chip.set = crystalcove_gpio_set;\r\ncg->chip.base = -1;\r\ncg->chip.ngpio = CRYSTALCOVE_VGPIO_NUM;\r\ncg->chip.can_sleep = true;\r\ncg->chip.dev = dev;\r\ncg->chip.dbg_show = crystalcove_gpio_dbg_show;\r\ncg->regmap = pmic->regmap;\r\nretval = gpiochip_add(&cg->chip);\r\nif (retval) {\r\ndev_warn(&pdev->dev, "add gpio chip error: %d\n", retval);\r\nreturn retval;\r\n}\r\ngpiochip_irqchip_add(&cg->chip, &crystalcove_irqchip, 0,\r\nhandle_simple_irq, IRQ_TYPE_NONE);\r\nretval = request_threaded_irq(irq, NULL, crystalcove_gpio_irq_handler,\r\nIRQF_ONESHOT, KBUILD_MODNAME, cg);\r\nif (retval) {\r\ndev_warn(&pdev->dev, "request irq failed: %d\n", retval);\r\ngoto out_remove_gpio;\r\n}\r\nreturn 0;\r\nout_remove_gpio:\r\ngpiochip_remove(&cg->chip);\r\nreturn retval;\r\n}\r\nstatic int crystalcove_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct crystalcove_gpio *cg = platform_get_drvdata(pdev);\r\nint irq = platform_get_irq(pdev, 0);\r\ngpiochip_remove(&cg->chip);\r\nif (irq >= 0)\r\nfree_irq(irq, cg);\r\nreturn 0;\r\n}
