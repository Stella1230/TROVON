static void sun5i_clkevt_sync(struct sun5i_timer_clkevt *ce)\r\n{\r\nu32 old = readl(ce->timer.base + TIMER_CNTVAL_LO_REG(1));\r\nwhile ((old - readl(ce->timer.base + TIMER_CNTVAL_LO_REG(1))) < TIMER_SYNC_TICKS)\r\ncpu_relax();\r\n}\r\nstatic void sun5i_clkevt_time_stop(struct sun5i_timer_clkevt *ce, u8 timer)\r\n{\r\nu32 val = readl(ce->timer.base + TIMER_CTL_REG(timer));\r\nwritel(val & ~TIMER_CTL_ENABLE, ce->timer.base + TIMER_CTL_REG(timer));\r\nsun5i_clkevt_sync(ce);\r\n}\r\nstatic void sun5i_clkevt_time_setup(struct sun5i_timer_clkevt *ce, u8 timer, u32 delay)\r\n{\r\nwritel(delay, ce->timer.base + TIMER_INTVAL_LO_REG(timer));\r\n}\r\nstatic void sun5i_clkevt_time_start(struct sun5i_timer_clkevt *ce, u8 timer, bool periodic)\r\n{\r\nu32 val = readl(ce->timer.base + TIMER_CTL_REG(timer));\r\nif (periodic)\r\nval &= ~TIMER_CTL_ONESHOT;\r\nelse\r\nval |= TIMER_CTL_ONESHOT;\r\nwritel(val | TIMER_CTL_ENABLE | TIMER_CTL_RELOAD,\r\nce->timer.base + TIMER_CTL_REG(timer));\r\n}\r\nstatic int sun5i_clkevt_shutdown(struct clock_event_device *clkevt)\r\n{\r\nstruct sun5i_timer_clkevt *ce = to_sun5i_timer_clkevt(clkevt);\r\nsun5i_clkevt_time_stop(ce, 0);\r\nreturn 0;\r\n}\r\nstatic int sun5i_clkevt_set_oneshot(struct clock_event_device *clkevt)\r\n{\r\nstruct sun5i_timer_clkevt *ce = to_sun5i_timer_clkevt(clkevt);\r\nsun5i_clkevt_time_stop(ce, 0);\r\nsun5i_clkevt_time_start(ce, 0, false);\r\nreturn 0;\r\n}\r\nstatic int sun5i_clkevt_set_periodic(struct clock_event_device *clkevt)\r\n{\r\nstruct sun5i_timer_clkevt *ce = to_sun5i_timer_clkevt(clkevt);\r\nsun5i_clkevt_time_stop(ce, 0);\r\nsun5i_clkevt_time_setup(ce, 0, ce->timer.ticks_per_jiffy);\r\nsun5i_clkevt_time_start(ce, 0, true);\r\nreturn 0;\r\n}\r\nstatic int sun5i_clkevt_next_event(unsigned long evt,\r\nstruct clock_event_device *clkevt)\r\n{\r\nstruct sun5i_timer_clkevt *ce = to_sun5i_timer_clkevt(clkevt);\r\nsun5i_clkevt_time_stop(ce, 0);\r\nsun5i_clkevt_time_setup(ce, 0, evt - TIMER_SYNC_TICKS);\r\nsun5i_clkevt_time_start(ce, 0, false);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t sun5i_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct sun5i_timer_clkevt *ce = (struct sun5i_timer_clkevt *)dev_id;\r\nwritel(0x1, ce->timer.base + TIMER_IRQ_ST_REG);\r\nce->clkevt.event_handler(&ce->clkevt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic cycle_t sun5i_clksrc_read(struct clocksource *clksrc)\r\n{\r\nstruct sun5i_timer_clksrc *cs = to_sun5i_timer_clksrc(clksrc);\r\nreturn ~readl(cs->timer.base + TIMER_CNTVAL_LO_REG(1));\r\n}\r\nstatic int sun5i_rate_cb_clksrc(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct clk_notifier_data *ndata = data;\r\nstruct sun5i_timer *timer = to_sun5i_timer(nb);\r\nstruct sun5i_timer_clksrc *cs = container_of(timer, struct sun5i_timer_clksrc, timer);\r\nswitch (event) {\r\ncase PRE_RATE_CHANGE:\r\nclocksource_unregister(&cs->clksrc);\r\nbreak;\r\ncase POST_RATE_CHANGE:\r\nclocksource_register_hz(&cs->clksrc, ndata->new_rate);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init sun5i_setup_clocksource(struct device_node *node,\r\nvoid __iomem *base,\r\nstruct clk *clk, int irq)\r\n{\r\nstruct sun5i_timer_clksrc *cs;\r\nunsigned long rate;\r\nint ret;\r\ncs = kzalloc(sizeof(*cs), GFP_KERNEL);\r\nif (!cs)\r\nreturn -ENOMEM;\r\nret = clk_prepare_enable(clk);\r\nif (ret) {\r\npr_err("Couldn't enable parent clock\n");\r\ngoto err_free;\r\n}\r\nrate = clk_get_rate(clk);\r\ncs->timer.base = base;\r\ncs->timer.clk = clk;\r\ncs->timer.clk_rate_cb.notifier_call = sun5i_rate_cb_clksrc;\r\ncs->timer.clk_rate_cb.next = NULL;\r\nret = clk_notifier_register(clk, &cs->timer.clk_rate_cb);\r\nif (ret) {\r\npr_err("Unable to register clock notifier.\n");\r\ngoto err_disable_clk;\r\n}\r\nwritel(~0, base + TIMER_INTVAL_LO_REG(1));\r\nwritel(TIMER_CTL_ENABLE | TIMER_CTL_RELOAD,\r\nbase + TIMER_CTL_REG(1));\r\ncs->clksrc.name = node->name;\r\ncs->clksrc.rating = 340;\r\ncs->clksrc.read = sun5i_clksrc_read;\r\ncs->clksrc.mask = CLOCKSOURCE_MASK(32);\r\ncs->clksrc.flags = CLOCK_SOURCE_IS_CONTINUOUS;\r\nret = clocksource_register_hz(&cs->clksrc, rate);\r\nif (ret) {\r\npr_err("Couldn't register clock source.\n");\r\ngoto err_remove_notifier;\r\n}\r\nreturn 0;\r\nerr_remove_notifier:\r\nclk_notifier_unregister(clk, &cs->timer.clk_rate_cb);\r\nerr_disable_clk:\r\nclk_disable_unprepare(clk);\r\nerr_free:\r\nkfree(cs);\r\nreturn ret;\r\n}\r\nstatic int sun5i_rate_cb_clkevt(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct clk_notifier_data *ndata = data;\r\nstruct sun5i_timer *timer = to_sun5i_timer(nb);\r\nstruct sun5i_timer_clkevt *ce = container_of(timer, struct sun5i_timer_clkevt, timer);\r\nif (event == POST_RATE_CHANGE) {\r\nclockevents_update_freq(&ce->clkevt, ndata->new_rate);\r\nce->timer.ticks_per_jiffy = DIV_ROUND_UP(ndata->new_rate, HZ);\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init sun5i_setup_clockevent(struct device_node *node, void __iomem *base,\r\nstruct clk *clk, int irq)\r\n{\r\nstruct sun5i_timer_clkevt *ce;\r\nunsigned long rate;\r\nint ret;\r\nu32 val;\r\nce = kzalloc(sizeof(*ce), GFP_KERNEL);\r\nif (!ce)\r\nreturn -ENOMEM;\r\nret = clk_prepare_enable(clk);\r\nif (ret) {\r\npr_err("Couldn't enable parent clock\n");\r\ngoto err_free;\r\n}\r\nrate = clk_get_rate(clk);\r\nce->timer.base = base;\r\nce->timer.ticks_per_jiffy = DIV_ROUND_UP(rate, HZ);\r\nce->timer.clk = clk;\r\nce->timer.clk_rate_cb.notifier_call = sun5i_rate_cb_clkevt;\r\nce->timer.clk_rate_cb.next = NULL;\r\nret = clk_notifier_register(clk, &ce->timer.clk_rate_cb);\r\nif (ret) {\r\npr_err("Unable to register clock notifier.\n");\r\ngoto err_disable_clk;\r\n}\r\nce->clkevt.name = node->name;\r\nce->clkevt.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;\r\nce->clkevt.set_next_event = sun5i_clkevt_next_event;\r\nce->clkevt.set_state_shutdown = sun5i_clkevt_shutdown;\r\nce->clkevt.set_state_periodic = sun5i_clkevt_set_periodic;\r\nce->clkevt.set_state_oneshot = sun5i_clkevt_set_oneshot;\r\nce->clkevt.tick_resume = sun5i_clkevt_shutdown;\r\nce->clkevt.rating = 340;\r\nce->clkevt.irq = irq;\r\nce->clkevt.cpumask = cpu_possible_mask;\r\nval = readl(base + TIMER_IRQ_EN_REG);\r\nwritel(val | TIMER_IRQ_EN(0), base + TIMER_IRQ_EN_REG);\r\nclockevents_config_and_register(&ce->clkevt, rate,\r\nTIMER_SYNC_TICKS, 0xffffffff);\r\nret = request_irq(irq, sun5i_timer_interrupt, IRQF_TIMER | IRQF_IRQPOLL,\r\n"sun5i_timer0", ce);\r\nif (ret) {\r\npr_err("Unable to register interrupt\n");\r\ngoto err_remove_notifier;\r\n}\r\nreturn 0;\r\nerr_remove_notifier:\r\nclk_notifier_unregister(clk, &ce->timer.clk_rate_cb);\r\nerr_disable_clk:\r\nclk_disable_unprepare(clk);\r\nerr_free:\r\nkfree(ce);\r\nreturn ret;\r\n}\r\nstatic void __init sun5i_timer_init(struct device_node *node)\r\n{\r\nstruct reset_control *rstc;\r\nvoid __iomem *timer_base;\r\nstruct clk *clk;\r\nint irq;\r\ntimer_base = of_io_request_and_map(node, 0, of_node_full_name(node));\r\nif (IS_ERR(timer_base))\r\npanic("Can't map registers");\r\nirq = irq_of_parse_and_map(node, 0);\r\nif (irq <= 0)\r\npanic("Can't parse IRQ");\r\nclk = of_clk_get(node, 0);\r\nif (IS_ERR(clk))\r\npanic("Can't get timer clock");\r\nrstc = of_reset_control_get(node, NULL);\r\nif (!IS_ERR(rstc))\r\nreset_control_deassert(rstc);\r\nsun5i_setup_clocksource(node, timer_base, clk, irq);\r\nsun5i_setup_clockevent(node, timer_base, clk, irq);\r\n}
