static struct adv7511 *encoder_to_adv7511(struct drm_encoder *encoder)\r\n{\r\nreturn to_encoder_slave(encoder)->slave_priv;\r\n}\r\nstatic bool adv7511_register_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase ADV7511_REG_CHIP_REVISION:\r\ncase ADV7511_REG_SPDIF_FREQ:\r\ncase ADV7511_REG_CTS_AUTOMATIC1:\r\ncase ADV7511_REG_CTS_AUTOMATIC2:\r\ncase ADV7511_REG_VIC_DETECTED:\r\ncase ADV7511_REG_VIC_SEND:\r\ncase ADV7511_REG_AUX_VIC_DETECTED:\r\ncase ADV7511_REG_STATUS:\r\ncase ADV7511_REG_GC(1):\r\ncase ADV7511_REG_INT(0):\r\ncase ADV7511_REG_INT(1):\r\ncase ADV7511_REG_PLL_STATUS:\r\ncase ADV7511_REG_AN(0):\r\ncase ADV7511_REG_AN(1):\r\ncase ADV7511_REG_AN(2):\r\ncase ADV7511_REG_AN(3):\r\ncase ADV7511_REG_AN(4):\r\ncase ADV7511_REG_AN(5):\r\ncase ADV7511_REG_AN(6):\r\ncase ADV7511_REG_AN(7):\r\ncase ADV7511_REG_HDCP_STATUS:\r\ncase ADV7511_REG_BCAPS:\r\ncase ADV7511_REG_BKSV(0):\r\ncase ADV7511_REG_BKSV(1):\r\ncase ADV7511_REG_BKSV(2):\r\ncase ADV7511_REG_BKSV(3):\r\ncase ADV7511_REG_BKSV(4):\r\ncase ADV7511_REG_DDC_STATUS:\r\ncase ADV7511_REG_BSTATUS(0):\r\ncase ADV7511_REG_BSTATUS(1):\r\ncase ADV7511_REG_CHIP_ID_HIGH:\r\ncase ADV7511_REG_CHIP_ID_LOW:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void adv7511_set_colormap(struct adv7511 *adv7511, bool enable,\r\nconst uint16_t *coeff,\r\nunsigned int scaling_factor)\r\n{\r\nunsigned int i;\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_CSC_UPPER(1),\r\nADV7511_CSC_UPDATE_MODE, ADV7511_CSC_UPDATE_MODE);\r\nif (enable) {\r\nfor (i = 0; i < 12; ++i) {\r\nregmap_update_bits(adv7511->regmap,\r\nADV7511_REG_CSC_UPPER(i),\r\n0x1f, coeff[i] >> 8);\r\nregmap_write(adv7511->regmap,\r\nADV7511_REG_CSC_LOWER(i),\r\ncoeff[i] & 0xff);\r\n}\r\n}\r\nif (enable)\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_CSC_UPPER(0),\r\n0xe0, 0x80 | (scaling_factor << 5));\r\nelse\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_CSC_UPPER(0),\r\n0x80, 0x00);\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_CSC_UPPER(1),\r\nADV7511_CSC_UPDATE_MODE, 0);\r\n}\r\nstatic int adv7511_packet_enable(struct adv7511 *adv7511, unsigned int packet)\r\n{\r\nif (packet & 0xff)\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_PACKET_ENABLE0,\r\npacket, 0xff);\r\nif (packet & 0xff00) {\r\npacket >>= 8;\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_PACKET_ENABLE1,\r\npacket, 0xff);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7511_packet_disable(struct adv7511 *adv7511, unsigned int packet)\r\n{\r\nif (packet & 0xff)\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_PACKET_ENABLE0,\r\npacket, 0x00);\r\nif (packet & 0xff00) {\r\npacket >>= 8;\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_PACKET_ENABLE1,\r\npacket, 0x00);\r\n}\r\nreturn 0;\r\n}\r\nstatic void adv7511_set_config_csc(struct adv7511 *adv7511,\r\nstruct drm_connector *connector,\r\nbool rgb)\r\n{\r\nstruct adv7511_video_config config;\r\nbool output_format_422, output_format_ycbcr;\r\nunsigned int mode;\r\nuint8_t infoframe[17];\r\nif (adv7511->edid)\r\nconfig.hdmi_mode = drm_detect_hdmi_monitor(adv7511->edid);\r\nelse\r\nconfig.hdmi_mode = false;\r\nhdmi_avi_infoframe_init(&config.avi_infoframe);\r\nconfig.avi_infoframe.scan_mode = HDMI_SCAN_MODE_UNDERSCAN;\r\nif (rgb) {\r\nconfig.csc_enable = false;\r\nconfig.avi_infoframe.colorspace = HDMI_COLORSPACE_RGB;\r\n} else {\r\nconfig.csc_scaling_factor = ADV7511_CSC_SCALING_4;\r\nconfig.csc_coefficents = adv7511_csc_ycbcr_to_rgb;\r\nif ((connector->display_info.color_formats &\r\nDRM_COLOR_FORMAT_YCRCB422) &&\r\nconfig.hdmi_mode) {\r\nconfig.csc_enable = false;\r\nconfig.avi_infoframe.colorspace =\r\nHDMI_COLORSPACE_YUV422;\r\n} else {\r\nconfig.csc_enable = true;\r\nconfig.avi_infoframe.colorspace = HDMI_COLORSPACE_RGB;\r\n}\r\n}\r\nif (config.hdmi_mode) {\r\nmode = ADV7511_HDMI_CFG_MODE_HDMI;\r\nswitch (config.avi_infoframe.colorspace) {\r\ncase HDMI_COLORSPACE_YUV444:\r\noutput_format_422 = false;\r\noutput_format_ycbcr = true;\r\nbreak;\r\ncase HDMI_COLORSPACE_YUV422:\r\noutput_format_422 = true;\r\noutput_format_ycbcr = true;\r\nbreak;\r\ndefault:\r\noutput_format_422 = false;\r\noutput_format_ycbcr = false;\r\nbreak;\r\n}\r\n} else {\r\nmode = ADV7511_HDMI_CFG_MODE_DVI;\r\noutput_format_422 = false;\r\noutput_format_ycbcr = false;\r\n}\r\nadv7511_packet_disable(adv7511, ADV7511_PACKET_ENABLE_AVI_INFOFRAME);\r\nadv7511_set_colormap(adv7511, config.csc_enable,\r\nconfig.csc_coefficents,\r\nconfig.csc_scaling_factor);\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_VIDEO_INPUT_CFG1, 0x81,\r\n(output_format_422 << 7) | output_format_ycbcr);\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_HDCP_HDMI_CFG,\r\nADV7511_HDMI_CFG_MODE_MASK, mode);\r\nhdmi_avi_infoframe_pack(&config.avi_infoframe, infoframe,\r\nsizeof(infoframe));\r\nregmap_bulk_write(adv7511->regmap, ADV7511_REG_AVI_INFOFRAME_VERSION,\r\ninfoframe + 1, sizeof(infoframe) - 1);\r\nadv7511_packet_enable(adv7511, ADV7511_PACKET_ENABLE_AVI_INFOFRAME);\r\n}\r\nstatic void adv7511_set_link_config(struct adv7511 *adv7511,\r\nconst struct adv7511_link_config *config)\r\n{\r\nstatic const unsigned int input_styles[4] = { 0, 2, 1, 3 };\r\nunsigned int clock_delay;\r\nunsigned int color_depth;\r\nunsigned int input_id;\r\nclock_delay = (config->clock_delay + 1200) / 400;\r\ncolor_depth = config->input_color_depth == 8 ? 3\r\n: (config->input_color_depth == 10 ? 1 : 2);\r\nif (config->input_colorspace != HDMI_COLORSPACE_YUV422)\r\ninput_id = config->input_clock == ADV7511_INPUT_CLOCK_DDR\r\n? 5 : 0;\r\nelse if (config->input_clock == ADV7511_INPUT_CLOCK_DDR)\r\ninput_id = config->embedded_sync ? 8 : 7;\r\nelse if (config->input_clock == ADV7511_INPUT_CLOCK_2X)\r\ninput_id = config->embedded_sync ? 4 : 3;\r\nelse\r\ninput_id = config->embedded_sync ? 2 : 1;\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_I2C_FREQ_ID_CFG, 0xf,\r\ninput_id);\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_VIDEO_INPUT_CFG1, 0x7e,\r\n(color_depth << 4) |\r\n(input_styles[config->input_style] << 2));\r\nregmap_write(adv7511->regmap, ADV7511_REG_VIDEO_INPUT_CFG2,\r\nconfig->input_justification << 3);\r\nregmap_write(adv7511->regmap, ADV7511_REG_TIMING_GEN_SEQ,\r\nconfig->sync_pulse << 2);\r\nregmap_write(adv7511->regmap, 0xba, clock_delay << 5);\r\nadv7511->embedded_sync = config->embedded_sync;\r\nadv7511->hsync_polarity = config->hsync_polarity;\r\nadv7511->vsync_polarity = config->vsync_polarity;\r\nadv7511->rgb = config->input_colorspace == HDMI_COLORSPACE_RGB;\r\n}\r\nstatic void adv7511_power_on(struct adv7511 *adv7511)\r\n{\r\nadv7511->current_edid_segment = -1;\r\nregmap_write(adv7511->regmap, ADV7511_REG_INT(0),\r\nADV7511_INT0_EDID_READY);\r\nregmap_write(adv7511->regmap, ADV7511_REG_INT(1),\r\nADV7511_INT1_DDC_ERROR);\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_POWER,\r\nADV7511_POWER_POWER_DOWN, 0);\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_POWER2,\r\nADV7511_REG_POWER2_HDP_SRC_MASK,\r\nADV7511_REG_POWER2_HDP_SRC_NONE);\r\nregcache_sync(adv7511->regmap);\r\nadv7511->powered = true;\r\n}\r\nstatic void adv7511_power_off(struct adv7511 *adv7511)\r\n{\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_POWER,\r\nADV7511_POWER_POWER_DOWN,\r\nADV7511_POWER_POWER_DOWN);\r\nregcache_mark_dirty(adv7511->regmap);\r\nadv7511->powered = false;\r\n}\r\nstatic bool adv7511_hpd(struct adv7511 *adv7511)\r\n{\r\nunsigned int irq0;\r\nint ret;\r\nret = regmap_read(adv7511->regmap, ADV7511_REG_INT(0), &irq0);\r\nif (ret < 0)\r\nreturn false;\r\nif (irq0 & ADV7511_INT0_HDP) {\r\nregmap_write(adv7511->regmap, ADV7511_REG_INT(0),\r\nADV7511_INT0_HDP);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int adv7511_irq_process(struct adv7511 *adv7511)\r\n{\r\nunsigned int irq0, irq1;\r\nint ret;\r\nret = regmap_read(adv7511->regmap, ADV7511_REG_INT(0), &irq0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_read(adv7511->regmap, ADV7511_REG_INT(1), &irq1);\r\nif (ret < 0)\r\nreturn ret;\r\nregmap_write(adv7511->regmap, ADV7511_REG_INT(0), irq0);\r\nregmap_write(adv7511->regmap, ADV7511_REG_INT(1), irq1);\r\nif (irq0 & ADV7511_INT0_HDP && adv7511->encoder)\r\ndrm_helper_hpd_irq_event(adv7511->encoder->dev);\r\nif (irq0 & ADV7511_INT0_EDID_READY || irq1 & ADV7511_INT1_DDC_ERROR) {\r\nadv7511->edid_read = true;\r\nif (adv7511->i2c_main->irq)\r\nwake_up_all(&adv7511->wq);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t adv7511_irq_handler(int irq, void *devid)\r\n{\r\nstruct adv7511 *adv7511 = devid;\r\nint ret;\r\nret = adv7511_irq_process(adv7511);\r\nreturn ret < 0 ? IRQ_NONE : IRQ_HANDLED;\r\n}\r\nstatic int adv7511_wait_for_edid(struct adv7511 *adv7511, int timeout)\r\n{\r\nint ret;\r\nif (adv7511->i2c_main->irq) {\r\nret = wait_event_interruptible_timeout(adv7511->wq,\r\nadv7511->edid_read, msecs_to_jiffies(timeout));\r\n} else {\r\nfor (; timeout > 0; timeout -= 25) {\r\nret = adv7511_irq_process(adv7511);\r\nif (ret < 0)\r\nbreak;\r\nif (adv7511->edid_read)\r\nbreak;\r\nmsleep(25);\r\n}\r\n}\r\nreturn adv7511->edid_read ? 0 : -EIO;\r\n}\r\nstatic int adv7511_get_edid_block(void *data, u8 *buf, unsigned int block,\r\nsize_t len)\r\n{\r\nstruct adv7511 *adv7511 = data;\r\nstruct i2c_msg xfer[2];\r\nuint8_t offset;\r\nunsigned int i;\r\nint ret;\r\nif (len > 128)\r\nreturn -EINVAL;\r\nif (adv7511->current_edid_segment != block / 2) {\r\nunsigned int status;\r\nret = regmap_read(adv7511->regmap, ADV7511_REG_DDC_STATUS,\r\n&status);\r\nif (ret < 0)\r\nreturn ret;\r\nif (status != 2) {\r\nadv7511->edid_read = false;\r\nregmap_write(adv7511->regmap, ADV7511_REG_EDID_SEGMENT,\r\nblock);\r\nret = adv7511_wait_for_edid(adv7511, 200);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nxfer[0].addr = adv7511->i2c_edid->addr;\r\nxfer[0].flags = 0;\r\nxfer[0].len = 1;\r\nxfer[0].buf = &offset;\r\nxfer[1].addr = adv7511->i2c_edid->addr;\r\nxfer[1].flags = I2C_M_RD;\r\nxfer[1].len = 64;\r\nxfer[1].buf = adv7511->edid_buf;\r\noffset = 0;\r\nfor (i = 0; i < 4; ++i) {\r\nret = i2c_transfer(adv7511->i2c_edid->adapter, xfer,\r\nARRAY_SIZE(xfer));\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret != 2)\r\nreturn -EIO;\r\nxfer[1].buf += 64;\r\noffset += 64;\r\n}\r\nadv7511->current_edid_segment = block / 2;\r\n}\r\nif (block % 2 == 0)\r\nmemcpy(buf, adv7511->edid_buf, len);\r\nelse\r\nmemcpy(buf, adv7511->edid_buf + 128, len);\r\nreturn 0;\r\n}\r\nstatic int adv7511_get_modes(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nstruct adv7511 *adv7511 = encoder_to_adv7511(encoder);\r\nstruct edid *edid;\r\nunsigned int count;\r\nif (!adv7511->powered) {\r\nregmap_write(adv7511->regmap, ADV7511_REG_INT(0),\r\nADV7511_INT0_EDID_READY);\r\nregmap_write(adv7511->regmap, ADV7511_REG_INT(1),\r\nADV7511_INT1_DDC_ERROR);\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_POWER,\r\nADV7511_POWER_POWER_DOWN, 0);\r\nadv7511->current_edid_segment = -1;\r\n}\r\nedid = drm_do_get_edid(connector, adv7511_get_edid_block, adv7511);\r\nif (!adv7511->powered)\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_POWER,\r\nADV7511_POWER_POWER_DOWN,\r\nADV7511_POWER_POWER_DOWN);\r\nkfree(adv7511->edid);\r\nadv7511->edid = edid;\r\nif (!edid)\r\nreturn 0;\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\ncount = drm_add_edid_modes(connector, edid);\r\nadv7511_set_config_csc(adv7511, connector, adv7511->rgb);\r\nreturn count;\r\n}\r\nstatic void adv7511_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct adv7511 *adv7511 = encoder_to_adv7511(encoder);\r\nif (mode == DRM_MODE_DPMS_ON)\r\nadv7511_power_on(adv7511);\r\nelse\r\nadv7511_power_off(adv7511);\r\n}\r\nstatic enum drm_connector_status\r\nadv7511_encoder_detect(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nstruct adv7511 *adv7511 = encoder_to_adv7511(encoder);\r\nenum drm_connector_status status;\r\nunsigned int val;\r\nbool hpd;\r\nint ret;\r\nret = regmap_read(adv7511->regmap, ADV7511_REG_STATUS, &val);\r\nif (ret < 0)\r\nreturn connector_status_disconnected;\r\nif (val & ADV7511_STATUS_HPD)\r\nstatus = connector_status_connected;\r\nelse\r\nstatus = connector_status_disconnected;\r\nhpd = adv7511_hpd(adv7511);\r\nif (status == connector_status_connected && hpd && adv7511->powered) {\r\nregcache_mark_dirty(adv7511->regmap);\r\nadv7511_power_on(adv7511);\r\nadv7511_get_modes(encoder, connector);\r\nif (adv7511->status == connector_status_connected)\r\nstatus = connector_status_disconnected;\r\n} else {\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_POWER2,\r\nADV7511_REG_POWER2_HDP_SRC_MASK,\r\nADV7511_REG_POWER2_HDP_SRC_BOTH);\r\n}\r\nadv7511->status = status;\r\nreturn status;\r\n}\r\nstatic int adv7511_encoder_mode_valid(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode)\r\n{\r\nif (mode->clock > 165000)\r\nreturn MODE_CLOCK_HIGH;\r\nreturn MODE_OK;\r\n}\r\nstatic void adv7511_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adj_mode)\r\n{\r\nstruct adv7511 *adv7511 = encoder_to_adv7511(encoder);\r\nunsigned int low_refresh_rate;\r\nunsigned int hsync_polarity = 0;\r\nunsigned int vsync_polarity = 0;\r\nif (adv7511->embedded_sync) {\r\nunsigned int hsync_offset, hsync_len;\r\nunsigned int vsync_offset, vsync_len;\r\nhsync_offset = adj_mode->crtc_hsync_start -\r\nadj_mode->crtc_hdisplay;\r\nvsync_offset = adj_mode->crtc_vsync_start -\r\nadj_mode->crtc_vdisplay;\r\nhsync_len = adj_mode->crtc_hsync_end -\r\nadj_mode->crtc_hsync_start;\r\nvsync_len = adj_mode->crtc_vsync_end -\r\nadj_mode->crtc_vsync_start;\r\nvsync_offset += 1;\r\nregmap_write(adv7511->regmap, ADV7511_REG_HSYNC_PLACEMENT_MSB,\r\n((hsync_offset >> 10) & 0x7) << 5);\r\nregmap_write(adv7511->regmap, ADV7511_REG_SYNC_DECODER(0),\r\n(hsync_offset >> 2) & 0xff);\r\nregmap_write(adv7511->regmap, ADV7511_REG_SYNC_DECODER(1),\r\n((hsync_offset & 0x3) << 6) |\r\n((hsync_len >> 4) & 0x3f));\r\nregmap_write(adv7511->regmap, ADV7511_REG_SYNC_DECODER(2),\r\n((hsync_len & 0xf) << 4) |\r\n((vsync_offset >> 6) & 0xf));\r\nregmap_write(adv7511->regmap, ADV7511_REG_SYNC_DECODER(3),\r\n((vsync_offset & 0x3f) << 2) |\r\n((vsync_len >> 8) & 0x3));\r\nregmap_write(adv7511->regmap, ADV7511_REG_SYNC_DECODER(4),\r\nvsync_len & 0xff);\r\nhsync_polarity = !(adj_mode->flags & DRM_MODE_FLAG_PHSYNC);\r\nvsync_polarity = !(adj_mode->flags & DRM_MODE_FLAG_PVSYNC);\r\n} else {\r\nenum adv7511_sync_polarity mode_hsync_polarity;\r\nenum adv7511_sync_polarity mode_vsync_polarity;\r\nif (adj_mode->flags & DRM_MODE_FLAG_NHSYNC)\r\nmode_hsync_polarity = ADV7511_SYNC_POLARITY_LOW;\r\nelse\r\nmode_hsync_polarity = ADV7511_SYNC_POLARITY_HIGH;\r\nif (adj_mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nmode_vsync_polarity = ADV7511_SYNC_POLARITY_LOW;\r\nelse\r\nmode_vsync_polarity = ADV7511_SYNC_POLARITY_HIGH;\r\nif (adv7511->hsync_polarity != mode_hsync_polarity &&\r\nadv7511->hsync_polarity !=\r\nADV7511_SYNC_POLARITY_PASSTHROUGH)\r\nhsync_polarity = 1;\r\nif (adv7511->vsync_polarity != mode_vsync_polarity &&\r\nadv7511->vsync_polarity !=\r\nADV7511_SYNC_POLARITY_PASSTHROUGH)\r\nvsync_polarity = 1;\r\n}\r\nif (mode->vrefresh <= 24000)\r\nlow_refresh_rate = ADV7511_LOW_REFRESH_RATE_24HZ;\r\nelse if (mode->vrefresh <= 25000)\r\nlow_refresh_rate = ADV7511_LOW_REFRESH_RATE_25HZ;\r\nelse if (mode->vrefresh <= 30000)\r\nlow_refresh_rate = ADV7511_LOW_REFRESH_RATE_30HZ;\r\nelse\r\nlow_refresh_rate = ADV7511_LOW_REFRESH_RATE_NONE;\r\nregmap_update_bits(adv7511->regmap, 0xfb,\r\n0x6, low_refresh_rate << 1);\r\nregmap_update_bits(adv7511->regmap, 0x17,\r\n0x60, (vsync_polarity << 6) | (hsync_polarity << 5));\r\nadv7511->f_tmds = mode->clock;\r\n}\r\nstatic int adv7511_parse_dt(struct device_node *np,\r\nstruct adv7511_link_config *config)\r\n{\r\nconst char *str;\r\nint ret;\r\nmemset(config, 0, sizeof(*config));\r\nof_property_read_u32(np, "adi,input-depth", &config->input_color_depth);\r\nif (config->input_color_depth != 8 && config->input_color_depth != 10 &&\r\nconfig->input_color_depth != 12)\r\nreturn -EINVAL;\r\nret = of_property_read_string(np, "adi,input-colorspace", &str);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!strcmp(str, "rgb"))\r\nconfig->input_colorspace = HDMI_COLORSPACE_RGB;\r\nelse if (!strcmp(str, "yuv422"))\r\nconfig->input_colorspace = HDMI_COLORSPACE_YUV422;\r\nelse if (!strcmp(str, "yuv444"))\r\nconfig->input_colorspace = HDMI_COLORSPACE_YUV444;\r\nelse\r\nreturn -EINVAL;\r\nret = of_property_read_string(np, "adi,input-clock", &str);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!strcmp(str, "1x"))\r\nconfig->input_clock = ADV7511_INPUT_CLOCK_1X;\r\nelse if (!strcmp(str, "2x"))\r\nconfig->input_clock = ADV7511_INPUT_CLOCK_2X;\r\nelse if (!strcmp(str, "ddr"))\r\nconfig->input_clock = ADV7511_INPUT_CLOCK_DDR;\r\nelse\r\nreturn -EINVAL;\r\nif (config->input_colorspace == HDMI_COLORSPACE_YUV422 ||\r\nconfig->input_clock != ADV7511_INPUT_CLOCK_1X) {\r\nret = of_property_read_u32(np, "adi,input-style",\r\n&config->input_style);\r\nif (ret)\r\nreturn ret;\r\nif (config->input_style < 1 || config->input_style > 3)\r\nreturn -EINVAL;\r\nret = of_property_read_string(np, "adi,input-justification",\r\n&str);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!strcmp(str, "left"))\r\nconfig->input_justification =\r\nADV7511_INPUT_JUSTIFICATION_LEFT;\r\nelse if (!strcmp(str, "evenly"))\r\nconfig->input_justification =\r\nADV7511_INPUT_JUSTIFICATION_EVENLY;\r\nelse if (!strcmp(str, "right"))\r\nconfig->input_justification =\r\nADV7511_INPUT_JUSTIFICATION_RIGHT;\r\nelse\r\nreturn -EINVAL;\r\n} else {\r\nconfig->input_style = 1;\r\nconfig->input_justification = ADV7511_INPUT_JUSTIFICATION_LEFT;\r\n}\r\nof_property_read_u32(np, "adi,clock-delay", &config->clock_delay);\r\nif (config->clock_delay < -1200 || config->clock_delay > 1600)\r\nreturn -EINVAL;\r\nconfig->embedded_sync = of_property_read_bool(np, "adi,embedded-sync");\r\nconfig->sync_pulse = ADV7511_INPUT_SYNC_PULSE_NONE;\r\nconfig->vsync_polarity = ADV7511_SYNC_POLARITY_PASSTHROUGH;\r\nconfig->hsync_polarity = ADV7511_SYNC_POLARITY_PASSTHROUGH;\r\nreturn 0;\r\n}\r\nstatic int adv7511_probe(struct i2c_client *i2c, const struct i2c_device_id *id)\r\n{\r\nstruct adv7511_link_config link_config;\r\nstruct adv7511 *adv7511;\r\nstruct device *dev = &i2c->dev;\r\nunsigned int val;\r\nint ret;\r\nif (!dev->of_node)\r\nreturn -EINVAL;\r\nadv7511 = devm_kzalloc(dev, sizeof(*adv7511), GFP_KERNEL);\r\nif (!adv7511)\r\nreturn -ENOMEM;\r\nadv7511->powered = false;\r\nadv7511->status = connector_status_disconnected;\r\nret = adv7511_parse_dt(dev->of_node, &link_config);\r\nif (ret)\r\nreturn ret;\r\nadv7511->gpio_pd = devm_gpiod_get_optional(dev, "pd", GPIOD_OUT_HIGH);\r\nif (IS_ERR(adv7511->gpio_pd))\r\nreturn PTR_ERR(adv7511->gpio_pd);\r\nif (adv7511->gpio_pd) {\r\nmdelay(5);\r\ngpiod_set_value_cansleep(adv7511->gpio_pd, 0);\r\n}\r\nadv7511->regmap = devm_regmap_init_i2c(i2c, &adv7511_regmap_config);\r\nif (IS_ERR(adv7511->regmap))\r\nreturn PTR_ERR(adv7511->regmap);\r\nret = regmap_read(adv7511->regmap, ADV7511_REG_CHIP_REVISION, &val);\r\nif (ret)\r\nreturn ret;\r\ndev_dbg(dev, "Rev. %d\n", val);\r\nret = regmap_register_patch(adv7511->regmap, adv7511_fixed_registers,\r\nARRAY_SIZE(adv7511_fixed_registers));\r\nif (ret)\r\nreturn ret;\r\nregmap_write(adv7511->regmap, ADV7511_REG_EDID_I2C_ADDR, edid_i2c_addr);\r\nregmap_write(adv7511->regmap, ADV7511_REG_PACKET_I2C_ADDR,\r\npacket_i2c_addr);\r\nregmap_write(adv7511->regmap, ADV7511_REG_CEC_I2C_ADDR, cec_i2c_addr);\r\nadv7511_packet_disable(adv7511, 0xffff);\r\nadv7511->i2c_main = i2c;\r\nadv7511->i2c_edid = i2c_new_dummy(i2c->adapter, edid_i2c_addr >> 1);\r\nif (!adv7511->i2c_edid)\r\nreturn -ENOMEM;\r\nif (i2c->irq) {\r\ninit_waitqueue_head(&adv7511->wq);\r\nret = devm_request_threaded_irq(dev, i2c->irq, NULL,\r\nadv7511_irq_handler,\r\nIRQF_ONESHOT, dev_name(dev),\r\nadv7511);\r\nif (ret)\r\ngoto err_i2c_unregister_device;\r\n}\r\nregmap_write(adv7511->regmap, ADV7511_REG_CEC_CTRL,\r\nADV7511_CEC_CTRL_POWER_DOWN);\r\nadv7511_power_off(adv7511);\r\ni2c_set_clientdata(i2c, adv7511);\r\nadv7511_set_link_config(adv7511, &link_config);\r\nreturn 0;\r\nerr_i2c_unregister_device:\r\ni2c_unregister_device(adv7511->i2c_edid);\r\nreturn ret;\r\n}\r\nstatic int adv7511_remove(struct i2c_client *i2c)\r\n{\r\nstruct adv7511 *adv7511 = i2c_get_clientdata(i2c);\r\ni2c_unregister_device(adv7511->i2c_edid);\r\nkfree(adv7511->edid);\r\nreturn 0;\r\n}\r\nstatic int adv7511_encoder_init(struct i2c_client *i2c, struct drm_device *dev,\r\nstruct drm_encoder_slave *encoder)\r\n{\r\nstruct adv7511 *adv7511 = i2c_get_clientdata(i2c);\r\nencoder->slave_priv = adv7511;\r\nencoder->slave_funcs = &adv7511_encoder_funcs;\r\nadv7511->encoder = &encoder->base;\r\nreturn 0;\r\n}\r\nstatic int __init adv7511_init(void)\r\n{\r\nreturn drm_i2c_encoder_register(THIS_MODULE, &adv7511_driver);\r\n}\r\nstatic void __exit adv7511_exit(void)\r\n{\r\ndrm_i2c_encoder_unregister(&adv7511_driver);\r\n}
