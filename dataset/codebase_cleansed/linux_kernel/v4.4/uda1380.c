static inline unsigned int uda1380_read_reg_cache(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nu16 *cache = codec->reg_cache;\r\nif (reg == UDA1380_RESET)\r\nreturn 0;\r\nif (reg >= UDA1380_CACHEREGNUM)\r\nreturn -1;\r\nreturn cache[reg];\r\n}\r\nstatic inline void uda1380_write_reg_cache(struct snd_soc_codec *codec,\r\nu16 reg, unsigned int value)\r\n{\r\nu16 *cache = codec->reg_cache;\r\nif (reg >= UDA1380_CACHEREGNUM)\r\nreturn;\r\nif ((reg >= 0x10) && (cache[reg] != value))\r\nset_bit(reg - 0x10, &uda1380_cache_dirty);\r\ncache[reg] = value;\r\n}\r\nstatic int uda1380_write(struct snd_soc_codec *codec, unsigned int reg,\r\nunsigned int value)\r\n{\r\nu8 data[3];\r\ndata[0] = reg;\r\ndata[1] = (value & 0xff00) >> 8;\r\ndata[2] = value & 0x00ff;\r\nuda1380_write_reg_cache(codec, reg, value);\r\nif (!snd_soc_codec_is_active(codec) && (reg >= UDA1380_MVOL))\r\nreturn 0;\r\npr_debug("uda1380: hw write %x val %x\n", reg, value);\r\nif (codec->hw_write(codec->control_data, data, 3) == 3) {\r\nunsigned int val;\r\ni2c_master_send(codec->control_data, data, 1);\r\ni2c_master_recv(codec->control_data, data, 2);\r\nval = (data[0]<<8) | data[1];\r\nif (val != value) {\r\npr_debug("uda1380: READ BACK VAL %x\n",\r\n(data[0]<<8) | data[1]);\r\nreturn -EIO;\r\n}\r\nif (reg >= 0x10)\r\nclear_bit(reg - 0x10, &uda1380_cache_dirty);\r\nreturn 0;\r\n} else\r\nreturn -EIO;\r\n}\r\nstatic void uda1380_sync_cache(struct snd_soc_codec *codec)\r\n{\r\nint reg;\r\nu8 data[3];\r\nu16 *cache = codec->reg_cache;\r\nfor (reg = 0; reg < UDA1380_MVOL; reg++) {\r\ndata[0] = reg;\r\ndata[1] = (cache[reg] & 0xff00) >> 8;\r\ndata[2] = cache[reg] & 0x00ff;\r\nif (codec->hw_write(codec->control_data, data, 3) != 3)\r\ndev_err(codec->dev, "%s: write to reg 0x%x failed\n",\r\n__func__, reg);\r\n}\r\n}\r\nstatic int uda1380_reset(struct snd_soc_codec *codec)\r\n{\r\nstruct uda1380_platform_data *pdata = codec->dev->platform_data;\r\nif (gpio_is_valid(pdata->gpio_reset)) {\r\ngpio_set_value(pdata->gpio_reset, 1);\r\nmdelay(1);\r\ngpio_set_value(pdata->gpio_reset, 0);\r\n} else {\r\nu8 data[3];\r\ndata[0] = UDA1380_RESET;\r\ndata[1] = 0;\r\ndata[2] = 0;\r\nif (codec->hw_write(codec->control_data, data, 3) != 3) {\r\ndev_err(codec->dev, "%s: failed\n", __func__);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void uda1380_flush_work(struct work_struct *work)\r\n{\r\nstruct uda1380_priv *uda1380 = container_of(work, struct uda1380_priv, work);\r\nstruct snd_soc_codec *uda1380_codec = uda1380->codec;\r\nint bit, reg;\r\nfor_each_set_bit(bit, &uda1380_cache_dirty, UDA1380_CACHEREGNUM - 0x10) {\r\nreg = 0x10 + bit;\r\npr_debug("uda1380: flush reg %x val %x:\n", reg,\r\nuda1380_read_reg_cache(uda1380_codec, reg));\r\nuda1380_write(uda1380_codec, reg,\r\nuda1380_read_reg_cache(uda1380_codec, reg));\r\nclear_bit(bit, &uda1380_cache_dirty);\r\n}\r\n}\r\nstatic int uda1380_set_dai_fmt_both(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nint iface;\r\niface = uda1380_read_reg_cache(codec, UDA1380_IFACE);\r\niface &= ~(R01_SFORI_MASK | R01_SIM | R01_SFORO_MASK);\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\niface |= R01_SFORI_I2S | R01_SFORO_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LSB:\r\niface |= R01_SFORI_LSB16 | R01_SFORO_LSB16;\r\nbreak;\r\ncase SND_SOC_DAIFMT_MSB:\r\niface |= R01_SFORI_MSB | R01_SFORO_MSB;\r\n}\r\nif ((fmt & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS)\r\nreturn -EINVAL;\r\nuda1380_write_reg_cache(codec, UDA1380_IFACE, iface);\r\nreturn 0;\r\n}\r\nstatic int uda1380_set_dai_fmt_playback(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nint iface;\r\niface = uda1380_read_reg_cache(codec, UDA1380_IFACE);\r\niface &= ~R01_SFORI_MASK;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\niface |= R01_SFORI_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LSB:\r\niface |= R01_SFORI_LSB16;\r\nbreak;\r\ncase SND_SOC_DAIFMT_MSB:\r\niface |= R01_SFORI_MSB;\r\n}\r\nif ((fmt & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS)\r\nreturn -EINVAL;\r\nuda1380_write(codec, UDA1380_IFACE, iface);\r\nreturn 0;\r\n}\r\nstatic int uda1380_set_dai_fmt_capture(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nint iface;\r\niface = uda1380_read_reg_cache(codec, UDA1380_IFACE);\r\niface &= ~(R01_SIM | R01_SFORO_MASK);\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\niface |= R01_SFORO_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LSB:\r\niface |= R01_SFORO_LSB16;\r\nbreak;\r\ncase SND_SOC_DAIFMT_MSB:\r\niface |= R01_SFORO_MSB;\r\n}\r\nif ((fmt & SND_SOC_DAIFMT_MASTER_MASK) == SND_SOC_DAIFMT_CBM_CFM)\r\niface |= R01_SIM;\r\nuda1380_write(codec, UDA1380_IFACE, iface);\r\nreturn 0;\r\n}\r\nstatic int uda1380_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct uda1380_priv *uda1380 = snd_soc_codec_get_drvdata(codec);\r\nint mixer = uda1380_read_reg_cache(codec, UDA1380_MIXER);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nuda1380_write_reg_cache(codec, UDA1380_MIXER,\r\nmixer & ~R14_SILENCE);\r\nschedule_work(&uda1380->work);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nuda1380_write_reg_cache(codec, UDA1380_MIXER,\r\nmixer | R14_SILENCE);\r\nschedule_work(&uda1380->work);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uda1380_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 clk = uda1380_read_reg_cache(codec, UDA1380_CLK);\r\nif (clk & R00_DAC_CLK) {\r\nint rate = params_rate(params);\r\nu16 pm = uda1380_read_reg_cache(codec, UDA1380_PM);\r\nclk &= ~0x3;\r\nswitch (rate) {\r\ncase 6250 ... 12500:\r\nclk |= 0x0;\r\nbreak;\r\ncase 12501 ... 25000:\r\nclk |= 0x1;\r\nbreak;\r\ncase 25001 ... 50000:\r\nclk |= 0x2;\r\nbreak;\r\ncase 50001 ... 100000:\r\nclk |= 0x3;\r\nbreak;\r\n}\r\nuda1380_write(codec, UDA1380_PM, R02_PON_PLL | pm);\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nclk |= R00_EN_DAC | R00_EN_INT;\r\nelse\r\nclk |= R00_EN_ADC | R00_EN_DEC;\r\nuda1380_write(codec, UDA1380_CLK, clk);\r\nreturn 0;\r\n}\r\nstatic void uda1380_pcm_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 clk = uda1380_read_reg_cache(codec, UDA1380_CLK);\r\nif (clk & R00_DAC_CLK) {\r\nu16 pm = uda1380_read_reg_cache(codec, UDA1380_PM);\r\nuda1380_write(codec, UDA1380_PM, ~R02_PON_PLL & pm);\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nclk &= ~(R00_EN_DAC | R00_EN_INT);\r\nelse\r\nclk &= ~(R00_EN_ADC | R00_EN_DEC);\r\nuda1380_write(codec, UDA1380_CLK, clk);\r\n}\r\nstatic int uda1380_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nint pm = uda1380_read_reg_cache(codec, UDA1380_PM);\r\nint reg;\r\nstruct uda1380_platform_data *pdata = codec->dev->platform_data;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\nuda1380_write(codec, UDA1380_PM, R02_PON_BIAS | pm);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {\r\nif (gpio_is_valid(pdata->gpio_power)) {\r\ngpio_set_value(pdata->gpio_power, 1);\r\nmdelay(1);\r\nuda1380_reset(codec);\r\n}\r\nuda1380_sync_cache(codec);\r\n}\r\nuda1380_write(codec, UDA1380_PM, 0x0);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nif (!gpio_is_valid(pdata->gpio_power))\r\nbreak;\r\ngpio_set_value(pdata->gpio_power, 0);\r\nfor (reg = UDA1380_MVOL; reg < UDA1380_CACHEREGNUM; reg++)\r\nset_bit(reg - 0x10, &uda1380_cache_dirty);\r\n}\r\nreturn 0;\r\n}\r\nstatic int uda1380_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct uda1380_platform_data *pdata =codec->dev->platform_data;\r\nstruct uda1380_priv *uda1380 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nuda1380->codec = codec;\r\ncodec->hw_write = (hw_write_t)i2c_master_send;\r\ncodec->control_data = uda1380->control_data;\r\nif (!pdata)\r\nreturn -EINVAL;\r\nif (gpio_is_valid(pdata->gpio_reset)) {\r\nret = gpio_request_one(pdata->gpio_reset, GPIOF_OUT_INIT_LOW,\r\n"uda1380 reset");\r\nif (ret)\r\ngoto err_out;\r\n}\r\nif (gpio_is_valid(pdata->gpio_power)) {\r\nret = gpio_request_one(pdata->gpio_power, GPIOF_OUT_INIT_LOW,\r\n"uda1380 power");\r\nif (ret)\r\ngoto err_free_gpio;\r\n} else {\r\nret = uda1380_reset(codec);\r\nif (ret)\r\ngoto err_free_gpio;\r\n}\r\nINIT_WORK(&uda1380->work, uda1380_flush_work);\r\nswitch (pdata->dac_clk) {\r\ncase UDA1380_DAC_CLK_SYSCLK:\r\nuda1380_write_reg_cache(codec, UDA1380_CLK, 0);\r\nbreak;\r\ncase UDA1380_DAC_CLK_WSPLL:\r\nuda1380_write_reg_cache(codec, UDA1380_CLK,\r\nR00_DAC_CLK);\r\nbreak;\r\n}\r\nreturn 0;\r\nerr_free_gpio:\r\nif (gpio_is_valid(pdata->gpio_reset))\r\ngpio_free(pdata->gpio_reset);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic int uda1380_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct uda1380_platform_data *pdata =codec->dev->platform_data;\r\ngpio_free(pdata->gpio_reset);\r\ngpio_free(pdata->gpio_power);\r\nreturn 0;\r\n}\r\nstatic int uda1380_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct uda1380_priv *uda1380;\r\nint ret;\r\nuda1380 = devm_kzalloc(&i2c->dev, sizeof(struct uda1380_priv),\r\nGFP_KERNEL);\r\nif (uda1380 == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, uda1380);\r\nuda1380->control_data = i2c;\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_uda1380, uda1380_dai, ARRAY_SIZE(uda1380_dai));\r\nreturn ret;\r\n}\r\nstatic int uda1380_i2c_remove(struct i2c_client *i2c)\r\n{\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nreturn 0;\r\n}\r\nstatic int __init uda1380_modinit(void)\r\n{\r\nint ret = 0;\r\n#if IS_ENABLED(CONFIG_I2C)\r\nret = i2c_add_driver(&uda1380_i2c_driver);\r\nif (ret != 0)\r\npr_err("Failed to register UDA1380 I2C driver: %d\n", ret);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit uda1380_exit(void)\r\n{\r\n#if IS_ENABLED(CONFIG_I2C)\r\ni2c_del_driver(&uda1380_i2c_driver);\r\n#endif\r\n}
