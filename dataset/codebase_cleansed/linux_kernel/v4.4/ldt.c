static inline int modify_ldt (int func, void *ptr, unsigned long bytecount)\r\n{\r\nreturn syscall(__NR_modify_ldt, func, ptr, bytecount);\r\n}\r\nstatic long write_ldt_entry(struct mm_id *mm_idp, int func,\r\nstruct user_desc *desc, void **addr, int done)\r\n{\r\nlong res;\r\nvoid *stub_addr;\r\nres = syscall_stub_data(mm_idp, (unsigned long *)desc,\r\n(sizeof(*desc) + sizeof(long) - 1) &\r\n~(sizeof(long) - 1),\r\naddr, &stub_addr);\r\nif (!res) {\r\nunsigned long args[] = { func,\r\n(unsigned long)stub_addr,\r\nsizeof(*desc),\r\n0, 0, 0 };\r\nres = run_syscall_stub(mm_idp, __NR_modify_ldt, args,\r\n0, addr, done);\r\n}\r\nreturn res;\r\n}\r\nstatic int read_ldt(void __user * ptr, unsigned long bytecount)\r\n{\r\nint i, err = 0;\r\nunsigned long size;\r\numl_ldt_t *ldt = &current->mm->context.arch.ldt;\r\nif (!ldt->entry_count)\r\ngoto out;\r\nif (bytecount > LDT_ENTRY_SIZE*LDT_ENTRIES)\r\nbytecount = LDT_ENTRY_SIZE*LDT_ENTRIES;\r\nerr = bytecount;\r\nmutex_lock(&ldt->lock);\r\nif (ldt->entry_count <= LDT_DIRECT_ENTRIES) {\r\nsize = LDT_ENTRY_SIZE*LDT_DIRECT_ENTRIES;\r\nif (size > bytecount)\r\nsize = bytecount;\r\nif (copy_to_user(ptr, ldt->u.entries, size))\r\nerr = -EFAULT;\r\nbytecount -= size;\r\nptr += size;\r\n}\r\nelse {\r\nfor (i=0; i<ldt->entry_count/LDT_ENTRIES_PER_PAGE && bytecount;\r\ni++) {\r\nsize = PAGE_SIZE;\r\nif (size > bytecount)\r\nsize = bytecount;\r\nif (copy_to_user(ptr, ldt->u.pages[i], size)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nbytecount -= size;\r\nptr += size;\r\n}\r\n}\r\nmutex_unlock(&ldt->lock);\r\nif (bytecount == 0 || err == -EFAULT)\r\ngoto out;\r\nif (clear_user(ptr, bytecount))\r\nerr = -EFAULT;\r\nout:\r\nreturn err;\r\n}\r\nstatic int read_default_ldt(void __user * ptr, unsigned long bytecount)\r\n{\r\nint err;\r\nif (bytecount > 5*LDT_ENTRY_SIZE)\r\nbytecount = 5*LDT_ENTRY_SIZE;\r\nerr = bytecount;\r\nif (clear_user(ptr, bytecount))\r\nerr = -EFAULT;\r\nreturn err;\r\n}\r\nstatic int write_ldt(void __user * ptr, unsigned long bytecount, int func)\r\n{\r\numl_ldt_t *ldt = &current->mm->context.arch.ldt;\r\nstruct mm_id * mm_idp = &current->mm->context.id;\r\nint i, err;\r\nstruct user_desc ldt_info;\r\nstruct ldt_entry entry0, *ldt_p;\r\nvoid *addr = NULL;\r\nerr = -EINVAL;\r\nif (bytecount != sizeof(ldt_info))\r\ngoto out;\r\nerr = -EFAULT;\r\nif (copy_from_user(&ldt_info, ptr, sizeof(ldt_info)))\r\ngoto out;\r\nerr = -EINVAL;\r\nif (ldt_info.entry_number >= LDT_ENTRIES)\r\ngoto out;\r\nif (ldt_info.contents == 3) {\r\nif (func == 1)\r\ngoto out;\r\nif (ldt_info.seg_not_present == 0)\r\ngoto out;\r\n}\r\nmutex_lock(&ldt->lock);\r\nerr = write_ldt_entry(mm_idp, func, &ldt_info, &addr, 1);\r\nif (err)\r\ngoto out_unlock;\r\nif (ldt_info.entry_number >= ldt->entry_count &&\r\nldt_info.entry_number >= LDT_DIRECT_ENTRIES) {\r\nfor (i=ldt->entry_count/LDT_ENTRIES_PER_PAGE;\r\ni*LDT_ENTRIES_PER_PAGE <= ldt_info.entry_number;\r\ni++) {\r\nif (i == 0)\r\nmemcpy(&entry0, ldt->u.entries,\r\nsizeof(entry0));\r\nldt->u.pages[i] = (struct ldt_entry *)\r\n__get_free_page(GFP_KERNEL|__GFP_ZERO);\r\nif (!ldt->u.pages[i]) {\r\nerr = -ENOMEM;\r\nmemset(&ldt_info, 0, sizeof(ldt_info));\r\nwrite_ldt_entry(mm_idp, 1, &ldt_info, &addr, 1);\r\ngoto out_unlock;\r\n}\r\nif (i == 0) {\r\nmemcpy(ldt->u.pages[0], &entry0,\r\nsizeof(entry0));\r\nmemcpy(ldt->u.pages[0]+1, ldt->u.entries+1,\r\nsizeof(entry0)*(LDT_DIRECT_ENTRIES-1));\r\n}\r\nldt->entry_count = (i + 1) * LDT_ENTRIES_PER_PAGE;\r\n}\r\n}\r\nif (ldt->entry_count <= ldt_info.entry_number)\r\nldt->entry_count = ldt_info.entry_number + 1;\r\nif (ldt->entry_count <= LDT_DIRECT_ENTRIES)\r\nldt_p = ldt->u.entries + ldt_info.entry_number;\r\nelse\r\nldt_p = ldt->u.pages[ldt_info.entry_number/LDT_ENTRIES_PER_PAGE] +\r\nldt_info.entry_number%LDT_ENTRIES_PER_PAGE;\r\nif (ldt_info.base_addr == 0 && ldt_info.limit == 0 &&\r\n(func == 1 || LDT_empty(&ldt_info))) {\r\nldt_p->a = 0;\r\nldt_p->b = 0;\r\n}\r\nelse{\r\nif (func == 1)\r\nldt_info.useable = 0;\r\nldt_p->a = LDT_entry_a(&ldt_info);\r\nldt_p->b = LDT_entry_b(&ldt_info);\r\n}\r\nerr = 0;\r\nout_unlock:\r\nmutex_unlock(&ldt->lock);\r\nout:\r\nreturn err;\r\n}\r\nstatic long do_modify_ldt_skas(int func, void __user *ptr,\r\nunsigned long bytecount)\r\n{\r\nint ret = -ENOSYS;\r\nswitch (func) {\r\ncase 0:\r\nret = read_ldt(ptr, bytecount);\r\nbreak;\r\ncase 1:\r\ncase 0x11:\r\nret = write_ldt(ptr, bytecount, func);\r\nbreak;\r\ncase 2:\r\nret = read_default_ldt(ptr, bytecount);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void ldt_get_host_info(void)\r\n{\r\nlong ret;\r\nstruct ldt_entry * ldt;\r\nshort *tmp;\r\nint i, size, k, order;\r\nspin_lock(&host_ldt_lock);\r\nif (host_ldt_entries != NULL) {\r\nspin_unlock(&host_ldt_lock);\r\nreturn;\r\n}\r\nhost_ldt_entries = dummy_list+1;\r\nspin_unlock(&host_ldt_lock);\r\nfor (i = LDT_PAGES_MAX-1, order=0; i; i>>=1, order++)\r\n;\r\nldt = (struct ldt_entry *)\r\n__get_free_pages(GFP_KERNEL|__GFP_ZERO, order);\r\nif (ldt == NULL) {\r\nprintk(KERN_ERR "ldt_get_host_info: couldn't allocate buffer "\r\n"for host ldt\n");\r\nreturn;\r\n}\r\nret = modify_ldt(0, ldt, (1<<order)*PAGE_SIZE);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "ldt_get_host_info: couldn't read host ldt\n");\r\ngoto out_free;\r\n}\r\nif (ret == 0) {\r\nhost_ldt_entries = dummy_list;\r\ngoto out_free;\r\n}\r\nfor (i=0, size=0; i<ret/LDT_ENTRY_SIZE; i++) {\r\nif (ldt[i].a != 0 || ldt[i].b != 0)\r\nsize++;\r\n}\r\nif (size < ARRAY_SIZE(dummy_list))\r\nhost_ldt_entries = dummy_list;\r\nelse {\r\nsize = (size + 1) * sizeof(dummy_list[0]);\r\ntmp = kmalloc(size, GFP_KERNEL);\r\nif (tmp == NULL) {\r\nprintk(KERN_ERR "ldt_get_host_info: couldn't allocate "\r\n"host ldt list\n");\r\ngoto out_free;\r\n}\r\nhost_ldt_entries = tmp;\r\n}\r\nfor (i=0, k=0; i<ret/LDT_ENTRY_SIZE; i++) {\r\nif (ldt[i].a != 0 || ldt[i].b != 0)\r\nhost_ldt_entries[k++] = i;\r\n}\r\nhost_ldt_entries[k] = -1;\r\nout_free:\r\nfree_pages((unsigned long)ldt, order);\r\n}\r\nlong init_new_ldt(struct mm_context *new_mm, struct mm_context *from_mm)\r\n{\r\nstruct user_desc desc;\r\nshort * num_p;\r\nint i;\r\nlong page, err=0;\r\nvoid *addr = NULL;\r\nmutex_init(&new_mm->arch.ldt.lock);\r\nif (!from_mm) {\r\nmemset(&desc, 0, sizeof(desc));\r\nldt_get_host_info();\r\nfor (num_p=host_ldt_entries; *num_p != -1; num_p++) {\r\ndesc.entry_number = *num_p;\r\nerr = write_ldt_entry(&new_mm->id, 1, &desc,\r\n&addr, *(num_p + 1) == -1);\r\nif (err)\r\nbreak;\r\n}\r\nnew_mm->arch.ldt.entry_count = 0;\r\ngoto out;\r\n}\r\nmutex_lock(&from_mm->arch.ldt.lock);\r\nif (from_mm->arch.ldt.entry_count <= LDT_DIRECT_ENTRIES)\r\nmemcpy(new_mm->arch.ldt.u.entries, from_mm->arch.ldt.u.entries,\r\nsizeof(new_mm->arch.ldt.u.entries));\r\nelse {\r\ni = from_mm->arch.ldt.entry_count / LDT_ENTRIES_PER_PAGE;\r\nwhile (i-->0) {\r\npage = __get_free_page(GFP_KERNEL|__GFP_ZERO);\r\nif (!page) {\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\nnew_mm->arch.ldt.u.pages[i] =\r\n(struct ldt_entry *) page;\r\nmemcpy(new_mm->arch.ldt.u.pages[i],\r\nfrom_mm->arch.ldt.u.pages[i], PAGE_SIZE);\r\n}\r\n}\r\nnew_mm->arch.ldt.entry_count = from_mm->arch.ldt.entry_count;\r\nmutex_unlock(&from_mm->arch.ldt.lock);\r\nout:\r\nreturn err;\r\n}\r\nvoid free_ldt(struct mm_context *mm)\r\n{\r\nint i;\r\nif (mm->arch.ldt.entry_count > LDT_DIRECT_ENTRIES) {\r\ni = mm->arch.ldt.entry_count / LDT_ENTRIES_PER_PAGE;\r\nwhile (i-- > 0)\r\nfree_page((long) mm->arch.ldt.u.pages[i]);\r\n}\r\nmm->arch.ldt.entry_count = 0;\r\n}\r\nint sys_modify_ldt(int func, void __user *ptr, unsigned long bytecount)\r\n{\r\nreturn do_modify_ldt_skas(func, ptr, bytecount);\r\n}
