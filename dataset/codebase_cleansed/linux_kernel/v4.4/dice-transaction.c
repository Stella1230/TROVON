static u64 get_subaddr(struct snd_dice *dice, enum snd_dice_addr_type type,\r\nu64 offset)\r\n{\r\nswitch (type) {\r\ncase SND_DICE_ADDR_TYPE_TX:\r\noffset += dice->tx_offset;\r\nbreak;\r\ncase SND_DICE_ADDR_TYPE_RX:\r\noffset += dice->rx_offset;\r\nbreak;\r\ncase SND_DICE_ADDR_TYPE_SYNC:\r\noffset += dice->sync_offset;\r\nbreak;\r\ncase SND_DICE_ADDR_TYPE_RSRV:\r\noffset += dice->rsrv_offset;\r\nbreak;\r\ncase SND_DICE_ADDR_TYPE_GLOBAL:\r\ndefault:\r\noffset += dice->global_offset;\r\nbreak;\r\n}\r\noffset += DICE_PRIVATE_SPACE;\r\nreturn offset;\r\n}\r\nint snd_dice_transaction_write(struct snd_dice *dice,\r\nenum snd_dice_addr_type type,\r\nunsigned int offset, void *buf, unsigned int len)\r\n{\r\nreturn snd_fw_transaction(dice->unit,\r\n(len == 4) ? TCODE_WRITE_QUADLET_REQUEST :\r\nTCODE_WRITE_BLOCK_REQUEST,\r\nget_subaddr(dice, type, offset), buf, len, 0);\r\n}\r\nint snd_dice_transaction_read(struct snd_dice *dice,\r\nenum snd_dice_addr_type type, unsigned int offset,\r\nvoid *buf, unsigned int len)\r\n{\r\nreturn snd_fw_transaction(dice->unit,\r\n(len == 4) ? TCODE_READ_QUADLET_REQUEST :\r\nTCODE_READ_BLOCK_REQUEST,\r\nget_subaddr(dice, type, offset), buf, len, 0);\r\n}\r\nstatic unsigned int get_clock_info(struct snd_dice *dice, __be32 *info)\r\n{\r\nreturn snd_dice_transaction_read_global(dice, GLOBAL_CLOCK_SELECT,\r\ninfo, 4);\r\n}\r\nstatic int set_clock_info(struct snd_dice *dice,\r\nunsigned int rate, unsigned int source)\r\n{\r\nunsigned int retries = 3;\r\nunsigned int i;\r\n__be32 info;\r\nu32 mask;\r\nu32 clock;\r\nint err;\r\nretry:\r\nerr = get_clock_info(dice, &info);\r\nif (err < 0)\r\ngoto end;\r\nclock = be32_to_cpu(info);\r\nif (source != UINT_MAX) {\r\nmask = CLOCK_SOURCE_MASK;\r\nclock &= ~mask;\r\nclock |= source;\r\n}\r\nif (rate != UINT_MAX) {\r\nfor (i = 0; i < ARRAY_SIZE(snd_dice_rates); i++) {\r\nif (snd_dice_rates[i] == rate)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(snd_dice_rates)) {\r\nerr = -EINVAL;\r\ngoto end;\r\n}\r\nmask = CLOCK_RATE_MASK;\r\nclock &= ~mask;\r\nclock |= i << CLOCK_RATE_SHIFT;\r\n}\r\ninfo = cpu_to_be32(clock);\r\nif (completion_done(&dice->clock_accepted))\r\nreinit_completion(&dice->clock_accepted);\r\nerr = snd_dice_transaction_write_global(dice, GLOBAL_CLOCK_SELECT,\r\n&info, 4);\r\nif (err < 0)\r\ngoto end;\r\nif (wait_for_completion_timeout(&dice->clock_accepted,\r\nmsecs_to_jiffies(NOTIFICATION_TIMEOUT_MS)) == 0) {\r\nif (retries-- == 0) {\r\nerr = -ETIMEDOUT;\r\ngoto end;\r\n}\r\nerr = snd_dice_transaction_reinit(dice);\r\nif (err < 0)\r\ngoto end;\r\nmsleep(500);\r\ngoto retry;\r\n}\r\nend:\r\nreturn err;\r\n}\r\nint snd_dice_transaction_get_clock_source(struct snd_dice *dice,\r\nunsigned int *source)\r\n{\r\n__be32 info;\r\nint err;\r\nerr = get_clock_info(dice, &info);\r\nif (err >= 0)\r\n*source = be32_to_cpu(info) & CLOCK_SOURCE_MASK;\r\nreturn err;\r\n}\r\nint snd_dice_transaction_get_rate(struct snd_dice *dice, unsigned int *rate)\r\n{\r\n__be32 info;\r\nunsigned int index;\r\nint err;\r\nerr = get_clock_info(dice, &info);\r\nif (err < 0)\r\ngoto end;\r\nindex = (be32_to_cpu(info) & CLOCK_RATE_MASK) >> CLOCK_RATE_SHIFT;\r\nif (index >= SND_DICE_RATES_COUNT) {\r\nerr = -ENOSYS;\r\ngoto end;\r\n}\r\n*rate = snd_dice_rates[index];\r\nend:\r\nreturn err;\r\n}\r\nint snd_dice_transaction_set_rate(struct snd_dice *dice, unsigned int rate)\r\n{\r\nreturn set_clock_info(dice, rate, UINT_MAX);\r\n}\r\nint snd_dice_transaction_set_enable(struct snd_dice *dice)\r\n{\r\n__be32 value;\r\nint err = 0;\r\nif (dice->global_enabled)\r\ngoto end;\r\nvalue = cpu_to_be32(1);\r\nerr = snd_fw_transaction(dice->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nget_subaddr(dice, SND_DICE_ADDR_TYPE_GLOBAL,\r\nGLOBAL_ENABLE),\r\n&value, 4,\r\nFW_FIXED_GENERATION | dice->owner_generation);\r\nif (err < 0)\r\ngoto end;\r\ndice->global_enabled = true;\r\nend:\r\nreturn err;\r\n}\r\nvoid snd_dice_transaction_clear_enable(struct snd_dice *dice)\r\n{\r\n__be32 value;\r\nvalue = 0;\r\nsnd_fw_transaction(dice->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nget_subaddr(dice, SND_DICE_ADDR_TYPE_GLOBAL,\r\nGLOBAL_ENABLE),\r\n&value, 4, FW_QUIET |\r\nFW_FIXED_GENERATION | dice->owner_generation);\r\ndice->global_enabled = false;\r\n}\r\nstatic void dice_notification(struct fw_card *card, struct fw_request *request,\r\nint tcode, int destination, int source,\r\nint generation, unsigned long long offset,\r\nvoid *data, size_t length, void *callback_data)\r\n{\r\nstruct snd_dice *dice = callback_data;\r\nu32 bits;\r\nunsigned long flags;\r\nif (tcode != TCODE_WRITE_QUADLET_REQUEST) {\r\nfw_send_response(card, request, RCODE_TYPE_ERROR);\r\nreturn;\r\n}\r\nif ((offset & 3) != 0) {\r\nfw_send_response(card, request, RCODE_ADDRESS_ERROR);\r\nreturn;\r\n}\r\nbits = be32_to_cpup(data);\r\nspin_lock_irqsave(&dice->lock, flags);\r\ndice->notification_bits |= bits;\r\nspin_unlock_irqrestore(&dice->lock, flags);\r\nfw_send_response(card, request, RCODE_COMPLETE);\r\nif (bits & NOTIFY_CLOCK_ACCEPTED)\r\ncomplete(&dice->clock_accepted);\r\nwake_up(&dice->hwdep_wait);\r\n}\r\nstatic int register_notification_address(struct snd_dice *dice, bool retry)\r\n{\r\nstruct fw_device *device = fw_parent_device(dice->unit);\r\n__be64 *buffer;\r\nunsigned int retries;\r\nint err;\r\nretries = (retry) ? 3 : 0;\r\nbuffer = kmalloc(2 * 8, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nfor (;;) {\r\nbuffer[0] = cpu_to_be64(OWNER_NO_OWNER);\r\nbuffer[1] = cpu_to_be64(\r\n((u64)device->card->node_id << OWNER_NODE_SHIFT) |\r\ndice->notification_handler.offset);\r\ndice->owner_generation = device->generation;\r\nsmp_rmb();\r\nerr = snd_fw_transaction(dice->unit, TCODE_LOCK_COMPARE_SWAP,\r\nget_subaddr(dice,\r\nSND_DICE_ADDR_TYPE_GLOBAL,\r\nGLOBAL_OWNER),\r\nbuffer, 2 * 8,\r\nFW_FIXED_GENERATION |\r\ndice->owner_generation);\r\nif (err == 0) {\r\nif (buffer[0] == cpu_to_be64(OWNER_NO_OWNER))\r\nbreak;\r\nif (buffer[0] == buffer[1])\r\nbreak;\r\ndev_err(&dice->unit->device,\r\n"device is already in use\n");\r\nerr = -EBUSY;\r\n}\r\nif (err != -EAGAIN || retries-- > 0)\r\nbreak;\r\nmsleep(20);\r\n}\r\nkfree(buffer);\r\nif (err < 0)\r\ndice->owner_generation = -1;\r\nreturn err;\r\n}\r\nstatic void unregister_notification_address(struct snd_dice *dice)\r\n{\r\nstruct fw_device *device = fw_parent_device(dice->unit);\r\n__be64 *buffer;\r\nbuffer = kmalloc(2 * 8, GFP_KERNEL);\r\nif (buffer == NULL)\r\nreturn;\r\nbuffer[0] = cpu_to_be64(\r\n((u64)device->card->node_id << OWNER_NODE_SHIFT) |\r\ndice->notification_handler.offset);\r\nbuffer[1] = cpu_to_be64(OWNER_NO_OWNER);\r\nsnd_fw_transaction(dice->unit, TCODE_LOCK_COMPARE_SWAP,\r\nget_subaddr(dice, SND_DICE_ADDR_TYPE_GLOBAL,\r\nGLOBAL_OWNER),\r\nbuffer, 2 * 8, FW_QUIET |\r\nFW_FIXED_GENERATION | dice->owner_generation);\r\nkfree(buffer);\r\ndice->owner_generation = -1;\r\n}\r\nvoid snd_dice_transaction_destroy(struct snd_dice *dice)\r\n{\r\nstruct fw_address_handler *handler = &dice->notification_handler;\r\nif (handler->callback_data == NULL)\r\nreturn;\r\nunregister_notification_address(dice);\r\nfw_core_remove_address_handler(handler);\r\nhandler->callback_data = NULL;\r\n}\r\nint snd_dice_transaction_reinit(struct snd_dice *dice)\r\n{\r\nstruct fw_address_handler *handler = &dice->notification_handler;\r\nif (handler->callback_data == NULL)\r\nreturn -EINVAL;\r\nreturn register_notification_address(dice, false);\r\n}\r\nint snd_dice_transaction_init(struct snd_dice *dice)\r\n{\r\nstruct fw_address_handler *handler = &dice->notification_handler;\r\n__be32 *pointers;\r\nint err;\r\npointers = kmalloc(sizeof(__be32) * 10, GFP_KERNEL);\r\nif (pointers == NULL)\r\nreturn -ENOMEM;\r\nerr = snd_fw_transaction(dice->unit, TCODE_READ_BLOCK_REQUEST,\r\nDICE_PRIVATE_SPACE,\r\npointers, sizeof(__be32) * 10, 0);\r\nif (err < 0)\r\ngoto end;\r\nhandler->length = 4;\r\nhandler->address_callback = dice_notification;\r\nhandler->callback_data = dice;\r\nerr = fw_core_add_address_handler(handler, &fw_high_memory_region);\r\nif (err < 0) {\r\nhandler->callback_data = NULL;\r\ngoto end;\r\n}\r\nerr = register_notification_address(dice, true);\r\nif (err < 0) {\r\nfw_core_remove_address_handler(handler);\r\nhandler->callback_data = NULL;\r\ngoto end;\r\n}\r\ndice->global_offset = be32_to_cpu(pointers[0]) * 4;\r\ndice->tx_offset = be32_to_cpu(pointers[2]) * 4;\r\ndice->rx_offset = be32_to_cpu(pointers[4]) * 4;\r\ndice->sync_offset = be32_to_cpu(pointers[6]) * 4;\r\ndice->rsrv_offset = be32_to_cpu(pointers[8]) * 4;\r\nif (be32_to_cpu(pointers[1]) * 4 >= GLOBAL_CLOCK_CAPABILITIES + 4)\r\ndice->clock_caps = 1;\r\nend:\r\nkfree(pointers);\r\nreturn err;\r\n}
