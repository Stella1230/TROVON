int register_adapter_interrupt(struct airq_struct *airq)\r\n{\r\nchar dbf_txt[32];\r\nif (!airq->handler || airq->isc > MAX_ISC)\r\nreturn -EINVAL;\r\nif (!airq->lsi_ptr) {\r\nairq->lsi_ptr = kzalloc(1, GFP_KERNEL);\r\nif (!airq->lsi_ptr)\r\nreturn -ENOMEM;\r\nairq->flags |= AIRQ_PTR_ALLOCATED;\r\n}\r\nif (!airq->lsi_mask)\r\nairq->lsi_mask = 0xff;\r\nsnprintf(dbf_txt, sizeof(dbf_txt), "rairq:%p", airq);\r\nCIO_TRACE_EVENT(4, dbf_txt);\r\nisc_register(airq->isc);\r\nspin_lock(&airq_lists_lock);\r\nhlist_add_head_rcu(&airq->list, &airq_lists[airq->isc]);\r\nspin_unlock(&airq_lists_lock);\r\nreturn 0;\r\n}\r\nvoid unregister_adapter_interrupt(struct airq_struct *airq)\r\n{\r\nchar dbf_txt[32];\r\nif (hlist_unhashed(&airq->list))\r\nreturn;\r\nsnprintf(dbf_txt, sizeof(dbf_txt), "urairq:%p", airq);\r\nCIO_TRACE_EVENT(4, dbf_txt);\r\nspin_lock(&airq_lists_lock);\r\nhlist_del_rcu(&airq->list);\r\nspin_unlock(&airq_lists_lock);\r\nsynchronize_rcu();\r\nisc_unregister(airq->isc);\r\nif (airq->flags & AIRQ_PTR_ALLOCATED) {\r\nkfree(airq->lsi_ptr);\r\nairq->lsi_ptr = NULL;\r\nairq->flags &= ~AIRQ_PTR_ALLOCATED;\r\n}\r\n}\r\nstatic irqreturn_t do_airq_interrupt(int irq, void *dummy)\r\n{\r\nstruct tpi_info *tpi_info;\r\nstruct airq_struct *airq;\r\nstruct hlist_head *head;\r\nset_cpu_flag(CIF_NOHZ_DELAY);\r\ntpi_info = (struct tpi_info *) &get_irq_regs()->int_code;\r\nhead = &airq_lists[tpi_info->isc];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(airq, head, list)\r\nif ((*airq->lsi_ptr & airq->lsi_mask) != 0)\r\nairq->handler(airq);\r\nrcu_read_unlock();\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid __init init_airq_interrupts(void)\r\n{\r\nirq_set_chip_and_handler(THIN_INTERRUPT,\r\n&dummy_irq_chip, handle_percpu_irq);\r\nsetup_irq(THIN_INTERRUPT, &airq_interrupt);\r\n}\r\nstruct airq_iv *airq_iv_create(unsigned long bits, unsigned long flags)\r\n{\r\nstruct airq_iv *iv;\r\nunsigned long size;\r\niv = kzalloc(sizeof(*iv), GFP_KERNEL);\r\nif (!iv)\r\ngoto out;\r\niv->bits = bits;\r\nsize = BITS_TO_LONGS(bits) * sizeof(unsigned long);\r\niv->vector = kzalloc(size, GFP_KERNEL);\r\nif (!iv->vector)\r\ngoto out_free;\r\nif (flags & AIRQ_IV_ALLOC) {\r\niv->avail = kmalloc(size, GFP_KERNEL);\r\nif (!iv->avail)\r\ngoto out_free;\r\nmemset(iv->avail, 0xff, size);\r\niv->end = 0;\r\n} else\r\niv->end = bits;\r\nif (flags & AIRQ_IV_BITLOCK) {\r\niv->bitlock = kzalloc(size, GFP_KERNEL);\r\nif (!iv->bitlock)\r\ngoto out_free;\r\n}\r\nif (flags & AIRQ_IV_PTR) {\r\nsize = bits * sizeof(unsigned long);\r\niv->ptr = kzalloc(size, GFP_KERNEL);\r\nif (!iv->ptr)\r\ngoto out_free;\r\n}\r\nif (flags & AIRQ_IV_DATA) {\r\nsize = bits * sizeof(unsigned int);\r\niv->data = kzalloc(size, GFP_KERNEL);\r\nif (!iv->data)\r\ngoto out_free;\r\n}\r\nspin_lock_init(&iv->lock);\r\nreturn iv;\r\nout_free:\r\nkfree(iv->ptr);\r\nkfree(iv->bitlock);\r\nkfree(iv->avail);\r\nkfree(iv->vector);\r\nkfree(iv);\r\nout:\r\nreturn NULL;\r\n}\r\nvoid airq_iv_release(struct airq_iv *iv)\r\n{\r\nkfree(iv->data);\r\nkfree(iv->ptr);\r\nkfree(iv->bitlock);\r\nkfree(iv->vector);\r\nkfree(iv->avail);\r\nkfree(iv);\r\n}\r\nunsigned long airq_iv_alloc(struct airq_iv *iv, unsigned long num)\r\n{\r\nunsigned long bit, i, flags;\r\nif (!iv->avail || num == 0)\r\nreturn -1UL;\r\nspin_lock_irqsave(&iv->lock, flags);\r\nbit = find_first_bit_inv(iv->avail, iv->bits);\r\nwhile (bit + num <= iv->bits) {\r\nfor (i = 1; i < num; i++)\r\nif (!test_bit_inv(bit + i, iv->avail))\r\nbreak;\r\nif (i >= num) {\r\nfor (i = 0; i < num; i++)\r\nclear_bit_inv(bit + i, iv->avail);\r\nif (bit + num >= iv->end)\r\niv->end = bit + num + 1;\r\nbreak;\r\n}\r\nbit = find_next_bit_inv(iv->avail, iv->bits, bit + i + 1);\r\n}\r\nif (bit + num > iv->bits)\r\nbit = -1UL;\r\nspin_unlock_irqrestore(&iv->lock, flags);\r\nreturn bit;\r\n}\r\nvoid airq_iv_free(struct airq_iv *iv, unsigned long bit, unsigned long num)\r\n{\r\nunsigned long i, flags;\r\nif (!iv->avail || num == 0)\r\nreturn;\r\nspin_lock_irqsave(&iv->lock, flags);\r\nfor (i = 0; i < num; i++) {\r\nclear_bit_inv(bit + i, iv->vector);\r\nset_bit_inv(bit + i, iv->avail);\r\n}\r\nif (bit + num >= iv->end) {\r\nwhile (iv->end > 0 && !test_bit_inv(iv->end - 1, iv->avail))\r\niv->end--;\r\n}\r\nspin_unlock_irqrestore(&iv->lock, flags);\r\n}\r\nunsigned long airq_iv_scan(struct airq_iv *iv, unsigned long start,\r\nunsigned long end)\r\n{\r\nunsigned long bit;\r\nbit = find_next_bit_inv(iv->vector, end, start);\r\nif (bit >= end)\r\nreturn -1UL;\r\nclear_bit_inv(bit, iv->vector);\r\nreturn bit;\r\n}
