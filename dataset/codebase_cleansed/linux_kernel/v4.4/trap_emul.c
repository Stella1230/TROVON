static gpa_t kvm_trap_emul_gva_to_gpa_cb(gva_t gva)\r\n{\r\ngpa_t gpa;\r\nuint32_t kseg = KSEGX(gva);\r\nif ((kseg == CKSEG0) || (kseg == CKSEG1))\r\ngpa = CPHYSADDR(gva);\r\nelse {\r\nkvm_err("%s: cannot find GPA for GVA: %#lx\n", __func__, gva);\r\nkvm_mips_dump_host_tlbs();\r\ngpa = KVM_INVALID_ADDR;\r\n}\r\nkvm_debug("%s: gva %#lx, gpa: %#llx\n", __func__, gva, gpa);\r\nreturn gpa;\r\n}\r\nstatic int kvm_trap_emul_handle_cop_unusable(struct kvm_vcpu *vcpu)\r\n{\r\nstruct mips_coproc *cop0 = vcpu->arch.cop0;\r\nstruct kvm_run *run = vcpu->run;\r\nuint32_t __user *opc = (uint32_t __user *) vcpu->arch.pc;\r\nunsigned long cause = vcpu->arch.host_cp0_cause;\r\nenum emulation_result er = EMULATE_DONE;\r\nint ret = RESUME_GUEST;\r\nif (((cause & CAUSEF_CE) >> CAUSEB_CE) == 1) {\r\nif (!kvm_mips_guest_has_fpu(&vcpu->arch) ||\r\n(kvm_read_c0_guest_status(cop0) & ST0_CU1) == 0) {\r\ner = kvm_mips_emulate_fpu_exc(cause, opc, run, vcpu);\r\n} else {\r\nkvm_own_fpu(vcpu);\r\ner = EMULATE_DONE;\r\n}\r\n} else {\r\ner = kvm_mips_emulate_inst(cause, opc, run, vcpu);\r\n}\r\nswitch (er) {\r\ncase EMULATE_DONE:\r\nret = RESUME_GUEST;\r\nbreak;\r\ncase EMULATE_FAIL:\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\nbreak;\r\ncase EMULATE_WAIT:\r\nrun->exit_reason = KVM_EXIT_INTR;\r\nret = RESUME_HOST;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn ret;\r\n}\r\nstatic int kvm_trap_emul_handle_tlb_mod(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_run *run = vcpu->run;\r\nuint32_t __user *opc = (uint32_t __user *) vcpu->arch.pc;\r\nunsigned long badvaddr = vcpu->arch.host_cp0_badvaddr;\r\nunsigned long cause = vcpu->arch.host_cp0_cause;\r\nenum emulation_result er = EMULATE_DONE;\r\nint ret = RESUME_GUEST;\r\nif (KVM_GUEST_KSEGX(badvaddr) < KVM_GUEST_KSEG0\r\n|| KVM_GUEST_KSEGX(badvaddr) == KVM_GUEST_KSEG23) {\r\nkvm_debug("USER/KSEG23 ADDR TLB MOD fault: cause %#lx, PC: %p, BadVaddr: %#lx\n",\r\ncause, opc, badvaddr);\r\ner = kvm_mips_handle_tlbmod(cause, opc, run, vcpu);\r\nif (er == EMULATE_DONE)\r\nret = RESUME_GUEST;\r\nelse {\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n}\r\n} else if (KVM_GUEST_KSEGX(badvaddr) == KVM_GUEST_KSEG0) {\r\nkvm_err("TLB MOD fault not handled, cause %#lx, PC: %p, BadVaddr: %#lx\n",\r\ncause, opc, badvaddr);\r\nkvm_mips_dump_host_tlbs();\r\nkvm_arch_vcpu_dump_regs(vcpu);\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n} else {\r\nkvm_err("Illegal TLB Mod fault address , cause %#lx, PC: %p, BadVaddr: %#lx\n",\r\ncause, opc, badvaddr);\r\nkvm_mips_dump_host_tlbs();\r\nkvm_arch_vcpu_dump_regs(vcpu);\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n}\r\nreturn ret;\r\n}\r\nstatic int kvm_trap_emul_handle_tlb_st_miss(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_run *run = vcpu->run;\r\nuint32_t __user *opc = (uint32_t __user *) vcpu->arch.pc;\r\nunsigned long badvaddr = vcpu->arch.host_cp0_badvaddr;\r\nunsigned long cause = vcpu->arch.host_cp0_cause;\r\nenum emulation_result er = EMULATE_DONE;\r\nint ret = RESUME_GUEST;\r\nif (((badvaddr & PAGE_MASK) == KVM_GUEST_COMMPAGE_ADDR)\r\n&& KVM_GUEST_KERNEL_MODE(vcpu)) {\r\nif (kvm_mips_handle_commpage_tlb_fault(badvaddr, vcpu) < 0) {\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n}\r\n} else if (KVM_GUEST_KSEGX(badvaddr) < KVM_GUEST_KSEG0\r\n|| KVM_GUEST_KSEGX(badvaddr) == KVM_GUEST_KSEG23) {\r\nkvm_debug("USER ADDR TLB LD fault: cause %#lx, PC: %p, BadVaddr: %#lx\n",\r\ncause, opc, badvaddr);\r\ner = kvm_mips_handle_tlbmiss(cause, opc, run, vcpu);\r\nif (er == EMULATE_DONE)\r\nret = RESUME_GUEST;\r\nelse {\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n}\r\n} else if (KVM_GUEST_KSEGX(badvaddr) == KVM_GUEST_KSEG0) {\r\nif (kvm_mips_handle_kseg0_tlb_fault\r\n(vcpu->arch.host_cp0_badvaddr, vcpu) < 0) {\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n}\r\n} else {\r\nkvm_err("Illegal TLB LD fault address , cause %#lx, PC: %p, BadVaddr: %#lx\n",\r\ncause, opc, badvaddr);\r\nkvm_mips_dump_host_tlbs();\r\nkvm_arch_vcpu_dump_regs(vcpu);\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n}\r\nreturn ret;\r\n}\r\nstatic int kvm_trap_emul_handle_tlb_ld_miss(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_run *run = vcpu->run;\r\nuint32_t __user *opc = (uint32_t __user *) vcpu->arch.pc;\r\nunsigned long badvaddr = vcpu->arch.host_cp0_badvaddr;\r\nunsigned long cause = vcpu->arch.host_cp0_cause;\r\nenum emulation_result er = EMULATE_DONE;\r\nint ret = RESUME_GUEST;\r\nif (((badvaddr & PAGE_MASK) == KVM_GUEST_COMMPAGE_ADDR)\r\n&& KVM_GUEST_KERNEL_MODE(vcpu)) {\r\nif (kvm_mips_handle_commpage_tlb_fault(badvaddr, vcpu) < 0) {\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n}\r\n} else if (KVM_GUEST_KSEGX(badvaddr) < KVM_GUEST_KSEG0\r\n|| KVM_GUEST_KSEGX(badvaddr) == KVM_GUEST_KSEG23) {\r\nkvm_debug("USER ADDR TLB ST fault: PC: %#lx, BadVaddr: %#lx\n",\r\nvcpu->arch.pc, badvaddr);\r\ner = kvm_mips_handle_tlbmiss(cause, opc, run, vcpu);\r\nif (er == EMULATE_DONE)\r\nret = RESUME_GUEST;\r\nelse {\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n}\r\n} else if (KVM_GUEST_KSEGX(badvaddr) == KVM_GUEST_KSEG0) {\r\nif (kvm_mips_handle_kseg0_tlb_fault\r\n(vcpu->arch.host_cp0_badvaddr, vcpu) < 0) {\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n}\r\n} else {\r\nkvm_err("Illegal TLB ST fault address , cause %#lx, PC: %p, BadVaddr: %#lx\n",\r\ncause, opc, badvaddr);\r\nkvm_mips_dump_host_tlbs();\r\nkvm_arch_vcpu_dump_regs(vcpu);\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n}\r\nreturn ret;\r\n}\r\nstatic int kvm_trap_emul_handle_addr_err_st(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_run *run = vcpu->run;\r\nuint32_t __user *opc = (uint32_t __user *) vcpu->arch.pc;\r\nunsigned long badvaddr = vcpu->arch.host_cp0_badvaddr;\r\nunsigned long cause = vcpu->arch.host_cp0_cause;\r\nenum emulation_result er = EMULATE_DONE;\r\nint ret = RESUME_GUEST;\r\nif (KVM_GUEST_KERNEL_MODE(vcpu)\r\n&& (KSEGX(badvaddr) == CKSEG0 || KSEGX(badvaddr) == CKSEG1)) {\r\nkvm_debug("Emulate Store to MMIO space\n");\r\ner = kvm_mips_emulate_inst(cause, opc, run, vcpu);\r\nif (er == EMULATE_FAIL) {\r\nkvm_err("Emulate Store to MMIO space failed\n");\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n} else {\r\nrun->exit_reason = KVM_EXIT_MMIO;\r\nret = RESUME_HOST;\r\n}\r\n} else {\r\nkvm_err("Address Error (STORE): cause %#lx, PC: %p, BadVaddr: %#lx\n",\r\ncause, opc, badvaddr);\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n}\r\nreturn ret;\r\n}\r\nstatic int kvm_trap_emul_handle_addr_err_ld(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_run *run = vcpu->run;\r\nuint32_t __user *opc = (uint32_t __user *) vcpu->arch.pc;\r\nunsigned long badvaddr = vcpu->arch.host_cp0_badvaddr;\r\nunsigned long cause = vcpu->arch.host_cp0_cause;\r\nenum emulation_result er = EMULATE_DONE;\r\nint ret = RESUME_GUEST;\r\nif (KSEGX(badvaddr) == CKSEG0 || KSEGX(badvaddr) == CKSEG1) {\r\nkvm_debug("Emulate Load from MMIO space @ %#lx\n", badvaddr);\r\ner = kvm_mips_emulate_inst(cause, opc, run, vcpu);\r\nif (er == EMULATE_FAIL) {\r\nkvm_err("Emulate Load from MMIO space failed\n");\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n} else {\r\nrun->exit_reason = KVM_EXIT_MMIO;\r\nret = RESUME_HOST;\r\n}\r\n} else {\r\nkvm_err("Address Error (LOAD): cause %#lx, PC: %p, BadVaddr: %#lx\n",\r\ncause, opc, badvaddr);\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\ner = EMULATE_FAIL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int kvm_trap_emul_handle_syscall(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_run *run = vcpu->run;\r\nuint32_t __user *opc = (uint32_t __user *) vcpu->arch.pc;\r\nunsigned long cause = vcpu->arch.host_cp0_cause;\r\nenum emulation_result er = EMULATE_DONE;\r\nint ret = RESUME_GUEST;\r\ner = kvm_mips_emulate_syscall(cause, opc, run, vcpu);\r\nif (er == EMULATE_DONE)\r\nret = RESUME_GUEST;\r\nelse {\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n}\r\nreturn ret;\r\n}\r\nstatic int kvm_trap_emul_handle_res_inst(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_run *run = vcpu->run;\r\nuint32_t __user *opc = (uint32_t __user *) vcpu->arch.pc;\r\nunsigned long cause = vcpu->arch.host_cp0_cause;\r\nenum emulation_result er = EMULATE_DONE;\r\nint ret = RESUME_GUEST;\r\ner = kvm_mips_handle_ri(cause, opc, run, vcpu);\r\nif (er == EMULATE_DONE)\r\nret = RESUME_GUEST;\r\nelse {\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n}\r\nreturn ret;\r\n}\r\nstatic int kvm_trap_emul_handle_break(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_run *run = vcpu->run;\r\nuint32_t __user *opc = (uint32_t __user *) vcpu->arch.pc;\r\nunsigned long cause = vcpu->arch.host_cp0_cause;\r\nenum emulation_result er = EMULATE_DONE;\r\nint ret = RESUME_GUEST;\r\ner = kvm_mips_emulate_bp_exc(cause, opc, run, vcpu);\r\nif (er == EMULATE_DONE)\r\nret = RESUME_GUEST;\r\nelse {\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n}\r\nreturn ret;\r\n}\r\nstatic int kvm_trap_emul_handle_trap(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_run *run = vcpu->run;\r\nuint32_t __user *opc = (uint32_t __user *)vcpu->arch.pc;\r\nunsigned long cause = vcpu->arch.host_cp0_cause;\r\nenum emulation_result er = EMULATE_DONE;\r\nint ret = RESUME_GUEST;\r\ner = kvm_mips_emulate_trap_exc(cause, opc, run, vcpu);\r\nif (er == EMULATE_DONE) {\r\nret = RESUME_GUEST;\r\n} else {\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n}\r\nreturn ret;\r\n}\r\nstatic int kvm_trap_emul_handle_msa_fpe(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_run *run = vcpu->run;\r\nuint32_t __user *opc = (uint32_t __user *)vcpu->arch.pc;\r\nunsigned long cause = vcpu->arch.host_cp0_cause;\r\nenum emulation_result er = EMULATE_DONE;\r\nint ret = RESUME_GUEST;\r\ner = kvm_mips_emulate_msafpe_exc(cause, opc, run, vcpu);\r\nif (er == EMULATE_DONE) {\r\nret = RESUME_GUEST;\r\n} else {\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n}\r\nreturn ret;\r\n}\r\nstatic int kvm_trap_emul_handle_fpe(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_run *run = vcpu->run;\r\nuint32_t __user *opc = (uint32_t __user *)vcpu->arch.pc;\r\nunsigned long cause = vcpu->arch.host_cp0_cause;\r\nenum emulation_result er = EMULATE_DONE;\r\nint ret = RESUME_GUEST;\r\ner = kvm_mips_emulate_fpe_exc(cause, opc, run, vcpu);\r\nif (er == EMULATE_DONE) {\r\nret = RESUME_GUEST;\r\n} else {\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\n}\r\nreturn ret;\r\n}\r\nstatic int kvm_trap_emul_handle_msa_disabled(struct kvm_vcpu *vcpu)\r\n{\r\nstruct mips_coproc *cop0 = vcpu->arch.cop0;\r\nstruct kvm_run *run = vcpu->run;\r\nuint32_t __user *opc = (uint32_t __user *) vcpu->arch.pc;\r\nunsigned long cause = vcpu->arch.host_cp0_cause;\r\nenum emulation_result er = EMULATE_DONE;\r\nint ret = RESUME_GUEST;\r\nif (!kvm_mips_guest_has_msa(&vcpu->arch) ||\r\n(kvm_read_c0_guest_status(cop0) & (ST0_CU1 | ST0_FR)) == ST0_CU1) {\r\ner = kvm_mips_emulate_ri_exc(cause, opc, run, vcpu);\r\n} else if (!(kvm_read_c0_guest_config5(cop0) & MIPS_CONF5_MSAEN)) {\r\ner = kvm_mips_emulate_msadis_exc(cause, opc, run, vcpu);\r\n} else {\r\nkvm_own_msa(vcpu);\r\ner = EMULATE_DONE;\r\n}\r\nswitch (er) {\r\ncase EMULATE_DONE:\r\nret = RESUME_GUEST;\r\nbreak;\r\ncase EMULATE_FAIL:\r\nrun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\r\nret = RESUME_HOST;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn ret;\r\n}\r\nstatic int kvm_trap_emul_vm_init(struct kvm *kvm)\r\n{\r\nreturn 0;\r\n}\r\nstatic int kvm_trap_emul_vcpu_init(struct kvm_vcpu *vcpu)\r\n{\r\nreturn 0;\r\n}\r\nstatic int kvm_trap_emul_vcpu_setup(struct kvm_vcpu *vcpu)\r\n{\r\nstruct mips_coproc *cop0 = vcpu->arch.cop0;\r\nuint32_t config1;\r\nint vcpu_id = vcpu->vcpu_id;\r\nkvm_write_c0_guest_prid(cop0, 0x00019300);\r\nkvm_write_c0_guest_config(cop0, MIPS_CONF_M | (0x3 << CP0C0_K0) |\r\n(0x1 << CP0C0_AR) |\r\n(MMU_TYPE_R4000 << CP0C0_MT));\r\nconfig1 = (read_c0_config1() & ~0x7f);\r\nconfig1 &= ~(0x3f << 25);\r\nconfig1 |= ((KVM_MIPS_GUEST_TLB_SIZE - 1) << 25);\r\nconfig1 &=\r\n~((1 << CP0C1_C2) | (1 << CP0C1_MD) | (1 << CP0C1_PC) |\r\n(1 << CP0C1_WR) | (1 << CP0C1_CA));\r\nkvm_write_c0_guest_config1(cop0, config1);\r\nkvm_write_c0_guest_config2(cop0, MIPS_CONF_M);\r\nkvm_write_c0_guest_config3(cop0, MIPS_CONF_M | MIPS_CONF3_ULRI);\r\nkvm_write_c0_guest_config4(cop0, MIPS_CONF_M);\r\nkvm_write_c0_guest_config5(cop0, 0);\r\nkvm_write_c0_guest_config7(cop0, (MIPS_CONF7_WII) | (1 << 10));\r\nkvm_write_c0_guest_intctl(cop0, 0xFC000000);\r\nkvm_write_c0_guest_ebase(cop0, KVM_GUEST_KSEG0 | (vcpu_id & 0xFF));\r\nreturn 0;\r\n}\r\nstatic int kvm_trap_emul_get_one_reg(struct kvm_vcpu *vcpu,\r\nconst struct kvm_one_reg *reg,\r\ns64 *v)\r\n{\r\nswitch (reg->id) {\r\ncase KVM_REG_MIPS_CP0_COUNT:\r\n*v = kvm_mips_read_count(vcpu);\r\nbreak;\r\ncase KVM_REG_MIPS_COUNT_CTL:\r\n*v = vcpu->arch.count_ctl;\r\nbreak;\r\ncase KVM_REG_MIPS_COUNT_RESUME:\r\n*v = ktime_to_ns(vcpu->arch.count_resume);\r\nbreak;\r\ncase KVM_REG_MIPS_COUNT_HZ:\r\n*v = vcpu->arch.count_hz;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kvm_trap_emul_set_one_reg(struct kvm_vcpu *vcpu,\r\nconst struct kvm_one_reg *reg,\r\ns64 v)\r\n{\r\nstruct mips_coproc *cop0 = vcpu->arch.cop0;\r\nint ret = 0;\r\nunsigned int cur, change;\r\nswitch (reg->id) {\r\ncase KVM_REG_MIPS_CP0_COUNT:\r\nkvm_mips_write_count(vcpu, v);\r\nbreak;\r\ncase KVM_REG_MIPS_CP0_COMPARE:\r\nkvm_mips_write_compare(vcpu, v);\r\nbreak;\r\ncase KVM_REG_MIPS_CP0_CAUSE:\r\nif ((kvm_read_c0_guest_cause(cop0) ^ v) & CAUSEF_DC) {\r\nif (v & CAUSEF_DC) {\r\nkvm_mips_count_disable_cause(vcpu);\r\nkvm_change_c0_guest_cause(cop0, ~CAUSEF_DC, v);\r\n} else {\r\nkvm_change_c0_guest_cause(cop0, ~CAUSEF_DC, v);\r\nkvm_mips_count_enable_cause(vcpu);\r\n}\r\n} else {\r\nkvm_write_c0_guest_cause(cop0, v);\r\n}\r\nbreak;\r\ncase KVM_REG_MIPS_CP0_CONFIG:\r\nbreak;\r\ncase KVM_REG_MIPS_CP0_CONFIG1:\r\ncur = kvm_read_c0_guest_config1(cop0);\r\nchange = (cur ^ v) & kvm_mips_config1_wrmask(vcpu);\r\nif (change) {\r\nv = cur ^ change;\r\nkvm_write_c0_guest_config1(cop0, v);\r\n}\r\nbreak;\r\ncase KVM_REG_MIPS_CP0_CONFIG2:\r\nbreak;\r\ncase KVM_REG_MIPS_CP0_CONFIG3:\r\ncur = kvm_read_c0_guest_config3(cop0);\r\nchange = (cur ^ v) & kvm_mips_config3_wrmask(vcpu);\r\nif (change) {\r\nv = cur ^ change;\r\nkvm_write_c0_guest_config3(cop0, v);\r\n}\r\nbreak;\r\ncase KVM_REG_MIPS_CP0_CONFIG4:\r\ncur = kvm_read_c0_guest_config4(cop0);\r\nchange = (cur ^ v) & kvm_mips_config4_wrmask(vcpu);\r\nif (change) {\r\nv = cur ^ change;\r\nkvm_write_c0_guest_config4(cop0, v);\r\n}\r\nbreak;\r\ncase KVM_REG_MIPS_CP0_CONFIG5:\r\ncur = kvm_read_c0_guest_config5(cop0);\r\nchange = (cur ^ v) & kvm_mips_config5_wrmask(vcpu);\r\nif (change) {\r\nv = cur ^ change;\r\nkvm_write_c0_guest_config5(cop0, v);\r\n}\r\nbreak;\r\ncase KVM_REG_MIPS_COUNT_CTL:\r\nret = kvm_mips_set_count_ctl(vcpu, v);\r\nbreak;\r\ncase KVM_REG_MIPS_COUNT_RESUME:\r\nret = kvm_mips_set_count_resume(vcpu, v);\r\nbreak;\r\ncase KVM_REG_MIPS_COUNT_HZ:\r\nret = kvm_mips_set_count_hz(vcpu, v);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int kvm_trap_emul_vcpu_get_regs(struct kvm_vcpu *vcpu)\r\n{\r\nkvm_lose_fpu(vcpu);\r\nreturn 0;\r\n}\r\nstatic int kvm_trap_emul_vcpu_set_regs(struct kvm_vcpu *vcpu)\r\n{\r\nreturn 0;\r\n}\r\nint kvm_mips_emulation_init(struct kvm_mips_callbacks **install_callbacks)\r\n{\r\n*install_callbacks = &kvm_trap_emul_callbacks;\r\nreturn 0;\r\n}
