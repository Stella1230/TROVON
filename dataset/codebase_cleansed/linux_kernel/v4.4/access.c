int pci_generic_config_read(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nvoid __iomem *addr;\r\naddr = bus->ops->map_bus(bus, devfn, where);\r\nif (!addr) {\r\n*val = ~0;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nif (size == 1)\r\n*val = readb(addr);\r\nelse if (size == 2)\r\n*val = readw(addr);\r\nelse\r\n*val = readl(addr);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nint pci_generic_config_write(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nvoid __iomem *addr;\r\naddr = bus->ops->map_bus(bus, devfn, where);\r\nif (!addr)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (size == 1)\r\nwriteb(val, addr);\r\nelse if (size == 2)\r\nwritew(val, addr);\r\nelse\r\nwritel(val, addr);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nint pci_generic_config_read32(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nvoid __iomem *addr;\r\naddr = bus->ops->map_bus(bus, devfn, where & ~0x3);\r\nif (!addr) {\r\n*val = ~0;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\n*val = readl(addr);\r\nif (size <= 2)\r\n*val = (*val >> (8 * (where & 3))) & ((1 << (size * 8)) - 1);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nint pci_generic_config_write32(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nvoid __iomem *addr;\r\nu32 mask, tmp;\r\naddr = bus->ops->map_bus(bus, devfn, where & ~0x3);\r\nif (!addr)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (size == 4) {\r\nwritel(val, addr);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n} else {\r\nmask = ~(((1 << (size * 8)) - 1) << ((where & 0x3) * 8));\r\n}\r\ntmp = readl(addr) & mask;\r\ntmp |= val << ((where & 0x3) * 8);\r\nwritel(tmp, addr);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstruct pci_ops *pci_bus_set_ops(struct pci_bus *bus, struct pci_ops *ops)\r\n{\r\nstruct pci_ops *old_ops;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&pci_lock, flags);\r\nold_ops = bus->ops;\r\nbus->ops = ops;\r\nraw_spin_unlock_irqrestore(&pci_lock, flags);\r\nreturn old_ops;\r\n}\r\nssize_t pci_read_vpd(struct pci_dev *dev, loff_t pos, size_t count, void *buf)\r\n{\r\nif (!dev->vpd || !dev->vpd->ops)\r\nreturn -ENODEV;\r\nreturn dev->vpd->ops->read(dev, pos, count, buf);\r\n}\r\nssize_t pci_write_vpd(struct pci_dev *dev, loff_t pos, size_t count, const void *buf)\r\n{\r\nif (!dev->vpd || !dev->vpd->ops)\r\nreturn -ENODEV;\r\nreturn dev->vpd->ops->write(dev, pos, count, buf);\r\n}\r\nstatic noinline void pci_wait_cfg(struct pci_dev *dev)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\n__add_wait_queue(&pci_cfg_wait, &wait);\r\ndo {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nraw_spin_unlock_irq(&pci_lock);\r\nschedule();\r\nraw_spin_lock_irq(&pci_lock);\r\n} while (dev->block_cfg_access);\r\n__remove_wait_queue(&pci_cfg_wait, &wait);\r\n}\r\nstatic int pci_vpd_pci22_wait(struct pci_dev *dev)\r\n{\r\nstruct pci_vpd_pci22 *vpd =\r\ncontainer_of(dev->vpd, struct pci_vpd_pci22, base);\r\nunsigned long timeout = jiffies + HZ/20 + 2;\r\nu16 status;\r\nint ret;\r\nif (!vpd->busy)\r\nreturn 0;\r\nfor (;;) {\r\nret = pci_user_read_config_word(dev, vpd->cap + PCI_VPD_ADDR,\r\n&status);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((status & PCI_VPD_ADDR_F) == vpd->flag) {\r\nvpd->busy = false;\r\nreturn 0;\r\n}\r\nif (time_after(jiffies, timeout)) {\r\ndev_printk(KERN_DEBUG, &dev->dev, "vpd r/w failed. This is likely a firmware bug on this device. Contact the card vendor for a firmware update\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (fatal_signal_pending(current))\r\nreturn -EINTR;\r\nif (!cond_resched())\r\nudelay(10);\r\n}\r\n}\r\nstatic ssize_t pci_vpd_pci22_read(struct pci_dev *dev, loff_t pos, size_t count,\r\nvoid *arg)\r\n{\r\nstruct pci_vpd_pci22 *vpd =\r\ncontainer_of(dev->vpd, struct pci_vpd_pci22, base);\r\nint ret;\r\nloff_t end = pos + count;\r\nu8 *buf = arg;\r\nif (pos < 0 || pos > vpd->base.len || end > vpd->base.len)\r\nreturn -EINVAL;\r\nif (mutex_lock_killable(&vpd->lock))\r\nreturn -EINTR;\r\nret = pci_vpd_pci22_wait(dev);\r\nif (ret < 0)\r\ngoto out;\r\nwhile (pos < end) {\r\nu32 val;\r\nunsigned int i, skip;\r\nret = pci_user_write_config_word(dev, vpd->cap + PCI_VPD_ADDR,\r\npos & ~3);\r\nif (ret < 0)\r\nbreak;\r\nvpd->busy = true;\r\nvpd->flag = PCI_VPD_ADDR_F;\r\nret = pci_vpd_pci22_wait(dev);\r\nif (ret < 0)\r\nbreak;\r\nret = pci_user_read_config_dword(dev, vpd->cap + PCI_VPD_DATA, &val);\r\nif (ret < 0)\r\nbreak;\r\nskip = pos & 3;\r\nfor (i = 0; i < sizeof(u32); i++) {\r\nif (i >= skip) {\r\n*buf++ = val;\r\nif (++pos == end)\r\nbreak;\r\n}\r\nval >>= 8;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&vpd->lock);\r\nreturn ret ? ret : count;\r\n}\r\nstatic ssize_t pci_vpd_pci22_write(struct pci_dev *dev, loff_t pos, size_t count,\r\nconst void *arg)\r\n{\r\nstruct pci_vpd_pci22 *vpd =\r\ncontainer_of(dev->vpd, struct pci_vpd_pci22, base);\r\nconst u8 *buf = arg;\r\nloff_t end = pos + count;\r\nint ret = 0;\r\nif (pos < 0 || (pos & 3) || (count & 3) || end > vpd->base.len)\r\nreturn -EINVAL;\r\nif (mutex_lock_killable(&vpd->lock))\r\nreturn -EINTR;\r\nret = pci_vpd_pci22_wait(dev);\r\nif (ret < 0)\r\ngoto out;\r\nwhile (pos < end) {\r\nu32 val;\r\nval = *buf++;\r\nval |= *buf++ << 8;\r\nval |= *buf++ << 16;\r\nval |= *buf++ << 24;\r\nret = pci_user_write_config_dword(dev, vpd->cap + PCI_VPD_DATA, val);\r\nif (ret < 0)\r\nbreak;\r\nret = pci_user_write_config_word(dev, vpd->cap + PCI_VPD_ADDR,\r\npos | PCI_VPD_ADDR_F);\r\nif (ret < 0)\r\nbreak;\r\nvpd->busy = true;\r\nvpd->flag = 0;\r\nret = pci_vpd_pci22_wait(dev);\r\nif (ret < 0)\r\nbreak;\r\npos += sizeof(u32);\r\n}\r\nout:\r\nmutex_unlock(&vpd->lock);\r\nreturn ret ? ret : count;\r\n}\r\nstatic void pci_vpd_pci22_release(struct pci_dev *dev)\r\n{\r\nkfree(container_of(dev->vpd, struct pci_vpd_pci22, base));\r\n}\r\nstatic ssize_t pci_vpd_f0_read(struct pci_dev *dev, loff_t pos, size_t count,\r\nvoid *arg)\r\n{\r\nstruct pci_dev *tdev = pci_get_slot(dev->bus,\r\nPCI_DEVFN(PCI_SLOT(dev->devfn), 0));\r\nssize_t ret;\r\nif (!tdev)\r\nreturn -ENODEV;\r\nret = pci_read_vpd(tdev, pos, count, arg);\r\npci_dev_put(tdev);\r\nreturn ret;\r\n}\r\nstatic ssize_t pci_vpd_f0_write(struct pci_dev *dev, loff_t pos, size_t count,\r\nconst void *arg)\r\n{\r\nstruct pci_dev *tdev = pci_get_slot(dev->bus,\r\nPCI_DEVFN(PCI_SLOT(dev->devfn), 0));\r\nssize_t ret;\r\nif (!tdev)\r\nreturn -ENODEV;\r\nret = pci_write_vpd(tdev, pos, count, arg);\r\npci_dev_put(tdev);\r\nreturn ret;\r\n}\r\nint pci_vpd_pci22_init(struct pci_dev *dev)\r\n{\r\nstruct pci_vpd_pci22 *vpd;\r\nu8 cap;\r\ncap = pci_find_capability(dev, PCI_CAP_ID_VPD);\r\nif (!cap)\r\nreturn -ENODEV;\r\nvpd = kzalloc(sizeof(*vpd), GFP_ATOMIC);\r\nif (!vpd)\r\nreturn -ENOMEM;\r\nvpd->base.len = PCI_VPD_PCI22_SIZE;\r\nif (dev->dev_flags & PCI_DEV_FLAGS_VPD_REF_F0)\r\nvpd->base.ops = &pci_vpd_f0_ops;\r\nelse\r\nvpd->base.ops = &pci_vpd_pci22_ops;\r\nmutex_init(&vpd->lock);\r\nvpd->cap = cap;\r\nvpd->busy = false;\r\ndev->vpd = &vpd->base;\r\nreturn 0;\r\n}\r\nvoid pci_cfg_access_lock(struct pci_dev *dev)\r\n{\r\nmight_sleep();\r\nraw_spin_lock_irq(&pci_lock);\r\nif (dev->block_cfg_access)\r\npci_wait_cfg(dev);\r\ndev->block_cfg_access = 1;\r\nraw_spin_unlock_irq(&pci_lock);\r\n}\r\nbool pci_cfg_access_trylock(struct pci_dev *dev)\r\n{\r\nunsigned long flags;\r\nbool locked = true;\r\nraw_spin_lock_irqsave(&pci_lock, flags);\r\nif (dev->block_cfg_access)\r\nlocked = false;\r\nelse\r\ndev->block_cfg_access = 1;\r\nraw_spin_unlock_irqrestore(&pci_lock, flags);\r\nreturn locked;\r\n}\r\nvoid pci_cfg_access_unlock(struct pci_dev *dev)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&pci_lock, flags);\r\nWARN_ON(!dev->block_cfg_access);\r\ndev->block_cfg_access = 0;\r\nwake_up_all(&pci_cfg_wait);\r\nraw_spin_unlock_irqrestore(&pci_lock, flags);\r\n}\r\nstatic inline int pcie_cap_version(const struct pci_dev *dev)\r\n{\r\nreturn pcie_caps_reg(dev) & PCI_EXP_FLAGS_VERS;\r\n}\r\nstatic bool pcie_downstream_port(const struct pci_dev *dev)\r\n{\r\nint type = pci_pcie_type(dev);\r\nreturn type == PCI_EXP_TYPE_ROOT_PORT ||\r\ntype == PCI_EXP_TYPE_DOWNSTREAM;\r\n}\r\nbool pcie_cap_has_lnkctl(const struct pci_dev *dev)\r\n{\r\nint type = pci_pcie_type(dev);\r\nreturn type == PCI_EXP_TYPE_ENDPOINT ||\r\ntype == PCI_EXP_TYPE_LEG_END ||\r\ntype == PCI_EXP_TYPE_ROOT_PORT ||\r\ntype == PCI_EXP_TYPE_UPSTREAM ||\r\ntype == PCI_EXP_TYPE_DOWNSTREAM ||\r\ntype == PCI_EXP_TYPE_PCI_BRIDGE ||\r\ntype == PCI_EXP_TYPE_PCIE_BRIDGE;\r\n}\r\nstatic inline bool pcie_cap_has_sltctl(const struct pci_dev *dev)\r\n{\r\nreturn pcie_downstream_port(dev) &&\r\npcie_caps_reg(dev) & PCI_EXP_FLAGS_SLOT;\r\n}\r\nstatic inline bool pcie_cap_has_rtctl(const struct pci_dev *dev)\r\n{\r\nint type = pci_pcie_type(dev);\r\nreturn type == PCI_EXP_TYPE_ROOT_PORT ||\r\ntype == PCI_EXP_TYPE_RC_EC;\r\n}\r\nstatic bool pcie_capability_reg_implemented(struct pci_dev *dev, int pos)\r\n{\r\nif (!pci_is_pcie(dev))\r\nreturn false;\r\nswitch (pos) {\r\ncase PCI_EXP_FLAGS:\r\nreturn true;\r\ncase PCI_EXP_DEVCAP:\r\ncase PCI_EXP_DEVCTL:\r\ncase PCI_EXP_DEVSTA:\r\nreturn true;\r\ncase PCI_EXP_LNKCAP:\r\ncase PCI_EXP_LNKCTL:\r\ncase PCI_EXP_LNKSTA:\r\nreturn pcie_cap_has_lnkctl(dev);\r\ncase PCI_EXP_SLTCAP:\r\ncase PCI_EXP_SLTCTL:\r\ncase PCI_EXP_SLTSTA:\r\nreturn pcie_cap_has_sltctl(dev);\r\ncase PCI_EXP_RTCTL:\r\ncase PCI_EXP_RTCAP:\r\ncase PCI_EXP_RTSTA:\r\nreturn pcie_cap_has_rtctl(dev);\r\ncase PCI_EXP_DEVCAP2:\r\ncase PCI_EXP_DEVCTL2:\r\ncase PCI_EXP_LNKCAP2:\r\ncase PCI_EXP_LNKCTL2:\r\ncase PCI_EXP_LNKSTA2:\r\nreturn pcie_cap_version(dev) > 1;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nint pcie_capability_read_word(struct pci_dev *dev, int pos, u16 *val)\r\n{\r\nint ret;\r\n*val = 0;\r\nif (pos & 1)\r\nreturn -EINVAL;\r\nif (pcie_capability_reg_implemented(dev, pos)) {\r\nret = pci_read_config_word(dev, pci_pcie_cap(dev) + pos, val);\r\nif (ret)\r\n*val = 0;\r\nreturn ret;\r\n}\r\nif (pci_is_pcie(dev) && pcie_downstream_port(dev) &&\r\npos == PCI_EXP_SLTSTA)\r\n*val = PCI_EXP_SLTSTA_PDS;\r\nreturn 0;\r\n}\r\nint pcie_capability_read_dword(struct pci_dev *dev, int pos, u32 *val)\r\n{\r\nint ret;\r\n*val = 0;\r\nif (pos & 3)\r\nreturn -EINVAL;\r\nif (pcie_capability_reg_implemented(dev, pos)) {\r\nret = pci_read_config_dword(dev, pci_pcie_cap(dev) + pos, val);\r\nif (ret)\r\n*val = 0;\r\nreturn ret;\r\n}\r\nif (pci_is_pcie(dev) && pcie_downstream_port(dev) &&\r\npos == PCI_EXP_SLTSTA)\r\n*val = PCI_EXP_SLTSTA_PDS;\r\nreturn 0;\r\n}\r\nint pcie_capability_write_word(struct pci_dev *dev, int pos, u16 val)\r\n{\r\nif (pos & 1)\r\nreturn -EINVAL;\r\nif (!pcie_capability_reg_implemented(dev, pos))\r\nreturn 0;\r\nreturn pci_write_config_word(dev, pci_pcie_cap(dev) + pos, val);\r\n}\r\nint pcie_capability_write_dword(struct pci_dev *dev, int pos, u32 val)\r\n{\r\nif (pos & 3)\r\nreturn -EINVAL;\r\nif (!pcie_capability_reg_implemented(dev, pos))\r\nreturn 0;\r\nreturn pci_write_config_dword(dev, pci_pcie_cap(dev) + pos, val);\r\n}\r\nint pcie_capability_clear_and_set_word(struct pci_dev *dev, int pos,\r\nu16 clear, u16 set)\r\n{\r\nint ret;\r\nu16 val;\r\nret = pcie_capability_read_word(dev, pos, &val);\r\nif (!ret) {\r\nval &= ~clear;\r\nval |= set;\r\nret = pcie_capability_write_word(dev, pos, val);\r\n}\r\nreturn ret;\r\n}\r\nint pcie_capability_clear_and_set_dword(struct pci_dev *dev, int pos,\r\nu32 clear, u32 set)\r\n{\r\nint ret;\r\nu32 val;\r\nret = pcie_capability_read_dword(dev, pos, &val);\r\nif (!ret) {\r\nval &= ~clear;\r\nval |= set;\r\nret = pcie_capability_write_dword(dev, pos, val);\r\n}\r\nreturn ret;\r\n}
