static bool rt5670_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(rt5670_ranges); i++) {\r\nif ((reg >= rt5670_ranges[i].window_start &&\r\nreg <= rt5670_ranges[i].window_start +\r\nrt5670_ranges[i].window_len) ||\r\n(reg >= rt5670_ranges[i].range_min &&\r\nreg <= rt5670_ranges[i].range_max)) {\r\nreturn true;\r\n}\r\n}\r\nswitch (reg) {\r\ncase RT5670_RESET:\r\ncase RT5670_PDM_DATA_CTRL1:\r\ncase RT5670_PDM1_DATA_CTRL4:\r\ncase RT5670_PDM2_DATA_CTRL4:\r\ncase RT5670_PRIV_DATA:\r\ncase RT5670_ASRC_5:\r\ncase RT5670_CJ_CTRL1:\r\ncase RT5670_CJ_CTRL2:\r\ncase RT5670_CJ_CTRL3:\r\ncase RT5670_A_JD_CTRL1:\r\ncase RT5670_A_JD_CTRL2:\r\ncase RT5670_VAD_CTRL5:\r\ncase RT5670_ADC_EQ_CTRL1:\r\ncase RT5670_EQ_CTRL1:\r\ncase RT5670_ALC_CTRL_1:\r\ncase RT5670_IRQ_CTRL2:\r\ncase RT5670_INT_IRQ_ST:\r\ncase RT5670_IL_CMD:\r\ncase RT5670_DSP_CTRL1:\r\ncase RT5670_DSP_CTRL2:\r\ncase RT5670_DSP_CTRL3:\r\ncase RT5670_DSP_CTRL4:\r\ncase RT5670_DSP_CTRL5:\r\ncase RT5670_VENDOR_ID:\r\ncase RT5670_VENDOR_ID1:\r\ncase RT5670_VENDOR_ID2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool rt5670_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(rt5670_ranges); i++) {\r\nif ((reg >= rt5670_ranges[i].window_start &&\r\nreg <= rt5670_ranges[i].window_start +\r\nrt5670_ranges[i].window_len) ||\r\n(reg >= rt5670_ranges[i].range_min &&\r\nreg <= rt5670_ranges[i].range_max)) {\r\nreturn true;\r\n}\r\n}\r\nswitch (reg) {\r\ncase RT5670_RESET:\r\ncase RT5670_HP_VOL:\r\ncase RT5670_LOUT1:\r\ncase RT5670_CJ_CTRL1:\r\ncase RT5670_CJ_CTRL2:\r\ncase RT5670_CJ_CTRL3:\r\ncase RT5670_IN2:\r\ncase RT5670_INL1_INR1_VOL:\r\ncase RT5670_DAC1_DIG_VOL:\r\ncase RT5670_DAC2_DIG_VOL:\r\ncase RT5670_DAC_CTRL:\r\ncase RT5670_STO1_ADC_DIG_VOL:\r\ncase RT5670_MONO_ADC_DIG_VOL:\r\ncase RT5670_STO2_ADC_DIG_VOL:\r\ncase RT5670_ADC_BST_VOL1:\r\ncase RT5670_ADC_BST_VOL2:\r\ncase RT5670_STO2_ADC_MIXER:\r\ncase RT5670_STO1_ADC_MIXER:\r\ncase RT5670_MONO_ADC_MIXER:\r\ncase RT5670_AD_DA_MIXER:\r\ncase RT5670_STO_DAC_MIXER:\r\ncase RT5670_DD_MIXER:\r\ncase RT5670_DIG_MIXER:\r\ncase RT5670_DSP_PATH1:\r\ncase RT5670_DSP_PATH2:\r\ncase RT5670_DIG_INF1_DATA:\r\ncase RT5670_DIG_INF2_DATA:\r\ncase RT5670_PDM_OUT_CTRL:\r\ncase RT5670_PDM_DATA_CTRL1:\r\ncase RT5670_PDM1_DATA_CTRL2:\r\ncase RT5670_PDM1_DATA_CTRL3:\r\ncase RT5670_PDM1_DATA_CTRL4:\r\ncase RT5670_PDM2_DATA_CTRL2:\r\ncase RT5670_PDM2_DATA_CTRL3:\r\ncase RT5670_PDM2_DATA_CTRL4:\r\ncase RT5670_REC_L1_MIXER:\r\ncase RT5670_REC_L2_MIXER:\r\ncase RT5670_REC_R1_MIXER:\r\ncase RT5670_REC_R2_MIXER:\r\ncase RT5670_HPO_MIXER:\r\ncase RT5670_MONO_MIXER:\r\ncase RT5670_OUT_L1_MIXER:\r\ncase RT5670_OUT_R1_MIXER:\r\ncase RT5670_LOUT_MIXER:\r\ncase RT5670_PWR_DIG1:\r\ncase RT5670_PWR_DIG2:\r\ncase RT5670_PWR_ANLG1:\r\ncase RT5670_PWR_ANLG2:\r\ncase RT5670_PWR_MIXER:\r\ncase RT5670_PWR_VOL:\r\ncase RT5670_PRIV_INDEX:\r\ncase RT5670_PRIV_DATA:\r\ncase RT5670_I2S4_SDP:\r\ncase RT5670_I2S1_SDP:\r\ncase RT5670_I2S2_SDP:\r\ncase RT5670_I2S3_SDP:\r\ncase RT5670_ADDA_CLK1:\r\ncase RT5670_ADDA_CLK2:\r\ncase RT5670_DMIC_CTRL1:\r\ncase RT5670_DMIC_CTRL2:\r\ncase RT5670_TDM_CTRL_1:\r\ncase RT5670_TDM_CTRL_2:\r\ncase RT5670_TDM_CTRL_3:\r\ncase RT5670_DSP_CLK:\r\ncase RT5670_GLB_CLK:\r\ncase RT5670_PLL_CTRL1:\r\ncase RT5670_PLL_CTRL2:\r\ncase RT5670_ASRC_1:\r\ncase RT5670_ASRC_2:\r\ncase RT5670_ASRC_3:\r\ncase RT5670_ASRC_4:\r\ncase RT5670_ASRC_5:\r\ncase RT5670_ASRC_7:\r\ncase RT5670_ASRC_8:\r\ncase RT5670_ASRC_9:\r\ncase RT5670_ASRC_10:\r\ncase RT5670_ASRC_11:\r\ncase RT5670_ASRC_12:\r\ncase RT5670_ASRC_13:\r\ncase RT5670_ASRC_14:\r\ncase RT5670_DEPOP_M1:\r\ncase RT5670_DEPOP_M2:\r\ncase RT5670_DEPOP_M3:\r\ncase RT5670_CHARGE_PUMP:\r\ncase RT5670_MICBIAS:\r\ncase RT5670_A_JD_CTRL1:\r\ncase RT5670_A_JD_CTRL2:\r\ncase RT5670_VAD_CTRL1:\r\ncase RT5670_VAD_CTRL2:\r\ncase RT5670_VAD_CTRL3:\r\ncase RT5670_VAD_CTRL4:\r\ncase RT5670_VAD_CTRL5:\r\ncase RT5670_ADC_EQ_CTRL1:\r\ncase RT5670_ADC_EQ_CTRL2:\r\ncase RT5670_EQ_CTRL1:\r\ncase RT5670_EQ_CTRL2:\r\ncase RT5670_ALC_DRC_CTRL1:\r\ncase RT5670_ALC_DRC_CTRL2:\r\ncase RT5670_ALC_CTRL_1:\r\ncase RT5670_ALC_CTRL_2:\r\ncase RT5670_ALC_CTRL_3:\r\ncase RT5670_JD_CTRL:\r\ncase RT5670_IRQ_CTRL1:\r\ncase RT5670_IRQ_CTRL2:\r\ncase RT5670_INT_IRQ_ST:\r\ncase RT5670_GPIO_CTRL1:\r\ncase RT5670_GPIO_CTRL2:\r\ncase RT5670_GPIO_CTRL3:\r\ncase RT5670_SCRABBLE_FUN:\r\ncase RT5670_SCRABBLE_CTRL:\r\ncase RT5670_BASE_BACK:\r\ncase RT5670_MP3_PLUS1:\r\ncase RT5670_MP3_PLUS2:\r\ncase RT5670_ADJ_HPF1:\r\ncase RT5670_ADJ_HPF2:\r\ncase RT5670_HP_CALIB_AMP_DET:\r\ncase RT5670_SV_ZCD1:\r\ncase RT5670_SV_ZCD2:\r\ncase RT5670_IL_CMD:\r\ncase RT5670_IL_CMD2:\r\ncase RT5670_IL_CMD3:\r\ncase RT5670_DRC_HL_CTRL1:\r\ncase RT5670_DRC_HL_CTRL2:\r\ncase RT5670_ADC_MONO_HP_CTRL1:\r\ncase RT5670_ADC_MONO_HP_CTRL2:\r\ncase RT5670_ADC_STO2_HP_CTRL1:\r\ncase RT5670_ADC_STO2_HP_CTRL2:\r\ncase RT5670_JD_CTRL3:\r\ncase RT5670_JD_CTRL4:\r\ncase RT5670_DIG_MISC:\r\ncase RT5670_DSP_CTRL1:\r\ncase RT5670_DSP_CTRL2:\r\ncase RT5670_DSP_CTRL3:\r\ncase RT5670_DSP_CTRL4:\r\ncase RT5670_DSP_CTRL5:\r\ncase RT5670_GEN_CTRL2:\r\ncase RT5670_GEN_CTRL3:\r\ncase RT5670_VENDOR_ID:\r\ncase RT5670_VENDOR_ID1:\r\ncase RT5670_VENDOR_ID2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int rt5670_headset_detect(struct snd_soc_codec *codec, int jack_insert)\r\n{\r\nint val;\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct rt5670_priv *rt5670 = snd_soc_codec_get_drvdata(codec);\r\nif (jack_insert) {\r\nsnd_soc_dapm_force_enable_pin(dapm, "Mic Det Power");\r\nsnd_soc_dapm_sync(dapm);\r\nsnd_soc_update_bits(codec, RT5670_GEN_CTRL3, 0x4, 0x0);\r\nsnd_soc_update_bits(codec, RT5670_CJ_CTRL2,\r\nRT5670_CBJ_DET_MODE | RT5670_CBJ_MN_JD,\r\nRT5670_CBJ_MN_JD);\r\nsnd_soc_write(codec, RT5670_GPIO_CTRL2, 0x0004);\r\nsnd_soc_update_bits(codec, RT5670_GPIO_CTRL1,\r\nRT5670_GP1_PIN_MASK, RT5670_GP1_PIN_IRQ);\r\nsnd_soc_update_bits(codec, RT5670_CJ_CTRL1,\r\nRT5670_CBJ_BST1_EN, RT5670_CBJ_BST1_EN);\r\nsnd_soc_write(codec, RT5670_JD_CTRL3, 0x00f0);\r\nsnd_soc_update_bits(codec, RT5670_CJ_CTRL2,\r\nRT5670_CBJ_MN_JD, RT5670_CBJ_MN_JD);\r\nsnd_soc_update_bits(codec, RT5670_CJ_CTRL2,\r\nRT5670_CBJ_MN_JD, 0);\r\nmsleep(300);\r\nval = snd_soc_read(codec, RT5670_CJ_CTRL3) & 0x7;\r\nif (val == 0x1 || val == 0x2) {\r\nrt5670->jack_type = SND_JACK_HEADSET;\r\nsnd_soc_update_bits(codec, RT5670_INT_IRQ_ST, 0x8, 0x8);\r\nsnd_soc_update_bits(codec, RT5670_IL_CMD, 0x40, 0x40);\r\nsnd_soc_read(codec, RT5670_IL_CMD);\r\n} else {\r\nsnd_soc_update_bits(codec, RT5670_GEN_CTRL3, 0x4, 0x4);\r\nrt5670->jack_type = SND_JACK_HEADPHONE;\r\nsnd_soc_dapm_disable_pin(dapm, "Mic Det Power");\r\nsnd_soc_dapm_sync(dapm);\r\n}\r\n} else {\r\nsnd_soc_update_bits(codec, RT5670_INT_IRQ_ST, 0x8, 0x0);\r\nsnd_soc_update_bits(codec, RT5670_GEN_CTRL3, 0x4, 0x4);\r\nrt5670->jack_type = 0;\r\nsnd_soc_dapm_disable_pin(dapm, "Mic Det Power");\r\nsnd_soc_dapm_sync(dapm);\r\n}\r\nreturn rt5670->jack_type;\r\n}\r\nvoid rt5670_jack_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct rt5670_priv *rt5670 = snd_soc_codec_get_drvdata(codec);\r\nrt5670->jack_type_saved = rt5670->jack_type;\r\nrt5670_headset_detect(codec, 0);\r\n}\r\nvoid rt5670_jack_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct rt5670_priv *rt5670 = snd_soc_codec_get_drvdata(codec);\r\nif (rt5670->jack_type_saved)\r\nrt5670_headset_detect(codec, 1);\r\n}\r\nstatic int rt5670_button_detect(struct snd_soc_codec *codec)\r\n{\r\nint btn_type, val;\r\nval = snd_soc_read(codec, RT5670_IL_CMD);\r\nbtn_type = val & 0xff80;\r\nsnd_soc_write(codec, RT5670_IL_CMD, val);\r\nif (btn_type != 0) {\r\nmsleep(20);\r\nval = snd_soc_read(codec, RT5670_IL_CMD);\r\nsnd_soc_write(codec, RT5670_IL_CMD, val);\r\n}\r\nreturn btn_type;\r\n}\r\nstatic int rt5670_irq_detection(void *data)\r\n{\r\nstruct rt5670_priv *rt5670 = (struct rt5670_priv *)data;\r\nstruct snd_soc_jack_gpio *gpio = &rt5670->hp_gpio;\r\nstruct snd_soc_jack *jack = rt5670->jack;\r\nint val, btn_type, report = jack->status;\r\nif (rt5670->pdata.jd_mode == 1)\r\nval = snd_soc_read(rt5670->codec, RT5670_A_JD_CTRL1) & 0x0070;\r\nelse\r\nval = snd_soc_read(rt5670->codec, RT5670_A_JD_CTRL1) & 0x0020;\r\nswitch (val) {\r\ncase 0x30:\r\ncase 0x0:\r\nif (rt5670->jack_type == 0) {\r\nreport = rt5670_headset_detect(rt5670->codec, 1);\r\ngpio->debounce_time = 25;\r\nbreak;\r\n}\r\nbtn_type = 0;\r\nif (snd_soc_read(rt5670->codec, RT5670_INT_IRQ_ST) & 0x4) {\r\nreport = SND_JACK_HEADSET;\r\nbtn_type = rt5670_button_detect(rt5670->codec);\r\nswitch (btn_type) {\r\ncase 0x2000:\r\nreport |= SND_JACK_BTN_1;\r\nbreak;\r\ncase 0x0400:\r\nreport |= SND_JACK_BTN_0;\r\nbreak;\r\ncase 0x0080:\r\nreport |= SND_JACK_BTN_2;\r\nbreak;\r\ndefault:\r\ndev_err(rt5670->codec->dev,\r\n"Unexpected button code 0x%04x\n",\r\nbtn_type);\r\nbreak;\r\n}\r\n}\r\nif (btn_type == 0)\r\nreport = rt5670->jack_type;\r\nbreak;\r\ncase 0x70:\r\ncase 0x10:\r\ncase 0x20:\r\nreport = 0;\r\nsnd_soc_update_bits(rt5670->codec, RT5670_INT_IRQ_ST, 0x1, 0x0);\r\nrt5670_headset_detect(rt5670->codec, 0);\r\ngpio->debounce_time = 150;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn report;\r\n}\r\nint rt5670_set_jack_detect(struct snd_soc_codec *codec,\r\nstruct snd_soc_jack *jack)\r\n{\r\nstruct rt5670_priv *rt5670 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nrt5670->jack = jack;\r\nrt5670->hp_gpio.gpiod_dev = codec->dev;\r\nrt5670->hp_gpio.name = "headphone detect";\r\nrt5670->hp_gpio.report = SND_JACK_HEADSET |\r\nSND_JACK_BTN_0 | SND_JACK_BTN_1 | SND_JACK_BTN_2;\r\nrt5670->hp_gpio.debounce_time = 150;\r\nrt5670->hp_gpio.wake = true;\r\nrt5670->hp_gpio.data = (struct rt5670_priv *)rt5670;\r\nrt5670->hp_gpio.jack_status_check = rt5670_irq_detection;\r\nret = snd_soc_jack_add_gpios(rt5670->jack, 1,\r\n&rt5670->hp_gpio);\r\nif (ret) {\r\ndev_err(codec->dev, "Adding jack GPIO failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_dmic_clk(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct rt5670_priv *rt5670 = snd_soc_codec_get_drvdata(codec);\r\nint idx, rate;\r\nrate = rt5670->sysclk / rl6231_get_pre_div(rt5670->regmap,\r\nRT5670_ADDA_CLK1, RT5670_I2S_PD1_SFT);\r\nidx = rl6231_calc_dmic_clk(rate);\r\nif (idx < 0)\r\ndev_err(codec->dev, "Failed to set DMIC clock\n");\r\nelse\r\nsnd_soc_update_bits(codec, RT5670_DMIC_CTRL1,\r\nRT5670_DMIC_CLK_MASK, idx << RT5670_DMIC_CLK_SFT);\r\nreturn idx;\r\n}\r\nstatic int is_sys_clk_from_pll(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(source->dapm);\r\nstruct rt5670_priv *rt5670 = snd_soc_codec_get_drvdata(codec);\r\nif (rt5670->sysclk_src == RT5670_SCLK_S_PLL1)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int is_using_asrc(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(source->dapm);\r\nunsigned int reg, shift, val;\r\nswitch (source->shift) {\r\ncase 0:\r\nreg = RT5670_ASRC_3;\r\nshift = 0;\r\nbreak;\r\ncase 1:\r\nreg = RT5670_ASRC_3;\r\nshift = 4;\r\nbreak;\r\ncase 2:\r\nreg = RT5670_ASRC_5;\r\nshift = 12;\r\nbreak;\r\ncase 3:\r\nreg = RT5670_ASRC_2;\r\nshift = 0;\r\nbreak;\r\ncase 8:\r\nreg = RT5670_ASRC_2;\r\nshift = 4;\r\nbreak;\r\ncase 9:\r\nreg = RT5670_ASRC_2;\r\nshift = 8;\r\nbreak;\r\ncase 10:\r\nreg = RT5670_ASRC_2;\r\nshift = 12;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nval = (snd_soc_read(codec, reg) >> shift) & 0xf;\r\nswitch (val) {\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\ncase 4:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int can_use_asrc(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(source->dapm);\r\nstruct rt5670_priv *rt5670 = snd_soc_codec_get_drvdata(codec);\r\nif (rt5670->sysclk > rt5670->lrck[RT5670_AIF1] * 384)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint rt5670_sel_asrc_clk_src(struct snd_soc_codec *codec,\r\nunsigned int filter_mask, unsigned int clk_src)\r\n{\r\nunsigned int asrc2_mask = 0, asrc2_value = 0;\r\nunsigned int asrc3_mask = 0, asrc3_value = 0;\r\nif (clk_src > RT5670_CLK_SEL_SYS3)\r\nreturn -EINVAL;\r\nif (filter_mask & RT5670_DA_STEREO_FILTER) {\r\nasrc2_mask |= RT5670_DA_STO_CLK_SEL_MASK;\r\nasrc2_value = (asrc2_value & ~RT5670_DA_STO_CLK_SEL_MASK)\r\n| (clk_src << RT5670_DA_STO_CLK_SEL_SFT);\r\n}\r\nif (filter_mask & RT5670_DA_MONO_L_FILTER) {\r\nasrc2_mask |= RT5670_DA_MONOL_CLK_SEL_MASK;\r\nasrc2_value = (asrc2_value & ~RT5670_DA_MONOL_CLK_SEL_MASK)\r\n| (clk_src << RT5670_DA_MONOL_CLK_SEL_SFT);\r\n}\r\nif (filter_mask & RT5670_DA_MONO_R_FILTER) {\r\nasrc2_mask |= RT5670_DA_MONOR_CLK_SEL_MASK;\r\nasrc2_value = (asrc2_value & ~RT5670_DA_MONOR_CLK_SEL_MASK)\r\n| (clk_src << RT5670_DA_MONOR_CLK_SEL_SFT);\r\n}\r\nif (filter_mask & RT5670_AD_STEREO_FILTER) {\r\nasrc2_mask |= RT5670_AD_STO1_CLK_SEL_MASK;\r\nasrc2_value = (asrc2_value & ~RT5670_AD_STO1_CLK_SEL_MASK)\r\n| (clk_src << RT5670_AD_STO1_CLK_SEL_SFT);\r\n}\r\nif (filter_mask & RT5670_AD_MONO_L_FILTER) {\r\nasrc3_mask |= RT5670_AD_MONOL_CLK_SEL_MASK;\r\nasrc3_value = (asrc3_value & ~RT5670_AD_MONOL_CLK_SEL_MASK)\r\n| (clk_src << RT5670_AD_MONOL_CLK_SEL_SFT);\r\n}\r\nif (filter_mask & RT5670_AD_MONO_R_FILTER) {\r\nasrc3_mask |= RT5670_AD_MONOR_CLK_SEL_MASK;\r\nasrc3_value = (asrc3_value & ~RT5670_AD_MONOR_CLK_SEL_MASK)\r\n| (clk_src << RT5670_AD_MONOR_CLK_SEL_SFT);\r\n}\r\nif (filter_mask & RT5670_UP_RATE_FILTER) {\r\nasrc3_mask |= RT5670_UP_CLK_SEL_MASK;\r\nasrc3_value = (asrc3_value & ~RT5670_UP_CLK_SEL_MASK)\r\n| (clk_src << RT5670_UP_CLK_SEL_SFT);\r\n}\r\nif (filter_mask & RT5670_DOWN_RATE_FILTER) {\r\nasrc3_mask |= RT5670_DOWN_CLK_SEL_MASK;\r\nasrc3_value = (asrc3_value & ~RT5670_DOWN_CLK_SEL_MASK)\r\n| (clk_src << RT5670_DOWN_CLK_SEL_SFT);\r\n}\r\nif (asrc2_mask)\r\nsnd_soc_update_bits(codec, RT5670_ASRC_2,\r\nasrc2_mask, asrc2_value);\r\nif (asrc3_mask)\r\nsnd_soc_update_bits(codec, RT5670_ASRC_3,\r\nasrc3_mask, asrc3_value);\r\nreturn 0;\r\n}\r\nstatic int rt5670_hp_power_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct rt5670_priv *rt5670 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nregmap_update_bits(rt5670->regmap, RT5670_CHARGE_PUMP,\r\nRT5670_PM_HP_MASK, RT5670_PM_HP_HV);\r\nregmap_update_bits(rt5670->regmap, RT5670_GEN_CTRL2,\r\n0x0400, 0x0400);\r\nregmap_update_bits(rt5670->regmap, RT5670_PWR_ANLG1,\r\nRT5670_PWR_HA | RT5670_PWR_FV1 |\r\nRT5670_PWR_FV2, RT5670_PWR_HA |\r\nRT5670_PWR_FV1 | RT5670_PWR_FV2);\r\nregmap_write(rt5670->regmap, RT5670_DEPOP_M2, 0x3100);\r\nregmap_write(rt5670->regmap, RT5670_DEPOP_M1, 0x8009);\r\nregmap_write(rt5670->regmap, RT5670_PR_BASE +\r\nRT5670_HP_DCC_INT1, 0x9f00);\r\nmdelay(20);\r\nregmap_write(rt5670->regmap, RT5670_DEPOP_M1, 0x8019);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nregmap_write(rt5670->regmap, RT5670_DEPOP_M1, 0x0004);\r\nmsleep(30);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5670_hp_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct rt5670_priv *rt5670 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nregmap_write(rt5670->regmap, RT5670_PR_BASE +\r\nRT5670_MAMP_INT_REG2, 0xb400);\r\nregmap_write(rt5670->regmap, RT5670_DEPOP_M3, 0x0772);\r\nregmap_write(rt5670->regmap, RT5670_DEPOP_M1, 0x805d);\r\nregmap_write(rt5670->regmap, RT5670_DEPOP_M1, 0x831d);\r\nregmap_update_bits(rt5670->regmap, RT5670_GEN_CTRL2,\r\n0x0300, 0x0300);\r\nregmap_update_bits(rt5670->regmap, RT5670_HP_VOL,\r\nRT5670_L_MUTE | RT5670_R_MUTE, 0);\r\nmsleep(80);\r\nregmap_write(rt5670->regmap, RT5670_DEPOP_M1, 0x8019);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nregmap_write(rt5670->regmap, RT5670_PR_BASE +\r\nRT5670_MAMP_INT_REG2, 0xb400);\r\nregmap_write(rt5670->regmap, RT5670_DEPOP_M3, 0x0772);\r\nregmap_write(rt5670->regmap, RT5670_DEPOP_M1, 0x803d);\r\nmdelay(10);\r\nregmap_write(rt5670->regmap, RT5670_DEPOP_M1, 0x831d);\r\nmdelay(10);\r\nregmap_update_bits(rt5670->regmap, RT5670_HP_VOL,\r\nRT5670_L_MUTE | RT5670_R_MUTE,\r\nRT5670_L_MUTE | RT5670_R_MUTE);\r\nmsleep(20);\r\nregmap_update_bits(rt5670->regmap,\r\nRT5670_GEN_CTRL2, 0x0300, 0x0);\r\nregmap_write(rt5670->regmap, RT5670_DEPOP_M1, 0x8019);\r\nregmap_write(rt5670->regmap, RT5670_DEPOP_M3, 0x0707);\r\nregmap_write(rt5670->regmap, RT5670_PR_BASE +\r\nRT5670_MAMP_INT_REG2, 0xfc00);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5670_bst1_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec, RT5670_PWR_ANLG2,\r\nRT5670_PWR_BST1_P, RT5670_PWR_BST1_P);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec, RT5670_PWR_ANLG2,\r\nRT5670_PWR_BST1_P, 0);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5670_bst2_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec, RT5670_PWR_ANLG2,\r\nRT5670_PWR_BST2_P, RT5670_PWR_BST2_P);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec, RT5670_PWR_ANLG2,\r\nRT5670_PWR_BST2_P, 0);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5670_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct rt5670_priv *rt5670 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val_len = 0, val_clk, mask_clk;\r\nint pre_div, bclk_ms, frame_size;\r\nrt5670->lrck[dai->id] = params_rate(params);\r\npre_div = rl6231_get_clk_info(rt5670->sysclk, rt5670->lrck[dai->id]);\r\nif (pre_div < 0) {\r\ndev_err(codec->dev, "Unsupported clock setting %d for DAI %d\n",\r\nrt5670->lrck[dai->id], dai->id);\r\nreturn -EINVAL;\r\n}\r\nframe_size = snd_soc_params_to_frame_size(params);\r\nif (frame_size < 0) {\r\ndev_err(codec->dev, "Unsupported frame size: %d\n", frame_size);\r\nreturn -EINVAL;\r\n}\r\nbclk_ms = frame_size > 32;\r\nrt5670->bclk[dai->id] = rt5670->lrck[dai->id] * (32 << bclk_ms);\r\ndev_dbg(dai->dev, "bclk is %dHz and lrck is %dHz\n",\r\nrt5670->bclk[dai->id], rt5670->lrck[dai->id]);\r\ndev_dbg(dai->dev, "bclk_ms is %d and pre_div is %d for iis %d\n",\r\nbclk_ms, pre_div, dai->id);\r\nswitch (params_width(params)) {\r\ncase 16:\r\nbreak;\r\ncase 20:\r\nval_len |= RT5670_I2S_DL_20;\r\nbreak;\r\ncase 24:\r\nval_len |= RT5670_I2S_DL_24;\r\nbreak;\r\ncase 8:\r\nval_len |= RT5670_I2S_DL_8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (dai->id) {\r\ncase RT5670_AIF1:\r\nmask_clk = RT5670_I2S_BCLK_MS1_MASK | RT5670_I2S_PD1_MASK;\r\nval_clk = bclk_ms << RT5670_I2S_BCLK_MS1_SFT |\r\npre_div << RT5670_I2S_PD1_SFT;\r\nsnd_soc_update_bits(codec, RT5670_I2S1_SDP,\r\nRT5670_I2S_DL_MASK, val_len);\r\nsnd_soc_update_bits(codec, RT5670_ADDA_CLK1, mask_clk, val_clk);\r\nbreak;\r\ncase RT5670_AIF2:\r\nmask_clk = RT5670_I2S_BCLK_MS2_MASK | RT5670_I2S_PD2_MASK;\r\nval_clk = bclk_ms << RT5670_I2S_BCLK_MS2_SFT |\r\npre_div << RT5670_I2S_PD2_SFT;\r\nsnd_soc_update_bits(codec, RT5670_I2S2_SDP,\r\nRT5670_I2S_DL_MASK, val_len);\r\nsnd_soc_update_bits(codec, RT5670_ADDA_CLK1, mask_clk, val_clk);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid dai->id: %d\n", dai->id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5670_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct rt5670_priv *rt5670 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int reg_val = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nrt5670->master[dai->id] = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nreg_val |= RT5670_I2S_MS_S;\r\nrt5670->master[dai->id] = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nreg_val |= RT5670_I2S_BP_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nreg_val |= RT5670_I2S_DF_LEFT;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nreg_val |= RT5670_I2S_DF_PCM_A;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nreg_val |= RT5670_I2S_DF_PCM_B;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (dai->id) {\r\ncase RT5670_AIF1:\r\nsnd_soc_update_bits(codec, RT5670_I2S1_SDP,\r\nRT5670_I2S_MS_MASK | RT5670_I2S_BP_MASK |\r\nRT5670_I2S_DF_MASK, reg_val);\r\nbreak;\r\ncase RT5670_AIF2:\r\nsnd_soc_update_bits(codec, RT5670_I2S2_SDP,\r\nRT5670_I2S_MS_MASK | RT5670_I2S_BP_MASK |\r\nRT5670_I2S_DF_MASK, reg_val);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid dai->id: %d\n", dai->id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5670_set_dai_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct rt5670_priv *rt5670 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int reg_val = 0;\r\nswitch (clk_id) {\r\ncase RT5670_SCLK_S_MCLK:\r\nreg_val |= RT5670_SCLK_SRC_MCLK;\r\nbreak;\r\ncase RT5670_SCLK_S_PLL1:\r\nreg_val |= RT5670_SCLK_SRC_PLL1;\r\nbreak;\r\ncase RT5670_SCLK_S_RCCLK:\r\nreg_val |= RT5670_SCLK_SRC_RCCLK;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid clock id (%d)\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, RT5670_GLB_CLK,\r\nRT5670_SCLK_SRC_MASK, reg_val);\r\nrt5670->sysclk = freq;\r\nif (clk_id != RT5670_SCLK_S_RCCLK)\r\nrt5670->sysclk_src = clk_id;\r\ndev_dbg(dai->dev, "Sysclk is %dHz and clock id is %d\n", freq, clk_id);\r\nreturn 0;\r\n}\r\nstatic int rt5670_set_dai_pll(struct snd_soc_dai *dai, int pll_id, int source,\r\nunsigned int freq_in, unsigned int freq_out)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct rt5670_priv *rt5670 = snd_soc_codec_get_drvdata(codec);\r\nstruct rl6231_pll_code pll_code;\r\nint ret;\r\nif (source == rt5670->pll_src && freq_in == rt5670->pll_in &&\r\nfreq_out == rt5670->pll_out)\r\nreturn 0;\r\nif (!freq_in || !freq_out) {\r\ndev_dbg(codec->dev, "PLL disabled\n");\r\nrt5670->pll_in = 0;\r\nrt5670->pll_out = 0;\r\nsnd_soc_update_bits(codec, RT5670_GLB_CLK,\r\nRT5670_SCLK_SRC_MASK, RT5670_SCLK_SRC_MCLK);\r\nreturn 0;\r\n}\r\nswitch (source) {\r\ncase RT5670_PLL1_S_MCLK:\r\nsnd_soc_update_bits(codec, RT5670_GLB_CLK,\r\nRT5670_PLL1_SRC_MASK, RT5670_PLL1_SRC_MCLK);\r\nbreak;\r\ncase RT5670_PLL1_S_BCLK1:\r\ncase RT5670_PLL1_S_BCLK2:\r\ncase RT5670_PLL1_S_BCLK3:\r\ncase RT5670_PLL1_S_BCLK4:\r\nswitch (dai->id) {\r\ncase RT5670_AIF1:\r\nsnd_soc_update_bits(codec, RT5670_GLB_CLK,\r\nRT5670_PLL1_SRC_MASK, RT5670_PLL1_SRC_BCLK1);\r\nbreak;\r\ncase RT5670_AIF2:\r\nsnd_soc_update_bits(codec, RT5670_GLB_CLK,\r\nRT5670_PLL1_SRC_MASK, RT5670_PLL1_SRC_BCLK2);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid dai->id: %d\n", dai->id);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unknown PLL source %d\n", source);\r\nreturn -EINVAL;\r\n}\r\nret = rl6231_pll_calc(freq_in, freq_out, &pll_code);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Unsupport input clock %d\n", freq_in);\r\nreturn ret;\r\n}\r\ndev_dbg(codec->dev, "bypass=%d m=%d n=%d k=%d\n",\r\npll_code.m_bp, (pll_code.m_bp ? 0 : pll_code.m_code),\r\npll_code.n_code, pll_code.k_code);\r\nsnd_soc_write(codec, RT5670_PLL_CTRL1,\r\npll_code.n_code << RT5670_PLL_N_SFT | pll_code.k_code);\r\nsnd_soc_write(codec, RT5670_PLL_CTRL2,\r\n(pll_code.m_bp ? 0 : pll_code.m_code) << RT5670_PLL_M_SFT |\r\npll_code.m_bp << RT5670_PLL_M_BP_SFT);\r\nrt5670->pll_in = freq_in;\r\nrt5670->pll_out = freq_out;\r\nrt5670->pll_src = source;\r\nreturn 0;\r\n}\r\nstatic int rt5670_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\r\nunsigned int rx_mask, int slots, int slot_width)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nunsigned int val = 0;\r\nif (rx_mask || tx_mask)\r\nval |= (1 << 14);\r\nswitch (slots) {\r\ncase 4:\r\nval |= (1 << 12);\r\nbreak;\r\ncase 6:\r\nval |= (2 << 12);\r\nbreak;\r\ncase 8:\r\nval |= (3 << 12);\r\nbreak;\r\ncase 2:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (slot_width) {\r\ncase 20:\r\nval |= (1 << 10);\r\nbreak;\r\ncase 24:\r\nval |= (2 << 10);\r\nbreak;\r\ncase 32:\r\nval |= (3 << 10);\r\nbreak;\r\ncase 16:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, RT5670_TDM_CTRL_1, 0x7c00, val);\r\nreturn 0;\r\n}\r\nstatic int rt5670_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct rt5670_priv *rt5670 = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_PREPARE:\r\nif (SND_SOC_BIAS_STANDBY == snd_soc_codec_get_bias_level(codec)) {\r\nsnd_soc_update_bits(codec, RT5670_PWR_ANLG1,\r\nRT5670_PWR_VREF1 | RT5670_PWR_MB |\r\nRT5670_PWR_BG | RT5670_PWR_VREF2,\r\nRT5670_PWR_VREF1 | RT5670_PWR_MB |\r\nRT5670_PWR_BG | RT5670_PWR_VREF2);\r\nmdelay(10);\r\nsnd_soc_update_bits(codec, RT5670_PWR_ANLG1,\r\nRT5670_PWR_FV1 | RT5670_PWR_FV2,\r\nRT5670_PWR_FV1 | RT5670_PWR_FV2);\r\nsnd_soc_update_bits(codec, RT5670_CHARGE_PUMP,\r\nRT5670_OSW_L_MASK | RT5670_OSW_R_MASK,\r\nRT5670_OSW_L_DIS | RT5670_OSW_R_DIS);\r\nsnd_soc_update_bits(codec, RT5670_DIG_MISC, 0x1, 0x1);\r\nsnd_soc_update_bits(codec, RT5670_PWR_ANLG1,\r\nRT5670_LDO_SEL_MASK, 0x3);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nsnd_soc_update_bits(codec, RT5670_PWR_ANLG1,\r\nRT5670_PWR_VREF1 | RT5670_PWR_VREF2 |\r\nRT5670_PWR_FV1 | RT5670_PWR_FV2, 0);\r\nsnd_soc_update_bits(codec, RT5670_PWR_ANLG1,\r\nRT5670_LDO_SEL_MASK, 0x1);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nif (rt5670->pdata.jd_mode)\r\nsnd_soc_update_bits(codec, RT5670_PWR_ANLG1,\r\nRT5670_PWR_VREF1 | RT5670_PWR_MB |\r\nRT5670_PWR_BG | RT5670_PWR_VREF2 |\r\nRT5670_PWR_FV1 | RT5670_PWR_FV2,\r\nRT5670_PWR_MB | RT5670_PWR_BG);\r\nelse\r\nsnd_soc_update_bits(codec, RT5670_PWR_ANLG1,\r\nRT5670_PWR_VREF1 | RT5670_PWR_MB |\r\nRT5670_PWR_BG | RT5670_PWR_VREF2 |\r\nRT5670_PWR_FV1 | RT5670_PWR_FV2, 0);\r\nsnd_soc_update_bits(codec, RT5670_DIG_MISC, 0x1, 0x0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5670_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct rt5670_priv *rt5670 = snd_soc_codec_get_drvdata(codec);\r\nswitch (snd_soc_read(codec, RT5670_RESET) & RT5670_ID_MASK) {\r\ncase RT5670_ID_5670:\r\ncase RT5670_ID_5671:\r\nsnd_soc_dapm_new_controls(dapm,\r\nrt5670_specific_dapm_widgets,\r\nARRAY_SIZE(rt5670_specific_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm,\r\nrt5670_specific_dapm_routes,\r\nARRAY_SIZE(rt5670_specific_dapm_routes));\r\nbreak;\r\ncase RT5670_ID_5672:\r\nsnd_soc_dapm_new_controls(dapm,\r\nrt5672_specific_dapm_widgets,\r\nARRAY_SIZE(rt5672_specific_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm,\r\nrt5672_specific_dapm_routes,\r\nARRAY_SIZE(rt5672_specific_dapm_routes));\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev,\r\n"The driver is for RT5670 RT5671 or RT5672 only\n");\r\nreturn -ENODEV;\r\n}\r\nrt5670->codec = codec;\r\nreturn 0;\r\n}\r\nstatic int rt5670_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct rt5670_priv *rt5670 = snd_soc_codec_get_drvdata(codec);\r\nregmap_write(rt5670->regmap, RT5670_RESET, 0);\r\nsnd_soc_jack_free_gpios(rt5670->jack, 1, &rt5670->hp_gpio);\r\nreturn 0;\r\n}\r\nstatic int rt5670_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct rt5670_priv *rt5670 = snd_soc_codec_get_drvdata(codec);\r\nregcache_cache_only(rt5670->regmap, true);\r\nregcache_mark_dirty(rt5670->regmap);\r\nreturn 0;\r\n}\r\nstatic int rt5670_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct rt5670_priv *rt5670 = snd_soc_codec_get_drvdata(codec);\r\nregcache_cache_only(rt5670->regmap, false);\r\nregcache_sync(rt5670->regmap);\r\nreturn 0;\r\n}\r\nstatic int rt5670_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct rt5670_platform_data *pdata = dev_get_platdata(&i2c->dev);\r\nstruct rt5670_priv *rt5670;\r\nint ret;\r\nunsigned int val;\r\nrt5670 = devm_kzalloc(&i2c->dev,\r\nsizeof(struct rt5670_priv),\r\nGFP_KERNEL);\r\nif (NULL == rt5670)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, rt5670);\r\nif (pdata)\r\nrt5670->pdata = *pdata;\r\nif (dmi_check_system(dmi_platform_intel_braswell)) {\r\nrt5670->pdata.dmic_en = true;\r\nrt5670->pdata.dmic1_data_pin = RT5670_DMIC_DATA_IN2P;\r\nrt5670->pdata.dev_gpio = true;\r\nrt5670->pdata.jd_mode = 1;\r\n}\r\nrt5670->regmap = devm_regmap_init_i2c(i2c, &rt5670_regmap);\r\nif (IS_ERR(rt5670->regmap)) {\r\nret = PTR_ERR(rt5670->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nregmap_read(rt5670->regmap, RT5670_VENDOR_ID2, &val);\r\nif (val != RT5670_DEVICE_ID) {\r\ndev_err(&i2c->dev,\r\n"Device with ID register %#x is not rt5670/72\n", val);\r\nreturn -ENODEV;\r\n}\r\nregmap_write(rt5670->regmap, RT5670_RESET, 0);\r\nregmap_update_bits(rt5670->regmap, RT5670_PWR_ANLG1,\r\nRT5670_PWR_HP_L | RT5670_PWR_HP_R |\r\nRT5670_PWR_VREF2, RT5670_PWR_VREF2);\r\nmsleep(100);\r\nregmap_write(rt5670->regmap, RT5670_RESET, 0);\r\nregmap_read(rt5670->regmap, RT5670_VENDOR_ID, &val);\r\nif (val >= 4)\r\nregmap_write(rt5670->regmap, RT5670_GPIO_CTRL3, 0x0980);\r\nelse\r\nregmap_write(rt5670->regmap, RT5670_GPIO_CTRL3, 0x0d00);\r\nret = regmap_register_patch(rt5670->regmap, init_list,\r\nARRAY_SIZE(init_list));\r\nif (ret != 0)\r\ndev_warn(&i2c->dev, "Failed to apply regmap patch: %d\n", ret);\r\nif (rt5670->pdata.in2_diff)\r\nregmap_update_bits(rt5670->regmap, RT5670_IN2,\r\nRT5670_IN_DF2, RT5670_IN_DF2);\r\nif (rt5670->pdata.dev_gpio) {\r\nregmap_write(rt5670->regmap, RT5670_IL_CMD, 0x0000);\r\nregmap_write(rt5670->regmap, RT5670_IL_CMD2, 0x0010);\r\nregmap_write(rt5670->regmap, RT5670_IL_CMD3, 0x0014);\r\nregmap_update_bits(rt5670->regmap, RT5670_GPIO_CTRL1,\r\nRT5670_GP1_PIN_MASK, RT5670_GP1_PIN_IRQ);\r\nregmap_update_bits(rt5670->regmap, RT5670_GPIO_CTRL2,\r\nRT5670_GP1_PF_MASK, RT5670_GP1_PF_OUT);\r\nregmap_update_bits(rt5670->regmap, RT5670_DIG_MISC, 0x8, 0x8);\r\n}\r\nif (rt5670->pdata.jd_mode) {\r\nregmap_update_bits(rt5670->regmap, RT5670_GLB_CLK,\r\nRT5670_SCLK_SRC_MASK, RT5670_SCLK_SRC_RCCLK);\r\nrt5670->sysclk = 0;\r\nrt5670->sysclk_src = RT5670_SCLK_S_RCCLK;\r\nregmap_update_bits(rt5670->regmap, RT5670_PWR_ANLG1,\r\nRT5670_PWR_MB, RT5670_PWR_MB);\r\nregmap_update_bits(rt5670->regmap, RT5670_PWR_ANLG2,\r\nRT5670_PWR_JD1, RT5670_PWR_JD1);\r\nregmap_update_bits(rt5670->regmap, RT5670_IRQ_CTRL1,\r\nRT5670_JD1_1_EN_MASK, RT5670_JD1_1_EN);\r\nregmap_update_bits(rt5670->regmap, RT5670_JD_CTRL3,\r\nRT5670_JD_TRI_CBJ_SEL_MASK |\r\nRT5670_JD_TRI_HPO_SEL_MASK,\r\nRT5670_JD_CBJ_JD1_1 | RT5670_JD_HPO_JD1_1);\r\nswitch (rt5670->pdata.jd_mode) {\r\ncase 1:\r\nregmap_update_bits(rt5670->regmap, RT5670_A_JD_CTRL1,\r\nRT5670_JD1_MODE_MASK,\r\nRT5670_JD1_MODE_0);\r\nbreak;\r\ncase 2:\r\nregmap_update_bits(rt5670->regmap, RT5670_A_JD_CTRL1,\r\nRT5670_JD1_MODE_MASK,\r\nRT5670_JD1_MODE_1);\r\nbreak;\r\ncase 3:\r\nregmap_update_bits(rt5670->regmap, RT5670_A_JD_CTRL1,\r\nRT5670_JD1_MODE_MASK,\r\nRT5670_JD1_MODE_2);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (rt5670->pdata.dmic_en) {\r\nregmap_update_bits(rt5670->regmap, RT5670_GPIO_CTRL1,\r\nRT5670_GP2_PIN_MASK,\r\nRT5670_GP2_PIN_DMIC1_SCL);\r\nswitch (rt5670->pdata.dmic1_data_pin) {\r\ncase RT5670_DMIC_DATA_IN2P:\r\nregmap_update_bits(rt5670->regmap, RT5670_DMIC_CTRL1,\r\nRT5670_DMIC_1_DP_MASK,\r\nRT5670_DMIC_1_DP_IN2P);\r\nbreak;\r\ncase RT5670_DMIC_DATA_GPIO6:\r\nregmap_update_bits(rt5670->regmap, RT5670_DMIC_CTRL1,\r\nRT5670_DMIC_1_DP_MASK,\r\nRT5670_DMIC_1_DP_GPIO6);\r\nregmap_update_bits(rt5670->regmap, RT5670_GPIO_CTRL1,\r\nRT5670_GP6_PIN_MASK,\r\nRT5670_GP6_PIN_DMIC1_SDA);\r\nbreak;\r\ncase RT5670_DMIC_DATA_GPIO7:\r\nregmap_update_bits(rt5670->regmap, RT5670_DMIC_CTRL1,\r\nRT5670_DMIC_1_DP_MASK,\r\nRT5670_DMIC_1_DP_GPIO7);\r\nregmap_update_bits(rt5670->regmap, RT5670_GPIO_CTRL1,\r\nRT5670_GP7_PIN_MASK,\r\nRT5670_GP7_PIN_DMIC1_SDA);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (rt5670->pdata.dmic2_data_pin) {\r\ncase RT5670_DMIC_DATA_IN3N:\r\nregmap_update_bits(rt5670->regmap, RT5670_DMIC_CTRL1,\r\nRT5670_DMIC_2_DP_MASK,\r\nRT5670_DMIC_2_DP_IN3N);\r\nbreak;\r\ncase RT5670_DMIC_DATA_GPIO8:\r\nregmap_update_bits(rt5670->regmap, RT5670_DMIC_CTRL1,\r\nRT5670_DMIC_2_DP_MASK,\r\nRT5670_DMIC_2_DP_GPIO8);\r\nregmap_update_bits(rt5670->regmap, RT5670_GPIO_CTRL1,\r\nRT5670_GP8_PIN_MASK,\r\nRT5670_GP8_PIN_DMIC2_SDA);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (rt5670->pdata.dmic3_data_pin) {\r\ncase RT5670_DMIC_DATA_GPIO5:\r\nregmap_update_bits(rt5670->regmap, RT5670_DMIC_CTRL2,\r\nRT5670_DMIC_3_DP_MASK,\r\nRT5670_DMIC_3_DP_GPIO5);\r\nregmap_update_bits(rt5670->regmap, RT5670_GPIO_CTRL1,\r\nRT5670_GP5_PIN_MASK,\r\nRT5670_GP5_PIN_DMIC3_SDA);\r\nbreak;\r\ncase RT5670_DMIC_DATA_GPIO9:\r\ncase RT5670_DMIC_DATA_GPIO10:\r\ndev_err(&i2c->dev,\r\n"Always use GPIO5 as DMIC3 data pin\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\npm_runtime_enable(&i2c->dev);\r\npm_request_idle(&i2c->dev);\r\nret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_rt5670,\r\nrt5670_dai, ARRAY_SIZE(rt5670_dai));\r\nif (ret < 0)\r\ngoto err;\r\npm_runtime_put(&i2c->dev);\r\nreturn 0;\r\nerr:\r\npm_runtime_disable(&i2c->dev);\r\nreturn ret;\r\n}\r\nstatic int rt5670_i2c_remove(struct i2c_client *i2c)\r\n{\r\npm_runtime_disable(&i2c->dev);\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nreturn 0;\r\n}
