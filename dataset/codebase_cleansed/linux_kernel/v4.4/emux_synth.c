void\r\nsnd_emux_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)\r\n{\r\nstruct snd_emux *emu;\r\nint i, key, nvoices;\r\nstruct snd_emux_voice *vp;\r\nstruct snd_sf_zone *table[SNDRV_EMUX_MAX_MULTI_VOICES];\r\nunsigned long flags;\r\nstruct snd_emux_port *port;\r\nport = p;\r\nif (snd_BUG_ON(!port || !chan))\r\nreturn;\r\nemu = port->emu;\r\nif (snd_BUG_ON(!emu || !emu->ops.get_voice || !emu->ops.trigger))\r\nreturn;\r\nkey = note;\r\nnvoices = get_zone(emu, port, &note, vel, chan, table);\r\nif (! nvoices)\r\nreturn;\r\nfor (i = 0; i < nvoices; i++) {\r\nstruct snd_sf_zone *zp = table[i];\r\nif (zp && zp->v.exclusiveClass)\r\nexclusive_note_off(emu, port, zp->v.exclusiveClass);\r\n}\r\n#if 0\r\nterminate_note1(emu, key, chan, 0);\r\n#endif\r\nspin_lock_irqsave(&emu->voice_lock, flags);\r\nfor (i = 0; i < nvoices; i++) {\r\nif (table[i] == NULL)\r\ncontinue;\r\nvp = emu->ops.get_voice(emu, port);\r\nif (vp == NULL || vp->ch < 0)\r\ncontinue;\r\nif (STATE_IS_PLAYING(vp->state))\r\nemu->ops.terminate(vp);\r\nvp->time = emu->use_time++;\r\nvp->chan = chan;\r\nvp->port = port;\r\nvp->key = key;\r\nvp->note = note;\r\nvp->velocity = vel;\r\nvp->zone = table[i];\r\nif (vp->zone->sample)\r\nvp->block = vp->zone->sample->block;\r\nelse\r\nvp->block = NULL;\r\nsetup_voice(vp);\r\nvp->state = SNDRV_EMUX_ST_STANDBY;\r\nif (emu->ops.prepare) {\r\nvp->state = SNDRV_EMUX_ST_OFF;\r\nif (emu->ops.prepare(vp) >= 0)\r\nvp->state = SNDRV_EMUX_ST_STANDBY;\r\n}\r\n}\r\nfor (i = 0; i < emu->max_voices; i++) {\r\nvp = &emu->voices[i];\r\nif (vp->state == SNDRV_EMUX_ST_STANDBY &&\r\nvp->chan == chan) {\r\nemu->ops.trigger(vp);\r\nvp->state = SNDRV_EMUX_ST_ON;\r\nvp->ontime = jiffies;\r\n}\r\n}\r\nspin_unlock_irqrestore(&emu->voice_lock, flags);\r\n#ifdef SNDRV_EMUX_USE_RAW_EFFECT\r\nif (port->port_mode == SNDRV_EMUX_PORT_MODE_OSS_SYNTH) {\r\nstruct snd_emux_effect_table *fx = chan->private;\r\nif (fx) {\r\nfx->flag[EMUX_FX_SAMPLE_START] = 0;\r\nfx->flag[EMUX_FX_COARSE_SAMPLE_START] = 0;\r\n}\r\n}\r\n#endif\r\n}\r\nvoid\r\nsnd_emux_note_off(void *p, int note, int vel, struct snd_midi_channel *chan)\r\n{\r\nint ch;\r\nstruct snd_emux *emu;\r\nstruct snd_emux_voice *vp;\r\nunsigned long flags;\r\nstruct snd_emux_port *port;\r\nport = p;\r\nif (snd_BUG_ON(!port || !chan))\r\nreturn;\r\nemu = port->emu;\r\nif (snd_BUG_ON(!emu || !emu->ops.release))\r\nreturn;\r\nspin_lock_irqsave(&emu->voice_lock, flags);\r\nfor (ch = 0; ch < emu->max_voices; ch++) {\r\nvp = &emu->voices[ch];\r\nif (STATE_IS_PLAYING(vp->state) &&\r\nvp->chan == chan && vp->key == note) {\r\nvp->state = SNDRV_EMUX_ST_RELEASED;\r\nif (vp->ontime == jiffies) {\r\nvp->state = SNDRV_EMUX_ST_PENDING;\r\nif (! emu->timer_active) {\r\nmod_timer(&emu->tlist, jiffies + 1);\r\nemu->timer_active = 1;\r\n}\r\n} else\r\nemu->ops.release(vp);\r\n}\r\n}\r\nspin_unlock_irqrestore(&emu->voice_lock, flags);\r\n}\r\nvoid snd_emux_timer_callback(unsigned long data)\r\n{\r\nstruct snd_emux *emu = (struct snd_emux *) data;\r\nstruct snd_emux_voice *vp;\r\nunsigned long flags;\r\nint ch, do_again = 0;\r\nspin_lock_irqsave(&emu->voice_lock, flags);\r\nfor (ch = 0; ch < emu->max_voices; ch++) {\r\nvp = &emu->voices[ch];\r\nif (vp->state == SNDRV_EMUX_ST_PENDING) {\r\nif (vp->ontime == jiffies)\r\ndo_again++;\r\nelse {\r\nemu->ops.release(vp);\r\nvp->state = SNDRV_EMUX_ST_RELEASED;\r\n}\r\n}\r\n}\r\nif (do_again) {\r\nmod_timer(&emu->tlist, jiffies + 1);\r\nemu->timer_active = 1;\r\n} else\r\nemu->timer_active = 0;\r\nspin_unlock_irqrestore(&emu->voice_lock, flags);\r\n}\r\nvoid\r\nsnd_emux_key_press(void *p, int note, int vel, struct snd_midi_channel *chan)\r\n{\r\nint ch;\r\nstruct snd_emux *emu;\r\nstruct snd_emux_voice *vp;\r\nunsigned long flags;\r\nstruct snd_emux_port *port;\r\nport = p;\r\nif (snd_BUG_ON(!port || !chan))\r\nreturn;\r\nemu = port->emu;\r\nif (snd_BUG_ON(!emu || !emu->ops.update))\r\nreturn;\r\nspin_lock_irqsave(&emu->voice_lock, flags);\r\nfor (ch = 0; ch < emu->max_voices; ch++) {\r\nvp = &emu->voices[ch];\r\nif (vp->state == SNDRV_EMUX_ST_ON &&\r\nvp->chan == chan && vp->key == note) {\r\nvp->velocity = vel;\r\nupdate_voice(emu, vp, SNDRV_EMUX_UPDATE_VOLUME);\r\n}\r\n}\r\nspin_unlock_irqrestore(&emu->voice_lock, flags);\r\n}\r\nvoid\r\nsnd_emux_update_channel(struct snd_emux_port *port, struct snd_midi_channel *chan, int update)\r\n{\r\nstruct snd_emux *emu;\r\nstruct snd_emux_voice *vp;\r\nint i;\r\nunsigned long flags;\r\nif (! update)\r\nreturn;\r\nemu = port->emu;\r\nif (snd_BUG_ON(!emu || !emu->ops.update))\r\nreturn;\r\nspin_lock_irqsave(&emu->voice_lock, flags);\r\nfor (i = 0; i < emu->max_voices; i++) {\r\nvp = &emu->voices[i];\r\nif (vp->chan == chan)\r\nupdate_voice(emu, vp, update);\r\n}\r\nspin_unlock_irqrestore(&emu->voice_lock, flags);\r\n}\r\nvoid\r\nsnd_emux_update_port(struct snd_emux_port *port, int update)\r\n{\r\nstruct snd_emux *emu;\r\nstruct snd_emux_voice *vp;\r\nint i;\r\nunsigned long flags;\r\nif (! update)\r\nreturn;\r\nemu = port->emu;\r\nif (snd_BUG_ON(!emu || !emu->ops.update))\r\nreturn;\r\nspin_lock_irqsave(&emu->voice_lock, flags);\r\nfor (i = 0; i < emu->max_voices; i++) {\r\nvp = &emu->voices[i];\r\nif (vp->port == port)\r\nupdate_voice(emu, vp, update);\r\n}\r\nspin_unlock_irqrestore(&emu->voice_lock, flags);\r\n}\r\nvoid\r\nsnd_emux_control(void *p, int type, struct snd_midi_channel *chan)\r\n{\r\nstruct snd_emux_port *port;\r\nport = p;\r\nif (snd_BUG_ON(!port || !chan))\r\nreturn;\r\nswitch (type) {\r\ncase MIDI_CTL_MSB_MAIN_VOLUME:\r\ncase MIDI_CTL_MSB_EXPRESSION:\r\nsnd_emux_update_channel(port, chan, SNDRV_EMUX_UPDATE_VOLUME);\r\nbreak;\r\ncase MIDI_CTL_MSB_PAN:\r\nsnd_emux_update_channel(port, chan, SNDRV_EMUX_UPDATE_PAN);\r\nbreak;\r\ncase MIDI_CTL_SOFT_PEDAL:\r\n#ifdef SNDRV_EMUX_USE_RAW_EFFECT\r\nif (chan->control[type] >= 64)\r\nsnd_emux_send_effect(port, chan, EMUX_FX_CUTOFF, -160,\r\nEMUX_FX_FLAG_ADD);\r\nelse\r\nsnd_emux_send_effect(port, chan, EMUX_FX_CUTOFF, 0,\r\nEMUX_FX_FLAG_OFF);\r\n#endif\r\nbreak;\r\ncase MIDI_CTL_PITCHBEND:\r\nsnd_emux_update_channel(port, chan, SNDRV_EMUX_UPDATE_PITCH);\r\nbreak;\r\ncase MIDI_CTL_MSB_MODWHEEL:\r\ncase MIDI_CTL_CHAN_PRESSURE:\r\nsnd_emux_update_channel(port, chan,\r\nSNDRV_EMUX_UPDATE_FMMOD |\r\nSNDRV_EMUX_UPDATE_FM2FRQ2);\r\nbreak;\r\n}\r\nif (port->chset.midi_mode == SNDRV_MIDI_MODE_XG) {\r\nsnd_emux_xg_control(port, chan, type);\r\n}\r\n}\r\nstatic void\r\nterminate_note1(struct snd_emux *emu, int note, struct snd_midi_channel *chan, int free)\r\n{\r\nint i;\r\nstruct snd_emux_voice *vp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&emu->voice_lock, flags);\r\nfor (i = 0; i < emu->max_voices; i++) {\r\nvp = &emu->voices[i];\r\nif (STATE_IS_PLAYING(vp->state) && vp->chan == chan &&\r\nvp->key == note)\r\nterminate_voice(emu, vp, free);\r\n}\r\nspin_unlock_irqrestore(&emu->voice_lock, flags);\r\n}\r\nvoid\r\nsnd_emux_terminate_note(void *p, int note, struct snd_midi_channel *chan)\r\n{\r\nstruct snd_emux *emu;\r\nstruct snd_emux_port *port;\r\nport = p;\r\nif (snd_BUG_ON(!port || !chan))\r\nreturn;\r\nemu = port->emu;\r\nif (snd_BUG_ON(!emu || !emu->ops.terminate))\r\nreturn;\r\nterminate_note1(emu, note, chan, 1);\r\n}\r\nvoid\r\nsnd_emux_terminate_all(struct snd_emux *emu)\r\n{\r\nint i;\r\nstruct snd_emux_voice *vp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&emu->voice_lock, flags);\r\nfor (i = 0; i < emu->max_voices; i++) {\r\nvp = &emu->voices[i];\r\nif (STATE_IS_PLAYING(vp->state))\r\nterminate_voice(emu, vp, 0);\r\nif (vp->state == SNDRV_EMUX_ST_OFF) {\r\nif (emu->ops.free_voice)\r\nemu->ops.free_voice(vp);\r\nif (emu->ops.reset)\r\nemu->ops.reset(emu, i);\r\n}\r\nvp->time = 0;\r\n}\r\nemu->use_time = 0;\r\nspin_unlock_irqrestore(&emu->voice_lock, flags);\r\n}\r\nvoid\r\nsnd_emux_sounds_off_all(struct snd_emux_port *port)\r\n{\r\nint i;\r\nstruct snd_emux *emu;\r\nstruct snd_emux_voice *vp;\r\nunsigned long flags;\r\nif (snd_BUG_ON(!port))\r\nreturn;\r\nemu = port->emu;\r\nif (snd_BUG_ON(!emu || !emu->ops.terminate))\r\nreturn;\r\nspin_lock_irqsave(&emu->voice_lock, flags);\r\nfor (i = 0; i < emu->max_voices; i++) {\r\nvp = &emu->voices[i];\r\nif (STATE_IS_PLAYING(vp->state) &&\r\nvp->port == port)\r\nterminate_voice(emu, vp, 0);\r\nif (vp->state == SNDRV_EMUX_ST_OFF) {\r\nif (emu->ops.free_voice)\r\nemu->ops.free_voice(vp);\r\nif (emu->ops.reset)\r\nemu->ops.reset(emu, i);\r\n}\r\n}\r\nspin_unlock_irqrestore(&emu->voice_lock, flags);\r\n}\r\nstatic void\r\nexclusive_note_off(struct snd_emux *emu, struct snd_emux_port *port, int exclass)\r\n{\r\nstruct snd_emux_voice *vp;\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&emu->voice_lock, flags);\r\nfor (i = 0; i < emu->max_voices; i++) {\r\nvp = &emu->voices[i];\r\nif (STATE_IS_PLAYING(vp->state) && vp->port == port &&\r\nvp->reg.exclusiveClass == exclass) {\r\nterminate_voice(emu, vp, 0);\r\n}\r\n}\r\nspin_unlock_irqrestore(&emu->voice_lock, flags);\r\n}\r\nstatic void\r\nterminate_voice(struct snd_emux *emu, struct snd_emux_voice *vp, int free)\r\n{\r\nemu->ops.terminate(vp);\r\nvp->time = emu->use_time++;\r\nvp->chan = NULL;\r\nvp->port = NULL;\r\nvp->zone = NULL;\r\nvp->block = NULL;\r\nvp->state = SNDRV_EMUX_ST_OFF;\r\nif (free && emu->ops.free_voice)\r\nemu->ops.free_voice(vp);\r\n}\r\nstatic void\r\nupdate_voice(struct snd_emux *emu, struct snd_emux_voice *vp, int update)\r\n{\r\nif (!STATE_IS_PLAYING(vp->state))\r\nreturn;\r\nif (vp->chan == NULL || vp->port == NULL)\r\nreturn;\r\nif (update & SNDRV_EMUX_UPDATE_VOLUME)\r\ncalc_volume(vp);\r\nif (update & SNDRV_EMUX_UPDATE_PITCH)\r\ncalc_pitch(vp);\r\nif (update & SNDRV_EMUX_UPDATE_PAN) {\r\nif (! calc_pan(vp) && (update == SNDRV_EMUX_UPDATE_PAN))\r\nreturn;\r\n}\r\nemu->ops.update(vp, update);\r\n}\r\nstatic void\r\nsetup_voice(struct snd_emux_voice *vp)\r\n{\r\nstruct soundfont_voice_parm *parm;\r\nint pitch;\r\nvp->reg = vp->zone->v;\r\n#ifdef SNDRV_EMUX_USE_RAW_EFFECT\r\nsnd_emux_setup_effect(vp);\r\n#endif\r\nvp->apan = -1;\r\nvp->avol = -1;\r\nvp->apitch = -1;\r\ncalc_volume(vp);\r\ncalc_pitch(vp);\r\ncalc_pan(vp);\r\nparm = &vp->reg.parm;\r\nif (LO_BYTE(parm->modatkhld) >= 0x80 && parm->moddelay >= 0x8000) {\r\nparm->moddelay = 0xbfff;\r\npitch = (HI_BYTE(parm->pefe) << 4) + vp->apitch;\r\nif (pitch > 0xffff)\r\npitch = 0xffff;\r\nvp->ftarget = parm->cutoff + LO_BYTE(parm->pefe);\r\nLIMITVALUE(vp->ftarget, 0, 255);\r\nvp->ftarget <<= 8;\r\n} else {\r\nvp->ftarget = parm->cutoff;\r\nvp->ftarget <<= 8;\r\npitch = vp->apitch;\r\n}\r\nif (pitch != 0xffff) {\r\nvp->ptarget = 1 << (pitch >> 12);\r\nif (pitch & 0x800) vp->ptarget += (vp->ptarget*0x102e)/0x2710;\r\nif (pitch & 0x400) vp->ptarget += (vp->ptarget*0x764)/0x2710;\r\nif (pitch & 0x200) vp->ptarget += (vp->ptarget*0x389)/0x2710;\r\nvp->ptarget += (vp->ptarget >> 1);\r\nif (vp->ptarget > 0xffff) vp->ptarget = 0xffff;\r\n} else\r\nvp->ptarget = 0xffff;\r\nif (LO_BYTE(parm->modatkhld) >= 0x80) {\r\nparm->modatkhld &= ~0xff;\r\nparm->modatkhld |= 0x7f;\r\n}\r\nvp->vtarget = 0;\r\n#if 0\r\nif (LO_BYTE(parm->volatkhld) >= 0x80 && parm->voldelay >= 0x8000) {\r\nparm->voldelay = 0xbfff;\r\nvp->vtarget = voltarget[vp->avol % 0x10] >> (vp->avol >> 4);\r\n}\r\n#endif\r\nif (LO_BYTE(parm->volatkhld) >= 0x80) {\r\nparm->volatkhld &= ~0xff;\r\nparm->volatkhld |= 0x7f;\r\n}\r\n}\r\nstatic int\r\ncalc_pan(struct snd_emux_voice *vp)\r\n{\r\nstruct snd_midi_channel *chan = vp->chan;\r\nint pan;\r\nif (vp->reg.fixpan > 0)\r\npan = 255 - (int)vp->reg.fixpan * 2;\r\nelse {\r\npan = chan->control[MIDI_CTL_MSB_PAN] - 64;\r\nif (vp->reg.pan >= 0)\r\npan += vp->reg.pan - 64;\r\npan = 127 - (int)pan * 2;\r\n}\r\nLIMITVALUE(pan, 0, 255);\r\nif (vp->emu->linear_panning) {\r\nif (pan != vp->apan) {\r\nvp->apan = pan;\r\nif (pan == 0)\r\nvp->aaux = 0xff;\r\nelse\r\nvp->aaux = (-pan) & 0xff;\r\nreturn 1;\r\n} else\r\nreturn 0;\r\n} else {\r\nif (vp->apan != (int)pan_volumes[pan]) {\r\nvp->apan = pan_volumes[pan];\r\nvp->aaux = pan_volumes[255 - pan];\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\n}\r\nstatic int\r\ncalc_volume(struct snd_emux_voice *vp)\r\n{\r\nint vol;\r\nint main_vol, expression_vol, master_vol;\r\nstruct snd_midi_channel *chan = vp->chan;\r\nstruct snd_emux_port *port = vp->port;\r\nexpression_vol = chan->control[MIDI_CTL_MSB_EXPRESSION];\r\nLIMITMAX(vp->velocity, 127);\r\nLIMITVALUE(expression_vol, 0, 127);\r\nif (port->port_mode == SNDRV_EMUX_PORT_MODE_OSS_SYNTH) {\r\nmain_vol = chan->control[MIDI_CTL_MSB_MAIN_VOLUME];\r\nvol = (vp->velocity * main_vol * expression_vol) / (127*127);\r\nvol = vol * vp->reg.amplitude / 127;\r\nLIMITVALUE(vol, 0, 127);\r\nvol = snd_sf_vol_table[vol];\r\n} else {\r\nmain_vol = chan->control[MIDI_CTL_MSB_MAIN_VOLUME] * vp->reg.amplitude / 127;\r\nLIMITVALUE(main_vol, 0, 127);\r\nvol = voltab1[main_vol] + voltab2[vp->velocity];\r\nvol = (vol * 8) / 3;\r\nvol += vp->reg.attenuation;\r\nvol += ((0x100 - vol) * expressiontab[expression_vol])/128;\r\n}\r\nmaster_vol = port->chset.gs_master_volume;\r\nLIMITVALUE(master_vol, 0, 127);\r\nvol += snd_sf_vol_table[master_vol];\r\nvol += port->volume_atten;\r\n#ifdef SNDRV_EMUX_USE_RAW_EFFECT\r\nif (chan->private) {\r\nstruct snd_emux_effect_table *fx = chan->private;\r\nvol += fx->val[EMUX_FX_ATTEN];\r\n}\r\n#endif\r\nLIMITVALUE(vol, 0, 255);\r\nif (vp->avol == vol)\r\nreturn 0;\r\nvp->avol = vol;\r\nif (!SF_IS_DRUM_BANK(get_bank(port, chan))\r\n&& LO_BYTE(vp->reg.parm.volatkhld) < 0x7d) {\r\nint atten;\r\nif (vp->velocity < 70)\r\natten = 70;\r\nelse\r\natten = vp->velocity;\r\nvp->acutoff = (atten * vp->reg.parm.cutoff + 0xa0) >> 7;\r\n} else {\r\nvp->acutoff = vp->reg.parm.cutoff;\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\ncalc_pitch(struct snd_emux_voice *vp)\r\n{\r\nstruct snd_midi_channel *chan = vp->chan;\r\nint offset;\r\nif (vp->reg.fixkey >= 0) {\r\noffset = (vp->reg.fixkey - vp->reg.root) * 4096 / 12;\r\n} else {\r\noffset = (vp->note - vp->reg.root) * 4096 / 12;\r\n}\r\noffset = (offset * vp->reg.scaleTuning) / 100;\r\noffset += vp->reg.tune * 4096 / 1200;\r\nif (chan->midi_pitchbend != 0) {\r\noffset += chan->midi_pitchbend * chan->gm_rpn_pitch_bend_range / 3072;\r\n}\r\noffset += chan->gm_rpn_coarse_tuning * 4096 / (12 * 128);\r\noffset += chan->gm_rpn_fine_tuning / 24;\r\n#ifdef SNDRV_EMUX_USE_RAW_EFFECT\r\nif (chan->private) {\r\nstruct snd_emux_effect_table *fx = chan->private;\r\nif (fx->flag[EMUX_FX_INIT_PITCH])\r\noffset += fx->val[EMUX_FX_INIT_PITCH];\r\n}\r\n#endif\r\noffset += 0xe000 + vp->reg.rate_offset;\r\noffset += vp->emu->pitch_shift;\r\nLIMITVALUE(offset, 0, 0xffff);\r\nif (offset == vp->apitch)\r\nreturn 0;\r\nvp->apitch = offset;\r\nreturn 1;\r\n}\r\nstatic int\r\nget_bank(struct snd_emux_port *port, struct snd_midi_channel *chan)\r\n{\r\nint val;\r\nswitch (port->chset.midi_mode) {\r\ncase SNDRV_MIDI_MODE_XG:\r\nval = chan->control[MIDI_CTL_MSB_BANK];\r\nif (val == 127)\r\nreturn 128;\r\nreturn chan->control[MIDI_CTL_LSB_BANK];\r\ncase SNDRV_MIDI_MODE_GS:\r\nif (chan->drum_channel)\r\nreturn 128;\r\nreturn chan->control[MIDI_CTL_MSB_BANK];\r\ndefault:\r\nif (chan->drum_channel)\r\nreturn 128;\r\nreturn chan->control[MIDI_CTL_MSB_BANK];\r\n}\r\n}\r\nstatic int\r\nget_zone(struct snd_emux *emu, struct snd_emux_port *port,\r\nint *notep, int vel, struct snd_midi_channel *chan,\r\nstruct snd_sf_zone **table)\r\n{\r\nint preset, bank, def_preset, def_bank;\r\nbank = get_bank(port, chan);\r\npreset = chan->midi_program;\r\nif (SF_IS_DRUM_BANK(bank)) {\r\ndef_preset = port->ctrls[EMUX_MD_DEF_DRUM];\r\ndef_bank = bank;\r\n} else {\r\ndef_preset = preset;\r\ndef_bank = port->ctrls[EMUX_MD_DEF_BANK];\r\n}\r\nreturn snd_soundfont_search_zone(emu->sflist, notep, vel, preset, bank,\r\ndef_preset, def_bank,\r\ntable, SNDRV_EMUX_MAX_MULTI_VOICES);\r\n}\r\nvoid\r\nsnd_emux_init_voices(struct snd_emux *emu)\r\n{\r\nstruct snd_emux_voice *vp;\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&emu->voice_lock, flags);\r\nfor (i = 0; i < emu->max_voices; i++) {\r\nvp = &emu->voices[i];\r\nvp->ch = -1;\r\nvp->state = SNDRV_EMUX_ST_OFF;\r\nvp->chan = NULL;\r\nvp->port = NULL;\r\nvp->time = 0;\r\nvp->emu = emu;\r\nvp->hw = emu->hw;\r\n}\r\nspin_unlock_irqrestore(&emu->voice_lock, flags);\r\n}\r\nvoid snd_emux_lock_voice(struct snd_emux *emu, int voice)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&emu->voice_lock, flags);\r\nif (emu->voices[voice].state == SNDRV_EMUX_ST_OFF)\r\nemu->voices[voice].state = SNDRV_EMUX_ST_LOCKED;\r\nelse\r\nsnd_printk(KERN_WARNING\r\n"invalid voice for lock %d (state = %x)\n",\r\nvoice, emu->voices[voice].state);\r\nspin_unlock_irqrestore(&emu->voice_lock, flags);\r\n}\r\nvoid snd_emux_unlock_voice(struct snd_emux *emu, int voice)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&emu->voice_lock, flags);\r\nif (emu->voices[voice].state == SNDRV_EMUX_ST_LOCKED)\r\nemu->voices[voice].state = SNDRV_EMUX_ST_OFF;\r\nelse\r\nsnd_printk(KERN_WARNING\r\n"invalid voice for unlock %d (state = %x)\n",\r\nvoice, emu->voices[voice].state);\r\nspin_unlock_irqrestore(&emu->voice_lock, flags);\r\n}
