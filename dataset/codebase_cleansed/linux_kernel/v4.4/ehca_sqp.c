u64 ehca_define_sqp(struct ehca_shca *shca,\r\nstruct ehca_qp *ehca_qp,\r\nstruct ib_qp_init_attr *qp_init_attr)\r\n{\r\nu32 pma_qp_nr, bma_qp_nr;\r\nu64 ret;\r\nu8 port = qp_init_attr->port_num;\r\nint counter;\r\nshca->sport[port - 1].port_state = IB_PORT_DOWN;\r\nswitch (qp_init_attr->qp_type) {\r\ncase IB_QPT_SMI:\r\nbreak;\r\ncase IB_QPT_GSI:\r\nret = hipz_h_define_aqp1(shca->ipz_hca_handle,\r\nehca_qp->ipz_qp_handle,\r\nehca_qp->galpas.kernel,\r\n(u32) qp_init_attr->port_num,\r\n&pma_qp_nr, &bma_qp_nr);\r\nif (ret != H_SUCCESS) {\r\nehca_err(&shca->ib_device,\r\n"Can't define AQP1 for port %x. h_ret=%lli",\r\nport, ret);\r\nreturn ret;\r\n}\r\nshca->sport[port - 1].pma_qp_nr = pma_qp_nr;\r\nehca_dbg(&shca->ib_device, "port=%x pma_qp_nr=%x",\r\nport, pma_qp_nr);\r\nbreak;\r\ndefault:\r\nehca_err(&shca->ib_device, "invalid qp_type=%x",\r\nqp_init_attr->qp_type);\r\nreturn H_PARAMETER;\r\n}\r\nif (ehca_nr_ports < 0)\r\nreturn H_SUCCESS;\r\nfor (counter = 0;\r\nshca->sport[port - 1].port_state != IB_PORT_ACTIVE &&\r\ncounter < ehca_port_act_time;\r\ncounter++) {\r\nehca_dbg(&shca->ib_device, "... wait until port %x is active",\r\nport);\r\nmsleep_interruptible(1000);\r\n}\r\nif (counter == ehca_port_act_time) {\r\nehca_err(&shca->ib_device, "Port %x is not active.", port);\r\nreturn H_HARDWARE;\r\n}\r\nreturn H_SUCCESS;\r\n}\r\nstatic int ehca_process_perf(struct ib_device *ibdev, u8 port_num,\r\nconst struct ib_wc *in_wc, const struct ib_grh *in_grh,\r\nconst struct ib_mad *in_mad, struct ib_mad *out_mad)\r\n{\r\nconst struct ib_perf *in_perf = (const struct ib_perf *)in_mad;\r\nstruct ib_perf *out_perf = (struct ib_perf *)out_mad;\r\nstruct ib_class_port_info *poi =\r\n(struct ib_class_port_info *)out_perf->data;\r\nstruct tcslfl *tcslfl =\r\n(struct tcslfl *)&poi->redirect_tcslfl;\r\nstruct ehca_shca *shca =\r\ncontainer_of(ibdev, struct ehca_shca, ib_device);\r\nstruct ehca_sport *sport = &shca->sport[port_num - 1];\r\nehca_dbg(ibdev, "method=%x", in_perf->mad_hdr.method);\r\n*out_mad = *in_mad;\r\nif (in_perf->mad_hdr.class_version != 1) {\r\nehca_warn(ibdev, "Unsupported class_version=%x",\r\nin_perf->mad_hdr.class_version);\r\nout_perf->mad_hdr.status = IB_MAD_STATUS_UNSUP_VERSION;\r\ngoto perf_reply;\r\n}\r\nswitch (in_perf->mad_hdr.method) {\r\ncase IB_MGMT_METHOD_GET:\r\ncase IB_MGMT_METHOD_SET:\r\nout_perf->mad_hdr.attr_id = IB_PMA_CLASS_PORT_INFO;\r\nout_perf->mad_hdr.status = IB_MAD_STATUS_REDIRECT;\r\nmemset(poi, 0, sizeof(*poi));\r\npoi->base_version = 1;\r\npoi->class_version = 1;\r\npoi->resp_time_value = 18;\r\ntcslfl->sl = in_wc->sl;\r\npoi->redirect_lid =\r\nsport->saved_attr.lid | in_wc->dlid_path_bits;\r\npoi->redirect_qp = sport->pma_qp_nr;\r\npoi->redirect_qkey = IB_QP1_QKEY;\r\nehca_query_pkey(ibdev, port_num, in_wc->pkey_index,\r\n&poi->redirect_pkey);\r\nif (in_grh) {\r\nconst struct vertcfl *vertcfl =\r\n(const struct vertcfl *)&in_grh->version_tclass_flow;\r\nmemcpy(poi->redirect_gid, in_grh->dgid.raw,\r\nsizeof(poi->redirect_gid));\r\ntcslfl->tc = vertcfl->tc;\r\ntcslfl->fl = vertcfl->fl;\r\n} else\r\nehca_query_gid(ibdev, port_num, 0,\r\n(union ib_gid *)&poi->redirect_gid);\r\nehca_dbg(ibdev, "ehca_pma_lid=%x ehca_pma_qp=%x",\r\nsport->saved_attr.lid, sport->pma_qp_nr);\r\nbreak;\r\ncase IB_MGMT_METHOD_GET_RESP:\r\nreturn IB_MAD_RESULT_FAILURE;\r\ndefault:\r\nout_perf->mad_hdr.status = IB_MAD_STATUS_UNSUP_METHOD;\r\nbreak;\r\n}\r\nperf_reply:\r\nout_perf->mad_hdr.method = IB_MGMT_METHOD_GET_RESP;\r\nreturn IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_REPLY;\r\n}\r\nint ehca_process_mad(struct ib_device *ibdev, int mad_flags, u8 port_num,\r\nconst struct ib_wc *in_wc, const struct ib_grh *in_grh,\r\nconst struct ib_mad_hdr *in, size_t in_mad_size,\r\nstruct ib_mad_hdr *out, size_t *out_mad_size,\r\nu16 *out_mad_pkey_index)\r\n{\r\nint ret;\r\nconst struct ib_mad *in_mad = (const struct ib_mad *)in;\r\nstruct ib_mad *out_mad = (struct ib_mad *)out;\r\nif (WARN_ON_ONCE(in_mad_size != sizeof(*in_mad) ||\r\n*out_mad_size != sizeof(*out_mad)))\r\nreturn IB_MAD_RESULT_FAILURE;\r\nif (!port_num || port_num > ibdev->phys_port_cnt || !in_wc)\r\nreturn IB_MAD_RESULT_FAILURE;\r\nif (in_mad->mad_hdr.mgmt_class != IB_MGMT_CLASS_PERF_MGMT)\r\nreturn IB_MAD_RESULT_SUCCESS;\r\nehca_dbg(ibdev, "port_num=%x src_qp=%x", port_num, in_wc->src_qp);\r\nret = ehca_process_perf(ibdev, port_num, in_wc, in_grh,\r\nin_mad, out_mad);\r\nreturn ret;\r\n}
