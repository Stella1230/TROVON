static inline void bnx2x_exe_queue_init(struct bnx2x *bp,\r\nstruct bnx2x_exe_queue_obj *o,\r\nint exe_len,\r\nunion bnx2x_qable_obj *owner,\r\nexe_q_validate validate,\r\nexe_q_remove remove,\r\nexe_q_optimize optimize,\r\nexe_q_execute exec,\r\nexe_q_get get)\r\n{\r\nmemset(o, 0, sizeof(*o));\r\nINIT_LIST_HEAD(&o->exe_queue);\r\nINIT_LIST_HEAD(&o->pending_comp);\r\nspin_lock_init(&o->lock);\r\no->exe_chunk_len = exe_len;\r\no->owner = owner;\r\no->validate = validate;\r\no->remove = remove;\r\no->optimize = optimize;\r\no->execute = exec;\r\no->get = get;\r\nDP(BNX2X_MSG_SP, "Setup the execution queue with the chunk length of %d\n",\r\nexe_len);\r\n}\r\nstatic inline void bnx2x_exe_queue_free_elem(struct bnx2x *bp,\r\nstruct bnx2x_exeq_elem *elem)\r\n{\r\nDP(BNX2X_MSG_SP, "Deleting an exe_queue element\n");\r\nkfree(elem);\r\n}\r\nstatic inline int bnx2x_exe_queue_length(struct bnx2x_exe_queue_obj *o)\r\n{\r\nstruct bnx2x_exeq_elem *elem;\r\nint cnt = 0;\r\nspin_lock_bh(&o->lock);\r\nlist_for_each_entry(elem, &o->exe_queue, link)\r\ncnt++;\r\nspin_unlock_bh(&o->lock);\r\nreturn cnt;\r\n}\r\nstatic inline int bnx2x_exe_queue_add(struct bnx2x *bp,\r\nstruct bnx2x_exe_queue_obj *o,\r\nstruct bnx2x_exeq_elem *elem,\r\nbool restore)\r\n{\r\nint rc;\r\nspin_lock_bh(&o->lock);\r\nif (!restore) {\r\nrc = o->optimize(bp, o->owner, elem);\r\nif (rc)\r\ngoto free_and_exit;\r\nrc = o->validate(bp, o->owner, elem);\r\nif (rc) {\r\nDP(BNX2X_MSG_SP, "Preamble failed: %d\n", rc);\r\ngoto free_and_exit;\r\n}\r\n}\r\nlist_add_tail(&elem->link, &o->exe_queue);\r\nspin_unlock_bh(&o->lock);\r\nreturn 0;\r\nfree_and_exit:\r\nbnx2x_exe_queue_free_elem(bp, elem);\r\nspin_unlock_bh(&o->lock);\r\nreturn rc;\r\n}\r\nstatic inline void __bnx2x_exe_queue_reset_pending(\r\nstruct bnx2x *bp,\r\nstruct bnx2x_exe_queue_obj *o)\r\n{\r\nstruct bnx2x_exeq_elem *elem;\r\nwhile (!list_empty(&o->pending_comp)) {\r\nelem = list_first_entry(&o->pending_comp,\r\nstruct bnx2x_exeq_elem, link);\r\nlist_del(&elem->link);\r\nbnx2x_exe_queue_free_elem(bp, elem);\r\n}\r\n}\r\nstatic inline int bnx2x_exe_queue_step(struct bnx2x *bp,\r\nstruct bnx2x_exe_queue_obj *o,\r\nunsigned long *ramrod_flags)\r\n{\r\nstruct bnx2x_exeq_elem *elem, spacer;\r\nint cur_len = 0, rc;\r\nmemset(&spacer, 0, sizeof(spacer));\r\nif (!list_empty(&o->pending_comp)) {\r\nif (test_bit(RAMROD_DRV_CLR_ONLY, ramrod_flags)) {\r\nDP(BNX2X_MSG_SP, "RAMROD_DRV_CLR_ONLY requested: resetting a pending_comp list\n");\r\n__bnx2x_exe_queue_reset_pending(bp, o);\r\n} else {\r\nreturn 1;\r\n}\r\n}\r\nwhile (!list_empty(&o->exe_queue)) {\r\nelem = list_first_entry(&o->exe_queue, struct bnx2x_exeq_elem,\r\nlink);\r\nWARN_ON(!elem->cmd_len);\r\nif (cur_len + elem->cmd_len <= o->exe_chunk_len) {\r\ncur_len += elem->cmd_len;\r\nlist_add_tail(&spacer.link, &o->pending_comp);\r\nmb();\r\nlist_move_tail(&elem->link, &o->pending_comp);\r\nlist_del(&spacer.link);\r\n} else\r\nbreak;\r\n}\r\nif (!cur_len)\r\nreturn 0;\r\nrc = o->execute(bp, o->owner, &o->pending_comp, ramrod_flags);\r\nif (rc < 0)\r\nlist_splice_init(&o->pending_comp, &o->exe_queue);\r\nelse if (!rc)\r\n__bnx2x_exe_queue_reset_pending(bp, o);\r\nreturn rc;\r\n}\r\nstatic inline bool bnx2x_exe_queue_empty(struct bnx2x_exe_queue_obj *o)\r\n{\r\nbool empty = list_empty(&o->exe_queue);\r\nmb();\r\nreturn empty && list_empty(&o->pending_comp);\r\n}\r\nstatic inline struct bnx2x_exeq_elem *bnx2x_exe_queue_alloc_elem(\r\nstruct bnx2x *bp)\r\n{\r\nDP(BNX2X_MSG_SP, "Allocating a new exe_queue element\n");\r\nreturn kzalloc(sizeof(struct bnx2x_exeq_elem), GFP_ATOMIC);\r\n}\r\nstatic bool bnx2x_raw_check_pending(struct bnx2x_raw_obj *o)\r\n{\r\nreturn !!test_bit(o->state, o->pstate);\r\n}\r\nstatic void bnx2x_raw_clear_pending(struct bnx2x_raw_obj *o)\r\n{\r\nsmp_mb__before_atomic();\r\nclear_bit(o->state, o->pstate);\r\nsmp_mb__after_atomic();\r\n}\r\nstatic void bnx2x_raw_set_pending(struct bnx2x_raw_obj *o)\r\n{\r\nsmp_mb__before_atomic();\r\nset_bit(o->state, o->pstate);\r\nsmp_mb__after_atomic();\r\n}\r\nstatic inline int bnx2x_state_wait(struct bnx2x *bp, int state,\r\nunsigned long *pstate)\r\n{\r\nint cnt = 5000;\r\nif (CHIP_REV_IS_EMUL(bp))\r\ncnt *= 20;\r\nDP(BNX2X_MSG_SP, "waiting for state to become %d\n", state);\r\nmight_sleep();\r\nwhile (cnt--) {\r\nif (!test_bit(state, pstate)) {\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nDP(BNX2X_MSG_SP, "exit (cnt %d)\n", 5000 - cnt);\r\n#endif\r\nreturn 0;\r\n}\r\nusleep_range(1000, 2000);\r\nif (bp->panic)\r\nreturn -EIO;\r\n}\r\nBNX2X_ERR("timeout waiting for state %d\n", state);\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nbnx2x_panic();\r\n#endif\r\nreturn -EBUSY;\r\n}\r\nstatic int bnx2x_raw_wait(struct bnx2x *bp, struct bnx2x_raw_obj *raw)\r\n{\r\nreturn bnx2x_state_wait(bp, raw->state, raw->pstate);\r\n}\r\nstatic bool bnx2x_get_cam_offset_mac(struct bnx2x_vlan_mac_obj *o, int *offset)\r\n{\r\nstruct bnx2x_credit_pool_obj *mp = o->macs_pool;\r\nWARN_ON(!mp);\r\nreturn mp->get_entry(mp, offset);\r\n}\r\nstatic bool bnx2x_get_credit_mac(struct bnx2x_vlan_mac_obj *o)\r\n{\r\nstruct bnx2x_credit_pool_obj *mp = o->macs_pool;\r\nWARN_ON(!mp);\r\nreturn mp->get(mp, 1);\r\n}\r\nstatic bool bnx2x_get_cam_offset_vlan(struct bnx2x_vlan_mac_obj *o, int *offset)\r\n{\r\nstruct bnx2x_credit_pool_obj *vp = o->vlans_pool;\r\nWARN_ON(!vp);\r\nreturn vp->get_entry(vp, offset);\r\n}\r\nstatic bool bnx2x_get_credit_vlan(struct bnx2x_vlan_mac_obj *o)\r\n{\r\nstruct bnx2x_credit_pool_obj *vp = o->vlans_pool;\r\nWARN_ON(!vp);\r\nreturn vp->get(vp, 1);\r\n}\r\nstatic bool bnx2x_get_credit_vlan_mac(struct bnx2x_vlan_mac_obj *o)\r\n{\r\nstruct bnx2x_credit_pool_obj *mp = o->macs_pool;\r\nstruct bnx2x_credit_pool_obj *vp = o->vlans_pool;\r\nif (!mp->get(mp, 1))\r\nreturn false;\r\nif (!vp->get(vp, 1)) {\r\nmp->put(mp, 1);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool bnx2x_put_cam_offset_mac(struct bnx2x_vlan_mac_obj *o, int offset)\r\n{\r\nstruct bnx2x_credit_pool_obj *mp = o->macs_pool;\r\nreturn mp->put_entry(mp, offset);\r\n}\r\nstatic bool bnx2x_put_credit_mac(struct bnx2x_vlan_mac_obj *o)\r\n{\r\nstruct bnx2x_credit_pool_obj *mp = o->macs_pool;\r\nreturn mp->put(mp, 1);\r\n}\r\nstatic bool bnx2x_put_cam_offset_vlan(struct bnx2x_vlan_mac_obj *o, int offset)\r\n{\r\nstruct bnx2x_credit_pool_obj *vp = o->vlans_pool;\r\nreturn vp->put_entry(vp, offset);\r\n}\r\nstatic bool bnx2x_put_credit_vlan(struct bnx2x_vlan_mac_obj *o)\r\n{\r\nstruct bnx2x_credit_pool_obj *vp = o->vlans_pool;\r\nreturn vp->put(vp, 1);\r\n}\r\nstatic bool bnx2x_put_credit_vlan_mac(struct bnx2x_vlan_mac_obj *o)\r\n{\r\nstruct bnx2x_credit_pool_obj *mp = o->macs_pool;\r\nstruct bnx2x_credit_pool_obj *vp = o->vlans_pool;\r\nif (!mp->put(mp, 1))\r\nreturn false;\r\nif (!vp->put(vp, 1)) {\r\nmp->get(mp, 1);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int __bnx2x_vlan_mac_h_write_trylock(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o)\r\n{\r\nif (o->head_reader) {\r\nDP(BNX2X_MSG_SP, "vlan_mac_lock writer - There are readers; Busy\n");\r\nreturn -EBUSY;\r\n}\r\nDP(BNX2X_MSG_SP, "vlan_mac_lock writer - Taken\n");\r\nreturn 0;\r\n}\r\nstatic void __bnx2x_vlan_mac_h_exec_pending(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o)\r\n{\r\nint rc;\r\nunsigned long ramrod_flags = o->saved_ramrod_flags;\r\nDP(BNX2X_MSG_SP, "vlan_mac_lock execute pending command with ramrod flags %lu\n",\r\nramrod_flags);\r\no->head_exe_request = false;\r\no->saved_ramrod_flags = 0;\r\nrc = bnx2x_exe_queue_step(bp, &o->exe_queue, &ramrod_flags);\r\nif ((rc != 0) && (rc != 1)) {\r\nBNX2X_ERR("execution of pending commands failed with rc %d\n",\r\nrc);\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nbnx2x_panic();\r\n#endif\r\n}\r\n}\r\nstatic void __bnx2x_vlan_mac_h_pend(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o,\r\nunsigned long ramrod_flags)\r\n{\r\no->head_exe_request = true;\r\no->saved_ramrod_flags = ramrod_flags;\r\nDP(BNX2X_MSG_SP, "Placing pending execution with ramrod flags %lu\n",\r\nramrod_flags);\r\n}\r\nstatic void __bnx2x_vlan_mac_h_write_unlock(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o)\r\n{\r\nwhile (o->head_exe_request) {\r\nDP(BNX2X_MSG_SP, "vlan_mac_lock - writer release encountered a pending request\n");\r\n__bnx2x_vlan_mac_h_exec_pending(bp, o);\r\n}\r\n}\r\nstatic int __bnx2x_vlan_mac_h_read_lock(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o)\r\n{\r\no->head_reader++;\r\nDP(BNX2X_MSG_SP, "vlan_mac_lock - locked reader - number %d\n",\r\no->head_reader);\r\nreturn 0;\r\n}\r\nint bnx2x_vlan_mac_h_read_lock(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o)\r\n{\r\nint rc;\r\nspin_lock_bh(&o->exe_queue.lock);\r\nrc = __bnx2x_vlan_mac_h_read_lock(bp, o);\r\nspin_unlock_bh(&o->exe_queue.lock);\r\nreturn rc;\r\n}\r\nstatic void __bnx2x_vlan_mac_h_read_unlock(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o)\r\n{\r\nif (!o->head_reader) {\r\nBNX2X_ERR("Need to release vlan mac reader lock, but lock isn't taken\n");\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nbnx2x_panic();\r\n#endif\r\n} else {\r\no->head_reader--;\r\nDP(BNX2X_MSG_SP, "vlan_mac_lock - decreased readers to %d\n",\r\no->head_reader);\r\n}\r\nif (!o->head_reader && o->head_exe_request) {\r\nDP(BNX2X_MSG_SP, "vlan_mac_lock - reader release encountered a pending request\n");\r\n__bnx2x_vlan_mac_h_write_unlock(bp, o);\r\n}\r\n}\r\nvoid bnx2x_vlan_mac_h_read_unlock(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o)\r\n{\r\nspin_lock_bh(&o->exe_queue.lock);\r\n__bnx2x_vlan_mac_h_read_unlock(bp, o);\r\nspin_unlock_bh(&o->exe_queue.lock);\r\n}\r\nstatic int bnx2x_get_n_elements(struct bnx2x *bp, struct bnx2x_vlan_mac_obj *o,\r\nint n, u8 *base, u8 stride, u8 size)\r\n{\r\nstruct bnx2x_vlan_mac_registry_elem *pos;\r\nu8 *next = base;\r\nint counter = 0;\r\nint read_lock;\r\nDP(BNX2X_MSG_SP, "get_n_elements - taking vlan_mac_lock (reader)\n");\r\nread_lock = bnx2x_vlan_mac_h_read_lock(bp, o);\r\nif (read_lock != 0)\r\nBNX2X_ERR("get_n_elements failed to get vlan mac reader lock; Access without lock\n");\r\nlist_for_each_entry(pos, &o->head, link) {\r\nif (counter < n) {\r\nmemcpy(next, &pos->u, size);\r\ncounter++;\r\nDP(BNX2X_MSG_SP, "copied element number %d to address %p element was:\n",\r\ncounter, next);\r\nnext += stride + size;\r\n}\r\n}\r\nif (read_lock == 0) {\r\nDP(BNX2X_MSG_SP, "get_n_elements - releasing vlan_mac_lock (reader)\n");\r\nbnx2x_vlan_mac_h_read_unlock(bp, o);\r\n}\r\nreturn counter * ETH_ALEN;\r\n}\r\nstatic int bnx2x_check_mac_add(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o,\r\nunion bnx2x_classification_ramrod_data *data)\r\n{\r\nstruct bnx2x_vlan_mac_registry_elem *pos;\r\nDP(BNX2X_MSG_SP, "Checking MAC %pM for ADD command\n", data->mac.mac);\r\nif (!is_valid_ether_addr(data->mac.mac))\r\nreturn -EINVAL;\r\nlist_for_each_entry(pos, &o->head, link)\r\nif (ether_addr_equal(data->mac.mac, pos->u.mac.mac) &&\r\n(data->mac.is_inner_mac == pos->u.mac.is_inner_mac))\r\nreturn -EEXIST;\r\nreturn 0;\r\n}\r\nstatic int bnx2x_check_vlan_add(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o,\r\nunion bnx2x_classification_ramrod_data *data)\r\n{\r\nstruct bnx2x_vlan_mac_registry_elem *pos;\r\nDP(BNX2X_MSG_SP, "Checking VLAN %d for ADD command\n", data->vlan.vlan);\r\nlist_for_each_entry(pos, &o->head, link)\r\nif (data->vlan.vlan == pos->u.vlan.vlan)\r\nreturn -EEXIST;\r\nreturn 0;\r\n}\r\nstatic int bnx2x_check_vlan_mac_add(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o,\r\nunion bnx2x_classification_ramrod_data *data)\r\n{\r\nstruct bnx2x_vlan_mac_registry_elem *pos;\r\nDP(BNX2X_MSG_SP, "Checking VLAN_MAC (%pM, %d) for ADD command\n",\r\ndata->vlan_mac.mac, data->vlan_mac.vlan);\r\nlist_for_each_entry(pos, &o->head, link)\r\nif ((data->vlan_mac.vlan == pos->u.vlan_mac.vlan) &&\r\n(!memcmp(data->vlan_mac.mac, pos->u.vlan_mac.mac,\r\nETH_ALEN)) &&\r\n(data->vlan_mac.is_inner_mac ==\r\npos->u.vlan_mac.is_inner_mac))\r\nreturn -EEXIST;\r\nreturn 0;\r\n}\r\nstatic struct bnx2x_vlan_mac_registry_elem *\r\nbnx2x_check_mac_del(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o,\r\nunion bnx2x_classification_ramrod_data *data)\r\n{\r\nstruct bnx2x_vlan_mac_registry_elem *pos;\r\nDP(BNX2X_MSG_SP, "Checking MAC %pM for DEL command\n", data->mac.mac);\r\nlist_for_each_entry(pos, &o->head, link)\r\nif (ether_addr_equal(data->mac.mac, pos->u.mac.mac) &&\r\n(data->mac.is_inner_mac == pos->u.mac.is_inner_mac))\r\nreturn pos;\r\nreturn NULL;\r\n}\r\nstatic struct bnx2x_vlan_mac_registry_elem *\r\nbnx2x_check_vlan_del(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o,\r\nunion bnx2x_classification_ramrod_data *data)\r\n{\r\nstruct bnx2x_vlan_mac_registry_elem *pos;\r\nDP(BNX2X_MSG_SP, "Checking VLAN %d for DEL command\n", data->vlan.vlan);\r\nlist_for_each_entry(pos, &o->head, link)\r\nif (data->vlan.vlan == pos->u.vlan.vlan)\r\nreturn pos;\r\nreturn NULL;\r\n}\r\nstatic struct bnx2x_vlan_mac_registry_elem *\r\nbnx2x_check_vlan_mac_del(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o,\r\nunion bnx2x_classification_ramrod_data *data)\r\n{\r\nstruct bnx2x_vlan_mac_registry_elem *pos;\r\nDP(BNX2X_MSG_SP, "Checking VLAN_MAC (%pM, %d) for DEL command\n",\r\ndata->vlan_mac.mac, data->vlan_mac.vlan);\r\nlist_for_each_entry(pos, &o->head, link)\r\nif ((data->vlan_mac.vlan == pos->u.vlan_mac.vlan) &&\r\n(!memcmp(data->vlan_mac.mac, pos->u.vlan_mac.mac,\r\nETH_ALEN)) &&\r\n(data->vlan_mac.is_inner_mac ==\r\npos->u.vlan_mac.is_inner_mac))\r\nreturn pos;\r\nreturn NULL;\r\n}\r\nstatic bool bnx2x_check_move(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *src_o,\r\nstruct bnx2x_vlan_mac_obj *dst_o,\r\nunion bnx2x_classification_ramrod_data *data)\r\n{\r\nstruct bnx2x_vlan_mac_registry_elem *pos;\r\nint rc;\r\npos = src_o->check_del(bp, src_o, data);\r\nrc = dst_o->check_add(bp, dst_o, data);\r\nif (rc || !pos)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool bnx2x_check_move_always_err(\r\nstruct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *src_o,\r\nstruct bnx2x_vlan_mac_obj *dst_o,\r\nunion bnx2x_classification_ramrod_data *data)\r\n{\r\nreturn false;\r\n}\r\nstatic inline u8 bnx2x_vlan_mac_get_rx_tx_flag(struct bnx2x_vlan_mac_obj *o)\r\n{\r\nstruct bnx2x_raw_obj *raw = &o->raw;\r\nu8 rx_tx_flag = 0;\r\nif ((raw->obj_type == BNX2X_OBJ_TYPE_TX) ||\r\n(raw->obj_type == BNX2X_OBJ_TYPE_RX_TX))\r\nrx_tx_flag |= ETH_CLASSIFY_CMD_HEADER_TX_CMD;\r\nif ((raw->obj_type == BNX2X_OBJ_TYPE_RX) ||\r\n(raw->obj_type == BNX2X_OBJ_TYPE_RX_TX))\r\nrx_tx_flag |= ETH_CLASSIFY_CMD_HEADER_RX_CMD;\r\nreturn rx_tx_flag;\r\n}\r\nstatic void bnx2x_set_mac_in_nig(struct bnx2x *bp,\r\nbool add, unsigned char *dev_addr, int index)\r\n{\r\nu32 wb_data[2];\r\nu32 reg_offset = BP_PORT(bp) ? NIG_REG_LLH1_FUNC_MEM :\r\nNIG_REG_LLH0_FUNC_MEM;\r\nif (!IS_MF_SI(bp) && !IS_MF_AFEX(bp))\r\nreturn;\r\nif (index > BNX2X_LLH_CAM_MAX_PF_LINE)\r\nreturn;\r\nDP(BNX2X_MSG_SP, "Going to %s LLH configuration at entry %d\n",\r\n(add ? "ADD" : "DELETE"), index);\r\nif (add) {\r\nreg_offset += 8*index;\r\nwb_data[0] = ((dev_addr[2] << 24) | (dev_addr[3] << 16) |\r\n(dev_addr[4] << 8) | dev_addr[5]);\r\nwb_data[1] = ((dev_addr[0] << 8) | dev_addr[1]);\r\nREG_WR_DMAE(bp, reg_offset, wb_data, 2);\r\n}\r\nREG_WR(bp, (BP_PORT(bp) ? NIG_REG_LLH1_FUNC_MEM_ENABLE :\r\nNIG_REG_LLH0_FUNC_MEM_ENABLE) + 4*index, add);\r\n}\r\nstatic inline void bnx2x_vlan_mac_set_cmd_hdr_e2(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o, bool add, int opcode,\r\nstruct eth_classify_cmd_header *hdr)\r\n{\r\nstruct bnx2x_raw_obj *raw = &o->raw;\r\nhdr->client_id = raw->cl_id;\r\nhdr->func_id = raw->func_id;\r\nhdr->cmd_general_data |=\r\nbnx2x_vlan_mac_get_rx_tx_flag(o);\r\nif (add)\r\nhdr->cmd_general_data |= ETH_CLASSIFY_CMD_HEADER_IS_ADD;\r\nhdr->cmd_general_data |=\r\n(opcode << ETH_CLASSIFY_CMD_HEADER_OPCODE_SHIFT);\r\n}\r\nstatic inline void bnx2x_vlan_mac_set_rdata_hdr_e2(u32 cid, int type,\r\nstruct eth_classify_header *hdr, int rule_cnt)\r\n{\r\nhdr->echo = cpu_to_le32((cid & BNX2X_SWCID_MASK) |\r\n(type << BNX2X_SWCID_SHIFT));\r\nhdr->rule_cnt = (u8)rule_cnt;\r\n}\r\nstatic void bnx2x_set_one_mac_e2(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o,\r\nstruct bnx2x_exeq_elem *elem, int rule_idx,\r\nint cam_offset)\r\n{\r\nstruct bnx2x_raw_obj *raw = &o->raw;\r\nstruct eth_classify_rules_ramrod_data *data =\r\n(struct eth_classify_rules_ramrod_data *)(raw->rdata);\r\nint rule_cnt = rule_idx + 1, cmd = elem->cmd_data.vlan_mac.cmd;\r\nunion eth_classify_rule_cmd *rule_entry = &data->rules[rule_idx];\r\nbool add = (cmd == BNX2X_VLAN_MAC_ADD) ? true : false;\r\nunsigned long *vlan_mac_flags = &elem->cmd_data.vlan_mac.vlan_mac_flags;\r\nu8 *mac = elem->cmd_data.vlan_mac.u.mac.mac;\r\nif (cmd != BNX2X_VLAN_MAC_MOVE) {\r\nif (test_bit(BNX2X_ISCSI_ETH_MAC, vlan_mac_flags))\r\nbnx2x_set_mac_in_nig(bp, add, mac,\r\nBNX2X_LLH_CAM_ISCSI_ETH_LINE);\r\nelse if (test_bit(BNX2X_ETH_MAC, vlan_mac_flags))\r\nbnx2x_set_mac_in_nig(bp, add, mac,\r\nBNX2X_LLH_CAM_ETH_LINE);\r\n}\r\nif (rule_idx == 0)\r\nmemset(data, 0, sizeof(*data));\r\nbnx2x_vlan_mac_set_cmd_hdr_e2(bp, o, add, CLASSIFY_RULE_OPCODE_MAC,\r\n&rule_entry->mac.header);\r\nDP(BNX2X_MSG_SP, "About to %s MAC %pM for Queue %d\n",\r\n(add ? "add" : "delete"), mac, raw->cl_id);\r\nbnx2x_set_fw_mac_addr(&rule_entry->mac.mac_msb,\r\n&rule_entry->mac.mac_mid,\r\n&rule_entry->mac.mac_lsb, mac);\r\nrule_entry->mac.inner_mac =\r\ncpu_to_le16(elem->cmd_data.vlan_mac.u.mac.is_inner_mac);\r\nif (cmd == BNX2X_VLAN_MAC_MOVE) {\r\nrule_entry++;\r\nrule_cnt++;\r\nbnx2x_vlan_mac_set_cmd_hdr_e2(bp,\r\nelem->cmd_data.vlan_mac.target_obj,\r\ntrue, CLASSIFY_RULE_OPCODE_MAC,\r\n&rule_entry->mac.header);\r\nbnx2x_set_fw_mac_addr(&rule_entry->mac.mac_msb,\r\n&rule_entry->mac.mac_mid,\r\n&rule_entry->mac.mac_lsb, mac);\r\nrule_entry->mac.inner_mac =\r\ncpu_to_le16(elem->cmd_data.vlan_mac.\r\nu.mac.is_inner_mac);\r\n}\r\nbnx2x_vlan_mac_set_rdata_hdr_e2(raw->cid, raw->state, &data->header,\r\nrule_cnt);\r\n}\r\nstatic inline void bnx2x_vlan_mac_set_rdata_hdr_e1x(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o, int type, int cam_offset,\r\nstruct mac_configuration_hdr *hdr)\r\n{\r\nstruct bnx2x_raw_obj *r = &o->raw;\r\nhdr->length = 1;\r\nhdr->offset = (u8)cam_offset;\r\nhdr->client_id = cpu_to_le16(0xff);\r\nhdr->echo = cpu_to_le32((r->cid & BNX2X_SWCID_MASK) |\r\n(type << BNX2X_SWCID_SHIFT));\r\n}\r\nstatic inline void bnx2x_vlan_mac_set_cfg_entry_e1x(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o, bool add, int opcode, u8 *mac,\r\nu16 vlan_id, struct mac_configuration_entry *cfg_entry)\r\n{\r\nstruct bnx2x_raw_obj *r = &o->raw;\r\nu32 cl_bit_vec = (1 << r->cl_id);\r\ncfg_entry->clients_bit_vector = cpu_to_le32(cl_bit_vec);\r\ncfg_entry->pf_id = r->func_id;\r\ncfg_entry->vlan_id = cpu_to_le16(vlan_id);\r\nif (add) {\r\nSET_FLAG(cfg_entry->flags, MAC_CONFIGURATION_ENTRY_ACTION_TYPE,\r\nT_ETH_MAC_COMMAND_SET);\r\nSET_FLAG(cfg_entry->flags,\r\nMAC_CONFIGURATION_ENTRY_VLAN_FILTERING_MODE, opcode);\r\nbnx2x_set_fw_mac_addr(&cfg_entry->msb_mac_addr,\r\n&cfg_entry->middle_mac_addr,\r\n&cfg_entry->lsb_mac_addr, mac);\r\n} else\r\nSET_FLAG(cfg_entry->flags, MAC_CONFIGURATION_ENTRY_ACTION_TYPE,\r\nT_ETH_MAC_COMMAND_INVALIDATE);\r\n}\r\nstatic inline void bnx2x_vlan_mac_set_rdata_e1x(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o, int type, int cam_offset, bool add,\r\nu8 *mac, u16 vlan_id, int opcode, struct mac_configuration_cmd *config)\r\n{\r\nstruct mac_configuration_entry *cfg_entry = &config->config_table[0];\r\nstruct bnx2x_raw_obj *raw = &o->raw;\r\nbnx2x_vlan_mac_set_rdata_hdr_e1x(bp, o, type, cam_offset,\r\n&config->hdr);\r\nbnx2x_vlan_mac_set_cfg_entry_e1x(bp, o, add, opcode, mac, vlan_id,\r\ncfg_entry);\r\nDP(BNX2X_MSG_SP, "%s MAC %pM CLID %d CAM offset %d\n",\r\n(add ? "setting" : "clearing"),\r\nmac, raw->cl_id, cam_offset);\r\n}\r\nstatic void bnx2x_set_one_mac_e1x(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o,\r\nstruct bnx2x_exeq_elem *elem, int rule_idx,\r\nint cam_offset)\r\n{\r\nstruct bnx2x_raw_obj *raw = &o->raw;\r\nstruct mac_configuration_cmd *config =\r\n(struct mac_configuration_cmd *)(raw->rdata);\r\nbool add = (elem->cmd_data.vlan_mac.cmd == BNX2X_VLAN_MAC_ADD) ?\r\ntrue : false;\r\nmemset(config, 0, sizeof(*config));\r\nbnx2x_vlan_mac_set_rdata_e1x(bp, o, raw->state,\r\ncam_offset, add,\r\nelem->cmd_data.vlan_mac.u.mac.mac, 0,\r\nETH_VLAN_FILTER_ANY_VLAN, config);\r\n}\r\nstatic void bnx2x_set_one_vlan_e2(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o,\r\nstruct bnx2x_exeq_elem *elem, int rule_idx,\r\nint cam_offset)\r\n{\r\nstruct bnx2x_raw_obj *raw = &o->raw;\r\nstruct eth_classify_rules_ramrod_data *data =\r\n(struct eth_classify_rules_ramrod_data *)(raw->rdata);\r\nint rule_cnt = rule_idx + 1;\r\nunion eth_classify_rule_cmd *rule_entry = &data->rules[rule_idx];\r\nenum bnx2x_vlan_mac_cmd cmd = elem->cmd_data.vlan_mac.cmd;\r\nbool add = (cmd == BNX2X_VLAN_MAC_ADD) ? true : false;\r\nu16 vlan = elem->cmd_data.vlan_mac.u.vlan.vlan;\r\nif (rule_idx == 0)\r\nmemset(data, 0, sizeof(*data));\r\nbnx2x_vlan_mac_set_cmd_hdr_e2(bp, o, add, CLASSIFY_RULE_OPCODE_VLAN,\r\n&rule_entry->vlan.header);\r\nDP(BNX2X_MSG_SP, "About to %s VLAN %d\n", (add ? "add" : "delete"),\r\nvlan);\r\nrule_entry->vlan.vlan = cpu_to_le16(vlan);\r\nif (cmd == BNX2X_VLAN_MAC_MOVE) {\r\nrule_entry++;\r\nrule_cnt++;\r\nbnx2x_vlan_mac_set_cmd_hdr_e2(bp,\r\nelem->cmd_data.vlan_mac.target_obj,\r\ntrue, CLASSIFY_RULE_OPCODE_VLAN,\r\n&rule_entry->vlan.header);\r\nrule_entry->vlan.vlan = cpu_to_le16(vlan);\r\n}\r\nbnx2x_vlan_mac_set_rdata_hdr_e2(raw->cid, raw->state, &data->header,\r\nrule_cnt);\r\n}\r\nstatic void bnx2x_set_one_vlan_mac_e2(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o,\r\nstruct bnx2x_exeq_elem *elem,\r\nint rule_idx, int cam_offset)\r\n{\r\nstruct bnx2x_raw_obj *raw = &o->raw;\r\nstruct eth_classify_rules_ramrod_data *data =\r\n(struct eth_classify_rules_ramrod_data *)(raw->rdata);\r\nint rule_cnt = rule_idx + 1;\r\nunion eth_classify_rule_cmd *rule_entry = &data->rules[rule_idx];\r\nenum bnx2x_vlan_mac_cmd cmd = elem->cmd_data.vlan_mac.cmd;\r\nbool add = (cmd == BNX2X_VLAN_MAC_ADD) ? true : false;\r\nu16 vlan = elem->cmd_data.vlan_mac.u.vlan_mac.vlan;\r\nu8 *mac = elem->cmd_data.vlan_mac.u.vlan_mac.mac;\r\nu16 inner_mac;\r\nif (rule_idx == 0)\r\nmemset(data, 0, sizeof(*data));\r\nbnx2x_vlan_mac_set_cmd_hdr_e2(bp, o, add, CLASSIFY_RULE_OPCODE_PAIR,\r\n&rule_entry->pair.header);\r\nrule_entry->pair.vlan = cpu_to_le16(vlan);\r\nbnx2x_set_fw_mac_addr(&rule_entry->pair.mac_msb,\r\n&rule_entry->pair.mac_mid,\r\n&rule_entry->pair.mac_lsb, mac);\r\ninner_mac = elem->cmd_data.vlan_mac.u.vlan_mac.is_inner_mac;\r\nrule_entry->pair.inner_mac = cpu_to_le16(inner_mac);\r\nif (cmd == BNX2X_VLAN_MAC_MOVE) {\r\nstruct bnx2x_vlan_mac_obj *target_obj;\r\nrule_entry++;\r\nrule_cnt++;\r\ntarget_obj = elem->cmd_data.vlan_mac.target_obj;\r\nbnx2x_vlan_mac_set_cmd_hdr_e2(bp, target_obj,\r\ntrue, CLASSIFY_RULE_OPCODE_PAIR,\r\n&rule_entry->pair.header);\r\nrule_entry->pair.vlan = cpu_to_le16(vlan);\r\nbnx2x_set_fw_mac_addr(&rule_entry->pair.mac_msb,\r\n&rule_entry->pair.mac_mid,\r\n&rule_entry->pair.mac_lsb, mac);\r\nrule_entry->pair.inner_mac = cpu_to_le16(inner_mac);\r\n}\r\nbnx2x_vlan_mac_set_rdata_hdr_e2(raw->cid, raw->state, &data->header,\r\nrule_cnt);\r\n}\r\nstatic void bnx2x_set_one_vlan_mac_e1h(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o,\r\nstruct bnx2x_exeq_elem *elem,\r\nint rule_idx, int cam_offset)\r\n{\r\nstruct bnx2x_raw_obj *raw = &o->raw;\r\nstruct mac_configuration_cmd *config =\r\n(struct mac_configuration_cmd *)(raw->rdata);\r\nbool add = (elem->cmd_data.vlan_mac.cmd == BNX2X_VLAN_MAC_ADD) ?\r\ntrue : false;\r\nmemset(config, 0, sizeof(*config));\r\nbnx2x_vlan_mac_set_rdata_e1x(bp, o, BNX2X_FILTER_VLAN_MAC_PENDING,\r\ncam_offset, add,\r\nelem->cmd_data.vlan_mac.u.vlan_mac.mac,\r\nelem->cmd_data.vlan_mac.u.vlan_mac.vlan,\r\nETH_VLAN_FILTER_CLASSIFY, config);\r\n}\r\nstatic int bnx2x_vlan_mac_restore(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_ramrod_params *p,\r\nstruct bnx2x_vlan_mac_registry_elem **ppos)\r\n{\r\nstruct bnx2x_vlan_mac_registry_elem *pos;\r\nstruct bnx2x_vlan_mac_obj *o = p->vlan_mac_obj;\r\nif (list_empty(&o->head)) {\r\n*ppos = NULL;\r\nreturn 0;\r\n}\r\nif (*ppos == NULL)\r\n*ppos = list_first_entry(&o->head,\r\nstruct bnx2x_vlan_mac_registry_elem,\r\nlink);\r\nelse\r\n*ppos = list_next_entry(*ppos, link);\r\npos = *ppos;\r\nif (list_is_last(&pos->link, &o->head))\r\n*ppos = NULL;\r\nmemcpy(&p->user_req.u, &pos->u, sizeof(pos->u));\r\np->user_req.cmd = BNX2X_VLAN_MAC_ADD;\r\np->user_req.vlan_mac_flags = pos->vlan_mac_flags;\r\n__set_bit(RAMROD_RESTORE, &p->ramrod_flags);\r\nreturn bnx2x_config_vlan_mac(bp, p);\r\n}\r\nstatic struct bnx2x_exeq_elem *bnx2x_exeq_get_mac(\r\nstruct bnx2x_exe_queue_obj *o,\r\nstruct bnx2x_exeq_elem *elem)\r\n{\r\nstruct bnx2x_exeq_elem *pos;\r\nstruct bnx2x_mac_ramrod_data *data = &elem->cmd_data.vlan_mac.u.mac;\r\nlist_for_each_entry(pos, &o->exe_queue, link)\r\nif (!memcmp(&pos->cmd_data.vlan_mac.u.mac, data,\r\nsizeof(*data)) &&\r\n(pos->cmd_data.vlan_mac.cmd == elem->cmd_data.vlan_mac.cmd))\r\nreturn pos;\r\nreturn NULL;\r\n}\r\nstatic struct bnx2x_exeq_elem *bnx2x_exeq_get_vlan(\r\nstruct bnx2x_exe_queue_obj *o,\r\nstruct bnx2x_exeq_elem *elem)\r\n{\r\nstruct bnx2x_exeq_elem *pos;\r\nstruct bnx2x_vlan_ramrod_data *data = &elem->cmd_data.vlan_mac.u.vlan;\r\nlist_for_each_entry(pos, &o->exe_queue, link)\r\nif (!memcmp(&pos->cmd_data.vlan_mac.u.vlan, data,\r\nsizeof(*data)) &&\r\n(pos->cmd_data.vlan_mac.cmd == elem->cmd_data.vlan_mac.cmd))\r\nreturn pos;\r\nreturn NULL;\r\n}\r\nstatic struct bnx2x_exeq_elem *bnx2x_exeq_get_vlan_mac(\r\nstruct bnx2x_exe_queue_obj *o,\r\nstruct bnx2x_exeq_elem *elem)\r\n{\r\nstruct bnx2x_exeq_elem *pos;\r\nstruct bnx2x_vlan_mac_ramrod_data *data =\r\n&elem->cmd_data.vlan_mac.u.vlan_mac;\r\nlist_for_each_entry(pos, &o->exe_queue, link)\r\nif (!memcmp(&pos->cmd_data.vlan_mac.u.vlan_mac, data,\r\nsizeof(*data)) &&\r\n(pos->cmd_data.vlan_mac.cmd ==\r\nelem->cmd_data.vlan_mac.cmd))\r\nreturn pos;\r\nreturn NULL;\r\n}\r\nstatic inline int bnx2x_validate_vlan_mac_add(struct bnx2x *bp,\r\nunion bnx2x_qable_obj *qo,\r\nstruct bnx2x_exeq_elem *elem)\r\n{\r\nstruct bnx2x_vlan_mac_obj *o = &qo->vlan_mac;\r\nstruct bnx2x_exe_queue_obj *exeq = &o->exe_queue;\r\nint rc;\r\nrc = o->check_add(bp, o, &elem->cmd_data.vlan_mac.u);\r\nif (rc) {\r\nDP(BNX2X_MSG_SP, "ADD command is not allowed considering current registry state.\n");\r\nreturn rc;\r\n}\r\nif (exeq->get(exeq, elem)) {\r\nDP(BNX2X_MSG_SP, "There is a pending ADD command already\n");\r\nreturn -EEXIST;\r\n}\r\nif (!(test_bit(BNX2X_DONT_CONSUME_CAM_CREDIT,\r\n&elem->cmd_data.vlan_mac.vlan_mac_flags) ||\r\no->get_credit(o)))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic inline int bnx2x_validate_vlan_mac_del(struct bnx2x *bp,\r\nunion bnx2x_qable_obj *qo,\r\nstruct bnx2x_exeq_elem *elem)\r\n{\r\nstruct bnx2x_vlan_mac_obj *o = &qo->vlan_mac;\r\nstruct bnx2x_vlan_mac_registry_elem *pos;\r\nstruct bnx2x_exe_queue_obj *exeq = &o->exe_queue;\r\nstruct bnx2x_exeq_elem query_elem;\r\npos = o->check_del(bp, o, &elem->cmd_data.vlan_mac.u);\r\nif (!pos) {\r\nDP(BNX2X_MSG_SP, "DEL command is not allowed considering current registry state\n");\r\nreturn -EEXIST;\r\n}\r\nmemcpy(&query_elem, elem, sizeof(query_elem));\r\nquery_elem.cmd_data.vlan_mac.cmd = BNX2X_VLAN_MAC_MOVE;\r\nif (exeq->get(exeq, &query_elem)) {\r\nBNX2X_ERR("There is a pending MOVE command already\n");\r\nreturn -EINVAL;\r\n}\r\nif (exeq->get(exeq, elem)) {\r\nDP(BNX2X_MSG_SP, "There is a pending DEL command already\n");\r\nreturn -EEXIST;\r\n}\r\nif (!(test_bit(BNX2X_DONT_CONSUME_CAM_CREDIT,\r\n&elem->cmd_data.vlan_mac.vlan_mac_flags) ||\r\no->put_credit(o))) {\r\nBNX2X_ERR("Failed to return a credit\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int bnx2x_validate_vlan_mac_move(struct bnx2x *bp,\r\nunion bnx2x_qable_obj *qo,\r\nstruct bnx2x_exeq_elem *elem)\r\n{\r\nstruct bnx2x_vlan_mac_obj *src_o = &qo->vlan_mac;\r\nstruct bnx2x_vlan_mac_obj *dest_o = elem->cmd_data.vlan_mac.target_obj;\r\nstruct bnx2x_exeq_elem query_elem;\r\nstruct bnx2x_exe_queue_obj *src_exeq = &src_o->exe_queue;\r\nstruct bnx2x_exe_queue_obj *dest_exeq = &dest_o->exe_queue;\r\nif (!src_o->check_move(bp, src_o, dest_o,\r\n&elem->cmd_data.vlan_mac.u)) {\r\nDP(BNX2X_MSG_SP, "MOVE command is not allowed considering current registry state\n");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(&query_elem, elem, sizeof(query_elem));\r\nquery_elem.cmd_data.vlan_mac.cmd = BNX2X_VLAN_MAC_DEL;\r\nif (src_exeq->get(src_exeq, &query_elem)) {\r\nBNX2X_ERR("There is a pending DEL command on the source queue already\n");\r\nreturn -EINVAL;\r\n}\r\nif (src_exeq->get(src_exeq, elem)) {\r\nDP(BNX2X_MSG_SP, "There is a pending MOVE command already\n");\r\nreturn -EEXIST;\r\n}\r\nquery_elem.cmd_data.vlan_mac.cmd = BNX2X_VLAN_MAC_ADD;\r\nif (dest_exeq->get(dest_exeq, &query_elem)) {\r\nBNX2X_ERR("There is a pending ADD command on the destination queue already\n");\r\nreturn -EINVAL;\r\n}\r\nif (!(test_bit(BNX2X_DONT_CONSUME_CAM_CREDIT_DEST,\r\n&elem->cmd_data.vlan_mac.vlan_mac_flags) ||\r\ndest_o->get_credit(dest_o)))\r\nreturn -EINVAL;\r\nif (!(test_bit(BNX2X_DONT_CONSUME_CAM_CREDIT,\r\n&elem->cmd_data.vlan_mac.vlan_mac_flags) ||\r\nsrc_o->put_credit(src_o))) {\r\ndest_o->put_credit(dest_o);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_validate_vlan_mac(struct bnx2x *bp,\r\nunion bnx2x_qable_obj *qo,\r\nstruct bnx2x_exeq_elem *elem)\r\n{\r\nswitch (elem->cmd_data.vlan_mac.cmd) {\r\ncase BNX2X_VLAN_MAC_ADD:\r\nreturn bnx2x_validate_vlan_mac_add(bp, qo, elem);\r\ncase BNX2X_VLAN_MAC_DEL:\r\nreturn bnx2x_validate_vlan_mac_del(bp, qo, elem);\r\ncase BNX2X_VLAN_MAC_MOVE:\r\nreturn bnx2x_validate_vlan_mac_move(bp, qo, elem);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int bnx2x_remove_vlan_mac(struct bnx2x *bp,\r\nunion bnx2x_qable_obj *qo,\r\nstruct bnx2x_exeq_elem *elem)\r\n{\r\nint rc = 0;\r\nif (test_bit(BNX2X_DONT_CONSUME_CAM_CREDIT,\r\n&elem->cmd_data.vlan_mac.vlan_mac_flags))\r\nreturn 0;\r\nswitch (elem->cmd_data.vlan_mac.cmd) {\r\ncase BNX2X_VLAN_MAC_ADD:\r\ncase BNX2X_VLAN_MAC_MOVE:\r\nrc = qo->vlan_mac.put_credit(&qo->vlan_mac);\r\nbreak;\r\ncase BNX2X_VLAN_MAC_DEL:\r\nrc = qo->vlan_mac.get_credit(&qo->vlan_mac);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (rc != true)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int bnx2x_wait_vlan_mac(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o)\r\n{\r\nint cnt = 5000, rc;\r\nstruct bnx2x_exe_queue_obj *exeq = &o->exe_queue;\r\nstruct bnx2x_raw_obj *raw = &o->raw;\r\nwhile (cnt--) {\r\nrc = raw->wait_comp(bp, raw);\r\nif (rc)\r\nreturn rc;\r\nif (!bnx2x_exe_queue_empty(exeq))\r\nusleep_range(1000, 2000);\r\nelse\r\nreturn 0;\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int __bnx2x_vlan_mac_execute_step(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o,\r\nunsigned long *ramrod_flags)\r\n{\r\nint rc = 0;\r\nspin_lock_bh(&o->exe_queue.lock);\r\nDP(BNX2X_MSG_SP, "vlan_mac_execute_step - trying to take writer lock\n");\r\nrc = __bnx2x_vlan_mac_h_write_trylock(bp, o);\r\nif (rc != 0) {\r\n__bnx2x_vlan_mac_h_pend(bp, o, *ramrod_flags);\r\nrc = 1;\r\n} else {\r\nrc = bnx2x_exe_queue_step(bp, &o->exe_queue, ramrod_flags);\r\n}\r\nspin_unlock_bh(&o->exe_queue.lock);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_complete_vlan_mac(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o,\r\nunion event_ring_elem *cqe,\r\nunsigned long *ramrod_flags)\r\n{\r\nstruct bnx2x_raw_obj *r = &o->raw;\r\nint rc;\r\nspin_lock_bh(&o->exe_queue.lock);\r\n__bnx2x_exe_queue_reset_pending(bp, &o->exe_queue);\r\nr->clear_pending(r);\r\nspin_unlock_bh(&o->exe_queue.lock);\r\nif (cqe->message.error)\r\nreturn -EINVAL;\r\nif (test_bit(RAMROD_CONT, ramrod_flags)) {\r\nrc = __bnx2x_vlan_mac_execute_step(bp, o, ramrod_flags);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nif (!bnx2x_exe_queue_empty(&o->exe_queue))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int bnx2x_optimize_vlan_mac(struct bnx2x *bp,\r\nunion bnx2x_qable_obj *qo,\r\nstruct bnx2x_exeq_elem *elem)\r\n{\r\nstruct bnx2x_exeq_elem query, *pos;\r\nstruct bnx2x_vlan_mac_obj *o = &qo->vlan_mac;\r\nstruct bnx2x_exe_queue_obj *exeq = &o->exe_queue;\r\nmemcpy(&query, elem, sizeof(query));\r\nswitch (elem->cmd_data.vlan_mac.cmd) {\r\ncase BNX2X_VLAN_MAC_ADD:\r\nquery.cmd_data.vlan_mac.cmd = BNX2X_VLAN_MAC_DEL;\r\nbreak;\r\ncase BNX2X_VLAN_MAC_DEL:\r\nquery.cmd_data.vlan_mac.cmd = BNX2X_VLAN_MAC_ADD;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\npos = exeq->get(exeq, &query);\r\nif (pos) {\r\nif (!test_bit(BNX2X_DONT_CONSUME_CAM_CREDIT,\r\n&pos->cmd_data.vlan_mac.vlan_mac_flags)) {\r\nif ((query.cmd_data.vlan_mac.cmd ==\r\nBNX2X_VLAN_MAC_ADD) && !o->put_credit(o)) {\r\nBNX2X_ERR("Failed to return the credit for the optimized ADD command\n");\r\nreturn -EINVAL;\r\n} else if (!o->get_credit(o)) {\r\nBNX2X_ERR("Failed to recover the credit from the optimized DEL command\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nDP(BNX2X_MSG_SP, "Optimizing %s command\n",\r\n(elem->cmd_data.vlan_mac.cmd == BNX2X_VLAN_MAC_ADD) ?\r\n"ADD" : "DEL");\r\nlist_del(&pos->link);\r\nbnx2x_exe_queue_free_elem(bp, pos);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int bnx2x_vlan_mac_get_registry_elem(\r\nstruct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o,\r\nstruct bnx2x_exeq_elem *elem,\r\nbool restore,\r\nstruct bnx2x_vlan_mac_registry_elem **re)\r\n{\r\nenum bnx2x_vlan_mac_cmd cmd = elem->cmd_data.vlan_mac.cmd;\r\nstruct bnx2x_vlan_mac_registry_elem *reg_elem;\r\nif (!restore &&\r\n((cmd == BNX2X_VLAN_MAC_ADD) || (cmd == BNX2X_VLAN_MAC_MOVE))) {\r\nreg_elem = kzalloc(sizeof(*reg_elem), GFP_ATOMIC);\r\nif (!reg_elem)\r\nreturn -ENOMEM;\r\nif (!o->get_cam_offset(o, &reg_elem->cam_offset)) {\r\nWARN_ON(1);\r\nkfree(reg_elem);\r\nreturn -EINVAL;\r\n}\r\nDP(BNX2X_MSG_SP, "Got cam offset %d\n", reg_elem->cam_offset);\r\nmemcpy(&reg_elem->u, &elem->cmd_data.vlan_mac.u,\r\nsizeof(reg_elem->u));\r\nreg_elem->vlan_mac_flags =\r\nelem->cmd_data.vlan_mac.vlan_mac_flags;\r\n} else\r\nreg_elem = o->check_del(bp, o, &elem->cmd_data.vlan_mac.u);\r\n*re = reg_elem;\r\nreturn 0;\r\n}\r\nstatic int bnx2x_execute_vlan_mac(struct bnx2x *bp,\r\nunion bnx2x_qable_obj *qo,\r\nstruct list_head *exe_chunk,\r\nunsigned long *ramrod_flags)\r\n{\r\nstruct bnx2x_exeq_elem *elem;\r\nstruct bnx2x_vlan_mac_obj *o = &qo->vlan_mac, *cam_obj;\r\nstruct bnx2x_raw_obj *r = &o->raw;\r\nint rc, idx = 0;\r\nbool restore = test_bit(RAMROD_RESTORE, ramrod_flags);\r\nbool drv_only = test_bit(RAMROD_DRV_CLR_ONLY, ramrod_flags);\r\nstruct bnx2x_vlan_mac_registry_elem *reg_elem;\r\nenum bnx2x_vlan_mac_cmd cmd;\r\nif (!drv_only) {\r\nWARN_ON(r->check_pending(r));\r\nr->set_pending(r);\r\nlist_for_each_entry(elem, exe_chunk, link) {\r\ncmd = elem->cmd_data.vlan_mac.cmd;\r\nif (cmd == BNX2X_VLAN_MAC_MOVE)\r\ncam_obj = elem->cmd_data.vlan_mac.target_obj;\r\nelse\r\ncam_obj = o;\r\nrc = bnx2x_vlan_mac_get_registry_elem(bp, cam_obj,\r\nelem, restore,\r\n&reg_elem);\r\nif (rc)\r\ngoto error_exit;\r\nWARN_ON(!reg_elem);\r\nif (!restore &&\r\n((cmd == BNX2X_VLAN_MAC_ADD) ||\r\n(cmd == BNX2X_VLAN_MAC_MOVE)))\r\nlist_add(&reg_elem->link, &cam_obj->head);\r\no->set_one_rule(bp, o, elem, idx,\r\nreg_elem->cam_offset);\r\nif (cmd == BNX2X_VLAN_MAC_MOVE)\r\nidx += 2;\r\nelse\r\nidx++;\r\n}\r\nrc = bnx2x_sp_post(bp, o->ramrod_cmd, r->cid,\r\nU64_HI(r->rdata_mapping),\r\nU64_LO(r->rdata_mapping),\r\nETH_CONNECTION_TYPE);\r\nif (rc)\r\ngoto error_exit;\r\n}\r\nlist_for_each_entry(elem, exe_chunk, link) {\r\ncmd = elem->cmd_data.vlan_mac.cmd;\r\nif ((cmd == BNX2X_VLAN_MAC_DEL) ||\r\n(cmd == BNX2X_VLAN_MAC_MOVE)) {\r\nreg_elem = o->check_del(bp, o,\r\n&elem->cmd_data.vlan_mac.u);\r\nWARN_ON(!reg_elem);\r\no->put_cam_offset(o, reg_elem->cam_offset);\r\nlist_del(&reg_elem->link);\r\nkfree(reg_elem);\r\n}\r\n}\r\nif (!drv_only)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\nerror_exit:\r\nr->clear_pending(r);\r\nlist_for_each_entry(elem, exe_chunk, link) {\r\ncmd = elem->cmd_data.vlan_mac.cmd;\r\nif (cmd == BNX2X_VLAN_MAC_MOVE)\r\ncam_obj = elem->cmd_data.vlan_mac.target_obj;\r\nelse\r\ncam_obj = o;\r\nif (!restore &&\r\n((cmd == BNX2X_VLAN_MAC_ADD) ||\r\n(cmd == BNX2X_VLAN_MAC_MOVE))) {\r\nreg_elem = o->check_del(bp, cam_obj,\r\n&elem->cmd_data.vlan_mac.u);\r\nif (reg_elem) {\r\nlist_del(&reg_elem->link);\r\nkfree(reg_elem);\r\n}\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic inline int bnx2x_vlan_mac_push_new_cmd(\r\nstruct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_ramrod_params *p)\r\n{\r\nstruct bnx2x_exeq_elem *elem;\r\nstruct bnx2x_vlan_mac_obj *o = p->vlan_mac_obj;\r\nbool restore = test_bit(RAMROD_RESTORE, &p->ramrod_flags);\r\nelem = bnx2x_exe_queue_alloc_elem(bp);\r\nif (!elem)\r\nreturn -ENOMEM;\r\nswitch (p->user_req.cmd) {\r\ncase BNX2X_VLAN_MAC_MOVE:\r\nelem->cmd_len = 2;\r\nbreak;\r\ndefault:\r\nelem->cmd_len = 1;\r\n}\r\nmemcpy(&elem->cmd_data.vlan_mac, &p->user_req, sizeof(p->user_req));\r\nreturn bnx2x_exe_queue_add(bp, &o->exe_queue, elem, restore);\r\n}\r\nint bnx2x_config_vlan_mac(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_ramrod_params *p)\r\n{\r\nint rc = 0;\r\nstruct bnx2x_vlan_mac_obj *o = p->vlan_mac_obj;\r\nunsigned long *ramrod_flags = &p->ramrod_flags;\r\nbool cont = test_bit(RAMROD_CONT, ramrod_flags);\r\nstruct bnx2x_raw_obj *raw = &o->raw;\r\nif (!cont) {\r\nrc = bnx2x_vlan_mac_push_new_cmd(bp, p);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (!bnx2x_exe_queue_empty(&o->exe_queue))\r\nrc = 1;\r\nif (test_bit(RAMROD_DRV_CLR_ONLY, ramrod_flags)) {\r\nDP(BNX2X_MSG_SP, "RAMROD_DRV_CLR_ONLY requested: clearing a pending bit.\n");\r\nraw->clear_pending(raw);\r\n}\r\nif (cont || test_bit(RAMROD_EXEC, ramrod_flags) ||\r\ntest_bit(RAMROD_COMP_WAIT, ramrod_flags)) {\r\nrc = __bnx2x_vlan_mac_execute_step(bp, p->vlan_mac_obj,\r\n&p->ramrod_flags);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nif (test_bit(RAMROD_COMP_WAIT, &p->ramrod_flags)) {\r\nint max_iterations = bnx2x_exe_queue_length(&o->exe_queue) + 1;\r\nwhile (!bnx2x_exe_queue_empty(&o->exe_queue) &&\r\nmax_iterations--) {\r\nrc = raw->wait_comp(bp, raw);\r\nif (rc)\r\nreturn rc;\r\nrc = __bnx2x_vlan_mac_execute_step(bp,\r\np->vlan_mac_obj,\r\n&p->ramrod_flags);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic int bnx2x_vlan_mac_del_all(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *o,\r\nunsigned long *vlan_mac_flags,\r\nunsigned long *ramrod_flags)\r\n{\r\nstruct bnx2x_vlan_mac_registry_elem *pos = NULL;\r\nstruct bnx2x_vlan_mac_ramrod_params p;\r\nstruct bnx2x_exe_queue_obj *exeq = &o->exe_queue;\r\nstruct bnx2x_exeq_elem *exeq_pos, *exeq_pos_n;\r\nunsigned long flags;\r\nint read_lock;\r\nint rc = 0;\r\nspin_lock_bh(&exeq->lock);\r\nlist_for_each_entry_safe(exeq_pos, exeq_pos_n, &exeq->exe_queue, link) {\r\nflags = exeq_pos->cmd_data.vlan_mac.vlan_mac_flags;\r\nif (BNX2X_VLAN_MAC_CMP_FLAGS(flags) ==\r\nBNX2X_VLAN_MAC_CMP_FLAGS(*vlan_mac_flags)) {\r\nrc = exeq->remove(bp, exeq->owner, exeq_pos);\r\nif (rc) {\r\nBNX2X_ERR("Failed to remove command\n");\r\nspin_unlock_bh(&exeq->lock);\r\nreturn rc;\r\n}\r\nlist_del(&exeq_pos->link);\r\nbnx2x_exe_queue_free_elem(bp, exeq_pos);\r\n}\r\n}\r\nspin_unlock_bh(&exeq->lock);\r\nmemset(&p, 0, sizeof(p));\r\np.vlan_mac_obj = o;\r\np.ramrod_flags = *ramrod_flags;\r\np.user_req.cmd = BNX2X_VLAN_MAC_DEL;\r\n__clear_bit(RAMROD_COMP_WAIT, &p.ramrod_flags);\r\n__clear_bit(RAMROD_EXEC, &p.ramrod_flags);\r\n__clear_bit(RAMROD_CONT, &p.ramrod_flags);\r\nDP(BNX2X_MSG_SP, "vlan_mac_del_all -- taking vlan_mac_lock (reader)\n");\r\nread_lock = bnx2x_vlan_mac_h_read_lock(bp, o);\r\nif (read_lock != 0)\r\nreturn read_lock;\r\nlist_for_each_entry(pos, &o->head, link) {\r\nflags = pos->vlan_mac_flags;\r\nif (BNX2X_VLAN_MAC_CMP_FLAGS(flags) ==\r\nBNX2X_VLAN_MAC_CMP_FLAGS(*vlan_mac_flags)) {\r\np.user_req.vlan_mac_flags = pos->vlan_mac_flags;\r\nmemcpy(&p.user_req.u, &pos->u, sizeof(pos->u));\r\nrc = bnx2x_config_vlan_mac(bp, &p);\r\nif (rc < 0) {\r\nBNX2X_ERR("Failed to add a new DEL command\n");\r\nbnx2x_vlan_mac_h_read_unlock(bp, o);\r\nreturn rc;\r\n}\r\n}\r\n}\r\nDP(BNX2X_MSG_SP, "vlan_mac_del_all -- releasing vlan_mac_lock (reader)\n");\r\nbnx2x_vlan_mac_h_read_unlock(bp, o);\r\np.ramrod_flags = *ramrod_flags;\r\n__set_bit(RAMROD_CONT, &p.ramrod_flags);\r\nreturn bnx2x_config_vlan_mac(bp, &p);\r\n}\r\nstatic inline void bnx2x_init_raw_obj(struct bnx2x_raw_obj *raw, u8 cl_id,\r\nu32 cid, u8 func_id, void *rdata, dma_addr_t rdata_mapping, int state,\r\nunsigned long *pstate, bnx2x_obj_type type)\r\n{\r\nraw->func_id = func_id;\r\nraw->cid = cid;\r\nraw->cl_id = cl_id;\r\nraw->rdata = rdata;\r\nraw->rdata_mapping = rdata_mapping;\r\nraw->state = state;\r\nraw->pstate = pstate;\r\nraw->obj_type = type;\r\nraw->check_pending = bnx2x_raw_check_pending;\r\nraw->clear_pending = bnx2x_raw_clear_pending;\r\nraw->set_pending = bnx2x_raw_set_pending;\r\nraw->wait_comp = bnx2x_raw_wait;\r\n}\r\nstatic inline void bnx2x_init_vlan_mac_common(struct bnx2x_vlan_mac_obj *o,\r\nu8 cl_id, u32 cid, u8 func_id, void *rdata, dma_addr_t rdata_mapping,\r\nint state, unsigned long *pstate, bnx2x_obj_type type,\r\nstruct bnx2x_credit_pool_obj *macs_pool,\r\nstruct bnx2x_credit_pool_obj *vlans_pool)\r\n{\r\nINIT_LIST_HEAD(&o->head);\r\no->head_reader = 0;\r\no->head_exe_request = false;\r\no->saved_ramrod_flags = 0;\r\no->macs_pool = macs_pool;\r\no->vlans_pool = vlans_pool;\r\no->delete_all = bnx2x_vlan_mac_del_all;\r\no->restore = bnx2x_vlan_mac_restore;\r\no->complete = bnx2x_complete_vlan_mac;\r\no->wait = bnx2x_wait_vlan_mac;\r\nbnx2x_init_raw_obj(&o->raw, cl_id, cid, func_id, rdata, rdata_mapping,\r\nstate, pstate, type);\r\n}\r\nvoid bnx2x_init_mac_obj(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *mac_obj,\r\nu8 cl_id, u32 cid, u8 func_id, void *rdata,\r\ndma_addr_t rdata_mapping, int state,\r\nunsigned long *pstate, bnx2x_obj_type type,\r\nstruct bnx2x_credit_pool_obj *macs_pool)\r\n{\r\nunion bnx2x_qable_obj *qable_obj = (union bnx2x_qable_obj *)mac_obj;\r\nbnx2x_init_vlan_mac_common(mac_obj, cl_id, cid, func_id, rdata,\r\nrdata_mapping, state, pstate, type,\r\nmacs_pool, NULL);\r\nmac_obj->get_credit = bnx2x_get_credit_mac;\r\nmac_obj->put_credit = bnx2x_put_credit_mac;\r\nmac_obj->get_cam_offset = bnx2x_get_cam_offset_mac;\r\nmac_obj->put_cam_offset = bnx2x_put_cam_offset_mac;\r\nif (CHIP_IS_E1x(bp)) {\r\nmac_obj->set_one_rule = bnx2x_set_one_mac_e1x;\r\nmac_obj->check_del = bnx2x_check_mac_del;\r\nmac_obj->check_add = bnx2x_check_mac_add;\r\nmac_obj->check_move = bnx2x_check_move_always_err;\r\nmac_obj->ramrod_cmd = RAMROD_CMD_ID_ETH_SET_MAC;\r\nbnx2x_exe_queue_init(bp,\r\n&mac_obj->exe_queue, 1, qable_obj,\r\nbnx2x_validate_vlan_mac,\r\nbnx2x_remove_vlan_mac,\r\nbnx2x_optimize_vlan_mac,\r\nbnx2x_execute_vlan_mac,\r\nbnx2x_exeq_get_mac);\r\n} else {\r\nmac_obj->set_one_rule = bnx2x_set_one_mac_e2;\r\nmac_obj->check_del = bnx2x_check_mac_del;\r\nmac_obj->check_add = bnx2x_check_mac_add;\r\nmac_obj->check_move = bnx2x_check_move;\r\nmac_obj->ramrod_cmd =\r\nRAMROD_CMD_ID_ETH_CLASSIFICATION_RULES;\r\nmac_obj->get_n_elements = bnx2x_get_n_elements;\r\nbnx2x_exe_queue_init(bp,\r\n&mac_obj->exe_queue, CLASSIFY_RULES_COUNT,\r\nqable_obj, bnx2x_validate_vlan_mac,\r\nbnx2x_remove_vlan_mac,\r\nbnx2x_optimize_vlan_mac,\r\nbnx2x_execute_vlan_mac,\r\nbnx2x_exeq_get_mac);\r\n}\r\n}\r\nvoid bnx2x_init_vlan_obj(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *vlan_obj,\r\nu8 cl_id, u32 cid, u8 func_id, void *rdata,\r\ndma_addr_t rdata_mapping, int state,\r\nunsigned long *pstate, bnx2x_obj_type type,\r\nstruct bnx2x_credit_pool_obj *vlans_pool)\r\n{\r\nunion bnx2x_qable_obj *qable_obj = (union bnx2x_qable_obj *)vlan_obj;\r\nbnx2x_init_vlan_mac_common(vlan_obj, cl_id, cid, func_id, rdata,\r\nrdata_mapping, state, pstate, type, NULL,\r\nvlans_pool);\r\nvlan_obj->get_credit = bnx2x_get_credit_vlan;\r\nvlan_obj->put_credit = bnx2x_put_credit_vlan;\r\nvlan_obj->get_cam_offset = bnx2x_get_cam_offset_vlan;\r\nvlan_obj->put_cam_offset = bnx2x_put_cam_offset_vlan;\r\nif (CHIP_IS_E1x(bp)) {\r\nBNX2X_ERR("Do not support chips others than E2 and newer\n");\r\nBUG();\r\n} else {\r\nvlan_obj->set_one_rule = bnx2x_set_one_vlan_e2;\r\nvlan_obj->check_del = bnx2x_check_vlan_del;\r\nvlan_obj->check_add = bnx2x_check_vlan_add;\r\nvlan_obj->check_move = bnx2x_check_move;\r\nvlan_obj->ramrod_cmd =\r\nRAMROD_CMD_ID_ETH_CLASSIFICATION_RULES;\r\nvlan_obj->get_n_elements = bnx2x_get_n_elements;\r\nbnx2x_exe_queue_init(bp,\r\n&vlan_obj->exe_queue, CLASSIFY_RULES_COUNT,\r\nqable_obj, bnx2x_validate_vlan_mac,\r\nbnx2x_remove_vlan_mac,\r\nbnx2x_optimize_vlan_mac,\r\nbnx2x_execute_vlan_mac,\r\nbnx2x_exeq_get_vlan);\r\n}\r\n}\r\nvoid bnx2x_init_vlan_mac_obj(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *vlan_mac_obj,\r\nu8 cl_id, u32 cid, u8 func_id, void *rdata,\r\ndma_addr_t rdata_mapping, int state,\r\nunsigned long *pstate, bnx2x_obj_type type,\r\nstruct bnx2x_credit_pool_obj *macs_pool,\r\nstruct bnx2x_credit_pool_obj *vlans_pool)\r\n{\r\nunion bnx2x_qable_obj *qable_obj =\r\n(union bnx2x_qable_obj *)vlan_mac_obj;\r\nbnx2x_init_vlan_mac_common(vlan_mac_obj, cl_id, cid, func_id, rdata,\r\nrdata_mapping, state, pstate, type,\r\nmacs_pool, vlans_pool);\r\nvlan_mac_obj->get_credit = bnx2x_get_credit_vlan_mac;\r\nvlan_mac_obj->put_credit = bnx2x_put_credit_vlan_mac;\r\nvlan_mac_obj->get_cam_offset = bnx2x_get_cam_offset_mac;\r\nvlan_mac_obj->put_cam_offset = bnx2x_put_cam_offset_mac;\r\nif (CHIP_IS_E1(bp)) {\r\nBNX2X_ERR("Do not support chips others than E2\n");\r\nBUG();\r\n} else if (CHIP_IS_E1H(bp)) {\r\nvlan_mac_obj->set_one_rule = bnx2x_set_one_vlan_mac_e1h;\r\nvlan_mac_obj->check_del = bnx2x_check_vlan_mac_del;\r\nvlan_mac_obj->check_add = bnx2x_check_vlan_mac_add;\r\nvlan_mac_obj->check_move = bnx2x_check_move_always_err;\r\nvlan_mac_obj->ramrod_cmd = RAMROD_CMD_ID_ETH_SET_MAC;\r\nbnx2x_exe_queue_init(bp,\r\n&vlan_mac_obj->exe_queue, 1, qable_obj,\r\nbnx2x_validate_vlan_mac,\r\nbnx2x_remove_vlan_mac,\r\nbnx2x_optimize_vlan_mac,\r\nbnx2x_execute_vlan_mac,\r\nbnx2x_exeq_get_vlan_mac);\r\n} else {\r\nvlan_mac_obj->set_one_rule = bnx2x_set_one_vlan_mac_e2;\r\nvlan_mac_obj->check_del = bnx2x_check_vlan_mac_del;\r\nvlan_mac_obj->check_add = bnx2x_check_vlan_mac_add;\r\nvlan_mac_obj->check_move = bnx2x_check_move;\r\nvlan_mac_obj->ramrod_cmd =\r\nRAMROD_CMD_ID_ETH_CLASSIFICATION_RULES;\r\nbnx2x_exe_queue_init(bp,\r\n&vlan_mac_obj->exe_queue,\r\nCLASSIFY_RULES_COUNT,\r\nqable_obj, bnx2x_validate_vlan_mac,\r\nbnx2x_remove_vlan_mac,\r\nbnx2x_optimize_vlan_mac,\r\nbnx2x_execute_vlan_mac,\r\nbnx2x_exeq_get_vlan_mac);\r\n}\r\n}\r\nstatic inline void __storm_memset_mac_filters(struct bnx2x *bp,\r\nstruct tstorm_eth_mac_filter_config *mac_filters,\r\nu16 pf_id)\r\n{\r\nsize_t size = sizeof(struct tstorm_eth_mac_filter_config);\r\nu32 addr = BAR_TSTRORM_INTMEM +\r\nTSTORM_MAC_FILTER_CONFIG_OFFSET(pf_id);\r\n__storm_memset_struct(bp, addr, size, (u32 *)mac_filters);\r\n}\r\nstatic int bnx2x_set_rx_mode_e1x(struct bnx2x *bp,\r\nstruct bnx2x_rx_mode_ramrod_params *p)\r\n{\r\nu32 mask = (1 << p->cl_id);\r\nstruct tstorm_eth_mac_filter_config *mac_filters =\r\n(struct tstorm_eth_mac_filter_config *)p->rdata;\r\nu8 drop_all_ucast = 1, drop_all_mcast = 1;\r\nu8 accp_all_ucast = 0, accp_all_bcast = 0, accp_all_mcast = 0;\r\nu8 unmatched_unicast = 0;\r\nif (test_bit(BNX2X_ACCEPT_UNICAST, &p->rx_accept_flags))\r\ndrop_all_ucast = 0;\r\nif (test_bit(BNX2X_ACCEPT_MULTICAST, &p->rx_accept_flags))\r\ndrop_all_mcast = 0;\r\nif (test_bit(BNX2X_ACCEPT_ALL_UNICAST, &p->rx_accept_flags)) {\r\ndrop_all_ucast = 0;\r\naccp_all_ucast = 1;\r\n}\r\nif (test_bit(BNX2X_ACCEPT_ALL_MULTICAST, &p->rx_accept_flags)) {\r\ndrop_all_mcast = 0;\r\naccp_all_mcast = 1;\r\n}\r\nif (test_bit(BNX2X_ACCEPT_BROADCAST, &p->rx_accept_flags))\r\naccp_all_bcast = 1;\r\nif (test_bit(BNX2X_ACCEPT_UNMATCHED, &p->rx_accept_flags))\r\nunmatched_unicast = 1;\r\nmac_filters->ucast_drop_all = drop_all_ucast ?\r\nmac_filters->ucast_drop_all | mask :\r\nmac_filters->ucast_drop_all & ~mask;\r\nmac_filters->mcast_drop_all = drop_all_mcast ?\r\nmac_filters->mcast_drop_all | mask :\r\nmac_filters->mcast_drop_all & ~mask;\r\nmac_filters->ucast_accept_all = accp_all_ucast ?\r\nmac_filters->ucast_accept_all | mask :\r\nmac_filters->ucast_accept_all & ~mask;\r\nmac_filters->mcast_accept_all = accp_all_mcast ?\r\nmac_filters->mcast_accept_all | mask :\r\nmac_filters->mcast_accept_all & ~mask;\r\nmac_filters->bcast_accept_all = accp_all_bcast ?\r\nmac_filters->bcast_accept_all | mask :\r\nmac_filters->bcast_accept_all & ~mask;\r\nmac_filters->unmatched_unicast = unmatched_unicast ?\r\nmac_filters->unmatched_unicast | mask :\r\nmac_filters->unmatched_unicast & ~mask;\r\nDP(BNX2X_MSG_SP, "drop_ucast 0x%x\ndrop_mcast 0x%x\n accp_ucast 0x%x\n"\r\n"accp_mcast 0x%x\naccp_bcast 0x%x\n",\r\nmac_filters->ucast_drop_all, mac_filters->mcast_drop_all,\r\nmac_filters->ucast_accept_all, mac_filters->mcast_accept_all,\r\nmac_filters->bcast_accept_all);\r\n__storm_memset_mac_filters(bp, mac_filters, p->func_id);\r\nclear_bit(p->state, p->pstate);\r\nsmp_mb__after_atomic();\r\nreturn 0;\r\n}\r\nstatic inline void bnx2x_rx_mode_set_rdata_hdr_e2(u32 cid,\r\nstruct eth_classify_header *hdr,\r\nu8 rule_cnt)\r\n{\r\nhdr->echo = cpu_to_le32(cid);\r\nhdr->rule_cnt = rule_cnt;\r\n}\r\nstatic inline void bnx2x_rx_mode_set_cmd_state_e2(struct bnx2x *bp,\r\nunsigned long *accept_flags,\r\nstruct eth_filter_rules_cmd *cmd,\r\nbool clear_accept_all)\r\n{\r\nu16 state;\r\nstate = ETH_FILTER_RULES_CMD_UCAST_DROP_ALL |\r\nETH_FILTER_RULES_CMD_MCAST_DROP_ALL;\r\nif (test_bit(BNX2X_ACCEPT_UNICAST, accept_flags))\r\nstate &= ~ETH_FILTER_RULES_CMD_UCAST_DROP_ALL;\r\nif (test_bit(BNX2X_ACCEPT_MULTICAST, accept_flags))\r\nstate &= ~ETH_FILTER_RULES_CMD_MCAST_DROP_ALL;\r\nif (test_bit(BNX2X_ACCEPT_ALL_UNICAST, accept_flags)) {\r\nstate &= ~ETH_FILTER_RULES_CMD_UCAST_DROP_ALL;\r\nstate |= ETH_FILTER_RULES_CMD_UCAST_ACCEPT_ALL;\r\n}\r\nif (test_bit(BNX2X_ACCEPT_ALL_MULTICAST, accept_flags)) {\r\nstate |= ETH_FILTER_RULES_CMD_MCAST_ACCEPT_ALL;\r\nstate &= ~ETH_FILTER_RULES_CMD_MCAST_DROP_ALL;\r\n}\r\nif (test_bit(BNX2X_ACCEPT_BROADCAST, accept_flags))\r\nstate |= ETH_FILTER_RULES_CMD_BCAST_ACCEPT_ALL;\r\nif (test_bit(BNX2X_ACCEPT_UNMATCHED, accept_flags)) {\r\nstate &= ~ETH_FILTER_RULES_CMD_UCAST_DROP_ALL;\r\nstate |= ETH_FILTER_RULES_CMD_UCAST_ACCEPT_UNMATCHED;\r\n}\r\nif (test_bit(BNX2X_ACCEPT_ANY_VLAN, accept_flags))\r\nstate |= ETH_FILTER_RULES_CMD_ACCEPT_ANY_VLAN;\r\nif (clear_accept_all) {\r\nstate &= ~ETH_FILTER_RULES_CMD_MCAST_ACCEPT_ALL;\r\nstate &= ~ETH_FILTER_RULES_CMD_BCAST_ACCEPT_ALL;\r\nstate &= ~ETH_FILTER_RULES_CMD_UCAST_ACCEPT_ALL;\r\nstate &= ~ETH_FILTER_RULES_CMD_UCAST_ACCEPT_UNMATCHED;\r\n}\r\ncmd->state = cpu_to_le16(state);\r\n}\r\nstatic int bnx2x_set_rx_mode_e2(struct bnx2x *bp,\r\nstruct bnx2x_rx_mode_ramrod_params *p)\r\n{\r\nstruct eth_filter_rules_ramrod_data *data = p->rdata;\r\nint rc;\r\nu8 rule_idx = 0;\r\nmemset(data, 0, sizeof(*data));\r\nif (test_bit(RAMROD_TX, &p->ramrod_flags)) {\r\ndata->rules[rule_idx].client_id = p->cl_id;\r\ndata->rules[rule_idx].func_id = p->func_id;\r\ndata->rules[rule_idx].cmd_general_data =\r\nETH_FILTER_RULES_CMD_TX_CMD;\r\nbnx2x_rx_mode_set_cmd_state_e2(bp, &p->tx_accept_flags,\r\n&(data->rules[rule_idx++]),\r\nfalse);\r\n}\r\nif (test_bit(RAMROD_RX, &p->ramrod_flags)) {\r\ndata->rules[rule_idx].client_id = p->cl_id;\r\ndata->rules[rule_idx].func_id = p->func_id;\r\ndata->rules[rule_idx].cmd_general_data =\r\nETH_FILTER_RULES_CMD_RX_CMD;\r\nbnx2x_rx_mode_set_cmd_state_e2(bp, &p->rx_accept_flags,\r\n&(data->rules[rule_idx++]),\r\nfalse);\r\n}\r\nif (test_bit(BNX2X_RX_MODE_FCOE_ETH, &p->rx_mode_flags)) {\r\nif (test_bit(RAMROD_TX, &p->ramrod_flags)) {\r\ndata->rules[rule_idx].client_id = bnx2x_fcoe(bp, cl_id);\r\ndata->rules[rule_idx].func_id = p->func_id;\r\ndata->rules[rule_idx].cmd_general_data =\r\nETH_FILTER_RULES_CMD_TX_CMD;\r\nbnx2x_rx_mode_set_cmd_state_e2(bp, &p->tx_accept_flags,\r\n&(data->rules[rule_idx]),\r\ntrue);\r\nrule_idx++;\r\n}\r\nif (test_bit(RAMROD_RX, &p->ramrod_flags)) {\r\ndata->rules[rule_idx].client_id = bnx2x_fcoe(bp, cl_id);\r\ndata->rules[rule_idx].func_id = p->func_id;\r\ndata->rules[rule_idx].cmd_general_data =\r\nETH_FILTER_RULES_CMD_RX_CMD;\r\nbnx2x_rx_mode_set_cmd_state_e2(bp, &p->rx_accept_flags,\r\n&(data->rules[rule_idx]),\r\ntrue);\r\nrule_idx++;\r\n}\r\n}\r\nbnx2x_rx_mode_set_rdata_hdr_e2(p->cid, &data->header, rule_idx);\r\nDP(BNX2X_MSG_SP, "About to configure %d rules, rx_accept_flags 0x%lx, tx_accept_flags 0x%lx\n",\r\ndata->header.rule_cnt, p->rx_accept_flags,\r\np->tx_accept_flags);\r\nrc = bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_FILTER_RULES, p->cid,\r\nU64_HI(p->rdata_mapping),\r\nU64_LO(p->rdata_mapping),\r\nETH_CONNECTION_TYPE);\r\nif (rc)\r\nreturn rc;\r\nreturn 1;\r\n}\r\nstatic int bnx2x_wait_rx_mode_comp_e2(struct bnx2x *bp,\r\nstruct bnx2x_rx_mode_ramrod_params *p)\r\n{\r\nreturn bnx2x_state_wait(bp, p->state, p->pstate);\r\n}\r\nstatic int bnx2x_empty_rx_mode_wait(struct bnx2x *bp,\r\nstruct bnx2x_rx_mode_ramrod_params *p)\r\n{\r\nreturn 0;\r\n}\r\nint bnx2x_config_rx_mode(struct bnx2x *bp,\r\nstruct bnx2x_rx_mode_ramrod_params *p)\r\n{\r\nint rc;\r\nrc = p->rx_mode_obj->config_rx_mode(bp, p);\r\nif (rc < 0)\r\nreturn rc;\r\nif (test_bit(RAMROD_COMP_WAIT, &p->ramrod_flags)) {\r\nrc = p->rx_mode_obj->wait_comp(bp, p);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}\r\nvoid bnx2x_init_rx_mode_obj(struct bnx2x *bp,\r\nstruct bnx2x_rx_mode_obj *o)\r\n{\r\nif (CHIP_IS_E1x(bp)) {\r\no->wait_comp = bnx2x_empty_rx_mode_wait;\r\no->config_rx_mode = bnx2x_set_rx_mode_e1x;\r\n} else {\r\no->wait_comp = bnx2x_wait_rx_mode_comp_e2;\r\no->config_rx_mode = bnx2x_set_rx_mode_e2;\r\n}\r\n}\r\nstatic inline u8 bnx2x_mcast_bin_from_mac(u8 *mac)\r\n{\r\nreturn (crc32c_le(0, mac, ETH_ALEN) >> 24) & 0xff;\r\n}\r\nstatic int bnx2x_mcast_wait(struct bnx2x *bp,\r\nstruct bnx2x_mcast_obj *o)\r\n{\r\nif (bnx2x_state_wait(bp, o->sched_state, o->raw.pstate) ||\r\no->raw.wait_comp(bp, &o->raw))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int bnx2x_mcast_enqueue_cmd(struct bnx2x *bp,\r\nstruct bnx2x_mcast_obj *o,\r\nstruct bnx2x_mcast_ramrod_params *p,\r\nenum bnx2x_mcast_cmd cmd)\r\n{\r\nint total_sz;\r\nstruct bnx2x_pending_mcast_cmd *new_cmd;\r\nstruct bnx2x_mcast_mac_elem *cur_mac = NULL;\r\nstruct bnx2x_mcast_list_elem *pos;\r\nint macs_list_len = ((cmd == BNX2X_MCAST_CMD_ADD) ?\r\np->mcast_list_len : 0);\r\nif (!p->mcast_list_len)\r\nreturn 0;\r\ntotal_sz = sizeof(*new_cmd) +\r\nmacs_list_len * sizeof(struct bnx2x_mcast_mac_elem);\r\nnew_cmd = kzalloc(total_sz, GFP_ATOMIC);\r\nif (!new_cmd)\r\nreturn -ENOMEM;\r\nDP(BNX2X_MSG_SP, "About to enqueue a new %d command. macs_list_len=%d\n",\r\ncmd, macs_list_len);\r\nINIT_LIST_HEAD(&new_cmd->data.macs_head);\r\nnew_cmd->type = cmd;\r\nnew_cmd->done = false;\r\nswitch (cmd) {\r\ncase BNX2X_MCAST_CMD_ADD:\r\ncur_mac = (struct bnx2x_mcast_mac_elem *)\r\n((u8 *)new_cmd + sizeof(*new_cmd));\r\nlist_for_each_entry(pos, &p->mcast_list, link) {\r\nmemcpy(cur_mac->mac, pos->mac, ETH_ALEN);\r\nlist_add_tail(&cur_mac->link, &new_cmd->data.macs_head);\r\ncur_mac++;\r\n}\r\nbreak;\r\ncase BNX2X_MCAST_CMD_DEL:\r\nnew_cmd->data.macs_num = p->mcast_list_len;\r\nbreak;\r\ncase BNX2X_MCAST_CMD_RESTORE:\r\nnew_cmd->data.next_bin = 0;\r\nbreak;\r\ndefault:\r\nkfree(new_cmd);\r\nBNX2X_ERR("Unknown command: %d\n", cmd);\r\nreturn -EINVAL;\r\n}\r\nlist_add_tail(&new_cmd->link, &o->pending_cmds_head);\r\no->set_sched(o);\r\nreturn 1;\r\n}\r\nstatic inline int bnx2x_mcast_get_next_bin(struct bnx2x_mcast_obj *o, int last)\r\n{\r\nint i, j, inner_start = last % BIT_VEC64_ELEM_SZ;\r\nfor (i = last / BIT_VEC64_ELEM_SZ; i < BNX2X_MCAST_VEC_SZ; i++) {\r\nif (o->registry.aprox_match.vec[i])\r\nfor (j = inner_start; j < BIT_VEC64_ELEM_SZ; j++) {\r\nint cur_bit = j + BIT_VEC64_ELEM_SZ * i;\r\nif (BIT_VEC64_TEST_BIT(o->registry.aprox_match.\r\nvec, cur_bit)) {\r\nreturn cur_bit;\r\n}\r\n}\r\ninner_start = 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic inline int bnx2x_mcast_clear_first_bin(struct bnx2x_mcast_obj *o)\r\n{\r\nint cur_bit = bnx2x_mcast_get_next_bin(o, 0);\r\nif (cur_bit >= 0)\r\nBIT_VEC64_CLEAR_BIT(o->registry.aprox_match.vec, cur_bit);\r\nreturn cur_bit;\r\n}\r\nstatic inline u8 bnx2x_mcast_get_rx_tx_flag(struct bnx2x_mcast_obj *o)\r\n{\r\nstruct bnx2x_raw_obj *raw = &o->raw;\r\nu8 rx_tx_flag = 0;\r\nif ((raw->obj_type == BNX2X_OBJ_TYPE_TX) ||\r\n(raw->obj_type == BNX2X_OBJ_TYPE_RX_TX))\r\nrx_tx_flag |= ETH_MULTICAST_RULES_CMD_TX_CMD;\r\nif ((raw->obj_type == BNX2X_OBJ_TYPE_RX) ||\r\n(raw->obj_type == BNX2X_OBJ_TYPE_RX_TX))\r\nrx_tx_flag |= ETH_MULTICAST_RULES_CMD_RX_CMD;\r\nreturn rx_tx_flag;\r\n}\r\nstatic void bnx2x_mcast_set_one_rule_e2(struct bnx2x *bp,\r\nstruct bnx2x_mcast_obj *o, int idx,\r\nunion bnx2x_mcast_config_data *cfg_data,\r\nenum bnx2x_mcast_cmd cmd)\r\n{\r\nstruct bnx2x_raw_obj *r = &o->raw;\r\nstruct eth_multicast_rules_ramrod_data *data =\r\n(struct eth_multicast_rules_ramrod_data *)(r->rdata);\r\nu8 func_id = r->func_id;\r\nu8 rx_tx_add_flag = bnx2x_mcast_get_rx_tx_flag(o);\r\nint bin;\r\nif ((cmd == BNX2X_MCAST_CMD_ADD) || (cmd == BNX2X_MCAST_CMD_RESTORE))\r\nrx_tx_add_flag |= ETH_MULTICAST_RULES_CMD_IS_ADD;\r\ndata->rules[idx].cmd_general_data |= rx_tx_add_flag;\r\nswitch (cmd) {\r\ncase BNX2X_MCAST_CMD_ADD:\r\nbin = bnx2x_mcast_bin_from_mac(cfg_data->mac);\r\nBIT_VEC64_SET_BIT(o->registry.aprox_match.vec, bin);\r\nbreak;\r\ncase BNX2X_MCAST_CMD_DEL:\r\nbin = bnx2x_mcast_clear_first_bin(o);\r\nbreak;\r\ncase BNX2X_MCAST_CMD_RESTORE:\r\nbin = cfg_data->bin;\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Unknown command: %d\n", cmd);\r\nreturn;\r\n}\r\nDP(BNX2X_MSG_SP, "%s bin %d\n",\r\n((rx_tx_add_flag & ETH_MULTICAST_RULES_CMD_IS_ADD) ?\r\n"Setting" : "Clearing"), bin);\r\ndata->rules[idx].bin_id = (u8)bin;\r\ndata->rules[idx].func_id = func_id;\r\ndata->rules[idx].engine_id = o->engine_id;\r\n}\r\nstatic inline int bnx2x_mcast_handle_restore_cmd_e2(\r\nstruct bnx2x *bp, struct bnx2x_mcast_obj *o , int start_bin,\r\nint *rdata_idx)\r\n{\r\nint cur_bin, cnt = *rdata_idx;\r\nunion bnx2x_mcast_config_data cfg_data = {NULL};\r\nfor (cur_bin = bnx2x_mcast_get_next_bin(o, start_bin); cur_bin >= 0;\r\ncur_bin = bnx2x_mcast_get_next_bin(o, cur_bin + 1)) {\r\ncfg_data.bin = (u8)cur_bin;\r\no->set_one_rule(bp, o, cnt, &cfg_data,\r\nBNX2X_MCAST_CMD_RESTORE);\r\ncnt++;\r\nDP(BNX2X_MSG_SP, "About to configure a bin %d\n", cur_bin);\r\nif (cnt >= o->max_cmd_len)\r\nbreak;\r\n}\r\n*rdata_idx = cnt;\r\nreturn cur_bin;\r\n}\r\nstatic inline void bnx2x_mcast_hdl_pending_add_e2(struct bnx2x *bp,\r\nstruct bnx2x_mcast_obj *o, struct bnx2x_pending_mcast_cmd *cmd_pos,\r\nint *line_idx)\r\n{\r\nstruct bnx2x_mcast_mac_elem *pmac_pos, *pmac_pos_n;\r\nint cnt = *line_idx;\r\nunion bnx2x_mcast_config_data cfg_data = {NULL};\r\nlist_for_each_entry_safe(pmac_pos, pmac_pos_n, &cmd_pos->data.macs_head,\r\nlink) {\r\ncfg_data.mac = &pmac_pos->mac[0];\r\no->set_one_rule(bp, o, cnt, &cfg_data, cmd_pos->type);\r\ncnt++;\r\nDP(BNX2X_MSG_SP, "About to configure %pM mcast MAC\n",\r\npmac_pos->mac);\r\nlist_del(&pmac_pos->link);\r\nif (cnt >= o->max_cmd_len)\r\nbreak;\r\n}\r\n*line_idx = cnt;\r\nif (list_empty(&cmd_pos->data.macs_head))\r\ncmd_pos->done = true;\r\n}\r\nstatic inline void bnx2x_mcast_hdl_pending_del_e2(struct bnx2x *bp,\r\nstruct bnx2x_mcast_obj *o, struct bnx2x_pending_mcast_cmd *cmd_pos,\r\nint *line_idx)\r\n{\r\nint cnt = *line_idx;\r\nwhile (cmd_pos->data.macs_num) {\r\no->set_one_rule(bp, o, cnt, NULL, cmd_pos->type);\r\ncnt++;\r\ncmd_pos->data.macs_num--;\r\nDP(BNX2X_MSG_SP, "Deleting MAC. %d left,cnt is %d\n",\r\ncmd_pos->data.macs_num, cnt);\r\nif (cnt >= o->max_cmd_len)\r\nbreak;\r\n}\r\n*line_idx = cnt;\r\nif (!cmd_pos->data.macs_num)\r\ncmd_pos->done = true;\r\n}\r\nstatic inline void bnx2x_mcast_hdl_pending_restore_e2(struct bnx2x *bp,\r\nstruct bnx2x_mcast_obj *o, struct bnx2x_pending_mcast_cmd *cmd_pos,\r\nint *line_idx)\r\n{\r\ncmd_pos->data.next_bin = o->hdl_restore(bp, o, cmd_pos->data.next_bin,\r\nline_idx);\r\nif (cmd_pos->data.next_bin < 0)\r\ncmd_pos->done = true;\r\nelse\r\ncmd_pos->data.next_bin++;\r\n}\r\nstatic inline int bnx2x_mcast_handle_pending_cmds_e2(struct bnx2x *bp,\r\nstruct bnx2x_mcast_ramrod_params *p)\r\n{\r\nstruct bnx2x_pending_mcast_cmd *cmd_pos, *cmd_pos_n;\r\nint cnt = 0;\r\nstruct bnx2x_mcast_obj *o = p->mcast_obj;\r\nlist_for_each_entry_safe(cmd_pos, cmd_pos_n, &o->pending_cmds_head,\r\nlink) {\r\nswitch (cmd_pos->type) {\r\ncase BNX2X_MCAST_CMD_ADD:\r\nbnx2x_mcast_hdl_pending_add_e2(bp, o, cmd_pos, &cnt);\r\nbreak;\r\ncase BNX2X_MCAST_CMD_DEL:\r\nbnx2x_mcast_hdl_pending_del_e2(bp, o, cmd_pos, &cnt);\r\nbreak;\r\ncase BNX2X_MCAST_CMD_RESTORE:\r\nbnx2x_mcast_hdl_pending_restore_e2(bp, o, cmd_pos,\r\n&cnt);\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Unknown command: %d\n", cmd_pos->type);\r\nreturn -EINVAL;\r\n}\r\nif (cmd_pos->done) {\r\nlist_del(&cmd_pos->link);\r\nkfree(cmd_pos);\r\n}\r\nif (cnt >= o->max_cmd_len)\r\nbreak;\r\n}\r\nreturn cnt;\r\n}\r\nstatic inline void bnx2x_mcast_hdl_add(struct bnx2x *bp,\r\nstruct bnx2x_mcast_obj *o, struct bnx2x_mcast_ramrod_params *p,\r\nint *line_idx)\r\n{\r\nstruct bnx2x_mcast_list_elem *mlist_pos;\r\nunion bnx2x_mcast_config_data cfg_data = {NULL};\r\nint cnt = *line_idx;\r\nlist_for_each_entry(mlist_pos, &p->mcast_list, link) {\r\ncfg_data.mac = mlist_pos->mac;\r\no->set_one_rule(bp, o, cnt, &cfg_data, BNX2X_MCAST_CMD_ADD);\r\ncnt++;\r\nDP(BNX2X_MSG_SP, "About to configure %pM mcast MAC\n",\r\nmlist_pos->mac);\r\n}\r\n*line_idx = cnt;\r\n}\r\nstatic inline void bnx2x_mcast_hdl_del(struct bnx2x *bp,\r\nstruct bnx2x_mcast_obj *o, struct bnx2x_mcast_ramrod_params *p,\r\nint *line_idx)\r\n{\r\nint cnt = *line_idx, i;\r\nfor (i = 0; i < p->mcast_list_len; i++) {\r\no->set_one_rule(bp, o, cnt, NULL, BNX2X_MCAST_CMD_DEL);\r\ncnt++;\r\nDP(BNX2X_MSG_SP, "Deleting MAC. %d left\n",\r\np->mcast_list_len - i - 1);\r\n}\r\n*line_idx = cnt;\r\n}\r\nstatic inline int bnx2x_mcast_handle_current_cmd(struct bnx2x *bp,\r\nstruct bnx2x_mcast_ramrod_params *p,\r\nenum bnx2x_mcast_cmd cmd,\r\nint start_cnt)\r\n{\r\nstruct bnx2x_mcast_obj *o = p->mcast_obj;\r\nint cnt = start_cnt;\r\nDP(BNX2X_MSG_SP, "p->mcast_list_len=%d\n", p->mcast_list_len);\r\nswitch (cmd) {\r\ncase BNX2X_MCAST_CMD_ADD:\r\nbnx2x_mcast_hdl_add(bp, o, p, &cnt);\r\nbreak;\r\ncase BNX2X_MCAST_CMD_DEL:\r\nbnx2x_mcast_hdl_del(bp, o, p, &cnt);\r\nbreak;\r\ncase BNX2X_MCAST_CMD_RESTORE:\r\no->hdl_restore(bp, o, 0, &cnt);\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Unknown command: %d\n", cmd);\r\nreturn -EINVAL;\r\n}\r\np->mcast_list_len = 0;\r\nreturn cnt;\r\n}\r\nstatic int bnx2x_mcast_validate_e2(struct bnx2x *bp,\r\nstruct bnx2x_mcast_ramrod_params *p,\r\nenum bnx2x_mcast_cmd cmd)\r\n{\r\nstruct bnx2x_mcast_obj *o = p->mcast_obj;\r\nint reg_sz = o->get_registry_size(o);\r\nswitch (cmd) {\r\ncase BNX2X_MCAST_CMD_DEL:\r\no->set_registry_size(o, 0);\r\ncase BNX2X_MCAST_CMD_RESTORE:\r\np->mcast_list_len = reg_sz;\r\nbreak;\r\ncase BNX2X_MCAST_CMD_ADD:\r\ncase BNX2X_MCAST_CMD_CONT:\r\no->set_registry_size(o, reg_sz + p->mcast_list_len);\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Unknown command: %d\n", cmd);\r\nreturn -EINVAL;\r\n}\r\no->total_pending_num += p->mcast_list_len;\r\nreturn 0;\r\n}\r\nstatic void bnx2x_mcast_revert_e2(struct bnx2x *bp,\r\nstruct bnx2x_mcast_ramrod_params *p,\r\nint old_num_bins)\r\n{\r\nstruct bnx2x_mcast_obj *o = p->mcast_obj;\r\no->set_registry_size(o, old_num_bins);\r\no->total_pending_num -= p->mcast_list_len;\r\n}\r\nstatic inline void bnx2x_mcast_set_rdata_hdr_e2(struct bnx2x *bp,\r\nstruct bnx2x_mcast_ramrod_params *p,\r\nu8 len)\r\n{\r\nstruct bnx2x_raw_obj *r = &p->mcast_obj->raw;\r\nstruct eth_multicast_rules_ramrod_data *data =\r\n(struct eth_multicast_rules_ramrod_data *)(r->rdata);\r\ndata->header.echo = cpu_to_le32((r->cid & BNX2X_SWCID_MASK) |\r\n(BNX2X_FILTER_MCAST_PENDING <<\r\nBNX2X_SWCID_SHIFT));\r\ndata->header.rule_cnt = len;\r\n}\r\nstatic inline int bnx2x_mcast_refresh_registry_e2(struct bnx2x *bp,\r\nstruct bnx2x_mcast_obj *o)\r\n{\r\nint i, cnt = 0;\r\nu64 elem;\r\nfor (i = 0; i < BNX2X_MCAST_VEC_SZ; i++) {\r\nelem = o->registry.aprox_match.vec[i];\r\nfor (; elem; cnt++)\r\nelem &= elem - 1;\r\n}\r\no->set_registry_size(o, cnt);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_mcast_setup_e2(struct bnx2x *bp,\r\nstruct bnx2x_mcast_ramrod_params *p,\r\nenum bnx2x_mcast_cmd cmd)\r\n{\r\nstruct bnx2x_raw_obj *raw = &p->mcast_obj->raw;\r\nstruct bnx2x_mcast_obj *o = p->mcast_obj;\r\nstruct eth_multicast_rules_ramrod_data *data =\r\n(struct eth_multicast_rules_ramrod_data *)(raw->rdata);\r\nint cnt = 0, rc;\r\nmemset(data, 0, sizeof(*data));\r\ncnt = bnx2x_mcast_handle_pending_cmds_e2(bp, p);\r\nif (list_empty(&o->pending_cmds_head))\r\no->clear_sched(o);\r\nif (p->mcast_list_len > 0)\r\ncnt = bnx2x_mcast_handle_current_cmd(bp, p, cmd, cnt);\r\no->total_pending_num -= cnt;\r\nWARN_ON(o->total_pending_num < 0);\r\nWARN_ON(cnt > o->max_cmd_len);\r\nbnx2x_mcast_set_rdata_hdr_e2(bp, p, (u8)cnt);\r\nif (!o->total_pending_num)\r\nbnx2x_mcast_refresh_registry_e2(bp, o);\r\nif (test_bit(RAMROD_DRV_CLR_ONLY, &p->ramrod_flags)) {\r\nraw->clear_pending(raw);\r\nreturn 0;\r\n} else {\r\nrc = bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_MULTICAST_RULES,\r\nraw->cid, U64_HI(raw->rdata_mapping),\r\nU64_LO(raw->rdata_mapping),\r\nETH_CONNECTION_TYPE);\r\nif (rc)\r\nreturn rc;\r\nreturn 1;\r\n}\r\n}\r\nstatic int bnx2x_mcast_validate_e1h(struct bnx2x *bp,\r\nstruct bnx2x_mcast_ramrod_params *p,\r\nenum bnx2x_mcast_cmd cmd)\r\n{\r\nif ((cmd == BNX2X_MCAST_CMD_DEL) || (cmd == BNX2X_MCAST_CMD_RESTORE))\r\np->mcast_list_len = 1;\r\nreturn 0;\r\n}\r\nstatic void bnx2x_mcast_revert_e1h(struct bnx2x *bp,\r\nstruct bnx2x_mcast_ramrod_params *p,\r\nint old_num_bins)\r\n{\r\n}\r\nstatic inline void bnx2x_mcast_hdl_add_e1h(struct bnx2x *bp,\r\nstruct bnx2x_mcast_obj *o,\r\nstruct bnx2x_mcast_ramrod_params *p,\r\nu32 *mc_filter)\r\n{\r\nstruct bnx2x_mcast_list_elem *mlist_pos;\r\nint bit;\r\nlist_for_each_entry(mlist_pos, &p->mcast_list, link) {\r\nbit = bnx2x_mcast_bin_from_mac(mlist_pos->mac);\r\nBNX2X_57711_SET_MC_FILTER(mc_filter, bit);\r\nDP(BNX2X_MSG_SP, "About to configure %pM mcast MAC, bin %d\n",\r\nmlist_pos->mac, bit);\r\nBIT_VEC64_SET_BIT(o->registry.aprox_match.vec,\r\nbit);\r\n}\r\n}\r\nstatic inline void bnx2x_mcast_hdl_restore_e1h(struct bnx2x *bp,\r\nstruct bnx2x_mcast_obj *o, struct bnx2x_mcast_ramrod_params *p,\r\nu32 *mc_filter)\r\n{\r\nint bit;\r\nfor (bit = bnx2x_mcast_get_next_bin(o, 0);\r\nbit >= 0;\r\nbit = bnx2x_mcast_get_next_bin(o, bit + 1)) {\r\nBNX2X_57711_SET_MC_FILTER(mc_filter, bit);\r\nDP(BNX2X_MSG_SP, "About to set bin %d\n", bit);\r\n}\r\n}\r\nstatic int bnx2x_mcast_setup_e1h(struct bnx2x *bp,\r\nstruct bnx2x_mcast_ramrod_params *p,\r\nenum bnx2x_mcast_cmd cmd)\r\n{\r\nint i;\r\nstruct bnx2x_mcast_obj *o = p->mcast_obj;\r\nstruct bnx2x_raw_obj *r = &o->raw;\r\nif (!test_bit(RAMROD_DRV_CLR_ONLY, &p->ramrod_flags)) {\r\nu32 mc_filter[MC_HASH_SIZE] = {0};\r\nswitch (cmd) {\r\ncase BNX2X_MCAST_CMD_ADD:\r\nbnx2x_mcast_hdl_add_e1h(bp, o, p, mc_filter);\r\nbreak;\r\ncase BNX2X_MCAST_CMD_DEL:\r\nDP(BNX2X_MSG_SP,\r\n"Invalidating multicast MACs configuration\n");\r\nmemset(o->registry.aprox_match.vec, 0,\r\nsizeof(o->registry.aprox_match.vec));\r\nbreak;\r\ncase BNX2X_MCAST_CMD_RESTORE:\r\nbnx2x_mcast_hdl_restore_e1h(bp, o, p, mc_filter);\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Unknown command: %d\n", cmd);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < MC_HASH_SIZE; i++)\r\nREG_WR(bp, MC_HASH_OFFSET(bp, i), mc_filter[i]);\r\n} else\r\nmemset(o->registry.aprox_match.vec, 0,\r\nsizeof(o->registry.aprox_match.vec));\r\nr->clear_pending(r);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_mcast_validate_e1(struct bnx2x *bp,\r\nstruct bnx2x_mcast_ramrod_params *p,\r\nenum bnx2x_mcast_cmd cmd)\r\n{\r\nstruct bnx2x_mcast_obj *o = p->mcast_obj;\r\nint reg_sz = o->get_registry_size(o);\r\nswitch (cmd) {\r\ncase BNX2X_MCAST_CMD_DEL:\r\no->set_registry_size(o, 0);\r\ncase BNX2X_MCAST_CMD_RESTORE:\r\np->mcast_list_len = reg_sz;\r\nDP(BNX2X_MSG_SP, "Command %d, p->mcast_list_len=%d\n",\r\ncmd, p->mcast_list_len);\r\nbreak;\r\ncase BNX2X_MCAST_CMD_ADD:\r\ncase BNX2X_MCAST_CMD_CONT:\r\nif (p->mcast_list_len > o->max_cmd_len) {\r\nBNX2X_ERR("Can't configure more than %d multicast MACs on 57710\n",\r\no->max_cmd_len);\r\nreturn -EINVAL;\r\n}\r\nDP(BNX2X_MSG_SP, "p->mcast_list_len=%d\n", p->mcast_list_len);\r\nif (p->mcast_list_len > 0)\r\no->set_registry_size(o, p->mcast_list_len);\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Unknown command: %d\n", cmd);\r\nreturn -EINVAL;\r\n}\r\nif (p->mcast_list_len)\r\no->total_pending_num += o->max_cmd_len;\r\nreturn 0;\r\n}\r\nstatic void bnx2x_mcast_revert_e1(struct bnx2x *bp,\r\nstruct bnx2x_mcast_ramrod_params *p,\r\nint old_num_macs)\r\n{\r\nstruct bnx2x_mcast_obj *o = p->mcast_obj;\r\no->set_registry_size(o, old_num_macs);\r\nif (p->mcast_list_len)\r\no->total_pending_num -= o->max_cmd_len;\r\n}\r\nstatic void bnx2x_mcast_set_one_rule_e1(struct bnx2x *bp,\r\nstruct bnx2x_mcast_obj *o, int idx,\r\nunion bnx2x_mcast_config_data *cfg_data,\r\nenum bnx2x_mcast_cmd cmd)\r\n{\r\nstruct bnx2x_raw_obj *r = &o->raw;\r\nstruct mac_configuration_cmd *data =\r\n(struct mac_configuration_cmd *)(r->rdata);\r\nif ((cmd == BNX2X_MCAST_CMD_ADD) || (cmd == BNX2X_MCAST_CMD_RESTORE)) {\r\nbnx2x_set_fw_mac_addr(&data->config_table[idx].msb_mac_addr,\r\n&data->config_table[idx].middle_mac_addr,\r\n&data->config_table[idx].lsb_mac_addr,\r\ncfg_data->mac);\r\ndata->config_table[idx].vlan_id = 0;\r\ndata->config_table[idx].pf_id = r->func_id;\r\ndata->config_table[idx].clients_bit_vector =\r\ncpu_to_le32(1 << r->cl_id);\r\nSET_FLAG(data->config_table[idx].flags,\r\nMAC_CONFIGURATION_ENTRY_ACTION_TYPE,\r\nT_ETH_MAC_COMMAND_SET);\r\n}\r\n}\r\nstatic inline void bnx2x_mcast_set_rdata_hdr_e1(struct bnx2x *bp,\r\nstruct bnx2x_mcast_ramrod_params *p,\r\nu8 len)\r\n{\r\nstruct bnx2x_raw_obj *r = &p->mcast_obj->raw;\r\nstruct mac_configuration_cmd *data =\r\n(struct mac_configuration_cmd *)(r->rdata);\r\nu8 offset = (CHIP_REV_IS_SLOW(bp) ?\r\nBNX2X_MAX_EMUL_MULTI*(1 + r->func_id) :\r\nBNX2X_MAX_MULTICAST*(1 + r->func_id));\r\ndata->hdr.offset = offset;\r\ndata->hdr.client_id = cpu_to_le16(0xff);\r\ndata->hdr.echo = cpu_to_le32((r->cid & BNX2X_SWCID_MASK) |\r\n(BNX2X_FILTER_MCAST_PENDING <<\r\nBNX2X_SWCID_SHIFT));\r\ndata->hdr.length = len;\r\n}\r\nstatic inline int bnx2x_mcast_handle_restore_cmd_e1(\r\nstruct bnx2x *bp, struct bnx2x_mcast_obj *o , int start_idx,\r\nint *rdata_idx)\r\n{\r\nstruct bnx2x_mcast_mac_elem *elem;\r\nint i = 0;\r\nunion bnx2x_mcast_config_data cfg_data = {NULL};\r\nlist_for_each_entry(elem, &o->registry.exact_match.macs, link) {\r\ncfg_data.mac = &elem->mac[0];\r\no->set_one_rule(bp, o, i, &cfg_data, BNX2X_MCAST_CMD_RESTORE);\r\ni++;\r\nDP(BNX2X_MSG_SP, "About to configure %pM mcast MAC\n",\r\ncfg_data.mac);\r\n}\r\n*rdata_idx = i;\r\nreturn -1;\r\n}\r\nstatic inline int bnx2x_mcast_handle_pending_cmds_e1(\r\nstruct bnx2x *bp, struct bnx2x_mcast_ramrod_params *p)\r\n{\r\nstruct bnx2x_pending_mcast_cmd *cmd_pos;\r\nstruct bnx2x_mcast_mac_elem *pmac_pos;\r\nstruct bnx2x_mcast_obj *o = p->mcast_obj;\r\nunion bnx2x_mcast_config_data cfg_data = {NULL};\r\nint cnt = 0;\r\nif (list_empty(&o->pending_cmds_head))\r\nreturn 0;\r\ncmd_pos = list_first_entry(&o->pending_cmds_head,\r\nstruct bnx2x_pending_mcast_cmd, link);\r\nswitch (cmd_pos->type) {\r\ncase BNX2X_MCAST_CMD_ADD:\r\nlist_for_each_entry(pmac_pos, &cmd_pos->data.macs_head, link) {\r\ncfg_data.mac = &pmac_pos->mac[0];\r\no->set_one_rule(bp, o, cnt, &cfg_data, cmd_pos->type);\r\ncnt++;\r\nDP(BNX2X_MSG_SP, "About to configure %pM mcast MAC\n",\r\npmac_pos->mac);\r\n}\r\nbreak;\r\ncase BNX2X_MCAST_CMD_DEL:\r\ncnt = cmd_pos->data.macs_num;\r\nDP(BNX2X_MSG_SP, "About to delete %d multicast MACs\n", cnt);\r\nbreak;\r\ncase BNX2X_MCAST_CMD_RESTORE:\r\no->hdl_restore(bp, o, 0, &cnt);\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Unknown command: %d\n", cmd_pos->type);\r\nreturn -EINVAL;\r\n}\r\nlist_del(&cmd_pos->link);\r\nkfree(cmd_pos);\r\nreturn cnt;\r\n}\r\nstatic inline void bnx2x_get_fw_mac_addr(__le16 *fw_hi, __le16 *fw_mid,\r\n__le16 *fw_lo, u8 *mac)\r\n{\r\nmac[1] = ((u8 *)fw_hi)[0];\r\nmac[0] = ((u8 *)fw_hi)[1];\r\nmac[3] = ((u8 *)fw_mid)[0];\r\nmac[2] = ((u8 *)fw_mid)[1];\r\nmac[5] = ((u8 *)fw_lo)[0];\r\nmac[4] = ((u8 *)fw_lo)[1];\r\n}\r\nstatic inline int bnx2x_mcast_refresh_registry_e1(struct bnx2x *bp,\r\nstruct bnx2x_mcast_obj *o)\r\n{\r\nstruct bnx2x_raw_obj *raw = &o->raw;\r\nstruct bnx2x_mcast_mac_elem *elem;\r\nstruct mac_configuration_cmd *data =\r\n(struct mac_configuration_cmd *)(raw->rdata);\r\nif (GET_FLAG(data->config_table[0].flags,\r\nMAC_CONFIGURATION_ENTRY_ACTION_TYPE)) {\r\nint i, len = data->hdr.length;\r\nif (!list_empty(&o->registry.exact_match.macs))\r\nreturn 0;\r\nelem = kcalloc(len, sizeof(*elem), GFP_ATOMIC);\r\nif (!elem) {\r\nBNX2X_ERR("Failed to allocate registry memory\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < len; i++, elem++) {\r\nbnx2x_get_fw_mac_addr(\r\n&data->config_table[i].msb_mac_addr,\r\n&data->config_table[i].middle_mac_addr,\r\n&data->config_table[i].lsb_mac_addr,\r\nelem->mac);\r\nDP(BNX2X_MSG_SP, "Adding registry entry for [%pM]\n",\r\nelem->mac);\r\nlist_add_tail(&elem->link,\r\n&o->registry.exact_match.macs);\r\n}\r\n} else {\r\nelem = list_first_entry(&o->registry.exact_match.macs,\r\nstruct bnx2x_mcast_mac_elem, link);\r\nDP(BNX2X_MSG_SP, "Deleting a registry\n");\r\nkfree(elem);\r\nINIT_LIST_HEAD(&o->registry.exact_match.macs);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_mcast_setup_e1(struct bnx2x *bp,\r\nstruct bnx2x_mcast_ramrod_params *p,\r\nenum bnx2x_mcast_cmd cmd)\r\n{\r\nstruct bnx2x_mcast_obj *o = p->mcast_obj;\r\nstruct bnx2x_raw_obj *raw = &o->raw;\r\nstruct mac_configuration_cmd *data =\r\n(struct mac_configuration_cmd *)(raw->rdata);\r\nint cnt = 0, i, rc;\r\nmemset(data, 0, sizeof(*data));\r\nfor (i = 0; i < o->max_cmd_len ; i++)\r\nSET_FLAG(data->config_table[i].flags,\r\nMAC_CONFIGURATION_ENTRY_ACTION_TYPE,\r\nT_ETH_MAC_COMMAND_INVALIDATE);\r\ncnt = bnx2x_mcast_handle_pending_cmds_e1(bp, p);\r\nif (list_empty(&o->pending_cmds_head))\r\no->clear_sched(o);\r\nif (!cnt)\r\ncnt = bnx2x_mcast_handle_current_cmd(bp, p, cmd, 0);\r\no->total_pending_num -= o->max_cmd_len;\r\nWARN_ON(cnt > o->max_cmd_len);\r\nbnx2x_mcast_set_rdata_hdr_e1(bp, p, (u8)cnt);\r\nrc = bnx2x_mcast_refresh_registry_e1(bp, o);\r\nif (rc)\r\nreturn rc;\r\nif (test_bit(RAMROD_DRV_CLR_ONLY, &p->ramrod_flags)) {\r\nraw->clear_pending(raw);\r\nreturn 0;\r\n} else {\r\nrc = bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_SET_MAC, raw->cid,\r\nU64_HI(raw->rdata_mapping),\r\nU64_LO(raw->rdata_mapping),\r\nETH_CONNECTION_TYPE);\r\nif (rc)\r\nreturn rc;\r\nreturn 1;\r\n}\r\n}\r\nstatic int bnx2x_mcast_get_registry_size_exact(struct bnx2x_mcast_obj *o)\r\n{\r\nreturn o->registry.exact_match.num_macs_set;\r\n}\r\nstatic int bnx2x_mcast_get_registry_size_aprox(struct bnx2x_mcast_obj *o)\r\n{\r\nreturn o->registry.aprox_match.num_bins_set;\r\n}\r\nstatic void bnx2x_mcast_set_registry_size_exact(struct bnx2x_mcast_obj *o,\r\nint n)\r\n{\r\no->registry.exact_match.num_macs_set = n;\r\n}\r\nstatic void bnx2x_mcast_set_registry_size_aprox(struct bnx2x_mcast_obj *o,\r\nint n)\r\n{\r\no->registry.aprox_match.num_bins_set = n;\r\n}\r\nint bnx2x_config_mcast(struct bnx2x *bp,\r\nstruct bnx2x_mcast_ramrod_params *p,\r\nenum bnx2x_mcast_cmd cmd)\r\n{\r\nstruct bnx2x_mcast_obj *o = p->mcast_obj;\r\nstruct bnx2x_raw_obj *r = &o->raw;\r\nint rc = 0, old_reg_size;\r\nold_reg_size = o->get_registry_size(o);\r\nrc = o->validate(bp, p, cmd);\r\nif (rc)\r\nreturn rc;\r\nif ((!p->mcast_list_len) && (!o->check_sched(o)))\r\nreturn 0;\r\nDP(BNX2X_MSG_SP, "o->total_pending_num=%d p->mcast_list_len=%d o->max_cmd_len=%d\n",\r\no->total_pending_num, p->mcast_list_len, o->max_cmd_len);\r\nif (r->check_pending(r) ||\r\n((o->max_cmd_len > 0) && (o->total_pending_num > o->max_cmd_len))) {\r\nrc = o->enqueue_cmd(bp, p->mcast_obj, p, cmd);\r\nif (rc < 0)\r\ngoto error_exit1;\r\np->mcast_list_len = 0;\r\n}\r\nif (!r->check_pending(r)) {\r\nr->set_pending(r);\r\nrc = o->config_mcast(bp, p, cmd);\r\nif (rc < 0)\r\ngoto error_exit2;\r\nif (test_bit(RAMROD_COMP_WAIT, &p->ramrod_flags))\r\nrc = o->wait_comp(bp, o);\r\n}\r\nreturn rc;\r\nerror_exit2:\r\nr->clear_pending(r);\r\nerror_exit1:\r\no->revert(bp, p, old_reg_size);\r\nreturn rc;\r\n}\r\nstatic void bnx2x_mcast_clear_sched(struct bnx2x_mcast_obj *o)\r\n{\r\nsmp_mb__before_atomic();\r\nclear_bit(o->sched_state, o->raw.pstate);\r\nsmp_mb__after_atomic();\r\n}\r\nstatic void bnx2x_mcast_set_sched(struct bnx2x_mcast_obj *o)\r\n{\r\nsmp_mb__before_atomic();\r\nset_bit(o->sched_state, o->raw.pstate);\r\nsmp_mb__after_atomic();\r\n}\r\nstatic bool bnx2x_mcast_check_sched(struct bnx2x_mcast_obj *o)\r\n{\r\nreturn !!test_bit(o->sched_state, o->raw.pstate);\r\n}\r\nstatic bool bnx2x_mcast_check_pending(struct bnx2x_mcast_obj *o)\r\n{\r\nreturn o->raw.check_pending(&o->raw) || o->check_sched(o);\r\n}\r\nvoid bnx2x_init_mcast_obj(struct bnx2x *bp,\r\nstruct bnx2x_mcast_obj *mcast_obj,\r\nu8 mcast_cl_id, u32 mcast_cid, u8 func_id,\r\nu8 engine_id, void *rdata, dma_addr_t rdata_mapping,\r\nint state, unsigned long *pstate, bnx2x_obj_type type)\r\n{\r\nmemset(mcast_obj, 0, sizeof(*mcast_obj));\r\nbnx2x_init_raw_obj(&mcast_obj->raw, mcast_cl_id, mcast_cid, func_id,\r\nrdata, rdata_mapping, state, pstate, type);\r\nmcast_obj->engine_id = engine_id;\r\nINIT_LIST_HEAD(&mcast_obj->pending_cmds_head);\r\nmcast_obj->sched_state = BNX2X_FILTER_MCAST_SCHED;\r\nmcast_obj->check_sched = bnx2x_mcast_check_sched;\r\nmcast_obj->set_sched = bnx2x_mcast_set_sched;\r\nmcast_obj->clear_sched = bnx2x_mcast_clear_sched;\r\nif (CHIP_IS_E1(bp)) {\r\nmcast_obj->config_mcast = bnx2x_mcast_setup_e1;\r\nmcast_obj->enqueue_cmd = bnx2x_mcast_enqueue_cmd;\r\nmcast_obj->hdl_restore =\r\nbnx2x_mcast_handle_restore_cmd_e1;\r\nmcast_obj->check_pending = bnx2x_mcast_check_pending;\r\nif (CHIP_REV_IS_SLOW(bp))\r\nmcast_obj->max_cmd_len = BNX2X_MAX_EMUL_MULTI;\r\nelse\r\nmcast_obj->max_cmd_len = BNX2X_MAX_MULTICAST;\r\nmcast_obj->wait_comp = bnx2x_mcast_wait;\r\nmcast_obj->set_one_rule = bnx2x_mcast_set_one_rule_e1;\r\nmcast_obj->validate = bnx2x_mcast_validate_e1;\r\nmcast_obj->revert = bnx2x_mcast_revert_e1;\r\nmcast_obj->get_registry_size =\r\nbnx2x_mcast_get_registry_size_exact;\r\nmcast_obj->set_registry_size =\r\nbnx2x_mcast_set_registry_size_exact;\r\nINIT_LIST_HEAD(&mcast_obj->registry.exact_match.macs);\r\n} else if (CHIP_IS_E1H(bp)) {\r\nmcast_obj->config_mcast = bnx2x_mcast_setup_e1h;\r\nmcast_obj->enqueue_cmd = NULL;\r\nmcast_obj->hdl_restore = NULL;\r\nmcast_obj->check_pending = bnx2x_mcast_check_pending;\r\nmcast_obj->max_cmd_len = -1;\r\nmcast_obj->wait_comp = bnx2x_mcast_wait;\r\nmcast_obj->set_one_rule = NULL;\r\nmcast_obj->validate = bnx2x_mcast_validate_e1h;\r\nmcast_obj->revert = bnx2x_mcast_revert_e1h;\r\nmcast_obj->get_registry_size =\r\nbnx2x_mcast_get_registry_size_aprox;\r\nmcast_obj->set_registry_size =\r\nbnx2x_mcast_set_registry_size_aprox;\r\n} else {\r\nmcast_obj->config_mcast = bnx2x_mcast_setup_e2;\r\nmcast_obj->enqueue_cmd = bnx2x_mcast_enqueue_cmd;\r\nmcast_obj->hdl_restore =\r\nbnx2x_mcast_handle_restore_cmd_e2;\r\nmcast_obj->check_pending = bnx2x_mcast_check_pending;\r\nmcast_obj->max_cmd_len = 16;\r\nmcast_obj->wait_comp = bnx2x_mcast_wait;\r\nmcast_obj->set_one_rule = bnx2x_mcast_set_one_rule_e2;\r\nmcast_obj->validate = bnx2x_mcast_validate_e2;\r\nmcast_obj->revert = bnx2x_mcast_revert_e2;\r\nmcast_obj->get_registry_size =\r\nbnx2x_mcast_get_registry_size_aprox;\r\nmcast_obj->set_registry_size =\r\nbnx2x_mcast_set_registry_size_aprox;\r\n}\r\n}\r\nstatic inline bool __atomic_add_ifless(atomic_t *v, int a, int u)\r\n{\r\nint c, old;\r\nc = atomic_read(v);\r\nfor (;;) {\r\nif (unlikely(c + a >= u))\r\nreturn false;\r\nold = atomic_cmpxchg((v), c, c + a);\r\nif (likely(old == c))\r\nbreak;\r\nc = old;\r\n}\r\nreturn true;\r\n}\r\nstatic inline bool __atomic_dec_ifmoe(atomic_t *v, int a, int u)\r\n{\r\nint c, old;\r\nc = atomic_read(v);\r\nfor (;;) {\r\nif (unlikely(c - a < u))\r\nreturn false;\r\nold = atomic_cmpxchg((v), c, c - a);\r\nif (likely(old == c))\r\nbreak;\r\nc = old;\r\n}\r\nreturn true;\r\n}\r\nstatic bool bnx2x_credit_pool_get(struct bnx2x_credit_pool_obj *o, int cnt)\r\n{\r\nbool rc;\r\nsmp_mb();\r\nrc = __atomic_dec_ifmoe(&o->credit, cnt, 0);\r\nsmp_mb();\r\nreturn rc;\r\n}\r\nstatic bool bnx2x_credit_pool_put(struct bnx2x_credit_pool_obj *o, int cnt)\r\n{\r\nbool rc;\r\nsmp_mb();\r\nrc = __atomic_add_ifless(&o->credit, cnt, o->pool_sz + 1);\r\nsmp_mb();\r\nreturn rc;\r\n}\r\nstatic int bnx2x_credit_pool_check(struct bnx2x_credit_pool_obj *o)\r\n{\r\nint cur_credit;\r\nsmp_mb();\r\ncur_credit = atomic_read(&o->credit);\r\nreturn cur_credit;\r\n}\r\nstatic bool bnx2x_credit_pool_always_true(struct bnx2x_credit_pool_obj *o,\r\nint cnt)\r\n{\r\nreturn true;\r\n}\r\nstatic bool bnx2x_credit_pool_get_entry(\r\nstruct bnx2x_credit_pool_obj *o,\r\nint *offset)\r\n{\r\nint idx, vec, i;\r\n*offset = -1;\r\nfor (vec = 0; vec < BNX2X_POOL_VEC_SIZE; vec++) {\r\nif (!o->pool_mirror[vec])\r\ncontinue;\r\nfor (idx = vec * BIT_VEC64_ELEM_SZ, i = 0;\r\ni < BIT_VEC64_ELEM_SZ; idx++, i++)\r\nif (BIT_VEC64_TEST_BIT(o->pool_mirror, idx)) {\r\nBIT_VEC64_CLEAR_BIT(o->pool_mirror, idx);\r\n*offset = o->base_pool_offset + idx;\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic bool bnx2x_credit_pool_put_entry(\r\nstruct bnx2x_credit_pool_obj *o,\r\nint offset)\r\n{\r\nif (offset < o->base_pool_offset)\r\nreturn false;\r\noffset -= o->base_pool_offset;\r\nif (offset >= o->pool_sz)\r\nreturn false;\r\nBIT_VEC64_SET_BIT(o->pool_mirror, offset);\r\nreturn true;\r\n}\r\nstatic bool bnx2x_credit_pool_put_entry_always_true(\r\nstruct bnx2x_credit_pool_obj *o,\r\nint offset)\r\n{\r\nreturn true;\r\n}\r\nstatic bool bnx2x_credit_pool_get_entry_always_true(\r\nstruct bnx2x_credit_pool_obj *o,\r\nint *offset)\r\n{\r\n*offset = -1;\r\nreturn true;\r\n}\r\nvoid bnx2x_init_credit_pool(struct bnx2x_credit_pool_obj *p,\r\nint base, int credit)\r\n{\r\nmemset(p, 0, sizeof(*p));\r\nmemset(&p->pool_mirror, 0xff, sizeof(p->pool_mirror));\r\natomic_set(&p->credit, credit);\r\np->pool_sz = credit;\r\np->base_pool_offset = base;\r\nsmp_mb();\r\np->check = bnx2x_credit_pool_check;\r\nif (credit >= 0) {\r\np->put = bnx2x_credit_pool_put;\r\np->get = bnx2x_credit_pool_get;\r\np->put_entry = bnx2x_credit_pool_put_entry;\r\np->get_entry = bnx2x_credit_pool_get_entry;\r\n} else {\r\np->put = bnx2x_credit_pool_always_true;\r\np->get = bnx2x_credit_pool_always_true;\r\np->put_entry = bnx2x_credit_pool_put_entry_always_true;\r\np->get_entry = bnx2x_credit_pool_get_entry_always_true;\r\n}\r\nif (base < 0) {\r\np->put_entry = bnx2x_credit_pool_put_entry_always_true;\r\np->get_entry = bnx2x_credit_pool_get_entry_always_true;\r\n}\r\n}\r\nvoid bnx2x_init_mac_credit_pool(struct bnx2x *bp,\r\nstruct bnx2x_credit_pool_obj *p, u8 func_id,\r\nu8 func_num)\r\n{\r\n#define BNX2X_CAM_SIZE_EMUL 5\r\nint cam_sz;\r\nif (CHIP_IS_E1(bp)) {\r\nif (!CHIP_REV_IS_SLOW(bp))\r\ncam_sz = (MAX_MAC_CREDIT_E1 / 2) - BNX2X_MAX_MULTICAST;\r\nelse\r\ncam_sz = BNX2X_CAM_SIZE_EMUL - BNX2X_MAX_EMUL_MULTI;\r\nbnx2x_init_credit_pool(p, func_id * cam_sz, cam_sz);\r\n} else if (CHIP_IS_E1H(bp)) {\r\nif ((func_num > 0)) {\r\nif (!CHIP_REV_IS_SLOW(bp))\r\ncam_sz = (MAX_MAC_CREDIT_E1H / (2*func_num));\r\nelse\r\ncam_sz = BNX2X_CAM_SIZE_EMUL;\r\nbnx2x_init_credit_pool(p, func_id * cam_sz, cam_sz);\r\n} else {\r\nbnx2x_init_credit_pool(p, 0, 0);\r\n}\r\n} else {\r\nif (func_num > 0) {\r\nif (!CHIP_REV_IS_SLOW(bp))\r\ncam_sz = PF_MAC_CREDIT_E2(bp, func_num);\r\nelse\r\ncam_sz = BNX2X_CAM_SIZE_EMUL;\r\nbnx2x_init_credit_pool(p, -1, cam_sz);\r\n} else {\r\nbnx2x_init_credit_pool(p, 0, 0);\r\n}\r\n}\r\n}\r\nvoid bnx2x_init_vlan_credit_pool(struct bnx2x *bp,\r\nstruct bnx2x_credit_pool_obj *p,\r\nu8 func_id,\r\nu8 func_num)\r\n{\r\nif (CHIP_IS_E1x(bp)) {\r\nbnx2x_init_credit_pool(p, 0, -1);\r\n} else {\r\nif (func_num > 0) {\r\nint credit = PF_VLAN_CREDIT_E2(bp, func_num);\r\nbnx2x_init_credit_pool(p, -1, credit);\r\n} else\r\nbnx2x_init_credit_pool(p, 0, 0);\r\n}\r\n}\r\nstatic inline void bnx2x_debug_print_ind_table(struct bnx2x *bp,\r\nstruct bnx2x_config_rss_params *p)\r\n{\r\nint i;\r\nDP(BNX2X_MSG_SP, "Setting indirection table to:\n");\r\nDP(BNX2X_MSG_SP, "0x0000: ");\r\nfor (i = 0; i < T_ETH_INDIRECTION_TABLE_SIZE; i++) {\r\nDP_CONT(BNX2X_MSG_SP, "0x%02x ", p->ind_table[i]);\r\nif ((i + 1 < T_ETH_INDIRECTION_TABLE_SIZE) &&\r\n(((i + 1) & 0x3) == 0)) {\r\nDP_CONT(BNX2X_MSG_SP, "\n");\r\nDP(BNX2X_MSG_SP, "0x%04x: ", i + 1);\r\n}\r\n}\r\nDP_CONT(BNX2X_MSG_SP, "\n");\r\n}\r\nstatic int bnx2x_setup_rss(struct bnx2x *bp,\r\nstruct bnx2x_config_rss_params *p)\r\n{\r\nstruct bnx2x_rss_config_obj *o = p->rss_obj;\r\nstruct bnx2x_raw_obj *r = &o->raw;\r\nstruct eth_rss_update_ramrod_data *data =\r\n(struct eth_rss_update_ramrod_data *)(r->rdata);\r\nu16 caps = 0;\r\nu8 rss_mode = 0;\r\nint rc;\r\nmemset(data, 0, sizeof(*data));\r\nDP(BNX2X_MSG_SP, "Configuring RSS\n");\r\ndata->echo = cpu_to_le32((r->cid & BNX2X_SWCID_MASK) |\r\n(r->state << BNX2X_SWCID_SHIFT));\r\nif (test_bit(BNX2X_RSS_MODE_DISABLED, &p->rss_flags))\r\nrss_mode = ETH_RSS_MODE_DISABLED;\r\nelse if (test_bit(BNX2X_RSS_MODE_REGULAR, &p->rss_flags))\r\nrss_mode = ETH_RSS_MODE_REGULAR;\r\ndata->rss_mode = rss_mode;\r\nDP(BNX2X_MSG_SP, "rss_mode=%d\n", rss_mode);\r\nif (test_bit(BNX2X_RSS_IPV4, &p->rss_flags))\r\ncaps |= ETH_RSS_UPDATE_RAMROD_DATA_IPV4_CAPABILITY;\r\nif (test_bit(BNX2X_RSS_IPV4_TCP, &p->rss_flags))\r\ncaps |= ETH_RSS_UPDATE_RAMROD_DATA_IPV4_TCP_CAPABILITY;\r\nif (test_bit(BNX2X_RSS_IPV4_UDP, &p->rss_flags))\r\ncaps |= ETH_RSS_UPDATE_RAMROD_DATA_IPV4_UDP_CAPABILITY;\r\nif (test_bit(BNX2X_RSS_IPV6, &p->rss_flags))\r\ncaps |= ETH_RSS_UPDATE_RAMROD_DATA_IPV6_CAPABILITY;\r\nif (test_bit(BNX2X_RSS_IPV6_TCP, &p->rss_flags))\r\ncaps |= ETH_RSS_UPDATE_RAMROD_DATA_IPV6_TCP_CAPABILITY;\r\nif (test_bit(BNX2X_RSS_IPV6_UDP, &p->rss_flags))\r\ncaps |= ETH_RSS_UPDATE_RAMROD_DATA_IPV6_UDP_CAPABILITY;\r\nif (test_bit(BNX2X_RSS_IPV4_VXLAN, &p->rss_flags))\r\ncaps |= ETH_RSS_UPDATE_RAMROD_DATA_IPV4_VXLAN_CAPABILITY;\r\nif (test_bit(BNX2X_RSS_IPV6_VXLAN, &p->rss_flags))\r\ncaps |= ETH_RSS_UPDATE_RAMROD_DATA_IPV6_VXLAN_CAPABILITY;\r\nif (test_bit(BNX2X_RSS_TUNN_INNER_HDRS, &p->rss_flags))\r\ncaps |= ETH_RSS_UPDATE_RAMROD_DATA_TUNN_INNER_HDRS_CAPABILITY;\r\nif (test_bit(BNX2X_RSS_SET_SRCH, &p->rss_flags)) {\r\nu8 *dst = (u8 *)(data->rss_key) + sizeof(data->rss_key);\r\nconst u8 *src = (const u8 *)p->rss_key;\r\nint i;\r\nfor (i = 0; i < sizeof(data->rss_key); i++)\r\n*--dst = *src++;\r\ncaps |= ETH_RSS_UPDATE_RAMROD_DATA_UPDATE_RSS_KEY;\r\n}\r\ndata->capabilities = cpu_to_le16(caps);\r\ndata->rss_result_mask = p->rss_result_mask;\r\ndata->rss_engine_id = o->engine_id;\r\nDP(BNX2X_MSG_SP, "rss_engine_id=%d\n", data->rss_engine_id);\r\nmemcpy(data->indirection_table, p->ind_table,\r\nT_ETH_INDIRECTION_TABLE_SIZE);\r\nmemcpy(o->ind_table, p->ind_table, T_ETH_INDIRECTION_TABLE_SIZE);\r\nif (netif_msg_ifup(bp))\r\nbnx2x_debug_print_ind_table(bp, p);\r\nrc = bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_RSS_UPDATE, r->cid,\r\nU64_HI(r->rdata_mapping),\r\nU64_LO(r->rdata_mapping),\r\nETH_CONNECTION_TYPE);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn 1;\r\n}\r\nvoid bnx2x_get_rss_ind_table(struct bnx2x_rss_config_obj *rss_obj,\r\nu8 *ind_table)\r\n{\r\nmemcpy(ind_table, rss_obj->ind_table, sizeof(rss_obj->ind_table));\r\n}\r\nint bnx2x_config_rss(struct bnx2x *bp,\r\nstruct bnx2x_config_rss_params *p)\r\n{\r\nint rc;\r\nstruct bnx2x_rss_config_obj *o = p->rss_obj;\r\nstruct bnx2x_raw_obj *r = &o->raw;\r\nif (test_bit(RAMROD_DRV_CLR_ONLY, &p->ramrod_flags)) {\r\nDP(BNX2X_MSG_SP, "Not configuring RSS ramrod_flags=%lx\n",\r\np->ramrod_flags);\r\nreturn 0;\r\n}\r\nr->set_pending(r);\r\nrc = o->config_rss(bp, p);\r\nif (rc < 0) {\r\nr->clear_pending(r);\r\nreturn rc;\r\n}\r\nif (test_bit(RAMROD_COMP_WAIT, &p->ramrod_flags))\r\nrc = r->wait_comp(bp, r);\r\nreturn rc;\r\n}\r\nvoid bnx2x_init_rss_config_obj(struct bnx2x *bp,\r\nstruct bnx2x_rss_config_obj *rss_obj,\r\nu8 cl_id, u32 cid, u8 func_id, u8 engine_id,\r\nvoid *rdata, dma_addr_t rdata_mapping,\r\nint state, unsigned long *pstate,\r\nbnx2x_obj_type type)\r\n{\r\nbnx2x_init_raw_obj(&rss_obj->raw, cl_id, cid, func_id, rdata,\r\nrdata_mapping, state, pstate, type);\r\nrss_obj->engine_id = engine_id;\r\nrss_obj->config_rss = bnx2x_setup_rss;\r\n}\r\nint bnx2x_queue_state_change(struct bnx2x *bp,\r\nstruct bnx2x_queue_state_params *params)\r\n{\r\nstruct bnx2x_queue_sp_obj *o = params->q_obj;\r\nint rc, pending_bit;\r\nunsigned long *pending = &o->pending;\r\nrc = o->check_transition(bp, o, params);\r\nif (rc) {\r\nBNX2X_ERR("check transition returned an error. rc %d\n", rc);\r\nreturn -EINVAL;\r\n}\r\nDP(BNX2X_MSG_SP, "pending bit was=%lx\n", o->pending);\r\npending_bit = o->set_pending(o, params);\r\nDP(BNX2X_MSG_SP, "pending bit now=%lx\n", o->pending);\r\nif (test_bit(RAMROD_DRV_CLR_ONLY, &params->ramrod_flags))\r\no->complete_cmd(bp, o, pending_bit);\r\nelse {\r\nrc = o->send_cmd(bp, params);\r\nif (rc) {\r\no->next_state = BNX2X_Q_STATE_MAX;\r\nclear_bit(pending_bit, pending);\r\nsmp_mb__after_atomic();\r\nreturn rc;\r\n}\r\nif (test_bit(RAMROD_COMP_WAIT, &params->ramrod_flags)) {\r\nrc = o->wait_comp(bp, o, pending_bit);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\n}\r\nreturn !!test_bit(pending_bit, pending);\r\n}\r\nstatic int bnx2x_queue_set_pending(struct bnx2x_queue_sp_obj *obj,\r\nstruct bnx2x_queue_state_params *params)\r\n{\r\nenum bnx2x_queue_cmd cmd = params->cmd, bit;\r\nif ((cmd == BNX2X_Q_CMD_ACTIVATE) ||\r\n(cmd == BNX2X_Q_CMD_DEACTIVATE))\r\nbit = BNX2X_Q_CMD_UPDATE;\r\nelse\r\nbit = cmd;\r\nset_bit(bit, &obj->pending);\r\nreturn bit;\r\n}\r\nstatic int bnx2x_queue_wait_comp(struct bnx2x *bp,\r\nstruct bnx2x_queue_sp_obj *o,\r\nenum bnx2x_queue_cmd cmd)\r\n{\r\nreturn bnx2x_state_wait(bp, cmd, &o->pending);\r\n}\r\nstatic int bnx2x_queue_comp_cmd(struct bnx2x *bp,\r\nstruct bnx2x_queue_sp_obj *o,\r\nenum bnx2x_queue_cmd cmd)\r\n{\r\nunsigned long cur_pending = o->pending;\r\nif (!test_and_clear_bit(cmd, &cur_pending)) {\r\nBNX2X_ERR("Bad MC reply %d for queue %d in state %d pending 0x%lx, next_state %d\n",\r\ncmd, o->cids[BNX2X_PRIMARY_CID_INDEX],\r\no->state, cur_pending, o->next_state);\r\nreturn -EINVAL;\r\n}\r\nif (o->next_tx_only >= o->max_cos)\r\nBNX2X_ERR("illegal value for next tx_only: %d. max cos was %d",\r\no->next_tx_only, o->max_cos);\r\nDP(BNX2X_MSG_SP,\r\n"Completing command %d for queue %d, setting state to %d\n",\r\ncmd, o->cids[BNX2X_PRIMARY_CID_INDEX], o->next_state);\r\nif (o->next_tx_only)\r\nDP(BNX2X_MSG_SP, "primary cid %d: num tx-only cons %d\n",\r\no->cids[BNX2X_PRIMARY_CID_INDEX], o->next_tx_only);\r\no->state = o->next_state;\r\no->num_tx_only = o->next_tx_only;\r\no->next_state = BNX2X_Q_STATE_MAX;\r\nwmb();\r\nclear_bit(cmd, &o->pending);\r\nsmp_mb__after_atomic();\r\nreturn 0;\r\n}\r\nstatic void bnx2x_q_fill_setup_data_e2(struct bnx2x *bp,\r\nstruct bnx2x_queue_state_params *cmd_params,\r\nstruct client_init_ramrod_data *data)\r\n{\r\nstruct bnx2x_queue_setup_params *params = &cmd_params->params.setup;\r\ndata->rx.tpa_en |= test_bit(BNX2X_Q_FLG_TPA_IPV6, &params->flags) *\r\nCLIENT_INIT_RX_DATA_TPA_EN_IPV6;\r\n}\r\nstatic void bnx2x_q_fill_init_general_data(struct bnx2x *bp,\r\nstruct bnx2x_queue_sp_obj *o,\r\nstruct bnx2x_general_setup_params *params,\r\nstruct client_init_general_data *gen_data,\r\nunsigned long *flags)\r\n{\r\ngen_data->client_id = o->cl_id;\r\nif (test_bit(BNX2X_Q_FLG_STATS, flags)) {\r\ngen_data->statistics_counter_id =\r\nparams->stat_id;\r\ngen_data->statistics_en_flg = 1;\r\ngen_data->statistics_zero_flg =\r\ntest_bit(BNX2X_Q_FLG_ZERO_STATS, flags);\r\n} else\r\ngen_data->statistics_counter_id =\r\nDISABLE_STATISTIC_COUNTER_ID_VALUE;\r\ngen_data->is_fcoe_flg = test_bit(BNX2X_Q_FLG_FCOE, flags);\r\ngen_data->activate_flg = test_bit(BNX2X_Q_FLG_ACTIVE, flags);\r\ngen_data->sp_client_id = params->spcl_id;\r\ngen_data->mtu = cpu_to_le16(params->mtu);\r\ngen_data->func_id = o->func_id;\r\ngen_data->cos = params->cos;\r\ngen_data->traffic_type =\r\ntest_bit(BNX2X_Q_FLG_FCOE, flags) ?\r\nLLFC_TRAFFIC_TYPE_FCOE : LLFC_TRAFFIC_TYPE_NW;\r\ngen_data->fp_hsi_ver = params->fp_hsi;\r\nDP(BNX2X_MSG_SP, "flags: active %d, cos %d, stats en %d\n",\r\ngen_data->activate_flg, gen_data->cos, gen_data->statistics_en_flg);\r\n}\r\nstatic void bnx2x_q_fill_init_tx_data(struct bnx2x_queue_sp_obj *o,\r\nstruct bnx2x_txq_setup_params *params,\r\nstruct client_init_tx_data *tx_data,\r\nunsigned long *flags)\r\n{\r\ntx_data->enforce_security_flg =\r\ntest_bit(BNX2X_Q_FLG_TX_SEC, flags);\r\ntx_data->default_vlan =\r\ncpu_to_le16(params->default_vlan);\r\ntx_data->default_vlan_flg =\r\ntest_bit(BNX2X_Q_FLG_DEF_VLAN, flags);\r\ntx_data->tx_switching_flg =\r\ntest_bit(BNX2X_Q_FLG_TX_SWITCH, flags);\r\ntx_data->anti_spoofing_flg =\r\ntest_bit(BNX2X_Q_FLG_ANTI_SPOOF, flags);\r\ntx_data->force_default_pri_flg =\r\ntest_bit(BNX2X_Q_FLG_FORCE_DEFAULT_PRI, flags);\r\ntx_data->refuse_outband_vlan_flg =\r\ntest_bit(BNX2X_Q_FLG_REFUSE_OUTBAND_VLAN, flags);\r\ntx_data->tunnel_lso_inc_ip_id =\r\ntest_bit(BNX2X_Q_FLG_TUN_INC_INNER_IP_ID, flags);\r\ntx_data->tunnel_non_lso_pcsum_location =\r\ntest_bit(BNX2X_Q_FLG_PCSUM_ON_PKT, flags) ? CSUM_ON_PKT :\r\nCSUM_ON_BD;\r\ntx_data->tx_status_block_id = params->fw_sb_id;\r\ntx_data->tx_sb_index_number = params->sb_cq_index;\r\ntx_data->tss_leading_client_id = params->tss_leading_cl_id;\r\ntx_data->tx_bd_page_base.lo =\r\ncpu_to_le32(U64_LO(params->dscr_map));\r\ntx_data->tx_bd_page_base.hi =\r\ncpu_to_le32(U64_HI(params->dscr_map));\r\ntx_data->state = 0;\r\n}\r\nstatic void bnx2x_q_fill_init_pause_data(struct bnx2x_queue_sp_obj *o,\r\nstruct rxq_pause_params *params,\r\nstruct client_init_rx_data *rx_data)\r\n{\r\nrx_data->cqe_pause_thr_low = cpu_to_le16(params->rcq_th_lo);\r\nrx_data->cqe_pause_thr_high = cpu_to_le16(params->rcq_th_hi);\r\nrx_data->bd_pause_thr_low = cpu_to_le16(params->bd_th_lo);\r\nrx_data->bd_pause_thr_high = cpu_to_le16(params->bd_th_hi);\r\nrx_data->sge_pause_thr_low = cpu_to_le16(params->sge_th_lo);\r\nrx_data->sge_pause_thr_high = cpu_to_le16(params->sge_th_hi);\r\nrx_data->rx_cos_mask = cpu_to_le16(params->pri_map);\r\n}\r\nstatic void bnx2x_q_fill_init_rx_data(struct bnx2x_queue_sp_obj *o,\r\nstruct bnx2x_rxq_setup_params *params,\r\nstruct client_init_rx_data *rx_data,\r\nunsigned long *flags)\r\n{\r\nrx_data->tpa_en = test_bit(BNX2X_Q_FLG_TPA, flags) *\r\nCLIENT_INIT_RX_DATA_TPA_EN_IPV4;\r\nrx_data->tpa_en |= test_bit(BNX2X_Q_FLG_TPA_GRO, flags) *\r\nCLIENT_INIT_RX_DATA_TPA_MODE;\r\nrx_data->vmqueue_mode_en_flg = 0;\r\nrx_data->cache_line_alignment_log_size =\r\nparams->cache_line_log;\r\nrx_data->enable_dynamic_hc =\r\ntest_bit(BNX2X_Q_FLG_DHC, flags);\r\nrx_data->max_sges_for_packet = params->max_sges_pkt;\r\nrx_data->client_qzone_id = params->cl_qzone_id;\r\nrx_data->max_agg_size = cpu_to_le16(params->tpa_agg_sz);\r\nrx_data->state = cpu_to_le16(CLIENT_INIT_RX_DATA_UCAST_DROP_ALL |\r\nCLIENT_INIT_RX_DATA_MCAST_DROP_ALL);\r\nrx_data->drop_ip_cs_err_flg = 0;\r\nrx_data->drop_tcp_cs_err_flg = 0;\r\nrx_data->drop_ttl0_flg = 0;\r\nrx_data->drop_udp_cs_err_flg = 0;\r\nrx_data->inner_vlan_removal_enable_flg =\r\ntest_bit(BNX2X_Q_FLG_VLAN, flags);\r\nrx_data->outer_vlan_removal_enable_flg =\r\ntest_bit(BNX2X_Q_FLG_OV, flags);\r\nrx_data->status_block_id = params->fw_sb_id;\r\nrx_data->rx_sb_index_number = params->sb_cq_index;\r\nrx_data->max_tpa_queues = params->max_tpa_queues;\r\nrx_data->max_bytes_on_bd = cpu_to_le16(params->buf_sz);\r\nrx_data->sge_buff_size = cpu_to_le16(params->sge_buf_sz);\r\nrx_data->bd_page_base.lo =\r\ncpu_to_le32(U64_LO(params->dscr_map));\r\nrx_data->bd_page_base.hi =\r\ncpu_to_le32(U64_HI(params->dscr_map));\r\nrx_data->sge_page_base.lo =\r\ncpu_to_le32(U64_LO(params->sge_map));\r\nrx_data->sge_page_base.hi =\r\ncpu_to_le32(U64_HI(params->sge_map));\r\nrx_data->cqe_page_base.lo =\r\ncpu_to_le32(U64_LO(params->rcq_map));\r\nrx_data->cqe_page_base.hi =\r\ncpu_to_le32(U64_HI(params->rcq_map));\r\nrx_data->is_leading_rss = test_bit(BNX2X_Q_FLG_LEADING_RSS, flags);\r\nif (test_bit(BNX2X_Q_FLG_MCAST, flags)) {\r\nrx_data->approx_mcast_engine_id = params->mcast_engine_id;\r\nrx_data->is_approx_mcast = 1;\r\n}\r\nrx_data->rss_engine_id = params->rss_engine_id;\r\nrx_data->silent_vlan_removal_flg =\r\ntest_bit(BNX2X_Q_FLG_SILENT_VLAN_REM, flags);\r\nrx_data->silent_vlan_value =\r\ncpu_to_le16(params->silent_removal_value);\r\nrx_data->silent_vlan_mask =\r\ncpu_to_le16(params->silent_removal_mask);\r\n}\r\nstatic void bnx2x_q_fill_setup_data_cmn(struct bnx2x *bp,\r\nstruct bnx2x_queue_state_params *cmd_params,\r\nstruct client_init_ramrod_data *data)\r\n{\r\nbnx2x_q_fill_init_general_data(bp, cmd_params->q_obj,\r\n&cmd_params->params.setup.gen_params,\r\n&data->general,\r\n&cmd_params->params.setup.flags);\r\nbnx2x_q_fill_init_tx_data(cmd_params->q_obj,\r\n&cmd_params->params.setup.txq_params,\r\n&data->tx,\r\n&cmd_params->params.setup.flags);\r\nbnx2x_q_fill_init_rx_data(cmd_params->q_obj,\r\n&cmd_params->params.setup.rxq_params,\r\n&data->rx,\r\n&cmd_params->params.setup.flags);\r\nbnx2x_q_fill_init_pause_data(cmd_params->q_obj,\r\n&cmd_params->params.setup.pause_params,\r\n&data->rx);\r\n}\r\nstatic void bnx2x_q_fill_setup_tx_only(struct bnx2x *bp,\r\nstruct bnx2x_queue_state_params *cmd_params,\r\nstruct tx_queue_init_ramrod_data *data)\r\n{\r\nbnx2x_q_fill_init_general_data(bp, cmd_params->q_obj,\r\n&cmd_params->params.tx_only.gen_params,\r\n&data->general,\r\n&cmd_params->params.tx_only.flags);\r\nbnx2x_q_fill_init_tx_data(cmd_params->q_obj,\r\n&cmd_params->params.tx_only.txq_params,\r\n&data->tx,\r\n&cmd_params->params.tx_only.flags);\r\nDP(BNX2X_MSG_SP, "cid %d, tx bd page lo %x hi %x",\r\ncmd_params->q_obj->cids[0],\r\ndata->tx.tx_bd_page_base.lo,\r\ndata->tx.tx_bd_page_base.hi);\r\n}\r\nstatic inline int bnx2x_q_init(struct bnx2x *bp,\r\nstruct bnx2x_queue_state_params *params)\r\n{\r\nstruct bnx2x_queue_sp_obj *o = params->q_obj;\r\nstruct bnx2x_queue_init_params *init = &params->params.init;\r\nu16 hc_usec;\r\nu8 cos;\r\nif (test_bit(BNX2X_Q_TYPE_HAS_TX, &o->type) &&\r\ntest_bit(BNX2X_Q_FLG_HC, &init->tx.flags)) {\r\nhc_usec = init->tx.hc_rate ? 1000000 / init->tx.hc_rate : 0;\r\nbnx2x_update_coalesce_sb_index(bp, init->tx.fw_sb_id,\r\ninit->tx.sb_cq_index,\r\n!test_bit(BNX2X_Q_FLG_HC_EN, &init->tx.flags),\r\nhc_usec);\r\n}\r\nif (test_bit(BNX2X_Q_TYPE_HAS_RX, &o->type) &&\r\ntest_bit(BNX2X_Q_FLG_HC, &init->rx.flags)) {\r\nhc_usec = init->rx.hc_rate ? 1000000 / init->rx.hc_rate : 0;\r\nbnx2x_update_coalesce_sb_index(bp, init->rx.fw_sb_id,\r\ninit->rx.sb_cq_index,\r\n!test_bit(BNX2X_Q_FLG_HC_EN, &init->rx.flags),\r\nhc_usec);\r\n}\r\nfor (cos = 0; cos < o->max_cos; cos++) {\r\nDP(BNX2X_MSG_SP, "setting context validation. cid %d, cos %d\n",\r\no->cids[cos], cos);\r\nDP(BNX2X_MSG_SP, "context pointer %p\n", init->cxts[cos]);\r\nbnx2x_set_ctx_validation(bp, init->cxts[cos], o->cids[cos]);\r\n}\r\no->complete_cmd(bp, o, BNX2X_Q_CMD_INIT);\r\nmmiowb();\r\nsmp_mb();\r\nreturn 0;\r\n}\r\nstatic inline int bnx2x_q_send_setup_e1x(struct bnx2x *bp,\r\nstruct bnx2x_queue_state_params *params)\r\n{\r\nstruct bnx2x_queue_sp_obj *o = params->q_obj;\r\nstruct client_init_ramrod_data *rdata =\r\n(struct client_init_ramrod_data *)o->rdata;\r\ndma_addr_t data_mapping = o->rdata_mapping;\r\nint ramrod = RAMROD_CMD_ID_ETH_CLIENT_SETUP;\r\nmemset(rdata, 0, sizeof(*rdata));\r\nbnx2x_q_fill_setup_data_cmn(bp, params, rdata);\r\nreturn bnx2x_sp_post(bp, ramrod, o->cids[BNX2X_PRIMARY_CID_INDEX],\r\nU64_HI(data_mapping),\r\nU64_LO(data_mapping), ETH_CONNECTION_TYPE);\r\n}\r\nstatic inline int bnx2x_q_send_setup_e2(struct bnx2x *bp,\r\nstruct bnx2x_queue_state_params *params)\r\n{\r\nstruct bnx2x_queue_sp_obj *o = params->q_obj;\r\nstruct client_init_ramrod_data *rdata =\r\n(struct client_init_ramrod_data *)o->rdata;\r\ndma_addr_t data_mapping = o->rdata_mapping;\r\nint ramrod = RAMROD_CMD_ID_ETH_CLIENT_SETUP;\r\nmemset(rdata, 0, sizeof(*rdata));\r\nbnx2x_q_fill_setup_data_cmn(bp, params, rdata);\r\nbnx2x_q_fill_setup_data_e2(bp, params, rdata);\r\nreturn bnx2x_sp_post(bp, ramrod, o->cids[BNX2X_PRIMARY_CID_INDEX],\r\nU64_HI(data_mapping),\r\nU64_LO(data_mapping), ETH_CONNECTION_TYPE);\r\n}\r\nstatic inline int bnx2x_q_send_setup_tx_only(struct bnx2x *bp,\r\nstruct bnx2x_queue_state_params *params)\r\n{\r\nstruct bnx2x_queue_sp_obj *o = params->q_obj;\r\nstruct tx_queue_init_ramrod_data *rdata =\r\n(struct tx_queue_init_ramrod_data *)o->rdata;\r\ndma_addr_t data_mapping = o->rdata_mapping;\r\nint ramrod = RAMROD_CMD_ID_ETH_TX_QUEUE_SETUP;\r\nstruct bnx2x_queue_setup_tx_only_params *tx_only_params =\r\n&params->params.tx_only;\r\nu8 cid_index = tx_only_params->cid_index;\r\nif (cid_index >= o->max_cos) {\r\nBNX2X_ERR("queue[%d]: cid_index (%d) is out of range\n",\r\no->cl_id, cid_index);\r\nreturn -EINVAL;\r\n}\r\nDP(BNX2X_MSG_SP, "parameters received: cos: %d sp-id: %d\n",\r\ntx_only_params->gen_params.cos,\r\ntx_only_params->gen_params.spcl_id);\r\nmemset(rdata, 0, sizeof(*rdata));\r\nbnx2x_q_fill_setup_tx_only(bp, params, rdata);\r\nDP(BNX2X_MSG_SP, "sending tx-only ramrod: cid %d, client-id %d, sp-client id %d, cos %d\n",\r\no->cids[cid_index], rdata->general.client_id,\r\nrdata->general.sp_client_id, rdata->general.cos);\r\nreturn bnx2x_sp_post(bp, ramrod, o->cids[cid_index],\r\nU64_HI(data_mapping),\r\nU64_LO(data_mapping), ETH_CONNECTION_TYPE);\r\n}\r\nstatic void bnx2x_q_fill_update_data(struct bnx2x *bp,\r\nstruct bnx2x_queue_sp_obj *obj,\r\nstruct bnx2x_queue_update_params *params,\r\nstruct client_update_ramrod_data *data)\r\n{\r\ndata->client_id = obj->cl_id;\r\ndata->func_id = obj->func_id;\r\ndata->default_vlan = cpu_to_le16(params->def_vlan);\r\ndata->inner_vlan_removal_enable_flg =\r\ntest_bit(BNX2X_Q_UPDATE_IN_VLAN_REM, &params->update_flags);\r\ndata->inner_vlan_removal_change_flg =\r\ntest_bit(BNX2X_Q_UPDATE_IN_VLAN_REM_CHNG,\r\n&params->update_flags);\r\ndata->outer_vlan_removal_enable_flg =\r\ntest_bit(BNX2X_Q_UPDATE_OUT_VLAN_REM, &params->update_flags);\r\ndata->outer_vlan_removal_change_flg =\r\ntest_bit(BNX2X_Q_UPDATE_OUT_VLAN_REM_CHNG,\r\n&params->update_flags);\r\ndata->anti_spoofing_enable_flg =\r\ntest_bit(BNX2X_Q_UPDATE_ANTI_SPOOF, &params->update_flags);\r\ndata->anti_spoofing_change_flg =\r\ntest_bit(BNX2X_Q_UPDATE_ANTI_SPOOF_CHNG, &params->update_flags);\r\ndata->activate_flg =\r\ntest_bit(BNX2X_Q_UPDATE_ACTIVATE, &params->update_flags);\r\ndata->activate_change_flg =\r\ntest_bit(BNX2X_Q_UPDATE_ACTIVATE_CHNG, &params->update_flags);\r\ndata->default_vlan_enable_flg =\r\ntest_bit(BNX2X_Q_UPDATE_DEF_VLAN_EN, &params->update_flags);\r\ndata->default_vlan_change_flg =\r\ntest_bit(BNX2X_Q_UPDATE_DEF_VLAN_EN_CHNG,\r\n&params->update_flags);\r\ndata->silent_vlan_change_flg =\r\ntest_bit(BNX2X_Q_UPDATE_SILENT_VLAN_REM_CHNG,\r\n&params->update_flags);\r\ndata->silent_vlan_removal_flg =\r\ntest_bit(BNX2X_Q_UPDATE_SILENT_VLAN_REM, &params->update_flags);\r\ndata->silent_vlan_value = cpu_to_le16(params->silent_removal_value);\r\ndata->silent_vlan_mask = cpu_to_le16(params->silent_removal_mask);\r\ndata->tx_switching_flg =\r\ntest_bit(BNX2X_Q_UPDATE_TX_SWITCHING, &params->update_flags);\r\ndata->tx_switching_change_flg =\r\ntest_bit(BNX2X_Q_UPDATE_TX_SWITCHING_CHNG,\r\n&params->update_flags);\r\ndata->handle_ptp_pkts_flg =\r\ntest_bit(BNX2X_Q_UPDATE_PTP_PKTS, &params->update_flags);\r\ndata->handle_ptp_pkts_change_flg =\r\ntest_bit(BNX2X_Q_UPDATE_PTP_PKTS_CHNG, &params->update_flags);\r\n}\r\nstatic inline int bnx2x_q_send_update(struct bnx2x *bp,\r\nstruct bnx2x_queue_state_params *params)\r\n{\r\nstruct bnx2x_queue_sp_obj *o = params->q_obj;\r\nstruct client_update_ramrod_data *rdata =\r\n(struct client_update_ramrod_data *)o->rdata;\r\ndma_addr_t data_mapping = o->rdata_mapping;\r\nstruct bnx2x_queue_update_params *update_params =\r\n&params->params.update;\r\nu8 cid_index = update_params->cid_index;\r\nif (cid_index >= o->max_cos) {\r\nBNX2X_ERR("queue[%d]: cid_index (%d) is out of range\n",\r\no->cl_id, cid_index);\r\nreturn -EINVAL;\r\n}\r\nmemset(rdata, 0, sizeof(*rdata));\r\nbnx2x_q_fill_update_data(bp, o, update_params, rdata);\r\nreturn bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_CLIENT_UPDATE,\r\no->cids[cid_index], U64_HI(data_mapping),\r\nU64_LO(data_mapping), ETH_CONNECTION_TYPE);\r\n}\r\nstatic inline int bnx2x_q_send_deactivate(struct bnx2x *bp,\r\nstruct bnx2x_queue_state_params *params)\r\n{\r\nstruct bnx2x_queue_update_params *update = &params->params.update;\r\nmemset(update, 0, sizeof(*update));\r\n__set_bit(BNX2X_Q_UPDATE_ACTIVATE_CHNG, &update->update_flags);\r\nreturn bnx2x_q_send_update(bp, params);\r\n}\r\nstatic inline int bnx2x_q_send_activate(struct bnx2x *bp,\r\nstruct bnx2x_queue_state_params *params)\r\n{\r\nstruct bnx2x_queue_update_params *update = &params->params.update;\r\nmemset(update, 0, sizeof(*update));\r\n__set_bit(BNX2X_Q_UPDATE_ACTIVATE, &update->update_flags);\r\n__set_bit(BNX2X_Q_UPDATE_ACTIVATE_CHNG, &update->update_flags);\r\nreturn bnx2x_q_send_update(bp, params);\r\n}\r\nstatic void bnx2x_q_fill_update_tpa_data(struct bnx2x *bp,\r\nstruct bnx2x_queue_sp_obj *obj,\r\nstruct bnx2x_queue_update_tpa_params *params,\r\nstruct tpa_update_ramrod_data *data)\r\n{\r\ndata->client_id = obj->cl_id;\r\ndata->complete_on_both_clients = params->complete_on_both_clients;\r\ndata->dont_verify_rings_pause_thr_flg =\r\nparams->dont_verify_thr;\r\ndata->max_agg_size = cpu_to_le16(params->max_agg_sz);\r\ndata->max_sges_for_packet = params->max_sges_pkt;\r\ndata->max_tpa_queues = params->max_tpa_queues;\r\ndata->sge_buff_size = cpu_to_le16(params->sge_buff_sz);\r\ndata->sge_page_base_hi = cpu_to_le32(U64_HI(params->sge_map));\r\ndata->sge_page_base_lo = cpu_to_le32(U64_LO(params->sge_map));\r\ndata->sge_pause_thr_high = cpu_to_le16(params->sge_pause_thr_high);\r\ndata->sge_pause_thr_low = cpu_to_le16(params->sge_pause_thr_low);\r\ndata->tpa_mode = params->tpa_mode;\r\ndata->update_ipv4 = params->update_ipv4;\r\ndata->update_ipv6 = params->update_ipv6;\r\n}\r\nstatic inline int bnx2x_q_send_update_tpa(struct bnx2x *bp,\r\nstruct bnx2x_queue_state_params *params)\r\n{\r\nstruct bnx2x_queue_sp_obj *o = params->q_obj;\r\nstruct tpa_update_ramrod_data *rdata =\r\n(struct tpa_update_ramrod_data *)o->rdata;\r\ndma_addr_t data_mapping = o->rdata_mapping;\r\nstruct bnx2x_queue_update_tpa_params *update_tpa_params =\r\n&params->params.update_tpa;\r\nu16 type;\r\nmemset(rdata, 0, sizeof(*rdata));\r\nbnx2x_q_fill_update_tpa_data(bp, o, update_tpa_params, rdata);\r\ntype = ETH_CONNECTION_TYPE |\r\n((o->func_id) << SPE_HDR_FUNCTION_ID_SHIFT);\r\nreturn bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_TPA_UPDATE,\r\no->cids[BNX2X_PRIMARY_CID_INDEX],\r\nU64_HI(data_mapping),\r\nU64_LO(data_mapping), type);\r\n}\r\nstatic inline int bnx2x_q_send_halt(struct bnx2x *bp,\r\nstruct bnx2x_queue_state_params *params)\r\n{\r\nstruct bnx2x_queue_sp_obj *o = params->q_obj;\r\nreturn bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_HALT,\r\no->cids[BNX2X_PRIMARY_CID_INDEX], 0, o->cl_id,\r\nETH_CONNECTION_TYPE);\r\n}\r\nstatic inline int bnx2x_q_send_cfc_del(struct bnx2x *bp,\r\nstruct bnx2x_queue_state_params *params)\r\n{\r\nstruct bnx2x_queue_sp_obj *o = params->q_obj;\r\nu8 cid_idx = params->params.cfc_del.cid_index;\r\nif (cid_idx >= o->max_cos) {\r\nBNX2X_ERR("queue[%d]: cid_index (%d) is out of range\n",\r\no->cl_id, cid_idx);\r\nreturn -EINVAL;\r\n}\r\nreturn bnx2x_sp_post(bp, RAMROD_CMD_ID_COMMON_CFC_DEL,\r\no->cids[cid_idx], 0, 0, NONE_CONNECTION_TYPE);\r\n}\r\nstatic inline int bnx2x_q_send_terminate(struct bnx2x *bp,\r\nstruct bnx2x_queue_state_params *params)\r\n{\r\nstruct bnx2x_queue_sp_obj *o = params->q_obj;\r\nu8 cid_index = params->params.terminate.cid_index;\r\nif (cid_index >= o->max_cos) {\r\nBNX2X_ERR("queue[%d]: cid_index (%d) is out of range\n",\r\no->cl_id, cid_index);\r\nreturn -EINVAL;\r\n}\r\nreturn bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_TERMINATE,\r\no->cids[cid_index], 0, 0, ETH_CONNECTION_TYPE);\r\n}\r\nstatic inline int bnx2x_q_send_empty(struct bnx2x *bp,\r\nstruct bnx2x_queue_state_params *params)\r\n{\r\nstruct bnx2x_queue_sp_obj *o = params->q_obj;\r\nreturn bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_EMPTY,\r\no->cids[BNX2X_PRIMARY_CID_INDEX], 0, 0,\r\nETH_CONNECTION_TYPE);\r\n}\r\nstatic inline int bnx2x_queue_send_cmd_cmn(struct bnx2x *bp,\r\nstruct bnx2x_queue_state_params *params)\r\n{\r\nswitch (params->cmd) {\r\ncase BNX2X_Q_CMD_INIT:\r\nreturn bnx2x_q_init(bp, params);\r\ncase BNX2X_Q_CMD_SETUP_TX_ONLY:\r\nreturn bnx2x_q_send_setup_tx_only(bp, params);\r\ncase BNX2X_Q_CMD_DEACTIVATE:\r\nreturn bnx2x_q_send_deactivate(bp, params);\r\ncase BNX2X_Q_CMD_ACTIVATE:\r\nreturn bnx2x_q_send_activate(bp, params);\r\ncase BNX2X_Q_CMD_UPDATE:\r\nreturn bnx2x_q_send_update(bp, params);\r\ncase BNX2X_Q_CMD_UPDATE_TPA:\r\nreturn bnx2x_q_send_update_tpa(bp, params);\r\ncase BNX2X_Q_CMD_HALT:\r\nreturn bnx2x_q_send_halt(bp, params);\r\ncase BNX2X_Q_CMD_CFC_DEL:\r\nreturn bnx2x_q_send_cfc_del(bp, params);\r\ncase BNX2X_Q_CMD_TERMINATE:\r\nreturn bnx2x_q_send_terminate(bp, params);\r\ncase BNX2X_Q_CMD_EMPTY:\r\nreturn bnx2x_q_send_empty(bp, params);\r\ndefault:\r\nBNX2X_ERR("Unknown command: %d\n", params->cmd);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int bnx2x_queue_send_cmd_e1x(struct bnx2x *bp,\r\nstruct bnx2x_queue_state_params *params)\r\n{\r\nswitch (params->cmd) {\r\ncase BNX2X_Q_CMD_SETUP:\r\nreturn bnx2x_q_send_setup_e1x(bp, params);\r\ncase BNX2X_Q_CMD_INIT:\r\ncase BNX2X_Q_CMD_SETUP_TX_ONLY:\r\ncase BNX2X_Q_CMD_DEACTIVATE:\r\ncase BNX2X_Q_CMD_ACTIVATE:\r\ncase BNX2X_Q_CMD_UPDATE:\r\ncase BNX2X_Q_CMD_UPDATE_TPA:\r\ncase BNX2X_Q_CMD_HALT:\r\ncase BNX2X_Q_CMD_CFC_DEL:\r\ncase BNX2X_Q_CMD_TERMINATE:\r\ncase BNX2X_Q_CMD_EMPTY:\r\nreturn bnx2x_queue_send_cmd_cmn(bp, params);\r\ndefault:\r\nBNX2X_ERR("Unknown command: %d\n", params->cmd);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int bnx2x_queue_send_cmd_e2(struct bnx2x *bp,\r\nstruct bnx2x_queue_state_params *params)\r\n{\r\nswitch (params->cmd) {\r\ncase BNX2X_Q_CMD_SETUP:\r\nreturn bnx2x_q_send_setup_e2(bp, params);\r\ncase BNX2X_Q_CMD_INIT:\r\ncase BNX2X_Q_CMD_SETUP_TX_ONLY:\r\ncase BNX2X_Q_CMD_DEACTIVATE:\r\ncase BNX2X_Q_CMD_ACTIVATE:\r\ncase BNX2X_Q_CMD_UPDATE:\r\ncase BNX2X_Q_CMD_UPDATE_TPA:\r\ncase BNX2X_Q_CMD_HALT:\r\ncase BNX2X_Q_CMD_CFC_DEL:\r\ncase BNX2X_Q_CMD_TERMINATE:\r\ncase BNX2X_Q_CMD_EMPTY:\r\nreturn bnx2x_queue_send_cmd_cmn(bp, params);\r\ndefault:\r\nBNX2X_ERR("Unknown command: %d\n", params->cmd);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int bnx2x_queue_chk_transition(struct bnx2x *bp,\r\nstruct bnx2x_queue_sp_obj *o,\r\nstruct bnx2x_queue_state_params *params)\r\n{\r\nenum bnx2x_q_state state = o->state, next_state = BNX2X_Q_STATE_MAX;\r\nenum bnx2x_queue_cmd cmd = params->cmd;\r\nstruct bnx2x_queue_update_params *update_params =\r\n&params->params.update;\r\nu8 next_tx_only = o->num_tx_only;\r\nif (test_bit(RAMROD_DRV_CLR_ONLY, &params->ramrod_flags)) {\r\no->pending = 0;\r\no->next_state = BNX2X_Q_STATE_MAX;\r\n}\r\nif (o->pending) {\r\nBNX2X_ERR("Blocking transition since pending was %lx\n",\r\no->pending);\r\nreturn -EBUSY;\r\n}\r\nswitch (state) {\r\ncase BNX2X_Q_STATE_RESET:\r\nif (cmd == BNX2X_Q_CMD_INIT)\r\nnext_state = BNX2X_Q_STATE_INITIALIZED;\r\nbreak;\r\ncase BNX2X_Q_STATE_INITIALIZED:\r\nif (cmd == BNX2X_Q_CMD_SETUP) {\r\nif (test_bit(BNX2X_Q_FLG_ACTIVE,\r\n&params->params.setup.flags))\r\nnext_state = BNX2X_Q_STATE_ACTIVE;\r\nelse\r\nnext_state = BNX2X_Q_STATE_INACTIVE;\r\n}\r\nbreak;\r\ncase BNX2X_Q_STATE_ACTIVE:\r\nif (cmd == BNX2X_Q_CMD_DEACTIVATE)\r\nnext_state = BNX2X_Q_STATE_INACTIVE;\r\nelse if ((cmd == BNX2X_Q_CMD_EMPTY) ||\r\n(cmd == BNX2X_Q_CMD_UPDATE_TPA))\r\nnext_state = BNX2X_Q_STATE_ACTIVE;\r\nelse if (cmd == BNX2X_Q_CMD_SETUP_TX_ONLY) {\r\nnext_state = BNX2X_Q_STATE_MULTI_COS;\r\nnext_tx_only = 1;\r\n}\r\nelse if (cmd == BNX2X_Q_CMD_HALT)\r\nnext_state = BNX2X_Q_STATE_STOPPED;\r\nelse if (cmd == BNX2X_Q_CMD_UPDATE) {\r\nif (test_bit(BNX2X_Q_UPDATE_ACTIVATE_CHNG,\r\n&update_params->update_flags) &&\r\n!test_bit(BNX2X_Q_UPDATE_ACTIVATE,\r\n&update_params->update_flags))\r\nnext_state = BNX2X_Q_STATE_INACTIVE;\r\nelse\r\nnext_state = BNX2X_Q_STATE_ACTIVE;\r\n}\r\nbreak;\r\ncase BNX2X_Q_STATE_MULTI_COS:\r\nif (cmd == BNX2X_Q_CMD_TERMINATE)\r\nnext_state = BNX2X_Q_STATE_MCOS_TERMINATED;\r\nelse if (cmd == BNX2X_Q_CMD_SETUP_TX_ONLY) {\r\nnext_state = BNX2X_Q_STATE_MULTI_COS;\r\nnext_tx_only = o->num_tx_only + 1;\r\n}\r\nelse if ((cmd == BNX2X_Q_CMD_EMPTY) ||\r\n(cmd == BNX2X_Q_CMD_UPDATE_TPA))\r\nnext_state = BNX2X_Q_STATE_MULTI_COS;\r\nelse if (cmd == BNX2X_Q_CMD_UPDATE) {\r\nif (test_bit(BNX2X_Q_UPDATE_ACTIVATE_CHNG,\r\n&update_params->update_flags) &&\r\n!test_bit(BNX2X_Q_UPDATE_ACTIVATE,\r\n&update_params->update_flags))\r\nnext_state = BNX2X_Q_STATE_INACTIVE;\r\nelse\r\nnext_state = BNX2X_Q_STATE_MULTI_COS;\r\n}\r\nbreak;\r\ncase BNX2X_Q_STATE_MCOS_TERMINATED:\r\nif (cmd == BNX2X_Q_CMD_CFC_DEL) {\r\nnext_tx_only = o->num_tx_only - 1;\r\nif (next_tx_only == 0)\r\nnext_state = BNX2X_Q_STATE_ACTIVE;\r\nelse\r\nnext_state = BNX2X_Q_STATE_MULTI_COS;\r\n}\r\nbreak;\r\ncase BNX2X_Q_STATE_INACTIVE:\r\nif (cmd == BNX2X_Q_CMD_ACTIVATE)\r\nnext_state = BNX2X_Q_STATE_ACTIVE;\r\nelse if ((cmd == BNX2X_Q_CMD_EMPTY) ||\r\n(cmd == BNX2X_Q_CMD_UPDATE_TPA))\r\nnext_state = BNX2X_Q_STATE_INACTIVE;\r\nelse if (cmd == BNX2X_Q_CMD_HALT)\r\nnext_state = BNX2X_Q_STATE_STOPPED;\r\nelse if (cmd == BNX2X_Q_CMD_UPDATE) {\r\nif (test_bit(BNX2X_Q_UPDATE_ACTIVATE_CHNG,\r\n&update_params->update_flags) &&\r\ntest_bit(BNX2X_Q_UPDATE_ACTIVATE,\r\n&update_params->update_flags)){\r\nif (o->num_tx_only == 0)\r\nnext_state = BNX2X_Q_STATE_ACTIVE;\r\nelse\r\nnext_state = BNX2X_Q_STATE_MULTI_COS;\r\n} else\r\nnext_state = BNX2X_Q_STATE_INACTIVE;\r\n}\r\nbreak;\r\ncase BNX2X_Q_STATE_STOPPED:\r\nif (cmd == BNX2X_Q_CMD_TERMINATE)\r\nnext_state = BNX2X_Q_STATE_TERMINATED;\r\nbreak;\r\ncase BNX2X_Q_STATE_TERMINATED:\r\nif (cmd == BNX2X_Q_CMD_CFC_DEL)\r\nnext_state = BNX2X_Q_STATE_RESET;\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Illegal state: %d\n", state);\r\n}\r\nif (next_state != BNX2X_Q_STATE_MAX) {\r\nDP(BNX2X_MSG_SP, "Good state transition: %d(%d)->%d\n",\r\nstate, cmd, next_state);\r\no->next_state = next_state;\r\no->next_tx_only = next_tx_only;\r\nreturn 0;\r\n}\r\nDP(BNX2X_MSG_SP, "Bad state transition request: %d %d\n", state, cmd);\r\nreturn -EINVAL;\r\n}\r\nvoid bnx2x_init_queue_obj(struct bnx2x *bp,\r\nstruct bnx2x_queue_sp_obj *obj,\r\nu8 cl_id, u32 *cids, u8 cid_cnt, u8 func_id,\r\nvoid *rdata,\r\ndma_addr_t rdata_mapping, unsigned long type)\r\n{\r\nmemset(obj, 0, sizeof(*obj));\r\nBUG_ON(BNX2X_MULTI_TX_COS < cid_cnt);\r\nmemcpy(obj->cids, cids, sizeof(obj->cids[0]) * cid_cnt);\r\nobj->max_cos = cid_cnt;\r\nobj->cl_id = cl_id;\r\nobj->func_id = func_id;\r\nobj->rdata = rdata;\r\nobj->rdata_mapping = rdata_mapping;\r\nobj->type = type;\r\nobj->next_state = BNX2X_Q_STATE_MAX;\r\nif (CHIP_IS_E1x(bp))\r\nobj->send_cmd = bnx2x_queue_send_cmd_e1x;\r\nelse\r\nobj->send_cmd = bnx2x_queue_send_cmd_e2;\r\nobj->check_transition = bnx2x_queue_chk_transition;\r\nobj->complete_cmd = bnx2x_queue_comp_cmd;\r\nobj->wait_comp = bnx2x_queue_wait_comp;\r\nobj->set_pending = bnx2x_queue_set_pending;\r\n}\r\nint bnx2x_get_q_logical_state(struct bnx2x *bp,\r\nstruct bnx2x_queue_sp_obj *obj)\r\n{\r\nswitch (obj->state) {\r\ncase BNX2X_Q_STATE_ACTIVE:\r\ncase BNX2X_Q_STATE_MULTI_COS:\r\nreturn BNX2X_Q_LOGICAL_STATE_ACTIVE;\r\ncase BNX2X_Q_STATE_RESET:\r\ncase BNX2X_Q_STATE_INITIALIZED:\r\ncase BNX2X_Q_STATE_MCOS_TERMINATED:\r\ncase BNX2X_Q_STATE_INACTIVE:\r\ncase BNX2X_Q_STATE_STOPPED:\r\ncase BNX2X_Q_STATE_TERMINATED:\r\ncase BNX2X_Q_STATE_FLRED:\r\nreturn BNX2X_Q_LOGICAL_STATE_STOPPED;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nenum bnx2x_func_state bnx2x_func_get_state(struct bnx2x *bp,\r\nstruct bnx2x_func_sp_obj *o)\r\n{\r\nif (o->pending)\r\nreturn BNX2X_F_STATE_MAX;\r\nrmb();\r\nreturn o->state;\r\n}\r\nstatic int bnx2x_func_wait_comp(struct bnx2x *bp,\r\nstruct bnx2x_func_sp_obj *o,\r\nenum bnx2x_func_cmd cmd)\r\n{\r\nreturn bnx2x_state_wait(bp, cmd, &o->pending);\r\n}\r\nstatic inline int bnx2x_func_state_change_comp(struct bnx2x *bp,\r\nstruct bnx2x_func_sp_obj *o,\r\nenum bnx2x_func_cmd cmd)\r\n{\r\nunsigned long cur_pending = o->pending;\r\nif (!test_and_clear_bit(cmd, &cur_pending)) {\r\nBNX2X_ERR("Bad MC reply %d for func %d in state %d pending 0x%lx, next_state %d\n",\r\ncmd, BP_FUNC(bp), o->state,\r\ncur_pending, o->next_state);\r\nreturn -EINVAL;\r\n}\r\nDP(BNX2X_MSG_SP,\r\n"Completing command %d for func %d, setting state to %d\n",\r\ncmd, BP_FUNC(bp), o->next_state);\r\no->state = o->next_state;\r\no->next_state = BNX2X_F_STATE_MAX;\r\nwmb();\r\nclear_bit(cmd, &o->pending);\r\nsmp_mb__after_atomic();\r\nreturn 0;\r\n}\r\nstatic int bnx2x_func_comp_cmd(struct bnx2x *bp,\r\nstruct bnx2x_func_sp_obj *o,\r\nenum bnx2x_func_cmd cmd)\r\n{\r\nint rc = bnx2x_func_state_change_comp(bp, o, cmd);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_func_chk_transition(struct bnx2x *bp,\r\nstruct bnx2x_func_sp_obj *o,\r\nstruct bnx2x_func_state_params *params)\r\n{\r\nenum bnx2x_func_state state = o->state, next_state = BNX2X_F_STATE_MAX;\r\nenum bnx2x_func_cmd cmd = params->cmd;\r\nif (test_bit(RAMROD_DRV_CLR_ONLY, &params->ramrod_flags)) {\r\no->pending = 0;\r\no->next_state = BNX2X_F_STATE_MAX;\r\n}\r\nif (o->pending)\r\nreturn -EBUSY;\r\nswitch (state) {\r\ncase BNX2X_F_STATE_RESET:\r\nif (cmd == BNX2X_F_CMD_HW_INIT)\r\nnext_state = BNX2X_F_STATE_INITIALIZED;\r\nbreak;\r\ncase BNX2X_F_STATE_INITIALIZED:\r\nif (cmd == BNX2X_F_CMD_START)\r\nnext_state = BNX2X_F_STATE_STARTED;\r\nelse if (cmd == BNX2X_F_CMD_HW_RESET)\r\nnext_state = BNX2X_F_STATE_RESET;\r\nbreak;\r\ncase BNX2X_F_STATE_STARTED:\r\nif (cmd == BNX2X_F_CMD_STOP)\r\nnext_state = BNX2X_F_STATE_INITIALIZED;\r\nelse if ((cmd == BNX2X_F_CMD_AFEX_UPDATE) &&\r\n(!test_bit(BNX2X_F_CMD_STOP, &o->pending)))\r\nnext_state = BNX2X_F_STATE_STARTED;\r\nelse if ((cmd == BNX2X_F_CMD_AFEX_VIFLISTS) &&\r\n(!test_bit(BNX2X_F_CMD_STOP, &o->pending)))\r\nnext_state = BNX2X_F_STATE_STARTED;\r\nelse if ((cmd == BNX2X_F_CMD_SWITCH_UPDATE) &&\r\n(!test_bit(BNX2X_F_CMD_STOP, &o->pending)))\r\nnext_state = BNX2X_F_STATE_STARTED;\r\nelse if ((cmd == BNX2X_F_CMD_SET_TIMESYNC) &&\r\n(!test_bit(BNX2X_F_CMD_STOP, &o->pending)))\r\nnext_state = BNX2X_F_STATE_STARTED;\r\nelse if (cmd == BNX2X_F_CMD_TX_STOP)\r\nnext_state = BNX2X_F_STATE_TX_STOPPED;\r\nbreak;\r\ncase BNX2X_F_STATE_TX_STOPPED:\r\nif ((cmd == BNX2X_F_CMD_SWITCH_UPDATE) &&\r\n(!test_bit(BNX2X_F_CMD_STOP, &o->pending)))\r\nnext_state = BNX2X_F_STATE_TX_STOPPED;\r\nelse if ((cmd == BNX2X_F_CMD_SET_TIMESYNC) &&\r\n(!test_bit(BNX2X_F_CMD_STOP, &o->pending)))\r\nnext_state = BNX2X_F_STATE_TX_STOPPED;\r\nelse if (cmd == BNX2X_F_CMD_TX_START)\r\nnext_state = BNX2X_F_STATE_STARTED;\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Unknown state: %d\n", state);\r\n}\r\nif (next_state != BNX2X_F_STATE_MAX) {\r\nDP(BNX2X_MSG_SP, "Good function state transition: %d(%d)->%d\n",\r\nstate, cmd, next_state);\r\no->next_state = next_state;\r\nreturn 0;\r\n}\r\nDP(BNX2X_MSG_SP, "Bad function state transition request: %d %d\n",\r\nstate, cmd);\r\nreturn -EINVAL;\r\n}\r\nstatic inline int bnx2x_func_init_func(struct bnx2x *bp,\r\nconst struct bnx2x_func_sp_drv_ops *drv)\r\n{\r\nreturn drv->init_hw_func(bp);\r\n}\r\nstatic inline int bnx2x_func_init_port(struct bnx2x *bp,\r\nconst struct bnx2x_func_sp_drv_ops *drv)\r\n{\r\nint rc = drv->init_hw_port(bp);\r\nif (rc)\r\nreturn rc;\r\nreturn bnx2x_func_init_func(bp, drv);\r\n}\r\nstatic inline int bnx2x_func_init_cmn_chip(struct bnx2x *bp,\r\nconst struct bnx2x_func_sp_drv_ops *drv)\r\n{\r\nint rc = drv->init_hw_cmn_chip(bp);\r\nif (rc)\r\nreturn rc;\r\nreturn bnx2x_func_init_port(bp, drv);\r\n}\r\nstatic inline int bnx2x_func_init_cmn(struct bnx2x *bp,\r\nconst struct bnx2x_func_sp_drv_ops *drv)\r\n{\r\nint rc = drv->init_hw_cmn(bp);\r\nif (rc)\r\nreturn rc;\r\nreturn bnx2x_func_init_port(bp, drv);\r\n}\r\nstatic int bnx2x_func_hw_init(struct bnx2x *bp,\r\nstruct bnx2x_func_state_params *params)\r\n{\r\nu32 load_code = params->params.hw_init.load_phase;\r\nstruct bnx2x_func_sp_obj *o = params->f_obj;\r\nconst struct bnx2x_func_sp_drv_ops *drv = o->drv;\r\nint rc = 0;\r\nDP(BNX2X_MSG_SP, "function %d load_code %x\n",\r\nBP_ABS_FUNC(bp), load_code);\r\nrc = drv->gunzip_init(bp);\r\nif (rc)\r\nreturn rc;\r\nrc = drv->init_fw(bp);\r\nif (rc) {\r\nBNX2X_ERR("Error loading firmware\n");\r\ngoto init_err;\r\n}\r\nswitch (load_code) {\r\ncase FW_MSG_CODE_DRV_LOAD_COMMON_CHIP:\r\nrc = bnx2x_func_init_cmn_chip(bp, drv);\r\nif (rc)\r\ngoto init_err;\r\nbreak;\r\ncase FW_MSG_CODE_DRV_LOAD_COMMON:\r\nrc = bnx2x_func_init_cmn(bp, drv);\r\nif (rc)\r\ngoto init_err;\r\nbreak;\r\ncase FW_MSG_CODE_DRV_LOAD_PORT:\r\nrc = bnx2x_func_init_port(bp, drv);\r\nif (rc)\r\ngoto init_err;\r\nbreak;\r\ncase FW_MSG_CODE_DRV_LOAD_FUNCTION:\r\nrc = bnx2x_func_init_func(bp, drv);\r\nif (rc)\r\ngoto init_err;\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Unknown load_code (0x%x) from MCP\n", load_code);\r\nrc = -EINVAL;\r\n}\r\ninit_err:\r\ndrv->gunzip_end(bp);\r\nif (!rc)\r\no->complete_cmd(bp, o, BNX2X_F_CMD_HW_INIT);\r\nreturn rc;\r\n}\r\nstatic inline void bnx2x_func_reset_func(struct bnx2x *bp,\r\nconst struct bnx2x_func_sp_drv_ops *drv)\r\n{\r\ndrv->reset_hw_func(bp);\r\n}\r\nstatic inline void bnx2x_func_reset_port(struct bnx2x *bp,\r\nconst struct bnx2x_func_sp_drv_ops *drv)\r\n{\r\ndrv->reset_hw_port(bp);\r\nbnx2x_func_reset_func(bp, drv);\r\n}\r\nstatic inline void bnx2x_func_reset_cmn(struct bnx2x *bp,\r\nconst struct bnx2x_func_sp_drv_ops *drv)\r\n{\r\nbnx2x_func_reset_port(bp, drv);\r\ndrv->reset_hw_cmn(bp);\r\n}\r\nstatic inline int bnx2x_func_hw_reset(struct bnx2x *bp,\r\nstruct bnx2x_func_state_params *params)\r\n{\r\nu32 reset_phase = params->params.hw_reset.reset_phase;\r\nstruct bnx2x_func_sp_obj *o = params->f_obj;\r\nconst struct bnx2x_func_sp_drv_ops *drv = o->drv;\r\nDP(BNX2X_MSG_SP, "function %d reset_phase %x\n", BP_ABS_FUNC(bp),\r\nreset_phase);\r\nswitch (reset_phase) {\r\ncase FW_MSG_CODE_DRV_UNLOAD_COMMON:\r\nbnx2x_func_reset_cmn(bp, drv);\r\nbreak;\r\ncase FW_MSG_CODE_DRV_UNLOAD_PORT:\r\nbnx2x_func_reset_port(bp, drv);\r\nbreak;\r\ncase FW_MSG_CODE_DRV_UNLOAD_FUNCTION:\r\nbnx2x_func_reset_func(bp, drv);\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Unknown reset_phase (0x%x) from MCP\n",\r\nreset_phase);\r\nbreak;\r\n}\r\no->complete_cmd(bp, o, BNX2X_F_CMD_HW_RESET);\r\nreturn 0;\r\n}\r\nstatic inline int bnx2x_func_send_start(struct bnx2x *bp,\r\nstruct bnx2x_func_state_params *params)\r\n{\r\nstruct bnx2x_func_sp_obj *o = params->f_obj;\r\nstruct function_start_data *rdata =\r\n(struct function_start_data *)o->rdata;\r\ndma_addr_t data_mapping = o->rdata_mapping;\r\nstruct bnx2x_func_start_params *start_params = &params->params.start;\r\nmemset(rdata, 0, sizeof(*rdata));\r\nrdata->function_mode = (u8)start_params->mf_mode;\r\nrdata->sd_vlan_tag = cpu_to_le16(start_params->sd_vlan_tag);\r\nrdata->path_id = BP_PATH(bp);\r\nrdata->network_cos_mode = start_params->network_cos_mode;\r\nrdata->vxlan_dst_port = cpu_to_le16(start_params->vxlan_dst_port);\r\nrdata->geneve_dst_port = cpu_to_le16(start_params->geneve_dst_port);\r\nrdata->inner_clss_l2gre = start_params->inner_clss_l2gre;\r\nrdata->inner_clss_l2geneve = start_params->inner_clss_l2geneve;\r\nrdata->inner_clss_vxlan = start_params->inner_clss_vxlan;\r\nrdata->inner_rss = start_params->inner_rss;\r\nrdata->sd_accept_mf_clss_fail = start_params->class_fail;\r\nif (start_params->class_fail_ethtype) {\r\nrdata->sd_accept_mf_clss_fail_match_ethtype = 1;\r\nrdata->sd_accept_mf_clss_fail_ethtype =\r\ncpu_to_le16(start_params->class_fail_ethtype);\r\n}\r\nrdata->sd_vlan_force_pri_flg = start_params->sd_vlan_force_pri;\r\nrdata->sd_vlan_force_pri_val = start_params->sd_vlan_force_pri_val;\r\nif (start_params->sd_vlan_eth_type)\r\nrdata->sd_vlan_eth_type =\r\ncpu_to_le16(start_params->sd_vlan_eth_type);\r\nelse\r\nrdata->sd_vlan_eth_type =\r\ncpu_to_le16(0x8100);\r\nrdata->no_added_tags = start_params->no_added_tags;\r\nrdata->c2s_pri_tt_valid = start_params->c2s_pri_valid;\r\nif (rdata->c2s_pri_tt_valid) {\r\nmemcpy(rdata->c2s_pri_trans_table.val,\r\nstart_params->c2s_pri,\r\nMAX_VLAN_PRIORITIES);\r\nrdata->c2s_pri_default = start_params->c2s_pri_default;\r\n}\r\nreturn bnx2x_sp_post(bp, RAMROD_CMD_ID_COMMON_FUNCTION_START, 0,\r\nU64_HI(data_mapping),\r\nU64_LO(data_mapping), NONE_CONNECTION_TYPE);\r\n}\r\nstatic inline int bnx2x_func_send_switch_update(struct bnx2x *bp,\r\nstruct bnx2x_func_state_params *params)\r\n{\r\nstruct bnx2x_func_sp_obj *o = params->f_obj;\r\nstruct function_update_data *rdata =\r\n(struct function_update_data *)o->rdata;\r\ndma_addr_t data_mapping = o->rdata_mapping;\r\nstruct bnx2x_func_switch_update_params *switch_update_params =\r\n&params->params.switch_update;\r\nmemset(rdata, 0, sizeof(*rdata));\r\nif (test_bit(BNX2X_F_UPDATE_TX_SWITCH_SUSPEND_CHNG,\r\n&switch_update_params->changes)) {\r\nrdata->tx_switch_suspend_change_flg = 1;\r\nrdata->tx_switch_suspend =\r\ntest_bit(BNX2X_F_UPDATE_TX_SWITCH_SUSPEND,\r\n&switch_update_params->changes);\r\n}\r\nif (test_bit(BNX2X_F_UPDATE_SD_VLAN_TAG_CHNG,\r\n&switch_update_params->changes)) {\r\nrdata->sd_vlan_tag_change_flg = 1;\r\nrdata->sd_vlan_tag =\r\ncpu_to_le16(switch_update_params->vlan);\r\n}\r\nif (test_bit(BNX2X_F_UPDATE_SD_VLAN_ETH_TYPE_CHNG,\r\n&switch_update_params->changes)) {\r\nrdata->sd_vlan_eth_type_change_flg = 1;\r\nrdata->sd_vlan_eth_type =\r\ncpu_to_le16(switch_update_params->vlan_eth_type);\r\n}\r\nif (test_bit(BNX2X_F_UPDATE_VLAN_FORCE_PRIO_CHNG,\r\n&switch_update_params->changes)) {\r\nrdata->sd_vlan_force_pri_change_flg = 1;\r\nif (test_bit(BNX2X_F_UPDATE_VLAN_FORCE_PRIO_FLAG,\r\n&switch_update_params->changes))\r\nrdata->sd_vlan_force_pri_flg = 1;\r\nrdata->sd_vlan_force_pri_flg =\r\nswitch_update_params->vlan_force_prio;\r\n}\r\nif (test_bit(BNX2X_F_UPDATE_TUNNEL_CFG_CHNG,\r\n&switch_update_params->changes)) {\r\nrdata->update_tunn_cfg_flg = 1;\r\nif (test_bit(BNX2X_F_UPDATE_TUNNEL_INNER_CLSS_L2GRE,\r\n&switch_update_params->changes))\r\nrdata->inner_clss_l2gre = 1;\r\nif (test_bit(BNX2X_F_UPDATE_TUNNEL_INNER_CLSS_VXLAN,\r\n&switch_update_params->changes))\r\nrdata->inner_clss_vxlan = 1;\r\nif (test_bit(BNX2X_F_UPDATE_TUNNEL_INNER_CLSS_L2GENEVE,\r\n&switch_update_params->changes))\r\nrdata->inner_clss_l2geneve = 1;\r\nif (test_bit(BNX2X_F_UPDATE_TUNNEL_INNER_RSS,\r\n&switch_update_params->changes))\r\nrdata->inner_rss = 1;\r\nrdata->vxlan_dst_port =\r\ncpu_to_le16(switch_update_params->vxlan_dst_port);\r\nrdata->geneve_dst_port =\r\ncpu_to_le16(switch_update_params->geneve_dst_port);\r\n}\r\nrdata->echo = SWITCH_UPDATE;\r\nreturn bnx2x_sp_post(bp, RAMROD_CMD_ID_COMMON_FUNCTION_UPDATE, 0,\r\nU64_HI(data_mapping),\r\nU64_LO(data_mapping), NONE_CONNECTION_TYPE);\r\n}\r\nstatic inline int bnx2x_func_send_afex_update(struct bnx2x *bp,\r\nstruct bnx2x_func_state_params *params)\r\n{\r\nstruct bnx2x_func_sp_obj *o = params->f_obj;\r\nstruct function_update_data *rdata =\r\n(struct function_update_data *)o->afex_rdata;\r\ndma_addr_t data_mapping = o->afex_rdata_mapping;\r\nstruct bnx2x_func_afex_update_params *afex_update_params =\r\n&params->params.afex_update;\r\nmemset(rdata, 0, sizeof(*rdata));\r\nrdata->vif_id_change_flg = 1;\r\nrdata->vif_id = cpu_to_le16(afex_update_params->vif_id);\r\nrdata->afex_default_vlan_change_flg = 1;\r\nrdata->afex_default_vlan =\r\ncpu_to_le16(afex_update_params->afex_default_vlan);\r\nrdata->allowed_priorities_change_flg = 1;\r\nrdata->allowed_priorities = afex_update_params->allowed_priorities;\r\nrdata->echo = AFEX_UPDATE;\r\nDP(BNX2X_MSG_SP,\r\n"afex: sending func_update vif_id 0x%x dvlan 0x%x prio 0x%x\n",\r\nrdata->vif_id,\r\nrdata->afex_default_vlan, rdata->allowed_priorities);\r\nreturn bnx2x_sp_post(bp, RAMROD_CMD_ID_COMMON_FUNCTION_UPDATE, 0,\r\nU64_HI(data_mapping),\r\nU64_LO(data_mapping), NONE_CONNECTION_TYPE);\r\n}\r\nstatic\r\ninline int bnx2x_func_send_afex_viflists(struct bnx2x *bp,\r\nstruct bnx2x_func_state_params *params)\r\n{\r\nstruct bnx2x_func_sp_obj *o = params->f_obj;\r\nstruct afex_vif_list_ramrod_data *rdata =\r\n(struct afex_vif_list_ramrod_data *)o->afex_rdata;\r\nstruct bnx2x_func_afex_viflists_params *afex_vif_params =\r\n&params->params.afex_viflists;\r\nu64 *p_rdata = (u64 *)rdata;\r\nmemset(rdata, 0, sizeof(*rdata));\r\nrdata->vif_list_index = cpu_to_le16(afex_vif_params->vif_list_index);\r\nrdata->func_bit_map = afex_vif_params->func_bit_map;\r\nrdata->afex_vif_list_command = afex_vif_params->afex_vif_list_command;\r\nrdata->func_to_clear = afex_vif_params->func_to_clear;\r\nrdata->echo = afex_vif_params->afex_vif_list_command;\r\nDP(BNX2X_MSG_SP, "afex: ramrod lists, cmd 0x%x index 0x%x func_bit_map 0x%x func_to_clr 0x%x\n",\r\nrdata->afex_vif_list_command, rdata->vif_list_index,\r\nrdata->func_bit_map, rdata->func_to_clear);\r\nreturn bnx2x_sp_post(bp, RAMROD_CMD_ID_COMMON_AFEX_VIF_LISTS, 0,\r\nU64_HI(*p_rdata), U64_LO(*p_rdata),\r\nNONE_CONNECTION_TYPE);\r\n}\r\nstatic inline int bnx2x_func_send_stop(struct bnx2x *bp,\r\nstruct bnx2x_func_state_params *params)\r\n{\r\nreturn bnx2x_sp_post(bp, RAMROD_CMD_ID_COMMON_FUNCTION_STOP, 0, 0, 0,\r\nNONE_CONNECTION_TYPE);\r\n}\r\nstatic inline int bnx2x_func_send_tx_stop(struct bnx2x *bp,\r\nstruct bnx2x_func_state_params *params)\r\n{\r\nreturn bnx2x_sp_post(bp, RAMROD_CMD_ID_COMMON_STOP_TRAFFIC, 0, 0, 0,\r\nNONE_CONNECTION_TYPE);\r\n}\r\nstatic inline int bnx2x_func_send_tx_start(struct bnx2x *bp,\r\nstruct bnx2x_func_state_params *params)\r\n{\r\nstruct bnx2x_func_sp_obj *o = params->f_obj;\r\nstruct flow_control_configuration *rdata =\r\n(struct flow_control_configuration *)o->rdata;\r\ndma_addr_t data_mapping = o->rdata_mapping;\r\nstruct bnx2x_func_tx_start_params *tx_start_params =\r\n&params->params.tx_start;\r\nint i;\r\nmemset(rdata, 0, sizeof(*rdata));\r\nrdata->dcb_enabled = tx_start_params->dcb_enabled;\r\nrdata->dcb_version = tx_start_params->dcb_version;\r\nrdata->dont_add_pri_0_en = tx_start_params->dont_add_pri_0_en;\r\nfor (i = 0; i < ARRAY_SIZE(rdata->traffic_type_to_priority_cos); i++)\r\nrdata->traffic_type_to_priority_cos[i] =\r\ntx_start_params->traffic_type_to_priority_cos[i];\r\nfor (i = 0; i < MAX_TRAFFIC_TYPES; i++)\r\nrdata->dcb_outer_pri[i] = tx_start_params->dcb_outer_pri[i];\r\nreturn bnx2x_sp_post(bp, RAMROD_CMD_ID_COMMON_START_TRAFFIC, 0,\r\nU64_HI(data_mapping),\r\nU64_LO(data_mapping), NONE_CONNECTION_TYPE);\r\n}\r\nstatic inline\r\nint bnx2x_func_send_set_timesync(struct bnx2x *bp,\r\nstruct bnx2x_func_state_params *params)\r\n{\r\nstruct bnx2x_func_sp_obj *o = params->f_obj;\r\nstruct set_timesync_ramrod_data *rdata =\r\n(struct set_timesync_ramrod_data *)o->rdata;\r\ndma_addr_t data_mapping = o->rdata_mapping;\r\nstruct bnx2x_func_set_timesync_params *set_timesync_params =\r\n&params->params.set_timesync;\r\nmemset(rdata, 0, sizeof(*rdata));\r\nrdata->drift_adjust_cmd = set_timesync_params->drift_adjust_cmd;\r\nrdata->offset_cmd = set_timesync_params->offset_cmd;\r\nrdata->add_sub_drift_adjust_value =\r\nset_timesync_params->add_sub_drift_adjust_value;\r\nrdata->drift_adjust_value = set_timesync_params->drift_adjust_value;\r\nrdata->drift_adjust_period = set_timesync_params->drift_adjust_period;\r\nrdata->offset_delta.lo =\r\ncpu_to_le32(U64_LO(set_timesync_params->offset_delta));\r\nrdata->offset_delta.hi =\r\ncpu_to_le32(U64_HI(set_timesync_params->offset_delta));\r\nDP(BNX2X_MSG_SP, "Set timesync command params: drift_cmd = %d, offset_cmd = %d, add_sub_drift = %d, drift_val = %d, drift_period = %d, offset_lo = %d, offset_hi = %d\n",\r\nrdata->drift_adjust_cmd, rdata->offset_cmd,\r\nrdata->add_sub_drift_adjust_value, rdata->drift_adjust_value,\r\nrdata->drift_adjust_period, rdata->offset_delta.lo,\r\nrdata->offset_delta.hi);\r\nreturn bnx2x_sp_post(bp, RAMROD_CMD_ID_COMMON_SET_TIMESYNC, 0,\r\nU64_HI(data_mapping),\r\nU64_LO(data_mapping), NONE_CONNECTION_TYPE);\r\n}\r\nstatic int bnx2x_func_send_cmd(struct bnx2x *bp,\r\nstruct bnx2x_func_state_params *params)\r\n{\r\nswitch (params->cmd) {\r\ncase BNX2X_F_CMD_HW_INIT:\r\nreturn bnx2x_func_hw_init(bp, params);\r\ncase BNX2X_F_CMD_START:\r\nreturn bnx2x_func_send_start(bp, params);\r\ncase BNX2X_F_CMD_STOP:\r\nreturn bnx2x_func_send_stop(bp, params);\r\ncase BNX2X_F_CMD_HW_RESET:\r\nreturn bnx2x_func_hw_reset(bp, params);\r\ncase BNX2X_F_CMD_AFEX_UPDATE:\r\nreturn bnx2x_func_send_afex_update(bp, params);\r\ncase BNX2X_F_CMD_AFEX_VIFLISTS:\r\nreturn bnx2x_func_send_afex_viflists(bp, params);\r\ncase BNX2X_F_CMD_TX_STOP:\r\nreturn bnx2x_func_send_tx_stop(bp, params);\r\ncase BNX2X_F_CMD_TX_START:\r\nreturn bnx2x_func_send_tx_start(bp, params);\r\ncase BNX2X_F_CMD_SWITCH_UPDATE:\r\nreturn bnx2x_func_send_switch_update(bp, params);\r\ncase BNX2X_F_CMD_SET_TIMESYNC:\r\nreturn bnx2x_func_send_set_timesync(bp, params);\r\ndefault:\r\nBNX2X_ERR("Unknown command: %d\n", params->cmd);\r\nreturn -EINVAL;\r\n}\r\n}\r\nvoid bnx2x_init_func_obj(struct bnx2x *bp,\r\nstruct bnx2x_func_sp_obj *obj,\r\nvoid *rdata, dma_addr_t rdata_mapping,\r\nvoid *afex_rdata, dma_addr_t afex_rdata_mapping,\r\nstruct bnx2x_func_sp_drv_ops *drv_iface)\r\n{\r\nmemset(obj, 0, sizeof(*obj));\r\nmutex_init(&obj->one_pending_mutex);\r\nobj->rdata = rdata;\r\nobj->rdata_mapping = rdata_mapping;\r\nobj->afex_rdata = afex_rdata;\r\nobj->afex_rdata_mapping = afex_rdata_mapping;\r\nobj->send_cmd = bnx2x_func_send_cmd;\r\nobj->check_transition = bnx2x_func_chk_transition;\r\nobj->complete_cmd = bnx2x_func_comp_cmd;\r\nobj->wait_comp = bnx2x_func_wait_comp;\r\nobj->drv = drv_iface;\r\n}\r\nint bnx2x_func_state_change(struct bnx2x *bp,\r\nstruct bnx2x_func_state_params *params)\r\n{\r\nstruct bnx2x_func_sp_obj *o = params->f_obj;\r\nint rc, cnt = 300;\r\nenum bnx2x_func_cmd cmd = params->cmd;\r\nunsigned long *pending = &o->pending;\r\nmutex_lock(&o->one_pending_mutex);\r\nrc = o->check_transition(bp, o, params);\r\nif ((rc == -EBUSY) &&\r\n(test_bit(RAMROD_RETRY, &params->ramrod_flags))) {\r\nwhile ((rc == -EBUSY) && (--cnt > 0)) {\r\nmutex_unlock(&o->one_pending_mutex);\r\nmsleep(10);\r\nmutex_lock(&o->one_pending_mutex);\r\nrc = o->check_transition(bp, o, params);\r\n}\r\nif (rc == -EBUSY) {\r\nmutex_unlock(&o->one_pending_mutex);\r\nBNX2X_ERR("timeout waiting for previous ramrod completion\n");\r\nreturn rc;\r\n}\r\n} else if (rc) {\r\nmutex_unlock(&o->one_pending_mutex);\r\nreturn rc;\r\n}\r\nset_bit(cmd, pending);\r\nif (test_bit(RAMROD_DRV_CLR_ONLY, &params->ramrod_flags)) {\r\nbnx2x_func_state_change_comp(bp, o, cmd);\r\nmutex_unlock(&o->one_pending_mutex);\r\n} else {\r\nrc = o->send_cmd(bp, params);\r\nmutex_unlock(&o->one_pending_mutex);\r\nif (rc) {\r\no->next_state = BNX2X_F_STATE_MAX;\r\nclear_bit(cmd, pending);\r\nsmp_mb__after_atomic();\r\nreturn rc;\r\n}\r\nif (test_bit(RAMROD_COMP_WAIT, &params->ramrod_flags)) {\r\nrc = o->wait_comp(bp, o, cmd);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\n}\r\nreturn !!test_bit(cmd, pending);\r\n}
