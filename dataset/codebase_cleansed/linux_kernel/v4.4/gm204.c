static void\r\npmu_code(struct nv50_devinit *init, u32 pmu, u32 img, u32 len, bool sec)\r\n{\r\nstruct nvkm_device *device = init->base.subdev.device;\r\nstruct nvkm_bios *bios = device->bios;\r\nint i;\r\nnvkm_wr32(device, 0x10a180, 0x01000000 | (sec ? 0x10000000 : 0) | pmu);\r\nfor (i = 0; i < len; i += 4) {\r\nif ((i & 0xff) == 0)\r\nnvkm_wr32(device, 0x10a188, (pmu + i) >> 8);\r\nnvkm_wr32(device, 0x10a184, nvbios_rd32(bios, img + i));\r\n}\r\nwhile (i & 0xff) {\r\nnvkm_wr32(device, 0x10a184, 0x00000000);\r\ni += 4;\r\n}\r\n}\r\nstatic void\r\npmu_data(struct nv50_devinit *init, u32 pmu, u32 img, u32 len)\r\n{\r\nstruct nvkm_device *device = init->base.subdev.device;\r\nstruct nvkm_bios *bios = device->bios;\r\nint i;\r\nnvkm_wr32(device, 0x10a1c0, 0x01000000 | pmu);\r\nfor (i = 0; i < len; i += 4)\r\nnvkm_wr32(device, 0x10a1c4, nvbios_rd32(bios, img + i));\r\n}\r\nstatic u32\r\npmu_args(struct nv50_devinit *init, u32 argp, u32 argi)\r\n{\r\nstruct nvkm_device *device = init->base.subdev.device;\r\nnvkm_wr32(device, 0x10a1c0, argp);\r\nnvkm_wr32(device, 0x10a1c0, nvkm_rd32(device, 0x10a1c4) + argi);\r\nreturn nvkm_rd32(device, 0x10a1c4);\r\n}\r\nstatic void\r\npmu_exec(struct nv50_devinit *init, u32 init_addr)\r\n{\r\nstruct nvkm_device *device = init->base.subdev.device;\r\nnvkm_wr32(device, 0x10a104, init_addr);\r\nnvkm_wr32(device, 0x10a10c, 0x00000000);\r\nnvkm_wr32(device, 0x10a100, 0x00000002);\r\n}\r\nstatic int\r\npmu_load(struct nv50_devinit *init, u8 type, bool post,\r\nu32 *init_addr_pmu, u32 *args_addr_pmu)\r\n{\r\nstruct nvkm_subdev *subdev = &init->base.subdev;\r\nstruct nvkm_bios *bios = subdev->device->bios;\r\nstruct nvbios_pmuR pmu;\r\nif (!nvbios_pmuRm(bios, type, &pmu)) {\r\nnvkm_error(subdev, "VBIOS PMU fuc %02x not found\n", type);\r\nreturn -EINVAL;\r\n}\r\nif (!post)\r\nreturn 0;\r\npmu_code(init, pmu.boot_addr_pmu, pmu.boot_addr, pmu.boot_size, false);\r\npmu_code(init, pmu.code_addr_pmu, pmu.code_addr, pmu.code_size, true);\r\npmu_data(init, pmu.data_addr_pmu, pmu.data_addr, pmu.data_size);\r\nif (init_addr_pmu) {\r\n*init_addr_pmu = pmu.init_addr_pmu;\r\n*args_addr_pmu = pmu.args_addr_pmu;\r\nreturn 0;\r\n}\r\nreturn pmu_exec(init, pmu.init_addr_pmu), 0;\r\n}\r\nstatic int\r\ngm204_devinit_post(struct nvkm_devinit *base, bool post)\r\n{\r\nstruct nv50_devinit *init = nv50_devinit(base);\r\nstruct nvkm_subdev *subdev = &init->base.subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nstruct nvkm_bios *bios = device->bios;\r\nstruct bit_entry bit_I;\r\nu32 exec, args;\r\nint ret;\r\nif (bit_entry(bios, 'I', &bit_I) || bit_I.version != 1 ||\r\nbit_I.length < 0x1c) {\r\nnvkm_error(subdev, "VBIOS PMU init data not found\n");\r\nreturn -EINVAL;\r\n}\r\nif (post) {\r\nnvkm_mask(device, 0x000200, 0x00002000, 0x00000000);\r\nnvkm_mask(device, 0x000200, 0x00002000, 0x00002000);\r\nnvkm_rd32(device, 0x000200);\r\nwhile (nvkm_rd32(device, 0x10a10c) & 0x00000006) {\r\n}\r\n}\r\nret = pmu_load(init, 0x04, post, &exec, &args);\r\nif (ret)\r\nreturn ret;\r\nif (post) {\r\nu32 pmu = pmu_args(init, args + 0x08, 0x08);\r\nu32 img = nvbios_rd16(bios, bit_I.offset + 0x14);\r\nu32 len = nvbios_rd16(bios, bit_I.offset + 0x16);\r\npmu_data(init, pmu, img, len);\r\n}\r\nif (post) {\r\nu32 pmu = pmu_args(init, args + 0x08, 0x10);\r\nu32 img = nvbios_rd16(bios, bit_I.offset + 0x18);\r\nu32 len = nvbios_rd16(bios, bit_I.offset + 0x1a);\r\npmu_data(init, pmu, img, len);\r\n}\r\nif (post) {\r\nnvkm_wr32(device, 0x10a040, 0x00005000);\r\npmu_exec(init, exec);\r\nwhile (!(nvkm_rd32(device, 0x10a040) & 0x00002000)) {\r\n}\r\n}\r\nreturn pmu_load(init, 0x01, post, NULL, NULL);\r\n}\r\nint\r\ngm204_devinit_new(struct nvkm_device *device, int index,\r\nstruct nvkm_devinit **pinit)\r\n{\r\nreturn nv50_devinit_new_(&gm204_devinit, device, index, pinit);\r\n}
