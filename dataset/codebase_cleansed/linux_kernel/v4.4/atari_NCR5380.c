static void __init init_tags(struct NCR5380_hostdata *hostdata)\r\n{\r\nint target, lun;\r\nstruct tag_alloc *ta;\r\nif (!(hostdata->flags & FLAG_TAGGED_QUEUING))\r\nreturn;\r\nfor (target = 0; target < 8; ++target) {\r\nfor (lun = 0; lun < 8; ++lun) {\r\nta = &hostdata->TagAlloc[target][lun];\r\nbitmap_zero(ta->allocated, MAX_TAGS);\r\nta->nr_allocated = 0;\r\nta->queue_size = MAX_TAGS;\r\n}\r\n}\r\n}\r\nstatic int is_lun_busy(struct scsi_cmnd *cmd, int should_be_tagged)\r\n{\r\nu8 lun = cmd->device->lun;\r\nSETUP_HOSTDATA(cmd->device->host);\r\nif (hostdata->busy[cmd->device->id] & (1 << lun))\r\nreturn 1;\r\nif (!should_be_tagged ||\r\n!(hostdata->flags & FLAG_TAGGED_QUEUING) ||\r\n!cmd->device->tagged_supported)\r\nreturn 0;\r\nif (hostdata->TagAlloc[scmd_id(cmd)][lun].nr_allocated >=\r\nhostdata->TagAlloc[scmd_id(cmd)][lun].queue_size) {\r\ndprintk(NDEBUG_TAGS, "scsi%d: target %d lun %d: no free tags\n",\r\nH_NO(cmd), cmd->device->id, lun);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cmd_get_tag(struct scsi_cmnd *cmd, int should_be_tagged)\r\n{\r\nu8 lun = cmd->device->lun;\r\nSETUP_HOSTDATA(cmd->device->host);\r\nif (!should_be_tagged ||\r\n!(hostdata->flags & FLAG_TAGGED_QUEUING) ||\r\n!cmd->device->tagged_supported) {\r\ncmd->tag = TAG_NONE;\r\nhostdata->busy[cmd->device->id] |= (1 << lun);\r\ndprintk(NDEBUG_TAGS, "scsi%d: target %d lun %d now allocated by untagged "\r\n"command\n", H_NO(cmd), cmd->device->id, lun);\r\n} else {\r\nstruct tag_alloc *ta = &hostdata->TagAlloc[scmd_id(cmd)][lun];\r\ncmd->tag = find_first_zero_bit(ta->allocated, MAX_TAGS);\r\nset_bit(cmd->tag, ta->allocated);\r\nta->nr_allocated++;\r\ndprintk(NDEBUG_TAGS, "scsi%d: using tag %d for target %d lun %d "\r\n"(now %d tags in use)\n",\r\nH_NO(cmd), cmd->tag, cmd->device->id,\r\nlun, ta->nr_allocated);\r\n}\r\n}\r\nstatic void cmd_free_tag(struct scsi_cmnd *cmd)\r\n{\r\nu8 lun = cmd->device->lun;\r\nSETUP_HOSTDATA(cmd->device->host);\r\nif (cmd->tag == TAG_NONE) {\r\nhostdata->busy[cmd->device->id] &= ~(1 << lun);\r\ndprintk(NDEBUG_TAGS, "scsi%d: target %d lun %d untagged cmd finished\n",\r\nH_NO(cmd), cmd->device->id, lun);\r\n} else if (cmd->tag >= MAX_TAGS) {\r\nprintk(KERN_NOTICE "scsi%d: trying to free bad tag %d!\n",\r\nH_NO(cmd), cmd->tag);\r\n} else {\r\nstruct tag_alloc *ta = &hostdata->TagAlloc[scmd_id(cmd)][lun];\r\nclear_bit(cmd->tag, ta->allocated);\r\nta->nr_allocated--;\r\ndprintk(NDEBUG_TAGS, "scsi%d: freed tag %d for target %d lun %d\n",\r\nH_NO(cmd), cmd->tag, cmd->device->id, lun);\r\n}\r\n}\r\nstatic void free_all_tags(struct NCR5380_hostdata *hostdata)\r\n{\r\nint target, lun;\r\nstruct tag_alloc *ta;\r\nif (!(hostdata->flags & FLAG_TAGGED_QUEUING))\r\nreturn;\r\nfor (target = 0; target < 8; ++target) {\r\nfor (lun = 0; lun < 8; ++lun) {\r\nta = &hostdata->TagAlloc[target][lun];\r\nbitmap_zero(ta->allocated, MAX_TAGS);\r\nta->nr_allocated = 0;\r\n}\r\n}\r\n}\r\nstatic void merge_contiguous_buffers(struct scsi_cmnd *cmd)\r\n{\r\n#if !defined(CONFIG_SUN3)\r\nunsigned long endaddr;\r\n#if (NDEBUG & NDEBUG_MERGING)\r\nunsigned long oldlen = cmd->SCp.this_residual;\r\nint cnt = 1;\r\n#endif\r\nfor (endaddr = virt_to_phys(cmd->SCp.ptr + cmd->SCp.this_residual - 1) + 1;\r\ncmd->SCp.buffers_residual &&\r\nvirt_to_phys(sg_virt(&cmd->SCp.buffer[1])) == endaddr;) {\r\ndprintk(NDEBUG_MERGING, "VTOP(%p) == %08lx -> merging\n",\r\npage_address(sg_page(&cmd->SCp.buffer[1])), endaddr);\r\n#if (NDEBUG & NDEBUG_MERGING)\r\n++cnt;\r\n#endif\r\n++cmd->SCp.buffer;\r\n--cmd->SCp.buffers_residual;\r\ncmd->SCp.this_residual += cmd->SCp.buffer->length;\r\nendaddr += cmd->SCp.buffer->length;\r\n}\r\n#if (NDEBUG & NDEBUG_MERGING)\r\nif (oldlen != cmd->SCp.this_residual)\r\ndprintk(NDEBUG_MERGING, "merged %d buffers from %p, new length %08x\n",\r\ncnt, cmd->SCp.ptr, cmd->SCp.this_residual);\r\n#endif\r\n#endif\r\n}\r\nstatic inline void initialize_SCp(struct scsi_cmnd *cmd)\r\n{\r\nif (scsi_bufflen(cmd)) {\r\ncmd->SCp.buffer = scsi_sglist(cmd);\r\ncmd->SCp.buffers_residual = scsi_sg_count(cmd) - 1;\r\ncmd->SCp.ptr = sg_virt(cmd->SCp.buffer);\r\ncmd->SCp.this_residual = cmd->SCp.buffer->length;\r\nmerge_contiguous_buffers(cmd);\r\n} else {\r\ncmd->SCp.buffer = NULL;\r\ncmd->SCp.buffers_residual = 0;\r\ncmd->SCp.ptr = NULL;\r\ncmd->SCp.this_residual = 0;\r\n}\r\n}\r\nstatic void NCR5380_print(struct Scsi_Host *instance)\r\n{\r\nunsigned char status, data, basr, mr, icr, i;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ndata = NCR5380_read(CURRENT_SCSI_DATA_REG);\r\nstatus = NCR5380_read(STATUS_REG);\r\nmr = NCR5380_read(MODE_REG);\r\nicr = NCR5380_read(INITIATOR_COMMAND_REG);\r\nbasr = NCR5380_read(BUS_AND_STATUS_REG);\r\nlocal_irq_restore(flags);\r\nprintk("STATUS_REG: %02x ", status);\r\nfor (i = 0; signals[i].mask; ++i)\r\nif (status & signals[i].mask)\r\nprintk(",%s", signals[i].name);\r\nprintk("\nBASR: %02x ", basr);\r\nfor (i = 0; basrs[i].mask; ++i)\r\nif (basr & basrs[i].mask)\r\nprintk(",%s", basrs[i].name);\r\nprintk("\nICR: %02x ", icr);\r\nfor (i = 0; icrs[i].mask; ++i)\r\nif (icr & icrs[i].mask)\r\nprintk(",%s", icrs[i].name);\r\nprintk("\nMODE: %02x ", mr);\r\nfor (i = 0; mrs[i].mask; ++i)\r\nif (mr & mrs[i].mask)\r\nprintk(",%s", mrs[i].name);\r\nprintk("\n");\r\n}\r\nstatic void NCR5380_print_phase(struct Scsi_Host *instance)\r\n{\r\nunsigned char status;\r\nint i;\r\nstatus = NCR5380_read(STATUS_REG);\r\nif (!(status & SR_REQ))\r\nprintk(KERN_DEBUG "scsi%d: REQ not asserted, phase unknown.\n", HOSTNO);\r\nelse {\r\nfor (i = 0; (phases[i].value != PHASE_UNKNOWN) &&\r\n(phases[i].value != (status & PHASE_MASK)); ++i)\r\n;\r\nprintk(KERN_DEBUG "scsi%d: phase %s\n", HOSTNO, phases[i].name);\r\n}\r\n}\r\nstatic inline void queue_main(struct NCR5380_hostdata *hostdata)\r\n{\r\nif (!hostdata->main_running) {\r\nschedule_work(&hostdata->main_task);\r\n}\r\n}\r\nstatic const char *NCR5380_info(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nreturn hostdata->info;\r\n}\r\nstatic void prepare_info(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nsnprintf(hostdata->info, sizeof(hostdata->info),\r\n"%s, io_port 0x%lx, n_io_port %d, "\r\n"base 0x%lx, irq %d, "\r\n"can_queue %d, cmd_per_lun %d, "\r\n"sg_tablesize %d, this_id %d, "\r\n"flags { %s}, "\r\n"options { %s} ",\r\ninstance->hostt->name, instance->io_port, instance->n_io_port,\r\ninstance->base, instance->irq,\r\ninstance->can_queue, instance->cmd_per_lun,\r\ninstance->sg_tablesize, instance->this_id,\r\nhostdata->flags & FLAG_TAGGED_QUEUING ? "TAGGED_QUEUING " : "",\r\n#ifdef DIFFERENTIAL\r\n"DIFFERENTIAL "\r\n#endif\r\n#ifdef REAL_DMA\r\n"REAL_DMA "\r\n#endif\r\n#ifdef PARITY\r\n"PARITY "\r\n#endif\r\n#ifdef SUPPORT_TAGS\r\n"SUPPORT_TAGS "\r\n#endif\r\n"");\r\n}\r\nstatic void lprint_Scsi_Cmnd(struct scsi_cmnd *cmd)\r\n{\r\nint i, s;\r\nunsigned char *command;\r\nprintk("scsi%d: destination target %d, lun %llu\n",\r\nH_NO(cmd), cmd->device->id, cmd->device->lun);\r\nprintk(KERN_CONT " command = ");\r\ncommand = cmd->cmnd;\r\nprintk(KERN_CONT "%2d (0x%02x)", command[0], command[0]);\r\nfor (i = 1, s = COMMAND_SIZE(command[0]); i < s; ++i)\r\nprintk(KERN_CONT " %02x", command[i]);\r\nprintk("\n");\r\n}\r\nstatic void NCR5380_print_status(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata;\r\nstruct scsi_cmnd *ptr;\r\nunsigned long flags;\r\nNCR5380_dprint(NDEBUG_ANY, instance);\r\nNCR5380_dprint_phase(NDEBUG_ANY, instance);\r\nhostdata = (struct NCR5380_hostdata *)instance->hostdata;\r\nlocal_irq_save(flags);\r\nprintk("NCR5380: coroutine is%s running.\n",\r\nhostdata->main_running ? "" : "n't");\r\nif (!hostdata->connected)\r\nprintk("scsi%d: no currently connected command\n", HOSTNO);\r\nelse\r\nlprint_Scsi_Cmnd((struct scsi_cmnd *) hostdata->connected);\r\nprintk("scsi%d: issue_queue\n", HOSTNO);\r\nfor (ptr = (struct scsi_cmnd *)hostdata->issue_queue; ptr; ptr = NEXT(ptr))\r\nlprint_Scsi_Cmnd(ptr);\r\nprintk("scsi%d: disconnected_queue\n", HOSTNO);\r\nfor (ptr = (struct scsi_cmnd *) hostdata->disconnected_queue; ptr;\r\nptr = NEXT(ptr))\r\nlprint_Scsi_Cmnd(ptr);\r\nlocal_irq_restore(flags);\r\nprintk("\n");\r\n}\r\nstatic void show_Scsi_Cmnd(struct scsi_cmnd *cmd, struct seq_file *m)\r\n{\r\nint i, s;\r\nunsigned char *command;\r\nseq_printf(m, "scsi%d: destination target %d, lun %llu\n",\r\nH_NO(cmd), cmd->device->id, cmd->device->lun);\r\nseq_puts(m, " command = ");\r\ncommand = cmd->cmnd;\r\nseq_printf(m, "%2d (0x%02x)", command[0], command[0]);\r\nfor (i = 1, s = COMMAND_SIZE(command[0]); i < s; ++i)\r\nseq_printf(m, " %02x", command[i]);\r\nseq_putc(m, '\n');\r\n}\r\nstatic int __maybe_unused NCR5380_show_info(struct seq_file *m,\r\nstruct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata;\r\nstruct scsi_cmnd *ptr;\r\nunsigned long flags;\r\nhostdata = (struct NCR5380_hostdata *)instance->hostdata;\r\nlocal_irq_save(flags);\r\nseq_printf(m, "NCR5380: coroutine is%s running.\n",\r\nhostdata->main_running ? "" : "n't");\r\nif (!hostdata->connected)\r\nseq_printf(m, "scsi%d: no currently connected command\n", HOSTNO);\r\nelse\r\nshow_Scsi_Cmnd((struct scsi_cmnd *) hostdata->connected, m);\r\nseq_printf(m, "scsi%d: issue_queue\n", HOSTNO);\r\nfor (ptr = (struct scsi_cmnd *)hostdata->issue_queue; ptr; ptr = NEXT(ptr))\r\nshow_Scsi_Cmnd(ptr, m);\r\nseq_printf(m, "scsi%d: disconnected_queue\n", HOSTNO);\r\nfor (ptr = (struct scsi_cmnd *) hostdata->disconnected_queue; ptr;\r\nptr = NEXT(ptr))\r\nshow_Scsi_Cmnd(ptr, m);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int __init NCR5380_init(struct Scsi_Host *instance, int flags)\r\n{\r\nint i;\r\nSETUP_HOSTDATA(instance);\r\nhostdata->host = instance;\r\nhostdata->aborted = 0;\r\nhostdata->id_mask = 1 << instance->this_id;\r\nhostdata->id_higher_mask = 0;\r\nfor (i = hostdata->id_mask; i <= 0x80; i <<= 1)\r\nif (i > hostdata->id_mask)\r\nhostdata->id_higher_mask |= i;\r\nfor (i = 0; i < 8; ++i)\r\nhostdata->busy[i] = 0;\r\n#ifdef SUPPORT_TAGS\r\ninit_tags(hostdata);\r\n#endif\r\n#if defined (REAL_DMA)\r\nhostdata->dma_len = 0;\r\n#endif\r\nhostdata->targets_present = 0;\r\nhostdata->connected = NULL;\r\nhostdata->issue_queue = NULL;\r\nhostdata->disconnected_queue = NULL;\r\nhostdata->flags = flags;\r\nINIT_WORK(&hostdata->main_task, NCR5380_main);\r\nprepare_info(instance);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(TARGET_COMMAND_REG, 0);\r\nNCR5380_write(SELECT_ENABLE_REG, 0);\r\nreturn 0;\r\n}\r\nstatic void NCR5380_exit(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\ncancel_work_sync(&hostdata->main_task);\r\n}\r\nstatic int NCR5380_queue_command(struct Scsi_Host *instance,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nstruct scsi_cmnd *tmp;\r\nunsigned long flags;\r\n#if (NDEBUG & NDEBUG_NO_WRITE)\r\nswitch (cmd->cmnd[0]) {\r\ncase WRITE_6:\r\ncase WRITE_10:\r\nprintk(KERN_NOTICE "scsi%d: WRITE attempted with NO_WRITE debugging flag set\n",\r\nH_NO(cmd));\r\ncmd->result = (DID_ERROR << 16);\r\ncmd->scsi_done(cmd);\r\nreturn 0;\r\n}\r\n#endif\r\nSET_NEXT(cmd, NULL);\r\ncmd->result = 0;\r\nif (!NCR5380_acquire_dma_irq(instance))\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nlocal_irq_save(flags);\r\nif (!(hostdata->issue_queue) || (cmd->cmnd[0] == REQUEST_SENSE)) {\r\nLIST(cmd, hostdata->issue_queue);\r\nSET_NEXT(cmd, hostdata->issue_queue);\r\nhostdata->issue_queue = cmd;\r\n} else {\r\nfor (tmp = (struct scsi_cmnd *)hostdata->issue_queue;\r\nNEXT(tmp); tmp = NEXT(tmp))\r\n;\r\nLIST(cmd, tmp);\r\nSET_NEXT(tmp, cmd);\r\n}\r\nlocal_irq_restore(flags);\r\ndprintk(NDEBUG_QUEUES, "scsi%d: command added to %s of queue\n", H_NO(cmd),\r\n(cmd->cmnd[0] == REQUEST_SENSE) ? "head" : "tail");\r\nif (in_interrupt() || irqs_disabled())\r\nqueue_main(hostdata);\r\nelse\r\nNCR5380_main(&hostdata->main_task);\r\nreturn 0;\r\n}\r\nstatic inline void maybe_release_dma_irq(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nif (!hostdata->disconnected_queue &&\r\n!hostdata->issue_queue &&\r\n!hostdata->connected &&\r\n!hostdata->retain_dma_intr)\r\nNCR5380_release_dma_irq(instance);\r\n}\r\nstatic void NCR5380_main(struct work_struct *work)\r\n{\r\nstruct NCR5380_hostdata *hostdata =\r\ncontainer_of(work, struct NCR5380_hostdata, main_task);\r\nstruct Scsi_Host *instance = hostdata->host;\r\nstruct scsi_cmnd *tmp, *prev;\r\nint done;\r\nunsigned long flags;\r\nif (hostdata->main_running)\r\nreturn;\r\nhostdata->main_running = 1;\r\nlocal_save_flags(flags);\r\ndo {\r\nlocal_irq_disable();\r\ndone = 1;\r\nif (!hostdata->connected) {\r\ndprintk(NDEBUG_MAIN, "scsi%d: not connected\n", HOSTNO);\r\n#if (NDEBUG & NDEBUG_LISTS)\r\nfor (tmp = (struct scsi_cmnd *) hostdata->issue_queue, prev = NULL;\r\ntmp && (tmp != prev); prev = tmp, tmp = NEXT(tmp))\r\n;\r\nif ((tmp == prev) && tmp)\r\nprintk(" LOOP\n");\r\n#endif\r\nfor (tmp = (struct scsi_cmnd *) hostdata->issue_queue,\r\nprev = NULL; tmp; prev = tmp, tmp = NEXT(tmp)) {\r\nu8 lun = tmp->device->lun;\r\ndprintk(NDEBUG_LISTS,\r\n"MAIN tmp=%p target=%d busy=%d lun=%d\n",\r\ntmp, scmd_id(tmp), hostdata->busy[scmd_id(tmp)],\r\nlun);\r\nif (\r\n#ifdef SUPPORT_TAGS\r\n!is_lun_busy( tmp, tmp->cmnd[0] != REQUEST_SENSE)\r\n#else\r\n!(hostdata->busy[tmp->device->id] & (1 << lun))\r\n#endif\r\n) {\r\nlocal_irq_disable();\r\nif (prev) {\r\nREMOVE(prev, NEXT(prev), tmp, NEXT(tmp));\r\nSET_NEXT(prev, NEXT(tmp));\r\n} else {\r\nREMOVE(-1, hostdata->issue_queue, tmp, NEXT(tmp));\r\nhostdata->issue_queue = NEXT(tmp);\r\n}\r\nSET_NEXT(tmp, NULL);\r\nhostdata->retain_dma_intr++;\r\nlocal_irq_restore(flags);\r\ndprintk(NDEBUG_MAIN, "scsi%d: main(): command for target %d "\r\n"lun %d removed from issue_queue\n",\r\nHOSTNO, tmp->device->id, lun);\r\n#ifdef SUPPORT_TAGS\r\ncmd_get_tag(tmp, tmp->cmnd[0] != REQUEST_SENSE);\r\n#endif\r\nif (!NCR5380_select(instance, tmp)) {\r\nlocal_irq_disable();\r\nhostdata->retain_dma_intr--;\r\nmaybe_release_dma_irq(instance);\r\nlocal_irq_restore(flags);\r\nbreak;\r\n} else {\r\nlocal_irq_disable();\r\nLIST(tmp, hostdata->issue_queue);\r\nSET_NEXT(tmp, hostdata->issue_queue);\r\nhostdata->issue_queue = tmp;\r\n#ifdef SUPPORT_TAGS\r\ncmd_free_tag(tmp);\r\n#endif\r\nhostdata->retain_dma_intr--;\r\nlocal_irq_restore(flags);\r\ndprintk(NDEBUG_MAIN, "scsi%d: main(): select() failed, "\r\n"returned to issue_queue\n", HOSTNO);\r\nif (hostdata->connected)\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nif (hostdata->connected\r\n#ifdef REAL_DMA\r\n&& !hostdata->dma_len\r\n#endif\r\n) {\r\nlocal_irq_restore(flags);\r\ndprintk(NDEBUG_MAIN, "scsi%d: main: performing information transfer\n",\r\nHOSTNO);\r\nNCR5380_information_transfer(instance);\r\ndprintk(NDEBUG_MAIN, "scsi%d: main: done set false\n", HOSTNO);\r\ndone = 0;\r\n}\r\n} while (!done);\r\nhostdata->main_running = 0;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void NCR5380_dma_complete(struct Scsi_Host *instance)\r\n{\r\nSETUP_HOSTDATA(instance);\r\nint transferred;\r\nunsigned char **data;\r\nvolatile int *count;\r\nint saved_data = 0, overrun = 0;\r\nunsigned char p;\r\nif (!hostdata->connected) {\r\nprintk(KERN_WARNING "scsi%d: received end of DMA interrupt with "\r\n"no connected cmd\n", HOSTNO);\r\nreturn;\r\n}\r\nif (hostdata->read_overruns) {\r\np = hostdata->connected->SCp.phase;\r\nif (p & SR_IO) {\r\nudelay(10);\r\nif ((NCR5380_read(BUS_AND_STATUS_REG) &\r\n(BASR_PHASE_MATCH|BASR_ACK)) ==\r\n(BASR_PHASE_MATCH|BASR_ACK)) {\r\nsaved_data = NCR5380_read(INPUT_DATA_REG);\r\noverrun = 1;\r\ndprintk(NDEBUG_DMA, "scsi%d: read overrun handled\n", HOSTNO);\r\n}\r\n}\r\n}\r\ndprintk(NDEBUG_DMA, "scsi%d: real DMA transfer complete, basr 0x%X, sr 0x%X\n",\r\nHOSTNO, NCR5380_read(BUS_AND_STATUS_REG),\r\nNCR5380_read(STATUS_REG));\r\n#if defined(CONFIG_SUN3)\r\nif ((sun3scsi_dma_finish(rq_data_dir(hostdata->connected->request)))) {\r\npr_err("scsi%d: overrun in UDC counter -- not prepared to deal with this!\n",\r\ninstance->host_no);\r\nBUG();\r\n}\r\nif ((NCR5380_read(BUS_AND_STATUS_REG) & (BASR_PHASE_MATCH | BASR_ACK)) ==\r\n(BASR_PHASE_MATCH | BASR_ACK)) {\r\npr_err("scsi%d: BASR %02x\n", instance->host_no,\r\nNCR5380_read(BUS_AND_STATUS_REG));\r\npr_err("scsi%d: bus stuck in data phase -- probably a single byte overrun!\n",\r\ninstance->host_no);\r\nBUG();\r\n}\r\n#endif\r\n(void)NCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\ntransferred = hostdata->dma_len - NCR5380_dma_residual(instance);\r\nhostdata->dma_len = 0;\r\ndata = (unsigned char **)&hostdata->connected->SCp.ptr;\r\ncount = &hostdata->connected->SCp.this_residual;\r\n*data += transferred;\r\n*count -= transferred;\r\nif (hostdata->read_overruns) {\r\nint cnt, toPIO;\r\nif ((NCR5380_read(STATUS_REG) & PHASE_MASK) == p && (p & SR_IO)) {\r\ncnt = toPIO = hostdata->read_overruns;\r\nif (overrun) {\r\ndprintk(NDEBUG_DMA, "Got an input overrun, using saved byte\n");\r\n*(*data)++ = saved_data;\r\n(*count)--;\r\ncnt--;\r\ntoPIO--;\r\n}\r\ndprintk(NDEBUG_DMA, "Doing %d-byte PIO to 0x%08lx\n", cnt, (long)*data);\r\nNCR5380_transfer_pio(instance, &p, &cnt, data);\r\n*count -= toPIO - cnt;\r\n}\r\n}\r\n}\r\nstatic irqreturn_t NCR5380_intr(int irq, void *dev_id)\r\n{\r\nstruct Scsi_Host *instance = dev_id;\r\nint done = 1, handled = 0;\r\nunsigned char basr;\r\ndprintk(NDEBUG_INTR, "scsi%d: NCR5380 irq triggered\n", HOSTNO);\r\nbasr = NCR5380_read(BUS_AND_STATUS_REG);\r\ndprintk(NDEBUG_INTR, "scsi%d: BASR=%02x\n", HOSTNO, basr);\r\nif (basr & BASR_IRQ) {\r\nNCR5380_dprint(NDEBUG_INTR, instance);\r\nif ((NCR5380_read(STATUS_REG) & (SR_SEL|SR_IO)) == (SR_SEL|SR_IO)) {\r\ndone = 0;\r\ndprintk(NDEBUG_INTR, "scsi%d: SEL interrupt\n", HOSTNO);\r\nNCR5380_reselect(instance);\r\n(void)NCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\n} else if (basr & BASR_PARITY_ERROR) {\r\ndprintk(NDEBUG_INTR, "scsi%d: PARITY interrupt\n", HOSTNO);\r\n(void)NCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\n} else if ((NCR5380_read(STATUS_REG) & SR_RST) == SR_RST) {\r\ndprintk(NDEBUG_INTR, "scsi%d: RESET interrupt\n", HOSTNO);\r\n(void)NCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\n} else {\r\n#if defined(REAL_DMA)\r\nif ((NCR5380_read(MODE_REG) & MR_DMA_MODE) &&\r\n((basr & BASR_END_DMA_TRANSFER) ||\r\n!(basr & BASR_PHASE_MATCH))) {\r\ndprintk(NDEBUG_INTR, "scsi%d: PHASE MISM or EOP interrupt\n", HOSTNO);\r\nNCR5380_dma_complete( instance );\r\ndone = 0;\r\n} else\r\n#endif\r\n{\r\nif (basr & BASR_PHASE_MATCH)\r\ndprintk(NDEBUG_INTR, "scsi%d: unknown interrupt, "\r\n"BASR 0x%x, MR 0x%x, SR 0x%x\n",\r\nHOSTNO, basr, NCR5380_read(MODE_REG),\r\nNCR5380_read(STATUS_REG));\r\n(void)NCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr |= CSR_DMA_ENABLE;\r\n#endif\r\n}\r\n}\r\nhandled = 1;\r\n} else {\r\nprintk(KERN_NOTICE "scsi%d: interrupt without IRQ bit set in BASR, "\r\n"BASR 0x%X, MR 0x%X, SR 0x%x\n", HOSTNO, basr,\r\nNCR5380_read(MODE_REG), NCR5380_read(STATUS_REG));\r\n(void)NCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr |= CSR_DMA_ENABLE;\r\n#endif\r\n}\r\nif (!done) {\r\ndprintk(NDEBUG_INTR, "scsi%d: in int routine, calling main\n", HOSTNO);\r\nqueue_main(shost_priv(instance));\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int NCR5380_select(struct Scsi_Host *instance, struct scsi_cmnd *cmd)\r\n{\r\nSETUP_HOSTDATA(instance);\r\nunsigned char tmp[3], phase;\r\nunsigned char *data;\r\nint len;\r\nunsigned long timeout;\r\nunsigned long flags;\r\nhostdata->restart_select = 0;\r\nNCR5380_dprint(NDEBUG_ARBITRATION, instance);\r\ndprintk(NDEBUG_ARBITRATION, "scsi%d: starting arbitration, id = %d\n", HOSTNO,\r\ninstance->this_id);\r\nlocal_irq_save(flags);\r\nif (hostdata->connected) {\r\nlocal_irq_restore(flags);\r\nreturn -1;\r\n}\r\nNCR5380_write(TARGET_COMMAND_REG, 0);\r\nNCR5380_write(OUTPUT_DATA_REG, hostdata->id_mask);\r\nNCR5380_write(MODE_REG, MR_ARBITRATE);\r\nlocal_irq_restore(flags);\r\n#if defined(NCR_TIMEOUT)\r\n{\r\nunsigned long timeout = jiffies + 2*NCR_TIMEOUT;\r\nwhile (!(NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_PROGRESS) &&\r\ntime_before(jiffies, timeout) && !hostdata->connected)\r\n;\r\nif (time_after_eq(jiffies, timeout)) {\r\nprintk("scsi : arbitration timeout at %d\n", __LINE__);\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nreturn -1;\r\n}\r\n}\r\n#else\r\nwhile (!(NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_PROGRESS) &&\r\n!hostdata->connected)\r\n;\r\n#endif\r\ndprintk(NDEBUG_ARBITRATION, "scsi%d: arbitration complete\n", HOSTNO);\r\nif (hostdata->connected) {\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nreturn -1;\r\n}\r\nudelay(3);\r\nif ((NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_LOST) ||\r\n(NCR5380_read(CURRENT_SCSI_DATA_REG) & hostdata->id_higher_mask) ||\r\n(NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_LOST) ||\r\nhostdata->connected) {\r\nNCR5380_write(MODE_REG, MR_BASE);\r\ndprintk(NDEBUG_ARBITRATION, "scsi%d: lost arbitration, deasserting MR_ARBITRATE\n",\r\nHOSTNO);\r\nreturn -1;\r\n}\r\nNCR5380_write(INITIATOR_COMMAND_REG,\r\nICR_BASE | ICR_ASSERT_SEL | ICR_ASSERT_BSY);\r\nif ((NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_LOST) ||\r\nhostdata->connected) {\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\ndprintk(NDEBUG_ARBITRATION, "scsi%d: lost arbitration, deasserting ICR_ASSERT_SEL\n",\r\nHOSTNO);\r\nreturn -1;\r\n}\r\n#ifdef CONFIG_ATARI_SCSI_TOSHIBA_DELAY\r\nudelay(15);\r\n#else\r\nudelay(2);\r\n#endif\r\nif (hostdata->connected) {\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nreturn -1;\r\n}\r\ndprintk(NDEBUG_ARBITRATION, "scsi%d: won arbitration\n", HOSTNO);\r\nNCR5380_write(OUTPUT_DATA_REG, (hostdata->id_mask | (1 << cmd->device->id)));\r\nNCR5380_write(INITIATOR_COMMAND_REG, (ICR_BASE | ICR_ASSERT_BSY |\r\nICR_ASSERT_DATA | ICR_ASSERT_ATN | ICR_ASSERT_SEL ));\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nif (hostdata->connected) {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nreturn -1;\r\n}\r\nNCR5380_write(SELECT_ENABLE_REG, 0);\r\nudelay(1);\r\nNCR5380_write(INITIATOR_COMMAND_REG, (ICR_BASE | ICR_ASSERT_DATA |\r\nICR_ASSERT_ATN | ICR_ASSERT_SEL));\r\nudelay(1);\r\ndprintk(NDEBUG_SELECTION, "scsi%d: selecting target %d\n", HOSTNO, cmd->device->id);\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\n#if 0\r\nwhile (time_before(jiffies, timeout) &&\r\n!(NCR5380_read(STATUS_REG) & (SR_BSY | SR_IO)))\r\n;\r\nif ((NCR5380_read(STATUS_REG) & (SR_SEL | SR_IO)) == (SR_SEL | SR_IO)) {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nNCR5380_reselect(instance);\r\nprintk(KERN_ERR "scsi%d: reselection after won arbitration?\n",\r\nHOSTNO);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nreturn -1;\r\n}\r\n#else\r\nwhile (time_before(jiffies, timeout) && !(NCR5380_read(STATUS_REG) & SR_BSY))\r\n;\r\n#endif\r\nudelay(1);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\r\nif (!(NCR5380_read(STATUS_REG) & SR_BSY)) {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nif (hostdata->targets_present & (1 << cmd->device->id)) {\r\nprintk(KERN_ERR "scsi%d: weirdness\n", HOSTNO);\r\nif (hostdata->restart_select)\r\nprintk(KERN_NOTICE "\trestart select\n");\r\nNCR5380_dprint(NDEBUG_ANY, instance);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nreturn -1;\r\n}\r\ncmd->result = DID_BAD_TARGET << 16;\r\n#ifdef SUPPORT_TAGS\r\ncmd_free_tag(cmd);\r\n#endif\r\ncmd->scsi_done(cmd);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\ndprintk(NDEBUG_SELECTION, "scsi%d: target did not respond within 250ms\n", HOSTNO);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nreturn 0;\r\n}\r\nhostdata->targets_present |= (1 << cmd->device->id);\r\nwhile (!(NCR5380_read(STATUS_REG) & SR_REQ))\r\n;\r\ndprintk(NDEBUG_SELECTION, "scsi%d: target %d selected, going into MESSAGE OUT phase.\n",\r\nHOSTNO, cmd->device->id);\r\ntmp[0] = IDENTIFY(1, cmd->device->lun);\r\n#ifdef SUPPORT_TAGS\r\nif (cmd->tag != TAG_NONE) {\r\ntmp[1] = hostdata->last_message = SIMPLE_QUEUE_TAG;\r\ntmp[2] = cmd->tag;\r\nlen = 3;\r\n} else\r\nlen = 1;\r\n#else\r\nlen = 1;\r\ncmd->tag = 0;\r\n#endif\r\ndata = tmp;\r\nphase = PHASE_MSGOUT;\r\nNCR5380_transfer_pio(instance, &phase, &len, &data);\r\ndprintk(NDEBUG_SELECTION, "scsi%d: nexus established.\n", HOSTNO);\r\nhostdata->connected = cmd;\r\n#ifndef SUPPORT_TAGS\r\nhostdata->busy[cmd->device->id] |= (1 << cmd->device->lun);\r\n#endif\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr |= CSR_INTR;\r\n#endif\r\ninitialize_SCp(cmd);\r\nreturn 0;\r\n}\r\nstatic int NCR5380_transfer_pio(struct Scsi_Host *instance,\r\nunsigned char *phase, int *count,\r\nunsigned char **data)\r\n{\r\nregister unsigned char p = *phase, tmp;\r\nregister int c = *count;\r\nregister unsigned char *d = *data;\r\nNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(p));\r\ndo {\r\nwhile (!((tmp = NCR5380_read(STATUS_REG)) & SR_REQ))\r\n;\r\ndprintk(NDEBUG_HANDSHAKE, "scsi%d: REQ detected\n", HOSTNO);\r\nif ((tmp & PHASE_MASK) != p) {\r\ndprintk(NDEBUG_PIO, "scsi%d: phase mismatch\n", HOSTNO);\r\nNCR5380_dprint_phase(NDEBUG_PIO, instance);\r\nbreak;\r\n}\r\nif (!(p & SR_IO))\r\nNCR5380_write(OUTPUT_DATA_REG, *d);\r\nelse\r\n*d = NCR5380_read(CURRENT_SCSI_DATA_REG);\r\n++d;\r\nif (!(p & SR_IO)) {\r\nif (!((p & SR_MSG) && c > 1)) {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA);\r\nNCR5380_dprint(NDEBUG_PIO, instance);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |\r\nICR_ASSERT_DATA | ICR_ASSERT_ACK);\r\n} else {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |\r\nICR_ASSERT_DATA | ICR_ASSERT_ATN);\r\nNCR5380_dprint(NDEBUG_PIO, instance);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |\r\nICR_ASSERT_DATA | ICR_ASSERT_ATN | ICR_ASSERT_ACK);\r\n}\r\n} else {\r\nNCR5380_dprint(NDEBUG_PIO, instance);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ACK);\r\n}\r\nwhile (NCR5380_read(STATUS_REG) & SR_REQ)\r\n;\r\ndprintk(NDEBUG_HANDSHAKE, "scsi%d: req false, handshake complete\n", HOSTNO);\r\nif (!(p == PHASE_MSGIN && c == 1)) {\r\nif (p == PHASE_MSGOUT && c > 1)\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\r\nelse\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\n}\r\n} while (--c);\r\ndprintk(NDEBUG_PIO, "scsi%d: residual %d\n", HOSTNO, c);\r\n*count = c;\r\n*data = d;\r\ntmp = NCR5380_read(STATUS_REG);\r\nif ((tmp & SR_REQ) || (p == PHASE_MSGIN && c == 0))\r\n*phase = tmp & PHASE_MASK;\r\nelse\r\n*phase = PHASE_UNKNOWN;\r\nif (!c || (*phase == p))\r\nreturn 0;\r\nelse\r\nreturn -1;\r\n}\r\nstatic int do_abort(struct Scsi_Host *instance)\r\n{\r\nunsigned char tmp, *msgptr, phase;\r\nint len;\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\r\nwhile (!((tmp = NCR5380_read(STATUS_REG)) & SR_REQ))\r\n;\r\nNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(tmp));\r\nif ((tmp & PHASE_MASK) != PHASE_MSGOUT) {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN |\r\nICR_ASSERT_ACK);\r\nwhile (NCR5380_read(STATUS_REG) & SR_REQ)\r\n;\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\r\n}\r\ntmp = ABORT;\r\nmsgptr = &tmp;\r\nlen = 1;\r\nphase = PHASE_MSGOUT;\r\nNCR5380_transfer_pio(instance, &phase, &len, &msgptr);\r\nreturn len ? -1 : 0;\r\n}\r\nstatic int NCR5380_transfer_dma(struct Scsi_Host *instance,\r\nunsigned char *phase, int *count,\r\nunsigned char **data)\r\n{\r\nSETUP_HOSTDATA(instance);\r\nregister int c = *count;\r\nregister unsigned char p = *phase;\r\nunsigned long flags;\r\n#if defined(CONFIG_SUN3)\r\nif (!sun3_dma_setup_done) {\r\npr_err("scsi%d: transfer_dma without setup!\n",\r\ninstance->host_no);\r\nBUG();\r\n}\r\nhostdata->dma_len = c;\r\ndprintk(NDEBUG_DMA, "scsi%d: initializing DMA for %s, %d bytes %s %p\n",\r\ninstance->host_no, (p & SR_IO) ? "reading" : "writing",\r\nc, (p & SR_IO) ? "to" : "from", *data);\r\nlocal_irq_save(flags);\r\nsun3scsi_dma_start(c, *data);\r\nif (p & SR_IO) {\r\nNCR5380_write(TARGET_COMMAND_REG, 1);\r\nNCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\nNCR5380_write(INITIATOR_COMMAND_REG, 0);\r\nNCR5380_write(MODE_REG,\r\n(NCR5380_read(MODE_REG) | MR_DMA_MODE | MR_ENABLE_EOP_INTR));\r\nNCR5380_write(START_DMA_INITIATOR_RECEIVE_REG, 0);\r\n} else {\r\nNCR5380_write(TARGET_COMMAND_REG, 0);\r\nNCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_ASSERT_DATA);\r\nNCR5380_write(MODE_REG,\r\n(NCR5380_read(MODE_REG) | MR_DMA_MODE | MR_ENABLE_EOP_INTR));\r\nNCR5380_write(START_DMA_SEND_REG, 0);\r\n}\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr |= CSR_DMA_ENABLE;\r\n#endif\r\nlocal_irq_restore(flags);\r\nsun3_dma_active = 1;\r\n#else\r\nregister unsigned char *d = *data;\r\nunsigned char tmp;\r\nif ((tmp = (NCR5380_read(STATUS_REG) & PHASE_MASK)) != p) {\r\n*phase = tmp;\r\nreturn -1;\r\n}\r\nif (hostdata->read_overruns && (p & SR_IO))\r\nc -= hostdata->read_overruns;\r\ndprintk(NDEBUG_DMA, "scsi%d: initializing DMA for %s, %d bytes %s %p\n",\r\nHOSTNO, (p & SR_IO) ? "reading" : "writing",\r\nc, (p & SR_IO) ? "to" : "from", d);\r\nNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(p));\r\n#ifdef REAL_DMA\r\nNCR5380_write(MODE_REG, MR_BASE | MR_DMA_MODE | MR_ENABLE_EOP_INTR | MR_MONITOR_BSY);\r\n#endif\r\nif (!(hostdata->flags & FLAG_LATE_DMA_SETUP)) {\r\nlocal_irq_save(flags);\r\nhostdata->dma_len = (p & SR_IO) ?\r\nNCR5380_dma_read_setup(instance, d, c) :\r\nNCR5380_dma_write_setup(instance, d, c);\r\nlocal_irq_restore(flags);\r\n}\r\nif (p & SR_IO)\r\nNCR5380_write(START_DMA_INITIATOR_RECEIVE_REG, 0);\r\nelse {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA);\r\nNCR5380_write(START_DMA_SEND_REG, 0);\r\n}\r\nif (hostdata->flags & FLAG_LATE_DMA_SETUP) {\r\nlocal_irq_save(flags);\r\nhostdata->dma_len = (p & SR_IO) ?\r\nNCR5380_dma_read_setup(instance, d, c) :\r\nNCR5380_dma_write_setup(instance, d, c);\r\nlocal_irq_restore(flags);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void NCR5380_information_transfer(struct Scsi_Host *instance)\r\n{\r\nSETUP_HOSTDATA(instance);\r\nunsigned long flags;\r\nunsigned char msgout = NOP;\r\nint sink = 0;\r\nint len;\r\n#if defined(REAL_DMA)\r\nint transfersize;\r\n#endif\r\nunsigned char *data;\r\nunsigned char phase, tmp, extended_msg[10], old_phase = 0xff;\r\nstruct scsi_cmnd *cmd = (struct scsi_cmnd *) hostdata->connected;\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr |= CSR_INTR;\r\n#endif\r\nwhile (1) {\r\ntmp = NCR5380_read(STATUS_REG);\r\nif (tmp & SR_REQ) {\r\nphase = (tmp & PHASE_MASK);\r\nif (phase != old_phase) {\r\nold_phase = phase;\r\nNCR5380_dprint_phase(NDEBUG_INFORMATION, instance);\r\n}\r\n#if defined(CONFIG_SUN3)\r\nif (phase == PHASE_CMDOUT) {\r\n#if defined(REAL_DMA)\r\nvoid *d;\r\nunsigned long count;\r\nif (!cmd->SCp.this_residual && cmd->SCp.buffers_residual) {\r\ncount = cmd->SCp.buffer->length;\r\nd = sg_virt(cmd->SCp.buffer);\r\n} else {\r\ncount = cmd->SCp.this_residual;\r\nd = cmd->SCp.ptr;\r\n}\r\nif ((count >= DMA_MIN_SIZE) && (sun3_dma_setup_done != cmd)) {\r\nif (cmd->request->cmd_type == REQ_TYPE_FS) {\r\nsun3scsi_dma_setup(d, count,\r\nrq_data_dir(cmd->request));\r\nsun3_dma_setup_done = cmd;\r\n}\r\n}\r\n#endif\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr |= CSR_INTR;\r\n#endif\r\n}\r\n#endif\r\nif (sink && (phase != PHASE_MSGOUT)) {\r\nNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(tmp));\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN |\r\nICR_ASSERT_ACK);\r\nwhile (NCR5380_read(STATUS_REG) & SR_REQ)\r\n;\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |\r\nICR_ASSERT_ATN);\r\nsink = 0;\r\ncontinue;\r\n}\r\nswitch (phase) {\r\ncase PHASE_DATAOUT:\r\n#if (NDEBUG & NDEBUG_NO_DATAOUT)\r\nprintk("scsi%d: NDEBUG_NO_DATAOUT set, attempted DATAOUT "\r\n"aborted\n", HOSTNO);\r\nsink = 1;\r\ndo_abort(instance);\r\ncmd->result = DID_ERROR << 16;\r\ncmd->scsi_done(cmd);\r\nreturn;\r\n#endif\r\ncase PHASE_DATAIN:\r\nif (!cmd->SCp.this_residual && cmd->SCp.buffers_residual) {\r\n++cmd->SCp.buffer;\r\n--cmd->SCp.buffers_residual;\r\ncmd->SCp.this_residual = cmd->SCp.buffer->length;\r\ncmd->SCp.ptr = sg_virt(cmd->SCp.buffer);\r\nmerge_contiguous_buffers(cmd);\r\ndprintk(NDEBUG_INFORMATION, "scsi%d: %d bytes and %d buffers left\n",\r\nHOSTNO, cmd->SCp.this_residual,\r\ncmd->SCp.buffers_residual);\r\n}\r\n#if defined(REAL_DMA)\r\nif (\r\n#if !defined(CONFIG_SUN3)\r\n!cmd->device->borken &&\r\n#endif\r\n(transfersize = NCR5380_dma_xfer_len(instance, cmd, phase)) >= DMA_MIN_SIZE) {\r\nlen = transfersize;\r\ncmd->SCp.phase = phase;\r\nif (NCR5380_transfer_dma(instance, &phase,\r\n&len, (unsigned char **)&cmd->SCp.ptr)) {\r\nscmd_printk(KERN_INFO, cmd,\r\n"switching to slow handshake\n");\r\ncmd->device->borken = 1;\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |\r\nICR_ASSERT_ATN);\r\nsink = 1;\r\ndo_abort(instance);\r\ncmd->result = DID_ERROR << 16;\r\ncmd->scsi_done(cmd);\r\n} else {\r\n#ifdef REAL_DMA\r\nreturn;\r\n#else\r\ncmd->SCp.this_residual -= transfersize - len;\r\n#endif\r\n}\r\n} else\r\n#endif\r\nNCR5380_transfer_pio(instance, &phase,\r\n(int *)&cmd->SCp.this_residual,\r\n(unsigned char **)&cmd->SCp.ptr);\r\n#if defined(CONFIG_SUN3) && defined(REAL_DMA)\r\nif (sun3_dma_setup_done == cmd)\r\nsun3_dma_setup_done = NULL;\r\n#endif\r\nbreak;\r\ncase PHASE_MSGIN:\r\nlen = 1;\r\ndata = &tmp;\r\nNCR5380_write(SELECT_ENABLE_REG, 0);\r\nNCR5380_transfer_pio(instance, &phase, &len, &data);\r\ncmd->SCp.Message = tmp;\r\nswitch (tmp) {\r\n#ifdef LINKED\r\ncase LINKED_CMD_COMPLETE:\r\ncase LINKED_FLG_CMD_COMPLETE:\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\ndprintk(NDEBUG_LINKED, "scsi%d: target %d lun %llu linked command "\r\n"complete.\n", HOSTNO, cmd->device->id, cmd->device->lun);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nif (!cmd->next_link) {\r\nprintk(KERN_NOTICE "scsi%d: target %d lun %llu "\r\n"linked command complete, no next_link\n",\r\nHOSTNO, cmd->device->id, cmd->device->lun);\r\nsink = 1;\r\ndo_abort(instance);\r\nreturn;\r\n}\r\ninitialize_SCp(cmd->next_link);\r\ncmd->next_link->tag = cmd->tag;\r\ncmd->result = cmd->SCp.Status | (cmd->SCp.Message << 8);\r\ndprintk(NDEBUG_LINKED, "scsi%d: target %d lun %llu linked request "\r\n"done, calling scsi_done().\n",\r\nHOSTNO, cmd->device->id, cmd->device->lun);\r\ncmd->scsi_done(cmd);\r\ncmd = hostdata->connected;\r\nbreak;\r\n#endif\r\ncase ABORT:\r\ncase COMMAND_COMPLETE:\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\ndprintk(NDEBUG_QUEUES, "scsi%d: command for target %d, lun %llu "\r\n"completed\n", HOSTNO, cmd->device->id, cmd->device->lun);\r\nlocal_irq_save(flags);\r\nhostdata->retain_dma_intr++;\r\nhostdata->connected = NULL;\r\n#ifdef SUPPORT_TAGS\r\ncmd_free_tag(cmd);\r\nif (status_byte(cmd->SCp.Status) == QUEUE_FULL) {\r\nstruct tag_alloc *ta = &hostdata->TagAlloc[scmd_id(cmd)][cmd->device->lun];\r\ndprintk(NDEBUG_TAGS, "scsi%d: target %d lun %llu returned "\r\n"QUEUE_FULL after %d commands\n",\r\nHOSTNO, cmd->device->id, cmd->device->lun,\r\nta->nr_allocated);\r\nif (ta->queue_size > ta->nr_allocated)\r\nta->nr_allocated = ta->queue_size;\r\n}\r\n#else\r\nhostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);\r\n#endif\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nif (cmd->cmnd[0] != REQUEST_SENSE)\r\ncmd->result = cmd->SCp.Status | (cmd->SCp.Message << 8);\r\nelse if (status_byte(cmd->SCp.Status) != GOOD)\r\ncmd->result = (cmd->result & 0x00ffff) | (DID_ERROR << 16);\r\nif ((cmd->cmnd[0] == REQUEST_SENSE) &&\r\nhostdata->ses.cmd_len) {\r\nscsi_eh_restore_cmnd(cmd, &hostdata->ses);\r\nhostdata->ses.cmd_len = 0 ;\r\n}\r\nif ((cmd->cmnd[0] != REQUEST_SENSE) &&\r\n(status_byte(cmd->SCp.Status) == CHECK_CONDITION)) {\r\nscsi_eh_prep_cmnd(cmd, &hostdata->ses, NULL, 0, ~0);\r\ndprintk(NDEBUG_AUTOSENSE, "scsi%d: performing request sense\n", HOSTNO);\r\nLIST(cmd,hostdata->issue_queue);\r\nSET_NEXT(cmd, hostdata->issue_queue);\r\nhostdata->issue_queue = (struct scsi_cmnd *) cmd;\r\ndprintk(NDEBUG_QUEUES, "scsi%d: REQUEST SENSE added to head of "\r\n"issue queue\n", H_NO(cmd));\r\n} else {\r\ncmd->scsi_done(cmd);\r\n}\r\nlocal_irq_restore(flags);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nNCR5380_write(TARGET_COMMAND_REG, 0);\r\nwhile ((NCR5380_read(STATUS_REG) & SR_BSY) && !hostdata->connected)\r\nbarrier();\r\nlocal_irq_save(flags);\r\nhostdata->retain_dma_intr--;\r\nmaybe_release_dma_irq(instance);\r\nlocal_irq_restore(flags);\r\nreturn;\r\ncase MESSAGE_REJECT:\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nswitch (hostdata->last_message) {\r\ncase HEAD_OF_QUEUE_TAG:\r\ncase ORDERED_QUEUE_TAG:\r\ncase SIMPLE_QUEUE_TAG:\r\ncmd->device->tagged_supported = 0;\r\nhostdata->busy[cmd->device->id] |= (1 << cmd->device->lun);\r\ncmd->tag = TAG_NONE;\r\ndprintk(NDEBUG_TAGS, "scsi%d: target %d lun %llu rejected "\r\n"QUEUE_TAG message; tagged queuing "\r\n"disabled\n",\r\nHOSTNO, cmd->device->id, cmd->device->lun);\r\nbreak;\r\n}\r\nbreak;\r\ncase DISCONNECT:\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nlocal_irq_save(flags);\r\ncmd->device->disconnect = 1;\r\nLIST(cmd,hostdata->disconnected_queue);\r\nSET_NEXT(cmd, hostdata->disconnected_queue);\r\nhostdata->connected = NULL;\r\nhostdata->disconnected_queue = cmd;\r\nlocal_irq_restore(flags);\r\ndprintk(NDEBUG_QUEUES, "scsi%d: command for target %d lun %llu was "\r\n"moved from connected to the "\r\n"disconnected_queue\n", HOSTNO,\r\ncmd->device->id, cmd->device->lun);\r\nNCR5380_write(TARGET_COMMAND_REG, 0);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nwhile ((NCR5380_read(STATUS_REG) & SR_BSY) && !hostdata->connected)\r\nbarrier();\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr |= CSR_DMA_ENABLE;\r\n#endif\r\nreturn;\r\ncase SAVE_POINTERS:\r\ncase RESTORE_POINTERS:\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nbreak;\r\ncase EXTENDED_MESSAGE:\r\nextended_msg[0] = EXTENDED_MESSAGE;\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\ndprintk(NDEBUG_EXTENDED, "scsi%d: receiving extended message\n", HOSTNO);\r\nlen = 2;\r\ndata = extended_msg + 1;\r\nphase = PHASE_MSGIN;\r\nNCR5380_transfer_pio(instance, &phase, &len, &data);\r\ndprintk(NDEBUG_EXTENDED, "scsi%d: length=%d, code=0x%02x\n", HOSTNO,\r\n(int)extended_msg[1], (int)extended_msg[2]);\r\nif (!len && extended_msg[1] <=\r\n(sizeof(extended_msg) - 1)) {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nlen = extended_msg[1] - 1;\r\ndata = extended_msg + 3;\r\nphase = PHASE_MSGIN;\r\nNCR5380_transfer_pio(instance, &phase, &len, &data);\r\ndprintk(NDEBUG_EXTENDED, "scsi%d: message received, residual %d\n",\r\nHOSTNO, len);\r\nswitch (extended_msg[2]) {\r\ncase EXTENDED_SDTR:\r\ncase EXTENDED_WDTR:\r\ncase EXTENDED_MODIFY_DATA_POINTER:\r\ncase EXTENDED_EXTENDED_IDENTIFY:\r\ntmp = 0;\r\n}\r\n} else if (len) {\r\nprintk(KERN_NOTICE "scsi%d: error receiving "\r\n"extended message\n", HOSTNO);\r\ntmp = 0;\r\n} else {\r\nprintk(KERN_NOTICE "scsi%d: extended message "\r\n"code %02x length %d is too long\n",\r\nHOSTNO, extended_msg[2], extended_msg[1]);\r\ntmp = 0;\r\n}\r\ndefault:\r\nif (!tmp) {\r\nprintk(KERN_INFO "scsi%d: rejecting message ",\r\ninstance->host_no);\r\nspi_print_msg(extended_msg);\r\nprintk("\n");\r\n} else if (tmp != EXTENDED_MESSAGE)\r\nscmd_printk(KERN_INFO, cmd,\r\n"rejecting unknown message %02x\n",\r\ntmp);\r\nelse\r\nscmd_printk(KERN_INFO, cmd,\r\n"rejecting unknown extended message code %02x, length %d\n",\r\nextended_msg[1], extended_msg[0]);\r\nmsgout = MESSAGE_REJECT;\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\r\nbreak;\r\n}\r\nbreak;\r\ncase PHASE_MSGOUT:\r\nlen = 1;\r\ndata = &msgout;\r\nhostdata->last_message = msgout;\r\nNCR5380_transfer_pio(instance, &phase, &len, &data);\r\nif (msgout == ABORT) {\r\nlocal_irq_save(flags);\r\n#ifdef SUPPORT_TAGS\r\ncmd_free_tag(cmd);\r\n#else\r\nhostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);\r\n#endif\r\nhostdata->connected = NULL;\r\ncmd->result = DID_ERROR << 16;\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nmaybe_release_dma_irq(instance);\r\nlocal_irq_restore(flags);\r\ncmd->scsi_done(cmd);\r\nreturn;\r\n}\r\nmsgout = NOP;\r\nbreak;\r\ncase PHASE_CMDOUT:\r\nlen = cmd->cmd_len;\r\ndata = cmd->cmnd;\r\nNCR5380_transfer_pio(instance, &phase, &len, &data);\r\nbreak;\r\ncase PHASE_STATIN:\r\nlen = 1;\r\ndata = &tmp;\r\nNCR5380_transfer_pio(instance, &phase, &len, &data);\r\ncmd->SCp.Status = tmp;\r\nbreak;\r\ndefault:\r\nprintk("scsi%d: unknown phase\n", HOSTNO);\r\nNCR5380_dprint(NDEBUG_ANY, instance);\r\n}\r\n}\r\n}\r\n}\r\nstatic void NCR5380_reselect(struct Scsi_Host *instance)\r\n{\r\nSETUP_HOSTDATA(instance);\r\nunsigned char target_mask;\r\nunsigned char lun;\r\n#ifdef SUPPORT_TAGS\r\nunsigned char tag;\r\n#endif\r\nunsigned char msg[3];\r\nint __maybe_unused len;\r\nunsigned char __maybe_unused *data, __maybe_unused phase;\r\nstruct scsi_cmnd *tmp = NULL, *prev;\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nhostdata->restart_select = 1;\r\ntarget_mask = NCR5380_read(CURRENT_SCSI_DATA_REG) & ~(hostdata->id_mask);\r\ndprintk(NDEBUG_RESELECTION, "scsi%d: reselect\n", HOSTNO);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_BSY);\r\nwhile (NCR5380_read(STATUS_REG) & SR_SEL)\r\n;\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nwhile (!(NCR5380_read(STATUS_REG) & SR_REQ))\r\n;\r\n#if defined(CONFIG_SUN3) && defined(REAL_DMA)\r\nNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(PHASE_MSGIN));\r\nmsg[0] = NCR5380_read(CURRENT_SCSI_DATA_REG);\r\n#else\r\nlen = 1;\r\ndata = msg;\r\nphase = PHASE_MSGIN;\r\nNCR5380_transfer_pio(instance, &phase, &len, &data);\r\n#endif\r\nif (!(msg[0] & 0x80)) {\r\nprintk(KERN_DEBUG "scsi%d: expecting IDENTIFY message, got ", HOSTNO);\r\nspi_print_msg(msg);\r\ndo_abort(instance);\r\nreturn;\r\n}\r\nlun = (msg[0] & 0x07);\r\n#if defined(SUPPORT_TAGS) && !defined(CONFIG_SUN3)\r\ntag = TAG_NONE;\r\nif (phase == PHASE_MSGIN && (hostdata->flags & FLAG_TAGGED_QUEUING)) {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nlen = 2;\r\ndata = msg + 1;\r\nif (!NCR5380_transfer_pio(instance, &phase, &len, &data) &&\r\nmsg[1] == SIMPLE_QUEUE_TAG)\r\ntag = msg[2];\r\ndprintk(NDEBUG_TAGS, "scsi%d: target mask %02x, lun %d sent tag %d at "\r\n"reselection\n", HOSTNO, target_mask, lun, tag);\r\n}\r\n#endif\r\nfor (tmp = (struct scsi_cmnd *) hostdata->disconnected_queue, prev = NULL;\r\ntmp; prev = tmp, tmp = NEXT(tmp)) {\r\nif ((target_mask == (1 << tmp->device->id)) && (lun == tmp->device->lun)\r\n#ifdef SUPPORT_TAGS\r\n&& (tag == tmp->tag)\r\n#endif\r\n) {\r\nif (prev) {\r\nREMOVE(prev, NEXT(prev), tmp, NEXT(tmp));\r\nSET_NEXT(prev, NEXT(tmp));\r\n} else {\r\nREMOVE(-1, hostdata->disconnected_queue, tmp, NEXT(tmp));\r\nhostdata->disconnected_queue = NEXT(tmp);\r\n}\r\nSET_NEXT(tmp, NULL);\r\nbreak;\r\n}\r\n}\r\nif (!tmp) {\r\nprintk(KERN_WARNING "scsi%d: warning: target bitmask %02x lun %d "\r\n#ifdef SUPPORT_TAGS\r\n"tag %d "\r\n#endif\r\n"not in disconnected_queue.\n",\r\nHOSTNO, target_mask, lun\r\n#ifdef SUPPORT_TAGS\r\n, tag\r\n#endif\r\n);\r\ndo_abort(instance);\r\nreturn;\r\n}\r\n#if defined(CONFIG_SUN3) && defined(REAL_DMA)\r\n{\r\nvoid *d;\r\nunsigned long count;\r\nif (!tmp->SCp.this_residual && tmp->SCp.buffers_residual) {\r\ncount = tmp->SCp.buffer->length;\r\nd = sg_virt(tmp->SCp.buffer);\r\n} else {\r\ncount = tmp->SCp.this_residual;\r\nd = tmp->SCp.ptr;\r\n}\r\nif ((count >= DMA_MIN_SIZE) && (sun3_dma_setup_done != tmp)) {\r\nsun3scsi_dma_setup(d, count, rq_data_dir(tmp->request));\r\nsun3_dma_setup_done = tmp;\r\n}\r\n}\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ACK);\r\n#endif\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\n#if defined(SUPPORT_TAGS) && defined(CONFIG_SUN3)\r\ntag = TAG_NONE;\r\nif (phase == PHASE_MSGIN && setup_use_tagged_queuing) {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nlen = 2;\r\ndata = msg + 1;\r\nif (!NCR5380_transfer_pio(instance, &phase, &len, &data) &&\r\nmsg[1] == SIMPLE_QUEUE_TAG)\r\ntag = msg[2];\r\ndprintk(NDEBUG_TAGS, "scsi%d: target mask %02x, lun %d sent tag %d at reselection\n"\r\nHOSTNO, target_mask, lun, tag);\r\n}\r\n#endif\r\nhostdata->connected = tmp;\r\ndprintk(NDEBUG_RESELECTION, "scsi%d: nexus established, target = %d, lun = %llu, tag = %d\n",\r\nHOSTNO, tmp->device->id, tmp->device->lun, tmp->tag);\r\n}\r\nstatic\r\nint NCR5380_abort(struct scsi_cmnd *cmd)\r\n{\r\nstruct Scsi_Host *instance = cmd->device->host;\r\nSETUP_HOSTDATA(instance);\r\nstruct scsi_cmnd *tmp, **prev;\r\nunsigned long flags;\r\nscmd_printk(KERN_NOTICE, cmd, "aborting command\n");\r\nNCR5380_print_status(instance);\r\nlocal_irq_save(flags);\r\ndprintk(NDEBUG_ABORT, "scsi%d: abort called basr 0x%02x, sr 0x%02x\n", HOSTNO,\r\nNCR5380_read(BUS_AND_STATUS_REG),\r\nNCR5380_read(STATUS_REG));\r\n#if 1\r\nif (hostdata->connected == cmd) {\r\ndprintk(NDEBUG_ABORT, "scsi%d: aborting connected command\n", HOSTNO);\r\nif (do_abort(instance) == 0) {\r\nhostdata->aborted = 1;\r\nhostdata->connected = NULL;\r\ncmd->result = DID_ABORT << 16;\r\n#ifdef SUPPORT_TAGS\r\ncmd_free_tag(cmd);\r\n#else\r\nhostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);\r\n#endif\r\nmaybe_release_dma_irq(instance);\r\nlocal_irq_restore(flags);\r\ncmd->scsi_done(cmd);\r\nreturn SUCCESS;\r\n} else {\r\nlocal_irq_restore(flags);\r\nprintk("scsi%d: abort of connected command failed!\n", HOSTNO);\r\nreturn FAILED;\r\n}\r\n}\r\n#endif\r\nfor (prev = (struct scsi_cmnd **)&(hostdata->issue_queue),\r\ntmp = (struct scsi_cmnd *)hostdata->issue_queue;\r\ntmp; prev = NEXTADDR(tmp), tmp = NEXT(tmp)) {\r\nif (cmd == tmp) {\r\nREMOVE(5, *prev, tmp, NEXT(tmp));\r\n(*prev) = NEXT(tmp);\r\nSET_NEXT(tmp, NULL);\r\ntmp->result = DID_ABORT << 16;\r\nmaybe_release_dma_irq(instance);\r\nlocal_irq_restore(flags);\r\ndprintk(NDEBUG_ABORT, "scsi%d: abort removed command from issue queue.\n",\r\nHOSTNO);\r\ntmp->scsi_done(tmp);\r\nreturn SUCCESS;\r\n}\r\n}\r\nif (hostdata->connected) {\r\nlocal_irq_restore(flags);\r\ndprintk(NDEBUG_ABORT, "scsi%d: abort failed, command connected.\n", HOSTNO);\r\nreturn FAILED;\r\n}\r\nfor (tmp = (struct scsi_cmnd *) hostdata->disconnected_queue; tmp;\r\ntmp = NEXT(tmp)) {\r\nif (cmd == tmp) {\r\nlocal_irq_restore(flags);\r\ndprintk(NDEBUG_ABORT, "scsi%d: aborting disconnected command.\n", HOSTNO);\r\nif (NCR5380_select(instance, cmd))\r\nreturn FAILED;\r\ndprintk(NDEBUG_ABORT, "scsi%d: nexus reestablished.\n", HOSTNO);\r\ndo_abort(instance);\r\nlocal_irq_save(flags);\r\nfor (prev = (struct scsi_cmnd **)&(hostdata->disconnected_queue),\r\ntmp = (struct scsi_cmnd *)hostdata->disconnected_queue;\r\ntmp; prev = NEXTADDR(tmp), tmp = NEXT(tmp)) {\r\nif (cmd == tmp) {\r\nREMOVE(5, *prev, tmp, NEXT(tmp));\r\n*prev = NEXT(tmp);\r\nSET_NEXT(tmp, NULL);\r\ntmp->result = DID_ABORT << 16;\r\n#ifdef SUPPORT_TAGS\r\ncmd_free_tag(tmp);\r\n#else\r\nhostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);\r\n#endif\r\nmaybe_release_dma_irq(instance);\r\nlocal_irq_restore(flags);\r\ntmp->scsi_done(tmp);\r\nreturn SUCCESS;\r\n}\r\n}\r\n}\r\n}\r\nmaybe_release_dma_irq(instance);\r\nlocal_irq_restore(flags);\r\nprintk(KERN_INFO "scsi%d: warning : SCSI command probably completed successfully before abortion\n", HOSTNO);\r\nreturn FAILED;\r\n}\r\nstatic int NCR5380_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct Scsi_Host *instance = cmd->device->host;\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nint i;\r\nunsigned long flags;\r\nNCR5380_print_status(instance);\r\nNCR5380_write(TARGET_COMMAND_REG,\r\nPHASE_SR_TO_TCR(NCR5380_read(STATUS_REG)));\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_RST);\r\nudelay(40);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(TARGET_COMMAND_REG, 0);\r\nNCR5380_write(SELECT_ENABLE_REG, 0);\r\n(void)NCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\nif (hostdata->issue_queue)\r\ndprintk(NDEBUG_ABORT, "scsi%d: reset aborted issued command(s)\n", H_NO(cmd));\r\nif (hostdata->connected)\r\ndprintk(NDEBUG_ABORT, "scsi%d: reset aborted a connected command\n", H_NO(cmd));\r\nif (hostdata->disconnected_queue)\r\ndprintk(NDEBUG_ABORT, "scsi%d: reset aborted disconnected command(s)\n", H_NO(cmd));\r\nlocal_irq_save(flags);\r\nhostdata->issue_queue = NULL;\r\nhostdata->connected = NULL;\r\nhostdata->disconnected_queue = NULL;\r\n#ifdef SUPPORT_TAGS\r\nfree_all_tags(hostdata);\r\n#endif\r\nfor (i = 0; i < 8; ++i)\r\nhostdata->busy[i] = 0;\r\n#ifdef REAL_DMA\r\nhostdata->dma_len = 0;\r\n#endif\r\nmaybe_release_dma_irq(instance);\r\nlocal_irq_restore(flags);\r\nreturn SUCCESS;\r\n}
