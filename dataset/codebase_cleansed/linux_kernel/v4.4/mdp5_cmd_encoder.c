static struct mdp5_kms *get_kms(struct drm_encoder *encoder)\r\n{\r\nstruct msm_drm_private *priv = encoder->dev->dev_private;\r\nreturn to_mdp5_kms(to_mdp_kms(priv->kms));\r\n}\r\nstatic void bs_init(struct mdp5_cmd_encoder *mdp5_cmd_enc)\r\n{\r\nmdp5_cmd_enc->bsc = msm_bus_scale_register_client(\r\n&mdp_bus_scale_table);\r\nDBG("bus scale client: %08x", mdp5_cmd_enc->bsc);\r\n}\r\nstatic void bs_fini(struct mdp5_cmd_encoder *mdp5_cmd_enc)\r\n{\r\nif (mdp5_cmd_enc->bsc) {\r\nmsm_bus_scale_unregister_client(mdp5_cmd_enc->bsc);\r\nmdp5_cmd_enc->bsc = 0;\r\n}\r\n}\r\nstatic void bs_set(struct mdp5_cmd_encoder *mdp5_cmd_enc, int idx)\r\n{\r\nif (mdp5_cmd_enc->bsc) {\r\nDBG("set bus scaling: %d", idx);\r\nidx = 1;\r\nmsm_bus_scale_client_update_request(mdp5_cmd_enc->bsc, idx);\r\n}\r\n}\r\nstatic void bs_init(struct mdp5_cmd_encoder *mdp5_cmd_enc) {}\r\nstatic void bs_fini(struct mdp5_cmd_encoder *mdp5_cmd_enc) {}\r\nstatic void bs_set(struct mdp5_cmd_encoder *mdp5_cmd_enc, int idx) {}\r\nstatic int pingpong_tearcheck_setup(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct mdp5_kms *mdp5_kms = get_kms(encoder);\r\nstruct device *dev = encoder->dev->dev;\r\nu32 total_lines_x100, vclks_line, cfg;\r\nlong vsync_clk_speed;\r\nint pp_id = GET_PING_PONG_ID(mdp5_crtc_get_lm(encoder->crtc));\r\nif (IS_ERR_OR_NULL(mdp5_kms->vsync_clk)) {\r\ndev_err(dev, "vsync_clk is not initialized\n");\r\nreturn -EINVAL;\r\n}\r\ntotal_lines_x100 = mode->vtotal * mode->vrefresh;\r\nif (!total_lines_x100) {\r\ndev_err(dev, "%s: vtotal(%d) or vrefresh(%d) is 0\n",\r\n__func__, mode->vtotal, mode->vrefresh);\r\nreturn -EINVAL;\r\n}\r\nvsync_clk_speed = clk_round_rate(mdp5_kms->vsync_clk, VSYNC_CLK_RATE);\r\nif (vsync_clk_speed <= 0) {\r\ndev_err(dev, "vsync_clk round rate failed %ld\n",\r\nvsync_clk_speed);\r\nreturn -EINVAL;\r\n}\r\nvclks_line = vsync_clk_speed * 100 / total_lines_x100;\r\ncfg = MDP5_PP_SYNC_CONFIG_VSYNC_COUNTER_EN\r\n| MDP5_PP_SYNC_CONFIG_VSYNC_IN_EN;\r\ncfg |= MDP5_PP_SYNC_CONFIG_VSYNC_COUNT(vclks_line);\r\nmdp5_write(mdp5_kms, REG_MDP5_PP_SYNC_CONFIG_VSYNC(pp_id), cfg);\r\nmdp5_write(mdp5_kms,\r\nREG_MDP5_PP_SYNC_CONFIG_HEIGHT(pp_id), 0xfff0);\r\nmdp5_write(mdp5_kms,\r\nREG_MDP5_PP_VSYNC_INIT_VAL(pp_id), mode->vdisplay);\r\nmdp5_write(mdp5_kms, REG_MDP5_PP_RD_PTR_IRQ(pp_id), mode->vdisplay + 1);\r\nmdp5_write(mdp5_kms, REG_MDP5_PP_START_POS(pp_id), mode->vdisplay);\r\nmdp5_write(mdp5_kms, REG_MDP5_PP_SYNC_THRESH(pp_id),\r\nMDP5_PP_SYNC_THRESH_START(4) |\r\nMDP5_PP_SYNC_THRESH_CONTINUE(4));\r\nreturn 0;\r\n}\r\nstatic int pingpong_tearcheck_enable(struct drm_encoder *encoder)\r\n{\r\nstruct mdp5_kms *mdp5_kms = get_kms(encoder);\r\nint pp_id = GET_PING_PONG_ID(mdp5_crtc_get_lm(encoder->crtc));\r\nint ret;\r\nret = clk_set_rate(mdp5_kms->vsync_clk,\r\nclk_round_rate(mdp5_kms->vsync_clk, VSYNC_CLK_RATE));\r\nif (ret) {\r\ndev_err(encoder->dev->dev,\r\n"vsync_clk clk_set_rate failed, %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(mdp5_kms->vsync_clk);\r\nif (ret) {\r\ndev_err(encoder->dev->dev,\r\n"vsync_clk clk_prepare_enable failed, %d\n", ret);\r\nreturn ret;\r\n}\r\nmdp5_write(mdp5_kms, REG_MDP5_PP_TEAR_CHECK_EN(pp_id), 1);\r\nreturn 0;\r\n}\r\nstatic void pingpong_tearcheck_disable(struct drm_encoder *encoder)\r\n{\r\nstruct mdp5_kms *mdp5_kms = get_kms(encoder);\r\nint pp_id = GET_PING_PONG_ID(mdp5_crtc_get_lm(encoder->crtc));\r\nmdp5_write(mdp5_kms, REG_MDP5_PP_TEAR_CHECK_EN(pp_id), 0);\r\nclk_disable_unprepare(mdp5_kms->vsync_clk);\r\n}\r\nstatic void mdp5_cmd_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct mdp5_cmd_encoder *mdp5_cmd_enc = to_mdp5_cmd_encoder(encoder);\r\nbs_fini(mdp5_cmd_enc);\r\ndrm_encoder_cleanup(encoder);\r\nkfree(mdp5_cmd_enc);\r\n}\r\nstatic bool mdp5_cmd_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void mdp5_cmd_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct mdp5_cmd_encoder *mdp5_cmd_enc = to_mdp5_cmd_encoder(encoder);\r\nmode = adjusted_mode;\r\nDBG("set mode: %d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x",\r\nmode->base.id, mode->name,\r\nmode->vrefresh, mode->clock,\r\nmode->hdisplay, mode->hsync_start,\r\nmode->hsync_end, mode->htotal,\r\nmode->vdisplay, mode->vsync_start,\r\nmode->vsync_end, mode->vtotal,\r\nmode->type, mode->flags);\r\npingpong_tearcheck_setup(encoder, mode);\r\nmdp5_crtc_set_pipeline(encoder->crtc, &mdp5_cmd_enc->intf,\r\nmdp5_cmd_enc->ctl);\r\n}\r\nstatic void mdp5_cmd_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct mdp5_cmd_encoder *mdp5_cmd_enc = to_mdp5_cmd_encoder(encoder);\r\nstruct mdp5_ctl *ctl = mdp5_cmd_enc->ctl;\r\nstruct mdp5_interface *intf = &mdp5_cmd_enc->intf;\r\nif (WARN_ON(!mdp5_cmd_enc->enabled))\r\nreturn;\r\npingpong_tearcheck_disable(encoder);\r\nmdp5_ctl_set_encoder_state(ctl, false);\r\nmdp5_ctl_commit(ctl, mdp_ctl_flush_mask_encoder(intf));\r\nbs_set(mdp5_cmd_enc, 0);\r\nmdp5_cmd_enc->enabled = false;\r\n}\r\nstatic void mdp5_cmd_encoder_enable(struct drm_encoder *encoder)\r\n{\r\nstruct mdp5_cmd_encoder *mdp5_cmd_enc = to_mdp5_cmd_encoder(encoder);\r\nstruct mdp5_ctl *ctl = mdp5_cmd_enc->ctl;\r\nstruct mdp5_interface *intf = &mdp5_cmd_enc->intf;\r\nif (WARN_ON(mdp5_cmd_enc->enabled))\r\nreturn;\r\nbs_set(mdp5_cmd_enc, 1);\r\nif (pingpong_tearcheck_enable(encoder))\r\nreturn;\r\nmdp5_ctl_commit(ctl, mdp_ctl_flush_mask_encoder(intf));\r\nmdp5_ctl_set_encoder_state(ctl, true);\r\nmdp5_cmd_enc->enabled = true;\r\n}\r\nint mdp5_cmd_encoder_set_split_display(struct drm_encoder *encoder,\r\nstruct drm_encoder *slave_encoder)\r\n{\r\nstruct mdp5_cmd_encoder *mdp5_cmd_enc = to_mdp5_cmd_encoder(encoder);\r\nstruct mdp5_kms *mdp5_kms;\r\nint intf_num;\r\nu32 data = 0;\r\nif (!encoder || !slave_encoder)\r\nreturn -EINVAL;\r\nmdp5_kms = get_kms(encoder);\r\nintf_num = mdp5_cmd_enc->intf.num;\r\nif (intf_num == 1)\r\ndata |= MDP5_MDP_SPLIT_DPL_UPPER_INTF2_SW_TRG_MUX;\r\nelse if (intf_num == 2)\r\ndata |= MDP5_MDP_SPLIT_DPL_UPPER_INTF1_SW_TRG_MUX;\r\nelse\r\nreturn -EINVAL;\r\ndata |= MDP5_MDP_SPLIT_DPL_UPPER_SMART_PANEL;\r\nmdp5_enable(mdp5_kms);\r\nmdp5_write(mdp5_kms, REG_MDP5_MDP_SPLIT_DPL_UPPER(0), data);\r\nmdp5_write(mdp5_kms, REG_MDP5_MDP_SPLIT_DPL_LOWER(0),\r\nMDP5_MDP_SPLIT_DPL_LOWER_SMART_PANEL);\r\nmdp5_write(mdp5_kms, REG_MDP5_MDP_SPLIT_DPL_EN(0), 1);\r\nmdp5_disable(mdp5_kms);\r\nreturn 0;\r\n}\r\nstruct drm_encoder *mdp5_cmd_encoder_init(struct drm_device *dev,\r\nstruct mdp5_interface *intf, struct mdp5_ctl *ctl)\r\n{\r\nstruct drm_encoder *encoder = NULL;\r\nstruct mdp5_cmd_encoder *mdp5_cmd_enc;\r\nint ret;\r\nif (WARN_ON((intf->type != INTF_DSI) &&\r\n(intf->mode != MDP5_INTF_DSI_MODE_COMMAND))) {\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nmdp5_cmd_enc = kzalloc(sizeof(*mdp5_cmd_enc), GFP_KERNEL);\r\nif (!mdp5_cmd_enc) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nmemcpy(&mdp5_cmd_enc->intf, intf, sizeof(mdp5_cmd_enc->intf));\r\nencoder = &mdp5_cmd_enc->base;\r\nmdp5_cmd_enc->ctl = ctl;\r\ndrm_encoder_init(dev, encoder, &mdp5_cmd_encoder_funcs,\r\nDRM_MODE_ENCODER_DSI);\r\ndrm_encoder_helper_add(encoder, &mdp5_cmd_encoder_helper_funcs);\r\nbs_init(mdp5_cmd_enc);\r\nreturn encoder;\r\nfail:\r\nif (encoder)\r\nmdp5_cmd_encoder_destroy(encoder);\r\nreturn ERR_PTR(ret);\r\n}
