static int adjust_smc_value(int *value, struct smc_range *range, int size)\r\n{\r\nint maximum = (range + size - 1)->max;\r\nint remainder;\r\ndo {\r\nif (*value < range->min) {\r\nremainder = range->min - *value;\r\n*value = range->min;\r\nreturn remainder;\r\n} else if ((range->min <= *value) && (*value <= range->max))\r\nreturn 0;\r\nrange++;\r\n} while (--size);\r\n*value = maximum;\r\nreturn -1;\r\n}\r\nstatic int calc_smc_vals(struct device *dev,\r\nint *setup, int *pulse, int *cycle, int *cs_pulse)\r\n{\r\nint ret_val;\r\nint err = 0;\r\nstruct smc_range range_setup[] = {\r\n{.min = 0, .max = 31},\r\n{.min = 128, .max = 159}\r\n};\r\nstruct smc_range range_pulse[] = {\r\n{.min = 0, .max = 63},\r\n{.min = 256, .max = 319}\r\n};\r\nstruct smc_range range_cycle[] = {\r\n{.min = 0, .max = 127},\r\n{.min = 256, .max = 383},\r\n{.min = 512, .max = 639},\r\n{.min = 768, .max = 895}\r\n};\r\nret_val = adjust_smc_value(setup, range_setup, ARRAY_SIZE(range_setup));\r\nif (ret_val < 0)\r\ndev_warn(dev, "maximal SMC Setup value\n");\r\nelse\r\n*cycle += ret_val;\r\nret_val = adjust_smc_value(pulse, range_pulse, ARRAY_SIZE(range_pulse));\r\nif (ret_val < 0)\r\ndev_warn(dev, "maximal SMC Pulse value\n");\r\nelse\r\n*cycle += ret_val;\r\nret_val = adjust_smc_value(cycle, range_cycle, ARRAY_SIZE(range_cycle));\r\nif (ret_val < 0)\r\ndev_warn(dev, "maximal SMC Cycle value\n");\r\n*cs_pulse = *cycle;\r\nif (*cs_pulse > CS_PULSE_MAXIMUM) {\r\ndev_err(dev, "unable to calculate valid SMC settings\n");\r\nreturn -ER_SMC_CALC;\r\n}\r\nret_val = adjust_smc_value(cs_pulse, range_pulse,\r\nARRAY_SIZE(range_pulse));\r\nif (ret_val < 0) {\r\ndev_warn(dev, "maximal SMC CS Pulse value\n");\r\n} else if (ret_val != 0) {\r\n*cycle = *cs_pulse;\r\ndev_warn(dev, "SMC Cycle extended\n");\r\nerr = -ER_SMC_RECALC;\r\n}\r\nreturn err;\r\n}\r\nstatic void to_smc_format(int *setup, int *pulse, int *cycle, int *cs_pulse)\r\n{\r\n*setup = (*setup & 0x1f) | ((*setup & 0x80) >> 2);\r\n*pulse = (*pulse & 0x3f) | ((*pulse & 0x100) >> 2);\r\n*cycle = (*cycle & 0x7f) | ((*cycle & 0x300) >> 1);\r\n*cs_pulse = (*cs_pulse & 0x3f) | ((*cs_pulse & 0x100) >> 2);\r\n}\r\nstatic unsigned long calc_mck_cycles(unsigned long ns, unsigned long mck_hz)\r\n{\r\nunsigned long mul;\r\nmul = (mck_hz / 10000) << 16;\r\nmul /= 100000;\r\nreturn (ns * mul + 65536) >> 16;\r\n}\r\nstatic void set_smc_timing(struct device *dev, struct ata_device *adev,\r\nstruct at91_ide_info *info, const struct ata_timing *ata)\r\n{\r\nint ret = 0;\r\nint use_iordy;\r\nunsigned int t6z;\r\nunsigned int cycle;\r\nunsigned int setup;\r\nunsigned int pulse;\r\nunsigned int cs_pulse;\r\nunsigned int tdf_cycles;\r\nunsigned long mck_hz;\r\nt6z = (ata->mode < XFER_PIO_5) ? 30 : 20;\r\nmck_hz = clk_get_rate(info->mck);\r\ncycle = calc_mck_cycles(ata->cyc8b, mck_hz);\r\nsetup = calc_mck_cycles(ata->setup, mck_hz);\r\npulse = calc_mck_cycles(ata->act8b, mck_hz);\r\ntdf_cycles = calc_mck_cycles(t6z, mck_hz);\r\ndo {\r\nret = calc_smc_vals(dev, &setup, &pulse, &cycle, &cs_pulse);\r\n} while (ret == -ER_SMC_RECALC);\r\nif (ret == -ER_SMC_CALC)\r\ndev_err(dev, "Interface may not operate correctly\n");\r\ndev_dbg(dev, "SMC Setup=%u, Pulse=%u, Cycle=%u, CS Pulse=%u\n",\r\nsetup, pulse, cycle, cs_pulse);\r\nto_smc_format(&setup, &pulse, &cycle, &cs_pulse);\r\nuse_iordy = ata_pio_need_iordy(adev);\r\nif (use_iordy)\r\ninfo->mode |= AT91_SMC_EXNWMODE_READY;\r\nif (tdf_cycles > 15) {\r\ntdf_cycles = 15;\r\ndev_warn(dev, "maximal SMC TDF Cycles value\n");\r\n}\r\ndev_dbg(dev, "Use IORDY=%u, TDF Cycles=%u\n", use_iordy, tdf_cycles);\r\nregmap_fields_write(fields.setup, info->cs,\r\nAT91SAM9_SMC_NRDSETUP(setup) |\r\nAT91SAM9_SMC_NWESETUP(setup) |\r\nAT91SAM9_SMC_NCS_NRDSETUP(0) |\r\nAT91SAM9_SMC_NCS_WRSETUP(0));\r\nregmap_fields_write(fields.pulse, info->cs,\r\nAT91SAM9_SMC_NRDPULSE(pulse) |\r\nAT91SAM9_SMC_NWEPULSE(pulse) |\r\nAT91SAM9_SMC_NCS_NRDPULSE(cs_pulse) |\r\nAT91SAM9_SMC_NCS_WRPULSE(cs_pulse));\r\nregmap_fields_write(fields.cycle, info->cs,\r\nAT91SAM9_SMC_NRDCYCLE(cycle) |\r\nAT91SAM9_SMC_NWECYCLE(cycle));\r\nregmap_fields_write(fields.mode, info->cs, info->mode |\r\nAT91_SMC_TDF_(tdf_cycles));\r\n}\r\nstatic void pata_at91_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct at91_ide_info *info = ap->host->private_data;\r\nstruct ata_timing timing;\r\nint ret;\r\nret = ata_timing_compute(adev, adev->pio_mode, &timing, 1000, 0);\r\nif (ret) {\r\ndev_warn(ap->dev, "Failed to compute ATA timing %d, "\r\n"set PIO_0 timing\n", ret);\r\ntiming = *ata_timing_find_mode(XFER_PIO_0);\r\n}\r\nset_smc_timing(ap->dev, adev, info, &timing);\r\n}\r\nstatic unsigned int pata_at91_data_xfer_noirq(struct ata_device *dev,\r\nunsigned char *buf, unsigned int buflen, int rw)\r\n{\r\nstruct at91_ide_info *info = dev->link->ap->host->private_data;\r\nunsigned int consumed;\r\nunsigned int mode;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nregmap_fields_read(fields.mode, info->cs, &mode);\r\nregmap_fields_write(fields.mode, info->cs, (mode & ~AT91_SMC_DBW) |\r\nAT91_SMC_DBW_16);\r\nconsumed = ata_sff_data_xfer(dev, buf, buflen, rw);\r\nregmap_fields_write(fields.mode, info->cs, (mode & ~AT91_SMC_DBW) |\r\nAT91_SMC_DBW_8);\r\nlocal_irq_restore(flags);\r\nreturn consumed;\r\n}\r\nstatic int at91sam9_smc_fields_init(struct device *dev)\r\n{\r\nstruct reg_field field = REG_FIELD(0, 0, 31);\r\nfield.id_size = 8;\r\nfield.id_offset = AT91SAM9_SMC_GENERIC_BLK_SZ;\r\nfield.reg = AT91SAM9_SMC_SETUP(AT91SAM9_SMC_GENERIC);\r\nfields.setup = devm_regmap_field_alloc(dev, smc, field);\r\nif (IS_ERR(fields.setup))\r\nreturn PTR_ERR(fields.setup);\r\nfield.reg = AT91SAM9_SMC_PULSE(AT91SAM9_SMC_GENERIC);\r\nfields.pulse = devm_regmap_field_alloc(dev, smc, field);\r\nif (IS_ERR(fields.pulse))\r\nreturn PTR_ERR(fields.pulse);\r\nfield.reg = AT91SAM9_SMC_CYCLE(AT91SAM9_SMC_GENERIC);\r\nfields.cycle = devm_regmap_field_alloc(dev, smc, field);\r\nif (IS_ERR(fields.cycle))\r\nreturn PTR_ERR(fields.cycle);\r\nfield.reg = AT91SAM9_SMC_MODE(AT91SAM9_SMC_GENERIC);\r\nfields.mode = devm_regmap_field_alloc(dev, smc, field);\r\nif (IS_ERR(fields.mode))\r\nreturn PTR_ERR(fields.mode);\r\nreturn 0;\r\n}\r\nstatic int pata_at91_probe(struct platform_device *pdev)\r\n{\r\nstruct at91_cf_data *board = dev_get_platdata(&pdev->dev);\r\nstruct device *dev = &pdev->dev;\r\nstruct at91_ide_info *info;\r\nstruct resource *mem_res;\r\nstruct ata_host *host;\r\nstruct ata_port *ap;\r\nint irq_flags = 0;\r\nint irq = 0;\r\nint ret;\r\nif (pdev->num_resources != 1) {\r\ndev_err(&pdev->dev, "invalid number of resources\n");\r\nreturn -EINVAL;\r\n}\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem_res) {\r\ndev_err(dev, "failed to get mem resource\n");\r\nreturn -EINVAL;\r\n}\r\nirq = board->irq_pin;\r\nsmc = syscon_regmap_lookup_by_phandle(pdev->dev.of_node, "atmel,smc");\r\nif (IS_ERR(smc))\r\nreturn PTR_ERR(smc);\r\nret = at91sam9_smc_fields_init(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nhost = ata_host_alloc(dev, 1);\r\nif (!host)\r\nreturn -ENOMEM;\r\nap = host->ports[0];\r\nap->ops = &pata_at91_port_ops;\r\nap->flags |= ATA_FLAG_SLAVE_POSS;\r\nap->pio_mask = ATA_PIO4;\r\nif (!gpio_is_valid(irq)) {\r\nap->flags |= ATA_FLAG_PIO_POLLING;\r\nata_port_desc(ap, "no IRQ, using PIO polling");\r\n}\r\ninfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\r\nif (!info) {\r\ndev_err(dev, "failed to allocate memory for private data\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo->mck = clk_get(NULL, "mck");\r\nif (IS_ERR(info->mck)) {\r\ndev_err(dev, "failed to get access to mck clock\n");\r\nreturn -ENODEV;\r\n}\r\ninfo->cs = board->chipselect;\r\ninfo->mode = AT91_SMC_READMODE | AT91_SMC_WRITEMODE |\r\nAT91_SMC_EXNWMODE_READY | AT91_SMC_BAT_SELECT |\r\nAT91_SMC_DBW_8 | AT91_SMC_TDF_(0);\r\ninfo->ide_addr = devm_ioremap(dev,\r\nmem_res->start + CF_IDE_OFFSET, CF_IDE_RES_SIZE);\r\nif (!info->ide_addr) {\r\ndev_err(dev, "failed to map IO base\n");\r\nret = -ENOMEM;\r\ngoto err_put;\r\n}\r\ninfo->alt_addr = devm_ioremap(dev,\r\nmem_res->start + CF_ALT_IDE_OFFSET, CF_IDE_RES_SIZE);\r\nif (!info->alt_addr) {\r\ndev_err(dev, "failed to map CTL base\n");\r\nret = -ENOMEM;\r\ngoto err_put;\r\n}\r\nap->ioaddr.cmd_addr = info->ide_addr;\r\nap->ioaddr.ctl_addr = info->alt_addr + 0x06;\r\nap->ioaddr.altstatus_addr = ap->ioaddr.ctl_addr;\r\nata_sff_std_ports(&ap->ioaddr);\r\nata_port_desc(ap, "mmio cmd 0x%llx ctl 0x%llx",\r\n(unsigned long long)mem_res->start + CF_IDE_OFFSET,\r\n(unsigned long long)mem_res->start + CF_ALT_IDE_OFFSET);\r\nhost->private_data = info;\r\nret = ata_host_activate(host, gpio_is_valid(irq) ? gpio_to_irq(irq) : 0,\r\ngpio_is_valid(irq) ? ata_sff_interrupt : NULL,\r\nirq_flags, &pata_at91_sht);\r\nif (ret)\r\ngoto err_put;\r\nreturn 0;\r\nerr_put:\r\nclk_put(info->mck);\r\nreturn ret;\r\n}\r\nstatic int pata_at91_remove(struct platform_device *pdev)\r\n{\r\nstruct ata_host *host = platform_get_drvdata(pdev);\r\nstruct at91_ide_info *info;\r\nif (!host)\r\nreturn 0;\r\ninfo = host->private_data;\r\nata_host_detach(host);\r\nif (!info)\r\nreturn 0;\r\nclk_put(info->mck);\r\nreturn 0;\r\n}
