static inline char *bfd_demangle(void __maybe_unused *v, const char *c, int i)\r\n{\r\nreturn cplus_demangle(c, i);\r\n}\r\nstatic inline char *bfd_demangle(void __maybe_unused *v,\r\nconst char __maybe_unused *c,\r\nint __maybe_unused i)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int elf_getphdrnum(Elf *elf, size_t *dst)\r\n{\r\nGElf_Ehdr gehdr;\r\nGElf_Ehdr *ehdr;\r\nehdr = gelf_getehdr(elf, &gehdr);\r\nif (!ehdr)\r\nreturn -1;\r\n*dst = ehdr->e_phnum;\r\nreturn 0;\r\n}\r\nstatic inline uint8_t elf_sym__type(const GElf_Sym *sym)\r\n{\r\nreturn GELF_ST_TYPE(sym->st_info);\r\n}\r\nstatic inline int elf_sym__is_function(const GElf_Sym *sym)\r\n{\r\nreturn (elf_sym__type(sym) == STT_FUNC ||\r\nelf_sym__type(sym) == STT_GNU_IFUNC) &&\r\nsym->st_name != 0 &&\r\nsym->st_shndx != SHN_UNDEF;\r\n}\r\nstatic inline bool elf_sym__is_object(const GElf_Sym *sym)\r\n{\r\nreturn elf_sym__type(sym) == STT_OBJECT &&\r\nsym->st_name != 0 &&\r\nsym->st_shndx != SHN_UNDEF;\r\n}\r\nstatic inline int elf_sym__is_label(const GElf_Sym *sym)\r\n{\r\nreturn elf_sym__type(sym) == STT_NOTYPE &&\r\nsym->st_name != 0 &&\r\nsym->st_shndx != SHN_UNDEF &&\r\nsym->st_shndx != SHN_ABS;\r\n}\r\nstatic bool elf_sym__is_a(GElf_Sym *sym, enum map_type type)\r\n{\r\nswitch (type) {\r\ncase MAP__FUNCTION:\r\nreturn elf_sym__is_function(sym);\r\ncase MAP__VARIABLE:\r\nreturn elf_sym__is_object(sym);\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic inline const char *elf_sym__name(const GElf_Sym *sym,\r\nconst Elf_Data *symstrs)\r\n{\r\nreturn symstrs->d_buf + sym->st_name;\r\n}\r\nstatic inline const char *elf_sec__name(const GElf_Shdr *shdr,\r\nconst Elf_Data *secstrs)\r\n{\r\nreturn secstrs->d_buf + shdr->sh_name;\r\n}\r\nstatic inline int elf_sec__is_text(const GElf_Shdr *shdr,\r\nconst Elf_Data *secstrs)\r\n{\r\nreturn strstr(elf_sec__name(shdr, secstrs), "text") != NULL;\r\n}\r\nstatic inline bool elf_sec__is_data(const GElf_Shdr *shdr,\r\nconst Elf_Data *secstrs)\r\n{\r\nreturn strstr(elf_sec__name(shdr, secstrs), "data") != NULL;\r\n}\r\nstatic bool elf_sec__is_a(GElf_Shdr *shdr, Elf_Data *secstrs,\r\nenum map_type type)\r\n{\r\nswitch (type) {\r\ncase MAP__FUNCTION:\r\nreturn elf_sec__is_text(shdr, secstrs);\r\ncase MAP__VARIABLE:\r\nreturn elf_sec__is_data(shdr, secstrs);\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic size_t elf_addr_to_index(Elf *elf, GElf_Addr addr)\r\n{\r\nElf_Scn *sec = NULL;\r\nGElf_Shdr shdr;\r\nsize_t cnt = 1;\r\nwhile ((sec = elf_nextscn(elf, sec)) != NULL) {\r\ngelf_getshdr(sec, &shdr);\r\nif ((addr >= shdr.sh_addr) &&\r\n(addr < (shdr.sh_addr + shdr.sh_size)))\r\nreturn cnt;\r\n++cnt;\r\n}\r\nreturn -1;\r\n}\r\nElf_Scn *elf_section_by_name(Elf *elf, GElf_Ehdr *ep,\r\nGElf_Shdr *shp, const char *name, size_t *idx)\r\n{\r\nElf_Scn *sec = NULL;\r\nsize_t cnt = 1;\r\nif (!elf_rawdata(elf_getscn(elf, ep->e_shstrndx), NULL))\r\nreturn NULL;\r\nwhile ((sec = elf_nextscn(elf, sec)) != NULL) {\r\nchar *str;\r\ngelf_getshdr(sec, shp);\r\nstr = elf_strptr(elf, ep->e_shstrndx, shp->sh_name);\r\nif (str && !strcmp(name, str)) {\r\nif (idx)\r\n*idx = cnt;\r\nreturn sec;\r\n}\r\n++cnt;\r\n}\r\nreturn NULL;\r\n}\r\nint dso__synthesize_plt_symbols(struct dso *dso, struct symsrc *ss, struct map *map,\r\nsymbol_filter_t filter)\r\n{\r\nuint32_t nr_rel_entries, idx;\r\nGElf_Sym sym;\r\nu64 plt_offset;\r\nGElf_Shdr shdr_plt;\r\nstruct symbol *f;\r\nGElf_Shdr shdr_rel_plt, shdr_dynsym;\r\nElf_Data *reldata, *syms, *symstrs;\r\nElf_Scn *scn_plt_rel, *scn_symstrs, *scn_dynsym;\r\nsize_t dynsym_idx;\r\nGElf_Ehdr ehdr;\r\nchar sympltname[1024];\r\nElf *elf;\r\nint nr = 0, symidx, err = 0;\r\nif (!ss->dynsym)\r\nreturn 0;\r\nelf = ss->elf;\r\nehdr = ss->ehdr;\r\nscn_dynsym = ss->dynsym;\r\nshdr_dynsym = ss->dynshdr;\r\ndynsym_idx = ss->dynsym_idx;\r\nif (scn_dynsym == NULL)\r\ngoto out_elf_end;\r\nscn_plt_rel = elf_section_by_name(elf, &ehdr, &shdr_rel_plt,\r\n".rela.plt", NULL);\r\nif (scn_plt_rel == NULL) {\r\nscn_plt_rel = elf_section_by_name(elf, &ehdr, &shdr_rel_plt,\r\n".rel.plt", NULL);\r\nif (scn_plt_rel == NULL)\r\ngoto out_elf_end;\r\n}\r\nerr = -1;\r\nif (shdr_rel_plt.sh_link != dynsym_idx)\r\ngoto out_elf_end;\r\nif (elf_section_by_name(elf, &ehdr, &shdr_plt, ".plt", NULL) == NULL)\r\ngoto out_elf_end;\r\nreldata = elf_getdata(scn_plt_rel, NULL);\r\nif (reldata == NULL)\r\ngoto out_elf_end;\r\nsyms = elf_getdata(scn_dynsym, NULL);\r\nif (syms == NULL)\r\ngoto out_elf_end;\r\nscn_symstrs = elf_getscn(elf, shdr_dynsym.sh_link);\r\nif (scn_symstrs == NULL)\r\ngoto out_elf_end;\r\nsymstrs = elf_getdata(scn_symstrs, NULL);\r\nif (symstrs == NULL)\r\ngoto out_elf_end;\r\nif (symstrs->d_size == 0)\r\ngoto out_elf_end;\r\nnr_rel_entries = shdr_rel_plt.sh_size / shdr_rel_plt.sh_entsize;\r\nplt_offset = shdr_plt.sh_offset;\r\nif (shdr_rel_plt.sh_type == SHT_RELA) {\r\nGElf_Rela pos_mem, *pos;\r\nelf_section__for_each_rela(reldata, pos, pos_mem, idx,\r\nnr_rel_entries) {\r\nsymidx = GELF_R_SYM(pos->r_info);\r\nplt_offset += shdr_plt.sh_entsize;\r\ngelf_getsym(syms, symidx, &sym);\r\nsnprintf(sympltname, sizeof(sympltname),\r\n"%s@plt", elf_sym__name(&sym, symstrs));\r\nf = symbol__new(plt_offset, shdr_plt.sh_entsize,\r\nSTB_GLOBAL, sympltname);\r\nif (!f)\r\ngoto out_elf_end;\r\nif (filter && filter(map, f))\r\nsymbol__delete(f);\r\nelse {\r\nsymbols__insert(&dso->symbols[map->type], f);\r\n++nr;\r\n}\r\n}\r\n} else if (shdr_rel_plt.sh_type == SHT_REL) {\r\nGElf_Rel pos_mem, *pos;\r\nelf_section__for_each_rel(reldata, pos, pos_mem, idx,\r\nnr_rel_entries) {\r\nsymidx = GELF_R_SYM(pos->r_info);\r\nplt_offset += shdr_plt.sh_entsize;\r\ngelf_getsym(syms, symidx, &sym);\r\nsnprintf(sympltname, sizeof(sympltname),\r\n"%s@plt", elf_sym__name(&sym, symstrs));\r\nf = symbol__new(plt_offset, shdr_plt.sh_entsize,\r\nSTB_GLOBAL, sympltname);\r\nif (!f)\r\ngoto out_elf_end;\r\nif (filter && filter(map, f))\r\nsymbol__delete(f);\r\nelse {\r\nsymbols__insert(&dso->symbols[map->type], f);\r\n++nr;\r\n}\r\n}\r\n}\r\nerr = 0;\r\nout_elf_end:\r\nif (err == 0)\r\nreturn nr;\r\npr_debug("%s: problems reading %s PLT info.\n",\r\n__func__, dso->long_name);\r\nreturn 0;\r\n}\r\nstatic int elf_read_build_id(Elf *elf, void *bf, size_t size)\r\n{\r\nint err = -1;\r\nGElf_Ehdr ehdr;\r\nGElf_Shdr shdr;\r\nElf_Data *data;\r\nElf_Scn *sec;\r\nElf_Kind ek;\r\nvoid *ptr;\r\nif (size < BUILD_ID_SIZE)\r\ngoto out;\r\nek = elf_kind(elf);\r\nif (ek != ELF_K_ELF)\r\ngoto out;\r\nif (gelf_getehdr(elf, &ehdr) == NULL) {\r\npr_err("%s: cannot get elf header.\n", __func__);\r\ngoto out;\r\n}\r\ndo {\r\nsec = elf_section_by_name(elf, &ehdr, &shdr,\r\n".note.gnu.build-id", NULL);\r\nif (sec)\r\nbreak;\r\nsec = elf_section_by_name(elf, &ehdr, &shdr,\r\n".notes", NULL);\r\nif (sec)\r\nbreak;\r\nsec = elf_section_by_name(elf, &ehdr, &shdr,\r\n".note", NULL);\r\nif (sec)\r\nbreak;\r\nreturn err;\r\n} while (0);\r\ndata = elf_getdata(sec, NULL);\r\nif (data == NULL)\r\ngoto out;\r\nptr = data->d_buf;\r\nwhile (ptr < (data->d_buf + data->d_size)) {\r\nGElf_Nhdr *nhdr = ptr;\r\nsize_t namesz = NOTE_ALIGN(nhdr->n_namesz),\r\ndescsz = NOTE_ALIGN(nhdr->n_descsz);\r\nconst char *name;\r\nptr += sizeof(*nhdr);\r\nname = ptr;\r\nptr += namesz;\r\nif (nhdr->n_type == NT_GNU_BUILD_ID &&\r\nnhdr->n_namesz == sizeof("GNU")) {\r\nif (memcmp(name, "GNU", sizeof("GNU")) == 0) {\r\nsize_t sz = min(size, descsz);\r\nmemcpy(bf, ptr, sz);\r\nmemset(bf + sz, 0, size - sz);\r\nerr = descsz;\r\nbreak;\r\n}\r\n}\r\nptr += descsz;\r\n}\r\nout:\r\nreturn err;\r\n}\r\nint filename__read_build_id(const char *filename, void *bf, size_t size)\r\n{\r\nint fd, err = -1;\r\nElf *elf;\r\nif (size < BUILD_ID_SIZE)\r\ngoto out;\r\nfd = open(filename, O_RDONLY);\r\nif (fd < 0)\r\ngoto out;\r\nelf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\r\nif (elf == NULL) {\r\npr_debug2("%s: cannot read %s ELF file.\n", __func__, filename);\r\ngoto out_close;\r\n}\r\nerr = elf_read_build_id(elf, bf, size);\r\nelf_end(elf);\r\nout_close:\r\nclose(fd);\r\nout:\r\nreturn err;\r\n}\r\nint sysfs__read_build_id(const char *filename, void *build_id, size_t size)\r\n{\r\nint fd, err = -1;\r\nif (size < BUILD_ID_SIZE)\r\ngoto out;\r\nfd = open(filename, O_RDONLY);\r\nif (fd < 0)\r\ngoto out;\r\nwhile (1) {\r\nchar bf[BUFSIZ];\r\nGElf_Nhdr nhdr;\r\nsize_t namesz, descsz;\r\nif (read(fd, &nhdr, sizeof(nhdr)) != sizeof(nhdr))\r\nbreak;\r\nnamesz = NOTE_ALIGN(nhdr.n_namesz);\r\ndescsz = NOTE_ALIGN(nhdr.n_descsz);\r\nif (nhdr.n_type == NT_GNU_BUILD_ID &&\r\nnhdr.n_namesz == sizeof("GNU")) {\r\nif (read(fd, bf, namesz) != (ssize_t)namesz)\r\nbreak;\r\nif (memcmp(bf, "GNU", sizeof("GNU")) == 0) {\r\nsize_t sz = min(descsz, size);\r\nif (read(fd, build_id, sz) == (ssize_t)sz) {\r\nmemset(build_id + sz, 0, size - sz);\r\nerr = 0;\r\nbreak;\r\n}\r\n} else if (read(fd, bf, descsz) != (ssize_t)descsz)\r\nbreak;\r\n} else {\r\nint n = namesz + descsz;\r\nif (read(fd, bf, n) != n)\r\nbreak;\r\n}\r\n}\r\nclose(fd);\r\nout:\r\nreturn err;\r\n}\r\nint filename__read_debuglink(const char *filename, char *debuglink,\r\nsize_t size)\r\n{\r\nint fd, err = -1;\r\nElf *elf;\r\nGElf_Ehdr ehdr;\r\nGElf_Shdr shdr;\r\nElf_Data *data;\r\nElf_Scn *sec;\r\nElf_Kind ek;\r\nfd = open(filename, O_RDONLY);\r\nif (fd < 0)\r\ngoto out;\r\nelf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\r\nif (elf == NULL) {\r\npr_debug2("%s: cannot read %s ELF file.\n", __func__, filename);\r\ngoto out_close;\r\n}\r\nek = elf_kind(elf);\r\nif (ek != ELF_K_ELF)\r\ngoto out_elf_end;\r\nif (gelf_getehdr(elf, &ehdr) == NULL) {\r\npr_err("%s: cannot get elf header.\n", __func__);\r\ngoto out_elf_end;\r\n}\r\nsec = elf_section_by_name(elf, &ehdr, &shdr,\r\n".gnu_debuglink", NULL);\r\nif (sec == NULL)\r\ngoto out_elf_end;\r\ndata = elf_getdata(sec, NULL);\r\nif (data == NULL)\r\ngoto out_elf_end;\r\nstrncpy(debuglink, data->d_buf, size);\r\nerr = 0;\r\nout_elf_end:\r\nelf_end(elf);\r\nout_close:\r\nclose(fd);\r\nout:\r\nreturn err;\r\n}\r\nstatic int dso__swap_init(struct dso *dso, unsigned char eidata)\r\n{\r\nstatic unsigned int const endian = 1;\r\ndso->needs_swap = DSO_SWAP__NO;\r\nswitch (eidata) {\r\ncase ELFDATA2LSB:\r\nif (*(unsigned char const *)&endian != 1)\r\ndso->needs_swap = DSO_SWAP__YES;\r\nbreak;\r\ncase ELFDATA2MSB:\r\nif (*(unsigned char const *)&endian != 0)\r\ndso->needs_swap = DSO_SWAP__YES;\r\nbreak;\r\ndefault:\r\npr_err("unrecognized DSO data encoding %d\n", eidata);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int decompress_kmodule(struct dso *dso, const char *name,\r\nenum dso_binary_type type)\r\n{\r\nint fd = -1;\r\nchar tmpbuf[] = "/tmp/perf-kmod-XXXXXX";\r\nstruct kmod_path m;\r\nif (type != DSO_BINARY_TYPE__SYSTEM_PATH_KMODULE_COMP &&\r\ntype != DSO_BINARY_TYPE__GUEST_KMODULE_COMP &&\r\ntype != DSO_BINARY_TYPE__BUILD_ID_CACHE)\r\nreturn -1;\r\nif (type == DSO_BINARY_TYPE__BUILD_ID_CACHE)\r\nname = dso->long_name;\r\nif (kmod_path__parse_ext(&m, name) || !m.comp)\r\nreturn -1;\r\nfd = mkstemp(tmpbuf);\r\nif (fd < 0) {\r\ndso->load_errno = errno;\r\ngoto out;\r\n}\r\nif (!decompress_to_file(m.ext, name, fd)) {\r\ndso->load_errno = DSO_LOAD_ERRNO__DECOMPRESSION_FAILURE;\r\nclose(fd);\r\nfd = -1;\r\n}\r\nunlink(tmpbuf);\r\nout:\r\nfree(m.ext);\r\nreturn fd;\r\n}\r\nbool symsrc__possibly_runtime(struct symsrc *ss)\r\n{\r\nreturn ss->dynsym || ss->opdsec;\r\n}\r\nbool symsrc__has_symtab(struct symsrc *ss)\r\n{\r\nreturn ss->symtab != NULL;\r\n}\r\nvoid symsrc__destroy(struct symsrc *ss)\r\n{\r\nzfree(&ss->name);\r\nelf_end(ss->elf);\r\nclose(ss->fd);\r\n}\r\nbool __weak elf__needs_adjust_symbols(GElf_Ehdr ehdr)\r\n{\r\nreturn ehdr.e_type == ET_EXEC || ehdr.e_type == ET_REL;\r\n}\r\nint symsrc__init(struct symsrc *ss, struct dso *dso, const char *name,\r\nenum dso_binary_type type)\r\n{\r\nint err = -1;\r\nGElf_Ehdr ehdr;\r\nElf *elf;\r\nint fd;\r\nif (dso__needs_decompress(dso)) {\r\nfd = decompress_kmodule(dso, name, type);\r\nif (fd < 0)\r\nreturn -1;\r\n} else {\r\nfd = open(name, O_RDONLY);\r\nif (fd < 0) {\r\ndso->load_errno = errno;\r\nreturn -1;\r\n}\r\n}\r\nelf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\r\nif (elf == NULL) {\r\npr_debug("%s: cannot read %s ELF file.\n", __func__, name);\r\ndso->load_errno = DSO_LOAD_ERRNO__INVALID_ELF;\r\ngoto out_close;\r\n}\r\nif (gelf_getehdr(elf, &ehdr) == NULL) {\r\ndso->load_errno = DSO_LOAD_ERRNO__INVALID_ELF;\r\npr_debug("%s: cannot get elf header.\n", __func__);\r\ngoto out_elf_end;\r\n}\r\nif (dso__swap_init(dso, ehdr.e_ident[EI_DATA])) {\r\ndso->load_errno = DSO_LOAD_ERRNO__INTERNAL_ERROR;\r\ngoto out_elf_end;\r\n}\r\nif (dso->has_build_id) {\r\nu8 build_id[BUILD_ID_SIZE];\r\nif (elf_read_build_id(elf, build_id, BUILD_ID_SIZE) < 0) {\r\ndso->load_errno = DSO_LOAD_ERRNO__CANNOT_READ_BUILDID;\r\ngoto out_elf_end;\r\n}\r\nif (!dso__build_id_equal(dso, build_id)) {\r\npr_debug("%s: build id mismatch for %s.\n", __func__, name);\r\ndso->load_errno = DSO_LOAD_ERRNO__MISMATCHING_BUILDID;\r\ngoto out_elf_end;\r\n}\r\n}\r\nss->is_64_bit = (gelf_getclass(elf) == ELFCLASS64);\r\nss->symtab = elf_section_by_name(elf, &ehdr, &ss->symshdr, ".symtab",\r\nNULL);\r\nif (ss->symshdr.sh_type != SHT_SYMTAB)\r\nss->symtab = NULL;\r\nss->dynsym_idx = 0;\r\nss->dynsym = elf_section_by_name(elf, &ehdr, &ss->dynshdr, ".dynsym",\r\n&ss->dynsym_idx);\r\nif (ss->dynshdr.sh_type != SHT_DYNSYM)\r\nss->dynsym = NULL;\r\nss->opdidx = 0;\r\nss->opdsec = elf_section_by_name(elf, &ehdr, &ss->opdshdr, ".opd",\r\n&ss->opdidx);\r\nif (ss->opdshdr.sh_type != SHT_PROGBITS)\r\nss->opdsec = NULL;\r\nif (dso->kernel == DSO_TYPE_USER) {\r\nGElf_Shdr shdr;\r\nss->adjust_symbols = (ehdr.e_type == ET_EXEC ||\r\nehdr.e_type == ET_REL ||\r\ndso__is_vdso(dso) ||\r\nelf_section_by_name(elf, &ehdr, &shdr,\r\n".gnu.prelink_undo",\r\nNULL) != NULL);\r\n} else {\r\nss->adjust_symbols = elf__needs_adjust_symbols(ehdr);\r\n}\r\nss->name = strdup(name);\r\nif (!ss->name) {\r\ndso->load_errno = errno;\r\ngoto out_elf_end;\r\n}\r\nss->elf = elf;\r\nss->fd = fd;\r\nss->ehdr = ehdr;\r\nss->type = type;\r\nreturn 0;\r\nout_elf_end:\r\nelf_end(elf);\r\nout_close:\r\nclose(fd);\r\nreturn err;\r\n}\r\nstatic bool ref_reloc_sym_not_found(struct kmap *kmap)\r\n{\r\nreturn kmap && kmap->ref_reloc_sym && kmap->ref_reloc_sym->name &&\r\n!kmap->ref_reloc_sym->unrelocated_addr;\r\n}\r\nstatic u64 ref_reloc(struct kmap *kmap)\r\n{\r\nif (kmap && kmap->ref_reloc_sym &&\r\nkmap->ref_reloc_sym->unrelocated_addr)\r\nreturn kmap->ref_reloc_sym->addr -\r\nkmap->ref_reloc_sym->unrelocated_addr;\r\nreturn 0;\r\n}\r\nstatic bool want_demangle(bool is_kernel_sym)\r\n{\r\nreturn is_kernel_sym ? symbol_conf.demangle_kernel : symbol_conf.demangle;\r\n}\r\nvoid __weak arch__elf_sym_adjust(GElf_Sym *sym __maybe_unused) { }\r\nint dso__load_sym(struct dso *dso, struct map *map,\r\nstruct symsrc *syms_ss, struct symsrc *runtime_ss,\r\nsymbol_filter_t filter, int kmodule)\r\n{\r\nstruct kmap *kmap = dso->kernel ? map__kmap(map) : NULL;\r\nstruct map_groups *kmaps = kmap ? map__kmaps(map) : NULL;\r\nstruct map *curr_map = map;\r\nstruct dso *curr_dso = dso;\r\nElf_Data *symstrs, *secstrs;\r\nuint32_t nr_syms;\r\nint err = -1;\r\nuint32_t idx;\r\nGElf_Ehdr ehdr;\r\nGElf_Shdr shdr;\r\nElf_Data *syms, *opddata = NULL;\r\nGElf_Sym sym;\r\nElf_Scn *sec, *sec_strndx;\r\nElf *elf;\r\nint nr = 0;\r\nbool remap_kernel = false, adjust_kernel_syms = false;\r\nif (kmap && !kmaps)\r\nreturn -1;\r\ndso->symtab_type = syms_ss->type;\r\ndso->is_64_bit = syms_ss->is_64_bit;\r\ndso->rel = syms_ss->ehdr.e_type == ET_REL;\r\nif (kmodule && syms_ss->symtab)\r\nsymbols__delete(&dso->symbols[map->type]);\r\nif (!syms_ss->symtab) {\r\nif (dso->kernel)\r\ngoto out_elf_end;\r\nsyms_ss->symtab = syms_ss->dynsym;\r\nsyms_ss->symshdr = syms_ss->dynshdr;\r\n}\r\nelf = syms_ss->elf;\r\nehdr = syms_ss->ehdr;\r\nsec = syms_ss->symtab;\r\nshdr = syms_ss->symshdr;\r\nif (runtime_ss->opdsec)\r\nopddata = elf_rawdata(runtime_ss->opdsec, NULL);\r\nsyms = elf_getdata(sec, NULL);\r\nif (syms == NULL)\r\ngoto out_elf_end;\r\nsec = elf_getscn(elf, shdr.sh_link);\r\nif (sec == NULL)\r\ngoto out_elf_end;\r\nsymstrs = elf_getdata(sec, NULL);\r\nif (symstrs == NULL)\r\ngoto out_elf_end;\r\nsec_strndx = elf_getscn(runtime_ss->elf, runtime_ss->ehdr.e_shstrndx);\r\nif (sec_strndx == NULL)\r\ngoto out_elf_end;\r\nsecstrs = elf_getdata(sec_strndx, NULL);\r\nif (secstrs == NULL)\r\ngoto out_elf_end;\r\nnr_syms = shdr.sh_size / shdr.sh_entsize;\r\nmemset(&sym, 0, sizeof(sym));\r\nif (ref_reloc_sym_not_found(kmap)) {\r\nelf_symtab__for_each_symbol(syms, nr_syms, idx, sym) {\r\nconst char *elf_name = elf_sym__name(&sym, symstrs);\r\nif (strcmp(elf_name, kmap->ref_reloc_sym->name))\r\ncontinue;\r\nkmap->ref_reloc_sym->unrelocated_addr = sym.st_value;\r\nmap->reloc = kmap->ref_reloc_sym->addr -\r\nkmap->ref_reloc_sym->unrelocated_addr;\r\nbreak;\r\n}\r\n}\r\nif (dso__is_vdso(dso)) {\r\nGElf_Shdr tshdr;\r\nif (elf_section_by_name(elf, &ehdr, &tshdr, ".text", NULL))\r\nmap->reloc = map->start - tshdr.sh_addr + tshdr.sh_offset;\r\n}\r\ndso->adjust_symbols = runtime_ss->adjust_symbols || ref_reloc(kmap);\r\nif (map->type == MAP__FUNCTION && (dso->kernel || kmodule)) {\r\nremap_kernel = true;\r\nadjust_kernel_syms = dso->adjust_symbols;\r\n}\r\nelf_symtab__for_each_symbol(syms, nr_syms, idx, sym) {\r\nstruct symbol *f;\r\nconst char *elf_name = elf_sym__name(&sym, symstrs);\r\nchar *demangled = NULL;\r\nint is_label = elf_sym__is_label(&sym);\r\nconst char *section_name;\r\nbool used_opd = false;\r\nif (!is_label && !elf_sym__is_a(&sym, map->type))\r\ncontinue;\r\nif (ehdr.e_machine == EM_ARM || ehdr.e_machine == EM_AARCH64) {\r\nif (elf_name[0] == '$' && strchr("adtx", elf_name[1])\r\n&& (elf_name[2] == '\0' || elf_name[2] == '.'))\r\ncontinue;\r\n}\r\nif (runtime_ss->opdsec && sym.st_shndx == runtime_ss->opdidx) {\r\nu32 offset = sym.st_value - syms_ss->opdshdr.sh_addr;\r\nu64 *opd = opddata->d_buf + offset;\r\nsym.st_value = DSO__SWAP(dso, u64, *opd);\r\nsym.st_shndx = elf_addr_to_index(runtime_ss->elf,\r\nsym.st_value);\r\nused_opd = true;\r\n}\r\nif (sym.st_shndx == SHN_ABS)\r\ncontinue;\r\nsec = elf_getscn(runtime_ss->elf, sym.st_shndx);\r\nif (!sec)\r\ngoto out_elf_end;\r\ngelf_getshdr(sec, &shdr);\r\nif (is_label && !elf_sec__is_a(&shdr, secstrs, map->type))\r\ncontinue;\r\nsection_name = elf_sec__name(&shdr, secstrs);\r\nif ((ehdr.e_machine == EM_ARM) &&\r\n(map->type == MAP__FUNCTION) &&\r\n(sym.st_value & 1))\r\n--sym.st_value;\r\narch__elf_sym_adjust(&sym);\r\nif (dso->kernel || kmodule) {\r\nchar dso_name[PATH_MAX];\r\nif (adjust_kernel_syms)\r\nsym.st_value -= shdr.sh_addr - shdr.sh_offset;\r\nif (strcmp(section_name,\r\n(curr_dso->short_name +\r\ndso->short_name_len)) == 0)\r\ngoto new_symbol;\r\nif (strcmp(section_name, ".text") == 0) {\r\nif (remap_kernel && dso->kernel) {\r\nremap_kernel = false;\r\nmap->start = shdr.sh_addr +\r\nref_reloc(kmap);\r\nmap->end = map->start + shdr.sh_size;\r\nmap->pgoff = shdr.sh_offset;\r\nmap->map_ip = map__map_ip;\r\nmap->unmap_ip = map__unmap_ip;\r\nif (kmaps) {\r\nmap__get(map);\r\nmap_groups__remove(kmaps, map);\r\nmap_groups__insert(kmaps, map);\r\nmap__put(map);\r\n}\r\n}\r\nif (remap_kernel && kmodule) {\r\nremap_kernel = false;\r\nmap->pgoff = shdr.sh_offset;\r\n}\r\ncurr_map = map;\r\ncurr_dso = dso;\r\ngoto new_symbol;\r\n}\r\nif (!kmap)\r\ngoto new_symbol;\r\nsnprintf(dso_name, sizeof(dso_name),\r\n"%s%s", dso->short_name, section_name);\r\ncurr_map = map_groups__find_by_name(kmaps, map->type, dso_name);\r\nif (curr_map == NULL) {\r\nu64 start = sym.st_value;\r\nif (kmodule)\r\nstart += map->start + shdr.sh_offset;\r\ncurr_dso = dso__new(dso_name);\r\nif (curr_dso == NULL)\r\ngoto out_elf_end;\r\ncurr_dso->kernel = dso->kernel;\r\ncurr_dso->long_name = dso->long_name;\r\ncurr_dso->long_name_len = dso->long_name_len;\r\ncurr_map = map__new2(start, curr_dso,\r\nmap->type);\r\nif (curr_map == NULL) {\r\ndso__put(curr_dso);\r\ngoto out_elf_end;\r\n}\r\nif (adjust_kernel_syms) {\r\ncurr_map->start = shdr.sh_addr +\r\nref_reloc(kmap);\r\ncurr_map->end = curr_map->start +\r\nshdr.sh_size;\r\ncurr_map->pgoff = shdr.sh_offset;\r\n} else {\r\ncurr_map->map_ip = identity__map_ip;\r\ncurr_map->unmap_ip = identity__map_ip;\r\n}\r\ncurr_dso->symtab_type = dso->symtab_type;\r\nmap_groups__insert(kmaps, curr_map);\r\ndsos__add(&map->groups->machine->dsos, curr_dso);\r\ndso__set_loaded(curr_dso, map->type);\r\n} else\r\ncurr_dso = curr_map->dso;\r\ngoto new_symbol;\r\n}\r\nif ((used_opd && runtime_ss->adjust_symbols)\r\n|| (!used_opd && syms_ss->adjust_symbols)) {\r\npr_debug4("%s: adjusting symbol: st_value: %#" PRIx64 " "\r\n"sh_addr: %#" PRIx64 " sh_offset: %#" PRIx64 "\n", __func__,\r\n(u64)sym.st_value, (u64)shdr.sh_addr,\r\n(u64)shdr.sh_offset);\r\nsym.st_value -= shdr.sh_addr - shdr.sh_offset;\r\n}\r\nnew_symbol:\r\nif (want_demangle(dso->kernel || kmodule)) {\r\nint demangle_flags = DMGL_NO_OPTS;\r\nif (verbose)\r\ndemangle_flags = DMGL_PARAMS | DMGL_ANSI;\r\ndemangled = bfd_demangle(NULL, elf_name, demangle_flags);\r\nif (demangled != NULL)\r\nelf_name = demangled;\r\n}\r\nf = symbol__new(sym.st_value, sym.st_size,\r\nGELF_ST_BIND(sym.st_info), elf_name);\r\nfree(demangled);\r\nif (!f)\r\ngoto out_elf_end;\r\nif (filter && filter(curr_map, f))\r\nsymbol__delete(f);\r\nelse {\r\nsymbols__insert(&curr_dso->symbols[curr_map->type], f);\r\nnr++;\r\n}\r\n}\r\nif (nr > 0) {\r\nif (!symbol_conf.allow_aliases)\r\nsymbols__fixup_duplicate(&dso->symbols[map->type]);\r\nsymbols__fixup_end(&dso->symbols[map->type]);\r\nif (kmap) {\r\n__map_groups__fixup_end(kmaps, map->type);\r\n}\r\n}\r\nerr = nr;\r\nout_elf_end:\r\nreturn err;\r\n}\r\nstatic int elf_read_maps(Elf *elf, bool exe, mapfn_t mapfn, void *data)\r\n{\r\nGElf_Phdr phdr;\r\nsize_t i, phdrnum;\r\nint err;\r\nu64 sz;\r\nif (elf_getphdrnum(elf, &phdrnum))\r\nreturn -1;\r\nfor (i = 0; i < phdrnum; i++) {\r\nif (gelf_getphdr(elf, i, &phdr) == NULL)\r\nreturn -1;\r\nif (phdr.p_type != PT_LOAD)\r\ncontinue;\r\nif (exe) {\r\nif (!(phdr.p_flags & PF_X))\r\ncontinue;\r\n} else {\r\nif (!(phdr.p_flags & PF_R))\r\ncontinue;\r\n}\r\nsz = min(phdr.p_memsz, phdr.p_filesz);\r\nif (!sz)\r\ncontinue;\r\nerr = mapfn(phdr.p_vaddr, sz, phdr.p_offset, data);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint file__read_maps(int fd, bool exe, mapfn_t mapfn, void *data,\r\nbool *is_64_bit)\r\n{\r\nint err;\r\nElf *elf;\r\nelf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\r\nif (elf == NULL)\r\nreturn -1;\r\nif (is_64_bit)\r\n*is_64_bit = (gelf_getclass(elf) == ELFCLASS64);\r\nerr = elf_read_maps(elf, exe, mapfn, data);\r\nelf_end(elf);\r\nreturn err;\r\n}\r\nenum dso_type dso__type_fd(int fd)\r\n{\r\nenum dso_type dso_type = DSO__TYPE_UNKNOWN;\r\nGElf_Ehdr ehdr;\r\nElf_Kind ek;\r\nElf *elf;\r\nelf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\r\nif (elf == NULL)\r\ngoto out;\r\nek = elf_kind(elf);\r\nif (ek != ELF_K_ELF)\r\ngoto out_end;\r\nif (gelf_getclass(elf) == ELFCLASS64) {\r\ndso_type = DSO__TYPE_64BIT;\r\ngoto out_end;\r\n}\r\nif (gelf_getehdr(elf, &ehdr) == NULL)\r\ngoto out_end;\r\nif (ehdr.e_machine == EM_X86_64)\r\ndso_type = DSO__TYPE_X32BIT;\r\nelse\r\ndso_type = DSO__TYPE_32BIT;\r\nout_end:\r\nelf_end(elf);\r\nout:\r\nreturn dso_type;\r\n}\r\nstatic int copy_bytes(int from, off_t from_offs, int to, off_t to_offs, u64 len)\r\n{\r\nssize_t r;\r\nsize_t n;\r\nint err = -1;\r\nchar *buf = malloc(page_size);\r\nif (buf == NULL)\r\nreturn -1;\r\nif (lseek(to, to_offs, SEEK_SET) != to_offs)\r\ngoto out;\r\nif (lseek(from, from_offs, SEEK_SET) != from_offs)\r\ngoto out;\r\nwhile (len) {\r\nn = page_size;\r\nif (len < n)\r\nn = len;\r\nr = read(from, buf, n);\r\nif (r < 0)\r\ngoto out;\r\nif (!r)\r\nbreak;\r\nn = r;\r\nr = write(to, buf, n);\r\nif (r < 0)\r\ngoto out;\r\nif ((size_t)r != n)\r\ngoto out;\r\nlen -= n;\r\n}\r\nerr = 0;\r\nout:\r\nfree(buf);\r\nreturn err;\r\n}\r\nstatic int kcore__open(struct kcore *kcore, const char *filename)\r\n{\r\nGElf_Ehdr *ehdr;\r\nkcore->fd = open(filename, O_RDONLY);\r\nif (kcore->fd == -1)\r\nreturn -1;\r\nkcore->elf = elf_begin(kcore->fd, ELF_C_READ, NULL);\r\nif (!kcore->elf)\r\ngoto out_close;\r\nkcore->elfclass = gelf_getclass(kcore->elf);\r\nif (kcore->elfclass == ELFCLASSNONE)\r\ngoto out_end;\r\nehdr = gelf_getehdr(kcore->elf, &kcore->ehdr);\r\nif (!ehdr)\r\ngoto out_end;\r\nreturn 0;\r\nout_end:\r\nelf_end(kcore->elf);\r\nout_close:\r\nclose(kcore->fd);\r\nreturn -1;\r\n}\r\nstatic int kcore__init(struct kcore *kcore, char *filename, int elfclass,\r\nbool temp)\r\n{\r\nkcore->elfclass = elfclass;\r\nif (temp)\r\nkcore->fd = mkstemp(filename);\r\nelse\r\nkcore->fd = open(filename, O_WRONLY | O_CREAT | O_EXCL, 0400);\r\nif (kcore->fd == -1)\r\nreturn -1;\r\nkcore->elf = elf_begin(kcore->fd, ELF_C_WRITE, NULL);\r\nif (!kcore->elf)\r\ngoto out_close;\r\nif (!gelf_newehdr(kcore->elf, elfclass))\r\ngoto out_end;\r\nmemset(&kcore->ehdr, 0, sizeof(GElf_Ehdr));\r\nreturn 0;\r\nout_end:\r\nelf_end(kcore->elf);\r\nout_close:\r\nclose(kcore->fd);\r\nunlink(filename);\r\nreturn -1;\r\n}\r\nstatic void kcore__close(struct kcore *kcore)\r\n{\r\nelf_end(kcore->elf);\r\nclose(kcore->fd);\r\n}\r\nstatic int kcore__copy_hdr(struct kcore *from, struct kcore *to, size_t count)\r\n{\r\nGElf_Ehdr *ehdr = &to->ehdr;\r\nGElf_Ehdr *kehdr = &from->ehdr;\r\nmemcpy(ehdr->e_ident, kehdr->e_ident, EI_NIDENT);\r\nehdr->e_type = kehdr->e_type;\r\nehdr->e_machine = kehdr->e_machine;\r\nehdr->e_version = kehdr->e_version;\r\nehdr->e_entry = 0;\r\nehdr->e_shoff = 0;\r\nehdr->e_flags = kehdr->e_flags;\r\nehdr->e_phnum = count;\r\nehdr->e_shentsize = 0;\r\nehdr->e_shnum = 0;\r\nehdr->e_shstrndx = 0;\r\nif (from->elfclass == ELFCLASS32) {\r\nehdr->e_phoff = sizeof(Elf32_Ehdr);\r\nehdr->e_ehsize = sizeof(Elf32_Ehdr);\r\nehdr->e_phentsize = sizeof(Elf32_Phdr);\r\n} else {\r\nehdr->e_phoff = sizeof(Elf64_Ehdr);\r\nehdr->e_ehsize = sizeof(Elf64_Ehdr);\r\nehdr->e_phentsize = sizeof(Elf64_Phdr);\r\n}\r\nif (!gelf_update_ehdr(to->elf, ehdr))\r\nreturn -1;\r\nif (!gelf_newphdr(to->elf, count))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int kcore__add_phdr(struct kcore *kcore, int idx, off_t offset,\r\nu64 addr, u64 len)\r\n{\r\nGElf_Phdr phdr = {\r\n.p_type = PT_LOAD,\r\n.p_flags = PF_R | PF_W | PF_X,\r\n.p_offset = offset,\r\n.p_vaddr = addr,\r\n.p_paddr = 0,\r\n.p_filesz = len,\r\n.p_memsz = len,\r\n.p_align = page_size,\r\n};\r\nif (!gelf_update_phdr(kcore->elf, idx, &phdr))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic off_t kcore__write(struct kcore *kcore)\r\n{\r\nreturn elf_update(kcore->elf, ELF_C_WRITE);\r\n}\r\nstatic int kcore_copy__process_kallsyms(void *arg, const char *name, char type,\r\nu64 start)\r\n{\r\nstruct kcore_copy_info *kci = arg;\r\nif (!symbol_type__is_a(type, MAP__FUNCTION))\r\nreturn 0;\r\nif (strchr(name, '[')) {\r\nif (start > kci->last_module_symbol)\r\nkci->last_module_symbol = start;\r\nreturn 0;\r\n}\r\nif (!kci->first_symbol || start < kci->first_symbol)\r\nkci->first_symbol = start;\r\nif (!kci->last_symbol || start > kci->last_symbol)\r\nkci->last_symbol = start;\r\nif (!strcmp(name, "_stext")) {\r\nkci->stext = start;\r\nreturn 0;\r\n}\r\nif (!strcmp(name, "_etext")) {\r\nkci->etext = start;\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kcore_copy__parse_kallsyms(struct kcore_copy_info *kci,\r\nconst char *dir)\r\n{\r\nchar kallsyms_filename[PATH_MAX];\r\nscnprintf(kallsyms_filename, PATH_MAX, "%s/kallsyms", dir);\r\nif (symbol__restricted_filename(kallsyms_filename, "/proc/kallsyms"))\r\nreturn -1;\r\nif (kallsyms__parse(kallsyms_filename, kci,\r\nkcore_copy__process_kallsyms) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int kcore_copy__process_modules(void *arg,\r\nconst char *name __maybe_unused,\r\nu64 start)\r\n{\r\nstruct kcore_copy_info *kci = arg;\r\nif (!kci->first_module || start < kci->first_module)\r\nkci->first_module = start;\r\nreturn 0;\r\n}\r\nstatic int kcore_copy__parse_modules(struct kcore_copy_info *kci,\r\nconst char *dir)\r\n{\r\nchar modules_filename[PATH_MAX];\r\nscnprintf(modules_filename, PATH_MAX, "%s/modules", dir);\r\nif (symbol__restricted_filename(modules_filename, "/proc/modules"))\r\nreturn -1;\r\nif (modules__parse(modules_filename, kci,\r\nkcore_copy__process_modules) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void kcore_copy__map(struct phdr_data *p, u64 start, u64 end, u64 pgoff,\r\nu64 s, u64 e)\r\n{\r\nif (p->addr || s < start || s >= end)\r\nreturn;\r\np->addr = s;\r\np->offset = (s - start) + pgoff;\r\np->len = e < end ? e - s : end - s;\r\n}\r\nstatic int kcore_copy__read_map(u64 start, u64 len, u64 pgoff, void *data)\r\n{\r\nstruct kcore_copy_info *kci = data;\r\nu64 end = start + len;\r\nkcore_copy__map(&kci->kernel_map, start, end, pgoff, kci->stext,\r\nkci->etext);\r\nkcore_copy__map(&kci->modules_map, start, end, pgoff, kci->first_module,\r\nkci->last_module_symbol);\r\nreturn 0;\r\n}\r\nstatic int kcore_copy__read_maps(struct kcore_copy_info *kci, Elf *elf)\r\n{\r\nif (elf_read_maps(elf, true, kcore_copy__read_map, kci) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int kcore_copy__calc_maps(struct kcore_copy_info *kci, const char *dir,\r\nElf *elf)\r\n{\r\nif (kcore_copy__parse_kallsyms(kci, dir))\r\nreturn -1;\r\nif (kcore_copy__parse_modules(kci, dir))\r\nreturn -1;\r\nif (kci->stext)\r\nkci->stext = round_down(kci->stext, page_size);\r\nelse\r\nkci->stext = round_down(kci->first_symbol, page_size);\r\nif (kci->etext) {\r\nkci->etext = round_up(kci->etext, page_size);\r\n} else if (kci->last_symbol) {\r\nkci->etext = round_up(kci->last_symbol, page_size);\r\nkci->etext += page_size;\r\n}\r\nkci->first_module = round_down(kci->first_module, page_size);\r\nif (kci->last_module_symbol) {\r\nkci->last_module_symbol = round_up(kci->last_module_symbol,\r\npage_size);\r\nkci->last_module_symbol += page_size;\r\n}\r\nif (!kci->stext || !kci->etext)\r\nreturn -1;\r\nif (kci->first_module && !kci->last_module_symbol)\r\nreturn -1;\r\nreturn kcore_copy__read_maps(kci, elf);\r\n}\r\nstatic int kcore_copy__copy_file(const char *from_dir, const char *to_dir,\r\nconst char *name)\r\n{\r\nchar from_filename[PATH_MAX];\r\nchar to_filename[PATH_MAX];\r\nscnprintf(from_filename, PATH_MAX, "%s/%s", from_dir, name);\r\nscnprintf(to_filename, PATH_MAX, "%s/%s", to_dir, name);\r\nreturn copyfile_mode(from_filename, to_filename, 0400);\r\n}\r\nstatic int kcore_copy__unlink(const char *dir, const char *name)\r\n{\r\nchar filename[PATH_MAX];\r\nscnprintf(filename, PATH_MAX, "%s/%s", dir, name);\r\nreturn unlink(filename);\r\n}\r\nstatic int kcore_copy__compare_fds(int from, int to)\r\n{\r\nchar *buf_from;\r\nchar *buf_to;\r\nssize_t ret;\r\nsize_t len;\r\nint err = -1;\r\nbuf_from = malloc(page_size);\r\nbuf_to = malloc(page_size);\r\nif (!buf_from || !buf_to)\r\ngoto out;\r\nwhile (1) {\r\nret = read(from, buf_from, page_size);\r\nif (ret < 0)\r\ngoto out;\r\nif (!ret)\r\nbreak;\r\nlen = ret;\r\nif (readn(to, buf_to, len) != (int)len)\r\ngoto out;\r\nif (memcmp(buf_from, buf_to, len))\r\ngoto out;\r\n}\r\nerr = 0;\r\nout:\r\nfree(buf_to);\r\nfree(buf_from);\r\nreturn err;\r\n}\r\nstatic int kcore_copy__compare_files(const char *from_filename,\r\nconst char *to_filename)\r\n{\r\nint from, to, err = -1;\r\nfrom = open(from_filename, O_RDONLY);\r\nif (from < 0)\r\nreturn -1;\r\nto = open(to_filename, O_RDONLY);\r\nif (to < 0)\r\ngoto out_close_from;\r\nerr = kcore_copy__compare_fds(from, to);\r\nclose(to);\r\nout_close_from:\r\nclose(from);\r\nreturn err;\r\n}\r\nstatic int kcore_copy__compare_file(const char *from_dir, const char *to_dir,\r\nconst char *name)\r\n{\r\nchar from_filename[PATH_MAX];\r\nchar to_filename[PATH_MAX];\r\nscnprintf(from_filename, PATH_MAX, "%s/%s", from_dir, name);\r\nscnprintf(to_filename, PATH_MAX, "%s/%s", to_dir, name);\r\nreturn kcore_copy__compare_files(from_filename, to_filename);\r\n}\r\nint kcore_copy(const char *from_dir, const char *to_dir)\r\n{\r\nstruct kcore kcore;\r\nstruct kcore extract;\r\nsize_t count = 2;\r\nint idx = 0, err = -1;\r\noff_t offset = page_size, sz, modules_offset = 0;\r\nstruct kcore_copy_info kci = { .stext = 0, };\r\nchar kcore_filename[PATH_MAX];\r\nchar extract_filename[PATH_MAX];\r\nif (kcore_copy__copy_file(from_dir, to_dir, "kallsyms"))\r\nreturn -1;\r\nif (kcore_copy__copy_file(from_dir, to_dir, "modules"))\r\ngoto out_unlink_kallsyms;\r\nscnprintf(kcore_filename, PATH_MAX, "%s/kcore", from_dir);\r\nscnprintf(extract_filename, PATH_MAX, "%s/kcore", to_dir);\r\nif (kcore__open(&kcore, kcore_filename))\r\ngoto out_unlink_modules;\r\nif (kcore_copy__calc_maps(&kci, from_dir, kcore.elf))\r\ngoto out_kcore_close;\r\nif (kcore__init(&extract, extract_filename, kcore.elfclass, false))\r\ngoto out_kcore_close;\r\nif (!kci.modules_map.addr)\r\ncount -= 1;\r\nif (kcore__copy_hdr(&kcore, &extract, count))\r\ngoto out_extract_close;\r\nif (kcore__add_phdr(&extract, idx++, offset, kci.kernel_map.addr,\r\nkci.kernel_map.len))\r\ngoto out_extract_close;\r\nif (kci.modules_map.addr) {\r\nmodules_offset = offset + kci.kernel_map.len;\r\nif (kcore__add_phdr(&extract, idx, modules_offset,\r\nkci.modules_map.addr, kci.modules_map.len))\r\ngoto out_extract_close;\r\n}\r\nsz = kcore__write(&extract);\r\nif (sz < 0 || sz > offset)\r\ngoto out_extract_close;\r\nif (copy_bytes(kcore.fd, kci.kernel_map.offset, extract.fd, offset,\r\nkci.kernel_map.len))\r\ngoto out_extract_close;\r\nif (modules_offset && copy_bytes(kcore.fd, kci.modules_map.offset,\r\nextract.fd, modules_offset,\r\nkci.modules_map.len))\r\ngoto out_extract_close;\r\nif (kcore_copy__compare_file(from_dir, to_dir, "modules"))\r\ngoto out_extract_close;\r\nif (kcore_copy__compare_file(from_dir, to_dir, "kallsyms"))\r\ngoto out_extract_close;\r\nerr = 0;\r\nout_extract_close:\r\nkcore__close(&extract);\r\nif (err)\r\nunlink(extract_filename);\r\nout_kcore_close:\r\nkcore__close(&kcore);\r\nout_unlink_modules:\r\nif (err)\r\nkcore_copy__unlink(to_dir, "modules");\r\nout_unlink_kallsyms:\r\nif (err)\r\nkcore_copy__unlink(to_dir, "kallsyms");\r\nreturn err;\r\n}\r\nint kcore_extract__create(struct kcore_extract *kce)\r\n{\r\nstruct kcore kcore;\r\nstruct kcore extract;\r\nsize_t count = 1;\r\nint idx = 0, err = -1;\r\noff_t offset = page_size, sz;\r\nif (kcore__open(&kcore, kce->kcore_filename))\r\nreturn -1;\r\nstrcpy(kce->extract_filename, PERF_KCORE_EXTRACT);\r\nif (kcore__init(&extract, kce->extract_filename, kcore.elfclass, true))\r\ngoto out_kcore_close;\r\nif (kcore__copy_hdr(&kcore, &extract, count))\r\ngoto out_extract_close;\r\nif (kcore__add_phdr(&extract, idx, offset, kce->addr, kce->len))\r\ngoto out_extract_close;\r\nsz = kcore__write(&extract);\r\nif (sz < 0 || sz > offset)\r\ngoto out_extract_close;\r\nif (copy_bytes(kcore.fd, kce->offs, extract.fd, offset, kce->len))\r\ngoto out_extract_close;\r\nerr = 0;\r\nout_extract_close:\r\nkcore__close(&extract);\r\nif (err)\r\nunlink(kce->extract_filename);\r\nout_kcore_close:\r\nkcore__close(&kcore);\r\nreturn err;\r\n}\r\nvoid kcore_extract__delete(struct kcore_extract *kce)\r\n{\r\nunlink(kce->extract_filename);\r\n}\r\nvoid symbol__elf_init(void)\r\n{\r\nelf_version(EV_CURRENT);\r\n}
