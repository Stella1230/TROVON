static void faulty_fail(struct bio *bio)\r\n{\r\nstruct bio *b = bio->bi_private;\r\nb->bi_iter.bi_size = bio->bi_iter.bi_size;\r\nb->bi_iter.bi_sector = bio->bi_iter.bi_sector;\r\nbio_put(bio);\r\nbio_io_error(b);\r\n}\r\nstatic int check_mode(struct faulty_conf *conf, int mode)\r\n{\r\nif (conf->period[mode] == 0 &&\r\natomic_read(&conf->counters[mode]) <= 0)\r\nreturn 0;\r\nif (atomic_dec_and_test(&conf->counters[mode])) {\r\nif (conf->period[mode])\r\natomic_set(&conf->counters[mode], conf->period[mode]);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_sector(struct faulty_conf *conf, sector_t start, sector_t end, int dir)\r\n{\r\nint i;\r\nfor (i=0; i<conf->nfaults; i++)\r\nif (conf->faults[i] >= start &&\r\nconf->faults[i] < end) {\r\nswitch (conf->modes[i] * 2 + dir) {\r\ncase WritePersistent*2+WRITE: return 1;\r\ncase ReadPersistent*2+READ: return 1;\r\ncase ReadFixable*2+READ: return 1;\r\ncase ReadFixable*2+WRITE:\r\nconf->modes[i] = NoPersist;\r\nreturn 0;\r\ncase AllPersist*2+READ:\r\ncase AllPersist*2+WRITE: return 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void add_sector(struct faulty_conf *conf, sector_t start, int mode)\r\n{\r\nint i;\r\nint n = conf->nfaults;\r\nfor (i=0; i<conf->nfaults; i++)\r\nif (conf->faults[i] == start) {\r\nswitch(mode) {\r\ncase NoPersist: conf->modes[i] = mode; return;\r\ncase WritePersistent:\r\nif (conf->modes[i] == ReadPersistent ||\r\nconf->modes[i] == ReadFixable)\r\nconf->modes[i] = AllPersist;\r\nelse\r\nconf->modes[i] = WritePersistent;\r\nreturn;\r\ncase ReadPersistent:\r\nif (conf->modes[i] == WritePersistent)\r\nconf->modes[i] = AllPersist;\r\nelse\r\nconf->modes[i] = ReadPersistent;\r\nreturn;\r\ncase ReadFixable:\r\nif (conf->modes[i] == WritePersistent ||\r\nconf->modes[i] == ReadPersistent)\r\nconf->modes[i] = AllPersist;\r\nelse\r\nconf->modes[i] = ReadFixable;\r\nreturn;\r\n}\r\n} else if (conf->modes[i] == NoPersist)\r\nn = i;\r\nif (n >= MaxFault)\r\nreturn;\r\nconf->faults[n] = start;\r\nconf->modes[n] = mode;\r\nif (conf->nfaults == n)\r\nconf->nfaults = n+1;\r\n}\r\nstatic void make_request(struct mddev *mddev, struct bio *bio)\r\n{\r\nstruct faulty_conf *conf = mddev->private;\r\nint failit = 0;\r\nif (bio_data_dir(bio) == WRITE) {\r\nif (atomic_read(&conf->counters[WriteAll])) {\r\nbio_io_error(bio);\r\nreturn;\r\n}\r\nif (check_sector(conf, bio->bi_iter.bi_sector,\r\nbio_end_sector(bio), WRITE))\r\nfailit = 1;\r\nif (check_mode(conf, WritePersistent)) {\r\nadd_sector(conf, bio->bi_iter.bi_sector,\r\nWritePersistent);\r\nfailit = 1;\r\n}\r\nif (check_mode(conf, WriteTransient))\r\nfailit = 1;\r\n} else {\r\nif (check_sector(conf, bio->bi_iter.bi_sector,\r\nbio_end_sector(bio), READ))\r\nfailit = 1;\r\nif (check_mode(conf, ReadTransient))\r\nfailit = 1;\r\nif (check_mode(conf, ReadPersistent)) {\r\nadd_sector(conf, bio->bi_iter.bi_sector,\r\nReadPersistent);\r\nfailit = 1;\r\n}\r\nif (check_mode(conf, ReadFixable)) {\r\nadd_sector(conf, bio->bi_iter.bi_sector,\r\nReadFixable);\r\nfailit = 1;\r\n}\r\n}\r\nif (failit) {\r\nstruct bio *b = bio_clone_mddev(bio, GFP_NOIO, mddev);\r\nb->bi_bdev = conf->rdev->bdev;\r\nb->bi_private = bio;\r\nb->bi_end_io = faulty_fail;\r\nbio = b;\r\n} else\r\nbio->bi_bdev = conf->rdev->bdev;\r\ngeneric_make_request(bio);\r\n}\r\nstatic void status(struct seq_file *seq, struct mddev *mddev)\r\n{\r\nstruct faulty_conf *conf = mddev->private;\r\nint n;\r\nif ((n=atomic_read(&conf->counters[WriteTransient])) != 0)\r\nseq_printf(seq, " WriteTransient=%d(%d)",\r\nn, conf->period[WriteTransient]);\r\nif ((n=atomic_read(&conf->counters[ReadTransient])) != 0)\r\nseq_printf(seq, " ReadTransient=%d(%d)",\r\nn, conf->period[ReadTransient]);\r\nif ((n=atomic_read(&conf->counters[WritePersistent])) != 0)\r\nseq_printf(seq, " WritePersistent=%d(%d)",\r\nn, conf->period[WritePersistent]);\r\nif ((n=atomic_read(&conf->counters[ReadPersistent])) != 0)\r\nseq_printf(seq, " ReadPersistent=%d(%d)",\r\nn, conf->period[ReadPersistent]);\r\nif ((n=atomic_read(&conf->counters[ReadFixable])) != 0)\r\nseq_printf(seq, " ReadFixable=%d(%d)",\r\nn, conf->period[ReadFixable]);\r\nif ((n=atomic_read(&conf->counters[WriteAll])) != 0)\r\nseq_printf(seq, " WriteAll");\r\nseq_printf(seq, " nfaults=%d", conf->nfaults);\r\n}\r\nstatic int reshape(struct mddev *mddev)\r\n{\r\nint mode = mddev->new_layout & ModeMask;\r\nint count = mddev->new_layout >> ModeShift;\r\nstruct faulty_conf *conf = mddev->private;\r\nif (mddev->new_layout < 0)\r\nreturn 0;\r\nif (mode == ClearFaults)\r\nconf->nfaults = 0;\r\nelse if (mode == ClearErrors) {\r\nint i;\r\nfor (i=0 ; i < Modes ; i++) {\r\nconf->period[i] = 0;\r\natomic_set(&conf->counters[i], 0);\r\n}\r\n} else if (mode < Modes) {\r\nconf->period[mode] = count;\r\nif (!count) count++;\r\natomic_set(&conf->counters[mode], count);\r\n} else\r\nreturn -EINVAL;\r\nmddev->new_layout = -1;\r\nmddev->layout = -1;\r\nreturn 0;\r\n}\r\nstatic sector_t faulty_size(struct mddev *mddev, sector_t sectors, int raid_disks)\r\n{\r\nWARN_ONCE(raid_disks,\r\n"%s does not support generic reshape\n", __func__);\r\nif (sectors == 0)\r\nreturn mddev->dev_sectors;\r\nreturn sectors;\r\n}\r\nstatic int run(struct mddev *mddev)\r\n{\r\nstruct md_rdev *rdev;\r\nint i;\r\nstruct faulty_conf *conf;\r\nif (md_check_no_bitmap(mddev))\r\nreturn -EINVAL;\r\nconf = kmalloc(sizeof(*conf), GFP_KERNEL);\r\nif (!conf)\r\nreturn -ENOMEM;\r\nfor (i=0; i<Modes; i++) {\r\natomic_set(&conf->counters[i], 0);\r\nconf->period[i] = 0;\r\n}\r\nconf->nfaults = 0;\r\nrdev_for_each(rdev, mddev) {\r\nconf->rdev = rdev;\r\ndisk_stack_limits(mddev->gendisk, rdev->bdev,\r\nrdev->data_offset << 9);\r\n}\r\nmd_set_array_sectors(mddev, faulty_size(mddev, 0, 0));\r\nmddev->private = conf;\r\nreshape(mddev);\r\nreturn 0;\r\n}\r\nstatic void faulty_free(struct mddev *mddev, void *priv)\r\n{\r\nstruct faulty_conf *conf = priv;\r\nkfree(conf);\r\n}\r\nstatic int __init raid_init(void)\r\n{\r\nreturn register_md_personality(&faulty_personality);\r\n}\r\nstatic void raid_exit(void)\r\n{\r\nunregister_md_personality(&faulty_personality);\r\n}
