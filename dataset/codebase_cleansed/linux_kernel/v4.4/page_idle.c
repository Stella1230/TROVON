static struct page *page_idle_get_page(unsigned long pfn)\r\n{\r\nstruct page *page;\r\nstruct zone *zone;\r\nif (!pfn_valid(pfn))\r\nreturn NULL;\r\npage = pfn_to_page(pfn);\r\nif (!page || !PageLRU(page) ||\r\n!get_page_unless_zero(page))\r\nreturn NULL;\r\nzone = page_zone(page);\r\nspin_lock_irq(&zone->lru_lock);\r\nif (unlikely(!PageLRU(page))) {\r\nput_page(page);\r\npage = NULL;\r\n}\r\nspin_unlock_irq(&zone->lru_lock);\r\nreturn page;\r\n}\r\nstatic int page_idle_clear_pte_refs_one(struct page *page,\r\nstruct vm_area_struct *vma,\r\nunsigned long addr, void *arg)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nspinlock_t *ptl;\r\npmd_t *pmd;\r\npte_t *pte;\r\nbool referenced = false;\r\nif (unlikely(PageTransHuge(page))) {\r\npmd = page_check_address_pmd(page, mm, addr,\r\nPAGE_CHECK_ADDRESS_PMD_FLAG, &ptl);\r\nif (pmd) {\r\nreferenced = pmdp_clear_young_notify(vma, addr, pmd);\r\nspin_unlock(ptl);\r\n}\r\n} else {\r\npte = page_check_address(page, mm, addr, &ptl, 0);\r\nif (pte) {\r\nreferenced = ptep_clear_young_notify(vma, addr, pte);\r\npte_unmap_unlock(pte, ptl);\r\n}\r\n}\r\nif (referenced) {\r\nclear_page_idle(page);\r\nset_page_young(page);\r\n}\r\nreturn SWAP_AGAIN;\r\n}\r\nstatic void page_idle_clear_pte_refs(struct page *page)\r\n{\r\nstatic const struct rmap_walk_control rwc = {\r\n.rmap_one = page_idle_clear_pte_refs_one,\r\n.anon_lock = page_lock_anon_vma_read,\r\n};\r\nbool need_lock;\r\nif (!page_mapped(page) ||\r\n!page_rmapping(page))\r\nreturn;\r\nneed_lock = !PageAnon(page) || PageKsm(page);\r\nif (need_lock && !trylock_page(page))\r\nreturn;\r\nrmap_walk(page, (struct rmap_walk_control *)&rwc);\r\nif (need_lock)\r\nunlock_page(page);\r\n}\r\nstatic ssize_t page_idle_bitmap_read(struct file *file, struct kobject *kobj,\r\nstruct bin_attribute *attr, char *buf,\r\nloff_t pos, size_t count)\r\n{\r\nu64 *out = (u64 *)buf;\r\nstruct page *page;\r\nunsigned long pfn, end_pfn;\r\nint bit;\r\nif (pos % BITMAP_CHUNK_SIZE || count % BITMAP_CHUNK_SIZE)\r\nreturn -EINVAL;\r\npfn = pos * BITS_PER_BYTE;\r\nif (pfn >= max_pfn)\r\nreturn 0;\r\nend_pfn = pfn + count * BITS_PER_BYTE;\r\nif (end_pfn > max_pfn)\r\nend_pfn = ALIGN(max_pfn, BITMAP_CHUNK_BITS);\r\nfor (; pfn < end_pfn; pfn++) {\r\nbit = pfn % BITMAP_CHUNK_BITS;\r\nif (!bit)\r\n*out = 0ULL;\r\npage = page_idle_get_page(pfn);\r\nif (page) {\r\nif (page_is_idle(page)) {\r\npage_idle_clear_pte_refs(page);\r\nif (page_is_idle(page))\r\n*out |= 1ULL << bit;\r\n}\r\nput_page(page);\r\n}\r\nif (bit == BITMAP_CHUNK_BITS - 1)\r\nout++;\r\ncond_resched();\r\n}\r\nreturn (char *)out - buf;\r\n}\r\nstatic ssize_t page_idle_bitmap_write(struct file *file, struct kobject *kobj,\r\nstruct bin_attribute *attr, char *buf,\r\nloff_t pos, size_t count)\r\n{\r\nconst u64 *in = (u64 *)buf;\r\nstruct page *page;\r\nunsigned long pfn, end_pfn;\r\nint bit;\r\nif (pos % BITMAP_CHUNK_SIZE || count % BITMAP_CHUNK_SIZE)\r\nreturn -EINVAL;\r\npfn = pos * BITS_PER_BYTE;\r\nif (pfn >= max_pfn)\r\nreturn -ENXIO;\r\nend_pfn = pfn + count * BITS_PER_BYTE;\r\nif (end_pfn > max_pfn)\r\nend_pfn = ALIGN(max_pfn, BITMAP_CHUNK_BITS);\r\nfor (; pfn < end_pfn; pfn++) {\r\nbit = pfn % BITMAP_CHUNK_BITS;\r\nif ((*in >> bit) & 1) {\r\npage = page_idle_get_page(pfn);\r\nif (page) {\r\npage_idle_clear_pte_refs(page);\r\nset_page_idle(page);\r\nput_page(page);\r\n}\r\n}\r\nif (bit == BITMAP_CHUNK_BITS - 1)\r\nin++;\r\ncond_resched();\r\n}\r\nreturn (char *)in - buf;\r\n}\r\nstatic bool need_page_idle(void)\r\n{\r\nreturn true;\r\n}\r\nstatic int __init page_idle_init(void)\r\n{\r\nint err;\r\nerr = sysfs_create_group(mm_kobj, &page_idle_attr_group);\r\nif (err) {\r\npr_err("page_idle: register sysfs failed\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
