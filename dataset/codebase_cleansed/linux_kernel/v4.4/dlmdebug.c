void dlm_print_one_lock_resource(struct dlm_lock_resource *res)\r\n{\r\nspin_lock(&res->spinlock);\r\n__dlm_print_one_lock_resource(res);\r\nspin_unlock(&res->spinlock);\r\n}\r\nstatic void dlm_print_lockres_refmap(struct dlm_lock_resource *res)\r\n{\r\nint bit;\r\nassert_spin_locked(&res->spinlock);\r\nprintk(" refmap nodes: [ ");\r\nbit = 0;\r\nwhile (1) {\r\nbit = find_next_bit(res->refmap, O2NM_MAX_NODES, bit);\r\nif (bit >= O2NM_MAX_NODES)\r\nbreak;\r\nprintk("%u ", bit);\r\nbit++;\r\n}\r\nprintk("], inflight=%u\n", res->inflight_locks);\r\n}\r\nstatic void __dlm_print_lock(struct dlm_lock *lock)\r\n{\r\nspin_lock(&lock->spinlock);\r\nprintk(" type=%d, conv=%d, node=%u, cookie=%u:%llu, "\r\n"ref=%u, ast=(empty=%c,pend=%c), bast=(empty=%c,pend=%c), "\r\n"pending=(conv=%c,lock=%c,cancel=%c,unlock=%c)\n",\r\nlock->ml.type, lock->ml.convert_type, lock->ml.node,\r\ndlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\r\natomic_read(&lock->lock_refs.refcount),\r\n(list_empty(&lock->ast_list) ? 'y' : 'n'),\r\n(lock->ast_pending ? 'y' : 'n'),\r\n(list_empty(&lock->bast_list) ? 'y' : 'n'),\r\n(lock->bast_pending ? 'y' : 'n'),\r\n(lock->convert_pending ? 'y' : 'n'),\r\n(lock->lock_pending ? 'y' : 'n'),\r\n(lock->cancel_pending ? 'y' : 'n'),\r\n(lock->unlock_pending ? 'y' : 'n'));\r\nspin_unlock(&lock->spinlock);\r\n}\r\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\r\n{\r\nstruct dlm_lock *lock;\r\nchar buf[DLM_LOCKID_NAME_MAX];\r\nassert_spin_locked(&res->spinlock);\r\nstringify_lockname(res->lockname.name, res->lockname.len,\r\nbuf, sizeof(buf));\r\nprintk("lockres: %s, owner=%u, state=%u\n",\r\nbuf, res->owner, res->state);\r\nprintk(" last used: %lu, refcnt: %u, on purge list: %s\n",\r\nres->last_used, atomic_read(&res->refs.refcount),\r\nlist_empty(&res->purge) ? "no" : "yes");\r\nprintk(" on dirty list: %s, on reco list: %s, "\r\n"migrating pending: %s\n",\r\nlist_empty(&res->dirty) ? "no" : "yes",\r\nlist_empty(&res->recovering) ? "no" : "yes",\r\nres->migration_pending ? "yes" : "no");\r\nprintk(" inflight locks: %d, asts reserved: %d\n",\r\nres->inflight_locks, atomic_read(&res->asts_reserved));\r\ndlm_print_lockres_refmap(res);\r\nprintk(" granted queue:\n");\r\nlist_for_each_entry(lock, &res->granted, list) {\r\n__dlm_print_lock(lock);\r\n}\r\nprintk(" converting queue:\n");\r\nlist_for_each_entry(lock, &res->converting, list) {\r\n__dlm_print_lock(lock);\r\n}\r\nprintk(" blocked queue:\n");\r\nlist_for_each_entry(lock, &res->blocked, list) {\r\n__dlm_print_lock(lock);\r\n}\r\n}\r\nvoid dlm_print_one_lock(struct dlm_lock *lockid)\r\n{\r\ndlm_print_one_lock_resource(lockid->lockres);\r\n}\r\nconst char *dlm_errmsg(enum dlm_status err)\r\n{\r\nif (err >= DLM_MAXSTATS || err < 0)\r\nreturn dlm_errmsgs[DLM_MAXSTATS];\r\nreturn dlm_errmsgs[err];\r\n}\r\nconst char *dlm_errname(enum dlm_status err)\r\n{\r\nif (err >= DLM_MAXSTATS || err < 0)\r\nreturn dlm_errnames[DLM_MAXSTATS];\r\nreturn dlm_errnames[err];\r\n}\r\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\r\nint len)\r\n{\r\nint out = 0;\r\n__be64 inode_blkno_be;\r\n#define OCFS2_DENTRY_LOCK_INO_START 18\r\nif (*lockname == 'N') {\r\nmemcpy((__be64 *)&inode_blkno_be,\r\n(char *)&lockname[OCFS2_DENTRY_LOCK_INO_START],\r\nsizeof(__be64));\r\nout += snprintf(buf + out, len - out, "%.*s%08x",\r\nOCFS2_DENTRY_LOCK_INO_START - 1, lockname,\r\n(unsigned int)be64_to_cpu(inode_blkno_be));\r\n} else\r\nout += snprintf(buf + out, len - out, "%.*s",\r\nlocklen, lockname);\r\nreturn out;\r\n}\r\nstatic int stringify_nodemap(unsigned long *nodemap, int maxnodes,\r\nchar *buf, int len)\r\n{\r\nint out = 0;\r\nint i = -1;\r\nwhile ((i = find_next_bit(nodemap, maxnodes, i + 1)) < maxnodes)\r\nout += snprintf(buf + out, len - out, "%d ", i);\r\nreturn out;\r\n}\r\nstatic int dump_mle(struct dlm_master_list_entry *mle, char *buf, int len)\r\n{\r\nint out = 0;\r\nchar *mle_type;\r\nif (mle->type == DLM_MLE_BLOCK)\r\nmle_type = "BLK";\r\nelse if (mle->type == DLM_MLE_MASTER)\r\nmle_type = "MAS";\r\nelse\r\nmle_type = "MIG";\r\nout += stringify_lockname(mle->mname, mle->mnamelen, buf + out, len - out);\r\nout += snprintf(buf + out, len - out,\r\n"\t%3s\tmas=%3u\tnew=%3u\tevt=%1d\tuse=%1d\tref=%3d\n",\r\nmle_type, mle->master, mle->new_master,\r\n!list_empty(&mle->hb_events),\r\n!!mle->inuse,\r\natomic_read(&mle->mle_refs.refcount));\r\nout += snprintf(buf + out, len - out, "Maybe=");\r\nout += stringify_nodemap(mle->maybe_map, O2NM_MAX_NODES,\r\nbuf + out, len - out);\r\nout += snprintf(buf + out, len - out, "\n");\r\nout += snprintf(buf + out, len - out, "Vote=");\r\nout += stringify_nodemap(mle->vote_map, O2NM_MAX_NODES,\r\nbuf + out, len - out);\r\nout += snprintf(buf + out, len - out, "\n");\r\nout += snprintf(buf + out, len - out, "Response=");\r\nout += stringify_nodemap(mle->response_map, O2NM_MAX_NODES,\r\nbuf + out, len - out);\r\nout += snprintf(buf + out, len - out, "\n");\r\nout += snprintf(buf + out, len - out, "Node=");\r\nout += stringify_nodemap(mle->node_map, O2NM_MAX_NODES,\r\nbuf + out, len - out);\r\nout += snprintf(buf + out, len - out, "\n");\r\nout += snprintf(buf + out, len - out, "\n");\r\nreturn out;\r\n}\r\nvoid dlm_print_one_mle(struct dlm_master_list_entry *mle)\r\n{\r\nchar *buf;\r\nbuf = (char *) get_zeroed_page(GFP_NOFS);\r\nif (buf) {\r\ndump_mle(mle, buf, PAGE_SIZE - 1);\r\nfree_page((unsigned long)buf);\r\n}\r\n}\r\nstatic void dlm_debug_free(struct kref *kref)\r\n{\r\nstruct dlm_debug_ctxt *dc;\r\ndc = container_of(kref, struct dlm_debug_ctxt, debug_refcnt);\r\nkfree(dc);\r\n}\r\nstatic void dlm_debug_put(struct dlm_debug_ctxt *dc)\r\n{\r\nif (dc)\r\nkref_put(&dc->debug_refcnt, dlm_debug_free);\r\n}\r\nstatic void dlm_debug_get(struct dlm_debug_ctxt *dc)\r\n{\r\nkref_get(&dc->debug_refcnt);\r\n}\r\nstatic int debug_release(struct inode *inode, struct file *file)\r\n{\r\nfree_page((unsigned long)file->private_data);\r\nreturn 0;\r\n}\r\nstatic ssize_t debug_read(struct file *file, char __user *buf,\r\nsize_t nbytes, loff_t *ppos)\r\n{\r\nreturn simple_read_from_buffer(buf, nbytes, ppos, file->private_data,\r\ni_size_read(file->f_mapping->host));\r\n}\r\nstatic int debug_purgelist_print(struct dlm_ctxt *dlm, char *buf, int len)\r\n{\r\nstruct dlm_lock_resource *res;\r\nint out = 0;\r\nunsigned long total = 0;\r\nout += snprintf(buf + out, len - out,\r\n"Dumping Purgelist for Domain: %s\n", dlm->name);\r\nspin_lock(&dlm->spinlock);\r\nlist_for_each_entry(res, &dlm->purge_list, purge) {\r\n++total;\r\nif (len - out < 100)\r\ncontinue;\r\nspin_lock(&res->spinlock);\r\nout += stringify_lockname(res->lockname.name,\r\nres->lockname.len,\r\nbuf + out, len - out);\r\nout += snprintf(buf + out, len - out, "\t%ld\n",\r\n(jiffies - res->last_used)/HZ);\r\nspin_unlock(&res->spinlock);\r\n}\r\nspin_unlock(&dlm->spinlock);\r\nout += snprintf(buf + out, len - out, "Total on list: %lu\n", total);\r\nreturn out;\r\n}\r\nstatic int debug_purgelist_open(struct inode *inode, struct file *file)\r\n{\r\nstruct dlm_ctxt *dlm = inode->i_private;\r\nchar *buf = NULL;\r\nbuf = (char *) get_zeroed_page(GFP_NOFS);\r\nif (!buf)\r\ngoto bail;\r\ni_size_write(inode, debug_purgelist_print(dlm, buf, PAGE_SIZE - 1));\r\nfile->private_data = buf;\r\nreturn 0;\r\nbail:\r\nreturn -ENOMEM;\r\n}\r\nstatic int debug_mle_print(struct dlm_ctxt *dlm, char *buf, int len)\r\n{\r\nstruct dlm_master_list_entry *mle;\r\nstruct hlist_head *bucket;\r\nint i, out = 0;\r\nunsigned long total = 0, longest = 0, bucket_count = 0;\r\nout += snprintf(buf + out, len - out,\r\n"Dumping MLEs for Domain: %s\n", dlm->name);\r\nspin_lock(&dlm->master_lock);\r\nfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\r\nbucket = dlm_master_hash(dlm, i);\r\nhlist_for_each_entry(mle, bucket, master_hash_node) {\r\n++total;\r\n++bucket_count;\r\nif (len - out < 200)\r\ncontinue;\r\nout += dump_mle(mle, buf + out, len - out);\r\n}\r\nlongest = max(longest, bucket_count);\r\nbucket_count = 0;\r\n}\r\nspin_unlock(&dlm->master_lock);\r\nout += snprintf(buf + out, len - out,\r\n"Total: %lu, Longest: %lu\n", total, longest);\r\nreturn out;\r\n}\r\nstatic int debug_mle_open(struct inode *inode, struct file *file)\r\n{\r\nstruct dlm_ctxt *dlm = inode->i_private;\r\nchar *buf = NULL;\r\nbuf = (char *) get_zeroed_page(GFP_NOFS);\r\nif (!buf)\r\ngoto bail;\r\ni_size_write(inode, debug_mle_print(dlm, buf, PAGE_SIZE - 1));\r\nfile->private_data = buf;\r\nreturn 0;\r\nbail:\r\nreturn -ENOMEM;\r\n}\r\nstatic int dump_lock(struct dlm_lock *lock, int list_type, char *buf, int len)\r\n{\r\nint out;\r\n#define DEBUG_LOCK_VERSION 1\r\nspin_lock(&lock->spinlock);\r\nout = snprintf(buf, len, "LOCK:%d,%d,%d,%d,%d,%d:%lld,%d,%d,%d,%d,%d,"\r\n"%d,%d,%d,%d\n",\r\nDEBUG_LOCK_VERSION,\r\nlist_type, lock->ml.type, lock->ml.convert_type,\r\nlock->ml.node,\r\ndlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\r\n!list_empty(&lock->ast_list),\r\n!list_empty(&lock->bast_list),\r\nlock->ast_pending, lock->bast_pending,\r\nlock->convert_pending, lock->lock_pending,\r\nlock->cancel_pending, lock->unlock_pending,\r\natomic_read(&lock->lock_refs.refcount));\r\nspin_unlock(&lock->spinlock);\r\nreturn out;\r\n}\r\nstatic int dump_lockres(struct dlm_lock_resource *res, char *buf, int len)\r\n{\r\nstruct dlm_lock *lock;\r\nint i;\r\nint out = 0;\r\nout += snprintf(buf + out, len - out, "NAME:");\r\nout += stringify_lockname(res->lockname.name, res->lockname.len,\r\nbuf + out, len - out);\r\nout += snprintf(buf + out, len - out, "\n");\r\n#define DEBUG_LRES_VERSION 1\r\nout += snprintf(buf + out, len - out,\r\n"LRES:%d,%d,%d,%ld,%d,%d,%d,%d,%d,%d,%d\n",\r\nDEBUG_LRES_VERSION,\r\nres->owner, res->state, res->last_used,\r\n!list_empty(&res->purge),\r\n!list_empty(&res->dirty),\r\n!list_empty(&res->recovering),\r\nres->inflight_locks, res->migration_pending,\r\natomic_read(&res->asts_reserved),\r\natomic_read(&res->refs.refcount));\r\nout += snprintf(buf + out, len - out, "RMAP:");\r\nout += stringify_nodemap(res->refmap, O2NM_MAX_NODES,\r\nbuf + out, len - out);\r\nout += snprintf(buf + out, len - out, "\n");\r\nout += snprintf(buf + out, len - out, "LVBX:");\r\nfor (i = 0; i < DLM_LVB_LEN; i++)\r\nout += snprintf(buf + out, len - out,\r\n"%02x", (unsigned char)res->lvb[i]);\r\nout += snprintf(buf + out, len - out, "\n");\r\nlist_for_each_entry(lock, &res->granted, list)\r\nout += dump_lock(lock, 0, buf + out, len - out);\r\nlist_for_each_entry(lock, &res->converting, list)\r\nout += dump_lock(lock, 1, buf + out, len - out);\r\nlist_for_each_entry(lock, &res->blocked, list)\r\nout += dump_lock(lock, 2, buf + out, len - out);\r\nout += snprintf(buf + out, len - out, "\n");\r\nreturn out;\r\n}\r\nstatic void *lockres_seq_start(struct seq_file *m, loff_t *pos)\r\n{\r\nstruct debug_lockres *dl = m->private;\r\nstruct dlm_ctxt *dlm = dl->dl_ctxt;\r\nstruct dlm_lock_resource *oldres = dl->dl_res;\r\nstruct dlm_lock_resource *res = NULL;\r\nstruct list_head *track_list;\r\nspin_lock(&dlm->track_lock);\r\nif (oldres)\r\ntrack_list = &oldres->tracking;\r\nelse {\r\ntrack_list = &dlm->tracking_list;\r\nif (list_empty(track_list)) {\r\ndl = NULL;\r\nspin_unlock(&dlm->track_lock);\r\ngoto bail;\r\n}\r\n}\r\nlist_for_each_entry(res, track_list, tracking) {\r\nif (&res->tracking == &dlm->tracking_list)\r\nres = NULL;\r\nelse\r\ndlm_lockres_get(res);\r\nbreak;\r\n}\r\nspin_unlock(&dlm->track_lock);\r\nif (oldres)\r\ndlm_lockres_put(oldres);\r\ndl->dl_res = res;\r\nif (res) {\r\nspin_lock(&res->spinlock);\r\ndump_lockres(res, dl->dl_buf, dl->dl_len - 1);\r\nspin_unlock(&res->spinlock);\r\n} else\r\ndl = NULL;\r\nbail:\r\nreturn dl;\r\n}\r\nstatic void lockres_seq_stop(struct seq_file *m, void *v)\r\n{\r\n}\r\nstatic void *lockres_seq_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int lockres_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct debug_lockres *dl = (struct debug_lockres *)v;\r\nseq_printf(s, "%s", dl->dl_buf);\r\nreturn 0;\r\n}\r\nstatic int debug_lockres_open(struct inode *inode, struct file *file)\r\n{\r\nstruct dlm_ctxt *dlm = inode->i_private;\r\nstruct debug_lockres *dl;\r\nvoid *buf;\r\nbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!buf)\r\ngoto bail;\r\ndl = __seq_open_private(file, &debug_lockres_ops, sizeof(*dl));\r\nif (!dl)\r\ngoto bailfree;\r\ndl->dl_len = PAGE_SIZE;\r\ndl->dl_buf = buf;\r\ndlm_grab(dlm);\r\ndl->dl_ctxt = dlm;\r\nreturn 0;\r\nbailfree:\r\nkfree(buf);\r\nbail:\r\nmlog_errno(-ENOMEM);\r\nreturn -ENOMEM;\r\n}\r\nstatic int debug_lockres_release(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct debug_lockres *dl = (struct debug_lockres *)seq->private;\r\nif (dl->dl_res)\r\ndlm_lockres_put(dl->dl_res);\r\ndlm_put(dl->dl_ctxt);\r\nkfree(dl->dl_buf);\r\nreturn seq_release_private(inode, file);\r\n}\r\nstatic int debug_state_print(struct dlm_ctxt *dlm, char *buf, int len)\r\n{\r\nint out = 0;\r\nstruct dlm_reco_node_data *node;\r\nchar *state;\r\nint cur_mles = 0, tot_mles = 0;\r\nint i;\r\nspin_lock(&dlm->spinlock);\r\nswitch (dlm->dlm_state) {\r\ncase DLM_CTXT_NEW:\r\nstate = "NEW"; break;\r\ncase DLM_CTXT_JOINED:\r\nstate = "JOINED"; break;\r\ncase DLM_CTXT_IN_SHUTDOWN:\r\nstate = "SHUTDOWN"; break;\r\ncase DLM_CTXT_LEAVING:\r\nstate = "LEAVING"; break;\r\ndefault:\r\nstate = "UNKNOWN"; break;\r\n}\r\nout += snprintf(buf + out, len - out,\r\n"Domain: %s Key: 0x%08x Protocol: %d.%d\n",\r\ndlm->name, dlm->key, dlm->dlm_locking_proto.pv_major,\r\ndlm->dlm_locking_proto.pv_minor);\r\nout += snprintf(buf + out, len - out,\r\n"Thread Pid: %d Node: %d State: %s\n",\r\ntask_pid_nr(dlm->dlm_thread_task), dlm->node_num, state);\r\nout += snprintf(buf + out, len - out,\r\n"Number of Joins: %d Joining Node: %d\n",\r\ndlm->num_joins, dlm->joining_node);\r\nout += snprintf(buf + out, len - out, "Domain Map: ");\r\nout += stringify_nodemap(dlm->domain_map, O2NM_MAX_NODES,\r\nbuf + out, len - out);\r\nout += snprintf(buf + out, len - out, "\n");\r\nout += snprintf(buf + out, len - out, "Exit Domain Map: ");\r\nout += stringify_nodemap(dlm->exit_domain_map, O2NM_MAX_NODES,\r\nbuf + out, len - out);\r\nout += snprintf(buf + out, len - out, "\n");\r\nout += snprintf(buf + out, len - out, "Live Map: ");\r\nout += stringify_nodemap(dlm->live_nodes_map, O2NM_MAX_NODES,\r\nbuf + out, len - out);\r\nout += snprintf(buf + out, len - out, "\n");\r\nout += snprintf(buf + out, len - out,\r\n"Lock Resources: %d (%d)\n",\r\natomic_read(&dlm->res_cur_count),\r\natomic_read(&dlm->res_tot_count));\r\nfor (i = 0; i < DLM_MLE_NUM_TYPES; ++i)\r\ntot_mles += atomic_read(&dlm->mle_tot_count[i]);\r\nfor (i = 0; i < DLM_MLE_NUM_TYPES; ++i)\r\ncur_mles += atomic_read(&dlm->mle_cur_count[i]);\r\nout += snprintf(buf + out, len - out,\r\n"MLEs: %d (%d)\n", cur_mles, tot_mles);\r\nout += snprintf(buf + out, len - out,\r\n" Blocking: %d (%d)\n",\r\natomic_read(&dlm->mle_cur_count[DLM_MLE_BLOCK]),\r\natomic_read(&dlm->mle_tot_count[DLM_MLE_BLOCK]));\r\nout += snprintf(buf + out, len - out,\r\n" Mastery: %d (%d)\n",\r\natomic_read(&dlm->mle_cur_count[DLM_MLE_MASTER]),\r\natomic_read(&dlm->mle_tot_count[DLM_MLE_MASTER]));\r\nout += snprintf(buf + out, len - out,\r\n" Migration: %d (%d)\n",\r\natomic_read(&dlm->mle_cur_count[DLM_MLE_MIGRATION]),\r\natomic_read(&dlm->mle_tot_count[DLM_MLE_MIGRATION]));\r\nout += snprintf(buf + out, len - out,\r\n"Lists: Dirty=%s Purge=%s PendingASTs=%s "\r\n"PendingBASTs=%s\n",\r\n(list_empty(&dlm->dirty_list) ? "Empty" : "InUse"),\r\n(list_empty(&dlm->purge_list) ? "Empty" : "InUse"),\r\n(list_empty(&dlm->pending_asts) ? "Empty" : "InUse"),\r\n(list_empty(&dlm->pending_basts) ? "Empty" : "InUse"));\r\nout += snprintf(buf + out, len - out,\r\n"Purge Count: %d Refs: %d\n", dlm->purge_count,\r\natomic_read(&dlm->dlm_refs.refcount));\r\nout += snprintf(buf + out, len - out,\r\n"Dead Node: %d\n", dlm->reco.dead_node);\r\nif (dlm->reco.state == DLM_RECO_STATE_ACTIVE)\r\nstate = "ACTIVE";\r\nelse\r\nstate = "INACTIVE";\r\nout += snprintf(buf + out, len - out,\r\n"Recovery Pid: %d Master: %d State: %s\n",\r\ntask_pid_nr(dlm->dlm_reco_thread_task),\r\ndlm->reco.new_master, state);\r\nout += snprintf(buf + out, len - out, "Recovery Map: ");\r\nout += stringify_nodemap(dlm->recovery_map, O2NM_MAX_NODES,\r\nbuf + out, len - out);\r\nout += snprintf(buf + out, len - out, "\n");\r\nout += snprintf(buf + out, len - out, "Recovery Node State:\n");\r\nlist_for_each_entry(node, &dlm->reco.node_data, list) {\r\nswitch (node->state) {\r\ncase DLM_RECO_NODE_DATA_INIT:\r\nstate = "INIT";\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_REQUESTING:\r\nstate = "REQUESTING";\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_DEAD:\r\nstate = "DEAD";\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_RECEIVING:\r\nstate = "RECEIVING";\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_REQUESTED:\r\nstate = "REQUESTED";\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_DONE:\r\nstate = "DONE";\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_FINALIZE_SENT:\r\nstate = "FINALIZE-SENT";\r\nbreak;\r\ndefault:\r\nstate = "BAD";\r\nbreak;\r\n}\r\nout += snprintf(buf + out, len - out, "\t%u - %s\n",\r\nnode->node_num, state);\r\n}\r\nspin_unlock(&dlm->spinlock);\r\nreturn out;\r\n}\r\nstatic int debug_state_open(struct inode *inode, struct file *file)\r\n{\r\nstruct dlm_ctxt *dlm = inode->i_private;\r\nchar *buf = NULL;\r\nbuf = (char *) get_zeroed_page(GFP_NOFS);\r\nif (!buf)\r\ngoto bail;\r\ni_size_write(inode, debug_state_print(dlm, buf, PAGE_SIZE - 1));\r\nfile->private_data = buf;\r\nreturn 0;\r\nbail:\r\nreturn -ENOMEM;\r\n}\r\nint dlm_debug_init(struct dlm_ctxt *dlm)\r\n{\r\nstruct dlm_debug_ctxt *dc = dlm->dlm_debug_ctxt;\r\ndc->debug_state_dentry = debugfs_create_file(DLM_DEBUGFS_DLM_STATE,\r\nS_IFREG|S_IRUSR,\r\ndlm->dlm_debugfs_subroot,\r\ndlm, &debug_state_fops);\r\nif (!dc->debug_state_dentry) {\r\nmlog_errno(-ENOMEM);\r\ngoto bail;\r\n}\r\ndc->debug_lockres_dentry =\r\ndebugfs_create_file(DLM_DEBUGFS_LOCKING_STATE,\r\nS_IFREG|S_IRUSR,\r\ndlm->dlm_debugfs_subroot,\r\ndlm, &debug_lockres_fops);\r\nif (!dc->debug_lockres_dentry) {\r\nmlog_errno(-ENOMEM);\r\ngoto bail;\r\n}\r\ndc->debug_mle_dentry = debugfs_create_file(DLM_DEBUGFS_MLE_STATE,\r\nS_IFREG|S_IRUSR,\r\ndlm->dlm_debugfs_subroot,\r\ndlm, &debug_mle_fops);\r\nif (!dc->debug_mle_dentry) {\r\nmlog_errno(-ENOMEM);\r\ngoto bail;\r\n}\r\ndc->debug_purgelist_dentry =\r\ndebugfs_create_file(DLM_DEBUGFS_PURGE_LIST,\r\nS_IFREG|S_IRUSR,\r\ndlm->dlm_debugfs_subroot,\r\ndlm, &debug_purgelist_fops);\r\nif (!dc->debug_purgelist_dentry) {\r\nmlog_errno(-ENOMEM);\r\ngoto bail;\r\n}\r\ndlm_debug_get(dc);\r\nreturn 0;\r\nbail:\r\ndlm_debug_shutdown(dlm);\r\nreturn -ENOMEM;\r\n}\r\nvoid dlm_debug_shutdown(struct dlm_ctxt *dlm)\r\n{\r\nstruct dlm_debug_ctxt *dc = dlm->dlm_debug_ctxt;\r\nif (dc) {\r\ndebugfs_remove(dc->debug_purgelist_dentry);\r\ndebugfs_remove(dc->debug_mle_dentry);\r\ndebugfs_remove(dc->debug_lockres_dentry);\r\ndebugfs_remove(dc->debug_state_dentry);\r\ndlm_debug_put(dc);\r\n}\r\n}\r\nint dlm_create_debugfs_subroot(struct dlm_ctxt *dlm)\r\n{\r\ndlm->dlm_debugfs_subroot = debugfs_create_dir(dlm->name,\r\ndlm_debugfs_root);\r\nif (!dlm->dlm_debugfs_subroot) {\r\nmlog_errno(-ENOMEM);\r\ngoto bail;\r\n}\r\ndlm->dlm_debug_ctxt = kzalloc(sizeof(struct dlm_debug_ctxt),\r\nGFP_KERNEL);\r\nif (!dlm->dlm_debug_ctxt) {\r\nmlog_errno(-ENOMEM);\r\ngoto bail;\r\n}\r\nkref_init(&dlm->dlm_debug_ctxt->debug_refcnt);\r\nreturn 0;\r\nbail:\r\ndlm_destroy_debugfs_subroot(dlm);\r\nreturn -ENOMEM;\r\n}\r\nvoid dlm_destroy_debugfs_subroot(struct dlm_ctxt *dlm)\r\n{\r\ndebugfs_remove(dlm->dlm_debugfs_subroot);\r\n}\r\nint dlm_create_debugfs_root(void)\r\n{\r\ndlm_debugfs_root = debugfs_create_dir(DLM_DEBUGFS_DIR, NULL);\r\nif (!dlm_debugfs_root) {\r\nmlog_errno(-ENOMEM);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid dlm_destroy_debugfs_root(void)\r\n{\r\ndebugfs_remove(dlm_debugfs_root);\r\n}
