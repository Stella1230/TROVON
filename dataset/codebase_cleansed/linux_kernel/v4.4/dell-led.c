static int dell_wmi_perform_query(struct app_wmi_args *args)\r\n{\r\nstruct app_wmi_args *bios_return;\r\nunion acpi_object *obj;\r\nstruct acpi_buffer input;\r\nstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\r\nacpi_status status;\r\nu32 rc = -EINVAL;\r\ninput.length = 128;\r\ninput.pointer = args;\r\nstatus = wmi_evaluate_method(DELL_APP_GUID, 0, 1, &input, &output);\r\nif (!ACPI_SUCCESS(status))\r\ngoto err_out0;\r\nobj = output.pointer;\r\nif (!obj)\r\ngoto err_out0;\r\nif (obj->type != ACPI_TYPE_BUFFER)\r\ngoto err_out1;\r\nbios_return = (struct app_wmi_args *)obj->buffer.pointer;\r\nrc = bios_return->res1;\r\nif (rc)\r\ngoto err_out1;\r\nmemcpy(args, bios_return, sizeof(struct app_wmi_args));\r\nrc = 0;\r\nerr_out1:\r\nkfree(obj);\r\nerr_out0:\r\nreturn rc;\r\n}\r\nstatic void __init find_micmute_tokens(const struct dmi_header *dm, void *dummy)\r\n{\r\nstruct dell_bios_calling_interface *calling_interface;\r\nstruct dell_bios_data_token *token;\r\nint token_size = sizeof(struct dell_bios_data_token);\r\nint i = 0;\r\nif (dm->type == 0xda && dm->length > 17) {\r\ncalling_interface = container_of(dm,\r\nstruct dell_bios_calling_interface, header);\r\ntoken = &calling_interface->damap[i];\r\nwhile (token->tokenid != 0xffff) {\r\nif (token->tokenid == GLOBAL_MIC_MUTE_DISABLE)\r\nmemcpy(&dell_mic_tokens[0], token, token_size);\r\nelse if (token->tokenid == GLOBAL_MIC_MUTE_ENABLE)\r\nmemcpy(&dell_mic_tokens[1], token, token_size);\r\ni++;\r\ntoken = &calling_interface->damap[i];\r\n}\r\n}\r\n}\r\nstatic int dell_micmute_led_set(int state)\r\n{\r\nstruct app_wmi_args args;\r\nstruct dell_bios_data_token *token;\r\nif (!wmi_has_guid(DELL_APP_GUID))\r\nreturn -ENODEV;\r\nif (state == 0 || state == 1)\r\ntoken = &dell_mic_tokens[state];\r\nelse\r\nreturn -EINVAL;\r\nmemset(&args, 0, sizeof(struct app_wmi_args));\r\nargs.class = 1;\r\nargs.arg1 = token->location;\r\nargs.arg2 = token->value;\r\ndell_wmi_perform_query(&args);\r\nreturn state;\r\n}\r\nint dell_app_wmi_led_set(int whichled, int on)\r\n{\r\nint state = 0;\r\nswitch (whichled) {\r\ncase DELL_LED_MICMUTE:\r\nstate = dell_micmute_led_set(on);\r\nbreak;\r\ndefault:\r\npr_warn("led type %x is not supported\n", whichled);\r\nbreak;\r\n}\r\nreturn state;\r\n}\r\nstatic int __init dell_micmute_led_init(void)\r\n{\r\nmemset(dell_mic_tokens, 0, sizeof(struct dell_bios_data_token) * 2);\r\ndmi_walk(find_micmute_tokens, NULL);\r\nreturn 0;\r\n}\r\nstatic int dell_led_perform_fn(u8 length,\r\nu8 result_code,\r\nu8 device_id,\r\nu8 command,\r\nu8 on_time,\r\nu8 off_time)\r\n{\r\nstruct bios_args *bios_return;\r\nu8 return_code;\r\nunion acpi_object *obj;\r\nstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct acpi_buffer input;\r\nacpi_status status;\r\nstruct bios_args args;\r\nargs.length = length;\r\nargs.result_code = result_code;\r\nargs.device_id = device_id;\r\nargs.command = command;\r\nargs.on_time = on_time;\r\nargs.off_time = off_time;\r\ninput.length = sizeof(struct bios_args);\r\ninput.pointer = &args;\r\nstatus = wmi_evaluate_method(DELL_LED_BIOS_GUID,\r\n1,\r\n1,\r\n&input,\r\n&output);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nobj = output.pointer;\r\nif (!obj)\r\nreturn -EINVAL;\r\nelse if (obj->type != ACPI_TYPE_BUFFER) {\r\nkfree(obj);\r\nreturn -EINVAL;\r\n}\r\nbios_return = ((struct bios_args *)obj->buffer.pointer);\r\nreturn_code = bios_return->result_code;\r\nkfree(obj);\r\nreturn return_code;\r\n}\r\nstatic int led_on(void)\r\n{\r\nreturn dell_led_perform_fn(3,\r\nINTERFACE_ERROR,\r\nDEVICE_ID_PANEL_BACK,\r\nCMD_LED_ON,\r\n0,\r\n0);\r\n}\r\nstatic int led_off(void)\r\n{\r\nreturn dell_led_perform_fn(3,\r\nINTERFACE_ERROR,\r\nDEVICE_ID_PANEL_BACK,\r\nCMD_LED_OFF,\r\n0,\r\n0);\r\n}\r\nstatic int led_blink(unsigned char on_eighths,\r\nunsigned char off_eighths)\r\n{\r\nreturn dell_led_perform_fn(5,\r\nINTERFACE_ERROR,\r\nDEVICE_ID_PANEL_BACK,\r\nCMD_LED_BLINK,\r\non_eighths,\r\noff_eighths);\r\n}\r\nstatic void dell_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nif (value == LED_OFF)\r\nled_off();\r\nelse\r\nled_on();\r\n}\r\nstatic int dell_led_blink(struct led_classdev *led_cdev,\r\nunsigned long *delay_on,\r\nunsigned long *delay_off)\r\n{\r\nunsigned long on_eighths;\r\nunsigned long off_eighths;\r\non_eighths = (*delay_on + 124) / 125;\r\nif (0 == on_eighths)\r\non_eighths = 1;\r\nif (on_eighths > 255)\r\non_eighths = 255;\r\n*delay_on = on_eighths * 125;\r\noff_eighths = (*delay_off + 124) / 125;\r\nif (0 == off_eighths)\r\noff_eighths = 1;\r\nif (off_eighths > 255)\r\noff_eighths = 255;\r\n*delay_off = off_eighths * 125;\r\nled_blink(on_eighths, off_eighths);\r\nreturn 0;\r\n}\r\nstatic int __init dell_led_init(void)\r\n{\r\nint error = 0;\r\nif (!wmi_has_guid(DELL_LED_BIOS_GUID) && !wmi_has_guid(DELL_APP_GUID))\r\nreturn -ENODEV;\r\nif (wmi_has_guid(DELL_APP_GUID))\r\nerror = dell_micmute_led_init();\r\nif (wmi_has_guid(DELL_LED_BIOS_GUID)) {\r\nerror = led_off();\r\nif (error != 0)\r\nreturn -ENODEV;\r\nerror = led_classdev_register(NULL, &dell_led);\r\n}\r\nreturn error;\r\n}\r\nstatic void __exit dell_led_exit(void)\r\n{\r\nint error = 0;\r\nif (wmi_has_guid(DELL_LED_BIOS_GUID)) {\r\nerror = led_off();\r\nif (error == 0)\r\nled_classdev_unregister(&dell_led);\r\n}\r\n}
