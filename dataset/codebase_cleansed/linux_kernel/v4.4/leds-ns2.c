static void ns2_led_work(struct work_struct *work)\r\n{\r\nstruct ns2_led_data *led_dat =\r\ncontainer_of(work, struct ns2_led_data, work);\r\nint i = led_dat->mode_index;\r\ngpio_set_value_cansleep(led_dat->cmd, led_dat->modval[i].cmd_level);\r\ngpio_set_value_cansleep(led_dat->slow, led_dat->modval[i].slow_level);\r\n}\r\nstatic int ns2_led_get_mode(struct ns2_led_data *led_dat,\r\nenum ns2_led_modes *mode)\r\n{\r\nint i;\r\nint ret = -EINVAL;\r\nint cmd_level;\r\nint slow_level;\r\ncmd_level = gpio_get_value_cansleep(led_dat->cmd);\r\nslow_level = gpio_get_value_cansleep(led_dat->slow);\r\nfor (i = 0; i < led_dat->num_modes; i++) {\r\nif (cmd_level == led_dat->modval[i].cmd_level &&\r\nslow_level == led_dat->modval[i].slow_level) {\r\n*mode = led_dat->modval[i].mode;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void ns2_led_set_mode(struct ns2_led_data *led_dat,\r\nenum ns2_led_modes mode)\r\n{\r\nint i;\r\nbool found = false;\r\nunsigned long flags;\r\nfor (i = 0; i < led_dat->num_modes; i++)\r\nif (mode == led_dat->modval[i].mode) {\r\nfound = true;\r\nbreak;\r\n}\r\nif (!found)\r\nreturn;\r\nwrite_lock_irqsave(&led_dat->rw_lock, flags);\r\nif (!led_dat->can_sleep) {\r\ngpio_set_value(led_dat->cmd,\r\nled_dat->modval[i].cmd_level);\r\ngpio_set_value(led_dat->slow,\r\nled_dat->modval[i].slow_level);\r\ngoto exit_unlock;\r\n}\r\nled_dat->mode_index = i;\r\nschedule_work(&led_dat->work);\r\nexit_unlock:\r\nwrite_unlock_irqrestore(&led_dat->rw_lock, flags);\r\n}\r\nstatic void ns2_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct ns2_led_data *led_dat =\r\ncontainer_of(led_cdev, struct ns2_led_data, cdev);\r\nenum ns2_led_modes mode;\r\nif (value == LED_OFF)\r\nmode = NS_V2_LED_OFF;\r\nelse if (led_dat->sata)\r\nmode = NS_V2_LED_SATA;\r\nelse\r\nmode = NS_V2_LED_ON;\r\nns2_led_set_mode(led_dat, mode);\r\n}\r\nstatic ssize_t ns2_led_sata_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buff, size_t count)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct ns2_led_data *led_dat =\r\ncontainer_of(led_cdev, struct ns2_led_data, cdev);\r\nint ret;\r\nunsigned long enable;\r\nret = kstrtoul(buff, 10, &enable);\r\nif (ret < 0)\r\nreturn ret;\r\nenable = !!enable;\r\nif (led_dat->sata == enable)\r\ngoto exit;\r\nled_dat->sata = enable;\r\nif (!led_get_brightness(led_cdev))\r\ngoto exit;\r\nif (enable)\r\nns2_led_set_mode(led_dat, NS_V2_LED_SATA);\r\nelse\r\nns2_led_set_mode(led_dat, NS_V2_LED_ON);\r\nexit:\r\nreturn count;\r\n}\r\nstatic ssize_t ns2_led_sata_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct ns2_led_data *led_dat =\r\ncontainer_of(led_cdev, struct ns2_led_data, cdev);\r\nreturn sprintf(buf, "%d\n", led_dat->sata);\r\n}\r\nstatic int\r\ncreate_ns2_led(struct platform_device *pdev, struct ns2_led_data *led_dat,\r\nconst struct ns2_led *template)\r\n{\r\nint ret;\r\nenum ns2_led_modes mode;\r\nret = devm_gpio_request_one(&pdev->dev, template->cmd,\r\ngpio_get_value_cansleep(template->cmd) ?\r\nGPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW,\r\ntemplate->name);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s: failed to setup command GPIO\n",\r\ntemplate->name);\r\nreturn ret;\r\n}\r\nret = devm_gpio_request_one(&pdev->dev, template->slow,\r\ngpio_get_value_cansleep(template->slow) ?\r\nGPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW,\r\ntemplate->name);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s: failed to setup slow GPIO\n",\r\ntemplate->name);\r\nreturn ret;\r\n}\r\nrwlock_init(&led_dat->rw_lock);\r\nled_dat->cdev.name = template->name;\r\nled_dat->cdev.default_trigger = template->default_trigger;\r\nled_dat->cdev.blink_set = NULL;\r\nled_dat->cdev.brightness_set = ns2_led_set;\r\nled_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;\r\nled_dat->cdev.groups = ns2_led_groups;\r\nled_dat->cmd = template->cmd;\r\nled_dat->slow = template->slow;\r\nled_dat->can_sleep = gpio_cansleep(led_dat->cmd) |\r\ngpio_cansleep(led_dat->slow);\r\nled_dat->modval = template->modval;\r\nled_dat->num_modes = template->num_modes;\r\nret = ns2_led_get_mode(led_dat, &mode);\r\nif (ret < 0)\r\nreturn ret;\r\nled_dat->sata = (mode == NS_V2_LED_SATA) ? 1 : 0;\r\nled_dat->cdev.brightness =\r\n(mode == NS_V2_LED_OFF) ? LED_OFF : LED_FULL;\r\nINIT_WORK(&led_dat->work, ns2_led_work);\r\nret = led_classdev_register(&pdev->dev, &led_dat->cdev);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void delete_ns2_led(struct ns2_led_data *led_dat)\r\n{\r\nled_classdev_unregister(&led_dat->cdev);\r\ncancel_work_sync(&led_dat->work);\r\n}\r\nstatic int\r\nns2_leds_get_of_pdata(struct device *dev, struct ns2_led_platform_data *pdata)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *child;\r\nstruct ns2_led *led, *leds;\r\nint num_leds = 0;\r\nnum_leds = of_get_child_count(np);\r\nif (!num_leds)\r\nreturn -ENODEV;\r\nleds = devm_kzalloc(dev, num_leds * sizeof(struct ns2_led),\r\nGFP_KERNEL);\r\nif (!leds)\r\nreturn -ENOMEM;\r\nled = leds;\r\nfor_each_child_of_node(np, child) {\r\nconst char *string;\r\nint ret, i, num_modes;\r\nstruct ns2_led_modval *modval;\r\nret = of_get_named_gpio(child, "cmd-gpio", 0);\r\nif (ret < 0)\r\nreturn ret;\r\nled->cmd = ret;\r\nret = of_get_named_gpio(child, "slow-gpio", 0);\r\nif (ret < 0)\r\nreturn ret;\r\nled->slow = ret;\r\nret = of_property_read_string(child, "label", &string);\r\nled->name = (ret == 0) ? string : child->name;\r\nret = of_property_read_string(child, "linux,default-trigger",\r\n&string);\r\nif (ret == 0)\r\nled->default_trigger = string;\r\nret = of_property_count_u32_elems(child, "modes-map");\r\nif (ret < 0 || ret % 3) {\r\ndev_err(dev,\r\n"Missing or malformed modes-map property\n");\r\nreturn -EINVAL;\r\n}\r\nnum_modes = ret / 3;\r\nmodval = devm_kzalloc(dev,\r\nnum_modes * sizeof(struct ns2_led_modval),\r\nGFP_KERNEL);\r\nif (!modval)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_modes; i++) {\r\nof_property_read_u32_index(child,\r\n"modes-map", 3 * i,\r\n(u32 *) &modval[i].mode);\r\nof_property_read_u32_index(child,\r\n"modes-map", 3 * i + 1,\r\n(u32 *) &modval[i].cmd_level);\r\nof_property_read_u32_index(child,\r\n"modes-map", 3 * i + 2,\r\n(u32 *) &modval[i].slow_level);\r\n}\r\nled->num_modes = num_modes;\r\nled->modval = modval;\r\nled++;\r\n}\r\npdata->leds = leds;\r\npdata->num_leds = num_leds;\r\nreturn 0;\r\n}\r\nstatic inline int sizeof_ns2_led_priv(int num_leds)\r\n{\r\nreturn sizeof(struct ns2_led_priv) +\r\n(sizeof(struct ns2_led_data) * num_leds);\r\n}\r\nstatic int ns2_led_probe(struct platform_device *pdev)\r\n{\r\nstruct ns2_led_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct ns2_led_priv *priv;\r\nint i;\r\nint ret;\r\n#ifdef CONFIG_OF_GPIO\r\nif (!pdata) {\r\npdata = devm_kzalloc(&pdev->dev,\r\nsizeof(struct ns2_led_platform_data),\r\nGFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nret = ns2_leds_get_of_pdata(&pdev->dev, pdata);\r\nif (ret)\r\nreturn ret;\r\n}\r\n#else\r\nif (!pdata)\r\nreturn -EINVAL;\r\n#endif\r\npriv = devm_kzalloc(&pdev->dev,\r\nsizeof_ns2_led_priv(pdata->num_leds), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->num_leds = pdata->num_leds;\r\nfor (i = 0; i < priv->num_leds; i++) {\r\nret = create_ns2_led(pdev, &priv->leds_data[i],\r\n&pdata->leds[i]);\r\nif (ret < 0) {\r\nfor (i = i - 1; i >= 0; i--)\r\ndelete_ns2_led(&priv->leds_data[i]);\r\nreturn ret;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nreturn 0;\r\n}\r\nstatic int ns2_led_remove(struct platform_device *pdev)\r\n{\r\nint i;\r\nstruct ns2_led_priv *priv;\r\npriv = platform_get_drvdata(pdev);\r\nfor (i = 0; i < priv->num_leds; i++)\r\ndelete_ns2_led(&priv->leds_data[i]);\r\nreturn 0;\r\n}
