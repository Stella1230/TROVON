static struct ip_vs_dest *\r\nip_vs_lc_schedule(struct ip_vs_service *svc, const struct sk_buff *skb,\r\nstruct ip_vs_iphdr *iph)\r\n{\r\nstruct ip_vs_dest *dest, *least = NULL;\r\nunsigned int loh = 0, doh;\r\nIP_VS_DBG(6, "%s(): Scheduling...\n", __func__);\r\nlist_for_each_entry_rcu(dest, &svc->destinations, n_list) {\r\nif ((dest->flags & IP_VS_DEST_F_OVERLOAD) ||\r\natomic_read(&dest->weight) == 0)\r\ncontinue;\r\ndoh = ip_vs_dest_conn_overhead(dest);\r\nif (!least || doh < loh) {\r\nleast = dest;\r\nloh = doh;\r\n}\r\n}\r\nif (!least)\r\nip_vs_scheduler_err(svc, "no destination available");\r\nelse\r\nIP_VS_DBG_BUF(6, "LC: server %s:%u activeconns %d "\r\n"inactconns %d\n",\r\nIP_VS_DBG_ADDR(least->af, &least->addr),\r\nntohs(least->port),\r\natomic_read(&least->activeconns),\r\natomic_read(&least->inactconns));\r\nreturn least;\r\n}\r\nstatic int __init ip_vs_lc_init(void)\r\n{\r\nreturn register_ip_vs_scheduler(&ip_vs_lc_scheduler) ;\r\n}\r\nstatic void __exit ip_vs_lc_cleanup(void)\r\n{\r\nunregister_ip_vs_scheduler(&ip_vs_lc_scheduler);\r\nsynchronize_rcu();\r\n}
