static void sms_board_dvb3_event(struct smsdvb_client_t *client,\r\nenum SMS_DVB3_EVENTS event) {\r\nstruct smscore_device_t *coredev = client->coredev;\r\nswitch (event) {\r\ncase DVB3_EVENT_INIT:\r\npr_debug("DVB3_EVENT_INIT\n");\r\nsms_board_event(coredev, BOARD_EVENT_BIND);\r\nbreak;\r\ncase DVB3_EVENT_SLEEP:\r\npr_debug("DVB3_EVENT_SLEEP\n");\r\nsms_board_event(coredev, BOARD_EVENT_POWER_SUSPEND);\r\nbreak;\r\ncase DVB3_EVENT_HOTPLUG:\r\npr_debug("DVB3_EVENT_HOTPLUG\n");\r\nsms_board_event(coredev, BOARD_EVENT_POWER_INIT);\r\nbreak;\r\ncase DVB3_EVENT_FE_LOCK:\r\nif (client->event_fe_state != DVB3_EVENT_FE_LOCK) {\r\nclient->event_fe_state = DVB3_EVENT_FE_LOCK;\r\npr_debug("DVB3_EVENT_FE_LOCK\n");\r\nsms_board_event(coredev, BOARD_EVENT_FE_LOCK);\r\n}\r\nbreak;\r\ncase DVB3_EVENT_FE_UNLOCK:\r\nif (client->event_fe_state != DVB3_EVENT_FE_UNLOCK) {\r\nclient->event_fe_state = DVB3_EVENT_FE_UNLOCK;\r\npr_debug("DVB3_EVENT_FE_UNLOCK\n");\r\nsms_board_event(coredev, BOARD_EVENT_FE_UNLOCK);\r\n}\r\nbreak;\r\ncase DVB3_EVENT_UNC_OK:\r\nif (client->event_unc_state != DVB3_EVENT_UNC_OK) {\r\nclient->event_unc_state = DVB3_EVENT_UNC_OK;\r\npr_debug("DVB3_EVENT_UNC_OK\n");\r\nsms_board_event(coredev, BOARD_EVENT_MULTIPLEX_OK);\r\n}\r\nbreak;\r\ncase DVB3_EVENT_UNC_ERR:\r\nif (client->event_unc_state != DVB3_EVENT_UNC_ERR) {\r\nclient->event_unc_state = DVB3_EVENT_UNC_ERR;\r\npr_debug("DVB3_EVENT_UNC_ERR\n");\r\nsms_board_event(coredev, BOARD_EVENT_MULTIPLEX_ERRORS);\r\n}\r\nbreak;\r\ndefault:\r\npr_err("Unknown dvb3 api event\n");\r\nbreak;\r\n}\r\n}\r\nstatic void smsdvb_stats_not_ready(struct dvb_frontend *fe)\r\n{\r\nstruct smsdvb_client_t *client =\r\ncontainer_of(fe, struct smsdvb_client_t, frontend);\r\nstruct smscore_device_t *coredev = client->coredev;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint i, n_layers;\r\nswitch (smscore_get_device_mode(coredev)) {\r\ncase DEVICE_MODE_ISDBT:\r\ncase DEVICE_MODE_ISDBT_BDA:\r\nn_layers = 4;\r\nbreak;\r\ndefault:\r\nn_layers = 1;\r\n}\r\nc->strength.len = 1;\r\nc->cnr.len = 1;\r\nc->strength.stat[0].scale = FE_SCALE_DECIBEL;\r\nc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\r\nc->post_bit_error.len = n_layers;\r\nc->post_bit_count.len = n_layers;\r\nc->block_error.len = n_layers;\r\nc->block_count.len = n_layers;\r\nfor (i = 0; i < n_layers; i++) {\r\nc->post_bit_error.stat[i].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_count.stat[i].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_error.stat[i].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_count.stat[i].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\n}\r\nstatic inline int sms_to_mode(u32 mode)\r\n{\r\nswitch (mode) {\r\ncase 2:\r\nreturn TRANSMISSION_MODE_2K;\r\ncase 4:\r\nreturn TRANSMISSION_MODE_4K;\r\ncase 8:\r\nreturn TRANSMISSION_MODE_8K;\r\n}\r\nreturn TRANSMISSION_MODE_AUTO;\r\n}\r\nstatic inline int sms_to_status(u32 is_demod_locked, u32 is_rf_locked)\r\n{\r\nif (is_demod_locked)\r\nreturn FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI |\r\nFE_HAS_SYNC | FE_HAS_LOCK;\r\nif (is_rf_locked)\r\nreturn FE_HAS_SIGNAL | FE_HAS_CARRIER;\r\nreturn 0;\r\n}\r\nstatic inline u32 sms_to_bw(u32 value)\r\n{\r\nreturn value * 1000000;\r\n}\r\nstatic void smsdvb_update_tx_params(struct smsdvb_client_t *client,\r\nstruct sms_tx_stats *p)\r\n{\r\nstruct dvb_frontend *fe = &client->frontend;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nc->frequency = p->frequency;\r\nclient->fe_status = sms_to_status(p->is_demod_locked, 0);\r\nc->bandwidth_hz = sms_to_bw(p->bandwidth);\r\nc->transmission_mode = sms_to_mode(p->transmission_mode);\r\nc->guard_interval = sms_to_guard_interval(p->guard_interval);\r\nc->code_rate_HP = sms_to_code_rate(p->code_rate);\r\nc->code_rate_LP = sms_to_code_rate(p->lp_code_rate);\r\nc->hierarchy = sms_to_hierarchy(p->hierarchy);\r\nc->modulation = sms_to_modulation(p->constellation);\r\n}\r\nstatic void smsdvb_update_per_slices(struct smsdvb_client_t *client,\r\nstruct RECEPTION_STATISTICS_PER_SLICES_S *p)\r\n{\r\nstruct dvb_frontend *fe = &client->frontend;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu64 tmp;\r\nclient->fe_status = sms_to_status(p->is_demod_locked, p->is_rf_locked);\r\nc->modulation = sms_to_modulation(p->constellation);\r\nc->strength.stat[0].uvalue = p->in_band_power * 1000;\r\nc->cnr.stat[0].svalue = p->snr * 1000;\r\nif (!p->is_demod_locked)\r\nreturn;\r\nclient->last_per = c->block_error.stat[0].uvalue;\r\nc->block_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->block_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->block_error.stat[0].uvalue += p->ets_packets;\r\nc->block_count.stat[0].uvalue += p->ets_packets + p->ts_packets;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[0].uvalue += p->ber_error_count;\r\nc->post_bit_count.stat[0].uvalue += p->ber_bit_count;\r\ntmp = p->ets_packets * 65535;\r\nif (p->ts_packets + p->ets_packets)\r\ndo_div(tmp, p->ts_packets + p->ets_packets);\r\nclient->legacy_per = tmp;\r\n}\r\nstatic void smsdvb_update_dvb_stats(struct smsdvb_client_t *client,\r\nstruct sms_stats *p)\r\n{\r\nstruct dvb_frontend *fe = &client->frontend;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nif (client->prt_dvb_stats)\r\nclient->prt_dvb_stats(client->debug_data, p);\r\nclient->fe_status = sms_to_status(p->is_demod_locked, p->is_rf_locked);\r\nc->frequency = p->frequency;\r\nclient->fe_status = sms_to_status(p->is_demod_locked, 0);\r\nc->bandwidth_hz = sms_to_bw(p->bandwidth);\r\nc->transmission_mode = sms_to_mode(p->transmission_mode);\r\nc->guard_interval = sms_to_guard_interval(p->guard_interval);\r\nc->code_rate_HP = sms_to_code_rate(p->code_rate);\r\nc->code_rate_LP = sms_to_code_rate(p->lp_code_rate);\r\nc->hierarchy = sms_to_hierarchy(p->hierarchy);\r\nc->modulation = sms_to_modulation(p->constellation);\r\nc->lna = p->is_external_lna_on ? 1 : 0;\r\nc->cnr.stat[0].svalue = p->SNR * 1000;\r\nc->strength.stat[0].uvalue = p->in_band_pwr * 1000;\r\nif (!p->is_demod_locked)\r\nreturn;\r\nclient->last_per = c->block_error.stat[0].uvalue;\r\nc->block_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->block_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->block_error.stat[0].uvalue += p->error_ts_packets;\r\nc->block_count.stat[0].uvalue += p->total_ts_packets;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[0].uvalue += p->ber_error_count;\r\nc->post_bit_count.stat[0].uvalue += p->ber_bit_count;\r\nclient->legacy_ber = p->ber;\r\n}\r\nstatic void smsdvb_update_isdbt_stats(struct smsdvb_client_t *client,\r\nstruct sms_isdbt_stats *p)\r\n{\r\nstruct dvb_frontend *fe = &client->frontend;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct sms_isdbt_layer_stats *lr;\r\nint i, n_layers;\r\nif (client->prt_isdb_stats)\r\nclient->prt_isdb_stats(client->debug_data, p);\r\nclient->fe_status = sms_to_status(p->is_demod_locked, p->is_rf_locked);\r\nif (p->statistics_type == 0) {\r\nc->strength.stat[0].uvalue = ((s32)p->transmission_mode) * 1000;\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nreturn;\r\n}\r\nc->frequency = p->frequency;\r\nc->bandwidth_hz = sms_to_bw(p->bandwidth);\r\nc->transmission_mode = sms_to_mode(p->transmission_mode);\r\nc->guard_interval = sms_to_guard_interval(p->guard_interval);\r\nc->isdbt_partial_reception = p->partial_reception ? 1 : 0;\r\nn_layers = p->num_of_layers;\r\nif (n_layers < 1)\r\nn_layers = 1;\r\nif (n_layers > 3)\r\nn_layers = 3;\r\nc->isdbt_layer_enabled = 0;\r\nc->lna = p->is_external_lna_on ? 1 : 0;\r\nc->cnr.stat[0].svalue = p->SNR * 1000;\r\nc->strength.stat[0].uvalue = p->in_band_pwr * 1000;\r\nif (!p->is_demod_locked)\r\nreturn;\r\nclient->last_per = c->block_error.stat[0].uvalue;\r\nc->block_error.stat[0].uvalue = 0;\r\nc->block_count.stat[0].uvalue = 0;\r\nc->block_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->block_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[0].uvalue = 0;\r\nc->post_bit_count.stat[0].uvalue = 0;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\r\nfor (i = 0; i < n_layers; i++) {\r\nlr = &p->layer_info[i];\r\nif (lr->number_of_segments > 0 && lr->number_of_segments < 13) {\r\nc->isdbt_layer_enabled |= 1 << i;\r\nc->layer[i].segment_count = lr->number_of_segments;\r\n} else {\r\ncontinue;\r\n}\r\nc->layer[i].modulation = sms_to_modulation(lr->constellation);\r\nc->block_error.stat[i + 1].scale = FE_SCALE_COUNTER;\r\nc->block_count.stat[i + 1].scale = FE_SCALE_COUNTER;\r\nc->block_error.stat[i + 1].uvalue += lr->error_ts_packets;\r\nc->block_count.stat[i + 1].uvalue += lr->total_ts_packets;\r\nc->block_error.stat[0].uvalue += lr->error_ts_packets;\r\nc->block_count.stat[0].uvalue += lr->total_ts_packets;\r\nc->post_bit_error.stat[i + 1].scale = FE_SCALE_COUNTER;\r\nc->post_bit_count.stat[i + 1].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[i + 1].uvalue += lr->ber_error_count;\r\nc->post_bit_count.stat[i + 1].uvalue += lr->ber_bit_count;\r\nc->post_bit_error.stat[0].uvalue += lr->ber_error_count;\r\nc->post_bit_count.stat[0].uvalue += lr->ber_bit_count;\r\n}\r\n}\r\nstatic void smsdvb_update_isdbt_stats_ex(struct smsdvb_client_t *client,\r\nstruct sms_isdbt_stats_ex *p)\r\n{\r\nstruct dvb_frontend *fe = &client->frontend;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct sms_isdbt_layer_stats *lr;\r\nint i, n_layers;\r\nif (client->prt_isdb_stats_ex)\r\nclient->prt_isdb_stats_ex(client->debug_data, p);\r\nc->frequency = p->frequency;\r\nclient->fe_status = sms_to_status(p->is_demod_locked, 0);\r\nc->bandwidth_hz = sms_to_bw(p->bandwidth);\r\nc->transmission_mode = sms_to_mode(p->transmission_mode);\r\nc->guard_interval = sms_to_guard_interval(p->guard_interval);\r\nc->isdbt_partial_reception = p->partial_reception ? 1 : 0;\r\nn_layers = p->num_of_layers;\r\nif (n_layers < 1)\r\nn_layers = 1;\r\nif (n_layers > 3)\r\nn_layers = 3;\r\nc->isdbt_layer_enabled = 0;\r\nc->lna = p->is_external_lna_on ? 1 : 0;\r\nc->cnr.stat[0].svalue = p->SNR * 1000;\r\nc->strength.stat[0].uvalue = p->in_band_pwr * 1000;\r\nif (!p->is_demod_locked)\r\nreturn;\r\nclient->last_per = c->block_error.stat[0].uvalue;\r\nc->block_error.stat[0].uvalue = 0;\r\nc->block_count.stat[0].uvalue = 0;\r\nc->block_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->block_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[0].uvalue = 0;\r\nc->post_bit_count.stat[0].uvalue = 0;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.len = n_layers + 1;\r\nc->post_bit_count.len = n_layers + 1;\r\nc->block_error.len = n_layers + 1;\r\nc->block_count.len = n_layers + 1;\r\nfor (i = 0; i < n_layers; i++) {\r\nlr = &p->layer_info[i];\r\nif (lr->number_of_segments > 0 && lr->number_of_segments < 13) {\r\nc->isdbt_layer_enabled |= 1 << i;\r\nc->layer[i].segment_count = lr->number_of_segments;\r\n} else {\r\ncontinue;\r\n}\r\nc->layer[i].modulation = sms_to_modulation(lr->constellation);\r\nc->block_error.stat[i + 1].scale = FE_SCALE_COUNTER;\r\nc->block_count.stat[i + 1].scale = FE_SCALE_COUNTER;\r\nc->block_error.stat[i + 1].uvalue += lr->error_ts_packets;\r\nc->block_count.stat[i + 1].uvalue += lr->total_ts_packets;\r\nc->block_error.stat[0].uvalue += lr->error_ts_packets;\r\nc->block_count.stat[0].uvalue += lr->total_ts_packets;\r\nc->post_bit_error.stat[i + 1].scale = FE_SCALE_COUNTER;\r\nc->post_bit_count.stat[i + 1].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[i + 1].uvalue += lr->ber_error_count;\r\nc->post_bit_count.stat[i + 1].uvalue += lr->ber_bit_count;\r\nc->post_bit_error.stat[0].uvalue += lr->ber_error_count;\r\nc->post_bit_count.stat[0].uvalue += lr->ber_bit_count;\r\n}\r\n}\r\nstatic int smsdvb_onresponse(void *context, struct smscore_buffer_t *cb)\r\n{\r\nstruct smsdvb_client_t *client = (struct smsdvb_client_t *) context;\r\nstruct sms_msg_hdr *phdr = (struct sms_msg_hdr *) (((u8 *) cb->p)\r\n+ cb->offset);\r\nvoid *p = phdr + 1;\r\nstruct dvb_frontend *fe = &client->frontend;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nbool is_status_update = false;\r\nswitch (phdr->msg_type) {\r\ncase MSG_SMS_DVBT_BDA_DATA:\r\nif (client->feed_users && client->has_tuned)\r\ndvb_dmx_swfilter(&client->demux, p,\r\ncb->size - sizeof(struct sms_msg_hdr));\r\nbreak;\r\ncase MSG_SMS_RF_TUNE_RES:\r\ncase MSG_SMS_ISDBT_TUNE_RES:\r\ncomplete(&client->tune_done);\r\nbreak;\r\ncase MSG_SMS_SIGNAL_DETECTED_IND:\r\nclient->fe_status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC |\r\nFE_HAS_LOCK;\r\nis_status_update = true;\r\nbreak;\r\ncase MSG_SMS_NO_SIGNAL_IND:\r\nclient->fe_status = 0;\r\nis_status_update = true;\r\nbreak;\r\ncase MSG_SMS_TRANSMISSION_IND:\r\nsmsdvb_update_tx_params(client, p);\r\nis_status_update = true;\r\nbreak;\r\ncase MSG_SMS_HO_PER_SLICES_IND:\r\nsmsdvb_update_per_slices(client, p);\r\nis_status_update = true;\r\nbreak;\r\ncase MSG_SMS_GET_STATISTICS_RES:\r\nswitch (smscore_get_device_mode(client->coredev)) {\r\ncase DEVICE_MODE_ISDBT:\r\ncase DEVICE_MODE_ISDBT_BDA:\r\nsmsdvb_update_isdbt_stats(client, p);\r\nbreak;\r\ndefault:\r\nsmsdvb_update_dvb_stats(client, p + sizeof(u32));\r\n}\r\nis_status_update = true;\r\nbreak;\r\ncase MSG_SMS_GET_STATISTICS_EX_RES:\r\nsmsdvb_update_isdbt_stats_ex(client, p + sizeof(u32));\r\nis_status_update = true;\r\nbreak;\r\ndefault:\r\npr_debug("message not handled\n");\r\n}\r\nsmscore_putbuffer(client->coredev, cb);\r\nif (is_status_update) {\r\nif (client->fe_status & FE_HAS_LOCK) {\r\nsms_board_dvb3_event(client, DVB3_EVENT_FE_LOCK);\r\nif (client->last_per == c->block_error.stat[0].uvalue)\r\nsms_board_dvb3_event(client, DVB3_EVENT_UNC_OK);\r\nelse\r\nsms_board_dvb3_event(client, DVB3_EVENT_UNC_ERR);\r\nclient->has_tuned = true;\r\n} else {\r\nsmsdvb_stats_not_ready(fe);\r\nclient->has_tuned = false;\r\nsms_board_dvb3_event(client, DVB3_EVENT_FE_UNLOCK);\r\n}\r\ncomplete(&client->stats_done);\r\n}\r\nreturn 0;\r\n}\r\nstatic void smsdvb_media_device_unregister(struct smsdvb_client_t *client)\r\n{\r\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\r\nstruct smscore_device_t *coredev = client->coredev;\r\nif (!coredev->media_dev)\r\nreturn;\r\nmedia_device_unregister(coredev->media_dev);\r\nkfree(coredev->media_dev);\r\ncoredev->media_dev = NULL;\r\n#endif\r\n}\r\nstatic void smsdvb_unregister_client(struct smsdvb_client_t *client)\r\n{\r\nlist_del(&client->entry);\r\nsmsdvb_debugfs_release(client);\r\nsmscore_unregister_client(client->smsclient);\r\ndvb_unregister_frontend(&client->frontend);\r\ndvb_dmxdev_release(&client->dmxdev);\r\ndvb_dmx_release(&client->demux);\r\nsmsdvb_media_device_unregister(client);\r\ndvb_unregister_adapter(&client->adapter);\r\nkfree(client);\r\n}\r\nstatic void smsdvb_onremove(void *context)\r\n{\r\nkmutex_lock(&g_smsdvb_clientslock);\r\nsmsdvb_unregister_client((struct smsdvb_client_t *) context);\r\nkmutex_unlock(&g_smsdvb_clientslock);\r\n}\r\nstatic int smsdvb_start_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct smsdvb_client_t *client =\r\ncontainer_of(feed->demux, struct smsdvb_client_t, demux);\r\nstruct sms_msg_data pid_msg;\r\npr_debug("add pid %d(%x)\n",\r\nfeed->pid, feed->pid);\r\nclient->feed_users++;\r\npid_msg.x_msg_header.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;\r\npid_msg.x_msg_header.msg_dst_id = HIF_TASK;\r\npid_msg.x_msg_header.msg_flags = 0;\r\npid_msg.x_msg_header.msg_type = MSG_SMS_ADD_PID_FILTER_REQ;\r\npid_msg.x_msg_header.msg_length = sizeof(pid_msg);\r\npid_msg.msg_data[0] = feed->pid;\r\nreturn smsclient_sendrequest(client->smsclient,\r\n&pid_msg, sizeof(pid_msg));\r\n}\r\nstatic int smsdvb_stop_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct smsdvb_client_t *client =\r\ncontainer_of(feed->demux, struct smsdvb_client_t, demux);\r\nstruct sms_msg_data pid_msg;\r\npr_debug("remove pid %d(%x)\n",\r\nfeed->pid, feed->pid);\r\nclient->feed_users--;\r\npid_msg.x_msg_header.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;\r\npid_msg.x_msg_header.msg_dst_id = HIF_TASK;\r\npid_msg.x_msg_header.msg_flags = 0;\r\npid_msg.x_msg_header.msg_type = MSG_SMS_REMOVE_PID_FILTER_REQ;\r\npid_msg.x_msg_header.msg_length = sizeof(pid_msg);\r\npid_msg.msg_data[0] = feed->pid;\r\nreturn smsclient_sendrequest(client->smsclient,\r\n&pid_msg, sizeof(pid_msg));\r\n}\r\nstatic int smsdvb_sendrequest_and_wait(struct smsdvb_client_t *client,\r\nvoid *buffer, size_t size,\r\nstruct completion *completion)\r\n{\r\nint rc;\r\nrc = smsclient_sendrequest(client->smsclient, buffer, size);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn wait_for_completion_timeout(completion,\r\nmsecs_to_jiffies(2000)) ?\r\n0 : -ETIME;\r\n}\r\nstatic int smsdvb_send_statistics_request(struct smsdvb_client_t *client)\r\n{\r\nint rc;\r\nstruct sms_msg_hdr msg;\r\nif (client->get_stats_jiffies &&\r\n(!time_after(jiffies, client->get_stats_jiffies)))\r\nreturn 0;\r\nclient->get_stats_jiffies = jiffies + msecs_to_jiffies(100);\r\nmsg.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;\r\nmsg.msg_dst_id = HIF_TASK;\r\nmsg.msg_flags = 0;\r\nmsg.msg_length = sizeof(msg);\r\nswitch (smscore_get_device_mode(client->coredev)) {\r\ncase DEVICE_MODE_ISDBT:\r\ncase DEVICE_MODE_ISDBT_BDA:\r\nif (client->coredev->fw_version >= 0x800)\r\nmsg.msg_type = MSG_SMS_GET_STATISTICS_EX_REQ;\r\nelse\r\nmsg.msg_type = MSG_SMS_GET_STATISTICS_REQ;\r\nbreak;\r\ndefault:\r\nmsg.msg_type = MSG_SMS_GET_STATISTICS_REQ;\r\n}\r\nrc = smsdvb_sendrequest_and_wait(client, &msg, sizeof(msg),\r\n&client->stats_done);\r\nreturn rc;\r\n}\r\nstatic inline int led_feedback(struct smsdvb_client_t *client)\r\n{\r\nif (!(client->fe_status & FE_HAS_LOCK))\r\nreturn sms_board_led_feedback(client->coredev, SMS_LED_OFF);\r\nreturn sms_board_led_feedback(client->coredev,\r\n(client->legacy_ber == 0) ?\r\nSMS_LED_HI : SMS_LED_LO);\r\n}\r\nstatic int smsdvb_read_status(struct dvb_frontend *fe, enum fe_status *stat)\r\n{\r\nint rc;\r\nstruct smsdvb_client_t *client;\r\nclient = container_of(fe, struct smsdvb_client_t, frontend);\r\nrc = smsdvb_send_statistics_request(client);\r\n*stat = client->fe_status;\r\nled_feedback(client);\r\nreturn rc;\r\n}\r\nstatic int smsdvb_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nint rc;\r\nstruct smsdvb_client_t *client;\r\nclient = container_of(fe, struct smsdvb_client_t, frontend);\r\nrc = smsdvb_send_statistics_request(client);\r\n*ber = client->legacy_ber;\r\nled_feedback(client);\r\nreturn rc;\r\n}\r\nstatic int smsdvb_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint rc;\r\ns32 power = (s32) c->strength.stat[0].uvalue;\r\nstruct smsdvb_client_t *client;\r\nclient = container_of(fe, struct smsdvb_client_t, frontend);\r\nrc = smsdvb_send_statistics_request(client);\r\nif (power < -95)\r\n*strength = 0;\r\nelse if (power > -29)\r\n*strength = 65535;\r\nelse\r\n*strength = (power + 95) * 65535 / 66;\r\nled_feedback(client);\r\nreturn rc;\r\n}\r\nstatic int smsdvb_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint rc;\r\nstruct smsdvb_client_t *client;\r\nclient = container_of(fe, struct smsdvb_client_t, frontend);\r\nrc = smsdvb_send_statistics_request(client);\r\n*snr = ((u32)c->cnr.stat[0].svalue) / 100;\r\nled_feedback(client);\r\nreturn rc;\r\n}\r\nstatic int smsdvb_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nint rc;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct smsdvb_client_t *client;\r\nclient = container_of(fe, struct smsdvb_client_t, frontend);\r\nrc = smsdvb_send_statistics_request(client);\r\n*ucblocks = c->block_error.stat[0].uvalue;\r\nled_feedback(client);\r\nreturn rc;\r\n}\r\nstatic int smsdvb_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *tune)\r\n{\r\npr_debug("\n");\r\ntune->min_delay_ms = 400;\r\ntune->step_size = 250000;\r\ntune->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic int smsdvb_dvbt_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct smsdvb_client_t *client =\r\ncontainer_of(fe, struct smsdvb_client_t, frontend);\r\nstruct {\r\nstruct sms_msg_hdr msg;\r\nu32 Data[3];\r\n} msg;\r\nint ret;\r\nclient->fe_status = 0;\r\nclient->event_fe_state = -1;\r\nclient->event_unc_state = -1;\r\nfe->dtv_property_cache.delivery_system = SYS_DVBT;\r\nmsg.msg.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;\r\nmsg.msg.msg_dst_id = HIF_TASK;\r\nmsg.msg.msg_flags = 0;\r\nmsg.msg.msg_type = MSG_SMS_RF_TUNE_REQ;\r\nmsg.msg.msg_length = sizeof(msg);\r\nmsg.Data[0] = c->frequency;\r\nmsg.Data[2] = 12000000;\r\npr_debug("%s: freq %d band %d\n", __func__, c->frequency,\r\nc->bandwidth_hz);\r\nswitch (c->bandwidth_hz / 1000000) {\r\ncase 8:\r\nmsg.Data[1] = BW_8_MHZ;\r\nbreak;\r\ncase 7:\r\nmsg.Data[1] = BW_7_MHZ;\r\nbreak;\r\ncase 6:\r\nmsg.Data[1] = BW_6_MHZ;\r\nbreak;\r\ncase 0:\r\nreturn -EOPNOTSUPP;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = sms_board_lna_control(client->coredev, 0);\r\nif (ret == 0) {\r\nenum fe_status status;\r\nret = smsdvb_sendrequest_and_wait(client, &msg, sizeof(msg),\r\n&client->tune_done);\r\nsmsdvb_read_status(fe, &status);\r\nif (status & FE_HAS_LOCK)\r\nreturn ret;\r\nsms_board_lna_control(client->coredev, 1);\r\n}\r\nreturn smsdvb_sendrequest_and_wait(client, &msg, sizeof(msg),\r\n&client->tune_done);\r\n}\r\nstatic int smsdvb_isdbt_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct smsdvb_client_t *client =\r\ncontainer_of(fe, struct smsdvb_client_t, frontend);\r\nint board_id = smscore_get_board_id(client->coredev);\r\nstruct sms_board *board = sms_get_board(board_id);\r\nenum sms_device_type_st type = board->type;\r\nint ret;\r\nstruct {\r\nstruct sms_msg_hdr msg;\r\nu32 Data[4];\r\n} msg;\r\nfe->dtv_property_cache.delivery_system = SYS_ISDBT;\r\nmsg.msg.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;\r\nmsg.msg.msg_dst_id = HIF_TASK;\r\nmsg.msg.msg_flags = 0;\r\nmsg.msg.msg_type = MSG_SMS_ISDBT_TUNE_REQ;\r\nmsg.msg.msg_length = sizeof(msg);\r\nif (c->isdbt_sb_segment_idx == -1)\r\nc->isdbt_sb_segment_idx = 0;\r\nif (!c->isdbt_layer_enabled)\r\nc->isdbt_layer_enabled = 7;\r\nmsg.Data[0] = c->frequency;\r\nmsg.Data[1] = BW_ISDBT_1SEG;\r\nmsg.Data[2] = 12000000;\r\nmsg.Data[3] = c->isdbt_sb_segment_idx;\r\nif (c->isdbt_partial_reception) {\r\nif ((type == SMS_PELE || type == SMS_RIO) &&\r\nc->isdbt_sb_segment_count > 3)\r\nmsg.Data[1] = BW_ISDBT_13SEG;\r\nelse if (c->isdbt_sb_segment_count > 1)\r\nmsg.Data[1] = BW_ISDBT_3SEG;\r\n} else if (type == SMS_PELE || type == SMS_RIO)\r\nmsg.Data[1] = BW_ISDBT_13SEG;\r\nc->bandwidth_hz = 6000000;\r\npr_debug("freq %d segwidth %d segindex %d\n",\r\nc->frequency, c->isdbt_sb_segment_count,\r\nc->isdbt_sb_segment_idx);\r\nret = sms_board_lna_control(client->coredev, 0);\r\nif (ret == 0) {\r\nenum fe_status status;\r\nret = smsdvb_sendrequest_and_wait(client, &msg, sizeof(msg),\r\n&client->tune_done);\r\nsmsdvb_read_status(fe, &status);\r\nif (status & FE_HAS_LOCK)\r\nreturn ret;\r\nsms_board_lna_control(client->coredev, 1);\r\n}\r\nreturn smsdvb_sendrequest_and_wait(client, &msg, sizeof(msg),\r\n&client->tune_done);\r\n}\r\nstatic int smsdvb_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct smsdvb_client_t *client =\r\ncontainer_of(fe, struct smsdvb_client_t, frontend);\r\nstruct smscore_device_t *coredev = client->coredev;\r\nsmsdvb_stats_not_ready(fe);\r\nc->strength.stat[0].uvalue = 0;\r\nc->cnr.stat[0].uvalue = 0;\r\nclient->has_tuned = false;\r\nswitch (smscore_get_device_mode(coredev)) {\r\ncase DEVICE_MODE_DVBT:\r\ncase DEVICE_MODE_DVBT_BDA:\r\nreturn smsdvb_dvbt_set_frontend(fe);\r\ncase DEVICE_MODE_ISDBT:\r\ncase DEVICE_MODE_ISDBT_BDA:\r\nreturn smsdvb_isdbt_set_frontend(fe);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int smsdvb_get_frontend(struct dvb_frontend *fe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int smsdvb_init(struct dvb_frontend *fe)\r\n{\r\nstruct smsdvb_client_t *client =\r\ncontainer_of(fe, struct smsdvb_client_t, frontend);\r\nsms_board_power(client->coredev, 1);\r\nsms_board_dvb3_event(client, DVB3_EVENT_INIT);\r\nreturn 0;\r\n}\r\nstatic int smsdvb_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct smsdvb_client_t *client =\r\ncontainer_of(fe, struct smsdvb_client_t, frontend);\r\nsms_board_led_feedback(client->coredev, SMS_LED_OFF);\r\nsms_board_power(client->coredev, 0);\r\nsms_board_dvb3_event(client, DVB3_EVENT_SLEEP);\r\nreturn 0;\r\n}\r\nstatic void smsdvb_release(struct dvb_frontend *fe)\r\n{\r\n}\r\nstatic int smsdvb_hotplug(struct smscore_device_t *coredev,\r\nstruct device *device, int arrival)\r\n{\r\nstruct smsclient_params_t params;\r\nstruct smsdvb_client_t *client;\r\nint rc;\r\nif (!arrival)\r\nreturn 0;\r\nclient = kzalloc(sizeof(struct smsdvb_client_t), GFP_KERNEL);\r\nif (!client)\r\nreturn -ENOMEM;\r\nrc = dvb_register_adapter(&client->adapter,\r\nsms_get_board(\r\nsmscore_get_board_id(coredev))->name,\r\nTHIS_MODULE, device, adapter_nr);\r\nif (rc < 0) {\r\npr_err("dvb_register_adapter() failed %d\n", rc);\r\ngoto adapter_error;\r\n}\r\ndvb_register_media_controller(&client->adapter, coredev->media_dev);\r\nclient->demux.dmx.capabilities = DMX_TS_FILTERING;\r\nclient->demux.filternum = 32;\r\nclient->demux.feednum = 32;\r\nclient->demux.start_feed = smsdvb_start_feed;\r\nclient->demux.stop_feed = smsdvb_stop_feed;\r\nrc = dvb_dmx_init(&client->demux);\r\nif (rc < 0) {\r\npr_err("dvb_dmx_init failed %d\n", rc);\r\ngoto dvbdmx_error;\r\n}\r\nclient->dmxdev.filternum = 32;\r\nclient->dmxdev.demux = &client->demux.dmx;\r\nclient->dmxdev.capabilities = 0;\r\nrc = dvb_dmxdev_init(&client->dmxdev, &client->adapter);\r\nif (rc < 0) {\r\npr_err("dvb_dmxdev_init failed %d\n", rc);\r\ngoto dmxdev_error;\r\n}\r\nmemcpy(&client->frontend.ops, &smsdvb_fe_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nswitch (smscore_get_device_mode(coredev)) {\r\ncase DEVICE_MODE_DVBT:\r\ncase DEVICE_MODE_DVBT_BDA:\r\nclient->frontend.ops.delsys[0] = SYS_DVBT;\r\nbreak;\r\ncase DEVICE_MODE_ISDBT:\r\ncase DEVICE_MODE_ISDBT_BDA:\r\nclient->frontend.ops.delsys[0] = SYS_ISDBT;\r\nbreak;\r\n}\r\nrc = dvb_register_frontend(&client->adapter, &client->frontend);\r\nif (rc < 0) {\r\npr_err("frontend registration failed %d\n", rc);\r\ngoto frontend_error;\r\n}\r\nparams.initial_id = 1;\r\nparams.data_type = MSG_SMS_DVBT_BDA_DATA;\r\nparams.onresponse_handler = smsdvb_onresponse;\r\nparams.onremove_handler = smsdvb_onremove;\r\nparams.context = client;\r\nrc = smscore_register_client(coredev, &params, &client->smsclient);\r\nif (rc < 0) {\r\npr_err("smscore_register_client() failed %d\n", rc);\r\ngoto client_error;\r\n}\r\nclient->coredev = coredev;\r\ninit_completion(&client->tune_done);\r\ninit_completion(&client->stats_done);\r\nkmutex_lock(&g_smsdvb_clientslock);\r\nlist_add(&client->entry, &g_smsdvb_clients);\r\nkmutex_unlock(&g_smsdvb_clientslock);\r\nclient->event_fe_state = -1;\r\nclient->event_unc_state = -1;\r\nsms_board_dvb3_event(client, DVB3_EVENT_HOTPLUG);\r\nsms_board_setup(coredev);\r\nif (smsdvb_debugfs_create(client) < 0)\r\npr_info("failed to create debugfs node\n");\r\ndvb_create_media_graph(&client->adapter);\r\npr_info("DVB interface registered.\n");\r\nreturn 0;\r\nclient_error:\r\ndvb_unregister_frontend(&client->frontend);\r\nfrontend_error:\r\ndvb_dmxdev_release(&client->dmxdev);\r\ndmxdev_error:\r\ndvb_dmx_release(&client->demux);\r\ndvbdmx_error:\r\nsmsdvb_media_device_unregister(client);\r\ndvb_unregister_adapter(&client->adapter);\r\nadapter_error:\r\nkfree(client);\r\nreturn rc;\r\n}\r\nstatic int __init smsdvb_module_init(void)\r\n{\r\nint rc;\r\nINIT_LIST_HEAD(&g_smsdvb_clients);\r\nkmutex_init(&g_smsdvb_clientslock);\r\nsmsdvb_debugfs_register();\r\nrc = smscore_register_hotplug(smsdvb_hotplug);\r\npr_debug("\n");\r\nreturn rc;\r\n}\r\nstatic void __exit smsdvb_module_exit(void)\r\n{\r\nsmscore_unregister_hotplug(smsdvb_hotplug);\r\nkmutex_lock(&g_smsdvb_clientslock);\r\nwhile (!list_empty(&g_smsdvb_clients))\r\nsmsdvb_unregister_client((struct smsdvb_client_t *)g_smsdvb_clients.next);\r\nsmsdvb_debugfs_unregister();\r\nkmutex_unlock(&g_smsdvb_clientslock);\r\n}
