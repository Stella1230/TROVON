static struct ssp_msg *ssp_create_msg(u8 cmd, u16 len, u16 opt, u32 data)\r\n{\r\nstruct ssp_msg_header h;\r\nstruct ssp_msg *msg;\r\nmsg = kzalloc(sizeof(*msg), GFP_KERNEL);\r\nif (!msg)\r\nreturn NULL;\r\nh.cmd = cmd;\r\nh.length = cpu_to_le16(len);\r\nh.options = cpu_to_le16(opt);\r\nh.data = cpu_to_le32(data);\r\nmsg->buffer = kzalloc(SSP_HEADER_SIZE_ALIGNED + len,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!msg->buffer) {\r\nkfree(msg);\r\nreturn NULL;\r\n}\r\nmsg->length = len;\r\nmsg->options = opt;\r\nmemcpy(msg->buffer, &h, SSP_HEADER_SIZE);\r\nreturn msg;\r\n}\r\nstatic inline void ssp_fill_buffer(struct ssp_msg *m, unsigned int offset,\r\nconst void *src, unsigned int len)\r\n{\r\nmemcpy(&m->buffer[SSP_HEADER_SIZE_ALIGNED + offset], src, len);\r\n}\r\nstatic inline void ssp_get_buffer(struct ssp_msg *m, unsigned int offset,\r\nvoid *dest, unsigned int len)\r\n{\r\nmemcpy(dest, &m->buffer[SSP_HEADER_SIZE_ALIGNED + offset], len);\r\n}\r\nstatic void ssp_clean_msg(struct ssp_msg *m)\r\n{\r\nkfree(m->buffer);\r\nkfree(m);\r\n}\r\nstatic int ssp_print_mcu_debug(char *data_frame, int *data_index,\r\nint received_len)\r\n{\r\nint length = data_frame[(*data_index)++];\r\nif (length > received_len - *data_index || length <= 0) {\r\nssp_dbg("[SSP]: MSG From MCU-invalid debug length(%d/%d)\n",\r\nlength, received_len);\r\nreturn length ? length : -EPROTO;\r\n}\r\nssp_dbg("[SSP]: MSG From MCU - %s\n", &data_frame[*data_index]);\r\n*data_index += length;\r\nreturn 0;\r\n}\r\nstatic int ssp_check_lines(struct ssp_data *data, bool state)\r\n{\r\nint delay_cnt = 0;\r\ngpio_set_value_cansleep(data->ap_mcu_gpio, state);\r\nwhile (gpio_get_value_cansleep(data->mcu_ap_gpio) != state) {\r\nusleep_range(3000, 3500);\r\nif (data->shut_down || delay_cnt++ > 500) {\r\ndev_err(SSP_DEV, "%s:timeout, hw ack wait fail %d\n",\r\n__func__, state);\r\nif (!state)\r\ngpio_set_value_cansleep(data->ap_mcu_gpio, 1);\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ssp_do_transfer(struct ssp_data *data, struct ssp_msg *msg,\r\nstruct completion *done, int timeout)\r\n{\r\nint status;\r\nconst bool use_no_irq = msg->length == 0;\r\nif (data->shut_down)\r\nreturn -EPERM;\r\nmsg->done = done;\r\nmutex_lock(&data->comm_lock);\r\nstatus = ssp_check_lines(data, false);\r\nif (status < 0)\r\ngoto _error_locked;\r\nstatus = spi_write(data->spi, msg->buffer, SSP_HEADER_SIZE);\r\nif (status < 0) {\r\ngpio_set_value_cansleep(data->ap_mcu_gpio, 1);\r\ndev_err(SSP_DEV, "%s spi_write fail\n", __func__);\r\ngoto _error_locked;\r\n}\r\nif (!use_no_irq) {\r\nmutex_lock(&data->pending_lock);\r\nlist_add_tail(&msg->list, &data->pending_list);\r\nmutex_unlock(&data->pending_lock);\r\n}\r\nstatus = ssp_check_lines(data, true);\r\nif (status < 0) {\r\nif (!use_no_irq) {\r\nmutex_lock(&data->pending_lock);\r\nlist_del(&msg->list);\r\nmutex_unlock(&data->pending_lock);\r\n}\r\ngoto _error_locked;\r\n}\r\nmutex_unlock(&data->comm_lock);\r\nif (!use_no_irq && done)\r\nif (wait_for_completion_timeout(done,\r\nmsecs_to_jiffies(timeout)) ==\r\n0) {\r\nmutex_lock(&data->pending_lock);\r\nlist_del(&msg->list);\r\nmutex_unlock(&data->pending_lock);\r\ndata->timeout_cnt++;\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n_error_locked:\r\nmutex_unlock(&data->comm_lock);\r\ndata->timeout_cnt++;\r\nreturn status;\r\n}\r\nstatic inline int ssp_spi_sync_command(struct ssp_data *data,\r\nstruct ssp_msg *msg)\r\n{\r\nreturn ssp_do_transfer(data, msg, NULL, 0);\r\n}\r\nstatic int ssp_spi_sync(struct ssp_data *data, struct ssp_msg *msg,\r\nint timeout)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(done);\r\nif (WARN_ON(!msg->length))\r\nreturn -EPERM;\r\nreturn ssp_do_transfer(data, msg, &done, timeout);\r\n}\r\nstatic int ssp_handle_big_data(struct ssp_data *data, char *dataframe, int *idx)\r\n{\r\n*idx += 8;\r\nreturn 0;\r\n}\r\nstatic int ssp_parse_dataframe(struct ssp_data *data, char *dataframe, int len)\r\n{\r\nint idx, sd;\r\nstruct timespec ts;\r\nstruct ssp_sensor_data *spd;\r\nstruct iio_dev **indio_devs = data->sensor_devs;\r\ngetnstimeofday(&ts);\r\nfor (idx = 0; idx < len;) {\r\nswitch (dataframe[idx++]) {\r\ncase SSP_MSG2AP_INST_BYPASS_DATA:\r\nsd = dataframe[idx++];\r\nif (sd < 0 || sd >= SSP_SENSOR_MAX) {\r\ndev_err(SSP_DEV,\r\n"Mcu data frame1 error %d\n", sd);\r\nreturn -EPROTO;\r\n}\r\nif (indio_devs[sd]) {\r\nspd = iio_priv(indio_devs[sd]);\r\nif (spd->process_data)\r\nspd->process_data(indio_devs[sd],\r\n&dataframe[idx],\r\ndata->timestamp);\r\n} else {\r\ndev_err(SSP_DEV, "no client for frame\n");\r\n}\r\nidx += ssp_offset_map[sd];\r\nbreak;\r\ncase SSP_MSG2AP_INST_DEBUG_DATA:\r\nsd = ssp_print_mcu_debug(dataframe, &idx, len);\r\nif (sd) {\r\ndev_err(SSP_DEV,\r\n"Mcu data frame3 error %d\n", sd);\r\nreturn sd;\r\n}\r\nbreak;\r\ncase SSP_MSG2AP_INST_LIBRARY_DATA:\r\nidx += len;\r\nbreak;\r\ncase SSP_MSG2AP_INST_BIG_DATA:\r\nssp_handle_big_data(data, dataframe, &idx);\r\nbreak;\r\ncase SSP_MSG2AP_INST_TIME_SYNC:\r\ndata->time_syncing = true;\r\nbreak;\r\ncase SSP_MSG2AP_INST_RESET:\r\nssp_queue_ssp_refresh_task(data, 0);\r\nbreak;\r\n}\r\n}\r\nif (data->time_syncing)\r\ndata->timestamp = ts.tv_sec * 1000000000ULL + ts.tv_nsec;\r\nreturn 0;\r\n}\r\nint ssp_irq_msg(struct ssp_data *data)\r\n{\r\nbool found = false;\r\nchar *buffer;\r\nu8 msg_type;\r\nint ret;\r\nu16 length, msg_options;\r\nstruct ssp_msg *msg, *n;\r\nret = spi_read(data->spi, data->header_buffer, SSP_HEADER_BUFFER_SIZE);\r\nif (ret < 0) {\r\ndev_err(SSP_DEV, "header read fail\n");\r\nreturn ret;\r\n}\r\nlength = le16_to_cpu(data->header_buffer[1]);\r\nmsg_options = le16_to_cpu(data->header_buffer[0]);\r\nif (length == 0) {\r\ndev_err(SSP_DEV, "length received from mcu is 0\n");\r\nreturn -EINVAL;\r\n}\r\nmsg_type = SSP_GET_MESSAGE_TYPE(msg_options);\r\nswitch (msg_type) {\r\ncase SSP_AP2HUB_READ:\r\ncase SSP_AP2HUB_WRITE:\r\nmutex_lock(&data->pending_lock);\r\nlist_for_each_entry_safe(msg, n, &data->pending_list, list) {\r\nif (msg->options == msg_options) {\r\nlist_del(&msg->list);\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nbuffer = kmalloc(length, GFP_KERNEL | GFP_DMA);\r\nif (!buffer) {\r\nret = -ENOMEM;\r\ngoto _unlock;\r\n}\r\nret = spi_read(data->spi, buffer, length);\r\nif (ret >= 0)\r\nret = -EPROTO;\r\nkfree(buffer);\r\ndev_err(SSP_DEV, "No match error %x\n",\r\nmsg_options);\r\ngoto _unlock;\r\n}\r\nif (msg_type == SSP_AP2HUB_READ)\r\nret = spi_read(data->spi,\r\n&msg->buffer[SSP_HEADER_SIZE_ALIGNED],\r\nmsg->length);\r\nif (msg_type == SSP_AP2HUB_WRITE) {\r\nret = spi_write(data->spi,\r\n&msg->buffer[SSP_HEADER_SIZE_ALIGNED],\r\nmsg->length);\r\nif (msg_options & SSP_AP2HUB_RETURN) {\r\nmsg->options =\r\nSSP_AP2HUB_READ | SSP_AP2HUB_RETURN;\r\nmsg->length = 1;\r\nlist_add_tail(&msg->list, &data->pending_list);\r\ngoto _unlock;\r\n}\r\n}\r\nif (msg->done)\r\nif (!completion_done(msg->done))\r\ncomplete(msg->done);\r\n_unlock:\r\nmutex_unlock(&data->pending_lock);\r\nbreak;\r\ncase SSP_HUB2AP_WRITE:\r\nbuffer = kzalloc(length, GFP_KERNEL | GFP_DMA);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nret = spi_read(data->spi, buffer, length);\r\nif (ret < 0) {\r\ndev_err(SSP_DEV, "spi read fail\n");\r\nkfree(buffer);\r\nbreak;\r\n}\r\nret = ssp_parse_dataframe(data, buffer, length);\r\nkfree(buffer);\r\nbreak;\r\ndefault:\r\ndev_err(SSP_DEV, "unknown msg type\n");\r\nreturn -EPROTO;\r\n}\r\nreturn ret;\r\n}\r\nvoid ssp_clean_pending_list(struct ssp_data *data)\r\n{\r\nstruct ssp_msg *msg, *n;\r\nmutex_lock(&data->pending_lock);\r\nlist_for_each_entry_safe(msg, n, &data->pending_list, list) {\r\nlist_del(&msg->list);\r\nif (msg->done)\r\nif (!completion_done(msg->done))\r\ncomplete(msg->done);\r\n}\r\nmutex_unlock(&data->pending_lock);\r\n}\r\nint ssp_command(struct ssp_data *data, char command, int arg)\r\n{\r\nint ret;\r\nstruct ssp_msg *msg;\r\nmsg = ssp_create_msg(command, 0, SSP_AP2HUB_WRITE, arg);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nssp_dbg("%s - command 0x%x %d\n", __func__, command, arg);\r\nret = ssp_spi_sync_command(data, msg);\r\nssp_clean_msg(msg);\r\nreturn ret;\r\n}\r\nint ssp_send_instruction(struct ssp_data *data, u8 inst, u8 sensor_type,\r\nu8 *send_buf, u8 length)\r\n{\r\nint ret;\r\nstruct ssp_msg *msg;\r\nif (data->fw_dl_state == SSP_FW_DL_STATE_DOWNLOADING) {\r\ndev_err(SSP_DEV, "%s - Skip Inst! DL state = %d\n",\r\n__func__, data->fw_dl_state);\r\nreturn -EBUSY;\r\n} else if (!(data->available_sensors & BIT(sensor_type)) &&\r\n(inst <= SSP_MSG2SSP_INST_CHANGE_DELAY)) {\r\ndev_err(SSP_DEV, "%s - Bypass Inst Skip! - %u\n",\r\n__func__, sensor_type);\r\nreturn -EIO;\r\n}\r\nmsg = ssp_create_msg(inst, length + 2, SSP_AP2HUB_WRITE, 0);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nssp_fill_buffer(msg, 0, &sensor_type, 1);\r\nssp_fill_buffer(msg, 1, send_buf, length);\r\nssp_dbg("%s - Inst = 0x%x, Sensor Type = 0x%x, data = %u\n",\r\n__func__, inst, sensor_type, send_buf[1]);\r\nret = ssp_spi_sync(data, msg, 1000);\r\nssp_clean_msg(msg);\r\nreturn ret;\r\n}\r\nint ssp_get_chipid(struct ssp_data *data)\r\n{\r\nint ret;\r\nchar buffer;\r\nstruct ssp_msg *msg;\r\nmsg = ssp_create_msg(SSP_MSG2SSP_AP_WHOAMI, 1, SSP_AP2HUB_READ, 0);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nret = ssp_spi_sync(data, msg, 1000);\r\nbuffer = SSP_GET_BUFFER_AT_INDEX(msg, 0);\r\nssp_clean_msg(msg);\r\nreturn ret < 0 ? ret : buffer;\r\n}\r\nint ssp_set_magnetic_matrix(struct ssp_data *data)\r\n{\r\nint ret;\r\nstruct ssp_msg *msg;\r\nmsg = ssp_create_msg(SSP_MSG2SSP_AP_SET_MAGNETIC_STATIC_MATRIX,\r\ndata->sensorhub_info->mag_length, SSP_AP2HUB_WRITE,\r\n0);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nssp_fill_buffer(msg, 0, data->sensorhub_info->mag_table,\r\ndata->sensorhub_info->mag_length);\r\nret = ssp_spi_sync(data, msg, 1000);\r\nssp_clean_msg(msg);\r\nreturn ret;\r\n}\r\nunsigned int ssp_get_sensor_scanning_info(struct ssp_data *data)\r\n{\r\nint ret;\r\n__le32 result;\r\nu32 cpu_result = 0;\r\nstruct ssp_msg *msg = ssp_create_msg(SSP_MSG2SSP_AP_SENSOR_SCANNING, 4,\r\nSSP_AP2HUB_READ, 0);\r\nif (!msg)\r\nreturn 0;\r\nret = ssp_spi_sync(data, msg, 1000);\r\nif (ret < 0) {\r\ndev_err(SSP_DEV, "%s - spi read fail %d\n", __func__, ret);\r\ngoto _exit;\r\n}\r\nssp_get_buffer(msg, 0, &result, 4);\r\ncpu_result = le32_to_cpu(result);\r\ndev_info(SSP_DEV, "%s state: 0x%08x\n", __func__, cpu_result);\r\n_exit:\r\nssp_clean_msg(msg);\r\nreturn cpu_result;\r\n}\r\nunsigned int ssp_get_firmware_rev(struct ssp_data *data)\r\n{\r\nint ret;\r\n__le32 result;\r\nstruct ssp_msg *msg = ssp_create_msg(SSP_MSG2SSP_AP_FIRMWARE_REV, 4,\r\nSSP_AP2HUB_READ, 0);\r\nif (!msg)\r\nreturn SSP_INVALID_REVISION;\r\nret = ssp_spi_sync(data, msg, 1000);\r\nif (ret < 0) {\r\ndev_err(SSP_DEV, "%s - transfer fail %d\n", __func__, ret);\r\nret = SSP_INVALID_REVISION;\r\ngoto _exit;\r\n}\r\nssp_get_buffer(msg, 0, &result, 4);\r\nret = le32_to_cpu(result);\r\n_exit:\r\nssp_clean_msg(msg);\r\nreturn ret;\r\n}
