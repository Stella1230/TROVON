static u8 bcma_host_soc_read8(struct bcma_device *core, u16 offset)\r\n{\r\nreturn readb(core->io_addr + offset);\r\n}\r\nstatic u16 bcma_host_soc_read16(struct bcma_device *core, u16 offset)\r\n{\r\nreturn readw(core->io_addr + offset);\r\n}\r\nstatic u32 bcma_host_soc_read32(struct bcma_device *core, u16 offset)\r\n{\r\nreturn readl(core->io_addr + offset);\r\n}\r\nstatic void bcma_host_soc_write8(struct bcma_device *core, u16 offset,\r\nu8 value)\r\n{\r\nwriteb(value, core->io_addr + offset);\r\n}\r\nstatic void bcma_host_soc_write16(struct bcma_device *core, u16 offset,\r\nu16 value)\r\n{\r\nwritew(value, core->io_addr + offset);\r\n}\r\nstatic void bcma_host_soc_write32(struct bcma_device *core, u16 offset,\r\nu32 value)\r\n{\r\nwritel(value, core->io_addr + offset);\r\n}\r\nstatic void bcma_host_soc_block_read(struct bcma_device *core, void *buffer,\r\nsize_t count, u16 offset, u8 reg_width)\r\n{\r\nvoid __iomem *addr = core->io_addr + offset;\r\nswitch (reg_width) {\r\ncase sizeof(u8): {\r\nu8 *buf = buffer;\r\nwhile (count) {\r\n*buf = __raw_readb(addr);\r\nbuf++;\r\ncount--;\r\n}\r\nbreak;\r\n}\r\ncase sizeof(u16): {\r\n__le16 *buf = buffer;\r\nWARN_ON(count & 1);\r\nwhile (count) {\r\n*buf = (__force __le16)__raw_readw(addr);\r\nbuf++;\r\ncount -= 2;\r\n}\r\nbreak;\r\n}\r\ncase sizeof(u32): {\r\n__le32 *buf = buffer;\r\nWARN_ON(count & 3);\r\nwhile (count) {\r\n*buf = (__force __le32)__raw_readl(addr);\r\nbuf++;\r\ncount -= 4;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nWARN_ON(1);\r\n}\r\n}\r\nstatic void bcma_host_soc_block_write(struct bcma_device *core,\r\nconst void *buffer,\r\nsize_t count, u16 offset, u8 reg_width)\r\n{\r\nvoid __iomem *addr = core->io_addr + offset;\r\nswitch (reg_width) {\r\ncase sizeof(u8): {\r\nconst u8 *buf = buffer;\r\nwhile (count) {\r\n__raw_writeb(*buf, addr);\r\nbuf++;\r\ncount--;\r\n}\r\nbreak;\r\n}\r\ncase sizeof(u16): {\r\nconst __le16 *buf = buffer;\r\nWARN_ON(count & 1);\r\nwhile (count) {\r\n__raw_writew((__force u16)(*buf), addr);\r\nbuf++;\r\ncount -= 2;\r\n}\r\nbreak;\r\n}\r\ncase sizeof(u32): {\r\nconst __le32 *buf = buffer;\r\nWARN_ON(count & 3);\r\nwhile (count) {\r\n__raw_writel((__force u32)(*buf), addr);\r\nbuf++;\r\ncount -= 4;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nWARN_ON(1);\r\n}\r\n}\r\nstatic u32 bcma_host_soc_aread32(struct bcma_device *core, u16 offset)\r\n{\r\nif (WARN_ONCE(!core->io_wrap, "Accessed core has no wrapper/agent\n"))\r\nreturn ~0;\r\nreturn readl(core->io_wrap + offset);\r\n}\r\nstatic void bcma_host_soc_awrite32(struct bcma_device *core, u16 offset,\r\nu32 value)\r\n{\r\nif (WARN_ONCE(!core->io_wrap, "Accessed core has no wrapper/agent\n"))\r\nreturn;\r\nwritel(value, core->io_wrap + offset);\r\n}\r\nint __init bcma_host_soc_register(struct bcma_soc *soc)\r\n{\r\nstruct bcma_bus *bus = &soc->bus;\r\nbus->mmio = ioremap_nocache(BCMA_ADDR_BASE, BCMA_CORE_SIZE * 1);\r\nif (!bus->mmio)\r\nreturn -ENOMEM;\r\nbus->hosttype = BCMA_HOSTTYPE_SOC;\r\nbus->ops = &bcma_host_soc_ops;\r\nbus->host_pdev = NULL;\r\nbcma_init_bus(bus);\r\nreturn 0;\r\n}\r\nint __init bcma_host_soc_init(struct bcma_soc *soc)\r\n{\r\nstruct bcma_bus *bus = &soc->bus;\r\nint err;\r\nerr = bcma_bus_early_register(bus);\r\nif (err)\r\niounmap(bus->mmio);\r\nreturn err;\r\n}\r\nstatic int bcma_host_soc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct bcma_bus *bus;\r\nint err;\r\nbus = devm_kzalloc(dev, sizeof(*bus), GFP_KERNEL);\r\nif (!bus)\r\nreturn -ENOMEM;\r\nbus->mmio = of_iomap(np, 0);\r\nif (!bus->mmio)\r\nreturn -ENOMEM;\r\nbus->hosttype = BCMA_HOSTTYPE_SOC;\r\nbus->ops = &bcma_host_soc_ops;\r\nbus->host_pdev = pdev;\r\nbcma_init_bus(bus);\r\nerr = bcma_bus_register(bus);\r\nif (err)\r\ngoto err_unmap_mmio;\r\nplatform_set_drvdata(pdev, bus);\r\nreturn err;\r\nerr_unmap_mmio:\r\niounmap(bus->mmio);\r\nreturn err;\r\n}\r\nstatic int bcma_host_soc_remove(struct platform_device *pdev)\r\n{\r\nstruct bcma_bus *bus = platform_get_drvdata(pdev);\r\nbcma_bus_unregister(bus);\r\niounmap(bus->mmio);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nint __init bcma_host_soc_register_driver(void)\r\n{\r\nreturn platform_driver_register(&bcma_host_soc_driver);\r\n}\r\nvoid __exit bcma_host_soc_unregister_driver(void)\r\n{\r\nplatform_driver_unregister(&bcma_host_soc_driver);\r\n}
