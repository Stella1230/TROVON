static void warn_setuid_and_fcaps_mixed(const char *fname)\r\n{\r\nstatic int warned;\r\nif (!warned) {\r\nprintk(KERN_INFO "warning: `%s' has both setuid-root and"\r\n" effective capabilities. Therefore not raising all"\r\n" capabilities.\n", fname);\r\nwarned = 1;\r\n}\r\n}\r\nint cap_capable(const struct cred *cred, struct user_namespace *targ_ns,\r\nint cap, int audit)\r\n{\r\nstruct user_namespace *ns = targ_ns;\r\nfor (;;) {\r\nif (ns == cred->user_ns)\r\nreturn cap_raised(cred->cap_effective, cap) ? 0 : -EPERM;\r\nif (ns == &init_user_ns)\r\nreturn -EPERM;\r\nif ((ns->parent == cred->user_ns) && uid_eq(ns->owner, cred->euid))\r\nreturn 0;\r\nns = ns->parent;\r\n}\r\n}\r\nint cap_settime(const struct timespec *ts, const struct timezone *tz)\r\n{\r\nif (!capable(CAP_SYS_TIME))\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nint cap_ptrace_access_check(struct task_struct *child, unsigned int mode)\r\n{\r\nint ret = 0;\r\nconst struct cred *cred, *child_cred;\r\nrcu_read_lock();\r\ncred = current_cred();\r\nchild_cred = __task_cred(child);\r\nif (cred->user_ns == child_cred->user_ns &&\r\ncap_issubset(child_cred->cap_permitted, cred->cap_permitted))\r\ngoto out;\r\nif (ns_capable(child_cred->user_ns, CAP_SYS_PTRACE))\r\ngoto out;\r\nret = -EPERM;\r\nout:\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nint cap_ptrace_traceme(struct task_struct *parent)\r\n{\r\nint ret = 0;\r\nconst struct cred *cred, *child_cred;\r\nrcu_read_lock();\r\ncred = __task_cred(parent);\r\nchild_cred = current_cred();\r\nif (cred->user_ns == child_cred->user_ns &&\r\ncap_issubset(child_cred->cap_permitted, cred->cap_permitted))\r\ngoto out;\r\nif (has_ns_capability(parent, child_cred->user_ns, CAP_SYS_PTRACE))\r\ngoto out;\r\nret = -EPERM;\r\nout:\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nint cap_capget(struct task_struct *target, kernel_cap_t *effective,\r\nkernel_cap_t *inheritable, kernel_cap_t *permitted)\r\n{\r\nconst struct cred *cred;\r\nrcu_read_lock();\r\ncred = __task_cred(target);\r\n*effective = cred->cap_effective;\r\n*inheritable = cred->cap_inheritable;\r\n*permitted = cred->cap_permitted;\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic inline int cap_inh_is_capped(void)\r\n{\r\nif (cap_capable(current_cred(), current_cred()->user_ns,\r\nCAP_SETPCAP, SECURITY_CAP_AUDIT) == 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint cap_capset(struct cred *new,\r\nconst struct cred *old,\r\nconst kernel_cap_t *effective,\r\nconst kernel_cap_t *inheritable,\r\nconst kernel_cap_t *permitted)\r\n{\r\nif (cap_inh_is_capped() &&\r\n!cap_issubset(*inheritable,\r\ncap_combine(old->cap_inheritable,\r\nold->cap_permitted)))\r\nreturn -EPERM;\r\nif (!cap_issubset(*inheritable,\r\ncap_combine(old->cap_inheritable,\r\nold->cap_bset)))\r\nreturn -EPERM;\r\nif (!cap_issubset(*permitted, old->cap_permitted))\r\nreturn -EPERM;\r\nif (!cap_issubset(*effective, *permitted))\r\nreturn -EPERM;\r\nnew->cap_effective = *effective;\r\nnew->cap_inheritable = *inheritable;\r\nnew->cap_permitted = *permitted;\r\nnew->cap_ambient = cap_intersect(new->cap_ambient,\r\ncap_intersect(*permitted,\r\n*inheritable));\r\nif (WARN_ON(!cap_ambient_invariant_ok(new)))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic inline void bprm_clear_caps(struct linux_binprm *bprm)\r\n{\r\ncap_clear(bprm->cred->cap_permitted);\r\nbprm->cap_effective = false;\r\n}\r\nint cap_inode_need_killpriv(struct dentry *dentry)\r\n{\r\nstruct inode *inode = d_backing_inode(dentry);\r\nint error;\r\nif (!inode->i_op->getxattr)\r\nreturn 0;\r\nerror = inode->i_op->getxattr(dentry, XATTR_NAME_CAPS, NULL, 0);\r\nif (error <= 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint cap_inode_killpriv(struct dentry *dentry)\r\n{\r\nstruct inode *inode = d_backing_inode(dentry);\r\nif (!inode->i_op->removexattr)\r\nreturn 0;\r\nreturn inode->i_op->removexattr(dentry, XATTR_NAME_CAPS);\r\n}\r\nstatic inline int bprm_caps_from_vfs_caps(struct cpu_vfs_cap_data *caps,\r\nstruct linux_binprm *bprm,\r\nbool *effective,\r\nbool *has_cap)\r\n{\r\nstruct cred *new = bprm->cred;\r\nunsigned i;\r\nint ret = 0;\r\nif (caps->magic_etc & VFS_CAP_FLAGS_EFFECTIVE)\r\n*effective = true;\r\nif (caps->magic_etc & VFS_CAP_REVISION_MASK)\r\n*has_cap = true;\r\nCAP_FOR_EACH_U32(i) {\r\n__u32 permitted = caps->permitted.cap[i];\r\n__u32 inheritable = caps->inheritable.cap[i];\r\nnew->cap_permitted.cap[i] =\r\n(new->cap_bset.cap[i] & permitted) |\r\n(new->cap_inheritable.cap[i] & inheritable);\r\nif (permitted & ~new->cap_permitted.cap[i])\r\nret = -EPERM;\r\n}\r\nreturn *effective ? ret : 0;\r\n}\r\nint get_vfs_caps_from_disk(const struct dentry *dentry, struct cpu_vfs_cap_data *cpu_caps)\r\n{\r\nstruct inode *inode = d_backing_inode(dentry);\r\n__u32 magic_etc;\r\nunsigned tocopy, i;\r\nint size;\r\nstruct vfs_cap_data caps;\r\nmemset(cpu_caps, 0, sizeof(struct cpu_vfs_cap_data));\r\nif (!inode || !inode->i_op->getxattr)\r\nreturn -ENODATA;\r\nsize = inode->i_op->getxattr((struct dentry *)dentry, XATTR_NAME_CAPS, &caps,\r\nXATTR_CAPS_SZ);\r\nif (size == -ENODATA || size == -EOPNOTSUPP)\r\nreturn -ENODATA;\r\nif (size < 0)\r\nreturn size;\r\nif (size < sizeof(magic_etc))\r\nreturn -EINVAL;\r\ncpu_caps->magic_etc = magic_etc = le32_to_cpu(caps.magic_etc);\r\nswitch (magic_etc & VFS_CAP_REVISION_MASK) {\r\ncase VFS_CAP_REVISION_1:\r\nif (size != XATTR_CAPS_SZ_1)\r\nreturn -EINVAL;\r\ntocopy = VFS_CAP_U32_1;\r\nbreak;\r\ncase VFS_CAP_REVISION_2:\r\nif (size != XATTR_CAPS_SZ_2)\r\nreturn -EINVAL;\r\ntocopy = VFS_CAP_U32_2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nCAP_FOR_EACH_U32(i) {\r\nif (i >= tocopy)\r\nbreak;\r\ncpu_caps->permitted.cap[i] = le32_to_cpu(caps.data[i].permitted);\r\ncpu_caps->inheritable.cap[i] = le32_to_cpu(caps.data[i].inheritable);\r\n}\r\ncpu_caps->permitted.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\r\ncpu_caps->inheritable.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\r\nreturn 0;\r\n}\r\nstatic int get_file_caps(struct linux_binprm *bprm, bool *effective, bool *has_cap)\r\n{\r\nint rc = 0;\r\nstruct cpu_vfs_cap_data vcaps;\r\nbprm_clear_caps(bprm);\r\nif (!file_caps_enabled)\r\nreturn 0;\r\nif (bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID)\r\nreturn 0;\r\nrc = get_vfs_caps_from_disk(bprm->file->f_path.dentry, &vcaps);\r\nif (rc < 0) {\r\nif (rc == -EINVAL)\r\nprintk(KERN_NOTICE "%s: get_vfs_caps_from_disk returned %d for %s\n",\r\n__func__, rc, bprm->filename);\r\nelse if (rc == -ENODATA)\r\nrc = 0;\r\ngoto out;\r\n}\r\nrc = bprm_caps_from_vfs_caps(&vcaps, bprm, effective, has_cap);\r\nif (rc == -EINVAL)\r\nprintk(KERN_NOTICE "%s: cap_from_disk returned %d for %s\n",\r\n__func__, rc, bprm->filename);\r\nout:\r\nif (rc)\r\nbprm_clear_caps(bprm);\r\nreturn rc;\r\n}\r\nint cap_bprm_set_creds(struct linux_binprm *bprm)\r\n{\r\nconst struct cred *old = current_cred();\r\nstruct cred *new = bprm->cred;\r\nbool effective, has_cap = false, is_setid;\r\nint ret;\r\nkuid_t root_uid;\r\nif (WARN_ON(!cap_ambient_invariant_ok(old)))\r\nreturn -EPERM;\r\neffective = false;\r\nret = get_file_caps(bprm, &effective, &has_cap);\r\nif (ret < 0)\r\nreturn ret;\r\nroot_uid = make_kuid(new->user_ns, 0);\r\nif (!issecure(SECURE_NOROOT)) {\r\nif (has_cap && !uid_eq(new->uid, root_uid) && uid_eq(new->euid, root_uid)) {\r\nwarn_setuid_and_fcaps_mixed(bprm->filename);\r\ngoto skip;\r\n}\r\nif (uid_eq(new->euid, root_uid) || uid_eq(new->uid, root_uid)) {\r\nnew->cap_permitted = cap_combine(old->cap_bset,\r\nold->cap_inheritable);\r\n}\r\nif (uid_eq(new->euid, root_uid))\r\neffective = true;\r\n}\r\nskip:\r\nif (!cap_issubset(new->cap_permitted, old->cap_permitted))\r\nbprm->per_clear |= PER_CLEAR_ON_SETID;\r\nis_setid = !uid_eq(new->euid, old->uid) || !gid_eq(new->egid, old->gid);\r\nif ((is_setid ||\r\n!cap_issubset(new->cap_permitted, old->cap_permitted)) &&\r\nbprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {\r\nif (!capable(CAP_SETUID) ||\r\n(bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS)) {\r\nnew->euid = new->uid;\r\nnew->egid = new->gid;\r\n}\r\nnew->cap_permitted = cap_intersect(new->cap_permitted,\r\nold->cap_permitted);\r\n}\r\nnew->suid = new->fsuid = new->euid;\r\nnew->sgid = new->fsgid = new->egid;\r\nif (has_cap || is_setid)\r\ncap_clear(new->cap_ambient);\r\nnew->cap_permitted = cap_combine(new->cap_permitted, new->cap_ambient);\r\nif (effective)\r\nnew->cap_effective = new->cap_permitted;\r\nelse\r\nnew->cap_effective = new->cap_ambient;\r\nif (WARN_ON(!cap_ambient_invariant_ok(new)))\r\nreturn -EPERM;\r\nbprm->cap_effective = effective;\r\nif (!cap_issubset(new->cap_effective, new->cap_ambient)) {\r\nif (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||\r\n!uid_eq(new->euid, root_uid) || !uid_eq(new->uid, root_uid) ||\r\nissecure(SECURE_NOROOT)) {\r\nret = audit_log_bprm_fcaps(bprm, new, old);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nnew->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);\r\nif (WARN_ON(!cap_ambient_invariant_ok(new)))\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nint cap_bprm_secureexec(struct linux_binprm *bprm)\r\n{\r\nconst struct cred *cred = current_cred();\r\nkuid_t root_uid = make_kuid(cred->user_ns, 0);\r\nif (!uid_eq(cred->uid, root_uid)) {\r\nif (bprm->cap_effective)\r\nreturn 1;\r\nif (!cap_issubset(cred->cap_permitted, cred->cap_ambient))\r\nreturn 1;\r\n}\r\nreturn (!uid_eq(cred->euid, cred->uid) ||\r\n!gid_eq(cred->egid, cred->gid));\r\n}\r\nint cap_inode_setxattr(struct dentry *dentry, const char *name,\r\nconst void *value, size_t size, int flags)\r\n{\r\nif (!strcmp(name, XATTR_NAME_CAPS)) {\r\nif (!capable(CAP_SETFCAP))\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nif (!strncmp(name, XATTR_SECURITY_PREFIX,\r\nsizeof(XATTR_SECURITY_PREFIX) - 1) &&\r\n!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nint cap_inode_removexattr(struct dentry *dentry, const char *name)\r\n{\r\nif (!strcmp(name, XATTR_NAME_CAPS)) {\r\nif (!capable(CAP_SETFCAP))\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nif (!strncmp(name, XATTR_SECURITY_PREFIX,\r\nsizeof(XATTR_SECURITY_PREFIX) - 1) &&\r\n!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nstatic inline void cap_emulate_setxuid(struct cred *new, const struct cred *old)\r\n{\r\nkuid_t root_uid = make_kuid(old->user_ns, 0);\r\nif ((uid_eq(old->uid, root_uid) ||\r\nuid_eq(old->euid, root_uid) ||\r\nuid_eq(old->suid, root_uid)) &&\r\n(!uid_eq(new->uid, root_uid) &&\r\n!uid_eq(new->euid, root_uid) &&\r\n!uid_eq(new->suid, root_uid))) {\r\nif (!issecure(SECURE_KEEP_CAPS)) {\r\ncap_clear(new->cap_permitted);\r\ncap_clear(new->cap_effective);\r\n}\r\ncap_clear(new->cap_ambient);\r\n}\r\nif (uid_eq(old->euid, root_uid) && !uid_eq(new->euid, root_uid))\r\ncap_clear(new->cap_effective);\r\nif (!uid_eq(old->euid, root_uid) && uid_eq(new->euid, root_uid))\r\nnew->cap_effective = new->cap_permitted;\r\n}\r\nint cap_task_fix_setuid(struct cred *new, const struct cred *old, int flags)\r\n{\r\nswitch (flags) {\r\ncase LSM_SETID_RE:\r\ncase LSM_SETID_ID:\r\ncase LSM_SETID_RES:\r\nif (!issecure(SECURE_NO_SETUID_FIXUP))\r\ncap_emulate_setxuid(new, old);\r\nbreak;\r\ncase LSM_SETID_FS:\r\nif (!issecure(SECURE_NO_SETUID_FIXUP)) {\r\nkuid_t root_uid = make_kuid(old->user_ns, 0);\r\nif (uid_eq(old->fsuid, root_uid) && !uid_eq(new->fsuid, root_uid))\r\nnew->cap_effective =\r\ncap_drop_fs_set(new->cap_effective);\r\nif (!uid_eq(old->fsuid, root_uid) && uid_eq(new->fsuid, root_uid))\r\nnew->cap_effective =\r\ncap_raise_fs_set(new->cap_effective,\r\nnew->cap_permitted);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cap_safe_nice(struct task_struct *p)\r\n{\r\nint is_subset, ret = 0;\r\nrcu_read_lock();\r\nis_subset = cap_issubset(__task_cred(p)->cap_permitted,\r\ncurrent_cred()->cap_permitted);\r\nif (!is_subset && !ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE))\r\nret = -EPERM;\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nint cap_task_setscheduler(struct task_struct *p)\r\n{\r\nreturn cap_safe_nice(p);\r\n}\r\nint cap_task_setioprio(struct task_struct *p, int ioprio)\r\n{\r\nreturn cap_safe_nice(p);\r\n}\r\nint cap_task_setnice(struct task_struct *p, int nice)\r\n{\r\nreturn cap_safe_nice(p);\r\n}\r\nstatic int cap_prctl_drop(unsigned long cap)\r\n{\r\nstruct cred *new;\r\nif (!ns_capable(current_user_ns(), CAP_SETPCAP))\r\nreturn -EPERM;\r\nif (!cap_valid(cap))\r\nreturn -EINVAL;\r\nnew = prepare_creds();\r\nif (!new)\r\nreturn -ENOMEM;\r\ncap_lower(new->cap_bset, cap);\r\nreturn commit_creds(new);\r\n}\r\nint cap_task_prctl(int option, unsigned long arg2, unsigned long arg3,\r\nunsigned long arg4, unsigned long arg5)\r\n{\r\nconst struct cred *old = current_cred();\r\nstruct cred *new;\r\nswitch (option) {\r\ncase PR_CAPBSET_READ:\r\nif (!cap_valid(arg2))\r\nreturn -EINVAL;\r\nreturn !!cap_raised(old->cap_bset, arg2);\r\ncase PR_CAPBSET_DROP:\r\nreturn cap_prctl_drop(arg2);\r\ncase PR_SET_SECUREBITS:\r\nif ((((old->securebits & SECURE_ALL_LOCKS) >> 1)\r\n& (old->securebits ^ arg2))\r\n|| ((old->securebits & SECURE_ALL_LOCKS & ~arg2))\r\n|| (arg2 & ~(SECURE_ALL_LOCKS | SECURE_ALL_BITS))\r\n|| (cap_capable(current_cred(),\r\ncurrent_cred()->user_ns, CAP_SETPCAP,\r\nSECURITY_CAP_AUDIT) != 0)\r\n)\r\nreturn -EPERM;\r\nnew = prepare_creds();\r\nif (!new)\r\nreturn -ENOMEM;\r\nnew->securebits = arg2;\r\nreturn commit_creds(new);\r\ncase PR_GET_SECUREBITS:\r\nreturn old->securebits;\r\ncase PR_GET_KEEPCAPS:\r\nreturn !!issecure(SECURE_KEEP_CAPS);\r\ncase PR_SET_KEEPCAPS:\r\nif (arg2 > 1)\r\nreturn -EINVAL;\r\nif (issecure(SECURE_KEEP_CAPS_LOCKED))\r\nreturn -EPERM;\r\nnew = prepare_creds();\r\nif (!new)\r\nreturn -ENOMEM;\r\nif (arg2)\r\nnew->securebits |= issecure_mask(SECURE_KEEP_CAPS);\r\nelse\r\nnew->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);\r\nreturn commit_creds(new);\r\ncase PR_CAP_AMBIENT:\r\nif (arg2 == PR_CAP_AMBIENT_CLEAR_ALL) {\r\nif (arg3 | arg4 | arg5)\r\nreturn -EINVAL;\r\nnew = prepare_creds();\r\nif (!new)\r\nreturn -ENOMEM;\r\ncap_clear(new->cap_ambient);\r\nreturn commit_creds(new);\r\n}\r\nif (((!cap_valid(arg3)) | arg4 | arg5))\r\nreturn -EINVAL;\r\nif (arg2 == PR_CAP_AMBIENT_IS_SET) {\r\nreturn !!cap_raised(current_cred()->cap_ambient, arg3);\r\n} else if (arg2 != PR_CAP_AMBIENT_RAISE &&\r\narg2 != PR_CAP_AMBIENT_LOWER) {\r\nreturn -EINVAL;\r\n} else {\r\nif (arg2 == PR_CAP_AMBIENT_RAISE &&\r\n(!cap_raised(current_cred()->cap_permitted, arg3) ||\r\n!cap_raised(current_cred()->cap_inheritable,\r\narg3) ||\r\nissecure(SECURE_NO_CAP_AMBIENT_RAISE)))\r\nreturn -EPERM;\r\nnew = prepare_creds();\r\nif (!new)\r\nreturn -ENOMEM;\r\nif (arg2 == PR_CAP_AMBIENT_RAISE)\r\ncap_raise(new->cap_ambient, arg3);\r\nelse\r\ncap_lower(new->cap_ambient, arg3);\r\nreturn commit_creds(new);\r\n}\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\n}\r\nint cap_vm_enough_memory(struct mm_struct *mm, long pages)\r\n{\r\nint cap_sys_admin = 0;\r\nif (cap_capable(current_cred(), &init_user_ns, CAP_SYS_ADMIN,\r\nSECURITY_CAP_NOAUDIT) == 0)\r\ncap_sys_admin = 1;\r\nreturn cap_sys_admin;\r\n}\r\nint cap_mmap_addr(unsigned long addr)\r\n{\r\nint ret = 0;\r\nif (addr < dac_mmap_min_addr) {\r\nret = cap_capable(current_cred(), &init_user_ns, CAP_SYS_RAWIO,\r\nSECURITY_CAP_AUDIT);\r\nif (ret == 0)\r\ncurrent->flags |= PF_SUPERPRIV;\r\n}\r\nreturn ret;\r\n}\r\nint cap_mmap_file(struct file *file, unsigned long reqprot,\r\nunsigned long prot, unsigned long flags)\r\n{\r\nreturn 0;\r\n}\r\nvoid __init capability_add_hooks(void)\r\n{\r\nsecurity_add_hooks(capability_hooks, ARRAY_SIZE(capability_hooks));\r\n}
