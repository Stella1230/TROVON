static inline struct msm_dsi *dsi_mgr_get_dsi(int id)\r\n{\r\nreturn msm_dsim_glb.dsi[id];\r\n}\r\nstatic inline struct msm_dsi *dsi_mgr_get_other_dsi(int id)\r\n{\r\nreturn msm_dsim_glb.dsi[(id + 1) % DSI_MAX];\r\n}\r\nstatic int dsi_mgr_parse_dual_dsi(struct device_node *np, int id)\r\n{\r\nstruct msm_dsi_manager *msm_dsim = &msm_dsim_glb;\r\nif (!msm_dsim->is_dual_dsi)\r\nmsm_dsim->is_dual_dsi = of_property_read_bool(\r\nnp, "qcom,dual-dsi-mode");\r\nif (msm_dsim->is_dual_dsi) {\r\nif (of_property_read_bool(np, "qcom,master-dsi"))\r\nmsm_dsim->master_dsi_link_id = id;\r\nif (!msm_dsim->is_sync_needed)\r\nmsm_dsim->is_sync_needed = of_property_read_bool(\r\nnp, "qcom,sync-dual-dsi");\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsi_mgr_host_register(int id)\r\n{\r\nstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\r\nstruct msm_dsi *other_dsi = dsi_mgr_get_other_dsi(id);\r\nstruct msm_dsi *clk_master_dsi = dsi_mgr_get_dsi(DSI_CLOCK_MASTER);\r\nstruct msm_dsi_pll *src_pll;\r\nint ret;\r\nif (!IS_DUAL_DSI()) {\r\nret = msm_dsi_host_register(msm_dsi->host, true);\r\nif (ret)\r\nreturn ret;\r\nsrc_pll = msm_dsi_phy_get_pll(msm_dsi->phy);\r\nret = msm_dsi_host_set_src_pll(msm_dsi->host, src_pll);\r\n} else if (!other_dsi) {\r\nret = 0;\r\n} else {\r\nstruct msm_dsi *mdsi = IS_MASTER_DSI_LINK(id) ?\r\nmsm_dsi : other_dsi;\r\nstruct msm_dsi *sdsi = IS_MASTER_DSI_LINK(id) ?\r\nother_dsi : msm_dsi;\r\nret = msm_dsi_host_register(sdsi->host, false);\r\nif (ret)\r\nreturn ret;\r\nret = msm_dsi_host_register(mdsi->host, true);\r\nif (ret)\r\nreturn ret;\r\nsrc_pll = msm_dsi_phy_get_pll(clk_master_dsi->phy);\r\nret = msm_dsi_host_set_src_pll(msm_dsi->host, src_pll);\r\nif (ret)\r\nreturn ret;\r\nret = msm_dsi_host_set_src_pll(other_dsi->host, src_pll);\r\n}\r\nreturn ret;\r\n}\r\nstatic inline int dsi_mgr_connector_get_id(struct drm_connector *connector)\r\n{\r\nstruct dsi_connector *dsi_connector = to_dsi_connector(connector);\r\nreturn dsi_connector->id;\r\n}\r\nstatic int dsi_mgr_bridge_get_id(struct drm_bridge *bridge)\r\n{\r\nstruct dsi_bridge *dsi_bridge = to_dsi_bridge(bridge);\r\nreturn dsi_bridge->id;\r\n}\r\nstatic enum drm_connector_status dsi_mgr_connector_detect(\r\nstruct drm_connector *connector, bool force)\r\n{\r\nint id = dsi_mgr_connector_get_id(connector);\r\nstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\r\nstruct msm_dsi *other_dsi = dsi_mgr_get_other_dsi(id);\r\nstruct msm_drm_private *priv = connector->dev->dev_private;\r\nstruct msm_kms *kms = priv->kms;\r\nDBG("id=%d", id);\r\nif (!msm_dsi->panel) {\r\nmsm_dsi->panel = msm_dsi_host_get_panel(msm_dsi->host,\r\n&msm_dsi->device_flags);\r\nif (!msm_dsi->panel && IS_DUAL_DSI() &&\r\n!IS_MASTER_DSI_LINK(id) && other_dsi)\r\nmsm_dsi->panel = msm_dsi_host_get_panel(\r\nother_dsi->host, NULL);\r\nif (msm_dsi->panel && IS_DUAL_DSI())\r\ndrm_object_attach_property(&connector->base,\r\nconnector->dev->mode_config.tile_property, 0);\r\nif (msm_dsi->panel && IS_DUAL_DSI() &&\r\nother_dsi && other_dsi->panel) {\r\nbool cmd_mode = !(msm_dsi->device_flags &\r\nMIPI_DSI_MODE_VIDEO);\r\nstruct drm_encoder *encoder = msm_dsi_get_encoder(\r\ndsi_mgr_get_dsi(DSI_ENCODER_MASTER));\r\nstruct drm_encoder *slave_enc = msm_dsi_get_encoder(\r\ndsi_mgr_get_dsi(DSI_ENCODER_SLAVE));\r\nif (kms->funcs->set_split_display)\r\nkms->funcs->set_split_display(kms, encoder,\r\nslave_enc, cmd_mode);\r\nelse\r\npr_err("mdp does not support dual DSI\n");\r\n}\r\n}\r\nreturn msm_dsi->panel ? connector_status_connected :\r\nconnector_status_disconnected;\r\n}\r\nstatic void dsi_mgr_connector_destroy(struct drm_connector *connector)\r\n{\r\nDBG("");\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\n}\r\nstatic void dsi_dual_connector_fix_modes(struct drm_connector *connector)\r\n{\r\nstruct drm_display_mode *mode, *m;\r\nlist_for_each_entry_safe(mode, m, &connector->probed_modes, head) {\r\nmode->clock >>= 1;\r\nmode->hdisplay >>= 1;\r\nmode->hsync_start >>= 1;\r\nmode->hsync_end >>= 1;\r\nmode->htotal >>= 1;\r\ndrm_mode_set_name(mode);\r\n}\r\n}\r\nstatic int dsi_dual_connector_tile_init(\r\nstruct drm_connector *connector, int id)\r\n{\r\nstruct drm_display_mode *mode;\r\nchar topo_id[8] = {'M', 'S', 'M', 'D', 'U', 'D', 'S', 'I'};\r\nif (connector->tile_group) {\r\nDBG("Tile property has been initialized");\r\nreturn 0;\r\n}\r\nmode = list_first_entry(&connector->probed_modes,\r\nstruct drm_display_mode,\r\nhead);\r\nif (!mode)\r\nreturn -EINVAL;\r\nconnector->tile_group = drm_mode_get_tile_group(\r\nconnector->dev, topo_id);\r\nif (!connector->tile_group)\r\nconnector->tile_group = drm_mode_create_tile_group(\r\nconnector->dev, topo_id);\r\nif (!connector->tile_group) {\r\npr_err("%s: failed to create tile group\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nconnector->has_tile = true;\r\nconnector->tile_is_single_monitor = true;\r\nconnector->tile_h_size = mode->hdisplay;\r\nconnector->tile_v_size = mode->vdisplay;\r\nconnector->num_h_tile = 2;\r\nconnector->num_v_tile = 1;\r\nconnector->tile_v_loc = 0;\r\nconnector->tile_h_loc = (id == DSI_RIGHT) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int dsi_mgr_connector_get_modes(struct drm_connector *connector)\r\n{\r\nint id = dsi_mgr_connector_get_id(connector);\r\nstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\r\nstruct drm_panel *panel = msm_dsi->panel;\r\nint ret, num;\r\nif (!panel)\r\nreturn 0;\r\ndrm_panel_attach(panel, connector);\r\nnum = drm_panel_get_modes(panel);\r\ndrm_panel_detach(panel);\r\nif (!num)\r\nreturn 0;\r\nif (IS_DUAL_DSI()) {\r\ndsi_dual_connector_fix_modes(connector);\r\nret = dsi_dual_connector_tile_init(connector, id);\r\nif (ret)\r\nreturn ret;\r\nret = drm_mode_connector_set_tile_property(connector);\r\nif (ret) {\r\npr_err("%s: set tile property failed, %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn num;\r\n}\r\nstatic int dsi_mgr_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nint id = dsi_mgr_connector_get_id(connector);\r\nstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\r\nstruct drm_encoder *encoder = msm_dsi_get_encoder(msm_dsi);\r\nstruct msm_drm_private *priv = connector->dev->dev_private;\r\nstruct msm_kms *kms = priv->kms;\r\nlong actual, requested;\r\nDBG("");\r\nrequested = 1000 * mode->clock;\r\nactual = kms->funcs->round_pixclk(kms, requested, encoder);\r\nDBG("requested=%ld, actual=%ld", requested, actual);\r\nif (actual != requested)\r\nreturn MODE_CLOCK_RANGE;\r\nreturn MODE_OK;\r\n}\r\nstatic struct drm_encoder *\r\ndsi_mgr_connector_best_encoder(struct drm_connector *connector)\r\n{\r\nint id = dsi_mgr_connector_get_id(connector);\r\nstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\r\nDBG("");\r\nreturn msm_dsi_get_encoder(msm_dsi);\r\n}\r\nstatic void dsi_mgr_bridge_pre_enable(struct drm_bridge *bridge)\r\n{\r\nint id = dsi_mgr_bridge_get_id(bridge);\r\nstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\r\nstruct msm_dsi *msm_dsi1 = dsi_mgr_get_dsi(DSI_1);\r\nstruct mipi_dsi_host *host = msm_dsi->host;\r\nstruct drm_panel *panel = msm_dsi->panel;\r\nbool is_dual_dsi = IS_DUAL_DSI();\r\nint ret;\r\nDBG("id=%d", id);\r\nif (!msm_dsi_device_connected(msm_dsi) ||\r\n(is_dual_dsi && (DSI_1 == id)))\r\nreturn;\r\nret = msm_dsi_host_power_on(host);\r\nif (ret) {\r\npr_err("%s: power on host %d failed, %d\n", __func__, id, ret);\r\ngoto host_on_fail;\r\n}\r\nif (is_dual_dsi && msm_dsi1) {\r\nret = msm_dsi_host_power_on(msm_dsi1->host);\r\nif (ret) {\r\npr_err("%s: power on host1 failed, %d\n",\r\n__func__, ret);\r\ngoto host1_on_fail;\r\n}\r\n}\r\nif (panel) {\r\nret = drm_panel_prepare(panel);\r\nif (ret) {\r\npr_err("%s: prepare panel %d failed, %d\n", __func__,\r\nid, ret);\r\ngoto panel_prep_fail;\r\n}\r\n}\r\nret = msm_dsi_host_enable(host);\r\nif (ret) {\r\npr_err("%s: enable host %d failed, %d\n", __func__, id, ret);\r\ngoto host_en_fail;\r\n}\r\nif (is_dual_dsi && msm_dsi1) {\r\nret = msm_dsi_host_enable(msm_dsi1->host);\r\nif (ret) {\r\npr_err("%s: enable host1 failed, %d\n", __func__, ret);\r\ngoto host1_en_fail;\r\n}\r\n}\r\nif (panel) {\r\nret = drm_panel_enable(panel);\r\nif (ret) {\r\npr_err("%s: enable panel %d failed, %d\n", __func__, id,\r\nret);\r\ngoto panel_en_fail;\r\n}\r\n}\r\nreturn;\r\npanel_en_fail:\r\nif (is_dual_dsi && msm_dsi1)\r\nmsm_dsi_host_disable(msm_dsi1->host);\r\nhost1_en_fail:\r\nmsm_dsi_host_disable(host);\r\nhost_en_fail:\r\nif (panel)\r\ndrm_panel_unprepare(panel);\r\npanel_prep_fail:\r\nif (is_dual_dsi && msm_dsi1)\r\nmsm_dsi_host_power_off(msm_dsi1->host);\r\nhost1_on_fail:\r\nmsm_dsi_host_power_off(host);\r\nhost_on_fail:\r\nreturn;\r\n}\r\nstatic void dsi_mgr_bridge_enable(struct drm_bridge *bridge)\r\n{\r\nDBG("");\r\n}\r\nstatic void dsi_mgr_bridge_disable(struct drm_bridge *bridge)\r\n{\r\nDBG("");\r\n}\r\nstatic void dsi_mgr_bridge_post_disable(struct drm_bridge *bridge)\r\n{\r\nint id = dsi_mgr_bridge_get_id(bridge);\r\nstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\r\nstruct msm_dsi *msm_dsi1 = dsi_mgr_get_dsi(DSI_1);\r\nstruct mipi_dsi_host *host = msm_dsi->host;\r\nstruct drm_panel *panel = msm_dsi->panel;\r\nbool is_dual_dsi = IS_DUAL_DSI();\r\nint ret;\r\nDBG("id=%d", id);\r\nif (!msm_dsi_device_connected(msm_dsi) ||\r\n(is_dual_dsi && (DSI_1 == id)))\r\nreturn;\r\nif (panel) {\r\nret = drm_panel_disable(panel);\r\nif (ret)\r\npr_err("%s: Panel %d OFF failed, %d\n", __func__, id,\r\nret);\r\n}\r\nret = msm_dsi_host_disable(host);\r\nif (ret)\r\npr_err("%s: host %d disable failed, %d\n", __func__, id, ret);\r\nif (is_dual_dsi && msm_dsi1) {\r\nret = msm_dsi_host_disable(msm_dsi1->host);\r\nif (ret)\r\npr_err("%s: host1 disable failed, %d\n", __func__, ret);\r\n}\r\nif (panel) {\r\nret = drm_panel_unprepare(panel);\r\nif (ret)\r\npr_err("%s: Panel %d unprepare failed,%d\n", __func__,\r\nid, ret);\r\n}\r\nret = msm_dsi_host_power_off(host);\r\nif (ret)\r\npr_err("%s: host %d power off failed,%d\n", __func__, id, ret);\r\nif (is_dual_dsi && msm_dsi1) {\r\nret = msm_dsi_host_power_off(msm_dsi1->host);\r\nif (ret)\r\npr_err("%s: host1 power off failed, %d\n",\r\n__func__, ret);\r\n}\r\n}\r\nstatic void dsi_mgr_bridge_mode_set(struct drm_bridge *bridge,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nint id = dsi_mgr_bridge_get_id(bridge);\r\nstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\r\nstruct msm_dsi *other_dsi = dsi_mgr_get_other_dsi(id);\r\nstruct mipi_dsi_host *host = msm_dsi->host;\r\nbool is_dual_dsi = IS_DUAL_DSI();\r\nDBG("set mode: %d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x",\r\nmode->base.id, mode->name,\r\nmode->vrefresh, mode->clock,\r\nmode->hdisplay, mode->hsync_start,\r\nmode->hsync_end, mode->htotal,\r\nmode->vdisplay, mode->vsync_start,\r\nmode->vsync_end, mode->vtotal,\r\nmode->type, mode->flags);\r\nif (is_dual_dsi && (DSI_1 == id))\r\nreturn;\r\nmsm_dsi_host_set_display_mode(host, adjusted_mode);\r\nif (is_dual_dsi && other_dsi)\r\nmsm_dsi_host_set_display_mode(other_dsi->host, adjusted_mode);\r\n}\r\nstruct drm_connector *msm_dsi_manager_connector_init(u8 id)\r\n{\r\nstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\r\nstruct drm_connector *connector = NULL;\r\nstruct dsi_connector *dsi_connector;\r\nint ret, i;\r\ndsi_connector = devm_kzalloc(msm_dsi->dev->dev,\r\nsizeof(*dsi_connector), GFP_KERNEL);\r\nif (!dsi_connector) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\ndsi_connector->id = id;\r\nconnector = &dsi_connector->base;\r\nret = drm_connector_init(msm_dsi->dev, connector,\r\n&dsi_mgr_connector_funcs, DRM_MODE_CONNECTOR_DSI);\r\nif (ret)\r\ngoto fail;\r\ndrm_connector_helper_add(connector, &dsi_mgr_conn_helper_funcs);\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\nconnector->interlace_allowed = 0;\r\nconnector->doublescan_allowed = 0;\r\nret = drm_connector_register(connector);\r\nif (ret)\r\ngoto fail;\r\nfor (i = 0; i < MSM_DSI_ENCODER_NUM; i++)\r\ndrm_mode_connector_attach_encoder(connector,\r\nmsm_dsi->encoders[i]);\r\nreturn connector;\r\nfail:\r\nif (connector)\r\ndsi_mgr_connector_destroy(connector);\r\nreturn ERR_PTR(ret);\r\n}\r\nstruct drm_bridge *msm_dsi_manager_bridge_init(u8 id)\r\n{\r\nstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\r\nstruct drm_bridge *bridge = NULL;\r\nstruct dsi_bridge *dsi_bridge;\r\nint ret;\r\ndsi_bridge = devm_kzalloc(msm_dsi->dev->dev,\r\nsizeof(*dsi_bridge), GFP_KERNEL);\r\nif (!dsi_bridge) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\ndsi_bridge->id = id;\r\nbridge = &dsi_bridge->base;\r\nbridge->funcs = &dsi_mgr_bridge_funcs;\r\nret = drm_bridge_attach(msm_dsi->dev, bridge);\r\nif (ret)\r\ngoto fail;\r\nreturn bridge;\r\nfail:\r\nif (bridge)\r\nmsm_dsi_manager_bridge_destroy(bridge);\r\nreturn ERR_PTR(ret);\r\n}\r\nstruct drm_connector *msm_dsi_manager_ext_bridge_init(u8 id)\r\n{\r\nstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\r\nstruct drm_device *dev = msm_dsi->dev;\r\nstruct drm_encoder *encoder;\r\nstruct drm_bridge *int_bridge, *ext_bridge;\r\nstruct drm_connector *connector;\r\nstruct list_head *connector_list;\r\nint_bridge = msm_dsi->bridge;\r\next_bridge = msm_dsi->external_bridge =\r\nmsm_dsi_host_get_bridge(msm_dsi->host);\r\nencoder = msm_dsi->encoders[MSM_DSI_VIDEO_ENCODER_ID];\r\nint_bridge->next = ext_bridge;\r\next_bridge->encoder = encoder;\r\ndrm_bridge_attach(dev, ext_bridge);\r\nconnector_list = &dev->mode_config.connector_list;\r\nlist_for_each_entry(connector, connector_list, head) {\r\nint i;\r\nfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\r\nif (connector->encoder_ids[i] == encoder->base.id)\r\nreturn connector;\r\n}\r\n}\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nvoid msm_dsi_manager_bridge_destroy(struct drm_bridge *bridge)\r\n{\r\n}\r\nint msm_dsi_manager_phy_enable(int id,\r\nconst unsigned long bit_rate, const unsigned long esc_rate,\r\nu32 *clk_pre, u32 *clk_post)\r\n{\r\nstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\r\nstruct msm_dsi_phy *phy = msm_dsi->phy;\r\nint src_pll_id = IS_DUAL_DSI() ? DSI_CLOCK_MASTER : id;\r\nstruct msm_dsi_pll *pll = msm_dsi_phy_get_pll(msm_dsi->phy);\r\nint ret;\r\nret = msm_dsi_phy_enable(phy, src_pll_id, bit_rate, esc_rate);\r\nif (ret)\r\nreturn ret;\r\nif (!IS_DUAL_DSI() || (id == DSI_CLOCK_MASTER)) {\r\nret = msm_dsi_pll_restore_state(pll);\r\nif (ret) {\r\npr_err("%s: failed to restore pll state\n", __func__);\r\nmsm_dsi_phy_disable(phy);\r\nreturn ret;\r\n}\r\n}\r\nmsm_dsi->phy_enabled = true;\r\nmsm_dsi_phy_get_clk_pre_post(phy, clk_pre, clk_post);\r\nreturn 0;\r\n}\r\nvoid msm_dsi_manager_phy_disable(int id)\r\n{\r\nstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\r\nstruct msm_dsi *mdsi = dsi_mgr_get_dsi(DSI_CLOCK_MASTER);\r\nstruct msm_dsi *sdsi = dsi_mgr_get_dsi(DSI_CLOCK_SLAVE);\r\nstruct msm_dsi_phy *phy = msm_dsi->phy;\r\nstruct msm_dsi_pll *pll = msm_dsi_phy_get_pll(msm_dsi->phy);\r\nif (!IS_DUAL_DSI() || (id == DSI_CLOCK_MASTER))\r\nmsm_dsi_pll_save_state(pll);\r\nmsm_dsi->phy_enabled = false;\r\nif (IS_DUAL_DSI() && mdsi && sdsi) {\r\nif (!mdsi->phy_enabled && !sdsi->phy_enabled) {\r\nmsm_dsi_phy_disable(sdsi->phy);\r\nmsm_dsi_phy_disable(mdsi->phy);\r\n}\r\n} else {\r\nmsm_dsi_phy_disable(phy);\r\n}\r\n}\r\nint msm_dsi_manager_cmd_xfer(int id, const struct mipi_dsi_msg *msg)\r\n{\r\nstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\r\nstruct msm_dsi *msm_dsi0 = dsi_mgr_get_dsi(DSI_0);\r\nstruct mipi_dsi_host *host = msm_dsi->host;\r\nbool is_read = (msg->rx_buf && msg->rx_len);\r\nbool need_sync = (IS_SYNC_NEEDED() && !is_read);\r\nint ret;\r\nif (!msg->tx_buf || !msg->tx_len)\r\nreturn 0;\r\nif (need_sync && (id == DSI_0))\r\nreturn is_read ? msg->rx_len : msg->tx_len;\r\nif (need_sync && msm_dsi0) {\r\nret = msm_dsi_host_xfer_prepare(msm_dsi0->host, msg);\r\nif (ret) {\r\npr_err("%s: failed to prepare non-trigger host, %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\n}\r\nret = msm_dsi_host_xfer_prepare(host, msg);\r\nif (ret) {\r\npr_err("%s: failed to prepare host, %d\n", __func__, ret);\r\ngoto restore_host0;\r\n}\r\nret = is_read ? msm_dsi_host_cmd_rx(host, msg) :\r\nmsm_dsi_host_cmd_tx(host, msg);\r\nmsm_dsi_host_xfer_restore(host, msg);\r\nrestore_host0:\r\nif (need_sync && msm_dsi0)\r\nmsm_dsi_host_xfer_restore(msm_dsi0->host, msg);\r\nreturn ret;\r\n}\r\nbool msm_dsi_manager_cmd_xfer_trigger(int id, u32 iova, u32 len)\r\n{\r\nstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\r\nstruct msm_dsi *msm_dsi0 = dsi_mgr_get_dsi(DSI_0);\r\nstruct mipi_dsi_host *host = msm_dsi->host;\r\nif (IS_SYNC_NEEDED() && (id == DSI_0))\r\nreturn false;\r\nif (IS_SYNC_NEEDED() && msm_dsi0)\r\nmsm_dsi_host_cmd_xfer_commit(msm_dsi0->host, iova, len);\r\nmsm_dsi_host_cmd_xfer_commit(host, iova, len);\r\nreturn true;\r\n}\r\nint msm_dsi_manager_register(struct msm_dsi *msm_dsi)\r\n{\r\nstruct msm_dsi_manager *msm_dsim = &msm_dsim_glb;\r\nint id = msm_dsi->id;\r\nint ret;\r\nif (id > DSI_MAX) {\r\npr_err("%s: invalid id %d\n", __func__, id);\r\nreturn -EINVAL;\r\n}\r\nif (msm_dsim->dsi[id]) {\r\npr_err("%s: dsi%d already registered\n", __func__, id);\r\nreturn -EBUSY;\r\n}\r\nmsm_dsim->dsi[id] = msm_dsi;\r\nret = dsi_mgr_parse_dual_dsi(msm_dsi->pdev->dev.of_node, id);\r\nif (ret) {\r\npr_err("%s: failed to parse dual DSI info\n", __func__);\r\ngoto fail;\r\n}\r\nret = dsi_mgr_host_register(id);\r\nif (ret) {\r\npr_err("%s: failed to register mipi dsi host for DSI %d\n",\r\n__func__, id);\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nmsm_dsim->dsi[id] = NULL;\r\nreturn ret;\r\n}\r\nvoid msm_dsi_manager_unregister(struct msm_dsi *msm_dsi)\r\n{\r\nstruct msm_dsi_manager *msm_dsim = &msm_dsim_glb;\r\nif (msm_dsi->host)\r\nmsm_dsi_host_unregister(msm_dsi->host);\r\nmsm_dsim->dsi[msm_dsi->id] = NULL;\r\n}
