static void\r\nmemx_out(struct nvkm_memx *memx)\r\n{\r\nstruct nvkm_device *device = memx->pmu->subdev.device;\r\nint i;\r\nif (memx->c.mthd) {\r\nnvkm_wr32(device, 0x10a1c4, (memx->c.size << 16) | memx->c.mthd);\r\nfor (i = 0; i < memx->c.size; i++)\r\nnvkm_wr32(device, 0x10a1c4, memx->c.data[i]);\r\nmemx->c.mthd = 0;\r\nmemx->c.size = 0;\r\n}\r\n}\r\nstatic void\r\nmemx_cmd(struct nvkm_memx *memx, u32 mthd, u32 size, u32 data[])\r\n{\r\nif ((memx->c.size + size >= ARRAY_SIZE(memx->c.data)) ||\r\n(memx->c.mthd && memx->c.mthd != mthd))\r\nmemx_out(memx);\r\nmemcpy(&memx->c.data[memx->c.size], data, size * sizeof(data[0]));\r\nmemx->c.size += size;\r\nmemx->c.mthd = mthd;\r\n}\r\nint\r\nnvkm_memx_init(struct nvkm_pmu *pmu, struct nvkm_memx **pmemx)\r\n{\r\nstruct nvkm_device *device = pmu->subdev.device;\r\nstruct nvkm_memx *memx;\r\nu32 reply[2];\r\nint ret;\r\nret = nvkm_pmu_send(pmu, reply, PROC_MEMX, MEMX_MSG_INFO,\r\nMEMX_INFO_DATA, 0);\r\nif (ret)\r\nreturn ret;\r\nmemx = *pmemx = kzalloc(sizeof(*memx), GFP_KERNEL);\r\nif (!memx)\r\nreturn -ENOMEM;\r\nmemx->pmu = pmu;\r\nmemx->base = reply[0];\r\nmemx->size = reply[1];\r\ndo {\r\nnvkm_wr32(device, 0x10a580, 0x00000003);\r\n} while (nvkm_rd32(device, 0x10a580) != 0x00000003);\r\nnvkm_wr32(device, 0x10a1c0, 0x01000000 | memx->base);\r\nreturn 0;\r\n}\r\nint\r\nnvkm_memx_fini(struct nvkm_memx **pmemx, bool exec)\r\n{\r\nstruct nvkm_memx *memx = *pmemx;\r\nstruct nvkm_pmu *pmu = memx->pmu;\r\nstruct nvkm_subdev *subdev = &pmu->subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nu32 finish, reply[2];\r\nmemx_out(memx);\r\nfinish = nvkm_rd32(device, 0x10a1c0) & 0x00ffffff;\r\nnvkm_wr32(device, 0x10a580, 0x00000000);\r\nif (exec) {\r\nnvkm_pmu_send(pmu, reply, PROC_MEMX, MEMX_MSG_EXEC,\r\nmemx->base, finish);\r\n}\r\nnvkm_debug(subdev, "Exec took %uns, PMU_IN %08x\n",\r\nreply[0], reply[1]);\r\nkfree(memx);\r\nreturn 0;\r\n}\r\nvoid\r\nnvkm_memx_wr32(struct nvkm_memx *memx, u32 addr, u32 data)\r\n{\r\nnvkm_debug(&memx->pmu->subdev, "R[%06x] = %08x\n", addr, data);\r\nmemx_cmd(memx, MEMX_WR32, 2, (u32[]){ addr, data });\r\n}\r\nvoid\r\nnvkm_memx_wait(struct nvkm_memx *memx,\r\nu32 addr, u32 mask, u32 data, u32 nsec)\r\n{\r\nnvkm_debug(&memx->pmu->subdev, "R[%06x] & %08x == %08x, %d us\n",\r\naddr, mask, data, nsec);\r\nmemx_cmd(memx, MEMX_WAIT, 4, (u32[]){ addr, mask, data, nsec });\r\nmemx_out(memx);\r\n}\r\nvoid\r\nnvkm_memx_nsec(struct nvkm_memx *memx, u32 nsec)\r\n{\r\nnvkm_debug(&memx->pmu->subdev, " DELAY = %d ns\n", nsec);\r\nmemx_cmd(memx, MEMX_DELAY, 1, (u32[]){ nsec });\r\nmemx_out(memx);\r\n}\r\nvoid\r\nnvkm_memx_wait_vblank(struct nvkm_memx *memx)\r\n{\r\nstruct nvkm_subdev *subdev = &memx->pmu->subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nu32 heads, x, y, px = 0;\r\nint i, head_sync;\r\nif (device->chipset < 0xd0) {\r\nheads = nvkm_rd32(device, 0x610050);\r\nfor (i = 0; i < 2; i++) {\r\nif (heads & (2 << (i << 3))) {\r\nx = nvkm_rd32(device, 0x610b40 + (0x540 * i));\r\ny = (x & 0xffff0000) >> 16;\r\nx &= 0x0000ffff;\r\nif ((x * y) > px) {\r\npx = (x * y);\r\nhead_sync = i;\r\n}\r\n}\r\n}\r\n}\r\nif (px == 0) {\r\nnvkm_debug(subdev, "WAIT VBLANK !NO ACTIVE HEAD\n");\r\nreturn;\r\n}\r\nnvkm_debug(subdev, "WAIT VBLANK HEAD%d\n", head_sync);\r\nmemx_cmd(memx, MEMX_VBLANK, 1, (u32[]){ head_sync });\r\nmemx_out(memx);\r\n}\r\nvoid\r\nnvkm_memx_train(struct nvkm_memx *memx)\r\n{\r\nnvkm_debug(&memx->pmu->subdev, " MEM TRAIN\n");\r\nmemx_cmd(memx, MEMX_TRAIN, 0, NULL);\r\n}\r\nint\r\nnvkm_memx_train_result(struct nvkm_pmu *pmu, u32 *res, int rsize)\r\n{\r\nstruct nvkm_device *device = pmu->subdev.device;\r\nu32 reply[2], base, size, i;\r\nint ret;\r\nret = nvkm_pmu_send(pmu, reply, PROC_MEMX, MEMX_MSG_INFO,\r\nMEMX_INFO_TRAIN, 0);\r\nif (ret)\r\nreturn ret;\r\nbase = reply[0];\r\nsize = reply[1] >> 2;\r\nif (size > rsize)\r\nreturn -ENOMEM;\r\nnvkm_wr32(device, 0x10a1c0, 0x02000000 | base);\r\nfor (i = 0; i < size; i++)\r\nres[i] = nvkm_rd32(device, 0x10a1c4);\r\nreturn 0;\r\n}\r\nvoid\r\nnvkm_memx_block(struct nvkm_memx *memx)\r\n{\r\nnvkm_debug(&memx->pmu->subdev, " HOST BLOCKED\n");\r\nmemx_cmd(memx, MEMX_ENTER, 0, NULL);\r\n}\r\nvoid\r\nnvkm_memx_unblock(struct nvkm_memx *memx)\r\n{\r\nnvkm_debug(&memx->pmu->subdev, " HOST UNBLOCKED\n");\r\nmemx_cmd(memx, MEMX_LEAVE, 0, NULL);\r\n}
