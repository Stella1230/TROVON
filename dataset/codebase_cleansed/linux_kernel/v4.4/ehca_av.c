int ehca_calc_ipd(struct ehca_shca *shca, int port,\r\nenum ib_rate path_rate, u32 *ipd)\r\n{\r\nint path = ib_rate_to_mult(path_rate);\r\nint link, ret;\r\nstruct ib_port_attr pa;\r\nif (path_rate == IB_RATE_PORT_CURRENT) {\r\n*ipd = 0;\r\nreturn 0;\r\n}\r\nif (unlikely(path < 0)) {\r\nehca_err(&shca->ib_device, "Invalid static rate! path_rate=%x",\r\npath_rate);\r\nreturn -EINVAL;\r\n}\r\nret = ehca_query_port(&shca->ib_device, port, &pa);\r\nif (unlikely(ret < 0)) {\r\nehca_err(&shca->ib_device, "Failed to query port ret=%i", ret);\r\nreturn ret;\r\n}\r\nlink = ib_width_enum_to_int(pa.active_width) * pa.active_speed;\r\nif (path >= link)\r\n*ipd = 0;\r\nelse\r\n*ipd = ((link + (path >> 1)) / path) - 1;\r\nreturn 0;\r\n}\r\nstruct ib_ah *ehca_create_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr)\r\n{\r\nint ret;\r\nstruct ehca_av *av;\r\nstruct ehca_shca *shca = container_of(pd->device, struct ehca_shca,\r\nib_device);\r\nav = kmem_cache_alloc(av_cache, GFP_KERNEL);\r\nif (!av) {\r\nehca_err(pd->device, "Out of memory pd=%p ah_attr=%p",\r\npd, ah_attr);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nav->av.sl = ah_attr->sl;\r\nav->av.dlid = ah_attr->dlid;\r\nav->av.slid_path_bits = ah_attr->src_path_bits;\r\nif (ehca_static_rate < 0) {\r\nu32 ipd;\r\nif (ehca_calc_ipd(shca, ah_attr->port_num,\r\nah_attr->static_rate, &ipd)) {\r\nret = -EINVAL;\r\ngoto create_ah_exit1;\r\n}\r\nav->av.ipd = ipd;\r\n} else\r\nav->av.ipd = ehca_static_rate;\r\nav->av.lnh = ah_attr->ah_flags;\r\nav->av.grh.word_0 = EHCA_BMASK_SET(GRH_IPVERSION_MASK, 6);\r\nav->av.grh.word_0 |= EHCA_BMASK_SET(GRH_TCLASS_MASK,\r\nah_attr->grh.traffic_class);\r\nav->av.grh.word_0 |= EHCA_BMASK_SET(GRH_FLOWLABEL_MASK,\r\nah_attr->grh.flow_label);\r\nav->av.grh.word_0 |= EHCA_BMASK_SET(GRH_HOPLIMIT_MASK,\r\nah_attr->grh.hop_limit);\r\nav->av.grh.word_0 |= EHCA_BMASK_SET(GRH_NEXTHEADER_MASK, 0x1B);\r\nif (ah_attr->ah_flags & IB_AH_GRH) {\r\nint rc;\r\nstruct ib_port_attr port_attr;\r\nunion ib_gid gid;\r\nmemset(&port_attr, 0, sizeof(port_attr));\r\nrc = ehca_query_port(pd->device, ah_attr->port_num,\r\n&port_attr);\r\nif (rc) {\r\nret = -EINVAL;\r\nehca_err(pd->device, "Invalid port number "\r\n"ehca_query_port() returned %x "\r\n"pd=%p ah_attr=%p", rc, pd, ah_attr);\r\ngoto create_ah_exit1;\r\n}\r\nmemset(&gid, 0, sizeof(gid));\r\nrc = ehca_query_gid(pd->device,\r\nah_attr->port_num,\r\nah_attr->grh.sgid_index, &gid);\r\nif (rc) {\r\nret = -EINVAL;\r\nehca_err(pd->device, "Failed to retrieve sgid "\r\n"ehca_query_gid() returned %x "\r\n"pd=%p ah_attr=%p", rc, pd, ah_attr);\r\ngoto create_ah_exit1;\r\n}\r\nmemcpy(&av->av.grh.word_1, &gid, sizeof(gid));\r\n}\r\nav->av.pmtu = shca->max_mtu;\r\nmemcpy(&av->av.grh.word_3, &ah_attr->grh.dgid,\r\nsizeof(ah_attr->grh.dgid));\r\nreturn &av->ib_ah;\r\ncreate_ah_exit1:\r\nkmem_cache_free(av_cache, av);\r\nreturn ERR_PTR(ret);\r\n}\r\nint ehca_modify_ah(struct ib_ah *ah, struct ib_ah_attr *ah_attr)\r\n{\r\nstruct ehca_av *av;\r\nstruct ehca_ud_av new_ehca_av;\r\nstruct ehca_shca *shca = container_of(ah->pd->device, struct ehca_shca,\r\nib_device);\r\nmemset(&new_ehca_av, 0, sizeof(new_ehca_av));\r\nnew_ehca_av.sl = ah_attr->sl;\r\nnew_ehca_av.dlid = ah_attr->dlid;\r\nnew_ehca_av.slid_path_bits = ah_attr->src_path_bits;\r\nnew_ehca_av.ipd = ah_attr->static_rate;\r\nnew_ehca_av.lnh = EHCA_BMASK_SET(GRH_FLAG_MASK,\r\n(ah_attr->ah_flags & IB_AH_GRH) > 0);\r\nnew_ehca_av.grh.word_0 = EHCA_BMASK_SET(GRH_TCLASS_MASK,\r\nah_attr->grh.traffic_class);\r\nnew_ehca_av.grh.word_0 |= EHCA_BMASK_SET(GRH_FLOWLABEL_MASK,\r\nah_attr->grh.flow_label);\r\nnew_ehca_av.grh.word_0 |= EHCA_BMASK_SET(GRH_HOPLIMIT_MASK,\r\nah_attr->grh.hop_limit);\r\nnew_ehca_av.grh.word_0 |= EHCA_BMASK_SET(GRH_NEXTHEADER_MASK, 0x1b);\r\nif (ah_attr->ah_flags & IB_AH_GRH) {\r\nint rc;\r\nstruct ib_port_attr port_attr;\r\nunion ib_gid gid;\r\nmemset(&port_attr, 0, sizeof(port_attr));\r\nrc = ehca_query_port(ah->device, ah_attr->port_num,\r\n&port_attr);\r\nif (rc) {\r\nehca_err(ah->device, "Invalid port number "\r\n"ehca_query_port() returned %x "\r\n"ah=%p ah_attr=%p port_num=%x",\r\nrc, ah, ah_attr, ah_attr->port_num);\r\nreturn -EINVAL;\r\n}\r\nmemset(&gid, 0, sizeof(gid));\r\nrc = ehca_query_gid(ah->device,\r\nah_attr->port_num,\r\nah_attr->grh.sgid_index, &gid);\r\nif (rc) {\r\nehca_err(ah->device, "Failed to retrieve sgid "\r\n"ehca_query_gid() returned %x "\r\n"ah=%p ah_attr=%p port_num=%x "\r\n"sgid_index=%x",\r\nrc, ah, ah_attr, ah_attr->port_num,\r\nah_attr->grh.sgid_index);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(&new_ehca_av.grh.word_1, &gid, sizeof(gid));\r\n}\r\nnew_ehca_av.pmtu = shca->max_mtu;\r\nmemcpy(&new_ehca_av.grh.word_3, &ah_attr->grh.dgid,\r\nsizeof(ah_attr->grh.dgid));\r\nav = container_of(ah, struct ehca_av, ib_ah);\r\nav->av = new_ehca_av;\r\nreturn 0;\r\n}\r\nint ehca_query_ah(struct ib_ah *ah, struct ib_ah_attr *ah_attr)\r\n{\r\nstruct ehca_av *av = container_of(ah, struct ehca_av, ib_ah);\r\nmemcpy(&ah_attr->grh.dgid, &av->av.grh.word_3,\r\nsizeof(ah_attr->grh.dgid));\r\nah_attr->sl = av->av.sl;\r\nah_attr->dlid = av->av.dlid;\r\nah_attr->src_path_bits = av->av.slid_path_bits;\r\nah_attr->static_rate = av->av.ipd;\r\nah_attr->ah_flags = EHCA_BMASK_GET(GRH_FLAG_MASK, av->av.lnh);\r\nah_attr->grh.traffic_class = EHCA_BMASK_GET(GRH_TCLASS_MASK,\r\nav->av.grh.word_0);\r\nah_attr->grh.hop_limit = EHCA_BMASK_GET(GRH_HOPLIMIT_MASK,\r\nav->av.grh.word_0);\r\nah_attr->grh.flow_label = EHCA_BMASK_GET(GRH_FLOWLABEL_MASK,\r\nav->av.grh.word_0);\r\nreturn 0;\r\n}\r\nint ehca_destroy_ah(struct ib_ah *ah)\r\n{\r\nkmem_cache_free(av_cache, container_of(ah, struct ehca_av, ib_ah));\r\nreturn 0;\r\n}\r\nint ehca_init_av_cache(void)\r\n{\r\nav_cache = kmem_cache_create("ehca_cache_av",\r\nsizeof(struct ehca_av), 0,\r\nSLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (!av_cache)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid ehca_cleanup_av_cache(void)\r\n{\r\nif (av_cache)\r\nkmem_cache_destroy(av_cache);\r\n}
