static void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)\r\n{\r\nu32 plat_lpc, arm_srpgcr, ccm_clpcr;\r\nu32 empgc0, empgc1;\r\nint stop_mode = 0;\r\nplat_lpc = __raw_readl(cortex_base + MXC_CORTEXA8_PLAT_LPC) &\r\n~(MXC_CORTEXA8_PLAT_LPC_DSM);\r\nccm_clpcr = __raw_readl(ccm_base + MXC_CCM_CLPCR) &\r\n~(MXC_CCM_CLPCR_LPM_MASK);\r\narm_srpgcr = __raw_readl(gpc_base + MXC_SRPG_ARM_SRPGCR) &\r\n~(MXC_SRPGCR_PCR);\r\nempgc0 = __raw_readl(gpc_base + MXC_SRPG_EMPGC0_SRPGCR) &\r\n~(MXC_SRPGCR_PCR);\r\nempgc1 = __raw_readl(gpc_base + MXC_SRPG_EMPGC1_SRPGCR) &\r\n~(MXC_SRPGCR_PCR);\r\nswitch (mode) {\r\ncase WAIT_CLOCKED:\r\nbreak;\r\ncase WAIT_UNCLOCKED:\r\nccm_clpcr |= 0x1 << MXC_CCM_CLPCR_LPM_OFFSET;\r\nbreak;\r\ncase WAIT_UNCLOCKED_POWER_OFF:\r\ncase STOP_POWER_OFF:\r\nplat_lpc |= MXC_CORTEXA8_PLAT_LPC_DSM\r\n| MXC_CORTEXA8_PLAT_LPC_DBG_DSM;\r\nif (mode == WAIT_UNCLOCKED_POWER_OFF) {\r\nccm_clpcr |= 0x1 << MXC_CCM_CLPCR_LPM_OFFSET;\r\nccm_clpcr &= ~MXC_CCM_CLPCR_VSTBY;\r\nccm_clpcr &= ~MXC_CCM_CLPCR_SBYOS;\r\nstop_mode = 0;\r\n} else {\r\nccm_clpcr |= 0x2 << MXC_CCM_CLPCR_LPM_OFFSET;\r\nccm_clpcr |= 0x3 << MXC_CCM_CLPCR_STBY_COUNT_OFFSET;\r\nccm_clpcr |= MXC_CCM_CLPCR_VSTBY;\r\nccm_clpcr |= MXC_CCM_CLPCR_SBYOS;\r\nstop_mode = 1;\r\n}\r\narm_srpgcr |= MXC_SRPGCR_PCR;\r\nbreak;\r\ncase STOP_POWER_ON:\r\nccm_clpcr |= 0x2 << MXC_CCM_CLPCR_LPM_OFFSET;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "UNKNOWN cpu power mode: %d\n", mode);\r\nreturn;\r\n}\r\n__raw_writel(plat_lpc, cortex_base + MXC_CORTEXA8_PLAT_LPC);\r\n__raw_writel(ccm_clpcr, ccm_base + MXC_CCM_CLPCR);\r\n__raw_writel(arm_srpgcr, gpc_base + MXC_SRPG_ARM_SRPGCR);\r\n__raw_writel(arm_srpgcr, gpc_base + MXC_SRPG_NEON_SRPGCR);\r\nif (stop_mode) {\r\nempgc0 |= MXC_SRPGCR_PCR;\r\nempgc1 |= MXC_SRPGCR_PCR;\r\n__raw_writel(empgc0, gpc_base + MXC_SRPG_EMPGC0_SRPGCR);\r\n__raw_writel(empgc1, gpc_base + MXC_SRPG_EMPGC1_SRPGCR);\r\n}\r\n}\r\nstatic int mx5_suspend_enter(suspend_state_t state)\r\n{\r\nswitch (state) {\r\ncase PM_SUSPEND_MEM:\r\nmx5_cpu_lp_set(STOP_POWER_OFF);\r\nbreak;\r\ncase PM_SUSPEND_STANDBY:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (state == PM_SUSPEND_MEM) {\r\nlocal_flush_tlb_all();\r\nflush_cache_all();\r\n__raw_writel(0, gpc_base + MXC_SRPG_EMPGC0_SRPGCR);\r\n__raw_writel(0, gpc_base + MXC_SRPG_EMPGC1_SRPGCR);\r\nif (imx5_suspend_in_ocram_fn)\r\nimx5_suspend_in_ocram_fn(suspend_ocram_base);\r\nelse\r\ncpu_do_idle();\r\n} else {\r\ncpu_do_idle();\r\n}\r\nmx5_cpu_lp_set(IMX5_DEFAULT_CPU_IDLE_STATE);\r\nreturn 0;\r\n}\r\nstatic int mx5_pm_valid(suspend_state_t state)\r\n{\r\nreturn (state > PM_SUSPEND_ON && state <= PM_SUSPEND_MAX);\r\n}\r\nstatic inline int imx5_cpu_do_idle(void)\r\n{\r\nint ret = tzic_enable_wake();\r\nif (likely(!ret))\r\ncpu_do_idle();\r\nreturn ret;\r\n}\r\nstatic void imx5_pm_idle(void)\r\n{\r\nimx5_cpu_do_idle();\r\n}\r\nstatic int __init imx_suspend_alloc_ocram(\r\nsize_t size,\r\nvoid __iomem **virt_out,\r\nphys_addr_t *phys_out)\r\n{\r\nstruct device_node *node;\r\nstruct platform_device *pdev;\r\nstruct gen_pool *ocram_pool;\r\nunsigned long ocram_base;\r\nvoid __iomem *virt;\r\nphys_addr_t phys;\r\nint ret = 0;\r\nnode = of_find_compatible_node(NULL, NULL, "mmio-sram");\r\nif (!node) {\r\npr_warn("%s: failed to find ocram node!\n", __func__);\r\nreturn -ENODEV;\r\n}\r\npdev = of_find_device_by_node(node);\r\nif (!pdev) {\r\npr_warn("%s: failed to find ocram device!\n", __func__);\r\nret = -ENODEV;\r\ngoto put_node;\r\n}\r\nocram_pool = gen_pool_get(&pdev->dev, NULL);\r\nif (!ocram_pool) {\r\npr_warn("%s: ocram pool unavailable!\n", __func__);\r\nret = -ENODEV;\r\ngoto put_node;\r\n}\r\nocram_base = gen_pool_alloc(ocram_pool, size);\r\nif (!ocram_base) {\r\npr_warn("%s: unable to alloc ocram!\n", __func__);\r\nret = -ENOMEM;\r\ngoto put_node;\r\n}\r\nphys = gen_pool_virt_to_phys(ocram_pool, ocram_base);\r\nvirt = __arm_ioremap_exec(phys, size, false);\r\nif (phys_out)\r\n*phys_out = phys;\r\nif (virt_out)\r\n*virt_out = virt;\r\nput_node:\r\nof_node_put(node);\r\nreturn ret;\r\n}\r\nstatic int __init imx5_suspend_init(const struct imx5_pm_data *soc_data)\r\n{\r\nstruct imx5_cpu_suspend_info *suspend_info;\r\nint ret;\r\nvoid (*suspend_asm)(void __iomem *) = soc_data->suspend_asm;\r\nif (!suspend_asm)\r\nreturn 0;\r\nif (!soc_data->suspend_asm_sz || !*soc_data->suspend_asm_sz)\r\nreturn -EINVAL;\r\nret = imx_suspend_alloc_ocram(\r\n*soc_data->suspend_asm_sz + sizeof(*suspend_info),\r\n&suspend_ocram_base, NULL);\r\nif (ret)\r\nreturn ret;\r\nsuspend_info = suspend_ocram_base;\r\nsuspend_info->io_count = soc_data->suspend_io_count;\r\nmemcpy(suspend_info->io_state, soc_data->suspend_io_config,\r\nsizeof(*suspend_info->io_state) * soc_data->suspend_io_count);\r\nsuspend_info->m4if_base = ioremap(soc_data->m4if_addr, SZ_16K);\r\nif (!suspend_info->m4if_base) {\r\nret = -ENOMEM;\r\ngoto failed_map_m4if;\r\n}\r\nsuspend_info->iomuxc_base = ioremap(soc_data->iomuxc_addr, SZ_16K);\r\nif (!suspend_info->iomuxc_base) {\r\nret = -ENOMEM;\r\ngoto failed_map_iomuxc;\r\n}\r\nimx5_suspend_in_ocram_fn = fncpy(\r\nsuspend_ocram_base + sizeof(*suspend_info),\r\nsuspend_asm,\r\n*soc_data->suspend_asm_sz);\r\nreturn 0;\r\nfailed_map_iomuxc:\r\niounmap(suspend_info->m4if_base);\r\nfailed_map_m4if:\r\nreturn ret;\r\n}\r\nstatic int __init imx5_pm_common_init(const struct imx5_pm_data *data)\r\n{\r\nint ret;\r\nstruct clk *gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs");\r\nif (IS_ERR(gpc_dvfs_clk))\r\nreturn PTR_ERR(gpc_dvfs_clk);\r\nret = clk_prepare_enable(gpc_dvfs_clk);\r\nif (ret)\r\nreturn ret;\r\narm_pm_idle = imx5_pm_idle;\r\nccm_base = ioremap(data->ccm_addr, SZ_16K);\r\ncortex_base = ioremap(data->cortex_addr, SZ_16K);\r\ngpc_base = ioremap(data->gpc_addr, SZ_16K);\r\nWARN_ON(!ccm_base || !cortex_base || !gpc_base);\r\nmx5_cpu_lp_set(IMX5_DEFAULT_CPU_IDLE_STATE);\r\nret = imx5_cpuidle_init();\r\nif (ret)\r\npr_warn("%s: cpuidle init failed %d\n", __func__, ret);\r\nret = imx5_suspend_init(data);\r\nif (ret)\r\npr_warn("%s: No DDR LPM support with suspend %d!\n",\r\n__func__, ret);\r\nsuspend_set_ops(&mx5_suspend_ops);\r\nreturn 0;\r\n}\r\nvoid __init imx51_pm_init(void)\r\n{\r\nif (IS_ENABLED(CONFIG_SOC_IMX51))\r\nimx5_pm_common_init(&imx51_pm_data);\r\n}\r\nvoid __init imx53_pm_init(void)\r\n{\r\nif (IS_ENABLED(CONFIG_SOC_IMX53))\r\nimx5_pm_common_init(&imx53_pm_data);\r\n}
