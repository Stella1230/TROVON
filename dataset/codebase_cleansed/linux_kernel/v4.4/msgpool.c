static void *msgpool_alloc(gfp_t gfp_mask, void *arg)\r\n{\r\nstruct ceph_msgpool *pool = arg;\r\nstruct ceph_msg *msg;\r\nmsg = ceph_msg_new(pool->type, pool->front_len, gfp_mask, true);\r\nif (!msg) {\r\ndout("msgpool_alloc %s failed\n", pool->name);\r\n} else {\r\ndout("msgpool_alloc %s %p\n", pool->name, msg);\r\nmsg->pool = pool;\r\n}\r\nreturn msg;\r\n}\r\nstatic void msgpool_free(void *element, void *arg)\r\n{\r\nstruct ceph_msgpool *pool = arg;\r\nstruct ceph_msg *msg = element;\r\ndout("msgpool_release %s %p\n", pool->name, msg);\r\nmsg->pool = NULL;\r\nceph_msg_put(msg);\r\n}\r\nint ceph_msgpool_init(struct ceph_msgpool *pool, int type,\r\nint front_len, int size, bool blocking, const char *name)\r\n{\r\ndout("msgpool %s init\n", name);\r\npool->type = type;\r\npool->front_len = front_len;\r\npool->pool = mempool_create(size, msgpool_alloc, msgpool_free, pool);\r\nif (!pool->pool)\r\nreturn -ENOMEM;\r\npool->name = name;\r\nreturn 0;\r\n}\r\nvoid ceph_msgpool_destroy(struct ceph_msgpool *pool)\r\n{\r\ndout("msgpool %s destroy\n", pool->name);\r\nmempool_destroy(pool->pool);\r\n}\r\nstruct ceph_msg *ceph_msgpool_get(struct ceph_msgpool *pool,\r\nint front_len)\r\n{\r\nstruct ceph_msg *msg;\r\nif (front_len > pool->front_len) {\r\ndout("msgpool_get %s need front %d, pool size is %d\n",\r\npool->name, front_len, pool->front_len);\r\nWARN_ON(1);\r\nreturn ceph_msg_new(pool->type, front_len, GFP_NOFS, false);\r\n}\r\nmsg = mempool_alloc(pool->pool, GFP_NOFS);\r\ndout("msgpool_get %s %p\n", pool->name, msg);\r\nreturn msg;\r\n}\r\nvoid ceph_msgpool_put(struct ceph_msgpool *pool, struct ceph_msg *msg)\r\n{\r\ndout("msgpool_put %s %p\n", pool->name, msg);\r\nmsg->front.iov_len = pool->front_len;\r\nmsg->hdr.front_len = cpu_to_le32(pool->front_len);\r\nkref_init(&msg->kref);\r\nmempool_free(msg, pool->pool);\r\n}
