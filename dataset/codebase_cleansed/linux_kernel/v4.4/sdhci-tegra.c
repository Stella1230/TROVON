static u16 tegra_sdhci_readw(struct sdhci_host *host, int reg)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_tegra *tegra_host = pltfm_host->priv;\r\nconst struct sdhci_tegra_soc_data *soc_data = tegra_host->soc_data;\r\nif (unlikely((soc_data->nvquirks & NVQUIRK_FORCE_SDHCI_SPEC_200) &&\r\n(reg == SDHCI_HOST_VERSION))) {\r\nreturn SDHCI_SPEC_200;\r\n}\r\nreturn readw(host->ioaddr + reg);\r\n}\r\nstatic void tegra_sdhci_writew(struct sdhci_host *host, u16 val, int reg)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nswitch (reg) {\r\ncase SDHCI_TRANSFER_MODE:\r\npltfm_host->xfer_mode_shadow = val;\r\nreturn;\r\ncase SDHCI_COMMAND:\r\nwritel((val << 16) | pltfm_host->xfer_mode_shadow,\r\nhost->ioaddr + SDHCI_TRANSFER_MODE);\r\nreturn;\r\n}\r\nwritew(val, host->ioaddr + reg);\r\n}\r\nstatic void tegra_sdhci_writel(struct sdhci_host *host, u32 val, int reg)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_tegra *tegra_host = pltfm_host->priv;\r\nconst struct sdhci_tegra_soc_data *soc_data = tegra_host->soc_data;\r\nif (unlikely(reg == SDHCI_SIGNAL_ENABLE))\r\nval &= ~(SDHCI_INT_TIMEOUT|SDHCI_INT_CRC);\r\nwritel(val, host->ioaddr + reg);\r\nif (unlikely((soc_data->nvquirks & NVQUIRK_ENABLE_BLOCK_GAP_DET) &&\r\n(reg == SDHCI_INT_ENABLE))) {\r\nu8 gap_ctrl = readb(host->ioaddr + SDHCI_BLOCK_GAP_CONTROL);\r\nif (val & SDHCI_INT_CARD_INT)\r\ngap_ctrl |= 0x8;\r\nelse\r\ngap_ctrl &= ~0x8;\r\nwriteb(gap_ctrl, host->ioaddr + SDHCI_BLOCK_GAP_CONTROL);\r\n}\r\n}\r\nstatic unsigned int tegra_sdhci_get_ro(struct sdhci_host *host)\r\n{\r\nreturn mmc_gpio_get_ro(host->mmc);\r\n}\r\nstatic void tegra_sdhci_reset(struct sdhci_host *host, u8 mask)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_tegra *tegra_host = pltfm_host->priv;\r\nconst struct sdhci_tegra_soc_data *soc_data = tegra_host->soc_data;\r\nu32 misc_ctrl;\r\nsdhci_reset(host, mask);\r\nif (!(mask & SDHCI_RESET_ALL))\r\nreturn;\r\nmisc_ctrl = sdhci_readw(host, SDHCI_TEGRA_VENDOR_MISC_CTRL);\r\nif (soc_data->nvquirks & NVQUIRK_ENABLE_SDHCI_SPEC_300)\r\nmisc_ctrl |= SDHCI_MISC_CTRL_ENABLE_SDHCI_SPEC_300;\r\nif (soc_data->nvquirks & NVQUIRK_DISABLE_SDR50)\r\nmisc_ctrl &= ~SDHCI_MISC_CTRL_ENABLE_SDR50;\r\nif (soc_data->nvquirks & NVQUIRK_DISABLE_DDR50)\r\nmisc_ctrl &= ~SDHCI_MISC_CTRL_ENABLE_DDR50;\r\nif (soc_data->nvquirks & NVQUIRK_DISABLE_SDR104)\r\nmisc_ctrl &= ~SDHCI_MISC_CTRL_ENABLE_SDR104;\r\nsdhci_writew(host, misc_ctrl, SDHCI_TEGRA_VENDOR_MISC_CTRL);\r\n}\r\nstatic void tegra_sdhci_set_bus_width(struct sdhci_host *host, int bus_width)\r\n{\r\nu32 ctrl;\r\nctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);\r\nif ((host->mmc->caps & MMC_CAP_8_BIT_DATA) &&\r\n(bus_width == MMC_BUS_WIDTH_8)) {\r\nctrl &= ~SDHCI_CTRL_4BITBUS;\r\nctrl |= SDHCI_CTRL_8BITBUS;\r\n} else {\r\nctrl &= ~SDHCI_CTRL_8BITBUS;\r\nif (bus_width == MMC_BUS_WIDTH_4)\r\nctrl |= SDHCI_CTRL_4BITBUS;\r\nelse\r\nctrl &= ~SDHCI_CTRL_4BITBUS;\r\n}\r\nsdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);\r\n}\r\nstatic int sdhci_tegra_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nconst struct sdhci_tegra_soc_data *soc_data;\r\nstruct sdhci_host *host;\r\nstruct sdhci_pltfm_host *pltfm_host;\r\nstruct sdhci_tegra *tegra_host;\r\nstruct clk *clk;\r\nint rc;\r\nmatch = of_match_device(sdhci_tegra_dt_match, &pdev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nsoc_data = match->data;\r\nhost = sdhci_pltfm_init(pdev, soc_data->pdata, 0);\r\nif (IS_ERR(host))\r\nreturn PTR_ERR(host);\r\npltfm_host = sdhci_priv(host);\r\ntegra_host = devm_kzalloc(&pdev->dev, sizeof(*tegra_host), GFP_KERNEL);\r\nif (!tegra_host) {\r\ndev_err(mmc_dev(host->mmc), "failed to allocate tegra_host\n");\r\nrc = -ENOMEM;\r\ngoto err_alloc_tegra_host;\r\n}\r\ntegra_host->soc_data = soc_data;\r\npltfm_host->priv = tegra_host;\r\nrc = mmc_of_parse(host->mmc);\r\nif (rc)\r\ngoto err_parse_dt;\r\ntegra_host->power_gpio = devm_gpiod_get_optional(&pdev->dev, "power",\r\nGPIOD_OUT_HIGH);\r\nif (IS_ERR(tegra_host->power_gpio)) {\r\nrc = PTR_ERR(tegra_host->power_gpio);\r\ngoto err_power_req;\r\n}\r\nclk = devm_clk_get(mmc_dev(host->mmc), NULL);\r\nif (IS_ERR(clk)) {\r\ndev_err(mmc_dev(host->mmc), "clk err\n");\r\nrc = PTR_ERR(clk);\r\ngoto err_clk_get;\r\n}\r\nclk_prepare_enable(clk);\r\npltfm_host->clk = clk;\r\nrc = sdhci_add_host(host);\r\nif (rc)\r\ngoto err_add_host;\r\nreturn 0;\r\nerr_add_host:\r\nclk_disable_unprepare(pltfm_host->clk);\r\nerr_clk_get:\r\nerr_power_req:\r\nerr_parse_dt:\r\nerr_alloc_tegra_host:\r\nsdhci_pltfm_free(pdev);\r\nreturn rc;\r\n}
