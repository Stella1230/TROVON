static unsigned short zf_readw(unsigned char port)\r\n{\r\noutb(port, INDEX);\r\nreturn inw(DATA_W);\r\n}\r\nstatic inline void zf_set_status(unsigned char new)\r\n{\r\nzf_writeb(STATUS, new);\r\n}\r\nstatic inline unsigned short zf_get_control(void)\r\n{\r\nreturn zf_readw(CONTROL);\r\n}\r\nstatic inline void zf_set_control(unsigned short new)\r\n{\r\nzf_writew(CONTROL, new);\r\n}\r\nstatic inline void zf_set_timer(unsigned short new, unsigned char n)\r\n{\r\nswitch (n) {\r\ncase WD1:\r\nzf_writew(COUNTER_1, new);\r\ncase WD2:\r\nzf_writeb(COUNTER_2, new > 0xff ? 0xff : new);\r\ndefault:\r\nreturn;\r\n}\r\n}\r\nstatic void zf_timer_off(void)\r\n{\r\nunsigned int ctrl_reg = 0;\r\nunsigned long flags;\r\ndel_timer_sync(&zf_timer);\r\nspin_lock_irqsave(&zf_port_lock, flags);\r\nctrl_reg = zf_get_control();\r\nctrl_reg |= (ENABLE_WD1|ENABLE_WD2);\r\nctrl_reg &= ~(ENABLE_WD1|ENABLE_WD2);\r\nzf_set_control(ctrl_reg);\r\nspin_unlock_irqrestore(&zf_port_lock, flags);\r\npr_info("Watchdog timer is now disabled\n");\r\n}\r\nstatic void zf_timer_on(void)\r\n{\r\nunsigned int ctrl_reg = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&zf_port_lock, flags);\r\nzf_writeb(PULSE_LEN, 0xff);\r\nzf_set_timer(ZF_CTIMEOUT, WD1);\r\nnext_heartbeat = jiffies + ZF_USER_TIMEO;\r\nmod_timer(&zf_timer, jiffies + ZF_HW_TIMEO);\r\nctrl_reg = zf_get_control();\r\nctrl_reg |= (ENABLE_WD1|zf_action);\r\nzf_set_control(ctrl_reg);\r\nspin_unlock_irqrestore(&zf_port_lock, flags);\r\npr_info("Watchdog timer is now enabled\n");\r\n}\r\nstatic void zf_ping(unsigned long data)\r\n{\r\nunsigned int ctrl_reg = 0;\r\nunsigned long flags;\r\nzf_writeb(COUNTER_2, 0xff);\r\nif (time_before(jiffies, next_heartbeat)) {\r\ndprintk("time_before: %ld\n", next_heartbeat - jiffies);\r\nspin_lock_irqsave(&zf_port_lock, flags);\r\nctrl_reg = zf_get_control();\r\nctrl_reg |= RESET_WD1;\r\nzf_set_control(ctrl_reg);\r\nctrl_reg &= ~(RESET_WD1);\r\nzf_set_control(ctrl_reg);\r\nspin_unlock_irqrestore(&zf_port_lock, flags);\r\nmod_timer(&zf_timer, jiffies + ZF_HW_TIMEO);\r\n} else\r\npr_crit("I will reset your machine\n");\r\n}\r\nstatic ssize_t zf_write(struct file *file, const char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nif (count) {\r\nif (!nowayout) {\r\nsize_t ofs;\r\nzf_expect_close = 0;\r\nfor (ofs = 0; ofs != count; ofs++) {\r\nchar c;\r\nif (get_user(c, buf + ofs))\r\nreturn -EFAULT;\r\nif (c == 'V') {\r\nzf_expect_close = 42;\r\ndprintk("zf_expect_close = 42\n");\r\n}\r\n}\r\n}\r\nnext_heartbeat = jiffies + ZF_USER_TIMEO;\r\ndprintk("user ping at %ld\n", jiffies);\r\n}\r\nreturn count;\r\n}\r\nstatic long zf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nif (copy_to_user(argp, &zf_info, sizeof(zf_info)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_KEEPALIVE:\r\nzf_ping(0);\r\nbreak;\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zf_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &zf_is_open))\r\nreturn -EBUSY;\r\nif (nowayout)\r\n__module_get(THIS_MODULE);\r\nzf_timer_on();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int zf_close(struct inode *inode, struct file *file)\r\n{\r\nif (zf_expect_close == 42)\r\nzf_timer_off();\r\nelse {\r\ndel_timer(&zf_timer);\r\npr_err("device file closed unexpectedly. Will not stop the WDT!\n");\r\n}\r\nclear_bit(0, &zf_is_open);\r\nzf_expect_close = 0;\r\nreturn 0;\r\n}\r\nstatic int zf_notify_sys(struct notifier_block *this, unsigned long code,\r\nvoid *unused)\r\n{\r\nif (code == SYS_DOWN || code == SYS_HALT)\r\nzf_timer_off();\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void __init zf_show_action(int act)\r\n{\r\nstatic const char * const str[] = { "RESET", "SMI", "NMI", "SCI" };\r\npr_info("Watchdog using action = %s\n", str[act]);\r\n}\r\nstatic int __init zf_init(void)\r\n{\r\nint ret;\r\npr_info("MachZ ZF-Logic Watchdog driver initializing\n");\r\nret = zf_get_ZFL_version();\r\nif (!ret || ret == 0xffff) {\r\npr_warn("no ZF-Logic found\n");\r\nreturn -ENODEV;\r\n}\r\nif (action <= 3 && action >= 0)\r\nzf_action = zf_action >> action;\r\nelse\r\naction = 0;\r\nzf_show_action(action);\r\nif (!request_region(ZF_IOBASE, 3, "MachZ ZFL WDT")) {\r\npr_err("cannot reserve I/O ports at %d\n", ZF_IOBASE);\r\nret = -EBUSY;\r\ngoto no_region;\r\n}\r\nret = register_reboot_notifier(&zf_notifier);\r\nif (ret) {\r\npr_err("can't register reboot notifier (err=%d)\n", ret);\r\ngoto no_reboot;\r\n}\r\nret = misc_register(&zf_miscdev);\r\nif (ret) {\r\npr_err("can't misc_register on minor=%d\n", WATCHDOG_MINOR);\r\ngoto no_misc;\r\n}\r\nzf_set_status(0);\r\nzf_set_control(0);\r\nreturn 0;\r\nno_misc:\r\nunregister_reboot_notifier(&zf_notifier);\r\nno_reboot:\r\nrelease_region(ZF_IOBASE, 3);\r\nno_region:\r\nreturn ret;\r\n}\r\nstatic void __exit zf_exit(void)\r\n{\r\nzf_timer_off();\r\nmisc_deregister(&zf_miscdev);\r\nunregister_reboot_notifier(&zf_notifier);\r\nrelease_region(ZF_IOBASE, 3);\r\n}
