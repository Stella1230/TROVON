static __be32\r\ncheck_filename(char *str, int len)\r\n{\r\nint i;\r\nif (len == 0)\r\nreturn nfserr_inval;\r\nif (isdotent(str, len))\r\nreturn nfserr_badname;\r\nfor (i = 0; i < len; i++)\r\nif (str[i] == '/')\r\nreturn nfserr_badname;\r\nreturn 0;\r\n}\r\nstatic void next_decode_page(struct nfsd4_compoundargs *argp)\r\n{\r\nargp->p = page_address(argp->pagelist[0]);\r\nargp->pagelist++;\r\nif (argp->pagelen < PAGE_SIZE) {\r\nargp->end = argp->p + (argp->pagelen>>2);\r\nargp->pagelen = 0;\r\n} else {\r\nargp->end = argp->p + (PAGE_SIZE>>2);\r\nargp->pagelen -= PAGE_SIZE;\r\n}\r\n}\r\nstatic __be32 *read_buf(struct nfsd4_compoundargs *argp, u32 nbytes)\r\n{\r\nunsigned int avail = (char *)argp->end - (char *)argp->p;\r\n__be32 *p;\r\nif (avail + argp->pagelen < nbytes)\r\nreturn NULL;\r\nif (avail + PAGE_SIZE < nbytes)\r\nreturn NULL;\r\nif (nbytes <= sizeof(argp->tmp))\r\np = argp->tmp;\r\nelse {\r\nkfree(argp->tmpp);\r\np = argp->tmpp = kmalloc(nbytes, GFP_KERNEL);\r\nif (!p)\r\nreturn NULL;\r\n}\r\nmemcpy(p, argp->p, avail);\r\nnext_decode_page(argp);\r\nmemcpy(((char*)p)+avail, argp->p, (nbytes - avail));\r\nargp->p += XDR_QUADLEN(nbytes - avail);\r\nreturn p;\r\n}\r\nstatic int zero_clientid(clientid_t *clid)\r\n{\r\nreturn (clid->cl_boot == 0) && (clid->cl_id == 0);\r\n}\r\nstatic void *\r\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\r\n{\r\nstruct svcxdr_tmpbuf *tb;\r\ntb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\r\nif (!tb)\r\nreturn NULL;\r\ntb->next = argp->to_free;\r\nargp->to_free = tb;\r\nreturn tb->buf;\r\n}\r\nstatic char *\r\nsvcxdr_dupstr(struct nfsd4_compoundargs *argp, void *buf, u32 len)\r\n{\r\nchar *p = svcxdr_tmpalloc(argp, len + 1);\r\nif (!p)\r\nreturn NULL;\r\nmemcpy(p, buf, len);\r\np[len] = '\0';\r\nreturn p;\r\n}\r\nstatic char *savemem(struct nfsd4_compoundargs *argp, __be32 *p, int nbytes)\r\n{\r\nvoid *ret;\r\nret = svcxdr_tmpalloc(argp, nbytes);\r\nif (!ret)\r\nreturn NULL;\r\nmemcpy(ret, p, nbytes);\r\nreturn ret;\r\n}\r\nstatic __be32\r\nnfsd4_decode_time(struct nfsd4_compoundargs *argp, struct timespec *tv)\r\n{\r\nDECODE_HEAD;\r\nu64 sec;\r\nREAD_BUF(12);\r\np = xdr_decode_hyper(p, &sec);\r\ntv->tv_sec = sec;\r\ntv->tv_nsec = be32_to_cpup(p++);\r\nif (tv->tv_nsec >= (u32)1000000000)\r\nreturn nfserr_inval;\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\r\n{\r\nu32 bmlen;\r\nDECODE_HEAD;\r\nbmval[0] = 0;\r\nbmval[1] = 0;\r\nbmval[2] = 0;\r\nREAD_BUF(4);\r\nbmlen = be32_to_cpup(p++);\r\nif (bmlen > 1000)\r\ngoto xdr_error;\r\nREAD_BUF(bmlen << 2);\r\nif (bmlen > 0)\r\nbmval[0] = be32_to_cpup(p++);\r\nif (bmlen > 1)\r\nbmval[1] = be32_to_cpup(p++);\r\nif (bmlen > 2)\r\nbmval[2] = be32_to_cpup(p++);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,\r\nstruct iattr *iattr, struct nfs4_acl **acl,\r\nstruct xdr_netobj *label)\r\n{\r\nint expected_len, len = 0;\r\nu32 dummy32;\r\nchar *buf;\r\nDECODE_HEAD;\r\niattr->ia_valid = 0;\r\nif ((status = nfsd4_decode_bitmap(argp, bmval)))\r\nreturn status;\r\nREAD_BUF(4);\r\nexpected_len = be32_to_cpup(p++);\r\nif (bmval[0] & FATTR4_WORD0_SIZE) {\r\nREAD_BUF(8);\r\nlen += 8;\r\np = xdr_decode_hyper(p, &iattr->ia_size);\r\niattr->ia_valid |= ATTR_SIZE;\r\n}\r\nif (bmval[0] & FATTR4_WORD0_ACL) {\r\nu32 nace;\r\nstruct nfs4_ace *ace;\r\nREAD_BUF(4); len += 4;\r\nnace = be32_to_cpup(p++);\r\nif (nace > NFS4_ACL_MAX)\r\nreturn nfserr_fbig;\r\n*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(nace));\r\nif (*acl == NULL)\r\nreturn nfserr_jukebox;\r\n(*acl)->naces = nace;\r\nfor (ace = (*acl)->aces; ace < (*acl)->aces + nace; ace++) {\r\nREAD_BUF(16); len += 16;\r\nace->type = be32_to_cpup(p++);\r\nace->flag = be32_to_cpup(p++);\r\nace->access_mask = be32_to_cpup(p++);\r\ndummy32 = be32_to_cpup(p++);\r\nREAD_BUF(dummy32);\r\nlen += XDR_QUADLEN(dummy32) << 2;\r\nREADMEM(buf, dummy32);\r\nace->whotype = nfs4_acl_get_whotype(buf, dummy32);\r\nstatus = nfs_ok;\r\nif (ace->whotype != NFS4_ACL_WHO_NAMED)\r\n;\r\nelse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\r\nstatus = nfsd_map_name_to_gid(argp->rqstp,\r\nbuf, dummy32, &ace->who_gid);\r\nelse\r\nstatus = nfsd_map_name_to_uid(argp->rqstp,\r\nbuf, dummy32, &ace->who_uid);\r\nif (status)\r\nreturn status;\r\n}\r\n} else\r\n*acl = NULL;\r\nif (bmval[1] & FATTR4_WORD1_MODE) {\r\nREAD_BUF(4);\r\nlen += 4;\r\niattr->ia_mode = be32_to_cpup(p++);\r\niattr->ia_mode &= (S_IFMT | S_IALLUGO);\r\niattr->ia_valid |= ATTR_MODE;\r\n}\r\nif (bmval[1] & FATTR4_WORD1_OWNER) {\r\nREAD_BUF(4);\r\nlen += 4;\r\ndummy32 = be32_to_cpup(p++);\r\nREAD_BUF(dummy32);\r\nlen += (XDR_QUADLEN(dummy32) << 2);\r\nREADMEM(buf, dummy32);\r\nif ((status = nfsd_map_name_to_uid(argp->rqstp, buf, dummy32, &iattr->ia_uid)))\r\nreturn status;\r\niattr->ia_valid |= ATTR_UID;\r\n}\r\nif (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {\r\nREAD_BUF(4);\r\nlen += 4;\r\ndummy32 = be32_to_cpup(p++);\r\nREAD_BUF(dummy32);\r\nlen += (XDR_QUADLEN(dummy32) << 2);\r\nREADMEM(buf, dummy32);\r\nif ((status = nfsd_map_name_to_gid(argp->rqstp, buf, dummy32, &iattr->ia_gid)))\r\nreturn status;\r\niattr->ia_valid |= ATTR_GID;\r\n}\r\nif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\r\nREAD_BUF(4);\r\nlen += 4;\r\ndummy32 = be32_to_cpup(p++);\r\nswitch (dummy32) {\r\ncase NFS4_SET_TO_CLIENT_TIME:\r\nlen += 12;\r\nstatus = nfsd4_decode_time(argp, &iattr->ia_atime);\r\nif (status)\r\nreturn status;\r\niattr->ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\r\nbreak;\r\ncase NFS4_SET_TO_SERVER_TIME:\r\niattr->ia_valid |= ATTR_ATIME;\r\nbreak;\r\ndefault:\r\ngoto xdr_error;\r\n}\r\n}\r\nif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\r\nREAD_BUF(4);\r\nlen += 4;\r\ndummy32 = be32_to_cpup(p++);\r\nswitch (dummy32) {\r\ncase NFS4_SET_TO_CLIENT_TIME:\r\nlen += 12;\r\nstatus = nfsd4_decode_time(argp, &iattr->ia_mtime);\r\nif (status)\r\nreturn status;\r\niattr->ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\r\nbreak;\r\ncase NFS4_SET_TO_SERVER_TIME:\r\niattr->ia_valid |= ATTR_MTIME;\r\nbreak;\r\ndefault:\r\ngoto xdr_error;\r\n}\r\n}\r\nlabel->len = 0;\r\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\r\nif (bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {\r\nREAD_BUF(4);\r\nlen += 4;\r\ndummy32 = be32_to_cpup(p++);\r\nREAD_BUF(4);\r\nlen += 4;\r\ndummy32 = be32_to_cpup(p++);\r\nREAD_BUF(4);\r\nlen += 4;\r\ndummy32 = be32_to_cpup(p++);\r\nREAD_BUF(dummy32);\r\nif (dummy32 > NFS4_MAXLABELLEN)\r\nreturn nfserr_badlabel;\r\nlen += (XDR_QUADLEN(dummy32) << 2);\r\nREADMEM(buf, dummy32);\r\nlabel->len = dummy32;\r\nlabel->data = svcxdr_dupstr(argp, buf, dummy32);\r\nif (!label->data)\r\nreturn nfserr_jukebox;\r\n}\r\n#endif\r\nif (bmval[0] & ~NFSD_WRITEABLE_ATTRS_WORD0\r\n|| bmval[1] & ~NFSD_WRITEABLE_ATTRS_WORD1\r\n|| bmval[2] & ~NFSD_WRITEABLE_ATTRS_WORD2)\r\nREAD_BUF(expected_len - len);\r\nelse if (len != expected_len)\r\ngoto xdr_error;\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(sizeof(stateid_t));\r\nsid->si_generation = be32_to_cpup(p++);\r\nCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_access(struct nfsd4_compoundargs *argp, struct nfsd4_access *access)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(4);\r\naccess->ac_req_access = be32_to_cpup(p++);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32 nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)\r\n{\r\nDECODE_HEAD;\r\nu32 dummy, uid, gid;\r\nchar *machine_name;\r\nint i;\r\nint nr_secflavs;\r\nREAD_BUF(4);\r\nnr_secflavs = be32_to_cpup(p++);\r\nif (nr_secflavs)\r\ncbs->flavor = (u32)(-1);\r\nelse\r\ncbs->flavor = 0;\r\nfor (i = 0; i < nr_secflavs; ++i) {\r\nREAD_BUF(4);\r\ndummy = be32_to_cpup(p++);\r\nswitch (dummy) {\r\ncase RPC_AUTH_NULL:\r\nif (cbs->flavor == (u32)(-1))\r\ncbs->flavor = RPC_AUTH_NULL;\r\nbreak;\r\ncase RPC_AUTH_UNIX:\r\nREAD_BUF(8);\r\ndummy = be32_to_cpup(p++);\r\ndummy = be32_to_cpup(p++);\r\nREAD_BUF(dummy);\r\nSAVEMEM(machine_name, dummy);\r\nREAD_BUF(8);\r\nuid = be32_to_cpup(p++);\r\ngid = be32_to_cpup(p++);\r\nREAD_BUF(4);\r\ndummy = be32_to_cpup(p++);\r\nREAD_BUF(dummy * 4);\r\nif (cbs->flavor == (u32)(-1)) {\r\nkuid_t kuid = make_kuid(&init_user_ns, uid);\r\nkgid_t kgid = make_kgid(&init_user_ns, gid);\r\nif (uid_valid(kuid) && gid_valid(kgid)) {\r\ncbs->uid = kuid;\r\ncbs->gid = kgid;\r\ncbs->flavor = RPC_AUTH_UNIX;\r\n} else {\r\ndprintk("RPC_AUTH_UNIX with invalid"\r\n"uid or gid ignoring!\n");\r\n}\r\n}\r\nbreak;\r\ncase RPC_AUTH_GSS:\r\ndprintk("RPC_AUTH_GSS callback secflavor "\r\n"not supported!\n");\r\nREAD_BUF(8);\r\ndummy = be32_to_cpup(p++);\r\ndummy = be32_to_cpup(p++);\r\nREAD_BUF(dummy);\r\np += XDR_QUADLEN(dummy);\r\nREAD_BUF(4);\r\ndummy = be32_to_cpup(p++);\r\nREAD_BUF(dummy);\r\nbreak;\r\ndefault:\r\ndprintk("Illegal callback secflavor\n");\r\nreturn nfserr_inval;\r\n}\r\n}\r\nDECODE_TAIL;\r\n}\r\nstatic __be32 nfsd4_decode_backchannel_ctl(struct nfsd4_compoundargs *argp, struct nfsd4_backchannel_ctl *bc)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(4);\r\nbc->bc_cb_program = be32_to_cpup(p++);\r\nnfsd4_decode_cb_sec(argp, &bc->bc_cb_sec);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32 nfsd4_decode_bind_conn_to_session(struct nfsd4_compoundargs *argp, struct nfsd4_bind_conn_to_session *bcts)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(NFS4_MAX_SESSIONID_LEN + 8);\r\nCOPYMEM(bcts->sessionid.data, NFS4_MAX_SESSIONID_LEN);\r\nbcts->dir = be32_to_cpup(p++);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_close(struct nfsd4_compoundargs *argp, struct nfsd4_close *close)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(4);\r\nclose->cl_seqid = be32_to_cpup(p++);\r\nreturn nfsd4_decode_stateid(argp, &close->cl_stateid);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_commit(struct nfsd4_compoundargs *argp, struct nfsd4_commit *commit)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(12);\r\np = xdr_decode_hyper(p, &commit->co_offset);\r\ncommit->co_count = be32_to_cpup(p++);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_create(struct nfsd4_compoundargs *argp, struct nfsd4_create *create)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(4);\r\ncreate->cr_type = be32_to_cpup(p++);\r\nswitch (create->cr_type) {\r\ncase NF4LNK:\r\nREAD_BUF(4);\r\ncreate->cr_datalen = be32_to_cpup(p++);\r\nREAD_BUF(create->cr_datalen);\r\ncreate->cr_data = svcxdr_dupstr(argp, p, create->cr_datalen);\r\nif (!create->cr_data)\r\nreturn nfserr_jukebox;\r\nbreak;\r\ncase NF4BLK:\r\ncase NF4CHR:\r\nREAD_BUF(8);\r\ncreate->cr_specdata1 = be32_to_cpup(p++);\r\ncreate->cr_specdata2 = be32_to_cpup(p++);\r\nbreak;\r\ncase NF4SOCK:\r\ncase NF4FIFO:\r\ncase NF4DIR:\r\ndefault:\r\nbreak;\r\n}\r\nREAD_BUF(4);\r\ncreate->cr_namelen = be32_to_cpup(p++);\r\nREAD_BUF(create->cr_namelen);\r\nSAVEMEM(create->cr_name, create->cr_namelen);\r\nif ((status = check_filename(create->cr_name, create->cr_namelen)))\r\nreturn status;\r\nstatus = nfsd4_decode_fattr(argp, create->cr_bmval, &create->cr_iattr,\r\n&create->cr_acl, &create->cr_label);\r\nif (status)\r\ngoto out;\r\nDECODE_TAIL;\r\n}\r\nstatic inline __be32\r\nnfsd4_decode_delegreturn(struct nfsd4_compoundargs *argp, struct nfsd4_delegreturn *dr)\r\n{\r\nreturn nfsd4_decode_stateid(argp, &dr->dr_stateid);\r\n}\r\nstatic inline __be32\r\nnfsd4_decode_getattr(struct nfsd4_compoundargs *argp, struct nfsd4_getattr *getattr)\r\n{\r\nreturn nfsd4_decode_bitmap(argp, getattr->ga_bmval);\r\n}\r\nstatic __be32\r\nnfsd4_decode_link(struct nfsd4_compoundargs *argp, struct nfsd4_link *link)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(4);\r\nlink->li_namelen = be32_to_cpup(p++);\r\nREAD_BUF(link->li_namelen);\r\nSAVEMEM(link->li_name, link->li_namelen);\r\nif ((status = check_filename(link->li_name, link->li_namelen)))\r\nreturn status;\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_lock(struct nfsd4_compoundargs *argp, struct nfsd4_lock *lock)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(28);\r\nlock->lk_type = be32_to_cpup(p++);\r\nif ((lock->lk_type < NFS4_READ_LT) || (lock->lk_type > NFS4_WRITEW_LT))\r\ngoto xdr_error;\r\nlock->lk_reclaim = be32_to_cpup(p++);\r\np = xdr_decode_hyper(p, &lock->lk_offset);\r\np = xdr_decode_hyper(p, &lock->lk_length);\r\nlock->lk_is_new = be32_to_cpup(p++);\r\nif (lock->lk_is_new) {\r\nREAD_BUF(4);\r\nlock->lk_new_open_seqid = be32_to_cpup(p++);\r\nstatus = nfsd4_decode_stateid(argp, &lock->lk_new_open_stateid);\r\nif (status)\r\nreturn status;\r\nREAD_BUF(8 + sizeof(clientid_t));\r\nlock->lk_new_lock_seqid = be32_to_cpup(p++);\r\nCOPYMEM(&lock->lk_new_clientid, sizeof(clientid_t));\r\nlock->lk_new_owner.len = be32_to_cpup(p++);\r\nREAD_BUF(lock->lk_new_owner.len);\r\nREADMEM(lock->lk_new_owner.data, lock->lk_new_owner.len);\r\n} else {\r\nstatus = nfsd4_decode_stateid(argp, &lock->lk_old_lock_stateid);\r\nif (status)\r\nreturn status;\r\nREAD_BUF(4);\r\nlock->lk_old_lock_seqid = be32_to_cpup(p++);\r\n}\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_lockt(struct nfsd4_compoundargs *argp, struct nfsd4_lockt *lockt)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(32);\r\nlockt->lt_type = be32_to_cpup(p++);\r\nif((lockt->lt_type < NFS4_READ_LT) || (lockt->lt_type > NFS4_WRITEW_LT))\r\ngoto xdr_error;\r\np = xdr_decode_hyper(p, &lockt->lt_offset);\r\np = xdr_decode_hyper(p, &lockt->lt_length);\r\nCOPYMEM(&lockt->lt_clientid, 8);\r\nlockt->lt_owner.len = be32_to_cpup(p++);\r\nREAD_BUF(lockt->lt_owner.len);\r\nREADMEM(lockt->lt_owner.data, lockt->lt_owner.len);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_locku(struct nfsd4_compoundargs *argp, struct nfsd4_locku *locku)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(8);\r\nlocku->lu_type = be32_to_cpup(p++);\r\nif ((locku->lu_type < NFS4_READ_LT) || (locku->lu_type > NFS4_WRITEW_LT))\r\ngoto xdr_error;\r\nlocku->lu_seqid = be32_to_cpup(p++);\r\nstatus = nfsd4_decode_stateid(argp, &locku->lu_stateid);\r\nif (status)\r\nreturn status;\r\nREAD_BUF(16);\r\np = xdr_decode_hyper(p, &locku->lu_offset);\r\np = xdr_decode_hyper(p, &locku->lu_length);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_lookup(struct nfsd4_compoundargs *argp, struct nfsd4_lookup *lookup)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(4);\r\nlookup->lo_len = be32_to_cpup(p++);\r\nREAD_BUF(lookup->lo_len);\r\nSAVEMEM(lookup->lo_name, lookup->lo_len);\r\nif ((status = check_filename(lookup->lo_name, lookup->lo_len)))\r\nreturn status;\r\nDECODE_TAIL;\r\n}\r\nstatic __be32 nfsd4_decode_share_access(struct nfsd4_compoundargs *argp, u32 *share_access, u32 *deleg_want, u32 *deleg_when)\r\n{\r\n__be32 *p;\r\nu32 w;\r\nREAD_BUF(4);\r\nw = be32_to_cpup(p++);\r\n*share_access = w & NFS4_SHARE_ACCESS_MASK;\r\n*deleg_want = w & NFS4_SHARE_WANT_MASK;\r\nif (deleg_when)\r\n*deleg_when = w & NFS4_SHARE_WHEN_MASK;\r\nswitch (w & NFS4_SHARE_ACCESS_MASK) {\r\ncase NFS4_SHARE_ACCESS_READ:\r\ncase NFS4_SHARE_ACCESS_WRITE:\r\ncase NFS4_SHARE_ACCESS_BOTH:\r\nbreak;\r\ndefault:\r\nreturn nfserr_bad_xdr;\r\n}\r\nw &= ~NFS4_SHARE_ACCESS_MASK;\r\nif (!w)\r\nreturn nfs_ok;\r\nif (!argp->minorversion)\r\nreturn nfserr_bad_xdr;\r\nswitch (w & NFS4_SHARE_WANT_MASK) {\r\ncase NFS4_SHARE_WANT_NO_PREFERENCE:\r\ncase NFS4_SHARE_WANT_READ_DELEG:\r\ncase NFS4_SHARE_WANT_WRITE_DELEG:\r\ncase NFS4_SHARE_WANT_ANY_DELEG:\r\ncase NFS4_SHARE_WANT_NO_DELEG:\r\ncase NFS4_SHARE_WANT_CANCEL:\r\nbreak;\r\ndefault:\r\nreturn nfserr_bad_xdr;\r\n}\r\nw &= ~NFS4_SHARE_WANT_MASK;\r\nif (!w)\r\nreturn nfs_ok;\r\nif (!deleg_when)\r\nreturn nfserr_inval;\r\nswitch (w) {\r\ncase NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL:\r\ncase NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED:\r\ncase (NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL |\r\nNFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED):\r\nreturn nfs_ok;\r\n}\r\nxdr_error:\r\nreturn nfserr_bad_xdr;\r\n}\r\nstatic __be32 nfsd4_decode_share_deny(struct nfsd4_compoundargs *argp, u32 *x)\r\n{\r\n__be32 *p;\r\nREAD_BUF(4);\r\n*x = be32_to_cpup(p++);\r\nif (*x & ~NFS4_SHARE_DENY_BOTH)\r\nreturn nfserr_bad_xdr;\r\nreturn nfs_ok;\r\nxdr_error:\r\nreturn nfserr_bad_xdr;\r\n}\r\nstatic __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\r\n{\r\n__be32 *p;\r\nREAD_BUF(4);\r\no->len = be32_to_cpup(p++);\r\nif (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)\r\nreturn nfserr_bad_xdr;\r\nREAD_BUF(o->len);\r\nSAVEMEM(o->data, o->len);\r\nreturn nfs_ok;\r\nxdr_error:\r\nreturn nfserr_bad_xdr;\r\n}\r\nstatic __be32\r\nnfsd4_decode_open(struct nfsd4_compoundargs *argp, struct nfsd4_open *open)\r\n{\r\nDECODE_HEAD;\r\nu32 dummy;\r\nmemset(open->op_bmval, 0, sizeof(open->op_bmval));\r\nopen->op_iattr.ia_valid = 0;\r\nopen->op_openowner = NULL;\r\nopen->op_xdr_error = 0;\r\nREAD_BUF(4);\r\nopen->op_seqid = be32_to_cpup(p++);\r\nstatus = nfsd4_decode_share_access(argp, &open->op_share_access,\r\n&open->op_deleg_want, &dummy);\r\nif (status)\r\ngoto xdr_error;\r\nstatus = nfsd4_decode_share_deny(argp, &open->op_share_deny);\r\nif (status)\r\ngoto xdr_error;\r\nREAD_BUF(sizeof(clientid_t));\r\nCOPYMEM(&open->op_clientid, sizeof(clientid_t));\r\nstatus = nfsd4_decode_opaque(argp, &open->op_owner);\r\nif (status)\r\ngoto xdr_error;\r\nREAD_BUF(4);\r\nopen->op_create = be32_to_cpup(p++);\r\nswitch (open->op_create) {\r\ncase NFS4_OPEN_NOCREATE:\r\nbreak;\r\ncase NFS4_OPEN_CREATE:\r\nREAD_BUF(4);\r\nopen->op_createmode = be32_to_cpup(p++);\r\nswitch (open->op_createmode) {\r\ncase NFS4_CREATE_UNCHECKED:\r\ncase NFS4_CREATE_GUARDED:\r\nstatus = nfsd4_decode_fattr(argp, open->op_bmval,\r\n&open->op_iattr, &open->op_acl, &open->op_label);\r\nif (status)\r\ngoto out;\r\nbreak;\r\ncase NFS4_CREATE_EXCLUSIVE:\r\nREAD_BUF(NFS4_VERIFIER_SIZE);\r\nCOPYMEM(open->op_verf.data, NFS4_VERIFIER_SIZE);\r\nbreak;\r\ncase NFS4_CREATE_EXCLUSIVE4_1:\r\nif (argp->minorversion < 1)\r\ngoto xdr_error;\r\nREAD_BUF(NFS4_VERIFIER_SIZE);\r\nCOPYMEM(open->op_verf.data, NFS4_VERIFIER_SIZE);\r\nstatus = nfsd4_decode_fattr(argp, open->op_bmval,\r\n&open->op_iattr, &open->op_acl, &open->op_label);\r\nif (status)\r\ngoto out;\r\nbreak;\r\ndefault:\r\ngoto xdr_error;\r\n}\r\nbreak;\r\ndefault:\r\ngoto xdr_error;\r\n}\r\nREAD_BUF(4);\r\nopen->op_claim_type = be32_to_cpup(p++);\r\nswitch (open->op_claim_type) {\r\ncase NFS4_OPEN_CLAIM_NULL:\r\ncase NFS4_OPEN_CLAIM_DELEGATE_PREV:\r\nREAD_BUF(4);\r\nopen->op_fname.len = be32_to_cpup(p++);\r\nREAD_BUF(open->op_fname.len);\r\nSAVEMEM(open->op_fname.data, open->op_fname.len);\r\nif ((status = check_filename(open->op_fname.data, open->op_fname.len)))\r\nreturn status;\r\nbreak;\r\ncase NFS4_OPEN_CLAIM_PREVIOUS:\r\nREAD_BUF(4);\r\nopen->op_delegate_type = be32_to_cpup(p++);\r\nbreak;\r\ncase NFS4_OPEN_CLAIM_DELEGATE_CUR:\r\nstatus = nfsd4_decode_stateid(argp, &open->op_delegate_stateid);\r\nif (status)\r\nreturn status;\r\nREAD_BUF(4);\r\nopen->op_fname.len = be32_to_cpup(p++);\r\nREAD_BUF(open->op_fname.len);\r\nSAVEMEM(open->op_fname.data, open->op_fname.len);\r\nif ((status = check_filename(open->op_fname.data, open->op_fname.len)))\r\nreturn status;\r\nbreak;\r\ncase NFS4_OPEN_CLAIM_FH:\r\ncase NFS4_OPEN_CLAIM_DELEG_PREV_FH:\r\nif (argp->minorversion < 1)\r\ngoto xdr_error;\r\nbreak;\r\ncase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\r\nif (argp->minorversion < 1)\r\ngoto xdr_error;\r\nstatus = nfsd4_decode_stateid(argp, &open->op_delegate_stateid);\r\nif (status)\r\nreturn status;\r\nbreak;\r\ndefault:\r\ngoto xdr_error;\r\n}\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_open_confirm(struct nfsd4_compoundargs *argp, struct nfsd4_open_confirm *open_conf)\r\n{\r\nDECODE_HEAD;\r\nif (argp->minorversion >= 1)\r\nreturn nfserr_notsupp;\r\nstatus = nfsd4_decode_stateid(argp, &open_conf->oc_req_stateid);\r\nif (status)\r\nreturn status;\r\nREAD_BUF(4);\r\nopen_conf->oc_seqid = be32_to_cpup(p++);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_open_downgrade(struct nfsd4_compoundargs *argp, struct nfsd4_open_downgrade *open_down)\r\n{\r\nDECODE_HEAD;\r\nstatus = nfsd4_decode_stateid(argp, &open_down->od_stateid);\r\nif (status)\r\nreturn status;\r\nREAD_BUF(4);\r\nopen_down->od_seqid = be32_to_cpup(p++);\r\nstatus = nfsd4_decode_share_access(argp, &open_down->od_share_access,\r\n&open_down->od_deleg_want, NULL);\r\nif (status)\r\nreturn status;\r\nstatus = nfsd4_decode_share_deny(argp, &open_down->od_share_deny);\r\nif (status)\r\nreturn status;\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_putfh(struct nfsd4_compoundargs *argp, struct nfsd4_putfh *putfh)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(4);\r\nputfh->pf_fhlen = be32_to_cpup(p++);\r\nif (putfh->pf_fhlen > NFS4_FHSIZE)\r\ngoto xdr_error;\r\nREAD_BUF(putfh->pf_fhlen);\r\nSAVEMEM(putfh->pf_fhval, putfh->pf_fhlen);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_putpubfh(struct nfsd4_compoundargs *argp, void *p)\r\n{\r\nif (argp->minorversion == 0)\r\nreturn nfs_ok;\r\nreturn nfserr_notsupp;\r\n}\r\nstatic __be32\r\nnfsd4_decode_read(struct nfsd4_compoundargs *argp, struct nfsd4_read *read)\r\n{\r\nDECODE_HEAD;\r\nstatus = nfsd4_decode_stateid(argp, &read->rd_stateid);\r\nif (status)\r\nreturn status;\r\nREAD_BUF(12);\r\np = xdr_decode_hyper(p, &read->rd_offset);\r\nread->rd_length = be32_to_cpup(p++);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_readdir(struct nfsd4_compoundargs *argp, struct nfsd4_readdir *readdir)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(24);\r\np = xdr_decode_hyper(p, &readdir->rd_cookie);\r\nCOPYMEM(readdir->rd_verf.data, sizeof(readdir->rd_verf.data));\r\nreaddir->rd_dircount = be32_to_cpup(p++);\r\nreaddir->rd_maxcount = be32_to_cpup(p++);\r\nif ((status = nfsd4_decode_bitmap(argp, readdir->rd_bmval)))\r\ngoto out;\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_remove(struct nfsd4_compoundargs *argp, struct nfsd4_remove *remove)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(4);\r\nremove->rm_namelen = be32_to_cpup(p++);\r\nREAD_BUF(remove->rm_namelen);\r\nSAVEMEM(remove->rm_name, remove->rm_namelen);\r\nif ((status = check_filename(remove->rm_name, remove->rm_namelen)))\r\nreturn status;\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_rename(struct nfsd4_compoundargs *argp, struct nfsd4_rename *rename)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(4);\r\nrename->rn_snamelen = be32_to_cpup(p++);\r\nREAD_BUF(rename->rn_snamelen + 4);\r\nSAVEMEM(rename->rn_sname, rename->rn_snamelen);\r\nrename->rn_tnamelen = be32_to_cpup(p++);\r\nREAD_BUF(rename->rn_tnamelen);\r\nSAVEMEM(rename->rn_tname, rename->rn_tnamelen);\r\nif ((status = check_filename(rename->rn_sname, rename->rn_snamelen)))\r\nreturn status;\r\nif ((status = check_filename(rename->rn_tname, rename->rn_tnamelen)))\r\nreturn status;\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_renew(struct nfsd4_compoundargs *argp, clientid_t *clientid)\r\n{\r\nDECODE_HEAD;\r\nif (argp->minorversion >= 1)\r\nreturn nfserr_notsupp;\r\nREAD_BUF(sizeof(clientid_t));\r\nCOPYMEM(clientid, sizeof(clientid_t));\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_secinfo(struct nfsd4_compoundargs *argp,\r\nstruct nfsd4_secinfo *secinfo)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(4);\r\nsecinfo->si_namelen = be32_to_cpup(p++);\r\nREAD_BUF(secinfo->si_namelen);\r\nSAVEMEM(secinfo->si_name, secinfo->si_namelen);\r\nstatus = check_filename(secinfo->si_name, secinfo->si_namelen);\r\nif (status)\r\nreturn status;\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_secinfo_no_name(struct nfsd4_compoundargs *argp,\r\nstruct nfsd4_secinfo_no_name *sin)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(4);\r\nsin->sin_style = be32_to_cpup(p++);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_setattr(struct nfsd4_compoundargs *argp, struct nfsd4_setattr *setattr)\r\n{\r\n__be32 status;\r\nstatus = nfsd4_decode_stateid(argp, &setattr->sa_stateid);\r\nif (status)\r\nreturn status;\r\nreturn nfsd4_decode_fattr(argp, setattr->sa_bmval, &setattr->sa_iattr,\r\n&setattr->sa_acl, &setattr->sa_label);\r\n}\r\nstatic __be32\r\nnfsd4_decode_setclientid(struct nfsd4_compoundargs *argp, struct nfsd4_setclientid *setclientid)\r\n{\r\nDECODE_HEAD;\r\nif (argp->minorversion >= 1)\r\nreturn nfserr_notsupp;\r\nREAD_BUF(NFS4_VERIFIER_SIZE);\r\nCOPYMEM(setclientid->se_verf.data, NFS4_VERIFIER_SIZE);\r\nstatus = nfsd4_decode_opaque(argp, &setclientid->se_name);\r\nif (status)\r\nreturn nfserr_bad_xdr;\r\nREAD_BUF(8);\r\nsetclientid->se_callback_prog = be32_to_cpup(p++);\r\nsetclientid->se_callback_netid_len = be32_to_cpup(p++);\r\nREAD_BUF(setclientid->se_callback_netid_len + 4);\r\nSAVEMEM(setclientid->se_callback_netid_val, setclientid->se_callback_netid_len);\r\nsetclientid->se_callback_addr_len = be32_to_cpup(p++);\r\nREAD_BUF(setclientid->se_callback_addr_len + 4);\r\nSAVEMEM(setclientid->se_callback_addr_val, setclientid->se_callback_addr_len);\r\nsetclientid->se_callback_ident = be32_to_cpup(p++);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_setclientid_confirm(struct nfsd4_compoundargs *argp, struct nfsd4_setclientid_confirm *scd_c)\r\n{\r\nDECODE_HEAD;\r\nif (argp->minorversion >= 1)\r\nreturn nfserr_notsupp;\r\nREAD_BUF(8 + NFS4_VERIFIER_SIZE);\r\nCOPYMEM(&scd_c->sc_clientid, 8);\r\nCOPYMEM(&scd_c->sc_confirm, NFS4_VERIFIER_SIZE);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_verify(struct nfsd4_compoundargs *argp, struct nfsd4_verify *verify)\r\n{\r\nDECODE_HEAD;\r\nif ((status = nfsd4_decode_bitmap(argp, verify->ve_bmval)))\r\ngoto out;\r\nREAD_BUF(4);\r\nverify->ve_attrlen = be32_to_cpup(p++);\r\nREAD_BUF(verify->ve_attrlen);\r\nSAVEMEM(verify->ve_attrval, verify->ve_attrlen);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_write(struct nfsd4_compoundargs *argp, struct nfsd4_write *write)\r\n{\r\nint avail;\r\nint len;\r\nDECODE_HEAD;\r\nstatus = nfsd4_decode_stateid(argp, &write->wr_stateid);\r\nif (status)\r\nreturn status;\r\nREAD_BUF(16);\r\np = xdr_decode_hyper(p, &write->wr_offset);\r\nwrite->wr_stable_how = be32_to_cpup(p++);\r\nif (write->wr_stable_how > 2)\r\ngoto xdr_error;\r\nwrite->wr_buflen = be32_to_cpup(p++);\r\navail = (char*)argp->end - (char*)argp->p;\r\nif (avail + argp->pagelen < write->wr_buflen) {\r\ndprintk("NFSD: xdr error (%s:%d)\n",\r\n__FILE__, __LINE__);\r\ngoto xdr_error;\r\n}\r\nwrite->wr_head.iov_base = p;\r\nwrite->wr_head.iov_len = avail;\r\nwrite->wr_pagelist = argp->pagelist;\r\nlen = XDR_QUADLEN(write->wr_buflen) << 2;\r\nif (len >= avail) {\r\nint pages;\r\nlen -= avail;\r\npages = len >> PAGE_SHIFT;\r\nargp->pagelist += pages;\r\nargp->pagelen -= pages * PAGE_SIZE;\r\nlen -= pages * PAGE_SIZE;\r\nargp->p = (__be32 *)page_address(argp->pagelist[0]);\r\nargp->pagelist++;\r\nargp->end = argp->p + XDR_QUADLEN(PAGE_SIZE);\r\n}\r\nargp->p += XDR_QUADLEN(len);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_release_lockowner(struct nfsd4_compoundargs *argp, struct nfsd4_release_lockowner *rlockowner)\r\n{\r\nDECODE_HEAD;\r\nif (argp->minorversion >= 1)\r\nreturn nfserr_notsupp;\r\nREAD_BUF(12);\r\nCOPYMEM(&rlockowner->rl_clientid, sizeof(clientid_t));\r\nrlockowner->rl_owner.len = be32_to_cpup(p++);\r\nREAD_BUF(rlockowner->rl_owner.len);\r\nREADMEM(rlockowner->rl_owner.data, rlockowner->rl_owner.len);\r\nif (argp->minorversion && !zero_clientid(&rlockowner->rl_clientid))\r\nreturn nfserr_inval;\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_exchange_id(struct nfsd4_compoundargs *argp,\r\nstruct nfsd4_exchange_id *exid)\r\n{\r\nint dummy, tmp;\r\nDECODE_HEAD;\r\nREAD_BUF(NFS4_VERIFIER_SIZE);\r\nCOPYMEM(exid->verifier.data, NFS4_VERIFIER_SIZE);\r\nstatus = nfsd4_decode_opaque(argp, &exid->clname);\r\nif (status)\r\nreturn nfserr_bad_xdr;\r\nREAD_BUF(4);\r\nexid->flags = be32_to_cpup(p++);\r\nREAD_BUF(4);\r\nexid->spa_how = be32_to_cpup(p++);\r\nswitch (exid->spa_how) {\r\ncase SP4_NONE:\r\nbreak;\r\ncase SP4_MACH_CRED:\r\nREAD_BUF(4);\r\ndummy = be32_to_cpup(p++);\r\nREAD_BUF(dummy * 4);\r\np += dummy;\r\nREAD_BUF(4);\r\ndummy = be32_to_cpup(p++);\r\nREAD_BUF(dummy * 4);\r\np += dummy;\r\nbreak;\r\ncase SP4_SSV:\r\nREAD_BUF(4);\r\ndummy = be32_to_cpup(p++);\r\nREAD_BUF(dummy * 4);\r\np += dummy;\r\nREAD_BUF(4);\r\ndummy = be32_to_cpup(p++);\r\nREAD_BUF(dummy * 4);\r\np += dummy;\r\nREAD_BUF(4);\r\ntmp = be32_to_cpup(p++);\r\nwhile (tmp--) {\r\nREAD_BUF(4);\r\ndummy = be32_to_cpup(p++);\r\nREAD_BUF(dummy);\r\np += XDR_QUADLEN(dummy);\r\n}\r\nREAD_BUF(4);\r\ntmp = be32_to_cpup(p++);\r\nwhile (tmp--) {\r\nREAD_BUF(4);\r\ndummy = be32_to_cpup(p++);\r\nREAD_BUF(dummy);\r\np += XDR_QUADLEN(dummy);\r\n}\r\nREAD_BUF(8);\r\ndummy = be32_to_cpup(p++);\r\ndummy = be32_to_cpup(p++);\r\nbreak;\r\ndefault:\r\ngoto xdr_error;\r\n}\r\nREAD_BUF(4);\r\ndummy = be32_to_cpup(p++);\r\nif (dummy > 1)\r\ngoto xdr_error;\r\nif (dummy == 1) {\r\nREAD_BUF(4);\r\ndummy = be32_to_cpup(p++);\r\nREAD_BUF(dummy);\r\np += XDR_QUADLEN(dummy);\r\nREAD_BUF(4);\r\ndummy = be32_to_cpup(p++);\r\nREAD_BUF(dummy);\r\np += XDR_QUADLEN(dummy);\r\nREAD_BUF(12);\r\np += 3;\r\n}\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_create_session(struct nfsd4_compoundargs *argp,\r\nstruct nfsd4_create_session *sess)\r\n{\r\nDECODE_HEAD;\r\nu32 dummy;\r\nREAD_BUF(16);\r\nCOPYMEM(&sess->clientid, 8);\r\nsess->seqid = be32_to_cpup(p++);\r\nsess->flags = be32_to_cpup(p++);\r\nREAD_BUF(28);\r\ndummy = be32_to_cpup(p++);\r\nsess->fore_channel.maxreq_sz = be32_to_cpup(p++);\r\nsess->fore_channel.maxresp_sz = be32_to_cpup(p++);\r\nsess->fore_channel.maxresp_cached = be32_to_cpup(p++);\r\nsess->fore_channel.maxops = be32_to_cpup(p++);\r\nsess->fore_channel.maxreqs = be32_to_cpup(p++);\r\nsess->fore_channel.nr_rdma_attrs = be32_to_cpup(p++);\r\nif (sess->fore_channel.nr_rdma_attrs == 1) {\r\nREAD_BUF(4);\r\nsess->fore_channel.rdma_attrs = be32_to_cpup(p++);\r\n} else if (sess->fore_channel.nr_rdma_attrs > 1) {\r\ndprintk("Too many fore channel attr bitmaps!\n");\r\ngoto xdr_error;\r\n}\r\nREAD_BUF(28);\r\ndummy = be32_to_cpup(p++);\r\nsess->back_channel.maxreq_sz = be32_to_cpup(p++);\r\nsess->back_channel.maxresp_sz = be32_to_cpup(p++);\r\nsess->back_channel.maxresp_cached = be32_to_cpup(p++);\r\nsess->back_channel.maxops = be32_to_cpup(p++);\r\nsess->back_channel.maxreqs = be32_to_cpup(p++);\r\nsess->back_channel.nr_rdma_attrs = be32_to_cpup(p++);\r\nif (sess->back_channel.nr_rdma_attrs == 1) {\r\nREAD_BUF(4);\r\nsess->back_channel.rdma_attrs = be32_to_cpup(p++);\r\n} else if (sess->back_channel.nr_rdma_attrs > 1) {\r\ndprintk("Too many back channel attr bitmaps!\n");\r\ngoto xdr_error;\r\n}\r\nREAD_BUF(4);\r\nsess->callback_prog = be32_to_cpup(p++);\r\nnfsd4_decode_cb_sec(argp, &sess->cb_sec);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_destroy_session(struct nfsd4_compoundargs *argp,\r\nstruct nfsd4_destroy_session *destroy_session)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(NFS4_MAX_SESSIONID_LEN);\r\nCOPYMEM(destroy_session->sessionid.data, NFS4_MAX_SESSIONID_LEN);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_free_stateid(struct nfsd4_compoundargs *argp,\r\nstruct nfsd4_free_stateid *free_stateid)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(sizeof(stateid_t));\r\nfree_stateid->fr_stateid.si_generation = be32_to_cpup(p++);\r\nCOPYMEM(&free_stateid->fr_stateid.si_opaque, sizeof(stateid_opaque_t));\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_sequence(struct nfsd4_compoundargs *argp,\r\nstruct nfsd4_sequence *seq)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(NFS4_MAX_SESSIONID_LEN + 16);\r\nCOPYMEM(seq->sessionid.data, NFS4_MAX_SESSIONID_LEN);\r\nseq->seqid = be32_to_cpup(p++);\r\nseq->slotid = be32_to_cpup(p++);\r\nseq->maxslots = be32_to_cpup(p++);\r\nseq->cachethis = be32_to_cpup(p++);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_test_stateid(struct nfsd4_compoundargs *argp, struct nfsd4_test_stateid *test_stateid)\r\n{\r\nint i;\r\n__be32 *p, status;\r\nstruct nfsd4_test_stateid_id *stateid;\r\nREAD_BUF(4);\r\ntest_stateid->ts_num_ids = ntohl(*p++);\r\nINIT_LIST_HEAD(&test_stateid->ts_stateid_list);\r\nfor (i = 0; i < test_stateid->ts_num_ids; i++) {\r\nstateid = svcxdr_tmpalloc(argp, sizeof(*stateid));\r\nif (!stateid) {\r\nstatus = nfserrno(-ENOMEM);\r\ngoto out;\r\n}\r\nINIT_LIST_HEAD(&stateid->ts_id_list);\r\nlist_add_tail(&stateid->ts_id_list, &test_stateid->ts_stateid_list);\r\nstatus = nfsd4_decode_stateid(argp, &stateid->ts_id_stateid);\r\nif (status)\r\ngoto out;\r\n}\r\nstatus = 0;\r\nout:\r\nreturn status;\r\nxdr_error:\r\ndprintk("NFSD: xdr error (%s:%d)\n", __FILE__, __LINE__);\r\nstatus = nfserr_bad_xdr;\r\ngoto out;\r\n}\r\nstatic __be32 nfsd4_decode_destroy_clientid(struct nfsd4_compoundargs *argp, struct nfsd4_destroy_clientid *dc)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(8);\r\nCOPYMEM(&dc->clientid, 8);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32 nfsd4_decode_reclaim_complete(struct nfsd4_compoundargs *argp, struct nfsd4_reclaim_complete *rc)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(4);\r\nrc->rca_one_fs = be32_to_cpup(p++);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_getdeviceinfo(struct nfsd4_compoundargs *argp,\r\nstruct nfsd4_getdeviceinfo *gdev)\r\n{\r\nDECODE_HEAD;\r\nu32 num, i;\r\nREAD_BUF(sizeof(struct nfsd4_deviceid) + 3 * 4);\r\nCOPYMEM(&gdev->gd_devid, sizeof(struct nfsd4_deviceid));\r\ngdev->gd_layout_type = be32_to_cpup(p++);\r\ngdev->gd_maxcount = be32_to_cpup(p++);\r\nnum = be32_to_cpup(p++);\r\nif (num) {\r\nREAD_BUF(4 * num);\r\ngdev->gd_notify_types = be32_to_cpup(p++);\r\nfor (i = 1; i < num; i++) {\r\nif (be32_to_cpup(p++)) {\r\nstatus = nfserr_inval;\r\ngoto out;\r\n}\r\n}\r\n}\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_layoutget(struct nfsd4_compoundargs *argp,\r\nstruct nfsd4_layoutget *lgp)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(36);\r\nlgp->lg_signal = be32_to_cpup(p++);\r\nlgp->lg_layout_type = be32_to_cpup(p++);\r\nlgp->lg_seg.iomode = be32_to_cpup(p++);\r\np = xdr_decode_hyper(p, &lgp->lg_seg.offset);\r\np = xdr_decode_hyper(p, &lgp->lg_seg.length);\r\np = xdr_decode_hyper(p, &lgp->lg_minlength);\r\nstatus = nfsd4_decode_stateid(argp, &lgp->lg_sid);\r\nif (status)\r\nreturn status;\r\nREAD_BUF(4);\r\nlgp->lg_maxcount = be32_to_cpup(p++);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_layoutcommit(struct nfsd4_compoundargs *argp,\r\nstruct nfsd4_layoutcommit *lcp)\r\n{\r\nDECODE_HEAD;\r\nu32 timechange;\r\nREAD_BUF(20);\r\np = xdr_decode_hyper(p, &lcp->lc_seg.offset);\r\np = xdr_decode_hyper(p, &lcp->lc_seg.length);\r\nlcp->lc_reclaim = be32_to_cpup(p++);\r\nstatus = nfsd4_decode_stateid(argp, &lcp->lc_sid);\r\nif (status)\r\nreturn status;\r\nREAD_BUF(4);\r\nlcp->lc_newoffset = be32_to_cpup(p++);\r\nif (lcp->lc_newoffset) {\r\nREAD_BUF(8);\r\np = xdr_decode_hyper(p, &lcp->lc_last_wr);\r\n} else\r\nlcp->lc_last_wr = 0;\r\nREAD_BUF(4);\r\ntimechange = be32_to_cpup(p++);\r\nif (timechange) {\r\nstatus = nfsd4_decode_time(argp, &lcp->lc_mtime);\r\nif (status)\r\nreturn status;\r\n} else {\r\nlcp->lc_mtime.tv_nsec = UTIME_NOW;\r\n}\r\nREAD_BUF(8);\r\nlcp->lc_layout_type = be32_to_cpup(p++);\r\nlcp->lc_up_len = be32_to_cpup(p++);\r\nif (lcp->lc_up_len > 0) {\r\nREAD_BUF(lcp->lc_up_len);\r\nREADMEM(lcp->lc_up_layout, lcp->lc_up_len);\r\n}\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_layoutreturn(struct nfsd4_compoundargs *argp,\r\nstruct nfsd4_layoutreturn *lrp)\r\n{\r\nDECODE_HEAD;\r\nREAD_BUF(16);\r\nlrp->lr_reclaim = be32_to_cpup(p++);\r\nlrp->lr_layout_type = be32_to_cpup(p++);\r\nlrp->lr_seg.iomode = be32_to_cpup(p++);\r\nlrp->lr_return_type = be32_to_cpup(p++);\r\nif (lrp->lr_return_type == RETURN_FILE) {\r\nREAD_BUF(16);\r\np = xdr_decode_hyper(p, &lrp->lr_seg.offset);\r\np = xdr_decode_hyper(p, &lrp->lr_seg.length);\r\nstatus = nfsd4_decode_stateid(argp, &lrp->lr_sid);\r\nif (status)\r\nreturn status;\r\nREAD_BUF(4);\r\nlrp->lrf_body_len = be32_to_cpup(p++);\r\nif (lrp->lrf_body_len > 0) {\r\nREAD_BUF(lrp->lrf_body_len);\r\nREADMEM(lrp->lrf_body, lrp->lrf_body_len);\r\n}\r\n} else {\r\nlrp->lr_seg.offset = 0;\r\nlrp->lr_seg.length = NFS4_MAX_UINT64;\r\n}\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_fallocate(struct nfsd4_compoundargs *argp,\r\nstruct nfsd4_fallocate *fallocate)\r\n{\r\nDECODE_HEAD;\r\nstatus = nfsd4_decode_stateid(argp, &fallocate->falloc_stateid);\r\nif (status)\r\nreturn status;\r\nREAD_BUF(16);\r\np = xdr_decode_hyper(p, &fallocate->falloc_offset);\r\nxdr_decode_hyper(p, &fallocate->falloc_length);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_seek(struct nfsd4_compoundargs *argp, struct nfsd4_seek *seek)\r\n{\r\nDECODE_HEAD;\r\nstatus = nfsd4_decode_stateid(argp, &seek->seek_stateid);\r\nif (status)\r\nreturn status;\r\nREAD_BUF(8 + 4);\r\np = xdr_decode_hyper(p, &seek->seek_offset);\r\nseek->seek_whence = be32_to_cpup(p);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32\r\nnfsd4_decode_noop(struct nfsd4_compoundargs *argp, void *p)\r\n{\r\nreturn nfs_ok;\r\n}\r\nstatic __be32\r\nnfsd4_decode_notsupp(struct nfsd4_compoundargs *argp, void *p)\r\n{\r\nreturn nfserr_notsupp;\r\n}\r\nstatic inline bool\r\nnfsd4_opnum_in_range(struct nfsd4_compoundargs *argp, struct nfsd4_op *op)\r\n{\r\nif (op->opnum < FIRST_NFS4_OP)\r\nreturn false;\r\nelse if (argp->minorversion == 0 && op->opnum > LAST_NFS40_OP)\r\nreturn false;\r\nelse if (argp->minorversion == 1 && op->opnum > LAST_NFS41_OP)\r\nreturn false;\r\nelse if (argp->minorversion == 2 && op->opnum > LAST_NFS42_OP)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic __be32\r\nnfsd4_decode_compound(struct nfsd4_compoundargs *argp)\r\n{\r\nDECODE_HEAD;\r\nstruct nfsd4_op *op;\r\nbool cachethis = false;\r\nint auth_slack= argp->rqstp->rq_auth_slack;\r\nint max_reply = auth_slack + 8;\r\nint readcount = 0;\r\nint readbytes = 0;\r\nint i;\r\nREAD_BUF(4);\r\nargp->taglen = be32_to_cpup(p++);\r\nREAD_BUF(argp->taglen + 8);\r\nSAVEMEM(argp->tag, argp->taglen);\r\nargp->minorversion = be32_to_cpup(p++);\r\nargp->opcnt = be32_to_cpup(p++);\r\nmax_reply += 4 + (XDR_QUADLEN(argp->taglen) << 2);\r\nif (argp->taglen > NFSD4_MAX_TAGLEN)\r\ngoto xdr_error;\r\nif (argp->opcnt > 100)\r\ngoto xdr_error;\r\nif (argp->opcnt > ARRAY_SIZE(argp->iops)) {\r\nargp->ops = kzalloc(argp->opcnt * sizeof(*argp->ops), GFP_KERNEL);\r\nif (!argp->ops) {\r\nargp->ops = argp->iops;\r\ndprintk("nfsd: couldn't allocate room for COMPOUND\n");\r\ngoto xdr_error;\r\n}\r\n}\r\nif (argp->minorversion > NFSD_SUPPORTED_MINOR_VERSION)\r\nargp->opcnt = 0;\r\nfor (i = 0; i < argp->opcnt; i++) {\r\nop = &argp->ops[i];\r\nop->replay = NULL;\r\nREAD_BUF(4);\r\nop->opnum = be32_to_cpup(p++);\r\nif (nfsd4_opnum_in_range(argp, op))\r\nop->status = nfsd4_dec_ops[op->opnum](argp, &op->u);\r\nelse {\r\nop->opnum = OP_ILLEGAL;\r\nop->status = nfserr_op_illegal;\r\n}\r\ncachethis |= nfsd4_cache_this_op(op);\r\nif (op->opnum == OP_READ) {\r\nreadcount++;\r\nreadbytes += nfsd4_max_reply(argp->rqstp, op);\r\n} else\r\nmax_reply += nfsd4_max_reply(argp->rqstp, op);\r\nif (op->opnum == OP_LOCK)\r\nmax_reply += NFS4_OPAQUE_LIMIT;\r\nif (op->status) {\r\nargp->opcnt = i+1;\r\nbreak;\r\n}\r\n}\r\nif (argp->minorversion)\r\ncachethis = false;\r\nsvc_reserve(argp->rqstp, max_reply + readbytes);\r\nargp->rqstp->rq_cachetype = cachethis ? RC_REPLBUFF : RC_NOCACHE;\r\nif (readcount > 1 || max_reply > PAGE_SIZE - auth_slack)\r\nclear_bit(RQ_SPLICE_OK, &argp->rqstp->rq_flags);\r\nDECODE_TAIL;\r\n}\r\nstatic __be32 *encode_change(__be32 *p, struct kstat *stat, struct inode *inode)\r\n{\r\nif (IS_I_VERSION(inode)) {\r\np = xdr_encode_hyper(p, inode->i_version);\r\n} else {\r\n*p++ = cpu_to_be32(stat->ctime.tv_sec);\r\n*p++ = cpu_to_be32(stat->ctime.tv_nsec);\r\n}\r\nreturn p;\r\n}\r\nstatic __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\r\n{\r\n*p++ = cpu_to_be32(c->atomic);\r\nif (c->change_supported) {\r\np = xdr_encode_hyper(p, c->before_change);\r\np = xdr_encode_hyper(p, c->after_change);\r\n} else {\r\n*p++ = cpu_to_be32(c->before_ctime_sec);\r\n*p++ = cpu_to_be32(c->before_ctime_nsec);\r\n*p++ = cpu_to_be32(c->after_ctime_sec);\r\n*p++ = cpu_to_be32(c->after_ctime_nsec);\r\n}\r\nreturn p;\r\n}\r\nstatic __be32 nfsd4_encode_components_esc(struct xdr_stream *xdr, char sep,\r\nchar *components, char esc_enter,\r\nchar esc_exit)\r\n{\r\n__be32 *p;\r\n__be32 pathlen;\r\nint pathlen_offset;\r\nint strlen, count=0;\r\nchar *str, *end, *next;\r\ndprintk("nfsd4_encode_components(%s)\n", components);\r\npathlen_offset = xdr->buf->len;\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\nreturn nfserr_resource;\r\np++;\r\nend = str = components;\r\nwhile (*end) {\r\nbool found_esc = false;\r\nif (*str == esc_enter) {\r\nfor (; *end && (*end != esc_exit); end++)\r\n;\r\nnext = end + 1;\r\nif (*end && (!*next || *next == sep)) {\r\nstr++;\r\nfound_esc = true;\r\n}\r\n}\r\nif (!found_esc)\r\nfor (; *end && (*end != sep); end++)\r\n;\r\nstrlen = end - str;\r\nif (strlen) {\r\np = xdr_reserve_space(xdr, strlen + 4);\r\nif (!p)\r\nreturn nfserr_resource;\r\np = xdr_encode_opaque(p, str, strlen);\r\ncount++;\r\n}\r\nelse\r\nend++;\r\nif (found_esc)\r\nend = next;\r\nstr = end;\r\n}\r\npathlen = htonl(count);\r\nwrite_bytes_to_xdr_buf(xdr->buf, pathlen_offset, &pathlen, 4);\r\nreturn 0;\r\n}\r\nstatic __be32 nfsd4_encode_components(struct xdr_stream *xdr, char sep,\r\nchar *components)\r\n{\r\nreturn nfsd4_encode_components_esc(xdr, sep, components, 0, 0);\r\n}\r\nstatic __be32 nfsd4_encode_fs_location4(struct xdr_stream *xdr,\r\nstruct nfsd4_fs_location *location)\r\n{\r\n__be32 status;\r\nstatus = nfsd4_encode_components_esc(xdr, ':', location->hosts,\r\n'[', ']');\r\nif (status)\r\nreturn status;\r\nstatus = nfsd4_encode_components(xdr, '/', location->path);\r\nif (status)\r\nreturn status;\r\nreturn 0;\r\n}\r\nstatic __be32 nfsd4_encode_path(struct xdr_stream *xdr,\r\nconst struct path *root,\r\nconst struct path *path)\r\n{\r\nstruct path cur = *path;\r\n__be32 *p;\r\nstruct dentry **components = NULL;\r\nunsigned int ncomponents = 0;\r\n__be32 err = nfserr_jukebox;\r\ndprintk("nfsd4_encode_components(");\r\npath_get(&cur);\r\nfor (;;) {\r\nif (path_equal(&cur, root))\r\nbreak;\r\nif (cur.dentry == cur.mnt->mnt_root) {\r\nif (follow_up(&cur))\r\ncontinue;\r\ngoto out_free;\r\n}\r\nif ((ncomponents & 15) == 0) {\r\nstruct dentry **new;\r\nnew = krealloc(components,\r\nsizeof(*new) * (ncomponents + 16),\r\nGFP_KERNEL);\r\nif (!new)\r\ngoto out_free;\r\ncomponents = new;\r\n}\r\ncomponents[ncomponents++] = cur.dentry;\r\ncur.dentry = dget_parent(cur.dentry);\r\n}\r\nerr = nfserr_resource;\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_free;\r\n*p++ = cpu_to_be32(ncomponents);\r\nwhile (ncomponents) {\r\nstruct dentry *dentry = components[ncomponents - 1];\r\nunsigned int len;\r\nspin_lock(&dentry->d_lock);\r\nlen = dentry->d_name.len;\r\np = xdr_reserve_space(xdr, len + 4);\r\nif (!p) {\r\nspin_unlock(&dentry->d_lock);\r\ngoto out_free;\r\n}\r\np = xdr_encode_opaque(p, dentry->d_name.name, len);\r\ndprintk("/%pd", dentry);\r\nspin_unlock(&dentry->d_lock);\r\ndput(dentry);\r\nncomponents--;\r\n}\r\nerr = 0;\r\nout_free:\r\ndprintk(")\n");\r\nwhile (ncomponents)\r\ndput(components[--ncomponents]);\r\nkfree(components);\r\npath_put(&cur);\r\nreturn err;\r\n}\r\nstatic __be32 nfsd4_encode_fsloc_fsroot(struct xdr_stream *xdr,\r\nstruct svc_rqst *rqstp, const struct path *path)\r\n{\r\nstruct svc_export *exp_ps;\r\n__be32 res;\r\nexp_ps = rqst_find_fsidzero_export(rqstp);\r\nif (IS_ERR(exp_ps))\r\nreturn nfserrno(PTR_ERR(exp_ps));\r\nres = nfsd4_encode_path(xdr, &exp_ps->ex_path, path);\r\nexp_put(exp_ps);\r\nreturn res;\r\n}\r\nstatic __be32 nfsd4_encode_fs_locations(struct xdr_stream *xdr,\r\nstruct svc_rqst *rqstp, struct svc_export *exp)\r\n{\r\n__be32 status;\r\nint i;\r\n__be32 *p;\r\nstruct nfsd4_fs_locations *fslocs = &exp->ex_fslocs;\r\nstatus = nfsd4_encode_fsloc_fsroot(xdr, rqstp, &exp->ex_path);\r\nif (status)\r\nreturn status;\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(fslocs->locations_count);\r\nfor (i=0; i<fslocs->locations_count; i++) {\r\nstatus = nfsd4_encode_fs_location4(xdr, &fslocs->locations[i]);\r\nif (status)\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 nfs4_file_type(umode_t mode)\r\n{\r\nswitch (mode & S_IFMT) {\r\ncase S_IFIFO: return NF4FIFO;\r\ncase S_IFCHR: return NF4CHR;\r\ncase S_IFDIR: return NF4DIR;\r\ncase S_IFBLK: return NF4BLK;\r\ncase S_IFLNK: return NF4LNK;\r\ncase S_IFREG: return NF4REG;\r\ncase S_IFSOCK: return NF4SOCK;\r\ndefault: return NF4BAD;\r\n};\r\n}\r\nstatic inline __be32\r\nnfsd4_encode_aclname(struct xdr_stream *xdr, struct svc_rqst *rqstp,\r\nstruct nfs4_ace *ace)\r\n{\r\nif (ace->whotype != NFS4_ACL_WHO_NAMED)\r\nreturn nfs4_acl_write_who(xdr, ace->whotype);\r\nelse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\r\nreturn nfsd4_encode_group(xdr, rqstp, ace->who_gid);\r\nelse\r\nreturn nfsd4_encode_user(xdr, rqstp, ace->who_uid);\r\n}\r\nstatic inline __be32\r\nnfsd4_encode_layout_type(struct xdr_stream *xdr, enum pnfs_layouttype layout_type)\r\n{\r\n__be32 *p;\r\nif (layout_type) {\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(1);\r\n*p++ = cpu_to_be32(layout_type);\r\n} else {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(0);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline __be32\r\nnfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,\r\nvoid *context, int len)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, len + 4 + 4 + 4);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(0);\r\n*p++ = cpu_to_be32(0);\r\np = xdr_encode_opaque(p, context, len);\r\nreturn 0;\r\n}\r\nstatic inline __be32\r\nnfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,\r\nvoid *context, int len)\r\n{ return 0; }\r\nstatic __be32 fattr_handle_absent_fs(u32 *bmval0, u32 *bmval1, u32 *bmval2, u32 *rdattr_err)\r\n{\r\nif (*bmval0 & ~WORD0_ABSENT_FS_ATTRS ||\r\n*bmval1 & ~WORD1_ABSENT_FS_ATTRS) {\r\nif (*bmval0 & FATTR4_WORD0_RDATTR_ERROR ||\r\n*bmval0 & FATTR4_WORD0_FS_LOCATIONS)\r\n*rdattr_err = NFSERR_MOVED;\r\nelse\r\nreturn nfserr_moved;\r\n}\r\n*bmval0 &= WORD0_ABSENT_FS_ATTRS;\r\n*bmval1 &= WORD1_ABSENT_FS_ATTRS;\r\n*bmval2 &= WORD2_ABSENT_FS_ATTRS;\r\nreturn 0;\r\n}\r\nstatic int get_parent_attributes(struct svc_export *exp, struct kstat *stat)\r\n{\r\nstruct path path = exp->ex_path;\r\nint err;\r\npath_get(&path);\r\nwhile (follow_up(&path)) {\r\nif (path.dentry != path.mnt->mnt_root)\r\nbreak;\r\n}\r\nerr = vfs_getattr(&path, stat);\r\npath_put(&path);\r\nreturn err;\r\n}\r\nstatic __be32\r\nnfsd4_encode_bitmap(struct xdr_stream *xdr, u32 bmval0, u32 bmval1, u32 bmval2)\r\n{\r\n__be32 *p;\r\nif (bmval2) {\r\np = xdr_reserve_space(xdr, 16);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(3);\r\n*p++ = cpu_to_be32(bmval0);\r\n*p++ = cpu_to_be32(bmval1);\r\n*p++ = cpu_to_be32(bmval2);\r\n} else if (bmval1) {\r\np = xdr_reserve_space(xdr, 12);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(2);\r\n*p++ = cpu_to_be32(bmval0);\r\n*p++ = cpu_to_be32(bmval1);\r\n} else {\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(1);\r\n*p++ = cpu_to_be32(bmval0);\r\n}\r\nreturn 0;\r\nout_resource:\r\nreturn nfserr_resource;\r\n}\r\nstatic __be32\r\nnfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,\r\nstruct svc_export *exp,\r\nstruct dentry *dentry, u32 *bmval,\r\nstruct svc_rqst *rqstp, int ignore_crossmnt)\r\n{\r\nu32 bmval0 = bmval[0];\r\nu32 bmval1 = bmval[1];\r\nu32 bmval2 = bmval[2];\r\nstruct kstat stat;\r\nstruct svc_fh *tempfh = NULL;\r\nstruct kstatfs statfs;\r\n__be32 *p;\r\nint starting_len = xdr->buf->len;\r\nint attrlen_offset;\r\n__be32 attrlen;\r\nu32 dummy;\r\nu64 dummy64;\r\nu32 rdattr_err = 0;\r\n__be32 status;\r\nint err;\r\nstruct nfs4_acl *acl = NULL;\r\nvoid *context = NULL;\r\nint contextlen;\r\nbool contextsupport = false;\r\nstruct nfsd4_compoundres *resp = rqstp->rq_resp;\r\nu32 minorversion = resp->cstate.minorversion;\r\nstruct path path = {\r\n.mnt = exp->ex_path.mnt,\r\n.dentry = dentry,\r\n};\r\nstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\r\nBUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);\r\nBUG_ON(bmval0 & ~nfsd_suppattrs0(minorversion));\r\nBUG_ON(bmval1 & ~nfsd_suppattrs1(minorversion));\r\nBUG_ON(bmval2 & ~nfsd_suppattrs2(minorversion));\r\nif (exp->ex_fslocs.migrated) {\r\nstatus = fattr_handle_absent_fs(&bmval0, &bmval1, &bmval2, &rdattr_err);\r\nif (status)\r\ngoto out;\r\n}\r\nerr = vfs_getattr(&path, &stat);\r\nif (err)\r\ngoto out_nfserr;\r\nif ((bmval0 & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |\r\nFATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||\r\n(bmval1 & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |\r\nFATTR4_WORD1_SPACE_TOTAL))) {\r\nerr = vfs_statfs(&path, &statfs);\r\nif (err)\r\ngoto out_nfserr;\r\n}\r\nif ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {\r\ntempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\r\nstatus = nfserr_jukebox;\r\nif (!tempfh)\r\ngoto out;\r\nfh_init(tempfh, NFS4_FHSIZE);\r\nstatus = fh_compose(tempfh, exp, dentry, NULL);\r\nif (status)\r\ngoto out;\r\nfhp = tempfh;\r\n}\r\nif (bmval0 & FATTR4_WORD0_ACL) {\r\nerr = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);\r\nif (err == -EOPNOTSUPP)\r\nbmval0 &= ~FATTR4_WORD0_ACL;\r\nelse if (err == -EINVAL) {\r\nstatus = nfserr_attrnotsupp;\r\ngoto out;\r\n} else if (err != 0)\r\ngoto out_nfserr;\r\n}\r\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\r\nif ((bmval2 & FATTR4_WORD2_SECURITY_LABEL) ||\r\nbmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\r\nerr = security_inode_getsecctx(d_inode(dentry),\r\n&context, &contextlen);\r\ncontextsupport = (err == 0);\r\nif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\r\nif (err == -EOPNOTSUPP)\r\nbmval2 &= ~FATTR4_WORD2_SECURITY_LABEL;\r\nelse if (err)\r\ngoto out_nfserr;\r\n}\r\n}\r\n#endif\r\nstatus = nfsd4_encode_bitmap(xdr, bmval0, bmval1, bmval2);\r\nif (status)\r\ngoto out;\r\nattrlen_offset = xdr->buf->len;\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\np++;\r\nif (bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\r\nu32 word0 = nfsd_suppattrs0(minorversion);\r\nu32 word1 = nfsd_suppattrs1(minorversion);\r\nu32 word2 = nfsd_suppattrs2(minorversion);\r\nif (!IS_POSIXACL(dentry->d_inode))\r\nword0 &= ~FATTR4_WORD0_ACL;\r\nif (!contextsupport)\r\nword2 &= ~FATTR4_WORD2_SECURITY_LABEL;\r\nif (!word2) {\r\np = xdr_reserve_space(xdr, 12);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(2);\r\n*p++ = cpu_to_be32(word0);\r\n*p++ = cpu_to_be32(word1);\r\n} else {\r\np = xdr_reserve_space(xdr, 16);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(3);\r\n*p++ = cpu_to_be32(word0);\r\n*p++ = cpu_to_be32(word1);\r\n*p++ = cpu_to_be32(word2);\r\n}\r\n}\r\nif (bmval0 & FATTR4_WORD0_TYPE) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\ndummy = nfs4_file_type(stat.mode);\r\nif (dummy == NF4BAD) {\r\nstatus = nfserr_serverfault;\r\ngoto out;\r\n}\r\n*p++ = cpu_to_be32(dummy);\r\n}\r\nif (bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\nif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\r\n*p++ = cpu_to_be32(NFS4_FH_PERSISTENT);\r\nelse\r\n*p++ = cpu_to_be32(NFS4_FH_PERSISTENT|\r\nNFS4_FH_VOL_RENAME);\r\n}\r\nif (bmval0 & FATTR4_WORD0_CHANGE) {\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\ngoto out_resource;\r\np = encode_change(p, &stat, d_inode(dentry));\r\n}\r\nif (bmval0 & FATTR4_WORD0_SIZE) {\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\ngoto out_resource;\r\np = xdr_encode_hyper(p, stat.size);\r\n}\r\nif (bmval0 & FATTR4_WORD0_LINK_SUPPORT) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(1);\r\n}\r\nif (bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(1);\r\n}\r\nif (bmval0 & FATTR4_WORD0_NAMED_ATTR) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(0);\r\n}\r\nif (bmval0 & FATTR4_WORD0_FSID) {\r\np = xdr_reserve_space(xdr, 16);\r\nif (!p)\r\ngoto out_resource;\r\nif (exp->ex_fslocs.migrated) {\r\np = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MAJOR);\r\np = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MINOR);\r\n} else switch(fsid_source(fhp)) {\r\ncase FSIDSOURCE_FSID:\r\np = xdr_encode_hyper(p, (u64)exp->ex_fsid);\r\np = xdr_encode_hyper(p, (u64)0);\r\nbreak;\r\ncase FSIDSOURCE_DEV:\r\n*p++ = cpu_to_be32(0);\r\n*p++ = cpu_to_be32(MAJOR(stat.dev));\r\n*p++ = cpu_to_be32(0);\r\n*p++ = cpu_to_be32(MINOR(stat.dev));\r\nbreak;\r\ncase FSIDSOURCE_UUID:\r\np = xdr_encode_opaque_fixed(p, exp->ex_uuid,\r\nEX_UUID_LEN);\r\nbreak;\r\n}\r\n}\r\nif (bmval0 & FATTR4_WORD0_UNIQUE_HANDLES) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(0);\r\n}\r\nif (bmval0 & FATTR4_WORD0_LEASE_TIME) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(nn->nfsd4_lease);\r\n}\r\nif (bmval0 & FATTR4_WORD0_RDATTR_ERROR) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(rdattr_err);\r\n}\r\nif (bmval0 & FATTR4_WORD0_ACL) {\r\nstruct nfs4_ace *ace;\r\nif (acl == NULL) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(0);\r\ngoto out_acl;\r\n}\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(acl->naces);\r\nfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\r\np = xdr_reserve_space(xdr, 4*3);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(ace->type);\r\n*p++ = cpu_to_be32(ace->flag);\r\n*p++ = cpu_to_be32(ace->access_mask &\r\nNFS4_ACE_MASK_ALL);\r\nstatus = nfsd4_encode_aclname(xdr, rqstp, ace);\r\nif (status)\r\ngoto out;\r\n}\r\n}\r\nout_acl:\r\nif (bmval0 & FATTR4_WORD0_ACLSUPPORT) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(IS_POSIXACL(dentry->d_inode) ?\r\nACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);\r\n}\r\nif (bmval0 & FATTR4_WORD0_CANSETTIME) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(1);\r\n}\r\nif (bmval0 & FATTR4_WORD0_CASE_INSENSITIVE) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(0);\r\n}\r\nif (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(1);\r\n}\r\nif (bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(1);\r\n}\r\nif (bmval0 & FATTR4_WORD0_FILEHANDLE) {\r\np = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);\r\nif (!p)\r\ngoto out_resource;\r\np = xdr_encode_opaque(p, &fhp->fh_handle.fh_base,\r\nfhp->fh_handle.fh_size);\r\n}\r\nif (bmval0 & FATTR4_WORD0_FILEID) {\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\ngoto out_resource;\r\np = xdr_encode_hyper(p, stat.ino);\r\n}\r\nif (bmval0 & FATTR4_WORD0_FILES_AVAIL) {\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\ngoto out_resource;\r\np = xdr_encode_hyper(p, (u64) statfs.f_ffree);\r\n}\r\nif (bmval0 & FATTR4_WORD0_FILES_FREE) {\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\ngoto out_resource;\r\np = xdr_encode_hyper(p, (u64) statfs.f_ffree);\r\n}\r\nif (bmval0 & FATTR4_WORD0_FILES_TOTAL) {\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\ngoto out_resource;\r\np = xdr_encode_hyper(p, (u64) statfs.f_files);\r\n}\r\nif (bmval0 & FATTR4_WORD0_FS_LOCATIONS) {\r\nstatus = nfsd4_encode_fs_locations(xdr, rqstp, exp);\r\nif (status)\r\ngoto out;\r\n}\r\nif (bmval0 & FATTR4_WORD0_HOMOGENEOUS) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(1);\r\n}\r\nif (bmval0 & FATTR4_WORD0_MAXFILESIZE) {\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\ngoto out_resource;\r\np = xdr_encode_hyper(p, exp->ex_path.mnt->mnt_sb->s_maxbytes);\r\n}\r\nif (bmval0 & FATTR4_WORD0_MAXLINK) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(255);\r\n}\r\nif (bmval0 & FATTR4_WORD0_MAXNAME) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(statfs.f_namelen);\r\n}\r\nif (bmval0 & FATTR4_WORD0_MAXREAD) {\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\ngoto out_resource;\r\np = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\r\n}\r\nif (bmval0 & FATTR4_WORD0_MAXWRITE) {\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\ngoto out_resource;\r\np = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\r\n}\r\nif (bmval1 & FATTR4_WORD1_MODE) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(stat.mode & S_IALLUGO);\r\n}\r\nif (bmval1 & FATTR4_WORD1_NO_TRUNC) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(1);\r\n}\r\nif (bmval1 & FATTR4_WORD1_NUMLINKS) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(stat.nlink);\r\n}\r\nif (bmval1 & FATTR4_WORD1_OWNER) {\r\nstatus = nfsd4_encode_user(xdr, rqstp, stat.uid);\r\nif (status)\r\ngoto out;\r\n}\r\nif (bmval1 & FATTR4_WORD1_OWNER_GROUP) {\r\nstatus = nfsd4_encode_group(xdr, rqstp, stat.gid);\r\nif (status)\r\ngoto out;\r\n}\r\nif (bmval1 & FATTR4_WORD1_RAWDEV) {\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32((u32) MAJOR(stat.rdev));\r\n*p++ = cpu_to_be32((u32) MINOR(stat.rdev));\r\n}\r\nif (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\ngoto out_resource;\r\ndummy64 = (u64)statfs.f_bavail * (u64)statfs.f_bsize;\r\np = xdr_encode_hyper(p, dummy64);\r\n}\r\nif (bmval1 & FATTR4_WORD1_SPACE_FREE) {\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\ngoto out_resource;\r\ndummy64 = (u64)statfs.f_bfree * (u64)statfs.f_bsize;\r\np = xdr_encode_hyper(p, dummy64);\r\n}\r\nif (bmval1 & FATTR4_WORD1_SPACE_TOTAL) {\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\ngoto out_resource;\r\ndummy64 = (u64)statfs.f_blocks * (u64)statfs.f_bsize;\r\np = xdr_encode_hyper(p, dummy64);\r\n}\r\nif (bmval1 & FATTR4_WORD1_SPACE_USED) {\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\ngoto out_resource;\r\ndummy64 = (u64)stat.blocks << 9;\r\np = xdr_encode_hyper(p, dummy64);\r\n}\r\nif (bmval1 & FATTR4_WORD1_TIME_ACCESS) {\r\np = xdr_reserve_space(xdr, 12);\r\nif (!p)\r\ngoto out_resource;\r\np = xdr_encode_hyper(p, (s64)stat.atime.tv_sec);\r\n*p++ = cpu_to_be32(stat.atime.tv_nsec);\r\n}\r\nif (bmval1 & FATTR4_WORD1_TIME_DELTA) {\r\np = xdr_reserve_space(xdr, 12);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(0);\r\n*p++ = cpu_to_be32(1);\r\n*p++ = cpu_to_be32(0);\r\n}\r\nif (bmval1 & FATTR4_WORD1_TIME_METADATA) {\r\np = xdr_reserve_space(xdr, 12);\r\nif (!p)\r\ngoto out_resource;\r\np = xdr_encode_hyper(p, (s64)stat.ctime.tv_sec);\r\n*p++ = cpu_to_be32(stat.ctime.tv_nsec);\r\n}\r\nif (bmval1 & FATTR4_WORD1_TIME_MODIFY) {\r\np = xdr_reserve_space(xdr, 12);\r\nif (!p)\r\ngoto out_resource;\r\np = xdr_encode_hyper(p, (s64)stat.mtime.tv_sec);\r\n*p++ = cpu_to_be32(stat.mtime.tv_nsec);\r\n}\r\nif (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {\r\nstruct kstat parent_stat;\r\nu64 ino = stat.ino;\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\ngoto out_resource;\r\nif (ignore_crossmnt == 0 &&\r\ndentry == exp->ex_path.mnt->mnt_root) {\r\nerr = get_parent_attributes(exp, &parent_stat);\r\nif (err)\r\ngoto out_nfserr;\r\nino = parent_stat.ino;\r\n}\r\np = xdr_encode_hyper(p, ino);\r\n}\r\n#ifdef CONFIG_NFSD_PNFS\r\nif (bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES) {\r\nstatus = nfsd4_encode_layout_type(xdr, exp->ex_layout_type);\r\nif (status)\r\ngoto out;\r\n}\r\nif (bmval2 & FATTR4_WORD2_LAYOUT_TYPES) {\r\nstatus = nfsd4_encode_layout_type(xdr, exp->ex_layout_type);\r\nif (status)\r\ngoto out;\r\n}\r\nif (bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out_resource;\r\n*p++ = cpu_to_be32(stat.blksize);\r\n}\r\n#endif\r\nif (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {\r\nstatus = nfsd4_encode_bitmap(xdr, NFSD_SUPPATTR_EXCLCREAT_WORD0,\r\nNFSD_SUPPATTR_EXCLCREAT_WORD1,\r\nNFSD_SUPPATTR_EXCLCREAT_WORD2);\r\nif (status)\r\ngoto out;\r\n}\r\nif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\r\nstatus = nfsd4_encode_security_label(xdr, rqstp, context,\r\ncontextlen);\r\nif (status)\r\ngoto out;\r\n}\r\nattrlen = htonl(xdr->buf->len - attrlen_offset - 4);\r\nwrite_bytes_to_xdr_buf(xdr->buf, attrlen_offset, &attrlen, 4);\r\nstatus = nfs_ok;\r\nout:\r\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\r\nif (context)\r\nsecurity_release_secctx(context, contextlen);\r\n#endif\r\nkfree(acl);\r\nif (tempfh) {\r\nfh_put(tempfh);\r\nkfree(tempfh);\r\n}\r\nif (status)\r\nxdr_truncate_encode(xdr, starting_len);\r\nreturn status;\r\nout_nfserr:\r\nstatus = nfserrno(err);\r\ngoto out;\r\nout_resource:\r\nstatus = nfserr_resource;\r\ngoto out;\r\n}\r\nstatic void svcxdr_init_encode_from_buffer(struct xdr_stream *xdr,\r\nstruct xdr_buf *buf, __be32 *p, int bytes)\r\n{\r\nxdr->scratch.iov_len = 0;\r\nmemset(buf, 0, sizeof(struct xdr_buf));\r\nbuf->head[0].iov_base = p;\r\nbuf->head[0].iov_len = 0;\r\nbuf->len = 0;\r\nxdr->buf = buf;\r\nxdr->iov = buf->head;\r\nxdr->p = p;\r\nxdr->end = (void *)p + bytes;\r\nbuf->buflen = bytes;\r\n}\r\n__be32 nfsd4_encode_fattr_to_buf(__be32 **p, int words,\r\nstruct svc_fh *fhp, struct svc_export *exp,\r\nstruct dentry *dentry, u32 *bmval,\r\nstruct svc_rqst *rqstp, int ignore_crossmnt)\r\n{\r\nstruct xdr_buf dummy;\r\nstruct xdr_stream xdr;\r\n__be32 ret;\r\nsvcxdr_init_encode_from_buffer(&xdr, &dummy, *p, words << 2);\r\nret = nfsd4_encode_fattr(&xdr, fhp, exp, dentry, bmval, rqstp,\r\nignore_crossmnt);\r\n*p = xdr.p;\r\nreturn ret;\r\n}\r\nstatic inline int attributes_need_mount(u32 *bmval)\r\n{\r\nif (bmval[0] & ~(FATTR4_WORD0_RDATTR_ERROR | FATTR4_WORD0_LEASE_TIME))\r\nreturn 1;\r\nif (bmval[1] & ~FATTR4_WORD1_MOUNTED_ON_FILEID)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic __be32\r\nnfsd4_encode_dirent_fattr(struct xdr_stream *xdr, struct nfsd4_readdir *cd,\r\nconst char *name, int namlen)\r\n{\r\nstruct svc_export *exp = cd->rd_fhp->fh_export;\r\nstruct dentry *dentry;\r\n__be32 nfserr;\r\nint ignore_crossmnt = 0;\r\ndentry = lookup_one_len(name, cd->rd_fhp->fh_dentry, namlen);\r\nif (IS_ERR(dentry))\r\nreturn nfserrno(PTR_ERR(dentry));\r\nif (d_really_is_negative(dentry)) {\r\ndput(dentry);\r\nreturn nfserr_noent;\r\n}\r\nexp_get(exp);\r\nif (nfsd_mountpoint(dentry, exp)) {\r\nint err;\r\nif (!(exp->ex_flags & NFSEXP_V4ROOT)\r\n&& !attributes_need_mount(cd->rd_bmval)) {\r\nignore_crossmnt = 1;\r\ngoto out_encode;\r\n}\r\nerr = nfsd_cross_mnt(cd->rd_rqstp, &dentry, &exp);\r\nif (err) {\r\nnfserr = nfserrno(err);\r\ngoto out_put;\r\n}\r\nnfserr = check_nfsd_access(exp, cd->rd_rqstp);\r\nif (nfserr)\r\ngoto out_put;\r\n}\r\nout_encode:\r\nnfserr = nfsd4_encode_fattr(xdr, NULL, exp, dentry, cd->rd_bmval,\r\ncd->rd_rqstp, ignore_crossmnt);\r\nout_put:\r\ndput(dentry);\r\nexp_put(exp);\r\nreturn nfserr;\r\n}\r\nstatic __be32 *\r\nnfsd4_encode_rdattr_error(struct xdr_stream *xdr, __be32 nfserr)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, 20);\r\nif (!p)\r\nreturn NULL;\r\n*p++ = htonl(2);\r\n*p++ = htonl(FATTR4_WORD0_RDATTR_ERROR);\r\n*p++ = htonl(0);\r\n*p++ = htonl(4);\r\n*p++ = nfserr;\r\nreturn p;\r\n}\r\nstatic int\r\nnfsd4_encode_dirent(void *ccdv, const char *name, int namlen,\r\nloff_t offset, u64 ino, unsigned int d_type)\r\n{\r\nstruct readdir_cd *ccd = ccdv;\r\nstruct nfsd4_readdir *cd = container_of(ccd, struct nfsd4_readdir, common);\r\nstruct xdr_stream *xdr = cd->xdr;\r\nint start_offset = xdr->buf->len;\r\nint cookie_offset;\r\nu32 name_and_cookie;\r\nint entry_bytes;\r\n__be32 nfserr = nfserr_toosmall;\r\n__be64 wire_offset;\r\n__be32 *p;\r\nif (name && isdotent(name, namlen)) {\r\ncd->common.err = nfs_ok;\r\nreturn 0;\r\n}\r\nif (cd->cookie_offset) {\r\nwire_offset = cpu_to_be64(offset);\r\nwrite_bytes_to_xdr_buf(xdr->buf, cd->cookie_offset,\r\n&wire_offset, 8);\r\n}\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto fail;\r\n*p++ = xdr_one;\r\ncookie_offset = xdr->buf->len;\r\np = xdr_reserve_space(xdr, 3*4 + namlen);\r\nif (!p)\r\ngoto fail;\r\np = xdr_encode_hyper(p, NFS_OFFSET_MAX);\r\np = xdr_encode_array(p, name, namlen);\r\nnfserr = nfsd4_encode_dirent_fattr(xdr, cd, name, namlen);\r\nswitch (nfserr) {\r\ncase nfs_ok:\r\nbreak;\r\ncase nfserr_resource:\r\nnfserr = nfserr_toosmall;\r\ngoto fail;\r\ncase nfserr_noent:\r\nxdr_truncate_encode(xdr, start_offset);\r\ngoto skip_entry;\r\ndefault:\r\nif (!(cd->rd_bmval[0] & FATTR4_WORD0_RDATTR_ERROR))\r\ngoto fail;\r\np = nfsd4_encode_rdattr_error(xdr, nfserr);\r\nif (p == NULL) {\r\nnfserr = nfserr_toosmall;\r\ngoto fail;\r\n}\r\n}\r\nnfserr = nfserr_toosmall;\r\nentry_bytes = xdr->buf->len - start_offset;\r\nif (entry_bytes > cd->rd_maxcount)\r\ngoto fail;\r\ncd->rd_maxcount -= entry_bytes;\r\nif (!cd->rd_dircount)\r\ngoto fail;\r\nname_and_cookie = 4 + 4 * XDR_QUADLEN(namlen) + 8;\r\nif (name_and_cookie > cd->rd_dircount && cd->cookie_offset)\r\ngoto fail;\r\ncd->rd_dircount -= min(cd->rd_dircount, name_and_cookie);\r\ncd->cookie_offset = cookie_offset;\r\nskip_entry:\r\ncd->common.err = nfs_ok;\r\nreturn 0;\r\nfail:\r\nxdr_truncate_encode(xdr, start_offset);\r\ncd->common.err = nfserr;\r\nreturn -EINVAL;\r\n}\r\nstatic __be32\r\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, sizeof(stateid_t));\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(sid->si_generation);\r\np = xdr_encode_opaque_fixed(p, &sid->si_opaque,\r\nsizeof(stateid_opaque_t));\r\nreturn 0;\r\n}\r\nstatic __be32\r\nnfsd4_encode_access(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_access *access)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\n__be32 *p;\r\nif (!nfserr) {\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(access->ac_supported);\r\n*p++ = cpu_to_be32(access->ac_resp_access);\r\n}\r\nreturn nfserr;\r\n}\r\nstatic __be32 nfsd4_encode_bind_conn_to_session(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_bind_conn_to_session *bcts)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\n__be32 *p;\r\nif (!nfserr) {\r\np = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN + 8);\r\nif (!p)\r\nreturn nfserr_resource;\r\np = xdr_encode_opaque_fixed(p, bcts->sessionid.data,\r\nNFS4_MAX_SESSIONID_LEN);\r\n*p++ = cpu_to_be32(bcts->dir);\r\n*p++ = cpu_to_be32(0);\r\n}\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_close(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_close *close)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\nif (!nfserr)\r\nnfserr = nfsd4_encode_stateid(xdr, &close->cl_stateid);\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_commit(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_commit *commit)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\n__be32 *p;\r\nif (!nfserr) {\r\np = xdr_reserve_space(xdr, NFS4_VERIFIER_SIZE);\r\nif (!p)\r\nreturn nfserr_resource;\r\np = xdr_encode_opaque_fixed(p, commit->co_verf.data,\r\nNFS4_VERIFIER_SIZE);\r\n}\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_create(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_create *create)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\n__be32 *p;\r\nif (!nfserr) {\r\np = xdr_reserve_space(xdr, 20);\r\nif (!p)\r\nreturn nfserr_resource;\r\nencode_cinfo(p, &create->cr_cinfo);\r\nnfserr = nfsd4_encode_bitmap(xdr, create->cr_bmval[0],\r\ncreate->cr_bmval[1], create->cr_bmval[2]);\r\n}\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_getattr(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_getattr *getattr)\r\n{\r\nstruct svc_fh *fhp = getattr->ga_fhp;\r\nstruct xdr_stream *xdr = &resp->xdr;\r\nif (nfserr)\r\nreturn nfserr;\r\nnfserr = nfsd4_encode_fattr(xdr, fhp, fhp->fh_export, fhp->fh_dentry,\r\ngetattr->ga_bmval,\r\nresp->rqstp, 0);\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_getfh(struct nfsd4_compoundres *resp, __be32 nfserr, struct svc_fh **fhpp)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\nstruct svc_fh *fhp = *fhpp;\r\nunsigned int len;\r\n__be32 *p;\r\nif (!nfserr) {\r\nlen = fhp->fh_handle.fh_size;\r\np = xdr_reserve_space(xdr, len + 4);\r\nif (!p)\r\nreturn nfserr_resource;\r\np = xdr_encode_opaque(p, &fhp->fh_handle.fh_base, len);\r\n}\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_lock_denied(struct xdr_stream *xdr, struct nfsd4_lock_denied *ld)\r\n{\r\nstruct xdr_netobj *conf = &ld->ld_owner;\r\n__be32 *p;\r\nagain:\r\np = xdr_reserve_space(xdr, 32 + XDR_LEN(conf->len));\r\nif (!p) {\r\nif (conf->len) {\r\nkfree(conf->data);\r\nconf->len = 0;\r\nconf->data = NULL;\r\ngoto again;\r\n}\r\nreturn nfserr_resource;\r\n}\r\np = xdr_encode_hyper(p, ld->ld_start);\r\np = xdr_encode_hyper(p, ld->ld_length);\r\n*p++ = cpu_to_be32(ld->ld_type);\r\nif (conf->len) {\r\np = xdr_encode_opaque_fixed(p, &ld->ld_clientid, 8);\r\np = xdr_encode_opaque(p, conf->data, conf->len);\r\nkfree(conf->data);\r\n} else {\r\np = xdr_encode_hyper(p, (u64)0);\r\n*p++ = cpu_to_be32(0);\r\n}\r\nreturn nfserr_denied;\r\n}\r\nstatic __be32\r\nnfsd4_encode_lock(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_lock *lock)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\nif (!nfserr)\r\nnfserr = nfsd4_encode_stateid(xdr, &lock->lk_resp_stateid);\r\nelse if (nfserr == nfserr_denied)\r\nnfserr = nfsd4_encode_lock_denied(xdr, &lock->lk_denied);\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_lockt(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_lockt *lockt)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\nif (nfserr == nfserr_denied)\r\nnfsd4_encode_lock_denied(xdr, &lockt->lt_denied);\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_locku(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_locku *locku)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\nif (!nfserr)\r\nnfserr = nfsd4_encode_stateid(xdr, &locku->lu_stateid);\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_link(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_link *link)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\n__be32 *p;\r\nif (!nfserr) {\r\np = xdr_reserve_space(xdr, 20);\r\nif (!p)\r\nreturn nfserr_resource;\r\np = encode_cinfo(p, &link->li_cinfo);\r\n}\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_open(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_open *open)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\n__be32 *p;\r\nif (nfserr)\r\ngoto out;\r\nnfserr = nfsd4_encode_stateid(xdr, &open->op_stateid);\r\nif (nfserr)\r\ngoto out;\r\np = xdr_reserve_space(xdr, 24);\r\nif (!p)\r\nreturn nfserr_resource;\r\np = encode_cinfo(p, &open->op_cinfo);\r\n*p++ = cpu_to_be32(open->op_rflags);\r\nnfserr = nfsd4_encode_bitmap(xdr, open->op_bmval[0], open->op_bmval[1],\r\nopen->op_bmval[2]);\r\nif (nfserr)\r\ngoto out;\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(open->op_delegate_type);\r\nswitch (open->op_delegate_type) {\r\ncase NFS4_OPEN_DELEGATE_NONE:\r\nbreak;\r\ncase NFS4_OPEN_DELEGATE_READ:\r\nnfserr = nfsd4_encode_stateid(xdr, &open->op_delegate_stateid);\r\nif (nfserr)\r\nreturn nfserr;\r\np = xdr_reserve_space(xdr, 20);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(open->op_recall);\r\n*p++ = cpu_to_be32(NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE);\r\n*p++ = cpu_to_be32(0);\r\n*p++ = cpu_to_be32(0);\r\n*p++ = cpu_to_be32(0);\r\nbreak;\r\ncase NFS4_OPEN_DELEGATE_WRITE:\r\nnfserr = nfsd4_encode_stateid(xdr, &open->op_delegate_stateid);\r\nif (nfserr)\r\nreturn nfserr;\r\np = xdr_reserve_space(xdr, 32);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(0);\r\n*p++ = cpu_to_be32(NFS4_LIMIT_SIZE);\r\n*p++ = cpu_to_be32(~(u32)0);\r\n*p++ = cpu_to_be32(~(u32)0);\r\n*p++ = cpu_to_be32(NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE);\r\n*p++ = cpu_to_be32(0);\r\n*p++ = cpu_to_be32(0);\r\n*p++ = cpu_to_be32(0);\r\nbreak;\r\ncase NFS4_OPEN_DELEGATE_NONE_EXT:\r\nswitch (open->op_why_no_deleg) {\r\ncase WND4_CONTENTION:\r\ncase WND4_RESOURCE:\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(open->op_why_no_deleg);\r\n*p++ = cpu_to_be32(0);\r\nbreak;\r\ndefault:\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(open->op_why_no_deleg);\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nout:\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_open_confirm(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_open_confirm *oc)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\nif (!nfserr)\r\nnfserr = nfsd4_encode_stateid(xdr, &oc->oc_resp_stateid);\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_open_downgrade(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_open_downgrade *od)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\nif (!nfserr)\r\nnfserr = nfsd4_encode_stateid(xdr, &od->od_stateid);\r\nreturn nfserr;\r\n}\r\nstatic __be32 nfsd4_encode_splice_read(\r\nstruct nfsd4_compoundres *resp,\r\nstruct nfsd4_read *read,\r\nstruct file *file, unsigned long maxcount)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\nstruct xdr_buf *buf = xdr->buf;\r\nu32 eof;\r\nint space_left;\r\n__be32 nfserr;\r\n__be32 *p = xdr->p - 2;\r\nif (xdr->end - xdr->p < 1)\r\nreturn nfserr_resource;\r\nnfserr = nfsd_splice_read(read->rd_rqstp, file,\r\nread->rd_offset, &maxcount);\r\nif (nfserr) {\r\nbuf->page_len = 0;\r\nreturn nfserr;\r\n}\r\neof = (read->rd_offset + maxcount >=\r\nd_inode(read->rd_fhp->fh_dentry)->i_size);\r\n*(p++) = htonl(eof);\r\n*(p++) = htonl(maxcount);\r\nbuf->page_len = maxcount;\r\nbuf->len += maxcount;\r\nxdr->page_ptr += (buf->page_base + maxcount + PAGE_SIZE - 1)\r\n/ PAGE_SIZE;\r\nbuf->tail[0].iov_base = xdr->p;\r\nbuf->tail[0].iov_len = 0;\r\nxdr->iov = buf->tail;\r\nif (maxcount&3) {\r\nint pad = 4 - (maxcount&3);\r\n*(xdr->p++) = 0;\r\nbuf->tail[0].iov_base += maxcount&3;\r\nbuf->tail[0].iov_len = pad;\r\nbuf->len += pad;\r\n}\r\nspace_left = min_t(int, (void *)xdr->end - (void *)xdr->p,\r\nbuf->buflen - buf->len);\r\nbuf->buflen = buf->len + space_left;\r\nxdr->end = (__be32 *)((void *)xdr->end + space_left);\r\nreturn 0;\r\n}\r\nstatic __be32 nfsd4_encode_readv(struct nfsd4_compoundres *resp,\r\nstruct nfsd4_read *read,\r\nstruct file *file, unsigned long maxcount)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\nu32 eof;\r\nint v;\r\nint starting_len = xdr->buf->len - 8;\r\nlong len;\r\nint thislen;\r\n__be32 nfserr;\r\n__be32 tmp;\r\n__be32 *p;\r\nu32 zzz = 0;\r\nint pad;\r\nlen = maxcount;\r\nv = 0;\r\nthislen = min_t(long, len, ((void *)xdr->end - (void *)xdr->p));\r\np = xdr_reserve_space(xdr, (thislen+3)&~3);\r\nWARN_ON_ONCE(!p);\r\nresp->rqstp->rq_vec[v].iov_base = p;\r\nresp->rqstp->rq_vec[v].iov_len = thislen;\r\nv++;\r\nlen -= thislen;\r\nwhile (len) {\r\nthislen = min_t(long, len, PAGE_SIZE);\r\np = xdr_reserve_space(xdr, (thislen+3)&~3);\r\nWARN_ON_ONCE(!p);\r\nresp->rqstp->rq_vec[v].iov_base = p;\r\nresp->rqstp->rq_vec[v].iov_len = thislen;\r\nv++;\r\nlen -= thislen;\r\n}\r\nread->rd_vlen = v;\r\nnfserr = nfsd_readv(file, read->rd_offset, resp->rqstp->rq_vec,\r\nread->rd_vlen, &maxcount);\r\nif (nfserr)\r\nreturn nfserr;\r\nxdr_truncate_encode(xdr, starting_len + 8 + ((maxcount+3)&~3));\r\neof = (read->rd_offset + maxcount >=\r\nd_inode(read->rd_fhp->fh_dentry)->i_size);\r\ntmp = htonl(eof);\r\nwrite_bytes_to_xdr_buf(xdr->buf, starting_len , &tmp, 4);\r\ntmp = htonl(maxcount);\r\nwrite_bytes_to_xdr_buf(xdr->buf, starting_len + 4, &tmp, 4);\r\npad = (maxcount&3) ? 4 - (maxcount&3) : 0;\r\nwrite_bytes_to_xdr_buf(xdr->buf, starting_len + 8 + maxcount,\r\n&zzz, pad);\r\nreturn 0;\r\n}\r\nstatic __be32\r\nnfsd4_encode_read(struct nfsd4_compoundres *resp, __be32 nfserr,\r\nstruct nfsd4_read *read)\r\n{\r\nunsigned long maxcount;\r\nstruct xdr_stream *xdr = &resp->xdr;\r\nstruct file *file = read->rd_filp;\r\nint starting_len = xdr->buf->len;\r\nstruct raparms *ra = NULL;\r\n__be32 *p;\r\nif (nfserr)\r\ngoto out;\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p) {\r\nWARN_ON_ONCE(test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags));\r\nnfserr = nfserr_resource;\r\ngoto out;\r\n}\r\nif (resp->xdr.buf->page_len &&\r\ntest_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags)) {\r\nWARN_ON_ONCE(1);\r\nnfserr = nfserr_resource;\r\ngoto out;\r\n}\r\nxdr_commit_encode(xdr);\r\nmaxcount = svc_max_payload(resp->rqstp);\r\nmaxcount = min_t(unsigned long, maxcount,\r\n(xdr->buf->buflen - xdr->buf->len));\r\nmaxcount = min_t(unsigned long, maxcount, read->rd_length);\r\nif (read->rd_tmp_file)\r\nra = nfsd_init_raparms(file);\r\nif (file->f_op->splice_read &&\r\ntest_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags))\r\nnfserr = nfsd4_encode_splice_read(resp, read, file, maxcount);\r\nelse\r\nnfserr = nfsd4_encode_readv(resp, read, file, maxcount);\r\nif (ra)\r\nnfsd_put_raparams(file, ra);\r\nif (nfserr)\r\nxdr_truncate_encode(xdr, starting_len);\r\nout:\r\nif (file)\r\nfput(file);\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_readlink(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_readlink *readlink)\r\n{\r\nint maxcount;\r\n__be32 wire_count;\r\nint zero = 0;\r\nstruct xdr_stream *xdr = &resp->xdr;\r\nint length_offset = xdr->buf->len;\r\n__be32 *p;\r\nif (nfserr)\r\nreturn nfserr;\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\nreturn nfserr_resource;\r\nmaxcount = PAGE_SIZE;\r\np = xdr_reserve_space(xdr, maxcount);\r\nif (!p)\r\nreturn nfserr_resource;\r\nnfserr = nfsd_readlink(readlink->rl_rqstp, readlink->rl_fhp,\r\n(char *)p, &maxcount);\r\nif (nfserr == nfserr_isdir)\r\nnfserr = nfserr_inval;\r\nif (nfserr) {\r\nxdr_truncate_encode(xdr, length_offset);\r\nreturn nfserr;\r\n}\r\nwire_count = htonl(maxcount);\r\nwrite_bytes_to_xdr_buf(xdr->buf, length_offset, &wire_count, 4);\r\nxdr_truncate_encode(xdr, length_offset + 4 + ALIGN(maxcount, 4));\r\nif (maxcount & 3)\r\nwrite_bytes_to_xdr_buf(xdr->buf, length_offset + 4 + maxcount,\r\n&zero, 4 - (maxcount&3));\r\nreturn 0;\r\n}\r\nstatic __be32\r\nnfsd4_encode_readdir(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_readdir *readdir)\r\n{\r\nint maxcount;\r\nint bytes_left;\r\nloff_t offset;\r\n__be64 wire_offset;\r\nstruct xdr_stream *xdr = &resp->xdr;\r\nint starting_len = xdr->buf->len;\r\n__be32 *p;\r\nif (nfserr)\r\nreturn nfserr;\r\np = xdr_reserve_space(xdr, NFS4_VERIFIER_SIZE);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(0);\r\n*p++ = cpu_to_be32(0);\r\nresp->xdr.buf->head[0].iov_len = ((char *)resp->xdr.p)\r\n- (char *)resp->xdr.buf->head[0].iov_base;\r\nbytes_left = xdr->buf->buflen - xdr->buf->len\r\n- COMPOUND_ERR_SLACK_SPACE - 8;\r\nif (bytes_left < 0) {\r\nnfserr = nfserr_resource;\r\ngoto err_no_verf;\r\n}\r\nmaxcount = min_t(u32, readdir->rd_maxcount, INT_MAX);\r\nif (maxcount < 16) {\r\nnfserr = nfserr_toosmall;\r\ngoto err_no_verf;\r\n}\r\nmaxcount = min_t(int, maxcount-16, bytes_left);\r\nif (!readdir->rd_dircount)\r\nreaddir->rd_dircount = INT_MAX;\r\nreaddir->xdr = xdr;\r\nreaddir->rd_maxcount = maxcount;\r\nreaddir->common.err = 0;\r\nreaddir->cookie_offset = 0;\r\noffset = readdir->rd_cookie;\r\nnfserr = nfsd_readdir(readdir->rd_rqstp, readdir->rd_fhp,\r\n&offset,\r\n&readdir->common, nfsd4_encode_dirent);\r\nif (nfserr == nfs_ok &&\r\nreaddir->common.err == nfserr_toosmall &&\r\nxdr->buf->len == starting_len + 8) {\r\nif (maxcount - 16 < bytes_left)\r\nnfserr = nfserr_toosmall;\r\nelse\r\nnfserr = nfserr_resource;\r\n}\r\nif (nfserr)\r\ngoto err_no_verf;\r\nif (readdir->cookie_offset) {\r\nwire_offset = cpu_to_be64(offset);\r\nwrite_bytes_to_xdr_buf(xdr->buf, readdir->cookie_offset,\r\n&wire_offset, 8);\r\n}\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p) {\r\nWARN_ON_ONCE(1);\r\ngoto err_no_verf;\r\n}\r\n*p++ = 0;\r\n*p++ = htonl(readdir->common.err == nfserr_eof);\r\nreturn 0;\r\nerr_no_verf:\r\nxdr_truncate_encode(xdr, starting_len);\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_remove(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_remove *remove)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\n__be32 *p;\r\nif (!nfserr) {\r\np = xdr_reserve_space(xdr, 20);\r\nif (!p)\r\nreturn nfserr_resource;\r\np = encode_cinfo(p, &remove->rm_cinfo);\r\n}\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_rename(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_rename *rename)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\n__be32 *p;\r\nif (!nfserr) {\r\np = xdr_reserve_space(xdr, 40);\r\nif (!p)\r\nreturn nfserr_resource;\r\np = encode_cinfo(p, &rename->rn_sinfo);\r\np = encode_cinfo(p, &rename->rn_tinfo);\r\n}\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_do_encode_secinfo(struct xdr_stream *xdr,\r\n__be32 nfserr, struct svc_export *exp)\r\n{\r\nu32 i, nflavs, supported;\r\nstruct exp_flavor_info *flavs;\r\nstruct exp_flavor_info def_flavs[2];\r\n__be32 *p, *flavorsp;\r\nstatic bool report = true;\r\nif (nfserr)\r\ngoto out;\r\nnfserr = nfserr_resource;\r\nif (exp->ex_nflavors) {\r\nflavs = exp->ex_flavors;\r\nnflavs = exp->ex_nflavors;\r\n} else {\r\nflavs = def_flavs;\r\nif (exp->ex_client->flavour->flavour == RPC_AUTH_UNIX) {\r\nnflavs = 2;\r\nflavs[0].pseudoflavor = RPC_AUTH_UNIX;\r\nflavs[1].pseudoflavor = RPC_AUTH_NULL;\r\n} else if (exp->ex_client->flavour->flavour == RPC_AUTH_GSS) {\r\nnflavs = 1;\r\nflavs[0].pseudoflavor\r\n= svcauth_gss_flavor(exp->ex_client);\r\n} else {\r\nnflavs = 1;\r\nflavs[0].pseudoflavor\r\n= exp->ex_client->flavour->flavour;\r\n}\r\n}\r\nsupported = 0;\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out;\r\nflavorsp = p++;\r\nfor (i = 0; i < nflavs; i++) {\r\nrpc_authflavor_t pf = flavs[i].pseudoflavor;\r\nstruct rpcsec_gss_info info;\r\nif (rpcauth_get_gssinfo(pf, &info) == 0) {\r\nsupported++;\r\np = xdr_reserve_space(xdr, 4 + 4 +\r\nXDR_LEN(info.oid.len) + 4 + 4);\r\nif (!p)\r\ngoto out;\r\n*p++ = cpu_to_be32(RPC_AUTH_GSS);\r\np = xdr_encode_opaque(p, info.oid.data, info.oid.len);\r\n*p++ = cpu_to_be32(info.qop);\r\n*p++ = cpu_to_be32(info.service);\r\n} else if (pf < RPC_AUTH_MAXFLAVOR) {\r\nsupported++;\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out;\r\n*p++ = cpu_to_be32(pf);\r\n} else {\r\nif (report)\r\npr_warn("NFS: SECINFO: security flavor %u "\r\n"is not supported\n", pf);\r\n}\r\n}\r\nif (nflavs != supported)\r\nreport = false;\r\n*flavorsp = htonl(supported);\r\nnfserr = 0;\r\nout:\r\nif (exp)\r\nexp_put(exp);\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_secinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\r\nstruct nfsd4_secinfo *secinfo)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\nreturn nfsd4_do_encode_secinfo(xdr, nfserr, secinfo->si_exp);\r\n}\r\nstatic __be32\r\nnfsd4_encode_secinfo_no_name(struct nfsd4_compoundres *resp, __be32 nfserr,\r\nstruct nfsd4_secinfo_no_name *secinfo)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\nreturn nfsd4_do_encode_secinfo(xdr, nfserr, secinfo->sin_exp);\r\n}\r\nstatic __be32\r\nnfsd4_encode_setattr(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_setattr *setattr)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, 16);\r\nif (!p)\r\nreturn nfserr_resource;\r\nif (nfserr) {\r\n*p++ = cpu_to_be32(3);\r\n*p++ = cpu_to_be32(0);\r\n*p++ = cpu_to_be32(0);\r\n*p++ = cpu_to_be32(0);\r\n}\r\nelse {\r\n*p++ = cpu_to_be32(3);\r\n*p++ = cpu_to_be32(setattr->sa_bmval[0]);\r\n*p++ = cpu_to_be32(setattr->sa_bmval[1]);\r\n*p++ = cpu_to_be32(setattr->sa_bmval[2]);\r\n}\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_setclientid(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_setclientid *scd)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\n__be32 *p;\r\nif (!nfserr) {\r\np = xdr_reserve_space(xdr, 8 + NFS4_VERIFIER_SIZE);\r\nif (!p)\r\nreturn nfserr_resource;\r\np = xdr_encode_opaque_fixed(p, &scd->se_clientid, 8);\r\np = xdr_encode_opaque_fixed(p, &scd->se_confirm,\r\nNFS4_VERIFIER_SIZE);\r\n}\r\nelse if (nfserr == nfserr_clid_inuse) {\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(0);\r\n*p++ = cpu_to_be32(0);\r\n}\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_write(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_write *write)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\n__be32 *p;\r\nif (!nfserr) {\r\np = xdr_reserve_space(xdr, 16);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(write->wr_bytes_written);\r\n*p++ = cpu_to_be32(write->wr_how_written);\r\np = xdr_encode_opaque_fixed(p, write->wr_verifier.data,\r\nNFS4_VERIFIER_SIZE);\r\n}\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_exchange_id(struct nfsd4_compoundres *resp, __be32 nfserr,\r\nstruct nfsd4_exchange_id *exid)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\n__be32 *p;\r\nchar *major_id;\r\nchar *server_scope;\r\nint major_id_sz;\r\nint server_scope_sz;\r\nuint64_t minor_id = 0;\r\nif (nfserr)\r\nreturn nfserr;\r\nmajor_id = utsname()->nodename;\r\nmajor_id_sz = strlen(major_id);\r\nserver_scope = utsname()->nodename;\r\nserver_scope_sz = strlen(server_scope);\r\np = xdr_reserve_space(xdr,\r\n8 +\r\n4 +\r\n4 +\r\n4 );\r\nif (!p)\r\nreturn nfserr_resource;\r\np = xdr_encode_opaque_fixed(p, &exid->clientid, 8);\r\n*p++ = cpu_to_be32(exid->seqid);\r\n*p++ = cpu_to_be32(exid->flags);\r\n*p++ = cpu_to_be32(exid->spa_how);\r\nswitch (exid->spa_how) {\r\ncase SP4_NONE:\r\nbreak;\r\ncase SP4_MACH_CRED:\r\np = xdr_reserve_space(xdr, 16);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(2);\r\n*p++ = cpu_to_be32(nfs4_minimal_spo_must_enforce[0]);\r\n*p++ = cpu_to_be32(nfs4_minimal_spo_must_enforce[1]);\r\n*p++ = cpu_to_be32(0);\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\n}\r\np = xdr_reserve_space(xdr,\r\n8 +\r\n4 +\r\n(XDR_QUADLEN(major_id_sz) * 4) +\r\n4 +\r\n(XDR_QUADLEN(server_scope_sz) * 4) +\r\n4 );\r\nif (!p)\r\nreturn nfserr_resource;\r\np = xdr_encode_hyper(p, minor_id);\r\np = xdr_encode_opaque(p, major_id, major_id_sz);\r\np = xdr_encode_opaque(p, server_scope, server_scope_sz);\r\n*p++ = cpu_to_be32(0);\r\nreturn 0;\r\n}\r\nstatic __be32\r\nnfsd4_encode_create_session(struct nfsd4_compoundres *resp, __be32 nfserr,\r\nstruct nfsd4_create_session *sess)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\n__be32 *p;\r\nif (nfserr)\r\nreturn nfserr;\r\np = xdr_reserve_space(xdr, 24);\r\nif (!p)\r\nreturn nfserr_resource;\r\np = xdr_encode_opaque_fixed(p, sess->sessionid.data,\r\nNFS4_MAX_SESSIONID_LEN);\r\n*p++ = cpu_to_be32(sess->seqid);\r\n*p++ = cpu_to_be32(sess->flags);\r\np = xdr_reserve_space(xdr, 28);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(0);\r\n*p++ = cpu_to_be32(sess->fore_channel.maxreq_sz);\r\n*p++ = cpu_to_be32(sess->fore_channel.maxresp_sz);\r\n*p++ = cpu_to_be32(sess->fore_channel.maxresp_cached);\r\n*p++ = cpu_to_be32(sess->fore_channel.maxops);\r\n*p++ = cpu_to_be32(sess->fore_channel.maxreqs);\r\n*p++ = cpu_to_be32(sess->fore_channel.nr_rdma_attrs);\r\nif (sess->fore_channel.nr_rdma_attrs) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(sess->fore_channel.rdma_attrs);\r\n}\r\np = xdr_reserve_space(xdr, 28);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(0);\r\n*p++ = cpu_to_be32(sess->back_channel.maxreq_sz);\r\n*p++ = cpu_to_be32(sess->back_channel.maxresp_sz);\r\n*p++ = cpu_to_be32(sess->back_channel.maxresp_cached);\r\n*p++ = cpu_to_be32(sess->back_channel.maxops);\r\n*p++ = cpu_to_be32(sess->back_channel.maxreqs);\r\n*p++ = cpu_to_be32(sess->back_channel.nr_rdma_attrs);\r\nif (sess->back_channel.nr_rdma_attrs) {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(sess->back_channel.rdma_attrs);\r\n}\r\nreturn 0;\r\n}\r\nstatic __be32\r\nnfsd4_encode_sequence(struct nfsd4_compoundres *resp, __be32 nfserr,\r\nstruct nfsd4_sequence *seq)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\n__be32 *p;\r\nif (nfserr)\r\nreturn nfserr;\r\np = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN + 20);\r\nif (!p)\r\nreturn nfserr_resource;\r\np = xdr_encode_opaque_fixed(p, seq->sessionid.data,\r\nNFS4_MAX_SESSIONID_LEN);\r\n*p++ = cpu_to_be32(seq->seqid);\r\n*p++ = cpu_to_be32(seq->slotid);\r\n*p++ = cpu_to_be32(seq->maxslots - 1);\r\n*p++ = cpu_to_be32(seq->maxslots - 1);\r\n*p++ = cpu_to_be32(seq->status_flags);\r\nresp->cstate.data_offset = xdr->buf->len;\r\nreturn 0;\r\n}\r\nstatic __be32\r\nnfsd4_encode_test_stateid(struct nfsd4_compoundres *resp, __be32 nfserr,\r\nstruct nfsd4_test_stateid *test_stateid)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\nstruct nfsd4_test_stateid_id *stateid, *next;\r\n__be32 *p;\r\nif (nfserr)\r\nreturn nfserr;\r\np = xdr_reserve_space(xdr, 4 + (4 * test_stateid->ts_num_ids));\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = htonl(test_stateid->ts_num_ids);\r\nlist_for_each_entry_safe(stateid, next, &test_stateid->ts_stateid_list, ts_id_list) {\r\n*p++ = stateid->ts_id_status;\r\n}\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\r\nstruct nfsd4_getdeviceinfo *gdev)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\nconst struct nfsd4_layout_ops *ops =\r\nnfsd4_layout_ops[gdev->gd_layout_type];\r\nu32 starting_len = xdr->buf->len, needed_len;\r\n__be32 *p;\r\ndprintk("%s: err %d\n", __func__, nfserr);\r\nif (nfserr)\r\ngoto out;\r\nnfserr = nfserr_resource;\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out;\r\n*p++ = cpu_to_be32(gdev->gd_layout_type);\r\nif (gdev->gd_maxcount != 0) {\r\nnfserr = ops->encode_getdeviceinfo(xdr, gdev);\r\nif (nfserr) {\r\nif (xdr->buf->len + 4 > gdev->gd_maxcount)\r\ngoto toosmall;\r\ngoto out;\r\n}\r\n}\r\nnfserr = nfserr_resource;\r\nif (gdev->gd_notify_types) {\r\np = xdr_reserve_space(xdr, 4 + 4);\r\nif (!p)\r\ngoto out;\r\n*p++ = cpu_to_be32(1);\r\n*p++ = cpu_to_be32(gdev->gd_notify_types);\r\n} else {\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\ngoto out;\r\n*p++ = 0;\r\n}\r\nnfserr = 0;\r\nout:\r\nkfree(gdev->gd_device);\r\ndprintk("%s: done: %d\n", __func__, be32_to_cpu(nfserr));\r\nreturn nfserr;\r\ntoosmall:\r\ndprintk("%s: maxcount too small\n", __func__);\r\nneeded_len = xdr->buf->len + 4 ;\r\nxdr_truncate_encode(xdr, starting_len);\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p) {\r\nnfserr = nfserr_resource;\r\n} else {\r\n*p++ = cpu_to_be32(needed_len);\r\nnfserr = nfserr_toosmall;\r\n}\r\ngoto out;\r\n}\r\nstatic __be32\r\nnfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\r\nstruct nfsd4_layoutget *lgp)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\nconst struct nfsd4_layout_ops *ops =\r\nnfsd4_layout_ops[lgp->lg_layout_type];\r\n__be32 *p;\r\ndprintk("%s: err %d\n", __func__, nfserr);\r\nif (nfserr)\r\ngoto out;\r\nnfserr = nfserr_resource;\r\np = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));\r\nif (!p)\r\ngoto out;\r\n*p++ = cpu_to_be32(1);\r\n*p++ = cpu_to_be32(lgp->lg_sid.si_generation);\r\np = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,\r\nsizeof(stateid_opaque_t));\r\n*p++ = cpu_to_be32(1);\r\np = xdr_encode_hyper(p, lgp->lg_seg.offset);\r\np = xdr_encode_hyper(p, lgp->lg_seg.length);\r\n*p++ = cpu_to_be32(lgp->lg_seg.iomode);\r\n*p++ = cpu_to_be32(lgp->lg_layout_type);\r\nnfserr = ops->encode_layoutget(xdr, lgp);\r\nout:\r\nkfree(lgp->lg_content);\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_layoutcommit(struct nfsd4_compoundres *resp, __be32 nfserr,\r\nstruct nfsd4_layoutcommit *lcp)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\n__be32 *p;\r\nif (nfserr)\r\nreturn nfserr;\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(lcp->lc_size_chg);\r\nif (lcp->lc_size_chg) {\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\nreturn nfserr_resource;\r\np = xdr_encode_hyper(p, lcp->lc_newsize);\r\n}\r\nreturn nfs_ok;\r\n}\r\nstatic __be32\r\nnfsd4_encode_layoutreturn(struct nfsd4_compoundres *resp, __be32 nfserr,\r\nstruct nfsd4_layoutreturn *lrp)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\n__be32 *p;\r\nif (nfserr)\r\nreturn nfserr;\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\nreturn nfserr_resource;\r\n*p++ = cpu_to_be32(lrp->lrs_present);\r\nif (lrp->lrs_present)\r\nreturn nfsd4_encode_stateid(xdr, &lrp->lr_sid);\r\nreturn nfs_ok;\r\n}\r\nstatic __be32\r\nnfsd4_encode_seek(struct nfsd4_compoundres *resp, __be32 nfserr,\r\nstruct nfsd4_seek *seek)\r\n{\r\n__be32 *p;\r\nif (nfserr)\r\nreturn nfserr;\r\np = xdr_reserve_space(&resp->xdr, 4 + 8);\r\n*p++ = cpu_to_be32(seek->seek_eof);\r\np = xdr_encode_hyper(p, seek->seek_pos);\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd4_encode_noop(struct nfsd4_compoundres *resp, __be32 nfserr, void *p)\r\n{\r\nreturn nfserr;\r\n}\r\n__be32 nfsd4_check_resp_size(struct nfsd4_compoundres *resp, u32 respsize)\r\n{\r\nstruct xdr_buf *buf = &resp->rqstp->rq_res;\r\nstruct nfsd4_slot *slot = resp->cstate.slot;\r\nif (buf->len + respsize <= buf->buflen)\r\nreturn nfs_ok;\r\nif (!nfsd4_has_session(&resp->cstate))\r\nreturn nfserr_resource;\r\nif (slot->sl_flags & NFSD4_SLOT_CACHETHIS) {\r\nWARN_ON_ONCE(1);\r\nreturn nfserr_rep_too_big_to_cache;\r\n}\r\nreturn nfserr_rep_too_big;\r\n}\r\nvoid\r\nnfsd4_encode_operation(struct nfsd4_compoundres *resp, struct nfsd4_op *op)\r\n{\r\nstruct xdr_stream *xdr = &resp->xdr;\r\nstruct nfs4_stateowner *so = resp->cstate.replay_owner;\r\nstruct svc_rqst *rqstp = resp->rqstp;\r\nint post_err_offset;\r\nnfsd4_enc encoder;\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p) {\r\nWARN_ON_ONCE(1);\r\nreturn;\r\n}\r\n*p++ = cpu_to_be32(op->opnum);\r\npost_err_offset = xdr->buf->len;\r\nif (op->opnum == OP_ILLEGAL)\r\ngoto status;\r\nBUG_ON(op->opnum < 0 || op->opnum >= ARRAY_SIZE(nfsd4_enc_ops) ||\r\n!nfsd4_enc_ops[op->opnum]);\r\nencoder = nfsd4_enc_ops[op->opnum];\r\nop->status = encoder(resp, op->status, &op->u);\r\nxdr_commit_encode(xdr);\r\nif (!op->status) {\r\nint space_needed = 0;\r\nif (!nfsd4_last_compound_op(rqstp))\r\nspace_needed = COMPOUND_ERR_SLACK_SPACE;\r\nop->status = nfsd4_check_resp_size(resp, space_needed);\r\n}\r\nif (op->status == nfserr_resource && nfsd4_has_session(&resp->cstate)) {\r\nstruct nfsd4_slot *slot = resp->cstate.slot;\r\nif (slot->sl_flags & NFSD4_SLOT_CACHETHIS)\r\nop->status = nfserr_rep_too_big_to_cache;\r\nelse\r\nop->status = nfserr_rep_too_big;\r\n}\r\nif (op->status == nfserr_resource ||\r\nop->status == nfserr_rep_too_big ||\r\nop->status == nfserr_rep_too_big_to_cache) {\r\nwarn_on_nonidempotent_op(op);\r\nxdr_truncate_encode(xdr, post_err_offset);\r\n}\r\nif (so) {\r\nint len = xdr->buf->len - post_err_offset;\r\nso->so_replay.rp_status = op->status;\r\nso->so_replay.rp_buflen = len;\r\nread_bytes_from_xdr_buf(xdr->buf, post_err_offset,\r\nso->so_replay.rp_buf, len);\r\n}\r\nstatus:\r\nwrite_bytes_to_xdr_buf(xdr->buf, post_err_offset - 4, &op->status, 4);\r\n}\r\nvoid\r\nnfsd4_encode_replay(struct xdr_stream *xdr, struct nfsd4_op *op)\r\n{\r\n__be32 *p;\r\nstruct nfs4_replay *rp = op->replay;\r\nBUG_ON(!rp);\r\np = xdr_reserve_space(xdr, 8 + rp->rp_buflen);\r\nif (!p) {\r\nWARN_ON_ONCE(1);\r\nreturn;\r\n}\r\n*p++ = cpu_to_be32(op->opnum);\r\n*p++ = rp->rp_status;\r\np = xdr_encode_opaque_fixed(p, rp->rp_buf, rp->rp_buflen);\r\n}\r\nint\r\nnfs4svc_encode_voidres(struct svc_rqst *rqstp, __be32 *p, void *dummy)\r\n{\r\nreturn xdr_ressize_check(rqstp, p);\r\n}\r\nint nfsd4_release_compoundargs(void *rq, __be32 *p, void *resp)\r\n{\r\nstruct svc_rqst *rqstp = rq;\r\nstruct nfsd4_compoundargs *args = rqstp->rq_argp;\r\nif (args->ops != args->iops) {\r\nkfree(args->ops);\r\nargs->ops = args->iops;\r\n}\r\nkfree(args->tmpp);\r\nargs->tmpp = NULL;\r\nwhile (args->to_free) {\r\nstruct svcxdr_tmpbuf *tb = args->to_free;\r\nargs->to_free = tb->next;\r\nkfree(tb);\r\n}\r\nreturn 1;\r\n}\r\nint\r\nnfs4svc_decode_compoundargs(struct svc_rqst *rqstp, __be32 *p, struct nfsd4_compoundargs *args)\r\n{\r\nif (rqstp->rq_arg.head[0].iov_len % 4) {\r\ndprintk("%s: compound not properly padded! (peeraddr=%pISc xid=0x%x)",\r\n__func__, svc_addr(rqstp), be32_to_cpu(rqstp->rq_xid));\r\nreturn 0;\r\n}\r\nargs->p = p;\r\nargs->end = rqstp->rq_arg.head[0].iov_base + rqstp->rq_arg.head[0].iov_len;\r\nargs->pagelist = rqstp->rq_arg.pages;\r\nargs->pagelen = rqstp->rq_arg.page_len;\r\nargs->tmpp = NULL;\r\nargs->to_free = NULL;\r\nargs->ops = args->iops;\r\nargs->rqstp = rqstp;\r\nreturn !nfsd4_decode_compound(args);\r\n}\r\nint\r\nnfs4svc_encode_compoundres(struct svc_rqst *rqstp, __be32 *p, struct nfsd4_compoundres *resp)\r\n{\r\nstruct xdr_buf *buf = resp->xdr.buf;\r\nWARN_ON_ONCE(buf->len != buf->head[0].iov_len + buf->page_len +\r\nbuf->tail[0].iov_len);\r\nrqstp->rq_next_page = resp->xdr.page_ptr + 1;\r\np = resp->tagp;\r\n*p++ = htonl(resp->taglen);\r\nmemcpy(p, resp->tag, resp->taglen);\r\np += XDR_QUADLEN(resp->taglen);\r\n*p++ = htonl(resp->opcnt);\r\nnfsd4_sequence_done(resp);\r\nreturn 1;\r\n}
