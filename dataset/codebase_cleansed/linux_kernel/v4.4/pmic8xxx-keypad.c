static u8 pmic8xxx_col_state(struct pmic8xxx_kp *kp, u8 col)\r\n{\r\nif (col == 0x00)\r\nreturn 1 << kp->num_cols;\r\nelse\r\nreturn col & ((1 << kp->num_cols) - 1);\r\n}\r\nstatic int pmic8xxx_chk_sync_read(struct pmic8xxx_kp *kp)\r\n{\r\nint rc;\r\nunsigned int scan_val;\r\nrc = regmap_read(kp->regmap, KEYP_SCAN, &scan_val);\r\nif (rc < 0) {\r\ndev_err(kp->dev, "Error reading KEYP_SCAN reg, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nscan_val |= 0x1;\r\nrc = regmap_write(kp->regmap, KEYP_SCAN, scan_val);\r\nif (rc < 0) {\r\ndev_err(kp->dev, "Error writing KEYP_SCAN reg, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nudelay((2 * DIV_ROUND_UP(USEC_PER_SEC, KEYP_CLOCK_FREQ)) + 1);\r\nreturn rc;\r\n}\r\nstatic int pmic8xxx_kp_read_data(struct pmic8xxx_kp *kp, u16 *state,\r\nu16 data_reg, int read_rows)\r\n{\r\nint rc, row;\r\nunsigned int val;\r\nfor (row = 0; row < read_rows; row++) {\r\nrc = regmap_read(kp->regmap, data_reg, &val);\r\nif (rc)\r\nreturn rc;\r\ndev_dbg(kp->dev, "%d = %d\n", row, val);\r\nstate[row] = pmic8xxx_col_state(kp, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pmic8xxx_kp_read_matrix(struct pmic8xxx_kp *kp, u16 *new_state,\r\nu16 *old_state)\r\n{\r\nint rc, read_rows;\r\nunsigned int scan_val;\r\nif (kp->num_rows < PM8XXX_MIN_ROWS)\r\nread_rows = PM8XXX_MIN_ROWS;\r\nelse\r\nread_rows = kp->num_rows;\r\npmic8xxx_chk_sync_read(kp);\r\nif (old_state) {\r\nrc = pmic8xxx_kp_read_data(kp, old_state, KEYP_OLD_DATA,\r\nread_rows);\r\nif (rc < 0) {\r\ndev_err(kp->dev,\r\n"Error reading KEYP_OLD_DATA, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\n}\r\nrc = pmic8xxx_kp_read_data(kp, new_state, KEYP_RECENT_DATA,\r\nread_rows);\r\nif (rc < 0) {\r\ndev_err(kp->dev,\r\n"Error reading KEYP_RECENT_DATA, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nudelay((4 * DIV_ROUND_UP(USEC_PER_SEC, KEYP_CLOCK_FREQ)) + 1);\r\nrc = regmap_read(kp->regmap, KEYP_SCAN, &scan_val);\r\nif (rc < 0) {\r\ndev_err(kp->dev, "Error reading KEYP_SCAN reg, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nscan_val &= 0xFE;\r\nrc = regmap_write(kp->regmap, KEYP_SCAN, scan_val);\r\nif (rc < 0)\r\ndev_err(kp->dev, "Error writing KEYP_SCAN reg, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nstatic void __pmic8xxx_kp_scan_matrix(struct pmic8xxx_kp *kp, u16 *new_state,\r\nu16 *old_state)\r\n{\r\nint row, col, code;\r\nfor (row = 0; row < kp->num_rows; row++) {\r\nint bits_changed = new_state[row] ^ old_state[row];\r\nif (!bits_changed)\r\ncontinue;\r\nfor (col = 0; col < kp->num_cols; col++) {\r\nif (!(bits_changed & (1 << col)))\r\ncontinue;\r\ndev_dbg(kp->dev, "key [%d:%d] %s\n", row, col,\r\n!(new_state[row] & (1 << col)) ?\r\n"pressed" : "released");\r\ncode = MATRIX_SCAN_CODE(row, col, PM8XXX_ROW_SHIFT);\r\ninput_event(kp->input, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(kp->input,\r\nkp->keycodes[code],\r\n!(new_state[row] & (1 << col)));\r\ninput_sync(kp->input);\r\n}\r\n}\r\n}\r\nstatic bool pmic8xxx_detect_ghost_keys(struct pmic8xxx_kp *kp, u16 *new_state)\r\n{\r\nint row, found_first = -1;\r\nu16 check, row_state;\r\ncheck = 0;\r\nfor (row = 0; row < kp->num_rows; row++) {\r\nrow_state = (~new_state[row]) &\r\n((1 << kp->num_cols) - 1);\r\nif (hweight16(row_state) > 1) {\r\nif (found_first == -1)\r\nfound_first = row;\r\nif (check & row_state) {\r\ndev_dbg(kp->dev, "detected ghost key on row[%d]"\r\n" and row[%d]\n", found_first, row);\r\nreturn true;\r\n}\r\n}\r\ncheck |= row_state;\r\n}\r\nreturn false;\r\n}\r\nstatic int pmic8xxx_kp_scan_matrix(struct pmic8xxx_kp *kp, unsigned int events)\r\n{\r\nu16 new_state[PM8XXX_MAX_ROWS];\r\nu16 old_state[PM8XXX_MAX_ROWS];\r\nint rc;\r\nswitch (events) {\r\ncase 0x1:\r\nrc = pmic8xxx_kp_read_matrix(kp, new_state, NULL);\r\nif (rc < 0)\r\nreturn rc;\r\nif (pmic8xxx_detect_ghost_keys(kp, new_state))\r\nreturn 0;\r\n__pmic8xxx_kp_scan_matrix(kp, new_state, kp->keystate);\r\nmemcpy(kp->keystate, new_state, sizeof(new_state));\r\nbreak;\r\ncase 0x3:\r\nrc = pmic8xxx_kp_read_matrix(kp, new_state, old_state);\r\nif (rc < 0)\r\nreturn rc;\r\n__pmic8xxx_kp_scan_matrix(kp, old_state, kp->keystate);\r\n__pmic8xxx_kp_scan_matrix(kp, new_state, old_state);\r\nmemcpy(kp->keystate, new_state, sizeof(new_state));\r\nbreak;\r\ncase 0x2:\r\ndev_dbg(kp->dev, "Some key events were lost\n");\r\nrc = pmic8xxx_kp_read_matrix(kp, new_state, old_state);\r\nif (rc < 0)\r\nreturn rc;\r\n__pmic8xxx_kp_scan_matrix(kp, old_state, kp->keystate);\r\n__pmic8xxx_kp_scan_matrix(kp, new_state, old_state);\r\nmemcpy(kp->keystate, new_state, sizeof(new_state));\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\n}\r\nreturn rc;\r\n}\r\nstatic irqreturn_t pmic8xxx_kp_stuck_irq(int irq, void *data)\r\n{\r\nu16 new_state[PM8XXX_MAX_ROWS];\r\nu16 old_state[PM8XXX_MAX_ROWS];\r\nint rc;\r\nstruct pmic8xxx_kp *kp = data;\r\nrc = pmic8xxx_kp_read_matrix(kp, new_state, old_state);\r\nif (rc < 0) {\r\ndev_err(kp->dev, "failed to read keypad matrix\n");\r\nreturn IRQ_HANDLED;\r\n}\r\n__pmic8xxx_kp_scan_matrix(kp, new_state, kp->stuckstate);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t pmic8xxx_kp_irq(int irq, void *data)\r\n{\r\nstruct pmic8xxx_kp *kp = data;\r\nunsigned int ctrl_val, events;\r\nint rc;\r\nrc = regmap_read(kp->regmap, KEYP_CTRL, &ctrl_val);\r\nif (rc < 0) {\r\ndev_err(kp->dev, "failed to read keyp_ctrl register\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nevents = ctrl_val & KEYP_CTRL_EVNTS_MASK;\r\nrc = pmic8xxx_kp_scan_matrix(kp, events);\r\nif (rc < 0)\r\ndev_err(kp->dev, "failed to scan matrix\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pmic8xxx_kpd_init(struct pmic8xxx_kp *kp,\r\nstruct platform_device *pdev)\r\n{\r\nconst struct device_node *of_node = pdev->dev.of_node;\r\nunsigned int scan_delay_ms;\r\nunsigned int row_hold_ns;\r\nunsigned int debounce_ms;\r\nint bits, rc, cycles;\r\nu8 scan_val = 0, ctrl_val = 0;\r\nstatic const u8 row_bits[] = {\r\n0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 7, 7, 7,\r\n};\r\nif (kp->num_cols < KEYP_CTRL_SCAN_COLS_MIN)\r\nbits = 0;\r\nelse\r\nbits = kp->num_cols - KEYP_CTRL_SCAN_COLS_MIN;\r\nctrl_val = (bits & KEYP_CTRL_SCAN_COLS_BITS) <<\r\nKEYP_CTRL_SCAN_COLS_SHIFT;\r\nif (kp->num_rows < KEYP_CTRL_SCAN_ROWS_MIN)\r\nbits = 0;\r\nelse\r\nbits = row_bits[kp->num_rows - KEYP_CTRL_SCAN_ROWS_MIN];\r\nctrl_val |= (bits << KEYP_CTRL_SCAN_ROWS_SHIFT);\r\nrc = regmap_write(kp->regmap, KEYP_CTRL, ctrl_val);\r\nif (rc < 0) {\r\ndev_err(kp->dev, "Error writing KEYP_CTRL reg, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nif (of_property_read_u32(of_node, "scan-delay", &scan_delay_ms))\r\nscan_delay_ms = MIN_SCAN_DELAY;\r\nif (scan_delay_ms > MAX_SCAN_DELAY || scan_delay_ms < MIN_SCAN_DELAY ||\r\n!is_power_of_2(scan_delay_ms)) {\r\ndev_err(&pdev->dev, "invalid keypad scan time supplied\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_u32(of_node, "row-hold", &row_hold_ns))\r\nrow_hold_ns = MIN_ROW_HOLD_DELAY;\r\nif (row_hold_ns > MAX_ROW_HOLD_DELAY ||\r\nrow_hold_ns < MIN_ROW_HOLD_DELAY ||\r\n((row_hold_ns % MIN_ROW_HOLD_DELAY) != 0)) {\r\ndev_err(&pdev->dev, "invalid keypad row hold time supplied\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_u32(of_node, "debounce", &debounce_ms))\r\ndebounce_ms = MIN_DEBOUNCE_TIME;\r\nif (((debounce_ms % 5) != 0) ||\r\ndebounce_ms > MAX_DEBOUNCE_TIME ||\r\ndebounce_ms < MIN_DEBOUNCE_TIME) {\r\ndev_err(&pdev->dev, "invalid debounce time supplied\n");\r\nreturn -EINVAL;\r\n}\r\nbits = (debounce_ms / 5) - 1;\r\nscan_val |= (bits << KEYP_SCAN_DBOUNCE_SHIFT);\r\nbits = fls(scan_delay_ms) - 1;\r\nscan_val |= (bits << KEYP_SCAN_PAUSE_SHIFT);\r\ncycles = (row_hold_ns * KEYP_CLOCK_FREQ) / NSEC_PER_SEC;\r\nscan_val |= (cycles << KEYP_SCAN_ROW_HOLD_SHIFT);\r\nrc = regmap_write(kp->regmap, KEYP_SCAN, scan_val);\r\nif (rc)\r\ndev_err(kp->dev, "Error writing KEYP_SCAN reg, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int pmic8xxx_kp_enable(struct pmic8xxx_kp *kp)\r\n{\r\nint rc;\r\nkp->ctrl_reg |= KEYP_CTRL_KEYP_EN;\r\nrc = regmap_write(kp->regmap, KEYP_CTRL, kp->ctrl_reg);\r\nif (rc < 0)\r\ndev_err(kp->dev, "Error writing KEYP_CTRL reg, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int pmic8xxx_kp_disable(struct pmic8xxx_kp *kp)\r\n{\r\nint rc;\r\nkp->ctrl_reg &= ~KEYP_CTRL_KEYP_EN;\r\nrc = regmap_write(kp->regmap, KEYP_CTRL, kp->ctrl_reg);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn rc;\r\n}\r\nstatic int pmic8xxx_kp_open(struct input_dev *dev)\r\n{\r\nstruct pmic8xxx_kp *kp = input_get_drvdata(dev);\r\nreturn pmic8xxx_kp_enable(kp);\r\n}\r\nstatic void pmic8xxx_kp_close(struct input_dev *dev)\r\n{\r\nstruct pmic8xxx_kp *kp = input_get_drvdata(dev);\r\npmic8xxx_kp_disable(kp);\r\n}\r\nstatic int pmic8xxx_kp_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nunsigned int rows, cols;\r\nbool repeat;\r\nbool wakeup;\r\nstruct pmic8xxx_kp *kp;\r\nint rc;\r\nunsigned int ctrl_val;\r\nrc = matrix_keypad_parse_of_params(&pdev->dev, &rows, &cols);\r\nif (rc)\r\nreturn rc;\r\nif (cols > PM8XXX_MAX_COLS || rows > PM8XXX_MAX_ROWS ||\r\ncols < PM8XXX_MIN_COLS) {\r\ndev_err(&pdev->dev, "invalid platform data\n");\r\nreturn -EINVAL;\r\n}\r\nrepeat = !of_property_read_bool(np, "linux,input-no-autorepeat");\r\nwakeup = of_property_read_bool(np, "wakeup-source") ||\r\nof_property_read_bool(np, "linux,keypad-wakeup");\r\nkp = devm_kzalloc(&pdev->dev, sizeof(*kp), GFP_KERNEL);\r\nif (!kp)\r\nreturn -ENOMEM;\r\nkp->regmap = dev_get_regmap(pdev->dev.parent, NULL);\r\nif (!kp->regmap)\r\nreturn -ENODEV;\r\nplatform_set_drvdata(pdev, kp);\r\nkp->num_rows = rows;\r\nkp->num_cols = cols;\r\nkp->dev = &pdev->dev;\r\nkp->input = devm_input_allocate_device(&pdev->dev);\r\nif (!kp->input) {\r\ndev_err(&pdev->dev, "unable to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\nkp->key_sense_irq = platform_get_irq(pdev, 0);\r\nif (kp->key_sense_irq < 0) {\r\ndev_err(&pdev->dev, "unable to get keypad sense irq\n");\r\nreturn kp->key_sense_irq;\r\n}\r\nkp->key_stuck_irq = platform_get_irq(pdev, 1);\r\nif (kp->key_stuck_irq < 0) {\r\ndev_err(&pdev->dev, "unable to get keypad stuck irq\n");\r\nreturn kp->key_stuck_irq;\r\n}\r\nkp->input->name = "PMIC8XXX keypad";\r\nkp->input->phys = "pmic8xxx_keypad/input0";\r\nkp->input->id.bustype = BUS_I2C;\r\nkp->input->id.version = 0x0001;\r\nkp->input->id.product = 0x0001;\r\nkp->input->id.vendor = 0x0001;\r\nkp->input->open = pmic8xxx_kp_open;\r\nkp->input->close = pmic8xxx_kp_close;\r\nrc = matrix_keypad_build_keymap(NULL, NULL,\r\nPM8XXX_MAX_ROWS, PM8XXX_MAX_COLS,\r\nkp->keycodes, kp->input);\r\nif (rc) {\r\ndev_err(&pdev->dev, "failed to build keymap\n");\r\nreturn rc;\r\n}\r\nif (repeat)\r\n__set_bit(EV_REP, kp->input->evbit);\r\ninput_set_capability(kp->input, EV_MSC, MSC_SCAN);\r\ninput_set_drvdata(kp->input, kp);\r\nmemset(kp->keystate, 0xff, sizeof(kp->keystate));\r\nmemset(kp->stuckstate, 0xff, sizeof(kp->stuckstate));\r\nrc = pmic8xxx_kpd_init(kp, pdev);\r\nif (rc < 0) {\r\ndev_err(&pdev->dev, "unable to initialize keypad controller\n");\r\nreturn rc;\r\n}\r\nrc = devm_request_any_context_irq(&pdev->dev, kp->key_sense_irq,\r\npmic8xxx_kp_irq, IRQF_TRIGGER_RISING, "pmic-keypad",\r\nkp);\r\nif (rc < 0) {\r\ndev_err(&pdev->dev, "failed to request keypad sense irq\n");\r\nreturn rc;\r\n}\r\nrc = devm_request_any_context_irq(&pdev->dev, kp->key_stuck_irq,\r\npmic8xxx_kp_stuck_irq, IRQF_TRIGGER_RISING,\r\n"pmic-keypad-stuck", kp);\r\nif (rc < 0) {\r\ndev_err(&pdev->dev, "failed to request keypad stuck irq\n");\r\nreturn rc;\r\n}\r\nrc = regmap_read(kp->regmap, KEYP_CTRL, &ctrl_val);\r\nif (rc < 0) {\r\ndev_err(&pdev->dev, "failed to read KEYP_CTRL register\n");\r\nreturn rc;\r\n}\r\nkp->ctrl_reg = ctrl_val;\r\nrc = input_register_device(kp->input);\r\nif (rc < 0) {\r\ndev_err(&pdev->dev, "unable to register keypad input device\n");\r\nreturn rc;\r\n}\r\ndevice_init_wakeup(&pdev->dev, wakeup);\r\nreturn 0;\r\n}\r\nstatic int pmic8xxx_kp_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct pmic8xxx_kp *kp = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = kp->input;\r\nif (device_may_wakeup(dev)) {\r\nenable_irq_wake(kp->key_sense_irq);\r\n} else {\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\npmic8xxx_kp_disable(kp);\r\nmutex_unlock(&input_dev->mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pmic8xxx_kp_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct pmic8xxx_kp *kp = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = kp->input;\r\nif (device_may_wakeup(dev)) {\r\ndisable_irq_wake(kp->key_sense_irq);\r\n} else {\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\npmic8xxx_kp_enable(kp);\r\nmutex_unlock(&input_dev->mutex);\r\n}\r\nreturn 0;\r\n}
