static inline struct mt9t001 *to_mt9t001(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct mt9t001, subdev);\r\n}\r\nstatic int mt9t001_read(struct i2c_client *client, u8 reg)\r\n{\r\nreturn i2c_smbus_read_word_swapped(client, reg);\r\n}\r\nstatic int mt9t001_write(struct i2c_client *client, u8 reg, u16 data)\r\n{\r\nreturn i2c_smbus_write_word_swapped(client, reg, data);\r\n}\r\nstatic int mt9t001_set_output_control(struct mt9t001 *mt9t001, u16 clear,\r\nu16 set)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9t001->subdev);\r\nu16 value = (mt9t001->output_control & ~clear) | set;\r\nint ret;\r\nif (value == mt9t001->output_control)\r\nreturn 0;\r\nret = mt9t001_write(client, MT9T001_OUTPUT_CONTROL, value);\r\nif (ret < 0)\r\nreturn ret;\r\nmt9t001->output_control = value;\r\nreturn 0;\r\n}\r\nstatic int mt9t001_reset(struct mt9t001 *mt9t001)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9t001->subdev);\r\nint ret;\r\nret = mt9t001_write(client, MT9T001_RESET, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9t001_write(client, MT9T001_RESET, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nmt9t001->output_control = MT9T001_OUTPUT_CONTROL_DEF;\r\nreturn mt9t001_set_output_control(mt9t001,\r\nMT9T001_OUTPUT_CONTROL_CHIP_ENABLE,\r\n0);\r\n}\r\nstatic int mt9t001_power_on(struct mt9t001 *mt9t001)\r\n{\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(mt9t001->regulators),\r\nmt9t001->regulators);\r\nif (ret < 0)\r\nreturn ret;\r\nret = clk_prepare_enable(mt9t001->clk);\r\nif (ret < 0)\r\nregulator_bulk_disable(ARRAY_SIZE(mt9t001->regulators),\r\nmt9t001->regulators);\r\nreturn ret;\r\n}\r\nstatic void mt9t001_power_off(struct mt9t001 *mt9t001)\r\n{\r\nregulator_bulk_disable(ARRAY_SIZE(mt9t001->regulators),\r\nmt9t001->regulators);\r\nclk_disable_unprepare(mt9t001->clk);\r\n}\r\nstatic int __mt9t001_set_power(struct mt9t001 *mt9t001, bool on)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9t001->subdev);\r\nint ret;\r\nif (!on) {\r\nmt9t001_power_off(mt9t001);\r\nreturn 0;\r\n}\r\nret = mt9t001_power_on(mt9t001);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9t001_reset(mt9t001);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to reset the camera\n");\r\nreturn ret;\r\n}\r\nreturn v4l2_ctrl_handler_setup(&mt9t001->ctrls);\r\n}\r\nstatic struct v4l2_mbus_framefmt *\r\n__mt9t001_get_pad_format(struct mt9t001 *mt9t001, struct v4l2_subdev_pad_config *cfg,\r\nunsigned int pad, enum v4l2_subdev_format_whence which)\r\n{\r\nswitch (which) {\r\ncase V4L2_SUBDEV_FORMAT_TRY:\r\nreturn v4l2_subdev_get_try_format(&mt9t001->subdev, cfg, pad);\r\ncase V4L2_SUBDEV_FORMAT_ACTIVE:\r\nreturn &mt9t001->format;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic struct v4l2_rect *\r\n__mt9t001_get_pad_crop(struct mt9t001 *mt9t001, struct v4l2_subdev_pad_config *cfg,\r\nunsigned int pad, enum v4l2_subdev_format_whence which)\r\n{\r\nswitch (which) {\r\ncase V4L2_SUBDEV_FORMAT_TRY:\r\nreturn v4l2_subdev_get_try_crop(&mt9t001->subdev, cfg, pad);\r\ncase V4L2_SUBDEV_FORMAT_ACTIVE:\r\nreturn &mt9t001->crop;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic int mt9t001_s_stream(struct v4l2_subdev *subdev, int enable)\r\n{\r\nconst u16 mode = MT9T001_OUTPUT_CONTROL_CHIP_ENABLE;\r\nstruct i2c_client *client = v4l2_get_subdevdata(subdev);\r\nstruct mt9t001_platform_data *pdata = client->dev.platform_data;\r\nstruct mt9t001 *mt9t001 = to_mt9t001(subdev);\r\nstruct v4l2_mbus_framefmt *format = &mt9t001->format;\r\nstruct v4l2_rect *crop = &mt9t001->crop;\r\nunsigned int hratio;\r\nunsigned int vratio;\r\nint ret;\r\nif (!enable)\r\nreturn mt9t001_set_output_control(mt9t001, mode, 0);\r\nif (pdata->clk_pol) {\r\nret = mt9t001_write(client, MT9T001_PIXEL_CLOCK,\r\nMT9T001_PIXEL_CLOCK_INVERT);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nhratio = DIV_ROUND_CLOSEST(crop->width, format->width);\r\nvratio = DIV_ROUND_CLOSEST(crop->height, format->height);\r\nret = mt9t001_write(client, MT9T001_ROW_ADDRESS_MODE, hratio - 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9t001_write(client, MT9T001_COLUMN_ADDRESS_MODE, vratio - 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9t001_write(client, MT9T001_COLUMN_START, crop->left);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9t001_write(client, MT9T001_ROW_START, crop->top);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9t001_write(client, MT9T001_WINDOW_WIDTH, crop->width - 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9t001_write(client, MT9T001_WINDOW_HEIGHT, crop->height - 1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn mt9t001_set_output_control(mt9t001, 0, mode);\r\n}\r\nstatic int mt9t001_enum_mbus_code(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->index > 0)\r\nreturn -EINVAL;\r\ncode->code = MEDIA_BUS_FMT_SGRBG10_1X10;\r\nreturn 0;\r\n}\r\nstatic int mt9t001_enum_frame_size(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nif (fse->index >= 8 || fse->code != MEDIA_BUS_FMT_SGRBG10_1X10)\r\nreturn -EINVAL;\r\nfse->min_width = (MT9T001_WINDOW_WIDTH_DEF + 1) / fse->index;\r\nfse->max_width = fse->min_width;\r\nfse->min_height = (MT9T001_WINDOW_HEIGHT_DEF + 1) / fse->index;\r\nfse->max_height = fse->min_height;\r\nreturn 0;\r\n}\r\nstatic int mt9t001_get_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct mt9t001 *mt9t001 = to_mt9t001(subdev);\r\nformat->format = *__mt9t001_get_pad_format(mt9t001, cfg, format->pad,\r\nformat->which);\r\nreturn 0;\r\n}\r\nstatic int mt9t001_set_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct mt9t001 *mt9t001 = to_mt9t001(subdev);\r\nstruct v4l2_mbus_framefmt *__format;\r\nstruct v4l2_rect *__crop;\r\nunsigned int width;\r\nunsigned int height;\r\nunsigned int hratio;\r\nunsigned int vratio;\r\n__crop = __mt9t001_get_pad_crop(mt9t001, cfg, format->pad,\r\nformat->which);\r\nwidth = clamp_t(unsigned int, ALIGN(format->format.width, 2),\r\nmax_t(unsigned int, __crop->width / 8,\r\nMT9T001_WINDOW_HEIGHT_MIN + 1),\r\n__crop->width);\r\nheight = clamp_t(unsigned int, ALIGN(format->format.height, 2),\r\nmax_t(unsigned int, __crop->height / 8,\r\nMT9T001_WINDOW_HEIGHT_MIN + 1),\r\n__crop->height);\r\nhratio = DIV_ROUND_CLOSEST(__crop->width, width);\r\nvratio = DIV_ROUND_CLOSEST(__crop->height, height);\r\n__format = __mt9t001_get_pad_format(mt9t001, cfg, format->pad,\r\nformat->which);\r\n__format->width = __crop->width / hratio;\r\n__format->height = __crop->height / vratio;\r\nformat->format = *__format;\r\nreturn 0;\r\n}\r\nstatic int mt9t001_get_selection(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct mt9t001 *mt9t001 = to_mt9t001(subdev);\r\nif (sel->target != V4L2_SEL_TGT_CROP)\r\nreturn -EINVAL;\r\nsel->r = *__mt9t001_get_pad_crop(mt9t001, cfg, sel->pad, sel->which);\r\nreturn 0;\r\n}\r\nstatic int mt9t001_set_selection(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct mt9t001 *mt9t001 = to_mt9t001(subdev);\r\nstruct v4l2_mbus_framefmt *__format;\r\nstruct v4l2_rect *__crop;\r\nstruct v4l2_rect rect;\r\nif (sel->target != V4L2_SEL_TGT_CROP)\r\nreturn -EINVAL;\r\nrect.left = clamp(ALIGN(sel->r.left, 2),\r\nMT9T001_COLUMN_START_MIN,\r\nMT9T001_COLUMN_START_MAX);\r\nrect.top = clamp(ALIGN(sel->r.top, 2),\r\nMT9T001_ROW_START_MIN,\r\nMT9T001_ROW_START_MAX);\r\nrect.width = clamp_t(unsigned int, ALIGN(sel->r.width, 2),\r\nMT9T001_WINDOW_WIDTH_MIN + 1,\r\nMT9T001_WINDOW_WIDTH_MAX + 1);\r\nrect.height = clamp_t(unsigned int, ALIGN(sel->r.height, 2),\r\nMT9T001_WINDOW_HEIGHT_MIN + 1,\r\nMT9T001_WINDOW_HEIGHT_MAX + 1);\r\nrect.width = min_t(unsigned int, rect.width,\r\nMT9T001_PIXEL_ARRAY_WIDTH - rect.left);\r\nrect.height = min_t(unsigned int, rect.height,\r\nMT9T001_PIXEL_ARRAY_HEIGHT - rect.top);\r\n__crop = __mt9t001_get_pad_crop(mt9t001, cfg, sel->pad, sel->which);\r\nif (rect.width != __crop->width || rect.height != __crop->height) {\r\n__format = __mt9t001_get_pad_format(mt9t001, cfg, sel->pad,\r\nsel->which);\r\n__format->width = rect.width;\r\n__format->height = rect.height;\r\n}\r\n*__crop = rect;\r\nsel->r = rect;\r\nreturn 0;\r\n}\r\nstatic u16 mt9t001_gain_value(s32 *gain)\r\n{\r\nif (*gain <= 32)\r\nreturn *gain;\r\nif (*gain <= 64) {\r\n*gain &= ~1;\r\nreturn (1 << 6) | (*gain >> 1);\r\n}\r\n*gain &= ~7;\r\nreturn ((*gain - 64) << 5) | (1 << 6) | 32;\r\n}\r\nstatic int mt9t001_ctrl_freeze(struct mt9t001 *mt9t001, bool freeze)\r\n{\r\nreturn mt9t001_set_output_control(mt9t001,\r\nfreeze ? 0 : MT9T001_OUTPUT_CONTROL_SYNC,\r\nfreeze ? MT9T001_OUTPUT_CONTROL_SYNC : 0);\r\n}\r\nstatic int mt9t001_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstatic const u8 gains[4] = {\r\nMT9T001_RED_GAIN, MT9T001_GREEN1_GAIN,\r\nMT9T001_GREEN2_GAIN, MT9T001_BLUE_GAIN\r\n};\r\nstruct mt9t001 *mt9t001 =\r\ncontainer_of(ctrl->handler, struct mt9t001, ctrls);\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9t001->subdev);\r\nunsigned int count;\r\nunsigned int i;\r\nu16 value;\r\nint ret;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_GAIN_RED:\r\ncase V4L2_CID_GAIN_GREEN_RED:\r\ncase V4L2_CID_GAIN_GREEN_BLUE:\r\ncase V4L2_CID_GAIN_BLUE:\r\nfor (i = 0, count = 0; i < 4; ++i) {\r\nstruct v4l2_ctrl *gain = mt9t001->gains[i];\r\nif (gain->val != gain->cur.val)\r\ncount++;\r\n}\r\nif (count > 1) {\r\nret = mt9t001_ctrl_freeze(mt9t001, true);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < 4; ++i) {\r\nstruct v4l2_ctrl *gain = mt9t001->gains[i];\r\nif (gain->val == gain->cur.val)\r\ncontinue;\r\nvalue = mt9t001_gain_value(&gain->val);\r\nret = mt9t001_write(client, gains[i], value);\r\nif (ret < 0) {\r\nmt9t001_ctrl_freeze(mt9t001, false);\r\nreturn ret;\r\n}\r\n}\r\nif (count > 1) {\r\nret = mt9t001_ctrl_freeze(mt9t001, false);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nbreak;\r\ncase V4L2_CID_EXPOSURE:\r\nret = mt9t001_write(client, MT9T001_SHUTTER_WIDTH_LOW,\r\nctrl->val & 0xffff);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn mt9t001_write(client, MT9T001_SHUTTER_WIDTH_HIGH,\r\nctrl->val >> 16);\r\ncase V4L2_CID_TEST_PATTERN:\r\nreturn mt9t001_set_output_control(mt9t001,\r\nctrl->val ? 0 : MT9T001_OUTPUT_CONTROL_TEST_DATA,\r\nctrl->val ? MT9T001_OUTPUT_CONTROL_TEST_DATA : 0);\r\ncase V4L2_CID_TEST_PATTERN_COLOR:\r\nreturn mt9t001_write(client, MT9T001_TEST_DATA, ctrl->val << 2);\r\ncase V4L2_CID_BLACK_LEVEL_AUTO:\r\nvalue = ctrl->val ? 0 : MT9T001_BLACK_LEVEL_OVERRIDE;\r\nret = mt9t001_write(client, MT9T001_BLACK_LEVEL_CALIBRATION,\r\nvalue);\r\nif (ret < 0)\r\nreturn ret;\r\nmt9t001->black_level = value;\r\nbreak;\r\ncase V4L2_CID_BLACK_LEVEL_OFFSET:\r\nret = mt9t001_write(client, MT9T001_GREEN1_OFFSET, ctrl->val);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9t001_write(client, MT9T001_GREEN2_OFFSET, ctrl->val);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9t001_write(client, MT9T001_RED_OFFSET, ctrl->val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn mt9t001_write(client, MT9T001_BLUE_OFFSET, ctrl->val);\r\ncase V4L2_CID_BLACK_LEVEL_CALIBRATE:\r\nreturn mt9t001_write(client, MT9T001_BLACK_LEVEL_CALIBRATION,\r\nMT9T001_BLACK_LEVEL_RECALCULATE |\r\nmt9t001->black_level);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt9t001_set_power(struct v4l2_subdev *subdev, int on)\r\n{\r\nstruct mt9t001 *mt9t001 = to_mt9t001(subdev);\r\nint ret = 0;\r\nmutex_lock(&mt9t001->power_lock);\r\nif (mt9t001->power_count == !on) {\r\nret = __mt9t001_set_power(mt9t001, !!on);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nmt9t001->power_count += on ? 1 : -1;\r\nWARN_ON(mt9t001->power_count < 0);\r\nout:\r\nmutex_unlock(&mt9t001->power_lock);\r\nreturn ret;\r\n}\r\nstatic int mt9t001_registered(struct v4l2_subdev *subdev)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(subdev);\r\nstruct mt9t001 *mt9t001 = to_mt9t001(subdev);\r\ns32 data;\r\nint ret;\r\nret = mt9t001_power_on(mt9t001);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "MT9T001 power up failed\n");\r\nreturn ret;\r\n}\r\ndata = mt9t001_read(client, MT9T001_CHIP_VERSION);\r\nmt9t001_power_off(mt9t001);\r\nif (data != MT9T001_CHIP_ID) {\r\ndev_err(&client->dev,\r\n"MT9T001 not detected, wrong version 0x%04x\n", data);\r\nreturn -ENODEV;\r\n}\r\ndev_info(&client->dev, "MT9T001 detected at address 0x%02x\n",\r\nclient->addr);\r\nreturn 0;\r\n}\r\nstatic int mt9t001_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_mbus_framefmt *format;\r\nstruct v4l2_rect *crop;\r\ncrop = v4l2_subdev_get_try_crop(subdev, fh->pad, 0);\r\ncrop->left = MT9T001_COLUMN_START_DEF;\r\ncrop->top = MT9T001_ROW_START_DEF;\r\ncrop->width = MT9T001_WINDOW_WIDTH_DEF + 1;\r\ncrop->height = MT9T001_WINDOW_HEIGHT_DEF + 1;\r\nformat = v4l2_subdev_get_try_format(subdev, fh->pad, 0);\r\nformat->code = MEDIA_BUS_FMT_SGRBG10_1X10;\r\nformat->width = MT9T001_WINDOW_WIDTH_DEF + 1;\r\nformat->height = MT9T001_WINDOW_HEIGHT_DEF + 1;\r\nformat->field = V4L2_FIELD_NONE;\r\nformat->colorspace = V4L2_COLORSPACE_SRGB;\r\nreturn mt9t001_set_power(subdev, 1);\r\n}\r\nstatic int mt9t001_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)\r\n{\r\nreturn mt9t001_set_power(subdev, 0);\r\n}\r\nstatic int mt9t001_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct mt9t001_platform_data *pdata = client->dev.platform_data;\r\nstruct mt9t001 *mt9t001;\r\nunsigned int i;\r\nint ret;\r\nif (pdata == NULL) {\r\ndev_err(&client->dev, "No platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_WORD_DATA)) {\r\ndev_warn(&client->adapter->dev,\r\n"I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\n");\r\nreturn -EIO;\r\n}\r\nmt9t001 = devm_kzalloc(&client->dev, sizeof(*mt9t001), GFP_KERNEL);\r\nif (!mt9t001)\r\nreturn -ENOMEM;\r\nmutex_init(&mt9t001->power_lock);\r\nmt9t001->output_control = MT9T001_OUTPUT_CONTROL_DEF;\r\nmt9t001->regulators[0].supply = "vdd";\r\nmt9t001->regulators[1].supply = "vaa";\r\nret = devm_regulator_bulk_get(&client->dev, 2, mt9t001->regulators);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Unable to get regulators\n");\r\nreturn ret;\r\n}\r\nmt9t001->clk = devm_clk_get(&client->dev, NULL);\r\nif (IS_ERR(mt9t001->clk)) {\r\ndev_err(&client->dev, "Unable to get clock\n");\r\nreturn PTR_ERR(mt9t001->clk);\r\n}\r\nv4l2_ctrl_handler_init(&mt9t001->ctrls, ARRAY_SIZE(mt9t001_ctrls) +\r\nARRAY_SIZE(mt9t001_gains) + 4);\r\nv4l2_ctrl_new_std(&mt9t001->ctrls, &mt9t001_ctrl_ops,\r\nV4L2_CID_EXPOSURE, MT9T001_SHUTTER_WIDTH_MIN,\r\nMT9T001_SHUTTER_WIDTH_MAX, 1,\r\nMT9T001_SHUTTER_WIDTH_DEF);\r\nv4l2_ctrl_new_std(&mt9t001->ctrls, &mt9t001_ctrl_ops,\r\nV4L2_CID_BLACK_LEVEL, 1, 1, 1, 1);\r\nv4l2_ctrl_new_std(&mt9t001->ctrls, &mt9t001_ctrl_ops,\r\nV4L2_CID_PIXEL_RATE, pdata->ext_clk, pdata->ext_clk,\r\n1, pdata->ext_clk);\r\nv4l2_ctrl_new_std_menu_items(&mt9t001->ctrls, &mt9t001_ctrl_ops,\r\nV4L2_CID_TEST_PATTERN,\r\nARRAY_SIZE(mt9t001_test_pattern_menu) - 1, 0,\r\n0, mt9t001_test_pattern_menu);\r\nfor (i = 0; i < ARRAY_SIZE(mt9t001_ctrls); ++i)\r\nv4l2_ctrl_new_custom(&mt9t001->ctrls, &mt9t001_ctrls[i], NULL);\r\nfor (i = 0; i < ARRAY_SIZE(mt9t001_gains); ++i)\r\nmt9t001->gains[i] = v4l2_ctrl_new_custom(&mt9t001->ctrls,\r\n&mt9t001_gains[i], NULL);\r\nv4l2_ctrl_cluster(ARRAY_SIZE(mt9t001_gains), mt9t001->gains);\r\nmt9t001->subdev.ctrl_handler = &mt9t001->ctrls;\r\nif (mt9t001->ctrls.error) {\r\nprintk(KERN_INFO "%s: control initialization error %d\n",\r\n__func__, mt9t001->ctrls.error);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nmt9t001->crop.left = MT9T001_COLUMN_START_DEF;\r\nmt9t001->crop.top = MT9T001_ROW_START_DEF;\r\nmt9t001->crop.width = MT9T001_WINDOW_WIDTH_DEF + 1;\r\nmt9t001->crop.height = MT9T001_WINDOW_HEIGHT_DEF + 1;\r\nmt9t001->format.code = MEDIA_BUS_FMT_SGRBG10_1X10;\r\nmt9t001->format.width = MT9T001_WINDOW_WIDTH_DEF + 1;\r\nmt9t001->format.height = MT9T001_WINDOW_HEIGHT_DEF + 1;\r\nmt9t001->format.field = V4L2_FIELD_NONE;\r\nmt9t001->format.colorspace = V4L2_COLORSPACE_SRGB;\r\nv4l2_i2c_subdev_init(&mt9t001->subdev, client, &mt9t001_subdev_ops);\r\nmt9t001->subdev.internal_ops = &mt9t001_subdev_internal_ops;\r\nmt9t001->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nmt9t001->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_init(&mt9t001->subdev.entity, 1, &mt9t001->pad, 0);\r\ndone:\r\nif (ret < 0) {\r\nv4l2_ctrl_handler_free(&mt9t001->ctrls);\r\nmedia_entity_cleanup(&mt9t001->subdev.entity);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mt9t001_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct mt9t001 *mt9t001 = to_mt9t001(subdev);\r\nv4l2_ctrl_handler_free(&mt9t001->ctrls);\r\nv4l2_device_unregister_subdev(subdev);\r\nmedia_entity_cleanup(&subdev->entity);\r\nreturn 0;\r\n}
