static inline struct xilinx_pcie_port *sys_to_pcie(struct pci_sys_data *sys)\r\n{\r\nreturn sys->private_data;\r\n}\r\nstatic inline u32 pcie_read(struct xilinx_pcie_port *port, u32 reg)\r\n{\r\nreturn readl(port->reg_base + reg);\r\n}\r\nstatic inline void pcie_write(struct xilinx_pcie_port *port, u32 val, u32 reg)\r\n{\r\nwritel(val, port->reg_base + reg);\r\n}\r\nstatic inline bool xilinx_pcie_link_is_up(struct xilinx_pcie_port *port)\r\n{\r\nreturn (pcie_read(port, XILINX_PCIE_REG_PSCR) &\r\nXILINX_PCIE_REG_PSCR_LNKUP) ? 1 : 0;\r\n}\r\nstatic void xilinx_pcie_clear_err_interrupts(struct xilinx_pcie_port *port)\r\n{\r\nunsigned long val = pcie_read(port, XILINX_PCIE_REG_RPEFR);\r\nif (val & XILINX_PCIE_RPEFR_ERR_VALID) {\r\ndev_dbg(port->dev, "Requester ID %lu\n",\r\nval & XILINX_PCIE_RPEFR_REQ_ID);\r\npcie_write(port, XILINX_PCIE_RPEFR_ALL_MASK,\r\nXILINX_PCIE_REG_RPEFR);\r\n}\r\n}\r\nstatic bool xilinx_pcie_valid_device(struct pci_bus *bus, unsigned int devfn)\r\n{\r\nstruct xilinx_pcie_port *port = sys_to_pcie(bus->sysdata);\r\nif (bus->number != port->root_busno)\r\nif (!xilinx_pcie_link_is_up(port))\r\nreturn false;\r\nif (bus->number == port->root_busno && devfn > 0)\r\nreturn false;\r\nif (bus->primary == port->root_busno && devfn > 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void __iomem *xilinx_pcie_map_bus(struct pci_bus *bus,\r\nunsigned int devfn, int where)\r\n{\r\nstruct xilinx_pcie_port *port = sys_to_pcie(bus->sysdata);\r\nint relbus;\r\nif (!xilinx_pcie_valid_device(bus, devfn))\r\nreturn NULL;\r\nrelbus = (bus->number << ECAM_BUS_NUM_SHIFT) |\r\n(devfn << ECAM_DEV_NUM_SHIFT);\r\nreturn port->reg_base + relbus + where;\r\n}\r\nstatic void xilinx_pcie_destroy_msi(unsigned int irq)\r\n{\r\nstruct msi_desc *msi;\r\nstruct xilinx_pcie_port *port;\r\nif (!test_bit(irq, msi_irq_in_use)) {\r\nmsi = irq_get_msi_desc(irq);\r\nport = sys_to_pcie(msi_desc_to_pci_sysdata(msi));\r\ndev_err(port->dev, "Trying to free unused MSI#%d\n", irq);\r\n} else {\r\nclear_bit(irq, msi_irq_in_use);\r\n}\r\n}\r\nstatic int xilinx_pcie_assign_msi(struct xilinx_pcie_port *port)\r\n{\r\nint pos;\r\npos = find_first_zero_bit(msi_irq_in_use, XILINX_NUM_MSI_IRQS);\r\nif (pos < XILINX_NUM_MSI_IRQS)\r\nset_bit(pos, msi_irq_in_use);\r\nelse\r\nreturn -ENOSPC;\r\nreturn pos;\r\n}\r\nstatic void xilinx_msi_teardown_irq(struct msi_controller *chip,\r\nunsigned int irq)\r\n{\r\nxilinx_pcie_destroy_msi(irq);\r\n}\r\nstatic int xilinx_pcie_msi_setup_irq(struct msi_controller *chip,\r\nstruct pci_dev *pdev,\r\nstruct msi_desc *desc)\r\n{\r\nstruct xilinx_pcie_port *port = sys_to_pcie(pdev->bus->sysdata);\r\nunsigned int irq;\r\nint hwirq;\r\nstruct msi_msg msg;\r\nphys_addr_t msg_addr;\r\nhwirq = xilinx_pcie_assign_msi(port);\r\nif (hwirq < 0)\r\nreturn hwirq;\r\nirq = irq_create_mapping(port->irq_domain, hwirq);\r\nif (!irq)\r\nreturn -EINVAL;\r\nirq_set_msi_desc(irq, desc);\r\nmsg_addr = virt_to_phys((void *)port->msi_pages);\r\nmsg.address_hi = 0;\r\nmsg.address_lo = msg_addr;\r\nmsg.data = irq;\r\npci_write_msi_msg(irq, &msg);\r\nreturn 0;\r\n}\r\nstatic int xilinx_pcie_msi_map(struct irq_domain *domain, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nirq_set_chip_and_handler(irq, &xilinx_msi_irq_chip, handle_simple_irq);\r\nirq_set_chip_data(irq, domain->host_data);\r\nreturn 0;\r\n}\r\nstatic void xilinx_pcie_enable_msi(struct xilinx_pcie_port *port)\r\n{\r\nphys_addr_t msg_addr;\r\nport->msi_pages = __get_free_pages(GFP_KERNEL, 0);\r\nmsg_addr = virt_to_phys((void *)port->msi_pages);\r\npcie_write(port, 0x0, XILINX_PCIE_REG_MSIBASE1);\r\npcie_write(port, msg_addr, XILINX_PCIE_REG_MSIBASE2);\r\n}\r\nstatic int xilinx_pcie_intx_map(struct irq_domain *domain, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nirq_set_chip_and_handler(irq, &dummy_irq_chip, handle_simple_irq);\r\nirq_set_chip_data(irq, domain->host_data);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t xilinx_pcie_intr_handler(int irq, void *data)\r\n{\r\nstruct xilinx_pcie_port *port = (struct xilinx_pcie_port *)data;\r\nu32 val, mask, status, msi_data;\r\nval = pcie_read(port, XILINX_PCIE_REG_IDR);\r\nmask = pcie_read(port, XILINX_PCIE_REG_IMR);\r\nstatus = val & mask;\r\nif (!status)\r\nreturn IRQ_NONE;\r\nif (status & XILINX_PCIE_INTR_LINK_DOWN)\r\ndev_warn(port->dev, "Link Down\n");\r\nif (status & XILINX_PCIE_INTR_ECRC_ERR)\r\ndev_warn(port->dev, "ECRC failed\n");\r\nif (status & XILINX_PCIE_INTR_STR_ERR)\r\ndev_warn(port->dev, "Streaming error\n");\r\nif (status & XILINX_PCIE_INTR_HOT_RESET)\r\ndev_info(port->dev, "Hot reset\n");\r\nif (status & XILINX_PCIE_INTR_CFG_TIMEOUT)\r\ndev_warn(port->dev, "ECAM access timeout\n");\r\nif (status & XILINX_PCIE_INTR_CORRECTABLE) {\r\ndev_warn(port->dev, "Correctable error message\n");\r\nxilinx_pcie_clear_err_interrupts(port);\r\n}\r\nif (status & XILINX_PCIE_INTR_NONFATAL) {\r\ndev_warn(port->dev, "Non fatal error message\n");\r\nxilinx_pcie_clear_err_interrupts(port);\r\n}\r\nif (status & XILINX_PCIE_INTR_FATAL) {\r\ndev_warn(port->dev, "Fatal error message\n");\r\nxilinx_pcie_clear_err_interrupts(port);\r\n}\r\nif (status & XILINX_PCIE_INTR_INTX) {\r\nval = pcie_read(port, XILINX_PCIE_REG_RPIFR1);\r\nif (!(val & XILINX_PCIE_RPIFR1_INTR_VALID)) {\r\ndev_warn(port->dev, "RP Intr FIFO1 read error\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (!(val & XILINX_PCIE_RPIFR1_MSI_INTR)) {\r\npcie_write(port, XILINX_PCIE_RPIFR1_ALL_MASK,\r\nXILINX_PCIE_REG_RPIFR1);\r\nval = ((val & XILINX_PCIE_RPIFR1_INTR_MASK) >>\r\nXILINX_PCIE_RPIFR1_INTR_SHIFT) + 1;\r\ngeneric_handle_irq(irq_find_mapping(port->irq_domain,\r\nval));\r\n}\r\n}\r\nif (status & XILINX_PCIE_INTR_MSI) {\r\nval = pcie_read(port, XILINX_PCIE_REG_RPIFR1);\r\nif (!(val & XILINX_PCIE_RPIFR1_INTR_VALID)) {\r\ndev_warn(port->dev, "RP Intr FIFO1 read error\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (val & XILINX_PCIE_RPIFR1_MSI_INTR) {\r\nmsi_data = pcie_read(port, XILINX_PCIE_REG_RPIFR2) &\r\nXILINX_PCIE_RPIFR2_MSG_DATA;\r\npcie_write(port, XILINX_PCIE_RPIFR1_ALL_MASK,\r\nXILINX_PCIE_REG_RPIFR1);\r\nif (IS_ENABLED(CONFIG_PCI_MSI)) {\r\ngeneric_handle_irq(msi_data);\r\n}\r\n}\r\n}\r\nif (status & XILINX_PCIE_INTR_SLV_UNSUPP)\r\ndev_warn(port->dev, "Slave unsupported request\n");\r\nif (status & XILINX_PCIE_INTR_SLV_UNEXP)\r\ndev_warn(port->dev, "Slave unexpected completion\n");\r\nif (status & XILINX_PCIE_INTR_SLV_COMPL)\r\ndev_warn(port->dev, "Slave completion timeout\n");\r\nif (status & XILINX_PCIE_INTR_SLV_ERRP)\r\ndev_warn(port->dev, "Slave Error Poison\n");\r\nif (status & XILINX_PCIE_INTR_SLV_CMPABT)\r\ndev_warn(port->dev, "Slave Completer Abort\n");\r\nif (status & XILINX_PCIE_INTR_SLV_ILLBUR)\r\ndev_warn(port->dev, "Slave Illegal Burst\n");\r\nif (status & XILINX_PCIE_INTR_MST_DECERR)\r\ndev_warn(port->dev, "Master decode error\n");\r\nif (status & XILINX_PCIE_INTR_MST_SLVERR)\r\ndev_warn(port->dev, "Master slave error\n");\r\nif (status & XILINX_PCIE_INTR_MST_ERRP)\r\ndev_warn(port->dev, "Master error poison\n");\r\npcie_write(port, status, XILINX_PCIE_REG_IDR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void xilinx_pcie_free_irq_domain(struct xilinx_pcie_port *port)\r\n{\r\nint i;\r\nu32 irq, num_irqs;\r\nif (IS_ENABLED(CONFIG_PCI_MSI)) {\r\nfree_pages(port->msi_pages, 0);\r\nnum_irqs = XILINX_NUM_MSI_IRQS;\r\n} else {\r\nnum_irqs = 4;\r\n}\r\nfor (i = 0; i < num_irqs; i++) {\r\nirq = irq_find_mapping(port->irq_domain, i);\r\nif (irq > 0)\r\nirq_dispose_mapping(irq);\r\n}\r\nirq_domain_remove(port->irq_domain);\r\n}\r\nstatic int xilinx_pcie_init_irq_domain(struct xilinx_pcie_port *port)\r\n{\r\nstruct device *dev = port->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct device_node *pcie_intc_node;\r\npcie_intc_node = of_get_next_child(node, NULL);\r\nif (!pcie_intc_node) {\r\ndev_err(dev, "No PCIe Intc node found\n");\r\nreturn PTR_ERR(pcie_intc_node);\r\n}\r\nport->irq_domain = irq_domain_add_linear(pcie_intc_node, 4,\r\n&intx_domain_ops,\r\nport);\r\nif (!port->irq_domain) {\r\ndev_err(dev, "Failed to get a INTx IRQ domain\n");\r\nreturn PTR_ERR(port->irq_domain);\r\n}\r\nif (IS_ENABLED(CONFIG_PCI_MSI)) {\r\nport->irq_domain = irq_domain_add_linear(node,\r\nXILINX_NUM_MSI_IRQS,\r\n&msi_domain_ops,\r\n&xilinx_pcie_msi_chip);\r\nif (!port->irq_domain) {\r\ndev_err(dev, "Failed to get a MSI IRQ domain\n");\r\nreturn PTR_ERR(port->irq_domain);\r\n}\r\nxilinx_pcie_enable_msi(port);\r\n}\r\nreturn 0;\r\n}\r\nstatic void xilinx_pcie_init_port(struct xilinx_pcie_port *port)\r\n{\r\nif (xilinx_pcie_link_is_up(port))\r\ndev_info(port->dev, "PCIe Link is UP\n");\r\nelse\r\ndev_info(port->dev, "PCIe Link is DOWN\n");\r\npcie_write(port, ~XILINX_PCIE_IDR_ALL_MASK,\r\nXILINX_PCIE_REG_IMR);\r\npcie_write(port, pcie_read(port, XILINX_PCIE_REG_IDR) &\r\nXILINX_PCIE_IMR_ALL_MASK,\r\nXILINX_PCIE_REG_IDR);\r\npcie_write(port, XILINX_PCIE_IMR_ALL_MASK, XILINX_PCIE_REG_IMR);\r\npcie_write(port, pcie_read(port, XILINX_PCIE_REG_RPSC) |\r\nXILINX_PCIE_REG_RPSC_BEN,\r\nXILINX_PCIE_REG_RPSC);\r\n}\r\nstatic int xilinx_pcie_setup(int nr, struct pci_sys_data *sys)\r\n{\r\nstruct xilinx_pcie_port *port = sys_to_pcie(sys);\r\nlist_splice_init(&port->resources, &sys->resources);\r\nreturn 1;\r\n}\r\nstatic struct pci_bus *xilinx_pcie_scan_bus(int nr, struct pci_sys_data *sys)\r\n{\r\nstruct xilinx_pcie_port *port = sys_to_pcie(sys);\r\nstruct pci_bus *bus;\r\nport->root_busno = sys->busnr;\r\nif (IS_ENABLED(CONFIG_PCI_MSI))\r\nbus = pci_scan_root_bus_msi(port->dev, sys->busnr,\r\n&xilinx_pcie_ops, sys,\r\n&sys->resources,\r\n&xilinx_pcie_msi_chip);\r\nelse\r\nbus = pci_scan_root_bus(port->dev, sys->busnr,\r\n&xilinx_pcie_ops, sys, &sys->resources);\r\nreturn bus;\r\n}\r\nstatic int xilinx_pcie_parse_and_add_res(struct xilinx_pcie_port *port)\r\n{\r\nstruct device *dev = port->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct resource *mem;\r\nresource_size_t offset;\r\nstruct of_pci_range_parser parser;\r\nstruct of_pci_range range;\r\nstruct resource_entry *win;\r\nint err = 0, mem_resno = 0;\r\nif (of_pci_range_parser_init(&parser, node)) {\r\ndev_err(dev, "missing \"ranges\" property\n");\r\nreturn -EINVAL;\r\n}\r\nfor_each_of_pci_range(&parser, &range) {\r\nif (mem_resno >= XILINX_MAX_NUM_RESOURCES) {\r\ndev_err(dev, "Maximum memory resources exceeded\n");\r\nreturn -EINVAL;\r\n}\r\nmem = devm_kmalloc(dev, sizeof(*mem), GFP_KERNEL);\r\nif (!mem) {\r\nerr = -ENOMEM;\r\ngoto free_resources;\r\n}\r\nof_pci_range_to_resource(&range, node, mem);\r\nswitch (mem->flags & IORESOURCE_TYPE_BITS) {\r\ncase IORESOURCE_MEM:\r\noffset = range.cpu_addr - range.pci_addr;\r\nmem_resno++;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (err < 0) {\r\ndev_warn(dev, "Invalid resource found %pR\n", mem);\r\ncontinue;\r\n}\r\nerr = request_resource(&iomem_resource, mem);\r\nif (err)\r\ngoto free_resources;\r\npci_add_resource_offset(&port->resources, mem, offset);\r\n}\r\nif (of_pci_parse_bus_range(node, &port->bus_range)) {\r\nu32 val = pcie_read(port, XILINX_PCIE_REG_BIR);\r\nu8 last;\r\nlast = (val & XILINX_PCIE_BIR_ECAM_SZ_MASK) >>\r\nXILINX_PCIE_BIR_ECAM_SZ_SHIFT;\r\nport->bus_range = (struct resource) {\r\n.name = node->name,\r\n.start = 0,\r\n.end = last,\r\n.flags = IORESOURCE_BUS,\r\n};\r\n}\r\npci_add_resource(&port->resources, &port->bus_range);\r\nreturn 0;\r\nfree_resources:\r\nrelease_child_resources(&iomem_resource);\r\nresource_list_for_each_entry(win, &port->resources)\r\ndevm_kfree(dev, win->res);\r\npci_free_resource_list(&port->resources);\r\nreturn err;\r\n}\r\nstatic int xilinx_pcie_parse_dt(struct xilinx_pcie_port *port)\r\n{\r\nstruct device *dev = port->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct resource regs;\r\nconst char *type;\r\nint err;\r\ntype = of_get_property(node, "device_type", NULL);\r\nif (!type || strcmp(type, "pci")) {\r\ndev_err(dev, "invalid \"device_type\" %s\n", type);\r\nreturn -EINVAL;\r\n}\r\nerr = of_address_to_resource(node, 0, &regs);\r\nif (err) {\r\ndev_err(dev, "missing \"reg\" property\n");\r\nreturn err;\r\n}\r\nport->reg_base = devm_ioremap_resource(dev, &regs);\r\nif (IS_ERR(port->reg_base))\r\nreturn PTR_ERR(port->reg_base);\r\nport->irq = irq_of_parse_and_map(node, 0);\r\nerr = devm_request_irq(dev, port->irq, xilinx_pcie_intr_handler,\r\nIRQF_SHARED, "xilinx-pcie", port);\r\nif (err) {\r\ndev_err(dev, "unable to request irq %d\n", port->irq);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xilinx_pcie_probe(struct platform_device *pdev)\r\n{\r\nstruct xilinx_pcie_port *port;\r\nstruct hw_pci hw;\r\nstruct device *dev = &pdev->dev;\r\nint err;\r\nif (!dev->of_node)\r\nreturn -ENODEV;\r\nport = devm_kzalloc(dev, sizeof(*port), GFP_KERNEL);\r\nif (!port)\r\nreturn -ENOMEM;\r\nport->dev = dev;\r\nerr = xilinx_pcie_parse_dt(port);\r\nif (err) {\r\ndev_err(dev, "Parsing DT failed\n");\r\nreturn err;\r\n}\r\nxilinx_pcie_init_port(port);\r\nerr = xilinx_pcie_init_irq_domain(port);\r\nif (err) {\r\ndev_err(dev, "Failed creating IRQ Domain\n");\r\nreturn err;\r\n}\r\nINIT_LIST_HEAD(&port->resources);\r\nerr = xilinx_pcie_parse_and_add_res(port);\r\nif (err) {\r\ndev_err(dev, "Failed adding resources\n");\r\nreturn err;\r\n}\r\nplatform_set_drvdata(pdev, port);\r\nmemset(&hw, 0, sizeof(hw));\r\nhw = (struct hw_pci) {\r\n.nr_controllers = 1,\r\n.private_data = (void **)&port,\r\n.setup = xilinx_pcie_setup,\r\n.map_irq = of_irq_parse_and_map_pci,\r\n.scan = xilinx_pcie_scan_bus,\r\n.ops = &xilinx_pcie_ops,\r\n};\r\n#ifdef CONFIG_PCI_MSI\r\nxilinx_pcie_msi_chip.dev = port->dev;\r\n#endif\r\npci_common_init_dev(dev, &hw);\r\nreturn 0;\r\n}\r\nstatic int xilinx_pcie_remove(struct platform_device *pdev)\r\n{\r\nstruct xilinx_pcie_port *port = platform_get_drvdata(pdev);\r\nxilinx_pcie_free_irq_domain(port);\r\nreturn 0;\r\n}
