static int wil_fw_verify(struct wil6210_priv *wil, const u8 *data, size_t size)\r\n{\r\nconst struct wil_fw_record_head *hdr = (const void *)data;\r\nstruct wil_fw_record_file_header fh;\r\nconst struct wil_fw_record_file_header *fh_;\r\nu32 crc;\r\nu32 dlen;\r\nif (size % 4) {\r\nwil_err_fw(wil, "image size not aligned: %zu\n", size);\r\nreturn -EINVAL;\r\n}\r\nif (size < sizeof(*hdr) + sizeof(fh)) {\r\nwil_err_fw(wil, "file too short: %zu bytes\n", size);\r\nreturn -EINVAL;\r\n}\r\nif (le16_to_cpu(hdr->type) != wil_fw_type_file_header) {\r\nwil_err_fw(wil, "no file header\n");\r\nreturn -EINVAL;\r\n}\r\nfh_ = (struct wil_fw_record_file_header *)&hdr[1];\r\ndlen = le32_to_cpu(fh_->data_len);\r\nif (dlen % 4) {\r\nwil_err_fw(wil, "data length not aligned: %lu\n", (ulong)dlen);\r\nreturn -EINVAL;\r\n}\r\nif (size < dlen) {\r\nwil_err_fw(wil, "file truncated at %zu/%lu\n",\r\nsize, (ulong)dlen);\r\nreturn -EINVAL;\r\n}\r\nif (dlen < sizeof(*hdr) + sizeof(fh)) {\r\nwil_err_fw(wil, "data length too short: %lu\n", (ulong)dlen);\r\nreturn -EINVAL;\r\n}\r\nif (le32_to_cpu(fh_->signature) != WIL_FW_SIGNATURE) {\r\nwil_err_fw(wil, "bad header signature: 0x%08x\n",\r\nle32_to_cpu(fh_->signature));\r\nreturn -EINVAL;\r\n}\r\nif (le32_to_cpu(fh_->version) > WIL_FW_FMT_VERSION) {\r\nwil_err_fw(wil, "unsupported header version: %d\n",\r\nle32_to_cpu(fh_->version));\r\nreturn -EINVAL;\r\n}\r\nfh = *fh_;\r\nfh.crc = 0;\r\ncrc = crc32_le(~0, (unsigned char const *)hdr, sizeof(*hdr));\r\ncrc = crc32_le(crc, (unsigned char const *)&fh, sizeof(fh));\r\ncrc = crc32_le(crc, (unsigned char const *)&fh_[1],\r\ndlen - sizeof(*hdr) - sizeof(fh));\r\ncrc = ~crc;\r\nif (crc != le32_to_cpu(fh_->crc)) {\r\nwil_err_fw(wil, "checksum mismatch:"\r\n" calculated for %lu bytes 0x%08x != 0x%08x\n",\r\n(ulong)dlen, crc, le32_to_cpu(fh_->crc));\r\nreturn -EINVAL;\r\n}\r\nreturn (int)dlen;\r\n}\r\nstatic int fw_handle_comment(struct wil6210_priv *wil, const void *data,\r\nsize_t size)\r\n{\r\nwil_hex_dump_fw("", DUMP_PREFIX_OFFSET, 16, 1, data, size, true);\r\nreturn 0;\r\n}\r\nstatic int fw_handle_data(struct wil6210_priv *wil, const void *data,\r\nsize_t size)\r\n{\r\nconst struct wil_fw_record_data *d = data;\r\nvoid __iomem *dst;\r\nsize_t s = size - sizeof(*d);\r\nif (size < sizeof(*d) + sizeof(u32)) {\r\nwil_err_fw(wil, "data record too short: %zu\n", size);\r\nreturn -EINVAL;\r\n}\r\nFW_ADDR_CHECK(dst, d->addr, "address");\r\nwil_dbg_fw(wil, "write [0x%08x] <== %zu bytes\n", le32_to_cpu(d->addr),\r\ns);\r\nwil_memcpy_toio_32(dst, d->data, s);\r\nwmb();\r\nreturn 0;\r\n}\r\nstatic int fw_handle_fill(struct wil6210_priv *wil, const void *data,\r\nsize_t size)\r\n{\r\nconst struct wil_fw_record_fill *d = data;\r\nvoid __iomem *dst;\r\nu32 v;\r\nsize_t s = (size_t)le32_to_cpu(d->size);\r\nif (size != sizeof(*d)) {\r\nwil_err_fw(wil, "bad size for fill record: %zu\n", size);\r\nreturn -EINVAL;\r\n}\r\nif (s < sizeof(u32)) {\r\nwil_err_fw(wil, "fill size too short: %zu\n", s);\r\nreturn -EINVAL;\r\n}\r\nif (s % sizeof(u32)) {\r\nwil_err_fw(wil, "fill size not aligned: %zu\n", s);\r\nreturn -EINVAL;\r\n}\r\nFW_ADDR_CHECK(dst, d->addr, "address");\r\nv = le32_to_cpu(d->value);\r\nwil_dbg_fw(wil, "fill [0x%08x] <== 0x%08x, %zu bytes\n",\r\nle32_to_cpu(d->addr), v, s);\r\nwil_memset_toio_32(dst, v, s);\r\nwmb();\r\nreturn 0;\r\n}\r\nstatic int fw_handle_file_header(struct wil6210_priv *wil, const void *data,\r\nsize_t size)\r\n{\r\nconst struct wil_fw_record_file_header *d = data;\r\nif (size != sizeof(*d)) {\r\nwil_err_fw(wil, "file header length incorrect: %zu\n", size);\r\nreturn -EINVAL;\r\n}\r\nwil_dbg_fw(wil, "new file, ver. %d, %i bytes\n",\r\nd->version, d->data_len);\r\nwil_hex_dump_fw("", DUMP_PREFIX_OFFSET, 16, 1, d->comment,\r\nsizeof(d->comment), true);\r\nreturn 0;\r\n}\r\nstatic int fw_handle_direct_write(struct wil6210_priv *wil, const void *data,\r\nsize_t size)\r\n{\r\nconst struct wil_fw_record_direct_write *d = data;\r\nconst struct wil_fw_data_dwrite *block = d->data;\r\nint n, i;\r\nif (size % sizeof(*block)) {\r\nwil_err_fw(wil, "record size not aligned on %zu: %zu\n",\r\nsizeof(*block), size);\r\nreturn -EINVAL;\r\n}\r\nn = size / sizeof(*block);\r\nfor (i = 0; i < n; i++) {\r\nvoid __iomem *dst;\r\nu32 m = le32_to_cpu(block[i].mask);\r\nu32 v = le32_to_cpu(block[i].value);\r\nu32 x, y;\r\nFW_ADDR_CHECK(dst, block[i].addr, "address");\r\nx = readl(dst);\r\ny = (x & m) | (v & ~m);\r\nwil_dbg_fw(wil, "write [0x%08x] <== 0x%08x "\r\n"(old 0x%08x val 0x%08x mask 0x%08x)\n",\r\nle32_to_cpu(block[i].addr), y, x, v, m);\r\nwritel(y, dst);\r\nwmb();\r\n}\r\nreturn 0;\r\n}\r\nstatic int gw_write(struct wil6210_priv *wil, void __iomem *gwa_addr,\r\nvoid __iomem *gwa_cmd, void __iomem *gwa_ctl, u32 gw_cmd,\r\nu32 a)\r\n{\r\nunsigned delay = 0;\r\nwritel(a, gwa_addr);\r\nwritel(gw_cmd, gwa_cmd);\r\nwmb();\r\nwritel(WIL_FW_GW_CTL_RUN, gwa_ctl);\r\ndo {\r\nudelay(1);\r\nif (delay++ > 100) {\r\nwil_err_fw(wil, "gw timeout\n");\r\nreturn -EINVAL;\r\n}\r\n} while (readl(gwa_ctl) & WIL_FW_GW_CTL_BUSY);\r\nreturn 0;\r\n}\r\nstatic int fw_handle_gateway_data(struct wil6210_priv *wil, const void *data,\r\nsize_t size)\r\n{\r\nconst struct wil_fw_record_gateway_data *d = data;\r\nconst struct wil_fw_data_gw *block = d->data;\r\nvoid __iomem *gwa_addr;\r\nvoid __iomem *gwa_val;\r\nvoid __iomem *gwa_cmd;\r\nvoid __iomem *gwa_ctl;\r\nu32 gw_cmd;\r\nint n, i;\r\nif (size < sizeof(*d) + sizeof(*block)) {\r\nwil_err_fw(wil, "gateway record too short: %zu\n", size);\r\nreturn -EINVAL;\r\n}\r\nif ((size - sizeof(*d)) % sizeof(*block)) {\r\nwil_err_fw(wil, "gateway record data size"\r\n" not aligned on %zu: %zu\n",\r\nsizeof(*block), size - sizeof(*d));\r\nreturn -EINVAL;\r\n}\r\nn = (size - sizeof(*d)) / sizeof(*block);\r\ngw_cmd = le32_to_cpu(d->command);\r\nwil_dbg_fw(wil, "gw write record [%3d] blocks, cmd 0x%08x\n",\r\nn, gw_cmd);\r\nFW_ADDR_CHECK(gwa_addr, d->gateway_addr_addr, "gateway_addr_addr");\r\nFW_ADDR_CHECK(gwa_val, d->gateway_value_addr, "gateway_value_addr");\r\nFW_ADDR_CHECK(gwa_cmd, d->gateway_cmd_addr, "gateway_cmd_addr");\r\nFW_ADDR_CHECK(gwa_ctl, d->gateway_ctrl_address, "gateway_ctrl_address");\r\nwil_dbg_fw(wil, "gw addresses: addr 0x%08x val 0x%08x"\r\n" cmd 0x%08x ctl 0x%08x\n",\r\nle32_to_cpu(d->gateway_addr_addr),\r\nle32_to_cpu(d->gateway_value_addr),\r\nle32_to_cpu(d->gateway_cmd_addr),\r\nle32_to_cpu(d->gateway_ctrl_address));\r\nfor (i = 0; i < n; i++) {\r\nint rc;\r\nu32 a = le32_to_cpu(block[i].addr);\r\nu32 v = le32_to_cpu(block[i].value);\r\nwil_dbg_fw(wil, " gw write[%3d] [0x%08x] <== 0x%08x\n",\r\ni, a, v);\r\nwritel(v, gwa_val);\r\nrc = gw_write(wil, gwa_addr, gwa_cmd, gwa_ctl, gw_cmd, a);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fw_handle_gateway_data4(struct wil6210_priv *wil, const void *data,\r\nsize_t size)\r\n{\r\nconst struct wil_fw_record_gateway_data4 *d = data;\r\nconst struct wil_fw_data_gw4 *block = d->data;\r\nvoid __iomem *gwa_addr;\r\nvoid __iomem *gwa_val[ARRAY_SIZE(block->value)];\r\nvoid __iomem *gwa_cmd;\r\nvoid __iomem *gwa_ctl;\r\nu32 gw_cmd;\r\nint n, i, k;\r\nif (size < sizeof(*d) + sizeof(*block)) {\r\nwil_err_fw(wil, "gateway4 record too short: %zu\n", size);\r\nreturn -EINVAL;\r\n}\r\nif ((size - sizeof(*d)) % sizeof(*block)) {\r\nwil_err_fw(wil, "gateway4 record data size"\r\n" not aligned on %zu: %zu\n",\r\nsizeof(*block), size - sizeof(*d));\r\nreturn -EINVAL;\r\n}\r\nn = (size - sizeof(*d)) / sizeof(*block);\r\ngw_cmd = le32_to_cpu(d->command);\r\nwil_dbg_fw(wil, "gw4 write record [%3d] blocks, cmd 0x%08x\n",\r\nn, gw_cmd);\r\nFW_ADDR_CHECK(gwa_addr, d->gateway_addr_addr, "gateway_addr_addr");\r\nfor (k = 0; k < ARRAY_SIZE(block->value); k++)\r\nFW_ADDR_CHECK(gwa_val[k], d->gateway_value_addr[k],\r\n"gateway_value_addr");\r\nFW_ADDR_CHECK(gwa_cmd, d->gateway_cmd_addr, "gateway_cmd_addr");\r\nFW_ADDR_CHECK(gwa_ctl, d->gateway_ctrl_address, "gateway_ctrl_address");\r\nwil_dbg_fw(wil, "gw4 addresses: addr 0x%08x cmd 0x%08x ctl 0x%08x\n",\r\nle32_to_cpu(d->gateway_addr_addr),\r\nle32_to_cpu(d->gateway_cmd_addr),\r\nle32_to_cpu(d->gateway_ctrl_address));\r\nwil_hex_dump_fw("val addresses: ", DUMP_PREFIX_NONE, 16, 4,\r\nd->gateway_value_addr, sizeof(d->gateway_value_addr),\r\nfalse);\r\nfor (i = 0; i < n; i++) {\r\nint rc;\r\nu32 a = le32_to_cpu(block[i].addr);\r\nu32 v[ARRAY_SIZE(block->value)];\r\nfor (k = 0; k < ARRAY_SIZE(block->value); k++)\r\nv[k] = le32_to_cpu(block[i].value[k]);\r\nwil_dbg_fw(wil, " gw4 write[%3d] [0x%08x] <==\n", i, a);\r\nwil_hex_dump_fw(" val ", DUMP_PREFIX_NONE, 16, 4, v,\r\nsizeof(v), false);\r\nfor (k = 0; k < ARRAY_SIZE(block->value); k++)\r\nwritel(v[k], gwa_val[k]);\r\nrc = gw_write(wil, gwa_addr, gwa_cmd, gwa_ctl, gw_cmd, a);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wil_fw_handle_record(struct wil6210_priv *wil, int type,\r\nconst void *data, size_t size)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(wil_fw_handlers); i++) {\r\nif (wil_fw_handlers[i].type == type)\r\nreturn wil_fw_handlers[i].handler(wil, data, size);\r\n}\r\nwil_err_fw(wil, "unknown record type: %d\n", type);\r\nreturn -EINVAL;\r\n}\r\nstatic int wil_fw_load(struct wil6210_priv *wil, const void *data, size_t size)\r\n{\r\nint rc = 0;\r\nconst struct wil_fw_record_head *hdr;\r\nsize_t s, hdr_sz;\r\nfor (hdr = data;; hdr = (const void *)hdr + s, size -= s) {\r\nif (size < sizeof(*hdr))\r\nbreak;\r\nhdr_sz = le32_to_cpu(hdr->size);\r\ns = sizeof(*hdr) + hdr_sz;\r\nif (s > size)\r\nbreak;\r\nif (hdr_sz % 4) {\r\nwil_err_fw(wil, "unaligned record size: %zu\n",\r\nhdr_sz);\r\nreturn -EINVAL;\r\n}\r\nrc = wil_fw_handle_record(wil, le16_to_cpu(hdr->type),\r\n&hdr[1], hdr_sz);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (size) {\r\nwil_err_fw(wil, "unprocessed bytes: %zu\n", size);\r\nif (size >= sizeof(*hdr)) {\r\nwil_err_fw(wil, "Stop at offset %ld"\r\n" record type %d [%zd bytes]\n",\r\n(long)((const void *)hdr - data),\r\nle16_to_cpu(hdr->type), hdr_sz);\r\n}\r\nreturn -EINVAL;\r\n}\r\nreturn rc;\r\n}\r\nint wil_request_firmware(struct wil6210_priv *wil, const char *name)\r\n{\r\nint rc, rc1;\r\nconst struct firmware *fw;\r\nsize_t sz;\r\nconst void *d;\r\nrc = request_firmware(&fw, name, wil_to_dev(wil));\r\nif (rc) {\r\nwil_err_fw(wil, "Failed to load firmware %s\n", name);\r\nreturn rc;\r\n}\r\nwil_dbg_fw(wil, "Loading <%s>, %zu bytes\n", name, fw->size);\r\nfor (sz = fw->size, d = fw->data; sz; sz -= rc1, d += rc1) {\r\nrc1 = wil_fw_verify(wil, d, sz);\r\nif (rc1 < 0) {\r\nrc = rc1;\r\ngoto out;\r\n}\r\nrc = wil_fw_load(wil, d, rc1);\r\nif (rc < 0)\r\ngoto out;\r\n}\r\nout:\r\nrelease_firmware(fw);\r\nreturn rc;\r\n}
