u32 bcma_chipco_pll_read(struct bcma_drv_cc *cc, u32 offset)\r\n{\r\nbcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR, offset);\r\nbcma_cc_read32(cc, BCMA_CC_PLLCTL_ADDR);\r\nreturn bcma_cc_read32(cc, BCMA_CC_PLLCTL_DATA);\r\n}\r\nvoid bcma_chipco_pll_write(struct bcma_drv_cc *cc, u32 offset, u32 value)\r\n{\r\nbcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR, offset);\r\nbcma_cc_read32(cc, BCMA_CC_PLLCTL_ADDR);\r\nbcma_cc_write32(cc, BCMA_CC_PLLCTL_DATA, value);\r\n}\r\nvoid bcma_chipco_pll_maskset(struct bcma_drv_cc *cc, u32 offset, u32 mask,\r\nu32 set)\r\n{\r\nbcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR, offset);\r\nbcma_cc_read32(cc, BCMA_CC_PLLCTL_ADDR);\r\nbcma_cc_maskset32(cc, BCMA_CC_PLLCTL_DATA, mask, set);\r\n}\r\nvoid bcma_chipco_chipctl_maskset(struct bcma_drv_cc *cc,\r\nu32 offset, u32 mask, u32 set)\r\n{\r\nbcma_cc_write32(cc, BCMA_CC_CHIPCTL_ADDR, offset);\r\nbcma_cc_read32(cc, BCMA_CC_CHIPCTL_ADDR);\r\nbcma_cc_maskset32(cc, BCMA_CC_CHIPCTL_DATA, mask, set);\r\n}\r\nvoid bcma_chipco_regctl_maskset(struct bcma_drv_cc *cc, u32 offset, u32 mask,\r\nu32 set)\r\n{\r\nbcma_cc_write32(cc, BCMA_CC_REGCTL_ADDR, offset);\r\nbcma_cc_read32(cc, BCMA_CC_REGCTL_ADDR);\r\nbcma_cc_maskset32(cc, BCMA_CC_REGCTL_DATA, mask, set);\r\n}\r\nstatic u32 bcma_pmu_xtalfreq(struct bcma_drv_cc *cc)\r\n{\r\nu32 ilp_ctl, alp_hz;\r\nif (!(bcma_cc_read32(cc, BCMA_CC_PMU_STAT) &\r\nBCMA_CC_PMU_STAT_EXT_LPO_AVAIL))\r\nreturn 0;\r\nbcma_cc_write32(cc, BCMA_CC_PMU_XTAL_FREQ,\r\nBIT(BCMA_CC_PMU_XTAL_FREQ_MEASURE_SHIFT));\r\nusleep_range(1000, 2000);\r\nilp_ctl = bcma_cc_read32(cc, BCMA_CC_PMU_XTAL_FREQ);\r\nilp_ctl &= BCMA_CC_PMU_XTAL_FREQ_ILPCTL_MASK;\r\nbcma_cc_write32(cc, BCMA_CC_PMU_XTAL_FREQ, 0);\r\nalp_hz = ilp_ctl * 32768 / 4;\r\nreturn (alp_hz + 50000) / 100000 * 100;\r\n}\r\nstatic void bcma_pmu2_pll_init0(struct bcma_drv_cc *cc, u32 xtalfreq)\r\n{\r\nstruct bcma_bus *bus = cc->core->bus;\r\nu32 freq_tgt_target = 0, freq_tgt_current;\r\nu32 pll0, mask;\r\nswitch (bus->chipinfo.id) {\r\ncase BCMA_CHIP_ID_BCM43142:\r\nswitch (xtalfreq) {\r\ncase 12000:\r\nfreq_tgt_target = 0x50D52;\r\nbreak;\r\ncase 20000:\r\nfreq_tgt_target = 0x307FE;\r\nbreak;\r\ncase 26000:\r\nfreq_tgt_target = 0x254EA;\r\nbreak;\r\ncase 37400:\r\nfreq_tgt_target = 0x19EF8;\r\nbreak;\r\ncase 52000:\r\nfreq_tgt_target = 0x12A75;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nif (!freq_tgt_target) {\r\nbcma_err(bus, "Unknown TGT frequency for xtalfreq %d\n",\r\nxtalfreq);\r\nreturn;\r\n}\r\npll0 = bcma_chipco_pll_read(cc, BCMA_CC_PMU15_PLL_PLLCTL0);\r\nfreq_tgt_current = (pll0 & BCMA_CC_PMU15_PLL_PC0_FREQTGT_MASK) >>\r\nBCMA_CC_PMU15_PLL_PC0_FREQTGT_SHIFT;\r\nif (freq_tgt_current == freq_tgt_target) {\r\nbcma_debug(bus, "Target TGT frequency already set\n");\r\nreturn;\r\n}\r\nswitch (bus->chipinfo.id) {\r\ncase BCMA_CHIP_ID_BCM43142:\r\nmask = (u32)~(BCMA_RES_4314_HT_AVAIL |\r\nBCMA_RES_4314_MACPHY_CLK_AVAIL);\r\nbcma_cc_mask32(cc, BCMA_CC_PMU_MINRES_MSK, mask);\r\nbcma_cc_mask32(cc, BCMA_CC_PMU_MAXRES_MSK, mask);\r\nbcma_wait_value(cc->core, BCMA_CLKCTLST,\r\nBCMA_CLKCTLST_HAVEHT, 0, 20000);\r\nbreak;\r\n}\r\npll0 &= ~BCMA_CC_PMU15_PLL_PC0_FREQTGT_MASK;\r\npll0 |= freq_tgt_target << BCMA_CC_PMU15_PLL_PC0_FREQTGT_SHIFT;\r\nbcma_chipco_pll_write(cc, BCMA_CC_PMU15_PLL_PLLCTL0, pll0);\r\nif (cc->pmu.rev >= 2)\r\nbcma_cc_set32(cc, BCMA_CC_PMU_CTL, BCMA_CC_PMU_CTL_PLL_UPD);\r\n}\r\nstatic void bcma_pmu_pll_init(struct bcma_drv_cc *cc)\r\n{\r\nstruct bcma_bus *bus = cc->core->bus;\r\nu32 xtalfreq = bcma_pmu_xtalfreq(cc);\r\nswitch (bus->chipinfo.id) {\r\ncase BCMA_CHIP_ID_BCM43142:\r\nif (xtalfreq == 0)\r\nxtalfreq = 20000;\r\nbcma_pmu2_pll_init0(cc, xtalfreq);\r\nbreak;\r\n}\r\n}\r\nstatic void bcma_pmu_resources_init(struct bcma_drv_cc *cc)\r\n{\r\nstruct bcma_bus *bus = cc->core->bus;\r\nu32 min_msk = 0, max_msk = 0;\r\nswitch (bus->chipinfo.id) {\r\ncase BCMA_CHIP_ID_BCM4313:\r\nmin_msk = 0x200D;\r\nmax_msk = 0xFFFF;\r\nbreak;\r\ncase BCMA_CHIP_ID_BCM43142:\r\nmin_msk = BCMA_RES_4314_LPLDO_PU |\r\nBCMA_RES_4314_PMU_SLEEP_DIS |\r\nBCMA_RES_4314_PMU_BG_PU |\r\nBCMA_RES_4314_CBUCK_LPOM_PU |\r\nBCMA_RES_4314_CBUCK_PFM_PU |\r\nBCMA_RES_4314_CLDO_PU |\r\nBCMA_RES_4314_LPLDO2_LVM |\r\nBCMA_RES_4314_WL_PMU_PU |\r\nBCMA_RES_4314_LDO3P3_PU |\r\nBCMA_RES_4314_OTP_PU |\r\nBCMA_RES_4314_WL_PWRSW_PU |\r\nBCMA_RES_4314_LQ_AVAIL |\r\nBCMA_RES_4314_LOGIC_RET |\r\nBCMA_RES_4314_MEM_SLEEP |\r\nBCMA_RES_4314_MACPHY_RET |\r\nBCMA_RES_4314_WL_CORE_READY;\r\nmax_msk = 0x3FFFFFFF;\r\nbreak;\r\ndefault:\r\nbcma_debug(bus, "PMU resource config unknown or not needed for device 0x%04X\n",\r\nbus->chipinfo.id);\r\n}\r\nif (min_msk)\r\nbcma_cc_write32(cc, BCMA_CC_PMU_MINRES_MSK, min_msk);\r\nif (max_msk)\r\nbcma_cc_write32(cc, BCMA_CC_PMU_MAXRES_MSK, max_msk);\r\nmdelay(2);\r\n}\r\nvoid bcma_chipco_bcm4331_ext_pa_lines_ctl(struct bcma_drv_cc *cc, bool enable)\r\n{\r\nstruct bcma_bus *bus = cc->core->bus;\r\nu32 val;\r\nval = bcma_cc_read32(cc, BCMA_CC_CHIPCTL);\r\nif (enable) {\r\nval |= BCMA_CHIPCTL_4331_EXTPA_EN;\r\nif (bus->chipinfo.pkg == 9 || bus->chipinfo.pkg == 11)\r\nval |= BCMA_CHIPCTL_4331_EXTPA_ON_GPIO2_5;\r\nelse if (bus->chipinfo.rev > 0)\r\nval |= BCMA_CHIPCTL_4331_EXTPA_EN2;\r\n} else {\r\nval &= ~BCMA_CHIPCTL_4331_EXTPA_EN;\r\nval &= ~BCMA_CHIPCTL_4331_EXTPA_EN2;\r\nval &= ~BCMA_CHIPCTL_4331_EXTPA_ON_GPIO2_5;\r\n}\r\nbcma_cc_write32(cc, BCMA_CC_CHIPCTL, val);\r\n}\r\nstatic void bcma_pmu_workarounds(struct bcma_drv_cc *cc)\r\n{\r\nstruct bcma_bus *bus = cc->core->bus;\r\nswitch (bus->chipinfo.id) {\r\ncase BCMA_CHIP_ID_BCM4313:\r\nbcma_chipco_chipctl_maskset(cc, 0,\r\n~BCMA_CCTRL_4313_12MA_LED_DRIVE,\r\nBCMA_CCTRL_4313_12MA_LED_DRIVE);\r\nbreak;\r\ncase BCMA_CHIP_ID_BCM4331:\r\ncase BCMA_CHIP_ID_BCM43431:\r\nbcma_chipco_bcm4331_ext_pa_lines_ctl(cc, true);\r\nbreak;\r\ncase BCMA_CHIP_ID_BCM43224:\r\ncase BCMA_CHIP_ID_BCM43421:\r\nif (bus->chipinfo.rev == 0) {\r\nbcma_cc_maskset32(cc, BCMA_CC_CHIPCTL,\r\n~BCMA_CCTRL_43224_GPIO_TOGGLE,\r\nBCMA_CCTRL_43224_GPIO_TOGGLE);\r\nbcma_chipco_chipctl_maskset(cc, 0,\r\n~BCMA_CCTRL_43224A0_12MA_LED_DRIVE,\r\nBCMA_CCTRL_43224A0_12MA_LED_DRIVE);\r\n} else {\r\nbcma_chipco_chipctl_maskset(cc, 0,\r\n~BCMA_CCTRL_43224B0_12MA_LED_DRIVE,\r\nBCMA_CCTRL_43224B0_12MA_LED_DRIVE);\r\n}\r\nbreak;\r\ndefault:\r\nbcma_debug(bus, "Workarounds unknown or not needed for device 0x%04X\n",\r\nbus->chipinfo.id);\r\n}\r\n}\r\nvoid bcma_pmu_early_init(struct bcma_drv_cc *cc)\r\n{\r\nu32 pmucap;\r\npmucap = bcma_cc_read32(cc, BCMA_CC_PMU_CAP);\r\ncc->pmu.rev = (pmucap & BCMA_CC_PMU_CAP_REVISION);\r\nbcma_debug(cc->core->bus, "Found rev %u PMU (capabilities 0x%08X)\n",\r\ncc->pmu.rev, pmucap);\r\n}\r\nvoid bcma_pmu_init(struct bcma_drv_cc *cc)\r\n{\r\nif (cc->pmu.rev == 1)\r\nbcma_cc_mask32(cc, BCMA_CC_PMU_CTL,\r\n~BCMA_CC_PMU_CTL_NOILPONW);\r\nelse\r\nbcma_cc_set32(cc, BCMA_CC_PMU_CTL,\r\nBCMA_CC_PMU_CTL_NOILPONW);\r\nbcma_pmu_pll_init(cc);\r\nbcma_pmu_resources_init(cc);\r\nbcma_pmu_workarounds(cc);\r\n}\r\nu32 bcma_pmu_get_alp_clock(struct bcma_drv_cc *cc)\r\n{\r\nstruct bcma_bus *bus = cc->core->bus;\r\nswitch (bus->chipinfo.id) {\r\ncase BCMA_CHIP_ID_BCM4313:\r\ncase BCMA_CHIP_ID_BCM43224:\r\ncase BCMA_CHIP_ID_BCM43225:\r\ncase BCMA_CHIP_ID_BCM43227:\r\ncase BCMA_CHIP_ID_BCM43228:\r\ncase BCMA_CHIP_ID_BCM4331:\r\ncase BCMA_CHIP_ID_BCM43421:\r\ncase BCMA_CHIP_ID_BCM43428:\r\ncase BCMA_CHIP_ID_BCM43431:\r\ncase BCMA_CHIP_ID_BCM4716:\r\ncase BCMA_CHIP_ID_BCM47162:\r\ncase BCMA_CHIP_ID_BCM4748:\r\ncase BCMA_CHIP_ID_BCM4749:\r\ncase BCMA_CHIP_ID_BCM5357:\r\ncase BCMA_CHIP_ID_BCM53572:\r\ncase BCMA_CHIP_ID_BCM6362:\r\nreturn 20000 * 1000;\r\ncase BCMA_CHIP_ID_BCM4706:\r\ncase BCMA_CHIP_ID_BCM5356:\r\nreturn 25000 * 1000;\r\ncase BCMA_CHIP_ID_BCM43460:\r\ncase BCMA_CHIP_ID_BCM4352:\r\ncase BCMA_CHIP_ID_BCM4360:\r\nif (cc->status & BCMA_CC_CHIPST_4360_XTAL_40MZ)\r\nreturn 40000 * 1000;\r\nelse\r\nreturn 20000 * 1000;\r\ndefault:\r\nbcma_warn(bus, "No ALP clock specified for %04X device, pmu rev. %d, using default %d Hz\n",\r\nbus->chipinfo.id, cc->pmu.rev, BCMA_CC_PMU_ALP_CLOCK);\r\n}\r\nreturn BCMA_CC_PMU_ALP_CLOCK;\r\n}\r\nstatic u32 bcma_pmu_pll_clock(struct bcma_drv_cc *cc, u32 pll0, u32 m)\r\n{\r\nu32 tmp, div, ndiv, p1, p2, fc;\r\nstruct bcma_bus *bus = cc->core->bus;\r\nBUG_ON((pll0 & 3) || (pll0 > BCMA_CC_PMU4716_MAINPLL_PLL0));\r\nBUG_ON(!m || m > 4);\r\nif (bus->chipinfo.id == BCMA_CHIP_ID_BCM5357 ||\r\nbus->chipinfo.id == BCMA_CHIP_ID_BCM4749) {\r\ntmp = bcma_cc_read32(cc, BCMA_CC_CHIPSTAT);\r\nif (tmp & 0x40000)\r\nreturn 133 * 1000000;\r\n}\r\ntmp = bcma_chipco_pll_read(cc, pll0 + BCMA_CC_PPL_P1P2_OFF);\r\np1 = (tmp & BCMA_CC_PPL_P1_MASK) >> BCMA_CC_PPL_P1_SHIFT;\r\np2 = (tmp & BCMA_CC_PPL_P2_MASK) >> BCMA_CC_PPL_P2_SHIFT;\r\ntmp = bcma_chipco_pll_read(cc, pll0 + BCMA_CC_PPL_M14_OFF);\r\ndiv = (tmp >> ((m - 1) * BCMA_CC_PPL_MDIV_WIDTH)) &\r\nBCMA_CC_PPL_MDIV_MASK;\r\ntmp = bcma_chipco_pll_read(cc, pll0 + BCMA_CC_PPL_NM5_OFF);\r\nndiv = (tmp & BCMA_CC_PPL_NDIV_MASK) >> BCMA_CC_PPL_NDIV_SHIFT;\r\nfc = bcma_pmu_get_alp_clock(cc) / 1000000;\r\nfc = (p1 * ndiv * fc) / p2;\r\nreturn (fc / div) * 1000000;\r\n}\r\nstatic u32 bcma_pmu_pll_clock_bcm4706(struct bcma_drv_cc *cc, u32 pll0, u32 m)\r\n{\r\nu32 tmp, ndiv, p1div, p2div;\r\nu32 clock;\r\nBUG_ON(!m || m > 4);\r\ntmp = bcma_chipco_pll_read(cc, pll0 + BCMA_CC_PMU6_4706_PROCPLL_OFF);\r\nndiv = (tmp & BCMA_CC_PMU6_4706_PROC_NDIV_INT_MASK)\r\n>> BCMA_CC_PMU6_4706_PROC_NDIV_INT_SHIFT;\r\np1div = (tmp & BCMA_CC_PMU6_4706_PROC_P1DIV_MASK)\r\n>> BCMA_CC_PMU6_4706_PROC_P1DIV_SHIFT;\r\np2div = (tmp & BCMA_CC_PMU6_4706_PROC_P2DIV_MASK)\r\n>> BCMA_CC_PMU6_4706_PROC_P2DIV_SHIFT;\r\ntmp = bcma_cc_read32(cc, BCMA_CC_CHIPSTAT);\r\nif (tmp & BCMA_CC_CHIPST_4706_PKG_OPTION)\r\nclock = (25000000 / 4) * ndiv * p2div / p1div;\r\nelse\r\nclock = (25000000 / 2) * ndiv * p2div / p1div;\r\nif (m == BCMA_CC_PMU5_MAINPLL_SSB)\r\nclock = clock / 4;\r\nreturn clock;\r\n}\r\nu32 bcma_pmu_get_bus_clock(struct bcma_drv_cc *cc)\r\n{\r\nstruct bcma_bus *bus = cc->core->bus;\r\nswitch (bus->chipinfo.id) {\r\ncase BCMA_CHIP_ID_BCM4716:\r\ncase BCMA_CHIP_ID_BCM4748:\r\ncase BCMA_CHIP_ID_BCM47162:\r\nreturn bcma_pmu_pll_clock(cc, BCMA_CC_PMU4716_MAINPLL_PLL0,\r\nBCMA_CC_PMU5_MAINPLL_SSB);\r\ncase BCMA_CHIP_ID_BCM5356:\r\nreturn bcma_pmu_pll_clock(cc, BCMA_CC_PMU5356_MAINPLL_PLL0,\r\nBCMA_CC_PMU5_MAINPLL_SSB);\r\ncase BCMA_CHIP_ID_BCM5357:\r\ncase BCMA_CHIP_ID_BCM4749:\r\nreturn bcma_pmu_pll_clock(cc, BCMA_CC_PMU5357_MAINPLL_PLL0,\r\nBCMA_CC_PMU5_MAINPLL_SSB);\r\ncase BCMA_CHIP_ID_BCM4706:\r\nreturn bcma_pmu_pll_clock_bcm4706(cc,\r\nBCMA_CC_PMU4706_MAINPLL_PLL0,\r\nBCMA_CC_PMU5_MAINPLL_SSB);\r\ncase BCMA_CHIP_ID_BCM53572:\r\nreturn 75000000;\r\ndefault:\r\nbcma_warn(bus, "No bus clock specified for %04X device, pmu rev. %d, using default %d Hz\n",\r\nbus->chipinfo.id, cc->pmu.rev, BCMA_CC_PMU_HT_CLOCK);\r\n}\r\nreturn BCMA_CC_PMU_HT_CLOCK;\r\n}\r\nu32 bcma_pmu_get_cpu_clock(struct bcma_drv_cc *cc)\r\n{\r\nstruct bcma_bus *bus = cc->core->bus;\r\nif (bus->chipinfo.id == BCMA_CHIP_ID_BCM53572)\r\nreturn 300000000;\r\nif (cc->pmu.rev >= 5) {\r\nu32 pll;\r\nswitch (bus->chipinfo.id) {\r\ncase BCMA_CHIP_ID_BCM4706:\r\nreturn bcma_pmu_pll_clock_bcm4706(cc,\r\nBCMA_CC_PMU4706_MAINPLL_PLL0,\r\nBCMA_CC_PMU5_MAINPLL_CPU);\r\ncase BCMA_CHIP_ID_BCM5356:\r\npll = BCMA_CC_PMU5356_MAINPLL_PLL0;\r\nbreak;\r\ncase BCMA_CHIP_ID_BCM5357:\r\ncase BCMA_CHIP_ID_BCM4749:\r\npll = BCMA_CC_PMU5357_MAINPLL_PLL0;\r\nbreak;\r\ndefault:\r\npll = BCMA_CC_PMU4716_MAINPLL_PLL0;\r\nbreak;\r\n}\r\nreturn bcma_pmu_pll_clock(cc, pll, BCMA_CC_PMU5_MAINPLL_CPU);\r\n}\r\nreturn bcma_pmu_get_bus_clock(cc);\r\n}\r\nstatic void bcma_pmu_spuravoid_pll_write(struct bcma_drv_cc *cc, u32 offset,\r\nu32 value)\r\n{\r\nbcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR, offset);\r\nbcma_cc_write32(cc, BCMA_CC_PLLCTL_DATA, value);\r\n}\r\nvoid bcma_pmu_spuravoid_pllupdate(struct bcma_drv_cc *cc, int spuravoid)\r\n{\r\nu32 tmp = 0;\r\nu8 phypll_offset = 0;\r\nu8 bcm5357_bcm43236_p1div[] = {0x1, 0x5, 0x5};\r\nu8 bcm5357_bcm43236_ndiv[] = {0x30, 0xf6, 0xfc};\r\nstruct bcma_bus *bus = cc->core->bus;\r\nswitch (bus->chipinfo.id) {\r\ncase BCMA_CHIP_ID_BCM5357:\r\ncase BCMA_CHIP_ID_BCM4749:\r\ncase BCMA_CHIP_ID_BCM53572:\r\nphypll_offset = (bus->chipinfo.id == BCMA_CHIP_ID_BCM5357 ||\r\nbus->chipinfo.id == BCMA_CHIP_ID_BCM4749 ||\r\nbus->chipinfo.id == BCMA_CHIP_ID_BCM53572) ? 6 : 0;\r\nbcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR,\r\nBCMA_CC_PMU_PLL_CTL0 + phypll_offset);\r\ntmp = bcma_cc_read32(cc, BCMA_CC_PLLCTL_DATA);\r\ntmp &= (~(BCMA_CC_PMU1_PLL0_PC0_P1DIV_MASK));\r\ntmp |= (bcm5357_bcm43236_p1div[spuravoid] << BCMA_CC_PMU1_PLL0_PC0_P1DIV_SHIFT);\r\nbcma_cc_write32(cc, BCMA_CC_PLLCTL_DATA, tmp);\r\nbcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR,\r\nBCMA_CC_PMU_PLL_CTL2 + phypll_offset);\r\ntmp = bcma_cc_read32(cc, BCMA_CC_PLLCTL_DATA);\r\ntmp &= ~(BCMA_CC_PMU1_PLL0_PC2_NDIV_INT_MASK);\r\ntmp |= (bcm5357_bcm43236_ndiv[spuravoid]) << BCMA_CC_PMU1_PLL0_PC2_NDIV_INT_SHIFT;\r\nbcma_cc_write32(cc, BCMA_CC_PLLCTL_DATA, tmp);\r\ntmp = BCMA_CC_PMU_CTL_PLL_UPD;\r\nbreak;\r\ncase BCMA_CHIP_ID_BCM4331:\r\ncase BCMA_CHIP_ID_BCM43431:\r\nif (spuravoid == 2) {\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,\r\n0x11500014);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,\r\n0x0FC00a08);\r\n} else if (spuravoid == 1) {\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,\r\n0x11500014);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,\r\n0x0F600a08);\r\n} else {\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,\r\n0x11100014);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,\r\n0x03000a08);\r\n}\r\ntmp = BCMA_CC_PMU_CTL_PLL_UPD;\r\nbreak;\r\ncase BCMA_CHIP_ID_BCM43224:\r\ncase BCMA_CHIP_ID_BCM43225:\r\ncase BCMA_CHIP_ID_BCM43421:\r\nif (spuravoid == 1) {\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,\r\n0x11500010);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL1,\r\n0x000C0C06);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,\r\n0x0F600a08);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL3,\r\n0x00000000);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL4,\r\n0x2001E920);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL5,\r\n0x88888815);\r\n} else {\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,\r\n0x11100010);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL1,\r\n0x000c0c06);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,\r\n0x03000a08);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL3,\r\n0x00000000);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL4,\r\n0x200005c0);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL5,\r\n0x88888815);\r\n}\r\ntmp = BCMA_CC_PMU_CTL_PLL_UPD;\r\nbreak;\r\ncase BCMA_CHIP_ID_BCM4716:\r\ncase BCMA_CHIP_ID_BCM4748:\r\ncase BCMA_CHIP_ID_BCM47162:\r\nif (spuravoid == 1) {\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,\r\n0x11500060);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL1,\r\n0x080C0C06);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,\r\n0x0F600000);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL3,\r\n0x00000000);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL4,\r\n0x2001E924);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL5,\r\n0x88888815);\r\n} else {\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,\r\n0x11100060);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL1,\r\n0x080c0c06);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,\r\n0x03000000);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL3,\r\n0x00000000);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL4,\r\n0x200005c0);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL5,\r\n0x88888815);\r\n}\r\ntmp = BCMA_CC_PMU_CTL_PLL_UPD | BCMA_CC_PMU_CTL_NOILPONW;\r\nbreak;\r\ncase BCMA_CHIP_ID_BCM43131:\r\ncase BCMA_CHIP_ID_BCM43217:\r\ncase BCMA_CHIP_ID_BCM43227:\r\ncase BCMA_CHIP_ID_BCM43228:\r\ncase BCMA_CHIP_ID_BCM43428:\r\nif (spuravoid == 1) {\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,\r\n0x01100014);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL1,\r\n0x040C0C06);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,\r\n0x03140A08);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL3,\r\n0x00333333);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL4,\r\n0x202C2820);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL5,\r\n0x88888815);\r\n} else {\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,\r\n0x11100014);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL1,\r\n0x040c0c06);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,\r\n0x03000a08);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL3,\r\n0x00000000);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL4,\r\n0x200005c0);\r\nbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL5,\r\n0x88888815);\r\n}\r\ntmp = BCMA_CC_PMU_CTL_PLL_UPD;\r\nbreak;\r\ndefault:\r\nbcma_err(bus, "Unknown spuravoidance settings for chip 0x%04X, not changing PLL\n",\r\nbus->chipinfo.id);\r\nbreak;\r\n}\r\ntmp |= bcma_cc_read32(cc, BCMA_CC_PMU_CTL);\r\nbcma_cc_write32(cc, BCMA_CC_PMU_CTL, tmp);\r\n}
