static inline int _tg3_flag(enum TG3_FLAGS flag, unsigned long *bits)\r\n{\r\nreturn test_bit(flag, bits);\r\n}\r\nstatic inline void _tg3_flag_set(enum TG3_FLAGS flag, unsigned long *bits)\r\n{\r\nset_bit(flag, bits);\r\n}\r\nstatic inline void _tg3_flag_clear(enum TG3_FLAGS flag, unsigned long *bits)\r\n{\r\nclear_bit(flag, bits);\r\n}\r\nstatic void tg3_write32(struct tg3 *tp, u32 off, u32 val)\r\n{\r\nwritel(val, tp->regs + off);\r\n}\r\nstatic u32 tg3_read32(struct tg3 *tp, u32 off)\r\n{\r\nreturn readl(tp->regs + off);\r\n}\r\nstatic void tg3_ape_write32(struct tg3 *tp, u32 off, u32 val)\r\n{\r\nwritel(val, tp->aperegs + off);\r\n}\r\nstatic u32 tg3_ape_read32(struct tg3 *tp, u32 off)\r\n{\r\nreturn readl(tp->aperegs + off);\r\n}\r\nstatic void tg3_write_indirect_reg32(struct tg3 *tp, u32 off, u32 val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tp->indirect_lock, flags);\r\npci_write_config_dword(tp->pdev, TG3PCI_REG_BASE_ADDR, off);\r\npci_write_config_dword(tp->pdev, TG3PCI_REG_DATA, val);\r\nspin_unlock_irqrestore(&tp->indirect_lock, flags);\r\n}\r\nstatic void tg3_write_flush_reg32(struct tg3 *tp, u32 off, u32 val)\r\n{\r\nwritel(val, tp->regs + off);\r\nreadl(tp->regs + off);\r\n}\r\nstatic u32 tg3_read_indirect_reg32(struct tg3 *tp, u32 off)\r\n{\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&tp->indirect_lock, flags);\r\npci_write_config_dword(tp->pdev, TG3PCI_REG_BASE_ADDR, off);\r\npci_read_config_dword(tp->pdev, TG3PCI_REG_DATA, &val);\r\nspin_unlock_irqrestore(&tp->indirect_lock, flags);\r\nreturn val;\r\n}\r\nstatic void tg3_write_indirect_mbox(struct tg3 *tp, u32 off, u32 val)\r\n{\r\nunsigned long flags;\r\nif (off == (MAILBOX_RCVRET_CON_IDX_0 + TG3_64BIT_REG_LOW)) {\r\npci_write_config_dword(tp->pdev, TG3PCI_RCV_RET_RING_CON_IDX +\r\nTG3_64BIT_REG_LOW, val);\r\nreturn;\r\n}\r\nif (off == TG3_RX_STD_PROD_IDX_REG) {\r\npci_write_config_dword(tp->pdev, TG3PCI_STD_RING_PROD_IDX +\r\nTG3_64BIT_REG_LOW, val);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&tp->indirect_lock, flags);\r\npci_write_config_dword(tp->pdev, TG3PCI_REG_BASE_ADDR, off + 0x5600);\r\npci_write_config_dword(tp->pdev, TG3PCI_REG_DATA, val);\r\nspin_unlock_irqrestore(&tp->indirect_lock, flags);\r\nif ((off == (MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW)) &&\r\n(val == 0x1)) {\r\npci_write_config_dword(tp->pdev, TG3PCI_MISC_LOCAL_CTRL,\r\ntp->grc_local_ctrl|GRC_LCLCTRL_CLEARINT);\r\n}\r\n}\r\nstatic u32 tg3_read_indirect_mbox(struct tg3 *tp, u32 off)\r\n{\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&tp->indirect_lock, flags);\r\npci_write_config_dword(tp->pdev, TG3PCI_REG_BASE_ADDR, off + 0x5600);\r\npci_read_config_dword(tp->pdev, TG3PCI_REG_DATA, &val);\r\nspin_unlock_irqrestore(&tp->indirect_lock, flags);\r\nreturn val;\r\n}\r\nstatic void _tw32_flush(struct tg3 *tp, u32 off, u32 val, u32 usec_wait)\r\n{\r\nif (tg3_flag(tp, PCIX_TARGET_HWBUG) || tg3_flag(tp, ICH_WORKAROUND))\r\ntp->write32(tp, off, val);\r\nelse {\r\ntg3_write32(tp, off, val);\r\nif (usec_wait)\r\nudelay(usec_wait);\r\ntp->read32(tp, off);\r\n}\r\nif (usec_wait)\r\nudelay(usec_wait);\r\n}\r\nstatic inline void tw32_mailbox_flush(struct tg3 *tp, u32 off, u32 val)\r\n{\r\ntp->write32_mbox(tp, off, val);\r\nif (tg3_flag(tp, FLUSH_POSTED_WRITES) ||\r\n(!tg3_flag(tp, MBOX_WRITE_REORDER) &&\r\n!tg3_flag(tp, ICH_WORKAROUND)))\r\ntp->read32_mbox(tp, off);\r\n}\r\nstatic void tg3_write32_tx_mbox(struct tg3 *tp, u32 off, u32 val)\r\n{\r\nvoid __iomem *mbox = tp->regs + off;\r\nwritel(val, mbox);\r\nif (tg3_flag(tp, TXD_MBOX_HWBUG))\r\nwritel(val, mbox);\r\nif (tg3_flag(tp, MBOX_WRITE_REORDER) ||\r\ntg3_flag(tp, FLUSH_POSTED_WRITES))\r\nreadl(mbox);\r\n}\r\nstatic u32 tg3_read32_mbox_5906(struct tg3 *tp, u32 off)\r\n{\r\nreturn readl(tp->regs + off + GRCMBOX_BASE);\r\n}\r\nstatic void tg3_write32_mbox_5906(struct tg3 *tp, u32 off, u32 val)\r\n{\r\nwritel(val, tp->regs + off + GRCMBOX_BASE);\r\n}\r\nstatic void tg3_write_mem(struct tg3 *tp, u32 off, u32 val)\r\n{\r\nunsigned long flags;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5906 &&\r\n(off >= NIC_SRAM_STATS_BLK) && (off < NIC_SRAM_TX_BUFFER_DESC))\r\nreturn;\r\nspin_lock_irqsave(&tp->indirect_lock, flags);\r\nif (tg3_flag(tp, SRAM_USE_CONFIG)) {\r\npci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, off);\r\npci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_DATA, val);\r\npci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, 0);\r\n} else {\r\ntw32_f(TG3PCI_MEM_WIN_BASE_ADDR, off);\r\ntw32_f(TG3PCI_MEM_WIN_DATA, val);\r\ntw32_f(TG3PCI_MEM_WIN_BASE_ADDR, 0);\r\n}\r\nspin_unlock_irqrestore(&tp->indirect_lock, flags);\r\n}\r\nstatic void tg3_read_mem(struct tg3 *tp, u32 off, u32 *val)\r\n{\r\nunsigned long flags;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5906 &&\r\n(off >= NIC_SRAM_STATS_BLK) && (off < NIC_SRAM_TX_BUFFER_DESC)) {\r\n*val = 0;\r\nreturn;\r\n}\r\nspin_lock_irqsave(&tp->indirect_lock, flags);\r\nif (tg3_flag(tp, SRAM_USE_CONFIG)) {\r\npci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, off);\r\npci_read_config_dword(tp->pdev, TG3PCI_MEM_WIN_DATA, val);\r\npci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, 0);\r\n} else {\r\ntw32_f(TG3PCI_MEM_WIN_BASE_ADDR, off);\r\n*val = tr32(TG3PCI_MEM_WIN_DATA);\r\ntw32_f(TG3PCI_MEM_WIN_BASE_ADDR, 0);\r\n}\r\nspin_unlock_irqrestore(&tp->indirect_lock, flags);\r\n}\r\nstatic void tg3_ape_lock_init(struct tg3 *tp)\r\n{\r\nint i;\r\nu32 regbase, bit;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5761)\r\nregbase = TG3_APE_LOCK_GRANT;\r\nelse\r\nregbase = TG3_APE_PER_LOCK_GRANT;\r\nfor (i = TG3_APE_LOCK_PHY0; i <= TG3_APE_LOCK_GPIO; i++) {\r\nswitch (i) {\r\ncase TG3_APE_LOCK_PHY0:\r\ncase TG3_APE_LOCK_PHY1:\r\ncase TG3_APE_LOCK_PHY2:\r\ncase TG3_APE_LOCK_PHY3:\r\nbit = APE_LOCK_GRANT_DRIVER;\r\nbreak;\r\ndefault:\r\nif (!tp->pci_fn)\r\nbit = APE_LOCK_GRANT_DRIVER;\r\nelse\r\nbit = 1 << tp->pci_fn;\r\n}\r\ntg3_ape_write32(tp, regbase + 4 * i, bit);\r\n}\r\n}\r\nstatic int tg3_ape_lock(struct tg3 *tp, int locknum)\r\n{\r\nint i, off;\r\nint ret = 0;\r\nu32 status, req, gnt, bit;\r\nif (!tg3_flag(tp, ENABLE_APE))\r\nreturn 0;\r\nswitch (locknum) {\r\ncase TG3_APE_LOCK_GPIO:\r\nif (tg3_asic_rev(tp) == ASIC_REV_5761)\r\nreturn 0;\r\ncase TG3_APE_LOCK_GRC:\r\ncase TG3_APE_LOCK_MEM:\r\nif (!tp->pci_fn)\r\nbit = APE_LOCK_REQ_DRIVER;\r\nelse\r\nbit = 1 << tp->pci_fn;\r\nbreak;\r\ncase TG3_APE_LOCK_PHY0:\r\ncase TG3_APE_LOCK_PHY1:\r\ncase TG3_APE_LOCK_PHY2:\r\ncase TG3_APE_LOCK_PHY3:\r\nbit = APE_LOCK_REQ_DRIVER;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5761) {\r\nreq = TG3_APE_LOCK_REQ;\r\ngnt = TG3_APE_LOCK_GRANT;\r\n} else {\r\nreq = TG3_APE_PER_LOCK_REQ;\r\ngnt = TG3_APE_PER_LOCK_GRANT;\r\n}\r\noff = 4 * locknum;\r\ntg3_ape_write32(tp, req + off, bit);\r\nfor (i = 0; i < 100; i++) {\r\nstatus = tg3_ape_read32(tp, gnt + off);\r\nif (status == bit)\r\nbreak;\r\nif (pci_channel_offline(tp->pdev))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (status != bit) {\r\ntg3_ape_write32(tp, gnt + off, bit);\r\nret = -EBUSY;\r\n}\r\nreturn ret;\r\n}\r\nstatic void tg3_ape_unlock(struct tg3 *tp, int locknum)\r\n{\r\nu32 gnt, bit;\r\nif (!tg3_flag(tp, ENABLE_APE))\r\nreturn;\r\nswitch (locknum) {\r\ncase TG3_APE_LOCK_GPIO:\r\nif (tg3_asic_rev(tp) == ASIC_REV_5761)\r\nreturn;\r\ncase TG3_APE_LOCK_GRC:\r\ncase TG3_APE_LOCK_MEM:\r\nif (!tp->pci_fn)\r\nbit = APE_LOCK_GRANT_DRIVER;\r\nelse\r\nbit = 1 << tp->pci_fn;\r\nbreak;\r\ncase TG3_APE_LOCK_PHY0:\r\ncase TG3_APE_LOCK_PHY1:\r\ncase TG3_APE_LOCK_PHY2:\r\ncase TG3_APE_LOCK_PHY3:\r\nbit = APE_LOCK_GRANT_DRIVER;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5761)\r\ngnt = TG3_APE_LOCK_GRANT;\r\nelse\r\ngnt = TG3_APE_PER_LOCK_GRANT;\r\ntg3_ape_write32(tp, gnt + 4 * locknum, bit);\r\n}\r\nstatic int tg3_ape_event_lock(struct tg3 *tp, u32 timeout_us)\r\n{\r\nu32 apedata;\r\nwhile (timeout_us) {\r\nif (tg3_ape_lock(tp, TG3_APE_LOCK_MEM))\r\nreturn -EBUSY;\r\napedata = tg3_ape_read32(tp, TG3_APE_EVENT_STATUS);\r\nif (!(apedata & APE_EVENT_STATUS_EVENT_PENDING))\r\nbreak;\r\ntg3_ape_unlock(tp, TG3_APE_LOCK_MEM);\r\nudelay(10);\r\ntimeout_us -= (timeout_us > 10) ? 10 : timeout_us;\r\n}\r\nreturn timeout_us ? 0 : -EBUSY;\r\n}\r\nstatic int tg3_ape_wait_for_event(struct tg3 *tp, u32 timeout_us)\r\n{\r\nu32 i, apedata;\r\nfor (i = 0; i < timeout_us / 10; i++) {\r\napedata = tg3_ape_read32(tp, TG3_APE_EVENT_STATUS);\r\nif (!(apedata & APE_EVENT_STATUS_EVENT_PENDING))\r\nbreak;\r\nudelay(10);\r\n}\r\nreturn i == timeout_us / 10;\r\n}\r\nstatic int tg3_ape_scratchpad_read(struct tg3 *tp, u32 *data, u32 base_off,\r\nu32 len)\r\n{\r\nint err;\r\nu32 i, bufoff, msgoff, maxlen, apedata;\r\nif (!tg3_flag(tp, APE_HAS_NCSI))\r\nreturn 0;\r\napedata = tg3_ape_read32(tp, TG3_APE_SEG_SIG);\r\nif (apedata != APE_SEG_SIG_MAGIC)\r\nreturn -ENODEV;\r\napedata = tg3_ape_read32(tp, TG3_APE_FW_STATUS);\r\nif (!(apedata & APE_FW_STATUS_READY))\r\nreturn -EAGAIN;\r\nbufoff = tg3_ape_read32(tp, TG3_APE_SEG_MSG_BUF_OFF) +\r\nTG3_APE_SHMEM_BASE;\r\nmsgoff = bufoff + 2 * sizeof(u32);\r\nmaxlen = tg3_ape_read32(tp, TG3_APE_SEG_MSG_BUF_LEN);\r\nwhile (len) {\r\nu32 length;\r\nlength = (len > maxlen) ? maxlen : len;\r\nlen -= length;\r\napedata = tg3_ape_read32(tp, TG3_APE_FW_STATUS);\r\nif (!(apedata & APE_FW_STATUS_READY))\r\nreturn -EAGAIN;\r\nerr = tg3_ape_event_lock(tp, 1000);\r\nif (err)\r\nreturn err;\r\napedata = APE_EVENT_STATUS_DRIVER_EVNT |\r\nAPE_EVENT_STATUS_SCRTCHPD_READ |\r\nAPE_EVENT_STATUS_EVENT_PENDING;\r\ntg3_ape_write32(tp, TG3_APE_EVENT_STATUS, apedata);\r\ntg3_ape_write32(tp, bufoff, base_off);\r\ntg3_ape_write32(tp, bufoff + sizeof(u32), length);\r\ntg3_ape_unlock(tp, TG3_APE_LOCK_MEM);\r\ntg3_ape_write32(tp, TG3_APE_EVENT, APE_EVENT_1);\r\nbase_off += length;\r\nif (tg3_ape_wait_for_event(tp, 30000))\r\nreturn -EAGAIN;\r\nfor (i = 0; length; i += 4, length -= 4) {\r\nu32 val = tg3_ape_read32(tp, msgoff + i);\r\nmemcpy(data, &val, sizeof(u32));\r\ndata++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tg3_ape_send_event(struct tg3 *tp, u32 event)\r\n{\r\nint err;\r\nu32 apedata;\r\napedata = tg3_ape_read32(tp, TG3_APE_SEG_SIG);\r\nif (apedata != APE_SEG_SIG_MAGIC)\r\nreturn -EAGAIN;\r\napedata = tg3_ape_read32(tp, TG3_APE_FW_STATUS);\r\nif (!(apedata & APE_FW_STATUS_READY))\r\nreturn -EAGAIN;\r\nerr = tg3_ape_event_lock(tp, 1000);\r\nif (err)\r\nreturn err;\r\ntg3_ape_write32(tp, TG3_APE_EVENT_STATUS,\r\nevent | APE_EVENT_STATUS_EVENT_PENDING);\r\ntg3_ape_unlock(tp, TG3_APE_LOCK_MEM);\r\ntg3_ape_write32(tp, TG3_APE_EVENT, APE_EVENT_1);\r\nreturn 0;\r\n}\r\nstatic void tg3_ape_driver_state_change(struct tg3 *tp, int kind)\r\n{\r\nu32 event;\r\nu32 apedata;\r\nif (!tg3_flag(tp, ENABLE_APE))\r\nreturn;\r\nswitch (kind) {\r\ncase RESET_KIND_INIT:\r\ntg3_ape_write32(tp, TG3_APE_HOST_SEG_SIG,\r\nAPE_HOST_SEG_SIG_MAGIC);\r\ntg3_ape_write32(tp, TG3_APE_HOST_SEG_LEN,\r\nAPE_HOST_SEG_LEN_MAGIC);\r\napedata = tg3_ape_read32(tp, TG3_APE_HOST_INIT_COUNT);\r\ntg3_ape_write32(tp, TG3_APE_HOST_INIT_COUNT, ++apedata);\r\ntg3_ape_write32(tp, TG3_APE_HOST_DRIVER_ID,\r\nAPE_HOST_DRIVER_ID_MAGIC(TG3_MAJ_NUM, TG3_MIN_NUM));\r\ntg3_ape_write32(tp, TG3_APE_HOST_BEHAVIOR,\r\nAPE_HOST_BEHAV_NO_PHYLOCK);\r\ntg3_ape_write32(tp, TG3_APE_HOST_DRVR_STATE,\r\nTG3_APE_HOST_DRVR_STATE_START);\r\nevent = APE_EVENT_STATUS_STATE_START;\r\nbreak;\r\ncase RESET_KIND_SHUTDOWN:\r\ntg3_ape_write32(tp, TG3_APE_HOST_SEG_SIG, 0x0);\r\nif (device_may_wakeup(&tp->pdev->dev) &&\r\ntg3_flag(tp, WOL_ENABLE)) {\r\ntg3_ape_write32(tp, TG3_APE_HOST_WOL_SPEED,\r\nTG3_APE_HOST_WOL_SPEED_AUTO);\r\napedata = TG3_APE_HOST_DRVR_STATE_WOL;\r\n} else\r\napedata = TG3_APE_HOST_DRVR_STATE_UNLOAD;\r\ntg3_ape_write32(tp, TG3_APE_HOST_DRVR_STATE, apedata);\r\nevent = APE_EVENT_STATUS_STATE_UNLOAD;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nevent |= APE_EVENT_STATUS_DRIVER_EVNT | APE_EVENT_STATUS_STATE_CHNGE;\r\ntg3_ape_send_event(tp, event);\r\n}\r\nstatic void tg3_disable_ints(struct tg3 *tp)\r\n{\r\nint i;\r\ntw32(TG3PCI_MISC_HOST_CTRL,\r\n(tp->misc_host_ctrl | MISC_HOST_CTRL_MASK_PCI_INT));\r\nfor (i = 0; i < tp->irq_max; i++)\r\ntw32_mailbox_f(tp->napi[i].int_mbox, 0x00000001);\r\n}\r\nstatic void tg3_enable_ints(struct tg3 *tp)\r\n{\r\nint i;\r\ntp->irq_sync = 0;\r\nwmb();\r\ntw32(TG3PCI_MISC_HOST_CTRL,\r\n(tp->misc_host_ctrl & ~MISC_HOST_CTRL_MASK_PCI_INT));\r\ntp->coal_now = tp->coalesce_mode | HOSTCC_MODE_ENABLE;\r\nfor (i = 0; i < tp->irq_cnt; i++) {\r\nstruct tg3_napi *tnapi = &tp->napi[i];\r\ntw32_mailbox_f(tnapi->int_mbox, tnapi->last_tag << 24);\r\nif (tg3_flag(tp, 1SHOT_MSI))\r\ntw32_mailbox_f(tnapi->int_mbox, tnapi->last_tag << 24);\r\ntp->coal_now |= tnapi->coal_now;\r\n}\r\nif (!tg3_flag(tp, TAGGED_STATUS) &&\r\n(tp->napi[0].hw_status->status & SD_STATUS_UPDATED))\r\ntw32(GRC_LOCAL_CTRL, tp->grc_local_ctrl | GRC_LCLCTRL_SETINT);\r\nelse\r\ntw32(HOSTCC_MODE, tp->coal_now);\r\ntp->coal_now &= ~(tp->napi[0].coal_now | tp->napi[1].coal_now);\r\n}\r\nstatic inline unsigned int tg3_has_work(struct tg3_napi *tnapi)\r\n{\r\nstruct tg3 *tp = tnapi->tp;\r\nstruct tg3_hw_status *sblk = tnapi->hw_status;\r\nunsigned int work_exists = 0;\r\nif (!(tg3_flag(tp, USE_LINKCHG_REG) || tg3_flag(tp, POLL_SERDES))) {\r\nif (sblk->status & SD_STATUS_LINK_CHG)\r\nwork_exists = 1;\r\n}\r\nif (sblk->idx[0].tx_consumer != tnapi->tx_cons)\r\nwork_exists = 1;\r\nif (tnapi->rx_rcb_prod_idx &&\r\n*(tnapi->rx_rcb_prod_idx) != tnapi->rx_rcb_ptr)\r\nwork_exists = 1;\r\nreturn work_exists;\r\n}\r\nstatic void tg3_int_reenable(struct tg3_napi *tnapi)\r\n{\r\nstruct tg3 *tp = tnapi->tp;\r\ntw32_mailbox(tnapi->int_mbox, tnapi->last_tag << 24);\r\nmmiowb();\r\nif (!tg3_flag(tp, TAGGED_STATUS) && tg3_has_work(tnapi))\r\ntw32(HOSTCC_MODE, tp->coalesce_mode |\r\nHOSTCC_MODE_ENABLE | tnapi->coal_now);\r\n}\r\nstatic void tg3_switch_clocks(struct tg3 *tp)\r\n{\r\nu32 clock_ctrl;\r\nu32 orig_clock_ctrl;\r\nif (tg3_flag(tp, CPMU_PRESENT) || tg3_flag(tp, 5780_CLASS))\r\nreturn;\r\nclock_ctrl = tr32(TG3PCI_CLOCK_CTRL);\r\norig_clock_ctrl = clock_ctrl;\r\nclock_ctrl &= (CLOCK_CTRL_FORCE_CLKRUN |\r\nCLOCK_CTRL_CLKRUN_OENABLE |\r\n0x1f);\r\ntp->pci_clock_ctrl = clock_ctrl;\r\nif (tg3_flag(tp, 5705_PLUS)) {\r\nif (orig_clock_ctrl & CLOCK_CTRL_625_CORE) {\r\ntw32_wait_f(TG3PCI_CLOCK_CTRL,\r\nclock_ctrl | CLOCK_CTRL_625_CORE, 40);\r\n}\r\n} else if ((orig_clock_ctrl & CLOCK_CTRL_44MHZ_CORE) != 0) {\r\ntw32_wait_f(TG3PCI_CLOCK_CTRL,\r\nclock_ctrl |\r\n(CLOCK_CTRL_44MHZ_CORE | CLOCK_CTRL_ALTCLK),\r\n40);\r\ntw32_wait_f(TG3PCI_CLOCK_CTRL,\r\nclock_ctrl | (CLOCK_CTRL_ALTCLK),\r\n40);\r\n}\r\ntw32_wait_f(TG3PCI_CLOCK_CTRL, clock_ctrl, 40);\r\n}\r\nstatic int __tg3_readphy(struct tg3 *tp, unsigned int phy_addr, int reg,\r\nu32 *val)\r\n{\r\nu32 frame_val;\r\nunsigned int loops;\r\nint ret;\r\nif ((tp->mi_mode & MAC_MI_MODE_AUTO_POLL) != 0) {\r\ntw32_f(MAC_MI_MODE,\r\n(tp->mi_mode & ~MAC_MI_MODE_AUTO_POLL));\r\nudelay(80);\r\n}\r\ntg3_ape_lock(tp, tp->phy_ape_lock);\r\n*val = 0x0;\r\nframe_val = ((phy_addr << MI_COM_PHY_ADDR_SHIFT) &\r\nMI_COM_PHY_ADDR_MASK);\r\nframe_val |= ((reg << MI_COM_REG_ADDR_SHIFT) &\r\nMI_COM_REG_ADDR_MASK);\r\nframe_val |= (MI_COM_CMD_READ | MI_COM_START);\r\ntw32_f(MAC_MI_COM, frame_val);\r\nloops = PHY_BUSY_LOOPS;\r\nwhile (loops != 0) {\r\nudelay(10);\r\nframe_val = tr32(MAC_MI_COM);\r\nif ((frame_val & MI_COM_BUSY) == 0) {\r\nudelay(5);\r\nframe_val = tr32(MAC_MI_COM);\r\nbreak;\r\n}\r\nloops -= 1;\r\n}\r\nret = -EBUSY;\r\nif (loops != 0) {\r\n*val = frame_val & MI_COM_DATA_MASK;\r\nret = 0;\r\n}\r\nif ((tp->mi_mode & MAC_MI_MODE_AUTO_POLL) != 0) {\r\ntw32_f(MAC_MI_MODE, tp->mi_mode);\r\nudelay(80);\r\n}\r\ntg3_ape_unlock(tp, tp->phy_ape_lock);\r\nreturn ret;\r\n}\r\nstatic int tg3_readphy(struct tg3 *tp, int reg, u32 *val)\r\n{\r\nreturn __tg3_readphy(tp, tp->phy_addr, reg, val);\r\n}\r\nstatic int __tg3_writephy(struct tg3 *tp, unsigned int phy_addr, int reg,\r\nu32 val)\r\n{\r\nu32 frame_val;\r\nunsigned int loops;\r\nint ret;\r\nif ((tp->phy_flags & TG3_PHYFLG_IS_FET) &&\r\n(reg == MII_CTRL1000 || reg == MII_TG3_AUX_CTRL))\r\nreturn 0;\r\nif ((tp->mi_mode & MAC_MI_MODE_AUTO_POLL) != 0) {\r\ntw32_f(MAC_MI_MODE,\r\n(tp->mi_mode & ~MAC_MI_MODE_AUTO_POLL));\r\nudelay(80);\r\n}\r\ntg3_ape_lock(tp, tp->phy_ape_lock);\r\nframe_val = ((phy_addr << MI_COM_PHY_ADDR_SHIFT) &\r\nMI_COM_PHY_ADDR_MASK);\r\nframe_val |= ((reg << MI_COM_REG_ADDR_SHIFT) &\r\nMI_COM_REG_ADDR_MASK);\r\nframe_val |= (val & MI_COM_DATA_MASK);\r\nframe_val |= (MI_COM_CMD_WRITE | MI_COM_START);\r\ntw32_f(MAC_MI_COM, frame_val);\r\nloops = PHY_BUSY_LOOPS;\r\nwhile (loops != 0) {\r\nudelay(10);\r\nframe_val = tr32(MAC_MI_COM);\r\nif ((frame_val & MI_COM_BUSY) == 0) {\r\nudelay(5);\r\nframe_val = tr32(MAC_MI_COM);\r\nbreak;\r\n}\r\nloops -= 1;\r\n}\r\nret = -EBUSY;\r\nif (loops != 0)\r\nret = 0;\r\nif ((tp->mi_mode & MAC_MI_MODE_AUTO_POLL) != 0) {\r\ntw32_f(MAC_MI_MODE, tp->mi_mode);\r\nudelay(80);\r\n}\r\ntg3_ape_unlock(tp, tp->phy_ape_lock);\r\nreturn ret;\r\n}\r\nstatic int tg3_writephy(struct tg3 *tp, int reg, u32 val)\r\n{\r\nreturn __tg3_writephy(tp, tp->phy_addr, reg, val);\r\n}\r\nstatic int tg3_phy_cl45_write(struct tg3 *tp, u32 devad, u32 addr, u32 val)\r\n{\r\nint err;\r\nerr = tg3_writephy(tp, MII_TG3_MMD_CTRL, devad);\r\nif (err)\r\ngoto done;\r\nerr = tg3_writephy(tp, MII_TG3_MMD_ADDRESS, addr);\r\nif (err)\r\ngoto done;\r\nerr = tg3_writephy(tp, MII_TG3_MMD_CTRL,\r\nMII_TG3_MMD_CTRL_DATA_NOINC | devad);\r\nif (err)\r\ngoto done;\r\nerr = tg3_writephy(tp, MII_TG3_MMD_ADDRESS, val);\r\ndone:\r\nreturn err;\r\n}\r\nstatic int tg3_phy_cl45_read(struct tg3 *tp, u32 devad, u32 addr, u32 *val)\r\n{\r\nint err;\r\nerr = tg3_writephy(tp, MII_TG3_MMD_CTRL, devad);\r\nif (err)\r\ngoto done;\r\nerr = tg3_writephy(tp, MII_TG3_MMD_ADDRESS, addr);\r\nif (err)\r\ngoto done;\r\nerr = tg3_writephy(tp, MII_TG3_MMD_CTRL,\r\nMII_TG3_MMD_CTRL_DATA_NOINC | devad);\r\nif (err)\r\ngoto done;\r\nerr = tg3_readphy(tp, MII_TG3_MMD_ADDRESS, val);\r\ndone:\r\nreturn err;\r\n}\r\nstatic int tg3_phydsp_read(struct tg3 *tp, u32 reg, u32 *val)\r\n{\r\nint err;\r\nerr = tg3_writephy(tp, MII_TG3_DSP_ADDRESS, reg);\r\nif (!err)\r\nerr = tg3_readphy(tp, MII_TG3_DSP_RW_PORT, val);\r\nreturn err;\r\n}\r\nstatic int tg3_phydsp_write(struct tg3 *tp, u32 reg, u32 val)\r\n{\r\nint err;\r\nerr = tg3_writephy(tp, MII_TG3_DSP_ADDRESS, reg);\r\nif (!err)\r\nerr = tg3_writephy(tp, MII_TG3_DSP_RW_PORT, val);\r\nreturn err;\r\n}\r\nstatic int tg3_phy_auxctl_read(struct tg3 *tp, int reg, u32 *val)\r\n{\r\nint err;\r\nerr = tg3_writephy(tp, MII_TG3_AUX_CTRL,\r\n(reg << MII_TG3_AUXCTL_MISC_RDSEL_SHIFT) |\r\nMII_TG3_AUXCTL_SHDWSEL_MISC);\r\nif (!err)\r\nerr = tg3_readphy(tp, MII_TG3_AUX_CTRL, val);\r\nreturn err;\r\n}\r\nstatic int tg3_phy_auxctl_write(struct tg3 *tp, int reg, u32 set)\r\n{\r\nif (reg == MII_TG3_AUXCTL_SHDWSEL_MISC)\r\nset |= MII_TG3_AUXCTL_MISC_WREN;\r\nreturn tg3_writephy(tp, MII_TG3_AUX_CTRL, set | reg);\r\n}\r\nstatic int tg3_phy_toggle_auxctl_smdsp(struct tg3 *tp, bool enable)\r\n{\r\nu32 val;\r\nint err;\r\nerr = tg3_phy_auxctl_read(tp, MII_TG3_AUXCTL_SHDWSEL_AUXCTL, &val);\r\nif (err)\r\nreturn err;\r\nif (enable)\r\nval |= MII_TG3_AUXCTL_ACTL_SMDSP_ENA;\r\nelse\r\nval &= ~MII_TG3_AUXCTL_ACTL_SMDSP_ENA;\r\nerr = tg3_phy_auxctl_write((tp), MII_TG3_AUXCTL_SHDWSEL_AUXCTL,\r\nval | MII_TG3_AUXCTL_ACTL_TX_6DB);\r\nreturn err;\r\n}\r\nstatic int tg3_phy_shdw_write(struct tg3 *tp, int reg, u32 val)\r\n{\r\nreturn tg3_writephy(tp, MII_TG3_MISC_SHDW,\r\nreg | val | MII_TG3_MISC_SHDW_WREN);\r\n}\r\nstatic int tg3_bmcr_reset(struct tg3 *tp)\r\n{\r\nu32 phy_control;\r\nint limit, err;\r\nphy_control = BMCR_RESET;\r\nerr = tg3_writephy(tp, MII_BMCR, phy_control);\r\nif (err != 0)\r\nreturn -EBUSY;\r\nlimit = 5000;\r\nwhile (limit--) {\r\nerr = tg3_readphy(tp, MII_BMCR, &phy_control);\r\nif (err != 0)\r\nreturn -EBUSY;\r\nif ((phy_control & BMCR_RESET) == 0) {\r\nudelay(40);\r\nbreak;\r\n}\r\nudelay(10);\r\n}\r\nif (limit < 0)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int tg3_mdio_read(struct mii_bus *bp, int mii_id, int reg)\r\n{\r\nstruct tg3 *tp = bp->priv;\r\nu32 val;\r\nspin_lock_bh(&tp->lock);\r\nif (__tg3_readphy(tp, mii_id, reg, &val))\r\nval = -EIO;\r\nspin_unlock_bh(&tp->lock);\r\nreturn val;\r\n}\r\nstatic int tg3_mdio_write(struct mii_bus *bp, int mii_id, int reg, u16 val)\r\n{\r\nstruct tg3 *tp = bp->priv;\r\nu32 ret = 0;\r\nspin_lock_bh(&tp->lock);\r\nif (__tg3_writephy(tp, mii_id, reg, val))\r\nret = -EIO;\r\nspin_unlock_bh(&tp->lock);\r\nreturn ret;\r\n}\r\nstatic void tg3_mdio_config_5785(struct tg3 *tp)\r\n{\r\nu32 val;\r\nstruct phy_device *phydev;\r\nphydev = tp->mdio_bus->phy_map[tp->phy_addr];\r\nswitch (phydev->drv->phy_id & phydev->drv->phy_id_mask) {\r\ncase PHY_ID_BCM50610:\r\ncase PHY_ID_BCM50610M:\r\nval = MAC_PHYCFG2_50610_LED_MODES;\r\nbreak;\r\ncase PHY_ID_BCMAC131:\r\nval = MAC_PHYCFG2_AC131_LED_MODES;\r\nbreak;\r\ncase PHY_ID_RTL8211C:\r\nval = MAC_PHYCFG2_RTL8211C_LED_MODES;\r\nbreak;\r\ncase PHY_ID_RTL8201E:\r\nval = MAC_PHYCFG2_RTL8201E_LED_MODES;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (phydev->interface != PHY_INTERFACE_MODE_RGMII) {\r\ntw32(MAC_PHYCFG2, val);\r\nval = tr32(MAC_PHYCFG1);\r\nval &= ~(MAC_PHYCFG1_RGMII_INT |\r\nMAC_PHYCFG1_RXCLK_TO_MASK | MAC_PHYCFG1_TXCLK_TO_MASK);\r\nval |= MAC_PHYCFG1_RXCLK_TIMEOUT | MAC_PHYCFG1_TXCLK_TIMEOUT;\r\ntw32(MAC_PHYCFG1, val);\r\nreturn;\r\n}\r\nif (!tg3_flag(tp, RGMII_INBAND_DISABLE))\r\nval |= MAC_PHYCFG2_EMODE_MASK_MASK |\r\nMAC_PHYCFG2_FMODE_MASK_MASK |\r\nMAC_PHYCFG2_GMODE_MASK_MASK |\r\nMAC_PHYCFG2_ACT_MASK_MASK |\r\nMAC_PHYCFG2_QUAL_MASK_MASK |\r\nMAC_PHYCFG2_INBAND_ENABLE;\r\ntw32(MAC_PHYCFG2, val);\r\nval = tr32(MAC_PHYCFG1);\r\nval &= ~(MAC_PHYCFG1_RXCLK_TO_MASK | MAC_PHYCFG1_TXCLK_TO_MASK |\r\nMAC_PHYCFG1_RGMII_EXT_RX_DEC | MAC_PHYCFG1_RGMII_SND_STAT_EN);\r\nif (!tg3_flag(tp, RGMII_INBAND_DISABLE)) {\r\nif (tg3_flag(tp, RGMII_EXT_IBND_RX_EN))\r\nval |= MAC_PHYCFG1_RGMII_EXT_RX_DEC;\r\nif (tg3_flag(tp, RGMII_EXT_IBND_TX_EN))\r\nval |= MAC_PHYCFG1_RGMII_SND_STAT_EN;\r\n}\r\nval |= MAC_PHYCFG1_RXCLK_TIMEOUT | MAC_PHYCFG1_TXCLK_TIMEOUT |\r\nMAC_PHYCFG1_RGMII_INT | MAC_PHYCFG1_TXC_DRV;\r\ntw32(MAC_PHYCFG1, val);\r\nval = tr32(MAC_EXT_RGMII_MODE);\r\nval &= ~(MAC_RGMII_MODE_RX_INT_B |\r\nMAC_RGMII_MODE_RX_QUALITY |\r\nMAC_RGMII_MODE_RX_ACTIVITY |\r\nMAC_RGMII_MODE_RX_ENG_DET |\r\nMAC_RGMII_MODE_TX_ENABLE |\r\nMAC_RGMII_MODE_TX_LOWPWR |\r\nMAC_RGMII_MODE_TX_RESET);\r\nif (!tg3_flag(tp, RGMII_INBAND_DISABLE)) {\r\nif (tg3_flag(tp, RGMII_EXT_IBND_RX_EN))\r\nval |= MAC_RGMII_MODE_RX_INT_B |\r\nMAC_RGMII_MODE_RX_QUALITY |\r\nMAC_RGMII_MODE_RX_ACTIVITY |\r\nMAC_RGMII_MODE_RX_ENG_DET;\r\nif (tg3_flag(tp, RGMII_EXT_IBND_TX_EN))\r\nval |= MAC_RGMII_MODE_TX_ENABLE |\r\nMAC_RGMII_MODE_TX_LOWPWR |\r\nMAC_RGMII_MODE_TX_RESET;\r\n}\r\ntw32(MAC_EXT_RGMII_MODE, val);\r\n}\r\nstatic void tg3_mdio_start(struct tg3 *tp)\r\n{\r\ntp->mi_mode &= ~MAC_MI_MODE_AUTO_POLL;\r\ntw32_f(MAC_MI_MODE, tp->mi_mode);\r\nudelay(80);\r\nif (tg3_flag(tp, MDIOBUS_INITED) &&\r\ntg3_asic_rev(tp) == ASIC_REV_5785)\r\ntg3_mdio_config_5785(tp);\r\n}\r\nstatic int tg3_mdio_init(struct tg3 *tp)\r\n{\r\nint i;\r\nu32 reg;\r\nstruct phy_device *phydev;\r\nif (tg3_flag(tp, 5717_PLUS)) {\r\nu32 is_serdes;\r\ntp->phy_addr = tp->pci_fn + 1;\r\nif (tg3_chip_rev_id(tp) != CHIPREV_ID_5717_A0)\r\nis_serdes = tr32(SG_DIG_STATUS) & SG_DIG_IS_SERDES;\r\nelse\r\nis_serdes = tr32(TG3_CPMU_PHY_STRAP) &\r\nTG3_CPMU_PHY_STRAP_IS_SERDES;\r\nif (is_serdes)\r\ntp->phy_addr += 7;\r\n} else if (tg3_flag(tp, IS_SSB_CORE) && tg3_flag(tp, ROBOSWITCH)) {\r\nint addr;\r\naddr = ssb_gige_get_phyaddr(tp->pdev);\r\nif (addr < 0)\r\nreturn addr;\r\ntp->phy_addr = addr;\r\n} else\r\ntp->phy_addr = TG3_PHY_MII_ADDR;\r\ntg3_mdio_start(tp);\r\nif (!tg3_flag(tp, USE_PHYLIB) || tg3_flag(tp, MDIOBUS_INITED))\r\nreturn 0;\r\ntp->mdio_bus = mdiobus_alloc();\r\nif (tp->mdio_bus == NULL)\r\nreturn -ENOMEM;\r\ntp->mdio_bus->name = "tg3 mdio bus";\r\nsnprintf(tp->mdio_bus->id, MII_BUS_ID_SIZE, "%x",\r\n(tp->pdev->bus->number << 8) | tp->pdev->devfn);\r\ntp->mdio_bus->priv = tp;\r\ntp->mdio_bus->parent = &tp->pdev->dev;\r\ntp->mdio_bus->read = &tg3_mdio_read;\r\ntp->mdio_bus->write = &tg3_mdio_write;\r\ntp->mdio_bus->phy_mask = ~(1 << tp->phy_addr);\r\ntp->mdio_bus->irq = &tp->mdio_irq[0];\r\nfor (i = 0; i < PHY_MAX_ADDR; i++)\r\ntp->mdio_bus->irq[i] = PHY_POLL;\r\nif (tg3_readphy(tp, MII_BMCR, &reg) || (reg & BMCR_PDOWN))\r\ntg3_bmcr_reset(tp);\r\ni = mdiobus_register(tp->mdio_bus);\r\nif (i) {\r\ndev_warn(&tp->pdev->dev, "mdiobus_reg failed (0x%x)\n", i);\r\nmdiobus_free(tp->mdio_bus);\r\nreturn i;\r\n}\r\nphydev = tp->mdio_bus->phy_map[tp->phy_addr];\r\nif (!phydev || !phydev->drv) {\r\ndev_warn(&tp->pdev->dev, "No PHY devices\n");\r\nmdiobus_unregister(tp->mdio_bus);\r\nmdiobus_free(tp->mdio_bus);\r\nreturn -ENODEV;\r\n}\r\nswitch (phydev->drv->phy_id & phydev->drv->phy_id_mask) {\r\ncase PHY_ID_BCM57780:\r\nphydev->interface = PHY_INTERFACE_MODE_GMII;\r\nphydev->dev_flags |= PHY_BRCM_AUTO_PWRDWN_ENABLE;\r\nbreak;\r\ncase PHY_ID_BCM50610:\r\ncase PHY_ID_BCM50610M:\r\nphydev->dev_flags |= PHY_BRCM_CLEAR_RGMII_MODE |\r\nPHY_BRCM_RX_REFCLK_UNUSED |\r\nPHY_BRCM_DIS_TXCRXC_NOENRGY |\r\nPHY_BRCM_AUTO_PWRDWN_ENABLE;\r\nif (tg3_flag(tp, RGMII_INBAND_DISABLE))\r\nphydev->dev_flags |= PHY_BRCM_STD_IBND_DISABLE;\r\nif (tg3_flag(tp, RGMII_EXT_IBND_RX_EN))\r\nphydev->dev_flags |= PHY_BRCM_EXT_IBND_RX_ENABLE;\r\nif (tg3_flag(tp, RGMII_EXT_IBND_TX_EN))\r\nphydev->dev_flags |= PHY_BRCM_EXT_IBND_TX_ENABLE;\r\ncase PHY_ID_RTL8211C:\r\nphydev->interface = PHY_INTERFACE_MODE_RGMII;\r\nbreak;\r\ncase PHY_ID_RTL8201E:\r\ncase PHY_ID_BCMAC131:\r\nphydev->interface = PHY_INTERFACE_MODE_MII;\r\nphydev->dev_flags |= PHY_BRCM_AUTO_PWRDWN_ENABLE;\r\ntp->phy_flags |= TG3_PHYFLG_IS_FET;\r\nbreak;\r\n}\r\ntg3_flag_set(tp, MDIOBUS_INITED);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5785)\r\ntg3_mdio_config_5785(tp);\r\nreturn 0;\r\n}\r\nstatic void tg3_mdio_fini(struct tg3 *tp)\r\n{\r\nif (tg3_flag(tp, MDIOBUS_INITED)) {\r\ntg3_flag_clear(tp, MDIOBUS_INITED);\r\nmdiobus_unregister(tp->mdio_bus);\r\nmdiobus_free(tp->mdio_bus);\r\n}\r\n}\r\nstatic inline void tg3_generate_fw_event(struct tg3 *tp)\r\n{\r\nu32 val;\r\nval = tr32(GRC_RX_CPU_EVENT);\r\nval |= GRC_RX_CPU_DRIVER_EVENT;\r\ntw32_f(GRC_RX_CPU_EVENT, val);\r\ntp->last_event_jiffies = jiffies;\r\n}\r\nstatic void tg3_wait_for_event_ack(struct tg3 *tp)\r\n{\r\nint i;\r\nunsigned int delay_cnt;\r\nlong time_remain;\r\ntime_remain = (long)(tp->last_event_jiffies + 1 +\r\nusecs_to_jiffies(TG3_FW_EVENT_TIMEOUT_USEC)) -\r\n(long)jiffies;\r\nif (time_remain < 0)\r\nreturn;\r\ndelay_cnt = jiffies_to_usecs(time_remain);\r\nif (delay_cnt > TG3_FW_EVENT_TIMEOUT_USEC)\r\ndelay_cnt = TG3_FW_EVENT_TIMEOUT_USEC;\r\ndelay_cnt = (delay_cnt >> 3) + 1;\r\nfor (i = 0; i < delay_cnt; i++) {\r\nif (!(tr32(GRC_RX_CPU_EVENT) & GRC_RX_CPU_DRIVER_EVENT))\r\nbreak;\r\nif (pci_channel_offline(tp->pdev))\r\nbreak;\r\nudelay(8);\r\n}\r\n}\r\nstatic void tg3_phy_gather_ump_data(struct tg3 *tp, u32 *data)\r\n{\r\nu32 reg, val;\r\nval = 0;\r\nif (!tg3_readphy(tp, MII_BMCR, &reg))\r\nval = reg << 16;\r\nif (!tg3_readphy(tp, MII_BMSR, &reg))\r\nval |= (reg & 0xffff);\r\n*data++ = val;\r\nval = 0;\r\nif (!tg3_readphy(tp, MII_ADVERTISE, &reg))\r\nval = reg << 16;\r\nif (!tg3_readphy(tp, MII_LPA, &reg))\r\nval |= (reg & 0xffff);\r\n*data++ = val;\r\nval = 0;\r\nif (!(tp->phy_flags & TG3_PHYFLG_MII_SERDES)) {\r\nif (!tg3_readphy(tp, MII_CTRL1000, &reg))\r\nval = reg << 16;\r\nif (!tg3_readphy(tp, MII_STAT1000, &reg))\r\nval |= (reg & 0xffff);\r\n}\r\n*data++ = val;\r\nif (!tg3_readphy(tp, MII_PHYADDR, &reg))\r\nval = reg << 16;\r\nelse\r\nval = 0;\r\n*data++ = val;\r\n}\r\nstatic void tg3_ump_link_report(struct tg3 *tp)\r\n{\r\nu32 data[4];\r\nif (!tg3_flag(tp, 5780_CLASS) || !tg3_flag(tp, ENABLE_ASF))\r\nreturn;\r\ntg3_phy_gather_ump_data(tp, data);\r\ntg3_wait_for_event_ack(tp);\r\ntg3_write_mem(tp, NIC_SRAM_FW_CMD_MBOX, FWCMD_NICDRV_LINK_UPDATE);\r\ntg3_write_mem(tp, NIC_SRAM_FW_CMD_LEN_MBOX, 14);\r\ntg3_write_mem(tp, NIC_SRAM_FW_CMD_DATA_MBOX + 0x0, data[0]);\r\ntg3_write_mem(tp, NIC_SRAM_FW_CMD_DATA_MBOX + 0x4, data[1]);\r\ntg3_write_mem(tp, NIC_SRAM_FW_CMD_DATA_MBOX + 0x8, data[2]);\r\ntg3_write_mem(tp, NIC_SRAM_FW_CMD_DATA_MBOX + 0xc, data[3]);\r\ntg3_generate_fw_event(tp);\r\n}\r\nstatic void tg3_stop_fw(struct tg3 *tp)\r\n{\r\nif (tg3_flag(tp, ENABLE_ASF) && !tg3_flag(tp, ENABLE_APE)) {\r\ntg3_wait_for_event_ack(tp);\r\ntg3_write_mem(tp, NIC_SRAM_FW_CMD_MBOX, FWCMD_NICDRV_PAUSE_FW);\r\ntg3_generate_fw_event(tp);\r\ntg3_wait_for_event_ack(tp);\r\n}\r\n}\r\nstatic void tg3_write_sig_pre_reset(struct tg3 *tp, int kind)\r\n{\r\ntg3_write_mem(tp, NIC_SRAM_FIRMWARE_MBOX,\r\nNIC_SRAM_FIRMWARE_MBOX_MAGIC1);\r\nif (tg3_flag(tp, ASF_NEW_HANDSHAKE)) {\r\nswitch (kind) {\r\ncase RESET_KIND_INIT:\r\ntg3_write_mem(tp, NIC_SRAM_FW_DRV_STATE_MBOX,\r\nDRV_STATE_START);\r\nbreak;\r\ncase RESET_KIND_SHUTDOWN:\r\ntg3_write_mem(tp, NIC_SRAM_FW_DRV_STATE_MBOX,\r\nDRV_STATE_UNLOAD);\r\nbreak;\r\ncase RESET_KIND_SUSPEND:\r\ntg3_write_mem(tp, NIC_SRAM_FW_DRV_STATE_MBOX,\r\nDRV_STATE_SUSPEND);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void tg3_write_sig_post_reset(struct tg3 *tp, int kind)\r\n{\r\nif (tg3_flag(tp, ASF_NEW_HANDSHAKE)) {\r\nswitch (kind) {\r\ncase RESET_KIND_INIT:\r\ntg3_write_mem(tp, NIC_SRAM_FW_DRV_STATE_MBOX,\r\nDRV_STATE_START_DONE);\r\nbreak;\r\ncase RESET_KIND_SHUTDOWN:\r\ntg3_write_mem(tp, NIC_SRAM_FW_DRV_STATE_MBOX,\r\nDRV_STATE_UNLOAD_DONE);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void tg3_write_sig_legacy(struct tg3 *tp, int kind)\r\n{\r\nif (tg3_flag(tp, ENABLE_ASF)) {\r\nswitch (kind) {\r\ncase RESET_KIND_INIT:\r\ntg3_write_mem(tp, NIC_SRAM_FW_DRV_STATE_MBOX,\r\nDRV_STATE_START);\r\nbreak;\r\ncase RESET_KIND_SHUTDOWN:\r\ntg3_write_mem(tp, NIC_SRAM_FW_DRV_STATE_MBOX,\r\nDRV_STATE_UNLOAD);\r\nbreak;\r\ncase RESET_KIND_SUSPEND:\r\ntg3_write_mem(tp, NIC_SRAM_FW_DRV_STATE_MBOX,\r\nDRV_STATE_SUSPEND);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int tg3_poll_fw(struct tg3 *tp)\r\n{\r\nint i;\r\nu32 val;\r\nif (tg3_flag(tp, NO_FWARE_REPORTED))\r\nreturn 0;\r\nif (tg3_flag(tp, IS_SSB_CORE)) {\r\nreturn 0;\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5906) {\r\nfor (i = 0; i < 200; i++) {\r\nif (tr32(VCPU_STATUS) & VCPU_STATUS_INIT_DONE)\r\nreturn 0;\r\nif (pci_channel_offline(tp->pdev))\r\nreturn -ENODEV;\r\nudelay(100);\r\n}\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < 100000; i++) {\r\ntg3_read_mem(tp, NIC_SRAM_FIRMWARE_MBOX, &val);\r\nif (val == ~NIC_SRAM_FIRMWARE_MBOX_MAGIC1)\r\nbreak;\r\nif (pci_channel_offline(tp->pdev)) {\r\nif (!tg3_flag(tp, NO_FWARE_REPORTED)) {\r\ntg3_flag_set(tp, NO_FWARE_REPORTED);\r\nnetdev_info(tp->dev, "No firmware running\n");\r\n}\r\nbreak;\r\n}\r\nudelay(10);\r\n}\r\nif (i >= 100000 && !tg3_flag(tp, NO_FWARE_REPORTED)) {\r\ntg3_flag_set(tp, NO_FWARE_REPORTED);\r\nnetdev_info(tp->dev, "No firmware running\n");\r\n}\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_57765_A0) {\r\nmdelay(10);\r\n}\r\nreturn 0;\r\n}\r\nstatic void tg3_link_report(struct tg3 *tp)\r\n{\r\nif (!netif_carrier_ok(tp->dev)) {\r\nnetif_info(tp, link, tp->dev, "Link is down\n");\r\ntg3_ump_link_report(tp);\r\n} else if (netif_msg_link(tp)) {\r\nnetdev_info(tp->dev, "Link is up at %d Mbps, %s duplex\n",\r\n(tp->link_config.active_speed == SPEED_1000 ?\r\n1000 :\r\n(tp->link_config.active_speed == SPEED_100 ?\r\n100 : 10)),\r\n(tp->link_config.active_duplex == DUPLEX_FULL ?\r\n"full" : "half"));\r\nnetdev_info(tp->dev, "Flow control is %s for TX and %s for RX\n",\r\n(tp->link_config.active_flowctrl & FLOW_CTRL_TX) ?\r\n"on" : "off",\r\n(tp->link_config.active_flowctrl & FLOW_CTRL_RX) ?\r\n"on" : "off");\r\nif (tp->phy_flags & TG3_PHYFLG_EEE_CAP)\r\nnetdev_info(tp->dev, "EEE is %s\n",\r\ntp->setlpicnt ? "enabled" : "disabled");\r\ntg3_ump_link_report(tp);\r\n}\r\ntp->link_up = netif_carrier_ok(tp->dev);\r\n}\r\nstatic u32 tg3_decode_flowctrl_1000T(u32 adv)\r\n{\r\nu32 flowctrl = 0;\r\nif (adv & ADVERTISE_PAUSE_CAP) {\r\nflowctrl |= FLOW_CTRL_RX;\r\nif (!(adv & ADVERTISE_PAUSE_ASYM))\r\nflowctrl |= FLOW_CTRL_TX;\r\n} else if (adv & ADVERTISE_PAUSE_ASYM)\r\nflowctrl |= FLOW_CTRL_TX;\r\nreturn flowctrl;\r\n}\r\nstatic u16 tg3_advert_flowctrl_1000X(u8 flow_ctrl)\r\n{\r\nu16 miireg;\r\nif ((flow_ctrl & FLOW_CTRL_TX) && (flow_ctrl & FLOW_CTRL_RX))\r\nmiireg = ADVERTISE_1000XPAUSE;\r\nelse if (flow_ctrl & FLOW_CTRL_TX)\r\nmiireg = ADVERTISE_1000XPSE_ASYM;\r\nelse if (flow_ctrl & FLOW_CTRL_RX)\r\nmiireg = ADVERTISE_1000XPAUSE | ADVERTISE_1000XPSE_ASYM;\r\nelse\r\nmiireg = 0;\r\nreturn miireg;\r\n}\r\nstatic u32 tg3_decode_flowctrl_1000X(u32 adv)\r\n{\r\nu32 flowctrl = 0;\r\nif (adv & ADVERTISE_1000XPAUSE) {\r\nflowctrl |= FLOW_CTRL_RX;\r\nif (!(adv & ADVERTISE_1000XPSE_ASYM))\r\nflowctrl |= FLOW_CTRL_TX;\r\n} else if (adv & ADVERTISE_1000XPSE_ASYM)\r\nflowctrl |= FLOW_CTRL_TX;\r\nreturn flowctrl;\r\n}\r\nstatic u8 tg3_resolve_flowctrl_1000X(u16 lcladv, u16 rmtadv)\r\n{\r\nu8 cap = 0;\r\nif (lcladv & rmtadv & ADVERTISE_1000XPAUSE) {\r\ncap = FLOW_CTRL_TX | FLOW_CTRL_RX;\r\n} else if (lcladv & rmtadv & ADVERTISE_1000XPSE_ASYM) {\r\nif (lcladv & ADVERTISE_1000XPAUSE)\r\ncap = FLOW_CTRL_RX;\r\nif (rmtadv & ADVERTISE_1000XPAUSE)\r\ncap = FLOW_CTRL_TX;\r\n}\r\nreturn cap;\r\n}\r\nstatic void tg3_setup_flow_control(struct tg3 *tp, u32 lcladv, u32 rmtadv)\r\n{\r\nu8 autoneg;\r\nu8 flowctrl = 0;\r\nu32 old_rx_mode = tp->rx_mode;\r\nu32 old_tx_mode = tp->tx_mode;\r\nif (tg3_flag(tp, USE_PHYLIB))\r\nautoneg = tp->mdio_bus->phy_map[tp->phy_addr]->autoneg;\r\nelse\r\nautoneg = tp->link_config.autoneg;\r\nif (autoneg == AUTONEG_ENABLE && tg3_flag(tp, PAUSE_AUTONEG)) {\r\nif (tp->phy_flags & TG3_PHYFLG_ANY_SERDES)\r\nflowctrl = tg3_resolve_flowctrl_1000X(lcladv, rmtadv);\r\nelse\r\nflowctrl = mii_resolve_flowctrl_fdx(lcladv, rmtadv);\r\n} else\r\nflowctrl = tp->link_config.flowctrl;\r\ntp->link_config.active_flowctrl = flowctrl;\r\nif (flowctrl & FLOW_CTRL_RX)\r\ntp->rx_mode |= RX_MODE_FLOW_CTRL_ENABLE;\r\nelse\r\ntp->rx_mode &= ~RX_MODE_FLOW_CTRL_ENABLE;\r\nif (old_rx_mode != tp->rx_mode)\r\ntw32_f(MAC_RX_MODE, tp->rx_mode);\r\nif (flowctrl & FLOW_CTRL_TX)\r\ntp->tx_mode |= TX_MODE_FLOW_CTRL_ENABLE;\r\nelse\r\ntp->tx_mode &= ~TX_MODE_FLOW_CTRL_ENABLE;\r\nif (old_tx_mode != tp->tx_mode)\r\ntw32_f(MAC_TX_MODE, tp->tx_mode);\r\n}\r\nstatic void tg3_adjust_link(struct net_device *dev)\r\n{\r\nu8 oldflowctrl, linkmesg = 0;\r\nu32 mac_mode, lcl_adv, rmt_adv;\r\nstruct tg3 *tp = netdev_priv(dev);\r\nstruct phy_device *phydev = tp->mdio_bus->phy_map[tp->phy_addr];\r\nspin_lock_bh(&tp->lock);\r\nmac_mode = tp->mac_mode & ~(MAC_MODE_PORT_MODE_MASK |\r\nMAC_MODE_HALF_DUPLEX);\r\noldflowctrl = tp->link_config.active_flowctrl;\r\nif (phydev->link) {\r\nlcl_adv = 0;\r\nrmt_adv = 0;\r\nif (phydev->speed == SPEED_100 || phydev->speed == SPEED_10)\r\nmac_mode |= MAC_MODE_PORT_MODE_MII;\r\nelse if (phydev->speed == SPEED_1000 ||\r\ntg3_asic_rev(tp) != ASIC_REV_5785)\r\nmac_mode |= MAC_MODE_PORT_MODE_GMII;\r\nelse\r\nmac_mode |= MAC_MODE_PORT_MODE_MII;\r\nif (phydev->duplex == DUPLEX_HALF)\r\nmac_mode |= MAC_MODE_HALF_DUPLEX;\r\nelse {\r\nlcl_adv = mii_advertise_flowctrl(\r\ntp->link_config.flowctrl);\r\nif (phydev->pause)\r\nrmt_adv = LPA_PAUSE_CAP;\r\nif (phydev->asym_pause)\r\nrmt_adv |= LPA_PAUSE_ASYM;\r\n}\r\ntg3_setup_flow_control(tp, lcl_adv, rmt_adv);\r\n} else\r\nmac_mode |= MAC_MODE_PORT_MODE_GMII;\r\nif (mac_mode != tp->mac_mode) {\r\ntp->mac_mode = mac_mode;\r\ntw32_f(MAC_MODE, tp->mac_mode);\r\nudelay(40);\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5785) {\r\nif (phydev->speed == SPEED_10)\r\ntw32(MAC_MI_STAT,\r\nMAC_MI_STAT_10MBPS_MODE |\r\nMAC_MI_STAT_LNKSTAT_ATTN_ENAB);\r\nelse\r\ntw32(MAC_MI_STAT, MAC_MI_STAT_LNKSTAT_ATTN_ENAB);\r\n}\r\nif (phydev->speed == SPEED_1000 && phydev->duplex == DUPLEX_HALF)\r\ntw32(MAC_TX_LENGTHS,\r\n((2 << TX_LENGTHS_IPG_CRS_SHIFT) |\r\n(6 << TX_LENGTHS_IPG_SHIFT) |\r\n(0xff << TX_LENGTHS_SLOT_TIME_SHIFT)));\r\nelse\r\ntw32(MAC_TX_LENGTHS,\r\n((2 << TX_LENGTHS_IPG_CRS_SHIFT) |\r\n(6 << TX_LENGTHS_IPG_SHIFT) |\r\n(32 << TX_LENGTHS_SLOT_TIME_SHIFT)));\r\nif (phydev->link != tp->old_link ||\r\nphydev->speed != tp->link_config.active_speed ||\r\nphydev->duplex != tp->link_config.active_duplex ||\r\noldflowctrl != tp->link_config.active_flowctrl)\r\nlinkmesg = 1;\r\ntp->old_link = phydev->link;\r\ntp->link_config.active_speed = phydev->speed;\r\ntp->link_config.active_duplex = phydev->duplex;\r\nspin_unlock_bh(&tp->lock);\r\nif (linkmesg)\r\ntg3_link_report(tp);\r\n}\r\nstatic int tg3_phy_init(struct tg3 *tp)\r\n{\r\nstruct phy_device *phydev;\r\nif (tp->phy_flags & TG3_PHYFLG_IS_CONNECTED)\r\nreturn 0;\r\ntg3_bmcr_reset(tp);\r\nphydev = tp->mdio_bus->phy_map[tp->phy_addr];\r\nphydev = phy_connect(tp->dev, dev_name(&phydev->dev),\r\ntg3_adjust_link, phydev->interface);\r\nif (IS_ERR(phydev)) {\r\ndev_err(&tp->pdev->dev, "Could not attach to PHY\n");\r\nreturn PTR_ERR(phydev);\r\n}\r\nswitch (phydev->interface) {\r\ncase PHY_INTERFACE_MODE_GMII:\r\ncase PHY_INTERFACE_MODE_RGMII:\r\nif (!(tp->phy_flags & TG3_PHYFLG_10_100_ONLY)) {\r\nphydev->supported &= (PHY_GBIT_FEATURES |\r\nSUPPORTED_Pause |\r\nSUPPORTED_Asym_Pause);\r\nbreak;\r\n}\r\ncase PHY_INTERFACE_MODE_MII:\r\nphydev->supported &= (PHY_BASIC_FEATURES |\r\nSUPPORTED_Pause |\r\nSUPPORTED_Asym_Pause);\r\nbreak;\r\ndefault:\r\nphy_disconnect(tp->mdio_bus->phy_map[tp->phy_addr]);\r\nreturn -EINVAL;\r\n}\r\ntp->phy_flags |= TG3_PHYFLG_IS_CONNECTED;\r\nphydev->advertising = phydev->supported;\r\nreturn 0;\r\n}\r\nstatic void tg3_phy_start(struct tg3 *tp)\r\n{\r\nstruct phy_device *phydev;\r\nif (!(tp->phy_flags & TG3_PHYFLG_IS_CONNECTED))\r\nreturn;\r\nphydev = tp->mdio_bus->phy_map[tp->phy_addr];\r\nif (tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER) {\r\ntp->phy_flags &= ~TG3_PHYFLG_IS_LOW_POWER;\r\nphydev->speed = tp->link_config.speed;\r\nphydev->duplex = tp->link_config.duplex;\r\nphydev->autoneg = tp->link_config.autoneg;\r\nphydev->advertising = tp->link_config.advertising;\r\n}\r\nphy_start(phydev);\r\nphy_start_aneg(phydev);\r\n}\r\nstatic void tg3_phy_stop(struct tg3 *tp)\r\n{\r\nif (!(tp->phy_flags & TG3_PHYFLG_IS_CONNECTED))\r\nreturn;\r\nphy_stop(tp->mdio_bus->phy_map[tp->phy_addr]);\r\n}\r\nstatic void tg3_phy_fini(struct tg3 *tp)\r\n{\r\nif (tp->phy_flags & TG3_PHYFLG_IS_CONNECTED) {\r\nphy_disconnect(tp->mdio_bus->phy_map[tp->phy_addr]);\r\ntp->phy_flags &= ~TG3_PHYFLG_IS_CONNECTED;\r\n}\r\n}\r\nstatic int tg3_phy_set_extloopbk(struct tg3 *tp)\r\n{\r\nint err;\r\nu32 val;\r\nif (tp->phy_flags & TG3_PHYFLG_IS_FET)\r\nreturn 0;\r\nif ((tp->phy_id & TG3_PHY_ID_MASK) == TG3_PHY_ID_BCM5401) {\r\nerr = tg3_phy_auxctl_write(tp,\r\nMII_TG3_AUXCTL_SHDWSEL_AUXCTL,\r\nMII_TG3_AUXCTL_ACTL_EXTLOOPBK |\r\n0x4c20);\r\ngoto done;\r\n}\r\nerr = tg3_phy_auxctl_read(tp,\r\nMII_TG3_AUXCTL_SHDWSEL_AUXCTL, &val);\r\nif (err)\r\nreturn err;\r\nval |= MII_TG3_AUXCTL_ACTL_EXTLOOPBK;\r\nerr = tg3_phy_auxctl_write(tp,\r\nMII_TG3_AUXCTL_SHDWSEL_AUXCTL, val);\r\ndone:\r\nreturn err;\r\n}\r\nstatic void tg3_phy_fet_toggle_apd(struct tg3 *tp, bool enable)\r\n{\r\nu32 phytest;\r\nif (!tg3_readphy(tp, MII_TG3_FET_TEST, &phytest)) {\r\nu32 phy;\r\ntg3_writephy(tp, MII_TG3_FET_TEST,\r\nphytest | MII_TG3_FET_SHADOW_EN);\r\nif (!tg3_readphy(tp, MII_TG3_FET_SHDW_AUXSTAT2, &phy)) {\r\nif (enable)\r\nphy |= MII_TG3_FET_SHDW_AUXSTAT2_APD;\r\nelse\r\nphy &= ~MII_TG3_FET_SHDW_AUXSTAT2_APD;\r\ntg3_writephy(tp, MII_TG3_FET_SHDW_AUXSTAT2, phy);\r\n}\r\ntg3_writephy(tp, MII_TG3_FET_TEST, phytest);\r\n}\r\n}\r\nstatic void tg3_phy_toggle_apd(struct tg3 *tp, bool enable)\r\n{\r\nu32 reg;\r\nif (!tg3_flag(tp, 5705_PLUS) ||\r\n(tg3_flag(tp, 5717_PLUS) &&\r\n(tp->phy_flags & TG3_PHYFLG_MII_SERDES)))\r\nreturn;\r\nif (tp->phy_flags & TG3_PHYFLG_IS_FET) {\r\ntg3_phy_fet_toggle_apd(tp, enable);\r\nreturn;\r\n}\r\nreg = MII_TG3_MISC_SHDW_SCR5_LPED |\r\nMII_TG3_MISC_SHDW_SCR5_DLPTLM |\r\nMII_TG3_MISC_SHDW_SCR5_SDTL |\r\nMII_TG3_MISC_SHDW_SCR5_C125OE;\r\nif (tg3_asic_rev(tp) != ASIC_REV_5784 || !enable)\r\nreg |= MII_TG3_MISC_SHDW_SCR5_DLLAPD;\r\ntg3_phy_shdw_write(tp, MII_TG3_MISC_SHDW_SCR5_SEL, reg);\r\nreg = MII_TG3_MISC_SHDW_APD_WKTM_84MS;\r\nif (enable)\r\nreg |= MII_TG3_MISC_SHDW_APD_ENABLE;\r\ntg3_phy_shdw_write(tp, MII_TG3_MISC_SHDW_APD_SEL, reg);\r\n}\r\nstatic void tg3_phy_toggle_automdix(struct tg3 *tp, bool enable)\r\n{\r\nu32 phy;\r\nif (!tg3_flag(tp, 5705_PLUS) ||\r\n(tp->phy_flags & TG3_PHYFLG_ANY_SERDES))\r\nreturn;\r\nif (tp->phy_flags & TG3_PHYFLG_IS_FET) {\r\nu32 ephy;\r\nif (!tg3_readphy(tp, MII_TG3_FET_TEST, &ephy)) {\r\nu32 reg = MII_TG3_FET_SHDW_MISCCTRL;\r\ntg3_writephy(tp, MII_TG3_FET_TEST,\r\nephy | MII_TG3_FET_SHADOW_EN);\r\nif (!tg3_readphy(tp, reg, &phy)) {\r\nif (enable)\r\nphy |= MII_TG3_FET_SHDW_MISCCTRL_MDIX;\r\nelse\r\nphy &= ~MII_TG3_FET_SHDW_MISCCTRL_MDIX;\r\ntg3_writephy(tp, reg, phy);\r\n}\r\ntg3_writephy(tp, MII_TG3_FET_TEST, ephy);\r\n}\r\n} else {\r\nint ret;\r\nret = tg3_phy_auxctl_read(tp,\r\nMII_TG3_AUXCTL_SHDWSEL_MISC, &phy);\r\nif (!ret) {\r\nif (enable)\r\nphy |= MII_TG3_AUXCTL_MISC_FORCE_AMDIX;\r\nelse\r\nphy &= ~MII_TG3_AUXCTL_MISC_FORCE_AMDIX;\r\ntg3_phy_auxctl_write(tp,\r\nMII_TG3_AUXCTL_SHDWSEL_MISC, phy);\r\n}\r\n}\r\n}\r\nstatic void tg3_phy_set_wirespeed(struct tg3 *tp)\r\n{\r\nint ret;\r\nu32 val;\r\nif (tp->phy_flags & TG3_PHYFLG_NO_ETH_WIRE_SPEED)\r\nreturn;\r\nret = tg3_phy_auxctl_read(tp, MII_TG3_AUXCTL_SHDWSEL_MISC, &val);\r\nif (!ret)\r\ntg3_phy_auxctl_write(tp, MII_TG3_AUXCTL_SHDWSEL_MISC,\r\nval | MII_TG3_AUXCTL_MISC_WIRESPD_EN);\r\n}\r\nstatic void tg3_phy_apply_otp(struct tg3 *tp)\r\n{\r\nu32 otp, phy;\r\nif (!tp->phy_otp)\r\nreturn;\r\notp = tp->phy_otp;\r\nif (tg3_phy_toggle_auxctl_smdsp(tp, true))\r\nreturn;\r\nphy = ((otp & TG3_OTP_AGCTGT_MASK) >> TG3_OTP_AGCTGT_SHIFT);\r\nphy |= MII_TG3_DSP_TAP1_AGCTGT_DFLT;\r\ntg3_phydsp_write(tp, MII_TG3_DSP_TAP1, phy);\r\nphy = ((otp & TG3_OTP_HPFFLTR_MASK) >> TG3_OTP_HPFFLTR_SHIFT) |\r\n((otp & TG3_OTP_HPFOVER_MASK) >> TG3_OTP_HPFOVER_SHIFT);\r\ntg3_phydsp_write(tp, MII_TG3_DSP_AADJ1CH0, phy);\r\nphy = ((otp & TG3_OTP_LPFDIS_MASK) >> TG3_OTP_LPFDIS_SHIFT);\r\nphy |= MII_TG3_DSP_AADJ1CH3_ADCCKADJ;\r\ntg3_phydsp_write(tp, MII_TG3_DSP_AADJ1CH3, phy);\r\nphy = ((otp & TG3_OTP_VDAC_MASK) >> TG3_OTP_VDAC_SHIFT);\r\ntg3_phydsp_write(tp, MII_TG3_DSP_EXP75, phy);\r\nphy = ((otp & TG3_OTP_10BTAMP_MASK) >> TG3_OTP_10BTAMP_SHIFT);\r\ntg3_phydsp_write(tp, MII_TG3_DSP_EXP96, phy);\r\nphy = ((otp & TG3_OTP_ROFF_MASK) >> TG3_OTP_ROFF_SHIFT) |\r\n((otp & TG3_OTP_RCOFF_MASK) >> TG3_OTP_RCOFF_SHIFT);\r\ntg3_phydsp_write(tp, MII_TG3_DSP_EXP97, phy);\r\ntg3_phy_toggle_auxctl_smdsp(tp, false);\r\n}\r\nstatic void tg3_eee_pull_config(struct tg3 *tp, struct ethtool_eee *eee)\r\n{\r\nu32 val;\r\nstruct ethtool_eee *dest = &tp->eee;\r\nif (!(tp->phy_flags & TG3_PHYFLG_EEE_CAP))\r\nreturn;\r\nif (eee)\r\ndest = eee;\r\nif (tg3_phy_cl45_read(tp, MDIO_MMD_AN, TG3_CL45_D7_EEERES_STAT, &val))\r\nreturn;\r\nif (val == TG3_CL45_D7_EEERES_STAT_LP_1000T ||\r\nval == TG3_CL45_D7_EEERES_STAT_LP_100TX) {\r\ndest->eee_active = 1;\r\n} else\r\ndest->eee_active = 0;\r\nif (tg3_phy_cl45_read(tp, MDIO_MMD_AN, MDIO_AN_EEE_LPABLE, &val))\r\nreturn;\r\ndest->lp_advertised = mmd_eee_adv_to_ethtool_adv_t(val);\r\nif (tg3_phy_cl45_read(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV, &val))\r\nreturn;\r\ndest->eee_enabled = !!val;\r\ndest->advertised = mmd_eee_adv_to_ethtool_adv_t(val);\r\nval = tr32(TG3_CPMU_EEE_MODE);\r\ndest->tx_lpi_enabled = !!(val & TG3_CPMU_EEEMD_LPI_IN_TX);\r\ndest->tx_lpi_timer = tr32(TG3_CPMU_EEE_DBTMR1) & 0xffff;\r\n}\r\nstatic void tg3_phy_eee_adjust(struct tg3 *tp, bool current_link_up)\r\n{\r\nu32 val;\r\nif (!(tp->phy_flags & TG3_PHYFLG_EEE_CAP))\r\nreturn;\r\ntp->setlpicnt = 0;\r\nif (tp->link_config.autoneg == AUTONEG_ENABLE &&\r\ncurrent_link_up &&\r\ntp->link_config.active_duplex == DUPLEX_FULL &&\r\n(tp->link_config.active_speed == SPEED_100 ||\r\ntp->link_config.active_speed == SPEED_1000)) {\r\nu32 eeectl;\r\nif (tp->link_config.active_speed == SPEED_1000)\r\neeectl = TG3_CPMU_EEE_CTRL_EXIT_16_5_US;\r\nelse\r\neeectl = TG3_CPMU_EEE_CTRL_EXIT_36_US;\r\ntw32(TG3_CPMU_EEE_CTRL, eeectl);\r\ntg3_eee_pull_config(tp, NULL);\r\nif (tp->eee.eee_active)\r\ntp->setlpicnt = 2;\r\n}\r\nif (!tp->setlpicnt) {\r\nif (current_link_up &&\r\n!tg3_phy_toggle_auxctl_smdsp(tp, true)) {\r\ntg3_phydsp_write(tp, MII_TG3_DSP_TAP26, 0x0000);\r\ntg3_phy_toggle_auxctl_smdsp(tp, false);\r\n}\r\nval = tr32(TG3_CPMU_EEE_MODE);\r\ntw32(TG3_CPMU_EEE_MODE, val & ~TG3_CPMU_EEEMD_LPI_ENABLE);\r\n}\r\n}\r\nstatic void tg3_phy_eee_enable(struct tg3 *tp)\r\n{\r\nu32 val;\r\nif (tp->link_config.active_speed == SPEED_1000 &&\r\n(tg3_asic_rev(tp) == ASIC_REV_5717 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5719 ||\r\ntg3_flag(tp, 57765_CLASS)) &&\r\n!tg3_phy_toggle_auxctl_smdsp(tp, true)) {\r\nval = MII_TG3_DSP_TAP26_ALNOKO |\r\nMII_TG3_DSP_TAP26_RMRXSTO;\r\ntg3_phydsp_write(tp, MII_TG3_DSP_TAP26, val);\r\ntg3_phy_toggle_auxctl_smdsp(tp, false);\r\n}\r\nval = tr32(TG3_CPMU_EEE_MODE);\r\ntw32(TG3_CPMU_EEE_MODE, val | TG3_CPMU_EEEMD_LPI_ENABLE);\r\n}\r\nstatic int tg3_wait_macro_done(struct tg3 *tp)\r\n{\r\nint limit = 100;\r\nwhile (limit--) {\r\nu32 tmp32;\r\nif (!tg3_readphy(tp, MII_TG3_DSP_CONTROL, &tmp32)) {\r\nif ((tmp32 & 0x1000) == 0)\r\nbreak;\r\n}\r\n}\r\nif (limit < 0)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int tg3_phy_write_and_check_testpat(struct tg3 *tp, int *resetp)\r\n{\r\nstatic const u32 test_pat[4][6] = {\r\n{ 0x00005555, 0x00000005, 0x00002aaa, 0x0000000a, 0x00003456, 0x00000003 },\r\n{ 0x00002aaa, 0x0000000a, 0x00003333, 0x00000003, 0x0000789a, 0x00000005 },\r\n{ 0x00005a5a, 0x00000005, 0x00002a6a, 0x0000000a, 0x00001bcd, 0x00000003 },\r\n{ 0x00002a5a, 0x0000000a, 0x000033c3, 0x00000003, 0x00002ef1, 0x00000005 }\r\n};\r\nint chan;\r\nfor (chan = 0; chan < 4; chan++) {\r\nint i;\r\ntg3_writephy(tp, MII_TG3_DSP_ADDRESS,\r\n(chan * 0x2000) | 0x0200);\r\ntg3_writephy(tp, MII_TG3_DSP_CONTROL, 0x0002);\r\nfor (i = 0; i < 6; i++)\r\ntg3_writephy(tp, MII_TG3_DSP_RW_PORT,\r\ntest_pat[chan][i]);\r\ntg3_writephy(tp, MII_TG3_DSP_CONTROL, 0x0202);\r\nif (tg3_wait_macro_done(tp)) {\r\n*resetp = 1;\r\nreturn -EBUSY;\r\n}\r\ntg3_writephy(tp, MII_TG3_DSP_ADDRESS,\r\n(chan * 0x2000) | 0x0200);\r\ntg3_writephy(tp, MII_TG3_DSP_CONTROL, 0x0082);\r\nif (tg3_wait_macro_done(tp)) {\r\n*resetp = 1;\r\nreturn -EBUSY;\r\n}\r\ntg3_writephy(tp, MII_TG3_DSP_CONTROL, 0x0802);\r\nif (tg3_wait_macro_done(tp)) {\r\n*resetp = 1;\r\nreturn -EBUSY;\r\n}\r\nfor (i = 0; i < 6; i += 2) {\r\nu32 low, high;\r\nif (tg3_readphy(tp, MII_TG3_DSP_RW_PORT, &low) ||\r\ntg3_readphy(tp, MII_TG3_DSP_RW_PORT, &high) ||\r\ntg3_wait_macro_done(tp)) {\r\n*resetp = 1;\r\nreturn -EBUSY;\r\n}\r\nlow &= 0x7fff;\r\nhigh &= 0x000f;\r\nif (low != test_pat[chan][i] ||\r\nhigh != test_pat[chan][i+1]) {\r\ntg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x000b);\r\ntg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x4001);\r\ntg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x4005);\r\nreturn -EBUSY;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tg3_phy_reset_chanpat(struct tg3 *tp)\r\n{\r\nint chan;\r\nfor (chan = 0; chan < 4; chan++) {\r\nint i;\r\ntg3_writephy(tp, MII_TG3_DSP_ADDRESS,\r\n(chan * 0x2000) | 0x0200);\r\ntg3_writephy(tp, MII_TG3_DSP_CONTROL, 0x0002);\r\nfor (i = 0; i < 6; i++)\r\ntg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x000);\r\ntg3_writephy(tp, MII_TG3_DSP_CONTROL, 0x0202);\r\nif (tg3_wait_macro_done(tp))\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tg3_phy_reset_5703_4_5(struct tg3 *tp)\r\n{\r\nu32 reg32, phy9_orig;\r\nint retries, do_phy_reset, err;\r\nretries = 10;\r\ndo_phy_reset = 1;\r\ndo {\r\nif (do_phy_reset) {\r\nerr = tg3_bmcr_reset(tp);\r\nif (err)\r\nreturn err;\r\ndo_phy_reset = 0;\r\n}\r\nif (tg3_readphy(tp, MII_TG3_EXT_CTRL, &reg32))\r\ncontinue;\r\nreg32 |= 0x3000;\r\ntg3_writephy(tp, MII_TG3_EXT_CTRL, reg32);\r\ntg3_writephy(tp, MII_BMCR,\r\nBMCR_FULLDPLX | BMCR_SPEED1000);\r\nif (tg3_readphy(tp, MII_CTRL1000, &phy9_orig))\r\ncontinue;\r\ntg3_writephy(tp, MII_CTRL1000,\r\nCTL1000_AS_MASTER | CTL1000_ENABLE_MASTER);\r\nerr = tg3_phy_toggle_auxctl_smdsp(tp, true);\r\nif (err)\r\nreturn err;\r\ntg3_phydsp_write(tp, 0x8005, 0x0800);\r\nerr = tg3_phy_write_and_check_testpat(tp, &do_phy_reset);\r\nif (!err)\r\nbreak;\r\n} while (--retries);\r\nerr = tg3_phy_reset_chanpat(tp);\r\nif (err)\r\nreturn err;\r\ntg3_phydsp_write(tp, 0x8005, 0x0000);\r\ntg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x8200);\r\ntg3_writephy(tp, MII_TG3_DSP_CONTROL, 0x0000);\r\ntg3_phy_toggle_auxctl_smdsp(tp, false);\r\ntg3_writephy(tp, MII_CTRL1000, phy9_orig);\r\nerr = tg3_readphy(tp, MII_TG3_EXT_CTRL, &reg32);\r\nif (err)\r\nreturn err;\r\nreg32 &= ~0x3000;\r\ntg3_writephy(tp, MII_TG3_EXT_CTRL, reg32);\r\nreturn 0;\r\n}\r\nstatic void tg3_carrier_off(struct tg3 *tp)\r\n{\r\nnetif_carrier_off(tp->dev);\r\ntp->link_up = false;\r\n}\r\nstatic void tg3_warn_mgmt_link_flap(struct tg3 *tp)\r\n{\r\nif (tg3_flag(tp, ENABLE_ASF))\r\nnetdev_warn(tp->dev,\r\n"Management side-band traffic will be interrupted during phy settings change\n");\r\n}\r\nstatic int tg3_phy_reset(struct tg3 *tp)\r\n{\r\nu32 val, cpmuctrl;\r\nint err;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5906) {\r\nval = tr32(GRC_MISC_CFG);\r\ntw32_f(GRC_MISC_CFG, val & ~GRC_MISC_CFG_EPHY_IDDQ);\r\nudelay(40);\r\n}\r\nerr = tg3_readphy(tp, MII_BMSR, &val);\r\nerr |= tg3_readphy(tp, MII_BMSR, &val);\r\nif (err != 0)\r\nreturn -EBUSY;\r\nif (netif_running(tp->dev) && tp->link_up) {\r\nnetif_carrier_off(tp->dev);\r\ntg3_link_report(tp);\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5703 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5704 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5705) {\r\nerr = tg3_phy_reset_5703_4_5(tp);\r\nif (err)\r\nreturn err;\r\ngoto out;\r\n}\r\ncpmuctrl = 0;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5784 &&\r\ntg3_chip_rev(tp) != CHIPREV_5784_AX) {\r\ncpmuctrl = tr32(TG3_CPMU_CTRL);\r\nif (cpmuctrl & CPMU_CTRL_GPHY_10MB_RXONLY)\r\ntw32(TG3_CPMU_CTRL,\r\ncpmuctrl & ~CPMU_CTRL_GPHY_10MB_RXONLY);\r\n}\r\nerr = tg3_bmcr_reset(tp);\r\nif (err)\r\nreturn err;\r\nif (cpmuctrl & CPMU_CTRL_GPHY_10MB_RXONLY) {\r\nval = MII_TG3_DSP_EXP8_AEDW | MII_TG3_DSP_EXP8_REJ2MHz;\r\ntg3_phydsp_write(tp, MII_TG3_DSP_EXP8, val);\r\ntw32(TG3_CPMU_CTRL, cpmuctrl);\r\n}\r\nif (tg3_chip_rev(tp) == CHIPREV_5784_AX ||\r\ntg3_chip_rev(tp) == CHIPREV_5761_AX) {\r\nval = tr32(TG3_CPMU_LSPD_1000MB_CLK);\r\nif ((val & CPMU_LSPD_1000MB_MACCLK_MASK) ==\r\nCPMU_LSPD_1000MB_MACCLK_12_5) {\r\nval &= ~CPMU_LSPD_1000MB_MACCLK_MASK;\r\nudelay(40);\r\ntw32_f(TG3_CPMU_LSPD_1000MB_CLK, val);\r\n}\r\n}\r\nif (tg3_flag(tp, 5717_PLUS) &&\r\n(tp->phy_flags & TG3_PHYFLG_MII_SERDES))\r\nreturn 0;\r\ntg3_phy_apply_otp(tp);\r\nif (tp->phy_flags & TG3_PHYFLG_ENABLE_APD)\r\ntg3_phy_toggle_apd(tp, true);\r\nelse\r\ntg3_phy_toggle_apd(tp, false);\r\nout:\r\nif ((tp->phy_flags & TG3_PHYFLG_ADC_BUG) &&\r\n!tg3_phy_toggle_auxctl_smdsp(tp, true)) {\r\ntg3_phydsp_write(tp, 0x201f, 0x2aaa);\r\ntg3_phydsp_write(tp, 0x000a, 0x0323);\r\ntg3_phy_toggle_auxctl_smdsp(tp, false);\r\n}\r\nif (tp->phy_flags & TG3_PHYFLG_5704_A0_BUG) {\r\ntg3_writephy(tp, MII_TG3_MISC_SHDW, 0x8d68);\r\ntg3_writephy(tp, MII_TG3_MISC_SHDW, 0x8d68);\r\n}\r\nif (tp->phy_flags & TG3_PHYFLG_BER_BUG) {\r\nif (!tg3_phy_toggle_auxctl_smdsp(tp, true)) {\r\ntg3_phydsp_write(tp, 0x000a, 0x310b);\r\ntg3_phydsp_write(tp, 0x201f, 0x9506);\r\ntg3_phydsp_write(tp, 0x401f, 0x14e2);\r\ntg3_phy_toggle_auxctl_smdsp(tp, false);\r\n}\r\n} else if (tp->phy_flags & TG3_PHYFLG_JITTER_BUG) {\r\nif (!tg3_phy_toggle_auxctl_smdsp(tp, true)) {\r\ntg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x000a);\r\nif (tp->phy_flags & TG3_PHYFLG_ADJUST_TRIM) {\r\ntg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x110b);\r\ntg3_writephy(tp, MII_TG3_TEST1,\r\nMII_TG3_TEST1_TRIM_EN | 0x4);\r\n} else\r\ntg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x010b);\r\ntg3_phy_toggle_auxctl_smdsp(tp, false);\r\n}\r\n}\r\nif ((tp->phy_id & TG3_PHY_ID_MASK) == TG3_PHY_ID_BCM5401) {\r\ntg3_phy_auxctl_write(tp, MII_TG3_AUXCTL_SHDWSEL_AUXCTL, 0x4c20);\r\n} else if (tg3_flag(tp, JUMBO_CAPABLE)) {\r\nerr = tg3_phy_auxctl_read(tp,\r\nMII_TG3_AUXCTL_SHDWSEL_AUXCTL, &val);\r\nif (!err)\r\ntg3_phy_auxctl_write(tp, MII_TG3_AUXCTL_SHDWSEL_AUXCTL,\r\nval | MII_TG3_AUXCTL_ACTL_EXTPKTLEN);\r\n}\r\nif (tg3_flag(tp, JUMBO_CAPABLE)) {\r\nif (!tg3_readphy(tp, MII_TG3_EXT_CTRL, &val))\r\ntg3_writephy(tp, MII_TG3_EXT_CTRL,\r\nval | MII_TG3_EXT_CTRL_FIFO_ELASTIC);\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5906) {\r\ntg3_writephy(tp, MII_TG3_FET_PTEST, 0x12);\r\n}\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5762_A0)\r\ntg3_phydsp_write(tp, 0xffb, 0x4000);\r\ntg3_phy_toggle_automdix(tp, true);\r\ntg3_phy_set_wirespeed(tp);\r\nreturn 0;\r\n}\r\nstatic inline u32 tg3_set_function_status(struct tg3 *tp, u32 newstat)\r\n{\r\nu32 status, shift;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5719)\r\nstatus = tg3_ape_read32(tp, TG3_APE_GPIO_MSG);\r\nelse\r\nstatus = tr32(TG3_CPMU_DRV_STATUS);\r\nshift = TG3_APE_GPIO_MSG_SHIFT + 4 * tp->pci_fn;\r\nstatus &= ~(TG3_GPIO_MSG_MASK << shift);\r\nstatus |= (newstat << shift);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5719)\r\ntg3_ape_write32(tp, TG3_APE_GPIO_MSG, status);\r\nelse\r\ntw32(TG3_CPMU_DRV_STATUS, status);\r\nreturn status >> TG3_APE_GPIO_MSG_SHIFT;\r\n}\r\nstatic inline int tg3_pwrsrc_switch_to_vmain(struct tg3 *tp)\r\n{\r\nif (!tg3_flag(tp, IS_NIC))\r\nreturn 0;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5719 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5720) {\r\nif (tg3_ape_lock(tp, TG3_APE_LOCK_GPIO))\r\nreturn -EIO;\r\ntg3_set_function_status(tp, TG3_GPIO_MSG_DRVR_PRES);\r\ntw32_wait_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl,\r\nTG3_GRC_LCLCTL_PWRSW_DELAY);\r\ntg3_ape_unlock(tp, TG3_APE_LOCK_GPIO);\r\n} else {\r\ntw32_wait_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl,\r\nTG3_GRC_LCLCTL_PWRSW_DELAY);\r\n}\r\nreturn 0;\r\n}\r\nstatic void tg3_pwrsrc_die_with_vmain(struct tg3 *tp)\r\n{\r\nu32 grc_local_ctrl;\r\nif (!tg3_flag(tp, IS_NIC) ||\r\ntg3_asic_rev(tp) == ASIC_REV_5700 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5701)\r\nreturn;\r\ngrc_local_ctrl = tp->grc_local_ctrl | GRC_LCLCTRL_GPIO_OE1;\r\ntw32_wait_f(GRC_LOCAL_CTRL,\r\ngrc_local_ctrl | GRC_LCLCTRL_GPIO_OUTPUT1,\r\nTG3_GRC_LCLCTL_PWRSW_DELAY);\r\ntw32_wait_f(GRC_LOCAL_CTRL,\r\ngrc_local_ctrl,\r\nTG3_GRC_LCLCTL_PWRSW_DELAY);\r\ntw32_wait_f(GRC_LOCAL_CTRL,\r\ngrc_local_ctrl | GRC_LCLCTRL_GPIO_OUTPUT1,\r\nTG3_GRC_LCLCTL_PWRSW_DELAY);\r\n}\r\nstatic void tg3_pwrsrc_switch_to_vaux(struct tg3 *tp)\r\n{\r\nif (!tg3_flag(tp, IS_NIC))\r\nreturn;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5700 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5701) {\r\ntw32_wait_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl |\r\n(GRC_LCLCTRL_GPIO_OE0 |\r\nGRC_LCLCTRL_GPIO_OE1 |\r\nGRC_LCLCTRL_GPIO_OE2 |\r\nGRC_LCLCTRL_GPIO_OUTPUT0 |\r\nGRC_LCLCTRL_GPIO_OUTPUT1),\r\nTG3_GRC_LCLCTL_PWRSW_DELAY);\r\n} else if (tp->pdev->device == PCI_DEVICE_ID_TIGON3_5761 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5761S) {\r\nu32 grc_local_ctrl = GRC_LCLCTRL_GPIO_OE0 |\r\nGRC_LCLCTRL_GPIO_OE1 |\r\nGRC_LCLCTRL_GPIO_OE2 |\r\nGRC_LCLCTRL_GPIO_OUTPUT0 |\r\nGRC_LCLCTRL_GPIO_OUTPUT1 |\r\ntp->grc_local_ctrl;\r\ntw32_wait_f(GRC_LOCAL_CTRL, grc_local_ctrl,\r\nTG3_GRC_LCLCTL_PWRSW_DELAY);\r\ngrc_local_ctrl |= GRC_LCLCTRL_GPIO_OUTPUT2;\r\ntw32_wait_f(GRC_LOCAL_CTRL, grc_local_ctrl,\r\nTG3_GRC_LCLCTL_PWRSW_DELAY);\r\ngrc_local_ctrl &= ~GRC_LCLCTRL_GPIO_OUTPUT0;\r\ntw32_wait_f(GRC_LOCAL_CTRL, grc_local_ctrl,\r\nTG3_GRC_LCLCTL_PWRSW_DELAY);\r\n} else {\r\nu32 no_gpio2;\r\nu32 grc_local_ctrl = 0;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5714) {\r\ngrc_local_ctrl |= GRC_LCLCTRL_GPIO_OE3;\r\ntw32_wait_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl |\r\ngrc_local_ctrl,\r\nTG3_GRC_LCLCTL_PWRSW_DELAY);\r\n}\r\nno_gpio2 = tp->nic_sram_data_cfg &\r\nNIC_SRAM_DATA_CFG_NO_GPIO2;\r\ngrc_local_ctrl |= GRC_LCLCTRL_GPIO_OE0 |\r\nGRC_LCLCTRL_GPIO_OE1 |\r\nGRC_LCLCTRL_GPIO_OE2 |\r\nGRC_LCLCTRL_GPIO_OUTPUT1 |\r\nGRC_LCLCTRL_GPIO_OUTPUT2;\r\nif (no_gpio2) {\r\ngrc_local_ctrl &= ~(GRC_LCLCTRL_GPIO_OE2 |\r\nGRC_LCLCTRL_GPIO_OUTPUT2);\r\n}\r\ntw32_wait_f(GRC_LOCAL_CTRL,\r\ntp->grc_local_ctrl | grc_local_ctrl,\r\nTG3_GRC_LCLCTL_PWRSW_DELAY);\r\ngrc_local_ctrl |= GRC_LCLCTRL_GPIO_OUTPUT0;\r\ntw32_wait_f(GRC_LOCAL_CTRL,\r\ntp->grc_local_ctrl | grc_local_ctrl,\r\nTG3_GRC_LCLCTL_PWRSW_DELAY);\r\nif (!no_gpio2) {\r\ngrc_local_ctrl &= ~GRC_LCLCTRL_GPIO_OUTPUT2;\r\ntw32_wait_f(GRC_LOCAL_CTRL,\r\ntp->grc_local_ctrl | grc_local_ctrl,\r\nTG3_GRC_LCLCTL_PWRSW_DELAY);\r\n}\r\n}\r\n}\r\nstatic void tg3_frob_aux_power_5717(struct tg3 *tp, bool wol_enable)\r\n{\r\nu32 msg = 0;\r\nif (tg3_ape_lock(tp, TG3_APE_LOCK_GPIO))\r\nreturn;\r\nif (tg3_flag(tp, ENABLE_ASF) || tg3_flag(tp, ENABLE_APE) || wol_enable)\r\nmsg = TG3_GPIO_MSG_NEED_VAUX;\r\nmsg = tg3_set_function_status(tp, msg);\r\nif (msg & TG3_GPIO_MSG_ALL_DRVR_PRES_MASK)\r\ngoto done;\r\nif (msg & TG3_GPIO_MSG_ALL_NEED_VAUX_MASK)\r\ntg3_pwrsrc_switch_to_vaux(tp);\r\nelse\r\ntg3_pwrsrc_die_with_vmain(tp);\r\ndone:\r\ntg3_ape_unlock(tp, TG3_APE_LOCK_GPIO);\r\n}\r\nstatic void tg3_frob_aux_power(struct tg3 *tp, bool include_wol)\r\n{\r\nbool need_vaux = false;\r\nif (!tg3_flag(tp, IS_NIC) || tg3_flag(tp, 57765_CLASS))\r\nreturn;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5719 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5720) {\r\ntg3_frob_aux_power_5717(tp, include_wol ?\r\ntg3_flag(tp, WOL_ENABLE) != 0 : 0);\r\nreturn;\r\n}\r\nif (tp->pdev_peer && tp->pdev_peer != tp->pdev) {\r\nstruct net_device *dev_peer;\r\ndev_peer = pci_get_drvdata(tp->pdev_peer);\r\nif (dev_peer) {\r\nstruct tg3 *tp_peer = netdev_priv(dev_peer);\r\nif (tg3_flag(tp_peer, INIT_COMPLETE))\r\nreturn;\r\nif ((include_wol && tg3_flag(tp_peer, WOL_ENABLE)) ||\r\ntg3_flag(tp_peer, ENABLE_ASF))\r\nneed_vaux = true;\r\n}\r\n}\r\nif ((include_wol && tg3_flag(tp, WOL_ENABLE)) ||\r\ntg3_flag(tp, ENABLE_ASF))\r\nneed_vaux = true;\r\nif (need_vaux)\r\ntg3_pwrsrc_switch_to_vaux(tp);\r\nelse\r\ntg3_pwrsrc_die_with_vmain(tp);\r\n}\r\nstatic int tg3_5700_link_polarity(struct tg3 *tp, u32 speed)\r\n{\r\nif (tp->led_ctrl == LED_CTRL_MODE_PHY_2)\r\nreturn 1;\r\nelse if ((tp->phy_id & TG3_PHY_ID_MASK) == TG3_PHY_ID_BCM5411) {\r\nif (speed != SPEED_10)\r\nreturn 1;\r\n} else if (speed == SPEED_10)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic bool tg3_phy_power_bug(struct tg3 *tp)\r\n{\r\nswitch (tg3_asic_rev(tp)) {\r\ncase ASIC_REV_5700:\r\ncase ASIC_REV_5704:\r\nreturn true;\r\ncase ASIC_REV_5780:\r\nif (tp->phy_flags & TG3_PHYFLG_MII_SERDES)\r\nreturn true;\r\nreturn false;\r\ncase ASIC_REV_5717:\r\nif (!tp->pci_fn)\r\nreturn true;\r\nreturn false;\r\ncase ASIC_REV_5719:\r\ncase ASIC_REV_5720:\r\nif ((tp->phy_flags & TG3_PHYFLG_PHY_SERDES) &&\r\n!tp->pci_fn)\r\nreturn true;\r\nreturn false;\r\n}\r\nreturn false;\r\n}\r\nstatic bool tg3_phy_led_bug(struct tg3 *tp)\r\n{\r\nswitch (tg3_asic_rev(tp)) {\r\ncase ASIC_REV_5719:\r\ncase ASIC_REV_5720:\r\nif ((tp->phy_flags & TG3_PHYFLG_MII_SERDES) &&\r\n!tp->pci_fn)\r\nreturn true;\r\nreturn false;\r\n}\r\nreturn false;\r\n}\r\nstatic void tg3_power_down_phy(struct tg3 *tp, bool do_low_power)\r\n{\r\nu32 val;\r\nif (tp->phy_flags & TG3_PHYFLG_KEEP_LINK_ON_PWRDN)\r\nreturn;\r\nif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES) {\r\nif (tg3_asic_rev(tp) == ASIC_REV_5704) {\r\nu32 sg_dig_ctrl = tr32(SG_DIG_CTRL);\r\nu32 serdes_cfg = tr32(MAC_SERDES_CFG);\r\nsg_dig_ctrl |=\r\nSG_DIG_USING_HW_AUTONEG | SG_DIG_SOFT_RESET;\r\ntw32(SG_DIG_CTRL, sg_dig_ctrl);\r\ntw32(MAC_SERDES_CFG, serdes_cfg | (1 << 15));\r\n}\r\nreturn;\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5906) {\r\ntg3_bmcr_reset(tp);\r\nval = tr32(GRC_MISC_CFG);\r\ntw32_f(GRC_MISC_CFG, val | GRC_MISC_CFG_EPHY_IDDQ);\r\nudelay(40);\r\nreturn;\r\n} else if (tp->phy_flags & TG3_PHYFLG_IS_FET) {\r\nu32 phytest;\r\nif (!tg3_readphy(tp, MII_TG3_FET_TEST, &phytest)) {\r\nu32 phy;\r\ntg3_writephy(tp, MII_ADVERTISE, 0);\r\ntg3_writephy(tp, MII_BMCR,\r\nBMCR_ANENABLE | BMCR_ANRESTART);\r\ntg3_writephy(tp, MII_TG3_FET_TEST,\r\nphytest | MII_TG3_FET_SHADOW_EN);\r\nif (!tg3_readphy(tp, MII_TG3_FET_SHDW_AUXMODE4, &phy)) {\r\nphy |= MII_TG3_FET_SHDW_AUXMODE4_SBPD;\r\ntg3_writephy(tp,\r\nMII_TG3_FET_SHDW_AUXMODE4,\r\nphy);\r\n}\r\ntg3_writephy(tp, MII_TG3_FET_TEST, phytest);\r\n}\r\nreturn;\r\n} else if (do_low_power) {\r\nif (!tg3_phy_led_bug(tp))\r\ntg3_writephy(tp, MII_TG3_EXT_CTRL,\r\nMII_TG3_EXT_CTRL_FORCE_LED_OFF);\r\nval = MII_TG3_AUXCTL_PCTL_100TX_LPWR |\r\nMII_TG3_AUXCTL_PCTL_SPR_ISOLATE |\r\nMII_TG3_AUXCTL_PCTL_VREG_11V;\r\ntg3_phy_auxctl_write(tp, MII_TG3_AUXCTL_SHDWSEL_PWRCTL, val);\r\n}\r\nif (tg3_phy_power_bug(tp))\r\nreturn;\r\nif (tg3_chip_rev(tp) == CHIPREV_5784_AX ||\r\ntg3_chip_rev(tp) == CHIPREV_5761_AX) {\r\nval = tr32(TG3_CPMU_LSPD_1000MB_CLK);\r\nval &= ~CPMU_LSPD_1000MB_MACCLK_MASK;\r\nval |= CPMU_LSPD_1000MB_MACCLK_12_5;\r\ntw32_f(TG3_CPMU_LSPD_1000MB_CLK, val);\r\n}\r\ntg3_writephy(tp, MII_BMCR, BMCR_PDOWN);\r\n}\r\nstatic int tg3_nvram_lock(struct tg3 *tp)\r\n{\r\nif (tg3_flag(tp, NVRAM)) {\r\nint i;\r\nif (tp->nvram_lock_cnt == 0) {\r\ntw32(NVRAM_SWARB, SWARB_REQ_SET1);\r\nfor (i = 0; i < 8000; i++) {\r\nif (tr32(NVRAM_SWARB) & SWARB_GNT1)\r\nbreak;\r\nudelay(20);\r\n}\r\nif (i == 8000) {\r\ntw32(NVRAM_SWARB, SWARB_REQ_CLR1);\r\nreturn -ENODEV;\r\n}\r\n}\r\ntp->nvram_lock_cnt++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tg3_nvram_unlock(struct tg3 *tp)\r\n{\r\nif (tg3_flag(tp, NVRAM)) {\r\nif (tp->nvram_lock_cnt > 0)\r\ntp->nvram_lock_cnt--;\r\nif (tp->nvram_lock_cnt == 0)\r\ntw32_f(NVRAM_SWARB, SWARB_REQ_CLR1);\r\n}\r\n}\r\nstatic void tg3_enable_nvram_access(struct tg3 *tp)\r\n{\r\nif (tg3_flag(tp, 5750_PLUS) && !tg3_flag(tp, PROTECTED_NVRAM)) {\r\nu32 nvaccess = tr32(NVRAM_ACCESS);\r\ntw32(NVRAM_ACCESS, nvaccess | ACCESS_ENABLE);\r\n}\r\n}\r\nstatic void tg3_disable_nvram_access(struct tg3 *tp)\r\n{\r\nif (tg3_flag(tp, 5750_PLUS) && !tg3_flag(tp, PROTECTED_NVRAM)) {\r\nu32 nvaccess = tr32(NVRAM_ACCESS);\r\ntw32(NVRAM_ACCESS, nvaccess & ~ACCESS_ENABLE);\r\n}\r\n}\r\nstatic int tg3_nvram_read_using_eeprom(struct tg3 *tp,\r\nu32 offset, u32 *val)\r\n{\r\nu32 tmp;\r\nint i;\r\nif (offset > EEPROM_ADDR_ADDR_MASK || (offset % 4) != 0)\r\nreturn -EINVAL;\r\ntmp = tr32(GRC_EEPROM_ADDR) & ~(EEPROM_ADDR_ADDR_MASK |\r\nEEPROM_ADDR_DEVID_MASK |\r\nEEPROM_ADDR_READ);\r\ntw32(GRC_EEPROM_ADDR,\r\ntmp |\r\n(0 << EEPROM_ADDR_DEVID_SHIFT) |\r\n((offset << EEPROM_ADDR_ADDR_SHIFT) &\r\nEEPROM_ADDR_ADDR_MASK) |\r\nEEPROM_ADDR_READ | EEPROM_ADDR_START);\r\nfor (i = 0; i < 1000; i++) {\r\ntmp = tr32(GRC_EEPROM_ADDR);\r\nif (tmp & EEPROM_ADDR_COMPLETE)\r\nbreak;\r\nmsleep(1);\r\n}\r\nif (!(tmp & EEPROM_ADDR_COMPLETE))\r\nreturn -EBUSY;\r\ntmp = tr32(GRC_EEPROM_DATA);\r\n*val = swab32(tmp);\r\nreturn 0;\r\n}\r\nstatic int tg3_nvram_exec_cmd(struct tg3 *tp, u32 nvram_cmd)\r\n{\r\nint i;\r\ntw32(NVRAM_CMD, nvram_cmd);\r\nfor (i = 0; i < NVRAM_CMD_TIMEOUT; i++) {\r\nusleep_range(10, 40);\r\nif (tr32(NVRAM_CMD) & NVRAM_CMD_DONE) {\r\nudelay(10);\r\nbreak;\r\n}\r\n}\r\nif (i == NVRAM_CMD_TIMEOUT)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic u32 tg3_nvram_phys_addr(struct tg3 *tp, u32 addr)\r\n{\r\nif (tg3_flag(tp, NVRAM) &&\r\ntg3_flag(tp, NVRAM_BUFFERED) &&\r\ntg3_flag(tp, FLASH) &&\r\n!tg3_flag(tp, NO_NVRAM_ADDR_TRANS) &&\r\n(tp->nvram_jedecnum == JEDEC_ATMEL))\r\naddr = ((addr / tp->nvram_pagesize) <<\r\nATMEL_AT45DB0X1B_PAGE_POS) +\r\n(addr % tp->nvram_pagesize);\r\nreturn addr;\r\n}\r\nstatic u32 tg3_nvram_logical_addr(struct tg3 *tp, u32 addr)\r\n{\r\nif (tg3_flag(tp, NVRAM) &&\r\ntg3_flag(tp, NVRAM_BUFFERED) &&\r\ntg3_flag(tp, FLASH) &&\r\n!tg3_flag(tp, NO_NVRAM_ADDR_TRANS) &&\r\n(tp->nvram_jedecnum == JEDEC_ATMEL))\r\naddr = ((addr >> ATMEL_AT45DB0X1B_PAGE_POS) *\r\ntp->nvram_pagesize) +\r\n(addr & ((1 << ATMEL_AT45DB0X1B_PAGE_POS) - 1));\r\nreturn addr;\r\n}\r\nstatic int tg3_nvram_read(struct tg3 *tp, u32 offset, u32 *val)\r\n{\r\nint ret;\r\nif (!tg3_flag(tp, NVRAM))\r\nreturn tg3_nvram_read_using_eeprom(tp, offset, val);\r\noffset = tg3_nvram_phys_addr(tp, offset);\r\nif (offset > NVRAM_ADDR_MSK)\r\nreturn -EINVAL;\r\nret = tg3_nvram_lock(tp);\r\nif (ret)\r\nreturn ret;\r\ntg3_enable_nvram_access(tp);\r\ntw32(NVRAM_ADDR, offset);\r\nret = tg3_nvram_exec_cmd(tp, NVRAM_CMD_RD | NVRAM_CMD_GO |\r\nNVRAM_CMD_FIRST | NVRAM_CMD_LAST | NVRAM_CMD_DONE);\r\nif (ret == 0)\r\n*val = tr32(NVRAM_RDDATA);\r\ntg3_disable_nvram_access(tp);\r\ntg3_nvram_unlock(tp);\r\nreturn ret;\r\n}\r\nstatic int tg3_nvram_read_be32(struct tg3 *tp, u32 offset, __be32 *val)\r\n{\r\nu32 v;\r\nint res = tg3_nvram_read(tp, offset, &v);\r\nif (!res)\r\n*val = cpu_to_be32(v);\r\nreturn res;\r\n}\r\nstatic int tg3_nvram_write_block_using_eeprom(struct tg3 *tp,\r\nu32 offset, u32 len, u8 *buf)\r\n{\r\nint i, j, rc = 0;\r\nu32 val;\r\nfor (i = 0; i < len; i += 4) {\r\nu32 addr;\r\n__be32 data;\r\naddr = offset + i;\r\nmemcpy(&data, buf + i, 4);\r\ntw32(GRC_EEPROM_DATA, swab32(be32_to_cpu(data)));\r\nval = tr32(GRC_EEPROM_ADDR);\r\ntw32(GRC_EEPROM_ADDR, val | EEPROM_ADDR_COMPLETE);\r\nval &= ~(EEPROM_ADDR_ADDR_MASK | EEPROM_ADDR_DEVID_MASK |\r\nEEPROM_ADDR_READ);\r\ntw32(GRC_EEPROM_ADDR, val |\r\n(0 << EEPROM_ADDR_DEVID_SHIFT) |\r\n(addr & EEPROM_ADDR_ADDR_MASK) |\r\nEEPROM_ADDR_START |\r\nEEPROM_ADDR_WRITE);\r\nfor (j = 0; j < 1000; j++) {\r\nval = tr32(GRC_EEPROM_ADDR);\r\nif (val & EEPROM_ADDR_COMPLETE)\r\nbreak;\r\nmsleep(1);\r\n}\r\nif (!(val & EEPROM_ADDR_COMPLETE)) {\r\nrc = -EBUSY;\r\nbreak;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int tg3_nvram_write_block_unbuffered(struct tg3 *tp, u32 offset, u32 len,\r\nu8 *buf)\r\n{\r\nint ret = 0;\r\nu32 pagesize = tp->nvram_pagesize;\r\nu32 pagemask = pagesize - 1;\r\nu32 nvram_cmd;\r\nu8 *tmp;\r\ntmp = kmalloc(pagesize, GFP_KERNEL);\r\nif (tmp == NULL)\r\nreturn -ENOMEM;\r\nwhile (len) {\r\nint j;\r\nu32 phy_addr, page_off, size;\r\nphy_addr = offset & ~pagemask;\r\nfor (j = 0; j < pagesize; j += 4) {\r\nret = tg3_nvram_read_be32(tp, phy_addr + j,\r\n(__be32 *) (tmp + j));\r\nif (ret)\r\nbreak;\r\n}\r\nif (ret)\r\nbreak;\r\npage_off = offset & pagemask;\r\nsize = pagesize;\r\nif (len < size)\r\nsize = len;\r\nlen -= size;\r\nmemcpy(tmp + page_off, buf, size);\r\noffset = offset + (pagesize - page_off);\r\ntg3_enable_nvram_access(tp);\r\nnvram_cmd = NVRAM_CMD_WREN | NVRAM_CMD_GO | NVRAM_CMD_DONE;\r\nif (tg3_nvram_exec_cmd(tp, nvram_cmd))\r\nbreak;\r\ntw32(NVRAM_ADDR, phy_addr);\r\nnvram_cmd = NVRAM_CMD_GO | NVRAM_CMD_DONE | NVRAM_CMD_WR |\r\nNVRAM_CMD_FIRST | NVRAM_CMD_LAST | NVRAM_CMD_ERASE;\r\nif (tg3_nvram_exec_cmd(tp, nvram_cmd))\r\nbreak;\r\nnvram_cmd = NVRAM_CMD_WREN | NVRAM_CMD_GO | NVRAM_CMD_DONE;\r\nif (tg3_nvram_exec_cmd(tp, nvram_cmd))\r\nbreak;\r\nfor (j = 0; j < pagesize; j += 4) {\r\n__be32 data;\r\ndata = *((__be32 *) (tmp + j));\r\ntw32(NVRAM_WRDATA, be32_to_cpu(data));\r\ntw32(NVRAM_ADDR, phy_addr + j);\r\nnvram_cmd = NVRAM_CMD_GO | NVRAM_CMD_DONE |\r\nNVRAM_CMD_WR;\r\nif (j == 0)\r\nnvram_cmd |= NVRAM_CMD_FIRST;\r\nelse if (j == (pagesize - 4))\r\nnvram_cmd |= NVRAM_CMD_LAST;\r\nret = tg3_nvram_exec_cmd(tp, nvram_cmd);\r\nif (ret)\r\nbreak;\r\n}\r\nif (ret)\r\nbreak;\r\n}\r\nnvram_cmd = NVRAM_CMD_WRDI | NVRAM_CMD_GO | NVRAM_CMD_DONE;\r\ntg3_nvram_exec_cmd(tp, nvram_cmd);\r\nkfree(tmp);\r\nreturn ret;\r\n}\r\nstatic int tg3_nvram_write_block_buffered(struct tg3 *tp, u32 offset, u32 len,\r\nu8 *buf)\r\n{\r\nint i, ret = 0;\r\nfor (i = 0; i < len; i += 4, offset += 4) {\r\nu32 page_off, phy_addr, nvram_cmd;\r\n__be32 data;\r\nmemcpy(&data, buf + i, 4);\r\ntw32(NVRAM_WRDATA, be32_to_cpu(data));\r\npage_off = offset % tp->nvram_pagesize;\r\nphy_addr = tg3_nvram_phys_addr(tp, offset);\r\nnvram_cmd = NVRAM_CMD_GO | NVRAM_CMD_DONE | NVRAM_CMD_WR;\r\nif (page_off == 0 || i == 0)\r\nnvram_cmd |= NVRAM_CMD_FIRST;\r\nif (page_off == (tp->nvram_pagesize - 4))\r\nnvram_cmd |= NVRAM_CMD_LAST;\r\nif (i == (len - 4))\r\nnvram_cmd |= NVRAM_CMD_LAST;\r\nif ((nvram_cmd & NVRAM_CMD_FIRST) ||\r\n!tg3_flag(tp, FLASH) ||\r\n!tg3_flag(tp, 57765_PLUS))\r\ntw32(NVRAM_ADDR, phy_addr);\r\nif (tg3_asic_rev(tp) != ASIC_REV_5752 &&\r\n!tg3_flag(tp, 5755_PLUS) &&\r\n(tp->nvram_jedecnum == JEDEC_ST) &&\r\n(nvram_cmd & NVRAM_CMD_FIRST)) {\r\nu32 cmd;\r\ncmd = NVRAM_CMD_WREN | NVRAM_CMD_GO | NVRAM_CMD_DONE;\r\nret = tg3_nvram_exec_cmd(tp, cmd);\r\nif (ret)\r\nbreak;\r\n}\r\nif (!tg3_flag(tp, FLASH)) {\r\nnvram_cmd |= (NVRAM_CMD_FIRST | NVRAM_CMD_LAST);\r\n}\r\nret = tg3_nvram_exec_cmd(tp, nvram_cmd);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tg3_nvram_write_block(struct tg3 *tp, u32 offset, u32 len, u8 *buf)\r\n{\r\nint ret;\r\nif (tg3_flag(tp, EEPROM_WRITE_PROT)) {\r\ntw32_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl &\r\n~GRC_LCLCTRL_GPIO_OUTPUT1);\r\nudelay(40);\r\n}\r\nif (!tg3_flag(tp, NVRAM)) {\r\nret = tg3_nvram_write_block_using_eeprom(tp, offset, len, buf);\r\n} else {\r\nu32 grc_mode;\r\nret = tg3_nvram_lock(tp);\r\nif (ret)\r\nreturn ret;\r\ntg3_enable_nvram_access(tp);\r\nif (tg3_flag(tp, 5750_PLUS) && !tg3_flag(tp, PROTECTED_NVRAM))\r\ntw32(NVRAM_WRITE1, 0x406);\r\ngrc_mode = tr32(GRC_MODE);\r\ntw32(GRC_MODE, grc_mode | GRC_MODE_NVRAM_WR_ENABLE);\r\nif (tg3_flag(tp, NVRAM_BUFFERED) || !tg3_flag(tp, FLASH)) {\r\nret = tg3_nvram_write_block_buffered(tp, offset, len,\r\nbuf);\r\n} else {\r\nret = tg3_nvram_write_block_unbuffered(tp, offset, len,\r\nbuf);\r\n}\r\ngrc_mode = tr32(GRC_MODE);\r\ntw32(GRC_MODE, grc_mode & ~GRC_MODE_NVRAM_WR_ENABLE);\r\ntg3_disable_nvram_access(tp);\r\ntg3_nvram_unlock(tp);\r\n}\r\nif (tg3_flag(tp, EEPROM_WRITE_PROT)) {\r\ntw32_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl);\r\nudelay(40);\r\n}\r\nreturn ret;\r\n}\r\nstatic int tg3_pause_cpu(struct tg3 *tp, u32 cpu_base)\r\n{\r\nint i;\r\nconst int iters = 10000;\r\nfor (i = 0; i < iters; i++) {\r\ntw32(cpu_base + CPU_STATE, 0xffffffff);\r\ntw32(cpu_base + CPU_MODE, CPU_MODE_HALT);\r\nif (tr32(cpu_base + CPU_MODE) & CPU_MODE_HALT)\r\nbreak;\r\nif (pci_channel_offline(tp->pdev))\r\nreturn -EBUSY;\r\n}\r\nreturn (i == iters) ? -EBUSY : 0;\r\n}\r\nstatic int tg3_rxcpu_pause(struct tg3 *tp)\r\n{\r\nint rc = tg3_pause_cpu(tp, RX_CPU_BASE);\r\ntw32(RX_CPU_BASE + CPU_STATE, 0xffffffff);\r\ntw32_f(RX_CPU_BASE + CPU_MODE, CPU_MODE_HALT);\r\nudelay(10);\r\nreturn rc;\r\n}\r\nstatic int tg3_txcpu_pause(struct tg3 *tp)\r\n{\r\nreturn tg3_pause_cpu(tp, TX_CPU_BASE);\r\n}\r\nstatic void tg3_resume_cpu(struct tg3 *tp, u32 cpu_base)\r\n{\r\ntw32(cpu_base + CPU_STATE, 0xffffffff);\r\ntw32_f(cpu_base + CPU_MODE, 0x00000000);\r\n}\r\nstatic void tg3_rxcpu_resume(struct tg3 *tp)\r\n{\r\ntg3_resume_cpu(tp, RX_CPU_BASE);\r\n}\r\nstatic int tg3_halt_cpu(struct tg3 *tp, u32 cpu_base)\r\n{\r\nint rc;\r\nBUG_ON(cpu_base == TX_CPU_BASE && tg3_flag(tp, 5705_PLUS));\r\nif (tg3_asic_rev(tp) == ASIC_REV_5906) {\r\nu32 val = tr32(GRC_VCPU_EXT_CTRL);\r\ntw32(GRC_VCPU_EXT_CTRL, val | GRC_VCPU_EXT_CTRL_HALT_CPU);\r\nreturn 0;\r\n}\r\nif (cpu_base == RX_CPU_BASE) {\r\nrc = tg3_rxcpu_pause(tp);\r\n} else {\r\nif (tg3_flag(tp, IS_SSB_CORE))\r\nreturn 0;\r\nrc = tg3_txcpu_pause(tp);\r\n}\r\nif (rc) {\r\nnetdev_err(tp->dev, "%s timed out, %s CPU\n",\r\n__func__, cpu_base == RX_CPU_BASE ? "RX" : "TX");\r\nreturn -ENODEV;\r\n}\r\nif (tg3_flag(tp, NVRAM))\r\ntw32(NVRAM_SWARB, SWARB_REQ_CLR0);\r\nreturn 0;\r\n}\r\nstatic int tg3_fw_data_len(struct tg3 *tp,\r\nconst struct tg3_firmware_hdr *fw_hdr)\r\n{\r\nint fw_len;\r\nif (tp->fw_len == 0xffffffff)\r\nfw_len = be32_to_cpu(fw_hdr->len);\r\nelse\r\nfw_len = tp->fw->size;\r\nreturn (fw_len - TG3_FW_HDR_LEN) / sizeof(u32);\r\n}\r\nstatic int tg3_load_firmware_cpu(struct tg3 *tp, u32 cpu_base,\r\nu32 cpu_scratch_base, int cpu_scratch_size,\r\nconst struct tg3_firmware_hdr *fw_hdr)\r\n{\r\nint err, i;\r\nvoid (*write_op)(struct tg3 *, u32, u32);\r\nint total_len = tp->fw->size;\r\nif (cpu_base == TX_CPU_BASE && tg3_flag(tp, 5705_PLUS)) {\r\nnetdev_err(tp->dev,\r\n"%s: Trying to load TX cpu firmware which is 5705\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (tg3_flag(tp, 5705_PLUS) && tg3_asic_rev(tp) != ASIC_REV_57766)\r\nwrite_op = tg3_write_mem;\r\nelse\r\nwrite_op = tg3_write_indirect_reg32;\r\nif (tg3_asic_rev(tp) != ASIC_REV_57766) {\r\nint lock_err = tg3_nvram_lock(tp);\r\nerr = tg3_halt_cpu(tp, cpu_base);\r\nif (!lock_err)\r\ntg3_nvram_unlock(tp);\r\nif (err)\r\ngoto out;\r\nfor (i = 0; i < cpu_scratch_size; i += sizeof(u32))\r\nwrite_op(tp, cpu_scratch_base + i, 0);\r\ntw32(cpu_base + CPU_STATE, 0xffffffff);\r\ntw32(cpu_base + CPU_MODE,\r\ntr32(cpu_base + CPU_MODE) | CPU_MODE_HALT);\r\n} else {\r\ntotal_len -= TG3_FW_HDR_LEN;\r\nfw_hdr++;\r\n}\r\ndo {\r\nu32 *fw_data = (u32 *)(fw_hdr + 1);\r\nfor (i = 0; i < tg3_fw_data_len(tp, fw_hdr); i++)\r\nwrite_op(tp, cpu_scratch_base +\r\n(be32_to_cpu(fw_hdr->base_addr) & 0xffff) +\r\n(i * sizeof(u32)),\r\nbe32_to_cpu(fw_data[i]));\r\ntotal_len -= be32_to_cpu(fw_hdr->len);\r\nfw_hdr = (struct tg3_firmware_hdr *)\r\n((void *)fw_hdr + be32_to_cpu(fw_hdr->len));\r\n} while (total_len > 0);\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int tg3_pause_cpu_and_set_pc(struct tg3 *tp, u32 cpu_base, u32 pc)\r\n{\r\nint i;\r\nconst int iters = 5;\r\ntw32(cpu_base + CPU_STATE, 0xffffffff);\r\ntw32_f(cpu_base + CPU_PC, pc);\r\nfor (i = 0; i < iters; i++) {\r\nif (tr32(cpu_base + CPU_PC) == pc)\r\nbreak;\r\ntw32(cpu_base + CPU_STATE, 0xffffffff);\r\ntw32(cpu_base + CPU_MODE, CPU_MODE_HALT);\r\ntw32_f(cpu_base + CPU_PC, pc);\r\nudelay(1000);\r\n}\r\nreturn (i == iters) ? -EBUSY : 0;\r\n}\r\nstatic int tg3_load_5701_a0_firmware_fix(struct tg3 *tp)\r\n{\r\nconst struct tg3_firmware_hdr *fw_hdr;\r\nint err;\r\nfw_hdr = (struct tg3_firmware_hdr *)tp->fw->data;\r\nerr = tg3_load_firmware_cpu(tp, RX_CPU_BASE,\r\nRX_CPU_SCRATCH_BASE, RX_CPU_SCRATCH_SIZE,\r\nfw_hdr);\r\nif (err)\r\nreturn err;\r\nerr = tg3_load_firmware_cpu(tp, TX_CPU_BASE,\r\nTX_CPU_SCRATCH_BASE, TX_CPU_SCRATCH_SIZE,\r\nfw_hdr);\r\nif (err)\r\nreturn err;\r\nerr = tg3_pause_cpu_and_set_pc(tp, RX_CPU_BASE,\r\nbe32_to_cpu(fw_hdr->base_addr));\r\nif (err) {\r\nnetdev_err(tp->dev, "%s fails to set RX CPU PC, is %08x "\r\n"should be %08x\n", __func__,\r\ntr32(RX_CPU_BASE + CPU_PC),\r\nbe32_to_cpu(fw_hdr->base_addr));\r\nreturn -ENODEV;\r\n}\r\ntg3_rxcpu_resume(tp);\r\nreturn 0;\r\n}\r\nstatic int tg3_validate_rxcpu_state(struct tg3 *tp)\r\n{\r\nconst int iters = 1000;\r\nint i;\r\nu32 val;\r\nfor (i = 0; i < iters; i++) {\r\nif (tr32(RX_CPU_HWBKPT) == TG3_SBROM_IN_SERVICE_LOOP)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (i == iters) {\r\nnetdev_err(tp->dev, "Boot code not ready for service patches\n");\r\nreturn -EBUSY;\r\n}\r\nval = tg3_read_indirect_reg32(tp, TG3_57766_FW_HANDSHAKE);\r\nif (val & 0xff) {\r\nnetdev_warn(tp->dev,\r\n"Other patches exist. Not downloading EEE patch\n");\r\nreturn -EEXIST;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tg3_load_57766_firmware(struct tg3 *tp)\r\n{\r\nstruct tg3_firmware_hdr *fw_hdr;\r\nif (!tg3_flag(tp, NO_NVRAM))\r\nreturn;\r\nif (tg3_validate_rxcpu_state(tp))\r\nreturn;\r\nif (!tp->fw)\r\nreturn;\r\nfw_hdr = (struct tg3_firmware_hdr *)tp->fw->data;\r\nif (be32_to_cpu(fw_hdr->base_addr) != TG3_57766_FW_BASE_ADDR)\r\nreturn;\r\nif (tg3_rxcpu_pause(tp))\r\nreturn;\r\ntg3_load_firmware_cpu(tp, 0, TG3_57766_FW_BASE_ADDR, 0, fw_hdr);\r\ntg3_rxcpu_resume(tp);\r\n}\r\nstatic int tg3_load_tso_firmware(struct tg3 *tp)\r\n{\r\nconst struct tg3_firmware_hdr *fw_hdr;\r\nunsigned long cpu_base, cpu_scratch_base, cpu_scratch_size;\r\nint err;\r\nif (!tg3_flag(tp, FW_TSO))\r\nreturn 0;\r\nfw_hdr = (struct tg3_firmware_hdr *)tp->fw->data;\r\ncpu_scratch_size = tp->fw_len;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5705) {\r\ncpu_base = RX_CPU_BASE;\r\ncpu_scratch_base = NIC_SRAM_MBUF_POOL_BASE5705;\r\n} else {\r\ncpu_base = TX_CPU_BASE;\r\ncpu_scratch_base = TX_CPU_SCRATCH_BASE;\r\ncpu_scratch_size = TX_CPU_SCRATCH_SIZE;\r\n}\r\nerr = tg3_load_firmware_cpu(tp, cpu_base,\r\ncpu_scratch_base, cpu_scratch_size,\r\nfw_hdr);\r\nif (err)\r\nreturn err;\r\nerr = tg3_pause_cpu_and_set_pc(tp, cpu_base,\r\nbe32_to_cpu(fw_hdr->base_addr));\r\nif (err) {\r\nnetdev_err(tp->dev,\r\n"%s fails to set CPU PC, is %08x should be %08x\n",\r\n__func__, tr32(cpu_base + CPU_PC),\r\nbe32_to_cpu(fw_hdr->base_addr));\r\nreturn -ENODEV;\r\n}\r\ntg3_resume_cpu(tp, cpu_base);\r\nreturn 0;\r\n}\r\nstatic void __tg3_set_one_mac_addr(struct tg3 *tp, u8 *mac_addr, int index)\r\n{\r\nu32 addr_high, addr_low;\r\naddr_high = ((mac_addr[0] << 8) | mac_addr[1]);\r\naddr_low = ((mac_addr[2] << 24) | (mac_addr[3] << 16) |\r\n(mac_addr[4] << 8) | mac_addr[5]);\r\nif (index < 4) {\r\ntw32(MAC_ADDR_0_HIGH + (index * 8), addr_high);\r\ntw32(MAC_ADDR_0_LOW + (index * 8), addr_low);\r\n} else {\r\nindex -= 4;\r\ntw32(MAC_EXTADDR_0_HIGH + (index * 8), addr_high);\r\ntw32(MAC_EXTADDR_0_LOW + (index * 8), addr_low);\r\n}\r\n}\r\nstatic void __tg3_set_mac_addr(struct tg3 *tp, bool skip_mac_1)\r\n{\r\nu32 addr_high;\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nif (i == 1 && skip_mac_1)\r\ncontinue;\r\n__tg3_set_one_mac_addr(tp, tp->dev->dev_addr, i);\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5703 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5704) {\r\nfor (i = 4; i < 16; i++)\r\n__tg3_set_one_mac_addr(tp, tp->dev->dev_addr, i);\r\n}\r\naddr_high = (tp->dev->dev_addr[0] +\r\ntp->dev->dev_addr[1] +\r\ntp->dev->dev_addr[2] +\r\ntp->dev->dev_addr[3] +\r\ntp->dev->dev_addr[4] +\r\ntp->dev->dev_addr[5]) &\r\nTX_BACKOFF_SEED_MASK;\r\ntw32(MAC_TX_BACKOFF_SEED, addr_high);\r\n}\r\nstatic void tg3_enable_register_access(struct tg3 *tp)\r\n{\r\npci_write_config_dword(tp->pdev,\r\nTG3PCI_MISC_HOST_CTRL, tp->misc_host_ctrl);\r\n}\r\nstatic int tg3_power_up(struct tg3 *tp)\r\n{\r\nint err;\r\ntg3_enable_register_access(tp);\r\nerr = pci_set_power_state(tp->pdev, PCI_D0);\r\nif (!err) {\r\ntg3_pwrsrc_switch_to_vmain(tp);\r\n} else {\r\nnetdev_err(tp->dev, "Transition to D0 failed\n");\r\n}\r\nreturn err;\r\n}\r\nstatic int tg3_power_down_prepare(struct tg3 *tp)\r\n{\r\nu32 misc_host_ctrl;\r\nbool device_should_wake, do_low_power;\r\ntg3_enable_register_access(tp);\r\nif (tg3_flag(tp, CLKREQ_BUG))\r\npcie_capability_set_word(tp->pdev, PCI_EXP_LNKCTL,\r\nPCI_EXP_LNKCTL_CLKREQ_EN);\r\nmisc_host_ctrl = tr32(TG3PCI_MISC_HOST_CTRL);\r\ntw32(TG3PCI_MISC_HOST_CTRL,\r\nmisc_host_ctrl | MISC_HOST_CTRL_MASK_PCI_INT);\r\ndevice_should_wake = device_may_wakeup(&tp->pdev->dev) &&\r\ntg3_flag(tp, WOL_ENABLE);\r\nif (tg3_flag(tp, USE_PHYLIB)) {\r\ndo_low_power = false;\r\nif ((tp->phy_flags & TG3_PHYFLG_IS_CONNECTED) &&\r\n!(tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER)) {\r\nstruct phy_device *phydev;\r\nu32 phyid, advertising;\r\nphydev = tp->mdio_bus->phy_map[tp->phy_addr];\r\ntp->phy_flags |= TG3_PHYFLG_IS_LOW_POWER;\r\ntp->link_config.speed = phydev->speed;\r\ntp->link_config.duplex = phydev->duplex;\r\ntp->link_config.autoneg = phydev->autoneg;\r\ntp->link_config.advertising = phydev->advertising;\r\nadvertising = ADVERTISED_TP |\r\nADVERTISED_Pause |\r\nADVERTISED_Autoneg |\r\nADVERTISED_10baseT_Half;\r\nif (tg3_flag(tp, ENABLE_ASF) || device_should_wake) {\r\nif (tg3_flag(tp, WOL_SPEED_100MB))\r\nadvertising |=\r\nADVERTISED_100baseT_Half |\r\nADVERTISED_100baseT_Full |\r\nADVERTISED_10baseT_Full;\r\nelse\r\nadvertising |= ADVERTISED_10baseT_Full;\r\n}\r\nphydev->advertising = advertising;\r\nphy_start_aneg(phydev);\r\nphyid = phydev->drv->phy_id & phydev->drv->phy_id_mask;\r\nif (phyid != PHY_ID_BCMAC131) {\r\nphyid &= PHY_BCM_OUI_MASK;\r\nif (phyid == PHY_BCM_OUI_1 ||\r\nphyid == PHY_BCM_OUI_2 ||\r\nphyid == PHY_BCM_OUI_3)\r\ndo_low_power = true;\r\n}\r\n}\r\n} else {\r\ndo_low_power = true;\r\nif (!(tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER))\r\ntp->phy_flags |= TG3_PHYFLG_IS_LOW_POWER;\r\nif (!(tp->phy_flags & TG3_PHYFLG_ANY_SERDES))\r\ntg3_setup_phy(tp, false);\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5906) {\r\nu32 val;\r\nval = tr32(GRC_VCPU_EXT_CTRL);\r\ntw32(GRC_VCPU_EXT_CTRL, val | GRC_VCPU_EXT_CTRL_DISABLE_WOL);\r\n} else if (!tg3_flag(tp, ENABLE_ASF)) {\r\nint i;\r\nu32 val;\r\nfor (i = 0; i < 200; i++) {\r\ntg3_read_mem(tp, NIC_SRAM_FW_ASF_STATUS_MBOX, &val);\r\nif (val == ~NIC_SRAM_FIRMWARE_MBOX_MAGIC1)\r\nbreak;\r\nmsleep(1);\r\n}\r\n}\r\nif (tg3_flag(tp, WOL_CAP))\r\ntg3_write_mem(tp, NIC_SRAM_WOL_MBOX, WOL_SIGNATURE |\r\nWOL_DRV_STATE_SHUTDOWN |\r\nWOL_DRV_WOL |\r\nWOL_SET_MAGIC_PKT);\r\nif (device_should_wake) {\r\nu32 mac_mode;\r\nif (!(tp->phy_flags & TG3_PHYFLG_PHY_SERDES)) {\r\nif (do_low_power &&\r\n!(tp->phy_flags & TG3_PHYFLG_IS_FET)) {\r\ntg3_phy_auxctl_write(tp,\r\nMII_TG3_AUXCTL_SHDWSEL_PWRCTL,\r\nMII_TG3_AUXCTL_PCTL_WOL_EN |\r\nMII_TG3_AUXCTL_PCTL_100TX_LPWR |\r\nMII_TG3_AUXCTL_PCTL_CL_AB_TXDAC);\r\nudelay(40);\r\n}\r\nif (tp->phy_flags & TG3_PHYFLG_MII_SERDES)\r\nmac_mode = MAC_MODE_PORT_MODE_GMII;\r\nelse if (tp->phy_flags &\r\nTG3_PHYFLG_KEEP_LINK_ON_PWRDN) {\r\nif (tp->link_config.active_speed == SPEED_1000)\r\nmac_mode = MAC_MODE_PORT_MODE_GMII;\r\nelse\r\nmac_mode = MAC_MODE_PORT_MODE_MII;\r\n} else\r\nmac_mode = MAC_MODE_PORT_MODE_MII;\r\nmac_mode |= tp->mac_mode & MAC_MODE_LINK_POLARITY;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5700) {\r\nu32 speed = tg3_flag(tp, WOL_SPEED_100MB) ?\r\nSPEED_100 : SPEED_10;\r\nif (tg3_5700_link_polarity(tp, speed))\r\nmac_mode |= MAC_MODE_LINK_POLARITY;\r\nelse\r\nmac_mode &= ~MAC_MODE_LINK_POLARITY;\r\n}\r\n} else {\r\nmac_mode = MAC_MODE_PORT_MODE_TBI;\r\n}\r\nif (!tg3_flag(tp, 5750_PLUS))\r\ntw32(MAC_LED_CTRL, tp->led_ctrl);\r\nmac_mode |= MAC_MODE_MAGIC_PKT_ENABLE;\r\nif ((tg3_flag(tp, 5705_PLUS) && !tg3_flag(tp, 5780_CLASS)) &&\r\n(tg3_flag(tp, ENABLE_ASF) || tg3_flag(tp, ENABLE_APE)))\r\nmac_mode |= MAC_MODE_KEEP_FRAME_IN_WOL;\r\nif (tg3_flag(tp, ENABLE_APE))\r\nmac_mode |= MAC_MODE_APE_TX_EN |\r\nMAC_MODE_APE_RX_EN |\r\nMAC_MODE_TDE_ENABLE;\r\ntw32_f(MAC_MODE, mac_mode);\r\nudelay(100);\r\ntw32_f(MAC_RX_MODE, RX_MODE_ENABLE);\r\nudelay(10);\r\n}\r\nif (!tg3_flag(tp, WOL_SPEED_100MB) &&\r\n(tg3_asic_rev(tp) == ASIC_REV_5700 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5701)) {\r\nu32 base_val;\r\nbase_val = tp->pci_clock_ctrl;\r\nbase_val |= (CLOCK_CTRL_RXCLK_DISABLE |\r\nCLOCK_CTRL_TXCLK_DISABLE);\r\ntw32_wait_f(TG3PCI_CLOCK_CTRL, base_val | CLOCK_CTRL_ALTCLK |\r\nCLOCK_CTRL_PWRDOWN_PLL133, 40);\r\n} else if (tg3_flag(tp, 5780_CLASS) ||\r\ntg3_flag(tp, CPMU_PRESENT) ||\r\ntg3_asic_rev(tp) == ASIC_REV_5906) {\r\n} else if (!(tg3_flag(tp, 5750_PLUS) && tg3_flag(tp, ENABLE_ASF))) {\r\nu32 newbits1, newbits2;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5700 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5701) {\r\nnewbits1 = (CLOCK_CTRL_RXCLK_DISABLE |\r\nCLOCK_CTRL_TXCLK_DISABLE |\r\nCLOCK_CTRL_ALTCLK);\r\nnewbits2 = newbits1 | CLOCK_CTRL_44MHZ_CORE;\r\n} else if (tg3_flag(tp, 5705_PLUS)) {\r\nnewbits1 = CLOCK_CTRL_625_CORE;\r\nnewbits2 = newbits1 | CLOCK_CTRL_ALTCLK;\r\n} else {\r\nnewbits1 = CLOCK_CTRL_ALTCLK;\r\nnewbits2 = newbits1 | CLOCK_CTRL_44MHZ_CORE;\r\n}\r\ntw32_wait_f(TG3PCI_CLOCK_CTRL, tp->pci_clock_ctrl | newbits1,\r\n40);\r\ntw32_wait_f(TG3PCI_CLOCK_CTRL, tp->pci_clock_ctrl | newbits2,\r\n40);\r\nif (!tg3_flag(tp, 5705_PLUS)) {\r\nu32 newbits3;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5700 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5701) {\r\nnewbits3 = (CLOCK_CTRL_RXCLK_DISABLE |\r\nCLOCK_CTRL_TXCLK_DISABLE |\r\nCLOCK_CTRL_44MHZ_CORE);\r\n} else {\r\nnewbits3 = CLOCK_CTRL_44MHZ_CORE;\r\n}\r\ntw32_wait_f(TG3PCI_CLOCK_CTRL,\r\ntp->pci_clock_ctrl | newbits3, 40);\r\n}\r\n}\r\nif (!(device_should_wake) && !tg3_flag(tp, ENABLE_ASF))\r\ntg3_power_down_phy(tp, do_low_power);\r\ntg3_frob_aux_power(tp, true);\r\nif ((!tg3_flag(tp, IS_SSB_CORE)) &&\r\n((tg3_chip_rev(tp) == CHIPREV_5750_AX) ||\r\n(tg3_chip_rev(tp) == CHIPREV_5750_BX))) {\r\nu32 val = tr32(0x7d00);\r\nval &= ~((1 << 16) | (1 << 4) | (1 << 2) | (1 << 1) | 1);\r\ntw32(0x7d00, val);\r\nif (!tg3_flag(tp, ENABLE_ASF)) {\r\nint err;\r\nerr = tg3_nvram_lock(tp);\r\ntg3_halt_cpu(tp, RX_CPU_BASE);\r\nif (!err)\r\ntg3_nvram_unlock(tp);\r\n}\r\n}\r\ntg3_write_sig_post_reset(tp, RESET_KIND_SHUTDOWN);\r\ntg3_ape_driver_state_change(tp, RESET_KIND_SHUTDOWN);\r\nreturn 0;\r\n}\r\nstatic void tg3_power_down(struct tg3 *tp)\r\n{\r\npci_wake_from_d3(tp->pdev, tg3_flag(tp, WOL_ENABLE));\r\npci_set_power_state(tp->pdev, PCI_D3hot);\r\n}\r\nstatic void tg3_aux_stat_to_speed_duplex(struct tg3 *tp, u32 val, u16 *speed, u8 *duplex)\r\n{\r\nswitch (val & MII_TG3_AUX_STAT_SPDMASK) {\r\ncase MII_TG3_AUX_STAT_10HALF:\r\n*speed = SPEED_10;\r\n*duplex = DUPLEX_HALF;\r\nbreak;\r\ncase MII_TG3_AUX_STAT_10FULL:\r\n*speed = SPEED_10;\r\n*duplex = DUPLEX_FULL;\r\nbreak;\r\ncase MII_TG3_AUX_STAT_100HALF:\r\n*speed = SPEED_100;\r\n*duplex = DUPLEX_HALF;\r\nbreak;\r\ncase MII_TG3_AUX_STAT_100FULL:\r\n*speed = SPEED_100;\r\n*duplex = DUPLEX_FULL;\r\nbreak;\r\ncase MII_TG3_AUX_STAT_1000HALF:\r\n*speed = SPEED_1000;\r\n*duplex = DUPLEX_HALF;\r\nbreak;\r\ncase MII_TG3_AUX_STAT_1000FULL:\r\n*speed = SPEED_1000;\r\n*duplex = DUPLEX_FULL;\r\nbreak;\r\ndefault:\r\nif (tp->phy_flags & TG3_PHYFLG_IS_FET) {\r\n*speed = (val & MII_TG3_AUX_STAT_100) ? SPEED_100 :\r\nSPEED_10;\r\n*duplex = (val & MII_TG3_AUX_STAT_FULL) ? DUPLEX_FULL :\r\nDUPLEX_HALF;\r\nbreak;\r\n}\r\n*speed = SPEED_UNKNOWN;\r\n*duplex = DUPLEX_UNKNOWN;\r\nbreak;\r\n}\r\n}\r\nstatic int tg3_phy_autoneg_cfg(struct tg3 *tp, u32 advertise, u32 flowctrl)\r\n{\r\nint err = 0;\r\nu32 val, new_adv;\r\nnew_adv = ADVERTISE_CSMA;\r\nnew_adv |= ethtool_adv_to_mii_adv_t(advertise) & ADVERTISE_ALL;\r\nnew_adv |= mii_advertise_flowctrl(flowctrl);\r\nerr = tg3_writephy(tp, MII_ADVERTISE, new_adv);\r\nif (err)\r\ngoto done;\r\nif (!(tp->phy_flags & TG3_PHYFLG_10_100_ONLY)) {\r\nnew_adv = ethtool_adv_to_mii_ctrl1000_t(advertise);\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5701_A0 ||\r\ntg3_chip_rev_id(tp) == CHIPREV_ID_5701_B0)\r\nnew_adv |= CTL1000_AS_MASTER | CTL1000_ENABLE_MASTER;\r\nerr = tg3_writephy(tp, MII_CTRL1000, new_adv);\r\nif (err)\r\ngoto done;\r\n}\r\nif (!(tp->phy_flags & TG3_PHYFLG_EEE_CAP))\r\ngoto done;\r\ntw32(TG3_CPMU_EEE_MODE,\r\ntr32(TG3_CPMU_EEE_MODE) & ~TG3_CPMU_EEEMD_LPI_ENABLE);\r\nerr = tg3_phy_toggle_auxctl_smdsp(tp, true);\r\nif (!err) {\r\nu32 err2;\r\nval = 0;\r\nif (advertise & ADVERTISED_100baseT_Full)\r\nval |= MDIO_AN_EEE_ADV_100TX;\r\nif (advertise & ADVERTISED_1000baseT_Full)\r\nval |= MDIO_AN_EEE_ADV_1000T;\r\nif (!tp->eee.eee_enabled) {\r\nval = 0;\r\ntp->eee.advertised = 0;\r\n} else {\r\ntp->eee.advertised = advertise &\r\n(ADVERTISED_100baseT_Full |\r\nADVERTISED_1000baseT_Full);\r\n}\r\nerr = tg3_phy_cl45_write(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV, val);\r\nif (err)\r\nval = 0;\r\nswitch (tg3_asic_rev(tp)) {\r\ncase ASIC_REV_5717:\r\ncase ASIC_REV_57765:\r\ncase ASIC_REV_57766:\r\ncase ASIC_REV_5719:\r\nif (val)\r\nval = MII_TG3_DSP_TAP26_ALNOKO |\r\nMII_TG3_DSP_TAP26_RMRXSTO |\r\nMII_TG3_DSP_TAP26_OPCSINPT;\r\ntg3_phydsp_write(tp, MII_TG3_DSP_TAP26, val);\r\ncase ASIC_REV_5720:\r\ncase ASIC_REV_5762:\r\nif (!tg3_phydsp_read(tp, MII_TG3_DSP_CH34TP2, &val))\r\ntg3_phydsp_write(tp, MII_TG3_DSP_CH34TP2, val |\r\nMII_TG3_DSP_CH34TP2_HIBW01);\r\n}\r\nerr2 = tg3_phy_toggle_auxctl_smdsp(tp, false);\r\nif (!err)\r\nerr = err2;\r\n}\r\ndone:\r\nreturn err;\r\n}\r\nstatic void tg3_phy_copper_begin(struct tg3 *tp)\r\n{\r\nif (tp->link_config.autoneg == AUTONEG_ENABLE ||\r\n(tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER)) {\r\nu32 adv, fc;\r\nif ((tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER) &&\r\n!(tp->phy_flags & TG3_PHYFLG_KEEP_LINK_ON_PWRDN)) {\r\nadv = ADVERTISED_10baseT_Half |\r\nADVERTISED_10baseT_Full;\r\nif (tg3_flag(tp, WOL_SPEED_100MB))\r\nadv |= ADVERTISED_100baseT_Half |\r\nADVERTISED_100baseT_Full;\r\nif (tp->phy_flags & TG3_PHYFLG_1G_ON_VAUX_OK) {\r\nif (!(tp->phy_flags &\r\nTG3_PHYFLG_DISABLE_1G_HD_ADV))\r\nadv |= ADVERTISED_1000baseT_Half;\r\nadv |= ADVERTISED_1000baseT_Full;\r\n}\r\nfc = FLOW_CTRL_TX | FLOW_CTRL_RX;\r\n} else {\r\nadv = tp->link_config.advertising;\r\nif (tp->phy_flags & TG3_PHYFLG_10_100_ONLY)\r\nadv &= ~(ADVERTISED_1000baseT_Half |\r\nADVERTISED_1000baseT_Full);\r\nfc = tp->link_config.flowctrl;\r\n}\r\ntg3_phy_autoneg_cfg(tp, adv, fc);\r\nif ((tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER) &&\r\n(tp->phy_flags & TG3_PHYFLG_KEEP_LINK_ON_PWRDN)) {\r\nreturn;\r\n}\r\ntg3_writephy(tp, MII_BMCR,\r\nBMCR_ANENABLE | BMCR_ANRESTART);\r\n} else {\r\nint i;\r\nu32 bmcr, orig_bmcr;\r\ntp->link_config.active_speed = tp->link_config.speed;\r\ntp->link_config.active_duplex = tp->link_config.duplex;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5714) {\r\ntg3_writephy(tp, MII_ADVERTISE, ADVERTISE_ALL);\r\n}\r\nbmcr = 0;\r\nswitch (tp->link_config.speed) {\r\ndefault:\r\ncase SPEED_10:\r\nbreak;\r\ncase SPEED_100:\r\nbmcr |= BMCR_SPEED100;\r\nbreak;\r\ncase SPEED_1000:\r\nbmcr |= BMCR_SPEED1000;\r\nbreak;\r\n}\r\nif (tp->link_config.duplex == DUPLEX_FULL)\r\nbmcr |= BMCR_FULLDPLX;\r\nif (!tg3_readphy(tp, MII_BMCR, &orig_bmcr) &&\r\n(bmcr != orig_bmcr)) {\r\ntg3_writephy(tp, MII_BMCR, BMCR_LOOPBACK);\r\nfor (i = 0; i < 1500; i++) {\r\nu32 tmp;\r\nudelay(10);\r\nif (tg3_readphy(tp, MII_BMSR, &tmp) ||\r\ntg3_readphy(tp, MII_BMSR, &tmp))\r\ncontinue;\r\nif (!(tmp & BMSR_LSTATUS)) {\r\nudelay(40);\r\nbreak;\r\n}\r\n}\r\ntg3_writephy(tp, MII_BMCR, bmcr);\r\nudelay(40);\r\n}\r\n}\r\n}\r\nstatic int tg3_phy_pull_config(struct tg3 *tp)\r\n{\r\nint err;\r\nu32 val;\r\nerr = tg3_readphy(tp, MII_BMCR, &val);\r\nif (err)\r\ngoto done;\r\nif (!(val & BMCR_ANENABLE)) {\r\ntp->link_config.autoneg = AUTONEG_DISABLE;\r\ntp->link_config.advertising = 0;\r\ntg3_flag_clear(tp, PAUSE_AUTONEG);\r\nerr = -EIO;\r\nswitch (val & (BMCR_SPEED1000 | BMCR_SPEED100)) {\r\ncase 0:\r\nif (tp->phy_flags & TG3_PHYFLG_ANY_SERDES)\r\ngoto done;\r\ntp->link_config.speed = SPEED_10;\r\nbreak;\r\ncase BMCR_SPEED100:\r\nif (tp->phy_flags & TG3_PHYFLG_ANY_SERDES)\r\ngoto done;\r\ntp->link_config.speed = SPEED_100;\r\nbreak;\r\ncase BMCR_SPEED1000:\r\nif (!(tp->phy_flags & TG3_PHYFLG_10_100_ONLY)) {\r\ntp->link_config.speed = SPEED_1000;\r\nbreak;\r\n}\r\ndefault:\r\ngoto done;\r\n}\r\nif (val & BMCR_FULLDPLX)\r\ntp->link_config.duplex = DUPLEX_FULL;\r\nelse\r\ntp->link_config.duplex = DUPLEX_HALF;\r\ntp->link_config.flowctrl = FLOW_CTRL_RX | FLOW_CTRL_TX;\r\nerr = 0;\r\ngoto done;\r\n}\r\ntp->link_config.autoneg = AUTONEG_ENABLE;\r\ntp->link_config.advertising = ADVERTISED_Autoneg;\r\ntg3_flag_set(tp, PAUSE_AUTONEG);\r\nif (!(tp->phy_flags & TG3_PHYFLG_ANY_SERDES)) {\r\nu32 adv;\r\nerr = tg3_readphy(tp, MII_ADVERTISE, &val);\r\nif (err)\r\ngoto done;\r\nadv = mii_adv_to_ethtool_adv_t(val & ADVERTISE_ALL);\r\ntp->link_config.advertising |= adv | ADVERTISED_TP;\r\ntp->link_config.flowctrl = tg3_decode_flowctrl_1000T(val);\r\n} else {\r\ntp->link_config.advertising |= ADVERTISED_FIBRE;\r\n}\r\nif (!(tp->phy_flags & TG3_PHYFLG_10_100_ONLY)) {\r\nu32 adv;\r\nif (!(tp->phy_flags & TG3_PHYFLG_ANY_SERDES)) {\r\nerr = tg3_readphy(tp, MII_CTRL1000, &val);\r\nif (err)\r\ngoto done;\r\nadv = mii_ctrl1000_to_ethtool_adv_t(val);\r\n} else {\r\nerr = tg3_readphy(tp, MII_ADVERTISE, &val);\r\nif (err)\r\ngoto done;\r\nadv = tg3_decode_flowctrl_1000X(val);\r\ntp->link_config.flowctrl = adv;\r\nval &= (ADVERTISE_1000XHALF | ADVERTISE_1000XFULL);\r\nadv = mii_adv_to_ethtool_adv_x(val);\r\n}\r\ntp->link_config.advertising |= adv;\r\n}\r\ndone:\r\nreturn err;\r\n}\r\nstatic int tg3_init_5401phy_dsp(struct tg3 *tp)\r\n{\r\nint err;\r\nerr = tg3_phy_auxctl_write(tp, MII_TG3_AUXCTL_SHDWSEL_AUXCTL, 0x4c20);\r\nerr |= tg3_phydsp_write(tp, 0x0012, 0x1804);\r\nerr |= tg3_phydsp_write(tp, 0x0013, 0x1204);\r\nerr |= tg3_phydsp_write(tp, 0x8006, 0x0132);\r\nerr |= tg3_phydsp_write(tp, 0x8006, 0x0232);\r\nerr |= tg3_phydsp_write(tp, 0x201f, 0x0a20);\r\nudelay(40);\r\nreturn err;\r\n}\r\nstatic bool tg3_phy_eee_config_ok(struct tg3 *tp)\r\n{\r\nstruct ethtool_eee eee;\r\nif (!(tp->phy_flags & TG3_PHYFLG_EEE_CAP))\r\nreturn true;\r\ntg3_eee_pull_config(tp, &eee);\r\nif (tp->eee.eee_enabled) {\r\nif (tp->eee.advertised != eee.advertised ||\r\ntp->eee.tx_lpi_timer != eee.tx_lpi_timer ||\r\ntp->eee.tx_lpi_enabled != eee.tx_lpi_enabled)\r\nreturn false;\r\n} else {\r\nif (eee.advertised)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool tg3_phy_copper_an_config_ok(struct tg3 *tp, u32 *lcladv)\r\n{\r\nu32 advmsk, tgtadv, advertising;\r\nadvertising = tp->link_config.advertising;\r\ntgtadv = ethtool_adv_to_mii_adv_t(advertising) & ADVERTISE_ALL;\r\nadvmsk = ADVERTISE_ALL;\r\nif (tp->link_config.active_duplex == DUPLEX_FULL) {\r\ntgtadv |= mii_advertise_flowctrl(tp->link_config.flowctrl);\r\nadvmsk |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;\r\n}\r\nif (tg3_readphy(tp, MII_ADVERTISE, lcladv))\r\nreturn false;\r\nif ((*lcladv & advmsk) != tgtadv)\r\nreturn false;\r\nif (!(tp->phy_flags & TG3_PHYFLG_10_100_ONLY)) {\r\nu32 tg3_ctrl;\r\ntgtadv = ethtool_adv_to_mii_ctrl1000_t(advertising);\r\nif (tg3_readphy(tp, MII_CTRL1000, &tg3_ctrl))\r\nreturn false;\r\nif (tgtadv &&\r\n(tg3_chip_rev_id(tp) == CHIPREV_ID_5701_A0 ||\r\ntg3_chip_rev_id(tp) == CHIPREV_ID_5701_B0)) {\r\ntgtadv |= CTL1000_AS_MASTER | CTL1000_ENABLE_MASTER;\r\ntg3_ctrl &= (ADVERTISE_1000HALF | ADVERTISE_1000FULL |\r\nCTL1000_AS_MASTER | CTL1000_ENABLE_MASTER);\r\n} else {\r\ntg3_ctrl &= (ADVERTISE_1000HALF | ADVERTISE_1000FULL);\r\n}\r\nif (tg3_ctrl != tgtadv)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool tg3_phy_copper_fetch_rmtadv(struct tg3 *tp, u32 *rmtadv)\r\n{\r\nu32 lpeth = 0;\r\nif (!(tp->phy_flags & TG3_PHYFLG_10_100_ONLY)) {\r\nu32 val;\r\nif (tg3_readphy(tp, MII_STAT1000, &val))\r\nreturn false;\r\nlpeth = mii_stat1000_to_ethtool_lpa_t(val);\r\n}\r\nif (tg3_readphy(tp, MII_LPA, rmtadv))\r\nreturn false;\r\nlpeth |= mii_lpa_to_ethtool_lpa_t(*rmtadv);\r\ntp->link_config.rmt_adv = lpeth;\r\nreturn true;\r\n}\r\nstatic bool tg3_test_and_report_link_chg(struct tg3 *tp, bool curr_link_up)\r\n{\r\nif (curr_link_up != tp->link_up) {\r\nif (curr_link_up) {\r\nnetif_carrier_on(tp->dev);\r\n} else {\r\nnetif_carrier_off(tp->dev);\r\nif (tp->phy_flags & TG3_PHYFLG_MII_SERDES)\r\ntp->phy_flags &= ~TG3_PHYFLG_PARALLEL_DETECT;\r\n}\r\ntg3_link_report(tp);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void tg3_clear_mac_status(struct tg3 *tp)\r\n{\r\ntw32(MAC_EVENT, 0);\r\ntw32_f(MAC_STATUS,\r\nMAC_STATUS_SYNC_CHANGED |\r\nMAC_STATUS_CFG_CHANGED |\r\nMAC_STATUS_MI_COMPLETION |\r\nMAC_STATUS_LNKSTATE_CHANGED);\r\nudelay(40);\r\n}\r\nstatic void tg3_setup_eee(struct tg3 *tp)\r\n{\r\nu32 val;\r\nval = TG3_CPMU_EEE_LNKIDL_PCIE_NL0 |\r\nTG3_CPMU_EEE_LNKIDL_UART_IDL;\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_57765_A0)\r\nval |= TG3_CPMU_EEE_LNKIDL_APE_TX_MT;\r\ntw32_f(TG3_CPMU_EEE_LNKIDL_CTRL, val);\r\ntw32_f(TG3_CPMU_EEE_CTRL,\r\nTG3_CPMU_EEE_CTRL_EXIT_20_1_US);\r\nval = TG3_CPMU_EEEMD_ERLY_L1_XIT_DET |\r\n(tp->eee.tx_lpi_enabled ? TG3_CPMU_EEEMD_LPI_IN_TX : 0) |\r\nTG3_CPMU_EEEMD_LPI_IN_RX |\r\nTG3_CPMU_EEEMD_EEE_ENABLE;\r\nif (tg3_asic_rev(tp) != ASIC_REV_5717)\r\nval |= TG3_CPMU_EEEMD_SND_IDX_DET_EN;\r\nif (tg3_flag(tp, ENABLE_APE))\r\nval |= TG3_CPMU_EEEMD_APE_TX_DET_EN;\r\ntw32_f(TG3_CPMU_EEE_MODE, tp->eee.eee_enabled ? val : 0);\r\ntw32_f(TG3_CPMU_EEE_DBTMR1,\r\nTG3_CPMU_DBTMR1_PCIEXIT_2047US |\r\n(tp->eee.tx_lpi_timer & 0xffff));\r\ntw32_f(TG3_CPMU_EEE_DBTMR2,\r\nTG3_CPMU_DBTMR2_APE_TX_2047US |\r\nTG3_CPMU_DBTMR2_TXIDXEQ_2047US);\r\n}\r\nstatic int tg3_setup_copper_phy(struct tg3 *tp, bool force_reset)\r\n{\r\nbool current_link_up;\r\nu32 bmsr, val;\r\nu32 lcl_adv, rmt_adv;\r\nu16 current_speed;\r\nu8 current_duplex;\r\nint i, err;\r\ntg3_clear_mac_status(tp);\r\nif ((tp->mi_mode & MAC_MI_MODE_AUTO_POLL) != 0) {\r\ntw32_f(MAC_MI_MODE,\r\n(tp->mi_mode & ~MAC_MI_MODE_AUTO_POLL));\r\nudelay(80);\r\n}\r\ntg3_phy_auxctl_write(tp, MII_TG3_AUXCTL_SHDWSEL_PWRCTL, 0);\r\nif ((tg3_asic_rev(tp) == ASIC_REV_5703 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5704 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5705) &&\r\ntp->link_up) {\r\ntg3_readphy(tp, MII_BMSR, &bmsr);\r\nif (!tg3_readphy(tp, MII_BMSR, &bmsr) &&\r\n!(bmsr & BMSR_LSTATUS))\r\nforce_reset = true;\r\n}\r\nif (force_reset)\r\ntg3_phy_reset(tp);\r\nif ((tp->phy_id & TG3_PHY_ID_MASK) == TG3_PHY_ID_BCM5401) {\r\ntg3_readphy(tp, MII_BMSR, &bmsr);\r\nif (tg3_readphy(tp, MII_BMSR, &bmsr) ||\r\n!tg3_flag(tp, INIT_COMPLETE))\r\nbmsr = 0;\r\nif (!(bmsr & BMSR_LSTATUS)) {\r\nerr = tg3_init_5401phy_dsp(tp);\r\nif (err)\r\nreturn err;\r\ntg3_readphy(tp, MII_BMSR, &bmsr);\r\nfor (i = 0; i < 1000; i++) {\r\nudelay(10);\r\nif (!tg3_readphy(tp, MII_BMSR, &bmsr) &&\r\n(bmsr & BMSR_LSTATUS)) {\r\nudelay(40);\r\nbreak;\r\n}\r\n}\r\nif ((tp->phy_id & TG3_PHY_ID_REV_MASK) ==\r\nTG3_PHY_REV_BCM5401_B0 &&\r\n!(bmsr & BMSR_LSTATUS) &&\r\ntp->link_config.active_speed == SPEED_1000) {\r\nerr = tg3_phy_reset(tp);\r\nif (!err)\r\nerr = tg3_init_5401phy_dsp(tp);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\n} else if (tg3_chip_rev_id(tp) == CHIPREV_ID_5701_A0 ||\r\ntg3_chip_rev_id(tp) == CHIPREV_ID_5701_B0) {\r\ntg3_writephy(tp, 0x15, 0x0a75);\r\ntg3_writephy(tp, MII_TG3_MISC_SHDW, 0x8c68);\r\ntg3_writephy(tp, MII_TG3_MISC_SHDW, 0x8d68);\r\ntg3_writephy(tp, MII_TG3_MISC_SHDW, 0x8c68);\r\n}\r\ntg3_readphy(tp, MII_TG3_ISTAT, &val);\r\ntg3_readphy(tp, MII_TG3_ISTAT, &val);\r\nif (tp->phy_flags & TG3_PHYFLG_USE_MI_INTERRUPT)\r\ntg3_writephy(tp, MII_TG3_IMASK, ~MII_TG3_INT_LINKCHG);\r\nelse if (!(tp->phy_flags & TG3_PHYFLG_IS_FET))\r\ntg3_writephy(tp, MII_TG3_IMASK, ~0);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5700 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5701) {\r\nif (tp->led_ctrl == LED_CTRL_MODE_PHY_1)\r\ntg3_writephy(tp, MII_TG3_EXT_CTRL,\r\nMII_TG3_EXT_CTRL_LNK3_LED_MODE);\r\nelse\r\ntg3_writephy(tp, MII_TG3_EXT_CTRL, 0);\r\n}\r\ncurrent_link_up = false;\r\ncurrent_speed = SPEED_UNKNOWN;\r\ncurrent_duplex = DUPLEX_UNKNOWN;\r\ntp->phy_flags &= ~TG3_PHYFLG_MDIX_STATE;\r\ntp->link_config.rmt_adv = 0;\r\nif (tp->phy_flags & TG3_PHYFLG_CAPACITIVE_COUPLING) {\r\nerr = tg3_phy_auxctl_read(tp,\r\nMII_TG3_AUXCTL_SHDWSEL_MISCTEST,\r\n&val);\r\nif (!err && !(val & (1 << 10))) {\r\ntg3_phy_auxctl_write(tp,\r\nMII_TG3_AUXCTL_SHDWSEL_MISCTEST,\r\nval | (1 << 10));\r\ngoto relink;\r\n}\r\n}\r\nbmsr = 0;\r\nfor (i = 0; i < 100; i++) {\r\ntg3_readphy(tp, MII_BMSR, &bmsr);\r\nif (!tg3_readphy(tp, MII_BMSR, &bmsr) &&\r\n(bmsr & BMSR_LSTATUS))\r\nbreak;\r\nudelay(40);\r\n}\r\nif (bmsr & BMSR_LSTATUS) {\r\nu32 aux_stat, bmcr;\r\ntg3_readphy(tp, MII_TG3_AUX_STAT, &aux_stat);\r\nfor (i = 0; i < 2000; i++) {\r\nudelay(10);\r\nif (!tg3_readphy(tp, MII_TG3_AUX_STAT, &aux_stat) &&\r\naux_stat)\r\nbreak;\r\n}\r\ntg3_aux_stat_to_speed_duplex(tp, aux_stat,\r\n&current_speed,\r\n&current_duplex);\r\nbmcr = 0;\r\nfor (i = 0; i < 200; i++) {\r\ntg3_readphy(tp, MII_BMCR, &bmcr);\r\nif (tg3_readphy(tp, MII_BMCR, &bmcr))\r\ncontinue;\r\nif (bmcr && bmcr != 0x7fff)\r\nbreak;\r\nudelay(10);\r\n}\r\nlcl_adv = 0;\r\nrmt_adv = 0;\r\ntp->link_config.active_speed = current_speed;\r\ntp->link_config.active_duplex = current_duplex;\r\nif (tp->link_config.autoneg == AUTONEG_ENABLE) {\r\nbool eee_config_ok = tg3_phy_eee_config_ok(tp);\r\nif ((bmcr & BMCR_ANENABLE) &&\r\neee_config_ok &&\r\ntg3_phy_copper_an_config_ok(tp, &lcl_adv) &&\r\ntg3_phy_copper_fetch_rmtadv(tp, &rmt_adv))\r\ncurrent_link_up = true;\r\nif (!eee_config_ok &&\r\n(tp->phy_flags & TG3_PHYFLG_KEEP_LINK_ON_PWRDN) &&\r\n!force_reset) {\r\ntg3_setup_eee(tp);\r\ntg3_phy_reset(tp);\r\n}\r\n} else {\r\nif (!(bmcr & BMCR_ANENABLE) &&\r\ntp->link_config.speed == current_speed &&\r\ntp->link_config.duplex == current_duplex) {\r\ncurrent_link_up = true;\r\n}\r\n}\r\nif (current_link_up &&\r\ntp->link_config.active_duplex == DUPLEX_FULL) {\r\nu32 reg, bit;\r\nif (tp->phy_flags & TG3_PHYFLG_IS_FET) {\r\nreg = MII_TG3_FET_GEN_STAT;\r\nbit = MII_TG3_FET_GEN_STAT_MDIXSTAT;\r\n} else {\r\nreg = MII_TG3_EXT_STAT;\r\nbit = MII_TG3_EXT_STAT_MDIX;\r\n}\r\nif (!tg3_readphy(tp, reg, &val) && (val & bit))\r\ntp->phy_flags |= TG3_PHYFLG_MDIX_STATE;\r\ntg3_setup_flow_control(tp, lcl_adv, rmt_adv);\r\n}\r\n}\r\nrelink:\r\nif (!current_link_up || (tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER)) {\r\ntg3_phy_copper_begin(tp);\r\nif (tg3_flag(tp, ROBOSWITCH)) {\r\ncurrent_link_up = true;\r\ncurrent_speed = SPEED_1000;\r\ncurrent_duplex = DUPLEX_FULL;\r\ntp->link_config.active_speed = current_speed;\r\ntp->link_config.active_duplex = current_duplex;\r\n}\r\ntg3_readphy(tp, MII_BMSR, &bmsr);\r\nif ((!tg3_readphy(tp, MII_BMSR, &bmsr) && (bmsr & BMSR_LSTATUS)) ||\r\n(tp->mac_mode & MAC_MODE_PORT_INT_LPBACK))\r\ncurrent_link_up = true;\r\n}\r\ntp->mac_mode &= ~MAC_MODE_PORT_MODE_MASK;\r\nif (current_link_up) {\r\nif (tp->link_config.active_speed == SPEED_100 ||\r\ntp->link_config.active_speed == SPEED_10)\r\ntp->mac_mode |= MAC_MODE_PORT_MODE_MII;\r\nelse\r\ntp->mac_mode |= MAC_MODE_PORT_MODE_GMII;\r\n} else if (tp->phy_flags & TG3_PHYFLG_IS_FET)\r\ntp->mac_mode |= MAC_MODE_PORT_MODE_MII;\r\nelse\r\ntp->mac_mode |= MAC_MODE_PORT_MODE_GMII;\r\nif (tg3_flag(tp, RGMII_MODE)) {\r\nu32 led_ctrl = tr32(MAC_LED_CTRL);\r\nled_ctrl &= ~(LED_CTRL_1000MBPS_ON | LED_CTRL_100MBPS_ON);\r\nif (tp->link_config.active_speed == SPEED_10)\r\nled_ctrl |= LED_CTRL_LNKLED_OVERRIDE;\r\nelse if (tp->link_config.active_speed == SPEED_100)\r\nled_ctrl |= (LED_CTRL_LNKLED_OVERRIDE |\r\nLED_CTRL_100MBPS_ON);\r\nelse if (tp->link_config.active_speed == SPEED_1000)\r\nled_ctrl |= (LED_CTRL_LNKLED_OVERRIDE |\r\nLED_CTRL_1000MBPS_ON);\r\ntw32(MAC_LED_CTRL, led_ctrl);\r\nudelay(40);\r\n}\r\ntp->mac_mode &= ~MAC_MODE_HALF_DUPLEX;\r\nif (tp->link_config.active_duplex == DUPLEX_HALF)\r\ntp->mac_mode |= MAC_MODE_HALF_DUPLEX;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5700) {\r\nif (current_link_up &&\r\ntg3_5700_link_polarity(tp, tp->link_config.active_speed))\r\ntp->mac_mode |= MAC_MODE_LINK_POLARITY;\r\nelse\r\ntp->mac_mode &= ~MAC_MODE_LINK_POLARITY;\r\n}\r\nif ((tp->phy_id & TG3_PHY_ID_MASK) == TG3_PHY_ID_BCM5411 &&\r\ntg3_chip_rev_id(tp) == CHIPREV_ID_5700_ALTIMA) {\r\ntp->mi_mode |= MAC_MI_MODE_AUTO_POLL;\r\ntw32_f(MAC_MI_MODE, tp->mi_mode);\r\nudelay(80);\r\n}\r\ntw32_f(MAC_MODE, tp->mac_mode);\r\nudelay(40);\r\ntg3_phy_eee_adjust(tp, current_link_up);\r\nif (tg3_flag(tp, USE_LINKCHG_REG)) {\r\ntw32_f(MAC_EVENT, 0);\r\n} else {\r\ntw32_f(MAC_EVENT, MAC_EVENT_LNKSTATE_CHANGED);\r\n}\r\nudelay(40);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5700 &&\r\ncurrent_link_up &&\r\ntp->link_config.active_speed == SPEED_1000 &&\r\n(tg3_flag(tp, PCIX_MODE) || tg3_flag(tp, PCI_HIGH_SPEED))) {\r\nudelay(120);\r\ntw32_f(MAC_STATUS,\r\n(MAC_STATUS_SYNC_CHANGED |\r\nMAC_STATUS_CFG_CHANGED));\r\nudelay(40);\r\ntg3_write_mem(tp,\r\nNIC_SRAM_FIRMWARE_MBOX,\r\nNIC_SRAM_FIRMWARE_MBOX_MAGIC2);\r\n}\r\nif (tg3_flag(tp, CLKREQ_BUG)) {\r\nif (tp->link_config.active_speed == SPEED_100 ||\r\ntp->link_config.active_speed == SPEED_10)\r\npcie_capability_clear_word(tp->pdev, PCI_EXP_LNKCTL,\r\nPCI_EXP_LNKCTL_CLKREQ_EN);\r\nelse\r\npcie_capability_set_word(tp->pdev, PCI_EXP_LNKCTL,\r\nPCI_EXP_LNKCTL_CLKREQ_EN);\r\n}\r\ntg3_test_and_report_link_chg(tp, current_link_up);\r\nreturn 0;\r\n}\r\nstatic int tg3_fiber_aneg_smachine(struct tg3 *tp,\r\nstruct tg3_fiber_aneginfo *ap)\r\n{\r\nu16 flowctrl;\r\nunsigned long delta;\r\nu32 rx_cfg_reg;\r\nint ret;\r\nif (ap->state == ANEG_STATE_UNKNOWN) {\r\nap->rxconfig = 0;\r\nap->link_time = 0;\r\nap->cur_time = 0;\r\nap->ability_match_cfg = 0;\r\nap->ability_match_count = 0;\r\nap->ability_match = 0;\r\nap->idle_match = 0;\r\nap->ack_match = 0;\r\n}\r\nap->cur_time++;\r\nif (tr32(MAC_STATUS) & MAC_STATUS_RCVD_CFG) {\r\nrx_cfg_reg = tr32(MAC_RX_AUTO_NEG);\r\nif (rx_cfg_reg != ap->ability_match_cfg) {\r\nap->ability_match_cfg = rx_cfg_reg;\r\nap->ability_match = 0;\r\nap->ability_match_count = 0;\r\n} else {\r\nif (++ap->ability_match_count > 1) {\r\nap->ability_match = 1;\r\nap->ability_match_cfg = rx_cfg_reg;\r\n}\r\n}\r\nif (rx_cfg_reg & ANEG_CFG_ACK)\r\nap->ack_match = 1;\r\nelse\r\nap->ack_match = 0;\r\nap->idle_match = 0;\r\n} else {\r\nap->idle_match = 1;\r\nap->ability_match_cfg = 0;\r\nap->ability_match_count = 0;\r\nap->ability_match = 0;\r\nap->ack_match = 0;\r\nrx_cfg_reg = 0;\r\n}\r\nap->rxconfig = rx_cfg_reg;\r\nret = ANEG_OK;\r\nswitch (ap->state) {\r\ncase ANEG_STATE_UNKNOWN:\r\nif (ap->flags & (MR_AN_ENABLE | MR_RESTART_AN))\r\nap->state = ANEG_STATE_AN_ENABLE;\r\ncase ANEG_STATE_AN_ENABLE:\r\nap->flags &= ~(MR_AN_COMPLETE | MR_PAGE_RX);\r\nif (ap->flags & MR_AN_ENABLE) {\r\nap->link_time = 0;\r\nap->cur_time = 0;\r\nap->ability_match_cfg = 0;\r\nap->ability_match_count = 0;\r\nap->ability_match = 0;\r\nap->idle_match = 0;\r\nap->ack_match = 0;\r\nap->state = ANEG_STATE_RESTART_INIT;\r\n} else {\r\nap->state = ANEG_STATE_DISABLE_LINK_OK;\r\n}\r\nbreak;\r\ncase ANEG_STATE_RESTART_INIT:\r\nap->link_time = ap->cur_time;\r\nap->flags &= ~(MR_NP_LOADED);\r\nap->txconfig = 0;\r\ntw32(MAC_TX_AUTO_NEG, 0);\r\ntp->mac_mode |= MAC_MODE_SEND_CONFIGS;\r\ntw32_f(MAC_MODE, tp->mac_mode);\r\nudelay(40);\r\nret = ANEG_TIMER_ENAB;\r\nap->state = ANEG_STATE_RESTART;\r\ncase ANEG_STATE_RESTART:\r\ndelta = ap->cur_time - ap->link_time;\r\nif (delta > ANEG_STATE_SETTLE_TIME)\r\nap->state = ANEG_STATE_ABILITY_DETECT_INIT;\r\nelse\r\nret = ANEG_TIMER_ENAB;\r\nbreak;\r\ncase ANEG_STATE_DISABLE_LINK_OK:\r\nret = ANEG_DONE;\r\nbreak;\r\ncase ANEG_STATE_ABILITY_DETECT_INIT:\r\nap->flags &= ~(MR_TOGGLE_TX);\r\nap->txconfig = ANEG_CFG_FD;\r\nflowctrl = tg3_advert_flowctrl_1000X(tp->link_config.flowctrl);\r\nif (flowctrl & ADVERTISE_1000XPAUSE)\r\nap->txconfig |= ANEG_CFG_PS1;\r\nif (flowctrl & ADVERTISE_1000XPSE_ASYM)\r\nap->txconfig |= ANEG_CFG_PS2;\r\ntw32(MAC_TX_AUTO_NEG, ap->txconfig);\r\ntp->mac_mode |= MAC_MODE_SEND_CONFIGS;\r\ntw32_f(MAC_MODE, tp->mac_mode);\r\nudelay(40);\r\nap->state = ANEG_STATE_ABILITY_DETECT;\r\nbreak;\r\ncase ANEG_STATE_ABILITY_DETECT:\r\nif (ap->ability_match != 0 && ap->rxconfig != 0)\r\nap->state = ANEG_STATE_ACK_DETECT_INIT;\r\nbreak;\r\ncase ANEG_STATE_ACK_DETECT_INIT:\r\nap->txconfig |= ANEG_CFG_ACK;\r\ntw32(MAC_TX_AUTO_NEG, ap->txconfig);\r\ntp->mac_mode |= MAC_MODE_SEND_CONFIGS;\r\ntw32_f(MAC_MODE, tp->mac_mode);\r\nudelay(40);\r\nap->state = ANEG_STATE_ACK_DETECT;\r\ncase ANEG_STATE_ACK_DETECT:\r\nif (ap->ack_match != 0) {\r\nif ((ap->rxconfig & ~ANEG_CFG_ACK) ==\r\n(ap->ability_match_cfg & ~ANEG_CFG_ACK)) {\r\nap->state = ANEG_STATE_COMPLETE_ACK_INIT;\r\n} else {\r\nap->state = ANEG_STATE_AN_ENABLE;\r\n}\r\n} else if (ap->ability_match != 0 &&\r\nap->rxconfig == 0) {\r\nap->state = ANEG_STATE_AN_ENABLE;\r\n}\r\nbreak;\r\ncase ANEG_STATE_COMPLETE_ACK_INIT:\r\nif (ap->rxconfig & ANEG_CFG_INVAL) {\r\nret = ANEG_FAILED;\r\nbreak;\r\n}\r\nap->flags &= ~(MR_LP_ADV_FULL_DUPLEX |\r\nMR_LP_ADV_HALF_DUPLEX |\r\nMR_LP_ADV_SYM_PAUSE |\r\nMR_LP_ADV_ASYM_PAUSE |\r\nMR_LP_ADV_REMOTE_FAULT1 |\r\nMR_LP_ADV_REMOTE_FAULT2 |\r\nMR_LP_ADV_NEXT_PAGE |\r\nMR_TOGGLE_RX |\r\nMR_NP_RX);\r\nif (ap->rxconfig & ANEG_CFG_FD)\r\nap->flags |= MR_LP_ADV_FULL_DUPLEX;\r\nif (ap->rxconfig & ANEG_CFG_HD)\r\nap->flags |= MR_LP_ADV_HALF_DUPLEX;\r\nif (ap->rxconfig & ANEG_CFG_PS1)\r\nap->flags |= MR_LP_ADV_SYM_PAUSE;\r\nif (ap->rxconfig & ANEG_CFG_PS2)\r\nap->flags |= MR_LP_ADV_ASYM_PAUSE;\r\nif (ap->rxconfig & ANEG_CFG_RF1)\r\nap->flags |= MR_LP_ADV_REMOTE_FAULT1;\r\nif (ap->rxconfig & ANEG_CFG_RF2)\r\nap->flags |= MR_LP_ADV_REMOTE_FAULT2;\r\nif (ap->rxconfig & ANEG_CFG_NP)\r\nap->flags |= MR_LP_ADV_NEXT_PAGE;\r\nap->link_time = ap->cur_time;\r\nap->flags ^= (MR_TOGGLE_TX);\r\nif (ap->rxconfig & 0x0008)\r\nap->flags |= MR_TOGGLE_RX;\r\nif (ap->rxconfig & ANEG_CFG_NP)\r\nap->flags |= MR_NP_RX;\r\nap->flags |= MR_PAGE_RX;\r\nap->state = ANEG_STATE_COMPLETE_ACK;\r\nret = ANEG_TIMER_ENAB;\r\nbreak;\r\ncase ANEG_STATE_COMPLETE_ACK:\r\nif (ap->ability_match != 0 &&\r\nap->rxconfig == 0) {\r\nap->state = ANEG_STATE_AN_ENABLE;\r\nbreak;\r\n}\r\ndelta = ap->cur_time - ap->link_time;\r\nif (delta > ANEG_STATE_SETTLE_TIME) {\r\nif (!(ap->flags & (MR_LP_ADV_NEXT_PAGE))) {\r\nap->state = ANEG_STATE_IDLE_DETECT_INIT;\r\n} else {\r\nif ((ap->txconfig & ANEG_CFG_NP) == 0 &&\r\n!(ap->flags & MR_NP_RX)) {\r\nap->state = ANEG_STATE_IDLE_DETECT_INIT;\r\n} else {\r\nret = ANEG_FAILED;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase ANEG_STATE_IDLE_DETECT_INIT:\r\nap->link_time = ap->cur_time;\r\ntp->mac_mode &= ~MAC_MODE_SEND_CONFIGS;\r\ntw32_f(MAC_MODE, tp->mac_mode);\r\nudelay(40);\r\nap->state = ANEG_STATE_IDLE_DETECT;\r\nret = ANEG_TIMER_ENAB;\r\nbreak;\r\ncase ANEG_STATE_IDLE_DETECT:\r\nif (ap->ability_match != 0 &&\r\nap->rxconfig == 0) {\r\nap->state = ANEG_STATE_AN_ENABLE;\r\nbreak;\r\n}\r\ndelta = ap->cur_time - ap->link_time;\r\nif (delta > ANEG_STATE_SETTLE_TIME) {\r\nap->state = ANEG_STATE_LINK_OK;\r\n}\r\nbreak;\r\ncase ANEG_STATE_LINK_OK:\r\nap->flags |= (MR_AN_COMPLETE | MR_LINK_OK);\r\nret = ANEG_DONE;\r\nbreak;\r\ncase ANEG_STATE_NEXT_PAGE_WAIT_INIT:\r\nbreak;\r\ncase ANEG_STATE_NEXT_PAGE_WAIT:\r\nbreak;\r\ndefault:\r\nret = ANEG_FAILED;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int fiber_autoneg(struct tg3 *tp, u32 *txflags, u32 *rxflags)\r\n{\r\nint res = 0;\r\nstruct tg3_fiber_aneginfo aninfo;\r\nint status = ANEG_FAILED;\r\nunsigned int tick;\r\nu32 tmp;\r\ntw32_f(MAC_TX_AUTO_NEG, 0);\r\ntmp = tp->mac_mode & ~MAC_MODE_PORT_MODE_MASK;\r\ntw32_f(MAC_MODE, tmp | MAC_MODE_PORT_MODE_GMII);\r\nudelay(40);\r\ntw32_f(MAC_MODE, tp->mac_mode | MAC_MODE_SEND_CONFIGS);\r\nudelay(40);\r\nmemset(&aninfo, 0, sizeof(aninfo));\r\naninfo.flags |= MR_AN_ENABLE;\r\naninfo.state = ANEG_STATE_UNKNOWN;\r\naninfo.cur_time = 0;\r\ntick = 0;\r\nwhile (++tick < 195000) {\r\nstatus = tg3_fiber_aneg_smachine(tp, &aninfo);\r\nif (status == ANEG_DONE || status == ANEG_FAILED)\r\nbreak;\r\nudelay(1);\r\n}\r\ntp->mac_mode &= ~MAC_MODE_SEND_CONFIGS;\r\ntw32_f(MAC_MODE, tp->mac_mode);\r\nudelay(40);\r\n*txflags = aninfo.txconfig;\r\n*rxflags = aninfo.flags;\r\nif (status == ANEG_DONE &&\r\n(aninfo.flags & (MR_AN_COMPLETE | MR_LINK_OK |\r\nMR_LP_ADV_FULL_DUPLEX)))\r\nres = 1;\r\nreturn res;\r\n}\r\nstatic void tg3_init_bcm8002(struct tg3 *tp)\r\n{\r\nu32 mac_status = tr32(MAC_STATUS);\r\nint i;\r\nif (tg3_flag(tp, INIT_COMPLETE) &&\r\n!(mac_status & MAC_STATUS_PCS_SYNCED))\r\nreturn;\r\ntg3_writephy(tp, 0x16, 0x8007);\r\ntg3_writephy(tp, MII_BMCR, BMCR_RESET);\r\nfor (i = 0; i < 500; i++)\r\nudelay(10);\r\ntg3_writephy(tp, 0x10, 0x8411);\r\ntg3_writephy(tp, 0x11, 0x0a10);\r\ntg3_writephy(tp, 0x18, 0x00a0);\r\ntg3_writephy(tp, 0x16, 0x41ff);\r\ntg3_writephy(tp, 0x13, 0x0400);\r\nudelay(40);\r\ntg3_writephy(tp, 0x13, 0x0000);\r\ntg3_writephy(tp, 0x11, 0x0a50);\r\nudelay(40);\r\ntg3_writephy(tp, 0x11, 0x0a10);\r\nfor (i = 0; i < 15000; i++)\r\nudelay(10);\r\ntg3_writephy(tp, 0x10, 0x8011);\r\n}\r\nstatic bool tg3_setup_fiber_hw_autoneg(struct tg3 *tp, u32 mac_status)\r\n{\r\nu16 flowctrl;\r\nbool current_link_up;\r\nu32 sg_dig_ctrl, sg_dig_status;\r\nu32 serdes_cfg, expected_sg_dig_ctrl;\r\nint workaround, port_a;\r\nserdes_cfg = 0;\r\nexpected_sg_dig_ctrl = 0;\r\nworkaround = 0;\r\nport_a = 1;\r\ncurrent_link_up = false;\r\nif (tg3_chip_rev_id(tp) != CHIPREV_ID_5704_A0 &&\r\ntg3_chip_rev_id(tp) != CHIPREV_ID_5704_A1) {\r\nworkaround = 1;\r\nif (tr32(TG3PCI_DUAL_MAC_CTRL) & DUAL_MAC_CTRL_ID)\r\nport_a = 0;\r\nserdes_cfg = tr32(MAC_SERDES_CFG) & 0x00f06fff;\r\n}\r\nsg_dig_ctrl = tr32(SG_DIG_CTRL);\r\nif (tp->link_config.autoneg != AUTONEG_ENABLE) {\r\nif (sg_dig_ctrl & SG_DIG_USING_HW_AUTONEG) {\r\nif (workaround) {\r\nu32 val = serdes_cfg;\r\nif (port_a)\r\nval |= 0xc010000;\r\nelse\r\nval |= 0x4010000;\r\ntw32_f(MAC_SERDES_CFG, val);\r\n}\r\ntw32_f(SG_DIG_CTRL, SG_DIG_COMMON_SETUP);\r\n}\r\nif (mac_status & MAC_STATUS_PCS_SYNCED) {\r\ntg3_setup_flow_control(tp, 0, 0);\r\ncurrent_link_up = true;\r\n}\r\ngoto out;\r\n}\r\nexpected_sg_dig_ctrl = SG_DIG_USING_HW_AUTONEG | SG_DIG_COMMON_SETUP;\r\nflowctrl = tg3_advert_flowctrl_1000X(tp->link_config.flowctrl);\r\nif (flowctrl & ADVERTISE_1000XPAUSE)\r\nexpected_sg_dig_ctrl |= SG_DIG_PAUSE_CAP;\r\nif (flowctrl & ADVERTISE_1000XPSE_ASYM)\r\nexpected_sg_dig_ctrl |= SG_DIG_ASYM_PAUSE;\r\nif (sg_dig_ctrl != expected_sg_dig_ctrl) {\r\nif ((tp->phy_flags & TG3_PHYFLG_PARALLEL_DETECT) &&\r\ntp->serdes_counter &&\r\n((mac_status & (MAC_STATUS_PCS_SYNCED |\r\nMAC_STATUS_RCVD_CFG)) ==\r\nMAC_STATUS_PCS_SYNCED)) {\r\ntp->serdes_counter--;\r\ncurrent_link_up = true;\r\ngoto out;\r\n}\r\nrestart_autoneg:\r\nif (workaround)\r\ntw32_f(MAC_SERDES_CFG, serdes_cfg | 0xc011000);\r\ntw32_f(SG_DIG_CTRL, expected_sg_dig_ctrl | SG_DIG_SOFT_RESET);\r\nudelay(5);\r\ntw32_f(SG_DIG_CTRL, expected_sg_dig_ctrl);\r\ntp->serdes_counter = SERDES_AN_TIMEOUT_5704S;\r\ntp->phy_flags &= ~TG3_PHYFLG_PARALLEL_DETECT;\r\n} else if (mac_status & (MAC_STATUS_PCS_SYNCED |\r\nMAC_STATUS_SIGNAL_DET)) {\r\nsg_dig_status = tr32(SG_DIG_STATUS);\r\nmac_status = tr32(MAC_STATUS);\r\nif ((sg_dig_status & SG_DIG_AUTONEG_COMPLETE) &&\r\n(mac_status & MAC_STATUS_PCS_SYNCED)) {\r\nu32 local_adv = 0, remote_adv = 0;\r\nif (sg_dig_ctrl & SG_DIG_PAUSE_CAP)\r\nlocal_adv |= ADVERTISE_1000XPAUSE;\r\nif (sg_dig_ctrl & SG_DIG_ASYM_PAUSE)\r\nlocal_adv |= ADVERTISE_1000XPSE_ASYM;\r\nif (sg_dig_status & SG_DIG_PARTNER_PAUSE_CAPABLE)\r\nremote_adv |= LPA_1000XPAUSE;\r\nif (sg_dig_status & SG_DIG_PARTNER_ASYM_PAUSE)\r\nremote_adv |= LPA_1000XPAUSE_ASYM;\r\ntp->link_config.rmt_adv =\r\nmii_adv_to_ethtool_adv_x(remote_adv);\r\ntg3_setup_flow_control(tp, local_adv, remote_adv);\r\ncurrent_link_up = true;\r\ntp->serdes_counter = 0;\r\ntp->phy_flags &= ~TG3_PHYFLG_PARALLEL_DETECT;\r\n} else if (!(sg_dig_status & SG_DIG_AUTONEG_COMPLETE)) {\r\nif (tp->serdes_counter)\r\ntp->serdes_counter--;\r\nelse {\r\nif (workaround) {\r\nu32 val = serdes_cfg;\r\nif (port_a)\r\nval |= 0xc010000;\r\nelse\r\nval |= 0x4010000;\r\ntw32_f(MAC_SERDES_CFG, val);\r\n}\r\ntw32_f(SG_DIG_CTRL, SG_DIG_COMMON_SETUP);\r\nudelay(40);\r\nmac_status = tr32(MAC_STATUS);\r\nif ((mac_status & MAC_STATUS_PCS_SYNCED) &&\r\n!(mac_status & MAC_STATUS_RCVD_CFG)) {\r\ntg3_setup_flow_control(tp, 0, 0);\r\ncurrent_link_up = true;\r\ntp->phy_flags |=\r\nTG3_PHYFLG_PARALLEL_DETECT;\r\ntp->serdes_counter =\r\nSERDES_PARALLEL_DET_TIMEOUT;\r\n} else\r\ngoto restart_autoneg;\r\n}\r\n}\r\n} else {\r\ntp->serdes_counter = SERDES_AN_TIMEOUT_5704S;\r\ntp->phy_flags &= ~TG3_PHYFLG_PARALLEL_DETECT;\r\n}\r\nout:\r\nreturn current_link_up;\r\n}\r\nstatic bool tg3_setup_fiber_by_hand(struct tg3 *tp, u32 mac_status)\r\n{\r\nbool current_link_up = false;\r\nif (!(mac_status & MAC_STATUS_PCS_SYNCED))\r\ngoto out;\r\nif (tp->link_config.autoneg == AUTONEG_ENABLE) {\r\nu32 txflags, rxflags;\r\nint i;\r\nif (fiber_autoneg(tp, &txflags, &rxflags)) {\r\nu32 local_adv = 0, remote_adv = 0;\r\nif (txflags & ANEG_CFG_PS1)\r\nlocal_adv |= ADVERTISE_1000XPAUSE;\r\nif (txflags & ANEG_CFG_PS2)\r\nlocal_adv |= ADVERTISE_1000XPSE_ASYM;\r\nif (rxflags & MR_LP_ADV_SYM_PAUSE)\r\nremote_adv |= LPA_1000XPAUSE;\r\nif (rxflags & MR_LP_ADV_ASYM_PAUSE)\r\nremote_adv |= LPA_1000XPAUSE_ASYM;\r\ntp->link_config.rmt_adv =\r\nmii_adv_to_ethtool_adv_x(remote_adv);\r\ntg3_setup_flow_control(tp, local_adv, remote_adv);\r\ncurrent_link_up = true;\r\n}\r\nfor (i = 0; i < 30; i++) {\r\nudelay(20);\r\ntw32_f(MAC_STATUS,\r\n(MAC_STATUS_SYNC_CHANGED |\r\nMAC_STATUS_CFG_CHANGED));\r\nudelay(40);\r\nif ((tr32(MAC_STATUS) &\r\n(MAC_STATUS_SYNC_CHANGED |\r\nMAC_STATUS_CFG_CHANGED)) == 0)\r\nbreak;\r\n}\r\nmac_status = tr32(MAC_STATUS);\r\nif (!current_link_up &&\r\n(mac_status & MAC_STATUS_PCS_SYNCED) &&\r\n!(mac_status & MAC_STATUS_RCVD_CFG))\r\ncurrent_link_up = true;\r\n} else {\r\ntg3_setup_flow_control(tp, 0, 0);\r\ncurrent_link_up = true;\r\ntw32_f(MAC_MODE, (tp->mac_mode | MAC_MODE_SEND_CONFIGS));\r\nudelay(40);\r\ntw32_f(MAC_MODE, tp->mac_mode);\r\nudelay(40);\r\n}\r\nout:\r\nreturn current_link_up;\r\n}\r\nstatic int tg3_setup_fiber_phy(struct tg3 *tp, bool force_reset)\r\n{\r\nu32 orig_pause_cfg;\r\nu16 orig_active_speed;\r\nu8 orig_active_duplex;\r\nu32 mac_status;\r\nbool current_link_up;\r\nint i;\r\norig_pause_cfg = tp->link_config.active_flowctrl;\r\norig_active_speed = tp->link_config.active_speed;\r\norig_active_duplex = tp->link_config.active_duplex;\r\nif (!tg3_flag(tp, HW_AUTONEG) &&\r\ntp->link_up &&\r\ntg3_flag(tp, INIT_COMPLETE)) {\r\nmac_status = tr32(MAC_STATUS);\r\nmac_status &= (MAC_STATUS_PCS_SYNCED |\r\nMAC_STATUS_SIGNAL_DET |\r\nMAC_STATUS_CFG_CHANGED |\r\nMAC_STATUS_RCVD_CFG);\r\nif (mac_status == (MAC_STATUS_PCS_SYNCED |\r\nMAC_STATUS_SIGNAL_DET)) {\r\ntw32_f(MAC_STATUS, (MAC_STATUS_SYNC_CHANGED |\r\nMAC_STATUS_CFG_CHANGED));\r\nreturn 0;\r\n}\r\n}\r\ntw32_f(MAC_TX_AUTO_NEG, 0);\r\ntp->mac_mode &= ~(MAC_MODE_PORT_MODE_MASK | MAC_MODE_HALF_DUPLEX);\r\ntp->mac_mode |= MAC_MODE_PORT_MODE_TBI;\r\ntw32_f(MAC_MODE, tp->mac_mode);\r\nudelay(40);\r\nif (tp->phy_id == TG3_PHY_ID_BCM8002)\r\ntg3_init_bcm8002(tp);\r\ntw32_f(MAC_EVENT, MAC_EVENT_LNKSTATE_CHANGED);\r\nudelay(40);\r\ncurrent_link_up = false;\r\ntp->link_config.rmt_adv = 0;\r\nmac_status = tr32(MAC_STATUS);\r\nif (tg3_flag(tp, HW_AUTONEG))\r\ncurrent_link_up = tg3_setup_fiber_hw_autoneg(tp, mac_status);\r\nelse\r\ncurrent_link_up = tg3_setup_fiber_by_hand(tp, mac_status);\r\ntp->napi[0].hw_status->status =\r\n(SD_STATUS_UPDATED |\r\n(tp->napi[0].hw_status->status & ~SD_STATUS_LINK_CHG));\r\nfor (i = 0; i < 100; i++) {\r\ntw32_f(MAC_STATUS, (MAC_STATUS_SYNC_CHANGED |\r\nMAC_STATUS_CFG_CHANGED));\r\nudelay(5);\r\nif ((tr32(MAC_STATUS) & (MAC_STATUS_SYNC_CHANGED |\r\nMAC_STATUS_CFG_CHANGED |\r\nMAC_STATUS_LNKSTATE_CHANGED)) == 0)\r\nbreak;\r\n}\r\nmac_status = tr32(MAC_STATUS);\r\nif ((mac_status & MAC_STATUS_PCS_SYNCED) == 0) {\r\ncurrent_link_up = false;\r\nif (tp->link_config.autoneg == AUTONEG_ENABLE &&\r\ntp->serdes_counter == 0) {\r\ntw32_f(MAC_MODE, (tp->mac_mode |\r\nMAC_MODE_SEND_CONFIGS));\r\nudelay(1);\r\ntw32_f(MAC_MODE, tp->mac_mode);\r\n}\r\n}\r\nif (current_link_up) {\r\ntp->link_config.active_speed = SPEED_1000;\r\ntp->link_config.active_duplex = DUPLEX_FULL;\r\ntw32(MAC_LED_CTRL, (tp->led_ctrl |\r\nLED_CTRL_LNKLED_OVERRIDE |\r\nLED_CTRL_1000MBPS_ON));\r\n} else {\r\ntp->link_config.active_speed = SPEED_UNKNOWN;\r\ntp->link_config.active_duplex = DUPLEX_UNKNOWN;\r\ntw32(MAC_LED_CTRL, (tp->led_ctrl |\r\nLED_CTRL_LNKLED_OVERRIDE |\r\nLED_CTRL_TRAFFIC_OVERRIDE));\r\n}\r\nif (!tg3_test_and_report_link_chg(tp, current_link_up)) {\r\nu32 now_pause_cfg = tp->link_config.active_flowctrl;\r\nif (orig_pause_cfg != now_pause_cfg ||\r\norig_active_speed != tp->link_config.active_speed ||\r\norig_active_duplex != tp->link_config.active_duplex)\r\ntg3_link_report(tp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tg3_setup_fiber_mii_phy(struct tg3 *tp, bool force_reset)\r\n{\r\nint err = 0;\r\nu32 bmsr, bmcr;\r\nu16 current_speed = SPEED_UNKNOWN;\r\nu8 current_duplex = DUPLEX_UNKNOWN;\r\nbool current_link_up = false;\r\nu32 local_adv, remote_adv, sgsr;\r\nif ((tg3_asic_rev(tp) == ASIC_REV_5719 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5720) &&\r\n!tg3_readphy(tp, SERDES_TG3_1000X_STATUS, &sgsr) &&\r\n(sgsr & SERDES_TG3_SGMII_MODE)) {\r\nif (force_reset)\r\ntg3_phy_reset(tp);\r\ntp->mac_mode &= ~MAC_MODE_PORT_MODE_MASK;\r\nif (!(sgsr & SERDES_TG3_LINK_UP)) {\r\ntp->mac_mode |= MAC_MODE_PORT_MODE_GMII;\r\n} else {\r\ncurrent_link_up = true;\r\nif (sgsr & SERDES_TG3_SPEED_1000) {\r\ncurrent_speed = SPEED_1000;\r\ntp->mac_mode |= MAC_MODE_PORT_MODE_GMII;\r\n} else if (sgsr & SERDES_TG3_SPEED_100) {\r\ncurrent_speed = SPEED_100;\r\ntp->mac_mode |= MAC_MODE_PORT_MODE_MII;\r\n} else {\r\ncurrent_speed = SPEED_10;\r\ntp->mac_mode |= MAC_MODE_PORT_MODE_MII;\r\n}\r\nif (sgsr & SERDES_TG3_FULL_DUPLEX)\r\ncurrent_duplex = DUPLEX_FULL;\r\nelse\r\ncurrent_duplex = DUPLEX_HALF;\r\n}\r\ntw32_f(MAC_MODE, tp->mac_mode);\r\nudelay(40);\r\ntg3_clear_mac_status(tp);\r\ngoto fiber_setup_done;\r\n}\r\ntp->mac_mode |= MAC_MODE_PORT_MODE_GMII;\r\ntw32_f(MAC_MODE, tp->mac_mode);\r\nudelay(40);\r\ntg3_clear_mac_status(tp);\r\nif (force_reset)\r\ntg3_phy_reset(tp);\r\ntp->link_config.rmt_adv = 0;\r\nerr |= tg3_readphy(tp, MII_BMSR, &bmsr);\r\nerr |= tg3_readphy(tp, MII_BMSR, &bmsr);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5714) {\r\nif (tr32(MAC_TX_STATUS) & TX_STATUS_LINK_UP)\r\nbmsr |= BMSR_LSTATUS;\r\nelse\r\nbmsr &= ~BMSR_LSTATUS;\r\n}\r\nerr |= tg3_readphy(tp, MII_BMCR, &bmcr);\r\nif ((tp->link_config.autoneg == AUTONEG_ENABLE) && !force_reset &&\r\n(tp->phy_flags & TG3_PHYFLG_PARALLEL_DETECT)) {\r\n} else if (tp->link_config.autoneg == AUTONEG_ENABLE) {\r\nu32 adv, newadv;\r\nerr |= tg3_readphy(tp, MII_ADVERTISE, &adv);\r\nnewadv = adv & ~(ADVERTISE_1000XFULL | ADVERTISE_1000XHALF |\r\nADVERTISE_1000XPAUSE |\r\nADVERTISE_1000XPSE_ASYM |\r\nADVERTISE_SLCT);\r\nnewadv |= tg3_advert_flowctrl_1000X(tp->link_config.flowctrl);\r\nnewadv |= ethtool_adv_to_mii_adv_x(tp->link_config.advertising);\r\nif ((newadv != adv) || !(bmcr & BMCR_ANENABLE)) {\r\ntg3_writephy(tp, MII_ADVERTISE, newadv);\r\nbmcr |= BMCR_ANENABLE | BMCR_ANRESTART;\r\ntg3_writephy(tp, MII_BMCR, bmcr);\r\ntw32_f(MAC_EVENT, MAC_EVENT_LNKSTATE_CHANGED);\r\ntp->serdes_counter = SERDES_AN_TIMEOUT_5714S;\r\ntp->phy_flags &= ~TG3_PHYFLG_PARALLEL_DETECT;\r\nreturn err;\r\n}\r\n} else {\r\nu32 new_bmcr;\r\nbmcr &= ~BMCR_SPEED1000;\r\nnew_bmcr = bmcr & ~(BMCR_ANENABLE | BMCR_FULLDPLX);\r\nif (tp->link_config.duplex == DUPLEX_FULL)\r\nnew_bmcr |= BMCR_FULLDPLX;\r\nif (new_bmcr != bmcr) {\r\nnew_bmcr |= BMCR_SPEED1000;\r\nif (tp->link_up) {\r\nu32 adv;\r\nerr |= tg3_readphy(tp, MII_ADVERTISE, &adv);\r\nadv &= ~(ADVERTISE_1000XFULL |\r\nADVERTISE_1000XHALF |\r\nADVERTISE_SLCT);\r\ntg3_writephy(tp, MII_ADVERTISE, adv);\r\ntg3_writephy(tp, MII_BMCR, bmcr |\r\nBMCR_ANRESTART |\r\nBMCR_ANENABLE);\r\nudelay(10);\r\ntg3_carrier_off(tp);\r\n}\r\ntg3_writephy(tp, MII_BMCR, new_bmcr);\r\nbmcr = new_bmcr;\r\nerr |= tg3_readphy(tp, MII_BMSR, &bmsr);\r\nerr |= tg3_readphy(tp, MII_BMSR, &bmsr);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5714) {\r\nif (tr32(MAC_TX_STATUS) & TX_STATUS_LINK_UP)\r\nbmsr |= BMSR_LSTATUS;\r\nelse\r\nbmsr &= ~BMSR_LSTATUS;\r\n}\r\ntp->phy_flags &= ~TG3_PHYFLG_PARALLEL_DETECT;\r\n}\r\n}\r\nif (bmsr & BMSR_LSTATUS) {\r\ncurrent_speed = SPEED_1000;\r\ncurrent_link_up = true;\r\nif (bmcr & BMCR_FULLDPLX)\r\ncurrent_duplex = DUPLEX_FULL;\r\nelse\r\ncurrent_duplex = DUPLEX_HALF;\r\nlocal_adv = 0;\r\nremote_adv = 0;\r\nif (bmcr & BMCR_ANENABLE) {\r\nu32 common;\r\nerr |= tg3_readphy(tp, MII_ADVERTISE, &local_adv);\r\nerr |= tg3_readphy(tp, MII_LPA, &remote_adv);\r\ncommon = local_adv & remote_adv;\r\nif (common & (ADVERTISE_1000XHALF |\r\nADVERTISE_1000XFULL)) {\r\nif (common & ADVERTISE_1000XFULL)\r\ncurrent_duplex = DUPLEX_FULL;\r\nelse\r\ncurrent_duplex = DUPLEX_HALF;\r\ntp->link_config.rmt_adv =\r\nmii_adv_to_ethtool_adv_x(remote_adv);\r\n} else if (!tg3_flag(tp, 5780_CLASS)) {\r\n} else {\r\ncurrent_link_up = false;\r\n}\r\n}\r\n}\r\nfiber_setup_done:\r\nif (current_link_up && current_duplex == DUPLEX_FULL)\r\ntg3_setup_flow_control(tp, local_adv, remote_adv);\r\ntp->mac_mode &= ~MAC_MODE_HALF_DUPLEX;\r\nif (tp->link_config.active_duplex == DUPLEX_HALF)\r\ntp->mac_mode |= MAC_MODE_HALF_DUPLEX;\r\ntw32_f(MAC_MODE, tp->mac_mode);\r\nudelay(40);\r\ntw32_f(MAC_EVENT, MAC_EVENT_LNKSTATE_CHANGED);\r\ntp->link_config.active_speed = current_speed;\r\ntp->link_config.active_duplex = current_duplex;\r\ntg3_test_and_report_link_chg(tp, current_link_up);\r\nreturn err;\r\n}\r\nstatic void tg3_serdes_parallel_detect(struct tg3 *tp)\r\n{\r\nif (tp->serdes_counter) {\r\ntp->serdes_counter--;\r\nreturn;\r\n}\r\nif (!tp->link_up &&\r\n(tp->link_config.autoneg == AUTONEG_ENABLE)) {\r\nu32 bmcr;\r\ntg3_readphy(tp, MII_BMCR, &bmcr);\r\nif (bmcr & BMCR_ANENABLE) {\r\nu32 phy1, phy2;\r\ntg3_writephy(tp, MII_TG3_MISC_SHDW, 0x7c00);\r\ntg3_readphy(tp, MII_TG3_MISC_SHDW, &phy1);\r\ntg3_writephy(tp, MII_TG3_DSP_ADDRESS,\r\nMII_TG3_DSP_EXP1_INT_STAT);\r\ntg3_readphy(tp, MII_TG3_DSP_RW_PORT, &phy2);\r\ntg3_readphy(tp, MII_TG3_DSP_RW_PORT, &phy2);\r\nif ((phy1 & 0x10) && !(phy2 & 0x20)) {\r\nbmcr &= ~BMCR_ANENABLE;\r\nbmcr |= BMCR_SPEED1000 | BMCR_FULLDPLX;\r\ntg3_writephy(tp, MII_BMCR, bmcr);\r\ntp->phy_flags |= TG3_PHYFLG_PARALLEL_DETECT;\r\n}\r\n}\r\n} else if (tp->link_up &&\r\n(tp->link_config.autoneg == AUTONEG_ENABLE) &&\r\n(tp->phy_flags & TG3_PHYFLG_PARALLEL_DETECT)) {\r\nu32 phy2;\r\ntg3_writephy(tp, MII_TG3_DSP_ADDRESS,\r\nMII_TG3_DSP_EXP1_INT_STAT);\r\ntg3_readphy(tp, MII_TG3_DSP_RW_PORT, &phy2);\r\nif (phy2 & 0x20) {\r\nu32 bmcr;\r\ntg3_readphy(tp, MII_BMCR, &bmcr);\r\ntg3_writephy(tp, MII_BMCR, bmcr | BMCR_ANENABLE);\r\ntp->phy_flags &= ~TG3_PHYFLG_PARALLEL_DETECT;\r\n}\r\n}\r\n}\r\nstatic int tg3_setup_phy(struct tg3 *tp, bool force_reset)\r\n{\r\nu32 val;\r\nint err;\r\nif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES)\r\nerr = tg3_setup_fiber_phy(tp, force_reset);\r\nelse if (tp->phy_flags & TG3_PHYFLG_MII_SERDES)\r\nerr = tg3_setup_fiber_mii_phy(tp, force_reset);\r\nelse\r\nerr = tg3_setup_copper_phy(tp, force_reset);\r\nif (tg3_chip_rev(tp) == CHIPREV_5784_AX) {\r\nu32 scale;\r\nval = tr32(TG3_CPMU_CLCK_STAT) & CPMU_CLCK_STAT_MAC_CLCK_MASK;\r\nif (val == CPMU_CLCK_STAT_MAC_CLCK_62_5)\r\nscale = 65;\r\nelse if (val == CPMU_CLCK_STAT_MAC_CLCK_6_25)\r\nscale = 6;\r\nelse\r\nscale = 12;\r\nval = tr32(GRC_MISC_CFG) & ~GRC_MISC_CFG_PRESCALAR_MASK;\r\nval |= (scale << GRC_MISC_CFG_PRESCALAR_SHIFT);\r\ntw32(GRC_MISC_CFG, val);\r\n}\r\nval = (2 << TX_LENGTHS_IPG_CRS_SHIFT) |\r\n(6 << TX_LENGTHS_IPG_SHIFT);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5720 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5762)\r\nval |= tr32(MAC_TX_LENGTHS) &\r\n(TX_LENGTHS_JMB_FRM_LEN_MSK |\r\nTX_LENGTHS_CNT_DWN_VAL_MSK);\r\nif (tp->link_config.active_speed == SPEED_1000 &&\r\ntp->link_config.active_duplex == DUPLEX_HALF)\r\ntw32(MAC_TX_LENGTHS, val |\r\n(0xff << TX_LENGTHS_SLOT_TIME_SHIFT));\r\nelse\r\ntw32(MAC_TX_LENGTHS, val |\r\n(32 << TX_LENGTHS_SLOT_TIME_SHIFT));\r\nif (!tg3_flag(tp, 5705_PLUS)) {\r\nif (tp->link_up) {\r\ntw32(HOSTCC_STAT_COAL_TICKS,\r\ntp->coal.stats_block_coalesce_usecs);\r\n} else {\r\ntw32(HOSTCC_STAT_COAL_TICKS, 0);\r\n}\r\n}\r\nif (tg3_flag(tp, ASPM_WORKAROUND)) {\r\nval = tr32(PCIE_PWR_MGMT_THRESH);\r\nif (!tp->link_up)\r\nval = (val & ~PCIE_PWR_MGMT_L1_THRESH_MSK) |\r\ntp->pwrmgmt_thresh;\r\nelse\r\nval |= PCIE_PWR_MGMT_L1_THRESH_MSK;\r\ntw32(PCIE_PWR_MGMT_THRESH, val);\r\n}\r\nreturn err;\r\n}\r\nstatic u64 tg3_refclk_read(struct tg3 *tp)\r\n{\r\nu64 stamp = tr32(TG3_EAV_REF_CLCK_LSB);\r\nreturn stamp | (u64)tr32(TG3_EAV_REF_CLCK_MSB) << 32;\r\n}\r\nstatic void tg3_refclk_write(struct tg3 *tp, u64 newval)\r\n{\r\nu32 clock_ctl = tr32(TG3_EAV_REF_CLCK_CTL);\r\ntw32(TG3_EAV_REF_CLCK_CTL, clock_ctl | TG3_EAV_REF_CLCK_CTL_STOP);\r\ntw32(TG3_EAV_REF_CLCK_LSB, newval & 0xffffffff);\r\ntw32(TG3_EAV_REF_CLCK_MSB, newval >> 32);\r\ntw32_f(TG3_EAV_REF_CLCK_CTL, clock_ctl | TG3_EAV_REF_CLCK_CTL_RESUME);\r\n}\r\nstatic int tg3_get_ts_info(struct net_device *dev, struct ethtool_ts_info *info)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\ninfo->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\r\nSOF_TIMESTAMPING_RX_SOFTWARE |\r\nSOF_TIMESTAMPING_SOFTWARE;\r\nif (tg3_flag(tp, PTP_CAPABLE)) {\r\ninfo->so_timestamping |= SOF_TIMESTAMPING_TX_HARDWARE |\r\nSOF_TIMESTAMPING_RX_HARDWARE |\r\nSOF_TIMESTAMPING_RAW_HARDWARE;\r\n}\r\nif (tp->ptp_clock)\r\ninfo->phc_index = ptp_clock_index(tp->ptp_clock);\r\nelse\r\ninfo->phc_index = -1;\r\ninfo->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);\r\ninfo->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\r\n(1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT);\r\nreturn 0;\r\n}\r\nstatic int tg3_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nstruct tg3 *tp = container_of(ptp, struct tg3, ptp_info);\r\nbool neg_adj = false;\r\nu32 correction = 0;\r\nif (ppb < 0) {\r\nneg_adj = true;\r\nppb = -ppb;\r\n}\r\ncorrection = div_u64((u64)ppb * (1 << 24), 1000000000ULL) &\r\nTG3_EAV_REF_CLK_CORRECT_MASK;\r\ntg3_full_lock(tp, 0);\r\nif (correction)\r\ntw32(TG3_EAV_REF_CLK_CORRECT_CTL,\r\nTG3_EAV_REF_CLK_CORRECT_EN |\r\n(neg_adj ? TG3_EAV_REF_CLK_CORRECT_NEG : 0) | correction);\r\nelse\r\ntw32(TG3_EAV_REF_CLK_CORRECT_CTL, 0);\r\ntg3_full_unlock(tp);\r\nreturn 0;\r\n}\r\nstatic int tg3_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct tg3 *tp = container_of(ptp, struct tg3, ptp_info);\r\ntg3_full_lock(tp, 0);\r\ntp->ptp_adjust += delta;\r\ntg3_full_unlock(tp);\r\nreturn 0;\r\n}\r\nstatic int tg3_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\r\n{\r\nu64 ns;\r\nstruct tg3 *tp = container_of(ptp, struct tg3, ptp_info);\r\ntg3_full_lock(tp, 0);\r\nns = tg3_refclk_read(tp);\r\nns += tp->ptp_adjust;\r\ntg3_full_unlock(tp);\r\n*ts = ns_to_timespec64(ns);\r\nreturn 0;\r\n}\r\nstatic int tg3_ptp_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nu64 ns;\r\nstruct tg3 *tp = container_of(ptp, struct tg3, ptp_info);\r\nns = timespec64_to_ns(ts);\r\ntg3_full_lock(tp, 0);\r\ntg3_refclk_write(tp, ns);\r\ntp->ptp_adjust = 0;\r\ntg3_full_unlock(tp);\r\nreturn 0;\r\n}\r\nstatic int tg3_ptp_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq, int on)\r\n{\r\nstruct tg3 *tp = container_of(ptp, struct tg3, ptp_info);\r\nu32 clock_ctl;\r\nint rval = 0;\r\nswitch (rq->type) {\r\ncase PTP_CLK_REQ_PEROUT:\r\nif (rq->perout.index != 0)\r\nreturn -EINVAL;\r\ntg3_full_lock(tp, 0);\r\nclock_ctl = tr32(TG3_EAV_REF_CLCK_CTL);\r\nclock_ctl &= ~TG3_EAV_CTL_TSYNC_GPIO_MASK;\r\nif (on) {\r\nu64 nsec;\r\nnsec = rq->perout.start.sec * 1000000000ULL +\r\nrq->perout.start.nsec;\r\nif (rq->perout.period.sec || rq->perout.period.nsec) {\r\nnetdev_warn(tp->dev,\r\n"Device supports only a one-shot timesync output, period must be 0\n");\r\nrval = -EINVAL;\r\ngoto err_out;\r\n}\r\nif (nsec & (1ULL << 63)) {\r\nnetdev_warn(tp->dev,\r\n"Start value (nsec) is over limit. Maximum size of start is only 63 bits\n");\r\nrval = -EINVAL;\r\ngoto err_out;\r\n}\r\ntw32(TG3_EAV_WATCHDOG0_LSB, (nsec & 0xffffffff));\r\ntw32(TG3_EAV_WATCHDOG0_MSB,\r\nTG3_EAV_WATCHDOG0_EN |\r\n((nsec >> 32) & TG3_EAV_WATCHDOG_MSB_MASK));\r\ntw32(TG3_EAV_REF_CLCK_CTL,\r\nclock_ctl | TG3_EAV_CTL_TSYNC_WDOG0);\r\n} else {\r\ntw32(TG3_EAV_WATCHDOG0_MSB, 0);\r\ntw32(TG3_EAV_REF_CLCK_CTL, clock_ctl);\r\n}\r\nerr_out:\r\ntg3_full_unlock(tp);\r\nreturn rval;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void tg3_hwclock_to_timestamp(struct tg3 *tp, u64 hwclock,\r\nstruct skb_shared_hwtstamps *timestamp)\r\n{\r\nmemset(timestamp, 0, sizeof(struct skb_shared_hwtstamps));\r\ntimestamp->hwtstamp = ns_to_ktime((hwclock & TG3_TSTAMP_MASK) +\r\ntp->ptp_adjust);\r\n}\r\nstatic void tg3_ptp_init(struct tg3 *tp)\r\n{\r\nif (!tg3_flag(tp, PTP_CAPABLE))\r\nreturn;\r\ntg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));\r\ntp->ptp_adjust = 0;\r\ntp->ptp_info = tg3_ptp_caps;\r\n}\r\nstatic void tg3_ptp_resume(struct tg3 *tp)\r\n{\r\nif (!tg3_flag(tp, PTP_CAPABLE))\r\nreturn;\r\ntg3_refclk_write(tp, ktime_to_ns(ktime_get_real()) + tp->ptp_adjust);\r\ntp->ptp_adjust = 0;\r\n}\r\nstatic void tg3_ptp_fini(struct tg3 *tp)\r\n{\r\nif (!tg3_flag(tp, PTP_CAPABLE) || !tp->ptp_clock)\r\nreturn;\r\nptp_clock_unregister(tp->ptp_clock);\r\ntp->ptp_clock = NULL;\r\ntp->ptp_adjust = 0;\r\n}\r\nstatic inline int tg3_irq_sync(struct tg3 *tp)\r\n{\r\nreturn tp->irq_sync;\r\n}\r\nstatic inline void tg3_rd32_loop(struct tg3 *tp, u32 *dst, u32 off, u32 len)\r\n{\r\nint i;\r\ndst = (u32 *)((u8 *)dst + off);\r\nfor (i = 0; i < len; i += sizeof(u32))\r\n*dst++ = tr32(off + i);\r\n}\r\nstatic void tg3_dump_legacy_regs(struct tg3 *tp, u32 *regs)\r\n{\r\ntg3_rd32_loop(tp, regs, TG3PCI_VENDOR, 0xb0);\r\ntg3_rd32_loop(tp, regs, MAILBOX_INTERRUPT_0, 0x200);\r\ntg3_rd32_loop(tp, regs, MAC_MODE, 0x4f0);\r\ntg3_rd32_loop(tp, regs, SNDDATAI_MODE, 0xe0);\r\ntg3_rd32_loop(tp, regs, SNDDATAC_MODE, 0x04);\r\ntg3_rd32_loop(tp, regs, SNDBDS_MODE, 0x80);\r\ntg3_rd32_loop(tp, regs, SNDBDI_MODE, 0x48);\r\ntg3_rd32_loop(tp, regs, SNDBDC_MODE, 0x04);\r\ntg3_rd32_loop(tp, regs, RCVLPC_MODE, 0x20);\r\ntg3_rd32_loop(tp, regs, RCVLPC_SELLST_BASE, 0x15c);\r\ntg3_rd32_loop(tp, regs, RCVDBDI_MODE, 0x0c);\r\ntg3_rd32_loop(tp, regs, RCVDBDI_JUMBO_BD, 0x3c);\r\ntg3_rd32_loop(tp, regs, RCVDBDI_BD_PROD_IDX_0, 0x44);\r\ntg3_rd32_loop(tp, regs, RCVDCC_MODE, 0x04);\r\ntg3_rd32_loop(tp, regs, RCVBDI_MODE, 0x20);\r\ntg3_rd32_loop(tp, regs, RCVCC_MODE, 0x14);\r\ntg3_rd32_loop(tp, regs, RCVLSC_MODE, 0x08);\r\ntg3_rd32_loop(tp, regs, MBFREE_MODE, 0x08);\r\ntg3_rd32_loop(tp, regs, HOSTCC_MODE, 0x100);\r\nif (tg3_flag(tp, SUPPORT_MSIX))\r\ntg3_rd32_loop(tp, regs, HOSTCC_RXCOL_TICKS_VEC1, 0x180);\r\ntg3_rd32_loop(tp, regs, MEMARB_MODE, 0x10);\r\ntg3_rd32_loop(tp, regs, BUFMGR_MODE, 0x58);\r\ntg3_rd32_loop(tp, regs, RDMAC_MODE, 0x08);\r\ntg3_rd32_loop(tp, regs, WDMAC_MODE, 0x08);\r\ntg3_rd32_loop(tp, regs, RX_CPU_MODE, 0x04);\r\ntg3_rd32_loop(tp, regs, RX_CPU_STATE, 0x04);\r\ntg3_rd32_loop(tp, regs, RX_CPU_PGMCTR, 0x04);\r\ntg3_rd32_loop(tp, regs, RX_CPU_HWBKPT, 0x04);\r\nif (!tg3_flag(tp, 5705_PLUS)) {\r\ntg3_rd32_loop(tp, regs, TX_CPU_MODE, 0x04);\r\ntg3_rd32_loop(tp, regs, TX_CPU_STATE, 0x04);\r\ntg3_rd32_loop(tp, regs, TX_CPU_PGMCTR, 0x04);\r\n}\r\ntg3_rd32_loop(tp, regs, GRCMBOX_INTERRUPT_0, 0x110);\r\ntg3_rd32_loop(tp, regs, FTQ_RESET, 0x120);\r\ntg3_rd32_loop(tp, regs, MSGINT_MODE, 0x0c);\r\ntg3_rd32_loop(tp, regs, DMAC_MODE, 0x04);\r\ntg3_rd32_loop(tp, regs, GRC_MODE, 0x4c);\r\nif (tg3_flag(tp, NVRAM))\r\ntg3_rd32_loop(tp, regs, NVRAM_CMD, 0x24);\r\n}\r\nstatic void tg3_dump_state(struct tg3 *tp)\r\n{\r\nint i;\r\nu32 *regs;\r\nregs = kzalloc(TG3_REG_BLK_SIZE, GFP_ATOMIC);\r\nif (!regs)\r\nreturn;\r\nif (tg3_flag(tp, PCI_EXPRESS)) {\r\nfor (i = 0; i < TG3_PCIE_TLDLPL_PORT; i += sizeof(u32))\r\nregs[i / sizeof(u32)] = tr32(i);\r\n} else\r\ntg3_dump_legacy_regs(tp, regs);\r\nfor (i = 0; i < TG3_REG_BLK_SIZE / sizeof(u32); i += 4) {\r\nif (!regs[i + 0] && !regs[i + 1] &&\r\n!regs[i + 2] && !regs[i + 3])\r\ncontinue;\r\nnetdev_err(tp->dev, "0x%08x: 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",\r\ni * 4,\r\nregs[i + 0], regs[i + 1], regs[i + 2], regs[i + 3]);\r\n}\r\nkfree(regs);\r\nfor (i = 0; i < tp->irq_cnt; i++) {\r\nstruct tg3_napi *tnapi = &tp->napi[i];\r\nnetdev_err(tp->dev,\r\n"%d: Host status block [%08x:%08x:(%04x:%04x:%04x):(%04x:%04x)]\n",\r\ni,\r\ntnapi->hw_status->status,\r\ntnapi->hw_status->status_tag,\r\ntnapi->hw_status->rx_jumbo_consumer,\r\ntnapi->hw_status->rx_consumer,\r\ntnapi->hw_status->rx_mini_consumer,\r\ntnapi->hw_status->idx[0].rx_producer,\r\ntnapi->hw_status->idx[0].tx_consumer);\r\nnetdev_err(tp->dev,\r\n"%d: NAPI info [%08x:%08x:(%04x:%04x:%04x):%04x:(%04x:%04x:%04x:%04x)]\n",\r\ni,\r\ntnapi->last_tag, tnapi->last_irq_tag,\r\ntnapi->tx_prod, tnapi->tx_cons, tnapi->tx_pending,\r\ntnapi->rx_rcb_ptr,\r\ntnapi->prodring.rx_std_prod_idx,\r\ntnapi->prodring.rx_std_cons_idx,\r\ntnapi->prodring.rx_jmb_prod_idx,\r\ntnapi->prodring.rx_jmb_cons_idx);\r\n}\r\n}\r\nstatic void tg3_tx_recover(struct tg3 *tp)\r\n{\r\nBUG_ON(tg3_flag(tp, MBOX_WRITE_REORDER) ||\r\ntp->write32_tx_mbox == tg3_write_indirect_mbox);\r\nnetdev_warn(tp->dev,\r\n"The system may be re-ordering memory-mapped I/O "\r\n"cycles to the network device, attempting to recover. "\r\n"Please report the problem to the driver maintainer "\r\n"and include system chipset information.\n");\r\ntg3_flag_set(tp, TX_RECOVERY_PENDING);\r\n}\r\nstatic inline u32 tg3_tx_avail(struct tg3_napi *tnapi)\r\n{\r\nbarrier();\r\nreturn tnapi->tx_pending -\r\n((tnapi->tx_prod - tnapi->tx_cons) & (TG3_TX_RING_SIZE - 1));\r\n}\r\nstatic void tg3_tx(struct tg3_napi *tnapi)\r\n{\r\nstruct tg3 *tp = tnapi->tp;\r\nu32 hw_idx = tnapi->hw_status->idx[0].tx_consumer;\r\nu32 sw_idx = tnapi->tx_cons;\r\nstruct netdev_queue *txq;\r\nint index = tnapi - tp->napi;\r\nunsigned int pkts_compl = 0, bytes_compl = 0;\r\nif (tg3_flag(tp, ENABLE_TSS))\r\nindex--;\r\ntxq = netdev_get_tx_queue(tp->dev, index);\r\nwhile (sw_idx != hw_idx) {\r\nstruct tg3_tx_ring_info *ri = &tnapi->tx_buffers[sw_idx];\r\nstruct sk_buff *skb = ri->skb;\r\nint i, tx_bug = 0;\r\nif (unlikely(skb == NULL)) {\r\ntg3_tx_recover(tp);\r\nreturn;\r\n}\r\nif (tnapi->tx_ring[sw_idx].len_flags & TXD_FLAG_HWTSTAMP) {\r\nstruct skb_shared_hwtstamps timestamp;\r\nu64 hwclock = tr32(TG3_TX_TSTAMP_LSB);\r\nhwclock |= (u64)tr32(TG3_TX_TSTAMP_MSB) << 32;\r\ntg3_hwclock_to_timestamp(tp, hwclock, &timestamp);\r\nskb_tstamp_tx(skb, &timestamp);\r\n}\r\npci_unmap_single(tp->pdev,\r\ndma_unmap_addr(ri, mapping),\r\nskb_headlen(skb),\r\nPCI_DMA_TODEVICE);\r\nri->skb = NULL;\r\nwhile (ri->fragmented) {\r\nri->fragmented = false;\r\nsw_idx = NEXT_TX(sw_idx);\r\nri = &tnapi->tx_buffers[sw_idx];\r\n}\r\nsw_idx = NEXT_TX(sw_idx);\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\nri = &tnapi->tx_buffers[sw_idx];\r\nif (unlikely(ri->skb != NULL || sw_idx == hw_idx))\r\ntx_bug = 1;\r\npci_unmap_page(tp->pdev,\r\ndma_unmap_addr(ri, mapping),\r\nskb_frag_size(&skb_shinfo(skb)->frags[i]),\r\nPCI_DMA_TODEVICE);\r\nwhile (ri->fragmented) {\r\nri->fragmented = false;\r\nsw_idx = NEXT_TX(sw_idx);\r\nri = &tnapi->tx_buffers[sw_idx];\r\n}\r\nsw_idx = NEXT_TX(sw_idx);\r\n}\r\npkts_compl++;\r\nbytes_compl += skb->len;\r\ndev_kfree_skb_any(skb);\r\nif (unlikely(tx_bug)) {\r\ntg3_tx_recover(tp);\r\nreturn;\r\n}\r\n}\r\nnetdev_tx_completed_queue(txq, pkts_compl, bytes_compl);\r\ntnapi->tx_cons = sw_idx;\r\nsmp_mb();\r\nif (unlikely(netif_tx_queue_stopped(txq) &&\r\n(tg3_tx_avail(tnapi) > TG3_TX_WAKEUP_THRESH(tnapi)))) {\r\n__netif_tx_lock(txq, smp_processor_id());\r\nif (netif_tx_queue_stopped(txq) &&\r\n(tg3_tx_avail(tnapi) > TG3_TX_WAKEUP_THRESH(tnapi)))\r\nnetif_tx_wake_queue(txq);\r\n__netif_tx_unlock(txq);\r\n}\r\n}\r\nstatic void tg3_frag_free(bool is_frag, void *data)\r\n{\r\nif (is_frag)\r\nskb_free_frag(data);\r\nelse\r\nkfree(data);\r\n}\r\nstatic void tg3_rx_data_free(struct tg3 *tp, struct ring_info *ri, u32 map_sz)\r\n{\r\nunsigned int skb_size = SKB_DATA_ALIGN(map_sz + TG3_RX_OFFSET(tp)) +\r\nSKB_DATA_ALIGN(sizeof(struct skb_shared_info));\r\nif (!ri->data)\r\nreturn;\r\npci_unmap_single(tp->pdev, dma_unmap_addr(ri, mapping),\r\nmap_sz, PCI_DMA_FROMDEVICE);\r\ntg3_frag_free(skb_size <= PAGE_SIZE, ri->data);\r\nri->data = NULL;\r\n}\r\nstatic int tg3_alloc_rx_data(struct tg3 *tp, struct tg3_rx_prodring_set *tpr,\r\nu32 opaque_key, u32 dest_idx_unmasked,\r\nunsigned int *frag_size)\r\n{\r\nstruct tg3_rx_buffer_desc *desc;\r\nstruct ring_info *map;\r\nu8 *data;\r\ndma_addr_t mapping;\r\nint skb_size, data_size, dest_idx;\r\nswitch (opaque_key) {\r\ncase RXD_OPAQUE_RING_STD:\r\ndest_idx = dest_idx_unmasked & tp->rx_std_ring_mask;\r\ndesc = &tpr->rx_std[dest_idx];\r\nmap = &tpr->rx_std_buffers[dest_idx];\r\ndata_size = tp->rx_pkt_map_sz;\r\nbreak;\r\ncase RXD_OPAQUE_RING_JUMBO:\r\ndest_idx = dest_idx_unmasked & tp->rx_jmb_ring_mask;\r\ndesc = &tpr->rx_jmb[dest_idx].std;\r\nmap = &tpr->rx_jmb_buffers[dest_idx];\r\ndata_size = TG3_RX_JMB_MAP_SZ;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nskb_size = SKB_DATA_ALIGN(data_size + TG3_RX_OFFSET(tp)) +\r\nSKB_DATA_ALIGN(sizeof(struct skb_shared_info));\r\nif (skb_size <= PAGE_SIZE) {\r\ndata = netdev_alloc_frag(skb_size);\r\n*frag_size = skb_size;\r\n} else {\r\ndata = kmalloc(skb_size, GFP_ATOMIC);\r\n*frag_size = 0;\r\n}\r\nif (!data)\r\nreturn -ENOMEM;\r\nmapping = pci_map_single(tp->pdev,\r\ndata + TG3_RX_OFFSET(tp),\r\ndata_size,\r\nPCI_DMA_FROMDEVICE);\r\nif (unlikely(pci_dma_mapping_error(tp->pdev, mapping))) {\r\ntg3_frag_free(skb_size <= PAGE_SIZE, data);\r\nreturn -EIO;\r\n}\r\nmap->data = data;\r\ndma_unmap_addr_set(map, mapping, mapping);\r\ndesc->addr_hi = ((u64)mapping >> 32);\r\ndesc->addr_lo = ((u64)mapping & 0xffffffff);\r\nreturn data_size;\r\n}\r\nstatic void tg3_recycle_rx(struct tg3_napi *tnapi,\r\nstruct tg3_rx_prodring_set *dpr,\r\nu32 opaque_key, int src_idx,\r\nu32 dest_idx_unmasked)\r\n{\r\nstruct tg3 *tp = tnapi->tp;\r\nstruct tg3_rx_buffer_desc *src_desc, *dest_desc;\r\nstruct ring_info *src_map, *dest_map;\r\nstruct tg3_rx_prodring_set *spr = &tp->napi[0].prodring;\r\nint dest_idx;\r\nswitch (opaque_key) {\r\ncase RXD_OPAQUE_RING_STD:\r\ndest_idx = dest_idx_unmasked & tp->rx_std_ring_mask;\r\ndest_desc = &dpr->rx_std[dest_idx];\r\ndest_map = &dpr->rx_std_buffers[dest_idx];\r\nsrc_desc = &spr->rx_std[src_idx];\r\nsrc_map = &spr->rx_std_buffers[src_idx];\r\nbreak;\r\ncase RXD_OPAQUE_RING_JUMBO:\r\ndest_idx = dest_idx_unmasked & tp->rx_jmb_ring_mask;\r\ndest_desc = &dpr->rx_jmb[dest_idx].std;\r\ndest_map = &dpr->rx_jmb_buffers[dest_idx];\r\nsrc_desc = &spr->rx_jmb[src_idx].std;\r\nsrc_map = &spr->rx_jmb_buffers[src_idx];\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\ndest_map->data = src_map->data;\r\ndma_unmap_addr_set(dest_map, mapping,\r\ndma_unmap_addr(src_map, mapping));\r\ndest_desc->addr_hi = src_desc->addr_hi;\r\ndest_desc->addr_lo = src_desc->addr_lo;\r\nsmp_wmb();\r\nsrc_map->data = NULL;\r\n}\r\nstatic int tg3_rx(struct tg3_napi *tnapi, int budget)\r\n{\r\nstruct tg3 *tp = tnapi->tp;\r\nu32 work_mask, rx_std_posted = 0;\r\nu32 std_prod_idx, jmb_prod_idx;\r\nu32 sw_idx = tnapi->rx_rcb_ptr;\r\nu16 hw_idx;\r\nint received;\r\nstruct tg3_rx_prodring_set *tpr = &tnapi->prodring;\r\nhw_idx = *(tnapi->rx_rcb_prod_idx);\r\nrmb();\r\nwork_mask = 0;\r\nreceived = 0;\r\nstd_prod_idx = tpr->rx_std_prod_idx;\r\njmb_prod_idx = tpr->rx_jmb_prod_idx;\r\nwhile (sw_idx != hw_idx && budget > 0) {\r\nstruct ring_info *ri;\r\nstruct tg3_rx_buffer_desc *desc = &tnapi->rx_rcb[sw_idx];\r\nunsigned int len;\r\nstruct sk_buff *skb;\r\ndma_addr_t dma_addr;\r\nu32 opaque_key, desc_idx, *post_ptr;\r\nu8 *data;\r\nu64 tstamp = 0;\r\ndesc_idx = desc->opaque & RXD_OPAQUE_INDEX_MASK;\r\nopaque_key = desc->opaque & RXD_OPAQUE_RING_MASK;\r\nif (opaque_key == RXD_OPAQUE_RING_STD) {\r\nri = &tp->napi[0].prodring.rx_std_buffers[desc_idx];\r\ndma_addr = dma_unmap_addr(ri, mapping);\r\ndata = ri->data;\r\npost_ptr = &std_prod_idx;\r\nrx_std_posted++;\r\n} else if (opaque_key == RXD_OPAQUE_RING_JUMBO) {\r\nri = &tp->napi[0].prodring.rx_jmb_buffers[desc_idx];\r\ndma_addr = dma_unmap_addr(ri, mapping);\r\ndata = ri->data;\r\npost_ptr = &jmb_prod_idx;\r\n} else\r\ngoto next_pkt_nopost;\r\nwork_mask |= opaque_key;\r\nif (desc->err_vlan & RXD_ERR_MASK) {\r\ndrop_it:\r\ntg3_recycle_rx(tnapi, tpr, opaque_key,\r\ndesc_idx, *post_ptr);\r\ndrop_it_no_recycle:\r\ntp->rx_dropped++;\r\ngoto next_pkt;\r\n}\r\nprefetch(data + TG3_RX_OFFSET(tp));\r\nlen = ((desc->idx_len & RXD_LEN_MASK) >> RXD_LEN_SHIFT) -\r\nETH_FCS_LEN;\r\nif ((desc->type_flags & RXD_FLAG_PTPSTAT_MASK) ==\r\nRXD_FLAG_PTPSTAT_PTPV1 ||\r\n(desc->type_flags & RXD_FLAG_PTPSTAT_MASK) ==\r\nRXD_FLAG_PTPSTAT_PTPV2) {\r\ntstamp = tr32(TG3_RX_TSTAMP_LSB);\r\ntstamp |= (u64)tr32(TG3_RX_TSTAMP_MSB) << 32;\r\n}\r\nif (len > TG3_RX_COPY_THRESH(tp)) {\r\nint skb_size;\r\nunsigned int frag_size;\r\nskb_size = tg3_alloc_rx_data(tp, tpr, opaque_key,\r\n*post_ptr, &frag_size);\r\nif (skb_size < 0)\r\ngoto drop_it;\r\npci_unmap_single(tp->pdev, dma_addr, skb_size,\r\nPCI_DMA_FROMDEVICE);\r\nsmp_wmb();\r\nri->data = NULL;\r\nskb = build_skb(data, frag_size);\r\nif (!skb) {\r\ntg3_frag_free(frag_size != 0, data);\r\ngoto drop_it_no_recycle;\r\n}\r\nskb_reserve(skb, TG3_RX_OFFSET(tp));\r\n} else {\r\ntg3_recycle_rx(tnapi, tpr, opaque_key,\r\ndesc_idx, *post_ptr);\r\nskb = netdev_alloc_skb(tp->dev,\r\nlen + TG3_RAW_IP_ALIGN);\r\nif (skb == NULL)\r\ngoto drop_it_no_recycle;\r\nskb_reserve(skb, TG3_RAW_IP_ALIGN);\r\npci_dma_sync_single_for_cpu(tp->pdev, dma_addr, len, PCI_DMA_FROMDEVICE);\r\nmemcpy(skb->data,\r\ndata + TG3_RX_OFFSET(tp),\r\nlen);\r\npci_dma_sync_single_for_device(tp->pdev, dma_addr, len, PCI_DMA_FROMDEVICE);\r\n}\r\nskb_put(skb, len);\r\nif (tstamp)\r\ntg3_hwclock_to_timestamp(tp, tstamp,\r\nskb_hwtstamps(skb));\r\nif ((tp->dev->features & NETIF_F_RXCSUM) &&\r\n(desc->type_flags & RXD_FLAG_TCPUDP_CSUM) &&\r\n(((desc->ip_tcp_csum & RXD_TCPCSUM_MASK)\r\n>> RXD_TCPCSUM_SHIFT) == 0xffff))\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nelse\r\nskb_checksum_none_assert(skb);\r\nskb->protocol = eth_type_trans(skb, tp->dev);\r\nif (len > (tp->dev->mtu + ETH_HLEN) &&\r\nskb->protocol != htons(ETH_P_8021Q) &&\r\nskb->protocol != htons(ETH_P_8021AD)) {\r\ndev_kfree_skb_any(skb);\r\ngoto drop_it_no_recycle;\r\n}\r\nif (desc->type_flags & RXD_FLAG_VLAN &&\r\n!(tp->rx_mode & RX_MODE_KEEP_VLAN_TAG))\r\n__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),\r\ndesc->err_vlan & RXD_VLAN_MASK);\r\nnapi_gro_receive(&tnapi->napi, skb);\r\nreceived++;\r\nbudget--;\r\nnext_pkt:\r\n(*post_ptr)++;\r\nif (unlikely(rx_std_posted >= tp->rx_std_max_post)) {\r\ntpr->rx_std_prod_idx = std_prod_idx &\r\ntp->rx_std_ring_mask;\r\ntw32_rx_mbox(TG3_RX_STD_PROD_IDX_REG,\r\ntpr->rx_std_prod_idx);\r\nwork_mask &= ~RXD_OPAQUE_RING_STD;\r\nrx_std_posted = 0;\r\n}\r\nnext_pkt_nopost:\r\nsw_idx++;\r\nsw_idx &= tp->rx_ret_ring_mask;\r\nif (sw_idx == hw_idx) {\r\nhw_idx = *(tnapi->rx_rcb_prod_idx);\r\nrmb();\r\n}\r\n}\r\ntnapi->rx_rcb_ptr = sw_idx;\r\ntw32_rx_mbox(tnapi->consmbox, sw_idx);\r\nif (!tg3_flag(tp, ENABLE_RSS)) {\r\nwmb();\r\nif (work_mask & RXD_OPAQUE_RING_STD) {\r\ntpr->rx_std_prod_idx = std_prod_idx &\r\ntp->rx_std_ring_mask;\r\ntw32_rx_mbox(TG3_RX_STD_PROD_IDX_REG,\r\ntpr->rx_std_prod_idx);\r\n}\r\nif (work_mask & RXD_OPAQUE_RING_JUMBO) {\r\ntpr->rx_jmb_prod_idx = jmb_prod_idx &\r\ntp->rx_jmb_ring_mask;\r\ntw32_rx_mbox(TG3_RX_JMB_PROD_IDX_REG,\r\ntpr->rx_jmb_prod_idx);\r\n}\r\nmmiowb();\r\n} else if (work_mask) {\r\nsmp_wmb();\r\ntpr->rx_std_prod_idx = std_prod_idx & tp->rx_std_ring_mask;\r\ntpr->rx_jmb_prod_idx = jmb_prod_idx & tp->rx_jmb_ring_mask;\r\nif (tnapi != &tp->napi[1]) {\r\ntp->rx_refill = true;\r\nnapi_schedule(&tp->napi[1].napi);\r\n}\r\n}\r\nreturn received;\r\n}\r\nstatic void tg3_poll_link(struct tg3 *tp)\r\n{\r\nif (!(tg3_flag(tp, USE_LINKCHG_REG) || tg3_flag(tp, POLL_SERDES))) {\r\nstruct tg3_hw_status *sblk = tp->napi[0].hw_status;\r\nif (sblk->status & SD_STATUS_LINK_CHG) {\r\nsblk->status = SD_STATUS_UPDATED |\r\n(sblk->status & ~SD_STATUS_LINK_CHG);\r\nspin_lock(&tp->lock);\r\nif (tg3_flag(tp, USE_PHYLIB)) {\r\ntw32_f(MAC_STATUS,\r\n(MAC_STATUS_SYNC_CHANGED |\r\nMAC_STATUS_CFG_CHANGED |\r\nMAC_STATUS_MI_COMPLETION |\r\nMAC_STATUS_LNKSTATE_CHANGED));\r\nudelay(40);\r\n} else\r\ntg3_setup_phy(tp, false);\r\nspin_unlock(&tp->lock);\r\n}\r\n}\r\n}\r\nstatic int tg3_rx_prodring_xfer(struct tg3 *tp,\r\nstruct tg3_rx_prodring_set *dpr,\r\nstruct tg3_rx_prodring_set *spr)\r\n{\r\nu32 si, di, cpycnt, src_prod_idx;\r\nint i, err = 0;\r\nwhile (1) {\r\nsrc_prod_idx = spr->rx_std_prod_idx;\r\nsmp_rmb();\r\nif (spr->rx_std_cons_idx == src_prod_idx)\r\nbreak;\r\nif (spr->rx_std_cons_idx < src_prod_idx)\r\ncpycnt = src_prod_idx - spr->rx_std_cons_idx;\r\nelse\r\ncpycnt = tp->rx_std_ring_mask + 1 -\r\nspr->rx_std_cons_idx;\r\ncpycnt = min(cpycnt,\r\ntp->rx_std_ring_mask + 1 - dpr->rx_std_prod_idx);\r\nsi = spr->rx_std_cons_idx;\r\ndi = dpr->rx_std_prod_idx;\r\nfor (i = di; i < di + cpycnt; i++) {\r\nif (dpr->rx_std_buffers[i].data) {\r\ncpycnt = i - di;\r\nerr = -ENOSPC;\r\nbreak;\r\n}\r\n}\r\nif (!cpycnt)\r\nbreak;\r\nsmp_rmb();\r\nmemcpy(&dpr->rx_std_buffers[di],\r\n&spr->rx_std_buffers[si],\r\ncpycnt * sizeof(struct ring_info));\r\nfor (i = 0; i < cpycnt; i++, di++, si++) {\r\nstruct tg3_rx_buffer_desc *sbd, *dbd;\r\nsbd = &spr->rx_std[si];\r\ndbd = &dpr->rx_std[di];\r\ndbd->addr_hi = sbd->addr_hi;\r\ndbd->addr_lo = sbd->addr_lo;\r\n}\r\nspr->rx_std_cons_idx = (spr->rx_std_cons_idx + cpycnt) &\r\ntp->rx_std_ring_mask;\r\ndpr->rx_std_prod_idx = (dpr->rx_std_prod_idx + cpycnt) &\r\ntp->rx_std_ring_mask;\r\n}\r\nwhile (1) {\r\nsrc_prod_idx = spr->rx_jmb_prod_idx;\r\nsmp_rmb();\r\nif (spr->rx_jmb_cons_idx == src_prod_idx)\r\nbreak;\r\nif (spr->rx_jmb_cons_idx < src_prod_idx)\r\ncpycnt = src_prod_idx - spr->rx_jmb_cons_idx;\r\nelse\r\ncpycnt = tp->rx_jmb_ring_mask + 1 -\r\nspr->rx_jmb_cons_idx;\r\ncpycnt = min(cpycnt,\r\ntp->rx_jmb_ring_mask + 1 - dpr->rx_jmb_prod_idx);\r\nsi = spr->rx_jmb_cons_idx;\r\ndi = dpr->rx_jmb_prod_idx;\r\nfor (i = di; i < di + cpycnt; i++) {\r\nif (dpr->rx_jmb_buffers[i].data) {\r\ncpycnt = i - di;\r\nerr = -ENOSPC;\r\nbreak;\r\n}\r\n}\r\nif (!cpycnt)\r\nbreak;\r\nsmp_rmb();\r\nmemcpy(&dpr->rx_jmb_buffers[di],\r\n&spr->rx_jmb_buffers[si],\r\ncpycnt * sizeof(struct ring_info));\r\nfor (i = 0; i < cpycnt; i++, di++, si++) {\r\nstruct tg3_rx_buffer_desc *sbd, *dbd;\r\nsbd = &spr->rx_jmb[si].std;\r\ndbd = &dpr->rx_jmb[di].std;\r\ndbd->addr_hi = sbd->addr_hi;\r\ndbd->addr_lo = sbd->addr_lo;\r\n}\r\nspr->rx_jmb_cons_idx = (spr->rx_jmb_cons_idx + cpycnt) &\r\ntp->rx_jmb_ring_mask;\r\ndpr->rx_jmb_prod_idx = (dpr->rx_jmb_prod_idx + cpycnt) &\r\ntp->rx_jmb_ring_mask;\r\n}\r\nreturn err;\r\n}\r\nstatic int tg3_poll_work(struct tg3_napi *tnapi, int work_done, int budget)\r\n{\r\nstruct tg3 *tp = tnapi->tp;\r\nif (tnapi->hw_status->idx[0].tx_consumer != tnapi->tx_cons) {\r\ntg3_tx(tnapi);\r\nif (unlikely(tg3_flag(tp, TX_RECOVERY_PENDING)))\r\nreturn work_done;\r\n}\r\nif (!tnapi->rx_rcb_prod_idx)\r\nreturn work_done;\r\nif (*(tnapi->rx_rcb_prod_idx) != tnapi->rx_rcb_ptr)\r\nwork_done += tg3_rx(tnapi, budget - work_done);\r\nif (tg3_flag(tp, ENABLE_RSS) && tnapi == &tp->napi[1]) {\r\nstruct tg3_rx_prodring_set *dpr = &tp->napi[0].prodring;\r\nint i, err = 0;\r\nu32 std_prod_idx = dpr->rx_std_prod_idx;\r\nu32 jmb_prod_idx = dpr->rx_jmb_prod_idx;\r\ntp->rx_refill = false;\r\nfor (i = 1; i <= tp->rxq_cnt; i++)\r\nerr |= tg3_rx_prodring_xfer(tp, dpr,\r\n&tp->napi[i].prodring);\r\nwmb();\r\nif (std_prod_idx != dpr->rx_std_prod_idx)\r\ntw32_rx_mbox(TG3_RX_STD_PROD_IDX_REG,\r\ndpr->rx_std_prod_idx);\r\nif (jmb_prod_idx != dpr->rx_jmb_prod_idx)\r\ntw32_rx_mbox(TG3_RX_JMB_PROD_IDX_REG,\r\ndpr->rx_jmb_prod_idx);\r\nmmiowb();\r\nif (err)\r\ntw32_f(HOSTCC_MODE, tp->coal_now);\r\n}\r\nreturn work_done;\r\n}\r\nstatic inline void tg3_reset_task_schedule(struct tg3 *tp)\r\n{\r\nif (!test_and_set_bit(TG3_FLAG_RESET_TASK_PENDING, tp->tg3_flags))\r\nschedule_work(&tp->reset_task);\r\n}\r\nstatic inline void tg3_reset_task_cancel(struct tg3 *tp)\r\n{\r\ncancel_work_sync(&tp->reset_task);\r\ntg3_flag_clear(tp, RESET_TASK_PENDING);\r\ntg3_flag_clear(tp, TX_RECOVERY_PENDING);\r\n}\r\nstatic int tg3_poll_msix(struct napi_struct *napi, int budget)\r\n{\r\nstruct tg3_napi *tnapi = container_of(napi, struct tg3_napi, napi);\r\nstruct tg3 *tp = tnapi->tp;\r\nint work_done = 0;\r\nstruct tg3_hw_status *sblk = tnapi->hw_status;\r\nwhile (1) {\r\nwork_done = tg3_poll_work(tnapi, work_done, budget);\r\nif (unlikely(tg3_flag(tp, TX_RECOVERY_PENDING)))\r\ngoto tx_recovery;\r\nif (unlikely(work_done >= budget))\r\nbreak;\r\ntnapi->last_tag = sblk->status_tag;\r\ntnapi->last_irq_tag = tnapi->last_tag;\r\nrmb();\r\nif (likely(sblk->idx[0].tx_consumer == tnapi->tx_cons &&\r\n*(tnapi->rx_rcb_prod_idx) == tnapi->rx_rcb_ptr)) {\r\nif (tnapi == &tp->napi[1] && tp->rx_refill)\r\ncontinue;\r\nnapi_complete_done(napi, work_done);\r\ntw32_mailbox(tnapi->int_mbox, tnapi->last_tag << 24);\r\nif (unlikely(tnapi == &tp->napi[1] && tp->rx_refill)) {\r\ntw32(HOSTCC_MODE, tp->coalesce_mode |\r\nHOSTCC_MODE_ENABLE |\r\ntnapi->coal_now);\r\n}\r\nmmiowb();\r\nbreak;\r\n}\r\n}\r\nreturn work_done;\r\ntx_recovery:\r\nnapi_complete(napi);\r\ntg3_reset_task_schedule(tp);\r\nreturn work_done;\r\n}\r\nstatic void tg3_process_error(struct tg3 *tp)\r\n{\r\nu32 val;\r\nbool real_error = false;\r\nif (tg3_flag(tp, ERROR_PROCESSED))\r\nreturn;\r\nval = tr32(HOSTCC_FLOW_ATTN);\r\nif (val & ~HOSTCC_FLOW_ATTN_MBUF_LWM) {\r\nnetdev_err(tp->dev, "FLOW Attention error. Resetting chip.\n");\r\nreal_error = true;\r\n}\r\nif (tr32(MSGINT_STATUS) & ~MSGINT_STATUS_MSI_REQ) {\r\nnetdev_err(tp->dev, "MSI Status error. Resetting chip.\n");\r\nreal_error = true;\r\n}\r\nif (tr32(RDMAC_STATUS) || tr32(WDMAC_STATUS)) {\r\nnetdev_err(tp->dev, "DMA Status error. Resetting chip.\n");\r\nreal_error = true;\r\n}\r\nif (!real_error)\r\nreturn;\r\ntg3_dump_state(tp);\r\ntg3_flag_set(tp, ERROR_PROCESSED);\r\ntg3_reset_task_schedule(tp);\r\n}\r\nstatic int tg3_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct tg3_napi *tnapi = container_of(napi, struct tg3_napi, napi);\r\nstruct tg3 *tp = tnapi->tp;\r\nint work_done = 0;\r\nstruct tg3_hw_status *sblk = tnapi->hw_status;\r\nwhile (1) {\r\nif (sblk->status & SD_STATUS_ERROR)\r\ntg3_process_error(tp);\r\ntg3_poll_link(tp);\r\nwork_done = tg3_poll_work(tnapi, work_done, budget);\r\nif (unlikely(tg3_flag(tp, TX_RECOVERY_PENDING)))\r\ngoto tx_recovery;\r\nif (unlikely(work_done >= budget))\r\nbreak;\r\nif (tg3_flag(tp, TAGGED_STATUS)) {\r\ntnapi->last_tag = sblk->status_tag;\r\ntnapi->last_irq_tag = tnapi->last_tag;\r\nrmb();\r\n} else\r\nsblk->status &= ~SD_STATUS_UPDATED;\r\nif (likely(!tg3_has_work(tnapi))) {\r\nnapi_complete_done(napi, work_done);\r\ntg3_int_reenable(tnapi);\r\nbreak;\r\n}\r\n}\r\nreturn work_done;\r\ntx_recovery:\r\nnapi_complete(napi);\r\ntg3_reset_task_schedule(tp);\r\nreturn work_done;\r\n}\r\nstatic void tg3_napi_disable(struct tg3 *tp)\r\n{\r\nint i;\r\nfor (i = tp->irq_cnt - 1; i >= 0; i--)\r\nnapi_disable(&tp->napi[i].napi);\r\n}\r\nstatic void tg3_napi_enable(struct tg3 *tp)\r\n{\r\nint i;\r\nfor (i = 0; i < tp->irq_cnt; i++)\r\nnapi_enable(&tp->napi[i].napi);\r\n}\r\nstatic void tg3_napi_init(struct tg3 *tp)\r\n{\r\nint i;\r\nnetif_napi_add(tp->dev, &tp->napi[0].napi, tg3_poll, 64);\r\nfor (i = 1; i < tp->irq_cnt; i++)\r\nnetif_napi_add(tp->dev, &tp->napi[i].napi, tg3_poll_msix, 64);\r\n}\r\nstatic void tg3_napi_fini(struct tg3 *tp)\r\n{\r\nint i;\r\nfor (i = 0; i < tp->irq_cnt; i++)\r\nnetif_napi_del(&tp->napi[i].napi);\r\n}\r\nstatic inline void tg3_netif_stop(struct tg3 *tp)\r\n{\r\ntp->dev->trans_start = jiffies;\r\ntg3_napi_disable(tp);\r\nnetif_carrier_off(tp->dev);\r\nnetif_tx_disable(tp->dev);\r\n}\r\nstatic inline void tg3_netif_start(struct tg3 *tp)\r\n{\r\ntg3_ptp_resume(tp);\r\nnetif_tx_wake_all_queues(tp->dev);\r\nif (tp->link_up)\r\nnetif_carrier_on(tp->dev);\r\ntg3_napi_enable(tp);\r\ntp->napi[0].hw_status->status |= SD_STATUS_UPDATED;\r\ntg3_enable_ints(tp);\r\n}\r\nstatic void tg3_irq_quiesce(struct tg3 *tp)\r\n__releases(tp->lock)\r\n__acquires(tp->lock)\r\n{\r\nint i;\r\nBUG_ON(tp->irq_sync);\r\ntp->irq_sync = 1;\r\nsmp_mb();\r\nspin_unlock_bh(&tp->lock);\r\nfor (i = 0; i < tp->irq_cnt; i++)\r\nsynchronize_irq(tp->napi[i].irq_vec);\r\nspin_lock_bh(&tp->lock);\r\n}\r\nstatic inline void tg3_full_lock(struct tg3 *tp, int irq_sync)\r\n{\r\nspin_lock_bh(&tp->lock);\r\nif (irq_sync)\r\ntg3_irq_quiesce(tp);\r\n}\r\nstatic inline void tg3_full_unlock(struct tg3 *tp)\r\n{\r\nspin_unlock_bh(&tp->lock);\r\n}\r\nstatic irqreturn_t tg3_msi_1shot(int irq, void *dev_id)\r\n{\r\nstruct tg3_napi *tnapi = dev_id;\r\nstruct tg3 *tp = tnapi->tp;\r\nprefetch(tnapi->hw_status);\r\nif (tnapi->rx_rcb)\r\nprefetch(&tnapi->rx_rcb[tnapi->rx_rcb_ptr]);\r\nif (likely(!tg3_irq_sync(tp)))\r\nnapi_schedule(&tnapi->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t tg3_msi(int irq, void *dev_id)\r\n{\r\nstruct tg3_napi *tnapi = dev_id;\r\nstruct tg3 *tp = tnapi->tp;\r\nprefetch(tnapi->hw_status);\r\nif (tnapi->rx_rcb)\r\nprefetch(&tnapi->rx_rcb[tnapi->rx_rcb_ptr]);\r\ntw32_mailbox(tnapi->int_mbox, 0x00000001);\r\nif (likely(!tg3_irq_sync(tp)))\r\nnapi_schedule(&tnapi->napi);\r\nreturn IRQ_RETVAL(1);\r\n}\r\nstatic irqreturn_t tg3_interrupt(int irq, void *dev_id)\r\n{\r\nstruct tg3_napi *tnapi = dev_id;\r\nstruct tg3 *tp = tnapi->tp;\r\nstruct tg3_hw_status *sblk = tnapi->hw_status;\r\nunsigned int handled = 1;\r\nif (unlikely(!(sblk->status & SD_STATUS_UPDATED))) {\r\nif (tg3_flag(tp, CHIP_RESETTING) ||\r\n(tr32(TG3PCI_PCISTATE) & PCISTATE_INT_NOT_ACTIVE)) {\r\nhandled = 0;\r\ngoto out;\r\n}\r\n}\r\ntw32_mailbox_f(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW, 0x00000001);\r\nif (tg3_irq_sync(tp))\r\ngoto out;\r\nsblk->status &= ~SD_STATUS_UPDATED;\r\nif (likely(tg3_has_work(tnapi))) {\r\nprefetch(&tnapi->rx_rcb[tnapi->rx_rcb_ptr]);\r\nnapi_schedule(&tnapi->napi);\r\n} else {\r\ntw32_mailbox_f(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW,\r\n0x00000000);\r\n}\r\nout:\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic irqreturn_t tg3_interrupt_tagged(int irq, void *dev_id)\r\n{\r\nstruct tg3_napi *tnapi = dev_id;\r\nstruct tg3 *tp = tnapi->tp;\r\nstruct tg3_hw_status *sblk = tnapi->hw_status;\r\nunsigned int handled = 1;\r\nif (unlikely(sblk->status_tag == tnapi->last_irq_tag)) {\r\nif (tg3_flag(tp, CHIP_RESETTING) ||\r\n(tr32(TG3PCI_PCISTATE) & PCISTATE_INT_NOT_ACTIVE)) {\r\nhandled = 0;\r\ngoto out;\r\n}\r\n}\r\ntw32_mailbox_f(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW, 0x00000001);\r\ntnapi->last_irq_tag = sblk->status_tag;\r\nif (tg3_irq_sync(tp))\r\ngoto out;\r\nprefetch(&tnapi->rx_rcb[tnapi->rx_rcb_ptr]);\r\nnapi_schedule(&tnapi->napi);\r\nout:\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic irqreturn_t tg3_test_isr(int irq, void *dev_id)\r\n{\r\nstruct tg3_napi *tnapi = dev_id;\r\nstruct tg3 *tp = tnapi->tp;\r\nstruct tg3_hw_status *sblk = tnapi->hw_status;\r\nif ((sblk->status & SD_STATUS_UPDATED) ||\r\n!(tr32(TG3PCI_PCISTATE) & PCISTATE_INT_NOT_ACTIVE)) {\r\ntg3_disable_ints(tp);\r\nreturn IRQ_RETVAL(1);\r\n}\r\nreturn IRQ_RETVAL(0);\r\n}\r\nstatic void tg3_poll_controller(struct net_device *dev)\r\n{\r\nint i;\r\nstruct tg3 *tp = netdev_priv(dev);\r\nif (tg3_irq_sync(tp))\r\nreturn;\r\nfor (i = 0; i < tp->irq_cnt; i++)\r\ntg3_interrupt(tp->napi[i].irq_vec, &tp->napi[i]);\r\n}\r\nstatic void tg3_tx_timeout(struct net_device *dev)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nif (netif_msg_tx_err(tp)) {\r\nnetdev_err(dev, "transmit timed out, resetting\n");\r\ntg3_dump_state(tp);\r\n}\r\ntg3_reset_task_schedule(tp);\r\n}\r\nstatic inline int tg3_4g_overflow_test(dma_addr_t mapping, int len)\r\n{\r\nu32 base = (u32) mapping & 0xffffffff;\r\nreturn base + len + 8 < base;\r\n}\r\nstatic inline int tg3_4g_tso_overflow_test(struct tg3 *tp, dma_addr_t mapping,\r\nu32 len, u32 mss)\r\n{\r\nif (tg3_asic_rev(tp) == ASIC_REV_5762 && mss) {\r\nu32 base = (u32) mapping & 0xffffffff;\r\nreturn ((base + len + (mss & 0x3fff)) < base);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int tg3_40bit_overflow_test(struct tg3 *tp, dma_addr_t mapping,\r\nint len)\r\n{\r\n#if defined(CONFIG_HIGHMEM) && (BITS_PER_LONG == 64)\r\nif (tg3_flag(tp, 40BIT_DMA_BUG))\r\nreturn ((u64) mapping + len) > DMA_BIT_MASK(40);\r\nreturn 0;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic inline void tg3_tx_set_bd(struct tg3_tx_buffer_desc *txbd,\r\ndma_addr_t mapping, u32 len, u32 flags,\r\nu32 mss, u32 vlan)\r\n{\r\ntxbd->addr_hi = ((u64) mapping >> 32);\r\ntxbd->addr_lo = ((u64) mapping & 0xffffffff);\r\ntxbd->len_flags = (len << TXD_LEN_SHIFT) | (flags & 0x0000ffff);\r\ntxbd->vlan_tag = (mss << TXD_MSS_SHIFT) | (vlan << TXD_VLAN_TAG_SHIFT);\r\n}\r\nstatic bool tg3_tx_frag_set(struct tg3_napi *tnapi, u32 *entry, u32 *budget,\r\ndma_addr_t map, u32 len, u32 flags,\r\nu32 mss, u32 vlan)\r\n{\r\nstruct tg3 *tp = tnapi->tp;\r\nbool hwbug = false;\r\nif (tg3_flag(tp, SHORT_DMA_BUG) && len <= 8)\r\nhwbug = true;\r\nif (tg3_4g_overflow_test(map, len))\r\nhwbug = true;\r\nif (tg3_4g_tso_overflow_test(tp, map, len, mss))\r\nhwbug = true;\r\nif (tg3_40bit_overflow_test(tp, map, len))\r\nhwbug = true;\r\nif (tp->dma_limit) {\r\nu32 prvidx = *entry;\r\nu32 tmp_flag = flags & ~TXD_FLAG_END;\r\nwhile (len > tp->dma_limit && *budget) {\r\nu32 frag_len = tp->dma_limit;\r\nlen -= tp->dma_limit;\r\nif (len <= 8) {\r\nlen += tp->dma_limit / 2;\r\nfrag_len = tp->dma_limit / 2;\r\n}\r\ntnapi->tx_buffers[*entry].fragmented = true;\r\ntg3_tx_set_bd(&tnapi->tx_ring[*entry], map,\r\nfrag_len, tmp_flag, mss, vlan);\r\n*budget -= 1;\r\nprvidx = *entry;\r\n*entry = NEXT_TX(*entry);\r\nmap += frag_len;\r\n}\r\nif (len) {\r\nif (*budget) {\r\ntg3_tx_set_bd(&tnapi->tx_ring[*entry], map,\r\nlen, flags, mss, vlan);\r\n*budget -= 1;\r\n*entry = NEXT_TX(*entry);\r\n} else {\r\nhwbug = true;\r\ntnapi->tx_buffers[prvidx].fragmented = false;\r\n}\r\n}\r\n} else {\r\ntg3_tx_set_bd(&tnapi->tx_ring[*entry], map,\r\nlen, flags, mss, vlan);\r\n*entry = NEXT_TX(*entry);\r\n}\r\nreturn hwbug;\r\n}\r\nstatic void tg3_tx_skb_unmap(struct tg3_napi *tnapi, u32 entry, int last)\r\n{\r\nint i;\r\nstruct sk_buff *skb;\r\nstruct tg3_tx_ring_info *txb = &tnapi->tx_buffers[entry];\r\nskb = txb->skb;\r\ntxb->skb = NULL;\r\npci_unmap_single(tnapi->tp->pdev,\r\ndma_unmap_addr(txb, mapping),\r\nskb_headlen(skb),\r\nPCI_DMA_TODEVICE);\r\nwhile (txb->fragmented) {\r\ntxb->fragmented = false;\r\nentry = NEXT_TX(entry);\r\ntxb = &tnapi->tx_buffers[entry];\r\n}\r\nfor (i = 0; i <= last; i++) {\r\nconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\r\nentry = NEXT_TX(entry);\r\ntxb = &tnapi->tx_buffers[entry];\r\npci_unmap_page(tnapi->tp->pdev,\r\ndma_unmap_addr(txb, mapping),\r\nskb_frag_size(frag), PCI_DMA_TODEVICE);\r\nwhile (txb->fragmented) {\r\ntxb->fragmented = false;\r\nentry = NEXT_TX(entry);\r\ntxb = &tnapi->tx_buffers[entry];\r\n}\r\n}\r\n}\r\nstatic int tigon3_dma_hwbug_workaround(struct tg3_napi *tnapi,\r\nstruct sk_buff **pskb,\r\nu32 *entry, u32 *budget,\r\nu32 base_flags, u32 mss, u32 vlan)\r\n{\r\nstruct tg3 *tp = tnapi->tp;\r\nstruct sk_buff *new_skb, *skb = *pskb;\r\ndma_addr_t new_addr = 0;\r\nint ret = 0;\r\nif (tg3_asic_rev(tp) != ASIC_REV_5701)\r\nnew_skb = skb_copy(skb, GFP_ATOMIC);\r\nelse {\r\nint more_headroom = 4 - ((unsigned long)skb->data & 3);\r\nnew_skb = skb_copy_expand(skb,\r\nskb_headroom(skb) + more_headroom,\r\nskb_tailroom(skb), GFP_ATOMIC);\r\n}\r\nif (!new_skb) {\r\nret = -1;\r\n} else {\r\nnew_addr = pci_map_single(tp->pdev, new_skb->data, new_skb->len,\r\nPCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(tp->pdev, new_addr)) {\r\ndev_kfree_skb_any(new_skb);\r\nret = -1;\r\n} else {\r\nu32 save_entry = *entry;\r\nbase_flags |= TXD_FLAG_END;\r\ntnapi->tx_buffers[*entry].skb = new_skb;\r\ndma_unmap_addr_set(&tnapi->tx_buffers[*entry],\r\nmapping, new_addr);\r\nif (tg3_tx_frag_set(tnapi, entry, budget, new_addr,\r\nnew_skb->len, base_flags,\r\nmss, vlan)) {\r\ntg3_tx_skb_unmap(tnapi, save_entry, -1);\r\ndev_kfree_skb_any(new_skb);\r\nret = -1;\r\n}\r\n}\r\n}\r\ndev_kfree_skb_any(skb);\r\n*pskb = new_skb;\r\nreturn ret;\r\n}\r\nstatic int tg3_tso_bug(struct tg3 *tp, struct tg3_napi *tnapi,\r\nstruct netdev_queue *txq, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *segs, *nskb;\r\nu32 frag_cnt_est = skb_shinfo(skb)->gso_segs * 3;\r\nif (unlikely(tg3_tx_avail(tnapi) <= frag_cnt_est)) {\r\nnetif_tx_stop_queue(txq);\r\nsmp_mb();\r\nif (tg3_tx_avail(tnapi) <= frag_cnt_est)\r\nreturn NETDEV_TX_BUSY;\r\nnetif_tx_wake_queue(txq);\r\n}\r\nsegs = skb_gso_segment(skb, tp->dev->features &\r\n~(NETIF_F_TSO | NETIF_F_TSO6));\r\nif (IS_ERR(segs) || !segs)\r\ngoto tg3_tso_bug_end;\r\ndo {\r\nnskb = segs;\r\nsegs = segs->next;\r\nnskb->next = NULL;\r\ntg3_start_xmit(nskb, tp->dev);\r\n} while (segs);\r\ntg3_tso_bug_end:\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic netdev_tx_t tg3_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nu32 len, entry, base_flags, mss, vlan = 0;\r\nu32 budget;\r\nint i = -1, would_hit_hwbug;\r\ndma_addr_t mapping;\r\nstruct tg3_napi *tnapi;\r\nstruct netdev_queue *txq;\r\nunsigned int last;\r\nstruct iphdr *iph = NULL;\r\nstruct tcphdr *tcph = NULL;\r\n__sum16 tcp_csum = 0, ip_csum = 0;\r\n__be16 ip_tot_len = 0;\r\ntxq = netdev_get_tx_queue(dev, skb_get_queue_mapping(skb));\r\ntnapi = &tp->napi[skb_get_queue_mapping(skb)];\r\nif (tg3_flag(tp, ENABLE_TSS))\r\ntnapi++;\r\nbudget = tg3_tx_avail(tnapi);\r\nif (unlikely(budget <= (skb_shinfo(skb)->nr_frags + 1))) {\r\nif (!netif_tx_queue_stopped(txq)) {\r\nnetif_tx_stop_queue(txq);\r\nnetdev_err(dev,\r\n"BUG! Tx Ring full when queue awake!\n");\r\n}\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nentry = tnapi->tx_prod;\r\nbase_flags = 0;\r\nmss = skb_shinfo(skb)->gso_size;\r\nif (mss) {\r\nu32 tcp_opt_len, hdr_len;\r\nif (skb_cow_head(skb, 0))\r\ngoto drop;\r\niph = ip_hdr(skb);\r\ntcp_opt_len = tcp_optlen(skb);\r\nhdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb) - ETH_HLEN;\r\nif (skb->protocol == htons(ETH_P_8021Q) ||\r\nskb->protocol == htons(ETH_P_8021AD))\r\nreturn tg3_tso_bug(tp, tnapi, txq, skb);\r\nif (!skb_is_gso_v6(skb)) {\r\nif (unlikely((ETH_HLEN + hdr_len) > 80) &&\r\ntg3_flag(tp, TSO_BUG))\r\nreturn tg3_tso_bug(tp, tnapi, txq, skb);\r\nip_csum = iph->check;\r\nip_tot_len = iph->tot_len;\r\niph->check = 0;\r\niph->tot_len = htons(mss + hdr_len);\r\n}\r\nbase_flags |= (TXD_FLAG_CPU_PRE_DMA |\r\nTXD_FLAG_CPU_POST_DMA);\r\ntcph = tcp_hdr(skb);\r\ntcp_csum = tcph->check;\r\nif (tg3_flag(tp, HW_TSO_1) ||\r\ntg3_flag(tp, HW_TSO_2) ||\r\ntg3_flag(tp, HW_TSO_3)) {\r\ntcph->check = 0;\r\nbase_flags &= ~TXD_FLAG_TCPUDP_CSUM;\r\n} else {\r\ntcph->check = ~csum_tcpudp_magic(iph->saddr, iph->daddr,\r\n0, IPPROTO_TCP, 0);\r\n}\r\nif (tg3_flag(tp, HW_TSO_3)) {\r\nmss |= (hdr_len & 0xc) << 12;\r\nif (hdr_len & 0x10)\r\nbase_flags |= 0x00000010;\r\nbase_flags |= (hdr_len & 0x3e0) << 5;\r\n} else if (tg3_flag(tp, HW_TSO_2))\r\nmss |= hdr_len << 9;\r\nelse if (tg3_flag(tp, HW_TSO_1) ||\r\ntg3_asic_rev(tp) == ASIC_REV_5705) {\r\nif (tcp_opt_len || iph->ihl > 5) {\r\nint tsflags;\r\ntsflags = (iph->ihl - 5) + (tcp_opt_len >> 2);\r\nmss |= (tsflags << 11);\r\n}\r\n} else {\r\nif (tcp_opt_len || iph->ihl > 5) {\r\nint tsflags;\r\ntsflags = (iph->ihl - 5) + (tcp_opt_len >> 2);\r\nbase_flags |= tsflags << 12;\r\n}\r\n}\r\n} else if (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nif (skb->protocol == htons(ETH_P_8021Q) ||\r\nskb->protocol == htons(ETH_P_8021AD)) {\r\nif (skb_checksum_help(skb))\r\ngoto drop;\r\n} else {\r\nbase_flags |= TXD_FLAG_TCPUDP_CSUM;\r\n}\r\n}\r\nif (tg3_flag(tp, USE_JUMBO_BDFLAG) &&\r\n!mss && skb->len > VLAN_ETH_FRAME_LEN)\r\nbase_flags |= TXD_FLAG_JMB_PKT;\r\nif (skb_vlan_tag_present(skb)) {\r\nbase_flags |= TXD_FLAG_VLAN;\r\nvlan = skb_vlan_tag_get(skb);\r\n}\r\nif ((unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) &&\r\ntg3_flag(tp, TX_TSTAMP_EN)) {\r\nskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\r\nbase_flags |= TXD_FLAG_HWTSTAMP;\r\n}\r\nlen = skb_headlen(skb);\r\nmapping = pci_map_single(tp->pdev, skb->data, len, PCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(tp->pdev, mapping))\r\ngoto drop;\r\ntnapi->tx_buffers[entry].skb = skb;\r\ndma_unmap_addr_set(&tnapi->tx_buffers[entry], mapping, mapping);\r\nwould_hit_hwbug = 0;\r\nif (tg3_flag(tp, 5701_DMA_BUG))\r\nwould_hit_hwbug = 1;\r\nif (tg3_tx_frag_set(tnapi, &entry, &budget, mapping, len, base_flags |\r\n((skb_shinfo(skb)->nr_frags == 0) ? TXD_FLAG_END : 0),\r\nmss, vlan)) {\r\nwould_hit_hwbug = 1;\r\n} else if (skb_shinfo(skb)->nr_frags > 0) {\r\nu32 tmp_mss = mss;\r\nif (!tg3_flag(tp, HW_TSO_1) &&\r\n!tg3_flag(tp, HW_TSO_2) &&\r\n!tg3_flag(tp, HW_TSO_3))\r\ntmp_mss = 0;\r\nlast = skb_shinfo(skb)->nr_frags - 1;\r\nfor (i = 0; i <= last; i++) {\r\nskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\r\nlen = skb_frag_size(frag);\r\nmapping = skb_frag_dma_map(&tp->pdev->dev, frag, 0,\r\nlen, DMA_TO_DEVICE);\r\ntnapi->tx_buffers[entry].skb = NULL;\r\ndma_unmap_addr_set(&tnapi->tx_buffers[entry], mapping,\r\nmapping);\r\nif (dma_mapping_error(&tp->pdev->dev, mapping))\r\ngoto dma_error;\r\nif (!budget ||\r\ntg3_tx_frag_set(tnapi, &entry, &budget, mapping,\r\nlen, base_flags |\r\n((i == last) ? TXD_FLAG_END : 0),\r\ntmp_mss, vlan)) {\r\nwould_hit_hwbug = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (would_hit_hwbug) {\r\ntg3_tx_skb_unmap(tnapi, tnapi->tx_prod, i);\r\nif (mss) {\r\nif (ip_tot_len) {\r\niph->check = ip_csum;\r\niph->tot_len = ip_tot_len;\r\n}\r\ntcph->check = tcp_csum;\r\nreturn tg3_tso_bug(tp, tnapi, txq, skb);\r\n}\r\nentry = tnapi->tx_prod;\r\nbudget = tg3_tx_avail(tnapi);\r\nif (tigon3_dma_hwbug_workaround(tnapi, &skb, &entry, &budget,\r\nbase_flags, mss, vlan))\r\ngoto drop_nofree;\r\n}\r\nskb_tx_timestamp(skb);\r\nnetdev_tx_sent_queue(txq, skb->len);\r\nwmb();\r\ntnapi->tx_prod = entry;\r\nif (unlikely(tg3_tx_avail(tnapi) <= (MAX_SKB_FRAGS + 1))) {\r\nnetif_tx_stop_queue(txq);\r\nsmp_mb();\r\nif (tg3_tx_avail(tnapi) > TG3_TX_WAKEUP_THRESH(tnapi))\r\nnetif_tx_wake_queue(txq);\r\n}\r\nif (!skb->xmit_more || netif_xmit_stopped(txq)) {\r\ntw32_tx_mbox(tnapi->prodmbox, entry);\r\nmmiowb();\r\n}\r\nreturn NETDEV_TX_OK;\r\ndma_error:\r\ntg3_tx_skb_unmap(tnapi, tnapi->tx_prod, --i);\r\ntnapi->tx_buffers[tnapi->tx_prod].skb = NULL;\r\ndrop:\r\ndev_kfree_skb_any(skb);\r\ndrop_nofree:\r\ntp->tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void tg3_mac_loopback(struct tg3 *tp, bool enable)\r\n{\r\nif (enable) {\r\ntp->mac_mode &= ~(MAC_MODE_HALF_DUPLEX |\r\nMAC_MODE_PORT_MODE_MASK);\r\ntp->mac_mode |= MAC_MODE_PORT_INT_LPBACK;\r\nif (!tg3_flag(tp, 5705_PLUS))\r\ntp->mac_mode |= MAC_MODE_LINK_POLARITY;\r\nif (tp->phy_flags & TG3_PHYFLG_10_100_ONLY)\r\ntp->mac_mode |= MAC_MODE_PORT_MODE_MII;\r\nelse\r\ntp->mac_mode |= MAC_MODE_PORT_MODE_GMII;\r\n} else {\r\ntp->mac_mode &= ~MAC_MODE_PORT_INT_LPBACK;\r\nif (tg3_flag(tp, 5705_PLUS) ||\r\n(tp->phy_flags & TG3_PHYFLG_PHY_SERDES) ||\r\ntg3_asic_rev(tp) == ASIC_REV_5700)\r\ntp->mac_mode &= ~MAC_MODE_LINK_POLARITY;\r\n}\r\ntw32(MAC_MODE, tp->mac_mode);\r\nudelay(40);\r\n}\r\nstatic int tg3_phy_lpbk_set(struct tg3 *tp, u32 speed, bool extlpbk)\r\n{\r\nu32 val, bmcr, mac_mode, ptest = 0;\r\ntg3_phy_toggle_apd(tp, false);\r\ntg3_phy_toggle_automdix(tp, false);\r\nif (extlpbk && tg3_phy_set_extloopbk(tp))\r\nreturn -EIO;\r\nbmcr = BMCR_FULLDPLX;\r\nswitch (speed) {\r\ncase SPEED_10:\r\nbreak;\r\ncase SPEED_100:\r\nbmcr |= BMCR_SPEED100;\r\nbreak;\r\ncase SPEED_1000:\r\ndefault:\r\nif (tp->phy_flags & TG3_PHYFLG_IS_FET) {\r\nspeed = SPEED_100;\r\nbmcr |= BMCR_SPEED100;\r\n} else {\r\nspeed = SPEED_1000;\r\nbmcr |= BMCR_SPEED1000;\r\n}\r\n}\r\nif (extlpbk) {\r\nif (!(tp->phy_flags & TG3_PHYFLG_IS_FET)) {\r\ntg3_readphy(tp, MII_CTRL1000, &val);\r\nval |= CTL1000_AS_MASTER |\r\nCTL1000_ENABLE_MASTER;\r\ntg3_writephy(tp, MII_CTRL1000, val);\r\n} else {\r\nptest = MII_TG3_FET_PTEST_TRIM_SEL |\r\nMII_TG3_FET_PTEST_TRIM_2;\r\ntg3_writephy(tp, MII_TG3_FET_PTEST, ptest);\r\n}\r\n} else\r\nbmcr |= BMCR_LOOPBACK;\r\ntg3_writephy(tp, MII_BMCR, bmcr);\r\nif (tp->phy_flags & TG3_PHYFLG_IS_FET)\r\ntg3_readphy(tp, MII_BMCR, &bmcr);\r\nudelay(40);\r\nif ((tp->phy_flags & TG3_PHYFLG_IS_FET) &&\r\ntg3_asic_rev(tp) == ASIC_REV_5785) {\r\ntg3_writephy(tp, MII_TG3_FET_PTEST, ptest |\r\nMII_TG3_FET_PTEST_FRC_TX_LINK |\r\nMII_TG3_FET_PTEST_FRC_TX_LOCK);\r\ntg3_readphy(tp, MII_TG3_FET_PTEST, &val);\r\n}\r\nif ((tp->phy_flags & TG3_PHYFLG_MII_SERDES) &&\r\ntg3_flag(tp, 5780_CLASS)) {\r\ntw32_f(MAC_RX_MODE, RX_MODE_RESET);\r\nudelay(10);\r\ntw32_f(MAC_RX_MODE, tp->rx_mode);\r\n}\r\nmac_mode = tp->mac_mode &\r\n~(MAC_MODE_PORT_MODE_MASK | MAC_MODE_HALF_DUPLEX);\r\nif (speed == SPEED_1000)\r\nmac_mode |= MAC_MODE_PORT_MODE_GMII;\r\nelse\r\nmac_mode |= MAC_MODE_PORT_MODE_MII;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5700) {\r\nu32 masked_phy_id = tp->phy_id & TG3_PHY_ID_MASK;\r\nif (masked_phy_id == TG3_PHY_ID_BCM5401)\r\nmac_mode &= ~MAC_MODE_LINK_POLARITY;\r\nelse if (masked_phy_id == TG3_PHY_ID_BCM5411)\r\nmac_mode |= MAC_MODE_LINK_POLARITY;\r\ntg3_writephy(tp, MII_TG3_EXT_CTRL,\r\nMII_TG3_EXT_CTRL_LNK3_LED_MODE);\r\n}\r\ntw32(MAC_MODE, mac_mode);\r\nudelay(40);\r\nreturn 0;\r\n}\r\nstatic void tg3_set_loopback(struct net_device *dev, netdev_features_t features)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nif (features & NETIF_F_LOOPBACK) {\r\nif (tp->mac_mode & MAC_MODE_PORT_INT_LPBACK)\r\nreturn;\r\nspin_lock_bh(&tp->lock);\r\ntg3_mac_loopback(tp, true);\r\nnetif_carrier_on(tp->dev);\r\nspin_unlock_bh(&tp->lock);\r\nnetdev_info(dev, "Internal MAC loopback mode enabled.\n");\r\n} else {\r\nif (!(tp->mac_mode & MAC_MODE_PORT_INT_LPBACK))\r\nreturn;\r\nspin_lock_bh(&tp->lock);\r\ntg3_mac_loopback(tp, false);\r\ntg3_setup_phy(tp, true);\r\nspin_unlock_bh(&tp->lock);\r\nnetdev_info(dev, "Internal MAC loopback mode disabled.\n");\r\n}\r\n}\r\nstatic netdev_features_t tg3_fix_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nif (dev->mtu > ETH_DATA_LEN && tg3_flag(tp, 5780_CLASS))\r\nfeatures &= ~NETIF_F_ALL_TSO;\r\nreturn features;\r\n}\r\nstatic int tg3_set_features(struct net_device *dev, netdev_features_t features)\r\n{\r\nnetdev_features_t changed = dev->features ^ features;\r\nif ((changed & NETIF_F_LOOPBACK) && netif_running(dev))\r\ntg3_set_loopback(dev, features);\r\nreturn 0;\r\n}\r\nstatic void tg3_rx_prodring_free(struct tg3 *tp,\r\nstruct tg3_rx_prodring_set *tpr)\r\n{\r\nint i;\r\nif (tpr != &tp->napi[0].prodring) {\r\nfor (i = tpr->rx_std_cons_idx; i != tpr->rx_std_prod_idx;\r\ni = (i + 1) & tp->rx_std_ring_mask)\r\ntg3_rx_data_free(tp, &tpr->rx_std_buffers[i],\r\ntp->rx_pkt_map_sz);\r\nif (tg3_flag(tp, JUMBO_CAPABLE)) {\r\nfor (i = tpr->rx_jmb_cons_idx;\r\ni != tpr->rx_jmb_prod_idx;\r\ni = (i + 1) & tp->rx_jmb_ring_mask) {\r\ntg3_rx_data_free(tp, &tpr->rx_jmb_buffers[i],\r\nTG3_RX_JMB_MAP_SZ);\r\n}\r\n}\r\nreturn;\r\n}\r\nfor (i = 0; i <= tp->rx_std_ring_mask; i++)\r\ntg3_rx_data_free(tp, &tpr->rx_std_buffers[i],\r\ntp->rx_pkt_map_sz);\r\nif (tg3_flag(tp, JUMBO_CAPABLE) && !tg3_flag(tp, 5780_CLASS)) {\r\nfor (i = 0; i <= tp->rx_jmb_ring_mask; i++)\r\ntg3_rx_data_free(tp, &tpr->rx_jmb_buffers[i],\r\nTG3_RX_JMB_MAP_SZ);\r\n}\r\n}\r\nstatic int tg3_rx_prodring_alloc(struct tg3 *tp,\r\nstruct tg3_rx_prodring_set *tpr)\r\n{\r\nu32 i, rx_pkt_dma_sz;\r\ntpr->rx_std_cons_idx = 0;\r\ntpr->rx_std_prod_idx = 0;\r\ntpr->rx_jmb_cons_idx = 0;\r\ntpr->rx_jmb_prod_idx = 0;\r\nif (tpr != &tp->napi[0].prodring) {\r\nmemset(&tpr->rx_std_buffers[0], 0,\r\nTG3_RX_STD_BUFF_RING_SIZE(tp));\r\nif (tpr->rx_jmb_buffers)\r\nmemset(&tpr->rx_jmb_buffers[0], 0,\r\nTG3_RX_JMB_BUFF_RING_SIZE(tp));\r\ngoto done;\r\n}\r\nmemset(tpr->rx_std, 0, TG3_RX_STD_RING_BYTES(tp));\r\nrx_pkt_dma_sz = TG3_RX_STD_DMA_SZ;\r\nif (tg3_flag(tp, 5780_CLASS) &&\r\ntp->dev->mtu > ETH_DATA_LEN)\r\nrx_pkt_dma_sz = TG3_RX_JMB_DMA_SZ;\r\ntp->rx_pkt_map_sz = TG3_RX_DMA_TO_MAP_SZ(rx_pkt_dma_sz);\r\nfor (i = 0; i <= tp->rx_std_ring_mask; i++) {\r\nstruct tg3_rx_buffer_desc *rxd;\r\nrxd = &tpr->rx_std[i];\r\nrxd->idx_len = rx_pkt_dma_sz << RXD_LEN_SHIFT;\r\nrxd->type_flags = (RXD_FLAG_END << RXD_FLAGS_SHIFT);\r\nrxd->opaque = (RXD_OPAQUE_RING_STD |\r\n(i << RXD_OPAQUE_INDEX_SHIFT));\r\n}\r\nfor (i = 0; i < tp->rx_pending; i++) {\r\nunsigned int frag_size;\r\nif (tg3_alloc_rx_data(tp, tpr, RXD_OPAQUE_RING_STD, i,\r\n&frag_size) < 0) {\r\nnetdev_warn(tp->dev,\r\n"Using a smaller RX standard ring. Only "\r\n"%d out of %d buffers were allocated "\r\n"successfully\n", i, tp->rx_pending);\r\nif (i == 0)\r\ngoto initfail;\r\ntp->rx_pending = i;\r\nbreak;\r\n}\r\n}\r\nif (!tg3_flag(tp, JUMBO_CAPABLE) || tg3_flag(tp, 5780_CLASS))\r\ngoto done;\r\nmemset(tpr->rx_jmb, 0, TG3_RX_JMB_RING_BYTES(tp));\r\nif (!tg3_flag(tp, JUMBO_RING_ENABLE))\r\ngoto done;\r\nfor (i = 0; i <= tp->rx_jmb_ring_mask; i++) {\r\nstruct tg3_rx_buffer_desc *rxd;\r\nrxd = &tpr->rx_jmb[i].std;\r\nrxd->idx_len = TG3_RX_JMB_DMA_SZ << RXD_LEN_SHIFT;\r\nrxd->type_flags = (RXD_FLAG_END << RXD_FLAGS_SHIFT) |\r\nRXD_FLAG_JUMBO;\r\nrxd->opaque = (RXD_OPAQUE_RING_JUMBO |\r\n(i << RXD_OPAQUE_INDEX_SHIFT));\r\n}\r\nfor (i = 0; i < tp->rx_jumbo_pending; i++) {\r\nunsigned int frag_size;\r\nif (tg3_alloc_rx_data(tp, tpr, RXD_OPAQUE_RING_JUMBO, i,\r\n&frag_size) < 0) {\r\nnetdev_warn(tp->dev,\r\n"Using a smaller RX jumbo ring. Only %d "\r\n"out of %d buffers were allocated "\r\n"successfully\n", i, tp->rx_jumbo_pending);\r\nif (i == 0)\r\ngoto initfail;\r\ntp->rx_jumbo_pending = i;\r\nbreak;\r\n}\r\n}\r\ndone:\r\nreturn 0;\r\ninitfail:\r\ntg3_rx_prodring_free(tp, tpr);\r\nreturn -ENOMEM;\r\n}\r\nstatic void tg3_rx_prodring_fini(struct tg3 *tp,\r\nstruct tg3_rx_prodring_set *tpr)\r\n{\r\nkfree(tpr->rx_std_buffers);\r\ntpr->rx_std_buffers = NULL;\r\nkfree(tpr->rx_jmb_buffers);\r\ntpr->rx_jmb_buffers = NULL;\r\nif (tpr->rx_std) {\r\ndma_free_coherent(&tp->pdev->dev, TG3_RX_STD_RING_BYTES(tp),\r\ntpr->rx_std, tpr->rx_std_mapping);\r\ntpr->rx_std = NULL;\r\n}\r\nif (tpr->rx_jmb) {\r\ndma_free_coherent(&tp->pdev->dev, TG3_RX_JMB_RING_BYTES(tp),\r\ntpr->rx_jmb, tpr->rx_jmb_mapping);\r\ntpr->rx_jmb = NULL;\r\n}\r\n}\r\nstatic int tg3_rx_prodring_init(struct tg3 *tp,\r\nstruct tg3_rx_prodring_set *tpr)\r\n{\r\ntpr->rx_std_buffers = kzalloc(TG3_RX_STD_BUFF_RING_SIZE(tp),\r\nGFP_KERNEL);\r\nif (!tpr->rx_std_buffers)\r\nreturn -ENOMEM;\r\ntpr->rx_std = dma_alloc_coherent(&tp->pdev->dev,\r\nTG3_RX_STD_RING_BYTES(tp),\r\n&tpr->rx_std_mapping,\r\nGFP_KERNEL);\r\nif (!tpr->rx_std)\r\ngoto err_out;\r\nif (tg3_flag(tp, JUMBO_CAPABLE) && !tg3_flag(tp, 5780_CLASS)) {\r\ntpr->rx_jmb_buffers = kzalloc(TG3_RX_JMB_BUFF_RING_SIZE(tp),\r\nGFP_KERNEL);\r\nif (!tpr->rx_jmb_buffers)\r\ngoto err_out;\r\ntpr->rx_jmb = dma_alloc_coherent(&tp->pdev->dev,\r\nTG3_RX_JMB_RING_BYTES(tp),\r\n&tpr->rx_jmb_mapping,\r\nGFP_KERNEL);\r\nif (!tpr->rx_jmb)\r\ngoto err_out;\r\n}\r\nreturn 0;\r\nerr_out:\r\ntg3_rx_prodring_fini(tp, tpr);\r\nreturn -ENOMEM;\r\n}\r\nstatic void tg3_free_rings(struct tg3 *tp)\r\n{\r\nint i, j;\r\nfor (j = 0; j < tp->irq_cnt; j++) {\r\nstruct tg3_napi *tnapi = &tp->napi[j];\r\ntg3_rx_prodring_free(tp, &tnapi->prodring);\r\nif (!tnapi->tx_buffers)\r\ncontinue;\r\nfor (i = 0; i < TG3_TX_RING_SIZE; i++) {\r\nstruct sk_buff *skb = tnapi->tx_buffers[i].skb;\r\nif (!skb)\r\ncontinue;\r\ntg3_tx_skb_unmap(tnapi, i,\r\nskb_shinfo(skb)->nr_frags - 1);\r\ndev_kfree_skb_any(skb);\r\n}\r\nnetdev_tx_reset_queue(netdev_get_tx_queue(tp->dev, j));\r\n}\r\n}\r\nstatic int tg3_init_rings(struct tg3 *tp)\r\n{\r\nint i;\r\ntg3_free_rings(tp);\r\nfor (i = 0; i < tp->irq_cnt; i++) {\r\nstruct tg3_napi *tnapi = &tp->napi[i];\r\ntnapi->last_tag = 0;\r\ntnapi->last_irq_tag = 0;\r\ntnapi->hw_status->status = 0;\r\ntnapi->hw_status->status_tag = 0;\r\nmemset(tnapi->hw_status, 0, TG3_HW_STATUS_SIZE);\r\ntnapi->tx_prod = 0;\r\ntnapi->tx_cons = 0;\r\nif (tnapi->tx_ring)\r\nmemset(tnapi->tx_ring, 0, TG3_TX_RING_BYTES);\r\ntnapi->rx_rcb_ptr = 0;\r\nif (tnapi->rx_rcb)\r\nmemset(tnapi->rx_rcb, 0, TG3_RX_RCB_RING_BYTES(tp));\r\nif (tnapi->prodring.rx_std &&\r\ntg3_rx_prodring_alloc(tp, &tnapi->prodring)) {\r\ntg3_free_rings(tp);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void tg3_mem_tx_release(struct tg3 *tp)\r\n{\r\nint i;\r\nfor (i = 0; i < tp->irq_max; i++) {\r\nstruct tg3_napi *tnapi = &tp->napi[i];\r\nif (tnapi->tx_ring) {\r\ndma_free_coherent(&tp->pdev->dev, TG3_TX_RING_BYTES,\r\ntnapi->tx_ring, tnapi->tx_desc_mapping);\r\ntnapi->tx_ring = NULL;\r\n}\r\nkfree(tnapi->tx_buffers);\r\ntnapi->tx_buffers = NULL;\r\n}\r\n}\r\nstatic int tg3_mem_tx_acquire(struct tg3 *tp)\r\n{\r\nint i;\r\nstruct tg3_napi *tnapi = &tp->napi[0];\r\nif (tg3_flag(tp, ENABLE_TSS))\r\ntnapi++;\r\nfor (i = 0; i < tp->txq_cnt; i++, tnapi++) {\r\ntnapi->tx_buffers = kzalloc(sizeof(struct tg3_tx_ring_info) *\r\nTG3_TX_RING_SIZE, GFP_KERNEL);\r\nif (!tnapi->tx_buffers)\r\ngoto err_out;\r\ntnapi->tx_ring = dma_alloc_coherent(&tp->pdev->dev,\r\nTG3_TX_RING_BYTES,\r\n&tnapi->tx_desc_mapping,\r\nGFP_KERNEL);\r\nif (!tnapi->tx_ring)\r\ngoto err_out;\r\n}\r\nreturn 0;\r\nerr_out:\r\ntg3_mem_tx_release(tp);\r\nreturn -ENOMEM;\r\n}\r\nstatic void tg3_mem_rx_release(struct tg3 *tp)\r\n{\r\nint i;\r\nfor (i = 0; i < tp->irq_max; i++) {\r\nstruct tg3_napi *tnapi = &tp->napi[i];\r\ntg3_rx_prodring_fini(tp, &tnapi->prodring);\r\nif (!tnapi->rx_rcb)\r\ncontinue;\r\ndma_free_coherent(&tp->pdev->dev,\r\nTG3_RX_RCB_RING_BYTES(tp),\r\ntnapi->rx_rcb,\r\ntnapi->rx_rcb_mapping);\r\ntnapi->rx_rcb = NULL;\r\n}\r\n}\r\nstatic int tg3_mem_rx_acquire(struct tg3 *tp)\r\n{\r\nunsigned int i, limit;\r\nlimit = tp->rxq_cnt;\r\nif (tg3_flag(tp, ENABLE_RSS))\r\nlimit++;\r\nfor (i = 0; i < limit; i++) {\r\nstruct tg3_napi *tnapi = &tp->napi[i];\r\nif (tg3_rx_prodring_init(tp, &tnapi->prodring))\r\ngoto err_out;\r\nif (!i && tg3_flag(tp, ENABLE_RSS))\r\ncontinue;\r\ntnapi->rx_rcb = dma_zalloc_coherent(&tp->pdev->dev,\r\nTG3_RX_RCB_RING_BYTES(tp),\r\n&tnapi->rx_rcb_mapping,\r\nGFP_KERNEL);\r\nif (!tnapi->rx_rcb)\r\ngoto err_out;\r\n}\r\nreturn 0;\r\nerr_out:\r\ntg3_mem_rx_release(tp);\r\nreturn -ENOMEM;\r\n}\r\nstatic void tg3_free_consistent(struct tg3 *tp)\r\n{\r\nint i;\r\nfor (i = 0; i < tp->irq_cnt; i++) {\r\nstruct tg3_napi *tnapi = &tp->napi[i];\r\nif (tnapi->hw_status) {\r\ndma_free_coherent(&tp->pdev->dev, TG3_HW_STATUS_SIZE,\r\ntnapi->hw_status,\r\ntnapi->status_mapping);\r\ntnapi->hw_status = NULL;\r\n}\r\n}\r\ntg3_mem_rx_release(tp);\r\ntg3_mem_tx_release(tp);\r\nif (tp->hw_stats) {\r\ndma_free_coherent(&tp->pdev->dev, sizeof(struct tg3_hw_stats),\r\ntp->hw_stats, tp->stats_mapping);\r\ntp->hw_stats = NULL;\r\n}\r\n}\r\nstatic int tg3_alloc_consistent(struct tg3 *tp)\r\n{\r\nint i;\r\ntp->hw_stats = dma_zalloc_coherent(&tp->pdev->dev,\r\nsizeof(struct tg3_hw_stats),\r\n&tp->stats_mapping, GFP_KERNEL);\r\nif (!tp->hw_stats)\r\ngoto err_out;\r\nfor (i = 0; i < tp->irq_cnt; i++) {\r\nstruct tg3_napi *tnapi = &tp->napi[i];\r\nstruct tg3_hw_status *sblk;\r\ntnapi->hw_status = dma_zalloc_coherent(&tp->pdev->dev,\r\nTG3_HW_STATUS_SIZE,\r\n&tnapi->status_mapping,\r\nGFP_KERNEL);\r\nif (!tnapi->hw_status)\r\ngoto err_out;\r\nsblk = tnapi->hw_status;\r\nif (tg3_flag(tp, ENABLE_RSS)) {\r\nu16 *prodptr = NULL;\r\nswitch (i) {\r\ncase 1:\r\nprodptr = &sblk->idx[0].rx_producer;\r\nbreak;\r\ncase 2:\r\nprodptr = &sblk->rx_jumbo_consumer;\r\nbreak;\r\ncase 3:\r\nprodptr = &sblk->reserved;\r\nbreak;\r\ncase 4:\r\nprodptr = &sblk->rx_mini_consumer;\r\nbreak;\r\n}\r\ntnapi->rx_rcb_prod_idx = prodptr;\r\n} else {\r\ntnapi->rx_rcb_prod_idx = &sblk->idx[0].rx_producer;\r\n}\r\n}\r\nif (tg3_mem_tx_acquire(tp) || tg3_mem_rx_acquire(tp))\r\ngoto err_out;\r\nreturn 0;\r\nerr_out:\r\ntg3_free_consistent(tp);\r\nreturn -ENOMEM;\r\n}\r\nstatic int tg3_stop_block(struct tg3 *tp, unsigned long ofs, u32 enable_bit, bool silent)\r\n{\r\nunsigned int i;\r\nu32 val;\r\nif (tg3_flag(tp, 5705_PLUS)) {\r\nswitch (ofs) {\r\ncase RCVLSC_MODE:\r\ncase DMAC_MODE:\r\ncase MBFREE_MODE:\r\ncase BUFMGR_MODE:\r\ncase MEMARB_MODE:\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nval = tr32(ofs);\r\nval &= ~enable_bit;\r\ntw32_f(ofs, val);\r\nfor (i = 0; i < MAX_WAIT_CNT; i++) {\r\nif (pci_channel_offline(tp->pdev)) {\r\ndev_err(&tp->pdev->dev,\r\n"tg3_stop_block device offline, "\r\n"ofs=%lx enable_bit=%x\n",\r\nofs, enable_bit);\r\nreturn -ENODEV;\r\n}\r\nudelay(100);\r\nval = tr32(ofs);\r\nif ((val & enable_bit) == 0)\r\nbreak;\r\n}\r\nif (i == MAX_WAIT_CNT && !silent) {\r\ndev_err(&tp->pdev->dev,\r\n"tg3_stop_block timed out, ofs=%lx enable_bit=%x\n",\r\nofs, enable_bit);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tg3_abort_hw(struct tg3 *tp, bool silent)\r\n{\r\nint i, err;\r\ntg3_disable_ints(tp);\r\nif (pci_channel_offline(tp->pdev)) {\r\ntp->rx_mode &= ~(RX_MODE_ENABLE | TX_MODE_ENABLE);\r\ntp->mac_mode &= ~MAC_MODE_TDE_ENABLE;\r\nerr = -ENODEV;\r\ngoto err_no_dev;\r\n}\r\ntp->rx_mode &= ~RX_MODE_ENABLE;\r\ntw32_f(MAC_RX_MODE, tp->rx_mode);\r\nudelay(10);\r\nerr = tg3_stop_block(tp, RCVBDI_MODE, RCVBDI_MODE_ENABLE, silent);\r\nerr |= tg3_stop_block(tp, RCVLPC_MODE, RCVLPC_MODE_ENABLE, silent);\r\nerr |= tg3_stop_block(tp, RCVLSC_MODE, RCVLSC_MODE_ENABLE, silent);\r\nerr |= tg3_stop_block(tp, RCVDBDI_MODE, RCVDBDI_MODE_ENABLE, silent);\r\nerr |= tg3_stop_block(tp, RCVDCC_MODE, RCVDCC_MODE_ENABLE, silent);\r\nerr |= tg3_stop_block(tp, RCVCC_MODE, RCVCC_MODE_ENABLE, silent);\r\nerr |= tg3_stop_block(tp, SNDBDS_MODE, SNDBDS_MODE_ENABLE, silent);\r\nerr |= tg3_stop_block(tp, SNDBDI_MODE, SNDBDI_MODE_ENABLE, silent);\r\nerr |= tg3_stop_block(tp, SNDDATAI_MODE, SNDDATAI_MODE_ENABLE, silent);\r\nerr |= tg3_stop_block(tp, RDMAC_MODE, RDMAC_MODE_ENABLE, silent);\r\nerr |= tg3_stop_block(tp, SNDDATAC_MODE, SNDDATAC_MODE_ENABLE, silent);\r\nerr |= tg3_stop_block(tp, DMAC_MODE, DMAC_MODE_ENABLE, silent);\r\nerr |= tg3_stop_block(tp, SNDBDC_MODE, SNDBDC_MODE_ENABLE, silent);\r\ntp->mac_mode &= ~MAC_MODE_TDE_ENABLE;\r\ntw32_f(MAC_MODE, tp->mac_mode);\r\nudelay(40);\r\ntp->tx_mode &= ~TX_MODE_ENABLE;\r\ntw32_f(MAC_TX_MODE, tp->tx_mode);\r\nfor (i = 0; i < MAX_WAIT_CNT; i++) {\r\nudelay(100);\r\nif (!(tr32(MAC_TX_MODE) & TX_MODE_ENABLE))\r\nbreak;\r\n}\r\nif (i >= MAX_WAIT_CNT) {\r\ndev_err(&tp->pdev->dev,\r\n"%s timed out, TX_MODE_ENABLE will not clear "\r\n"MAC_TX_MODE=%08x\n", __func__, tr32(MAC_TX_MODE));\r\nerr |= -ENODEV;\r\n}\r\nerr |= tg3_stop_block(tp, HOSTCC_MODE, HOSTCC_MODE_ENABLE, silent);\r\nerr |= tg3_stop_block(tp, WDMAC_MODE, WDMAC_MODE_ENABLE, silent);\r\nerr |= tg3_stop_block(tp, MBFREE_MODE, MBFREE_MODE_ENABLE, silent);\r\ntw32(FTQ_RESET, 0xffffffff);\r\ntw32(FTQ_RESET, 0x00000000);\r\nerr |= tg3_stop_block(tp, BUFMGR_MODE, BUFMGR_MODE_ENABLE, silent);\r\nerr |= tg3_stop_block(tp, MEMARB_MODE, MEMARB_MODE_ENABLE, silent);\r\nerr_no_dev:\r\nfor (i = 0; i < tp->irq_cnt; i++) {\r\nstruct tg3_napi *tnapi = &tp->napi[i];\r\nif (tnapi->hw_status)\r\nmemset(tnapi->hw_status, 0, TG3_HW_STATUS_SIZE);\r\n}\r\nreturn err;\r\n}\r\nstatic void tg3_save_pci_state(struct tg3 *tp)\r\n{\r\npci_read_config_word(tp->pdev, PCI_COMMAND, &tp->pci_cmd);\r\n}\r\nstatic void tg3_restore_pci_state(struct tg3 *tp)\r\n{\r\nu32 val;\r\npci_write_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,\r\ntp->misc_host_ctrl);\r\nval = (PCISTATE_ROM_ENABLE | PCISTATE_ROM_RETRY_ENABLE);\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5704_A0 &&\r\ntg3_flag(tp, PCIX_MODE))\r\nval |= PCISTATE_RETRY_SAME_DMA;\r\nif (tg3_flag(tp, ENABLE_APE))\r\nval |= PCISTATE_ALLOW_APE_CTLSPC_WR |\r\nPCISTATE_ALLOW_APE_SHMEM_WR |\r\nPCISTATE_ALLOW_APE_PSPACE_WR;\r\npci_write_config_dword(tp->pdev, TG3PCI_PCISTATE, val);\r\npci_write_config_word(tp->pdev, PCI_COMMAND, tp->pci_cmd);\r\nif (!tg3_flag(tp, PCI_EXPRESS)) {\r\npci_write_config_byte(tp->pdev, PCI_CACHE_LINE_SIZE,\r\ntp->pci_cacheline_sz);\r\npci_write_config_byte(tp->pdev, PCI_LATENCY_TIMER,\r\ntp->pci_lat_timer);\r\n}\r\nif (tg3_flag(tp, PCIX_MODE)) {\r\nu16 pcix_cmd;\r\npci_read_config_word(tp->pdev, tp->pcix_cap + PCI_X_CMD,\r\n&pcix_cmd);\r\npcix_cmd &= ~PCI_X_CMD_ERO;\r\npci_write_config_word(tp->pdev, tp->pcix_cap + PCI_X_CMD,\r\npcix_cmd);\r\n}\r\nif (tg3_flag(tp, 5780_CLASS)) {\r\nif (tg3_flag(tp, USING_MSI)) {\r\nu16 ctrl;\r\npci_read_config_word(tp->pdev,\r\ntp->msi_cap + PCI_MSI_FLAGS,\r\n&ctrl);\r\npci_write_config_word(tp->pdev,\r\ntp->msi_cap + PCI_MSI_FLAGS,\r\nctrl | PCI_MSI_FLAGS_ENABLE);\r\nval = tr32(MSGINT_MODE);\r\ntw32(MSGINT_MODE, val | MSGINT_MODE_ENABLE);\r\n}\r\n}\r\n}\r\nstatic void tg3_override_clk(struct tg3 *tp)\r\n{\r\nu32 val;\r\nswitch (tg3_asic_rev(tp)) {\r\ncase ASIC_REV_5717:\r\nval = tr32(TG3_CPMU_CLCK_ORIDE_ENABLE);\r\ntw32(TG3_CPMU_CLCK_ORIDE_ENABLE, val |\r\nTG3_CPMU_MAC_ORIDE_ENABLE);\r\nbreak;\r\ncase ASIC_REV_5719:\r\ncase ASIC_REV_5720:\r\ntw32(TG3_CPMU_CLCK_ORIDE, CPMU_CLCK_ORIDE_MAC_ORIDE_EN);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\n}\r\nstatic void tg3_restore_clk(struct tg3 *tp)\r\n{\r\nu32 val;\r\nswitch (tg3_asic_rev(tp)) {\r\ncase ASIC_REV_5717:\r\nval = tr32(TG3_CPMU_CLCK_ORIDE_ENABLE);\r\ntw32(TG3_CPMU_CLCK_ORIDE_ENABLE,\r\nval & ~TG3_CPMU_MAC_ORIDE_ENABLE);\r\nbreak;\r\ncase ASIC_REV_5719:\r\ncase ASIC_REV_5720:\r\nval = tr32(TG3_CPMU_CLCK_ORIDE);\r\ntw32(TG3_CPMU_CLCK_ORIDE, val & ~CPMU_CLCK_ORIDE_MAC_ORIDE_EN);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\n}\r\nstatic int tg3_chip_reset(struct tg3 *tp)\r\n__releases(tp->lock)\r\n__acquires(tp->lock)\r\n{\r\nu32 val;\r\nvoid (*write_op)(struct tg3 *, u32, u32);\r\nint i, err;\r\nif (!pci_device_is_present(tp->pdev))\r\nreturn -ENODEV;\r\ntg3_nvram_lock(tp);\r\ntg3_ape_lock(tp, TG3_APE_LOCK_GRC);\r\ntp->nvram_lock_cnt = 0;\r\ntg3_save_pci_state(tp);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5752 ||\r\ntg3_flag(tp, 5755_PLUS))\r\ntw32(GRC_FASTBOOT_PC, 0);\r\nwrite_op = tp->write32;\r\nif (write_op == tg3_write_flush_reg32)\r\ntp->write32 = tg3_write32;\r\ntg3_flag_set(tp, CHIP_RESETTING);\r\nfor (i = 0; i < tp->irq_cnt; i++) {\r\nstruct tg3_napi *tnapi = &tp->napi[i];\r\nif (tnapi->hw_status) {\r\ntnapi->hw_status->status = 0;\r\ntnapi->hw_status->status_tag = 0;\r\n}\r\ntnapi->last_tag = 0;\r\ntnapi->last_irq_tag = 0;\r\n}\r\nsmp_mb();\r\ntg3_full_unlock(tp);\r\nfor (i = 0; i < tp->irq_cnt; i++)\r\nsynchronize_irq(tp->napi[i].irq_vec);\r\ntg3_full_lock(tp, 0);\r\nif (tg3_asic_rev(tp) == ASIC_REV_57780) {\r\nval = tr32(TG3_PCIE_LNKCTL) & ~TG3_PCIE_LNKCTL_L1_PLL_PD_EN;\r\ntw32(TG3_PCIE_LNKCTL, val | TG3_PCIE_LNKCTL_L1_PLL_PD_DIS);\r\n}\r\nval = GRC_MISC_CFG_CORECLK_RESET;\r\nif (tg3_flag(tp, PCI_EXPRESS)) {\r\nif (tg3_asic_rev(tp) != ASIC_REV_5785 &&\r\n!tg3_flag(tp, 57765_PLUS) &&\r\ntr32(TG3_PCIE_PHY_TSTCTL) ==\r\n(TG3_PCIE_PHY_TSTCTL_PCIE10 | TG3_PCIE_PHY_TSTCTL_PSCRAM))\r\ntw32(TG3_PCIE_PHY_TSTCTL, TG3_PCIE_PHY_TSTCTL_PSCRAM);\r\nif (tg3_chip_rev_id(tp) != CHIPREV_ID_5750_A0) {\r\ntw32(GRC_MISC_CFG, (1 << 29));\r\nval |= (1 << 29);\r\n}\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5906) {\r\ntw32(VCPU_STATUS, tr32(VCPU_STATUS) | VCPU_STATUS_DRV_RESET);\r\ntw32(GRC_VCPU_EXT_CTRL,\r\ntr32(GRC_VCPU_EXT_CTRL) & ~GRC_VCPU_EXT_CTRL_HALT_CPU);\r\n}\r\ntg3_override_clk(tp);\r\nif (tg3_flag(tp, 5705_PLUS) && !tg3_flag(tp, CPMU_PRESENT))\r\nval |= GRC_MISC_CFG_KEEP_GPHY_POWER;\r\ntw32(GRC_MISC_CFG, val);\r\ntp->write32 = write_op;\r\nudelay(120);\r\npci_read_config_dword(tp->pdev, PCI_COMMAND, &val);\r\nudelay(120);\r\nif (tg3_flag(tp, PCI_EXPRESS) && pci_is_pcie(tp->pdev)) {\r\nu16 val16;\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5750_A0) {\r\nint j;\r\nu32 cfg_val;\r\nfor (j = 0; j < 5000; j++)\r\nudelay(100);\r\npci_read_config_dword(tp->pdev, 0xc4, &cfg_val);\r\npci_write_config_dword(tp->pdev, 0xc4,\r\ncfg_val | (1 << 15));\r\n}\r\nval16 = PCI_EXP_DEVCTL_RELAX_EN | PCI_EXP_DEVCTL_NOSNOOP_EN;\r\nif (!tg3_flag(tp, CPMU_PRESENT))\r\nval16 |= PCI_EXP_DEVCTL_PAYLOAD;\r\npcie_capability_clear_word(tp->pdev, PCI_EXP_DEVCTL, val16);\r\npcie_capability_write_word(tp->pdev, PCI_EXP_DEVSTA,\r\nPCI_EXP_DEVSTA_CED |\r\nPCI_EXP_DEVSTA_NFED |\r\nPCI_EXP_DEVSTA_FED |\r\nPCI_EXP_DEVSTA_URD);\r\n}\r\ntg3_restore_pci_state(tp);\r\ntg3_flag_clear(tp, CHIP_RESETTING);\r\ntg3_flag_clear(tp, ERROR_PROCESSED);\r\nval = 0;\r\nif (tg3_flag(tp, 5780_CLASS))\r\nval = tr32(MEMARB_MODE);\r\ntw32(MEMARB_MODE, val | MEMARB_MODE_ENABLE);\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5750_A3) {\r\ntg3_stop_fw(tp);\r\ntw32(0x5000, 0x400);\r\n}\r\nif (tg3_flag(tp, IS_SSB_CORE)) {\r\ntg3_stop_fw(tp);\r\ntg3_halt_cpu(tp, RX_CPU_BASE);\r\n}\r\nerr = tg3_poll_fw(tp);\r\nif (err)\r\nreturn err;\r\ntw32(GRC_MODE, tp->grc_mode);\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5705_A0) {\r\nval = tr32(0xc4);\r\ntw32(0xc4, val | (1 << 15));\r\n}\r\nif ((tp->nic_sram_data_cfg & NIC_SRAM_DATA_CFG_MINI_PCI) != 0 &&\r\ntg3_asic_rev(tp) == ASIC_REV_5705) {\r\ntp->pci_clock_ctrl |= CLOCK_CTRL_CLKRUN_OENABLE;\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5705_A0)\r\ntp->pci_clock_ctrl |= CLOCK_CTRL_FORCE_CLKRUN;\r\ntw32(TG3PCI_CLOCK_CTRL, tp->pci_clock_ctrl);\r\n}\r\nif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES) {\r\ntp->mac_mode = MAC_MODE_PORT_MODE_TBI;\r\nval = tp->mac_mode;\r\n} else if (tp->phy_flags & TG3_PHYFLG_MII_SERDES) {\r\ntp->mac_mode = MAC_MODE_PORT_MODE_GMII;\r\nval = tp->mac_mode;\r\n} else\r\nval = 0;\r\ntw32_f(MAC_MODE, val);\r\nudelay(40);\r\ntg3_ape_unlock(tp, TG3_APE_LOCK_GRC);\r\ntg3_mdio_start(tp);\r\nif (tg3_flag(tp, PCI_EXPRESS) &&\r\ntg3_chip_rev_id(tp) != CHIPREV_ID_5750_A0 &&\r\ntg3_asic_rev(tp) != ASIC_REV_5785 &&\r\n!tg3_flag(tp, 57765_PLUS)) {\r\nval = tr32(0x7c00);\r\ntw32(0x7c00, val | (1 << 25));\r\n}\r\ntg3_restore_clk(tp);\r\ntg3_flag_clear(tp, ENABLE_ASF);\r\ntp->phy_flags &= ~(TG3_PHYFLG_1G_ON_VAUX_OK |\r\nTG3_PHYFLG_KEEP_LINK_ON_PWRDN);\r\ntg3_flag_clear(tp, ASF_NEW_HANDSHAKE);\r\ntg3_read_mem(tp, NIC_SRAM_DATA_SIG, &val);\r\nif (val == NIC_SRAM_DATA_SIG_MAGIC) {\r\nu32 nic_cfg;\r\ntg3_read_mem(tp, NIC_SRAM_DATA_CFG, &nic_cfg);\r\nif (nic_cfg & NIC_SRAM_DATA_CFG_ASF_ENABLE) {\r\ntg3_flag_set(tp, ENABLE_ASF);\r\ntp->last_event_jiffies = jiffies;\r\nif (tg3_flag(tp, 5750_PLUS))\r\ntg3_flag_set(tp, ASF_NEW_HANDSHAKE);\r\ntg3_read_mem(tp, NIC_SRAM_DATA_CFG_3, &nic_cfg);\r\nif (nic_cfg & NIC_SRAM_1G_ON_VAUX_OK)\r\ntp->phy_flags |= TG3_PHYFLG_1G_ON_VAUX_OK;\r\nif (nic_cfg & NIC_SRAM_LNK_FLAP_AVOID)\r\ntp->phy_flags |= TG3_PHYFLG_KEEP_LINK_ON_PWRDN;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tg3_halt(struct tg3 *tp, int kind, bool silent)\r\n{\r\nint err;\r\ntg3_stop_fw(tp);\r\ntg3_write_sig_pre_reset(tp, kind);\r\ntg3_abort_hw(tp, silent);\r\nerr = tg3_chip_reset(tp);\r\n__tg3_set_mac_addr(tp, false);\r\ntg3_write_sig_legacy(tp, kind);\r\ntg3_write_sig_post_reset(tp, kind);\r\nif (tp->hw_stats) {\r\ntg3_get_nstats(tp, &tp->net_stats_prev);\r\ntg3_get_estats(tp, &tp->estats_prev);\r\nmemset(tp->hw_stats, 0, sizeof(struct tg3_hw_stats));\r\n}\r\nreturn err;\r\n}\r\nstatic int tg3_set_mac_addr(struct net_device *dev, void *p)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nstruct sockaddr *addr = p;\r\nint err = 0;\r\nbool skip_mac_1 = false;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nif (!netif_running(dev))\r\nreturn 0;\r\nif (tg3_flag(tp, ENABLE_ASF)) {\r\nu32 addr0_high, addr0_low, addr1_high, addr1_low;\r\naddr0_high = tr32(MAC_ADDR_0_HIGH);\r\naddr0_low = tr32(MAC_ADDR_0_LOW);\r\naddr1_high = tr32(MAC_ADDR_1_HIGH);\r\naddr1_low = tr32(MAC_ADDR_1_LOW);\r\nif ((addr0_high != addr1_high || addr0_low != addr1_low) &&\r\n!(addr1_high == 0 && addr1_low == 0))\r\nskip_mac_1 = true;\r\n}\r\nspin_lock_bh(&tp->lock);\r\n__tg3_set_mac_addr(tp, skip_mac_1);\r\n__tg3_set_rx_mode(dev);\r\nspin_unlock_bh(&tp->lock);\r\nreturn err;\r\n}\r\nstatic void tg3_set_bdinfo(struct tg3 *tp, u32 bdinfo_addr,\r\ndma_addr_t mapping, u32 maxlen_flags,\r\nu32 nic_addr)\r\n{\r\ntg3_write_mem(tp,\r\n(bdinfo_addr + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_HIGH),\r\n((u64) mapping >> 32));\r\ntg3_write_mem(tp,\r\n(bdinfo_addr + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_LOW),\r\n((u64) mapping & 0xffffffff));\r\ntg3_write_mem(tp,\r\n(bdinfo_addr + TG3_BDINFO_MAXLEN_FLAGS),\r\nmaxlen_flags);\r\nif (!tg3_flag(tp, 5705_PLUS))\r\ntg3_write_mem(tp,\r\n(bdinfo_addr + TG3_BDINFO_NIC_ADDR),\r\nnic_addr);\r\n}\r\nstatic void tg3_coal_tx_init(struct tg3 *tp, struct ethtool_coalesce *ec)\r\n{\r\nint i = 0;\r\nif (!tg3_flag(tp, ENABLE_TSS)) {\r\ntw32(HOSTCC_TXCOL_TICKS, ec->tx_coalesce_usecs);\r\ntw32(HOSTCC_TXMAX_FRAMES, ec->tx_max_coalesced_frames);\r\ntw32(HOSTCC_TXCOAL_MAXF_INT, ec->tx_max_coalesced_frames_irq);\r\n} else {\r\ntw32(HOSTCC_TXCOL_TICKS, 0);\r\ntw32(HOSTCC_TXMAX_FRAMES, 0);\r\ntw32(HOSTCC_TXCOAL_MAXF_INT, 0);\r\nfor (; i < tp->txq_cnt; i++) {\r\nu32 reg;\r\nreg = HOSTCC_TXCOL_TICKS_VEC1 + i * 0x18;\r\ntw32(reg, ec->tx_coalesce_usecs);\r\nreg = HOSTCC_TXMAX_FRAMES_VEC1 + i * 0x18;\r\ntw32(reg, ec->tx_max_coalesced_frames);\r\nreg = HOSTCC_TXCOAL_MAXF_INT_VEC1 + i * 0x18;\r\ntw32(reg, ec->tx_max_coalesced_frames_irq);\r\n}\r\n}\r\nfor (; i < tp->irq_max - 1; i++) {\r\ntw32(HOSTCC_TXCOL_TICKS_VEC1 + i * 0x18, 0);\r\ntw32(HOSTCC_TXMAX_FRAMES_VEC1 + i * 0x18, 0);\r\ntw32(HOSTCC_TXCOAL_MAXF_INT_VEC1 + i * 0x18, 0);\r\n}\r\n}\r\nstatic void tg3_coal_rx_init(struct tg3 *tp, struct ethtool_coalesce *ec)\r\n{\r\nint i = 0;\r\nu32 limit = tp->rxq_cnt;\r\nif (!tg3_flag(tp, ENABLE_RSS)) {\r\ntw32(HOSTCC_RXCOL_TICKS, ec->rx_coalesce_usecs);\r\ntw32(HOSTCC_RXMAX_FRAMES, ec->rx_max_coalesced_frames);\r\ntw32(HOSTCC_RXCOAL_MAXF_INT, ec->rx_max_coalesced_frames_irq);\r\nlimit--;\r\n} else {\r\ntw32(HOSTCC_RXCOL_TICKS, 0);\r\ntw32(HOSTCC_RXMAX_FRAMES, 0);\r\ntw32(HOSTCC_RXCOAL_MAXF_INT, 0);\r\n}\r\nfor (; i < limit; i++) {\r\nu32 reg;\r\nreg = HOSTCC_RXCOL_TICKS_VEC1 + i * 0x18;\r\ntw32(reg, ec->rx_coalesce_usecs);\r\nreg = HOSTCC_RXMAX_FRAMES_VEC1 + i * 0x18;\r\ntw32(reg, ec->rx_max_coalesced_frames);\r\nreg = HOSTCC_RXCOAL_MAXF_INT_VEC1 + i * 0x18;\r\ntw32(reg, ec->rx_max_coalesced_frames_irq);\r\n}\r\nfor (; i < tp->irq_max - 1; i++) {\r\ntw32(HOSTCC_RXCOL_TICKS_VEC1 + i * 0x18, 0);\r\ntw32(HOSTCC_RXMAX_FRAMES_VEC1 + i * 0x18, 0);\r\ntw32(HOSTCC_RXCOAL_MAXF_INT_VEC1 + i * 0x18, 0);\r\n}\r\n}\r\nstatic void __tg3_set_coalesce(struct tg3 *tp, struct ethtool_coalesce *ec)\r\n{\r\ntg3_coal_tx_init(tp, ec);\r\ntg3_coal_rx_init(tp, ec);\r\nif (!tg3_flag(tp, 5705_PLUS)) {\r\nu32 val = ec->stats_block_coalesce_usecs;\r\ntw32(HOSTCC_RXCOAL_TICK_INT, ec->rx_coalesce_usecs_irq);\r\ntw32(HOSTCC_TXCOAL_TICK_INT, ec->tx_coalesce_usecs_irq);\r\nif (!tp->link_up)\r\nval = 0;\r\ntw32(HOSTCC_STAT_COAL_TICKS, val);\r\n}\r\n}\r\nstatic void tg3_tx_rcbs_disable(struct tg3 *tp)\r\n{\r\nu32 txrcb, limit;\r\nif (!tg3_flag(tp, 5705_PLUS))\r\nlimit = NIC_SRAM_SEND_RCB + TG3_BDINFO_SIZE * 16;\r\nelse if (tg3_flag(tp, 5717_PLUS))\r\nlimit = NIC_SRAM_SEND_RCB + TG3_BDINFO_SIZE * 4;\r\nelse if (tg3_flag(tp, 57765_CLASS) ||\r\ntg3_asic_rev(tp) == ASIC_REV_5762)\r\nlimit = NIC_SRAM_SEND_RCB + TG3_BDINFO_SIZE * 2;\r\nelse\r\nlimit = NIC_SRAM_SEND_RCB + TG3_BDINFO_SIZE;\r\nfor (txrcb = NIC_SRAM_SEND_RCB + TG3_BDINFO_SIZE;\r\ntxrcb < limit; txrcb += TG3_BDINFO_SIZE)\r\ntg3_write_mem(tp, txrcb + TG3_BDINFO_MAXLEN_FLAGS,\r\nBDINFO_FLAGS_DISABLED);\r\n}\r\nstatic void tg3_tx_rcbs_init(struct tg3 *tp)\r\n{\r\nint i = 0;\r\nu32 txrcb = NIC_SRAM_SEND_RCB;\r\nif (tg3_flag(tp, ENABLE_TSS))\r\ni++;\r\nfor (; i < tp->irq_max; i++, txrcb += TG3_BDINFO_SIZE) {\r\nstruct tg3_napi *tnapi = &tp->napi[i];\r\nif (!tnapi->tx_ring)\r\ncontinue;\r\ntg3_set_bdinfo(tp, txrcb, tnapi->tx_desc_mapping,\r\n(TG3_TX_RING_SIZE << BDINFO_FLAGS_MAXLEN_SHIFT),\r\nNIC_SRAM_TX_BUFFER_DESC);\r\n}\r\n}\r\nstatic void tg3_rx_ret_rcbs_disable(struct tg3 *tp)\r\n{\r\nu32 rxrcb, limit;\r\nif (tg3_flag(tp, 5717_PLUS))\r\nlimit = NIC_SRAM_RCV_RET_RCB + TG3_BDINFO_SIZE * 17;\r\nelse if (!tg3_flag(tp, 5705_PLUS))\r\nlimit = NIC_SRAM_RCV_RET_RCB + TG3_BDINFO_SIZE * 16;\r\nelse if (tg3_asic_rev(tp) == ASIC_REV_5755 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5762 ||\r\ntg3_flag(tp, 57765_CLASS))\r\nlimit = NIC_SRAM_RCV_RET_RCB + TG3_BDINFO_SIZE * 4;\r\nelse\r\nlimit = NIC_SRAM_RCV_RET_RCB + TG3_BDINFO_SIZE;\r\nfor (rxrcb = NIC_SRAM_RCV_RET_RCB + TG3_BDINFO_SIZE;\r\nrxrcb < limit; rxrcb += TG3_BDINFO_SIZE)\r\ntg3_write_mem(tp, rxrcb + TG3_BDINFO_MAXLEN_FLAGS,\r\nBDINFO_FLAGS_DISABLED);\r\n}\r\nstatic void tg3_rx_ret_rcbs_init(struct tg3 *tp)\r\n{\r\nint i = 0;\r\nu32 rxrcb = NIC_SRAM_RCV_RET_RCB;\r\nif (tg3_flag(tp, ENABLE_RSS))\r\ni++;\r\nfor (; i < tp->irq_max; i++, rxrcb += TG3_BDINFO_SIZE) {\r\nstruct tg3_napi *tnapi = &tp->napi[i];\r\nif (!tnapi->rx_rcb)\r\ncontinue;\r\ntg3_set_bdinfo(tp, rxrcb, tnapi->rx_rcb_mapping,\r\n(tp->rx_ret_ring_mask + 1) <<\r\nBDINFO_FLAGS_MAXLEN_SHIFT, 0);\r\n}\r\n}\r\nstatic void tg3_rings_reset(struct tg3 *tp)\r\n{\r\nint i;\r\nu32 stblk;\r\nstruct tg3_napi *tnapi = &tp->napi[0];\r\ntg3_tx_rcbs_disable(tp);\r\ntg3_rx_ret_rcbs_disable(tp);\r\ntw32_mailbox_f(tp->napi[0].int_mbox, 1);\r\ntp->napi[0].chk_msi_cnt = 0;\r\ntp->napi[0].last_rx_cons = 0;\r\ntp->napi[0].last_tx_cons = 0;\r\nif (tg3_flag(tp, SUPPORT_MSIX)) {\r\nfor (i = 1; i < tp->irq_max; i++) {\r\ntp->napi[i].tx_prod = 0;\r\ntp->napi[i].tx_cons = 0;\r\nif (tg3_flag(tp, ENABLE_TSS))\r\ntw32_mailbox(tp->napi[i].prodmbox, 0);\r\ntw32_rx_mbox(tp->napi[i].consmbox, 0);\r\ntw32_mailbox_f(tp->napi[i].int_mbox, 1);\r\ntp->napi[i].chk_msi_cnt = 0;\r\ntp->napi[i].last_rx_cons = 0;\r\ntp->napi[i].last_tx_cons = 0;\r\n}\r\nif (!tg3_flag(tp, ENABLE_TSS))\r\ntw32_mailbox(tp->napi[0].prodmbox, 0);\r\n} else {\r\ntp->napi[0].tx_prod = 0;\r\ntp->napi[0].tx_cons = 0;\r\ntw32_mailbox(tp->napi[0].prodmbox, 0);\r\ntw32_rx_mbox(tp->napi[0].consmbox, 0);\r\n}\r\nif (!tg3_flag(tp, 5705_PLUS)) {\r\nu32 mbox = MAILBOX_SNDNIC_PROD_IDX_0 + TG3_64BIT_REG_LOW;\r\nfor (i = 0; i < 16; i++)\r\ntw32_tx_mbox(mbox + i * 8, 0);\r\n}\r\nmemset(tnapi->hw_status, 0, TG3_HW_STATUS_SIZE);\r\ntw32(HOSTCC_STATUS_BLK_HOST_ADDR + TG3_64BIT_REG_HIGH,\r\n((u64) tnapi->status_mapping >> 32));\r\ntw32(HOSTCC_STATUS_BLK_HOST_ADDR + TG3_64BIT_REG_LOW,\r\n((u64) tnapi->status_mapping & 0xffffffff));\r\nstblk = HOSTCC_STATBLCK_RING1;\r\nfor (i = 1, tnapi++; i < tp->irq_cnt; i++, tnapi++) {\r\nu64 mapping = (u64)tnapi->status_mapping;\r\ntw32(stblk + TG3_64BIT_REG_HIGH, mapping >> 32);\r\ntw32(stblk + TG3_64BIT_REG_LOW, mapping & 0xffffffff);\r\nstblk += 8;\r\nmemset(tnapi->hw_status, 0, TG3_HW_STATUS_SIZE);\r\n}\r\ntg3_tx_rcbs_init(tp);\r\ntg3_rx_ret_rcbs_init(tp);\r\n}\r\nstatic void tg3_setup_rxbd_thresholds(struct tg3 *tp)\r\n{\r\nu32 val, bdcache_maxcnt, host_rep_thresh, nic_rep_thresh;\r\nif (!tg3_flag(tp, 5750_PLUS) ||\r\ntg3_flag(tp, 5780_CLASS) ||\r\ntg3_asic_rev(tp) == ASIC_REV_5750 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5752 ||\r\ntg3_flag(tp, 57765_PLUS))\r\nbdcache_maxcnt = TG3_SRAM_RX_STD_BDCACHE_SIZE_5700;\r\nelse if (tg3_asic_rev(tp) == ASIC_REV_5755 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5787)\r\nbdcache_maxcnt = TG3_SRAM_RX_STD_BDCACHE_SIZE_5755;\r\nelse\r\nbdcache_maxcnt = TG3_SRAM_RX_STD_BDCACHE_SIZE_5906;\r\nnic_rep_thresh = min(bdcache_maxcnt / 2, tp->rx_std_max_post);\r\nhost_rep_thresh = max_t(u32, tp->rx_pending / 8, 1);\r\nval = min(nic_rep_thresh, host_rep_thresh);\r\ntw32(RCVBDI_STD_THRESH, val);\r\nif (tg3_flag(tp, 57765_PLUS))\r\ntw32(STD_REPLENISH_LWM, bdcache_maxcnt);\r\nif (!tg3_flag(tp, JUMBO_CAPABLE) || tg3_flag(tp, 5780_CLASS))\r\nreturn;\r\nbdcache_maxcnt = TG3_SRAM_RX_JMB_BDCACHE_SIZE_5700;\r\nhost_rep_thresh = max_t(u32, tp->rx_jumbo_pending / 8, 1);\r\nval = min(bdcache_maxcnt / 2, host_rep_thresh);\r\ntw32(RCVBDI_JUMBO_THRESH, val);\r\nif (tg3_flag(tp, 57765_PLUS))\r\ntw32(JMB_REPLENISH_LWM, bdcache_maxcnt);\r\n}\r\nstatic inline u32 calc_crc(unsigned char *buf, int len)\r\n{\r\nu32 reg;\r\nu32 tmp;\r\nint j, k;\r\nreg = 0xffffffff;\r\nfor (j = 0; j < len; j++) {\r\nreg ^= buf[j];\r\nfor (k = 0; k < 8; k++) {\r\ntmp = reg & 0x01;\r\nreg >>= 1;\r\nif (tmp)\r\nreg ^= 0xedb88320;\r\n}\r\n}\r\nreturn ~reg;\r\n}\r\nstatic void tg3_set_multi(struct tg3 *tp, unsigned int accept_all)\r\n{\r\ntw32(MAC_HASH_REG_0, accept_all ? 0xffffffff : 0);\r\ntw32(MAC_HASH_REG_1, accept_all ? 0xffffffff : 0);\r\ntw32(MAC_HASH_REG_2, accept_all ? 0xffffffff : 0);\r\ntw32(MAC_HASH_REG_3, accept_all ? 0xffffffff : 0);\r\n}\r\nstatic void __tg3_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nu32 rx_mode;\r\nrx_mode = tp->rx_mode & ~(RX_MODE_PROMISC |\r\nRX_MODE_KEEP_VLAN_TAG);\r\n#if !defined(CONFIG_VLAN_8021Q) && !defined(CONFIG_VLAN_8021Q_MODULE)\r\nif (!tg3_flag(tp, ENABLE_ASF))\r\nrx_mode |= RX_MODE_KEEP_VLAN_TAG;\r\n#endif\r\nif (dev->flags & IFF_PROMISC) {\r\nrx_mode |= RX_MODE_PROMISC;\r\n} else if (dev->flags & IFF_ALLMULTI) {\r\ntg3_set_multi(tp, 1);\r\n} else if (netdev_mc_empty(dev)) {\r\ntg3_set_multi(tp, 0);\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nu32 mc_filter[4] = { 0, };\r\nu32 regidx;\r\nu32 bit;\r\nu32 crc;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ncrc = calc_crc(ha->addr, ETH_ALEN);\r\nbit = ~crc & 0x7f;\r\nregidx = (bit & 0x60) >> 5;\r\nbit &= 0x1f;\r\nmc_filter[regidx] |= (1 << bit);\r\n}\r\ntw32(MAC_HASH_REG_0, mc_filter[0]);\r\ntw32(MAC_HASH_REG_1, mc_filter[1]);\r\ntw32(MAC_HASH_REG_2, mc_filter[2]);\r\ntw32(MAC_HASH_REG_3, mc_filter[3]);\r\n}\r\nif (netdev_uc_count(dev) > TG3_MAX_UCAST_ADDR(tp)) {\r\nrx_mode |= RX_MODE_PROMISC;\r\n} else if (!(dev->flags & IFF_PROMISC)) {\r\nint i = 0;\r\nstruct netdev_hw_addr *ha;\r\nnetdev_for_each_uc_addr(ha, dev) {\r\n__tg3_set_one_mac_addr(tp, ha->addr,\r\ni + TG3_UCAST_ADDR_IDX(tp));\r\ni++;\r\n}\r\n}\r\nif (rx_mode != tp->rx_mode) {\r\ntp->rx_mode = rx_mode;\r\ntw32_f(MAC_RX_MODE, rx_mode);\r\nudelay(10);\r\n}\r\n}\r\nstatic void tg3_rss_init_dflt_indir_tbl(struct tg3 *tp, u32 qcnt)\r\n{\r\nint i;\r\nfor (i = 0; i < TG3_RSS_INDIR_TBL_SIZE; i++)\r\ntp->rss_ind_tbl[i] = ethtool_rxfh_indir_default(i, qcnt);\r\n}\r\nstatic void tg3_rss_check_indir_tbl(struct tg3 *tp)\r\n{\r\nint i;\r\nif (!tg3_flag(tp, SUPPORT_MSIX))\r\nreturn;\r\nif (tp->rxq_cnt == 1) {\r\nmemset(&tp->rss_ind_tbl[0], 0, sizeof(tp->rss_ind_tbl));\r\nreturn;\r\n}\r\nfor (i = 0; i < TG3_RSS_INDIR_TBL_SIZE; i++) {\r\nif (tp->rss_ind_tbl[i] >= tp->rxq_cnt)\r\nbreak;\r\n}\r\nif (i != TG3_RSS_INDIR_TBL_SIZE)\r\ntg3_rss_init_dflt_indir_tbl(tp, tp->rxq_cnt);\r\n}\r\nstatic void tg3_rss_write_indir_tbl(struct tg3 *tp)\r\n{\r\nint i = 0;\r\nu32 reg = MAC_RSS_INDIR_TBL_0;\r\nwhile (i < TG3_RSS_INDIR_TBL_SIZE) {\r\nu32 val = tp->rss_ind_tbl[i];\r\ni++;\r\nfor (; i % 8; i++) {\r\nval <<= 4;\r\nval |= tp->rss_ind_tbl[i];\r\n}\r\ntw32(reg, val);\r\nreg += 4;\r\n}\r\n}\r\nstatic inline u32 tg3_lso_rd_dma_workaround_bit(struct tg3 *tp)\r\n{\r\nif (tg3_asic_rev(tp) == ASIC_REV_5719)\r\nreturn TG3_LSO_RD_DMA_TX_LENGTH_WA_5719;\r\nelse\r\nreturn TG3_LSO_RD_DMA_TX_LENGTH_WA_5720;\r\n}\r\nstatic int tg3_reset_hw(struct tg3 *tp, bool reset_phy)\r\n{\r\nu32 val, rdmac_mode;\r\nint i, err, limit;\r\nstruct tg3_rx_prodring_set *tpr = &tp->napi[0].prodring;\r\ntg3_disable_ints(tp);\r\ntg3_stop_fw(tp);\r\ntg3_write_sig_pre_reset(tp, RESET_KIND_INIT);\r\nif (tg3_flag(tp, INIT_COMPLETE))\r\ntg3_abort_hw(tp, 1);\r\nif ((tp->phy_flags & TG3_PHYFLG_KEEP_LINK_ON_PWRDN) &&\r\n!(tp->phy_flags & TG3_PHYFLG_USER_CONFIGURED)) {\r\ntg3_phy_pull_config(tp);\r\ntg3_eee_pull_config(tp, NULL);\r\ntp->phy_flags |= TG3_PHYFLG_USER_CONFIGURED;\r\n}\r\nif (tp->phy_flags & TG3_PHYFLG_EEE_CAP)\r\ntg3_setup_eee(tp);\r\nif (reset_phy)\r\ntg3_phy_reset(tp);\r\nerr = tg3_chip_reset(tp);\r\nif (err)\r\nreturn err;\r\ntg3_write_sig_legacy(tp, RESET_KIND_INIT);\r\nif (tg3_chip_rev(tp) == CHIPREV_5784_AX) {\r\nval = tr32(TG3_CPMU_CTRL);\r\nval &= ~(CPMU_CTRL_LINK_AWARE_MODE | CPMU_CTRL_LINK_IDLE_MODE);\r\ntw32(TG3_CPMU_CTRL, val);\r\nval = tr32(TG3_CPMU_LSPD_10MB_CLK);\r\nval &= ~CPMU_LSPD_10MB_MACCLK_MASK;\r\nval |= CPMU_LSPD_10MB_MACCLK_6_25;\r\ntw32(TG3_CPMU_LSPD_10MB_CLK, val);\r\nval = tr32(TG3_CPMU_LNK_AWARE_PWRMD);\r\nval &= ~CPMU_LNK_AWARE_MACCLK_MASK;\r\nval |= CPMU_LNK_AWARE_MACCLK_6_25;\r\ntw32(TG3_CPMU_LNK_AWARE_PWRMD, val);\r\nval = tr32(TG3_CPMU_HST_ACC);\r\nval &= ~CPMU_HST_ACC_MACCLK_MASK;\r\nval |= CPMU_HST_ACC_MACCLK_6_25;\r\ntw32(TG3_CPMU_HST_ACC, val);\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_57780) {\r\nval = tr32(PCIE_PWR_MGMT_THRESH) & ~PCIE_PWR_MGMT_L1_THRESH_MSK;\r\nval |= PCIE_PWR_MGMT_EXT_ASPM_TMR_EN |\r\nPCIE_PWR_MGMT_L1_THRESH_4MS;\r\ntw32(PCIE_PWR_MGMT_THRESH, val);\r\nval = tr32(TG3_PCIE_EIDLE_DELAY) & ~TG3_PCIE_EIDLE_DELAY_MASK;\r\ntw32(TG3_PCIE_EIDLE_DELAY, val | TG3_PCIE_EIDLE_DELAY_13_CLKS);\r\ntw32(TG3_CORR_ERR_STAT, TG3_CORR_ERR_STAT_CLEAR);\r\nval = tr32(TG3_PCIE_LNKCTL) & ~TG3_PCIE_LNKCTL_L1_PLL_PD_EN;\r\ntw32(TG3_PCIE_LNKCTL, val | TG3_PCIE_LNKCTL_L1_PLL_PD_DIS);\r\n}\r\nif (tg3_flag(tp, L1PLLPD_EN)) {\r\nu32 grc_mode = tr32(GRC_MODE);\r\nval = grc_mode & ~GRC_MODE_PCIE_PORT_MASK;\r\ntw32(GRC_MODE, val | GRC_MODE_PCIE_PL_SEL);\r\nval = tr32(TG3_PCIE_TLDLPL_PORT + TG3_PCIE_PL_LO_PHYCTL1);\r\ntw32(TG3_PCIE_TLDLPL_PORT + TG3_PCIE_PL_LO_PHYCTL1,\r\nval | TG3_PCIE_PL_LO_PHYCTL1_L1PLLPD_EN);\r\ntw32(GRC_MODE, grc_mode);\r\n}\r\nif (tg3_flag(tp, 57765_CLASS)) {\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_57765_A0) {\r\nu32 grc_mode = tr32(GRC_MODE);\r\nval = grc_mode & ~GRC_MODE_PCIE_PORT_MASK;\r\ntw32(GRC_MODE, val | GRC_MODE_PCIE_PL_SEL);\r\nval = tr32(TG3_PCIE_TLDLPL_PORT +\r\nTG3_PCIE_PL_LO_PHYCTL5);\r\ntw32(TG3_PCIE_TLDLPL_PORT + TG3_PCIE_PL_LO_PHYCTL5,\r\nval | TG3_PCIE_PL_LO_PHYCTL5_DIS_L2CLKREQ);\r\ntw32(GRC_MODE, grc_mode);\r\n}\r\nif (tg3_chip_rev(tp) != CHIPREV_57765_AX) {\r\nu32 grc_mode;\r\nval = tr32(TG3_CPMU_PADRNG_CTL);\r\nval |= TG3_CPMU_PADRNG_CTL_RDIV2;\r\ntw32(TG3_CPMU_PADRNG_CTL, val);\r\ngrc_mode = tr32(GRC_MODE);\r\nval = grc_mode & ~GRC_MODE_PCIE_PORT_MASK;\r\ntw32(GRC_MODE, val | GRC_MODE_PCIE_DL_SEL);\r\nval = tr32(TG3_PCIE_TLDLPL_PORT +\r\nTG3_PCIE_DL_LO_FTSMAX);\r\nval &= ~TG3_PCIE_DL_LO_FTSMAX_MSK;\r\ntw32(TG3_PCIE_TLDLPL_PORT + TG3_PCIE_DL_LO_FTSMAX,\r\nval | TG3_PCIE_DL_LO_FTSMAX_VAL);\r\ntw32(GRC_MODE, grc_mode);\r\n}\r\nval = tr32(TG3_CPMU_LSPD_10MB_CLK);\r\nval &= ~CPMU_LSPD_10MB_MACCLK_MASK;\r\nval |= CPMU_LSPD_10MB_MACCLK_6_25;\r\ntw32(TG3_CPMU_LSPD_10MB_CLK, val);\r\n}\r\nif (!tg3_flag(tp, CPMU_PRESENT)) {\r\nif (!tg3_flag(tp, PCI_EXPRESS))\r\ntp->pci_clock_ctrl |= CLOCK_CTRL_DELAY_PCI_GRANT;\r\ntw32_f(TG3PCI_CLOCK_CTRL, tp->pci_clock_ctrl);\r\n}\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5704_A0 &&\r\ntg3_flag(tp, PCIX_MODE)) {\r\nval = tr32(TG3PCI_PCISTATE);\r\nval |= PCISTATE_RETRY_SAME_DMA;\r\ntw32(TG3PCI_PCISTATE, val);\r\n}\r\nif (tg3_flag(tp, ENABLE_APE)) {\r\nval = tr32(TG3PCI_PCISTATE);\r\nval |= PCISTATE_ALLOW_APE_CTLSPC_WR |\r\nPCISTATE_ALLOW_APE_SHMEM_WR |\r\nPCISTATE_ALLOW_APE_PSPACE_WR;\r\ntw32(TG3PCI_PCISTATE, val);\r\n}\r\nif (tg3_chip_rev(tp) == CHIPREV_5704_BX) {\r\nval = tr32(TG3PCI_MSI_DATA);\r\nval |= (1 << 26) | (1 << 28) | (1 << 29);\r\ntw32(TG3PCI_MSI_DATA, val);\r\n}\r\nerr = tg3_init_rings(tp);\r\nif (err)\r\nreturn err;\r\nif (tg3_flag(tp, 57765_PLUS)) {\r\nval = tr32(TG3PCI_DMA_RW_CTRL) &\r\n~DMA_RWCTRL_DIS_CACHE_ALIGNMENT;\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_57765_A0)\r\nval &= ~DMA_RWCTRL_CRDRDR_RDMA_MRRS_MSK;\r\nif (!tg3_flag(tp, 57765_CLASS) &&\r\ntg3_asic_rev(tp) != ASIC_REV_5717 &&\r\ntg3_asic_rev(tp) != ASIC_REV_5762)\r\nval |= DMA_RWCTRL_TAGGED_STAT_WA;\r\ntw32(TG3PCI_DMA_RW_CTRL, val | tp->dma_rwctrl);\r\n} else if (tg3_asic_rev(tp) != ASIC_REV_5784 &&\r\ntg3_asic_rev(tp) != ASIC_REV_5761) {\r\ntw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);\r\n}\r\ntp->grc_mode &= ~(GRC_MODE_HOST_SENDBDS |\r\nGRC_MODE_4X_NIC_SEND_RINGS |\r\nGRC_MODE_NO_TX_PHDR_CSUM |\r\nGRC_MODE_NO_RX_PHDR_CSUM);\r\ntp->grc_mode |= GRC_MODE_HOST_SENDBDS;\r\ntp->grc_mode |= GRC_MODE_NO_TX_PHDR_CSUM;\r\nval = GRC_MODE_IRQ_ON_MAC_ATTN | GRC_MODE_HOST_STACKUP;\r\nif (tp->rxptpctl)\r\ntw32(TG3_RX_PTP_CTL,\r\ntp->rxptpctl | TG3_RX_PTP_CTL_HWTS_INTERLOCK);\r\nif (tg3_flag(tp, PTP_CAPABLE))\r\nval |= GRC_MODE_TIME_SYNC_ENABLE;\r\ntw32(GRC_MODE, tp->grc_mode | val);\r\nval = tr32(GRC_MISC_CFG);\r\nval &= ~0xff;\r\nval |= (65 << GRC_MISC_CFG_PRESCALAR_SHIFT);\r\ntw32(GRC_MISC_CFG, val);\r\nif (tg3_flag(tp, 5750_PLUS)) {\r\n} else if (tg3_asic_rev(tp) != ASIC_REV_5705) {\r\ntw32(BUFMGR_MB_POOL_ADDR, NIC_SRAM_MBUF_POOL_BASE);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5704)\r\ntw32(BUFMGR_MB_POOL_SIZE, NIC_SRAM_MBUF_POOL_SIZE64);\r\nelse\r\ntw32(BUFMGR_MB_POOL_SIZE, NIC_SRAM_MBUF_POOL_SIZE96);\r\ntw32(BUFMGR_DMA_DESC_POOL_ADDR, NIC_SRAM_DMA_DESC_POOL_BASE);\r\ntw32(BUFMGR_DMA_DESC_POOL_SIZE, NIC_SRAM_DMA_DESC_POOL_SIZE);\r\n} else if (tg3_flag(tp, TSO_CAPABLE)) {\r\nint fw_len;\r\nfw_len = tp->fw_len;\r\nfw_len = (fw_len + (0x80 - 1)) & ~(0x80 - 1);\r\ntw32(BUFMGR_MB_POOL_ADDR,\r\nNIC_SRAM_MBUF_POOL_BASE5705 + fw_len);\r\ntw32(BUFMGR_MB_POOL_SIZE,\r\nNIC_SRAM_MBUF_POOL_SIZE5705 - fw_len - 0xa00);\r\n}\r\nif (tp->dev->mtu <= ETH_DATA_LEN) {\r\ntw32(BUFMGR_MB_RDMA_LOW_WATER,\r\ntp->bufmgr_config.mbuf_read_dma_low_water);\r\ntw32(BUFMGR_MB_MACRX_LOW_WATER,\r\ntp->bufmgr_config.mbuf_mac_rx_low_water);\r\ntw32(BUFMGR_MB_HIGH_WATER,\r\ntp->bufmgr_config.mbuf_high_water);\r\n} else {\r\ntw32(BUFMGR_MB_RDMA_LOW_WATER,\r\ntp->bufmgr_config.mbuf_read_dma_low_water_jumbo);\r\ntw32(BUFMGR_MB_MACRX_LOW_WATER,\r\ntp->bufmgr_config.mbuf_mac_rx_low_water_jumbo);\r\ntw32(BUFMGR_MB_HIGH_WATER,\r\ntp->bufmgr_config.mbuf_high_water_jumbo);\r\n}\r\ntw32(BUFMGR_DMA_LOW_WATER,\r\ntp->bufmgr_config.dma_low_water);\r\ntw32(BUFMGR_DMA_HIGH_WATER,\r\ntp->bufmgr_config.dma_high_water);\r\nval = BUFMGR_MODE_ENABLE | BUFMGR_MODE_ATTN_ENABLE;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5719)\r\nval |= BUFMGR_MODE_NO_TX_UNDERRUN;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5762 ||\r\ntg3_chip_rev_id(tp) == CHIPREV_ID_5719_A0 ||\r\ntg3_chip_rev_id(tp) == CHIPREV_ID_5720_A0)\r\nval |= BUFMGR_MODE_MBLOW_ATTN_ENAB;\r\ntw32(BUFMGR_MODE, val);\r\nfor (i = 0; i < 2000; i++) {\r\nif (tr32(BUFMGR_MODE) & BUFMGR_MODE_ENABLE)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (i >= 2000) {\r\nnetdev_err(tp->dev, "%s cannot enable BUFMGR\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5906_A1)\r\ntw32(ISO_PKT_TX, (tr32(ISO_PKT_TX) & ~0x3) | 0x2);\r\ntg3_setup_rxbd_thresholds(tp);\r\ntw32(RCVDBDI_STD_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_HIGH,\r\n((u64) tpr->rx_std_mapping >> 32));\r\ntw32(RCVDBDI_STD_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_LOW,\r\n((u64) tpr->rx_std_mapping & 0xffffffff));\r\nif (!tg3_flag(tp, 5717_PLUS))\r\ntw32(RCVDBDI_STD_BD + TG3_BDINFO_NIC_ADDR,\r\nNIC_SRAM_RX_BUFFER_DESC);\r\nif (!tg3_flag(tp, 5705_PLUS))\r\ntw32(RCVDBDI_MINI_BD + TG3_BDINFO_MAXLEN_FLAGS,\r\nBDINFO_FLAGS_DISABLED);\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5719_A0 ||\r\n(tg3_flag(tp, JUMBO_CAPABLE) && !tg3_flag(tp, 5780_CLASS))) {\r\nif (tg3_flag(tp, JUMBO_RING_ENABLE)) {\r\ntw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_HIGH,\r\n((u64) tpr->rx_jmb_mapping >> 32));\r\ntw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_LOW,\r\n((u64) tpr->rx_jmb_mapping & 0xffffffff));\r\nval = TG3_RX_JMB_RING_SIZE(tp) <<\r\nBDINFO_FLAGS_MAXLEN_SHIFT;\r\ntw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_MAXLEN_FLAGS,\r\nval | BDINFO_FLAGS_USE_EXT_RECV);\r\nif (!tg3_flag(tp, USE_JUMBO_BDFLAG) ||\r\ntg3_flag(tp, 57765_CLASS) ||\r\ntg3_asic_rev(tp) == ASIC_REV_5762)\r\ntw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_NIC_ADDR,\r\nNIC_SRAM_RX_JUMBO_BUFFER_DESC);\r\n} else {\r\ntw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_MAXLEN_FLAGS,\r\nBDINFO_FLAGS_DISABLED);\r\n}\r\nif (tg3_flag(tp, 57765_PLUS)) {\r\nval = TG3_RX_STD_RING_SIZE(tp);\r\nval <<= BDINFO_FLAGS_MAXLEN_SHIFT;\r\nval |= (TG3_RX_STD_DMA_SZ << 2);\r\n} else\r\nval = TG3_RX_STD_DMA_SZ << BDINFO_FLAGS_MAXLEN_SHIFT;\r\n} else\r\nval = TG3_RX_STD_MAX_SIZE_5700 << BDINFO_FLAGS_MAXLEN_SHIFT;\r\ntw32(RCVDBDI_STD_BD + TG3_BDINFO_MAXLEN_FLAGS, val);\r\ntpr->rx_std_prod_idx = tp->rx_pending;\r\ntw32_rx_mbox(TG3_RX_STD_PROD_IDX_REG, tpr->rx_std_prod_idx);\r\ntpr->rx_jmb_prod_idx =\r\ntg3_flag(tp, JUMBO_RING_ENABLE) ? tp->rx_jumbo_pending : 0;\r\ntw32_rx_mbox(TG3_RX_JMB_PROD_IDX_REG, tpr->rx_jmb_prod_idx);\r\ntg3_rings_reset(tp);\r\n__tg3_set_mac_addr(tp, false);\r\ntw32(MAC_RX_MTU_SIZE,\r\ntp->dev->mtu + ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN);\r\nval = (2 << TX_LENGTHS_IPG_CRS_SHIFT) |\r\n(6 << TX_LENGTHS_IPG_SHIFT) |\r\n(32 << TX_LENGTHS_SLOT_TIME_SHIFT);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5720 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5762)\r\nval |= tr32(MAC_TX_LENGTHS) &\r\n(TX_LENGTHS_JMB_FRM_LEN_MSK |\r\nTX_LENGTHS_CNT_DWN_VAL_MSK);\r\ntw32(MAC_TX_LENGTHS, val);\r\ntw32(MAC_RCV_RULE_CFG, RCV_RULE_CFG_DEFAULT_CLASS);\r\ntw32(RCVLPC_CONFIG, 0x0181);\r\nrdmac_mode = (RDMAC_MODE_ENABLE | RDMAC_MODE_TGTABORT_ENAB |\r\nRDMAC_MODE_MSTABORT_ENAB | RDMAC_MODE_PARITYERR_ENAB |\r\nRDMAC_MODE_ADDROFLOW_ENAB | RDMAC_MODE_FIFOOFLOW_ENAB |\r\nRDMAC_MODE_FIFOURUN_ENAB | RDMAC_MODE_FIFOOREAD_ENAB |\r\nRDMAC_MODE_LNGREAD_ENAB);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5717)\r\nrdmac_mode |= RDMAC_MODE_MULT_DMA_RD_DIS;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5784 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5785 ||\r\ntg3_asic_rev(tp) == ASIC_REV_57780)\r\nrdmac_mode |= RDMAC_MODE_BD_SBD_CRPT_ENAB |\r\nRDMAC_MODE_MBUF_RBD_CRPT_ENAB |\r\nRDMAC_MODE_MBUF_SBD_CRPT_ENAB;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5705 &&\r\ntg3_chip_rev_id(tp) != CHIPREV_ID_5705_A0) {\r\nif (tg3_flag(tp, TSO_CAPABLE) &&\r\ntg3_asic_rev(tp) == ASIC_REV_5705) {\r\nrdmac_mode |= RDMAC_MODE_FIFO_SIZE_128;\r\n} else if (!(tr32(TG3PCI_PCISTATE) & PCISTATE_BUS_SPEED_HIGH) &&\r\n!tg3_flag(tp, IS_5788)) {\r\nrdmac_mode |= RDMAC_MODE_FIFO_LONG_BURST;\r\n}\r\n}\r\nif (tg3_flag(tp, PCI_EXPRESS))\r\nrdmac_mode |= RDMAC_MODE_FIFO_LONG_BURST;\r\nif (tg3_asic_rev(tp) == ASIC_REV_57766) {\r\ntp->dma_limit = 0;\r\nif (tp->dev->mtu <= ETH_DATA_LEN) {\r\nrdmac_mode |= RDMAC_MODE_JMB_2K_MMRR;\r\ntp->dma_limit = TG3_TX_BD_DMA_MAX_2K;\r\n}\r\n}\r\nif (tg3_flag(tp, HW_TSO_1) ||\r\ntg3_flag(tp, HW_TSO_2) ||\r\ntg3_flag(tp, HW_TSO_3))\r\nrdmac_mode |= RDMAC_MODE_IPV4_LSO_EN;\r\nif (tg3_flag(tp, 57765_PLUS) ||\r\ntg3_asic_rev(tp) == ASIC_REV_5785 ||\r\ntg3_asic_rev(tp) == ASIC_REV_57780)\r\nrdmac_mode |= RDMAC_MODE_IPV6_LSO_EN;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5720 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5762)\r\nrdmac_mode |= tr32(RDMAC_MODE) & RDMAC_MODE_H2BNC_VLAN_DET;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5761 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5784 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5785 ||\r\ntg3_asic_rev(tp) == ASIC_REV_57780 ||\r\ntg3_flag(tp, 57765_PLUS)) {\r\nu32 tgtreg;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5762)\r\ntgtreg = TG3_RDMA_RSRVCTRL_REG2;\r\nelse\r\ntgtreg = TG3_RDMA_RSRVCTRL_REG;\r\nval = tr32(tgtreg);\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5719_A0 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5762) {\r\nval &= ~(TG3_RDMA_RSRVCTRL_TXMRGN_MASK |\r\nTG3_RDMA_RSRVCTRL_FIFO_LWM_MASK |\r\nTG3_RDMA_RSRVCTRL_FIFO_HWM_MASK);\r\nval |= TG3_RDMA_RSRVCTRL_TXMRGN_320B |\r\nTG3_RDMA_RSRVCTRL_FIFO_LWM_1_5K |\r\nTG3_RDMA_RSRVCTRL_FIFO_HWM_1_5K;\r\n}\r\ntw32(tgtreg, val | TG3_RDMA_RSRVCTRL_FIFO_OFLW_FIX);\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5719 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5720 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5762) {\r\nu32 tgtreg;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5762)\r\ntgtreg = TG3_LSO_RD_DMA_CRPTEN_CTRL2;\r\nelse\r\ntgtreg = TG3_LSO_RD_DMA_CRPTEN_CTRL;\r\nval = tr32(tgtreg);\r\ntw32(tgtreg, val |\r\nTG3_LSO_RD_DMA_CRPTEN_CTRL_BLEN_BD_4K |\r\nTG3_LSO_RD_DMA_CRPTEN_CTRL_BLEN_LSO_4K);\r\n}\r\nif (tg3_flag(tp, 5750_PLUS)) {\r\nval = tr32(RCVLPC_STATS_ENABLE);\r\nval &= ~RCVLPC_STATSENAB_DACK_FIX;\r\ntw32(RCVLPC_STATS_ENABLE, val);\r\n} else if ((rdmac_mode & RDMAC_MODE_FIFO_SIZE_128) &&\r\ntg3_flag(tp, TSO_CAPABLE)) {\r\nval = tr32(RCVLPC_STATS_ENABLE);\r\nval &= ~RCVLPC_STATSENAB_LNGBRST_RFIX;\r\ntw32(RCVLPC_STATS_ENABLE, val);\r\n} else {\r\ntw32(RCVLPC_STATS_ENABLE, 0xffffff);\r\n}\r\ntw32(RCVLPC_STATSCTRL, RCVLPC_STATSCTRL_ENABLE);\r\ntw32(SNDDATAI_STATSENAB, 0xffffff);\r\ntw32(SNDDATAI_STATSCTRL,\r\n(SNDDATAI_SCTRL_ENABLE |\r\nSNDDATAI_SCTRL_FASTUPD));\r\ntw32(HOSTCC_MODE, 0);\r\nfor (i = 0; i < 2000; i++) {\r\nif (!(tr32(HOSTCC_MODE) & HOSTCC_MODE_ENABLE))\r\nbreak;\r\nudelay(10);\r\n}\r\n__tg3_set_coalesce(tp, &tp->coal);\r\nif (!tg3_flag(tp, 5705_PLUS)) {\r\ntw32(HOSTCC_STATS_BLK_HOST_ADDR + TG3_64BIT_REG_HIGH,\r\n((u64) tp->stats_mapping >> 32));\r\ntw32(HOSTCC_STATS_BLK_HOST_ADDR + TG3_64BIT_REG_LOW,\r\n((u64) tp->stats_mapping & 0xffffffff));\r\ntw32(HOSTCC_STATS_BLK_NIC_ADDR, NIC_SRAM_STATS_BLK);\r\ntw32(HOSTCC_STATUS_BLK_NIC_ADDR, NIC_SRAM_STATUS_BLK);\r\nfor (i = NIC_SRAM_STATS_BLK;\r\ni < NIC_SRAM_STATUS_BLK + TG3_HW_STATUS_SIZE;\r\ni += sizeof(u32)) {\r\ntg3_write_mem(tp, i, 0);\r\nudelay(40);\r\n}\r\n}\r\ntw32(HOSTCC_MODE, HOSTCC_MODE_ENABLE | tp->coalesce_mode);\r\ntw32(RCVCC_MODE, RCVCC_MODE_ENABLE | RCVCC_MODE_ATTN_ENABLE);\r\ntw32(RCVLPC_MODE, RCVLPC_MODE_ENABLE);\r\nif (!tg3_flag(tp, 5705_PLUS))\r\ntw32(RCVLSC_MODE, RCVLSC_MODE_ENABLE | RCVLSC_MODE_ATTN_ENABLE);\r\nif (tp->phy_flags & TG3_PHYFLG_MII_SERDES) {\r\ntp->phy_flags &= ~TG3_PHYFLG_PARALLEL_DETECT;\r\ntw32_f(MAC_RX_MODE, RX_MODE_RESET);\r\nudelay(10);\r\n}\r\ntp->mac_mode |= MAC_MODE_TXSTAT_ENABLE | MAC_MODE_RXSTAT_ENABLE |\r\nMAC_MODE_TDE_ENABLE | MAC_MODE_RDE_ENABLE |\r\nMAC_MODE_FHDE_ENABLE;\r\nif (tg3_flag(tp, ENABLE_APE))\r\ntp->mac_mode |= MAC_MODE_APE_TX_EN | MAC_MODE_APE_RX_EN;\r\nif (!tg3_flag(tp, 5705_PLUS) &&\r\n!(tp->phy_flags & TG3_PHYFLG_PHY_SERDES) &&\r\ntg3_asic_rev(tp) != ASIC_REV_5700)\r\ntp->mac_mode |= MAC_MODE_LINK_POLARITY;\r\ntw32_f(MAC_MODE, tp->mac_mode | MAC_MODE_RXSTAT_CLEAR | MAC_MODE_TXSTAT_CLEAR);\r\nudelay(40);\r\nif (!tg3_flag(tp, IS_NIC)) {\r\nu32 gpio_mask;\r\ngpio_mask = GRC_LCLCTRL_GPIO_OE0 | GRC_LCLCTRL_GPIO_OE1 |\r\nGRC_LCLCTRL_GPIO_OE2 | GRC_LCLCTRL_GPIO_OUTPUT0 |\r\nGRC_LCLCTRL_GPIO_OUTPUT1 | GRC_LCLCTRL_GPIO_OUTPUT2;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5752)\r\ngpio_mask |= GRC_LCLCTRL_GPIO_OE3 |\r\nGRC_LCLCTRL_GPIO_OUTPUT3;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5755)\r\ngpio_mask |= GRC_LCLCTRL_GPIO_UART_SEL;\r\ntp->grc_local_ctrl &= ~gpio_mask;\r\ntp->grc_local_ctrl |= tr32(GRC_LOCAL_CTRL) & gpio_mask;\r\nif (tg3_flag(tp, EEPROM_WRITE_PROT))\r\ntp->grc_local_ctrl |= (GRC_LCLCTRL_GPIO_OE1 |\r\nGRC_LCLCTRL_GPIO_OUTPUT1);\r\n}\r\ntw32_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl);\r\nudelay(100);\r\nif (tg3_flag(tp, USING_MSIX)) {\r\nval = tr32(MSGINT_MODE);\r\nval |= MSGINT_MODE_ENABLE;\r\nif (tp->irq_cnt > 1)\r\nval |= MSGINT_MODE_MULTIVEC_EN;\r\nif (!tg3_flag(tp, 1SHOT_MSI))\r\nval |= MSGINT_MODE_ONE_SHOT_DISABLE;\r\ntw32(MSGINT_MODE, val);\r\n}\r\nif (!tg3_flag(tp, 5705_PLUS)) {\r\ntw32_f(DMAC_MODE, DMAC_MODE_ENABLE);\r\nudelay(40);\r\n}\r\nval = (WDMAC_MODE_ENABLE | WDMAC_MODE_TGTABORT_ENAB |\r\nWDMAC_MODE_MSTABORT_ENAB | WDMAC_MODE_PARITYERR_ENAB |\r\nWDMAC_MODE_ADDROFLOW_ENAB | WDMAC_MODE_FIFOOFLOW_ENAB |\r\nWDMAC_MODE_FIFOURUN_ENAB | WDMAC_MODE_FIFOOREAD_ENAB |\r\nWDMAC_MODE_LNGREAD_ENAB);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5705 &&\r\ntg3_chip_rev_id(tp) != CHIPREV_ID_5705_A0) {\r\nif (tg3_flag(tp, TSO_CAPABLE) &&\r\n(tg3_chip_rev_id(tp) == CHIPREV_ID_5705_A1 ||\r\ntg3_chip_rev_id(tp) == CHIPREV_ID_5705_A2)) {\r\n} else if (!(tr32(TG3PCI_PCISTATE) & PCISTATE_BUS_SPEED_HIGH) &&\r\n!tg3_flag(tp, IS_5788)) {\r\nval |= WDMAC_MODE_RX_ACCEL;\r\n}\r\n}\r\nif (tg3_flag(tp, 5755_PLUS))\r\nval |= WDMAC_MODE_STATUS_TAG_FIX;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5785)\r\nval |= WDMAC_MODE_BURST_ALL_DATA;\r\ntw32_f(WDMAC_MODE, val);\r\nudelay(40);\r\nif (tg3_flag(tp, PCIX_MODE)) {\r\nu16 pcix_cmd;\r\npci_read_config_word(tp->pdev, tp->pcix_cap + PCI_X_CMD,\r\n&pcix_cmd);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5703) {\r\npcix_cmd &= ~PCI_X_CMD_MAX_READ;\r\npcix_cmd |= PCI_X_CMD_READ_2K;\r\n} else if (tg3_asic_rev(tp) == ASIC_REV_5704) {\r\npcix_cmd &= ~(PCI_X_CMD_MAX_SPLIT | PCI_X_CMD_MAX_READ);\r\npcix_cmd |= PCI_X_CMD_READ_2K;\r\n}\r\npci_write_config_word(tp->pdev, tp->pcix_cap + PCI_X_CMD,\r\npcix_cmd);\r\n}\r\ntw32_f(RDMAC_MODE, rdmac_mode);\r\nudelay(40);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5719 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5720) {\r\nfor (i = 0; i < TG3_NUM_RDMA_CHANNELS; i++) {\r\nif (tr32(TG3_RDMA_LENGTH + (i << 2)) > TG3_MAX_MTU(tp))\r\nbreak;\r\n}\r\nif (i < TG3_NUM_RDMA_CHANNELS) {\r\nval = tr32(TG3_LSO_RD_DMA_CRPTEN_CTRL);\r\nval |= tg3_lso_rd_dma_workaround_bit(tp);\r\ntw32(TG3_LSO_RD_DMA_CRPTEN_CTRL, val);\r\ntg3_flag_set(tp, 5719_5720_RDMA_BUG);\r\n}\r\n}\r\ntw32(RCVDCC_MODE, RCVDCC_MODE_ENABLE | RCVDCC_MODE_ATTN_ENABLE);\r\nif (!tg3_flag(tp, 5705_PLUS))\r\ntw32(MBFREE_MODE, MBFREE_MODE_ENABLE);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5761)\r\ntw32(SNDDATAC_MODE,\r\nSNDDATAC_MODE_ENABLE | SNDDATAC_MODE_CDELAY);\r\nelse\r\ntw32(SNDDATAC_MODE, SNDDATAC_MODE_ENABLE);\r\ntw32(SNDBDC_MODE, SNDBDC_MODE_ENABLE | SNDBDC_MODE_ATTN_ENABLE);\r\ntw32(RCVBDI_MODE, RCVBDI_MODE_ENABLE | RCVBDI_MODE_RCB_ATTN_ENAB);\r\nval = RCVDBDI_MODE_ENABLE | RCVDBDI_MODE_INV_RING_SZ;\r\nif (tg3_flag(tp, LRG_PROD_RING_CAP))\r\nval |= RCVDBDI_MODE_LRG_RING_SZ;\r\ntw32(RCVDBDI_MODE, val);\r\ntw32(SNDDATAI_MODE, SNDDATAI_MODE_ENABLE);\r\nif (tg3_flag(tp, HW_TSO_1) ||\r\ntg3_flag(tp, HW_TSO_2) ||\r\ntg3_flag(tp, HW_TSO_3))\r\ntw32(SNDDATAI_MODE, SNDDATAI_MODE_ENABLE | 0x8);\r\nval = SNDBDI_MODE_ENABLE | SNDBDI_MODE_ATTN_ENABLE;\r\nif (tg3_flag(tp, ENABLE_TSS))\r\nval |= SNDBDI_MODE_MULTI_TXQ_EN;\r\ntw32(SNDBDI_MODE, val);\r\ntw32(SNDBDS_MODE, SNDBDS_MODE_ENABLE | SNDBDS_MODE_ATTN_ENABLE);\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5701_A0) {\r\nerr = tg3_load_5701_a0_firmware_fix(tp);\r\nif (err)\r\nreturn err;\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_57766) {\r\ntg3_load_57766_firmware(tp);\r\n}\r\nif (tg3_flag(tp, TSO_CAPABLE)) {\r\nerr = tg3_load_tso_firmware(tp);\r\nif (err)\r\nreturn err;\r\n}\r\ntp->tx_mode = TX_MODE_ENABLE;\r\nif (tg3_flag(tp, 5755_PLUS) ||\r\ntg3_asic_rev(tp) == ASIC_REV_5906)\r\ntp->tx_mode |= TX_MODE_MBUF_LOCKUP_FIX;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5720 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5762) {\r\nval = TX_MODE_JMB_FRM_LEN | TX_MODE_CNT_DN_MODE;\r\ntp->tx_mode &= ~val;\r\ntp->tx_mode |= tr32(MAC_TX_MODE) & val;\r\n}\r\ntw32_f(MAC_TX_MODE, tp->tx_mode);\r\nudelay(100);\r\nif (tg3_flag(tp, ENABLE_RSS)) {\r\nu32 rss_key[10];\r\ntg3_rss_write_indir_tbl(tp);\r\nnetdev_rss_key_fill(rss_key, 10 * sizeof(u32));\r\nfor (i = 0; i < 10 ; i++)\r\ntw32(MAC_RSS_HASH_KEY_0 + i*4, rss_key[i]);\r\n}\r\ntp->rx_mode = RX_MODE_ENABLE;\r\nif (tg3_flag(tp, 5755_PLUS))\r\ntp->rx_mode |= RX_MODE_IPV6_CSUM_ENABLE;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5762)\r\ntp->rx_mode |= RX_MODE_IPV4_FRAG_FIX;\r\nif (tg3_flag(tp, ENABLE_RSS))\r\ntp->rx_mode |= RX_MODE_RSS_ENABLE |\r\nRX_MODE_RSS_ITBL_HASH_BITS_7 |\r\nRX_MODE_RSS_IPV6_HASH_EN |\r\nRX_MODE_RSS_TCP_IPV6_HASH_EN |\r\nRX_MODE_RSS_IPV4_HASH_EN |\r\nRX_MODE_RSS_TCP_IPV4_HASH_EN;\r\ntw32_f(MAC_RX_MODE, tp->rx_mode);\r\nudelay(10);\r\ntw32(MAC_LED_CTRL, tp->led_ctrl);\r\ntw32(MAC_MI_STAT, MAC_MI_STAT_LNKSTAT_ATTN_ENAB);\r\nif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES) {\r\ntw32_f(MAC_RX_MODE, RX_MODE_RESET);\r\nudelay(10);\r\n}\r\ntw32_f(MAC_RX_MODE, tp->rx_mode);\r\nudelay(10);\r\nif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES) {\r\nif ((tg3_asic_rev(tp) == ASIC_REV_5704) &&\r\n!(tp->phy_flags & TG3_PHYFLG_SERDES_PREEMPHASIS)) {\r\nval = tr32(MAC_SERDES_CFG);\r\nval &= 0xfffff000;\r\nval |= 0x880;\r\ntw32(MAC_SERDES_CFG, val);\r\n}\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5703_A1)\r\ntw32(MAC_SERDES_CFG, 0x616000);\r\n}\r\nif (tg3_flag(tp, 57765_CLASS))\r\nval = 1;\r\nelse\r\nval = 2;\r\ntw32_f(MAC_LOW_WMARK_MAX_RX_FRAME, val);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5704 &&\r\n(tp->phy_flags & TG3_PHYFLG_PHY_SERDES)) {\r\ntg3_flag_set(tp, HW_AUTONEG);\r\n}\r\nif ((tp->phy_flags & TG3_PHYFLG_MII_SERDES) &&\r\ntg3_asic_rev(tp) == ASIC_REV_5714) {\r\nu32 tmp;\r\ntmp = tr32(SERDES_RX_CTRL);\r\ntw32(SERDES_RX_CTRL, tmp | SERDES_RX_SIG_DETECT);\r\ntp->grc_local_ctrl &= ~GRC_LCLCTRL_USE_EXT_SIG_DETECT;\r\ntp->grc_local_ctrl |= GRC_LCLCTRL_USE_SIG_DETECT;\r\ntw32(GRC_LOCAL_CTRL, tp->grc_local_ctrl);\r\n}\r\nif (!tg3_flag(tp, USE_PHYLIB)) {\r\nif (tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER)\r\ntp->phy_flags &= ~TG3_PHYFLG_IS_LOW_POWER;\r\nerr = tg3_setup_phy(tp, false);\r\nif (err)\r\nreturn err;\r\nif (!(tp->phy_flags & TG3_PHYFLG_PHY_SERDES) &&\r\n!(tp->phy_flags & TG3_PHYFLG_IS_FET)) {\r\nu32 tmp;\r\nif (!tg3_readphy(tp, MII_TG3_TEST1, &tmp)) {\r\ntg3_writephy(tp, MII_TG3_TEST1,\r\ntmp | MII_TG3_TEST1_CRC_EN);\r\ntg3_readphy(tp, MII_TG3_RXR_COUNTERS, &tmp);\r\n}\r\n}\r\n}\r\n__tg3_set_rx_mode(tp->dev);\r\ntw32(MAC_RCV_RULE_0, 0xc2000000 & RCV_RULE_DISABLE_MASK);\r\ntw32(MAC_RCV_VALUE_0, 0xffffffff & RCV_RULE_DISABLE_MASK);\r\ntw32(MAC_RCV_RULE_1, 0x86000004 & RCV_RULE_DISABLE_MASK);\r\ntw32(MAC_RCV_VALUE_1, 0xffffffff & RCV_RULE_DISABLE_MASK);\r\nif (tg3_flag(tp, 5705_PLUS) && !tg3_flag(tp, 5780_CLASS))\r\nlimit = 8;\r\nelse\r\nlimit = 16;\r\nif (tg3_flag(tp, ENABLE_ASF))\r\nlimit -= 4;\r\nswitch (limit) {\r\ncase 16:\r\ntw32(MAC_RCV_RULE_15, 0); tw32(MAC_RCV_VALUE_15, 0);\r\ncase 15:\r\ntw32(MAC_RCV_RULE_14, 0); tw32(MAC_RCV_VALUE_14, 0);\r\ncase 14:\r\ntw32(MAC_RCV_RULE_13, 0); tw32(MAC_RCV_VALUE_13, 0);\r\ncase 13:\r\ntw32(MAC_RCV_RULE_12, 0); tw32(MAC_RCV_VALUE_12, 0);\r\ncase 12:\r\ntw32(MAC_RCV_RULE_11, 0); tw32(MAC_RCV_VALUE_11, 0);\r\ncase 11:\r\ntw32(MAC_RCV_RULE_10, 0); tw32(MAC_RCV_VALUE_10, 0);\r\ncase 10:\r\ntw32(MAC_RCV_RULE_9, 0); tw32(MAC_RCV_VALUE_9, 0);\r\ncase 9:\r\ntw32(MAC_RCV_RULE_8, 0); tw32(MAC_RCV_VALUE_8, 0);\r\ncase 8:\r\ntw32(MAC_RCV_RULE_7, 0); tw32(MAC_RCV_VALUE_7, 0);\r\ncase 7:\r\ntw32(MAC_RCV_RULE_6, 0); tw32(MAC_RCV_VALUE_6, 0);\r\ncase 6:\r\ntw32(MAC_RCV_RULE_5, 0); tw32(MAC_RCV_VALUE_5, 0);\r\ncase 5:\r\ntw32(MAC_RCV_RULE_4, 0); tw32(MAC_RCV_VALUE_4, 0);\r\ncase 4:\r\ncase 3:\r\ncase 2:\r\ncase 1:\r\ndefault:\r\nbreak;\r\n}\r\nif (tg3_flag(tp, ENABLE_APE))\r\ntg3_ape_write32(tp, TG3_APE_HOST_HEARTBEAT_INT_MS,\r\nAPE_HOST_HEARTBEAT_INT_DISABLE);\r\ntg3_write_sig_post_reset(tp, RESET_KIND_INIT);\r\nreturn 0;\r\n}\r\nstatic int tg3_init_hw(struct tg3 *tp, bool reset_phy)\r\n{\r\ntg3_enable_register_access(tp);\r\ntg3_poll_fw(tp);\r\ntg3_switch_clocks(tp);\r\ntw32(TG3PCI_MEM_WIN_BASE_ADDR, 0);\r\nreturn tg3_reset_hw(tp, reset_phy);\r\n}\r\nstatic void tg3_sd_scan_scratchpad(struct tg3 *tp, struct tg3_ocir *ocir)\r\n{\r\nint i;\r\nfor (i = 0; i < TG3_SD_NUM_RECS; i++, ocir++) {\r\nu32 off = i * TG3_OCIR_LEN, len = TG3_OCIR_LEN;\r\ntg3_ape_scratchpad_read(tp, (u32 *) ocir, off, len);\r\noff += len;\r\nif (ocir->signature != TG3_OCIR_SIG_MAGIC ||\r\n!(ocir->version_flags & TG3_OCIR_FLAG_ACTIVE))\r\nmemset(ocir, 0, TG3_OCIR_LEN);\r\n}\r\n}\r\nstatic ssize_t tg3_show_temp(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct tg3 *tp = dev_get_drvdata(dev);\r\nu32 temperature;\r\nspin_lock_bh(&tp->lock);\r\ntg3_ape_scratchpad_read(tp, &temperature, attr->index,\r\nsizeof(temperature));\r\nspin_unlock_bh(&tp->lock);\r\nreturn sprintf(buf, "%u\n", temperature * 1000);\r\n}\r\nstatic void tg3_hwmon_close(struct tg3 *tp)\r\n{\r\nif (tp->hwmon_dev) {\r\nhwmon_device_unregister(tp->hwmon_dev);\r\ntp->hwmon_dev = NULL;\r\n}\r\n}\r\nstatic void tg3_hwmon_open(struct tg3 *tp)\r\n{\r\nint i;\r\nu32 size = 0;\r\nstruct pci_dev *pdev = tp->pdev;\r\nstruct tg3_ocir ocirs[TG3_SD_NUM_RECS];\r\ntg3_sd_scan_scratchpad(tp, ocirs);\r\nfor (i = 0; i < TG3_SD_NUM_RECS; i++) {\r\nif (!ocirs[i].src_data_length)\r\ncontinue;\r\nsize += ocirs[i].src_hdr_length;\r\nsize += ocirs[i].src_data_length;\r\n}\r\nif (!size)\r\nreturn;\r\ntp->hwmon_dev = hwmon_device_register_with_groups(&pdev->dev, "tg3",\r\ntp, tg3_groups);\r\nif (IS_ERR(tp->hwmon_dev)) {\r\ntp->hwmon_dev = NULL;\r\ndev_err(&pdev->dev, "Cannot register hwmon device, aborting\n");\r\n}\r\n}\r\nstatic void tg3_periodic_fetch_stats(struct tg3 *tp)\r\n{\r\nstruct tg3_hw_stats *sp = tp->hw_stats;\r\nif (!tp->link_up)\r\nreturn;\r\nTG3_STAT_ADD32(&sp->tx_octets, MAC_TX_STATS_OCTETS);\r\nTG3_STAT_ADD32(&sp->tx_collisions, MAC_TX_STATS_COLLISIONS);\r\nTG3_STAT_ADD32(&sp->tx_xon_sent, MAC_TX_STATS_XON_SENT);\r\nTG3_STAT_ADD32(&sp->tx_xoff_sent, MAC_TX_STATS_XOFF_SENT);\r\nTG3_STAT_ADD32(&sp->tx_mac_errors, MAC_TX_STATS_MAC_ERRORS);\r\nTG3_STAT_ADD32(&sp->tx_single_collisions, MAC_TX_STATS_SINGLE_COLLISIONS);\r\nTG3_STAT_ADD32(&sp->tx_mult_collisions, MAC_TX_STATS_MULT_COLLISIONS);\r\nTG3_STAT_ADD32(&sp->tx_deferred, MAC_TX_STATS_DEFERRED);\r\nTG3_STAT_ADD32(&sp->tx_excessive_collisions, MAC_TX_STATS_EXCESSIVE_COL);\r\nTG3_STAT_ADD32(&sp->tx_late_collisions, MAC_TX_STATS_LATE_COL);\r\nTG3_STAT_ADD32(&sp->tx_ucast_packets, MAC_TX_STATS_UCAST);\r\nTG3_STAT_ADD32(&sp->tx_mcast_packets, MAC_TX_STATS_MCAST);\r\nTG3_STAT_ADD32(&sp->tx_bcast_packets, MAC_TX_STATS_BCAST);\r\nif (unlikely(tg3_flag(tp, 5719_5720_RDMA_BUG) &&\r\n(sp->tx_ucast_packets.low + sp->tx_mcast_packets.low +\r\nsp->tx_bcast_packets.low) > TG3_NUM_RDMA_CHANNELS)) {\r\nu32 val;\r\nval = tr32(TG3_LSO_RD_DMA_CRPTEN_CTRL);\r\nval &= ~tg3_lso_rd_dma_workaround_bit(tp);\r\ntw32(TG3_LSO_RD_DMA_CRPTEN_CTRL, val);\r\ntg3_flag_clear(tp, 5719_5720_RDMA_BUG);\r\n}\r\nTG3_STAT_ADD32(&sp->rx_octets, MAC_RX_STATS_OCTETS);\r\nTG3_STAT_ADD32(&sp->rx_fragments, MAC_RX_STATS_FRAGMENTS);\r\nTG3_STAT_ADD32(&sp->rx_ucast_packets, MAC_RX_STATS_UCAST);\r\nTG3_STAT_ADD32(&sp->rx_mcast_packets, MAC_RX_STATS_MCAST);\r\nTG3_STAT_ADD32(&sp->rx_bcast_packets, MAC_RX_STATS_BCAST);\r\nTG3_STAT_ADD32(&sp->rx_fcs_errors, MAC_RX_STATS_FCS_ERRORS);\r\nTG3_STAT_ADD32(&sp->rx_align_errors, MAC_RX_STATS_ALIGN_ERRORS);\r\nTG3_STAT_ADD32(&sp->rx_xon_pause_rcvd, MAC_RX_STATS_XON_PAUSE_RECVD);\r\nTG3_STAT_ADD32(&sp->rx_xoff_pause_rcvd, MAC_RX_STATS_XOFF_PAUSE_RECVD);\r\nTG3_STAT_ADD32(&sp->rx_mac_ctrl_rcvd, MAC_RX_STATS_MAC_CTRL_RECVD);\r\nTG3_STAT_ADD32(&sp->rx_xoff_entered, MAC_RX_STATS_XOFF_ENTERED);\r\nTG3_STAT_ADD32(&sp->rx_frame_too_long_errors, MAC_RX_STATS_FRAME_TOO_LONG);\r\nTG3_STAT_ADD32(&sp->rx_jabbers, MAC_RX_STATS_JABBERS);\r\nTG3_STAT_ADD32(&sp->rx_undersize_packets, MAC_RX_STATS_UNDERSIZE);\r\nTG3_STAT_ADD32(&sp->rxbds_empty, RCVLPC_NO_RCV_BD_CNT);\r\nif (tg3_asic_rev(tp) != ASIC_REV_5717 &&\r\ntg3_asic_rev(tp) != ASIC_REV_5762 &&\r\ntg3_chip_rev_id(tp) != CHIPREV_ID_5719_A0 &&\r\ntg3_chip_rev_id(tp) != CHIPREV_ID_5720_A0) {\r\nTG3_STAT_ADD32(&sp->rx_discards, RCVLPC_IN_DISCARDS_CNT);\r\n} else {\r\nu32 val = tr32(HOSTCC_FLOW_ATTN);\r\nval = (val & HOSTCC_FLOW_ATTN_MBUF_LWM) ? 1 : 0;\r\nif (val) {\r\ntw32(HOSTCC_FLOW_ATTN, HOSTCC_FLOW_ATTN_MBUF_LWM);\r\nsp->rx_discards.low += val;\r\nif (sp->rx_discards.low < val)\r\nsp->rx_discards.high += 1;\r\n}\r\nsp->mbuf_lwm_thresh_hit = sp->rx_discards;\r\n}\r\nTG3_STAT_ADD32(&sp->rx_errors, RCVLPC_IN_ERRORS_CNT);\r\n}\r\nstatic void tg3_chk_missed_msi(struct tg3 *tp)\r\n{\r\nu32 i;\r\nfor (i = 0; i < tp->irq_cnt; i++) {\r\nstruct tg3_napi *tnapi = &tp->napi[i];\r\nif (tg3_has_work(tnapi)) {\r\nif (tnapi->last_rx_cons == tnapi->rx_rcb_ptr &&\r\ntnapi->last_tx_cons == tnapi->tx_cons) {\r\nif (tnapi->chk_msi_cnt < 1) {\r\ntnapi->chk_msi_cnt++;\r\nreturn;\r\n}\r\ntg3_msi(0, tnapi);\r\n}\r\n}\r\ntnapi->chk_msi_cnt = 0;\r\ntnapi->last_rx_cons = tnapi->rx_rcb_ptr;\r\ntnapi->last_tx_cons = tnapi->tx_cons;\r\n}\r\n}\r\nstatic void tg3_timer(unsigned long __opaque)\r\n{\r\nstruct tg3 *tp = (struct tg3 *) __opaque;\r\nspin_lock(&tp->lock);\r\nif (tp->irq_sync || tg3_flag(tp, RESET_TASK_PENDING)) {\r\nspin_unlock(&tp->lock);\r\ngoto restart_timer;\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\r\ntg3_flag(tp, 57765_CLASS))\r\ntg3_chk_missed_msi(tp);\r\nif (tg3_flag(tp, FLUSH_POSTED_WRITES)) {\r\ntr32(HOSTCC_MODE);\r\n}\r\nif (!tg3_flag(tp, TAGGED_STATUS)) {\r\nif (tp->napi[0].hw_status->status & SD_STATUS_UPDATED) {\r\ntw32(GRC_LOCAL_CTRL,\r\ntp->grc_local_ctrl | GRC_LCLCTRL_SETINT);\r\n} else {\r\ntw32(HOSTCC_MODE, tp->coalesce_mode |\r\nHOSTCC_MODE_ENABLE | HOSTCC_MODE_NOW);\r\n}\r\nif (!(tr32(WDMAC_MODE) & WDMAC_MODE_ENABLE)) {\r\nspin_unlock(&tp->lock);\r\ntg3_reset_task_schedule(tp);\r\ngoto restart_timer;\r\n}\r\n}\r\nif (!--tp->timer_counter) {\r\nif (tg3_flag(tp, 5705_PLUS))\r\ntg3_periodic_fetch_stats(tp);\r\nif (tp->setlpicnt && !--tp->setlpicnt)\r\ntg3_phy_eee_enable(tp);\r\nif (tg3_flag(tp, USE_LINKCHG_REG)) {\r\nu32 mac_stat;\r\nint phy_event;\r\nmac_stat = tr32(MAC_STATUS);\r\nphy_event = 0;\r\nif (tp->phy_flags & TG3_PHYFLG_USE_MI_INTERRUPT) {\r\nif (mac_stat & MAC_STATUS_MI_INTERRUPT)\r\nphy_event = 1;\r\n} else if (mac_stat & MAC_STATUS_LNKSTATE_CHANGED)\r\nphy_event = 1;\r\nif (phy_event)\r\ntg3_setup_phy(tp, false);\r\n} else if (tg3_flag(tp, POLL_SERDES)) {\r\nu32 mac_stat = tr32(MAC_STATUS);\r\nint need_setup = 0;\r\nif (tp->link_up &&\r\n(mac_stat & MAC_STATUS_LNKSTATE_CHANGED)) {\r\nneed_setup = 1;\r\n}\r\nif (!tp->link_up &&\r\n(mac_stat & (MAC_STATUS_PCS_SYNCED |\r\nMAC_STATUS_SIGNAL_DET))) {\r\nneed_setup = 1;\r\n}\r\nif (need_setup) {\r\nif (!tp->serdes_counter) {\r\ntw32_f(MAC_MODE,\r\n(tp->mac_mode &\r\n~MAC_MODE_PORT_MODE_MASK));\r\nudelay(40);\r\ntw32_f(MAC_MODE, tp->mac_mode);\r\nudelay(40);\r\n}\r\ntg3_setup_phy(tp, false);\r\n}\r\n} else if ((tp->phy_flags & TG3_PHYFLG_MII_SERDES) &&\r\ntg3_flag(tp, 5780_CLASS)) {\r\ntg3_serdes_parallel_detect(tp);\r\n} else if (tg3_flag(tp, POLL_CPMU_LINK)) {\r\nu32 cpmu = tr32(TG3_CPMU_STATUS);\r\nbool link_up = !((cpmu & TG3_CPMU_STATUS_LINK_MASK) ==\r\nTG3_CPMU_STATUS_LINK_MASK);\r\nif (link_up != tp->link_up)\r\ntg3_setup_phy(tp, false);\r\n}\r\ntp->timer_counter = tp->timer_multiplier;\r\n}\r\nif (!--tp->asf_counter) {\r\nif (tg3_flag(tp, ENABLE_ASF) && !tg3_flag(tp, ENABLE_APE)) {\r\ntg3_wait_for_event_ack(tp);\r\ntg3_write_mem(tp, NIC_SRAM_FW_CMD_MBOX,\r\nFWCMD_NICDRV_ALIVE3);\r\ntg3_write_mem(tp, NIC_SRAM_FW_CMD_LEN_MBOX, 4);\r\ntg3_write_mem(tp, NIC_SRAM_FW_CMD_DATA_MBOX,\r\nTG3_FW_UPDATE_TIMEOUT_SEC);\r\ntg3_generate_fw_event(tp);\r\n}\r\ntp->asf_counter = tp->asf_multiplier;\r\n}\r\nspin_unlock(&tp->lock);\r\nrestart_timer:\r\ntp->timer.expires = jiffies + tp->timer_offset;\r\nadd_timer(&tp->timer);\r\n}\r\nstatic void tg3_timer_init(struct tg3 *tp)\r\n{\r\nif (tg3_flag(tp, TAGGED_STATUS) &&\r\ntg3_asic_rev(tp) != ASIC_REV_5717 &&\r\n!tg3_flag(tp, 57765_CLASS))\r\ntp->timer_offset = HZ;\r\nelse\r\ntp->timer_offset = HZ / 10;\r\nBUG_ON(tp->timer_offset > HZ);\r\ntp->timer_multiplier = (HZ / tp->timer_offset);\r\ntp->asf_multiplier = (HZ / tp->timer_offset) *\r\nTG3_FW_UPDATE_FREQ_SEC;\r\ninit_timer(&tp->timer);\r\ntp->timer.data = (unsigned long) tp;\r\ntp->timer.function = tg3_timer;\r\n}\r\nstatic void tg3_timer_start(struct tg3 *tp)\r\n{\r\ntp->asf_counter = tp->asf_multiplier;\r\ntp->timer_counter = tp->timer_multiplier;\r\ntp->timer.expires = jiffies + tp->timer_offset;\r\nadd_timer(&tp->timer);\r\n}\r\nstatic void tg3_timer_stop(struct tg3 *tp)\r\n{\r\ndel_timer_sync(&tp->timer);\r\n}\r\nstatic int tg3_restart_hw(struct tg3 *tp, bool reset_phy)\r\n__releases(tp->lock)\r\n__acquires(tp->lock)\r\n{\r\nint err;\r\nerr = tg3_init_hw(tp, reset_phy);\r\nif (err) {\r\nnetdev_err(tp->dev,\r\n"Failed to re-initialize device, aborting\n");\r\ntg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\r\ntg3_full_unlock(tp);\r\ntg3_timer_stop(tp);\r\ntp->irq_sync = 0;\r\ntg3_napi_enable(tp);\r\ndev_close(tp->dev);\r\ntg3_full_lock(tp, 0);\r\n}\r\nreturn err;\r\n}\r\nstatic void tg3_reset_task(struct work_struct *work)\r\n{\r\nstruct tg3 *tp = container_of(work, struct tg3, reset_task);\r\nint err;\r\nrtnl_lock();\r\ntg3_full_lock(tp, 0);\r\nif (!netif_running(tp->dev)) {\r\ntg3_flag_clear(tp, RESET_TASK_PENDING);\r\ntg3_full_unlock(tp);\r\nrtnl_unlock();\r\nreturn;\r\n}\r\ntg3_full_unlock(tp);\r\ntg3_phy_stop(tp);\r\ntg3_netif_stop(tp);\r\ntg3_full_lock(tp, 1);\r\nif (tg3_flag(tp, TX_RECOVERY_PENDING)) {\r\ntp->write32_tx_mbox = tg3_write32_tx_mbox;\r\ntp->write32_rx_mbox = tg3_write_flush_reg32;\r\ntg3_flag_set(tp, MBOX_WRITE_REORDER);\r\ntg3_flag_clear(tp, TX_RECOVERY_PENDING);\r\n}\r\ntg3_halt(tp, RESET_KIND_SHUTDOWN, 0);\r\nerr = tg3_init_hw(tp, true);\r\nif (err)\r\ngoto out;\r\ntg3_netif_start(tp);\r\nout:\r\ntg3_full_unlock(tp);\r\nif (!err)\r\ntg3_phy_start(tp);\r\ntg3_flag_clear(tp, RESET_TASK_PENDING);\r\nrtnl_unlock();\r\n}\r\nstatic int tg3_request_irq(struct tg3 *tp, int irq_num)\r\n{\r\nirq_handler_t fn;\r\nunsigned long flags;\r\nchar *name;\r\nstruct tg3_napi *tnapi = &tp->napi[irq_num];\r\nif (tp->irq_cnt == 1)\r\nname = tp->dev->name;\r\nelse {\r\nname = &tnapi->irq_lbl[0];\r\nif (tnapi->tx_buffers && tnapi->rx_rcb)\r\nsnprintf(name, IFNAMSIZ,\r\n"%s-txrx-%d", tp->dev->name, irq_num);\r\nelse if (tnapi->tx_buffers)\r\nsnprintf(name, IFNAMSIZ,\r\n"%s-tx-%d", tp->dev->name, irq_num);\r\nelse if (tnapi->rx_rcb)\r\nsnprintf(name, IFNAMSIZ,\r\n"%s-rx-%d", tp->dev->name, irq_num);\r\nelse\r\nsnprintf(name, IFNAMSIZ,\r\n"%s-%d", tp->dev->name, irq_num);\r\nname[IFNAMSIZ-1] = 0;\r\n}\r\nif (tg3_flag(tp, USING_MSI) || tg3_flag(tp, USING_MSIX)) {\r\nfn = tg3_msi;\r\nif (tg3_flag(tp, 1SHOT_MSI))\r\nfn = tg3_msi_1shot;\r\nflags = 0;\r\n} else {\r\nfn = tg3_interrupt;\r\nif (tg3_flag(tp, TAGGED_STATUS))\r\nfn = tg3_interrupt_tagged;\r\nflags = IRQF_SHARED;\r\n}\r\nreturn request_irq(tnapi->irq_vec, fn, flags, name, tnapi);\r\n}\r\nstatic int tg3_test_interrupt(struct tg3 *tp)\r\n{\r\nstruct tg3_napi *tnapi = &tp->napi[0];\r\nstruct net_device *dev = tp->dev;\r\nint err, i, intr_ok = 0;\r\nu32 val;\r\nif (!netif_running(dev))\r\nreturn -ENODEV;\r\ntg3_disable_ints(tp);\r\nfree_irq(tnapi->irq_vec, tnapi);\r\nif (tg3_flag(tp, 57765_PLUS)) {\r\nval = tr32(MSGINT_MODE) | MSGINT_MODE_ONE_SHOT_DISABLE;\r\ntw32(MSGINT_MODE, val);\r\n}\r\nerr = request_irq(tnapi->irq_vec, tg3_test_isr,\r\nIRQF_SHARED, dev->name, tnapi);\r\nif (err)\r\nreturn err;\r\ntnapi->hw_status->status &= ~SD_STATUS_UPDATED;\r\ntg3_enable_ints(tp);\r\ntw32_f(HOSTCC_MODE, tp->coalesce_mode | HOSTCC_MODE_ENABLE |\r\ntnapi->coal_now);\r\nfor (i = 0; i < 5; i++) {\r\nu32 int_mbox, misc_host_ctrl;\r\nint_mbox = tr32_mailbox(tnapi->int_mbox);\r\nmisc_host_ctrl = tr32(TG3PCI_MISC_HOST_CTRL);\r\nif ((int_mbox != 0) ||\r\n(misc_host_ctrl & MISC_HOST_CTRL_MASK_PCI_INT)) {\r\nintr_ok = 1;\r\nbreak;\r\n}\r\nif (tg3_flag(tp, 57765_PLUS) &&\r\ntnapi->hw_status->status_tag != tnapi->last_tag)\r\ntw32_mailbox_f(tnapi->int_mbox, tnapi->last_tag << 24);\r\nmsleep(10);\r\n}\r\ntg3_disable_ints(tp);\r\nfree_irq(tnapi->irq_vec, tnapi);\r\nerr = tg3_request_irq(tp, 0);\r\nif (err)\r\nreturn err;\r\nif (intr_ok) {\r\nif (tg3_flag(tp, 57765_PLUS) && tg3_flag(tp, 1SHOT_MSI)) {\r\nval = tr32(MSGINT_MODE) & ~MSGINT_MODE_ONE_SHOT_DISABLE;\r\ntw32(MSGINT_MODE, val);\r\n}\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int tg3_test_msi(struct tg3 *tp)\r\n{\r\nint err;\r\nu16 pci_cmd;\r\nif (!tg3_flag(tp, USING_MSI))\r\nreturn 0;\r\npci_read_config_word(tp->pdev, PCI_COMMAND, &pci_cmd);\r\npci_write_config_word(tp->pdev, PCI_COMMAND,\r\npci_cmd & ~PCI_COMMAND_SERR);\r\nerr = tg3_test_interrupt(tp);\r\npci_write_config_word(tp->pdev, PCI_COMMAND, pci_cmd);\r\nif (!err)\r\nreturn 0;\r\nif (err != -EIO)\r\nreturn err;\r\nnetdev_warn(tp->dev, "No interrupt was generated using MSI. Switching "\r\n"to INTx mode. Please report this failure to the PCI "\r\n"maintainer and include system chipset information\n");\r\nfree_irq(tp->napi[0].irq_vec, &tp->napi[0]);\r\npci_disable_msi(tp->pdev);\r\ntg3_flag_clear(tp, USING_MSI);\r\ntp->napi[0].irq_vec = tp->pdev->irq;\r\nerr = tg3_request_irq(tp, 0);\r\nif (err)\r\nreturn err;\r\ntg3_full_lock(tp, 1);\r\ntg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\r\nerr = tg3_init_hw(tp, true);\r\ntg3_full_unlock(tp);\r\nif (err)\r\nfree_irq(tp->napi[0].irq_vec, &tp->napi[0]);\r\nreturn err;\r\n}\r\nstatic int tg3_request_firmware(struct tg3 *tp)\r\n{\r\nconst struct tg3_firmware_hdr *fw_hdr;\r\nif (request_firmware(&tp->fw, tp->fw_needed, &tp->pdev->dev)) {\r\nnetdev_err(tp->dev, "Failed to load firmware \"%s\"\n",\r\ntp->fw_needed);\r\nreturn -ENOENT;\r\n}\r\nfw_hdr = (struct tg3_firmware_hdr *)tp->fw->data;\r\ntp->fw_len = be32_to_cpu(fw_hdr->len);\r\nif (tp->fw_len < (tp->fw->size - TG3_FW_HDR_LEN)) {\r\nnetdev_err(tp->dev, "bogus length %d in \"%s\"\n",\r\ntp->fw_len, tp->fw_needed);\r\nrelease_firmware(tp->fw);\r\ntp->fw = NULL;\r\nreturn -EINVAL;\r\n}\r\ntp->fw_needed = NULL;\r\nreturn 0;\r\n}\r\nstatic u32 tg3_irq_count(struct tg3 *tp)\r\n{\r\nu32 irq_cnt = max(tp->rxq_cnt, tp->txq_cnt);\r\nif (irq_cnt > 1) {\r\nirq_cnt = min_t(unsigned, irq_cnt + 1, tp->irq_max);\r\n}\r\nreturn irq_cnt;\r\n}\r\nstatic bool tg3_enable_msix(struct tg3 *tp)\r\n{\r\nint i, rc;\r\nstruct msix_entry msix_ent[TG3_IRQ_MAX_VECS];\r\ntp->txq_cnt = tp->txq_req;\r\ntp->rxq_cnt = tp->rxq_req;\r\nif (!tp->rxq_cnt)\r\ntp->rxq_cnt = netif_get_num_default_rss_queues();\r\nif (tp->rxq_cnt > tp->rxq_max)\r\ntp->rxq_cnt = tp->rxq_max;\r\nif (!tp->txq_req)\r\ntp->txq_cnt = 1;\r\ntp->irq_cnt = tg3_irq_count(tp);\r\nfor (i = 0; i < tp->irq_max; i++) {\r\nmsix_ent[i].entry = i;\r\nmsix_ent[i].vector = 0;\r\n}\r\nrc = pci_enable_msix_range(tp->pdev, msix_ent, 1, tp->irq_cnt);\r\nif (rc < 0) {\r\nreturn false;\r\n} else if (rc < tp->irq_cnt) {\r\nnetdev_notice(tp->dev, "Requested %d MSI-X vectors, received %d\n",\r\ntp->irq_cnt, rc);\r\ntp->irq_cnt = rc;\r\ntp->rxq_cnt = max(rc - 1, 1);\r\nif (tp->txq_cnt)\r\ntp->txq_cnt = min(tp->rxq_cnt, tp->txq_max);\r\n}\r\nfor (i = 0; i < tp->irq_max; i++)\r\ntp->napi[i].irq_vec = msix_ent[i].vector;\r\nif (netif_set_real_num_rx_queues(tp->dev, tp->rxq_cnt)) {\r\npci_disable_msix(tp->pdev);\r\nreturn false;\r\n}\r\nif (tp->irq_cnt == 1)\r\nreturn true;\r\ntg3_flag_set(tp, ENABLE_RSS);\r\nif (tp->txq_cnt > 1)\r\ntg3_flag_set(tp, ENABLE_TSS);\r\nnetif_set_real_num_tx_queues(tp->dev, tp->txq_cnt);\r\nreturn true;\r\n}\r\nstatic void tg3_ints_init(struct tg3 *tp)\r\n{\r\nif ((tg3_flag(tp, SUPPORT_MSI) || tg3_flag(tp, SUPPORT_MSIX)) &&\r\n!tg3_flag(tp, TAGGED_STATUS)) {\r\nnetdev_warn(tp->dev,\r\n"MSI without TAGGED_STATUS? Not using MSI\n");\r\ngoto defcfg;\r\n}\r\nif (tg3_flag(tp, SUPPORT_MSIX) && tg3_enable_msix(tp))\r\ntg3_flag_set(tp, USING_MSIX);\r\nelse if (tg3_flag(tp, SUPPORT_MSI) && pci_enable_msi(tp->pdev) == 0)\r\ntg3_flag_set(tp, USING_MSI);\r\nif (tg3_flag(tp, USING_MSI) || tg3_flag(tp, USING_MSIX)) {\r\nu32 msi_mode = tr32(MSGINT_MODE);\r\nif (tg3_flag(tp, USING_MSIX) && tp->irq_cnt > 1)\r\nmsi_mode |= MSGINT_MODE_MULTIVEC_EN;\r\nif (!tg3_flag(tp, 1SHOT_MSI))\r\nmsi_mode |= MSGINT_MODE_ONE_SHOT_DISABLE;\r\ntw32(MSGINT_MODE, msi_mode | MSGINT_MODE_ENABLE);\r\n}\r\ndefcfg:\r\nif (!tg3_flag(tp, USING_MSIX)) {\r\ntp->irq_cnt = 1;\r\ntp->napi[0].irq_vec = tp->pdev->irq;\r\n}\r\nif (tp->irq_cnt == 1) {\r\ntp->txq_cnt = 1;\r\ntp->rxq_cnt = 1;\r\nnetif_set_real_num_tx_queues(tp->dev, 1);\r\nnetif_set_real_num_rx_queues(tp->dev, 1);\r\n}\r\n}\r\nstatic void tg3_ints_fini(struct tg3 *tp)\r\n{\r\nif (tg3_flag(tp, USING_MSIX))\r\npci_disable_msix(tp->pdev);\r\nelse if (tg3_flag(tp, USING_MSI))\r\npci_disable_msi(tp->pdev);\r\ntg3_flag_clear(tp, USING_MSI);\r\ntg3_flag_clear(tp, USING_MSIX);\r\ntg3_flag_clear(tp, ENABLE_RSS);\r\ntg3_flag_clear(tp, ENABLE_TSS);\r\n}\r\nstatic int tg3_start(struct tg3 *tp, bool reset_phy, bool test_irq,\r\nbool init)\r\n{\r\nstruct net_device *dev = tp->dev;\r\nint i, err;\r\ntg3_ints_init(tp);\r\ntg3_rss_check_indir_tbl(tp);\r\nerr = tg3_alloc_consistent(tp);\r\nif (err)\r\ngoto out_ints_fini;\r\ntg3_napi_init(tp);\r\ntg3_napi_enable(tp);\r\nfor (i = 0; i < tp->irq_cnt; i++) {\r\nstruct tg3_napi *tnapi = &tp->napi[i];\r\nerr = tg3_request_irq(tp, i);\r\nif (err) {\r\nfor (i--; i >= 0; i--) {\r\ntnapi = &tp->napi[i];\r\nfree_irq(tnapi->irq_vec, tnapi);\r\n}\r\ngoto out_napi_fini;\r\n}\r\n}\r\ntg3_full_lock(tp, 0);\r\nif (init)\r\ntg3_ape_driver_state_change(tp, RESET_KIND_INIT);\r\nerr = tg3_init_hw(tp, reset_phy);\r\nif (err) {\r\ntg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\r\ntg3_free_rings(tp);\r\n}\r\ntg3_full_unlock(tp);\r\nif (err)\r\ngoto out_free_irq;\r\nif (test_irq && tg3_flag(tp, USING_MSI)) {\r\nerr = tg3_test_msi(tp);\r\nif (err) {\r\ntg3_full_lock(tp, 0);\r\ntg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\r\ntg3_free_rings(tp);\r\ntg3_full_unlock(tp);\r\ngoto out_napi_fini;\r\n}\r\nif (!tg3_flag(tp, 57765_PLUS) && tg3_flag(tp, USING_MSI)) {\r\nu32 val = tr32(PCIE_TRANSACTION_CFG);\r\ntw32(PCIE_TRANSACTION_CFG,\r\nval | PCIE_TRANS_CFG_1SHOT_MSI);\r\n}\r\n}\r\ntg3_phy_start(tp);\r\ntg3_hwmon_open(tp);\r\ntg3_full_lock(tp, 0);\r\ntg3_timer_start(tp);\r\ntg3_flag_set(tp, INIT_COMPLETE);\r\ntg3_enable_ints(tp);\r\ntg3_ptp_resume(tp);\r\ntg3_full_unlock(tp);\r\nnetif_tx_start_all_queues(dev);\r\nif (dev->features & NETIF_F_LOOPBACK)\r\ntg3_set_loopback(dev, dev->features);\r\nreturn 0;\r\nout_free_irq:\r\nfor (i = tp->irq_cnt - 1; i >= 0; i--) {\r\nstruct tg3_napi *tnapi = &tp->napi[i];\r\nfree_irq(tnapi->irq_vec, tnapi);\r\n}\r\nout_napi_fini:\r\ntg3_napi_disable(tp);\r\ntg3_napi_fini(tp);\r\ntg3_free_consistent(tp);\r\nout_ints_fini:\r\ntg3_ints_fini(tp);\r\nreturn err;\r\n}\r\nstatic void tg3_stop(struct tg3 *tp)\r\n{\r\nint i;\r\ntg3_reset_task_cancel(tp);\r\ntg3_netif_stop(tp);\r\ntg3_timer_stop(tp);\r\ntg3_hwmon_close(tp);\r\ntg3_phy_stop(tp);\r\ntg3_full_lock(tp, 1);\r\ntg3_disable_ints(tp);\r\ntg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\r\ntg3_free_rings(tp);\r\ntg3_flag_clear(tp, INIT_COMPLETE);\r\ntg3_full_unlock(tp);\r\nfor (i = tp->irq_cnt - 1; i >= 0; i--) {\r\nstruct tg3_napi *tnapi = &tp->napi[i];\r\nfree_irq(tnapi->irq_vec, tnapi);\r\n}\r\ntg3_ints_fini(tp);\r\ntg3_napi_fini(tp);\r\ntg3_free_consistent(tp);\r\n}\r\nstatic int tg3_open(struct net_device *dev)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nint err;\r\nif (tp->pcierr_recovery) {\r\nnetdev_err(dev, "Failed to open device. PCI error recovery "\r\n"in progress\n");\r\nreturn -EAGAIN;\r\n}\r\nif (tp->fw_needed) {\r\nerr = tg3_request_firmware(tp);\r\nif (tg3_asic_rev(tp) == ASIC_REV_57766) {\r\nif (err) {\r\nnetdev_warn(tp->dev, "EEE capability disabled\n");\r\ntp->phy_flags &= ~TG3_PHYFLG_EEE_CAP;\r\n} else if (!(tp->phy_flags & TG3_PHYFLG_EEE_CAP)) {\r\nnetdev_warn(tp->dev, "EEE capability restored\n");\r\ntp->phy_flags |= TG3_PHYFLG_EEE_CAP;\r\n}\r\n} else if (tg3_chip_rev_id(tp) == CHIPREV_ID_5701_A0) {\r\nif (err)\r\nreturn err;\r\n} else if (err) {\r\nnetdev_warn(tp->dev, "TSO capability disabled\n");\r\ntg3_flag_clear(tp, TSO_CAPABLE);\r\n} else if (!tg3_flag(tp, TSO_CAPABLE)) {\r\nnetdev_notice(tp->dev, "TSO capability restored\n");\r\ntg3_flag_set(tp, TSO_CAPABLE);\r\n}\r\n}\r\ntg3_carrier_off(tp);\r\nerr = tg3_power_up(tp);\r\nif (err)\r\nreturn err;\r\ntg3_full_lock(tp, 0);\r\ntg3_disable_ints(tp);\r\ntg3_flag_clear(tp, INIT_COMPLETE);\r\ntg3_full_unlock(tp);\r\nerr = tg3_start(tp,\r\n!(tp->phy_flags & TG3_PHYFLG_KEEP_LINK_ON_PWRDN),\r\ntrue, true);\r\nif (err) {\r\ntg3_frob_aux_power(tp, false);\r\npci_set_power_state(tp->pdev, PCI_D3hot);\r\n}\r\nreturn err;\r\n}\r\nstatic int tg3_close(struct net_device *dev)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nif (tp->pcierr_recovery) {\r\nnetdev_err(dev, "Failed to close device. PCI error recovery "\r\n"in progress\n");\r\nreturn -EAGAIN;\r\n}\r\ntg3_stop(tp);\r\nmemset(&tp->net_stats_prev, 0, sizeof(tp->net_stats_prev));\r\nmemset(&tp->estats_prev, 0, sizeof(tp->estats_prev));\r\nif (pci_device_is_present(tp->pdev)) {\r\ntg3_power_down_prepare(tp);\r\ntg3_carrier_off(tp);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline u64 get_stat64(tg3_stat64_t *val)\r\n{\r\nreturn ((u64)val->high << 32) | ((u64)val->low);\r\n}\r\nstatic u64 tg3_calc_crc_errors(struct tg3 *tp)\r\n{\r\nstruct tg3_hw_stats *hw_stats = tp->hw_stats;\r\nif (!(tp->phy_flags & TG3_PHYFLG_PHY_SERDES) &&\r\n(tg3_asic_rev(tp) == ASIC_REV_5700 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5701)) {\r\nu32 val;\r\nif (!tg3_readphy(tp, MII_TG3_TEST1, &val)) {\r\ntg3_writephy(tp, MII_TG3_TEST1,\r\nval | MII_TG3_TEST1_CRC_EN);\r\ntg3_readphy(tp, MII_TG3_RXR_COUNTERS, &val);\r\n} else\r\nval = 0;\r\ntp->phy_crc_errors += val;\r\nreturn tp->phy_crc_errors;\r\n}\r\nreturn get_stat64(&hw_stats->rx_fcs_errors);\r\n}\r\nstatic void tg3_get_estats(struct tg3 *tp, struct tg3_ethtool_stats *estats)\r\n{\r\nstruct tg3_ethtool_stats *old_estats = &tp->estats_prev;\r\nstruct tg3_hw_stats *hw_stats = tp->hw_stats;\r\nESTAT_ADD(rx_octets);\r\nESTAT_ADD(rx_fragments);\r\nESTAT_ADD(rx_ucast_packets);\r\nESTAT_ADD(rx_mcast_packets);\r\nESTAT_ADD(rx_bcast_packets);\r\nESTAT_ADD(rx_fcs_errors);\r\nESTAT_ADD(rx_align_errors);\r\nESTAT_ADD(rx_xon_pause_rcvd);\r\nESTAT_ADD(rx_xoff_pause_rcvd);\r\nESTAT_ADD(rx_mac_ctrl_rcvd);\r\nESTAT_ADD(rx_xoff_entered);\r\nESTAT_ADD(rx_frame_too_long_errors);\r\nESTAT_ADD(rx_jabbers);\r\nESTAT_ADD(rx_undersize_packets);\r\nESTAT_ADD(rx_in_length_errors);\r\nESTAT_ADD(rx_out_length_errors);\r\nESTAT_ADD(rx_64_or_less_octet_packets);\r\nESTAT_ADD(rx_65_to_127_octet_packets);\r\nESTAT_ADD(rx_128_to_255_octet_packets);\r\nESTAT_ADD(rx_256_to_511_octet_packets);\r\nESTAT_ADD(rx_512_to_1023_octet_packets);\r\nESTAT_ADD(rx_1024_to_1522_octet_packets);\r\nESTAT_ADD(rx_1523_to_2047_octet_packets);\r\nESTAT_ADD(rx_2048_to_4095_octet_packets);\r\nESTAT_ADD(rx_4096_to_8191_octet_packets);\r\nESTAT_ADD(rx_8192_to_9022_octet_packets);\r\nESTAT_ADD(tx_octets);\r\nESTAT_ADD(tx_collisions);\r\nESTAT_ADD(tx_xon_sent);\r\nESTAT_ADD(tx_xoff_sent);\r\nESTAT_ADD(tx_flow_control);\r\nESTAT_ADD(tx_mac_errors);\r\nESTAT_ADD(tx_single_collisions);\r\nESTAT_ADD(tx_mult_collisions);\r\nESTAT_ADD(tx_deferred);\r\nESTAT_ADD(tx_excessive_collisions);\r\nESTAT_ADD(tx_late_collisions);\r\nESTAT_ADD(tx_collide_2times);\r\nESTAT_ADD(tx_collide_3times);\r\nESTAT_ADD(tx_collide_4times);\r\nESTAT_ADD(tx_collide_5times);\r\nESTAT_ADD(tx_collide_6times);\r\nESTAT_ADD(tx_collide_7times);\r\nESTAT_ADD(tx_collide_8times);\r\nESTAT_ADD(tx_collide_9times);\r\nESTAT_ADD(tx_collide_10times);\r\nESTAT_ADD(tx_collide_11times);\r\nESTAT_ADD(tx_collide_12times);\r\nESTAT_ADD(tx_collide_13times);\r\nESTAT_ADD(tx_collide_14times);\r\nESTAT_ADD(tx_collide_15times);\r\nESTAT_ADD(tx_ucast_packets);\r\nESTAT_ADD(tx_mcast_packets);\r\nESTAT_ADD(tx_bcast_packets);\r\nESTAT_ADD(tx_carrier_sense_errors);\r\nESTAT_ADD(tx_discards);\r\nESTAT_ADD(tx_errors);\r\nESTAT_ADD(dma_writeq_full);\r\nESTAT_ADD(dma_write_prioq_full);\r\nESTAT_ADD(rxbds_empty);\r\nESTAT_ADD(rx_discards);\r\nESTAT_ADD(rx_errors);\r\nESTAT_ADD(rx_threshold_hit);\r\nESTAT_ADD(dma_readq_full);\r\nESTAT_ADD(dma_read_prioq_full);\r\nESTAT_ADD(tx_comp_queue_full);\r\nESTAT_ADD(ring_set_send_prod_index);\r\nESTAT_ADD(ring_status_update);\r\nESTAT_ADD(nic_irqs);\r\nESTAT_ADD(nic_avoided_irqs);\r\nESTAT_ADD(nic_tx_threshold_hit);\r\nESTAT_ADD(mbuf_lwm_thresh_hit);\r\n}\r\nstatic void tg3_get_nstats(struct tg3 *tp, struct rtnl_link_stats64 *stats)\r\n{\r\nstruct rtnl_link_stats64 *old_stats = &tp->net_stats_prev;\r\nstruct tg3_hw_stats *hw_stats = tp->hw_stats;\r\nstats->rx_packets = old_stats->rx_packets +\r\nget_stat64(&hw_stats->rx_ucast_packets) +\r\nget_stat64(&hw_stats->rx_mcast_packets) +\r\nget_stat64(&hw_stats->rx_bcast_packets);\r\nstats->tx_packets = old_stats->tx_packets +\r\nget_stat64(&hw_stats->tx_ucast_packets) +\r\nget_stat64(&hw_stats->tx_mcast_packets) +\r\nget_stat64(&hw_stats->tx_bcast_packets);\r\nstats->rx_bytes = old_stats->rx_bytes +\r\nget_stat64(&hw_stats->rx_octets);\r\nstats->tx_bytes = old_stats->tx_bytes +\r\nget_stat64(&hw_stats->tx_octets);\r\nstats->rx_errors = old_stats->rx_errors +\r\nget_stat64(&hw_stats->rx_errors);\r\nstats->tx_errors = old_stats->tx_errors +\r\nget_stat64(&hw_stats->tx_errors) +\r\nget_stat64(&hw_stats->tx_mac_errors) +\r\nget_stat64(&hw_stats->tx_carrier_sense_errors) +\r\nget_stat64(&hw_stats->tx_discards);\r\nstats->multicast = old_stats->multicast +\r\nget_stat64(&hw_stats->rx_mcast_packets);\r\nstats->collisions = old_stats->collisions +\r\nget_stat64(&hw_stats->tx_collisions);\r\nstats->rx_length_errors = old_stats->rx_length_errors +\r\nget_stat64(&hw_stats->rx_frame_too_long_errors) +\r\nget_stat64(&hw_stats->rx_undersize_packets);\r\nstats->rx_frame_errors = old_stats->rx_frame_errors +\r\nget_stat64(&hw_stats->rx_align_errors);\r\nstats->tx_aborted_errors = old_stats->tx_aborted_errors +\r\nget_stat64(&hw_stats->tx_discards);\r\nstats->tx_carrier_errors = old_stats->tx_carrier_errors +\r\nget_stat64(&hw_stats->tx_carrier_sense_errors);\r\nstats->rx_crc_errors = old_stats->rx_crc_errors +\r\ntg3_calc_crc_errors(tp);\r\nstats->rx_missed_errors = old_stats->rx_missed_errors +\r\nget_stat64(&hw_stats->rx_discards);\r\nstats->rx_dropped = tp->rx_dropped;\r\nstats->tx_dropped = tp->tx_dropped;\r\n}\r\nstatic int tg3_get_regs_len(struct net_device *dev)\r\n{\r\nreturn TG3_REG_BLK_SIZE;\r\n}\r\nstatic void tg3_get_regs(struct net_device *dev,\r\nstruct ethtool_regs *regs, void *_p)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nregs->version = 0;\r\nmemset(_p, 0, TG3_REG_BLK_SIZE);\r\nif (tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER)\r\nreturn;\r\ntg3_full_lock(tp, 0);\r\ntg3_dump_legacy_regs(tp, (u32 *)_p);\r\ntg3_full_unlock(tp);\r\n}\r\nstatic int tg3_get_eeprom_len(struct net_device *dev)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nreturn tp->nvram_size;\r\n}\r\nstatic int tg3_get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom, u8 *data)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nint ret, cpmu_restore = 0;\r\nu8 *pd;\r\nu32 i, offset, len, b_offset, b_count, cpmu_val = 0;\r\n__be32 val;\r\nif (tg3_flag(tp, NO_NVRAM))\r\nreturn -EINVAL;\r\noffset = eeprom->offset;\r\nlen = eeprom->len;\r\neeprom->len = 0;\r\neeprom->magic = TG3_EEPROM_MAGIC;\r\nif (tg3_flag(tp, CPMU_PRESENT)) {\r\ncpmu_val = tr32(TG3_CPMU_CTRL);\r\nif (cpmu_val & (CPMU_CTRL_LINK_AWARE_MODE |\r\nCPMU_CTRL_LINK_IDLE_MODE)) {\r\ntw32(TG3_CPMU_CTRL, cpmu_val &\r\n~(CPMU_CTRL_LINK_AWARE_MODE |\r\nCPMU_CTRL_LINK_IDLE_MODE));\r\ncpmu_restore = 1;\r\n}\r\n}\r\ntg3_override_clk(tp);\r\nif (offset & 3) {\r\nb_offset = offset & 3;\r\nb_count = 4 - b_offset;\r\nif (b_count > len) {\r\nb_count = len;\r\n}\r\nret = tg3_nvram_read_be32(tp, offset-b_offset, &val);\r\nif (ret)\r\ngoto eeprom_done;\r\nmemcpy(data, ((char *)&val) + b_offset, b_count);\r\nlen -= b_count;\r\noffset += b_count;\r\neeprom->len += b_count;\r\n}\r\npd = &data[eeprom->len];\r\nfor (i = 0; i < (len - (len & 3)); i += 4) {\r\nret = tg3_nvram_read_be32(tp, offset + i, &val);\r\nif (ret) {\r\nif (i)\r\ni -= 4;\r\neeprom->len += i;\r\ngoto eeprom_done;\r\n}\r\nmemcpy(pd + i, &val, 4);\r\nif (need_resched()) {\r\nif (signal_pending(current)) {\r\neeprom->len += i;\r\nret = -EINTR;\r\ngoto eeprom_done;\r\n}\r\ncond_resched();\r\n}\r\n}\r\neeprom->len += i;\r\nif (len & 3) {\r\npd = &data[eeprom->len];\r\nb_count = len & 3;\r\nb_offset = offset + len - b_count;\r\nret = tg3_nvram_read_be32(tp, b_offset, &val);\r\nif (ret)\r\ngoto eeprom_done;\r\nmemcpy(pd, &val, b_count);\r\neeprom->len += b_count;\r\n}\r\nret = 0;\r\neeprom_done:\r\ntg3_restore_clk(tp);\r\nif (cpmu_restore)\r\ntw32(TG3_CPMU_CTRL, cpmu_val);\r\nreturn ret;\r\n}\r\nstatic int tg3_set_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom, u8 *data)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nint ret;\r\nu32 offset, len, b_offset, odd_len;\r\nu8 *buf;\r\n__be32 start, end;\r\nif (tg3_flag(tp, NO_NVRAM) ||\r\neeprom->magic != TG3_EEPROM_MAGIC)\r\nreturn -EINVAL;\r\noffset = eeprom->offset;\r\nlen = eeprom->len;\r\nif ((b_offset = (offset & 3))) {\r\nret = tg3_nvram_read_be32(tp, offset-b_offset, &start);\r\nif (ret)\r\nreturn ret;\r\nlen += b_offset;\r\noffset &= ~3;\r\nif (len < 4)\r\nlen = 4;\r\n}\r\nodd_len = 0;\r\nif (len & 3) {\r\nodd_len = 1;\r\nlen = (len + 3) & ~3;\r\nret = tg3_nvram_read_be32(tp, offset+len-4, &end);\r\nif (ret)\r\nreturn ret;\r\n}\r\nbuf = data;\r\nif (b_offset || odd_len) {\r\nbuf = kmalloc(len, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (b_offset)\r\nmemcpy(buf, &start, 4);\r\nif (odd_len)\r\nmemcpy(buf+len-4, &end, 4);\r\nmemcpy(buf + b_offset, data, eeprom->len);\r\n}\r\nret = tg3_nvram_write_block(tp, offset, len, buf);\r\nif (buf != data)\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int tg3_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nif (tg3_flag(tp, USE_PHYLIB)) {\r\nstruct phy_device *phydev;\r\nif (!(tp->phy_flags & TG3_PHYFLG_IS_CONNECTED))\r\nreturn -EAGAIN;\r\nphydev = tp->mdio_bus->phy_map[tp->phy_addr];\r\nreturn phy_ethtool_gset(phydev, cmd);\r\n}\r\ncmd->supported = (SUPPORTED_Autoneg);\r\nif (!(tp->phy_flags & TG3_PHYFLG_10_100_ONLY))\r\ncmd->supported |= (SUPPORTED_1000baseT_Half |\r\nSUPPORTED_1000baseT_Full);\r\nif (!(tp->phy_flags & TG3_PHYFLG_ANY_SERDES)) {\r\ncmd->supported |= (SUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_TP);\r\ncmd->port = PORT_TP;\r\n} else {\r\ncmd->supported |= SUPPORTED_FIBRE;\r\ncmd->port = PORT_FIBRE;\r\n}\r\ncmd->advertising = tp->link_config.advertising;\r\nif (tg3_flag(tp, PAUSE_AUTONEG)) {\r\nif (tp->link_config.flowctrl & FLOW_CTRL_RX) {\r\nif (tp->link_config.flowctrl & FLOW_CTRL_TX) {\r\ncmd->advertising |= ADVERTISED_Pause;\r\n} else {\r\ncmd->advertising |= ADVERTISED_Pause |\r\nADVERTISED_Asym_Pause;\r\n}\r\n} else if (tp->link_config.flowctrl & FLOW_CTRL_TX) {\r\ncmd->advertising |= ADVERTISED_Asym_Pause;\r\n}\r\n}\r\nif (netif_running(dev) && tp->link_up) {\r\nethtool_cmd_speed_set(cmd, tp->link_config.active_speed);\r\ncmd->duplex = tp->link_config.active_duplex;\r\ncmd->lp_advertising = tp->link_config.rmt_adv;\r\nif (!(tp->phy_flags & TG3_PHYFLG_ANY_SERDES)) {\r\nif (tp->phy_flags & TG3_PHYFLG_MDIX_STATE)\r\ncmd->eth_tp_mdix = ETH_TP_MDI_X;\r\nelse\r\ncmd->eth_tp_mdix = ETH_TP_MDI;\r\n}\r\n} else {\r\nethtool_cmd_speed_set(cmd, SPEED_UNKNOWN);\r\ncmd->duplex = DUPLEX_UNKNOWN;\r\ncmd->eth_tp_mdix = ETH_TP_MDI_INVALID;\r\n}\r\ncmd->phy_address = tp->phy_addr;\r\ncmd->transceiver = XCVR_INTERNAL;\r\ncmd->autoneg = tp->link_config.autoneg;\r\ncmd->maxtxpkt = 0;\r\ncmd->maxrxpkt = 0;\r\nreturn 0;\r\n}\r\nstatic int tg3_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nu32 speed = ethtool_cmd_speed(cmd);\r\nif (tg3_flag(tp, USE_PHYLIB)) {\r\nstruct phy_device *phydev;\r\nif (!(tp->phy_flags & TG3_PHYFLG_IS_CONNECTED))\r\nreturn -EAGAIN;\r\nphydev = tp->mdio_bus->phy_map[tp->phy_addr];\r\nreturn phy_ethtool_sset(phydev, cmd);\r\n}\r\nif (cmd->autoneg != AUTONEG_ENABLE &&\r\ncmd->autoneg != AUTONEG_DISABLE)\r\nreturn -EINVAL;\r\nif (cmd->autoneg == AUTONEG_DISABLE &&\r\ncmd->duplex != DUPLEX_FULL &&\r\ncmd->duplex != DUPLEX_HALF)\r\nreturn -EINVAL;\r\nif (cmd->autoneg == AUTONEG_ENABLE) {\r\nu32 mask = ADVERTISED_Autoneg |\r\nADVERTISED_Pause |\r\nADVERTISED_Asym_Pause;\r\nif (!(tp->phy_flags & TG3_PHYFLG_10_100_ONLY))\r\nmask |= ADVERTISED_1000baseT_Half |\r\nADVERTISED_1000baseT_Full;\r\nif (!(tp->phy_flags & TG3_PHYFLG_ANY_SERDES))\r\nmask |= ADVERTISED_100baseT_Half |\r\nADVERTISED_100baseT_Full |\r\nADVERTISED_10baseT_Half |\r\nADVERTISED_10baseT_Full |\r\nADVERTISED_TP;\r\nelse\r\nmask |= ADVERTISED_FIBRE;\r\nif (cmd->advertising & ~mask)\r\nreturn -EINVAL;\r\nmask &= (ADVERTISED_1000baseT_Half |\r\nADVERTISED_1000baseT_Full |\r\nADVERTISED_100baseT_Half |\r\nADVERTISED_100baseT_Full |\r\nADVERTISED_10baseT_Half |\r\nADVERTISED_10baseT_Full);\r\ncmd->advertising &= mask;\r\n} else {\r\nif (tp->phy_flags & TG3_PHYFLG_ANY_SERDES) {\r\nif (speed != SPEED_1000)\r\nreturn -EINVAL;\r\nif (cmd->duplex != DUPLEX_FULL)\r\nreturn -EINVAL;\r\n} else {\r\nif (speed != SPEED_100 &&\r\nspeed != SPEED_10)\r\nreturn -EINVAL;\r\n}\r\n}\r\ntg3_full_lock(tp, 0);\r\ntp->link_config.autoneg = cmd->autoneg;\r\nif (cmd->autoneg == AUTONEG_ENABLE) {\r\ntp->link_config.advertising = (cmd->advertising |\r\nADVERTISED_Autoneg);\r\ntp->link_config.speed = SPEED_UNKNOWN;\r\ntp->link_config.duplex = DUPLEX_UNKNOWN;\r\n} else {\r\ntp->link_config.advertising = 0;\r\ntp->link_config.speed = speed;\r\ntp->link_config.duplex = cmd->duplex;\r\n}\r\ntp->phy_flags |= TG3_PHYFLG_USER_CONFIGURED;\r\ntg3_warn_mgmt_link_flap(tp);\r\nif (netif_running(dev))\r\ntg3_setup_phy(tp, true);\r\ntg3_full_unlock(tp);\r\nreturn 0;\r\n}\r\nstatic void tg3_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nstrlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));\r\nstrlcpy(info->fw_version, tp->fw_ver, sizeof(info->fw_version));\r\nstrlcpy(info->bus_info, pci_name(tp->pdev), sizeof(info->bus_info));\r\n}\r\nstatic void tg3_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nif (tg3_flag(tp, WOL_CAP) && device_can_wakeup(&tp->pdev->dev))\r\nwol->supported = WAKE_MAGIC;\r\nelse\r\nwol->supported = 0;\r\nwol->wolopts = 0;\r\nif (tg3_flag(tp, WOL_ENABLE) && device_can_wakeup(&tp->pdev->dev))\r\nwol->wolopts = WAKE_MAGIC;\r\nmemset(&wol->sopass, 0, sizeof(wol->sopass));\r\n}\r\nstatic int tg3_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nstruct device *dp = &tp->pdev->dev;\r\nif (wol->wolopts & ~WAKE_MAGIC)\r\nreturn -EINVAL;\r\nif ((wol->wolopts & WAKE_MAGIC) &&\r\n!(tg3_flag(tp, WOL_CAP) && device_can_wakeup(dp)))\r\nreturn -EINVAL;\r\ndevice_set_wakeup_enable(dp, wol->wolopts & WAKE_MAGIC);\r\nif (device_may_wakeup(dp))\r\ntg3_flag_set(tp, WOL_ENABLE);\r\nelse\r\ntg3_flag_clear(tp, WOL_ENABLE);\r\nreturn 0;\r\n}\r\nstatic u32 tg3_get_msglevel(struct net_device *dev)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nreturn tp->msg_enable;\r\n}\r\nstatic void tg3_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\ntp->msg_enable = value;\r\n}\r\nstatic int tg3_nway_reset(struct net_device *dev)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nint r;\r\nif (!netif_running(dev))\r\nreturn -EAGAIN;\r\nif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES)\r\nreturn -EINVAL;\r\ntg3_warn_mgmt_link_flap(tp);\r\nif (tg3_flag(tp, USE_PHYLIB)) {\r\nif (!(tp->phy_flags & TG3_PHYFLG_IS_CONNECTED))\r\nreturn -EAGAIN;\r\nr = phy_start_aneg(tp->mdio_bus->phy_map[tp->phy_addr]);\r\n} else {\r\nu32 bmcr;\r\nspin_lock_bh(&tp->lock);\r\nr = -EINVAL;\r\ntg3_readphy(tp, MII_BMCR, &bmcr);\r\nif (!tg3_readphy(tp, MII_BMCR, &bmcr) &&\r\n((bmcr & BMCR_ANENABLE) ||\r\n(tp->phy_flags & TG3_PHYFLG_PARALLEL_DETECT))) {\r\ntg3_writephy(tp, MII_BMCR, bmcr | BMCR_ANRESTART |\r\nBMCR_ANENABLE);\r\nr = 0;\r\n}\r\nspin_unlock_bh(&tp->lock);\r\n}\r\nreturn r;\r\n}\r\nstatic void tg3_get_ringparam(struct net_device *dev, struct ethtool_ringparam *ering)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nering->rx_max_pending = tp->rx_std_ring_mask;\r\nif (tg3_flag(tp, JUMBO_RING_ENABLE))\r\nering->rx_jumbo_max_pending = tp->rx_jmb_ring_mask;\r\nelse\r\nering->rx_jumbo_max_pending = 0;\r\nering->tx_max_pending = TG3_TX_RING_SIZE - 1;\r\nering->rx_pending = tp->rx_pending;\r\nif (tg3_flag(tp, JUMBO_RING_ENABLE))\r\nering->rx_jumbo_pending = tp->rx_jumbo_pending;\r\nelse\r\nering->rx_jumbo_pending = 0;\r\nering->tx_pending = tp->napi[0].tx_pending;\r\n}\r\nstatic int tg3_set_ringparam(struct net_device *dev, struct ethtool_ringparam *ering)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nint i, irq_sync = 0, err = 0;\r\nif ((ering->rx_pending > tp->rx_std_ring_mask) ||\r\n(ering->rx_jumbo_pending > tp->rx_jmb_ring_mask) ||\r\n(ering->tx_pending > TG3_TX_RING_SIZE - 1) ||\r\n(ering->tx_pending <= MAX_SKB_FRAGS) ||\r\n(tg3_flag(tp, TSO_BUG) &&\r\n(ering->tx_pending <= (MAX_SKB_FRAGS * 3))))\r\nreturn -EINVAL;\r\nif (netif_running(dev)) {\r\ntg3_phy_stop(tp);\r\ntg3_netif_stop(tp);\r\nirq_sync = 1;\r\n}\r\ntg3_full_lock(tp, irq_sync);\r\ntp->rx_pending = ering->rx_pending;\r\nif (tg3_flag(tp, MAX_RXPEND_64) &&\r\ntp->rx_pending > 63)\r\ntp->rx_pending = 63;\r\nif (tg3_flag(tp, JUMBO_RING_ENABLE))\r\ntp->rx_jumbo_pending = ering->rx_jumbo_pending;\r\nfor (i = 0; i < tp->irq_max; i++)\r\ntp->napi[i].tx_pending = ering->tx_pending;\r\nif (netif_running(dev)) {\r\ntg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\r\nerr = tg3_restart_hw(tp, false);\r\nif (!err)\r\ntg3_netif_start(tp);\r\n}\r\ntg3_full_unlock(tp);\r\nif (irq_sync && !err)\r\ntg3_phy_start(tp);\r\nreturn err;\r\n}\r\nstatic void tg3_get_pauseparam(struct net_device *dev, struct ethtool_pauseparam *epause)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nepause->autoneg = !!tg3_flag(tp, PAUSE_AUTONEG);\r\nif (tp->link_config.flowctrl & FLOW_CTRL_RX)\r\nepause->rx_pause = 1;\r\nelse\r\nepause->rx_pause = 0;\r\nif (tp->link_config.flowctrl & FLOW_CTRL_TX)\r\nepause->tx_pause = 1;\r\nelse\r\nepause->tx_pause = 0;\r\n}\r\nstatic int tg3_set_pauseparam(struct net_device *dev, struct ethtool_pauseparam *epause)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nint err = 0;\r\nif (tp->link_config.autoneg == AUTONEG_ENABLE)\r\ntg3_warn_mgmt_link_flap(tp);\r\nif (tg3_flag(tp, USE_PHYLIB)) {\r\nu32 newadv;\r\nstruct phy_device *phydev;\r\nphydev = tp->mdio_bus->phy_map[tp->phy_addr];\r\nif (!(phydev->supported & SUPPORTED_Pause) ||\r\n(!(phydev->supported & SUPPORTED_Asym_Pause) &&\r\n(epause->rx_pause != epause->tx_pause)))\r\nreturn -EINVAL;\r\ntp->link_config.flowctrl = 0;\r\nif (epause->rx_pause) {\r\ntp->link_config.flowctrl |= FLOW_CTRL_RX;\r\nif (epause->tx_pause) {\r\ntp->link_config.flowctrl |= FLOW_CTRL_TX;\r\nnewadv = ADVERTISED_Pause;\r\n} else\r\nnewadv = ADVERTISED_Pause |\r\nADVERTISED_Asym_Pause;\r\n} else if (epause->tx_pause) {\r\ntp->link_config.flowctrl |= FLOW_CTRL_TX;\r\nnewadv = ADVERTISED_Asym_Pause;\r\n} else\r\nnewadv = 0;\r\nif (epause->autoneg)\r\ntg3_flag_set(tp, PAUSE_AUTONEG);\r\nelse\r\ntg3_flag_clear(tp, PAUSE_AUTONEG);\r\nif (tp->phy_flags & TG3_PHYFLG_IS_CONNECTED) {\r\nu32 oldadv = phydev->advertising &\r\n(ADVERTISED_Pause | ADVERTISED_Asym_Pause);\r\nif (oldadv != newadv) {\r\nphydev->advertising &=\r\n~(ADVERTISED_Pause |\r\nADVERTISED_Asym_Pause);\r\nphydev->advertising |= newadv;\r\nif (phydev->autoneg) {\r\nreturn phy_start_aneg(phydev);\r\n}\r\n}\r\nif (!epause->autoneg)\r\ntg3_setup_flow_control(tp, 0, 0);\r\n} else {\r\ntp->link_config.advertising &=\r\n~(ADVERTISED_Pause |\r\nADVERTISED_Asym_Pause);\r\ntp->link_config.advertising |= newadv;\r\n}\r\n} else {\r\nint irq_sync = 0;\r\nif (netif_running(dev)) {\r\ntg3_netif_stop(tp);\r\nirq_sync = 1;\r\n}\r\ntg3_full_lock(tp, irq_sync);\r\nif (epause->autoneg)\r\ntg3_flag_set(tp, PAUSE_AUTONEG);\r\nelse\r\ntg3_flag_clear(tp, PAUSE_AUTONEG);\r\nif (epause->rx_pause)\r\ntp->link_config.flowctrl |= FLOW_CTRL_RX;\r\nelse\r\ntp->link_config.flowctrl &= ~FLOW_CTRL_RX;\r\nif (epause->tx_pause)\r\ntp->link_config.flowctrl |= FLOW_CTRL_TX;\r\nelse\r\ntp->link_config.flowctrl &= ~FLOW_CTRL_TX;\r\nif (netif_running(dev)) {\r\ntg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\r\nerr = tg3_restart_hw(tp, false);\r\nif (!err)\r\ntg3_netif_start(tp);\r\n}\r\ntg3_full_unlock(tp);\r\n}\r\ntp->phy_flags |= TG3_PHYFLG_USER_CONFIGURED;\r\nreturn err;\r\n}\r\nstatic int tg3_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_TEST:\r\nreturn TG3_NUM_TEST;\r\ncase ETH_SS_STATS:\r\nreturn TG3_NUM_STATS;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int tg3_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,\r\nu32 *rules __always_unused)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nif (!tg3_flag(tp, SUPPORT_MSIX))\r\nreturn -EOPNOTSUPP;\r\nswitch (info->cmd) {\r\ncase ETHTOOL_GRXRINGS:\r\nif (netif_running(tp->dev))\r\ninfo->data = tp->rxq_cnt;\r\nelse {\r\ninfo->data = num_online_cpus();\r\nif (info->data > TG3_RSS_MAX_NUM_QS)\r\ninfo->data = TG3_RSS_MAX_NUM_QS;\r\n}\r\ninfo->data -= 1;\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic u32 tg3_get_rxfh_indir_size(struct net_device *dev)\r\n{\r\nu32 size = 0;\r\nstruct tg3 *tp = netdev_priv(dev);\r\nif (tg3_flag(tp, SUPPORT_MSIX))\r\nsize = TG3_RSS_INDIR_TBL_SIZE;\r\nreturn size;\r\n}\r\nstatic int tg3_get_rxfh(struct net_device *dev, u32 *indir, u8 *key, u8 *hfunc)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nint i;\r\nif (hfunc)\r\n*hfunc = ETH_RSS_HASH_TOP;\r\nif (!indir)\r\nreturn 0;\r\nfor (i = 0; i < TG3_RSS_INDIR_TBL_SIZE; i++)\r\nindir[i] = tp->rss_ind_tbl[i];\r\nreturn 0;\r\n}\r\nstatic int tg3_set_rxfh(struct net_device *dev, const u32 *indir, const u8 *key,\r\nconst u8 hfunc)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nsize_t i;\r\nif (key ||\r\n(hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP))\r\nreturn -EOPNOTSUPP;\r\nif (!indir)\r\nreturn 0;\r\nfor (i = 0; i < TG3_RSS_INDIR_TBL_SIZE; i++)\r\ntp->rss_ind_tbl[i] = indir[i];\r\nif (!netif_running(dev) || !tg3_flag(tp, ENABLE_RSS))\r\nreturn 0;\r\ntg3_full_lock(tp, 0);\r\ntg3_rss_write_indir_tbl(tp);\r\ntg3_full_unlock(tp);\r\nreturn 0;\r\n}\r\nstatic void tg3_get_channels(struct net_device *dev,\r\nstruct ethtool_channels *channel)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nu32 deflt_qs = netif_get_num_default_rss_queues();\r\nchannel->max_rx = tp->rxq_max;\r\nchannel->max_tx = tp->txq_max;\r\nif (netif_running(dev)) {\r\nchannel->rx_count = tp->rxq_cnt;\r\nchannel->tx_count = tp->txq_cnt;\r\n} else {\r\nif (tp->rxq_req)\r\nchannel->rx_count = tp->rxq_req;\r\nelse\r\nchannel->rx_count = min(deflt_qs, tp->rxq_max);\r\nif (tp->txq_req)\r\nchannel->tx_count = tp->txq_req;\r\nelse\r\nchannel->tx_count = min(deflt_qs, tp->txq_max);\r\n}\r\n}\r\nstatic int tg3_set_channels(struct net_device *dev,\r\nstruct ethtool_channels *channel)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nif (!tg3_flag(tp, SUPPORT_MSIX))\r\nreturn -EOPNOTSUPP;\r\nif (channel->rx_count > tp->rxq_max ||\r\nchannel->tx_count > tp->txq_max)\r\nreturn -EINVAL;\r\ntp->rxq_req = channel->rx_count;\r\ntp->txq_req = channel->tx_count;\r\nif (!netif_running(dev))\r\nreturn 0;\r\ntg3_stop(tp);\r\ntg3_carrier_off(tp);\r\ntg3_start(tp, true, false, false);\r\nreturn 0;\r\n}\r\nstatic void tg3_get_strings(struct net_device *dev, u32 stringset, u8 *buf)\r\n{\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nmemcpy(buf, &ethtool_stats_keys, sizeof(ethtool_stats_keys));\r\nbreak;\r\ncase ETH_SS_TEST:\r\nmemcpy(buf, &ethtool_test_keys, sizeof(ethtool_test_keys));\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\n}\r\nstatic int tg3_set_phys_id(struct net_device *dev,\r\nenum ethtool_phys_id_state state)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nif (!netif_running(tp->dev))\r\nreturn -EAGAIN;\r\nswitch (state) {\r\ncase ETHTOOL_ID_ACTIVE:\r\nreturn 1;\r\ncase ETHTOOL_ID_ON:\r\ntw32(MAC_LED_CTRL, LED_CTRL_LNKLED_OVERRIDE |\r\nLED_CTRL_1000MBPS_ON |\r\nLED_CTRL_100MBPS_ON |\r\nLED_CTRL_10MBPS_ON |\r\nLED_CTRL_TRAFFIC_OVERRIDE |\r\nLED_CTRL_TRAFFIC_BLINK |\r\nLED_CTRL_TRAFFIC_LED);\r\nbreak;\r\ncase ETHTOOL_ID_OFF:\r\ntw32(MAC_LED_CTRL, LED_CTRL_LNKLED_OVERRIDE |\r\nLED_CTRL_TRAFFIC_OVERRIDE);\r\nbreak;\r\ncase ETHTOOL_ID_INACTIVE:\r\ntw32(MAC_LED_CTRL, tp->led_ctrl);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tg3_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *estats, u64 *tmp_stats)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nif (tp->hw_stats)\r\ntg3_get_estats(tp, (struct tg3_ethtool_stats *)tmp_stats);\r\nelse\r\nmemset(tmp_stats, 0, sizeof(struct tg3_ethtool_stats));\r\n}\r\nstatic __be32 *tg3_vpd_readblock(struct tg3 *tp, u32 *vpdlen)\r\n{\r\nint i;\r\n__be32 *buf;\r\nu32 offset = 0, len = 0;\r\nu32 magic, val;\r\nif (tg3_flag(tp, NO_NVRAM) || tg3_nvram_read(tp, 0, &magic))\r\nreturn NULL;\r\nif (magic == TG3_EEPROM_MAGIC) {\r\nfor (offset = TG3_NVM_DIR_START;\r\noffset < TG3_NVM_DIR_END;\r\noffset += TG3_NVM_DIRENT_SIZE) {\r\nif (tg3_nvram_read(tp, offset, &val))\r\nreturn NULL;\r\nif ((val >> TG3_NVM_DIRTYPE_SHIFT) ==\r\nTG3_NVM_DIRTYPE_EXTVPD)\r\nbreak;\r\n}\r\nif (offset != TG3_NVM_DIR_END) {\r\nlen = (val & TG3_NVM_DIRTYPE_LENMSK) * 4;\r\nif (tg3_nvram_read(tp, offset + 4, &offset))\r\nreturn NULL;\r\noffset = tg3_nvram_logical_addr(tp, offset);\r\n}\r\n}\r\nif (!offset || !len) {\r\noffset = TG3_NVM_VPD_OFF;\r\nlen = TG3_NVM_VPD_LEN;\r\n}\r\nbuf = kmalloc(len, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn NULL;\r\nif (magic == TG3_EEPROM_MAGIC) {\r\nfor (i = 0; i < len; i += 4) {\r\nif (tg3_nvram_read_be32(tp, offset + i, &buf[i/4]))\r\ngoto error;\r\n}\r\n} else {\r\nu8 *ptr;\r\nssize_t cnt;\r\nunsigned int pos = 0;\r\nptr = (u8 *)&buf[0];\r\nfor (i = 0; pos < len && i < 3; i++, pos += cnt, ptr += cnt) {\r\ncnt = pci_read_vpd(tp->pdev, pos,\r\nlen - pos, ptr);\r\nif (cnt == -ETIMEDOUT || cnt == -EINTR)\r\ncnt = 0;\r\nelse if (cnt < 0)\r\ngoto error;\r\n}\r\nif (pos != len)\r\ngoto error;\r\n}\r\n*vpdlen = len;\r\nreturn buf;\r\nerror:\r\nkfree(buf);\r\nreturn NULL;\r\n}\r\nstatic int tg3_test_nvram(struct tg3 *tp)\r\n{\r\nu32 csum, magic, len;\r\n__be32 *buf;\r\nint i, j, k, err = 0, size;\r\nif (tg3_flag(tp, NO_NVRAM))\r\nreturn 0;\r\nif (tg3_nvram_read(tp, 0, &magic) != 0)\r\nreturn -EIO;\r\nif (magic == TG3_EEPROM_MAGIC)\r\nsize = NVRAM_TEST_SIZE;\r\nelse if ((magic & TG3_EEPROM_MAGIC_FW_MSK) == TG3_EEPROM_MAGIC_FW) {\r\nif ((magic & TG3_EEPROM_SB_FORMAT_MASK) ==\r\nTG3_EEPROM_SB_FORMAT_1) {\r\nswitch (magic & TG3_EEPROM_SB_REVISION_MASK) {\r\ncase TG3_EEPROM_SB_REVISION_0:\r\nsize = NVRAM_SELFBOOT_FORMAT1_0_SIZE;\r\nbreak;\r\ncase TG3_EEPROM_SB_REVISION_2:\r\nsize = NVRAM_SELFBOOT_FORMAT1_2_SIZE;\r\nbreak;\r\ncase TG3_EEPROM_SB_REVISION_3:\r\nsize = NVRAM_SELFBOOT_FORMAT1_3_SIZE;\r\nbreak;\r\ncase TG3_EEPROM_SB_REVISION_4:\r\nsize = NVRAM_SELFBOOT_FORMAT1_4_SIZE;\r\nbreak;\r\ncase TG3_EEPROM_SB_REVISION_5:\r\nsize = NVRAM_SELFBOOT_FORMAT1_5_SIZE;\r\nbreak;\r\ncase TG3_EEPROM_SB_REVISION_6:\r\nsize = NVRAM_SELFBOOT_FORMAT1_6_SIZE;\r\nbreak;\r\ndefault:\r\nreturn -EIO;\r\n}\r\n} else\r\nreturn 0;\r\n} else if ((magic & TG3_EEPROM_MAGIC_HW_MSK) == TG3_EEPROM_MAGIC_HW)\r\nsize = NVRAM_SELFBOOT_HW_SIZE;\r\nelse\r\nreturn -EIO;\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nerr = -EIO;\r\nfor (i = 0, j = 0; i < size; i += 4, j++) {\r\nerr = tg3_nvram_read_be32(tp, i, &buf[j]);\r\nif (err)\r\nbreak;\r\n}\r\nif (i < size)\r\ngoto out;\r\nmagic = be32_to_cpu(buf[0]);\r\nif ((magic & TG3_EEPROM_MAGIC_FW_MSK) ==\r\nTG3_EEPROM_MAGIC_FW) {\r\nu8 *buf8 = (u8 *) buf, csum8 = 0;\r\nif ((magic & TG3_EEPROM_SB_REVISION_MASK) ==\r\nTG3_EEPROM_SB_REVISION_2) {\r\nfor (i = 0; i < TG3_EEPROM_SB_F1R2_MBA_OFF; i++)\r\ncsum8 += buf8[i];\r\nfor (i = TG3_EEPROM_SB_F1R2_MBA_OFF + 4; i < size; i++)\r\ncsum8 += buf8[i];\r\n} else {\r\nfor (i = 0; i < size; i++)\r\ncsum8 += buf8[i];\r\n}\r\nif (csum8 == 0) {\r\nerr = 0;\r\ngoto out;\r\n}\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nif ((magic & TG3_EEPROM_MAGIC_HW_MSK) ==\r\nTG3_EEPROM_MAGIC_HW) {\r\nu8 data[NVRAM_SELFBOOT_DATA_SIZE];\r\nu8 parity[NVRAM_SELFBOOT_DATA_SIZE];\r\nu8 *buf8 = (u8 *) buf;\r\nfor (i = 0, j = 0, k = 0; i < NVRAM_SELFBOOT_HW_SIZE; i++) {\r\nif ((i == 0) || (i == 8)) {\r\nint l;\r\nu8 msk;\r\nfor (l = 0, msk = 0x80; l < 7; l++, msk >>= 1)\r\nparity[k++] = buf8[i] & msk;\r\ni++;\r\n} else if (i == 16) {\r\nint l;\r\nu8 msk;\r\nfor (l = 0, msk = 0x20; l < 6; l++, msk >>= 1)\r\nparity[k++] = buf8[i] & msk;\r\ni++;\r\nfor (l = 0, msk = 0x80; l < 8; l++, msk >>= 1)\r\nparity[k++] = buf8[i] & msk;\r\ni++;\r\n}\r\ndata[j++] = buf8[i];\r\n}\r\nerr = -EIO;\r\nfor (i = 0; i < NVRAM_SELFBOOT_DATA_SIZE; i++) {\r\nu8 hw8 = hweight8(data[i]);\r\nif ((hw8 & 0x1) && parity[i])\r\ngoto out;\r\nelse if (!(hw8 & 0x1) && !parity[i])\r\ngoto out;\r\n}\r\nerr = 0;\r\ngoto out;\r\n}\r\nerr = -EIO;\r\ncsum = calc_crc((unsigned char *) buf, 0x10);\r\nif (csum != le32_to_cpu(buf[0x10/4]))\r\ngoto out;\r\ncsum = calc_crc((unsigned char *) &buf[0x74/4], 0x88);\r\nif (csum != le32_to_cpu(buf[0xfc/4]))\r\ngoto out;\r\nkfree(buf);\r\nbuf = tg3_vpd_readblock(tp, &len);\r\nif (!buf)\r\nreturn -ENOMEM;\r\ni = pci_vpd_find_tag((u8 *)buf, 0, len, PCI_VPD_LRDT_RO_DATA);\r\nif (i > 0) {\r\nj = pci_vpd_lrdt_size(&((u8 *)buf)[i]);\r\nif (j < 0)\r\ngoto out;\r\nif (i + PCI_VPD_LRDT_TAG_SIZE + j > len)\r\ngoto out;\r\ni += PCI_VPD_LRDT_TAG_SIZE;\r\nj = pci_vpd_find_info_keyword((u8 *)buf, i, j,\r\nPCI_VPD_RO_KEYWORD_CHKSUM);\r\nif (j > 0) {\r\nu8 csum8 = 0;\r\nj += PCI_VPD_INFO_FLD_HDR_SIZE;\r\nfor (i = 0; i <= j; i++)\r\ncsum8 += ((u8 *)buf)[i];\r\nif (csum8)\r\ngoto out;\r\n}\r\n}\r\nerr = 0;\r\nout:\r\nkfree(buf);\r\nreturn err;\r\n}\r\nstatic int tg3_test_link(struct tg3 *tp)\r\n{\r\nint i, max;\r\nif (!netif_running(tp->dev))\r\nreturn -ENODEV;\r\nif (tp->phy_flags & TG3_PHYFLG_ANY_SERDES)\r\nmax = TG3_SERDES_TIMEOUT_SEC;\r\nelse\r\nmax = TG3_COPPER_TIMEOUT_SEC;\r\nfor (i = 0; i < max; i++) {\r\nif (tp->link_up)\r\nreturn 0;\r\nif (msleep_interruptible(1000))\r\nbreak;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int tg3_test_registers(struct tg3 *tp)\r\n{\r\nint i, is_5705, is_5750;\r\nu32 offset, read_mask, write_mask, val, save_val, read_val;\r\nstatic struct {\r\nu16 offset;\r\nu16 flags;\r\n#define TG3_FL_5705 0x1\r\n#define TG3_FL_NOT_5705 0x2\r\n#define TG3_FL_NOT_5788 0x4\r\n#define TG3_FL_NOT_5750 0x8\r\nu32 read_mask;\r\nu32 write_mask;\r\n} reg_tbl[] = {\r\n{ MAC_MODE, TG3_FL_NOT_5705,\r\n0x00000000, 0x00ef6f8c },\r\n{ MAC_MODE, TG3_FL_5705,\r\n0x00000000, 0x01ef6b8c },\r\n{ MAC_STATUS, TG3_FL_NOT_5705,\r\n0x03800107, 0x00000000 },\r\n{ MAC_STATUS, TG3_FL_5705,\r\n0x03800100, 0x00000000 },\r\n{ MAC_ADDR_0_HIGH, 0x0000,\r\n0x00000000, 0x0000ffff },\r\n{ MAC_ADDR_0_LOW, 0x0000,\r\n0x00000000, 0xffffffff },\r\n{ MAC_RX_MTU_SIZE, 0x0000,\r\n0x00000000, 0x0000ffff },\r\n{ MAC_TX_MODE, 0x0000,\r\n0x00000000, 0x00000070 },\r\n{ MAC_TX_LENGTHS, 0x0000,\r\n0x00000000, 0x00003fff },\r\n{ MAC_RX_MODE, TG3_FL_NOT_5705,\r\n0x00000000, 0x000007fc },\r\n{ MAC_RX_MODE, TG3_FL_5705,\r\n0x00000000, 0x000007dc },\r\n{ MAC_HASH_REG_0, 0x0000,\r\n0x00000000, 0xffffffff },\r\n{ MAC_HASH_REG_1, 0x0000,\r\n0x00000000, 0xffffffff },\r\n{ MAC_HASH_REG_2, 0x0000,\r\n0x00000000, 0xffffffff },\r\n{ MAC_HASH_REG_3, 0x0000,\r\n0x00000000, 0xffffffff },\r\n{ RCVDBDI_JUMBO_BD+0, TG3_FL_NOT_5705,\r\n0x00000000, 0xffffffff },\r\n{ RCVDBDI_JUMBO_BD+4, TG3_FL_NOT_5705,\r\n0x00000000, 0xffffffff },\r\n{ RCVDBDI_JUMBO_BD+8, TG3_FL_NOT_5705,\r\n0x00000000, 0x00000003 },\r\n{ RCVDBDI_JUMBO_BD+0xc, TG3_FL_NOT_5705,\r\n0x00000000, 0xffffffff },\r\n{ RCVDBDI_STD_BD+0, 0x0000,\r\n0x00000000, 0xffffffff },\r\n{ RCVDBDI_STD_BD+4, 0x0000,\r\n0x00000000, 0xffffffff },\r\n{ RCVDBDI_STD_BD+8, 0x0000,\r\n0x00000000, 0xffff0002 },\r\n{ RCVDBDI_STD_BD+0xc, 0x0000,\r\n0x00000000, 0xffffffff },\r\n{ RCVBDI_STD_THRESH, TG3_FL_NOT_5705,\r\n0x00000000, 0xffffffff },\r\n{ RCVBDI_STD_THRESH, TG3_FL_5705,\r\n0x00000000, 0x000003ff },\r\n{ RCVBDI_JUMBO_THRESH, TG3_FL_NOT_5705,\r\n0x00000000, 0xffffffff },\r\n{ HOSTCC_MODE, TG3_FL_NOT_5705,\r\n0x00000000, 0x00000004 },\r\n{ HOSTCC_MODE, TG3_FL_5705,\r\n0x00000000, 0x000000f6 },\r\n{ HOSTCC_RXCOL_TICKS, TG3_FL_NOT_5705,\r\n0x00000000, 0xffffffff },\r\n{ HOSTCC_RXCOL_TICKS, TG3_FL_5705,\r\n0x00000000, 0x000003ff },\r\n{ HOSTCC_TXCOL_TICKS, TG3_FL_NOT_5705,\r\n0x00000000, 0xffffffff },\r\n{ HOSTCC_TXCOL_TICKS, TG3_FL_5705,\r\n0x00000000, 0x000003ff },\r\n{ HOSTCC_RXMAX_FRAMES, TG3_FL_NOT_5705,\r\n0x00000000, 0xffffffff },\r\n{ HOSTCC_RXMAX_FRAMES, TG3_FL_5705 | TG3_FL_NOT_5788,\r\n0x00000000, 0x000000ff },\r\n{ HOSTCC_TXMAX_FRAMES, TG3_FL_NOT_5705,\r\n0x00000000, 0xffffffff },\r\n{ HOSTCC_TXMAX_FRAMES, TG3_FL_5705 | TG3_FL_NOT_5788,\r\n0x00000000, 0x000000ff },\r\n{ HOSTCC_RXCOAL_TICK_INT, TG3_FL_NOT_5705,\r\n0x00000000, 0xffffffff },\r\n{ HOSTCC_TXCOAL_TICK_INT, TG3_FL_NOT_5705,\r\n0x00000000, 0xffffffff },\r\n{ HOSTCC_RXCOAL_MAXF_INT, TG3_FL_NOT_5705,\r\n0x00000000, 0xffffffff },\r\n{ HOSTCC_RXCOAL_MAXF_INT, TG3_FL_5705 | TG3_FL_NOT_5788,\r\n0x00000000, 0x000000ff },\r\n{ HOSTCC_TXCOAL_MAXF_INT, TG3_FL_NOT_5705,\r\n0x00000000, 0xffffffff },\r\n{ HOSTCC_TXCOAL_MAXF_INT, TG3_FL_5705 | TG3_FL_NOT_5788,\r\n0x00000000, 0x000000ff },\r\n{ HOSTCC_STAT_COAL_TICKS, TG3_FL_NOT_5705,\r\n0x00000000, 0xffffffff },\r\n{ HOSTCC_STATS_BLK_HOST_ADDR, TG3_FL_NOT_5705,\r\n0x00000000, 0xffffffff },\r\n{ HOSTCC_STATS_BLK_HOST_ADDR+4, TG3_FL_NOT_5705,\r\n0x00000000, 0xffffffff },\r\n{ HOSTCC_STATUS_BLK_HOST_ADDR, 0x0000,\r\n0x00000000, 0xffffffff },\r\n{ HOSTCC_STATUS_BLK_HOST_ADDR+4, 0x0000,\r\n0x00000000, 0xffffffff },\r\n{ HOSTCC_STATS_BLK_NIC_ADDR, 0x0000,\r\n0xffffffff, 0x00000000 },\r\n{ HOSTCC_STATUS_BLK_NIC_ADDR, 0x0000,\r\n0xffffffff, 0x00000000 },\r\n{ BUFMGR_MB_POOL_ADDR, TG3_FL_NOT_5750,\r\n0x00000000, 0x007fff80 },\r\n{ BUFMGR_MB_POOL_SIZE, TG3_FL_NOT_5750,\r\n0x00000000, 0x007fffff },\r\n{ BUFMGR_MB_RDMA_LOW_WATER, 0x0000,\r\n0x00000000, 0x0000003f },\r\n{ BUFMGR_MB_MACRX_LOW_WATER, 0x0000,\r\n0x00000000, 0x000001ff },\r\n{ BUFMGR_MB_HIGH_WATER, 0x0000,\r\n0x00000000, 0x000001ff },\r\n{ BUFMGR_DMA_DESC_POOL_ADDR, TG3_FL_NOT_5705,\r\n0xffffffff, 0x00000000 },\r\n{ BUFMGR_DMA_DESC_POOL_SIZE, TG3_FL_NOT_5705,\r\n0xffffffff, 0x00000000 },\r\n{ GRCMBOX_RCVSTD_PROD_IDX+4, 0x0000,\r\n0x00000000, 0x000001ff },\r\n{ GRCMBOX_RCVJUMBO_PROD_IDX+4, TG3_FL_NOT_5705,\r\n0x00000000, 0x000001ff },\r\n{ GRCMBOX_RCVRET_CON_IDX_0+4, 0x0000,\r\n0x00000000, 0x000007ff },\r\n{ GRCMBOX_SNDHOST_PROD_IDX_0+4, 0x0000,\r\n0x00000000, 0x000001ff },\r\n{ 0xffff, 0x0000, 0x00000000, 0x00000000 },\r\n};\r\nis_5705 = is_5750 = 0;\r\nif (tg3_flag(tp, 5705_PLUS)) {\r\nis_5705 = 1;\r\nif (tg3_flag(tp, 5750_PLUS))\r\nis_5750 = 1;\r\n}\r\nfor (i = 0; reg_tbl[i].offset != 0xffff; i++) {\r\nif (is_5705 && (reg_tbl[i].flags & TG3_FL_NOT_5705))\r\ncontinue;\r\nif (!is_5705 && (reg_tbl[i].flags & TG3_FL_5705))\r\ncontinue;\r\nif (tg3_flag(tp, IS_5788) &&\r\n(reg_tbl[i].flags & TG3_FL_NOT_5788))\r\ncontinue;\r\nif (is_5750 && (reg_tbl[i].flags & TG3_FL_NOT_5750))\r\ncontinue;\r\noffset = (u32) reg_tbl[i].offset;\r\nread_mask = reg_tbl[i].read_mask;\r\nwrite_mask = reg_tbl[i].write_mask;\r\nsave_val = tr32(offset);\r\nread_val = save_val & read_mask;\r\ntw32(offset, 0);\r\nval = tr32(offset);\r\nif (((val & read_mask) != read_val) || (val & write_mask))\r\ngoto out;\r\ntw32(offset, read_mask | write_mask);\r\nval = tr32(offset);\r\nif ((val & read_mask) != read_val)\r\ngoto out;\r\nif ((val & write_mask) != write_mask)\r\ngoto out;\r\ntw32(offset, save_val);\r\n}\r\nreturn 0;\r\nout:\r\nif (netif_msg_hw(tp))\r\nnetdev_err(tp->dev,\r\n"Register test failed at offset %x\n", offset);\r\ntw32(offset, save_val);\r\nreturn -EIO;\r\n}\r\nstatic int tg3_do_mem_test(struct tg3 *tp, u32 offset, u32 len)\r\n{\r\nstatic const u32 test_pattern[] = { 0x00000000, 0xffffffff, 0xaa55a55a };\r\nint i;\r\nu32 j;\r\nfor (i = 0; i < ARRAY_SIZE(test_pattern); i++) {\r\nfor (j = 0; j < len; j += 4) {\r\nu32 val;\r\ntg3_write_mem(tp, offset + j, test_pattern[i]);\r\ntg3_read_mem(tp, offset + j, &val);\r\nif (val != test_pattern[i])\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tg3_test_memory(struct tg3 *tp)\r\n{\r\nstatic struct mem_entry {\r\nu32 offset;\r\nu32 len;\r\n} mem_tbl_570x[] = {\r\n{ 0x00000000, 0x00b50},\r\n{ 0x00002000, 0x1c000},\r\n{ 0xffffffff, 0x00000}\r\n}, mem_tbl_5705[] = {\r\n{ 0x00000100, 0x0000c},\r\n{ 0x00000200, 0x00008},\r\n{ 0x00004000, 0x00800},\r\n{ 0x00006000, 0x01000},\r\n{ 0x00008000, 0x02000},\r\n{ 0x00010000, 0x0e000},\r\n{ 0xffffffff, 0x00000}\r\n}, mem_tbl_5755[] = {\r\n{ 0x00000200, 0x00008},\r\n{ 0x00004000, 0x00800},\r\n{ 0x00006000, 0x00800},\r\n{ 0x00008000, 0x02000},\r\n{ 0x00010000, 0x0c000},\r\n{ 0xffffffff, 0x00000}\r\n}, mem_tbl_5906[] = {\r\n{ 0x00000200, 0x00008},\r\n{ 0x00004000, 0x00400},\r\n{ 0x00006000, 0x00400},\r\n{ 0x00008000, 0x01000},\r\n{ 0x00010000, 0x01000},\r\n{ 0xffffffff, 0x00000}\r\n}, mem_tbl_5717[] = {\r\n{ 0x00000200, 0x00008},\r\n{ 0x00010000, 0x0a000},\r\n{ 0x00020000, 0x13c00},\r\n{ 0xffffffff, 0x00000}\r\n}, mem_tbl_57765[] = {\r\n{ 0x00000200, 0x00008},\r\n{ 0x00004000, 0x00800},\r\n{ 0x00006000, 0x09800},\r\n{ 0x00010000, 0x0a000},\r\n{ 0xffffffff, 0x00000}\r\n};\r\nstruct mem_entry *mem_tbl;\r\nint err = 0;\r\nint i;\r\nif (tg3_flag(tp, 5717_PLUS))\r\nmem_tbl = mem_tbl_5717;\r\nelse if (tg3_flag(tp, 57765_CLASS) ||\r\ntg3_asic_rev(tp) == ASIC_REV_5762)\r\nmem_tbl = mem_tbl_57765;\r\nelse if (tg3_flag(tp, 5755_PLUS))\r\nmem_tbl = mem_tbl_5755;\r\nelse if (tg3_asic_rev(tp) == ASIC_REV_5906)\r\nmem_tbl = mem_tbl_5906;\r\nelse if (tg3_flag(tp, 5705_PLUS))\r\nmem_tbl = mem_tbl_5705;\r\nelse\r\nmem_tbl = mem_tbl_570x;\r\nfor (i = 0; mem_tbl[i].offset != 0xffffffff; i++) {\r\nerr = tg3_do_mem_test(tp, mem_tbl[i].offset, mem_tbl[i].len);\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int tg3_run_loopback(struct tg3 *tp, u32 pktsz, bool tso_loopback)\r\n{\r\nu32 rx_start_idx, rx_idx, tx_idx, opaque_key;\r\nu32 base_flags = 0, mss = 0, desc_idx, coal_now, data_off, val;\r\nu32 budget;\r\nstruct sk_buff *skb;\r\nu8 *tx_data, *rx_data;\r\ndma_addr_t map;\r\nint num_pkts, tx_len, rx_len, i, err;\r\nstruct tg3_rx_buffer_desc *desc;\r\nstruct tg3_napi *tnapi, *rnapi;\r\nstruct tg3_rx_prodring_set *tpr = &tp->napi[0].prodring;\r\ntnapi = &tp->napi[0];\r\nrnapi = &tp->napi[0];\r\nif (tp->irq_cnt > 1) {\r\nif (tg3_flag(tp, ENABLE_RSS))\r\nrnapi = &tp->napi[1];\r\nif (tg3_flag(tp, ENABLE_TSS))\r\ntnapi = &tp->napi[1];\r\n}\r\ncoal_now = tnapi->coal_now | rnapi->coal_now;\r\nerr = -EIO;\r\ntx_len = pktsz;\r\nskb = netdev_alloc_skb(tp->dev, tx_len);\r\nif (!skb)\r\nreturn -ENOMEM;\r\ntx_data = skb_put(skb, tx_len);\r\nmemcpy(tx_data, tp->dev->dev_addr, ETH_ALEN);\r\nmemset(tx_data + ETH_ALEN, 0x0, 8);\r\ntw32(MAC_RX_MTU_SIZE, tx_len + ETH_FCS_LEN);\r\nif (tso_loopback) {\r\nstruct iphdr *iph = (struct iphdr *)&tx_data[ETH_HLEN];\r\nu32 hdr_len = TG3_TSO_IP_HDR_LEN + TG3_TSO_TCP_HDR_LEN +\r\nTG3_TSO_TCP_OPT_LEN;\r\nmemcpy(tx_data + ETH_ALEN * 2, tg3_tso_header,\r\nsizeof(tg3_tso_header));\r\nmss = TG3_TSO_MSS;\r\nval = tx_len - ETH_ALEN * 2 - sizeof(tg3_tso_header);\r\nnum_pkts = DIV_ROUND_UP(val, TG3_TSO_MSS);\r\niph->tot_len = htons((u16)(mss + hdr_len));\r\nbase_flags = (TXD_FLAG_CPU_PRE_DMA |\r\nTXD_FLAG_CPU_POST_DMA);\r\nif (tg3_flag(tp, HW_TSO_1) ||\r\ntg3_flag(tp, HW_TSO_2) ||\r\ntg3_flag(tp, HW_TSO_3)) {\r\nstruct tcphdr *th;\r\nval = ETH_HLEN + TG3_TSO_IP_HDR_LEN;\r\nth = (struct tcphdr *)&tx_data[val];\r\nth->check = 0;\r\n} else\r\nbase_flags |= TXD_FLAG_TCPUDP_CSUM;\r\nif (tg3_flag(tp, HW_TSO_3)) {\r\nmss |= (hdr_len & 0xc) << 12;\r\nif (hdr_len & 0x10)\r\nbase_flags |= 0x00000010;\r\nbase_flags |= (hdr_len & 0x3e0) << 5;\r\n} else if (tg3_flag(tp, HW_TSO_2))\r\nmss |= hdr_len << 9;\r\nelse if (tg3_flag(tp, HW_TSO_1) ||\r\ntg3_asic_rev(tp) == ASIC_REV_5705) {\r\nmss |= (TG3_TSO_TCP_OPT_LEN << 9);\r\n} else {\r\nbase_flags |= (TG3_TSO_TCP_OPT_LEN << 10);\r\n}\r\ndata_off = ETH_ALEN * 2 + sizeof(tg3_tso_header);\r\n} else {\r\nnum_pkts = 1;\r\ndata_off = ETH_HLEN;\r\nif (tg3_flag(tp, USE_JUMBO_BDFLAG) &&\r\ntx_len > VLAN_ETH_FRAME_LEN)\r\nbase_flags |= TXD_FLAG_JMB_PKT;\r\n}\r\nfor (i = data_off; i < tx_len; i++)\r\ntx_data[i] = (u8) (i & 0xff);\r\nmap = pci_map_single(tp->pdev, skb->data, tx_len, PCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(tp->pdev, map)) {\r\ndev_kfree_skb(skb);\r\nreturn -EIO;\r\n}\r\nval = tnapi->tx_prod;\r\ntnapi->tx_buffers[val].skb = skb;\r\ndma_unmap_addr_set(&tnapi->tx_buffers[val], mapping, map);\r\ntw32_f(HOSTCC_MODE, tp->coalesce_mode | HOSTCC_MODE_ENABLE |\r\nrnapi->coal_now);\r\nudelay(10);\r\nrx_start_idx = rnapi->hw_status->idx[0].rx_producer;\r\nbudget = tg3_tx_avail(tnapi);\r\nif (tg3_tx_frag_set(tnapi, &val, &budget, map, tx_len,\r\nbase_flags | TXD_FLAG_END, mss, 0)) {\r\ntnapi->tx_buffers[val].skb = NULL;\r\ndev_kfree_skb(skb);\r\nreturn -EIO;\r\n}\r\ntnapi->tx_prod++;\r\nwmb();\r\ntw32_tx_mbox(tnapi->prodmbox, tnapi->tx_prod);\r\ntr32_mailbox(tnapi->prodmbox);\r\nudelay(10);\r\nfor (i = 0; i < 35; i++) {\r\ntw32_f(HOSTCC_MODE, tp->coalesce_mode | HOSTCC_MODE_ENABLE |\r\ncoal_now);\r\nudelay(10);\r\ntx_idx = tnapi->hw_status->idx[0].tx_consumer;\r\nrx_idx = rnapi->hw_status->idx[0].rx_producer;\r\nif ((tx_idx == tnapi->tx_prod) &&\r\n(rx_idx == (rx_start_idx + num_pkts)))\r\nbreak;\r\n}\r\ntg3_tx_skb_unmap(tnapi, tnapi->tx_prod - 1, -1);\r\ndev_kfree_skb(skb);\r\nif (tx_idx != tnapi->tx_prod)\r\ngoto out;\r\nif (rx_idx != rx_start_idx + num_pkts)\r\ngoto out;\r\nval = data_off;\r\nwhile (rx_idx != rx_start_idx) {\r\ndesc = &rnapi->rx_rcb[rx_start_idx++];\r\ndesc_idx = desc->opaque & RXD_OPAQUE_INDEX_MASK;\r\nopaque_key = desc->opaque & RXD_OPAQUE_RING_MASK;\r\nif ((desc->err_vlan & RXD_ERR_MASK) != 0 &&\r\n(desc->err_vlan != RXD_ERR_ODD_NIBBLE_RCVD_MII))\r\ngoto out;\r\nrx_len = ((desc->idx_len & RXD_LEN_MASK) >> RXD_LEN_SHIFT)\r\n- ETH_FCS_LEN;\r\nif (!tso_loopback) {\r\nif (rx_len != tx_len)\r\ngoto out;\r\nif (pktsz <= TG3_RX_STD_DMA_SZ - ETH_FCS_LEN) {\r\nif (opaque_key != RXD_OPAQUE_RING_STD)\r\ngoto out;\r\n} else {\r\nif (opaque_key != RXD_OPAQUE_RING_JUMBO)\r\ngoto out;\r\n}\r\n} else if ((desc->type_flags & RXD_FLAG_TCPUDP_CSUM) &&\r\n(desc->ip_tcp_csum & RXD_TCPCSUM_MASK)\r\n>> RXD_TCPCSUM_SHIFT != 0xffff) {\r\ngoto out;\r\n}\r\nif (opaque_key == RXD_OPAQUE_RING_STD) {\r\nrx_data = tpr->rx_std_buffers[desc_idx].data;\r\nmap = dma_unmap_addr(&tpr->rx_std_buffers[desc_idx],\r\nmapping);\r\n} else if (opaque_key == RXD_OPAQUE_RING_JUMBO) {\r\nrx_data = tpr->rx_jmb_buffers[desc_idx].data;\r\nmap = dma_unmap_addr(&tpr->rx_jmb_buffers[desc_idx],\r\nmapping);\r\n} else\r\ngoto out;\r\npci_dma_sync_single_for_cpu(tp->pdev, map, rx_len,\r\nPCI_DMA_FROMDEVICE);\r\nrx_data += TG3_RX_OFFSET(tp);\r\nfor (i = data_off; i < rx_len; i++, val++) {\r\nif (*(rx_data + i) != (u8) (val & 0xff))\r\ngoto out;\r\n}\r\n}\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int tg3_test_loopback(struct tg3 *tp, u64 *data, bool do_extlpbk)\r\n{\r\nint err = -EIO;\r\nu32 eee_cap;\r\nu32 jmb_pkt_sz = 9000;\r\nif (tp->dma_limit)\r\njmb_pkt_sz = tp->dma_limit - ETH_HLEN;\r\neee_cap = tp->phy_flags & TG3_PHYFLG_EEE_CAP;\r\ntp->phy_flags &= ~TG3_PHYFLG_EEE_CAP;\r\nif (!netif_running(tp->dev)) {\r\ndata[TG3_MAC_LOOPB_TEST] = TG3_LOOPBACK_FAILED;\r\ndata[TG3_PHY_LOOPB_TEST] = TG3_LOOPBACK_FAILED;\r\nif (do_extlpbk)\r\ndata[TG3_EXT_LOOPB_TEST] = TG3_LOOPBACK_FAILED;\r\ngoto done;\r\n}\r\nerr = tg3_reset_hw(tp, true);\r\nif (err) {\r\ndata[TG3_MAC_LOOPB_TEST] = TG3_LOOPBACK_FAILED;\r\ndata[TG3_PHY_LOOPB_TEST] = TG3_LOOPBACK_FAILED;\r\nif (do_extlpbk)\r\ndata[TG3_EXT_LOOPB_TEST] = TG3_LOOPBACK_FAILED;\r\ngoto done;\r\n}\r\nif (tg3_flag(tp, ENABLE_RSS)) {\r\nint i;\r\nfor (i = MAC_RSS_INDIR_TBL_0;\r\ni < MAC_RSS_INDIR_TBL_0 + TG3_RSS_INDIR_TBL_SIZE; i += 4)\r\ntw32(i, 0x0);\r\n}\r\nif (tg3_asic_rev(tp) != ASIC_REV_5780 &&\r\n!tg3_flag(tp, CPMU_PRESENT)) {\r\ntg3_mac_loopback(tp, true);\r\nif (tg3_run_loopback(tp, ETH_FRAME_LEN, false))\r\ndata[TG3_MAC_LOOPB_TEST] |= TG3_STD_LOOPBACK_FAILED;\r\nif (tg3_flag(tp, JUMBO_RING_ENABLE) &&\r\ntg3_run_loopback(tp, jmb_pkt_sz + ETH_HLEN, false))\r\ndata[TG3_MAC_LOOPB_TEST] |= TG3_JMB_LOOPBACK_FAILED;\r\ntg3_mac_loopback(tp, false);\r\n}\r\nif (!(tp->phy_flags & TG3_PHYFLG_PHY_SERDES) &&\r\n!tg3_flag(tp, USE_PHYLIB)) {\r\nint i;\r\ntg3_phy_lpbk_set(tp, 0, false);\r\nfor (i = 0; i < 100; i++) {\r\nif (tr32(MAC_TX_STATUS) & TX_STATUS_LINK_UP)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif (tg3_run_loopback(tp, ETH_FRAME_LEN, false))\r\ndata[TG3_PHY_LOOPB_TEST] |= TG3_STD_LOOPBACK_FAILED;\r\nif (tg3_flag(tp, TSO_CAPABLE) &&\r\ntg3_run_loopback(tp, ETH_FRAME_LEN, true))\r\ndata[TG3_PHY_LOOPB_TEST] |= TG3_TSO_LOOPBACK_FAILED;\r\nif (tg3_flag(tp, JUMBO_RING_ENABLE) &&\r\ntg3_run_loopback(tp, jmb_pkt_sz + ETH_HLEN, false))\r\ndata[TG3_PHY_LOOPB_TEST] |= TG3_JMB_LOOPBACK_FAILED;\r\nif (do_extlpbk) {\r\ntg3_phy_lpbk_set(tp, 0, true);\r\nmdelay(40);\r\nif (tg3_run_loopback(tp, ETH_FRAME_LEN, false))\r\ndata[TG3_EXT_LOOPB_TEST] |=\r\nTG3_STD_LOOPBACK_FAILED;\r\nif (tg3_flag(tp, TSO_CAPABLE) &&\r\ntg3_run_loopback(tp, ETH_FRAME_LEN, true))\r\ndata[TG3_EXT_LOOPB_TEST] |=\r\nTG3_TSO_LOOPBACK_FAILED;\r\nif (tg3_flag(tp, JUMBO_RING_ENABLE) &&\r\ntg3_run_loopback(tp, jmb_pkt_sz + ETH_HLEN, false))\r\ndata[TG3_EXT_LOOPB_TEST] |=\r\nTG3_JMB_LOOPBACK_FAILED;\r\n}\r\nif (tp->phy_flags & TG3_PHYFLG_ENABLE_APD)\r\ntg3_phy_toggle_apd(tp, true);\r\n}\r\nerr = (data[TG3_MAC_LOOPB_TEST] | data[TG3_PHY_LOOPB_TEST] |\r\ndata[TG3_EXT_LOOPB_TEST]) ? -EIO : 0;\r\ndone:\r\ntp->phy_flags |= eee_cap;\r\nreturn err;\r\n}\r\nstatic void tg3_self_test(struct net_device *dev, struct ethtool_test *etest,\r\nu64 *data)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nbool doextlpbk = etest->flags & ETH_TEST_FL_EXTERNAL_LB;\r\nif (tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER) {\r\nif (tg3_power_up(tp)) {\r\netest->flags |= ETH_TEST_FL_FAILED;\r\nmemset(data, 1, sizeof(u64) * TG3_NUM_TEST);\r\nreturn;\r\n}\r\ntg3_ape_driver_state_change(tp, RESET_KIND_INIT);\r\n}\r\nmemset(data, 0, sizeof(u64) * TG3_NUM_TEST);\r\nif (tg3_test_nvram(tp) != 0) {\r\netest->flags |= ETH_TEST_FL_FAILED;\r\ndata[TG3_NVRAM_TEST] = 1;\r\n}\r\nif (!doextlpbk && tg3_test_link(tp)) {\r\netest->flags |= ETH_TEST_FL_FAILED;\r\ndata[TG3_LINK_TEST] = 1;\r\n}\r\nif (etest->flags & ETH_TEST_FL_OFFLINE) {\r\nint err, err2 = 0, irq_sync = 0;\r\nif (netif_running(dev)) {\r\ntg3_phy_stop(tp);\r\ntg3_netif_stop(tp);\r\nirq_sync = 1;\r\n}\r\ntg3_full_lock(tp, irq_sync);\r\ntg3_halt(tp, RESET_KIND_SUSPEND, 1);\r\nerr = tg3_nvram_lock(tp);\r\ntg3_halt_cpu(tp, RX_CPU_BASE);\r\nif (!tg3_flag(tp, 5705_PLUS))\r\ntg3_halt_cpu(tp, TX_CPU_BASE);\r\nif (!err)\r\ntg3_nvram_unlock(tp);\r\nif (tp->phy_flags & TG3_PHYFLG_MII_SERDES)\r\ntg3_phy_reset(tp);\r\nif (tg3_test_registers(tp) != 0) {\r\netest->flags |= ETH_TEST_FL_FAILED;\r\ndata[TG3_REGISTER_TEST] = 1;\r\n}\r\nif (tg3_test_memory(tp) != 0) {\r\netest->flags |= ETH_TEST_FL_FAILED;\r\ndata[TG3_MEMORY_TEST] = 1;\r\n}\r\nif (doextlpbk)\r\netest->flags |= ETH_TEST_FL_EXTERNAL_LB_DONE;\r\nif (tg3_test_loopback(tp, data, doextlpbk))\r\netest->flags |= ETH_TEST_FL_FAILED;\r\ntg3_full_unlock(tp);\r\nif (tg3_test_interrupt(tp) != 0) {\r\netest->flags |= ETH_TEST_FL_FAILED;\r\ndata[TG3_INTERRUPT_TEST] = 1;\r\n}\r\ntg3_full_lock(tp, 0);\r\ntg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\r\nif (netif_running(dev)) {\r\ntg3_flag_set(tp, INIT_COMPLETE);\r\nerr2 = tg3_restart_hw(tp, true);\r\nif (!err2)\r\ntg3_netif_start(tp);\r\n}\r\ntg3_full_unlock(tp);\r\nif (irq_sync && !err2)\r\ntg3_phy_start(tp);\r\n}\r\nif (tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER)\r\ntg3_power_down_prepare(tp);\r\n}\r\nstatic int tg3_hwtstamp_set(struct net_device *dev, struct ifreq *ifr)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nstruct hwtstamp_config stmpconf;\r\nif (!tg3_flag(tp, PTP_CAPABLE))\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&stmpconf, ifr->ifr_data, sizeof(stmpconf)))\r\nreturn -EFAULT;\r\nif (stmpconf.flags)\r\nreturn -EINVAL;\r\nif (stmpconf.tx_type != HWTSTAMP_TX_ON &&\r\nstmpconf.tx_type != HWTSTAMP_TX_OFF)\r\nreturn -ERANGE;\r\nswitch (stmpconf.rx_filter) {\r\ncase HWTSTAMP_FILTER_NONE:\r\ntp->rxptpctl = 0;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\r\ntp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V1_EN |\r\nTG3_RX_PTP_CTL_ALL_V1_EVENTS;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\r\ntp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V1_EN |\r\nTG3_RX_PTP_CTL_SYNC_EVNT;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\r\ntp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V1_EN |\r\nTG3_RX_PTP_CTL_DELAY_REQ;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_EVENT:\r\ntp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V2_EN |\r\nTG3_RX_PTP_CTL_ALL_V2_EVENTS;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\r\ntp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V2_L2_EN |\r\nTG3_RX_PTP_CTL_ALL_V2_EVENTS;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\r\ntp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V2_L4_EN |\r\nTG3_RX_PTP_CTL_ALL_V2_EVENTS;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_SYNC:\r\ntp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V2_EN |\r\nTG3_RX_PTP_CTL_SYNC_EVNT;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\r\ntp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V2_L2_EN |\r\nTG3_RX_PTP_CTL_SYNC_EVNT;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\r\ntp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V2_L4_EN |\r\nTG3_RX_PTP_CTL_SYNC_EVNT;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\r\ntp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V2_EN |\r\nTG3_RX_PTP_CTL_DELAY_REQ;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\r\ntp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V2_L2_EN |\r\nTG3_RX_PTP_CTL_DELAY_REQ;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\r\ntp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V2_L4_EN |\r\nTG3_RX_PTP_CTL_DELAY_REQ;\r\nbreak;\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\nif (netif_running(dev) && tp->rxptpctl)\r\ntw32(TG3_RX_PTP_CTL,\r\ntp->rxptpctl | TG3_RX_PTP_CTL_HWTS_INTERLOCK);\r\nif (stmpconf.tx_type == HWTSTAMP_TX_ON)\r\ntg3_flag_set(tp, TX_TSTAMP_EN);\r\nelse\r\ntg3_flag_clear(tp, TX_TSTAMP_EN);\r\nreturn copy_to_user(ifr->ifr_data, &stmpconf, sizeof(stmpconf)) ?\r\n-EFAULT : 0;\r\n}\r\nstatic int tg3_hwtstamp_get(struct net_device *dev, struct ifreq *ifr)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nstruct hwtstamp_config stmpconf;\r\nif (!tg3_flag(tp, PTP_CAPABLE))\r\nreturn -EOPNOTSUPP;\r\nstmpconf.flags = 0;\r\nstmpconf.tx_type = (tg3_flag(tp, TX_TSTAMP_EN) ?\r\nHWTSTAMP_TX_ON : HWTSTAMP_TX_OFF);\r\nswitch (tp->rxptpctl) {\r\ncase 0:\r\nstmpconf.rx_filter = HWTSTAMP_FILTER_NONE;\r\nbreak;\r\ncase TG3_RX_PTP_CTL_RX_PTP_V1_EN | TG3_RX_PTP_CTL_ALL_V1_EVENTS:\r\nstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;\r\nbreak;\r\ncase TG3_RX_PTP_CTL_RX_PTP_V1_EN | TG3_RX_PTP_CTL_SYNC_EVNT:\r\nstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_SYNC;\r\nbreak;\r\ncase TG3_RX_PTP_CTL_RX_PTP_V1_EN | TG3_RX_PTP_CTL_DELAY_REQ:\r\nstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ;\r\nbreak;\r\ncase TG3_RX_PTP_CTL_RX_PTP_V2_EN | TG3_RX_PTP_CTL_ALL_V2_EVENTS:\r\nstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\r\nbreak;\r\ncase TG3_RX_PTP_CTL_RX_PTP_V2_L2_EN | TG3_RX_PTP_CTL_ALL_V2_EVENTS:\r\nstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_EVENT;\r\nbreak;\r\ncase TG3_RX_PTP_CTL_RX_PTP_V2_L4_EN | TG3_RX_PTP_CTL_ALL_V2_EVENTS:\r\nstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_EVENT;\r\nbreak;\r\ncase TG3_RX_PTP_CTL_RX_PTP_V2_EN | TG3_RX_PTP_CTL_SYNC_EVNT:\r\nstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V2_SYNC;\r\nbreak;\r\ncase TG3_RX_PTP_CTL_RX_PTP_V2_L2_EN | TG3_RX_PTP_CTL_SYNC_EVNT:\r\nstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_SYNC;\r\nbreak;\r\ncase TG3_RX_PTP_CTL_RX_PTP_V2_L4_EN | TG3_RX_PTP_CTL_SYNC_EVNT:\r\nstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_SYNC;\r\nbreak;\r\ncase TG3_RX_PTP_CTL_RX_PTP_V2_EN | TG3_RX_PTP_CTL_DELAY_REQ:\r\nstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V2_DELAY_REQ;\r\nbreak;\r\ncase TG3_RX_PTP_CTL_RX_PTP_V2_L2_EN | TG3_RX_PTP_CTL_DELAY_REQ:\r\nstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ;\r\nbreak;\r\ncase TG3_RX_PTP_CTL_RX_PTP_V2_L4_EN | TG3_RX_PTP_CTL_DELAY_REQ:\r\nstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ;\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nreturn -ERANGE;\r\n}\r\nreturn copy_to_user(ifr->ifr_data, &stmpconf, sizeof(stmpconf)) ?\r\n-EFAULT : 0;\r\n}\r\nstatic int tg3_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct mii_ioctl_data *data = if_mii(ifr);\r\nstruct tg3 *tp = netdev_priv(dev);\r\nint err;\r\nif (tg3_flag(tp, USE_PHYLIB)) {\r\nstruct phy_device *phydev;\r\nif (!(tp->phy_flags & TG3_PHYFLG_IS_CONNECTED))\r\nreturn -EAGAIN;\r\nphydev = tp->mdio_bus->phy_map[tp->phy_addr];\r\nreturn phy_mii_ioctl(phydev, ifr, cmd);\r\n}\r\nswitch (cmd) {\r\ncase SIOCGMIIPHY:\r\ndata->phy_id = tp->phy_addr;\r\ncase SIOCGMIIREG: {\r\nu32 mii_regval;\r\nif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES)\r\nbreak;\r\nif (!netif_running(dev))\r\nreturn -EAGAIN;\r\nspin_lock_bh(&tp->lock);\r\nerr = __tg3_readphy(tp, data->phy_id & 0x1f,\r\ndata->reg_num & 0x1f, &mii_regval);\r\nspin_unlock_bh(&tp->lock);\r\ndata->val_out = mii_regval;\r\nreturn err;\r\n}\r\ncase SIOCSMIIREG:\r\nif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES)\r\nbreak;\r\nif (!netif_running(dev))\r\nreturn -EAGAIN;\r\nspin_lock_bh(&tp->lock);\r\nerr = __tg3_writephy(tp, data->phy_id & 0x1f,\r\ndata->reg_num & 0x1f, data->val_in);\r\nspin_unlock_bh(&tp->lock);\r\nreturn err;\r\ncase SIOCSHWTSTAMP:\r\nreturn tg3_hwtstamp_set(dev, ifr);\r\ncase SIOCGHWTSTAMP:\r\nreturn tg3_hwtstamp_get(dev, ifr);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int tg3_get_coalesce(struct net_device *dev, struct ethtool_coalesce *ec)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nmemcpy(ec, &tp->coal, sizeof(*ec));\r\nreturn 0;\r\n}\r\nstatic int tg3_set_coalesce(struct net_device *dev, struct ethtool_coalesce *ec)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nu32 max_rxcoal_tick_int = 0, max_txcoal_tick_int = 0;\r\nu32 max_stat_coal_ticks = 0, min_stat_coal_ticks = 0;\r\nif (!tg3_flag(tp, 5705_PLUS)) {\r\nmax_rxcoal_tick_int = MAX_RXCOAL_TICK_INT;\r\nmax_txcoal_tick_int = MAX_TXCOAL_TICK_INT;\r\nmax_stat_coal_ticks = MAX_STAT_COAL_TICKS;\r\nmin_stat_coal_ticks = MIN_STAT_COAL_TICKS;\r\n}\r\nif ((ec->rx_coalesce_usecs > MAX_RXCOL_TICKS) ||\r\n(ec->tx_coalesce_usecs > MAX_TXCOL_TICKS) ||\r\n(ec->rx_max_coalesced_frames > MAX_RXMAX_FRAMES) ||\r\n(ec->tx_max_coalesced_frames > MAX_TXMAX_FRAMES) ||\r\n(ec->rx_coalesce_usecs_irq > max_rxcoal_tick_int) ||\r\n(ec->tx_coalesce_usecs_irq > max_txcoal_tick_int) ||\r\n(ec->rx_max_coalesced_frames_irq > MAX_RXCOAL_MAXF_INT) ||\r\n(ec->tx_max_coalesced_frames_irq > MAX_TXCOAL_MAXF_INT) ||\r\n(ec->stats_block_coalesce_usecs > max_stat_coal_ticks) ||\r\n(ec->stats_block_coalesce_usecs < min_stat_coal_ticks))\r\nreturn -EINVAL;\r\nif ((ec->rx_coalesce_usecs == 0) &&\r\n(ec->rx_max_coalesced_frames == 0))\r\nreturn -EINVAL;\r\nif ((ec->tx_coalesce_usecs == 0) &&\r\n(ec->tx_max_coalesced_frames == 0))\r\nreturn -EINVAL;\r\ntp->coal.rx_coalesce_usecs = ec->rx_coalesce_usecs;\r\ntp->coal.tx_coalesce_usecs = ec->tx_coalesce_usecs;\r\ntp->coal.rx_max_coalesced_frames = ec->rx_max_coalesced_frames;\r\ntp->coal.tx_max_coalesced_frames = ec->tx_max_coalesced_frames;\r\ntp->coal.rx_coalesce_usecs_irq = ec->rx_coalesce_usecs_irq;\r\ntp->coal.tx_coalesce_usecs_irq = ec->tx_coalesce_usecs_irq;\r\ntp->coal.rx_max_coalesced_frames_irq = ec->rx_max_coalesced_frames_irq;\r\ntp->coal.tx_max_coalesced_frames_irq = ec->tx_max_coalesced_frames_irq;\r\ntp->coal.stats_block_coalesce_usecs = ec->stats_block_coalesce_usecs;\r\nif (netif_running(dev)) {\r\ntg3_full_lock(tp, 0);\r\n__tg3_set_coalesce(tp, &tp->coal);\r\ntg3_full_unlock(tp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tg3_set_eee(struct net_device *dev, struct ethtool_eee *edata)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nif (!(tp->phy_flags & TG3_PHYFLG_EEE_CAP)) {\r\nnetdev_warn(tp->dev, "Board does not support EEE!\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (edata->advertised != tp->eee.advertised) {\r\nnetdev_warn(tp->dev,\r\n"Direct manipulation of EEE advertisement is not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (edata->tx_lpi_timer > TG3_CPMU_DBTMR1_LNKIDLE_MAX) {\r\nnetdev_warn(tp->dev,\r\n"Maximal Tx Lpi timer supported is %#x(u)\n",\r\nTG3_CPMU_DBTMR1_LNKIDLE_MAX);\r\nreturn -EINVAL;\r\n}\r\ntp->eee = *edata;\r\ntp->phy_flags |= TG3_PHYFLG_USER_CONFIGURED;\r\ntg3_warn_mgmt_link_flap(tp);\r\nif (netif_running(tp->dev)) {\r\ntg3_full_lock(tp, 0);\r\ntg3_setup_eee(tp);\r\ntg3_phy_reset(tp);\r\ntg3_full_unlock(tp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tg3_get_eee(struct net_device *dev, struct ethtool_eee *edata)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nif (!(tp->phy_flags & TG3_PHYFLG_EEE_CAP)) {\r\nnetdev_warn(tp->dev,\r\n"Board does not support EEE!\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\n*edata = tp->eee;\r\nreturn 0;\r\n}\r\nstatic struct rtnl_link_stats64 *tg3_get_stats64(struct net_device *dev,\r\nstruct rtnl_link_stats64 *stats)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nspin_lock_bh(&tp->lock);\r\nif (!tp->hw_stats) {\r\n*stats = tp->net_stats_prev;\r\nspin_unlock_bh(&tp->lock);\r\nreturn stats;\r\n}\r\ntg3_get_nstats(tp, stats);\r\nspin_unlock_bh(&tp->lock);\r\nreturn stats;\r\n}\r\nstatic void tg3_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nif (!netif_running(dev))\r\nreturn;\r\ntg3_full_lock(tp, 0);\r\n__tg3_set_rx_mode(dev);\r\ntg3_full_unlock(tp);\r\n}\r\nstatic inline void tg3_set_mtu(struct net_device *dev, struct tg3 *tp,\r\nint new_mtu)\r\n{\r\ndev->mtu = new_mtu;\r\nif (new_mtu > ETH_DATA_LEN) {\r\nif (tg3_flag(tp, 5780_CLASS)) {\r\nnetdev_update_features(dev);\r\ntg3_flag_clear(tp, TSO_CAPABLE);\r\n} else {\r\ntg3_flag_set(tp, JUMBO_RING_ENABLE);\r\n}\r\n} else {\r\nif (tg3_flag(tp, 5780_CLASS)) {\r\ntg3_flag_set(tp, TSO_CAPABLE);\r\nnetdev_update_features(dev);\r\n}\r\ntg3_flag_clear(tp, JUMBO_RING_ENABLE);\r\n}\r\n}\r\nstatic int tg3_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nstruct tg3 *tp = netdev_priv(dev);\r\nint err;\r\nbool reset_phy = false;\r\nif (new_mtu < TG3_MIN_MTU || new_mtu > TG3_MAX_MTU(tp))\r\nreturn -EINVAL;\r\nif (!netif_running(dev)) {\r\ntg3_set_mtu(dev, tp, new_mtu);\r\nreturn 0;\r\n}\r\ntg3_phy_stop(tp);\r\ntg3_netif_stop(tp);\r\ntg3_set_mtu(dev, tp, new_mtu);\r\ntg3_full_lock(tp, 1);\r\ntg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\r\nif (tg3_asic_rev(tp) == ASIC_REV_57766)\r\nreset_phy = true;\r\nerr = tg3_restart_hw(tp, reset_phy);\r\nif (!err)\r\ntg3_netif_start(tp);\r\ntg3_full_unlock(tp);\r\nif (!err)\r\ntg3_phy_start(tp);\r\nreturn err;\r\n}\r\nstatic void tg3_get_eeprom_size(struct tg3 *tp)\r\n{\r\nu32 cursize, val, magic;\r\ntp->nvram_size = EEPROM_CHIP_SIZE;\r\nif (tg3_nvram_read(tp, 0, &magic) != 0)\r\nreturn;\r\nif ((magic != TG3_EEPROM_MAGIC) &&\r\n((magic & TG3_EEPROM_MAGIC_FW_MSK) != TG3_EEPROM_MAGIC_FW) &&\r\n((magic & TG3_EEPROM_MAGIC_HW_MSK) != TG3_EEPROM_MAGIC_HW))\r\nreturn;\r\ncursize = 0x10;\r\nwhile (cursize < tp->nvram_size) {\r\nif (tg3_nvram_read(tp, cursize, &val) != 0)\r\nreturn;\r\nif (val == magic)\r\nbreak;\r\ncursize <<= 1;\r\n}\r\ntp->nvram_size = cursize;\r\n}\r\nstatic void tg3_get_nvram_size(struct tg3 *tp)\r\n{\r\nu32 val;\r\nif (tg3_flag(tp, NO_NVRAM) || tg3_nvram_read(tp, 0, &val) != 0)\r\nreturn;\r\nif (val != TG3_EEPROM_MAGIC) {\r\ntg3_get_eeprom_size(tp);\r\nreturn;\r\n}\r\nif (tg3_nvram_read(tp, 0xf0, &val) == 0) {\r\nif (val != 0) {\r\ntp->nvram_size = swab16((u16)(val & 0x0000ffff)) * 1024;\r\nreturn;\r\n}\r\n}\r\ntp->nvram_size = TG3_NVRAM_SIZE_512KB;\r\n}\r\nstatic void tg3_get_nvram_info(struct tg3 *tp)\r\n{\r\nu32 nvcfg1;\r\nnvcfg1 = tr32(NVRAM_CFG1);\r\nif (nvcfg1 & NVRAM_CFG1_FLASHIF_ENAB) {\r\ntg3_flag_set(tp, FLASH);\r\n} else {\r\nnvcfg1 &= ~NVRAM_CFG1_COMPAT_BYPASS;\r\ntw32(NVRAM_CFG1, nvcfg1);\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5750 ||\r\ntg3_flag(tp, 5780_CLASS)) {\r\nswitch (nvcfg1 & NVRAM_CFG1_VENDOR_MASK) {\r\ncase FLASH_VENDOR_ATMEL_FLASH_BUFFERED:\r\ntp->nvram_jedecnum = JEDEC_ATMEL;\r\ntp->nvram_pagesize = ATMEL_AT45DB0X1B_PAGE_SIZE;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\nbreak;\r\ncase FLASH_VENDOR_ATMEL_FLASH_UNBUFFERED:\r\ntp->nvram_jedecnum = JEDEC_ATMEL;\r\ntp->nvram_pagesize = ATMEL_AT25F512_PAGE_SIZE;\r\nbreak;\r\ncase FLASH_VENDOR_ATMEL_EEPROM:\r\ntp->nvram_jedecnum = JEDEC_ATMEL;\r\ntp->nvram_pagesize = ATMEL_AT24C512_CHIP_SIZE;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\nbreak;\r\ncase FLASH_VENDOR_ST:\r\ntp->nvram_jedecnum = JEDEC_ST;\r\ntp->nvram_pagesize = ST_M45PEX0_PAGE_SIZE;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\nbreak;\r\ncase FLASH_VENDOR_SAIFUN:\r\ntp->nvram_jedecnum = JEDEC_SAIFUN;\r\ntp->nvram_pagesize = SAIFUN_SA25F0XX_PAGE_SIZE;\r\nbreak;\r\ncase FLASH_VENDOR_SST_SMALL:\r\ncase FLASH_VENDOR_SST_LARGE:\r\ntp->nvram_jedecnum = JEDEC_SST;\r\ntp->nvram_pagesize = SST_25VF0X0_PAGE_SIZE;\r\nbreak;\r\n}\r\n} else {\r\ntp->nvram_jedecnum = JEDEC_ATMEL;\r\ntp->nvram_pagesize = ATMEL_AT45DB0X1B_PAGE_SIZE;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\n}\r\n}\r\nstatic void tg3_nvram_get_pagesize(struct tg3 *tp, u32 nvmcfg1)\r\n{\r\nswitch (nvmcfg1 & NVRAM_CFG1_5752PAGE_SIZE_MASK) {\r\ncase FLASH_5752PAGE_SIZE_256:\r\ntp->nvram_pagesize = 256;\r\nbreak;\r\ncase FLASH_5752PAGE_SIZE_512:\r\ntp->nvram_pagesize = 512;\r\nbreak;\r\ncase FLASH_5752PAGE_SIZE_1K:\r\ntp->nvram_pagesize = 1024;\r\nbreak;\r\ncase FLASH_5752PAGE_SIZE_2K:\r\ntp->nvram_pagesize = 2048;\r\nbreak;\r\ncase FLASH_5752PAGE_SIZE_4K:\r\ntp->nvram_pagesize = 4096;\r\nbreak;\r\ncase FLASH_5752PAGE_SIZE_264:\r\ntp->nvram_pagesize = 264;\r\nbreak;\r\ncase FLASH_5752PAGE_SIZE_528:\r\ntp->nvram_pagesize = 528;\r\nbreak;\r\n}\r\n}\r\nstatic void tg3_get_5752_nvram_info(struct tg3 *tp)\r\n{\r\nu32 nvcfg1;\r\nnvcfg1 = tr32(NVRAM_CFG1);\r\nif (nvcfg1 & (1 << 27))\r\ntg3_flag_set(tp, PROTECTED_NVRAM);\r\nswitch (nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK) {\r\ncase FLASH_5752VENDOR_ATMEL_EEPROM_64KHZ:\r\ncase FLASH_5752VENDOR_ATMEL_EEPROM_376KHZ:\r\ntp->nvram_jedecnum = JEDEC_ATMEL;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\nbreak;\r\ncase FLASH_5752VENDOR_ATMEL_FLASH_BUFFERED:\r\ntp->nvram_jedecnum = JEDEC_ATMEL;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\ntg3_flag_set(tp, FLASH);\r\nbreak;\r\ncase FLASH_5752VENDOR_ST_M45PE10:\r\ncase FLASH_5752VENDOR_ST_M45PE20:\r\ncase FLASH_5752VENDOR_ST_M45PE40:\r\ntp->nvram_jedecnum = JEDEC_ST;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\ntg3_flag_set(tp, FLASH);\r\nbreak;\r\n}\r\nif (tg3_flag(tp, FLASH)) {\r\ntg3_nvram_get_pagesize(tp, nvcfg1);\r\n} else {\r\ntp->nvram_pagesize = ATMEL_AT24C512_CHIP_SIZE;\r\nnvcfg1 &= ~NVRAM_CFG1_COMPAT_BYPASS;\r\ntw32(NVRAM_CFG1, nvcfg1);\r\n}\r\n}\r\nstatic void tg3_get_5755_nvram_info(struct tg3 *tp)\r\n{\r\nu32 nvcfg1, protect = 0;\r\nnvcfg1 = tr32(NVRAM_CFG1);\r\nif (nvcfg1 & (1 << 27)) {\r\ntg3_flag_set(tp, PROTECTED_NVRAM);\r\nprotect = 1;\r\n}\r\nnvcfg1 &= NVRAM_CFG1_5752VENDOR_MASK;\r\nswitch (nvcfg1) {\r\ncase FLASH_5755VENDOR_ATMEL_FLASH_1:\r\ncase FLASH_5755VENDOR_ATMEL_FLASH_2:\r\ncase FLASH_5755VENDOR_ATMEL_FLASH_3:\r\ncase FLASH_5755VENDOR_ATMEL_FLASH_5:\r\ntp->nvram_jedecnum = JEDEC_ATMEL;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\ntg3_flag_set(tp, FLASH);\r\ntp->nvram_pagesize = 264;\r\nif (nvcfg1 == FLASH_5755VENDOR_ATMEL_FLASH_1 ||\r\nnvcfg1 == FLASH_5755VENDOR_ATMEL_FLASH_5)\r\ntp->nvram_size = (protect ? 0x3e200 :\r\nTG3_NVRAM_SIZE_512KB);\r\nelse if (nvcfg1 == FLASH_5755VENDOR_ATMEL_FLASH_2)\r\ntp->nvram_size = (protect ? 0x1f200 :\r\nTG3_NVRAM_SIZE_256KB);\r\nelse\r\ntp->nvram_size = (protect ? 0x1f200 :\r\nTG3_NVRAM_SIZE_128KB);\r\nbreak;\r\ncase FLASH_5752VENDOR_ST_M45PE10:\r\ncase FLASH_5752VENDOR_ST_M45PE20:\r\ncase FLASH_5752VENDOR_ST_M45PE40:\r\ntp->nvram_jedecnum = JEDEC_ST;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\ntg3_flag_set(tp, FLASH);\r\ntp->nvram_pagesize = 256;\r\nif (nvcfg1 == FLASH_5752VENDOR_ST_M45PE10)\r\ntp->nvram_size = (protect ?\r\nTG3_NVRAM_SIZE_64KB :\r\nTG3_NVRAM_SIZE_128KB);\r\nelse if (nvcfg1 == FLASH_5752VENDOR_ST_M45PE20)\r\ntp->nvram_size = (protect ?\r\nTG3_NVRAM_SIZE_64KB :\r\nTG3_NVRAM_SIZE_256KB);\r\nelse\r\ntp->nvram_size = (protect ?\r\nTG3_NVRAM_SIZE_128KB :\r\nTG3_NVRAM_SIZE_512KB);\r\nbreak;\r\n}\r\n}\r\nstatic void tg3_get_5787_nvram_info(struct tg3 *tp)\r\n{\r\nu32 nvcfg1;\r\nnvcfg1 = tr32(NVRAM_CFG1);\r\nswitch (nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK) {\r\ncase FLASH_5787VENDOR_ATMEL_EEPROM_64KHZ:\r\ncase FLASH_5787VENDOR_ATMEL_EEPROM_376KHZ:\r\ncase FLASH_5787VENDOR_MICRO_EEPROM_64KHZ:\r\ncase FLASH_5787VENDOR_MICRO_EEPROM_376KHZ:\r\ntp->nvram_jedecnum = JEDEC_ATMEL;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\ntp->nvram_pagesize = ATMEL_AT24C512_CHIP_SIZE;\r\nnvcfg1 &= ~NVRAM_CFG1_COMPAT_BYPASS;\r\ntw32(NVRAM_CFG1, nvcfg1);\r\nbreak;\r\ncase FLASH_5752VENDOR_ATMEL_FLASH_BUFFERED:\r\ncase FLASH_5755VENDOR_ATMEL_FLASH_1:\r\ncase FLASH_5755VENDOR_ATMEL_FLASH_2:\r\ncase FLASH_5755VENDOR_ATMEL_FLASH_3:\r\ntp->nvram_jedecnum = JEDEC_ATMEL;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\ntg3_flag_set(tp, FLASH);\r\ntp->nvram_pagesize = 264;\r\nbreak;\r\ncase FLASH_5752VENDOR_ST_M45PE10:\r\ncase FLASH_5752VENDOR_ST_M45PE20:\r\ncase FLASH_5752VENDOR_ST_M45PE40:\r\ntp->nvram_jedecnum = JEDEC_ST;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\ntg3_flag_set(tp, FLASH);\r\ntp->nvram_pagesize = 256;\r\nbreak;\r\n}\r\n}\r\nstatic void tg3_get_5761_nvram_info(struct tg3 *tp)\r\n{\r\nu32 nvcfg1, protect = 0;\r\nnvcfg1 = tr32(NVRAM_CFG1);\r\nif (nvcfg1 & (1 << 27)) {\r\ntg3_flag_set(tp, PROTECTED_NVRAM);\r\nprotect = 1;\r\n}\r\nnvcfg1 &= NVRAM_CFG1_5752VENDOR_MASK;\r\nswitch (nvcfg1) {\r\ncase FLASH_5761VENDOR_ATMEL_ADB021D:\r\ncase FLASH_5761VENDOR_ATMEL_ADB041D:\r\ncase FLASH_5761VENDOR_ATMEL_ADB081D:\r\ncase FLASH_5761VENDOR_ATMEL_ADB161D:\r\ncase FLASH_5761VENDOR_ATMEL_MDB021D:\r\ncase FLASH_5761VENDOR_ATMEL_MDB041D:\r\ncase FLASH_5761VENDOR_ATMEL_MDB081D:\r\ncase FLASH_5761VENDOR_ATMEL_MDB161D:\r\ntp->nvram_jedecnum = JEDEC_ATMEL;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\ntg3_flag_set(tp, FLASH);\r\ntg3_flag_set(tp, NO_NVRAM_ADDR_TRANS);\r\ntp->nvram_pagesize = 256;\r\nbreak;\r\ncase FLASH_5761VENDOR_ST_A_M45PE20:\r\ncase FLASH_5761VENDOR_ST_A_M45PE40:\r\ncase FLASH_5761VENDOR_ST_A_M45PE80:\r\ncase FLASH_5761VENDOR_ST_A_M45PE16:\r\ncase FLASH_5761VENDOR_ST_M_M45PE20:\r\ncase FLASH_5761VENDOR_ST_M_M45PE40:\r\ncase FLASH_5761VENDOR_ST_M_M45PE80:\r\ncase FLASH_5761VENDOR_ST_M_M45PE16:\r\ntp->nvram_jedecnum = JEDEC_ST;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\ntg3_flag_set(tp, FLASH);\r\ntp->nvram_pagesize = 256;\r\nbreak;\r\n}\r\nif (protect) {\r\ntp->nvram_size = tr32(NVRAM_ADDR_LOCKOUT);\r\n} else {\r\nswitch (nvcfg1) {\r\ncase FLASH_5761VENDOR_ATMEL_ADB161D:\r\ncase FLASH_5761VENDOR_ATMEL_MDB161D:\r\ncase FLASH_5761VENDOR_ST_A_M45PE16:\r\ncase FLASH_5761VENDOR_ST_M_M45PE16:\r\ntp->nvram_size = TG3_NVRAM_SIZE_2MB;\r\nbreak;\r\ncase FLASH_5761VENDOR_ATMEL_ADB081D:\r\ncase FLASH_5761VENDOR_ATMEL_MDB081D:\r\ncase FLASH_5761VENDOR_ST_A_M45PE80:\r\ncase FLASH_5761VENDOR_ST_M_M45PE80:\r\ntp->nvram_size = TG3_NVRAM_SIZE_1MB;\r\nbreak;\r\ncase FLASH_5761VENDOR_ATMEL_ADB041D:\r\ncase FLASH_5761VENDOR_ATMEL_MDB041D:\r\ncase FLASH_5761VENDOR_ST_A_M45PE40:\r\ncase FLASH_5761VENDOR_ST_M_M45PE40:\r\ntp->nvram_size = TG3_NVRAM_SIZE_512KB;\r\nbreak;\r\ncase FLASH_5761VENDOR_ATMEL_ADB021D:\r\ncase FLASH_5761VENDOR_ATMEL_MDB021D:\r\ncase FLASH_5761VENDOR_ST_A_M45PE20:\r\ncase FLASH_5761VENDOR_ST_M_M45PE20:\r\ntp->nvram_size = TG3_NVRAM_SIZE_256KB;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void tg3_get_5906_nvram_info(struct tg3 *tp)\r\n{\r\ntp->nvram_jedecnum = JEDEC_ATMEL;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\ntp->nvram_pagesize = ATMEL_AT24C512_CHIP_SIZE;\r\n}\r\nstatic void tg3_get_57780_nvram_info(struct tg3 *tp)\r\n{\r\nu32 nvcfg1;\r\nnvcfg1 = tr32(NVRAM_CFG1);\r\nswitch (nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK) {\r\ncase FLASH_5787VENDOR_ATMEL_EEPROM_376KHZ:\r\ncase FLASH_5787VENDOR_MICRO_EEPROM_376KHZ:\r\ntp->nvram_jedecnum = JEDEC_ATMEL;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\ntp->nvram_pagesize = ATMEL_AT24C512_CHIP_SIZE;\r\nnvcfg1 &= ~NVRAM_CFG1_COMPAT_BYPASS;\r\ntw32(NVRAM_CFG1, nvcfg1);\r\nreturn;\r\ncase FLASH_5752VENDOR_ATMEL_FLASH_BUFFERED:\r\ncase FLASH_57780VENDOR_ATMEL_AT45DB011D:\r\ncase FLASH_57780VENDOR_ATMEL_AT45DB011B:\r\ncase FLASH_57780VENDOR_ATMEL_AT45DB021D:\r\ncase FLASH_57780VENDOR_ATMEL_AT45DB021B:\r\ncase FLASH_57780VENDOR_ATMEL_AT45DB041D:\r\ncase FLASH_57780VENDOR_ATMEL_AT45DB041B:\r\ntp->nvram_jedecnum = JEDEC_ATMEL;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\ntg3_flag_set(tp, FLASH);\r\nswitch (nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK) {\r\ncase FLASH_5752VENDOR_ATMEL_FLASH_BUFFERED:\r\ncase FLASH_57780VENDOR_ATMEL_AT45DB011D:\r\ncase FLASH_57780VENDOR_ATMEL_AT45DB011B:\r\ntp->nvram_size = TG3_NVRAM_SIZE_128KB;\r\nbreak;\r\ncase FLASH_57780VENDOR_ATMEL_AT45DB021D:\r\ncase FLASH_57780VENDOR_ATMEL_AT45DB021B:\r\ntp->nvram_size = TG3_NVRAM_SIZE_256KB;\r\nbreak;\r\ncase FLASH_57780VENDOR_ATMEL_AT45DB041D:\r\ncase FLASH_57780VENDOR_ATMEL_AT45DB041B:\r\ntp->nvram_size = TG3_NVRAM_SIZE_512KB;\r\nbreak;\r\n}\r\nbreak;\r\ncase FLASH_5752VENDOR_ST_M45PE10:\r\ncase FLASH_5752VENDOR_ST_M45PE20:\r\ncase FLASH_5752VENDOR_ST_M45PE40:\r\ntp->nvram_jedecnum = JEDEC_ST;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\ntg3_flag_set(tp, FLASH);\r\nswitch (nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK) {\r\ncase FLASH_5752VENDOR_ST_M45PE10:\r\ntp->nvram_size = TG3_NVRAM_SIZE_128KB;\r\nbreak;\r\ncase FLASH_5752VENDOR_ST_M45PE20:\r\ntp->nvram_size = TG3_NVRAM_SIZE_256KB;\r\nbreak;\r\ncase FLASH_5752VENDOR_ST_M45PE40:\r\ntp->nvram_size = TG3_NVRAM_SIZE_512KB;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\ntg3_flag_set(tp, NO_NVRAM);\r\nreturn;\r\n}\r\ntg3_nvram_get_pagesize(tp, nvcfg1);\r\nif (tp->nvram_pagesize != 264 && tp->nvram_pagesize != 528)\r\ntg3_flag_set(tp, NO_NVRAM_ADDR_TRANS);\r\n}\r\nstatic void tg3_get_5717_nvram_info(struct tg3 *tp)\r\n{\r\nu32 nvcfg1;\r\nnvcfg1 = tr32(NVRAM_CFG1);\r\nswitch (nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK) {\r\ncase FLASH_5717VENDOR_ATMEL_EEPROM:\r\ncase FLASH_5717VENDOR_MICRO_EEPROM:\r\ntp->nvram_jedecnum = JEDEC_ATMEL;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\ntp->nvram_pagesize = ATMEL_AT24C512_CHIP_SIZE;\r\nnvcfg1 &= ~NVRAM_CFG1_COMPAT_BYPASS;\r\ntw32(NVRAM_CFG1, nvcfg1);\r\nreturn;\r\ncase FLASH_5717VENDOR_ATMEL_MDB011D:\r\ncase FLASH_5717VENDOR_ATMEL_ADB011B:\r\ncase FLASH_5717VENDOR_ATMEL_ADB011D:\r\ncase FLASH_5717VENDOR_ATMEL_MDB021D:\r\ncase FLASH_5717VENDOR_ATMEL_ADB021B:\r\ncase FLASH_5717VENDOR_ATMEL_ADB021D:\r\ncase FLASH_5717VENDOR_ATMEL_45USPT:\r\ntp->nvram_jedecnum = JEDEC_ATMEL;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\ntg3_flag_set(tp, FLASH);\r\nswitch (nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK) {\r\ncase FLASH_5717VENDOR_ATMEL_MDB021D:\r\nbreak;\r\ncase FLASH_5717VENDOR_ATMEL_ADB021B:\r\ncase FLASH_5717VENDOR_ATMEL_ADB021D:\r\ntp->nvram_size = TG3_NVRAM_SIZE_256KB;\r\nbreak;\r\ndefault:\r\ntp->nvram_size = TG3_NVRAM_SIZE_128KB;\r\nbreak;\r\n}\r\nbreak;\r\ncase FLASH_5717VENDOR_ST_M_M25PE10:\r\ncase FLASH_5717VENDOR_ST_A_M25PE10:\r\ncase FLASH_5717VENDOR_ST_M_M45PE10:\r\ncase FLASH_5717VENDOR_ST_A_M45PE10:\r\ncase FLASH_5717VENDOR_ST_M_M25PE20:\r\ncase FLASH_5717VENDOR_ST_A_M25PE20:\r\ncase FLASH_5717VENDOR_ST_M_M45PE20:\r\ncase FLASH_5717VENDOR_ST_A_M45PE20:\r\ncase FLASH_5717VENDOR_ST_25USPT:\r\ncase FLASH_5717VENDOR_ST_45USPT:\r\ntp->nvram_jedecnum = JEDEC_ST;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\ntg3_flag_set(tp, FLASH);\r\nswitch (nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK) {\r\ncase FLASH_5717VENDOR_ST_M_M25PE20:\r\ncase FLASH_5717VENDOR_ST_M_M45PE20:\r\nbreak;\r\ncase FLASH_5717VENDOR_ST_A_M25PE20:\r\ncase FLASH_5717VENDOR_ST_A_M45PE20:\r\ntp->nvram_size = TG3_NVRAM_SIZE_256KB;\r\nbreak;\r\ndefault:\r\ntp->nvram_size = TG3_NVRAM_SIZE_128KB;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\ntg3_flag_set(tp, NO_NVRAM);\r\nreturn;\r\n}\r\ntg3_nvram_get_pagesize(tp, nvcfg1);\r\nif (tp->nvram_pagesize != 264 && tp->nvram_pagesize != 528)\r\ntg3_flag_set(tp, NO_NVRAM_ADDR_TRANS);\r\n}\r\nstatic void tg3_get_5720_nvram_info(struct tg3 *tp)\r\n{\r\nu32 nvcfg1, nvmpinstrp;\r\nnvcfg1 = tr32(NVRAM_CFG1);\r\nnvmpinstrp = nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5762) {\r\nif (!(nvcfg1 & NVRAM_CFG1_5762VENDOR_MASK)) {\r\ntg3_flag_set(tp, NO_NVRAM);\r\nreturn;\r\n}\r\nswitch (nvmpinstrp) {\r\ncase FLASH_5762_EEPROM_HD:\r\nnvmpinstrp = FLASH_5720_EEPROM_HD;\r\nbreak;\r\ncase FLASH_5762_EEPROM_LD:\r\nnvmpinstrp = FLASH_5720_EEPROM_LD;\r\nbreak;\r\ncase FLASH_5720VENDOR_M_ST_M45PE20:\r\nnvmpinstrp = FLASH_5720VENDOR_ST_45USPT;\r\nbreak;\r\n}\r\n}\r\nswitch (nvmpinstrp) {\r\ncase FLASH_5720_EEPROM_HD:\r\ncase FLASH_5720_EEPROM_LD:\r\ntp->nvram_jedecnum = JEDEC_ATMEL;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\nnvcfg1 &= ~NVRAM_CFG1_COMPAT_BYPASS;\r\ntw32(NVRAM_CFG1, nvcfg1);\r\nif (nvmpinstrp == FLASH_5720_EEPROM_HD)\r\ntp->nvram_pagesize = ATMEL_AT24C512_CHIP_SIZE;\r\nelse\r\ntp->nvram_pagesize = ATMEL_AT24C02_CHIP_SIZE;\r\nreturn;\r\ncase FLASH_5720VENDOR_M_ATMEL_DB011D:\r\ncase FLASH_5720VENDOR_A_ATMEL_DB011B:\r\ncase FLASH_5720VENDOR_A_ATMEL_DB011D:\r\ncase FLASH_5720VENDOR_M_ATMEL_DB021D:\r\ncase FLASH_5720VENDOR_A_ATMEL_DB021B:\r\ncase FLASH_5720VENDOR_A_ATMEL_DB021D:\r\ncase FLASH_5720VENDOR_M_ATMEL_DB041D:\r\ncase FLASH_5720VENDOR_A_ATMEL_DB041B:\r\ncase FLASH_5720VENDOR_A_ATMEL_DB041D:\r\ncase FLASH_5720VENDOR_M_ATMEL_DB081D:\r\ncase FLASH_5720VENDOR_A_ATMEL_DB081D:\r\ncase FLASH_5720VENDOR_ATMEL_45USPT:\r\ntp->nvram_jedecnum = JEDEC_ATMEL;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\ntg3_flag_set(tp, FLASH);\r\nswitch (nvmpinstrp) {\r\ncase FLASH_5720VENDOR_M_ATMEL_DB021D:\r\ncase FLASH_5720VENDOR_A_ATMEL_DB021B:\r\ncase FLASH_5720VENDOR_A_ATMEL_DB021D:\r\ntp->nvram_size = TG3_NVRAM_SIZE_256KB;\r\nbreak;\r\ncase FLASH_5720VENDOR_M_ATMEL_DB041D:\r\ncase FLASH_5720VENDOR_A_ATMEL_DB041B:\r\ncase FLASH_5720VENDOR_A_ATMEL_DB041D:\r\ntp->nvram_size = TG3_NVRAM_SIZE_512KB;\r\nbreak;\r\ncase FLASH_5720VENDOR_M_ATMEL_DB081D:\r\ncase FLASH_5720VENDOR_A_ATMEL_DB081D:\r\ntp->nvram_size = TG3_NVRAM_SIZE_1MB;\r\nbreak;\r\ndefault:\r\nif (tg3_asic_rev(tp) != ASIC_REV_5762)\r\ntp->nvram_size = TG3_NVRAM_SIZE_128KB;\r\nbreak;\r\n}\r\nbreak;\r\ncase FLASH_5720VENDOR_M_ST_M25PE10:\r\ncase FLASH_5720VENDOR_M_ST_M45PE10:\r\ncase FLASH_5720VENDOR_A_ST_M25PE10:\r\ncase FLASH_5720VENDOR_A_ST_M45PE10:\r\ncase FLASH_5720VENDOR_M_ST_M25PE20:\r\ncase FLASH_5720VENDOR_M_ST_M45PE20:\r\ncase FLASH_5720VENDOR_A_ST_M25PE20:\r\ncase FLASH_5720VENDOR_A_ST_M45PE20:\r\ncase FLASH_5720VENDOR_M_ST_M25PE40:\r\ncase FLASH_5720VENDOR_M_ST_M45PE40:\r\ncase FLASH_5720VENDOR_A_ST_M25PE40:\r\ncase FLASH_5720VENDOR_A_ST_M45PE40:\r\ncase FLASH_5720VENDOR_M_ST_M25PE80:\r\ncase FLASH_5720VENDOR_M_ST_M45PE80:\r\ncase FLASH_5720VENDOR_A_ST_M25PE80:\r\ncase FLASH_5720VENDOR_A_ST_M45PE80:\r\ncase FLASH_5720VENDOR_ST_25USPT:\r\ncase FLASH_5720VENDOR_ST_45USPT:\r\ntp->nvram_jedecnum = JEDEC_ST;\r\ntg3_flag_set(tp, NVRAM_BUFFERED);\r\ntg3_flag_set(tp, FLASH);\r\nswitch (nvmpinstrp) {\r\ncase FLASH_5720VENDOR_M_ST_M25PE20:\r\ncase FLASH_5720VENDOR_M_ST_M45PE20:\r\ncase FLASH_5720VENDOR_A_ST_M25PE20:\r\ncase FLASH_5720VENDOR_A_ST_M45PE20:\r\ntp->nvram_size = TG3_NVRAM_SIZE_256KB;\r\nbreak;\r\ncase FLASH_5720VENDOR_M_ST_M25PE40:\r\ncase FLASH_5720VENDOR_M_ST_M45PE40:\r\ncase FLASH_5720VENDOR_A_ST_M25PE40:\r\ncase FLASH_5720VENDOR_A_ST_M45PE40:\r\ntp->nvram_size = TG3_NVRAM_SIZE_512KB;\r\nbreak;\r\ncase FLASH_5720VENDOR_M_ST_M25PE80:\r\ncase FLASH_5720VENDOR_M_ST_M45PE80:\r\ncase FLASH_5720VENDOR_A_ST_M25PE80:\r\ncase FLASH_5720VENDOR_A_ST_M45PE80:\r\ntp->nvram_size = TG3_NVRAM_SIZE_1MB;\r\nbreak;\r\ndefault:\r\nif (tg3_asic_rev(tp) != ASIC_REV_5762)\r\ntp->nvram_size = TG3_NVRAM_SIZE_128KB;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\ntg3_flag_set(tp, NO_NVRAM);\r\nreturn;\r\n}\r\ntg3_nvram_get_pagesize(tp, nvcfg1);\r\nif (tp->nvram_pagesize != 264 && tp->nvram_pagesize != 528)\r\ntg3_flag_set(tp, NO_NVRAM_ADDR_TRANS);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5762) {\r\nu32 val;\r\nif (tg3_nvram_read(tp, 0, &val))\r\nreturn;\r\nif (val != TG3_EEPROM_MAGIC &&\r\n(val & TG3_EEPROM_MAGIC_FW_MSK) != TG3_EEPROM_MAGIC_FW)\r\ntg3_flag_set(tp, NO_NVRAM);\r\n}\r\n}\r\nstatic void tg3_nvram_init(struct tg3 *tp)\r\n{\r\nif (tg3_flag(tp, IS_SSB_CORE)) {\r\ntg3_flag_clear(tp, NVRAM);\r\ntg3_flag_clear(tp, NVRAM_BUFFERED);\r\ntg3_flag_set(tp, NO_NVRAM);\r\nreturn;\r\n}\r\ntw32_f(GRC_EEPROM_ADDR,\r\n(EEPROM_ADDR_FSM_RESET |\r\n(EEPROM_DEFAULT_CLOCK_PERIOD <<\r\nEEPROM_ADDR_CLKPERD_SHIFT)));\r\nmsleep(1);\r\ntw32_f(GRC_LOCAL_CTRL,\r\ntr32(GRC_LOCAL_CTRL) | GRC_LCLCTRL_AUTO_SEEPROM);\r\nudelay(100);\r\nif (tg3_asic_rev(tp) != ASIC_REV_5700 &&\r\ntg3_asic_rev(tp) != ASIC_REV_5701) {\r\ntg3_flag_set(tp, NVRAM);\r\nif (tg3_nvram_lock(tp)) {\r\nnetdev_warn(tp->dev,\r\n"Cannot get nvram lock, %s failed\n",\r\n__func__);\r\nreturn;\r\n}\r\ntg3_enable_nvram_access(tp);\r\ntp->nvram_size = 0;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5752)\r\ntg3_get_5752_nvram_info(tp);\r\nelse if (tg3_asic_rev(tp) == ASIC_REV_5755)\r\ntg3_get_5755_nvram_info(tp);\r\nelse if (tg3_asic_rev(tp) == ASIC_REV_5787 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5784 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5785)\r\ntg3_get_5787_nvram_info(tp);\r\nelse if (tg3_asic_rev(tp) == ASIC_REV_5761)\r\ntg3_get_5761_nvram_info(tp);\r\nelse if (tg3_asic_rev(tp) == ASIC_REV_5906)\r\ntg3_get_5906_nvram_info(tp);\r\nelse if (tg3_asic_rev(tp) == ASIC_REV_57780 ||\r\ntg3_flag(tp, 57765_CLASS))\r\ntg3_get_57780_nvram_info(tp);\r\nelse if (tg3_asic_rev(tp) == ASIC_REV_5717 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5719)\r\ntg3_get_5717_nvram_info(tp);\r\nelse if (tg3_asic_rev(tp) == ASIC_REV_5720 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5762)\r\ntg3_get_5720_nvram_info(tp);\r\nelse\r\ntg3_get_nvram_info(tp);\r\nif (tp->nvram_size == 0)\r\ntg3_get_nvram_size(tp);\r\ntg3_disable_nvram_access(tp);\r\ntg3_nvram_unlock(tp);\r\n} else {\r\ntg3_flag_clear(tp, NVRAM);\r\ntg3_flag_clear(tp, NVRAM_BUFFERED);\r\ntg3_get_eeprom_size(tp);\r\n}\r\n}\r\nstatic struct subsys_tbl_ent *tg3_lookup_by_subsys(struct tg3 *tp)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(subsys_id_to_phy_id); i++) {\r\nif ((subsys_id_to_phy_id[i].subsys_vendor ==\r\ntp->pdev->subsystem_vendor) &&\r\n(subsys_id_to_phy_id[i].subsys_devid ==\r\ntp->pdev->subsystem_device))\r\nreturn &subsys_id_to_phy_id[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic void tg3_get_eeprom_hw_cfg(struct tg3 *tp)\r\n{\r\nu32 val;\r\ntp->phy_id = TG3_PHY_ID_INVALID;\r\ntp->led_ctrl = LED_CTRL_MODE_PHY_1;\r\ntg3_flag_set(tp, EEPROM_WRITE_PROT);\r\ntg3_flag_set(tp, WOL_CAP);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5906) {\r\nif (!(tr32(PCIE_TRANSACTION_CFG) & PCIE_TRANS_CFG_LOM)) {\r\ntg3_flag_clear(tp, EEPROM_WRITE_PROT);\r\ntg3_flag_set(tp, IS_NIC);\r\n}\r\nval = tr32(VCPU_CFGSHDW);\r\nif (val & VCPU_CFGSHDW_ASPM_DBNC)\r\ntg3_flag_set(tp, ASPM_WORKAROUND);\r\nif ((val & VCPU_CFGSHDW_WOL_ENABLE) &&\r\n(val & VCPU_CFGSHDW_WOL_MAGPKT)) {\r\ntg3_flag_set(tp, WOL_ENABLE);\r\ndevice_set_wakeup_enable(&tp->pdev->dev, true);\r\n}\r\ngoto done;\r\n}\r\ntg3_read_mem(tp, NIC_SRAM_DATA_SIG, &val);\r\nif (val == NIC_SRAM_DATA_SIG_MAGIC) {\r\nu32 nic_cfg, led_cfg;\r\nu32 cfg2 = 0, cfg4 = 0, cfg5 = 0;\r\nu32 nic_phy_id, ver, eeprom_phy_id;\r\nint eeprom_phy_serdes = 0;\r\ntg3_read_mem(tp, NIC_SRAM_DATA_CFG, &nic_cfg);\r\ntp->nic_sram_data_cfg = nic_cfg;\r\ntg3_read_mem(tp, NIC_SRAM_DATA_VER, &ver);\r\nver >>= NIC_SRAM_DATA_VER_SHIFT;\r\nif (tg3_asic_rev(tp) != ASIC_REV_5700 &&\r\ntg3_asic_rev(tp) != ASIC_REV_5701 &&\r\ntg3_asic_rev(tp) != ASIC_REV_5703 &&\r\n(ver > 0) && (ver < 0x100))\r\ntg3_read_mem(tp, NIC_SRAM_DATA_CFG_2, &cfg2);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5785)\r\ntg3_read_mem(tp, NIC_SRAM_DATA_CFG_4, &cfg4);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5719 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5720)\r\ntg3_read_mem(tp, NIC_SRAM_DATA_CFG_5, &cfg5);\r\nif ((nic_cfg & NIC_SRAM_DATA_CFG_PHY_TYPE_MASK) ==\r\nNIC_SRAM_DATA_CFG_PHY_TYPE_FIBER)\r\neeprom_phy_serdes = 1;\r\ntg3_read_mem(tp, NIC_SRAM_DATA_PHY_ID, &nic_phy_id);\r\nif (nic_phy_id != 0) {\r\nu32 id1 = nic_phy_id & NIC_SRAM_DATA_PHY_ID1_MASK;\r\nu32 id2 = nic_phy_id & NIC_SRAM_DATA_PHY_ID2_MASK;\r\neeprom_phy_id = (id1 >> 16) << 10;\r\neeprom_phy_id |= (id2 & 0xfc00) << 16;\r\neeprom_phy_id |= (id2 & 0x03ff) << 0;\r\n} else\r\neeprom_phy_id = 0;\r\ntp->phy_id = eeprom_phy_id;\r\nif (eeprom_phy_serdes) {\r\nif (!tg3_flag(tp, 5705_PLUS))\r\ntp->phy_flags |= TG3_PHYFLG_PHY_SERDES;\r\nelse\r\ntp->phy_flags |= TG3_PHYFLG_MII_SERDES;\r\n}\r\nif (tg3_flag(tp, 5750_PLUS))\r\nled_cfg = cfg2 & (NIC_SRAM_DATA_CFG_LED_MODE_MASK |\r\nSHASTA_EXT_LED_MODE_MASK);\r\nelse\r\nled_cfg = nic_cfg & NIC_SRAM_DATA_CFG_LED_MODE_MASK;\r\nswitch (led_cfg) {\r\ndefault:\r\ncase NIC_SRAM_DATA_CFG_LED_MODE_PHY_1:\r\ntp->led_ctrl = LED_CTRL_MODE_PHY_1;\r\nbreak;\r\ncase NIC_SRAM_DATA_CFG_LED_MODE_PHY_2:\r\ntp->led_ctrl = LED_CTRL_MODE_PHY_2;\r\nbreak;\r\ncase NIC_SRAM_DATA_CFG_LED_MODE_MAC:\r\ntp->led_ctrl = LED_CTRL_MODE_MAC;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5700 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5701)\r\ntp->led_ctrl = LED_CTRL_MODE_PHY_1;\r\nbreak;\r\ncase SHASTA_EXT_LED_SHARED:\r\ntp->led_ctrl = LED_CTRL_MODE_SHARED;\r\nif (tg3_chip_rev_id(tp) != CHIPREV_ID_5750_A0 &&\r\ntg3_chip_rev_id(tp) != CHIPREV_ID_5750_A1)\r\ntp->led_ctrl |= (LED_CTRL_MODE_PHY_1 |\r\nLED_CTRL_MODE_PHY_2);\r\nif (tg3_flag(tp, 5717_PLUS) ||\r\ntg3_asic_rev(tp) == ASIC_REV_5762)\r\ntp->led_ctrl |= LED_CTRL_BLINK_RATE_OVERRIDE |\r\nLED_CTRL_BLINK_RATE_MASK;\r\nbreak;\r\ncase SHASTA_EXT_LED_MAC:\r\ntp->led_ctrl = LED_CTRL_MODE_SHASTA_MAC;\r\nbreak;\r\ncase SHASTA_EXT_LED_COMBO:\r\ntp->led_ctrl = LED_CTRL_MODE_COMBO;\r\nif (tg3_chip_rev_id(tp) != CHIPREV_ID_5750_A0)\r\ntp->led_ctrl |= (LED_CTRL_MODE_PHY_1 |\r\nLED_CTRL_MODE_PHY_2);\r\nbreak;\r\n}\r\nif ((tg3_asic_rev(tp) == ASIC_REV_5700 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5701) &&\r\ntp->pdev->subsystem_vendor == PCI_VENDOR_ID_DELL)\r\ntp->led_ctrl = LED_CTRL_MODE_PHY_2;\r\nif (tg3_chip_rev(tp) == CHIPREV_5784_AX)\r\ntp->led_ctrl = LED_CTRL_MODE_PHY_1;\r\nif (nic_cfg & NIC_SRAM_DATA_CFG_EEPROM_WP) {\r\ntg3_flag_set(tp, EEPROM_WRITE_PROT);\r\nif ((tp->pdev->subsystem_vendor ==\r\nPCI_VENDOR_ID_ARIMA) &&\r\n(tp->pdev->subsystem_device == 0x205a ||\r\ntp->pdev->subsystem_device == 0x2063))\r\ntg3_flag_clear(tp, EEPROM_WRITE_PROT);\r\n} else {\r\ntg3_flag_clear(tp, EEPROM_WRITE_PROT);\r\ntg3_flag_set(tp, IS_NIC);\r\n}\r\nif (nic_cfg & NIC_SRAM_DATA_CFG_ASF_ENABLE) {\r\ntg3_flag_set(tp, ENABLE_ASF);\r\nif (tg3_flag(tp, 5750_PLUS))\r\ntg3_flag_set(tp, ASF_NEW_HANDSHAKE);\r\n}\r\nif ((nic_cfg & NIC_SRAM_DATA_CFG_APE_ENABLE) &&\r\ntg3_flag(tp, 5750_PLUS))\r\ntg3_flag_set(tp, ENABLE_APE);\r\nif (tp->phy_flags & TG3_PHYFLG_ANY_SERDES &&\r\n!(nic_cfg & NIC_SRAM_DATA_CFG_FIBER_WOL))\r\ntg3_flag_clear(tp, WOL_CAP);\r\nif (tg3_flag(tp, WOL_CAP) &&\r\n(nic_cfg & NIC_SRAM_DATA_CFG_WOL_ENABLE)) {\r\ntg3_flag_set(tp, WOL_ENABLE);\r\ndevice_set_wakeup_enable(&tp->pdev->dev, true);\r\n}\r\nif (cfg2 & (1 << 17))\r\ntp->phy_flags |= TG3_PHYFLG_CAPACITIVE_COUPLING;\r\nif (cfg2 & (1 << 18))\r\ntp->phy_flags |= TG3_PHYFLG_SERDES_PREEMPHASIS;\r\nif ((tg3_flag(tp, 57765_PLUS) ||\r\n(tg3_asic_rev(tp) == ASIC_REV_5784 &&\r\ntg3_chip_rev(tp) != CHIPREV_5784_AX)) &&\r\n(cfg2 & NIC_SRAM_DATA_CFG_2_APD_EN))\r\ntp->phy_flags |= TG3_PHYFLG_ENABLE_APD;\r\nif (tg3_flag(tp, PCI_EXPRESS)) {\r\nu32 cfg3;\r\ntg3_read_mem(tp, NIC_SRAM_DATA_CFG_3, &cfg3);\r\nif (tg3_asic_rev(tp) != ASIC_REV_5785 &&\r\n!tg3_flag(tp, 57765_PLUS) &&\r\n(cfg3 & NIC_SRAM_ASPM_DEBOUNCE))\r\ntg3_flag_set(tp, ASPM_WORKAROUND);\r\nif (cfg3 & NIC_SRAM_LNK_FLAP_AVOID)\r\ntp->phy_flags |= TG3_PHYFLG_KEEP_LINK_ON_PWRDN;\r\nif (cfg3 & NIC_SRAM_1G_ON_VAUX_OK)\r\ntp->phy_flags |= TG3_PHYFLG_1G_ON_VAUX_OK;\r\n}\r\nif (cfg4 & NIC_SRAM_RGMII_INBAND_DISABLE)\r\ntg3_flag_set(tp, RGMII_INBAND_DISABLE);\r\nif (cfg4 & NIC_SRAM_RGMII_EXT_IBND_RX_EN)\r\ntg3_flag_set(tp, RGMII_EXT_IBND_RX_EN);\r\nif (cfg4 & NIC_SRAM_RGMII_EXT_IBND_TX_EN)\r\ntg3_flag_set(tp, RGMII_EXT_IBND_TX_EN);\r\nif (cfg5 & NIC_SRAM_DISABLE_1G_HALF_ADV)\r\ntp->phy_flags |= TG3_PHYFLG_DISABLE_1G_HD_ADV;\r\n}\r\ndone:\r\nif (tg3_flag(tp, WOL_CAP))\r\ndevice_set_wakeup_enable(&tp->pdev->dev,\r\ntg3_flag(tp, WOL_ENABLE));\r\nelse\r\ndevice_set_wakeup_capable(&tp->pdev->dev, false);\r\n}\r\nstatic int tg3_ape_otp_read(struct tg3 *tp, u32 offset, u32 *val)\r\n{\r\nint i, err;\r\nu32 val2, off = offset * 8;\r\nerr = tg3_nvram_lock(tp);\r\nif (err)\r\nreturn err;\r\ntg3_ape_write32(tp, TG3_APE_OTP_ADDR, off | APE_OTP_ADDR_CPU_ENABLE);\r\ntg3_ape_write32(tp, TG3_APE_OTP_CTRL, APE_OTP_CTRL_PROG_EN |\r\nAPE_OTP_CTRL_CMD_RD | APE_OTP_CTRL_START);\r\ntg3_ape_read32(tp, TG3_APE_OTP_CTRL);\r\nudelay(10);\r\nfor (i = 0; i < 100; i++) {\r\nval2 = tg3_ape_read32(tp, TG3_APE_OTP_STATUS);\r\nif (val2 & APE_OTP_STATUS_CMD_DONE) {\r\n*val = tg3_ape_read32(tp, TG3_APE_OTP_RD_DATA);\r\nbreak;\r\n}\r\nudelay(10);\r\n}\r\ntg3_ape_write32(tp, TG3_APE_OTP_CTRL, 0);\r\ntg3_nvram_unlock(tp);\r\nif (val2 & APE_OTP_STATUS_CMD_DONE)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int tg3_issue_otp_command(struct tg3 *tp, u32 cmd)\r\n{\r\nint i;\r\nu32 val;\r\ntw32(OTP_CTRL, cmd | OTP_CTRL_OTP_CMD_START);\r\ntw32(OTP_CTRL, cmd);\r\nfor (i = 0; i < 100; i++) {\r\nval = tr32(OTP_STATUS);\r\nif (val & OTP_STATUS_CMD_DONE)\r\nbreak;\r\nudelay(10);\r\n}\r\nreturn (val & OTP_STATUS_CMD_DONE) ? 0 : -EBUSY;\r\n}\r\nstatic u32 tg3_read_otp_phycfg(struct tg3 *tp)\r\n{\r\nu32 bhalf_otp, thalf_otp;\r\ntw32(OTP_MODE, OTP_MODE_OTP_THRU_GRC);\r\nif (tg3_issue_otp_command(tp, OTP_CTRL_OTP_CMD_INIT))\r\nreturn 0;\r\ntw32(OTP_ADDRESS, OTP_ADDRESS_MAGIC1);\r\nif (tg3_issue_otp_command(tp, OTP_CTRL_OTP_CMD_READ))\r\nreturn 0;\r\nthalf_otp = tr32(OTP_READ_DATA);\r\ntw32(OTP_ADDRESS, OTP_ADDRESS_MAGIC2);\r\nif (tg3_issue_otp_command(tp, OTP_CTRL_OTP_CMD_READ))\r\nreturn 0;\r\nbhalf_otp = tr32(OTP_READ_DATA);\r\nreturn ((thalf_otp & 0x0000ffff) << 16) | (bhalf_otp >> 16);\r\n}\r\nstatic void tg3_phy_init_link_config(struct tg3 *tp)\r\n{\r\nu32 adv = ADVERTISED_Autoneg;\r\nif (!(tp->phy_flags & TG3_PHYFLG_10_100_ONLY)) {\r\nif (!(tp->phy_flags & TG3_PHYFLG_DISABLE_1G_HD_ADV))\r\nadv |= ADVERTISED_1000baseT_Half;\r\nadv |= ADVERTISED_1000baseT_Full;\r\n}\r\nif (!(tp->phy_flags & TG3_PHYFLG_ANY_SERDES))\r\nadv |= ADVERTISED_100baseT_Half |\r\nADVERTISED_100baseT_Full |\r\nADVERTISED_10baseT_Half |\r\nADVERTISED_10baseT_Full |\r\nADVERTISED_TP;\r\nelse\r\nadv |= ADVERTISED_FIBRE;\r\ntp->link_config.advertising = adv;\r\ntp->link_config.speed = SPEED_UNKNOWN;\r\ntp->link_config.duplex = DUPLEX_UNKNOWN;\r\ntp->link_config.autoneg = AUTONEG_ENABLE;\r\ntp->link_config.active_speed = SPEED_UNKNOWN;\r\ntp->link_config.active_duplex = DUPLEX_UNKNOWN;\r\ntp->old_link = -1;\r\n}\r\nstatic int tg3_phy_probe(struct tg3 *tp)\r\n{\r\nu32 hw_phy_id_1, hw_phy_id_2;\r\nu32 hw_phy_id, hw_phy_id_masked;\r\nint err;\r\ntg3_flag_set(tp, PAUSE_AUTONEG);\r\ntp->link_config.flowctrl = FLOW_CTRL_TX | FLOW_CTRL_RX;\r\nif (tg3_flag(tp, ENABLE_APE)) {\r\nswitch (tp->pci_fn) {\r\ncase 0:\r\ntp->phy_ape_lock = TG3_APE_LOCK_PHY0;\r\nbreak;\r\ncase 1:\r\ntp->phy_ape_lock = TG3_APE_LOCK_PHY1;\r\nbreak;\r\ncase 2:\r\ntp->phy_ape_lock = TG3_APE_LOCK_PHY2;\r\nbreak;\r\ncase 3:\r\ntp->phy_ape_lock = TG3_APE_LOCK_PHY3;\r\nbreak;\r\n}\r\n}\r\nif (!tg3_flag(tp, ENABLE_ASF) &&\r\n!(tp->phy_flags & TG3_PHYFLG_ANY_SERDES) &&\r\n!(tp->phy_flags & TG3_PHYFLG_10_100_ONLY))\r\ntp->phy_flags &= ~(TG3_PHYFLG_1G_ON_VAUX_OK |\r\nTG3_PHYFLG_KEEP_LINK_ON_PWRDN);\r\nif (tg3_flag(tp, USE_PHYLIB))\r\nreturn tg3_phy_init(tp);\r\nerr = 0;\r\nif (tg3_flag(tp, ENABLE_ASF) || tg3_flag(tp, ENABLE_APE)) {\r\nhw_phy_id = hw_phy_id_masked = TG3_PHY_ID_INVALID;\r\n} else {\r\nerr |= tg3_readphy(tp, MII_PHYSID1, &hw_phy_id_1);\r\nerr |= tg3_readphy(tp, MII_PHYSID2, &hw_phy_id_2);\r\nhw_phy_id = (hw_phy_id_1 & 0xffff) << 10;\r\nhw_phy_id |= (hw_phy_id_2 & 0xfc00) << 16;\r\nhw_phy_id |= (hw_phy_id_2 & 0x03ff) << 0;\r\nhw_phy_id_masked = hw_phy_id & TG3_PHY_ID_MASK;\r\n}\r\nif (!err && TG3_KNOWN_PHY_ID(hw_phy_id_masked)) {\r\ntp->phy_id = hw_phy_id;\r\nif (hw_phy_id_masked == TG3_PHY_ID_BCM8002)\r\ntp->phy_flags |= TG3_PHYFLG_PHY_SERDES;\r\nelse\r\ntp->phy_flags &= ~TG3_PHYFLG_PHY_SERDES;\r\n} else {\r\nif (tp->phy_id != TG3_PHY_ID_INVALID) {\r\n} else {\r\nstruct subsys_tbl_ent *p;\r\np = tg3_lookup_by_subsys(tp);\r\nif (p) {\r\ntp->phy_id = p->phy_id;\r\n} else if (!tg3_flag(tp, IS_SSB_CORE)) {\r\nreturn -ENODEV;\r\n}\r\nif (!tp->phy_id ||\r\ntp->phy_id == TG3_PHY_ID_BCM8002)\r\ntp->phy_flags |= TG3_PHYFLG_PHY_SERDES;\r\n}\r\n}\r\nif (!(tp->phy_flags & TG3_PHYFLG_ANY_SERDES) &&\r\n(tg3_asic_rev(tp) == ASIC_REV_5719 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5720 ||\r\ntg3_asic_rev(tp) == ASIC_REV_57766 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5762 ||\r\n(tg3_asic_rev(tp) == ASIC_REV_5717 &&\r\ntg3_chip_rev_id(tp) != CHIPREV_ID_5717_A0) ||\r\n(tg3_asic_rev(tp) == ASIC_REV_57765 &&\r\ntg3_chip_rev_id(tp) != CHIPREV_ID_57765_A0))) {\r\ntp->phy_flags |= TG3_PHYFLG_EEE_CAP;\r\ntp->eee.supported = SUPPORTED_100baseT_Full |\r\nSUPPORTED_1000baseT_Full;\r\ntp->eee.advertised = ADVERTISED_100baseT_Full |\r\nADVERTISED_1000baseT_Full;\r\ntp->eee.eee_enabled = 1;\r\ntp->eee.tx_lpi_enabled = 1;\r\ntp->eee.tx_lpi_timer = TG3_CPMU_DBTMR1_LNKIDLE_2047US;\r\n}\r\ntg3_phy_init_link_config(tp);\r\nif (!(tp->phy_flags & TG3_PHYFLG_KEEP_LINK_ON_PWRDN) &&\r\n!(tp->phy_flags & TG3_PHYFLG_ANY_SERDES) &&\r\n!tg3_flag(tp, ENABLE_APE) &&\r\n!tg3_flag(tp, ENABLE_ASF)) {\r\nu32 bmsr, dummy;\r\ntg3_readphy(tp, MII_BMSR, &bmsr);\r\nif (!tg3_readphy(tp, MII_BMSR, &bmsr) &&\r\n(bmsr & BMSR_LSTATUS))\r\ngoto skip_phy_reset;\r\nerr = tg3_phy_reset(tp);\r\nif (err)\r\nreturn err;\r\ntg3_phy_set_wirespeed(tp);\r\nif (!tg3_phy_copper_an_config_ok(tp, &dummy)) {\r\ntg3_phy_autoneg_cfg(tp, tp->link_config.advertising,\r\ntp->link_config.flowctrl);\r\ntg3_writephy(tp, MII_BMCR,\r\nBMCR_ANENABLE | BMCR_ANRESTART);\r\n}\r\n}\r\nskip_phy_reset:\r\nif ((tp->phy_id & TG3_PHY_ID_MASK) == TG3_PHY_ID_BCM5401) {\r\nerr = tg3_init_5401phy_dsp(tp);\r\nif (err)\r\nreturn err;\r\nerr = tg3_init_5401phy_dsp(tp);\r\n}\r\nreturn err;\r\n}\r\nstatic void tg3_read_vpd(struct tg3 *tp)\r\n{\r\nu8 *vpd_data;\r\nunsigned int block_end, rosize, len;\r\nu32 vpdlen;\r\nint j, i = 0;\r\nvpd_data = (u8 *)tg3_vpd_readblock(tp, &vpdlen);\r\nif (!vpd_data)\r\ngoto out_no_vpd;\r\ni = pci_vpd_find_tag(vpd_data, 0, vpdlen, PCI_VPD_LRDT_RO_DATA);\r\nif (i < 0)\r\ngoto out_not_found;\r\nrosize = pci_vpd_lrdt_size(&vpd_data[i]);\r\nblock_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize;\r\ni += PCI_VPD_LRDT_TAG_SIZE;\r\nif (block_end > vpdlen)\r\ngoto out_not_found;\r\nj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\r\nPCI_VPD_RO_KEYWORD_MFR_ID);\r\nif (j > 0) {\r\nlen = pci_vpd_info_field_size(&vpd_data[j]);\r\nj += PCI_VPD_INFO_FLD_HDR_SIZE;\r\nif (j + len > block_end || len != 4 ||\r\nmemcmp(&vpd_data[j], "1028", 4))\r\ngoto partno;\r\nj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\r\nPCI_VPD_RO_KEYWORD_VENDOR0);\r\nif (j < 0)\r\ngoto partno;\r\nlen = pci_vpd_info_field_size(&vpd_data[j]);\r\nj += PCI_VPD_INFO_FLD_HDR_SIZE;\r\nif (j + len > block_end)\r\ngoto partno;\r\nif (len >= sizeof(tp->fw_ver))\r\nlen = sizeof(tp->fw_ver) - 1;\r\nmemset(tp->fw_ver, 0, sizeof(tp->fw_ver));\r\nsnprintf(tp->fw_ver, sizeof(tp->fw_ver), "%.*s bc ", len,\r\n&vpd_data[j]);\r\n}\r\npartno:\r\ni = pci_vpd_find_info_keyword(vpd_data, i, rosize,\r\nPCI_VPD_RO_KEYWORD_PARTNO);\r\nif (i < 0)\r\ngoto out_not_found;\r\nlen = pci_vpd_info_field_size(&vpd_data[i]);\r\ni += PCI_VPD_INFO_FLD_HDR_SIZE;\r\nif (len > TG3_BPN_SIZE ||\r\n(len + i) > vpdlen)\r\ngoto out_not_found;\r\nmemcpy(tp->board_part_number, &vpd_data[i], len);\r\nout_not_found:\r\nkfree(vpd_data);\r\nif (tp->board_part_number[0])\r\nreturn;\r\nout_no_vpd:\r\nif (tg3_asic_rev(tp) == ASIC_REV_5717) {\r\nif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5717_C)\r\nstrcpy(tp->board_part_number, "BCM5717");\r\nelse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5718)\r\nstrcpy(tp->board_part_number, "BCM5718");\r\nelse\r\ngoto nomatch;\r\n} else if (tg3_asic_rev(tp) == ASIC_REV_57780) {\r\nif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57780)\r\nstrcpy(tp->board_part_number, "BCM57780");\r\nelse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57760)\r\nstrcpy(tp->board_part_number, "BCM57760");\r\nelse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57790)\r\nstrcpy(tp->board_part_number, "BCM57790");\r\nelse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57788)\r\nstrcpy(tp->board_part_number, "BCM57788");\r\nelse\r\ngoto nomatch;\r\n} else if (tg3_asic_rev(tp) == ASIC_REV_57765) {\r\nif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57761)\r\nstrcpy(tp->board_part_number, "BCM57761");\r\nelse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57765)\r\nstrcpy(tp->board_part_number, "BCM57765");\r\nelse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57781)\r\nstrcpy(tp->board_part_number, "BCM57781");\r\nelse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57785)\r\nstrcpy(tp->board_part_number, "BCM57785");\r\nelse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57791)\r\nstrcpy(tp->board_part_number, "BCM57791");\r\nelse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57795)\r\nstrcpy(tp->board_part_number, "BCM57795");\r\nelse\r\ngoto nomatch;\r\n} else if (tg3_asic_rev(tp) == ASIC_REV_57766) {\r\nif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57762)\r\nstrcpy(tp->board_part_number, "BCM57762");\r\nelse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57766)\r\nstrcpy(tp->board_part_number, "BCM57766");\r\nelse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57782)\r\nstrcpy(tp->board_part_number, "BCM57782");\r\nelse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57786)\r\nstrcpy(tp->board_part_number, "BCM57786");\r\nelse\r\ngoto nomatch;\r\n} else if (tg3_asic_rev(tp) == ASIC_REV_5906) {\r\nstrcpy(tp->board_part_number, "BCM95906");\r\n} else {\r\nnomatch:\r\nstrcpy(tp->board_part_number, "none");\r\n}\r\n}\r\nstatic int tg3_fw_img_is_valid(struct tg3 *tp, u32 offset)\r\n{\r\nu32 val;\r\nif (tg3_nvram_read(tp, offset, &val) ||\r\n(val & 0xfc000000) != 0x0c000000 ||\r\ntg3_nvram_read(tp, offset + 4, &val) ||\r\nval != 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void tg3_read_bc_ver(struct tg3 *tp)\r\n{\r\nu32 val, offset, start, ver_offset;\r\nint i, dst_off;\r\nbool newver = false;\r\nif (tg3_nvram_read(tp, 0xc, &offset) ||\r\ntg3_nvram_read(tp, 0x4, &start))\r\nreturn;\r\noffset = tg3_nvram_logical_addr(tp, offset);\r\nif (tg3_nvram_read(tp, offset, &val))\r\nreturn;\r\nif ((val & 0xfc000000) == 0x0c000000) {\r\nif (tg3_nvram_read(tp, offset + 4, &val))\r\nreturn;\r\nif (val == 0)\r\nnewver = true;\r\n}\r\ndst_off = strlen(tp->fw_ver);\r\nif (newver) {\r\nif (TG3_VER_SIZE - dst_off < 16 ||\r\ntg3_nvram_read(tp, offset + 8, &ver_offset))\r\nreturn;\r\noffset = offset + ver_offset - start;\r\nfor (i = 0; i < 16; i += 4) {\r\n__be32 v;\r\nif (tg3_nvram_read_be32(tp, offset + i, &v))\r\nreturn;\r\nmemcpy(tp->fw_ver + dst_off + i, &v, sizeof(v));\r\n}\r\n} else {\r\nu32 major, minor;\r\nif (tg3_nvram_read(tp, TG3_NVM_PTREV_BCVER, &ver_offset))\r\nreturn;\r\nmajor = (ver_offset & TG3_NVM_BCVER_MAJMSK) >>\r\nTG3_NVM_BCVER_MAJSFT;\r\nminor = ver_offset & TG3_NVM_BCVER_MINMSK;\r\nsnprintf(&tp->fw_ver[dst_off], TG3_VER_SIZE - dst_off,\r\n"v%d.%02d", major, minor);\r\n}\r\n}\r\nstatic void tg3_read_hwsb_ver(struct tg3 *tp)\r\n{\r\nu32 val, major, minor;\r\nif (tg3_nvram_read(tp, TG3_NVM_HWSB_CFG1, &val))\r\nreturn;\r\nmajor = (val & TG3_NVM_HWSB_CFG1_MAJMSK) >>\r\nTG3_NVM_HWSB_CFG1_MAJSFT;\r\nminor = (val & TG3_NVM_HWSB_CFG1_MINMSK) >>\r\nTG3_NVM_HWSB_CFG1_MINSFT;\r\nsnprintf(&tp->fw_ver[0], 32, "sb v%d.%02d", major, minor);\r\n}\r\nstatic void tg3_read_sb_ver(struct tg3 *tp, u32 val)\r\n{\r\nu32 offset, major, minor, build;\r\nstrncat(tp->fw_ver, "sb", TG3_VER_SIZE - strlen(tp->fw_ver) - 1);\r\nif ((val & TG3_EEPROM_SB_FORMAT_MASK) != TG3_EEPROM_SB_FORMAT_1)\r\nreturn;\r\nswitch (val & TG3_EEPROM_SB_REVISION_MASK) {\r\ncase TG3_EEPROM_SB_REVISION_0:\r\noffset = TG3_EEPROM_SB_F1R0_EDH_OFF;\r\nbreak;\r\ncase TG3_EEPROM_SB_REVISION_2:\r\noffset = TG3_EEPROM_SB_F1R2_EDH_OFF;\r\nbreak;\r\ncase TG3_EEPROM_SB_REVISION_3:\r\noffset = TG3_EEPROM_SB_F1R3_EDH_OFF;\r\nbreak;\r\ncase TG3_EEPROM_SB_REVISION_4:\r\noffset = TG3_EEPROM_SB_F1R4_EDH_OFF;\r\nbreak;\r\ncase TG3_EEPROM_SB_REVISION_5:\r\noffset = TG3_EEPROM_SB_F1R5_EDH_OFF;\r\nbreak;\r\ncase TG3_EEPROM_SB_REVISION_6:\r\noffset = TG3_EEPROM_SB_F1R6_EDH_OFF;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (tg3_nvram_read(tp, offset, &val))\r\nreturn;\r\nbuild = (val & TG3_EEPROM_SB_EDH_BLD_MASK) >>\r\nTG3_EEPROM_SB_EDH_BLD_SHFT;\r\nmajor = (val & TG3_EEPROM_SB_EDH_MAJ_MASK) >>\r\nTG3_EEPROM_SB_EDH_MAJ_SHFT;\r\nminor = val & TG3_EEPROM_SB_EDH_MIN_MASK;\r\nif (minor > 99 || build > 26)\r\nreturn;\r\noffset = strlen(tp->fw_ver);\r\nsnprintf(&tp->fw_ver[offset], TG3_VER_SIZE - offset,\r\n" v%d.%02d", major, minor);\r\nif (build > 0) {\r\noffset = strlen(tp->fw_ver);\r\nif (offset < TG3_VER_SIZE - 1)\r\ntp->fw_ver[offset] = 'a' + build - 1;\r\n}\r\n}\r\nstatic void tg3_read_mgmtfw_ver(struct tg3 *tp)\r\n{\r\nu32 val, offset, start;\r\nint i, vlen;\r\nfor (offset = TG3_NVM_DIR_START;\r\noffset < TG3_NVM_DIR_END;\r\noffset += TG3_NVM_DIRENT_SIZE) {\r\nif (tg3_nvram_read(tp, offset, &val))\r\nreturn;\r\nif ((val >> TG3_NVM_DIRTYPE_SHIFT) == TG3_NVM_DIRTYPE_ASFINI)\r\nbreak;\r\n}\r\nif (offset == TG3_NVM_DIR_END)\r\nreturn;\r\nif (!tg3_flag(tp, 5705_PLUS))\r\nstart = 0x08000000;\r\nelse if (tg3_nvram_read(tp, offset - 4, &start))\r\nreturn;\r\nif (tg3_nvram_read(tp, offset + 4, &offset) ||\r\n!tg3_fw_img_is_valid(tp, offset) ||\r\ntg3_nvram_read(tp, offset + 8, &val))\r\nreturn;\r\noffset += val - start;\r\nvlen = strlen(tp->fw_ver);\r\ntp->fw_ver[vlen++] = ',';\r\ntp->fw_ver[vlen++] = ' ';\r\nfor (i = 0; i < 4; i++) {\r\n__be32 v;\r\nif (tg3_nvram_read_be32(tp, offset, &v))\r\nreturn;\r\noffset += sizeof(v);\r\nif (vlen > TG3_VER_SIZE - sizeof(v)) {\r\nmemcpy(&tp->fw_ver[vlen], &v, TG3_VER_SIZE - vlen);\r\nbreak;\r\n}\r\nmemcpy(&tp->fw_ver[vlen], &v, sizeof(v));\r\nvlen += sizeof(v);\r\n}\r\n}\r\nstatic void tg3_probe_ncsi(struct tg3 *tp)\r\n{\r\nu32 apedata;\r\napedata = tg3_ape_read32(tp, TG3_APE_SEG_SIG);\r\nif (apedata != APE_SEG_SIG_MAGIC)\r\nreturn;\r\napedata = tg3_ape_read32(tp, TG3_APE_FW_STATUS);\r\nif (!(apedata & APE_FW_STATUS_READY))\r\nreturn;\r\nif (tg3_ape_read32(tp, TG3_APE_FW_FEATURES) & TG3_APE_FW_FEATURE_NCSI)\r\ntg3_flag_set(tp, APE_HAS_NCSI);\r\n}\r\nstatic void tg3_read_dash_ver(struct tg3 *tp)\r\n{\r\nint vlen;\r\nu32 apedata;\r\nchar *fwtype;\r\napedata = tg3_ape_read32(tp, TG3_APE_FW_VERSION);\r\nif (tg3_flag(tp, APE_HAS_NCSI))\r\nfwtype = "NCSI";\r\nelse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5725)\r\nfwtype = "SMASH";\r\nelse\r\nfwtype = "DASH";\r\nvlen = strlen(tp->fw_ver);\r\nsnprintf(&tp->fw_ver[vlen], TG3_VER_SIZE - vlen, " %s v%d.%d.%d.%d",\r\nfwtype,\r\n(apedata & APE_FW_VERSION_MAJMSK) >> APE_FW_VERSION_MAJSFT,\r\n(apedata & APE_FW_VERSION_MINMSK) >> APE_FW_VERSION_MINSFT,\r\n(apedata & APE_FW_VERSION_REVMSK) >> APE_FW_VERSION_REVSFT,\r\n(apedata & APE_FW_VERSION_BLDMSK));\r\n}\r\nstatic void tg3_read_otp_ver(struct tg3 *tp)\r\n{\r\nu32 val, val2;\r\nif (tg3_asic_rev(tp) != ASIC_REV_5762)\r\nreturn;\r\nif (!tg3_ape_otp_read(tp, OTP_ADDRESS_MAGIC0, &val) &&\r\n!tg3_ape_otp_read(tp, OTP_ADDRESS_MAGIC0 + 4, &val2) &&\r\nTG3_OTP_MAGIC0_VALID(val)) {\r\nu64 val64 = (u64) val << 32 | val2;\r\nu32 ver = 0;\r\nint i, vlen;\r\nfor (i = 0; i < 7; i++) {\r\nif ((val64 & 0xff) == 0)\r\nbreak;\r\nver = val64 & 0xff;\r\nval64 >>= 8;\r\n}\r\nvlen = strlen(tp->fw_ver);\r\nsnprintf(&tp->fw_ver[vlen], TG3_VER_SIZE - vlen, " .%02d", ver);\r\n}\r\n}\r\nstatic void tg3_read_fw_ver(struct tg3 *tp)\r\n{\r\nu32 val;\r\nbool vpd_vers = false;\r\nif (tp->fw_ver[0] != 0)\r\nvpd_vers = true;\r\nif (tg3_flag(tp, NO_NVRAM)) {\r\nstrcat(tp->fw_ver, "sb");\r\ntg3_read_otp_ver(tp);\r\nreturn;\r\n}\r\nif (tg3_nvram_read(tp, 0, &val))\r\nreturn;\r\nif (val == TG3_EEPROM_MAGIC)\r\ntg3_read_bc_ver(tp);\r\nelse if ((val & TG3_EEPROM_MAGIC_FW_MSK) == TG3_EEPROM_MAGIC_FW)\r\ntg3_read_sb_ver(tp, val);\r\nelse if ((val & TG3_EEPROM_MAGIC_HW_MSK) == TG3_EEPROM_MAGIC_HW)\r\ntg3_read_hwsb_ver(tp);\r\nif (tg3_flag(tp, ENABLE_ASF)) {\r\nif (tg3_flag(tp, ENABLE_APE)) {\r\ntg3_probe_ncsi(tp);\r\nif (!vpd_vers)\r\ntg3_read_dash_ver(tp);\r\n} else if (!vpd_vers) {\r\ntg3_read_mgmtfw_ver(tp);\r\n}\r\n}\r\ntp->fw_ver[TG3_VER_SIZE - 1] = 0;\r\n}\r\nstatic inline u32 tg3_rx_ret_ring_size(struct tg3 *tp)\r\n{\r\nif (tg3_flag(tp, LRG_PROD_RING_CAP))\r\nreturn TG3_RX_RET_MAX_SIZE_5717;\r\nelse if (tg3_flag(tp, JUMBO_CAPABLE) && !tg3_flag(tp, 5780_CLASS))\r\nreturn TG3_RX_RET_MAX_SIZE_5700;\r\nelse\r\nreturn TG3_RX_RET_MAX_SIZE_5705;\r\n}\r\nstatic struct pci_dev *tg3_find_peer(struct tg3 *tp)\r\n{\r\nstruct pci_dev *peer;\r\nunsigned int func, devnr = tp->pdev->devfn & ~7;\r\nfor (func = 0; func < 8; func++) {\r\npeer = pci_get_slot(tp->pdev->bus, devnr | func);\r\nif (peer && peer != tp->pdev)\r\nbreak;\r\npci_dev_put(peer);\r\n}\r\nif (!peer) {\r\npeer = tp->pdev;\r\nreturn peer;\r\n}\r\npci_dev_put(peer);\r\nreturn peer;\r\n}\r\nstatic void tg3_detect_asic_rev(struct tg3 *tp, u32 misc_ctrl_reg)\r\n{\r\ntp->pci_chip_rev_id = misc_ctrl_reg >> MISC_HOST_CTRL_CHIPREV_SHIFT;\r\nif (tg3_asic_rev(tp) == ASIC_REV_USE_PROD_ID_REG) {\r\nu32 reg;\r\ntg3_flag_set(tp, CPMU_PRESENT);\r\nif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5717_C ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5718 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5719 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5720 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_57767 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_57764 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5762 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5725 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5727 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_57787)\r\nreg = TG3PCI_GEN2_PRODID_ASICREV;\r\nelse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57781 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_57785 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_57761 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_57765 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_57791 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_57795 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_57762 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_57766 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_57782 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_57786)\r\nreg = TG3PCI_GEN15_PRODID_ASICREV;\r\nelse\r\nreg = TG3PCI_PRODID_ASICREV;\r\npci_read_config_dword(tp->pdev, reg, &tp->pci_chip_rev_id);\r\n}\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5752_A0_HW)\r\ntp->pci_chip_rev_id = CHIPREV_ID_5752_A0;\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5717_C0)\r\ntp->pci_chip_rev_id = CHIPREV_ID_5720_A0;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5719 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5720)\r\ntg3_flag_set(tp, 5717_PLUS);\r\nif (tg3_asic_rev(tp) == ASIC_REV_57765 ||\r\ntg3_asic_rev(tp) == ASIC_REV_57766)\r\ntg3_flag_set(tp, 57765_CLASS);\r\nif (tg3_flag(tp, 57765_CLASS) || tg3_flag(tp, 5717_PLUS) ||\r\ntg3_asic_rev(tp) == ASIC_REV_5762)\r\ntg3_flag_set(tp, 57765_PLUS);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5755 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5787 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5784 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5761 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5785 ||\r\ntg3_asic_rev(tp) == ASIC_REV_57780 ||\r\ntg3_flag(tp, 57765_PLUS))\r\ntg3_flag_set(tp, 5755_PLUS);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5780 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5714)\r\ntg3_flag_set(tp, 5780_CLASS);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5750 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5752 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5906 ||\r\ntg3_flag(tp, 5755_PLUS) ||\r\ntg3_flag(tp, 5780_CLASS))\r\ntg3_flag_set(tp, 5750_PLUS);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5705 ||\r\ntg3_flag(tp, 5750_PLUS))\r\ntg3_flag_set(tp, 5705_PLUS);\r\n}\r\nstatic bool tg3_10_100_only_device(struct tg3 *tp,\r\nconst struct pci_device_id *ent)\r\n{\r\nu32 grc_misc_cfg = tr32(GRC_MISC_CFG) & GRC_MISC_CFG_BOARD_ID_MASK;\r\nif ((tg3_asic_rev(tp) == ASIC_REV_5703 &&\r\n(grc_misc_cfg == 0x8000 || grc_misc_cfg == 0x4000)) ||\r\n(tp->phy_flags & TG3_PHYFLG_IS_FET))\r\nreturn true;\r\nif (ent->driver_data & TG3_DRV_DATA_FLAG_10_100_ONLY) {\r\nif (tg3_asic_rev(tp) == ASIC_REV_5705) {\r\nif (ent->driver_data & TG3_DRV_DATA_FLAG_5705_10_100)\r\nreturn true;\r\n} else {\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic int tg3_get_invariants(struct tg3 *tp, const struct pci_device_id *ent)\r\n{\r\nu32 misc_ctrl_reg;\r\nu32 pci_state_reg, grc_misc_cfg;\r\nu32 val;\r\nu16 pci_cmd;\r\nint err;\r\npci_read_config_word(tp->pdev, PCI_COMMAND, &pci_cmd);\r\npci_cmd &= ~PCI_COMMAND_INVALIDATE;\r\npci_write_config_word(tp->pdev, PCI_COMMAND, pci_cmd);\r\npci_read_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,\r\n&misc_ctrl_reg);\r\ntp->misc_host_ctrl |= (misc_ctrl_reg &\r\nMISC_HOST_CTRL_CHIPREV);\r\npci_write_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,\r\ntp->misc_host_ctrl);\r\ntg3_detect_asic_rev(tp, misc_ctrl_reg);\r\nif ((tg3_chip_rev_id(tp) == CHIPREV_ID_5703_A1) ||\r\n(tg3_chip_rev_id(tp) == CHIPREV_ID_5703_A2)) {\r\nstatic struct tg3_dev_id {\r\nu32 vendor;\r\nu32 device;\r\nu32 rev;\r\n} ich_chipsets[] = {\r\n{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801AA_8,\r\nPCI_ANY_ID },\r\n{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801AB_8,\r\nPCI_ANY_ID },\r\n{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801BA_11,\r\n0xa },\r\n{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801BA_6,\r\nPCI_ANY_ID },\r\n{ },\r\n};\r\nstruct tg3_dev_id *pci_id = &ich_chipsets[0];\r\nstruct pci_dev *bridge = NULL;\r\nwhile (pci_id->vendor != 0) {\r\nbridge = pci_get_device(pci_id->vendor, pci_id->device,\r\nbridge);\r\nif (!bridge) {\r\npci_id++;\r\ncontinue;\r\n}\r\nif (pci_id->rev != PCI_ANY_ID) {\r\nif (bridge->revision > pci_id->rev)\r\ncontinue;\r\n}\r\nif (bridge->subordinate &&\r\n(bridge->subordinate->number ==\r\ntp->pdev->bus->number)) {\r\ntg3_flag_set(tp, ICH_WORKAROUND);\r\npci_dev_put(bridge);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5701) {\r\nstatic struct tg3_dev_id {\r\nu32 vendor;\r\nu32 device;\r\n} bridge_chipsets[] = {\r\n{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_PXH_0 },\r\n{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_PXH_1 },\r\n{ },\r\n};\r\nstruct tg3_dev_id *pci_id = &bridge_chipsets[0];\r\nstruct pci_dev *bridge = NULL;\r\nwhile (pci_id->vendor != 0) {\r\nbridge = pci_get_device(pci_id->vendor,\r\npci_id->device,\r\nbridge);\r\nif (!bridge) {\r\npci_id++;\r\ncontinue;\r\n}\r\nif (bridge->subordinate &&\r\n(bridge->subordinate->number <=\r\ntp->pdev->bus->number) &&\r\n(bridge->subordinate->busn_res.end >=\r\ntp->pdev->bus->number)) {\r\ntg3_flag_set(tp, 5701_DMA_BUG);\r\npci_dev_put(bridge);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (tg3_flag(tp, 5780_CLASS)) {\r\ntg3_flag_set(tp, 40BIT_DMA_BUG);\r\ntp->msi_cap = tp->pdev->msi_cap;\r\n} else {\r\nstruct pci_dev *bridge = NULL;\r\ndo {\r\nbridge = pci_get_device(PCI_VENDOR_ID_SERVERWORKS,\r\nPCI_DEVICE_ID_SERVERWORKS_EPB,\r\nbridge);\r\nif (bridge && bridge->subordinate &&\r\n(bridge->subordinate->number <=\r\ntp->pdev->bus->number) &&\r\n(bridge->subordinate->busn_res.end >=\r\ntp->pdev->bus->number)) {\r\ntg3_flag_set(tp, 40BIT_DMA_BUG);\r\npci_dev_put(bridge);\r\nbreak;\r\n}\r\n} while (bridge);\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5704 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5714)\r\ntp->pdev_peer = tg3_find_peer(tp);\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5719_A0)\r\n;\r\nelse if (tg3_flag(tp, 57765_PLUS))\r\ntg3_flag_set(tp, HW_TSO_3);\r\nelse if (tg3_flag(tp, 5755_PLUS) ||\r\ntg3_asic_rev(tp) == ASIC_REV_5906)\r\ntg3_flag_set(tp, HW_TSO_2);\r\nelse if (tg3_flag(tp, 5750_PLUS)) {\r\ntg3_flag_set(tp, HW_TSO_1);\r\ntg3_flag_set(tp, TSO_BUG);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5750 &&\r\ntg3_chip_rev_id(tp) >= CHIPREV_ID_5750_C2)\r\ntg3_flag_clear(tp, TSO_BUG);\r\n} else if (tg3_asic_rev(tp) != ASIC_REV_5700 &&\r\ntg3_asic_rev(tp) != ASIC_REV_5701 &&\r\ntg3_chip_rev_id(tp) != CHIPREV_ID_5705_A0) {\r\ntg3_flag_set(tp, FW_TSO);\r\ntg3_flag_set(tp, TSO_BUG);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5705)\r\ntp->fw_needed = FIRMWARE_TG3TSO5;\r\nelse\r\ntp->fw_needed = FIRMWARE_TG3TSO;\r\n}\r\nif (tg3_flag(tp, HW_TSO_1) ||\r\ntg3_flag(tp, HW_TSO_2) ||\r\ntg3_flag(tp, HW_TSO_3) ||\r\ntg3_flag(tp, FW_TSO)) {\r\ntg3_flag_set(tp, TSO_CAPABLE);\r\n} else {\r\ntg3_flag_clear(tp, TSO_CAPABLE);\r\ntg3_flag_clear(tp, TSO_BUG);\r\ntp->fw_needed = NULL;\r\n}\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5701_A0)\r\ntp->fw_needed = FIRMWARE_TG3;\r\nif (tg3_asic_rev(tp) == ASIC_REV_57766)\r\ntp->fw_needed = FIRMWARE_TG357766;\r\ntp->irq_max = 1;\r\nif (tg3_flag(tp, 5750_PLUS)) {\r\ntg3_flag_set(tp, SUPPORT_MSI);\r\nif (tg3_chip_rev(tp) == CHIPREV_5750_AX ||\r\ntg3_chip_rev(tp) == CHIPREV_5750_BX ||\r\n(tg3_asic_rev(tp) == ASIC_REV_5714 &&\r\ntg3_chip_rev_id(tp) <= CHIPREV_ID_5714_A2 &&\r\ntp->pdev_peer == tp->pdev))\r\ntg3_flag_clear(tp, SUPPORT_MSI);\r\nif (tg3_flag(tp, 5755_PLUS) ||\r\ntg3_asic_rev(tp) == ASIC_REV_5906) {\r\ntg3_flag_set(tp, 1SHOT_MSI);\r\n}\r\nif (tg3_flag(tp, 57765_PLUS)) {\r\ntg3_flag_set(tp, SUPPORT_MSIX);\r\ntp->irq_max = TG3_IRQ_MAX_VECS;\r\n}\r\n}\r\ntp->txq_max = 1;\r\ntp->rxq_max = 1;\r\nif (tp->irq_max > 1) {\r\ntp->rxq_max = TG3_RSS_MAX_NUM_QS;\r\ntg3_rss_init_dflt_indir_tbl(tp, TG3_RSS_MAX_NUM_QS);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5719 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5720)\r\ntp->txq_max = tp->irq_max - 1;\r\n}\r\nif (tg3_flag(tp, 5755_PLUS) ||\r\ntg3_asic_rev(tp) == ASIC_REV_5906)\r\ntg3_flag_set(tp, SHORT_DMA_BUG);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5719)\r\ntp->dma_limit = TG3_TX_BD_DMA_MAX_4K;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5719 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5720 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5762)\r\ntg3_flag_set(tp, LRG_PROD_RING_CAP);\r\nif (tg3_flag(tp, 57765_PLUS) &&\r\ntg3_chip_rev_id(tp) != CHIPREV_ID_5719_A0)\r\ntg3_flag_set(tp, USE_JUMBO_BDFLAG);\r\nif (!tg3_flag(tp, 5705_PLUS) ||\r\ntg3_flag(tp, 5780_CLASS) ||\r\ntg3_flag(tp, USE_JUMBO_BDFLAG))\r\ntg3_flag_set(tp, JUMBO_CAPABLE);\r\npci_read_config_dword(tp->pdev, TG3PCI_PCISTATE,\r\n&pci_state_reg);\r\nif (pci_is_pcie(tp->pdev)) {\r\nu16 lnkctl;\r\ntg3_flag_set(tp, PCI_EXPRESS);\r\npcie_capability_read_word(tp->pdev, PCI_EXP_LNKCTL, &lnkctl);\r\nif (lnkctl & PCI_EXP_LNKCTL_CLKREQ_EN) {\r\nif (tg3_asic_rev(tp) == ASIC_REV_5906) {\r\ntg3_flag_clear(tp, HW_TSO_2);\r\ntg3_flag_clear(tp, TSO_CAPABLE);\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5784 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5761 ||\r\ntg3_chip_rev_id(tp) == CHIPREV_ID_57780_A0 ||\r\ntg3_chip_rev_id(tp) == CHIPREV_ID_57780_A1)\r\ntg3_flag_set(tp, CLKREQ_BUG);\r\n} else if (tg3_chip_rev_id(tp) == CHIPREV_ID_5717_A0) {\r\ntg3_flag_set(tp, L1PLLPD_EN);\r\n}\r\n} else if (tg3_asic_rev(tp) == ASIC_REV_5785) {\r\ntg3_flag_set(tp, PCI_EXPRESS);\r\n} else if (!tg3_flag(tp, 5705_PLUS) ||\r\ntg3_flag(tp, 5780_CLASS)) {\r\ntp->pcix_cap = pci_find_capability(tp->pdev, PCI_CAP_ID_PCIX);\r\nif (!tp->pcix_cap) {\r\ndev_err(&tp->pdev->dev,\r\n"Cannot find PCI-X capability, aborting\n");\r\nreturn -EIO;\r\n}\r\nif (!(pci_state_reg & PCISTATE_CONV_PCI_MODE))\r\ntg3_flag_set(tp, PCIX_MODE);\r\n}\r\nif (pci_dev_present(tg3_write_reorder_chipsets) &&\r\n!tg3_flag(tp, PCI_EXPRESS))\r\ntg3_flag_set(tp, MBOX_WRITE_REORDER);\r\npci_read_config_byte(tp->pdev, PCI_CACHE_LINE_SIZE,\r\n&tp->pci_cacheline_sz);\r\npci_read_config_byte(tp->pdev, PCI_LATENCY_TIMER,\r\n&tp->pci_lat_timer);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5703 &&\r\ntp->pci_lat_timer < 64) {\r\ntp->pci_lat_timer = 64;\r\npci_write_config_byte(tp->pdev, PCI_LATENCY_TIMER,\r\ntp->pci_lat_timer);\r\n}\r\nif (tg3_chip_rev(tp) == CHIPREV_5700_BX) {\r\ntg3_flag_set(tp, TXD_MBOX_HWBUG);\r\nif (tg3_flag(tp, PCIX_MODE)) {\r\nu32 pm_reg;\r\ntg3_flag_set(tp, PCIX_TARGET_HWBUG);\r\npci_read_config_dword(tp->pdev,\r\ntp->pdev->pm_cap + PCI_PM_CTRL,\r\n&pm_reg);\r\npm_reg &= ~PCI_PM_CTRL_STATE_MASK;\r\npm_reg |= PCI_PM_CTRL_PME_ENABLE | 0 ;\r\npci_write_config_dword(tp->pdev,\r\ntp->pdev->pm_cap + PCI_PM_CTRL,\r\npm_reg);\r\npci_read_config_word(tp->pdev, PCI_COMMAND, &pci_cmd);\r\npci_cmd |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR;\r\npci_write_config_word(tp->pdev, PCI_COMMAND, pci_cmd);\r\n}\r\n}\r\nif ((pci_state_reg & PCISTATE_BUS_SPEED_HIGH) != 0)\r\ntg3_flag_set(tp, PCI_HIGH_SPEED);\r\nif ((pci_state_reg & PCISTATE_BUS_32BIT) != 0)\r\ntg3_flag_set(tp, PCI_32BIT);\r\nif ((tg3_chip_rev_id(tp) == CHIPREV_ID_5704_A0) &&\r\n(!(pci_state_reg & PCISTATE_RETRY_SAME_DMA))) {\r\npci_state_reg |= PCISTATE_RETRY_SAME_DMA;\r\npci_write_config_dword(tp->pdev, TG3PCI_PCISTATE, pci_state_reg);\r\n}\r\ntp->read32 = tg3_read32;\r\ntp->write32 = tg3_write32;\r\ntp->read32_mbox = tg3_read32;\r\ntp->write32_mbox = tg3_write32;\r\ntp->write32_tx_mbox = tg3_write32;\r\ntp->write32_rx_mbox = tg3_write32;\r\nif (tg3_flag(tp, PCIX_TARGET_HWBUG))\r\ntp->write32 = tg3_write_indirect_reg32;\r\nelse if (tg3_asic_rev(tp) == ASIC_REV_5701 ||\r\n(tg3_flag(tp, PCI_EXPRESS) &&\r\ntg3_chip_rev_id(tp) == CHIPREV_ID_5750_A0)) {\r\ntp->write32 = tg3_write_flush_reg32;\r\n}\r\nif (tg3_flag(tp, TXD_MBOX_HWBUG) || tg3_flag(tp, MBOX_WRITE_REORDER)) {\r\ntp->write32_tx_mbox = tg3_write32_tx_mbox;\r\nif (tg3_flag(tp, MBOX_WRITE_REORDER))\r\ntp->write32_rx_mbox = tg3_write_flush_reg32;\r\n}\r\nif (tg3_flag(tp, ICH_WORKAROUND)) {\r\ntp->read32 = tg3_read_indirect_reg32;\r\ntp->write32 = tg3_write_indirect_reg32;\r\ntp->read32_mbox = tg3_read_indirect_mbox;\r\ntp->write32_mbox = tg3_write_indirect_mbox;\r\ntp->write32_tx_mbox = tg3_write_indirect_mbox;\r\ntp->write32_rx_mbox = tg3_write_indirect_mbox;\r\niounmap(tp->regs);\r\ntp->regs = NULL;\r\npci_read_config_word(tp->pdev, PCI_COMMAND, &pci_cmd);\r\npci_cmd &= ~PCI_COMMAND_MEMORY;\r\npci_write_config_word(tp->pdev, PCI_COMMAND, pci_cmd);\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5906) {\r\ntp->read32_mbox = tg3_read32_mbox_5906;\r\ntp->write32_mbox = tg3_write32_mbox_5906;\r\ntp->write32_tx_mbox = tg3_write32_mbox_5906;\r\ntp->write32_rx_mbox = tg3_write32_mbox_5906;\r\n}\r\nif (tp->write32 == tg3_write_indirect_reg32 ||\r\n(tg3_flag(tp, PCIX_MODE) &&\r\n(tg3_asic_rev(tp) == ASIC_REV_5700 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5701)))\r\ntg3_flag_set(tp, SRAM_USE_CONFIG);\r\nval = tr32(MEMARB_MODE);\r\ntw32(MEMARB_MODE, val | MEMARB_MODE_ENABLE);\r\ntp->pci_fn = PCI_FUNC(tp->pdev->devfn) & 3;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5704 ||\r\ntg3_flag(tp, 5780_CLASS)) {\r\nif (tg3_flag(tp, PCIX_MODE)) {\r\npci_read_config_dword(tp->pdev,\r\ntp->pcix_cap + PCI_X_STATUS,\r\n&val);\r\ntp->pci_fn = val & 0x7;\r\n}\r\n} else if (tg3_asic_rev(tp) == ASIC_REV_5717 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5719 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5720) {\r\ntg3_read_mem(tp, NIC_SRAM_CPMU_STATUS, &val);\r\nif ((val & NIC_SRAM_CPMUSTAT_SIG_MSK) != NIC_SRAM_CPMUSTAT_SIG)\r\nval = tr32(TG3_CPMU_STATUS);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5717)\r\ntp->pci_fn = (val & TG3_CPMU_STATUS_FMSK_5717) ? 1 : 0;\r\nelse\r\ntp->pci_fn = (val & TG3_CPMU_STATUS_FMSK_5719) >>\r\nTG3_CPMU_STATUS_FSHFT_5719;\r\n}\r\nif (tg3_flag(tp, FLUSH_POSTED_WRITES)) {\r\ntp->write32_tx_mbox = tg3_write_flush_reg32;\r\ntp->write32_rx_mbox = tg3_write_flush_reg32;\r\n}\r\ntg3_get_eeprom_hw_cfg(tp);\r\nif (tg3_flag(tp, FW_TSO) && tg3_flag(tp, ENABLE_ASF)) {\r\ntg3_flag_clear(tp, TSO_CAPABLE);\r\ntg3_flag_clear(tp, TSO_BUG);\r\ntp->fw_needed = NULL;\r\n}\r\nif (tg3_flag(tp, ENABLE_APE)) {\r\npci_state_reg |= PCISTATE_ALLOW_APE_CTLSPC_WR |\r\nPCISTATE_ALLOW_APE_SHMEM_WR |\r\nPCISTATE_ALLOW_APE_PSPACE_WR;\r\npci_write_config_dword(tp->pdev, TG3PCI_PCISTATE,\r\npci_state_reg);\r\ntg3_ape_lock_init(tp);\r\n}\r\ntp->grc_local_ctrl = GRC_LCLCTRL_INT_ON_ATTN | GRC_LCLCTRL_AUTO_SEEPROM;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5700 ||\r\ntg3_flag(tp, EEPROM_WRITE_PROT))\r\ntp->grc_local_ctrl |= (GRC_LCLCTRL_GPIO_OE1 |\r\nGRC_LCLCTRL_GPIO_OUTPUT1);\r\nelse if (tg3_asic_rev(tp) == ASIC_REV_5752)\r\ntp->grc_local_ctrl |= GRC_LCLCTRL_GPIO_OE3;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5755 ||\r\ntg3_asic_rev(tp) == ASIC_REV_57780 ||\r\ntg3_flag(tp, 57765_CLASS))\r\ntp->grc_local_ctrl |= GRC_LCLCTRL_GPIO_UART_SEL;\r\nif (tp->pdev->device == PCI_DEVICE_ID_TIGON3_5761 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5761S) {\r\ntp->grc_local_ctrl |= GRC_LCLCTRL_GPIO_UART_SEL;\r\nif (tg3_flag(tp, IS_NIC))\r\ntp->grc_local_ctrl |= GRC_LCLCTRL_GPIO_OE0 |\r\nGRC_LCLCTRL_GPIO_OUTPUT0;\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5762)\r\ntp->grc_local_ctrl |=\r\ntr32(GRC_LOCAL_CTRL) & GRC_LCLCTRL_GPIO_UART_SEL;\r\ntg3_pwrsrc_switch_to_vmain(tp);\r\nif (tp->dev->mtu > ETH_DATA_LEN && !tg3_flag(tp, 5780_CLASS))\r\ntg3_flag_set(tp, JUMBO_RING_ENABLE);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5700 ||\r\ntg3_chip_rev_id(tp) == CHIPREV_ID_5701_A0 ||\r\ntg3_chip_rev_id(tp) == CHIPREV_ID_5701_B0 ||\r\ntg3_chip_rev_id(tp) == CHIPREV_ID_5701_B2) {\r\ntg3_flag_clear(tp, WOL_SPEED_100MB);\r\n} else {\r\ntg3_flag_set(tp, WOL_SPEED_100MB);\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5906)\r\ntp->phy_flags |= TG3_PHYFLG_IS_FET;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5700 ||\r\n(tg3_asic_rev(tp) == ASIC_REV_5705 &&\r\n(tg3_chip_rev_id(tp) != CHIPREV_ID_5705_A0) &&\r\n(tg3_chip_rev_id(tp) != CHIPREV_ID_5705_A1)) ||\r\n(tp->phy_flags & TG3_PHYFLG_IS_FET) ||\r\n(tp->phy_flags & TG3_PHYFLG_ANY_SERDES))\r\ntp->phy_flags |= TG3_PHYFLG_NO_ETH_WIRE_SPEED;\r\nif (tg3_chip_rev(tp) == CHIPREV_5703_AX ||\r\ntg3_chip_rev(tp) == CHIPREV_5704_AX)\r\ntp->phy_flags |= TG3_PHYFLG_ADC_BUG;\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5704_A0)\r\ntp->phy_flags |= TG3_PHYFLG_5704_A0_BUG;\r\nif (tg3_flag(tp, 5705_PLUS) &&\r\n!(tp->phy_flags & TG3_PHYFLG_IS_FET) &&\r\ntg3_asic_rev(tp) != ASIC_REV_5785 &&\r\ntg3_asic_rev(tp) != ASIC_REV_57780 &&\r\n!tg3_flag(tp, 57765_PLUS)) {\r\nif (tg3_asic_rev(tp) == ASIC_REV_5755 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5787 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5784 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5761) {\r\nif (tp->pdev->device != PCI_DEVICE_ID_TIGON3_5756 &&\r\ntp->pdev->device != PCI_DEVICE_ID_TIGON3_5722)\r\ntp->phy_flags |= TG3_PHYFLG_JITTER_BUG;\r\nif (tp->pdev->device == PCI_DEVICE_ID_TIGON3_5755M)\r\ntp->phy_flags |= TG3_PHYFLG_ADJUST_TRIM;\r\n} else\r\ntp->phy_flags |= TG3_PHYFLG_BER_BUG;\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5784 &&\r\ntg3_chip_rev(tp) != CHIPREV_5784_AX) {\r\ntp->phy_otp = tg3_read_otp_phycfg(tp);\r\nif (tp->phy_otp == 0)\r\ntp->phy_otp = TG3_OTP_DEFAULT;\r\n}\r\nif (tg3_flag(tp, CPMU_PRESENT))\r\ntp->mi_mode = MAC_MI_MODE_500KHZ_CONST;\r\nelse\r\ntp->mi_mode = MAC_MI_MODE_BASE;\r\ntp->coalesce_mode = 0;\r\nif (tg3_chip_rev(tp) != CHIPREV_5700_AX &&\r\ntg3_chip_rev(tp) != CHIPREV_5700_BX)\r\ntp->coalesce_mode |= HOSTCC_MODE_32BYTE;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5762 ||\r\ntg3_chip_rev_id(tp) == CHIPREV_ID_5719_A0 ||\r\ntg3_chip_rev_id(tp) == CHIPREV_ID_5720_A0) {\r\ntp->coalesce_mode |= HOSTCC_MODE_ATTN;\r\ntp->grc_mode |= GRC_MODE_IRQ_ON_FLOW_ATTN;\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5785 ||\r\ntg3_asic_rev(tp) == ASIC_REV_57780)\r\ntg3_flag_set(tp, USE_PHYLIB);\r\nerr = tg3_mdio_init(tp);\r\nif (err)\r\nreturn err;\r\nval = tr32(GRC_MODE);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5720 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5762)\r\nval &= (GRC_MODE_BYTE_SWAP_B2HRX_DATA |\r\nGRC_MODE_WORD_SWAP_B2HRX_DATA |\r\nGRC_MODE_B2HRX_ENABLE |\r\nGRC_MODE_HTX2B_ENABLE |\r\nGRC_MODE_HOST_STACKUP);\r\nelse\r\nval &= GRC_MODE_HOST_STACKUP;\r\ntw32(GRC_MODE, val | tp->grc_mode);\r\ntg3_switch_clocks(tp);\r\ntw32(TG3PCI_MEM_WIN_BASE_ADDR, 0);\r\ntw32(TG3PCI_REG_BASE_ADDR, 0);\r\npci_read_config_dword(tp->pdev, TG3PCI_PCISTATE,\r\n&pci_state_reg);\r\nif ((pci_state_reg & PCISTATE_CONV_PCI_MODE) == 0 &&\r\n!tg3_flag(tp, PCIX_TARGET_HWBUG)) {\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5701_A0 ||\r\ntg3_chip_rev_id(tp) == CHIPREV_ID_5701_B0 ||\r\ntg3_chip_rev_id(tp) == CHIPREV_ID_5701_B2 ||\r\ntg3_chip_rev_id(tp) == CHIPREV_ID_5701_B5) {\r\nvoid __iomem *sram_base;\r\nsram_base = tp->regs + NIC_SRAM_WIN_BASE + NIC_SRAM_STATS_BLK;\r\nwritel(0x00000000, sram_base);\r\nwritel(0x00000000, sram_base + 4);\r\nwritel(0xffffffff, sram_base + 4);\r\nif (readl(sram_base) != 0x00000000)\r\ntg3_flag_set(tp, PCIX_TARGET_HWBUG);\r\n}\r\n}\r\nudelay(50);\r\ntg3_nvram_init(tp);\r\nif (tg3_asic_rev(tp) == ASIC_REV_57766 &&\r\n!tg3_flag(tp, NO_NVRAM))\r\ntp->fw_needed = NULL;\r\ngrc_misc_cfg = tr32(GRC_MISC_CFG);\r\ngrc_misc_cfg &= GRC_MISC_CFG_BOARD_ID_MASK;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5705 &&\r\n(grc_misc_cfg == GRC_MISC_CFG_BOARD_ID_5788 ||\r\ngrc_misc_cfg == GRC_MISC_CFG_BOARD_ID_5788M))\r\ntg3_flag_set(tp, IS_5788);\r\nif (!tg3_flag(tp, IS_5788) &&\r\ntg3_asic_rev(tp) != ASIC_REV_5700)\r\ntg3_flag_set(tp, TAGGED_STATUS);\r\nif (tg3_flag(tp, TAGGED_STATUS)) {\r\ntp->coalesce_mode |= (HOSTCC_MODE_CLRTICK_RXBD |\r\nHOSTCC_MODE_CLRTICK_TXBD);\r\ntp->misc_host_ctrl |= MISC_HOST_CTRL_TAGGED_STATUS;\r\npci_write_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,\r\ntp->misc_host_ctrl);\r\n}\r\nif (tg3_flag(tp, ENABLE_APE))\r\ntp->mac_mode = MAC_MODE_APE_TX_EN | MAC_MODE_APE_RX_EN;\r\nelse\r\ntp->mac_mode = 0;\r\nif (tg3_10_100_only_device(tp, ent))\r\ntp->phy_flags |= TG3_PHYFLG_10_100_ONLY;\r\nerr = tg3_phy_probe(tp);\r\nif (err) {\r\ndev_err(&tp->pdev->dev, "phy probe failed, err %d\n", err);\r\ntg3_mdio_fini(tp);\r\n}\r\ntg3_read_vpd(tp);\r\ntg3_read_fw_ver(tp);\r\nif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES) {\r\ntp->phy_flags &= ~TG3_PHYFLG_USE_MI_INTERRUPT;\r\n} else {\r\nif (tg3_asic_rev(tp) == ASIC_REV_5700)\r\ntp->phy_flags |= TG3_PHYFLG_USE_MI_INTERRUPT;\r\nelse\r\ntp->phy_flags &= ~TG3_PHYFLG_USE_MI_INTERRUPT;\r\n}\r\nif (tg3_asic_rev(tp) == ASIC_REV_5700)\r\ntg3_flag_set(tp, USE_LINKCHG_REG);\r\nelse\r\ntg3_flag_clear(tp, USE_LINKCHG_REG);\r\nif (tp->pdev->subsystem_vendor == PCI_VENDOR_ID_DELL &&\r\ntg3_asic_rev(tp) == ASIC_REV_5701 &&\r\n!(tp->phy_flags & TG3_PHYFLG_PHY_SERDES)) {\r\ntp->phy_flags |= TG3_PHYFLG_USE_MI_INTERRUPT;\r\ntg3_flag_set(tp, USE_LINKCHG_REG);\r\n}\r\nif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES)\r\ntg3_flag_set(tp, POLL_SERDES);\r\nelse\r\ntg3_flag_clear(tp, POLL_SERDES);\r\nif (tg3_flag(tp, ENABLE_APE) && tg3_flag(tp, ENABLE_ASF))\r\ntg3_flag_set(tp, POLL_CPMU_LINK);\r\ntp->rx_offset = NET_SKB_PAD + NET_IP_ALIGN;\r\ntp->rx_copy_thresh = TG3_RX_COPY_THRESHOLD;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5701 &&\r\ntg3_flag(tp, PCIX_MODE)) {\r\ntp->rx_offset = NET_SKB_PAD;\r\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\r\ntp->rx_copy_thresh = ~(u16)0;\r\n#endif\r\n}\r\ntp->rx_std_ring_mask = TG3_RX_STD_RING_SIZE(tp) - 1;\r\ntp->rx_jmb_ring_mask = TG3_RX_JMB_RING_SIZE(tp) - 1;\r\ntp->rx_ret_ring_mask = tg3_rx_ret_ring_size(tp) - 1;\r\ntp->rx_std_max_post = tp->rx_std_ring_mask + 1;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5750 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5752 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5755)\r\ntp->rx_std_max_post = 8;\r\nif (tg3_flag(tp, ASPM_WORKAROUND))\r\ntp->pwrmgmt_thresh = tr32(PCIE_PWR_MGMT_THRESH) &\r\nPCIE_PWR_MGMT_L1_THRESH_MSK;\r\nreturn err;\r\n}\r\nstatic int tg3_get_macaddr_sparc(struct tg3 *tp)\r\n{\r\nstruct net_device *dev = tp->dev;\r\nstruct pci_dev *pdev = tp->pdev;\r\nstruct device_node *dp = pci_device_to_OF_node(pdev);\r\nconst unsigned char *addr;\r\nint len;\r\naddr = of_get_property(dp, "local-mac-address", &len);\r\nif (addr && len == ETH_ALEN) {\r\nmemcpy(dev->dev_addr, addr, ETH_ALEN);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int tg3_get_default_macaddr_sparc(struct tg3 *tp)\r\n{\r\nstruct net_device *dev = tp->dev;\r\nmemcpy(dev->dev_addr, idprom->id_ethaddr, ETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic int tg3_get_device_address(struct tg3 *tp)\r\n{\r\nstruct net_device *dev = tp->dev;\r\nu32 hi, lo, mac_offset;\r\nint addr_ok = 0;\r\nint err;\r\n#ifdef CONFIG_SPARC\r\nif (!tg3_get_macaddr_sparc(tp))\r\nreturn 0;\r\n#endif\r\nif (tg3_flag(tp, IS_SSB_CORE)) {\r\nerr = ssb_gige_get_macaddr(tp->pdev, &dev->dev_addr[0]);\r\nif (!err && is_valid_ether_addr(&dev->dev_addr[0]))\r\nreturn 0;\r\n}\r\nmac_offset = 0x7c;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5704 ||\r\ntg3_flag(tp, 5780_CLASS)) {\r\nif (tr32(TG3PCI_DUAL_MAC_CTRL) & DUAL_MAC_CTRL_ID)\r\nmac_offset = 0xcc;\r\nif (tg3_nvram_lock(tp))\r\ntw32_f(NVRAM_CMD, NVRAM_CMD_RESET);\r\nelse\r\ntg3_nvram_unlock(tp);\r\n} else if (tg3_flag(tp, 5717_PLUS)) {\r\nif (tp->pci_fn & 1)\r\nmac_offset = 0xcc;\r\nif (tp->pci_fn > 1)\r\nmac_offset += 0x18c;\r\n} else if (tg3_asic_rev(tp) == ASIC_REV_5906)\r\nmac_offset = 0x10;\r\ntg3_read_mem(tp, NIC_SRAM_MAC_ADDR_HIGH_MBOX, &hi);\r\nif ((hi >> 16) == 0x484b) {\r\ndev->dev_addr[0] = (hi >> 8) & 0xff;\r\ndev->dev_addr[1] = (hi >> 0) & 0xff;\r\ntg3_read_mem(tp, NIC_SRAM_MAC_ADDR_LOW_MBOX, &lo);\r\ndev->dev_addr[2] = (lo >> 24) & 0xff;\r\ndev->dev_addr[3] = (lo >> 16) & 0xff;\r\ndev->dev_addr[4] = (lo >> 8) & 0xff;\r\ndev->dev_addr[5] = (lo >> 0) & 0xff;\r\naddr_ok = is_valid_ether_addr(&dev->dev_addr[0]);\r\n}\r\nif (!addr_ok) {\r\nif (!tg3_flag(tp, NO_NVRAM) &&\r\n!tg3_nvram_read_be32(tp, mac_offset + 0, &hi) &&\r\n!tg3_nvram_read_be32(tp, mac_offset + 4, &lo)) {\r\nmemcpy(&dev->dev_addr[0], ((char *)&hi) + 2, 2);\r\nmemcpy(&dev->dev_addr[2], (char *)&lo, sizeof(lo));\r\n}\r\nelse {\r\nhi = tr32(MAC_ADDR_0_HIGH);\r\nlo = tr32(MAC_ADDR_0_LOW);\r\ndev->dev_addr[5] = lo & 0xff;\r\ndev->dev_addr[4] = (lo >> 8) & 0xff;\r\ndev->dev_addr[3] = (lo >> 16) & 0xff;\r\ndev->dev_addr[2] = (lo >> 24) & 0xff;\r\ndev->dev_addr[1] = hi & 0xff;\r\ndev->dev_addr[0] = (hi >> 8) & 0xff;\r\n}\r\n}\r\nif (!is_valid_ether_addr(&dev->dev_addr[0])) {\r\n#ifdef CONFIG_SPARC\r\nif (!tg3_get_default_macaddr_sparc(tp))\r\nreturn 0;\r\n#endif\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 tg3_calc_dma_bndry(struct tg3 *tp, u32 val)\r\n{\r\nint cacheline_size;\r\nu8 byte;\r\nint goal;\r\npci_read_config_byte(tp->pdev, PCI_CACHE_LINE_SIZE, &byte);\r\nif (byte == 0)\r\ncacheline_size = 1024;\r\nelse\r\ncacheline_size = (int) byte * 4;\r\nif (tg3_asic_rev(tp) != ASIC_REV_5700 &&\r\ntg3_asic_rev(tp) != ASIC_REV_5701 &&\r\n!tg3_flag(tp, PCI_EXPRESS))\r\ngoto out;\r\n#if defined(CONFIG_PPC64) || defined(CONFIG_IA64) || defined(CONFIG_PARISC)\r\ngoal = BOUNDARY_MULTI_CACHELINE;\r\n#else\r\n#if defined(CONFIG_SPARC64) || defined(CONFIG_ALPHA)\r\ngoal = BOUNDARY_SINGLE_CACHELINE;\r\n#else\r\ngoal = 0;\r\n#endif\r\n#endif\r\nif (tg3_flag(tp, 57765_PLUS)) {\r\nval = goal ? 0 : DMA_RWCTRL_DIS_CACHE_ALIGNMENT;\r\ngoto out;\r\n}\r\nif (!goal)\r\ngoto out;\r\nif (tg3_flag(tp, PCIX_MODE) && !tg3_flag(tp, PCI_EXPRESS)) {\r\nswitch (cacheline_size) {\r\ncase 16:\r\ncase 32:\r\ncase 64:\r\ncase 128:\r\nif (goal == BOUNDARY_SINGLE_CACHELINE) {\r\nval |= (DMA_RWCTRL_READ_BNDRY_128_PCIX |\r\nDMA_RWCTRL_WRITE_BNDRY_128_PCIX);\r\n} else {\r\nval |= (DMA_RWCTRL_READ_BNDRY_384_PCIX |\r\nDMA_RWCTRL_WRITE_BNDRY_384_PCIX);\r\n}\r\nbreak;\r\ncase 256:\r\nval |= (DMA_RWCTRL_READ_BNDRY_256_PCIX |\r\nDMA_RWCTRL_WRITE_BNDRY_256_PCIX);\r\nbreak;\r\ndefault:\r\nval |= (DMA_RWCTRL_READ_BNDRY_384_PCIX |\r\nDMA_RWCTRL_WRITE_BNDRY_384_PCIX);\r\nbreak;\r\n}\r\n} else if (tg3_flag(tp, PCI_EXPRESS)) {\r\nswitch (cacheline_size) {\r\ncase 16:\r\ncase 32:\r\ncase 64:\r\nif (goal == BOUNDARY_SINGLE_CACHELINE) {\r\nval &= ~DMA_RWCTRL_WRITE_BNDRY_DISAB_PCIE;\r\nval |= DMA_RWCTRL_WRITE_BNDRY_64_PCIE;\r\nbreak;\r\n}\r\ncase 128:\r\ndefault:\r\nval &= ~DMA_RWCTRL_WRITE_BNDRY_DISAB_PCIE;\r\nval |= DMA_RWCTRL_WRITE_BNDRY_128_PCIE;\r\nbreak;\r\n}\r\n} else {\r\nswitch (cacheline_size) {\r\ncase 16:\r\nif (goal == BOUNDARY_SINGLE_CACHELINE) {\r\nval |= (DMA_RWCTRL_READ_BNDRY_16 |\r\nDMA_RWCTRL_WRITE_BNDRY_16);\r\nbreak;\r\n}\r\ncase 32:\r\nif (goal == BOUNDARY_SINGLE_CACHELINE) {\r\nval |= (DMA_RWCTRL_READ_BNDRY_32 |\r\nDMA_RWCTRL_WRITE_BNDRY_32);\r\nbreak;\r\n}\r\ncase 64:\r\nif (goal == BOUNDARY_SINGLE_CACHELINE) {\r\nval |= (DMA_RWCTRL_READ_BNDRY_64 |\r\nDMA_RWCTRL_WRITE_BNDRY_64);\r\nbreak;\r\n}\r\ncase 128:\r\nif (goal == BOUNDARY_SINGLE_CACHELINE) {\r\nval |= (DMA_RWCTRL_READ_BNDRY_128 |\r\nDMA_RWCTRL_WRITE_BNDRY_128);\r\nbreak;\r\n}\r\ncase 256:\r\nval |= (DMA_RWCTRL_READ_BNDRY_256 |\r\nDMA_RWCTRL_WRITE_BNDRY_256);\r\nbreak;\r\ncase 512:\r\nval |= (DMA_RWCTRL_READ_BNDRY_512 |\r\nDMA_RWCTRL_WRITE_BNDRY_512);\r\nbreak;\r\ncase 1024:\r\ndefault:\r\nval |= (DMA_RWCTRL_READ_BNDRY_1024 |\r\nDMA_RWCTRL_WRITE_BNDRY_1024);\r\nbreak;\r\n}\r\n}\r\nout:\r\nreturn val;\r\n}\r\nstatic int tg3_do_test_dma(struct tg3 *tp, u32 *buf, dma_addr_t buf_dma,\r\nint size, bool to_device)\r\n{\r\nstruct tg3_internal_buffer_desc test_desc;\r\nu32 sram_dma_descs;\r\nint i, ret;\r\nsram_dma_descs = NIC_SRAM_DMA_DESC_POOL_BASE;\r\ntw32(FTQ_RCVBD_COMP_FIFO_ENQDEQ, 0);\r\ntw32(FTQ_RCVDATA_COMP_FIFO_ENQDEQ, 0);\r\ntw32(RDMAC_STATUS, 0);\r\ntw32(WDMAC_STATUS, 0);\r\ntw32(BUFMGR_MODE, 0);\r\ntw32(FTQ_RESET, 0);\r\ntest_desc.addr_hi = ((u64) buf_dma) >> 32;\r\ntest_desc.addr_lo = buf_dma & 0xffffffff;\r\ntest_desc.nic_mbuf = 0x00002100;\r\ntest_desc.len = size;\r\nif (to_device) {\r\ntest_desc.cqid_sqid = (13 << 8) | 2;\r\ntw32_f(RDMAC_MODE, RDMAC_MODE_ENABLE);\r\nudelay(40);\r\n} else {\r\ntest_desc.cqid_sqid = (16 << 8) | 7;\r\ntw32_f(WDMAC_MODE, WDMAC_MODE_ENABLE);\r\nudelay(40);\r\n}\r\ntest_desc.flags = 0x00000005;\r\nfor (i = 0; i < (sizeof(test_desc) / sizeof(u32)); i++) {\r\nu32 val;\r\nval = *(((u32 *)&test_desc) + i);\r\npci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR,\r\nsram_dma_descs + (i * sizeof(u32)));\r\npci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_DATA, val);\r\n}\r\npci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, 0);\r\nif (to_device)\r\ntw32(FTQ_DMA_HIGH_READ_FIFO_ENQDEQ, sram_dma_descs);\r\nelse\r\ntw32(FTQ_DMA_HIGH_WRITE_FIFO_ENQDEQ, sram_dma_descs);\r\nret = -ENODEV;\r\nfor (i = 0; i < 40; i++) {\r\nu32 val;\r\nif (to_device)\r\nval = tr32(FTQ_RCVBD_COMP_FIFO_ENQDEQ);\r\nelse\r\nval = tr32(FTQ_RCVDATA_COMP_FIFO_ENQDEQ);\r\nif ((val & 0xffff) == sram_dma_descs) {\r\nret = 0;\r\nbreak;\r\n}\r\nudelay(100);\r\n}\r\nreturn ret;\r\n}\r\nstatic int tg3_test_dma(struct tg3 *tp)\r\n{\r\ndma_addr_t buf_dma;\r\nu32 *buf, saved_dma_rwctrl;\r\nint ret = 0;\r\nbuf = dma_alloc_coherent(&tp->pdev->dev, TEST_BUFFER_SIZE,\r\n&buf_dma, GFP_KERNEL);\r\nif (!buf) {\r\nret = -ENOMEM;\r\ngoto out_nofree;\r\n}\r\ntp->dma_rwctrl = ((0x7 << DMA_RWCTRL_PCI_WRITE_CMD_SHIFT) |\r\n(0x6 << DMA_RWCTRL_PCI_READ_CMD_SHIFT));\r\ntp->dma_rwctrl = tg3_calc_dma_bndry(tp, tp->dma_rwctrl);\r\nif (tg3_flag(tp, 57765_PLUS))\r\ngoto out;\r\nif (tg3_flag(tp, PCI_EXPRESS)) {\r\ntp->dma_rwctrl |= 0x00180000;\r\n} else if (!tg3_flag(tp, PCIX_MODE)) {\r\nif (tg3_asic_rev(tp) == ASIC_REV_5705 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5750)\r\ntp->dma_rwctrl |= 0x003f0000;\r\nelse\r\ntp->dma_rwctrl |= 0x003f000f;\r\n} else {\r\nif (tg3_asic_rev(tp) == ASIC_REV_5703 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5704) {\r\nu32 ccval = (tr32(TG3PCI_CLOCK_CTRL) & 0x1f);\r\nu32 read_water = 0x7;\r\nif (tg3_flag(tp, 40BIT_DMA_BUG) &&\r\ntg3_asic_rev(tp) == ASIC_REV_5704)\r\ntp->dma_rwctrl |= 0x8000;\r\nelse if (ccval == 0x6 || ccval == 0x7)\r\ntp->dma_rwctrl |= DMA_RWCTRL_ONE_DMA;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5703)\r\nread_water = 4;\r\ntp->dma_rwctrl |=\r\n(read_water << DMA_RWCTRL_READ_WATER_SHIFT) |\r\n(0x3 << DMA_RWCTRL_WRITE_WATER_SHIFT) |\r\n(1 << 23);\r\n} else if (tg3_asic_rev(tp) == ASIC_REV_5780) {\r\ntp->dma_rwctrl |= 0x00144000;\r\n} else if (tg3_asic_rev(tp) == ASIC_REV_5714) {\r\ntp->dma_rwctrl |= 0x00148000;\r\n} else {\r\ntp->dma_rwctrl |= 0x001b000f;\r\n}\r\n}\r\nif (tg3_flag(tp, ONE_DMA_AT_ONCE))\r\ntp->dma_rwctrl |= DMA_RWCTRL_ONE_DMA;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5703 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5704)\r\ntp->dma_rwctrl &= 0xfffffff0;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5700 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5701) {\r\ntp->dma_rwctrl |= DMA_RWCTRL_USE_MEM_READ_MULT;\r\ntp->dma_rwctrl |= DMA_RWCTRL_ASSERT_ALL_BE;\r\n}\r\ntw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);\r\nif (tg3_asic_rev(tp) != ASIC_REV_5700 &&\r\ntg3_asic_rev(tp) != ASIC_REV_5701)\r\ngoto out;\r\nsaved_dma_rwctrl = tp->dma_rwctrl;\r\ntp->dma_rwctrl &= ~DMA_RWCTRL_WRITE_BNDRY_MASK;\r\ntw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);\r\nwhile (1) {\r\nu32 *p = buf, i;\r\nfor (i = 0; i < TEST_BUFFER_SIZE / sizeof(u32); i++)\r\np[i] = i;\r\nret = tg3_do_test_dma(tp, buf, buf_dma, TEST_BUFFER_SIZE, true);\r\nif (ret) {\r\ndev_err(&tp->pdev->dev,\r\n"%s: Buffer write failed. err = %d\n",\r\n__func__, ret);\r\nbreak;\r\n}\r\nret = tg3_do_test_dma(tp, buf, buf_dma, TEST_BUFFER_SIZE, false);\r\nif (ret) {\r\ndev_err(&tp->pdev->dev, "%s: Buffer read failed. "\r\n"err = %d\n", __func__, ret);\r\nbreak;\r\n}\r\nfor (i = 0; i < TEST_BUFFER_SIZE / sizeof(u32); i++) {\r\nif (p[i] == i)\r\ncontinue;\r\nif ((tp->dma_rwctrl & DMA_RWCTRL_WRITE_BNDRY_MASK) !=\r\nDMA_RWCTRL_WRITE_BNDRY_16) {\r\ntp->dma_rwctrl &= ~DMA_RWCTRL_WRITE_BNDRY_MASK;\r\ntp->dma_rwctrl |= DMA_RWCTRL_WRITE_BNDRY_16;\r\ntw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);\r\nbreak;\r\n} else {\r\ndev_err(&tp->pdev->dev,\r\n"%s: Buffer corrupted on read back! "\r\n"(%d != %d)\n", __func__, p[i], i);\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\n}\r\nif (i == (TEST_BUFFER_SIZE / sizeof(u32))) {\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nif ((tp->dma_rwctrl & DMA_RWCTRL_WRITE_BNDRY_MASK) !=\r\nDMA_RWCTRL_WRITE_BNDRY_16) {\r\nif (pci_dev_present(tg3_dma_wait_state_chipsets)) {\r\ntp->dma_rwctrl &= ~DMA_RWCTRL_WRITE_BNDRY_MASK;\r\ntp->dma_rwctrl |= DMA_RWCTRL_WRITE_BNDRY_16;\r\n} else {\r\ntp->dma_rwctrl = saved_dma_rwctrl;\r\n}\r\ntw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);\r\n}\r\nout:\r\ndma_free_coherent(&tp->pdev->dev, TEST_BUFFER_SIZE, buf, buf_dma);\r\nout_nofree:\r\nreturn ret;\r\n}\r\nstatic void tg3_init_bufmgr_config(struct tg3 *tp)\r\n{\r\nif (tg3_flag(tp, 57765_PLUS)) {\r\ntp->bufmgr_config.mbuf_read_dma_low_water =\r\nDEFAULT_MB_RDMA_LOW_WATER_5705;\r\ntp->bufmgr_config.mbuf_mac_rx_low_water =\r\nDEFAULT_MB_MACRX_LOW_WATER_57765;\r\ntp->bufmgr_config.mbuf_high_water =\r\nDEFAULT_MB_HIGH_WATER_57765;\r\ntp->bufmgr_config.mbuf_read_dma_low_water_jumbo =\r\nDEFAULT_MB_RDMA_LOW_WATER_5705;\r\ntp->bufmgr_config.mbuf_mac_rx_low_water_jumbo =\r\nDEFAULT_MB_MACRX_LOW_WATER_JUMBO_57765;\r\ntp->bufmgr_config.mbuf_high_water_jumbo =\r\nDEFAULT_MB_HIGH_WATER_JUMBO_57765;\r\n} else if (tg3_flag(tp, 5705_PLUS)) {\r\ntp->bufmgr_config.mbuf_read_dma_low_water =\r\nDEFAULT_MB_RDMA_LOW_WATER_5705;\r\ntp->bufmgr_config.mbuf_mac_rx_low_water =\r\nDEFAULT_MB_MACRX_LOW_WATER_5705;\r\ntp->bufmgr_config.mbuf_high_water =\r\nDEFAULT_MB_HIGH_WATER_5705;\r\nif (tg3_asic_rev(tp) == ASIC_REV_5906) {\r\ntp->bufmgr_config.mbuf_mac_rx_low_water =\r\nDEFAULT_MB_MACRX_LOW_WATER_5906;\r\ntp->bufmgr_config.mbuf_high_water =\r\nDEFAULT_MB_HIGH_WATER_5906;\r\n}\r\ntp->bufmgr_config.mbuf_read_dma_low_water_jumbo =\r\nDEFAULT_MB_RDMA_LOW_WATER_JUMBO_5780;\r\ntp->bufmgr_config.mbuf_mac_rx_low_water_jumbo =\r\nDEFAULT_MB_MACRX_LOW_WATER_JUMBO_5780;\r\ntp->bufmgr_config.mbuf_high_water_jumbo =\r\nDEFAULT_MB_HIGH_WATER_JUMBO_5780;\r\n} else {\r\ntp->bufmgr_config.mbuf_read_dma_low_water =\r\nDEFAULT_MB_RDMA_LOW_WATER;\r\ntp->bufmgr_config.mbuf_mac_rx_low_water =\r\nDEFAULT_MB_MACRX_LOW_WATER;\r\ntp->bufmgr_config.mbuf_high_water =\r\nDEFAULT_MB_HIGH_WATER;\r\ntp->bufmgr_config.mbuf_read_dma_low_water_jumbo =\r\nDEFAULT_MB_RDMA_LOW_WATER_JUMBO;\r\ntp->bufmgr_config.mbuf_mac_rx_low_water_jumbo =\r\nDEFAULT_MB_MACRX_LOW_WATER_JUMBO;\r\ntp->bufmgr_config.mbuf_high_water_jumbo =\r\nDEFAULT_MB_HIGH_WATER_JUMBO;\r\n}\r\ntp->bufmgr_config.dma_low_water = DEFAULT_DMA_LOW_WATER;\r\ntp->bufmgr_config.dma_high_water = DEFAULT_DMA_HIGH_WATER;\r\n}\r\nstatic char *tg3_phy_string(struct tg3 *tp)\r\n{\r\nswitch (tp->phy_id & TG3_PHY_ID_MASK) {\r\ncase TG3_PHY_ID_BCM5400: return "5400";\r\ncase TG3_PHY_ID_BCM5401: return "5401";\r\ncase TG3_PHY_ID_BCM5411: return "5411";\r\ncase TG3_PHY_ID_BCM5701: return "5701";\r\ncase TG3_PHY_ID_BCM5703: return "5703";\r\ncase TG3_PHY_ID_BCM5704: return "5704";\r\ncase TG3_PHY_ID_BCM5705: return "5705";\r\ncase TG3_PHY_ID_BCM5750: return "5750";\r\ncase TG3_PHY_ID_BCM5752: return "5752";\r\ncase TG3_PHY_ID_BCM5714: return "5714";\r\ncase TG3_PHY_ID_BCM5780: return "5780";\r\ncase TG3_PHY_ID_BCM5755: return "5755";\r\ncase TG3_PHY_ID_BCM5787: return "5787";\r\ncase TG3_PHY_ID_BCM5784: return "5784";\r\ncase TG3_PHY_ID_BCM5756: return "5722/5756";\r\ncase TG3_PHY_ID_BCM5906: return "5906";\r\ncase TG3_PHY_ID_BCM5761: return "5761";\r\ncase TG3_PHY_ID_BCM5718C: return "5718C";\r\ncase TG3_PHY_ID_BCM5718S: return "5718S";\r\ncase TG3_PHY_ID_BCM57765: return "57765";\r\ncase TG3_PHY_ID_BCM5719C: return "5719C";\r\ncase TG3_PHY_ID_BCM5720C: return "5720C";\r\ncase TG3_PHY_ID_BCM5762: return "5762C";\r\ncase TG3_PHY_ID_BCM8002: return "8002/serdes";\r\ncase 0: return "serdes";\r\ndefault: return "unknown";\r\n}\r\n}\r\nstatic char *tg3_bus_string(struct tg3 *tp, char *str)\r\n{\r\nif (tg3_flag(tp, PCI_EXPRESS)) {\r\nstrcpy(str, "PCI Express");\r\nreturn str;\r\n} else if (tg3_flag(tp, PCIX_MODE)) {\r\nu32 clock_ctrl = tr32(TG3PCI_CLOCK_CTRL) & 0x1f;\r\nstrcpy(str, "PCIX:");\r\nif ((clock_ctrl == 7) ||\r\n((tr32(GRC_MISC_CFG) & GRC_MISC_CFG_BOARD_ID_MASK) ==\r\nGRC_MISC_CFG_BOARD_ID_5704CIOBE))\r\nstrcat(str, "133MHz");\r\nelse if (clock_ctrl == 0)\r\nstrcat(str, "33MHz");\r\nelse if (clock_ctrl == 2)\r\nstrcat(str, "50MHz");\r\nelse if (clock_ctrl == 4)\r\nstrcat(str, "66MHz");\r\nelse if (clock_ctrl == 6)\r\nstrcat(str, "100MHz");\r\n} else {\r\nstrcpy(str, "PCI:");\r\nif (tg3_flag(tp, PCI_HIGH_SPEED))\r\nstrcat(str, "66MHz");\r\nelse\r\nstrcat(str, "33MHz");\r\n}\r\nif (tg3_flag(tp, PCI_32BIT))\r\nstrcat(str, ":32-bit");\r\nelse\r\nstrcat(str, ":64-bit");\r\nreturn str;\r\n}\r\nstatic void tg3_init_coal(struct tg3 *tp)\r\n{\r\nstruct ethtool_coalesce *ec = &tp->coal;\r\nmemset(ec, 0, sizeof(*ec));\r\nec->cmd = ETHTOOL_GCOALESCE;\r\nec->rx_coalesce_usecs = LOW_RXCOL_TICKS;\r\nec->tx_coalesce_usecs = LOW_TXCOL_TICKS;\r\nec->rx_max_coalesced_frames = LOW_RXMAX_FRAMES;\r\nec->tx_max_coalesced_frames = LOW_TXMAX_FRAMES;\r\nec->rx_coalesce_usecs_irq = DEFAULT_RXCOAL_TICK_INT;\r\nec->tx_coalesce_usecs_irq = DEFAULT_TXCOAL_TICK_INT;\r\nec->rx_max_coalesced_frames_irq = DEFAULT_RXCOAL_MAXF_INT;\r\nec->tx_max_coalesced_frames_irq = DEFAULT_TXCOAL_MAXF_INT;\r\nec->stats_block_coalesce_usecs = DEFAULT_STAT_COAL_TICKS;\r\nif (tp->coalesce_mode & (HOSTCC_MODE_CLRTICK_RXBD |\r\nHOSTCC_MODE_CLRTICK_TXBD)) {\r\nec->rx_coalesce_usecs = LOW_RXCOL_TICKS_CLRTCKS;\r\nec->rx_coalesce_usecs_irq = DEFAULT_RXCOAL_TICK_INT_CLRTCKS;\r\nec->tx_coalesce_usecs = LOW_TXCOL_TICKS_CLRTCKS;\r\nec->tx_coalesce_usecs_irq = DEFAULT_TXCOAL_TICK_INT_CLRTCKS;\r\n}\r\nif (tg3_flag(tp, 5705_PLUS)) {\r\nec->rx_coalesce_usecs_irq = 0;\r\nec->tx_coalesce_usecs_irq = 0;\r\nec->stats_block_coalesce_usecs = 0;\r\n}\r\n}\r\nstatic int tg3_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct net_device *dev;\r\nstruct tg3 *tp;\r\nint i, err;\r\nu32 sndmbx, rcvmbx, intmbx;\r\nchar str[40];\r\nu64 dma_mask, persist_dma_mask;\r\nnetdev_features_t features = 0;\r\nprintk_once(KERN_INFO "%s\n", version);\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot enable PCI device, aborting\n");\r\nreturn err;\r\n}\r\nerr = pci_request_regions(pdev, DRV_MODULE_NAME);\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot obtain PCI resources, aborting\n");\r\ngoto err_out_disable_pdev;\r\n}\r\npci_set_master(pdev);\r\ndev = alloc_etherdev_mq(sizeof(*tp), TG3_IRQ_MAX_VECS);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto err_out_free_res;\r\n}\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\ntp = netdev_priv(dev);\r\ntp->pdev = pdev;\r\ntp->dev = dev;\r\ntp->rx_mode = TG3_DEF_RX_MODE;\r\ntp->tx_mode = TG3_DEF_TX_MODE;\r\ntp->irq_sync = 1;\r\ntp->pcierr_recovery = false;\r\nif (tg3_debug > 0)\r\ntp->msg_enable = tg3_debug;\r\nelse\r\ntp->msg_enable = TG3_DEF_MSG_ENABLE;\r\nif (pdev_is_ssb_gige_core(pdev)) {\r\ntg3_flag_set(tp, IS_SSB_CORE);\r\nif (ssb_gige_must_flush_posted_writes(pdev))\r\ntg3_flag_set(tp, FLUSH_POSTED_WRITES);\r\nif (ssb_gige_one_dma_at_once(pdev))\r\ntg3_flag_set(tp, ONE_DMA_AT_ONCE);\r\nif (ssb_gige_have_roboswitch(pdev)) {\r\ntg3_flag_set(tp, USE_PHYLIB);\r\ntg3_flag_set(tp, ROBOSWITCH);\r\n}\r\nif (ssb_gige_is_rgmii(pdev))\r\ntg3_flag_set(tp, RGMII_MODE);\r\n}\r\ntp->misc_host_ctrl =\r\nMISC_HOST_CTRL_MASK_PCI_INT |\r\nMISC_HOST_CTRL_WORD_SWAP |\r\nMISC_HOST_CTRL_INDIR_ACCESS |\r\nMISC_HOST_CTRL_PCISTATE_RW;\r\ntp->grc_mode = (GRC_MODE_WSWAP_DATA | GRC_MODE_BSWAP_DATA |\r\nGRC_MODE_WSWAP_NONFRM_DATA);\r\n#ifdef __BIG_ENDIAN\r\ntp->grc_mode |= GRC_MODE_BSWAP_NONFRM_DATA;\r\n#endif\r\nspin_lock_init(&tp->lock);\r\nspin_lock_init(&tp->indirect_lock);\r\nINIT_WORK(&tp->reset_task, tg3_reset_task);\r\ntp->regs = pci_ioremap_bar(pdev, BAR_0);\r\nif (!tp->regs) {\r\ndev_err(&pdev->dev, "Cannot map device registers, aborting\n");\r\nerr = -ENOMEM;\r\ngoto err_out_free_dev;\r\n}\r\nif (tp->pdev->device == PCI_DEVICE_ID_TIGON3_5761 ||\r\ntp->pdev->device == PCI_DEVICE_ID_TIGON3_5761E ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5761S ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5761SE ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5717 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5717_C ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5718 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5719 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5720 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_57767 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_57764 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5762 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5725 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_5727 ||\r\ntp->pdev->device == TG3PCI_DEVICE_TIGON3_57787) {\r\ntg3_flag_set(tp, ENABLE_APE);\r\ntp->aperegs = pci_ioremap_bar(pdev, BAR_2);\r\nif (!tp->aperegs) {\r\ndev_err(&pdev->dev,\r\n"Cannot map APE registers, aborting\n");\r\nerr = -ENOMEM;\r\ngoto err_out_iounmap;\r\n}\r\n}\r\ntp->rx_pending = TG3_DEF_RX_RING_PENDING;\r\ntp->rx_jumbo_pending = TG3_DEF_RX_JUMBO_RING_PENDING;\r\ndev->ethtool_ops = &tg3_ethtool_ops;\r\ndev->watchdog_timeo = TG3_TX_TIMEOUT;\r\ndev->netdev_ops = &tg3_netdev_ops;\r\ndev->irq = pdev->irq;\r\nerr = tg3_get_invariants(tp, ent);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"Problem fetching invariants of chip, aborting\n");\r\ngoto err_out_apeunmap;\r\n}\r\nif (tg3_flag(tp, IS_5788))\r\npersist_dma_mask = dma_mask = DMA_BIT_MASK(32);\r\nelse if (tg3_flag(tp, 40BIT_DMA_BUG)) {\r\npersist_dma_mask = dma_mask = DMA_BIT_MASK(40);\r\n#ifdef CONFIG_HIGHMEM\r\ndma_mask = DMA_BIT_MASK(64);\r\n#endif\r\n} else\r\npersist_dma_mask = dma_mask = DMA_BIT_MASK(64);\r\nif (dma_mask > DMA_BIT_MASK(32)) {\r\nerr = pci_set_dma_mask(pdev, dma_mask);\r\nif (!err) {\r\nfeatures |= NETIF_F_HIGHDMA;\r\nerr = pci_set_consistent_dma_mask(pdev,\r\npersist_dma_mask);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "Unable to obtain 64 bit "\r\n"DMA for consistent allocations\n");\r\ngoto err_out_apeunmap;\r\n}\r\n}\r\n}\r\nif (err || dma_mask == DMA_BIT_MASK(32)) {\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"No usable DMA configuration, aborting\n");\r\ngoto err_out_apeunmap;\r\n}\r\n}\r\ntg3_init_bufmgr_config(tp);\r\nif (tg3_chip_rev_id(tp) != CHIPREV_ID_5700_B0) {\r\nfeatures |= NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_RXCSUM;\r\nif (tg3_flag(tp, 5755_PLUS))\r\nfeatures |= NETIF_F_IPV6_CSUM;\r\n}\r\nif ((tg3_flag(tp, HW_TSO_1) ||\r\ntg3_flag(tp, HW_TSO_2) ||\r\ntg3_flag(tp, HW_TSO_3)) &&\r\n(features & NETIF_F_IP_CSUM))\r\nfeatures |= NETIF_F_TSO;\r\nif (tg3_flag(tp, HW_TSO_2) || tg3_flag(tp, HW_TSO_3)) {\r\nif (features & NETIF_F_IPV6_CSUM)\r\nfeatures |= NETIF_F_TSO6;\r\nif (tg3_flag(tp, HW_TSO_3) ||\r\ntg3_asic_rev(tp) == ASIC_REV_5761 ||\r\n(tg3_asic_rev(tp) == ASIC_REV_5784 &&\r\ntg3_chip_rev(tp) != CHIPREV_5784_AX) ||\r\ntg3_asic_rev(tp) == ASIC_REV_5785 ||\r\ntg3_asic_rev(tp) == ASIC_REV_57780)\r\nfeatures |= NETIF_F_TSO_ECN;\r\n}\r\ndev->features |= features | NETIF_F_HW_VLAN_CTAG_TX |\r\nNETIF_F_HW_VLAN_CTAG_RX;\r\ndev->vlan_features |= features;\r\nif (tg3_asic_rev(tp) != ASIC_REV_5780 &&\r\n!tg3_flag(tp, CPMU_PRESENT))\r\nfeatures |= NETIF_F_LOOPBACK;\r\ndev->hw_features |= features;\r\ndev->priv_flags |= IFF_UNICAST_FLT;\r\nif (tg3_chip_rev_id(tp) == CHIPREV_ID_5705_A1 &&\r\n!tg3_flag(tp, TSO_CAPABLE) &&\r\n!(tr32(TG3PCI_PCISTATE) & PCISTATE_BUS_SPEED_HIGH)) {\r\ntg3_flag_set(tp, MAX_RXPEND_64);\r\ntp->rx_pending = 63;\r\n}\r\nerr = tg3_get_device_address(tp);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"Could not obtain valid ethernet address, aborting\n");\r\ngoto err_out_apeunmap;\r\n}\r\nintmbx = MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW;\r\nrcvmbx = MAILBOX_RCVRET_CON_IDX_0 + TG3_64BIT_REG_LOW;\r\nsndmbx = MAILBOX_SNDHOST_PROD_IDX_0 + TG3_64BIT_REG_LOW;\r\nfor (i = 0; i < tp->irq_max; i++) {\r\nstruct tg3_napi *tnapi = &tp->napi[i];\r\ntnapi->tp = tp;\r\ntnapi->tx_pending = TG3_DEF_TX_RING_PENDING;\r\ntnapi->int_mbox = intmbx;\r\nif (i <= 4)\r\nintmbx += 0x8;\r\nelse\r\nintmbx += 0x4;\r\ntnapi->consmbox = rcvmbx;\r\ntnapi->prodmbox = sndmbx;\r\nif (i)\r\ntnapi->coal_now = HOSTCC_MODE_COAL_VEC1_NOW << (i - 1);\r\nelse\r\ntnapi->coal_now = HOSTCC_MODE_NOW;\r\nif (!tg3_flag(tp, SUPPORT_MSIX))\r\nbreak;\r\nif (!i)\r\ncontinue;\r\nrcvmbx += 0x8;\r\nif (sndmbx & 0x4)\r\nsndmbx -= 0x4;\r\nelse\r\nsndmbx += 0xc;\r\n}\r\nif ((tr32(HOSTCC_MODE) & HOSTCC_MODE_ENABLE) ||\r\n(tr32(WDMAC_MODE) & WDMAC_MODE_ENABLE)) {\r\ntg3_full_lock(tp, 0);\r\ntw32(MEMARB_MODE, MEMARB_MODE_ENABLE);\r\ntg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\r\ntg3_full_unlock(tp);\r\n}\r\nerr = tg3_test_dma(tp);\r\nif (err) {\r\ndev_err(&pdev->dev, "DMA engine test failed, aborting\n");\r\ngoto err_out_apeunmap;\r\n}\r\ntg3_init_coal(tp);\r\npci_set_drvdata(pdev, dev);\r\nif (tg3_asic_rev(tp) == ASIC_REV_5719 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5720 ||\r\ntg3_asic_rev(tp) == ASIC_REV_5762)\r\ntg3_flag_set(tp, PTP_CAPABLE);\r\ntg3_timer_init(tp);\r\ntg3_carrier_off(tp);\r\nerr = register_netdev(dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot register net device, aborting\n");\r\ngoto err_out_apeunmap;\r\n}\r\nif (tg3_flag(tp, PTP_CAPABLE)) {\r\ntg3_ptp_init(tp);\r\ntp->ptp_clock = ptp_clock_register(&tp->ptp_info,\r\n&tp->pdev->dev);\r\nif (IS_ERR(tp->ptp_clock))\r\ntp->ptp_clock = NULL;\r\n}\r\nnetdev_info(dev, "Tigon3 [partno(%s) rev %04x] (%s) MAC address %pM\n",\r\ntp->board_part_number,\r\ntg3_chip_rev_id(tp),\r\ntg3_bus_string(tp, str),\r\ndev->dev_addr);\r\nif (tp->phy_flags & TG3_PHYFLG_IS_CONNECTED) {\r\nstruct phy_device *phydev;\r\nphydev = tp->mdio_bus->phy_map[tp->phy_addr];\r\nnetdev_info(dev,\r\n"attached PHY driver [%s] (mii_bus:phy_addr=%s)\n",\r\nphydev->drv->name, dev_name(&phydev->dev));\r\n} else {\r\nchar *ethtype;\r\nif (tp->phy_flags & TG3_PHYFLG_10_100_ONLY)\r\nethtype = "10/100Base-TX";\r\nelse if (tp->phy_flags & TG3_PHYFLG_ANY_SERDES)\r\nethtype = "1000Base-SX";\r\nelse\r\nethtype = "10/100/1000Base-T";\r\nnetdev_info(dev, "attached PHY is %s (%s Ethernet) "\r\n"(WireSpeed[%d], EEE[%d])\n",\r\ntg3_phy_string(tp), ethtype,\r\n(tp->phy_flags & TG3_PHYFLG_NO_ETH_WIRE_SPEED) == 0,\r\n(tp->phy_flags & TG3_PHYFLG_EEE_CAP) != 0);\r\n}\r\nnetdev_info(dev, "RXcsums[%d] LinkChgREG[%d] MIirq[%d] ASF[%d] TSOcap[%d]\n",\r\n(dev->features & NETIF_F_RXCSUM) != 0,\r\ntg3_flag(tp, USE_LINKCHG_REG) != 0,\r\n(tp->phy_flags & TG3_PHYFLG_USE_MI_INTERRUPT) != 0,\r\ntg3_flag(tp, ENABLE_ASF) != 0,\r\ntg3_flag(tp, TSO_CAPABLE) != 0);\r\nnetdev_info(dev, "dma_rwctrl[%08x] dma_mask[%d-bit]\n",\r\ntp->dma_rwctrl,\r\npdev->dma_mask == DMA_BIT_MASK(32) ? 32 :\r\n((u64)pdev->dma_mask) == DMA_BIT_MASK(40) ? 40 : 64);\r\npci_save_state(pdev);\r\nreturn 0;\r\nerr_out_apeunmap:\r\nif (tp->aperegs) {\r\niounmap(tp->aperegs);\r\ntp->aperegs = NULL;\r\n}\r\nerr_out_iounmap:\r\nif (tp->regs) {\r\niounmap(tp->regs);\r\ntp->regs = NULL;\r\n}\r\nerr_out_free_dev:\r\nfree_netdev(dev);\r\nerr_out_free_res:\r\npci_release_regions(pdev);\r\nerr_out_disable_pdev:\r\nif (pci_is_enabled(pdev))\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void tg3_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nif (dev) {\r\nstruct tg3 *tp = netdev_priv(dev);\r\ntg3_ptp_fini(tp);\r\nrelease_firmware(tp->fw);\r\ntg3_reset_task_cancel(tp);\r\nif (tg3_flag(tp, USE_PHYLIB)) {\r\ntg3_phy_fini(tp);\r\ntg3_mdio_fini(tp);\r\n}\r\nunregister_netdev(dev);\r\nif (tp->aperegs) {\r\niounmap(tp->aperegs);\r\ntp->aperegs = NULL;\r\n}\r\nif (tp->regs) {\r\niounmap(tp->regs);\r\ntp->regs = NULL;\r\n}\r\nfree_netdev(dev);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\n}\r\n}\r\nstatic int tg3_suspend(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct tg3 *tp = netdev_priv(dev);\r\nint err = 0;\r\nrtnl_lock();\r\nif (!netif_running(dev))\r\ngoto unlock;\r\ntg3_reset_task_cancel(tp);\r\ntg3_phy_stop(tp);\r\ntg3_netif_stop(tp);\r\ntg3_timer_stop(tp);\r\ntg3_full_lock(tp, 1);\r\ntg3_disable_ints(tp);\r\ntg3_full_unlock(tp);\r\nnetif_device_detach(dev);\r\ntg3_full_lock(tp, 0);\r\ntg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\r\ntg3_flag_clear(tp, INIT_COMPLETE);\r\ntg3_full_unlock(tp);\r\nerr = tg3_power_down_prepare(tp);\r\nif (err) {\r\nint err2;\r\ntg3_full_lock(tp, 0);\r\ntg3_flag_set(tp, INIT_COMPLETE);\r\nerr2 = tg3_restart_hw(tp, true);\r\nif (err2)\r\ngoto out;\r\ntg3_timer_start(tp);\r\nnetif_device_attach(dev);\r\ntg3_netif_start(tp);\r\nout:\r\ntg3_full_unlock(tp);\r\nif (!err2)\r\ntg3_phy_start(tp);\r\n}\r\nunlock:\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nstatic int tg3_resume(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct tg3 *tp = netdev_priv(dev);\r\nint err = 0;\r\nrtnl_lock();\r\nif (!netif_running(dev))\r\ngoto unlock;\r\nnetif_device_attach(dev);\r\ntg3_full_lock(tp, 0);\r\ntg3_ape_driver_state_change(tp, RESET_KIND_INIT);\r\ntg3_flag_set(tp, INIT_COMPLETE);\r\nerr = tg3_restart_hw(tp,\r\n!(tp->phy_flags & TG3_PHYFLG_KEEP_LINK_ON_PWRDN));\r\nif (err)\r\ngoto out;\r\ntg3_timer_start(tp);\r\ntg3_netif_start(tp);\r\nout:\r\ntg3_full_unlock(tp);\r\nif (!err)\r\ntg3_phy_start(tp);\r\nunlock:\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nstatic void tg3_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct tg3 *tp = netdev_priv(dev);\r\nrtnl_lock();\r\nnetif_device_detach(dev);\r\nif (netif_running(dev))\r\ndev_close(dev);\r\nif (system_state == SYSTEM_POWER_OFF)\r\ntg3_power_down(tp);\r\nrtnl_unlock();\r\n}\r\nstatic pci_ers_result_t tg3_io_error_detected(struct pci_dev *pdev,\r\npci_channel_state_t state)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct tg3 *tp = netdev_priv(netdev);\r\npci_ers_result_t err = PCI_ERS_RESULT_NEED_RESET;\r\nnetdev_info(netdev, "PCI I/O error detected\n");\r\nrtnl_lock();\r\nif (state == pci_channel_io_frozen)\r\ntp->pcierr_recovery = true;\r\nif (!netdev || !netif_running(netdev))\r\ngoto done;\r\ntg3_phy_stop(tp);\r\ntg3_netif_stop(tp);\r\ntg3_timer_stop(tp);\r\ntg3_reset_task_cancel(tp);\r\nnetif_device_detach(netdev);\r\ntg3_full_lock(tp, 0);\r\ntg3_halt(tp, RESET_KIND_SHUTDOWN, 0);\r\ntg3_full_unlock(tp);\r\ndone:\r\nif (state == pci_channel_io_perm_failure) {\r\nif (netdev) {\r\ntg3_napi_enable(tp);\r\ndev_close(netdev);\r\n}\r\nerr = PCI_ERS_RESULT_DISCONNECT;\r\n} else {\r\npci_disable_device(pdev);\r\n}\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nstatic pci_ers_result_t tg3_io_slot_reset(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct tg3 *tp = netdev_priv(netdev);\r\npci_ers_result_t rc = PCI_ERS_RESULT_DISCONNECT;\r\nint err;\r\nrtnl_lock();\r\nif (pci_enable_device(pdev)) {\r\ndev_err(&pdev->dev,\r\n"Cannot re-enable PCI device after reset.\n");\r\ngoto done;\r\n}\r\npci_set_master(pdev);\r\npci_restore_state(pdev);\r\npci_save_state(pdev);\r\nif (!netdev || !netif_running(netdev)) {\r\nrc = PCI_ERS_RESULT_RECOVERED;\r\ngoto done;\r\n}\r\nerr = tg3_power_up(tp);\r\nif (err)\r\ngoto done;\r\nrc = PCI_ERS_RESULT_RECOVERED;\r\ndone:\r\nif (rc != PCI_ERS_RESULT_RECOVERED && netdev && netif_running(netdev)) {\r\ntg3_napi_enable(tp);\r\ndev_close(netdev);\r\n}\r\nrtnl_unlock();\r\nreturn rc;\r\n}\r\nstatic void tg3_io_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct tg3 *tp = netdev_priv(netdev);\r\nint err;\r\nrtnl_lock();\r\nif (!netif_running(netdev))\r\ngoto done;\r\ntg3_full_lock(tp, 0);\r\ntg3_ape_driver_state_change(tp, RESET_KIND_INIT);\r\ntg3_flag_set(tp, INIT_COMPLETE);\r\nerr = tg3_restart_hw(tp, true);\r\nif (err) {\r\ntg3_full_unlock(tp);\r\nnetdev_err(netdev, "Cannot restart hardware after reset.\n");\r\ngoto done;\r\n}\r\nnetif_device_attach(netdev);\r\ntg3_timer_start(tp);\r\ntg3_netif_start(tp);\r\ntg3_full_unlock(tp);\r\ntg3_phy_start(tp);\r\ndone:\r\ntp->pcierr_recovery = false;\r\nrtnl_unlock();\r\n}
