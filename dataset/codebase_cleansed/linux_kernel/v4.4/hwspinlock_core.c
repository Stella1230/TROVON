int __hwspin_trylock(struct hwspinlock *hwlock, int mode, unsigned long *flags)\r\n{\r\nint ret;\r\nBUG_ON(!hwlock);\r\nBUG_ON(!flags && mode == HWLOCK_IRQSTATE);\r\nif (mode == HWLOCK_IRQSTATE)\r\nret = spin_trylock_irqsave(&hwlock->lock, *flags);\r\nelse if (mode == HWLOCK_IRQ)\r\nret = spin_trylock_irq(&hwlock->lock);\r\nelse\r\nret = spin_trylock(&hwlock->lock);\r\nif (!ret)\r\nreturn -EBUSY;\r\nret = hwlock->bank->ops->trylock(hwlock);\r\nif (!ret) {\r\nif (mode == HWLOCK_IRQSTATE)\r\nspin_unlock_irqrestore(&hwlock->lock, *flags);\r\nelse if (mode == HWLOCK_IRQ)\r\nspin_unlock_irq(&hwlock->lock);\r\nelse\r\nspin_unlock(&hwlock->lock);\r\nreturn -EBUSY;\r\n}\r\nmb();\r\nreturn 0;\r\n}\r\nint __hwspin_lock_timeout(struct hwspinlock *hwlock, unsigned int to,\r\nint mode, unsigned long *flags)\r\n{\r\nint ret;\r\nunsigned long expire;\r\nexpire = msecs_to_jiffies(to) + jiffies;\r\nfor (;;) {\r\nret = __hwspin_trylock(hwlock, mode, flags);\r\nif (ret != -EBUSY)\r\nbreak;\r\nif (time_is_before_eq_jiffies(expire))\r\nreturn -ETIMEDOUT;\r\nif (hwlock->bank->ops->relax)\r\nhwlock->bank->ops->relax(hwlock);\r\n}\r\nreturn ret;\r\n}\r\nvoid __hwspin_unlock(struct hwspinlock *hwlock, int mode, unsigned long *flags)\r\n{\r\nBUG_ON(!hwlock);\r\nBUG_ON(!flags && mode == HWLOCK_IRQSTATE);\r\nmb();\r\nhwlock->bank->ops->unlock(hwlock);\r\nif (mode == HWLOCK_IRQSTATE)\r\nspin_unlock_irqrestore(&hwlock->lock, *flags);\r\nelse if (mode == HWLOCK_IRQ)\r\nspin_unlock_irq(&hwlock->lock);\r\nelse\r\nspin_unlock(&hwlock->lock);\r\n}\r\nstatic inline int\r\nof_hwspin_lock_simple_xlate(const struct of_phandle_args *hwlock_spec)\r\n{\r\nif (WARN_ON(hwlock_spec->args_count != 1))\r\nreturn -EINVAL;\r\nreturn hwlock_spec->args[0];\r\n}\r\nint of_hwspin_lock_get_id(struct device_node *np, int index)\r\n{\r\nstruct of_phandle_args args;\r\nstruct hwspinlock *hwlock;\r\nstruct radix_tree_iter iter;\r\nvoid **slot;\r\nint id;\r\nint ret;\r\nret = of_parse_phandle_with_args(np, "hwlocks", "#hwlock-cells", index,\r\n&args);\r\nif (ret)\r\nreturn ret;\r\nret = -EPROBE_DEFER;\r\nrcu_read_lock();\r\nradix_tree_for_each_slot(slot, &hwspinlock_tree, &iter, 0) {\r\nhwlock = radix_tree_deref_slot(slot);\r\nif (unlikely(!hwlock))\r\ncontinue;\r\nif (hwlock->bank->dev->of_node == args.np) {\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (ret < 0)\r\ngoto out;\r\nid = of_hwspin_lock_simple_xlate(&args);\r\nif (id < 0 || id >= hwlock->bank->num_locks) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nid += hwlock->bank->base_id;\r\nout:\r\nof_node_put(args.np);\r\nreturn ret ? ret : id;\r\n}\r\nstatic int hwspin_lock_register_single(struct hwspinlock *hwlock, int id)\r\n{\r\nstruct hwspinlock *tmp;\r\nint ret;\r\nmutex_lock(&hwspinlock_tree_lock);\r\nret = radix_tree_insert(&hwspinlock_tree, id, hwlock);\r\nif (ret) {\r\nif (ret == -EEXIST)\r\npr_err("hwspinlock id %d already exists!\n", id);\r\ngoto out;\r\n}\r\ntmp = radix_tree_tag_set(&hwspinlock_tree, id, HWSPINLOCK_UNUSED);\r\nWARN_ON(tmp != hwlock);\r\nout:\r\nmutex_unlock(&hwspinlock_tree_lock);\r\nreturn 0;\r\n}\r\nstatic struct hwspinlock *hwspin_lock_unregister_single(unsigned int id)\r\n{\r\nstruct hwspinlock *hwlock = NULL;\r\nint ret;\r\nmutex_lock(&hwspinlock_tree_lock);\r\nret = radix_tree_tag_get(&hwspinlock_tree, id, HWSPINLOCK_UNUSED);\r\nif (ret == 0) {\r\npr_err("hwspinlock %d still in use (or not present)\n", id);\r\ngoto out;\r\n}\r\nhwlock = radix_tree_delete(&hwspinlock_tree, id);\r\nif (!hwlock) {\r\npr_err("failed to delete hwspinlock %d\n", id);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&hwspinlock_tree_lock);\r\nreturn hwlock;\r\n}\r\nint hwspin_lock_register(struct hwspinlock_device *bank, struct device *dev,\r\nconst struct hwspinlock_ops *ops, int base_id, int num_locks)\r\n{\r\nstruct hwspinlock *hwlock;\r\nint ret = 0, i;\r\nif (!bank || !ops || !dev || !num_locks || !ops->trylock ||\r\n!ops->unlock) {\r\npr_err("invalid parameters\n");\r\nreturn -EINVAL;\r\n}\r\nbank->dev = dev;\r\nbank->ops = ops;\r\nbank->base_id = base_id;\r\nbank->num_locks = num_locks;\r\nfor (i = 0; i < num_locks; i++) {\r\nhwlock = &bank->lock[i];\r\nspin_lock_init(&hwlock->lock);\r\nhwlock->bank = bank;\r\nret = hwspin_lock_register_single(hwlock, base_id + i);\r\nif (ret)\r\ngoto reg_failed;\r\n}\r\nreturn 0;\r\nreg_failed:\r\nwhile (--i >= 0)\r\nhwspin_lock_unregister_single(base_id + i);\r\nreturn ret;\r\n}\r\nint hwspin_lock_unregister(struct hwspinlock_device *bank)\r\n{\r\nstruct hwspinlock *hwlock, *tmp;\r\nint i;\r\nfor (i = 0; i < bank->num_locks; i++) {\r\nhwlock = &bank->lock[i];\r\ntmp = hwspin_lock_unregister_single(bank->base_id + i);\r\nif (!tmp)\r\nreturn -EBUSY;\r\nWARN_ON(tmp != hwlock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __hwspin_lock_request(struct hwspinlock *hwlock)\r\n{\r\nstruct device *dev = hwlock->bank->dev;\r\nstruct hwspinlock *tmp;\r\nint ret;\r\nif (!try_module_get(dev->driver->owner)) {\r\ndev_err(dev, "%s: can't get owner\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nret = pm_runtime_get_sync(dev);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: can't power on device\n", __func__);\r\npm_runtime_put_noidle(dev);\r\nmodule_put(dev->driver->owner);\r\nreturn ret;\r\n}\r\ntmp = radix_tree_tag_clear(&hwspinlock_tree, hwlock_to_id(hwlock),\r\nHWSPINLOCK_UNUSED);\r\nWARN_ON(tmp != hwlock);\r\nreturn ret;\r\n}\r\nint hwspin_lock_get_id(struct hwspinlock *hwlock)\r\n{\r\nif (!hwlock) {\r\npr_err("invalid hwlock\n");\r\nreturn -EINVAL;\r\n}\r\nreturn hwlock_to_id(hwlock);\r\n}\r\nstruct hwspinlock *hwspin_lock_request(void)\r\n{\r\nstruct hwspinlock *hwlock;\r\nint ret;\r\nmutex_lock(&hwspinlock_tree_lock);\r\nret = radix_tree_gang_lookup_tag(&hwspinlock_tree, (void **)&hwlock,\r\n0, 1, HWSPINLOCK_UNUSED);\r\nif (ret == 0) {\r\npr_warn("a free hwspinlock is not available\n");\r\nhwlock = NULL;\r\ngoto out;\r\n}\r\nWARN_ON(ret > 1);\r\nret = __hwspin_lock_request(hwlock);\r\nif (ret < 0)\r\nhwlock = NULL;\r\nout:\r\nmutex_unlock(&hwspinlock_tree_lock);\r\nreturn hwlock;\r\n}\r\nstruct hwspinlock *hwspin_lock_request_specific(unsigned int id)\r\n{\r\nstruct hwspinlock *hwlock;\r\nint ret;\r\nmutex_lock(&hwspinlock_tree_lock);\r\nhwlock = radix_tree_lookup(&hwspinlock_tree, id);\r\nif (!hwlock) {\r\npr_warn("hwspinlock %u does not exist\n", id);\r\ngoto out;\r\n}\r\nWARN_ON(hwlock_to_id(hwlock) != id);\r\nret = radix_tree_tag_get(&hwspinlock_tree, id, HWSPINLOCK_UNUSED);\r\nif (ret == 0) {\r\npr_warn("hwspinlock %u is already in use\n", id);\r\nhwlock = NULL;\r\ngoto out;\r\n}\r\nret = __hwspin_lock_request(hwlock);\r\nif (ret < 0)\r\nhwlock = NULL;\r\nout:\r\nmutex_unlock(&hwspinlock_tree_lock);\r\nreturn hwlock;\r\n}\r\nint hwspin_lock_free(struct hwspinlock *hwlock)\r\n{\r\nstruct device *dev;\r\nstruct hwspinlock *tmp;\r\nint ret;\r\nif (!hwlock) {\r\npr_err("invalid hwlock\n");\r\nreturn -EINVAL;\r\n}\r\ndev = hwlock->bank->dev;\r\nmutex_lock(&hwspinlock_tree_lock);\r\nret = radix_tree_tag_get(&hwspinlock_tree, hwlock_to_id(hwlock),\r\nHWSPINLOCK_UNUSED);\r\nif (ret == 1) {\r\ndev_err(dev, "%s: hwlock is already free\n", __func__);\r\ndump_stack();\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = pm_runtime_put(dev);\r\nif (ret < 0)\r\ngoto out;\r\ntmp = radix_tree_tag_set(&hwspinlock_tree, hwlock_to_id(hwlock),\r\nHWSPINLOCK_UNUSED);\r\nWARN_ON(tmp != hwlock);\r\nmodule_put(dev->driver->owner);\r\nout:\r\nmutex_unlock(&hwspinlock_tree_lock);\r\nreturn ret;\r\n}
