static inline int unsigned_offsets(struct file *file)\r\n{\r\nreturn file->f_mode & FMODE_UNSIGNED_OFFSET;\r\n}\r\nloff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\r\n{\r\nif (offset < 0 && !unsigned_offsets(file))\r\nreturn -EINVAL;\r\nif (offset > maxsize)\r\nreturn -EINVAL;\r\nif (offset != file->f_pos) {\r\nfile->f_pos = offset;\r\nfile->f_version = 0;\r\n}\r\nreturn offset;\r\n}\r\nloff_t\r\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\r\nloff_t maxsize, loff_t eof)\r\n{\r\nswitch (whence) {\r\ncase SEEK_END:\r\noffset += eof;\r\nbreak;\r\ncase SEEK_CUR:\r\nif (offset == 0)\r\nreturn file->f_pos;\r\nspin_lock(&file->f_lock);\r\noffset = vfs_setpos(file, file->f_pos + offset, maxsize);\r\nspin_unlock(&file->f_lock);\r\nreturn offset;\r\ncase SEEK_DATA:\r\nif (offset >= eof)\r\nreturn -ENXIO;\r\nbreak;\r\ncase SEEK_HOLE:\r\nif (offset >= eof)\r\nreturn -ENXIO;\r\noffset = eof;\r\nbreak;\r\n}\r\nreturn vfs_setpos(file, offset, maxsize);\r\n}\r\nloff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\r\n{\r\nstruct inode *inode = file->f_mapping->host;\r\nreturn generic_file_llseek_size(file, offset, whence,\r\ninode->i_sb->s_maxbytes,\r\ni_size_read(inode));\r\n}\r\nloff_t fixed_size_llseek(struct file *file, loff_t offset, int whence, loff_t size)\r\n{\r\nswitch (whence) {\r\ncase SEEK_SET: case SEEK_CUR: case SEEK_END:\r\nreturn generic_file_llseek_size(file, offset, whence,\r\nsize, size);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nloff_t noop_llseek(struct file *file, loff_t offset, int whence)\r\n{\r\nreturn file->f_pos;\r\n}\r\nloff_t no_llseek(struct file *file, loff_t offset, int whence)\r\n{\r\nreturn -ESPIPE;\r\n}\r\nloff_t default_llseek(struct file *file, loff_t offset, int whence)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nloff_t retval;\r\nmutex_lock(&inode->i_mutex);\r\nswitch (whence) {\r\ncase SEEK_END:\r\noffset += i_size_read(inode);\r\nbreak;\r\ncase SEEK_CUR:\r\nif (offset == 0) {\r\nretval = file->f_pos;\r\ngoto out;\r\n}\r\noffset += file->f_pos;\r\nbreak;\r\ncase SEEK_DATA:\r\nif (offset >= inode->i_size) {\r\nretval = -ENXIO;\r\ngoto out;\r\n}\r\nbreak;\r\ncase SEEK_HOLE:\r\nif (offset >= inode->i_size) {\r\nretval = -ENXIO;\r\ngoto out;\r\n}\r\noffset = inode->i_size;\r\nbreak;\r\n}\r\nretval = -EINVAL;\r\nif (offset >= 0 || unsigned_offsets(file)) {\r\nif (offset != file->f_pos) {\r\nfile->f_pos = offset;\r\nfile->f_version = 0;\r\n}\r\nretval = offset;\r\n}\r\nout:\r\nmutex_unlock(&inode->i_mutex);\r\nreturn retval;\r\n}\r\nloff_t vfs_llseek(struct file *file, loff_t offset, int whence)\r\n{\r\nloff_t (*fn)(struct file *, loff_t, int);\r\nfn = no_llseek;\r\nif (file->f_mode & FMODE_LSEEK) {\r\nif (file->f_op->llseek)\r\nfn = file->f_op->llseek;\r\n}\r\nreturn fn(file, offset, whence);\r\n}\r\nstatic inline struct fd fdget_pos(int fd)\r\n{\r\nreturn __to_fd(__fdget_pos(fd));\r\n}\r\nstatic inline void fdput_pos(struct fd f)\r\n{\r\nif (f.flags & FDPUT_POS_UNLOCK)\r\nmutex_unlock(&f.file->f_pos_lock);\r\nfdput(f);\r\n}\r\nssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos)\r\n{\r\nstruct kiocb kiocb;\r\nssize_t ret;\r\nif (!file->f_op->read_iter)\r\nreturn -EINVAL;\r\ninit_sync_kiocb(&kiocb, file);\r\nkiocb.ki_pos = *ppos;\r\niter->type |= READ;\r\nret = file->f_op->read_iter(&kiocb, iter);\r\nBUG_ON(ret == -EIOCBQUEUED);\r\nif (ret > 0)\r\n*ppos = kiocb.ki_pos;\r\nreturn ret;\r\n}\r\nssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos)\r\n{\r\nstruct kiocb kiocb;\r\nssize_t ret;\r\nif (!file->f_op->write_iter)\r\nreturn -EINVAL;\r\ninit_sync_kiocb(&kiocb, file);\r\nkiocb.ki_pos = *ppos;\r\niter->type |= WRITE;\r\nret = file->f_op->write_iter(&kiocb, iter);\r\nBUG_ON(ret == -EIOCBQUEUED);\r\nif (ret > 0)\r\n*ppos = kiocb.ki_pos;\r\nreturn ret;\r\n}\r\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\r\n{\r\nstruct inode *inode;\r\nloff_t pos;\r\nint retval = -EINVAL;\r\ninode = file_inode(file);\r\nif (unlikely((ssize_t) count < 0))\r\nreturn retval;\r\npos = *ppos;\r\nif (unlikely(pos < 0)) {\r\nif (!unsigned_offsets(file))\r\nreturn retval;\r\nif (count >= -pos)\r\nreturn -EOVERFLOW;\r\n} else if (unlikely((loff_t) (pos + count) < 0)) {\r\nif (!unsigned_offsets(file))\r\nreturn retval;\r\n}\r\nif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\r\nretval = locks_mandatory_area(\r\nread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\r\ninode, file, pos, count);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nretval = security_file_permission(file,\r\nread_write == READ ? MAY_READ : MAY_WRITE);\r\nif (retval)\r\nreturn retval;\r\nreturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\r\n}\r\nstatic ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)\r\n{\r\nstruct iovec iov = { .iov_base = buf, .iov_len = len };\r\nstruct kiocb kiocb;\r\nstruct iov_iter iter;\r\nssize_t ret;\r\ninit_sync_kiocb(&kiocb, filp);\r\nkiocb.ki_pos = *ppos;\r\niov_iter_init(&iter, READ, &iov, 1, len);\r\nret = filp->f_op->read_iter(&kiocb, &iter);\r\nBUG_ON(ret == -EIOCBQUEUED);\r\n*ppos = kiocb.ki_pos;\r\nreturn ret;\r\n}\r\nssize_t __vfs_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *pos)\r\n{\r\nif (file->f_op->read)\r\nreturn file->f_op->read(file, buf, count, pos);\r\nelse if (file->f_op->read_iter)\r\nreturn new_sync_read(file, buf, count, pos);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\r\n{\r\nssize_t ret;\r\nif (!(file->f_mode & FMODE_READ))\r\nreturn -EBADF;\r\nif (!(file->f_mode & FMODE_CAN_READ))\r\nreturn -EINVAL;\r\nif (unlikely(!access_ok(VERIFY_WRITE, buf, count)))\r\nreturn -EFAULT;\r\nret = rw_verify_area(READ, file, pos, count);\r\nif (ret >= 0) {\r\ncount = ret;\r\nret = __vfs_read(file, buf, count, pos);\r\nif (ret > 0) {\r\nfsnotify_access(file);\r\nadd_rchar(current, ret);\r\n}\r\ninc_syscr(current);\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\r\n{\r\nstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\r\nstruct kiocb kiocb;\r\nstruct iov_iter iter;\r\nssize_t ret;\r\ninit_sync_kiocb(&kiocb, filp);\r\nkiocb.ki_pos = *ppos;\r\niov_iter_init(&iter, WRITE, &iov, 1, len);\r\nret = filp->f_op->write_iter(&kiocb, &iter);\r\nBUG_ON(ret == -EIOCBQUEUED);\r\nif (ret > 0)\r\n*ppos = kiocb.ki_pos;\r\nreturn ret;\r\n}\r\nssize_t __vfs_write(struct file *file, const char __user *p, size_t count,\r\nloff_t *pos)\r\n{\r\nif (file->f_op->write)\r\nreturn file->f_op->write(file, p, count, pos);\r\nelse if (file->f_op->write_iter)\r\nreturn new_sync_write(file, p, count, pos);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nssize_t __kernel_write(struct file *file, const char *buf, size_t count, loff_t *pos)\r\n{\r\nmm_segment_t old_fs;\r\nconst char __user *p;\r\nssize_t ret;\r\nif (!(file->f_mode & FMODE_CAN_WRITE))\r\nreturn -EINVAL;\r\nold_fs = get_fs();\r\nset_fs(get_ds());\r\np = (__force const char __user *)buf;\r\nif (count > MAX_RW_COUNT)\r\ncount = MAX_RW_COUNT;\r\nret = __vfs_write(file, p, count, pos);\r\nset_fs(old_fs);\r\nif (ret > 0) {\r\nfsnotify_modify(file);\r\nadd_wchar(current, ret);\r\n}\r\ninc_syscw(current);\r\nreturn ret;\r\n}\r\nssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)\r\n{\r\nssize_t ret;\r\nif (!(file->f_mode & FMODE_WRITE))\r\nreturn -EBADF;\r\nif (!(file->f_mode & FMODE_CAN_WRITE))\r\nreturn -EINVAL;\r\nif (unlikely(!access_ok(VERIFY_READ, buf, count)))\r\nreturn -EFAULT;\r\nret = rw_verify_area(WRITE, file, pos, count);\r\nif (ret >= 0) {\r\ncount = ret;\r\nfile_start_write(file);\r\nret = __vfs_write(file, buf, count, pos);\r\nif (ret > 0) {\r\nfsnotify_modify(file);\r\nadd_wchar(current, ret);\r\n}\r\ninc_syscw(current);\r\nfile_end_write(file);\r\n}\r\nreturn ret;\r\n}\r\nstatic inline loff_t file_pos_read(struct file *file)\r\n{\r\nreturn file->f_pos;\r\n}\r\nstatic inline void file_pos_write(struct file *file, loff_t pos)\r\n{\r\nfile->f_pos = pos;\r\n}\r\nunsigned long iov_shorten(struct iovec *iov, unsigned long nr_segs, size_t to)\r\n{\r\nunsigned long seg = 0;\r\nsize_t len = 0;\r\nwhile (seg < nr_segs) {\r\nseg++;\r\nif (len + iov->iov_len >= to) {\r\niov->iov_len = to - len;\r\nbreak;\r\n}\r\nlen += iov->iov_len;\r\niov++;\r\n}\r\nreturn seg;\r\n}\r\nstatic ssize_t do_iter_readv_writev(struct file *filp, struct iov_iter *iter,\r\nloff_t *ppos, iter_fn_t fn)\r\n{\r\nstruct kiocb kiocb;\r\nssize_t ret;\r\ninit_sync_kiocb(&kiocb, filp);\r\nkiocb.ki_pos = *ppos;\r\nret = fn(&kiocb, iter);\r\nBUG_ON(ret == -EIOCBQUEUED);\r\n*ppos = kiocb.ki_pos;\r\nreturn ret;\r\n}\r\nstatic ssize_t do_loop_readv_writev(struct file *filp, struct iov_iter *iter,\r\nloff_t *ppos, io_fn_t fn)\r\n{\r\nssize_t ret = 0;\r\nwhile (iov_iter_count(iter)) {\r\nstruct iovec iovec = iov_iter_iovec(iter);\r\nssize_t nr;\r\nnr = fn(filp, iovec.iov_base, iovec.iov_len, ppos);\r\nif (nr < 0) {\r\nif (!ret)\r\nret = nr;\r\nbreak;\r\n}\r\nret += nr;\r\nif (nr != iovec.iov_len)\r\nbreak;\r\niov_iter_advance(iter, nr);\r\n}\r\nreturn ret;\r\n}\r\nssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,\r\nunsigned long nr_segs, unsigned long fast_segs,\r\nstruct iovec *fast_pointer,\r\nstruct iovec **ret_pointer)\r\n{\r\nunsigned long seg;\r\nssize_t ret;\r\nstruct iovec *iov = fast_pointer;\r\nif (nr_segs == 0) {\r\nret = 0;\r\ngoto out;\r\n}\r\nif (nr_segs > UIO_MAXIOV) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (nr_segs > fast_segs) {\r\niov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL);\r\nif (iov == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\nif (copy_from_user(iov, uvector, nr_segs*sizeof(*uvector))) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nret = 0;\r\nfor (seg = 0; seg < nr_segs; seg++) {\r\nvoid __user *buf = iov[seg].iov_base;\r\nssize_t len = (ssize_t)iov[seg].iov_len;\r\nif (len < 0) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (type >= 0\r\n&& unlikely(!access_ok(vrfy_dir(type), buf, len))) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nif (len > MAX_RW_COUNT - ret) {\r\nlen = MAX_RW_COUNT - ret;\r\niov[seg].iov_len = len;\r\n}\r\nret += len;\r\n}\r\nout:\r\n*ret_pointer = iov;\r\nreturn ret;\r\n}\r\nstatic ssize_t do_readv_writev(int type, struct file *file,\r\nconst struct iovec __user * uvector,\r\nunsigned long nr_segs, loff_t *pos)\r\n{\r\nsize_t tot_len;\r\nstruct iovec iovstack[UIO_FASTIOV];\r\nstruct iovec *iov = iovstack;\r\nstruct iov_iter iter;\r\nssize_t ret;\r\nio_fn_t fn;\r\niter_fn_t iter_fn;\r\nret = import_iovec(type, uvector, nr_segs,\r\nARRAY_SIZE(iovstack), &iov, &iter);\r\nif (ret < 0)\r\nreturn ret;\r\ntot_len = iov_iter_count(&iter);\r\nif (!tot_len)\r\ngoto out;\r\nret = rw_verify_area(type, file, pos, tot_len);\r\nif (ret < 0)\r\ngoto out;\r\nif (type == READ) {\r\nfn = file->f_op->read;\r\niter_fn = file->f_op->read_iter;\r\n} else {\r\nfn = (io_fn_t)file->f_op->write;\r\niter_fn = file->f_op->write_iter;\r\nfile_start_write(file);\r\n}\r\nif (iter_fn)\r\nret = do_iter_readv_writev(file, &iter, pos, iter_fn);\r\nelse\r\nret = do_loop_readv_writev(file, &iter, pos, fn);\r\nif (type != READ)\r\nfile_end_write(file);\r\nout:\r\nkfree(iov);\r\nif ((ret + (type == READ)) > 0) {\r\nif (type == READ)\r\nfsnotify_access(file);\r\nelse\r\nfsnotify_modify(file);\r\n}\r\nreturn ret;\r\n}\r\nssize_t vfs_readv(struct file *file, const struct iovec __user *vec,\r\nunsigned long vlen, loff_t *pos)\r\n{\r\nif (!(file->f_mode & FMODE_READ))\r\nreturn -EBADF;\r\nif (!(file->f_mode & FMODE_CAN_READ))\r\nreturn -EINVAL;\r\nreturn do_readv_writev(READ, file, vec, vlen, pos);\r\n}\r\nssize_t vfs_writev(struct file *file, const struct iovec __user *vec,\r\nunsigned long vlen, loff_t *pos)\r\n{\r\nif (!(file->f_mode & FMODE_WRITE))\r\nreturn -EBADF;\r\nif (!(file->f_mode & FMODE_CAN_WRITE))\r\nreturn -EINVAL;\r\nreturn do_readv_writev(WRITE, file, vec, vlen, pos);\r\n}\r\nstatic inline loff_t pos_from_hilo(unsigned long high, unsigned long low)\r\n{\r\n#define HALF_LONG_BITS (BITS_PER_LONG / 2)\r\nreturn (((loff_t)high << HALF_LONG_BITS) << HALF_LONG_BITS) | low;\r\n}\r\nstatic ssize_t compat_do_readv_writev(int type, struct file *file,\r\nconst struct compat_iovec __user *uvector,\r\nunsigned long nr_segs, loff_t *pos)\r\n{\r\ncompat_ssize_t tot_len;\r\nstruct iovec iovstack[UIO_FASTIOV];\r\nstruct iovec *iov = iovstack;\r\nstruct iov_iter iter;\r\nssize_t ret;\r\nio_fn_t fn;\r\niter_fn_t iter_fn;\r\nret = compat_import_iovec(type, uvector, nr_segs,\r\nUIO_FASTIOV, &iov, &iter);\r\nif (ret < 0)\r\nreturn ret;\r\ntot_len = iov_iter_count(&iter);\r\nif (!tot_len)\r\ngoto out;\r\nret = rw_verify_area(type, file, pos, tot_len);\r\nif (ret < 0)\r\ngoto out;\r\nif (type == READ) {\r\nfn = file->f_op->read;\r\niter_fn = file->f_op->read_iter;\r\n} else {\r\nfn = (io_fn_t)file->f_op->write;\r\niter_fn = file->f_op->write_iter;\r\nfile_start_write(file);\r\n}\r\nif (iter_fn)\r\nret = do_iter_readv_writev(file, &iter, pos, iter_fn);\r\nelse\r\nret = do_loop_readv_writev(file, &iter, pos, fn);\r\nif (type != READ)\r\nfile_end_write(file);\r\nout:\r\nkfree(iov);\r\nif ((ret + (type == READ)) > 0) {\r\nif (type == READ)\r\nfsnotify_access(file);\r\nelse\r\nfsnotify_modify(file);\r\n}\r\nreturn ret;\r\n}\r\nstatic size_t compat_readv(struct file *file,\r\nconst struct compat_iovec __user *vec,\r\nunsigned long vlen, loff_t *pos)\r\n{\r\nssize_t ret = -EBADF;\r\nif (!(file->f_mode & FMODE_READ))\r\ngoto out;\r\nret = -EINVAL;\r\nif (!(file->f_mode & FMODE_CAN_READ))\r\ngoto out;\r\nret = compat_do_readv_writev(READ, file, vec, vlen, pos);\r\nout:\r\nif (ret > 0)\r\nadd_rchar(current, ret);\r\ninc_syscr(current);\r\nreturn ret;\r\n}\r\nstatic long __compat_sys_preadv64(unsigned long fd,\r\nconst struct compat_iovec __user *vec,\r\nunsigned long vlen, loff_t pos)\r\n{\r\nstruct fd f;\r\nssize_t ret;\r\nif (pos < 0)\r\nreturn -EINVAL;\r\nf = fdget(fd);\r\nif (!f.file)\r\nreturn -EBADF;\r\nret = -ESPIPE;\r\nif (f.file->f_mode & FMODE_PREAD)\r\nret = compat_readv(f.file, vec, vlen, &pos);\r\nfdput(f);\r\nreturn ret;\r\n}\r\nstatic size_t compat_writev(struct file *file,\r\nconst struct compat_iovec __user *vec,\r\nunsigned long vlen, loff_t *pos)\r\n{\r\nssize_t ret = -EBADF;\r\nif (!(file->f_mode & FMODE_WRITE))\r\ngoto out;\r\nret = -EINVAL;\r\nif (!(file->f_mode & FMODE_CAN_WRITE))\r\ngoto out;\r\nret = compat_do_readv_writev(WRITE, file, vec, vlen, pos);\r\nout:\r\nif (ret > 0)\r\nadd_wchar(current, ret);\r\ninc_syscw(current);\r\nreturn ret;\r\n}\r\nstatic long __compat_sys_pwritev64(unsigned long fd,\r\nconst struct compat_iovec __user *vec,\r\nunsigned long vlen, loff_t pos)\r\n{\r\nstruct fd f;\r\nssize_t ret;\r\nif (pos < 0)\r\nreturn -EINVAL;\r\nf = fdget(fd);\r\nif (!f.file)\r\nreturn -EBADF;\r\nret = -ESPIPE;\r\nif (f.file->f_mode & FMODE_PWRITE)\r\nret = compat_writev(f.file, vec, vlen, &pos);\r\nfdput(f);\r\nreturn ret;\r\n}\r\nstatic ssize_t do_sendfile(int out_fd, int in_fd, loff_t *ppos,\r\nsize_t count, loff_t max)\r\n{\r\nstruct fd in, out;\r\nstruct inode *in_inode, *out_inode;\r\nloff_t pos;\r\nloff_t out_pos;\r\nssize_t retval;\r\nint fl;\r\nretval = -EBADF;\r\nin = fdget(in_fd);\r\nif (!in.file)\r\ngoto out;\r\nif (!(in.file->f_mode & FMODE_READ))\r\ngoto fput_in;\r\nretval = -ESPIPE;\r\nif (!ppos) {\r\npos = in.file->f_pos;\r\n} else {\r\npos = *ppos;\r\nif (!(in.file->f_mode & FMODE_PREAD))\r\ngoto fput_in;\r\n}\r\nretval = rw_verify_area(READ, in.file, &pos, count);\r\nif (retval < 0)\r\ngoto fput_in;\r\ncount = retval;\r\nretval = -EBADF;\r\nout = fdget(out_fd);\r\nif (!out.file)\r\ngoto fput_in;\r\nif (!(out.file->f_mode & FMODE_WRITE))\r\ngoto fput_out;\r\nretval = -EINVAL;\r\nin_inode = file_inode(in.file);\r\nout_inode = file_inode(out.file);\r\nout_pos = out.file->f_pos;\r\nretval = rw_verify_area(WRITE, out.file, &out_pos, count);\r\nif (retval < 0)\r\ngoto fput_out;\r\ncount = retval;\r\nif (!max)\r\nmax = min(in_inode->i_sb->s_maxbytes, out_inode->i_sb->s_maxbytes);\r\nif (unlikely(pos + count > max)) {\r\nretval = -EOVERFLOW;\r\nif (pos >= max)\r\ngoto fput_out;\r\ncount = max - pos;\r\n}\r\nfl = 0;\r\n#if 0\r\nif (in.file->f_flags & O_NONBLOCK)\r\nfl = SPLICE_F_NONBLOCK;\r\n#endif\r\nfile_start_write(out.file);\r\nretval = do_splice_direct(in.file, &pos, out.file, &out_pos, count, fl);\r\nfile_end_write(out.file);\r\nif (retval > 0) {\r\nadd_rchar(current, retval);\r\nadd_wchar(current, retval);\r\nfsnotify_access(in.file);\r\nfsnotify_modify(out.file);\r\nout.file->f_pos = out_pos;\r\nif (ppos)\r\n*ppos = pos;\r\nelse\r\nin.file->f_pos = pos;\r\n}\r\ninc_syscr(current);\r\ninc_syscw(current);\r\nif (pos > max)\r\nretval = -EOVERFLOW;\r\nfput_out:\r\nfdput(out);\r\nfput_in:\r\nfdput(in);\r\nout:\r\nreturn retval;\r\n}
