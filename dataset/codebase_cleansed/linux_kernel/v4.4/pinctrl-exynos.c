static inline struct exynos_irq_chip *to_exynos_irq_chip(struct irq_chip *chip)\r\n{\r\nreturn container_of(chip, struct exynos_irq_chip, chip);\r\n}\r\nstatic void exynos_irq_mask(struct irq_data *irqd)\r\n{\r\nstruct irq_chip *chip = irq_data_get_irq_chip(irqd);\r\nstruct exynos_irq_chip *our_chip = to_exynos_irq_chip(chip);\r\nstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\r\nstruct samsung_pinctrl_drv_data *d = bank->drvdata;\r\nunsigned long reg_mask = our_chip->eint_mask + bank->eint_offset;\r\nunsigned long mask;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bank->slock, flags);\r\nmask = readl(d->virt_base + reg_mask);\r\nmask |= 1 << irqd->hwirq;\r\nwritel(mask, d->virt_base + reg_mask);\r\nspin_unlock_irqrestore(&bank->slock, flags);\r\n}\r\nstatic void exynos_irq_ack(struct irq_data *irqd)\r\n{\r\nstruct irq_chip *chip = irq_data_get_irq_chip(irqd);\r\nstruct exynos_irq_chip *our_chip = to_exynos_irq_chip(chip);\r\nstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\r\nstruct samsung_pinctrl_drv_data *d = bank->drvdata;\r\nunsigned long reg_pend = our_chip->eint_pend + bank->eint_offset;\r\nwritel(1 << irqd->hwirq, d->virt_base + reg_pend);\r\n}\r\nstatic void exynos_irq_unmask(struct irq_data *irqd)\r\n{\r\nstruct irq_chip *chip = irq_data_get_irq_chip(irqd);\r\nstruct exynos_irq_chip *our_chip = to_exynos_irq_chip(chip);\r\nstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\r\nstruct samsung_pinctrl_drv_data *d = bank->drvdata;\r\nunsigned long reg_mask = our_chip->eint_mask + bank->eint_offset;\r\nunsigned long mask;\r\nunsigned long flags;\r\nif (irqd_get_trigger_type(irqd) & IRQ_TYPE_LEVEL_MASK)\r\nexynos_irq_ack(irqd);\r\nspin_lock_irqsave(&bank->slock, flags);\r\nmask = readl(d->virt_base + reg_mask);\r\nmask &= ~(1 << irqd->hwirq);\r\nwritel(mask, d->virt_base + reg_mask);\r\nspin_unlock_irqrestore(&bank->slock, flags);\r\n}\r\nstatic int exynos_irq_set_type(struct irq_data *irqd, unsigned int type)\r\n{\r\nstruct irq_chip *chip = irq_data_get_irq_chip(irqd);\r\nstruct exynos_irq_chip *our_chip = to_exynos_irq_chip(chip);\r\nstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\r\nstruct samsung_pinctrl_drv_data *d = bank->drvdata;\r\nunsigned int shift = EXYNOS_EINT_CON_LEN * irqd->hwirq;\r\nunsigned int con, trig_type;\r\nunsigned long reg_con = our_chip->eint_con + bank->eint_offset;\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\ntrig_type = EXYNOS_EINT_EDGE_RISING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ntrig_type = EXYNOS_EINT_EDGE_FALLING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\ntrig_type = EXYNOS_EINT_EDGE_BOTH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ntrig_type = EXYNOS_EINT_LEVEL_HIGH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ntrig_type = EXYNOS_EINT_LEVEL_LOW;\r\nbreak;\r\ndefault:\r\npr_err("unsupported external interrupt type\n");\r\nreturn -EINVAL;\r\n}\r\nif (type & IRQ_TYPE_EDGE_BOTH)\r\nirq_set_handler_locked(irqd, handle_edge_irq);\r\nelse\r\nirq_set_handler_locked(irqd, handle_level_irq);\r\ncon = readl(d->virt_base + reg_con);\r\ncon &= ~(EXYNOS_EINT_CON_MASK << shift);\r\ncon |= trig_type << shift;\r\nwritel(con, d->virt_base + reg_con);\r\nreturn 0;\r\n}\r\nstatic int exynos_irq_request_resources(struct irq_data *irqd)\r\n{\r\nstruct irq_chip *chip = irq_data_get_irq_chip(irqd);\r\nstruct exynos_irq_chip *our_chip = to_exynos_irq_chip(chip);\r\nstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\r\nconst struct samsung_pin_bank_type *bank_type = bank->type;\r\nstruct samsung_pinctrl_drv_data *d = bank->drvdata;\r\nunsigned int shift = EXYNOS_EINT_CON_LEN * irqd->hwirq;\r\nunsigned long reg_con = our_chip->eint_con + bank->eint_offset;\r\nunsigned long flags;\r\nunsigned int mask;\r\nunsigned int con;\r\nint ret;\r\nret = gpiochip_lock_as_irq(&bank->gpio_chip, irqd->hwirq);\r\nif (ret) {\r\ndev_err(bank->gpio_chip.dev, "unable to lock pin %s-%lu IRQ\n",\r\nbank->name, irqd->hwirq);\r\nreturn ret;\r\n}\r\nreg_con = bank->pctl_offset + bank_type->reg_offset[PINCFG_TYPE_FUNC];\r\nshift = irqd->hwirq * bank_type->fld_width[PINCFG_TYPE_FUNC];\r\nmask = (1 << bank_type->fld_width[PINCFG_TYPE_FUNC]) - 1;\r\nspin_lock_irqsave(&bank->slock, flags);\r\ncon = readl(d->virt_base + reg_con);\r\ncon &= ~(mask << shift);\r\ncon |= EXYNOS_EINT_FUNC << shift;\r\nwritel(con, d->virt_base + reg_con);\r\nspin_unlock_irqrestore(&bank->slock, flags);\r\nexynos_irq_unmask(irqd);\r\nreturn 0;\r\n}\r\nstatic void exynos_irq_release_resources(struct irq_data *irqd)\r\n{\r\nstruct irq_chip *chip = irq_data_get_irq_chip(irqd);\r\nstruct exynos_irq_chip *our_chip = to_exynos_irq_chip(chip);\r\nstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\r\nconst struct samsung_pin_bank_type *bank_type = bank->type;\r\nstruct samsung_pinctrl_drv_data *d = bank->drvdata;\r\nunsigned int shift = EXYNOS_EINT_CON_LEN * irqd->hwirq;\r\nunsigned long reg_con = our_chip->eint_con + bank->eint_offset;\r\nunsigned long flags;\r\nunsigned int mask;\r\nunsigned int con;\r\nreg_con = bank->pctl_offset + bank_type->reg_offset[PINCFG_TYPE_FUNC];\r\nshift = irqd->hwirq * bank_type->fld_width[PINCFG_TYPE_FUNC];\r\nmask = (1 << bank_type->fld_width[PINCFG_TYPE_FUNC]) - 1;\r\nexynos_irq_mask(irqd);\r\nspin_lock_irqsave(&bank->slock, flags);\r\ncon = readl(d->virt_base + reg_con);\r\ncon &= ~(mask << shift);\r\ncon |= FUNC_INPUT << shift;\r\nwritel(con, d->virt_base + reg_con);\r\nspin_unlock_irqrestore(&bank->slock, flags);\r\ngpiochip_unlock_as_irq(&bank->gpio_chip, irqd->hwirq);\r\n}\r\nstatic int exynos_eint_irq_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct samsung_pin_bank *b = h->host_data;\r\nirq_set_chip_data(virq, b);\r\nirq_set_chip_and_handler(virq, &b->irq_chip->chip,\r\nhandle_level_irq);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t exynos_eint_gpio_irq(int irq, void *data)\r\n{\r\nstruct samsung_pinctrl_drv_data *d = data;\r\nstruct samsung_pin_bank *bank = d->pin_banks;\r\nunsigned int svc, group, pin, virq;\r\nsvc = readl(d->virt_base + EXYNOS_SVC_OFFSET);\r\ngroup = EXYNOS_SVC_GROUP(svc);\r\npin = svc & EXYNOS_SVC_NUM_MASK;\r\nif (!group)\r\nreturn IRQ_HANDLED;\r\nbank += (group - 1);\r\nvirq = irq_linear_revmap(bank->irq_domain, pin);\r\nif (!virq)\r\nreturn IRQ_NONE;\r\ngeneric_handle_irq(virq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int exynos_eint_gpio_init(struct samsung_pinctrl_drv_data *d)\r\n{\r\nstruct samsung_pin_bank *bank;\r\nstruct device *dev = d->dev;\r\nint ret;\r\nint i;\r\nif (!d->irq) {\r\ndev_err(dev, "irq number not available\n");\r\nreturn -EINVAL;\r\n}\r\nret = devm_request_irq(dev, d->irq, exynos_eint_gpio_irq,\r\n0, dev_name(dev), d);\r\nif (ret) {\r\ndev_err(dev, "irq request failed\n");\r\nreturn -ENXIO;\r\n}\r\nbank = d->pin_banks;\r\nfor (i = 0; i < d->nr_banks; ++i, ++bank) {\r\nif (bank->eint_type != EINT_TYPE_GPIO)\r\ncontinue;\r\nbank->irq_domain = irq_domain_add_linear(bank->of_node,\r\nbank->nr_pins, &exynos_eint_irqd_ops, bank);\r\nif (!bank->irq_domain) {\r\ndev_err(dev, "gpio irq domain add failed\n");\r\nret = -ENXIO;\r\ngoto err_domains;\r\n}\r\nbank->soc_priv = devm_kzalloc(d->dev,\r\nsizeof(struct exynos_eint_gpio_save), GFP_KERNEL);\r\nif (!bank->soc_priv) {\r\nirq_domain_remove(bank->irq_domain);\r\nret = -ENOMEM;\r\ngoto err_domains;\r\n}\r\nbank->irq_chip = &exynos_gpio_irq_chip;\r\n}\r\nreturn 0;\r\nerr_domains:\r\nfor (--i, --bank; i >= 0; --i, --bank) {\r\nif (bank->eint_type != EINT_TYPE_GPIO)\r\ncontinue;\r\nirq_domain_remove(bank->irq_domain);\r\n}\r\nreturn ret;\r\n}\r\nu32 exynos_get_eint_wake_mask(void)\r\n{\r\nreturn exynos_eint_wake_mask;\r\n}\r\nstatic int exynos_wkup_irq_set_wake(struct irq_data *irqd, unsigned int on)\r\n{\r\nstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\r\nunsigned long bit = 1UL << (2 * bank->eint_offset + irqd->hwirq);\r\npr_info("wake %s for irq %d\n", on ? "enabled" : "disabled", irqd->irq);\r\nif (!on)\r\nexynos_eint_wake_mask |= bit;\r\nelse\r\nexynos_eint_wake_mask &= ~bit;\r\nreturn 0;\r\n}\r\nstatic void exynos_irq_eint0_15(struct irq_desc *desc)\r\n{\r\nstruct exynos_weint_data *eintd = irq_desc_get_handler_data(desc);\r\nstruct samsung_pin_bank *bank = eintd->bank;\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nint eint_irq;\r\nchained_irq_enter(chip, desc);\r\nchip->irq_mask(&desc->irq_data);\r\nif (chip->irq_ack)\r\nchip->irq_ack(&desc->irq_data);\r\neint_irq = irq_linear_revmap(bank->irq_domain, eintd->irq);\r\ngeneric_handle_irq(eint_irq);\r\nchip->irq_unmask(&desc->irq_data);\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic inline void exynos_irq_demux_eint(unsigned long pend,\r\nstruct irq_domain *domain)\r\n{\r\nunsigned int irq;\r\nwhile (pend) {\r\nirq = fls(pend) - 1;\r\ngeneric_handle_irq(irq_find_mapping(domain, irq));\r\npend &= ~(1 << irq);\r\n}\r\n}\r\nstatic void exynos_irq_demux_eint16_31(struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct exynos_muxed_weint_data *eintd = irq_desc_get_handler_data(desc);\r\nstruct samsung_pinctrl_drv_data *d = eintd->banks[0]->drvdata;\r\nunsigned long pend;\r\nunsigned long mask;\r\nint i;\r\nchained_irq_enter(chip, desc);\r\nfor (i = 0; i < eintd->nr_banks; ++i) {\r\nstruct samsung_pin_bank *b = eintd->banks[i];\r\npend = readl(d->virt_base + b->irq_chip->eint_pend\r\n+ b->eint_offset);\r\nmask = readl(d->virt_base + b->irq_chip->eint_mask\r\n+ b->eint_offset);\r\nexynos_irq_demux_eint(pend & ~mask, b->irq_domain);\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int exynos_eint_wkup_init(struct samsung_pinctrl_drv_data *d)\r\n{\r\nstruct device *dev = d->dev;\r\nstruct device_node *wkup_np = NULL;\r\nstruct device_node *np;\r\nstruct samsung_pin_bank *bank;\r\nstruct exynos_weint_data *weint_data;\r\nstruct exynos_muxed_weint_data *muxed_data;\r\nstruct exynos_irq_chip *irq_chip;\r\nunsigned int muxed_banks = 0;\r\nunsigned int i;\r\nint idx, irq;\r\nfor_each_child_of_node(dev->of_node, np) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(exynos_wkup_irq_ids, np);\r\nif (match) {\r\nirq_chip = kmemdup(match->data,\r\nsizeof(*irq_chip), GFP_KERNEL);\r\nwkup_np = np;\r\nbreak;\r\n}\r\n}\r\nif (!wkup_np)\r\nreturn -ENODEV;\r\nbank = d->pin_banks;\r\nfor (i = 0; i < d->nr_banks; ++i, ++bank) {\r\nif (bank->eint_type != EINT_TYPE_WKUP)\r\ncontinue;\r\nbank->irq_domain = irq_domain_add_linear(bank->of_node,\r\nbank->nr_pins, &exynos_eint_irqd_ops, bank);\r\nif (!bank->irq_domain) {\r\ndev_err(dev, "wkup irq domain add failed\n");\r\nreturn -ENXIO;\r\n}\r\nbank->irq_chip = irq_chip;\r\nif (!of_find_property(bank->of_node, "interrupts", NULL)) {\r\nbank->eint_type = EINT_TYPE_WKUP_MUX;\r\n++muxed_banks;\r\ncontinue;\r\n}\r\nweint_data = devm_kzalloc(dev, bank->nr_pins\r\n* sizeof(*weint_data), GFP_KERNEL);\r\nif (!weint_data) {\r\ndev_err(dev, "could not allocate memory for weint_data\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (idx = 0; idx < bank->nr_pins; ++idx) {\r\nirq = irq_of_parse_and_map(bank->of_node, idx);\r\nif (!irq) {\r\ndev_err(dev, "irq number for eint-%s-%d not found\n",\r\nbank->name, idx);\r\ncontinue;\r\n}\r\nweint_data[idx].irq = idx;\r\nweint_data[idx].bank = bank;\r\nirq_set_chained_handler_and_data(irq,\r\nexynos_irq_eint0_15,\r\n&weint_data[idx]);\r\n}\r\n}\r\nif (!muxed_banks)\r\nreturn 0;\r\nirq = irq_of_parse_and_map(wkup_np, 0);\r\nif (!irq) {\r\ndev_err(dev, "irq number for muxed EINTs not found\n");\r\nreturn 0;\r\n}\r\nmuxed_data = devm_kzalloc(dev, sizeof(*muxed_data)\r\n+ muxed_banks*sizeof(struct samsung_pin_bank *), GFP_KERNEL);\r\nif (!muxed_data) {\r\ndev_err(dev, "could not allocate memory for muxed_data\n");\r\nreturn -ENOMEM;\r\n}\r\nirq_set_chained_handler_and_data(irq, exynos_irq_demux_eint16_31,\r\nmuxed_data);\r\nbank = d->pin_banks;\r\nidx = 0;\r\nfor (i = 0; i < d->nr_banks; ++i, ++bank) {\r\nif (bank->eint_type != EINT_TYPE_WKUP_MUX)\r\ncontinue;\r\nmuxed_data->banks[idx++] = bank;\r\n}\r\nmuxed_data->nr_banks = muxed_banks;\r\nreturn 0;\r\n}\r\nstatic void exynos_pinctrl_suspend_bank(\r\nstruct samsung_pinctrl_drv_data *drvdata,\r\nstruct samsung_pin_bank *bank)\r\n{\r\nstruct exynos_eint_gpio_save *save = bank->soc_priv;\r\nvoid __iomem *regs = drvdata->virt_base;\r\nsave->eint_con = readl(regs + EXYNOS_GPIO_ECON_OFFSET\r\n+ bank->eint_offset);\r\nsave->eint_fltcon0 = readl(regs + EXYNOS_GPIO_EFLTCON_OFFSET\r\n+ 2 * bank->eint_offset);\r\nsave->eint_fltcon1 = readl(regs + EXYNOS_GPIO_EFLTCON_OFFSET\r\n+ 2 * bank->eint_offset + 4);\r\npr_debug("%s: save con %#010x\n", bank->name, save->eint_con);\r\npr_debug("%s: save fltcon0 %#010x\n", bank->name, save->eint_fltcon0);\r\npr_debug("%s: save fltcon1 %#010x\n", bank->name, save->eint_fltcon1);\r\n}\r\nstatic void exynos_pinctrl_suspend(struct samsung_pinctrl_drv_data *drvdata)\r\n{\r\nstruct samsung_pin_bank *bank = drvdata->pin_banks;\r\nint i;\r\nfor (i = 0; i < drvdata->nr_banks; ++i, ++bank)\r\nif (bank->eint_type == EINT_TYPE_GPIO)\r\nexynos_pinctrl_suspend_bank(drvdata, bank);\r\n}\r\nstatic void exynos_pinctrl_resume_bank(\r\nstruct samsung_pinctrl_drv_data *drvdata,\r\nstruct samsung_pin_bank *bank)\r\n{\r\nstruct exynos_eint_gpio_save *save = bank->soc_priv;\r\nvoid __iomem *regs = drvdata->virt_base;\r\npr_debug("%s: con %#010x => %#010x\n", bank->name,\r\nreadl(regs + EXYNOS_GPIO_ECON_OFFSET\r\n+ bank->eint_offset), save->eint_con);\r\npr_debug("%s: fltcon0 %#010x => %#010x\n", bank->name,\r\nreadl(regs + EXYNOS_GPIO_EFLTCON_OFFSET\r\n+ 2 * bank->eint_offset), save->eint_fltcon0);\r\npr_debug("%s: fltcon1 %#010x => %#010x\n", bank->name,\r\nreadl(regs + EXYNOS_GPIO_EFLTCON_OFFSET\r\n+ 2 * bank->eint_offset + 4), save->eint_fltcon1);\r\nwritel(save->eint_con, regs + EXYNOS_GPIO_ECON_OFFSET\r\n+ bank->eint_offset);\r\nwritel(save->eint_fltcon0, regs + EXYNOS_GPIO_EFLTCON_OFFSET\r\n+ 2 * bank->eint_offset);\r\nwritel(save->eint_fltcon1, regs + EXYNOS_GPIO_EFLTCON_OFFSET\r\n+ 2 * bank->eint_offset + 4);\r\n}\r\nstatic void exynos_pinctrl_resume(struct samsung_pinctrl_drv_data *drvdata)\r\n{\r\nstruct samsung_pin_bank *bank = drvdata->pin_banks;\r\nint i;\r\nfor (i = 0; i < drvdata->nr_banks; ++i, ++bank)\r\nif (bank->eint_type == EINT_TYPE_GPIO)\r\nexynos_pinctrl_resume_bank(drvdata, bank);\r\n}
