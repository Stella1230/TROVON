static inline void vsp1_hsit_write(struct vsp1_hsit *hsit, u32 reg, u32 data)\r\n{\r\nvsp1_write(hsit->entity.vsp1, reg, data);\r\n}\r\nstatic int hsit_s_stream(struct v4l2_subdev *subdev, int enable)\r\n{\r\nstruct vsp1_hsit *hsit = to_hsit(subdev);\r\nif (!enable)\r\nreturn 0;\r\nif (hsit->inverse)\r\nvsp1_hsit_write(hsit, VI6_HSI_CTRL, VI6_HSI_CTRL_EN);\r\nelse\r\nvsp1_hsit_write(hsit, VI6_HST_CTRL, VI6_HST_CTRL_EN);\r\nreturn 0;\r\n}\r\nstatic int hsit_enum_mbus_code(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstruct vsp1_hsit *hsit = to_hsit(subdev);\r\nif (code->index > 0)\r\nreturn -EINVAL;\r\nif ((code->pad == HSIT_PAD_SINK && !hsit->inverse) |\r\n(code->pad == HSIT_PAD_SOURCE && hsit->inverse))\r\ncode->code = MEDIA_BUS_FMT_ARGB8888_1X32;\r\nelse\r\ncode->code = MEDIA_BUS_FMT_AHSV8888_1X32;\r\nreturn 0;\r\n}\r\nstatic int hsit_enum_frame_size(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct vsp1_hsit *hsit = to_hsit(subdev);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = vsp1_entity_get_pad_format(&hsit->entity, cfg, fse->pad,\r\nfse->which);\r\nif (fse->index || fse->code != format->code)\r\nreturn -EINVAL;\r\nif (fse->pad == HSIT_PAD_SINK) {\r\nfse->min_width = HSIT_MIN_SIZE;\r\nfse->max_width = HSIT_MAX_SIZE;\r\nfse->min_height = HSIT_MIN_SIZE;\r\nfse->max_height = HSIT_MAX_SIZE;\r\n} else {\r\nfse->min_width = format->width;\r\nfse->max_width = format->width;\r\nfse->min_height = format->height;\r\nfse->max_height = format->height;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hsit_get_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct vsp1_hsit *hsit = to_hsit(subdev);\r\nfmt->format = *vsp1_entity_get_pad_format(&hsit->entity, cfg, fmt->pad,\r\nfmt->which);\r\nreturn 0;\r\n}\r\nstatic int hsit_set_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct vsp1_hsit *hsit = to_hsit(subdev);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = vsp1_entity_get_pad_format(&hsit->entity, cfg, fmt->pad,\r\nfmt->which);\r\nif (fmt->pad == HSIT_PAD_SOURCE) {\r\nfmt->format = *format;\r\nreturn 0;\r\n}\r\nformat->code = hsit->inverse ? MEDIA_BUS_FMT_AHSV8888_1X32\r\n: MEDIA_BUS_FMT_ARGB8888_1X32;\r\nformat->width = clamp_t(unsigned int, fmt->format.width,\r\nHSIT_MIN_SIZE, HSIT_MAX_SIZE);\r\nformat->height = clamp_t(unsigned int, fmt->format.height,\r\nHSIT_MIN_SIZE, HSIT_MAX_SIZE);\r\nformat->field = V4L2_FIELD_NONE;\r\nformat->colorspace = V4L2_COLORSPACE_SRGB;\r\nfmt->format = *format;\r\nformat = vsp1_entity_get_pad_format(&hsit->entity, cfg, HSIT_PAD_SOURCE,\r\nfmt->which);\r\n*format = fmt->format;\r\nformat->code = hsit->inverse ? MEDIA_BUS_FMT_ARGB8888_1X32\r\n: MEDIA_BUS_FMT_AHSV8888_1X32;\r\nreturn 0;\r\n}\r\nstruct vsp1_hsit *vsp1_hsit_create(struct vsp1_device *vsp1, bool inverse)\r\n{\r\nstruct v4l2_subdev *subdev;\r\nstruct vsp1_hsit *hsit;\r\nint ret;\r\nhsit = devm_kzalloc(vsp1->dev, sizeof(*hsit), GFP_KERNEL);\r\nif (hsit == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nhsit->inverse = inverse;\r\nif (inverse)\r\nhsit->entity.type = VSP1_ENTITY_HSI;\r\nelse\r\nhsit->entity.type = VSP1_ENTITY_HST;\r\nret = vsp1_entity_init(vsp1, &hsit->entity, 2);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nsubdev = &hsit->entity.subdev;\r\nv4l2_subdev_init(subdev, &hsit_ops);\r\nsubdev->entity.ops = &vsp1_media_ops;\r\nsubdev->internal_ops = &vsp1_subdev_internal_ops;\r\nsnprintf(subdev->name, sizeof(subdev->name), "%s %s",\r\ndev_name(vsp1->dev), inverse ? "hsi" : "hst");\r\nv4l2_set_subdevdata(subdev, hsit);\r\nsubdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nvsp1_entity_init_formats(subdev, NULL);\r\nreturn hsit;\r\n}
