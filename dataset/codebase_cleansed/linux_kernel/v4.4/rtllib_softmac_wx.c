int rtllib_wx_set_freq(struct rtllib_device *ieee, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nint ret;\r\nstruct iw_freq *fwrq = &wrqu->freq;\r\ndown(&ieee->wx_sem);\r\nif (ieee->iw_mode == IW_MODE_INFRA) {\r\nret = 0;\r\ngoto out;\r\n}\r\nif (fwrq->e == 1) {\r\nif ((fwrq->m >= (int) 2.412e8 &&\r\nfwrq->m <= (int) 2.487e8)) {\r\nint f = fwrq->m / 100000;\r\nint c = 0;\r\nwhile ((c < 14) && (f != rtllib_wlan_frequencies[c]))\r\nc++;\r\nfwrq->e = 0;\r\nfwrq->m = c + 1;\r\n}\r\n}\r\nif (fwrq->e > 0 || fwrq->m > 14 || fwrq->m < 1) {\r\nret = -EOPNOTSUPP;\r\ngoto out;\r\n} else {\r\nif (ieee->active_channel_map[fwrq->m] != 1) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nieee->current_network.channel = fwrq->m;\r\nieee->set_chan(ieee->dev, ieee->current_network.channel);\r\nif (ieee->iw_mode == IW_MODE_ADHOC ||\r\nieee->iw_mode == IW_MODE_MASTER)\r\nif (ieee->state == RTLLIB_LINKED) {\r\nrtllib_stop_send_beacons(ieee);\r\nrtllib_start_send_beacons(ieee);\r\n}\r\n}\r\nret = 0;\r\nout:\r\nup(&ieee->wx_sem);\r\nreturn ret;\r\n}\r\nint rtllib_wx_get_freq(struct rtllib_device *ieee,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nstruct iw_freq *fwrq = &wrqu->freq;\r\nif (ieee->current_network.channel == 0)\r\nreturn -1;\r\nfwrq->m = rtllib_wlan_frequencies[ieee->current_network.channel-1] *\r\n100000;\r\nfwrq->e = 1;\r\nreturn 0;\r\n}\r\nint rtllib_wx_get_wap(struct rtllib_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nunsigned long flags;\r\nwrqu->ap_addr.sa_family = ARPHRD_ETHER;\r\nif (ieee->iw_mode == IW_MODE_MONITOR)\r\nreturn -1;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif (ieee->state != RTLLIB_LINKED &&\r\nieee->state != RTLLIB_LINKED_SCANNING &&\r\nieee->wap_set == 0)\r\neth_zero_addr(wrqu->ap_addr.sa_data);\r\nelse\r\nmemcpy(wrqu->ap_addr.sa_data,\r\nieee->current_network.bssid, ETH_ALEN);\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\nreturn 0;\r\n}\r\nint rtllib_wx_set_wap(struct rtllib_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *awrq,\r\nchar *extra)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nshort ifup = ieee->proto_started;\r\nstruct sockaddr *temp = (struct sockaddr *)awrq;\r\nrtllib_stop_scan_syncro(ieee);\r\ndown(&ieee->wx_sem);\r\nif (ieee->iw_mode == IW_MODE_MASTER) {\r\nret = -1;\r\ngoto out;\r\n}\r\nif (temp->sa_family != ARPHRD_ETHER) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (is_zero_ether_addr(temp->sa_data)) {\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nether_addr_copy(ieee->current_network.bssid, temp->sa_data);\r\nieee->wap_set = 0;\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\nret = -1;\r\ngoto out;\r\n}\r\nif (ifup)\r\nrtllib_stop_protocol(ieee, true);\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nieee->cannot_notify = false;\r\nether_addr_copy(ieee->current_network.bssid, temp->sa_data);\r\nieee->wap_set = !is_zero_ether_addr(temp->sa_data);\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\nif (ifup)\r\nrtllib_start_protocol(ieee);\r\nout:\r\nup(&ieee->wx_sem);\r\nreturn ret;\r\n}\r\nint rtllib_wx_get_essid(struct rtllib_device *ieee, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nint len, ret = 0;\r\nunsigned long flags;\r\nif (ieee->iw_mode == IW_MODE_MONITOR)\r\nreturn -1;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif (ieee->current_network.ssid[0] == '\0' ||\r\nieee->current_network.ssid_len == 0) {\r\nret = -1;\r\ngoto out;\r\n}\r\nif (ieee->state != RTLLIB_LINKED &&\r\nieee->state != RTLLIB_LINKED_SCANNING &&\r\nieee->ssid_set == 0) {\r\nret = -1;\r\ngoto out;\r\n}\r\nlen = ieee->current_network.ssid_len;\r\nwrqu->essid.length = len;\r\nstrncpy(b, ieee->current_network.ssid, len);\r\nwrqu->essid.flags = 1;\r\nout:\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\nreturn ret;\r\n}\r\nint rtllib_wx_set_rate(struct rtllib_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nu32 target_rate = wrqu->bitrate.value;\r\nieee->rate = target_rate/100000;\r\nreturn 0;\r\n}\r\nint rtllib_wx_get_rate(struct rtllib_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nu32 tmp_rate = 0;\r\ntmp_rate = TxCountToDataRate(ieee,\r\nieee->softmac_stats.CurrentShowTxate);\r\nwrqu->bitrate.value = tmp_rate * 500000;\r\nreturn 0;\r\n}\r\nint rtllib_wx_set_rts(struct rtllib_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nif (wrqu->rts.disabled || !wrqu->rts.fixed)\r\nieee->rts = DEFAULT_RTS_THRESHOLD;\r\nelse {\r\nif (wrqu->rts.value < MIN_RTS_THRESHOLD ||\r\nwrqu->rts.value > MAX_RTS_THRESHOLD)\r\nreturn -EINVAL;\r\nieee->rts = wrqu->rts.value;\r\n}\r\nreturn 0;\r\n}\r\nint rtllib_wx_get_rts(struct rtllib_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nwrqu->rts.value = ieee->rts;\r\nwrqu->rts.fixed = 0;\r\nwrqu->rts.disabled = (wrqu->rts.value == DEFAULT_RTS_THRESHOLD);\r\nreturn 0;\r\n}\r\nint rtllib_wx_set_mode(struct rtllib_device *ieee, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nint set_mode_status = 0;\r\nrtllib_stop_scan_syncro(ieee);\r\ndown(&ieee->wx_sem);\r\nswitch (wrqu->mode) {\r\ncase IW_MODE_MONITOR:\r\ncase IW_MODE_ADHOC:\r\ncase IW_MODE_INFRA:\r\nbreak;\r\ncase IW_MODE_AUTO:\r\nwrqu->mode = IW_MODE_INFRA;\r\nbreak;\r\ndefault:\r\nset_mode_status = -EINVAL;\r\ngoto out;\r\n}\r\nif (wrqu->mode == ieee->iw_mode)\r\ngoto out;\r\nif (wrqu->mode == IW_MODE_MONITOR) {\r\nieee->dev->type = ARPHRD_IEEE80211;\r\nrtllib_EnableNetMonitorMode(ieee->dev, false);\r\n} else {\r\nieee->dev->type = ARPHRD_ETHER;\r\nif (ieee->iw_mode == IW_MODE_MONITOR)\r\nrtllib_DisableNetMonitorMode(ieee->dev, false);\r\n}\r\nif (!ieee->proto_started) {\r\nieee->iw_mode = wrqu->mode;\r\n} else {\r\nrtllib_stop_protocol(ieee, true);\r\nieee->iw_mode = wrqu->mode;\r\nrtllib_start_protocol(ieee);\r\n}\r\nout:\r\nup(&ieee->wx_sem);\r\nreturn set_mode_status;\r\n}\r\nvoid rtllib_wx_sync_scan_wq(void *data)\r\n{\r\nstruct rtllib_device *ieee = container_of_work_rsl(data,\r\nstruct rtllib_device, wx_sync_scan_wq);\r\nshort chan;\r\nenum ht_extchnl_offset chan_offset = 0;\r\nenum ht_channel_width bandwidth = 0;\r\nint b40M = 0;\r\nif (!(ieee->softmac_features & IEEE_SOFTMAC_SCAN)) {\r\nrtllib_start_scan_syncro(ieee, 0);\r\ngoto out;\r\n}\r\nchan = ieee->current_network.channel;\r\nif (ieee->LeisurePSLeave)\r\nieee->LeisurePSLeave(ieee->dev);\r\nrtllib_sta_ps_send_null_frame(ieee, 1);\r\nrtllib_sta_ps_send_null_frame(ieee, 1);\r\nrtllib_stop_all_queues(ieee);\r\nif (ieee->data_hard_stop)\r\nieee->data_hard_stop(ieee->dev);\r\nrtllib_stop_send_beacons(ieee);\r\nieee->state = RTLLIB_LINKED_SCANNING;\r\nieee->link_change(ieee->dev);\r\nmsleep(50);\r\nif (ieee->ScanOperationBackupHandler)\r\nieee->ScanOperationBackupHandler(ieee->dev, SCAN_OPT_BACKUP);\r\nif (ieee->pHTInfo->bCurrentHTSupport && ieee->pHTInfo->bEnableHT &&\r\nieee->pHTInfo->bCurBW40MHz) {\r\nb40M = 1;\r\nchan_offset = ieee->pHTInfo->CurSTAExtChnlOffset;\r\nbandwidth = (enum ht_channel_width)ieee->pHTInfo->bCurBW40MHz;\r\nRT_TRACE(COMP_DBG, "Scan in 40M, force to 20M first:%d, %d\n",\r\nchan_offset, bandwidth);\r\nieee->SetBWModeHandler(ieee->dev, HT_CHANNEL_WIDTH_20,\r\nHT_EXTCHNL_OFFSET_NO_EXT);\r\n}\r\nrtllib_start_scan_syncro(ieee, 0);\r\nif (b40M) {\r\nRT_TRACE(COMP_DBG, "Scan in 20M, back to 40M\n");\r\nif (chan_offset == HT_EXTCHNL_OFFSET_UPPER)\r\nieee->set_chan(ieee->dev, chan + 2);\r\nelse if (chan_offset == HT_EXTCHNL_OFFSET_LOWER)\r\nieee->set_chan(ieee->dev, chan - 2);\r\nelse\r\nieee->set_chan(ieee->dev, chan);\r\nieee->SetBWModeHandler(ieee->dev, bandwidth, chan_offset);\r\n} else {\r\nieee->set_chan(ieee->dev, chan);\r\n}\r\nif (ieee->ScanOperationBackupHandler)\r\nieee->ScanOperationBackupHandler(ieee->dev, SCAN_OPT_RESTORE);\r\nieee->state = RTLLIB_LINKED;\r\nieee->link_change(ieee->dev);\r\nrtllib_sta_ps_send_null_frame(ieee, 0);\r\nif (ieee->LinkDetectInfo.NumRecvBcnInPeriod == 0 ||\r\nieee->LinkDetectInfo.NumRecvDataInPeriod == 0) {\r\nieee->LinkDetectInfo.NumRecvBcnInPeriod = 1;\r\nieee->LinkDetectInfo.NumRecvDataInPeriod = 1;\r\n}\r\nif (ieee->data_hard_resume)\r\nieee->data_hard_resume(ieee->dev);\r\nif (ieee->iw_mode == IW_MODE_ADHOC || ieee->iw_mode == IW_MODE_MASTER)\r\nrtllib_start_send_beacons(ieee);\r\nrtllib_wake_all_queues(ieee);\r\nout:\r\nup(&ieee->wx_sem);\r\n}\r\nint rtllib_wx_set_scan(struct rtllib_device *ieee, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nint ret = 0;\r\ndown(&ieee->wx_sem);\r\nif (ieee->iw_mode == IW_MODE_MONITOR || !(ieee->proto_started)) {\r\nret = -1;\r\ngoto out;\r\n}\r\nif (ieee->state == RTLLIB_LINKED) {\r\nqueue_work_rsl(ieee->wq, &ieee->wx_sync_scan_wq);\r\nreturn 0;\r\n}\r\nout:\r\nup(&ieee->wx_sem);\r\nreturn ret;\r\n}\r\nint rtllib_wx_set_essid(struct rtllib_device *ieee,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint ret = 0, len, i;\r\nshort proto_started;\r\nunsigned long flags;\r\nrtllib_stop_scan_syncro(ieee);\r\ndown(&ieee->wx_sem);\r\nproto_started = ieee->proto_started;\r\nlen = min_t(__u16, wrqu->essid.length, IW_ESSID_MAX_SIZE);\r\nif (ieee->iw_mode == IW_MODE_MONITOR) {\r\nret = -1;\r\ngoto out;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nif (extra[i] < 0) {\r\nret = -1;\r\ngoto out;\r\n}\r\n}\r\nif (proto_started)\r\nrtllib_stop_protocol(ieee, true);\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif (wrqu->essid.flags && wrqu->essid.length) {\r\nstrncpy(ieee->current_network.ssid, extra, len);\r\nieee->current_network.ssid_len = len;\r\nieee->cannot_notify = false;\r\nieee->ssid_set = 1;\r\n} else {\r\nieee->ssid_set = 0;\r\nieee->current_network.ssid[0] = '\0';\r\nieee->current_network.ssid_len = 0;\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\nif (proto_started)\r\nrtllib_start_protocol(ieee);\r\nout:\r\nup(&ieee->wx_sem);\r\nreturn ret;\r\n}\r\nint rtllib_wx_get_mode(struct rtllib_device *ieee, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nwrqu->mode = ieee->iw_mode;\r\nreturn 0;\r\n}\r\nint rtllib_wx_set_rawtx(struct rtllib_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint *parms = (int *)extra;\r\nint enable = (parms[0] > 0);\r\nshort prev = ieee->raw_tx;\r\ndown(&ieee->wx_sem);\r\nif (enable)\r\nieee->raw_tx = 1;\r\nelse\r\nieee->raw_tx = 0;\r\nnetdev_info(ieee->dev, "raw TX is %s\n",\r\nieee->raw_tx ? "enabled" : "disabled");\r\nif (ieee->iw_mode == IW_MODE_MONITOR) {\r\nif (prev == 0 && ieee->raw_tx) {\r\nif (ieee->data_hard_resume)\r\nieee->data_hard_resume(ieee->dev);\r\nnetif_carrier_on(ieee->dev);\r\n}\r\nif (prev && ieee->raw_tx == 1)\r\nnetif_carrier_off(ieee->dev);\r\n}\r\nup(&ieee->wx_sem);\r\nreturn 0;\r\n}\r\nint rtllib_wx_get_name(struct rtllib_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstrcpy(wrqu->name, "802.11");\r\nif (ieee->modulation & RTLLIB_CCK_MODULATION)\r\nstrcat(wrqu->name, "b");\r\nif (ieee->modulation & RTLLIB_OFDM_MODULATION)\r\nstrcat(wrqu->name, "g");\r\nif (ieee->mode & (IEEE_N_24G | IEEE_N_5G))\r\nstrcat(wrqu->name, "n");\r\nreturn 0;\r\n}\r\nint rtllib_wx_set_power(struct rtllib_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint ret = 0;\r\nif ((!ieee->sta_wake_up) ||\r\n(!ieee->enter_sleep_state) ||\r\n(!ieee->ps_is_queue_empty)) {\r\nnetdev_warn(ieee->dev,\r\n"%s(): PS mode is tried to be use but driver missed a callback\n",\r\n__func__);\r\nreturn -1;\r\n}\r\ndown(&ieee->wx_sem);\r\nif (wrqu->power.disabled) {\r\nRT_TRACE(COMP_DBG, "===>%s(): power disable\n", __func__);\r\nieee->ps = RTLLIB_PS_DISABLED;\r\ngoto exit;\r\n}\r\nif (wrqu->power.flags & IW_POWER_TIMEOUT) {\r\nieee->ps_timeout = wrqu->power.value / 1000;\r\nRT_TRACE(COMP_DBG, "===>%s():ps_timeout is %d\n", __func__,\r\nieee->ps_timeout);\r\n}\r\nif (wrqu->power.flags & IW_POWER_PERIOD)\r\nieee->ps_period = wrqu->power.value / 1000;\r\nswitch (wrqu->power.flags & IW_POWER_MODE) {\r\ncase IW_POWER_UNICAST_R:\r\nieee->ps = RTLLIB_PS_UNICAST;\r\nbreak;\r\ncase IW_POWER_MULTICAST_R:\r\nieee->ps = RTLLIB_PS_MBCAST;\r\nbreak;\r\ncase IW_POWER_ALL_R:\r\nieee->ps = RTLLIB_PS_UNICAST | RTLLIB_PS_MBCAST;\r\nbreak;\r\ncase IW_POWER_ON:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nexit:\r\nup(&ieee->wx_sem);\r\nreturn ret;\r\n}\r\nint rtllib_wx_get_power(struct rtllib_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\ndown(&ieee->wx_sem);\r\nif (ieee->ps == RTLLIB_PS_DISABLED) {\r\nwrqu->power.disabled = 1;\r\ngoto exit;\r\n}\r\nwrqu->power.disabled = 0;\r\nif ((wrqu->power.flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\r\nwrqu->power.flags = IW_POWER_TIMEOUT;\r\nwrqu->power.value = ieee->ps_timeout * 1000;\r\n} else {\r\nwrqu->power.flags = IW_POWER_PERIOD;\r\nwrqu->power.value = ieee->ps_period * 1000;\r\n}\r\nif ((ieee->ps & (RTLLIB_PS_MBCAST | RTLLIB_PS_UNICAST)) ==\r\n(RTLLIB_PS_MBCAST | RTLLIB_PS_UNICAST))\r\nwrqu->power.flags |= IW_POWER_ALL_R;\r\nelse if (ieee->ps & RTLLIB_PS_MBCAST)\r\nwrqu->power.flags |= IW_POWER_MULTICAST_R;\r\nelse\r\nwrqu->power.flags |= IW_POWER_UNICAST_R;\r\nexit:\r\nup(&ieee->wx_sem);\r\nreturn 0;\r\n}
