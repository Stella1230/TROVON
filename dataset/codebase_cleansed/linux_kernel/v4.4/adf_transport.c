static inline uint32_t adf_modulo(uint32_t data, uint32_t shift)\r\n{\r\nuint32_t div = data >> shift;\r\nuint32_t mult = div << shift;\r\nreturn data - mult;\r\n}\r\nstatic inline int adf_check_ring_alignment(uint64_t addr, uint64_t size)\r\n{\r\nif (((size - 1) & addr) != 0)\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int adf_verify_ring_size(uint32_t msg_size, uint32_t msg_num)\r\n{\r\nint i = ADF_MIN_RING_SIZE;\r\nfor (; i <= ADF_MAX_RING_SIZE; i++)\r\nif ((msg_size * msg_num) == ADF_SIZE_TO_RING_SIZE_IN_BYTES(i))\r\nreturn i;\r\nreturn ADF_DEFAULT_RING_SIZE;\r\n}\r\nstatic int adf_reserve_ring(struct adf_etr_bank_data *bank, uint32_t ring)\r\n{\r\nspin_lock(&bank->lock);\r\nif (bank->ring_mask & (1 << ring)) {\r\nspin_unlock(&bank->lock);\r\nreturn -EFAULT;\r\n}\r\nbank->ring_mask |= (1 << ring);\r\nspin_unlock(&bank->lock);\r\nreturn 0;\r\n}\r\nstatic void adf_unreserve_ring(struct adf_etr_bank_data *bank, uint32_t ring)\r\n{\r\nspin_lock(&bank->lock);\r\nbank->ring_mask &= ~(1 << ring);\r\nspin_unlock(&bank->lock);\r\n}\r\nstatic void adf_enable_ring_irq(struct adf_etr_bank_data *bank, uint32_t ring)\r\n{\r\nspin_lock_bh(&bank->lock);\r\nbank->irq_mask |= (1 << ring);\r\nspin_unlock_bh(&bank->lock);\r\nWRITE_CSR_INT_COL_EN(bank->csr_addr, bank->bank_number, bank->irq_mask);\r\nWRITE_CSR_INT_COL_CTL(bank->csr_addr, bank->bank_number,\r\nbank->irq_coalesc_timer);\r\n}\r\nstatic void adf_disable_ring_irq(struct adf_etr_bank_data *bank, uint32_t ring)\r\n{\r\nspin_lock_bh(&bank->lock);\r\nbank->irq_mask &= ~(1 << ring);\r\nspin_unlock_bh(&bank->lock);\r\nWRITE_CSR_INT_COL_EN(bank->csr_addr, bank->bank_number, bank->irq_mask);\r\n}\r\nint adf_send_message(struct adf_etr_ring_data *ring, uint32_t *msg)\r\n{\r\nif (atomic_add_return(1, ring->inflights) >\r\nADF_MAX_INFLIGHTS(ring->ring_size, ring->msg_size)) {\r\natomic_dec(ring->inflights);\r\nreturn -EAGAIN;\r\n}\r\nspin_lock_bh(&ring->lock);\r\nmemcpy(ring->base_addr + ring->tail, msg,\r\nADF_MSG_SIZE_TO_BYTES(ring->msg_size));\r\nring->tail = adf_modulo(ring->tail +\r\nADF_MSG_SIZE_TO_BYTES(ring->msg_size),\r\nADF_RING_SIZE_MODULO(ring->ring_size));\r\nWRITE_CSR_RING_TAIL(ring->bank->csr_addr, ring->bank->bank_number,\r\nring->ring_number, ring->tail);\r\nspin_unlock_bh(&ring->lock);\r\nreturn 0;\r\n}\r\nstatic int adf_handle_response(struct adf_etr_ring_data *ring)\r\n{\r\nuint32_t msg_counter = 0;\r\nuint32_t *msg = (uint32_t *)(ring->base_addr + ring->head);\r\nwhile (*msg != ADF_RING_EMPTY_SIG) {\r\nring->callback((uint32_t *)msg);\r\n*msg = ADF_RING_EMPTY_SIG;\r\nring->head = adf_modulo(ring->head +\r\nADF_MSG_SIZE_TO_BYTES(ring->msg_size),\r\nADF_RING_SIZE_MODULO(ring->ring_size));\r\nmsg_counter++;\r\nmsg = (uint32_t *)(ring->base_addr + ring->head);\r\n}\r\nif (msg_counter > 0) {\r\nWRITE_CSR_RING_HEAD(ring->bank->csr_addr,\r\nring->bank->bank_number,\r\nring->ring_number, ring->head);\r\natomic_sub(msg_counter, ring->inflights);\r\n}\r\nreturn 0;\r\n}\r\nstatic void adf_configure_tx_ring(struct adf_etr_ring_data *ring)\r\n{\r\nuint32_t ring_config = BUILD_RING_CONFIG(ring->ring_size);\r\nWRITE_CSR_RING_CONFIG(ring->bank->csr_addr, ring->bank->bank_number,\r\nring->ring_number, ring_config);\r\n}\r\nstatic void adf_configure_rx_ring(struct adf_etr_ring_data *ring)\r\n{\r\nuint32_t ring_config =\r\nBUILD_RESP_RING_CONFIG(ring->ring_size,\r\nADF_RING_NEAR_WATERMARK_512,\r\nADF_RING_NEAR_WATERMARK_0);\r\nWRITE_CSR_RING_CONFIG(ring->bank->csr_addr, ring->bank->bank_number,\r\nring->ring_number, ring_config);\r\n}\r\nstatic int adf_init_ring(struct adf_etr_ring_data *ring)\r\n{\r\nstruct adf_etr_bank_data *bank = ring->bank;\r\nstruct adf_accel_dev *accel_dev = bank->accel_dev;\r\nstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\r\nuint64_t ring_base;\r\nuint32_t ring_size_bytes =\r\nADF_SIZE_TO_RING_SIZE_IN_BYTES(ring->ring_size);\r\nring_size_bytes = ADF_RING_SIZE_BYTES_MIN(ring_size_bytes);\r\nring->base_addr = dma_alloc_coherent(&GET_DEV(accel_dev),\r\nring_size_bytes, &ring->dma_addr,\r\nGFP_KERNEL);\r\nif (!ring->base_addr)\r\nreturn -ENOMEM;\r\nmemset(ring->base_addr, 0x7F, ring_size_bytes);\r\nif (adf_check_ring_alignment(ring->dma_addr, ring_size_bytes)) {\r\ndev_err(&GET_DEV(accel_dev), "Ring address not aligned\n");\r\ndma_free_coherent(&GET_DEV(accel_dev), ring_size_bytes,\r\nring->base_addr, ring->dma_addr);\r\nreturn -EFAULT;\r\n}\r\nif (hw_data->tx_rings_mask & (1 << ring->ring_number))\r\nadf_configure_tx_ring(ring);\r\nelse\r\nadf_configure_rx_ring(ring);\r\nring_base = BUILD_RING_BASE_ADDR(ring->dma_addr, ring->ring_size);\r\nWRITE_CSR_RING_BASE(ring->bank->csr_addr, ring->bank->bank_number,\r\nring->ring_number, ring_base);\r\nspin_lock_init(&ring->lock);\r\nreturn 0;\r\n}\r\nstatic void adf_cleanup_ring(struct adf_etr_ring_data *ring)\r\n{\r\nuint32_t ring_size_bytes =\r\nADF_SIZE_TO_RING_SIZE_IN_BYTES(ring->ring_size);\r\nring_size_bytes = ADF_RING_SIZE_BYTES_MIN(ring_size_bytes);\r\nif (ring->base_addr) {\r\nmemset(ring->base_addr, 0x7F, ring_size_bytes);\r\ndma_free_coherent(&GET_DEV(ring->bank->accel_dev),\r\nring_size_bytes, ring->base_addr,\r\nring->dma_addr);\r\n}\r\n}\r\nint adf_create_ring(struct adf_accel_dev *accel_dev, const char *section,\r\nuint32_t bank_num, uint32_t num_msgs,\r\nuint32_t msg_size, const char *ring_name,\r\nadf_callback_fn callback, int poll_mode,\r\nstruct adf_etr_ring_data **ring_ptr)\r\n{\r\nstruct adf_etr_data *transport_data = accel_dev->transport;\r\nstruct adf_etr_bank_data *bank;\r\nstruct adf_etr_ring_data *ring;\r\nchar val[ADF_CFG_MAX_VAL_LEN_IN_BYTES];\r\nuint32_t ring_num;\r\nint ret;\r\nif (bank_num >= GET_MAX_BANKS(accel_dev)) {\r\ndev_err(&GET_DEV(accel_dev), "Invalid bank number\n");\r\nreturn -EFAULT;\r\n}\r\nif (msg_size > ADF_MSG_SIZE_TO_BYTES(ADF_MAX_MSG_SIZE)) {\r\ndev_err(&GET_DEV(accel_dev), "Invalid msg size\n");\r\nreturn -EFAULT;\r\n}\r\nif (ADF_MAX_INFLIGHTS(adf_verify_ring_size(msg_size, num_msgs),\r\nADF_BYTES_TO_MSG_SIZE(msg_size)) < 2) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"Invalid ring size for given msg size\n");\r\nreturn -EFAULT;\r\n}\r\nif (adf_cfg_get_param_value(accel_dev, section, ring_name, val)) {\r\ndev_err(&GET_DEV(accel_dev), "Section %s, no such entry : %s\n",\r\nsection, ring_name);\r\nreturn -EFAULT;\r\n}\r\nif (kstrtouint(val, 10, &ring_num)) {\r\ndev_err(&GET_DEV(accel_dev), "Can't get ring number\n");\r\nreturn -EFAULT;\r\n}\r\nif (ring_num >= ADF_ETR_MAX_RINGS_PER_BANK) {\r\ndev_err(&GET_DEV(accel_dev), "Invalid ring number\n");\r\nreturn -EFAULT;\r\n}\r\nbank = &transport_data->banks[bank_num];\r\nif (adf_reserve_ring(bank, ring_num)) {\r\ndev_err(&GET_DEV(accel_dev), "Ring %d, %s already exists.\n",\r\nring_num, ring_name);\r\nreturn -EFAULT;\r\n}\r\nring = &bank->rings[ring_num];\r\nring->ring_number = ring_num;\r\nring->bank = bank;\r\nring->callback = callback;\r\nring->msg_size = ADF_BYTES_TO_MSG_SIZE(msg_size);\r\nring->ring_size = adf_verify_ring_size(msg_size, num_msgs);\r\nring->head = 0;\r\nring->tail = 0;\r\natomic_set(ring->inflights, 0);\r\nret = adf_init_ring(ring);\r\nif (ret)\r\ngoto err;\r\nadf_update_ring_arb(ring);\r\nif (adf_ring_debugfs_add(ring, ring_name)) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"Couldn't add ring debugfs entry\n");\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nif (callback && (!poll_mode))\r\nadf_enable_ring_irq(bank, ring->ring_number);\r\n*ring_ptr = ring;\r\nreturn 0;\r\nerr:\r\nadf_cleanup_ring(ring);\r\nadf_unreserve_ring(bank, ring_num);\r\nadf_update_ring_arb(ring);\r\nreturn ret;\r\n}\r\nvoid adf_remove_ring(struct adf_etr_ring_data *ring)\r\n{\r\nstruct adf_etr_bank_data *bank = ring->bank;\r\nadf_disable_ring_irq(bank, ring->ring_number);\r\nWRITE_CSR_RING_CONFIG(bank->csr_addr, bank->bank_number,\r\nring->ring_number, 0);\r\nWRITE_CSR_RING_BASE(bank->csr_addr, bank->bank_number,\r\nring->ring_number, 0);\r\nadf_ring_debugfs_rm(ring);\r\nadf_unreserve_ring(bank, ring->ring_number);\r\nadf_update_ring_arb(ring);\r\nadf_cleanup_ring(ring);\r\n}\r\nstatic void adf_ring_response_handler(struct adf_etr_bank_data *bank)\r\n{\r\nuint32_t empty_rings, i;\r\nempty_rings = READ_CSR_E_STAT(bank->csr_addr, bank->bank_number);\r\nempty_rings = ~empty_rings & bank->irq_mask;\r\nfor (i = 0; i < ADF_ETR_MAX_RINGS_PER_BANK; ++i) {\r\nif (empty_rings & (1 << i))\r\nadf_handle_response(&bank->rings[i]);\r\n}\r\n}\r\nvoid adf_response_handler(unsigned long bank_addr)\r\n{\r\nstruct adf_etr_bank_data *bank = (void *)bank_addr;\r\nadf_ring_response_handler(bank);\r\nWRITE_CSR_INT_FLAG_AND_COL(bank->csr_addr, bank->bank_number,\r\nbank->irq_mask);\r\n}\r\nstatic inline int adf_get_cfg_int(struct adf_accel_dev *accel_dev,\r\nconst char *section, const char *format,\r\nuint32_t key, uint32_t *value)\r\n{\r\nchar key_buf[ADF_CFG_MAX_KEY_LEN_IN_BYTES];\r\nchar val_buf[ADF_CFG_MAX_VAL_LEN_IN_BYTES];\r\nsnprintf(key_buf, ADF_CFG_MAX_KEY_LEN_IN_BYTES, format, key);\r\nif (adf_cfg_get_param_value(accel_dev, section, key_buf, val_buf))\r\nreturn -EFAULT;\r\nif (kstrtouint(val_buf, 10, value))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void adf_get_coalesc_timer(struct adf_etr_bank_data *bank,\r\nconst char *section,\r\nuint32_t bank_num_in_accel)\r\n{\r\nif (adf_get_cfg_int(bank->accel_dev, section,\r\nADF_ETRMGR_COALESCE_TIMER_FORMAT,\r\nbank_num_in_accel, &bank->irq_coalesc_timer))\r\nbank->irq_coalesc_timer = ADF_COALESCING_DEF_TIME;\r\nif (ADF_COALESCING_MAX_TIME < bank->irq_coalesc_timer ||\r\nADF_COALESCING_MIN_TIME > bank->irq_coalesc_timer)\r\nbank->irq_coalesc_timer = ADF_COALESCING_DEF_TIME;\r\n}\r\nstatic int adf_init_bank(struct adf_accel_dev *accel_dev,\r\nstruct adf_etr_bank_data *bank,\r\nuint32_t bank_num, void __iomem *csr_addr)\r\n{\r\nstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\r\nstruct adf_etr_ring_data *ring;\r\nstruct adf_etr_ring_data *tx_ring;\r\nuint32_t i, coalesc_enabled = 0;\r\nmemset(bank, 0, sizeof(*bank));\r\nbank->bank_number = bank_num;\r\nbank->csr_addr = csr_addr;\r\nbank->accel_dev = accel_dev;\r\nspin_lock_init(&bank->lock);\r\nif ((adf_get_cfg_int(accel_dev, "Accelerator0",\r\nADF_ETRMGR_COALESCING_ENABLED_FORMAT, bank_num,\r\n&coalesc_enabled) == 0) && coalesc_enabled)\r\nadf_get_coalesc_timer(bank, "Accelerator0", bank_num);\r\nelse\r\nbank->irq_coalesc_timer = ADF_COALESCING_MIN_TIME;\r\nfor (i = 0; i < ADF_ETR_MAX_RINGS_PER_BANK; i++) {\r\nWRITE_CSR_RING_CONFIG(csr_addr, bank_num, i, 0);\r\nWRITE_CSR_RING_BASE(csr_addr, bank_num, i, 0);\r\nring = &bank->rings[i];\r\nif (hw_data->tx_rings_mask & (1 << i)) {\r\nring->inflights =\r\nkzalloc_node(sizeof(atomic_t),\r\nGFP_KERNEL,\r\ndev_to_node(&GET_DEV(accel_dev)));\r\nif (!ring->inflights)\r\ngoto err;\r\n} else {\r\nif (i < hw_data->tx_rx_gap) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"Invalid tx rings mask config\n");\r\ngoto err;\r\n}\r\ntx_ring = &bank->rings[i - hw_data->tx_rx_gap];\r\nring->inflights = tx_ring->inflights;\r\n}\r\n}\r\nif (adf_bank_debugfs_add(bank)) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"Failed to add bank debugfs entry\n");\r\ngoto err;\r\n}\r\nWRITE_CSR_INT_SRCSEL(csr_addr, bank_num);\r\nreturn 0;\r\nerr:\r\nfor (i = 0; i < ADF_ETR_MAX_RINGS_PER_BANK; i++) {\r\nring = &bank->rings[i];\r\nif (hw_data->tx_rings_mask & (1 << i))\r\nkfree(ring->inflights);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nint adf_init_etr_data(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct adf_etr_data *etr_data;\r\nstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\r\nvoid __iomem *csr_addr;\r\nuint32_t size;\r\nuint32_t num_banks = 0;\r\nint i, ret;\r\netr_data = kzalloc_node(sizeof(*etr_data), GFP_KERNEL,\r\ndev_to_node(&GET_DEV(accel_dev)));\r\nif (!etr_data)\r\nreturn -ENOMEM;\r\nnum_banks = GET_MAX_BANKS(accel_dev);\r\nsize = num_banks * sizeof(struct adf_etr_bank_data);\r\netr_data->banks = kzalloc_node(size, GFP_KERNEL,\r\ndev_to_node(&GET_DEV(accel_dev)));\r\nif (!etr_data->banks) {\r\nret = -ENOMEM;\r\ngoto err_bank;\r\n}\r\naccel_dev->transport = etr_data;\r\ni = hw_data->get_etr_bar_id(hw_data);\r\ncsr_addr = accel_dev->accel_pci_dev.pci_bars[i].virt_addr;\r\netr_data->debug = debugfs_create_dir("transport",\r\naccel_dev->debugfs_dir);\r\nif (!etr_data->debug) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"Unable to create transport debugfs entry\n");\r\nret = -ENOENT;\r\ngoto err_bank_debug;\r\n}\r\nfor (i = 0; i < num_banks; i++) {\r\nret = adf_init_bank(accel_dev, &etr_data->banks[i], i,\r\ncsr_addr);\r\nif (ret)\r\ngoto err_bank_all;\r\n}\r\nreturn 0;\r\nerr_bank_all:\r\ndebugfs_remove(etr_data->debug);\r\nerr_bank_debug:\r\nkfree(etr_data->banks);\r\nerr_bank:\r\nkfree(etr_data);\r\naccel_dev->transport = NULL;\r\nreturn ret;\r\n}\r\nstatic void cleanup_bank(struct adf_etr_bank_data *bank)\r\n{\r\nuint32_t i;\r\nfor (i = 0; i < ADF_ETR_MAX_RINGS_PER_BANK; i++) {\r\nstruct adf_accel_dev *accel_dev = bank->accel_dev;\r\nstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\r\nstruct adf_etr_ring_data *ring = &bank->rings[i];\r\nif (bank->ring_mask & (1 << i))\r\nadf_cleanup_ring(ring);\r\nif (hw_data->tx_rings_mask & (1 << i))\r\nkfree(ring->inflights);\r\n}\r\nadf_bank_debugfs_rm(bank);\r\nmemset(bank, 0, sizeof(*bank));\r\n}\r\nstatic void adf_cleanup_etr_handles(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct adf_etr_data *etr_data = accel_dev->transport;\r\nuint32_t i, num_banks = GET_MAX_BANKS(accel_dev);\r\nfor (i = 0; i < num_banks; i++)\r\ncleanup_bank(&etr_data->banks[i]);\r\n}\r\nvoid adf_cleanup_etr_data(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct adf_etr_data *etr_data = accel_dev->transport;\r\nif (etr_data) {\r\nadf_cleanup_etr_handles(accel_dev);\r\ndebugfs_remove(etr_data->debug);\r\nkfree(etr_data->banks);\r\nkfree(etr_data);\r\naccel_dev->transport = NULL;\r\n}\r\n}
