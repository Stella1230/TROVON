struct vpe *get_vpe(int minor)\r\n{\r\nstruct vpe *res, *v;\r\nif (!cpu_has_mipsmt)\r\nreturn NULL;\r\nres = NULL;\r\nspin_lock(&vpecontrol.vpe_list_lock);\r\nlist_for_each_entry(v, &vpecontrol.vpe_list, list) {\r\nif (v->minor == VPE_MODULE_MINOR) {\r\nres = v;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&vpecontrol.vpe_list_lock);\r\nreturn res;\r\n}\r\nstruct tc *get_tc(int index)\r\n{\r\nstruct tc *res, *t;\r\nres = NULL;\r\nspin_lock(&vpecontrol.tc_list_lock);\r\nlist_for_each_entry(t, &vpecontrol.tc_list, list) {\r\nif (t->index == index) {\r\nres = t;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&vpecontrol.tc_list_lock);\r\nreturn res;\r\n}\r\nstruct vpe *alloc_vpe(int minor)\r\n{\r\nstruct vpe *v;\r\nv = kzalloc(sizeof(struct vpe), GFP_KERNEL);\r\nif (v == NULL)\r\ngoto out;\r\nINIT_LIST_HEAD(&v->tc);\r\nspin_lock(&vpecontrol.vpe_list_lock);\r\nlist_add_tail(&v->list, &vpecontrol.vpe_list);\r\nspin_unlock(&vpecontrol.vpe_list_lock);\r\nINIT_LIST_HEAD(&v->notify);\r\nv->minor = VPE_MODULE_MINOR;\r\nout:\r\nreturn v;\r\n}\r\nstruct tc *alloc_tc(int index)\r\n{\r\nstruct tc *tc;\r\ntc = kzalloc(sizeof(struct tc), GFP_KERNEL);\r\nif (tc == NULL)\r\ngoto out;\r\nINIT_LIST_HEAD(&tc->tc);\r\ntc->index = index;\r\nspin_lock(&vpecontrol.tc_list_lock);\r\nlist_add_tail(&tc->list, &vpecontrol.tc_list);\r\nspin_unlock(&vpecontrol.tc_list_lock);\r\nout:\r\nreturn tc;\r\n}\r\nvoid release_vpe(struct vpe *v)\r\n{\r\nlist_del(&v->list);\r\nif (v->load_addr)\r\nrelease_progmem(v);\r\nkfree(v);\r\n}\r\nvoid *alloc_progmem(unsigned long len)\r\n{\r\nvoid *addr;\r\n#ifdef CONFIG_MIPS_VPE_LOADER_TOM\r\naddr = pfn_to_kaddr(max_low_pfn);\r\nmemset(addr, 0, len);\r\n#else\r\naddr = kzalloc(len, GFP_KERNEL);\r\n#endif\r\nreturn addr;\r\n}\r\nvoid release_progmem(void *ptr)\r\n{\r\n#ifndef CONFIG_MIPS_VPE_LOADER_TOM\r\nkfree(ptr);\r\n#endif\r\n}\r\nstatic long get_offset(unsigned long *size, Elf_Shdr *sechdr)\r\n{\r\nlong ret;\r\nret = ALIGN(*size, sechdr->sh_addralign ? : 1);\r\n*size = ret + sechdr->sh_size;\r\nreturn ret;\r\n}\r\nstatic void layout_sections(struct module *mod, const Elf_Ehdr *hdr,\r\nElf_Shdr *sechdrs, const char *secstrings)\r\n{\r\nstatic unsigned long const masks[][2] = {\r\n{SHF_EXECINSTR | SHF_ALLOC, ARCH_SHF_SMALL},\r\n{SHF_ALLOC, SHF_WRITE | ARCH_SHF_SMALL},\r\n{SHF_WRITE | SHF_ALLOC, ARCH_SHF_SMALL},\r\n{ARCH_SHF_SMALL | SHF_ALLOC, 0}\r\n};\r\nunsigned int m, i;\r\nfor (i = 0; i < hdr->e_shnum; i++)\r\nsechdrs[i].sh_entsize = ~0UL;\r\nfor (m = 0; m < ARRAY_SIZE(masks); ++m) {\r\nfor (i = 0; i < hdr->e_shnum; ++i) {\r\nElf_Shdr *s = &sechdrs[i];\r\nif ((s->sh_flags & masks[m][0]) != masks[m][0]\r\n|| (s->sh_flags & masks[m][1])\r\n|| s->sh_entsize != ~0UL)\r\ncontinue;\r\ns->sh_entsize =\r\nget_offset((unsigned long *)&mod->core_size, s);\r\n}\r\nif (m == 0)\r\nmod->core_text_size = mod->core_size;\r\n}\r\n}\r\nstatic int apply_r_mips_none(struct module *me, uint32_t *location,\r\nElf32_Addr v)\r\n{\r\nreturn 0;\r\n}\r\nstatic int apply_r_mips_gprel16(struct module *me, uint32_t *location,\r\nElf32_Addr v)\r\n{\r\nint rel;\r\nif (!(*location & 0xffff)) {\r\nrel = (int)v - gp_addr;\r\n} else {\r\nrel = (int)(short)((int)v + gp_offs +\r\n(int)(short)(*location & 0xffff) - gp_addr);\r\n}\r\nif ((rel > 32768) || (rel < -32768)) {\r\npr_debug("VPE loader: apply_r_mips_gprel16: relative address 0x%x out of range of gp register\n",\r\nrel);\r\nreturn -ENOEXEC;\r\n}\r\n*location = (*location & 0xffff0000) | (rel & 0xffff);\r\nreturn 0;\r\n}\r\nstatic int apply_r_mips_pc16(struct module *me, uint32_t *location,\r\nElf32_Addr v)\r\n{\r\nint rel;\r\nrel = (((unsigned int)v - (unsigned int)location));\r\nrel >>= 2;\r\nrel -= 1;\r\nif ((rel > 32768) || (rel < -32768)) {\r\npr_debug("VPE loader: apply_r_mips_pc16: relative address out of range 0x%x\n",\r\nrel);\r\nreturn -ENOEXEC;\r\n}\r\n*location = (*location & 0xffff0000) | (rel & 0xffff);\r\nreturn 0;\r\n}\r\nstatic int apply_r_mips_32(struct module *me, uint32_t *location,\r\nElf32_Addr v)\r\n{\r\n*location += v;\r\nreturn 0;\r\n}\r\nstatic int apply_r_mips_26(struct module *me, uint32_t *location,\r\nElf32_Addr v)\r\n{\r\nif (v % 4) {\r\npr_debug("VPE loader: apply_r_mips_26: unaligned relocation\n");\r\nreturn -ENOEXEC;\r\n}\r\n*location = (*location & ~0x03ffffff) |\r\n((*location + (v >> 2)) & 0x03ffffff);\r\nreturn 0;\r\n}\r\nstatic int apply_r_mips_hi16(struct module *me, uint32_t *location,\r\nElf32_Addr v)\r\n{\r\nstruct mips_hi16 *n;\r\nn = kmalloc(sizeof(*n), GFP_KERNEL);\r\nif (!n)\r\nreturn -ENOMEM;\r\nn->addr = location;\r\nn->value = v;\r\nn->next = mips_hi16_list;\r\nmips_hi16_list = n;\r\nreturn 0;\r\n}\r\nstatic int apply_r_mips_lo16(struct module *me, uint32_t *location,\r\nElf32_Addr v)\r\n{\r\nunsigned long insnlo = *location;\r\nElf32_Addr val, vallo;\r\nstruct mips_hi16 *l, *next;\r\nvallo = ((insnlo & 0xffff) ^ 0x8000) - 0x8000;\r\nif (mips_hi16_list != NULL) {\r\nl = mips_hi16_list;\r\nwhile (l != NULL) {\r\nunsigned long insn;\r\nif (v != l->value) {\r\npr_debug("VPE loader: apply_r_mips_lo16/hi16: inconsistent value information\n");\r\ngoto out_free;\r\n}\r\ninsn = *l->addr;\r\nval = ((insn & 0xffff) << 16) + vallo;\r\nval += v;\r\nval = ((val >> 16) + ((val & 0x8000) != 0)) & 0xffff;\r\ninsn = (insn & ~0xffff) | val;\r\n*l->addr = insn;\r\nnext = l->next;\r\nkfree(l);\r\nl = next;\r\n}\r\nmips_hi16_list = NULL;\r\n}\r\nval = v + vallo;\r\ninsnlo = (insnlo & ~0xffff) | (val & 0xffff);\r\n*location = insnlo;\r\nreturn 0;\r\nout_free:\r\nwhile (l != NULL) {\r\nnext = l->next;\r\nkfree(l);\r\nl = next;\r\n}\r\nmips_hi16_list = NULL;\r\nreturn -ENOEXEC;\r\n}\r\nstatic int apply_relocations(Elf32_Shdr *sechdrs,\r\nconst char *strtab,\r\nunsigned int symindex,\r\nunsigned int relsec,\r\nstruct module *me)\r\n{\r\nElf32_Rel *rel = (void *) sechdrs[relsec].sh_addr;\r\nElf32_Sym *sym;\r\nuint32_t *location;\r\nunsigned int i;\r\nElf32_Addr v;\r\nint res;\r\nfor (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {\r\nElf32_Word r_info = rel[i].r_info;\r\nlocation = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr\r\n+ rel[i].r_offset;\r\nsym = (Elf32_Sym *)sechdrs[symindex].sh_addr\r\n+ ELF32_R_SYM(r_info);\r\nif (!sym->st_value) {\r\npr_debug("%s: undefined weak symbol %s\n",\r\nme->name, strtab + sym->st_name);\r\n}\r\nv = sym->st_value;\r\nres = reloc_handlers[ELF32_R_TYPE(r_info)](me, location, v);\r\nif (res) {\r\nchar *r = rstrs[ELF32_R_TYPE(r_info)];\r\npr_warn("VPE loader: .text+0x%x relocation type %s for symbol \"%s\" failed\n",\r\nrel[i].r_offset, r ? r : "UNKNOWN",\r\nstrtab + sym->st_name);\r\nreturn res;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void save_gp_address(unsigned int secbase, unsigned int rel)\r\n{\r\ngp_addr = secbase + rel;\r\ngp_offs = gp_addr - (secbase & 0xffff0000);\r\n}\r\nstatic void simplify_symbols(Elf_Shdr *sechdrs,\r\nunsigned int symindex,\r\nconst char *strtab,\r\nconst char *secstrings,\r\nunsigned int nsecs, struct module *mod)\r\n{\r\nElf_Sym *sym = (void *)sechdrs[symindex].sh_addr;\r\nunsigned long secbase, bssbase = 0;\r\nunsigned int i, n = sechdrs[symindex].sh_size / sizeof(Elf_Sym);\r\nint size;\r\nfor (i = 0; i < nsecs; i++) {\r\nif (strncmp(secstrings + sechdrs[i].sh_name, ".bss", 4) == 0) {\r\nbssbase = sechdrs[i].sh_addr;\r\nbreak;\r\n}\r\n}\r\nfor (i = 1; i < n; i++) {\r\nswitch (sym[i].st_shndx) {\r\ncase SHN_COMMON:\r\nsize = sym[i].st_value;\r\nsym[i].st_value = bssbase;\r\nbssbase += size;\r\nbreak;\r\ncase SHN_ABS:\r\nbreak;\r\ncase SHN_UNDEF:\r\nbreak;\r\ncase SHN_MIPS_SCOMMON:\r\npr_debug("simplify_symbols: ignoring SHN_MIPS_SCOMMON symbol <%s> st_shndx %d\n",\r\nstrtab + sym[i].st_name, sym[i].st_shndx);\r\nbreak;\r\ndefault:\r\nsecbase = sechdrs[sym[i].st_shndx].sh_addr;\r\nif (strncmp(strtab + sym[i].st_name, "_gp", 3) == 0)\r\nsave_gp_address(secbase, sym[i].st_value);\r\nsym[i].st_value += secbase;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void dump_elfsymbols(Elf_Shdr *sechdrs, unsigned int symindex,\r\nconst char *strtab, struct module *mod)\r\n{\r\nElf_Sym *sym = (void *)sechdrs[symindex].sh_addr;\r\nunsigned int i, n = sechdrs[symindex].sh_size / sizeof(Elf_Sym);\r\npr_debug("dump_elfsymbols: n %d\n", n);\r\nfor (i = 1; i < n; i++) {\r\npr_debug(" i %d name <%s> 0x%x\n", i, strtab + sym[i].st_name,\r\nsym[i].st_value);\r\n}\r\n}\r\nstatic int find_vpe_symbols(struct vpe *v, Elf_Shdr *sechdrs,\r\nunsigned int symindex, const char *strtab,\r\nstruct module *mod)\r\n{\r\nElf_Sym *sym = (void *)sechdrs[symindex].sh_addr;\r\nunsigned int i, n = sechdrs[symindex].sh_size / sizeof(Elf_Sym);\r\nfor (i = 1; i < n; i++) {\r\nif (strcmp(strtab + sym[i].st_name, "__start") == 0)\r\nv->__start = sym[i].st_value;\r\nif (strcmp(strtab + sym[i].st_name, "vpe_shared") == 0)\r\nv->shared_ptr = (void *)sym[i].st_value;\r\n}\r\nif ((v->__start == 0) || (v->shared_ptr == NULL))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int vpe_elfload(struct vpe *v)\r\n{\r\nElf_Ehdr *hdr;\r\nElf_Shdr *sechdrs;\r\nlong err = 0;\r\nchar *secstrings, *strtab = NULL;\r\nunsigned int len, i, symindex = 0, strindex = 0, relocate = 0;\r\nstruct module mod;\r\nmemset(&mod, 0, sizeof(struct module));\r\nstrcpy(mod.name, "VPE loader");\r\nhdr = (Elf_Ehdr *) v->pbuffer;\r\nlen = v->plen;\r\nif (memcmp(hdr->e_ident, ELFMAG, SELFMAG) != 0\r\n|| (hdr->e_type != ET_REL && hdr->e_type != ET_EXEC)\r\n|| !elf_check_arch(hdr)\r\n|| hdr->e_shentsize != sizeof(*sechdrs)) {\r\npr_warn("VPE loader: program wrong arch or weird elf version\n");\r\nreturn -ENOEXEC;\r\n}\r\nif (hdr->e_type == ET_REL)\r\nrelocate = 1;\r\nif (len < hdr->e_shoff + hdr->e_shnum * sizeof(Elf_Shdr)) {\r\npr_err("VPE loader: program length %u truncated\n", len);\r\nreturn -ENOEXEC;\r\n}\r\nsechdrs = (void *)hdr + hdr->e_shoff;\r\nsecstrings = (void *)hdr + sechdrs[hdr->e_shstrndx].sh_offset;\r\nsechdrs[0].sh_addr = 0;\r\nsymindex = strindex = 0;\r\nif (relocate) {\r\nfor (i = 1; i < hdr->e_shnum; i++) {\r\nif ((sechdrs[i].sh_type != SHT_NOBITS) &&\r\n(len < sechdrs[i].sh_offset + sechdrs[i].sh_size)) {\r\npr_err("VPE program length %u truncated\n",\r\nlen);\r\nreturn -ENOEXEC;\r\n}\r\nsechdrs[i].sh_addr = (size_t) hdr +\r\nsechdrs[i].sh_offset;\r\nif (sechdrs[i].sh_type == SHT_SYMTAB) {\r\nsymindex = i;\r\nstrindex = sechdrs[i].sh_link;\r\nstrtab = (char *)hdr +\r\nsechdrs[strindex].sh_offset;\r\n}\r\n}\r\nlayout_sections(&mod, hdr, sechdrs, secstrings);\r\n}\r\nv->load_addr = alloc_progmem(mod.core_size);\r\nif (!v->load_addr)\r\nreturn -ENOMEM;\r\npr_info("VPE loader: loading to %p\n", v->load_addr);\r\nif (relocate) {\r\nfor (i = 0; i < hdr->e_shnum; i++) {\r\nvoid *dest;\r\nif (!(sechdrs[i].sh_flags & SHF_ALLOC))\r\ncontinue;\r\ndest = v->load_addr + sechdrs[i].sh_entsize;\r\nif (sechdrs[i].sh_type != SHT_NOBITS)\r\nmemcpy(dest, (void *)sechdrs[i].sh_addr,\r\nsechdrs[i].sh_size);\r\nsechdrs[i].sh_addr = (unsigned long)dest;\r\npr_debug(" section sh_name %s sh_addr 0x%x\n",\r\nsecstrings + sechdrs[i].sh_name,\r\nsechdrs[i].sh_addr);\r\n}\r\nsimplify_symbols(sechdrs, symindex, strtab, secstrings,\r\nhdr->e_shnum, &mod);\r\nfor (i = 1; i < hdr->e_shnum; i++) {\r\nconst char *strtab = (char *)sechdrs[strindex].sh_addr;\r\nunsigned int info = sechdrs[i].sh_info;\r\nif (info >= hdr->e_shnum)\r\ncontinue;\r\nif (!(sechdrs[info].sh_flags & SHF_ALLOC))\r\ncontinue;\r\nif (sechdrs[i].sh_type == SHT_REL)\r\nerr = apply_relocations(sechdrs, strtab,\r\nsymindex, i, &mod);\r\nelse if (sechdrs[i].sh_type == SHT_RELA)\r\nerr = apply_relocate_add(sechdrs, strtab,\r\nsymindex, i, &mod);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n} else {\r\nstruct elf_phdr *phdr = (struct elf_phdr *)\r\n((char *)hdr + hdr->e_phoff);\r\nfor (i = 0; i < hdr->e_phnum; i++) {\r\nif (phdr->p_type == PT_LOAD) {\r\nmemcpy((void *)phdr->p_paddr,\r\n(char *)hdr + phdr->p_offset,\r\nphdr->p_filesz);\r\nmemset((void *)phdr->p_paddr + phdr->p_filesz,\r\n0, phdr->p_memsz - phdr->p_filesz);\r\n}\r\nphdr++;\r\n}\r\nfor (i = 0; i < hdr->e_shnum; i++) {\r\nif (sechdrs[i].sh_type == SHT_SYMTAB) {\r\nsymindex = i;\r\nstrindex = sechdrs[i].sh_link;\r\nstrtab = (char *)hdr +\r\nsechdrs[strindex].sh_offset;\r\nsechdrs[i].sh_addr = (size_t) hdr +\r\nsechdrs[i].sh_offset;\r\n}\r\n}\r\n}\r\nflush_icache_range((unsigned long)v->load_addr,\r\n(unsigned long)v->load_addr + v->len);\r\nif ((find_vpe_symbols(v, sechdrs, symindex, strtab, &mod)) < 0) {\r\nif (v->__start == 0) {\r\npr_warn("VPE loader: program does not contain a __start symbol\n");\r\nreturn -ENOEXEC;\r\n}\r\nif (v->shared_ptr == NULL)\r\npr_warn("VPE loader: program does not contain vpe_shared symbol.\n"\r\n" Unable to use AMVP (AP/SP) facilities.\n");\r\n}\r\npr_info(" elf loaded\n");\r\nreturn 0;\r\n}\r\nstatic int getcwd(char *buff, int size)\r\n{\r\nmm_segment_t old_fs;\r\nint ret;\r\nold_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\nret = sys_getcwd(buff, size);\r\nset_fs(old_fs);\r\nreturn ret;\r\n}\r\nstatic int vpe_open(struct inode *inode, struct file *filp)\r\n{\r\nenum vpe_state state;\r\nstruct vpe_notifications *notifier;\r\nstruct vpe *v;\r\nint ret;\r\nif (VPE_MODULE_MINOR != iminor(inode)) {\r\npr_warn("VPE loader: only vpe1 is supported\n");\r\nreturn -ENODEV;\r\n}\r\nv = get_vpe(aprp_cpu_index());\r\nif (v == NULL) {\r\npr_warn("VPE loader: unable to get vpe\n");\r\nreturn -ENODEV;\r\n}\r\nstate = xchg(&v->state, VPE_STATE_INUSE);\r\nif (state != VPE_STATE_UNUSED) {\r\npr_debug("VPE loader: tc in use dumping regs\n");\r\nlist_for_each_entry(notifier, &v->notify, list)\r\nnotifier->stop(aprp_cpu_index());\r\nrelease_progmem(v->load_addr);\r\ncleanup_tc(get_tc(aprp_cpu_index()));\r\n}\r\nv->pbuffer = vmalloc(P_SIZE);\r\nif (!v->pbuffer) {\r\npr_warn("VPE loader: unable to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nv->plen = P_SIZE;\r\nv->load_addr = NULL;\r\nv->len = 0;\r\nv->cwd[0] = 0;\r\nret = getcwd(v->cwd, VPE_PATH_MAX);\r\nif (ret < 0)\r\npr_warn("VPE loader: open, getcwd returned %d\n", ret);\r\nv->shared_ptr = NULL;\r\nv->__start = 0;\r\nreturn 0;\r\n}\r\nstatic int vpe_release(struct inode *inode, struct file *filp)\r\n{\r\n#if defined(CONFIG_MIPS_VPE_LOADER_MT) || defined(CONFIG_MIPS_VPE_LOADER_CMP)\r\nstruct vpe *v;\r\nElf_Ehdr *hdr;\r\nint ret = 0;\r\nv = get_vpe(aprp_cpu_index());\r\nif (v == NULL)\r\nreturn -ENODEV;\r\nhdr = (Elf_Ehdr *) v->pbuffer;\r\nif (memcmp(hdr->e_ident, ELFMAG, SELFMAG) == 0) {\r\nif (vpe_elfload(v) >= 0) {\r\nvpe_run(v);\r\n} else {\r\npr_warn("VPE loader: ELF load failed.\n");\r\nret = -ENOEXEC;\r\n}\r\n} else {\r\npr_warn("VPE loader: only elf files are supported\n");\r\nret = -ENOEXEC;\r\n}\r\nif (ret < 0)\r\nv->shared_ptr = NULL;\r\nvfree(v->pbuffer);\r\nv->plen = 0;\r\nreturn ret;\r\n#else\r\npr_warn("VPE loader: ELF load failed.\n");\r\nreturn -ENOEXEC;\r\n#endif\r\n}\r\nstatic ssize_t vpe_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nsize_t ret = count;\r\nstruct vpe *v;\r\nif (iminor(file_inode(file)) != VPE_MODULE_MINOR)\r\nreturn -ENODEV;\r\nv = get_vpe(aprp_cpu_index());\r\nif (v == NULL)\r\nreturn -ENODEV;\r\nif ((count + v->len) > v->plen) {\r\npr_warn("VPE loader: elf size too big. Perhaps strip uneeded symbols\n");\r\nreturn -ENOMEM;\r\n}\r\ncount -= copy_from_user(v->pbuffer + v->len, buffer, count);\r\nif (!count)\r\nreturn -EFAULT;\r\nv->len += count;\r\nreturn ret;\r\n}\r\nvoid *vpe_get_shared(int index)\r\n{\r\nstruct vpe *v = get_vpe(index);\r\nif (v == NULL)\r\nreturn NULL;\r\nreturn v->shared_ptr;\r\n}\r\nint vpe_notify(int index, struct vpe_notifications *notify)\r\n{\r\nstruct vpe *v = get_vpe(index);\r\nif (v == NULL)\r\nreturn -1;\r\nlist_add(&notify->list, &v->notify);\r\nreturn 0;\r\n}\r\nchar *vpe_getcwd(int index)\r\n{\r\nstruct vpe *v = get_vpe(index);\r\nif (v == NULL)\r\nreturn NULL;\r\nreturn v->cwd;\r\n}
