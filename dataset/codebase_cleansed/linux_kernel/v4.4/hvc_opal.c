static int hvc_opal_hvsi_get_chars(uint32_t vtermno, char *buf, int count)\r\n{\r\nstruct hvc_opal_priv *pv = hvc_opal_privs[vtermno];\r\nif (WARN_ON(!pv))\r\nreturn -ENODEV;\r\nreturn hvsilib_get_chars(&pv->hvsi, buf, count);\r\n}\r\nstatic int hvc_opal_hvsi_put_chars(uint32_t vtermno, const char *buf, int count)\r\n{\r\nstruct hvc_opal_priv *pv = hvc_opal_privs[vtermno];\r\nif (WARN_ON(!pv))\r\nreturn -ENODEV;\r\nreturn hvsilib_put_chars(&pv->hvsi, buf, count);\r\n}\r\nstatic int hvc_opal_hvsi_open(struct hvc_struct *hp, int data)\r\n{\r\nstruct hvc_opal_priv *pv = hvc_opal_privs[hp->vtermno];\r\nint rc;\r\npr_devel("HVSI@%x: do open !\n", hp->vtermno);\r\nrc = notifier_add_irq(hp, data);\r\nif (rc)\r\nreturn rc;\r\nreturn hvsilib_open(&pv->hvsi, hp);\r\n}\r\nstatic void hvc_opal_hvsi_close(struct hvc_struct *hp, int data)\r\n{\r\nstruct hvc_opal_priv *pv = hvc_opal_privs[hp->vtermno];\r\npr_devel("HVSI@%x: do close !\n", hp->vtermno);\r\nhvsilib_close(&pv->hvsi, hp);\r\nnotifier_del_irq(hp, data);\r\n}\r\nvoid hvc_opal_hvsi_hangup(struct hvc_struct *hp, int data)\r\n{\r\nstruct hvc_opal_priv *pv = hvc_opal_privs[hp->vtermno];\r\npr_devel("HVSI@%x: do hangup !\n", hp->vtermno);\r\nhvsilib_close(&pv->hvsi, hp);\r\nnotifier_hangup_irq(hp, data);\r\n}\r\nstatic int hvc_opal_hvsi_tiocmget(struct hvc_struct *hp)\r\n{\r\nstruct hvc_opal_priv *pv = hvc_opal_privs[hp->vtermno];\r\nif (!pv)\r\nreturn -EINVAL;\r\nreturn pv->hvsi.mctrl;\r\n}\r\nstatic int hvc_opal_hvsi_tiocmset(struct hvc_struct *hp, unsigned int set,\r\nunsigned int clear)\r\n{\r\nstruct hvc_opal_priv *pv = hvc_opal_privs[hp->vtermno];\r\npr_devel("HVSI@%x: Set modem control, set=%x,clr=%x\n",\r\nhp->vtermno, set, clear);\r\nif (set & TIOCM_DTR)\r\nhvsilib_write_mctrl(&pv->hvsi, 1);\r\nelse if (clear & TIOCM_DTR)\r\nhvsilib_write_mctrl(&pv->hvsi, 0);\r\nreturn 0;\r\n}\r\nstatic int hvc_opal_probe(struct platform_device *dev)\r\n{\r\nconst struct hv_ops *ops;\r\nstruct hvc_struct *hp;\r\nstruct hvc_opal_priv *pv;\r\nhv_protocol_t proto;\r\nunsigned int termno, irq, boot = 0;\r\nconst __be32 *reg;\r\nif (of_device_is_compatible(dev->dev.of_node, "ibm,opal-console-raw")) {\r\nproto = HV_PROTOCOL_RAW;\r\nops = &hvc_opal_raw_ops;\r\n} else if (of_device_is_compatible(dev->dev.of_node,\r\n"ibm,opal-console-hvsi")) {\r\nproto = HV_PROTOCOL_HVSI;\r\nops = &hvc_opal_hvsi_ops;\r\n} else {\r\npr_err("hvc_opal: Unknown protocol for %s\n",\r\ndev->dev.of_node->full_name);\r\nreturn -ENXIO;\r\n}\r\nreg = of_get_property(dev->dev.of_node, "reg", NULL);\r\ntermno = reg ? be32_to_cpup(reg) : 0;\r\nif (hvc_opal_privs[termno] == &hvc_opal_boot_priv) {\r\npv = hvc_opal_privs[termno];\r\nboot = 1;\r\n} else if (hvc_opal_privs[termno] == NULL) {\r\npv = kzalloc(sizeof(struct hvc_opal_priv), GFP_KERNEL);\r\nif (!pv)\r\nreturn -ENOMEM;\r\npv->proto = proto;\r\nhvc_opal_privs[termno] = pv;\r\nif (proto == HV_PROTOCOL_HVSI)\r\nhvsilib_init(&pv->hvsi, opal_get_chars, opal_put_chars,\r\ntermno, 0);\r\nhvc_instantiate(termno, termno, ops);\r\n} else {\r\npr_err("hvc_opal: Device %s has duplicate terminal number #%d\n",\r\ndev->dev.of_node->full_name, termno);\r\nreturn -ENXIO;\r\n}\r\npr_info("hvc%d: %s protocol on %s%s\n", termno,\r\nproto == HV_PROTOCOL_RAW ? "raw" : "hvsi",\r\ndev->dev.of_node->full_name,\r\nboot ? " (boot console)" : "");\r\nirq = opal_event_request(ilog2(OPAL_EVENT_CONSOLE_INPUT));\r\nif (!irq) {\r\npr_err("hvc_opal: Unable to map interrupt for device %s\n",\r\ndev->dev.of_node->full_name);\r\nreturn irq;\r\n}\r\nhp = hvc_alloc(termno, irq, ops, MAX_VIO_PUT_CHARS);\r\nif (IS_ERR(hp))\r\nreturn PTR_ERR(hp);\r\ndev_set_drvdata(&dev->dev, hp);\r\nreturn 0;\r\n}\r\nstatic int hvc_opal_remove(struct platform_device *dev)\r\n{\r\nstruct hvc_struct *hp = dev_get_drvdata(&dev->dev);\r\nint rc, termno;\r\ntermno = hp->vtermno;\r\nrc = hvc_remove(hp);\r\nif (rc == 0) {\r\nif (hvc_opal_privs[termno] != &hvc_opal_boot_priv)\r\nkfree(hvc_opal_privs[termno]);\r\nhvc_opal_privs[termno] = NULL;\r\n}\r\nreturn rc;\r\n}\r\nstatic int __init hvc_opal_init(void)\r\n{\r\nif (!firmware_has_feature(FW_FEATURE_OPAL))\r\nreturn -ENODEV;\r\nreturn platform_driver_register(&hvc_opal_driver);\r\n}\r\nstatic void udbg_opal_putc(char c)\r\n{\r\nunsigned int termno = hvc_opal_boot_termno;\r\nint count = -1;\r\nif (c == '\n')\r\nudbg_opal_putc('\r');\r\ndo {\r\nswitch(hvc_opal_boot_priv.proto) {\r\ncase HV_PROTOCOL_RAW:\r\ncount = opal_put_chars(termno, &c, 1);\r\nbreak;\r\ncase HV_PROTOCOL_HVSI:\r\ncount = hvc_opal_hvsi_put_chars(termno, &c, 1);\r\nbreak;\r\n}\r\n} while(count == 0 || count == -EAGAIN);\r\n}\r\nstatic int udbg_opal_getc_poll(void)\r\n{\r\nunsigned int termno = hvc_opal_boot_termno;\r\nint rc = 0;\r\nchar c;\r\nswitch(hvc_opal_boot_priv.proto) {\r\ncase HV_PROTOCOL_RAW:\r\nrc = opal_get_chars(termno, &c, 1);\r\nbreak;\r\ncase HV_PROTOCOL_HVSI:\r\nrc = hvc_opal_hvsi_get_chars(termno, &c, 1);\r\nbreak;\r\n}\r\nif (!rc)\r\nreturn -1;\r\nreturn c;\r\n}\r\nstatic int udbg_opal_getc(void)\r\n{\r\nint ch;\r\nfor (;;) {\r\nch = udbg_opal_getc_poll();\r\nif (ch == -1) {\r\nvolatile unsigned long delay;\r\nfor (delay=0; delay < 2000000; delay++)\r\n;\r\n} else {\r\nreturn ch;\r\n}\r\n}\r\n}\r\nstatic void udbg_init_opal_common(void)\r\n{\r\nudbg_putc = udbg_opal_putc;\r\nudbg_getc = udbg_opal_getc;\r\nudbg_getc_poll = udbg_opal_getc_poll;\r\ntb_ticks_per_usec = 0x200;\r\n}\r\nvoid __init hvc_opal_init_early(void)\r\n{\r\nstruct device_node *stdout_node = of_node_get(of_stdout);\r\nconst __be32 *termno;\r\nconst struct hv_ops *ops;\r\nu32 index;\r\nif (!stdout_node) {\r\nstruct device_node *opal, *np;\r\nopal = of_find_node_by_path("/ibm,opal/consoles");\r\nif (opal)\r\npr_devel("hvc_opal: Found consoles in new location\n");\r\nif (!opal) {\r\nopal = of_find_node_by_path("/ibm,opal");\r\nif (opal)\r\npr_devel("hvc_opal: "\r\n"Found consoles in old location\n");\r\n}\r\nif (!opal)\r\nreturn;\r\nfor_each_child_of_node(opal, np) {\r\nif (!strcmp(np->name, "serial")) {\r\nstdout_node = np;\r\nbreak;\r\n}\r\n}\r\nof_node_put(opal);\r\n}\r\nif (!stdout_node)\r\nreturn;\r\ntermno = of_get_property(stdout_node, "reg", NULL);\r\nindex = termno ? be32_to_cpup(termno) : 0;\r\nif (index >= MAX_NR_HVC_CONSOLES)\r\nreturn;\r\nhvc_opal_privs[index] = &hvc_opal_boot_priv;\r\nif (of_device_is_compatible(stdout_node, "ibm,opal-console-raw")) {\r\nhvc_opal_boot_priv.proto = HV_PROTOCOL_RAW;\r\nops = &hvc_opal_raw_ops;\r\npr_devel("hvc_opal: Found RAW console\n");\r\n}\r\nelse if (of_device_is_compatible(stdout_node,"ibm,opal-console-hvsi")) {\r\nhvc_opal_boot_priv.proto = HV_PROTOCOL_HVSI;\r\nops = &hvc_opal_hvsi_ops;\r\nhvsilib_init(&hvc_opal_boot_priv.hvsi, opal_get_chars,\r\nopal_put_chars, index, 1);\r\nhvsilib_establish(&hvc_opal_boot_priv.hvsi);\r\npr_devel("hvc_opal: Found HVSI console\n");\r\n} else\r\ngoto out;\r\nhvc_opal_boot_termno = index;\r\nudbg_init_opal_common();\r\nadd_preferred_console("hvc", index, NULL);\r\nhvc_instantiate(index, index, ops);\r\nout:\r\nof_node_put(stdout_node);\r\n}\r\nvoid __init udbg_init_debug_opal_raw(void)\r\n{\r\nu32 index = CONFIG_PPC_EARLY_DEBUG_OPAL_VTERMNO;\r\nhvc_opal_privs[index] = &hvc_opal_boot_priv;\r\nhvc_opal_boot_priv.proto = HV_PROTOCOL_RAW;\r\nhvc_opal_boot_termno = index;\r\nudbg_init_opal_common();\r\n}\r\nvoid __init udbg_init_debug_opal_hvsi(void)\r\n{\r\nu32 index = CONFIG_PPC_EARLY_DEBUG_OPAL_VTERMNO;\r\nhvc_opal_privs[index] = &hvc_opal_boot_priv;\r\nhvc_opal_boot_termno = index;\r\nudbg_init_opal_common();\r\nhvsilib_init(&hvc_opal_boot_priv.hvsi, opal_get_chars, opal_put_chars,\r\nindex, 1);\r\nhvsilib_establish(&hvc_opal_boot_priv.hvsi);\r\n}
