static ssize_t show_companion(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ehci_hcd *ehci;\r\nint nports, index, n;\r\nint count = PAGE_SIZE;\r\nchar *ptr = buf;\r\nehci = hcd_to_ehci(dev_get_drvdata(dev));\r\nnports = HCS_N_PORTS(ehci->hcs_params);\r\nfor (index = 0; index < nports; ++index) {\r\nif (test_bit(index, &ehci->companion_ports)) {\r\nn = scnprintf(ptr, count, "%d\n", index + 1);\r\nptr += n;\r\ncount -= n;\r\n}\r\n}\r\nreturn ptr - buf;\r\n}\r\nstatic ssize_t store_companion(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ehci_hcd *ehci;\r\nint portnum, new_owner;\r\nehci = hcd_to_ehci(dev_get_drvdata(dev));\r\nnew_owner = PORT_OWNER;\r\nif (sscanf(buf, "%d", &portnum) != 1)\r\nreturn -EINVAL;\r\nif (portnum < 0) {\r\nportnum = - portnum;\r\nnew_owner = 0;\r\n}\r\nif (portnum <= 0 || portnum > HCS_N_PORTS(ehci->hcs_params))\r\nreturn -ENOENT;\r\nportnum--;\r\nif (new_owner)\r\nset_bit(portnum, &ehci->companion_ports);\r\nelse\r\nclear_bit(portnum, &ehci->companion_ports);\r\nset_owner(ehci, portnum, new_owner);\r\nreturn count;\r\n}\r\nstatic ssize_t show_uframe_periodic_max(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ehci_hcd *ehci;\r\nint n;\r\nehci = hcd_to_ehci(dev_get_drvdata(dev));\r\nn = scnprintf(buf, PAGE_SIZE, "%d\n", ehci->uframe_periodic_max);\r\nreturn n;\r\n}\r\nstatic ssize_t store_uframe_periodic_max(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ehci_hcd *ehci;\r\nunsigned uframe_periodic_max;\r\nunsigned uframe;\r\nunsigned long flags;\r\nssize_t ret;\r\nehci = hcd_to_ehci(dev_get_drvdata(dev));\r\nif (kstrtouint(buf, 0, &uframe_periodic_max) < 0)\r\nreturn -EINVAL;\r\nif (uframe_periodic_max < 100 || uframe_periodic_max >= 125) {\r\nehci_info(ehci, "rejecting invalid request for "\r\n"uframe_periodic_max=%u\n", uframe_periodic_max);\r\nreturn -EINVAL;\r\n}\r\nret = -EINVAL;\r\nspin_lock_irqsave (&ehci->lock, flags);\r\nif (uframe_periodic_max < ehci->uframe_periodic_max) {\r\nu8 allocated_max = 0;\r\nfor (uframe = 0; uframe < EHCI_BANDWIDTH_SIZE; ++uframe)\r\nallocated_max = max(allocated_max,\r\nehci->bandwidth[uframe]);\r\nif (allocated_max > uframe_periodic_max) {\r\nehci_info(ehci,\r\n"cannot decrease uframe_periodic_max because "\r\n"periodic bandwidth is already allocated "\r\n"(%u > %u)\n",\r\nallocated_max, uframe_periodic_max);\r\ngoto out_unlock;\r\n}\r\n}\r\nehci_info(ehci, "setting max periodic bandwidth to %u%% "\r\n"(== %u usec/uframe)\n",\r\n100*uframe_periodic_max/125, uframe_periodic_max);\r\nif (uframe_periodic_max != 100)\r\nehci_warn(ehci, "max periodic bandwidth set is non-standard\n");\r\nehci->uframe_periodic_max = uframe_periodic_max;\r\nret = count;\r\nout_unlock:\r\nspin_unlock_irqrestore (&ehci->lock, flags);\r\nreturn ret;\r\n}\r\nstatic inline int create_sysfs_files(struct ehci_hcd *ehci)\r\n{\r\nstruct device *controller = ehci_to_hcd(ehci)->self.controller;\r\nint i = 0;\r\nif (!ehci_is_TDI(ehci))\r\ni = device_create_file(controller, &dev_attr_companion);\r\nif (i)\r\ngoto out;\r\ni = device_create_file(controller, &dev_attr_uframe_periodic_max);\r\nout:\r\nreturn i;\r\n}\r\nstatic inline void remove_sysfs_files(struct ehci_hcd *ehci)\r\n{\r\nstruct device *controller = ehci_to_hcd(ehci)->self.controller;\r\nif (!ehci_is_TDI(ehci))\r\ndevice_remove_file(controller, &dev_attr_companion);\r\ndevice_remove_file(controller, &dev_attr_uframe_periodic_max);\r\n}
