static int pm8001_find_tag(struct sas_task *task, u32 *tag)\r\n{\r\nif (task->lldd_task) {\r\nstruct pm8001_ccb_info *ccb;\r\nccb = task->lldd_task;\r\n*tag = ccb->ccb_tag;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid pm8001_tag_free(struct pm8001_hba_info *pm8001_ha, u32 tag)\r\n{\r\nvoid *bitmap = pm8001_ha->tags;\r\nclear_bit(tag, bitmap);\r\n}\r\ninline int pm8001_tag_alloc(struct pm8001_hba_info *pm8001_ha, u32 *tag_out)\r\n{\r\nunsigned int tag;\r\nvoid *bitmap = pm8001_ha->tags;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pm8001_ha->bitmap_lock, flags);\r\ntag = find_first_zero_bit(bitmap, pm8001_ha->tags_num);\r\nif (tag >= pm8001_ha->tags_num) {\r\nspin_unlock_irqrestore(&pm8001_ha->bitmap_lock, flags);\r\nreturn -SAS_QUEUE_FULL;\r\n}\r\nset_bit(tag, bitmap);\r\nspin_unlock_irqrestore(&pm8001_ha->bitmap_lock, flags);\r\n*tag_out = tag;\r\nreturn 0;\r\n}\r\nvoid pm8001_tag_init(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nint i;\r\nfor (i = 0; i < pm8001_ha->tags_num; ++i)\r\npm8001_tag_free(pm8001_ha, i);\r\n}\r\nint pm8001_mem_alloc(struct pci_dev *pdev, void **virt_addr,\r\ndma_addr_t *pphys_addr, u32 *pphys_addr_hi,\r\nu32 *pphys_addr_lo, u32 mem_size, u32 align)\r\n{\r\ncaddr_t mem_virt_alloc;\r\ndma_addr_t mem_dma_handle;\r\nu64 phys_align;\r\nu64 align_offset = 0;\r\nif (align)\r\nalign_offset = (dma_addr_t)align - 1;\r\nmem_virt_alloc = pci_zalloc_consistent(pdev, mem_size + align,\r\n&mem_dma_handle);\r\nif (!mem_virt_alloc) {\r\npm8001_printk("memory allocation error\n");\r\nreturn -1;\r\n}\r\n*pphys_addr = mem_dma_handle;\r\nphys_align = (*pphys_addr + align_offset) & ~align_offset;\r\n*virt_addr = (void *)mem_virt_alloc + phys_align - *pphys_addr;\r\n*pphys_addr_hi = upper_32_bits(phys_align);\r\n*pphys_addr_lo = lower_32_bits(phys_align);\r\nreturn 0;\r\n}\r\nstatic\r\nstruct pm8001_hba_info *pm8001_find_ha_by_dev(struct domain_device *dev)\r\n{\r\nstruct sas_ha_struct *sha = dev->port->ha;\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nreturn pm8001_ha;\r\n}\r\nint pm8001_phy_control(struct asd_sas_phy *sas_phy, enum phy_func func,\r\nvoid *funcdata)\r\n{\r\nint rc = 0, phy_id = sas_phy->id;\r\nstruct pm8001_hba_info *pm8001_ha = NULL;\r\nstruct sas_phy_linkrates *rates;\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nunsigned long flags;\r\npm8001_ha = sas_phy->ha->lldd_ha;\r\npm8001_ha->phy[phy_id].enable_completion = &completion;\r\nswitch (func) {\r\ncase PHY_FUNC_SET_LINK_RATE:\r\nrates = funcdata;\r\nif (rates->minimum_linkrate) {\r\npm8001_ha->phy[phy_id].minimum_linkrate =\r\nrates->minimum_linkrate;\r\n}\r\nif (rates->maximum_linkrate) {\r\npm8001_ha->phy[phy_id].maximum_linkrate =\r\nrates->maximum_linkrate;\r\n}\r\nif (pm8001_ha->phy[phy_id].phy_state == 0) {\r\nPM8001_CHIP_DISP->phy_start_req(pm8001_ha, phy_id);\r\nwait_for_completion(&completion);\r\n}\r\nPM8001_CHIP_DISP->phy_ctl_req(pm8001_ha, phy_id,\r\nPHY_LINK_RESET);\r\nbreak;\r\ncase PHY_FUNC_HARD_RESET:\r\nif (pm8001_ha->phy[phy_id].phy_state == 0) {\r\nPM8001_CHIP_DISP->phy_start_req(pm8001_ha, phy_id);\r\nwait_for_completion(&completion);\r\n}\r\nPM8001_CHIP_DISP->phy_ctl_req(pm8001_ha, phy_id,\r\nPHY_HARD_RESET);\r\nbreak;\r\ncase PHY_FUNC_LINK_RESET:\r\nif (pm8001_ha->phy[phy_id].phy_state == 0) {\r\nPM8001_CHIP_DISP->phy_start_req(pm8001_ha, phy_id);\r\nwait_for_completion(&completion);\r\n}\r\nPM8001_CHIP_DISP->phy_ctl_req(pm8001_ha, phy_id,\r\nPHY_LINK_RESET);\r\nbreak;\r\ncase PHY_FUNC_RELEASE_SPINUP_HOLD:\r\nPM8001_CHIP_DISP->phy_ctl_req(pm8001_ha, phy_id,\r\nPHY_LINK_RESET);\r\nbreak;\r\ncase PHY_FUNC_DISABLE:\r\nPM8001_CHIP_DISP->phy_stop_req(pm8001_ha, phy_id);\r\nbreak;\r\ncase PHY_FUNC_GET_EVENTS:\r\nspin_lock_irqsave(&pm8001_ha->lock, flags);\r\nif (pm8001_ha->chip_id == chip_8001) {\r\nif (-1 == pm8001_bar4_shift(pm8001_ha,\r\n(phy_id < 4) ? 0x30000 : 0x40000)) {\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nreturn -EINVAL;\r\n}\r\n}\r\n{\r\nstruct sas_phy *phy = sas_phy->phy;\r\nuint32_t *qp = (uint32_t *)(((char *)\r\npm8001_ha->io_mem[2].memvirtaddr)\r\n+ 0x1034 + (0x4000 * (phy_id & 3)));\r\nphy->invalid_dword_count = qp[0];\r\nphy->running_disparity_error_count = qp[1];\r\nphy->loss_of_dword_sync_count = qp[3];\r\nphy->phy_reset_problem_count = qp[4];\r\n}\r\nif (pm8001_ha->chip_id == chip_8001)\r\npm8001_bar4_shift(pm8001_ha, 0);\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nreturn 0;\r\ndefault:\r\nrc = -EOPNOTSUPP;\r\n}\r\nmsleep(300);\r\nreturn rc;\r\n}\r\nvoid pm8001_scan_start(struct Scsi_Host *shost)\r\n{\r\nint i;\r\nstruct pm8001_hba_info *pm8001_ha;\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\npm8001_ha = sha->lldd_ha;\r\nif (pm8001_ha->chip_id == chip_8001)\r\nPM8001_CHIP_DISP->sas_re_init_req(pm8001_ha);\r\nfor (i = 0; i < pm8001_ha->chip->n_phy; ++i)\r\nPM8001_CHIP_DISP->phy_start_req(pm8001_ha, i);\r\n}\r\nint pm8001_scan_finished(struct Scsi_Host *shost, unsigned long time)\r\n{\r\nstruct sas_ha_struct *ha = SHOST_TO_SAS_HA(shost);\r\nif (time < HZ)\r\nreturn 0;\r\nsas_drain_work(ha);\r\nreturn 1;\r\n}\r\nstatic int pm8001_task_prep_smp(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_ccb_info *ccb)\r\n{\r\nreturn PM8001_CHIP_DISP->smp_req(pm8001_ha, ccb);\r\n}\r\nu32 pm8001_get_ncq_tag(struct sas_task *task, u32 *tag)\r\n{\r\nstruct ata_queued_cmd *qc = task->uldd_task;\r\nif (qc) {\r\nif (qc->tf.command == ATA_CMD_FPDMA_WRITE ||\r\nqc->tf.command == ATA_CMD_FPDMA_READ) {\r\n*tag = qc->tag;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm8001_task_prep_ata(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_ccb_info *ccb)\r\n{\r\nreturn PM8001_CHIP_DISP->sata_req(pm8001_ha, ccb);\r\n}\r\nstatic int pm8001_task_prep_ssp_tm(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_ccb_info *ccb, struct pm8001_tmf_task *tmf)\r\n{\r\nreturn PM8001_CHIP_DISP->ssp_tm_req(pm8001_ha, ccb, tmf);\r\n}\r\nstatic int pm8001_task_prep_ssp(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_ccb_info *ccb)\r\n{\r\nreturn PM8001_CHIP_DISP->ssp_io_req(pm8001_ha, ccb);\r\n}\r\nstatic int sas_find_local_port_id(struct domain_device *dev)\r\n{\r\nstruct domain_device *pdev = dev->parent;\r\nif (!pdev)\r\nreturn dev->port->id;\r\nwhile (pdev) {\r\nstruct domain_device *pdev_p = pdev->parent;\r\nif (!pdev_p)\r\nreturn pdev->port->id;\r\npdev = pdev->parent;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm8001_task_exec(struct sas_task *task,\r\ngfp_t gfp_flags, int is_tmf, struct pm8001_tmf_task *tmf)\r\n{\r\nstruct domain_device *dev = task->dev;\r\nstruct pm8001_hba_info *pm8001_ha;\r\nstruct pm8001_device *pm8001_dev;\r\nstruct pm8001_port *port = NULL;\r\nstruct sas_task *t = task;\r\nstruct pm8001_ccb_info *ccb;\r\nu32 tag = 0xdeadbeef, rc, n_elem = 0;\r\nunsigned long flags = 0;\r\nif (!dev->port) {\r\nstruct task_status_struct *tsm = &t->task_status;\r\ntsm->resp = SAS_TASK_UNDELIVERED;\r\ntsm->stat = SAS_PHY_DOWN;\r\nif (dev->dev_type != SAS_SATA_DEV)\r\nt->task_done(t);\r\nreturn 0;\r\n}\r\npm8001_ha = pm8001_find_ha_by_dev(task->dev);\r\nPM8001_IO_DBG(pm8001_ha, pm8001_printk("pm8001_task_exec device \n "));\r\nspin_lock_irqsave(&pm8001_ha->lock, flags);\r\ndo {\r\ndev = t->dev;\r\npm8001_dev = dev->lldd_dev;\r\nport = &pm8001_ha->port[sas_find_local_port_id(dev)];\r\nif (DEV_IS_GONE(pm8001_dev) || !port->port_attached) {\r\nif (sas_protocol_ata(t->task_proto)) {\r\nstruct task_status_struct *ts = &t->task_status;\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_PHY_DOWN;\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nt->task_done(t);\r\nspin_lock_irqsave(&pm8001_ha->lock, flags);\r\ncontinue;\r\n} else {\r\nstruct task_status_struct *ts = &t->task_status;\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_PHY_DOWN;\r\nt->task_done(t);\r\ncontinue;\r\n}\r\n}\r\nrc = pm8001_tag_alloc(pm8001_ha, &tag);\r\nif (rc)\r\ngoto err_out;\r\nccb = &pm8001_ha->ccb_info[tag];\r\nif (!sas_protocol_ata(t->task_proto)) {\r\nif (t->num_scatter) {\r\nn_elem = dma_map_sg(pm8001_ha->dev,\r\nt->scatter,\r\nt->num_scatter,\r\nt->data_dir);\r\nif (!n_elem) {\r\nrc = -ENOMEM;\r\ngoto err_out_tag;\r\n}\r\n}\r\n} else {\r\nn_elem = t->num_scatter;\r\n}\r\nt->lldd_task = ccb;\r\nccb->n_elem = n_elem;\r\nccb->ccb_tag = tag;\r\nccb->task = t;\r\nccb->device = pm8001_dev;\r\nswitch (t->task_proto) {\r\ncase SAS_PROTOCOL_SMP:\r\nrc = pm8001_task_prep_smp(pm8001_ha, ccb);\r\nbreak;\r\ncase SAS_PROTOCOL_SSP:\r\nif (is_tmf)\r\nrc = pm8001_task_prep_ssp_tm(pm8001_ha,\r\nccb, tmf);\r\nelse\r\nrc = pm8001_task_prep_ssp(pm8001_ha, ccb);\r\nbreak;\r\ncase SAS_PROTOCOL_SATA:\r\ncase SAS_PROTOCOL_STP:\r\nrc = pm8001_task_prep_ata(pm8001_ha, ccb);\r\nbreak;\r\ndefault:\r\ndev_printk(KERN_ERR, pm8001_ha->dev,\r\n"unknown sas_task proto: 0x%x\n",\r\nt->task_proto);\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nif (rc) {\r\nPM8001_IO_DBG(pm8001_ha,\r\npm8001_printk("rc is %x\n", rc));\r\ngoto err_out_tag;\r\n}\r\nspin_lock(&t->task_state_lock);\r\nt->task_state_flags |= SAS_TASK_AT_INITIATOR;\r\nspin_unlock(&t->task_state_lock);\r\npm8001_dev->running_req++;\r\n} while (0);\r\nrc = 0;\r\ngoto out_done;\r\nerr_out_tag:\r\npm8001_tag_free(pm8001_ha, tag);\r\nerr_out:\r\ndev_printk(KERN_ERR, pm8001_ha->dev, "pm8001 exec failed[%d]!\n", rc);\r\nif (!sas_protocol_ata(t->task_proto))\r\nif (n_elem)\r\ndma_unmap_sg(pm8001_ha->dev, t->scatter, n_elem,\r\nt->data_dir);\r\nout_done:\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nreturn rc;\r\n}\r\nint pm8001_queue_command(struct sas_task *task, gfp_t gfp_flags)\r\n{\r\nreturn pm8001_task_exec(task, gfp_flags, 0, NULL);\r\n}\r\nvoid pm8001_ccb_task_free(struct pm8001_hba_info *pm8001_ha,\r\nstruct sas_task *task, struct pm8001_ccb_info *ccb, u32 ccb_idx)\r\n{\r\nif (!ccb->task)\r\nreturn;\r\nif (!sas_protocol_ata(task->task_proto))\r\nif (ccb->n_elem)\r\ndma_unmap_sg(pm8001_ha->dev, task->scatter,\r\ntask->num_scatter, task->data_dir);\r\nswitch (task->task_proto) {\r\ncase SAS_PROTOCOL_SMP:\r\ndma_unmap_sg(pm8001_ha->dev, &task->smp_task.smp_resp, 1,\r\nPCI_DMA_FROMDEVICE);\r\ndma_unmap_sg(pm8001_ha->dev, &task->smp_task.smp_req, 1,\r\nPCI_DMA_TODEVICE);\r\nbreak;\r\ncase SAS_PROTOCOL_SATA:\r\ncase SAS_PROTOCOL_STP:\r\ncase SAS_PROTOCOL_SSP:\r\ndefault:\r\nbreak;\r\n}\r\ntask->lldd_task = NULL;\r\nccb->task = NULL;\r\nccb->ccb_tag = 0xFFFFFFFF;\r\nccb->open_retry = 0;\r\npm8001_tag_free(pm8001_ha, ccb_idx);\r\n}\r\nstruct pm8001_device *pm8001_alloc_dev(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu32 dev;\r\nfor (dev = 0; dev < PM8001_MAX_DEVICES; dev++) {\r\nif (pm8001_ha->devices[dev].dev_type == SAS_PHY_UNUSED) {\r\npm8001_ha->devices[dev].id = dev;\r\nreturn &pm8001_ha->devices[dev];\r\n}\r\n}\r\nif (dev == PM8001_MAX_DEVICES) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("max support %d devices, ignore ..\n",\r\nPM8001_MAX_DEVICES));\r\n}\r\nreturn NULL;\r\n}\r\nstruct pm8001_device *pm8001_find_dev(struct pm8001_hba_info *pm8001_ha,\r\nu32 device_id)\r\n{\r\nu32 dev;\r\nfor (dev = 0; dev < PM8001_MAX_DEVICES; dev++) {\r\nif (pm8001_ha->devices[dev].device_id == device_id)\r\nreturn &pm8001_ha->devices[dev];\r\n}\r\nif (dev == PM8001_MAX_DEVICES) {\r\nPM8001_FAIL_DBG(pm8001_ha, pm8001_printk("NO MATCHING "\r\n"DEVICE FOUND !!!\n"));\r\n}\r\nreturn NULL;\r\n}\r\nstatic void pm8001_free_dev(struct pm8001_device *pm8001_dev)\r\n{\r\nu32 id = pm8001_dev->id;\r\nmemset(pm8001_dev, 0, sizeof(*pm8001_dev));\r\npm8001_dev->id = id;\r\npm8001_dev->dev_type = SAS_PHY_UNUSED;\r\npm8001_dev->device_id = PM8001_MAX_DEVICES;\r\npm8001_dev->sas_device = NULL;\r\n}\r\nstatic int pm8001_dev_found_notify(struct domain_device *dev)\r\n{\r\nunsigned long flags = 0;\r\nint res = 0;\r\nstruct pm8001_hba_info *pm8001_ha = NULL;\r\nstruct domain_device *parent_dev = dev->parent;\r\nstruct pm8001_device *pm8001_device;\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nu32 flag = 0;\r\npm8001_ha = pm8001_find_ha_by_dev(dev);\r\nspin_lock_irqsave(&pm8001_ha->lock, flags);\r\npm8001_device = pm8001_alloc_dev(pm8001_ha);\r\nif (!pm8001_device) {\r\nres = -1;\r\ngoto found_out;\r\n}\r\npm8001_device->sas_device = dev;\r\ndev->lldd_dev = pm8001_device;\r\npm8001_device->dev_type = dev->dev_type;\r\npm8001_device->dcompletion = &completion;\r\nif (parent_dev && DEV_IS_EXPANDER(parent_dev->dev_type)) {\r\nint phy_id;\r\nstruct ex_phy *phy;\r\nfor (phy_id = 0; phy_id < parent_dev->ex_dev.num_phys;\r\nphy_id++) {\r\nphy = &parent_dev->ex_dev.ex_phy[phy_id];\r\nif (SAS_ADDR(phy->attached_sas_addr)\r\n== SAS_ADDR(dev->sas_addr)) {\r\npm8001_device->attached_phy = phy_id;\r\nbreak;\r\n}\r\n}\r\nif (phy_id == parent_dev->ex_dev.num_phys) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Error: no attached dev:%016llx"\r\n" at ex:%016llx.\n", SAS_ADDR(dev->sas_addr),\r\nSAS_ADDR(parent_dev->sas_addr)));\r\nres = -1;\r\n}\r\n} else {\r\nif (dev->dev_type == SAS_SATA_DEV) {\r\npm8001_device->attached_phy =\r\ndev->rphy->identify.phy_identifier;\r\nflag = 1;\r\n}\r\n}\r\nPM8001_DISC_DBG(pm8001_ha, pm8001_printk("Found device\n"));\r\nPM8001_CHIP_DISP->reg_dev_req(pm8001_ha, pm8001_device, flag);\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nwait_for_completion(&completion);\r\nif (dev->dev_type == SAS_END_DEVICE)\r\nmsleep(50);\r\npm8001_ha->flags = PM8001F_RUN_TIME;\r\nreturn 0;\r\nfound_out:\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\nreturn res;\r\n}\r\nint pm8001_dev_found(struct domain_device *dev)\r\n{\r\nreturn pm8001_dev_found_notify(dev);\r\n}\r\nvoid pm8001_task_done(struct sas_task *task)\r\n{\r\nif (!del_timer(&task->slow_task->timer))\r\nreturn;\r\ncomplete(&task->slow_task->completion);\r\n}\r\nstatic void pm8001_tmf_timedout(unsigned long data)\r\n{\r\nstruct sas_task *task = (struct sas_task *)data;\r\ntask->task_state_flags |= SAS_TASK_STATE_ABORTED;\r\ncomplete(&task->slow_task->completion);\r\n}\r\nstatic int pm8001_exec_internal_tmf_task(struct domain_device *dev,\r\nvoid *parameter, u32 para_len, struct pm8001_tmf_task *tmf)\r\n{\r\nint res, retry;\r\nstruct sas_task *task = NULL;\r\nstruct pm8001_hba_info *pm8001_ha = pm8001_find_ha_by_dev(dev);\r\nstruct pm8001_device *pm8001_dev = dev->lldd_dev;\r\nDECLARE_COMPLETION_ONSTACK(completion_setstate);\r\nfor (retry = 0; retry < 3; retry++) {\r\ntask = sas_alloc_slow_task(GFP_KERNEL);\r\nif (!task)\r\nreturn -ENOMEM;\r\ntask->dev = dev;\r\ntask->task_proto = dev->tproto;\r\nmemcpy(&task->ssp_task, parameter, para_len);\r\ntask->task_done = pm8001_task_done;\r\ntask->slow_task->timer.data = (unsigned long)task;\r\ntask->slow_task->timer.function = pm8001_tmf_timedout;\r\ntask->slow_task->timer.expires = jiffies + PM8001_TASK_TIMEOUT*HZ;\r\nadd_timer(&task->slow_task->timer);\r\nres = pm8001_task_exec(task, GFP_KERNEL, 1, tmf);\r\nif (res) {\r\ndel_timer(&task->slow_task->timer);\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Executing internal task "\r\n"failed\n"));\r\ngoto ex_err;\r\n}\r\nwait_for_completion(&task->slow_task->completion);\r\nif (pm8001_ha->chip_id != chip_8001) {\r\npm8001_dev->setds_completion = &completion_setstate;\r\nPM8001_CHIP_DISP->set_dev_state_req(pm8001_ha,\r\npm8001_dev, 0x01);\r\nwait_for_completion(&completion_setstate);\r\n}\r\nres = -TMF_RESP_FUNC_FAILED;\r\nif ((task->task_state_flags & SAS_TASK_STATE_ABORTED)) {\r\nif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("TMF task[%x]timeout.\n",\r\ntmf->tmf));\r\ngoto ex_err;\r\n}\r\n}\r\nif (task->task_status.resp == SAS_TASK_COMPLETE &&\r\ntask->task_status.stat == SAM_STAT_GOOD) {\r\nres = TMF_RESP_FUNC_COMPLETE;\r\nbreak;\r\n}\r\nif (task->task_status.resp == SAS_TASK_COMPLETE &&\r\ntask->task_status.stat == SAS_DATA_UNDERRUN) {\r\nres = task->task_status.residual;\r\nbreak;\r\n}\r\nif (task->task_status.resp == SAS_TASK_COMPLETE &&\r\ntask->task_status.stat == SAS_DATA_OVERRUN) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Blocked task error.\n"));\r\nres = -EMSGSIZE;\r\nbreak;\r\n} else {\r\nPM8001_EH_DBG(pm8001_ha,\r\npm8001_printk(" Task to dev %016llx response:"\r\n"0x%x status 0x%x\n",\r\nSAS_ADDR(dev->sas_addr),\r\ntask->task_status.resp,\r\ntask->task_status.stat));\r\nsas_free_task(task);\r\ntask = NULL;\r\n}\r\n}\r\nex_err:\r\nBUG_ON(retry == 3 && task != NULL);\r\nsas_free_task(task);\r\nreturn res;\r\n}\r\nstatic int\r\npm8001_exec_internal_task_abort(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_device *pm8001_dev, struct domain_device *dev, u32 flag,\r\nu32 task_tag)\r\n{\r\nint res, retry;\r\nu32 ccb_tag;\r\nstruct pm8001_ccb_info *ccb;\r\nstruct sas_task *task = NULL;\r\nfor (retry = 0; retry < 3; retry++) {\r\ntask = sas_alloc_slow_task(GFP_KERNEL);\r\nif (!task)\r\nreturn -ENOMEM;\r\ntask->dev = dev;\r\ntask->task_proto = dev->tproto;\r\ntask->task_done = pm8001_task_done;\r\ntask->slow_task->timer.data = (unsigned long)task;\r\ntask->slow_task->timer.function = pm8001_tmf_timedout;\r\ntask->slow_task->timer.expires = jiffies + PM8001_TASK_TIMEOUT * HZ;\r\nadd_timer(&task->slow_task->timer);\r\nres = pm8001_tag_alloc(pm8001_ha, &ccb_tag);\r\nif (res)\r\nreturn res;\r\nccb = &pm8001_ha->ccb_info[ccb_tag];\r\nccb->device = pm8001_dev;\r\nccb->ccb_tag = ccb_tag;\r\nccb->task = task;\r\nccb->n_elem = 0;\r\nres = PM8001_CHIP_DISP->task_abort(pm8001_ha,\r\npm8001_dev, flag, task_tag, ccb_tag);\r\nif (res) {\r\ndel_timer(&task->slow_task->timer);\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Executing internal task "\r\n"failed\n"));\r\ngoto ex_err;\r\n}\r\nwait_for_completion(&task->slow_task->completion);\r\nres = TMF_RESP_FUNC_FAILED;\r\nif ((task->task_state_flags & SAS_TASK_STATE_ABORTED)) {\r\nif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("TMF task timeout.\n"));\r\ngoto ex_err;\r\n}\r\n}\r\nif (task->task_status.resp == SAS_TASK_COMPLETE &&\r\ntask->task_status.stat == SAM_STAT_GOOD) {\r\nres = TMF_RESP_FUNC_COMPLETE;\r\nbreak;\r\n} else {\r\nPM8001_EH_DBG(pm8001_ha,\r\npm8001_printk(" Task to dev %016llx response: "\r\n"0x%x status 0x%x\n",\r\nSAS_ADDR(dev->sas_addr),\r\ntask->task_status.resp,\r\ntask->task_status.stat));\r\nsas_free_task(task);\r\ntask = NULL;\r\n}\r\n}\r\nex_err:\r\nBUG_ON(retry == 3 && task != NULL);\r\nsas_free_task(task);\r\nreturn res;\r\n}\r\nstatic void pm8001_dev_gone_notify(struct domain_device *dev)\r\n{\r\nunsigned long flags = 0;\r\nstruct pm8001_hba_info *pm8001_ha;\r\nstruct pm8001_device *pm8001_dev = dev->lldd_dev;\r\npm8001_ha = pm8001_find_ha_by_dev(dev);\r\nspin_lock_irqsave(&pm8001_ha->lock, flags);\r\nif (pm8001_dev) {\r\nu32 device_id = pm8001_dev->device_id;\r\nPM8001_DISC_DBG(pm8001_ha,\r\npm8001_printk("found dev[%d:%x] is gone.\n",\r\npm8001_dev->device_id, pm8001_dev->dev_type));\r\nif (pm8001_dev->running_req) {\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\npm8001_exec_internal_task_abort(pm8001_ha, pm8001_dev ,\r\ndev, 1, 0);\r\nspin_lock_irqsave(&pm8001_ha->lock, flags);\r\n}\r\nPM8001_CHIP_DISP->dereg_dev_req(pm8001_ha, device_id);\r\npm8001_free_dev(pm8001_dev);\r\n} else {\r\nPM8001_DISC_DBG(pm8001_ha,\r\npm8001_printk("Found dev has gone.\n"));\r\n}\r\ndev->lldd_dev = NULL;\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\n}\r\nvoid pm8001_dev_gone(struct domain_device *dev)\r\n{\r\npm8001_dev_gone_notify(dev);\r\n}\r\nstatic int pm8001_issue_ssp_tmf(struct domain_device *dev,\r\nu8 *lun, struct pm8001_tmf_task *tmf)\r\n{\r\nstruct sas_ssp_task ssp_task;\r\nif (!(dev->tproto & SAS_PROTOCOL_SSP))\r\nreturn TMF_RESP_FUNC_ESUPP;\r\nstrncpy((u8 *)&ssp_task.LUN, lun, 8);\r\nreturn pm8001_exec_internal_tmf_task(dev, &ssp_task, sizeof(ssp_task),\r\ntmf);\r\n}\r\nvoid pm8001_open_reject_retry(\r\nstruct pm8001_hba_info *pm8001_ha,\r\nstruct sas_task *task_to_close,\r\nstruct pm8001_device *device_to_close)\r\n{\r\nint i;\r\nunsigned long flags;\r\nif (pm8001_ha == NULL)\r\nreturn;\r\nspin_lock_irqsave(&pm8001_ha->lock, flags);\r\nfor (i = 0; i < PM8001_MAX_CCB; i++) {\r\nstruct sas_task *task;\r\nstruct task_status_struct *ts;\r\nstruct pm8001_device *pm8001_dev;\r\nunsigned long flags1;\r\nu32 tag;\r\nstruct pm8001_ccb_info *ccb = &pm8001_ha->ccb_info[i];\r\npm8001_dev = ccb->device;\r\nif (!pm8001_dev || (pm8001_dev->dev_type == SAS_PHY_UNUSED))\r\ncontinue;\r\nif (!device_to_close) {\r\nuintptr_t d = (uintptr_t)pm8001_dev\r\n- (uintptr_t)&pm8001_ha->devices;\r\nif (((d % sizeof(*pm8001_dev)) != 0)\r\n|| ((d / sizeof(*pm8001_dev)) >= PM8001_MAX_DEVICES))\r\ncontinue;\r\n} else if (pm8001_dev != device_to_close)\r\ncontinue;\r\ntag = ccb->ccb_tag;\r\nif (!tag || (tag == 0xFFFFFFFF))\r\ncontinue;\r\ntask = ccb->task;\r\nif (!task || !task->task_done)\r\ncontinue;\r\nif (task_to_close && (task != task_to_close))\r\ncontinue;\r\nts = &task->task_status;\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_OPEN_REJECT;\r\nts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\r\nif (pm8001_dev)\r\npm8001_dev->running_req--;\r\nspin_lock_irqsave(&task->task_state_lock, flags1);\r\ntask->task_state_flags &= ~SAS_TASK_STATE_PENDING;\r\ntask->task_state_flags &= ~SAS_TASK_AT_INITIATOR;\r\ntask->task_state_flags |= SAS_TASK_STATE_DONE;\r\nif (unlikely((task->task_state_flags\r\n& SAS_TASK_STATE_ABORTED))) {\r\nspin_unlock_irqrestore(&task->task_state_lock,\r\nflags1);\r\npm8001_ccb_task_free(pm8001_ha, task, ccb, tag);\r\n} else {\r\nspin_unlock_irqrestore(&task->task_state_lock,\r\nflags1);\r\npm8001_ccb_task_free(pm8001_ha, task, ccb, tag);\r\nmb();\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\ntask->task_done(task);\r\nspin_lock_irqsave(&pm8001_ha->lock, flags);\r\n}\r\n}\r\nspin_unlock_irqrestore(&pm8001_ha->lock, flags);\r\n}\r\nint pm8001_I_T_nexus_reset(struct domain_device *dev)\r\n{\r\nint rc = TMF_RESP_FUNC_FAILED;\r\nstruct pm8001_device *pm8001_dev;\r\nstruct pm8001_hba_info *pm8001_ha;\r\nstruct sas_phy *phy;\r\nif (!dev || !dev->lldd_dev)\r\nreturn -ENODEV;\r\npm8001_dev = dev->lldd_dev;\r\npm8001_ha = pm8001_find_ha_by_dev(dev);\r\nphy = sas_get_local_phy(dev);\r\nif (dev_is_sata(dev)) {\r\nif (scsi_is_sas_phy_local(phy)) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nrc = sas_phy_reset(phy, 1);\r\nif (rc) {\r\nPM8001_EH_DBG(pm8001_ha,\r\npm8001_printk("phy reset failed for device %x\n"\r\n"with rc %d\n", pm8001_dev->device_id, rc));\r\nrc = TMF_RESP_FUNC_FAILED;\r\ngoto out;\r\n}\r\nmsleep(2000);\r\nrc = pm8001_exec_internal_task_abort(pm8001_ha, pm8001_dev ,\r\ndev, 1, 0);\r\nif (rc) {\r\nPM8001_EH_DBG(pm8001_ha,\r\npm8001_printk("task abort failed %x\n"\r\n"with rc %d\n", pm8001_dev->device_id, rc));\r\nrc = TMF_RESP_FUNC_FAILED;\r\n}\r\n} else {\r\nrc = sas_phy_reset(phy, 1);\r\nmsleep(2000);\r\n}\r\nPM8001_EH_DBG(pm8001_ha, pm8001_printk(" for device[%x]:rc=%d\n",\r\npm8001_dev->device_id, rc));\r\nout:\r\nsas_put_local_phy(phy);\r\nreturn rc;\r\n}\r\nint pm8001_I_T_nexus_event_handler(struct domain_device *dev)\r\n{\r\nint rc = TMF_RESP_FUNC_FAILED;\r\nstruct pm8001_device *pm8001_dev;\r\nstruct pm8001_hba_info *pm8001_ha;\r\nstruct sas_phy *phy;\r\nu32 device_id = 0;\r\nif (!dev || !dev->lldd_dev)\r\nreturn -1;\r\npm8001_dev = dev->lldd_dev;\r\ndevice_id = pm8001_dev->device_id;\r\npm8001_ha = pm8001_find_ha_by_dev(dev);\r\nPM8001_EH_DBG(pm8001_ha,\r\npm8001_printk("I_T_Nexus handler invoked !!"));\r\nphy = sas_get_local_phy(dev);\r\nif (dev_is_sata(dev)) {\r\nDECLARE_COMPLETION_ONSTACK(completion_setstate);\r\nif (scsi_is_sas_phy_local(phy)) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nrc = pm8001_exec_internal_task_abort(pm8001_ha, pm8001_dev ,\r\ndev, 1, 0);\r\nmsleep(100);\r\npm8001_dev_gone_notify(dev);\r\nmsleep(200);\r\nrc = sas_phy_reset(phy, 1);\r\nmsleep(2000);\r\npm8001_dev->setds_completion = &completion_setstate;\r\nwait_for_completion(&completion_setstate);\r\n} else {\r\nrc = pm8001_exec_internal_task_abort(pm8001_ha, pm8001_dev ,\r\ndev, 1, 0);\r\nmsleep(100);\r\npm8001_dev_gone_notify(dev);\r\nmsleep(200);\r\nrc = sas_phy_reset(phy, 1);\r\nmsleep(2000);\r\n}\r\nPM8001_EH_DBG(pm8001_ha, pm8001_printk(" for device[%x]:rc=%d\n",\r\npm8001_dev->device_id, rc));\r\nout:\r\nsas_put_local_phy(phy);\r\nreturn rc;\r\n}\r\nint pm8001_lu_reset(struct domain_device *dev, u8 *lun)\r\n{\r\nint rc = TMF_RESP_FUNC_FAILED;\r\nstruct pm8001_tmf_task tmf_task;\r\nstruct pm8001_device *pm8001_dev = dev->lldd_dev;\r\nstruct pm8001_hba_info *pm8001_ha = pm8001_find_ha_by_dev(dev);\r\nDECLARE_COMPLETION_ONSTACK(completion_setstate);\r\nif (dev_is_sata(dev)) {\r\nstruct sas_phy *phy = sas_get_local_phy(dev);\r\nrc = pm8001_exec_internal_task_abort(pm8001_ha, pm8001_dev ,\r\ndev, 1, 0);\r\nrc = sas_phy_reset(phy, 1);\r\nsas_put_local_phy(phy);\r\npm8001_dev->setds_completion = &completion_setstate;\r\nrc = PM8001_CHIP_DISP->set_dev_state_req(pm8001_ha,\r\npm8001_dev, 0x01);\r\nwait_for_completion(&completion_setstate);\r\n} else {\r\ntmf_task.tmf = TMF_LU_RESET;\r\nrc = pm8001_issue_ssp_tmf(dev, lun, &tmf_task);\r\n}\r\nPM8001_EH_DBG(pm8001_ha, pm8001_printk("for device[%x]:rc=%d\n",\r\npm8001_dev->device_id, rc));\r\nreturn rc;\r\n}\r\nint pm8001_query_task(struct sas_task *task)\r\n{\r\nu32 tag = 0xdeadbeef;\r\nint i = 0;\r\nstruct scsi_lun lun;\r\nstruct pm8001_tmf_task tmf_task;\r\nint rc = TMF_RESP_FUNC_FAILED;\r\nif (unlikely(!task || !task->lldd_task || !task->dev))\r\nreturn rc;\r\nif (task->task_proto & SAS_PROTOCOL_SSP) {\r\nstruct scsi_cmnd *cmnd = task->uldd_task;\r\nstruct domain_device *dev = task->dev;\r\nstruct pm8001_hba_info *pm8001_ha =\r\npm8001_find_ha_by_dev(dev);\r\nint_to_scsilun(cmnd->device->lun, &lun);\r\nrc = pm8001_find_tag(task, &tag);\r\nif (rc == 0) {\r\nrc = TMF_RESP_FUNC_FAILED;\r\nreturn rc;\r\n}\r\nPM8001_EH_DBG(pm8001_ha, pm8001_printk("Query:["));\r\nfor (i = 0; i < 16; i++)\r\nprintk(KERN_INFO "%02x ", cmnd->cmnd[i]);\r\nprintk(KERN_INFO "]\n");\r\ntmf_task.tmf = TMF_QUERY_TASK;\r\ntmf_task.tag_of_task_to_be_managed = tag;\r\nrc = pm8001_issue_ssp_tmf(dev, lun.scsi_lun, &tmf_task);\r\nswitch (rc) {\r\ncase TMF_RESP_FUNC_SUCC:\r\nPM8001_EH_DBG(pm8001_ha,\r\npm8001_printk("The task is still in Lun\n"));\r\nbreak;\r\ncase TMF_RESP_FUNC_FAILED:\r\ncase TMF_RESP_FUNC_COMPLETE:\r\nPM8001_EH_DBG(pm8001_ha,\r\npm8001_printk("The task is not in Lun or failed,"\r\n" reset the phy\n"));\r\nbreak;\r\n}\r\n}\r\npm8001_printk(":rc= %d\n", rc);\r\nreturn rc;\r\n}\r\nint pm8001_abort_task(struct sas_task *task)\r\n{\r\nunsigned long flags;\r\nu32 tag = 0xdeadbeef;\r\nu32 device_id;\r\nstruct domain_device *dev ;\r\nstruct pm8001_hba_info *pm8001_ha = NULL;\r\nstruct pm8001_ccb_info *ccb;\r\nstruct scsi_lun lun;\r\nstruct pm8001_device *pm8001_dev;\r\nstruct pm8001_tmf_task tmf_task;\r\nint rc = TMF_RESP_FUNC_FAILED;\r\nif (unlikely(!task || !task->lldd_task || !task->dev))\r\nreturn rc;\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\nif (task->task_state_flags & SAS_TASK_STATE_DONE) {\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nrc = TMF_RESP_FUNC_COMPLETE;\r\ngoto out;\r\n}\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nif (task->task_proto & SAS_PROTOCOL_SSP) {\r\nstruct scsi_cmnd *cmnd = task->uldd_task;\r\ndev = task->dev;\r\nccb = task->lldd_task;\r\npm8001_dev = dev->lldd_dev;\r\npm8001_ha = pm8001_find_ha_by_dev(dev);\r\nint_to_scsilun(cmnd->device->lun, &lun);\r\nrc = pm8001_find_tag(task, &tag);\r\nif (rc == 0) {\r\nprintk(KERN_INFO "No such tag in %s\n", __func__);\r\nrc = TMF_RESP_FUNC_FAILED;\r\nreturn rc;\r\n}\r\ndevice_id = pm8001_dev->device_id;\r\nPM8001_EH_DBG(pm8001_ha,\r\npm8001_printk("abort io to deviceid= %d\n", device_id));\r\ntmf_task.tmf = TMF_ABORT_TASK;\r\ntmf_task.tag_of_task_to_be_managed = tag;\r\nrc = pm8001_issue_ssp_tmf(dev, lun.scsi_lun, &tmf_task);\r\npm8001_exec_internal_task_abort(pm8001_ha, pm8001_dev,\r\npm8001_dev->sas_device, 0, tag);\r\n} else if (task->task_proto & SAS_PROTOCOL_SATA ||\r\ntask->task_proto & SAS_PROTOCOL_STP) {\r\ndev = task->dev;\r\npm8001_dev = dev->lldd_dev;\r\npm8001_ha = pm8001_find_ha_by_dev(dev);\r\nrc = pm8001_find_tag(task, &tag);\r\nif (rc == 0) {\r\nprintk(KERN_INFO "No such tag in %s\n", __func__);\r\nrc = TMF_RESP_FUNC_FAILED;\r\nreturn rc;\r\n}\r\nrc = pm8001_exec_internal_task_abort(pm8001_ha, pm8001_dev,\r\npm8001_dev->sas_device, 0, tag);\r\n} else if (task->task_proto & SAS_PROTOCOL_SMP) {\r\ndev = task->dev;\r\npm8001_dev = dev->lldd_dev;\r\npm8001_ha = pm8001_find_ha_by_dev(dev);\r\nrc = pm8001_find_tag(task, &tag);\r\nif (rc == 0) {\r\nprintk(KERN_INFO "No such tag in %s\n", __func__);\r\nrc = TMF_RESP_FUNC_FAILED;\r\nreturn rc;\r\n}\r\nrc = pm8001_exec_internal_task_abort(pm8001_ha, pm8001_dev,\r\npm8001_dev->sas_device, 0, tag);\r\n}\r\nout:\r\nif (rc != TMF_RESP_FUNC_COMPLETE)\r\npm8001_printk("rc= %d\n", rc);\r\nreturn rc;\r\n}\r\nint pm8001_abort_task_set(struct domain_device *dev, u8 *lun)\r\n{\r\nint rc = TMF_RESP_FUNC_FAILED;\r\nstruct pm8001_tmf_task tmf_task;\r\ntmf_task.tmf = TMF_ABORT_TASK_SET;\r\nrc = pm8001_issue_ssp_tmf(dev, lun, &tmf_task);\r\nreturn rc;\r\n}\r\nint pm8001_clear_aca(struct domain_device *dev, u8 *lun)\r\n{\r\nint rc = TMF_RESP_FUNC_FAILED;\r\nstruct pm8001_tmf_task tmf_task;\r\ntmf_task.tmf = TMF_CLEAR_ACA;\r\nrc = pm8001_issue_ssp_tmf(dev, lun, &tmf_task);\r\nreturn rc;\r\n}\r\nint pm8001_clear_task_set(struct domain_device *dev, u8 *lun)\r\n{\r\nint rc = TMF_RESP_FUNC_FAILED;\r\nstruct pm8001_tmf_task tmf_task;\r\nstruct pm8001_device *pm8001_dev = dev->lldd_dev;\r\nstruct pm8001_hba_info *pm8001_ha = pm8001_find_ha_by_dev(dev);\r\nPM8001_EH_DBG(pm8001_ha,\r\npm8001_printk("I_T_L_Q clear task set[%x]\n",\r\npm8001_dev->device_id));\r\ntmf_task.tmf = TMF_CLEAR_TASK_SET;\r\nrc = pm8001_issue_ssp_tmf(dev, lun, &tmf_task);\r\nreturn rc;\r\n}
