static void\r\ntcp_unique_tuple(const struct nf_nat_l3proto *l3proto,\r\nstruct nf_conntrack_tuple *tuple,\r\nconst struct nf_nat_range *range,\r\nenum nf_nat_manip_type maniptype,\r\nconst struct nf_conn *ct)\r\n{\r\nnf_nat_l4proto_unique_tuple(l3proto, tuple, range, maniptype, ct,\r\n&tcp_port_rover);\r\n}\r\nstatic bool\r\ntcp_manip_pkt(struct sk_buff *skb,\r\nconst struct nf_nat_l3proto *l3proto,\r\nunsigned int iphdroff, unsigned int hdroff,\r\nconst struct nf_conntrack_tuple *tuple,\r\nenum nf_nat_manip_type maniptype)\r\n{\r\nstruct tcphdr *hdr;\r\n__be16 *portptr, newport, oldport;\r\nint hdrsize = 8;\r\nif (skb->len >= hdroff + sizeof(struct tcphdr))\r\nhdrsize = sizeof(struct tcphdr);\r\nif (!skb_make_writable(skb, hdroff + hdrsize))\r\nreturn false;\r\nhdr = (struct tcphdr *)(skb->data + hdroff);\r\nif (maniptype == NF_NAT_MANIP_SRC) {\r\nnewport = tuple->src.u.tcp.port;\r\nportptr = &hdr->source;\r\n} else {\r\nnewport = tuple->dst.u.tcp.port;\r\nportptr = &hdr->dest;\r\n}\r\noldport = *portptr;\r\n*portptr = newport;\r\nif (hdrsize < sizeof(*hdr))\r\nreturn true;\r\nl3proto->csum_update(skb, iphdroff, &hdr->check, tuple, maniptype);\r\ninet_proto_csum_replace2(&hdr->check, skb, oldport, newport, false);\r\nreturn true;\r\n}
