static void brcmstb_i2c_enable_disable_irq(struct brcmstb_i2c_dev *dev,\r\nbool int_en)\r\n{\r\nif (int_en)\r\ndev->bsc_regmap->ctl_reg |= BSC_CTL_REG_INT_EN_MASK;\r\nelse\r\ndev->bsc_regmap->ctl_reg &= ~BSC_CTL_REG_INT_EN_MASK;\r\nbarrier();\r\nbsc_writel(dev, dev->bsc_regmap->ctl_reg, ctl_reg);\r\n}\r\nstatic irqreturn_t brcmstb_i2c_isr(int irq, void *devid)\r\n{\r\nstruct brcmstb_i2c_dev *dev = devid;\r\nu32 status_bsc_ctl = bsc_readl(dev, ctl_reg);\r\nu32 status_iic_intrp = bsc_readl(dev, iic_enable);\r\ndev_dbg(dev->device, "isr CTL_REG %x IIC_EN %x\n",\r\nstatus_bsc_ctl, status_iic_intrp);\r\nif (!(status_bsc_ctl & BSC_CTL_REG_INT_EN_MASK))\r\nreturn IRQ_NONE;\r\nbrcmstb_i2c_enable_disable_irq(dev, INT_DISABLE);\r\ncomplete_all(&dev->done);\r\ndev_dbg(dev->device, "isr handled");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int brcmstb_i2c_wait_if_busy(struct brcmstb_i2c_dev *dev)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(I2C_TIMEOUT);\r\nwhile ((bsc_readl(dev, iic_enable) & BSC_IIC_EN_INTRP_MASK)) {\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nstatic int brcmstb_i2c_wait_for_completion(struct brcmstb_i2c_dev *dev)\r\n{\r\nint ret = 0;\r\nunsigned long timeout = msecs_to_jiffies(I2C_TIMEOUT);\r\nif (dev->irq >= 0) {\r\nif (!wait_for_completion_timeout(&dev->done, timeout))\r\nret = -ETIMEDOUT;\r\n} else {\r\nu32 bsc_intrp;\r\nunsigned long time_left = jiffies + timeout;\r\ndo {\r\nbsc_intrp = bsc_readl(dev, iic_enable) &\r\nBSC_IIC_EN_INTRP_MASK;\r\nif (time_after(jiffies, time_left)) {\r\nret = -ETIMEDOUT;\r\nbreak;\r\n}\r\ncpu_relax();\r\n} while (!bsc_intrp);\r\n}\r\nif (dev->irq < 0 || ret == -ETIMEDOUT)\r\nbrcmstb_i2c_enable_disable_irq(dev, INT_DISABLE);\r\nreturn ret;\r\n}\r\nstatic void brcmstb_set_i2c_start_stop(struct brcmstb_i2c_dev *dev,\r\nu32 cond_flag)\r\n{\r\nu32 regval = dev->bsc_regmap->iic_enable;\r\ndev->bsc_regmap->iic_enable = (regval & ~COND_START_STOP) | cond_flag;\r\n}\r\nstatic int brcmstb_send_i2c_cmd(struct brcmstb_i2c_dev *dev,\r\nenum bsc_xfer_cmd cmd)\r\n{\r\nint rc = 0;\r\nstruct bsc_regs *pi2creg = dev->bsc_regmap;\r\nrc = brcmstb_i2c_wait_if_busy(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (dev->irq >= 0)\r\nreinit_completion(&dev->done);\r\nbrcmstb_i2c_enable_disable_irq(dev, INT_ENABLE);\r\npi2creg->iic_enable |= BSC_IIC_EN_ENABLE_MASK;\r\nbsc_writel(dev, pi2creg->iic_enable, iic_enable);\r\nrc = brcmstb_i2c_wait_for_completion(dev);\r\nif (rc) {\r\ndev_dbg(dev->device, "intr timeout for cmd %s\n",\r\ncmd_string[cmd]);\r\ngoto cmd_out;\r\n}\r\nif ((CMD_RD || CMD_WR) &&\r\nbsc_readl(dev, iic_enable) & BSC_IIC_EN_NOACK_MASK) {\r\nrc = -EREMOTEIO;\r\ndev_dbg(dev->device, "controller received NOACK intr for %s\n",\r\ncmd_string[cmd]);\r\n}\r\ncmd_out:\r\nbsc_writel(dev, 0, cnt_reg);\r\nbsc_writel(dev, 0, iic_enable);\r\nreturn rc;\r\n}\r\nstatic int brcmstb_i2c_xfer_bsc_data(struct brcmstb_i2c_dev *dev,\r\nu8 *buf, unsigned int len,\r\nstruct i2c_msg *pmsg)\r\n{\r\nint cnt, byte, rc;\r\nenum bsc_xfer_cmd cmd;\r\nu32 ctl_reg;\r\nstruct bsc_regs *pi2creg = dev->bsc_regmap;\r\nint no_ack = pmsg->flags & I2C_M_IGNORE_NAK;\r\nif (no_ack || len <= N_DATA_BYTES) {\r\ncmd = (pmsg->flags & I2C_M_RD) ? CMD_RD_NOACK\r\n: CMD_WR_NOACK;\r\npi2creg->ctlhi_reg |= BSC_CTLHI_REG_IGNORE_ACK_MASK;\r\n} else {\r\ncmd = (pmsg->flags & I2C_M_RD) ? CMD_RD : CMD_WR;\r\npi2creg->ctlhi_reg &= ~BSC_CTLHI_REG_IGNORE_ACK_MASK;\r\n}\r\nbsc_writel(dev, pi2creg->ctlhi_reg, ctlhi_reg);\r\nctl_reg = pi2creg->ctl_reg & ~BSC_CTL_REG_DTF_MASK;\r\nif (cmd == CMD_WR || cmd == CMD_WR_NOACK)\r\npi2creg->ctl_reg = ctl_reg | DTF_WR_MASK;\r\nelse\r\npi2creg->ctl_reg = ctl_reg | DTF_RD_MASK;\r\nbsc_writel(dev, BSC_CNT_REG1_MASK & (len << BSC_CNT_REG1_SHIFT),\r\ncnt_reg);\r\nif (cmd == CMD_WR || cmd == CMD_WR_NOACK) {\r\nfor (cnt = 0; cnt < len; cnt += 4) {\r\nu32 word = 0;\r\nfor (byte = 0; byte < 4; byte++) {\r\nword >>= 8;\r\nif ((cnt + byte) < len)\r\nword |= buf[cnt + byte] << 24;\r\n}\r\nbsc_writel(dev, word, data_in[cnt >> 2]);\r\n}\r\n}\r\nrc = brcmstb_send_i2c_cmd(dev, cmd);\r\nif (rc != 0) {\r\ndev_dbg(dev->device, "%s failure", cmd_string[cmd]);\r\nreturn rc;\r\n}\r\nif (cmd == CMD_RD || cmd == CMD_RD_NOACK) {\r\nfor (cnt = 0; cnt < len; cnt += 4) {\r\nu32 data = bsc_readl(dev, data_out[cnt >> 2]);\r\nfor (byte = 0; byte < 4 &&\r\n(byte + cnt) < len; byte++) {\r\nbuf[cnt + byte] = data & 0xff;\r\ndata >>= 8;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int brcmstb_i2c_write_data_byte(struct brcmstb_i2c_dev *dev,\r\nu8 *buf, unsigned int nak_expected)\r\n{\r\nenum bsc_xfer_cmd cmd = nak_expected ? CMD_WR : CMD_WR_NOACK;\r\nbsc_writel(dev, 1, cnt_reg);\r\nbsc_writel(dev, *buf, data_in);\r\nreturn brcmstb_send_i2c_cmd(dev, cmd);\r\n}\r\nstatic int brcmstb_i2c_do_addr(struct brcmstb_i2c_dev *dev,\r\nstruct i2c_msg *msg)\r\n{\r\nunsigned char addr;\r\nif (msg->flags & I2C_M_TEN) {\r\naddr = 0xF0 | ((msg->addr & 0x300) >> 7);\r\nbsc_writel(dev, addr, chip_address);\r\naddr = msg->addr & 0xFF;\r\nif (brcmstb_i2c_write_data_byte(dev, &addr, 0) < 0)\r\nreturn -EREMOTEIO;\r\nif (msg->flags & I2C_M_RD) {\r\nbrcmstb_set_i2c_start_stop(dev, COND_RESTART\r\n| COND_NOSTOP);\r\naddr = 0xF0 | ((msg->addr & 0x300) >> 7) | 0x01;\r\nif (brcmstb_i2c_write_data_byte(dev, &addr, 0) < 0)\r\nreturn -EREMOTEIO;\r\n}\r\n} else {\r\naddr = msg->addr << 1;\r\nif (msg->flags & I2C_M_RD)\r\naddr |= 1;\r\nbsc_writel(dev, addr, chip_address);\r\n}\r\nreturn 0;\r\n}\r\nstatic int brcmstb_i2c_xfer(struct i2c_adapter *adapter,\r\nstruct i2c_msg msgs[], int num)\r\n{\r\nstruct brcmstb_i2c_dev *dev = i2c_get_adapdata(adapter);\r\nstruct i2c_msg *pmsg;\r\nint rc = 0;\r\nint i;\r\nint bytes_to_xfer;\r\nu8 *tmp_buf;\r\nint len = 0;\r\nif (dev->is_suspended)\r\nreturn -EBUSY;\r\nfor (i = 0; i < num; i++) {\r\npmsg = &msgs[i];\r\nlen = pmsg->len;\r\ntmp_buf = pmsg->buf;\r\ndev_dbg(dev->device,\r\n"msg# %d/%d flg %x buf %x len %d\n", i,\r\nnum - 1, pmsg->flags,\r\npmsg->buf ? pmsg->buf[0] : '0', pmsg->len);\r\nif (i < (num - 1) && (msgs[i + 1].flags & I2C_M_NOSTART))\r\nbrcmstb_set_i2c_start_stop(dev, ~(COND_START_STOP));\r\nelse\r\nbrcmstb_set_i2c_start_stop(dev,\r\nCOND_RESTART | COND_NOSTOP);\r\nif (!(pmsg->flags & I2C_M_NOSTART)) {\r\nrc = brcmstb_i2c_do_addr(dev, pmsg);\r\nif (rc < 0) {\r\ndev_dbg(dev->device,\r\n"NACK for addr %2.2x msg#%d rc = %d\n",\r\npmsg->addr, i, rc);\r\ngoto out;\r\n}\r\n}\r\nwhile (len) {\r\nbytes_to_xfer = min(len, N_DATA_BYTES);\r\nif (len <= N_DATA_BYTES && i == (num - 1))\r\nbrcmstb_set_i2c_start_stop(dev,\r\n~(COND_START_STOP));\r\nrc = brcmstb_i2c_xfer_bsc_data(dev, tmp_buf,\r\nbytes_to_xfer, pmsg);\r\nif (rc < 0)\r\ngoto out;\r\nlen -= bytes_to_xfer;\r\ntmp_buf += bytes_to_xfer;\r\n}\r\n}\r\nrc = num;\r\nout:\r\nreturn rc;\r\n}\r\nstatic u32 brcmstb_i2c_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR\r\n| I2C_FUNC_NOSTART | I2C_FUNC_PROTOCOL_MANGLING;\r\n}\r\nstatic void brcmstb_i2c_set_bus_speed(struct brcmstb_i2c_dev *dev)\r\n{\r\nint i = 0, num_speeds = ARRAY_SIZE(bsc_clk);\r\nu32 clk_freq_hz = dev->clk_freq_hz;\r\nfor (i = 0; i < num_speeds; i++) {\r\nif (bsc_clk[i].hz == clk_freq_hz) {\r\ndev->bsc_regmap->ctl_reg &= ~(BSC_CTL_REG_SCL_SEL_MASK\r\n| BSC_CTL_REG_DIV_CLK_MASK);\r\ndev->bsc_regmap->ctl_reg |= (bsc_clk[i].scl_mask |\r\nbsc_clk[i].div_mask);\r\nbsc_writel(dev, dev->bsc_regmap->ctl_reg, ctl_reg);\r\nbreak;\r\n}\r\n}\r\nif (i == num_speeds) {\r\ni = (bsc_readl(dev, ctl_reg) & BSC_CTL_REG_SCL_SEL_MASK) >>\r\nBSC_CTL_REG_SCL_SEL_SHIFT;\r\ndev_warn(dev->device, "leaving current clock-frequency @ %dHz\n",\r\nbsc_clk[i].hz);\r\n}\r\n}\r\nstatic void brcmstb_i2c_set_bsc_reg_defaults(struct brcmstb_i2c_dev *dev)\r\n{\r\ndev->bsc_regmap->ctlhi_reg = BSC_CTLHI_REG_DATAREG_SIZE_MASK;\r\nbsc_writel(dev, dev->bsc_regmap->ctlhi_reg, ctlhi_reg);\r\nbrcmstb_i2c_set_bus_speed(dev);\r\n}\r\nstatic int brcmstb_i2c_probe(struct platform_device *pdev)\r\n{\r\nint rc = 0;\r\nstruct brcmstb_i2c_dev *dev;\r\nstruct i2c_adapter *adap;\r\nstruct resource *iomem;\r\nconst char *int_name;\r\ndev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->bsc_regmap = devm_kzalloc(&pdev->dev, sizeof(struct bsc_regs *),\r\nGFP_KERNEL);\r\nif (!dev->bsc_regmap)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, dev);\r\ndev->device = &pdev->dev;\r\ninit_completion(&dev->done);\r\niomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndev->base = devm_ioremap_resource(dev->device, iomem);\r\nif (IS_ERR(dev->base)) {\r\nrc = -ENOMEM;\r\ngoto probe_errorout;\r\n}\r\nrc = of_property_read_string(dev->device->of_node, "interrupt-names",\r\n&int_name);\r\nif (rc < 0)\r\nint_name = NULL;\r\ndev->irq = platform_get_irq(pdev, 0);\r\nbrcmstb_i2c_enable_disable_irq(dev, INT_DISABLE);\r\nrc = devm_request_irq(&pdev->dev, dev->irq, brcmstb_i2c_isr,\r\nIRQF_SHARED,\r\nint_name ? int_name : pdev->name,\r\ndev);\r\nif (rc) {\r\ndev_dbg(dev->device, "falling back to polling mode");\r\ndev->irq = -1;\r\n}\r\nif (of_property_read_u32(dev->device->of_node,\r\n"clock-frequency", &dev->clk_freq_hz)) {\r\ndev_warn(dev->device, "setting clock-frequency@%dHz\n",\r\nbsc_clk[0].hz);\r\ndev->clk_freq_hz = bsc_clk[0].hz;\r\n}\r\nbrcmstb_i2c_set_bsc_reg_defaults(dev);\r\nadap = &dev->adapter;\r\ni2c_set_adapdata(adap, dev);\r\nadap->owner = THIS_MODULE;\r\nstrlcpy(adap->name, "Broadcom STB : ", sizeof(adap->name));\r\nif (int_name)\r\nstrlcat(adap->name, int_name, sizeof(adap->name));\r\nadap->algo = &brcmstb_i2c_algo;\r\nadap->dev.parent = &pdev->dev;\r\nadap->dev.of_node = pdev->dev.of_node;\r\nrc = i2c_add_adapter(adap);\r\nif (rc) {\r\ndev_err(dev->device, "failed to add adapter\n");\r\ngoto probe_errorout;\r\n}\r\ndev_info(dev->device, "%s@%dhz registered in %s mode\n",\r\nint_name ? int_name : " ", dev->clk_freq_hz,\r\n(dev->irq >= 0) ? "interrupt" : "polling");\r\nreturn 0;\r\nprobe_errorout:\r\nreturn rc;\r\n}\r\nstatic int brcmstb_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct brcmstb_i2c_dev *dev = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&dev->adapter);\r\nreturn 0;\r\n}\r\nstatic int brcmstb_i2c_suspend(struct device *dev)\r\n{\r\nstruct brcmstb_i2c_dev *i2c_dev = dev_get_drvdata(dev);\r\ni2c_lock_adapter(&i2c_dev->adapter);\r\ni2c_dev->is_suspended = true;\r\ni2c_unlock_adapter(&i2c_dev->adapter);\r\nreturn 0;\r\n}\r\nstatic int brcmstb_i2c_resume(struct device *dev)\r\n{\r\nstruct brcmstb_i2c_dev *i2c_dev = dev_get_drvdata(dev);\r\ni2c_lock_adapter(&i2c_dev->adapter);\r\nbrcmstb_i2c_set_bsc_reg_defaults(i2c_dev);\r\ni2c_dev->is_suspended = false;\r\ni2c_unlock_adapter(&i2c_dev->adapter);\r\nreturn 0;\r\n}
