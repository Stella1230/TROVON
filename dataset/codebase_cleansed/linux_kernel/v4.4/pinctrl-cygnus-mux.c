static int cygnus_get_groups_count(struct pinctrl_dev *pctrl_dev)\r\n{\r\nstruct cygnus_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\nreturn pinctrl->num_groups;\r\n}\r\nstatic const char *cygnus_get_group_name(struct pinctrl_dev *pctrl_dev,\r\nunsigned selector)\r\n{\r\nstruct cygnus_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\nreturn pinctrl->groups[selector].name;\r\n}\r\nstatic int cygnus_get_group_pins(struct pinctrl_dev *pctrl_dev,\r\nunsigned selector, const unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct cygnus_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\n*pins = pinctrl->groups[selector].pins;\r\n*num_pins = pinctrl->groups[selector].num_pins;\r\nreturn 0;\r\n}\r\nstatic void cygnus_pin_dbg_show(struct pinctrl_dev *pctrl_dev,\r\nstruct seq_file *s, unsigned offset)\r\n{\r\nseq_printf(s, " %s", dev_name(pctrl_dev->dev));\r\n}\r\nstatic int cygnus_get_functions_count(struct pinctrl_dev *pctrl_dev)\r\n{\r\nstruct cygnus_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\nreturn pinctrl->num_functions;\r\n}\r\nstatic const char *cygnus_get_function_name(struct pinctrl_dev *pctrl_dev,\r\nunsigned selector)\r\n{\r\nstruct cygnus_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\nreturn pinctrl->functions[selector].name;\r\n}\r\nstatic int cygnus_get_function_groups(struct pinctrl_dev *pctrl_dev,\r\nunsigned selector,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct cygnus_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\n*groups = pinctrl->functions[selector].groups;\r\n*num_groups = pinctrl->functions[selector].num_groups;\r\nreturn 0;\r\n}\r\nstatic int cygnus_pinmux_set(struct cygnus_pinctrl *pinctrl,\r\nconst struct cygnus_pin_function *func,\r\nconst struct cygnus_pin_group *grp,\r\nstruct cygnus_mux_log *mux_log)\r\n{\r\nconst struct cygnus_mux *mux = &grp->mux;\r\nint i;\r\nu32 val, mask = 0x7;\r\nunsigned long flags;\r\nfor (i = 0; i < CYGNUS_NUM_IOMUX; i++) {\r\nif (mux->offset != mux_log[i].mux.offset ||\r\nmux->shift != mux_log[i].mux.shift)\r\ncontinue;\r\nif (!mux_log[i].is_configured)\r\nbreak;\r\nif (mux_log[i].mux.alt != mux->alt) {\r\ndev_err(pinctrl->dev,\r\n"double configuration error detected!\n");\r\ndev_err(pinctrl->dev, "func:%s grp:%s\n",\r\nfunc->name, grp->name);\r\nreturn -EINVAL;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nmux_log[i].mux.alt = mux->alt;\r\nmux_log[i].is_configured = true;\r\nspin_lock_irqsave(&pinctrl->lock, flags);\r\nval = readl(pinctrl->base0 + grp->mux.offset);\r\nval &= ~(mask << grp->mux.shift);\r\nval |= grp->mux.alt << grp->mux.shift;\r\nwritel(val, pinctrl->base0 + grp->mux.offset);\r\nspin_unlock_irqrestore(&pinctrl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int cygnus_pinmux_set_mux(struct pinctrl_dev *pctrl_dev,\r\nunsigned func_select, unsigned grp_select)\r\n{\r\nstruct cygnus_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\nconst struct cygnus_pin_function *func =\r\n&pinctrl->functions[func_select];\r\nconst struct cygnus_pin_group *grp = &pinctrl->groups[grp_select];\r\ndev_dbg(pctrl_dev->dev, "func:%u name:%s grp:%u name:%s\n",\r\nfunc_select, func->name, grp_select, grp->name);\r\ndev_dbg(pctrl_dev->dev, "offset:0x%08x shift:%u alt:%u\n",\r\ngrp->mux.offset, grp->mux.shift, grp->mux.alt);\r\nreturn cygnus_pinmux_set(pinctrl, func, grp, pinctrl->mux_log);\r\n}\r\nstatic int cygnus_gpio_request_enable(struct pinctrl_dev *pctrl_dev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned pin)\r\n{\r\nstruct cygnus_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\nconst struct cygnus_gpio_mux *mux = pctrl_dev->desc->pins[pin].drv_data;\r\nu32 val;\r\nunsigned long flags;\r\nif (!mux->is_supported)\r\nreturn -ENOTSUPP;\r\nspin_lock_irqsave(&pinctrl->lock, flags);\r\nval = readl(pinctrl->base1 + mux->offset);\r\nval |= 0x3 << mux->shift;\r\nwritel(val, pinctrl->base1 + mux->offset);\r\nspin_unlock_irqrestore(&pinctrl->lock, flags);\r\ndev_dbg(pctrl_dev->dev,\r\n"gpio request enable pin=%u offset=0x%x shift=%u\n",\r\npin, mux->offset, mux->shift);\r\nreturn 0;\r\n}\r\nstatic void cygnus_gpio_disable_free(struct pinctrl_dev *pctrl_dev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned pin)\r\n{\r\nstruct cygnus_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\nstruct cygnus_gpio_mux *mux = pctrl_dev->desc->pins[pin].drv_data;\r\nu32 val;\r\nunsigned long flags;\r\nif (!mux->is_supported)\r\nreturn;\r\nspin_lock_irqsave(&pinctrl->lock, flags);\r\nval = readl(pinctrl->base1 + mux->offset);\r\nval &= ~(0x3 << mux->shift);\r\nwritel(val, pinctrl->base1 + mux->offset);\r\nspin_unlock_irqrestore(&pinctrl->lock, flags);\r\ndev_err(pctrl_dev->dev,\r\n"gpio disable free pin=%u offset=0x%x shift=%u\n",\r\npin, mux->offset, mux->shift);\r\n}\r\nstatic int cygnus_mux_log_init(struct cygnus_pinctrl *pinctrl)\r\n{\r\nstruct cygnus_mux_log *log;\r\nunsigned int i, j;\r\npinctrl->mux_log = devm_kcalloc(pinctrl->dev, CYGNUS_NUM_IOMUX,\r\nsizeof(struct cygnus_mux_log),\r\nGFP_KERNEL);\r\nif (!pinctrl->mux_log)\r\nreturn -ENOMEM;\r\nlog = pinctrl->mux_log;\r\nfor (i = 0; i < CYGNUS_NUM_IOMUX_REGS; i++) {\r\nfor (j = 0; j < CYGNUS_NUM_MUX_PER_REG; j++) {\r\nlog = &pinctrl->mux_log[i * CYGNUS_NUM_MUX_PER_REG\r\n+ j];\r\nlog->mux.offset = i * 4;\r\nlog->mux.shift = j * 4;\r\nlog->mux.alt = 0;\r\nlog->is_configured = false;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cygnus_pinmux_probe(struct platform_device *pdev)\r\n{\r\nstruct cygnus_pinctrl *pinctrl;\r\nstruct resource *res;\r\nint i, ret;\r\nstruct pinctrl_pin_desc *pins;\r\nunsigned num_pins = ARRAY_SIZE(cygnus_pins);\r\npinctrl = devm_kzalloc(&pdev->dev, sizeof(*pinctrl), GFP_KERNEL);\r\nif (!pinctrl)\r\nreturn -ENOMEM;\r\npinctrl->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, pinctrl);\r\nspin_lock_init(&pinctrl->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npinctrl->base0 = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pinctrl->base0)) {\r\ndev_err(&pdev->dev, "unable to map I/O space\n");\r\nreturn PTR_ERR(pinctrl->base0);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\npinctrl->base1 = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pinctrl->base1)) {\r\ndev_err(&pdev->dev, "unable to map I/O space\n");\r\nreturn PTR_ERR(pinctrl->base1);\r\n}\r\nret = cygnus_mux_log_init(pinctrl);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to initialize IOMUX log\n");\r\nreturn ret;\r\n}\r\npins = devm_kcalloc(&pdev->dev, num_pins, sizeof(*pins), GFP_KERNEL);\r\nif (!pins)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_pins; i++) {\r\npins[i].number = cygnus_pins[i].pin;\r\npins[i].name = cygnus_pins[i].name;\r\npins[i].drv_data = &cygnus_pins[i].gpio_mux;\r\n}\r\npinctrl->groups = cygnus_pin_groups;\r\npinctrl->num_groups = ARRAY_SIZE(cygnus_pin_groups);\r\npinctrl->functions = cygnus_pin_functions;\r\npinctrl->num_functions = ARRAY_SIZE(cygnus_pin_functions);\r\ncygnus_pinctrl_desc.pins = pins;\r\ncygnus_pinctrl_desc.npins = num_pins;\r\npinctrl->pctl = pinctrl_register(&cygnus_pinctrl_desc, &pdev->dev,\r\npinctrl);\r\nif (IS_ERR(pinctrl->pctl)) {\r\ndev_err(&pdev->dev, "unable to register Cygnus IOMUX pinctrl\n");\r\nreturn PTR_ERR(pinctrl->pctl);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init cygnus_pinmux_init(void)\r\n{\r\nreturn platform_driver_register(&cygnus_pinmux_driver);\r\n}
