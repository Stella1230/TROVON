int intelfbhw_get_chipset(struct pci_dev *pdev, struct intelfb_info *dinfo)\r\n{\r\nu32 tmp;\r\nif (!pdev || !dinfo)\r\nreturn 1;\r\nswitch (pdev->device) {\r\ncase PCI_DEVICE_ID_INTEL_830M:\r\ndinfo->name = "Intel(R) 830M";\r\ndinfo->chipset = INTEL_830M;\r\ndinfo->mobile = 1;\r\ndinfo->pll_index = PLLS_I8xx;\r\nreturn 0;\r\ncase PCI_DEVICE_ID_INTEL_845G:\r\ndinfo->name = "Intel(R) 845G";\r\ndinfo->chipset = INTEL_845G;\r\ndinfo->mobile = 0;\r\ndinfo->pll_index = PLLS_I8xx;\r\nreturn 0;\r\ncase PCI_DEVICE_ID_INTEL_854:\r\ndinfo->mobile = 1;\r\ndinfo->name = "Intel(R) 854";\r\ndinfo->chipset = INTEL_854;\r\nreturn 0;\r\ncase PCI_DEVICE_ID_INTEL_85XGM:\r\ntmp = 0;\r\ndinfo->mobile = 1;\r\ndinfo->pll_index = PLLS_I8xx;\r\npci_read_config_dword(pdev, INTEL_85X_CAPID, &tmp);\r\nswitch ((tmp >> INTEL_85X_VARIANT_SHIFT) &\r\nINTEL_85X_VARIANT_MASK) {\r\ncase INTEL_VAR_855GME:\r\ndinfo->name = "Intel(R) 855GME";\r\ndinfo->chipset = INTEL_855GME;\r\nreturn 0;\r\ncase INTEL_VAR_855GM:\r\ndinfo->name = "Intel(R) 855GM";\r\ndinfo->chipset = INTEL_855GM;\r\nreturn 0;\r\ncase INTEL_VAR_852GME:\r\ndinfo->name = "Intel(R) 852GME";\r\ndinfo->chipset = INTEL_852GME;\r\nreturn 0;\r\ncase INTEL_VAR_852GM:\r\ndinfo->name = "Intel(R) 852GM";\r\ndinfo->chipset = INTEL_852GM;\r\nreturn 0;\r\ndefault:\r\ndinfo->name = "Intel(R) 852GM/855GM";\r\ndinfo->chipset = INTEL_85XGM;\r\nreturn 0;\r\n}\r\nbreak;\r\ncase PCI_DEVICE_ID_INTEL_865G:\r\ndinfo->name = "Intel(R) 865G";\r\ndinfo->chipset = INTEL_865G;\r\ndinfo->mobile = 0;\r\ndinfo->pll_index = PLLS_I8xx;\r\nreturn 0;\r\ncase PCI_DEVICE_ID_INTEL_915G:\r\ndinfo->name = "Intel(R) 915G";\r\ndinfo->chipset = INTEL_915G;\r\ndinfo->mobile = 0;\r\ndinfo->pll_index = PLLS_I9xx;\r\nreturn 0;\r\ncase PCI_DEVICE_ID_INTEL_915GM:\r\ndinfo->name = "Intel(R) 915GM";\r\ndinfo->chipset = INTEL_915GM;\r\ndinfo->mobile = 1;\r\ndinfo->pll_index = PLLS_I9xx;\r\nreturn 0;\r\ncase PCI_DEVICE_ID_INTEL_945G:\r\ndinfo->name = "Intel(R) 945G";\r\ndinfo->chipset = INTEL_945G;\r\ndinfo->mobile = 0;\r\ndinfo->pll_index = PLLS_I9xx;\r\nreturn 0;\r\ncase PCI_DEVICE_ID_INTEL_945GM:\r\ndinfo->name = "Intel(R) 945GM";\r\ndinfo->chipset = INTEL_945GM;\r\ndinfo->mobile = 1;\r\ndinfo->pll_index = PLLS_I9xx;\r\nreturn 0;\r\ncase PCI_DEVICE_ID_INTEL_945GME:\r\ndinfo->name = "Intel(R) 945GME";\r\ndinfo->chipset = INTEL_945GME;\r\ndinfo->mobile = 1;\r\ndinfo->pll_index = PLLS_I9xx;\r\nreturn 0;\r\ncase PCI_DEVICE_ID_INTEL_965G:\r\ndinfo->name = "Intel(R) 965G";\r\ndinfo->chipset = INTEL_965G;\r\ndinfo->mobile = 0;\r\ndinfo->pll_index = PLLS_I9xx;\r\nreturn 0;\r\ncase PCI_DEVICE_ID_INTEL_965GM:\r\ndinfo->name = "Intel(R) 965GM";\r\ndinfo->chipset = INTEL_965GM;\r\ndinfo->mobile = 1;\r\ndinfo->pll_index = PLLS_I9xx;\r\nreturn 0;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nint intelfbhw_get_memory(struct pci_dev *pdev, int *aperture_size,\r\nint *stolen_size)\r\n{\r\nstruct pci_dev *bridge_dev;\r\nu16 tmp;\r\nint stolen_overhead;\r\nif (!pdev || !aperture_size || !stolen_size)\r\nreturn 1;\r\nif (!(bridge_dev = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0)))) {\r\nERR_MSG("cannot find bridge device\n");\r\nreturn 1;\r\n}\r\ntmp = 0;\r\npci_read_config_word(bridge_dev, INTEL_GMCH_CTRL, &tmp);\r\npci_dev_put(bridge_dev);\r\nswitch (pdev->device) {\r\ncase PCI_DEVICE_ID_INTEL_915G:\r\ncase PCI_DEVICE_ID_INTEL_915GM:\r\ncase PCI_DEVICE_ID_INTEL_945G:\r\ncase PCI_DEVICE_ID_INTEL_945GM:\r\ncase PCI_DEVICE_ID_INTEL_945GME:\r\ncase PCI_DEVICE_ID_INTEL_965G:\r\ncase PCI_DEVICE_ID_INTEL_965GM:\r\nif (pci_resource_start(pdev, 2) & 0x08000000)\r\n*aperture_size = MB(128);\r\nelse\r\n*aperture_size = MB(256);\r\nbreak;\r\ndefault:\r\nif ((tmp & INTEL_GMCH_MEM_MASK) == INTEL_GMCH_MEM_64M)\r\n*aperture_size = MB(64);\r\nelse\r\n*aperture_size = MB(128);\r\nbreak;\r\n}\r\nstolen_overhead = (*aperture_size / MB(1)) + 4;\r\nswitch(pdev->device) {\r\ncase PCI_DEVICE_ID_INTEL_830M:\r\ncase PCI_DEVICE_ID_INTEL_845G:\r\nswitch (tmp & INTEL_830_GMCH_GMS_MASK) {\r\ncase INTEL_830_GMCH_GMS_STOLEN_512:\r\n*stolen_size = KB(512) - KB(stolen_overhead);\r\nreturn 0;\r\ncase INTEL_830_GMCH_GMS_STOLEN_1024:\r\n*stolen_size = MB(1) - KB(stolen_overhead);\r\nreturn 0;\r\ncase INTEL_830_GMCH_GMS_STOLEN_8192:\r\n*stolen_size = MB(8) - KB(stolen_overhead);\r\nreturn 0;\r\ncase INTEL_830_GMCH_GMS_LOCAL:\r\nERR_MSG("only local memory found\n");\r\nreturn 1;\r\ncase INTEL_830_GMCH_GMS_DISABLED:\r\nERR_MSG("video memory is disabled\n");\r\nreturn 1;\r\ndefault:\r\nERR_MSG("unexpected GMCH_GMS value: 0x%02x\n",\r\ntmp & INTEL_830_GMCH_GMS_MASK);\r\nreturn 1;\r\n}\r\nbreak;\r\ndefault:\r\nswitch (tmp & INTEL_855_GMCH_GMS_MASK) {\r\ncase INTEL_855_GMCH_GMS_STOLEN_1M:\r\n*stolen_size = MB(1) - KB(stolen_overhead);\r\nreturn 0;\r\ncase INTEL_855_GMCH_GMS_STOLEN_4M:\r\n*stolen_size = MB(4) - KB(stolen_overhead);\r\nreturn 0;\r\ncase INTEL_855_GMCH_GMS_STOLEN_8M:\r\n*stolen_size = MB(8) - KB(stolen_overhead);\r\nreturn 0;\r\ncase INTEL_855_GMCH_GMS_STOLEN_16M:\r\n*stolen_size = MB(16) - KB(stolen_overhead);\r\nreturn 0;\r\ncase INTEL_855_GMCH_GMS_STOLEN_32M:\r\n*stolen_size = MB(32) - KB(stolen_overhead);\r\nreturn 0;\r\ncase INTEL_915G_GMCH_GMS_STOLEN_48M:\r\n*stolen_size = MB(48) - KB(stolen_overhead);\r\nreturn 0;\r\ncase INTEL_915G_GMCH_GMS_STOLEN_64M:\r\n*stolen_size = MB(64) - KB(stolen_overhead);\r\nreturn 0;\r\ncase INTEL_855_GMCH_GMS_DISABLED:\r\nERR_MSG("video memory is disabled\n");\r\nreturn 0;\r\ndefault:\r\nERR_MSG("unexpected GMCH_GMS value: 0x%02x\n",\r\ntmp & INTEL_855_GMCH_GMS_MASK);\r\nreturn 1;\r\n}\r\n}\r\n}\r\nint intelfbhw_check_non_crt(struct intelfb_info *dinfo)\r\n{\r\nint dvo = 0;\r\nif (INREG(LVDS) & PORT_ENABLE)\r\ndvo |= LVDS_PORT;\r\nif (INREG(DVOA) & PORT_ENABLE)\r\ndvo |= DVOA_PORT;\r\nif (INREG(DVOB) & PORT_ENABLE)\r\ndvo |= DVOB_PORT;\r\nif (INREG(DVOC) & PORT_ENABLE)\r\ndvo |= DVOC_PORT;\r\nreturn dvo;\r\n}\r\nconst char * intelfbhw_dvo_to_string(int dvo)\r\n{\r\nif (dvo & DVOA_PORT)\r\nreturn "DVO port A";\r\nelse if (dvo & DVOB_PORT)\r\nreturn "DVO port B";\r\nelse if (dvo & DVOC_PORT)\r\nreturn "DVO port C";\r\nelse if (dvo & LVDS_PORT)\r\nreturn "LVDS port";\r\nelse\r\nreturn NULL;\r\n}\r\nint intelfbhw_validate_mode(struct intelfb_info *dinfo,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nint bytes_per_pixel;\r\nint tmp;\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfbhw_validate_mode\n");\r\n#endif\r\nbytes_per_pixel = var->bits_per_pixel / 8;\r\nif (bytes_per_pixel == 3)\r\nbytes_per_pixel = 4;\r\ntmp = var->yres_virtual * var->xres_virtual * bytes_per_pixel;\r\nif (tmp > dinfo->fb.size) {\r\nWRN_MSG("Not enough video ram for mode "\r\n"(%d KByte vs %d KByte).\n",\r\nBtoKB(tmp), BtoKB(dinfo->fb.size));\r\nreturn 1;\r\n}\r\nif (var->xres - 1 > HACTIVE_MASK) {\r\nWRN_MSG("X resolution too large (%d vs %d).\n",\r\nvar->xres, HACTIVE_MASK + 1);\r\nreturn 1;\r\n}\r\nif (var->yres - 1 > VACTIVE_MASK) {\r\nWRN_MSG("Y resolution too large (%d vs %d).\n",\r\nvar->yres, VACTIVE_MASK + 1);\r\nreturn 1;\r\n}\r\nif (var->xres < 4) {\r\nWRN_MSG("X resolution too small (%d vs 4).\n", var->xres);\r\nreturn 1;\r\n}\r\nif (var->yres < 4) {\r\nWRN_MSG("Y resolution too small (%d vs 4).\n", var->yres);\r\nreturn 1;\r\n}\r\nif (var->vmode & FB_VMODE_DOUBLE) {\r\nWRN_MSG("Mode is double-scan.\n");\r\nreturn 1;\r\n}\r\nif ((var->vmode & FB_VMODE_INTERLACED) && (var->yres & 1)) {\r\nWRN_MSG("Odd number of lines in interlaced mode\n");\r\nreturn 1;\r\n}\r\ntmp = 1000000000 / var->pixclock;\r\nif (tmp < MIN_CLOCK) {\r\nWRN_MSG("Pixel clock is too low (%d MHz vs %d MHz).\n",\r\n(tmp + 500) / 1000, MIN_CLOCK / 1000);\r\nreturn 1;\r\n}\r\nif (tmp > MAX_CLOCK) {\r\nWRN_MSG("Pixel clock is too high (%d MHz vs %d MHz).\n",\r\n(tmp + 500) / 1000, MAX_CLOCK / 1000);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint intelfbhw_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct intelfb_info *dinfo = GET_DINFO(info);\r\nu32 offset, xoffset, yoffset;\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfbhw_pan_display\n");\r\n#endif\r\nxoffset = ROUND_DOWN_TO(var->xoffset, 8);\r\nyoffset = var->yoffset;\r\nif ((xoffset + info->var.xres > info->var.xres_virtual) ||\r\n(yoffset + info->var.yres > info->var.yres_virtual))\r\nreturn -EINVAL;\r\noffset = (yoffset * dinfo->pitch) +\r\n(xoffset * info->var.bits_per_pixel) / 8;\r\noffset += dinfo->fb.offset << 12;\r\ndinfo->vsync.pan_offset = offset;\r\nif ((var->activate & FB_ACTIVATE_VBL) &&\r\n!intelfbhw_enable_irq(dinfo))\r\ndinfo->vsync.pan_display = 1;\r\nelse {\r\ndinfo->vsync.pan_display = 0;\r\nOUTREG(DSPABASE, offset);\r\n}\r\nreturn 0;\r\n}\r\nvoid intelfbhw_do_blank(int blank, struct fb_info *info)\r\n{\r\nstruct intelfb_info *dinfo = GET_DINFO(info);\r\nu32 tmp;\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfbhw_do_blank: blank is %d\n", blank);\r\n#endif\r\ntmp = INREG(DSPACNTR);\r\nif (blank)\r\ntmp &= ~DISPPLANE_PLANE_ENABLE;\r\nelse\r\ntmp |= DISPPLANE_PLANE_ENABLE;\r\nOUTREG(DSPACNTR, tmp);\r\ntmp = INREG(DSPABASE);\r\nOUTREG(DSPABASE, tmp);\r\n#if VERBOSE > 0\r\nDBG_MSG("cursor_on is %d\n", dinfo->cursor_on);\r\n#endif\r\nif (dinfo->cursor_on) {\r\nif (blank)\r\nintelfbhw_cursor_hide(dinfo);\r\nelse\r\nintelfbhw_cursor_show(dinfo);\r\ndinfo->cursor_on = 1;\r\n}\r\ndinfo->cursor_blanked = blank;\r\ntmp = INREG(ADPA) & ~ADPA_DPMS_CONTROL_MASK;\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\ncase FB_BLANK_NORMAL:\r\ntmp |= ADPA_DPMS_D0;\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ntmp |= ADPA_DPMS_D1;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ntmp |= ADPA_DPMS_D2;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\ntmp |= ADPA_DPMS_D3;\r\nbreak;\r\n}\r\nOUTREG(ADPA, tmp);\r\nreturn;\r\n}\r\nint intelfbhw_active_pipe(const struct intelfb_hwstate *hw)\r\n{\r\nint pipe = -1;\r\nif (hw->disp_b_ctrl & DISPPLANE_PLANE_ENABLE) {\r\npipe = (hw->disp_b_ctrl >> DISPPLANE_SEL_PIPE_SHIFT);\r\npipe &= PIPE_MASK;\r\nif (unlikely(pipe == PIPE_A))\r\nreturn PIPE_A;\r\n}\r\nif (hw->disp_a_ctrl & DISPPLANE_PLANE_ENABLE) {\r\npipe = (hw->disp_a_ctrl >> DISPPLANE_SEL_PIPE_SHIFT);\r\npipe &= PIPE_MASK;\r\nif (likely(pipe == PIPE_A))\r\nreturn PIPE_A;\r\n}\r\nWARN_ON(pipe == -1);\r\nif (unlikely(pipe == -1))\r\npipe = PIPE_A;\r\nreturn pipe;\r\n}\r\nvoid intelfbhw_setcolreg(struct intelfb_info *dinfo, unsigned regno,\r\nunsigned red, unsigned green, unsigned blue,\r\nunsigned transp)\r\n{\r\nu32 palette_reg = (dinfo->pipe == PIPE_A) ?\r\nPALETTE_A : PALETTE_B;\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfbhw_setcolreg: %d: (%d, %d, %d)\n",\r\nregno, red, green, blue);\r\n#endif\r\nOUTREG(palette_reg + (regno << 2),\r\n(red << PALETTE_8_RED_SHIFT) |\r\n(green << PALETTE_8_GREEN_SHIFT) |\r\n(blue << PALETTE_8_BLUE_SHIFT));\r\n}\r\nint intelfbhw_read_hw_state(struct intelfb_info *dinfo,\r\nstruct intelfb_hwstate *hw, int flag)\r\n{\r\nint i;\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfbhw_read_hw_state\n");\r\n#endif\r\nif (!hw || !dinfo)\r\nreturn -1;\r\nhw->vga0_divisor = INREG(VGA0_DIVISOR);\r\nhw->vga1_divisor = INREG(VGA1_DIVISOR);\r\nhw->vga_pd = INREG(VGAPD);\r\nhw->dpll_a = INREG(DPLL_A);\r\nhw->dpll_b = INREG(DPLL_B);\r\nhw->fpa0 = INREG(FPA0);\r\nhw->fpa1 = INREG(FPA1);\r\nhw->fpb0 = INREG(FPB0);\r\nhw->fpb1 = INREG(FPB1);\r\nif (flag == 1)\r\nreturn flag;\r\n#if 0\r\nfor (i = 0; i < PALETTE_8_ENTRIES; i++) {\r\nhw->palette_a[i] = INREG(PALETTE_A + (i << 2));\r\nhw->palette_b[i] = INREG(PALETTE_B + (i << 2));\r\n}\r\n#endif\r\nif (flag == 2)\r\nreturn flag;\r\nhw->htotal_a = INREG(HTOTAL_A);\r\nhw->hblank_a = INREG(HBLANK_A);\r\nhw->hsync_a = INREG(HSYNC_A);\r\nhw->vtotal_a = INREG(VTOTAL_A);\r\nhw->vblank_a = INREG(VBLANK_A);\r\nhw->vsync_a = INREG(VSYNC_A);\r\nhw->src_size_a = INREG(SRC_SIZE_A);\r\nhw->bclrpat_a = INREG(BCLRPAT_A);\r\nhw->htotal_b = INREG(HTOTAL_B);\r\nhw->hblank_b = INREG(HBLANK_B);\r\nhw->hsync_b = INREG(HSYNC_B);\r\nhw->vtotal_b = INREG(VTOTAL_B);\r\nhw->vblank_b = INREG(VBLANK_B);\r\nhw->vsync_b = INREG(VSYNC_B);\r\nhw->src_size_b = INREG(SRC_SIZE_B);\r\nhw->bclrpat_b = INREG(BCLRPAT_B);\r\nif (flag == 3)\r\nreturn flag;\r\nhw->adpa = INREG(ADPA);\r\nhw->dvoa = INREG(DVOA);\r\nhw->dvob = INREG(DVOB);\r\nhw->dvoc = INREG(DVOC);\r\nhw->dvoa_srcdim = INREG(DVOA_SRCDIM);\r\nhw->dvob_srcdim = INREG(DVOB_SRCDIM);\r\nhw->dvoc_srcdim = INREG(DVOC_SRCDIM);\r\nhw->lvds = INREG(LVDS);\r\nif (flag == 4)\r\nreturn flag;\r\nhw->pipe_a_conf = INREG(PIPEACONF);\r\nhw->pipe_b_conf = INREG(PIPEBCONF);\r\nhw->disp_arb = INREG(DISPARB);\r\nif (flag == 5)\r\nreturn flag;\r\nhw->cursor_a_control = INREG(CURSOR_A_CONTROL);\r\nhw->cursor_b_control = INREG(CURSOR_B_CONTROL);\r\nhw->cursor_a_base = INREG(CURSOR_A_BASEADDR);\r\nhw->cursor_b_base = INREG(CURSOR_B_BASEADDR);\r\nif (flag == 6)\r\nreturn flag;\r\nfor (i = 0; i < 4; i++) {\r\nhw->cursor_a_palette[i] = INREG(CURSOR_A_PALETTE0 + (i << 2));\r\nhw->cursor_b_palette[i] = INREG(CURSOR_B_PALETTE0 + (i << 2));\r\n}\r\nif (flag == 7)\r\nreturn flag;\r\nhw->cursor_size = INREG(CURSOR_SIZE);\r\nif (flag == 8)\r\nreturn flag;\r\nhw->disp_a_ctrl = INREG(DSPACNTR);\r\nhw->disp_b_ctrl = INREG(DSPBCNTR);\r\nhw->disp_a_base = INREG(DSPABASE);\r\nhw->disp_b_base = INREG(DSPBBASE);\r\nhw->disp_a_stride = INREG(DSPASTRIDE);\r\nhw->disp_b_stride = INREG(DSPBSTRIDE);\r\nif (flag == 9)\r\nreturn flag;\r\nhw->vgacntrl = INREG(VGACNTRL);\r\nif (flag == 10)\r\nreturn flag;\r\nhw->add_id = INREG(ADD_ID);\r\nif (flag == 11)\r\nreturn flag;\r\nfor (i = 0; i < 7; i++) {\r\nhw->swf0x[i] = INREG(SWF00 + (i << 2));\r\nhw->swf1x[i] = INREG(SWF10 + (i << 2));\r\nif (i < 3)\r\nhw->swf3x[i] = INREG(SWF30 + (i << 2));\r\n}\r\nfor (i = 0; i < 8; i++)\r\nhw->fence[i] = INREG(FENCE + (i << 2));\r\nhw->instpm = INREG(INSTPM);\r\nhw->mem_mode = INREG(MEM_MODE);\r\nhw->fw_blc_0 = INREG(FW_BLC_0);\r\nhw->fw_blc_1 = INREG(FW_BLC_1);\r\nhw->hwstam = INREG16(HWSTAM);\r\nhw->ier = INREG16(IER);\r\nhw->iir = INREG16(IIR);\r\nhw->imr = INREG16(IMR);\r\nreturn 0;\r\n}\r\nstatic int calc_vclock3(int index, int m, int n, int p)\r\n{\r\nif (p == 0 || n == 0)\r\nreturn 0;\r\nreturn plls[index].ref_clk * m / n / p;\r\n}\r\nstatic int calc_vclock(int index, int m1, int m2, int n, int p1, int p2,\r\nint lvds)\r\n{\r\nstruct pll_min_max *pll = &plls[index];\r\nu32 m, vco, p;\r\nm = (5 * (m1 + 2)) + (m2 + 2);\r\nn += 2;\r\nvco = pll->ref_clk * m / n;\r\nif (index == PLLS_I8xx)\r\np = ((p1 + 2) * (1 << (p2 + 1)));\r\nelse\r\np = ((p1) * (p2 ? 5 : 10));\r\nreturn vco / p;\r\n}\r\nstatic void intelfbhw_get_p1p2(struct intelfb_info *dinfo, int dpll,\r\nint *o_p1, int *o_p2)\r\n{\r\nint p1, p2;\r\nif (IS_I9XX(dinfo)) {\r\nif (dpll & DPLL_P1_FORCE_DIV2)\r\np1 = 1;\r\nelse\r\np1 = (dpll >> DPLL_P1_SHIFT) & 0xff;\r\np1 = ffs(p1);\r\np2 = (dpll >> DPLL_I9XX_P2_SHIFT) & DPLL_P2_MASK;\r\n} else {\r\nif (dpll & DPLL_P1_FORCE_DIV2)\r\np1 = 0;\r\nelse\r\np1 = (dpll >> DPLL_P1_SHIFT) & DPLL_P1_MASK;\r\np2 = (dpll >> DPLL_P2_SHIFT) & DPLL_P2_MASK;\r\n}\r\n*o_p1 = p1;\r\n*o_p2 = p2;\r\n}\r\nvoid intelfbhw_print_hw_state(struct intelfb_info *dinfo,\r\nstruct intelfb_hwstate *hw)\r\n{\r\n#if REGDUMP\r\nint i, m1, m2, n, p1, p2;\r\nint index = dinfo->pll_index;\r\nDBG_MSG("intelfbhw_print_hw_state\n");\r\nif (!hw)\r\nreturn;\r\nprintk("hw state dump start\n");\r\nprintk(" VGA0_DIVISOR: 0x%08x\n", hw->vga0_divisor);\r\nprintk(" VGA1_DIVISOR: 0x%08x\n", hw->vga1_divisor);\r\nprintk(" VGAPD: 0x%08x\n", hw->vga_pd);\r\nn = (hw->vga0_divisor >> FP_N_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\r\nm1 = (hw->vga0_divisor >> FP_M1_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\r\nm2 = (hw->vga0_divisor >> FP_M2_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\r\nintelfbhw_get_p1p2(dinfo, hw->vga_pd, &p1, &p2);\r\nprintk(" VGA0: (m1, m2, n, p1, p2) = (%d, %d, %d, %d, %d)\n",\r\nm1, m2, n, p1, p2);\r\nprintk(" VGA0: clock is %d\n",\r\ncalc_vclock(index, m1, m2, n, p1, p2, 0));\r\nn = (hw->vga1_divisor >> FP_N_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\r\nm1 = (hw->vga1_divisor >> FP_M1_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\r\nm2 = (hw->vga1_divisor >> FP_M2_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\r\nintelfbhw_get_p1p2(dinfo, hw->vga_pd, &p1, &p2);\r\nprintk(" VGA1: (m1, m2, n, p1, p2) = (%d, %d, %d, %d, %d)\n",\r\nm1, m2, n, p1, p2);\r\nprintk(" VGA1: clock is %d\n",\r\ncalc_vclock(index, m1, m2, n, p1, p2, 0));\r\nprintk(" DPLL_A: 0x%08x\n", hw->dpll_a);\r\nprintk(" DPLL_B: 0x%08x\n", hw->dpll_b);\r\nprintk(" FPA0: 0x%08x\n", hw->fpa0);\r\nprintk(" FPA1: 0x%08x\n", hw->fpa1);\r\nprintk(" FPB0: 0x%08x\n", hw->fpb0);\r\nprintk(" FPB1: 0x%08x\n", hw->fpb1);\r\nn = (hw->fpa0 >> FP_N_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\r\nm1 = (hw->fpa0 >> FP_M1_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\r\nm2 = (hw->fpa0 >> FP_M2_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\r\nintelfbhw_get_p1p2(dinfo, hw->dpll_a, &p1, &p2);\r\nprintk(" PLLA0: (m1, m2, n, p1, p2) = (%d, %d, %d, %d, %d)\n",\r\nm1, m2, n, p1, p2);\r\nprintk(" PLLA0: clock is %d\n",\r\ncalc_vclock(index, m1, m2, n, p1, p2, 0));\r\nn = (hw->fpa1 >> FP_N_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\r\nm1 = (hw->fpa1 >> FP_M1_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\r\nm2 = (hw->fpa1 >> FP_M2_DIVISOR_SHIFT) & FP_DIVISOR_MASK;\r\nintelfbhw_get_p1p2(dinfo, hw->dpll_a, &p1, &p2);\r\nprintk(" PLLA1: (m1, m2, n, p1, p2) = (%d, %d, %d, %d, %d)\n",\r\nm1, m2, n, p1, p2);\r\nprintk(" PLLA1: clock is %d\n",\r\ncalc_vclock(index, m1, m2, n, p1, p2, 0));\r\n#if 0\r\nprintk(" PALETTE_A:\n");\r\nfor (i = 0; i < PALETTE_8_ENTRIES)\r\nprintk(" %3d: 0x%08x\n", i, hw->palette_a[i]);\r\nprintk(" PALETTE_B:\n");\r\nfor (i = 0; i < PALETTE_8_ENTRIES)\r\nprintk(" %3d: 0x%08x\n", i, hw->palette_b[i]);\r\n#endif\r\nprintk(" HTOTAL_A: 0x%08x\n", hw->htotal_a);\r\nprintk(" HBLANK_A: 0x%08x\n", hw->hblank_a);\r\nprintk(" HSYNC_A: 0x%08x\n", hw->hsync_a);\r\nprintk(" VTOTAL_A: 0x%08x\n", hw->vtotal_a);\r\nprintk(" VBLANK_A: 0x%08x\n", hw->vblank_a);\r\nprintk(" VSYNC_A: 0x%08x\n", hw->vsync_a);\r\nprintk(" SRC_SIZE_A: 0x%08x\n", hw->src_size_a);\r\nprintk(" BCLRPAT_A: 0x%08x\n", hw->bclrpat_a);\r\nprintk(" HTOTAL_B: 0x%08x\n", hw->htotal_b);\r\nprintk(" HBLANK_B: 0x%08x\n", hw->hblank_b);\r\nprintk(" HSYNC_B: 0x%08x\n", hw->hsync_b);\r\nprintk(" VTOTAL_B: 0x%08x\n", hw->vtotal_b);\r\nprintk(" VBLANK_B: 0x%08x\n", hw->vblank_b);\r\nprintk(" VSYNC_B: 0x%08x\n", hw->vsync_b);\r\nprintk(" SRC_SIZE_B: 0x%08x\n", hw->src_size_b);\r\nprintk(" BCLRPAT_B: 0x%08x\n", hw->bclrpat_b);\r\nprintk(" ADPA: 0x%08x\n", hw->adpa);\r\nprintk(" DVOA: 0x%08x\n", hw->dvoa);\r\nprintk(" DVOB: 0x%08x\n", hw->dvob);\r\nprintk(" DVOC: 0x%08x\n", hw->dvoc);\r\nprintk(" DVOA_SRCDIM: 0x%08x\n", hw->dvoa_srcdim);\r\nprintk(" DVOB_SRCDIM: 0x%08x\n", hw->dvob_srcdim);\r\nprintk(" DVOC_SRCDIM: 0x%08x\n", hw->dvoc_srcdim);\r\nprintk(" LVDS: 0x%08x\n", hw->lvds);\r\nprintk(" PIPEACONF: 0x%08x\n", hw->pipe_a_conf);\r\nprintk(" PIPEBCONF: 0x%08x\n", hw->pipe_b_conf);\r\nprintk(" DISPARB: 0x%08x\n", hw->disp_arb);\r\nprintk(" CURSOR_A_CONTROL: 0x%08x\n", hw->cursor_a_control);\r\nprintk(" CURSOR_B_CONTROL: 0x%08x\n", hw->cursor_b_control);\r\nprintk(" CURSOR_A_BASEADDR: 0x%08x\n", hw->cursor_a_base);\r\nprintk(" CURSOR_B_BASEADDR: 0x%08x\n", hw->cursor_b_base);\r\nprintk(" CURSOR_A_PALETTE: ");\r\nfor (i = 0; i < 4; i++) {\r\nprintk("0x%08x", hw->cursor_a_palette[i]);\r\nif (i < 3)\r\nprintk(", ");\r\n}\r\nprintk("\n");\r\nprintk(" CURSOR_B_PALETTE: ");\r\nfor (i = 0; i < 4; i++) {\r\nprintk("0x%08x", hw->cursor_b_palette[i]);\r\nif (i < 3)\r\nprintk(", ");\r\n}\r\nprintk("\n");\r\nprintk(" CURSOR_SIZE: 0x%08x\n", hw->cursor_size);\r\nprintk(" DSPACNTR: 0x%08x\n", hw->disp_a_ctrl);\r\nprintk(" DSPBCNTR: 0x%08x\n", hw->disp_b_ctrl);\r\nprintk(" DSPABASE: 0x%08x\n", hw->disp_a_base);\r\nprintk(" DSPBBASE: 0x%08x\n", hw->disp_b_base);\r\nprintk(" DSPASTRIDE: 0x%08x\n", hw->disp_a_stride);\r\nprintk(" DSPBSTRIDE: 0x%08x\n", hw->disp_b_stride);\r\nprintk(" VGACNTRL: 0x%08x\n", hw->vgacntrl);\r\nprintk(" ADD_ID: 0x%08x\n", hw->add_id);\r\nfor (i = 0; i < 7; i++) {\r\nprintk(" SWF0%d 0x%08x\n", i,\r\nhw->swf0x[i]);\r\n}\r\nfor (i = 0; i < 7; i++) {\r\nprintk(" SWF1%d 0x%08x\n", i,\r\nhw->swf1x[i]);\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nprintk(" SWF3%d 0x%08x\n", i,\r\nhw->swf3x[i]);\r\n}\r\nfor (i = 0; i < 8; i++)\r\nprintk(" FENCE%d 0x%08x\n", i,\r\nhw->fence[i]);\r\nprintk(" INSTPM 0x%08x\n", hw->instpm);\r\nprintk(" MEM_MODE 0x%08x\n", hw->mem_mode);\r\nprintk(" FW_BLC_0 0x%08x\n", hw->fw_blc_0);\r\nprintk(" FW_BLC_1 0x%08x\n", hw->fw_blc_1);\r\nprintk(" HWSTAM 0x%04x\n", hw->hwstam);\r\nprintk(" IER 0x%04x\n", hw->ier);\r\nprintk(" IIR 0x%04x\n", hw->iir);\r\nprintk(" IMR 0x%04x\n", hw->imr);\r\nprintk("hw state dump end\n");\r\n#endif\r\n}\r\nstatic int splitm(int index, unsigned int m, unsigned int *retm1,\r\nunsigned int *retm2)\r\n{\r\nint m1, m2;\r\nint testm;\r\nstruct pll_min_max *pll = &plls[index];\r\nfor (m1 = pll->min_m1; m1 < pll->max_m1 + 1; m1++) {\r\nfor (m2 = pll->min_m2; m2 < pll->max_m2 + 1; m2++) {\r\ntestm = (5 * (m1 + 2)) + (m2 + 2);\r\nif (testm == m) {\r\n*retm1 = (unsigned int)m1;\r\n*retm2 = (unsigned int)m2;\r\nreturn 0;\r\n}\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int splitp(int index, unsigned int p, unsigned int *retp1,\r\nunsigned int *retp2)\r\n{\r\nint p1, p2;\r\nstruct pll_min_max *pll = &plls[index];\r\nif (index == PLLS_I9xx) {\r\np2 = (p % 10) ? 1 : 0;\r\np1 = p / (p2 ? 5 : 10);\r\n*retp1 = (unsigned int)p1;\r\n*retp2 = (unsigned int)p2;\r\nreturn 0;\r\n}\r\nif (p % 4 == 0)\r\np2 = 1;\r\nelse\r\np2 = 0;\r\np1 = (p / (1 << (p2 + 1))) - 2;\r\nif (p % 4 == 0 && p1 < pll->min_p1) {\r\np2 = 0;\r\np1 = (p / (1 << (p2 + 1))) - 2;\r\n}\r\nif (p1 < pll->min_p1 || p1 > pll->max_p1 ||\r\n(p1 + 2) * (1 << (p2 + 1)) != p) {\r\nreturn 1;\r\n} else {\r\n*retp1 = (unsigned int)p1;\r\n*retp2 = (unsigned int)p2;\r\nreturn 0;\r\n}\r\n}\r\nstatic int calc_pll_params(int index, int clock, u32 *retm1, u32 *retm2,\r\nu32 *retn, u32 *retp1, u32 *retp2, u32 *retclock)\r\n{\r\nu32 m1, m2, n, p1, p2, n1, testm;\r\nu32 f_vco, p, p_best = 0, m, f_out = 0;\r\nu32 err_max, err_target, err_best = 10000000;\r\nu32 n_best = 0, m_best = 0, f_best, f_err;\r\nu32 p_min, p_max, p_inc, div_max;\r\nstruct pll_min_max *pll = &plls[index];\r\nerr_max = 5 * clock / 1000;\r\nerr_target = clock / 1000;\r\nDBG_MSG("Clock is %d\n", clock);\r\ndiv_max = pll->max_vco / clock;\r\np_inc = (clock <= pll->p_transition_clk) ? pll->p_inc_lo : pll->p_inc_hi;\r\np_min = p_inc;\r\np_max = ROUND_DOWN_TO(div_max, p_inc);\r\nif (p_min < pll->min_p)\r\np_min = pll->min_p;\r\nif (p_max > pll->max_p)\r\np_max = pll->max_p;\r\nDBG_MSG("p range is %d-%d (%d)\n", p_min, p_max, p_inc);\r\np = p_min;\r\ndo {\r\nif (splitp(index, p, &p1, &p2)) {\r\nWRN_MSG("cannot split p = %d\n", p);\r\np += p_inc;\r\ncontinue;\r\n}\r\nn = pll->min_n;\r\nf_vco = clock * p;\r\ndo {\r\nm = ROUND_UP_TO(f_vco * n, pll->ref_clk) / pll->ref_clk;\r\nif (m < pll->min_m)\r\nm = pll->min_m + 1;\r\nif (m > pll->max_m)\r\nm = pll->max_m - 1;\r\nfor (testm = m - 1; testm <= m; testm++) {\r\nf_out = calc_vclock3(index, testm, n, p);\r\nif (splitm(index, testm, &m1, &m2)) {\r\nWRN_MSG("cannot split m = %d\n",\r\ntestm);\r\ncontinue;\r\n}\r\nif (clock > f_out)\r\nf_err = clock - f_out;\r\nelse\r\nf_err = f_out - clock + 1;\r\nif (f_err < err_best) {\r\nm_best = testm;\r\nn_best = n;\r\np_best = p;\r\nf_best = f_out;\r\nerr_best = f_err;\r\n}\r\n}\r\nn++;\r\n} while ((n <= pll->max_n) && (f_out >= clock));\r\np += p_inc;\r\n} while ((p <= p_max));\r\nif (!m_best) {\r\nWRN_MSG("cannot find parameters for clock %d\n", clock);\r\nreturn 1;\r\n}\r\nm = m_best;\r\nn = n_best;\r\np = p_best;\r\nsplitm(index, m, &m1, &m2);\r\nsplitp(index, p, &p1, &p2);\r\nn1 = n - 2;\r\nDBG_MSG("m, n, p: %d (%d,%d), %d (%d), %d (%d,%d), "\r\n"f: %d (%d), VCO: %d\n",\r\nm, m1, m2, n, n1, p, p1, p2,\r\ncalc_vclock3(index, m, n, p),\r\ncalc_vclock(index, m1, m2, n1, p1, p2, 0),\r\ncalc_vclock3(index, m, n, p) * p);\r\n*retm1 = m1;\r\n*retm2 = m2;\r\n*retn = n1;\r\n*retp1 = p1;\r\n*retp2 = p2;\r\n*retclock = calc_vclock(index, m1, m2, n1, p1, p2, 0);\r\nreturn 0;\r\n}\r\nstatic __inline__ int check_overflow(u32 value, u32 limit,\r\nconst char *description)\r\n{\r\nif (value > limit) {\r\nWRN_MSG("%s value %d exceeds limit %d\n",\r\ndescription, value, limit);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint intelfbhw_mode_to_hw(struct intelfb_info *dinfo,\r\nstruct intelfb_hwstate *hw,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nint pipe = intelfbhw_active_pipe(hw);\r\nu32 *dpll, *fp0, *fp1;\r\nu32 m1, m2, n, p1, p2, clock_target, clock;\r\nu32 hsync_start, hsync_end, hblank_start, hblank_end, htotal, hactive;\r\nu32 vsync_start, vsync_end, vblank_start, vblank_end, vtotal, vactive;\r\nu32 vsync_pol, hsync_pol;\r\nu32 *vs, *vb, *vt, *hs, *hb, *ht, *ss, *pipe_conf;\r\nu32 stride_alignment;\r\nDBG_MSG("intelfbhw_mode_to_hw\n");\r\nhw->vgacntrl |= VGA_DISABLE;\r\nif (pipe == PIPE_B) {\r\ndpll = &hw->dpll_b;\r\nfp0 = &hw->fpb0;\r\nfp1 = &hw->fpb1;\r\nhs = &hw->hsync_b;\r\nhb = &hw->hblank_b;\r\nht = &hw->htotal_b;\r\nvs = &hw->vsync_b;\r\nvb = &hw->vblank_b;\r\nvt = &hw->vtotal_b;\r\nss = &hw->src_size_b;\r\npipe_conf = &hw->pipe_b_conf;\r\n} else {\r\ndpll = &hw->dpll_a;\r\nfp0 = &hw->fpa0;\r\nfp1 = &hw->fpa1;\r\nhs = &hw->hsync_a;\r\nhb = &hw->hblank_a;\r\nht = &hw->htotal_a;\r\nvs = &hw->vsync_a;\r\nvb = &hw->vblank_a;\r\nvt = &hw->vtotal_a;\r\nss = &hw->src_size_a;\r\npipe_conf = &hw->pipe_a_conf;\r\n}\r\nhw->adpa &= ~ADPA_USE_VGA_HVPOLARITY;\r\nhsync_pol = (var->sync & FB_SYNC_HOR_HIGH_ACT) ?\r\nADPA_SYNC_ACTIVE_HIGH : ADPA_SYNC_ACTIVE_LOW;\r\nvsync_pol = (var->sync & FB_SYNC_VERT_HIGH_ACT) ?\r\nADPA_SYNC_ACTIVE_HIGH : ADPA_SYNC_ACTIVE_LOW;\r\nhw->adpa &= ~((ADPA_SYNC_ACTIVE_MASK << ADPA_VSYNC_ACTIVE_SHIFT) |\r\n(ADPA_SYNC_ACTIVE_MASK << ADPA_HSYNC_ACTIVE_SHIFT));\r\nhw->adpa |= (hsync_pol << ADPA_HSYNC_ACTIVE_SHIFT) |\r\n(vsync_pol << ADPA_VSYNC_ACTIVE_SHIFT);\r\nhw->adpa &= ~(PIPE_MASK << ADPA_PIPE_SELECT_SHIFT);\r\nhw->adpa |= (pipe << ADPA_PIPE_SELECT_SHIFT);\r\nhw->adpa &= ~ADPA_DPMS_CONTROL_MASK;\r\nhw->adpa |= ADPA_DPMS_D0;\r\nhw->adpa |= ADPA_DAC_ENABLE;\r\n*dpll |= (DPLL_VCO_ENABLE | DPLL_VGA_MODE_DISABLE);\r\n*dpll &= ~(DPLL_RATE_SELECT_MASK | DPLL_REFERENCE_SELECT_MASK);\r\n*dpll |= (DPLL_REFERENCE_DEFAULT | DPLL_RATE_SELECT_FP0);\r\nclock_target = 1000000000 / var->pixclock;\r\nif (calc_pll_params(dinfo->pll_index, clock_target, &m1, &m2,\r\n&n, &p1, &p2, &clock)) {\r\nWRN_MSG("calc_pll_params failed\n");\r\nreturn 1;\r\n}\r\nif (check_overflow(p1, DPLL_P1_MASK, "PLL P1 parameter"))\r\nreturn 1;\r\nif (check_overflow(p2, DPLL_P2_MASK, "PLL P2 parameter"))\r\nreturn 1;\r\nif (check_overflow(m1, FP_DIVISOR_MASK, "PLL M1 parameter"))\r\nreturn 1;\r\nif (check_overflow(m2, FP_DIVISOR_MASK, "PLL M2 parameter"))\r\nreturn 1;\r\nif (check_overflow(n, FP_DIVISOR_MASK, "PLL N parameter"))\r\nreturn 1;\r\n*dpll &= ~DPLL_P1_FORCE_DIV2;\r\n*dpll &= ~((DPLL_P2_MASK << DPLL_P2_SHIFT) |\r\n(DPLL_P1_MASK << DPLL_P1_SHIFT));\r\nif (IS_I9XX(dinfo)) {\r\n*dpll |= (p2 << DPLL_I9XX_P2_SHIFT);\r\n*dpll |= (1 << (p1 - 1)) << DPLL_P1_SHIFT;\r\n} else\r\n*dpll |= (p2 << DPLL_P2_SHIFT) | (p1 << DPLL_P1_SHIFT);\r\n*fp0 = (n << FP_N_DIVISOR_SHIFT) |\r\n(m1 << FP_M1_DIVISOR_SHIFT) |\r\n(m2 << FP_M2_DIVISOR_SHIFT);\r\n*fp1 = *fp0;\r\nhw->dvob &= ~PORT_ENABLE;\r\nhw->dvoc &= ~PORT_ENABLE;\r\nhw->disp_a_ctrl |= DISPPLANE_PLANE_ENABLE;\r\nhw->disp_a_ctrl &= ~DISPPLANE_GAMMA_ENABLE;\r\nhw->disp_a_ctrl &= ~DISPPLANE_PIXFORMAT_MASK;\r\nswitch (intelfb_var_to_depth(var)) {\r\ncase 8:\r\nhw->disp_a_ctrl |= DISPPLANE_8BPP | DISPPLANE_GAMMA_ENABLE;\r\nbreak;\r\ncase 15:\r\nhw->disp_a_ctrl |= DISPPLANE_15_16BPP;\r\nbreak;\r\ncase 16:\r\nhw->disp_a_ctrl |= DISPPLANE_16BPP;\r\nbreak;\r\ncase 24:\r\nhw->disp_a_ctrl |= DISPPLANE_32BPP_NO_ALPHA;\r\nbreak;\r\n}\r\nhw->disp_a_ctrl &= ~(PIPE_MASK << DISPPLANE_SEL_PIPE_SHIFT);\r\nhw->disp_a_ctrl |= (pipe << DISPPLANE_SEL_PIPE_SHIFT);\r\nhactive = var->xres;\r\nhsync_start = hactive + var->right_margin;\r\nhsync_end = hsync_start + var->hsync_len;\r\nhtotal = hsync_end + var->left_margin;\r\nhblank_start = hactive;\r\nhblank_end = htotal;\r\nDBG_MSG("H: act %d, ss %d, se %d, tot %d bs %d, be %d\n",\r\nhactive, hsync_start, hsync_end, htotal, hblank_start,\r\nhblank_end);\r\nvactive = var->yres;\r\nif (var->vmode & FB_VMODE_INTERLACED)\r\nvactive--;\r\nvsync_start = vactive + var->lower_margin;\r\nvsync_end = vsync_start + var->vsync_len;\r\nvtotal = vsync_end + var->upper_margin;\r\nvblank_start = vactive;\r\nvblank_end = vsync_end + 1;\r\nDBG_MSG("V: act %d, ss %d, se %d, tot %d bs %d, be %d\n",\r\nvactive, vsync_start, vsync_end, vtotal, vblank_start,\r\nvblank_end);\r\nhactive--;\r\nif (check_overflow(hactive, HACTIVE_MASK, "CRTC hactive"))\r\nreturn 1;\r\nhsync_start--;\r\nif (check_overflow(hsync_start, HSYNCSTART_MASK, "CRTC hsync_start"))\r\nreturn 1;\r\nhsync_end--;\r\nif (check_overflow(hsync_end, HSYNCEND_MASK, "CRTC hsync_end"))\r\nreturn 1;\r\nhtotal--;\r\nif (check_overflow(htotal, HTOTAL_MASK, "CRTC htotal"))\r\nreturn 1;\r\nhblank_start--;\r\nif (check_overflow(hblank_start, HBLANKSTART_MASK, "CRTC hblank_start"))\r\nreturn 1;\r\nhblank_end--;\r\nif (check_overflow(hblank_end, HBLANKEND_MASK, "CRTC hblank_end"))\r\nreturn 1;\r\nvactive--;\r\nif (check_overflow(vactive, VACTIVE_MASK, "CRTC vactive"))\r\nreturn 1;\r\nvsync_start--;\r\nif (check_overflow(vsync_start, VSYNCSTART_MASK, "CRTC vsync_start"))\r\nreturn 1;\r\nvsync_end--;\r\nif (check_overflow(vsync_end, VSYNCEND_MASK, "CRTC vsync_end"))\r\nreturn 1;\r\nvtotal--;\r\nif (check_overflow(vtotal, VTOTAL_MASK, "CRTC vtotal"))\r\nreturn 1;\r\nvblank_start--;\r\nif (check_overflow(vblank_start, VBLANKSTART_MASK, "CRTC vblank_start"))\r\nreturn 1;\r\nvblank_end--;\r\nif (check_overflow(vblank_end, VBLANKEND_MASK, "CRTC vblank_end"))\r\nreturn 1;\r\n*ht = (htotal << HTOTAL_SHIFT) | (hactive << HACTIVE_SHIFT);\r\n*hb = (hblank_start << HBLANKSTART_SHIFT) |\r\n(hblank_end << HSYNCEND_SHIFT);\r\n*hs = (hsync_start << HSYNCSTART_SHIFT) | (hsync_end << HSYNCEND_SHIFT);\r\n*vt = (vtotal << VTOTAL_SHIFT) | (vactive << VACTIVE_SHIFT);\r\n*vb = (vblank_start << VBLANKSTART_SHIFT) |\r\n(vblank_end << VSYNCEND_SHIFT);\r\n*vs = (vsync_start << VSYNCSTART_SHIFT) | (vsync_end << VSYNCEND_SHIFT);\r\n*ss = (hactive << SRC_SIZE_HORIZ_SHIFT) |\r\n(vactive << SRC_SIZE_VERT_SHIFT);\r\nhw->disp_a_stride = dinfo->pitch;\r\nDBG_MSG("pitch is %d\n", hw->disp_a_stride);\r\nhw->disp_a_base = hw->disp_a_stride * var->yoffset +\r\nvar->xoffset * var->bits_per_pixel / 8;\r\nhw->disp_a_base += dinfo->fb.offset << 12;\r\nstride_alignment = IS_I9XX(dinfo) ? STRIDE_ALIGNMENT_I9XX :\r\nSTRIDE_ALIGNMENT;\r\nif (hw->disp_a_stride % stride_alignment != 0) {\r\nWRN_MSG("display stride %d has bad alignment %d\n",\r\nhw->disp_a_stride, stride_alignment);\r\nreturn 1;\r\n}\r\n*pipe_conf &= ~PIPECONF_GAMMA;\r\nif (var->vmode & FB_VMODE_INTERLACED)\r\n*pipe_conf |= PIPECONF_INTERLACE_W_FIELD_INDICATION;\r\nelse\r\n*pipe_conf &= ~PIPECONF_INTERLACE_MASK;\r\nreturn 0;\r\n}\r\nint intelfbhw_program_mode(struct intelfb_info *dinfo,\r\nconst struct intelfb_hwstate *hw, int blank)\r\n{\r\nu32 tmp;\r\nconst u32 *dpll, *fp0, *fp1, *pipe_conf;\r\nconst u32 *hs, *ht, *hb, *vs, *vt, *vb, *ss;\r\nu32 dpll_reg, fp0_reg, fp1_reg, pipe_conf_reg, pipe_stat_reg;\r\nu32 hsync_reg, htotal_reg, hblank_reg;\r\nu32 vsync_reg, vtotal_reg, vblank_reg;\r\nu32 src_size_reg;\r\nu32 count, tmp_val[3];\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfbhw_program_mode\n");\r\n#endif\r\ntmp = INREG(VGACNTRL);\r\ntmp |= VGA_DISABLE;\r\nOUTREG(VGACNTRL, tmp);\r\ndinfo->pipe = intelfbhw_active_pipe(hw);\r\nif (dinfo->pipe == PIPE_B) {\r\ndpll = &hw->dpll_b;\r\nfp0 = &hw->fpb0;\r\nfp1 = &hw->fpb1;\r\npipe_conf = &hw->pipe_b_conf;\r\nhs = &hw->hsync_b;\r\nhb = &hw->hblank_b;\r\nht = &hw->htotal_b;\r\nvs = &hw->vsync_b;\r\nvb = &hw->vblank_b;\r\nvt = &hw->vtotal_b;\r\nss = &hw->src_size_b;\r\ndpll_reg = DPLL_B;\r\nfp0_reg = FPB0;\r\nfp1_reg = FPB1;\r\npipe_conf_reg = PIPEBCONF;\r\npipe_stat_reg = PIPEBSTAT;\r\nhsync_reg = HSYNC_B;\r\nhtotal_reg = HTOTAL_B;\r\nhblank_reg = HBLANK_B;\r\nvsync_reg = VSYNC_B;\r\nvtotal_reg = VTOTAL_B;\r\nvblank_reg = VBLANK_B;\r\nsrc_size_reg = SRC_SIZE_B;\r\n} else {\r\ndpll = &hw->dpll_a;\r\nfp0 = &hw->fpa0;\r\nfp1 = &hw->fpa1;\r\npipe_conf = &hw->pipe_a_conf;\r\nhs = &hw->hsync_a;\r\nhb = &hw->hblank_a;\r\nht = &hw->htotal_a;\r\nvs = &hw->vsync_a;\r\nvb = &hw->vblank_a;\r\nvt = &hw->vtotal_a;\r\nss = &hw->src_size_a;\r\ndpll_reg = DPLL_A;\r\nfp0_reg = FPA0;\r\nfp1_reg = FPA1;\r\npipe_conf_reg = PIPEACONF;\r\npipe_stat_reg = PIPEASTAT;\r\nhsync_reg = HSYNC_A;\r\nhtotal_reg = HTOTAL_A;\r\nhblank_reg = HBLANK_A;\r\nvsync_reg = VSYNC_A;\r\nvtotal_reg = VTOTAL_A;\r\nvblank_reg = VBLANK_A;\r\nsrc_size_reg = SRC_SIZE_A;\r\n}\r\ntmp = INREG(pipe_conf_reg);\r\ntmp &= ~PIPECONF_ENABLE;\r\nOUTREG(pipe_conf_reg, tmp);\r\ncount = 0;\r\ndo {\r\ntmp_val[count % 3] = INREG(PIPEA_DSL);\r\nif ((tmp_val[0] == tmp_val[1]) && (tmp_val[1] == tmp_val[2]))\r\nbreak;\r\ncount++;\r\nudelay(1);\r\nif (count % 200 == 0) {\r\ntmp = INREG(pipe_conf_reg);\r\ntmp &= ~PIPECONF_ENABLE;\r\nOUTREG(pipe_conf_reg, tmp);\r\n}\r\n} while (count < 2000);\r\nOUTREG(ADPA, INREG(ADPA) & ~ADPA_DAC_ENABLE);\r\ntmp = INREG(DSPACNTR);\r\ntmp &= ~DISPPLANE_PLANE_ENABLE;\r\nOUTREG(DSPACNTR, tmp);\r\ntmp = INREG(DSPBCNTR);\r\ntmp &= ~DISPPLANE_PLANE_ENABLE;\r\nOUTREG(DSPBCNTR, tmp);\r\nmdelay(20);\r\nOUTREG(DVOB, INREG(DVOB) & ~PORT_ENABLE);\r\nOUTREG(DVOC, INREG(DVOC) & ~PORT_ENABLE);\r\nOUTREG(ADPA, INREG(ADPA) & ~ADPA_DAC_ENABLE);\r\ntmp = INREG(ADPA);\r\ntmp &= ~ADPA_DPMS_CONTROL_MASK;\r\ntmp |= ADPA_DPMS_D3;\r\nOUTREG(ADPA, tmp);\r\nOUTREG(0x61204, 0xabcd0000);\r\ntmp = INREG(dpll_reg);\r\ntmp &= ~DPLL_VCO_ENABLE;\r\nOUTREG(dpll_reg, tmp);\r\nOUTREG(fp0_reg, *fp0);\r\nOUTREG(fp1_reg, *fp1);\r\nOUTREG(dpll_reg, *dpll);\r\nOUTREG(DVOB, hw->dvob);\r\nOUTREG(DVOC, hw->dvoc);\r\nOUTREG(0x61204, 0x00000000);\r\nOUTREG(ADPA, INREG(ADPA) | ADPA_DAC_ENABLE);\r\nOUTREG(ADPA, (hw->adpa & ~(ADPA_DPMS_CONTROL_MASK)) | ADPA_DPMS_D3);\r\nOUTREG(hsync_reg, *hs);\r\nOUTREG(hblank_reg, *hb);\r\nOUTREG(htotal_reg, *ht);\r\nOUTREG(vsync_reg, *vs);\r\nOUTREG(vblank_reg, *vb);\r\nOUTREG(vtotal_reg, *vt);\r\nOUTREG(src_size_reg, *ss);\r\nswitch (dinfo->info->var.vmode & (FB_VMODE_INTERLACED |\r\nFB_VMODE_ODD_FLD_FIRST)) {\r\ncase FB_VMODE_INTERLACED | FB_VMODE_ODD_FLD_FIRST:\r\nOUTREG(pipe_stat_reg, 0xFFFF | PIPESTAT_FLD_EVT_ODD_EN);\r\nbreak;\r\ncase FB_VMODE_INTERLACED:\r\nOUTREG(pipe_stat_reg, 0xFFFF | PIPESTAT_FLD_EVT_EVEN_EN);\r\nbreak;\r\ndefault:\r\nOUTREG(pipe_stat_reg, 0xFFFF);\r\n}\r\nOUTREG(pipe_conf_reg, *pipe_conf | PIPECONF_ENABLE);\r\ntmp = INREG(ADPA);\r\ntmp &= ~ADPA_DPMS_CONTROL_MASK;\r\ntmp |= ADPA_DPMS_D0;\r\nOUTREG(ADPA, tmp);\r\nif (dinfo->pdev->device == PCI_DEVICE_ID_INTEL_830M) {\r\ntmp = INREG(DSPACNTR);\r\nif ((tmp & DISPPLANE_PLANE_ENABLE) != DISPPLANE_PLANE_ENABLE) {\r\ntmp |= DISPPLANE_PLANE_ENABLE;\r\nOUTREG(DSPACNTR, tmp);\r\nOUTREG(DSPACNTR,\r\nhw->disp_a_ctrl|DISPPLANE_PLANE_ENABLE);\r\nmdelay(1);\r\n}\r\n}\r\nOUTREG(DSPACNTR, hw->disp_a_ctrl & ~DISPPLANE_PLANE_ENABLE);\r\nOUTREG(DSPASTRIDE, hw->disp_a_stride);\r\nOUTREG(DSPABASE, hw->disp_a_base);\r\nif (!blank) {\r\ntmp = INREG(DSPACNTR);\r\ntmp |= DISPPLANE_PLANE_ENABLE;\r\nOUTREG(DSPACNTR, tmp);\r\nOUTREG(DSPABASE, hw->disp_a_base);\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 get_ring_space(struct intelfb_info *dinfo)\r\n{\r\nu32 ring_space;\r\nif (dinfo->ring_tail >= dinfo->ring_head)\r\nring_space = dinfo->ring.size -\r\n(dinfo->ring_tail - dinfo->ring_head);\r\nelse\r\nring_space = dinfo->ring_head - dinfo->ring_tail;\r\nif (ring_space > RING_MIN_FREE)\r\nring_space -= RING_MIN_FREE;\r\nelse\r\nring_space = 0;\r\nreturn ring_space;\r\n}\r\nstatic int wait_ring(struct intelfb_info *dinfo, int n)\r\n{\r\nint i = 0;\r\nunsigned long end;\r\nu32 last_head = INREG(PRI_RING_HEAD) & RING_HEAD_MASK;\r\n#if VERBOSE > 0\r\nDBG_MSG("wait_ring: %d\n", n);\r\n#endif\r\nend = jiffies + (HZ * 3);\r\nwhile (dinfo->ring_space < n) {\r\ndinfo->ring_head = INREG(PRI_RING_HEAD) & RING_HEAD_MASK;\r\ndinfo->ring_space = get_ring_space(dinfo);\r\nif (dinfo->ring_head != last_head) {\r\nend = jiffies + (HZ * 3);\r\nlast_head = dinfo->ring_head;\r\n}\r\ni++;\r\nif (time_before(end, jiffies)) {\r\nif (!i) {\r\nreset_state(dinfo);\r\nrefresh_ring(dinfo);\r\ndo_flush(dinfo);\r\nend = jiffies + (HZ * 3);\r\ni = 1;\r\n} else {\r\nWRN_MSG("ring buffer : space: %d wanted %d\n",\r\ndinfo->ring_space, n);\r\nWRN_MSG("lockup - turning off hardware "\r\n"acceleration\n");\r\ndinfo->ring_lockup = 1;\r\nbreak;\r\n}\r\n}\r\nudelay(1);\r\n}\r\nreturn i;\r\n}\r\nstatic void do_flush(struct intelfb_info *dinfo)\r\n{\r\nSTART_RING(2);\r\nOUT_RING(MI_FLUSH | MI_WRITE_DIRTY_STATE | MI_INVALIDATE_MAP_CACHE);\r\nOUT_RING(MI_NOOP);\r\nADVANCE_RING();\r\n}\r\nvoid intelfbhw_do_sync(struct intelfb_info *dinfo)\r\n{\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfbhw_do_sync\n");\r\n#endif\r\nif (!dinfo->accel)\r\nreturn;\r\ndo_flush(dinfo);\r\nwait_ring(dinfo, dinfo->ring.size - RING_MIN_FREE);\r\ndinfo->ring_space = dinfo->ring.size - RING_MIN_FREE;\r\n}\r\nstatic void refresh_ring(struct intelfb_info *dinfo)\r\n{\r\n#if VERBOSE > 0\r\nDBG_MSG("refresh_ring\n");\r\n#endif\r\ndinfo->ring_head = INREG(PRI_RING_HEAD) & RING_HEAD_MASK;\r\ndinfo->ring_tail = INREG(PRI_RING_TAIL) & RING_TAIL_MASK;\r\ndinfo->ring_space = get_ring_space(dinfo);\r\n}\r\nstatic void reset_state(struct intelfb_info *dinfo)\r\n{\r\nint i;\r\nu32 tmp;\r\n#if VERBOSE > 0\r\nDBG_MSG("reset_state\n");\r\n#endif\r\nfor (i = 0; i < FENCE_NUM; i++)\r\nOUTREG(FENCE + (i << 2), 0);\r\ntmp = INREG(PRI_RING_LENGTH);\r\nif (tmp & RING_ENABLE) {\r\n#if VERBOSE > 0\r\nDBG_MSG("reset_state: ring was enabled\n");\r\n#endif\r\nrefresh_ring(dinfo);\r\nintelfbhw_do_sync(dinfo);\r\nDO_RING_IDLE();\r\n}\r\nOUTREG(PRI_RING_LENGTH, 0);\r\nOUTREG(PRI_RING_HEAD, 0);\r\nOUTREG(PRI_RING_TAIL, 0);\r\nOUTREG(PRI_RING_START, 0);\r\n}\r\nvoid intelfbhw_2d_stop(struct intelfb_info *dinfo)\r\n{\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfbhw_2d_stop: accel: %d, ring_active: %d\n",\r\ndinfo->accel, dinfo->ring_active);\r\n#endif\r\nif (!dinfo->accel)\r\nreturn;\r\ndinfo->ring_active = 0;\r\nreset_state(dinfo);\r\n}\r\nvoid intelfbhw_2d_start(struct intelfb_info *dinfo)\r\n{\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfbhw_2d_start: accel: %d, ring_active: %d\n",\r\ndinfo->accel, dinfo->ring_active);\r\n#endif\r\nif (!dinfo->accel)\r\nreturn;\r\nOUTREG(PRI_RING_LENGTH, 0);\r\nOUTREG(PRI_RING_TAIL, 0);\r\nOUTREG(PRI_RING_HEAD, 0);\r\nOUTREG(PRI_RING_START, dinfo->ring.physical & RING_START_MASK);\r\nOUTREG(PRI_RING_LENGTH,\r\n((dinfo->ring.size - GTT_PAGE_SIZE) & RING_LENGTH_MASK) |\r\nRING_NO_REPORT | RING_ENABLE);\r\nrefresh_ring(dinfo);\r\ndinfo->ring_active = 1;\r\n}\r\nvoid intelfbhw_do_fillrect(struct intelfb_info *dinfo, u32 x, u32 y, u32 w,\r\nu32 h, u32 color, u32 pitch, u32 bpp, u32 rop)\r\n{\r\nu32 br00, br09, br13, br14, br16;\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfbhw_do_fillrect: (%d,%d) %dx%d, c 0x%06x, p %d bpp %d, "\r\n"rop 0x%02x\n", x, y, w, h, color, pitch, bpp, rop);\r\n#endif\r\nbr00 = COLOR_BLT_CMD;\r\nbr09 = dinfo->fb_start + (y * pitch + x * (bpp / 8));\r\nbr13 = (rop << ROP_SHIFT) | pitch;\r\nbr14 = (h << HEIGHT_SHIFT) | ((w * (bpp / 8)) << WIDTH_SHIFT);\r\nbr16 = color;\r\nswitch (bpp) {\r\ncase 8:\r\nbr13 |= COLOR_DEPTH_8;\r\nbreak;\r\ncase 16:\r\nbr13 |= COLOR_DEPTH_16;\r\nbreak;\r\ncase 32:\r\nbr13 |= COLOR_DEPTH_32;\r\nbr00 |= WRITE_ALPHA | WRITE_RGB;\r\nbreak;\r\n}\r\nSTART_RING(6);\r\nOUT_RING(br00);\r\nOUT_RING(br13);\r\nOUT_RING(br14);\r\nOUT_RING(br09);\r\nOUT_RING(br16);\r\nOUT_RING(MI_NOOP);\r\nADVANCE_RING();\r\n#if VERBOSE > 0\r\nDBG_MSG("ring = 0x%08x, 0x%08x (%d)\n", dinfo->ring_head,\r\ndinfo->ring_tail, dinfo->ring_space);\r\n#endif\r\n}\r\nvoid\r\nintelfbhw_do_bitblt(struct intelfb_info *dinfo, u32 curx, u32 cury,\r\nu32 dstx, u32 dsty, u32 w, u32 h, u32 pitch, u32 bpp)\r\n{\r\nu32 br00, br09, br11, br12, br13, br22, br23, br26;\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfbhw_do_bitblt: (%d,%d)->(%d,%d) %dx%d, p %d bpp %d\n",\r\ncurx, cury, dstx, dsty, w, h, pitch, bpp);\r\n#endif\r\nbr00 = XY_SRC_COPY_BLT_CMD;\r\nbr09 = dinfo->fb_start;\r\nbr11 = (pitch << PITCH_SHIFT);\r\nbr12 = dinfo->fb_start;\r\nbr13 = (SRC_ROP_GXCOPY << ROP_SHIFT) | (pitch << PITCH_SHIFT);\r\nbr22 = (dstx << WIDTH_SHIFT) | (dsty << HEIGHT_SHIFT);\r\nbr23 = ((dstx + w) << WIDTH_SHIFT) |\r\n((dsty + h) << HEIGHT_SHIFT);\r\nbr26 = (curx << WIDTH_SHIFT) | (cury << HEIGHT_SHIFT);\r\nswitch (bpp) {\r\ncase 8:\r\nbr13 |= COLOR_DEPTH_8;\r\nbreak;\r\ncase 16:\r\nbr13 |= COLOR_DEPTH_16;\r\nbreak;\r\ncase 32:\r\nbr13 |= COLOR_DEPTH_32;\r\nbr00 |= WRITE_ALPHA | WRITE_RGB;\r\nbreak;\r\n}\r\nSTART_RING(8);\r\nOUT_RING(br00);\r\nOUT_RING(br13);\r\nOUT_RING(br22);\r\nOUT_RING(br23);\r\nOUT_RING(br09);\r\nOUT_RING(br26);\r\nOUT_RING(br11);\r\nOUT_RING(br12);\r\nADVANCE_RING();\r\n}\r\nint intelfbhw_do_drawglyph(struct intelfb_info *dinfo, u32 fg, u32 bg, u32 w,\r\nu32 h, const u8* cdat, u32 x, u32 y, u32 pitch,\r\nu32 bpp)\r\n{\r\nint nbytes, ndwords, pad, tmp;\r\nu32 br00, br09, br13, br18, br19, br22, br23;\r\nint dat, ix, iy, iw;\r\nint i, j;\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfbhw_do_drawglyph: (%d,%d) %dx%d\n", x, y, w, h);\r\n#endif\r\nnbytes = ROUND_UP_TO(w, 16) / 8;\r\nnbytes = nbytes * h;\r\nif (nbytes > MAX_MONO_IMM_SIZE)\r\nreturn 0;\r\nndwords = ROUND_UP_TO(nbytes, 4) / 4;\r\npad = !(ndwords % 2);\r\ntmp = (XY_MONO_SRC_IMM_BLT_CMD & DW_LENGTH_MASK) + ndwords;\r\nbr00 = (XY_MONO_SRC_IMM_BLT_CMD & ~DW_LENGTH_MASK) | tmp;\r\nbr09 = dinfo->fb_start;\r\nbr13 = (SRC_ROP_GXCOPY << ROP_SHIFT) | (pitch << PITCH_SHIFT);\r\nbr18 = bg;\r\nbr19 = fg;\r\nbr22 = (x << WIDTH_SHIFT) | (y << HEIGHT_SHIFT);\r\nbr23 = ((x + w) << WIDTH_SHIFT) | ((y + h) << HEIGHT_SHIFT);\r\nswitch (bpp) {\r\ncase 8:\r\nbr13 |= COLOR_DEPTH_8;\r\nbreak;\r\ncase 16:\r\nbr13 |= COLOR_DEPTH_16;\r\nbreak;\r\ncase 32:\r\nbr13 |= COLOR_DEPTH_32;\r\nbr00 |= WRITE_ALPHA | WRITE_RGB;\r\nbreak;\r\n}\r\nSTART_RING(8 + ndwords);\r\nOUT_RING(br00);\r\nOUT_RING(br13);\r\nOUT_RING(br22);\r\nOUT_RING(br23);\r\nOUT_RING(br09);\r\nOUT_RING(br18);\r\nOUT_RING(br19);\r\nix = iy = 0;\r\niw = ROUND_UP_TO(w, 8) / 8;\r\nwhile (ndwords--) {\r\ndat = 0;\r\nfor (j = 0; j < 2; ++j) {\r\nfor (i = 0; i < 2; ++i) {\r\nif (ix != iw || i == 0)\r\ndat |= cdat[iy*iw + ix++] << (i+j*2)*8;\r\n}\r\nif (ix == iw && iy != (h-1)) {\r\nix = 0;\r\n++iy;\r\n}\r\n}\r\nOUT_RING(dat);\r\n}\r\nif (pad)\r\nOUT_RING(MI_NOOP);\r\nADVANCE_RING();\r\nreturn 1;\r\n}\r\nvoid intelfbhw_cursor_init(struct intelfb_info *dinfo)\r\n{\r\nu32 tmp;\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfbhw_cursor_init\n");\r\n#endif\r\nif (dinfo->mobile || IS_I9XX(dinfo)) {\r\nif (!dinfo->cursor.physical)\r\nreturn;\r\ntmp = INREG(CURSOR_A_CONTROL);\r\ntmp &= ~(CURSOR_MODE_MASK | CURSOR_MOBILE_GAMMA_ENABLE |\r\nCURSOR_MEM_TYPE_LOCAL |\r\n(1 << CURSOR_PIPE_SELECT_SHIFT));\r\ntmp |= CURSOR_MODE_DISABLE;\r\nOUTREG(CURSOR_A_CONTROL, tmp);\r\nOUTREG(CURSOR_A_BASEADDR, dinfo->cursor.physical);\r\n} else {\r\ntmp = INREG(CURSOR_CONTROL);\r\ntmp &= ~(CURSOR_FORMAT_MASK | CURSOR_GAMMA_ENABLE |\r\nCURSOR_ENABLE | CURSOR_STRIDE_MASK);\r\ntmp |= CURSOR_FORMAT_3C;\r\nOUTREG(CURSOR_CONTROL, tmp);\r\nOUTREG(CURSOR_A_BASEADDR, dinfo->cursor.offset << 12);\r\ntmp = (64 << CURSOR_SIZE_H_SHIFT) |\r\n(64 << CURSOR_SIZE_V_SHIFT);\r\nOUTREG(CURSOR_SIZE, tmp);\r\n}\r\n}\r\nvoid intelfbhw_cursor_hide(struct intelfb_info *dinfo)\r\n{\r\nu32 tmp;\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfbhw_cursor_hide\n");\r\n#endif\r\ndinfo->cursor_on = 0;\r\nif (dinfo->mobile || IS_I9XX(dinfo)) {\r\nif (!dinfo->cursor.physical)\r\nreturn;\r\ntmp = INREG(CURSOR_A_CONTROL);\r\ntmp &= ~CURSOR_MODE_MASK;\r\ntmp |= CURSOR_MODE_DISABLE;\r\nOUTREG(CURSOR_A_CONTROL, tmp);\r\nOUTREG(CURSOR_A_BASEADDR, dinfo->cursor.physical);\r\n} else {\r\ntmp = INREG(CURSOR_CONTROL);\r\ntmp &= ~CURSOR_ENABLE;\r\nOUTREG(CURSOR_CONTROL, tmp);\r\n}\r\n}\r\nvoid intelfbhw_cursor_show(struct intelfb_info *dinfo)\r\n{\r\nu32 tmp;\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfbhw_cursor_show\n");\r\n#endif\r\ndinfo->cursor_on = 1;\r\nif (dinfo->cursor_blanked)\r\nreturn;\r\nif (dinfo->mobile || IS_I9XX(dinfo)) {\r\nif (!dinfo->cursor.physical)\r\nreturn;\r\ntmp = INREG(CURSOR_A_CONTROL);\r\ntmp &= ~CURSOR_MODE_MASK;\r\ntmp |= CURSOR_MODE_64_4C_AX;\r\nOUTREG(CURSOR_A_CONTROL, tmp);\r\nOUTREG(CURSOR_A_BASEADDR, dinfo->cursor.physical);\r\n} else {\r\ntmp = INREG(CURSOR_CONTROL);\r\ntmp |= CURSOR_ENABLE;\r\nOUTREG(CURSOR_CONTROL, tmp);\r\n}\r\n}\r\nvoid intelfbhw_cursor_setpos(struct intelfb_info *dinfo, int x, int y)\r\n{\r\nu32 tmp;\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfbhw_cursor_setpos: (%d, %d)\n", x, y);\r\n#endif\r\ntmp = ((x & CURSOR_POS_MASK) << CURSOR_X_SHIFT) |\r\n((y & CURSOR_POS_MASK) << CURSOR_Y_SHIFT);\r\nOUTREG(CURSOR_A_POSITION, tmp);\r\nif (IS_I9XX(dinfo))\r\nOUTREG(CURSOR_A_BASEADDR, dinfo->cursor.physical);\r\n}\r\nvoid intelfbhw_cursor_setcolor(struct intelfb_info *dinfo, u32 bg, u32 fg)\r\n{\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfbhw_cursor_setcolor\n");\r\n#endif\r\nOUTREG(CURSOR_A_PALETTE0, bg & CURSOR_PALETTE_MASK);\r\nOUTREG(CURSOR_A_PALETTE1, fg & CURSOR_PALETTE_MASK);\r\nOUTREG(CURSOR_A_PALETTE2, fg & CURSOR_PALETTE_MASK);\r\nOUTREG(CURSOR_A_PALETTE3, bg & CURSOR_PALETTE_MASK);\r\n}\r\nvoid intelfbhw_cursor_load(struct intelfb_info *dinfo, int width, int height,\r\nu8 *data)\r\n{\r\nu8 __iomem *addr = (u8 __iomem *)dinfo->cursor.virtual;\r\nint i, j, w = width / 8;\r\nint mod = width % 8, t_mask, d_mask;\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfbhw_cursor_load\n");\r\n#endif\r\nif (!dinfo->cursor.virtual)\r\nreturn;\r\nt_mask = 0xff >> mod;\r\nd_mask = ~(0xff >> mod);\r\nfor (i = height; i--; ) {\r\nfor (j = 0; j < w; j++) {\r\nwriteb(0x00, addr + j);\r\nwriteb(*(data++), addr + j+8);\r\n}\r\nif (mod) {\r\nwriteb(t_mask, addr + j);\r\nwriteb(*(data++) & d_mask, addr + j+8);\r\n}\r\naddr += 16;\r\n}\r\n}\r\nvoid intelfbhw_cursor_reset(struct intelfb_info *dinfo)\r\n{\r\nu8 __iomem *addr = (u8 __iomem *)dinfo->cursor.virtual;\r\nint i, j;\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfbhw_cursor_reset\n");\r\n#endif\r\nif (!dinfo->cursor.virtual)\r\nreturn;\r\nfor (i = 64; i--; ) {\r\nfor (j = 0; j < 8; j++) {\r\nwriteb(0xff, addr + j+0);\r\nwriteb(0x00, addr + j+8);\r\n}\r\naddr += 16;\r\n}\r\n}\r\nstatic irqreturn_t intelfbhw_irq(int irq, void *dev_id)\r\n{\r\nu16 tmp;\r\nstruct intelfb_info *dinfo = dev_id;\r\nspin_lock(&dinfo->int_lock);\r\ntmp = INREG16(IIR);\r\nif (dinfo->info->var.vmode & FB_VMODE_INTERLACED)\r\ntmp &= PIPE_A_EVENT_INTERRUPT;\r\nelse\r\ntmp &= VSYNC_PIPE_A_INTERRUPT;\r\nif (tmp == 0) {\r\nspin_unlock(&dinfo->int_lock);\r\nreturn IRQ_RETVAL(0);\r\n}\r\nOUTREG(PIPEASTAT, INREG(PIPEASTAT));\r\nOUTREG16(IIR, tmp);\r\nif (dinfo->vsync.pan_display) {\r\ndinfo->vsync.pan_display = 0;\r\nOUTREG(DSPABASE, dinfo->vsync.pan_offset);\r\n}\r\ndinfo->vsync.count++;\r\nwake_up_interruptible(&dinfo->vsync.wait);\r\nspin_unlock(&dinfo->int_lock);\r\nreturn IRQ_RETVAL(1);\r\n}\r\nint intelfbhw_enable_irq(struct intelfb_info *dinfo)\r\n{\r\nu16 tmp;\r\nif (!test_and_set_bit(0, &dinfo->irq_flags)) {\r\nif (request_irq(dinfo->pdev->irq, intelfbhw_irq, IRQF_SHARED,\r\n"intelfb", dinfo)) {\r\nclear_bit(0, &dinfo->irq_flags);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irq(&dinfo->int_lock);\r\nOUTREG16(HWSTAM, 0xfffe);\r\nOUTREG16(IMR, 0);\r\n} else\r\nspin_lock_irq(&dinfo->int_lock);\r\nif (dinfo->info->var.vmode & FB_VMODE_INTERLACED)\r\ntmp = PIPE_A_EVENT_INTERRUPT;\r\nelse\r\ntmp = VSYNC_PIPE_A_INTERRUPT;\r\nif (tmp != INREG16(IER)) {\r\nDBG_MSG("changing IER to 0x%X\n", tmp);\r\nOUTREG16(IER, tmp);\r\n}\r\nspin_unlock_irq(&dinfo->int_lock);\r\nreturn 0;\r\n}\r\nvoid intelfbhw_disable_irq(struct intelfb_info *dinfo)\r\n{\r\nif (test_and_clear_bit(0, &dinfo->irq_flags)) {\r\nif (dinfo->vsync.pan_display) {\r\ndinfo->vsync.pan_display = 0;\r\nOUTREG(DSPABASE, dinfo->vsync.pan_offset);\r\n}\r\nspin_lock_irq(&dinfo->int_lock);\r\nOUTREG16(HWSTAM, 0xffff);\r\nOUTREG16(IMR, 0xffff);\r\nOUTREG16(IER, 0x0);\r\nOUTREG16(IIR, INREG16(IIR));\r\nspin_unlock_irq(&dinfo->int_lock);\r\nfree_irq(dinfo->pdev->irq, dinfo);\r\n}\r\n}\r\nint intelfbhw_wait_for_vsync(struct intelfb_info *dinfo, u32 pipe)\r\n{\r\nstruct intelfb_vsync *vsync;\r\nunsigned int count;\r\nint ret;\r\nswitch (pipe) {\r\ncase 0:\r\nvsync = &dinfo->vsync;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nret = intelfbhw_enable_irq(dinfo);\r\nif (ret)\r\nreturn ret;\r\ncount = vsync->count;\r\nret = wait_event_interruptible_timeout(vsync->wait,\r\ncount != vsync->count, HZ / 10);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret == 0) {\r\nDBG_MSG("wait_for_vsync timed out!\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}
