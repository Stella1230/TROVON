static inline int mlx5e_hash_eth_addr(u8 *addr)\r\n{\r\nreturn addr[5];\r\n}\r\nstatic void mlx5e_add_eth_addr_to_hash(struct hlist_head *hash, u8 *addr)\r\n{\r\nstruct mlx5e_eth_addr_hash_node *hn;\r\nint ix = mlx5e_hash_eth_addr(addr);\r\nint found = 0;\r\nhlist_for_each_entry(hn, &hash[ix], hlist)\r\nif (ether_addr_equal_64bits(hn->ai.addr, addr)) {\r\nfound = 1;\r\nbreak;\r\n}\r\nif (found) {\r\nhn->action = MLX5E_ACTION_NONE;\r\nreturn;\r\n}\r\nhn = kzalloc(sizeof(*hn), GFP_ATOMIC);\r\nif (!hn)\r\nreturn;\r\nether_addr_copy(hn->ai.addr, addr);\r\nhn->action = MLX5E_ACTION_ADD;\r\nhlist_add_head(&hn->hlist, &hash[ix]);\r\n}\r\nstatic void mlx5e_del_eth_addr_from_hash(struct mlx5e_eth_addr_hash_node *hn)\r\n{\r\nhlist_del(&hn->hlist);\r\nkfree(hn);\r\n}\r\nstatic void mlx5e_del_eth_addr_from_flow_table(struct mlx5e_priv *priv,\r\nstruct mlx5e_eth_addr_info *ai)\r\n{\r\nvoid *ft = priv->ft.main;\r\nif (ai->tt_vec & BIT(MLX5E_TT_IPV6_IPSEC_ESP))\r\nmlx5_del_flow_table_entry(ft,\r\nai->ft_ix[MLX5E_TT_IPV6_IPSEC_ESP]);\r\nif (ai->tt_vec & BIT(MLX5E_TT_IPV4_IPSEC_ESP))\r\nmlx5_del_flow_table_entry(ft,\r\nai->ft_ix[MLX5E_TT_IPV4_IPSEC_ESP]);\r\nif (ai->tt_vec & BIT(MLX5E_TT_IPV6_IPSEC_AH))\r\nmlx5_del_flow_table_entry(ft,\r\nai->ft_ix[MLX5E_TT_IPV6_IPSEC_AH]);\r\nif (ai->tt_vec & BIT(MLX5E_TT_IPV4_IPSEC_AH))\r\nmlx5_del_flow_table_entry(ft,\r\nai->ft_ix[MLX5E_TT_IPV4_IPSEC_AH]);\r\nif (ai->tt_vec & BIT(MLX5E_TT_IPV6_TCP))\r\nmlx5_del_flow_table_entry(ft, ai->ft_ix[MLX5E_TT_IPV6_TCP]);\r\nif (ai->tt_vec & BIT(MLX5E_TT_IPV4_TCP))\r\nmlx5_del_flow_table_entry(ft, ai->ft_ix[MLX5E_TT_IPV4_TCP]);\r\nif (ai->tt_vec & BIT(MLX5E_TT_IPV6_UDP))\r\nmlx5_del_flow_table_entry(ft, ai->ft_ix[MLX5E_TT_IPV6_UDP]);\r\nif (ai->tt_vec & BIT(MLX5E_TT_IPV4_UDP))\r\nmlx5_del_flow_table_entry(ft, ai->ft_ix[MLX5E_TT_IPV4_UDP]);\r\nif (ai->tt_vec & BIT(MLX5E_TT_IPV6))\r\nmlx5_del_flow_table_entry(ft, ai->ft_ix[MLX5E_TT_IPV6]);\r\nif (ai->tt_vec & BIT(MLX5E_TT_IPV4))\r\nmlx5_del_flow_table_entry(ft, ai->ft_ix[MLX5E_TT_IPV4]);\r\nif (ai->tt_vec & BIT(MLX5E_TT_ANY))\r\nmlx5_del_flow_table_entry(ft, ai->ft_ix[MLX5E_TT_ANY]);\r\n}\r\nstatic int mlx5e_get_eth_addr_type(u8 *addr)\r\n{\r\nif (is_unicast_ether_addr(addr))\r\nreturn MLX5E_UC;\r\nif ((addr[0] == 0x01) &&\r\n(addr[1] == 0x00) &&\r\n(addr[2] == 0x5e) &&\r\n!(addr[3] & 0x80))\r\nreturn MLX5E_MC_IPV4;\r\nif ((addr[0] == 0x33) &&\r\n(addr[1] == 0x33))\r\nreturn MLX5E_MC_IPV6;\r\nreturn MLX5E_MC_OTHER;\r\n}\r\nstatic u32 mlx5e_get_tt_vec(struct mlx5e_eth_addr_info *ai, int type)\r\n{\r\nint eth_addr_type;\r\nu32 ret;\r\nswitch (type) {\r\ncase MLX5E_FULLMATCH:\r\neth_addr_type = mlx5e_get_eth_addr_type(ai->addr);\r\nswitch (eth_addr_type) {\r\ncase MLX5E_UC:\r\nret =\r\nBIT(MLX5E_TT_IPV4_TCP) |\r\nBIT(MLX5E_TT_IPV6_TCP) |\r\nBIT(MLX5E_TT_IPV4_UDP) |\r\nBIT(MLX5E_TT_IPV6_UDP) |\r\nBIT(MLX5E_TT_IPV4_IPSEC_AH) |\r\nBIT(MLX5E_TT_IPV6_IPSEC_AH) |\r\nBIT(MLX5E_TT_IPV4_IPSEC_ESP) |\r\nBIT(MLX5E_TT_IPV6_IPSEC_ESP) |\r\nBIT(MLX5E_TT_IPV4) |\r\nBIT(MLX5E_TT_IPV6) |\r\nBIT(MLX5E_TT_ANY) |\r\n0;\r\nbreak;\r\ncase MLX5E_MC_IPV4:\r\nret =\r\nBIT(MLX5E_TT_IPV4_UDP) |\r\nBIT(MLX5E_TT_IPV4) |\r\n0;\r\nbreak;\r\ncase MLX5E_MC_IPV6:\r\nret =\r\nBIT(MLX5E_TT_IPV6_UDP) |\r\nBIT(MLX5E_TT_IPV6) |\r\n0;\r\nbreak;\r\ncase MLX5E_MC_OTHER:\r\nret =\r\nBIT(MLX5E_TT_ANY) |\r\n0;\r\nbreak;\r\n}\r\nbreak;\r\ncase MLX5E_ALLMULTI:\r\nret =\r\nBIT(MLX5E_TT_IPV4_UDP) |\r\nBIT(MLX5E_TT_IPV6_UDP) |\r\nBIT(MLX5E_TT_IPV4) |\r\nBIT(MLX5E_TT_IPV6) |\r\nBIT(MLX5E_TT_ANY) |\r\n0;\r\nbreak;\r\ndefault:\r\nret =\r\nBIT(MLX5E_TT_IPV4_TCP) |\r\nBIT(MLX5E_TT_IPV6_TCP) |\r\nBIT(MLX5E_TT_IPV4_UDP) |\r\nBIT(MLX5E_TT_IPV6_UDP) |\r\nBIT(MLX5E_TT_IPV4_IPSEC_AH) |\r\nBIT(MLX5E_TT_IPV6_IPSEC_AH) |\r\nBIT(MLX5E_TT_IPV4_IPSEC_ESP) |\r\nBIT(MLX5E_TT_IPV6_IPSEC_ESP) |\r\nBIT(MLX5E_TT_IPV4) |\r\nBIT(MLX5E_TT_IPV6) |\r\nBIT(MLX5E_TT_ANY) |\r\n0;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __mlx5e_add_eth_addr_rule(struct mlx5e_priv *priv,\r\nstruct mlx5e_eth_addr_info *ai, int type,\r\nvoid *flow_context, void *match_criteria)\r\n{\r\nu8 match_criteria_enable = 0;\r\nvoid *match_value;\r\nvoid *dest;\r\nu8 *dmac;\r\nu8 *match_criteria_dmac;\r\nvoid *ft = priv->ft.main;\r\nu32 *tirn = priv->tirn;\r\nu32 *ft_ix;\r\nu32 tt_vec;\r\nint err;\r\nmatch_value = MLX5_ADDR_OF(flow_context, flow_context, match_value);\r\ndmac = MLX5_ADDR_OF(fte_match_param, match_value,\r\nouter_headers.dmac_47_16);\r\nmatch_criteria_dmac = MLX5_ADDR_OF(fte_match_param, match_criteria,\r\nouter_headers.dmac_47_16);\r\ndest = MLX5_ADDR_OF(flow_context, flow_context, destination);\r\nMLX5_SET(flow_context, flow_context, action,\r\nMLX5_FLOW_CONTEXT_ACTION_FWD_DEST);\r\nMLX5_SET(flow_context, flow_context, destination_list_size, 1);\r\nMLX5_SET(dest_format_struct, dest, destination_type,\r\nMLX5_FLOW_CONTEXT_DEST_TYPE_TIR);\r\nswitch (type) {\r\ncase MLX5E_FULLMATCH:\r\nmatch_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\r\nmemset(match_criteria_dmac, 0xff, ETH_ALEN);\r\nether_addr_copy(dmac, ai->addr);\r\nbreak;\r\ncase MLX5E_ALLMULTI:\r\nmatch_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\r\nmatch_criteria_dmac[0] = 0x01;\r\ndmac[0] = 0x01;\r\nbreak;\r\ncase MLX5E_PROMISC:\r\nbreak;\r\n}\r\ntt_vec = mlx5e_get_tt_vec(ai, type);\r\nft_ix = &ai->ft_ix[MLX5E_TT_ANY];\r\nif (tt_vec & BIT(MLX5E_TT_ANY)) {\r\nMLX5_SET(dest_format_struct, dest, destination_id,\r\ntirn[MLX5E_TT_ANY]);\r\nerr = mlx5_add_flow_table_entry(ft, match_criteria_enable,\r\nmatch_criteria, flow_context,\r\nft_ix);\r\nif (err)\r\ngoto err_del_ai;\r\nai->tt_vec |= BIT(MLX5E_TT_ANY);\r\n}\r\nmatch_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\r\nMLX5_SET_TO_ONES(fte_match_param, match_criteria,\r\nouter_headers.ethertype);\r\nft_ix = &ai->ft_ix[MLX5E_TT_IPV4];\r\nif (tt_vec & BIT(MLX5E_TT_IPV4)) {\r\nMLX5_SET(fte_match_param, match_value, outer_headers.ethertype,\r\nETH_P_IP);\r\nMLX5_SET(dest_format_struct, dest, destination_id,\r\ntirn[MLX5E_TT_IPV4]);\r\nerr = mlx5_add_flow_table_entry(ft, match_criteria_enable,\r\nmatch_criteria, flow_context,\r\nft_ix);\r\nif (err)\r\ngoto err_del_ai;\r\nai->tt_vec |= BIT(MLX5E_TT_IPV4);\r\n}\r\nft_ix = &ai->ft_ix[MLX5E_TT_IPV6];\r\nif (tt_vec & BIT(MLX5E_TT_IPV6)) {\r\nMLX5_SET(fte_match_param, match_value, outer_headers.ethertype,\r\nETH_P_IPV6);\r\nMLX5_SET(dest_format_struct, dest, destination_id,\r\ntirn[MLX5E_TT_IPV6]);\r\nerr = mlx5_add_flow_table_entry(ft, match_criteria_enable,\r\nmatch_criteria, flow_context,\r\nft_ix);\r\nif (err)\r\ngoto err_del_ai;\r\nai->tt_vec |= BIT(MLX5E_TT_IPV6);\r\n}\r\nMLX5_SET_TO_ONES(fte_match_param, match_criteria,\r\nouter_headers.ip_protocol);\r\nMLX5_SET(fte_match_param, match_value, outer_headers.ip_protocol,\r\nIPPROTO_UDP);\r\nft_ix = &ai->ft_ix[MLX5E_TT_IPV4_UDP];\r\nif (tt_vec & BIT(MLX5E_TT_IPV4_UDP)) {\r\nMLX5_SET(fte_match_param, match_value, outer_headers.ethertype,\r\nETH_P_IP);\r\nMLX5_SET(dest_format_struct, dest, destination_id,\r\ntirn[MLX5E_TT_IPV4_UDP]);\r\nerr = mlx5_add_flow_table_entry(ft, match_criteria_enable,\r\nmatch_criteria, flow_context,\r\nft_ix);\r\nif (err)\r\ngoto err_del_ai;\r\nai->tt_vec |= BIT(MLX5E_TT_IPV4_UDP);\r\n}\r\nft_ix = &ai->ft_ix[MLX5E_TT_IPV6_UDP];\r\nif (tt_vec & BIT(MLX5E_TT_IPV6_UDP)) {\r\nMLX5_SET(fte_match_param, match_value, outer_headers.ethertype,\r\nETH_P_IPV6);\r\nMLX5_SET(dest_format_struct, dest, destination_id,\r\ntirn[MLX5E_TT_IPV6_UDP]);\r\nerr = mlx5_add_flow_table_entry(ft, match_criteria_enable,\r\nmatch_criteria, flow_context,\r\nft_ix);\r\nif (err)\r\ngoto err_del_ai;\r\nai->tt_vec |= BIT(MLX5E_TT_IPV6_UDP);\r\n}\r\nMLX5_SET(fte_match_param, match_value, outer_headers.ip_protocol,\r\nIPPROTO_TCP);\r\nft_ix = &ai->ft_ix[MLX5E_TT_IPV4_TCP];\r\nif (tt_vec & BIT(MLX5E_TT_IPV4_TCP)) {\r\nMLX5_SET(fte_match_param, match_value, outer_headers.ethertype,\r\nETH_P_IP);\r\nMLX5_SET(dest_format_struct, dest, destination_id,\r\ntirn[MLX5E_TT_IPV4_TCP]);\r\nerr = mlx5_add_flow_table_entry(ft, match_criteria_enable,\r\nmatch_criteria, flow_context,\r\nft_ix);\r\nif (err)\r\ngoto err_del_ai;\r\nai->tt_vec |= BIT(MLX5E_TT_IPV4_TCP);\r\n}\r\nft_ix = &ai->ft_ix[MLX5E_TT_IPV6_TCP];\r\nif (tt_vec & BIT(MLX5E_TT_IPV6_TCP)) {\r\nMLX5_SET(fte_match_param, match_value, outer_headers.ethertype,\r\nETH_P_IPV6);\r\nMLX5_SET(dest_format_struct, dest, destination_id,\r\ntirn[MLX5E_TT_IPV6_TCP]);\r\nerr = mlx5_add_flow_table_entry(ft, match_criteria_enable,\r\nmatch_criteria, flow_context,\r\nft_ix);\r\nif (err)\r\ngoto err_del_ai;\r\nai->tt_vec |= BIT(MLX5E_TT_IPV6_TCP);\r\n}\r\nMLX5_SET(fte_match_param, match_value, outer_headers.ip_protocol,\r\nIPPROTO_AH);\r\nft_ix = &ai->ft_ix[MLX5E_TT_IPV4_IPSEC_AH];\r\nif (tt_vec & BIT(MLX5E_TT_IPV4_IPSEC_AH)) {\r\nMLX5_SET(fte_match_param, match_value, outer_headers.ethertype,\r\nETH_P_IP);\r\nMLX5_SET(dest_format_struct, dest, destination_id,\r\ntirn[MLX5E_TT_IPV4_IPSEC_AH]);\r\nerr = mlx5_add_flow_table_entry(ft, match_criteria_enable,\r\nmatch_criteria, flow_context,\r\nft_ix);\r\nif (err)\r\ngoto err_del_ai;\r\nai->tt_vec |= BIT(MLX5E_TT_IPV4_IPSEC_AH);\r\n}\r\nft_ix = &ai->ft_ix[MLX5E_TT_IPV6_IPSEC_AH];\r\nif (tt_vec & BIT(MLX5E_TT_IPV6_IPSEC_AH)) {\r\nMLX5_SET(fte_match_param, match_value, outer_headers.ethertype,\r\nETH_P_IPV6);\r\nMLX5_SET(dest_format_struct, dest, destination_id,\r\ntirn[MLX5E_TT_IPV6_IPSEC_AH]);\r\nerr = mlx5_add_flow_table_entry(ft, match_criteria_enable,\r\nmatch_criteria, flow_context,\r\nft_ix);\r\nif (err)\r\ngoto err_del_ai;\r\nai->tt_vec |= BIT(MLX5E_TT_IPV6_IPSEC_AH);\r\n}\r\nMLX5_SET(fte_match_param, match_value, outer_headers.ip_protocol,\r\nIPPROTO_ESP);\r\nft_ix = &ai->ft_ix[MLX5E_TT_IPV4_IPSEC_ESP];\r\nif (tt_vec & BIT(MLX5E_TT_IPV4_IPSEC_ESP)) {\r\nMLX5_SET(fte_match_param, match_value, outer_headers.ethertype,\r\nETH_P_IP);\r\nMLX5_SET(dest_format_struct, dest, destination_id,\r\ntirn[MLX5E_TT_IPV4_IPSEC_ESP]);\r\nerr = mlx5_add_flow_table_entry(ft, match_criteria_enable,\r\nmatch_criteria, flow_context,\r\nft_ix);\r\nif (err)\r\ngoto err_del_ai;\r\nai->tt_vec |= BIT(MLX5E_TT_IPV4_IPSEC_ESP);\r\n}\r\nft_ix = &ai->ft_ix[MLX5E_TT_IPV6_IPSEC_ESP];\r\nif (tt_vec & BIT(MLX5E_TT_IPV6_IPSEC_ESP)) {\r\nMLX5_SET(fte_match_param, match_value, outer_headers.ethertype,\r\nETH_P_IPV6);\r\nMLX5_SET(dest_format_struct, dest, destination_id,\r\ntirn[MLX5E_TT_IPV6_IPSEC_ESP]);\r\nerr = mlx5_add_flow_table_entry(ft, match_criteria_enable,\r\nmatch_criteria, flow_context,\r\nft_ix);\r\nif (err)\r\ngoto err_del_ai;\r\nai->tt_vec |= BIT(MLX5E_TT_IPV6_IPSEC_ESP);\r\n}\r\nreturn 0;\r\nerr_del_ai:\r\nmlx5e_del_eth_addr_from_flow_table(priv, ai);\r\nreturn err;\r\n}\r\nstatic int mlx5e_add_eth_addr_rule(struct mlx5e_priv *priv,\r\nstruct mlx5e_eth_addr_info *ai, int type)\r\n{\r\nu32 *flow_context;\r\nu32 *match_criteria;\r\nint err;\r\nflow_context = mlx5_vzalloc(MLX5_ST_SZ_BYTES(flow_context) +\r\nMLX5_ST_SZ_BYTES(dest_format_struct));\r\nmatch_criteria = mlx5_vzalloc(MLX5_ST_SZ_BYTES(fte_match_param));\r\nif (!flow_context || !match_criteria) {\r\nnetdev_err(priv->netdev, "%s: alloc failed\n", __func__);\r\nerr = -ENOMEM;\r\ngoto add_eth_addr_rule_out;\r\n}\r\nerr = __mlx5e_add_eth_addr_rule(priv, ai, type, flow_context,\r\nmatch_criteria);\r\nif (err)\r\nnetdev_err(priv->netdev, "%s: failed\n", __func__);\r\nadd_eth_addr_rule_out:\r\nkvfree(match_criteria);\r\nkvfree(flow_context);\r\nreturn err;\r\n}\r\nstatic int mlx5e_add_vlan_rule(struct mlx5e_priv *priv,\r\nenum mlx5e_vlan_rule_type rule_type, u16 vid)\r\n{\r\nu8 match_criteria_enable = 0;\r\nu32 *flow_context;\r\nvoid *match_value;\r\nvoid *dest;\r\nu32 *match_criteria;\r\nu32 *ft_ix;\r\nint err;\r\nflow_context = mlx5_vzalloc(MLX5_ST_SZ_BYTES(flow_context) +\r\nMLX5_ST_SZ_BYTES(dest_format_struct));\r\nmatch_criteria = mlx5_vzalloc(MLX5_ST_SZ_BYTES(fte_match_param));\r\nif (!flow_context || !match_criteria) {\r\nnetdev_err(priv->netdev, "%s: alloc failed\n", __func__);\r\nerr = -ENOMEM;\r\ngoto add_vlan_rule_out;\r\n}\r\nmatch_value = MLX5_ADDR_OF(flow_context, flow_context, match_value);\r\ndest = MLX5_ADDR_OF(flow_context, flow_context, destination);\r\nMLX5_SET(flow_context, flow_context, action,\r\nMLX5_FLOW_CONTEXT_ACTION_FWD_DEST);\r\nMLX5_SET(flow_context, flow_context, destination_list_size, 1);\r\nMLX5_SET(dest_format_struct, dest, destination_type,\r\nMLX5_FLOW_CONTEXT_DEST_TYPE_FLOW_TABLE);\r\nMLX5_SET(dest_format_struct, dest, destination_id,\r\nmlx5_get_flow_table_id(priv->ft.main));\r\nmatch_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\r\nMLX5_SET_TO_ONES(fte_match_param, match_criteria,\r\nouter_headers.vlan_tag);\r\nswitch (rule_type) {\r\ncase MLX5E_VLAN_RULE_TYPE_UNTAGGED:\r\nft_ix = &priv->vlan.untagged_rule_ft_ix;\r\nbreak;\r\ncase MLX5E_VLAN_RULE_TYPE_ANY_VID:\r\nft_ix = &priv->vlan.any_vlan_rule_ft_ix;\r\nMLX5_SET(fte_match_param, match_value, outer_headers.vlan_tag,\r\n1);\r\nbreak;\r\ndefault:\r\nft_ix = &priv->vlan.active_vlans_ft_ix[vid];\r\nMLX5_SET(fte_match_param, match_value, outer_headers.vlan_tag,\r\n1);\r\nMLX5_SET_TO_ONES(fte_match_param, match_criteria,\r\nouter_headers.first_vid);\r\nMLX5_SET(fte_match_param, match_value, outer_headers.first_vid,\r\nvid);\r\nbreak;\r\n}\r\nerr = mlx5_add_flow_table_entry(priv->ft.vlan, match_criteria_enable,\r\nmatch_criteria, flow_context, ft_ix);\r\nif (err)\r\nnetdev_err(priv->netdev, "%s: failed\n", __func__);\r\nadd_vlan_rule_out:\r\nkvfree(match_criteria);\r\nkvfree(flow_context);\r\nreturn err;\r\n}\r\nstatic void mlx5e_del_vlan_rule(struct mlx5e_priv *priv,\r\nenum mlx5e_vlan_rule_type rule_type, u16 vid)\r\n{\r\nswitch (rule_type) {\r\ncase MLX5E_VLAN_RULE_TYPE_UNTAGGED:\r\nmlx5_del_flow_table_entry(priv->ft.vlan,\r\npriv->vlan.untagged_rule_ft_ix);\r\nbreak;\r\ncase MLX5E_VLAN_RULE_TYPE_ANY_VID:\r\nmlx5_del_flow_table_entry(priv->ft.vlan,\r\npriv->vlan.any_vlan_rule_ft_ix);\r\nbreak;\r\ncase MLX5E_VLAN_RULE_TYPE_MATCH_VID:\r\nmlx5_del_flow_table_entry(priv->ft.vlan,\r\npriv->vlan.active_vlans_ft_ix[vid]);\r\nbreak;\r\n}\r\n}\r\nvoid mlx5e_enable_vlan_filter(struct mlx5e_priv *priv)\r\n{\r\nif (!priv->vlan.filter_disabled)\r\nreturn;\r\npriv->vlan.filter_disabled = false;\r\nif (priv->netdev->flags & IFF_PROMISC)\r\nreturn;\r\nmlx5e_del_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_ANY_VID, 0);\r\n}\r\nvoid mlx5e_disable_vlan_filter(struct mlx5e_priv *priv)\r\n{\r\nif (priv->vlan.filter_disabled)\r\nreturn;\r\npriv->vlan.filter_disabled = true;\r\nif (priv->netdev->flags & IFF_PROMISC)\r\nreturn;\r\nmlx5e_add_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_ANY_VID, 0);\r\n}\r\nint mlx5e_vlan_rx_add_vid(struct net_device *dev, __always_unused __be16 proto,\r\nu16 vid)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(dev);\r\nreturn mlx5e_add_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_MATCH_VID, vid);\r\n}\r\nint mlx5e_vlan_rx_kill_vid(struct net_device *dev, __always_unused __be16 proto,\r\nu16 vid)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(dev);\r\nmlx5e_del_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_MATCH_VID, vid);\r\nreturn 0;\r\n}\r\nstatic void mlx5e_execute_action(struct mlx5e_priv *priv,\r\nstruct mlx5e_eth_addr_hash_node *hn)\r\n{\r\nswitch (hn->action) {\r\ncase MLX5E_ACTION_ADD:\r\nmlx5e_add_eth_addr_rule(priv, &hn->ai, MLX5E_FULLMATCH);\r\nhn->action = MLX5E_ACTION_NONE;\r\nbreak;\r\ncase MLX5E_ACTION_DEL:\r\nmlx5e_del_eth_addr_from_flow_table(priv, &hn->ai);\r\nmlx5e_del_eth_addr_from_hash(hn);\r\nbreak;\r\n}\r\n}\r\nstatic void mlx5e_sync_netdev_addr(struct mlx5e_priv *priv)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nstruct netdev_hw_addr *ha;\r\nnetif_addr_lock_bh(netdev);\r\nmlx5e_add_eth_addr_to_hash(priv->eth_addr.netdev_uc,\r\npriv->netdev->dev_addr);\r\nnetdev_for_each_uc_addr(ha, netdev)\r\nmlx5e_add_eth_addr_to_hash(priv->eth_addr.netdev_uc, ha->addr);\r\nnetdev_for_each_mc_addr(ha, netdev)\r\nmlx5e_add_eth_addr_to_hash(priv->eth_addr.netdev_mc, ha->addr);\r\nnetif_addr_unlock_bh(netdev);\r\n}\r\nstatic void mlx5e_apply_netdev_addr(struct mlx5e_priv *priv)\r\n{\r\nstruct mlx5e_eth_addr_hash_node *hn;\r\nstruct hlist_node *tmp;\r\nint i;\r\nmlx5e_for_each_hash_node(hn, tmp, priv->eth_addr.netdev_uc, i)\r\nmlx5e_execute_action(priv, hn);\r\nmlx5e_for_each_hash_node(hn, tmp, priv->eth_addr.netdev_mc, i)\r\nmlx5e_execute_action(priv, hn);\r\n}\r\nstatic void mlx5e_handle_netdev_addr(struct mlx5e_priv *priv)\r\n{\r\nstruct mlx5e_eth_addr_hash_node *hn;\r\nstruct hlist_node *tmp;\r\nint i;\r\nmlx5e_for_each_hash_node(hn, tmp, priv->eth_addr.netdev_uc, i)\r\nhn->action = MLX5E_ACTION_DEL;\r\nmlx5e_for_each_hash_node(hn, tmp, priv->eth_addr.netdev_mc, i)\r\nhn->action = MLX5E_ACTION_DEL;\r\nif (!test_bit(MLX5E_STATE_DESTROYING, &priv->state))\r\nmlx5e_sync_netdev_addr(priv);\r\nmlx5e_apply_netdev_addr(priv);\r\n}\r\nvoid mlx5e_set_rx_mode_work(struct work_struct *work)\r\n{\r\nstruct mlx5e_priv *priv = container_of(work, struct mlx5e_priv,\r\nset_rx_mode_work);\r\nstruct mlx5e_eth_addr_db *ea = &priv->eth_addr;\r\nstruct net_device *ndev = priv->netdev;\r\nbool rx_mode_enable = !test_bit(MLX5E_STATE_DESTROYING, &priv->state);\r\nbool promisc_enabled = rx_mode_enable && (ndev->flags & IFF_PROMISC);\r\nbool allmulti_enabled = rx_mode_enable && (ndev->flags & IFF_ALLMULTI);\r\nbool broadcast_enabled = rx_mode_enable;\r\nbool enable_promisc = !ea->promisc_enabled && promisc_enabled;\r\nbool disable_promisc = ea->promisc_enabled && !promisc_enabled;\r\nbool enable_allmulti = !ea->allmulti_enabled && allmulti_enabled;\r\nbool disable_allmulti = ea->allmulti_enabled && !allmulti_enabled;\r\nbool enable_broadcast = !ea->broadcast_enabled && broadcast_enabled;\r\nbool disable_broadcast = ea->broadcast_enabled && !broadcast_enabled;\r\nif (enable_promisc) {\r\nmlx5e_add_eth_addr_rule(priv, &ea->promisc, MLX5E_PROMISC);\r\nif (!priv->vlan.filter_disabled)\r\nmlx5e_add_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_ANY_VID,\r\n0);\r\n}\r\nif (enable_allmulti)\r\nmlx5e_add_eth_addr_rule(priv, &ea->allmulti, MLX5E_ALLMULTI);\r\nif (enable_broadcast)\r\nmlx5e_add_eth_addr_rule(priv, &ea->broadcast, MLX5E_FULLMATCH);\r\nmlx5e_handle_netdev_addr(priv);\r\nif (disable_broadcast)\r\nmlx5e_del_eth_addr_from_flow_table(priv, &ea->broadcast);\r\nif (disable_allmulti)\r\nmlx5e_del_eth_addr_from_flow_table(priv, &ea->allmulti);\r\nif (disable_promisc) {\r\nif (!priv->vlan.filter_disabled)\r\nmlx5e_del_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_ANY_VID,\r\n0);\r\nmlx5e_del_eth_addr_from_flow_table(priv, &ea->promisc);\r\n}\r\nea->promisc_enabled = promisc_enabled;\r\nea->allmulti_enabled = allmulti_enabled;\r\nea->broadcast_enabled = broadcast_enabled;\r\n}\r\nvoid mlx5e_init_eth_addr(struct mlx5e_priv *priv)\r\n{\r\nether_addr_copy(priv->eth_addr.broadcast.addr, priv->netdev->broadcast);\r\n}\r\nstatic int mlx5e_create_main_flow_table(struct mlx5e_priv *priv)\r\n{\r\nstruct mlx5_flow_table_group *g;\r\nu8 *dmac;\r\ng = kcalloc(9, sizeof(*g), GFP_KERNEL);\r\nif (!g)\r\nreturn -ENOMEM;\r\ng[0].log_sz = 3;\r\ng[0].match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\r\nMLX5_SET_TO_ONES(fte_match_param, g[0].match_criteria,\r\nouter_headers.ethertype);\r\nMLX5_SET_TO_ONES(fte_match_param, g[0].match_criteria,\r\nouter_headers.ip_protocol);\r\ng[1].log_sz = 1;\r\ng[1].match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\r\nMLX5_SET_TO_ONES(fte_match_param, g[1].match_criteria,\r\nouter_headers.ethertype);\r\ng[2].log_sz = 0;\r\ng[3].log_sz = 14;\r\ng[3].match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\r\ndmac = MLX5_ADDR_OF(fte_match_param, g[3].match_criteria,\r\nouter_headers.dmac_47_16);\r\nmemset(dmac, 0xff, ETH_ALEN);\r\nMLX5_SET_TO_ONES(fte_match_param, g[3].match_criteria,\r\nouter_headers.ethertype);\r\nMLX5_SET_TO_ONES(fte_match_param, g[3].match_criteria,\r\nouter_headers.ip_protocol);\r\ng[4].log_sz = 13;\r\ng[4].match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\r\ndmac = MLX5_ADDR_OF(fte_match_param, g[4].match_criteria,\r\nouter_headers.dmac_47_16);\r\nmemset(dmac, 0xff, ETH_ALEN);\r\nMLX5_SET_TO_ONES(fte_match_param, g[4].match_criteria,\r\nouter_headers.ethertype);\r\ng[5].log_sz = 11;\r\ng[5].match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\r\ndmac = MLX5_ADDR_OF(fte_match_param, g[5].match_criteria,\r\nouter_headers.dmac_47_16);\r\nmemset(dmac, 0xff, ETH_ALEN);\r\ng[6].log_sz = 2;\r\ng[6].match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\r\ndmac = MLX5_ADDR_OF(fte_match_param, g[6].match_criteria,\r\nouter_headers.dmac_47_16);\r\ndmac[0] = 0x01;\r\nMLX5_SET_TO_ONES(fte_match_param, g[6].match_criteria,\r\nouter_headers.ethertype);\r\nMLX5_SET_TO_ONES(fte_match_param, g[6].match_criteria,\r\nouter_headers.ip_protocol);\r\ng[7].log_sz = 1;\r\ng[7].match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\r\ndmac = MLX5_ADDR_OF(fte_match_param, g[7].match_criteria,\r\nouter_headers.dmac_47_16);\r\ndmac[0] = 0x01;\r\nMLX5_SET_TO_ONES(fte_match_param, g[7].match_criteria,\r\nouter_headers.ethertype);\r\ng[8].log_sz = 0;\r\ng[8].match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\r\ndmac = MLX5_ADDR_OF(fte_match_param, g[8].match_criteria,\r\nouter_headers.dmac_47_16);\r\ndmac[0] = 0x01;\r\npriv->ft.main = mlx5_create_flow_table(priv->mdev, 1,\r\nMLX5_FLOW_TABLE_TYPE_NIC_RCV,\r\n9, g);\r\nkfree(g);\r\nreturn priv->ft.main ? 0 : -ENOMEM;\r\n}\r\nstatic void mlx5e_destroy_main_flow_table(struct mlx5e_priv *priv)\r\n{\r\nmlx5_destroy_flow_table(priv->ft.main);\r\n}\r\nstatic int mlx5e_create_vlan_flow_table(struct mlx5e_priv *priv)\r\n{\r\nstruct mlx5_flow_table_group *g;\r\ng = kcalloc(2, sizeof(*g), GFP_KERNEL);\r\nif (!g)\r\nreturn -ENOMEM;\r\ng[0].log_sz = 12;\r\ng[0].match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\r\nMLX5_SET_TO_ONES(fte_match_param, g[0].match_criteria,\r\nouter_headers.vlan_tag);\r\nMLX5_SET_TO_ONES(fte_match_param, g[0].match_criteria,\r\nouter_headers.first_vid);\r\ng[1].log_sz = 1;\r\ng[1].match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\r\nMLX5_SET_TO_ONES(fte_match_param, g[1].match_criteria,\r\nouter_headers.vlan_tag);\r\npriv->ft.vlan = mlx5_create_flow_table(priv->mdev, 0,\r\nMLX5_FLOW_TABLE_TYPE_NIC_RCV,\r\n2, g);\r\nkfree(g);\r\nreturn priv->ft.vlan ? 0 : -ENOMEM;\r\n}\r\nstatic void mlx5e_destroy_vlan_flow_table(struct mlx5e_priv *priv)\r\n{\r\nmlx5_destroy_flow_table(priv->ft.vlan);\r\n}\r\nint mlx5e_create_flow_tables(struct mlx5e_priv *priv)\r\n{\r\nint err;\r\nerr = mlx5e_create_main_flow_table(priv);\r\nif (err)\r\nreturn err;\r\nerr = mlx5e_create_vlan_flow_table(priv);\r\nif (err)\r\ngoto err_destroy_main_flow_table;\r\nerr = mlx5e_add_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_UNTAGGED, 0);\r\nif (err)\r\ngoto err_destroy_vlan_flow_table;\r\nreturn 0;\r\nerr_destroy_vlan_flow_table:\r\nmlx5e_destroy_vlan_flow_table(priv);\r\nerr_destroy_main_flow_table:\r\nmlx5e_destroy_main_flow_table(priv);\r\nreturn err;\r\n}\r\nvoid mlx5e_destroy_flow_tables(struct mlx5e_priv *priv)\r\n{\r\nmlx5e_del_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_UNTAGGED, 0);\r\nmlx5e_destroy_vlan_flow_table(priv);\r\nmlx5e_destroy_main_flow_table(priv);\r\n}
