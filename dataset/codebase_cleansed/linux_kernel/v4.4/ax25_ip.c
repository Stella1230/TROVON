static int ax25_hard_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type, const void *daddr,\r\nconst void *saddr, unsigned int len)\r\n{\r\nunsigned char *buff;\r\nif (type == ETH_P_AX25)\r\nreturn 0;\r\nbuff = skb_push(skb, AX25_HEADER_LEN);\r\n*buff++ = 0x00;\r\nif (daddr != NULL)\r\nmemcpy(buff, daddr, dev->addr_len);\r\nbuff[6] &= ~AX25_CBIT;\r\nbuff[6] &= ~AX25_EBIT;\r\nbuff[6] |= AX25_SSSID_SPARE;\r\nbuff += AX25_ADDR_LEN;\r\nif (saddr != NULL)\r\nmemcpy(buff, saddr, dev->addr_len);\r\nelse\r\nmemcpy(buff, dev->dev_addr, dev->addr_len);\r\nbuff[6] &= ~AX25_CBIT;\r\nbuff[6] |= AX25_EBIT;\r\nbuff[6] |= AX25_SSSID_SPARE;\r\nbuff += AX25_ADDR_LEN;\r\n*buff++ = AX25_UI;\r\nswitch (type) {\r\ncase ETH_P_IP:\r\n*buff++ = AX25_P_IP;\r\nbreak;\r\ncase ETH_P_ARP:\r\n*buff++ = AX25_P_ARP;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "AX.25: ax25_hard_header - wrong protocol type 0x%2.2x\n", type);\r\n*buff++ = 0;\r\nbreak;\r\n}\r\nif (daddr != NULL)\r\nreturn AX25_HEADER_LEN;\r\nreturn -AX25_HEADER_LEN;\r\n}\r\nnetdev_tx_t ax25_ip_xmit(struct sk_buff *skb)\r\n{\r\nstruct sk_buff *ourskb;\r\nunsigned char *bp = skb->data;\r\nax25_route *route;\r\nstruct net_device *dev = NULL;\r\nax25_address *src, *dst;\r\nax25_digi *digipeat = NULL;\r\nax25_dev *ax25_dev;\r\nax25_cb *ax25;\r\nchar ip_mode = ' ';\r\ndst = (ax25_address *)(bp + 1);\r\nsrc = (ax25_address *)(bp + 8);\r\nroute = ax25_get_route(dst, NULL);\r\nif (route) {\r\ndigipeat = route->digipeat;\r\ndev = route->dev;\r\nip_mode = route->ip_mode;\r\n}\r\nif (dev == NULL)\r\ndev = skb->dev;\r\nif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL) {\r\nkfree_skb(skb);\r\ngoto put;\r\n}\r\nif (bp[16] == AX25_P_IP) {\r\nif (ip_mode == 'V' || (ip_mode == ' ' && ax25_dev->values[AX25_VALUES_IPDEFMODE])) {\r\nax25_address src_c;\r\nax25_address dst_c;\r\nif ((ourskb = skb_copy(skb, GFP_ATOMIC)) == NULL) {\r\nkfree_skb(skb);\r\ngoto put;\r\n}\r\nif (skb->sk != NULL)\r\nskb_set_owner_w(ourskb, skb->sk);\r\nkfree_skb(skb);\r\nbp = ourskb->data;\r\ndst_c = *(ax25_address *)(bp + 1);\r\nsrc_c = *(ax25_address *)(bp + 8);\r\nskb_pull(ourskb, AX25_HEADER_LEN - 1);\r\nskb_reset_network_header(ourskb);\r\nax25=ax25_send_frame(\r\nourskb,\r\nax25_dev->values[AX25_VALUES_PACLEN],\r\n&src_c,\r\n&dst_c, digipeat, dev);\r\nif (ax25) {\r\nax25_cb_put(ax25);\r\n}\r\ngoto put;\r\n}\r\n}\r\nbp[7] &= ~AX25_CBIT;\r\nbp[7] &= ~AX25_EBIT;\r\nbp[7] |= AX25_SSSID_SPARE;\r\nbp[14] &= ~AX25_CBIT;\r\nbp[14] |= AX25_EBIT;\r\nbp[14] |= AX25_SSSID_SPARE;\r\nskb_pull(skb, AX25_KISS_HEADER_LEN);\r\nif (digipeat != NULL) {\r\nif ((ourskb = ax25_rt_build_path(skb, src, dst, route->digipeat)) == NULL) {\r\nkfree_skb(skb);\r\ngoto put;\r\n}\r\nskb = ourskb;\r\n}\r\nax25_queue_xmit(skb, dev);\r\nput:\r\nif (route)\r\nax25_put_route(route);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ax25_hard_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type, const void *daddr,\r\nconst void *saddr, unsigned int len)\r\n{\r\nreturn -AX25_HEADER_LEN;\r\n}\r\nnetdev_tx_t ax25_ip_xmit(struct sk_buff *skb)\r\n{\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}
