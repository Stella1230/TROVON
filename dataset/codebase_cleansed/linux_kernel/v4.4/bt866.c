static inline struct bt866 *to_bt866(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct bt866, sd);\r\n}\r\nstatic int bt866_write(struct bt866 *encoder, u8 subaddr, u8 data)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&encoder->sd);\r\nu8 buffer[2];\r\nint err;\r\nbuffer[0] = subaddr;\r\nbuffer[1] = data;\r\nencoder->reg[subaddr] = data;\r\nv4l_dbg(1, debug, client, "write 0x%02x = 0x%02x\n", subaddr, data);\r\nfor (err = 0; err < 3;) {\r\nif (i2c_master_send(client, buffer, 2) == 2)\r\nbreak;\r\nerr++;\r\nv4l_warn(client, "error #%d writing to 0x%02x\n",\r\nerr, subaddr);\r\nschedule_timeout_interruptible(msecs_to_jiffies(100));\r\n}\r\nif (err == 3) {\r\nv4l_warn(client, "giving up\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bt866_s_std_output(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nv4l2_dbg(1, debug, sd, "set norm %llx\n", (unsigned long long)std);\r\nif (!(std & V4L2_STD_NTSC))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int bt866_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstatic const __u8 init[] = {\r\n0xc8, 0xcc,\r\n0xca, 0x91,\r\n0xcc, 0x24,\r\n0xda, 0x00,\r\n0xdc, 0x24,\r\n0xde, 0x02,\r\n0x70, 0xEB, 0x90, 0x80, 0xB0, 0x80,\r\n0x72, 0xA2, 0x92, 0x8E, 0xB2, 0x2C,\r\n0x74, 0x83, 0x94, 0x2C, 0xB4, 0x9C,\r\n0x76, 0x70, 0x96, 0x3A, 0xB6, 0x48,\r\n0x78, 0x54, 0x98, 0xC6, 0xB8, 0xB8,\r\n0x7A, 0x41, 0x9A, 0xD4, 0xBA, 0x64,\r\n0x7C, 0x23, 0x9C, 0x72, 0xBC, 0xD4,\r\n0x7E, 0x10, 0x9E, 0x80, 0xBE, 0x80,\r\n0x60, 0xEB, 0x80, 0x80, 0xc0, 0x80,\r\n0x62, 0xA2, 0x82, 0x8E, 0xc2, 0x2C,\r\n0x64, 0x83, 0x84, 0x2C, 0xc4, 0x9C,\r\n0x66, 0x70, 0x86, 0x3A, 0xc6, 0x48,\r\n0x68, 0x54, 0x88, 0xC6, 0xc8, 0xB8,\r\n0x6A, 0x41, 0x8A, 0xD4, 0xcA, 0x64,\r\n0x6C, 0x23, 0x8C, 0x72, 0xcC, 0xD4,\r\n0x6E, 0x10, 0x8E, 0x80, 0xcE, 0x80,\r\n};\r\nstruct bt866 *encoder = to_bt866(sd);\r\nu8 val;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(init) / 2; i += 2)\r\nbt866_write(encoder, init[i], init[i+1]);\r\nval = encoder->reg[0xdc];\r\nif (input == 0)\r\nval |= 0x40;\r\nelse\r\nval &= ~0x40;\r\nbt866_write(encoder, 0xdc, val);\r\nval = encoder->reg[0xcc];\r\nif (input == 2)\r\nval |= 0x01;\r\nelse\r\nval &= ~0x01;\r\nbt866_write(encoder, 0xcc, val);\r\nv4l2_dbg(1, debug, sd, "set input %d\n", input);\r\nswitch (input) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bt866_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct bt866 *encoder;\r\nstruct v4l2_subdev *sd;\r\nv4l_info(client, "chip found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nencoder = devm_kzalloc(&client->dev, sizeof(*encoder), GFP_KERNEL);\r\nif (encoder == NULL)\r\nreturn -ENOMEM;\r\nsd = &encoder->sd;\r\nv4l2_i2c_subdev_init(sd, client, &bt866_ops);\r\nreturn 0;\r\n}\r\nstatic int bt866_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nreturn 0;\r\n}
