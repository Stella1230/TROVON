static bool wait_for_reg(void __iomem *reg, u32 mask, unsigned long timeout)\r\n{\r\ntimeout += jiffies;\r\nwhile (time_is_after_eq_jiffies(timeout)) {\r\nif ((readl(reg) & mask) == mask)\r\nreturn true;\r\nmsleep(1);\r\n}\r\nreturn false;\r\n}\r\nstatic int mv_usb2_phy_28nm_init(struct phy *phy)\r\n{\r\nstruct mv_usb2_phy *mv_phy = phy_get_drvdata(phy);\r\nstruct platform_device *pdev = mv_phy->pdev;\r\nvoid __iomem *base = mv_phy->base;\r\nu32 reg;\r\nint ret;\r\nclk_prepare_enable(mv_phy->clk);\r\nreg = readl(base + PHY_28NM_PLL_REG0) &\r\n~(PHY_28NM_PLL_SELLPFR_MASK | PHY_28NM_PLL_FBDIV_MASK\r\n| PHY_28NM_PLL_ICP_MASK | PHY_28NM_PLL_REFDIV_MASK);\r\nwritel(reg | (0x1 << PHY_28NM_PLL_SELLPFR_SHIFT\r\n| 0xf0 << PHY_28NM_PLL_FBDIV_SHIFT\r\n| 0x3 << PHY_28NM_PLL_ICP_SHIFT\r\n| 0xd << PHY_28NM_PLL_REFDIV_SHIFT),\r\nbase + PHY_28NM_PLL_REG0);\r\nreg = readl(base + PHY_28NM_PLL_REG1);\r\nwritel(reg | PHY_28NM_PLL_PU_PLL | PHY_28NM_PLL_PU_BY_REG,\r\nbase + PHY_28NM_PLL_REG1);\r\nreg = readl(base + PHY_28NM_TX_REG0) & ~PHY_28NM_TX_AMP_MASK;\r\nwritel(reg | PHY_28NM_TX_PU_BY_REG | 0x3 << PHY_28NM_TX_AMP_SHIFT |\r\nPHY_28NM_TX_PU_ANA,\r\nbase + PHY_28NM_TX_REG0);\r\nreg = readl(base + PHY_28NM_RX_REG0) & ~PHY_28NM_RX_SQ_THRESH_MASK;\r\nwritel(reg | 0xa << PHY_28NM_RX_SQ_THRESH_SHIFT,\r\nbase + PHY_28NM_RX_REG0);\r\nreg = readl(base + PHY_28NM_DIG_REG0) &\r\n~(PHY_28NM_DIG_BITSTAFFING_ERR | PHY_28NM_DIG_SYNC_ERR |\r\nPHY_28NM_DIG_SQ_FILT_MASK | PHY_28NM_DIG_SQ_BLK_MASK |\r\nPHY_28NM_DIG_SYNC_NUM_MASK);\r\nwritel(reg | (0x1 << PHY_28NM_DIG_SYNC_NUM_SHIFT |\r\nPHY_28NM_PLL_LOCK_BYPASS),\r\nbase + PHY_28NM_DIG_REG0);\r\nreg = readl(base + PHY_28NM_OTG_REG) | PHY_28NM_OTG_PU_OTG;\r\nwritel(reg & ~PHY_28NM_OTG_CONTROL_BY_PIN, base + PHY_28NM_OTG_REG);\r\nif (!wait_for_reg(base + PHY_28NM_CAL_REG,\r\nPHY_28NM_PLL_PLLCAL_DONE | PHY_28NM_PLL_IMPCAL_DONE,\r\nHZ / 10)) {\r\ndev_warn(&pdev->dev, "USB PHY PLL calibrate not done after 100mS.");\r\nret = -ETIMEDOUT;\r\ngoto err_clk;\r\n}\r\nif (!wait_for_reg(base + PHY_28NM_RX_REG1,\r\nPHY_28NM_RX_SQCAL_DONE, HZ / 10)) {\r\ndev_warn(&pdev->dev, "USB PHY RX SQ calibrate not done after 100mS.");\r\nret = -ETIMEDOUT;\r\ngoto err_clk;\r\n}\r\nif (!wait_for_reg(base + PHY_28NM_PLL_REG0,\r\nPHY_28NM_PLL_READY, HZ / 10)) {\r\ndev_warn(&pdev->dev, "PLL_READY not set after 100mS.");\r\nret = -ETIMEDOUT;\r\ngoto err_clk;\r\n}\r\nreturn 0;\r\nerr_clk:\r\nclk_disable_unprepare(mv_phy->clk);\r\nreturn ret;\r\n}\r\nstatic int mv_usb2_phy_28nm_power_on(struct phy *phy)\r\n{\r\nstruct mv_usb2_phy *mv_phy = phy_get_drvdata(phy);\r\nvoid __iomem *base = mv_phy->base;\r\nwritel(readl(base + PHY_28NM_CTRL_REG3) |\r\n(PHY_28NM_CTRL3_OVERWRITE | PHY_28NM_CTRL3_VBUS_VALID |\r\nPHY_28NM_CTRL3_AVALID | PHY_28NM_CTRL3_BVALID),\r\nbase + PHY_28NM_CTRL_REG3);\r\nreturn 0;\r\n}\r\nstatic int mv_usb2_phy_28nm_power_off(struct phy *phy)\r\n{\r\nstruct mv_usb2_phy *mv_phy = phy_get_drvdata(phy);\r\nvoid __iomem *base = mv_phy->base;\r\nwritel(readl(base + PHY_28NM_CTRL_REG3) |\r\n~(PHY_28NM_CTRL3_OVERWRITE | PHY_28NM_CTRL3_VBUS_VALID\r\n| PHY_28NM_CTRL3_AVALID | PHY_28NM_CTRL3_BVALID),\r\nbase + PHY_28NM_CTRL_REG3);\r\nreturn 0;\r\n}\r\nstatic int mv_usb2_phy_28nm_exit(struct phy *phy)\r\n{\r\nstruct mv_usb2_phy *mv_phy = phy_get_drvdata(phy);\r\nvoid __iomem *base = mv_phy->base;\r\nunsigned int val;\r\nval = readw(base + PHY_28NM_PLL_REG1);\r\nval &= ~PHY_28NM_PLL_PU_PLL;\r\nwritew(val, base + PHY_28NM_PLL_REG1);\r\nval = readw(base + PHY_28NM_TX_REG0);\r\nval &= ~PHY_28NM_TX_PU_ANA;\r\nwritew(val, base + PHY_28NM_TX_REG0);\r\nval = readw(base + PHY_28NM_OTG_REG);\r\nval &= ~PHY_28NM_OTG_PU_OTG;\r\nwritew(val, base + PHY_28NM_OTG_REG);\r\nclk_disable_unprepare(mv_phy->clk);\r\nreturn 0;\r\n}\r\nstatic int mv_usb2_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct phy_provider *phy_provider;\r\nstruct mv_usb2_phy *mv_phy;\r\nstruct resource *r;\r\nmv_phy = devm_kzalloc(&pdev->dev, sizeof(*mv_phy), GFP_KERNEL);\r\nif (!mv_phy)\r\nreturn -ENOMEM;\r\nmv_phy->pdev = pdev;\r\nmv_phy->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(mv_phy->clk)) {\r\ndev_err(&pdev->dev, "failed to get clock.\n");\r\nreturn PTR_ERR(mv_phy->clk);\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmv_phy->base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(mv_phy->base))\r\nreturn PTR_ERR(mv_phy->base);\r\nmv_phy->phy = devm_phy_create(&pdev->dev, pdev->dev.of_node, &usb_ops);\r\nif (IS_ERR(mv_phy->phy))\r\nreturn PTR_ERR(mv_phy->phy);\r\nphy_set_drvdata(mv_phy->phy, mv_phy);\r\nphy_provider = devm_of_phy_provider_register(&pdev->dev, of_phy_simple_xlate);\r\nreturn PTR_ERR_OR_ZERO(phy_provider);\r\n}
