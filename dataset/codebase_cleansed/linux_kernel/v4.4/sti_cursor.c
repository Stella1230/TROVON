static void sti_cursor_argb8888_to_clut8(struct sti_cursor *cursor, u32 *src)\r\n{\r\nu8 *dst = cursor->pixmap.base;\r\nunsigned int i, j;\r\nu32 a, r, g, b;\r\nfor (i = 0; i < cursor->height; i++) {\r\nfor (j = 0; j < cursor->width; j++) {\r\na = (*src >> 30) & 3;\r\nr = (*src >> 22) & 3;\r\ng = (*src >> 14) & 3;\r\nb = (*src >> 6) & 3;\r\n*dst = a << 6 | r << 4 | g << 2 | b;\r\nsrc++;\r\ndst++;\r\n}\r\n}\r\n}\r\nstatic void sti_cursor_init(struct sti_cursor *cursor)\r\n{\r\nunsigned short *base = cursor->clut;\r\nunsigned int a, r, g, b;\r\nfor (a = 0; a < 4; a++)\r\nfor (r = 0; r < 4; r++)\r\nfor (g = 0; g < 4; g++)\r\nfor (b = 0; b < 4; b++)\r\n*base++ = (a * 5) << 12 |\r\n(r * 5) << 8 |\r\n(g * 5) << 4 |\r\n(b * 5);\r\n}\r\nstatic void sti_cursor_atomic_update(struct drm_plane *drm_plane,\r\nstruct drm_plane_state *oldstate)\r\n{\r\nstruct drm_plane_state *state = drm_plane->state;\r\nstruct sti_plane *plane = to_sti_plane(drm_plane);\r\nstruct sti_cursor *cursor = to_sti_cursor(plane);\r\nstruct drm_crtc *crtc = state->crtc;\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nstruct drm_framebuffer *fb = state->fb;\r\nstruct drm_display_mode *mode = &crtc->mode;\r\nint dst_x = state->crtc_x;\r\nint dst_y = state->crtc_y;\r\nint dst_w = clamp_val(state->crtc_w, 0, mode->crtc_hdisplay - dst_x);\r\nint dst_h = clamp_val(state->crtc_h, 0, mode->crtc_vdisplay - dst_y);\r\nint src_w = state->src_w >> 16;\r\nint src_h = state->src_h >> 16;\r\nbool first_prepare = plane->status == STI_PLANE_DISABLED ? true : false;\r\nstruct drm_gem_cma_object *cma_obj;\r\nu32 y, x;\r\nu32 val;\r\nDRM_DEBUG_KMS("CRTC:%d (%s) drm plane:%d (%s)\n",\r\ncrtc->base.id, sti_mixer_to_str(mixer),\r\ndrm_plane->base.id, sti_plane_to_str(plane));\r\nDRM_DEBUG_KMS("(%dx%d)@(%d,%d)\n", dst_w, dst_h, dst_x, dst_y);\r\ndev_dbg(cursor->dev, "%s %s\n", __func__,\r\nsti_plane_to_str(plane));\r\nif (src_w < STI_CURS_MIN_SIZE ||\r\nsrc_h < STI_CURS_MIN_SIZE ||\r\nsrc_w > STI_CURS_MAX_SIZE ||\r\nsrc_h > STI_CURS_MAX_SIZE) {\r\nDRM_ERROR("Invalid cursor size (%dx%d)\n",\r\nsrc_w, src_h);\r\nreturn;\r\n}\r\nif (!cursor->pixmap.base ||\r\n(cursor->width != src_w) ||\r\n(cursor->height != src_h)) {\r\ncursor->width = src_w;\r\ncursor->height = src_h;\r\nif (cursor->pixmap.base)\r\ndma_free_writecombine(cursor->dev,\r\ncursor->pixmap.size,\r\ncursor->pixmap.base,\r\ncursor->pixmap.paddr);\r\ncursor->pixmap.size = cursor->width * cursor->height;\r\ncursor->pixmap.base = dma_alloc_writecombine(cursor->dev,\r\ncursor->pixmap.size,\r\n&cursor->pixmap.paddr,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!cursor->pixmap.base) {\r\nDRM_ERROR("Failed to allocate memory for pixmap\n");\r\nreturn;\r\n}\r\n}\r\ncma_obj = drm_fb_cma_get_gem_obj(fb, 0);\r\nif (!cma_obj) {\r\nDRM_ERROR("Can't get CMA GEM object for fb\n");\r\nreturn;\r\n}\r\nsti_cursor_argb8888_to_clut8(cursor, (u32 *)cma_obj->vaddr);\r\ny = sti_vtg_get_line_number(*mode, 0);\r\nx = sti_vtg_get_pixel_number(*mode, 0);\r\nval = y << 16 | x;\r\nwritel(val, cursor->regs + CUR_AWS);\r\ny = sti_vtg_get_line_number(*mode, mode->vdisplay - 1);\r\nx = sti_vtg_get_pixel_number(*mode, mode->hdisplay - 1);\r\nval = y << 16 | x;\r\nwritel(val, cursor->regs + CUR_AWE);\r\nif (first_prepare) {\r\nwritel(cursor->clut_paddr, cursor->regs + CUR_CML);\r\nwritel(CUR_CTL_CLUT_UPDATE, cursor->regs + CUR_CTL);\r\n}\r\nwritel(cursor->pixmap.paddr, cursor->regs + CUR_PML);\r\nwritel(cursor->width, cursor->regs + CUR_PMP);\r\nwritel(cursor->height << 16 | cursor->width, cursor->regs + CUR_SIZE);\r\ny = sti_vtg_get_line_number(*mode, dst_y);\r\nx = sti_vtg_get_pixel_number(*mode, dst_y);\r\nwritel((y << 16) | x, cursor->regs + CUR_VPO);\r\nplane->status = STI_PLANE_UPDATED;\r\n}\r\nstatic void sti_cursor_atomic_disable(struct drm_plane *drm_plane,\r\nstruct drm_plane_state *oldstate)\r\n{\r\nstruct sti_plane *plane = to_sti_plane(drm_plane);\r\nstruct sti_mixer *mixer = to_sti_mixer(drm_plane->crtc);\r\nif (!drm_plane->crtc) {\r\nDRM_DEBUG_DRIVER("drm plane:%d not enabled\n",\r\ndrm_plane->base.id);\r\nreturn;\r\n}\r\nDRM_DEBUG_DRIVER("CRTC:%d (%s) drm plane:%d (%s)\n",\r\ndrm_plane->crtc->base.id, sti_mixer_to_str(mixer),\r\ndrm_plane->base.id, sti_plane_to_str(plane));\r\nplane->status = STI_PLANE_DISABLING;\r\n}\r\nstruct drm_plane *sti_cursor_create(struct drm_device *drm_dev,\r\nstruct device *dev, int desc,\r\nvoid __iomem *baseaddr,\r\nunsigned int possible_crtcs)\r\n{\r\nstruct sti_cursor *cursor;\r\nsize_t size;\r\nint res;\r\ncursor = devm_kzalloc(dev, sizeof(*cursor), GFP_KERNEL);\r\nif (!cursor) {\r\nDRM_ERROR("Failed to allocate memory for cursor\n");\r\nreturn NULL;\r\n}\r\nsize = 0x100 * sizeof(unsigned short);\r\ncursor->clut = dma_alloc_writecombine(dev, size, &cursor->clut_paddr,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!cursor->clut) {\r\nDRM_ERROR("Failed to allocate memory for cursor clut\n");\r\ngoto err_clut;\r\n}\r\ncursor->dev = dev;\r\ncursor->regs = baseaddr;\r\ncursor->plane.desc = desc;\r\ncursor->plane.status = STI_PLANE_DISABLED;\r\nsti_cursor_init(cursor);\r\nres = drm_universal_plane_init(drm_dev, &cursor->plane.drm_plane,\r\npossible_crtcs,\r\n&sti_plane_helpers_funcs,\r\ncursor_supported_formats,\r\nARRAY_SIZE(cursor_supported_formats),\r\nDRM_PLANE_TYPE_CURSOR);\r\nif (res) {\r\nDRM_ERROR("Failed to initialize universal plane\n");\r\ngoto err_plane;\r\n}\r\ndrm_plane_helper_add(&cursor->plane.drm_plane,\r\n&sti_cursor_helpers_funcs);\r\nsti_plane_init_property(&cursor->plane, DRM_PLANE_TYPE_CURSOR);\r\nreturn &cursor->plane.drm_plane;\r\nerr_plane:\r\ndma_free_writecombine(dev, size, cursor->clut, cursor->clut_paddr);\r\nerr_clut:\r\ndevm_kfree(dev, cursor);\r\nreturn NULL;\r\n}
