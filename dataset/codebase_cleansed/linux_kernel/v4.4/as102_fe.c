static uint8_t as102_fe_get_code_rate(enum fe_code_rate arg)\r\n{\r\nuint8_t c;\r\nswitch (arg) {\r\ncase FEC_1_2:\r\nc = CODE_RATE_1_2;\r\nbreak;\r\ncase FEC_2_3:\r\nc = CODE_RATE_2_3;\r\nbreak;\r\ncase FEC_3_4:\r\nc = CODE_RATE_3_4;\r\nbreak;\r\ncase FEC_5_6:\r\nc = CODE_RATE_5_6;\r\nbreak;\r\ncase FEC_7_8:\r\nc = CODE_RATE_7_8;\r\nbreak;\r\ndefault:\r\nc = CODE_RATE_UNKNOWN;\r\nbreak;\r\n}\r\nreturn c;\r\n}\r\nstatic int as102_fe_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct as102_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct as10x_tune_args tune_args = { 0 };\r\ntune_args.freq = c->frequency / 1000;\r\ntune_args.interleaving_mode = INTLV_NATIVE;\r\nswitch (c->bandwidth_hz) {\r\ncase 8000000:\r\ntune_args.bandwidth = BW_8_MHZ;\r\nbreak;\r\ncase 7000000:\r\ntune_args.bandwidth = BW_7_MHZ;\r\nbreak;\r\ncase 6000000:\r\ntune_args.bandwidth = BW_6_MHZ;\r\nbreak;\r\ndefault:\r\ntune_args.bandwidth = BW_8_MHZ;\r\n}\r\nswitch (c->guard_interval) {\r\ncase GUARD_INTERVAL_1_32:\r\ntune_args.guard_interval = GUARD_INT_1_32;\r\nbreak;\r\ncase GUARD_INTERVAL_1_16:\r\ntune_args.guard_interval = GUARD_INT_1_16;\r\nbreak;\r\ncase GUARD_INTERVAL_1_8:\r\ntune_args.guard_interval = GUARD_INT_1_8;\r\nbreak;\r\ncase GUARD_INTERVAL_1_4:\r\ntune_args.guard_interval = GUARD_INT_1_4;\r\nbreak;\r\ncase GUARD_INTERVAL_AUTO:\r\ndefault:\r\ntune_args.guard_interval = GUARD_UNKNOWN;\r\nbreak;\r\n}\r\nswitch (c->modulation) {\r\ncase QPSK:\r\ntune_args.modulation = CONST_QPSK;\r\nbreak;\r\ncase QAM_16:\r\ntune_args.modulation = CONST_QAM16;\r\nbreak;\r\ncase QAM_64:\r\ntune_args.modulation = CONST_QAM64;\r\nbreak;\r\ndefault:\r\ntune_args.modulation = CONST_UNKNOWN;\r\nbreak;\r\n}\r\nswitch (c->transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\ntune_args.transmission_mode = TRANS_MODE_2K;\r\nbreak;\r\ncase TRANSMISSION_MODE_8K:\r\ntune_args.transmission_mode = TRANS_MODE_8K;\r\nbreak;\r\ndefault:\r\ntune_args.transmission_mode = TRANS_MODE_UNKNOWN;\r\n}\r\nswitch (c->hierarchy) {\r\ncase HIERARCHY_NONE:\r\ntune_args.hierarchy = HIER_NONE;\r\nbreak;\r\ncase HIERARCHY_1:\r\ntune_args.hierarchy = HIER_ALPHA_1;\r\nbreak;\r\ncase HIERARCHY_2:\r\ntune_args.hierarchy = HIER_ALPHA_2;\r\nbreak;\r\ncase HIERARCHY_4:\r\ntune_args.hierarchy = HIER_ALPHA_4;\r\nbreak;\r\ncase HIERARCHY_AUTO:\r\ntune_args.hierarchy = HIER_UNKNOWN;\r\nbreak;\r\n}\r\npr_debug("as102: tuner parameters: freq: %d bw: 0x%02x gi: 0x%02x\n",\r\nc->frequency,\r\ntune_args.bandwidth,\r\ntune_args.guard_interval);\r\nif ((tune_args.hierarchy != HIER_NONE) &&\r\n((c->code_rate_LP == FEC_NONE) ||\r\n(c->code_rate_HP == FEC_NONE))) {\r\nif (c->code_rate_LP == FEC_NONE) {\r\ntune_args.hier_select = HIER_HIGH_PRIORITY;\r\ntune_args.code_rate =\r\nas102_fe_get_code_rate(c->code_rate_HP);\r\n}\r\nif (c->code_rate_HP == FEC_NONE) {\r\ntune_args.hier_select = HIER_LOW_PRIORITY;\r\ntune_args.code_rate =\r\nas102_fe_get_code_rate(c->code_rate_LP);\r\n}\r\npr_debug("as102: \thierarchy: 0x%02x selected: %s code_rate_%s: 0x%02x\n",\r\ntune_args.hierarchy,\r\ntune_args.hier_select == HIER_HIGH_PRIORITY ?\r\n"HP" : "LP",\r\ntune_args.hier_select == HIER_HIGH_PRIORITY ?\r\n"HP" : "LP",\r\ntune_args.code_rate);\r\n} else {\r\ntune_args.code_rate =\r\nas102_fe_get_code_rate(c->code_rate_HP);\r\n}\r\nreturn state->ops->set_tune(state->priv, &tune_args);\r\n}\r\nstatic int as102_fe_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct as102_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret = 0;\r\nstruct as10x_tps tps = { 0 };\r\nret = state->ops->get_tps(state->priv, &tps);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (tps.modulation) {\r\ncase CONST_QPSK:\r\nc->modulation = QPSK;\r\nbreak;\r\ncase CONST_QAM16:\r\nc->modulation = QAM_16;\r\nbreak;\r\ncase CONST_QAM64:\r\nc->modulation = QAM_64;\r\nbreak;\r\n}\r\nswitch (tps.hierarchy) {\r\ncase HIER_NONE:\r\nc->hierarchy = HIERARCHY_NONE;\r\nbreak;\r\ncase HIER_ALPHA_1:\r\nc->hierarchy = HIERARCHY_1;\r\nbreak;\r\ncase HIER_ALPHA_2:\r\nc->hierarchy = HIERARCHY_2;\r\nbreak;\r\ncase HIER_ALPHA_4:\r\nc->hierarchy = HIERARCHY_4;\r\nbreak;\r\n}\r\nswitch (tps.code_rate_HP) {\r\ncase CODE_RATE_1_2:\r\nc->code_rate_HP = FEC_1_2;\r\nbreak;\r\ncase CODE_RATE_2_3:\r\nc->code_rate_HP = FEC_2_3;\r\nbreak;\r\ncase CODE_RATE_3_4:\r\nc->code_rate_HP = FEC_3_4;\r\nbreak;\r\ncase CODE_RATE_5_6:\r\nc->code_rate_HP = FEC_5_6;\r\nbreak;\r\ncase CODE_RATE_7_8:\r\nc->code_rate_HP = FEC_7_8;\r\nbreak;\r\n}\r\nswitch (tps.code_rate_LP) {\r\ncase CODE_RATE_1_2:\r\nc->code_rate_LP = FEC_1_2;\r\nbreak;\r\ncase CODE_RATE_2_3:\r\nc->code_rate_LP = FEC_2_3;\r\nbreak;\r\ncase CODE_RATE_3_4:\r\nc->code_rate_LP = FEC_3_4;\r\nbreak;\r\ncase CODE_RATE_5_6:\r\nc->code_rate_LP = FEC_5_6;\r\nbreak;\r\ncase CODE_RATE_7_8:\r\nc->code_rate_LP = FEC_7_8;\r\nbreak;\r\n}\r\nswitch (tps.guard_interval) {\r\ncase GUARD_INT_1_32:\r\nc->guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase GUARD_INT_1_16:\r\nc->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase GUARD_INT_1_8:\r\nc->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase GUARD_INT_1_4:\r\nc->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nswitch (tps.transmission_mode) {\r\ncase TRANS_MODE_2K:\r\nc->transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase TRANS_MODE_8K:\r\nc->transmission_mode = TRANSMISSION_MODE_8K;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int as102_fe_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *settings) {\r\nsettings->min_delay_ms = 1000;\r\nreturn 0;\r\n}\r\nstatic int as102_fe_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nint ret = 0;\r\nstruct as102_state *state = fe->demodulator_priv;\r\nstruct as10x_tune_status tstate = { 0 };\r\nret = state->ops->get_status(state->priv, &tstate);\r\nif (ret < 0)\r\nreturn ret;\r\nstate->signal_strength = tstate.signal_strength;\r\nstate->ber = tstate.BER;\r\nswitch (tstate.tune_state) {\r\ncase TUNE_STATUS_SIGNAL_DVB_OK:\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER;\r\nbreak;\r\ncase TUNE_STATUS_STREAM_DETECTED:\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_SYNC |\r\nFE_HAS_VITERBI;\r\nbreak;\r\ncase TUNE_STATUS_STREAM_TUNED:\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_SYNC |\r\nFE_HAS_LOCK | FE_HAS_VITERBI;\r\nbreak;\r\ndefault:\r\n*status = TUNE_STATUS_NOT_TUNED;\r\n}\r\npr_debug("as102: tuner status: 0x%02x, strength %d, per: %d, ber: %d\n",\r\ntstate.tune_state, tstate.signal_strength,\r\ntstate.PER, tstate.BER);\r\nif (!(*status & FE_HAS_LOCK)) {\r\nmemset(&state->demod_stats, 0, sizeof(state->demod_stats));\r\nreturn 0;\r\n}\r\nret = state->ops->get_stats(state->priv, &state->demod_stats);\r\nif (ret < 0)\r\nmemset(&state->demod_stats, 0, sizeof(state->demod_stats));\r\nreturn ret;\r\n}\r\nstatic int as102_fe_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct as102_state *state = fe->demodulator_priv;\r\n*snr = state->demod_stats.mer;\r\nreturn 0;\r\n}\r\nstatic int as102_fe_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct as102_state *state = fe->demodulator_priv;\r\n*ber = state->ber;\r\nreturn 0;\r\n}\r\nstatic int as102_fe_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *strength)\r\n{\r\nstruct as102_state *state = fe->demodulator_priv;\r\n*strength = (((0xffff * 400) * state->signal_strength + 41000) * 2);\r\nreturn 0;\r\n}\r\nstatic int as102_fe_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct as102_state *state = fe->demodulator_priv;\r\nif (state->demod_stats.has_started)\r\n*ucblocks = state->demod_stats.bad_frame_count;\r\nelse\r\n*ucblocks = 0;\r\nreturn 0;\r\n}\r\nstatic int as102_fe_ts_bus_ctrl(struct dvb_frontend *fe, int acquire)\r\n{\r\nstruct as102_state *state = fe->demodulator_priv;\r\nreturn state->ops->stream_ctrl(state->priv, acquire,\r\nstate->elna_cfg);\r\n}\r\nstatic void as102_fe_release(struct dvb_frontend *fe)\r\n{\r\nstruct as102_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *as102_attach(const char *name,\r\nconst struct as102_fe_ops *ops,\r\nvoid *priv,\r\nuint8_t elna_cfg)\r\n{\r\nstruct as102_state *state;\r\nstruct dvb_frontend *fe;\r\nstate = kzalloc(sizeof(struct as102_state), GFP_KERNEL);\r\nif (state == NULL) {\r\npr_err("%s: unable to allocate memory for state\n", __func__);\r\nreturn NULL;\r\n}\r\nfe = &state->frontend;\r\nfe->demodulator_priv = state;\r\nstate->ops = ops;\r\nstate->priv = priv;\r\nstate->elna_cfg = elna_cfg;\r\nmemcpy(&fe->ops, &as102_fe_ops, sizeof(struct dvb_frontend_ops));\r\nstrncpy(fe->ops.info.name, name, sizeof(fe->ops.info.name));\r\nreturn fe;\r\n}
