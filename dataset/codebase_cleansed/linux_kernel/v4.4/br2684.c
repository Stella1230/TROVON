static void skb_debug(const struct sk_buff *skb)\r\n{\r\n#ifdef SKB_DEBUG\r\n#define NUM2PRINT 50\r\nprint_hex_dump(KERN_DEBUG, "br2684: skb: ", DUMP_OFFSET,\r\n16, 1, skb->data, min(NUM2PRINT, skb->len), true);\r\n#endif\r\n}\r\nstatic inline struct br2684_dev *BRPRIV(const struct net_device *net_dev)\r\n{\r\nreturn netdev_priv(net_dev);\r\n}\r\nstatic inline struct net_device *list_entry_brdev(const struct list_head *le)\r\n{\r\nreturn list_entry(le, struct br2684_dev, br2684_devs)->net_dev;\r\n}\r\nstatic inline struct br2684_vcc *BR2684_VCC(const struct atm_vcc *atmvcc)\r\n{\r\nreturn (struct br2684_vcc *)(atmvcc->user_back);\r\n}\r\nstatic inline struct br2684_vcc *list_entry_brvcc(const struct list_head *le)\r\n{\r\nreturn list_entry(le, struct br2684_vcc, brvccs);\r\n}\r\nstatic struct net_device *br2684_find_dev(const struct br2684_if_spec *s)\r\n{\r\nstruct list_head *lh;\r\nstruct net_device *net_dev;\r\nswitch (s->method) {\r\ncase BR2684_FIND_BYNUM:\r\nlist_for_each(lh, &br2684_devs) {\r\nnet_dev = list_entry_brdev(lh);\r\nif (BRPRIV(net_dev)->number == s->spec.devnum)\r\nreturn net_dev;\r\n}\r\nbreak;\r\ncase BR2684_FIND_BYIFNAME:\r\nlist_for_each(lh, &br2684_devs) {\r\nnet_dev = list_entry_brdev(lh);\r\nif (!strncmp(net_dev->name, s->spec.ifname, IFNAMSIZ))\r\nreturn net_dev;\r\n}\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int atm_dev_event(struct notifier_block *this, unsigned long event,\r\nvoid *arg)\r\n{\r\nstruct atm_dev *atm_dev = arg;\r\nstruct list_head *lh;\r\nstruct net_device *net_dev;\r\nstruct br2684_vcc *brvcc;\r\nstruct atm_vcc *atm_vcc;\r\nunsigned long flags;\r\npr_debug("event=%ld dev=%p\n", event, atm_dev);\r\nread_lock_irqsave(&devs_lock, flags);\r\nlist_for_each(lh, &br2684_devs) {\r\nnet_dev = list_entry_brdev(lh);\r\nlist_for_each_entry(brvcc, &BRPRIV(net_dev)->brvccs, brvccs) {\r\natm_vcc = brvcc->atmvcc;\r\nif (atm_vcc && brvcc->atmvcc->dev == atm_dev) {\r\nif (atm_vcc->dev->signal == ATM_PHY_SIG_LOST)\r\nnetif_carrier_off(net_dev);\r\nelse\r\nnetif_carrier_on(net_dev);\r\n}\r\n}\r\n}\r\nread_unlock_irqrestore(&devs_lock, flags);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void br2684_pop(struct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nstruct br2684_vcc *brvcc = BR2684_VCC(vcc);\r\npr_debug("(vcc %p ; net_dev %p )\n", vcc, brvcc->device);\r\nbrvcc->old_pop(vcc, skb);\r\nif (atomic_inc_return(&brvcc->qspace) == 1)\r\nnetif_wake_queue(brvcc->device);\r\n}\r\nstatic int br2684_xmit_vcc(struct sk_buff *skb, struct net_device *dev,\r\nstruct br2684_vcc *brvcc)\r\n{\r\nstruct br2684_dev *brdev = BRPRIV(dev);\r\nstruct atm_vcc *atmvcc;\r\nint minheadroom = (brvcc->encaps == e_llc) ?\r\n((brdev->payload == p_bridged) ?\r\nsizeof(llc_oui_pid_pad) : sizeof(llc_oui_ipv4)) :\r\n((brdev->payload == p_bridged) ? BR2684_PAD_LEN : 0);\r\nif (skb_headroom(skb) < minheadroom) {\r\nstruct sk_buff *skb2 = skb_realloc_headroom(skb, minheadroom);\r\nbrvcc->copies_needed++;\r\ndev_kfree_skb(skb);\r\nif (skb2 == NULL) {\r\nbrvcc->copies_failed++;\r\nreturn 0;\r\n}\r\nskb = skb2;\r\n}\r\nif (brvcc->encaps == e_llc) {\r\nif (brdev->payload == p_bridged) {\r\nskb_push(skb, sizeof(llc_oui_pid_pad));\r\nskb_copy_to_linear_data(skb, llc_oui_pid_pad,\r\nsizeof(llc_oui_pid_pad));\r\n} else if (brdev->payload == p_routed) {\r\nunsigned short prot = ntohs(skb->protocol);\r\nskb_push(skb, sizeof(llc_oui_ipv4));\r\nswitch (prot) {\r\ncase ETH_P_IP:\r\nskb_copy_to_linear_data(skb, llc_oui_ipv4,\r\nsizeof(llc_oui_ipv4));\r\nbreak;\r\ncase ETH_P_IPV6:\r\nskb_copy_to_linear_data(skb, llc_oui_ipv6,\r\nsizeof(llc_oui_ipv6));\r\nbreak;\r\ndefault:\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\n}\r\n} else {\r\nif (brdev->payload == p_bridged) {\r\nskb_push(skb, 2);\r\nmemset(skb->data, 0, 2);\r\n}\r\n}\r\nskb_debug(skb);\r\nATM_SKB(skb)->vcc = atmvcc = brvcc->atmvcc;\r\npr_debug("atm_skb(%p)->vcc(%p)->dev(%p)\n", skb, atmvcc, atmvcc->dev);\r\natomic_add(skb->truesize, &sk_atm(atmvcc)->sk_wmem_alloc);\r\nATM_SKB(skb)->atm_options = atmvcc->atm_options;\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\nif (atomic_dec_return(&brvcc->qspace) < 1) {\r\nnetif_stop_queue(brvcc->device);\r\nif (unlikely(atomic_read(&brvcc->qspace) > 0))\r\nnetif_wake_queue(brvcc->device);\r\n}\r\nreturn !atmvcc->send(atmvcc, skb);\r\n}\r\nstatic void br2684_release_cb(struct atm_vcc *atmvcc)\r\n{\r\nstruct br2684_vcc *brvcc = BR2684_VCC(atmvcc);\r\nif (atomic_read(&brvcc->qspace) > 0)\r\nnetif_wake_queue(brvcc->device);\r\nif (brvcc->old_release_cb)\r\nbrvcc->old_release_cb(atmvcc);\r\n}\r\nstatic inline struct br2684_vcc *pick_outgoing_vcc(const struct sk_buff *skb,\r\nconst struct br2684_dev *brdev)\r\n{\r\nreturn list_empty(&brdev->brvccs) ? NULL : list_entry_brvcc(brdev->brvccs.next);\r\n}\r\nstatic netdev_tx_t br2684_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct br2684_dev *brdev = BRPRIV(dev);\r\nstruct br2684_vcc *brvcc;\r\nstruct atm_vcc *atmvcc;\r\nnetdev_tx_t ret = NETDEV_TX_OK;\r\npr_debug("skb_dst(skb)=%p\n", skb_dst(skb));\r\nread_lock(&devs_lock);\r\nbrvcc = pick_outgoing_vcc(skb, brdev);\r\nif (brvcc == NULL) {\r\npr_debug("no vcc attached to dev %s\n", dev->name);\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_carrier_errors++;\r\ndev_kfree_skb(skb);\r\ngoto out_devs;\r\n}\r\natmvcc = brvcc->atmvcc;\r\nbh_lock_sock(sk_atm(atmvcc));\r\nif (test_bit(ATM_VF_RELEASED, &atmvcc->flags) ||\r\ntest_bit(ATM_VF_CLOSE, &atmvcc->flags) ||\r\n!test_bit(ATM_VF_READY, &atmvcc->flags)) {\r\ndev->stats.tx_dropped++;\r\ndev_kfree_skb(skb);\r\ngoto out;\r\n}\r\nif (sock_owned_by_user(sk_atm(atmvcc))) {\r\nnetif_stop_queue(brvcc->device);\r\nret = NETDEV_TX_BUSY;\r\ngoto out;\r\n}\r\nif (!br2684_xmit_vcc(skb, dev, brvcc)) {\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_fifo_errors++;\r\n}\r\nout:\r\nbh_unlock_sock(sk_atm(atmvcc));\r\nout_devs:\r\nread_unlock(&devs_lock);\r\nreturn ret;\r\n}\r\nstatic int br2684_mac_addr(struct net_device *dev, void *p)\r\n{\r\nint err = eth_mac_addr(dev, p);\r\nif (!err)\r\nBRPRIV(dev)->mac_was_set = 1;\r\nreturn err;\r\n}\r\nstatic int br2684_setfilt(struct atm_vcc *atmvcc, void __user * arg)\r\n{\r\nstruct br2684_vcc *brvcc;\r\nstruct br2684_filter_set fs;\r\nif (copy_from_user(&fs, arg, sizeof fs))\r\nreturn -EFAULT;\r\nif (fs.ifspec.method != BR2684_FIND_BYNOTHING) {\r\nstruct br2684_dev *brdev;\r\nread_lock(&devs_lock);\r\nbrdev = BRPRIV(br2684_find_dev(&fs.ifspec));\r\nif (brdev == NULL || list_empty(&brdev->brvccs) ||\r\nbrdev->brvccs.next != brdev->brvccs.prev)\r\nbrvcc = NULL;\r\nelse\r\nbrvcc = list_entry_brvcc(brdev->brvccs.next);\r\nread_unlock(&devs_lock);\r\nif (brvcc == NULL)\r\nreturn -ESRCH;\r\n} else\r\nbrvcc = BR2684_VCC(atmvcc);\r\nmemcpy(&brvcc->filter, &fs.filter, sizeof(brvcc->filter));\r\nreturn 0;\r\n}\r\nstatic inline int\r\npacket_fails_filter(__be16 type, struct br2684_vcc *brvcc, struct sk_buff *skb)\r\n{\r\nif (brvcc->filter.netmask == 0)\r\nreturn 0;\r\nif (type == htons(ETH_P_IP) &&\r\n(((struct iphdr *)(skb->data))->daddr & brvcc->filter.\r\nnetmask) == brvcc->filter.prefix)\r\nreturn 0;\r\nif (type == htons(ETH_P_ARP))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void br2684_close_vcc(struct br2684_vcc *brvcc)\r\n{\r\npr_debug("removing VCC %p from dev %p\n", brvcc, brvcc->device);\r\nwrite_lock_irq(&devs_lock);\r\nlist_del(&brvcc->brvccs);\r\nwrite_unlock_irq(&devs_lock);\r\nbrvcc->atmvcc->user_back = NULL;\r\nbrvcc->atmvcc->release_cb = brvcc->old_release_cb;\r\nbrvcc->old_push(brvcc->atmvcc, NULL);\r\nmodule_put(brvcc->old_owner);\r\nkfree(brvcc);\r\n}\r\nstatic void br2684_push(struct atm_vcc *atmvcc, struct sk_buff *skb)\r\n{\r\nstruct br2684_vcc *brvcc = BR2684_VCC(atmvcc);\r\nstruct net_device *net_dev = brvcc->device;\r\nstruct br2684_dev *brdev = BRPRIV(net_dev);\r\npr_debug("\n");\r\nif (unlikely(skb == NULL)) {\r\nbr2684_close_vcc(brvcc);\r\nif (list_empty(&brdev->brvccs)) {\r\nwrite_lock_irq(&devs_lock);\r\nlist_del(&brdev->br2684_devs);\r\nwrite_unlock_irq(&devs_lock);\r\nunregister_netdev(net_dev);\r\nfree_netdev(net_dev);\r\n}\r\nreturn;\r\n}\r\nskb_debug(skb);\r\natm_return(atmvcc, skb->truesize);\r\npr_debug("skb from brdev %p\n", brdev);\r\nif (brvcc->encaps == e_llc) {\r\nif (skb->len > 7 && skb->data[7] == 0x01)\r\n__skb_trim(skb, skb->len - 4);\r\nif ((skb->len >= (sizeof(llc_oui_ipv4))) &&\r\n(memcmp(skb->data, llc_oui_ipv4,\r\nsizeof(llc_oui_ipv4) - BR2684_ETHERTYPE_LEN) == 0)) {\r\nif (memcmp(skb->data + 6, ethertype_ipv6,\r\nsizeof(ethertype_ipv6)) == 0)\r\nskb->protocol = htons(ETH_P_IPV6);\r\nelse if (memcmp(skb->data + 6, ethertype_ipv4,\r\nsizeof(ethertype_ipv4)) == 0)\r\nskb->protocol = htons(ETH_P_IP);\r\nelse\r\ngoto error;\r\nskb_pull(skb, sizeof(llc_oui_ipv4));\r\nskb_reset_network_header(skb);\r\nskb->pkt_type = PACKET_HOST;\r\n} else if ((skb->len >= sizeof(llc_oui_pid_pad)) &&\r\n(memcmp(skb->data, llc_oui_pid_pad, 7) == 0)) {\r\nskb_pull(skb, sizeof(llc_oui_pid_pad));\r\nskb->protocol = eth_type_trans(skb, net_dev);\r\n} else\r\ngoto error;\r\n} else {\r\nif (brdev->payload == p_routed) {\r\nstruct iphdr *iph;\r\nskb_reset_network_header(skb);\r\niph = ip_hdr(skb);\r\nif (iph->version == 4)\r\nskb->protocol = htons(ETH_P_IP);\r\nelse if (iph->version == 6)\r\nskb->protocol = htons(ETH_P_IPV6);\r\nelse\r\ngoto error;\r\nskb->pkt_type = PACKET_HOST;\r\n} else {\r\nif (memcmp(skb->data, pad, BR2684_PAD_LEN) != 0)\r\ngoto error;\r\nskb_pull(skb, BR2684_PAD_LEN);\r\nskb->protocol = eth_type_trans(skb, net_dev);\r\n}\r\n}\r\n#ifdef CONFIG_ATM_BR2684_IPFILTER\r\nif (unlikely(packet_fails_filter(skb->protocol, brvcc, skb)))\r\ngoto dropped;\r\n#endif\r\nskb->dev = net_dev;\r\nATM_SKB(skb)->vcc = atmvcc;\r\npr_debug("received packet's protocol: %x\n", ntohs(skb->protocol));\r\nskb_debug(skb);\r\nif (unlikely(!(net_dev->flags & IFF_UP)))\r\ngoto dropped;\r\nnet_dev->stats.rx_packets++;\r\nnet_dev->stats.rx_bytes += skb->len;\r\nmemset(ATM_SKB(skb), 0, sizeof(struct atm_skb_data));\r\nnetif_rx(skb);\r\nreturn;\r\ndropped:\r\nnet_dev->stats.rx_dropped++;\r\ngoto free_skb;\r\nerror:\r\nnet_dev->stats.rx_errors++;\r\nfree_skb:\r\ndev_kfree_skb(skb);\r\n}\r\nstatic int br2684_regvcc(struct atm_vcc *atmvcc, void __user * arg)\r\n{\r\nstruct br2684_vcc *brvcc;\r\nstruct br2684_dev *brdev;\r\nstruct net_device *net_dev;\r\nstruct atm_backend_br2684 be;\r\nint err;\r\nif (copy_from_user(&be, arg, sizeof be))\r\nreturn -EFAULT;\r\nbrvcc = kzalloc(sizeof(struct br2684_vcc), GFP_KERNEL);\r\nif (!brvcc)\r\nreturn -ENOMEM;\r\natomic_set(&brvcc->qspace, 2);\r\nwrite_lock_irq(&devs_lock);\r\nnet_dev = br2684_find_dev(&be.ifspec);\r\nif (net_dev == NULL) {\r\npr_err("tried to attach to non-existent device\n");\r\nerr = -ENXIO;\r\ngoto error;\r\n}\r\nbrdev = BRPRIV(net_dev);\r\nif (atmvcc->push == NULL) {\r\nerr = -EBADFD;\r\ngoto error;\r\n}\r\nif (!list_empty(&brdev->brvccs)) {\r\nerr = -EEXIST;\r\ngoto error;\r\n}\r\nif (be.fcs_in != BR2684_FCSIN_NO ||\r\nbe.fcs_out != BR2684_FCSOUT_NO ||\r\nbe.fcs_auto || be.has_vpiid || be.send_padding ||\r\n(be.encaps != BR2684_ENCAPS_VC &&\r\nbe.encaps != BR2684_ENCAPS_LLC) ||\r\nbe.min_size != 0) {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\npr_debug("vcc=%p, encaps=%d, brvcc=%p\n", atmvcc, be.encaps, brvcc);\r\nif (list_empty(&brdev->brvccs) && !brdev->mac_was_set) {\r\nunsigned char *esi = atmvcc->dev->esi;\r\nif (esi[0] | esi[1] | esi[2] | esi[3] | esi[4] | esi[5])\r\nmemcpy(net_dev->dev_addr, esi, net_dev->addr_len);\r\nelse\r\nnet_dev->dev_addr[2] = 1;\r\n}\r\nlist_add(&brvcc->brvccs, &brdev->brvccs);\r\nwrite_unlock_irq(&devs_lock);\r\nbrvcc->device = net_dev;\r\nbrvcc->atmvcc = atmvcc;\r\natmvcc->user_back = brvcc;\r\nbrvcc->encaps = (enum br2684_encaps)be.encaps;\r\nbrvcc->old_push = atmvcc->push;\r\nbrvcc->old_pop = atmvcc->pop;\r\nbrvcc->old_release_cb = atmvcc->release_cb;\r\nbrvcc->old_owner = atmvcc->owner;\r\nbarrier();\r\natmvcc->push = br2684_push;\r\natmvcc->pop = br2684_pop;\r\natmvcc->release_cb = br2684_release_cb;\r\natmvcc->owner = THIS_MODULE;\r\nif (atmvcc->dev->signal == ATM_PHY_SIG_LOST)\r\nnetif_carrier_off(net_dev);\r\nelse\r\nnetif_carrier_on(net_dev);\r\n__module_get(THIS_MODULE);\r\nvcc_process_recv_queue(atmvcc);\r\nreturn 0;\r\nerror:\r\nwrite_unlock_irq(&devs_lock);\r\nkfree(brvcc);\r\nreturn err;\r\n}\r\nstatic void br2684_setup(struct net_device *netdev)\r\n{\r\nstruct br2684_dev *brdev = BRPRIV(netdev);\r\nether_setup(netdev);\r\nnetdev->hard_header_len += sizeof(llc_oui_pid_pad);\r\nbrdev->net_dev = netdev;\r\nnetdev->netdev_ops = &br2684_netdev_ops;\r\nINIT_LIST_HEAD(&brdev->brvccs);\r\n}\r\nstatic void br2684_setup_routed(struct net_device *netdev)\r\n{\r\nstruct br2684_dev *brdev = BRPRIV(netdev);\r\nbrdev->net_dev = netdev;\r\nnetdev->hard_header_len = sizeof(llc_oui_ipv4);\r\nnetdev->netdev_ops = &br2684_netdev_ops_routed;\r\nnetdev->addr_len = 0;\r\nnetdev->mtu = 1500;\r\nnetdev->type = ARPHRD_PPP;\r\nnetdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\r\nnetdev->tx_queue_len = 100;\r\nINIT_LIST_HEAD(&brdev->brvccs);\r\n}\r\nstatic int br2684_create(void __user *arg)\r\n{\r\nint err;\r\nstruct net_device *netdev;\r\nstruct br2684_dev *brdev;\r\nstruct atm_newif_br2684 ni;\r\nenum br2684_payload payload;\r\npr_debug("\n");\r\nif (copy_from_user(&ni, arg, sizeof ni))\r\nreturn -EFAULT;\r\nif (ni.media & BR2684_FLAG_ROUTED)\r\npayload = p_routed;\r\nelse\r\npayload = p_bridged;\r\nni.media &= 0xffff;\r\nif (ni.media != BR2684_MEDIA_ETHERNET || ni.mtu != 1500)\r\nreturn -EINVAL;\r\nnetdev = alloc_netdev(sizeof(struct br2684_dev),\r\nni.ifname[0] ? ni.ifname : "nas%d",\r\nNET_NAME_UNKNOWN,\r\n(payload == p_routed) ? br2684_setup_routed : br2684_setup);\r\nif (!netdev)\r\nreturn -ENOMEM;\r\nbrdev = BRPRIV(netdev);\r\npr_debug("registered netdev %s\n", netdev->name);\r\nerr = register_netdev(netdev);\r\nif (err < 0) {\r\npr_err("register_netdev failed\n");\r\nfree_netdev(netdev);\r\nreturn err;\r\n}\r\nwrite_lock_irq(&devs_lock);\r\nbrdev->payload = payload;\r\nif (list_empty(&br2684_devs)) {\r\nbrdev->number = 1;\r\n} else\r\nbrdev->number = BRPRIV(list_entry_brdev(br2684_devs.prev))->number + 1;\r\nlist_add_tail(&brdev->br2684_devs, &br2684_devs);\r\nwrite_unlock_irq(&devs_lock);\r\nreturn 0;\r\n}\r\nstatic int br2684_ioctl(struct socket *sock, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct atm_vcc *atmvcc = ATM_SD(sock);\r\nvoid __user *argp = (void __user *)arg;\r\natm_backend_t b;\r\nint err;\r\nswitch (cmd) {\r\ncase ATM_SETBACKEND:\r\ncase ATM_NEWBACKENDIF:\r\nerr = get_user(b, (atm_backend_t __user *) argp);\r\nif (err)\r\nreturn -EFAULT;\r\nif (b != ATM_BACKEND_BR2684)\r\nreturn -ENOIOCTLCMD;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (cmd == ATM_SETBACKEND) {\r\nif (sock->state != SS_CONNECTED)\r\nreturn -EINVAL;\r\nreturn br2684_regvcc(atmvcc, argp);\r\n} else {\r\nreturn br2684_create(argp);\r\n}\r\n#ifdef CONFIG_ATM_BR2684_IPFILTER\r\ncase BR2684_SETFILT:\r\nif (atmvcc->push != br2684_push)\r\nreturn -ENOIOCTLCMD;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nerr = br2684_setfilt(atmvcc, argp);\r\nreturn err;\r\n#endif\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void *br2684_seq_start(struct seq_file *seq, loff_t * pos)\r\n__acquires(devs_lock)\r\n{\r\nread_lock(&devs_lock);\r\nreturn seq_list_start(&br2684_devs, *pos);\r\n}\r\nstatic void *br2684_seq_next(struct seq_file *seq, void *v, loff_t * pos)\r\n{\r\nreturn seq_list_next(v, &br2684_devs, pos);\r\n}\r\nstatic void br2684_seq_stop(struct seq_file *seq, void *v)\r\n__releases(devs_lock)\r\n{\r\nread_unlock(&devs_lock);\r\n}\r\nstatic int br2684_seq_show(struct seq_file *seq, void *v)\r\n{\r\nconst struct br2684_dev *brdev = list_entry(v, struct br2684_dev,\r\nbr2684_devs);\r\nconst struct net_device *net_dev = brdev->net_dev;\r\nconst struct br2684_vcc *brvcc;\r\nseq_printf(seq, "dev %.16s: num=%d, mac=%pM (%s)\n",\r\nnet_dev->name,\r\nbrdev->number,\r\nnet_dev->dev_addr,\r\nbrdev->mac_was_set ? "set" : "auto");\r\nlist_for_each_entry(brvcc, &brdev->brvccs, brvccs) {\r\nseq_printf(seq, " vcc %d.%d.%d: encaps=%s payload=%s"\r\n", failed copies %u/%u"\r\n"\n", brvcc->atmvcc->dev->number,\r\nbrvcc->atmvcc->vpi, brvcc->atmvcc->vci,\r\n(brvcc->encaps == e_llc) ? "LLC" : "VC",\r\n(brdev->payload == p_bridged) ? "bridged" : "routed",\r\nbrvcc->copies_failed, brvcc->copies_needed);\r\n#ifdef CONFIG_ATM_BR2684_IPFILTER\r\nif (brvcc->filter.netmask != 0)\r\nseq_printf(seq, " filter=%pI4/%pI4\n",\r\n&brvcc->filter.prefix,\r\n&brvcc->filter.netmask);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic int br2684_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &br2684_seq_ops);\r\n}\r\nstatic int __init br2684_init(void)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\nstruct proc_dir_entry *p;\r\np = proc_create("br2684", 0, atm_proc_root, &br2684_proc_ops);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\n#endif\r\nregister_atm_ioctl(&br2684_ioctl_ops);\r\nregister_atmdevice_notifier(&atm_dev_notifier);\r\nreturn 0;\r\n}\r\nstatic void __exit br2684_exit(void)\r\n{\r\nstruct net_device *net_dev;\r\nstruct br2684_dev *brdev;\r\nstruct br2684_vcc *brvcc;\r\nderegister_atm_ioctl(&br2684_ioctl_ops);\r\n#ifdef CONFIG_PROC_FS\r\nremove_proc_entry("br2684", atm_proc_root);\r\n#endif\r\nunregister_atmdevice_notifier(&atm_dev_notifier);\r\nwhile (!list_empty(&br2684_devs)) {\r\nnet_dev = list_entry_brdev(br2684_devs.next);\r\nbrdev = BRPRIV(net_dev);\r\nwhile (!list_empty(&brdev->brvccs)) {\r\nbrvcc = list_entry_brvcc(brdev->brvccs.next);\r\nbr2684_close_vcc(brvcc);\r\n}\r\nlist_del(&brdev->br2684_devs);\r\nunregister_netdev(net_dev);\r\nfree_netdev(net_dev);\r\n}\r\n}
