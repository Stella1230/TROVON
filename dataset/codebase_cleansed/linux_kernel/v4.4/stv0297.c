static int stv0297_writereg(struct stv0297_state *state, u8 reg, u8 data)\r\n{\r\nint ret;\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = {.addr = state->config->demod_address,.flags = 0,.buf = buf,.len = 2 };\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1)\r\ndprintk("%s: writereg error (reg == 0x%02x, val == 0x%02x, "\r\n"ret == %i)\n", __func__, reg, data, ret);\r\nreturn (ret != 1) ? -1 : 0;\r\n}\r\nstatic int stv0297_readreg(struct stv0297_state *state, u8 reg)\r\n{\r\nint ret;\r\nu8 b0[] = { reg };\r\nu8 b1[] = { 0 };\r\nstruct i2c_msg msg[] = { {.addr = state->config->demod_address,.flags = 0,.buf = b0,.len = 1},\r\n{.addr = state->config->demod_address,.flags = I2C_M_RD,.buf = b1,.len = 1}\r\n};\r\nif (state->config->stop_during_read) {\r\nif ((ret = i2c_transfer(state->i2c, &msg[0], 1)) != 1) {\r\ndprintk("%s: readreg error (reg == 0x%02x, ret == %i)\n", __func__, reg, ret);\r\nreturn -1;\r\n}\r\nif ((ret = i2c_transfer(state->i2c, &msg[1], 1)) != 1) {\r\ndprintk("%s: readreg error (reg == 0x%02x, ret == %i)\n", __func__, reg, ret);\r\nreturn -1;\r\n}\r\n} else {\r\nif ((ret = i2c_transfer(state->i2c, msg, 2)) != 2) {\r\ndprintk("%s: readreg error (reg == 0x%02x, ret == %i)\n", __func__, reg, ret);\r\nreturn -1;\r\n}\r\n}\r\nreturn b1[0];\r\n}\r\nstatic int stv0297_writereg_mask(struct stv0297_state *state, u8 reg, u8 mask, u8 data)\r\n{\r\nint val;\r\nval = stv0297_readreg(state, reg);\r\nval &= ~mask;\r\nval |= (data & mask);\r\nstv0297_writereg(state, reg, val);\r\nreturn 0;\r\n}\r\nstatic int stv0297_readregs(struct stv0297_state *state, u8 reg1, u8 * b, u8 len)\r\n{\r\nint ret;\r\nstruct i2c_msg msg[] = { {.addr = state->config->demod_address,.flags = 0,.buf =\r\n&reg1,.len = 1},\r\n{.addr = state->config->demod_address,.flags = I2C_M_RD,.buf = b,.len = len}\r\n};\r\nif (state->config->stop_during_read) {\r\nif ((ret = i2c_transfer(state->i2c, &msg[0], 1)) != 1) {\r\ndprintk("%s: readreg error (reg == 0x%02x, ret == %i)\n", __func__, reg1, ret);\r\nreturn -1;\r\n}\r\nif ((ret = i2c_transfer(state->i2c, &msg[1], 1)) != 1) {\r\ndprintk("%s: readreg error (reg == 0x%02x, ret == %i)\n", __func__, reg1, ret);\r\nreturn -1;\r\n}\r\n} else {\r\nif ((ret = i2c_transfer(state->i2c, msg, 2)) != 2) {\r\ndprintk("%s: readreg error (reg == 0x%02x, ret == %i)\n", __func__, reg1, ret);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 stv0297_get_symbolrate(struct stv0297_state *state)\r\n{\r\nu64 tmp;\r\ntmp = (u64)(stv0297_readreg(state, 0x55)\r\n| (stv0297_readreg(state, 0x56) << 8)\r\n| (stv0297_readreg(state, 0x57) << 16)\r\n| (stv0297_readreg(state, 0x58) << 24));\r\ntmp *= STV0297_CLOCK_KHZ;\r\ntmp >>= 32;\r\nreturn (u32) tmp;\r\n}\r\nstatic void stv0297_set_symbolrate(struct stv0297_state *state, u32 srate)\r\n{\r\nlong tmp;\r\ntmp = 131072L * srate;\r\ntmp = tmp / (STV0297_CLOCK_KHZ / 4);\r\ntmp = tmp * 8192L;\r\nstv0297_writereg(state, 0x55, (unsigned char) (tmp & 0xFF));\r\nstv0297_writereg(state, 0x56, (unsigned char) (tmp >> 8));\r\nstv0297_writereg(state, 0x57, (unsigned char) (tmp >> 16));\r\nstv0297_writereg(state, 0x58, (unsigned char) (tmp >> 24));\r\n}\r\nstatic void stv0297_set_sweeprate(struct stv0297_state *state, short fshift, long symrate)\r\n{\r\nlong tmp;\r\ntmp = (long) fshift *262144L;\r\ntmp /= symrate;\r\ntmp *= 1024;\r\nif (tmp >= 0) {\r\ntmp += 500000;\r\n} else {\r\ntmp -= 500000;\r\n}\r\ntmp /= 1000000;\r\nstv0297_writereg(state, 0x60, tmp & 0xFF);\r\nstv0297_writereg_mask(state, 0x69, 0xF0, (tmp >> 4) & 0xf0);\r\n}\r\nstatic void stv0297_set_carrieroffset(struct stv0297_state *state, long offset)\r\n{\r\nlong tmp;\r\ntmp = offset * 26844L;\r\nif (tmp < 0)\r\ntmp += 0x10000000;\r\ntmp &= 0x0FFFFFFF;\r\nstv0297_writereg(state, 0x66, (unsigned char) (tmp & 0xFF));\r\nstv0297_writereg(state, 0x67, (unsigned char) (tmp >> 8));\r\nstv0297_writereg(state, 0x68, (unsigned char) (tmp >> 16));\r\nstv0297_writereg_mask(state, 0x69, 0x0F, (tmp >> 24) & 0x0f);\r\n}\r\nstatic void stv0297_set_initialdemodfreq(struct stv0297_state *state, long freq)\r\n{\r\ns32 tmp;\r\nif (freq > 10000)\r\nfreq -= STV0297_CLOCK_KHZ;\r\ntmp = (STV0297_CLOCK_KHZ * 1000) / (1 << 16);\r\ntmp = (freq * 1000) / tmp;\r\nif (tmp > 0xffff)\r\ntmp = 0xffff;\r\nstv0297_writereg_mask(state, 0x25, 0x80, 0x80);\r\nstv0297_writereg(state, 0x21, tmp >> 8);\r\nstv0297_writereg(state, 0x20, tmp);\r\n}\r\nstatic int stv0297_set_qam(struct stv0297_state *state,\r\nenum fe_modulation modulation)\r\n{\r\nint val = 0;\r\nswitch (modulation) {\r\ncase QAM_16:\r\nval = 0;\r\nbreak;\r\ncase QAM_32:\r\nval = 1;\r\nbreak;\r\ncase QAM_64:\r\nval = 4;\r\nbreak;\r\ncase QAM_128:\r\nval = 2;\r\nbreak;\r\ncase QAM_256:\r\nval = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nstv0297_writereg_mask(state, 0x00, 0x70, val << 4);\r\nreturn 0;\r\n}\r\nstatic int stv0297_set_inversion(struct stv0297_state *state,\r\nenum fe_spectral_inversion inversion)\r\n{\r\nint val = 0;\r\nswitch (inversion) {\r\ncase INVERSION_OFF:\r\nval = 0;\r\nbreak;\r\ncase INVERSION_ON:\r\nval = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nstv0297_writereg_mask(state, 0x83, 0x08, val << 3);\r\nreturn 0;\r\n}\r\nstatic int stv0297_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct stv0297_state *state = fe->demodulator_priv;\r\nif (enable) {\r\nstv0297_writereg(state, 0x87, 0x78);\r\nstv0297_writereg(state, 0x86, 0xc8);\r\n}\r\nreturn 0;\r\n}\r\nstatic int stv0297_init(struct dvb_frontend *fe)\r\n{\r\nstruct stv0297_state *state = fe->demodulator_priv;\r\nint i;\r\nfor (i=0; !(state->config->inittab[i] == 0xff && state->config->inittab[i+1] == 0xff); i+=2)\r\nstv0297_writereg(state, state->config->inittab[i], state->config->inittab[i+1]);\r\nmsleep(200);\r\nstate->last_ber = 0;\r\nreturn 0;\r\n}\r\nstatic int stv0297_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct stv0297_state *state = fe->demodulator_priv;\r\nstv0297_writereg_mask(state, 0x80, 1, 1);\r\nreturn 0;\r\n}\r\nstatic int stv0297_read_status(struct dvb_frontend *fe,\r\nenum fe_status *status)\r\n{\r\nstruct stv0297_state *state = fe->demodulator_priv;\r\nu8 sync = stv0297_readreg(state, 0xDF);\r\n*status = 0;\r\nif (sync & 0x80)\r\n*status |=\r\nFE_HAS_SYNC | FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int stv0297_read_ber(struct dvb_frontend *fe, u32 * ber)\r\n{\r\nstruct stv0297_state *state = fe->demodulator_priv;\r\nu8 BER[3];\r\nstv0297_readregs(state, 0xA0, BER, 3);\r\nif (!(BER[0] & 0x80)) {\r\nstate->last_ber = BER[2] << 8 | BER[1];\r\nstv0297_writereg_mask(state, 0xA0, 0x80, 0x80);\r\n}\r\n*ber = state->last_ber;\r\nreturn 0;\r\n}\r\nstatic int stv0297_read_signal_strength(struct dvb_frontend *fe, u16 * strength)\r\n{\r\nstruct stv0297_state *state = fe->demodulator_priv;\r\nu8 STRENGTH[3];\r\nu16 tmp;\r\nstv0297_readregs(state, 0x41, STRENGTH, 3);\r\ntmp = (STRENGTH[1] & 0x03) << 8 | STRENGTH[0];\r\nif (STRENGTH[2] & 0x20) {\r\nif (tmp < 0x200)\r\ntmp = 0;\r\nelse\r\ntmp = tmp - 0x200;\r\n} else {\r\nif (tmp > 0x1ff)\r\ntmp = 0;\r\nelse\r\ntmp = 0x1ff - tmp;\r\n}\r\n*strength = (tmp << 7) | (tmp >> 2);\r\nreturn 0;\r\n}\r\nstatic int stv0297_read_snr(struct dvb_frontend *fe, u16 * snr)\r\n{\r\nstruct stv0297_state *state = fe->demodulator_priv;\r\nu8 SNR[2];\r\nstv0297_readregs(state, 0x07, SNR, 2);\r\n*snr = SNR[1] << 8 | SNR[0];\r\nreturn 0;\r\n}\r\nstatic int stv0297_read_ucblocks(struct dvb_frontend *fe, u32 * ucblocks)\r\n{\r\nstruct stv0297_state *state = fe->demodulator_priv;\r\nstv0297_writereg_mask(state, 0xDF, 0x03, 0x03);\r\n*ucblocks = (stv0297_readreg(state, 0xD5) << 8)\r\n| stv0297_readreg(state, 0xD4);\r\nstv0297_writereg_mask(state, 0xDF, 0x03, 0x02);\r\nstv0297_writereg_mask(state, 0xDF, 0x03, 0x01);\r\nreturn 0;\r\n}\r\nstatic int stv0297_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct stv0297_state *state = fe->demodulator_priv;\r\nint u_threshold;\r\nint initial_u;\r\nint blind_u;\r\nint delay;\r\nint sweeprate;\r\nint carrieroffset;\r\nunsigned long timeout;\r\nenum fe_spectral_inversion inversion;\r\nswitch (p->modulation) {\r\ncase QAM_16:\r\ncase QAM_32:\r\ncase QAM_64:\r\ndelay = 100;\r\nsweeprate = 1000;\r\nbreak;\r\ncase QAM_128:\r\ncase QAM_256:\r\ndelay = 200;\r\nsweeprate = 500;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ninversion = p->inversion;\r\nif (state->config->invert)\r\ninversion = (inversion == INVERSION_ON) ? INVERSION_OFF : INVERSION_ON;\r\ncarrieroffset = -330;\r\nswitch (inversion) {\r\ncase INVERSION_OFF:\r\nbreak;\r\ncase INVERSION_ON:\r\nsweeprate = -sweeprate;\r\ncarrieroffset = -carrieroffset;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nstv0297_init(fe);\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nstv0297_writereg(state, 0x82, 0x0);\r\nstv0297_set_initialdemodfreq(state, 7250);\r\nstv0297_writereg_mask(state, 0x43, 0x10, 0x00);\r\nstv0297_writereg(state, 0x41, 0x00);\r\nstv0297_writereg_mask(state, 0x42, 0x03, 0x01);\r\nstv0297_writereg_mask(state, 0x36, 0x60, 0x00);\r\nstv0297_writereg_mask(state, 0x36, 0x18, 0x00);\r\nstv0297_writereg_mask(state, 0x71, 0x80, 0x80);\r\nstv0297_writereg(state, 0x72, 0x00);\r\nstv0297_writereg(state, 0x73, 0x00);\r\nstv0297_writereg_mask(state, 0x74, 0x0F, 0x00);\r\nstv0297_writereg_mask(state, 0x43, 0x08, 0x00);\r\nstv0297_writereg_mask(state, 0x71, 0x80, 0x00);\r\nstv0297_writereg_mask(state, 0x5a, 0x20, 0x20);\r\nstv0297_writereg_mask(state, 0x5b, 0x02, 0x02);\r\nstv0297_writereg_mask(state, 0x5b, 0x02, 0x00);\r\nstv0297_writereg_mask(state, 0x5b, 0x01, 0x00);\r\nstv0297_writereg_mask(state, 0x5a, 0x40, 0x40);\r\nstv0297_writereg_mask(state, 0x6a, 0x01, 0x00);\r\nstv0297_writereg_mask(state, 0x81, 0x01, 0x01);\r\nstv0297_writereg_mask(state, 0x81, 0x01, 0x00);\r\nstv0297_writereg_mask(state, 0x83, 0x20, 0x20);\r\nstv0297_writereg_mask(state, 0x83, 0x20, 0x00);\r\nu_threshold = stv0297_readreg(state, 0x00) & 0xf;\r\ninitial_u = stv0297_readreg(state, 0x01) >> 4;\r\nblind_u = stv0297_readreg(state, 0x01) & 0xf;\r\nstv0297_writereg_mask(state, 0x84, 0x01, 0x01);\r\nstv0297_writereg_mask(state, 0x84, 0x01, 0x00);\r\nstv0297_writereg_mask(state, 0x00, 0x0f, u_threshold);\r\nstv0297_writereg_mask(state, 0x01, 0xf0, initial_u << 4);\r\nstv0297_writereg_mask(state, 0x01, 0x0f, blind_u);\r\nstv0297_writereg_mask(state, 0x87, 0x80, 0x00);\r\nstv0297_writereg(state, 0x63, 0x00);\r\nstv0297_writereg(state, 0x64, 0x00);\r\nstv0297_writereg(state, 0x65, 0x00);\r\nstv0297_writereg(state, 0x66, 0x00);\r\nstv0297_writereg(state, 0x67, 0x00);\r\nstv0297_writereg(state, 0x68, 0x00);\r\nstv0297_writereg_mask(state, 0x69, 0x0f, 0x00);\r\nstv0297_set_qam(state, p->modulation);\r\nstv0297_set_symbolrate(state, p->symbol_rate / 1000);\r\nstv0297_set_sweeprate(state, sweeprate, p->symbol_rate / 1000);\r\nstv0297_set_carrieroffset(state, carrieroffset);\r\nstv0297_set_inversion(state, inversion);\r\nif (p->modulation == QAM_128 ||\r\np->modulation == QAM_256)\r\nstv0297_writereg_mask(state, 0x88, 0x08, 0x00);\r\nelse\r\nstv0297_writereg_mask(state, 0x88, 0x08, 0x08);\r\nstv0297_writereg_mask(state, 0x5a, 0x20, 0x00);\r\nstv0297_writereg_mask(state, 0x6a, 0x01, 0x01);\r\nstv0297_writereg_mask(state, 0x43, 0x40, 0x40);\r\nstv0297_writereg_mask(state, 0x5b, 0x30, 0x00);\r\nstv0297_writereg_mask(state, 0x03, 0x0c, 0x0c);\r\nstv0297_writereg_mask(state, 0x03, 0x03, 0x03);\r\nstv0297_writereg_mask(state, 0x43, 0x10, 0x10);\r\ntimeout = jiffies + msecs_to_jiffies(2000);\r\nwhile (time_before(jiffies, timeout)) {\r\nmsleep(10);\r\nif (stv0297_readreg(state, 0x43) & 0x08)\r\nbreak;\r\n}\r\nif (time_after(jiffies, timeout)) {\r\ngoto timeout;\r\n}\r\nmsleep(20);\r\ntimeout = jiffies + msecs_to_jiffies(500);\r\nwhile (time_before(jiffies, timeout)) {\r\nmsleep(10);\r\nif (stv0297_readreg(state, 0x82) & 0x04) {\r\nbreak;\r\n}\r\n}\r\nif (time_after(jiffies, timeout)) {\r\ngoto timeout;\r\n}\r\ntimeout = jiffies + msecs_to_jiffies(delay);\r\nwhile (time_before(jiffies, timeout)) {\r\nmsleep(10);\r\nif (stv0297_readreg(state, 0x82) & 0x08) {\r\nbreak;\r\n}\r\n}\r\nif (time_after(jiffies, timeout)) {\r\ngoto timeout;\r\n}\r\nstv0297_writereg_mask(state, 0x6a, 1, 0);\r\nstv0297_writereg_mask(state, 0x88, 8, 0);\r\ntimeout = jiffies + msecs_to_jiffies(20);\r\nwhile (time_before(jiffies, timeout)) {\r\nmsleep(10);\r\nif (stv0297_readreg(state, 0xDF) & 0x80) {\r\nbreak;\r\n}\r\n}\r\nif (time_after(jiffies, timeout)) {\r\ngoto timeout;\r\n}\r\nmsleep(100);\r\nif (!(stv0297_readreg(state, 0xDF) & 0x80)) {\r\ngoto timeout;\r\n}\r\nstv0297_writereg_mask(state, 0x5a, 0x40, 0x00);\r\nstate->base_freq = p->frequency;\r\nreturn 0;\r\ntimeout:\r\nstv0297_writereg_mask(state, 0x6a, 0x01, 0x00);\r\nreturn 0;\r\n}\r\nstatic int stv0297_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct stv0297_state *state = fe->demodulator_priv;\r\nint reg_00, reg_83;\r\nreg_00 = stv0297_readreg(state, 0x00);\r\nreg_83 = stv0297_readreg(state, 0x83);\r\np->frequency = state->base_freq;\r\np->inversion = (reg_83 & 0x08) ? INVERSION_ON : INVERSION_OFF;\r\nif (state->config->invert)\r\np->inversion = (p->inversion == INVERSION_ON) ? INVERSION_OFF : INVERSION_ON;\r\np->symbol_rate = stv0297_get_symbolrate(state) * 1000;\r\np->fec_inner = FEC_NONE;\r\nswitch ((reg_00 >> 4) & 0x7) {\r\ncase 0:\r\np->modulation = QAM_16;\r\nbreak;\r\ncase 1:\r\np->modulation = QAM_32;\r\nbreak;\r\ncase 2:\r\np->modulation = QAM_128;\r\nbreak;\r\ncase 3:\r\np->modulation = QAM_256;\r\nbreak;\r\ncase 4:\r\np->modulation = QAM_64;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void stv0297_release(struct dvb_frontend *fe)\r\n{\r\nstruct stv0297_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *stv0297_attach(const struct stv0297_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct stv0297_state *state = NULL;\r\nstate = kzalloc(sizeof(struct stv0297_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->last_ber = 0;\r\nstate->base_freq = 0;\r\nif ((stv0297_readreg(state, 0x80) & 0x70) != 0x20)\r\ngoto error;\r\nmemcpy(&state->frontend.ops, &stv0297_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
