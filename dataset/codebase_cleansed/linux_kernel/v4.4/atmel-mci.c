static int atmci_req_show(struct seq_file *s, void *v)\r\n{\r\nstruct atmel_mci_slot *slot = s->private;\r\nstruct mmc_request *mrq;\r\nstruct mmc_command *cmd;\r\nstruct mmc_command *stop;\r\nstruct mmc_data *data;\r\nspin_lock_bh(&slot->host->lock);\r\nmrq = slot->mrq;\r\nif (mrq) {\r\ncmd = mrq->cmd;\r\ndata = mrq->data;\r\nstop = mrq->stop;\r\nif (cmd)\r\nseq_printf(s,\r\n"CMD%u(0x%x) flg %x rsp %x %x %x %x err %d\n",\r\ncmd->opcode, cmd->arg, cmd->flags,\r\ncmd->resp[0], cmd->resp[1], cmd->resp[2],\r\ncmd->resp[3], cmd->error);\r\nif (data)\r\nseq_printf(s, "DATA %u / %u * %u flg %x err %d\n",\r\ndata->bytes_xfered, data->blocks,\r\ndata->blksz, data->flags, data->error);\r\nif (stop)\r\nseq_printf(s,\r\n"CMD%u(0x%x) flg %x rsp %x %x %x %x err %d\n",\r\nstop->opcode, stop->arg, stop->flags,\r\nstop->resp[0], stop->resp[1], stop->resp[2],\r\nstop->resp[3], stop->error);\r\n}\r\nspin_unlock_bh(&slot->host->lock);\r\nreturn 0;\r\n}\r\nstatic int atmci_req_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, atmci_req_show, inode->i_private);\r\n}\r\nstatic void atmci_show_status_reg(struct seq_file *s,\r\nconst char *regname, u32 value)\r\n{\r\nstatic const char *sr_bit[] = {\r\n[0] = "CMDRDY",\r\n[1] = "RXRDY",\r\n[2] = "TXRDY",\r\n[3] = "BLKE",\r\n[4] = "DTIP",\r\n[5] = "NOTBUSY",\r\n[6] = "ENDRX",\r\n[7] = "ENDTX",\r\n[8] = "SDIOIRQA",\r\n[9] = "SDIOIRQB",\r\n[12] = "SDIOWAIT",\r\n[14] = "RXBUFF",\r\n[15] = "TXBUFE",\r\n[16] = "RINDE",\r\n[17] = "RDIRE",\r\n[18] = "RCRCE",\r\n[19] = "RENDE",\r\n[20] = "RTOE",\r\n[21] = "DCRCE",\r\n[22] = "DTOE",\r\n[23] = "CSTOE",\r\n[24] = "BLKOVRE",\r\n[25] = "DMADONE",\r\n[26] = "FIFOEMPTY",\r\n[27] = "XFRDONE",\r\n[30] = "OVRE",\r\n[31] = "UNRE",\r\n};\r\nunsigned int i;\r\nseq_printf(s, "%s:\t0x%08x", regname, value);\r\nfor (i = 0; i < ARRAY_SIZE(sr_bit); i++) {\r\nif (value & (1 << i)) {\r\nif (sr_bit[i])\r\nseq_printf(s, " %s", sr_bit[i]);\r\nelse\r\nseq_puts(s, " UNKNOWN");\r\n}\r\n}\r\nseq_putc(s, '\n');\r\n}\r\nstatic int atmci_regs_show(struct seq_file *s, void *v)\r\n{\r\nstruct atmel_mci *host = s->private;\r\nu32 *buf;\r\nint ret = 0;\r\nbuf = kmalloc(ATMCI_REGS_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\npm_runtime_get_sync(&host->pdev->dev);\r\nspin_lock_bh(&host->lock);\r\nmemcpy_fromio(buf, host->regs, ATMCI_REGS_SIZE);\r\nspin_unlock_bh(&host->lock);\r\npm_runtime_mark_last_busy(&host->pdev->dev);\r\npm_runtime_put_autosuspend(&host->pdev->dev);\r\nseq_printf(s, "MR:\t0x%08x%s%s ",\r\nbuf[ATMCI_MR / 4],\r\nbuf[ATMCI_MR / 4] & ATMCI_MR_RDPROOF ? " RDPROOF" : "",\r\nbuf[ATMCI_MR / 4] & ATMCI_MR_WRPROOF ? " WRPROOF" : "");\r\nif (host->caps.has_odd_clk_div)\r\nseq_printf(s, "{CLKDIV,CLKODD}=%u\n",\r\n((buf[ATMCI_MR / 4] & 0xff) << 1)\r\n| ((buf[ATMCI_MR / 4] >> 16) & 1));\r\nelse\r\nseq_printf(s, "CLKDIV=%u\n",\r\n(buf[ATMCI_MR / 4] & 0xff));\r\nseq_printf(s, "DTOR:\t0x%08x\n", buf[ATMCI_DTOR / 4]);\r\nseq_printf(s, "SDCR:\t0x%08x\n", buf[ATMCI_SDCR / 4]);\r\nseq_printf(s, "ARGR:\t0x%08x\n", buf[ATMCI_ARGR / 4]);\r\nseq_printf(s, "BLKR:\t0x%08x BCNT=%u BLKLEN=%u\n",\r\nbuf[ATMCI_BLKR / 4],\r\nbuf[ATMCI_BLKR / 4] & 0xffff,\r\n(buf[ATMCI_BLKR / 4] >> 16) & 0xffff);\r\nif (host->caps.has_cstor_reg)\r\nseq_printf(s, "CSTOR:\t0x%08x\n", buf[ATMCI_CSTOR / 4]);\r\natmci_show_status_reg(s, "SR", buf[ATMCI_SR / 4]);\r\natmci_show_status_reg(s, "IMR", buf[ATMCI_IMR / 4]);\r\nif (host->caps.has_dma_conf_reg) {\r\nu32 val;\r\nval = buf[ATMCI_DMA / 4];\r\nseq_printf(s, "DMA:\t0x%08x OFFSET=%u CHKSIZE=%u%s\n",\r\nval, val & 3,\r\n((val >> 4) & 3) ?\r\n1 << (((val >> 4) & 3) + 1) : 1,\r\nval & ATMCI_DMAEN ? " DMAEN" : "");\r\n}\r\nif (host->caps.has_cfg_reg) {\r\nu32 val;\r\nval = buf[ATMCI_CFG / 4];\r\nseq_printf(s, "CFG:\t0x%08x%s%s%s%s\n",\r\nval,\r\nval & ATMCI_CFG_FIFOMODE_1DATA ? " FIFOMODE_ONE_DATA" : "",\r\nval & ATMCI_CFG_FERRCTRL_COR ? " FERRCTRL_CLEAR_ON_READ" : "",\r\nval & ATMCI_CFG_HSMODE ? " HSMODE" : "",\r\nval & ATMCI_CFG_LSYNC ? " LSYNC" : "");\r\n}\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int atmci_regs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, atmci_regs_show, inode->i_private);\r\n}\r\nstatic void atmci_init_debugfs(struct atmel_mci_slot *slot)\r\n{\r\nstruct mmc_host *mmc = slot->mmc;\r\nstruct atmel_mci *host = slot->host;\r\nstruct dentry *root;\r\nstruct dentry *node;\r\nroot = mmc->debugfs_root;\r\nif (!root)\r\nreturn;\r\nnode = debugfs_create_file("regs", S_IRUSR, root, host,\r\n&atmci_regs_fops);\r\nif (IS_ERR(node))\r\nreturn;\r\nif (!node)\r\ngoto err;\r\nnode = debugfs_create_file("req", S_IRUSR, root, slot, &atmci_req_fops);\r\nif (!node)\r\ngoto err;\r\nnode = debugfs_create_u32("state", S_IRUSR, root, (u32 *)&host->state);\r\nif (!node)\r\ngoto err;\r\nnode = debugfs_create_x32("pending_events", S_IRUSR, root,\r\n(u32 *)&host->pending_events);\r\nif (!node)\r\ngoto err;\r\nnode = debugfs_create_x32("completed_events", S_IRUSR, root,\r\n(u32 *)&host->completed_events);\r\nif (!node)\r\ngoto err;\r\nreturn;\r\nerr:\r\ndev_err(&mmc->class_dev, "failed to initialize debugfs for slot\n");\r\n}\r\nstatic struct mci_platform_data*\r\natmci_of_init(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *cnp;\r\nstruct mci_platform_data *pdata;\r\nu32 slot_id;\r\nif (!np) {\r\ndev_err(&pdev->dev, "device node not found\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "could not allocate memory for pdata\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nfor_each_child_of_node(np, cnp) {\r\nif (of_property_read_u32(cnp, "reg", &slot_id)) {\r\ndev_warn(&pdev->dev, "reg property is missing for %s\n",\r\ncnp->full_name);\r\ncontinue;\r\n}\r\nif (slot_id >= ATMCI_MAX_NR_SLOTS) {\r\ndev_warn(&pdev->dev, "can't have more than %d slots\n",\r\nATMCI_MAX_NR_SLOTS);\r\nbreak;\r\n}\r\nif (of_property_read_u32(cnp, "bus-width",\r\n&pdata->slot[slot_id].bus_width))\r\npdata->slot[slot_id].bus_width = 1;\r\npdata->slot[slot_id].detect_pin =\r\nof_get_named_gpio(cnp, "cd-gpios", 0);\r\npdata->slot[slot_id].detect_is_active_high =\r\nof_property_read_bool(cnp, "cd-inverted");\r\npdata->slot[slot_id].non_removable =\r\nof_property_read_bool(cnp, "non-removable");\r\npdata->slot[slot_id].wp_pin =\r\nof_get_named_gpio(cnp, "wp-gpios", 0);\r\n}\r\nreturn pdata;\r\n}\r\nstatic inline struct mci_platform_data*\r\natmci_of_init(struct platform_device *dev)\r\n{\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic inline unsigned int atmci_get_version(struct atmel_mci *host)\r\n{\r\nreturn atmci_readl(host, ATMCI_VERSION) & 0x00000fff;\r\n}\r\nstatic void atmci_timeout_timer(unsigned long data)\r\n{\r\nstruct atmel_mci *host;\r\nhost = (struct atmel_mci *)data;\r\ndev_dbg(&host->pdev->dev, "software timeout\n");\r\nif (host->mrq->cmd->data) {\r\nhost->mrq->cmd->data->error = -ETIMEDOUT;\r\nhost->data = NULL;\r\nif (host->state == STATE_DATA_XFER)\r\nhost->stop_transfer(host);\r\n} else {\r\nhost->mrq->cmd->error = -ETIMEDOUT;\r\nhost->cmd = NULL;\r\n}\r\nhost->need_reset = 1;\r\nhost->state = STATE_END_REQUEST;\r\nsmp_wmb();\r\ntasklet_schedule(&host->tasklet);\r\n}\r\nstatic inline unsigned int atmci_ns_to_clocks(struct atmel_mci *host,\r\nunsigned int ns)\r\n{\r\nunsigned int us = DIV_ROUND_UP(ns, 1000);\r\nreturn us * (DIV_ROUND_UP(host->bus_hz, 2000000));\r\n}\r\nstatic void atmci_set_timeout(struct atmel_mci *host,\r\nstruct atmel_mci_slot *slot, struct mmc_data *data)\r\n{\r\nstatic unsigned dtomul_to_shift[] = {\r\n0, 4, 7, 8, 10, 12, 16, 20\r\n};\r\nunsigned timeout;\r\nunsigned dtocyc;\r\nunsigned dtomul;\r\ntimeout = atmci_ns_to_clocks(host, data->timeout_ns)\r\n+ data->timeout_clks;\r\nfor (dtomul = 0; dtomul < 8; dtomul++) {\r\nunsigned shift = dtomul_to_shift[dtomul];\r\ndtocyc = (timeout + (1 << shift) - 1) >> shift;\r\nif (dtocyc < 15)\r\nbreak;\r\n}\r\nif (dtomul >= 8) {\r\ndtomul = 7;\r\ndtocyc = 15;\r\n}\r\ndev_vdbg(&slot->mmc->class_dev, "setting timeout to %u cycles\n",\r\ndtocyc << dtomul_to_shift[dtomul]);\r\natmci_writel(host, ATMCI_DTOR, (ATMCI_DTOMUL(dtomul) | ATMCI_DTOCYC(dtocyc)));\r\n}\r\nstatic u32 atmci_prepare_command(struct mmc_host *mmc,\r\nstruct mmc_command *cmd)\r\n{\r\nstruct mmc_data *data;\r\nu32 cmdr;\r\ncmd->error = -EINPROGRESS;\r\ncmdr = ATMCI_CMDR_CMDNB(cmd->opcode);\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\nif (cmd->flags & MMC_RSP_136)\r\ncmdr |= ATMCI_CMDR_RSPTYP_136BIT;\r\nelse\r\ncmdr |= ATMCI_CMDR_RSPTYP_48BIT;\r\n}\r\ncmdr |= ATMCI_CMDR_MAXLAT_64CYC;\r\nif (mmc->ios.bus_mode == MMC_BUSMODE_OPENDRAIN)\r\ncmdr |= ATMCI_CMDR_OPDCMD;\r\ndata = cmd->data;\r\nif (data) {\r\ncmdr |= ATMCI_CMDR_START_XFER;\r\nif (cmd->opcode == SD_IO_RW_EXTENDED) {\r\ncmdr |= ATMCI_CMDR_SDIO_BLOCK;\r\n} else {\r\nif (data->flags & MMC_DATA_STREAM)\r\ncmdr |= ATMCI_CMDR_STREAM;\r\nelse if (data->blocks > 1)\r\ncmdr |= ATMCI_CMDR_MULTI_BLOCK;\r\nelse\r\ncmdr |= ATMCI_CMDR_BLOCK;\r\n}\r\nif (data->flags & MMC_DATA_READ)\r\ncmdr |= ATMCI_CMDR_TRDIR_READ;\r\n}\r\nreturn cmdr;\r\n}\r\nstatic void atmci_send_command(struct atmel_mci *host,\r\nstruct mmc_command *cmd, u32 cmd_flags)\r\n{\r\nWARN_ON(host->cmd);\r\nhost->cmd = cmd;\r\ndev_vdbg(&host->pdev->dev,\r\n"start command: ARGR=0x%08x CMDR=0x%08x\n",\r\ncmd->arg, cmd_flags);\r\natmci_writel(host, ATMCI_ARGR, cmd->arg);\r\natmci_writel(host, ATMCI_CMDR, cmd_flags);\r\n}\r\nstatic void atmci_send_stop_cmd(struct atmel_mci *host, struct mmc_data *data)\r\n{\r\ndev_dbg(&host->pdev->dev, "send stop command\n");\r\natmci_send_command(host, data->stop, host->stop_cmdr);\r\natmci_writel(host, ATMCI_IER, ATMCI_CMDRDY);\r\n}\r\nstatic void atmci_pdc_set_single_buf(struct atmel_mci *host,\r\nenum atmci_xfer_dir dir, enum atmci_pdc_buf buf_nb)\r\n{\r\nu32 pointer_reg, counter_reg;\r\nunsigned int buf_size;\r\nif (dir == XFER_RECEIVE) {\r\npointer_reg = ATMEL_PDC_RPR;\r\ncounter_reg = ATMEL_PDC_RCR;\r\n} else {\r\npointer_reg = ATMEL_PDC_TPR;\r\ncounter_reg = ATMEL_PDC_TCR;\r\n}\r\nif (buf_nb == PDC_SECOND_BUF) {\r\npointer_reg += ATMEL_PDC_SCND_BUF_OFF;\r\ncounter_reg += ATMEL_PDC_SCND_BUF_OFF;\r\n}\r\nif (!host->caps.has_rwproof) {\r\nbuf_size = host->buf_size;\r\natmci_writel(host, pointer_reg, host->buf_phys_addr);\r\n} else {\r\nbuf_size = sg_dma_len(host->sg);\r\natmci_writel(host, pointer_reg, sg_dma_address(host->sg));\r\n}\r\nif (host->data_size <= buf_size) {\r\nif (host->data_size & 0x3) {\r\natmci_writel(host, counter_reg, host->data_size);\r\natmci_writel(host, ATMCI_MR, host->mode_reg | ATMCI_MR_PDCFBYTE);\r\n} else {\r\natmci_writel(host, counter_reg, host->data_size / 4);\r\n}\r\nhost->data_size = 0;\r\n} else {\r\natmci_writel(host, counter_reg, sg_dma_len(host->sg) / 4);\r\nhost->data_size -= sg_dma_len(host->sg);\r\nif (host->data_size)\r\nhost->sg = sg_next(host->sg);\r\n}\r\n}\r\nstatic void atmci_pdc_set_both_buf(struct atmel_mci *host, int dir)\r\n{\r\natmci_pdc_set_single_buf(host, dir, PDC_FIRST_BUF);\r\nif (host->data_size)\r\natmci_pdc_set_single_buf(host, dir, PDC_SECOND_BUF);\r\n}\r\nstatic void atmci_pdc_cleanup(struct atmel_mci *host)\r\n{\r\nstruct mmc_data *data = host->data;\r\nif (data)\r\ndma_unmap_sg(&host->pdev->dev,\r\ndata->sg, data->sg_len,\r\n((data->flags & MMC_DATA_WRITE)\r\n? DMA_TO_DEVICE : DMA_FROM_DEVICE));\r\n}\r\nstatic void atmci_pdc_complete(struct atmel_mci *host)\r\n{\r\nint transfer_size = host->data->blocks * host->data->blksz;\r\nint i;\r\natmci_writel(host, ATMEL_PDC_PTCR, ATMEL_PDC_RXTDIS | ATMEL_PDC_TXTDIS);\r\nif ((!host->caps.has_rwproof)\r\n&& (host->data->flags & MMC_DATA_READ)) {\r\nif (host->caps.has_bad_data_ordering)\r\nfor (i = 0; i < transfer_size; i++)\r\nhost->buffer[i] = swab32(host->buffer[i]);\r\nsg_copy_from_buffer(host->data->sg, host->data->sg_len,\r\nhost->buffer, transfer_size);\r\n}\r\natmci_pdc_cleanup(host);\r\ndev_dbg(&host->pdev->dev, "(%s) set pending xfer complete\n", __func__);\r\natmci_set_pending(host, EVENT_XFER_COMPLETE);\r\ntasklet_schedule(&host->tasklet);\r\n}\r\nstatic void atmci_dma_cleanup(struct atmel_mci *host)\r\n{\r\nstruct mmc_data *data = host->data;\r\nif (data)\r\ndma_unmap_sg(host->dma.chan->device->dev,\r\ndata->sg, data->sg_len,\r\n((data->flags & MMC_DATA_WRITE)\r\n? DMA_TO_DEVICE : DMA_FROM_DEVICE));\r\n}\r\nstatic void atmci_dma_complete(void *arg)\r\n{\r\nstruct atmel_mci *host = arg;\r\nstruct mmc_data *data = host->data;\r\ndev_vdbg(&host->pdev->dev, "DMA complete\n");\r\nif (host->caps.has_dma_conf_reg)\r\natmci_writel(host, ATMCI_DMA, atmci_readl(host, ATMCI_DMA) & ~ATMCI_DMAEN);\r\natmci_dma_cleanup(host);\r\nif (data) {\r\ndev_dbg(&host->pdev->dev,\r\n"(%s) set pending xfer complete\n", __func__);\r\natmci_set_pending(host, EVENT_XFER_COMPLETE);\r\ntasklet_schedule(&host->tasklet);\r\natmci_writel(host, ATMCI_IER, ATMCI_NOTBUSY);\r\n}\r\n}\r\nstatic u32 atmci_prepare_data(struct atmel_mci *host, struct mmc_data *data)\r\n{\r\nu32 iflags;\r\ndata->error = -EINPROGRESS;\r\nhost->sg = data->sg;\r\nhost->sg_len = data->sg_len;\r\nhost->data = data;\r\nhost->data_chan = NULL;\r\niflags = ATMCI_DATA_ERROR_FLAGS;\r\nif (data->blocks * data->blksz < 12\r\n|| (data->blocks * data->blksz) & 3)\r\nhost->need_reset = true;\r\nhost->pio_offset = 0;\r\nif (data->flags & MMC_DATA_READ)\r\niflags |= ATMCI_RXRDY;\r\nelse\r\niflags |= ATMCI_TXRDY;\r\nreturn iflags;\r\n}\r\nstatic u32\r\natmci_prepare_data_pdc(struct atmel_mci *host, struct mmc_data *data)\r\n{\r\nu32 iflags, tmp;\r\nunsigned int sg_len;\r\nenum dma_data_direction dir;\r\nint i;\r\ndata->error = -EINPROGRESS;\r\nhost->data = data;\r\nhost->sg = data->sg;\r\niflags = ATMCI_DATA_ERROR_FLAGS;\r\natmci_writel(host, ATMCI_MR, host->mode_reg | ATMCI_MR_PDCMODE);\r\nif (data->flags & MMC_DATA_READ) {\r\ndir = DMA_FROM_DEVICE;\r\niflags |= ATMCI_ENDRX | ATMCI_RXBUFF;\r\n} else {\r\ndir = DMA_TO_DEVICE;\r\niflags |= ATMCI_ENDTX | ATMCI_TXBUFE | ATMCI_BLKE;\r\n}\r\ntmp = atmci_readl(host, ATMCI_MR);\r\ntmp &= 0x0000ffff;\r\ntmp |= ATMCI_BLKLEN(data->blksz);\r\natmci_writel(host, ATMCI_MR, tmp);\r\nhost->data_size = data->blocks * data->blksz;\r\nsg_len = dma_map_sg(&host->pdev->dev, data->sg, data->sg_len, dir);\r\nif ((!host->caps.has_rwproof)\r\n&& (host->data->flags & MMC_DATA_WRITE)) {\r\nsg_copy_to_buffer(host->data->sg, host->data->sg_len,\r\nhost->buffer, host->data_size);\r\nif (host->caps.has_bad_data_ordering)\r\nfor (i = 0; i < host->data_size; i++)\r\nhost->buffer[i] = swab32(host->buffer[i]);\r\n}\r\nif (host->data_size)\r\natmci_pdc_set_both_buf(host,\r\n((dir == DMA_FROM_DEVICE) ? XFER_RECEIVE : XFER_TRANSMIT));\r\nreturn iflags;\r\n}\r\nstatic u32\r\natmci_prepare_data_dma(struct atmel_mci *host, struct mmc_data *data)\r\n{\r\nstruct dma_chan *chan;\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct scatterlist *sg;\r\nunsigned int i;\r\nenum dma_data_direction direction;\r\nenum dma_transfer_direction slave_dirn;\r\nunsigned int sglen;\r\nu32 maxburst;\r\nu32 iflags;\r\ndata->error = -EINPROGRESS;\r\nWARN_ON(host->data);\r\nhost->sg = NULL;\r\nhost->data = data;\r\niflags = ATMCI_DATA_ERROR_FLAGS;\r\nif (data->blocks * data->blksz < ATMCI_DMA_THRESHOLD)\r\nreturn atmci_prepare_data(host, data);\r\nif (data->blksz & 3)\r\nreturn atmci_prepare_data(host, data);\r\nfor_each_sg(data->sg, sg, data->sg_len, i) {\r\nif (sg->offset & 3 || sg->length & 3)\r\nreturn atmci_prepare_data(host, data);\r\n}\r\nchan = host->dma.chan;\r\nif (chan)\r\nhost->data_chan = chan;\r\nif (!chan)\r\nreturn -ENODEV;\r\nif (data->flags & MMC_DATA_READ) {\r\ndirection = DMA_FROM_DEVICE;\r\nhost->dma_conf.direction = slave_dirn = DMA_DEV_TO_MEM;\r\nmaxburst = atmci_convert_chksize(host->dma_conf.src_maxburst);\r\n} else {\r\ndirection = DMA_TO_DEVICE;\r\nhost->dma_conf.direction = slave_dirn = DMA_MEM_TO_DEV;\r\nmaxburst = atmci_convert_chksize(host->dma_conf.dst_maxburst);\r\n}\r\nif (host->caps.has_dma_conf_reg)\r\natmci_writel(host, ATMCI_DMA, ATMCI_DMA_CHKSIZE(maxburst) |\r\nATMCI_DMAEN);\r\nsglen = dma_map_sg(chan->device->dev, data->sg,\r\ndata->sg_len, direction);\r\ndmaengine_slave_config(chan, &host->dma_conf);\r\ndesc = dmaengine_prep_slave_sg(chan,\r\ndata->sg, sglen, slave_dirn,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc)\r\ngoto unmap_exit;\r\nhost->dma.data_desc = desc;\r\ndesc->callback = atmci_dma_complete;\r\ndesc->callback_param = host;\r\nreturn iflags;\r\nunmap_exit:\r\ndma_unmap_sg(chan->device->dev, data->sg, data->sg_len, direction);\r\nreturn -ENOMEM;\r\n}\r\nstatic void\r\natmci_submit_data(struct atmel_mci *host, struct mmc_data *data)\r\n{\r\nreturn;\r\n}\r\nstatic void\r\natmci_submit_data_pdc(struct atmel_mci *host, struct mmc_data *data)\r\n{\r\nif (data->flags & MMC_DATA_READ)\r\natmci_writel(host, ATMEL_PDC_PTCR, ATMEL_PDC_RXTEN);\r\nelse\r\natmci_writel(host, ATMEL_PDC_PTCR, ATMEL_PDC_TXTEN);\r\n}\r\nstatic void\r\natmci_submit_data_dma(struct atmel_mci *host, struct mmc_data *data)\r\n{\r\nstruct dma_chan *chan = host->data_chan;\r\nstruct dma_async_tx_descriptor *desc = host->dma.data_desc;\r\nif (chan) {\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(chan);\r\n}\r\n}\r\nstatic void atmci_stop_transfer(struct atmel_mci *host)\r\n{\r\ndev_dbg(&host->pdev->dev,\r\n"(%s) set pending xfer complete\n", __func__);\r\natmci_set_pending(host, EVENT_XFER_COMPLETE);\r\natmci_writel(host, ATMCI_IER, ATMCI_NOTBUSY);\r\n}\r\nstatic void atmci_stop_transfer_pdc(struct atmel_mci *host)\r\n{\r\natmci_writel(host, ATMEL_PDC_PTCR, ATMEL_PDC_RXTDIS | ATMEL_PDC_TXTDIS);\r\n}\r\nstatic void atmci_stop_transfer_dma(struct atmel_mci *host)\r\n{\r\nstruct dma_chan *chan = host->data_chan;\r\nif (chan) {\r\ndmaengine_terminate_all(chan);\r\natmci_dma_cleanup(host);\r\n} else {\r\ndev_dbg(&host->pdev->dev,\r\n"(%s) set pending xfer complete\n", __func__);\r\natmci_set_pending(host, EVENT_XFER_COMPLETE);\r\natmci_writel(host, ATMCI_IER, ATMCI_NOTBUSY);\r\n}\r\n}\r\nstatic void atmci_start_request(struct atmel_mci *host,\r\nstruct atmel_mci_slot *slot)\r\n{\r\nstruct mmc_request *mrq;\r\nstruct mmc_command *cmd;\r\nstruct mmc_data *data;\r\nu32 iflags;\r\nu32 cmdflags;\r\nmrq = slot->mrq;\r\nhost->cur_slot = slot;\r\nhost->mrq = mrq;\r\nhost->pending_events = 0;\r\nhost->completed_events = 0;\r\nhost->cmd_status = 0;\r\nhost->data_status = 0;\r\ndev_dbg(&host->pdev->dev, "start request: cmd %u\n", mrq->cmd->opcode);\r\nif (host->need_reset || host->caps.need_reset_after_xfer) {\r\niflags = atmci_readl(host, ATMCI_IMR);\r\niflags &= (ATMCI_SDIOIRQA | ATMCI_SDIOIRQB);\r\natmci_writel(host, ATMCI_CR, ATMCI_CR_SWRST);\r\natmci_writel(host, ATMCI_CR, ATMCI_CR_MCIEN);\r\natmci_writel(host, ATMCI_MR, host->mode_reg);\r\nif (host->caps.has_cfg_reg)\r\natmci_writel(host, ATMCI_CFG, host->cfg_reg);\r\natmci_writel(host, ATMCI_IER, iflags);\r\nhost->need_reset = false;\r\n}\r\natmci_writel(host, ATMCI_SDCR, slot->sdc_reg);\r\niflags = atmci_readl(host, ATMCI_IMR);\r\nif (iflags & ~(ATMCI_SDIOIRQA | ATMCI_SDIOIRQB))\r\ndev_dbg(&slot->mmc->class_dev, "WARNING: IMR=0x%08x\n",\r\niflags);\r\nif (unlikely(test_and_clear_bit(ATMCI_CARD_NEED_INIT, &slot->flags))) {\r\natmci_writel(host, ATMCI_CMDR, ATMCI_CMDR_SPCMD_INIT);\r\nwhile (!(atmci_readl(host, ATMCI_SR) & ATMCI_CMDRDY))\r\ncpu_relax();\r\n}\r\niflags = 0;\r\ndata = mrq->data;\r\nif (data) {\r\natmci_set_timeout(host, slot, data);\r\natmci_writel(host, ATMCI_BLKR, ATMCI_BCNT(data->blocks)\r\n| ATMCI_BLKLEN(data->blksz));\r\ndev_vdbg(&slot->mmc->class_dev, "BLKR=0x%08x\n",\r\nATMCI_BCNT(data->blocks) | ATMCI_BLKLEN(data->blksz));\r\niflags |= host->prepare_data(host, data);\r\n}\r\niflags |= ATMCI_CMDRDY;\r\ncmd = mrq->cmd;\r\ncmdflags = atmci_prepare_command(slot->mmc, cmd);\r\nif (host->submit_data != &atmci_submit_data_dma)\r\natmci_send_command(host, cmd, cmdflags);\r\nif (data)\r\nhost->submit_data(host, data);\r\nif (host->submit_data == &atmci_submit_data_dma)\r\natmci_send_command(host, cmd, cmdflags);\r\nif (mrq->stop) {\r\nhost->stop_cmdr = atmci_prepare_command(slot->mmc, mrq->stop);\r\nhost->stop_cmdr |= ATMCI_CMDR_STOP_XFER;\r\nif (!(data->flags & MMC_DATA_WRITE))\r\nhost->stop_cmdr |= ATMCI_CMDR_TRDIR_READ;\r\nif (data->flags & MMC_DATA_STREAM)\r\nhost->stop_cmdr |= ATMCI_CMDR_STREAM;\r\nelse\r\nhost->stop_cmdr |= ATMCI_CMDR_MULTI_BLOCK;\r\n}\r\natmci_writel(host, ATMCI_IER, iflags);\r\nmod_timer(&host->timer, jiffies + msecs_to_jiffies(2000));\r\n}\r\nstatic void atmci_queue_request(struct atmel_mci *host,\r\nstruct atmel_mci_slot *slot, struct mmc_request *mrq)\r\n{\r\ndev_vdbg(&slot->mmc->class_dev, "queue request: state=%d\n",\r\nhost->state);\r\nspin_lock_bh(&host->lock);\r\nslot->mrq = mrq;\r\nif (host->state == STATE_IDLE) {\r\nhost->state = STATE_SENDING_CMD;\r\natmci_start_request(host, slot);\r\n} else {\r\ndev_dbg(&host->pdev->dev, "queue request\n");\r\nlist_add_tail(&slot->queue_node, &host->queue);\r\n}\r\nspin_unlock_bh(&host->lock);\r\n}\r\nstatic void atmci_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct atmel_mci_slot *slot = mmc_priv(mmc);\r\nstruct atmel_mci *host = slot->host;\r\nstruct mmc_data *data;\r\nWARN_ON(slot->mrq);\r\ndev_dbg(&host->pdev->dev, "MRQ: cmd %u\n", mrq->cmd->opcode);\r\npm_runtime_get_sync(&host->pdev->dev);\r\nif (!test_bit(ATMCI_CARD_PRESENT, &slot->flags)) {\r\nmrq->cmd->error = -ENOMEDIUM;\r\nmmc_request_done(mmc, mrq);\r\nreturn;\r\n}\r\ndata = mrq->data;\r\nif (data && data->blocks > 1 && data->blksz & 3) {\r\nmrq->cmd->error = -EINVAL;\r\nmmc_request_done(mmc, mrq);\r\n}\r\natmci_queue_request(host, slot, mrq);\r\n}\r\nstatic void atmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct atmel_mci_slot *slot = mmc_priv(mmc);\r\nstruct atmel_mci *host = slot->host;\r\nunsigned int i;\r\npm_runtime_get_sync(&host->pdev->dev);\r\nslot->sdc_reg &= ~ATMCI_SDCBUS_MASK;\r\nswitch (ios->bus_width) {\r\ncase MMC_BUS_WIDTH_1:\r\nslot->sdc_reg |= ATMCI_SDCBUS_1BIT;\r\nbreak;\r\ncase MMC_BUS_WIDTH_4:\r\nslot->sdc_reg |= ATMCI_SDCBUS_4BIT;\r\nbreak;\r\n}\r\nif (ios->clock) {\r\nunsigned int clock_min = ~0U;\r\nint clkdiv;\r\nspin_lock_bh(&host->lock);\r\nif (!host->mode_reg) {\r\natmci_writel(host, ATMCI_CR, ATMCI_CR_SWRST);\r\natmci_writel(host, ATMCI_CR, ATMCI_CR_MCIEN);\r\nif (host->caps.has_cfg_reg)\r\natmci_writel(host, ATMCI_CFG, host->cfg_reg);\r\n}\r\nslot->clock = ios->clock;\r\nfor (i = 0; i < ATMCI_MAX_NR_SLOTS; i++) {\r\nif (host->slot[i] && host->slot[i]->clock\r\n&& host->slot[i]->clock < clock_min)\r\nclock_min = host->slot[i]->clock;\r\n}\r\nif (host->caps.has_odd_clk_div) {\r\nclkdiv = DIV_ROUND_UP(host->bus_hz, clock_min) - 2;\r\nif (clkdiv < 0) {\r\ndev_warn(&mmc->class_dev,\r\n"clock %u too fast; using %lu\n",\r\nclock_min, host->bus_hz / 2);\r\nclkdiv = 0;\r\n} else if (clkdiv > 511) {\r\ndev_warn(&mmc->class_dev,\r\n"clock %u too slow; using %lu\n",\r\nclock_min, host->bus_hz / (511 + 2));\r\nclkdiv = 511;\r\n}\r\nhost->mode_reg = ATMCI_MR_CLKDIV(clkdiv >> 1)\r\n| ATMCI_MR_CLKODD(clkdiv & 1);\r\n} else {\r\nclkdiv = DIV_ROUND_UP(host->bus_hz, 2 * clock_min) - 1;\r\nif (clkdiv > 255) {\r\ndev_warn(&mmc->class_dev,\r\n"clock %u too slow; using %lu\n",\r\nclock_min, host->bus_hz / (2 * 256));\r\nclkdiv = 255;\r\n}\r\nhost->mode_reg = ATMCI_MR_CLKDIV(clkdiv);\r\n}\r\nif (host->caps.has_rwproof)\r\nhost->mode_reg |= (ATMCI_MR_WRPROOF | ATMCI_MR_RDPROOF);\r\nif (host->caps.has_cfg_reg) {\r\nif (ios->timing == MMC_TIMING_SD_HS)\r\nhost->cfg_reg |= ATMCI_CFG_HSMODE;\r\nelse\r\nhost->cfg_reg &= ~ATMCI_CFG_HSMODE;\r\n}\r\nif (list_empty(&host->queue)) {\r\natmci_writel(host, ATMCI_MR, host->mode_reg);\r\nif (host->caps.has_cfg_reg)\r\natmci_writel(host, ATMCI_CFG, host->cfg_reg);\r\n} else {\r\nhost->need_clock_update = true;\r\n}\r\nspin_unlock_bh(&host->lock);\r\n} else {\r\nbool any_slot_active = false;\r\nspin_lock_bh(&host->lock);\r\nslot->clock = 0;\r\nfor (i = 0; i < ATMCI_MAX_NR_SLOTS; i++) {\r\nif (host->slot[i] && host->slot[i]->clock) {\r\nany_slot_active = true;\r\nbreak;\r\n}\r\n}\r\nif (!any_slot_active) {\r\natmci_writel(host, ATMCI_CR, ATMCI_CR_MCIDIS);\r\nif (host->mode_reg) {\r\natmci_readl(host, ATMCI_MR);\r\n}\r\nhost->mode_reg = 0;\r\n}\r\nspin_unlock_bh(&host->lock);\r\n}\r\nswitch (ios->power_mode) {\r\ncase MMC_POWER_OFF:\r\nif (!IS_ERR(mmc->supply.vmmc))\r\nmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);\r\nbreak;\r\ncase MMC_POWER_UP:\r\nset_bit(ATMCI_CARD_NEED_INIT, &slot->flags);\r\nif (!IS_ERR(mmc->supply.vmmc))\r\nmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, ios->vdd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npm_runtime_mark_last_busy(&host->pdev->dev);\r\npm_runtime_put_autosuspend(&host->pdev->dev);\r\n}\r\nstatic int atmci_get_ro(struct mmc_host *mmc)\r\n{\r\nint read_only = -ENOSYS;\r\nstruct atmel_mci_slot *slot = mmc_priv(mmc);\r\nif (gpio_is_valid(slot->wp_pin)) {\r\nread_only = gpio_get_value(slot->wp_pin);\r\ndev_dbg(&mmc->class_dev, "card is %s\n",\r\nread_only ? "read-only" : "read-write");\r\n}\r\nreturn read_only;\r\n}\r\nstatic int atmci_get_cd(struct mmc_host *mmc)\r\n{\r\nint present = -ENOSYS;\r\nstruct atmel_mci_slot *slot = mmc_priv(mmc);\r\nif (gpio_is_valid(slot->detect_pin)) {\r\npresent = !(gpio_get_value(slot->detect_pin) ^\r\nslot->detect_is_active_high);\r\ndev_dbg(&mmc->class_dev, "card is %spresent\n",\r\npresent ? "" : "not ");\r\n}\r\nreturn present;\r\n}\r\nstatic void atmci_enable_sdio_irq(struct mmc_host *mmc, int enable)\r\n{\r\nstruct atmel_mci_slot *slot = mmc_priv(mmc);\r\nstruct atmel_mci *host = slot->host;\r\nif (enable)\r\natmci_writel(host, ATMCI_IER, slot->sdio_irq);\r\nelse\r\natmci_writel(host, ATMCI_IDR, slot->sdio_irq);\r\n}\r\nstatic void atmci_request_end(struct atmel_mci *host, struct mmc_request *mrq)\r\n__releases(&host->lock\r\nstatic void atmci_command_complete(struct atmel_mci *host,\r\nstruct mmc_command *cmd)\r\n{\r\nu32 status = host->cmd_status;\r\ncmd->resp[0] = atmci_readl(host, ATMCI_RSPR);\r\ncmd->resp[1] = atmci_readl(host, ATMCI_RSPR);\r\ncmd->resp[2] = atmci_readl(host, ATMCI_RSPR);\r\ncmd->resp[3] = atmci_readl(host, ATMCI_RSPR);\r\nif (status & ATMCI_RTOE)\r\ncmd->error = -ETIMEDOUT;\r\nelse if ((cmd->flags & MMC_RSP_CRC) && (status & ATMCI_RCRCE))\r\ncmd->error = -EILSEQ;\r\nelse if (status & (ATMCI_RINDE | ATMCI_RDIRE | ATMCI_RENDE))\r\ncmd->error = -EIO;\r\nelse if (host->mrq->data && (host->mrq->data->blksz & 3)) {\r\nif (host->caps.need_blksz_mul_4) {\r\ncmd->error = -EINVAL;\r\nhost->need_reset = 1;\r\n}\r\n} else\r\ncmd->error = 0;\r\n}\r\nstatic void atmci_detect_change(unsigned long data)\r\n{\r\nstruct atmel_mci_slot *slot = (struct atmel_mci_slot *)data;\r\nbool present;\r\nbool present_old;\r\nsmp_rmb();\r\nif (test_bit(ATMCI_SHUTDOWN, &slot->flags))\r\nreturn;\r\nenable_irq(gpio_to_irq(slot->detect_pin));\r\npresent = !(gpio_get_value(slot->detect_pin) ^\r\nslot->detect_is_active_high);\r\npresent_old = test_bit(ATMCI_CARD_PRESENT, &slot->flags);\r\ndev_vdbg(&slot->mmc->class_dev, "detect change: %d (was %d)\n",\r\npresent, present_old);\r\nif (present != present_old) {\r\nstruct atmel_mci *host = slot->host;\r\nstruct mmc_request *mrq;\r\ndev_dbg(&slot->mmc->class_dev, "card %s\n",\r\npresent ? "inserted" : "removed");\r\nspin_lock(&host->lock);\r\nif (!present)\r\nclear_bit(ATMCI_CARD_PRESENT, &slot->flags);\r\nelse\r\nset_bit(ATMCI_CARD_PRESENT, &slot->flags);\r\nmrq = slot->mrq;\r\nif (mrq) {\r\nif (mrq == host->mrq) {\r\natmci_writel(host, ATMCI_CR, ATMCI_CR_SWRST);\r\natmci_writel(host, ATMCI_CR, ATMCI_CR_MCIEN);\r\natmci_writel(host, ATMCI_MR, host->mode_reg);\r\nif (host->caps.has_cfg_reg)\r\natmci_writel(host, ATMCI_CFG, host->cfg_reg);\r\nhost->data = NULL;\r\nhost->cmd = NULL;\r\nswitch (host->state) {\r\ncase STATE_IDLE:\r\nbreak;\r\ncase STATE_SENDING_CMD:\r\nmrq->cmd->error = -ENOMEDIUM;\r\nif (mrq->data)\r\nhost->stop_transfer(host);\r\nbreak;\r\ncase STATE_DATA_XFER:\r\nmrq->data->error = -ENOMEDIUM;\r\nhost->stop_transfer(host);\r\nbreak;\r\ncase STATE_WAITING_NOTBUSY:\r\nmrq->data->error = -ENOMEDIUM;\r\nbreak;\r\ncase STATE_SENDING_STOP:\r\nmrq->stop->error = -ENOMEDIUM;\r\nbreak;\r\ncase STATE_END_REQUEST:\r\nbreak;\r\n}\r\natmci_request_end(host, mrq);\r\n} else {\r\nlist_del(&slot->queue_node);\r\nmrq->cmd->error = -ENOMEDIUM;\r\nif (mrq->data)\r\nmrq->data->error = -ENOMEDIUM;\r\nif (mrq->stop)\r\nmrq->stop->error = -ENOMEDIUM;\r\nspin_unlock(&host->lock);\r\nmmc_request_done(slot->mmc, mrq);\r\nspin_lock(&host->lock);\r\n}\r\n}\r\nspin_unlock(&host->lock);\r\nmmc_detect_change(slot->mmc, 0);\r\n}\r\n}\r\nstatic void atmci_tasklet_func(unsigned long priv)\r\n{\r\nstruct atmel_mci *host = (struct atmel_mci *)priv;\r\nstruct mmc_request *mrq = host->mrq;\r\nstruct mmc_data *data = host->data;\r\nenum atmel_mci_state state = host->state;\r\nenum atmel_mci_state prev_state;\r\nu32 status;\r\nspin_lock(&host->lock);\r\nstate = host->state;\r\ndev_vdbg(&host->pdev->dev,\r\n"tasklet: state %u pending/completed/mask %lx/%lx/%x\n",\r\nstate, host->pending_events, host->completed_events,\r\natmci_readl(host, ATMCI_IMR));\r\ndo {\r\nprev_state = state;\r\ndev_dbg(&host->pdev->dev, "FSM: state=%d\n", state);\r\nswitch (state) {\r\ncase STATE_IDLE:\r\nbreak;\r\ncase STATE_SENDING_CMD:\r\ndev_dbg(&host->pdev->dev, "FSM: cmd ready?\n");\r\nif (!atmci_test_and_clear_pending(host,\r\nEVENT_CMD_RDY))\r\nbreak;\r\ndev_dbg(&host->pdev->dev, "set completed cmd ready\n");\r\nhost->cmd = NULL;\r\natmci_set_completed(host, EVENT_CMD_RDY);\r\natmci_command_complete(host, mrq->cmd);\r\nif (mrq->data) {\r\ndev_dbg(&host->pdev->dev,\r\n"command with data transfer");\r\nif (mrq->cmd->error) {\r\nhost->stop_transfer(host);\r\nhost->data = NULL;\r\natmci_writel(host, ATMCI_IDR,\r\nATMCI_TXRDY | ATMCI_RXRDY\r\n| ATMCI_DATA_ERROR_FLAGS);\r\nstate = STATE_END_REQUEST;\r\n} else\r\nstate = STATE_DATA_XFER;\r\n} else if ((!mrq->data) && (mrq->cmd->flags & MMC_RSP_BUSY)) {\r\ndev_dbg(&host->pdev->dev,\r\n"command response need waiting notbusy");\r\natmci_writel(host, ATMCI_IER, ATMCI_NOTBUSY);\r\nstate = STATE_WAITING_NOTBUSY;\r\n} else\r\nstate = STATE_END_REQUEST;\r\nbreak;\r\ncase STATE_DATA_XFER:\r\nif (atmci_test_and_clear_pending(host,\r\nEVENT_DATA_ERROR)) {\r\ndev_dbg(&host->pdev->dev, "set completed data error\n");\r\natmci_set_completed(host, EVENT_DATA_ERROR);\r\nstate = STATE_END_REQUEST;\r\nbreak;\r\n}\r\ndev_dbg(&host->pdev->dev, "FSM: xfer complete?\n");\r\nif (!atmci_test_and_clear_pending(host,\r\nEVENT_XFER_COMPLETE))\r\nbreak;\r\ndev_dbg(&host->pdev->dev,\r\n"(%s) set completed xfer complete\n",\r\n__func__);\r\natmci_set_completed(host, EVENT_XFER_COMPLETE);\r\nif (host->caps.need_notbusy_for_read_ops ||\r\n(host->data->flags & MMC_DATA_WRITE)) {\r\natmci_writel(host, ATMCI_IER, ATMCI_NOTBUSY);\r\nstate = STATE_WAITING_NOTBUSY;\r\n} else if (host->mrq->stop) {\r\natmci_writel(host, ATMCI_IER, ATMCI_CMDRDY);\r\natmci_send_stop_cmd(host, data);\r\nstate = STATE_SENDING_STOP;\r\n} else {\r\nhost->data = NULL;\r\ndata->bytes_xfered = data->blocks * data->blksz;\r\ndata->error = 0;\r\nstate = STATE_END_REQUEST;\r\n}\r\nbreak;\r\ncase STATE_WAITING_NOTBUSY:\r\ndev_dbg(&host->pdev->dev, "FSM: not busy?\n");\r\nif (!atmci_test_and_clear_pending(host,\r\nEVENT_NOTBUSY))\r\nbreak;\r\ndev_dbg(&host->pdev->dev, "set completed not busy\n");\r\natmci_set_completed(host, EVENT_NOTBUSY);\r\nif (host->data) {\r\nif (host->mrq->stop) {\r\natmci_writel(host, ATMCI_IER,\r\nATMCI_CMDRDY);\r\natmci_send_stop_cmd(host, data);\r\nstate = STATE_SENDING_STOP;\r\n} else {\r\nhost->data = NULL;\r\ndata->bytes_xfered = data->blocks\r\n* data->blksz;\r\ndata->error = 0;\r\nstate = STATE_END_REQUEST;\r\n}\r\n} else\r\nstate = STATE_END_REQUEST;\r\nbreak;\r\ncase STATE_SENDING_STOP:\r\ndev_dbg(&host->pdev->dev, "FSM: cmd ready?\n");\r\nif (!atmci_test_and_clear_pending(host,\r\nEVENT_CMD_RDY))\r\nbreak;\r\ndev_dbg(&host->pdev->dev, "FSM: cmd ready\n");\r\nhost->cmd = NULL;\r\ndata->bytes_xfered = data->blocks * data->blksz;\r\ndata->error = 0;\r\natmci_command_complete(host, mrq->stop);\r\nif (mrq->stop->error) {\r\nhost->stop_transfer(host);\r\natmci_writel(host, ATMCI_IDR,\r\nATMCI_TXRDY | ATMCI_RXRDY\r\n| ATMCI_DATA_ERROR_FLAGS);\r\nstate = STATE_END_REQUEST;\r\n} else {\r\natmci_writel(host, ATMCI_IER, ATMCI_NOTBUSY);\r\nstate = STATE_WAITING_NOTBUSY;\r\n}\r\nhost->data = NULL;\r\nbreak;\r\ncase STATE_END_REQUEST:\r\natmci_writel(host, ATMCI_IDR, ATMCI_TXRDY | ATMCI_RXRDY\r\n| ATMCI_DATA_ERROR_FLAGS);\r\nstatus = host->data_status;\r\nif (unlikely(status)) {\r\nhost->stop_transfer(host);\r\nhost->data = NULL;\r\nif (data) {\r\nif (status & ATMCI_DTOE) {\r\ndata->error = -ETIMEDOUT;\r\n} else if (status & ATMCI_DCRCE) {\r\ndata->error = -EILSEQ;\r\n} else {\r\ndata->error = -EIO;\r\n}\r\n}\r\n}\r\natmci_request_end(host, host->mrq);\r\nstate = STATE_IDLE;\r\nbreak;\r\n}\r\n} while (state != prev_state);\r\nhost->state = state;\r\nspin_unlock(&host->lock);\r\n}\r\nstatic void atmci_read_data_pio(struct atmel_mci *host)\r\n{\r\nstruct scatterlist *sg = host->sg;\r\nvoid *buf = sg_virt(sg);\r\nunsigned int offset = host->pio_offset;\r\nstruct mmc_data *data = host->data;\r\nu32 value;\r\nu32 status;\r\nunsigned int nbytes = 0;\r\ndo {\r\nvalue = atmci_readl(host, ATMCI_RDR);\r\nif (likely(offset + 4 <= sg->length)) {\r\nput_unaligned(value, (u32 *)(buf + offset));\r\noffset += 4;\r\nnbytes += 4;\r\nif (offset == sg->length) {\r\nflush_dcache_page(sg_page(sg));\r\nhost->sg = sg = sg_next(sg);\r\nhost->sg_len--;\r\nif (!sg || !host->sg_len)\r\ngoto done;\r\noffset = 0;\r\nbuf = sg_virt(sg);\r\n}\r\n} else {\r\nunsigned int remaining = sg->length - offset;\r\nmemcpy(buf + offset, &value, remaining);\r\nnbytes += remaining;\r\nflush_dcache_page(sg_page(sg));\r\nhost->sg = sg = sg_next(sg);\r\nhost->sg_len--;\r\nif (!sg || !host->sg_len)\r\ngoto done;\r\noffset = 4 - remaining;\r\nbuf = sg_virt(sg);\r\nmemcpy(buf, (u8 *)&value + remaining, offset);\r\nnbytes += offset;\r\n}\r\nstatus = atmci_readl(host, ATMCI_SR);\r\nif (status & ATMCI_DATA_ERROR_FLAGS) {\r\natmci_writel(host, ATMCI_IDR, (ATMCI_NOTBUSY | ATMCI_RXRDY\r\n| ATMCI_DATA_ERROR_FLAGS));\r\nhost->data_status = status;\r\ndata->bytes_xfered += nbytes;\r\nreturn;\r\n}\r\n} while (status & ATMCI_RXRDY);\r\nhost->pio_offset = offset;\r\ndata->bytes_xfered += nbytes;\r\nreturn;\r\ndone:\r\natmci_writel(host, ATMCI_IDR, ATMCI_RXRDY);\r\natmci_writel(host, ATMCI_IER, ATMCI_NOTBUSY);\r\ndata->bytes_xfered += nbytes;\r\nsmp_wmb();\r\natmci_set_pending(host, EVENT_XFER_COMPLETE);\r\n}\r\nstatic void atmci_write_data_pio(struct atmel_mci *host)\r\n{\r\nstruct scatterlist *sg = host->sg;\r\nvoid *buf = sg_virt(sg);\r\nunsigned int offset = host->pio_offset;\r\nstruct mmc_data *data = host->data;\r\nu32 value;\r\nu32 status;\r\nunsigned int nbytes = 0;\r\ndo {\r\nif (likely(offset + 4 <= sg->length)) {\r\nvalue = get_unaligned((u32 *)(buf + offset));\r\natmci_writel(host, ATMCI_TDR, value);\r\noffset += 4;\r\nnbytes += 4;\r\nif (offset == sg->length) {\r\nhost->sg = sg = sg_next(sg);\r\nhost->sg_len--;\r\nif (!sg || !host->sg_len)\r\ngoto done;\r\noffset = 0;\r\nbuf = sg_virt(sg);\r\n}\r\n} else {\r\nunsigned int remaining = sg->length - offset;\r\nvalue = 0;\r\nmemcpy(&value, buf + offset, remaining);\r\nnbytes += remaining;\r\nhost->sg = sg = sg_next(sg);\r\nhost->sg_len--;\r\nif (!sg || !host->sg_len) {\r\natmci_writel(host, ATMCI_TDR, value);\r\ngoto done;\r\n}\r\noffset = 4 - remaining;\r\nbuf = sg_virt(sg);\r\nmemcpy((u8 *)&value + remaining, buf, offset);\r\natmci_writel(host, ATMCI_TDR, value);\r\nnbytes += offset;\r\n}\r\nstatus = atmci_readl(host, ATMCI_SR);\r\nif (status & ATMCI_DATA_ERROR_FLAGS) {\r\natmci_writel(host, ATMCI_IDR, (ATMCI_NOTBUSY | ATMCI_TXRDY\r\n| ATMCI_DATA_ERROR_FLAGS));\r\nhost->data_status = status;\r\ndata->bytes_xfered += nbytes;\r\nreturn;\r\n}\r\n} while (status & ATMCI_TXRDY);\r\nhost->pio_offset = offset;\r\ndata->bytes_xfered += nbytes;\r\nreturn;\r\ndone:\r\natmci_writel(host, ATMCI_IDR, ATMCI_TXRDY);\r\natmci_writel(host, ATMCI_IER, ATMCI_NOTBUSY);\r\ndata->bytes_xfered += nbytes;\r\nsmp_wmb();\r\natmci_set_pending(host, EVENT_XFER_COMPLETE);\r\n}\r\nstatic void atmci_sdio_interrupt(struct atmel_mci *host, u32 status)\r\n{\r\nint i;\r\nfor (i = 0; i < ATMCI_MAX_NR_SLOTS; i++) {\r\nstruct atmel_mci_slot *slot = host->slot[i];\r\nif (slot && (status & slot->sdio_irq)) {\r\nmmc_signal_sdio_irq(slot->mmc);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t atmci_interrupt(int irq, void *dev_id)\r\n{\r\nstruct atmel_mci *host = dev_id;\r\nu32 status, mask, pending;\r\nunsigned int pass_count = 0;\r\ndo {\r\nstatus = atmci_readl(host, ATMCI_SR);\r\nmask = atmci_readl(host, ATMCI_IMR);\r\npending = status & mask;\r\nif (!pending)\r\nbreak;\r\nif (pending & ATMCI_DATA_ERROR_FLAGS) {\r\ndev_dbg(&host->pdev->dev, "IRQ: data error\n");\r\natmci_writel(host, ATMCI_IDR, ATMCI_DATA_ERROR_FLAGS\r\n| ATMCI_RXRDY | ATMCI_TXRDY\r\n| ATMCI_ENDRX | ATMCI_ENDTX\r\n| ATMCI_RXBUFF | ATMCI_TXBUFE);\r\nhost->data_status = status;\r\ndev_dbg(&host->pdev->dev, "set pending data error\n");\r\nsmp_wmb();\r\natmci_set_pending(host, EVENT_DATA_ERROR);\r\ntasklet_schedule(&host->tasklet);\r\n}\r\nif (pending & ATMCI_TXBUFE) {\r\ndev_dbg(&host->pdev->dev, "IRQ: tx buffer empty\n");\r\natmci_writel(host, ATMCI_IDR, ATMCI_TXBUFE);\r\natmci_writel(host, ATMCI_IDR, ATMCI_ENDTX);\r\nif (host->data_size) {\r\natmci_pdc_set_both_buf(host, XFER_TRANSMIT);\r\natmci_writel(host, ATMCI_IER, ATMCI_ENDTX);\r\natmci_writel(host, ATMCI_IER, ATMCI_TXBUFE);\r\n} else {\r\natmci_pdc_complete(host);\r\n}\r\n} else if (pending & ATMCI_ENDTX) {\r\ndev_dbg(&host->pdev->dev, "IRQ: end of tx buffer\n");\r\natmci_writel(host, ATMCI_IDR, ATMCI_ENDTX);\r\nif (host->data_size) {\r\natmci_pdc_set_single_buf(host,\r\nXFER_TRANSMIT, PDC_SECOND_BUF);\r\natmci_writel(host, ATMCI_IER, ATMCI_ENDTX);\r\n}\r\n}\r\nif (pending & ATMCI_RXBUFF) {\r\ndev_dbg(&host->pdev->dev, "IRQ: rx buffer full\n");\r\natmci_writel(host, ATMCI_IDR, ATMCI_RXBUFF);\r\natmci_writel(host, ATMCI_IDR, ATMCI_ENDRX);\r\nif (host->data_size) {\r\natmci_pdc_set_both_buf(host, XFER_RECEIVE);\r\natmci_writel(host, ATMCI_IER, ATMCI_ENDRX);\r\natmci_writel(host, ATMCI_IER, ATMCI_RXBUFF);\r\n} else {\r\natmci_pdc_complete(host);\r\n}\r\n} else if (pending & ATMCI_ENDRX) {\r\ndev_dbg(&host->pdev->dev, "IRQ: end of rx buffer\n");\r\natmci_writel(host, ATMCI_IDR, ATMCI_ENDRX);\r\nif (host->data_size) {\r\natmci_pdc_set_single_buf(host,\r\nXFER_RECEIVE, PDC_SECOND_BUF);\r\natmci_writel(host, ATMCI_IER, ATMCI_ENDRX);\r\n}\r\n}\r\nif (pending & ATMCI_BLKE) {\r\ndev_dbg(&host->pdev->dev, "IRQ: blke\n");\r\natmci_writel(host, ATMCI_IDR, ATMCI_BLKE);\r\nsmp_wmb();\r\ndev_dbg(&host->pdev->dev, "set pending notbusy\n");\r\natmci_set_pending(host, EVENT_NOTBUSY);\r\ntasklet_schedule(&host->tasklet);\r\n}\r\nif (pending & ATMCI_NOTBUSY) {\r\ndev_dbg(&host->pdev->dev, "IRQ: not_busy\n");\r\natmci_writel(host, ATMCI_IDR, ATMCI_NOTBUSY);\r\nsmp_wmb();\r\ndev_dbg(&host->pdev->dev, "set pending notbusy\n");\r\natmci_set_pending(host, EVENT_NOTBUSY);\r\ntasklet_schedule(&host->tasklet);\r\n}\r\nif (pending & ATMCI_RXRDY)\r\natmci_read_data_pio(host);\r\nif (pending & ATMCI_TXRDY)\r\natmci_write_data_pio(host);\r\nif (pending & ATMCI_CMDRDY) {\r\ndev_dbg(&host->pdev->dev, "IRQ: cmd ready\n");\r\natmci_writel(host, ATMCI_IDR, ATMCI_CMDRDY);\r\nhost->cmd_status = status;\r\nsmp_wmb();\r\ndev_dbg(&host->pdev->dev, "set pending cmd rdy\n");\r\natmci_set_pending(host, EVENT_CMD_RDY);\r\ntasklet_schedule(&host->tasklet);\r\n}\r\nif (pending & (ATMCI_SDIOIRQA | ATMCI_SDIOIRQB))\r\natmci_sdio_interrupt(host, status);\r\n} while (pass_count++ < 5);\r\nreturn pass_count ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic irqreturn_t atmci_detect_interrupt(int irq, void *dev_id)\r\n{\r\nstruct atmel_mci_slot *slot = dev_id;\r\ndisable_irq_nosync(irq);\r\nmod_timer(&slot->detect_timer, jiffies + msecs_to_jiffies(20));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int atmci_init_slot(struct atmel_mci *host,\r\nstruct mci_slot_pdata *slot_data, unsigned int id,\r\nu32 sdc_reg, u32 sdio_irq)\r\n{\r\nstruct mmc_host *mmc;\r\nstruct atmel_mci_slot *slot;\r\nmmc = mmc_alloc_host(sizeof(struct atmel_mci_slot), &host->pdev->dev);\r\nif (!mmc)\r\nreturn -ENOMEM;\r\nslot = mmc_priv(mmc);\r\nslot->mmc = mmc;\r\nslot->host = host;\r\nslot->detect_pin = slot_data->detect_pin;\r\nslot->wp_pin = slot_data->wp_pin;\r\nslot->detect_is_active_high = slot_data->detect_is_active_high;\r\nslot->sdc_reg = sdc_reg;\r\nslot->sdio_irq = sdio_irq;\r\ndev_dbg(&mmc->class_dev,\r\n"slot[%u]: bus_width=%u, detect_pin=%d, "\r\n"detect_is_active_high=%s, wp_pin=%d\n",\r\nid, slot_data->bus_width, slot_data->detect_pin,\r\nslot_data->detect_is_active_high ? "true" : "false",\r\nslot_data->wp_pin);\r\nmmc->ops = &atmci_ops;\r\nmmc->f_min = DIV_ROUND_UP(host->bus_hz, 512);\r\nmmc->f_max = host->bus_hz / 2;\r\nmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\r\nif (sdio_irq)\r\nmmc->caps |= MMC_CAP_SDIO_IRQ;\r\nif (host->caps.has_highspeed)\r\nmmc->caps |= MMC_CAP_SD_HIGHSPEED;\r\nif ((slot_data->bus_width >= 4) && host->caps.has_rwproof)\r\nmmc->caps |= MMC_CAP_4_BIT_DATA;\r\nif (atmci_get_version(host) < 0x200) {\r\nmmc->max_segs = 256;\r\nmmc->max_blk_size = 4095;\r\nmmc->max_blk_count = 256;\r\nmmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;\r\nmmc->max_seg_size = mmc->max_blk_size * mmc->max_segs;\r\n} else {\r\nmmc->max_segs = 64;\r\nmmc->max_req_size = 32768 * 512;\r\nmmc->max_blk_size = 32768;\r\nmmc->max_blk_count = 512;\r\n}\r\nset_bit(ATMCI_CARD_PRESENT, &slot->flags);\r\nif (gpio_is_valid(slot->detect_pin)) {\r\nif (devm_gpio_request(&host->pdev->dev, slot->detect_pin,\r\n"mmc_detect")) {\r\ndev_dbg(&mmc->class_dev, "no detect pin available\n");\r\nslot->detect_pin = -EBUSY;\r\n} else if (gpio_get_value(slot->detect_pin) ^\r\nslot->detect_is_active_high) {\r\nclear_bit(ATMCI_CARD_PRESENT, &slot->flags);\r\n}\r\n}\r\nif (!gpio_is_valid(slot->detect_pin)) {\r\nif (slot_data->non_removable)\r\nmmc->caps |= MMC_CAP_NONREMOVABLE;\r\nelse\r\nmmc->caps |= MMC_CAP_NEEDS_POLL;\r\n}\r\nif (gpio_is_valid(slot->wp_pin)) {\r\nif (devm_gpio_request(&host->pdev->dev, slot->wp_pin,\r\n"mmc_wp")) {\r\ndev_dbg(&mmc->class_dev, "no WP pin available\n");\r\nslot->wp_pin = -EBUSY;\r\n}\r\n}\r\nhost->slot[id] = slot;\r\nmmc_regulator_get_supply(mmc);\r\nmmc_add_host(mmc);\r\nif (gpio_is_valid(slot->detect_pin)) {\r\nint ret;\r\nsetup_timer(&slot->detect_timer, atmci_detect_change,\r\n(unsigned long)slot);\r\nret = request_irq(gpio_to_irq(slot->detect_pin),\r\natmci_detect_interrupt,\r\nIRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,\r\n"mmc-detect", slot);\r\nif (ret) {\r\ndev_dbg(&mmc->class_dev,\r\n"could not request IRQ %d for detect pin\n",\r\ngpio_to_irq(slot->detect_pin));\r\nslot->detect_pin = -EBUSY;\r\n}\r\n}\r\natmci_init_debugfs(slot);\r\nreturn 0;\r\n}\r\nstatic void atmci_cleanup_slot(struct atmel_mci_slot *slot,\r\nunsigned int id)\r\n{\r\nset_bit(ATMCI_SHUTDOWN, &slot->flags);\r\nsmp_wmb();\r\nmmc_remove_host(slot->mmc);\r\nif (gpio_is_valid(slot->detect_pin)) {\r\nint pin = slot->detect_pin;\r\nfree_irq(gpio_to_irq(pin), slot);\r\ndel_timer_sync(&slot->detect_timer);\r\n}\r\nslot->host->slot[id] = NULL;\r\nmmc_free_host(slot->mmc);\r\n}\r\nstatic int atmci_configure_dma(struct atmel_mci *host)\r\n{\r\nhost->dma.chan = dma_request_slave_channel_reason(&host->pdev->dev,\r\n"rxtx");\r\nif (IS_ERR(host->dma.chan))\r\nreturn PTR_ERR(host->dma.chan);\r\ndev_info(&host->pdev->dev, "using %s for DMA transfers\n",\r\ndma_chan_name(host->dma.chan));\r\nhost->dma_conf.src_addr = host->mapbase + ATMCI_RDR;\r\nhost->dma_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nhost->dma_conf.src_maxburst = 1;\r\nhost->dma_conf.dst_addr = host->mapbase + ATMCI_TDR;\r\nhost->dma_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nhost->dma_conf.dst_maxburst = 1;\r\nhost->dma_conf.device_fc = false;\r\nreturn 0;\r\n}\r\nstatic void atmci_get_cap(struct atmel_mci *host)\r\n{\r\nunsigned int version;\r\nversion = atmci_get_version(host);\r\ndev_info(&host->pdev->dev,\r\n"version: 0x%x\n", version);\r\nhost->caps.has_dma_conf_reg = 0;\r\nhost->caps.has_pdc = ATMCI_PDC_CONNECTED;\r\nhost->caps.has_cfg_reg = 0;\r\nhost->caps.has_cstor_reg = 0;\r\nhost->caps.has_highspeed = 0;\r\nhost->caps.has_rwproof = 0;\r\nhost->caps.has_odd_clk_div = 0;\r\nhost->caps.has_bad_data_ordering = 1;\r\nhost->caps.need_reset_after_xfer = 1;\r\nhost->caps.need_blksz_mul_4 = 1;\r\nhost->caps.need_notbusy_for_read_ops = 0;\r\nswitch (version & 0xf00) {\r\ncase 0x600:\r\ncase 0x500:\r\nhost->caps.has_odd_clk_div = 1;\r\ncase 0x400:\r\ncase 0x300:\r\nhost->caps.has_dma_conf_reg = 1;\r\nhost->caps.has_pdc = 0;\r\nhost->caps.has_cfg_reg = 1;\r\nhost->caps.has_cstor_reg = 1;\r\nhost->caps.has_highspeed = 1;\r\ncase 0x200:\r\nhost->caps.has_rwproof = 1;\r\nhost->caps.need_blksz_mul_4 = 0;\r\nhost->caps.need_notbusy_for_read_ops = 1;\r\ncase 0x100:\r\nhost->caps.has_bad_data_ordering = 0;\r\nhost->caps.need_reset_after_xfer = 0;\r\ncase 0x0:\r\nbreak;\r\ndefault:\r\nhost->caps.has_pdc = 0;\r\ndev_warn(&host->pdev->dev,\r\n"Unmanaged mci version, set minimum capabilities\n");\r\nbreak;\r\n}\r\n}\r\nstatic int atmci_probe(struct platform_device *pdev)\r\n{\r\nstruct mci_platform_data *pdata;\r\nstruct atmel_mci *host;\r\nstruct resource *regs;\r\nunsigned int nr_slots;\r\nint irq;\r\nint ret, i;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!regs)\r\nreturn -ENXIO;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\npdata = atmci_of_init(pdev);\r\nif (IS_ERR(pdata)) {\r\ndev_err(&pdev->dev, "platform data not available\n");\r\nreturn PTR_ERR(pdata);\r\n}\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nhost = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);\r\nif (!host)\r\nreturn -ENOMEM;\r\nhost->pdev = pdev;\r\nspin_lock_init(&host->lock);\r\nINIT_LIST_HEAD(&host->queue);\r\nhost->mck = devm_clk_get(&pdev->dev, "mci_clk");\r\nif (IS_ERR(host->mck))\r\nreturn PTR_ERR(host->mck);\r\nhost->regs = devm_ioremap(&pdev->dev, regs->start, resource_size(regs));\r\nif (!host->regs)\r\nreturn -ENOMEM;\r\nret = clk_prepare_enable(host->mck);\r\nif (ret)\r\nreturn ret;\r\natmci_writel(host, ATMCI_CR, ATMCI_CR_SWRST);\r\nhost->bus_hz = clk_get_rate(host->mck);\r\nhost->mapbase = regs->start;\r\ntasklet_init(&host->tasklet, atmci_tasklet_func, (unsigned long)host);\r\nret = request_irq(irq, atmci_interrupt, 0, dev_name(&pdev->dev), host);\r\nif (ret) {\r\nclk_disable_unprepare(host->mck);\r\nreturn ret;\r\n}\r\natmci_get_cap(host);\r\nret = atmci_configure_dma(host);\r\nif (ret == -EPROBE_DEFER)\r\ngoto err_dma_probe_defer;\r\nif (ret == 0) {\r\nhost->prepare_data = &atmci_prepare_data_dma;\r\nhost->submit_data = &atmci_submit_data_dma;\r\nhost->stop_transfer = &atmci_stop_transfer_dma;\r\n} else if (host->caps.has_pdc) {\r\ndev_info(&pdev->dev, "using PDC\n");\r\nhost->prepare_data = &atmci_prepare_data_pdc;\r\nhost->submit_data = &atmci_submit_data_pdc;\r\nhost->stop_transfer = &atmci_stop_transfer_pdc;\r\n} else {\r\ndev_info(&pdev->dev, "using PIO\n");\r\nhost->prepare_data = &atmci_prepare_data;\r\nhost->submit_data = &atmci_submit_data;\r\nhost->stop_transfer = &atmci_stop_transfer;\r\n}\r\nplatform_set_drvdata(pdev, host);\r\nsetup_timer(&host->timer, atmci_timeout_timer, (unsigned long)host);\r\npm_runtime_get_noresume(&pdev->dev);\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_set_autosuspend_delay(&pdev->dev, AUTOSUSPEND_DELAY);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\nnr_slots = 0;\r\nret = -ENODEV;\r\nif (pdata->slot[0].bus_width) {\r\nret = atmci_init_slot(host, &pdata->slot[0],\r\n0, ATMCI_SDCSEL_SLOT_A, ATMCI_SDIOIRQA);\r\nif (!ret) {\r\nnr_slots++;\r\nhost->buf_size = host->slot[0]->mmc->max_req_size;\r\n}\r\n}\r\nif (pdata->slot[1].bus_width) {\r\nret = atmci_init_slot(host, &pdata->slot[1],\r\n1, ATMCI_SDCSEL_SLOT_B, ATMCI_SDIOIRQB);\r\nif (!ret) {\r\nnr_slots++;\r\nif (host->slot[1]->mmc->max_req_size > host->buf_size)\r\nhost->buf_size =\r\nhost->slot[1]->mmc->max_req_size;\r\n}\r\n}\r\nif (!nr_slots) {\r\ndev_err(&pdev->dev, "init failed: no slot defined\n");\r\ngoto err_init_slot;\r\n}\r\nif (!host->caps.has_rwproof) {\r\nhost->buffer = dma_alloc_coherent(&pdev->dev, host->buf_size,\r\n&host->buf_phys_addr,\r\nGFP_KERNEL);\r\nif (!host->buffer) {\r\nret = -ENOMEM;\r\ndev_err(&pdev->dev, "buffer allocation failed\n");\r\ngoto err_dma_alloc;\r\n}\r\n}\r\ndev_info(&pdev->dev,\r\n"Atmel MCI controller at 0x%08lx irq %d, %u slots\n",\r\nhost->mapbase, irq, nr_slots);\r\npm_runtime_mark_last_busy(&host->pdev->dev);\r\npm_runtime_put_autosuspend(&pdev->dev);\r\nreturn 0;\r\nerr_dma_alloc:\r\nfor (i = 0; i < ATMCI_MAX_NR_SLOTS; i++) {\r\nif (host->slot[i])\r\natmci_cleanup_slot(host->slot[i], i);\r\n}\r\nerr_init_slot:\r\nclk_disable_unprepare(host->mck);\r\npm_runtime_disable(&pdev->dev);\r\npm_runtime_put_noidle(&pdev->dev);\r\ndel_timer_sync(&host->timer);\r\nif (!IS_ERR(host->dma.chan))\r\ndma_release_channel(host->dma.chan);\r\nerr_dma_probe_defer:\r\nfree_irq(irq, host);\r\nreturn ret;\r\n}\r\nstatic int atmci_remove(struct platform_device *pdev)\r\n{\r\nstruct atmel_mci *host = platform_get_drvdata(pdev);\r\nunsigned int i;\r\npm_runtime_get_sync(&pdev->dev);\r\nif (host->buffer)\r\ndma_free_coherent(&pdev->dev, host->buf_size,\r\nhost->buffer, host->buf_phys_addr);\r\nfor (i = 0; i < ATMCI_MAX_NR_SLOTS; i++) {\r\nif (host->slot[i])\r\natmci_cleanup_slot(host->slot[i], i);\r\n}\r\natmci_writel(host, ATMCI_IDR, ~0UL);\r\natmci_writel(host, ATMCI_CR, ATMCI_CR_MCIDIS);\r\natmci_readl(host, ATMCI_SR);\r\ndel_timer_sync(&host->timer);\r\nif (!IS_ERR(host->dma.chan))\r\ndma_release_channel(host->dma.chan);\r\nfree_irq(platform_get_irq(pdev, 0), host);\r\nclk_disable_unprepare(host->mck);\r\npm_runtime_disable(&pdev->dev);\r\npm_runtime_put_noidle(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int atmci_runtime_suspend(struct device *dev)\r\n{\r\nstruct atmel_mci *host = dev_get_drvdata(dev);\r\nclk_disable_unprepare(host->mck);\r\npinctrl_pm_select_sleep_state(dev);\r\nreturn 0;\r\n}\r\nstatic int atmci_runtime_resume(struct device *dev)\r\n{\r\nstruct atmel_mci *host = dev_get_drvdata(dev);\r\npinctrl_pm_select_default_state(dev);\r\nreturn clk_prepare_enable(host->mck);\r\n}
