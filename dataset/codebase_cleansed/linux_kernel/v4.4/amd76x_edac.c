static void amd76x_get_error_info(struct mem_ctl_info *mci,\r\nstruct amd76x_error_info *info)\r\n{\r\nstruct pci_dev *pdev;\r\npdev = to_pci_dev(mci->pdev);\r\npci_read_config_dword(pdev, AMD76X_ECC_MODE_STATUS,\r\n&info->ecc_mode_status);\r\nif (info->ecc_mode_status & BIT(8))\r\npci_write_bits32(pdev, AMD76X_ECC_MODE_STATUS,\r\n(u32) BIT(8), (u32) BIT(8));\r\nif (info->ecc_mode_status & BIT(9))\r\npci_write_bits32(pdev, AMD76X_ECC_MODE_STATUS,\r\n(u32) BIT(9), (u32) BIT(9));\r\n}\r\nstatic int amd76x_process_error_info(struct mem_ctl_info *mci,\r\nstruct amd76x_error_info *info,\r\nint handle_errors)\r\n{\r\nint error_found;\r\nu32 row;\r\nerror_found = 0;\r\nif (info->ecc_mode_status & BIT(8)) {\r\nerror_found = 1;\r\nif (handle_errors) {\r\nrow = (info->ecc_mode_status >> 4) & 0xf;\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\r\nmci->csrows[row]->first_page, 0, 0,\r\nrow, 0, -1,\r\nmci->ctl_name, "");\r\n}\r\n}\r\nif (info->ecc_mode_status & BIT(9)) {\r\nerror_found = 1;\r\nif (handle_errors) {\r\nrow = info->ecc_mode_status & 0xf;\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\nmci->csrows[row]->first_page, 0, 0,\r\nrow, 0, -1,\r\nmci->ctl_name, "");\r\n}\r\n}\r\nreturn error_found;\r\n}\r\nstatic void amd76x_check(struct mem_ctl_info *mci)\r\n{\r\nstruct amd76x_error_info info;\r\nedac_dbg(3, "\n");\r\namd76x_get_error_info(mci, &info);\r\namd76x_process_error_info(mci, &info, 1);\r\n}\r\nstatic void amd76x_init_csrows(struct mem_ctl_info *mci, struct pci_dev *pdev,\r\nenum edac_type edac_mode)\r\n{\r\nstruct csrow_info *csrow;\r\nstruct dimm_info *dimm;\r\nu32 mba, mba_base, mba_mask, dms;\r\nint index;\r\nfor (index = 0; index < mci->nr_csrows; index++) {\r\ncsrow = mci->csrows[index];\r\ndimm = csrow->channels[0]->dimm;\r\npci_read_config_dword(pdev,\r\nAMD76X_MEM_BASE_ADDR + (index * 4), &mba);\r\nif (!(mba & BIT(0)))\r\ncontinue;\r\nmba_base = mba & 0xff800000UL;\r\nmba_mask = ((mba & 0xff80) << 16) | 0x7fffffUL;\r\npci_read_config_dword(pdev, AMD76X_DRAM_MODE_STATUS, &dms);\r\ncsrow->first_page = mba_base >> PAGE_SHIFT;\r\ndimm->nr_pages = (mba_mask + 1) >> PAGE_SHIFT;\r\ncsrow->last_page = csrow->first_page + dimm->nr_pages - 1;\r\ncsrow->page_mask = mba_mask >> PAGE_SHIFT;\r\ndimm->grain = dimm->nr_pages << PAGE_SHIFT;\r\ndimm->mtype = MEM_RDDR;\r\ndimm->dtype = ((dms >> index) & 0x1) ? DEV_X4 : DEV_UNKNOWN;\r\ndimm->edac_mode = edac_mode;\r\n}\r\n}\r\nstatic int amd76x_probe1(struct pci_dev *pdev, int dev_idx)\r\n{\r\nstatic const enum edac_type ems_modes[] = {\r\nEDAC_NONE,\r\nEDAC_EC,\r\nEDAC_SECDED,\r\nEDAC_SECDED\r\n};\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[2];\r\nu32 ems;\r\nu32 ems_mode;\r\nstruct amd76x_error_info discard;\r\nedac_dbg(0, "\n");\r\npci_read_config_dword(pdev, AMD76X_ECC_MODE_STATUS, &ems);\r\nems_mode = (ems >> 10) & 0x3;\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = AMD76X_NR_CSROWS;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = 1;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, 0);\r\nif (mci == NULL)\r\nreturn -ENOMEM;\r\nedac_dbg(0, "mci = %p\n", mci);\r\nmci->pdev = &pdev->dev;\r\nmci->mtype_cap = MEM_FLAG_RDDR;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_EC | EDAC_FLAG_SECDED;\r\nmci->edac_cap = ems_mode ?\r\n(EDAC_FLAG_EC | EDAC_FLAG_SECDED) : EDAC_FLAG_NONE;\r\nmci->mod_name = EDAC_MOD_STR;\r\nmci->mod_ver = AMD76X_REVISION;\r\nmci->ctl_name = amd76x_devs[dev_idx].ctl_name;\r\nmci->dev_name = pci_name(pdev);\r\nmci->edac_check = amd76x_check;\r\nmci->ctl_page_to_phys = NULL;\r\namd76x_init_csrows(mci, pdev, ems_modes[ems_mode]);\r\namd76x_get_error_info(mci, &discard);\r\nif (edac_mc_add_mc(mci)) {\r\nedac_dbg(3, "failed edac_mc_add_mc()\n");\r\ngoto fail;\r\n}\r\namd76x_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\r\nif (!amd76x_pci) {\r\nprintk(KERN_WARNING\r\n"%s(): Unable to create PCI control\n",\r\n__func__);\r\nprintk(KERN_WARNING\r\n"%s(): PCI error report via EDAC not setup\n",\r\n__func__);\r\n}\r\nedac_dbg(3, "success\n");\r\nreturn 0;\r\nfail:\r\nedac_mc_free(mci);\r\nreturn -ENODEV;\r\n}\r\nstatic int amd76x_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nedac_dbg(0, "\n");\r\nreturn amd76x_probe1(pdev, ent->driver_data);\r\n}\r\nstatic void amd76x_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nedac_dbg(0, "\n");\r\nif (amd76x_pci)\r\nedac_pci_release_generic_ctl(amd76x_pci);\r\nif ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)\r\nreturn;\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init amd76x_init(void)\r\n{\r\nopstate_init();\r\nreturn pci_register_driver(&amd76x_driver);\r\n}\r\nstatic void __exit amd76x_exit(void)\r\n{\r\npci_unregister_driver(&amd76x_driver);\r\n}
