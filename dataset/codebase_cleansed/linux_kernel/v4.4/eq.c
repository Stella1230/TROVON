static u64 get_async_ev_mask(struct mlx4_dev *dev)\r\n{\r\nu64 async_ev_mask = MLX4_ASYNC_EVENT_MASK;\r\nif (dev->caps.flags & MLX4_DEV_CAP_FLAG_PORT_MNG_CHG_EV)\r\nasync_ev_mask |= (1ull << MLX4_EVENT_TYPE_PORT_MNG_CHG_EVENT);\r\nif (dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_RECOVERABLE_ERROR_EVENT)\r\nasync_ev_mask |= (1ull << MLX4_EVENT_TYPE_RECOVERABLE_ERROR_EVENT);\r\nreturn async_ev_mask;\r\n}\r\nstatic void eq_set_ci(struct mlx4_eq *eq, int req_not)\r\n{\r\n__raw_writel((__force u32) cpu_to_be32((eq->cons_index & 0xffffff) |\r\nreq_not << 31),\r\neq->doorbell);\r\nmb();\r\n}\r\nstatic struct mlx4_eqe *get_eqe(struct mlx4_eq *eq, u32 entry, u8 eqe_factor,\r\nu8 eqe_size)\r\n{\r\nunsigned long offset = (entry & (eq->nent - 1)) * eqe_size;\r\nreturn eq->page_list[offset / PAGE_SIZE].buf + (offset + (eqe_factor ? MLX4_EQ_ENTRY_SIZE : 0)) % PAGE_SIZE;\r\n}\r\nstatic struct mlx4_eqe *next_eqe_sw(struct mlx4_eq *eq, u8 eqe_factor, u8 size)\r\n{\r\nstruct mlx4_eqe *eqe = get_eqe(eq, eq->cons_index, eqe_factor, size);\r\nreturn !!(eqe->owner & 0x80) ^ !!(eq->cons_index & eq->nent) ? NULL : eqe;\r\n}\r\nstatic struct mlx4_eqe *next_slave_event_eqe(struct mlx4_slave_event_eq *slave_eq)\r\n{\r\nstruct mlx4_eqe *eqe =\r\n&slave_eq->event_eqe[slave_eq->cons & (SLAVE_EVENT_EQ_SIZE - 1)];\r\nreturn (!!(eqe->owner & 0x80) ^\r\n!!(slave_eq->cons & SLAVE_EVENT_EQ_SIZE)) ?\r\neqe : NULL;\r\n}\r\nvoid mlx4_gen_slave_eqe(struct work_struct *work)\r\n{\r\nstruct mlx4_mfunc_master_ctx *master =\r\ncontainer_of(work, struct mlx4_mfunc_master_ctx,\r\nslave_event_work);\r\nstruct mlx4_mfunc *mfunc =\r\ncontainer_of(master, struct mlx4_mfunc, master);\r\nstruct mlx4_priv *priv = container_of(mfunc, struct mlx4_priv, mfunc);\r\nstruct mlx4_dev *dev = &priv->dev;\r\nstruct mlx4_slave_event_eq *slave_eq = &mfunc->master.slave_eq;\r\nstruct mlx4_eqe *eqe;\r\nu8 slave;\r\nint i, phys_port, slave_port;\r\nfor (eqe = next_slave_event_eqe(slave_eq); eqe;\r\neqe = next_slave_event_eqe(slave_eq)) {\r\nslave = eqe->slave_id;\r\nif (slave == ALL_SLAVES) {\r\nfor (i = 0; i <= dev->persist->num_vfs; i++) {\r\nphys_port = 0;\r\nif (eqe->type == MLX4_EVENT_TYPE_PORT_MNG_CHG_EVENT &&\r\neqe->subtype == MLX4_DEV_PMC_SUBTYPE_PORT_INFO) {\r\nphys_port = eqe->event.port_mgmt_change.port;\r\nslave_port = mlx4_phys_to_slave_port(dev, i, phys_port);\r\nif (slave_port < 0)\r\ncontinue;\r\neqe->event.port_mgmt_change.port = slave_port;\r\n}\r\nif (mlx4_GEN_EQE(dev, i, eqe))\r\nmlx4_warn(dev, "Failed to generate event for slave %d\n",\r\ni);\r\nif (phys_port)\r\neqe->event.port_mgmt_change.port = phys_port;\r\n}\r\n} else {\r\nif (mlx4_GEN_EQE(dev, slave, eqe))\r\nmlx4_warn(dev, "Failed to generate event for slave %d\n",\r\nslave);\r\n}\r\n++slave_eq->cons;\r\n}\r\n}\r\nstatic void slave_event(struct mlx4_dev *dev, u8 slave, struct mlx4_eqe *eqe)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_slave_event_eq *slave_eq = &priv->mfunc.master.slave_eq;\r\nstruct mlx4_eqe *s_eqe;\r\nunsigned long flags;\r\nspin_lock_irqsave(&slave_eq->event_lock, flags);\r\ns_eqe = &slave_eq->event_eqe[slave_eq->prod & (SLAVE_EVENT_EQ_SIZE - 1)];\r\nif ((!!(s_eqe->owner & 0x80)) ^\r\n(!!(slave_eq->prod & SLAVE_EVENT_EQ_SIZE))) {\r\nmlx4_warn(dev, "Master failed to generate an EQE for slave: %d. No free EQE on slave events queue\n",\r\nslave);\r\nspin_unlock_irqrestore(&slave_eq->event_lock, flags);\r\nreturn;\r\n}\r\nmemcpy(s_eqe, eqe, sizeof(struct mlx4_eqe) - 1);\r\ns_eqe->slave_id = slave;\r\ndma_wmb();\r\ns_eqe->owner = !!(slave_eq->prod & SLAVE_EVENT_EQ_SIZE) ? 0x0 : 0x80;\r\n++slave_eq->prod;\r\nqueue_work(priv->mfunc.master.comm_wq,\r\n&priv->mfunc.master.slave_event_work);\r\nspin_unlock_irqrestore(&slave_eq->event_lock, flags);\r\n}\r\nstatic void mlx4_slave_event(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_eqe *eqe)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nif (slave < 0 || slave > dev->persist->num_vfs ||\r\nslave == dev->caps.function ||\r\n!priv->mfunc.master.slave_state[slave].active)\r\nreturn;\r\nslave_event(dev, slave, eqe);\r\n}\r\nstatic void mlx4_set_eq_affinity_hint(struct mlx4_priv *priv, int vec)\r\n{\r\nint hint_err;\r\nstruct mlx4_dev *dev = &priv->dev;\r\nstruct mlx4_eq *eq = &priv->eq_table.eq[vec];\r\nif (!eq->affinity_mask || cpumask_empty(eq->affinity_mask))\r\nreturn;\r\nhint_err = irq_set_affinity_hint(eq->irq, eq->affinity_mask);\r\nif (hint_err)\r\nmlx4_warn(dev, "irq_set_affinity_hint failed, err %d\n", hint_err);\r\n}\r\nint mlx4_gen_pkey_eqe(struct mlx4_dev *dev, int slave, u8 port)\r\n{\r\nstruct mlx4_eqe eqe;\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_slave_state *s_slave = &priv->mfunc.master.slave_state[slave];\r\nif (!s_slave->active)\r\nreturn 0;\r\nmemset(&eqe, 0, sizeof eqe);\r\neqe.type = MLX4_EVENT_TYPE_PORT_MNG_CHG_EVENT;\r\neqe.subtype = MLX4_DEV_PMC_SUBTYPE_PKEY_TABLE;\r\neqe.event.port_mgmt_change.port = mlx4_phys_to_slave_port(dev, slave, port);\r\nreturn mlx4_GEN_EQE(dev, slave, &eqe);\r\n}\r\nint mlx4_gen_guid_change_eqe(struct mlx4_dev *dev, int slave, u8 port)\r\n{\r\nstruct mlx4_eqe eqe;\r\nif (dev->persist->num_vfs < slave)\r\nreturn 0;\r\nmemset(&eqe, 0, sizeof eqe);\r\neqe.type = MLX4_EVENT_TYPE_PORT_MNG_CHG_EVENT;\r\neqe.subtype = MLX4_DEV_PMC_SUBTYPE_GUID_INFO;\r\neqe.event.port_mgmt_change.port = mlx4_phys_to_slave_port(dev, slave, port);\r\nreturn mlx4_GEN_EQE(dev, slave, &eqe);\r\n}\r\nint mlx4_gen_port_state_change_eqe(struct mlx4_dev *dev, int slave, u8 port,\r\nu8 port_subtype_change)\r\n{\r\nstruct mlx4_eqe eqe;\r\nu8 slave_port = mlx4_phys_to_slave_port(dev, slave, port);\r\nif (dev->persist->num_vfs < slave)\r\nreturn 0;\r\nmemset(&eqe, 0, sizeof eqe);\r\neqe.type = MLX4_EVENT_TYPE_PORT_CHANGE;\r\neqe.subtype = port_subtype_change;\r\neqe.event.port_change.port = cpu_to_be32(slave_port << 28);\r\nmlx4_dbg(dev, "%s: sending: %d to slave: %d on port: %d\n", __func__,\r\nport_subtype_change, slave, port);\r\nreturn mlx4_GEN_EQE(dev, slave, &eqe);\r\n}\r\nenum slave_port_state mlx4_get_slave_port_state(struct mlx4_dev *dev, int slave, u8 port)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_slave_state *s_state = priv->mfunc.master.slave_state;\r\nstruct mlx4_active_ports actv_ports = mlx4_get_active_ports(dev, slave);\r\nif (slave >= dev->num_slaves || port > dev->caps.num_ports ||\r\nport <= 0 || !test_bit(port - 1, actv_ports.ports)) {\r\npr_err("%s: Error: asking for slave:%d, port:%d\n",\r\n__func__, slave, port);\r\nreturn SLAVE_PORT_DOWN;\r\n}\r\nreturn s_state[slave].port_state[port];\r\n}\r\nstatic int mlx4_set_slave_port_state(struct mlx4_dev *dev, int slave, u8 port,\r\nenum slave_port_state state)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_slave_state *s_state = priv->mfunc.master.slave_state;\r\nstruct mlx4_active_ports actv_ports = mlx4_get_active_ports(dev, slave);\r\nif (slave >= dev->num_slaves || port > dev->caps.num_ports ||\r\nport <= 0 || !test_bit(port - 1, actv_ports.ports)) {\r\npr_err("%s: Error: asking for slave:%d, port:%d\n",\r\n__func__, slave, port);\r\nreturn -1;\r\n}\r\ns_state[slave].port_state[port] = state;\r\nreturn 0;\r\n}\r\nstatic void set_all_slave_state(struct mlx4_dev *dev, u8 port, int event)\r\n{\r\nint i;\r\nenum slave_port_gen_event gen_event;\r\nstruct mlx4_slaves_pport slaves_pport = mlx4_phys_to_slaves_pport(dev,\r\nport);\r\nfor (i = 0; i < dev->persist->num_vfs + 1; i++)\r\nif (test_bit(i, slaves_pport.slaves))\r\nset_and_calc_slave_port_state(dev, i, port,\r\nevent, &gen_event);\r\n}\r\nint set_and_calc_slave_port_state(struct mlx4_dev *dev, int slave,\r\nu8 port, int event,\r\nenum slave_port_gen_event *gen_event)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_slave_state *ctx = NULL;\r\nunsigned long flags;\r\nint ret = -1;\r\nstruct mlx4_active_ports actv_ports = mlx4_get_active_ports(dev, slave);\r\nenum slave_port_state cur_state =\r\nmlx4_get_slave_port_state(dev, slave, port);\r\n*gen_event = SLAVE_PORT_GEN_EVENT_NONE;\r\nif (slave >= dev->num_slaves || port > dev->caps.num_ports ||\r\nport <= 0 || !test_bit(port - 1, actv_ports.ports)) {\r\npr_err("%s: Error: asking for slave:%d, port:%d\n",\r\n__func__, slave, port);\r\nreturn ret;\r\n}\r\nctx = &priv->mfunc.master.slave_state[slave];\r\nspin_lock_irqsave(&ctx->lock, flags);\r\nswitch (cur_state) {\r\ncase SLAVE_PORT_DOWN:\r\nif (MLX4_PORT_STATE_DEV_EVENT_PORT_UP == event)\r\nmlx4_set_slave_port_state(dev, slave, port,\r\nSLAVE_PENDING_UP);\r\nbreak;\r\ncase SLAVE_PENDING_UP:\r\nif (MLX4_PORT_STATE_DEV_EVENT_PORT_DOWN == event)\r\nmlx4_set_slave_port_state(dev, slave, port,\r\nSLAVE_PORT_DOWN);\r\nelse if (MLX4_PORT_STATE_IB_PORT_STATE_EVENT_GID_VALID == event) {\r\nmlx4_set_slave_port_state(dev, slave, port,\r\nSLAVE_PORT_UP);\r\n*gen_event = SLAVE_PORT_GEN_EVENT_UP;\r\n}\r\nbreak;\r\ncase SLAVE_PORT_UP:\r\nif (MLX4_PORT_STATE_DEV_EVENT_PORT_DOWN == event) {\r\nmlx4_set_slave_port_state(dev, slave, port,\r\nSLAVE_PORT_DOWN);\r\n*gen_event = SLAVE_PORT_GEN_EVENT_DOWN;\r\n} else if (MLX4_PORT_STATE_IB_EVENT_GID_INVALID ==\r\nevent) {\r\nmlx4_set_slave_port_state(dev, slave, port,\r\nSLAVE_PENDING_UP);\r\n*gen_event = SLAVE_PORT_GEN_EVENT_DOWN;\r\n}\r\nbreak;\r\ndefault:\r\npr_err("%s: BUG!!! UNKNOWN state: slave:%d, port:%d\n",\r\n__func__, slave, port);\r\ngoto out;\r\n}\r\nret = mlx4_get_slave_port_state(dev, slave, port);\r\nout:\r\nspin_unlock_irqrestore(&ctx->lock, flags);\r\nreturn ret;\r\n}\r\nint mlx4_gen_slaves_port_mgt_ev(struct mlx4_dev *dev, u8 port, int attr)\r\n{\r\nstruct mlx4_eqe eqe;\r\nmemset(&eqe, 0, sizeof eqe);\r\neqe.type = MLX4_EVENT_TYPE_PORT_MNG_CHG_EVENT;\r\neqe.subtype = MLX4_DEV_PMC_SUBTYPE_PORT_INFO;\r\neqe.event.port_mgmt_change.port = port;\r\neqe.event.port_mgmt_change.params.port_info.changed_attr =\r\ncpu_to_be32((u32) attr);\r\nslave_event(dev, ALL_SLAVES, &eqe);\r\nreturn 0;\r\n}\r\nvoid mlx4_master_handle_slave_flr(struct work_struct *work)\r\n{\r\nstruct mlx4_mfunc_master_ctx *master =\r\ncontainer_of(work, struct mlx4_mfunc_master_ctx,\r\nslave_flr_event_work);\r\nstruct mlx4_mfunc *mfunc =\r\ncontainer_of(master, struct mlx4_mfunc, master);\r\nstruct mlx4_priv *priv =\r\ncontainer_of(mfunc, struct mlx4_priv, mfunc);\r\nstruct mlx4_dev *dev = &priv->dev;\r\nstruct mlx4_slave_state *slave_state = priv->mfunc.master.slave_state;\r\nint i;\r\nint err;\r\nunsigned long flags;\r\nmlx4_dbg(dev, "mlx4_handle_slave_flr\n");\r\nfor (i = 0 ; i < dev->num_slaves; i++) {\r\nif (MLX4_COMM_CMD_FLR == slave_state[i].last_cmd) {\r\nmlx4_dbg(dev, "mlx4_handle_slave_flr: clean slave: %d\n",\r\ni);\r\nif (dev->persist->interface_state &\r\nMLX4_INTERFACE_STATE_UP)\r\nmlx4_delete_all_resources_for_slave(dev, i);\r\nspin_lock_irqsave(&priv->mfunc.master.slave_state_lock, flags);\r\nslave_state[i].last_cmd = MLX4_COMM_CMD_RESET;\r\nslave_state[i].is_slave_going_down = 0;\r\nspin_unlock_irqrestore(&priv->mfunc.master.slave_state_lock, flags);\r\nerr = mlx4_cmd(dev, 0, i, 0, MLX4_CMD_INFORM_FLR_DONE,\r\nMLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\r\nif (err)\r\nmlx4_warn(dev, "Failed to notify FW on FLR done (slave:%d)\n",\r\ni);\r\n}\r\n}\r\n}\r\nstatic int mlx4_eq_int(struct mlx4_dev *dev, struct mlx4_eq *eq)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_eqe *eqe;\r\nint cqn = -1;\r\nint eqes_found = 0;\r\nint set_ci = 0;\r\nint port;\r\nint slave = 0;\r\nint ret;\r\nu32 flr_slave;\r\nu8 update_slave_state;\r\nint i;\r\nenum slave_port_gen_event gen_event;\r\nunsigned long flags;\r\nstruct mlx4_vport_state *s_info;\r\nint eqe_size = dev->caps.eqe_size;\r\nwhile ((eqe = next_eqe_sw(eq, dev->caps.eqe_factor, eqe_size))) {\r\ndma_rmb();\r\nswitch (eqe->type) {\r\ncase MLX4_EVENT_TYPE_COMP:\r\ncqn = be32_to_cpu(eqe->event.comp.cqn) & 0xffffff;\r\nmlx4_cq_completion(dev, cqn);\r\nbreak;\r\ncase MLX4_EVENT_TYPE_PATH_MIG:\r\ncase MLX4_EVENT_TYPE_COMM_EST:\r\ncase MLX4_EVENT_TYPE_SQ_DRAINED:\r\ncase MLX4_EVENT_TYPE_SRQ_QP_LAST_WQE:\r\ncase MLX4_EVENT_TYPE_WQ_CATAS_ERROR:\r\ncase MLX4_EVENT_TYPE_PATH_MIG_FAILED:\r\ncase MLX4_EVENT_TYPE_WQ_INVAL_REQ_ERROR:\r\ncase MLX4_EVENT_TYPE_WQ_ACCESS_ERROR:\r\nmlx4_dbg(dev, "event %d arrived\n", eqe->type);\r\nif (mlx4_is_master(dev)) {\r\nret = mlx4_get_slave_from_resource_id(dev,\r\nRES_QP,\r\nbe32_to_cpu(eqe->event.qp.qpn)\r\n& 0xffffff, &slave);\r\nif (ret && ret != -ENOENT) {\r\nmlx4_dbg(dev, "QP event %02x(%02x) on EQ %d at index %u: could not get slave id (%d)\n",\r\neqe->type, eqe->subtype,\r\neq->eqn, eq->cons_index, ret);\r\nbreak;\r\n}\r\nif (!ret && slave != dev->caps.function) {\r\nmlx4_slave_event(dev, slave, eqe);\r\nbreak;\r\n}\r\n}\r\nmlx4_qp_event(dev, be32_to_cpu(eqe->event.qp.qpn) &\r\n0xffffff, eqe->type);\r\nbreak;\r\ncase MLX4_EVENT_TYPE_SRQ_LIMIT:\r\nmlx4_dbg(dev, "%s: MLX4_EVENT_TYPE_SRQ_LIMIT\n",\r\n__func__);\r\ncase MLX4_EVENT_TYPE_SRQ_CATAS_ERROR:\r\nif (mlx4_is_master(dev)) {\r\nret = mlx4_get_slave_from_resource_id(dev,\r\nRES_SRQ,\r\nbe32_to_cpu(eqe->event.srq.srqn)\r\n& 0xffffff,\r\n&slave);\r\nif (ret && ret != -ENOENT) {\r\nmlx4_warn(dev, "SRQ event %02x(%02x) on EQ %d at index %u: could not get slave id (%d)\n",\r\neqe->type, eqe->subtype,\r\neq->eqn, eq->cons_index, ret);\r\nbreak;\r\n}\r\nmlx4_warn(dev, "%s: slave:%d, srq_no:0x%x, event: %02x(%02x)\n",\r\n__func__, slave,\r\nbe32_to_cpu(eqe->event.srq.srqn),\r\neqe->type, eqe->subtype);\r\nif (!ret && slave != dev->caps.function) {\r\nmlx4_warn(dev, "%s: sending event %02x(%02x) to slave:%d\n",\r\n__func__, eqe->type,\r\neqe->subtype, slave);\r\nmlx4_slave_event(dev, slave, eqe);\r\nbreak;\r\n}\r\n}\r\nmlx4_srq_event(dev, be32_to_cpu(eqe->event.srq.srqn) &\r\n0xffffff, eqe->type);\r\nbreak;\r\ncase MLX4_EVENT_TYPE_CMD:\r\nmlx4_cmd_event(dev,\r\nbe16_to_cpu(eqe->event.cmd.token),\r\neqe->event.cmd.status,\r\nbe64_to_cpu(eqe->event.cmd.out_param));\r\nbreak;\r\ncase MLX4_EVENT_TYPE_PORT_CHANGE: {\r\nstruct mlx4_slaves_pport slaves_port;\r\nport = be32_to_cpu(eqe->event.port_change.port) >> 28;\r\nslaves_port = mlx4_phys_to_slaves_pport(dev, port);\r\nif (eqe->subtype == MLX4_PORT_CHANGE_SUBTYPE_DOWN) {\r\nmlx4_dispatch_event(dev, MLX4_DEV_EVENT_PORT_DOWN,\r\nport);\r\nmlx4_priv(dev)->sense.do_sense_port[port] = 1;\r\nif (!mlx4_is_master(dev))\r\nbreak;\r\nfor (i = 0; i < dev->persist->num_vfs + 1;\r\ni++) {\r\nif (!test_bit(i, slaves_port.slaves))\r\ncontinue;\r\nif (dev->caps.port_type[port] == MLX4_PORT_TYPE_ETH) {\r\nif (i == mlx4_master_func_num(dev))\r\ncontinue;\r\nmlx4_dbg(dev, "%s: Sending MLX4_PORT_CHANGE_SUBTYPE_DOWN to slave: %d, port:%d\n",\r\n__func__, i, port);\r\ns_info = &priv->mfunc.master.vf_oper[i].vport[port].state;\r\nif (IFLA_VF_LINK_STATE_AUTO == s_info->link_state) {\r\neqe->event.port_change.port =\r\ncpu_to_be32(\r\n(be32_to_cpu(eqe->event.port_change.port) & 0xFFFFFFF)\r\n| (mlx4_phys_to_slave_port(dev, i, port) << 28));\r\nmlx4_slave_event(dev, i, eqe);\r\n}\r\n} else {\r\nset_and_calc_slave_port_state(dev, i, port,\r\nMLX4_PORT_STATE_DEV_EVENT_PORT_DOWN,\r\n&gen_event);\r\nif (SLAVE_PORT_GEN_EVENT_DOWN == gen_event) {\r\nif (i == mlx4_master_func_num(dev))\r\ncontinue;\r\neqe->event.port_change.port =\r\ncpu_to_be32(\r\n(be32_to_cpu(eqe->event.port_change.port) & 0xFFFFFFF)\r\n| (mlx4_phys_to_slave_port(dev, i, port) << 28));\r\nmlx4_slave_event(dev, i, eqe);\r\n}\r\n}\r\n}\r\n} else {\r\nmlx4_dispatch_event(dev, MLX4_DEV_EVENT_PORT_UP, port);\r\nmlx4_priv(dev)->sense.do_sense_port[port] = 0;\r\nif (!mlx4_is_master(dev))\r\nbreak;\r\nif (dev->caps.port_type[port] == MLX4_PORT_TYPE_ETH)\r\nfor (i = 0;\r\ni < dev->persist->num_vfs + 1;\r\ni++) {\r\nif (!test_bit(i, slaves_port.slaves))\r\ncontinue;\r\nif (i == mlx4_master_func_num(dev))\r\ncontinue;\r\ns_info = &priv->mfunc.master.vf_oper[i].vport[port].state;\r\nif (IFLA_VF_LINK_STATE_AUTO == s_info->link_state) {\r\neqe->event.port_change.port =\r\ncpu_to_be32(\r\n(be32_to_cpu(eqe->event.port_change.port) & 0xFFFFFFF)\r\n| (mlx4_phys_to_slave_port(dev, i, port) << 28));\r\nmlx4_slave_event(dev, i, eqe);\r\n}\r\n}\r\nelse\r\nset_all_slave_state(dev, port, MLX4_DEV_EVENT_PORT_UP);\r\n}\r\nbreak;\r\n}\r\ncase MLX4_EVENT_TYPE_CQ_ERROR:\r\nmlx4_warn(dev, "CQ %s on CQN %06x\n",\r\neqe->event.cq_err.syndrome == 1 ?\r\n"overrun" : "access violation",\r\nbe32_to_cpu(eqe->event.cq_err.cqn) & 0xffffff);\r\nif (mlx4_is_master(dev)) {\r\nret = mlx4_get_slave_from_resource_id(dev,\r\nRES_CQ,\r\nbe32_to_cpu(eqe->event.cq_err.cqn)\r\n& 0xffffff, &slave);\r\nif (ret && ret != -ENOENT) {\r\nmlx4_dbg(dev, "CQ event %02x(%02x) on EQ %d at index %u: could not get slave id (%d)\n",\r\neqe->type, eqe->subtype,\r\neq->eqn, eq->cons_index, ret);\r\nbreak;\r\n}\r\nif (!ret && slave != dev->caps.function) {\r\nmlx4_slave_event(dev, slave, eqe);\r\nbreak;\r\n}\r\n}\r\nmlx4_cq_event(dev,\r\nbe32_to_cpu(eqe->event.cq_err.cqn)\r\n& 0xffffff,\r\neqe->type);\r\nbreak;\r\ncase MLX4_EVENT_TYPE_EQ_OVERFLOW:\r\nmlx4_warn(dev, "EQ overrun on EQN %d\n", eq->eqn);\r\nbreak;\r\ncase MLX4_EVENT_TYPE_OP_REQUIRED:\r\natomic_inc(&priv->opreq_count);\r\nqueue_work(mlx4_wq, &priv->opreq_task);\r\nbreak;\r\ncase MLX4_EVENT_TYPE_COMM_CHANNEL:\r\nif (!mlx4_is_master(dev)) {\r\nmlx4_warn(dev, "Received comm channel event for non master device\n");\r\nbreak;\r\n}\r\nmemcpy(&priv->mfunc.master.comm_arm_bit_vector,\r\neqe->event.comm_channel_arm.bit_vec,\r\nsizeof eqe->event.comm_channel_arm.bit_vec);\r\nqueue_work(priv->mfunc.master.comm_wq,\r\n&priv->mfunc.master.comm_work);\r\nbreak;\r\ncase MLX4_EVENT_TYPE_FLR_EVENT:\r\nflr_slave = be32_to_cpu(eqe->event.flr_event.slave_id);\r\nif (!mlx4_is_master(dev)) {\r\nmlx4_warn(dev, "Non-master function received FLR event\n");\r\nbreak;\r\n}\r\nmlx4_dbg(dev, "FLR event for slave: %d\n", flr_slave);\r\nif (flr_slave >= dev->num_slaves) {\r\nmlx4_warn(dev,\r\n"Got FLR for unknown function: %d\n",\r\nflr_slave);\r\nupdate_slave_state = 0;\r\n} else\r\nupdate_slave_state = 1;\r\nspin_lock_irqsave(&priv->mfunc.master.slave_state_lock, flags);\r\nif (update_slave_state) {\r\npriv->mfunc.master.slave_state[flr_slave].active = false;\r\npriv->mfunc.master.slave_state[flr_slave].last_cmd = MLX4_COMM_CMD_FLR;\r\npriv->mfunc.master.slave_state[flr_slave].is_slave_going_down = 1;\r\n}\r\nspin_unlock_irqrestore(&priv->mfunc.master.slave_state_lock, flags);\r\nmlx4_dispatch_event(dev, MLX4_DEV_EVENT_SLAVE_SHUTDOWN,\r\nflr_slave);\r\nqueue_work(priv->mfunc.master.comm_wq,\r\n&priv->mfunc.master.slave_flr_event_work);\r\nbreak;\r\ncase MLX4_EVENT_TYPE_FATAL_WARNING:\r\nif (eqe->subtype == MLX4_FATAL_WARNING_SUBTYPE_WARMING) {\r\nif (mlx4_is_master(dev))\r\nfor (i = 0; i < dev->num_slaves; i++) {\r\nmlx4_dbg(dev, "%s: Sending MLX4_FATAL_WARNING_SUBTYPE_WARMING to slave: %d\n",\r\n__func__, i);\r\nif (i == dev->caps.function)\r\ncontinue;\r\nmlx4_slave_event(dev, i, eqe);\r\n}\r\nmlx4_err(dev, "Temperature Threshold was reached! Threshold: %d celsius degrees; Current Temperature: %d\n",\r\nbe16_to_cpu(eqe->event.warming.warning_threshold),\r\nbe16_to_cpu(eqe->event.warming.current_temperature));\r\n} else\r\nmlx4_warn(dev, "Unhandled event FATAL WARNING (%02x), subtype %02x on EQ %d at index %u. owner=%x, nent=0x%x, slave=%x, ownership=%s\n",\r\neqe->type, eqe->subtype, eq->eqn,\r\neq->cons_index, eqe->owner, eq->nent,\r\neqe->slave_id,\r\n!!(eqe->owner & 0x80) ^\r\n!!(eq->cons_index & eq->nent) ? "HW" : "SW");\r\nbreak;\r\ncase MLX4_EVENT_TYPE_PORT_MNG_CHG_EVENT:\r\nmlx4_dispatch_event(dev, MLX4_DEV_EVENT_PORT_MGMT_CHANGE,\r\n(unsigned long) eqe);\r\nbreak;\r\ncase MLX4_EVENT_TYPE_RECOVERABLE_ERROR_EVENT:\r\nswitch (eqe->subtype) {\r\ncase MLX4_RECOVERABLE_ERROR_EVENT_SUBTYPE_BAD_CABLE:\r\nmlx4_warn(dev, "Bad cable detected on port %u\n",\r\neqe->event.bad_cable.port);\r\nbreak;\r\ncase MLX4_RECOVERABLE_ERROR_EVENT_SUBTYPE_UNSUPPORTED_CABLE:\r\nmlx4_warn(dev, "Unsupported cable detected\n");\r\nbreak;\r\ndefault:\r\nmlx4_dbg(dev,\r\n"Unhandled recoverable error event detected: %02x(%02x) on EQ %d at index %u. owner=%x, nent=0x%x, ownership=%s\n",\r\neqe->type, eqe->subtype, eq->eqn,\r\neq->cons_index, eqe->owner, eq->nent,\r\n!!(eqe->owner & 0x80) ^\r\n!!(eq->cons_index & eq->nent) ? "HW" : "SW");\r\nbreak;\r\n}\r\nbreak;\r\ncase MLX4_EVENT_TYPE_EEC_CATAS_ERROR:\r\ncase MLX4_EVENT_TYPE_ECC_DETECT:\r\ndefault:\r\nmlx4_warn(dev, "Unhandled event %02x(%02x) on EQ %d at index %u. owner=%x, nent=0x%x, slave=%x, ownership=%s\n",\r\neqe->type, eqe->subtype, eq->eqn,\r\neq->cons_index, eqe->owner, eq->nent,\r\neqe->slave_id,\r\n!!(eqe->owner & 0x80) ^\r\n!!(eq->cons_index & eq->nent) ? "HW" : "SW");\r\nbreak;\r\n};\r\n++eq->cons_index;\r\neqes_found = 1;\r\n++set_ci;\r\nif (unlikely(set_ci >= MLX4_NUM_SPARE_EQE)) {\r\neq_set_ci(eq, 0);\r\nset_ci = 0;\r\n}\r\n}\r\neq_set_ci(eq, 1);\r\nif (!(cqn & ~0xffffff))\r\ntasklet_schedule(&eq->tasklet_ctx.task);\r\nreturn eqes_found;\r\n}\r\nstatic irqreturn_t mlx4_interrupt(int irq, void *dev_ptr)\r\n{\r\nstruct mlx4_dev *dev = dev_ptr;\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint work = 0;\r\nint i;\r\nwritel(priv->eq_table.clr_mask, priv->eq_table.clr_int);\r\nfor (i = 0; i < dev->caps.num_comp_vectors + 1; ++i)\r\nwork |= mlx4_eq_int(dev, &priv->eq_table.eq[i]);\r\nreturn IRQ_RETVAL(work);\r\n}\r\nstatic irqreturn_t mlx4_msi_x_interrupt(int irq, void *eq_ptr)\r\n{\r\nstruct mlx4_eq *eq = eq_ptr;\r\nstruct mlx4_dev *dev = eq->dev;\r\nmlx4_eq_int(dev, eq);\r\nreturn IRQ_HANDLED;\r\n}\r\nint mlx4_MAP_EQ_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_slave_event_eq_info *event_eq =\r\npriv->mfunc.master.slave_state[slave].event_eq;\r\nu32 in_modifier = vhcr->in_modifier;\r\nu32 eqn = in_modifier & 0x3FF;\r\nu64 in_param = vhcr->in_param;\r\nint err = 0;\r\nint i;\r\nif (slave == dev->caps.function)\r\nerr = mlx4_cmd(dev, in_param, (in_modifier & 0x80000000) | eqn,\r\n0, MLX4_CMD_MAP_EQ, MLX4_CMD_TIME_CLASS_B,\r\nMLX4_CMD_NATIVE);\r\nif (!err)\r\nfor (i = 0; i < MLX4_EVENT_TYPES_NUM; ++i)\r\nif (in_param & (1LL << i))\r\nevent_eq[i].eqn = in_modifier >> 31 ? -1 : eqn;\r\nreturn err;\r\n}\r\nstatic int mlx4_MAP_EQ(struct mlx4_dev *dev, u64 event_mask, int unmap,\r\nint eq_num)\r\n{\r\nreturn mlx4_cmd(dev, event_mask, (unmap << 31) | eq_num,\r\n0, MLX4_CMD_MAP_EQ, MLX4_CMD_TIME_CLASS_B,\r\nMLX4_CMD_WRAPPED);\r\n}\r\nstatic int mlx4_SW2HW_EQ(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox,\r\nint eq_num)\r\n{\r\nreturn mlx4_cmd(dev, mailbox->dma, eq_num, 0,\r\nMLX4_CMD_SW2HW_EQ, MLX4_CMD_TIME_CLASS_A,\r\nMLX4_CMD_WRAPPED);\r\n}\r\nstatic int mlx4_HW2SW_EQ(struct mlx4_dev *dev, int eq_num)\r\n{\r\nreturn mlx4_cmd(dev, 0, eq_num, 1, MLX4_CMD_HW2SW_EQ,\r\nMLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\r\n}\r\nstatic int mlx4_num_eq_uar(struct mlx4_dev *dev)\r\n{\r\nreturn (dev->caps.num_comp_vectors + 1 + dev->caps.reserved_eqs) / 4 -\r\ndev->caps.reserved_eqs / 4 + 1;\r\n}\r\nstatic void __iomem *mlx4_get_eq_uar(struct mlx4_dev *dev, struct mlx4_eq *eq)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint index;\r\nindex = eq->eqn / 4 - dev->caps.reserved_eqs / 4;\r\nif (!priv->eq_table.uar_map[index]) {\r\npriv->eq_table.uar_map[index] =\r\nioremap(pci_resource_start(dev->persist->pdev, 2) +\r\n((eq->eqn / 4) << PAGE_SHIFT),\r\nPAGE_SIZE);\r\nif (!priv->eq_table.uar_map[index]) {\r\nmlx4_err(dev, "Couldn't map EQ doorbell for EQN 0x%06x\n",\r\neq->eqn);\r\nreturn NULL;\r\n}\r\n}\r\nreturn priv->eq_table.uar_map[index] + 0x800 + 8 * (eq->eqn % 4);\r\n}\r\nstatic void mlx4_unmap_uar(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint i;\r\nfor (i = 0; i < mlx4_num_eq_uar(dev); ++i)\r\nif (priv->eq_table.uar_map[i]) {\r\niounmap(priv->eq_table.uar_map[i]);\r\npriv->eq_table.uar_map[i] = NULL;\r\n}\r\n}\r\nstatic int mlx4_create_eq(struct mlx4_dev *dev, int nent,\r\nu8 intr, struct mlx4_eq *eq)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_cmd_mailbox *mailbox;\r\nstruct mlx4_eq_context *eq_context;\r\nint npages;\r\nu64 *dma_list = NULL;\r\ndma_addr_t t;\r\nu64 mtt_addr;\r\nint err = -ENOMEM;\r\nint i;\r\neq->dev = dev;\r\neq->nent = roundup_pow_of_two(max(nent, 2));\r\nnpages = PAGE_ALIGN(eq->nent * dev->caps.eqe_size) / PAGE_SIZE;\r\neq->page_list = kmalloc(npages * sizeof *eq->page_list,\r\nGFP_KERNEL);\r\nif (!eq->page_list)\r\ngoto err_out;\r\nfor (i = 0; i < npages; ++i)\r\neq->page_list[i].buf = NULL;\r\ndma_list = kmalloc(npages * sizeof *dma_list, GFP_KERNEL);\r\nif (!dma_list)\r\ngoto err_out_free;\r\nmailbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(mailbox))\r\ngoto err_out_free;\r\neq_context = mailbox->buf;\r\nfor (i = 0; i < npages; ++i) {\r\neq->page_list[i].buf = dma_alloc_coherent(&dev->persist->\r\npdev->dev,\r\nPAGE_SIZE, &t,\r\nGFP_KERNEL);\r\nif (!eq->page_list[i].buf)\r\ngoto err_out_free_pages;\r\ndma_list[i] = t;\r\neq->page_list[i].map = t;\r\nmemset(eq->page_list[i].buf, 0, PAGE_SIZE);\r\n}\r\neq->eqn = mlx4_bitmap_alloc(&priv->eq_table.bitmap);\r\nif (eq->eqn == -1)\r\ngoto err_out_free_pages;\r\neq->doorbell = mlx4_get_eq_uar(dev, eq);\r\nif (!eq->doorbell) {\r\nerr = -ENOMEM;\r\ngoto err_out_free_eq;\r\n}\r\nerr = mlx4_mtt_init(dev, npages, PAGE_SHIFT, &eq->mtt);\r\nif (err)\r\ngoto err_out_free_eq;\r\nerr = mlx4_write_mtt(dev, &eq->mtt, 0, npages, dma_list);\r\nif (err)\r\ngoto err_out_free_mtt;\r\neq_context->flags = cpu_to_be32(MLX4_EQ_STATUS_OK |\r\nMLX4_EQ_STATE_ARMED);\r\neq_context->log_eq_size = ilog2(eq->nent);\r\neq_context->intr = intr;\r\neq_context->log_page_size = PAGE_SHIFT - MLX4_ICM_PAGE_SHIFT;\r\nmtt_addr = mlx4_mtt_addr(dev, &eq->mtt);\r\neq_context->mtt_base_addr_h = mtt_addr >> 32;\r\neq_context->mtt_base_addr_l = cpu_to_be32(mtt_addr & 0xffffffff);\r\nerr = mlx4_SW2HW_EQ(dev, mailbox, eq->eqn);\r\nif (err) {\r\nmlx4_warn(dev, "SW2HW_EQ failed (%d)\n", err);\r\ngoto err_out_free_mtt;\r\n}\r\nkfree(dma_list);\r\nmlx4_free_cmd_mailbox(dev, mailbox);\r\neq->cons_index = 0;\r\nINIT_LIST_HEAD(&eq->tasklet_ctx.list);\r\nINIT_LIST_HEAD(&eq->tasklet_ctx.process_list);\r\nspin_lock_init(&eq->tasklet_ctx.lock);\r\ntasklet_init(&eq->tasklet_ctx.task, mlx4_cq_tasklet_cb,\r\n(unsigned long)&eq->tasklet_ctx);\r\nreturn err;\r\nerr_out_free_mtt:\r\nmlx4_mtt_cleanup(dev, &eq->mtt);\r\nerr_out_free_eq:\r\nmlx4_bitmap_free(&priv->eq_table.bitmap, eq->eqn, MLX4_USE_RR);\r\nerr_out_free_pages:\r\nfor (i = 0; i < npages; ++i)\r\nif (eq->page_list[i].buf)\r\ndma_free_coherent(&dev->persist->pdev->dev, PAGE_SIZE,\r\neq->page_list[i].buf,\r\neq->page_list[i].map);\r\nmlx4_free_cmd_mailbox(dev, mailbox);\r\nerr_out_free:\r\nkfree(eq->page_list);\r\nkfree(dma_list);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic void mlx4_free_eq(struct mlx4_dev *dev,\r\nstruct mlx4_eq *eq)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint err;\r\nint i;\r\nint npages = PAGE_ALIGN(dev->caps.eqe_size * eq->nent) / PAGE_SIZE;\r\nerr = mlx4_HW2SW_EQ(dev, eq->eqn);\r\nif (err)\r\nmlx4_warn(dev, "HW2SW_EQ failed (%d)\n", err);\r\nsynchronize_irq(eq->irq);\r\ntasklet_disable(&eq->tasklet_ctx.task);\r\nmlx4_mtt_cleanup(dev, &eq->mtt);\r\nfor (i = 0; i < npages; ++i)\r\ndma_free_coherent(&dev->persist->pdev->dev, PAGE_SIZE,\r\neq->page_list[i].buf,\r\neq->page_list[i].map);\r\nkfree(eq->page_list);\r\nmlx4_bitmap_free(&priv->eq_table.bitmap, eq->eqn, MLX4_USE_RR);\r\n}\r\nstatic void mlx4_free_irqs(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_eq_table *eq_table = &mlx4_priv(dev)->eq_table;\r\nint i;\r\nif (eq_table->have_irq)\r\nfree_irq(dev->persist->pdev->irq, dev);\r\nfor (i = 0; i < dev->caps.num_comp_vectors + 1; ++i)\r\nif (eq_table->eq[i].have_irq) {\r\nfree_cpumask_var(eq_table->eq[i].affinity_mask);\r\n#if defined(CONFIG_SMP)\r\nirq_set_affinity_hint(eq_table->eq[i].irq, NULL);\r\n#endif\r\nfree_irq(eq_table->eq[i].irq, eq_table->eq + i);\r\neq_table->eq[i].have_irq = 0;\r\n}\r\nkfree(eq_table->irq_names);\r\n}\r\nstatic int mlx4_map_clr_int(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\npriv->clr_base = ioremap(pci_resource_start(dev->persist->pdev,\r\npriv->fw.clr_int_bar) +\r\npriv->fw.clr_int_base, MLX4_CLR_INT_SIZE);\r\nif (!priv->clr_base) {\r\nmlx4_err(dev, "Couldn't map interrupt clear register, aborting\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mlx4_unmap_clr_int(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\niounmap(priv->clr_base);\r\n}\r\nint mlx4_alloc_eq_table(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\npriv->eq_table.eq = kcalloc(dev->caps.num_eqs - dev->caps.reserved_eqs,\r\nsizeof *priv->eq_table.eq, GFP_KERNEL);\r\nif (!priv->eq_table.eq)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid mlx4_free_eq_table(struct mlx4_dev *dev)\r\n{\r\nkfree(mlx4_priv(dev)->eq_table.eq);\r\n}\r\nint mlx4_init_eq_table(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint err;\r\nint i;\r\npriv->eq_table.uar_map = kcalloc(mlx4_num_eq_uar(dev),\r\nsizeof *priv->eq_table.uar_map,\r\nGFP_KERNEL);\r\nif (!priv->eq_table.uar_map) {\r\nerr = -ENOMEM;\r\ngoto err_out_free;\r\n}\r\nerr = mlx4_bitmap_init(&priv->eq_table.bitmap,\r\nroundup_pow_of_two(dev->caps.num_eqs),\r\ndev->caps.num_eqs - 1,\r\ndev->caps.reserved_eqs,\r\nroundup_pow_of_two(dev->caps.num_eqs) -\r\ndev->caps.num_eqs);\r\nif (err)\r\ngoto err_out_free;\r\nfor (i = 0; i < mlx4_num_eq_uar(dev); ++i)\r\npriv->eq_table.uar_map[i] = NULL;\r\nif (!mlx4_is_slave(dev)) {\r\nerr = mlx4_map_clr_int(dev);\r\nif (err)\r\ngoto err_out_bitmap;\r\npriv->eq_table.clr_mask =\r\nswab32(1 << (priv->eq_table.inta_pin & 31));\r\npriv->eq_table.clr_int = priv->clr_base +\r\n(priv->eq_table.inta_pin < 32 ? 4 : 0);\r\n}\r\npriv->eq_table.irq_names =\r\nkmalloc(MLX4_IRQNAME_SIZE * (dev->caps.num_comp_vectors + 1),\r\nGFP_KERNEL);\r\nif (!priv->eq_table.irq_names) {\r\nerr = -ENOMEM;\r\ngoto err_out_clr_int;\r\n}\r\nfor (i = 0; i < dev->caps.num_comp_vectors + 1; ++i) {\r\nif (i == MLX4_EQ_ASYNC) {\r\nerr = mlx4_create_eq(dev,\r\nMLX4_NUM_ASYNC_EQE + MLX4_NUM_SPARE_EQE,\r\n0, &priv->eq_table.eq[MLX4_EQ_ASYNC]);\r\n} else {\r\nstruct mlx4_eq *eq = &priv->eq_table.eq[i];\r\n#ifdef CONFIG_RFS_ACCEL\r\nint port = find_first_bit(eq->actv_ports.ports,\r\ndev->caps.num_ports) + 1;\r\nif (port <= dev->caps.num_ports) {\r\nstruct mlx4_port_info *info =\r\n&mlx4_priv(dev)->port[port];\r\nif (!info->rmap) {\r\ninfo->rmap = alloc_irq_cpu_rmap(\r\nmlx4_get_eqs_per_port(dev, port));\r\nif (!info->rmap) {\r\nmlx4_warn(dev, "Failed to allocate cpu rmap\n");\r\nerr = -ENOMEM;\r\ngoto err_out_unmap;\r\n}\r\n}\r\nerr = irq_cpu_rmap_add(\r\ninfo->rmap, eq->irq);\r\nif (err)\r\nmlx4_warn(dev, "Failed adding irq rmap\n");\r\n}\r\n#endif\r\nerr = mlx4_create_eq(dev, dev->caps.num_cqs -\r\ndev->caps.reserved_cqs +\r\nMLX4_NUM_SPARE_EQE,\r\n(dev->flags & MLX4_FLAG_MSI_X) ?\r\ni + 1 - !!(i > MLX4_EQ_ASYNC) : 0,\r\neq);\r\n}\r\nif (err)\r\ngoto err_out_unmap;\r\n}\r\nif (dev->flags & MLX4_FLAG_MSI_X) {\r\nconst char *eq_name;\r\nsnprintf(priv->eq_table.irq_names +\r\nMLX4_EQ_ASYNC * MLX4_IRQNAME_SIZE,\r\nMLX4_IRQNAME_SIZE,\r\n"mlx4-async@pci:%s",\r\npci_name(dev->persist->pdev));\r\neq_name = priv->eq_table.irq_names +\r\nMLX4_EQ_ASYNC * MLX4_IRQNAME_SIZE;\r\nerr = request_irq(priv->eq_table.eq[MLX4_EQ_ASYNC].irq,\r\nmlx4_msi_x_interrupt, 0, eq_name,\r\npriv->eq_table.eq + MLX4_EQ_ASYNC);\r\nif (err)\r\ngoto err_out_unmap;\r\npriv->eq_table.eq[MLX4_EQ_ASYNC].have_irq = 1;\r\n} else {\r\nsnprintf(priv->eq_table.irq_names,\r\nMLX4_IRQNAME_SIZE,\r\nDRV_NAME "@pci:%s",\r\npci_name(dev->persist->pdev));\r\nerr = request_irq(dev->persist->pdev->irq, mlx4_interrupt,\r\nIRQF_SHARED, priv->eq_table.irq_names, dev);\r\nif (err)\r\ngoto err_out_unmap;\r\npriv->eq_table.have_irq = 1;\r\n}\r\nerr = mlx4_MAP_EQ(dev, get_async_ev_mask(dev), 0,\r\npriv->eq_table.eq[MLX4_EQ_ASYNC].eqn);\r\nif (err)\r\nmlx4_warn(dev, "MAP_EQ for async EQ %d failed (%d)\n",\r\npriv->eq_table.eq[MLX4_EQ_ASYNC].eqn, err);\r\neq_set_ci(&priv->eq_table.eq[MLX4_EQ_ASYNC], 1);\r\nreturn 0;\r\nerr_out_unmap:\r\nwhile (i >= 0)\r\nmlx4_free_eq(dev, &priv->eq_table.eq[i--]);\r\n#ifdef CONFIG_RFS_ACCEL\r\nfor (i = 1; i <= dev->caps.num_ports; i++) {\r\nif (mlx4_priv(dev)->port[i].rmap) {\r\nfree_irq_cpu_rmap(mlx4_priv(dev)->port[i].rmap);\r\nmlx4_priv(dev)->port[i].rmap = NULL;\r\n}\r\n}\r\n#endif\r\nmlx4_free_irqs(dev);\r\nerr_out_clr_int:\r\nif (!mlx4_is_slave(dev))\r\nmlx4_unmap_clr_int(dev);\r\nerr_out_bitmap:\r\nmlx4_unmap_uar(dev);\r\nmlx4_bitmap_cleanup(&priv->eq_table.bitmap);\r\nerr_out_free:\r\nkfree(priv->eq_table.uar_map);\r\nreturn err;\r\n}\r\nvoid mlx4_cleanup_eq_table(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint i;\r\nmlx4_MAP_EQ(dev, get_async_ev_mask(dev), 1,\r\npriv->eq_table.eq[MLX4_EQ_ASYNC].eqn);\r\n#ifdef CONFIG_RFS_ACCEL\r\nfor (i = 1; i <= dev->caps.num_ports; i++) {\r\nif (mlx4_priv(dev)->port[i].rmap) {\r\nfree_irq_cpu_rmap(mlx4_priv(dev)->port[i].rmap);\r\nmlx4_priv(dev)->port[i].rmap = NULL;\r\n}\r\n}\r\n#endif\r\nmlx4_free_irqs(dev);\r\nfor (i = 0; i < dev->caps.num_comp_vectors + 1; ++i)\r\nmlx4_free_eq(dev, &priv->eq_table.eq[i]);\r\nif (!mlx4_is_slave(dev))\r\nmlx4_unmap_clr_int(dev);\r\nmlx4_unmap_uar(dev);\r\nmlx4_bitmap_cleanup(&priv->eq_table.bitmap);\r\nkfree(priv->eq_table.uar_map);\r\n}\r\nint mlx4_test_interrupts(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint i;\r\nint err;\r\nerr = mlx4_NOP(dev);\r\nif (!(dev->flags & MLX4_FLAG_MSI_X) || mlx4_is_slave(dev))\r\nreturn err;\r\nfor(i = 0; !err && (i < dev->caps.num_comp_vectors); ++i) {\r\nif (!priv->eq_table.eq[i].have_irq)\r\ncontinue;\r\nmlx4_cmd_use_polling(dev);\r\nerr = mlx4_MAP_EQ(dev, get_async_ev_mask(dev), 0,\r\npriv->eq_table.eq[i].eqn);\r\nif (err) {\r\nmlx4_warn(dev, "Failed mapping eq for interrupt test\n");\r\nmlx4_cmd_use_events(dev);\r\nbreak;\r\n}\r\nmlx4_cmd_use_events(dev);\r\nerr = mlx4_NOP(dev);\r\n}\r\nmlx4_MAP_EQ(dev, get_async_ev_mask(dev), 0,\r\npriv->eq_table.eq[MLX4_EQ_ASYNC].eqn);\r\nreturn err;\r\n}\r\nbool mlx4_is_eq_vector_valid(struct mlx4_dev *dev, u8 port, int vector)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nvector = MLX4_CQ_TO_EQ_VECTOR(vector);\r\nif (vector < 0 || (vector >= dev->caps.num_comp_vectors + 1) ||\r\n(vector == MLX4_EQ_ASYNC))\r\nreturn false;\r\nreturn test_bit(port - 1, priv->eq_table.eq[vector].actv_ports.ports);\r\n}\r\nu32 mlx4_get_eqs_per_port(struct mlx4_dev *dev, u8 port)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nunsigned int i;\r\nunsigned int sum = 0;\r\nfor (i = 0; i < dev->caps.num_comp_vectors + 1; i++)\r\nsum += !!test_bit(port - 1,\r\npriv->eq_table.eq[i].actv_ports.ports);\r\nreturn sum;\r\n}\r\nint mlx4_is_eq_shared(struct mlx4_dev *dev, int vector)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nvector = MLX4_CQ_TO_EQ_VECTOR(vector);\r\nif (vector <= 0 || (vector >= dev->caps.num_comp_vectors + 1))\r\nreturn -EINVAL;\r\nreturn !!(bitmap_weight(priv->eq_table.eq[vector].actv_ports.ports,\r\ndev->caps.num_ports) > 1);\r\n}\r\nstruct cpu_rmap *mlx4_get_cpu_rmap(struct mlx4_dev *dev, int port)\r\n{\r\nreturn mlx4_priv(dev)->port[port].rmap;\r\n}\r\nint mlx4_assign_eq(struct mlx4_dev *dev, u8 port, int *vector)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint err = 0, i = 0;\r\nu32 min_ref_count_val = (u32)-1;\r\nint requested_vector = MLX4_CQ_TO_EQ_VECTOR(*vector);\r\nint *prequested_vector = NULL;\r\nmutex_lock(&priv->msix_ctl.pool_lock);\r\nif (requested_vector < (dev->caps.num_comp_vectors + 1) &&\r\n(requested_vector >= 0) &&\r\n(requested_vector != MLX4_EQ_ASYNC)) {\r\nif (test_bit(port - 1,\r\npriv->eq_table.eq[requested_vector].actv_ports.ports)) {\r\nprequested_vector = &requested_vector;\r\n} else {\r\nstruct mlx4_eq *eq;\r\nfor (i = 1; i < port;\r\nrequested_vector += mlx4_get_eqs_per_port(dev, i++))\r\n;\r\neq = &priv->eq_table.eq[requested_vector];\r\nif (requested_vector < dev->caps.num_comp_vectors + 1 &&\r\ntest_bit(port - 1, eq->actv_ports.ports)) {\r\nprequested_vector = &requested_vector;\r\n}\r\n}\r\n}\r\nif (!prequested_vector) {\r\nrequested_vector = -1;\r\nfor (i = 0; min_ref_count_val && i < dev->caps.num_comp_vectors + 1;\r\ni++) {\r\nstruct mlx4_eq *eq = &priv->eq_table.eq[i];\r\nif (min_ref_count_val > eq->ref_count &&\r\ntest_bit(port - 1, eq->actv_ports.ports)) {\r\nmin_ref_count_val = eq->ref_count;\r\nrequested_vector = i;\r\n}\r\n}\r\nif (requested_vector < 0) {\r\nerr = -ENOSPC;\r\ngoto err_unlock;\r\n}\r\nprequested_vector = &requested_vector;\r\n}\r\nif (!test_bit(*prequested_vector, priv->msix_ctl.pool_bm) &&\r\ndev->flags & MLX4_FLAG_MSI_X) {\r\nset_bit(*prequested_vector, priv->msix_ctl.pool_bm);\r\nsnprintf(priv->eq_table.irq_names +\r\n*prequested_vector * MLX4_IRQNAME_SIZE,\r\nMLX4_IRQNAME_SIZE, "mlx4-%d@%s",\r\n*prequested_vector, dev_name(&dev->persist->pdev->dev));\r\nerr = request_irq(priv->eq_table.eq[*prequested_vector].irq,\r\nmlx4_msi_x_interrupt, 0,\r\n&priv->eq_table.irq_names[*prequested_vector << 5],\r\npriv->eq_table.eq + *prequested_vector);\r\nif (err) {\r\nclear_bit(*prequested_vector, priv->msix_ctl.pool_bm);\r\n*prequested_vector = -1;\r\n} else {\r\n#if defined(CONFIG_SMP)\r\nmlx4_set_eq_affinity_hint(priv, *prequested_vector);\r\n#endif\r\neq_set_ci(&priv->eq_table.eq[*prequested_vector], 1);\r\npriv->eq_table.eq[*prequested_vector].have_irq = 1;\r\n}\r\n}\r\nif (!err && *prequested_vector >= 0)\r\npriv->eq_table.eq[*prequested_vector].ref_count++;\r\nerr_unlock:\r\nmutex_unlock(&priv->msix_ctl.pool_lock);\r\nif (!err && *prequested_vector >= 0)\r\n*vector = MLX4_EQ_TO_CQ_VECTOR(*prequested_vector);\r\nelse\r\n*vector = 0;\r\nreturn err;\r\n}\r\nint mlx4_eq_get_irq(struct mlx4_dev *dev, int cq_vec)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nreturn priv->eq_table.eq[MLX4_CQ_TO_EQ_VECTOR(cq_vec)].irq;\r\n}\r\nvoid mlx4_release_eq(struct mlx4_dev *dev, int vec)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint eq_vec = MLX4_CQ_TO_EQ_VECTOR(vec);\r\nmutex_lock(&priv->msix_ctl.pool_lock);\r\npriv->eq_table.eq[eq_vec].ref_count--;\r\nmutex_unlock(&priv->msix_ctl.pool_lock);\r\n}
