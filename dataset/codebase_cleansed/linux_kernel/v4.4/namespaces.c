static const char *proc_ns_follow_link(struct dentry *dentry, void **cookie)\r\n{\r\nstruct inode *inode = d_inode(dentry);\r\nconst struct proc_ns_operations *ns_ops = PROC_I(inode)->ns_ops;\r\nstruct task_struct *task;\r\nstruct path ns_path;\r\nvoid *error = ERR_PTR(-EACCES);\r\ntask = get_proc_task(inode);\r\nif (!task)\r\nreturn error;\r\nif (ptrace_may_access(task, PTRACE_MODE_READ)) {\r\nerror = ns_get_path(&ns_path, task, ns_ops);\r\nif (!error)\r\nnd_jump_link(&ns_path);\r\n}\r\nput_task_struct(task);\r\nreturn error;\r\n}\r\nstatic int proc_ns_readlink(struct dentry *dentry, char __user *buffer, int buflen)\r\n{\r\nstruct inode *inode = d_inode(dentry);\r\nconst struct proc_ns_operations *ns_ops = PROC_I(inode)->ns_ops;\r\nstruct task_struct *task;\r\nchar name[50];\r\nint res = -EACCES;\r\ntask = get_proc_task(inode);\r\nif (!task)\r\nreturn res;\r\nif (ptrace_may_access(task, PTRACE_MODE_READ)) {\r\nres = ns_get_name(name, sizeof(name), task, ns_ops);\r\nif (res >= 0)\r\nres = readlink_copy(buffer, buflen, name);\r\n}\r\nput_task_struct(task);\r\nreturn res;\r\n}\r\nstatic int proc_ns_instantiate(struct inode *dir,\r\nstruct dentry *dentry, struct task_struct *task, const void *ptr)\r\n{\r\nconst struct proc_ns_operations *ns_ops = ptr;\r\nstruct inode *inode;\r\nstruct proc_inode *ei;\r\ninode = proc_pid_make_inode(dir->i_sb, task);\r\nif (!inode)\r\ngoto out;\r\nei = PROC_I(inode);\r\ninode->i_mode = S_IFLNK|S_IRWXUGO;\r\ninode->i_op = &proc_ns_link_inode_operations;\r\nei->ns_ops = ns_ops;\r\nd_set_d_op(dentry, &pid_dentry_operations);\r\nd_add(dentry, inode);\r\nif (pid_revalidate(dentry, 0))\r\nreturn 0;\r\nout:\r\nreturn -ENOENT;\r\n}\r\nstatic int proc_ns_dir_readdir(struct file *file, struct dir_context *ctx)\r\n{\r\nstruct task_struct *task = get_proc_task(file_inode(file));\r\nconst struct proc_ns_operations **entry, **last;\r\nif (!task)\r\nreturn -ENOENT;\r\nif (!dir_emit_dots(file, ctx))\r\ngoto out;\r\nif (ctx->pos >= 2 + ARRAY_SIZE(ns_entries))\r\ngoto out;\r\nentry = ns_entries + (ctx->pos - 2);\r\nlast = &ns_entries[ARRAY_SIZE(ns_entries) - 1];\r\nwhile (entry <= last) {\r\nconst struct proc_ns_operations *ops = *entry;\r\nif (!proc_fill_cache(file, ctx, ops->name, strlen(ops->name),\r\nproc_ns_instantiate, task, ops))\r\nbreak;\r\nctx->pos++;\r\nentry++;\r\n}\r\nout:\r\nput_task_struct(task);\r\nreturn 0;\r\n}\r\nstatic struct dentry *proc_ns_dir_lookup(struct inode *dir,\r\nstruct dentry *dentry, unsigned int flags)\r\n{\r\nint error;\r\nstruct task_struct *task = get_proc_task(dir);\r\nconst struct proc_ns_operations **entry, **last;\r\nunsigned int len = dentry->d_name.len;\r\nerror = -ENOENT;\r\nif (!task)\r\ngoto out_no_task;\r\nlast = &ns_entries[ARRAY_SIZE(ns_entries)];\r\nfor (entry = ns_entries; entry < last; entry++) {\r\nif (strlen((*entry)->name) != len)\r\ncontinue;\r\nif (!memcmp(dentry->d_name.name, (*entry)->name, len))\r\nbreak;\r\n}\r\nif (entry == last)\r\ngoto out;\r\nerror = proc_ns_instantiate(dir, dentry, task, *entry);\r\nout:\r\nput_task_struct(task);\r\nout_no_task:\r\nreturn ERR_PTR(error);\r\n}
