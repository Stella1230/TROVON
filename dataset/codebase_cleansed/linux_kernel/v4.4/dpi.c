static struct dpi_data *dpi_get_data_from_dssdev(struct omap_dss_device *dssdev)\r\n{\r\nreturn container_of(dssdev, struct dpi_data, output);\r\n}\r\nstatic struct dpi_data *dpi_get_data_from_pdev(struct platform_device *pdev)\r\n{\r\nreturn dev_get_drvdata(&pdev->dev);\r\n}\r\nstatic struct dss_pll *dpi_get_pll(enum omap_channel channel)\r\n{\r\nswitch (omapdss_get_version()) {\r\ncase OMAPDSS_VER_OMAP24xx:\r\ncase OMAPDSS_VER_OMAP34xx_ES1:\r\ncase OMAPDSS_VER_OMAP34xx_ES3:\r\ncase OMAPDSS_VER_OMAP3630:\r\ncase OMAPDSS_VER_AM35xx:\r\ncase OMAPDSS_VER_AM43xx:\r\nreturn NULL;\r\ncase OMAPDSS_VER_OMAP4430_ES1:\r\ncase OMAPDSS_VER_OMAP4430_ES2:\r\ncase OMAPDSS_VER_OMAP4:\r\nswitch (channel) {\r\ncase OMAP_DSS_CHANNEL_LCD:\r\nreturn dss_pll_find("dsi0");\r\ncase OMAP_DSS_CHANNEL_LCD2:\r\nreturn dss_pll_find("dsi1");\r\ndefault:\r\nreturn NULL;\r\n}\r\ncase OMAPDSS_VER_OMAP5:\r\nswitch (channel) {\r\ncase OMAP_DSS_CHANNEL_LCD:\r\nreturn dss_pll_find("dsi0");\r\ncase OMAP_DSS_CHANNEL_LCD3:\r\nreturn dss_pll_find("dsi1");\r\ndefault:\r\nreturn NULL;\r\n}\r\ncase OMAPDSS_VER_DRA7xx:\r\nswitch (channel) {\r\ncase OMAP_DSS_CHANNEL_LCD:\r\ncase OMAP_DSS_CHANNEL_LCD2:\r\nreturn dss_pll_find("video0");\r\ncase OMAP_DSS_CHANNEL_LCD3:\r\nreturn dss_pll_find("video1");\r\ndefault:\r\nreturn NULL;\r\n}\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic enum omap_dss_clk_source dpi_get_alt_clk_src(enum omap_channel channel)\r\n{\r\nswitch (channel) {\r\ncase OMAP_DSS_CHANNEL_LCD:\r\nreturn OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC;\r\ncase OMAP_DSS_CHANNEL_LCD2:\r\nreturn OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC;\r\ncase OMAP_DSS_CHANNEL_LCD3:\r\nreturn OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC;\r\ndefault:\r\nWARN_ON(1);\r\nreturn OMAP_DSS_CLK_SRC_FCK;\r\n}\r\n}\r\nstatic bool dpi_calc_dispc_cb(int lckd, int pckd, unsigned long lck,\r\nunsigned long pck, void *data)\r\n{\r\nstruct dpi_clk_calc_ctx *ctx = data;\r\nif (ctx->pck_min >= 100000000) {\r\nif (lckd > 1 && lckd % 2 != 0)\r\nreturn false;\r\nif (pckd > 1 && pckd % 2 != 0)\r\nreturn false;\r\n}\r\nctx->dispc_cinfo.lck_div = lckd;\r\nctx->dispc_cinfo.pck_div = pckd;\r\nctx->dispc_cinfo.lck = lck;\r\nctx->dispc_cinfo.pck = pck;\r\nreturn true;\r\n}\r\nstatic bool dpi_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\r\nvoid *data)\r\n{\r\nstruct dpi_clk_calc_ctx *ctx = data;\r\nif (m_dispc > 1 && m_dispc % 2 != 0 && ctx->pck_min >= 100000000)\r\nreturn false;\r\nctx->dsi_cinfo.mX[HSDIV_DISPC] = m_dispc;\r\nctx->dsi_cinfo.clkout[HSDIV_DISPC] = dispc;\r\nreturn dispc_div_calc(dispc, ctx->pck_min, ctx->pck_max,\r\ndpi_calc_dispc_cb, ctx);\r\n}\r\nstatic bool dpi_calc_pll_cb(int n, int m, unsigned long fint,\r\nunsigned long clkdco,\r\nvoid *data)\r\n{\r\nstruct dpi_clk_calc_ctx *ctx = data;\r\nctx->dsi_cinfo.n = n;\r\nctx->dsi_cinfo.m = m;\r\nctx->dsi_cinfo.fint = fint;\r\nctx->dsi_cinfo.clkdco = clkdco;\r\nreturn dss_pll_hsdiv_calc(ctx->pll, clkdco,\r\nctx->pck_min, dss_feat_get_param_max(FEAT_PARAM_DSS_FCK),\r\ndpi_calc_hsdiv_cb, ctx);\r\n}\r\nstatic bool dpi_calc_dss_cb(unsigned long fck, void *data)\r\n{\r\nstruct dpi_clk_calc_ctx *ctx = data;\r\nctx->fck = fck;\r\nreturn dispc_div_calc(fck, ctx->pck_min, ctx->pck_max,\r\ndpi_calc_dispc_cb, ctx);\r\n}\r\nstatic bool dpi_dsi_clk_calc(struct dpi_data *dpi, unsigned long pck,\r\nstruct dpi_clk_calc_ctx *ctx)\r\n{\r\nunsigned long clkin;\r\nunsigned long pll_min, pll_max;\r\nmemset(ctx, 0, sizeof(*ctx));\r\nctx->pll = dpi->pll;\r\nctx->pck_min = pck - 1000;\r\nctx->pck_max = pck + 1000;\r\npll_min = 0;\r\npll_max = 0;\r\nclkin = clk_get_rate(ctx->pll->clkin);\r\nreturn dss_pll_calc(ctx->pll, clkin,\r\npll_min, pll_max,\r\ndpi_calc_pll_cb, ctx);\r\n}\r\nstatic bool dpi_dss_clk_calc(unsigned long pck, struct dpi_clk_calc_ctx *ctx)\r\n{\r\nint i;\r\nfor (i = 0; i < 25; ++i) {\r\nbool ok;\r\nmemset(ctx, 0, sizeof(*ctx));\r\nif (pck > 1000 * i * i * i)\r\nctx->pck_min = max(pck - 1000 * i * i * i, 0lu);\r\nelse\r\nctx->pck_min = 0;\r\nctx->pck_max = pck + 1000 * i * i * i;\r\nok = dss_div_calc(pck, ctx->pck_min, dpi_calc_dss_cb, ctx);\r\nif (ok)\r\nreturn ok;\r\n}\r\nreturn false;\r\n}\r\nstatic int dpi_set_dsi_clk(struct dpi_data *dpi, enum omap_channel channel,\r\nunsigned long pck_req, unsigned long *fck, int *lck_div,\r\nint *pck_div)\r\n{\r\nstruct dpi_clk_calc_ctx ctx;\r\nint r;\r\nbool ok;\r\nok = dpi_dsi_clk_calc(dpi, pck_req, &ctx);\r\nif (!ok)\r\nreturn -EINVAL;\r\nr = dss_pll_set_config(dpi->pll, &ctx.dsi_cinfo);\r\nif (r)\r\nreturn r;\r\ndss_select_lcd_clk_source(channel,\r\ndpi_get_alt_clk_src(channel));\r\ndpi->mgr_config.clock_info = ctx.dispc_cinfo;\r\n*fck = ctx.dsi_cinfo.clkout[HSDIV_DISPC];\r\n*lck_div = ctx.dispc_cinfo.lck_div;\r\n*pck_div = ctx.dispc_cinfo.pck_div;\r\nreturn 0;\r\n}\r\nstatic int dpi_set_dispc_clk(struct dpi_data *dpi, unsigned long pck_req,\r\nunsigned long *fck, int *lck_div, int *pck_div)\r\n{\r\nstruct dpi_clk_calc_ctx ctx;\r\nint r;\r\nbool ok;\r\nok = dpi_dss_clk_calc(pck_req, &ctx);\r\nif (!ok)\r\nreturn -EINVAL;\r\nr = dss_set_fck_rate(ctx.fck);\r\nif (r)\r\nreturn r;\r\ndpi->mgr_config.clock_info = ctx.dispc_cinfo;\r\n*fck = ctx.fck;\r\n*lck_div = ctx.dispc_cinfo.lck_div;\r\n*pck_div = ctx.dispc_cinfo.pck_div;\r\nreturn 0;\r\n}\r\nstatic int dpi_set_mode(struct dpi_data *dpi)\r\n{\r\nstruct omap_dss_device *out = &dpi->output;\r\nstruct omap_overlay_manager *mgr = out->manager;\r\nstruct omap_video_timings *t = &dpi->timings;\r\nint lck_div = 0, pck_div = 0;\r\nunsigned long fck = 0;\r\nunsigned long pck;\r\nint r = 0;\r\nif (dpi->pll)\r\nr = dpi_set_dsi_clk(dpi, mgr->id, t->pixelclock, &fck,\r\n&lck_div, &pck_div);\r\nelse\r\nr = dpi_set_dispc_clk(dpi, t->pixelclock, &fck,\r\n&lck_div, &pck_div);\r\nif (r)\r\nreturn r;\r\npck = fck / lck_div / pck_div;\r\nif (pck != t->pixelclock) {\r\nDSSWARN("Could not find exact pixel clock. Requested %d Hz, got %lu Hz\n",\r\nt->pixelclock, pck);\r\nt->pixelclock = pck;\r\n}\r\ndss_mgr_set_timings(mgr, t);\r\nreturn 0;\r\n}\r\nstatic void dpi_config_lcd_manager(struct dpi_data *dpi)\r\n{\r\nstruct omap_dss_device *out = &dpi->output;\r\nstruct omap_overlay_manager *mgr = out->manager;\r\ndpi->mgr_config.io_pad_mode = DSS_IO_PAD_MODE_BYPASS;\r\ndpi->mgr_config.stallmode = false;\r\ndpi->mgr_config.fifohandcheck = false;\r\ndpi->mgr_config.video_port_width = dpi->data_lines;\r\ndpi->mgr_config.lcden_sig_polarity = 0;\r\ndss_mgr_set_lcd_config(mgr, &dpi->mgr_config);\r\n}\r\nstatic int dpi_display_enable(struct omap_dss_device *dssdev)\r\n{\r\nstruct dpi_data *dpi = dpi_get_data_from_dssdev(dssdev);\r\nstruct omap_dss_device *out = &dpi->output;\r\nint r;\r\nmutex_lock(&dpi->lock);\r\nif (dss_has_feature(FEAT_DPI_USES_VDDS_DSI) && !dpi->vdds_dsi_reg) {\r\nDSSERR("no VDSS_DSI regulator\n");\r\nr = -ENODEV;\r\ngoto err_no_reg;\r\n}\r\nif (out == NULL || out->manager == NULL) {\r\nDSSERR("failed to enable display: no output/manager\n");\r\nr = -ENODEV;\r\ngoto err_no_out_mgr;\r\n}\r\nif (dss_has_feature(FEAT_DPI_USES_VDDS_DSI)) {\r\nr = regulator_enable(dpi->vdds_dsi_reg);\r\nif (r)\r\ngoto err_reg_enable;\r\n}\r\nr = dispc_runtime_get();\r\nif (r)\r\ngoto err_get_dispc;\r\nr = dss_dpi_select_source(out->port_num, out->manager->id);\r\nif (r)\r\ngoto err_src_sel;\r\nif (dpi->pll) {\r\nr = dss_pll_enable(dpi->pll);\r\nif (r)\r\ngoto err_dsi_pll_init;\r\n}\r\nr = dpi_set_mode(dpi);\r\nif (r)\r\ngoto err_set_mode;\r\ndpi_config_lcd_manager(dpi);\r\nmdelay(2);\r\nr = dss_mgr_enable(out->manager);\r\nif (r)\r\ngoto err_mgr_enable;\r\nmutex_unlock(&dpi->lock);\r\nreturn 0;\r\nerr_mgr_enable:\r\nerr_set_mode:\r\nif (dpi->pll)\r\ndss_pll_disable(dpi->pll);\r\nerr_dsi_pll_init:\r\nerr_src_sel:\r\ndispc_runtime_put();\r\nerr_get_dispc:\r\nif (dss_has_feature(FEAT_DPI_USES_VDDS_DSI))\r\nregulator_disable(dpi->vdds_dsi_reg);\r\nerr_reg_enable:\r\nerr_no_out_mgr:\r\nerr_no_reg:\r\nmutex_unlock(&dpi->lock);\r\nreturn r;\r\n}\r\nstatic void dpi_display_disable(struct omap_dss_device *dssdev)\r\n{\r\nstruct dpi_data *dpi = dpi_get_data_from_dssdev(dssdev);\r\nstruct omap_overlay_manager *mgr = dpi->output.manager;\r\nmutex_lock(&dpi->lock);\r\ndss_mgr_disable(mgr);\r\nif (dpi->pll) {\r\ndss_select_lcd_clk_source(mgr->id, OMAP_DSS_CLK_SRC_FCK);\r\ndss_pll_disable(dpi->pll);\r\n}\r\ndispc_runtime_put();\r\nif (dss_has_feature(FEAT_DPI_USES_VDDS_DSI))\r\nregulator_disable(dpi->vdds_dsi_reg);\r\nmutex_unlock(&dpi->lock);\r\n}\r\nstatic void dpi_set_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nstruct dpi_data *dpi = dpi_get_data_from_dssdev(dssdev);\r\nDSSDBG("dpi_set_timings\n");\r\nmutex_lock(&dpi->lock);\r\ndpi->timings = *timings;\r\nmutex_unlock(&dpi->lock);\r\n}\r\nstatic void dpi_get_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nstruct dpi_data *dpi = dpi_get_data_from_dssdev(dssdev);\r\nmutex_lock(&dpi->lock);\r\n*timings = dpi->timings;\r\nmutex_unlock(&dpi->lock);\r\n}\r\nstatic int dpi_check_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nstruct dpi_data *dpi = dpi_get_data_from_dssdev(dssdev);\r\nstruct omap_overlay_manager *mgr = dpi->output.manager;\r\nint lck_div, pck_div;\r\nunsigned long fck;\r\nunsigned long pck;\r\nstruct dpi_clk_calc_ctx ctx;\r\nbool ok;\r\nif (mgr && !dispc_mgr_timings_ok(mgr->id, timings))\r\nreturn -EINVAL;\r\nif (timings->pixelclock == 0)\r\nreturn -EINVAL;\r\nif (dpi->pll) {\r\nok = dpi_dsi_clk_calc(dpi, timings->pixelclock, &ctx);\r\nif (!ok)\r\nreturn -EINVAL;\r\nfck = ctx.dsi_cinfo.clkout[HSDIV_DISPC];\r\n} else {\r\nok = dpi_dss_clk_calc(timings->pixelclock, &ctx);\r\nif (!ok)\r\nreturn -EINVAL;\r\nfck = ctx.fck;\r\n}\r\nlck_div = ctx.dispc_cinfo.lck_div;\r\npck_div = ctx.dispc_cinfo.pck_div;\r\npck = fck / lck_div / pck_div;\r\ntimings->pixelclock = pck;\r\nreturn 0;\r\n}\r\nstatic void dpi_set_data_lines(struct omap_dss_device *dssdev, int data_lines)\r\n{\r\nstruct dpi_data *dpi = dpi_get_data_from_dssdev(dssdev);\r\nmutex_lock(&dpi->lock);\r\ndpi->data_lines = data_lines;\r\nmutex_unlock(&dpi->lock);\r\n}\r\nstatic int dpi_verify_dsi_pll(struct dss_pll *pll)\r\n{\r\nint r;\r\nr = dss_pll_enable(pll);\r\nif (r)\r\nreturn r;\r\ndss_pll_disable(pll);\r\nreturn 0;\r\n}\r\nstatic int dpi_init_regulator(struct dpi_data *dpi)\r\n{\r\nstruct regulator *vdds_dsi;\r\nif (!dss_has_feature(FEAT_DPI_USES_VDDS_DSI))\r\nreturn 0;\r\nif (dpi->vdds_dsi_reg)\r\nreturn 0;\r\nvdds_dsi = devm_regulator_get(&dpi->pdev->dev, "vdds_dsi");\r\nif (IS_ERR(vdds_dsi)) {\r\nif (PTR_ERR(vdds_dsi) != -EPROBE_DEFER)\r\nDSSERR("can't get VDDS_DSI regulator\n");\r\nreturn PTR_ERR(vdds_dsi);\r\n}\r\ndpi->vdds_dsi_reg = vdds_dsi;\r\nreturn 0;\r\n}\r\nstatic void dpi_init_pll(struct dpi_data *dpi)\r\n{\r\nstruct dss_pll *pll;\r\nif (dpi->pll)\r\nreturn;\r\npll = dpi_get_pll(dpi->output.dispc_channel);\r\nif (!pll)\r\nreturn;\r\nif (omapdss_get_version() == OMAPDSS_VER_DRA7xx)\r\ndss_ctrl_pll_set_control_mux(pll->id, dpi->output.dispc_channel);\r\nif (dpi_verify_dsi_pll(pll)) {\r\nDSSWARN("DSI PLL not operational\n");\r\nreturn;\r\n}\r\ndpi->pll = pll;\r\n}\r\nstatic enum omap_channel dpi_get_channel(int port_num)\r\n{\r\nswitch (omapdss_get_version()) {\r\ncase OMAPDSS_VER_OMAP24xx:\r\ncase OMAPDSS_VER_OMAP34xx_ES1:\r\ncase OMAPDSS_VER_OMAP34xx_ES3:\r\ncase OMAPDSS_VER_OMAP3630:\r\ncase OMAPDSS_VER_AM35xx:\r\ncase OMAPDSS_VER_AM43xx:\r\nreturn OMAP_DSS_CHANNEL_LCD;\r\ncase OMAPDSS_VER_DRA7xx:\r\nswitch (port_num) {\r\ncase 2:\r\nreturn OMAP_DSS_CHANNEL_LCD3;\r\ncase 1:\r\nreturn OMAP_DSS_CHANNEL_LCD2;\r\ncase 0:\r\ndefault:\r\nreturn OMAP_DSS_CHANNEL_LCD;\r\n}\r\ncase OMAPDSS_VER_OMAP4430_ES1:\r\ncase OMAPDSS_VER_OMAP4430_ES2:\r\ncase OMAPDSS_VER_OMAP4:\r\nreturn OMAP_DSS_CHANNEL_LCD2;\r\ncase OMAPDSS_VER_OMAP5:\r\nreturn OMAP_DSS_CHANNEL_LCD3;\r\ndefault:\r\nDSSWARN("unsupported DSS version\n");\r\nreturn OMAP_DSS_CHANNEL_LCD;\r\n}\r\n}\r\nstatic int dpi_connect(struct omap_dss_device *dssdev,\r\nstruct omap_dss_device *dst)\r\n{\r\nstruct dpi_data *dpi = dpi_get_data_from_dssdev(dssdev);\r\nstruct omap_overlay_manager *mgr;\r\nint r;\r\nr = dpi_init_regulator(dpi);\r\nif (r)\r\nreturn r;\r\ndpi_init_pll(dpi);\r\nmgr = omap_dss_get_overlay_manager(dssdev->dispc_channel);\r\nif (!mgr)\r\nreturn -ENODEV;\r\nr = dss_mgr_connect(mgr, dssdev);\r\nif (r)\r\nreturn r;\r\nr = omapdss_output_set_device(dssdev, dst);\r\nif (r) {\r\nDSSERR("failed to connect output to new device: %s\n",\r\ndst->name);\r\ndss_mgr_disconnect(mgr, dssdev);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dpi_disconnect(struct omap_dss_device *dssdev,\r\nstruct omap_dss_device *dst)\r\n{\r\nWARN_ON(dst != dssdev->dst);\r\nif (dst != dssdev->dst)\r\nreturn;\r\nomapdss_output_unset_device(dssdev);\r\nif (dssdev->manager)\r\ndss_mgr_disconnect(dssdev->manager, dssdev);\r\n}\r\nstatic void dpi_init_output(struct platform_device *pdev)\r\n{\r\nstruct dpi_data *dpi = dpi_get_data_from_pdev(pdev);\r\nstruct omap_dss_device *out = &dpi->output;\r\nout->dev = &pdev->dev;\r\nout->id = OMAP_DSS_OUTPUT_DPI;\r\nout->output_type = OMAP_DISPLAY_TYPE_DPI;\r\nout->name = "dpi.0";\r\nout->dispc_channel = dpi_get_channel(0);\r\nout->ops.dpi = &dpi_ops;\r\nout->owner = THIS_MODULE;\r\nomapdss_register_output(out);\r\n}\r\nstatic void dpi_uninit_output(struct platform_device *pdev)\r\n{\r\nstruct dpi_data *dpi = dpi_get_data_from_pdev(pdev);\r\nstruct omap_dss_device *out = &dpi->output;\r\nomapdss_unregister_output(out);\r\n}\r\nstatic void dpi_init_output_port(struct platform_device *pdev,\r\nstruct device_node *port)\r\n{\r\nstruct dpi_data *dpi = port->data;\r\nstruct omap_dss_device *out = &dpi->output;\r\nint r;\r\nu32 port_num;\r\nr = of_property_read_u32(port, "reg", &port_num);\r\nif (r)\r\nport_num = 0;\r\nswitch (port_num) {\r\ncase 2:\r\nout->name = "dpi.2";\r\nbreak;\r\ncase 1:\r\nout->name = "dpi.1";\r\nbreak;\r\ncase 0:\r\ndefault:\r\nout->name = "dpi.0";\r\nbreak;\r\n}\r\nout->dev = &pdev->dev;\r\nout->id = OMAP_DSS_OUTPUT_DPI;\r\nout->output_type = OMAP_DISPLAY_TYPE_DPI;\r\nout->dispc_channel = dpi_get_channel(port_num);\r\nout->port_num = port_num;\r\nout->ops.dpi = &dpi_ops;\r\nout->owner = THIS_MODULE;\r\nomapdss_register_output(out);\r\n}\r\nstatic void dpi_uninit_output_port(struct device_node *port)\r\n{\r\nstruct dpi_data *dpi = port->data;\r\nstruct omap_dss_device *out = &dpi->output;\r\nomapdss_unregister_output(out);\r\n}\r\nstatic int dpi_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct dpi_data *dpi;\r\ndpi = devm_kzalloc(&pdev->dev, sizeof(*dpi), GFP_KERNEL);\r\nif (!dpi)\r\nreturn -ENOMEM;\r\ndpi->pdev = pdev;\r\ndev_set_drvdata(&pdev->dev, dpi);\r\nmutex_init(&dpi->lock);\r\ndpi_init_output(pdev);\r\nreturn 0;\r\n}\r\nstatic void dpi_unbind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\ndpi_uninit_output(pdev);\r\n}\r\nstatic int dpi_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &dpi_component_ops);\r\n}\r\nstatic int dpi_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &dpi_component_ops);\r\nreturn 0;\r\n}\r\nint __init dpi_init_platform_driver(void)\r\n{\r\nreturn platform_driver_register(&omap_dpi_driver);\r\n}\r\nvoid dpi_uninit_platform_driver(void)\r\n{\r\nplatform_driver_unregister(&omap_dpi_driver);\r\n}\r\nint dpi_init_port(struct platform_device *pdev, struct device_node *port)\r\n{\r\nstruct dpi_data *dpi;\r\nstruct device_node *ep;\r\nu32 datalines;\r\nint r;\r\ndpi = devm_kzalloc(&pdev->dev, sizeof(*dpi), GFP_KERNEL);\r\nif (!dpi)\r\nreturn -ENOMEM;\r\nep = omapdss_of_get_next_endpoint(port, NULL);\r\nif (!ep)\r\nreturn 0;\r\nr = of_property_read_u32(ep, "data-lines", &datalines);\r\nif (r) {\r\nDSSERR("failed to parse datalines\n");\r\ngoto err_datalines;\r\n}\r\ndpi->data_lines = datalines;\r\nof_node_put(ep);\r\ndpi->pdev = pdev;\r\nport->data = dpi;\r\nmutex_init(&dpi->lock);\r\ndpi_init_output_port(pdev, port);\r\ndpi->port_initialized = true;\r\nreturn 0;\r\nerr_datalines:\r\nof_node_put(ep);\r\nreturn r;\r\n}\r\nvoid dpi_uninit_port(struct device_node *port)\r\n{\r\nstruct dpi_data *dpi = port->data;\r\nif (!dpi->port_initialized)\r\nreturn;\r\ndpi_uninit_output_port(port);\r\n}
