static int cxd2820r_wr_regs_i2c(struct cxd2820r_priv *priv, u8 i2c, u8 reg,\r\nu8 *val, int len)\r\n{\r\nint ret;\r\nu8 buf[MAX_XFER_SIZE];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = i2c,\r\n.flags = 0,\r\n.len = len + 1,\r\n.buf = buf,\r\n}\r\n};\r\nif (1 + len > sizeof(buf)) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c wr reg=%04x: len=%d is too big!\n",\r\nKBUILD_MODNAME, reg, len);\r\nreturn -EINVAL;\r\n}\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], val, len);\r\nret = i2c_transfer(priv->i2c, msg, 1);\r\nif (ret == 1) {\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev, "%s: i2c wr failed=%d reg=%02x " \\r\n"len=%d\n", KBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_rd_regs_i2c(struct cxd2820r_priv *priv, u8 i2c, u8 reg,\r\nu8 *val, int len)\r\n{\r\nint ret;\r\nu8 buf[MAX_XFER_SIZE];\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = i2c,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &reg,\r\n}, {\r\n.addr = i2c,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = buf,\r\n}\r\n};\r\nif (len > sizeof(buf)) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c wr reg=%04x: len=%d is too big!\n",\r\nKBUILD_MODNAME, reg, len);\r\nreturn -EINVAL;\r\n}\r\nret = i2c_transfer(priv->i2c, msg, 2);\r\nif (ret == 2) {\r\nmemcpy(val, buf, len);\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev, "%s: i2c rd failed=%d reg=%02x " \\r\n"len=%d\n", KBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nint cxd2820r_wr_regs(struct cxd2820r_priv *priv, u32 reginfo, u8 *val,\r\nint len)\r\n{\r\nint ret;\r\nu8 i2c_addr;\r\nu8 reg = (reginfo >> 0) & 0xff;\r\nu8 bank = (reginfo >> 8) & 0xff;\r\nu8 i2c = (reginfo >> 16) & 0x01;\r\nif (i2c)\r\ni2c_addr = priv->cfg.i2c_address | (1 << 1);\r\nelse\r\ni2c_addr = priv->cfg.i2c_address;\r\nif (bank != priv->bank[i2c]) {\r\nret = cxd2820r_wr_regs_i2c(priv, i2c_addr, 0x00, &bank, 1);\r\nif (ret)\r\nreturn ret;\r\npriv->bank[i2c] = bank;\r\n}\r\nreturn cxd2820r_wr_regs_i2c(priv, i2c_addr, reg, val, len);\r\n}\r\nint cxd2820r_rd_regs(struct cxd2820r_priv *priv, u32 reginfo, u8 *val,\r\nint len)\r\n{\r\nint ret;\r\nu8 i2c_addr;\r\nu8 reg = (reginfo >> 0) & 0xff;\r\nu8 bank = (reginfo >> 8) & 0xff;\r\nu8 i2c = (reginfo >> 16) & 0x01;\r\nif (i2c)\r\ni2c_addr = priv->cfg.i2c_address | (1 << 1);\r\nelse\r\ni2c_addr = priv->cfg.i2c_address;\r\nif (bank != priv->bank[i2c]) {\r\nret = cxd2820r_wr_regs_i2c(priv, i2c_addr, 0x00, &bank, 1);\r\nif (ret)\r\nreturn ret;\r\npriv->bank[i2c] = bank;\r\n}\r\nreturn cxd2820r_rd_regs_i2c(priv, i2c_addr, reg, val, len);\r\n}\r\nint cxd2820r_wr_reg(struct cxd2820r_priv *priv, u32 reg, u8 val)\r\n{\r\nreturn cxd2820r_wr_regs(priv, reg, &val, 1);\r\n}\r\nint cxd2820r_rd_reg(struct cxd2820r_priv *priv, u32 reg, u8 *val)\r\n{\r\nreturn cxd2820r_rd_regs(priv, reg, val, 1);\r\n}\r\nint cxd2820r_wr_reg_mask(struct cxd2820r_priv *priv, u32 reg, u8 val,\r\nu8 mask)\r\n{\r\nint ret;\r\nu8 tmp;\r\nif (mask != 0xff) {\r\nret = cxd2820r_rd_reg(priv, reg, &tmp);\r\nif (ret)\r\nreturn ret;\r\nval &= mask;\r\ntmp &= ~mask;\r\nval |= tmp;\r\n}\r\nreturn cxd2820r_wr_reg(priv, reg, val);\r\n}\r\nint cxd2820r_gpio(struct dvb_frontend *fe, u8 *gpio)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nint ret, i;\r\nu8 tmp0, tmp1;\r\ndev_dbg(&priv->i2c->dev, "%s: delsys=%d\n", __func__,\r\nfe->dtv_property_cache.delivery_system);\r\nif (!memcmp(gpio, priv->gpio, sizeof(priv->gpio)))\r\nreturn 0;\r\ntmp0 = 0x00;\r\ntmp1 = 0x00;\r\nfor (i = 0; i < sizeof(priv->gpio); i++) {\r\nif (gpio[i] & CXD2820R_GPIO_E)\r\ntmp0 |= (2 << 6) >> (2 * i);\r\nelse\r\ntmp0 |= (1 << 6) >> (2 * i);\r\nif (gpio[i] & CXD2820R_GPIO_I)\r\ntmp1 |= (1 << (3 + i));\r\nelse\r\ntmp1 |= (0 << (3 + i));\r\nif (gpio[i] & CXD2820R_GPIO_H)\r\ntmp1 |= (1 << (0 + i));\r\nelse\r\ntmp1 |= (0 << (0 + i));\r\ndev_dbg(&priv->i2c->dev, "%s: gpio i=%d %02x %02x\n", __func__,\r\ni, tmp0, tmp1);\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s: wr gpio=%02x %02x\n", __func__, tmp0,\r\ntmp1);\r\nret = cxd2820r_wr_reg_mask(priv, 0x00089, tmp0, 0xfc);\r\nif (ret)\r\ngoto error;\r\nret = cxd2820r_wr_reg_mask(priv, 0x0008e, tmp1, 0x3f);\r\nif (ret)\r\ngoto error;\r\nmemcpy(priv->gpio, gpio, sizeof(priv->gpio));\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\ndev_dbg(&priv->i2c->dev, "%s: delsys=%d\n", __func__,\r\nfe->dtv_property_cache.delivery_system);\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_init_t(fe);\r\nif (ret < 0)\r\ngoto err;\r\nret = cxd2820r_set_frontend_t(fe);\r\nif (ret < 0)\r\ngoto err;\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_init_t(fe);\r\nif (ret < 0)\r\ngoto err;\r\nret = cxd2820r_set_frontend_t2(fe);\r\nif (ret < 0)\r\ngoto err;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_init_c(fe);\r\nif (ret < 0)\r\ngoto err;\r\nret = cxd2820r_set_frontend_c(fe);\r\nif (ret < 0)\r\ngoto err;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: error state=%d\n", __func__,\r\nfe->dtv_property_cache.delivery_system);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nint ret;\r\ndev_dbg(&priv->i2c->dev, "%s: delsys=%d\n", __func__,\r\nfe->dtv_property_cache.delivery_system);\r\nswitch (fe->dtv_property_cache.delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_read_status_t(fe, status);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_read_status_t2(fe, status);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_read_status_c(fe, status);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nint ret;\r\ndev_dbg(&priv->i2c->dev, "%s: delsys=%d\n", __func__,\r\nfe->dtv_property_cache.delivery_system);\r\nif (priv->delivery_system == SYS_UNDEFINED)\r\nreturn 0;\r\nswitch (fe->dtv_property_cache.delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_get_frontend_t(fe);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_get_frontend_t2(fe);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_get_frontend_c(fe);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nint ret;\r\ndev_dbg(&priv->i2c->dev, "%s: delsys=%d\n", __func__,\r\nfe->dtv_property_cache.delivery_system);\r\nswitch (fe->dtv_property_cache.delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_read_ber_t(fe, ber);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_read_ber_t2(fe, ber);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_read_ber_c(fe, ber);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nint ret;\r\ndev_dbg(&priv->i2c->dev, "%s: delsys=%d\n", __func__,\r\nfe->dtv_property_cache.delivery_system);\r\nswitch (fe->dtv_property_cache.delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_read_signal_strength_t(fe, strength);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_read_signal_strength_t2(fe, strength);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_read_signal_strength_c(fe, strength);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nint ret;\r\ndev_dbg(&priv->i2c->dev, "%s: delsys=%d\n", __func__,\r\nfe->dtv_property_cache.delivery_system);\r\nswitch (fe->dtv_property_cache.delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_read_snr_t(fe, snr);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_read_snr_t2(fe, snr);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_read_snr_c(fe, snr);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nint ret;\r\ndev_dbg(&priv->i2c->dev, "%s: delsys=%d\n", __func__,\r\nfe->dtv_property_cache.delivery_system);\r\nswitch (fe->dtv_property_cache.delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_read_ucblocks_t(fe, ucblocks);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_read_ucblocks_t2(fe, ucblocks);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_read_ucblocks_c(fe, ucblocks);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_init(struct dvb_frontend *fe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cxd2820r_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nint ret;\r\ndev_dbg(&priv->i2c->dev, "%s: delsys=%d\n", __func__,\r\nfe->dtv_property_cache.delivery_system);\r\nswitch (fe->dtv_property_cache.delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_sleep_t(fe);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_sleep_t2(fe);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_sleep_c(fe);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *s)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nint ret;\r\ndev_dbg(&priv->i2c->dev, "%s: delsys=%d\n", __func__,\r\nfe->dtv_property_cache.delivery_system);\r\nswitch (fe->dtv_property_cache.delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_get_tune_settings_t(fe, s);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_get_tune_settings_t2(fe, s);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_get_tune_settings_c(fe, s);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic enum dvbfe_search cxd2820r_search(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i;\r\nenum fe_status status = 0;\r\ndev_dbg(&priv->i2c->dev, "%s: delsys=%d\n", __func__,\r\nfe->dtv_property_cache.delivery_system);\r\nif (priv->last_tune_failed) {\r\nif (priv->delivery_system == SYS_DVBT) {\r\nret = cxd2820r_sleep_t(fe);\r\nif (ret)\r\ngoto error;\r\nc->delivery_system = SYS_DVBT2;\r\n} else if (priv->delivery_system == SYS_DVBT2) {\r\nret = cxd2820r_sleep_t2(fe);\r\nif (ret)\r\ngoto error;\r\nc->delivery_system = SYS_DVBT;\r\n}\r\n}\r\nret = cxd2820r_set_frontend(fe);\r\nif (ret)\r\ngoto error;\r\nswitch (priv->delivery_system) {\r\ncase SYS_DVBT:\r\ncase SYS_DVBC_ANNEX_A:\r\ni = 20;\r\nbreak;\r\ncase SYS_DVBT2:\r\ni = 40;\r\nbreak;\r\ncase SYS_UNDEFINED:\r\ndefault:\r\ni = 0;\r\nbreak;\r\n}\r\nfor (; i > 0; i--) {\r\ndev_dbg(&priv->i2c->dev, "%s: loop=%d\n", __func__, i);\r\nmsleep(50);\r\nret = cxd2820r_read_status(fe, &status);\r\nif (ret)\r\ngoto error;\r\nif (status & FE_HAS_LOCK)\r\nbreak;\r\n}\r\nif (status & FE_HAS_LOCK) {\r\npriv->last_tune_failed = false;\r\nreturn DVBFE_ALGO_SEARCH_SUCCESS;\r\n} else {\r\npriv->last_tune_failed = true;\r\nreturn DVBFE_ALGO_SEARCH_AGAIN;\r\n}\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn DVBFE_ALGO_SEARCH_ERROR;\r\n}\r\nstatic int cxd2820r_get_frontend_algo(struct dvb_frontend *fe)\r\n{\r\nreturn DVBFE_ALGO_CUSTOM;\r\n}\r\nstatic void cxd2820r_release(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s\n", __func__);\r\n#ifdef CONFIG_GPIOLIB\r\nif (priv->gpio_chip.label)\r\ngpiochip_remove(&priv->gpio_chip);\r\n#endif\r\nkfree(priv);\r\nreturn;\r\n}\r\nstatic int cxd2820r_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s: %d\n", __func__, enable);\r\nreturn cxd2820r_wr_reg_mask(priv, 0xdb, enable ? 1 : 0, 0x1);\r\n}\r\nstatic int cxd2820r_gpio_direction_output(struct gpio_chip *chip, unsigned nr,\r\nint val)\r\n{\r\nstruct cxd2820r_priv *priv =\r\ncontainer_of(chip, struct cxd2820r_priv, gpio_chip);\r\nu8 gpio[GPIO_COUNT];\r\ndev_dbg(&priv->i2c->dev, "%s: nr=%d val=%d\n", __func__, nr, val);\r\nmemcpy(gpio, priv->gpio, sizeof(gpio));\r\ngpio[nr] = CXD2820R_GPIO_E | CXD2820R_GPIO_O | (val << 2);\r\nreturn cxd2820r_gpio(&priv->fe, gpio);\r\n}\r\nstatic void cxd2820r_gpio_set(struct gpio_chip *chip, unsigned nr, int val)\r\n{\r\nstruct cxd2820r_priv *priv =\r\ncontainer_of(chip, struct cxd2820r_priv, gpio_chip);\r\nu8 gpio[GPIO_COUNT];\r\ndev_dbg(&priv->i2c->dev, "%s: nr=%d val=%d\n", __func__, nr, val);\r\nmemcpy(gpio, priv->gpio, sizeof(gpio));\r\ngpio[nr] = CXD2820R_GPIO_E | CXD2820R_GPIO_O | (val << 2);\r\n(void) cxd2820r_gpio(&priv->fe, gpio);\r\nreturn;\r\n}\r\nstatic int cxd2820r_gpio_get(struct gpio_chip *chip, unsigned nr)\r\n{\r\nstruct cxd2820r_priv *priv =\r\ncontainer_of(chip, struct cxd2820r_priv, gpio_chip);\r\ndev_dbg(&priv->i2c->dev, "%s: nr=%d\n", __func__, nr);\r\nreturn (priv->gpio[nr] >> 2) & 0x01;\r\n}\r\nstruct dvb_frontend *cxd2820r_attach(const struct cxd2820r_config *cfg,\r\nstruct i2c_adapter *i2c, int *gpio_chip_base\r\n)\r\n{\r\nstruct cxd2820r_priv *priv;\r\nint ret;\r\nu8 tmp;\r\npriv = kzalloc(sizeof(struct cxd2820r_priv), GFP_KERNEL);\r\nif (!priv) {\r\nret = -ENOMEM;\r\ndev_err(&i2c->dev, "%s: kzalloc() failed\n",\r\nKBUILD_MODNAME);\r\ngoto error;\r\n}\r\npriv->i2c = i2c;\r\nmemcpy(&priv->cfg, cfg, sizeof(struct cxd2820r_config));\r\nmemcpy(&priv->fe.ops, &cxd2820r_ops, sizeof(struct dvb_frontend_ops));\r\npriv->fe.demodulator_priv = priv;\r\npriv->bank[0] = priv->bank[1] = 0xff;\r\nret = cxd2820r_rd_reg(priv, 0x000fd, &tmp);\r\ndev_dbg(&priv->i2c->dev, "%s: chip id=%02x\n", __func__, tmp);\r\nif (ret || tmp != 0xe1)\r\ngoto error;\r\nif (gpio_chip_base) {\r\n#ifdef CONFIG_GPIOLIB\r\npriv->gpio_chip.label = KBUILD_MODNAME;\r\npriv->gpio_chip.dev = &priv->i2c->dev;\r\npriv->gpio_chip.owner = THIS_MODULE;\r\npriv->gpio_chip.direction_output =\r\ncxd2820r_gpio_direction_output;\r\npriv->gpio_chip.set = cxd2820r_gpio_set;\r\npriv->gpio_chip.get = cxd2820r_gpio_get;\r\npriv->gpio_chip.base = -1;\r\npriv->gpio_chip.ngpio = GPIO_COUNT;\r\npriv->gpio_chip.can_sleep = 1;\r\nret = gpiochip_add(&priv->gpio_chip);\r\nif (ret)\r\ngoto error;\r\ndev_dbg(&priv->i2c->dev, "%s: gpio_chip.base=%d\n", __func__,\r\npriv->gpio_chip.base);\r\n*gpio_chip_base = priv->gpio_chip.base;\r\n#else\r\nu8 gpio[GPIO_COUNT];\r\ngpio[0] = (*gpio_chip_base >> 0) & 0x07;\r\ngpio[1] = (*gpio_chip_base >> 3) & 0x07;\r\ngpio[2] = 0;\r\nret = cxd2820r_gpio(&priv->fe, gpio);\r\nif (ret)\r\ngoto error;\r\n#endif\r\n}\r\nreturn &priv->fe;\r\nerror:\r\ndev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nkfree(priv);\r\nreturn NULL;\r\n}
