static ide_startstop_t ide_ata_error(ide_drive_t *drive, struct request *rq,\r\nu8 stat, u8 err)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nif ((stat & ATA_BUSY) ||\r\n((stat & ATA_DF) && (drive->dev_flags & IDE_DFLAG_NOWERR) == 0)) {\r\nrq->errors |= ERROR_RESET;\r\n} else if (stat & ATA_ERR) {\r\nif (err == ATA_ABORTED) {\r\nif ((drive->dev_flags & IDE_DFLAG_LBA) &&\r\nhwif->tp_ops->read_status(hwif) == ATA_CMD_INIT_DEV_PARAMS)\r\nreturn ide_stopped;\r\n} else if ((err & BAD_CRC) == BAD_CRC) {\r\ndrive->crc_count++;\r\n} else if (err & (ATA_BBK | ATA_UNC)) {\r\nrq->errors = ERROR_MAX;\r\n} else if (err & ATA_TRK0NF) {\r\nrq->errors |= ERROR_RECAL;\r\n}\r\n}\r\nif ((stat & ATA_DRQ) && rq_data_dir(rq) == READ &&\r\n(hwif->host_flags & IDE_HFLAG_ERROR_STOPS_FIFO) == 0) {\r\nint nsect = drive->mult_count ? drive->mult_count : 1;\r\nide_pad_transfer(drive, READ, nsect * SECTOR_SIZE);\r\n}\r\nif (rq->errors >= ERROR_MAX || blk_noretry_request(rq)) {\r\nide_kill_rq(drive, rq);\r\nreturn ide_stopped;\r\n}\r\nif (hwif->tp_ops->read_status(hwif) & (ATA_BUSY | ATA_DRQ))\r\nrq->errors |= ERROR_RESET;\r\nif ((rq->errors & ERROR_RESET) == ERROR_RESET) {\r\n++rq->errors;\r\nreturn ide_do_reset(drive);\r\n}\r\nif ((rq->errors & ERROR_RECAL) == ERROR_RECAL)\r\ndrive->special_flags |= IDE_SFLAG_RECALIBRATE;\r\n++rq->errors;\r\nreturn ide_stopped;\r\n}\r\nstatic ide_startstop_t ide_atapi_error(ide_drive_t *drive, struct request *rq,\r\nu8 stat, u8 err)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nif ((stat & ATA_BUSY) ||\r\n((stat & ATA_DF) && (drive->dev_flags & IDE_DFLAG_NOWERR) == 0)) {\r\nrq->errors |= ERROR_RESET;\r\n} else {\r\n}\r\nif (hwif->tp_ops->read_status(hwif) & (ATA_BUSY | ATA_DRQ))\r\nhwif->tp_ops->exec_command(hwif, ATA_CMD_IDLEIMMEDIATE);\r\nif (rq->errors >= ERROR_MAX) {\r\nide_kill_rq(drive, rq);\r\n} else {\r\nif ((rq->errors & ERROR_RESET) == ERROR_RESET) {\r\n++rq->errors;\r\nreturn ide_do_reset(drive);\r\n}\r\n++rq->errors;\r\n}\r\nreturn ide_stopped;\r\n}\r\nstatic ide_startstop_t __ide_error(ide_drive_t *drive, struct request *rq,\r\nu8 stat, u8 err)\r\n{\r\nif (drive->media == ide_disk)\r\nreturn ide_ata_error(drive, rq, stat, err);\r\nreturn ide_atapi_error(drive, rq, stat, err);\r\n}\r\nide_startstop_t ide_error(ide_drive_t *drive, const char *msg, u8 stat)\r\n{\r\nstruct request *rq;\r\nu8 err;\r\nerr = ide_dump_status(drive, msg, stat);\r\nrq = drive->hwif->rq;\r\nif (rq == NULL)\r\nreturn ide_stopped;\r\nif (rq->cmd_type != REQ_TYPE_FS) {\r\nif (rq->cmd_type == REQ_TYPE_ATA_TASKFILE) {\r\nstruct ide_cmd *cmd = rq->special;\r\nif (cmd)\r\nide_complete_cmd(drive, cmd, stat, err);\r\n} else if (ata_pm_request(rq)) {\r\nrq->errors = 1;\r\nide_complete_pm_rq(drive, rq);\r\nreturn ide_stopped;\r\n}\r\nrq->errors = err;\r\nide_complete_rq(drive, err ? -EIO : 0, blk_rq_bytes(rq));\r\nreturn ide_stopped;\r\n}\r\nreturn __ide_error(drive, rq, stat, err);\r\n}\r\nstatic inline void ide_complete_drive_reset(ide_drive_t *drive, int err)\r\n{\r\nstruct request *rq = drive->hwif->rq;\r\nif (rq && rq->cmd_type == REQ_TYPE_DRV_PRIV &&\r\nrq->cmd[0] == REQ_DRIVE_RESET) {\r\nif (err <= 0 && rq->errors == 0)\r\nrq->errors = -EIO;\r\nide_complete_rq(drive, err ? err : 0, blk_rq_bytes(rq));\r\n}\r\n}\r\nstatic ide_startstop_t atapi_reset_pollfunc(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nconst struct ide_tp_ops *tp_ops = hwif->tp_ops;\r\nu8 stat;\r\ntp_ops->dev_select(drive);\r\nudelay(10);\r\nstat = tp_ops->read_status(hwif);\r\nif (OK_STAT(stat, 0, ATA_BUSY))\r\nprintk(KERN_INFO "%s: ATAPI reset complete\n", drive->name);\r\nelse {\r\nif (time_before(jiffies, hwif->poll_timeout)) {\r\nide_set_handler(drive, &atapi_reset_pollfunc, HZ/20);\r\nreturn ide_started;\r\n}\r\nhwif->polling = 0;\r\nprintk(KERN_ERR "%s: ATAPI reset timed-out, status=0x%02x\n",\r\ndrive->name, stat);\r\nreturn do_reset1(drive, 1);\r\n}\r\nhwif->polling = 0;\r\nide_complete_drive_reset(drive, 0);\r\nreturn ide_stopped;\r\n}\r\nstatic void ide_reset_report_error(ide_hwif_t *hwif, u8 err)\r\n{\r\nstatic const char *err_master_vals[] =\r\n{ NULL, "passed", "formatter device error",\r\n"sector buffer error", "ECC circuitry error",\r\n"controlling MPU error" };\r\nu8 err_master = err & 0x7f;\r\nprintk(KERN_ERR "%s: reset: master: ", hwif->name);\r\nif (err_master && err_master < 6)\r\nprintk(KERN_CONT "%s", err_master_vals[err_master]);\r\nelse\r\nprintk(KERN_CONT "error (0x%02x?)", err);\r\nif (err & 0x80)\r\nprintk(KERN_CONT "; slave: failed");\r\nprintk(KERN_CONT "\n");\r\n}\r\nstatic ide_startstop_t reset_pollfunc(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nconst struct ide_port_ops *port_ops = hwif->port_ops;\r\nu8 tmp;\r\nint err = 0;\r\nif (port_ops && port_ops->reset_poll) {\r\nerr = port_ops->reset_poll(drive);\r\nif (err) {\r\nprintk(KERN_ERR "%s: host reset_poll failure for %s.\n",\r\nhwif->name, drive->name);\r\ngoto out;\r\n}\r\n}\r\ntmp = hwif->tp_ops->read_status(hwif);\r\nif (!OK_STAT(tmp, 0, ATA_BUSY)) {\r\nif (time_before(jiffies, hwif->poll_timeout)) {\r\nide_set_handler(drive, &reset_pollfunc, HZ/20);\r\nreturn ide_started;\r\n}\r\nprintk(KERN_ERR "%s: reset timed-out, status=0x%02x\n",\r\nhwif->name, tmp);\r\ndrive->failures++;\r\nerr = -EIO;\r\n} else {\r\ntmp = ide_read_error(drive);\r\nif (tmp == 1) {\r\nprintk(KERN_INFO "%s: reset: success\n", hwif->name);\r\ndrive->failures = 0;\r\n} else {\r\nide_reset_report_error(hwif, tmp);\r\ndrive->failures++;\r\nerr = -EIO;\r\n}\r\n}\r\nout:\r\nhwif->polling = 0;\r\nide_complete_drive_reset(drive, err);\r\nreturn ide_stopped;\r\n}\r\nstatic void ide_disk_pre_reset(ide_drive_t *drive)\r\n{\r\nint legacy = (drive->id[ATA_ID_CFS_ENABLE_2] & 0x0400) ? 0 : 1;\r\ndrive->special_flags =\r\nlegacy ? (IDE_SFLAG_SET_GEOMETRY | IDE_SFLAG_RECALIBRATE) : 0;\r\ndrive->mult_count = 0;\r\ndrive->dev_flags &= ~IDE_DFLAG_PARKED;\r\nif ((drive->dev_flags & IDE_DFLAG_KEEP_SETTINGS) == 0 &&\r\n(drive->dev_flags & IDE_DFLAG_USING_DMA) == 0)\r\ndrive->mult_req = 0;\r\nif (drive->mult_req != drive->mult_count)\r\ndrive->special_flags |= IDE_SFLAG_SET_MULTMODE;\r\n}\r\nstatic void pre_reset(ide_drive_t *drive)\r\n{\r\nconst struct ide_port_ops *port_ops = drive->hwif->port_ops;\r\nif (drive->media == ide_disk)\r\nide_disk_pre_reset(drive);\r\nelse\r\ndrive->dev_flags |= IDE_DFLAG_POST_RESET;\r\nif (drive->dev_flags & IDE_DFLAG_USING_DMA) {\r\nif (drive->crc_count)\r\nide_check_dma_crc(drive);\r\nelse\r\nide_dma_off(drive);\r\n}\r\nif ((drive->dev_flags & IDE_DFLAG_KEEP_SETTINGS) == 0) {\r\nif ((drive->dev_flags & IDE_DFLAG_USING_DMA) == 0) {\r\ndrive->dev_flags &= ~IDE_DFLAG_UNMASK;\r\ndrive->io_32bit = 0;\r\n}\r\nreturn;\r\n}\r\nif (port_ops && port_ops->pre_reset)\r\nport_ops->pre_reset(drive);\r\nif (drive->current_speed != 0xff)\r\ndrive->desired_speed = drive->current_speed;\r\ndrive->current_speed = 0xff;\r\n}\r\nstatic ide_startstop_t do_reset1(ide_drive_t *drive, int do_not_try_atapi)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct ide_io_ports *io_ports = &hwif->io_ports;\r\nconst struct ide_tp_ops *tp_ops = hwif->tp_ops;\r\nconst struct ide_port_ops *port_ops;\r\nide_drive_t *tdrive;\r\nunsigned long flags, timeout;\r\nint i;\r\nDEFINE_WAIT(wait);\r\nspin_lock_irqsave(&hwif->lock, flags);\r\nBUG_ON(hwif->handler != NULL);\r\nif (drive->media != ide_disk && !do_not_try_atapi) {\r\npre_reset(drive);\r\ntp_ops->dev_select(drive);\r\nudelay(20);\r\ntp_ops->exec_command(hwif, ATA_CMD_DEV_RESET);\r\nndelay(400);\r\nhwif->poll_timeout = jiffies + WAIT_WORSTCASE;\r\nhwif->polling = 1;\r\n__ide_set_handler(drive, &atapi_reset_pollfunc, HZ/20);\r\nspin_unlock_irqrestore(&hwif->lock, flags);\r\nreturn ide_started;\r\n}\r\ndo {\r\nunsigned long now;\r\nprepare_to_wait(&ide_park_wq, &wait, TASK_UNINTERRUPTIBLE);\r\ntimeout = jiffies;\r\nide_port_for_each_present_dev(i, tdrive, hwif) {\r\nif ((tdrive->dev_flags & IDE_DFLAG_PARKED) &&\r\ntime_after(tdrive->sleep, timeout))\r\ntimeout = tdrive->sleep;\r\n}\r\nnow = jiffies;\r\nif (time_before_eq(timeout, now))\r\nbreak;\r\nspin_unlock_irqrestore(&hwif->lock, flags);\r\ntimeout = schedule_timeout_uninterruptible(timeout - now);\r\nspin_lock_irqsave(&hwif->lock, flags);\r\n} while (timeout);\r\nfinish_wait(&ide_park_wq, &wait);\r\nide_port_for_each_dev(i, tdrive, hwif)\r\npre_reset(tdrive);\r\nif (io_ports->ctl_addr == 0) {\r\nspin_unlock_irqrestore(&hwif->lock, flags);\r\nide_complete_drive_reset(drive, -ENXIO);\r\nreturn ide_stopped;\r\n}\r\ntp_ops->write_devctl(hwif, ATA_SRST | ATA_NIEN | ATA_DEVCTL_OBS);\r\nudelay(10);\r\ntp_ops->write_devctl(hwif,\r\n((drive->dev_flags & IDE_DFLAG_NIEN_QUIRK) ? 0 : ATA_NIEN) |\r\nATA_DEVCTL_OBS);\r\nudelay(10);\r\nhwif->poll_timeout = jiffies + WAIT_WORSTCASE;\r\nhwif->polling = 1;\r\n__ide_set_handler(drive, &reset_pollfunc, HZ/20);\r\nport_ops = hwif->port_ops;\r\nif (port_ops && port_ops->resetproc)\r\nport_ops->resetproc(drive);\r\nspin_unlock_irqrestore(&hwif->lock, flags);\r\nreturn ide_started;\r\n}\r\nide_startstop_t ide_do_reset(ide_drive_t *drive)\r\n{\r\nreturn do_reset1(drive, 0);\r\n}
