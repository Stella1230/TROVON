static ssize_t ds1682_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\n__le32 val = 0;\r\nint rc;\r\ndev_dbg(dev, "ds1682_show() called on %s\n", attr->attr.name);\r\nrc = i2c_smbus_read_i2c_block_data(client, sattr->index, sattr->nr,\r\n(u8 *) & val);\r\nif (rc < 0)\r\nreturn -EIO;\r\nif (sattr->nr == 4)\r\nreturn sprintf(buf, "%llu\n",\r\n((unsigned long long)le32_to_cpu(val)) * 250);\r\nreturn sprintf(buf, "%li\n", (long)le32_to_cpu(val));\r\n}\r\nstatic ssize_t ds1682_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nu64 val;\r\n__le32 val_le;\r\nint rc;\r\ndev_dbg(dev, "ds1682_store() called on %s\n", attr->attr.name);\r\nrc = kstrtoull(buf, 0, &val);\r\nif (rc < 0) {\r\ndev_dbg(dev, "input string not a number\n");\r\nreturn -EINVAL;\r\n}\r\nif (sattr->nr == 4)\r\ndo_div(val, 250);\r\nval_le = cpu_to_le32(val);\r\nrc = i2c_smbus_write_i2c_block_data(client, sattr->index, sattr->nr,\r\n(u8 *) & val_le);\r\nif (rc < 0) {\r\ndev_err(dev, "register write failed; reg=0x%x, size=%i\n",\r\nsattr->index, sattr->nr);\r\nreturn -EIO;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t ds1682_eeprom_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct i2c_client *client = kobj_to_i2c_client(kobj);\r\nint rc;\r\ndev_dbg(&client->dev, "ds1682_eeprom_read(p=%p, off=%lli, c=%zi)\n",\r\nbuf, off, count);\r\nrc = i2c_smbus_read_i2c_block_data(client, DS1682_REG_EEPROM + off,\r\ncount, buf);\r\nif (rc < 0)\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic ssize_t ds1682_eeprom_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct i2c_client *client = kobj_to_i2c_client(kobj);\r\ndev_dbg(&client->dev, "ds1682_eeprom_write(p=%p, off=%lli, c=%zi)\n",\r\nbuf, off, count);\r\nif (i2c_smbus_write_i2c_block_data(client, DS1682_REG_EEPROM + off,\r\ncount, buf) < 0)\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic int ds1682_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint rc;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_I2C_BLOCK)) {\r\ndev_err(&client->dev, "i2c bus does not support the ds1682\n");\r\nrc = -ENODEV;\r\ngoto exit;\r\n}\r\nrc = sysfs_create_group(&client->dev.kobj, &ds1682_group);\r\nif (rc)\r\ngoto exit;\r\nrc = sysfs_create_bin_file(&client->dev.kobj, &ds1682_eeprom_attr);\r\nif (rc)\r\ngoto exit_bin_attr;\r\nreturn 0;\r\nexit_bin_attr:\r\nsysfs_remove_group(&client->dev.kobj, &ds1682_group);\r\nexit:\r\nreturn rc;\r\n}\r\nstatic int ds1682_remove(struct i2c_client *client)\r\n{\r\nsysfs_remove_bin_file(&client->dev.kobj, &ds1682_eeprom_attr);\r\nsysfs_remove_group(&client->dev.kobj, &ds1682_group);\r\nreturn 0;\r\n}
