static int build_via_table(struct viadev *dev, struct snd_pcm_substream *substream,\r\nstruct pci_dev *pci,\r\nunsigned int periods, unsigned int fragsize)\r\n{\r\nunsigned int i, idx, ofs, rest;\r\nstruct via82xx *chip = snd_pcm_substream_chip(substream);\r\nif (dev->table.area == NULL) {\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),\r\nPAGE_ALIGN(VIA_TABLE_SIZE * 2 * 8),\r\n&dev->table) < 0)\r\nreturn -ENOMEM;\r\n}\r\nif (! dev->idx_table) {\r\ndev->idx_table = kmalloc(sizeof(*dev->idx_table) * VIA_TABLE_SIZE, GFP_KERNEL);\r\nif (! dev->idx_table)\r\nreturn -ENOMEM;\r\n}\r\nidx = 0;\r\nofs = 0;\r\nfor (i = 0; i < periods; i++) {\r\nrest = fragsize;\r\ndo {\r\nunsigned int r;\r\nunsigned int flag;\r\nunsigned int addr;\r\nif (idx >= VIA_TABLE_SIZE) {\r\ndev_err(&pci->dev, "too much table size!\n");\r\nreturn -EINVAL;\r\n}\r\naddr = snd_pcm_sgbuf_get_addr(substream, ofs);\r\n((u32 *)dev->table.area)[idx << 1] = cpu_to_le32(addr);\r\nr = snd_pcm_sgbuf_get_chunk_size(substream, ofs, rest);\r\nrest -= r;\r\nif (! rest) {\r\nif (i == periods - 1)\r\nflag = VIA_TBL_BIT_EOL;\r\nelse\r\nflag = VIA_TBL_BIT_FLAG;\r\n} else\r\nflag = 0;\r\n((u32 *)dev->table.area)[(idx<<1) + 1] = cpu_to_le32(r | flag);\r\ndev->idx_table[idx].offset = ofs;\r\ndev->idx_table[idx].size = r;\r\nofs += r;\r\nidx++;\r\n} while (rest > 0);\r\n}\r\ndev->tbl_entries = idx;\r\ndev->bufsize = periods * fragsize;\r\ndev->bufsize2 = dev->bufsize / 2;\r\ndev->fragsize = fragsize;\r\nreturn 0;\r\n}\r\nstatic int clean_via_table(struct viadev *dev, struct snd_pcm_substream *substream,\r\nstruct pci_dev *pci)\r\n{\r\nif (dev->table.area) {\r\nsnd_dma_free_pages(&dev->table);\r\ndev->table.area = NULL;\r\n}\r\nkfree(dev->idx_table);\r\ndev->idx_table = NULL;\r\nreturn 0;\r\n}\r\nstatic inline unsigned int snd_via82xx_codec_xread(struct via82xx *chip)\r\n{\r\nreturn inl(VIAREG(chip, AC97));\r\n}\r\nstatic inline void snd_via82xx_codec_xwrite(struct via82xx *chip, unsigned int val)\r\n{\r\noutl(val, VIAREG(chip, AC97));\r\n}\r\nstatic int snd_via82xx_codec_ready(struct via82xx *chip, int secondary)\r\n{\r\nunsigned int timeout = 1000;\r\nunsigned int val;\r\nwhile (timeout-- > 0) {\r\nudelay(1);\r\nif (!((val = snd_via82xx_codec_xread(chip)) & VIA_REG_AC97_BUSY))\r\nreturn val & 0xffff;\r\n}\r\ndev_err(chip->card->dev, "codec_ready: codec %i is not ready [0x%x]\n",\r\nsecondary, snd_via82xx_codec_xread(chip));\r\nreturn -EIO;\r\n}\r\nstatic int snd_via82xx_codec_valid(struct via82xx *chip, int secondary)\r\n{\r\nunsigned int timeout = 1000;\r\nunsigned int val, val1;\r\nunsigned int stat = !secondary ? VIA_REG_AC97_PRIMARY_VALID :\r\nVIA_REG_AC97_SECONDARY_VALID;\r\nwhile (timeout-- > 0) {\r\nval = snd_via82xx_codec_xread(chip);\r\nval1 = val & (VIA_REG_AC97_BUSY | stat);\r\nif (val1 == stat)\r\nreturn val & 0xffff;\r\nudelay(1);\r\n}\r\nreturn -EIO;\r\n}\r\nstatic void snd_via82xx_codec_wait(struct snd_ac97 *ac97)\r\n{\r\nstruct via82xx *chip = ac97->private_data;\r\nint err;\r\nerr = snd_via82xx_codec_ready(chip, ac97->num);\r\nif (!nodelay)\r\nmsleep(500);\r\n}\r\nstatic void snd_via82xx_codec_write(struct snd_ac97 *ac97,\r\nunsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct via82xx *chip = ac97->private_data;\r\nunsigned int xval;\r\nxval = !ac97->num ? VIA_REG_AC97_CODEC_ID_PRIMARY : VIA_REG_AC97_CODEC_ID_SECONDARY;\r\nxval <<= VIA_REG_AC97_CODEC_ID_SHIFT;\r\nxval |= reg << VIA_REG_AC97_CMD_SHIFT;\r\nxval |= val << VIA_REG_AC97_DATA_SHIFT;\r\nsnd_via82xx_codec_xwrite(chip, xval);\r\nsnd_via82xx_codec_ready(chip, ac97->num);\r\n}\r\nstatic unsigned short snd_via82xx_codec_read(struct snd_ac97 *ac97, unsigned short reg)\r\n{\r\nstruct via82xx *chip = ac97->private_data;\r\nunsigned int xval, val = 0xffff;\r\nint again = 0;\r\nxval = ac97->num << VIA_REG_AC97_CODEC_ID_SHIFT;\r\nxval |= ac97->num ? VIA_REG_AC97_SECONDARY_VALID : VIA_REG_AC97_PRIMARY_VALID;\r\nxval |= VIA_REG_AC97_READ;\r\nxval |= (reg & 0x7f) << VIA_REG_AC97_CMD_SHIFT;\r\nwhile (1) {\r\nif (again++ > 3) {\r\ndev_err(chip->card->dev,\r\n"codec_read: codec %i is not valid [0x%x]\n",\r\nac97->num, snd_via82xx_codec_xread(chip));\r\nreturn 0xffff;\r\n}\r\nsnd_via82xx_codec_xwrite(chip, xval);\r\nudelay (20);\r\nif (snd_via82xx_codec_valid(chip, ac97->num) >= 0) {\r\nudelay(25);\r\nval = snd_via82xx_codec_xread(chip);\r\nbreak;\r\n}\r\n}\r\nreturn val & 0xffff;\r\n}\r\nstatic void snd_via82xx_channel_reset(struct via82xx *chip, struct viadev *viadev)\r\n{\r\noutb(VIA_REG_CTRL_PAUSE | VIA_REG_CTRL_TERMINATE | VIA_REG_CTRL_RESET,\r\nVIADEV_REG(viadev, OFFSET_CONTROL));\r\ninb(VIADEV_REG(viadev, OFFSET_CONTROL));\r\nudelay(50);\r\noutb(0x00, VIADEV_REG(viadev, OFFSET_CONTROL));\r\noutb(0x03, VIADEV_REG(viadev, OFFSET_STATUS));\r\noutb(0x00, VIADEV_REG(viadev, OFFSET_TYPE));\r\nviadev->lastpos = 0;\r\nviadev->hwptr_done = 0;\r\n}\r\nstatic irqreturn_t snd_via686_interrupt(int irq, void *dev_id)\r\n{\r\nstruct via82xx *chip = dev_id;\r\nunsigned int status;\r\nunsigned int i;\r\nstatus = inl(VIAREG(chip, SGD_SHADOW));\r\nif (! (status & chip->intr_mask)) {\r\nif (chip->rmidi)\r\nreturn snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);\r\nreturn IRQ_NONE;\r\n}\r\nspin_lock(&chip->reg_lock);\r\nfor (i = 0; i < chip->num_devs; i++) {\r\nstruct viadev *viadev = &chip->devs[i];\r\nunsigned char c_status = inb(VIADEV_REG(viadev, OFFSET_STATUS));\r\nif (! (c_status & (VIA_REG_STAT_EOL|VIA_REG_STAT_FLAG|VIA_REG_STAT_STOPPED)))\r\ncontinue;\r\nif (viadev->substream && viadev->running) {\r\nif (c_status & VIA_REG_STAT_EOL)\r\nviadev->hwptr_done = 0;\r\nelse\r\nviadev->hwptr_done += viadev->fragsize;\r\nviadev->in_interrupt = c_status;\r\nspin_unlock(&chip->reg_lock);\r\nsnd_pcm_period_elapsed(viadev->substream);\r\nspin_lock(&chip->reg_lock);\r\nviadev->in_interrupt = 0;\r\n}\r\noutb(c_status, VIADEV_REG(viadev, OFFSET_STATUS));\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t snd_via8233_interrupt(int irq, void *dev_id)\r\n{\r\nstruct via82xx *chip = dev_id;\r\nunsigned int status;\r\nunsigned int i;\r\nint irqreturn = 0;\r\nspin_lock(&chip->reg_lock);\r\nstatus = inl(VIAREG(chip, SGD_SHADOW));\r\nfor (i = 0; i < chip->num_devs; i++) {\r\nstruct viadev *viadev = &chip->devs[i];\r\nstruct snd_pcm_substream *substream;\r\nunsigned char c_status, shadow_status;\r\nshadow_status = (status >> viadev->shadow_shift) &\r\n(VIA8233_SHADOW_STAT_ACTIVE|VIA_REG_STAT_EOL|\r\nVIA_REG_STAT_FLAG);\r\nc_status = shadow_status & (VIA_REG_STAT_EOL|VIA_REG_STAT_FLAG);\r\nif (!c_status)\r\ncontinue;\r\nsubstream = viadev->substream;\r\nif (substream && viadev->running) {\r\nif (c_status & VIA_REG_STAT_EOL)\r\nviadev->hwptr_done = 0;\r\nelse\r\nviadev->hwptr_done += viadev->fragsize;\r\nviadev->in_interrupt = c_status;\r\nif (shadow_status & VIA8233_SHADOW_STAT_ACTIVE)\r\nviadev->in_interrupt |= VIA_REG_STAT_ACTIVE;\r\nspin_unlock(&chip->reg_lock);\r\nsnd_pcm_period_elapsed(substream);\r\nspin_lock(&chip->reg_lock);\r\nviadev->in_interrupt = 0;\r\n}\r\noutb(c_status, VIADEV_REG(viadev, OFFSET_STATUS));\r\nirqreturn = 1;\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn IRQ_RETVAL(irqreturn);\r\n}\r\nstatic int snd_via82xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct via82xx *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = substream->runtime->private_data;\r\nunsigned char val;\r\nif (chip->chip_type != TYPE_VIA686)\r\nval = VIA_REG_CTRL_INT;\r\nelse\r\nval = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nval |= VIA_REG_CTRL_START;\r\nviadev->running = 1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nval = VIA_REG_CTRL_TERMINATE;\r\nviadev->running = 0;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nval |= VIA_REG_CTRL_PAUSE;\r\nviadev->running = 0;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nviadev->running = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\noutb(val, VIADEV_REG(viadev, OFFSET_CONTROL));\r\nif (cmd == SNDRV_PCM_TRIGGER_STOP)\r\nsnd_via82xx_channel_reset(chip, viadev);\r\nreturn 0;\r\n}\r\nstatic inline unsigned int calc_linear_pos(struct via82xx *chip,\r\nstruct viadev *viadev,\r\nunsigned int idx,\r\nunsigned int count)\r\n{\r\nunsigned int size, base, res;\r\nsize = viadev->idx_table[idx].size;\r\nbase = viadev->idx_table[idx].offset;\r\nres = base + size - count;\r\nif (res >= viadev->bufsize)\r\nres -= viadev->bufsize;\r\nif (size < count) {\r\ndev_dbg(chip->card->dev,\r\n"invalid via82xx_cur_ptr (size = %d, count = %d)\n",\r\n(int)size, (int)count);\r\nres = viadev->lastpos;\r\n} else {\r\nif (! count) {\r\nint delta = res - viadev->lastpos;\r\nif (delta < 0)\r\ndelta += viadev->bufsize;\r\nif ((unsigned int)delta > viadev->fragsize)\r\nres = base;\r\n}\r\nif (check_invalid_pos(viadev, res)) {\r\n#ifdef POINTER_DEBUG\r\ndev_dbg(chip->card->dev,\r\n"fail: idx = %i/%i, lastpos = 0x%x, bufsize2 = 0x%x, offsize = 0x%x, size = 0x%x, count = 0x%x\n",\r\nidx, viadev->tbl_entries,\r\nviadev->lastpos, viadev->bufsize2,\r\nviadev->idx_table[idx].offset,\r\nviadev->idx_table[idx].size, count);\r\n#endif\r\nres = base + size;\r\nif (check_invalid_pos(viadev, res)) {\r\ndev_dbg(chip->card->dev,\r\n"invalid via82xx_cur_ptr (2), using last valid pointer\n");\r\nres = viadev->lastpos;\r\n}\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic snd_pcm_uframes_t snd_via686_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct via82xx *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = substream->runtime->private_data;\r\nunsigned int idx, ptr, count, res;\r\nif (snd_BUG_ON(!viadev->tbl_entries))\r\nreturn 0;\r\nif (!(inb(VIADEV_REG(viadev, OFFSET_STATUS)) & VIA_REG_STAT_ACTIVE))\r\nreturn 0;\r\nspin_lock(&chip->reg_lock);\r\ncount = inl(VIADEV_REG(viadev, OFFSET_CURR_COUNT)) & 0xffffff;\r\nptr = inl(VIADEV_REG(viadev, OFFSET_CURR_PTR));\r\nif (ptr <= (unsigned int)viadev->table.addr)\r\nidx = 0;\r\nelse\r\nidx = ((ptr - (unsigned int)viadev->table.addr) / 8 - 1) % viadev->tbl_entries;\r\nres = calc_linear_pos(chip, viadev, idx, count);\r\nviadev->lastpos = res;\r\nspin_unlock(&chip->reg_lock);\r\nreturn bytes_to_frames(substream->runtime, res);\r\n}\r\nstatic snd_pcm_uframes_t snd_via8233_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct via82xx *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = substream->runtime->private_data;\r\nunsigned int idx, count, res;\r\nint status;\r\nif (snd_BUG_ON(!viadev->tbl_entries))\r\nreturn 0;\r\nspin_lock(&chip->reg_lock);\r\ncount = inl(VIADEV_REG(viadev, OFFSET_CURR_COUNT));\r\nstatus = viadev->in_interrupt;\r\nif (!status)\r\nstatus = inb(VIADEV_REG(viadev, OFFSET_STATUS));\r\nif (chip->revision == VIA_REV_8251 && (status & VIA_REG_STAT_EOL))\r\nsnd_via82xx_pcm_trigger(substream, SNDRV_PCM_TRIGGER_START);\r\nif (!(status & VIA_REG_STAT_ACTIVE)) {\r\nres = 0;\r\ngoto unlock;\r\n}\r\nif (count & 0xffffff) {\r\nidx = count >> 24;\r\nif (idx >= viadev->tbl_entries) {\r\n#ifdef POINTER_DEBUG\r\ndev_dbg(chip->card->dev,\r\n"fail: invalid idx = %i/%i\n", idx,\r\nviadev->tbl_entries);\r\n#endif\r\nres = viadev->lastpos;\r\n} else {\r\ncount &= 0xffffff;\r\nres = calc_linear_pos(chip, viadev, idx, count);\r\n}\r\n} else {\r\nres = viadev->hwptr_done;\r\nif (!viadev->in_interrupt) {\r\nif (status & VIA_REG_STAT_EOL) {\r\nres = 0;\r\n} else\r\nif (status & VIA_REG_STAT_FLAG) {\r\nres += viadev->fragsize;\r\n}\r\n}\r\n}\r\nunlock:\r\nviadev->lastpos = res;\r\nspin_unlock(&chip->reg_lock);\r\nreturn bytes_to_frames(substream->runtime, res);\r\n}\r\nstatic int snd_via82xx_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct via82xx *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = substream->runtime->private_data;\r\nint err;\r\nerr = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nerr = build_via_table(viadev, substream, chip->pci,\r\nparams_periods(hw_params),\r\nparams_period_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_via82xx_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct via82xx *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = substream->runtime->private_data;\r\nclean_via_table(viadev, substream, chip->pci);\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic void snd_via82xx_set_table_ptr(struct via82xx *chip, struct viadev *viadev)\r\n{\r\nsnd_via82xx_codec_ready(chip, 0);\r\noutl((u32)viadev->table.addr, VIADEV_REG(viadev, OFFSET_TABLE_PTR));\r\nudelay(20);\r\nsnd_via82xx_codec_ready(chip, 0);\r\n}\r\nstatic void via686_setup_format(struct via82xx *chip, struct viadev *viadev,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nsnd_via82xx_channel_reset(chip, viadev);\r\nsnd_via82xx_set_table_ptr(chip, viadev);\r\noutb(VIA_REG_TYPE_AUTOSTART |\r\n(runtime->format == SNDRV_PCM_FORMAT_S16_LE ? VIA_REG_TYPE_16BIT : 0) |\r\n(runtime->channels > 1 ? VIA_REG_TYPE_STEREO : 0) |\r\n((viadev->reg_offset & 0x10) == 0 ? VIA_REG_TYPE_INT_LSAMPLE : 0) |\r\nVIA_REG_TYPE_INT_EOL |\r\nVIA_REG_TYPE_INT_FLAG, VIADEV_REG(viadev, OFFSET_TYPE));\r\n}\r\nstatic int snd_via686_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct via82xx *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = substream->runtime->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_ac97_set_rate(chip->ac97, AC97_PCM_FRONT_DAC_RATE, runtime->rate);\r\nsnd_ac97_set_rate(chip->ac97, AC97_SPDIF, runtime->rate);\r\nvia686_setup_format(chip, viadev, runtime);\r\nreturn 0;\r\n}\r\nstatic int snd_via686_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct via82xx *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = substream->runtime->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_ac97_set_rate(chip->ac97, AC97_PCM_LR_ADC_RATE, runtime->rate);\r\nvia686_setup_format(chip, viadev, runtime);\r\nreturn 0;\r\n}\r\nstatic int via_lock_rate(struct via_rate_lock *rec, int rate)\r\n{\r\nint changed = 0;\r\nspin_lock_irq(&rec->lock);\r\nif (rec->rate != rate) {\r\nif (rec->rate && rec->used > 1)\r\nchanged = -EINVAL;\r\nelse {\r\nrec->rate = rate;\r\nchanged = 1;\r\n}\r\n}\r\nspin_unlock_irq(&rec->lock);\r\nreturn changed;\r\n}\r\nstatic int snd_via8233_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct via82xx *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = substream->runtime->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint ac97_rate = chip->dxs_src ? 48000 : runtime->rate;\r\nint rate_changed;\r\nu32 rbits;\r\nif ((rate_changed = via_lock_rate(&chip->rates[0], ac97_rate)) < 0)\r\nreturn rate_changed;\r\nif (rate_changed)\r\nsnd_ac97_set_rate(chip->ac97, AC97_PCM_FRONT_DAC_RATE,\r\nchip->no_vra ? 48000 : runtime->rate);\r\nif (chip->spdif_on && viadev->reg_offset == 0x30)\r\nsnd_ac97_set_rate(chip->ac97, AC97_SPDIF, runtime->rate);\r\nif (runtime->rate == 48000)\r\nrbits = 0xfffff;\r\nelse\r\nrbits = (0x100000 / 48000) * runtime->rate +\r\n((0x100000 % 48000) * runtime->rate) / 48000;\r\nsnd_BUG_ON(rbits & ~0xfffff);\r\nsnd_via82xx_channel_reset(chip, viadev);\r\nsnd_via82xx_set_table_ptr(chip, viadev);\r\noutb(chip->playback_volume[viadev->reg_offset / 0x10][0],\r\nVIADEV_REG(viadev, OFS_PLAYBACK_VOLUME_L));\r\noutb(chip->playback_volume[viadev->reg_offset / 0x10][1],\r\nVIADEV_REG(viadev, OFS_PLAYBACK_VOLUME_R));\r\noutl((runtime->format == SNDRV_PCM_FORMAT_S16_LE ? VIA8233_REG_TYPE_16BIT : 0) |\r\n(runtime->channels > 1 ? VIA8233_REG_TYPE_STEREO : 0) |\r\nrbits |\r\n0xff000000,\r\nVIADEV_REG(viadev, OFFSET_STOP_IDX));\r\nudelay(20);\r\nsnd_via82xx_codec_ready(chip, 0);\r\nreturn 0;\r\n}\r\nstatic int snd_via8233_multi_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct via82xx *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = substream->runtime->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int slots;\r\nint fmt;\r\nif (via_lock_rate(&chip->rates[0], runtime->rate) < 0)\r\nreturn -EINVAL;\r\nsnd_ac97_set_rate(chip->ac97, AC97_PCM_FRONT_DAC_RATE, runtime->rate);\r\nsnd_ac97_set_rate(chip->ac97, AC97_PCM_SURR_DAC_RATE, runtime->rate);\r\nsnd_ac97_set_rate(chip->ac97, AC97_PCM_LFE_DAC_RATE, runtime->rate);\r\nsnd_ac97_set_rate(chip->ac97, AC97_SPDIF, runtime->rate);\r\nsnd_via82xx_channel_reset(chip, viadev);\r\nsnd_via82xx_set_table_ptr(chip, viadev);\r\nfmt = (runtime->format == SNDRV_PCM_FORMAT_S16_LE) ?\r\nVIA_REG_MULTPLAY_FMT_16BIT : VIA_REG_MULTPLAY_FMT_8BIT;\r\nfmt |= runtime->channels << 4;\r\noutb(fmt, VIADEV_REG(viadev, OFS_MULTPLAY_FORMAT));\r\n#if 0\r\nif (chip->revision == VIA_REV_8233A)\r\nslots = 0;\r\nelse\r\n#endif\r\n{\r\nswitch (runtime->channels) {\r\ncase 1: slots = (1<<0) | (1<<4); break;\r\ncase 2: slots = (1<<0) | (2<<4); break;\r\ncase 3: slots = (1<<0) | (2<<4) | (5<<8); break;\r\ncase 4: slots = (1<<0) | (2<<4) | (3<<8) | (4<<12); break;\r\ncase 5: slots = (1<<0) | (2<<4) | (3<<8) | (4<<12) | (5<<16); break;\r\ncase 6: slots = (1<<0) | (2<<4) | (3<<8) | (4<<12) | (5<<16) | (6<<20); break;\r\ndefault: slots = 0; break;\r\n}\r\n}\r\noutl(0xff000000 | slots, VIADEV_REG(viadev, OFFSET_STOP_IDX));\r\nudelay(20);\r\nsnd_via82xx_codec_ready(chip, 0);\r\nreturn 0;\r\n}\r\nstatic int snd_via8233_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct via82xx *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = substream->runtime->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (via_lock_rate(&chip->rates[1], runtime->rate) < 0)\r\nreturn -EINVAL;\r\nsnd_ac97_set_rate(chip->ac97, AC97_PCM_LR_ADC_RATE, runtime->rate);\r\nsnd_via82xx_channel_reset(chip, viadev);\r\nsnd_via82xx_set_table_ptr(chip, viadev);\r\noutb(VIA_REG_CAPTURE_FIFO_ENABLE, VIADEV_REG(viadev, OFS_CAPTURE_FIFO));\r\noutl((runtime->format == SNDRV_PCM_FORMAT_S16_LE ? VIA8233_REG_TYPE_16BIT : 0) |\r\n(runtime->channels > 1 ? VIA8233_REG_TYPE_STEREO : 0) |\r\n0xff000000,\r\nVIADEV_REG(viadev, OFFSET_STOP_IDX));\r\nudelay(20);\r\nsnd_via82xx_codec_ready(chip, 0);\r\nreturn 0;\r\n}\r\nstatic int snd_via82xx_pcm_open(struct via82xx *chip, struct viadev *viadev,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nstruct via_rate_lock *ratep;\r\nbool use_src = false;\r\nruntime->hw = snd_via82xx_hw;\r\nratep = &chip->rates[viadev->direction];\r\nspin_lock_irq(&ratep->lock);\r\nratep->used++;\r\nif (chip->spdif_on && viadev->reg_offset == 0x30) {\r\nruntime->hw.rates = chip->ac97->rates[AC97_RATES_SPDIF];\r\nsnd_pcm_limit_hw_rates(runtime);\r\n} else if (chip->dxs_fixed && viadev->reg_offset < 0x40) {\r\nruntime->hw.rates = SNDRV_PCM_RATE_48000;\r\nruntime->hw.rate_min = runtime->hw.rate_max = 48000;\r\n} else if (chip->dxs_src && viadev->reg_offset < 0x40) {\r\nruntime->hw.rates = (SNDRV_PCM_RATE_CONTINUOUS |\r\nSNDRV_PCM_RATE_8000_48000);\r\nruntime->hw.rate_min = 8000;\r\nruntime->hw.rate_max = 48000;\r\nuse_src = true;\r\n} else if (! ratep->rate) {\r\nint idx = viadev->direction ? AC97_RATES_ADC : AC97_RATES_FRONT_DAC;\r\nruntime->hw.rates = chip->ac97->rates[idx];\r\nsnd_pcm_limit_hw_rates(runtime);\r\n} else {\r\nruntime->hw.rates = SNDRV_PCM_RATE_KNOT;\r\nruntime->hw.rate_max = runtime->hw.rate_min = ratep->rate;\r\n}\r\nspin_unlock_irq(&ratep->lock);\r\nif ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)\r\nreturn err;\r\nif (use_src) {\r\nerr = snd_pcm_hw_rule_noresample(runtime, 48000);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nruntime->private_data = viadev;\r\nviadev->substream = substream;\r\nreturn 0;\r\n}\r\nstatic int snd_via686_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct via82xx *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = &chip->devs[chip->playback_devno + substream->number];\r\nint err;\r\nif ((err = snd_via82xx_pcm_open(chip, viadev, substream)) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_via8233_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct via82xx *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev;\r\nunsigned int stream;\r\nint err;\r\nviadev = &chip->devs[chip->playback_devno + substream->number];\r\nif ((err = snd_via82xx_pcm_open(chip, viadev, substream)) < 0)\r\nreturn err;\r\nstream = viadev->reg_offset / 0x10;\r\nif (chip->dxs_controls[stream]) {\r\nchip->playback_volume[stream][0] =\r\nVIA_DXS_MAX_VOLUME - (dxs_init_volume & 31);\r\nchip->playback_volume[stream][1] =\r\nVIA_DXS_MAX_VOLUME - (dxs_init_volume & 31);\r\nchip->dxs_controls[stream]->vd[0].access &=\r\n~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO,\r\n&chip->dxs_controls[stream]->id);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_via8233_multi_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct via82xx *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = &chip->devs[chip->multi_devno];\r\nint err;\r\nstatic unsigned int channels[] = {\r\n1, 2, 4, 6\r\n};\r\nstatic struct snd_pcm_hw_constraint_list hw_constraints_channels = {\r\n.count = ARRAY_SIZE(channels),\r\n.list = channels,\r\n.mask = 0,\r\n};\r\nif ((err = snd_via82xx_pcm_open(chip, viadev, substream)) < 0)\r\nreturn err;\r\nsubstream->runtime->hw.channels_max = 6;\r\nif (chip->revision == VIA_REV_8233A)\r\nsnd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\n&hw_constraints_channels);\r\nreturn 0;\r\n}\r\nstatic int snd_via82xx_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct via82xx *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = &chip->devs[chip->capture_devno + substream->pcm->device];\r\nreturn snd_via82xx_pcm_open(chip, viadev, substream);\r\n}\r\nstatic int snd_via82xx_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct via82xx *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = substream->runtime->private_data;\r\nstruct via_rate_lock *ratep;\r\nratep = &chip->rates[viadev->direction];\r\nspin_lock_irq(&ratep->lock);\r\nratep->used--;\r\nif (! ratep->used)\r\nratep->rate = 0;\r\nspin_unlock_irq(&ratep->lock);\r\nif (! ratep->rate) {\r\nif (! viadev->direction) {\r\nsnd_ac97_update_power(chip->ac97,\r\nAC97_PCM_FRONT_DAC_RATE, 0);\r\nsnd_ac97_update_power(chip->ac97,\r\nAC97_PCM_SURR_DAC_RATE, 0);\r\nsnd_ac97_update_power(chip->ac97,\r\nAC97_PCM_LFE_DAC_RATE, 0);\r\n} else\r\nsnd_ac97_update_power(chip->ac97,\r\nAC97_PCM_LR_ADC_RATE, 0);\r\n}\r\nviadev->substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_via8233_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct via82xx *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = substream->runtime->private_data;\r\nunsigned int stream;\r\nstream = viadev->reg_offset / 0x10;\r\nif (chip->dxs_controls[stream]) {\r\nchip->dxs_controls[stream]->vd[0].access |=\r\nSNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_INFO,\r\n&chip->dxs_controls[stream]->id);\r\n}\r\nreturn snd_via82xx_pcm_close(substream);\r\n}\r\nstatic void init_viadev(struct via82xx *chip, int idx, unsigned int reg_offset,\r\nint shadow_pos, int direction)\r\n{\r\nchip->devs[idx].reg_offset = reg_offset;\r\nchip->devs[idx].shadow_shift = shadow_pos * 4;\r\nchip->devs[idx].direction = direction;\r\nchip->devs[idx].port = chip->port + reg_offset;\r\n}\r\nstatic int snd_via8233_pcm_new(struct via82xx *chip)\r\n{\r\nstruct snd_pcm *pcm;\r\nstruct snd_pcm_chmap *chmap;\r\nint i, err;\r\nchip->playback_devno = 0;\r\nchip->multi_devno = 4;\r\nchip->capture_devno = 5;\r\nchip->num_devs = 7;\r\nchip->intr_mask = 0x33033333;\r\nerr = snd_pcm_new(chip->card, chip->card->shortname, 0, 4, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_via8233_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_via8233_capture_ops);\r\npcm->private_data = chip;\r\nstrcpy(pcm->name, chip->card->shortname);\r\nchip->pcms[0] = pcm;\r\nfor (i = 0; i < 4; i++)\r\ninit_viadev(chip, i, 0x10 * i, i, 0);\r\ninit_viadev(chip, chip->capture_devno, VIA_REG_CAPTURE_8233_STATUS, 6, 1);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\r\nsnd_dma_pci_data(chip->pci),\r\n64*1024, VIA_MAX_BUFSIZE);\r\nerr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\nsnd_pcm_std_chmaps, 2, 0,\r\n&chmap);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_new(chip->card, chip->card->shortname, 1, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_via8233_multi_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_via8233_capture_ops);\r\npcm->private_data = chip;\r\nstrcpy(pcm->name, chip->card->shortname);\r\nchip->pcms[1] = pcm;\r\ninit_viadev(chip, chip->multi_devno, VIA_REG_MULTPLAY_STATUS, 4, 0);\r\ninit_viadev(chip, chip->capture_devno + 1, VIA_REG_CAPTURE_8233_STATUS + 0x10, 7, 1);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\r\nsnd_dma_pci_data(chip->pci),\r\n64*1024, VIA_MAX_BUFSIZE);\r\nerr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\nsnd_pcm_alt_chmaps, 6, 0,\r\n&chmap);\r\nif (err < 0)\r\nreturn err;\r\nchip->ac97->chmaps[SNDRV_PCM_STREAM_PLAYBACK] = chmap;\r\nreturn 0;\r\n}\r\nstatic int snd_via8233a_pcm_new(struct via82xx *chip)\r\n{\r\nstruct snd_pcm *pcm;\r\nstruct snd_pcm_chmap *chmap;\r\nint err;\r\nchip->multi_devno = 0;\r\nchip->playback_devno = 1;\r\nchip->capture_devno = 2;\r\nchip->num_devs = 3;\r\nchip->intr_mask = 0x03033000;\r\nerr = snd_pcm_new(chip->card, chip->card->shortname, 0, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_via8233_multi_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_via8233_capture_ops);\r\npcm->private_data = chip;\r\nstrcpy(pcm->name, chip->card->shortname);\r\nchip->pcms[0] = pcm;\r\ninit_viadev(chip, chip->multi_devno, VIA_REG_MULTPLAY_STATUS, 4, 0);\r\ninit_viadev(chip, chip->capture_devno, VIA_REG_CAPTURE_8233_STATUS, 6, 1);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\r\nsnd_dma_pci_data(chip->pci),\r\n64*1024, VIA_MAX_BUFSIZE);\r\nerr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\nsnd_pcm_alt_chmaps, 6, 0,\r\n&chmap);\r\nif (err < 0)\r\nreturn err;\r\nchip->ac97->chmaps[SNDRV_PCM_STREAM_PLAYBACK] = chmap;\r\nif (! ac97_can_spdif(chip->ac97))\r\nreturn 0;\r\nerr = snd_pcm_new(chip->card, chip->card->shortname, 1, 1, 0, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_via8233_playback_ops);\r\npcm->private_data = chip;\r\nstrcpy(pcm->name, chip->card->shortname);\r\nchip->pcms[1] = pcm;\r\ninit_viadev(chip, chip->playback_devno, 0x30, 3, 0);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\r\nsnd_dma_pci_data(chip->pci),\r\n64*1024, VIA_MAX_BUFSIZE);\r\nreturn 0;\r\n}\r\nstatic int snd_via686_pcm_new(struct via82xx *chip)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nchip->playback_devno = 0;\r\nchip->capture_devno = 1;\r\nchip->num_devs = 2;\r\nchip->intr_mask = 0x77;\r\nerr = snd_pcm_new(chip->card, chip->card->shortname, 0, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_via686_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_via686_capture_ops);\r\npcm->private_data = chip;\r\nstrcpy(pcm->name, chip->card->shortname);\r\nchip->pcms[0] = pcm;\r\ninit_viadev(chip, 0, VIA_REG_PLAYBACK_STATUS, 0, 0);\r\ninit_viadev(chip, 1, VIA_REG_CAPTURE_STATUS, 0, 1);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\r\nsnd_dma_pci_data(chip->pci),\r\n64*1024, VIA_MAX_BUFSIZE);\r\nreturn 0;\r\n}\r\nstatic int snd_via8233_capture_source_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[2] = {\r\n"Input1", "Input2"\r\n};\r\nreturn snd_ctl_enum_info(uinfo, 1, 2, texts);\r\n}\r\nstatic int snd_via8233_capture_source_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct via82xx *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long port = chip->port + (kcontrol->id.index ? (VIA_REG_CAPTURE_CHANNEL + 0x10) : VIA_REG_CAPTURE_CHANNEL);\r\nucontrol->value.enumerated.item[0] = inb(port) & VIA_REG_CAPTURE_CHANNEL_MIC ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int snd_via8233_capture_source_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct via82xx *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long port = chip->port + (kcontrol->id.index ? (VIA_REG_CAPTURE_CHANNEL + 0x10) : VIA_REG_CAPTURE_CHANNEL);\r\nu8 val, oval;\r\nspin_lock_irq(&chip->reg_lock);\r\noval = inb(port);\r\nval = oval & ~VIA_REG_CAPTURE_CHANNEL_MIC;\r\nif (ucontrol->value.enumerated.item[0])\r\nval |= VIA_REG_CAPTURE_CHANNEL_MIC;\r\nif (val != oval)\r\noutb(val, port);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn val != oval;\r\n}\r\nstatic int snd_via8233_dxs3_spdif_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct via82xx *chip = snd_kcontrol_chip(kcontrol);\r\nu8 val;\r\npci_read_config_byte(chip->pci, VIA8233_SPDIF_CTRL, &val);\r\nucontrol->value.integer.value[0] = (val & VIA8233_SPDIF_DX3) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int snd_via8233_dxs3_spdif_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct via82xx *chip = snd_kcontrol_chip(kcontrol);\r\nu8 val, oval;\r\npci_read_config_byte(chip->pci, VIA8233_SPDIF_CTRL, &oval);\r\nval = oval & ~VIA8233_SPDIF_DX3;\r\nif (ucontrol->value.integer.value[0])\r\nval |= VIA8233_SPDIF_DX3;\r\nchip->spdif_on = ucontrol->value.integer.value[0] ? 1 : 0;\r\nif (val != oval) {\r\npci_write_config_byte(chip->pci, VIA8233_SPDIF_CTRL, val);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_via8233_dxs_volume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = VIA_DXS_MAX_VOLUME;\r\nreturn 0;\r\n}\r\nstatic int snd_via8233_dxs_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct via82xx *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int idx = kcontrol->id.subdevice;\r\nucontrol->value.integer.value[0] = VIA_DXS_MAX_VOLUME - chip->playback_volume[idx][0];\r\nucontrol->value.integer.value[1] = VIA_DXS_MAX_VOLUME - chip->playback_volume[idx][1];\r\nreturn 0;\r\n}\r\nstatic int snd_via8233_pcmdxs_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct via82xx *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = VIA_DXS_MAX_VOLUME - chip->playback_volume_c[0];\r\nucontrol->value.integer.value[1] = VIA_DXS_MAX_VOLUME - chip->playback_volume_c[1];\r\nreturn 0;\r\n}\r\nstatic int snd_via8233_dxs_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct via82xx *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int idx = kcontrol->id.subdevice;\r\nunsigned long port = chip->port + 0x10 * idx;\r\nunsigned char val;\r\nint i, change = 0;\r\nfor (i = 0; i < 2; i++) {\r\nval = ucontrol->value.integer.value[i];\r\nif (val > VIA_DXS_MAX_VOLUME)\r\nval = VIA_DXS_MAX_VOLUME;\r\nval = VIA_DXS_MAX_VOLUME - val;\r\nchange |= val != chip->playback_volume[idx][i];\r\nif (change) {\r\nchip->playback_volume[idx][i] = val;\r\noutb(val, port + VIA_REG_OFS_PLAYBACK_VOLUME_L + i);\r\n}\r\n}\r\nreturn change;\r\n}\r\nstatic int snd_via8233_pcmdxs_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct via82xx *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int idx;\r\nunsigned char val;\r\nint i, change = 0;\r\nfor (i = 0; i < 2; i++) {\r\nval = ucontrol->value.integer.value[i];\r\nif (val > VIA_DXS_MAX_VOLUME)\r\nval = VIA_DXS_MAX_VOLUME;\r\nval = VIA_DXS_MAX_VOLUME - val;\r\nif (val != chip->playback_volume_c[i]) {\r\nchange = 1;\r\nchip->playback_volume_c[i] = val;\r\nfor (idx = 0; idx < 4; idx++) {\r\nunsigned long port = chip->port + 0x10 * idx;\r\nchip->playback_volume[idx][i] = val;\r\noutb(val, port + VIA_REG_OFS_PLAYBACK_VOLUME_L + i);\r\n}\r\n}\r\n}\r\nreturn change;\r\n}\r\nstatic void snd_via82xx_mixer_free_ac97_bus(struct snd_ac97_bus *bus)\r\n{\r\nstruct via82xx *chip = bus->private_data;\r\nchip->ac97_bus = NULL;\r\n}\r\nstatic void snd_via82xx_mixer_free_ac97(struct snd_ac97 *ac97)\r\n{\r\nstruct via82xx *chip = ac97->private_data;\r\nchip->ac97 = NULL;\r\n}\r\nstatic int snd_via82xx_mixer_new(struct via82xx *chip, const char *quirk_override)\r\n{\r\nstruct snd_ac97_template ac97;\r\nint err;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_via82xx_codec_write,\r\n.read = snd_via82xx_codec_read,\r\n.wait = snd_via82xx_codec_wait,\r\n};\r\nif ((err = snd_ac97_bus(chip->card, 0, &ops, chip, &chip->ac97_bus)) < 0)\r\nreturn err;\r\nchip->ac97_bus->private_free = snd_via82xx_mixer_free_ac97_bus;\r\nchip->ac97_bus->clock = chip->ac97_clock;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = chip;\r\nac97.private_free = snd_via82xx_mixer_free_ac97;\r\nac97.pci = chip->pci;\r\nac97.scaps = AC97_SCAP_SKIP_MODEM | AC97_SCAP_POWER_SAVE;\r\nif ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97)) < 0)\r\nreturn err;\r\nsnd_ac97_tune_hardware(chip->ac97, ac97_quirks, quirk_override);\r\nif (chip->chip_type != TYPE_VIA686) {\r\nsnd_ac97_update_bits(chip->ac97, AC97_EXTENDED_STATUS, 0x03 << 4, 0x03 << 4);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_via686_create_gameport(struct via82xx *chip, unsigned char *legacy)\r\n{\r\nstruct gameport *gp;\r\nstruct resource *r;\r\nif (!joystick)\r\nreturn -ENODEV;\r\nr = request_region(JOYSTICK_ADDR, 8, "VIA686 gameport");\r\nif (!r) {\r\ndev_warn(chip->card->dev, "cannot reserve joystick port %#x\n",\r\nJOYSTICK_ADDR);\r\nreturn -EBUSY;\r\n}\r\nchip->gameport = gp = gameport_allocate_port();\r\nif (!gp) {\r\ndev_err(chip->card->dev,\r\n"cannot allocate memory for gameport\n");\r\nrelease_and_free_resource(r);\r\nreturn -ENOMEM;\r\n}\r\ngameport_set_name(gp, "VIA686 Gameport");\r\ngameport_set_phys(gp, "pci%s/gameport0", pci_name(chip->pci));\r\ngameport_set_dev_parent(gp, &chip->pci->dev);\r\ngp->io = JOYSTICK_ADDR;\r\ngameport_set_port_data(gp, r);\r\n*legacy |= VIA_FUNC_ENABLE_GAME;\r\npci_write_config_byte(chip->pci, VIA_FUNC_ENABLE, *legacy);\r\ngameport_register_port(chip->gameport);\r\nreturn 0;\r\n}\r\nstatic void snd_via686_free_gameport(struct via82xx *chip)\r\n{\r\nif (chip->gameport) {\r\nstruct resource *r = gameport_get_port_data(chip->gameport);\r\ngameport_unregister_port(chip->gameport);\r\nchip->gameport = NULL;\r\nrelease_and_free_resource(r);\r\n}\r\n}\r\nstatic inline int snd_via686_create_gameport(struct via82xx *chip, unsigned char *legacy)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic inline void snd_via686_free_gameport(struct via82xx *chip) { }\r\nstatic int snd_via8233_init_misc(struct via82xx *chip)\r\n{\r\nint i, err, caps;\r\nunsigned char val;\r\ncaps = chip->chip_type == TYPE_VIA8233A ? 1 : 2;\r\nfor (i = 0; i < caps; i++) {\r\nsnd_via8233_capture_source.index = i;\r\nerr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_via8233_capture_source, chip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (ac97_can_spdif(chip->ac97)) {\r\nerr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_via8233_dxs3_spdif_control, chip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (chip->chip_type != TYPE_VIA8233A) {\r\nstruct snd_ctl_elem_id sid;\r\nmemset(&sid, 0, sizeof(sid));\r\nstrcpy(sid.name, "PCM Playback Volume");\r\nsid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nif (! snd_ctl_find_id(chip->card, &sid)) {\r\ndev_info(chip->card->dev,\r\n"Using DXS as PCM Playback\n");\r\nerr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_via8233_pcmdxs_volume_control, chip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nelse\r\n{\r\nfor (i = 0; i < 4; ++i) {\r\nstruct snd_kcontrol *kctl;\r\nkctl = snd_ctl_new1(\r\n&snd_via8233_dxs_volume_control, chip);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nkctl->id.subdevice = i;\r\nerr = snd_ctl_add(chip->card, kctl);\r\nif (err < 0)\r\nreturn err;\r\nchip->dxs_controls[i] = kctl;\r\n}\r\n}\r\n}\r\npci_read_config_byte(chip->pci, VIA8233_SPDIF_CTRL, &val);\r\nval = (val & ~VIA8233_SPDIF_SLOT_MASK) | VIA8233_SPDIF_SLOT_1011;\r\nval &= ~VIA8233_SPDIF_DX3;\r\npci_write_config_byte(chip->pci, VIA8233_SPDIF_CTRL, val);\r\nreturn 0;\r\n}\r\nstatic int snd_via686_init_misc(struct via82xx *chip)\r\n{\r\nunsigned char legacy, legacy_cfg;\r\nint rev_h = 0;\r\nlegacy = chip->old_legacy;\r\nlegacy_cfg = chip->old_legacy_cfg;\r\nlegacy |= VIA_FUNC_MIDI_IRQMASK;\r\nlegacy &= ~VIA_FUNC_ENABLE_GAME;\r\nif (chip->revision >= VIA_REV_686_H) {\r\nrev_h = 1;\r\nif (mpu_port >= 0x200) {\r\nmpu_port &= 0xfffc;\r\npci_write_config_dword(chip->pci, 0x18, mpu_port | 0x01);\r\n#ifdef CONFIG_PM_SLEEP\r\nchip->mpu_port_saved = mpu_port;\r\n#endif\r\n} else {\r\nmpu_port = pci_resource_start(chip->pci, 2);\r\n}\r\n} else {\r\nswitch (mpu_port) {\r\ncase 0x300:\r\ncase 0x310:\r\ncase 0x320:\r\ncase 0x330:\r\nlegacy_cfg &= ~(3 << 2);\r\nlegacy_cfg |= (mpu_port & 0x0030) >> 2;\r\nbreak;\r\ndefault:\r\nif (legacy & VIA_FUNC_ENABLE_MIDI)\r\nmpu_port = 0x300 + ((legacy_cfg & 0x000c) << 2);\r\nbreak;\r\n}\r\n}\r\nif (mpu_port >= 0x200 &&\r\n(chip->mpu_res = request_region(mpu_port, 2, "VIA82xx MPU401"))\r\n!= NULL) {\r\nif (rev_h)\r\nlegacy |= VIA_FUNC_MIDI_PNP;\r\nlegacy |= VIA_FUNC_ENABLE_MIDI;\r\n} else {\r\nif (rev_h)\r\nlegacy &= ~VIA_FUNC_MIDI_PNP;\r\nlegacy &= ~VIA_FUNC_ENABLE_MIDI;\r\nmpu_port = 0;\r\n}\r\npci_write_config_byte(chip->pci, VIA_FUNC_ENABLE, legacy);\r\npci_write_config_byte(chip->pci, VIA_PNP_CONTROL, legacy_cfg);\r\nif (chip->mpu_res) {\r\nif (snd_mpu401_uart_new(chip->card, 0, MPU401_HW_VIA686A,\r\nmpu_port, MPU401_INFO_INTEGRATED |\r\nMPU401_INFO_IRQ_HOOK, -1,\r\n&chip->rmidi) < 0) {\r\ndev_warn(chip->card->dev,\r\n"unable to initialize MPU-401 at 0x%lx, skipping\n",\r\nmpu_port);\r\nlegacy &= ~VIA_FUNC_ENABLE_MIDI;\r\n} else {\r\nlegacy &= ~VIA_FUNC_MIDI_IRQMASK;\r\n}\r\npci_write_config_byte(chip->pci, VIA_FUNC_ENABLE, legacy);\r\n}\r\nsnd_via686_create_gameport(chip, &legacy);\r\n#ifdef CONFIG_PM_SLEEP\r\nchip->legacy_saved = legacy;\r\nchip->legacy_cfg_saved = legacy_cfg;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void snd_via82xx_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct via82xx *chip = entry->private_data;\r\nint i;\r\nsnd_iprintf(buffer, "%s\n\n", chip->card->longname);\r\nfor (i = 0; i < 0xa0; i += 4) {\r\nsnd_iprintf(buffer, "%02x: %08x\n", i, inl(chip->port + i));\r\n}\r\n}\r\nstatic void snd_via82xx_proc_init(struct via82xx *chip)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (! snd_card_proc_new(chip->card, "via82xx", &entry))\r\nsnd_info_set_text_ops(entry, chip, snd_via82xx_proc_read);\r\n}\r\nstatic int snd_via82xx_chip_init(struct via82xx *chip)\r\n{\r\nunsigned int val;\r\nunsigned long end_time;\r\nunsigned char pval;\r\n#if 0\r\nif (chip->chip_type == TYPE_VIA686)\r\npci_write_config_byte(chip->pci, VIA_FUNC_ENABLE, 0);\r\n#endif\r\npci_read_config_byte(chip->pci, VIA_ACLINK_STAT, &pval);\r\nif (! (pval & VIA_ACLINK_C00_READY)) {\r\npci_write_config_byte(chip->pci, VIA_ACLINK_CTRL,\r\nVIA_ACLINK_CTRL_ENABLE |\r\nVIA_ACLINK_CTRL_RESET |\r\nVIA_ACLINK_CTRL_SYNC);\r\nudelay(100);\r\n#if 1\r\npci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, 0x00);\r\nudelay(100);\r\n#else\r\npci_write_config_byte(chip->pci, VIA_ACLINK_CTRL,\r\nVIA_ACLINK_CTRL_RESET|VIA_ACLINK_CTRL_SYNC);\r\nudelay(2);\r\n#endif\r\npci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, VIA_ACLINK_CTRL_INIT);\r\nudelay(100);\r\n}\r\npci_read_config_byte(chip->pci, VIA_ACLINK_CTRL, &pval);\r\nif ((pval & VIA_ACLINK_CTRL_INIT) != VIA_ACLINK_CTRL_INIT) {\r\npci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, VIA_ACLINK_CTRL_INIT);\r\nudelay(100);\r\n}\r\nend_time = jiffies + msecs_to_jiffies(750);\r\ndo {\r\npci_read_config_byte(chip->pci, VIA_ACLINK_STAT, &pval);\r\nif (pval & VIA_ACLINK_C00_READY)\r\nbreak;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_before(jiffies, end_time));\r\nif ((val = snd_via82xx_codec_xread(chip)) & VIA_REG_AC97_BUSY)\r\ndev_err(chip->card->dev,\r\n"AC'97 codec is not ready [0x%x]\n", val);\r\n#if 0\r\nsnd_via82xx_codec_xwrite(chip, VIA_REG_AC97_READ |\r\nVIA_REG_AC97_SECONDARY_VALID |\r\n(VIA_REG_AC97_CODEC_ID_SECONDARY << VIA_REG_AC97_CODEC_ID_SHIFT));\r\nend_time = jiffies + msecs_to_jiffies(750);\r\nsnd_via82xx_codec_xwrite(chip, VIA_REG_AC97_READ |\r\nVIA_REG_AC97_SECONDARY_VALID |\r\n(VIA_REG_AC97_CODEC_ID_SECONDARY << VIA_REG_AC97_CODEC_ID_SHIFT));\r\ndo {\r\nif ((val = snd_via82xx_codec_xread(chip)) & VIA_REG_AC97_SECONDARY_VALID) {\r\nchip->ac97_secondary = 1;\r\ngoto __ac97_ok2;\r\n}\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_before(jiffies, end_time));\r\n__ac97_ok2:\r\n#endif\r\nif (chip->chip_type == TYPE_VIA686) {\r\npci_write_config_byte(chip->pci, VIA_FM_NMI_CTRL, 0);\r\noutl(0, VIAREG(chip, GPI_INTR));\r\n}\r\nif (chip->chip_type != TYPE_VIA686) {\r\nstruct pci_dev *pci;\r\npci = pci_get_device(0x1106, 0x3068, NULL);\r\nif (pci) {\r\nunsigned char data;\r\npci_read_config_byte(pci, 0x44, &data);\r\npci_write_config_byte(pci, 0x44, data | 0x40);\r\npci_dev_put(pci);\r\n}\r\n}\r\nif (chip->chip_type != TYPE_VIA8233A) {\r\nint i, idx;\r\nfor (idx = 0; idx < 4; idx++) {\r\nunsigned long port = chip->port + 0x10 * idx;\r\nfor (i = 0; i < 2; i++) {\r\nchip->playback_volume[idx][i]=chip->playback_volume_c[i];\r\noutb(chip->playback_volume_c[i],\r\nport + VIA_REG_OFS_PLAYBACK_VOLUME_L + i);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_via82xx_suspend(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct via82xx *chip = card->private_data;\r\nint i;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nfor (i = 0; i < 2; i++)\r\nsnd_pcm_suspend_all(chip->pcms[i]);\r\nfor (i = 0; i < chip->num_devs; i++)\r\nsnd_via82xx_channel_reset(chip, &chip->devs[i]);\r\nsynchronize_irq(chip->irq);\r\nsnd_ac97_suspend(chip->ac97);\r\nif (chip->chip_type != TYPE_VIA686) {\r\npci_read_config_byte(chip->pci, VIA8233_SPDIF_CTRL, &chip->spdif_ctrl_saved);\r\nchip->capture_src_saved[0] = inb(chip->port + VIA_REG_CAPTURE_CHANNEL);\r\nchip->capture_src_saved[1] = inb(chip->port + VIA_REG_CAPTURE_CHANNEL + 0x10);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_via82xx_resume(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct via82xx *chip = card->private_data;\r\nint i;\r\nsnd_via82xx_chip_init(chip);\r\nif (chip->chip_type == TYPE_VIA686) {\r\nif (chip->mpu_port_saved)\r\npci_write_config_dword(chip->pci, 0x18, chip->mpu_port_saved | 0x01);\r\npci_write_config_byte(chip->pci, VIA_FUNC_ENABLE, chip->legacy_saved);\r\npci_write_config_byte(chip->pci, VIA_PNP_CONTROL, chip->legacy_cfg_saved);\r\n} else {\r\npci_write_config_byte(chip->pci, VIA8233_SPDIF_CTRL, chip->spdif_ctrl_saved);\r\noutb(chip->capture_src_saved[0], chip->port + VIA_REG_CAPTURE_CHANNEL);\r\noutb(chip->capture_src_saved[1], chip->port + VIA_REG_CAPTURE_CHANNEL + 0x10);\r\n}\r\nsnd_ac97_resume(chip->ac97);\r\nfor (i = 0; i < chip->num_devs; i++)\r\nsnd_via82xx_channel_reset(chip, &chip->devs[i]);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic int snd_via82xx_free(struct via82xx *chip)\r\n{\r\nunsigned int i;\r\nif (chip->irq < 0)\r\ngoto __end_hw;\r\nfor (i = 0; i < chip->num_devs; i++)\r\nsnd_via82xx_channel_reset(chip, &chip->devs[i]);\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\n__end_hw:\r\nrelease_and_free_resource(chip->mpu_res);\r\npci_release_regions(chip->pci);\r\nif (chip->chip_type == TYPE_VIA686) {\r\nsnd_via686_free_gameport(chip);\r\npci_write_config_byte(chip->pci, VIA_FUNC_ENABLE, chip->old_legacy);\r\npci_write_config_byte(chip->pci, VIA_PNP_CONTROL, chip->old_legacy_cfg);\r\n}\r\npci_disable_device(chip->pci);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_via82xx_dev_free(struct snd_device *device)\r\n{\r\nstruct via82xx *chip = device->device_data;\r\nreturn snd_via82xx_free(chip);\r\n}\r\nstatic int snd_via82xx_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nint chip_type,\r\nint revision,\r\nunsigned int ac97_clock,\r\nstruct via82xx **r_via)\r\n{\r\nstruct via82xx *chip;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_via82xx_dev_free,\r\n};\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nif ((chip = kzalloc(sizeof(*chip), GFP_KERNEL)) == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nchip->chip_type = chip_type;\r\nchip->revision = revision;\r\nspin_lock_init(&chip->reg_lock);\r\nspin_lock_init(&chip->rates[0].lock);\r\nspin_lock_init(&chip->rates[1].lock);\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\npci_read_config_byte(pci, VIA_FUNC_ENABLE, &chip->old_legacy);\r\npci_read_config_byte(pci, VIA_PNP_CONTROL, &chip->old_legacy_cfg);\r\npci_write_config_byte(chip->pci, VIA_FUNC_ENABLE,\r\nchip->old_legacy & ~(VIA_FUNC_ENABLE_SB|VIA_FUNC_ENABLE_FM));\r\nif ((err = pci_request_regions(pci, card->driver)) < 0) {\r\nkfree(chip);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nchip->port = pci_resource_start(pci, 0);\r\nif (request_irq(pci->irq,\r\nchip_type == TYPE_VIA8233 ?\r\nsnd_via8233_interrupt : snd_via686_interrupt,\r\nIRQF_SHARED,\r\nKBUILD_MODNAME, chip)) {\r\ndev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);\r\nsnd_via82xx_free(chip);\r\nreturn -EBUSY;\r\n}\r\nchip->irq = pci->irq;\r\nif (ac97_clock >= 8000 && ac97_clock <= 48000)\r\nchip->ac97_clock = ac97_clock;\r\nsynchronize_irq(chip->irq);\r\nif ((err = snd_via82xx_chip_init(chip)) < 0) {\r\nsnd_via82xx_free(chip);\r\nreturn err;\r\n}\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\r\nsnd_via82xx_free(chip);\r\nreturn err;\r\n}\r\npci_set_master(pci);\r\n*r_via = chip;\r\nreturn 0;\r\n}\r\nstatic int check_dxs_list(struct pci_dev *pci, int revision)\r\n{\r\nconst struct snd_pci_quirk *w;\r\nw = snd_pci_quirk_lookup(pci, dxs_whitelist);\r\nif (w) {\r\ndev_dbg(&pci->dev, "DXS white list for %s found\n",\r\nsnd_pci_quirk_name(w));\r\nreturn w->value;\r\n}\r\nif (revision >= VIA_REV_8235)\r\nreturn VIA_DXS_SRC;\r\ndev_info(&pci->dev, "Assuming DXS channels with 48k fixed sample rate.\n");\r\ndev_info(&pci->dev, " Please try dxs_support=5 option\n");\r\ndev_info(&pci->dev, " and report if it works on your machine.\n");\r\ndev_info(&pci->dev, " For more details, read ALSA-Configuration.txt.\n");\r\nreturn VIA_DXS_48K;\r\n}\r\nstatic int snd_via82xx_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct snd_card *card;\r\nstruct via82xx *chip;\r\nint chip_type = 0, card_type;\r\nunsigned int i;\r\nint err;\r\nerr = snd_card_new(&pci->dev, index, id, THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\ncard_type = pci_id->driver_data;\r\nswitch (card_type) {\r\ncase TYPE_CARD_VIA686:\r\nstrcpy(card->driver, "VIA686A");\r\nsprintf(card->shortname, "VIA 82C686A/B rev%x", pci->revision);\r\nchip_type = TYPE_VIA686;\r\nbreak;\r\ncase TYPE_CARD_VIA8233:\r\nchip_type = TYPE_VIA8233;\r\nsprintf(card->shortname, "VIA 823x rev%x", pci->revision);\r\nfor (i = 0; i < ARRAY_SIZE(via823x_cards); i++) {\r\nif (pci->revision == via823x_cards[i].revision) {\r\nchip_type = via823x_cards[i].type;\r\nstrcpy(card->shortname, via823x_cards[i].name);\r\nbreak;\r\n}\r\n}\r\nif (chip_type != TYPE_VIA8233A) {\r\nif (dxs_support == VIA_DXS_AUTO)\r\ndxs_support = check_dxs_list(pci, pci->revision);\r\nif (dxs_support == VIA_DXS_DISABLE)\r\nchip_type = TYPE_VIA8233A;\r\nelse\r\nchip_type = TYPE_VIA8233;\r\n}\r\nif (chip_type == TYPE_VIA8233A)\r\nstrcpy(card->driver, "VIA8233A");\r\nelse if (pci->revision >= VIA_REV_8237)\r\nstrcpy(card->driver, "VIA8237");\r\nelse\r\nstrcpy(card->driver, "VIA8233");\r\nbreak;\r\ndefault:\r\ndev_err(card->dev, "invalid card type %d\n", card_type);\r\nerr = -EINVAL;\r\ngoto __error;\r\n}\r\nif ((err = snd_via82xx_create(card, pci, chip_type, pci->revision,\r\nac97_clock, &chip)) < 0)\r\ngoto __error;\r\ncard->private_data = chip;\r\nif ((err = snd_via82xx_mixer_new(chip, ac97_quirk)) < 0)\r\ngoto __error;\r\nif (chip_type == TYPE_VIA686) {\r\nif ((err = snd_via686_pcm_new(chip)) < 0 ||\r\n(err = snd_via686_init_misc(chip)) < 0)\r\ngoto __error;\r\n} else {\r\nif (chip_type == TYPE_VIA8233A) {\r\nif ((err = snd_via8233a_pcm_new(chip)) < 0)\r\ngoto __error;\r\n} else {\r\nif ((err = snd_via8233_pcm_new(chip)) < 0)\r\ngoto __error;\r\nif (dxs_support == VIA_DXS_48K)\r\nchip->dxs_fixed = 1;\r\nelse if (dxs_support == VIA_DXS_NO_VRA)\r\nchip->no_vra = 1;\r\nelse if (dxs_support == VIA_DXS_SRC) {\r\nchip->no_vra = 1;\r\nchip->dxs_src = 1;\r\n}\r\n}\r\nif ((err = snd_via8233_init_misc(chip)) < 0)\r\ngoto __error;\r\n}\r\nfor (i = 0; i < chip->num_devs; i++)\r\nsnd_via82xx_channel_reset(chip, &chip->devs[i]);\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"%s with %s at %#lx, irq %d", card->shortname,\r\nsnd_ac97_get_short_name(chip->ac97), chip->port, chip->irq);\r\nsnd_via82xx_proc_init(chip);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\nreturn 0;\r\n__error:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic void snd_via82xx_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\n}
