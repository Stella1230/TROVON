void acpi_ut_strlwr(char *src_string)\r\n{\r\nchar *string;\r\nACPI_FUNCTION_ENTRY();\r\nif (!src_string) {\r\nreturn;\r\n}\r\nfor (string = src_string; *string; string++) {\r\n*string = (char)tolower((int)*string);\r\n}\r\n}\r\nvoid acpi_ut_strupr(char *src_string)\r\n{\r\nchar *string;\r\nACPI_FUNCTION_ENTRY();\r\nif (!src_string) {\r\nreturn;\r\n}\r\nfor (string = src_string; *string; string++) {\r\n*string = (char)toupper((int)*string);\r\n}\r\n}\r\nint acpi_ut_stricmp(char *string1, char *string2)\r\n{\r\nint c1;\r\nint c2;\r\ndo {\r\nc1 = tolower((int)*string1);\r\nc2 = tolower((int)*string2);\r\nstring1++;\r\nstring2++;\r\n}\r\nwhile ((c1 == c2) && (c1));\r\nreturn (c1 - c2);\r\n}\r\nacpi_status acpi_ut_strtoul64(char *string, u32 base, u64 *ret_integer)\r\n{\r\nu32 this_digit = 0;\r\nu64 return_value = 0;\r\nu64 quotient;\r\nu64 dividend;\r\nu32 to_integer_op = (base == ACPI_ANY_BASE);\r\nu32 mode32 = (acpi_gbl_integer_byte_width == 4);\r\nu8 valid_digits = 0;\r\nu8 sign_of0x = 0;\r\nu8 term = 0;\r\nACPI_FUNCTION_TRACE_STR(ut_stroul64, string);\r\nswitch (base) {\r\ncase ACPI_ANY_BASE:\r\ncase 16:\r\nbreak;\r\ndefault:\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nif (!string) {\r\ngoto error_exit;\r\n}\r\nwhile ((*string) && (isspace((int)*string) || *string == '\t')) {\r\nstring++;\r\n}\r\nif (to_integer_op) {\r\nif ((*string == '0') && (tolower((int)*(string + 1)) == 'x')) {\r\nsign_of0x = 1;\r\nbase = 16;\r\nstring += 2;\r\n} else {\r\nbase = 10;\r\n}\r\n}\r\nif (!(*string) || isspace((int)*string) || *string == '\t') {\r\nif (to_integer_op) {\r\ngoto error_exit;\r\n} else {\r\ngoto all_done;\r\n}\r\n}\r\ndividend = (mode32) ? ACPI_UINT32_MAX : ACPI_UINT64_MAX;\r\nwhile (*string) {\r\nif (isdigit((int)*string)) {\r\nthis_digit = ((u8)*string) - '0';\r\n} else if (base == 10) {\r\nterm = 1;\r\n} else {\r\nthis_digit = (u8)toupper((int)*string);\r\nif (isxdigit((int)this_digit)) {\r\nthis_digit = this_digit - 'A' + 10;\r\n} else {\r\nterm = 1;\r\n}\r\n}\r\nif (term) {\r\nif (to_integer_op) {\r\ngoto error_exit;\r\n} else {\r\nbreak;\r\n}\r\n} else if ((valid_digits == 0) && (this_digit == 0)\r\n&& !sign_of0x) {\r\nstring++;\r\ncontinue;\r\n}\r\nvalid_digits++;\r\nif (sign_of0x\r\n&& ((valid_digits > 16)\r\n|| ((valid_digits > 8) && mode32))) {\r\ngoto error_exit;\r\n}\r\n(void)acpi_ut_short_divide((dividend - (u64)this_digit),\r\nbase, &quotient, NULL);\r\nif (return_value > quotient) {\r\nif (to_integer_op) {\r\ngoto error_exit;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nreturn_value *= base;\r\nreturn_value += this_digit;\r\nstring++;\r\n}\r\nall_done:\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Converted value: %8.8X%8.8X\n",\r\nACPI_FORMAT_UINT64(return_value)));\r\n*ret_integer = return_value;\r\nreturn_ACPI_STATUS(AE_OK);\r\nerror_exit:\r\nif (base == 10) {\r\nreturn_ACPI_STATUS(AE_BAD_DECIMAL_CONSTANT);\r\n} else {\r\nreturn_ACPI_STATUS(AE_BAD_HEX_CONSTANT);\r\n}\r\n}\r\nu8 acpi_ut_safe_strcpy(char *dest, acpi_size dest_size, char *source)\r\n{\r\nif (strlen(source) >= dest_size) {\r\nreturn (TRUE);\r\n}\r\nstrcpy(dest, source);\r\nreturn (FALSE);\r\n}\r\nu8 acpi_ut_safe_strcat(char *dest, acpi_size dest_size, char *source)\r\n{\r\nif ((strlen(dest) + strlen(source)) >= dest_size) {\r\nreturn (TRUE);\r\n}\r\nstrcat(dest, source);\r\nreturn (FALSE);\r\n}\r\nu8\r\nacpi_ut_safe_strncat(char *dest,\r\nacpi_size dest_size,\r\nchar *source, acpi_size max_transfer_length)\r\n{\r\nacpi_size actual_transfer_length;\r\nactual_transfer_length = ACPI_MIN(max_transfer_length, strlen(source));\r\nif ((strlen(dest) + actual_transfer_length) >= dest_size) {\r\nreturn (TRUE);\r\n}\r\nstrncat(dest, source, max_transfer_length);\r\nreturn (FALSE);\r\n}
