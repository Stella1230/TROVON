static int address_not_null(u8 *ip)\r\n{\r\nreturn (memcmp(ip, nulls, 16) && memcmp(ip, mapped_nulls, 16));\r\n}\r\nstatic ssize_t sprintf_ipaddr(char *buf, u8 *ip)\r\n{\r\nchar *str = buf;\r\nif (ip[0] == 0 && ip[1] == 0 && ip[2] == 0 && ip[3] == 0 &&\r\nip[4] == 0 && ip[5] == 0 && ip[6] == 0 && ip[7] == 0 &&\r\nip[8] == 0 && ip[9] == 0 && ip[10] == 0xff && ip[11] == 0xff) {\r\nstr += sprintf(buf, "%pI4", ip + 12);\r\n} else {\r\nstr += sprintf(str, "%pI6", ip);\r\n}\r\nstr += sprintf(str, "\n");\r\nreturn str - buf;\r\n}\r\nstatic ssize_t sprintf_string(char *str, int len, char *buf)\r\n{\r\nreturn sprintf(str, "%.*s\n", len, buf);\r\n}\r\nstatic int ibft_verify_hdr(char *t, struct ibft_hdr *hdr, int id, int length)\r\n{\r\nif (hdr->id != id) {\r\nprintk(KERN_ERR "iBFT error: We expected the %s " \\r\n"field header.id to have %d but " \\r\n"found %d instead!\n", t, id, hdr->id);\r\nreturn -ENODEV;\r\n}\r\nif (hdr->length != length) {\r\nprintk(KERN_ERR "iBFT error: We expected the %s " \\r\n"field header.length to have %d but " \\r\n"found %d instead!\n", t, length, hdr->length);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t ibft_attr_show_initiator(void *data, int type, char *buf)\r\n{\r\nstruct ibft_kobject *entry = data;\r\nstruct ibft_initiator *initiator = entry->initiator;\r\nvoid *ibft_loc = entry->header;\r\nchar *str = buf;\r\nif (!initiator)\r\nreturn 0;\r\nswitch (type) {\r\ncase ISCSI_BOOT_INI_INDEX:\r\nstr += sprintf(str, "%d\n", initiator->hdr.index);\r\nbreak;\r\ncase ISCSI_BOOT_INI_FLAGS:\r\nstr += sprintf(str, "%d\n", initiator->hdr.flags);\r\nbreak;\r\ncase ISCSI_BOOT_INI_ISNS_SERVER:\r\nstr += sprintf_ipaddr(str, initiator->isns_server);\r\nbreak;\r\ncase ISCSI_BOOT_INI_SLP_SERVER:\r\nstr += sprintf_ipaddr(str, initiator->slp_server);\r\nbreak;\r\ncase ISCSI_BOOT_INI_PRI_RADIUS_SERVER:\r\nstr += sprintf_ipaddr(str, initiator->pri_radius_server);\r\nbreak;\r\ncase ISCSI_BOOT_INI_SEC_RADIUS_SERVER:\r\nstr += sprintf_ipaddr(str, initiator->sec_radius_server);\r\nbreak;\r\ncase ISCSI_BOOT_INI_INITIATOR_NAME:\r\nstr += sprintf_string(str, initiator->initiator_name_len,\r\n(char *)ibft_loc +\r\ninitiator->initiator_name_off);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn str - buf;\r\n}\r\nstatic ssize_t ibft_attr_show_nic(void *data, int type, char *buf)\r\n{\r\nstruct ibft_kobject *entry = data;\r\nstruct ibft_nic *nic = entry->nic;\r\nvoid *ibft_loc = entry->header;\r\nchar *str = buf;\r\n__be32 val;\r\nif (!nic)\r\nreturn 0;\r\nswitch (type) {\r\ncase ISCSI_BOOT_ETH_INDEX:\r\nstr += sprintf(str, "%d\n", nic->hdr.index);\r\nbreak;\r\ncase ISCSI_BOOT_ETH_FLAGS:\r\nstr += sprintf(str, "%d\n", nic->hdr.flags);\r\nbreak;\r\ncase ISCSI_BOOT_ETH_IP_ADDR:\r\nstr += sprintf_ipaddr(str, nic->ip_addr);\r\nbreak;\r\ncase ISCSI_BOOT_ETH_SUBNET_MASK:\r\nval = cpu_to_be32(~((1 << (32-nic->subnet_mask_prefix))-1));\r\nstr += sprintf(str, "%pI4", &val);\r\nbreak;\r\ncase ISCSI_BOOT_ETH_ORIGIN:\r\nstr += sprintf(str, "%d\n", nic->origin);\r\nbreak;\r\ncase ISCSI_BOOT_ETH_GATEWAY:\r\nstr += sprintf_ipaddr(str, nic->gateway);\r\nbreak;\r\ncase ISCSI_BOOT_ETH_PRIMARY_DNS:\r\nstr += sprintf_ipaddr(str, nic->primary_dns);\r\nbreak;\r\ncase ISCSI_BOOT_ETH_SECONDARY_DNS:\r\nstr += sprintf_ipaddr(str, nic->secondary_dns);\r\nbreak;\r\ncase ISCSI_BOOT_ETH_DHCP:\r\nstr += sprintf_ipaddr(str, nic->dhcp);\r\nbreak;\r\ncase ISCSI_BOOT_ETH_VLAN:\r\nstr += sprintf(str, "%d\n", nic->vlan);\r\nbreak;\r\ncase ISCSI_BOOT_ETH_MAC:\r\nstr += sprintf(str, "%pM\n", nic->mac);\r\nbreak;\r\ncase ISCSI_BOOT_ETH_HOSTNAME:\r\nstr += sprintf_string(str, nic->hostname_len,\r\n(char *)ibft_loc + nic->hostname_off);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn str - buf;\r\n}\r\nstatic ssize_t ibft_attr_show_target(void *data, int type, char *buf)\r\n{\r\nstruct ibft_kobject *entry = data;\r\nstruct ibft_tgt *tgt = entry->tgt;\r\nvoid *ibft_loc = entry->header;\r\nchar *str = buf;\r\nint i;\r\nif (!tgt)\r\nreturn 0;\r\nswitch (type) {\r\ncase ISCSI_BOOT_TGT_INDEX:\r\nstr += sprintf(str, "%d\n", tgt->hdr.index);\r\nbreak;\r\ncase ISCSI_BOOT_TGT_FLAGS:\r\nstr += sprintf(str, "%d\n", tgt->hdr.flags);\r\nbreak;\r\ncase ISCSI_BOOT_TGT_IP_ADDR:\r\nstr += sprintf_ipaddr(str, tgt->ip_addr);\r\nbreak;\r\ncase ISCSI_BOOT_TGT_PORT:\r\nstr += sprintf(str, "%d\n", tgt->port);\r\nbreak;\r\ncase ISCSI_BOOT_TGT_LUN:\r\nfor (i = 0; i < 8; i++)\r\nstr += sprintf(str, "%x", (u8)tgt->lun[i]);\r\nstr += sprintf(str, "\n");\r\nbreak;\r\ncase ISCSI_BOOT_TGT_NIC_ASSOC:\r\nstr += sprintf(str, "%d\n", tgt->nic_assoc);\r\nbreak;\r\ncase ISCSI_BOOT_TGT_CHAP_TYPE:\r\nstr += sprintf(str, "%d\n", tgt->chap_type);\r\nbreak;\r\ncase ISCSI_BOOT_TGT_NAME:\r\nstr += sprintf_string(str, tgt->tgt_name_len,\r\n(char *)ibft_loc + tgt->tgt_name_off);\r\nbreak;\r\ncase ISCSI_BOOT_TGT_CHAP_NAME:\r\nstr += sprintf_string(str, tgt->chap_name_len,\r\n(char *)ibft_loc + tgt->chap_name_off);\r\nbreak;\r\ncase ISCSI_BOOT_TGT_CHAP_SECRET:\r\nstr += sprintf_string(str, tgt->chap_secret_len,\r\n(char *)ibft_loc + tgt->chap_secret_off);\r\nbreak;\r\ncase ISCSI_BOOT_TGT_REV_CHAP_NAME:\r\nstr += sprintf_string(str, tgt->rev_chap_name_len,\r\n(char *)ibft_loc +\r\ntgt->rev_chap_name_off);\r\nbreak;\r\ncase ISCSI_BOOT_TGT_REV_CHAP_SECRET:\r\nstr += sprintf_string(str, tgt->rev_chap_secret_len,\r\n(char *)ibft_loc +\r\ntgt->rev_chap_secret_off);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn str - buf;\r\n}\r\nstatic int __init ibft_check_device(void)\r\n{\r\nint len;\r\nu8 *pos;\r\nu8 csum = 0;\r\nlen = ibft_addr->header.length;\r\nif (ibft_addr->header.revision != 1) {\r\nprintk(KERN_ERR "iBFT module supports only revision 1, " \\r\n"while this is %d.\n",\r\nibft_addr->header.revision);\r\nreturn -ENOENT;\r\n}\r\nfor (pos = (u8 *)ibft_addr; pos < (u8 *)ibft_addr + len; pos++)\r\ncsum += *pos;\r\nif (csum) {\r\nprintk(KERN_ERR "iBFT has incorrect checksum (0x%x)!\n", csum);\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\n}\r\nstatic umode_t ibft_check_nic_for(void *data, int type)\r\n{\r\nstruct ibft_kobject *entry = data;\r\nstruct ibft_nic *nic = entry->nic;\r\numode_t rc = 0;\r\nswitch (type) {\r\ncase ISCSI_BOOT_ETH_INDEX:\r\ncase ISCSI_BOOT_ETH_FLAGS:\r\nrc = S_IRUGO;\r\nbreak;\r\ncase ISCSI_BOOT_ETH_IP_ADDR:\r\nif (address_not_null(nic->ip_addr))\r\nrc = S_IRUGO;\r\nbreak;\r\ncase ISCSI_BOOT_ETH_SUBNET_MASK:\r\nif (nic->subnet_mask_prefix)\r\nrc = S_IRUGO;\r\nbreak;\r\ncase ISCSI_BOOT_ETH_ORIGIN:\r\nrc = S_IRUGO;\r\nbreak;\r\ncase ISCSI_BOOT_ETH_GATEWAY:\r\nif (address_not_null(nic->gateway))\r\nrc = S_IRUGO;\r\nbreak;\r\ncase ISCSI_BOOT_ETH_PRIMARY_DNS:\r\nif (address_not_null(nic->primary_dns))\r\nrc = S_IRUGO;\r\nbreak;\r\ncase ISCSI_BOOT_ETH_SECONDARY_DNS:\r\nif (address_not_null(nic->secondary_dns))\r\nrc = S_IRUGO;\r\nbreak;\r\ncase ISCSI_BOOT_ETH_DHCP:\r\nif (address_not_null(nic->dhcp))\r\nrc = S_IRUGO;\r\nbreak;\r\ncase ISCSI_BOOT_ETH_VLAN:\r\ncase ISCSI_BOOT_ETH_MAC:\r\nrc = S_IRUGO;\r\nbreak;\r\ncase ISCSI_BOOT_ETH_HOSTNAME:\r\nif (nic->hostname_off)\r\nrc = S_IRUGO;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic umode_t __init ibft_check_tgt_for(void *data, int type)\r\n{\r\nstruct ibft_kobject *entry = data;\r\nstruct ibft_tgt *tgt = entry->tgt;\r\numode_t rc = 0;\r\nswitch (type) {\r\ncase ISCSI_BOOT_TGT_INDEX:\r\ncase ISCSI_BOOT_TGT_FLAGS:\r\ncase ISCSI_BOOT_TGT_IP_ADDR:\r\ncase ISCSI_BOOT_TGT_PORT:\r\ncase ISCSI_BOOT_TGT_LUN:\r\ncase ISCSI_BOOT_TGT_NIC_ASSOC:\r\ncase ISCSI_BOOT_TGT_CHAP_TYPE:\r\nrc = S_IRUGO;\r\ncase ISCSI_BOOT_TGT_NAME:\r\nif (tgt->tgt_name_len)\r\nrc = S_IRUGO;\r\nbreak;\r\ncase ISCSI_BOOT_TGT_CHAP_NAME:\r\ncase ISCSI_BOOT_TGT_CHAP_SECRET:\r\nif (tgt->chap_name_len)\r\nrc = S_IRUGO;\r\nbreak;\r\ncase ISCSI_BOOT_TGT_REV_CHAP_NAME:\r\ncase ISCSI_BOOT_TGT_REV_CHAP_SECRET:\r\nif (tgt->rev_chap_name_len)\r\nrc = S_IRUGO;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic umode_t __init ibft_check_initiator_for(void *data, int type)\r\n{\r\nstruct ibft_kobject *entry = data;\r\nstruct ibft_initiator *init = entry->initiator;\r\numode_t rc = 0;\r\nswitch (type) {\r\ncase ISCSI_BOOT_INI_INDEX:\r\ncase ISCSI_BOOT_INI_FLAGS:\r\nrc = S_IRUGO;\r\nbreak;\r\ncase ISCSI_BOOT_INI_ISNS_SERVER:\r\nif (address_not_null(init->isns_server))\r\nrc = S_IRUGO;\r\nbreak;\r\ncase ISCSI_BOOT_INI_SLP_SERVER:\r\nif (address_not_null(init->slp_server))\r\nrc = S_IRUGO;\r\nbreak;\r\ncase ISCSI_BOOT_INI_PRI_RADIUS_SERVER:\r\nif (address_not_null(init->pri_radius_server))\r\nrc = S_IRUGO;\r\nbreak;\r\ncase ISCSI_BOOT_INI_SEC_RADIUS_SERVER:\r\nif (address_not_null(init->sec_radius_server))\r\nrc = S_IRUGO;\r\nbreak;\r\ncase ISCSI_BOOT_INI_INITIATOR_NAME:\r\nif (init->initiator_name_len)\r\nrc = S_IRUGO;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic void ibft_kobj_release(void *data)\r\n{\r\nkfree(data);\r\n}\r\nstatic int __init ibft_create_kobject(struct acpi_table_ibft *header,\r\nstruct ibft_hdr *hdr)\r\n{\r\nstruct iscsi_boot_kobj *boot_kobj = NULL;\r\nstruct ibft_kobject *ibft_kobj = NULL;\r\nstruct ibft_nic *nic = (struct ibft_nic *)hdr;\r\nstruct pci_dev *pci_dev;\r\nint rc = 0;\r\nibft_kobj = kzalloc(sizeof(*ibft_kobj), GFP_KERNEL);\r\nif (!ibft_kobj)\r\nreturn -ENOMEM;\r\nibft_kobj->header = header;\r\nibft_kobj->hdr = hdr;\r\nswitch (hdr->id) {\r\ncase id_initiator:\r\nrc = ibft_verify_hdr("initiator", hdr, id_initiator,\r\nsizeof(*ibft_kobj->initiator));\r\nif (rc)\r\nbreak;\r\nboot_kobj = iscsi_boot_create_initiator(boot_kset, hdr->index,\r\nibft_kobj,\r\nibft_attr_show_initiator,\r\nibft_check_initiator_for,\r\nibft_kobj_release);\r\nif (!boot_kobj) {\r\nrc = -ENOMEM;\r\ngoto free_ibft_obj;\r\n}\r\nbreak;\r\ncase id_nic:\r\nrc = ibft_verify_hdr("ethernet", hdr, id_nic,\r\nsizeof(*ibft_kobj->nic));\r\nif (rc)\r\nbreak;\r\nboot_kobj = iscsi_boot_create_ethernet(boot_kset, hdr->index,\r\nibft_kobj,\r\nibft_attr_show_nic,\r\nibft_check_nic_for,\r\nibft_kobj_release);\r\nif (!boot_kobj) {\r\nrc = -ENOMEM;\r\ngoto free_ibft_obj;\r\n}\r\nbreak;\r\ncase id_target:\r\nrc = ibft_verify_hdr("target", hdr, id_target,\r\nsizeof(*ibft_kobj->tgt));\r\nif (rc)\r\nbreak;\r\nboot_kobj = iscsi_boot_create_target(boot_kset, hdr->index,\r\nibft_kobj,\r\nibft_attr_show_target,\r\nibft_check_tgt_for,\r\nibft_kobj_release);\r\nif (!boot_kobj) {\r\nrc = -ENOMEM;\r\ngoto free_ibft_obj;\r\n}\r\nbreak;\r\ncase id_reserved:\r\ncase id_control:\r\ncase id_extensions:\r\nrc = 1;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "iBFT has unknown structure type (%d). " \\r\n"Report this bug to %.6s!\n", hdr->id,\r\nheader->header.oem_id);\r\nrc = 1;\r\nbreak;\r\n}\r\nif (rc) {\r\nrc = 0;\r\ngoto free_ibft_obj;\r\n}\r\nif (hdr->id == id_nic) {\r\npci_dev = pci_get_bus_and_slot((nic->pci_bdf & 0xff00) >> 8,\r\n(nic->pci_bdf & 0xff));\r\nif (pci_dev) {\r\nrc = sysfs_create_link(&boot_kobj->kobj,\r\n&pci_dev->dev.kobj, "device");\r\npci_dev_put(pci_dev);\r\n}\r\n}\r\nreturn 0;\r\nfree_ibft_obj:\r\nkfree(ibft_kobj);\r\nreturn rc;\r\n}\r\nstatic int __init ibft_register_kobjects(struct acpi_table_ibft *header)\r\n{\r\nstruct ibft_control *control = NULL;\r\nvoid *ptr, *end;\r\nint rc = 0;\r\nu16 offset;\r\nu16 eot_offset;\r\ncontrol = (void *)header + sizeof(*header);\r\nend = (void *)control + control->hdr.length;\r\neot_offset = (void *)header + header->header.length - (void *)control;\r\nrc = ibft_verify_hdr("control", (struct ibft_hdr *)control, id_control,\r\nsizeof(*control));\r\nrc |= ((control->hdr.index) ? -ENODEV : 0);\r\nif (rc) {\r\nprintk(KERN_ERR "iBFT error: Control header is invalid!\n");\r\nreturn rc;\r\n}\r\nfor (ptr = &control->initiator_off; ptr < end; ptr += sizeof(u16)) {\r\noffset = *(u16 *)ptr;\r\nif (offset && offset < header->header.length &&\r\noffset < eot_offset) {\r\nrc = ibft_create_kobject(header,\r\n(void *)header + offset);\r\nif (rc)\r\nbreak;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic void ibft_unregister(void)\r\n{\r\nstruct iscsi_boot_kobj *boot_kobj, *tmp_kobj;\r\nstruct ibft_kobject *ibft_kobj;\r\nlist_for_each_entry_safe(boot_kobj, tmp_kobj,\r\n&boot_kset->kobj_list, list) {\r\nibft_kobj = boot_kobj->data;\r\nif (ibft_kobj->hdr->id == id_nic)\r\nsysfs_remove_link(&boot_kobj->kobj, "device");\r\n};\r\n}\r\nstatic void ibft_cleanup(void)\r\n{\r\nif (boot_kset) {\r\nibft_unregister();\r\niscsi_boot_destroy_kset(boot_kset);\r\n}\r\n}\r\nstatic void __exit ibft_exit(void)\r\n{\r\nibft_cleanup();\r\n}\r\nstatic void __init acpi_find_ibft_region(void)\r\n{\r\nint i;\r\nstruct acpi_table_header *table = NULL;\r\nif (acpi_disabled)\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(ibft_signs) && !ibft_addr; i++) {\r\nacpi_get_table(ibft_signs[i].sign, 0, &table);\r\nibft_addr = (struct acpi_table_ibft *)table;\r\n}\r\n}\r\nstatic void __init acpi_find_ibft_region(void)\r\n{\r\n}\r\nstatic int __init ibft_init(void)\r\n{\r\nint rc = 0;\r\nif (!ibft_addr)\r\nacpi_find_ibft_region();\r\nif (ibft_addr) {\r\npr_info("iBFT detected.\n");\r\nrc = ibft_check_device();\r\nif (rc)\r\nreturn rc;\r\nboot_kset = iscsi_boot_create_kset("ibft");\r\nif (!boot_kset)\r\nreturn -ENOMEM;\r\nrc = ibft_register_kobjects(ibft_addr);\r\nif (rc)\r\ngoto out_free;\r\n} else\r\nprintk(KERN_INFO "No iBFT detected.\n");\r\nreturn 0;\r\nout_free:\r\nibft_cleanup();\r\nreturn rc;\r\n}
