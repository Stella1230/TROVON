static int poll_oip(struct bdc *bdc, int usec)\r\n{\r\nu32 status;\r\nwhile (usec) {\r\nstatus = bdc_readl(bdc->regs, BDC_BDCSC);\r\nif (BDC_CSTS(status) != BDC_OIP) {\r\ndev_dbg(bdc->dev,\r\n"poll_oip complete status=%d",\r\nBDC_CSTS(status));\r\nreturn 0;\r\n}\r\nudelay(10);\r\nusec -= 10;\r\n}\r\ndev_err(bdc->dev, "Err: operation timedout BDCSC: 0x%08x\n", status);\r\nreturn -ETIMEDOUT;\r\n}\r\nint bdc_stop(struct bdc *bdc)\r\n{\r\nint ret;\r\nu32 temp;\r\ndev_dbg(bdc->dev, "%s ()\n\n", __func__);\r\ntemp = bdc_readl(bdc->regs, BDC_BDCSC);\r\nif (BDC_CSTS(temp) == BDC_HLT) {\r\ndev_vdbg(bdc->dev, "BDC already halted\n");\r\nreturn 0;\r\n}\r\ntemp &= ~BDC_COP_MASK;\r\ntemp |= BDC_COS|BDC_COP_STP;\r\nbdc_writel(bdc->regs, BDC_BDCSC, temp);\r\nret = poll_oip(bdc, BDC_COP_TIMEOUT);\r\nif (ret)\r\ndev_err(bdc->dev, "bdc stop operation failed");\r\nreturn ret;\r\n}\r\nint bdc_reset(struct bdc *bdc)\r\n{\r\nu32 temp;\r\nint ret;\r\ndev_dbg(bdc->dev, "%s ()\n", __func__);\r\nret = bdc_stop(bdc);\r\nif (ret)\r\nreturn ret;\r\ntemp = bdc_readl(bdc->regs, BDC_BDCSC);\r\ntemp &= ~BDC_COP_MASK;\r\ntemp |= BDC_COS|BDC_COP_RST;\r\nbdc_writel(bdc->regs, BDC_BDCSC, temp);\r\nret = poll_oip(bdc, BDC_COP_TIMEOUT);\r\nif (ret)\r\ndev_err(bdc->dev, "bdc reset operation failed");\r\nreturn ret;\r\n}\r\nint bdc_run(struct bdc *bdc)\r\n{\r\nu32 temp;\r\nint ret;\r\ndev_dbg(bdc->dev, "%s ()\n", __func__);\r\ntemp = bdc_readl(bdc->regs, BDC_BDCSC);\r\nif (BDC_CSTS(temp) == BDC_NOR) {\r\ndev_warn(bdc->dev, "bdc is already in running state\n");\r\nreturn 0;\r\n}\r\ntemp &= ~BDC_COP_MASK;\r\ntemp |= BDC_COP_RUN;\r\ntemp |= BDC_COS;\r\nbdc_writel(bdc->regs, BDC_BDCSC, temp);\r\nret = poll_oip(bdc, BDC_COP_TIMEOUT);\r\nif (ret) {\r\ndev_err(bdc->dev, "bdc run operation failed:%d", ret);\r\nreturn ret;\r\n}\r\ntemp = bdc_readl(bdc->regs, BDC_BDCSC);\r\nif (BDC_CSTS(temp) != BDC_NOR) {\r\ndev_err(bdc->dev, "bdc not in normal mode after RUN op :%d\n",\r\nBDC_CSTS(temp));\r\nreturn -ESHUTDOWN;\r\n}\r\nreturn 0;\r\n}\r\nvoid bdc_softconn(struct bdc *bdc)\r\n{\r\nu32 uspc;\r\nuspc = bdc_readl(bdc->regs, BDC_USPC);\r\nuspc &= ~BDC_PST_MASK;\r\nuspc |= BDC_LINK_STATE_RX_DET;\r\nuspc |= BDC_SWS;\r\ndev_dbg(bdc->dev, "%s () uspc=%08x\n", __func__, uspc);\r\nbdc_writel(bdc->regs, BDC_USPC, uspc);\r\n}\r\nvoid bdc_softdisconn(struct bdc *bdc)\r\n{\r\nu32 uspc;\r\nuspc = bdc_readl(bdc->regs, BDC_USPC);\r\nuspc |= BDC_SDC;\r\nuspc &= ~BDC_SCN;\r\ndev_dbg(bdc->dev, "%s () uspc=%x\n", __func__, uspc);\r\nbdc_writel(bdc->regs, BDC_USPC, uspc);\r\n}\r\nstatic int scratchpad_setup(struct bdc *bdc)\r\n{\r\nint sp_buff_size;\r\nu32 low32;\r\nu32 upp32;\r\nsp_buff_size = BDC_SPB(bdc_readl(bdc->regs, BDC_BDCCFG0));\r\ndev_dbg(bdc->dev, "%s() sp_buff_size=%d\n", __func__, sp_buff_size);\r\nif (!sp_buff_size) {\r\ndev_dbg(bdc->dev, "Scratchpad buffer not needed\n");\r\nreturn 0;\r\n}\r\nsp_buff_size = 1 << (sp_buff_size + 5);\r\ndev_dbg(bdc->dev, "Allocating %d bytes for scratchpad\n", sp_buff_size);\r\nbdc->scratchpad.buff = dma_zalloc_coherent(bdc->dev, sp_buff_size,\r\n&bdc->scratchpad.sp_dma, GFP_KERNEL);\r\nif (!bdc->scratchpad.buff)\r\ngoto fail;\r\nbdc->sp_buff_size = sp_buff_size;\r\nbdc->scratchpad.size = sp_buff_size;\r\nlow32 = lower_32_bits(bdc->scratchpad.sp_dma);\r\nupp32 = upper_32_bits(bdc->scratchpad.sp_dma);\r\ncpu_to_le32s(&low32);\r\ncpu_to_le32s(&upp32);\r\nbdc_writel(bdc->regs, BDC_SPBBAL, low32);\r\nbdc_writel(bdc->regs, BDC_SPBBAH, upp32);\r\nreturn 0;\r\nfail:\r\nbdc->scratchpad.buff = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic int setup_srr(struct bdc *bdc, int interrupter)\r\n{\r\ndev_dbg(bdc->dev, "%s() NUM_SR_ENTRIES:%d\n", __func__, NUM_SR_ENTRIES);\r\nbdc_writel(bdc->regs, BDC_SRRINT(0), BDC_SRR_RWS | BDC_SRR_RST);\r\nbdc->srr.dqp_index = 0;\r\nbdc->srr.sr_bds = dma_zalloc_coherent(\r\nbdc->dev,\r\nNUM_SR_ENTRIES * sizeof(struct bdc_bd),\r\n&bdc->srr.dma_addr,\r\nGFP_KERNEL);\r\nif (!bdc->srr.sr_bds)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void bdc_mem_init(struct bdc *bdc, bool reinit)\r\n{\r\nu8 size = 0;\r\nu32 usb2_pm;\r\nu32 low32;\r\nu32 upp32;\r\nu32 temp;\r\ndev_dbg(bdc->dev, "%s ()\n", __func__);\r\nbdc->ep0_state = WAIT_FOR_SETUP;\r\nbdc->dev_addr = 0;\r\nbdc->srr.eqp_index = 0;\r\nbdc->srr.dqp_index = 0;\r\nbdc->zlp_needed = false;\r\nbdc->delayed_status = false;\r\nbdc_writel(bdc->regs, BDC_SPBBAL, bdc->scratchpad.sp_dma);\r\ntemp = BDC_SRR_RWS | BDC_SRR_RST;\r\nbdc_writel(bdc->regs, BDC_SRRINT(0), temp);\r\ndev_dbg(bdc->dev, "bdc->srr.sr_bds =%p\n", bdc->srr.sr_bds);\r\ntemp = lower_32_bits(bdc->srr.dma_addr);\r\nsize = fls(NUM_SR_ENTRIES) - 2;\r\ntemp |= size;\r\ndev_dbg(bdc->dev, "SRRBAL[0]=%08x NUM_SR_ENTRIES:%d size:%d\n",\r\ntemp, NUM_SR_ENTRIES, size);\r\nlow32 = lower_32_bits(temp);\r\nupp32 = upper_32_bits(bdc->srr.dma_addr);\r\ncpu_to_le32s(&low32);\r\ncpu_to_le32s(&upp32);\r\nbdc_writel(bdc->regs, BDC_SRRBAL(0), low32);\r\nbdc_writel(bdc->regs, BDC_SRRBAH(0), upp32);\r\ntemp = bdc_readl(bdc->regs, BDC_SRRINT(0));\r\ntemp |= BDC_SRR_IE;\r\ntemp &= ~(BDC_SRR_RST | BDC_SRR_RWS);\r\nbdc_writel(bdc->regs, BDC_SRRINT(0), temp);\r\ntemp = bdc_readl(bdc->regs, BDC_INTCTLS(0));\r\ntemp &= ~0xffff;\r\ntemp |= INT_CLS;\r\nbdc_writel(bdc->regs, BDC_INTCTLS(0), temp);\r\nusb2_pm = bdc_readl(bdc->regs, BDC_USPPM2);\r\ndev_dbg(bdc->dev, "usb2_pm=%08x", usb2_pm);\r\nusb2_pm |= BDC_HLE;\r\nbdc_writel(bdc->regs, BDC_USPPM2, usb2_pm);\r\nusb2_pm = bdc_readl(bdc->regs, BDC_USPPM2);\r\ndev_dbg(bdc->dev, "usb2_pm=%08x\n", usb2_pm);\r\ntemp = bdc_readl(bdc->regs, BDC_BDCSC);\r\ntemp |= BDC_MASK_MCW;\r\nbdc_writel(bdc->regs, BDC_BDCSC, temp);\r\nif (reinit) {\r\ntemp = bdc_readl(bdc->regs, BDC_BDCSC);\r\ntemp |= BDC_GIE;\r\nbdc_writel(bdc->regs, BDC_BDCSC, temp);\r\nmemset(bdc->scratchpad.buff, 0, bdc->sp_buff_size);\r\nmemset(bdc->srr.sr_bds, 0,\r\nNUM_SR_ENTRIES * sizeof(struct bdc_bd));\r\n} else {\r\nbdc->sr_handler[0] = bdc_sr_xsf;\r\nbdc->sr_handler[1] = bdc_sr_uspc;\r\nbdc->sr_xsf_ep0[0] = bdc_xsf_ep0_setup_recv;\r\nbdc->sr_xsf_ep0[1] = bdc_xsf_ep0_data_start;\r\nbdc->sr_xsf_ep0[2] = bdc_xsf_ep0_status_start;\r\n}\r\n}\r\nstatic void bdc_mem_free(struct bdc *bdc)\r\n{\r\ndev_dbg(bdc->dev, "%s\n", __func__);\r\nif (bdc->srr.sr_bds)\r\ndma_free_coherent(bdc->dev,\r\nNUM_SR_ENTRIES * sizeof(struct bdc_bd),\r\nbdc->srr.sr_bds, bdc->srr.dma_addr);\r\nif (bdc->scratchpad.buff)\r\ndma_free_coherent(bdc->dev, bdc->sp_buff_size,\r\nbdc->scratchpad.buff, bdc->scratchpad.sp_dma);\r\ndma_pool_destroy(bdc->bd_table_pool);\r\nkfree(bdc->bdc_ep_array);\r\nbdc->srr.sr_bds = NULL;\r\nbdc->scratchpad.buff = NULL;\r\nbdc->bd_table_pool = NULL;\r\nbdc->bdc_ep_array = NULL;\r\n}\r\nint bdc_reinit(struct bdc *bdc)\r\n{\r\nint ret;\r\ndev_dbg(bdc->dev, "%s\n", __func__);\r\nret = bdc_stop(bdc);\r\nif (ret)\r\ngoto out;\r\nret = bdc_reset(bdc);\r\nif (ret)\r\ngoto out;\r\nbdc_mem_init(bdc, true);\r\nret = bdc_run(bdc);\r\nout:\r\nbdc->reinit = false;\r\nreturn ret;\r\n}\r\nstatic int bdc_mem_alloc(struct bdc *bdc)\r\n{\r\nu32 page_size;\r\nunsigned int num_ieps, num_oeps;\r\ndev_dbg(bdc->dev,\r\n"%s() NUM_BDS_PER_TABLE:%d\n", __func__,\r\nNUM_BDS_PER_TABLE);\r\npage_size = BDC_PGS(bdc_readl(bdc->regs, BDC_BDCCFG0));\r\npage_size = 1 << page_size;\r\npage_size <<= 10;\r\ndev_dbg(bdc->dev, "page_size=%d\n", page_size);\r\nbdc->bd_table_pool =\r\ndma_pool_create("BDC BD tables", bdc->dev, NUM_BDS_PER_TABLE * 16,\r\n16, page_size);\r\nif (!bdc->bd_table_pool)\r\ngoto fail;\r\nif (scratchpad_setup(bdc))\r\ngoto fail;\r\nnum_ieps = NUM_NCS(bdc_readl(bdc->regs, BDC_FSCNIC));\r\nnum_oeps = NUM_NCS(bdc_readl(bdc->regs, BDC_FSCNOC));\r\nbdc->num_eps = num_ieps + num_oeps + 2;\r\ndev_dbg(bdc->dev,\r\n"ieps:%d eops:%d num_eps:%d\n",\r\nnum_ieps, num_oeps, bdc->num_eps);\r\nbdc->bdc_ep_array = kcalloc(bdc->num_eps, sizeof(struct bdc_ep *),\r\nGFP_KERNEL);\r\nif (!bdc->bdc_ep_array)\r\ngoto fail;\r\ndev_dbg(bdc->dev, "Allocating sr report0\n");\r\nif (setup_srr(bdc, 0))\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\ndev_warn(bdc->dev, "Couldn't initialize memory\n");\r\nbdc_mem_free(bdc);\r\nreturn -ENOMEM;\r\n}\r\nstatic void bdc_hw_exit(struct bdc *bdc)\r\n{\r\ndev_dbg(bdc->dev, "%s ()\n", __func__);\r\nbdc_mem_free(bdc);\r\n}\r\nstatic int bdc_hw_init(struct bdc *bdc)\r\n{\r\nint ret;\r\ndev_dbg(bdc->dev, "%s ()\n", __func__);\r\nret = bdc_reset(bdc);\r\nif (ret) {\r\ndev_err(bdc->dev, "err resetting bdc abort bdc init%d\n", ret);\r\nreturn ret;\r\n}\r\nret = bdc_mem_alloc(bdc);\r\nif (ret) {\r\ndev_err(bdc->dev, "Mem alloc failed, aborting\n");\r\nreturn -ENOMEM;\r\n}\r\nbdc_mem_init(bdc, 0);\r\nbdc_dbg_regs(bdc);\r\ndev_dbg(bdc->dev, "HW Init done\n");\r\nreturn 0;\r\n}\r\nstatic int bdc_probe(struct platform_device *pdev)\r\n{\r\nstruct bdc *bdc;\r\nstruct resource *res;\r\nint ret = -ENOMEM;\r\nint irq;\r\nu32 temp;\r\nstruct device *dev = &pdev->dev;\r\ndev_dbg(dev, "%s()\n", __func__);\r\nbdc = devm_kzalloc(dev, sizeof(*bdc), GFP_KERNEL);\r\nif (!bdc)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbdc->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(bdc->regs)) {\r\ndev_err(dev, "ioremap error\n");\r\nreturn -ENOMEM;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "platform_get_irq failed:%d\n", irq);\r\nreturn irq;\r\n}\r\nspin_lock_init(&bdc->lock);\r\nplatform_set_drvdata(pdev, bdc);\r\nbdc->irq = irq;\r\nbdc->dev = dev;\r\ndev_dbg(bdc->dev, "bdc->regs: %p irq=%d\n", bdc->regs, bdc->irq);\r\ntemp = bdc_readl(bdc->regs, BDC_BDCSC);\r\nif ((temp & BDC_P64) &&\r\n!dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64))) {\r\ndev_dbg(bdc->dev, "Using 64-bit address\n");\r\n} else {\r\nret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\r\nif (ret) {\r\ndev_err(bdc->dev, "No suitable DMA config available, abort\n");\r\nreturn -ENOTSUPP;\r\n}\r\ndev_dbg(bdc->dev, "Using 32-bit address\n");\r\n}\r\nret = bdc_hw_init(bdc);\r\nif (ret) {\r\ndev_err(bdc->dev, "BDC init failure:%d\n", ret);\r\nreturn ret;\r\n}\r\nret = bdc_udc_init(bdc);\r\nif (ret) {\r\ndev_err(bdc->dev, "BDC Gadget init failure:%d\n", ret);\r\ngoto cleanup;\r\n}\r\nreturn 0;\r\ncleanup:\r\nbdc_hw_exit(bdc);\r\nreturn ret;\r\n}\r\nstatic int bdc_remove(struct platform_device *pdev)\r\n{\r\nstruct bdc *bdc;\r\nbdc = platform_get_drvdata(pdev);\r\ndev_dbg(bdc->dev, "%s ()\n", __func__);\r\nbdc_udc_exit(bdc);\r\nbdc_hw_exit(bdc);\r\nreturn 0;\r\n}
