static bool alps_is_valid_first_byte(struct alps_data *priv,\r\nunsigned char data)\r\n{\r\nreturn (data & priv->mask0) == priv->byte0;\r\n}\r\nstatic void alps_report_buttons(struct input_dev *dev1, struct input_dev *dev2,\r\nint left, int right, int middle)\r\n{\r\nstruct input_dev *dev;\r\ndev = (dev2 && test_bit(BTN_LEFT, dev2->key)) ? dev2 : dev1;\r\ninput_report_key(dev, BTN_LEFT, left);\r\ndev = (dev2 && test_bit(BTN_RIGHT, dev2->key)) ? dev2 : dev1;\r\ninput_report_key(dev, BTN_RIGHT, right);\r\ndev = (dev2 && test_bit(BTN_MIDDLE, dev2->key)) ? dev2 : dev1;\r\ninput_report_key(dev, BTN_MIDDLE, middle);\r\nif (dev2)\r\ninput_sync(dev2);\r\n}\r\nstatic void alps_process_packet_v1_v2(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct input_dev *dev2 = priv->dev2;\r\nint x, y, z, ges, fin, left, right, middle;\r\nint back = 0, forward = 0;\r\nif (priv->proto_version == ALPS_PROTO_V1) {\r\nleft = packet[2] & 0x10;\r\nright = packet[2] & 0x08;\r\nmiddle = 0;\r\nx = packet[1] | ((packet[0] & 0x07) << 7);\r\ny = packet[4] | ((packet[3] & 0x07) << 7);\r\nz = packet[5];\r\n} else {\r\nleft = packet[3] & 1;\r\nright = packet[3] & 2;\r\nmiddle = packet[3] & 4;\r\nx = packet[1] | ((packet[2] & 0x78) << (7 - 3));\r\ny = packet[4] | ((packet[3] & 0x70) << (7 - 4));\r\nz = packet[5];\r\n}\r\nif (priv->flags & ALPS_FW_BK_1) {\r\nback = packet[0] & 0x10;\r\nforward = packet[2] & 4;\r\n}\r\nif (priv->flags & ALPS_FW_BK_2) {\r\nback = packet[3] & 4;\r\nforward = packet[2] & 4;\r\nif ((middle = forward && back))\r\nforward = back = 0;\r\n}\r\nges = packet[2] & 1;\r\nfin = packet[2] & 2;\r\nif ((priv->flags & ALPS_DUALPOINT) && z == 127) {\r\ninput_report_rel(dev2, REL_X, (x > 383 ? (x - 768) : x));\r\ninput_report_rel(dev2, REL_Y, -(y > 255 ? (y - 512) : y));\r\nalps_report_buttons(dev2, dev, left, right, middle);\r\ninput_sync(dev2);\r\nreturn;\r\n}\r\nif (priv->flags & ALPS_STICK_BITS) {\r\nleft |= packet[0] & 1;\r\nright |= packet[0] & 2;\r\nmiddle |= packet[0] & 4;\r\n}\r\nalps_report_buttons(dev, dev2, left, right, middle);\r\nif (ges && !fin)\r\nz = 40;\r\nif (ges && fin && !priv->prev_fin) {\r\ninput_report_abs(dev, ABS_X, x);\r\ninput_report_abs(dev, ABS_Y, y);\r\ninput_report_abs(dev, ABS_PRESSURE, 0);\r\ninput_report_key(dev, BTN_TOOL_FINGER, 0);\r\ninput_sync(dev);\r\n}\r\npriv->prev_fin = fin;\r\nif (z > 30)\r\ninput_report_key(dev, BTN_TOUCH, 1);\r\nif (z < 25)\r\ninput_report_key(dev, BTN_TOUCH, 0);\r\nif (z > 0) {\r\ninput_report_abs(dev, ABS_X, x);\r\ninput_report_abs(dev, ABS_Y, y);\r\n}\r\ninput_report_abs(dev, ABS_PRESSURE, z);\r\ninput_report_key(dev, BTN_TOOL_FINGER, z > 0);\r\nif (priv->flags & ALPS_WHEEL)\r\ninput_report_rel(dev, REL_WHEEL, ((packet[2] << 1) & 0x08) - ((packet[0] >> 4) & 0x07));\r\nif (priv->flags & (ALPS_FW_BK_1 | ALPS_FW_BK_2)) {\r\ninput_report_key(dev, BTN_FORWARD, forward);\r\ninput_report_key(dev, BTN_BACK, back);\r\n}\r\nif (priv->flags & ALPS_FOUR_BUTTONS) {\r\ninput_report_key(dev, BTN_0, packet[2] & 4);\r\ninput_report_key(dev, BTN_1, packet[0] & 0x10);\r\ninput_report_key(dev, BTN_2, packet[3] & 4);\r\ninput_report_key(dev, BTN_3, packet[0] & 0x20);\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic void alps_get_bitmap_points(unsigned int map,\r\nstruct alps_bitmap_point *low,\r\nstruct alps_bitmap_point *high,\r\nint *fingers)\r\n{\r\nstruct alps_bitmap_point *point;\r\nint i, bit, prev_bit = 0;\r\npoint = low;\r\nfor (i = 0; map != 0; i++, map >>= 1) {\r\nbit = map & 1;\r\nif (bit) {\r\nif (!prev_bit) {\r\npoint->start_bit = i;\r\npoint->num_bits = 0;\r\n(*fingers)++;\r\n}\r\npoint->num_bits++;\r\n} else {\r\nif (prev_bit)\r\npoint = high;\r\n}\r\nprev_bit = bit;\r\n}\r\n}\r\nstatic int alps_process_bitmap(struct alps_data *priv,\r\nstruct alps_fields *fields)\r\n{\r\nint i, fingers_x = 0, fingers_y = 0, fingers, closest;\r\nstruct alps_bitmap_point x_low = {0,}, x_high = {0,};\r\nstruct alps_bitmap_point y_low = {0,}, y_high = {0,};\r\nstruct input_mt_pos corner[4];\r\nif (!fields->x_map || !fields->y_map)\r\nreturn 0;\r\nalps_get_bitmap_points(fields->x_map, &x_low, &x_high, &fingers_x);\r\nalps_get_bitmap_points(fields->y_map, &y_low, &y_high, &fingers_y);\r\nfingers = max(fingers_x, fingers_y);\r\nif (fingers_x == 1) {\r\ni = (x_low.num_bits - 1) / 2;\r\nx_low.num_bits = x_low.num_bits - i;\r\nx_high.start_bit = x_low.start_bit + i;\r\nx_high.num_bits = max(i, 1);\r\n}\r\nif (fingers_y == 1) {\r\ni = (y_low.num_bits - 1) / 2;\r\ny_low.num_bits = y_low.num_bits - i;\r\ny_high.start_bit = y_low.start_bit + i;\r\ny_high.num_bits = max(i, 1);\r\n}\r\ncorner[0].x =\r\n(priv->x_max * (2 * x_low.start_bit + x_low.num_bits - 1)) /\r\n(2 * (priv->x_bits - 1));\r\ncorner[0].y =\r\n(priv->y_max * (2 * y_low.start_bit + y_low.num_bits - 1)) /\r\n(2 * (priv->y_bits - 1));\r\ncorner[1].x =\r\n(priv->x_max * (2 * x_high.start_bit + x_high.num_bits - 1)) /\r\n(2 * (priv->x_bits - 1));\r\ncorner[1].y =\r\n(priv->y_max * (2 * y_low.start_bit + y_low.num_bits - 1)) /\r\n(2 * (priv->y_bits - 1));\r\ncorner[2].x =\r\n(priv->x_max * (2 * x_high.start_bit + x_high.num_bits - 1)) /\r\n(2 * (priv->x_bits - 1));\r\ncorner[2].y =\r\n(priv->y_max * (2 * y_high.start_bit + y_high.num_bits - 1)) /\r\n(2 * (priv->y_bits - 1));\r\ncorner[3].x =\r\n(priv->x_max * (2 * x_low.start_bit + x_low.num_bits - 1)) /\r\n(2 * (priv->x_bits - 1));\r\ncorner[3].y =\r\n(priv->y_max * (2 * y_high.start_bit + y_high.num_bits - 1)) /\r\n(2 * (priv->y_bits - 1));\r\nif (priv->proto_version == ALPS_PROTO_V5) {\r\nfor (i = 0; i < 4; i++)\r\ncorner[i].x = priv->x_max - corner[i].x;\r\n}\r\nif (priv->proto_version == ALPS_PROTO_V3 ||\r\npriv->proto_version == ALPS_PROTO_V4) {\r\nfor (i = 0; i < 4; i++)\r\ncorner[i].y = priv->y_max - corner[i].y;\r\n}\r\nif (priv->second_touch == -1) {\r\nclosest = 0x7fffffff;\r\nfor (i = 0; i < 4; i++) {\r\nint dx = fields->st.x - corner[i].x;\r\nint dy = fields->st.y - corner[i].y;\r\nint distance = dx * dx + dy * dy;\r\nif (distance < closest) {\r\npriv->second_touch = i;\r\nclosest = distance;\r\n}\r\n}\r\npriv->second_touch = (priv->second_touch + 2) % 4;\r\n}\r\nfields->mt[0] = fields->st;\r\nfields->mt[1] = corner[priv->second_touch];\r\nreturn fingers;\r\n}\r\nstatic void alps_set_slot(struct input_dev *dev, int slot, int x, int y)\r\n{\r\ninput_mt_slot(dev, slot);\r\ninput_mt_report_slot_state(dev, MT_TOOL_FINGER, true);\r\ninput_report_abs(dev, ABS_MT_POSITION_X, x);\r\ninput_report_abs(dev, ABS_MT_POSITION_Y, y);\r\n}\r\nstatic void alps_report_mt_data(struct psmouse *psmouse, int n)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct alps_fields *f = &priv->f;\r\nint i, slot[MAX_TOUCHES];\r\ninput_mt_assign_slots(dev, slot, f->mt, n, 0);\r\nfor (i = 0; i < n; i++)\r\nalps_set_slot(dev, slot[i], f->mt[i].x, f->mt[i].y);\r\ninput_mt_sync_frame(dev);\r\n}\r\nstatic void alps_report_semi_mt_data(struct psmouse *psmouse, int fingers)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct alps_fields *f = &priv->f;\r\nif (fingers < 2) {\r\nf->mt[0].x = f->st.x;\r\nf->mt[0].y = f->st.y;\r\nfingers = f->pressure > 0 ? 1 : 0;\r\npriv->second_touch = -1;\r\n}\r\nif (fingers >= 1)\r\nalps_set_slot(dev, 0, f->mt[0].x, f->mt[0].y);\r\nif (fingers >= 2)\r\nalps_set_slot(dev, 1, f->mt[1].x, f->mt[1].y);\r\ninput_mt_sync_frame(dev);\r\ninput_mt_report_finger_count(dev, fingers);\r\ninput_report_key(dev, BTN_LEFT, f->left);\r\ninput_report_key(dev, BTN_RIGHT, f->right);\r\ninput_report_key(dev, BTN_MIDDLE, f->middle);\r\ninput_report_abs(dev, ABS_PRESSURE, f->pressure);\r\ninput_sync(dev);\r\n}\r\nstatic void alps_process_trackstick_packet_v3(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nstruct input_dev *dev = priv->dev2;\r\nint x, y, z, left, right, middle;\r\nif (!(priv->flags & ALPS_DUALPOINT)) {\r\npsmouse_warn(psmouse,\r\n"Rejected trackstick packet from non DualPoint device");\r\nreturn;\r\n}\r\nif (!(packet[0] & 0x40)) {\r\npsmouse_dbg(psmouse, "Bad trackstick packet, discarding\n");\r\nreturn;\r\n}\r\nif (packet[1] == 0x7f && packet[2] == 0x7f && packet[4] == 0x7f)\r\nreturn;\r\nx = (s8)(((packet[0] & 0x20) << 2) | (packet[1] & 0x7f));\r\ny = (s8)(((packet[0] & 0x10) << 3) | (packet[2] & 0x7f));\r\nz = (packet[4] & 0x7c) >> 2;\r\nx /= 8;\r\ny /= 8;\r\ninput_report_rel(dev, REL_X, x);\r\ninput_report_rel(dev, REL_Y, -y);\r\nleft = packet[3] & 0x01;\r\nright = packet[3] & 0x02;\r\nmiddle = packet[3] & 0x04;\r\nif (!(priv->quirks & ALPS_QUIRK_TRACKSTICK_BUTTONS) &&\r\n(left || right || middle))\r\npriv->quirks |= ALPS_QUIRK_TRACKSTICK_BUTTONS;\r\nif (priv->quirks & ALPS_QUIRK_TRACKSTICK_BUTTONS) {\r\ninput_report_key(dev, BTN_LEFT, left);\r\ninput_report_key(dev, BTN_RIGHT, right);\r\ninput_report_key(dev, BTN_MIDDLE, middle);\r\n}\r\ninput_sync(dev);\r\nreturn;\r\n}\r\nstatic void alps_decode_buttons_v3(struct alps_fields *f, unsigned char *p)\r\n{\r\nf->left = !!(p[3] & 0x01);\r\nf->right = !!(p[3] & 0x02);\r\nf->middle = !!(p[3] & 0x04);\r\nf->ts_left = !!(p[3] & 0x10);\r\nf->ts_right = !!(p[3] & 0x20);\r\nf->ts_middle = !!(p[3] & 0x40);\r\n}\r\nstatic int alps_decode_pinnacle(struct alps_fields *f, unsigned char *p,\r\nstruct psmouse *psmouse)\r\n{\r\nf->first_mp = !!(p[4] & 0x40);\r\nf->is_mp = !!(p[0] & 0x40);\r\nif (f->is_mp) {\r\nf->fingers = (p[5] & 0x3) + 1;\r\nf->x_map = ((p[4] & 0x7e) << 8) |\r\n((p[1] & 0x7f) << 2) |\r\n((p[0] & 0x30) >> 4);\r\nf->y_map = ((p[3] & 0x70) << 4) |\r\n((p[2] & 0x7f) << 1) |\r\n(p[4] & 0x01);\r\n} else {\r\nf->st.x = ((p[1] & 0x7f) << 4) | ((p[4] & 0x30) >> 2) |\r\n((p[0] & 0x30) >> 4);\r\nf->st.y = ((p[2] & 0x7f) << 4) | (p[4] & 0x0f);\r\nf->pressure = p[5] & 0x7f;\r\nalps_decode_buttons_v3(f, p);\r\n}\r\nreturn 0;\r\n}\r\nstatic int alps_decode_rushmore(struct alps_fields *f, unsigned char *p,\r\nstruct psmouse *psmouse)\r\n{\r\nf->first_mp = !!(p[4] & 0x40);\r\nf->is_mp = !!(p[5] & 0x40);\r\nif (f->is_mp) {\r\nf->fingers = max((p[5] & 0x3), ((p[5] >> 2) & 0x3)) + 1;\r\nf->x_map = ((p[5] & 0x10) << 11) |\r\n((p[4] & 0x7e) << 8) |\r\n((p[1] & 0x7f) << 2) |\r\n((p[0] & 0x30) >> 4);\r\nf->y_map = ((p[5] & 0x20) << 6) |\r\n((p[3] & 0x70) << 4) |\r\n((p[2] & 0x7f) << 1) |\r\n(p[4] & 0x01);\r\n} else {\r\nf->st.x = ((p[1] & 0x7f) << 4) | ((p[4] & 0x30) >> 2) |\r\n((p[0] & 0x30) >> 4);\r\nf->st.y = ((p[2] & 0x7f) << 4) | (p[4] & 0x0f);\r\nf->pressure = p[5] & 0x7f;\r\nalps_decode_buttons_v3(f, p);\r\n}\r\nreturn 0;\r\n}\r\nstatic int alps_decode_dolphin(struct alps_fields *f, unsigned char *p,\r\nstruct psmouse *psmouse)\r\n{\r\nu64 palm_data = 0;\r\nstruct alps_data *priv = psmouse->private;\r\nf->first_mp = !!(p[0] & 0x02);\r\nf->is_mp = !!(p[0] & 0x20);\r\nif (!f->is_mp) {\r\nf->st.x = ((p[1] & 0x7f) | ((p[4] & 0x0f) << 7));\r\nf->st.y = ((p[2] & 0x7f) | ((p[4] & 0xf0) << 3));\r\nf->pressure = (p[0] & 4) ? 0 : p[5] & 0x7f;\r\nalps_decode_buttons_v3(f, p);\r\n} else {\r\nf->fingers = ((p[0] & 0x6) >> 1 |\r\n(p[0] & 0x10) >> 2);\r\npalm_data = (p[1] & 0x7f) |\r\n((p[2] & 0x7f) << 7) |\r\n((p[4] & 0x7f) << 14) |\r\n((p[5] & 0x7f) << 21) |\r\n((p[3] & 0x07) << 28) |\r\n(((u64)p[3] & 0x70) << 27) |\r\n(((u64)p[0] & 0x01) << 34);\r\nf->y_map = palm_data & (BIT(priv->y_bits) - 1);\r\nf->x_map = (palm_data >> priv->y_bits) &\r\n(BIT(priv->x_bits) - 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void alps_process_touchpad_packet_v3_v5(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nstruct input_dev *dev2 = priv->dev2;\r\nstruct alps_fields *f = &priv->f;\r\nint fingers = 0;\r\nmemset(f, 0, sizeof(*f));\r\npriv->decode_fields(f, packet, psmouse);\r\nif (priv->multi_packet) {\r\nif (f->is_mp) {\r\nfingers = f->fingers;\r\npriv->decode_fields(f, priv->multi_data, psmouse);\r\nif (alps_process_bitmap(priv, f) == 0)\r\nfingers = 0;\r\n} else {\r\npriv->multi_packet = 0;\r\n}\r\n}\r\nif (f->is_mp)\r\nreturn;\r\nif (!priv->multi_packet && f->first_mp) {\r\npriv->multi_packet = 1;\r\nmemcpy(priv->multi_data, packet, sizeof(priv->multi_data));\r\nreturn;\r\n}\r\npriv->multi_packet = 0;\r\nif (f->st.x && f->st.y && !f->pressure)\r\nreturn;\r\nalps_report_semi_mt_data(psmouse, fingers);\r\nif ((priv->flags & ALPS_DUALPOINT) &&\r\n!(priv->quirks & ALPS_QUIRK_TRACKSTICK_BUTTONS)) {\r\ninput_report_key(dev2, BTN_LEFT, f->ts_left);\r\ninput_report_key(dev2, BTN_RIGHT, f->ts_right);\r\ninput_report_key(dev2, BTN_MIDDLE, f->ts_middle);\r\ninput_sync(dev2);\r\n}\r\n}\r\nstatic void alps_process_packet_v3(struct psmouse *psmouse)\r\n{\r\nunsigned char *packet = psmouse->packet;\r\nif (packet[5] == 0x3f) {\r\nalps_process_trackstick_packet_v3(psmouse);\r\nreturn;\r\n}\r\nalps_process_touchpad_packet_v3_v5(psmouse);\r\n}\r\nstatic void alps_process_packet_v6(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct input_dev *dev2 = priv->dev2;\r\nint x, y, z, left, right, middle;\r\nif (packet[5] == 0x7F) {\r\nif (!(priv->flags & ALPS_DUALPOINT)) {\r\npsmouse_warn(psmouse,\r\n"Rejected trackstick packet from non DualPoint device");\r\nreturn;\r\n}\r\nx = packet[1] | ((packet[3] & 0x20) << 2);\r\ny = packet[2] | ((packet[3] & 0x40) << 1);\r\nz = packet[4];\r\nleft = packet[3] & 0x01;\r\nright = packet[3] & 0x02;\r\nmiddle = packet[3] & 0x04;\r\nif (x == 0x7F && y == 0x7F && z == 0x7F)\r\nx = y = z = 0;\r\ninput_report_rel(dev2, REL_X, (char)x / 4);\r\ninput_report_rel(dev2, REL_Y, -((char)y / 4));\r\ninput_report_key(dev2, BTN_LEFT, left);\r\ninput_report_key(dev2, BTN_RIGHT, right);\r\ninput_report_key(dev2, BTN_MIDDLE, middle);\r\ninput_sync(dev2);\r\nreturn;\r\n}\r\nx = packet[1] | ((packet[3] & 0x78) << 4);\r\ny = packet[2] | ((packet[4] & 0x78) << 4);\r\nz = packet[5];\r\nleft = packet[3] & 0x01;\r\nright = packet[3] & 0x02;\r\nif (z > 30)\r\ninput_report_key(dev, BTN_TOUCH, 1);\r\nif (z < 25)\r\ninput_report_key(dev, BTN_TOUCH, 0);\r\nif (z > 0) {\r\ninput_report_abs(dev, ABS_X, x);\r\ninput_report_abs(dev, ABS_Y, y);\r\n}\r\ninput_report_abs(dev, ABS_PRESSURE, z);\r\ninput_report_key(dev, BTN_TOOL_FINGER, z > 0);\r\ninput_report_key(dev, BTN_LEFT, left);\r\ninput_report_key(dev, BTN_RIGHT, right);\r\ninput_sync(dev);\r\n}\r\nstatic void alps_process_packet_v4(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nstruct alps_fields *f = &priv->f;\r\nint offset;\r\nif (packet[6] & 0x40) {\r\npriv->multi_packet = 0;\r\n}\r\nif (WARN_ON_ONCE(priv->multi_packet > 2))\r\nreturn;\r\noffset = 2 * priv->multi_packet;\r\npriv->multi_data[offset] = packet[6];\r\npriv->multi_data[offset + 1] = packet[7];\r\nf->left = !!(packet[4] & 0x01);\r\nf->right = !!(packet[4] & 0x02);\r\nf->st.x = ((packet[1] & 0x7f) << 4) | ((packet[3] & 0x30) >> 2) |\r\n((packet[0] & 0x30) >> 4);\r\nf->st.y = ((packet[2] & 0x7f) << 4) | (packet[3] & 0x0f);\r\nf->pressure = packet[5] & 0x7f;\r\nif (++priv->multi_packet > 2) {\r\npriv->multi_packet = 0;\r\nf->x_map = ((priv->multi_data[2] & 0x1f) << 10) |\r\n((priv->multi_data[3] & 0x60) << 3) |\r\n((priv->multi_data[0] & 0x3f) << 2) |\r\n((priv->multi_data[1] & 0x60) >> 5);\r\nf->y_map = ((priv->multi_data[5] & 0x01) << 10) |\r\n((priv->multi_data[3] & 0x1f) << 5) |\r\n(priv->multi_data[1] & 0x1f);\r\nf->fingers = alps_process_bitmap(priv, f);\r\n}\r\nalps_report_semi_mt_data(psmouse, f->fingers);\r\n}\r\nstatic bool alps_is_valid_package_v7(struct psmouse *psmouse)\r\n{\r\nswitch (psmouse->pktcnt) {\r\ncase 3:\r\nreturn (psmouse->packet[2] & 0x40) == 0x40;\r\ncase 4:\r\nreturn (psmouse->packet[3] & 0x48) == 0x48;\r\ncase 6:\r\nreturn (psmouse->packet[5] & 0x40) == 0x00;\r\n}\r\nreturn true;\r\n}\r\nstatic unsigned char alps_get_packet_id_v7(char *byte)\r\n{\r\nunsigned char packet_id;\r\nif (byte[4] & 0x40)\r\npacket_id = V7_PACKET_ID_TWO;\r\nelse if (byte[4] & 0x01)\r\npacket_id = V7_PACKET_ID_MULTI;\r\nelse if ((byte[0] & 0x10) && !(byte[4] & 0x43))\r\npacket_id = V7_PACKET_ID_NEW;\r\nelse if (byte[1] == 0x00 && byte[4] == 0x00)\r\npacket_id = V7_PACKET_ID_IDLE;\r\nelse\r\npacket_id = V7_PACKET_ID_UNKNOWN;\r\nreturn packet_id;\r\n}\r\nstatic void alps_get_finger_coordinate_v7(struct input_mt_pos *mt,\r\nunsigned char *pkt,\r\nunsigned char pkt_id)\r\n{\r\nmt[0].x = ((pkt[2] & 0x80) << 4);\r\nmt[0].x |= ((pkt[2] & 0x3F) << 5);\r\nmt[0].x |= ((pkt[3] & 0x30) >> 1);\r\nmt[0].x |= (pkt[3] & 0x07);\r\nmt[0].y = (pkt[1] << 3) | (pkt[0] & 0x07);\r\nmt[1].x = ((pkt[3] & 0x80) << 4);\r\nmt[1].x |= ((pkt[4] & 0x80) << 3);\r\nmt[1].x |= ((pkt[4] & 0x3F) << 4);\r\nmt[1].y = ((pkt[5] & 0x80) << 3);\r\nmt[1].y |= ((pkt[5] & 0x3F) << 4);\r\nswitch (pkt_id) {\r\ncase V7_PACKET_ID_TWO:\r\nmt[1].x &= ~0x000F;\r\nmt[1].y |= 0x000F;\r\nif (mt[1].y == 0x7ff && mt[1].x == 0xff0) {\r\nmt[1].x = 0;\r\n}\r\nbreak;\r\ncase V7_PACKET_ID_MULTI:\r\nmt[1].x &= ~0x003F;\r\nmt[1].y &= ~0x0020;\r\nmt[1].y |= ((pkt[4] & 0x02) << 4);\r\nmt[1].y |= 0x001F;\r\nbreak;\r\ncase V7_PACKET_ID_NEW:\r\nmt[1].x &= ~0x003F;\r\nmt[1].x |= (pkt[0] & 0x20);\r\nmt[1].y |= 0x000F;\r\nbreak;\r\n}\r\nmt[0].y = 0x7FF - mt[0].y;\r\nmt[1].y = 0x7FF - mt[1].y;\r\n}\r\nstatic int alps_get_mt_count(struct input_mt_pos *mt)\r\n{\r\nint i, fingers = 0;\r\nfor (i = 0; i < MAX_TOUCHES; i++) {\r\nif (mt[i].x != 0 || mt[i].y != 0)\r\nfingers++;\r\n}\r\nreturn fingers;\r\n}\r\nstatic int alps_decode_packet_v7(struct alps_fields *f,\r\nunsigned char *p,\r\nstruct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char pkt_id;\r\npkt_id = alps_get_packet_id_v7(p);\r\nif (pkt_id == V7_PACKET_ID_IDLE)\r\nreturn 0;\r\nif (pkt_id == V7_PACKET_ID_UNKNOWN)\r\nreturn -1;\r\nif (pkt_id == V7_PACKET_ID_NEW)\r\nreturn 1;\r\nalps_get_finger_coordinate_v7(f->mt, p, pkt_id);\r\nif (pkt_id == V7_PACKET_ID_TWO)\r\nf->fingers = alps_get_mt_count(f->mt);\r\nelse\r\nf->fingers = 3 + (p[5] & 0x03);\r\nf->left = (p[0] & 0x80) >> 7;\r\nif (priv->flags & ALPS_BUTTONPAD) {\r\nif (p[0] & 0x20)\r\nf->fingers++;\r\nif (p[0] & 0x10)\r\nf->fingers++;\r\n} else {\r\nf->right = (p[0] & 0x20) >> 5;\r\nf->middle = (p[0] & 0x10) >> 4;\r\n}\r\nif (f->fingers == 1 && f->mt[0].x == 0 && f->mt[0].y == 0) {\r\nf->mt[0].x = f->mt[1].x;\r\nf->mt[0].y = f->mt[1].y;\r\nf->mt[1].x = 0;\r\nf->mt[1].y = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void alps_process_trackstick_packet_v7(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nstruct input_dev *dev2 = priv->dev2;\r\nint x, y, z, left, right, middle;\r\nif (!(priv->flags & ALPS_DUALPOINT)) {\r\npsmouse_warn(psmouse,\r\n"Rejected trackstick packet from non DualPoint device");\r\nreturn;\r\n}\r\nx = ((packet[2] & 0xbf)) | ((packet[3] & 0x10) << 2);\r\ny = (packet[3] & 0x07) | (packet[4] & 0xb8) |\r\n((packet[3] & 0x20) << 1);\r\nz = (packet[5] & 0x3f) | ((packet[3] & 0x80) >> 1);\r\nleft = (packet[1] & 0x01);\r\nright = (packet[1] & 0x02) >> 1;\r\nmiddle = (packet[1] & 0x04) >> 2;\r\ninput_report_rel(dev2, REL_X, (char)x);\r\ninput_report_rel(dev2, REL_Y, -((char)y));\r\ninput_report_key(dev2, BTN_LEFT, left);\r\ninput_report_key(dev2, BTN_RIGHT, right);\r\ninput_report_key(dev2, BTN_MIDDLE, middle);\r\ninput_sync(dev2);\r\n}\r\nstatic void alps_process_touchpad_packet_v7(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct alps_fields *f = &priv->f;\r\nmemset(f, 0, sizeof(*f));\r\nif (priv->decode_fields(f, psmouse->packet, psmouse))\r\nreturn;\r\nalps_report_mt_data(psmouse, alps_get_mt_count(f->mt));\r\ninput_mt_report_finger_count(dev, f->fingers);\r\ninput_report_key(dev, BTN_LEFT, f->left);\r\ninput_report_key(dev, BTN_RIGHT, f->right);\r\ninput_report_key(dev, BTN_MIDDLE, f->middle);\r\ninput_sync(dev);\r\n}\r\nstatic void alps_process_packet_v7(struct psmouse *psmouse)\r\n{\r\nunsigned char *packet = psmouse->packet;\r\nif (packet[0] == 0x48 && (packet[4] & 0x47) == 0x06)\r\nalps_process_trackstick_packet_v7(psmouse);\r\nelse\r\nalps_process_touchpad_packet_v7(psmouse);\r\n}\r\nstatic unsigned char alps_get_pkt_id_ss4_v2(unsigned char *byte)\r\n{\r\nunsigned char pkt_id = SS4_PACKET_ID_IDLE;\r\nif (byte[0] == 0x18 && byte[1] == 0x10 && byte[2] == 0x00 &&\r\n(byte[3] & 0x88) == 0x08 && byte[4] == 0x10 && byte[5] == 0x00) {\r\npkt_id = SS4_PACKET_ID_IDLE;\r\n} else if (!(byte[3] & 0x10)) {\r\npkt_id = SS4_PACKET_ID_ONE;\r\n} else if (!(byte[3] & 0x20)) {\r\npkt_id = SS4_PACKET_ID_TWO;\r\n} else {\r\npkt_id = SS4_PACKET_ID_MULTI;\r\n}\r\nreturn pkt_id;\r\n}\r\nstatic int alps_decode_ss4_v2(struct alps_fields *f,\r\nunsigned char *p, struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char pkt_id;\r\nunsigned int no_data_x, no_data_y;\r\npkt_id = alps_get_pkt_id_ss4_v2(p);\r\nswitch (pkt_id) {\r\ncase SS4_PACKET_ID_ONE:\r\nf->mt[0].x = SS4_1F_X_V2(p);\r\nf->mt[0].y = SS4_1F_Y_V2(p);\r\nf->pressure = ((SS4_1F_Z_V2(p)) * 2) & 0x7f;\r\nf->fingers = 1;\r\nf->first_mp = 0;\r\nf->is_mp = 0;\r\nbreak;\r\ncase SS4_PACKET_ID_TWO:\r\nif (priv->flags & ALPS_BUTTONPAD) {\r\nf->mt[0].x = SS4_BTL_MF_X_V2(p, 0);\r\nf->mt[0].y = SS4_BTL_MF_Y_V2(p, 0);\r\nf->mt[1].x = SS4_BTL_MF_X_V2(p, 1);\r\nf->mt[1].y = SS4_BTL_MF_Y_V2(p, 1);\r\n} else {\r\nf->mt[0].x = SS4_STD_MF_X_V2(p, 0);\r\nf->mt[0].y = SS4_STD_MF_Y_V2(p, 0);\r\nf->mt[1].x = SS4_STD_MF_X_V2(p, 1);\r\nf->mt[1].y = SS4_STD_MF_Y_V2(p, 1);\r\n}\r\nf->pressure = SS4_MF_Z_V2(p, 0) ? 0x30 : 0;\r\nif (SS4_IS_MF_CONTINUE(p)) {\r\nf->first_mp = 1;\r\n} else {\r\nf->fingers = 2;\r\nf->first_mp = 0;\r\n}\r\nf->is_mp = 0;\r\nbreak;\r\ncase SS4_PACKET_ID_MULTI:\r\nif (priv->flags & ALPS_BUTTONPAD) {\r\nf->mt[2].x = SS4_BTL_MF_X_V2(p, 0);\r\nf->mt[2].y = SS4_BTL_MF_Y_V2(p, 0);\r\nf->mt[3].x = SS4_BTL_MF_X_V2(p, 1);\r\nf->mt[3].y = SS4_BTL_MF_Y_V2(p, 1);\r\nno_data_x = SS4_MFPACKET_NO_AX_BL;\r\nno_data_y = SS4_MFPACKET_NO_AY_BL;\r\n} else {\r\nf->mt[2].x = SS4_STD_MF_X_V2(p, 0);\r\nf->mt[2].y = SS4_STD_MF_Y_V2(p, 0);\r\nf->mt[3].x = SS4_STD_MF_X_V2(p, 1);\r\nf->mt[3].y = SS4_STD_MF_Y_V2(p, 1);\r\nno_data_x = SS4_MFPACKET_NO_AX;\r\nno_data_y = SS4_MFPACKET_NO_AY;\r\n}\r\nf->first_mp = 0;\r\nf->is_mp = 1;\r\nif (SS4_IS_5F_DETECTED(p)) {\r\nf->fingers = 5;\r\n} else if (f->mt[3].x == no_data_x &&\r\nf->mt[3].y == no_data_y) {\r\nf->mt[3].x = 0;\r\nf->mt[3].y = 0;\r\nf->fingers = 3;\r\n} else {\r\nf->fingers = 4;\r\n}\r\nbreak;\r\ncase SS4_PACKET_ID_IDLE:\r\ndefault:\r\nmemset(f, 0, sizeof(struct alps_fields));\r\nbreak;\r\n}\r\nf->left = !!(SS4_BTN_V2(p) & 0x01);\r\nif (!(priv->flags & ALPS_BUTTONPAD)) {\r\nf->right = !!(SS4_BTN_V2(p) & 0x02);\r\nf->middle = !!(SS4_BTN_V2(p) & 0x04);\r\n}\r\nreturn 0;\r\n}\r\nstatic void alps_process_packet_ss4_v2(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct alps_fields *f = &priv->f;\r\nmemset(f, 0, sizeof(struct alps_fields));\r\npriv->decode_fields(f, packet, psmouse);\r\nif (priv->multi_packet) {\r\nif (f->is_mp) {\r\npriv->decode_fields(f, priv->multi_data, psmouse);\r\n} else {\r\npriv->multi_packet = 0;\r\n}\r\n}\r\nif (f->is_mp)\r\nreturn;\r\nif (!priv->multi_packet && f->first_mp) {\r\npriv->multi_packet = 1;\r\nmemcpy(priv->multi_data, packet, sizeof(priv->multi_data));\r\nreturn;\r\n}\r\npriv->multi_packet = 0;\r\nalps_report_mt_data(psmouse, (f->fingers <= 4) ? f->fingers : 4);\r\ninput_mt_report_finger_count(dev, f->fingers);\r\ninput_report_key(dev, BTN_LEFT, f->left);\r\ninput_report_key(dev, BTN_RIGHT, f->right);\r\ninput_report_key(dev, BTN_MIDDLE, f->middle);\r\ninput_report_abs(dev, ABS_PRESSURE, f->pressure);\r\ninput_sync(dev);\r\n}\r\nstatic bool alps_is_valid_package_ss4_v2(struct psmouse *psmouse)\r\n{\r\nif (psmouse->pktcnt == 4 && ((psmouse->packet[3] & 0x08) != 0x08))\r\nreturn false;\r\nif (psmouse->pktcnt == 6 && ((psmouse->packet[5] & 0x10) != 0x0))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void alps_register_bare_ps2_mouse(struct work_struct *work)\r\n{\r\nstruct alps_data *priv =\r\ncontainer_of(work, struct alps_data, dev3_register_work.work);\r\nstruct psmouse *psmouse = priv->psmouse;\r\nstruct input_dev *dev3;\r\nint error = 0;\r\nmutex_lock(&alps_mutex);\r\nif (priv->dev3)\r\ngoto out;\r\ndev3 = input_allocate_device();\r\nif (!dev3) {\r\npsmouse_err(psmouse, "failed to allocate secondary device\n");\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nsnprintf(priv->phys3, sizeof(priv->phys3), "%s/%s",\r\npsmouse->ps2dev.serio->phys,\r\n(priv->dev2 ? "input2" : "input1"));\r\ndev3->phys = priv->phys3;\r\ndev3->name = "PS/2 ALPS Mouse";\r\ndev3->id.bustype = BUS_I8042;\r\ndev3->id.vendor = 0x0002;\r\ndev3->id.product = PSMOUSE_PS2;\r\ndev3->id.version = 0x0000;\r\ndev3->dev.parent = &psmouse->ps2dev.serio->dev;\r\ninput_set_capability(dev3, EV_REL, REL_X);\r\ninput_set_capability(dev3, EV_REL, REL_Y);\r\ninput_set_capability(dev3, EV_KEY, BTN_LEFT);\r\ninput_set_capability(dev3, EV_KEY, BTN_RIGHT);\r\ninput_set_capability(dev3, EV_KEY, BTN_MIDDLE);\r\n__set_bit(INPUT_PROP_POINTER, dev3->propbit);\r\nerror = input_register_device(dev3);\r\nif (error) {\r\npsmouse_err(psmouse,\r\n"failed to register secondary device: %d\n",\r\nerror);\r\ninput_free_device(dev3);\r\ngoto out;\r\n}\r\npriv->dev3 = dev3;\r\nout:\r\nif (error)\r\npriv->dev3 = ERR_PTR(error);\r\nmutex_unlock(&alps_mutex);\r\n}\r\nstatic void alps_report_bare_ps2_packet(struct psmouse *psmouse,\r\nunsigned char packet[],\r\nbool report_buttons)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nstruct input_dev *dev, *dev2 = NULL;\r\nif (priv->proto_version == ALPS_PROTO_V2 &&\r\n(priv->flags & ALPS_DUALPOINT)) {\r\ndev = priv->dev2;\r\ndev2 = psmouse->dev;\r\n} else if (unlikely(IS_ERR_OR_NULL(priv->dev3))) {\r\nif (!IS_ERR(priv->dev3))\r\npsmouse_queue_work(psmouse, &priv->dev3_register_work,\r\n0);\r\nreturn;\r\n} else {\r\ndev = priv->dev3;\r\n}\r\nif (report_buttons)\r\nalps_report_buttons(dev, dev2,\r\npacket[0] & 1, packet[0] & 2, packet[0] & 4);\r\ninput_report_rel(dev, REL_X,\r\npacket[1] ? packet[1] - ((packet[0] << 4) & 0x100) : 0);\r\ninput_report_rel(dev, REL_Y,\r\npacket[2] ? ((packet[0] << 3) & 0x100) - packet[2] : 0);\r\ninput_sync(dev);\r\n}\r\nstatic psmouse_ret_t alps_handle_interleaved_ps2(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nif (psmouse->pktcnt < 6)\r\nreturn PSMOUSE_GOOD_DATA;\r\nif (psmouse->pktcnt == 6) {\r\nmod_timer(&priv->timer, jiffies + msecs_to_jiffies(20));\r\nreturn PSMOUSE_GOOD_DATA;\r\n}\r\ndel_timer(&priv->timer);\r\nif (psmouse->packet[6] & 0x80) {\r\nif (((psmouse->packet[3] |\r\npsmouse->packet[4] |\r\npsmouse->packet[5]) & 0x80) ||\r\n(!alps_is_valid_first_byte(priv, psmouse->packet[6]))) {\r\npsmouse_dbg(psmouse,\r\n"refusing packet %4ph (suspected interleaved ps/2)\n",\r\npsmouse->packet + 3);\r\nreturn PSMOUSE_BAD_DATA;\r\n}\r\npriv->process_packet(psmouse);\r\npsmouse->packet[0] = psmouse->packet[6];\r\npsmouse->pktcnt = 1;\r\n} else {\r\nalps_report_bare_ps2_packet(psmouse, &psmouse->packet[3],\r\nfalse);\r\npsmouse->packet[3] = psmouse->packet[6] & 0xf7;\r\npsmouse->pktcnt = 4;\r\n}\r\nreturn PSMOUSE_GOOD_DATA;\r\n}\r\nstatic void alps_flush_packet(unsigned long data)\r\n{\r\nstruct psmouse *psmouse = (struct psmouse *)data;\r\nstruct alps_data *priv = psmouse->private;\r\nserio_pause_rx(psmouse->ps2dev.serio);\r\nif (psmouse->pktcnt == psmouse->pktsize) {\r\nif ((psmouse->packet[3] |\r\npsmouse->packet[4] |\r\npsmouse->packet[5]) & 0x80) {\r\npsmouse_dbg(psmouse,\r\n"refusing packet %3ph (suspected interleaved ps/2)\n",\r\npsmouse->packet + 3);\r\n} else {\r\npriv->process_packet(psmouse);\r\n}\r\npsmouse->pktcnt = 0;\r\n}\r\nserio_continue_rx(psmouse->ps2dev.serio);\r\n}\r\nstatic psmouse_ret_t alps_process_byte(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nif (priv->proto_version != ALPS_PROTO_V8 &&\r\n!psmouse->out_of_sync_cnt &&\r\n(psmouse->packet[0] & 0xc8) == 0x08) {\r\nif (psmouse->pktcnt == 3) {\r\nalps_report_bare_ps2_packet(psmouse, psmouse->packet,\r\ntrue);\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nreturn PSMOUSE_GOOD_DATA;\r\n}\r\nif ((priv->flags & ALPS_PS2_INTERLEAVED) &&\r\npsmouse->pktcnt >= 4 && (psmouse->packet[3] & 0x0f) == 0x0f) {\r\nreturn alps_handle_interleaved_ps2(psmouse);\r\n}\r\nif (!alps_is_valid_first_byte(priv, psmouse->packet[0])) {\r\npsmouse_dbg(psmouse,\r\n"refusing packet[0] = %x (mask0 = %x, byte0 = %x)\n",\r\npsmouse->packet[0], priv->mask0, priv->byte0);\r\nreturn PSMOUSE_BAD_DATA;\r\n}\r\nif (priv->proto_version < ALPS_PROTO_V5 &&\r\npsmouse->pktcnt >= 2 && psmouse->pktcnt <= psmouse->pktsize &&\r\n(psmouse->packet[psmouse->pktcnt - 1] & 0x80)) {\r\npsmouse_dbg(psmouse, "refusing packet[%i] = %x\n",\r\npsmouse->pktcnt - 1,\r\npsmouse->packet[psmouse->pktcnt - 1]);\r\nif (priv->proto_version == ALPS_PROTO_V3_RUSHMORE &&\r\npsmouse->pktcnt == psmouse->pktsize) {\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nreturn PSMOUSE_BAD_DATA;\r\n}\r\nif ((priv->proto_version == ALPS_PROTO_V7 &&\r\n!alps_is_valid_package_v7(psmouse)) ||\r\n(priv->proto_version == ALPS_PROTO_V8 &&\r\n!alps_is_valid_package_ss4_v2(psmouse))) {\r\npsmouse_dbg(psmouse, "refusing packet[%i] = %x\n",\r\npsmouse->pktcnt - 1,\r\npsmouse->packet[psmouse->pktcnt - 1]);\r\nreturn PSMOUSE_BAD_DATA;\r\n}\r\nif (psmouse->pktcnt == psmouse->pktsize) {\r\npriv->process_packet(psmouse);\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nreturn PSMOUSE_GOOD_DATA;\r\n}\r\nstatic int alps_command_mode_send_nibble(struct psmouse *psmouse, int nibble)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nstruct alps_data *priv = psmouse->private;\r\nint command;\r\nunsigned char *param;\r\nunsigned char dummy[4];\r\nBUG_ON(nibble > 0xf);\r\ncommand = priv->nibble_commands[nibble].command;\r\nparam = (command & 0x0f00) ?\r\ndummy : (unsigned char *)&priv->nibble_commands[nibble].data;\r\nif (ps2_command(ps2dev, param, command))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_command_mode_set_addr(struct psmouse *psmouse, int addr)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nstruct alps_data *priv = psmouse->private;\r\nint i, nibble;\r\nif (ps2_command(ps2dev, NULL, priv->addr_command))\r\nreturn -1;\r\nfor (i = 12; i >= 0; i -= 4) {\r\nnibble = (addr >> i) & 0xf;\r\nif (alps_command_mode_send_nibble(psmouse, nibble))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __alps_command_mode_read_reg(struct psmouse *psmouse, int addr)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[4];\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))\r\nreturn -1;\r\nif (addr != ((param[0] << 8) | param[1]))\r\nreturn -1;\r\nreturn param[2];\r\n}\r\nstatic int alps_command_mode_read_reg(struct psmouse *psmouse, int addr)\r\n{\r\nif (alps_command_mode_set_addr(psmouse, addr))\r\nreturn -1;\r\nreturn __alps_command_mode_read_reg(psmouse, addr);\r\n}\r\nstatic int __alps_command_mode_write_reg(struct psmouse *psmouse, u8 value)\r\n{\r\nif (alps_command_mode_send_nibble(psmouse, (value >> 4) & 0xf))\r\nreturn -1;\r\nif (alps_command_mode_send_nibble(psmouse, value & 0xf))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_command_mode_write_reg(struct psmouse *psmouse, int addr,\r\nu8 value)\r\n{\r\nif (alps_command_mode_set_addr(psmouse, addr))\r\nreturn -1;\r\nreturn __alps_command_mode_write_reg(psmouse, value);\r\n}\r\nstatic int alps_rpt_cmd(struct psmouse *psmouse, int init_command,\r\nint repeated_command, unsigned char *param)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nparam[0] = 0;\r\nif (init_command && ps2_command(ps2dev, param, init_command))\r\nreturn -EIO;\r\nif (ps2_command(ps2dev, NULL, repeated_command) ||\r\nps2_command(ps2dev, NULL, repeated_command) ||\r\nps2_command(ps2dev, NULL, repeated_command))\r\nreturn -EIO;\r\nparam[0] = param[1] = param[2] = 0xff;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))\r\nreturn -EIO;\r\npsmouse_dbg(psmouse, "%2.2X report: %3ph\n",\r\nrepeated_command, param);\r\nreturn 0;\r\n}\r\nstatic bool alps_check_valid_firmware_id(unsigned char id[])\r\n{\r\nif (id[0] == 0x73)\r\nreturn true;\r\nif (id[0] == 0x88 &&\r\n(id[1] == 0x07 ||\r\nid[1] == 0x08 ||\r\n(id[1] & 0xf0) == 0xb0 ||\r\n(id[1] & 0xf0) == 0xc0)) {\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int alps_enter_command_mode(struct psmouse *psmouse)\r\n{\r\nunsigned char param[4];\r\nif (alps_rpt_cmd(psmouse, 0, PSMOUSE_CMD_RESET_WRAP, param)) {\r\npsmouse_err(psmouse, "failed to enter command mode\n");\r\nreturn -1;\r\n}\r\nif (!alps_check_valid_firmware_id(param)) {\r\npsmouse_dbg(psmouse,\r\n"unknown response while entering command mode\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int alps_exit_command_mode(struct psmouse *psmouse)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSTREAM))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_passthrough_mode_v2(struct psmouse *psmouse, bool enable)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nint cmd = enable ? PSMOUSE_CMD_SETSCALE21 : PSMOUSE_CMD_SETSCALE11;\r\nif (ps2_command(ps2dev, NULL, cmd) ||\r\nps2_command(ps2dev, NULL, cmd) ||\r\nps2_command(ps2dev, NULL, cmd) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE))\r\nreturn -1;\r\nps2_drain(ps2dev, 3, 100);\r\nreturn 0;\r\n}\r\nstatic int alps_absolute_mode_v1_v2(struct psmouse *psmouse)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE))\r\nreturn -1;\r\nreturn ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETPOLL);\r\n}\r\nstatic int alps_monitor_mode_send_word(struct psmouse *psmouse, u16 word)\r\n{\r\nint i, nibble;\r\nfor (i = 0; i <= 8; i += 4) {\r\nnibble = (word >> i) & 0xf;\r\nif (alps_command_mode_send_nibble(psmouse, nibble))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int alps_monitor_mode_write_reg(struct psmouse *psmouse,\r\nu16 addr, u16 value)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE) ||\r\nalps_monitor_mode_send_word(psmouse, 0x0A0) ||\r\nalps_monitor_mode_send_word(psmouse, addr) ||\r\nalps_monitor_mode_send_word(psmouse, value) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_monitor_mode(struct psmouse *psmouse, bool enable)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nif (enable) {\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_RESET_WRAP) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_GETINFO) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE21) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE21) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_GETINFO))\r\nreturn -1;\r\n} else {\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_RESET_WRAP))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int alps_absolute_mode_v6(struct psmouse *psmouse)\r\n{\r\nu16 reg_val = 0x181;\r\nint ret = -1;\r\nif (alps_monitor_mode(psmouse, true))\r\nreturn -1;\r\nret = alps_monitor_mode_write_reg(psmouse, 0x000, reg_val);\r\nif (alps_monitor_mode(psmouse, false))\r\nret = -1;\r\nreturn ret;\r\n}\r\nstatic int alps_get_status(struct psmouse *psmouse, char *param)\r\n{\r\nif (alps_rpt_cmd(psmouse, 0, PSMOUSE_CMD_DISABLE, param))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_tap_mode(struct psmouse *psmouse, int enable)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nint cmd = enable ? PSMOUSE_CMD_SETRATE : PSMOUSE_CMD_SETRES;\r\nunsigned char tap_arg = enable ? 0x0A : 0x00;\r\nunsigned char param[4];\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, &tap_arg, cmd))\r\nreturn -1;\r\nif (alps_get_status(psmouse, param))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_poll(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char buf[sizeof(psmouse->packet)];\r\nbool poll_failed;\r\nif (priv->flags & ALPS_PASS)\r\nalps_passthrough_mode_v2(psmouse, true);\r\npoll_failed = ps2_command(&psmouse->ps2dev, buf,\r\nPSMOUSE_CMD_POLL | (psmouse->pktsize << 8)) < 0;\r\nif (priv->flags & ALPS_PASS)\r\nalps_passthrough_mode_v2(psmouse, false);\r\nif (poll_failed || (buf[0] & priv->mask0) != priv->byte0)\r\nreturn -1;\r\nif ((psmouse->badbyte & 0xc8) == 0x08) {\r\nif (ps2_command(&psmouse->ps2dev, buf, PSMOUSE_CMD_POLL | (3 << 8)))\r\nreturn -1;\r\n}\r\nmemcpy(psmouse->packet, buf, sizeof(buf));\r\nreturn 0;\r\n}\r\nstatic int alps_hw_init_v1_v2(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nif ((priv->flags & ALPS_PASS) &&\r\nalps_passthrough_mode_v2(psmouse, true)) {\r\nreturn -1;\r\n}\r\nif (alps_tap_mode(psmouse, true)) {\r\npsmouse_warn(psmouse, "Failed to enable hardware tapping\n");\r\nreturn -1;\r\n}\r\nif (alps_absolute_mode_v1_v2(psmouse)) {\r\npsmouse_err(psmouse, "Failed to enable absolute mode\n");\r\nreturn -1;\r\n}\r\nif ((priv->flags & ALPS_PASS) &&\r\nalps_passthrough_mode_v2(psmouse, false)) {\r\nreturn -1;\r\n}\r\nif (ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETSTREAM)) {\r\npsmouse_err(psmouse, "Failed to enable stream mode\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int alps_hw_init_v6(struct psmouse *psmouse)\r\n{\r\nunsigned char param[2] = {0xC8, 0x14};\r\nif (alps_passthrough_mode_v2(psmouse, true))\r\nreturn -1;\r\nif (ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(&psmouse->ps2dev, &param[0], PSMOUSE_CMD_SETRATE) ||\r\nps2_command(&psmouse->ps2dev, &param[1], PSMOUSE_CMD_SETRATE))\r\nreturn -1;\r\nif (alps_passthrough_mode_v2(psmouse, false))\r\nreturn -1;\r\nif (alps_absolute_mode_v6(psmouse)) {\r\npsmouse_err(psmouse, "Failed to enable absolute mode\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int alps_passthrough_mode_v3(struct psmouse *psmouse,\r\nint reg_base, bool enable)\r\n{\r\nint reg_val, ret = -1;\r\nif (alps_enter_command_mode(psmouse))\r\nreturn -1;\r\nreg_val = alps_command_mode_read_reg(psmouse, reg_base + 0x0008);\r\nif (reg_val == -1)\r\ngoto error;\r\nif (enable)\r\nreg_val |= 0x01;\r\nelse\r\nreg_val &= ~0x01;\r\nret = __alps_command_mode_write_reg(psmouse, reg_val);\r\nerror:\r\nif (alps_exit_command_mode(psmouse))\r\nret = -1;\r\nreturn ret;\r\n}\r\nstatic int alps_absolute_mode_v3(struct psmouse *psmouse)\r\n{\r\nint reg_val;\r\nreg_val = alps_command_mode_read_reg(psmouse, 0x0004);\r\nif (reg_val == -1)\r\nreturn -1;\r\nreg_val |= 0x06;\r\nif (__alps_command_mode_write_reg(psmouse, reg_val))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_probe_trackstick_v3(struct psmouse *psmouse, int reg_base)\r\n{\r\nint ret = -EIO, reg_val;\r\nif (alps_enter_command_mode(psmouse))\r\ngoto error;\r\nreg_val = alps_command_mode_read_reg(psmouse, reg_base + 0x08);\r\nif (reg_val == -1)\r\ngoto error;\r\nret = reg_val & 0x80 ? 0 : -ENODEV;\r\nerror:\r\nalps_exit_command_mode(psmouse);\r\nreturn ret;\r\n}\r\nstatic int alps_setup_trackstick_v3(struct psmouse *psmouse, int reg_base)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nint ret = 0;\r\nunsigned char param[4];\r\nif (alps_passthrough_mode_v3(psmouse, reg_base, true))\r\nreturn -EIO;\r\nif (alps_rpt_cmd(psmouse, 0, PSMOUSE_CMD_SETSCALE21, param)) {\r\npsmouse_warn(psmouse, "Failed to initialize trackstick (E7 report failed)\n");\r\nret = -ENODEV;\r\n} else {\r\npsmouse_dbg(psmouse, "trackstick E7 report: %3ph\n", param);\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nalps_command_mode_send_nibble(psmouse, 0x9) ||\r\nalps_command_mode_send_nibble(psmouse, 0x4)) {\r\npsmouse_err(psmouse,\r\n"Error sending magic E6 sequence\n");\r\nret = -EIO;\r\ngoto error;\r\n}\r\nif (alps_enter_command_mode(psmouse) ||\r\nalps_command_mode_write_reg(psmouse,\r\nreg_base + 0x08, 0x82) ||\r\nalps_exit_command_mode(psmouse))\r\nret = -EIO;\r\n}\r\nerror:\r\nif (alps_passthrough_mode_v3(psmouse, reg_base, false))\r\nret = -EIO;\r\nreturn ret;\r\n}\r\nstatic int alps_hw_init_v3(struct psmouse *psmouse)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nint reg_val;\r\nunsigned char param[4];\r\nreg_val = alps_probe_trackstick_v3(psmouse, ALPS_REG_BASE_PINNACLE);\r\nif (reg_val == -EIO)\r\ngoto error;\r\nif (reg_val == 0 &&\r\nalps_setup_trackstick_v3(psmouse, ALPS_REG_BASE_PINNACLE) == -EIO)\r\ngoto error;\r\nif (alps_enter_command_mode(psmouse) ||\r\nalps_absolute_mode_v3(psmouse)) {\r\npsmouse_err(psmouse, "Failed to enter absolute mode\n");\r\ngoto error;\r\n}\r\nreg_val = alps_command_mode_read_reg(psmouse, 0x0006);\r\nif (reg_val == -1)\r\ngoto error;\r\nif (__alps_command_mode_write_reg(psmouse, reg_val | 0x01))\r\ngoto error;\r\nreg_val = alps_command_mode_read_reg(psmouse, 0x0007);\r\nif (reg_val == -1)\r\ngoto error;\r\nif (__alps_command_mode_write_reg(psmouse, reg_val | 0x01))\r\ngoto error;\r\nif (alps_command_mode_read_reg(psmouse, 0x0144) == -1)\r\ngoto error;\r\nif (__alps_command_mode_write_reg(psmouse, 0x04))\r\ngoto error;\r\nif (alps_command_mode_read_reg(psmouse, 0x0159) == -1)\r\ngoto error;\r\nif (__alps_command_mode_write_reg(psmouse, 0x03))\r\ngoto error;\r\nif (alps_command_mode_read_reg(psmouse, 0x0163) == -1)\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0163, 0x03))\r\ngoto error;\r\nif (alps_command_mode_read_reg(psmouse, 0x0162) == -1)\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0162, 0x04))\r\ngoto error;\r\nalps_exit_command_mode(psmouse);\r\nparam[0] = 0x64;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE)) {\r\npsmouse_err(psmouse, "Failed to enable data reporting\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\nerror:\r\nalps_exit_command_mode(psmouse);\r\nreturn -1;\r\n}\r\nstatic int alps_get_v3_v7_resolution(struct psmouse *psmouse, int reg_pitch)\r\n{\r\nint reg, x_pitch, y_pitch, x_electrode, y_electrode, x_phys, y_phys;\r\nstruct alps_data *priv = psmouse->private;\r\nreg = alps_command_mode_read_reg(psmouse, reg_pitch);\r\nif (reg < 0)\r\nreturn reg;\r\nx_pitch = (char)(reg << 4) >> 4;\r\nx_pitch = 50 + 2 * x_pitch;\r\ny_pitch = (char)reg >> 4;\r\ny_pitch = 36 + 2 * y_pitch;\r\nreg = alps_command_mode_read_reg(psmouse, reg_pitch + 1);\r\nif (reg < 0)\r\nreturn reg;\r\nx_electrode = (char)(reg << 4) >> 4;\r\nx_electrode = 17 + x_electrode;\r\ny_electrode = (char)reg >> 4;\r\ny_electrode = 13 + y_electrode;\r\nx_phys = x_pitch * (x_electrode - 1);\r\ny_phys = y_pitch * (y_electrode - 1);\r\npriv->x_res = priv->x_max * 10 / x_phys;\r\npriv->y_res = priv->y_max * 10 / y_phys;\r\npsmouse_dbg(psmouse,\r\n"pitch %dx%d num-electrodes %dx%d physical size %dx%d mm res %dx%d\n",\r\nx_pitch, y_pitch, x_electrode, y_electrode,\r\nx_phys / 10, y_phys / 10, priv->x_res, priv->y_res);\r\nreturn 0;\r\n}\r\nstatic int alps_hw_init_rushmore_v3(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nint reg_val, ret = -1;\r\nif (priv->flags & ALPS_DUALPOINT) {\r\nreg_val = alps_setup_trackstick_v3(psmouse,\r\nALPS_REG_BASE_RUSHMORE);\r\nif (reg_val == -EIO)\r\ngoto error;\r\n}\r\nif (alps_enter_command_mode(psmouse) ||\r\nalps_command_mode_read_reg(psmouse, 0xc2d9) == -1 ||\r\nalps_command_mode_write_reg(psmouse, 0xc2cb, 0x00))\r\ngoto error;\r\nif (alps_get_v3_v7_resolution(psmouse, 0xc2da))\r\ngoto error;\r\nreg_val = alps_command_mode_read_reg(psmouse, 0xc2c6);\r\nif (reg_val == -1)\r\ngoto error;\r\nif (__alps_command_mode_write_reg(psmouse, reg_val & 0xfd))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0xc2c9, 0x64))\r\ngoto error;\r\nreg_val = alps_command_mode_read_reg(psmouse, 0xc2c4);\r\nif (reg_val == -1)\r\ngoto error;\r\nif (__alps_command_mode_write_reg(psmouse, reg_val | 0x02))\r\ngoto error;\r\nalps_exit_command_mode(psmouse);\r\nreturn ps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE);\r\nerror:\r\nalps_exit_command_mode(psmouse);\r\nreturn ret;\r\n}\r\nstatic int alps_absolute_mode_v4(struct psmouse *psmouse)\r\n{\r\nint reg_val;\r\nreg_val = alps_command_mode_read_reg(psmouse, 0x0004);\r\nif (reg_val == -1)\r\nreturn -1;\r\nreg_val |= 0x02;\r\nif (__alps_command_mode_write_reg(psmouse, reg_val))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_hw_init_v4(struct psmouse *psmouse)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[4];\r\nif (alps_enter_command_mode(psmouse))\r\ngoto error;\r\nif (alps_absolute_mode_v4(psmouse)) {\r\npsmouse_err(psmouse, "Failed to enter absolute mode\n");\r\ngoto error;\r\n}\r\nif (alps_command_mode_write_reg(psmouse, 0x0007, 0x8c))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0149, 0x03))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0160, 0x03))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x017f, 0x15))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0151, 0x01))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0168, 0x03))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x014a, 0x03))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0161, 0x03))\r\ngoto error;\r\nalps_exit_command_mode(psmouse);\r\nparam[0] = 0xc8;\r\nparam[1] = 0x64;\r\nparam[2] = 0x50;\r\nif (ps2_command(ps2dev, &param[0], PSMOUSE_CMD_SETRATE) ||\r\nps2_command(ps2dev, &param[1], PSMOUSE_CMD_SETRATE) ||\r\nps2_command(ps2dev, &param[2], PSMOUSE_CMD_SETRATE) ||\r\nps2_command(ps2dev, param, PSMOUSE_CMD_GETID))\r\nreturn -1;\r\nparam[0] = 0x64;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE)) {\r\npsmouse_err(psmouse, "Failed to enable data reporting\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\nerror:\r\nalps_exit_command_mode(psmouse);\r\nreturn -1;\r\n}\r\nstatic int alps_get_otp_values_ss4_v2(struct psmouse *psmouse,\r\nunsigned char index, unsigned char otp[])\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nswitch (index) {\r\ncase 0:\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSTREAM) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSTREAM) ||\r\nps2_command(ps2dev, otp, PSMOUSE_CMD_GETINFO))\r\nreturn -1;\r\nbreak;\r\ncase 1:\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETPOLL) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETPOLL) ||\r\nps2_command(ps2dev, otp, PSMOUSE_CMD_GETINFO))\r\nreturn -1;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int alps_update_device_area_ss4_v2(unsigned char otp[][4],\r\nstruct alps_data *priv)\r\n{\r\nint num_x_electrode;\r\nint num_y_electrode;\r\nint x_pitch, y_pitch, x_phys, y_phys;\r\nnum_x_electrode = SS4_NUMSENSOR_XOFFSET + (otp[1][0] & 0x0F);\r\nnum_y_electrode = SS4_NUMSENSOR_YOFFSET + ((otp[1][0] >> 4) & 0x0F);\r\npriv->x_max = (num_x_electrode - 1) * SS4_COUNT_PER_ELECTRODE;\r\npriv->y_max = (num_y_electrode - 1) * SS4_COUNT_PER_ELECTRODE;\r\nx_pitch = ((otp[1][2] >> 2) & 0x07) + SS4_MIN_PITCH_MM;\r\ny_pitch = ((otp[1][2] >> 5) & 0x07) + SS4_MIN_PITCH_MM;\r\nx_phys = x_pitch * (num_x_electrode - 1);\r\ny_phys = y_pitch * (num_y_electrode - 1);\r\npriv->x_res = priv->x_max * 10 / x_phys;\r\npriv->y_res = priv->y_max * 10 / y_phys;\r\nreturn 0;\r\n}\r\nstatic int alps_update_btn_info_ss4_v2(unsigned char otp[][4],\r\nstruct alps_data *priv)\r\n{\r\nunsigned char is_btnless;\r\nis_btnless = (otp[1][1] >> 3) & 0x01;\r\nif (is_btnless)\r\npriv->flags |= ALPS_BUTTONPAD;\r\nreturn 0;\r\n}\r\nstatic int alps_set_defaults_ss4_v2(struct psmouse *psmouse,\r\nstruct alps_data *priv)\r\n{\r\nunsigned char otp[2][4];\r\nmemset(otp, 0, sizeof(otp));\r\nif (alps_get_otp_values_ss4_v2(psmouse, 0, &otp[0][0]) ||\r\nalps_get_otp_values_ss4_v2(psmouse, 1, &otp[1][0]))\r\nreturn -1;\r\nalps_update_device_area_ss4_v2(otp, priv);\r\nalps_update_btn_info_ss4_v2(otp, priv);\r\nreturn 0;\r\n}\r\nstatic int alps_dolphin_get_device_area(struct psmouse *psmouse,\r\nstruct alps_data *priv)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[4] = {0};\r\nint num_x_electrode, num_y_electrode;\r\nif (alps_enter_command_mode(psmouse))\r\nreturn -1;\r\nparam[0] = 0x0a;\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_RESET_WRAP) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETPOLL) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETPOLL) ||\r\nps2_command(ps2dev, &param[0], PSMOUSE_CMD_SETRATE) ||\r\nps2_command(ps2dev, &param[0], PSMOUSE_CMD_SETRATE))\r\nreturn -1;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))\r\nreturn -1;\r\nnum_x_electrode = DOLPHIN_PROFILE_XOFFSET + (param[2] & 0x0F);\r\nnum_y_electrode = DOLPHIN_PROFILE_YOFFSET + ((param[2] >> 4) & 0x0F);\r\npriv->x_bits = num_x_electrode;\r\npriv->y_bits = num_y_electrode;\r\npriv->x_max = (num_x_electrode - 1) * DOLPHIN_COUNT_PER_ELECTRODE;\r\npriv->y_max = (num_y_electrode - 1) * DOLPHIN_COUNT_PER_ELECTRODE;\r\nif (alps_exit_command_mode(psmouse))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_hw_init_dolphin_v1(struct psmouse *psmouse)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[2];\r\nparam[0] = 0x64;\r\nparam[1] = 0x28;\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSTREAM) ||\r\nps2_command(ps2dev, &param[0], PSMOUSE_CMD_SETRATE) ||\r\nps2_command(ps2dev, &param[1], PSMOUSE_CMD_SETRATE))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_hw_init_v7(struct psmouse *psmouse)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nint reg_val, ret = -1;\r\nif (alps_enter_command_mode(psmouse) ||\r\nalps_command_mode_read_reg(psmouse, 0xc2d9) == -1)\r\ngoto error;\r\nif (alps_get_v3_v7_resolution(psmouse, 0xc397))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0xc2c9, 0x64))\r\ngoto error;\r\nreg_val = alps_command_mode_read_reg(psmouse, 0xc2c4);\r\nif (reg_val == -1)\r\ngoto error;\r\nif (__alps_command_mode_write_reg(psmouse, reg_val | 0x02))\r\ngoto error;\r\nalps_exit_command_mode(psmouse);\r\nreturn ps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE);\r\nerror:\r\nalps_exit_command_mode(psmouse);\r\nreturn ret;\r\n}\r\nstatic int alps_hw_init_ss4_v2(struct psmouse *psmouse)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nchar param[2] = {0x64, 0x28};\r\nint ret = -1;\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSTREAM) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSTREAM) ||\r\nps2_command(ps2dev, &param[0], PSMOUSE_CMD_SETRATE) ||\r\nps2_command(ps2dev, &param[1], PSMOUSE_CMD_SETRATE)) {\r\ngoto error;\r\n}\r\nif (alps_exit_command_mode(psmouse) ||\r\nalps_enter_command_mode(psmouse) ||\r\nalps_command_mode_write_reg(psmouse, 0x001D, 0x20)) {\r\ngoto error;\r\n}\r\nalps_exit_command_mode(psmouse);\r\nreturn ps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE);\r\nerror:\r\nalps_exit_command_mode(psmouse);\r\nreturn ret;\r\n}\r\nstatic int alps_set_protocol(struct psmouse *psmouse,\r\nstruct alps_data *priv,\r\nconst struct alps_protocol_info *protocol)\r\n{\r\npsmouse->private = priv;\r\nsetup_timer(&priv->timer, alps_flush_packet, (unsigned long)psmouse);\r\npriv->proto_version = protocol->version;\r\npriv->byte0 = protocol->byte0;\r\npriv->mask0 = protocol->mask0;\r\npriv->flags = protocol->flags;\r\npriv->x_max = 2000;\r\npriv->y_max = 1400;\r\npriv->x_bits = 15;\r\npriv->y_bits = 11;\r\nswitch (priv->proto_version) {\r\ncase ALPS_PROTO_V1:\r\ncase ALPS_PROTO_V2:\r\npriv->hw_init = alps_hw_init_v1_v2;\r\npriv->process_packet = alps_process_packet_v1_v2;\r\npriv->set_abs_params = alps_set_abs_params_st;\r\npriv->x_max = 1023;\r\npriv->y_max = 767;\r\nif (dmi_check_system(alps_dmi_has_separate_stick_buttons))\r\npriv->flags |= ALPS_STICK_BITS;\r\nbreak;\r\ncase ALPS_PROTO_V3:\r\npriv->hw_init = alps_hw_init_v3;\r\npriv->process_packet = alps_process_packet_v3;\r\npriv->set_abs_params = alps_set_abs_params_semi_mt;\r\npriv->decode_fields = alps_decode_pinnacle;\r\npriv->nibble_commands = alps_v3_nibble_commands;\r\npriv->addr_command = PSMOUSE_CMD_RESET_WRAP;\r\nbreak;\r\ncase ALPS_PROTO_V3_RUSHMORE:\r\npriv->hw_init = alps_hw_init_rushmore_v3;\r\npriv->process_packet = alps_process_packet_v3;\r\npriv->set_abs_params = alps_set_abs_params_semi_mt;\r\npriv->decode_fields = alps_decode_rushmore;\r\npriv->nibble_commands = alps_v3_nibble_commands;\r\npriv->addr_command = PSMOUSE_CMD_RESET_WRAP;\r\npriv->x_bits = 16;\r\npriv->y_bits = 12;\r\nif (alps_probe_trackstick_v3(psmouse,\r\nALPS_REG_BASE_RUSHMORE) < 0)\r\npriv->flags &= ~ALPS_DUALPOINT;\r\nbreak;\r\ncase ALPS_PROTO_V4:\r\npriv->hw_init = alps_hw_init_v4;\r\npriv->process_packet = alps_process_packet_v4;\r\npriv->set_abs_params = alps_set_abs_params_semi_mt;\r\npriv->nibble_commands = alps_v4_nibble_commands;\r\npriv->addr_command = PSMOUSE_CMD_DISABLE;\r\nbreak;\r\ncase ALPS_PROTO_V5:\r\npriv->hw_init = alps_hw_init_dolphin_v1;\r\npriv->process_packet = alps_process_touchpad_packet_v3_v5;\r\npriv->decode_fields = alps_decode_dolphin;\r\npriv->set_abs_params = alps_set_abs_params_semi_mt;\r\npriv->nibble_commands = alps_v3_nibble_commands;\r\npriv->addr_command = PSMOUSE_CMD_RESET_WRAP;\r\npriv->x_bits = 23;\r\npriv->y_bits = 12;\r\nif (alps_dolphin_get_device_area(psmouse, priv))\r\nreturn -EIO;\r\nbreak;\r\ncase ALPS_PROTO_V6:\r\npriv->hw_init = alps_hw_init_v6;\r\npriv->process_packet = alps_process_packet_v6;\r\npriv->set_abs_params = alps_set_abs_params_st;\r\npriv->nibble_commands = alps_v6_nibble_commands;\r\npriv->x_max = 2047;\r\npriv->y_max = 1535;\r\nbreak;\r\ncase ALPS_PROTO_V7:\r\npriv->hw_init = alps_hw_init_v7;\r\npriv->process_packet = alps_process_packet_v7;\r\npriv->decode_fields = alps_decode_packet_v7;\r\npriv->set_abs_params = alps_set_abs_params_v7;\r\npriv->nibble_commands = alps_v3_nibble_commands;\r\npriv->addr_command = PSMOUSE_CMD_RESET_WRAP;\r\npriv->x_max = 0xfff;\r\npriv->y_max = 0x7ff;\r\nif (priv->fw_ver[1] != 0xba)\r\npriv->flags |= ALPS_BUTTONPAD;\r\nbreak;\r\ncase ALPS_PROTO_V8:\r\npriv->hw_init = alps_hw_init_ss4_v2;\r\npriv->process_packet = alps_process_packet_ss4_v2;\r\npriv->decode_fields = alps_decode_ss4_v2;\r\npriv->set_abs_params = alps_set_abs_params_ss4_v2;\r\npriv->nibble_commands = alps_v3_nibble_commands;\r\npriv->addr_command = PSMOUSE_CMD_RESET_WRAP;\r\nif (alps_set_defaults_ss4_v2(psmouse, priv))\r\nreturn -EIO;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic const struct alps_protocol_info *alps_match_table(unsigned char *e7,\r\nunsigned char *ec)\r\n{\r\nconst struct alps_model_info *model;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(alps_model_data); i++) {\r\nmodel = &alps_model_data[i];\r\nif (!memcmp(e7, model->signature, sizeof(model->signature)) &&\r\n(!model->command_mode_resp ||\r\nmodel->command_mode_resp == ec[2])) {\r\nreturn &model->protocol_info;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int alps_identify(struct psmouse *psmouse, struct alps_data *priv)\r\n{\r\nconst struct alps_protocol_info *protocol;\r\nunsigned char e6[4], e7[4], ec[4];\r\nint error;\r\nif (alps_rpt_cmd(psmouse, PSMOUSE_CMD_SETRES,\r\nPSMOUSE_CMD_SETSCALE11, e6))\r\nreturn -EIO;\r\nif ((e6[0] & 0xf8) != 0 || e6[1] != 0 || (e6[2] != 10 && e6[2] != 100))\r\nreturn -EINVAL;\r\nif (alps_rpt_cmd(psmouse, PSMOUSE_CMD_SETRES,\r\nPSMOUSE_CMD_SETSCALE21, e7) ||\r\nalps_rpt_cmd(psmouse, PSMOUSE_CMD_SETRES,\r\nPSMOUSE_CMD_RESET_WRAP, ec) ||\r\nalps_exit_command_mode(psmouse))\r\nreturn -EIO;\r\nprotocol = alps_match_table(e7, ec);\r\nif (!protocol) {\r\nif (e7[0] == 0x73 && e7[1] == 0x03 && e7[2] == 0x50 &&\r\nec[0] == 0x73 && (ec[1] == 0x01 || ec[1] == 0x02)) {\r\nprotocol = &alps_v5_protocol_data;\r\n} else if (ec[0] == 0x88 &&\r\n((ec[1] & 0xf0) == 0xb0 || (ec[1] & 0xf0) == 0xc0)) {\r\nprotocol = &alps_v7_protocol_data;\r\n} else if (ec[0] == 0x88 && ec[1] == 0x08) {\r\nprotocol = &alps_v3_rushmore_data;\r\n} else if (ec[0] == 0x88 && ec[1] == 0x07 &&\r\nec[2] >= 0x90 && ec[2] <= 0x9d) {\r\nprotocol = &alps_v3_protocol_data;\r\n} else if (e7[0] == 0x73 && e7[1] == 0x03 &&\r\ne7[2] == 0x14 && ec[1] == 0x02) {\r\nprotocol = &alps_v8_protocol_data;\r\n} else {\r\npsmouse_dbg(psmouse,\r\n"Likely not an ALPS touchpad: E7=%3ph, EC=%3ph\n", e7, ec);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (priv) {\r\nmemcpy(priv->fw_ver, ec, 3);\r\nerror = alps_set_protocol(psmouse, priv, protocol);\r\nif (error)\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int alps_reconnect(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\npsmouse_reset(psmouse);\r\nif (alps_identify(psmouse, priv) < 0)\r\nreturn -1;\r\nreturn priv->hw_init(psmouse);\r\n}\r\nstatic void alps_disconnect(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\npsmouse_reset(psmouse);\r\ndel_timer_sync(&priv->timer);\r\nif (priv->dev2)\r\ninput_unregister_device(priv->dev2);\r\nif (!IS_ERR_OR_NULL(priv->dev3))\r\ninput_unregister_device(priv->dev3);\r\nkfree(priv);\r\n}\r\nstatic void alps_set_abs_params_st(struct alps_data *priv,\r\nstruct input_dev *dev1)\r\n{\r\ninput_set_abs_params(dev1, ABS_X, 0, priv->x_max, 0, 0);\r\ninput_set_abs_params(dev1, ABS_Y, 0, priv->y_max, 0, 0);\r\ninput_set_abs_params(dev1, ABS_PRESSURE, 0, 127, 0, 0);\r\n}\r\nstatic void alps_set_abs_params_mt_common(struct alps_data *priv,\r\nstruct input_dev *dev1)\r\n{\r\ninput_set_abs_params(dev1, ABS_MT_POSITION_X, 0, priv->x_max, 0, 0);\r\ninput_set_abs_params(dev1, ABS_MT_POSITION_Y, 0, priv->y_max, 0, 0);\r\ninput_abs_set_res(dev1, ABS_MT_POSITION_X, priv->x_res);\r\ninput_abs_set_res(dev1, ABS_MT_POSITION_Y, priv->y_res);\r\nset_bit(BTN_TOOL_TRIPLETAP, dev1->keybit);\r\nset_bit(BTN_TOOL_QUADTAP, dev1->keybit);\r\n}\r\nstatic void alps_set_abs_params_semi_mt(struct alps_data *priv,\r\nstruct input_dev *dev1)\r\n{\r\nalps_set_abs_params_mt_common(priv, dev1);\r\ninput_set_abs_params(dev1, ABS_PRESSURE, 0, 127, 0, 0);\r\ninput_mt_init_slots(dev1, MAX_TOUCHES,\r\nINPUT_MT_POINTER | INPUT_MT_DROP_UNUSED |\r\nINPUT_MT_SEMI_MT);\r\n}\r\nstatic void alps_set_abs_params_v7(struct alps_data *priv,\r\nstruct input_dev *dev1)\r\n{\r\nalps_set_abs_params_mt_common(priv, dev1);\r\nset_bit(BTN_TOOL_QUINTTAP, dev1->keybit);\r\ninput_mt_init_slots(dev1, MAX_TOUCHES,\r\nINPUT_MT_POINTER | INPUT_MT_DROP_UNUSED |\r\nINPUT_MT_TRACK);\r\nset_bit(BTN_TOOL_QUINTTAP, dev1->keybit);\r\n}\r\nstatic void alps_set_abs_params_ss4_v2(struct alps_data *priv,\r\nstruct input_dev *dev1)\r\n{\r\nalps_set_abs_params_mt_common(priv, dev1);\r\ninput_set_abs_params(dev1, ABS_PRESSURE, 0, 127, 0, 0);\r\nset_bit(BTN_TOOL_QUINTTAP, dev1->keybit);\r\ninput_mt_init_slots(dev1, MAX_TOUCHES,\r\nINPUT_MT_POINTER | INPUT_MT_DROP_UNUSED |\r\nINPUT_MT_TRACK);\r\n}\r\nint alps_init(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nstruct input_dev *dev1 = psmouse->dev;\r\nint error;\r\nerror = priv->hw_init(psmouse);\r\nif (error)\r\ngoto init_fail;\r\n__clear_bit(EV_REL, dev1->evbit);\r\n__clear_bit(REL_X, dev1->relbit);\r\n__clear_bit(REL_Y, dev1->relbit);\r\ndev1->evbit[BIT_WORD(EV_KEY)] |= BIT_MASK(EV_KEY);\r\ndev1->keybit[BIT_WORD(BTN_TOUCH)] |= BIT_MASK(BTN_TOUCH);\r\ndev1->keybit[BIT_WORD(BTN_TOOL_FINGER)] |= BIT_MASK(BTN_TOOL_FINGER);\r\ndev1->keybit[BIT_WORD(BTN_LEFT)] |=\r\nBIT_MASK(BTN_LEFT) | BIT_MASK(BTN_RIGHT);\r\ndev1->evbit[BIT_WORD(EV_ABS)] |= BIT_MASK(EV_ABS);\r\npriv->set_abs_params(priv, dev1);\r\nif (priv->flags & ALPS_WHEEL) {\r\ndev1->evbit[BIT_WORD(EV_REL)] |= BIT_MASK(EV_REL);\r\ndev1->relbit[BIT_WORD(REL_WHEEL)] |= BIT_MASK(REL_WHEEL);\r\n}\r\nif (priv->flags & (ALPS_FW_BK_1 | ALPS_FW_BK_2)) {\r\ndev1->keybit[BIT_WORD(BTN_FORWARD)] |= BIT_MASK(BTN_FORWARD);\r\ndev1->keybit[BIT_WORD(BTN_BACK)] |= BIT_MASK(BTN_BACK);\r\n}\r\nif (priv->flags & ALPS_FOUR_BUTTONS) {\r\ndev1->keybit[BIT_WORD(BTN_0)] |= BIT_MASK(BTN_0);\r\ndev1->keybit[BIT_WORD(BTN_1)] |= BIT_MASK(BTN_1);\r\ndev1->keybit[BIT_WORD(BTN_2)] |= BIT_MASK(BTN_2);\r\ndev1->keybit[BIT_WORD(BTN_3)] |= BIT_MASK(BTN_3);\r\n} else if (priv->flags & ALPS_BUTTONPAD) {\r\nset_bit(INPUT_PROP_BUTTONPAD, dev1->propbit);\r\nclear_bit(BTN_RIGHT, dev1->keybit);\r\n} else {\r\ndev1->keybit[BIT_WORD(BTN_MIDDLE)] |= BIT_MASK(BTN_MIDDLE);\r\n}\r\nif (priv->flags & ALPS_DUALPOINT) {\r\nstruct input_dev *dev2;\r\ndev2 = input_allocate_device();\r\nif (!dev2) {\r\npsmouse_err(psmouse,\r\n"failed to allocate trackstick device\n");\r\nerror = -ENOMEM;\r\ngoto init_fail;\r\n}\r\nsnprintf(priv->phys2, sizeof(priv->phys2), "%s/input1",\r\npsmouse->ps2dev.serio->phys);\r\ndev2->phys = priv->phys2;\r\ndev2->name = "AlpsPS/2 ALPS DualPoint Stick";\r\ndev2->id.bustype = BUS_I8042;\r\ndev2->id.vendor = 0x0002;\r\ndev2->id.product = PSMOUSE_ALPS;\r\ndev2->id.version = priv->proto_version;\r\ndev2->dev.parent = &psmouse->ps2dev.serio->dev;\r\ninput_set_capability(dev2, EV_REL, REL_X);\r\ninput_set_capability(dev2, EV_REL, REL_Y);\r\ninput_set_capability(dev2, EV_KEY, BTN_LEFT);\r\ninput_set_capability(dev2, EV_KEY, BTN_RIGHT);\r\ninput_set_capability(dev2, EV_KEY, BTN_MIDDLE);\r\n__set_bit(INPUT_PROP_POINTER, dev2->propbit);\r\n__set_bit(INPUT_PROP_POINTING_STICK, dev2->propbit);\r\nerror = input_register_device(dev2);\r\nif (error) {\r\npsmouse_err(psmouse,\r\n"failed to register trackstick device: %d\n",\r\nerror);\r\ninput_free_device(dev2);\r\ngoto init_fail;\r\n}\r\npriv->dev2 = dev2;\r\n}\r\npriv->psmouse = psmouse;\r\nINIT_DELAYED_WORK(&priv->dev3_register_work,\r\nalps_register_bare_ps2_mouse);\r\npsmouse->protocol_handler = alps_process_byte;\r\npsmouse->poll = alps_poll;\r\npsmouse->disconnect = alps_disconnect;\r\npsmouse->reconnect = alps_reconnect;\r\npsmouse->pktsize = priv->proto_version == ALPS_PROTO_V4 ? 8 : 6;\r\npsmouse->resync_time = 0;\r\npsmouse->resetafter = psmouse->pktsize * 2;\r\nreturn 0;\r\ninit_fail:\r\npsmouse_reset(psmouse);\r\nkfree(psmouse->private);\r\npsmouse->private = NULL;\r\nreturn error;\r\n}\r\nint alps_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nstruct alps_data *priv;\r\nint error;\r\nerror = alps_identify(psmouse, NULL);\r\nif (error)\r\nreturn error;\r\npsmouse_reset(psmouse);\r\npriv = kzalloc(sizeof(struct alps_data), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nerror = alps_identify(psmouse, priv);\r\nif (error) {\r\nkfree(priv);\r\nreturn error;\r\n}\r\nif (set_properties) {\r\npsmouse->vendor = "ALPS";\r\npsmouse->name = priv->flags & ALPS_DUALPOINT ?\r\n"DualPoint TouchPad" : "GlidePoint";\r\npsmouse->model = priv->proto_version;\r\n} else {\r\nkfree(priv);\r\npsmouse->private = NULL;\r\n}\r\nreturn 0;\r\n}
