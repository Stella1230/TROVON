acpi_status acpi_ns_initialize_objects(void)\r\n{\r\nacpi_status status;\r\nstruct acpi_init_walk_info info;\r\nACPI_FUNCTION_TRACE(ns_initialize_objects);\r\nACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\r\n"**** Starting initialization of namespace objects ****\n"));\r\nACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,\r\n"Completing Region/Field/Buffer/Package initialization:\n"));\r\nmemset(&info, 0, sizeof(struct acpi_init_walk_info));\r\nstatus = acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, acpi_ns_init_one_object,\r\nNULL, &info, NULL);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "During WalkNamespace"));\r\n}\r\nACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,\r\n" Initialized %u/%u Regions %u/%u Fields %u/%u "\r\n"Buffers %u/%u Packages (%u nodes)\n",\r\ninfo.op_region_init, info.op_region_count,\r\ninfo.field_init, info.field_count,\r\ninfo.buffer_init, info.buffer_count,\r\ninfo.package_init, info.package_count,\r\ninfo.object_count));\r\nACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\r\n"%u Control Methods found\n%u Op Regions found\n",\r\ninfo.method_count, info.op_region_count));\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status acpi_ns_initialize_devices(void)\r\n{\r\nacpi_status status;\r\nstruct acpi_device_walk_info info;\r\nACPI_FUNCTION_TRACE(ns_initialize_devices);\r\ninfo.device_count = 0;\r\ninfo.num_STA = 0;\r\ninfo.num_INI = 0;\r\nACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,\r\n"Initializing Device/Processor/Thermal objects "\r\n"and executing _INI/_STA methods:\n"));\r\nstatus = acpi_ns_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, FALSE,\r\nacpi_ns_find_ini_methods, NULL, &info,\r\nNULL);\r\nif (ACPI_FAILURE(status)) {\r\ngoto error_exit;\r\n}\r\ninfo.evaluate_info =\r\nACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));\r\nif (!info.evaluate_info) {\r\nstatus = AE_NO_MEMORY;\r\ngoto error_exit;\r\n}\r\ninfo.evaluate_info->prefix_node = acpi_gbl_root_node;\r\ninfo.evaluate_info->relative_pathname = METHOD_NAME__INI;\r\ninfo.evaluate_info->parameters = NULL;\r\ninfo.evaluate_info->flags = ACPI_IGNORE_RETURN_VALUE;\r\nstatus = acpi_ns_evaluate(info.evaluate_info);\r\nif (ACPI_SUCCESS(status)) {\r\ninfo.num_INI++;\r\n}\r\nstatus = acpi_ns_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, FALSE,\r\nacpi_ns_init_one_device, NULL, &info,\r\nNULL);\r\nif (acpi_gbl_osi_data >= ACPI_OSI_WIN_2000) {\r\nacpi_gbl_truncate_io_addresses = TRUE;\r\n}\r\nACPI_FREE(info.evaluate_info);\r\nif (ACPI_FAILURE(status)) {\r\ngoto error_exit;\r\n}\r\nACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,\r\n" Executed %u _INI methods requiring %u _STA executions "\r\n"(examined %u objects)\n",\r\ninfo.num_INI, info.num_STA, info.device_count));\r\nreturn_ACPI_STATUS(status);\r\nerror_exit:\r\nACPI_EXCEPTION((AE_INFO, status, "During device initialization"));\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatic acpi_status\r\nacpi_ns_init_one_object(acpi_handle obj_handle,\r\nu32 level, void *context, void **return_value)\r\n{\r\nacpi_object_type type;\r\nacpi_status status = AE_OK;\r\nstruct acpi_init_walk_info *info =\r\n(struct acpi_init_walk_info *)context;\r\nstruct acpi_namespace_node *node =\r\n(struct acpi_namespace_node *)obj_handle;\r\nunion acpi_operand_object *obj_desc;\r\nACPI_FUNCTION_NAME(ns_init_one_object);\r\ninfo->object_count++;\r\ntype = acpi_ns_get_type(obj_handle);\r\nobj_desc = acpi_ns_get_attached_object(node);\r\nif (!obj_desc) {\r\nreturn (AE_OK);\r\n}\r\nswitch (type) {\r\ncase ACPI_TYPE_REGION:\r\ninfo->op_region_count++;\r\nbreak;\r\ncase ACPI_TYPE_BUFFER_FIELD:\r\ninfo->field_count++;\r\nbreak;\r\ncase ACPI_TYPE_LOCAL_BANK_FIELD:\r\ninfo->field_count++;\r\nbreak;\r\ncase ACPI_TYPE_BUFFER:\r\ninfo->buffer_count++;\r\nbreak;\r\ncase ACPI_TYPE_PACKAGE:\r\ninfo->package_count++;\r\nbreak;\r\ndefault:\r\nreturn (AE_OK);\r\n}\r\nif (obj_desc->common.flags & AOPOBJ_DATA_VALID) {\r\nreturn (AE_OK);\r\n}\r\nacpi_ex_enter_interpreter();\r\nswitch (type) {\r\ncase ACPI_TYPE_REGION:\r\ninfo->op_region_init++;\r\nstatus = acpi_ds_get_region_arguments(obj_desc);\r\nbreak;\r\ncase ACPI_TYPE_BUFFER_FIELD:\r\ninfo->field_init++;\r\nstatus = acpi_ds_get_buffer_field_arguments(obj_desc);\r\nbreak;\r\ncase ACPI_TYPE_LOCAL_BANK_FIELD:\r\ninfo->field_init++;\r\nstatus = acpi_ds_get_bank_field_arguments(obj_desc);\r\nbreak;\r\ncase ACPI_TYPE_BUFFER:\r\ninfo->buffer_init++;\r\nstatus = acpi_ds_get_buffer_arguments(obj_desc);\r\nbreak;\r\ncase ACPI_TYPE_PACKAGE:\r\ninfo->package_init++;\r\nstatus = acpi_ds_get_package_arguments(obj_desc);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"Could not execute arguments for [%4.4s] (%s)",\r\nacpi_ut_get_node_name(node),\r\nacpi_ut_get_type_name(type)));\r\n}\r\nacpi_ex_exit_interpreter();\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_ns_find_ini_methods(acpi_handle obj_handle,\r\nu32 nesting_level, void *context, void **return_value)\r\n{\r\nstruct acpi_device_walk_info *info =\r\nACPI_CAST_PTR(struct acpi_device_walk_info, context);\r\nstruct acpi_namespace_node *node;\r\nstruct acpi_namespace_node *parent_node;\r\nnode = ACPI_CAST_PTR(struct acpi_namespace_node, obj_handle);\r\nif ((node->type == ACPI_TYPE_DEVICE) ||\r\n(node->type == ACPI_TYPE_PROCESSOR) ||\r\n(node->type == ACPI_TYPE_THERMAL)) {\r\ninfo->device_count++;\r\nreturn (AE_OK);\r\n}\r\nif (!ACPI_COMPARE_NAME(node->name.ascii, METHOD_NAME__INI)) {\r\nreturn (AE_OK);\r\n}\r\nparent_node = node->parent;\r\nswitch (parent_node->type) {\r\ncase ACPI_TYPE_DEVICE:\r\ncase ACPI_TYPE_PROCESSOR:\r\ncase ACPI_TYPE_THERMAL:\r\nwhile (parent_node) {\r\nparent_node->flags |= ANOBJ_SUBTREE_HAS_INI;\r\nparent_node = parent_node->parent;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_ns_init_one_device(acpi_handle obj_handle,\r\nu32 nesting_level, void *context, void **return_value)\r\n{\r\nstruct acpi_device_walk_info *walk_info =\r\nACPI_CAST_PTR(struct acpi_device_walk_info, context);\r\nstruct acpi_evaluate_info *info = walk_info->evaluate_info;\r\nu32 flags;\r\nacpi_status status;\r\nstruct acpi_namespace_node *device_node;\r\nACPI_FUNCTION_TRACE(ns_init_one_device);\r\ndevice_node = ACPI_CAST_PTR(struct acpi_namespace_node, obj_handle);\r\nif ((device_node->type != ACPI_TYPE_DEVICE) &&\r\n(device_node->type != ACPI_TYPE_PROCESSOR) &&\r\n(device_node->type != ACPI_TYPE_THERMAL)) {\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nif (!(device_node->flags & ANOBJ_SUBTREE_HAS_INI)) {\r\nreturn_ACPI_STATUS(AE_CTRL_DEPTH);\r\n}\r\nACPI_DEBUG_EXEC(acpi_ut_display_init_pathname\r\n(ACPI_TYPE_METHOD, device_node, METHOD_NAME__STA));\r\nstatus = acpi_ut_execute_STA(device_node, &flags);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nif (flags != ACPI_UINT32_MAX) {\r\nwalk_info->num_STA++;\r\n}\r\nif (!(flags & ACPI_STA_DEVICE_PRESENT)) {\r\nif (flags & ACPI_STA_DEVICE_FUNCTIONING) {\r\nreturn_ACPI_STATUS(AE_OK);\r\n} else {\r\nreturn_ACPI_STATUS(AE_CTRL_DEPTH);\r\n}\r\n}\r\nACPI_DEBUG_EXEC(acpi_ut_display_init_pathname\r\n(ACPI_TYPE_METHOD, device_node, METHOD_NAME__INI));\r\nmemset(info, 0, sizeof(struct acpi_evaluate_info));\r\ninfo->prefix_node = device_node;\r\ninfo->relative_pathname = METHOD_NAME__INI;\r\ninfo->parameters = NULL;\r\ninfo->flags = ACPI_IGNORE_RETURN_VALUE;\r\nstatus = acpi_ns_evaluate(info);\r\nif (ACPI_SUCCESS(status)) {\r\nwalk_info->num_INI++;\r\n}\r\n#ifdef ACPI_DEBUG_OUTPUT\r\nelse if (status != AE_NOT_FOUND) {\r\nchar *scope_name = acpi_ns_get_external_pathname(info->node);\r\nACPI_EXCEPTION((AE_INFO, status, "during %s._INI execution",\r\nscope_name));\r\nACPI_FREE(scope_name);\r\n}\r\n#endif\r\nstatus = AE_OK;\r\nif (acpi_gbl_init_handler) {\r\nstatus =\r\nacpi_gbl_init_handler(device_node, ACPI_INIT_DEVICE_INI);\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}
