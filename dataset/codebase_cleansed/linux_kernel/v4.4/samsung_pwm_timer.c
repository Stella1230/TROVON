static void samsung_timer_set_prescale(unsigned int channel, u16 prescale)\r\n{\r\nunsigned long flags;\r\nu8 shift = 0;\r\nu32 reg;\r\nif (channel >= 2)\r\nshift = TCFG0_PRESCALER1_SHIFT;\r\nspin_lock_irqsave(&samsung_pwm_lock, flags);\r\nreg = readl(pwm.base + REG_TCFG0);\r\nreg &= ~(TCFG0_PRESCALER_MASK << shift);\r\nreg |= (prescale - 1) << shift;\r\nwritel(reg, pwm.base + REG_TCFG0);\r\nspin_unlock_irqrestore(&samsung_pwm_lock, flags);\r\n}\r\nstatic void samsung_timer_set_divisor(unsigned int channel, u8 divisor)\r\n{\r\nu8 shift = TCFG1_SHIFT(channel);\r\nunsigned long flags;\r\nu32 reg;\r\nu8 bits;\r\nbits = (fls(divisor) - 1) - pwm.variant.div_base;\r\nspin_lock_irqsave(&samsung_pwm_lock, flags);\r\nreg = readl(pwm.base + REG_TCFG1);\r\nreg &= ~(TCFG1_MUX_MASK << shift);\r\nreg |= bits << shift;\r\nwritel(reg, pwm.base + REG_TCFG1);\r\nspin_unlock_irqrestore(&samsung_pwm_lock, flags);\r\n}\r\nstatic void samsung_time_stop(unsigned int channel)\r\n{\r\nunsigned long tcon;\r\nunsigned long flags;\r\nif (channel > 0)\r\n++channel;\r\nspin_lock_irqsave(&samsung_pwm_lock, flags);\r\ntcon = __raw_readl(pwm.base + REG_TCON);\r\ntcon &= ~TCON_START(channel);\r\n__raw_writel(tcon, pwm.base + REG_TCON);\r\nspin_unlock_irqrestore(&samsung_pwm_lock, flags);\r\n}\r\nstatic void samsung_time_setup(unsigned int channel, unsigned long tcnt)\r\n{\r\nunsigned long tcon;\r\nunsigned long flags;\r\nunsigned int tcon_chan = channel;\r\nif (tcon_chan > 0)\r\n++tcon_chan;\r\nspin_lock_irqsave(&samsung_pwm_lock, flags);\r\ntcon = __raw_readl(pwm.base + REG_TCON);\r\ntcon &= ~(TCON_START(tcon_chan) | TCON_AUTORELOAD(tcon_chan));\r\ntcon |= TCON_MANUALUPDATE(tcon_chan);\r\n__raw_writel(tcnt, pwm.base + REG_TCNTB(channel));\r\n__raw_writel(tcnt, pwm.base + REG_TCMPB(channel));\r\n__raw_writel(tcon, pwm.base + REG_TCON);\r\nspin_unlock_irqrestore(&samsung_pwm_lock, flags);\r\n}\r\nstatic void samsung_time_start(unsigned int channel, bool periodic)\r\n{\r\nunsigned long tcon;\r\nunsigned long flags;\r\nif (channel > 0)\r\n++channel;\r\nspin_lock_irqsave(&samsung_pwm_lock, flags);\r\ntcon = __raw_readl(pwm.base + REG_TCON);\r\ntcon &= ~TCON_MANUALUPDATE(channel);\r\ntcon |= TCON_START(channel);\r\nif (periodic)\r\ntcon |= TCON_AUTORELOAD(channel);\r\nelse\r\ntcon &= ~TCON_AUTORELOAD(channel);\r\n__raw_writel(tcon, pwm.base + REG_TCON);\r\nspin_unlock_irqrestore(&samsung_pwm_lock, flags);\r\n}\r\nstatic int samsung_set_next_event(unsigned long cycles,\r\nstruct clock_event_device *evt)\r\n{\r\nif (!cycles)\r\ncycles = 1;\r\nsamsung_time_setup(pwm.event_id, cycles);\r\nsamsung_time_start(pwm.event_id, false);\r\nreturn 0;\r\n}\r\nstatic int samsung_shutdown(struct clock_event_device *evt)\r\n{\r\nsamsung_time_stop(pwm.event_id);\r\nreturn 0;\r\n}\r\nstatic int samsung_set_periodic(struct clock_event_device *evt)\r\n{\r\nsamsung_time_stop(pwm.event_id);\r\nsamsung_time_setup(pwm.event_id, pwm.clock_count_per_tick - 1);\r\nsamsung_time_start(pwm.event_id, true);\r\nreturn 0;\r\n}\r\nstatic void samsung_clockevent_resume(struct clock_event_device *cev)\r\n{\r\nsamsung_timer_set_prescale(pwm.event_id, pwm.tscaler_div);\r\nsamsung_timer_set_divisor(pwm.event_id, pwm.tdiv);\r\nif (pwm.variant.has_tint_cstat) {\r\nu32 mask = (1 << pwm.event_id);\r\nwritel(mask | (mask << 5), pwm.base + REG_TINT_CSTAT);\r\n}\r\n}\r\nstatic irqreturn_t samsung_clock_event_isr(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nif (pwm.variant.has_tint_cstat) {\r\nu32 mask = (1 << pwm.event_id);\r\nwritel(mask | (mask << 5), pwm.base + REG_TINT_CSTAT);\r\n}\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void __init samsung_clockevent_init(void)\r\n{\r\nunsigned long pclk;\r\nunsigned long clock_rate;\r\nunsigned int irq_number;\r\npclk = clk_get_rate(pwm.timerclk);\r\nsamsung_timer_set_prescale(pwm.event_id, pwm.tscaler_div);\r\nsamsung_timer_set_divisor(pwm.event_id, pwm.tdiv);\r\nclock_rate = pclk / (pwm.tscaler_div * pwm.tdiv);\r\npwm.clock_count_per_tick = clock_rate / HZ;\r\ntime_event_device.cpumask = cpumask_of(0);\r\nclockevents_config_and_register(&time_event_device,\r\nclock_rate, 1, pwm.tcnt_max);\r\nirq_number = pwm.irq[pwm.event_id];\r\nsetup_irq(irq_number, &samsung_clock_event_irq);\r\nif (pwm.variant.has_tint_cstat) {\r\nu32 mask = (1 << pwm.event_id);\r\nwritel(mask | (mask << 5), pwm.base + REG_TINT_CSTAT);\r\n}\r\n}\r\nstatic void samsung_clocksource_suspend(struct clocksource *cs)\r\n{\r\nsamsung_time_stop(pwm.source_id);\r\n}\r\nstatic void samsung_clocksource_resume(struct clocksource *cs)\r\n{\r\nsamsung_timer_set_prescale(pwm.source_id, pwm.tscaler_div);\r\nsamsung_timer_set_divisor(pwm.source_id, pwm.tdiv);\r\nsamsung_time_setup(pwm.source_id, pwm.tcnt_max);\r\nsamsung_time_start(pwm.source_id, true);\r\n}\r\nstatic cycle_t notrace samsung_clocksource_read(struct clocksource *c)\r\n{\r\nreturn ~readl_relaxed(pwm.source_reg);\r\n}\r\nstatic u64 notrace samsung_read_sched_clock(void)\r\n{\r\nreturn samsung_clocksource_read(NULL);\r\n}\r\nstatic void __init samsung_clocksource_init(void)\r\n{\r\nunsigned long pclk;\r\nunsigned long clock_rate;\r\nint ret;\r\npclk = clk_get_rate(pwm.timerclk);\r\nsamsung_timer_set_prescale(pwm.source_id, pwm.tscaler_div);\r\nsamsung_timer_set_divisor(pwm.source_id, pwm.tdiv);\r\nclock_rate = pclk / (pwm.tscaler_div * pwm.tdiv);\r\nsamsung_time_setup(pwm.source_id, pwm.tcnt_max);\r\nsamsung_time_start(pwm.source_id, true);\r\nif (pwm.source_id == 4)\r\npwm.source_reg = pwm.base + 0x40;\r\nelse\r\npwm.source_reg = pwm.base + pwm.source_id * 0x0c + 0x14;\r\nsched_clock_register(samsung_read_sched_clock,\r\npwm.variant.bits, clock_rate);\r\nsamsung_clocksource.mask = CLOCKSOURCE_MASK(pwm.variant.bits);\r\nret = clocksource_register_hz(&samsung_clocksource, clock_rate);\r\nif (ret)\r\npanic("samsung_clocksource_timer: can't register clocksource\n");\r\n}\r\nstatic void __init samsung_timer_resources(void)\r\n{\r\nclk_prepare_enable(pwm.timerclk);\r\npwm.tcnt_max = (1UL << pwm.variant.bits) - 1;\r\nif (pwm.variant.bits == 16) {\r\npwm.tscaler_div = 25;\r\npwm.tdiv = 2;\r\n} else {\r\npwm.tscaler_div = 2;\r\npwm.tdiv = 1;\r\n}\r\n}\r\nstatic void __init _samsung_pwm_clocksource_init(void)\r\n{\r\nu8 mask;\r\nint channel;\r\nmask = ~pwm.variant.output_mask & ((1 << SAMSUNG_PWM_NUM) - 1);\r\nchannel = fls(mask) - 1;\r\nif (channel < 0)\r\npanic("failed to find PWM channel for clocksource");\r\npwm.source_id = channel;\r\nmask &= ~(1 << channel);\r\nchannel = fls(mask) - 1;\r\nif (channel < 0)\r\npanic("failed to find PWM channel for clock event");\r\npwm.event_id = channel;\r\nsamsung_timer_resources();\r\nsamsung_clockevent_init();\r\nsamsung_clocksource_init();\r\n}\r\nvoid __init samsung_pwm_clocksource_init(void __iomem *base,\r\nunsigned int *irqs, struct samsung_pwm_variant *variant)\r\n{\r\npwm.base = base;\r\nmemcpy(&pwm.variant, variant, sizeof(pwm.variant));\r\nmemcpy(pwm.irq, irqs, SAMSUNG_PWM_NUM * sizeof(*irqs));\r\npwm.timerclk = clk_get(NULL, "timers");\r\nif (IS_ERR(pwm.timerclk))\r\npanic("failed to get timers clock for timer");\r\n_samsung_pwm_clocksource_init();\r\n}\r\nstatic void __init samsung_pwm_alloc(struct device_node *np,\r\nconst struct samsung_pwm_variant *variant)\r\n{\r\nstruct property *prop;\r\nconst __be32 *cur;\r\nu32 val;\r\nint i;\r\nmemcpy(&pwm.variant, variant, sizeof(pwm.variant));\r\nfor (i = 0; i < SAMSUNG_PWM_NUM; ++i)\r\npwm.irq[i] = irq_of_parse_and_map(np, i);\r\nof_property_for_each_u32(np, "samsung,pwm-outputs", prop, cur, val) {\r\nif (val >= SAMSUNG_PWM_NUM) {\r\npr_warning("%s: invalid channel index in samsung,pwm-outputs property\n",\r\n__func__);\r\ncontinue;\r\n}\r\npwm.variant.output_mask |= 1 << val;\r\n}\r\npwm.base = of_iomap(np, 0);\r\nif (!pwm.base) {\r\npr_err("%s: failed to map PWM registers\n", __func__);\r\nreturn;\r\n}\r\npwm.timerclk = of_clk_get_by_name(np, "timers");\r\nif (IS_ERR(pwm.timerclk))\r\npanic("failed to get timers clock for timer");\r\n_samsung_pwm_clocksource_init();\r\n}\r\nstatic void __init s3c2410_pwm_clocksource_init(struct device_node *np)\r\n{\r\nsamsung_pwm_alloc(np, &s3c24xx_variant);\r\n}\r\nstatic void __init s3c64xx_pwm_clocksource_init(struct device_node *np)\r\n{\r\nsamsung_pwm_alloc(np, &s3c64xx_variant);\r\n}\r\nstatic void __init s5p64x0_pwm_clocksource_init(struct device_node *np)\r\n{\r\nsamsung_pwm_alloc(np, &s5p64x0_variant);\r\n}\r\nstatic void __init s5p_pwm_clocksource_init(struct device_node *np)\r\n{\r\nsamsung_pwm_alloc(np, &s5p_variant);\r\n}
