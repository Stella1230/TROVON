static int nau7802_set_gain(struct nau7802_state *st, int gain)\r\n{\r\nint ret;\r\nmutex_lock(&st->lock);\r\nst->conversion_count = 0;\r\nret = i2c_smbus_read_byte_data(st->client, NAU7802_REG_CTRL1);\r\nif (ret < 0)\r\ngoto nau7802_sysfs_set_gain_out;\r\nret = i2c_smbus_write_byte_data(st->client, NAU7802_REG_CTRL1,\r\n(ret & (~NAU7802_CTRL1_GAINS_BITS)) |\r\ngain);\r\nnau7802_sysfs_set_gain_out:\r\nmutex_unlock(&st->lock);\r\nreturn ret;\r\n}\r\nstatic int nau7802_read_conversion(struct nau7802_state *st)\r\n{\r\nint data;\r\nmutex_lock(&st->data_lock);\r\ndata = i2c_smbus_read_byte_data(st->client, NAU7802_REG_ADC_B2);\r\nif (data < 0)\r\ngoto nau7802_read_conversion_out;\r\nst->last_value = data << 16;\r\ndata = i2c_smbus_read_byte_data(st->client, NAU7802_REG_ADC_B1);\r\nif (data < 0)\r\ngoto nau7802_read_conversion_out;\r\nst->last_value |= data << 8;\r\ndata = i2c_smbus_read_byte_data(st->client, NAU7802_REG_ADC_B0);\r\nif (data < 0)\r\ngoto nau7802_read_conversion_out;\r\nst->last_value |= data;\r\nst->last_value = sign_extend32(st->last_value, 23);\r\nnau7802_read_conversion_out:\r\nmutex_unlock(&st->data_lock);\r\nreturn data;\r\n}\r\nstatic int nau7802_sync(struct nau7802_state *st)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(st->client, NAU7802_REG_PUCTRL);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(st->client, NAU7802_REG_PUCTRL,\r\nret | NAU7802_PUCTRL_CS_BIT);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t nau7802_eoc_trigger(int irq, void *private)\r\n{\r\nstruct iio_dev *indio_dev = private;\r\nstruct nau7802_state *st = iio_priv(indio_dev);\r\nint status;\r\nstatus = i2c_smbus_read_byte_data(st->client, NAU7802_REG_PUCTRL);\r\nif (status < 0)\r\nreturn IRQ_HANDLED;\r\nif (!(status & NAU7802_PUCTRL_CR_BIT))\r\nreturn IRQ_NONE;\r\nif (nau7802_read_conversion(st) < 0)\r\nreturn IRQ_HANDLED;\r\nif (st->conversion_count < NAU7802_MIN_CONVERSIONS)\r\nst->conversion_count++;\r\nif (st->conversion_count >= NAU7802_MIN_CONVERSIONS)\r\ncomplete_all(&st->value_ok);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int nau7802_read_irq(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val)\r\n{\r\nstruct nau7802_state *st = iio_priv(indio_dev);\r\nint ret;\r\nreinit_completion(&st->value_ok);\r\nenable_irq(st->client->irq);\r\nnau7802_sync(st);\r\nret = nau7802_read_conversion(st);\r\nif (ret < 0)\r\ngoto read_chan_info_failure;\r\nret = wait_for_completion_interruptible_timeout(&st->value_ok,\r\nmsecs_to_jiffies(1000));\r\nif (ret == 0)\r\nret = -ETIMEDOUT;\r\nif (ret < 0)\r\ngoto read_chan_info_failure;\r\ndisable_irq(st->client->irq);\r\n*val = st->last_value;\r\nreturn IIO_VAL_INT;\r\nread_chan_info_failure:\r\ndisable_irq(st->client->irq);\r\nreturn ret;\r\n}\r\nstatic int nau7802_read_poll(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val)\r\n{\r\nstruct nau7802_state *st = iio_priv(indio_dev);\r\nint ret;\r\nnau7802_sync(st);\r\nret = nau7802_read_conversion(st);\r\nif (ret < 0)\r\nreturn ret;\r\ndo {\r\nret = i2c_smbus_read_byte_data(st->client, NAU7802_REG_PUCTRL);\r\nif (ret < 0)\r\nreturn ret;\r\nwhile (!(ret & NAU7802_PUCTRL_CR_BIT)) {\r\nif (st->sample_rate != NAU7802_SAMP_FREQ_320)\r\nmsleep(20);\r\nelse\r\nmdelay(4);\r\nret = i2c_smbus_read_byte_data(st->client,\r\nNAU7802_REG_PUCTRL);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = nau7802_read_conversion(st);\r\nif (ret < 0)\r\nreturn ret;\r\nif (st->conversion_count < NAU7802_MIN_CONVERSIONS)\r\nst->conversion_count++;\r\n} while (st->conversion_count < NAU7802_MIN_CONVERSIONS);\r\n*val = st->last_value;\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int nau7802_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct nau7802_state *st = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nmutex_lock(&st->lock);\r\nret = i2c_smbus_read_byte_data(st->client, NAU7802_REG_CTRL2);\r\nif (ret < 0) {\r\nmutex_unlock(&st->lock);\r\nreturn ret;\r\n}\r\nif (((ret & NAU7802_CTRL2_CHS_BIT) && !chan->channel) ||\r\n(!(ret & NAU7802_CTRL2_CHS_BIT) &&\r\nchan->channel)) {\r\nst->conversion_count = 0;\r\nret = i2c_smbus_write_byte_data(st->client,\r\nNAU7802_REG_CTRL2,\r\nNAU7802_CTRL2_CHS(chan->channel) |\r\nNAU7802_CTRL2_CRS(st->sample_rate));\r\nif (ret < 0) {\r\nmutex_unlock(&st->lock);\r\nreturn ret;\r\n}\r\n}\r\nif (st->client->irq)\r\nret = nau7802_read_irq(indio_dev, chan, val);\r\nelse\r\nret = nau7802_read_poll(indio_dev, chan, val);\r\nmutex_unlock(&st->lock);\r\nreturn ret;\r\ncase IIO_CHAN_INFO_SCALE:\r\nret = i2c_smbus_read_byte_data(st->client, NAU7802_REG_CTRL1);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = st->vref_mv;\r\n*val2 = 23 + (ret & NAU7802_CTRL1_GAINS_BITS);\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\n*val = nau7802_sample_freq_avail[st->sample_rate];\r\n*val2 = 0;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int nau7802_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct nau7802_state *st = iio_priv(indio_dev);\r\nint i, ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nfor (i = 0; i < ARRAY_SIZE(st->scale_avail); i++)\r\nif (val2 == st->scale_avail[i])\r\nreturn nau7802_set_gain(st, i);\r\nbreak;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nfor (i = 0; i < ARRAY_SIZE(nau7802_sample_freq_avail); i++)\r\nif (val == nau7802_sample_freq_avail[i]) {\r\nmutex_lock(&st->lock);\r\nst->sample_rate = i;\r\nst->conversion_count = 0;\r\nret = i2c_smbus_write_byte_data(st->client,\r\nNAU7802_REG_CTRL2,\r\nNAU7802_CTRL2_CRS(st->sample_rate));\r\nmutex_unlock(&st->lock);\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int nau7802_write_raw_get_fmt(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nlong mask)\r\n{\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\n}\r\nstatic int nau7802_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct nau7802_state *st;\r\nstruct device_node *np = client->dev.of_node;\r\nint i, ret;\r\nu8 data;\r\nu32 tmp = 0;\r\nif (!client->dev.of_node) {\r\ndev_err(&client->dev, "No device tree node available.\n");\r\nreturn -EINVAL;\r\n}\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*st));\r\nif (indio_dev == NULL)\r\nreturn -ENOMEM;\r\nst = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->name = dev_name(&client->dev);\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &nau7802_info;\r\nst->client = client;\r\nret = i2c_smbus_write_byte_data(st->client, NAU7802_REG_PUCTRL,\r\nNAU7802_PUCTRL_RR_BIT);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(st->client, NAU7802_REG_PUCTRL,\r\nNAU7802_PUCTRL_PUD_BIT);\r\nif (ret < 0)\r\nreturn ret;\r\nudelay(210);\r\nret = i2c_smbus_read_byte_data(st->client, NAU7802_REG_PUCTRL);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(ret & NAU7802_PUCTRL_PUR_BIT))\r\nreturn ret;\r\nof_property_read_u32(np, "nuvoton,vldo", &tmp);\r\nst->vref_mv = tmp;\r\ndata = NAU7802_PUCTRL_PUD_BIT | NAU7802_PUCTRL_PUA_BIT |\r\nNAU7802_PUCTRL_CS_BIT;\r\nif (tmp >= 2400)\r\ndata |= NAU7802_PUCTRL_AVDDS_BIT;\r\nret = i2c_smbus_write_byte_data(st->client, NAU7802_REG_PUCTRL, data);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(st->client, NAU7802_REG_ADC_CTRL, 0x30);\r\nif (ret < 0)\r\nreturn ret;\r\nif (tmp >= 2400) {\r\ndata = NAU7802_CTRL1_VLDO((4500 - tmp) / 300);\r\nret = i2c_smbus_write_byte_data(st->client, NAU7802_REG_CTRL1,\r\ndata);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(st->scale_avail); i++)\r\nst->scale_avail[i] = (((u64)st->vref_mv) * 1000000000ULL)\r\n>> (23 + i);\r\ninit_completion(&st->value_ok);\r\nif (client->irq) {\r\nret = request_threaded_irq(client->irq,\r\nNULL,\r\nnau7802_eoc_trigger,\r\nIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\r\nclient->dev.driver->name,\r\nindio_dev);\r\nif (ret) {\r\ndev_info(&client->dev,\r\n"Failed to allocate IRQ, using polling mode\n");\r\nclient->irq = 0;\r\n} else\r\ndisable_irq(client->irq);\r\n}\r\nif (!client->irq) {\r\nst->sample_rate = NAU7802_SAMP_FREQ_320;\r\nret = i2c_smbus_write_byte_data(st->client, NAU7802_REG_CTRL2,\r\nNAU7802_CTRL2_CRS(st->sample_rate));\r\nif (ret)\r\ngoto error_free_irq;\r\n}\r\nindio_dev->num_channels = ARRAY_SIZE(nau7802_chan_array);\r\nindio_dev->channels = nau7802_chan_array;\r\nmutex_init(&st->lock);\r\nmutex_init(&st->data_lock);\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Couldn't register the device.\n");\r\ngoto error_device_register;\r\n}\r\nreturn 0;\r\nerror_device_register:\r\nmutex_destroy(&st->lock);\r\nmutex_destroy(&st->data_lock);\r\nerror_free_irq:\r\nif (client->irq)\r\nfree_irq(client->irq, indio_dev);\r\nreturn ret;\r\n}\r\nstatic int nau7802_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct nau7802_state *st = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nmutex_destroy(&st->lock);\r\nmutex_destroy(&st->data_lock);\r\nif (client->irq)\r\nfree_irq(client->irq, indio_dev);\r\nreturn 0;\r\n}
