static int lp8860_unlock_eeprom(struct lp8860_led *led, int lock)\r\n{\r\nint ret;\r\nmutex_lock(&led->lock);\r\nif (lock == LP8860_UNLOCK_EEPROM) {\r\nret = regmap_write(led->regmap,\r\nLP8860_EEPROM_UNLOCK,\r\nLP8860_EEPROM_CODE_1);\r\nif (ret) {\r\ndev_err(&led->client->dev, "EEPROM Unlock failed\n");\r\ngoto out;\r\n}\r\nret = regmap_write(led->regmap,\r\nLP8860_EEPROM_UNLOCK,\r\nLP8860_EEPROM_CODE_2);\r\nif (ret) {\r\ndev_err(&led->client->dev, "EEPROM Unlock failed\n");\r\ngoto out;\r\n}\r\nret = regmap_write(led->regmap,\r\nLP8860_EEPROM_UNLOCK,\r\nLP8860_EEPROM_CODE_3);\r\nif (ret) {\r\ndev_err(&led->client->dev, "EEPROM Unlock failed\n");\r\ngoto out;\r\n}\r\n} else {\r\nret = regmap_write(led->regmap,\r\nLP8860_EEPROM_UNLOCK,\r\nLP8860_LOCK_EEPROM);\r\n}\r\nout:\r\nmutex_unlock(&led->lock);\r\nreturn ret;\r\n}\r\nstatic int lp8860_fault_check(struct lp8860_led *led)\r\n{\r\nint ret, fault;\r\nunsigned int read_buf;\r\nret = regmap_read(led->regmap, LP8860_LED_FAULT, &read_buf);\r\nif (ret)\r\ngoto out;\r\nfault = read_buf;\r\nret = regmap_read(led->regmap, LP8860_FAULT, &read_buf);\r\nif (ret)\r\ngoto out;\r\nfault |= read_buf;\r\nif (fault)\r\nret = regmap_write(led->regmap, LP8860_FAULT_CLEAR,\r\nLP8860_CLEAR_FAULTS);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void lp8860_led_brightness_work(struct work_struct *work)\r\n{\r\nstruct lp8860_led *led = container_of(work, struct lp8860_led, work);\r\nint ret;\r\nint disp_brightness = led->brightness * 255;\r\nmutex_lock(&led->lock);\r\nret = lp8860_fault_check(led);\r\nif (ret) {\r\ndev_err(&led->client->dev, "Cannot read/clear faults\n");\r\ngoto out;\r\n}\r\nret = regmap_write(led->regmap, LP8860_DISP_CL1_BRT_MSB,\r\n(disp_brightness & 0xff00) >> 8);\r\nif (ret) {\r\ndev_err(&led->client->dev, "Cannot write CL1 MSB\n");\r\ngoto out;\r\n}\r\nret = regmap_write(led->regmap, LP8860_DISP_CL1_BRT_LSB,\r\ndisp_brightness & 0xff);\r\nif (ret) {\r\ndev_err(&led->client->dev, "Cannot write CL1 LSB\n");\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&led->lock);\r\n}\r\nstatic void lp8860_brightness_set(struct led_classdev *led_cdev,\r\nenum led_brightness brt_val)\r\n{\r\nstruct lp8860_led *led =\r\ncontainer_of(led_cdev, struct lp8860_led, led_dev);\r\nled->brightness = brt_val;\r\nschedule_work(&led->work);\r\n}\r\nstatic int lp8860_init(struct lp8860_led *led)\r\n{\r\nunsigned int read_buf;\r\nint ret, i, reg_count;\r\nif (led->enable_gpio)\r\ngpiod_direction_output(led->enable_gpio, 1);\r\nret = lp8860_fault_check(led);\r\nif (ret)\r\ngoto out;\r\nret = regmap_read(led->regmap, LP8860_STATUS, &read_buf);\r\nif (ret)\r\ngoto out;\r\nret = lp8860_unlock_eeprom(led, LP8860_UNLOCK_EEPROM);\r\nif (ret) {\r\ndev_err(&led->client->dev, "Failed unlocking EEPROM\n");\r\ngoto out;\r\n}\r\nreg_count = ARRAY_SIZE(lp8860_eeprom_disp_regs) / sizeof(lp8860_eeprom_disp_regs[0]);\r\nfor (i = 0; i < reg_count; i++) {\r\nret = regmap_write(led->eeprom_regmap,\r\nlp8860_eeprom_disp_regs[i].reg,\r\nlp8860_eeprom_disp_regs[i].value);\r\nif (ret) {\r\ndev_err(&led->client->dev, "Failed writing EEPROM\n");\r\ngoto out;\r\n}\r\n}\r\nret = lp8860_unlock_eeprom(led, LP8860_LOCK_EEPROM);\r\nif (ret)\r\ngoto out;\r\nret = regmap_write(led->regmap,\r\nLP8860_EEPROM_CNTRL,\r\nLP8860_PROGRAM_EEPROM);\r\nif (ret)\r\ndev_err(&led->client->dev, "Failed programming EEPROM\n");\r\nout:\r\nif (ret)\r\nif (led->enable_gpio)\r\ngpiod_direction_output(led->enable_gpio, 0);\r\nreturn ret;\r\n}\r\nstatic int lp8860_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct lp8860_led *led;\r\nstruct device_node *np = client->dev.of_node;\r\nled = devm_kzalloc(&client->dev, sizeof(*led), GFP_KERNEL);\r\nif (!led)\r\nreturn -ENOMEM;\r\nled->label = LP8860_DISP_LED_NAME;\r\nif (client->dev.of_node) {\r\nret = of_property_read_string(np, "label", &led->label);\r\nif (ret) {\r\ndev_err(&client->dev, "Missing label in dt\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nled->enable_gpio = devm_gpiod_get_optional(&client->dev,\r\n"enable", GPIOD_OUT_LOW);\r\nif (IS_ERR(led->enable_gpio)) {\r\nret = PTR_ERR(led->enable_gpio);\r\ndev_err(&client->dev, "Failed to get enable gpio: %d\n", ret);\r\nreturn ret;\r\n}\r\nled->regulator = devm_regulator_get(&client->dev, "vled");\r\nif (IS_ERR(led->regulator))\r\nled->regulator = NULL;\r\nled->client = client;\r\nled->led_dev.name = led->label;\r\nled->led_dev.max_brightness = LED_FULL;\r\nled->led_dev.brightness_set = lp8860_brightness_set;\r\nmutex_init(&led->lock);\r\nINIT_WORK(&led->work, lp8860_led_brightness_work);\r\ni2c_set_clientdata(client, led);\r\nled->regmap = devm_regmap_init_i2c(client, &lp8860_regmap_config);\r\nif (IS_ERR(led->regmap)) {\r\nret = PTR_ERR(led->regmap);\r\ndev_err(&client->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nled->eeprom_regmap = devm_regmap_init_i2c(client, &lp8860_eeprom_regmap_config);\r\nif (IS_ERR(led->eeprom_regmap)) {\r\nret = PTR_ERR(led->eeprom_regmap);\r\ndev_err(&client->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = lp8860_init(led);\r\nif (ret)\r\nreturn ret;\r\nret = led_classdev_register(&client->dev, &led->led_dev);\r\nif (ret) {\r\ndev_err(&client->dev, "led register err: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lp8860_remove(struct i2c_client *client)\r\n{\r\nstruct lp8860_led *led = i2c_get_clientdata(client);\r\nint ret;\r\nled_classdev_unregister(&led->led_dev);\r\ncancel_work_sync(&led->work);\r\nif (led->enable_gpio)\r\ngpiod_direction_output(led->enable_gpio, 0);\r\nif (led->regulator) {\r\nret = regulator_disable(led->regulator);\r\nif (ret)\r\ndev_err(&led->client->dev,\r\n"Failed to disable regulator\n");\r\n}\r\nreturn 0;\r\n}
