const struct xvip_video_format *xvip_get_format_by_code(unsigned int code)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(xvip_video_formats); ++i) {\r\nconst struct xvip_video_format *format = &xvip_video_formats[i];\r\nif (format->code == code)\r\nreturn format;\r\n}\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nconst struct xvip_video_format *xvip_get_format_by_fourcc(u32 fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(xvip_video_formats); ++i) {\r\nconst struct xvip_video_format *format = &xvip_video_formats[i];\r\nif (format->fourcc == fourcc)\r\nreturn format;\r\n}\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nconst struct xvip_video_format *xvip_of_get_format(struct device_node *node)\r\n{\r\nconst char *pattern = "mono";\r\nunsigned int vf_code;\r\nunsigned int i;\r\nu32 width;\r\nint ret;\r\nret = of_property_read_u32(node, "xlnx,video-format", &vf_code);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nret = of_property_read_u32(node, "xlnx,video-width", &width);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nif (vf_code == XVIP_VF_MONO_SENSOR)\r\nof_property_read_string(node, "xlnx,cfa-pattern", &pattern);\r\nfor (i = 0; i < ARRAY_SIZE(xvip_video_formats); ++i) {\r\nconst struct xvip_video_format *format = &xvip_video_formats[i];\r\nif (format->vf_code != vf_code || format->width != width)\r\ncontinue;\r\nif (vf_code == XVIP_VF_MONO_SENSOR &&\r\nstrcmp(pattern, format->pattern))\r\ncontinue;\r\nreturn format;\r\n}\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nvoid xvip_set_format_size(struct v4l2_mbus_framefmt *format,\r\nconst struct v4l2_subdev_format *fmt)\r\n{\r\nformat->width = clamp_t(unsigned int, fmt->format.width,\r\nXVIP_MIN_WIDTH, XVIP_MAX_WIDTH);\r\nformat->height = clamp_t(unsigned int, fmt->format.height,\r\nXVIP_MIN_HEIGHT, XVIP_MAX_HEIGHT);\r\n}\r\nvoid xvip_clr_or_set(struct xvip_device *xvip, u32 addr, u32 mask, bool set)\r\n{\r\nu32 reg;\r\nreg = xvip_read(xvip, addr);\r\nreg = set ? reg | mask : reg & ~mask;\r\nxvip_write(xvip, addr, reg);\r\n}\r\nvoid xvip_clr_and_set(struct xvip_device *xvip, u32 addr, u32 clr, u32 set)\r\n{\r\nu32 reg;\r\nreg = xvip_read(xvip, addr);\r\nreg &= ~clr;\r\nreg |= set;\r\nxvip_write(xvip, addr, reg);\r\n}\r\nint xvip_init_resources(struct xvip_device *xvip)\r\n{\r\nstruct platform_device *pdev = to_platform_device(xvip->dev);\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nxvip->iomem = devm_ioremap_resource(xvip->dev, res);\r\nif (IS_ERR(xvip->iomem))\r\nreturn PTR_ERR(xvip->iomem);\r\nxvip->clk = devm_clk_get(xvip->dev, NULL);\r\nif (IS_ERR(xvip->clk))\r\nreturn PTR_ERR(xvip->clk);\r\nclk_prepare_enable(xvip->clk);\r\nreturn 0;\r\n}\r\nvoid xvip_cleanup_resources(struct xvip_device *xvip)\r\n{\r\nclk_disable_unprepare(xvip->clk);\r\n}\r\nint xvip_enum_mbus_code(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstruct v4l2_mbus_framefmt *format;\r\nif (code->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn -EINVAL;\r\nif (code->index)\r\nreturn -EINVAL;\r\nformat = v4l2_subdev_get_try_format(subdev, cfg, code->pad);\r\ncode->code = format->code;\r\nreturn 0;\r\n}\r\nint xvip_enum_frame_size(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct v4l2_mbus_framefmt *format;\r\nif (fse->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn -EINVAL;\r\nformat = v4l2_subdev_get_try_format(subdev, cfg, fse->pad);\r\nif (fse->index || fse->code != format->code)\r\nreturn -EINVAL;\r\nif (fse->pad == XVIP_PAD_SINK) {\r\nfse->min_width = XVIP_MIN_WIDTH;\r\nfse->max_width = XVIP_MAX_WIDTH;\r\nfse->min_height = XVIP_MIN_HEIGHT;\r\nfse->max_height = XVIP_MAX_HEIGHT;\r\n} else {\r\nfse->min_width = format->width;\r\nfse->max_width = format->width;\r\nfse->min_height = format->height;\r\nfse->max_height = format->height;\r\n}\r\nreturn 0;\r\n}
