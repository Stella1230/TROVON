ax25_cb *ax25_send_frame(struct sk_buff *skb, int paclen, ax25_address *src, ax25_address *dest, ax25_digi *digi, struct net_device *dev)\r\n{\r\nax25_dev *ax25_dev;\r\nax25_cb *ax25;\r\nif (paclen == 0) {\r\nif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\r\nreturn NULL;\r\npaclen = ax25_dev->values[AX25_VALUES_PACLEN];\r\n}\r\nif ((ax25 = ax25_find_cb(src, dest, digi, dev)) != NULL) {\r\nax25_output(ax25, paclen, skb);\r\nreturn ax25;\r\n}\r\nif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\r\nreturn NULL;\r\nif ((ax25 = ax25_create_cb()) == NULL)\r\nreturn NULL;\r\nax25_fillin_cb(ax25, ax25_dev);\r\nax25->source_addr = *src;\r\nax25->dest_addr = *dest;\r\nif (digi != NULL) {\r\nax25->digipeat = kmemdup(digi, sizeof(*digi), GFP_ATOMIC);\r\nif (ax25->digipeat == NULL) {\r\nax25_cb_put(ax25);\r\nreturn NULL;\r\n}\r\n}\r\nswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\r\ncase AX25_PROTO_STD_SIMPLEX:\r\ncase AX25_PROTO_STD_DUPLEX:\r\nax25_std_establish_data_link(ax25);\r\nbreak;\r\n#ifdef CONFIG_AX25_DAMA_SLAVE\r\ncase AX25_PROTO_DAMA_SLAVE:\r\nif (ax25_dev->dama.slave)\r\nax25_ds_establish_data_link(ax25);\r\nelse\r\nax25_std_establish_data_link(ax25);\r\nbreak;\r\n#endif\r\n}\r\nax25_cb_hold(ax25);\r\nax25_cb_add(ax25);\r\nax25->state = AX25_STATE_1;\r\nax25_start_heartbeat(ax25);\r\nax25_output(ax25, paclen, skb);\r\nreturn ax25;\r\n}\r\nvoid ax25_output(ax25_cb *ax25, int paclen, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *skbn;\r\nunsigned char *p;\r\nint frontlen, len, fragno, ka9qfrag, first = 1;\r\nif (paclen < 16) {\r\nWARN_ON_ONCE(1);\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif ((skb->len - 1) > paclen) {\r\nif (*skb->data == AX25_P_TEXT) {\r\nskb_pull(skb, 1);\r\nka9qfrag = 0;\r\n} else {\r\npaclen -= 2;\r\nka9qfrag = 1;\r\n}\r\nfragno = skb->len / paclen;\r\nif (skb->len % paclen == 0) fragno--;\r\nfrontlen = skb_headroom(skb);\r\nwhile (skb->len > 0) {\r\nspin_lock_bh(&ax25_frag_lock);\r\nif ((skbn = alloc_skb(paclen + 2 + frontlen, GFP_ATOMIC)) == NULL) {\r\nspin_unlock_bh(&ax25_frag_lock);\r\nprintk(KERN_CRIT "AX.25: ax25_output - out of memory\n");\r\nreturn;\r\n}\r\nif (skb->sk != NULL)\r\nskb_set_owner_w(skbn, skb->sk);\r\nspin_unlock_bh(&ax25_frag_lock);\r\nlen = (paclen > skb->len) ? skb->len : paclen;\r\nif (ka9qfrag == 1) {\r\nskb_reserve(skbn, frontlen + 2);\r\nskb_set_network_header(skbn,\r\nskb_network_offset(skb));\r\nskb_copy_from_linear_data(skb, skb_put(skbn, len), len);\r\np = skb_push(skbn, 2);\r\n*p++ = AX25_P_SEGMENT;\r\n*p = fragno--;\r\nif (first) {\r\n*p |= AX25_SEG_FIRST;\r\nfirst = 0;\r\n}\r\n} else {\r\nskb_reserve(skbn, frontlen + 1);\r\nskb_set_network_header(skbn,\r\nskb_network_offset(skb));\r\nskb_copy_from_linear_data(skb, skb_put(skbn, len), len);\r\np = skb_push(skbn, 1);\r\n*p = AX25_P_TEXT;\r\n}\r\nskb_pull(skb, len);\r\nskb_queue_tail(&ax25->write_queue, skbn);\r\n}\r\nkfree_skb(skb);\r\n} else {\r\nskb_queue_tail(&ax25->write_queue, skb);\r\n}\r\nswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\r\ncase AX25_PROTO_STD_SIMPLEX:\r\ncase AX25_PROTO_STD_DUPLEX:\r\nax25_kick(ax25);\r\nbreak;\r\n#ifdef CONFIG_AX25_DAMA_SLAVE\r\ncase AX25_PROTO_DAMA_SLAVE:\r\nif (!ax25->ax25_dev->dama.slave) ax25_kick(ax25);\r\nbreak;\r\n#endif\r\n}\r\n}\r\nstatic void ax25_send_iframe(ax25_cb *ax25, struct sk_buff *skb, int poll_bit)\r\n{\r\nunsigned char *frame;\r\nif (skb == NULL)\r\nreturn;\r\nskb_reset_network_header(skb);\r\nif (ax25->modulus == AX25_MODULUS) {\r\nframe = skb_push(skb, 1);\r\n*frame = AX25_I;\r\n*frame |= (poll_bit) ? AX25_PF : 0;\r\n*frame |= (ax25->vr << 5);\r\n*frame |= (ax25->vs << 1);\r\n} else {\r\nframe = skb_push(skb, 2);\r\nframe[0] = AX25_I;\r\nframe[0] |= (ax25->vs << 1);\r\nframe[1] = (poll_bit) ? AX25_EPF : 0;\r\nframe[1] |= (ax25->vr << 1);\r\n}\r\nax25_start_idletimer(ax25);\r\nax25_transmit_buffer(ax25, skb, AX25_COMMAND);\r\n}\r\nvoid ax25_kick(ax25_cb *ax25)\r\n{\r\nstruct sk_buff *skb, *skbn;\r\nint last = 1;\r\nunsigned short start, end, next;\r\nif (ax25->state != AX25_STATE_3 && ax25->state != AX25_STATE_4)\r\nreturn;\r\nif (ax25->condition & AX25_COND_PEER_RX_BUSY)\r\nreturn;\r\nif (skb_peek(&ax25->write_queue) == NULL)\r\nreturn;\r\nstart = (skb_peek(&ax25->ack_queue) == NULL) ? ax25->va : ax25->vs;\r\nend = (ax25->va + ax25->window) % ax25->modulus;\r\nif (start == end)\r\nreturn;\r\nskb = skb_dequeue(&ax25->write_queue);\r\nif (!skb)\r\nreturn;\r\nax25->vs = start;\r\ndo {\r\nif ((skbn = skb_clone(skb, GFP_ATOMIC)) == NULL) {\r\nskb_queue_head(&ax25->write_queue, skb);\r\nbreak;\r\n}\r\nif (skb->sk != NULL)\r\nskb_set_owner_w(skbn, skb->sk);\r\nnext = (ax25->vs + 1) % ax25->modulus;\r\nlast = (next == end);\r\nswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\r\ncase AX25_PROTO_STD_SIMPLEX:\r\ncase AX25_PROTO_STD_DUPLEX:\r\nax25_send_iframe(ax25, skbn, (last) ? AX25_POLLON : AX25_POLLOFF);\r\nbreak;\r\n#ifdef CONFIG_AX25_DAMA_SLAVE\r\ncase AX25_PROTO_DAMA_SLAVE:\r\nax25_send_iframe(ax25, skbn, AX25_POLLOFF);\r\nbreak;\r\n#endif\r\n}\r\nax25->vs = next;\r\nskb_queue_tail(&ax25->ack_queue, skb);\r\n} while (!last && (skb = skb_dequeue(&ax25->write_queue)) != NULL);\r\nax25->condition &= ~AX25_COND_ACK_PENDING;\r\nif (!ax25_t1timer_running(ax25)) {\r\nax25_stop_t3timer(ax25);\r\nax25_calculate_t1(ax25);\r\nax25_start_t1timer(ax25);\r\n}\r\n}\r\nvoid ax25_transmit_buffer(ax25_cb *ax25, struct sk_buff *skb, int type)\r\n{\r\nstruct sk_buff *skbn;\r\nunsigned char *ptr;\r\nint headroom;\r\nif (ax25->ax25_dev == NULL) {\r\nax25_disconnect(ax25, ENETUNREACH);\r\nreturn;\r\n}\r\nheadroom = ax25_addr_size(ax25->digipeat);\r\nif (skb_headroom(skb) < headroom) {\r\nif ((skbn = skb_realloc_headroom(skb, headroom)) == NULL) {\r\nprintk(KERN_CRIT "AX.25: ax25_transmit_buffer - out of memory\n");\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (skb->sk != NULL)\r\nskb_set_owner_w(skbn, skb->sk);\r\nconsume_skb(skb);\r\nskb = skbn;\r\n}\r\nptr = skb_push(skb, headroom);\r\nax25_addr_build(ptr, &ax25->source_addr, &ax25->dest_addr, ax25->digipeat, type, ax25->modulus);\r\nax25_queue_xmit(skb, ax25->ax25_dev->dev);\r\n}\r\nvoid ax25_queue_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nunsigned char *ptr;\r\nskb->protocol = ax25_type_trans(skb, ax25_fwd_dev(dev));\r\nptr = skb_push(skb, 1);\r\n*ptr = 0x00;\r\ndev_queue_xmit(skb);\r\n}\r\nint ax25_check_iframes_acked(ax25_cb *ax25, unsigned short nr)\r\n{\r\nif (ax25->vs == nr) {\r\nax25_frames_acked(ax25, nr);\r\nax25_calculate_rtt(ax25);\r\nax25_stop_t1timer(ax25);\r\nax25_start_t3timer(ax25);\r\nreturn 1;\r\n} else {\r\nif (ax25->va != nr) {\r\nax25_frames_acked(ax25, nr);\r\nax25_calculate_t1(ax25);\r\nax25_start_t1timer(ax25);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}
