int\r\nnv50_dac_power(NV50_DISP_MTHD_V1)\r\n{\r\nstruct nvkm_device *device = disp->base.engine.subdev.device;\r\nconst u32 doff = outp->or * 0x800;\r\nunion {\r\nstruct nv50_disp_dac_pwr_v0 v0;\r\n} *args = data;\r\nu32 stat;\r\nint ret;\r\nnvif_ioctl(object, "disp dac pwr size %d\n", size);\r\nif (nvif_unpack(args->v0, 0, 0, false)) {\r\nnvif_ioctl(object, "disp dac pwr vers %d state %d data %d "\r\n"vsync %d hsync %d\n",\r\nargs->v0.version, args->v0.state, args->v0.data,\r\nargs->v0.vsync, args->v0.hsync);\r\nstat = 0x00000040 * !args->v0.state;\r\nstat |= 0x00000010 * !args->v0.data;\r\nstat |= 0x00000004 * !args->v0.vsync;\r\nstat |= 0x00000001 * !args->v0.hsync;\r\n} else\r\nreturn ret;\r\nnvkm_msec(device, 2000,\r\nif (!(nvkm_rd32(device, 0x61a004 + doff) & 0x80000000))\r\nbreak;\r\n);\r\nnvkm_mask(device, 0x61a004 + doff, 0xc000007f, 0x80000000 | stat);\r\nnvkm_msec(device, 2000,\r\nif (!(nvkm_rd32(device, 0x61a004 + doff) & 0x80000000))\r\nbreak;\r\n);\r\nreturn 0;\r\n}\r\nint\r\nnv50_dac_sense(NV50_DISP_MTHD_V1)\r\n{\r\nstruct nvkm_subdev *subdev = &disp->base.engine.subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nunion {\r\nstruct nv50_disp_dac_load_v0 v0;\r\n} *args = data;\r\nconst u32 doff = outp->or * 0x800;\r\nu32 loadval;\r\nint ret;\r\nnvif_ioctl(object, "disp dac load size %d\n", size);\r\nif (nvif_unpack(args->v0, 0, 0, false)) {\r\nnvif_ioctl(object, "disp dac load vers %d data %08x\n",\r\nargs->v0.version, args->v0.data);\r\nif (args->v0.data & 0xfff00000)\r\nreturn -EINVAL;\r\nloadval = args->v0.data;\r\n} else\r\nreturn ret;\r\nnvkm_mask(device, 0x61a004 + doff, 0x807f0000, 0x80150000);\r\nnvkm_msec(device, 2000,\r\nif (!(nvkm_rd32(device, 0x61a004 + doff) & 0x80000000))\r\nbreak;\r\n);\r\nnvkm_wr32(device, 0x61a00c + doff, 0x00100000 | loadval);\r\nmdelay(9);\r\nudelay(500);\r\nloadval = nvkm_mask(device, 0x61a00c + doff, 0xffffffff, 0x00000000);\r\nnvkm_mask(device, 0x61a004 + doff, 0x807f0000, 0x80550000);\r\nnvkm_msec(device, 2000,\r\nif (!(nvkm_rd32(device, 0x61a004 + doff) & 0x80000000))\r\nbreak;\r\n);\r\nnvkm_debug(subdev, "DAC%d sense: %08x\n", outp->or, loadval);\r\nif (!(loadval & 0x80000000))\r\nreturn -ETIMEDOUT;\r\nargs->v0.load = (loadval & 0x38000000) >> 27;\r\nreturn 0;\r\n}\r\nint\r\nnv50_dac_output_new(struct nvkm_disp *disp, int index,\r\nstruct dcb_output *dcbE, struct nvkm_output **poutp)\r\n{\r\nreturn nvkm_output_new_(&nv50_dac_output_func, disp,\r\nindex, dcbE, poutp);\r\n}
