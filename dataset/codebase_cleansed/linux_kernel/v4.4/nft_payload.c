static bool\r\nnft_payload_copy_vlan(u32 *d, const struct sk_buff *skb, u8 offset, u8 len)\r\n{\r\nint mac_off = skb_mac_header(skb) - skb->data;\r\nu8 vlan_len, *vlanh, *dst_u8 = (u8 *) d;\r\nstruct vlan_ethhdr veth;\r\nvlanh = (u8 *) &veth;\r\nif (offset < ETH_HLEN) {\r\nu8 ethlen = min_t(u8, len, ETH_HLEN - offset);\r\nif (skb_copy_bits(skb, mac_off, &veth, ETH_HLEN))\r\nreturn false;\r\nveth.h_vlan_proto = skb->vlan_proto;\r\nmemcpy(dst_u8, vlanh + offset, ethlen);\r\nlen -= ethlen;\r\nif (len == 0)\r\nreturn true;\r\ndst_u8 += ethlen;\r\noffset = ETH_HLEN;\r\n} else if (offset >= VLAN_ETH_HLEN) {\r\noffset -= VLAN_HLEN;\r\ngoto skip;\r\n}\r\nveth.h_vlan_TCI = htons(skb_vlan_tag_get(skb));\r\nveth.h_vlan_encapsulated_proto = skb->protocol;\r\nvlanh += offset;\r\nvlan_len = min_t(u8, len, VLAN_ETH_HLEN - offset);\r\nmemcpy(dst_u8, vlanh, vlan_len);\r\nlen -= vlan_len;\r\nif (!len)\r\nreturn true;\r\ndst_u8 += vlan_len;\r\nskip:\r\nreturn skb_copy_bits(skb, offset + mac_off, dst_u8, len) == 0;\r\n}\r\nstatic void nft_payload_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_payload *priv = nft_expr_priv(expr);\r\nconst struct sk_buff *skb = pkt->skb;\r\nu32 *dest = &regs->data[priv->dreg];\r\nint offset;\r\ndest[priv->len / NFT_REG32_SIZE] = 0;\r\nswitch (priv->base) {\r\ncase NFT_PAYLOAD_LL_HEADER:\r\nif (!skb_mac_header_was_set(skb))\r\ngoto err;\r\nif (skb_vlan_tag_present(skb)) {\r\nif (!nft_payload_copy_vlan(dest, skb,\r\npriv->offset, priv->len))\r\ngoto err;\r\nreturn;\r\n}\r\noffset = skb_mac_header(skb) - skb->data;\r\nbreak;\r\ncase NFT_PAYLOAD_NETWORK_HEADER:\r\noffset = skb_network_offset(skb);\r\nbreak;\r\ncase NFT_PAYLOAD_TRANSPORT_HEADER:\r\noffset = pkt->xt.thoff;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\noffset += priv->offset;\r\nif (skb_copy_bits(skb, offset, dest, priv->len) < 0)\r\ngoto err;\r\nreturn;\r\nerr:\r\nregs->verdict.code = NFT_BREAK;\r\n}\r\nstatic int nft_payload_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_payload *priv = nft_expr_priv(expr);\r\npriv->base = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_BASE]));\r\npriv->offset = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_OFFSET]));\r\npriv->len = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN]));\r\npriv->dreg = nft_parse_register(tb[NFTA_PAYLOAD_DREG]);\r\nreturn nft_validate_register_store(ctx, priv->dreg, NULL,\r\nNFT_DATA_VALUE, priv->len);\r\n}\r\nstatic int nft_payload_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_payload *priv = nft_expr_priv(expr);\r\nif (nft_dump_register(skb, NFTA_PAYLOAD_DREG, priv->dreg) ||\r\nnla_put_be32(skb, NFTA_PAYLOAD_BASE, htonl(priv->base)) ||\r\nnla_put_be32(skb, NFTA_PAYLOAD_OFFSET, htonl(priv->offset)) ||\r\nnla_put_be32(skb, NFTA_PAYLOAD_LEN, htonl(priv->len)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic const struct nft_expr_ops *\r\nnft_payload_select_ops(const struct nft_ctx *ctx,\r\nconst struct nlattr * const tb[])\r\n{\r\nenum nft_payload_bases base;\r\nunsigned int offset, len;\r\nif (tb[NFTA_PAYLOAD_DREG] == NULL ||\r\ntb[NFTA_PAYLOAD_BASE] == NULL ||\r\ntb[NFTA_PAYLOAD_OFFSET] == NULL ||\r\ntb[NFTA_PAYLOAD_LEN] == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nbase = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_BASE]));\r\nswitch (base) {\r\ncase NFT_PAYLOAD_LL_HEADER:\r\ncase NFT_PAYLOAD_NETWORK_HEADER:\r\ncase NFT_PAYLOAD_TRANSPORT_HEADER:\r\nbreak;\r\ndefault:\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\n}\r\noffset = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_OFFSET]));\r\nlen = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN]));\r\nif (len <= 4 && is_power_of_2(len) && IS_ALIGNED(offset, len) &&\r\nbase != NFT_PAYLOAD_LL_HEADER)\r\nreturn &nft_payload_fast_ops;\r\nelse\r\nreturn &nft_payload_ops;\r\n}\r\nint __init nft_payload_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_payload_type);\r\n}\r\nvoid nft_payload_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_payload_type);\r\n}
