static unsigned int gpio_poll(struct file *file, poll_table *wait)\r\n{\r\nunsigned int mask = 0;\r\nstruct gpio_private *priv = file->private_data;\r\nunsigned long data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\npoll_wait(file, &priv->alarm_wq, wait);\r\nif (priv->minor == GPIO_MINOR_A) {\r\nunsigned long tmp;\r\ndata = *R_PORT_PA_DATA;\r\ntmp = ~data & priv->highalarm & 0xFF;\r\ntmp = (tmp << R_IRQ_MASK1_SET__pa0__BITNR);\r\ngpio_pa_irq_enabled_mask |= tmp;\r\n*R_IRQ_MASK1_SET = tmp;\r\n} else if (priv->minor == GPIO_MINOR_B)\r\ndata = *R_PORT_PB_DATA;\r\nelse if (priv->minor == GPIO_MINOR_G)\r\ndata = *R_PORT_G_DATA;\r\nelse {\r\nmask = 0;\r\ngoto out;\r\n}\r\nif ((data & priv->highalarm) ||\r\n(~data & priv->lowalarm)) {\r\nmask = POLLIN|POLLRDNORM;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nDP(printk("gpio_poll ready: mask 0x%08X\n", mask));\r\nreturn mask;\r\n}\r\nint etrax_gpio_wake_up_check(void)\r\n{\r\nstruct gpio_private *priv;\r\nunsigned long data = 0;\r\nint ret = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\npriv = alarmlist;\r\nwhile (priv) {\r\nif (USE_PORTS(priv))\r\ndata = *priv->port;\r\nelse if (priv->minor == GPIO_MINOR_G)\r\ndata = *R_PORT_G_DATA;\r\nif ((data & priv->highalarm) ||\r\n(~data & priv->lowalarm)) {\r\nDP(printk("etrax_gpio_wake_up_check %i\n",priv->minor));\r\nwake_up_interruptible(&priv->alarm_wq);\r\nret = 1;\r\n}\r\npriv = priv->next;\r\n}\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t\r\ngpio_poll_timer_interrupt(int irq, void *dev_id)\r\n{\r\nif (gpio_some_alarms) {\r\netrax_gpio_wake_up_check();\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic irqreturn_t\r\ngpio_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned long tmp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\ntmp = (*R_IRQ_READ1);\r\ntmp &= gpio_pa_irq_enabled_mask;\r\n*R_IRQ_MASK1_CLR = tmp;\r\ngpio_pa_irq_enabled_mask &= ~tmp;\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nif (gpio_some_alarms)\r\nreturn IRQ_RETVAL(etrax_gpio_wake_up_check());\r\nreturn IRQ_NONE;\r\n}\r\nstatic void gpio_write_bit(struct gpio_private *priv,\r\nunsigned char data, int bit)\r\n{\r\n*priv->port = *priv->shadow &= ~(priv->clk_mask);\r\nif (data & 1 << bit)\r\n*priv->port = *priv->shadow |= priv->data_mask;\r\nelse\r\n*priv->port = *priv->shadow &= ~(priv->data_mask);\r\n*priv->port = *priv->shadow |= priv->clk_mask;\r\n}\r\nstatic void gpio_write_byte(struct gpio_private *priv, unsigned char data)\r\n{\r\nint i;\r\nif (priv->write_msb)\r\nfor (i = 7; i >= 0; i--)\r\ngpio_write_bit(priv, data, i);\r\nelse\r\nfor (i = 0; i <= 7; i++)\r\ngpio_write_bit(priv, data, i);\r\n}\r\nstatic ssize_t gpio_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct gpio_private *priv = file->private_data;\r\nunsigned long flags;\r\nssize_t retval = count;\r\nif (priv->minor != GPIO_MINOR_A && priv->minor != GPIO_MINOR_B)\r\nreturn -EFAULT;\r\nif (!access_ok(VERIFY_READ, buf, count))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nif (priv->clk_mask == 0 || priv->data_mask == 0) {\r\nretval = -EPERM;\r\ngoto out;\r\n}\r\nD(printk(KERN_DEBUG "gpio_write: %02X to data 0x%02X "\r\n"clk 0x%02X msb: %i\n",\r\ncount, priv->data_mask, priv->clk_mask, priv->write_msb));\r\nwhile (count--)\r\ngpio_write_byte(priv, *buf++);\r\nout:\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nreturn retval;\r\n}\r\nstatic int\r\ngpio_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct gpio_private *priv;\r\nint p = iminor(inode);\r\nunsigned long flags;\r\nif (p > GPIO_MINOR_LAST)\r\nreturn -EINVAL;\r\npriv = kzalloc(sizeof(struct gpio_private), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->minor = p;\r\nif (USE_PORTS(priv)) {\r\npriv->port = ports[p];\r\npriv->shadow = shads[p];\r\npriv->dir = dir[p];\r\npriv->dir_shadow = dir_shadow[p];\r\npriv->changeable_dir = changeable_dir[p];\r\npriv->changeable_bits = changeable_bits[p];\r\n} else {\r\npriv->port = NULL;\r\npriv->shadow = NULL;\r\npriv->dir = NULL;\r\npriv->dir_shadow = NULL;\r\npriv->changeable_dir = 0;\r\npriv->changeable_bits = 0;\r\n}\r\npriv->highalarm = 0;\r\npriv->lowalarm = 0;\r\npriv->clk_mask = 0;\r\npriv->data_mask = 0;\r\ninit_waitqueue_head(&priv->alarm_wq);\r\nfilp->private_data = priv;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\npriv->next = alarmlist;\r\nalarmlist = priv;\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\ngpio_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct gpio_private *p;\r\nstruct gpio_private *todel;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\np = alarmlist;\r\ntodel = filp->private_data;\r\nif (p == todel) {\r\nalarmlist = todel->next;\r\n} else {\r\nwhile (p->next != todel)\r\np = p->next;\r\np->next = todel->next;\r\n}\r\nkfree(todel);\r\np = alarmlist;\r\nwhile (p) {\r\nif (p->highalarm | p->lowalarm) {\r\ngpio_some_alarms = 1;\r\ngoto out;\r\n}\r\np = p->next;\r\n}\r\ngpio_some_alarms = 0;\r\nout:\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nreturn 0;\r\n}\r\nunsigned long inline setget_input(struct gpio_private *priv, unsigned long arg)\r\n{\r\nif (USE_PORTS(priv)) {\r\n*priv->dir = *priv->dir_shadow &=\r\n~((unsigned char)arg & priv->changeable_dir);\r\nreturn ~(*priv->dir_shadow) & 0xFF;\r\n}\r\nif (priv->minor != GPIO_MINOR_G)\r\nreturn 0;\r\nif (((arg & dir_g_in_bits) != arg) &&\r\n(arg & changeable_dir_g)) {\r\narg &= changeable_dir_g;\r\nif (arg & (1<<0)) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, g0dir);\r\ndir_g_in_bits |= (1<<0);\r\ndir_g_out_bits &= ~(1<<0);\r\n}\r\nif ((arg & 0x0000FF00) == 0x0000FF00) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, g8_15dir);\r\ndir_g_in_bits |= 0x0000FF00;\r\ndir_g_out_bits &= ~0x0000FF00;\r\n}\r\nif ((arg & 0x00FF0000) == 0x00FF0000) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, g16_23dir);\r\ndir_g_in_bits |= 0x00FF0000;\r\ndir_g_out_bits &= ~0x00FF0000;\r\n}\r\nif (arg & (1<<24)) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, g24dir);\r\ndir_g_in_bits |= (1<<24);\r\ndir_g_out_bits &= ~(1<<24);\r\n}\r\nD(printk(KERN_DEBUG "gpio: SETINPUT on port G set "\r\n"genconfig to 0x%08lX "\r\n"in_bits: 0x%08lX "\r\n"out_bits: 0x%08lX\n",\r\n(unsigned long)genconfig_shadow,\r\ndir_g_in_bits, dir_g_out_bits));\r\n*R_GEN_CONFIG = genconfig_shadow;\r\n}\r\nreturn dir_g_in_bits;\r\n}\r\nunsigned long inline setget_output(struct gpio_private *priv, unsigned long arg)\r\n{\r\nif (USE_PORTS(priv)) {\r\n*priv->dir = *priv->dir_shadow |=\r\n((unsigned char)arg & priv->changeable_dir);\r\nreturn *priv->dir_shadow;\r\n}\r\nif (priv->minor != GPIO_MINOR_G)\r\nreturn 0;\r\nif (((arg & dir_g_out_bits) != arg) &&\r\n(arg & changeable_dir_g)) {\r\nif (arg & (1<<0)) {\r\ngenconfig_shadow |= IO_MASK(R_GEN_CONFIG, g0dir);\r\ndir_g_out_bits |= (1<<0);\r\ndir_g_in_bits &= ~(1<<0);\r\n}\r\nif ((arg & 0x0000FF00) == 0x0000FF00) {\r\ngenconfig_shadow |= IO_MASK(R_GEN_CONFIG, g8_15dir);\r\ndir_g_out_bits |= 0x0000FF00;\r\ndir_g_in_bits &= ~0x0000FF00;\r\n}\r\nif ((arg & 0x00FF0000) == 0x00FF0000) {\r\ngenconfig_shadow |= IO_MASK(R_GEN_CONFIG, g16_23dir);\r\ndir_g_out_bits |= 0x00FF0000;\r\ndir_g_in_bits &= ~0x00FF0000;\r\n}\r\nif (arg & (1<<24)) {\r\ngenconfig_shadow |= IO_MASK(R_GEN_CONFIG, g24dir);\r\ndir_g_out_bits |= (1<<24);\r\ndir_g_in_bits &= ~(1<<24);\r\n}\r\nD(printk(KERN_INFO "gpio: SETOUTPUT on port G set "\r\n"genconfig to 0x%08lX "\r\n"in_bits: 0x%08lX "\r\n"out_bits: 0x%08lX\n",\r\n(unsigned long)genconfig_shadow,\r\ndir_g_in_bits, dir_g_out_bits));\r\n*R_GEN_CONFIG = genconfig_shadow;\r\n}\r\nreturn dir_g_out_bits & 0x7FFFFFFF;\r\n}\r\nstatic long gpio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nunsigned long flags;\r\nunsigned long val;\r\nint ret = 0;\r\nstruct gpio_private *priv = file->private_data;\r\nif (_IOC_TYPE(cmd) != ETRAXGPIO_IOCTYPE)\r\nreturn -EINVAL;\r\nswitch (_IOC_NR(cmd)) {\r\ncase IO_READBITS:\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nif (USE_PORTS(priv)) {\r\nret = *priv->port;\r\n} else if (priv->minor == GPIO_MINOR_G) {\r\nret = (*R_PORT_G_DATA) & 0x7FFFFFFF;\r\n}\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nbreak;\r\ncase IO_SETBITS:\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nif (USE_PORTS(priv)) {\r\n*priv->port = *priv->shadow |=\r\n((unsigned char)arg & priv->changeable_bits);\r\n} else if (priv->minor == GPIO_MINOR_G) {\r\n*R_PORT_G_DATA = port_g_data_shadow |= (arg & dir_g_out_bits);\r\n}\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nbreak;\r\ncase IO_CLRBITS:\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nif (USE_PORTS(priv)) {\r\n*priv->port = *priv->shadow &=\r\n~((unsigned char)arg & priv->changeable_bits);\r\n} else if (priv->minor == GPIO_MINOR_G) {\r\n*R_PORT_G_DATA = port_g_data_shadow &= ~((unsigned long)arg & dir_g_out_bits);\r\n}\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nbreak;\r\ncase IO_HIGHALARM:\r\nspin_lock_irqsave(&gpio_lock, flags);\r\npriv->highalarm |= arg;\r\ngpio_some_alarms = 1;\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nbreak;\r\ncase IO_LOWALARM:\r\nspin_lock_irqsave(&gpio_lock, flags);\r\npriv->lowalarm |= arg;\r\ngpio_some_alarms = 1;\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nbreak;\r\ncase IO_CLRALARM:\r\nspin_lock_irqsave(&gpio_lock, flags);\r\npriv->highalarm &= ~arg;\r\npriv->lowalarm &= ~arg;\r\n{\r\nstruct gpio_private *p = alarmlist;\r\nint some_alarms;\r\np = alarmlist;\r\nsome_alarms = 0;\r\nwhile (p) {\r\nif (p->highalarm | p->lowalarm) {\r\nsome_alarms = 1;\r\nbreak;\r\n}\r\np = p->next;\r\n}\r\ngpio_some_alarms = some_alarms;\r\n}\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nbreak;\r\ncase IO_READDIR:\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nif (USE_PORTS(priv)) {\r\nret = *priv->dir_shadow;\r\n} else if (priv->minor == GPIO_MINOR_G) {\r\nret = (dir_g_shadow | dir_g_out_bits) & 0x7FFFFFFF;\r\n}\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nbreak;\r\ncase IO_SETINPUT:\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nret = setget_input(priv, arg) & 0x7FFFFFFF;\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nbreak;\r\ncase IO_SETOUTPUT:\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nret = setget_output(priv, arg) & 0x7FFFFFFF;\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nbreak;\r\ncase IO_SHUTDOWN:\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nSOFT_SHUTDOWN();\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nbreak;\r\ncase IO_GET_PWR_BT:\r\nspin_lock_irqsave(&gpio_lock, flags);\r\n#if defined (CONFIG_ETRAX_SOFT_SHUTDOWN)\r\nret = (*R_PORT_G_DATA & ( 1 << CONFIG_ETRAX_POWERBUTTON_BIT));\r\n#else\r\nret = 0;\r\n#endif\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nbreak;\r\ncase IO_CFG_WRITE_MODE:\r\nspin_lock_irqsave(&gpio_lock, flags);\r\npriv->clk_mask = arg & 0xFF;\r\npriv->data_mask = (arg >> 8) & 0xFF;\r\npriv->write_msb = (arg >> 16) & 0x01;\r\nif (!((priv->clk_mask & priv->changeable_bits) &&\r\n(priv->data_mask & priv->changeable_bits) &&\r\n(priv->clk_mask & *priv->dir_shadow) &&\r\n(priv->data_mask & *priv->dir_shadow)))\r\n{\r\npriv->clk_mask = 0;\r\npriv->data_mask = 0;\r\nret = -EPERM;\r\n}\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nbreak;\r\ncase IO_READ_INBITS:\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nif (USE_PORTS(priv)) {\r\nval = *priv->port;\r\n} else if (priv->minor == GPIO_MINOR_G) {\r\nval = *R_PORT_G_DATA;\r\n}\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nif (copy_to_user((void __user *)arg, &val, sizeof(val)))\r\nret = -EFAULT;\r\nbreak;\r\ncase IO_READ_OUTBITS:\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nif (USE_PORTS(priv)) {\r\nval = *priv->shadow;\r\n} else if (priv->minor == GPIO_MINOR_G) {\r\nval = port_g_data_shadow;\r\n}\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nif (copy_to_user((void __user *)arg, &val, sizeof(val)))\r\nret = -EFAULT;\r\nbreak;\r\ncase IO_SETGET_INPUT:\r\nif (copy_from_user(&val, (void __user *)arg, sizeof(val)))\r\n{\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nval = setget_input(priv, val);\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nif (copy_to_user((void __user *)arg, &val, sizeof(val)))\r\nret = -EFAULT;\r\nbreak;\r\ncase IO_SETGET_OUTPUT:\r\nif (copy_from_user(&val, (void __user *)arg, sizeof(val))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nval = setget_output(priv, val);\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nif (copy_to_user((void __user *)arg, &val, sizeof(val)))\r\nret = -EFAULT;\r\nbreak;\r\ndefault:\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nif (priv->minor == GPIO_MINOR_LEDS)\r\nret = gpio_leds_ioctl(cmd, arg);\r\nelse\r\nret = -EINVAL;\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\ngpio_leds_ioctl(unsigned int cmd, unsigned long arg)\r\n{\r\nunsigned char green;\r\nunsigned char red;\r\nswitch (_IOC_NR(cmd)) {\r\ncase IO_LEDACTIVE_SET:\r\ngreen = ((unsigned char)arg) & 1;\r\nred = (((unsigned char)arg) >> 1) & 1;\r\nCRIS_LED_ACTIVE_SET_G(green);\r\nCRIS_LED_ACTIVE_SET_R(red);\r\nbreak;\r\ncase IO_LED_SETBIT:\r\nCRIS_LED_BIT_SET(arg);\r\nbreak;\r\ncase IO_LED_CLRBIT:\r\nCRIS_LED_BIT_CLR(arg);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ioif_watcher(const unsigned int gpio_in_available,\r\nconst unsigned int gpio_out_available,\r\nconst unsigned char pa_available,\r\nconst unsigned char pb_available)\r\n{\r\nunsigned long int flags;\r\nD(printk(KERN_DEBUG "gpio.c: ioif_watcher called\n"));\r\nD(printk(KERN_DEBUG "gpio.c: G in: 0x%08x G out: 0x%08x "\r\n"PA: 0x%02x PB: 0x%02x\n",\r\ngpio_in_available, gpio_out_available,\r\npa_available, pb_available));\r\nspin_lock_irqsave(&gpio_lock, flags);\r\ndir_g_in_bits = gpio_in_available;\r\ndir_g_out_bits = gpio_out_available;\r\nif (genconfig_shadow & IO_STATE(R_GEN_CONFIG, g0dir, out))\r\ndir_g_shadow |= (1 << 0);\r\nif (genconfig_shadow & IO_STATE(R_GEN_CONFIG, g8_15dir, out))\r\ndir_g_shadow |= 0x0000FF00;\r\nif (genconfig_shadow & IO_STATE(R_GEN_CONFIG, g16_23dir, out))\r\ndir_g_shadow |= 0x00FF0000;\r\nif (genconfig_shadow & IO_STATE(R_GEN_CONFIG, g24dir, out))\r\ndir_g_shadow |= (1 << 24);\r\nchangeable_dir_g = changeable_dir_g_mask;\r\nchangeable_dir_g &= dir_g_out_bits;\r\nchangeable_dir_g &= dir_g_in_bits;\r\ndir_g_out_bits &= ~changeable_dir_g;\r\ndir_g_out_bits |= dir_g_shadow;\r\ndir_g_in_bits &= ~changeable_dir_g;\r\ndir_g_in_bits |= (~dir_g_shadow & changeable_dir_g);\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nprintk(KERN_INFO "GPIO port G: in_bits: 0x%08lX out_bits: 0x%08lX "\r\n"val: %08lX\n",\r\ndir_g_in_bits, dir_g_out_bits, (unsigned long)*R_PORT_G_DATA);\r\nprintk(KERN_INFO "GPIO port G: dir: %08lX changeable: %08lX\n",\r\ndir_g_shadow, changeable_dir_g);\r\n}\r\nstatic int __init gpio_init(void)\r\n{\r\nint res;\r\n#if defined (CONFIG_ETRAX_CSP0_LEDS)\r\nint i;\r\n#endif\r\nres = register_chrdev(GPIO_MAJOR, gpio_name, &gpio_fops);\r\nif (res < 0) {\r\nprintk(KERN_ERR "gpio: couldn't get a major number.\n");\r\nreturn res;\r\n}\r\n#if defined (CONFIG_ETRAX_CSP0_LEDS) || defined (CONFIG_ETRAX_PA_LEDS) || defined (CONFIG_ETRAX_PB_LEDS)\r\nCRIS_LED_NETWORK_SET(0);\r\nCRIS_LED_ACTIVE_SET(0);\r\nCRIS_LED_DISK_READ(0);\r\nCRIS_LED_DISK_WRITE(0);\r\n#if defined (CONFIG_ETRAX_CSP0_LEDS)\r\nfor (i = 0; i < 32; i++)\r\nCRIS_LED_BIT_SET(i);\r\n#endif\r\n#endif\r\nif (cris_io_interface_register_watcher(ioif_watcher)){\r\nprintk(KERN_WARNING "gpio_init: Failed to install IO "\r\n"if allocator watcher\n");\r\n}\r\nprintk(KERN_INFO "ETRAX 100LX GPIO driver v2.5, (c) 2001-2008 "\r\n"Axis Communications AB\n");\r\nres = request_irq(TIMER0_IRQ_NBR, gpio_poll_timer_interrupt,\r\nIRQF_SHARED, "gpio poll", gpio_name);\r\nif (res) {\r\nprintk(KERN_CRIT "err: timer0 irq for gpio\n");\r\nreturn res;\r\n}\r\nres = request_irq(PA_IRQ_NBR, gpio_interrupt,\r\nIRQF_SHARED, "gpio PA", gpio_name);\r\nif (res)\r\nprintk(KERN_CRIT "err: PA irq for gpio\n");\r\nreturn res;\r\n}
