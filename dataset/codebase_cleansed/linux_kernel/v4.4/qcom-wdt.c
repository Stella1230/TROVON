static inline\r\nstruct qcom_wdt *to_qcom_wdt(struct watchdog_device *wdd)\r\n{\r\nreturn container_of(wdd, struct qcom_wdt, wdd);\r\n}\r\nstatic int qcom_wdt_start(struct watchdog_device *wdd)\r\n{\r\nstruct qcom_wdt *wdt = to_qcom_wdt(wdd);\r\nwritel(0, wdt->base + WDT_EN);\r\nwritel(1, wdt->base + WDT_RST);\r\nwritel(wdd->timeout * wdt->rate, wdt->base + WDT_BITE_TIME);\r\nwritel(1, wdt->base + WDT_EN);\r\nreturn 0;\r\n}\r\nstatic int qcom_wdt_stop(struct watchdog_device *wdd)\r\n{\r\nstruct qcom_wdt *wdt = to_qcom_wdt(wdd);\r\nwritel(0, wdt->base + WDT_EN);\r\nreturn 0;\r\n}\r\nstatic int qcom_wdt_ping(struct watchdog_device *wdd)\r\n{\r\nstruct qcom_wdt *wdt = to_qcom_wdt(wdd);\r\nwritel(1, wdt->base + WDT_RST);\r\nreturn 0;\r\n}\r\nstatic int qcom_wdt_set_timeout(struct watchdog_device *wdd,\r\nunsigned int timeout)\r\n{\r\nwdd->timeout = timeout;\r\nreturn qcom_wdt_start(wdd);\r\n}\r\nstatic int qcom_wdt_restart(struct notifier_block *nb, unsigned long action,\r\nvoid *data)\r\n{\r\nstruct qcom_wdt *wdt = container_of(nb, struct qcom_wdt, restart_nb);\r\nu32 timeout;\r\ntimeout = 128 * wdt->rate / 1000;\r\nwritel(0, wdt->base + WDT_EN);\r\nwritel(1, wdt->base + WDT_RST);\r\nwritel(timeout, wdt->base + WDT_BITE_TIME);\r\nwritel(1, wdt->base + WDT_EN);\r\nwmb();\r\nmsleep(150);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int qcom_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct qcom_wdt *wdt;\r\nstruct resource *res;\r\nstruct device_node *np = pdev->dev.of_node;\r\nu32 percpu_offset;\r\nint ret;\r\nwdt = devm_kzalloc(&pdev->dev, sizeof(*wdt), GFP_KERNEL);\r\nif (!wdt)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (of_property_read_u32(np, "cpu-offset", &percpu_offset))\r\npercpu_offset = 0;\r\nres->start += percpu_offset;\r\nres->end += percpu_offset;\r\nwdt->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(wdt->base))\r\nreturn PTR_ERR(wdt->base);\r\nwdt->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(wdt->clk)) {\r\ndev_err(&pdev->dev, "failed to get input clock\n");\r\nreturn PTR_ERR(wdt->clk);\r\n}\r\nret = clk_prepare_enable(wdt->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to setup clock\n");\r\nreturn ret;\r\n}\r\nwdt->rate = clk_get_rate(wdt->clk);\r\nif (wdt->rate == 0 ||\r\nwdt->rate > 0x10000000U) {\r\ndev_err(&pdev->dev, "invalid clock rate\n");\r\nret = -EINVAL;\r\ngoto err_clk_unprepare;\r\n}\r\nwdt->wdd.dev = &pdev->dev;\r\nwdt->wdd.info = &qcom_wdt_info;\r\nwdt->wdd.ops = &qcom_wdt_ops;\r\nwdt->wdd.min_timeout = 1;\r\nwdt->wdd.max_timeout = 0x10000000U / wdt->rate;\r\nwdt->wdd.parent = &pdev->dev;\r\nwdt->wdd.timeout = min(wdt->wdd.max_timeout, 30U);\r\nwatchdog_init_timeout(&wdt->wdd, 0, &pdev->dev);\r\nret = watchdog_register_device(&wdt->wdd);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register watchdog\n");\r\ngoto err_clk_unprepare;\r\n}\r\nwdt->restart_nb.notifier_call = qcom_wdt_restart;\r\nret = register_restart_handler(&wdt->restart_nb);\r\nif (ret)\r\ndev_err(&pdev->dev, "failed to setup restart handler\n");\r\nplatform_set_drvdata(pdev, wdt);\r\nreturn 0;\r\nerr_clk_unprepare:\r\nclk_disable_unprepare(wdt->clk);\r\nreturn ret;\r\n}\r\nstatic int qcom_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct qcom_wdt *wdt = platform_get_drvdata(pdev);\r\nunregister_restart_handler(&wdt->restart_nb);\r\nwatchdog_unregister_device(&wdt->wdd);\r\nclk_disable_unprepare(wdt->clk);\r\nreturn 0;\r\n}
