static void close_panel(PANEL *p)\r\n{\r\nif (p) {\r\ndel_panel(p);\r\np = NULL;\r\n}\r\n}\r\nstatic void close_window(WINDOW *win)\r\n{\r\nif (win) {\r\ndelwin(win);\r\nwin = NULL;\r\n}\r\n}\r\nvoid close_windows(void)\r\n{\r\nif (tui_disabled)\r\nreturn;\r\nif (dialogue_window)\r\nclose_panel(dialogue_panel);\r\nif (cooling_device_window)\r\nclose_panel(data_panel);\r\nclose_window(title_bar_window);\r\nclose_window(tz_sensor_window);\r\nclose_window(status_bar_window);\r\nclose_window(cooling_device_window);\r\nclose_window(control_window);\r\nclose_window(thermal_data_window);\r\nclose_window(dialogue_window);\r\n}\r\nvoid write_status_bar(int x, char *line)\r\n{\r\nmvwprintw(status_bar_window, 0, x, "%s", line);\r\nwrefresh(status_bar_window);\r\n}\r\nstatic int diag_dev_rows(void)\r\n{\r\nint entries = ptdata.nr_cooling_dev + 1;\r\nint rows = max(DIAG_DEV_ROWS, (entries + 1) / 2);\r\nreturn min(rows, entries);\r\n}\r\nvoid setup_windows(void)\r\n{\r\nint y_begin = 1;\r\nif (tui_disabled)\r\nreturn;\r\ngetmaxyx(stdscr, maxy, maxx);\r\nresizeterm(maxy, maxx);\r\ntitle_bar_window = subwin(stdscr, TITLE_BAR_HIGHT, maxx, 0, 0);\r\ny_begin += TITLE_BAR_HIGHT;\r\ntz_sensor_window = subwin(stdscr, SENSOR_WIN_HIGHT, maxx, y_begin, 0);\r\ny_begin += SENSOR_WIN_HIGHT;\r\ncooling_device_window = subwin(stdscr, ptdata.nr_cooling_dev + 3, maxx,\r\ny_begin, 0);\r\ny_begin += ptdata.nr_cooling_dev + 3;\r\ndialogue_window = subwin(stdscr, diag_dev_rows() + 5, maxx-50,\r\nDIAG_Y, DIAG_X);\r\nthermal_data_window = subwin(stdscr, ptdata.nr_tz_sensor *\r\nNR_LINES_TZDATA + 3, maxx, y_begin, 0);\r\ny_begin += ptdata.nr_tz_sensor * NR_LINES_TZDATA + 3;\r\ncontrol_window = subwin(stdscr, 4, maxx, y_begin, 0);\r\nscrollok(cooling_device_window, TRUE);\r\nmaxwidth = maxx - 18;\r\nstatus_bar_window = subwin(stdscr, 1, maxx, maxy-1, 0);\r\nstrcpy(status_bar_slots[0], " Ctrl-c - Quit ");\r\nstrcpy(status_bar_slots[1], " TAB - Tuning ");\r\nwmove(status_bar_window, 1, 30);\r\ndata_panel = new_panel(cooling_device_window);\r\nif (!data_panel)\r\nsyslog(LOG_DEBUG, "No data panel\n");\r\nelse {\r\nif (dialogue_window) {\r\ndialogue_panel = new_panel(dialogue_window);\r\nif (!dialogue_panel)\r\nsyslog(LOG_DEBUG, "No dialogue panel\n");\r\nelse {\r\nset_panel_userptr(data_panel, dialogue_panel);\r\nset_panel_userptr(dialogue_panel, data_panel);\r\ntop = data_panel;\r\n}\r\n} else\r\nsyslog(LOG_INFO, "no dialogue win, term too small\n");\r\n}\r\ndoupdate();\r\nwerase(stdscr);\r\nrefresh();\r\n}\r\nvoid resize_handler(int sig)\r\n{\r\nclose_windows();\r\nendwin();\r\nrefresh();\r\nclear();\r\ngetmaxyx(stdscr, maxy, maxx);\r\nsetup_windows();\r\nsleep(1);\r\nsyslog(LOG_DEBUG, "SIG %d, term resized to %d x %d\n",\r\nsig, maxy, maxx);\r\nsignal(SIGWINCH, resize_handler);\r\n}\r\nvoid show_cooling_device(void)\r\n{\r\nint i, j, x, y = 0;\r\nif (tui_disabled || !cooling_device_window)\r\nreturn;\r\nwerase(cooling_device_window);\r\nwattron(cooling_device_window, A_BOLD);\r\nmvwprintw(cooling_device_window, 1, 1,\r\n"ID Cooling Dev Cur Max Thermal Zone Binding");\r\nwattroff(cooling_device_window, A_BOLD);\r\nfor (j = 0; j < ptdata.nr_cooling_dev; j++) {\r\nmvwprintw(cooling_device_window, j + 2, 1,\r\n"%02d %12.12s%6d %6d",\r\nptdata.cdi[j].instance,\r\nptdata.cdi[j].type,\r\nptdata.cdi[j].cur_state,\r\nptdata.cdi[j].max_state);\r\n}\r\nfor (i = 0; i < ptdata.nr_tz_sensor; i++) {\r\nint tz_inst = ptdata.tzi[i].instance;\r\nfor (j = 0; j < ptdata.nr_cooling_dev; j++) {\r\nint cdev_inst;\r\ny = j;\r\nx = tz_inst * TZONE_RECORD_SIZE + TZ_LEFT_ALIGN;\r\ndraw_hbar(cooling_device_window, y+2, x,\r\nTZONE_RECORD_SIZE-1, ACS_VLINE, false);\r\nmvwprintw(cooling_device_window, y+2, x-1, " ");\r\nif (ptdata.tzi[i].cdev_binding) {\r\ncdev_inst = ptdata.cdi[j].instance;\r\nunsigned long trip_binding =\r\nptdata.tzi[i].trip_binding[cdev_inst];\r\nint k = 0;\r\nsyslog(LOG_DEBUG,\r\n"bind tz%d cdev%d tp%lx %d cdev%lx\n",\r\ni, j, trip_binding, y,\r\nptdata.tzi[i].cdev_binding);\r\nwhile (trip_binding >>= 1) {\r\nk++;\r\nif (!(trip_binding & 1))\r\ncontinue;\r\nmvwprintw(cooling_device_window,\r\ny + 2,\r\nx + ptdata.tzi[i].nr_trip_pts -\r\nk - 1, "*");\r\n}\r\n}\r\n}\r\n}\r\nwborder(cooling_device_window, 0, 0, 0, 0, 0, 0, 0, 0);\r\nwattron(cooling_device_window, A_BOLD);\r\nmvwprintw(cooling_device_window, 0, maxx/2 - sizeof(cdev_title),\r\ncdev_title);\r\nwattroff(cooling_device_window, A_BOLD);\r\nwrefresh(cooling_device_window);\r\n}\r\nvoid show_dialogue(void)\r\n{\r\nint j, x = 0, y = 0;\r\nint rows, cols;\r\nWINDOW *w = dialogue_window;\r\nif (tui_disabled || !w)\r\nreturn;\r\ngetmaxyx(w, rows, cols);\r\n(void)cols;\r\nwerase(w);\r\nbox(w, 0, 0);\r\nmvwprintw(w, 0, maxx/4, DIAG_TITLE);\r\nfor (j = 0; j <= ptdata.nr_cooling_dev; j++) {\r\ny = j % diag_dev_rows();\r\nif (y == 0 && j != 0)\r\nx += 20;\r\nif (j == ptdata.nr_cooling_dev)\r\nmvwprintw(w, y+1, x+1, "%C-%.12s", 'A'+j, "Set Temp");\r\nelse\r\nmvwprintw(w, y+1, x+1, "%C-%.10s-%2d", 'A'+j,\r\nptdata.cdi[j].type, ptdata.cdi[j].instance);\r\n}\r\nwattron(w, A_BOLD);\r\nmvwprintw(w, diag_dev_rows()+1, 1, "Enter Choice [A-Z]?");\r\nwattroff(w, A_BOLD);\r\nmvwprintw(w, rows - 2, 1,\r\n"Legend: A=Active, P=Passive, C=Critical");\r\nwrefresh(dialogue_window);\r\n}\r\nvoid write_dialogue_win(char *buf, int y, int x)\r\n{\r\nWINDOW *w = dialogue_window;\r\nmvwprintw(w, y, x, "%s", buf);\r\n}\r\nvoid show_control_w(void)\r\n{\r\nunsigned long state;\r\nget_ctrl_state(&state);\r\nif (tui_disabled || !control_window)\r\nreturn;\r\nwerase(control_window);\r\nmvwprintw(control_window, 1, 1,\r\n"PID gain: kp=%2.2f ki=%2.2f kd=%2.2f Output %2.2f",\r\np_param.kp, p_param.ki, p_param.kd, p_param.y_k);\r\nmvwprintw(control_window, 2, 1,\r\n"Target Temp: %2.1fC, Zone: %d, Control Device: %.12s",\r\np_param.t_target, target_thermal_zone, ctrl_cdev);\r\nwborder(control_window, 0, 0, 0, 0, 0, 0, 0, 0);\r\nwattron(control_window, A_BOLD);\r\nmvwprintw(control_window, 0, maxx/2 - sizeof(control_title),\r\ncontrol_title);\r\nwattroff(control_window, A_BOLD);\r\nwrefresh(control_window);\r\n}\r\nvoid initialize_curses(void)\r\n{\r\nif (tui_disabled)\r\nreturn;\r\ninitscr();\r\nstart_color();\r\nkeypad(stdscr, TRUE);\r\nnonl();\r\ncbreak();\r\nnoecho();\r\ncurs_set(0);\r\nuse_default_colors();\r\ninit_pair(PT_COLOR_DEFAULT, COLOR_WHITE, COLOR_BLACK);\r\ninit_pair(PT_COLOR_HEADER_BAR, COLOR_BLACK, COLOR_WHITE);\r\ninit_pair(PT_COLOR_ERROR, COLOR_BLACK, COLOR_RED);\r\ninit_pair(PT_COLOR_RED, COLOR_WHITE, COLOR_RED);\r\ninit_pair(PT_COLOR_YELLOW, COLOR_WHITE, COLOR_YELLOW);\r\ninit_pair(PT_COLOR_GREEN, COLOR_WHITE, COLOR_GREEN);\r\ninit_pair(PT_COLOR_BLUE, COLOR_WHITE, COLOR_BLUE);\r\ninit_pair(PT_COLOR_BRIGHT, COLOR_WHITE, COLOR_BLACK);\r\n}\r\nvoid show_title_bar(void)\r\n{\r\nint i;\r\nint x = 0;\r\nif (tui_disabled || !title_bar_window)\r\nreturn;\r\nwattrset(title_bar_window, COLOR_PAIR(PT_COLOR_HEADER_BAR));\r\nwbkgd(title_bar_window, COLOR_PAIR(PT_COLOR_HEADER_BAR));\r\nwerase(title_bar_window);\r\nmvwprintw(title_bar_window, 0, 0,\r\n" TMON v%s", VERSION);\r\nwrefresh(title_bar_window);\r\nwerase(status_bar_window);\r\nfor (i = 0; i < 10; i++) {\r\nif (strlen(status_bar_slots[i]) == 0)\r\ncontinue;\r\nwattron(status_bar_window, A_REVERSE);\r\nmvwprintw(status_bar_window, 0, x, "%s", status_bar_slots[i]);\r\nwattroff(status_bar_window, A_REVERSE);\r\nx += strlen(status_bar_slots[i]) + 1;\r\n}\r\nwrefresh(status_bar_window);\r\n}\r\nstatic void handle_input_val(int ch)\r\n{\r\nchar buf[32];\r\nint val;\r\nchar path[256];\r\nWINDOW *w = dialogue_window;\r\necho();\r\nkeypad(w, TRUE);\r\nwgetnstr(w, buf, 31);\r\nval = atoi(buf);\r\nif (ch == ptdata.nr_cooling_dev) {\r\nsnprintf(buf, 31, "Invalid Temp %d! %d-%d", val,\r\nMIN_CTRL_TEMP, MAX_CTRL_TEMP);\r\nif (val < MIN_CTRL_TEMP || val > MAX_CTRL_TEMP)\r\nwrite_status_bar(40, buf);\r\nelse {\r\np_param.t_target = val;\r\nsnprintf(buf, 31, "Set New Target Temp %d", val);\r\nwrite_status_bar(40, buf);\r\n}\r\n} else {\r\nsnprintf(path, 256, "%s/%s%d", THERMAL_SYSFS,\r\nCDEV, ptdata.cdi[ch].instance);\r\nsysfs_set_ulong(path, "cur_state", val);\r\n}\r\nnoecho();\r\ndialogue_on = 0;\r\nshow_data_w();\r\nshow_control_w();\r\ntop = (PANEL *)panel_userptr(top);\r\ntop_panel(top);\r\n}\r\nstatic void handle_input_choice(int ch)\r\n{\r\nchar buf[48];\r\nint base = 0;\r\nint cdev_id = 0;\r\nif ((ch >= 'A' && ch <= 'A' + ptdata.nr_cooling_dev) ||\r\n(ch >= 'a' && ch <= 'a' + ptdata.nr_cooling_dev)) {\r\nbase = (ch < 'a') ? 'A' : 'a';\r\ncdev_id = ch - base;\r\nif (ptdata.nr_cooling_dev == cdev_id)\r\nsnprintf(buf, sizeof(buf), "New Target Temp:");\r\nelse\r\nsnprintf(buf, sizeof(buf), "New Value for %.10s-%2d: ",\r\nptdata.cdi[cdev_id].type,\r\nptdata.cdi[cdev_id].instance);\r\nwrite_dialogue_win(buf, diag_dev_rows() + 2, 2);\r\nhandle_input_val(cdev_id);\r\n} else {\r\nsnprintf(buf, sizeof(buf), "Invalid selection %d", ch);\r\nwrite_dialogue_win(buf, 8, 2);\r\n}\r\n}\r\nvoid *handle_tui_events(void *arg)\r\n{\r\nint ch;\r\nkeypad(cooling_device_window, TRUE);\r\nwhile ((ch = wgetch(cooling_device_window)) != EOF) {\r\nif (tmon_exit)\r\nbreak;\r\nif (!data_panel || !dialogue_panel ||\r\n!cooling_device_window ||\r\n!dialogue_window) {\r\ncontinue;\r\n}\r\npthread_mutex_lock(&input_lock);\r\nif (dialogue_on) {\r\nhandle_input_choice(ch);\r\nif (ch == 'q' || ch == 'Q')\r\nch = 0;\r\n}\r\nswitch (ch) {\r\ncase KEY_LEFT:\r\nbox(cooling_device_window, 10, 0);\r\nbreak;\r\ncase 9:\r\ntop = (PANEL *)panel_userptr(top);\r\ntop_panel(top);\r\nif (top == dialogue_panel) {\r\ndialogue_on = 1;\r\nshow_dialogue();\r\n} else {\r\ndialogue_on = 0;\r\nshow_data_w();\r\nshow_control_w();\r\n}\r\nbreak;\r\ncase 'q':\r\ncase 'Q':\r\ntmon_exit = 1;\r\nbreak;\r\n}\r\nupdate_panels();\r\ndoupdate();\r\npthread_mutex_unlock(&input_lock);\r\n}\r\nif (arg)\r\n*(int *)arg = 0;\r\nreturn NULL;\r\n}\r\nstatic void draw_hbar(WINDOW *win, int y, int start, int len, unsigned long ptn,\r\nbool end)\r\n{\r\nmvwaddch(win, y, start, ptn);\r\nwhline(win, ptn, len);\r\nif (end)\r\nmvwaddch(win, y, MAX_DISP_TEMP+TDATA_LEFT, ']');\r\n}\r\nstatic char trip_type_to_char(int type)\r\n{\r\nswitch (type) {\r\ncase THERMAL_TRIP_CRITICAL: return 'C';\r\ncase THERMAL_TRIP_HOT: return 'H';\r\ncase THERMAL_TRIP_PASSIVE: return 'P';\r\ncase THERMAL_TRIP_ACTIVE: return 'A';\r\ndefault:\r\nreturn '?';\r\n}\r\n}\r\nstatic void draw_tp_line(int tz, int y)\r\n{\r\nint j;\r\nint x;\r\nfor (j = 0; j < ptdata.tzi[tz].nr_trip_pts; j++) {\r\nx = ptdata.tzi[tz].tp[j].temp / 1000;\r\nmvwprintw(thermal_data_window, y + 0, x + TDATA_LEFT,\r\n"%c%d", trip_type_to_char(ptdata.tzi[tz].tp[j].type),\r\nx);\r\nsyslog(LOG_INFO, "%s:tz %d tp %d temp = %lu\n", __func__,\r\ntz, j, ptdata.tzi[tz].tp[j].temp);\r\n}\r\n}\r\nvoid show_data_w(void)\r\n{\r\nint i;\r\nif (tui_disabled || !thermal_data_window)\r\nreturn;\r\nwerase(thermal_data_window);\r\nwattron(thermal_data_window, A_BOLD);\r\nmvwprintw(thermal_data_window, 0, maxx/2 - sizeof(data_win_title),\r\ndata_win_title);\r\nwattroff(thermal_data_window, A_BOLD);\r\nfor (i = 10; i < MAX_DISP_TEMP; i += 10)\r\nmvwprintw(thermal_data_window, 1, i+TDATA_LEFT, "%2d", i);\r\nfor (i = 0; i < ptdata.nr_tz_sensor; i++) {\r\nint temp = trec[cur_thermal_record].temp[i] / 1000;\r\nint y = 0;\r\ny = i * NR_LINES_TZDATA + 2;\r\nmvwprintw(thermal_data_window, y, 1, "%6.6s%2d:[%3d][",\r\nptdata.tzi[i].type,\r\nptdata.tzi[i].instance, temp);\r\ndraw_hbar(thermal_data_window, y, TDATA_LEFT, temp, ACS_RARROW,\r\ntrue);\r\ndraw_tp_line(i, y);\r\n}\r\nwborder(thermal_data_window, 0, 0, 0, 0, 0, 0, 0, 0);\r\nwrefresh(thermal_data_window);\r\n}\r\nvoid show_sensors_w(void)\r\n{\r\nint i, j;\r\nchar buffer[512];\r\nif (tui_disabled || !tz_sensor_window)\r\nreturn;\r\nwerase(tz_sensor_window);\r\nmemset(buffer, 0, sizeof(buffer));\r\nwattron(tz_sensor_window, A_BOLD);\r\nmvwprintw(tz_sensor_window, 1, 1, "Thermal Zones:");\r\nwattroff(tz_sensor_window, A_BOLD);\r\nmvwprintw(tz_sensor_window, 1, TZ_LEFT_ALIGN, "%s", buffer);\r\nwattron(tz_sensor_window, A_BOLD);\r\nmvwprintw(tz_sensor_window, 2, 1, "Trip Points:");\r\nwattroff(tz_sensor_window, A_BOLD);\r\nfor (i = 0; i < ptdata.nr_tz_sensor; i++) {\r\nint inst = ptdata.tzi[i].instance;\r\nmvwprintw(tz_sensor_window, 1,\r\nTZ_LEFT_ALIGN+TZONE_RECORD_SIZE * inst, "%.9s%02d",\r\nptdata.tzi[i].type, ptdata.tzi[i].instance);\r\nfor (j = ptdata.tzi[i].nr_trip_pts - 1; j >= 0; j--) {\r\nchar type;\r\nint tp_pos;\r\ntp_pos = ptdata.tzi[i].nr_trip_pts - j - 1;\r\ntype = trip_type_to_char(ptdata.tzi[i].tp[j].type);\r\nmvwaddch(tz_sensor_window, 2,\r\ninst * TZONE_RECORD_SIZE + TZ_LEFT_ALIGN +\r\ntp_pos, type);\r\nsyslog(LOG_DEBUG, "draw tz %d tp %d ch:%c\n",\r\ninst, j, type);\r\n}\r\n}\r\nwborder(tz_sensor_window, 0, 0, 0, 0, 0, 0, 0, 0);\r\nwattron(tz_sensor_window, A_BOLD);\r\nmvwprintw(tz_sensor_window, 0, maxx/2 - sizeof(tz_title), tz_title);\r\nwattroff(tz_sensor_window, A_BOLD);\r\nwrefresh(tz_sensor_window);\r\n}\r\nvoid disable_tui(void)\r\n{\r\ntui_disabled = 1;\r\n}
