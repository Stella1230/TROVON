static void write_enable(struct hfi1_devdata *dd)\r\n{\r\nwrite_csr(dd, ASIC_GPIO_OUT,\r\nread_csr(dd, ASIC_GPIO_OUT) | EPROM_WP_N);\r\nwrite_csr(dd, ASIC_GPIO_OE,\r\nread_csr(dd, ASIC_GPIO_OE) | EPROM_WP_N);\r\n}\r\nstatic void write_disable(struct hfi1_devdata *dd)\r\n{\r\nwrite_csr(dd, ASIC_GPIO_OUT,\r\nread_csr(dd, ASIC_GPIO_OUT) & ~EPROM_WP_N);\r\nwrite_csr(dd, ASIC_GPIO_OE,\r\nread_csr(dd, ASIC_GPIO_OE) & ~EPROM_WP_N);\r\n}\r\nstatic int wait_for_not_busy(struct hfi1_devdata *dd)\r\n{\r\nunsigned long count = 0;\r\nu64 reg;\r\nint ret = 0;\r\nwrite_csr(dd, ASIC_EEP_ADDR_CMD, CMD_READ_SR1);\r\nwhile (1) {\r\nudelay(WAIT_SLEEP_US);\r\nusleep_range(WAIT_SLEEP_US - 5, WAIT_SLEEP_US + 5);\r\ncount++;\r\nreg = read_csr(dd, ASIC_EEP_DATA);\r\nif ((reg & SR1_BUSY) == 0)\r\nbreak;\r\nif (count > COUNT_DELAY_SEC(200)) {\r\ndd_dev_err(dd, "waited too long for SPI FLASH busy to clear - failing\n");\r\nret = -ETIMEDOUT;\r\nbreak;\r\n}\r\n}\r\nwrite_csr(dd, ASIC_EEP_ADDR_CMD, CMD_NOP);\r\nreturn ret;\r\n}\r\nstatic u32 read_device_id(struct hfi1_devdata *dd)\r\n{\r\nwrite_csr(dd, ASIC_EEP_ADDR_CMD, CMD_READ_MANUF_DEV_ID);\r\nreturn (u32)read_csr(dd, ASIC_EEP_DATA);\r\n}\r\nstatic int erase_chip(struct hfi1_devdata *dd)\r\n{\r\nint ret;\r\nwrite_enable(dd);\r\nwrite_csr(dd, ASIC_EEP_ADDR_CMD, CMD_WRITE_ENABLE);\r\nwrite_csr(dd, ASIC_EEP_ADDR_CMD, CMD_CHIP_ERASE);\r\nret = wait_for_not_busy(dd);\r\nwrite_disable(dd);\r\nreturn ret;\r\n}\r\nstatic int erase_32kb_range(struct hfi1_devdata *dd, u32 start, u32 end)\r\n{\r\nint ret = 0;\r\nif (end < start)\r\nreturn -EINVAL;\r\nif ((start & MASK_32KB) || (end & MASK_32KB)) {\r\ndd_dev_err(dd,\r\n"%s: non-aligned range (0x%x,0x%x) for a 32KB erase\n",\r\n__func__, start, end);\r\nreturn -EINVAL;\r\n}\r\nwrite_enable(dd);\r\nfor (; start < end; start += SIZE_32KB) {\r\nwrite_csr(dd, ASIC_EEP_ADDR_CMD, CMD_WRITE_ENABLE);\r\nwrite_csr(dd, ASIC_EEP_ADDR_CMD,\r\nCMD_SECTOR_ERASE_32KB(start));\r\nret = wait_for_not_busy(dd);\r\nif (ret)\r\ngoto done;\r\n}\r\ndone:\r\nwrite_disable(dd);\r\nreturn ret;\r\n}\r\nstatic void read_page(struct hfi1_devdata *dd, u32 offset, u32 *result)\r\n{\r\nint i;\r\nwrite_csr(dd, ASIC_EEP_ADDR_CMD, CMD_READ_DATA(offset));\r\nfor (i = 0; i < EP_PAGE_SIZE/sizeof(u32); i++)\r\nresult[i] = (u32)read_csr(dd, ASIC_EEP_DATA);\r\nwrite_csr(dd, ASIC_EEP_ADDR_CMD, CMD_NOP);\r\n}\r\nstatic int read_length(struct hfi1_devdata *dd, u32 start, u32 len, u64 addr)\r\n{\r\nu32 offset;\r\nu32 buffer[EP_PAGE_SIZE/sizeof(u32)];\r\nint ret = 0;\r\nif ((start & EEP_PAGE_MASK) || (len & EEP_PAGE_MASK))\r\nreturn -EINVAL;\r\nfor (offset = 0; offset < len; offset += EP_PAGE_SIZE) {\r\nread_page(dd, start + offset, buffer);\r\nif (copy_to_user((void __user *)(addr + offset),\r\nbuffer, EP_PAGE_SIZE)) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\n}\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int write_page(struct hfi1_devdata *dd, u32 offset, u32 *data)\r\n{\r\nint i;\r\nwrite_csr(dd, ASIC_EEP_ADDR_CMD, CMD_WRITE_ENABLE);\r\nwrite_csr(dd, ASIC_EEP_DATA, data[0]);\r\nwrite_csr(dd, ASIC_EEP_ADDR_CMD, CMD_PAGE_PROGRAM(offset));\r\nfor (i = 1; i < EP_PAGE_SIZE/sizeof(u32); i++)\r\nwrite_csr(dd, ASIC_EEP_DATA, data[i]);\r\nreturn wait_for_not_busy(dd);\r\n}\r\nstatic int write_length(struct hfi1_devdata *dd, u32 start, u32 len, u64 addr)\r\n{\r\nu32 offset;\r\nu32 buffer[EP_PAGE_SIZE/sizeof(u32)];\r\nint ret = 0;\r\nif ((start & EEP_PAGE_MASK) || (len & EEP_PAGE_MASK))\r\nreturn -EINVAL;\r\nwrite_enable(dd);\r\nfor (offset = 0; offset < len; offset += EP_PAGE_SIZE) {\r\nif (copy_from_user(buffer, (void __user *)(addr + offset),\r\nEP_PAGE_SIZE)) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\nret = write_page(dd, start + offset, buffer);\r\nif (ret)\r\ngoto done;\r\n}\r\ndone:\r\nwrite_disable(dd);\r\nreturn ret;\r\n}\r\nint handle_eprom_command(const struct hfi1_cmd *cmd)\r\n{\r\nstruct hfi1_devdata *dd;\r\nu32 dev_id;\r\nint ret = 0;\r\ndd = hfi1_lookup(0);\r\nif (!dd) {\r\npr_err("%s: cannot find unit 0!\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&eprom_mutex);\r\nif (!eprom_available) {\r\nret = -ENOSYS;\r\ngoto done_asic;\r\n}\r\nret = acquire_hw_mutex(dd);\r\nif (ret) {\r\ndd_dev_err(dd,\r\n"%s: unable to acquire hw mutex, no EPROM support\n",\r\n__func__);\r\ngoto done_asic;\r\n}\r\ndd_dev_info(dd, "%s: cmd: type %d, len 0x%x, addr 0x%016llx\n",\r\n__func__, cmd->type, cmd->len, cmd->addr);\r\nswitch (cmd->type) {\r\ncase HFI1_CMD_EP_INFO:\r\nif (cmd->len != sizeof(u32)) {\r\nret = -ERANGE;\r\nbreak;\r\n}\r\ndev_id = read_device_id(dd);\r\nif (copy_to_user((void __user *)cmd->addr, &dev_id,\r\nsizeof(u32)))\r\nret = -EFAULT;\r\nbreak;\r\ncase HFI1_CMD_EP_ERASE_CHIP:\r\nret = erase_chip(dd);\r\nbreak;\r\ncase HFI1_CMD_EP_ERASE_P0:\r\nif (cmd->len != P0_SIZE) {\r\nret = -ERANGE;\r\nbreak;\r\n}\r\nret = erase_32kb_range(dd, 0, cmd->len);\r\nbreak;\r\ncase HFI1_CMD_EP_ERASE_P1:\r\nif (P1_START + cmd->len > ASIC_EEP_ADDR_CMD_EP_ADDR_MASK) {\r\nret = -ERANGE;\r\nbreak;\r\n}\r\nret = erase_32kb_range(dd, P1_START, P1_START + cmd->len);\r\nbreak;\r\ncase HFI1_CMD_EP_READ_P0:\r\nif (cmd->len != P0_SIZE) {\r\nret = -ERANGE;\r\nbreak;\r\n}\r\nret = read_length(dd, 0, cmd->len, cmd->addr);\r\nbreak;\r\ncase HFI1_CMD_EP_READ_P1:\r\nif (P1_START + cmd->len > ASIC_EEP_ADDR_CMD_EP_ADDR_MASK) {\r\nret = -ERANGE;\r\nbreak;\r\n}\r\nret = read_length(dd, P1_START, cmd->len, cmd->addr);\r\nbreak;\r\ncase HFI1_CMD_EP_WRITE_P0:\r\nif (cmd->len > P0_SIZE) {\r\nret = -ERANGE;\r\nbreak;\r\n}\r\nret = write_length(dd, 0, cmd->len, cmd->addr);\r\nbreak;\r\ncase HFI1_CMD_EP_WRITE_P1:\r\nif (P1_START + cmd->len > ASIC_EEP_ADDR_CMD_EP_ADDR_MASK) {\r\nret = -ERANGE;\r\nbreak;\r\n}\r\nret = write_length(dd, P1_START, cmd->len, cmd->addr);\r\nbreak;\r\ndefault:\r\ndd_dev_err(dd, "%s: unexpected command %d\n",\r\n__func__, cmd->type);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nrelease_hw_mutex(dd);\r\ndone_asic:\r\nmutex_unlock(&eprom_mutex);\r\nreturn ret;\r\n}\r\nint eprom_init(struct hfi1_devdata *dd)\r\n{\r\nint ret = 0;\r\nif (dd->pcidev->device != PCI_DEVICE_ID_INTEL0)\r\nreturn 0;\r\nmutex_lock(&eprom_mutex);\r\nif (eprom_available)\r\ngoto done_asic;\r\nret = acquire_hw_mutex(dd);\r\nif (ret) {\r\ndd_dev_err(dd,\r\n"%s: unable to acquire hw mutex, no EPROM support\n",\r\n__func__);\r\ngoto done_asic;\r\n}\r\nwrite_csr(dd, ASIC_EEP_CTL_STAT,\r\nASIC_EEP_CTL_STAT_EP_RESET_SMASK);\r\nwrite_csr(dd, ASIC_EEP_CTL_STAT,\r\nEP_SPEED_FULL << ASIC_EEP_CTL_STAT_RATE_SPI_SHIFT);\r\nwrite_csr(dd, ASIC_EEP_ADDR_CMD, CMD_RELEASE_POWERDOWN_NOID);\r\neprom_available = 1;\r\nrelease_hw_mutex(dd);\r\ndone_asic:\r\nmutex_unlock(&eprom_mutex);\r\nreturn ret;\r\n}
