static bool dissector_uses_key(const struct flow_dissector *flow_dissector,\r\nenum flow_dissector_key_id key_id)\r\n{\r\nreturn flow_dissector->used_keys & (1 << key_id);\r\n}\r\nstatic void dissector_set_key(struct flow_dissector *flow_dissector,\r\nenum flow_dissector_key_id key_id)\r\n{\r\nflow_dissector->used_keys |= (1 << key_id);\r\n}\r\nstatic void *skb_flow_dissector_target(struct flow_dissector *flow_dissector,\r\nenum flow_dissector_key_id key_id,\r\nvoid *target_container)\r\n{\r\nreturn ((char *) target_container) + flow_dissector->offset[key_id];\r\n}\r\nvoid skb_flow_dissector_init(struct flow_dissector *flow_dissector,\r\nconst struct flow_dissector_key *key,\r\nunsigned int key_count)\r\n{\r\nunsigned int i;\r\nmemset(flow_dissector, 0, sizeof(*flow_dissector));\r\nfor (i = 0; i < key_count; i++, key++) {\r\nBUG_ON(key->offset > USHRT_MAX);\r\nBUG_ON(dissector_uses_key(flow_dissector,\r\nkey->key_id));\r\ndissector_set_key(flow_dissector, key->key_id);\r\nflow_dissector->offset[key->key_id] = key->offset;\r\n}\r\nBUG_ON(!dissector_uses_key(flow_dissector,\r\nFLOW_DISSECTOR_KEY_CONTROL));\r\nBUG_ON(!dissector_uses_key(flow_dissector,\r\nFLOW_DISSECTOR_KEY_BASIC));\r\n}\r\n__be32 __skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto,\r\nvoid *data, int hlen)\r\n{\r\nint poff = proto_ports_offset(ip_proto);\r\nif (!data) {\r\ndata = skb->data;\r\nhlen = skb_headlen(skb);\r\n}\r\nif (poff >= 0) {\r\n__be32 *ports, _ports;\r\nports = __skb_header_pointer(skb, thoff + poff,\r\nsizeof(_ports), data, hlen, &_ports);\r\nif (ports)\r\nreturn *ports;\r\n}\r\nreturn 0;\r\n}\r\nbool __skb_flow_dissect(const struct sk_buff *skb,\r\nstruct flow_dissector *flow_dissector,\r\nvoid *target_container,\r\nvoid *data, __be16 proto, int nhoff, int hlen,\r\nunsigned int flags)\r\n{\r\nstruct flow_dissector_key_control *key_control;\r\nstruct flow_dissector_key_basic *key_basic;\r\nstruct flow_dissector_key_addrs *key_addrs;\r\nstruct flow_dissector_key_ports *key_ports;\r\nstruct flow_dissector_key_tags *key_tags;\r\nstruct flow_dissector_key_keyid *key_keyid;\r\nu8 ip_proto = 0;\r\nbool ret = false;\r\nif (!data) {\r\ndata = skb->data;\r\nproto = skb->protocol;\r\nnhoff = skb_network_offset(skb);\r\nhlen = skb_headlen(skb);\r\n}\r\nkey_control = skb_flow_dissector_target(flow_dissector,\r\nFLOW_DISSECTOR_KEY_CONTROL,\r\ntarget_container);\r\nkey_basic = skb_flow_dissector_target(flow_dissector,\r\nFLOW_DISSECTOR_KEY_BASIC,\r\ntarget_container);\r\nif (dissector_uses_key(flow_dissector,\r\nFLOW_DISSECTOR_KEY_ETH_ADDRS)) {\r\nstruct ethhdr *eth = eth_hdr(skb);\r\nstruct flow_dissector_key_eth_addrs *key_eth_addrs;\r\nkey_eth_addrs = skb_flow_dissector_target(flow_dissector,\r\nFLOW_DISSECTOR_KEY_ETH_ADDRS,\r\ntarget_container);\r\nmemcpy(key_eth_addrs, &eth->h_dest, sizeof(*key_eth_addrs));\r\n}\r\nagain:\r\nswitch (proto) {\r\ncase htons(ETH_P_IP): {\r\nconst struct iphdr *iph;\r\nstruct iphdr _iph;\r\nip:\r\niph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\r\nif (!iph || iph->ihl < 5)\r\ngoto out_bad;\r\nnhoff += iph->ihl * 4;\r\nip_proto = iph->protocol;\r\nif (!dissector_uses_key(flow_dissector,\r\nFLOW_DISSECTOR_KEY_IPV4_ADDRS))\r\nbreak;\r\nkey_addrs = skb_flow_dissector_target(flow_dissector,\r\nFLOW_DISSECTOR_KEY_IPV4_ADDRS, target_container);\r\nmemcpy(&key_addrs->v4addrs, &iph->saddr,\r\nsizeof(key_addrs->v4addrs));\r\nkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\r\nif (ip_is_fragment(iph)) {\r\nkey_control->flags |= FLOW_DIS_IS_FRAGMENT;\r\nif (iph->frag_off & htons(IP_OFFSET)) {\r\ngoto out_good;\r\n} else {\r\nkey_control->flags |= FLOW_DIS_FIRST_FRAG;\r\nif (!(flags & FLOW_DISSECTOR_F_PARSE_1ST_FRAG))\r\ngoto out_good;\r\n}\r\n}\r\nif (flags & FLOW_DISSECTOR_F_STOP_AT_L3)\r\ngoto out_good;\r\nbreak;\r\n}\r\ncase htons(ETH_P_IPV6): {\r\nconst struct ipv6hdr *iph;\r\nstruct ipv6hdr _iph;\r\n__be32 flow_label;\r\nipv6:\r\niph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\r\nif (!iph)\r\ngoto out_bad;\r\nip_proto = iph->nexthdr;\r\nnhoff += sizeof(struct ipv6hdr);\r\nif (dissector_uses_key(flow_dissector,\r\nFLOW_DISSECTOR_KEY_IPV6_ADDRS)) {\r\nstruct flow_dissector_key_ipv6_addrs *key_ipv6_addrs;\r\nkey_ipv6_addrs = skb_flow_dissector_target(flow_dissector,\r\nFLOW_DISSECTOR_KEY_IPV6_ADDRS,\r\ntarget_container);\r\nmemcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));\r\nkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\r\n}\r\nflow_label = ip6_flowlabel(iph);\r\nif (flow_label) {\r\nif (dissector_uses_key(flow_dissector,\r\nFLOW_DISSECTOR_KEY_FLOW_LABEL)) {\r\nkey_tags = skb_flow_dissector_target(flow_dissector,\r\nFLOW_DISSECTOR_KEY_FLOW_LABEL,\r\ntarget_container);\r\nkey_tags->flow_label = ntohl(flow_label);\r\n}\r\nif (flags & FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL)\r\ngoto out_good;\r\n}\r\nif (flags & FLOW_DISSECTOR_F_STOP_AT_L3)\r\ngoto out_good;\r\nbreak;\r\n}\r\ncase htons(ETH_P_8021AD):\r\ncase htons(ETH_P_8021Q): {\r\nconst struct vlan_hdr *vlan;\r\nstruct vlan_hdr _vlan;\r\nvlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);\r\nif (!vlan)\r\ngoto out_bad;\r\nif (dissector_uses_key(flow_dissector,\r\nFLOW_DISSECTOR_KEY_VLANID)) {\r\nkey_tags = skb_flow_dissector_target(flow_dissector,\r\nFLOW_DISSECTOR_KEY_VLANID,\r\ntarget_container);\r\nkey_tags->vlan_id = skb_vlan_tag_get_id(skb);\r\n}\r\nproto = vlan->h_vlan_encapsulated_proto;\r\nnhoff += sizeof(*vlan);\r\ngoto again;\r\n}\r\ncase htons(ETH_P_PPP_SES): {\r\nstruct {\r\nstruct pppoe_hdr hdr;\r\n__be16 proto;\r\n} *hdr, _hdr;\r\nhdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\r\nif (!hdr)\r\ngoto out_bad;\r\nproto = hdr->proto;\r\nnhoff += PPPOE_SES_HLEN;\r\nswitch (proto) {\r\ncase htons(PPP_IP):\r\ngoto ip;\r\ncase htons(PPP_IPV6):\r\ngoto ipv6;\r\ndefault:\r\ngoto out_bad;\r\n}\r\n}\r\ncase htons(ETH_P_TIPC): {\r\nstruct {\r\n__be32 pre[3];\r\n__be32 srcnode;\r\n} *hdr, _hdr;\r\nhdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\r\nif (!hdr)\r\ngoto out_bad;\r\nif (dissector_uses_key(flow_dissector,\r\nFLOW_DISSECTOR_KEY_TIPC_ADDRS)) {\r\nkey_addrs = skb_flow_dissector_target(flow_dissector,\r\nFLOW_DISSECTOR_KEY_TIPC_ADDRS,\r\ntarget_container);\r\nkey_addrs->tipcaddrs.srcnode = hdr->srcnode;\r\nkey_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;\r\n}\r\ngoto out_good;\r\n}\r\ncase htons(ETH_P_MPLS_UC):\r\ncase htons(ETH_P_MPLS_MC): {\r\nstruct mpls_label *hdr, _hdr[2];\r\nmpls:\r\nhdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,\r\nhlen, &_hdr);\r\nif (!hdr)\r\ngoto out_bad;\r\nif ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>\r\nMPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {\r\nif (dissector_uses_key(flow_dissector,\r\nFLOW_DISSECTOR_KEY_MPLS_ENTROPY)) {\r\nkey_keyid = skb_flow_dissector_target(flow_dissector,\r\nFLOW_DISSECTOR_KEY_MPLS_ENTROPY,\r\ntarget_container);\r\nkey_keyid->keyid = hdr[1].entry &\r\nhtonl(MPLS_LS_LABEL_MASK);\r\n}\r\ngoto out_good;\r\n}\r\ngoto out_good;\r\n}\r\ncase htons(ETH_P_FCOE):\r\nkey_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);\r\ndefault:\r\ngoto out_bad;\r\n}\r\nip_proto_again:\r\nswitch (ip_proto) {\r\ncase IPPROTO_GRE: {\r\nstruct gre_hdr {\r\n__be16 flags;\r\n__be16 proto;\r\n} *hdr, _hdr;\r\nhdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\r\nif (!hdr)\r\ngoto out_bad;\r\nif (hdr->flags & (GRE_VERSION | GRE_ROUTING))\r\nbreak;\r\nproto = hdr->proto;\r\nnhoff += 4;\r\nif (hdr->flags & GRE_CSUM)\r\nnhoff += 4;\r\nif (hdr->flags & GRE_KEY) {\r\nconst __be32 *keyid;\r\n__be32 _keyid;\r\nkeyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),\r\ndata, hlen, &_keyid);\r\nif (!keyid)\r\ngoto out_bad;\r\nif (dissector_uses_key(flow_dissector,\r\nFLOW_DISSECTOR_KEY_GRE_KEYID)) {\r\nkey_keyid = skb_flow_dissector_target(flow_dissector,\r\nFLOW_DISSECTOR_KEY_GRE_KEYID,\r\ntarget_container);\r\nkey_keyid->keyid = *keyid;\r\n}\r\nnhoff += 4;\r\n}\r\nif (hdr->flags & GRE_SEQ)\r\nnhoff += 4;\r\nif (proto == htons(ETH_P_TEB)) {\r\nconst struct ethhdr *eth;\r\nstruct ethhdr _eth;\r\neth = __skb_header_pointer(skb, nhoff,\r\nsizeof(_eth),\r\ndata, hlen, &_eth);\r\nif (!eth)\r\ngoto out_bad;\r\nproto = eth->h_proto;\r\nnhoff += sizeof(*eth);\r\n}\r\nkey_control->flags |= FLOW_DIS_ENCAPSULATION;\r\nif (flags & FLOW_DISSECTOR_F_STOP_AT_ENCAP)\r\ngoto out_good;\r\ngoto again;\r\n}\r\ncase NEXTHDR_HOP:\r\ncase NEXTHDR_ROUTING:\r\ncase NEXTHDR_DEST: {\r\nu8 _opthdr[2], *opthdr;\r\nif (proto != htons(ETH_P_IPV6))\r\nbreak;\r\nopthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),\r\ndata, hlen, &_opthdr);\r\nif (!opthdr)\r\ngoto out_bad;\r\nip_proto = opthdr[0];\r\nnhoff += (opthdr[1] + 1) << 3;\r\ngoto ip_proto_again;\r\n}\r\ncase NEXTHDR_FRAGMENT: {\r\nstruct frag_hdr _fh, *fh;\r\nif (proto != htons(ETH_P_IPV6))\r\nbreak;\r\nfh = __skb_header_pointer(skb, nhoff, sizeof(_fh),\r\ndata, hlen, &_fh);\r\nif (!fh)\r\ngoto out_bad;\r\nkey_control->flags |= FLOW_DIS_IS_FRAGMENT;\r\nnhoff += sizeof(_fh);\r\nif (!(fh->frag_off & htons(IP6_OFFSET))) {\r\nkey_control->flags |= FLOW_DIS_FIRST_FRAG;\r\nif (flags & FLOW_DISSECTOR_F_PARSE_1ST_FRAG) {\r\nip_proto = fh->nexthdr;\r\ngoto ip_proto_again;\r\n}\r\n}\r\ngoto out_good;\r\n}\r\ncase IPPROTO_IPIP:\r\nproto = htons(ETH_P_IP);\r\nkey_control->flags |= FLOW_DIS_ENCAPSULATION;\r\nif (flags & FLOW_DISSECTOR_F_STOP_AT_ENCAP)\r\ngoto out_good;\r\ngoto ip;\r\ncase IPPROTO_IPV6:\r\nproto = htons(ETH_P_IPV6);\r\nkey_control->flags |= FLOW_DIS_ENCAPSULATION;\r\nif (flags & FLOW_DISSECTOR_F_STOP_AT_ENCAP)\r\ngoto out_good;\r\ngoto ipv6;\r\ncase IPPROTO_MPLS:\r\nproto = htons(ETH_P_MPLS_UC);\r\ngoto mpls;\r\ndefault:\r\nbreak;\r\n}\r\nif (dissector_uses_key(flow_dissector,\r\nFLOW_DISSECTOR_KEY_PORTS)) {\r\nkey_ports = skb_flow_dissector_target(flow_dissector,\r\nFLOW_DISSECTOR_KEY_PORTS,\r\ntarget_container);\r\nkey_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,\r\ndata, hlen);\r\n}\r\nout_good:\r\nret = true;\r\nout_bad:\r\nkey_basic->n_proto = proto;\r\nkey_basic->ip_proto = ip_proto;\r\nkey_control->thoff = (u16)nhoff;\r\nreturn ret;\r\n}\r\nstatic __always_inline void __flow_hash_secret_init(void)\r\n{\r\nnet_get_random_once(&hashrnd, sizeof(hashrnd));\r\n}\r\nstatic __always_inline u32 __flow_hash_words(const u32 *words, u32 length,\r\nu32 keyval)\r\n{\r\nreturn jhash2(words, length, keyval);\r\n}\r\nstatic inline const u32 *flow_keys_hash_start(const struct flow_keys *flow)\r\n{\r\nconst void *p = flow;\r\nBUILD_BUG_ON(FLOW_KEYS_HASH_OFFSET % sizeof(u32));\r\nreturn (const u32 *)(p + FLOW_KEYS_HASH_OFFSET);\r\n}\r\nstatic inline size_t flow_keys_hash_length(const struct flow_keys *flow)\r\n{\r\nsize_t diff = FLOW_KEYS_HASH_OFFSET + sizeof(flow->addrs);\r\nBUILD_BUG_ON((sizeof(*flow) - FLOW_KEYS_HASH_OFFSET) % sizeof(u32));\r\nBUILD_BUG_ON(offsetof(typeof(*flow), addrs) !=\r\nsizeof(*flow) - sizeof(flow->addrs));\r\nswitch (flow->control.addr_type) {\r\ncase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\r\ndiff -= sizeof(flow->addrs.v4addrs);\r\nbreak;\r\ncase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\r\ndiff -= sizeof(flow->addrs.v6addrs);\r\nbreak;\r\ncase FLOW_DISSECTOR_KEY_TIPC_ADDRS:\r\ndiff -= sizeof(flow->addrs.tipcaddrs);\r\nbreak;\r\n}\r\nreturn (sizeof(*flow) - diff) / sizeof(u32);\r\n}\r\n__be32 flow_get_u32_src(const struct flow_keys *flow)\r\n{\r\nswitch (flow->control.addr_type) {\r\ncase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\r\nreturn flow->addrs.v4addrs.src;\r\ncase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\r\nreturn (__force __be32)ipv6_addr_hash(\r\n&flow->addrs.v6addrs.src);\r\ncase FLOW_DISSECTOR_KEY_TIPC_ADDRS:\r\nreturn flow->addrs.tipcaddrs.srcnode;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\n__be32 flow_get_u32_dst(const struct flow_keys *flow)\r\n{\r\nswitch (flow->control.addr_type) {\r\ncase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\r\nreturn flow->addrs.v4addrs.dst;\r\ncase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\r\nreturn (__force __be32)ipv6_addr_hash(\r\n&flow->addrs.v6addrs.dst);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic inline void __flow_hash_consistentify(struct flow_keys *keys)\r\n{\r\nint addr_diff, i;\r\nswitch (keys->control.addr_type) {\r\ncase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\r\naddr_diff = (__force u32)keys->addrs.v4addrs.dst -\r\n(__force u32)keys->addrs.v4addrs.src;\r\nif ((addr_diff < 0) ||\r\n(addr_diff == 0 &&\r\n((__force u16)keys->ports.dst <\r\n(__force u16)keys->ports.src))) {\r\nswap(keys->addrs.v4addrs.src, keys->addrs.v4addrs.dst);\r\nswap(keys->ports.src, keys->ports.dst);\r\n}\r\nbreak;\r\ncase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\r\naddr_diff = memcmp(&keys->addrs.v6addrs.dst,\r\n&keys->addrs.v6addrs.src,\r\nsizeof(keys->addrs.v6addrs.dst));\r\nif ((addr_diff < 0) ||\r\n(addr_diff == 0 &&\r\n((__force u16)keys->ports.dst <\r\n(__force u16)keys->ports.src))) {\r\nfor (i = 0; i < 4; i++)\r\nswap(keys->addrs.v6addrs.src.s6_addr32[i],\r\nkeys->addrs.v6addrs.dst.s6_addr32[i]);\r\nswap(keys->ports.src, keys->ports.dst);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic inline u32 __flow_hash_from_keys(struct flow_keys *keys, u32 keyval)\r\n{\r\nu32 hash;\r\n__flow_hash_consistentify(keys);\r\nhash = __flow_hash_words(flow_keys_hash_start(keys),\r\nflow_keys_hash_length(keys), keyval);\r\nif (!hash)\r\nhash = 1;\r\nreturn hash;\r\n}\r\nu32 flow_hash_from_keys(struct flow_keys *keys)\r\n{\r\n__flow_hash_secret_init();\r\nreturn __flow_hash_from_keys(keys, hashrnd);\r\n}\r\nstatic inline u32 ___skb_get_hash(const struct sk_buff *skb,\r\nstruct flow_keys *keys, u32 keyval)\r\n{\r\nskb_flow_dissect_flow_keys(skb, keys,\r\nFLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL);\r\nreturn __flow_hash_from_keys(keys, keyval);\r\n}\r\nvoid make_flow_keys_digest(struct flow_keys_digest *digest,\r\nconst struct flow_keys *flow)\r\n{\r\nstruct _flow_keys_digest_data *data =\r\n(struct _flow_keys_digest_data *)digest;\r\nBUILD_BUG_ON(sizeof(*data) > sizeof(*digest));\r\nmemset(digest, 0, sizeof(*digest));\r\ndata->n_proto = flow->basic.n_proto;\r\ndata->ip_proto = flow->basic.ip_proto;\r\ndata->ports = flow->ports.ports;\r\ndata->src = flow->addrs.v4addrs.src;\r\ndata->dst = flow->addrs.v4addrs.dst;\r\n}\r\nvoid __skb_get_hash(struct sk_buff *skb)\r\n{\r\nstruct flow_keys keys;\r\n__flow_hash_secret_init();\r\n__skb_set_sw_hash(skb, ___skb_get_hash(skb, &keys, hashrnd),\r\nflow_keys_have_l4(&keys));\r\n}\r\n__u32 skb_get_hash_perturb(const struct sk_buff *skb, u32 perturb)\r\n{\r\nstruct flow_keys keys;\r\nreturn ___skb_get_hash(skb, &keys, perturb);\r\n}\r\n__u32 __skb_get_hash_flowi6(struct sk_buff *skb, const struct flowi6 *fl6)\r\n{\r\nstruct flow_keys keys;\r\nmemset(&keys, 0, sizeof(keys));\r\nmemcpy(&keys.addrs.v6addrs.src, &fl6->saddr,\r\nsizeof(keys.addrs.v6addrs.src));\r\nmemcpy(&keys.addrs.v6addrs.dst, &fl6->daddr,\r\nsizeof(keys.addrs.v6addrs.dst));\r\nkeys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\r\nkeys.ports.src = fl6->fl6_sport;\r\nkeys.ports.dst = fl6->fl6_dport;\r\nkeys.keyid.keyid = fl6->fl6_gre_key;\r\nkeys.tags.flow_label = (__force u32)fl6->flowlabel;\r\nkeys.basic.ip_proto = fl6->flowi6_proto;\r\n__skb_set_sw_hash(skb, flow_hash_from_keys(&keys),\r\nflow_keys_have_l4(&keys));\r\nreturn skb->hash;\r\n}\r\n__u32 __skb_get_hash_flowi4(struct sk_buff *skb, const struct flowi4 *fl4)\r\n{\r\nstruct flow_keys keys;\r\nmemset(&keys, 0, sizeof(keys));\r\nkeys.addrs.v4addrs.src = fl4->saddr;\r\nkeys.addrs.v4addrs.dst = fl4->daddr;\r\nkeys.control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\r\nkeys.ports.src = fl4->fl4_sport;\r\nkeys.ports.dst = fl4->fl4_dport;\r\nkeys.keyid.keyid = fl4->fl4_gre_key;\r\nkeys.basic.ip_proto = fl4->flowi4_proto;\r\n__skb_set_sw_hash(skb, flow_hash_from_keys(&keys),\r\nflow_keys_have_l4(&keys));\r\nreturn skb->hash;\r\n}\r\nu32 __skb_get_poff(const struct sk_buff *skb, void *data,\r\nconst struct flow_keys *keys, int hlen)\r\n{\r\nu32 poff = keys->control.thoff;\r\nswitch (keys->basic.ip_proto) {\r\ncase IPPROTO_TCP: {\r\nconst u8 *doff;\r\nu8 _doff;\r\ndoff = __skb_header_pointer(skb, poff + 12, sizeof(_doff),\r\ndata, hlen, &_doff);\r\nif (!doff)\r\nreturn poff;\r\npoff += max_t(u32, sizeof(struct tcphdr), (*doff & 0xF0) >> 2);\r\nbreak;\r\n}\r\ncase IPPROTO_UDP:\r\ncase IPPROTO_UDPLITE:\r\npoff += sizeof(struct udphdr);\r\nbreak;\r\ncase IPPROTO_ICMP:\r\npoff += sizeof(struct icmphdr);\r\nbreak;\r\ncase IPPROTO_ICMPV6:\r\npoff += sizeof(struct icmp6hdr);\r\nbreak;\r\ncase IPPROTO_IGMP:\r\npoff += sizeof(struct igmphdr);\r\nbreak;\r\ncase IPPROTO_DCCP:\r\npoff += sizeof(struct dccp_hdr);\r\nbreak;\r\ncase IPPROTO_SCTP:\r\npoff += sizeof(struct sctphdr);\r\nbreak;\r\n}\r\nreturn poff;\r\n}\r\nu32 skb_get_poff(const struct sk_buff *skb)\r\n{\r\nstruct flow_keys keys;\r\nif (!skb_flow_dissect_flow_keys(skb, &keys, 0))\r\nreturn 0;\r\nreturn __skb_get_poff(skb, skb->data, &keys, skb_headlen(skb));\r\n}\r\n__u32 __get_hash_from_flowi6(const struct flowi6 *fl6, struct flow_keys *keys)\r\n{\r\nmemset(keys, 0, sizeof(*keys));\r\nmemcpy(&keys->addrs.v6addrs.src, &fl6->saddr,\r\nsizeof(keys->addrs.v6addrs.src));\r\nmemcpy(&keys->addrs.v6addrs.dst, &fl6->daddr,\r\nsizeof(keys->addrs.v6addrs.dst));\r\nkeys->control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\r\nkeys->ports.src = fl6->fl6_sport;\r\nkeys->ports.dst = fl6->fl6_dport;\r\nkeys->keyid.keyid = fl6->fl6_gre_key;\r\nkeys->tags.flow_label = (__force u32)fl6->flowlabel;\r\nkeys->basic.ip_proto = fl6->flowi6_proto;\r\nreturn flow_hash_from_keys(keys);\r\n}\r\n__u32 __get_hash_from_flowi4(const struct flowi4 *fl4, struct flow_keys *keys)\r\n{\r\nmemset(keys, 0, sizeof(*keys));\r\nkeys->addrs.v4addrs.src = fl4->saddr;\r\nkeys->addrs.v4addrs.dst = fl4->daddr;\r\nkeys->control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\r\nkeys->ports.src = fl4->fl4_sport;\r\nkeys->ports.dst = fl4->fl4_dport;\r\nkeys->keyid.keyid = fl4->fl4_gre_key;\r\nkeys->basic.ip_proto = fl4->flowi4_proto;\r\nreturn flow_hash_from_keys(keys);\r\n}\r\nstatic int __init init_default_flow_dissectors(void)\r\n{\r\nskb_flow_dissector_init(&flow_keys_dissector,\r\nflow_keys_dissector_keys,\r\nARRAY_SIZE(flow_keys_dissector_keys));\r\nskb_flow_dissector_init(&flow_keys_buf_dissector,\r\nflow_keys_buf_dissector_keys,\r\nARRAY_SIZE(flow_keys_buf_dissector_keys));\r\nreturn 0;\r\n}
