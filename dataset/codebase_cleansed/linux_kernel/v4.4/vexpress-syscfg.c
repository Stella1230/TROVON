static int vexpress_syscfg_exec(struct vexpress_syscfg_func *func,\r\nint index, bool write, u32 *data)\r\n{\r\nstruct vexpress_syscfg *syscfg = func->syscfg;\r\nu32 command, status;\r\nint tries;\r\nlong timeout;\r\nif (WARN_ON(index > func->num_templates))\r\nreturn -EINVAL;\r\ncommand = readl(syscfg->base + SYS_CFGCTRL);\r\nif (WARN_ON(command & SYS_CFGCTRL_START))\r\nreturn -EBUSY;\r\ncommand = func->template[index];\r\ncommand |= SYS_CFGCTRL_START;\r\ncommand |= write ? SYS_CFGCTRL_WRITE : 0;\r\nif (!write)\r\n*data = 0xdeadbeef;\r\ndev_dbg(syscfg->dev, "func %p, command %x, data %x\n",\r\nfunc, command, *data);\r\nwritel(*data, syscfg->base + SYS_CFGDATA);\r\nwritel(0, syscfg->base + SYS_CFGSTAT);\r\nwritel(command, syscfg->base + SYS_CFGCTRL);\r\nmb();\r\ntries = 100;\r\ntimeout = 100;\r\ndo {\r\nif (!irqs_disabled()) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(usecs_to_jiffies(timeout));\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\n} else {\r\nudelay(timeout);\r\n}\r\nstatus = readl(syscfg->base + SYS_CFGSTAT);\r\nif (status & SYS_CFGSTAT_ERR)\r\nreturn -EFAULT;\r\nif (timeout > 20)\r\ntimeout -= 20;\r\n} while (--tries && !(status & SYS_CFGSTAT_COMPLETE));\r\nif (WARN_ON_ONCE(!tries))\r\nreturn -ETIMEDOUT;\r\nif (!write) {\r\n*data = readl(syscfg->base + SYS_CFGDATA);\r\ndev_dbg(syscfg->dev, "func %p, read data %x\n", func, *data);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vexpress_syscfg_read(void *context, unsigned int index,\r\nunsigned int *val)\r\n{\r\nstruct vexpress_syscfg_func *func = context;\r\nreturn vexpress_syscfg_exec(func, index, false, val);\r\n}\r\nstatic int vexpress_syscfg_write(void *context, unsigned int index,\r\nunsigned int val)\r\n{\r\nstruct vexpress_syscfg_func *func = context;\r\nreturn vexpress_syscfg_exec(func, index, true, &val);\r\n}\r\nstatic struct regmap *vexpress_syscfg_regmap_init(struct device *dev,\r\nvoid *context)\r\n{\r\nint err;\r\nstruct vexpress_syscfg *syscfg = context;\r\nstruct vexpress_syscfg_func *func;\r\nstruct property *prop;\r\nconst __be32 *val = NULL;\r\n__be32 energy_quirk[4];\r\nint num;\r\nu32 site, position, dcc;\r\nint i;\r\nerr = vexpress_config_get_topo(dev->of_node, &site,\r\n&position, &dcc);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nprop = of_find_property(dev->of_node,\r\n"arm,vexpress-sysreg,func", NULL);\r\nif (!prop)\r\nreturn ERR_PTR(-EINVAL);\r\nnum = prop->length / sizeof(u32) / 2;\r\nval = prop->value;\r\nif (num == 1 && of_device_is_compatible(dev->of_node,\r\n"arm,vexpress-energy")) {\r\nnum = 2;\r\nenergy_quirk[0] = *val;\r\nenergy_quirk[2] = *val++;\r\nenergy_quirk[1] = *val;\r\nenergy_quirk[3] = cpu_to_be32(be32_to_cpup(val) + 1);\r\nval = energy_quirk;\r\n}\r\nfunc = kzalloc(sizeof(*func) + sizeof(*func->template) * num,\r\nGFP_KERNEL);\r\nif (!func)\r\nreturn ERR_PTR(-ENOMEM);\r\nfunc->syscfg = syscfg;\r\nfunc->num_templates = num;\r\nfor (i = 0; i < num; i++) {\r\nu32 function, device;\r\nfunction = be32_to_cpup(val++);\r\ndevice = be32_to_cpup(val++);\r\ndev_dbg(dev, "func %p: %u/%u/%u/%u/%u\n",\r\nfunc, site, position, dcc,\r\nfunction, device);\r\nfunc->template[i] = SYS_CFGCTRL_DCC(dcc);\r\nfunc->template[i] |= SYS_CFGCTRL_SITE(site);\r\nfunc->template[i] |= SYS_CFGCTRL_POSITION(position);\r\nfunc->template[i] |= SYS_CFGCTRL_FUNC(function);\r\nfunc->template[i] |= SYS_CFGCTRL_DEVICE(device);\r\n}\r\nvexpress_syscfg_regmap_config.max_register = num - 1;\r\nfunc->regmap = regmap_init(dev, NULL, func,\r\n&vexpress_syscfg_regmap_config);\r\nif (IS_ERR(func->regmap)) {\r\nvoid *err = func->regmap;\r\nkfree(func);\r\nreturn err;\r\n}\r\nlist_add(&func->list, &syscfg->funcs);\r\nreturn func->regmap;\r\n}\r\nstatic void vexpress_syscfg_regmap_exit(struct regmap *regmap, void *context)\r\n{\r\nstruct vexpress_syscfg *syscfg = context;\r\nstruct vexpress_syscfg_func *func, *tmp;\r\nregmap_exit(regmap);\r\nlist_for_each_entry_safe(func, tmp, &syscfg->funcs, list) {\r\nif (func->regmap == regmap) {\r\nlist_del(&syscfg->funcs);\r\nkfree(func);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int vexpress_syscfg_probe(struct platform_device *pdev)\r\n{\r\nstruct vexpress_syscfg *syscfg;\r\nstruct resource *res;\r\nstruct device *bridge;\r\nsyscfg = devm_kzalloc(&pdev->dev, sizeof(*syscfg), GFP_KERNEL);\r\nif (!syscfg)\r\nreturn -ENOMEM;\r\nsyscfg->dev = &pdev->dev;\r\nINIT_LIST_HEAD(&syscfg->funcs);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!devm_request_mem_region(&pdev->dev, res->start,\r\nresource_size(res), pdev->name))\r\nreturn -EBUSY;\r\nsyscfg->base = devm_ioremap(&pdev->dev, res->start, resource_size(res));\r\nif (!syscfg->base)\r\nreturn -EFAULT;\r\nbridge = vexpress_config_bridge_register(pdev->dev.parent,\r\n&vexpress_syscfg_bridge_ops, syscfg);\r\nif (IS_ERR(bridge))\r\nreturn PTR_ERR(bridge);\r\nreturn 0;\r\n}\r\nstatic int __init vexpress_syscfg_init(void)\r\n{\r\nreturn platform_driver_register(&vexpress_syscfg_driver);\r\n}
