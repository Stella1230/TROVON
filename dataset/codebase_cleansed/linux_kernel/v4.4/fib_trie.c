static inline struct tnode *tn_info(struct key_vector *kv)\r\n{\r\nreturn container_of(kv, struct tnode, kv[0]);\r\n}\r\nstatic inline void node_set_parent(struct key_vector *n, struct key_vector *tp)\r\n{\r\nif (n)\r\nrcu_assign_pointer(tn_info(n)->parent, tp);\r\n}\r\nstatic inline unsigned long child_length(const struct key_vector *tn)\r\n{\r\nreturn (1ul << tn->bits) & ~(1ul);\r\n}\r\nstatic inline unsigned long get_index(t_key key, struct key_vector *kv)\r\n{\r\nunsigned long index = key ^ kv->key;\r\nif ((BITS_PER_LONG <= KEYLENGTH) && (KEYLENGTH == kv->pos))\r\nreturn 0;\r\nreturn index >> kv->pos;\r\n}\r\nstatic void __alias_free_mem(struct rcu_head *head)\r\n{\r\nstruct fib_alias *fa = container_of(head, struct fib_alias, rcu);\r\nkmem_cache_free(fn_alias_kmem, fa);\r\n}\r\nstatic inline void alias_free_mem_rcu(struct fib_alias *fa)\r\n{\r\ncall_rcu(&fa->rcu, __alias_free_mem);\r\n}\r\nstatic void __node_free_rcu(struct rcu_head *head)\r\n{\r\nstruct tnode *n = container_of(head, struct tnode, rcu);\r\nif (!n->tn_bits)\r\nkmem_cache_free(trie_leaf_kmem, n);\r\nelse if (n->tn_bits <= TNODE_KMALLOC_MAX)\r\nkfree(n);\r\nelse\r\nvfree(n);\r\n}\r\nstatic struct tnode *tnode_alloc(int bits)\r\n{\r\nsize_t size;\r\nif (bits > TNODE_VMALLOC_MAX)\r\nreturn NULL;\r\nsize = TNODE_SIZE(1ul << bits);\r\nif (size <= PAGE_SIZE)\r\nreturn kzalloc(size, GFP_KERNEL);\r\nelse\r\nreturn vzalloc(size);\r\n}\r\nstatic inline void empty_child_inc(struct key_vector *n)\r\n{\r\n++tn_info(n)->empty_children ? : ++tn_info(n)->full_children;\r\n}\r\nstatic inline void empty_child_dec(struct key_vector *n)\r\n{\r\ntn_info(n)->empty_children-- ? : tn_info(n)->full_children--;\r\n}\r\nstatic struct key_vector *leaf_new(t_key key, struct fib_alias *fa)\r\n{\r\nstruct key_vector *l;\r\nstruct tnode *kv;\r\nkv = kmem_cache_alloc(trie_leaf_kmem, GFP_KERNEL);\r\nif (!kv)\r\nreturn NULL;\r\nl = kv->kv;\r\nl->key = key;\r\nl->pos = 0;\r\nl->bits = 0;\r\nl->slen = fa->fa_slen;\r\nINIT_HLIST_HEAD(&l->leaf);\r\nhlist_add_head(&fa->fa_list, &l->leaf);\r\nreturn l;\r\n}\r\nstatic struct key_vector *tnode_new(t_key key, int pos, int bits)\r\n{\r\nunsigned int shift = pos + bits;\r\nstruct key_vector *tn;\r\nstruct tnode *tnode;\r\nBUG_ON(!bits || (shift > KEYLENGTH));\r\ntnode = tnode_alloc(bits);\r\nif (!tnode)\r\nreturn NULL;\r\npr_debug("AT %p s=%zu %zu\n", tnode, TNODE_SIZE(0),\r\nsizeof(struct key_vector *) << bits);\r\nif (bits == KEYLENGTH)\r\ntnode->full_children = 1;\r\nelse\r\ntnode->empty_children = 1ul << bits;\r\ntn = tnode->kv;\r\ntn->key = (shift < KEYLENGTH) ? (key >> shift) << shift : 0;\r\ntn->pos = pos;\r\ntn->bits = bits;\r\ntn->slen = pos;\r\nreturn tn;\r\n}\r\nstatic inline int tnode_full(struct key_vector *tn, struct key_vector *n)\r\n{\r\nreturn n && ((n->pos + n->bits) == tn->pos) && IS_TNODE(n);\r\n}\r\nstatic void put_child(struct key_vector *tn, unsigned long i,\r\nstruct key_vector *n)\r\n{\r\nstruct key_vector *chi = get_child(tn, i);\r\nint isfull, wasfull;\r\nBUG_ON(i >= child_length(tn));\r\nif (!n && chi)\r\nempty_child_inc(tn);\r\nif (n && !chi)\r\nempty_child_dec(tn);\r\nwasfull = tnode_full(tn, chi);\r\nisfull = tnode_full(tn, n);\r\nif (wasfull && !isfull)\r\ntn_info(tn)->full_children--;\r\nelse if (!wasfull && isfull)\r\ntn_info(tn)->full_children++;\r\nif (n && (tn->slen < n->slen))\r\ntn->slen = n->slen;\r\nrcu_assign_pointer(tn->tnode[i], n);\r\n}\r\nstatic void update_children(struct key_vector *tn)\r\n{\r\nunsigned long i;\r\nfor (i = child_length(tn); i;) {\r\nstruct key_vector *inode = get_child(tn, --i);\r\nif (!inode)\r\ncontinue;\r\nif (node_parent(inode) == tn)\r\nupdate_children(inode);\r\nelse\r\nnode_set_parent(inode, tn);\r\n}\r\n}\r\nstatic inline void put_child_root(struct key_vector *tp, t_key key,\r\nstruct key_vector *n)\r\n{\r\nif (IS_TRIE(tp))\r\nrcu_assign_pointer(tp->tnode[0], n);\r\nelse\r\nput_child(tp, get_index(key, tp), n);\r\n}\r\nstatic inline void tnode_free_init(struct key_vector *tn)\r\n{\r\ntn_info(tn)->rcu.next = NULL;\r\n}\r\nstatic inline void tnode_free_append(struct key_vector *tn,\r\nstruct key_vector *n)\r\n{\r\ntn_info(n)->rcu.next = tn_info(tn)->rcu.next;\r\ntn_info(tn)->rcu.next = &tn_info(n)->rcu;\r\n}\r\nstatic void tnode_free(struct key_vector *tn)\r\n{\r\nstruct callback_head *head = &tn_info(tn)->rcu;\r\nwhile (head) {\r\nhead = head->next;\r\ntnode_free_size += TNODE_SIZE(1ul << tn->bits);\r\nnode_free(tn);\r\ntn = container_of(head, struct tnode, rcu)->kv;\r\n}\r\nif (tnode_free_size >= PAGE_SIZE * sync_pages) {\r\ntnode_free_size = 0;\r\nsynchronize_rcu();\r\n}\r\n}\r\nstatic struct key_vector *replace(struct trie *t,\r\nstruct key_vector *oldtnode,\r\nstruct key_vector *tn)\r\n{\r\nstruct key_vector *tp = node_parent(oldtnode);\r\nunsigned long i;\r\nNODE_INIT_PARENT(tn, tp);\r\nput_child_root(tp, tn->key, tn);\r\nupdate_children(tn);\r\ntnode_free(oldtnode);\r\nfor (i = child_length(tn); i;) {\r\nstruct key_vector *inode = get_child(tn, --i);\r\nif (tnode_full(tn, inode))\r\ntn = resize(t, inode);\r\n}\r\nreturn tp;\r\n}\r\nstatic struct key_vector *inflate(struct trie *t,\r\nstruct key_vector *oldtnode)\r\n{\r\nstruct key_vector *tn;\r\nunsigned long i;\r\nt_key m;\r\npr_debug("In inflate\n");\r\ntn = tnode_new(oldtnode->key, oldtnode->pos - 1, oldtnode->bits + 1);\r\nif (!tn)\r\ngoto notnode;\r\ntnode_free_init(oldtnode);\r\nfor (i = child_length(oldtnode), m = 1u << tn->pos; i;) {\r\nstruct key_vector *inode = get_child(oldtnode, --i);\r\nstruct key_vector *node0, *node1;\r\nunsigned long j, k;\r\nif (!inode)\r\ncontinue;\r\nif (!tnode_full(oldtnode, inode)) {\r\nput_child(tn, get_index(inode->key, tn), inode);\r\ncontinue;\r\n}\r\ntnode_free_append(oldtnode, inode);\r\nif (inode->bits == 1) {\r\nput_child(tn, 2 * i + 1, get_child(inode, 1));\r\nput_child(tn, 2 * i, get_child(inode, 0));\r\ncontinue;\r\n}\r\nnode1 = tnode_new(inode->key | m, inode->pos, inode->bits - 1);\r\nif (!node1)\r\ngoto nomem;\r\nnode0 = tnode_new(inode->key, inode->pos, inode->bits - 1);\r\ntnode_free_append(tn, node1);\r\nif (!node0)\r\ngoto nomem;\r\ntnode_free_append(tn, node0);\r\nfor (k = child_length(inode), j = k / 2; j;) {\r\nput_child(node1, --j, get_child(inode, --k));\r\nput_child(node0, j, get_child(inode, j));\r\nput_child(node1, --j, get_child(inode, --k));\r\nput_child(node0, j, get_child(inode, j));\r\n}\r\nNODE_INIT_PARENT(node1, tn);\r\nNODE_INIT_PARENT(node0, tn);\r\nput_child(tn, 2 * i + 1, node1);\r\nput_child(tn, 2 * i, node0);\r\n}\r\nreturn replace(t, oldtnode, tn);\r\nnomem:\r\ntnode_free(tn);\r\nnotnode:\r\nreturn NULL;\r\n}\r\nstatic struct key_vector *halve(struct trie *t,\r\nstruct key_vector *oldtnode)\r\n{\r\nstruct key_vector *tn;\r\nunsigned long i;\r\npr_debug("In halve\n");\r\ntn = tnode_new(oldtnode->key, oldtnode->pos + 1, oldtnode->bits - 1);\r\nif (!tn)\r\ngoto notnode;\r\ntnode_free_init(oldtnode);\r\nfor (i = child_length(oldtnode); i;) {\r\nstruct key_vector *node1 = get_child(oldtnode, --i);\r\nstruct key_vector *node0 = get_child(oldtnode, --i);\r\nstruct key_vector *inode;\r\nif (!node1 || !node0) {\r\nput_child(tn, i / 2, node1 ? : node0);\r\ncontinue;\r\n}\r\ninode = tnode_new(node0->key, oldtnode->pos, 1);\r\nif (!inode)\r\ngoto nomem;\r\ntnode_free_append(tn, inode);\r\nput_child(inode, 1, node1);\r\nput_child(inode, 0, node0);\r\nNODE_INIT_PARENT(inode, tn);\r\nput_child(tn, i / 2, inode);\r\n}\r\nreturn replace(t, oldtnode, tn);\r\nnomem:\r\ntnode_free(tn);\r\nnotnode:\r\nreturn NULL;\r\n}\r\nstatic struct key_vector *collapse(struct trie *t,\r\nstruct key_vector *oldtnode)\r\n{\r\nstruct key_vector *n, *tp;\r\nunsigned long i;\r\nfor (n = NULL, i = child_length(oldtnode); !n && i;)\r\nn = get_child(oldtnode, --i);\r\ntp = node_parent(oldtnode);\r\nput_child_root(tp, oldtnode->key, n);\r\nnode_set_parent(n, tp);\r\nnode_free(oldtnode);\r\nreturn tp;\r\n}\r\nstatic unsigned char update_suffix(struct key_vector *tn)\r\n{\r\nunsigned char slen = tn->pos;\r\nunsigned long stride, i;\r\nfor (i = 0, stride = 0x2ul ; i < child_length(tn); i += stride) {\r\nstruct key_vector *n = get_child(tn, i);\r\nif (!n || (n->slen <= slen))\r\ncontinue;\r\nstride <<= (n->slen - slen);\r\nslen = n->slen;\r\ni &= ~(stride - 1);\r\nif ((slen + 1) >= (tn->pos + tn->bits))\r\nbreak;\r\n}\r\ntn->slen = slen;\r\nreturn slen;\r\n}\r\nstatic inline bool should_inflate(struct key_vector *tp, struct key_vector *tn)\r\n{\r\nunsigned long used = child_length(tn);\r\nunsigned long threshold = used;\r\nthreshold *= IS_TRIE(tp) ? inflate_threshold_root : inflate_threshold;\r\nused -= tn_info(tn)->empty_children;\r\nused += tn_info(tn)->full_children;\r\nreturn (used > 1) && tn->pos && ((50 * used) >= threshold);\r\n}\r\nstatic inline bool should_halve(struct key_vector *tp, struct key_vector *tn)\r\n{\r\nunsigned long used = child_length(tn);\r\nunsigned long threshold = used;\r\nthreshold *= IS_TRIE(tp) ? halve_threshold_root : halve_threshold;\r\nused -= tn_info(tn)->empty_children;\r\nreturn (used > 1) && (tn->bits > 1) && ((100 * used) < threshold);\r\n}\r\nstatic inline bool should_collapse(struct key_vector *tn)\r\n{\r\nunsigned long used = child_length(tn);\r\nused -= tn_info(tn)->empty_children;\r\nif ((tn->bits == KEYLENGTH) && tn_info(tn)->full_children)\r\nused -= KEY_MAX;\r\nreturn used < 2;\r\n}\r\nstatic struct key_vector *resize(struct trie *t, struct key_vector *tn)\r\n{\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nstruct trie_use_stats __percpu *stats = t->stats;\r\n#endif\r\nstruct key_vector *tp = node_parent(tn);\r\nunsigned long cindex = get_index(tn->key, tp);\r\nint max_work = MAX_WORK;\r\npr_debug("In tnode_resize %p inflate_threshold=%d threshold=%d\n",\r\ntn, inflate_threshold, halve_threshold);\r\nBUG_ON(tn != get_child(tp, cindex));\r\nwhile (should_inflate(tp, tn) && max_work) {\r\ntp = inflate(t, tn);\r\nif (!tp) {\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nthis_cpu_inc(stats->resize_node_skipped);\r\n#endif\r\nbreak;\r\n}\r\nmax_work--;\r\ntn = get_child(tp, cindex);\r\n}\r\ntp = node_parent(tn);\r\nif (max_work != MAX_WORK)\r\nreturn tp;\r\nwhile (should_halve(tp, tn) && max_work) {\r\ntp = halve(t, tn);\r\nif (!tp) {\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nthis_cpu_inc(stats->resize_node_skipped);\r\n#endif\r\nbreak;\r\n}\r\nmax_work--;\r\ntn = get_child(tp, cindex);\r\n}\r\nif (should_collapse(tn))\r\nreturn collapse(t, tn);\r\ntp = node_parent(tn);\r\nif (max_work != MAX_WORK)\r\nreturn tp;\r\nif (tn->slen > tn->pos) {\r\nunsigned char slen = update_suffix(tn);\r\nif (slen > tp->slen)\r\ntp->slen = slen;\r\n}\r\nreturn tp;\r\n}\r\nstatic void leaf_pull_suffix(struct key_vector *tp, struct key_vector *l)\r\n{\r\nwhile ((tp->slen > tp->pos) && (tp->slen > l->slen)) {\r\nif (update_suffix(tp) > l->slen)\r\nbreak;\r\ntp = node_parent(tp);\r\n}\r\n}\r\nstatic void leaf_push_suffix(struct key_vector *tn, struct key_vector *l)\r\n{\r\nwhile (tn->slen < l->slen) {\r\ntn->slen = l->slen;\r\ntn = node_parent(tn);\r\n}\r\n}\r\nstatic struct key_vector *fib_find_node(struct trie *t,\r\nstruct key_vector **tp, u32 key)\r\n{\r\nstruct key_vector *pn, *n = t->kv;\r\nunsigned long index = 0;\r\ndo {\r\npn = n;\r\nn = get_child_rcu(n, index);\r\nif (!n)\r\nbreak;\r\nindex = get_cindex(key, n);\r\nif (index >= (1ul << n->bits)) {\r\nn = NULL;\r\nbreak;\r\n}\r\n} while (IS_TNODE(n));\r\n*tp = pn;\r\nreturn n;\r\n}\r\nstatic struct fib_alias *fib_find_alias(struct hlist_head *fah, u8 slen,\r\nu8 tos, u32 prio, u32 tb_id)\r\n{\r\nstruct fib_alias *fa;\r\nif (!fah)\r\nreturn NULL;\r\nhlist_for_each_entry(fa, fah, fa_list) {\r\nif (fa->fa_slen < slen)\r\ncontinue;\r\nif (fa->fa_slen != slen)\r\nbreak;\r\nif (fa->tb_id > tb_id)\r\ncontinue;\r\nif (fa->tb_id != tb_id)\r\nbreak;\r\nif (fa->fa_tos > tos)\r\ncontinue;\r\nif (fa->fa_info->fib_priority >= prio || fa->fa_tos < tos)\r\nreturn fa;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void trie_rebalance(struct trie *t, struct key_vector *tn)\r\n{\r\nwhile (!IS_TRIE(tn))\r\ntn = resize(t, tn);\r\n}\r\nstatic int fib_insert_node(struct trie *t, struct key_vector *tp,\r\nstruct fib_alias *new, t_key key)\r\n{\r\nstruct key_vector *n, *l;\r\nl = leaf_new(key, new);\r\nif (!l)\r\ngoto noleaf;\r\nn = get_child(tp, get_index(key, tp));\r\nif (n) {\r\nstruct key_vector *tn;\r\ntn = tnode_new(key, __fls(key ^ n->key), 1);\r\nif (!tn)\r\ngoto notnode;\r\nNODE_INIT_PARENT(tn, tp);\r\nput_child(tn, get_index(key, tn) ^ 1, n);\r\nput_child_root(tp, key, tn);\r\nnode_set_parent(n, tn);\r\ntp = tn;\r\n}\r\nNODE_INIT_PARENT(l, tp);\r\nput_child_root(tp, key, l);\r\ntrie_rebalance(t, tp);\r\nreturn 0;\r\nnotnode:\r\nnode_free(l);\r\nnoleaf:\r\nreturn -ENOMEM;\r\n}\r\nstatic int fib_insert_alias(struct trie *t, struct key_vector *tp,\r\nstruct key_vector *l, struct fib_alias *new,\r\nstruct fib_alias *fa, t_key key)\r\n{\r\nif (!l)\r\nreturn fib_insert_node(t, tp, new, key);\r\nif (fa) {\r\nhlist_add_before_rcu(&new->fa_list, &fa->fa_list);\r\n} else {\r\nstruct fib_alias *last;\r\nhlist_for_each_entry(last, &l->leaf, fa_list) {\r\nif (new->fa_slen < last->fa_slen)\r\nbreak;\r\nif ((new->fa_slen == last->fa_slen) &&\r\n(new->tb_id > last->tb_id))\r\nbreak;\r\nfa = last;\r\n}\r\nif (fa)\r\nhlist_add_behind_rcu(&new->fa_list, &fa->fa_list);\r\nelse\r\nhlist_add_head_rcu(&new->fa_list, &l->leaf);\r\n}\r\nif (l->slen < new->fa_slen) {\r\nl->slen = new->fa_slen;\r\nleaf_push_suffix(tp, l);\r\n}\r\nreturn 0;\r\n}\r\nint fib_table_insert(struct fib_table *tb, struct fib_config *cfg)\r\n{\r\nstruct trie *t = (struct trie *)tb->tb_data;\r\nstruct fib_alias *fa, *new_fa;\r\nstruct key_vector *l, *tp;\r\nunsigned int nlflags = 0;\r\nstruct fib_info *fi;\r\nu8 plen = cfg->fc_dst_len;\r\nu8 slen = KEYLENGTH - plen;\r\nu8 tos = cfg->fc_tos;\r\nu32 key;\r\nint err;\r\nif (plen > KEYLENGTH)\r\nreturn -EINVAL;\r\nkey = ntohl(cfg->fc_dst);\r\npr_debug("Insert table=%u %08x/%d\n", tb->tb_id, key, plen);\r\nif ((plen < KEYLENGTH) && (key << plen))\r\nreturn -EINVAL;\r\nfi = fib_create_info(cfg);\r\nif (IS_ERR(fi)) {\r\nerr = PTR_ERR(fi);\r\ngoto err;\r\n}\r\nl = fib_find_node(t, &tp, key);\r\nfa = l ? fib_find_alias(&l->leaf, slen, tos, fi->fib_priority,\r\ntb->tb_id) : NULL;\r\nif (fa && fa->fa_tos == tos &&\r\nfa->fa_info->fib_priority == fi->fib_priority) {\r\nstruct fib_alias *fa_first, *fa_match;\r\nerr = -EEXIST;\r\nif (cfg->fc_nlflags & NLM_F_EXCL)\r\ngoto out;\r\nfa_match = NULL;\r\nfa_first = fa;\r\nhlist_for_each_entry_from(fa, fa_list) {\r\nif ((fa->fa_slen != slen) ||\r\n(fa->tb_id != tb->tb_id) ||\r\n(fa->fa_tos != tos))\r\nbreak;\r\nif (fa->fa_info->fib_priority != fi->fib_priority)\r\nbreak;\r\nif (fa->fa_type == cfg->fc_type &&\r\nfa->fa_info == fi) {\r\nfa_match = fa;\r\nbreak;\r\n}\r\n}\r\nif (cfg->fc_nlflags & NLM_F_REPLACE) {\r\nstruct fib_info *fi_drop;\r\nu8 state;\r\nfa = fa_first;\r\nif (fa_match) {\r\nif (fa == fa_match)\r\nerr = 0;\r\ngoto out;\r\n}\r\nerr = -ENOBUFS;\r\nnew_fa = kmem_cache_alloc(fn_alias_kmem, GFP_KERNEL);\r\nif (!new_fa)\r\ngoto out;\r\nfi_drop = fa->fa_info;\r\nnew_fa->fa_tos = fa->fa_tos;\r\nnew_fa->fa_info = fi;\r\nnew_fa->fa_type = cfg->fc_type;\r\nstate = fa->fa_state;\r\nnew_fa->fa_state = state & ~FA_S_ACCESSED;\r\nnew_fa->fa_slen = fa->fa_slen;\r\nnew_fa->tb_id = tb->tb_id;\r\nnew_fa->fa_default = -1;\r\nerr = switchdev_fib_ipv4_add(key, plen, fi,\r\nnew_fa->fa_tos,\r\ncfg->fc_type,\r\ncfg->fc_nlflags,\r\ntb->tb_id);\r\nif (err) {\r\nswitchdev_fib_ipv4_abort(fi);\r\nkmem_cache_free(fn_alias_kmem, new_fa);\r\ngoto out;\r\n}\r\nhlist_replace_rcu(&fa->fa_list, &new_fa->fa_list);\r\nalias_free_mem_rcu(fa);\r\nfib_release_info(fi_drop);\r\nif (state & FA_S_ACCESSED)\r\nrt_cache_flush(cfg->fc_nlinfo.nl_net);\r\nrtmsg_fib(RTM_NEWROUTE, htonl(key), new_fa, plen,\r\ntb->tb_id, &cfg->fc_nlinfo, NLM_F_REPLACE);\r\ngoto succeeded;\r\n}\r\nif (fa_match)\r\ngoto out;\r\nif (cfg->fc_nlflags & NLM_F_APPEND)\r\nnlflags = NLM_F_APPEND;\r\nelse\r\nfa = fa_first;\r\n}\r\nerr = -ENOENT;\r\nif (!(cfg->fc_nlflags & NLM_F_CREATE))\r\ngoto out;\r\nerr = -ENOBUFS;\r\nnew_fa = kmem_cache_alloc(fn_alias_kmem, GFP_KERNEL);\r\nif (!new_fa)\r\ngoto out;\r\nnew_fa->fa_info = fi;\r\nnew_fa->fa_tos = tos;\r\nnew_fa->fa_type = cfg->fc_type;\r\nnew_fa->fa_state = 0;\r\nnew_fa->fa_slen = slen;\r\nnew_fa->tb_id = tb->tb_id;\r\nnew_fa->fa_default = -1;\r\nerr = switchdev_fib_ipv4_add(key, plen, fi, tos, cfg->fc_type,\r\ncfg->fc_nlflags, tb->tb_id);\r\nif (err) {\r\nswitchdev_fib_ipv4_abort(fi);\r\ngoto out_free_new_fa;\r\n}\r\nerr = fib_insert_alias(t, tp, l, new_fa, fa, key);\r\nif (err)\r\ngoto out_sw_fib_del;\r\nif (!plen)\r\ntb->tb_num_default++;\r\nrt_cache_flush(cfg->fc_nlinfo.nl_net);\r\nrtmsg_fib(RTM_NEWROUTE, htonl(key), new_fa, plen, new_fa->tb_id,\r\n&cfg->fc_nlinfo, nlflags);\r\nsucceeded:\r\nreturn 0;\r\nout_sw_fib_del:\r\nswitchdev_fib_ipv4_del(key, plen, fi, tos, cfg->fc_type, tb->tb_id);\r\nout_free_new_fa:\r\nkmem_cache_free(fn_alias_kmem, new_fa);\r\nout:\r\nfib_release_info(fi);\r\nerr:\r\nreturn err;\r\n}\r\nstatic inline t_key prefix_mismatch(t_key key, struct key_vector *n)\r\n{\r\nt_key prefix = n->key;\r\nreturn (key ^ prefix) & (prefix | -prefix);\r\n}\r\nint fib_table_lookup(struct fib_table *tb, const struct flowi4 *flp,\r\nstruct fib_result *res, int fib_flags)\r\n{\r\nstruct trie *t = (struct trie *) tb->tb_data;\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nstruct trie_use_stats __percpu *stats = t->stats;\r\n#endif\r\nconst t_key key = ntohl(flp->daddr);\r\nstruct key_vector *n, *pn;\r\nstruct fib_alias *fa;\r\nunsigned long index;\r\nt_key cindex;\r\ntrace_fib_table_lookup(tb->tb_id, flp);\r\npn = t->kv;\r\ncindex = 0;\r\nn = get_child_rcu(pn, cindex);\r\nif (!n)\r\nreturn -EAGAIN;\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nthis_cpu_inc(stats->gets);\r\n#endif\r\nfor (;;) {\r\nindex = get_cindex(key, n);\r\nif (index >= (1ul << n->bits))\r\nbreak;\r\nif (IS_LEAF(n))\r\ngoto found;\r\nif (n->slen > n->pos) {\r\npn = n;\r\ncindex = index;\r\n}\r\nn = get_child_rcu(n, index);\r\nif (unlikely(!n))\r\ngoto backtrace;\r\n}\r\nfor (;;) {\r\nstruct key_vector __rcu **cptr = n->tnode;\r\nif (unlikely(prefix_mismatch(key, n)) || (n->slen == n->pos))\r\ngoto backtrace;\r\nif (unlikely(IS_LEAF(n)))\r\nbreak;\r\nwhile ((n = rcu_dereference(*cptr)) == NULL) {\r\nbacktrace:\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nif (!n)\r\nthis_cpu_inc(stats->null_node_hit);\r\n#endif\r\nwhile (!cindex) {\r\nt_key pkey = pn->key;\r\nif (IS_TRIE(pn))\r\nreturn -EAGAIN;\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nthis_cpu_inc(stats->backtrack);\r\n#endif\r\npn = node_parent_rcu(pn);\r\ncindex = get_index(pkey, pn);\r\n}\r\ncindex &= cindex - 1;\r\ncptr = &pn->tnode[cindex];\r\n}\r\n}\r\nfound:\r\nindex = key ^ n->key;\r\nhlist_for_each_entry_rcu(fa, &n->leaf, fa_list) {\r\nstruct fib_info *fi = fa->fa_info;\r\nint nhsel, err;\r\nif ((index >= (1ul << fa->fa_slen)) &&\r\n((BITS_PER_LONG > KEYLENGTH) || (fa->fa_slen != KEYLENGTH)))\r\ncontinue;\r\nif (fa->fa_tos && fa->fa_tos != flp->flowi4_tos)\r\ncontinue;\r\nif (fi->fib_dead)\r\ncontinue;\r\nif (fa->fa_info->fib_scope < flp->flowi4_scope)\r\ncontinue;\r\nfib_alias_accessed(fa);\r\nerr = fib_props[fa->fa_type].error;\r\nif (unlikely(err < 0)) {\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nthis_cpu_inc(stats->semantic_match_passed);\r\n#endif\r\nreturn err;\r\n}\r\nif (fi->fib_flags & RTNH_F_DEAD)\r\ncontinue;\r\nfor (nhsel = 0; nhsel < fi->fib_nhs; nhsel++) {\r\nconst struct fib_nh *nh = &fi->fib_nh[nhsel];\r\nstruct in_device *in_dev = __in_dev_get_rcu(nh->nh_dev);\r\nif (nh->nh_flags & RTNH_F_DEAD)\r\ncontinue;\r\nif (in_dev &&\r\nIN_DEV_IGNORE_ROUTES_WITH_LINKDOWN(in_dev) &&\r\nnh->nh_flags & RTNH_F_LINKDOWN &&\r\n!(fib_flags & FIB_LOOKUP_IGNORE_LINKSTATE))\r\ncontinue;\r\nif (!(flp->flowi4_flags & FLOWI_FLAG_SKIP_NH_OIF)) {\r\nif (flp->flowi4_oif &&\r\nflp->flowi4_oif != nh->nh_oif)\r\ncontinue;\r\n}\r\nif (!(fib_flags & FIB_LOOKUP_NOREF))\r\natomic_inc(&fi->fib_clntref);\r\nres->prefixlen = KEYLENGTH - fa->fa_slen;\r\nres->nh_sel = nhsel;\r\nres->type = fa->fa_type;\r\nres->scope = fi->fib_scope;\r\nres->fi = fi;\r\nres->table = tb;\r\nres->fa_head = &n->leaf;\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nthis_cpu_inc(stats->semantic_match_passed);\r\n#endif\r\ntrace_fib_table_lookup_nh(nh);\r\nreturn err;\r\n}\r\n}\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nthis_cpu_inc(stats->semantic_match_miss);\r\n#endif\r\ngoto backtrace;\r\n}\r\nstatic void fib_remove_alias(struct trie *t, struct key_vector *tp,\r\nstruct key_vector *l, struct fib_alias *old)\r\n{\r\nstruct hlist_node **pprev = old->fa_list.pprev;\r\nstruct fib_alias *fa = hlist_entry(pprev, typeof(*fa), fa_list.next);\r\nhlist_del_rcu(&old->fa_list);\r\nif (hlist_empty(&l->leaf)) {\r\nput_child_root(tp, l->key, NULL);\r\nnode_free(l);\r\ntrie_rebalance(t, tp);\r\nreturn;\r\n}\r\nif (*pprev)\r\nreturn;\r\nl->slen = fa->fa_slen;\r\nleaf_pull_suffix(tp, l);\r\n}\r\nint fib_table_delete(struct fib_table *tb, struct fib_config *cfg)\r\n{\r\nstruct trie *t = (struct trie *) tb->tb_data;\r\nstruct fib_alias *fa, *fa_to_delete;\r\nstruct key_vector *l, *tp;\r\nu8 plen = cfg->fc_dst_len;\r\nu8 slen = KEYLENGTH - plen;\r\nu8 tos = cfg->fc_tos;\r\nu32 key;\r\nif (plen > KEYLENGTH)\r\nreturn -EINVAL;\r\nkey = ntohl(cfg->fc_dst);\r\nif ((plen < KEYLENGTH) && (key << plen))\r\nreturn -EINVAL;\r\nl = fib_find_node(t, &tp, key);\r\nif (!l)\r\nreturn -ESRCH;\r\nfa = fib_find_alias(&l->leaf, slen, tos, 0, tb->tb_id);\r\nif (!fa)\r\nreturn -ESRCH;\r\npr_debug("Deleting %08x/%d tos=%d t=%p\n", key, plen, tos, t);\r\nfa_to_delete = NULL;\r\nhlist_for_each_entry_from(fa, fa_list) {\r\nstruct fib_info *fi = fa->fa_info;\r\nif ((fa->fa_slen != slen) ||\r\n(fa->tb_id != tb->tb_id) ||\r\n(fa->fa_tos != tos))\r\nbreak;\r\nif ((!cfg->fc_type || fa->fa_type == cfg->fc_type) &&\r\n(cfg->fc_scope == RT_SCOPE_NOWHERE ||\r\nfa->fa_info->fib_scope == cfg->fc_scope) &&\r\n(!cfg->fc_prefsrc ||\r\nfi->fib_prefsrc == cfg->fc_prefsrc) &&\r\n(!cfg->fc_protocol ||\r\nfi->fib_protocol == cfg->fc_protocol) &&\r\nfib_nh_match(cfg, fi) == 0) {\r\nfa_to_delete = fa;\r\nbreak;\r\n}\r\n}\r\nif (!fa_to_delete)\r\nreturn -ESRCH;\r\nswitchdev_fib_ipv4_del(key, plen, fa_to_delete->fa_info, tos,\r\ncfg->fc_type, tb->tb_id);\r\nrtmsg_fib(RTM_DELROUTE, htonl(key), fa_to_delete, plen, tb->tb_id,\r\n&cfg->fc_nlinfo, 0);\r\nif (!plen)\r\ntb->tb_num_default--;\r\nfib_remove_alias(t, tp, l, fa_to_delete);\r\nif (fa_to_delete->fa_state & FA_S_ACCESSED)\r\nrt_cache_flush(cfg->fc_nlinfo.nl_net);\r\nfib_release_info(fa_to_delete->fa_info);\r\nalias_free_mem_rcu(fa_to_delete);\r\nreturn 0;\r\n}\r\nstatic struct key_vector *leaf_walk_rcu(struct key_vector **tn, t_key key)\r\n{\r\nstruct key_vector *pn, *n = *tn;\r\nunsigned long cindex;\r\ndo {\r\npn = n;\r\ncindex = (key > pn->key) ? get_index(key, pn) : 0;\r\nif (cindex >> pn->bits)\r\nbreak;\r\nn = get_child_rcu(pn, cindex++);\r\nif (!n)\r\nbreak;\r\nif (IS_LEAF(n) && (n->key >= key))\r\ngoto found;\r\n} while (IS_TNODE(n));\r\nwhile (!IS_TRIE(pn)) {\r\nif (cindex >= (1ul << pn->bits)) {\r\nt_key pkey = pn->key;\r\npn = node_parent_rcu(pn);\r\ncindex = get_index(pkey, pn) + 1;\r\ncontinue;\r\n}\r\nn = get_child_rcu(pn, cindex++);\r\nif (!n)\r\ncontinue;\r\nif (IS_LEAF(n))\r\ngoto found;\r\npn = n;\r\ncindex = 0;\r\n}\r\n*tn = pn;\r\nreturn NULL;\r\nfound:\r\n*tn = pn;\r\nreturn n;\r\n}\r\nstatic void fib_trie_free(struct fib_table *tb)\r\n{\r\nstruct trie *t = (struct trie *)tb->tb_data;\r\nstruct key_vector *pn = t->kv;\r\nunsigned long cindex = 1;\r\nstruct hlist_node *tmp;\r\nstruct fib_alias *fa;\r\nfor (;;) {\r\nstruct key_vector *n;\r\nif (!(cindex--)) {\r\nt_key pkey = pn->key;\r\nif (IS_TRIE(pn))\r\nbreak;\r\nn = pn;\r\npn = node_parent(pn);\r\nput_child_root(pn, n->key, NULL);\r\nnode_free(n);\r\ncindex = get_index(pkey, pn);\r\ncontinue;\r\n}\r\nn = get_child(pn, cindex);\r\nif (!n)\r\ncontinue;\r\nif (IS_TNODE(n)) {\r\npn = n;\r\ncindex = 1ul << n->bits;\r\ncontinue;\r\n}\r\nhlist_for_each_entry_safe(fa, tmp, &n->leaf, fa_list) {\r\nhlist_del_rcu(&fa->fa_list);\r\nalias_free_mem_rcu(fa);\r\n}\r\nput_child_root(pn, n->key, NULL);\r\nnode_free(n);\r\n}\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nfree_percpu(t->stats);\r\n#endif\r\nkfree(tb);\r\n}\r\nstruct fib_table *fib_trie_unmerge(struct fib_table *oldtb)\r\n{\r\nstruct trie *ot = (struct trie *)oldtb->tb_data;\r\nstruct key_vector *l, *tp = ot->kv;\r\nstruct fib_table *local_tb;\r\nstruct fib_alias *fa;\r\nstruct trie *lt;\r\nt_key key = 0;\r\nif (oldtb->tb_data == oldtb->__data)\r\nreturn oldtb;\r\nlocal_tb = fib_trie_table(RT_TABLE_LOCAL, NULL);\r\nif (!local_tb)\r\nreturn NULL;\r\nlt = (struct trie *)local_tb->tb_data;\r\nwhile ((l = leaf_walk_rcu(&tp, key)) != NULL) {\r\nstruct key_vector *local_l = NULL, *local_tp;\r\nhlist_for_each_entry_rcu(fa, &l->leaf, fa_list) {\r\nstruct fib_alias *new_fa;\r\nif (local_tb->tb_id != fa->tb_id)\r\ncontinue;\r\nnew_fa = kmem_cache_alloc(fn_alias_kmem, GFP_KERNEL);\r\nif (!new_fa)\r\ngoto out;\r\nmemcpy(new_fa, fa, sizeof(*fa));\r\nif (!local_l)\r\nlocal_l = fib_find_node(lt, &local_tp, l->key);\r\nif (fib_insert_alias(lt, local_tp, local_l, new_fa,\r\nNULL, l->key))\r\ngoto out;\r\n}\r\nkey = l->key + 1;\r\nif (key < l->key)\r\nbreak;\r\n}\r\nreturn local_tb;\r\nout:\r\nfib_trie_free(local_tb);\r\nreturn NULL;\r\n}\r\nvoid fib_table_flush_external(struct fib_table *tb)\r\n{\r\nstruct trie *t = (struct trie *)tb->tb_data;\r\nstruct key_vector *pn = t->kv;\r\nunsigned long cindex = 1;\r\nstruct hlist_node *tmp;\r\nstruct fib_alias *fa;\r\nfor (;;) {\r\nunsigned char slen = 0;\r\nstruct key_vector *n;\r\nif (!(cindex--)) {\r\nt_key pkey = pn->key;\r\nif (IS_TRIE(pn))\r\nbreak;\r\npn = resize(t, pn);\r\ncindex = get_index(pkey, pn);\r\ncontinue;\r\n}\r\nn = get_child(pn, cindex);\r\nif (!n)\r\ncontinue;\r\nif (IS_TNODE(n)) {\r\npn = n;\r\ncindex = 1ul << n->bits;\r\ncontinue;\r\n}\r\nhlist_for_each_entry_safe(fa, tmp, &n->leaf, fa_list) {\r\nstruct fib_info *fi = fa->fa_info;\r\nif (tb->tb_id != fa->tb_id) {\r\nhlist_del_rcu(&fa->fa_list);\r\nalias_free_mem_rcu(fa);\r\ncontinue;\r\n}\r\nslen = fa->fa_slen;\r\nif (!fi || !(fi->fib_flags & RTNH_F_OFFLOAD))\r\ncontinue;\r\nswitchdev_fib_ipv4_del(n->key, KEYLENGTH - fa->fa_slen,\r\nfi, fa->fa_tos, fa->fa_type,\r\ntb->tb_id);\r\n}\r\nn->slen = slen;\r\nif (hlist_empty(&n->leaf)) {\r\nput_child_root(pn, n->key, NULL);\r\nnode_free(n);\r\n}\r\n}\r\n}\r\nint fib_table_flush(struct fib_table *tb)\r\n{\r\nstruct trie *t = (struct trie *)tb->tb_data;\r\nstruct key_vector *pn = t->kv;\r\nunsigned long cindex = 1;\r\nstruct hlist_node *tmp;\r\nstruct fib_alias *fa;\r\nint found = 0;\r\nfor (;;) {\r\nunsigned char slen = 0;\r\nstruct key_vector *n;\r\nif (!(cindex--)) {\r\nt_key pkey = pn->key;\r\nif (IS_TRIE(pn))\r\nbreak;\r\npn = resize(t, pn);\r\ncindex = get_index(pkey, pn);\r\ncontinue;\r\n}\r\nn = get_child(pn, cindex);\r\nif (!n)\r\ncontinue;\r\nif (IS_TNODE(n)) {\r\npn = n;\r\ncindex = 1ul << n->bits;\r\ncontinue;\r\n}\r\nhlist_for_each_entry_safe(fa, tmp, &n->leaf, fa_list) {\r\nstruct fib_info *fi = fa->fa_info;\r\nif (!fi || !(fi->fib_flags & RTNH_F_DEAD)) {\r\nslen = fa->fa_slen;\r\ncontinue;\r\n}\r\nswitchdev_fib_ipv4_del(n->key, KEYLENGTH - fa->fa_slen,\r\nfi, fa->fa_tos, fa->fa_type,\r\ntb->tb_id);\r\nhlist_del_rcu(&fa->fa_list);\r\nfib_release_info(fa->fa_info);\r\nalias_free_mem_rcu(fa);\r\nfound++;\r\n}\r\nn->slen = slen;\r\nif (hlist_empty(&n->leaf)) {\r\nput_child_root(pn, n->key, NULL);\r\nnode_free(n);\r\n}\r\n}\r\npr_debug("trie_flush found=%d\n", found);\r\nreturn found;\r\n}\r\nstatic void __trie_free_rcu(struct rcu_head *head)\r\n{\r\nstruct fib_table *tb = container_of(head, struct fib_table, rcu);\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nstruct trie *t = (struct trie *)tb->tb_data;\r\nif (tb->tb_data == tb->__data)\r\nfree_percpu(t->stats);\r\n#endif\r\nkfree(tb);\r\n}\r\nvoid fib_free_table(struct fib_table *tb)\r\n{\r\ncall_rcu(&tb->rcu, __trie_free_rcu);\r\n}\r\nstatic int fn_trie_dump_leaf(struct key_vector *l, struct fib_table *tb,\r\nstruct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\n__be32 xkey = htonl(l->key);\r\nstruct fib_alias *fa;\r\nint i, s_i;\r\ns_i = cb->args[4];\r\ni = 0;\r\nhlist_for_each_entry_rcu(fa, &l->leaf, fa_list) {\r\nif (i < s_i) {\r\ni++;\r\ncontinue;\r\n}\r\nif (tb->tb_id != fa->tb_id) {\r\ni++;\r\ncontinue;\r\n}\r\nif (fib_dump_info(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nRTM_NEWROUTE,\r\ntb->tb_id,\r\nfa->fa_type,\r\nxkey,\r\nKEYLENGTH - fa->fa_slen,\r\nfa->fa_tos,\r\nfa->fa_info, NLM_F_MULTI) < 0) {\r\ncb->args[4] = i;\r\nreturn -1;\r\n}\r\ni++;\r\n}\r\ncb->args[4] = i;\r\nreturn skb->len;\r\n}\r\nint fib_table_dump(struct fib_table *tb, struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nstruct trie *t = (struct trie *)tb->tb_data;\r\nstruct key_vector *l, *tp = t->kv;\r\nint count = cb->args[2];\r\nt_key key = cb->args[3];\r\nwhile ((l = leaf_walk_rcu(&tp, key)) != NULL) {\r\nif (fn_trie_dump_leaf(l, tb, skb, cb) < 0) {\r\ncb->args[3] = key;\r\ncb->args[2] = count;\r\nreturn -1;\r\n}\r\n++count;\r\nkey = l->key + 1;\r\nmemset(&cb->args[4], 0,\r\nsizeof(cb->args) - 4*sizeof(cb->args[0]));\r\nif (key < l->key)\r\nbreak;\r\n}\r\ncb->args[3] = key;\r\ncb->args[2] = count;\r\nreturn skb->len;\r\n}\r\nvoid __init fib_trie_init(void)\r\n{\r\nfn_alias_kmem = kmem_cache_create("ip_fib_alias",\r\nsizeof(struct fib_alias),\r\n0, SLAB_PANIC, NULL);\r\ntrie_leaf_kmem = kmem_cache_create("ip_fib_trie",\r\nLEAF_SIZE,\r\n0, SLAB_PANIC, NULL);\r\n}\r\nstruct fib_table *fib_trie_table(u32 id, struct fib_table *alias)\r\n{\r\nstruct fib_table *tb;\r\nstruct trie *t;\r\nsize_t sz = sizeof(*tb);\r\nif (!alias)\r\nsz += sizeof(struct trie);\r\ntb = kzalloc(sz, GFP_KERNEL);\r\nif (!tb)\r\nreturn NULL;\r\ntb->tb_id = id;\r\ntb->tb_num_default = 0;\r\ntb->tb_data = (alias ? alias->__data : tb->__data);\r\nif (alias)\r\nreturn tb;\r\nt = (struct trie *) tb->tb_data;\r\nt->kv[0].pos = KEYLENGTH;\r\nt->kv[0].slen = KEYLENGTH;\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\nt->stats = alloc_percpu(struct trie_use_stats);\r\nif (!t->stats) {\r\nkfree(tb);\r\ntb = NULL;\r\n}\r\n#endif\r\nreturn tb;\r\n}\r\nstatic struct key_vector *fib_trie_get_next(struct fib_trie_iter *iter)\r\n{\r\nunsigned long cindex = iter->index;\r\nstruct key_vector *pn = iter->tnode;\r\nt_key pkey;\r\npr_debug("get_next iter={node=%p index=%d depth=%d}\n",\r\niter->tnode, iter->index, iter->depth);\r\nwhile (!IS_TRIE(pn)) {\r\nwhile (cindex < child_length(pn)) {\r\nstruct key_vector *n = get_child_rcu(pn, cindex++);\r\nif (!n)\r\ncontinue;\r\nif (IS_LEAF(n)) {\r\niter->tnode = pn;\r\niter->index = cindex;\r\n} else {\r\niter->tnode = n;\r\niter->index = 0;\r\n++iter->depth;\r\n}\r\nreturn n;\r\n}\r\npkey = pn->key;\r\npn = node_parent_rcu(pn);\r\ncindex = get_index(pkey, pn) + 1;\r\n--iter->depth;\r\n}\r\niter->tnode = pn;\r\niter->index = 0;\r\nreturn NULL;\r\n}\r\nstatic struct key_vector *fib_trie_get_first(struct fib_trie_iter *iter,\r\nstruct trie *t)\r\n{\r\nstruct key_vector *n, *pn;\r\nif (!t)\r\nreturn NULL;\r\npn = t->kv;\r\nn = rcu_dereference(pn->tnode[0]);\r\nif (!n)\r\nreturn NULL;\r\nif (IS_TNODE(n)) {\r\niter->tnode = n;\r\niter->index = 0;\r\niter->depth = 1;\r\n} else {\r\niter->tnode = pn;\r\niter->index = 0;\r\niter->depth = 0;\r\n}\r\nreturn n;\r\n}\r\nstatic void trie_collect_stats(struct trie *t, struct trie_stat *s)\r\n{\r\nstruct key_vector *n;\r\nstruct fib_trie_iter iter;\r\nmemset(s, 0, sizeof(*s));\r\nrcu_read_lock();\r\nfor (n = fib_trie_get_first(&iter, t); n; n = fib_trie_get_next(&iter)) {\r\nif (IS_LEAF(n)) {\r\nstruct fib_alias *fa;\r\ns->leaves++;\r\ns->totdepth += iter.depth;\r\nif (iter.depth > s->maxdepth)\r\ns->maxdepth = iter.depth;\r\nhlist_for_each_entry_rcu(fa, &n->leaf, fa_list)\r\n++s->prefixes;\r\n} else {\r\ns->tnodes++;\r\nif (n->bits < MAX_STAT_DEPTH)\r\ns->nodesizes[n->bits]++;\r\ns->nullpointers += tn_info(n)->empty_children;\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void trie_show_stats(struct seq_file *seq, struct trie_stat *stat)\r\n{\r\nunsigned int i, max, pointers, bytes, avdepth;\r\nif (stat->leaves)\r\navdepth = stat->totdepth*100 / stat->leaves;\r\nelse\r\navdepth = 0;\r\nseq_printf(seq, "\tAver depth: %u.%02d\n",\r\navdepth / 100, avdepth % 100);\r\nseq_printf(seq, "\tMax depth: %u\n", stat->maxdepth);\r\nseq_printf(seq, "\tLeaves: %u\n", stat->leaves);\r\nbytes = LEAF_SIZE * stat->leaves;\r\nseq_printf(seq, "\tPrefixes: %u\n", stat->prefixes);\r\nbytes += sizeof(struct fib_alias) * stat->prefixes;\r\nseq_printf(seq, "\tInternal nodes: %u\n\t", stat->tnodes);\r\nbytes += TNODE_SIZE(0) * stat->tnodes;\r\nmax = MAX_STAT_DEPTH;\r\nwhile (max > 0 && stat->nodesizes[max-1] == 0)\r\nmax--;\r\npointers = 0;\r\nfor (i = 1; i < max; i++)\r\nif (stat->nodesizes[i] != 0) {\r\nseq_printf(seq, " %u: %u", i, stat->nodesizes[i]);\r\npointers += (1<<i) * stat->nodesizes[i];\r\n}\r\nseq_putc(seq, '\n');\r\nseq_printf(seq, "\tPointers: %u\n", pointers);\r\nbytes += sizeof(struct key_vector *) * pointers;\r\nseq_printf(seq, "Null ptrs: %u\n", stat->nullpointers);\r\nseq_printf(seq, "Total size: %u kB\n", (bytes + 1023) / 1024);\r\n}\r\nstatic void trie_show_usage(struct seq_file *seq,\r\nconst struct trie_use_stats __percpu *stats)\r\n{\r\nstruct trie_use_stats s = { 0 };\r\nint cpu;\r\nfor_each_possible_cpu(cpu) {\r\nconst struct trie_use_stats *pcpu = per_cpu_ptr(stats, cpu);\r\ns.gets += pcpu->gets;\r\ns.backtrack += pcpu->backtrack;\r\ns.semantic_match_passed += pcpu->semantic_match_passed;\r\ns.semantic_match_miss += pcpu->semantic_match_miss;\r\ns.null_node_hit += pcpu->null_node_hit;\r\ns.resize_node_skipped += pcpu->resize_node_skipped;\r\n}\r\nseq_printf(seq, "\nCounters:\n---------\n");\r\nseq_printf(seq, "gets = %u\n", s.gets);\r\nseq_printf(seq, "backtracks = %u\n", s.backtrack);\r\nseq_printf(seq, "semantic match passed = %u\n",\r\ns.semantic_match_passed);\r\nseq_printf(seq, "semantic match miss = %u\n", s.semantic_match_miss);\r\nseq_printf(seq, "null node hit= %u\n", s.null_node_hit);\r\nseq_printf(seq, "skipped node resize = %u\n\n", s.resize_node_skipped);\r\n}\r\nstatic void fib_table_print(struct seq_file *seq, struct fib_table *tb)\r\n{\r\nif (tb->tb_id == RT_TABLE_LOCAL)\r\nseq_puts(seq, "Local:\n");\r\nelse if (tb->tb_id == RT_TABLE_MAIN)\r\nseq_puts(seq, "Main:\n");\r\nelse\r\nseq_printf(seq, "Id %d:\n", tb->tb_id);\r\n}\r\nstatic int fib_triestat_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct net *net = (struct net *)seq->private;\r\nunsigned int h;\r\nseq_printf(seq,\r\n"Basic info: size of leaf:"\r\n" %Zd bytes, size of tnode: %Zd bytes.\n",\r\nLEAF_SIZE, TNODE_SIZE(0));\r\nfor (h = 0; h < FIB_TABLE_HASHSZ; h++) {\r\nstruct hlist_head *head = &net->ipv4.fib_table_hash[h];\r\nstruct fib_table *tb;\r\nhlist_for_each_entry_rcu(tb, head, tb_hlist) {\r\nstruct trie *t = (struct trie *) tb->tb_data;\r\nstruct trie_stat stat;\r\nif (!t)\r\ncontinue;\r\nfib_table_print(seq, tb);\r\ntrie_collect_stats(t, &stat);\r\ntrie_show_stats(seq, &stat);\r\n#ifdef CONFIG_IP_FIB_TRIE_STATS\r\ntrie_show_usage(seq, t->stats);\r\n#endif\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int fib_triestat_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open_net(inode, file, fib_triestat_seq_show);\r\n}\r\nstatic struct key_vector *fib_trie_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct fib_trie_iter *iter = seq->private;\r\nstruct net *net = seq_file_net(seq);\r\nloff_t idx = 0;\r\nunsigned int h;\r\nfor (h = 0; h < FIB_TABLE_HASHSZ; h++) {\r\nstruct hlist_head *head = &net->ipv4.fib_table_hash[h];\r\nstruct fib_table *tb;\r\nhlist_for_each_entry_rcu(tb, head, tb_hlist) {\r\nstruct key_vector *n;\r\nfor (n = fib_trie_get_first(iter,\r\n(struct trie *) tb->tb_data);\r\nn; n = fib_trie_get_next(iter))\r\nif (pos == idx++) {\r\niter->tb = tb;\r\nreturn n;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *fib_trie_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU)\r\n{\r\nrcu_read_lock();\r\nreturn fib_trie_get_idx(seq, *pos);\r\n}\r\nstatic void *fib_trie_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct fib_trie_iter *iter = seq->private;\r\nstruct net *net = seq_file_net(seq);\r\nstruct fib_table *tb = iter->tb;\r\nstruct hlist_node *tb_node;\r\nunsigned int h;\r\nstruct key_vector *n;\r\n++*pos;\r\nn = fib_trie_get_next(iter);\r\nif (n)\r\nreturn n;\r\nh = tb->tb_id & (FIB_TABLE_HASHSZ - 1);\r\nwhile ((tb_node = rcu_dereference(hlist_next_rcu(&tb->tb_hlist)))) {\r\ntb = hlist_entry(tb_node, struct fib_table, tb_hlist);\r\nn = fib_trie_get_first(iter, (struct trie *) tb->tb_data);\r\nif (n)\r\ngoto found;\r\n}\r\nwhile (++h < FIB_TABLE_HASHSZ) {\r\nstruct hlist_head *head = &net->ipv4.fib_table_hash[h];\r\nhlist_for_each_entry_rcu(tb, head, tb_hlist) {\r\nn = fib_trie_get_first(iter, (struct trie *) tb->tb_data);\r\nif (n)\r\ngoto found;\r\n}\r\n}\r\nreturn NULL;\r\nfound:\r\niter->tb = tb;\r\nreturn n;\r\n}\r\nstatic void fib_trie_seq_stop(struct seq_file *seq, void *v)\r\n__releases(RCU)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic void seq_indent(struct seq_file *seq, int n)\r\n{\r\nwhile (n-- > 0)\r\nseq_puts(seq, " ");\r\n}\r\nstatic inline const char *rtn_scope(char *buf, size_t len, enum rt_scope_t s)\r\n{\r\nswitch (s) {\r\ncase RT_SCOPE_UNIVERSE: return "universe";\r\ncase RT_SCOPE_SITE: return "site";\r\ncase RT_SCOPE_LINK: return "link";\r\ncase RT_SCOPE_HOST: return "host";\r\ncase RT_SCOPE_NOWHERE: return "nowhere";\r\ndefault:\r\nsnprintf(buf, len, "scope=%d", s);\r\nreturn buf;\r\n}\r\n}\r\nstatic inline const char *rtn_type(char *buf, size_t len, unsigned int t)\r\n{\r\nif (t < __RTN_MAX && rtn_type_names[t])\r\nreturn rtn_type_names[t];\r\nsnprintf(buf, len, "type %u", t);\r\nreturn buf;\r\n}\r\nstatic int fib_trie_seq_show(struct seq_file *seq, void *v)\r\n{\r\nconst struct fib_trie_iter *iter = seq->private;\r\nstruct key_vector *n = v;\r\nif (IS_TRIE(node_parent_rcu(n)))\r\nfib_table_print(seq, iter->tb);\r\nif (IS_TNODE(n)) {\r\n__be32 prf = htonl(n->key);\r\nseq_indent(seq, iter->depth-1);\r\nseq_printf(seq, " +-- %pI4/%zu %u %u %u\n",\r\n&prf, KEYLENGTH - n->pos - n->bits, n->bits,\r\ntn_info(n)->full_children,\r\ntn_info(n)->empty_children);\r\n} else {\r\n__be32 val = htonl(n->key);\r\nstruct fib_alias *fa;\r\nseq_indent(seq, iter->depth);\r\nseq_printf(seq, " |-- %pI4\n", &val);\r\nhlist_for_each_entry_rcu(fa, &n->leaf, fa_list) {\r\nchar buf1[32], buf2[32];\r\nseq_indent(seq, iter->depth + 1);\r\nseq_printf(seq, " /%zu %s %s",\r\nKEYLENGTH - fa->fa_slen,\r\nrtn_scope(buf1, sizeof(buf1),\r\nfa->fa_info->fib_scope),\r\nrtn_type(buf2, sizeof(buf2),\r\nfa->fa_type));\r\nif (fa->fa_tos)\r\nseq_printf(seq, " tos=%d", fa->fa_tos);\r\nseq_putc(seq, '\n');\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int fib_trie_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &fib_trie_seq_ops,\r\nsizeof(struct fib_trie_iter));\r\n}\r\nstatic struct key_vector *fib_route_get_idx(struct fib_route_iter *iter,\r\nloff_t pos)\r\n{\r\nstruct fib_table *tb = iter->main_tb;\r\nstruct key_vector *l, **tp = &iter->tnode;\r\nstruct trie *t;\r\nt_key key;\r\nif (iter->pos > 0 && pos >= iter->pos) {\r\npos -= iter->pos;\r\nkey = iter->key;\r\n} else {\r\nt = (struct trie *)tb->tb_data;\r\niter->tnode = t->kv;\r\niter->pos = 0;\r\nkey = 0;\r\n}\r\nwhile ((l = leaf_walk_rcu(tp, key)) != NULL) {\r\nkey = l->key + 1;\r\niter->pos++;\r\nif (--pos <= 0)\r\nbreak;\r\nl = NULL;\r\nif (!key)\r\nbreak;\r\n}\r\nif (l)\r\niter->key = key;\r\nelse\r\niter->pos = 0;\r\nreturn l;\r\n}\r\nstatic void *fib_route_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU)\r\n{\r\nstruct fib_route_iter *iter = seq->private;\r\nstruct fib_table *tb;\r\nstruct trie *t;\r\nrcu_read_lock();\r\ntb = fib_get_table(seq_file_net(seq), RT_TABLE_MAIN);\r\nif (!tb)\r\nreturn NULL;\r\niter->main_tb = tb;\r\nif (*pos != 0)\r\nreturn fib_route_get_idx(iter, *pos);\r\nt = (struct trie *)tb->tb_data;\r\niter->tnode = t->kv;\r\niter->pos = 0;\r\niter->key = 0;\r\nreturn SEQ_START_TOKEN;\r\n}\r\nstatic void *fib_route_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct fib_route_iter *iter = seq->private;\r\nstruct key_vector *l = NULL;\r\nt_key key = iter->key;\r\n++*pos;\r\nif ((v == SEQ_START_TOKEN) || key)\r\nl = leaf_walk_rcu(&iter->tnode, key);\r\nif (l) {\r\niter->key = l->key + 1;\r\niter->pos++;\r\n} else {\r\niter->pos = 0;\r\n}\r\nreturn l;\r\n}\r\nstatic void fib_route_seq_stop(struct seq_file *seq, void *v)\r\n__releases(RCU)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic unsigned int fib_flag_trans(int type, __be32 mask, const struct fib_info *fi)\r\n{\r\nunsigned int flags = 0;\r\nif (type == RTN_UNREACHABLE || type == RTN_PROHIBIT)\r\nflags = RTF_REJECT;\r\nif (fi && fi->fib_nh->nh_gw)\r\nflags |= RTF_GATEWAY;\r\nif (mask == htonl(0xFFFFFFFF))\r\nflags |= RTF_HOST;\r\nflags |= RTF_UP;\r\nreturn flags;\r\n}\r\nstatic int fib_route_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct fib_route_iter *iter = seq->private;\r\nstruct fib_table *tb = iter->main_tb;\r\nstruct fib_alias *fa;\r\nstruct key_vector *l = v;\r\n__be32 prefix;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_printf(seq, "%-127s\n", "Iface\tDestination\tGateway "\r\n"\tFlags\tRefCnt\tUse\tMetric\tMask\t\tMTU"\r\n"\tWindow\tIRTT");\r\nreturn 0;\r\n}\r\nprefix = htonl(l->key);\r\nhlist_for_each_entry_rcu(fa, &l->leaf, fa_list) {\r\nconst struct fib_info *fi = fa->fa_info;\r\n__be32 mask = inet_make_mask(KEYLENGTH - fa->fa_slen);\r\nunsigned int flags = fib_flag_trans(fa->fa_type, mask, fi);\r\nif ((fa->fa_type == RTN_BROADCAST) ||\r\n(fa->fa_type == RTN_MULTICAST))\r\ncontinue;\r\nif (fa->tb_id != tb->tb_id)\r\ncontinue;\r\nseq_setwidth(seq, 127);\r\nif (fi)\r\nseq_printf(seq,\r\n"%s\t%08X\t%08X\t%04X\t%d\t%u\t"\r\n"%d\t%08X\t%d\t%u\t%u",\r\nfi->fib_dev ? fi->fib_dev->name : "*",\r\nprefix,\r\nfi->fib_nh->nh_gw, flags, 0, 0,\r\nfi->fib_priority,\r\nmask,\r\n(fi->fib_advmss ?\r\nfi->fib_advmss + 40 : 0),\r\nfi->fib_window,\r\nfi->fib_rtt >> 3);\r\nelse\r\nseq_printf(seq,\r\n"*\t%08X\t%08X\t%04X\t%d\t%u\t"\r\n"%d\t%08X\t%d\t%u\t%u",\r\nprefix, 0, flags, 0, 0, 0,\r\nmask, 0, 0, 0);\r\nseq_pad(seq, '\n');\r\n}\r\nreturn 0;\r\n}\r\nstatic int fib_route_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &fib_route_seq_ops,\r\nsizeof(struct fib_route_iter));\r\n}\r\nint __net_init fib_proc_init(struct net *net)\r\n{\r\nif (!proc_create("fib_trie", S_IRUGO, net->proc_net, &fib_trie_fops))\r\ngoto out1;\r\nif (!proc_create("fib_triestat", S_IRUGO, net->proc_net,\r\n&fib_triestat_fops))\r\ngoto out2;\r\nif (!proc_create("route", S_IRUGO, net->proc_net, &fib_route_fops))\r\ngoto out3;\r\nreturn 0;\r\nout3:\r\nremove_proc_entry("fib_triestat", net->proc_net);\r\nout2:\r\nremove_proc_entry("fib_trie", net->proc_net);\r\nout1:\r\nreturn -ENOMEM;\r\n}\r\nvoid __net_exit fib_proc_exit(struct net *net)\r\n{\r\nremove_proc_entry("fib_trie", net->proc_net);\r\nremove_proc_entry("fib_triestat", net->proc_net);\r\nremove_proc_entry("route", net->proc_net);\r\n}
