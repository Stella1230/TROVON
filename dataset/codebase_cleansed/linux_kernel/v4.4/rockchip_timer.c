static inline struct bc_timer *rk_timer(struct clock_event_device *ce)\r\n{\r\nreturn container_of(ce, struct bc_timer, ce);\r\n}\r\nstatic inline void __iomem *rk_base(struct clock_event_device *ce)\r\n{\r\nreturn rk_timer(ce)->base;\r\n}\r\nstatic inline void rk_timer_disable(struct clock_event_device *ce)\r\n{\r\nwritel_relaxed(TIMER_DISABLE, rk_base(ce) + TIMER_CONTROL_REG);\r\ndsb();\r\n}\r\nstatic inline void rk_timer_enable(struct clock_event_device *ce, u32 flags)\r\n{\r\nwritel_relaxed(TIMER_ENABLE | TIMER_INT_UNMASK | flags,\r\nrk_base(ce) + TIMER_CONTROL_REG);\r\ndsb();\r\n}\r\nstatic void rk_timer_update_counter(unsigned long cycles,\r\nstruct clock_event_device *ce)\r\n{\r\nwritel_relaxed(cycles, rk_base(ce) + TIMER_LOAD_COUNT0);\r\nwritel_relaxed(0, rk_base(ce) + TIMER_LOAD_COUNT1);\r\ndsb();\r\n}\r\nstatic void rk_timer_interrupt_clear(struct clock_event_device *ce)\r\n{\r\nwritel_relaxed(1, rk_base(ce) + TIMER_INT_STATUS);\r\ndsb();\r\n}\r\nstatic inline int rk_timer_set_next_event(unsigned long cycles,\r\nstruct clock_event_device *ce)\r\n{\r\nrk_timer_disable(ce);\r\nrk_timer_update_counter(cycles, ce);\r\nrk_timer_enable(ce, TIMER_MODE_USER_DEFINED_COUNT);\r\nreturn 0;\r\n}\r\nstatic int rk_timer_shutdown(struct clock_event_device *ce)\r\n{\r\nrk_timer_disable(ce);\r\nreturn 0;\r\n}\r\nstatic int rk_timer_set_periodic(struct clock_event_device *ce)\r\n{\r\nrk_timer_disable(ce);\r\nrk_timer_update_counter(rk_timer(ce)->freq / HZ - 1, ce);\r\nrk_timer_enable(ce, TIMER_MODE_FREE_RUNNING);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t rk_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *ce = dev_id;\r\nrk_timer_interrupt_clear(ce);\r\nif (clockevent_state_oneshot(ce))\r\nrk_timer_disable(ce);\r\nce->event_handler(ce);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void __init rk_timer_init(struct device_node *np)\r\n{\r\nstruct clock_event_device *ce = &bc_timer.ce;\r\nstruct clk *timer_clk;\r\nstruct clk *pclk;\r\nint ret, irq;\r\nbc_timer.base = of_iomap(np, 0);\r\nif (!bc_timer.base) {\r\npr_err("Failed to get base address for '%s'\n", TIMER_NAME);\r\nreturn;\r\n}\r\npclk = of_clk_get_by_name(np, "pclk");\r\nif (IS_ERR(pclk)) {\r\npr_err("Failed to get pclk for '%s'\n", TIMER_NAME);\r\nreturn;\r\n}\r\nif (clk_prepare_enable(pclk)) {\r\npr_err("Failed to enable pclk for '%s'\n", TIMER_NAME);\r\nreturn;\r\n}\r\ntimer_clk = of_clk_get_by_name(np, "timer");\r\nif (IS_ERR(timer_clk)) {\r\npr_err("Failed to get timer clock for '%s'\n", TIMER_NAME);\r\nreturn;\r\n}\r\nif (clk_prepare_enable(timer_clk)) {\r\npr_err("Failed to enable timer clock\n");\r\nreturn;\r\n}\r\nbc_timer.freq = clk_get_rate(timer_clk);\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq) {\r\npr_err("Failed to map interrupts for '%s'\n", TIMER_NAME);\r\nreturn;\r\n}\r\nce->name = TIMER_NAME;\r\nce->features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;\r\nce->set_next_event = rk_timer_set_next_event;\r\nce->set_state_shutdown = rk_timer_shutdown;\r\nce->set_state_periodic = rk_timer_set_periodic;\r\nce->irq = irq;\r\nce->cpumask = cpumask_of(0);\r\nce->rating = 250;\r\nrk_timer_interrupt_clear(ce);\r\nrk_timer_disable(ce);\r\nret = request_irq(irq, rk_timer_interrupt, IRQF_TIMER, TIMER_NAME, ce);\r\nif (ret) {\r\npr_err("Failed to initialize '%s': %d\n", TIMER_NAME, ret);\r\nreturn;\r\n}\r\nclockevents_config_and_register(ce, bc_timer.freq, 1, UINT_MAX);\r\n}
