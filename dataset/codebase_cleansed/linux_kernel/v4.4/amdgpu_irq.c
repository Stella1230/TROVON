static void amdgpu_hotplug_work_func(struct work_struct *work)\r\n{\r\nstruct amdgpu_device *adev = container_of(work, struct amdgpu_device,\r\nhotplug_work);\r\nstruct drm_device *dev = adev->ddev;\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nstruct drm_connector *connector;\r\nmutex_lock(&mode_config->mutex);\r\nif (mode_config->num_connector) {\r\nlist_for_each_entry(connector, &mode_config->connector_list, head)\r\namdgpu_connector_hotplug(connector);\r\n}\r\nmutex_unlock(&mode_config->mutex);\r\ndrm_helper_hpd_irq_event(dev);\r\n}\r\nstatic void amdgpu_irq_reset_work_func(struct work_struct *work)\r\n{\r\nstruct amdgpu_device *adev = container_of(work, struct amdgpu_device,\r\nreset_work);\r\namdgpu_gpu_reset(adev);\r\n}\r\nstatic void amdgpu_irq_disable_all(struct amdgpu_device *adev)\r\n{\r\nunsigned long irqflags;\r\nunsigned i, j;\r\nint r;\r\nspin_lock_irqsave(&adev->irq.lock, irqflags);\r\nfor (i = 0; i < AMDGPU_MAX_IRQ_SRC_ID; ++i) {\r\nstruct amdgpu_irq_src *src = adev->irq.sources[i];\r\nif (!src || !src->funcs->set || !src->num_types)\r\ncontinue;\r\nfor (j = 0; j < src->num_types; ++j) {\r\natomic_set(&src->enabled_types[j], 0);\r\nr = src->funcs->set(adev, src, j,\r\nAMDGPU_IRQ_STATE_DISABLE);\r\nif (r)\r\nDRM_ERROR("error disabling interrupt (%d)\n",\r\nr);\r\n}\r\n}\r\nspin_unlock_irqrestore(&adev->irq.lock, irqflags);\r\n}\r\nvoid amdgpu_irq_preinstall(struct drm_device *dev)\r\n{\r\nstruct amdgpu_device *adev = dev->dev_private;\r\namdgpu_irq_disable_all(adev);\r\namdgpu_ih_process(adev);\r\n}\r\nint amdgpu_irq_postinstall(struct drm_device *dev)\r\n{\r\ndev->max_vblank_count = 0x00ffffff;\r\nreturn 0;\r\n}\r\nvoid amdgpu_irq_uninstall(struct drm_device *dev)\r\n{\r\nstruct amdgpu_device *adev = dev->dev_private;\r\nif (adev == NULL) {\r\nreturn;\r\n}\r\namdgpu_irq_disable_all(adev);\r\n}\r\nirqreturn_t amdgpu_irq_handler(int irq, void *arg)\r\n{\r\nstruct drm_device *dev = (struct drm_device *) arg;\r\nstruct amdgpu_device *adev = dev->dev_private;\r\nirqreturn_t ret;\r\nret = amdgpu_ih_process(adev);\r\nif (ret == IRQ_HANDLED)\r\npm_runtime_mark_last_busy(dev->dev);\r\nreturn ret;\r\n}\r\nstatic bool amdgpu_msi_ok(struct amdgpu_device *adev)\r\n{\r\nif (amdgpu_msi == 1)\r\nreturn true;\r\nelse if (amdgpu_msi == 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nint amdgpu_irq_init(struct amdgpu_device *adev)\r\n{\r\nint r = 0;\r\nspin_lock_init(&adev->irq.lock);\r\nr = drm_vblank_init(adev->ddev, adev->mode_info.num_crtc);\r\nif (r) {\r\nreturn r;\r\n}\r\nadev->irq.msi_enabled = false;\r\nif (amdgpu_msi_ok(adev)) {\r\nint ret = pci_enable_msi(adev->pdev);\r\nif (!ret) {\r\nadev->irq.msi_enabled = true;\r\ndev_info(adev->dev, "amdgpu: using MSI.\n");\r\n}\r\n}\r\nINIT_WORK(&adev->hotplug_work, amdgpu_hotplug_work_func);\r\nINIT_WORK(&adev->reset_work, amdgpu_irq_reset_work_func);\r\nadev->irq.installed = true;\r\nr = drm_irq_install(adev->ddev, adev->ddev->pdev->irq);\r\nif (r) {\r\nadev->irq.installed = false;\r\nflush_work(&adev->hotplug_work);\r\nreturn r;\r\n}\r\nDRM_INFO("amdgpu: irq initialized.\n");\r\nreturn 0;\r\n}\r\nvoid amdgpu_irq_fini(struct amdgpu_device *adev)\r\n{\r\nunsigned i;\r\ndrm_vblank_cleanup(adev->ddev);\r\nif (adev->irq.installed) {\r\ndrm_irq_uninstall(adev->ddev);\r\nadev->irq.installed = false;\r\nif (adev->irq.msi_enabled)\r\npci_disable_msi(adev->pdev);\r\nflush_work(&adev->hotplug_work);\r\n}\r\nfor (i = 0; i < AMDGPU_MAX_IRQ_SRC_ID; ++i) {\r\nstruct amdgpu_irq_src *src = adev->irq.sources[i];\r\nif (!src)\r\ncontinue;\r\nkfree(src->enabled_types);\r\nsrc->enabled_types = NULL;\r\nif (src->data) {\r\nkfree(src->data);\r\nkfree(src);\r\nadev->irq.sources[i] = NULL;\r\n}\r\n}\r\n}\r\nint amdgpu_irq_add_id(struct amdgpu_device *adev, unsigned src_id,\r\nstruct amdgpu_irq_src *source)\r\n{\r\nif (src_id >= AMDGPU_MAX_IRQ_SRC_ID)\r\nreturn -EINVAL;\r\nif (adev->irq.sources[src_id] != NULL)\r\nreturn -EINVAL;\r\nif (!source->funcs)\r\nreturn -EINVAL;\r\nif (source->num_types && !source->enabled_types) {\r\natomic_t *types;\r\ntypes = kcalloc(source->num_types, sizeof(atomic_t),\r\nGFP_KERNEL);\r\nif (!types)\r\nreturn -ENOMEM;\r\nsource->enabled_types = types;\r\n}\r\nadev->irq.sources[src_id] = source;\r\nreturn 0;\r\n}\r\nvoid amdgpu_irq_dispatch(struct amdgpu_device *adev,\r\nstruct amdgpu_iv_entry *entry)\r\n{\r\nunsigned src_id = entry->src_id;\r\nstruct amdgpu_irq_src *src;\r\nint r;\r\nif (src_id >= AMDGPU_MAX_IRQ_SRC_ID) {\r\nDRM_DEBUG("Invalid src_id in IV: %d\n", src_id);\r\nreturn;\r\n}\r\nsrc = adev->irq.sources[src_id];\r\nif (!src) {\r\nDRM_DEBUG("Unhandled interrupt src_id: %d\n", src_id);\r\nreturn;\r\n}\r\nr = src->funcs->process(adev, src, entry);\r\nif (r)\r\nDRM_ERROR("error processing interrupt (%d)\n", r);\r\n}\r\nint amdgpu_irq_update(struct amdgpu_device *adev,\r\nstruct amdgpu_irq_src *src, unsigned type)\r\n{\r\nunsigned long irqflags;\r\nenum amdgpu_interrupt_state state;\r\nint r;\r\nspin_lock_irqsave(&adev->irq.lock, irqflags);\r\nif (amdgpu_irq_enabled(adev, src, type))\r\nstate = AMDGPU_IRQ_STATE_ENABLE;\r\nelse\r\nstate = AMDGPU_IRQ_STATE_DISABLE;\r\nr = src->funcs->set(adev, src, type, state);\r\nspin_unlock_irqrestore(&adev->irq.lock, irqflags);\r\nreturn r;\r\n}\r\nint amdgpu_irq_get(struct amdgpu_device *adev, struct amdgpu_irq_src *src,\r\nunsigned type)\r\n{\r\nif (!adev->ddev->irq_enabled)\r\nreturn -ENOENT;\r\nif (type >= src->num_types)\r\nreturn -EINVAL;\r\nif (!src->enabled_types || !src->funcs->set)\r\nreturn -EINVAL;\r\nif (atomic_inc_return(&src->enabled_types[type]) == 1)\r\nreturn amdgpu_irq_update(adev, src, type);\r\nreturn 0;\r\n}\r\nbool amdgpu_irq_get_delayed(struct amdgpu_device *adev,\r\nstruct amdgpu_irq_src *src,\r\nunsigned type)\r\n{\r\nif ((type >= src->num_types) || !src->enabled_types)\r\nreturn false;\r\nreturn atomic_inc_return(&src->enabled_types[type]) == 1;\r\n}\r\nint amdgpu_irq_put(struct amdgpu_device *adev, struct amdgpu_irq_src *src,\r\nunsigned type)\r\n{\r\nif (!adev->ddev->irq_enabled)\r\nreturn -ENOENT;\r\nif (type >= src->num_types)\r\nreturn -EINVAL;\r\nif (!src->enabled_types || !src->funcs->set)\r\nreturn -EINVAL;\r\nif (atomic_dec_and_test(&src->enabled_types[type]))\r\nreturn amdgpu_irq_update(adev, src, type);\r\nreturn 0;\r\n}\r\nbool amdgpu_irq_enabled(struct amdgpu_device *adev, struct amdgpu_irq_src *src,\r\nunsigned type)\r\n{\r\nif (!adev->ddev->irq_enabled)\r\nreturn false;\r\nif (type >= src->num_types)\r\nreturn false;\r\nif (!src->enabled_types || !src->funcs->set)\r\nreturn false;\r\nreturn !!atomic_read(&src->enabled_types[type]);\r\n}
