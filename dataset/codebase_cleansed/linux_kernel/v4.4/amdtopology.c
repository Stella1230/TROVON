static __init int find_northbridge(void)\r\n{\r\nint num;\r\nfor (num = 0; num < 32; num++) {\r\nu32 header;\r\nheader = read_pci_config(0, num, 0, 0x00);\r\nif (header != (PCI_VENDOR_ID_AMD | (0x1100<<16)) &&\r\nheader != (PCI_VENDOR_ID_AMD | (0x1200<<16)) &&\r\nheader != (PCI_VENDOR_ID_AMD | (0x1300<<16)))\r\ncontinue;\r\nheader = read_pci_config(0, num, 1, 0x00);\r\nif (header != (PCI_VENDOR_ID_AMD | (0x1101<<16)) &&\r\nheader != (PCI_VENDOR_ID_AMD | (0x1201<<16)) &&\r\nheader != (PCI_VENDOR_ID_AMD | (0x1301<<16)))\r\ncontinue;\r\nreturn num;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic __init void early_get_boot_cpu_id(void)\r\n{\r\n#ifdef CONFIG_X86_MPPARSE\r\nif (smp_found_config)\r\nearly_get_smp_config();\r\n#endif\r\n}\r\nint __init amd_numa_init(void)\r\n{\r\nu64 start = PFN_PHYS(0);\r\nu64 end = PFN_PHYS(max_pfn);\r\nunsigned numnodes;\r\nu64 prevbase;\r\nint i, j, nb;\r\nu32 nodeid, reg;\r\nunsigned int bits, cores, apicid_base;\r\nif (!early_pci_allowed())\r\nreturn -EINVAL;\r\nnb = find_northbridge();\r\nif (nb < 0)\r\nreturn nb;\r\npr_info("Scanning NUMA topology in Northbridge %d\n", nb);\r\nreg = read_pci_config(0, nb, 0, 0x60);\r\nnumnodes = ((reg >> 4) & 0xF) + 1;\r\nif (numnodes <= 1)\r\nreturn -ENOENT;\r\npr_info("Number of physical nodes %d\n", numnodes);\r\nprevbase = 0;\r\nfor (i = 0; i < 8; i++) {\r\nu64 base, limit;\r\nbase = read_pci_config(0, nb, 1, 0x40 + i*8);\r\nlimit = read_pci_config(0, nb, 1, 0x44 + i*8);\r\nnodeids[i] = nodeid = limit & 7;\r\nif ((base & 3) == 0) {\r\nif (i < numnodes)\r\npr_info("Skipping disabled node %d\n", i);\r\ncontinue;\r\n}\r\nif (nodeid >= numnodes) {\r\npr_info("Ignoring excess node %d (%Lx:%Lx)\n", nodeid,\r\nbase, limit);\r\ncontinue;\r\n}\r\nif (!limit) {\r\npr_info("Skipping node entry %d (base %Lx)\n",\r\ni, base);\r\ncontinue;\r\n}\r\nif ((base >> 8) & 3 || (limit >> 8) & 3) {\r\npr_err("Node %d using interleaving mode %Lx/%Lx\n",\r\nnodeid, (base >> 8) & 3, (limit >> 8) & 3);\r\nreturn -EINVAL;\r\n}\r\nif (node_isset(nodeid, numa_nodes_parsed)) {\r\npr_info("Node %d already present, skipping\n",\r\nnodeid);\r\ncontinue;\r\n}\r\nlimit >>= 16;\r\nlimit++;\r\nlimit <<= 24;\r\nif (limit > end)\r\nlimit = end;\r\nif (limit <= base)\r\ncontinue;\r\nbase >>= 16;\r\nbase <<= 24;\r\nif (base < start)\r\nbase = start;\r\nif (limit > end)\r\nlimit = end;\r\nif (limit == base) {\r\npr_err("Empty node %d\n", nodeid);\r\ncontinue;\r\n}\r\nif (limit < base) {\r\npr_err("Node %d bogus settings %Lx-%Lx.\n",\r\nnodeid, base, limit);\r\ncontinue;\r\n}\r\nif (prevbase > base) {\r\npr_err("Node map not sorted %Lx,%Lx\n",\r\nprevbase, base);\r\nreturn -EINVAL;\r\n}\r\npr_info("Node %d MemBase %016Lx Limit %016Lx\n",\r\nnodeid, base, limit);\r\nprevbase = base;\r\nnuma_add_memblk(nodeid, base, limit);\r\nnode_set(nodeid, numa_nodes_parsed);\r\n}\r\nif (!nodes_weight(numa_nodes_parsed))\r\nreturn -ENOENT;\r\nbits = boot_cpu_data.x86_coreid_bits;\r\ncores = 1 << bits;\r\napicid_base = 0;\r\nearly_get_boot_cpu_id();\r\nif (boot_cpu_physical_apicid > 0) {\r\npr_info("BSP APIC ID: %02x\n", boot_cpu_physical_apicid);\r\napicid_base = boot_cpu_physical_apicid;\r\n}\r\nfor_each_node_mask(i, numa_nodes_parsed)\r\nfor (j = apicid_base; j < cores + apicid_base; j++)\r\nset_apicid_to_node((i << bits) + j, i);\r\nreturn 0;\r\n}
