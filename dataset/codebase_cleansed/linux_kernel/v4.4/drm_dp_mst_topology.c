static u8 drm_dp_msg_header_crc4(const uint8_t *data, size_t num_nibbles)\r\n{\r\nu8 bitmask = 0x80;\r\nu8 bitshift = 7;\r\nu8 array_index = 0;\r\nint number_of_bits = num_nibbles * 4;\r\nu8 remainder = 0;\r\nwhile (number_of_bits != 0) {\r\nnumber_of_bits--;\r\nremainder <<= 1;\r\nremainder |= (data[array_index] & bitmask) >> bitshift;\r\nbitmask >>= 1;\r\nbitshift--;\r\nif (bitmask == 0) {\r\nbitmask = 0x80;\r\nbitshift = 7;\r\narray_index++;\r\n}\r\nif ((remainder & 0x10) == 0x10)\r\nremainder ^= 0x13;\r\n}\r\nnumber_of_bits = 4;\r\nwhile (number_of_bits != 0) {\r\nnumber_of_bits--;\r\nremainder <<= 1;\r\nif ((remainder & 0x10) != 0)\r\nremainder ^= 0x13;\r\n}\r\nreturn remainder;\r\n}\r\nstatic u8 drm_dp_msg_data_crc4(const uint8_t *data, u8 number_of_bytes)\r\n{\r\nu8 bitmask = 0x80;\r\nu8 bitshift = 7;\r\nu8 array_index = 0;\r\nint number_of_bits = number_of_bytes * 8;\r\nu16 remainder = 0;\r\nwhile (number_of_bits != 0) {\r\nnumber_of_bits--;\r\nremainder <<= 1;\r\nremainder |= (data[array_index] & bitmask) >> bitshift;\r\nbitmask >>= 1;\r\nbitshift--;\r\nif (bitmask == 0) {\r\nbitmask = 0x80;\r\nbitshift = 7;\r\narray_index++;\r\n}\r\nif ((remainder & 0x100) == 0x100)\r\nremainder ^= 0xd5;\r\n}\r\nnumber_of_bits = 8;\r\nwhile (number_of_bits != 0) {\r\nnumber_of_bits--;\r\nremainder <<= 1;\r\nif ((remainder & 0x100) != 0)\r\nremainder ^= 0xd5;\r\n}\r\nreturn remainder & 0xff;\r\n}\r\nstatic inline u8 drm_dp_calc_sb_hdr_size(struct drm_dp_sideband_msg_hdr *hdr)\r\n{\r\nu8 size = 3;\r\nsize += (hdr->lct / 2);\r\nreturn size;\r\n}\r\nstatic void drm_dp_encode_sideband_msg_hdr(struct drm_dp_sideband_msg_hdr *hdr,\r\nu8 *buf, int *len)\r\n{\r\nint idx = 0;\r\nint i;\r\nu8 crc4;\r\nbuf[idx++] = ((hdr->lct & 0xf) << 4) | (hdr->lcr & 0xf);\r\nfor (i = 0; i < (hdr->lct / 2); i++)\r\nbuf[idx++] = hdr->rad[i];\r\nbuf[idx++] = (hdr->broadcast << 7) | (hdr->path_msg << 6) |\r\n(hdr->msg_len & 0x3f);\r\nbuf[idx++] = (hdr->somt << 7) | (hdr->eomt << 6) | (hdr->seqno << 4);\r\ncrc4 = drm_dp_msg_header_crc4(buf, (idx * 2) - 1);\r\nbuf[idx - 1] |= (crc4 & 0xf);\r\n*len = idx;\r\n}\r\nstatic bool drm_dp_decode_sideband_msg_hdr(struct drm_dp_sideband_msg_hdr *hdr,\r\nu8 *buf, int buflen, u8 *hdrlen)\r\n{\r\nu8 crc4;\r\nu8 len;\r\nint i;\r\nu8 idx;\r\nif (buf[0] == 0)\r\nreturn false;\r\nlen = 3;\r\nlen += ((buf[0] & 0xf0) >> 4) / 2;\r\nif (len > buflen)\r\nreturn false;\r\ncrc4 = drm_dp_msg_header_crc4(buf, (len * 2) - 1);\r\nif ((crc4 & 0xf) != (buf[len - 1] & 0xf)) {\r\nDRM_DEBUG_KMS("crc4 mismatch 0x%x 0x%x\n", crc4, buf[len - 1]);\r\nreturn false;\r\n}\r\nhdr->lct = (buf[0] & 0xf0) >> 4;\r\nhdr->lcr = (buf[0] & 0xf);\r\nidx = 1;\r\nfor (i = 0; i < (hdr->lct / 2); i++)\r\nhdr->rad[i] = buf[idx++];\r\nhdr->broadcast = (buf[idx] >> 7) & 0x1;\r\nhdr->path_msg = (buf[idx] >> 6) & 0x1;\r\nhdr->msg_len = buf[idx] & 0x3f;\r\nidx++;\r\nhdr->somt = (buf[idx] >> 7) & 0x1;\r\nhdr->eomt = (buf[idx] >> 6) & 0x1;\r\nhdr->seqno = (buf[idx] >> 4) & 0x1;\r\nidx++;\r\n*hdrlen = idx;\r\nreturn true;\r\n}\r\nstatic void drm_dp_encode_sideband_req(struct drm_dp_sideband_msg_req_body *req,\r\nstruct drm_dp_sideband_msg_tx *raw)\r\n{\r\nint idx = 0;\r\nint i;\r\nu8 *buf = raw->msg;\r\nbuf[idx++] = req->req_type & 0x7f;\r\nswitch (req->req_type) {\r\ncase DP_ENUM_PATH_RESOURCES:\r\nbuf[idx] = (req->u.port_num.port_number & 0xf) << 4;\r\nidx++;\r\nbreak;\r\ncase DP_ALLOCATE_PAYLOAD:\r\nbuf[idx] = (req->u.allocate_payload.port_number & 0xf) << 4 |\r\n(req->u.allocate_payload.number_sdp_streams & 0xf);\r\nidx++;\r\nbuf[idx] = (req->u.allocate_payload.vcpi & 0x7f);\r\nidx++;\r\nbuf[idx] = (req->u.allocate_payload.pbn >> 8);\r\nidx++;\r\nbuf[idx] = (req->u.allocate_payload.pbn & 0xff);\r\nidx++;\r\nfor (i = 0; i < req->u.allocate_payload.number_sdp_streams / 2; i++) {\r\nbuf[idx] = ((req->u.allocate_payload.sdp_stream_sink[i * 2] & 0xf) << 4) |\r\n(req->u.allocate_payload.sdp_stream_sink[i * 2 + 1] & 0xf);\r\nidx++;\r\n}\r\nif (req->u.allocate_payload.number_sdp_streams & 1) {\r\ni = req->u.allocate_payload.number_sdp_streams - 1;\r\nbuf[idx] = (req->u.allocate_payload.sdp_stream_sink[i] & 0xf) << 4;\r\nidx++;\r\n}\r\nbreak;\r\ncase DP_QUERY_PAYLOAD:\r\nbuf[idx] = (req->u.query_payload.port_number & 0xf) << 4;\r\nidx++;\r\nbuf[idx] = (req->u.query_payload.vcpi & 0x7f);\r\nidx++;\r\nbreak;\r\ncase DP_REMOTE_DPCD_READ:\r\nbuf[idx] = (req->u.dpcd_read.port_number & 0xf) << 4;\r\nbuf[idx] |= ((req->u.dpcd_read.dpcd_address & 0xf0000) >> 16) & 0xf;\r\nidx++;\r\nbuf[idx] = (req->u.dpcd_read.dpcd_address & 0xff00) >> 8;\r\nidx++;\r\nbuf[idx] = (req->u.dpcd_read.dpcd_address & 0xff);\r\nidx++;\r\nbuf[idx] = (req->u.dpcd_read.num_bytes);\r\nidx++;\r\nbreak;\r\ncase DP_REMOTE_DPCD_WRITE:\r\nbuf[idx] = (req->u.dpcd_write.port_number & 0xf) << 4;\r\nbuf[idx] |= ((req->u.dpcd_write.dpcd_address & 0xf0000) >> 16) & 0xf;\r\nidx++;\r\nbuf[idx] = (req->u.dpcd_write.dpcd_address & 0xff00) >> 8;\r\nidx++;\r\nbuf[idx] = (req->u.dpcd_write.dpcd_address & 0xff);\r\nidx++;\r\nbuf[idx] = (req->u.dpcd_write.num_bytes);\r\nidx++;\r\nmemcpy(&buf[idx], req->u.dpcd_write.bytes, req->u.dpcd_write.num_bytes);\r\nidx += req->u.dpcd_write.num_bytes;\r\nbreak;\r\ncase DP_REMOTE_I2C_READ:\r\nbuf[idx] = (req->u.i2c_read.port_number & 0xf) << 4;\r\nbuf[idx] |= (req->u.i2c_read.num_transactions & 0x3);\r\nidx++;\r\nfor (i = 0; i < (req->u.i2c_read.num_transactions & 0x3); i++) {\r\nbuf[idx] = req->u.i2c_read.transactions[i].i2c_dev_id & 0x7f;\r\nidx++;\r\nbuf[idx] = req->u.i2c_read.transactions[i].num_bytes;\r\nidx++;\r\nmemcpy(&buf[idx], req->u.i2c_read.transactions[i].bytes, req->u.i2c_read.transactions[i].num_bytes);\r\nidx += req->u.i2c_read.transactions[i].num_bytes;\r\nbuf[idx] = (req->u.i2c_read.transactions[i].no_stop_bit & 0x1) << 5;\r\nbuf[idx] |= (req->u.i2c_read.transactions[i].i2c_transaction_delay & 0xf);\r\nidx++;\r\n}\r\nbuf[idx] = (req->u.i2c_read.read_i2c_device_id) & 0x7f;\r\nidx++;\r\nbuf[idx] = (req->u.i2c_read.num_bytes_read);\r\nidx++;\r\nbreak;\r\ncase DP_REMOTE_I2C_WRITE:\r\nbuf[idx] = (req->u.i2c_write.port_number & 0xf) << 4;\r\nidx++;\r\nbuf[idx] = (req->u.i2c_write.write_i2c_device_id) & 0x7f;\r\nidx++;\r\nbuf[idx] = (req->u.i2c_write.num_bytes);\r\nidx++;\r\nmemcpy(&buf[idx], req->u.i2c_write.bytes, req->u.i2c_write.num_bytes);\r\nidx += req->u.i2c_write.num_bytes;\r\nbreak;\r\n}\r\nraw->cur_len = idx;\r\n}\r\nstatic void drm_dp_crc_sideband_chunk_req(u8 *msg, u8 len)\r\n{\r\nu8 crc4;\r\ncrc4 = drm_dp_msg_data_crc4(msg, len);\r\nmsg[len] = crc4;\r\n}\r\nstatic void drm_dp_encode_sideband_reply(struct drm_dp_sideband_msg_reply_body *rep,\r\nstruct drm_dp_sideband_msg_tx *raw)\r\n{\r\nint idx = 0;\r\nu8 *buf = raw->msg;\r\nbuf[idx++] = (rep->reply_type & 0x1) << 7 | (rep->req_type & 0x7f);\r\nraw->cur_len = idx;\r\n}\r\nstatic bool drm_dp_sideband_msg_build(struct drm_dp_sideband_msg_rx *msg,\r\nu8 *replybuf, u8 replybuflen, bool hdr)\r\n{\r\nint ret;\r\nu8 crc4;\r\nif (hdr) {\r\nu8 hdrlen;\r\nstruct drm_dp_sideband_msg_hdr recv_hdr;\r\nret = drm_dp_decode_sideband_msg_hdr(&recv_hdr, replybuf, replybuflen, &hdrlen);\r\nif (ret == false) {\r\nprint_hex_dump(KERN_DEBUG, "failed hdr", DUMP_PREFIX_NONE, 16, 1, replybuf, replybuflen, false);\r\nreturn false;\r\n}\r\nmsg->curchunk_len = recv_hdr.msg_len;\r\nmsg->curchunk_hdrlen = hdrlen;\r\nif (recv_hdr.somt && msg->have_somt)\r\nreturn false;\r\nif (recv_hdr.somt) {\r\nmemcpy(&msg->initial_hdr, &recv_hdr, sizeof(struct drm_dp_sideband_msg_hdr));\r\nmsg->have_somt = true;\r\n}\r\nif (recv_hdr.eomt)\r\nmsg->have_eomt = true;\r\nmsg->curchunk_idx = min(msg->curchunk_len, (u8)(replybuflen - hdrlen));\r\nmemcpy(&msg->chunk[0], replybuf + hdrlen, msg->curchunk_idx);\r\n} else {\r\nmemcpy(&msg->chunk[msg->curchunk_idx], replybuf, replybuflen);\r\nmsg->curchunk_idx += replybuflen;\r\n}\r\nif (msg->curchunk_idx >= msg->curchunk_len) {\r\ncrc4 = drm_dp_msg_data_crc4(msg->chunk, msg->curchunk_len - 1);\r\nmemcpy(&msg->msg[msg->curlen], msg->chunk, msg->curchunk_len - 1);\r\nmsg->curlen += msg->curchunk_len - 1;\r\n}\r\nreturn true;\r\n}\r\nstatic bool drm_dp_sideband_parse_link_address(struct drm_dp_sideband_msg_rx *raw,\r\nstruct drm_dp_sideband_msg_reply_body *repmsg)\r\n{\r\nint idx = 1;\r\nint i;\r\nmemcpy(repmsg->u.link_addr.guid, &raw->msg[idx], 16);\r\nidx += 16;\r\nrepmsg->u.link_addr.nports = raw->msg[idx] & 0xf;\r\nidx++;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nfor (i = 0; i < repmsg->u.link_addr.nports; i++) {\r\nif (raw->msg[idx] & 0x80)\r\nrepmsg->u.link_addr.ports[i].input_port = 1;\r\nrepmsg->u.link_addr.ports[i].peer_device_type = (raw->msg[idx] >> 4) & 0x7;\r\nrepmsg->u.link_addr.ports[i].port_number = (raw->msg[idx] & 0xf);\r\nidx++;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nrepmsg->u.link_addr.ports[i].mcs = (raw->msg[idx] >> 7) & 0x1;\r\nrepmsg->u.link_addr.ports[i].ddps = (raw->msg[idx] >> 6) & 0x1;\r\nif (repmsg->u.link_addr.ports[i].input_port == 0)\r\nrepmsg->u.link_addr.ports[i].legacy_device_plug_status = (raw->msg[idx] >> 5) & 0x1;\r\nidx++;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nif (repmsg->u.link_addr.ports[i].input_port == 0) {\r\nrepmsg->u.link_addr.ports[i].dpcd_revision = (raw->msg[idx]);\r\nidx++;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nmemcpy(repmsg->u.link_addr.ports[i].peer_guid, &raw->msg[idx], 16);\r\nidx += 16;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nrepmsg->u.link_addr.ports[i].num_sdp_streams = (raw->msg[idx] >> 4) & 0xf;\r\nrepmsg->u.link_addr.ports[i].num_sdp_stream_sinks = (raw->msg[idx] & 0xf);\r\nidx++;\r\n}\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\n}\r\nreturn true;\r\nfail_len:\r\nDRM_DEBUG_KMS("link address reply parse length fail %d %d\n", idx, raw->curlen);\r\nreturn false;\r\n}\r\nstatic bool drm_dp_sideband_parse_remote_dpcd_read(struct drm_dp_sideband_msg_rx *raw,\r\nstruct drm_dp_sideband_msg_reply_body *repmsg)\r\n{\r\nint idx = 1;\r\nrepmsg->u.remote_dpcd_read_ack.port_number = raw->msg[idx] & 0xf;\r\nidx++;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nrepmsg->u.remote_dpcd_read_ack.num_bytes = raw->msg[idx];\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nmemcpy(repmsg->u.remote_dpcd_read_ack.bytes, &raw->msg[idx], repmsg->u.remote_dpcd_read_ack.num_bytes);\r\nreturn true;\r\nfail_len:\r\nDRM_DEBUG_KMS("link address reply parse length fail %d %d\n", idx, raw->curlen);\r\nreturn false;\r\n}\r\nstatic bool drm_dp_sideband_parse_remote_dpcd_write(struct drm_dp_sideband_msg_rx *raw,\r\nstruct drm_dp_sideband_msg_reply_body *repmsg)\r\n{\r\nint idx = 1;\r\nrepmsg->u.remote_dpcd_write_ack.port_number = raw->msg[idx] & 0xf;\r\nidx++;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nreturn true;\r\nfail_len:\r\nDRM_DEBUG_KMS("parse length fail %d %d\n", idx, raw->curlen);\r\nreturn false;\r\n}\r\nstatic bool drm_dp_sideband_parse_remote_i2c_read_ack(struct drm_dp_sideband_msg_rx *raw,\r\nstruct drm_dp_sideband_msg_reply_body *repmsg)\r\n{\r\nint idx = 1;\r\nrepmsg->u.remote_i2c_read_ack.port_number = (raw->msg[idx] & 0xf);\r\nidx++;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nrepmsg->u.remote_i2c_read_ack.num_bytes = raw->msg[idx];\r\nidx++;\r\nmemcpy(repmsg->u.remote_i2c_read_ack.bytes, &raw->msg[idx], repmsg->u.remote_i2c_read_ack.num_bytes);\r\nreturn true;\r\nfail_len:\r\nDRM_DEBUG_KMS("remote i2c reply parse length fail %d %d\n", idx, raw->curlen);\r\nreturn false;\r\n}\r\nstatic bool drm_dp_sideband_parse_enum_path_resources_ack(struct drm_dp_sideband_msg_rx *raw,\r\nstruct drm_dp_sideband_msg_reply_body *repmsg)\r\n{\r\nint idx = 1;\r\nrepmsg->u.path_resources.port_number = (raw->msg[idx] >> 4) & 0xf;\r\nidx++;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nrepmsg->u.path_resources.full_payload_bw_number = (raw->msg[idx] << 8) | (raw->msg[idx+1]);\r\nidx += 2;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nrepmsg->u.path_resources.avail_payload_bw_number = (raw->msg[idx] << 8) | (raw->msg[idx+1]);\r\nidx += 2;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nreturn true;\r\nfail_len:\r\nDRM_DEBUG_KMS("enum resource parse length fail %d %d\n", idx, raw->curlen);\r\nreturn false;\r\n}\r\nstatic bool drm_dp_sideband_parse_allocate_payload_ack(struct drm_dp_sideband_msg_rx *raw,\r\nstruct drm_dp_sideband_msg_reply_body *repmsg)\r\n{\r\nint idx = 1;\r\nrepmsg->u.allocate_payload.port_number = (raw->msg[idx] >> 4) & 0xf;\r\nidx++;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nrepmsg->u.allocate_payload.vcpi = raw->msg[idx];\r\nidx++;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nrepmsg->u.allocate_payload.allocated_pbn = (raw->msg[idx] << 8) | (raw->msg[idx+1]);\r\nidx += 2;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nreturn true;\r\nfail_len:\r\nDRM_DEBUG_KMS("allocate payload parse length fail %d %d\n", idx, raw->curlen);\r\nreturn false;\r\n}\r\nstatic bool drm_dp_sideband_parse_query_payload_ack(struct drm_dp_sideband_msg_rx *raw,\r\nstruct drm_dp_sideband_msg_reply_body *repmsg)\r\n{\r\nint idx = 1;\r\nrepmsg->u.query_payload.port_number = (raw->msg[idx] >> 4) & 0xf;\r\nidx++;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nrepmsg->u.query_payload.allocated_pbn = (raw->msg[idx] << 8) | (raw->msg[idx + 1]);\r\nidx += 2;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nreturn true;\r\nfail_len:\r\nDRM_DEBUG_KMS("query payload parse length fail %d %d\n", idx, raw->curlen);\r\nreturn false;\r\n}\r\nstatic bool drm_dp_sideband_parse_reply(struct drm_dp_sideband_msg_rx *raw,\r\nstruct drm_dp_sideband_msg_reply_body *msg)\r\n{\r\nmemset(msg, 0, sizeof(*msg));\r\nmsg->reply_type = (raw->msg[0] & 0x80) >> 7;\r\nmsg->req_type = (raw->msg[0] & 0x7f);\r\nif (msg->reply_type) {\r\nmemcpy(msg->u.nak.guid, &raw->msg[1], 16);\r\nmsg->u.nak.reason = raw->msg[17];\r\nmsg->u.nak.nak_data = raw->msg[18];\r\nreturn false;\r\n}\r\nswitch (msg->req_type) {\r\ncase DP_LINK_ADDRESS:\r\nreturn drm_dp_sideband_parse_link_address(raw, msg);\r\ncase DP_QUERY_PAYLOAD:\r\nreturn drm_dp_sideband_parse_query_payload_ack(raw, msg);\r\ncase DP_REMOTE_DPCD_READ:\r\nreturn drm_dp_sideband_parse_remote_dpcd_read(raw, msg);\r\ncase DP_REMOTE_DPCD_WRITE:\r\nreturn drm_dp_sideband_parse_remote_dpcd_write(raw, msg);\r\ncase DP_REMOTE_I2C_READ:\r\nreturn drm_dp_sideband_parse_remote_i2c_read_ack(raw, msg);\r\ncase DP_ENUM_PATH_RESOURCES:\r\nreturn drm_dp_sideband_parse_enum_path_resources_ack(raw, msg);\r\ncase DP_ALLOCATE_PAYLOAD:\r\nreturn drm_dp_sideband_parse_allocate_payload_ack(raw, msg);\r\ndefault:\r\nDRM_ERROR("Got unknown reply 0x%02x\n", msg->req_type);\r\nreturn false;\r\n}\r\n}\r\nstatic bool drm_dp_sideband_parse_connection_status_notify(struct drm_dp_sideband_msg_rx *raw,\r\nstruct drm_dp_sideband_msg_req_body *msg)\r\n{\r\nint idx = 1;\r\nmsg->u.conn_stat.port_number = (raw->msg[idx] & 0xf0) >> 4;\r\nidx++;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nmemcpy(msg->u.conn_stat.guid, &raw->msg[idx], 16);\r\nidx += 16;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nmsg->u.conn_stat.legacy_device_plug_status = (raw->msg[idx] >> 6) & 0x1;\r\nmsg->u.conn_stat.displayport_device_plug_status = (raw->msg[idx] >> 5) & 0x1;\r\nmsg->u.conn_stat.message_capability_status = (raw->msg[idx] >> 4) & 0x1;\r\nmsg->u.conn_stat.input_port = (raw->msg[idx] >> 3) & 0x1;\r\nmsg->u.conn_stat.peer_device_type = (raw->msg[idx] & 0x7);\r\nidx++;\r\nreturn true;\r\nfail_len:\r\nDRM_DEBUG_KMS("connection status reply parse length fail %d %d\n", idx, raw->curlen);\r\nreturn false;\r\n}\r\nstatic bool drm_dp_sideband_parse_resource_status_notify(struct drm_dp_sideband_msg_rx *raw,\r\nstruct drm_dp_sideband_msg_req_body *msg)\r\n{\r\nint idx = 1;\r\nmsg->u.resource_stat.port_number = (raw->msg[idx] & 0xf0) >> 4;\r\nidx++;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nmemcpy(msg->u.resource_stat.guid, &raw->msg[idx], 16);\r\nidx += 16;\r\nif (idx > raw->curlen)\r\ngoto fail_len;\r\nmsg->u.resource_stat.available_pbn = (raw->msg[idx] << 8) | (raw->msg[idx + 1]);\r\nidx++;\r\nreturn true;\r\nfail_len:\r\nDRM_DEBUG_KMS("resource status reply parse length fail %d %d\n", idx, raw->curlen);\r\nreturn false;\r\n}\r\nstatic bool drm_dp_sideband_parse_req(struct drm_dp_sideband_msg_rx *raw,\r\nstruct drm_dp_sideband_msg_req_body *msg)\r\n{\r\nmemset(msg, 0, sizeof(*msg));\r\nmsg->req_type = (raw->msg[0] & 0x7f);\r\nswitch (msg->req_type) {\r\ncase DP_CONNECTION_STATUS_NOTIFY:\r\nreturn drm_dp_sideband_parse_connection_status_notify(raw, msg);\r\ncase DP_RESOURCE_STATUS_NOTIFY:\r\nreturn drm_dp_sideband_parse_resource_status_notify(raw, msg);\r\ndefault:\r\nDRM_ERROR("Got unknown request 0x%02x\n", msg->req_type);\r\nreturn false;\r\n}\r\n}\r\nstatic int build_dpcd_write(struct drm_dp_sideband_msg_tx *msg, u8 port_num, u32 offset, u8 num_bytes, u8 *bytes)\r\n{\r\nstruct drm_dp_sideband_msg_req_body req;\r\nreq.req_type = DP_REMOTE_DPCD_WRITE;\r\nreq.u.dpcd_write.port_number = port_num;\r\nreq.u.dpcd_write.dpcd_address = offset;\r\nreq.u.dpcd_write.num_bytes = num_bytes;\r\nreq.u.dpcd_write.bytes = bytes;\r\ndrm_dp_encode_sideband_req(&req, msg);\r\nreturn 0;\r\n}\r\nstatic int build_link_address(struct drm_dp_sideband_msg_tx *msg)\r\n{\r\nstruct drm_dp_sideband_msg_req_body req;\r\nreq.req_type = DP_LINK_ADDRESS;\r\ndrm_dp_encode_sideband_req(&req, msg);\r\nreturn 0;\r\n}\r\nstatic int build_enum_path_resources(struct drm_dp_sideband_msg_tx *msg, int port_num)\r\n{\r\nstruct drm_dp_sideband_msg_req_body req;\r\nreq.req_type = DP_ENUM_PATH_RESOURCES;\r\nreq.u.port_num.port_number = port_num;\r\ndrm_dp_encode_sideband_req(&req, msg);\r\nmsg->path_msg = true;\r\nreturn 0;\r\n}\r\nstatic int build_allocate_payload(struct drm_dp_sideband_msg_tx *msg, int port_num,\r\nu8 vcpi, uint16_t pbn)\r\n{\r\nstruct drm_dp_sideband_msg_req_body req;\r\nmemset(&req, 0, sizeof(req));\r\nreq.req_type = DP_ALLOCATE_PAYLOAD;\r\nreq.u.allocate_payload.port_number = port_num;\r\nreq.u.allocate_payload.vcpi = vcpi;\r\nreq.u.allocate_payload.pbn = pbn;\r\ndrm_dp_encode_sideband_req(&req, msg);\r\nmsg->path_msg = true;\r\nreturn 0;\r\n}\r\nstatic int drm_dp_mst_assign_payload_id(struct drm_dp_mst_topology_mgr *mgr,\r\nstruct drm_dp_vcpi *vcpi)\r\n{\r\nint ret, vcpi_ret;\r\nmutex_lock(&mgr->payload_lock);\r\nret = find_first_zero_bit(&mgr->payload_mask, mgr->max_payloads + 1);\r\nif (ret > mgr->max_payloads) {\r\nret = -EINVAL;\r\nDRM_DEBUG_KMS("out of payload ids %d\n", ret);\r\ngoto out_unlock;\r\n}\r\nvcpi_ret = find_first_zero_bit(&mgr->vcpi_mask, mgr->max_payloads + 1);\r\nif (vcpi_ret > mgr->max_payloads) {\r\nret = -EINVAL;\r\nDRM_DEBUG_KMS("out of vcpi ids %d\n", ret);\r\ngoto out_unlock;\r\n}\r\nset_bit(ret, &mgr->payload_mask);\r\nset_bit(vcpi_ret, &mgr->vcpi_mask);\r\nvcpi->vcpi = vcpi_ret + 1;\r\nmgr->proposed_vcpis[ret - 1] = vcpi;\r\nout_unlock:\r\nmutex_unlock(&mgr->payload_lock);\r\nreturn ret;\r\n}\r\nstatic void drm_dp_mst_put_payload_id(struct drm_dp_mst_topology_mgr *mgr,\r\nint vcpi)\r\n{\r\nint i;\r\nif (vcpi == 0)\r\nreturn;\r\nmutex_lock(&mgr->payload_lock);\r\nDRM_DEBUG_KMS("putting payload %d\n", vcpi);\r\nclear_bit(vcpi - 1, &mgr->vcpi_mask);\r\nfor (i = 0; i < mgr->max_payloads; i++) {\r\nif (mgr->proposed_vcpis[i])\r\nif (mgr->proposed_vcpis[i]->vcpi == vcpi) {\r\nmgr->proposed_vcpis[i] = NULL;\r\nclear_bit(i + 1, &mgr->payload_mask);\r\n}\r\n}\r\nmutex_unlock(&mgr->payload_lock);\r\n}\r\nstatic bool check_txmsg_state(struct drm_dp_mst_topology_mgr *mgr,\r\nstruct drm_dp_sideband_msg_tx *txmsg)\r\n{\r\nbool ret;\r\nret = (txmsg->state == DRM_DP_SIDEBAND_TX_RX ||\r\ntxmsg->state == DRM_DP_SIDEBAND_TX_TIMEOUT);\r\nreturn ret;\r\n}\r\nstatic int drm_dp_mst_wait_tx_reply(struct drm_dp_mst_branch *mstb,\r\nstruct drm_dp_sideband_msg_tx *txmsg)\r\n{\r\nstruct drm_dp_mst_topology_mgr *mgr = mstb->mgr;\r\nint ret;\r\nret = wait_event_timeout(mgr->tx_waitq,\r\ncheck_txmsg_state(mgr, txmsg),\r\n(4 * HZ));\r\nmutex_lock(&mstb->mgr->qlock);\r\nif (ret > 0) {\r\nif (txmsg->state == DRM_DP_SIDEBAND_TX_TIMEOUT) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\n} else {\r\nDRM_DEBUG_KMS("timedout msg send %p %d %d\n", txmsg, txmsg->state, txmsg->seqno);\r\nret = -EIO;\r\nif (txmsg->state == DRM_DP_SIDEBAND_TX_QUEUED ||\r\ntxmsg->state == DRM_DP_SIDEBAND_TX_START_SEND) {\r\nlist_del(&txmsg->next);\r\n}\r\nif (txmsg->state == DRM_DP_SIDEBAND_TX_START_SEND ||\r\ntxmsg->state == DRM_DP_SIDEBAND_TX_SENT) {\r\nmstb->tx_slots[txmsg->seqno] = NULL;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&mgr->qlock);\r\nreturn ret;\r\n}\r\nstatic struct drm_dp_mst_branch *drm_dp_add_mst_branch_device(u8 lct, u8 *rad)\r\n{\r\nstruct drm_dp_mst_branch *mstb;\r\nmstb = kzalloc(sizeof(*mstb), GFP_KERNEL);\r\nif (!mstb)\r\nreturn NULL;\r\nmstb->lct = lct;\r\nif (lct > 1)\r\nmemcpy(mstb->rad, rad, lct / 2);\r\nINIT_LIST_HEAD(&mstb->ports);\r\nkref_init(&mstb->kref);\r\nreturn mstb;\r\n}\r\nstatic void drm_dp_destroy_mst_branch_device(struct kref *kref)\r\n{\r\nstruct drm_dp_mst_branch *mstb = container_of(kref, struct drm_dp_mst_branch, kref);\r\nstruct drm_dp_mst_port *port, *tmp;\r\nbool wake_tx = false;\r\nlist_for_each_entry_safe(port, tmp, &mstb->ports, next) {\r\nlist_del(&port->next);\r\ndrm_dp_put_port(port);\r\n}\r\nmutex_lock(&mstb->mgr->qlock);\r\nif (mstb->tx_slots[0]) {\r\nmstb->tx_slots[0]->state = DRM_DP_SIDEBAND_TX_TIMEOUT;\r\nmstb->tx_slots[0] = NULL;\r\nwake_tx = true;\r\n}\r\nif (mstb->tx_slots[1]) {\r\nmstb->tx_slots[1]->state = DRM_DP_SIDEBAND_TX_TIMEOUT;\r\nmstb->tx_slots[1] = NULL;\r\nwake_tx = true;\r\n}\r\nmutex_unlock(&mstb->mgr->qlock);\r\nif (wake_tx)\r\nwake_up(&mstb->mgr->tx_waitq);\r\nkfree(mstb);\r\n}\r\nstatic void drm_dp_put_mst_branch_device(struct drm_dp_mst_branch *mstb)\r\n{\r\nkref_put(&mstb->kref, drm_dp_destroy_mst_branch_device);\r\n}\r\nstatic void drm_dp_port_teardown_pdt(struct drm_dp_mst_port *port, int old_pdt)\r\n{\r\nstruct drm_dp_mst_branch *mstb;\r\nswitch (old_pdt) {\r\ncase DP_PEER_DEVICE_DP_LEGACY_CONV:\r\ncase DP_PEER_DEVICE_SST_SINK:\r\ndrm_dp_mst_unregister_i2c_bus(&port->aux);\r\nbreak;\r\ncase DP_PEER_DEVICE_MST_BRANCHING:\r\nmstb = port->mstb;\r\nport->mstb = NULL;\r\ndrm_dp_put_mst_branch_device(mstb);\r\nbreak;\r\n}\r\n}\r\nstatic void drm_dp_destroy_port(struct kref *kref)\r\n{\r\nstruct drm_dp_mst_port *port = container_of(kref, struct drm_dp_mst_port, kref);\r\nstruct drm_dp_mst_topology_mgr *mgr = port->mgr;\r\nif (!port->input) {\r\nport->vcpi.num_slots = 0;\r\nkfree(port->cached_edid);\r\nif (port->connector) {\r\nmutex_lock(&mgr->destroy_connector_lock);\r\nlist_add(&port->next, &mgr->destroy_connector_list);\r\nmutex_unlock(&mgr->destroy_connector_lock);\r\nschedule_work(&mgr->destroy_connector_work);\r\nreturn;\r\n}\r\ndrm_dp_port_teardown_pdt(port, port->pdt);\r\n}\r\nkfree(port);\r\n}\r\nstatic void drm_dp_put_port(struct drm_dp_mst_port *port)\r\n{\r\nkref_put(&port->kref, drm_dp_destroy_port);\r\n}\r\nstatic struct drm_dp_mst_branch *drm_dp_mst_get_validated_mstb_ref_locked(struct drm_dp_mst_branch *mstb, struct drm_dp_mst_branch *to_find)\r\n{\r\nstruct drm_dp_mst_port *port;\r\nstruct drm_dp_mst_branch *rmstb;\r\nif (to_find == mstb) {\r\nkref_get(&mstb->kref);\r\nreturn mstb;\r\n}\r\nlist_for_each_entry(port, &mstb->ports, next) {\r\nif (port->mstb) {\r\nrmstb = drm_dp_mst_get_validated_mstb_ref_locked(port->mstb, to_find);\r\nif (rmstb)\r\nreturn rmstb;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct drm_dp_mst_branch *drm_dp_get_validated_mstb_ref(struct drm_dp_mst_topology_mgr *mgr, struct drm_dp_mst_branch *mstb)\r\n{\r\nstruct drm_dp_mst_branch *rmstb = NULL;\r\nmutex_lock(&mgr->lock);\r\nif (mgr->mst_primary)\r\nrmstb = drm_dp_mst_get_validated_mstb_ref_locked(mgr->mst_primary, mstb);\r\nmutex_unlock(&mgr->lock);\r\nreturn rmstb;\r\n}\r\nstatic struct drm_dp_mst_port *drm_dp_mst_get_port_ref_locked(struct drm_dp_mst_branch *mstb, struct drm_dp_mst_port *to_find)\r\n{\r\nstruct drm_dp_mst_port *port, *mport;\r\nlist_for_each_entry(port, &mstb->ports, next) {\r\nif (port == to_find) {\r\nkref_get(&port->kref);\r\nreturn port;\r\n}\r\nif (port->mstb) {\r\nmport = drm_dp_mst_get_port_ref_locked(port->mstb, to_find);\r\nif (mport)\r\nreturn mport;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct drm_dp_mst_port *drm_dp_get_validated_port_ref(struct drm_dp_mst_topology_mgr *mgr, struct drm_dp_mst_port *port)\r\n{\r\nstruct drm_dp_mst_port *rport = NULL;\r\nmutex_lock(&mgr->lock);\r\nif (mgr->mst_primary)\r\nrport = drm_dp_mst_get_port_ref_locked(mgr->mst_primary, port);\r\nmutex_unlock(&mgr->lock);\r\nreturn rport;\r\n}\r\nstatic struct drm_dp_mst_port *drm_dp_get_port(struct drm_dp_mst_branch *mstb, u8 port_num)\r\n{\r\nstruct drm_dp_mst_port *port;\r\nlist_for_each_entry(port, &mstb->ports, next) {\r\nif (port->port_num == port_num) {\r\nkref_get(&port->kref);\r\nreturn port;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic u8 drm_dp_calculate_rad(struct drm_dp_mst_port *port,\r\nu8 *rad)\r\n{\r\nint lct = port->parent->lct;\r\nint shift = 4;\r\nint idx = lct / 2;\r\nif (lct > 1) {\r\nmemcpy(rad, port->parent->rad, idx);\r\nshift = (lct % 2) ? 4 : 0;\r\n} else\r\nrad[0] = 0;\r\nrad[idx] |= port->port_num << shift;\r\nreturn lct + 1;\r\n}\r\nstatic bool drm_dp_port_setup_pdt(struct drm_dp_mst_port *port)\r\n{\r\nint ret;\r\nu8 rad[6], lct;\r\nbool send_link = false;\r\nswitch (port->pdt) {\r\ncase DP_PEER_DEVICE_DP_LEGACY_CONV:\r\ncase DP_PEER_DEVICE_SST_SINK:\r\nret = drm_dp_mst_register_i2c_bus(&port->aux);\r\nbreak;\r\ncase DP_PEER_DEVICE_MST_BRANCHING:\r\nlct = drm_dp_calculate_rad(port, rad);\r\nport->mstb = drm_dp_add_mst_branch_device(lct, rad);\r\nport->mstb->mgr = port->mgr;\r\nport->mstb->port_parent = port;\r\nsend_link = true;\r\nbreak;\r\n}\r\nreturn send_link;\r\n}\r\nstatic void drm_dp_check_port_guid(struct drm_dp_mst_branch *mstb,\r\nstruct drm_dp_mst_port *port)\r\n{\r\nint ret;\r\nif (port->dpcd_rev >= 0x12) {\r\nport->guid_valid = drm_dp_validate_guid(mstb->mgr, port->guid);\r\nif (!port->guid_valid) {\r\nret = drm_dp_send_dpcd_write(mstb->mgr,\r\nport,\r\nDP_GUID,\r\n16, port->guid);\r\nport->guid_valid = true;\r\n}\r\n}\r\n}\r\nstatic void build_mst_prop_path(const struct drm_dp_mst_branch *mstb,\r\nint pnum,\r\nchar *proppath,\r\nsize_t proppath_size)\r\n{\r\nint i;\r\nchar temp[8];\r\nsnprintf(proppath, proppath_size, "mst:%d", mstb->mgr->conn_base_id);\r\nfor (i = 0; i < (mstb->lct - 1); i++) {\r\nint shift = (i % 2) ? 0 : 4;\r\nint port_num = mstb->rad[i / 2] >> shift;\r\nsnprintf(temp, sizeof(temp), "-%d", port_num);\r\nstrlcat(proppath, temp, proppath_size);\r\n}\r\nsnprintf(temp, sizeof(temp), "-%d", pnum);\r\nstrlcat(proppath, temp, proppath_size);\r\n}\r\nstatic void drm_dp_add_port(struct drm_dp_mst_branch *mstb,\r\nstruct device *dev,\r\nstruct drm_dp_link_addr_reply_port *port_msg)\r\n{\r\nstruct drm_dp_mst_port *port;\r\nbool ret;\r\nbool created = false;\r\nint old_pdt = 0;\r\nint old_ddps = 0;\r\nport = drm_dp_get_port(mstb, port_msg->port_number);\r\nif (!port) {\r\nport = kzalloc(sizeof(*port), GFP_KERNEL);\r\nif (!port)\r\nreturn;\r\nkref_init(&port->kref);\r\nport->parent = mstb;\r\nport->port_num = port_msg->port_number;\r\nport->mgr = mstb->mgr;\r\nport->aux.name = "DPMST";\r\nport->aux.dev = dev;\r\ncreated = true;\r\n} else {\r\nold_pdt = port->pdt;\r\nold_ddps = port->ddps;\r\n}\r\nport->pdt = port_msg->peer_device_type;\r\nport->input = port_msg->input_port;\r\nport->mcs = port_msg->mcs;\r\nport->ddps = port_msg->ddps;\r\nport->ldps = port_msg->legacy_device_plug_status;\r\nport->dpcd_rev = port_msg->dpcd_revision;\r\nport->num_sdp_streams = port_msg->num_sdp_streams;\r\nport->num_sdp_stream_sinks = port_msg->num_sdp_stream_sinks;\r\nmemcpy(port->guid, port_msg->peer_guid, 16);\r\nif (created) {\r\nmutex_lock(&mstb->mgr->lock);\r\nkref_get(&port->kref);\r\nlist_add(&port->next, &mstb->ports);\r\nmutex_unlock(&mstb->mgr->lock);\r\n}\r\nif (old_ddps != port->ddps) {\r\nif (port->ddps) {\r\ndrm_dp_check_port_guid(mstb, port);\r\nif (!port->input)\r\ndrm_dp_send_enum_path_resources(mstb->mgr, mstb, port);\r\n} else {\r\nport->guid_valid = false;\r\nport->available_pbn = 0;\r\n}\r\n}\r\nif (old_pdt != port->pdt && !port->input) {\r\ndrm_dp_port_teardown_pdt(port, old_pdt);\r\nret = drm_dp_port_setup_pdt(port);\r\nif (ret == true)\r\ndrm_dp_send_link_address(mstb->mgr, port->mstb);\r\n}\r\nif (created && !port->input) {\r\nchar proppath[255];\r\nbuild_mst_prop_path(mstb, port->port_num, proppath, sizeof(proppath));\r\nport->connector = (*mstb->mgr->cbs->add_connector)(mstb->mgr, port, proppath);\r\nif (!port->connector) {\r\nmutex_lock(&mstb->mgr->lock);\r\nlist_del(&port->next);\r\nmutex_unlock(&mstb->mgr->lock);\r\ndrm_dp_put_port(port);\r\ngoto out;\r\n}\r\nif (port->port_num >= DP_MST_LOGICAL_PORT_0) {\r\nport->cached_edid = drm_get_edid(port->connector, &port->aux.ddc);\r\ndrm_mode_connector_set_tile_property(port->connector);\r\n}\r\n(*mstb->mgr->cbs->register_connector)(port->connector);\r\n}\r\nout:\r\ndrm_dp_put_port(port);\r\n}\r\nstatic void drm_dp_update_port(struct drm_dp_mst_branch *mstb,\r\nstruct drm_dp_connection_status_notify *conn_stat)\r\n{\r\nstruct drm_dp_mst_port *port;\r\nint old_pdt;\r\nint old_ddps;\r\nbool dowork = false;\r\nport = drm_dp_get_port(mstb, conn_stat->port_number);\r\nif (!port)\r\nreturn;\r\nold_ddps = port->ddps;\r\nold_pdt = port->pdt;\r\nport->pdt = conn_stat->peer_device_type;\r\nport->mcs = conn_stat->message_capability_status;\r\nport->ldps = conn_stat->legacy_device_plug_status;\r\nport->ddps = conn_stat->displayport_device_plug_status;\r\nif (old_ddps != port->ddps) {\r\nif (port->ddps) {\r\ndrm_dp_check_port_guid(mstb, port);\r\ndowork = true;\r\n} else {\r\nport->guid_valid = false;\r\nport->available_pbn = 0;\r\n}\r\n}\r\nif (old_pdt != port->pdt && !port->input) {\r\ndrm_dp_port_teardown_pdt(port, old_pdt);\r\nif (drm_dp_port_setup_pdt(port))\r\ndowork = true;\r\n}\r\ndrm_dp_put_port(port);\r\nif (dowork)\r\nqueue_work(system_long_wq, &mstb->mgr->work);\r\n}\r\nstatic struct drm_dp_mst_branch *drm_dp_get_mst_branch_device(struct drm_dp_mst_topology_mgr *mgr,\r\nu8 lct, u8 *rad)\r\n{\r\nstruct drm_dp_mst_branch *mstb;\r\nstruct drm_dp_mst_port *port;\r\nint i;\r\nmutex_lock(&mgr->lock);\r\nmstb = mgr->mst_primary;\r\nfor (i = 0; i < lct - 1; i++) {\r\nint shift = (i % 2) ? 0 : 4;\r\nint port_num = rad[i / 2] >> shift;\r\nlist_for_each_entry(port, &mstb->ports, next) {\r\nif (port->port_num == port_num) {\r\nmstb = port->mstb;\r\nif (!mstb) {\r\nDRM_ERROR("failed to lookup MSTB with lct %d, rad %02x\n", lct, rad[0]);\r\ngoto out;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nkref_get(&mstb->kref);\r\nout:\r\nmutex_unlock(&mgr->lock);\r\nreturn mstb;\r\n}\r\nstatic void drm_dp_check_and_send_link_address(struct drm_dp_mst_topology_mgr *mgr,\r\nstruct drm_dp_mst_branch *mstb)\r\n{\r\nstruct drm_dp_mst_port *port;\r\nstruct drm_dp_mst_branch *mstb_child;\r\nif (!mstb->link_address_sent)\r\ndrm_dp_send_link_address(mgr, mstb);\r\nlist_for_each_entry(port, &mstb->ports, next) {\r\nif (port->input)\r\ncontinue;\r\nif (!port->ddps)\r\ncontinue;\r\nif (!port->available_pbn)\r\ndrm_dp_send_enum_path_resources(mgr, mstb, port);\r\nif (port->mstb) {\r\nmstb_child = drm_dp_get_validated_mstb_ref(mgr, port->mstb);\r\nif (mstb_child) {\r\ndrm_dp_check_and_send_link_address(mgr, mstb_child);\r\ndrm_dp_put_mst_branch_device(mstb_child);\r\n}\r\n}\r\n}\r\n}\r\nstatic void drm_dp_mst_link_probe_work(struct work_struct *work)\r\n{\r\nstruct drm_dp_mst_topology_mgr *mgr = container_of(work, struct drm_dp_mst_topology_mgr, work);\r\nstruct drm_dp_mst_branch *mstb;\r\nmutex_lock(&mgr->lock);\r\nmstb = mgr->mst_primary;\r\nif (mstb) {\r\nkref_get(&mstb->kref);\r\n}\r\nmutex_unlock(&mgr->lock);\r\nif (mstb) {\r\ndrm_dp_check_and_send_link_address(mgr, mstb);\r\ndrm_dp_put_mst_branch_device(mstb);\r\n}\r\n}\r\nstatic bool drm_dp_validate_guid(struct drm_dp_mst_topology_mgr *mgr,\r\nu8 *guid)\r\n{\r\nstatic u8 zero_guid[16];\r\nif (!memcmp(guid, zero_guid, 16)) {\r\nu64 salt = get_jiffies_64();\r\nmemcpy(&guid[0], &salt, sizeof(u64));\r\nmemcpy(&guid[8], &salt, sizeof(u64));\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int drm_dp_send_sideband_msg(struct drm_dp_mst_topology_mgr *mgr,\r\nbool up, u8 *msg, int len)\r\n{\r\nint ret;\r\nint regbase = up ? DP_SIDEBAND_MSG_UP_REP_BASE : DP_SIDEBAND_MSG_DOWN_REQ_BASE;\r\nint tosend, total, offset;\r\nint retries = 0;\r\nretry:\r\ntotal = len;\r\noffset = 0;\r\ndo {\r\ntosend = min3(mgr->max_dpcd_transaction_bytes, 16, total);\r\nret = drm_dp_dpcd_write(mgr->aux, regbase + offset,\r\n&msg[offset],\r\ntosend);\r\nif (ret != tosend) {\r\nif (ret == -EIO && retries < 5) {\r\nretries++;\r\ngoto retry;\r\n}\r\nDRM_DEBUG_KMS("failed to dpcd write %d %d\n", tosend, ret);\r\nreturn -EIO;\r\n}\r\noffset += tosend;\r\ntotal -= tosend;\r\n} while (total > 0);\r\nreturn 0;\r\n}\r\nstatic int set_hdr_from_dst_qlock(struct drm_dp_sideband_msg_hdr *hdr,\r\nstruct drm_dp_sideband_msg_tx *txmsg)\r\n{\r\nstruct drm_dp_mst_branch *mstb = txmsg->dst;\r\nif (txmsg->seqno == -1) {\r\nif (mstb->tx_slots[0] && mstb->tx_slots[1]) {\r\nDRM_DEBUG_KMS("%s: failed to find slot\n", __func__);\r\nreturn -EAGAIN;\r\n}\r\nif (mstb->tx_slots[0] == NULL && mstb->tx_slots[1] == NULL) {\r\ntxmsg->seqno = mstb->last_seqno;\r\nmstb->last_seqno ^= 1;\r\n} else if (mstb->tx_slots[0] == NULL)\r\ntxmsg->seqno = 0;\r\nelse\r\ntxmsg->seqno = 1;\r\nmstb->tx_slots[txmsg->seqno] = txmsg;\r\n}\r\nhdr->broadcast = 0;\r\nhdr->path_msg = txmsg->path_msg;\r\nhdr->lct = mstb->lct;\r\nhdr->lcr = mstb->lct - 1;\r\nif (mstb->lct > 1)\r\nmemcpy(hdr->rad, mstb->rad, mstb->lct / 2);\r\nhdr->seqno = txmsg->seqno;\r\nreturn 0;\r\n}\r\nstatic int process_single_tx_qlock(struct drm_dp_mst_topology_mgr *mgr,\r\nstruct drm_dp_sideband_msg_tx *txmsg,\r\nbool up)\r\n{\r\nu8 chunk[48];\r\nstruct drm_dp_sideband_msg_hdr hdr;\r\nint len, space, idx, tosend;\r\nint ret;\r\nmemset(&hdr, 0, sizeof(struct drm_dp_sideband_msg_hdr));\r\nif (txmsg->state == DRM_DP_SIDEBAND_TX_QUEUED) {\r\ntxmsg->seqno = -1;\r\ntxmsg->state = DRM_DP_SIDEBAND_TX_START_SEND;\r\n}\r\nret = set_hdr_from_dst_qlock(&hdr, txmsg);\r\nif (ret < 0)\r\nreturn ret;\r\nlen = txmsg->cur_len - txmsg->cur_offset;\r\nspace = 48 - 1 - drm_dp_calc_sb_hdr_size(&hdr);\r\ntosend = min(len, space);\r\nif (len == txmsg->cur_len)\r\nhdr.somt = 1;\r\nif (space >= len)\r\nhdr.eomt = 1;\r\nhdr.msg_len = tosend + 1;\r\ndrm_dp_encode_sideband_msg_hdr(&hdr, chunk, &idx);\r\nmemcpy(&chunk[idx], &txmsg->msg[txmsg->cur_offset], tosend);\r\ndrm_dp_crc_sideband_chunk_req(&chunk[idx], tosend);\r\nidx += tosend + 1;\r\nret = drm_dp_send_sideband_msg(mgr, up, chunk, idx);\r\nif (ret) {\r\nDRM_DEBUG_KMS("sideband msg failed to send\n");\r\nreturn ret;\r\n}\r\ntxmsg->cur_offset += tosend;\r\nif (txmsg->cur_offset == txmsg->cur_len) {\r\ntxmsg->state = DRM_DP_SIDEBAND_TX_SENT;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void process_single_down_tx_qlock(struct drm_dp_mst_topology_mgr *mgr)\r\n{\r\nstruct drm_dp_sideband_msg_tx *txmsg;\r\nint ret;\r\nWARN_ON(!mutex_is_locked(&mgr->qlock));\r\nif (list_empty(&mgr->tx_msg_downq)) {\r\nmgr->tx_down_in_progress = false;\r\nreturn;\r\n}\r\nmgr->tx_down_in_progress = true;\r\ntxmsg = list_first_entry(&mgr->tx_msg_downq, struct drm_dp_sideband_msg_tx, next);\r\nret = process_single_tx_qlock(mgr, txmsg, false);\r\nif (ret == 1) {\r\nlist_del(&txmsg->next);\r\n} else if (ret) {\r\nDRM_DEBUG_KMS("failed to send msg in q %d\n", ret);\r\nlist_del(&txmsg->next);\r\nif (txmsg->seqno != -1)\r\ntxmsg->dst->tx_slots[txmsg->seqno] = NULL;\r\ntxmsg->state = DRM_DP_SIDEBAND_TX_TIMEOUT;\r\nwake_up(&mgr->tx_waitq);\r\n}\r\nif (list_empty(&mgr->tx_msg_downq)) {\r\nmgr->tx_down_in_progress = false;\r\nreturn;\r\n}\r\n}\r\nstatic void process_single_up_tx_qlock(struct drm_dp_mst_topology_mgr *mgr)\r\n{\r\nstruct drm_dp_sideband_msg_tx *txmsg;\r\nint ret;\r\nif (list_empty(&mgr->tx_msg_upq)) {\r\nmgr->tx_up_in_progress = false;\r\nreturn;\r\n}\r\ntxmsg = list_first_entry(&mgr->tx_msg_upq, struct drm_dp_sideband_msg_tx, next);\r\nret = process_single_tx_qlock(mgr, txmsg, true);\r\nif (ret == 1) {\r\nlist_del(&txmsg->next);\r\nkfree(txmsg);\r\n} else if (ret)\r\nDRM_DEBUG_KMS("failed to send msg in q %d\n", ret);\r\nmgr->tx_up_in_progress = true;\r\n}\r\nstatic void drm_dp_queue_down_tx(struct drm_dp_mst_topology_mgr *mgr,\r\nstruct drm_dp_sideband_msg_tx *txmsg)\r\n{\r\nmutex_lock(&mgr->qlock);\r\nlist_add_tail(&txmsg->next, &mgr->tx_msg_downq);\r\nif (!mgr->tx_down_in_progress)\r\nprocess_single_down_tx_qlock(mgr);\r\nmutex_unlock(&mgr->qlock);\r\n}\r\nstatic void drm_dp_send_link_address(struct drm_dp_mst_topology_mgr *mgr,\r\nstruct drm_dp_mst_branch *mstb)\r\n{\r\nint len;\r\nstruct drm_dp_sideband_msg_tx *txmsg;\r\nint ret;\r\ntxmsg = kzalloc(sizeof(*txmsg), GFP_KERNEL);\r\nif (!txmsg)\r\nreturn;\r\ntxmsg->dst = mstb;\r\nlen = build_link_address(txmsg);\r\nmstb->link_address_sent = true;\r\ndrm_dp_queue_down_tx(mgr, txmsg);\r\nret = drm_dp_mst_wait_tx_reply(mstb, txmsg);\r\nif (ret > 0) {\r\nint i;\r\nif (txmsg->reply.reply_type == 1)\r\nDRM_DEBUG_KMS("link address nak received\n");\r\nelse {\r\nDRM_DEBUG_KMS("link address reply: %d\n", txmsg->reply.u.link_addr.nports);\r\nfor (i = 0; i < txmsg->reply.u.link_addr.nports; i++) {\r\nDRM_DEBUG_KMS("port %d: input %d, pdt: %d, pn: %d, dpcd_rev: %02x, mcs: %d, ddps: %d, ldps %d, sdp %d/%d\n", i,\r\ntxmsg->reply.u.link_addr.ports[i].input_port,\r\ntxmsg->reply.u.link_addr.ports[i].peer_device_type,\r\ntxmsg->reply.u.link_addr.ports[i].port_number,\r\ntxmsg->reply.u.link_addr.ports[i].dpcd_revision,\r\ntxmsg->reply.u.link_addr.ports[i].mcs,\r\ntxmsg->reply.u.link_addr.ports[i].ddps,\r\ntxmsg->reply.u.link_addr.ports[i].legacy_device_plug_status,\r\ntxmsg->reply.u.link_addr.ports[i].num_sdp_streams,\r\ntxmsg->reply.u.link_addr.ports[i].num_sdp_stream_sinks);\r\n}\r\nfor (i = 0; i < txmsg->reply.u.link_addr.nports; i++) {\r\ndrm_dp_add_port(mstb, mgr->dev, &txmsg->reply.u.link_addr.ports[i]);\r\n}\r\n(*mgr->cbs->hotplug)(mgr);\r\n}\r\n} else {\r\nmstb->link_address_sent = false;\r\nDRM_DEBUG_KMS("link address failed %d\n", ret);\r\n}\r\nkfree(txmsg);\r\n}\r\nstatic int drm_dp_send_enum_path_resources(struct drm_dp_mst_topology_mgr *mgr,\r\nstruct drm_dp_mst_branch *mstb,\r\nstruct drm_dp_mst_port *port)\r\n{\r\nint len;\r\nstruct drm_dp_sideband_msg_tx *txmsg;\r\nint ret;\r\ntxmsg = kzalloc(sizeof(*txmsg), GFP_KERNEL);\r\nif (!txmsg)\r\nreturn -ENOMEM;\r\ntxmsg->dst = mstb;\r\nlen = build_enum_path_resources(txmsg, port->port_num);\r\ndrm_dp_queue_down_tx(mgr, txmsg);\r\nret = drm_dp_mst_wait_tx_reply(mstb, txmsg);\r\nif (ret > 0) {\r\nif (txmsg->reply.reply_type == 1)\r\nDRM_DEBUG_KMS("enum path resources nak received\n");\r\nelse {\r\nif (port->port_num != txmsg->reply.u.path_resources.port_number)\r\nDRM_ERROR("got incorrect port in response\n");\r\nDRM_DEBUG_KMS("enum path resources %d: %d %d\n", txmsg->reply.u.path_resources.port_number, txmsg->reply.u.path_resources.full_payload_bw_number,\r\ntxmsg->reply.u.path_resources.avail_payload_bw_number);\r\nport->available_pbn = txmsg->reply.u.path_resources.avail_payload_bw_number;\r\n}\r\n}\r\nkfree(txmsg);\r\nreturn 0;\r\n}\r\nstatic int drm_dp_payload_send_msg(struct drm_dp_mst_topology_mgr *mgr,\r\nstruct drm_dp_mst_port *port,\r\nint id,\r\nint pbn)\r\n{\r\nstruct drm_dp_sideband_msg_tx *txmsg;\r\nstruct drm_dp_mst_branch *mstb;\r\nint len, ret;\r\nmstb = drm_dp_get_validated_mstb_ref(mgr, port->parent);\r\nif (!mstb)\r\nreturn -EINVAL;\r\ntxmsg = kzalloc(sizeof(*txmsg), GFP_KERNEL);\r\nif (!txmsg) {\r\nret = -ENOMEM;\r\ngoto fail_put;\r\n}\r\ntxmsg->dst = mstb;\r\nlen = build_allocate_payload(txmsg, port->port_num,\r\nid,\r\npbn);\r\ndrm_dp_queue_down_tx(mgr, txmsg);\r\nret = drm_dp_mst_wait_tx_reply(mstb, txmsg);\r\nif (ret > 0) {\r\nif (txmsg->reply.reply_type == 1) {\r\nret = -EINVAL;\r\n} else\r\nret = 0;\r\n}\r\nkfree(txmsg);\r\nfail_put:\r\ndrm_dp_put_mst_branch_device(mstb);\r\nreturn ret;\r\n}\r\nstatic int drm_dp_create_payload_step1(struct drm_dp_mst_topology_mgr *mgr,\r\nint id,\r\nstruct drm_dp_payload *payload)\r\n{\r\nint ret;\r\nret = drm_dp_dpcd_write_payload(mgr, id, payload);\r\nif (ret < 0) {\r\npayload->payload_state = 0;\r\nreturn ret;\r\n}\r\npayload->payload_state = DP_PAYLOAD_LOCAL;\r\nreturn 0;\r\n}\r\nstatic int drm_dp_create_payload_step2(struct drm_dp_mst_topology_mgr *mgr,\r\nstruct drm_dp_mst_port *port,\r\nint id,\r\nstruct drm_dp_payload *payload)\r\n{\r\nint ret;\r\nret = drm_dp_payload_send_msg(mgr, port, id, port->vcpi.pbn);\r\nif (ret < 0)\r\nreturn ret;\r\npayload->payload_state = DP_PAYLOAD_REMOTE;\r\nreturn ret;\r\n}\r\nstatic int drm_dp_destroy_payload_step1(struct drm_dp_mst_topology_mgr *mgr,\r\nstruct drm_dp_mst_port *port,\r\nint id,\r\nstruct drm_dp_payload *payload)\r\n{\r\nDRM_DEBUG_KMS("\n");\r\nif (port) {\r\ndrm_dp_payload_send_msg(mgr, port, id, 0);\r\n}\r\ndrm_dp_dpcd_write_payload(mgr, id, payload);\r\npayload->payload_state = DP_PAYLOAD_DELETE_LOCAL;\r\nreturn 0;\r\n}\r\nstatic int drm_dp_destroy_payload_step2(struct drm_dp_mst_topology_mgr *mgr,\r\nint id,\r\nstruct drm_dp_payload *payload)\r\n{\r\npayload->payload_state = 0;\r\nreturn 0;\r\n}\r\nint drm_dp_update_payload_part1(struct drm_dp_mst_topology_mgr *mgr)\r\n{\r\nint i, j;\r\nint cur_slots = 1;\r\nstruct drm_dp_payload req_payload;\r\nstruct drm_dp_mst_port *port;\r\nmutex_lock(&mgr->payload_lock);\r\nfor (i = 0; i < mgr->max_payloads; i++) {\r\nreq_payload.start_slot = cur_slots;\r\nif (mgr->proposed_vcpis[i]) {\r\nport = container_of(mgr->proposed_vcpis[i], struct drm_dp_mst_port, vcpi);\r\nreq_payload.num_slots = mgr->proposed_vcpis[i]->num_slots;\r\n} else {\r\nport = NULL;\r\nreq_payload.num_slots = 0;\r\n}\r\nif (mgr->payloads[i].start_slot != req_payload.start_slot) {\r\nmgr->payloads[i].start_slot = req_payload.start_slot;\r\n}\r\nif (mgr->payloads[i].num_slots != req_payload.num_slots) {\r\nif (req_payload.num_slots) {\r\ndrm_dp_create_payload_step1(mgr, mgr->proposed_vcpis[i]->vcpi, &req_payload);\r\nmgr->payloads[i].num_slots = req_payload.num_slots;\r\n} else if (mgr->payloads[i].num_slots) {\r\nmgr->payloads[i].num_slots = 0;\r\ndrm_dp_destroy_payload_step1(mgr, port, port->vcpi.vcpi, &mgr->payloads[i]);\r\nreq_payload.payload_state = mgr->payloads[i].payload_state;\r\nmgr->payloads[i].start_slot = 0;\r\n}\r\nmgr->payloads[i].payload_state = req_payload.payload_state;\r\n}\r\ncur_slots += req_payload.num_slots;\r\n}\r\nfor (i = 0; i < mgr->max_payloads; i++) {\r\nif (mgr->payloads[i].payload_state == DP_PAYLOAD_DELETE_LOCAL) {\r\nDRM_DEBUG_KMS("removing payload %d\n", i);\r\nfor (j = i; j < mgr->max_payloads - 1; j++) {\r\nmemcpy(&mgr->payloads[j], &mgr->payloads[j + 1], sizeof(struct drm_dp_payload));\r\nmgr->proposed_vcpis[j] = mgr->proposed_vcpis[j + 1];\r\nif (mgr->proposed_vcpis[j] && mgr->proposed_vcpis[j]->num_slots) {\r\nset_bit(j + 1, &mgr->payload_mask);\r\n} else {\r\nclear_bit(j + 1, &mgr->payload_mask);\r\n}\r\n}\r\nmemset(&mgr->payloads[mgr->max_payloads - 1], 0, sizeof(struct drm_dp_payload));\r\nmgr->proposed_vcpis[mgr->max_payloads - 1] = NULL;\r\nclear_bit(mgr->max_payloads, &mgr->payload_mask);\r\n}\r\n}\r\nmutex_unlock(&mgr->payload_lock);\r\nreturn 0;\r\n}\r\nint drm_dp_update_payload_part2(struct drm_dp_mst_topology_mgr *mgr)\r\n{\r\nstruct drm_dp_mst_port *port;\r\nint i;\r\nint ret = 0;\r\nmutex_lock(&mgr->payload_lock);\r\nfor (i = 0; i < mgr->max_payloads; i++) {\r\nif (!mgr->proposed_vcpis[i])\r\ncontinue;\r\nport = container_of(mgr->proposed_vcpis[i], struct drm_dp_mst_port, vcpi);\r\nDRM_DEBUG_KMS("payload %d %d\n", i, mgr->payloads[i].payload_state);\r\nif (mgr->payloads[i].payload_state == DP_PAYLOAD_LOCAL) {\r\nret = drm_dp_create_payload_step2(mgr, port, mgr->proposed_vcpis[i]->vcpi, &mgr->payloads[i]);\r\n} else if (mgr->payloads[i].payload_state == DP_PAYLOAD_DELETE_LOCAL) {\r\nret = drm_dp_destroy_payload_step2(mgr, mgr->proposed_vcpis[i]->vcpi, &mgr->payloads[i]);\r\n}\r\nif (ret) {\r\nmutex_unlock(&mgr->payload_lock);\r\nreturn ret;\r\n}\r\n}\r\nmutex_unlock(&mgr->payload_lock);\r\nreturn 0;\r\n}\r\nstatic int drm_dp_send_dpcd_write(struct drm_dp_mst_topology_mgr *mgr,\r\nstruct drm_dp_mst_port *port,\r\nint offset, int size, u8 *bytes)\r\n{\r\nint len;\r\nint ret;\r\nstruct drm_dp_sideband_msg_tx *txmsg;\r\nstruct drm_dp_mst_branch *mstb;\r\nmstb = drm_dp_get_validated_mstb_ref(mgr, port->parent);\r\nif (!mstb)\r\nreturn -EINVAL;\r\ntxmsg = kzalloc(sizeof(*txmsg), GFP_KERNEL);\r\nif (!txmsg) {\r\nret = -ENOMEM;\r\ngoto fail_put;\r\n}\r\nlen = build_dpcd_write(txmsg, port->port_num, offset, size, bytes);\r\ntxmsg->dst = mstb;\r\ndrm_dp_queue_down_tx(mgr, txmsg);\r\nret = drm_dp_mst_wait_tx_reply(mstb, txmsg);\r\nif (ret > 0) {\r\nif (txmsg->reply.reply_type == 1) {\r\nret = -EINVAL;\r\n} else\r\nret = 0;\r\n}\r\nkfree(txmsg);\r\nfail_put:\r\ndrm_dp_put_mst_branch_device(mstb);\r\nreturn ret;\r\n}\r\nstatic int drm_dp_encode_up_ack_reply(struct drm_dp_sideband_msg_tx *msg, u8 req_type)\r\n{\r\nstruct drm_dp_sideband_msg_reply_body reply;\r\nreply.reply_type = 1;\r\nreply.req_type = req_type;\r\ndrm_dp_encode_sideband_reply(&reply, msg);\r\nreturn 0;\r\n}\r\nstatic int drm_dp_send_up_ack_reply(struct drm_dp_mst_topology_mgr *mgr,\r\nstruct drm_dp_mst_branch *mstb,\r\nint req_type, int seqno, bool broadcast)\r\n{\r\nstruct drm_dp_sideband_msg_tx *txmsg;\r\ntxmsg = kzalloc(sizeof(*txmsg), GFP_KERNEL);\r\nif (!txmsg)\r\nreturn -ENOMEM;\r\ntxmsg->dst = mstb;\r\ntxmsg->seqno = seqno;\r\ndrm_dp_encode_up_ack_reply(txmsg, req_type);\r\nmutex_lock(&mgr->qlock);\r\nlist_add_tail(&txmsg->next, &mgr->tx_msg_upq);\r\nif (!mgr->tx_up_in_progress) {\r\nprocess_single_up_tx_qlock(mgr);\r\n}\r\nmutex_unlock(&mgr->qlock);\r\nreturn 0;\r\n}\r\nstatic bool drm_dp_get_vc_payload_bw(int dp_link_bw,\r\nint dp_link_count,\r\nint *out)\r\n{\r\nswitch (dp_link_bw) {\r\ndefault:\r\nDRM_DEBUG_KMS("invalid link bandwidth in DPCD: %x (link count: %d)\n",\r\ndp_link_bw, dp_link_count);\r\nreturn false;\r\ncase DP_LINK_BW_1_62:\r\n*out = 3 * dp_link_count;\r\nbreak;\r\ncase DP_LINK_BW_2_7:\r\n*out = 5 * dp_link_count;\r\nbreak;\r\ncase DP_LINK_BW_5_4:\r\n*out = 10 * dp_link_count;\r\nbreak;\r\n}\r\nreturn true;\r\n}\r\nint drm_dp_mst_topology_mgr_set_mst(struct drm_dp_mst_topology_mgr *mgr, bool mst_state)\r\n{\r\nint ret = 0;\r\nstruct drm_dp_mst_branch *mstb = NULL;\r\nmutex_lock(&mgr->lock);\r\nif (mst_state == mgr->mst_state)\r\ngoto out_unlock;\r\nmgr->mst_state = mst_state;\r\nif (mst_state) {\r\nWARN_ON(mgr->mst_primary);\r\nret = drm_dp_dpcd_read(mgr->aux, DP_DPCD_REV, mgr->dpcd, DP_RECEIVER_CAP_SIZE);\r\nif (ret != DP_RECEIVER_CAP_SIZE) {\r\nDRM_DEBUG_KMS("failed to read DPCD\n");\r\ngoto out_unlock;\r\n}\r\nif (!drm_dp_get_vc_payload_bw(mgr->dpcd[1],\r\nmgr->dpcd[2] & DP_MAX_LANE_COUNT_MASK,\r\n&mgr->pbn_div)) {\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nmgr->total_pbn = 2560;\r\nmgr->total_slots = DIV_ROUND_UP(mgr->total_pbn, mgr->pbn_div);\r\nmgr->avail_slots = mgr->total_slots;\r\nmstb = drm_dp_add_mst_branch_device(1, NULL);\r\nif (mstb == NULL) {\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nmstb->mgr = mgr;\r\nmgr->mst_primary = mstb;\r\nkref_get(&mgr->mst_primary->kref);\r\n{\r\nstruct drm_dp_payload reset_pay;\r\nreset_pay.start_slot = 0;\r\nreset_pay.num_slots = 0x3f;\r\ndrm_dp_dpcd_write_payload(mgr, 0, &reset_pay);\r\n}\r\nret = drm_dp_dpcd_writeb(mgr->aux, DP_MSTM_CTRL,\r\nDP_MST_EN | DP_UP_REQ_EN | DP_UPSTREAM_IS_SRC);\r\nif (ret < 0) {\r\ngoto out_unlock;\r\n}\r\nret = drm_dp_dpcd_read(mgr->aux, DP_GUID, mgr->guid, 16);\r\nif (ret != 16) {\r\nDRM_DEBUG_KMS("failed to read DP GUID %d\n", ret);\r\ngoto out_unlock;\r\n}\r\nmgr->guid_valid = drm_dp_validate_guid(mgr, mgr->guid);\r\nif (!mgr->guid_valid) {\r\nret = drm_dp_dpcd_write(mgr->aux, DP_GUID, mgr->guid, 16);\r\nmgr->guid_valid = true;\r\n}\r\nqueue_work(system_long_wq, &mgr->work);\r\nret = 0;\r\n} else {\r\nmstb = mgr->mst_primary;\r\nmgr->mst_primary = NULL;\r\ndrm_dp_dpcd_writeb(mgr->aux, DP_MSTM_CTRL, 0);\r\nret = 0;\r\nmemset(mgr->payloads, 0, mgr->max_payloads * sizeof(struct drm_dp_payload));\r\nmgr->payload_mask = 0;\r\nset_bit(0, &mgr->payload_mask);\r\nmgr->vcpi_mask = 0;\r\n}\r\nout_unlock:\r\nmutex_unlock(&mgr->lock);\r\nif (mstb)\r\ndrm_dp_put_mst_branch_device(mstb);\r\nreturn ret;\r\n}\r\nvoid drm_dp_mst_topology_mgr_suspend(struct drm_dp_mst_topology_mgr *mgr)\r\n{\r\nmutex_lock(&mgr->lock);\r\ndrm_dp_dpcd_writeb(mgr->aux, DP_MSTM_CTRL,\r\nDP_MST_EN | DP_UPSTREAM_IS_SRC);\r\nmutex_unlock(&mgr->lock);\r\nflush_work(&mgr->work);\r\nflush_work(&mgr->destroy_connector_work);\r\n}\r\nint drm_dp_mst_topology_mgr_resume(struct drm_dp_mst_topology_mgr *mgr)\r\n{\r\nint ret = 0;\r\nmutex_lock(&mgr->lock);\r\nif (mgr->mst_primary) {\r\nint sret;\r\nsret = drm_dp_dpcd_read(mgr->aux, DP_DPCD_REV, mgr->dpcd, DP_RECEIVER_CAP_SIZE);\r\nif (sret != DP_RECEIVER_CAP_SIZE) {\r\nDRM_DEBUG_KMS("dpcd read failed - undocked during suspend?\n");\r\nret = -1;\r\ngoto out_unlock;\r\n}\r\nret = drm_dp_dpcd_writeb(mgr->aux, DP_MSTM_CTRL,\r\nDP_MST_EN | DP_UP_REQ_EN | DP_UPSTREAM_IS_SRC);\r\nif (ret < 0) {\r\nDRM_DEBUG_KMS("mst write failed - undocked during suspend?\n");\r\nret = -1;\r\ngoto out_unlock;\r\n}\r\nret = 0;\r\n} else\r\nret = -1;\r\nout_unlock:\r\nmutex_unlock(&mgr->lock);\r\nreturn ret;\r\n}\r\nstatic void drm_dp_get_one_sb_msg(struct drm_dp_mst_topology_mgr *mgr, bool up)\r\n{\r\nint len;\r\nu8 replyblock[32];\r\nint replylen, origlen, curreply;\r\nint ret;\r\nstruct drm_dp_sideband_msg_rx *msg;\r\nint basereg = up ? DP_SIDEBAND_MSG_UP_REQ_BASE : DP_SIDEBAND_MSG_DOWN_REP_BASE;\r\nmsg = up ? &mgr->up_req_recv : &mgr->down_rep_recv;\r\nlen = min(mgr->max_dpcd_transaction_bytes, 16);\r\nret = drm_dp_dpcd_read(mgr->aux, basereg,\r\nreplyblock, len);\r\nif (ret != len) {\r\nDRM_DEBUG_KMS("failed to read DPCD down rep %d %d\n", len, ret);\r\nreturn;\r\n}\r\nret = drm_dp_sideband_msg_build(msg, replyblock, len, true);\r\nif (!ret) {\r\nDRM_DEBUG_KMS("sideband msg build failed %d\n", replyblock[0]);\r\nreturn;\r\n}\r\nreplylen = msg->curchunk_len + msg->curchunk_hdrlen;\r\noriglen = replylen;\r\nreplylen -= len;\r\ncurreply = len;\r\nwhile (replylen > 0) {\r\nlen = min3(replylen, mgr->max_dpcd_transaction_bytes, 16);\r\nret = drm_dp_dpcd_read(mgr->aux, basereg + curreply,\r\nreplyblock, len);\r\nif (ret != len) {\r\nDRM_DEBUG_KMS("failed to read a chunk\n");\r\n}\r\nret = drm_dp_sideband_msg_build(msg, replyblock, len, false);\r\nif (ret == false)\r\nDRM_DEBUG_KMS("failed to build sideband msg\n");\r\ncurreply += len;\r\nreplylen -= len;\r\n}\r\n}\r\nstatic int drm_dp_mst_handle_down_rep(struct drm_dp_mst_topology_mgr *mgr)\r\n{\r\nint ret = 0;\r\ndrm_dp_get_one_sb_msg(mgr, false);\r\nif (mgr->down_rep_recv.have_eomt) {\r\nstruct drm_dp_sideband_msg_tx *txmsg;\r\nstruct drm_dp_mst_branch *mstb;\r\nint slot = -1;\r\nmstb = drm_dp_get_mst_branch_device(mgr,\r\nmgr->down_rep_recv.initial_hdr.lct,\r\nmgr->down_rep_recv.initial_hdr.rad);\r\nif (!mstb) {\r\nDRM_DEBUG_KMS("Got MST reply from unknown device %d\n", mgr->down_rep_recv.initial_hdr.lct);\r\nmemset(&mgr->down_rep_recv, 0, sizeof(struct drm_dp_sideband_msg_rx));\r\nreturn 0;\r\n}\r\nslot = mgr->down_rep_recv.initial_hdr.seqno;\r\nmutex_lock(&mgr->qlock);\r\ntxmsg = mstb->tx_slots[slot];\r\nmutex_unlock(&mgr->qlock);\r\nif (!txmsg) {\r\nDRM_DEBUG_KMS("Got MST reply with no msg %p %d %d %02x %02x\n",\r\nmstb,\r\nmgr->down_rep_recv.initial_hdr.seqno,\r\nmgr->down_rep_recv.initial_hdr.lct,\r\nmgr->down_rep_recv.initial_hdr.rad[0],\r\nmgr->down_rep_recv.msg[0]);\r\ndrm_dp_put_mst_branch_device(mstb);\r\nmemset(&mgr->down_rep_recv, 0, sizeof(struct drm_dp_sideband_msg_rx));\r\nreturn 0;\r\n}\r\ndrm_dp_sideband_parse_reply(&mgr->down_rep_recv, &txmsg->reply);\r\nif (txmsg->reply.reply_type == 1) {\r\nDRM_DEBUG_KMS("Got NAK reply: req 0x%02x, reason 0x%02x, nak data 0x%02x\n", txmsg->reply.req_type, txmsg->reply.u.nak.reason, txmsg->reply.u.nak.nak_data);\r\n}\r\nmemset(&mgr->down_rep_recv, 0, sizeof(struct drm_dp_sideband_msg_rx));\r\ndrm_dp_put_mst_branch_device(mstb);\r\nmutex_lock(&mgr->qlock);\r\ntxmsg->state = DRM_DP_SIDEBAND_TX_RX;\r\nmstb->tx_slots[slot] = NULL;\r\nmutex_unlock(&mgr->qlock);\r\nwake_up(&mgr->tx_waitq);\r\n}\r\nreturn ret;\r\n}\r\nstatic int drm_dp_mst_handle_up_req(struct drm_dp_mst_topology_mgr *mgr)\r\n{\r\nint ret = 0;\r\ndrm_dp_get_one_sb_msg(mgr, true);\r\nif (mgr->up_req_recv.have_eomt) {\r\nstruct drm_dp_sideband_msg_req_body msg;\r\nstruct drm_dp_mst_branch *mstb;\r\nbool seqno;\r\nmstb = drm_dp_get_mst_branch_device(mgr,\r\nmgr->up_req_recv.initial_hdr.lct,\r\nmgr->up_req_recv.initial_hdr.rad);\r\nif (!mstb) {\r\nDRM_DEBUG_KMS("Got MST reply from unknown device %d\n", mgr->up_req_recv.initial_hdr.lct);\r\nmemset(&mgr->up_req_recv, 0, sizeof(struct drm_dp_sideband_msg_rx));\r\nreturn 0;\r\n}\r\nseqno = mgr->up_req_recv.initial_hdr.seqno;\r\ndrm_dp_sideband_parse_req(&mgr->up_req_recv, &msg);\r\nif (msg.req_type == DP_CONNECTION_STATUS_NOTIFY) {\r\ndrm_dp_send_up_ack_reply(mgr, mstb, msg.req_type, seqno, false);\r\ndrm_dp_update_port(mstb, &msg.u.conn_stat);\r\nDRM_DEBUG_KMS("Got CSN: pn: %d ldps:%d ddps: %d mcs: %d ip: %d pdt: %d\n", msg.u.conn_stat.port_number, msg.u.conn_stat.legacy_device_plug_status, msg.u.conn_stat.displayport_device_plug_status, msg.u.conn_stat.message_capability_status, msg.u.conn_stat.input_port, msg.u.conn_stat.peer_device_type);\r\n(*mgr->cbs->hotplug)(mgr);\r\n} else if (msg.req_type == DP_RESOURCE_STATUS_NOTIFY) {\r\ndrm_dp_send_up_ack_reply(mgr, mstb, msg.req_type, seqno, false);\r\nDRM_DEBUG_KMS("Got RSN: pn: %d avail_pbn %d\n", msg.u.resource_stat.port_number, msg.u.resource_stat.available_pbn);\r\n}\r\ndrm_dp_put_mst_branch_device(mstb);\r\nmemset(&mgr->up_req_recv, 0, sizeof(struct drm_dp_sideband_msg_rx));\r\n}\r\nreturn ret;\r\n}\r\nint drm_dp_mst_hpd_irq(struct drm_dp_mst_topology_mgr *mgr, u8 *esi, bool *handled)\r\n{\r\nint ret = 0;\r\nint sc;\r\n*handled = false;\r\nsc = esi[0] & 0x3f;\r\nif (sc != mgr->sink_count) {\r\nmgr->sink_count = sc;\r\n*handled = true;\r\n}\r\nif (esi[1] & DP_DOWN_REP_MSG_RDY) {\r\nret = drm_dp_mst_handle_down_rep(mgr);\r\n*handled = true;\r\n}\r\nif (esi[1] & DP_UP_REQ_MSG_RDY) {\r\nret |= drm_dp_mst_handle_up_req(mgr);\r\n*handled = true;\r\n}\r\ndrm_dp_mst_kick_tx(mgr);\r\nreturn ret;\r\n}\r\nenum drm_connector_status drm_dp_mst_detect_port(struct drm_connector *connector,\r\nstruct drm_dp_mst_topology_mgr *mgr, struct drm_dp_mst_port *port)\r\n{\r\nenum drm_connector_status status = connector_status_disconnected;\r\nport = drm_dp_get_validated_port_ref(mgr, port);\r\nif (!port)\r\nreturn connector_status_disconnected;\r\nif (!port->ddps)\r\ngoto out;\r\nswitch (port->pdt) {\r\ncase DP_PEER_DEVICE_NONE:\r\ncase DP_PEER_DEVICE_MST_BRANCHING:\r\nbreak;\r\ncase DP_PEER_DEVICE_SST_SINK:\r\nstatus = connector_status_connected;\r\nif (port->port_num >= 8 && !port->cached_edid) {\r\nport->cached_edid = drm_get_edid(connector, &port->aux.ddc);\r\n}\r\nbreak;\r\ncase DP_PEER_DEVICE_DP_LEGACY_CONV:\r\nif (port->ldps)\r\nstatus = connector_status_connected;\r\nbreak;\r\n}\r\nout:\r\ndrm_dp_put_port(port);\r\nreturn status;\r\n}\r\nstruct edid *drm_dp_mst_get_edid(struct drm_connector *connector, struct drm_dp_mst_topology_mgr *mgr, struct drm_dp_mst_port *port)\r\n{\r\nstruct edid *edid = NULL;\r\nport = drm_dp_get_validated_port_ref(mgr, port);\r\nif (!port)\r\nreturn NULL;\r\nif (port->cached_edid)\r\nedid = drm_edid_duplicate(port->cached_edid);\r\nelse {\r\nedid = drm_get_edid(connector, &port->aux.ddc);\r\ndrm_mode_connector_set_tile_property(connector);\r\n}\r\ndrm_dp_put_port(port);\r\nreturn edid;\r\n}\r\nint drm_dp_find_vcpi_slots(struct drm_dp_mst_topology_mgr *mgr,\r\nint pbn)\r\n{\r\nint num_slots;\r\nnum_slots = DIV_ROUND_UP(pbn, mgr->pbn_div);\r\nif (num_slots > mgr->avail_slots)\r\nreturn -ENOSPC;\r\nreturn num_slots;\r\n}\r\nstatic int drm_dp_init_vcpi(struct drm_dp_mst_topology_mgr *mgr,\r\nstruct drm_dp_vcpi *vcpi, int pbn)\r\n{\r\nint num_slots;\r\nint ret;\r\nnum_slots = DIV_ROUND_UP(pbn, mgr->pbn_div);\r\nif (num_slots > mgr->avail_slots)\r\nreturn -ENOSPC;\r\nvcpi->pbn = pbn;\r\nvcpi->aligned_pbn = num_slots * mgr->pbn_div;\r\nvcpi->num_slots = num_slots;\r\nret = drm_dp_mst_assign_payload_id(mgr, vcpi);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nbool drm_dp_mst_allocate_vcpi(struct drm_dp_mst_topology_mgr *mgr, struct drm_dp_mst_port *port, int pbn, int *slots)\r\n{\r\nint ret;\r\nport = drm_dp_get_validated_port_ref(mgr, port);\r\nif (!port)\r\nreturn false;\r\nif (port->vcpi.vcpi > 0) {\r\nDRM_DEBUG_KMS("payload: vcpi %d already allocated for pbn %d - requested pbn %d\n", port->vcpi.vcpi, port->vcpi.pbn, pbn);\r\nif (pbn == port->vcpi.pbn) {\r\n*slots = port->vcpi.num_slots;\r\nreturn true;\r\n}\r\n}\r\nret = drm_dp_init_vcpi(mgr, &port->vcpi, pbn);\r\nif (ret) {\r\nDRM_DEBUG_KMS("failed to init vcpi %d %d %d\n", DIV_ROUND_UP(pbn, mgr->pbn_div), mgr->avail_slots, ret);\r\ngoto out;\r\n}\r\nDRM_DEBUG_KMS("initing vcpi for %d %d\n", pbn, port->vcpi.num_slots);\r\n*slots = port->vcpi.num_slots;\r\ndrm_dp_put_port(port);\r\nreturn true;\r\nout:\r\nreturn false;\r\n}\r\nint drm_dp_mst_get_vcpi_slots(struct drm_dp_mst_topology_mgr *mgr, struct drm_dp_mst_port *port)\r\n{\r\nint slots = 0;\r\nport = drm_dp_get_validated_port_ref(mgr, port);\r\nif (!port)\r\nreturn slots;\r\nslots = port->vcpi.num_slots;\r\ndrm_dp_put_port(port);\r\nreturn slots;\r\n}\r\nvoid drm_dp_mst_reset_vcpi_slots(struct drm_dp_mst_topology_mgr *mgr, struct drm_dp_mst_port *port)\r\n{\r\nport = drm_dp_get_validated_port_ref(mgr, port);\r\nif (!port)\r\nreturn;\r\nport->vcpi.num_slots = 0;\r\ndrm_dp_put_port(port);\r\n}\r\nvoid drm_dp_mst_deallocate_vcpi(struct drm_dp_mst_topology_mgr *mgr, struct drm_dp_mst_port *port)\r\n{\r\nport = drm_dp_get_validated_port_ref(mgr, port);\r\nif (!port)\r\nreturn;\r\ndrm_dp_mst_put_payload_id(mgr, port->vcpi.vcpi);\r\nport->vcpi.num_slots = 0;\r\nport->vcpi.pbn = 0;\r\nport->vcpi.aligned_pbn = 0;\r\nport->vcpi.vcpi = 0;\r\ndrm_dp_put_port(port);\r\n}\r\nstatic int drm_dp_dpcd_write_payload(struct drm_dp_mst_topology_mgr *mgr,\r\nint id, struct drm_dp_payload *payload)\r\n{\r\nu8 payload_alloc[3], status;\r\nint ret;\r\nint retries = 0;\r\ndrm_dp_dpcd_writeb(mgr->aux, DP_PAYLOAD_TABLE_UPDATE_STATUS,\r\nDP_PAYLOAD_TABLE_UPDATED);\r\npayload_alloc[0] = id;\r\npayload_alloc[1] = payload->start_slot;\r\npayload_alloc[2] = payload->num_slots;\r\nret = drm_dp_dpcd_write(mgr->aux, DP_PAYLOAD_ALLOCATE_SET, payload_alloc, 3);\r\nif (ret != 3) {\r\nDRM_DEBUG_KMS("failed to write payload allocation %d\n", ret);\r\ngoto fail;\r\n}\r\nretry:\r\nret = drm_dp_dpcd_readb(mgr->aux, DP_PAYLOAD_TABLE_UPDATE_STATUS, &status);\r\nif (ret < 0) {\r\nDRM_DEBUG_KMS("failed to read payload table status %d\n", ret);\r\ngoto fail;\r\n}\r\nif (!(status & DP_PAYLOAD_TABLE_UPDATED)) {\r\nretries++;\r\nif (retries < 20) {\r\nusleep_range(10000, 20000);\r\ngoto retry;\r\n}\r\nDRM_DEBUG_KMS("status not set after read payload table status %d\n", status);\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nret = 0;\r\nfail:\r\nreturn ret;\r\n}\r\nint drm_dp_check_act_status(struct drm_dp_mst_topology_mgr *mgr)\r\n{\r\nu8 status;\r\nint ret;\r\nint count = 0;\r\ndo {\r\nret = drm_dp_dpcd_readb(mgr->aux, DP_PAYLOAD_TABLE_UPDATE_STATUS, &status);\r\nif (ret < 0) {\r\nDRM_DEBUG_KMS("failed to read payload table status %d\n", ret);\r\ngoto fail;\r\n}\r\nif (status & DP_PAYLOAD_ACT_HANDLED)\r\nbreak;\r\ncount++;\r\nudelay(100);\r\n} while (count < 30);\r\nif (!(status & DP_PAYLOAD_ACT_HANDLED)) {\r\nDRM_DEBUG_KMS("failed to get ACT bit %d after %d retries\n", status, count);\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nreturn ret;\r\n}\r\nint drm_dp_calc_pbn_mode(int clock, int bpp)\r\n{\r\nfixed20_12 pix_bw;\r\nfixed20_12 fbpp;\r\nfixed20_12 result;\r\nfixed20_12 margin, tmp;\r\nu32 res;\r\npix_bw.full = dfixed_const(clock);\r\nfbpp.full = dfixed_const(bpp);\r\ntmp.full = dfixed_const(8);\r\nfbpp.full = dfixed_div(fbpp, tmp);\r\nresult.full = dfixed_mul(pix_bw, fbpp);\r\nmargin.full = dfixed_const(54);\r\ntmp.full = dfixed_const(64);\r\nmargin.full = dfixed_div(margin, tmp);\r\nresult.full = dfixed_div(result, margin);\r\nmargin.full = dfixed_const(1006);\r\ntmp.full = dfixed_const(1000);\r\nmargin.full = dfixed_div(margin, tmp);\r\nresult.full = dfixed_mul(result, margin);\r\nresult.full = dfixed_div(result, tmp);\r\nresult.full = dfixed_ceil(result);\r\nres = dfixed_trunc(result);\r\nreturn res;\r\n}\r\nstatic int test_calc_pbn_mode(void)\r\n{\r\nint ret;\r\nret = drm_dp_calc_pbn_mode(154000, 30);\r\nif (ret != 689)\r\nreturn -EINVAL;\r\nret = drm_dp_calc_pbn_mode(234000, 30);\r\nif (ret != 1047)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void drm_dp_mst_kick_tx(struct drm_dp_mst_topology_mgr *mgr)\r\n{\r\nqueue_work(system_long_wq, &mgr->tx_work);\r\n}\r\nstatic void drm_dp_mst_dump_mstb(struct seq_file *m,\r\nstruct drm_dp_mst_branch *mstb)\r\n{\r\nstruct drm_dp_mst_port *port;\r\nint tabs = mstb->lct;\r\nchar prefix[10];\r\nint i;\r\nfor (i = 0; i < tabs; i++)\r\nprefix[i] = '\t';\r\nprefix[i] = '\0';\r\nseq_printf(m, "%smst: %p, %d\n", prefix, mstb, mstb->num_ports);\r\nlist_for_each_entry(port, &mstb->ports, next) {\r\nseq_printf(m, "%sport: %d: ddps: %d ldps: %d, %p, conn: %p\n", prefix, port->port_num, port->ddps, port->ldps, port, port->connector);\r\nif (port->mstb)\r\ndrm_dp_mst_dump_mstb(m, port->mstb);\r\n}\r\n}\r\nstatic bool dump_dp_payload_table(struct drm_dp_mst_topology_mgr *mgr,\r\nchar *buf)\r\n{\r\nint ret;\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nret = drm_dp_dpcd_read(mgr->aux, DP_PAYLOAD_TABLE_UPDATE_STATUS + (i * 16), &buf[i * 16], 16);\r\nif (ret != 16)\r\nbreak;\r\n}\r\nif (i == 4)\r\nreturn true;\r\nreturn false;\r\n}\r\nvoid drm_dp_mst_dump_topology(struct seq_file *m,\r\nstruct drm_dp_mst_topology_mgr *mgr)\r\n{\r\nint i;\r\nstruct drm_dp_mst_port *port;\r\nmutex_lock(&mgr->lock);\r\nif (mgr->mst_primary)\r\ndrm_dp_mst_dump_mstb(m, mgr->mst_primary);\r\nmutex_unlock(&mgr->lock);\r\nmutex_lock(&mgr->payload_lock);\r\nseq_printf(m, "vcpi: %lx %lx\n", mgr->payload_mask, mgr->vcpi_mask);\r\nfor (i = 0; i < mgr->max_payloads; i++) {\r\nif (mgr->proposed_vcpis[i]) {\r\nport = container_of(mgr->proposed_vcpis[i], struct drm_dp_mst_port, vcpi);\r\nseq_printf(m, "vcpi %d: %d %d %d\n", i, port->port_num, port->vcpi.vcpi, port->vcpi.num_slots);\r\n} else\r\nseq_printf(m, "vcpi %d:unsed\n", i);\r\n}\r\nfor (i = 0; i < mgr->max_payloads; i++) {\r\nseq_printf(m, "payload %d: %d, %d, %d\n",\r\ni,\r\nmgr->payloads[i].payload_state,\r\nmgr->payloads[i].start_slot,\r\nmgr->payloads[i].num_slots);\r\n}\r\nmutex_unlock(&mgr->payload_lock);\r\nmutex_lock(&mgr->lock);\r\nif (mgr->mst_primary) {\r\nu8 buf[64];\r\nbool bret;\r\nint ret;\r\nret = drm_dp_dpcd_read(mgr->aux, DP_DPCD_REV, buf, DP_RECEIVER_CAP_SIZE);\r\nseq_printf(m, "dpcd: ");\r\nfor (i = 0; i < DP_RECEIVER_CAP_SIZE; i++)\r\nseq_printf(m, "%02x ", buf[i]);\r\nseq_printf(m, "\n");\r\nret = drm_dp_dpcd_read(mgr->aux, DP_FAUX_CAP, buf, 2);\r\nseq_printf(m, "faux/mst: ");\r\nfor (i = 0; i < 2; i++)\r\nseq_printf(m, "%02x ", buf[i]);\r\nseq_printf(m, "\n");\r\nret = drm_dp_dpcd_read(mgr->aux, DP_MSTM_CTRL, buf, 1);\r\nseq_printf(m, "mst ctrl: ");\r\nfor (i = 0; i < 1; i++)\r\nseq_printf(m, "%02x ", buf[i]);\r\nseq_printf(m, "\n");\r\nret = drm_dp_dpcd_read(mgr->aux, DP_BRANCH_OUI, buf, DP_BRANCH_OUI_HEADER_SIZE);\r\nseq_printf(m, "branch oui: ");\r\nfor (i = 0; i < 0x3; i++)\r\nseq_printf(m, "%02x", buf[i]);\r\nseq_printf(m, " devid: ");\r\nfor (i = 0x3; i < 0x8; i++)\r\nseq_printf(m, "%c", buf[i]);\r\nseq_printf(m, " revision: hw: %x.%x sw: %x.%x", buf[0x9] >> 4, buf[0x9] & 0xf, buf[0xa], buf[0xb]);\r\nseq_printf(m, "\n");\r\nbret = dump_dp_payload_table(mgr, buf);\r\nif (bret == true) {\r\nseq_printf(m, "payload table: ");\r\nfor (i = 0; i < 63; i++)\r\nseq_printf(m, "%02x ", buf[i]);\r\nseq_printf(m, "\n");\r\n}\r\n}\r\nmutex_unlock(&mgr->lock);\r\n}\r\nstatic void drm_dp_tx_work(struct work_struct *work)\r\n{\r\nstruct drm_dp_mst_topology_mgr *mgr = container_of(work, struct drm_dp_mst_topology_mgr, tx_work);\r\nmutex_lock(&mgr->qlock);\r\nif (mgr->tx_down_in_progress)\r\nprocess_single_down_tx_qlock(mgr);\r\nmutex_unlock(&mgr->qlock);\r\n}\r\nstatic void drm_dp_destroy_connector_work(struct work_struct *work)\r\n{\r\nstruct drm_dp_mst_topology_mgr *mgr = container_of(work, struct drm_dp_mst_topology_mgr, destroy_connector_work);\r\nstruct drm_dp_mst_port *port;\r\nbool send_hotplug = false;\r\nfor (;;) {\r\nmutex_lock(&mgr->destroy_connector_lock);\r\nport = list_first_entry_or_null(&mgr->destroy_connector_list, struct drm_dp_mst_port, next);\r\nif (!port) {\r\nmutex_unlock(&mgr->destroy_connector_lock);\r\nbreak;\r\n}\r\nlist_del(&port->next);\r\nmutex_unlock(&mgr->destroy_connector_lock);\r\nmgr->cbs->destroy_connector(mgr, port->connector);\r\ndrm_dp_port_teardown_pdt(port, port->pdt);\r\nif (!port->input && port->vcpi.vcpi > 0)\r\ndrm_dp_mst_put_payload_id(mgr, port->vcpi.vcpi);\r\nkfree(port);\r\nsend_hotplug = true;\r\n}\r\nif (send_hotplug)\r\n(*mgr->cbs->hotplug)(mgr);\r\n}\r\nint drm_dp_mst_topology_mgr_init(struct drm_dp_mst_topology_mgr *mgr,\r\nstruct device *dev, struct drm_dp_aux *aux,\r\nint max_dpcd_transaction_bytes,\r\nint max_payloads, int conn_base_id)\r\n{\r\nmutex_init(&mgr->lock);\r\nmutex_init(&mgr->qlock);\r\nmutex_init(&mgr->payload_lock);\r\nmutex_init(&mgr->destroy_connector_lock);\r\nINIT_LIST_HEAD(&mgr->tx_msg_upq);\r\nINIT_LIST_HEAD(&mgr->tx_msg_downq);\r\nINIT_LIST_HEAD(&mgr->destroy_connector_list);\r\nINIT_WORK(&mgr->work, drm_dp_mst_link_probe_work);\r\nINIT_WORK(&mgr->tx_work, drm_dp_tx_work);\r\nINIT_WORK(&mgr->destroy_connector_work, drm_dp_destroy_connector_work);\r\ninit_waitqueue_head(&mgr->tx_waitq);\r\nmgr->dev = dev;\r\nmgr->aux = aux;\r\nmgr->max_dpcd_transaction_bytes = max_dpcd_transaction_bytes;\r\nmgr->max_payloads = max_payloads;\r\nmgr->conn_base_id = conn_base_id;\r\nmgr->payloads = kcalloc(max_payloads, sizeof(struct drm_dp_payload), GFP_KERNEL);\r\nif (!mgr->payloads)\r\nreturn -ENOMEM;\r\nmgr->proposed_vcpis = kcalloc(max_payloads, sizeof(struct drm_dp_vcpi *), GFP_KERNEL);\r\nif (!mgr->proposed_vcpis)\r\nreturn -ENOMEM;\r\nset_bit(0, &mgr->payload_mask);\r\ntest_calc_pbn_mode();\r\nreturn 0;\r\n}\r\nvoid drm_dp_mst_topology_mgr_destroy(struct drm_dp_mst_topology_mgr *mgr)\r\n{\r\nflush_work(&mgr->work);\r\nflush_work(&mgr->destroy_connector_work);\r\nmutex_lock(&mgr->payload_lock);\r\nkfree(mgr->payloads);\r\nmgr->payloads = NULL;\r\nkfree(mgr->proposed_vcpis);\r\nmgr->proposed_vcpis = NULL;\r\nmutex_unlock(&mgr->payload_lock);\r\nmgr->dev = NULL;\r\nmgr->aux = NULL;\r\n}\r\nstatic int drm_dp_mst_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct drm_dp_aux *aux = adapter->algo_data;\r\nstruct drm_dp_mst_port *port = container_of(aux, struct drm_dp_mst_port, aux);\r\nstruct drm_dp_mst_branch *mstb;\r\nstruct drm_dp_mst_topology_mgr *mgr = port->mgr;\r\nunsigned int i;\r\nbool reading = false;\r\nstruct drm_dp_sideband_msg_req_body msg;\r\nstruct drm_dp_sideband_msg_tx *txmsg = NULL;\r\nint ret;\r\nmstb = drm_dp_get_validated_mstb_ref(mgr, port->parent);\r\nif (!mstb)\r\nreturn -EREMOTEIO;\r\nif (msgs[num - 1].flags & I2C_M_RD)\r\nreading = true;\r\nif (!reading || (num - 1 > DP_REMOTE_I2C_READ_MAX_TRANSACTIONS)) {\r\nDRM_DEBUG_KMS("Unsupported I2C transaction for MST device\n");\r\nret = -EIO;\r\ngoto out;\r\n}\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.req_type = DP_REMOTE_I2C_READ;\r\nmsg.u.i2c_read.num_transactions = num - 1;\r\nmsg.u.i2c_read.port_number = port->port_num;\r\nfor (i = 0; i < num - 1; i++) {\r\nmsg.u.i2c_read.transactions[i].i2c_dev_id = msgs[i].addr;\r\nmsg.u.i2c_read.transactions[i].num_bytes = msgs[i].len;\r\nmsg.u.i2c_read.transactions[i].bytes = msgs[i].buf;\r\n}\r\nmsg.u.i2c_read.read_i2c_device_id = msgs[num - 1].addr;\r\nmsg.u.i2c_read.num_bytes_read = msgs[num - 1].len;\r\ntxmsg = kzalloc(sizeof(*txmsg), GFP_KERNEL);\r\nif (!txmsg) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ntxmsg->dst = mstb;\r\ndrm_dp_encode_sideband_req(&msg, txmsg);\r\ndrm_dp_queue_down_tx(mgr, txmsg);\r\nret = drm_dp_mst_wait_tx_reply(mstb, txmsg);\r\nif (ret > 0) {\r\nif (txmsg->reply.reply_type == 1) {\r\nret = -EREMOTEIO;\r\ngoto out;\r\n}\r\nif (txmsg->reply.u.remote_i2c_read_ack.num_bytes != msgs[num - 1].len) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nmemcpy(msgs[num - 1].buf, txmsg->reply.u.remote_i2c_read_ack.bytes, msgs[num - 1].len);\r\nret = num;\r\n}\r\nout:\r\nkfree(txmsg);\r\ndrm_dp_put_mst_branch_device(mstb);\r\nreturn ret;\r\n}\r\nstatic u32 drm_dp_mst_i2c_functionality(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |\r\nI2C_FUNC_SMBUS_READ_BLOCK_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_PROC_CALL |\r\nI2C_FUNC_10BIT_ADDR;\r\n}\r\nstatic int drm_dp_mst_register_i2c_bus(struct drm_dp_aux *aux)\r\n{\r\naux->ddc.algo = &drm_dp_mst_i2c_algo;\r\naux->ddc.algo_data = aux;\r\naux->ddc.retries = 3;\r\naux->ddc.class = I2C_CLASS_DDC;\r\naux->ddc.owner = THIS_MODULE;\r\naux->ddc.dev.parent = aux->dev;\r\naux->ddc.dev.of_node = aux->dev->of_node;\r\nstrlcpy(aux->ddc.name, aux->name ? aux->name : dev_name(aux->dev),\r\nsizeof(aux->ddc.name));\r\nreturn i2c_add_adapter(&aux->ddc);\r\n}\r\nstatic void drm_dp_mst_unregister_i2c_bus(struct drm_dp_aux *aux)\r\n{\r\ni2c_del_adapter(&aux->ddc);\r\n}
