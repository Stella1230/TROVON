static loff_t\r\nfilelayout_get_dense_offset(struct nfs4_filelayout_segment *flseg,\r\nloff_t offset)\r\n{\r\nu32 stripe_width = flseg->stripe_unit * flseg->dsaddr->stripe_count;\r\nu64 stripe_no;\r\nu32 rem;\r\noffset -= flseg->pattern_offset;\r\nstripe_no = div_u64(offset, stripe_width);\r\ndiv_u64_rem(offset, flseg->stripe_unit, &rem);\r\nreturn stripe_no * flseg->stripe_unit + rem;\r\n}\r\nstatic loff_t\r\nfilelayout_get_dserver_offset(struct pnfs_layout_segment *lseg, loff_t offset)\r\n{\r\nstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\r\nswitch (flseg->stripe_type) {\r\ncase STRIPE_SPARSE:\r\nreturn offset;\r\ncase STRIPE_DENSE:\r\nreturn filelayout_get_dense_offset(flseg, offset);\r\n}\r\nBUG();\r\n}\r\nstatic void filelayout_reset_write(struct nfs_pgio_header *hdr)\r\n{\r\nstruct rpc_task *task = &hdr->task;\r\nif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\r\ndprintk("%s Reset task %5u for i/o through MDS "\r\n"(req %s/%llu, %u bytes @ offset %llu)\n", __func__,\r\nhdr->task.tk_pid,\r\nhdr->inode->i_sb->s_id,\r\n(unsigned long long)NFS_FILEID(hdr->inode),\r\nhdr->args.count,\r\n(unsigned long long)hdr->args.offset);\r\ntask->tk_status = pnfs_write_done_resend_to_mds(hdr);\r\n}\r\n}\r\nstatic void filelayout_reset_read(struct nfs_pgio_header *hdr)\r\n{\r\nstruct rpc_task *task = &hdr->task;\r\nif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\r\ndprintk("%s Reset task %5u for i/o through MDS "\r\n"(req %s/%llu, %u bytes @ offset %llu)\n", __func__,\r\nhdr->task.tk_pid,\r\nhdr->inode->i_sb->s_id,\r\n(unsigned long long)NFS_FILEID(hdr->inode),\r\nhdr->args.count,\r\n(unsigned long long)hdr->args.offset);\r\ntask->tk_status = pnfs_read_done_resend_to_mds(hdr);\r\n}\r\n}\r\nstatic int filelayout_async_handle_error(struct rpc_task *task,\r\nstruct nfs4_state *state,\r\nstruct nfs_client *clp,\r\nstruct pnfs_layout_segment *lseg)\r\n{\r\nstruct pnfs_layout_hdr *lo = lseg->pls_layout;\r\nstruct inode *inode = lo->plh_inode;\r\nstruct nfs_server *mds_server = NFS_SERVER(inode);\r\nstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\r\nstruct nfs_client *mds_client = mds_server->nfs_client;\r\nstruct nfs4_slot_table *tbl = &clp->cl_session->fc_slot_table;\r\nif (task->tk_status >= 0)\r\nreturn 0;\r\nswitch (task->tk_status) {\r\ncase -NFS4ERR_DELEG_REVOKED:\r\ncase -NFS4ERR_ADMIN_REVOKED:\r\ncase -NFS4ERR_BAD_STATEID:\r\ncase -NFS4ERR_OPENMODE:\r\nif (state == NULL)\r\nbreak;\r\nif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\r\ngoto out_bad_stateid;\r\ngoto wait_on_recovery;\r\ncase -NFS4ERR_EXPIRED:\r\nif (state != NULL) {\r\nif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\r\ngoto out_bad_stateid;\r\n}\r\nnfs4_schedule_lease_recovery(mds_client);\r\ngoto wait_on_recovery;\r\ncase -NFS4ERR_BADSESSION:\r\ncase -NFS4ERR_BADSLOT:\r\ncase -NFS4ERR_BAD_HIGH_SLOT:\r\ncase -NFS4ERR_DEADSESSION:\r\ncase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\r\ncase -NFS4ERR_SEQ_FALSE_RETRY:\r\ncase -NFS4ERR_SEQ_MISORDERED:\r\ndprintk("%s ERROR %d, Reset session. Exchangeid "\r\n"flags 0x%x\n", __func__, task->tk_status,\r\nclp->cl_exchange_flags);\r\nnfs4_schedule_session_recovery(clp->cl_session, task->tk_status);\r\nbreak;\r\ncase -NFS4ERR_DELAY:\r\ncase -NFS4ERR_GRACE:\r\nrpc_delay(task, FILELAYOUT_POLL_RETRY_MAX);\r\nbreak;\r\ncase -NFS4ERR_RETRY_UNCACHED_REP:\r\nbreak;\r\ncase -NFS4ERR_PNFS_NO_LAYOUT:\r\ncase -ESTALE:\r\ncase -EBADHANDLE:\r\ncase -EISDIR:\r\ncase -NFS4ERR_FHEXPIRED:\r\ncase -NFS4ERR_WRONG_TYPE:\r\ndprintk("%s Invalid layout error %d\n", __func__,\r\ntask->tk_status);\r\npnfs_destroy_layout(NFS_I(inode));\r\nrpc_wake_up(&tbl->slot_tbl_waitq);\r\ngoto reset;\r\ncase -ECONNREFUSED:\r\ncase -EHOSTDOWN:\r\ncase -EHOSTUNREACH:\r\ncase -ENETUNREACH:\r\ncase -EIO:\r\ncase -ETIMEDOUT:\r\ncase -EPIPE:\r\ndprintk("%s DS connection error %d\n", __func__,\r\ntask->tk_status);\r\nnfs4_mark_deviceid_unavailable(devid);\r\npnfs_error_mark_layout_for_return(inode, lseg);\r\nrpc_wake_up(&tbl->slot_tbl_waitq);\r\ndefault:\r\nreset:\r\ndprintk("%s Retry through MDS. Error %d\n", __func__,\r\ntask->tk_status);\r\nreturn -NFS4ERR_RESET_TO_MDS;\r\n}\r\nout:\r\ntask->tk_status = 0;\r\nreturn -EAGAIN;\r\nout_bad_stateid:\r\ntask->tk_status = -EIO;\r\nreturn 0;\r\nwait_on_recovery:\r\nrpc_sleep_on(&mds_client->cl_rpcwaitq, task, NULL);\r\nif (test_bit(NFS4CLNT_MANAGER_RUNNING, &mds_client->cl_state) == 0)\r\nrpc_wake_up_queued_task(&mds_client->cl_rpcwaitq, task);\r\ngoto out;\r\n}\r\nstatic int filelayout_read_done_cb(struct rpc_task *task,\r\nstruct nfs_pgio_header *hdr)\r\n{\r\nint err;\r\ntrace_nfs4_pnfs_read(hdr, task->tk_status);\r\nerr = filelayout_async_handle_error(task, hdr->args.context->state,\r\nhdr->ds_clp, hdr->lseg);\r\nswitch (err) {\r\ncase -NFS4ERR_RESET_TO_MDS:\r\nfilelayout_reset_read(hdr);\r\nreturn task->tk_status;\r\ncase -EAGAIN:\r\nrpc_restart_call_prepare(task);\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nfilelayout_set_layoutcommit(struct nfs_pgio_header *hdr)\r\n{\r\nif (FILELAYOUT_LSEG(hdr->lseg)->commit_through_mds ||\r\nhdr->res.verf->committed != NFS_DATA_SYNC)\r\nreturn;\r\npnfs_set_layoutcommit(hdr->inode, hdr->lseg,\r\nhdr->mds_offset + hdr->res.count);\r\ndprintk("%s inode %lu pls_end_pos %lu\n", __func__, hdr->inode->i_ino,\r\n(unsigned long) NFS_I(hdr->inode)->layout->plh_lwb);\r\n}\r\nbool\r\nfilelayout_test_devid_unavailable(struct nfs4_deviceid_node *node)\r\n{\r\nreturn filelayout_test_devid_invalid(node) ||\r\nnfs4_test_deviceid_unavailable(node);\r\n}\r\nstatic bool\r\nfilelayout_reset_to_mds(struct pnfs_layout_segment *lseg)\r\n{\r\nstruct nfs4_deviceid_node *node = FILELAYOUT_DEVID_NODE(lseg);\r\nreturn filelayout_test_devid_unavailable(node);\r\n}\r\nstatic void filelayout_read_prepare(struct rpc_task *task, void *data)\r\n{\r\nstruct nfs_pgio_header *hdr = data;\r\nif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\r\nrpc_exit(task, -EIO);\r\nreturn;\r\n}\r\nif (filelayout_reset_to_mds(hdr->lseg)) {\r\ndprintk("%s task %u reset io to MDS\n", __func__, task->tk_pid);\r\nfilelayout_reset_read(hdr);\r\nrpc_exit(task, 0);\r\nreturn;\r\n}\r\nhdr->pgio_done_cb = filelayout_read_done_cb;\r\nif (nfs41_setup_sequence(hdr->ds_clp->cl_session,\r\n&hdr->args.seq_args,\r\n&hdr->res.seq_res,\r\ntask))\r\nreturn;\r\nif (nfs4_set_rw_stateid(&hdr->args.stateid, hdr->args.context,\r\nhdr->args.lock_context, FMODE_READ) == -EIO)\r\nrpc_exit(task, -EIO);\r\n}\r\nstatic void filelayout_read_call_done(struct rpc_task *task, void *data)\r\n{\r\nstruct nfs_pgio_header *hdr = data;\r\ndprintk("--> %s task->tk_status %d\n", __func__, task->tk_status);\r\nif (test_bit(NFS_IOHDR_REDO, &hdr->flags) &&\r\ntask->tk_status == 0) {\r\nnfs41_sequence_done(task, &hdr->res.seq_res);\r\nreturn;\r\n}\r\nhdr->mds_ops->rpc_call_done(task, data);\r\n}\r\nstatic void filelayout_read_count_stats(struct rpc_task *task, void *data)\r\n{\r\nstruct nfs_pgio_header *hdr = data;\r\nrpc_count_iostats(task, NFS_SERVER(hdr->inode)->client->cl_metrics);\r\n}\r\nstatic int filelayout_write_done_cb(struct rpc_task *task,\r\nstruct nfs_pgio_header *hdr)\r\n{\r\nint err;\r\ntrace_nfs4_pnfs_write(hdr, task->tk_status);\r\nerr = filelayout_async_handle_error(task, hdr->args.context->state,\r\nhdr->ds_clp, hdr->lseg);\r\nswitch (err) {\r\ncase -NFS4ERR_RESET_TO_MDS:\r\nfilelayout_reset_write(hdr);\r\nreturn task->tk_status;\r\ncase -EAGAIN:\r\nrpc_restart_call_prepare(task);\r\nreturn -EAGAIN;\r\n}\r\nfilelayout_set_layoutcommit(hdr);\r\nreturn 0;\r\n}\r\nstatic int filelayout_commit_done_cb(struct rpc_task *task,\r\nstruct nfs_commit_data *data)\r\n{\r\nint err;\r\ntrace_nfs4_pnfs_commit_ds(data, task->tk_status);\r\nerr = filelayout_async_handle_error(task, NULL, data->ds_clp,\r\ndata->lseg);\r\nswitch (err) {\r\ncase -NFS4ERR_RESET_TO_MDS:\r\npnfs_generic_prepare_to_resend_writes(data);\r\nreturn -EAGAIN;\r\ncase -EAGAIN:\r\nrpc_restart_call_prepare(task);\r\nreturn -EAGAIN;\r\n}\r\nif (data->verf.committed == NFS_UNSTABLE)\r\npnfs_set_layoutcommit(data->inode, data->lseg, data->lwb);\r\nreturn 0;\r\n}\r\nstatic void filelayout_write_prepare(struct rpc_task *task, void *data)\r\n{\r\nstruct nfs_pgio_header *hdr = data;\r\nif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\r\nrpc_exit(task, -EIO);\r\nreturn;\r\n}\r\nif (filelayout_reset_to_mds(hdr->lseg)) {\r\ndprintk("%s task %u reset io to MDS\n", __func__, task->tk_pid);\r\nfilelayout_reset_write(hdr);\r\nrpc_exit(task, 0);\r\nreturn;\r\n}\r\nif (nfs41_setup_sequence(hdr->ds_clp->cl_session,\r\n&hdr->args.seq_args,\r\n&hdr->res.seq_res,\r\ntask))\r\nreturn;\r\nif (nfs4_set_rw_stateid(&hdr->args.stateid, hdr->args.context,\r\nhdr->args.lock_context, FMODE_WRITE) == -EIO)\r\nrpc_exit(task, -EIO);\r\n}\r\nstatic void filelayout_write_call_done(struct rpc_task *task, void *data)\r\n{\r\nstruct nfs_pgio_header *hdr = data;\r\nif (test_bit(NFS_IOHDR_REDO, &hdr->flags) &&\r\ntask->tk_status == 0) {\r\nnfs41_sequence_done(task, &hdr->res.seq_res);\r\nreturn;\r\n}\r\nhdr->mds_ops->rpc_call_done(task, data);\r\n}\r\nstatic void filelayout_write_count_stats(struct rpc_task *task, void *data)\r\n{\r\nstruct nfs_pgio_header *hdr = data;\r\nrpc_count_iostats(task, NFS_SERVER(hdr->inode)->client->cl_metrics);\r\n}\r\nstatic void filelayout_commit_prepare(struct rpc_task *task, void *data)\r\n{\r\nstruct nfs_commit_data *wdata = data;\r\nnfs41_setup_sequence(wdata->ds_clp->cl_session,\r\n&wdata->args.seq_args,\r\n&wdata->res.seq_res,\r\ntask);\r\n}\r\nstatic void filelayout_commit_count_stats(struct rpc_task *task, void *data)\r\n{\r\nstruct nfs_commit_data *cdata = data;\r\nrpc_count_iostats(task, NFS_SERVER(cdata->inode)->client->cl_metrics);\r\n}\r\nstatic enum pnfs_try_status\r\nfilelayout_read_pagelist(struct nfs_pgio_header *hdr)\r\n{\r\nstruct pnfs_layout_segment *lseg = hdr->lseg;\r\nstruct nfs4_pnfs_ds *ds;\r\nstruct rpc_clnt *ds_clnt;\r\nloff_t offset = hdr->args.offset;\r\nu32 j, idx;\r\nstruct nfs_fh *fh;\r\ndprintk("--> %s ino %lu pgbase %u req %Zu@%llu\n",\r\n__func__, hdr->inode->i_ino,\r\nhdr->args.pgbase, (size_t)hdr->args.count, offset);\r\nj = nfs4_fl_calc_j_index(lseg, offset);\r\nidx = nfs4_fl_calc_ds_index(lseg, j);\r\nds = nfs4_fl_prepare_ds(lseg, idx);\r\nif (!ds)\r\nreturn PNFS_NOT_ATTEMPTED;\r\nds_clnt = nfs4_find_or_create_ds_client(ds->ds_clp, hdr->inode);\r\nif (IS_ERR(ds_clnt))\r\nreturn PNFS_NOT_ATTEMPTED;\r\ndprintk("%s USE DS: %s cl_count %d\n", __func__,\r\nds->ds_remotestr, atomic_read(&ds->ds_clp->cl_count));\r\natomic_inc(&ds->ds_clp->cl_count);\r\nhdr->ds_clp = ds->ds_clp;\r\nhdr->ds_commit_idx = idx;\r\nfh = nfs4_fl_select_ds_fh(lseg, j);\r\nif (fh)\r\nhdr->args.fh = fh;\r\nhdr->args.offset = filelayout_get_dserver_offset(lseg, offset);\r\nhdr->mds_offset = offset;\r\nnfs_initiate_pgio(ds_clnt, hdr, hdr->cred,\r\nNFS_PROTO(hdr->inode), &filelayout_read_call_ops,\r\n0, RPC_TASK_SOFTCONN);\r\nreturn PNFS_ATTEMPTED;\r\n}\r\nstatic enum pnfs_try_status\r\nfilelayout_write_pagelist(struct nfs_pgio_header *hdr, int sync)\r\n{\r\nstruct pnfs_layout_segment *lseg = hdr->lseg;\r\nstruct nfs4_pnfs_ds *ds;\r\nstruct rpc_clnt *ds_clnt;\r\nloff_t offset = hdr->args.offset;\r\nu32 j, idx;\r\nstruct nfs_fh *fh;\r\nj = nfs4_fl_calc_j_index(lseg, offset);\r\nidx = nfs4_fl_calc_ds_index(lseg, j);\r\nds = nfs4_fl_prepare_ds(lseg, idx);\r\nif (!ds)\r\nreturn PNFS_NOT_ATTEMPTED;\r\nds_clnt = nfs4_find_or_create_ds_client(ds->ds_clp, hdr->inode);\r\nif (IS_ERR(ds_clnt))\r\nreturn PNFS_NOT_ATTEMPTED;\r\ndprintk("%s ino %lu sync %d req %Zu@%llu DS: %s cl_count %d\n",\r\n__func__, hdr->inode->i_ino, sync, (size_t) hdr->args.count,\r\noffset, ds->ds_remotestr, atomic_read(&ds->ds_clp->cl_count));\r\nhdr->pgio_done_cb = filelayout_write_done_cb;\r\natomic_inc(&ds->ds_clp->cl_count);\r\nhdr->ds_clp = ds->ds_clp;\r\nhdr->ds_commit_idx = idx;\r\nfh = nfs4_fl_select_ds_fh(lseg, j);\r\nif (fh)\r\nhdr->args.fh = fh;\r\nhdr->args.offset = filelayout_get_dserver_offset(lseg, offset);\r\nnfs_initiate_pgio(ds_clnt, hdr, hdr->cred,\r\nNFS_PROTO(hdr->inode), &filelayout_write_call_ops,\r\nsync, RPC_TASK_SOFTCONN);\r\nreturn PNFS_ATTEMPTED;\r\n}\r\nstatic int\r\nfilelayout_check_layout(struct pnfs_layout_hdr *lo,\r\nstruct nfs4_filelayout_segment *fl,\r\nstruct nfs4_layoutget_res *lgr,\r\nstruct nfs4_deviceid *id,\r\ngfp_t gfp_flags)\r\n{\r\nstruct nfs4_deviceid_node *d;\r\nstruct nfs4_file_layout_dsaddr *dsaddr;\r\nint status = -EINVAL;\r\ndprintk("--> %s\n", __func__);\r\nif (lgr->range.offset != 0 ||\r\nlgr->range.length != NFS4_MAX_UINT64) {\r\ndprintk("%s Only whole file layouts supported. Use MDS i/o\n",\r\n__func__);\r\ngoto out;\r\n}\r\nif (fl->pattern_offset > lgr->range.offset) {\r\ndprintk("%s pattern_offset %lld too large\n",\r\n__func__, fl->pattern_offset);\r\ngoto out;\r\n}\r\nif (!fl->stripe_unit) {\r\ndprintk("%s Invalid stripe unit (%u)\n",\r\n__func__, fl->stripe_unit);\r\ngoto out;\r\n}\r\nd = nfs4_find_get_deviceid(NFS_SERVER(lo->plh_inode), id,\r\nlo->plh_lc_cred, gfp_flags);\r\nif (d == NULL)\r\ngoto out;\r\ndsaddr = container_of(d, struct nfs4_file_layout_dsaddr, id_node);\r\nif (filelayout_test_devid_unavailable(&dsaddr->id_node))\r\ngoto out_put;\r\nfl->dsaddr = dsaddr;\r\nif (fl->first_stripe_index >= dsaddr->stripe_count) {\r\ndprintk("%s Bad first_stripe_index %u\n",\r\n__func__, fl->first_stripe_index);\r\ngoto out_put;\r\n}\r\nif ((fl->stripe_type == STRIPE_SPARSE &&\r\nfl->num_fh > 1 && fl->num_fh != dsaddr->ds_num) ||\r\n(fl->stripe_type == STRIPE_DENSE &&\r\nfl->num_fh != dsaddr->stripe_count)) {\r\ndprintk("%s num_fh %u not valid for given packing\n",\r\n__func__, fl->num_fh);\r\ngoto out_put;\r\n}\r\nstatus = 0;\r\nout:\r\ndprintk("--> %s returns %d\n", __func__, status);\r\nreturn status;\r\nout_put:\r\nnfs4_fl_put_deviceid(dsaddr);\r\ngoto out;\r\n}\r\nstatic void _filelayout_free_lseg(struct nfs4_filelayout_segment *fl)\r\n{\r\nint i;\r\nif (fl->fh_array) {\r\nfor (i = 0; i < fl->num_fh; i++) {\r\nif (!fl->fh_array[i])\r\nbreak;\r\nkfree(fl->fh_array[i]);\r\n}\r\nkfree(fl->fh_array);\r\n}\r\nkfree(fl);\r\n}\r\nstatic int\r\nfilelayout_decode_layout(struct pnfs_layout_hdr *flo,\r\nstruct nfs4_filelayout_segment *fl,\r\nstruct nfs4_layoutget_res *lgr,\r\nstruct nfs4_deviceid *id,\r\ngfp_t gfp_flags)\r\n{\r\nstruct xdr_stream stream;\r\nstruct xdr_buf buf;\r\nstruct page *scratch;\r\n__be32 *p;\r\nuint32_t nfl_util;\r\nint i;\r\ndprintk("%s: set_layout_map Begin\n", __func__);\r\nscratch = alloc_page(gfp_flags);\r\nif (!scratch)\r\nreturn -ENOMEM;\r\nxdr_init_decode_pages(&stream, &buf, lgr->layoutp->pages, lgr->layoutp->len);\r\nxdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\r\np = xdr_inline_decode(&stream, NFS4_DEVICEID4_SIZE + 20);\r\nif (unlikely(!p))\r\ngoto out_err;\r\nmemcpy(id, p, sizeof(*id));\r\np += XDR_QUADLEN(NFS4_DEVICEID4_SIZE);\r\nnfs4_print_deviceid(id);\r\nnfl_util = be32_to_cpup(p++);\r\nif (nfl_util & NFL4_UFLG_COMMIT_THRU_MDS)\r\nfl->commit_through_mds = 1;\r\nif (nfl_util & NFL4_UFLG_DENSE)\r\nfl->stripe_type = STRIPE_DENSE;\r\nelse\r\nfl->stripe_type = STRIPE_SPARSE;\r\nfl->stripe_unit = nfl_util & ~NFL4_UFLG_MASK;\r\nfl->first_stripe_index = be32_to_cpup(p++);\r\np = xdr_decode_hyper(p, &fl->pattern_offset);\r\nfl->num_fh = be32_to_cpup(p++);\r\ndprintk("%s: nfl_util 0x%X num_fh %u fsi %u po %llu\n",\r\n__func__, nfl_util, fl->num_fh, fl->first_stripe_index,\r\nfl->pattern_offset);\r\nif (fl->num_fh >\r\nmax(NFS4_PNFS_MAX_STRIPE_CNT, NFS4_PNFS_MAX_MULTI_CNT))\r\ngoto out_err;\r\nif (fl->num_fh > 0) {\r\nfl->fh_array = kcalloc(fl->num_fh, sizeof(fl->fh_array[0]),\r\ngfp_flags);\r\nif (!fl->fh_array)\r\ngoto out_err;\r\n}\r\nfor (i = 0; i < fl->num_fh; i++) {\r\nfl->fh_array[i] = kmalloc(sizeof(struct nfs_fh), gfp_flags);\r\nif (!fl->fh_array[i])\r\ngoto out_err;\r\np = xdr_inline_decode(&stream, 4);\r\nif (unlikely(!p))\r\ngoto out_err;\r\nfl->fh_array[i]->size = be32_to_cpup(p++);\r\nif (sizeof(struct nfs_fh) < fl->fh_array[i]->size) {\r\nprintk(KERN_ERR "NFS: Too big fh %d received %d\n",\r\ni, fl->fh_array[i]->size);\r\ngoto out_err;\r\n}\r\np = xdr_inline_decode(&stream, fl->fh_array[i]->size);\r\nif (unlikely(!p))\r\ngoto out_err;\r\nmemcpy(fl->fh_array[i]->data, p, fl->fh_array[i]->size);\r\ndprintk("DEBUG: %s: fh len %d\n", __func__,\r\nfl->fh_array[i]->size);\r\n}\r\n__free_page(scratch);\r\nreturn 0;\r\nout_err:\r\n__free_page(scratch);\r\nreturn -EIO;\r\n}\r\nstatic void\r\nfilelayout_free_lseg(struct pnfs_layout_segment *lseg)\r\n{\r\nstruct nfs4_filelayout_segment *fl = FILELAYOUT_LSEG(lseg);\r\ndprintk("--> %s\n", __func__);\r\nnfs4_fl_put_deviceid(fl->dsaddr);\r\nif (lseg->pls_range.iomode == IOMODE_RW) {\r\nstruct nfs4_filelayout *flo;\r\nflo = FILELAYOUT_FROM_HDR(lseg->pls_layout);\r\nflo->commit_info.nbuckets = 0;\r\nkfree(flo->commit_info.buckets);\r\nflo->commit_info.buckets = NULL;\r\n}\r\n_filelayout_free_lseg(fl);\r\n}\r\nstatic int\r\nfilelayout_alloc_commit_info(struct pnfs_layout_segment *lseg,\r\nstruct nfs_commit_info *cinfo,\r\ngfp_t gfp_flags)\r\n{\r\nstruct nfs4_filelayout_segment *fl = FILELAYOUT_LSEG(lseg);\r\nstruct pnfs_commit_bucket *buckets;\r\nint size, i;\r\nif (fl->commit_through_mds)\r\nreturn 0;\r\nsize = (fl->stripe_type == STRIPE_SPARSE) ?\r\nfl->dsaddr->ds_num : fl->dsaddr->stripe_count;\r\nif (cinfo->ds->nbuckets >= size) {\r\nreturn 0;\r\n}\r\nbuckets = kcalloc(size, sizeof(struct pnfs_commit_bucket),\r\ngfp_flags);\r\nif (!buckets)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < size; i++) {\r\nINIT_LIST_HEAD(&buckets[i].written);\r\nINIT_LIST_HEAD(&buckets[i].committing);\r\nbuckets[i].direct_verf.committed = NFS_INVALID_STABLE_HOW;\r\n}\r\nspin_lock(cinfo->lock);\r\nif (cinfo->ds->nbuckets >= size)\r\ngoto out;\r\nfor (i = 0; i < cinfo->ds->nbuckets; i++) {\r\nlist_splice(&cinfo->ds->buckets[i].written,\r\n&buckets[i].written);\r\nlist_splice(&cinfo->ds->buckets[i].committing,\r\n&buckets[i].committing);\r\nbuckets[i].direct_verf.committed =\r\ncinfo->ds->buckets[i].direct_verf.committed;\r\nbuckets[i].wlseg = cinfo->ds->buckets[i].wlseg;\r\nbuckets[i].clseg = cinfo->ds->buckets[i].clseg;\r\n}\r\nswap(cinfo->ds->buckets, buckets);\r\ncinfo->ds->nbuckets = size;\r\nout:\r\nspin_unlock(cinfo->lock);\r\nkfree(buckets);\r\nreturn 0;\r\n}\r\nstatic struct pnfs_layout_segment *\r\nfilelayout_alloc_lseg(struct pnfs_layout_hdr *layoutid,\r\nstruct nfs4_layoutget_res *lgr,\r\ngfp_t gfp_flags)\r\n{\r\nstruct nfs4_filelayout_segment *fl;\r\nint rc;\r\nstruct nfs4_deviceid id;\r\ndprintk("--> %s\n", __func__);\r\nfl = kzalloc(sizeof(*fl), gfp_flags);\r\nif (!fl)\r\nreturn NULL;\r\nrc = filelayout_decode_layout(layoutid, fl, lgr, &id, gfp_flags);\r\nif (rc != 0 || filelayout_check_layout(layoutid, fl, lgr, &id, gfp_flags)) {\r\n_filelayout_free_lseg(fl);\r\nreturn NULL;\r\n}\r\nreturn &fl->generic_hdr;\r\n}\r\nstatic size_t\r\nfilelayout_pg_test(struct nfs_pageio_descriptor *pgio, struct nfs_page *prev,\r\nstruct nfs_page *req)\r\n{\r\nunsigned int size;\r\nu64 p_stripe, r_stripe;\r\nu32 stripe_offset;\r\nu64 segment_offset = pgio->pg_lseg->pls_range.offset;\r\nu32 stripe_unit = FILELAYOUT_LSEG(pgio->pg_lseg)->stripe_unit;\r\nsize = pnfs_generic_pg_test(pgio, prev, req);\r\nif (!size)\r\nreturn 0;\r\nif (prev) {\r\np_stripe = (u64)req_offset(prev) - segment_offset;\r\nr_stripe = (u64)req_offset(req) - segment_offset;\r\ndo_div(p_stripe, stripe_unit);\r\ndo_div(r_stripe, stripe_unit);\r\nif (p_stripe != r_stripe)\r\nreturn 0;\r\n}\r\ndiv_u64_rem((u64)req_offset(req) - segment_offset,\r\nstripe_unit,\r\n&stripe_offset);\r\nWARN_ON_ONCE(stripe_offset > stripe_unit);\r\nif (stripe_offset >= stripe_unit)\r\nreturn 0;\r\nreturn min(stripe_unit - (unsigned int)stripe_offset, size);\r\n}\r\nstatic void\r\nfilelayout_pg_init_read(struct nfs_pageio_descriptor *pgio,\r\nstruct nfs_page *req)\r\n{\r\nif (!pgio->pg_lseg)\r\npgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\r\nreq->wb_context,\r\n0,\r\nNFS4_MAX_UINT64,\r\nIOMODE_READ,\r\nGFP_KERNEL);\r\nif (pgio->pg_lseg == NULL)\r\nnfs_pageio_reset_read_mds(pgio);\r\n}\r\nstatic void\r\nfilelayout_pg_init_write(struct nfs_pageio_descriptor *pgio,\r\nstruct nfs_page *req)\r\n{\r\nstruct nfs_commit_info cinfo;\r\nint status;\r\nif (!pgio->pg_lseg)\r\npgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\r\nreq->wb_context,\r\n0,\r\nNFS4_MAX_UINT64,\r\nIOMODE_RW,\r\nGFP_NOFS);\r\nif (pgio->pg_lseg == NULL)\r\ngoto out_mds;\r\nnfs_init_cinfo(&cinfo, pgio->pg_inode, pgio->pg_dreq);\r\nstatus = filelayout_alloc_commit_info(pgio->pg_lseg, &cinfo, GFP_NOFS);\r\nif (status < 0) {\r\npnfs_put_lseg(pgio->pg_lseg);\r\npgio->pg_lseg = NULL;\r\ngoto out_mds;\r\n}\r\nreturn;\r\nout_mds:\r\nnfs_pageio_reset_write_mds(pgio);\r\n}\r\nstatic u32 select_bucket_index(struct nfs4_filelayout_segment *fl, u32 j)\r\n{\r\nif (fl->stripe_type == STRIPE_SPARSE)\r\nreturn nfs4_fl_calc_ds_index(&fl->generic_hdr, j);\r\nelse\r\nreturn j;\r\n}\r\nstatic void\r\nfilelayout_mark_request_commit(struct nfs_page *req,\r\nstruct pnfs_layout_segment *lseg,\r\nstruct nfs_commit_info *cinfo,\r\nu32 ds_commit_idx)\r\n{\r\nstruct nfs4_filelayout_segment *fl = FILELAYOUT_LSEG(lseg);\r\nu32 i, j;\r\nif (fl->commit_through_mds) {\r\nnfs_request_add_commit_list(req, &cinfo->mds->list, cinfo);\r\n} else {\r\nj = nfs4_fl_calc_j_index(lseg, req_offset(req));\r\ni = select_bucket_index(fl, j);\r\npnfs_layout_mark_request_commit(req, lseg, cinfo, i);\r\n}\r\n}\r\nstatic u32 calc_ds_index_from_commit(struct pnfs_layout_segment *lseg, u32 i)\r\n{\r\nstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\r\nif (flseg->stripe_type == STRIPE_SPARSE)\r\nreturn i;\r\nelse\r\nreturn nfs4_fl_calc_ds_index(lseg, i);\r\n}\r\nstatic struct nfs_fh *\r\nselect_ds_fh_from_commit(struct pnfs_layout_segment *lseg, u32 i)\r\n{\r\nstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\r\nif (flseg->stripe_type == STRIPE_SPARSE) {\r\nif (flseg->num_fh == 1)\r\ni = 0;\r\nelse if (flseg->num_fh == 0)\r\nreturn NULL;\r\n}\r\nreturn flseg->fh_array[i];\r\n}\r\nstatic int filelayout_initiate_commit(struct nfs_commit_data *data, int how)\r\n{\r\nstruct pnfs_layout_segment *lseg = data->lseg;\r\nstruct nfs4_pnfs_ds *ds;\r\nstruct rpc_clnt *ds_clnt;\r\nu32 idx;\r\nstruct nfs_fh *fh;\r\nidx = calc_ds_index_from_commit(lseg, data->ds_commit_index);\r\nds = nfs4_fl_prepare_ds(lseg, idx);\r\nif (!ds)\r\ngoto out_err;\r\nds_clnt = nfs4_find_or_create_ds_client(ds->ds_clp, data->inode);\r\nif (IS_ERR(ds_clnt))\r\ngoto out_err;\r\ndprintk("%s ino %lu, how %d cl_count %d\n", __func__,\r\ndata->inode->i_ino, how, atomic_read(&ds->ds_clp->cl_count));\r\ndata->commit_done_cb = filelayout_commit_done_cb;\r\natomic_inc(&ds->ds_clp->cl_count);\r\ndata->ds_clp = ds->ds_clp;\r\nfh = select_ds_fh_from_commit(lseg, data->ds_commit_index);\r\nif (fh)\r\ndata->args.fh = fh;\r\nreturn nfs_initiate_commit(ds_clnt, data, NFS_PROTO(data->inode),\r\n&filelayout_commit_call_ops, how,\r\nRPC_TASK_SOFTCONN);\r\nout_err:\r\npnfs_generic_prepare_to_resend_writes(data);\r\npnfs_generic_commit_release(data);\r\nreturn -EAGAIN;\r\n}\r\nstatic struct nfs_page *\r\nfilelayout_search_commit_reqs(struct nfs_commit_info *cinfo, struct page *page)\r\n{\r\nstruct nfs_page *freq, *t;\r\nstruct pnfs_commit_bucket *b;\r\nint i;\r\nfor (i = 0, b = cinfo->ds->buckets; i < cinfo->ds->nbuckets; i++, b++) {\r\nlist_for_each_entry_safe(freq, t, &b->written, wb_list) {\r\nif (freq->wb_page == page)\r\nreturn freq->wb_head;\r\n}\r\nlist_for_each_entry_safe(freq, t, &b->committing, wb_list) {\r\nif (freq->wb_page == page)\r\nreturn freq->wb_head;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nfilelayout_commit_pagelist(struct inode *inode, struct list_head *mds_pages,\r\nint how, struct nfs_commit_info *cinfo)\r\n{\r\nreturn pnfs_generic_commit_pagelist(inode, mds_pages, how, cinfo,\r\nfilelayout_initiate_commit);\r\n}\r\nstatic struct nfs4_deviceid_node *\r\nfilelayout_alloc_deviceid_node(struct nfs_server *server,\r\nstruct pnfs_device *pdev, gfp_t gfp_flags)\r\n{\r\nstruct nfs4_file_layout_dsaddr *dsaddr;\r\ndsaddr = nfs4_fl_alloc_deviceid_node(server, pdev, gfp_flags);\r\nif (!dsaddr)\r\nreturn NULL;\r\nreturn &dsaddr->id_node;\r\n}\r\nstatic void\r\nfilelayout_free_deviceid_node(struct nfs4_deviceid_node *d)\r\n{\r\nnfs4_fl_free_deviceid(container_of(d, struct nfs4_file_layout_dsaddr, id_node));\r\n}\r\nstatic struct pnfs_layout_hdr *\r\nfilelayout_alloc_layout_hdr(struct inode *inode, gfp_t gfp_flags)\r\n{\r\nstruct nfs4_filelayout *flo;\r\nflo = kzalloc(sizeof(*flo), gfp_flags);\r\nreturn flo != NULL ? &flo->generic_hdr : NULL;\r\n}\r\nstatic void\r\nfilelayout_free_layout_hdr(struct pnfs_layout_hdr *lo)\r\n{\r\nkfree(FILELAYOUT_FROM_HDR(lo));\r\n}\r\nstatic struct pnfs_ds_commit_info *\r\nfilelayout_get_ds_info(struct inode *inode)\r\n{\r\nstruct pnfs_layout_hdr *layout = NFS_I(inode)->layout;\r\nif (layout == NULL)\r\nreturn NULL;\r\nelse\r\nreturn &FILELAYOUT_FROM_HDR(layout)->commit_info;\r\n}\r\nstatic int __init nfs4filelayout_init(void)\r\n{\r\nprintk(KERN_INFO "%s: NFSv4 File Layout Driver Registering...\n",\r\n__func__);\r\nreturn pnfs_register_layoutdriver(&filelayout_type);\r\n}\r\nstatic void __exit nfs4filelayout_exit(void)\r\n{\r\nprintk(KERN_INFO "%s: NFSv4 File Layout Driver Unregistering...\n",\r\n__func__);\r\npnfs_unregister_layoutdriver(&filelayout_type);\r\n}
