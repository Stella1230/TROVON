static int nd_region_probe(struct device *dev)\r\n{\r\nint err, rc;\r\nstatic unsigned long once;\r\nstruct nd_region_namespaces *num_ns;\r\nstruct nd_region *nd_region = to_nd_region(dev);\r\nif (nd_region->num_lanes > num_online_cpus()\r\n&& nd_region->num_lanes < num_possible_cpus()\r\n&& !test_and_set_bit(0, &once)) {\r\ndev_info(dev, "online cpus (%d) < concurrent i/o lanes (%d) < possible cpus (%d)\n",\r\nnum_online_cpus(), nd_region->num_lanes,\r\nnum_possible_cpus());\r\ndev_info(dev, "setting nr_cpus=%d may yield better libnvdimm device performance\n",\r\nnd_region->num_lanes);\r\n}\r\nrc = nd_blk_region_init(nd_region);\r\nif (rc)\r\nreturn rc;\r\nrc = nd_region_register_namespaces(nd_region, &err);\r\nnum_ns = devm_kzalloc(dev, sizeof(*num_ns), GFP_KERNEL);\r\nif (!num_ns)\r\nreturn -ENOMEM;\r\nif (rc < 0)\r\nreturn rc;\r\nnum_ns->active = rc;\r\nnum_ns->count = rc + err;\r\ndev_set_drvdata(dev, num_ns);\r\nif (rc && err && rc == err)\r\nreturn -ENODEV;\r\nnd_region->btt_seed = nd_btt_create(nd_region);\r\nnd_region->pfn_seed = nd_pfn_create(nd_region);\r\nif (err == 0)\r\nreturn 0;\r\ndev_err(dev, "failed to register %d namespace%s, continuing...\n",\r\nerr, err == 1 ? "" : "s");\r\nreturn 0;\r\n}\r\nstatic int child_unregister(struct device *dev, void *data)\r\n{\r\nnd_device_unregister(dev, ND_SYNC);\r\nreturn 0;\r\n}\r\nstatic int nd_region_remove(struct device *dev)\r\n{\r\nstruct nd_region *nd_region = to_nd_region(dev);\r\nnvdimm_bus_lock(dev);\r\nnd_region->ns_seed = NULL;\r\nnd_region->btt_seed = NULL;\r\nnd_region->pfn_seed = NULL;\r\ndev_set_drvdata(dev, NULL);\r\nnvdimm_bus_unlock(dev);\r\ndevice_for_each_child(dev, NULL, child_unregister);\r\nreturn 0;\r\n}\r\nint __init nd_region_init(void)\r\n{\r\nreturn nd_driver_register(&nd_region_driver);\r\n}\r\nvoid nd_region_exit(void)\r\n{\r\ndriver_unregister(&nd_region_driver.drv);\r\n}
