static int goodix_i2c_read(struct i2c_client *client,\r\nu16 reg, u8 *buf, int len)\r\n{\r\nstruct i2c_msg msgs[2];\r\nu16 wbuf = cpu_to_be16(reg);\r\nint ret;\r\nmsgs[0].flags = 0;\r\nmsgs[0].addr = client->addr;\r\nmsgs[0].len = 2;\r\nmsgs[0].buf = (u8 *)&wbuf;\r\nmsgs[1].flags = I2C_M_RD;\r\nmsgs[1].addr = client->addr;\r\nmsgs[1].len = len;\r\nmsgs[1].buf = buf;\r\nret = i2c_transfer(client->adapter, msgs, 2);\r\nreturn ret < 0 ? ret : (ret != ARRAY_SIZE(msgs) ? -EIO : 0);\r\n}\r\nstatic int goodix_ts_read_input_report(struct goodix_ts_data *ts, u8 *data)\r\n{\r\nint touch_num;\r\nint error;\r\nerror = goodix_i2c_read(ts->client, GOODIX_READ_COOR_ADDR, data,\r\nGOODIX_CONTACT_SIZE + 1);\r\nif (error) {\r\ndev_err(&ts->client->dev, "I2C transfer error: %d\n", error);\r\nreturn error;\r\n}\r\nif (!(data[0] & 0x80))\r\nreturn -EAGAIN;\r\ntouch_num = data[0] & 0x0f;\r\nif (touch_num > ts->max_touch_num)\r\nreturn -EPROTO;\r\nif (touch_num > 1) {\r\ndata += 1 + GOODIX_CONTACT_SIZE;\r\nerror = goodix_i2c_read(ts->client,\r\nGOODIX_READ_COOR_ADDR +\r\n1 + GOODIX_CONTACT_SIZE,\r\ndata,\r\nGOODIX_CONTACT_SIZE * (touch_num - 1));\r\nif (error)\r\nreturn error;\r\n}\r\nreturn touch_num;\r\n}\r\nstatic void goodix_ts_report_touch(struct goodix_ts_data *ts, u8 *coor_data)\r\n{\r\nint id = coor_data[0] & 0x0F;\r\nint input_x = get_unaligned_le16(&coor_data[1]);\r\nint input_y = get_unaligned_le16(&coor_data[3]);\r\nint input_w = get_unaligned_le16(&coor_data[5]);\r\nif (ts->rotated_screen) {\r\ninput_x = ts->abs_x_max - input_x;\r\ninput_y = ts->abs_y_max - input_y;\r\n}\r\ninput_mt_slot(ts->input_dev, id);\r\ninput_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);\r\ninput_report_abs(ts->input_dev, ABS_MT_POSITION_X, input_x);\r\ninput_report_abs(ts->input_dev, ABS_MT_POSITION_Y, input_y);\r\ninput_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, input_w);\r\ninput_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, input_w);\r\n}\r\nstatic void goodix_process_events(struct goodix_ts_data *ts)\r\n{\r\nu8 point_data[1 + GOODIX_CONTACT_SIZE * GOODIX_MAX_CONTACTS];\r\nint touch_num;\r\nint i;\r\ntouch_num = goodix_ts_read_input_report(ts, point_data);\r\nif (touch_num < 0)\r\nreturn;\r\nfor (i = 0; i < touch_num; i++)\r\ngoodix_ts_report_touch(ts,\r\n&point_data[1 + GOODIX_CONTACT_SIZE * i]);\r\ninput_mt_sync_frame(ts->input_dev);\r\ninput_sync(ts->input_dev);\r\n}\r\nstatic irqreturn_t goodix_ts_irq_handler(int irq, void *dev_id)\r\n{\r\nstatic const u8 end_cmd[] = {\r\nGOODIX_READ_COOR_ADDR >> 8,\r\nGOODIX_READ_COOR_ADDR & 0xff,\r\n0\r\n};\r\nstruct goodix_ts_data *ts = dev_id;\r\ngoodix_process_events(ts);\r\nif (i2c_master_send(ts->client, end_cmd, sizeof(end_cmd)) < 0)\r\ndev_err(&ts->client->dev, "I2C write end_cmd error\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void goodix_read_config(struct goodix_ts_data *ts)\r\n{\r\nu8 config[GOODIX_CONFIG_MAX_LENGTH];\r\nint error;\r\nerror = goodix_i2c_read(ts->client, GOODIX_REG_CONFIG_DATA,\r\nconfig,\r\nGOODIX_CONFIG_MAX_LENGTH);\r\nif (error) {\r\ndev_warn(&ts->client->dev,\r\n"Error reading config (%d), using defaults\n",\r\nerror);\r\nts->abs_x_max = GOODIX_MAX_WIDTH;\r\nts->abs_y_max = GOODIX_MAX_HEIGHT;\r\nts->int_trigger_type = GOODIX_INT_TRIGGER;\r\nts->max_touch_num = GOODIX_MAX_CONTACTS;\r\nreturn;\r\n}\r\nts->abs_x_max = get_unaligned_le16(&config[RESOLUTION_LOC]);\r\nts->abs_y_max = get_unaligned_le16(&config[RESOLUTION_LOC + 2]);\r\nts->int_trigger_type = config[TRIGGER_LOC] & 0x03;\r\nts->max_touch_num = config[MAX_CONTACTS_LOC] & 0x0f;\r\nif (!ts->abs_x_max || !ts->abs_y_max || !ts->max_touch_num) {\r\ndev_err(&ts->client->dev,\r\n"Invalid config, using defaults\n");\r\nts->abs_x_max = GOODIX_MAX_WIDTH;\r\nts->abs_y_max = GOODIX_MAX_HEIGHT;\r\nts->max_touch_num = GOODIX_MAX_CONTACTS;\r\n}\r\nts->rotated_screen = dmi_check_system(rotated_screen);\r\nif (ts->rotated_screen)\r\ndev_dbg(&ts->client->dev,\r\n"Applying '180 degrees rotated screen' quirk\n");\r\n}\r\nstatic int goodix_read_version(struct i2c_client *client, u16 *version, u16 *id)\r\n{\r\nint error;\r\nu8 buf[6];\r\nchar id_str[5];\r\nerror = goodix_i2c_read(client, GOODIX_REG_ID, buf, sizeof(buf));\r\nif (error) {\r\ndev_err(&client->dev, "read version failed: %d\n", error);\r\nreturn error;\r\n}\r\nmemcpy(id_str, buf, 4);\r\nid_str[4] = 0;\r\nif (kstrtou16(id_str, 10, id))\r\n*id = 0x1001;\r\n*version = get_unaligned_le16(&buf[4]);\r\ndev_info(&client->dev, "ID %d, version: %04x\n", *id, *version);\r\nreturn 0;\r\n}\r\nstatic int goodix_i2c_test(struct i2c_client *client)\r\n{\r\nint retry = 0;\r\nint error;\r\nu8 test;\r\nwhile (retry++ < 2) {\r\nerror = goodix_i2c_read(client, GOODIX_REG_CONFIG_DATA,\r\n&test, 1);\r\nif (!error)\r\nreturn 0;\r\ndev_err(&client->dev, "i2c test failed attempt %d: %d\n",\r\nretry, error);\r\nmsleep(20);\r\n}\r\nreturn error;\r\n}\r\nstatic int goodix_request_input_dev(struct goodix_ts_data *ts, u16 version,\r\nu16 id)\r\n{\r\nint error;\r\nts->input_dev = devm_input_allocate_device(&ts->client->dev);\r\nif (!ts->input_dev) {\r\ndev_err(&ts->client->dev, "Failed to allocate input device.");\r\nreturn -ENOMEM;\r\n}\r\ninput_set_abs_params(ts->input_dev, ABS_MT_POSITION_X,\r\n0, ts->abs_x_max, 0, 0);\r\ninput_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y,\r\n0, ts->abs_y_max, 0, 0);\r\ninput_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);\r\ninput_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);\r\ninput_mt_init_slots(ts->input_dev, ts->max_touch_num,\r\nINPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\r\nts->input_dev->name = "Goodix Capacitive TouchScreen";\r\nts->input_dev->phys = "input/ts";\r\nts->input_dev->id.bustype = BUS_I2C;\r\nts->input_dev->id.vendor = 0x0416;\r\nts->input_dev->id.product = id;\r\nts->input_dev->id.version = version;\r\nerror = input_register_device(ts->input_dev);\r\nif (error) {\r\ndev_err(&ts->client->dev,\r\n"Failed to register input device: %d", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int goodix_ts_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct goodix_ts_data *ts;\r\nunsigned long irq_flags;\r\nint error;\r\nu16 version_info, id_info;\r\ndev_dbg(&client->dev, "I2C Address: 0x%02x\n", client->addr);\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev, "I2C check functionality failed.\n");\r\nreturn -ENXIO;\r\n}\r\nts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);\r\nif (!ts)\r\nreturn -ENOMEM;\r\nts->client = client;\r\ni2c_set_clientdata(client, ts);\r\nerror = goodix_i2c_test(client);\r\nif (error) {\r\ndev_err(&client->dev, "I2C communication failure: %d\n", error);\r\nreturn error;\r\n}\r\nerror = goodix_read_version(client, &version_info, &id_info);\r\nif (error) {\r\ndev_err(&client->dev, "Read version failed.\n");\r\nreturn error;\r\n}\r\ngoodix_read_config(ts);\r\nerror = goodix_request_input_dev(ts, version_info, id_info);\r\nif (error)\r\nreturn error;\r\nirq_flags = goodix_irq_flags[ts->int_trigger_type] | IRQF_ONESHOT;\r\nerror = devm_request_threaded_irq(&ts->client->dev, client->irq,\r\nNULL, goodix_ts_irq_handler,\r\nirq_flags, client->name, ts);\r\nif (error) {\r\ndev_err(&client->dev, "request IRQ failed: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}
