static void seq_print_age_or_dash(struct seq_file *m, bool valid, unsigned long dt)\r\n{\r\nif (valid)\r\nseq_printf(m, "\t%d", jiffies_to_msecs(dt));\r\nelse\r\nseq_printf(m, "\t-");\r\n}\r\nstatic void __seq_print_rq_state_bit(struct seq_file *m,\r\nbool is_set, char *sep, const char *set_name, const char *unset_name)\r\n{\r\nif (is_set && set_name) {\r\nseq_putc(m, *sep);\r\nseq_puts(m, set_name);\r\n*sep = '|';\r\n} else if (!is_set && unset_name) {\r\nseq_putc(m, *sep);\r\nseq_puts(m, unset_name);\r\n*sep = '|';\r\n}\r\n}\r\nstatic void seq_print_rq_state_bit(struct seq_file *m,\r\nbool is_set, char *sep, const char *set_name)\r\n{\r\n__seq_print_rq_state_bit(m, is_set, sep, set_name, NULL);\r\n}\r\nstatic void seq_print_request_state(struct seq_file *m, struct drbd_request *req)\r\n{\r\nunsigned int s = req->rq_state;\r\nchar sep = ' ';\r\nseq_printf(m, "\t0x%08x", s);\r\nseq_printf(m, "\tmaster: %s", req->master_bio ? "pending" : "completed");\r\nseq_puts(m, "\tlocal:");\r\nseq_print_rq_state_bit(m, s & RQ_IN_ACT_LOG, &sep, "in-AL");\r\nseq_print_rq_state_bit(m, s & RQ_POSTPONED, &sep, "postponed");\r\nseq_print_rq_state_bit(m, s & RQ_COMPLETION_SUSP, &sep, "suspended");\r\nsep = ' ';\r\nseq_print_rq_state_bit(m, s & RQ_LOCAL_PENDING, &sep, "pending");\r\nseq_print_rq_state_bit(m, s & RQ_LOCAL_COMPLETED, &sep, "completed");\r\nseq_print_rq_state_bit(m, s & RQ_LOCAL_ABORTED, &sep, "aborted");\r\nseq_print_rq_state_bit(m, s & RQ_LOCAL_OK, &sep, "ok");\r\nif (sep == ' ')\r\nseq_puts(m, " -");\r\nseq_printf(m, "\tnet:");\r\nsep = ' ';\r\nseq_print_rq_state_bit(m, s & RQ_NET_PENDING, &sep, "pending");\r\nseq_print_rq_state_bit(m, s & RQ_NET_QUEUED, &sep, "queued");\r\nseq_print_rq_state_bit(m, s & RQ_NET_SENT, &sep, "sent");\r\nseq_print_rq_state_bit(m, s & RQ_NET_DONE, &sep, "done");\r\nseq_print_rq_state_bit(m, s & RQ_NET_SIS, &sep, "sis");\r\nseq_print_rq_state_bit(m, s & RQ_NET_OK, &sep, "ok");\r\nif (sep == ' ')\r\nseq_puts(m, " -");\r\nseq_printf(m, " :");\r\nsep = ' ';\r\nseq_print_rq_state_bit(m, s & RQ_EXP_RECEIVE_ACK, &sep, "B");\r\nseq_print_rq_state_bit(m, s & RQ_EXP_WRITE_ACK, &sep, "C");\r\nseq_print_rq_state_bit(m, s & RQ_EXP_BARR_ACK, &sep, "barr");\r\nif (sep == ' ')\r\nseq_puts(m, " -");\r\nseq_printf(m, "\n");\r\n}\r\nstatic void seq_print_one_request(struct seq_file *m, struct drbd_request *req, unsigned long now)\r\n{\r\nunsigned int s = req->rq_state;\r\n#define RQ_HDR_1 "epoch\tsector\tsize\trw"\r\nseq_printf(m, "0x%x\t%llu\t%u\t%s",\r\nreq->epoch,\r\n(unsigned long long)req->i.sector, req->i.size >> 9,\r\n(s & RQ_WRITE) ? "W" : "R");\r\n#define RQ_HDR_2 "\tstart\tin AL\tsubmit"\r\nseq_printf(m, "\t%d", jiffies_to_msecs(now - req->start_jif));\r\nseq_print_age_or_dash(m, s & RQ_IN_ACT_LOG, now - req->in_actlog_jif);\r\nseq_print_age_or_dash(m, s & RQ_LOCAL_PENDING, now - req->pre_submit_jif);\r\n#define RQ_HDR_3 "\tsent\tacked\tdone"\r\nseq_print_age_or_dash(m, s & RQ_NET_SENT, now - req->pre_send_jif);\r\nseq_print_age_or_dash(m, (s & RQ_NET_SENT) && !(s & RQ_NET_PENDING), now - req->acked_jif);\r\nseq_print_age_or_dash(m, s & RQ_NET_DONE, now - req->net_done_jif);\r\n#define RQ_HDR_4 "\tstate\n"\r\nseq_print_request_state(m, req);\r\n}\r\nstatic void seq_print_minor_vnr_req(struct seq_file *m, struct drbd_request *req, unsigned long now)\r\n{\r\nseq_printf(m, "%u\t%u\t", req->device->minor, req->device->vnr);\r\nseq_print_one_request(m, req, now);\r\n}\r\nstatic void seq_print_resource_pending_meta_io(struct seq_file *m, struct drbd_resource *resource, unsigned long now)\r\n{\r\nstruct drbd_device *device;\r\nunsigned int i;\r\nseq_puts(m, "minor\tvnr\tstart\tsubmit\tintent\n");\r\nrcu_read_lock();\r\nidr_for_each_entry(&resource->devices, device, i) {\r\nstruct drbd_md_io tmp;\r\ntmp = device->md_io;\r\nif (atomic_read(&tmp.in_use)) {\r\nseq_printf(m, "%u\t%u\t%d\t",\r\ndevice->minor, device->vnr,\r\njiffies_to_msecs(now - tmp.start_jif));\r\nif (time_before(tmp.submit_jif, tmp.start_jif))\r\nseq_puts(m, "-\t");\r\nelse\r\nseq_printf(m, "%d\t", jiffies_to_msecs(now - tmp.submit_jif));\r\nseq_printf(m, "%s\n", tmp.current_use);\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void seq_print_waiting_for_AL(struct seq_file *m, struct drbd_resource *resource, unsigned long now)\r\n{\r\nstruct drbd_device *device;\r\nunsigned int i;\r\nseq_puts(m, "minor\tvnr\tage\t#waiting\n");\r\nrcu_read_lock();\r\nidr_for_each_entry(&resource->devices, device, i) {\r\nunsigned long jif;\r\nstruct drbd_request *req;\r\nint n = atomic_read(&device->ap_actlog_cnt);\r\nif (n) {\r\nspin_lock_irq(&device->resource->req_lock);\r\nreq = list_first_entry_or_null(&device->pending_master_completion[1],\r\nstruct drbd_request, req_pending_master_completion);\r\nif (req && !(req->rq_state & RQ_IN_ACT_LOG))\r\njif = req->start_jif;\r\nelse\r\nreq = NULL;\r\nspin_unlock_irq(&device->resource->req_lock);\r\n}\r\nif (n) {\r\nseq_printf(m, "%u\t%u\t", device->minor, device->vnr);\r\nif (req)\r\nseq_printf(m, "%u\t", jiffies_to_msecs(now - jif));\r\nelse\r\nseq_puts(m, "-\t");\r\nseq_printf(m, "%u\n", n);\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void seq_print_device_bitmap_io(struct seq_file *m, struct drbd_device *device, unsigned long now)\r\n{\r\nstruct drbd_bm_aio_ctx *ctx;\r\nunsigned long start_jif;\r\nunsigned int in_flight;\r\nunsigned int flags;\r\nspin_lock_irq(&device->resource->req_lock);\r\nctx = list_first_entry_or_null(&device->pending_bitmap_io, struct drbd_bm_aio_ctx, list);\r\nif (ctx && ctx->done)\r\nctx = NULL;\r\nif (ctx) {\r\nstart_jif = ctx->start_jif;\r\nin_flight = atomic_read(&ctx->in_flight);\r\nflags = ctx->flags;\r\n}\r\nspin_unlock_irq(&device->resource->req_lock);\r\nif (ctx) {\r\nseq_printf(m, "%u\t%u\t%c\t%u\t%u\n",\r\ndevice->minor, device->vnr,\r\n(flags & BM_AIO_READ) ? 'R' : 'W',\r\njiffies_to_msecs(now - start_jif),\r\nin_flight);\r\n}\r\n}\r\nstatic void seq_print_resource_pending_bitmap_io(struct seq_file *m, struct drbd_resource *resource, unsigned long now)\r\n{\r\nstruct drbd_device *device;\r\nunsigned int i;\r\nseq_puts(m, "minor\tvnr\trw\tage\t#in-flight\n");\r\nrcu_read_lock();\r\nidr_for_each_entry(&resource->devices, device, i) {\r\nseq_print_device_bitmap_io(m, device, now);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void seq_print_peer_request_flags(struct seq_file *m, struct drbd_peer_request *peer_req)\r\n{\r\nunsigned long f = peer_req->flags;\r\nchar sep = ' ';\r\n__seq_print_rq_state_bit(m, f & EE_SUBMITTED, &sep, "submitted", "preparing");\r\n__seq_print_rq_state_bit(m, f & EE_APPLICATION, &sep, "application", "internal");\r\nseq_print_rq_state_bit(m, f & EE_CALL_AL_COMPLETE_IO, &sep, "in-AL");\r\nseq_print_rq_state_bit(m, f & EE_SEND_WRITE_ACK, &sep, "C");\r\nseq_print_rq_state_bit(m, f & EE_MAY_SET_IN_SYNC, &sep, "set-in-sync");\r\nif (f & EE_IS_TRIM) {\r\nseq_putc(m, sep);\r\nsep = '|';\r\nif (f & EE_IS_TRIM_USE_ZEROOUT)\r\nseq_puts(m, "zero-out");\r\nelse\r\nseq_puts(m, "trim");\r\n}\r\nseq_putc(m, '\n');\r\n}\r\nstatic void seq_print_peer_request(struct seq_file *m,\r\nstruct drbd_device *device, struct list_head *lh,\r\nunsigned long now)\r\n{\r\nbool reported_preparing = false;\r\nstruct drbd_peer_request *peer_req;\r\nlist_for_each_entry(peer_req, lh, w.list) {\r\nif (reported_preparing && !(peer_req->flags & EE_SUBMITTED))\r\ncontinue;\r\nif (device)\r\nseq_printf(m, "%u\t%u\t", device->minor, device->vnr);\r\nseq_printf(m, "%llu\t%u\t%c\t%u\t",\r\n(unsigned long long)peer_req->i.sector, peer_req->i.size >> 9,\r\n(peer_req->flags & EE_WRITE) ? 'W' : 'R',\r\njiffies_to_msecs(now - peer_req->submit_jif));\r\nseq_print_peer_request_flags(m, peer_req);\r\nif (peer_req->flags & EE_SUBMITTED)\r\nbreak;\r\nelse\r\nreported_preparing = true;\r\n}\r\n}\r\nstatic void seq_print_device_peer_requests(struct seq_file *m,\r\nstruct drbd_device *device, unsigned long now)\r\n{\r\nseq_puts(m, "minor\tvnr\tsector\tsize\trw\tage\tflags\n");\r\nspin_lock_irq(&device->resource->req_lock);\r\nseq_print_peer_request(m, device, &device->active_ee, now);\r\nseq_print_peer_request(m, device, &device->read_ee, now);\r\nseq_print_peer_request(m, device, &device->sync_ee, now);\r\nspin_unlock_irq(&device->resource->req_lock);\r\nif (test_bit(FLUSH_PENDING, &device->flags)) {\r\nseq_printf(m, "%u\t%u\t-\t-\tF\t%u\tflush\n",\r\ndevice->minor, device->vnr,\r\njiffies_to_msecs(now - device->flush_jif));\r\n}\r\n}\r\nstatic void seq_print_resource_pending_peer_requests(struct seq_file *m,\r\nstruct drbd_resource *resource, unsigned long now)\r\n{\r\nstruct drbd_device *device;\r\nunsigned int i;\r\nrcu_read_lock();\r\nidr_for_each_entry(&resource->devices, device, i) {\r\nseq_print_device_peer_requests(m, device, now);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void seq_print_resource_transfer_log_summary(struct seq_file *m,\r\nstruct drbd_resource *resource,\r\nstruct drbd_connection *connection,\r\nunsigned long now)\r\n{\r\nstruct drbd_request *req;\r\nunsigned int count = 0;\r\nunsigned int show_state = 0;\r\nseq_puts(m, "n\tdevice\tvnr\t" RQ_HDR);\r\nspin_lock_irq(&resource->req_lock);\r\nlist_for_each_entry(req, &connection->transfer_log, tl_requests) {\r\nunsigned int tmp = 0;\r\nunsigned int s;\r\n++count;\r\nif (!(count & 0x1ff)) {\r\nstruct drbd_request *req_next;\r\nkref_get(&req->kref);\r\nspin_unlock_irq(&resource->req_lock);\r\ncond_resched();\r\nspin_lock_irq(&resource->req_lock);\r\nreq_next = list_next_entry(req, tl_requests);\r\nif (kref_put(&req->kref, drbd_req_destroy))\r\nreq = req_next;\r\nif (&req->tl_requests == &connection->transfer_log)\r\nbreak;\r\n}\r\ns = req->rq_state;\r\nif (req->master_bio == NULL)\r\ntmp |= 1;\r\nif ((s & RQ_LOCAL_MASK) && (s & RQ_LOCAL_PENDING))\r\ntmp |= 2;\r\nif (s & RQ_NET_MASK) {\r\nif (!(s & RQ_NET_SENT))\r\ntmp |= 4;\r\nif (s & RQ_NET_PENDING)\r\ntmp |= 8;\r\nif (!(s & RQ_NET_DONE))\r\ntmp |= 16;\r\n}\r\nif ((tmp & show_state) == tmp)\r\ncontinue;\r\nshow_state |= tmp;\r\nseq_printf(m, "%u\t", count);\r\nseq_print_minor_vnr_req(m, req, now);\r\nif (show_state == 0x1f)\r\nbreak;\r\n}\r\nspin_unlock_irq(&resource->req_lock);\r\n}\r\nstatic int in_flight_summary_show(struct seq_file *m, void *pos)\r\n{\r\nstruct drbd_resource *resource = m->private;\r\nstruct drbd_connection *connection;\r\nunsigned long jif = jiffies;\r\nconnection = first_connection(resource);\r\nif (!connection || !kref_get_unless_zero(&connection->kref))\r\nreturn -ESTALE;\r\nseq_printf(m, "v: %u\n\n", 0);\r\nseq_puts(m, "oldest bitmap IO\n");\r\nseq_print_resource_pending_bitmap_io(m, resource, jif);\r\nseq_putc(m, '\n');\r\nseq_puts(m, "meta data IO\n");\r\nseq_print_resource_pending_meta_io(m, resource, jif);\r\nseq_putc(m, '\n');\r\nseq_puts(m, "socket buffer stats\n");\r\nrcu_read_lock();\r\nif (connection->data.socket) {\r\nstruct tcp_sock *tp = tcp_sk(connection->data.socket->sk);\r\nint answ = tp->rcv_nxt - tp->copied_seq;\r\nseq_printf(m, "unread receive buffer: %u Byte\n", answ);\r\nansw = tp->write_seq - tp->snd_una;\r\nseq_printf(m, "unacked send buffer: %u Byte\n", answ);\r\n}\r\nrcu_read_unlock();\r\nseq_putc(m, '\n');\r\nseq_puts(m, "oldest peer requests\n");\r\nseq_print_resource_pending_peer_requests(m, resource, jif);\r\nseq_putc(m, '\n');\r\nseq_puts(m, "application requests waiting for activity log\n");\r\nseq_print_waiting_for_AL(m, resource, jif);\r\nseq_putc(m, '\n');\r\nseq_puts(m, "oldest application requests\n");\r\nseq_print_resource_transfer_log_summary(m, resource, connection, jif);\r\nseq_putc(m, '\n');\r\njif = jiffies - jif;\r\nif (jif)\r\nseq_printf(m, "generated in %d ms\n", jiffies_to_msecs(jif));\r\nkref_put(&connection->kref, drbd_destroy_connection);\r\nreturn 0;\r\n}\r\nstatic int drbd_single_open(struct file *file, int (*show)(struct seq_file *, void *),\r\nvoid *data, struct kref *kref,\r\nvoid (*release)(struct kref *))\r\n{\r\nstruct dentry *parent;\r\nint ret = -ESTALE;\r\nparent = file->f_path.dentry->d_parent;\r\nif (!parent || d_really_is_negative(parent))\r\ngoto out;\r\nmutex_lock(&d_inode(parent)->i_mutex);\r\nif (simple_positive(file->f_path.dentry)\r\n&& kref_get_unless_zero(kref))\r\nret = 0;\r\nmutex_unlock(&d_inode(parent)->i_mutex);\r\nif (!ret) {\r\nret = single_open(file, show, data);\r\nif (ret)\r\nkref_put(kref, release);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int in_flight_summary_open(struct inode *inode, struct file *file)\r\n{\r\nstruct drbd_resource *resource = inode->i_private;\r\nreturn drbd_single_open(file, in_flight_summary_show, resource,\r\n&resource->kref, drbd_destroy_resource);\r\n}\r\nstatic int in_flight_summary_release(struct inode *inode, struct file *file)\r\n{\r\nstruct drbd_resource *resource = inode->i_private;\r\nkref_put(&resource->kref, drbd_destroy_resource);\r\nreturn single_release(inode, file);\r\n}\r\nvoid drbd_debugfs_resource_add(struct drbd_resource *resource)\r\n{\r\nstruct dentry *dentry;\r\nif (!drbd_debugfs_resources)\r\nreturn;\r\ndentry = debugfs_create_dir(resource->name, drbd_debugfs_resources);\r\nif (IS_ERR_OR_NULL(dentry))\r\ngoto fail;\r\nresource->debugfs_res = dentry;\r\ndentry = debugfs_create_dir("volumes", resource->debugfs_res);\r\nif (IS_ERR_OR_NULL(dentry))\r\ngoto fail;\r\nresource->debugfs_res_volumes = dentry;\r\ndentry = debugfs_create_dir("connections", resource->debugfs_res);\r\nif (IS_ERR_OR_NULL(dentry))\r\ngoto fail;\r\nresource->debugfs_res_connections = dentry;\r\ndentry = debugfs_create_file("in_flight_summary", S_IRUSR|S_IRGRP,\r\nresource->debugfs_res, resource,\r\n&in_flight_summary_fops);\r\nif (IS_ERR_OR_NULL(dentry))\r\ngoto fail;\r\nresource->debugfs_res_in_flight_summary = dentry;\r\nreturn;\r\nfail:\r\ndrbd_debugfs_resource_cleanup(resource);\r\ndrbd_err(resource, "failed to create debugfs dentry\n");\r\n}\r\nstatic void drbd_debugfs_remove(struct dentry **dp)\r\n{\r\ndebugfs_remove(*dp);\r\n*dp = NULL;\r\n}\r\nvoid drbd_debugfs_resource_cleanup(struct drbd_resource *resource)\r\n{\r\ndrbd_debugfs_remove(&resource->debugfs_res_in_flight_summary);\r\ndrbd_debugfs_remove(&resource->debugfs_res_connections);\r\ndrbd_debugfs_remove(&resource->debugfs_res_volumes);\r\ndrbd_debugfs_remove(&resource->debugfs_res);\r\n}\r\nstatic void seq_print_one_timing_detail(struct seq_file *m,\r\nconst struct drbd_thread_timing_details *tdp,\r\nunsigned long now)\r\n{\r\nstruct drbd_thread_timing_details td;\r\ndo {\r\ntd = *tdp;\r\n} while (td.cb_nr != tdp->cb_nr);\r\nif (!td.cb_addr)\r\nreturn;\r\nseq_printf(m, "%u\t%d\t%s:%u\t%ps\n",\r\ntd.cb_nr,\r\njiffies_to_msecs(now - td.start_jif),\r\ntd.caller_fn, td.line,\r\ntd.cb_addr);\r\n}\r\nstatic void seq_print_timing_details(struct seq_file *m,\r\nconst char *title,\r\nunsigned int cb_nr, struct drbd_thread_timing_details *tdp, unsigned long now)\r\n{\r\nunsigned int start_idx;\r\nunsigned int i;\r\nseq_printf(m, "%s\n", title);\r\nstart_idx = cb_nr % DRBD_THREAD_DETAILS_HIST;\r\nfor (i = start_idx; i < DRBD_THREAD_DETAILS_HIST; i++)\r\nseq_print_one_timing_detail(m, tdp+i, now);\r\nfor (i = 0; i < start_idx; i++)\r\nseq_print_one_timing_detail(m, tdp+i, now);\r\n}\r\nstatic int callback_history_show(struct seq_file *m, void *ignored)\r\n{\r\nstruct drbd_connection *connection = m->private;\r\nunsigned long jif = jiffies;\r\nseq_printf(m, "v: %u\n\n", 0);\r\nseq_puts(m, "n\tage\tcallsite\tfn\n");\r\nseq_print_timing_details(m, "worker", connection->w_cb_nr, connection->w_timing_details, jif);\r\nseq_print_timing_details(m, "receiver", connection->r_cb_nr, connection->r_timing_details, jif);\r\nreturn 0;\r\n}\r\nstatic int callback_history_open(struct inode *inode, struct file *file)\r\n{\r\nstruct drbd_connection *connection = inode->i_private;\r\nreturn drbd_single_open(file, callback_history_show, connection,\r\n&connection->kref, drbd_destroy_connection);\r\n}\r\nstatic int callback_history_release(struct inode *inode, struct file *file)\r\n{\r\nstruct drbd_connection *connection = inode->i_private;\r\nkref_put(&connection->kref, drbd_destroy_connection);\r\nreturn single_release(inode, file);\r\n}\r\nstatic int connection_oldest_requests_show(struct seq_file *m, void *ignored)\r\n{\r\nstruct drbd_connection *connection = m->private;\r\nunsigned long now = jiffies;\r\nstruct drbd_request *r1, *r2;\r\nseq_printf(m, "v: %u\n\n", 0);\r\nspin_lock_irq(&connection->resource->req_lock);\r\nr1 = connection->req_next;\r\nif (r1)\r\nseq_print_minor_vnr_req(m, r1, now);\r\nr2 = connection->req_ack_pending;\r\nif (r2 && r2 != r1) {\r\nr1 = r2;\r\nseq_print_minor_vnr_req(m, r1, now);\r\n}\r\nr2 = connection->req_not_net_done;\r\nif (r2 && r2 != r1)\r\nseq_print_minor_vnr_req(m, r2, now);\r\nspin_unlock_irq(&connection->resource->req_lock);\r\nreturn 0;\r\n}\r\nstatic int connection_oldest_requests_open(struct inode *inode, struct file *file)\r\n{\r\nstruct drbd_connection *connection = inode->i_private;\r\nreturn drbd_single_open(file, connection_oldest_requests_show, connection,\r\n&connection->kref, drbd_destroy_connection);\r\n}\r\nstatic int connection_oldest_requests_release(struct inode *inode, struct file *file)\r\n{\r\nstruct drbd_connection *connection = inode->i_private;\r\nkref_put(&connection->kref, drbd_destroy_connection);\r\nreturn single_release(inode, file);\r\n}\r\nvoid drbd_debugfs_connection_add(struct drbd_connection *connection)\r\n{\r\nstruct dentry *conns_dir = connection->resource->debugfs_res_connections;\r\nstruct dentry *dentry;\r\nif (!conns_dir)\r\nreturn;\r\ndentry = debugfs_create_dir("peer", conns_dir);\r\nif (IS_ERR_OR_NULL(dentry))\r\ngoto fail;\r\nconnection->debugfs_conn = dentry;\r\ndentry = debugfs_create_file("callback_history", S_IRUSR|S_IRGRP,\r\nconnection->debugfs_conn, connection,\r\n&connection_callback_history_fops);\r\nif (IS_ERR_OR_NULL(dentry))\r\ngoto fail;\r\nconnection->debugfs_conn_callback_history = dentry;\r\ndentry = debugfs_create_file("oldest_requests", S_IRUSR|S_IRGRP,\r\nconnection->debugfs_conn, connection,\r\n&connection_oldest_requests_fops);\r\nif (IS_ERR_OR_NULL(dentry))\r\ngoto fail;\r\nconnection->debugfs_conn_oldest_requests = dentry;\r\nreturn;\r\nfail:\r\ndrbd_debugfs_connection_cleanup(connection);\r\ndrbd_err(connection, "failed to create debugfs dentry\n");\r\n}\r\nvoid drbd_debugfs_connection_cleanup(struct drbd_connection *connection)\r\n{\r\ndrbd_debugfs_remove(&connection->debugfs_conn_callback_history);\r\ndrbd_debugfs_remove(&connection->debugfs_conn_oldest_requests);\r\ndrbd_debugfs_remove(&connection->debugfs_conn);\r\n}\r\nstatic void resync_dump_detail(struct seq_file *m, struct lc_element *e)\r\n{\r\nstruct bm_extent *bme = lc_entry(e, struct bm_extent, lce);\r\nseq_printf(m, "%5d %s %s %s", bme->rs_left,\r\ntest_bit(BME_NO_WRITES, &bme->flags) ? "NO_WRITES" : "---------",\r\ntest_bit(BME_LOCKED, &bme->flags) ? "LOCKED" : "------",\r\ntest_bit(BME_PRIORITY, &bme->flags) ? "PRIORITY" : "--------"\r\n);\r\n}\r\nstatic int device_resync_extents_show(struct seq_file *m, void *ignored)\r\n{\r\nstruct drbd_device *device = m->private;\r\nseq_printf(m, "v: %u\n\n", 0);\r\nif (get_ldev_if_state(device, D_FAILED)) {\r\nlc_seq_printf_stats(m, device->resync);\r\nlc_seq_dump_details(m, device->resync, "rs_left flags", resync_dump_detail);\r\nput_ldev(device);\r\n}\r\nreturn 0;\r\n}\r\nstatic int device_act_log_extents_show(struct seq_file *m, void *ignored)\r\n{\r\nstruct drbd_device *device = m->private;\r\nseq_printf(m, "v: %u\n\n", 0);\r\nif (get_ldev_if_state(device, D_FAILED)) {\r\nlc_seq_printf_stats(m, device->act_log);\r\nlc_seq_dump_details(m, device->act_log, "", NULL);\r\nput_ldev(device);\r\n}\r\nreturn 0;\r\n}\r\nstatic int device_oldest_requests_show(struct seq_file *m, void *ignored)\r\n{\r\nstruct drbd_device *device = m->private;\r\nstruct drbd_resource *resource = device->resource;\r\nunsigned long now = jiffies;\r\nstruct drbd_request *r1, *r2;\r\nint i;\r\nseq_printf(m, "v: %u\n\n", 0);\r\nseq_puts(m, RQ_HDR);\r\nspin_lock_irq(&resource->req_lock);\r\nfor (i = 1; i >= 0; --i) {\r\nr1 = list_first_entry_or_null(&device->pending_master_completion[i],\r\nstruct drbd_request, req_pending_master_completion);\r\nr2 = list_first_entry_or_null(&device->pending_completion[i],\r\nstruct drbd_request, req_pending_local);\r\nif (r1)\r\nseq_print_one_request(m, r1, now);\r\nif (r2 && r2 != r1)\r\nseq_print_one_request(m, r2, now);\r\n}\r\nspin_unlock_irq(&resource->req_lock);\r\nreturn 0;\r\n}\r\nstatic int device_data_gen_id_show(struct seq_file *m, void *ignored)\r\n{\r\nstruct drbd_device *device = m->private;\r\nstruct drbd_md *md;\r\nenum drbd_uuid_index idx;\r\nif (!get_ldev_if_state(device, D_FAILED))\r\nreturn -ENODEV;\r\nmd = &device->ldev->md;\r\nspin_lock_irq(&md->uuid_lock);\r\nfor (idx = UI_CURRENT; idx <= UI_HISTORY_END; idx++) {\r\nseq_printf(m, "0x%016llX\n", md->uuid[idx]);\r\n}\r\nspin_unlock_irq(&md->uuid_lock);\r\nput_ldev(device);\r\nreturn 0;\r\n}\r\nvoid drbd_debugfs_device_add(struct drbd_device *device)\r\n{\r\nstruct dentry *vols_dir = device->resource->debugfs_res_volumes;\r\nchar minor_buf[8];\r\nchar vnr_buf[8];\r\nchar *slink_name = NULL;\r\nstruct dentry *dentry;\r\nif (!vols_dir || !drbd_debugfs_minors)\r\nreturn;\r\nsnprintf(vnr_buf, sizeof(vnr_buf), "%u", device->vnr);\r\ndentry = debugfs_create_dir(vnr_buf, vols_dir);\r\nif (IS_ERR_OR_NULL(dentry))\r\ngoto fail;\r\ndevice->debugfs_vol = dentry;\r\nsnprintf(minor_buf, sizeof(minor_buf), "%u", device->minor);\r\nslink_name = kasprintf(GFP_KERNEL, "../resources/%s/volumes/%u",\r\ndevice->resource->name, device->vnr);\r\nif (!slink_name)\r\ngoto fail;\r\ndentry = debugfs_create_symlink(minor_buf, drbd_debugfs_minors, slink_name);\r\nkfree(slink_name);\r\nslink_name = NULL;\r\nif (IS_ERR_OR_NULL(dentry))\r\ngoto fail;\r\ndevice->debugfs_minor = dentry;\r\n#define DCF(name) do { \\r\ndentry = debugfs_create_file(#name, S_IRUSR|S_IRGRP, \\r\ndevice->debugfs_vol, device, \\r\n&device_ ## name ## _fops); \\r\nif (IS_ERR_OR_NULL(dentry)) \\r\ngoto fail; \\r\ndevice->debugfs_vol_ ## name = dentry; \\r\n} while (0)\r\nDCF(oldest_requests);\r\nDCF(act_log_extents);\r\nDCF(resync_extents);\r\nDCF(data_gen_id);\r\n#undef DCF\r\nreturn;\r\nfail:\r\ndrbd_debugfs_device_cleanup(device);\r\ndrbd_err(device, "failed to create debugfs entries\n");\r\n}\r\nvoid drbd_debugfs_device_cleanup(struct drbd_device *device)\r\n{\r\ndrbd_debugfs_remove(&device->debugfs_minor);\r\ndrbd_debugfs_remove(&device->debugfs_vol_oldest_requests);\r\ndrbd_debugfs_remove(&device->debugfs_vol_act_log_extents);\r\ndrbd_debugfs_remove(&device->debugfs_vol_resync_extents);\r\ndrbd_debugfs_remove(&device->debugfs_vol_data_gen_id);\r\ndrbd_debugfs_remove(&device->debugfs_vol);\r\n}\r\nvoid drbd_debugfs_peer_device_add(struct drbd_peer_device *peer_device)\r\n{\r\nstruct dentry *conn_dir = peer_device->connection->debugfs_conn;\r\nstruct dentry *dentry;\r\nchar vnr_buf[8];\r\nif (!conn_dir)\r\nreturn;\r\nsnprintf(vnr_buf, sizeof(vnr_buf), "%u", peer_device->device->vnr);\r\ndentry = debugfs_create_dir(vnr_buf, conn_dir);\r\nif (IS_ERR_OR_NULL(dentry))\r\ngoto fail;\r\npeer_device->debugfs_peer_dev = dentry;\r\nreturn;\r\nfail:\r\ndrbd_debugfs_peer_device_cleanup(peer_device);\r\ndrbd_err(peer_device, "failed to create debugfs entries\n");\r\n}\r\nvoid drbd_debugfs_peer_device_cleanup(struct drbd_peer_device *peer_device)\r\n{\r\ndrbd_debugfs_remove(&peer_device->debugfs_peer_dev);\r\n}\r\nstatic int drbd_version_show(struct seq_file *m, void *ignored)\r\n{\r\nseq_printf(m, "# %s\n", drbd_buildtag());\r\nseq_printf(m, "VERSION=%s\n", REL_VERSION);\r\nseq_printf(m, "API_VERSION=%u\n", API_VERSION);\r\nseq_printf(m, "PRO_VERSION_MIN=%u\n", PRO_VERSION_MIN);\r\nseq_printf(m, "PRO_VERSION_MAX=%u\n", PRO_VERSION_MAX);\r\nreturn 0;\r\n}\r\nstatic int drbd_version_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, drbd_version_show, NULL);\r\n}\r\nvoid drbd_debugfs_cleanup(void)\r\n{\r\ndrbd_debugfs_remove(&drbd_debugfs_resources);\r\ndrbd_debugfs_remove(&drbd_debugfs_minors);\r\ndrbd_debugfs_remove(&drbd_debugfs_version);\r\ndrbd_debugfs_remove(&drbd_debugfs_root);\r\n}\r\nint __init drbd_debugfs_init(void)\r\n{\r\nstruct dentry *dentry;\r\ndentry = debugfs_create_dir("drbd", NULL);\r\nif (IS_ERR_OR_NULL(dentry))\r\ngoto fail;\r\ndrbd_debugfs_root = dentry;\r\ndentry = debugfs_create_file("version", 0444, drbd_debugfs_root, NULL, &drbd_version_fops);\r\nif (IS_ERR_OR_NULL(dentry))\r\ngoto fail;\r\ndrbd_debugfs_version = dentry;\r\ndentry = debugfs_create_dir("resources", drbd_debugfs_root);\r\nif (IS_ERR_OR_NULL(dentry))\r\ngoto fail;\r\ndrbd_debugfs_resources = dentry;\r\ndentry = debugfs_create_dir("minors", drbd_debugfs_root);\r\nif (IS_ERR_OR_NULL(dentry))\r\ngoto fail;\r\ndrbd_debugfs_minors = dentry;\r\nreturn 0;\r\nfail:\r\ndrbd_debugfs_cleanup();\r\nif (dentry)\r\nreturn PTR_ERR(dentry);\r\nelse\r\nreturn -EINVAL;\r\n}
