static bool adv7842_check_dv_timings(const struct v4l2_dv_timings *t, void *hdl)\r\n{\r\nint i;\r\nfor (i = 0; adv7842_timings_exceptions[i].bt.width; i++)\r\nif (v4l2_match_dv_timings(t, adv7842_timings_exceptions + i, 0))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic inline struct adv7842_state *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct adv7842_state, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct adv7842_state, hdl)->sd;\r\n}\r\nstatic inline unsigned hblanking(const struct v4l2_bt_timings *t)\r\n{\r\nreturn V4L2_DV_BT_BLANKING_WIDTH(t);\r\n}\r\nstatic inline unsigned htotal(const struct v4l2_bt_timings *t)\r\n{\r\nreturn V4L2_DV_BT_FRAME_WIDTH(t);\r\n}\r\nstatic inline unsigned vblanking(const struct v4l2_bt_timings *t)\r\n{\r\nreturn V4L2_DV_BT_BLANKING_HEIGHT(t);\r\n}\r\nstatic inline unsigned vtotal(const struct v4l2_bt_timings *t)\r\n{\r\nreturn V4L2_DV_BT_FRAME_HEIGHT(t);\r\n}\r\nstatic s32 adv_smbus_read_byte_data_check(struct i2c_client *client,\r\nu8 command, bool check)\r\n{\r\nunion i2c_smbus_data data;\r\nif (!i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_READ, command,\r\nI2C_SMBUS_BYTE_DATA, &data))\r\nreturn data.byte;\r\nif (check)\r\nv4l_err(client, "error reading %02x, %02x\n",\r\nclient->addr, command);\r\nreturn -EIO;\r\n}\r\nstatic s32 adv_smbus_read_byte_data(struct i2c_client *client, u8 command)\r\n{\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nint ret = adv_smbus_read_byte_data_check(client, command, true);\r\nif (ret >= 0) {\r\nif (i)\r\nv4l_err(client, "read ok after %d retries\n", i);\r\nreturn ret;\r\n}\r\n}\r\nv4l_err(client, "read failed\n");\r\nreturn -EIO;\r\n}\r\nstatic s32 adv_smbus_write_byte_data(struct i2c_client *client,\r\nu8 command, u8 value)\r\n{\r\nunion i2c_smbus_data data;\r\nint err;\r\nint i;\r\ndata.byte = value;\r\nfor (i = 0; i < 3; i++) {\r\nerr = i2c_smbus_xfer(client->adapter, client->addr,\r\nclient->flags,\r\nI2C_SMBUS_WRITE, command,\r\nI2C_SMBUS_BYTE_DATA, &data);\r\nif (!err)\r\nbreak;\r\n}\r\nif (err < 0)\r\nv4l_err(client, "error writing %02x, %02x, %02x\n",\r\nclient->addr, command, value);\r\nreturn err;\r\n}\r\nstatic void adv_smbus_write_byte_no_check(struct i2c_client *client,\r\nu8 command, u8 value)\r\n{\r\nunion i2c_smbus_data data;\r\ndata.byte = value;\r\ni2c_smbus_xfer(client->adapter, client->addr,\r\nclient->flags,\r\nI2C_SMBUS_WRITE, command,\r\nI2C_SMBUS_BYTE_DATA, &data);\r\n}\r\nstatic s32 adv_smbus_write_i2c_block_data(struct i2c_client *client,\r\nu8 command, unsigned length, const u8 *values)\r\n{\r\nunion i2c_smbus_data data;\r\nif (length > I2C_SMBUS_BLOCK_MAX)\r\nlength = I2C_SMBUS_BLOCK_MAX;\r\ndata.block[0] = length;\r\nmemcpy(data.block + 1, values, length);\r\nreturn i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_WRITE, command,\r\nI2C_SMBUS_I2C_BLOCK_DATA, &data);\r\n}\r\nstatic inline int io_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn adv_smbus_read_byte_data(client, reg);\r\n}\r\nstatic inline int io_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn adv_smbus_write_byte_data(client, reg, val);\r\n}\r\nstatic inline int io_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\r\n{\r\nreturn io_write(sd, reg, (io_read(sd, reg) & mask) | val);\r\n}\r\nstatic inline int io_write_clr_set(struct v4l2_subdev *sd,\r\nu8 reg, u8 mask, u8 val)\r\n{\r\nreturn io_write(sd, reg, (io_read(sd, reg) & ~mask) | val);\r\n}\r\nstatic inline int avlink_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_avlink, reg);\r\n}\r\nstatic inline int avlink_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_avlink, reg, val);\r\n}\r\nstatic inline int cec_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_cec, reg);\r\n}\r\nstatic inline int cec_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_cec, reg, val);\r\n}\r\nstatic inline int cec_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\r\n{\r\nreturn cec_write(sd, reg, (cec_read(sd, reg) & mask) | val);\r\n}\r\nstatic inline int infoframe_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_infoframe, reg);\r\n}\r\nstatic inline int infoframe_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_infoframe, reg, val);\r\n}\r\nstatic inline int sdp_io_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_sdp_io, reg);\r\n}\r\nstatic inline int sdp_io_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_sdp_io, reg, val);\r\n}\r\nstatic inline int sdp_io_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\r\n{\r\nreturn sdp_io_write(sd, reg, (sdp_io_read(sd, reg) & mask) | val);\r\n}\r\nstatic inline int sdp_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_sdp, reg);\r\n}\r\nstatic inline int sdp_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_sdp, reg, val);\r\n}\r\nstatic inline int sdp_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\r\n{\r\nreturn sdp_write(sd, reg, (sdp_read(sd, reg) & mask) | val);\r\n}\r\nstatic inline int afe_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_afe, reg);\r\n}\r\nstatic inline int afe_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_afe, reg, val);\r\n}\r\nstatic inline int afe_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\r\n{\r\nreturn afe_write(sd, reg, (afe_read(sd, reg) & mask) | val);\r\n}\r\nstatic inline int rep_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_repeater, reg);\r\n}\r\nstatic inline int rep_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_repeater, reg, val);\r\n}\r\nstatic inline int rep_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\r\n{\r\nreturn rep_write(sd, reg, (rep_read(sd, reg) & mask) | val);\r\n}\r\nstatic inline int edid_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_edid, reg);\r\n}\r\nstatic inline int edid_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_edid, reg, val);\r\n}\r\nstatic inline int hdmi_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_hdmi, reg);\r\n}\r\nstatic inline int hdmi_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_hdmi, reg, val);\r\n}\r\nstatic inline int hdmi_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\r\n{\r\nreturn hdmi_write(sd, reg, (hdmi_read(sd, reg) & mask) | val);\r\n}\r\nstatic inline int cp_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_cp, reg);\r\n}\r\nstatic inline int cp_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_cp, reg, val);\r\n}\r\nstatic inline int cp_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\r\n{\r\nreturn cp_write(sd, reg, (cp_read(sd, reg) & mask) | val);\r\n}\r\nstatic inline int vdp_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_vdp, reg);\r\n}\r\nstatic inline int vdp_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_vdp, reg, val);\r\n}\r\nstatic void main_reset(struct v4l2_subdev *sd)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\nadv_smbus_write_byte_no_check(client, 0xff, 0x80);\r\nmdelay(5);\r\n}\r\nstatic const struct adv7842_format_info *\r\nadv7842_format_info(struct adv7842_state *state, u32 code)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(adv7842_formats); ++i) {\r\nif (adv7842_formats[i].code == code)\r\nreturn &adv7842_formats[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline bool is_analog_input(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn ((state->mode == ADV7842_MODE_RGB) ||\r\n(state->mode == ADV7842_MODE_COMP));\r\n}\r\nstatic inline bool is_digital_input(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nreturn state->mode == ADV7842_MODE_HDMI;\r\n}\r\nstatic inline const struct v4l2_dv_timings_cap *\r\nadv7842_get_dv_timings_cap(struct v4l2_subdev *sd)\r\n{\r\nreturn is_digital_input(sd) ? &adv7842_timings_cap_digital :\r\n&adv7842_timings_cap_analog;\r\n}\r\nstatic void adv7842_delayed_work_enable_hotplug(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct adv7842_state *state = container_of(dwork,\r\nstruct adv7842_state, delayed_work_enable_hotplug);\r\nstruct v4l2_subdev *sd = &state->sd;\r\nint present = state->hdmi_edid.present;\r\nu8 mask = 0;\r\nv4l2_dbg(2, debug, sd, "%s: enable hotplug on ports: 0x%x\n",\r\n__func__, present);\r\nif (present & (0x04 << ADV7842_EDID_PORT_A))\r\nmask |= 0x20;\r\nif (present & (0x04 << ADV7842_EDID_PORT_B))\r\nmask |= 0x10;\r\nio_write_and_or(sd, 0x20, 0xcf, mask);\r\n}\r\nstatic int edid_write_vga_segment(struct v4l2_subdev *sd)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct adv7842_state *state = to_state(sd);\r\nconst u8 *val = state->vga_edid.edid;\r\nint err = 0;\r\nint i;\r\nv4l2_dbg(2, debug, sd, "%s: write EDID on VGA port\n", __func__);\r\nio_write_and_or(sd, 0x20, 0xcf, 0x00);\r\nrep_write_and_or(sd, 0x7f, 0x7f, 0x00);\r\nrep_write_and_or(sd, 0x77, 0xef, 0x10);\r\nfor (i = 0; !err && i < 256; i += I2C_SMBUS_BLOCK_MAX)\r\nerr = adv_smbus_write_i2c_block_data(state->i2c_edid, i,\r\nI2C_SMBUS_BLOCK_MAX, val + i);\r\nif (err)\r\nreturn err;\r\nrep_write_and_or(sd, 0x7f, 0x7f, 0x80);\r\nfor (i = 0; i < 1000; i++) {\r\nif (rep_read(sd, 0x79) & 0x20)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif (i == 1000) {\r\nv4l_err(client, "error enabling edid on VGA port\n");\r\nreturn -EIO;\r\n}\r\nqueue_delayed_work(state->work_queues,\r\n&state->delayed_work_enable_hotplug, HZ / 5);\r\nreturn 0;\r\n}\r\nstatic int edid_spa_location(const u8 *edid)\r\n{\r\nu8 d;\r\nif ((edid[0x7e] != 1) ||\r\n(edid[0x80] != 0x02) ||\r\n(edid[0x81] != 0x03)) {\r\nreturn -EINVAL;\r\n}\r\nd = edid[0x82] & 0x7f;\r\nif (d > 4) {\r\nint i = 0x84;\r\nint end = 0x80 + d;\r\ndo {\r\nu8 tag = edid[i]>>5;\r\nu8 len = edid[i] & 0x1f;\r\nif ((tag == 3) && (len >= 5))\r\nreturn i + 4;\r\ni += len + 1;\r\n} while (i < end);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int edid_write_hdmi_segment(struct v4l2_subdev *sd, u8 port)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct adv7842_state *state = to_state(sd);\r\nconst u8 *val = state->hdmi_edid.edid;\r\nint spa_loc = edid_spa_location(val);\r\nint err = 0;\r\nint i;\r\nv4l2_dbg(2, debug, sd, "%s: write EDID on port %c (spa at 0x%x)\n",\r\n__func__, (port == ADV7842_EDID_PORT_A) ? 'A' : 'B', spa_loc);\r\nio_write_and_or(sd, 0x20, 0xcf, 0x00);\r\nrep_write_and_or(sd, 0x77, 0xf3, 0x00);\r\nif (!state->hdmi_edid.present)\r\nreturn 0;\r\nrep_write_and_or(sd, 0x77, 0xef, 0x00);\r\nfor (i = 0; !err && i < 256; i += I2C_SMBUS_BLOCK_MAX)\r\nerr = adv_smbus_write_i2c_block_data(state->i2c_edid, i,\r\nI2C_SMBUS_BLOCK_MAX, val + i);\r\nif (err)\r\nreturn err;\r\nif (spa_loc < 0)\r\nspa_loc = 0xc0;\r\nif (port == ADV7842_EDID_PORT_A) {\r\nrep_write(sd, 0x72, val[spa_loc]);\r\nrep_write(sd, 0x73, val[spa_loc + 1]);\r\n} else {\r\nrep_write(sd, 0x74, val[spa_loc]);\r\nrep_write(sd, 0x75, val[spa_loc + 1]);\r\n}\r\nrep_write(sd, 0x76, spa_loc & 0xff);\r\nrep_write_and_or(sd, 0x77, 0xbf, (spa_loc >> 2) & 0x40);\r\nrep_write_and_or(sd, 0x77, 0xf3, state->hdmi_edid.present);\r\nfor (i = 0; i < 1000; i++) {\r\nif (rep_read(sd, 0x7d) & state->hdmi_edid.present)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif (i == 1000) {\r\nv4l_err(client, "error enabling edid on port %c\n",\r\n(port == ADV7842_EDID_PORT_A) ? 'A' : 'B');\r\nreturn -EIO;\r\n}\r\nqueue_delayed_work(state->work_queues,\r\n&state->delayed_work_enable_hotplug, HZ / 5);\r\nreturn 0;\r\n}\r\nstatic void adv7842_inv_register(struct v4l2_subdev *sd)\r\n{\r\nv4l2_info(sd, "0x000-0x0ff: IO Map\n");\r\nv4l2_info(sd, "0x100-0x1ff: AVLink Map\n");\r\nv4l2_info(sd, "0x200-0x2ff: CEC Map\n");\r\nv4l2_info(sd, "0x300-0x3ff: InfoFrame Map\n");\r\nv4l2_info(sd, "0x400-0x4ff: SDP_IO Map\n");\r\nv4l2_info(sd, "0x500-0x5ff: SDP Map\n");\r\nv4l2_info(sd, "0x600-0x6ff: AFE Map\n");\r\nv4l2_info(sd, "0x700-0x7ff: Repeater Map\n");\r\nv4l2_info(sd, "0x800-0x8ff: EDID Map\n");\r\nv4l2_info(sd, "0x900-0x9ff: HDMI Map\n");\r\nv4l2_info(sd, "0xa00-0xaff: CP Map\n");\r\nv4l2_info(sd, "0xb00-0xbff: VDP Map\n");\r\n}\r\nstatic int adv7842_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nreg->size = 1;\r\nswitch (reg->reg >> 8) {\r\ncase 0:\r\nreg->val = io_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 1:\r\nreg->val = avlink_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 2:\r\nreg->val = cec_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 3:\r\nreg->val = infoframe_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 4:\r\nreg->val = sdp_io_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 5:\r\nreg->val = sdp_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 6:\r\nreg->val = afe_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 7:\r\nreg->val = rep_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 8:\r\nreg->val = edid_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 9:\r\nreg->val = hdmi_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 0xa:\r\nreg->val = cp_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 0xb:\r\nreg->val = vdp_read(sd, reg->reg & 0xff);\r\nbreak;\r\ndefault:\r\nv4l2_info(sd, "Register %03llx not supported\n", reg->reg);\r\nadv7842_inv_register(sd);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7842_s_register(struct v4l2_subdev *sd,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nu8 val = reg->val & 0xff;\r\nswitch (reg->reg >> 8) {\r\ncase 0:\r\nio_write(sd, reg->reg & 0xff, val);\r\nbreak;\r\ncase 1:\r\navlink_write(sd, reg->reg & 0xff, val);\r\nbreak;\r\ncase 2:\r\ncec_write(sd, reg->reg & 0xff, val);\r\nbreak;\r\ncase 3:\r\ninfoframe_write(sd, reg->reg & 0xff, val);\r\nbreak;\r\ncase 4:\r\nsdp_io_write(sd, reg->reg & 0xff, val);\r\nbreak;\r\ncase 5:\r\nsdp_write(sd, reg->reg & 0xff, val);\r\nbreak;\r\ncase 6:\r\nafe_write(sd, reg->reg & 0xff, val);\r\nbreak;\r\ncase 7:\r\nrep_write(sd, reg->reg & 0xff, val);\r\nbreak;\r\ncase 8:\r\nedid_write(sd, reg->reg & 0xff, val);\r\nbreak;\r\ncase 9:\r\nhdmi_write(sd, reg->reg & 0xff, val);\r\nbreak;\r\ncase 0xa:\r\ncp_write(sd, reg->reg & 0xff, val);\r\nbreak;\r\ncase 0xb:\r\nvdp_write(sd, reg->reg & 0xff, val);\r\nbreak;\r\ndefault:\r\nv4l2_info(sd, "Register %03llx not supported\n", reg->reg);\r\nadv7842_inv_register(sd);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7842_s_detect_tx_5v_ctrl(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nint prev = v4l2_ctrl_g_ctrl(state->detect_tx_5v_ctrl);\r\nu8 reg_io_6f = io_read(sd, 0x6f);\r\nint val = 0;\r\nif (reg_io_6f & 0x02)\r\nval |= 1;\r\nif (reg_io_6f & 0x01)\r\nval |= 2;\r\nv4l2_dbg(1, debug, sd, "%s: 0x%x -> 0x%x\n", __func__, prev, val);\r\nif (val != prev)\r\nreturn v4l2_ctrl_s_ctrl(state->detect_tx_5v_ctrl, val);\r\nreturn 0;\r\n}\r\nstatic int find_and_set_predefined_video_timings(struct v4l2_subdev *sd,\r\nu8 prim_mode,\r\nconst struct adv7842_video_standards *predef_vid_timings,\r\nconst struct v4l2_dv_timings *timings)\r\n{\r\nint i;\r\nfor (i = 0; predef_vid_timings[i].timings.bt.width; i++) {\r\nif (!v4l2_match_dv_timings(timings, &predef_vid_timings[i].timings,\r\nis_digital_input(sd) ? 250000 : 1000000))\r\ncontinue;\r\nio_write(sd, 0x00, predef_vid_timings[i].vid_std);\r\nio_write(sd, 0x01, (predef_vid_timings[i].v_freq << 4) + prim_mode);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int configure_predefined_video_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nint err;\r\nv4l2_dbg(1, debug, sd, "%s\n", __func__);\r\nio_write(sd, 0x16, 0x43);\r\nio_write(sd, 0x17, 0x5a);\r\ncp_write_and_or(sd, 0x81, 0xef, 0x00);\r\ncp_write(sd, 0x26, 0x00);\r\ncp_write(sd, 0x27, 0x00);\r\ncp_write(sd, 0x28, 0x00);\r\ncp_write(sd, 0x29, 0x00);\r\ncp_write(sd, 0x8f, 0x40);\r\ncp_write(sd, 0x90, 0x00);\r\ncp_write(sd, 0xa5, 0x00);\r\ncp_write(sd, 0xa6, 0x00);\r\ncp_write(sd, 0xa7, 0x00);\r\ncp_write(sd, 0xab, 0x00);\r\ncp_write(sd, 0xac, 0x00);\r\nswitch (state->mode) {\r\ncase ADV7842_MODE_COMP:\r\ncase ADV7842_MODE_RGB:\r\nerr = find_and_set_predefined_video_timings(sd,\r\n0x01, adv7842_prim_mode_comp, timings);\r\nif (err)\r\nerr = find_and_set_predefined_video_timings(sd,\r\n0x02, adv7842_prim_mode_gr, timings);\r\nbreak;\r\ncase ADV7842_MODE_HDMI:\r\nerr = find_and_set_predefined_video_timings(sd,\r\n0x05, adv7842_prim_mode_hdmi_comp, timings);\r\nif (err)\r\nerr = find_and_set_predefined_video_timings(sd,\r\n0x06, adv7842_prim_mode_hdmi_gr, timings);\r\nbreak;\r\ndefault:\r\nv4l2_dbg(2, debug, sd, "%s: Unknown mode %d\n",\r\n__func__, state->mode);\r\nerr = -1;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic void configure_custom_video_timings(struct v4l2_subdev *sd,\r\nconst struct v4l2_bt_timings *bt)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu32 width = htotal(bt);\r\nu32 height = vtotal(bt);\r\nu16 cp_start_sav = bt->hsync + bt->hbackporch - 4;\r\nu16 cp_start_eav = width - bt->hfrontporch;\r\nu16 cp_start_vbi = height - bt->vfrontporch + 1;\r\nu16 cp_end_vbi = bt->vsync + bt->vbackporch + 1;\r\nu16 ch1_fr_ll = (((u32)bt->pixelclock / 100) > 0) ?\r\n((width * (ADV7842_fsc / 100)) / ((u32)bt->pixelclock / 100)) : 0;\r\nconst u8 pll[2] = {\r\n0xc0 | ((width >> 8) & 0x1f),\r\nwidth & 0xff\r\n};\r\nv4l2_dbg(2, debug, sd, "%s\n", __func__);\r\nswitch (state->mode) {\r\ncase ADV7842_MODE_COMP:\r\ncase ADV7842_MODE_RGB:\r\nio_write(sd, 0x00, 0x07);\r\nio_write(sd, 0x01, 0x02);\r\ncp_write_and_or(sd, 0x81, 0xef, 0x10);\r\nif (adv_smbus_write_i2c_block_data(client, 0x16, 2, pll)) {\r\nv4l2_err(sd, "writing to reg 0x16 and 0x17 failed\n");\r\nbreak;\r\n}\r\ncp_write(sd, 0x26, (cp_start_sav >> 8) & 0xf);\r\ncp_write(sd, 0x27, (cp_start_sav & 0xff));\r\ncp_write(sd, 0x28, (cp_start_eav >> 8) & 0xf);\r\ncp_write(sd, 0x29, (cp_start_eav & 0xff));\r\ncp_write(sd, 0xa5, (cp_start_vbi >> 4) & 0xff);\r\ncp_write(sd, 0xa6, ((cp_start_vbi & 0xf) << 4) |\r\n((cp_end_vbi >> 8) & 0xf));\r\ncp_write(sd, 0xa7, cp_end_vbi & 0xff);\r\nbreak;\r\ncase ADV7842_MODE_HDMI:\r\nio_write(sd, 0x00, 0x02);\r\nio_write(sd, 0x01, 0x06);\r\nbreak;\r\ndefault:\r\nv4l2_dbg(2, debug, sd, "%s: Unknown mode %d\n",\r\n__func__, state->mode);\r\nbreak;\r\n}\r\ncp_write(sd, 0x8f, (ch1_fr_ll >> 8) & 0x7);\r\ncp_write(sd, 0x90, ch1_fr_ll & 0xff);\r\ncp_write(sd, 0xab, (height >> 4) & 0xff);\r\ncp_write(sd, 0xac, (height & 0x0f) << 4);\r\n}\r\nstatic void adv7842_set_offset(struct v4l2_subdev *sd, bool auto_offset, u16 offset_a, u16 offset_b, u16 offset_c)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nu8 offset_buf[4];\r\nif (auto_offset) {\r\noffset_a = 0x3ff;\r\noffset_b = 0x3ff;\r\noffset_c = 0x3ff;\r\n}\r\nv4l2_dbg(2, debug, sd, "%s: %s offset: a = 0x%x, b = 0x%x, c = 0x%x\n",\r\n__func__, auto_offset ? "Auto" : "Manual",\r\noffset_a, offset_b, offset_c);\r\noffset_buf[0]= (cp_read(sd, 0x77) & 0xc0) | ((offset_a & 0x3f0) >> 4);\r\noffset_buf[1] = ((offset_a & 0x00f) << 4) | ((offset_b & 0x3c0) >> 6);\r\noffset_buf[2] = ((offset_b & 0x03f) << 2) | ((offset_c & 0x300) >> 8);\r\noffset_buf[3] = offset_c & 0x0ff;\r\nif (adv_smbus_write_i2c_block_data(state->i2c_cp, 0x77, 4, offset_buf))\r\nv4l2_err(sd, "%s: i2c error writing to CP reg 0x77, 0x78, 0x79, 0x7a\n", __func__);\r\n}\r\nstatic void adv7842_set_gain(struct v4l2_subdev *sd, bool auto_gain, u16 gain_a, u16 gain_b, u16 gain_c)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nu8 gain_buf[4];\r\nu8 gain_man = 1;\r\nu8 agc_mode_man = 1;\r\nif (auto_gain) {\r\ngain_man = 0;\r\nagc_mode_man = 0;\r\ngain_a = 0x100;\r\ngain_b = 0x100;\r\ngain_c = 0x100;\r\n}\r\nv4l2_dbg(2, debug, sd, "%s: %s gain: a = 0x%x, b = 0x%x, c = 0x%x\n",\r\n__func__, auto_gain ? "Auto" : "Manual",\r\ngain_a, gain_b, gain_c);\r\ngain_buf[0] = ((gain_man << 7) | (agc_mode_man << 6) | ((gain_a & 0x3f0) >> 4));\r\ngain_buf[1] = (((gain_a & 0x00f) << 4) | ((gain_b & 0x3c0) >> 6));\r\ngain_buf[2] = (((gain_b & 0x03f) << 2) | ((gain_c & 0x300) >> 8));\r\ngain_buf[3] = ((gain_c & 0x0ff));\r\nif (adv_smbus_write_i2c_block_data(state->i2c_cp, 0x73, 4, gain_buf))\r\nv4l2_err(sd, "%s: i2c error writing to CP reg 0x73, 0x74, 0x75, 0x76\n", __func__);\r\n}\r\nstatic void set_rgb_quantization_range(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nbool rgb_output = io_read(sd, 0x02) & 0x02;\r\nbool hdmi_signal = hdmi_read(sd, 0x05) & 0x80;\r\nv4l2_dbg(2, debug, sd, "%s: RGB quantization range: %d, RGB out: %d, HDMI: %d\n",\r\n__func__, state->rgb_quantization_range,\r\nrgb_output, hdmi_signal);\r\nadv7842_set_gain(sd, true, 0x0, 0x0, 0x0);\r\nadv7842_set_offset(sd, true, 0x0, 0x0, 0x0);\r\nswitch (state->rgb_quantization_range) {\r\ncase V4L2_DV_RGB_RANGE_AUTO:\r\nif (state->mode == ADV7842_MODE_RGB) {\r\nio_write_and_or(sd, 0x02, 0x0f, 0x10);\r\nbreak;\r\n}\r\nif (state->mode == ADV7842_MODE_COMP) {\r\nio_write_and_or(sd, 0x02, 0x0f, 0xf0);\r\nbreak;\r\n}\r\nif (hdmi_signal) {\r\nio_write_and_or(sd, 0x02, 0x0f, 0xf0);\r\nbreak;\r\n}\r\nif (state->timings.bt.flags & V4L2_DV_FL_IS_CE_VIDEO) {\r\nio_write_and_or(sd, 0x02, 0x0f, 0x00);\r\n} else {\r\nio_write_and_or(sd, 0x02, 0x0f, 0x10);\r\nif (is_digital_input(sd) && rgb_output) {\r\nadv7842_set_offset(sd, false, 0x40, 0x40, 0x40);\r\n} else {\r\nadv7842_set_gain(sd, false, 0xe0, 0xe0, 0xe0);\r\nadv7842_set_offset(sd, false, 0x70, 0x70, 0x70);\r\n}\r\n}\r\nbreak;\r\ncase V4L2_DV_RGB_RANGE_LIMITED:\r\nif (state->mode == ADV7842_MODE_COMP) {\r\nio_write_and_or(sd, 0x02, 0x0f, 0x20);\r\nbreak;\r\n}\r\nio_write_and_or(sd, 0x02, 0x0f, 0x00);\r\nbreak;\r\ncase V4L2_DV_RGB_RANGE_FULL:\r\nif (state->mode == ADV7842_MODE_COMP) {\r\nio_write_and_or(sd, 0x02, 0x0f, 0x60);\r\nbreak;\r\n}\r\nio_write_and_or(sd, 0x02, 0x0f, 0x10);\r\nif (is_analog_input(sd) || hdmi_signal)\r\nbreak;\r\nif (rgb_output) {\r\nadv7842_set_offset(sd, false, 0x40, 0x40, 0x40);\r\n} else {\r\nadv7842_set_gain(sd, false, 0xe0, 0xe0, 0xe0);\r\nadv7842_set_offset(sd, false, 0x70, 0x70, 0x70);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int adv7842_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nstruct adv7842_state *state = to_state(sd);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ncp_write(sd, 0x3c, ctrl->val);\r\nsdp_write(sd, 0x14, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_CONTRAST:\r\ncp_write(sd, 0x3a, ctrl->val);\r\nsdp_write(sd, 0x13, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_SATURATION:\r\ncp_write(sd, 0x3b, ctrl->val);\r\nsdp_write(sd, 0x15, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_HUE:\r\ncp_write(sd, 0x3d, ctrl->val);\r\nsdp_write(sd, 0x16, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_ADV_RX_ANALOG_SAMPLING_PHASE:\r\nafe_write(sd, 0xc8, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_ADV_RX_FREE_RUN_COLOR_MANUAL:\r\ncp_write_and_or(sd, 0xbf, ~0x04, (ctrl->val << 2));\r\nsdp_write_and_or(sd, 0xdd, ~0x04, (ctrl->val << 2));\r\nreturn 0;\r\ncase V4L2_CID_ADV_RX_FREE_RUN_COLOR: {\r\nu8 R = (ctrl->val & 0xff0000) >> 16;\r\nu8 G = (ctrl->val & 0x00ff00) >> 8;\r\nu8 B = (ctrl->val & 0x0000ff);\r\nint Y = 66 * R + 129 * G + 25 * B;\r\nint U = -38 * R - 74 * G + 112 * B;\r\nint V = 112 * R - 94 * G - 18 * B;\r\nY = (Y + 128) >> 8;\r\nU = (U + 128) >> 8;\r\nV = (V + 128) >> 8;\r\nY += 16;\r\nU += 128;\r\nV += 128;\r\nv4l2_dbg(1, debug, sd, "R %x, G %x, B %x\n", R, G, B);\r\nv4l2_dbg(1, debug, sd, "Y %x, U %x, V %x\n", Y, U, V);\r\ncp_write(sd, 0xc1, R);\r\ncp_write(sd, 0xc0, G);\r\ncp_write(sd, 0xc2, B);\r\nsdp_write(sd, 0xde, Y);\r\nsdp_write(sd, 0xdf, (V & 0xf0) | ((U >> 4) & 0x0f));\r\nreturn 0;\r\n}\r\ncase V4L2_CID_DV_RX_RGB_RANGE:\r\nstate->rgb_quantization_range = ctrl->val;\r\nset_rgb_quantization_range(sd);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic inline bool no_power(struct v4l2_subdev *sd)\r\n{\r\nreturn io_read(sd, 0x0c) & 0x24;\r\n}\r\nstatic inline bool no_cp_signal(struct v4l2_subdev *sd)\r\n{\r\nreturn ((cp_read(sd, 0xb5) & 0xd0) != 0xd0) || !(cp_read(sd, 0xb1) & 0x80);\r\n}\r\nstatic inline bool is_hdmi(struct v4l2_subdev *sd)\r\n{\r\nreturn hdmi_read(sd, 0x05) & 0x80;\r\n}\r\nstatic int adv7842_g_input_status(struct v4l2_subdev *sd, u32 *status)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\n*status = 0;\r\nif (io_read(sd, 0x0c) & 0x24)\r\n*status |= V4L2_IN_ST_NO_POWER;\r\nif (state->mode == ADV7842_MODE_SDP) {\r\nif (!(sdp_read(sd, 0x5A) & 0x01))\r\n*status |= V4L2_IN_ST_NO_SIGNAL;\r\nv4l2_dbg(1, debug, sd, "%s: SDP status = 0x%x\n",\r\n__func__, *status);\r\nreturn 0;\r\n}\r\nif ((cp_read(sd, 0xb5) & 0xd0) != 0xd0 ||\r\n!(cp_read(sd, 0xb1) & 0x80))\r\n*status |= V4L2_IN_ST_NO_SIGNAL;\r\nif (is_digital_input(sd) && ((io_read(sd, 0x74) & 0x03) != 0x03))\r\n*status |= V4L2_IN_ST_NO_SIGNAL;\r\nv4l2_dbg(1, debug, sd, "%s: CP status = 0x%x\n",\r\n__func__, *status);\r\nreturn 0;\r\n}\r\nstatic int stdi2dv_timings(struct v4l2_subdev *sd,\r\nstruct stdi_readback *stdi,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nu32 hfreq = (ADV7842_fsc * 8) / stdi->bl;\r\nu32 pix_clk;\r\nint i;\r\nfor (i = 0; v4l2_dv_timings_presets[i].bt.width; i++) {\r\nconst struct v4l2_bt_timings *bt = &v4l2_dv_timings_presets[i].bt;\r\nif (!v4l2_valid_dv_timings(&v4l2_dv_timings_presets[i],\r\nadv7842_get_dv_timings_cap(sd),\r\nadv7842_check_dv_timings, NULL))\r\ncontinue;\r\nif (vtotal(bt) != stdi->lcf + 1)\r\ncontinue;\r\nif (bt->vsync != stdi->lcvs)\r\ncontinue;\r\npix_clk = hfreq * htotal(bt);\r\nif ((pix_clk < bt->pixelclock + 1000000) &&\r\n(pix_clk > bt->pixelclock - 1000000)) {\r\n*timings = v4l2_dv_timings_presets[i];\r\nreturn 0;\r\n}\r\n}\r\nif (v4l2_detect_cvt(stdi->lcf + 1, hfreq, stdi->lcvs, 0,\r\n(stdi->hs_pol == '+' ? V4L2_DV_HSYNC_POS_POL : 0) |\r\n(stdi->vs_pol == '+' ? V4L2_DV_VSYNC_POS_POL : 0),\r\nfalse, timings))\r\nreturn 0;\r\nif (v4l2_detect_gtf(stdi->lcf + 1, hfreq, stdi->lcvs,\r\n(stdi->hs_pol == '+' ? V4L2_DV_HSYNC_POS_POL : 0) |\r\n(stdi->vs_pol == '+' ? V4L2_DV_VSYNC_POS_POL : 0),\r\nfalse, state->aspect_ratio, timings))\r\nreturn 0;\r\nv4l2_dbg(2, debug, sd,\r\n"%s: No format candidate found for lcvs = %d, lcf=%d, bl = %d, %chsync, %cvsync\n",\r\n__func__, stdi->lcvs, stdi->lcf, stdi->bl,\r\nstdi->hs_pol, stdi->vs_pol);\r\nreturn -1;\r\n}\r\nstatic int read_stdi(struct v4l2_subdev *sd, struct stdi_readback *stdi)\r\n{\r\nu32 status;\r\nadv7842_g_input_status(sd, &status);\r\nif (status & V4L2_IN_ST_NO_SIGNAL) {\r\nv4l2_dbg(2, debug, sd, "%s: no signal\n", __func__);\r\nreturn -ENOLINK;\r\n}\r\nstdi->bl = ((cp_read(sd, 0xb1) & 0x3f) << 8) | cp_read(sd, 0xb2);\r\nstdi->lcf = ((cp_read(sd, 0xb3) & 0x7) << 8) | cp_read(sd, 0xb4);\r\nstdi->lcvs = cp_read(sd, 0xb3) >> 3;\r\nif ((cp_read(sd, 0xb5) & 0x80) && ((cp_read(sd, 0xb5) & 0x03) == 0x01)) {\r\nstdi->hs_pol = ((cp_read(sd, 0xb5) & 0x10) ?\r\n((cp_read(sd, 0xb5) & 0x08) ? '+' : '-') : 'x');\r\nstdi->vs_pol = ((cp_read(sd, 0xb5) & 0x40) ?\r\n((cp_read(sd, 0xb5) & 0x20) ? '+' : '-') : 'x');\r\n} else {\r\nstdi->hs_pol = 'x';\r\nstdi->vs_pol = 'x';\r\n}\r\nstdi->interlaced = (cp_read(sd, 0xb1) & 0x40) ? true : false;\r\nif (stdi->lcf < 239 || stdi->bl < 8 || stdi->bl == 0x3fff) {\r\nv4l2_dbg(2, debug, sd, "%s: invalid signal\n", __func__);\r\nreturn -ENOLINK;\r\n}\r\nv4l2_dbg(2, debug, sd,\r\n"%s: lcf (frame height - 1) = %d, bl = %d, lcvs (vsync) = %d, %chsync, %cvsync, %s\n",\r\n__func__, stdi->lcf, stdi->bl, stdi->lcvs,\r\nstdi->hs_pol, stdi->vs_pol,\r\nstdi->interlaced ? "interlaced" : "progressive");\r\nreturn 0;\r\n}\r\nstatic int adv7842_enum_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nif (timings->pad != 0)\r\nreturn -EINVAL;\r\nreturn v4l2_enum_dv_timings_cap(timings,\r\nadv7842_get_dv_timings_cap(sd), adv7842_check_dv_timings, NULL);\r\n}\r\nstatic int adv7842_dv_timings_cap(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings_cap *cap)\r\n{\r\nif (cap->pad != 0)\r\nreturn -EINVAL;\r\n*cap = *adv7842_get_dv_timings_cap(sd);\r\nreturn 0;\r\n}\r\nstatic void adv7842_fill_optional_dv_timings_fields(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nv4l2_find_dv_timings_cap(timings, adv7842_get_dv_timings_cap(sd),\r\nis_digital_input(sd) ? 250000 : 1000000,\r\nadv7842_check_dv_timings, NULL);\r\n}\r\nstatic int adv7842_query_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nstruct v4l2_bt_timings *bt = &timings->bt;\r\nstruct stdi_readback stdi = { 0 };\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\nmemset(timings, 0, sizeof(struct v4l2_dv_timings));\r\nif (state->mode == ADV7842_MODE_SDP)\r\nreturn -ENODATA;\r\nif (read_stdi(sd, &stdi)) {\r\nstate->restart_stdi_once = true;\r\nv4l2_dbg(1, debug, sd, "%s: no valid signal\n", __func__);\r\nreturn -ENOLINK;\r\n}\r\nbt->interlaced = stdi.interlaced ?\r\nV4L2_DV_INTERLACED : V4L2_DV_PROGRESSIVE;\r\nbt->standards = V4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT |\r\nV4L2_DV_BT_STD_GTF | V4L2_DV_BT_STD_CVT;\r\nif (is_digital_input(sd)) {\r\nu32 freq;\r\ntimings->type = V4L2_DV_BT_656_1120;\r\nbt->width = (hdmi_read(sd, 0x07) & 0x0f) * 256 + hdmi_read(sd, 0x08);\r\nbt->height = (hdmi_read(sd, 0x09) & 0x0f) * 256 + hdmi_read(sd, 0x0a);\r\nfreq = ((hdmi_read(sd, 0x51) << 1) + (hdmi_read(sd, 0x52) >> 7)) * 1000000;\r\nfreq += ((hdmi_read(sd, 0x52) & 0x7f) * 7813);\r\nif (is_hdmi(sd)) {\r\nfreq = freq * 8 / (((hdmi_read(sd, 0x0b) & 0xc0) >> 6) * 2 + 8);\r\n}\r\nbt->pixelclock = freq;\r\nbt->hfrontporch = (hdmi_read(sd, 0x20) & 0x03) * 256 +\r\nhdmi_read(sd, 0x21);\r\nbt->hsync = (hdmi_read(sd, 0x22) & 0x03) * 256 +\r\nhdmi_read(sd, 0x23);\r\nbt->hbackporch = (hdmi_read(sd, 0x24) & 0x03) * 256 +\r\nhdmi_read(sd, 0x25);\r\nbt->vfrontporch = ((hdmi_read(sd, 0x2a) & 0x1f) * 256 +\r\nhdmi_read(sd, 0x2b)) / 2;\r\nbt->vsync = ((hdmi_read(sd, 0x2e) & 0x1f) * 256 +\r\nhdmi_read(sd, 0x2f)) / 2;\r\nbt->vbackporch = ((hdmi_read(sd, 0x32) & 0x1f) * 256 +\r\nhdmi_read(sd, 0x33)) / 2;\r\nbt->polarities = ((hdmi_read(sd, 0x05) & 0x10) ? V4L2_DV_VSYNC_POS_POL : 0) |\r\n((hdmi_read(sd, 0x05) & 0x20) ? V4L2_DV_HSYNC_POS_POL : 0);\r\nif (bt->interlaced == V4L2_DV_INTERLACED) {\r\nbt->height += (hdmi_read(sd, 0x0b) & 0x0f) * 256 +\r\nhdmi_read(sd, 0x0c);\r\nbt->il_vfrontporch = ((hdmi_read(sd, 0x2c) & 0x1f) * 256 +\r\nhdmi_read(sd, 0x2d)) / 2;\r\nbt->il_vsync = ((hdmi_read(sd, 0x30) & 0x1f) * 256 +\r\nhdmi_read(sd, 0x31)) / 2;\r\nbt->il_vbackporch = ((hdmi_read(sd, 0x34) & 0x1f) * 256 +\r\nhdmi_read(sd, 0x35)) / 2;\r\n} else {\r\nbt->il_vfrontporch = 0;\r\nbt->il_vsync = 0;\r\nbt->il_vbackporch = 0;\r\n}\r\nadv7842_fill_optional_dv_timings_fields(sd, timings);\r\n} else {\r\nif (!stdi2dv_timings(sd, &stdi, timings))\r\ngoto found;\r\nstdi.lcvs += 1;\r\nv4l2_dbg(1, debug, sd, "%s: lcvs + 1 = %d\n", __func__, stdi.lcvs);\r\nif (!stdi2dv_timings(sd, &stdi, timings))\r\ngoto found;\r\nstdi.lcvs -= 2;\r\nv4l2_dbg(1, debug, sd, "%s: lcvs - 1 = %d\n", __func__, stdi.lcvs);\r\nif (stdi2dv_timings(sd, &stdi, timings)) {\r\nif (state->restart_stdi_once) {\r\nv4l2_dbg(1, debug, sd, "%s: restart STDI\n", __func__);\r\ncp_write_and_or(sd, 0x86, 0xf9, 0x00);\r\ncp_write_and_or(sd, 0x86, 0xf9, 0x04);\r\ncp_write_and_or(sd, 0x86, 0xf9, 0x02);\r\nstate->restart_stdi_once = false;\r\nreturn -ENOLINK;\r\n}\r\nv4l2_dbg(1, debug, sd, "%s: format not supported\n", __func__);\r\nreturn -ERANGE;\r\n}\r\nstate->restart_stdi_once = true;\r\n}\r\nfound:\r\nif (debug > 1)\r\nv4l2_print_dv_timings(sd->name, "adv7842_query_dv_timings:",\r\ntimings, true);\r\nreturn 0;\r\n}\r\nstatic int adv7842_s_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nstruct v4l2_bt_timings *bt;\r\nint err;\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\nif (state->mode == ADV7842_MODE_SDP)\r\nreturn -ENODATA;\r\nif (v4l2_match_dv_timings(&state->timings, timings, 0)) {\r\nv4l2_dbg(1, debug, sd, "%s: no change\n", __func__);\r\nreturn 0;\r\n}\r\nbt = &timings->bt;\r\nif (!v4l2_valid_dv_timings(timings, adv7842_get_dv_timings_cap(sd),\r\nadv7842_check_dv_timings, NULL))\r\nreturn -ERANGE;\r\nadv7842_fill_optional_dv_timings_fields(sd, timings);\r\nstate->timings = *timings;\r\ncp_write(sd, 0x91, bt->interlaced ? 0x40 : 0x00);\r\nerr = configure_predefined_video_timings(sd, timings);\r\nif (err) {\r\nconfigure_custom_video_timings(sd, bt);\r\n}\r\nset_rgb_quantization_range(sd);\r\nif (debug > 1)\r\nv4l2_print_dv_timings(sd->name, "adv7842_s_dv_timings: ",\r\ntimings, true);\r\nreturn 0;\r\n}\r\nstatic int adv7842_g_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nif (state->mode == ADV7842_MODE_SDP)\r\nreturn -ENODATA;\r\n*timings = state->timings;\r\nreturn 0;\r\n}\r\nstatic void enable_input(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nset_rgb_quantization_range(sd);\r\nswitch (state->mode) {\r\ncase ADV7842_MODE_SDP:\r\ncase ADV7842_MODE_COMP:\r\ncase ADV7842_MODE_RGB:\r\nio_write(sd, 0x15, 0xb0);\r\nbreak;\r\ncase ADV7842_MODE_HDMI:\r\nhdmi_write(sd, 0x01, 0x00);\r\nio_write(sd, 0x15, 0xa0);\r\nhdmi_write_and_or(sd, 0x1a, 0xef, 0x00);\r\nbreak;\r\ndefault:\r\nv4l2_dbg(2, debug, sd, "%s: Unknown mode %d\n",\r\n__func__, state->mode);\r\nbreak;\r\n}\r\n}\r\nstatic void disable_input(struct v4l2_subdev *sd)\r\n{\r\nhdmi_write_and_or(sd, 0x1a, 0xef, 0x10);\r\nmsleep(16);\r\nio_write(sd, 0x15, 0xbe);\r\nhdmi_write(sd, 0x01, 0x78);\r\n}\r\nstatic void sdp_csc_coeff(struct v4l2_subdev *sd,\r\nconst struct adv7842_sdp_csc_coeff *c)\r\n{\r\nsdp_io_write_and_or(sd, 0xe0, 0xbf, c->manual ? 0x00 : 0x40);\r\nif (!c->manual)\r\nreturn;\r\nsdp_io_write_and_or(sd, 0xe0, 0x7f, c->scaling == 2 ? 0x80 : 0x00);\r\nsdp_io_write_and_or(sd, 0xe0, 0xe0, c->A1 >> 8);\r\nsdp_io_write(sd, 0xe1, c->A1);\r\nsdp_io_write_and_or(sd, 0xe2, 0xe0, c->A2 >> 8);\r\nsdp_io_write(sd, 0xe3, c->A2);\r\nsdp_io_write_and_or(sd, 0xe4, 0xe0, c->A3 >> 8);\r\nsdp_io_write(sd, 0xe5, c->A3);\r\nsdp_io_write_and_or(sd, 0xe6, 0x80, c->A4 >> 8);\r\nsdp_io_write(sd, 0xe7, c->A4);\r\nsdp_io_write_and_or(sd, 0xe8, 0xe0, c->B1 >> 8);\r\nsdp_io_write(sd, 0xe9, c->B1);\r\nsdp_io_write_and_or(sd, 0xea, 0xe0, c->B2 >> 8);\r\nsdp_io_write(sd, 0xeb, c->B2);\r\nsdp_io_write_and_or(sd, 0xec, 0xe0, c->B3 >> 8);\r\nsdp_io_write(sd, 0xed, c->B3);\r\nsdp_io_write_and_or(sd, 0xee, 0x80, c->B4 >> 8);\r\nsdp_io_write(sd, 0xef, c->B4);\r\nsdp_io_write_and_or(sd, 0xf0, 0xe0, c->C1 >> 8);\r\nsdp_io_write(sd, 0xf1, c->C1);\r\nsdp_io_write_and_or(sd, 0xf2, 0xe0, c->C2 >> 8);\r\nsdp_io_write(sd, 0xf3, c->C2);\r\nsdp_io_write_and_or(sd, 0xf4, 0xe0, c->C3 >> 8);\r\nsdp_io_write(sd, 0xf5, c->C3);\r\nsdp_io_write_and_or(sd, 0xf6, 0x80, c->C4 >> 8);\r\nsdp_io_write(sd, 0xf7, c->C4);\r\n}\r\nstatic void select_input(struct v4l2_subdev *sd,\r\nenum adv7842_vid_std_select vid_std_select)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nswitch (state->mode) {\r\ncase ADV7842_MODE_SDP:\r\nio_write(sd, 0x00, vid_std_select);\r\nio_write(sd, 0x01, 0);\r\ncp_write_and_or(sd, 0x81, 0xef, 0x10);\r\nafe_write(sd, 0x00, 0x00);\r\nafe_write(sd, 0xc8, 0x00);\r\nio_write(sd, 0xdd, 0x90);\r\nafe_write_and_or(sd, 0x02, 0x7f, 0x80);\r\nif (vid_std_select == ADV7842_SDP_VID_STD_CVBS_SD_4x1) {\r\nafe_write(sd, 0x03, 0xa0);\r\nafe_write(sd, 0x04, 0x00);\r\n} else {\r\nafe_write(sd, 0x03, 0xa0);\r\nafe_write(sd, 0x04, 0xc0);\r\n}\r\nafe_write(sd, 0x0c, 0x1f);\r\nafe_write(sd, 0x12, 0x63);\r\nsdp_io_write(sd, 0xb2, 0x60);\r\nsdp_io_write(sd, 0xc8, 0xe3);\r\nsdp_write(sd, 0x00, 0x3F);\r\nsdp_write(sd, 0x01, 0x00);\r\nsdp_write(sd, 0x03, 0xE4);\r\nsdp_write(sd, 0x04, 0x0B);\r\nsdp_write(sd, 0x05, 0xC3);\r\nsdp_write(sd, 0x06, 0xFE);\r\nsdp_write(sd, 0x12, 0x0D);\r\nsdp_write(sd, 0xA7, 0x00);\r\nsdp_io_write(sd, 0xB0, 0x00);\r\nsdp_write_and_or(sd, 0x12, 0xf6, 0x09);\r\nbreak;\r\ncase ADV7842_MODE_COMP:\r\ncase ADV7842_MODE_RGB:\r\nafe_write_and_or(sd, 0x02, 0x7f, 0x00);\r\nio_write(sd, 0x00, vid_std_select);\r\nio_write(sd, 0x01, 0x02);\r\ncp_write_and_or(sd, 0x81, 0xef, 0x10);\r\nafe_write(sd, 0x00, 0x00);\r\nafe_write(sd, 0xc8, 0x00);\r\nif (state->mode == ADV7842_MODE_COMP) {\r\nio_write_and_or(sd, 0x02, 0x0f, 0x60);\r\n} else {\r\nio_write_and_or(sd, 0x02, 0x0f, 0x10);\r\n}\r\nafe_write(sd, 0x0c, 0x1f);\r\nafe_write(sd, 0x12, 0x63);\r\ncp_write(sd, 0x73, 0x10);\r\ncp_write(sd, 0x74, 0x04);\r\ncp_write(sd, 0x75, 0x01);\r\ncp_write(sd, 0x76, 0x00);\r\ncp_write(sd, 0x3e, 0x04);\r\ncp_write(sd, 0xc3, 0x39);\r\ncp_write(sd, 0x40, 0x5c);\r\nbreak;\r\ncase ADV7842_MODE_HDMI:\r\nafe_write_and_or(sd, 0x02, 0x7f, 0x00);\r\nif (state->hdmi_port_a)\r\nhdmi_write(sd, 0x00, 0x02);\r\nelse\r\nhdmi_write(sd, 0x00, 0x03);\r\nio_write(sd, 0x00, vid_std_select);\r\nio_write(sd, 0x01, 5);\r\ncp_write_and_or(sd, 0x81, 0xef, 0x00);\r\nhdmi_write(sd, 0xc0, 0x00);\r\nhdmi_write(sd, 0x0d, 0x34);\r\nhdmi_write(sd, 0x3d, 0x10);\r\nhdmi_write(sd, 0x44, 0x85);\r\nhdmi_write(sd, 0x46, 0x1f);\r\nhdmi_write(sd, 0x57, 0xb6);\r\nhdmi_write(sd, 0x58, 0x03);\r\nhdmi_write(sd, 0x60, 0x88);\r\nhdmi_write(sd, 0x61, 0x88);\r\nhdmi_write(sd, 0x6c, 0x18);\r\nhdmi_write(sd, 0x75, 0x10);\r\nhdmi_write(sd, 0x85, 0x1f);\r\nhdmi_write(sd, 0x87, 0x70);\r\nhdmi_write(sd, 0x89, 0x04);\r\nhdmi_write(sd, 0x8a, 0x1e);\r\nhdmi_write(sd, 0x93, 0x04);\r\nhdmi_write(sd, 0x94, 0x1e);\r\nhdmi_write(sd, 0x99, 0xa1);\r\nhdmi_write(sd, 0x9b, 0x09);\r\nhdmi_write(sd, 0x9d, 0x02);\r\nafe_write(sd, 0x00, 0xff);\r\nafe_write(sd, 0xc8, 0x40);\r\ncp_write(sd, 0x73, 0x10);\r\ncp_write(sd, 0x74, 0x04);\r\ncp_write(sd, 0x75, 0x01);\r\ncp_write(sd, 0x76, 0x00);\r\nafe_write(sd, 0x12, 0xfb);\r\nafe_write(sd, 0x0c, 0x0d);\r\ncp_write(sd, 0x3e, 0x00);\r\ncp_write(sd, 0xc3, 0x33);\r\nio_write_and_or(sd, 0x02, 0x0f, 0xf0);\r\nbreak;\r\ndefault:\r\nv4l2_dbg(2, debug, sd, "%s: Unknown mode %d\n",\r\n__func__, state->mode);\r\nbreak;\r\n}\r\n}\r\nstatic int adv7842_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nv4l2_dbg(2, debug, sd, "%s: input %d\n", __func__, input);\r\nswitch (input) {\r\ncase ADV7842_SELECT_HDMI_PORT_A:\r\nstate->mode = ADV7842_MODE_HDMI;\r\nstate->vid_std_select = ADV7842_HDMI_COMP_VID_STD_HD_1250P;\r\nstate->hdmi_port_a = true;\r\nbreak;\r\ncase ADV7842_SELECT_HDMI_PORT_B:\r\nstate->mode = ADV7842_MODE_HDMI;\r\nstate->vid_std_select = ADV7842_HDMI_COMP_VID_STD_HD_1250P;\r\nstate->hdmi_port_a = false;\r\nbreak;\r\ncase ADV7842_SELECT_VGA_COMP:\r\nstate->mode = ADV7842_MODE_COMP;\r\nstate->vid_std_select = ADV7842_RGB_VID_STD_AUTO_GRAPH_MODE;\r\nbreak;\r\ncase ADV7842_SELECT_VGA_RGB:\r\nstate->mode = ADV7842_MODE_RGB;\r\nstate->vid_std_select = ADV7842_RGB_VID_STD_AUTO_GRAPH_MODE;\r\nbreak;\r\ncase ADV7842_SELECT_SDP_CVBS:\r\nstate->mode = ADV7842_MODE_SDP;\r\nstate->vid_std_select = ADV7842_SDP_VID_STD_CVBS_SD_4x1;\r\nbreak;\r\ncase ADV7842_SELECT_SDP_YC:\r\nstate->mode = ADV7842_MODE_SDP;\r\nstate->vid_std_select = ADV7842_SDP_VID_STD_YC_SD4_x1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndisable_input(sd);\r\nselect_input(sd, state->vid_std_select);\r\nenable_input(sd);\r\nv4l2_subdev_notify_event(sd, &adv7842_ev_fmt);\r\nreturn 0;\r\n}\r\nstatic int adv7842_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->index >= ARRAY_SIZE(adv7842_formats))\r\nreturn -EINVAL;\r\ncode->code = adv7842_formats[code->index].code;\r\nreturn 0;\r\n}\r\nstatic void adv7842_fill_format(struct adv7842_state *state,\r\nstruct v4l2_mbus_framefmt *format)\r\n{\r\nmemset(format, 0, sizeof(*format));\r\nformat->width = state->timings.bt.width;\r\nformat->height = state->timings.bt.height;\r\nformat->field = V4L2_FIELD_NONE;\r\nformat->colorspace = V4L2_COLORSPACE_SRGB;\r\nif (state->timings.bt.flags & V4L2_DV_FL_IS_CE_VIDEO)\r\nformat->colorspace = (state->timings.bt.height <= 576) ?\r\nV4L2_COLORSPACE_SMPTE170M : V4L2_COLORSPACE_REC709;\r\n}\r\nstatic unsigned int adv7842_op_ch_sel(struct adv7842_state *state)\r\n{\r\n#define _SEL(a, b, c, d, e, f) { \\r\nADV7842_OP_CH_SEL_##a, ADV7842_OP_CH_SEL_##b, ADV7842_OP_CH_SEL_##c, \\r\nADV7842_OP_CH_SEL_##d, ADV7842_OP_CH_SEL_##e, ADV7842_OP_CH_SEL_##f }\r\n#define _BUS(x) [ADV7842_BUS_ORDER_##x]\r\nstatic const unsigned int op_ch_sel[6][6] = {\r\n_BUS(RGB) = _SEL(GBR, GRB, BGR, RGB, BRG, RBG),\r\n_BUS(GRB) = _SEL(BGR, RGB, GBR, GRB, RBG, BRG),\r\n_BUS(RBG) = _SEL(GRB, GBR, BRG, RBG, BGR, RGB),\r\n_BUS(BGR) = _SEL(RBG, BRG, RGB, BGR, GRB, GBR),\r\n_BUS(BRG) = _SEL(BRG, RBG, GRB, GBR, RGB, BGR),\r\n_BUS(GBR) = _SEL(RGB, BGR, RBG, BRG, GBR, GRB),\r\n};\r\nreturn op_ch_sel[state->pdata.bus_order][state->format->op_ch_sel >> 5];\r\n}\r\nstatic void adv7842_setup_format(struct adv7842_state *state)\r\n{\r\nstruct v4l2_subdev *sd = &state->sd;\r\nio_write_clr_set(sd, 0x02, 0x02,\r\nstate->format->rgb_out ? ADV7842_RGB_OUT : 0);\r\nio_write(sd, 0x03, state->format->op_format_sel |\r\nstate->pdata.op_format_mode_sel);\r\nio_write_clr_set(sd, 0x04, 0xe0, adv7842_op_ch_sel(state));\r\nio_write_clr_set(sd, 0x05, 0x01,\r\nstate->format->swap_cb_cr ? ADV7842_OP_SWAP_CB_CR : 0);\r\n}\r\nstatic int adv7842_get_format(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nif (format->pad != ADV7842_PAD_SOURCE)\r\nreturn -EINVAL;\r\nif (state->mode == ADV7842_MODE_SDP) {\r\nif (!(sdp_read(sd, 0x5a) & 0x01))\r\nreturn -EINVAL;\r\nformat->format.code = MEDIA_BUS_FMT_YUYV8_2X8;\r\nformat->format.width = 720;\r\nif (state->norm & V4L2_STD_525_60)\r\nformat->format.height = 480;\r\nelse\r\nformat->format.height = 576;\r\nformat->format.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nadv7842_fill_format(state, &format->format);\r\nif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nstruct v4l2_mbus_framefmt *fmt;\r\nfmt = v4l2_subdev_get_try_format(sd, cfg, format->pad);\r\nformat->format.code = fmt->code;\r\n} else {\r\nformat->format.code = state->format->code;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7842_set_format(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nconst struct adv7842_format_info *info;\r\nif (format->pad != ADV7842_PAD_SOURCE)\r\nreturn -EINVAL;\r\nif (state->mode == ADV7842_MODE_SDP)\r\nreturn adv7842_get_format(sd, cfg, format);\r\ninfo = adv7842_format_info(state, format->format.code);\r\nif (info == NULL)\r\ninfo = adv7842_format_info(state, MEDIA_BUS_FMT_YUYV8_2X8);\r\nadv7842_fill_format(state, &format->format);\r\nformat->format.code = info->code;\r\nif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nstruct v4l2_mbus_framefmt *fmt;\r\nfmt = v4l2_subdev_get_try_format(sd, cfg, format->pad);\r\nfmt->code = format->format.code;\r\n} else {\r\nstate->format = info;\r\nadv7842_setup_format(state);\r\n}\r\nreturn 0;\r\n}\r\nstatic void adv7842_irq_enable(struct v4l2_subdev *sd, bool enable)\r\n{\r\nif (enable) {\r\nio_write(sd, 0x46, 0x9c);\r\nio_write(sd, 0x5a, 0x10);\r\nio_write(sd, 0x73, 0x03);\r\nio_write(sd, 0x78, 0x03);\r\nio_write(sd, 0xa0, 0x09);\r\nio_write(sd, 0x69, 0x08);\r\n} else {\r\nio_write(sd, 0x46, 0x0);\r\nio_write(sd, 0x5a, 0x0);\r\nio_write(sd, 0x73, 0x0);\r\nio_write(sd, 0x78, 0x0);\r\nio_write(sd, 0xa0, 0x0);\r\nio_write(sd, 0x69, 0x0);\r\n}\r\n}\r\nstatic int adv7842_isr(struct v4l2_subdev *sd, u32 status, bool *handled)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nu8 fmt_change_cp, fmt_change_digital, fmt_change_sdp;\r\nu8 irq_status[6];\r\nadv7842_irq_enable(sd, false);\r\nirq_status[0] = io_read(sd, 0x43);\r\nirq_status[1] = io_read(sd, 0x57);\r\nirq_status[2] = io_read(sd, 0x70);\r\nirq_status[3] = io_read(sd, 0x75);\r\nirq_status[4] = io_read(sd, 0x9d);\r\nirq_status[5] = io_read(sd, 0x66);\r\nif (irq_status[0])\r\nio_write(sd, 0x44, irq_status[0]);\r\nif (irq_status[1])\r\nio_write(sd, 0x58, irq_status[1]);\r\nif (irq_status[2])\r\nio_write(sd, 0x71, irq_status[2]);\r\nif (irq_status[3])\r\nio_write(sd, 0x76, irq_status[3]);\r\nif (irq_status[4])\r\nio_write(sd, 0x9e, irq_status[4]);\r\nif (irq_status[5])\r\nio_write(sd, 0x67, irq_status[5]);\r\nadv7842_irq_enable(sd, true);\r\nv4l2_dbg(1, debug, sd, "%s: irq %x, %x, %x, %x, %x, %x\n", __func__,\r\nirq_status[0], irq_status[1], irq_status[2],\r\nirq_status[3], irq_status[4], irq_status[5]);\r\nfmt_change_cp = irq_status[0] & 0x9c;\r\nif (state->mode == ADV7842_MODE_SDP)\r\nfmt_change_sdp = (irq_status[1] & 0x30) | (irq_status[4] & 0x09);\r\nelse\r\nfmt_change_sdp = 0;\r\nif (is_digital_input(sd))\r\nfmt_change_digital = irq_status[3] & 0x03;\r\nelse\r\nfmt_change_digital = 0;\r\nif (fmt_change_cp || fmt_change_digital || fmt_change_sdp) {\r\nv4l2_dbg(1, debug, sd,\r\n"%s: fmt_change_cp = 0x%x, fmt_change_digital = 0x%x, fmt_change_sdp = 0x%x\n",\r\n__func__, fmt_change_cp, fmt_change_digital,\r\nfmt_change_sdp);\r\nv4l2_subdev_notify_event(sd, &adv7842_ev_fmt);\r\nif (handled)\r\n*handled = true;\r\n}\r\nif (irq_status[5] & 0x08) {\r\nv4l2_dbg(1, debug, sd, "%s: irq %s mode\n", __func__,\r\n(io_read(sd, 0x65) & 0x08) ? "HDMI" : "DVI");\r\nset_rgb_quantization_range(sd);\r\nif (handled)\r\n*handled = true;\r\n}\r\nif (irq_status[2] & 0x3) {\r\nv4l2_dbg(1, debug, sd, "%s: irq tx_5v\n", __func__);\r\nadv7842_s_detect_tx_5v_ctrl(sd);\r\nif (handled)\r\n*handled = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7842_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nu8 *data = NULL;\r\nmemset(edid->reserved, 0, sizeof(edid->reserved));\r\nswitch (edid->pad) {\r\ncase ADV7842_EDID_PORT_A:\r\ncase ADV7842_EDID_PORT_B:\r\nif (state->hdmi_edid.present & (0x04 << edid->pad))\r\ndata = state->hdmi_edid.edid;\r\nbreak;\r\ncase ADV7842_EDID_PORT_VGA:\r\nif (state->vga_edid.present)\r\ndata = state->vga_edid.edid;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (edid->start_block == 0 && edid->blocks == 0) {\r\nedid->blocks = data ? 2 : 0;\r\nreturn 0;\r\n}\r\nif (!data)\r\nreturn -ENODATA;\r\nif (edid->start_block >= 2)\r\nreturn -EINVAL;\r\nif (edid->start_block + edid->blocks > 2)\r\nedid->blocks = 2 - edid->start_block;\r\nmemcpy(edid->edid, data + edid->start_block * 128, edid->blocks * 128);\r\nreturn 0;\r\n}\r\nstatic int adv7842_set_edid(struct v4l2_subdev *sd, struct v4l2_edid *e)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nint err = 0;\r\nmemset(e->reserved, 0, sizeof(e->reserved));\r\nif (e->pad > ADV7842_EDID_PORT_VGA)\r\nreturn -EINVAL;\r\nif (e->start_block != 0)\r\nreturn -EINVAL;\r\nif (e->blocks > 2) {\r\ne->blocks = 2;\r\nreturn -E2BIG;\r\n}\r\nstate->aspect_ratio = v4l2_calc_aspect_ratio(e->edid[0x15],\r\ne->edid[0x16]);\r\nswitch (e->pad) {\r\ncase ADV7842_EDID_PORT_VGA:\r\nmemset(&state->vga_edid.edid, 0, 256);\r\nstate->vga_edid.present = e->blocks ? 0x1 : 0x0;\r\nmemcpy(&state->vga_edid.edid, e->edid, 128 * e->blocks);\r\nerr = edid_write_vga_segment(sd);\r\nbreak;\r\ncase ADV7842_EDID_PORT_A:\r\ncase ADV7842_EDID_PORT_B:\r\nmemset(&state->hdmi_edid.edid, 0, 256);\r\nif (e->blocks)\r\nstate->hdmi_edid.present |= 0x04 << e->pad;\r\nelse\r\nstate->hdmi_edid.present &= ~(0x04 << e->pad);\r\nmemcpy(&state->hdmi_edid.edid, e->edid, 128 * e->blocks);\r\nerr = edid_write_hdmi_segment(sd, e->pad);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (err < 0)\r\nv4l2_err(sd, "error %d writing edid on port %d\n", err, e->pad);\r\nreturn err;\r\n}\r\nstatic void log_infoframe(struct v4l2_subdev *sd, struct adv7842_cfg_read_infoframe *cri)\r\n{\r\nint i;\r\nu8 buffer[32];\r\nunion hdmi_infoframe frame;\r\nu8 len;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct device *dev = &client->dev;\r\nif (!(io_read(sd, 0x60) & cri->present_mask)) {\r\nv4l2_info(sd, "%s infoframe not received\n", cri->desc);\r\nreturn;\r\n}\r\nfor (i = 0; i < 3; i++)\r\nbuffer[i] = infoframe_read(sd, cri->head_addr + i);\r\nlen = buffer[2] + 1;\r\nif (len + 3 > sizeof(buffer)) {\r\nv4l2_err(sd, "%s: invalid %s infoframe length %d\n", __func__, cri->desc, len);\r\nreturn;\r\n}\r\nfor (i = 0; i < len; i++)\r\nbuffer[i + 3] = infoframe_read(sd, cri->payload_addr + i);\r\nif (hdmi_infoframe_unpack(&frame, buffer) < 0) {\r\nv4l2_err(sd, "%s: unpack of %s infoframe failed\n", __func__, cri->desc);\r\nreturn;\r\n}\r\nhdmi_infoframe_log(KERN_INFO, dev, &frame);\r\n}\r\nstatic void adv7842_log_infoframes(struct v4l2_subdev *sd)\r\n{\r\nint i;\r\nstruct adv7842_cfg_read_infoframe cri[] = {\r\n{ "AVI", 0x01, 0xe0, 0x00 },\r\n{ "Audio", 0x02, 0xe3, 0x1c },\r\n{ "SDP", 0x04, 0xe6, 0x2a },\r\n{ "Vendor", 0x10, 0xec, 0x54 }\r\n};\r\nif (!(hdmi_read(sd, 0x05) & 0x80)) {\r\nv4l2_info(sd, "receive DVI-D signal, no infoframes\n");\r\nreturn;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(cri); i++)\r\nlog_infoframe(sd, &cri[i]);\r\n}\r\nstatic int adv7842_sdp_log_status(struct v4l2_subdev *sd)\r\n{\r\nu8 sdp_signal_detected = sdp_read(sd, 0x5A) & 0x01;\r\nv4l2_info(sd, "Chip powered %s\n", no_power(sd) ? "off" : "on");\r\nv4l2_info(sd, "Prim-mode = 0x%x, video std = 0x%x\n",\r\nio_read(sd, 0x01) & 0x0f, io_read(sd, 0x00) & 0x3f);\r\nv4l2_info(sd, "SDP: free run: %s\n",\r\n(sdp_read(sd, 0x56) & 0x01) ? "on" : "off");\r\nv4l2_info(sd, "SDP: %s\n", sdp_signal_detected ?\r\n"valid SD/PR signal detected" : "invalid/no signal");\r\nif (sdp_signal_detected) {\r\nstatic const char * const sdp_std_txt[] = {\r\n"NTSC-M/J",\r\n"1?",\r\n"NTSC-443",\r\n"60HzSECAM",\r\n"PAL-M",\r\n"5?",\r\n"PAL-60",\r\n"7?", "8?", "9?", "a?", "b?",\r\n"PAL-CombN",\r\n"d?",\r\n"PAL-BGHID",\r\n"SECAM"\r\n};\r\nv4l2_info(sd, "SDP: standard %s\n",\r\nsdp_std_txt[sdp_read(sd, 0x52) & 0x0f]);\r\nv4l2_info(sd, "SDP: %s\n",\r\n(sdp_read(sd, 0x59) & 0x08) ? "50Hz" : "60Hz");\r\nv4l2_info(sd, "SDP: %s\n",\r\n(sdp_read(sd, 0x57) & 0x08) ? "Interlaced" : "Progressive");\r\nv4l2_info(sd, "SDP: deinterlacer %s\n",\r\n(sdp_read(sd, 0x12) & 0x08) ? "enabled" : "disabled");\r\nv4l2_info(sd, "SDP: csc %s mode\n",\r\n(sdp_io_read(sd, 0xe0) & 0x40) ? "auto" : "manual");\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7842_cp_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nstruct v4l2_dv_timings timings;\r\nu8 reg_io_0x02 = io_read(sd, 0x02);\r\nu8 reg_io_0x21 = io_read(sd, 0x21);\r\nu8 reg_rep_0x77 = rep_read(sd, 0x77);\r\nu8 reg_rep_0x7d = rep_read(sd, 0x7d);\r\nbool audio_pll_locked = hdmi_read(sd, 0x04) & 0x01;\r\nbool audio_sample_packet_detect = hdmi_read(sd, 0x18) & 0x01;\r\nbool audio_mute = io_read(sd, 0x65) & 0x40;\r\nstatic const char * const csc_coeff_sel_rb[16] = {\r\n"bypassed", "YPbPr601 -> RGB", "reserved", "YPbPr709 -> RGB",\r\n"reserved", "RGB -> YPbPr601", "reserved", "RGB -> YPbPr709",\r\n"reserved", "YPbPr709 -> YPbPr601", "YPbPr601 -> YPbPr709",\r\n"reserved", "reserved", "reserved", "reserved", "manual"\r\n};\r\nstatic const char * const input_color_space_txt[16] = {\r\n"RGB limited range (16-235)", "RGB full range (0-255)",\r\n"YCbCr Bt.601 (16-235)", "YCbCr Bt.709 (16-235)",\r\n"xvYCC Bt.601", "xvYCC Bt.709",\r\n"YCbCr Bt.601 (0-255)", "YCbCr Bt.709 (0-255)",\r\n"invalid", "invalid", "invalid", "invalid", "invalid",\r\n"invalid", "invalid", "automatic"\r\n};\r\nstatic const char * const rgb_quantization_range_txt[] = {\r\n"Automatic",\r\n"RGB limited range (16-235)",\r\n"RGB full range (0-255)",\r\n};\r\nstatic const char * const deep_color_mode_txt[4] = {\r\n"8-bits per channel",\r\n"10-bits per channel",\r\n"12-bits per channel",\r\n"16-bits per channel (not supported)"\r\n};\r\nv4l2_info(sd, "-----Chip status-----\n");\r\nv4l2_info(sd, "Chip power: %s\n", no_power(sd) ? "off" : "on");\r\nv4l2_info(sd, "HDMI/DVI-D port selected: %s\n",\r\nstate->hdmi_port_a ? "A" : "B");\r\nv4l2_info(sd, "EDID A %s, B %s\n",\r\n((reg_rep_0x7d & 0x04) && (reg_rep_0x77 & 0x04)) ?\r\n"enabled" : "disabled",\r\n((reg_rep_0x7d & 0x08) && (reg_rep_0x77 & 0x08)) ?\r\n"enabled" : "disabled");\r\nv4l2_info(sd, "HPD A %s, B %s\n",\r\nreg_io_0x21 & 0x02 ? "enabled" : "disabled",\r\nreg_io_0x21 & 0x01 ? "enabled" : "disabled");\r\nv4l2_info(sd, "CEC %s\n", !!(cec_read(sd, 0x2a) & 0x01) ?\r\n"enabled" : "disabled");\r\nv4l2_info(sd, "-----Signal status-----\n");\r\nif (state->hdmi_port_a) {\r\nv4l2_info(sd, "Cable detected (+5V power): %s\n",\r\nio_read(sd, 0x6f) & 0x02 ? "true" : "false");\r\nv4l2_info(sd, "TMDS signal detected: %s\n",\r\n(io_read(sd, 0x6a) & 0x02) ? "true" : "false");\r\nv4l2_info(sd, "TMDS signal locked: %s\n",\r\n(io_read(sd, 0x6a) & 0x20) ? "true" : "false");\r\n} else {\r\nv4l2_info(sd, "Cable detected (+5V power):%s\n",\r\nio_read(sd, 0x6f) & 0x01 ? "true" : "false");\r\nv4l2_info(sd, "TMDS signal detected: %s\n",\r\n(io_read(sd, 0x6a) & 0x01) ? "true" : "false");\r\nv4l2_info(sd, "TMDS signal locked: %s\n",\r\n(io_read(sd, 0x6a) & 0x10) ? "true" : "false");\r\n}\r\nv4l2_info(sd, "CP free run: %s\n",\r\n(!!(cp_read(sd, 0xff) & 0x10) ? "on" : "off"));\r\nv4l2_info(sd, "Prim-mode = 0x%x, video std = 0x%x, v_freq = 0x%x\n",\r\nio_read(sd, 0x01) & 0x0f, io_read(sd, 0x00) & 0x3f,\r\n(io_read(sd, 0x01) & 0x70) >> 4);\r\nv4l2_info(sd, "-----Video Timings-----\n");\r\nif (no_cp_signal(sd)) {\r\nv4l2_info(sd, "STDI: not locked\n");\r\n} else {\r\nu32 bl = ((cp_read(sd, 0xb1) & 0x3f) << 8) | cp_read(sd, 0xb2);\r\nu32 lcf = ((cp_read(sd, 0xb3) & 0x7) << 8) | cp_read(sd, 0xb4);\r\nu32 lcvs = cp_read(sd, 0xb3) >> 3;\r\nu32 fcl = ((cp_read(sd, 0xb8) & 0x1f) << 8) | cp_read(sd, 0xb9);\r\nchar hs_pol = ((cp_read(sd, 0xb5) & 0x10) ?\r\n((cp_read(sd, 0xb5) & 0x08) ? '+' : '-') : 'x');\r\nchar vs_pol = ((cp_read(sd, 0xb5) & 0x40) ?\r\n((cp_read(sd, 0xb5) & 0x20) ? '+' : '-') : 'x');\r\nv4l2_info(sd,\r\n"STDI: lcf (frame height - 1) = %d, bl = %d, lcvs (vsync) = %d, fcl = %d, %s, %chsync, %cvsync\n",\r\nlcf, bl, lcvs, fcl,\r\n(cp_read(sd, 0xb1) & 0x40) ?\r\n"interlaced" : "progressive",\r\nhs_pol, vs_pol);\r\n}\r\nif (adv7842_query_dv_timings(sd, &timings))\r\nv4l2_info(sd, "No video detected\n");\r\nelse\r\nv4l2_print_dv_timings(sd->name, "Detected format: ",\r\n&timings, true);\r\nv4l2_print_dv_timings(sd->name, "Configured format: ",\r\n&state->timings, true);\r\nif (no_cp_signal(sd))\r\nreturn 0;\r\nv4l2_info(sd, "-----Color space-----\n");\r\nv4l2_info(sd, "RGB quantization range ctrl: %s\n",\r\nrgb_quantization_range_txt[state->rgb_quantization_range]);\r\nv4l2_info(sd, "Input color space: %s\n",\r\ninput_color_space_txt[reg_io_0x02 >> 4]);\r\nv4l2_info(sd, "Output color space: %s %s, saturator %s\n",\r\n(reg_io_0x02 & 0x02) ? "RGB" : "YCbCr",\r\n(reg_io_0x02 & 0x04) ? "(16-235)" : "(0-255)",\r\n((reg_io_0x02 & 0x04) ^ (reg_io_0x02 & 0x01)) ?\r\n"enabled" : "disabled");\r\nv4l2_info(sd, "Color space conversion: %s\n",\r\ncsc_coeff_sel_rb[cp_read(sd, 0xf4) >> 4]);\r\nif (!is_digital_input(sd))\r\nreturn 0;\r\nv4l2_info(sd, "-----%s status-----\n", is_hdmi(sd) ? "HDMI" : "DVI-D");\r\nv4l2_info(sd, "HDCP encrypted content: %s\n",\r\n(hdmi_read(sd, 0x05) & 0x40) ? "true" : "false");\r\nv4l2_info(sd, "HDCP keys read: %s%s\n",\r\n(hdmi_read(sd, 0x04) & 0x20) ? "yes" : "no",\r\n(hdmi_read(sd, 0x04) & 0x10) ? "ERROR" : "");\r\nif (!is_hdmi(sd))\r\nreturn 0;\r\nv4l2_info(sd, "Audio: pll %s, samples %s, %s\n",\r\naudio_pll_locked ? "locked" : "not locked",\r\naudio_sample_packet_detect ? "detected" : "not detected",\r\naudio_mute ? "muted" : "enabled");\r\nif (audio_pll_locked && audio_sample_packet_detect) {\r\nv4l2_info(sd, "Audio format: %s\n",\r\n(hdmi_read(sd, 0x07) & 0x40) ? "multi-channel" : "stereo");\r\n}\r\nv4l2_info(sd, "Audio CTS: %u\n", (hdmi_read(sd, 0x5b) << 12) +\r\n(hdmi_read(sd, 0x5c) << 8) +\r\n(hdmi_read(sd, 0x5d) & 0xf0));\r\nv4l2_info(sd, "Audio N: %u\n", ((hdmi_read(sd, 0x5d) & 0x0f) << 16) +\r\n(hdmi_read(sd, 0x5e) << 8) +\r\nhdmi_read(sd, 0x5f));\r\nv4l2_info(sd, "AV Mute: %s\n",\r\n(hdmi_read(sd, 0x04) & 0x40) ? "on" : "off");\r\nv4l2_info(sd, "Deep color mode: %s\n",\r\ndeep_color_mode_txt[hdmi_read(sd, 0x0b) >> 6]);\r\nadv7842_log_infoframes(sd);\r\nreturn 0;\r\n}\r\nstatic int adv7842_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nif (state->mode == ADV7842_MODE_SDP)\r\nreturn adv7842_sdp_log_status(sd);\r\nreturn adv7842_cp_log_status(sd);\r\n}\r\nstatic int adv7842_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\nif (state->mode != ADV7842_MODE_SDP)\r\nreturn -ENODATA;\r\nif (!(sdp_read(sd, 0x5A) & 0x01)) {\r\n*std = 0;\r\nv4l2_dbg(1, debug, sd, "%s: no valid signal\n", __func__);\r\nreturn 0;\r\n}\r\nswitch (sdp_read(sd, 0x52) & 0x0f) {\r\ncase 0:\r\n*std &= V4L2_STD_NTSC;\r\nbreak;\r\ncase 2:\r\n*std &= V4L2_STD_NTSC_443;\r\nbreak;\r\ncase 3:\r\n*std &= V4L2_STD_SECAM;\r\nbreak;\r\ncase 4:\r\n*std &= V4L2_STD_PAL_M;\r\nbreak;\r\ncase 6:\r\n*std &= V4L2_STD_PAL_60;\r\nbreak;\r\ncase 0xc:\r\n*std &= V4L2_STD_PAL_Nc;\r\nbreak;\r\ncase 0xe:\r\n*std &= V4L2_STD_PAL;\r\nbreak;\r\ncase 0xf:\r\n*std &= V4L2_STD_SECAM;\r\nbreak;\r\ndefault:\r\n*std &= V4L2_STD_ALL;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void adv7842_s_sdp_io(struct v4l2_subdev *sd, struct adv7842_sdp_io_sync_adjustment *s)\r\n{\r\nif (s && s->adjust) {\r\nsdp_io_write(sd, 0x94, (s->hs_beg >> 8) & 0xf);\r\nsdp_io_write(sd, 0x95, s->hs_beg & 0xff);\r\nsdp_io_write(sd, 0x96, (s->hs_width >> 8) & 0xf);\r\nsdp_io_write(sd, 0x97, s->hs_width & 0xff);\r\nsdp_io_write(sd, 0x98, (s->de_beg >> 8) & 0xf);\r\nsdp_io_write(sd, 0x99, s->de_beg & 0xff);\r\nsdp_io_write(sd, 0x9a, (s->de_end >> 8) & 0xf);\r\nsdp_io_write(sd, 0x9b, s->de_end & 0xff);\r\nsdp_io_write(sd, 0xa8, s->vs_beg_o);\r\nsdp_io_write(sd, 0xa9, s->vs_beg_e);\r\nsdp_io_write(sd, 0xaa, s->vs_end_o);\r\nsdp_io_write(sd, 0xab, s->vs_end_e);\r\nsdp_io_write(sd, 0xac, s->de_v_beg_o);\r\nsdp_io_write(sd, 0xad, s->de_v_beg_e);\r\nsdp_io_write(sd, 0xae, s->de_v_end_o);\r\nsdp_io_write(sd, 0xaf, s->de_v_end_e);\r\n} else {\r\nsdp_io_write(sd, 0x94, 0x00);\r\nsdp_io_write(sd, 0x95, 0x00);\r\nsdp_io_write(sd, 0x96, 0x00);\r\nsdp_io_write(sd, 0x97, 0x20);\r\nsdp_io_write(sd, 0x98, 0x00);\r\nsdp_io_write(sd, 0x99, 0x00);\r\nsdp_io_write(sd, 0x9a, 0x00);\r\nsdp_io_write(sd, 0x9b, 0x00);\r\nsdp_io_write(sd, 0xa8, 0x04);\r\nsdp_io_write(sd, 0xa9, 0x04);\r\nsdp_io_write(sd, 0xaa, 0x04);\r\nsdp_io_write(sd, 0xab, 0x04);\r\nsdp_io_write(sd, 0xac, 0x04);\r\nsdp_io_write(sd, 0xad, 0x04);\r\nsdp_io_write(sd, 0xae, 0x04);\r\nsdp_io_write(sd, 0xaf, 0x04);\r\n}\r\n}\r\nstatic int adv7842_s_std(struct v4l2_subdev *sd, v4l2_std_id norm)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nstruct adv7842_platform_data *pdata = &state->pdata;\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\nif (state->mode != ADV7842_MODE_SDP)\r\nreturn -ENODATA;\r\nif (norm & V4L2_STD_625_50)\r\nadv7842_s_sdp_io(sd, &pdata->sdp_io_sync_625);\r\nelse if (norm & V4L2_STD_525_60)\r\nadv7842_s_sdp_io(sd, &pdata->sdp_io_sync_525);\r\nelse\r\nadv7842_s_sdp_io(sd, NULL);\r\nif (norm & V4L2_STD_ALL) {\r\nstate->norm = norm;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int adv7842_g_std(struct v4l2_subdev *sd, v4l2_std_id *norm)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\nif (state->mode != ADV7842_MODE_SDP)\r\nreturn -ENODATA;\r\n*norm = state->norm;\r\nreturn 0;\r\n}\r\nstatic int adv7842_core_init(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nstruct adv7842_platform_data *pdata = &state->pdata;\r\nhdmi_write(sd, 0x48,\r\n(pdata->disable_pwrdnb ? 0x80 : 0) |\r\n(pdata->disable_cable_det_rst ? 0x40 : 0));\r\ndisable_input(sd);\r\nrep_write_and_or(sd, 0x77, 0xd3, 0x20);\r\nio_write(sd, 0x0c, 0x42);\r\nio_write(sd, 0x15, 0x80);\r\nio_write(sd, 0x02,\r\n0xf0 |\r\npdata->alt_gamma << 3 |\r\npdata->op_656_range << 2 |\r\npdata->alt_data_sat << 0);\r\nio_write_and_or(sd, 0x05, 0xf0, pdata->blank_data << 3 |\r\npdata->insert_av_codes << 2 |\r\npdata->replicate_av_codes << 1);\r\nadv7842_setup_format(state);\r\nhdmi_write_and_or(sd, 0x1a, 0xf1, 0x08);\r\nio_write_and_or(sd, 0x14, 0xc0,\r\npdata->dr_str_data << 4 |\r\npdata->dr_str_clk << 2 |\r\npdata->dr_str_sync);\r\ncp_write_and_or(sd, 0xba, 0xfc, pdata->hdmi_free_run_enable |\r\n(pdata->hdmi_free_run_mode << 1));\r\nsdp_write_and_or(sd, 0xdd, 0xf0, pdata->sdp_free_run_force |\r\n(pdata->sdp_free_run_cbar_en << 1) |\r\n(pdata->sdp_free_run_man_col_en << 2) |\r\n(pdata->sdp_free_run_auto << 3));\r\ncp_write(sd, 0x69, 0x14);\r\nio_write(sd, 0x06, 0xa6);\r\ncp_write(sd, 0xf3, 0xdc);\r\nafe_write(sd, 0xb5, 0x01);\r\nafe_write(sd, 0x02, pdata->ain_sel);\r\nio_write_and_or(sd, 0x30, ~(1 << 4), pdata->output_bus_lsb_to_msb << 4);\r\nsdp_csc_coeff(sd, &pdata->sdp_csc_coeff);\r\nif (pdata->sd_ram_size >= 128) {\r\nsdp_write(sd, 0x12, 0x0d);\r\nif (pdata->sd_ram_ddr) {\r\nsdp_io_write(sd, 0x6f, 0x00);\r\nsdp_io_write(sd, 0x75, 0x0a);\r\nsdp_io_write(sd, 0x7a, 0xa5);\r\nsdp_io_write(sd, 0x7b, 0x8f);\r\nsdp_io_write(sd, 0x60, 0x01);\r\n} else {\r\nsdp_io_write(sd, 0x75, 0x0a);\r\nsdp_io_write(sd, 0x74, 0x00);\r\nsdp_io_write(sd, 0x79, 0x33);\r\nsdp_io_write(sd, 0x6f, 0x01);\r\nsdp_io_write(sd, 0x7a, 0xa5);\r\nsdp_io_write(sd, 0x7b, 0x8f);\r\nsdp_io_write(sd, 0x60, 0x01);\r\n}\r\n} else {\r\nsdp_io_write(sd, 0x29, 0x10);\r\n}\r\nselect_input(sd, pdata->vid_std_select);\r\nenable_input(sd);\r\nif (pdata->hpa_auto) {\r\nhdmi_write(sd, 0x69, 0x5c);\r\n} else {\r\nhdmi_write(sd, 0x69, 0xa3);\r\nio_write_and_or(sd, 0x20, 0xcf, 0x00);\r\n}\r\nio_write(sd, 0x19, 0x80 | pdata->llc_dll_phase);\r\nio_write(sd, 0x33, 0x40);\r\nio_write(sd, 0x40, 0xf2);\r\nadv7842_irq_enable(sd, true);\r\nreturn v4l2_ctrl_handler_setup(sd->ctrl_handler);\r\n}\r\nstatic int adv7842_ddr_ram_test(struct v4l2_subdev *sd)\r\n{\r\nint i;\r\nint pass = 0;\r\nint fail = 0;\r\nint complete = 0;\r\nio_write(sd, 0x00, 0x01);\r\nio_write(sd, 0x01, 0x00);\r\nafe_write(sd, 0x80, 0x92);\r\nafe_write(sd, 0x9B, 0x01);\r\nafe_write(sd, 0x9C, 0x60);\r\nafe_write(sd, 0x9E, 0x02);\r\nafe_write(sd, 0xA0, 0x0B);\r\nafe_write(sd, 0xC3, 0x02);\r\nio_write(sd, 0x0C, 0x40);\r\nio_write(sd, 0x15, 0xBA);\r\nsdp_write(sd, 0x12, 0x00);\r\nio_write(sd, 0xFF, 0x04);\r\nmdelay(5);\r\nsdp_write(sd, 0x12, 0x00);\r\nsdp_io_write(sd, 0x2A, 0x01);\r\nsdp_io_write(sd, 0x7c, 0x19);\r\nsdp_io_write(sd, 0x80, 0x87);\r\nsdp_io_write(sd, 0x81, 0x4a);\r\nsdp_io_write(sd, 0x82, 0x2c);\r\nsdp_io_write(sd, 0x83, 0x0e);\r\nsdp_io_write(sd, 0x84, 0x94);\r\nsdp_io_write(sd, 0x85, 0x62);\r\nsdp_io_write(sd, 0x7d, 0x00);\r\nsdp_io_write(sd, 0x7e, 0x1a);\r\nmdelay(5);\r\nsdp_io_write(sd, 0xd9, 0xd5);\r\nsdp_write(sd, 0x12, 0x05);\r\nmdelay(20);\r\nfor (i = 0; i < 10; i++) {\r\nu8 result = sdp_io_read(sd, 0xdb);\r\nif (result & 0x10) {\r\ncomplete++;\r\nif (result & 0x20)\r\nfail++;\r\nelse\r\npass++;\r\n}\r\nmdelay(20);\r\n}\r\nv4l2_dbg(1, debug, sd,\r\n"Ram Test: completed %d of %d: pass %d, fail %d\n",\r\ncomplete, i, pass, fail);\r\nif (!complete || fail)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void adv7842_rewrite_i2c_addresses(struct v4l2_subdev *sd,\r\nstruct adv7842_platform_data *pdata)\r\n{\r\nio_write(sd, 0xf1, pdata->i2c_sdp << 1);\r\nio_write(sd, 0xf2, pdata->i2c_sdp_io << 1);\r\nio_write(sd, 0xf3, pdata->i2c_avlink << 1);\r\nio_write(sd, 0xf4, pdata->i2c_cec << 1);\r\nio_write(sd, 0xf5, pdata->i2c_infoframe << 1);\r\nio_write(sd, 0xf8, pdata->i2c_afe << 1);\r\nio_write(sd, 0xf9, pdata->i2c_repeater << 1);\r\nio_write(sd, 0xfa, pdata->i2c_edid << 1);\r\nio_write(sd, 0xfb, pdata->i2c_hdmi << 1);\r\nio_write(sd, 0xfd, pdata->i2c_cp << 1);\r\nio_write(sd, 0xfe, pdata->i2c_vdp << 1);\r\n}\r\nstatic int adv7842_command_ram_test(struct v4l2_subdev *sd)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct adv7842_state *state = to_state(sd);\r\nstruct adv7842_platform_data *pdata = client->dev.platform_data;\r\nstruct v4l2_dv_timings timings;\r\nint ret = 0;\r\nif (!pdata)\r\nreturn -ENODEV;\r\nif (!pdata->sd_ram_size || !pdata->sd_ram_ddr) {\r\nv4l2_info(sd, "no sdram or no ddr sdram\n");\r\nreturn -EINVAL;\r\n}\r\nmain_reset(sd);\r\nadv7842_rewrite_i2c_addresses(sd, pdata);\r\nret = adv7842_ddr_ram_test(sd);\r\nmain_reset(sd);\r\nadv7842_rewrite_i2c_addresses(sd, pdata);\r\nadv7842_core_init(sd);\r\ndisable_input(sd);\r\nselect_input(sd, state->vid_std_select);\r\nenable_input(sd);\r\nedid_write_vga_segment(sd);\r\nedid_write_hdmi_segment(sd, ADV7842_EDID_PORT_A);\r\nedid_write_hdmi_segment(sd, ADV7842_EDID_PORT_B);\r\ntimings = state->timings;\r\nmemset(&state->timings, 0, sizeof(struct v4l2_dv_timings));\r\nadv7842_s_dv_timings(sd, &timings);\r\nreturn ret;\r\n}\r\nstatic long adv7842_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\r\n{\r\nswitch (cmd) {\r\ncase ADV7842_CMD_RAM_TEST:\r\nreturn adv7842_command_ram_test(sd);\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic int adv7842_subscribe_event(struct v4l2_subdev *sd,\r\nstruct v4l2_fh *fh,\r\nstruct v4l2_event_subscription *sub)\r\n{\r\nswitch (sub->type) {\r\ncase V4L2_EVENT_SOURCE_CHANGE:\r\nreturn v4l2_src_change_event_subdev_subscribe(sd, fh, sub);\r\ncase V4L2_EVENT_CTRL:\r\nreturn v4l2_ctrl_subdev_subscribe_event(sd, fh, sub);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void adv7842_unregister_clients(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nif (state->i2c_avlink)\r\ni2c_unregister_device(state->i2c_avlink);\r\nif (state->i2c_cec)\r\ni2c_unregister_device(state->i2c_cec);\r\nif (state->i2c_infoframe)\r\ni2c_unregister_device(state->i2c_infoframe);\r\nif (state->i2c_sdp_io)\r\ni2c_unregister_device(state->i2c_sdp_io);\r\nif (state->i2c_sdp)\r\ni2c_unregister_device(state->i2c_sdp);\r\nif (state->i2c_afe)\r\ni2c_unregister_device(state->i2c_afe);\r\nif (state->i2c_repeater)\r\ni2c_unregister_device(state->i2c_repeater);\r\nif (state->i2c_edid)\r\ni2c_unregister_device(state->i2c_edid);\r\nif (state->i2c_hdmi)\r\ni2c_unregister_device(state->i2c_hdmi);\r\nif (state->i2c_cp)\r\ni2c_unregister_device(state->i2c_cp);\r\nif (state->i2c_vdp)\r\ni2c_unregister_device(state->i2c_vdp);\r\nstate->i2c_avlink = NULL;\r\nstate->i2c_cec = NULL;\r\nstate->i2c_infoframe = NULL;\r\nstate->i2c_sdp_io = NULL;\r\nstate->i2c_sdp = NULL;\r\nstate->i2c_afe = NULL;\r\nstate->i2c_repeater = NULL;\r\nstate->i2c_edid = NULL;\r\nstate->i2c_hdmi = NULL;\r\nstate->i2c_cp = NULL;\r\nstate->i2c_vdp = NULL;\r\n}\r\nstatic struct i2c_client *adv7842_dummy_client(struct v4l2_subdev *sd, const char *desc,\r\nu8 addr, u8 io_reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct i2c_client *cp;\r\nio_write(sd, io_reg, addr << 1);\r\nif (addr == 0) {\r\nv4l2_err(sd, "no %s i2c addr configured\n", desc);\r\nreturn NULL;\r\n}\r\ncp = i2c_new_dummy(client->adapter, io_read(sd, io_reg) >> 1);\r\nif (!cp)\r\nv4l2_err(sd, "register %s on i2c addr 0x%x failed\n", desc, addr);\r\nreturn cp;\r\n}\r\nstatic int adv7842_register_clients(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7842_state *state = to_state(sd);\r\nstruct adv7842_platform_data *pdata = &state->pdata;\r\nstate->i2c_avlink = adv7842_dummy_client(sd, "avlink", pdata->i2c_avlink, 0xf3);\r\nstate->i2c_cec = adv7842_dummy_client(sd, "cec", pdata->i2c_cec, 0xf4);\r\nstate->i2c_infoframe = adv7842_dummy_client(sd, "infoframe", pdata->i2c_infoframe, 0xf5);\r\nstate->i2c_sdp_io = adv7842_dummy_client(sd, "sdp_io", pdata->i2c_sdp_io, 0xf2);\r\nstate->i2c_sdp = adv7842_dummy_client(sd, "sdp", pdata->i2c_sdp, 0xf1);\r\nstate->i2c_afe = adv7842_dummy_client(sd, "afe", pdata->i2c_afe, 0xf8);\r\nstate->i2c_repeater = adv7842_dummy_client(sd, "repeater", pdata->i2c_repeater, 0xf9);\r\nstate->i2c_edid = adv7842_dummy_client(sd, "edid", pdata->i2c_edid, 0xfa);\r\nstate->i2c_hdmi = adv7842_dummy_client(sd, "hdmi", pdata->i2c_hdmi, 0xfb);\r\nstate->i2c_cp = adv7842_dummy_client(sd, "cp", pdata->i2c_cp, 0xfd);\r\nstate->i2c_vdp = adv7842_dummy_client(sd, "vdp", pdata->i2c_vdp, 0xfe);\r\nif (!state->i2c_avlink ||\r\n!state->i2c_cec ||\r\n!state->i2c_infoframe ||\r\n!state->i2c_sdp_io ||\r\n!state->i2c_sdp ||\r\n!state->i2c_afe ||\r\n!state->i2c_repeater ||\r\n!state->i2c_edid ||\r\n!state->i2c_hdmi ||\r\n!state->i2c_cp ||\r\n!state->i2c_vdp)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int adv7842_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct adv7842_state *state;\r\nstatic const struct v4l2_dv_timings cea640x480 =\r\nV4L2_DV_BT_CEA_640X480P59_94;\r\nstruct adv7842_platform_data *pdata = client->dev.platform_data;\r\nstruct v4l2_ctrl_handler *hdl;\r\nstruct v4l2_subdev *sd;\r\nu16 rev;\r\nint err;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nv4l_dbg(1, debug, client, "detecting adv7842 client on address 0x%x\n",\r\nclient->addr << 1);\r\nif (!pdata) {\r\nv4l_err(client, "No platform data!\n");\r\nreturn -ENODEV;\r\n}\r\nstate = devm_kzalloc(&client->dev, sizeof(struct adv7842_state), GFP_KERNEL);\r\nif (!state) {\r\nv4l_err(client, "Could not allocate adv7842_state memory!\n");\r\nreturn -ENOMEM;\r\n}\r\nstate->pdata = *pdata;\r\nstate->timings = cea640x480;\r\nstate->format = adv7842_format_info(state, MEDIA_BUS_FMT_YUYV8_2X8);\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, client, &adv7842_ops);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;\r\nstate->mode = pdata->mode;\r\nstate->hdmi_port_a = pdata->input == ADV7842_SELECT_HDMI_PORT_A;\r\nstate->restart_stdi_once = true;\r\nrev = adv_smbus_read_byte_data_check(client, 0xea, false) << 8 |\r\nadv_smbus_read_byte_data_check(client, 0xeb, false);\r\nif (rev != 0x2012) {\r\nv4l2_info(sd, "got rev=0x%04x on first read attempt\n", rev);\r\nrev = adv_smbus_read_byte_data_check(client, 0xea, false) << 8 |\r\nadv_smbus_read_byte_data_check(client, 0xeb, false);\r\n}\r\nif (rev != 0x2012) {\r\nv4l2_info(sd, "not an adv7842 on address 0x%x (rev=0x%04x)\n",\r\nclient->addr << 1, rev);\r\nreturn -ENODEV;\r\n}\r\nif (pdata->chip_reset)\r\nmain_reset(sd);\r\nhdl = &state->hdl;\r\nv4l2_ctrl_handler_init(hdl, 6);\r\nv4l2_ctrl_new_std(hdl, &adv7842_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &adv7842_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(hdl, &adv7842_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(hdl, &adv7842_ctrl_ops,\r\nV4L2_CID_HUE, 0, 128, 1, 0);\r\nstate->detect_tx_5v_ctrl = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_DV_RX_POWER_PRESENT, 0, 3, 0, 0);\r\nstate->analog_sampling_phase_ctrl = v4l2_ctrl_new_custom(hdl,\r\n&adv7842_ctrl_analog_sampling_phase, NULL);\r\nstate->free_run_color_ctrl_manual = v4l2_ctrl_new_custom(hdl,\r\n&adv7842_ctrl_free_run_color_manual, NULL);\r\nstate->free_run_color_ctrl = v4l2_ctrl_new_custom(hdl,\r\n&adv7842_ctrl_free_run_color, NULL);\r\nstate->rgb_quantization_range_ctrl =\r\nv4l2_ctrl_new_std_menu(hdl, &adv7842_ctrl_ops,\r\nV4L2_CID_DV_RX_RGB_RANGE, V4L2_DV_RGB_RANGE_FULL,\r\n0, V4L2_DV_RGB_RANGE_AUTO);\r\nsd->ctrl_handler = hdl;\r\nif (hdl->error) {\r\nerr = hdl->error;\r\ngoto err_hdl;\r\n}\r\nstate->detect_tx_5v_ctrl->is_private = true;\r\nstate->rgb_quantization_range_ctrl->is_private = true;\r\nstate->analog_sampling_phase_ctrl->is_private = true;\r\nstate->free_run_color_ctrl_manual->is_private = true;\r\nstate->free_run_color_ctrl->is_private = true;\r\nif (adv7842_s_detect_tx_5v_ctrl(sd)) {\r\nerr = -ENODEV;\r\ngoto err_hdl;\r\n}\r\nif (adv7842_register_clients(sd) < 0) {\r\nerr = -ENOMEM;\r\nv4l2_err(sd, "failed to create all i2c clients\n");\r\ngoto err_i2c;\r\n}\r\nstate->work_queues = create_singlethread_workqueue(client->name);\r\nif (!state->work_queues) {\r\nv4l2_err(sd, "Could not create work queue\n");\r\nerr = -ENOMEM;\r\ngoto err_i2c;\r\n}\r\nINIT_DELAYED_WORK(&state->delayed_work_enable_hotplug,\r\nadv7842_delayed_work_enable_hotplug);\r\nstate->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nerr = media_entity_init(&sd->entity, 1, &state->pad, 0);\r\nif (err)\r\ngoto err_work_queues;\r\nerr = adv7842_core_init(sd);\r\nif (err)\r\ngoto err_entity;\r\nv4l2_info(sd, "%s found @ 0x%x (%s)\n", client->name,\r\nclient->addr << 1, client->adapter->name);\r\nreturn 0;\r\nerr_entity:\r\nmedia_entity_cleanup(&sd->entity);\r\nerr_work_queues:\r\ncancel_delayed_work(&state->delayed_work_enable_hotplug);\r\ndestroy_workqueue(state->work_queues);\r\nerr_i2c:\r\nadv7842_unregister_clients(sd);\r\nerr_hdl:\r\nv4l2_ctrl_handler_free(hdl);\r\nreturn err;\r\n}\r\nstatic int adv7842_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct adv7842_state *state = to_state(sd);\r\nadv7842_irq_enable(sd, false);\r\ncancel_delayed_work(&state->delayed_work_enable_hotplug);\r\ndestroy_workqueue(state->work_queues);\r\nv4l2_device_unregister_subdev(sd);\r\nmedia_entity_cleanup(&sd->entity);\r\nadv7842_unregister_clients(sd);\r\nv4l2_ctrl_handler_free(sd->ctrl_handler);\r\nreturn 0;\r\n}
