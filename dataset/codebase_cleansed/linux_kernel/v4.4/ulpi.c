int ulpi_read(struct ulpi *ulpi, u8 addr)\r\n{\r\nreturn ulpi->ops->read(ulpi->ops, addr);\r\n}\r\nint ulpi_write(struct ulpi *ulpi, u8 addr, u8 val)\r\n{\r\nreturn ulpi->ops->write(ulpi->ops, addr, val);\r\n}\r\nstatic int ulpi_match(struct device *dev, struct device_driver *driver)\r\n{\r\nstruct ulpi_driver *drv = to_ulpi_driver(driver);\r\nstruct ulpi *ulpi = to_ulpi_dev(dev);\r\nconst struct ulpi_device_id *id;\r\nfor (id = drv->id_table; id->vendor; id++)\r\nif (id->vendor == ulpi->id.vendor &&\r\nid->product == ulpi->id.product)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ulpi_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct ulpi *ulpi = to_ulpi_dev(dev);\r\nif (add_uevent_var(env, "MODALIAS=ulpi:v%04xp%04x",\r\nulpi->id.vendor, ulpi->id.product))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int ulpi_probe(struct device *dev)\r\n{\r\nstruct ulpi_driver *drv = to_ulpi_driver(dev->driver);\r\nreturn drv->probe(to_ulpi_dev(dev));\r\n}\r\nstatic int ulpi_remove(struct device *dev)\r\n{\r\nstruct ulpi_driver *drv = to_ulpi_driver(dev->driver);\r\nif (drv->remove)\r\ndrv->remove(to_ulpi_dev(dev));\r\nreturn 0;\r\n}\r\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ulpi *ulpi = to_ulpi_dev(dev);\r\nreturn sprintf(buf, "ulpi:v%04xp%04x\n",\r\nulpi->id.vendor, ulpi->id.product);\r\n}\r\nstatic void ulpi_dev_release(struct device *dev)\r\n{\r\nkfree(to_ulpi_dev(dev));\r\n}\r\nint ulpi_register_driver(struct ulpi_driver *drv)\r\n{\r\nif (!drv->probe)\r\nreturn -EINVAL;\r\ndrv->driver.bus = &ulpi_bus;\r\nreturn driver_register(&drv->driver);\r\n}\r\nvoid ulpi_unregister_driver(struct ulpi_driver *drv)\r\n{\r\ndriver_unregister(&drv->driver);\r\n}\r\nstatic int ulpi_register(struct device *dev, struct ulpi *ulpi)\r\n{\r\nint ret;\r\nret = ulpi_write(ulpi, ULPI_SCRATCH, 0xaa);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ulpi_read(ulpi, ULPI_SCRATCH);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != 0xaa)\r\nreturn -ENODEV;\r\nulpi->id.vendor = ulpi_read(ulpi, ULPI_VENDOR_ID_LOW);\r\nulpi->id.vendor |= ulpi_read(ulpi, ULPI_VENDOR_ID_HIGH) << 8;\r\nulpi->id.product = ulpi_read(ulpi, ULPI_PRODUCT_ID_LOW);\r\nulpi->id.product |= ulpi_read(ulpi, ULPI_PRODUCT_ID_HIGH) << 8;\r\nulpi->dev.parent = dev;\r\nulpi->dev.bus = &ulpi_bus;\r\nulpi->dev.type = &ulpi_dev_type;\r\ndev_set_name(&ulpi->dev, "%s.ulpi", dev_name(dev));\r\nACPI_COMPANION_SET(&ulpi->dev, ACPI_COMPANION(dev));\r\nrequest_module("ulpi:v%04xp%04x", ulpi->id.vendor, ulpi->id.product);\r\nret = device_register(&ulpi->dev);\r\nif (ret)\r\nreturn ret;\r\ndev_dbg(&ulpi->dev, "registered ULPI PHY: vendor %04x, product %04x\n",\r\nulpi->id.vendor, ulpi->id.product);\r\nreturn 0;\r\n}\r\nstruct ulpi *ulpi_register_interface(struct device *dev, struct ulpi_ops *ops)\r\n{\r\nstruct ulpi *ulpi;\r\nint ret;\r\nulpi = kzalloc(sizeof(*ulpi), GFP_KERNEL);\r\nif (!ulpi)\r\nreturn ERR_PTR(-ENOMEM);\r\nulpi->ops = ops;\r\nops->dev = dev;\r\nret = ulpi_register(dev, ulpi);\r\nif (ret) {\r\nkfree(ulpi);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn ulpi;\r\n}\r\nvoid ulpi_unregister_interface(struct ulpi *ulpi)\r\n{\r\ndevice_unregister(&ulpi->dev);\r\n}\r\nstatic int __init ulpi_init(void)\r\n{\r\nreturn bus_register(&ulpi_bus);\r\n}\r\nstatic void __exit ulpi_exit(void)\r\n{\r\nbus_unregister(&ulpi_bus);\r\n}
