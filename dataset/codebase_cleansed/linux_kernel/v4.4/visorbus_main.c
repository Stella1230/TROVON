static ssize_t version_show(struct bus_type *bus, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", VERSION);\r\n}\r\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct visor_device *vdev;\r\nuuid_le guid;\r\nvdev = to_visor_device(dev);\r\nguid = visorchannel_get_uuid(vdev->visorchannel);\r\nreturn snprintf(buf, PAGE_SIZE, "visorbus:%pUl\n", &guid);\r\n}\r\nstatic int\r\nvisorbus_uevent(struct device *xdev, struct kobj_uevent_env *env)\r\n{\r\nstruct visor_device *dev;\r\nuuid_le guid;\r\ndev = to_visor_device(xdev);\r\nguid = visorchannel_get_uuid(dev->visorchannel);\r\nif (add_uevent_var(env, "MODALIAS=visorbus:%pUl", &guid))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int\r\nvisorbus_match(struct device *xdev, struct device_driver *xdrv)\r\n{\r\nuuid_le channel_type;\r\nint rc = 0;\r\nint i;\r\nstruct visor_device *dev;\r\nstruct visor_driver *drv;\r\ndev = to_visor_device(xdev);\r\ndrv = to_visor_driver(xdrv);\r\nchannel_type = visorchannel_get_uuid(dev->visorchannel);\r\nif (visorbus_forcematch) {\r\nrc = 1;\r\ngoto away;\r\n}\r\nif (visorbus_forcenomatch)\r\ngoto away;\r\nif (!drv->channel_types)\r\ngoto away;\r\nfor (i = 0;\r\n(uuid_le_cmp(drv->channel_types[i].guid, NULL_UUID_LE) != 0) ||\r\n(drv->channel_types[i].name);\r\ni++)\r\nif (uuid_le_cmp(drv->channel_types[i].guid,\r\nchannel_type) == 0) {\r\nrc = i + 1;\r\ngoto away;\r\n}\r\naway:\r\nreturn rc;\r\n}\r\nstatic void\r\nvisorbus_release_busdevice(struct device *xdev)\r\n{\r\nstruct visor_device *dev = dev_get_drvdata(xdev);\r\ndev_set_drvdata(xdev, NULL);\r\nkfree(dev);\r\n}\r\nstatic void\r\nvisorbus_release_device(struct device *xdev)\r\n{\r\nstruct visor_device *dev = to_visor_device(xdev);\r\nif (dev->periodic_work) {\r\nvisor_periodic_work_destroy(dev->periodic_work);\r\ndev->periodic_work = NULL;\r\n}\r\nif (dev->visorchannel) {\r\nvisorchannel_destroy(dev->visorchannel);\r\ndev->visorchannel = NULL;\r\n}\r\nkfree(dev);\r\n}\r\nstatic ssize_t DEVMAJORMINOR_ATTR(struct visor_device *dev, int slot, char *buf)\r\n{\r\nint maxdevnodes = ARRAY_SIZE(dev->devnodes) / sizeof(dev->devnodes[0]);\r\nif (slot < 0 || slot >= maxdevnodes)\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "%d:%d\n",\r\ndev->devnodes[slot].major, dev->devnodes[slot].minor);\r\n}\r\nstatic ssize_t\r\ndevmajorminor_attr_show(struct kobject *kobj, struct attribute *attr, char *buf)\r\n{\r\nstruct devmajorminor_attribute *devmajorminor_attr =\r\nto_devmajorminor_attr(attr);\r\nstruct visor_device *dev = to_visor_device_from_kobjdevmajorminor(kobj);\r\nssize_t ret = 0;\r\nif (devmajorminor_attr->show)\r\nret = devmajorminor_attr->show(dev,\r\ndevmajorminor_attr->slot, buf);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\ndevmajorminor_attr_store(struct kobject *kobj,\r\nstruct attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct devmajorminor_attribute *devmajorminor_attr =\r\nto_devmajorminor_attr(attr);\r\nstruct visor_device *dev = to_visor_device_from_kobjdevmajorminor(kobj);\r\nssize_t ret = 0;\r\nif (devmajorminor_attr->store)\r\nret = devmajorminor_attr->store(dev,\r\ndevmajorminor_attr->slot,\r\nbuf, count);\r\nreturn ret;\r\n}\r\nstatic int\r\ndevmajorminor_create_file(struct visor_device *dev, const char *name,\r\nint major, int minor)\r\n{\r\nint maxdevnodes = ARRAY_SIZE(dev->devnodes) / sizeof(dev->devnodes[0]);\r\nstruct devmajorminor_attribute *myattr = NULL;\r\nint x = -1, rc = 0, slot = -1;\r\nregister_devmajorminor_attributes(dev);\r\nfor (slot = 0; slot < maxdevnodes; slot++)\r\nif (!dev->devnodes[slot].attr)\r\nbreak;\r\nif (slot == maxdevnodes) {\r\nrc = -ENOMEM;\r\ngoto away;\r\n}\r\nmyattr = kzalloc(sizeof(*myattr), GFP_KERNEL);\r\nif (!myattr) {\r\nrc = -ENOMEM;\r\ngoto away;\r\n}\r\nmyattr->show = DEVMAJORMINOR_ATTR;\r\nmyattr->store = NULL;\r\nmyattr->slot = slot;\r\nmyattr->attr.name = name;\r\nmyattr->attr.mode = S_IRUGO;\r\ndev->devnodes[slot].attr = myattr;\r\ndev->devnodes[slot].major = major;\r\ndev->devnodes[slot].minor = minor;\r\nx = sysfs_create_file(&dev->kobjdevmajorminor, &myattr->attr);\r\nif (x < 0) {\r\nrc = x;\r\ngoto away;\r\n}\r\nkobject_uevent(&dev->device.kobj, KOBJ_ONLINE);\r\naway:\r\nif (rc < 0) {\r\nkfree(myattr);\r\nmyattr = NULL;\r\ndev->devnodes[slot].attr = NULL;\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\ndevmajorminor_remove_file(struct visor_device *dev, int slot)\r\n{\r\nint maxdevnodes = ARRAY_SIZE(dev->devnodes) / sizeof(dev->devnodes[0]);\r\nstruct devmajorminor_attribute *myattr = NULL;\r\nif (slot < 0 || slot >= maxdevnodes)\r\nreturn;\r\nmyattr = (struct devmajorminor_attribute *)(dev->devnodes[slot].attr);\r\nif (!myattr)\r\nreturn;\r\nsysfs_remove_file(&dev->kobjdevmajorminor, &myattr->attr);\r\nkobject_uevent(&dev->device.kobj, KOBJ_OFFLINE);\r\ndev->devnodes[slot].attr = NULL;\r\nkfree(myattr);\r\n}\r\nstatic void\r\ndevmajorminor_remove_all_files(struct visor_device *dev)\r\n{\r\nint i = 0;\r\nint maxdevnodes = ARRAY_SIZE(dev->devnodes) / sizeof(dev->devnodes[0]);\r\nfor (i = 0; i < maxdevnodes; i++)\r\ndevmajorminor_remove_file(dev, i);\r\n}\r\nstatic int\r\nregister_devmajorminor_attributes(struct visor_device *dev)\r\n{\r\nint rc = 0, x = 0;\r\nif (dev->kobjdevmajorminor.parent)\r\ngoto away;\r\nx = kobject_init_and_add(&dev->kobjdevmajorminor,\r\n&devmajorminor_kobj_type, &dev->device.kobj,\r\n"devmajorminor");\r\nif (x < 0) {\r\nrc = x;\r\ngoto away;\r\n}\r\nkobject_uevent(&dev->kobjdevmajorminor, KOBJ_ADD);\r\naway:\r\nreturn rc;\r\n}\r\nstatic void\r\nunregister_devmajorminor_attributes(struct visor_device *dev)\r\n{\r\nif (!dev->kobjdevmajorminor.parent)\r\nreturn;\r\ndevmajorminor_remove_all_files(dev);\r\nkobject_del(&dev->kobjdevmajorminor);\r\nkobject_put(&dev->kobjdevmajorminor);\r\ndev->kobjdevmajorminor.parent = NULL;\r\n}\r\nstatic ssize_t physaddr_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct visor_device *vdev = to_visor_device(dev);\r\nif (!vdev->visorchannel)\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "0x%Lx\n",\r\nvisorchannel_get_physaddr(vdev->visorchannel));\r\n}\r\nstatic ssize_t nbytes_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct visor_device *vdev = to_visor_device(dev);\r\nif (!vdev->visorchannel)\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "0x%lx\n",\r\nvisorchannel_get_nbytes(vdev->visorchannel));\r\n}\r\nstatic ssize_t clientpartition_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct visor_device *vdev = to_visor_device(dev);\r\nif (!vdev->visorchannel)\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "0x%Lx\n",\r\nvisorchannel_get_clientpartition(vdev->visorchannel));\r\n}\r\nstatic ssize_t typeguid_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct visor_device *vdev = to_visor_device(dev);\r\nchar s[99];\r\nif (!vdev->visorchannel)\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\nvisorchannel_id(vdev->visorchannel, s));\r\n}\r\nstatic ssize_t zoneguid_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct visor_device *vdev = to_visor_device(dev);\r\nchar s[99];\r\nif (!vdev->visorchannel)\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\nvisorchannel_zoneid(vdev->visorchannel, s));\r\n}\r\nstatic ssize_t typename_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct visor_device *vdev = to_visor_device(dev);\r\nint i = 0;\r\nstruct bus_type *xbus = dev->bus;\r\nstruct device_driver *xdrv = dev->driver;\r\nstruct visor_driver *drv = NULL;\r\nif (!vdev->visorchannel || !xbus || !xdrv)\r\nreturn 0;\r\ni = xbus->match(dev, xdrv);\r\nif (!i)\r\nreturn 0;\r\ndrv = to_visor_driver(xdrv);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", drv->channel_types[i - 1].name);\r\n}\r\nstatic ssize_t partition_handle_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf) {\r\nstruct visor_device *vdev = to_visor_device(dev);\r\nu64 handle = visorchannel_get_clientpartition(vdev->visorchannel);\r\nreturn snprintf(buf, PAGE_SIZE, "0x%Lx\n", handle);\r\n}\r\nstatic ssize_t partition_guid_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf) {\r\nstruct visor_device *vdev = to_visor_device(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "{%pUb}\n", &vdev->partition_uuid);\r\n}\r\nstatic ssize_t partition_name_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf) {\r\nstruct visor_device *vdev = to_visor_device(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", vdev->name);\r\n}\r\nstatic ssize_t channel_addr_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf) {\r\nstruct visor_device *vdev = to_visor_device(dev);\r\nu64 addr = visorchannel_get_physaddr(vdev->visorchannel);\r\nreturn snprintf(buf, PAGE_SIZE, "0x%Lx\n", addr);\r\n}\r\nstatic ssize_t channel_bytes_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf) {\r\nstruct visor_device *vdev = to_visor_device(dev);\r\nu64 nbytes = visorchannel_get_nbytes(vdev->visorchannel);\r\nreturn snprintf(buf, PAGE_SIZE, "0x%Lx\n", nbytes);\r\n}\r\nstatic ssize_t channel_id_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf) {\r\nstruct visor_device *vdev = to_visor_device(dev);\r\nint len = 0;\r\nif (vdev->visorchannel) {\r\nvisorchannel_id(vdev->visorchannel, buf);\r\nlen = strlen(buf);\r\nbuf[len++] = '\n';\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t client_bus_info_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf) {\r\nstruct visor_device *vdev = to_visor_device(dev);\r\nstruct visorchannel *channel = vdev->visorchannel;\r\nint i, x, remain = PAGE_SIZE;\r\nunsigned long off;\r\nchar *p = buf;\r\nu8 *partition_name;\r\nstruct ultra_vbus_deviceinfo dev_info;\r\npartition_name = "";\r\nif (channel) {\r\nif (vdev->name)\r\npartition_name = vdev->name;\r\nx = snprintf(p, remain,\r\n"Client device / client driver info for %s partition (vbus #%d):\n",\r\npartition_name, vdev->chipset_dev_no);\r\np += x;\r\nremain -= x;\r\nx = visorchannel_read(channel,\r\noffsetof(struct\r\nspar_vbus_channel_protocol,\r\nchp_info),\r\n&dev_info, sizeof(dev_info));\r\nif (x >= 0) {\r\nx = vbuschannel_devinfo_to_string(&dev_info, p,\r\nremain, -1);\r\np += x;\r\nremain -= x;\r\n}\r\nx = visorchannel_read(channel,\r\noffsetof(struct\r\nspar_vbus_channel_protocol,\r\nbus_info),\r\n&dev_info, sizeof(dev_info));\r\nif (x >= 0) {\r\nx = vbuschannel_devinfo_to_string(&dev_info, p,\r\nremain, -1);\r\np += x;\r\nremain -= x;\r\n}\r\noff = offsetof(struct spar_vbus_channel_protocol, dev_info);\r\ni = 0;\r\nwhile (off + sizeof(dev_info) <=\r\nvisorchannel_get_nbytes(channel)) {\r\nx = visorchannel_read(channel,\r\noff, &dev_info, sizeof(dev_info));\r\nif (x >= 0) {\r\nx = vbuschannel_devinfo_to_string\r\n(&dev_info, p, remain, i);\r\np += x;\r\nremain -= x;\r\n}\r\noff += sizeof(dev_info);\r\ni++;\r\n}\r\n}\r\nreturn PAGE_SIZE - remain;\r\n}\r\nstatic ssize_t\r\nDRIVER_ATTR_version(struct device_driver *xdrv, char *buf)\r\n{\r\nstruct visor_driver *drv = to_visor_driver(xdrv);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", drv->version);\r\n}\r\nstatic int\r\nregister_driver_attributes(struct visor_driver *drv)\r\n{\r\nint rc;\r\nstruct driver_attribute version =\r\n__ATTR(version, S_IRUGO, DRIVER_ATTR_version, NULL);\r\ndrv->version_attr = version;\r\nrc = driver_create_file(&drv->driver, &drv->version_attr);\r\nreturn rc;\r\n}\r\nstatic void\r\nunregister_driver_attributes(struct visor_driver *drv)\r\n{\r\ndriver_remove_file(&drv->driver, &drv->version_attr);\r\n}\r\nstatic void\r\ndev_periodic_work(void *xdev)\r\n{\r\nstruct visor_device *dev = xdev;\r\nstruct visor_driver *drv = to_visor_driver(dev->device.driver);\r\ndown(&dev->visordriver_callback_lock);\r\nif (drv->channel_interrupt)\r\ndrv->channel_interrupt(dev);\r\nup(&dev->visordriver_callback_lock);\r\nif (!visor_periodic_work_nextperiod(dev->periodic_work))\r\nput_device(&dev->device);\r\n}\r\nstatic void\r\ndev_start_periodic_work(struct visor_device *dev)\r\n{\r\nif (dev->being_removed)\r\nreturn;\r\nget_device(&dev->device);\r\nif (!visor_periodic_work_start(dev->periodic_work))\r\nput_device(&dev->device);\r\n}\r\nstatic void\r\ndev_stop_periodic_work(struct visor_device *dev)\r\n{\r\nif (visor_periodic_work_stop(dev->periodic_work))\r\nput_device(&dev->device);\r\n}\r\nstatic int\r\nvisordriver_probe_device(struct device *xdev)\r\n{\r\nint rc;\r\nstruct visor_driver *drv;\r\nstruct visor_device *dev;\r\ndrv = to_visor_driver(xdev->driver);\r\ndev = to_visor_device(xdev);\r\ndown(&dev->visordriver_callback_lock);\r\ndev->being_removed = false;\r\nwmb();\r\nget_device(&dev->device);\r\nif (!drv->probe) {\r\nup(&dev->visordriver_callback_lock);\r\nrc = -1;\r\ngoto away;\r\n}\r\nrc = drv->probe(dev);\r\nif (rc < 0)\r\ngoto away;\r\nfix_vbus_dev_info(dev);\r\nup(&dev->visordriver_callback_lock);\r\nrc = 0;\r\naway:\r\nif (rc != 0)\r\nput_device(&dev->device);\r\nreturn rc;\r\n}\r\nstatic int\r\nvisordriver_remove_device(struct device *xdev)\r\n{\r\nstruct visor_device *dev;\r\nstruct visor_driver *drv;\r\ndev = to_visor_device(xdev);\r\ndrv = to_visor_driver(xdev->driver);\r\ndown(&dev->visordriver_callback_lock);\r\ndev->being_removed = true;\r\nwmb();\r\nif (drv) {\r\nif (drv->remove)\r\ndrv->remove(dev);\r\n}\r\nup(&dev->visordriver_callback_lock);\r\ndev_stop_periodic_work(dev);\r\ndevmajorminor_remove_all_files(dev);\r\nput_device(&dev->device);\r\nreturn 0;\r\n}\r\nint visorbus_register_visor_driver(struct visor_driver *drv)\r\n{\r\nint rc = 0;\r\nif (busreg_rc < 0)\r\nreturn -ENODEV;\r\ndrv->driver.name = drv->name;\r\ndrv->driver.bus = &visorbus_type;\r\ndrv->driver.probe = visordriver_probe_device;\r\ndrv->driver.remove = visordriver_remove_device;\r\ndrv->driver.owner = drv->owner;\r\nrc = driver_register(&drv->driver);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = register_driver_attributes(drv);\r\nif (rc < 0)\r\ndriver_unregister(&drv->driver);\r\nreturn rc;\r\n}\r\nvoid\r\nvisorbus_unregister_visor_driver(struct visor_driver *drv)\r\n{\r\nunregister_driver_attributes(drv);\r\ndriver_unregister(&drv->driver);\r\n}\r\nint\r\nvisorbus_read_channel(struct visor_device *dev, unsigned long offset,\r\nvoid *dest, unsigned long nbytes)\r\n{\r\nreturn visorchannel_read(dev->visorchannel, offset, dest, nbytes);\r\n}\r\nint\r\nvisorbus_write_channel(struct visor_device *dev, unsigned long offset,\r\nvoid *src, unsigned long nbytes)\r\n{\r\nreturn visorchannel_write(dev->visorchannel, offset, src, nbytes);\r\n}\r\nint\r\nvisorbus_clear_channel(struct visor_device *dev, unsigned long offset, u8 ch,\r\nunsigned long nbytes)\r\n{\r\nreturn visorchannel_clear(dev->visorchannel, offset, ch, nbytes);\r\n}\r\nint\r\nvisorbus_registerdevnode(struct visor_device *dev,\r\nconst char *name, int major, int minor)\r\n{\r\nreturn devmajorminor_create_file(dev, name, major, minor);\r\n}\r\nvoid\r\nvisorbus_enable_channel_interrupts(struct visor_device *dev)\r\n{\r\ndev_start_periodic_work(dev);\r\n}\r\nvoid\r\nvisorbus_disable_channel_interrupts(struct visor_device *dev)\r\n{\r\ndev_stop_periodic_work(dev);\r\n}\r\nstatic int\r\ncreate_visor_device(struct visor_device *dev)\r\n{\r\nint rc = -1;\r\nu32 chipset_bus_no = dev->chipset_bus_no;\r\nu32 chipset_dev_no = dev->chipset_dev_no;\r\nPOSTCODE_LINUX_4(DEVICE_CREATE_ENTRY_PC, chipset_dev_no, chipset_bus_no,\r\nPOSTCODE_SEVERITY_INFO);\r\nsema_init(&dev->visordriver_callback_lock, 1);\r\ndev->device.bus = &visorbus_type;\r\ndev->device.groups = visorbus_channel_groups;\r\ndevice_initialize(&dev->device);\r\ndev->device.release = visorbus_release_device;\r\nget_device(&dev->device);\r\ndev->periodic_work =\r\nvisor_periodic_work_create(POLLJIFFIES_NORMALCHANNEL,\r\nperiodic_dev_workqueue,\r\ndev_periodic_work,\r\ndev, dev_name(&dev->device));\r\nif (!dev->periodic_work) {\r\nPOSTCODE_LINUX_3(DEVICE_CREATE_FAILURE_PC, chipset_dev_no,\r\nDIAG_SEVERITY_ERR);\r\ngoto away;\r\n}\r\ndev_set_name(&dev->device, "vbus%u:dev%u",\r\nchipset_bus_no, chipset_dev_no);\r\nrc = device_add(&dev->device);\r\nif (rc < 0) {\r\nPOSTCODE_LINUX_3(DEVICE_ADD_PC, chipset_bus_no,\r\nDIAG_SEVERITY_ERR);\r\ngoto away;\r\n}\r\nrc = register_devmajorminor_attributes(dev);\r\nif (rc < 0) {\r\nPOSTCODE_LINUX_3(DEVICE_REGISTER_FAILURE_PC, chipset_dev_no,\r\nDIAG_SEVERITY_ERR);\r\ngoto away_register;\r\n}\r\nlist_add_tail(&dev->list_all, &list_all_device_instances);\r\nreturn 0;\r\naway_register:\r\ndevice_unregister(&dev->device);\r\naway:\r\nput_device(&dev->device);\r\nreturn rc;\r\n}\r\nstatic void\r\nremove_visor_device(struct visor_device *dev)\r\n{\r\nlist_del(&dev->list_all);\r\nunregister_devmajorminor_attributes(dev);\r\nput_device(&dev->device);\r\ndevice_unregister(&dev->device);\r\n}\r\nstatic int\r\nget_vbus_header_info(struct visorchannel *chan,\r\nstruct spar_vbus_headerinfo *hdr_info)\r\n{\r\nint rc = -1;\r\nif (!SPAR_VBUS_CHANNEL_OK_CLIENT(visorchannel_get_header(chan)))\r\ngoto away;\r\nif (visorchannel_read(chan, sizeof(struct channel_header), hdr_info,\r\nsizeof(*hdr_info)) < 0) {\r\ngoto away;\r\n}\r\nif (hdr_info->struct_bytes < sizeof(struct spar_vbus_headerinfo))\r\ngoto away;\r\nif (hdr_info->device_info_struct_bytes <\r\nsizeof(struct ultra_vbus_deviceinfo)) {\r\ngoto away;\r\n}\r\nrc = 0;\r\naway:\r\nreturn rc;\r\n}\r\nstatic int\r\nwrite_vbus_chp_info(struct visorchannel *chan,\r\nstruct spar_vbus_headerinfo *hdr_info,\r\nstruct ultra_vbus_deviceinfo *info)\r\n{\r\nint off = sizeof(struct channel_header) + hdr_info->chp_info_offset;\r\nif (hdr_info->chp_info_offset == 0)\r\nreturn -1;\r\nif (visorchannel_write(chan, off, info, sizeof(*info)) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int\r\nwrite_vbus_bus_info(struct visorchannel *chan,\r\nstruct spar_vbus_headerinfo *hdr_info,\r\nstruct ultra_vbus_deviceinfo *info)\r\n{\r\nint off = sizeof(struct channel_header) + hdr_info->bus_info_offset;\r\nif (hdr_info->bus_info_offset == 0)\r\nreturn -1;\r\nif (visorchannel_write(chan, off, info, sizeof(*info)) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int\r\nwrite_vbus_dev_info(struct visorchannel *chan,\r\nstruct spar_vbus_headerinfo *hdr_info,\r\nstruct ultra_vbus_deviceinfo *info, int devix)\r\n{\r\nint off =\r\n(sizeof(struct channel_header) + hdr_info->dev_info_offset) +\r\n(hdr_info->device_info_struct_bytes * devix);\r\nif (hdr_info->dev_info_offset == 0)\r\nreturn -1;\r\nif (visorchannel_write(chan, off, info, sizeof(*info)) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void\r\nfix_vbus_dev_info(struct visor_device *visordev)\r\n{\r\nint i;\r\nstruct visor_device *bdev;\r\nstruct visor_driver *visordrv;\r\nint bus_no = visordev->chipset_bus_no;\r\nint dev_no = visordev->chipset_dev_no;\r\nstruct ultra_vbus_deviceinfo dev_info;\r\nconst char *chan_type_name = NULL;\r\nstruct spar_vbus_headerinfo *hdr_info;\r\nif (!visordev->device.driver)\r\nreturn;\r\nhdr_info = (struct spar_vbus_headerinfo *)visordev->vbus_hdr_info;\r\nif (!hdr_info)\r\nreturn;\r\nbdev = visorbus_get_device_by_id(bus_no, BUS_ROOT_DEVICE, NULL);\r\nif (!bdev)\r\nreturn;\r\nvisordrv = to_visor_driver(visordev->device.driver);\r\nfor (i = 0; visordrv->channel_types[i].name; i++) {\r\nif (memcmp(&visordrv->channel_types[i].guid,\r\n&visordev->channel_type_guid,\r\nsizeof(visordrv->channel_types[i].guid)) == 0) {\r\nchan_type_name = visordrv->channel_types[i].name;\r\nbreak;\r\n}\r\n}\r\nbus_device_info_init(&dev_info, chan_type_name,\r\nvisordrv->name, visordrv->version,\r\nvisordrv->vertag);\r\nwrite_vbus_dev_info(bdev->visorchannel, hdr_info, &dev_info, dev_no);\r\nwrite_vbus_chp_info(bdev->visorchannel, hdr_info, &chipset_driverinfo);\r\nwrite_vbus_bus_info(bdev->visorchannel, hdr_info,\r\n&clientbus_driverinfo);\r\n}\r\nstatic int\r\ncreate_bus_instance(struct visor_device *dev)\r\n{\r\nint rc;\r\nint id = dev->chipset_bus_no;\r\nstruct spar_vbus_headerinfo *hdr_info;\r\nPOSTCODE_LINUX_2(BUS_CREATE_ENTRY_PC, POSTCODE_SEVERITY_INFO);\r\nhdr_info = kzalloc(sizeof(*hdr_info), GFP_KERNEL);\r\nif (!hdr_info) {\r\nrc = -1;\r\ngoto away;\r\n}\r\ndev_set_name(&dev->device, "visorbus%d", id);\r\ndev->device.bus = &visorbus_type;\r\ndev->device.groups = visorbus_groups;\r\ndev->device.release = visorbus_release_busdevice;\r\nif (device_register(&dev->device) < 0) {\r\nPOSTCODE_LINUX_3(DEVICE_CREATE_FAILURE_PC, id,\r\nPOSTCODE_SEVERITY_ERR);\r\nrc = -1;\r\ngoto away_mem;\r\n}\r\nif (get_vbus_header_info(dev->visorchannel, hdr_info) >= 0) {\r\ndev->vbus_hdr_info = (void *)hdr_info;\r\nwrite_vbus_chp_info(dev->visorchannel, hdr_info,\r\n&chipset_driverinfo);\r\nwrite_vbus_bus_info(dev->visorchannel, hdr_info,\r\n&clientbus_driverinfo);\r\n} else {\r\nkfree(hdr_info);\r\n}\r\nbus_count++;\r\nlist_add_tail(&dev->list_all, &list_all_bus_instances);\r\ndev_set_drvdata(&dev->device, dev);\r\nreturn 0;\r\naway_mem:\r\nkfree(hdr_info);\r\naway:\r\nreturn rc;\r\n}\r\nstatic void\r\nremove_bus_instance(struct visor_device *dev)\r\n{\r\nbus_count--;\r\nif (dev->visorchannel) {\r\nvisorchannel_destroy(dev->visorchannel);\r\ndev->visorchannel = NULL;\r\n}\r\nkfree(dev->vbus_hdr_info);\r\nlist_del(&dev->list_all);\r\ndevice_unregister(&dev->device);\r\n}\r\nstatic int\r\ncreate_bus_type(void)\r\n{\r\nbusreg_rc = bus_register(&visorbus_type);\r\nreturn busreg_rc;\r\n}\r\nstatic void\r\nremove_bus_type(void)\r\n{\r\nbus_unregister(&visorbus_type);\r\n}\r\nstatic void\r\nremove_all_visor_devices(void)\r\n{\r\nstruct list_head *listentry, *listtmp;\r\nlist_for_each_safe(listentry, listtmp, &list_all_device_instances) {\r\nstruct visor_device *dev = list_entry(listentry,\r\nstruct visor_device,\r\nlist_all);\r\nremove_visor_device(dev);\r\n}\r\n}\r\nstatic void\r\nchipset_bus_create(struct visor_device *dev)\r\n{\r\nint rc;\r\nu32 bus_no = dev->chipset_bus_no;\r\nPOSTCODE_LINUX_3(BUS_CREATE_ENTRY_PC, bus_no, POSTCODE_SEVERITY_INFO);\r\nrc = create_bus_instance(dev);\r\nPOSTCODE_LINUX_3(BUS_CREATE_EXIT_PC, bus_no, POSTCODE_SEVERITY_INFO);\r\nif (rc < 0)\r\nPOSTCODE_LINUX_3(BUS_CREATE_FAILURE_PC, bus_no,\r\nPOSTCODE_SEVERITY_ERR);\r\nelse\r\nPOSTCODE_LINUX_3(CHIPSET_INIT_SUCCESS_PC, bus_no,\r\nPOSTCODE_SEVERITY_INFO);\r\nif (chipset_responders.bus_create)\r\n(*chipset_responders.bus_create) (dev, rc);\r\n}\r\nstatic void\r\nchipset_bus_destroy(struct visor_device *dev)\r\n{\r\nremove_bus_instance(dev);\r\nif (chipset_responders.bus_destroy)\r\n(*chipset_responders.bus_destroy)(dev, 0);\r\n}\r\nstatic void\r\nchipset_device_create(struct visor_device *dev_info)\r\n{\r\nint rc = -1;\r\nu32 bus_no = dev_info->chipset_bus_no;\r\nu32 dev_no = dev_info->chipset_dev_no;\r\nPOSTCODE_LINUX_4(DEVICE_CREATE_ENTRY_PC, dev_no, bus_no,\r\nPOSTCODE_SEVERITY_INFO);\r\nrc = create_visor_device(dev_info);\r\nif (chipset_responders.device_create)\r\nchipset_responders.device_create(dev_info, rc);\r\nif (rc < 0)\r\nPOSTCODE_LINUX_4(DEVICE_CREATE_FAILURE_PC, dev_no, bus_no,\r\nPOSTCODE_SEVERITY_ERR);\r\nelse\r\nPOSTCODE_LINUX_4(DEVICE_CREATE_SUCCESS_PC, dev_no, bus_no,\r\nPOSTCODE_SEVERITY_INFO);\r\n}\r\nstatic void\r\nchipset_device_destroy(struct visor_device *dev_info)\r\n{\r\nremove_visor_device(dev_info);\r\nif (chipset_responders.device_destroy)\r\n(*chipset_responders.device_destroy) (dev_info, 0);\r\n}\r\nstatic void\r\npause_state_change_complete(struct visor_device *dev, int status)\r\n{\r\nif (!dev->pausing)\r\nreturn;\r\ndev->pausing = false;\r\nif (!chipset_responders.device_pause)\r\nreturn;\r\n(*chipset_responders.device_pause) (dev, status);\r\n}\r\nstatic void\r\nresume_state_change_complete(struct visor_device *dev, int status)\r\n{\r\nif (!dev->resuming)\r\nreturn;\r\ndev->resuming = false;\r\nif (!chipset_responders.device_resume)\r\nreturn;\r\n(*chipset_responders.device_resume) (dev, status);\r\n}\r\nstatic void\r\ninitiate_chipset_device_pause_resume(struct visor_device *dev, bool is_pause)\r\n{\r\nint rc = -1, x;\r\nstruct visor_driver *drv = NULL;\r\nvoid (*notify_func)(struct visor_device *dev, int response) = NULL;\r\nif (is_pause)\r\nnotify_func = chipset_responders.device_pause;\r\nelse\r\nnotify_func = chipset_responders.device_resume;\r\nif (!notify_func)\r\ngoto away;\r\ndrv = to_visor_driver(dev->device.driver);\r\nif (!drv)\r\ngoto away;\r\nif (dev->pausing || dev->resuming)\r\ngoto away;\r\nif (is_pause) {\r\nif (!drv->pause)\r\ngoto away;\r\ndev->pausing = true;\r\nx = drv->pause(dev, pause_state_change_complete);\r\n} else {\r\nfix_vbus_dev_info(dev);\r\nif (!drv->resume)\r\ngoto away;\r\ndev->resuming = true;\r\nx = drv->resume(dev, resume_state_change_complete);\r\n}\r\nif (x < 0) {\r\nif (is_pause)\r\ndev->pausing = false;\r\nelse\r\ndev->resuming = false;\r\ngoto away;\r\n}\r\nrc = 0;\r\naway:\r\nif (rc < 0) {\r\nif (notify_func)\r\n(*notify_func)(dev, rc);\r\n}\r\n}\r\nstatic void\r\nchipset_device_pause(struct visor_device *dev_info)\r\n{\r\ninitiate_chipset_device_pause_resume(dev_info, true);\r\n}\r\nstatic void\r\nchipset_device_resume(struct visor_device *dev_info)\r\n{\r\ninitiate_chipset_device_pause_resume(dev_info, false);\r\n}\r\nint\r\nvisorbus_init(void)\r\n{\r\nint rc = 0;\r\nPOSTCODE_LINUX_3(DRIVER_ENTRY_PC, rc, POSTCODE_SEVERITY_INFO);\r\nbus_device_info_init(&clientbus_driverinfo,\r\n"clientbus", "visorbus",\r\nVERSION, NULL);\r\nrc = create_bus_type();\r\nif (rc < 0) {\r\nPOSTCODE_LINUX_2(BUS_CREATE_ENTRY_PC, DIAG_SEVERITY_ERR);\r\ngoto away;\r\n}\r\nperiodic_dev_workqueue = create_singlethread_workqueue("visorbus_dev");\r\nif (!periodic_dev_workqueue) {\r\nPOSTCODE_LINUX_2(CREATE_WORKQUEUE_PC, DIAG_SEVERITY_ERR);\r\nrc = -ENOMEM;\r\ngoto away;\r\n}\r\nvisorchipset_register_busdev(&chipset_notifiers,\r\n&chipset_responders,\r\n&chipset_driverinfo);\r\nrc = 0;\r\naway:\r\nif (rc)\r\nPOSTCODE_LINUX_3(CHIPSET_INIT_FAILURE_PC, rc,\r\nPOSTCODE_SEVERITY_ERR);\r\nreturn rc;\r\n}\r\nvoid\r\nvisorbus_exit(void)\r\n{\r\nstruct list_head *listentry, *listtmp;\r\nvisorchipset_register_busdev(NULL, NULL, NULL);\r\nremove_all_visor_devices();\r\nflush_workqueue(periodic_dev_workqueue);\r\ndestroy_workqueue(periodic_dev_workqueue);\r\nperiodic_dev_workqueue = NULL;\r\nif (periodic_test_workqueue) {\r\ncancel_delayed_work(&periodic_work);\r\nflush_workqueue(periodic_test_workqueue);\r\ndestroy_workqueue(periodic_test_workqueue);\r\nperiodic_test_workqueue = NULL;\r\n}\r\nlist_for_each_safe(listentry, listtmp, &list_all_bus_instances) {\r\nstruct visor_device *dev = list_entry(listentry,\r\nstruct visor_device,\r\nlist_all);\r\nremove_bus_instance(dev);\r\n}\r\nremove_bus_type();\r\n}
