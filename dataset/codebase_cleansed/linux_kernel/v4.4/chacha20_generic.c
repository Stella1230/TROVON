static inline u32 rotl32(u32 v, u8 n)\r\n{\r\nreturn (v << n) | (v >> (sizeof(v) * 8 - n));\r\n}\r\nstatic inline u32 le32_to_cpuvp(const void *p)\r\n{\r\nreturn le32_to_cpup(p);\r\n}\r\nstatic void chacha20_block(u32 *state, void *stream)\r\n{\r\nu32 x[16], *out = stream;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(x); i++)\r\nx[i] = state[i];\r\nfor (i = 0; i < 20; i += 2) {\r\nx[0] += x[4]; x[12] = rotl32(x[12] ^ x[0], 16);\r\nx[1] += x[5]; x[13] = rotl32(x[13] ^ x[1], 16);\r\nx[2] += x[6]; x[14] = rotl32(x[14] ^ x[2], 16);\r\nx[3] += x[7]; x[15] = rotl32(x[15] ^ x[3], 16);\r\nx[8] += x[12]; x[4] = rotl32(x[4] ^ x[8], 12);\r\nx[9] += x[13]; x[5] = rotl32(x[5] ^ x[9], 12);\r\nx[10] += x[14]; x[6] = rotl32(x[6] ^ x[10], 12);\r\nx[11] += x[15]; x[7] = rotl32(x[7] ^ x[11], 12);\r\nx[0] += x[4]; x[12] = rotl32(x[12] ^ x[0], 8);\r\nx[1] += x[5]; x[13] = rotl32(x[13] ^ x[1], 8);\r\nx[2] += x[6]; x[14] = rotl32(x[14] ^ x[2], 8);\r\nx[3] += x[7]; x[15] = rotl32(x[15] ^ x[3], 8);\r\nx[8] += x[12]; x[4] = rotl32(x[4] ^ x[8], 7);\r\nx[9] += x[13]; x[5] = rotl32(x[5] ^ x[9], 7);\r\nx[10] += x[14]; x[6] = rotl32(x[6] ^ x[10], 7);\r\nx[11] += x[15]; x[7] = rotl32(x[7] ^ x[11], 7);\r\nx[0] += x[5]; x[15] = rotl32(x[15] ^ x[0], 16);\r\nx[1] += x[6]; x[12] = rotl32(x[12] ^ x[1], 16);\r\nx[2] += x[7]; x[13] = rotl32(x[13] ^ x[2], 16);\r\nx[3] += x[4]; x[14] = rotl32(x[14] ^ x[3], 16);\r\nx[10] += x[15]; x[5] = rotl32(x[5] ^ x[10], 12);\r\nx[11] += x[12]; x[6] = rotl32(x[6] ^ x[11], 12);\r\nx[8] += x[13]; x[7] = rotl32(x[7] ^ x[8], 12);\r\nx[9] += x[14]; x[4] = rotl32(x[4] ^ x[9], 12);\r\nx[0] += x[5]; x[15] = rotl32(x[15] ^ x[0], 8);\r\nx[1] += x[6]; x[12] = rotl32(x[12] ^ x[1], 8);\r\nx[2] += x[7]; x[13] = rotl32(x[13] ^ x[2], 8);\r\nx[3] += x[4]; x[14] = rotl32(x[14] ^ x[3], 8);\r\nx[10] += x[15]; x[5] = rotl32(x[5] ^ x[10], 7);\r\nx[11] += x[12]; x[6] = rotl32(x[6] ^ x[11], 7);\r\nx[8] += x[13]; x[7] = rotl32(x[7] ^ x[8], 7);\r\nx[9] += x[14]; x[4] = rotl32(x[4] ^ x[9], 7);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(x); i++)\r\nout[i] = cpu_to_le32(x[i] + state[i]);\r\nstate[12]++;\r\n}\r\nstatic void chacha20_docrypt(u32 *state, u8 *dst, const u8 *src,\r\nunsigned int bytes)\r\n{\r\nu8 stream[CHACHA20_BLOCK_SIZE];\r\nif (dst != src)\r\nmemcpy(dst, src, bytes);\r\nwhile (bytes >= CHACHA20_BLOCK_SIZE) {\r\nchacha20_block(state, stream);\r\ncrypto_xor(dst, stream, CHACHA20_BLOCK_SIZE);\r\nbytes -= CHACHA20_BLOCK_SIZE;\r\ndst += CHACHA20_BLOCK_SIZE;\r\n}\r\nif (bytes) {\r\nchacha20_block(state, stream);\r\ncrypto_xor(dst, stream, bytes);\r\n}\r\n}\r\nvoid crypto_chacha20_init(u32 *state, struct chacha20_ctx *ctx, u8 *iv)\r\n{\r\nstatic const char constant[16] = "expand 32-byte k";\r\nstate[0] = le32_to_cpuvp(constant + 0);\r\nstate[1] = le32_to_cpuvp(constant + 4);\r\nstate[2] = le32_to_cpuvp(constant + 8);\r\nstate[3] = le32_to_cpuvp(constant + 12);\r\nstate[4] = ctx->key[0];\r\nstate[5] = ctx->key[1];\r\nstate[6] = ctx->key[2];\r\nstate[7] = ctx->key[3];\r\nstate[8] = ctx->key[4];\r\nstate[9] = ctx->key[5];\r\nstate[10] = ctx->key[6];\r\nstate[11] = ctx->key[7];\r\nstate[12] = le32_to_cpuvp(iv + 0);\r\nstate[13] = le32_to_cpuvp(iv + 4);\r\nstate[14] = le32_to_cpuvp(iv + 8);\r\nstate[15] = le32_to_cpuvp(iv + 12);\r\n}\r\nint crypto_chacha20_setkey(struct crypto_tfm *tfm, const u8 *key,\r\nunsigned int keysize)\r\n{\r\nstruct chacha20_ctx *ctx = crypto_tfm_ctx(tfm);\r\nint i;\r\nif (keysize != CHACHA20_KEY_SIZE)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(ctx->key); i++)\r\nctx->key[i] = le32_to_cpuvp(key + i * sizeof(u32));\r\nreturn 0;\r\n}\r\nint crypto_chacha20_crypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nstruct blkcipher_walk walk;\r\nu32 state[16];\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt_block(desc, &walk, CHACHA20_BLOCK_SIZE);\r\ncrypto_chacha20_init(state, crypto_blkcipher_ctx(desc->tfm), walk.iv);\r\nwhile (walk.nbytes >= CHACHA20_BLOCK_SIZE) {\r\nchacha20_docrypt(state, walk.dst.virt.addr, walk.src.virt.addr,\r\nrounddown(walk.nbytes, CHACHA20_BLOCK_SIZE));\r\nerr = blkcipher_walk_done(desc, &walk,\r\nwalk.nbytes % CHACHA20_BLOCK_SIZE);\r\n}\r\nif (walk.nbytes) {\r\nchacha20_docrypt(state, walk.dst.virt.addr, walk.src.virt.addr,\r\nwalk.nbytes);\r\nerr = blkcipher_walk_done(desc, &walk, 0);\r\n}\r\nreturn err;\r\n}\r\nstatic int __init chacha20_generic_mod_init(void)\r\n{\r\nreturn crypto_register_alg(&alg);\r\n}\r\nstatic void __exit chacha20_generic_mod_fini(void)\r\n{\r\ncrypto_unregister_alg(&alg);\r\n}
