static int htc_issue_send(struct htc_target *target, struct sk_buff* skb,\r\nu16 len, u8 flags, u8 epid)\r\n{\r\nstruct htc_frame_hdr *hdr;\r\nstruct htc_endpoint *endpoint = &target->endpoint[epid];\r\nint status;\r\nhdr = (struct htc_frame_hdr *)\r\nskb_push(skb, sizeof(struct htc_frame_hdr));\r\nhdr->endpoint_id = epid;\r\nhdr->flags = flags;\r\nhdr->payload_len = cpu_to_be16(len);\r\nstatus = target->hif->send(target->hif_dev, endpoint->ul_pipeid, skb);\r\nreturn status;\r\n}\r\nstatic struct htc_endpoint *get_next_avail_ep(struct htc_endpoint *endpoint)\r\n{\r\nenum htc_endpoint_id avail_epid;\r\nfor (avail_epid = (ENDPOINT_MAX - 1); avail_epid > ENDPOINT0; avail_epid--)\r\nif (endpoint[avail_epid].service_id == 0)\r\nreturn &endpoint[avail_epid];\r\nreturn NULL;\r\n}\r\nstatic u8 service_to_ulpipe(u16 service_id)\r\n{\r\nswitch (service_id) {\r\ncase WMI_CONTROL_SVC:\r\nreturn 4;\r\ncase WMI_BEACON_SVC:\r\ncase WMI_CAB_SVC:\r\ncase WMI_UAPSD_SVC:\r\ncase WMI_MGMT_SVC:\r\ncase WMI_DATA_VO_SVC:\r\ncase WMI_DATA_VI_SVC:\r\ncase WMI_DATA_BE_SVC:\r\ncase WMI_DATA_BK_SVC:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic u8 service_to_dlpipe(u16 service_id)\r\n{\r\nswitch (service_id) {\r\ncase WMI_CONTROL_SVC:\r\nreturn 3;\r\ncase WMI_BEACON_SVC:\r\ncase WMI_CAB_SVC:\r\ncase WMI_UAPSD_SVC:\r\ncase WMI_MGMT_SVC:\r\ncase WMI_DATA_VO_SVC:\r\ncase WMI_DATA_VI_SVC:\r\ncase WMI_DATA_BE_SVC:\r\ncase WMI_DATA_BK_SVC:\r\nreturn 2;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void htc_process_target_rdy(struct htc_target *target,\r\nvoid *buf)\r\n{\r\nstruct htc_endpoint *endpoint;\r\nstruct htc_ready_msg *htc_ready_msg = (struct htc_ready_msg *) buf;\r\ntarget->credit_size = be16_to_cpu(htc_ready_msg->credit_size);\r\nendpoint = &target->endpoint[ENDPOINT0];\r\nendpoint->service_id = HTC_CTRL_RSVD_SVC;\r\nendpoint->max_msglen = HTC_MAX_CONTROL_MESSAGE_LENGTH;\r\natomic_inc(&target->tgt_ready);\r\ncomplete(&target->target_wait);\r\n}\r\nstatic void htc_process_conn_rsp(struct htc_target *target,\r\nstruct htc_frame_hdr *htc_hdr)\r\n{\r\nstruct htc_conn_svc_rspmsg *svc_rspmsg;\r\nstruct htc_endpoint *endpoint, *tmp_endpoint = NULL;\r\nu16 service_id;\r\nu16 max_msglen;\r\nenum htc_endpoint_id epid, tepid;\r\nsvc_rspmsg = (struct htc_conn_svc_rspmsg *)\r\n((void *) htc_hdr + sizeof(struct htc_frame_hdr));\r\nif (svc_rspmsg->status == HTC_SERVICE_SUCCESS) {\r\nepid = svc_rspmsg->endpoint_id;\r\nservice_id = be16_to_cpu(svc_rspmsg->service_id);\r\nmax_msglen = be16_to_cpu(svc_rspmsg->max_msg_len);\r\nendpoint = &target->endpoint[epid];\r\nfor (tepid = (ENDPOINT_MAX - 1); tepid > ENDPOINT0; tepid--) {\r\ntmp_endpoint = &target->endpoint[tepid];\r\nif (tmp_endpoint->service_id == service_id) {\r\ntmp_endpoint->service_id = 0;\r\nbreak;\r\n}\r\n}\r\nif (tepid == ENDPOINT0)\r\nreturn;\r\nendpoint->service_id = service_id;\r\nendpoint->max_txqdepth = tmp_endpoint->max_txqdepth;\r\nendpoint->ep_callbacks = tmp_endpoint->ep_callbacks;\r\nendpoint->ul_pipeid = tmp_endpoint->ul_pipeid;\r\nendpoint->dl_pipeid = tmp_endpoint->dl_pipeid;\r\nendpoint->max_msglen = max_msglen;\r\ntarget->conn_rsp_epid = epid;\r\ncomplete(&target->cmd_wait);\r\n} else {\r\ntarget->conn_rsp_epid = ENDPOINT_UNUSED;\r\n}\r\n}\r\nstatic int htc_config_pipe_credits(struct htc_target *target)\r\n{\r\nstruct sk_buff *skb;\r\nstruct htc_config_pipe_msg *cp_msg;\r\nint ret;\r\nunsigned long time_left;\r\nskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\r\nif (!skb) {\r\ndev_err(target->dev, "failed to allocate send buffer\n");\r\nreturn -ENOMEM;\r\n}\r\nskb_reserve(skb, sizeof(struct htc_frame_hdr));\r\ncp_msg = (struct htc_config_pipe_msg *)\r\nskb_put(skb, sizeof(struct htc_config_pipe_msg));\r\ncp_msg->message_id = cpu_to_be16(HTC_MSG_CONFIG_PIPE_ID);\r\ncp_msg->pipe_id = USB_WLAN_TX_PIPE;\r\ncp_msg->credits = target->credits;\r\ntarget->htc_flags |= HTC_OP_CONFIG_PIPE_CREDITS;\r\nret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\r\nif (ret)\r\ngoto err;\r\ntime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\r\nif (!time_left) {\r\ndev_err(target->dev, "HTC credit config timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\nerr:\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nstatic int htc_setup_complete(struct htc_target *target)\r\n{\r\nstruct sk_buff *skb;\r\nstruct htc_comp_msg *comp_msg;\r\nint ret = 0;\r\nunsigned long time_left;\r\nskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\r\nif (!skb) {\r\ndev_err(target->dev, "failed to allocate send buffer\n");\r\nreturn -ENOMEM;\r\n}\r\nskb_reserve(skb, sizeof(struct htc_frame_hdr));\r\ncomp_msg = (struct htc_comp_msg *)\r\nskb_put(skb, sizeof(struct htc_comp_msg));\r\ncomp_msg->msg_id = cpu_to_be16(HTC_MSG_SETUP_COMPLETE_ID);\r\ntarget->htc_flags |= HTC_OP_START_WAIT;\r\nret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\r\nif (ret)\r\ngoto err;\r\ntime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\r\nif (!time_left) {\r\ndev_err(target->dev, "HTC start timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\nerr:\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nint htc_init(struct htc_target *target)\r\n{\r\nint ret;\r\nret = htc_config_pipe_credits(target);\r\nif (ret)\r\nreturn ret;\r\nreturn htc_setup_complete(target);\r\n}\r\nint htc_connect_service(struct htc_target *target,\r\nstruct htc_service_connreq *service_connreq,\r\nenum htc_endpoint_id *conn_rsp_epid)\r\n{\r\nstruct sk_buff *skb;\r\nstruct htc_endpoint *endpoint;\r\nstruct htc_conn_svc_msg *conn_msg;\r\nint ret;\r\nunsigned long time_left;\r\nendpoint = get_next_avail_ep(target->endpoint);\r\nif (!endpoint) {\r\ndev_err(target->dev, "Endpoint is not available for"\r\n"service %d\n", service_connreq->service_id);\r\nreturn -EINVAL;\r\n}\r\nendpoint->service_id = service_connreq->service_id;\r\nendpoint->max_txqdepth = service_connreq->max_send_qdepth;\r\nendpoint->ul_pipeid = service_to_ulpipe(service_connreq->service_id);\r\nendpoint->dl_pipeid = service_to_dlpipe(service_connreq->service_id);\r\nendpoint->ep_callbacks = service_connreq->ep_callbacks;\r\nskb = alloc_skb(sizeof(struct htc_conn_svc_msg) +\r\nsizeof(struct htc_frame_hdr), GFP_ATOMIC);\r\nif (!skb) {\r\ndev_err(target->dev, "Failed to allocate buf to send"\r\n"service connect req\n");\r\nreturn -ENOMEM;\r\n}\r\nskb_reserve(skb, sizeof(struct htc_frame_hdr));\r\nconn_msg = (struct htc_conn_svc_msg *)\r\nskb_put(skb, sizeof(struct htc_conn_svc_msg));\r\nconn_msg->service_id = cpu_to_be16(service_connreq->service_id);\r\nconn_msg->msg_id = cpu_to_be16(HTC_MSG_CONNECT_SERVICE_ID);\r\nconn_msg->con_flags = cpu_to_be16(service_connreq->con_flags);\r\nconn_msg->dl_pipeid = endpoint->dl_pipeid;\r\nconn_msg->ul_pipeid = endpoint->ul_pipeid;\r\nret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\r\nif (ret)\r\ngoto err;\r\ntime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\r\nif (!time_left) {\r\ndev_err(target->dev, "Service connection timeout for: %d\n",\r\nservice_connreq->service_id);\r\nreturn -ETIMEDOUT;\r\n}\r\n*conn_rsp_epid = target->conn_rsp_epid;\r\nreturn 0;\r\nerr:\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nint htc_send(struct htc_target *target, struct sk_buff *skb)\r\n{\r\nstruct ath9k_htc_tx_ctl *tx_ctl;\r\ntx_ctl = HTC_SKB_CB(skb);\r\nreturn htc_issue_send(target, skb, skb->len, 0, tx_ctl->epid);\r\n}\r\nint htc_send_epid(struct htc_target *target, struct sk_buff *skb,\r\nenum htc_endpoint_id epid)\r\n{\r\nreturn htc_issue_send(target, skb, skb->len, 0, epid);\r\n}\r\nvoid htc_stop(struct htc_target *target)\r\n{\r\ntarget->hif->stop(target->hif_dev);\r\n}\r\nvoid htc_start(struct htc_target *target)\r\n{\r\ntarget->hif->start(target->hif_dev);\r\n}\r\nvoid htc_sta_drain(struct htc_target *target, u8 idx)\r\n{\r\ntarget->hif->sta_drain(target->hif_dev, idx);\r\n}\r\nvoid ath9k_htc_txcompletion_cb(struct htc_target *htc_handle,\r\nstruct sk_buff *skb, bool txok)\r\n{\r\nstruct htc_endpoint *endpoint;\r\nstruct htc_frame_hdr *htc_hdr = NULL;\r\nif (htc_handle->htc_flags & HTC_OP_CONFIG_PIPE_CREDITS) {\r\ncomplete(&htc_handle->cmd_wait);\r\nhtc_handle->htc_flags &= ~HTC_OP_CONFIG_PIPE_CREDITS;\r\ngoto ret;\r\n}\r\nif (htc_handle->htc_flags & HTC_OP_START_WAIT) {\r\ncomplete(&htc_handle->cmd_wait);\r\nhtc_handle->htc_flags &= ~HTC_OP_START_WAIT;\r\ngoto ret;\r\n}\r\nif (skb) {\r\nhtc_hdr = (struct htc_frame_hdr *) skb->data;\r\nendpoint = &htc_handle->endpoint[htc_hdr->endpoint_id];\r\nskb_pull(skb, sizeof(struct htc_frame_hdr));\r\nif (endpoint->ep_callbacks.tx) {\r\nendpoint->ep_callbacks.tx(endpoint->ep_callbacks.priv,\r\nskb, htc_hdr->endpoint_id,\r\ntxok);\r\n} else {\r\nkfree_skb(skb);\r\n}\r\n}\r\nreturn;\r\nret:\r\nkfree_skb(skb);\r\n}\r\nstatic void ath9k_htc_fw_panic_report(struct htc_target *htc_handle,\r\nstruct sk_buff *skb)\r\n{\r\nuint32_t *pattern = (uint32_t *)skb->data;\r\nswitch (*pattern) {\r\ncase 0x33221199:\r\n{\r\nstruct htc_panic_bad_vaddr *htc_panic;\r\nhtc_panic = (struct htc_panic_bad_vaddr *) skb->data;\r\ndev_err(htc_handle->dev, "ath: firmware panic! "\r\n"exccause: 0x%08x; pc: 0x%08x; badvaddr: 0x%08x.\n",\r\nhtc_panic->exccause, htc_panic->pc,\r\nhtc_panic->badvaddr);\r\nbreak;\r\n}\r\ncase 0x33221299:\r\n{\r\nstruct htc_panic_bad_epid *htc_panic;\r\nhtc_panic = (struct htc_panic_bad_epid *) skb->data;\r\ndev_err(htc_handle->dev, "ath: firmware panic! "\r\n"bad epid: 0x%08x\n", htc_panic->epid);\r\nbreak;\r\n}\r\ndefault:\r\ndev_err(htc_handle->dev, "ath: uknown panic pattern!\n");\r\nbreak;\r\n}\r\n}\r\nvoid ath9k_htc_rx_msg(struct htc_target *htc_handle,\r\nstruct sk_buff *skb, u32 len, u8 pipe_id)\r\n{\r\nstruct htc_frame_hdr *htc_hdr;\r\nenum htc_endpoint_id epid;\r\nstruct htc_endpoint *endpoint;\r\n__be16 *msg_id;\r\nif (!htc_handle || !skb)\r\nreturn;\r\nhtc_hdr = (struct htc_frame_hdr *) skb->data;\r\nepid = htc_hdr->endpoint_id;\r\nif (epid == 0x99) {\r\nath9k_htc_fw_panic_report(htc_handle, skb);\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (epid >= ENDPOINT_MAX) {\r\nif (pipe_id != USB_REG_IN_PIPE)\r\ndev_kfree_skb_any(skb);\r\nelse\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (epid == ENDPOINT0) {\r\nif (htc_hdr->flags & HTC_FLAGS_RECV_TRAILER) {\r\nif (be32_to_cpu(*(__be32 *) skb->data) == 0x00C60000)\r\nhtc_hdr = (struct htc_frame_hdr *)(skb->data + 4);\r\n}\r\nmsg_id = (__be16 *) ((void *) htc_hdr +\r\nsizeof(struct htc_frame_hdr));\r\nswitch (be16_to_cpu(*msg_id)) {\r\ncase HTC_MSG_READY_ID:\r\nhtc_process_target_rdy(htc_handle, htc_hdr);\r\nbreak;\r\ncase HTC_MSG_CONNECT_SERVICE_RESPONSE_ID:\r\nhtc_process_conn_rsp(htc_handle, htc_hdr);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nkfree_skb(skb);\r\n} else {\r\nif (htc_hdr->flags & HTC_FLAGS_RECV_TRAILER)\r\nskb_trim(skb, len - htc_hdr->control[0]);\r\nskb_pull(skb, sizeof(struct htc_frame_hdr));\r\nendpoint = &htc_handle->endpoint[epid];\r\nif (endpoint->ep_callbacks.rx)\r\nendpoint->ep_callbacks.rx(endpoint->ep_callbacks.priv,\r\nskb, epid);\r\n}\r\n}\r\nstruct htc_target *ath9k_htc_hw_alloc(void *hif_handle,\r\nstruct ath9k_htc_hif *hif,\r\nstruct device *dev)\r\n{\r\nstruct htc_endpoint *endpoint;\r\nstruct htc_target *target;\r\ntarget = kzalloc(sizeof(struct htc_target), GFP_KERNEL);\r\nif (!target)\r\nreturn NULL;\r\ninit_completion(&target->target_wait);\r\ninit_completion(&target->cmd_wait);\r\ntarget->hif = hif;\r\ntarget->hif_dev = hif_handle;\r\ntarget->dev = dev;\r\nendpoint = &target->endpoint[ENDPOINT0];\r\nendpoint->ul_pipeid = hif->control_ul_pipe;\r\nendpoint->dl_pipeid = hif->control_dl_pipe;\r\natomic_set(&target->tgt_ready, 0);\r\nreturn target;\r\n}\r\nvoid ath9k_htc_hw_free(struct htc_target *htc)\r\n{\r\nkfree(htc);\r\n}\r\nint ath9k_htc_hw_init(struct htc_target *target,\r\nstruct device *dev, u16 devid,\r\nchar *product, u32 drv_info)\r\n{\r\nif (ath9k_htc_probe_device(target, dev, devid, product, drv_info)) {\r\npr_err("Failed to initialize the device\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nvoid ath9k_htc_hw_deinit(struct htc_target *target, bool hot_unplug)\r\n{\r\nif (target)\r\nath9k_htc_disconnect_device(target, hot_unplug);\r\n}
