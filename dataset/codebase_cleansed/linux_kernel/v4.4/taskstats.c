static int prepare_reply(struct genl_info *info, u8 cmd, struct sk_buff **skbp,\r\nsize_t size)\r\n{\r\nstruct sk_buff *skb;\r\nvoid *reply;\r\nskb = genlmsg_new(size, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nif (!info) {\r\nint seq = this_cpu_inc_return(taskstats_seqnum) - 1;\r\nreply = genlmsg_put(skb, 0, seq, &family, 0, cmd);\r\n} else\r\nreply = genlmsg_put_reply(skb, info, &family, 0, cmd);\r\nif (reply == NULL) {\r\nnlmsg_free(skb);\r\nreturn -EINVAL;\r\n}\r\n*skbp = skb;\r\nreturn 0;\r\n}\r\nstatic int send_reply(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\r\nvoid *reply = genlmsg_data(genlhdr);\r\ngenlmsg_end(skb, reply);\r\nreturn genlmsg_reply(skb, info);\r\n}\r\nstatic void send_cpu_listeners(struct sk_buff *skb,\r\nstruct listener_list *listeners)\r\n{\r\nstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\r\nstruct listener *s, *tmp;\r\nstruct sk_buff *skb_next, *skb_cur = skb;\r\nvoid *reply = genlmsg_data(genlhdr);\r\nint rc, delcount = 0;\r\ngenlmsg_end(skb, reply);\r\nrc = 0;\r\ndown_read(&listeners->sem);\r\nlist_for_each_entry(s, &listeners->list, list) {\r\nskb_next = NULL;\r\nif (!list_is_last(&s->list, &listeners->list)) {\r\nskb_next = skb_clone(skb_cur, GFP_KERNEL);\r\nif (!skb_next)\r\nbreak;\r\n}\r\nrc = genlmsg_unicast(&init_net, skb_cur, s->pid);\r\nif (rc == -ECONNREFUSED) {\r\ns->valid = 0;\r\ndelcount++;\r\n}\r\nskb_cur = skb_next;\r\n}\r\nup_read(&listeners->sem);\r\nif (skb_cur)\r\nnlmsg_free(skb_cur);\r\nif (!delcount)\r\nreturn;\r\ndown_write(&listeners->sem);\r\nlist_for_each_entry_safe(s, tmp, &listeners->list, list) {\r\nif (!s->valid) {\r\nlist_del(&s->list);\r\nkfree(s);\r\n}\r\n}\r\nup_write(&listeners->sem);\r\n}\r\nstatic void fill_stats(struct user_namespace *user_ns,\r\nstruct pid_namespace *pid_ns,\r\nstruct task_struct *tsk, struct taskstats *stats)\r\n{\r\nmemset(stats, 0, sizeof(*stats));\r\ndelayacct_add_tsk(stats, tsk);\r\nstats->version = TASKSTATS_VERSION;\r\nstats->nvcsw = tsk->nvcsw;\r\nstats->nivcsw = tsk->nivcsw;\r\nbacct_add_tsk(user_ns, pid_ns, stats, tsk);\r\nxacct_add_tsk(stats, tsk);\r\n}\r\nstatic int fill_stats_for_pid(pid_t pid, struct taskstats *stats)\r\n{\r\nstruct task_struct *tsk;\r\nrcu_read_lock();\r\ntsk = find_task_by_vpid(pid);\r\nif (tsk)\r\nget_task_struct(tsk);\r\nrcu_read_unlock();\r\nif (!tsk)\r\nreturn -ESRCH;\r\nfill_stats(current_user_ns(), task_active_pid_ns(current), tsk, stats);\r\nput_task_struct(tsk);\r\nreturn 0;\r\n}\r\nstatic int fill_stats_for_tgid(pid_t tgid, struct taskstats *stats)\r\n{\r\nstruct task_struct *tsk, *first;\r\nunsigned long flags;\r\nint rc = -ESRCH;\r\nrcu_read_lock();\r\nfirst = find_task_by_vpid(tgid);\r\nif (!first || !lock_task_sighand(first, &flags))\r\ngoto out;\r\nif (first->signal->stats)\r\nmemcpy(stats, first->signal->stats, sizeof(*stats));\r\nelse\r\nmemset(stats, 0, sizeof(*stats));\r\ntsk = first;\r\ndo {\r\nif (tsk->exit_state)\r\ncontinue;\r\ndelayacct_add_tsk(stats, tsk);\r\nstats->nvcsw += tsk->nvcsw;\r\nstats->nivcsw += tsk->nivcsw;\r\n} while_each_thread(first, tsk);\r\nvoid fill_tgid_exit(struct task_struct *tsk)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tsk->sighand->siglock, flags);\r\nif (!tsk->signal->stats)\r\ngoto ret;\r\ndelayacct_add_tsk(tsk->signal->stats, tsk);\r\nret:\r\nspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\r\nreturn;\r\n}\r\nstatic int add_del_listener(pid_t pid, const struct cpumask *mask, int isadd)\r\n{\r\nstruct listener_list *listeners;\r\nstruct listener *s, *tmp, *s2;\r\nunsigned int cpu;\r\nint ret = 0;\r\nif (!cpumask_subset(mask, cpu_possible_mask))\r\nreturn -EINVAL;\r\nif (current_user_ns() != &init_user_ns)\r\nreturn -EINVAL;\r\nif (task_active_pid_ns(current) != &init_pid_ns)\r\nreturn -EINVAL;\r\nif (isadd == REGISTER) {\r\nfor_each_cpu(cpu, mask) {\r\ns = kmalloc_node(sizeof(struct listener),\r\nGFP_KERNEL, cpu_to_node(cpu));\r\nif (!s) {\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\ns->pid = pid;\r\ns->valid = 1;\r\nlisteners = &per_cpu(listener_array, cpu);\r\ndown_write(&listeners->sem);\r\nlist_for_each_entry(s2, &listeners->list, list) {\r\nif (s2->pid == pid && s2->valid)\r\ngoto exists;\r\n}\r\nlist_add(&s->list, &listeners->list);\r\ns = NULL;\r\nexists:\r\nup_write(&listeners->sem);\r\nkfree(s);\r\n}\r\nreturn 0;\r\n}\r\ncleanup:\r\nfor_each_cpu(cpu, mask) {\r\nlisteners = &per_cpu(listener_array, cpu);\r\ndown_write(&listeners->sem);\r\nlist_for_each_entry_safe(s, tmp, &listeners->list, list) {\r\nif (s->pid == pid) {\r\nlist_del(&s->list);\r\nkfree(s);\r\nbreak;\r\n}\r\n}\r\nup_write(&listeners->sem);\r\n}\r\nreturn ret;\r\n}\r\nstatic int parse(struct nlattr *na, struct cpumask *mask)\r\n{\r\nchar *data;\r\nint len;\r\nint ret;\r\nif (na == NULL)\r\nreturn 1;\r\nlen = nla_len(na);\r\nif (len > TASKSTATS_CPUMASK_MAXLEN)\r\nreturn -E2BIG;\r\nif (len < 1)\r\nreturn -EINVAL;\r\ndata = kmalloc(len, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nnla_strlcpy(data, na, len);\r\nret = cpulist_parse(data, mask);\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic struct taskstats *mk_reply(struct sk_buff *skb, int type, u32 pid)\r\n{\r\nstruct nlattr *na, *ret;\r\nint aggr;\r\naggr = (type == TASKSTATS_TYPE_PID)\r\n? TASKSTATS_TYPE_AGGR_PID\r\n: TASKSTATS_TYPE_AGGR_TGID;\r\n#ifdef TASKSTATS_NEEDS_PADDING\r\nif (nla_put(skb, TASKSTATS_TYPE_NULL, 0, NULL) < 0)\r\ngoto err;\r\n#endif\r\nna = nla_nest_start(skb, aggr);\r\nif (!na)\r\ngoto err;\r\nif (nla_put(skb, type, sizeof(pid), &pid) < 0) {\r\nnla_nest_cancel(skb, na);\r\ngoto err;\r\n}\r\nret = nla_reserve(skb, TASKSTATS_TYPE_STATS, sizeof(struct taskstats));\r\nif (!ret) {\r\nnla_nest_cancel(skb, na);\r\ngoto err;\r\n}\r\nnla_nest_end(skb, na);\r\nreturn nla_data(ret);\r\nerr:\r\nreturn NULL;\r\n}\r\nstatic int cgroupstats_user_cmd(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nint rc = 0;\r\nstruct sk_buff *rep_skb;\r\nstruct cgroupstats *stats;\r\nstruct nlattr *na;\r\nsize_t size;\r\nu32 fd;\r\nstruct fd f;\r\nna = info->attrs[CGROUPSTATS_CMD_ATTR_FD];\r\nif (!na)\r\nreturn -EINVAL;\r\nfd = nla_get_u32(info->attrs[CGROUPSTATS_CMD_ATTR_FD]);\r\nf = fdget(fd);\r\nif (!f.file)\r\nreturn 0;\r\nsize = nla_total_size(sizeof(struct cgroupstats));\r\nrc = prepare_reply(info, CGROUPSTATS_CMD_NEW, &rep_skb,\r\nsize);\r\nif (rc < 0)\r\ngoto err;\r\nna = nla_reserve(rep_skb, CGROUPSTATS_TYPE_CGROUP_STATS,\r\nsizeof(struct cgroupstats));\r\nif (na == NULL) {\r\nnlmsg_free(rep_skb);\r\nrc = -EMSGSIZE;\r\ngoto err;\r\n}\r\nstats = nla_data(na);\r\nmemset(stats, 0, sizeof(*stats));\r\nrc = cgroupstats_build(stats, f.file->f_path.dentry);\r\nif (rc < 0) {\r\nnlmsg_free(rep_skb);\r\ngoto err;\r\n}\r\nrc = send_reply(rep_skb, info);\r\nerr:\r\nfdput(f);\r\nreturn rc;\r\n}\r\nstatic int cmd_attr_register_cpumask(struct genl_info *info)\r\n{\r\ncpumask_var_t mask;\r\nint rc;\r\nif (!alloc_cpumask_var(&mask, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nrc = parse(info->attrs[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK], mask);\r\nif (rc < 0)\r\ngoto out;\r\nrc = add_del_listener(info->snd_portid, mask, REGISTER);\r\nout:\r\nfree_cpumask_var(mask);\r\nreturn rc;\r\n}\r\nstatic int cmd_attr_deregister_cpumask(struct genl_info *info)\r\n{\r\ncpumask_var_t mask;\r\nint rc;\r\nif (!alloc_cpumask_var(&mask, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nrc = parse(info->attrs[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK], mask);\r\nif (rc < 0)\r\ngoto out;\r\nrc = add_del_listener(info->snd_portid, mask, DEREGISTER);\r\nout:\r\nfree_cpumask_var(mask);\r\nreturn rc;\r\n}\r\nstatic size_t taskstats_packet_size(void)\r\n{\r\nsize_t size;\r\nsize = nla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(struct taskstats)) + nla_total_size(0);\r\n#ifdef TASKSTATS_NEEDS_PADDING\r\nsize += nla_total_size(0);\r\n#endif\r\nreturn size;\r\n}\r\nstatic int cmd_attr_pid(struct genl_info *info)\r\n{\r\nstruct taskstats *stats;\r\nstruct sk_buff *rep_skb;\r\nsize_t size;\r\nu32 pid;\r\nint rc;\r\nsize = taskstats_packet_size();\r\nrc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = -EINVAL;\r\npid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_PID]);\r\nstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID, pid);\r\nif (!stats)\r\ngoto err;\r\nrc = fill_stats_for_pid(pid, stats);\r\nif (rc < 0)\r\ngoto err;\r\nreturn send_reply(rep_skb, info);\r\nerr:\r\nnlmsg_free(rep_skb);\r\nreturn rc;\r\n}\r\nstatic int cmd_attr_tgid(struct genl_info *info)\r\n{\r\nstruct taskstats *stats;\r\nstruct sk_buff *rep_skb;\r\nsize_t size;\r\nu32 tgid;\r\nint rc;\r\nsize = taskstats_packet_size();\r\nrc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = -EINVAL;\r\ntgid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_TGID]);\r\nstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID, tgid);\r\nif (!stats)\r\ngoto err;\r\nrc = fill_stats_for_tgid(tgid, stats);\r\nif (rc < 0)\r\ngoto err;\r\nreturn send_reply(rep_skb, info);\r\nerr:\r\nnlmsg_free(rep_skb);\r\nreturn rc;\r\n}\r\nstatic int taskstats_user_cmd(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nif (info->attrs[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK])\r\nreturn cmd_attr_register_cpumask(info);\r\nelse if (info->attrs[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK])\r\nreturn cmd_attr_deregister_cpumask(info);\r\nelse if (info->attrs[TASKSTATS_CMD_ATTR_PID])\r\nreturn cmd_attr_pid(info);\r\nelse if (info->attrs[TASKSTATS_CMD_ATTR_TGID])\r\nreturn cmd_attr_tgid(info);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic struct taskstats *taskstats_tgid_alloc(struct task_struct *tsk)\r\n{\r\nstruct signal_struct *sig = tsk->signal;\r\nstruct taskstats *stats;\r\nif (sig->stats || thread_group_empty(tsk))\r\ngoto ret;\r\nstats = kmem_cache_zalloc(taskstats_cache, GFP_KERNEL);\r\nspin_lock_irq(&tsk->sighand->siglock);\r\nif (!sig->stats) {\r\nsig->stats = stats;\r\nstats = NULL;\r\n}\r\nspin_unlock_irq(&tsk->sighand->siglock);\r\nif (stats)\r\nkmem_cache_free(taskstats_cache, stats);\r\nret:\r\nreturn sig->stats;\r\n}\r\nvoid taskstats_exit(struct task_struct *tsk, int group_dead)\r\n{\r\nint rc;\r\nstruct listener_list *listeners;\r\nstruct taskstats *stats;\r\nstruct sk_buff *rep_skb;\r\nsize_t size;\r\nint is_thread_group;\r\nif (!family_registered)\r\nreturn;\r\nsize = taskstats_packet_size();\r\nis_thread_group = !!taskstats_tgid_alloc(tsk);\r\nif (is_thread_group) {\r\nsize = 2 * size;\r\nfill_tgid_exit(tsk);\r\n}\r\nlisteners = raw_cpu_ptr(&listener_array);\r\nif (list_empty(&listeners->list))\r\nreturn;\r\nrc = prepare_reply(NULL, TASKSTATS_CMD_NEW, &rep_skb, size);\r\nif (rc < 0)\r\nreturn;\r\nstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID,\r\ntask_pid_nr_ns(tsk, &init_pid_ns));\r\nif (!stats)\r\ngoto err;\r\nfill_stats(&init_user_ns, &init_pid_ns, tsk, stats);\r\nif (!is_thread_group || !group_dead)\r\ngoto send;\r\nstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID,\r\ntask_tgid_nr_ns(tsk, &init_pid_ns));\r\nif (!stats)\r\ngoto err;\r\nmemcpy(stats, tsk->signal->stats, sizeof(*stats));\r\nsend:\r\nsend_cpu_listeners(rep_skb, listeners);\r\nreturn;\r\nerr:\r\nnlmsg_free(rep_skb);\r\n}\r\nvoid __init taskstats_init_early(void)\r\n{\r\nunsigned int i;\r\ntaskstats_cache = KMEM_CACHE(taskstats, SLAB_PANIC);\r\nfor_each_possible_cpu(i) {\r\nINIT_LIST_HEAD(&(per_cpu(listener_array, i).list));\r\ninit_rwsem(&(per_cpu(listener_array, i).sem));\r\n}\r\n}\r\nstatic int __init taskstats_init(void)\r\n{\r\nint rc;\r\nrc = genl_register_family_with_ops(&family, taskstats_ops);\r\nif (rc)\r\nreturn rc;\r\nfamily_registered = 1;\r\npr_info("registered taskstats version %d\n", TASKSTATS_GENL_VERSION);\r\nreturn 0;\r\n}
