static struct mdp5_kms *get_kms(struct drm_crtc *crtc)\r\n{\r\nstruct msm_drm_private *priv = crtc->dev->dev_private;\r\nreturn to_mdp5_kms(to_mdp_kms(priv->kms));\r\n}\r\nstatic void request_pending(struct drm_crtc *crtc, uint32_t pending)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\natomic_or(pending, &mdp5_crtc->pending);\r\nmdp_irq_register(&get_kms(crtc)->base, &mdp5_crtc->vblank);\r\n}\r\nstatic void request_pp_done_pending(struct drm_crtc *crtc)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nreinit_completion(&mdp5_crtc->pp_completion);\r\n}\r\nstatic u32 crtc_flush(struct drm_crtc *crtc, u32 flush_mask)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nDBG("%s: flush=%08x", mdp5_crtc->name, flush_mask);\r\nreturn mdp5_ctl_commit(mdp5_crtc->ctl, flush_mask);\r\n}\r\nstatic u32 crtc_flush_all(struct drm_crtc *crtc)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nstruct drm_plane *plane;\r\nuint32_t flush_mask = 0;\r\nif (WARN_ON(!mdp5_crtc->ctl))\r\nreturn 0;\r\ndrm_atomic_crtc_for_each_plane(plane, crtc) {\r\nflush_mask |= mdp5_plane_get_flush(plane);\r\n}\r\nflush_mask |= mdp_ctl_flush_mask_lm(mdp5_crtc->lm);\r\nreturn crtc_flush(crtc, flush_mask);\r\n}\r\nstatic void complete_flip(struct drm_crtc *crtc, struct drm_file *file)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_pending_vblank_event *event;\r\nstruct drm_plane *plane;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nevent = mdp5_crtc->event;\r\nif (event) {\r\nif (!file || (event->base.file_priv == file)) {\r\nmdp5_crtc->event = NULL;\r\nDBG("%s: send event: %p", mdp5_crtc->name, event);\r\ndrm_send_vblank_event(dev, mdp5_crtc->id, event);\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\ndrm_atomic_crtc_for_each_plane(plane, crtc) {\r\nmdp5_plane_complete_flip(plane);\r\n}\r\nif (mdp5_crtc->ctl && !crtc->state->enable) {\r\nmdp5_ctl_blend(mdp5_crtc->ctl, NULL, 0, 0);\r\nmdp5_crtc->ctl = NULL;\r\n}\r\n}\r\nstatic void unref_cursor_worker(struct drm_flip_work *work, void *val)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc =\r\ncontainer_of(work, struct mdp5_crtc, unref_cursor_work);\r\nstruct mdp5_kms *mdp5_kms = get_kms(&mdp5_crtc->base);\r\nmsm_gem_put_iova(val, mdp5_kms->id);\r\ndrm_gem_object_unreference_unlocked(val);\r\n}\r\nstatic void mdp5_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\ndrm_crtc_cleanup(crtc);\r\ndrm_flip_work_cleanup(&mdp5_crtc->unref_cursor_work);\r\nkfree(mdp5_crtc);\r\n}\r\nstatic bool mdp5_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void blend_setup(struct drm_crtc *crtc)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nstruct mdp5_kms *mdp5_kms = get_kms(crtc);\r\nstruct drm_plane *plane;\r\nconst struct mdp5_cfg_hw *hw_cfg;\r\nstruct mdp5_plane_state *pstate, *pstates[STAGE_MAX + 1] = {NULL};\r\nconst struct mdp_format *format;\r\nuint32_t lm = mdp5_crtc->lm;\r\nuint32_t blend_op, fg_alpha, bg_alpha, ctl_blend_flags = 0;\r\nunsigned long flags;\r\nuint8_t stage[STAGE_MAX + 1];\r\nint i, plane_cnt = 0;\r\n#define blender(stage) ((stage) - STAGE0)\r\nhw_cfg = mdp5_cfg_get_hw_config(mdp5_kms->cfg);\r\nspin_lock_irqsave(&mdp5_crtc->lm_lock, flags);\r\nif (!mdp5_crtc->ctl)\r\ngoto out;\r\ndrm_atomic_crtc_for_each_plane(plane, crtc) {\r\npstate = to_mdp5_plane_state(plane->state);\r\npstates[pstate->stage] = pstate;\r\nstage[pstate->stage] = mdp5_plane_pipe(plane);\r\nplane_cnt++;\r\n}\r\nif (!pstates[STAGE_BASE] && plane_cnt) {\r\nctl_blend_flags |= MDP5_CTL_BLEND_OP_FLAG_BORDER_OUT;\r\nDBG("Border Color is enabled");\r\n}\r\nfor (i = STAGE0; i <= STAGE_MAX; i++) {\r\nif (!pstates[i])\r\ncontinue;\r\nformat = to_mdp_format(\r\nmsm_framebuffer_format(pstates[i]->base.fb));\r\nplane = pstates[i]->base.plane;\r\nblend_op = MDP5_LM_BLEND_OP_MODE_FG_ALPHA(FG_CONST) |\r\nMDP5_LM_BLEND_OP_MODE_BG_ALPHA(BG_CONST);\r\nfg_alpha = pstates[i]->alpha;\r\nbg_alpha = 0xFF - pstates[i]->alpha;\r\nDBG("Stage %d fg_alpha %x bg_alpha %x", i, fg_alpha, bg_alpha);\r\nif (format->alpha_enable && pstates[i]->premultiplied) {\r\nblend_op = MDP5_LM_BLEND_OP_MODE_FG_ALPHA(FG_CONST) |\r\nMDP5_LM_BLEND_OP_MODE_BG_ALPHA(FG_PIXEL);\r\nif (fg_alpha != 0xff) {\r\nbg_alpha = fg_alpha;\r\nblend_op |=\r\nMDP5_LM_BLEND_OP_MODE_BG_MOD_ALPHA |\r\nMDP5_LM_BLEND_OP_MODE_BG_INV_MOD_ALPHA;\r\n} else {\r\nblend_op |= MDP5_LM_BLEND_OP_MODE_BG_INV_ALPHA;\r\n}\r\n} else if (format->alpha_enable) {\r\nblend_op = MDP5_LM_BLEND_OP_MODE_FG_ALPHA(FG_PIXEL) |\r\nMDP5_LM_BLEND_OP_MODE_BG_ALPHA(FG_PIXEL);\r\nif (fg_alpha != 0xff) {\r\nbg_alpha = fg_alpha;\r\nblend_op |=\r\nMDP5_LM_BLEND_OP_MODE_FG_MOD_ALPHA |\r\nMDP5_LM_BLEND_OP_MODE_FG_INV_MOD_ALPHA |\r\nMDP5_LM_BLEND_OP_MODE_BG_MOD_ALPHA |\r\nMDP5_LM_BLEND_OP_MODE_BG_INV_MOD_ALPHA;\r\n} else {\r\nblend_op |= MDP5_LM_BLEND_OP_MODE_BG_INV_ALPHA;\r\n}\r\n}\r\nmdp5_write(mdp5_kms, REG_MDP5_LM_BLEND_OP_MODE(lm,\r\nblender(i)), blend_op);\r\nmdp5_write(mdp5_kms, REG_MDP5_LM_BLEND_FG_ALPHA(lm,\r\nblender(i)), fg_alpha);\r\nmdp5_write(mdp5_kms, REG_MDP5_LM_BLEND_BG_ALPHA(lm,\r\nblender(i)), bg_alpha);\r\n}\r\nmdp5_ctl_blend(mdp5_crtc->ctl, stage, plane_cnt, ctl_blend_flags);\r\nout:\r\nspin_unlock_irqrestore(&mdp5_crtc->lm_lock, flags);\r\n}\r\nstatic void mdp5_crtc_mode_set_nofb(struct drm_crtc *crtc)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nstruct mdp5_kms *mdp5_kms = get_kms(crtc);\r\nunsigned long flags;\r\nstruct drm_display_mode *mode;\r\nif (WARN_ON(!crtc->state))\r\nreturn;\r\nmode = &crtc->state->adjusted_mode;\r\nDBG("%s: set mode: %d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x",\r\nmdp5_crtc->name, mode->base.id, mode->name,\r\nmode->vrefresh, mode->clock,\r\nmode->hdisplay, mode->hsync_start,\r\nmode->hsync_end, mode->htotal,\r\nmode->vdisplay, mode->vsync_start,\r\nmode->vsync_end, mode->vtotal,\r\nmode->type, mode->flags);\r\nspin_lock_irqsave(&mdp5_crtc->lm_lock, flags);\r\nmdp5_write(mdp5_kms, REG_MDP5_LM_OUT_SIZE(mdp5_crtc->lm),\r\nMDP5_LM_OUT_SIZE_WIDTH(mode->hdisplay) |\r\nMDP5_LM_OUT_SIZE_HEIGHT(mode->vdisplay));\r\nspin_unlock_irqrestore(&mdp5_crtc->lm_lock, flags);\r\n}\r\nstatic void mdp5_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nstruct mdp5_kms *mdp5_kms = get_kms(crtc);\r\nDBG("%s", mdp5_crtc->name);\r\nif (WARN_ON(!mdp5_crtc->enabled))\r\nreturn;\r\nif (mdp5_crtc->cmd_mode)\r\nmdp_irq_unregister(&mdp5_kms->base, &mdp5_crtc->pp_done);\r\nmdp_irq_unregister(&mdp5_kms->base, &mdp5_crtc->err);\r\nmdp5_disable(mdp5_kms);\r\nmdp5_crtc->enabled = false;\r\n}\r\nstatic void mdp5_crtc_enable(struct drm_crtc *crtc)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nstruct mdp5_kms *mdp5_kms = get_kms(crtc);\r\nDBG("%s", mdp5_crtc->name);\r\nif (WARN_ON(mdp5_crtc->enabled))\r\nreturn;\r\nmdp5_enable(mdp5_kms);\r\nmdp_irq_register(&mdp5_kms->base, &mdp5_crtc->err);\r\nif (mdp5_crtc->cmd_mode)\r\nmdp_irq_register(&mdp5_kms->base, &mdp5_crtc->pp_done);\r\nmdp5_crtc->enabled = true;\r\n}\r\nstatic int pstate_cmp(const void *a, const void *b)\r\n{\r\nstruct plane_state *pa = (struct plane_state *)a;\r\nstruct plane_state *pb = (struct plane_state *)b;\r\nreturn pa->state->zpos - pb->state->zpos;\r\n}\r\nstatic int mdp5_crtc_atomic_check(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *state)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nstruct mdp5_kms *mdp5_kms = get_kms(crtc);\r\nstruct drm_plane *plane;\r\nstruct drm_device *dev = crtc->dev;\r\nstruct plane_state pstates[STAGE_MAX + 1];\r\nconst struct mdp5_cfg_hw *hw_cfg;\r\nint cnt = 0, i;\r\nDBG("%s: check", mdp5_crtc->name);\r\nhw_cfg = mdp5_cfg_get_hw_config(mdp5_kms->cfg);\r\ndrm_atomic_crtc_state_for_each_plane(plane, state) {\r\nstruct drm_plane_state *pstate;\r\nif (cnt >= (hw_cfg->lm.nb_stages)) {\r\ndev_err(dev->dev, "too many planes!\n");\r\nreturn -EINVAL;\r\n}\r\npstate = state->state->plane_states[drm_plane_index(plane)];\r\nif (!pstate)\r\npstate = plane->state;\r\npstates[cnt].plane = plane;\r\npstates[cnt].state = to_mdp5_plane_state(pstate);\r\ncnt++;\r\n}\r\nsort(pstates, cnt, sizeof(pstates[0]), pstate_cmp, NULL);\r\nfor (i = 0; i < cnt; i++) {\r\npstates[i].state->stage = STAGE_BASE + i;\r\nDBG("%s: assign pipe %s on stage=%d", mdp5_crtc->name,\r\npipe2name(mdp5_plane_pipe(pstates[i].plane)),\r\npstates[i].state->stage);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mdp5_crtc_atomic_begin(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *old_crtc_state)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nDBG("%s: begin", mdp5_crtc->name);\r\n}\r\nstatic void mdp5_crtc_atomic_flush(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *old_crtc_state)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nunsigned long flags;\r\nDBG("%s: event: %p", mdp5_crtc->name, crtc->state->event);\r\nWARN_ON(mdp5_crtc->event);\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nmdp5_crtc->event = crtc->state->event;\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nif (unlikely(!mdp5_crtc->ctl))\r\nreturn;\r\nblend_setup(crtc);\r\nif (mdp5_crtc->cmd_mode)\r\nrequest_pp_done_pending(crtc);\r\nmdp5_crtc->flushed_mask = crtc_flush_all(crtc);\r\nrequest_pending(crtc, PENDING_FLIP);\r\n}\r\nstatic int mdp5_crtc_set_property(struct drm_crtc *crtc,\r\nstruct drm_property *property, uint64_t val)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic void get_roi(struct drm_crtc *crtc, uint32_t *roi_w, uint32_t *roi_h)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nuint32_t xres = crtc->mode.hdisplay;\r\nuint32_t yres = crtc->mode.vdisplay;\r\n*roi_w = min(mdp5_crtc->cursor.width, xres -\r\nmdp5_crtc->cursor.x);\r\n*roi_h = min(mdp5_crtc->cursor.height, yres -\r\nmdp5_crtc->cursor.y);\r\n}\r\nstatic int mdp5_crtc_cursor_set(struct drm_crtc *crtc,\r\nstruct drm_file *file, uint32_t handle,\r\nuint32_t width, uint32_t height)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct mdp5_kms *mdp5_kms = get_kms(crtc);\r\nstruct drm_gem_object *cursor_bo, *old_bo = NULL;\r\nuint32_t blendcfg, cursor_addr, stride;\r\nint ret, bpp, lm;\r\nunsigned int depth;\r\nenum mdp5_cursor_alpha cur_alpha = CURSOR_ALPHA_PER_PIXEL;\r\nuint32_t flush_mask = mdp_ctl_flush_mask_cursor(0);\r\nuint32_t roi_w, roi_h;\r\nbool cursor_enable = true;\r\nunsigned long flags;\r\nif ((width > CURSOR_WIDTH) || (height > CURSOR_HEIGHT)) {\r\ndev_err(dev->dev, "bad cursor size: %dx%d\n", width, height);\r\nreturn -EINVAL;\r\n}\r\nif (NULL == mdp5_crtc->ctl)\r\nreturn -EINVAL;\r\nif (!handle) {\r\nDBG("Cursor off");\r\ncursor_enable = false;\r\ngoto set_cursor;\r\n}\r\ncursor_bo = drm_gem_object_lookup(dev, file, handle);\r\nif (!cursor_bo)\r\nreturn -ENOENT;\r\nret = msm_gem_get_iova(cursor_bo, mdp5_kms->id, &cursor_addr);\r\nif (ret)\r\nreturn -EINVAL;\r\nlm = mdp5_crtc->lm;\r\ndrm_fb_get_bpp_depth(DRM_FORMAT_ARGB8888, &depth, &bpp);\r\nstride = width * (bpp >> 3);\r\nspin_lock_irqsave(&mdp5_crtc->cursor.lock, flags);\r\nold_bo = mdp5_crtc->cursor.scanout_bo;\r\nmdp5_crtc->cursor.scanout_bo = cursor_bo;\r\nmdp5_crtc->cursor.width = width;\r\nmdp5_crtc->cursor.height = height;\r\nget_roi(crtc, &roi_w, &roi_h);\r\nmdp5_write(mdp5_kms, REG_MDP5_LM_CURSOR_STRIDE(lm), stride);\r\nmdp5_write(mdp5_kms, REG_MDP5_LM_CURSOR_FORMAT(lm),\r\nMDP5_LM_CURSOR_FORMAT_FORMAT(CURSOR_FMT_ARGB8888));\r\nmdp5_write(mdp5_kms, REG_MDP5_LM_CURSOR_IMG_SIZE(lm),\r\nMDP5_LM_CURSOR_IMG_SIZE_SRC_H(height) |\r\nMDP5_LM_CURSOR_IMG_SIZE_SRC_W(width));\r\nmdp5_write(mdp5_kms, REG_MDP5_LM_CURSOR_SIZE(lm),\r\nMDP5_LM_CURSOR_SIZE_ROI_H(roi_h) |\r\nMDP5_LM_CURSOR_SIZE_ROI_W(roi_w));\r\nmdp5_write(mdp5_kms, REG_MDP5_LM_CURSOR_BASE_ADDR(lm), cursor_addr);\r\nblendcfg = MDP5_LM_CURSOR_BLEND_CONFIG_BLEND_EN;\r\nblendcfg |= MDP5_LM_CURSOR_BLEND_CONFIG_BLEND_ALPHA_SEL(cur_alpha);\r\nmdp5_write(mdp5_kms, REG_MDP5_LM_CURSOR_BLEND_CONFIG(lm), blendcfg);\r\nspin_unlock_irqrestore(&mdp5_crtc->cursor.lock, flags);\r\nset_cursor:\r\nret = mdp5_ctl_set_cursor(mdp5_crtc->ctl, 0, cursor_enable);\r\nif (ret) {\r\ndev_err(dev->dev, "failed to %sable cursor: %d\n",\r\ncursor_enable ? "en" : "dis", ret);\r\ngoto end;\r\n}\r\ncrtc_flush(crtc, flush_mask);\r\nend:\r\nif (old_bo) {\r\ndrm_flip_work_queue(&mdp5_crtc->unref_cursor_work, old_bo);\r\nrequest_pending(crtc, PENDING_CURSOR);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mdp5_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)\r\n{\r\nstruct mdp5_kms *mdp5_kms = get_kms(crtc);\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nuint32_t flush_mask = mdp_ctl_flush_mask_cursor(0);\r\nuint32_t roi_w;\r\nuint32_t roi_h;\r\nunsigned long flags;\r\nif (unlikely(!crtc->state->enable))\r\nreturn 0;\r\nmdp5_crtc->cursor.x = x = max(x, 0);\r\nmdp5_crtc->cursor.y = y = max(y, 0);\r\nget_roi(crtc, &roi_w, &roi_h);\r\nspin_lock_irqsave(&mdp5_crtc->cursor.lock, flags);\r\nmdp5_write(mdp5_kms, REG_MDP5_LM_CURSOR_SIZE(mdp5_crtc->lm),\r\nMDP5_LM_CURSOR_SIZE_ROI_H(roi_h) |\r\nMDP5_LM_CURSOR_SIZE_ROI_W(roi_w));\r\nmdp5_write(mdp5_kms, REG_MDP5_LM_CURSOR_START_XY(mdp5_crtc->lm),\r\nMDP5_LM_CURSOR_START_XY_Y_START(y) |\r\nMDP5_LM_CURSOR_START_XY_X_START(x));\r\nspin_unlock_irqrestore(&mdp5_crtc->cursor.lock, flags);\r\ncrtc_flush(crtc, flush_mask);\r\nreturn 0;\r\n}\r\nstatic void mdp5_crtc_vblank_irq(struct mdp_irq *irq, uint32_t irqstatus)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = container_of(irq, struct mdp5_crtc, vblank);\r\nstruct drm_crtc *crtc = &mdp5_crtc->base;\r\nstruct msm_drm_private *priv = crtc->dev->dev_private;\r\nunsigned pending;\r\nmdp_irq_unregister(&get_kms(crtc)->base, &mdp5_crtc->vblank);\r\npending = atomic_xchg(&mdp5_crtc->pending, 0);\r\nif (pending & PENDING_FLIP) {\r\ncomplete_flip(crtc, NULL);\r\n}\r\nif (pending & PENDING_CURSOR)\r\ndrm_flip_work_commit(&mdp5_crtc->unref_cursor_work, priv->wq);\r\n}\r\nstatic void mdp5_crtc_err_irq(struct mdp_irq *irq, uint32_t irqstatus)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = container_of(irq, struct mdp5_crtc, err);\r\nDBG("%s: error: %08x", mdp5_crtc->name, irqstatus);\r\n}\r\nstatic void mdp5_crtc_pp_done_irq(struct mdp_irq *irq, uint32_t irqstatus)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = container_of(irq, struct mdp5_crtc,\r\npp_done);\r\ncomplete(&mdp5_crtc->pp_completion);\r\n}\r\nstatic void mdp5_crtc_wait_for_pp_done(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nint ret;\r\nret = wait_for_completion_timeout(&mdp5_crtc->pp_completion,\r\nmsecs_to_jiffies(50));\r\nif (ret == 0)\r\ndev_warn(dev->dev, "pp done time out, lm=%d\n", mdp5_crtc->lm);\r\n}\r\nstatic void mdp5_crtc_wait_for_flush_done(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nint ret;\r\nif (!mdp5_crtc->ctl)\r\nreturn;\r\nret = drm_crtc_vblank_get(crtc);\r\nif (ret)\r\nreturn;\r\nret = wait_event_timeout(dev->vblank[drm_crtc_index(crtc)].queue,\r\n((mdp5_ctl_get_commit_status(mdp5_crtc->ctl) &\r\nmdp5_crtc->flushed_mask) == 0),\r\nmsecs_to_jiffies(50));\r\nif (ret <= 0)\r\ndev_warn(dev->dev, "vblank time out, crtc=%d\n", mdp5_crtc->id);\r\nmdp5_crtc->flushed_mask = 0;\r\ndrm_crtc_vblank_put(crtc);\r\n}\r\nuint32_t mdp5_crtc_vblank(struct drm_crtc *crtc)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nreturn mdp5_crtc->vblank.irqmask;\r\n}\r\nvoid mdp5_crtc_cancel_pending_flip(struct drm_crtc *crtc, struct drm_file *file)\r\n{\r\nDBG("cancel: %p", file);\r\ncomplete_flip(crtc, file);\r\n}\r\nvoid mdp5_crtc_set_pipeline(struct drm_crtc *crtc,\r\nstruct mdp5_interface *intf, struct mdp5_ctl *ctl)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nstruct mdp5_kms *mdp5_kms = get_kms(crtc);\r\nint lm = mdp5_crtc_get_lm(crtc);\r\nmdp5_crtc->err.irqmask = intf2err(intf->num);\r\nmdp5_crtc->vblank.irqmask = intf2vblank(lm, intf);\r\nif ((intf->type == INTF_DSI) &&\r\n(intf->mode == MDP5_INTF_DSI_MODE_COMMAND)) {\r\nmdp5_crtc->pp_done.irqmask = lm2ppdone(lm);\r\nmdp5_crtc->pp_done.irq = mdp5_crtc_pp_done_irq;\r\nmdp5_crtc->cmd_mode = true;\r\n} else {\r\nmdp5_crtc->pp_done.irqmask = 0;\r\nmdp5_crtc->pp_done.irq = NULL;\r\nmdp5_crtc->cmd_mode = false;\r\n}\r\nmdp_irq_update(&mdp5_kms->base);\r\nmdp5_crtc->ctl = ctl;\r\nmdp5_ctl_set_pipeline(ctl, intf, lm);\r\n}\r\nint mdp5_crtc_get_lm(struct drm_crtc *crtc)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nreturn WARN_ON(!crtc) ? -EINVAL : mdp5_crtc->lm;\r\n}\r\nvoid mdp5_crtc_wait_for_commit_done(struct drm_crtc *crtc)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nif (mdp5_crtc->cmd_mode)\r\nmdp5_crtc_wait_for_pp_done(crtc);\r\nelse\r\nmdp5_crtc_wait_for_flush_done(crtc);\r\n}\r\nstruct drm_crtc *mdp5_crtc_init(struct drm_device *dev,\r\nstruct drm_plane *plane, int id)\r\n{\r\nstruct drm_crtc *crtc = NULL;\r\nstruct mdp5_crtc *mdp5_crtc;\r\nmdp5_crtc = kzalloc(sizeof(*mdp5_crtc), GFP_KERNEL);\r\nif (!mdp5_crtc)\r\nreturn ERR_PTR(-ENOMEM);\r\ncrtc = &mdp5_crtc->base;\r\nmdp5_crtc->id = id;\r\nmdp5_crtc->lm = GET_LM_ID(id);\r\nspin_lock_init(&mdp5_crtc->lm_lock);\r\nspin_lock_init(&mdp5_crtc->cursor.lock);\r\ninit_completion(&mdp5_crtc->pp_completion);\r\nmdp5_crtc->vblank.irq = mdp5_crtc_vblank_irq;\r\nmdp5_crtc->err.irq = mdp5_crtc_err_irq;\r\nsnprintf(mdp5_crtc->name, sizeof(mdp5_crtc->name), "%s:%d",\r\npipe2name(mdp5_plane_pipe(plane)), id);\r\ndrm_crtc_init_with_planes(dev, crtc, plane, NULL, &mdp5_crtc_funcs);\r\ndrm_flip_work_init(&mdp5_crtc->unref_cursor_work,\r\n"unref cursor", unref_cursor_worker);\r\ndrm_crtc_helper_add(crtc, &mdp5_crtc_helper_funcs);\r\nplane->crtc = crtc;\r\nreturn crtc;\r\n}
