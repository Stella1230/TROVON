static void\r\nnvkm_client_unmap(void *priv, void __iomem *ptr, u32 size)\r\n{\r\niounmap(ptr);\r\n}\r\nstatic void __iomem *\r\nnvkm_client_map(void *priv, u64 handle, u32 size)\r\n{\r\nreturn ioremap(handle, size);\r\n}\r\nstatic int\r\nnvkm_client_ioctl(void *priv, bool super, void *data, u32 size, void **hack)\r\n{\r\nreturn nvkm_ioctl(priv, super, data, size, hack);\r\n}\r\nstatic int\r\nnvkm_client_resume(void *priv)\r\n{\r\nreturn nvkm_client_init(priv);\r\n}\r\nstatic int\r\nnvkm_client_suspend(void *priv)\r\n{\r\nreturn nvkm_client_fini(priv, true);\r\n}\r\nstatic void\r\nnvkm_client_driver_fini(void *priv)\r\n{\r\nstruct nvkm_client *client = priv;\r\nnvkm_client_del(&client);\r\n}\r\nstatic int\r\nnvkm_client_ntfy(const void *header, u32 length, const void *data, u32 size)\r\n{\r\nconst union {\r\nstruct nvif_notify_req_v0 v0;\r\n} *args = header;\r\nu8 route;\r\nif (length == sizeof(args->v0) && args->v0.version == 0) {\r\nroute = args->v0.route;\r\n} else {\r\nWARN_ON(1);\r\nreturn NVKM_NOTIFY_DROP;\r\n}\r\nswitch (route) {\r\ncase NVDRM_NOTIFY_NVIF:\r\nreturn nvif_notify(header, length, data, size);\r\ncase NVDRM_NOTIFY_USIF:\r\nreturn usif_notify(header, length, data, size);\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\nreturn NVKM_NOTIFY_DROP;\r\n}\r\nstatic int\r\nnvkm_client_driver_init(const char *name, u64 device, const char *cfg,\r\nconst char *dbg, void **ppriv)\r\n{\r\nstruct nvkm_client *client;\r\nint ret;\r\nret = nvkm_client_new(name, device, cfg, dbg, &client);\r\n*ppriv = client;\r\nif (ret)\r\nreturn ret;\r\nclient->ntfy = nvkm_client_ntfy;\r\nreturn 0;\r\n}
