void ipvlan_adjust_mtu(struct ipvl_dev *ipvlan, struct net_device *dev)\r\n{\r\nipvlan->dev->mtu = dev->mtu - ipvlan->mtu_adj;\r\n}\r\nvoid ipvlan_set_port_mode(struct ipvl_port *port, u32 nval)\r\n{\r\nstruct ipvl_dev *ipvlan;\r\nif (port->mode != nval) {\r\nlist_for_each_entry(ipvlan, &port->ipvlans, pnode) {\r\nif (nval == IPVLAN_MODE_L3)\r\nipvlan->dev->flags |= IFF_NOARP;\r\nelse\r\nipvlan->dev->flags &= ~IFF_NOARP;\r\n}\r\nport->mode = nval;\r\n}\r\n}\r\nstatic int ipvlan_port_create(struct net_device *dev)\r\n{\r\nstruct ipvl_port *port;\r\nint err, idx;\r\nif (dev->type != ARPHRD_ETHER || dev->flags & IFF_LOOPBACK) {\r\nnetdev_err(dev, "Master is either lo or non-ether device\n");\r\nreturn -EINVAL;\r\n}\r\nif (netif_is_macvlan_port(dev)) {\r\nnetdev_err(dev, "Master is a macvlan port.\n");\r\nreturn -EBUSY;\r\n}\r\nport = kzalloc(sizeof(struct ipvl_port), GFP_KERNEL);\r\nif (!port)\r\nreturn -ENOMEM;\r\nport->dev = dev;\r\nport->mode = IPVLAN_MODE_L3;\r\nINIT_LIST_HEAD(&port->ipvlans);\r\nfor (idx = 0; idx < IPVLAN_HASH_SIZE; idx++)\r\nINIT_HLIST_HEAD(&port->hlhead[idx]);\r\nskb_queue_head_init(&port->backlog);\r\nINIT_WORK(&port->wq, ipvlan_process_multicast);\r\nerr = netdev_rx_handler_register(dev, ipvlan_handle_frame, port);\r\nif (err)\r\ngoto err;\r\ndev->priv_flags |= IFF_IPVLAN_MASTER;\r\nreturn 0;\r\nerr:\r\nkfree_rcu(port, rcu);\r\nreturn err;\r\n}\r\nstatic void ipvlan_port_destroy(struct net_device *dev)\r\n{\r\nstruct ipvl_port *port = ipvlan_port_get_rtnl(dev);\r\ndev->priv_flags &= ~IFF_IPVLAN_MASTER;\r\nnetdev_rx_handler_unregister(dev);\r\ncancel_work_sync(&port->wq);\r\n__skb_queue_purge(&port->backlog);\r\nkfree_rcu(port, rcu);\r\n}\r\nstatic void ipvlan_set_lockdep_class_one(struct net_device *dev,\r\nstruct netdev_queue *txq,\r\nvoid *_unused)\r\n{\r\nlockdep_set_class(&txq->_xmit_lock, &ipvlan_netdev_xmit_lock_key);\r\n}\r\nstatic void ipvlan_set_lockdep_class(struct net_device *dev)\r\n{\r\nlockdep_set_class(&dev->addr_list_lock, &ipvlan_netdev_addr_lock_key);\r\nnetdev_for_each_tx_queue(dev, ipvlan_set_lockdep_class_one, NULL);\r\n}\r\nstatic int ipvlan_init(struct net_device *dev)\r\n{\r\nstruct ipvl_dev *ipvlan = netdev_priv(dev);\r\nconst struct net_device *phy_dev = ipvlan->phy_dev;\r\ndev->state = (dev->state & ~IPVLAN_STATE_MASK) |\r\n(phy_dev->state & IPVLAN_STATE_MASK);\r\ndev->features = phy_dev->features & IPVLAN_FEATURES;\r\ndev->features |= NETIF_F_LLTX;\r\ndev->gso_max_size = phy_dev->gso_max_size;\r\ndev->hard_header_len = phy_dev->hard_header_len;\r\nipvlan_set_lockdep_class(dev);\r\nipvlan->pcpu_stats = alloc_percpu(struct ipvl_pcpu_stats);\r\nif (!ipvlan->pcpu_stats)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void ipvlan_uninit(struct net_device *dev)\r\n{\r\nstruct ipvl_dev *ipvlan = netdev_priv(dev);\r\nstruct ipvl_port *port = ipvlan->port;\r\nfree_percpu(ipvlan->pcpu_stats);\r\nport->count -= 1;\r\nif (!port->count)\r\nipvlan_port_destroy(port->dev);\r\n}\r\nstatic int ipvlan_open(struct net_device *dev)\r\n{\r\nstruct ipvl_dev *ipvlan = netdev_priv(dev);\r\nstruct net_device *phy_dev = ipvlan->phy_dev;\r\nstruct ipvl_addr *addr;\r\nif (ipvlan->port->mode == IPVLAN_MODE_L3)\r\ndev->flags |= IFF_NOARP;\r\nelse\r\ndev->flags &= ~IFF_NOARP;\r\nlist_for_each_entry(addr, &ipvlan->addrs, anode)\r\nipvlan_ht_addr_add(ipvlan, addr);\r\nreturn dev_uc_add(phy_dev, phy_dev->dev_addr);\r\n}\r\nstatic int ipvlan_stop(struct net_device *dev)\r\n{\r\nstruct ipvl_dev *ipvlan = netdev_priv(dev);\r\nstruct net_device *phy_dev = ipvlan->phy_dev;\r\nstruct ipvl_addr *addr;\r\ndev_uc_unsync(phy_dev, dev);\r\ndev_mc_unsync(phy_dev, dev);\r\ndev_uc_del(phy_dev, phy_dev->dev_addr);\r\nlist_for_each_entry(addr, &ipvlan->addrs, anode)\r\nipvlan_ht_addr_del(addr);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t ipvlan_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nconst struct ipvl_dev *ipvlan = netdev_priv(dev);\r\nint skblen = skb->len;\r\nint ret;\r\nret = ipvlan_queue_xmit(skb, dev);\r\nif (likely(ret == NET_XMIT_SUCCESS || ret == NET_XMIT_CN)) {\r\nstruct ipvl_pcpu_stats *pcptr;\r\npcptr = this_cpu_ptr(ipvlan->pcpu_stats);\r\nu64_stats_update_begin(&pcptr->syncp);\r\npcptr->tx_pkts++;\r\npcptr->tx_bytes += skblen;\r\nu64_stats_update_end(&pcptr->syncp);\r\n} else {\r\nthis_cpu_inc(ipvlan->pcpu_stats->tx_drps);\r\n}\r\nreturn ret;\r\n}\r\nstatic netdev_features_t ipvlan_fix_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nstruct ipvl_dev *ipvlan = netdev_priv(dev);\r\nreturn features & (ipvlan->sfeatures | ~IPVLAN_FEATURES);\r\n}\r\nstatic void ipvlan_change_rx_flags(struct net_device *dev, int change)\r\n{\r\nstruct ipvl_dev *ipvlan = netdev_priv(dev);\r\nstruct net_device *phy_dev = ipvlan->phy_dev;\r\nif (change & IFF_ALLMULTI)\r\ndev_set_allmulti(phy_dev, dev->flags & IFF_ALLMULTI? 1 : -1);\r\n}\r\nstatic void ipvlan_set_multicast_mac_filter(struct net_device *dev)\r\n{\r\nstruct ipvl_dev *ipvlan = netdev_priv(dev);\r\nif (dev->flags & (IFF_PROMISC | IFF_ALLMULTI)) {\r\nbitmap_fill(ipvlan->mac_filters, IPVLAN_MAC_FILTER_SIZE);\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nDECLARE_BITMAP(mc_filters, IPVLAN_MAC_FILTER_SIZE);\r\nbitmap_zero(mc_filters, IPVLAN_MAC_FILTER_SIZE);\r\nnetdev_for_each_mc_addr(ha, dev)\r\n__set_bit(ipvlan_mac_hash(ha->addr), mc_filters);\r\n__set_bit(ipvlan_mac_hash(dev->broadcast), mc_filters);\r\nbitmap_copy(ipvlan->mac_filters, mc_filters,\r\nIPVLAN_MAC_FILTER_SIZE);\r\n}\r\ndev_uc_sync(ipvlan->phy_dev, dev);\r\ndev_mc_sync(ipvlan->phy_dev, dev);\r\n}\r\nstatic struct rtnl_link_stats64 *ipvlan_get_stats64(struct net_device *dev,\r\nstruct rtnl_link_stats64 *s)\r\n{\r\nstruct ipvl_dev *ipvlan = netdev_priv(dev);\r\nif (ipvlan->pcpu_stats) {\r\nstruct ipvl_pcpu_stats *pcptr;\r\nu64 rx_pkts, rx_bytes, rx_mcast, tx_pkts, tx_bytes;\r\nu32 rx_errs = 0, tx_drps = 0;\r\nu32 strt;\r\nint idx;\r\nfor_each_possible_cpu(idx) {\r\npcptr = per_cpu_ptr(ipvlan->pcpu_stats, idx);\r\ndo {\r\nstrt= u64_stats_fetch_begin_irq(&pcptr->syncp);\r\nrx_pkts = pcptr->rx_pkts;\r\nrx_bytes = pcptr->rx_bytes;\r\nrx_mcast = pcptr->rx_mcast;\r\ntx_pkts = pcptr->tx_pkts;\r\ntx_bytes = pcptr->tx_bytes;\r\n} while (u64_stats_fetch_retry_irq(&pcptr->syncp,\r\nstrt));\r\ns->rx_packets += rx_pkts;\r\ns->rx_bytes += rx_bytes;\r\ns->multicast += rx_mcast;\r\ns->tx_packets += tx_pkts;\r\ns->tx_bytes += tx_bytes;\r\nrx_errs += pcptr->rx_errs;\r\ntx_drps += pcptr->tx_drps;\r\n}\r\ns->rx_errors = rx_errs;\r\ns->rx_dropped = rx_errs;\r\ns->tx_dropped = tx_drps;\r\n}\r\nreturn s;\r\n}\r\nstatic int ipvlan_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid)\r\n{\r\nstruct ipvl_dev *ipvlan = netdev_priv(dev);\r\nstruct net_device *phy_dev = ipvlan->phy_dev;\r\nreturn vlan_vid_add(phy_dev, proto, vid);\r\n}\r\nstatic int ipvlan_vlan_rx_kill_vid(struct net_device *dev, __be16 proto,\r\nu16 vid)\r\n{\r\nstruct ipvl_dev *ipvlan = netdev_priv(dev);\r\nstruct net_device *phy_dev = ipvlan->phy_dev;\r\nvlan_vid_del(phy_dev, proto, vid);\r\nreturn 0;\r\n}\r\nstatic int ipvlan_get_iflink(const struct net_device *dev)\r\n{\r\nstruct ipvl_dev *ipvlan = netdev_priv(dev);\r\nreturn ipvlan->phy_dev->ifindex;\r\n}\r\nstatic int ipvlan_hard_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type, const void *daddr,\r\nconst void *saddr, unsigned len)\r\n{\r\nconst struct ipvl_dev *ipvlan = netdev_priv(dev);\r\nstruct net_device *phy_dev = ipvlan->phy_dev;\r\nreturn dev_hard_header(skb, phy_dev, type, daddr,\r\nsaddr ? : dev->dev_addr, len);\r\n}\r\nstatic int ipvlan_ethtool_get_settings(struct net_device *dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nconst struct ipvl_dev *ipvlan = netdev_priv(dev);\r\nreturn __ethtool_get_settings(ipvlan->phy_dev, cmd);\r\n}\r\nstatic void ipvlan_ethtool_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstrlcpy(drvinfo->driver, IPVLAN_DRV, sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, IPV_DRV_VER, sizeof(drvinfo->version));\r\n}\r\nstatic u32 ipvlan_ethtool_get_msglevel(struct net_device *dev)\r\n{\r\nconst struct ipvl_dev *ipvlan = netdev_priv(dev);\r\nreturn ipvlan->msg_enable;\r\n}\r\nstatic void ipvlan_ethtool_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\nstruct ipvl_dev *ipvlan = netdev_priv(dev);\r\nipvlan->msg_enable = value;\r\n}\r\nstatic int ipvlan_nl_changelink(struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nstruct ipvl_dev *ipvlan = netdev_priv(dev);\r\nstruct ipvl_port *port = ipvlan_port_get_rtnl(ipvlan->phy_dev);\r\nif (data && data[IFLA_IPVLAN_MODE]) {\r\nu16 nmode = nla_get_u16(data[IFLA_IPVLAN_MODE]);\r\nipvlan_set_port_mode(port, nmode);\r\n}\r\nreturn 0;\r\n}\r\nstatic size_t ipvlan_nl_getsize(const struct net_device *dev)\r\n{\r\nreturn (0\r\n+ nla_total_size(2)\r\n);\r\n}\r\nstatic int ipvlan_nl_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\nif (data && data[IFLA_IPVLAN_MODE]) {\r\nu16 mode = nla_get_u16(data[IFLA_IPVLAN_MODE]);\r\nif (mode < IPVLAN_MODE_L2 || mode >= IPVLAN_MODE_MAX)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipvlan_nl_fillinfo(struct sk_buff *skb,\r\nconst struct net_device *dev)\r\n{\r\nstruct ipvl_dev *ipvlan = netdev_priv(dev);\r\nstruct ipvl_port *port = ipvlan_port_get_rtnl(ipvlan->phy_dev);\r\nint ret = -EINVAL;\r\nif (!port)\r\ngoto err;\r\nret = -EMSGSIZE;\r\nif (nla_put_u16(skb, IFLA_IPVLAN_MODE, port->mode))\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int ipvlan_link_new(struct net *src_net, struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nstruct ipvl_dev *ipvlan = netdev_priv(dev);\r\nstruct ipvl_port *port;\r\nstruct net_device *phy_dev;\r\nint err;\r\nif (!tb[IFLA_LINK])\r\nreturn -EINVAL;\r\nphy_dev = __dev_get_by_index(src_net, nla_get_u32(tb[IFLA_LINK]));\r\nif (!phy_dev)\r\nreturn -ENODEV;\r\nif (netif_is_ipvlan(phy_dev)) {\r\nstruct ipvl_dev *tmp = netdev_priv(phy_dev);\r\nphy_dev = tmp->phy_dev;\r\n} else if (!netif_is_ipvlan_port(phy_dev)) {\r\nerr = ipvlan_port_create(phy_dev);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nport = ipvlan_port_get_rtnl(phy_dev);\r\nif (data && data[IFLA_IPVLAN_MODE])\r\nport->mode = nla_get_u16(data[IFLA_IPVLAN_MODE]);\r\nipvlan->phy_dev = phy_dev;\r\nipvlan->dev = dev;\r\nipvlan->port = port;\r\nipvlan->sfeatures = IPVLAN_FEATURES;\r\nINIT_LIST_HEAD(&ipvlan->addrs);\r\nmemcpy(dev->dev_addr, phy_dev->dev_addr, ETH_ALEN);\r\ndev->priv_flags |= IFF_IPVLAN_SLAVE;\r\nport->count += 1;\r\nerr = register_netdevice(dev);\r\nif (err < 0)\r\ngoto ipvlan_destroy_port;\r\nerr = netdev_upper_dev_link(phy_dev, dev);\r\nif (err)\r\ngoto ipvlan_destroy_port;\r\nlist_add_tail_rcu(&ipvlan->pnode, &port->ipvlans);\r\nnetif_stacked_transfer_operstate(phy_dev, dev);\r\nreturn 0;\r\nipvlan_destroy_port:\r\nport->count -= 1;\r\nif (!port->count)\r\nipvlan_port_destroy(phy_dev);\r\nreturn err;\r\n}\r\nstatic void ipvlan_link_delete(struct net_device *dev, struct list_head *head)\r\n{\r\nstruct ipvl_dev *ipvlan = netdev_priv(dev);\r\nstruct ipvl_addr *addr, *next;\r\nlist_for_each_entry_safe(addr, next, &ipvlan->addrs, anode) {\r\nipvlan_ht_addr_del(addr);\r\nlist_del(&addr->anode);\r\nkfree_rcu(addr, rcu);\r\n}\r\nlist_del_rcu(&ipvlan->pnode);\r\nunregister_netdevice_queue(dev, head);\r\nnetdev_upper_dev_unlink(ipvlan->phy_dev, dev);\r\n}\r\nstatic void ipvlan_link_setup(struct net_device *dev)\r\n{\r\nether_setup(dev);\r\ndev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\r\ndev->priv_flags |= IFF_UNICAST_FLT | IFF_NO_QUEUE;\r\ndev->netdev_ops = &ipvlan_netdev_ops;\r\ndev->destructor = free_netdev;\r\ndev->header_ops = &ipvlan_header_ops;\r\ndev->ethtool_ops = &ipvlan_ethtool_ops;\r\n}\r\nstatic int ipvlan_link_register(struct rtnl_link_ops *ops)\r\n{\r\nreturn rtnl_link_register(ops);\r\n}\r\nstatic int ipvlan_device_event(struct notifier_block *unused,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct ipvl_dev *ipvlan, *next;\r\nstruct ipvl_port *port;\r\nLIST_HEAD(lst_kill);\r\nif (!netif_is_ipvlan_port(dev))\r\nreturn NOTIFY_DONE;\r\nport = ipvlan_port_get_rtnl(dev);\r\nswitch (event) {\r\ncase NETDEV_CHANGE:\r\nlist_for_each_entry(ipvlan, &port->ipvlans, pnode)\r\nnetif_stacked_transfer_operstate(ipvlan->phy_dev,\r\nipvlan->dev);\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nif (dev->reg_state != NETREG_UNREGISTERING)\r\nbreak;\r\nlist_for_each_entry_safe(ipvlan, next, &port->ipvlans,\r\npnode)\r\nipvlan->dev->rtnl_link_ops->dellink(ipvlan->dev,\r\n&lst_kill);\r\nunregister_netdevice_many(&lst_kill);\r\nbreak;\r\ncase NETDEV_FEAT_CHANGE:\r\nlist_for_each_entry(ipvlan, &port->ipvlans, pnode) {\r\nipvlan->dev->features = dev->features & IPVLAN_FEATURES;\r\nipvlan->dev->gso_max_size = dev->gso_max_size;\r\nnetdev_features_change(ipvlan->dev);\r\n}\r\nbreak;\r\ncase NETDEV_CHANGEMTU:\r\nlist_for_each_entry(ipvlan, &port->ipvlans, pnode)\r\nipvlan_adjust_mtu(ipvlan, dev);\r\nbreak;\r\ncase NETDEV_PRE_TYPE_CHANGE:\r\nreturn NOTIFY_BAD;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int ipvlan_add_addr6(struct ipvl_dev *ipvlan, struct in6_addr *ip6_addr)\r\n{\r\nstruct ipvl_addr *addr;\r\nif (ipvlan_addr_busy(ipvlan->port, ip6_addr, true)) {\r\nnetif_err(ipvlan, ifup, ipvlan->dev,\r\n"Failed to add IPv6=%pI6c addr for %s intf\n",\r\nip6_addr, ipvlan->dev->name);\r\nreturn -EINVAL;\r\n}\r\naddr = kzalloc(sizeof(struct ipvl_addr), GFP_ATOMIC);\r\nif (!addr)\r\nreturn -ENOMEM;\r\naddr->master = ipvlan;\r\nmemcpy(&addr->ip6addr, ip6_addr, sizeof(struct in6_addr));\r\naddr->atype = IPVL_IPV6;\r\nlist_add_tail(&addr->anode, &ipvlan->addrs);\r\nif (netif_running(ipvlan->dev))\r\nipvlan_ht_addr_add(ipvlan, addr);\r\nreturn 0;\r\n}\r\nstatic void ipvlan_del_addr6(struct ipvl_dev *ipvlan, struct in6_addr *ip6_addr)\r\n{\r\nstruct ipvl_addr *addr;\r\naddr = ipvlan_find_addr(ipvlan, ip6_addr, true);\r\nif (!addr)\r\nreturn;\r\nipvlan_ht_addr_del(addr);\r\nlist_del(&addr->anode);\r\nkfree_rcu(addr, rcu);\r\nreturn;\r\n}\r\nstatic int ipvlan_addr6_event(struct notifier_block *unused,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct inet6_ifaddr *if6 = (struct inet6_ifaddr *)ptr;\r\nstruct net_device *dev = (struct net_device *)if6->idev->dev;\r\nstruct ipvl_dev *ipvlan = netdev_priv(dev);\r\nif (in_softirq())\r\nreturn NOTIFY_DONE;\r\nif (!netif_is_ipvlan(dev))\r\nreturn NOTIFY_DONE;\r\nif (!ipvlan || !ipvlan->port)\r\nreturn NOTIFY_DONE;\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nif (ipvlan_add_addr6(ipvlan, &if6->addr))\r\nreturn NOTIFY_BAD;\r\nbreak;\r\ncase NETDEV_DOWN:\r\nipvlan_del_addr6(ipvlan, &if6->addr);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int ipvlan_add_addr4(struct ipvl_dev *ipvlan, struct in_addr *ip4_addr)\r\n{\r\nstruct ipvl_addr *addr;\r\nif (ipvlan_addr_busy(ipvlan->port, ip4_addr, false)) {\r\nnetif_err(ipvlan, ifup, ipvlan->dev,\r\n"Failed to add IPv4=%pI4 on %s intf.\n",\r\nip4_addr, ipvlan->dev->name);\r\nreturn -EINVAL;\r\n}\r\naddr = kzalloc(sizeof(struct ipvl_addr), GFP_KERNEL);\r\nif (!addr)\r\nreturn -ENOMEM;\r\naddr->master = ipvlan;\r\nmemcpy(&addr->ip4addr, ip4_addr, sizeof(struct in_addr));\r\naddr->atype = IPVL_IPV4;\r\nlist_add_tail(&addr->anode, &ipvlan->addrs);\r\nif (netif_running(ipvlan->dev))\r\nipvlan_ht_addr_add(ipvlan, addr);\r\nreturn 0;\r\n}\r\nstatic void ipvlan_del_addr4(struct ipvl_dev *ipvlan, struct in_addr *ip4_addr)\r\n{\r\nstruct ipvl_addr *addr;\r\naddr = ipvlan_find_addr(ipvlan, ip4_addr, false);\r\nif (!addr)\r\nreturn;\r\nipvlan_ht_addr_del(addr);\r\nlist_del(&addr->anode);\r\nkfree_rcu(addr, rcu);\r\nreturn;\r\n}\r\nstatic int ipvlan_addr4_event(struct notifier_block *unused,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct in_ifaddr *if4 = (struct in_ifaddr *)ptr;\r\nstruct net_device *dev = (struct net_device *)if4->ifa_dev->dev;\r\nstruct ipvl_dev *ipvlan = netdev_priv(dev);\r\nstruct in_addr ip4_addr;\r\nif (!netif_is_ipvlan(dev))\r\nreturn NOTIFY_DONE;\r\nif (!ipvlan || !ipvlan->port)\r\nreturn NOTIFY_DONE;\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nip4_addr.s_addr = if4->ifa_address;\r\nif (ipvlan_add_addr4(ipvlan, &ip4_addr))\r\nreturn NOTIFY_BAD;\r\nbreak;\r\ncase NETDEV_DOWN:\r\nip4_addr.s_addr = if4->ifa_address;\r\nipvlan_del_addr4(ipvlan, &ip4_addr);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init ipvlan_init_module(void)\r\n{\r\nint err;\r\nipvlan_init_secret();\r\nregister_netdevice_notifier(&ipvlan_notifier_block);\r\nregister_inet6addr_notifier(&ipvlan_addr6_notifier_block);\r\nregister_inetaddr_notifier(&ipvlan_addr4_notifier_block);\r\nerr = ipvlan_link_register(&ipvlan_link_ops);\r\nif (err < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nunregister_inetaddr_notifier(&ipvlan_addr4_notifier_block);\r\nunregister_inet6addr_notifier(&ipvlan_addr6_notifier_block);\r\nunregister_netdevice_notifier(&ipvlan_notifier_block);\r\nreturn err;\r\n}\r\nstatic void __exit ipvlan_cleanup_module(void)\r\n{\r\nrtnl_link_unregister(&ipvlan_link_ops);\r\nunregister_netdevice_notifier(&ipvlan_notifier_block);\r\nunregister_inetaddr_notifier(&ipvlan_addr4_notifier_block);\r\nunregister_inet6addr_notifier(&ipvlan_addr6_notifier_block);\r\n}
