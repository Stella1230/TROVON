int dss_pll_register(struct dss_pll *pll)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(dss_plls); ++i) {\r\nif (!dss_plls[i]) {\r\ndss_plls[i] = pll;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EBUSY;\r\n}\r\nvoid dss_pll_unregister(struct dss_pll *pll)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(dss_plls); ++i) {\r\nif (dss_plls[i] == pll) {\r\ndss_plls[i] = NULL;\r\nreturn;\r\n}\r\n}\r\n}\r\nstruct dss_pll *dss_pll_find(const char *name)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(dss_plls); ++i) {\r\nif (dss_plls[i] && strcmp(dss_plls[i]->name, name) == 0)\r\nreturn dss_plls[i];\r\n}\r\nreturn NULL;\r\n}\r\nint dss_pll_enable(struct dss_pll *pll)\r\n{\r\nint r;\r\nr = clk_prepare_enable(pll->clkin);\r\nif (r)\r\nreturn r;\r\nif (pll->regulator) {\r\nr = regulator_enable(pll->regulator);\r\nif (r)\r\ngoto err_reg;\r\n}\r\nr = pll->ops->enable(pll);\r\nif (r)\r\ngoto err_enable;\r\nreturn 0;\r\nerr_enable:\r\nif (pll->regulator)\r\nregulator_disable(pll->regulator);\r\nerr_reg:\r\nclk_disable_unprepare(pll->clkin);\r\nreturn r;\r\n}\r\nvoid dss_pll_disable(struct dss_pll *pll)\r\n{\r\npll->ops->disable(pll);\r\nif (pll->regulator)\r\nregulator_disable(pll->regulator);\r\nclk_disable_unprepare(pll->clkin);\r\nmemset(&pll->cinfo, 0, sizeof(pll->cinfo));\r\n}\r\nint dss_pll_set_config(struct dss_pll *pll, const struct dss_pll_clock_info *cinfo)\r\n{\r\nint r;\r\nr = pll->ops->set_config(pll, cinfo);\r\nif (r)\r\nreturn r;\r\npll->cinfo = *cinfo;\r\nreturn 0;\r\n}\r\nbool dss_pll_hsdiv_calc(const struct dss_pll *pll, unsigned long clkdco,\r\nunsigned long out_min, unsigned long out_max,\r\ndss_hsdiv_calc_func func, void *data)\r\n{\r\nconst struct dss_pll_hw *hw = pll->hw;\r\nint m, m_start, m_stop;\r\nunsigned long out;\r\nout_min = out_min ? out_min : 1;\r\nout_max = out_max ? out_max : ULONG_MAX;\r\nm_start = max(DIV_ROUND_UP(clkdco, out_max), 1ul);\r\nm_stop = min((unsigned)(clkdco / out_min), hw->mX_max);\r\nfor (m = m_start; m <= m_stop; ++m) {\r\nout = clkdco / m;\r\nif (func(m, out, data))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nbool dss_pll_calc(const struct dss_pll *pll, unsigned long clkin,\r\nunsigned long pll_min, unsigned long pll_max,\r\ndss_pll_calc_func func, void *data)\r\n{\r\nconst struct dss_pll_hw *hw = pll->hw;\r\nint n, n_start, n_stop;\r\nint m, m_start, m_stop;\r\nunsigned long fint, clkdco;\r\nunsigned long pll_hw_max;\r\nunsigned long fint_hw_min, fint_hw_max;\r\npll_hw_max = hw->clkdco_max;\r\nfint_hw_min = hw->fint_min;\r\nfint_hw_max = hw->fint_max;\r\nn_start = max(DIV_ROUND_UP(clkin, fint_hw_max), 1ul);\r\nn_stop = min((unsigned)(clkin / fint_hw_min), hw->n_max);\r\npll_max = pll_max ? pll_max : ULONG_MAX;\r\nfor (n = n_start; n <= n_stop; ++n) {\r\nfint = clkin / n;\r\nm_start = max(DIV_ROUND_UP(DIV_ROUND_UP(pll_min, fint), 2),\r\n1ul);\r\nm_stop = min3((unsigned)(pll_max / fint / 2),\r\n(unsigned)(pll_hw_max / fint / 2),\r\nhw->m_max);\r\nfor (m = m_start; m <= m_stop; ++m) {\r\nclkdco = 2 * m * fint;\r\nif (func(n, m, fint, clkdco, data))\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic int wait_for_bit_change(void __iomem *reg, int bitnum, int value)\r\n{\r\nunsigned long timeout;\r\nktime_t wait;\r\nint t;\r\nt = 100;\r\nwhile (t-- > 0) {\r\nif (FLD_GET(readl_relaxed(reg), bitnum, bitnum) == value)\r\nreturn value;\r\n}\r\ntimeout = jiffies + msecs_to_jiffies(500);\r\nwhile (time_before(jiffies, timeout)) {\r\nif (FLD_GET(readl_relaxed(reg), bitnum, bitnum) == value)\r\nreturn value;\r\nwait = ns_to_ktime(1000 * 1000);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_hrtimeout(&wait, HRTIMER_MODE_REL);\r\n}\r\nreturn !value;\r\n}\r\nint dss_pll_wait_reset_done(struct dss_pll *pll)\r\n{\r\nvoid __iomem *base = pll->base;\r\nif (wait_for_bit_change(base + PLL_STATUS, 0, 1) != 1)\r\nreturn -ETIMEDOUT;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int dss_wait_hsdiv_ack(struct dss_pll *pll, u32 hsdiv_ack_mask)\r\n{\r\nint t = 100;\r\nwhile (t-- > 0) {\r\nu32 v = readl_relaxed(pll->base + PLL_STATUS);\r\nv &= hsdiv_ack_mask;\r\nif (v == hsdiv_ack_mask)\r\nreturn 0;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nint dss_pll_write_config_type_a(struct dss_pll *pll,\r\nconst struct dss_pll_clock_info *cinfo)\r\n{\r\nconst struct dss_pll_hw *hw = pll->hw;\r\nvoid __iomem *base = pll->base;\r\nint r = 0;\r\nu32 l;\r\nl = 0;\r\nif (hw->has_stopmode)\r\nl = FLD_MOD(l, 1, 0, 0);\r\nl = FLD_MOD(l, cinfo->n - 1, hw->n_msb, hw->n_lsb);\r\nl = FLD_MOD(l, cinfo->m, hw->m_msb, hw->m_lsb);\r\nl = FLD_MOD(l, cinfo->mX[0] ? cinfo->mX[0] - 1 : 0,\r\nhw->mX_msb[0], hw->mX_lsb[0]);\r\nl = FLD_MOD(l, cinfo->mX[1] ? cinfo->mX[1] - 1 : 0,\r\nhw->mX_msb[1], hw->mX_lsb[1]);\r\nwritel_relaxed(l, base + PLL_CONFIGURATION1);\r\nl = 0;\r\nl = FLD_MOD(l, cinfo->mX[2] ? cinfo->mX[2] - 1 : 0,\r\nhw->mX_msb[2], hw->mX_lsb[2]);\r\nl = FLD_MOD(l, cinfo->mX[3] ? cinfo->mX[3] - 1 : 0,\r\nhw->mX_msb[3], hw->mX_lsb[3]);\r\nwritel_relaxed(l, base + PLL_CONFIGURATION3);\r\nl = readl_relaxed(base + PLL_CONFIGURATION2);\r\nif (hw->has_freqsel) {\r\nu32 f = cinfo->fint < 1000000 ? 0x3 :\r\ncinfo->fint < 1250000 ? 0x4 :\r\ncinfo->fint < 1500000 ? 0x5 :\r\ncinfo->fint < 1750000 ? 0x6 :\r\n0x7;\r\nl = FLD_MOD(l, f, 4, 1);\r\n} else if (hw->has_selfreqdco) {\r\nu32 f = cinfo->clkdco < hw->clkdco_low ? 0x2 : 0x4;\r\nl = FLD_MOD(l, f, 3, 1);\r\n}\r\nl = FLD_MOD(l, 1, 13, 13);\r\nl = FLD_MOD(l, 0, 14, 14);\r\nl = FLD_MOD(l, 0, 16, 16);\r\nl = FLD_MOD(l, 0, 18, 18);\r\nl = FLD_MOD(l, 1, 20, 20);\r\nif (hw->has_refsel)\r\nl = FLD_MOD(l, 3, 22, 21);\r\nl = FLD_MOD(l, 0, 23, 23);\r\nl = FLD_MOD(l, 0, 25, 25);\r\nwritel_relaxed(l, base + PLL_CONFIGURATION2);\r\nwritel_relaxed(1, base + PLL_GO);\r\nif (wait_for_bit_change(base + PLL_GO, 0, 0) != 0) {\r\nDSSERR("DSS DPLL GO bit not going down.\n");\r\nr = -EIO;\r\ngoto err;\r\n}\r\nif (wait_for_bit_change(base + PLL_STATUS, 1, 1) != 1) {\r\nDSSERR("cannot lock DSS DPLL\n");\r\nr = -EIO;\r\ngoto err;\r\n}\r\nl = readl_relaxed(base + PLL_CONFIGURATION2);\r\nl = FLD_MOD(l, 1, 14, 14);\r\nl = FLD_MOD(l, cinfo->mX[0] ? 1 : 0, 16, 16);\r\nl = FLD_MOD(l, cinfo->mX[1] ? 1 : 0, 18, 18);\r\nl = FLD_MOD(l, 0, 20, 20);\r\nl = FLD_MOD(l, cinfo->mX[2] ? 1 : 0, 23, 23);\r\nl = FLD_MOD(l, cinfo->mX[3] ? 1 : 0, 25, 25);\r\nwritel_relaxed(l, base + PLL_CONFIGURATION2);\r\nr = dss_wait_hsdiv_ack(pll,\r\n(cinfo->mX[0] ? BIT(7) : 0) |\r\n(cinfo->mX[1] ? BIT(8) : 0) |\r\n(cinfo->mX[2] ? BIT(10) : 0) |\r\n(cinfo->mX[3] ? BIT(11) : 0));\r\nif (r) {\r\nDSSERR("failed to enable HSDIV clocks\n");\r\ngoto err;\r\n}\r\nerr:\r\nreturn r;\r\n}\r\nint dss_pll_write_config_type_b(struct dss_pll *pll,\r\nconst struct dss_pll_clock_info *cinfo)\r\n{\r\nconst struct dss_pll_hw *hw = pll->hw;\r\nvoid __iomem *base = pll->base;\r\nu32 l;\r\nl = 0;\r\nl = FLD_MOD(l, cinfo->m, 20, 9);\r\nl = FLD_MOD(l, cinfo->n - 1, 8, 1);\r\nwritel_relaxed(l, base + PLL_CONFIGURATION1);\r\nl = readl_relaxed(base + PLL_CONFIGURATION2);\r\nl = FLD_MOD(l, 0x0, 12, 12);\r\nl = FLD_MOD(l, 0x1, 13, 13);\r\nl = FLD_MOD(l, 0x0, 14, 14);\r\nif (hw->has_refsel)\r\nl = FLD_MOD(l, 0x3, 22, 21);\r\nif (cinfo->clkdco > hw->clkdco_low)\r\nl = FLD_MOD(l, 0x4, 3, 1);\r\nelse\r\nl = FLD_MOD(l, 0x2, 3, 1);\r\nwritel_relaxed(l, base + PLL_CONFIGURATION2);\r\nl = readl_relaxed(base + PLL_CONFIGURATION3);\r\nl = FLD_MOD(l, cinfo->sd, 17, 10);\r\nwritel_relaxed(l, base + PLL_CONFIGURATION3);\r\nl = readl_relaxed(base + PLL_CONFIGURATION4);\r\nl = FLD_MOD(l, cinfo->mX[0], 24, 18);\r\nl = FLD_MOD(l, cinfo->mf, 17, 0);\r\nwritel_relaxed(l, base + PLL_CONFIGURATION4);\r\nwritel_relaxed(1, base + PLL_GO);\r\nif (wait_for_bit_change(base + PLL_GO, 0, 0) != 0) {\r\nDSSERR("DSS DPLL GO bit not going down.\n");\r\nreturn -EIO;\r\n}\r\nif (wait_for_bit_change(base + PLL_STATUS, 1, 1) != 1) {\r\nDSSERR("cannot lock DSS DPLL\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}
