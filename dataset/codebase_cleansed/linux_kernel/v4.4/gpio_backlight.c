static int gpio_backlight_update_status(struct backlight_device *bl)\r\n{\r\nstruct gpio_backlight *gbl = bl_get_data(bl);\r\nint brightness = bl->props.brightness;\r\nif (bl->props.power != FB_BLANK_UNBLANK ||\r\nbl->props.fb_blank != FB_BLANK_UNBLANK ||\r\nbl->props.state & (BL_CORE_SUSPENDED | BL_CORE_FBBLANK))\r\nbrightness = 0;\r\ngpio_set_value_cansleep(gbl->gpio,\r\nbrightness ? gbl->active : !gbl->active);\r\nreturn 0;\r\n}\r\nstatic int gpio_backlight_check_fb(struct backlight_device *bl,\r\nstruct fb_info *info)\r\n{\r\nstruct gpio_backlight *gbl = bl_get_data(bl);\r\nreturn gbl->fbdev == NULL || gbl->fbdev == info->dev;\r\n}\r\nstatic int gpio_backlight_probe_dt(struct platform_device *pdev,\r\nstruct gpio_backlight *gbl)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nenum of_gpio_flags gpio_flags;\r\ngbl->gpio = of_get_gpio_flags(np, 0, &gpio_flags);\r\nif (!gpio_is_valid(gbl->gpio)) {\r\nif (gbl->gpio != -EPROBE_DEFER) {\r\ndev_err(&pdev->dev,\r\n"Error: The gpios parameter is missing or invalid.\n");\r\n}\r\nreturn gbl->gpio;\r\n}\r\ngbl->active = (gpio_flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;\r\ngbl->def_value = of_property_read_bool(np, "default-on");\r\nreturn 0;\r\n}\r\nstatic int gpio_backlight_probe(struct platform_device *pdev)\r\n{\r\nstruct gpio_backlight_platform_data *pdata =\r\ndev_get_platdata(&pdev->dev);\r\nstruct backlight_properties props;\r\nstruct backlight_device *bl;\r\nstruct gpio_backlight *gbl;\r\nstruct device_node *np = pdev->dev.of_node;\r\nint ret;\r\nif (!pdata && !np) {\r\ndev_err(&pdev->dev,\r\n"failed to find platform data or device tree node.\n");\r\nreturn -ENODEV;\r\n}\r\ngbl = devm_kzalloc(&pdev->dev, sizeof(*gbl), GFP_KERNEL);\r\nif (gbl == NULL)\r\nreturn -ENOMEM;\r\ngbl->dev = &pdev->dev;\r\nif (np) {\r\nret = gpio_backlight_probe_dt(pdev, gbl);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\ngbl->fbdev = pdata->fbdev;\r\ngbl->gpio = pdata->gpio;\r\ngbl->active = pdata->active_low ? 0 : 1;\r\ngbl->def_value = pdata->def_value;\r\n}\r\nret = devm_gpio_request_one(gbl->dev, gbl->gpio, GPIOF_DIR_OUT |\r\n(gbl->active ? GPIOF_INIT_LOW\r\n: GPIOF_INIT_HIGH),\r\npdata ? pdata->name : "backlight");\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "unable to request GPIO\n");\r\nreturn ret;\r\n}\r\nmemset(&props, 0, sizeof(props));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = 1;\r\nbl = devm_backlight_device_register(&pdev->dev, dev_name(&pdev->dev),\r\n&pdev->dev, gbl, &gpio_backlight_ops,\r\n&props);\r\nif (IS_ERR(bl)) {\r\ndev_err(&pdev->dev, "failed to register backlight\n");\r\nreturn PTR_ERR(bl);\r\n}\r\nbl->props.brightness = gbl->def_value;\r\nbacklight_update_status(bl);\r\nplatform_set_drvdata(pdev, bl);\r\nreturn 0;\r\n}
