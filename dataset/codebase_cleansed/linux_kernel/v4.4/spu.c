static struct spu_pdata *spu_pdata(struct spu *spu)\r\n{\r\nreturn spu->pdata;\r\n}\r\nstatic void _dump_areas(unsigned int spe_id, unsigned long priv2,\r\nunsigned long problem, unsigned long ls, unsigned long shadow,\r\nconst char* func, int line)\r\n{\r\npr_debug("%s:%d: spe_id: %xh (%u)\n", func, line, spe_id, spe_id);\r\npr_debug("%s:%d: priv2: %lxh\n", func, line, priv2);\r\npr_debug("%s:%d: problem: %lxh\n", func, line, problem);\r\npr_debug("%s:%d: ls: %lxh\n", func, line, ls);\r\npr_debug("%s:%d: shadow: %lxh\n", func, line, shadow);\r\n}\r\nu64 ps3_get_spe_id(void *arg)\r\n{\r\nreturn spu_pdata(arg)->spe_id;\r\n}\r\nstatic unsigned long get_vas_id(void)\r\n{\r\nu64 id;\r\nlv1_get_logical_ppe_id(&id);\r\nlv1_get_virtual_address_space_id_of_ppe(&id);\r\nreturn id;\r\n}\r\nstatic int __init construct_spu(struct spu *spu)\r\n{\r\nint result;\r\nu64 unused;\r\nu64 problem_phys;\r\nu64 local_store_phys;\r\nresult = lv1_construct_logical_spe(PAGE_SHIFT, PAGE_SHIFT, PAGE_SHIFT,\r\nPAGE_SHIFT, PAGE_SHIFT, get_vas_id(), SPE_TYPE_LOGICAL,\r\n&spu_pdata(spu)->priv2_addr, &problem_phys,\r\n&local_store_phys, &unused,\r\n&spu_pdata(spu)->shadow_addr,\r\n&spu_pdata(spu)->spe_id);\r\nspu->problem_phys = problem_phys;\r\nspu->local_store_phys = local_store_phys;\r\nif (result) {\r\npr_debug("%s:%d: lv1_construct_logical_spe failed: %s\n",\r\n__func__, __LINE__, ps3_result(result));\r\nreturn result;\r\n}\r\nreturn result;\r\n}\r\nstatic void spu_unmap(struct spu *spu)\r\n{\r\niounmap(spu->priv2);\r\niounmap(spu->problem);\r\niounmap((__force u8 __iomem *)spu->local_store);\r\niounmap(spu_pdata(spu)->shadow);\r\n}\r\nstatic int __init setup_areas(struct spu *spu)\r\n{\r\nstruct table {char* name; unsigned long addr; unsigned long size;};\r\nstatic const unsigned long shadow_flags = _PAGE_NO_CACHE | 3;\r\nspu_pdata(spu)->shadow = __ioremap(spu_pdata(spu)->shadow_addr,\r\nsizeof(struct spe_shadow),\r\nshadow_flags);\r\nif (!spu_pdata(spu)->shadow) {\r\npr_debug("%s:%d: ioremap shadow failed\n", __func__, __LINE__);\r\ngoto fail_ioremap;\r\n}\r\nspu->local_store = (__force void *)ioremap_prot(spu->local_store_phys,\r\nLS_SIZE, _PAGE_NO_CACHE);\r\nif (!spu->local_store) {\r\npr_debug("%s:%d: ioremap local_store failed\n",\r\n__func__, __LINE__);\r\ngoto fail_ioremap;\r\n}\r\nspu->problem = ioremap(spu->problem_phys,\r\nsizeof(struct spu_problem));\r\nif (!spu->problem) {\r\npr_debug("%s:%d: ioremap problem failed\n", __func__, __LINE__);\r\ngoto fail_ioremap;\r\n}\r\nspu->priv2 = ioremap(spu_pdata(spu)->priv2_addr,\r\nsizeof(struct spu_priv2));\r\nif (!spu->priv2) {\r\npr_debug("%s:%d: ioremap priv2 failed\n", __func__, __LINE__);\r\ngoto fail_ioremap;\r\n}\r\ndump_areas(spu_pdata(spu)->spe_id, spu_pdata(spu)->priv2_addr,\r\nspu->problem_phys, spu->local_store_phys,\r\nspu_pdata(spu)->shadow_addr);\r\ndump_areas(spu_pdata(spu)->spe_id, (unsigned long)spu->priv2,\r\n(unsigned long)spu->problem, (unsigned long)spu->local_store,\r\n(unsigned long)spu_pdata(spu)->shadow);\r\nreturn 0;\r\nfail_ioremap:\r\nspu_unmap(spu);\r\nreturn -ENOMEM;\r\n}\r\nstatic int __init setup_interrupts(struct spu *spu)\r\n{\r\nint result;\r\nresult = ps3_spe_irq_setup(PS3_BINDING_CPU_ANY, spu_pdata(spu)->spe_id,\r\n0, &spu->irqs[0]);\r\nif (result)\r\ngoto fail_alloc_0;\r\nresult = ps3_spe_irq_setup(PS3_BINDING_CPU_ANY, spu_pdata(spu)->spe_id,\r\n1, &spu->irqs[1]);\r\nif (result)\r\ngoto fail_alloc_1;\r\nresult = ps3_spe_irq_setup(PS3_BINDING_CPU_ANY, spu_pdata(spu)->spe_id,\r\n2, &spu->irqs[2]);\r\nif (result)\r\ngoto fail_alloc_2;\r\nreturn result;\r\nfail_alloc_2:\r\nps3_spe_irq_destroy(spu->irqs[1]);\r\nfail_alloc_1:\r\nps3_spe_irq_destroy(spu->irqs[0]);\r\nfail_alloc_0:\r\nspu->irqs[0] = spu->irqs[1] = spu->irqs[2] = NO_IRQ;\r\nreturn result;\r\n}\r\nstatic int __init enable_spu(struct spu *spu)\r\n{\r\nint result;\r\nresult = lv1_enable_logical_spe(spu_pdata(spu)->spe_id,\r\nspu_pdata(spu)->resource_id);\r\nif (result) {\r\npr_debug("%s:%d: lv1_enable_logical_spe failed: %s\n",\r\n__func__, __LINE__, ps3_result(result));\r\ngoto fail_enable;\r\n}\r\nresult = setup_areas(spu);\r\nif (result)\r\ngoto fail_areas;\r\nresult = setup_interrupts(spu);\r\nif (result)\r\ngoto fail_interrupts;\r\nreturn 0;\r\nfail_interrupts:\r\nspu_unmap(spu);\r\nfail_areas:\r\nlv1_disable_logical_spe(spu_pdata(spu)->spe_id, 0);\r\nfail_enable:\r\nreturn result;\r\n}\r\nstatic int ps3_destroy_spu(struct spu *spu)\r\n{\r\nint result;\r\npr_debug("%s:%d spu_%d\n", __func__, __LINE__, spu->number);\r\nresult = lv1_disable_logical_spe(spu_pdata(spu)->spe_id, 0);\r\nBUG_ON(result);\r\nps3_spe_irq_destroy(spu->irqs[2]);\r\nps3_spe_irq_destroy(spu->irqs[1]);\r\nps3_spe_irq_destroy(spu->irqs[0]);\r\nspu->irqs[0] = spu->irqs[1] = spu->irqs[2] = NO_IRQ;\r\nspu_unmap(spu);\r\nresult = lv1_destruct_logical_spe(spu_pdata(spu)->spe_id);\r\nBUG_ON(result);\r\nkfree(spu->pdata);\r\nspu->pdata = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init ps3_create_spu(struct spu *spu, void *data)\r\n{\r\nint result;\r\npr_debug("%s:%d spu_%d\n", __func__, __LINE__, spu->number);\r\nspu->pdata = kzalloc(sizeof(struct spu_pdata),\r\nGFP_KERNEL);\r\nif (!spu->pdata) {\r\nresult = -ENOMEM;\r\ngoto fail_malloc;\r\n}\r\nspu_pdata(spu)->resource_id = (unsigned long)data;\r\nspu_pdata(spu)->cache.sr1 = 0x33;\r\nresult = construct_spu(spu);\r\nif (result)\r\ngoto fail_construct;\r\nresult = enable_spu(spu);\r\nif (result)\r\ngoto fail_enable;\r\nwhile (in_be64(&spu_pdata(spu)->shadow->spe_execution_status)\r\n!= SPE_EX_STATE_EXECUTED)\r\n(void)0;\r\nreturn result;\r\nfail_enable:\r\nfail_construct:\r\nps3_destroy_spu(spu);\r\nfail_malloc:\r\nreturn result;\r\n}\r\nstatic int __init ps3_enumerate_spus(int (*fn)(void *data))\r\n{\r\nint result;\r\nunsigned int num_resource_id;\r\nunsigned int i;\r\nresult = ps3_repository_read_num_spu_resource_id(&num_resource_id);\r\npr_debug("%s:%d: num_resource_id %u\n", __func__, __LINE__,\r\nnum_resource_id);\r\nfor (i = 0; i < num_resource_id; i++) {\r\nenum ps3_spu_resource_type resource_type;\r\nunsigned int resource_id;\r\nresult = ps3_repository_read_spu_resource_id(i,\r\n&resource_type, &resource_id);\r\nif (result)\r\nbreak;\r\nif (resource_type == PS3_SPU_RESOURCE_TYPE_EXCLUSIVE) {\r\nresult = fn((void*)(unsigned long)resource_id);\r\nif (result)\r\nbreak;\r\n}\r\n}\r\nif (result) {\r\nprintk(KERN_WARNING "%s:%d: Error initializing spus\n",\r\n__func__, __LINE__);\r\nreturn result;\r\n}\r\nreturn num_resource_id;\r\n}\r\nstatic int ps3_init_affinity(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ps3_enable_spu(struct spu_context *ctx)\r\n{\r\n}\r\nstatic void ps3_disable_spu(struct spu_context *ctx)\r\n{\r\nctx->ops->runcntl_stop(ctx);\r\n}\r\nstatic void int_mask_and(struct spu *spu, int class, u64 mask)\r\n{\r\nu64 old_mask;\r\nold_mask = spu_int_mask_get(spu, class);\r\nspu_int_mask_set(spu, class, old_mask & mask);\r\n}\r\nstatic void int_mask_or(struct spu *spu, int class, u64 mask)\r\n{\r\nu64 old_mask;\r\nold_mask = spu_int_mask_get(spu, class);\r\nspu_int_mask_set(spu, class, old_mask | mask);\r\n}\r\nstatic void int_mask_set(struct spu *spu, int class, u64 mask)\r\n{\r\nspu_pdata(spu)->cache.masks[class] = mask;\r\nlv1_set_spe_interrupt_mask(spu_pdata(spu)->spe_id, class,\r\nspu_pdata(spu)->cache.masks[class]);\r\n}\r\nstatic u64 int_mask_get(struct spu *spu, int class)\r\n{\r\nreturn spu_pdata(spu)->cache.masks[class];\r\n}\r\nstatic void int_stat_clear(struct spu *spu, int class, u64 stat)\r\n{\r\nlv1_clear_spe_interrupt_status(spu_pdata(spu)->spe_id, class,\r\nstat, 0);\r\n}\r\nstatic u64 int_stat_get(struct spu *spu, int class)\r\n{\r\nu64 stat;\r\nlv1_get_spe_interrupt_status(spu_pdata(spu)->spe_id, class, &stat);\r\nreturn stat;\r\n}\r\nstatic void cpu_affinity_set(struct spu *spu, int cpu)\r\n{\r\n}\r\nstatic u64 mfc_dar_get(struct spu *spu)\r\n{\r\nreturn in_be64(&spu_pdata(spu)->shadow->mfc_dar_RW);\r\n}\r\nstatic void mfc_dsisr_set(struct spu *spu, u64 dsisr)\r\n{\r\n}\r\nstatic u64 mfc_dsisr_get(struct spu *spu)\r\n{\r\nreturn in_be64(&spu_pdata(spu)->shadow->mfc_dsisr_RW);\r\n}\r\nstatic void mfc_sdr_setup(struct spu *spu)\r\n{\r\n}\r\nstatic void mfc_sr1_set(struct spu *spu, u64 sr1)\r\n{\r\nstatic const u64 allowed = ~(MFC_STATE1_LOCAL_STORAGE_DECODE_MASK\r\n| MFC_STATE1_PROBLEM_STATE_MASK);\r\nBUG_ON((sr1 & allowed) != (spu_pdata(spu)->cache.sr1 & allowed));\r\nspu_pdata(spu)->cache.sr1 = sr1;\r\nlv1_set_spe_privilege_state_area_1_register(\r\nspu_pdata(spu)->spe_id,\r\noffsetof(struct spu_priv1, mfc_sr1_RW),\r\nspu_pdata(spu)->cache.sr1);\r\n}\r\nstatic u64 mfc_sr1_get(struct spu *spu)\r\n{\r\nreturn spu_pdata(spu)->cache.sr1;\r\n}\r\nstatic void mfc_tclass_id_set(struct spu *spu, u64 tclass_id)\r\n{\r\nspu_pdata(spu)->cache.tclass_id = tclass_id;\r\nlv1_set_spe_privilege_state_area_1_register(\r\nspu_pdata(spu)->spe_id,\r\noffsetof(struct spu_priv1, mfc_tclass_id_RW),\r\nspu_pdata(spu)->cache.tclass_id);\r\n}\r\nstatic u64 mfc_tclass_id_get(struct spu *spu)\r\n{\r\nreturn spu_pdata(spu)->cache.tclass_id;\r\n}\r\nstatic void tlb_invalidate(struct spu *spu)\r\n{\r\n}\r\nstatic void resource_allocation_groupID_set(struct spu *spu, u64 id)\r\n{\r\n}\r\nstatic u64 resource_allocation_groupID_get(struct spu *spu)\r\n{\r\nreturn 0;\r\n}\r\nstatic void resource_allocation_enable_set(struct spu *spu, u64 enable)\r\n{\r\n}\r\nstatic u64 resource_allocation_enable_get(struct spu *spu)\r\n{\r\nreturn 0;\r\n}\r\nvoid ps3_spu_set_platform(void)\r\n{\r\nspu_priv1_ops = &spu_priv1_ps3_ops;\r\nspu_management_ops = &spu_management_ps3_ops;\r\n}
