static int rs5c_get_regs(struct rs5c372 *rs5c)\r\n{\r\nstruct i2c_client *client = rs5c->client;\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = sizeof(rs5c->buf),\r\n.buf = rs5c->buf\r\n},\r\n};\r\nif (rs5c->smbus) {\r\nint addr = RS5C_ADDR(RS5C372_REG_SECS);\r\nint size = sizeof(rs5c->buf) - 1;\r\nif (i2c_smbus_read_i2c_block_data(client, addr, size,\r\nrs5c->buf + 1) != size) {\r\ndev_warn(&client->dev, "can't read registers\n");\r\nreturn -EIO;\r\n}\r\n} else {\r\nif ((i2c_transfer(client->adapter, msgs, 1)) != 1) {\r\ndev_warn(&client->dev, "can't read registers\n");\r\nreturn -EIO;\r\n}\r\n}\r\ndev_dbg(&client->dev,\r\n"%3ph (%02x) %3ph (%02x), %3ph, %3ph; %02x %02x\n",\r\nrs5c->regs + 0, rs5c->regs[3],\r\nrs5c->regs + 4, rs5c->regs[7],\r\nrs5c->regs + 8, rs5c->regs + 11,\r\nrs5c->regs[14], rs5c->regs[15]);\r\nreturn 0;\r\n}\r\nstatic unsigned rs5c_reg2hr(struct rs5c372 *rs5c, unsigned reg)\r\n{\r\nunsigned hour;\r\nif (rs5c->time24)\r\nreturn bcd2bin(reg & 0x3f);\r\nhour = bcd2bin(reg & 0x1f);\r\nif (hour == 12)\r\nhour = 0;\r\nif (reg & 0x20)\r\nhour += 12;\r\nreturn hour;\r\n}\r\nstatic unsigned rs5c_hr2reg(struct rs5c372 *rs5c, unsigned hour)\r\n{\r\nif (rs5c->time24)\r\nreturn bin2bcd(hour);\r\nif (hour > 12)\r\nreturn 0x20 | bin2bcd(hour - 12);\r\nif (hour == 12)\r\nreturn 0x20 | bin2bcd(12);\r\nif (hour == 0)\r\nreturn bin2bcd(12);\r\nreturn bin2bcd(hour);\r\n}\r\nstatic int rs5c372_get_datetime(struct i2c_client *client, struct rtc_time *tm)\r\n{\r\nstruct rs5c372 *rs5c = i2c_get_clientdata(client);\r\nint status = rs5c_get_regs(rs5c);\r\nif (status < 0)\r\nreturn status;\r\ntm->tm_sec = bcd2bin(rs5c->regs[RS5C372_REG_SECS] & 0x7f);\r\ntm->tm_min = bcd2bin(rs5c->regs[RS5C372_REG_MINS] & 0x7f);\r\ntm->tm_hour = rs5c_reg2hr(rs5c, rs5c->regs[RS5C372_REG_HOURS]);\r\ntm->tm_wday = bcd2bin(rs5c->regs[RS5C372_REG_WDAY] & 0x07);\r\ntm->tm_mday = bcd2bin(rs5c->regs[RS5C372_REG_DAY] & 0x3f);\r\ntm->tm_mon = bcd2bin(rs5c->regs[RS5C372_REG_MONTH] & 0x1f) - 1;\r\ntm->tm_year = bcd2bin(rs5c->regs[RS5C372_REG_YEAR]) + 100;\r\ndev_dbg(&client->dev, "%s: tm is secs=%d, mins=%d, hours=%d, "\r\n"mday=%d, mon=%d, year=%d, wday=%d\n",\r\n__func__,\r\ntm->tm_sec, tm->tm_min, tm->tm_hour,\r\ntm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_wday);\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int rs5c372_set_datetime(struct i2c_client *client, struct rtc_time *tm)\r\n{\r\nstruct rs5c372 *rs5c = i2c_get_clientdata(client);\r\nunsigned char buf[7];\r\nint addr;\r\ndev_dbg(&client->dev, "%s: tm is secs=%d, mins=%d, hours=%d "\r\n"mday=%d, mon=%d, year=%d, wday=%d\n",\r\n__func__,\r\ntm->tm_sec, tm->tm_min, tm->tm_hour,\r\ntm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_wday);\r\naddr = RS5C_ADDR(RS5C372_REG_SECS);\r\nbuf[0] = bin2bcd(tm->tm_sec);\r\nbuf[1] = bin2bcd(tm->tm_min);\r\nbuf[2] = rs5c_hr2reg(rs5c, tm->tm_hour);\r\nbuf[3] = bin2bcd(tm->tm_wday);\r\nbuf[4] = bin2bcd(tm->tm_mday);\r\nbuf[5] = bin2bcd(tm->tm_mon + 1);\r\nbuf[6] = bin2bcd(tm->tm_year - 100);\r\nif (i2c_smbus_write_i2c_block_data(client, addr, sizeof(buf), buf) < 0) {\r\ndev_err(&client->dev, "%s: write error\n", __func__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rs5c372_get_trim(struct i2c_client *client, int *osc, int *trim)\r\n{\r\nstruct rs5c372 *rs5c372 = i2c_get_clientdata(client);\r\nu8 tmp = rs5c372->regs[RS5C372_REG_TRIM];\r\nif (osc)\r\n*osc = (tmp & RS5C372_TRIM_XSL) ? 32000 : 32768;\r\nif (trim) {\r\ndev_dbg(&client->dev, "%s: raw trim=%x\n", __func__, tmp);\r\ntmp &= RS5C372_TRIM_MASK;\r\nif (tmp & 0x3e) {\r\nint t = tmp & 0x3f;\r\nif (tmp & 0x40)\r\nt = (~t | (s8)0xc0) + 1;\r\nelse\r\nt = t - 1;\r\ntmp = t * 2;\r\n} else\r\ntmp = 0;\r\n*trim = tmp;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rs5c372_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nreturn rs5c372_get_datetime(to_i2c_client(dev), tm);\r\n}\r\nstatic int rs5c372_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nreturn rs5c372_set_datetime(to_i2c_client(dev), tm);\r\n}\r\nstatic int rs5c_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rs5c372 *rs5c = i2c_get_clientdata(client);\r\nunsigned char buf;\r\nint status, addr;\r\nbuf = rs5c->regs[RS5C_REG_CTRL1];\r\nif (!rs5c->has_irq)\r\nreturn -EINVAL;\r\nstatus = rs5c_get_regs(rs5c);\r\nif (status < 0)\r\nreturn status;\r\naddr = RS5C_ADDR(RS5C_REG_CTRL1);\r\nif (enabled)\r\nbuf |= RS5C_CTRL1_AALE;\r\nelse\r\nbuf &= ~RS5C_CTRL1_AALE;\r\nif (i2c_smbus_write_byte_data(client, addr, buf) < 0) {\r\ndev_warn(dev, "can't update alarm\n");\r\nstatus = -EIO;\r\n} else\r\nrs5c->regs[RS5C_REG_CTRL1] = buf;\r\nreturn status;\r\n}\r\nstatic int rs5c_read_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rs5c372 *rs5c = i2c_get_clientdata(client);\r\nint status;\r\nstatus = rs5c_get_regs(rs5c);\r\nif (status < 0)\r\nreturn status;\r\nt->time.tm_sec = 0;\r\nt->time.tm_min = bcd2bin(rs5c->regs[RS5C_REG_ALARM_A_MIN] & 0x7f);\r\nt->time.tm_hour = rs5c_reg2hr(rs5c, rs5c->regs[RS5C_REG_ALARM_A_HOURS]);\r\nt->time.tm_mday = -1;\r\nt->time.tm_mon = -1;\r\nt->time.tm_year = -1;\r\nt->time.tm_wday = -1;\r\nt->time.tm_yday = -1;\r\nt->time.tm_isdst = -1;\r\nt->enabled = !!(rs5c->regs[RS5C_REG_CTRL1] & RS5C_CTRL1_AALE);\r\nt->pending = !!(rs5c->regs[RS5C_REG_CTRL2] & RS5C_CTRL2_AAFG);\r\nreturn 0;\r\n}\r\nstatic int rs5c_set_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rs5c372 *rs5c = i2c_get_clientdata(client);\r\nint status, addr, i;\r\nunsigned char buf[3];\r\nif (t->time.tm_mday != -1\r\n|| t->time.tm_mon != -1\r\n|| t->time.tm_year != -1)\r\nreturn -EINVAL;\r\nstatus = rs5c_get_regs(rs5c);\r\nif (status < 0)\r\nreturn status;\r\nif (rs5c->regs[RS5C_REG_CTRL1] & RS5C_CTRL1_AALE) {\r\naddr = RS5C_ADDR(RS5C_REG_CTRL1);\r\nbuf[0] = rs5c->regs[RS5C_REG_CTRL1] & ~RS5C_CTRL1_AALE;\r\nif (i2c_smbus_write_byte_data(client, addr, buf[0]) < 0) {\r\ndev_dbg(dev, "can't disable alarm\n");\r\nreturn -EIO;\r\n}\r\nrs5c->regs[RS5C_REG_CTRL1] = buf[0];\r\n}\r\nbuf[0] = bin2bcd(t->time.tm_min);\r\nbuf[1] = rs5c_hr2reg(rs5c, t->time.tm_hour);\r\nbuf[2] = 0x7f;\r\nfor (i = 0; i < sizeof(buf); i++) {\r\naddr = RS5C_ADDR(RS5C_REG_ALARM_A_MIN + i);\r\nif (i2c_smbus_write_byte_data(client, addr, buf[i]) < 0) {\r\ndev_dbg(dev, "can't set alarm time\n");\r\nreturn -EIO;\r\n}\r\n}\r\nif (t->enabled) {\r\naddr = RS5C_ADDR(RS5C_REG_CTRL1);\r\nbuf[0] = rs5c->regs[RS5C_REG_CTRL1] | RS5C_CTRL1_AALE;\r\nif (i2c_smbus_write_byte_data(client, addr, buf[0]) < 0)\r\ndev_warn(dev, "can't enable alarm\n");\r\nrs5c->regs[RS5C_REG_CTRL1] = buf[0];\r\n}\r\nreturn 0;\r\n}\r\nstatic int rs5c372_rtc_proc(struct device *dev, struct seq_file *seq)\r\n{\r\nint err, osc, trim;\r\nerr = rs5c372_get_trim(to_i2c_client(dev), &osc, &trim);\r\nif (err == 0) {\r\nseq_printf(seq, "crystal\t\t: %d.%03d KHz\n",\r\nosc / 1000, osc % 1000);\r\nseq_printf(seq, "trim\t\t: %d\n", trim);\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t rs5c372_sysfs_show_trim(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint err, trim;\r\nerr = rs5c372_get_trim(to_i2c_client(dev), NULL, &trim);\r\nif (err)\r\nreturn err;\r\nreturn sprintf(buf, "%d\n", trim);\r\n}\r\nstatic ssize_t rs5c372_sysfs_show_osc(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint err, osc;\r\nerr = rs5c372_get_trim(to_i2c_client(dev), &osc, NULL);\r\nif (err)\r\nreturn err;\r\nreturn sprintf(buf, "%d.%03d KHz\n", osc / 1000, osc % 1000);\r\n}\r\nstatic int rs5c_sysfs_register(struct device *dev)\r\n{\r\nint err;\r\nerr = device_create_file(dev, &dev_attr_trim);\r\nif (err)\r\nreturn err;\r\nerr = device_create_file(dev, &dev_attr_osc);\r\nif (err)\r\ndevice_remove_file(dev, &dev_attr_trim);\r\nreturn err;\r\n}\r\nstatic void rs5c_sysfs_unregister(struct device *dev)\r\n{\r\ndevice_remove_file(dev, &dev_attr_trim);\r\ndevice_remove_file(dev, &dev_attr_osc);\r\n}\r\nstatic int rs5c_sysfs_register(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void rs5c_sysfs_unregister(struct device *dev)\r\n{\r\n}\r\nstatic int rs5c_oscillator_setup(struct rs5c372 *rs5c372)\r\n{\r\nunsigned char buf[2];\r\nint addr, i, ret = 0;\r\nif (rs5c372->type == rtc_r2025sd) {\r\nif (!(rs5c372->regs[RS5C_REG_CTRL2] & R2025_CTRL2_XST))\r\nreturn ret;\r\nrs5c372->regs[RS5C_REG_CTRL2] &= ~R2025_CTRL2_XST;\r\n} else {\r\nif (!(rs5c372->regs[RS5C_REG_CTRL2] & RS5C_CTRL2_XSTP))\r\nreturn ret;\r\nrs5c372->regs[RS5C_REG_CTRL2] &= ~RS5C_CTRL2_XSTP;\r\n}\r\naddr = RS5C_ADDR(RS5C_REG_CTRL1);\r\nbuf[0] = rs5c372->regs[RS5C_REG_CTRL1];\r\nbuf[1] = rs5c372->regs[RS5C_REG_CTRL2];\r\nswitch (rs5c372->type) {\r\ncase rtc_rs5c372a:\r\ncase rtc_rs5c372b:\r\nbuf[1] |= RS5C372_CTRL2_24;\r\nrs5c372->time24 = 1;\r\nbreak;\r\ncase rtc_r2025sd:\r\ncase rtc_r2221tl:\r\ncase rtc_rv5c386:\r\ncase rtc_rv5c387a:\r\nbuf[0] |= RV5C387_CTRL1_24;\r\nrs5c372->time24 = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfor (i = 0; i < sizeof(buf); i++) {\r\naddr = RS5C_ADDR(RS5C_REG_CTRL1 + i);\r\nret = i2c_smbus_write_byte_data(rs5c372->client, addr, buf[i]);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\n}\r\nrs5c372->regs[RS5C_REG_CTRL1] = buf[0];\r\nrs5c372->regs[RS5C_REG_CTRL2] = buf[1];\r\nreturn 0;\r\n}\r\nstatic int rs5c372_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint err = 0;\r\nint smbus_mode = 0;\r\nstruct rs5c372 *rs5c372;\r\nstruct rtc_time tm;\r\ndev_dbg(&client->dev, "%s\n", __func__);\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |\r\nI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_I2C_BLOCK)) {\r\nif (i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_I2C_BLOCK))\r\nsmbus_mode = 1;\r\nelse {\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\n}\r\nrs5c372 = devm_kzalloc(&client->dev, sizeof(struct rs5c372),\r\nGFP_KERNEL);\r\nif (!rs5c372) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\nrs5c372->client = client;\r\ni2c_set_clientdata(client, rs5c372);\r\nrs5c372->type = id->driver_data;\r\nrs5c372->regs = &rs5c372->buf[1];\r\nrs5c372->smbus = smbus_mode;\r\nerr = rs5c_get_regs(rs5c372);\r\nif (err < 0)\r\ngoto exit;\r\nswitch (rs5c372->type) {\r\ncase rtc_rs5c372a:\r\ncase rtc_rs5c372b:\r\nif (rs5c372->regs[RS5C_REG_CTRL2] & RS5C372_CTRL2_24)\r\nrs5c372->time24 = 1;\r\nbreak;\r\ncase rtc_r2025sd:\r\ncase rtc_r2221tl:\r\ncase rtc_rv5c386:\r\ncase rtc_rv5c387a:\r\nif (rs5c372->regs[RS5C_REG_CTRL1] & RV5C387_CTRL1_24)\r\nrs5c372->time24 = 1;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "unknown RTC type\n");\r\ngoto exit;\r\n}\r\nerr = rs5c_oscillator_setup(rs5c372);\r\nif (unlikely(err < 0)) {\r\ndev_err(&client->dev, "setup error\n");\r\ngoto exit;\r\n}\r\nif (rs5c372_get_datetime(client, &tm) < 0)\r\ndev_warn(&client->dev, "clock needs to be set\n");\r\ndev_info(&client->dev, "%s found, %s, driver version " DRV_VERSION "\n",\r\n({ char *s; switch (rs5c372->type) {\r\ncase rtc_r2025sd: s = "r2025sd"; break;\r\ncase rtc_r2221tl: s = "r2221tl"; break;\r\ncase rtc_rs5c372a: s = "rs5c372a"; break;\r\ncase rtc_rs5c372b: s = "rs5c372b"; break;\r\ncase rtc_rv5c386: s = "rv5c386"; break;\r\ncase rtc_rv5c387a: s = "rv5c387a"; break;\r\ndefault: s = "chip"; break;\r\n}; s;}),\r\nrs5c372->time24 ? "24hr" : "am/pm"\r\n);\r\nrs5c372->rtc = devm_rtc_device_register(&client->dev,\r\nrs5c372_driver.driver.name,\r\n&rs5c372_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rs5c372->rtc)) {\r\nerr = PTR_ERR(rs5c372->rtc);\r\ngoto exit;\r\n}\r\nerr = rs5c_sysfs_register(&client->dev);\r\nif (err)\r\ngoto exit;\r\nreturn 0;\r\nexit:\r\nreturn err;\r\n}\r\nstatic int rs5c372_remove(struct i2c_client *client)\r\n{\r\nrs5c_sysfs_unregister(&client->dev);\r\nreturn 0;\r\n}
