static inline struct isp1760_udc *gadget_to_udc(struct usb_gadget *gadget)\r\n{\r\nreturn container_of(gadget, struct isp1760_udc, gadget);\r\n}\r\nstatic inline struct isp1760_ep *ep_to_udc_ep(struct usb_ep *ep)\r\n{\r\nreturn container_of(ep, struct isp1760_ep, ep);\r\n}\r\nstatic inline struct isp1760_request *req_to_udc_req(struct usb_request *req)\r\n{\r\nreturn container_of(req, struct isp1760_request, req);\r\n}\r\nstatic inline u32 isp1760_udc_read(struct isp1760_udc *udc, u16 reg)\r\n{\r\nreturn isp1760_read32(udc->regs, reg);\r\n}\r\nstatic inline void isp1760_udc_write(struct isp1760_udc *udc, u16 reg, u32 val)\r\n{\r\nisp1760_write32(udc->regs, reg, val);\r\n}\r\nstatic struct isp1760_ep *isp1760_udc_find_ep(struct isp1760_udc *udc,\r\nu16 index)\r\n{\r\nunsigned int i;\r\nif (index == 0)\r\nreturn &udc->ep[0];\r\nfor (i = 1; i < ARRAY_SIZE(udc->ep); ++i) {\r\nif (udc->ep[i].addr == index)\r\nreturn udc->ep[i].desc ? &udc->ep[i] : NULL;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void __isp1760_udc_select_ep(struct isp1760_ep *ep, int dir)\r\n{\r\nisp1760_udc_write(ep->udc, DC_EPINDEX,\r\nDC_ENDPIDX(ep->addr & USB_ENDPOINT_NUMBER_MASK) |\r\n(dir == USB_DIR_IN ? DC_EPDIR : 0));\r\n}\r\nstatic void isp1760_udc_select_ep(struct isp1760_ep *ep)\r\n{\r\n__isp1760_udc_select_ep(ep, ep->addr & USB_ENDPOINT_DIR_MASK);\r\n}\r\nstatic void isp1760_udc_ctrl_send_status(struct isp1760_ep *ep, int dir)\r\n{\r\nstruct isp1760_udc *udc = ep->udc;\r\nisp1760_udc_write(udc, DC_EPINDEX, DC_ENDPIDX(0) |\r\n(dir == USB_DIR_IN ? 0 : DC_EPDIR));\r\nisp1760_udc_write(udc, DC_CTRLFUNC, DC_STATUS);\r\nudc->ep0_state = ISP1760_CTRL_SETUP;\r\n}\r\nstatic void isp1760_udc_request_complete(struct isp1760_ep *ep,\r\nstruct isp1760_request *req,\r\nint status)\r\n{\r\nstruct isp1760_udc *udc = ep->udc;\r\nunsigned long flags;\r\ndev_dbg(ep->udc->isp->dev, "completing request %p with status %d\n",\r\nreq, status);\r\nreq->ep = NULL;\r\nreq->req.status = status;\r\nreq->req.complete(&ep->ep, &req->req);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (status == 0 && ep->addr == 0 && udc->ep0_dir == USB_DIR_OUT)\r\nisp1760_udc_ctrl_send_status(ep, USB_DIR_OUT);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\n}\r\nstatic void isp1760_udc_ctrl_send_stall(struct isp1760_ep *ep)\r\n{\r\nstruct isp1760_udc *udc = ep->udc;\r\nunsigned long flags;\r\ndev_dbg(ep->udc->isp->dev, "%s(ep%02x)\n", __func__, ep->addr);\r\nspin_lock_irqsave(&udc->lock, flags);\r\n__isp1760_udc_select_ep(ep, USB_DIR_OUT);\r\nisp1760_udc_write(udc, DC_CTRLFUNC, DC_STALL);\r\n__isp1760_udc_select_ep(ep, USB_DIR_IN);\r\nisp1760_udc_write(udc, DC_CTRLFUNC, DC_STALL);\r\nudc->ep0_state = ISP1760_CTRL_SETUP;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\n}\r\nstatic bool isp1760_udc_receive(struct isp1760_ep *ep,\r\nstruct isp1760_request *req)\r\n{\r\nstruct isp1760_udc *udc = ep->udc;\r\nunsigned int len;\r\nu32 *buf;\r\nint i;\r\nisp1760_udc_select_ep(ep);\r\nlen = isp1760_udc_read(udc, DC_BUFLEN) & DC_DATACOUNT_MASK;\r\ndev_dbg(udc->isp->dev, "%s: received %u bytes (%u/%u done)\n",\r\n__func__, len, req->req.actual, req->req.length);\r\nlen = min(len, req->req.length - req->req.actual);\r\nif (!len) {\r\nisp1760_udc_write(udc, DC_CTRLFUNC, DC_CLBUF);\r\nreturn false;\r\n}\r\nbuf = req->req.buf + req->req.actual;\r\nfor (i = len; i > 2; i -= 4, ++buf)\r\n*buf = le32_to_cpu(isp1760_udc_read(udc, DC_DATAPORT));\r\nif (i > 0)\r\n*(u16 *)buf = le16_to_cpu(readw(udc->regs + DC_DATAPORT));\r\nreq->req.actual += len;\r\ndev_dbg(udc->isp->dev,\r\n"%s: req %p actual/length %u/%u maxpacket %u packet size %u\n",\r\n__func__, req, req->req.actual, req->req.length, ep->maxpacket,\r\nlen);\r\nep->rx_pending = false;\r\nif (req->req.actual == req->req.length || len < ep->maxpacket) {\r\nlist_del(&req->queue);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void isp1760_udc_transmit(struct isp1760_ep *ep,\r\nstruct isp1760_request *req)\r\n{\r\nstruct isp1760_udc *udc = ep->udc;\r\nu32 *buf = req->req.buf + req->req.actual;\r\nint i;\r\nreq->packet_size = min(req->req.length - req->req.actual,\r\nep->maxpacket);\r\ndev_dbg(udc->isp->dev, "%s: transferring %u bytes (%u/%u done)\n",\r\n__func__, req->packet_size, req->req.actual,\r\nreq->req.length);\r\n__isp1760_udc_select_ep(ep, USB_DIR_IN);\r\nif (req->packet_size)\r\nisp1760_udc_write(udc, DC_BUFLEN, req->packet_size);\r\nfor (i = req->packet_size; i > 2; i -= 4, ++buf)\r\nisp1760_udc_write(udc, DC_DATAPORT, cpu_to_le32(*buf));\r\nif (i > 0)\r\nwritew(cpu_to_le16(*(u16 *)buf), udc->regs + DC_DATAPORT);\r\nif (ep->addr == 0)\r\nisp1760_udc_write(udc, DC_CTRLFUNC, DC_DSEN);\r\nif (!req->packet_size)\r\nisp1760_udc_write(udc, DC_CTRLFUNC, DC_VENDP);\r\n}\r\nstatic void isp1760_ep_rx_ready(struct isp1760_ep *ep)\r\n{\r\nstruct isp1760_udc *udc = ep->udc;\r\nstruct isp1760_request *req;\r\nbool complete;\r\nspin_lock(&udc->lock);\r\nif (ep->addr == 0 && udc->ep0_state != ISP1760_CTRL_DATA_OUT) {\r\nspin_unlock(&udc->lock);\r\ndev_dbg(udc->isp->dev, "%s: invalid ep0 state %u\n", __func__,\r\nudc->ep0_state);\r\nreturn;\r\n}\r\nif (ep->addr != 0 && !ep->desc) {\r\nspin_unlock(&udc->lock);\r\ndev_dbg(udc->isp->dev, "%s: ep%02x is disabled\n", __func__,\r\nep->addr);\r\nreturn;\r\n}\r\nif (list_empty(&ep->queue)) {\r\nep->rx_pending = true;\r\nspin_unlock(&udc->lock);\r\ndev_dbg(udc->isp->dev, "%s: ep%02x (%p) has no request queued\n",\r\n__func__, ep->addr, ep);\r\nreturn;\r\n}\r\nreq = list_first_entry(&ep->queue, struct isp1760_request,\r\nqueue);\r\ncomplete = isp1760_udc_receive(ep, req);\r\nspin_unlock(&udc->lock);\r\nif (complete)\r\nisp1760_udc_request_complete(ep, req, 0);\r\n}\r\nstatic void isp1760_ep_tx_complete(struct isp1760_ep *ep)\r\n{\r\nstruct isp1760_udc *udc = ep->udc;\r\nstruct isp1760_request *complete = NULL;\r\nstruct isp1760_request *req;\r\nbool need_zlp;\r\nspin_lock(&udc->lock);\r\nif (ep->addr == 0 && udc->ep0_state != ISP1760_CTRL_DATA_IN) {\r\nspin_unlock(&udc->lock);\r\ndev_dbg(udc->isp->dev, "TX IRQ: invalid endpoint state %u\n",\r\nudc->ep0_state);\r\nreturn;\r\n}\r\nif (list_empty(&ep->queue)) {\r\nif (ep->addr == 0) {\r\nisp1760_udc_ctrl_send_status(ep, USB_DIR_IN);\r\nspin_unlock(&udc->lock);\r\nreturn;\r\n}\r\nspin_unlock(&udc->lock);\r\ndev_dbg(udc->isp->dev, "%s: ep%02x has no request queued\n",\r\n__func__, ep->addr);\r\nreturn;\r\n}\r\nreq = list_first_entry(&ep->queue, struct isp1760_request,\r\nqueue);\r\nreq->req.actual += req->packet_size;\r\nneed_zlp = req->req.actual == req->req.length &&\r\n!(req->req.length % ep->maxpacket) &&\r\nreq->packet_size && req->req.zero;\r\ndev_dbg(udc->isp->dev,\r\n"TX IRQ: req %p actual/length %u/%u maxpacket %u packet size %u zero %u need zlp %u\n",\r\nreq, req->req.actual, req->req.length, ep->maxpacket,\r\nreq->packet_size, req->req.zero, need_zlp);\r\nif (req->req.actual == req->req.length && !need_zlp) {\r\ncomplete = req;\r\nlist_del(&req->queue);\r\nif (ep->addr == 0)\r\nisp1760_udc_ctrl_send_status(ep, USB_DIR_IN);\r\nif (!list_empty(&ep->queue))\r\nreq = list_first_entry(&ep->queue,\r\nstruct isp1760_request, queue);\r\nelse\r\nreq = NULL;\r\n}\r\nif (req)\r\nisp1760_udc_transmit(ep, req);\r\nspin_unlock(&udc->lock);\r\nif (complete)\r\nisp1760_udc_request_complete(ep, complete, 0);\r\n}\r\nstatic int __isp1760_udc_set_halt(struct isp1760_ep *ep, bool halt)\r\n{\r\nstruct isp1760_udc *udc = ep->udc;\r\ndev_dbg(udc->isp->dev, "%s: %s halt on ep%02x\n", __func__,\r\nhalt ? "set" : "clear", ep->addr);\r\nif (ep->desc && usb_endpoint_xfer_isoc(ep->desc)) {\r\ndev_dbg(udc->isp->dev, "%s: ep%02x is isochronous\n", __func__,\r\nep->addr);\r\nreturn -EINVAL;\r\n}\r\nisp1760_udc_select_ep(ep);\r\nisp1760_udc_write(udc, DC_CTRLFUNC, halt ? DC_STALL : 0);\r\nif (ep->addr == 0) {\r\n__isp1760_udc_select_ep(ep, USB_DIR_IN);\r\nisp1760_udc_write(udc, DC_CTRLFUNC, halt ? DC_STALL : 0);\r\n} else if (!halt) {\r\nu16 eptype = isp1760_udc_read(udc, DC_EPTYPE);\r\nisp1760_udc_write(udc, DC_EPTYPE, eptype & ~DC_EPENABLE);\r\nisp1760_udc_write(udc, DC_EPTYPE, eptype);\r\nif ((ep->addr & USB_DIR_IN) && !list_empty(&ep->queue)) {\r\nstruct isp1760_request *req;\r\nreq = list_first_entry(&ep->queue,\r\nstruct isp1760_request, queue);\r\nisp1760_udc_transmit(ep, req);\r\n}\r\n}\r\nep->halted = halt;\r\nreturn 0;\r\n}\r\nstatic int isp1760_udc_get_status(struct isp1760_udc *udc,\r\nconst struct usb_ctrlrequest *req)\r\n{\r\nstruct isp1760_ep *ep;\r\nu16 status;\r\nif (req->wLength != cpu_to_le16(2) || req->wValue != cpu_to_le16(0))\r\nreturn -EINVAL;\r\nswitch (req->bRequestType) {\r\ncase USB_DIR_IN | USB_RECIP_DEVICE:\r\nstatus = udc->devstatus;\r\nbreak;\r\ncase USB_DIR_IN | USB_RECIP_INTERFACE:\r\nstatus = 0;\r\nbreak;\r\ncase USB_DIR_IN | USB_RECIP_ENDPOINT:\r\nep = isp1760_udc_find_ep(udc, le16_to_cpu(req->wIndex));\r\nif (!ep)\r\nreturn -EINVAL;\r\nstatus = 0;\r\nif (ep->halted)\r\nstatus |= 1 << USB_ENDPOINT_HALT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nisp1760_udc_write(udc, DC_EPINDEX, DC_ENDPIDX(0) | DC_EPDIR);\r\nisp1760_udc_write(udc, DC_BUFLEN, 2);\r\nwritew(cpu_to_le16(status), udc->regs + DC_DATAPORT);\r\nisp1760_udc_write(udc, DC_CTRLFUNC, DC_DSEN);\r\ndev_dbg(udc->isp->dev, "%s: status 0x%04x\n", __func__, status);\r\nreturn 0;\r\n}\r\nstatic int isp1760_udc_set_address(struct isp1760_udc *udc, u16 addr)\r\n{\r\nif (addr > 127) {\r\ndev_dbg(udc->isp->dev, "invalid device address %u\n", addr);\r\nreturn -EINVAL;\r\n}\r\nif (udc->gadget.state != USB_STATE_DEFAULT &&\r\nudc->gadget.state != USB_STATE_ADDRESS) {\r\ndev_dbg(udc->isp->dev, "can't set address in state %u\n",\r\nudc->gadget.state);\r\nreturn -EINVAL;\r\n}\r\nusb_gadget_set_state(&udc->gadget, addr ? USB_STATE_ADDRESS :\r\nUSB_STATE_DEFAULT);\r\nisp1760_udc_write(udc, DC_ADDRESS, DC_DEVEN | addr);\r\nspin_lock(&udc->lock);\r\nisp1760_udc_ctrl_send_status(&udc->ep[0], USB_DIR_OUT);\r\nspin_unlock(&udc->lock);\r\nreturn 0;\r\n}\r\nstatic bool isp1760_ep0_setup_standard(struct isp1760_udc *udc,\r\nstruct usb_ctrlrequest *req)\r\n{\r\nbool stall;\r\nswitch (req->bRequest) {\r\ncase USB_REQ_GET_STATUS:\r\nreturn isp1760_udc_get_status(udc, req);\r\ncase USB_REQ_CLEAR_FEATURE:\r\nswitch (req->bRequestType) {\r\ncase USB_DIR_OUT | USB_RECIP_DEVICE: {\r\nreturn true;\r\n}\r\ncase USB_DIR_OUT | USB_RECIP_ENDPOINT: {\r\nu16 index = le16_to_cpu(req->wIndex);\r\nstruct isp1760_ep *ep;\r\nif (req->wLength != cpu_to_le16(0) ||\r\nreq->wValue != cpu_to_le16(USB_ENDPOINT_HALT))\r\nreturn true;\r\nep = isp1760_udc_find_ep(udc, index);\r\nif (!ep)\r\nreturn true;\r\nspin_lock(&udc->lock);\r\nif (!ep->wedged)\r\nstall = __isp1760_udc_set_halt(ep, false);\r\nelse\r\nstall = false;\r\nif (!stall)\r\nisp1760_udc_ctrl_send_status(&udc->ep[0],\r\nUSB_DIR_OUT);\r\nspin_unlock(&udc->lock);\r\nreturn stall;\r\n}\r\ndefault:\r\nreturn true;\r\n}\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\nswitch (req->bRequestType) {\r\ncase USB_DIR_OUT | USB_RECIP_DEVICE: {\r\nreturn true;\r\n}\r\ncase USB_DIR_OUT | USB_RECIP_ENDPOINT: {\r\nu16 index = le16_to_cpu(req->wIndex);\r\nstruct isp1760_ep *ep;\r\nif (req->wLength != cpu_to_le16(0) ||\r\nreq->wValue != cpu_to_le16(USB_ENDPOINT_HALT))\r\nreturn true;\r\nep = isp1760_udc_find_ep(udc, index);\r\nif (!ep)\r\nreturn true;\r\nspin_lock(&udc->lock);\r\nstall = __isp1760_udc_set_halt(ep, true);\r\nif (!stall)\r\nisp1760_udc_ctrl_send_status(&udc->ep[0],\r\nUSB_DIR_OUT);\r\nspin_unlock(&udc->lock);\r\nreturn stall;\r\n}\r\ndefault:\r\nreturn true;\r\n}\r\nbreak;\r\ncase USB_REQ_SET_ADDRESS:\r\nif (req->bRequestType != (USB_DIR_OUT | USB_RECIP_DEVICE))\r\nreturn true;\r\nreturn isp1760_udc_set_address(udc, le16_to_cpu(req->wValue));\r\ncase USB_REQ_SET_CONFIGURATION:\r\nif (req->bRequestType != (USB_DIR_OUT | USB_RECIP_DEVICE))\r\nreturn true;\r\nif (udc->gadget.state != USB_STATE_ADDRESS &&\r\nudc->gadget.state != USB_STATE_CONFIGURED)\r\nreturn true;\r\nstall = udc->driver->setup(&udc->gadget, req) < 0;\r\nif (stall)\r\nreturn true;\r\nusb_gadget_set_state(&udc->gadget, req->wValue ?\r\nUSB_STATE_CONFIGURED : USB_STATE_ADDRESS);\r\nreturn false;\r\ndefault:\r\nreturn udc->driver->setup(&udc->gadget, req) < 0;\r\n}\r\n}\r\nstatic void isp1760_ep0_setup(struct isp1760_udc *udc)\r\n{\r\nunion {\r\nstruct usb_ctrlrequest r;\r\nu32 data[2];\r\n} req;\r\nunsigned int count;\r\nbool stall = false;\r\nspin_lock(&udc->lock);\r\nisp1760_udc_write(udc, DC_EPINDEX, DC_EP0SETUP);\r\ncount = isp1760_udc_read(udc, DC_BUFLEN) & DC_DATACOUNT_MASK;\r\nif (count != sizeof(req)) {\r\nspin_unlock(&udc->lock);\r\ndev_err(udc->isp->dev, "invalid length %u for setup packet\n",\r\ncount);\r\nisp1760_udc_ctrl_send_stall(&udc->ep[0]);\r\nreturn;\r\n}\r\nreq.data[0] = isp1760_udc_read(udc, DC_DATAPORT);\r\nreq.data[1] = isp1760_udc_read(udc, DC_DATAPORT);\r\nif (udc->ep0_state != ISP1760_CTRL_SETUP) {\r\nspin_unlock(&udc->lock);\r\ndev_dbg(udc->isp->dev, "unexpected SETUP packet\n");\r\nreturn;\r\n}\r\nif (!req.r.wLength)\r\nudc->ep0_state = ISP1760_CTRL_STATUS;\r\nelse if (req.r.bRequestType & USB_DIR_IN)\r\nudc->ep0_state = ISP1760_CTRL_DATA_IN;\r\nelse\r\nudc->ep0_state = ISP1760_CTRL_DATA_OUT;\r\nudc->ep0_dir = req.r.bRequestType & USB_DIR_IN;\r\nudc->ep0_length = le16_to_cpu(req.r.wLength);\r\nspin_unlock(&udc->lock);\r\ndev_dbg(udc->isp->dev,\r\n"%s: bRequestType 0x%02x bRequest 0x%02x wValue 0x%04x wIndex 0x%04x wLength 0x%04x\n",\r\n__func__, req.r.bRequestType, req.r.bRequest,\r\nle16_to_cpu(req.r.wValue), le16_to_cpu(req.r.wIndex),\r\nle16_to_cpu(req.r.wLength));\r\nif ((req.r.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)\r\nstall = isp1760_ep0_setup_standard(udc, &req.r);\r\nelse\r\nstall = udc->driver->setup(&udc->gadget, &req.r) < 0;\r\nif (stall)\r\nisp1760_udc_ctrl_send_stall(&udc->ep[0]);\r\n}\r\nstatic int isp1760_ep_enable(struct usb_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct isp1760_ep *uep = ep_to_udc_ep(ep);\r\nstruct isp1760_udc *udc = uep->udc;\r\nunsigned long flags;\r\nunsigned int type;\r\ndev_dbg(uep->udc->isp->dev, "%s\n", __func__);\r\nif (desc->bDescriptorType != USB_DT_ENDPOINT ||\r\ndesc->bEndpointAddress == 0 ||\r\ndesc->bEndpointAddress != uep->addr ||\r\nle16_to_cpu(desc->wMaxPacketSize) > ep->maxpacket) {\r\ndev_dbg(udc->isp->dev,\r\n"%s: invalid descriptor type %u addr %02x ep addr %02x max packet size %u/%u\n",\r\n__func__, desc->bDescriptorType,\r\ndesc->bEndpointAddress, uep->addr,\r\nle16_to_cpu(desc->wMaxPacketSize), ep->maxpacket);\r\nreturn -EINVAL;\r\n}\r\nswitch (usb_endpoint_type(desc)) {\r\ncase USB_ENDPOINT_XFER_ISOC:\r\ntype = DC_ENDPTYP_ISOC;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\ntype = DC_ENDPTYP_BULK;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\ntype = DC_ENDPTYP_INTERRUPT;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\ndefault:\r\ndev_dbg(udc->isp->dev, "%s: control endpoints unsupported\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&udc->lock, flags);\r\nuep->desc = desc;\r\nuep->maxpacket = le16_to_cpu(desc->wMaxPacketSize);\r\nuep->rx_pending = false;\r\nuep->halted = false;\r\nuep->wedged = false;\r\nisp1760_udc_select_ep(uep);\r\nisp1760_udc_write(udc, DC_EPMAXPKTSZ, uep->maxpacket);\r\nisp1760_udc_write(udc, DC_BUFLEN, uep->maxpacket);\r\nisp1760_udc_write(udc, DC_EPTYPE, DC_EPENABLE | type);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int isp1760_ep_disable(struct usb_ep *ep)\r\n{\r\nstruct isp1760_ep *uep = ep_to_udc_ep(ep);\r\nstruct isp1760_udc *udc = uep->udc;\r\nstruct isp1760_request *req, *nreq;\r\nLIST_HEAD(req_list);\r\nunsigned long flags;\r\ndev_dbg(udc->isp->dev, "%s\n", __func__);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (!uep->desc) {\r\ndev_dbg(udc->isp->dev, "%s: endpoint not enabled\n", __func__);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nuep->desc = NULL;\r\nuep->maxpacket = 0;\r\nisp1760_udc_select_ep(uep);\r\nisp1760_udc_write(udc, DC_EPTYPE, 0);\r\nlist_splice_init(&uep->queue, &req_list);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nlist_for_each_entry_safe(req, nreq, &req_list, queue) {\r\nlist_del(&req->queue);\r\nisp1760_udc_request_complete(uep, req, -ESHUTDOWN);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct usb_request *isp1760_ep_alloc_request(struct usb_ep *ep,\r\ngfp_t gfp_flags)\r\n{\r\nstruct isp1760_request *req;\r\nreq = kzalloc(sizeof(*req), gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nreturn &req->req;\r\n}\r\nstatic void isp1760_ep_free_request(struct usb_ep *ep, struct usb_request *_req)\r\n{\r\nstruct isp1760_request *req = req_to_udc_req(_req);\r\nkfree(req);\r\n}\r\nstatic int isp1760_ep_queue(struct usb_ep *ep, struct usb_request *_req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct isp1760_request *req = req_to_udc_req(_req);\r\nstruct isp1760_ep *uep = ep_to_udc_ep(ep);\r\nstruct isp1760_udc *udc = uep->udc;\r\nbool complete = false;\r\nunsigned long flags;\r\nint ret = 0;\r\n_req->status = -EINPROGRESS;\r\n_req->actual = 0;\r\nspin_lock_irqsave(&udc->lock, flags);\r\ndev_dbg(udc->isp->dev,\r\n"%s: req %p (%u bytes%s) ep %p(0x%02x)\n", __func__, _req,\r\n_req->length, _req->zero ? " (zlp)" : "", uep, uep->addr);\r\nreq->ep = uep;\r\nif (uep->addr == 0) {\r\nif (_req->length != udc->ep0_length &&\r\nudc->ep0_state != ISP1760_CTRL_DATA_IN) {\r\ndev_dbg(udc->isp->dev,\r\n"%s: invalid length %u for req %p\n",\r\n__func__, _req->length, req);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nswitch (udc->ep0_state) {\r\ncase ISP1760_CTRL_DATA_IN:\r\ndev_dbg(udc->isp->dev, "%s: transmitting req %p\n",\r\n__func__, req);\r\nlist_add_tail(&req->queue, &uep->queue);\r\nisp1760_udc_transmit(uep, req);\r\nbreak;\r\ncase ISP1760_CTRL_DATA_OUT:\r\nlist_add_tail(&req->queue, &uep->queue);\r\n__isp1760_udc_select_ep(uep, USB_DIR_OUT);\r\nisp1760_udc_write(udc, DC_CTRLFUNC, DC_DSEN);\r\nbreak;\r\ncase ISP1760_CTRL_STATUS:\r\ncomplete = true;\r\nbreak;\r\ndefault:\r\ndev_dbg(udc->isp->dev, "%s: invalid ep0 state\n",\r\n__func__);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n} else if (uep->desc) {\r\nbool empty = list_empty(&uep->queue);\r\nlist_add_tail(&req->queue, &uep->queue);\r\nif ((uep->addr & USB_DIR_IN) && !uep->halted && empty)\r\nisp1760_udc_transmit(uep, req);\r\nelse if (!(uep->addr & USB_DIR_IN) && uep->rx_pending)\r\ncomplete = isp1760_udc_receive(uep, req);\r\n} else {\r\ndev_dbg(udc->isp->dev,\r\n"%s: can't queue request to disabled ep%02x\n",\r\n__func__, uep->addr);\r\nret = -ESHUTDOWN;\r\n}\r\ndone:\r\nif (ret < 0)\r\nreq->ep = NULL;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nif (complete)\r\nisp1760_udc_request_complete(uep, req, 0);\r\nreturn ret;\r\n}\r\nstatic int isp1760_ep_dequeue(struct usb_ep *ep, struct usb_request *_req)\r\n{\r\nstruct isp1760_request *req = req_to_udc_req(_req);\r\nstruct isp1760_ep *uep = ep_to_udc_ep(ep);\r\nstruct isp1760_udc *udc = uep->udc;\r\nunsigned long flags;\r\ndev_dbg(uep->udc->isp->dev, "%s(ep%02x)\n", __func__, uep->addr);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (req->ep != uep)\r\nreq = NULL;\r\nelse\r\nlist_del(&req->queue);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nif (!req)\r\nreturn -EINVAL;\r\nisp1760_udc_request_complete(uep, req, -ECONNRESET);\r\nreturn 0;\r\n}\r\nstatic int __isp1760_ep_set_halt(struct isp1760_ep *uep, bool stall, bool wedge)\r\n{\r\nstruct isp1760_udc *udc = uep->udc;\r\nint ret;\r\nif (!uep->addr) {\r\nif (WARN_ON(udc->ep0_state == ISP1760_CTRL_SETUP || !stall ||\r\nwedge)) {\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (uep->addr && !uep->desc) {\r\ndev_dbg(udc->isp->dev, "%s: ep%02x is disabled\n", __func__,\r\nuep->addr);\r\nreturn -EINVAL;\r\n}\r\nif (uep->addr & USB_DIR_IN) {\r\nif (!list_empty(&uep->queue)) {\r\ndev_dbg(udc->isp->dev,\r\n"%s: ep%02x has request pending\n", __func__,\r\nuep->addr);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nret = __isp1760_udc_set_halt(uep, stall);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!uep->addr) {\r\nudc->ep0_state = ISP1760_CTRL_SETUP;\r\nreturn 0;\r\n}\r\nif (wedge)\r\nuep->wedged = true;\r\nelse if (!stall)\r\nuep->wedged = false;\r\nreturn 0;\r\n}\r\nstatic int isp1760_ep_set_halt(struct usb_ep *ep, int value)\r\n{\r\nstruct isp1760_ep *uep = ep_to_udc_ep(ep);\r\nunsigned long flags;\r\nint ret;\r\ndev_dbg(uep->udc->isp->dev, "%s: %s halt on ep%02x\n", __func__,\r\nvalue ? "set" : "clear", uep->addr);\r\nspin_lock_irqsave(&uep->udc->lock, flags);\r\nret = __isp1760_ep_set_halt(uep, value, false);\r\nspin_unlock_irqrestore(&uep->udc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int isp1760_ep_set_wedge(struct usb_ep *ep)\r\n{\r\nstruct isp1760_ep *uep = ep_to_udc_ep(ep);\r\nunsigned long flags;\r\nint ret;\r\ndev_dbg(uep->udc->isp->dev, "%s: set wedge on ep%02x)\n", __func__,\r\nuep->addr);\r\nspin_lock_irqsave(&uep->udc->lock, flags);\r\nret = __isp1760_ep_set_halt(uep, true, true);\r\nspin_unlock_irqrestore(&uep->udc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void isp1760_ep_fifo_flush(struct usb_ep *ep)\r\n{\r\nstruct isp1760_ep *uep = ep_to_udc_ep(ep);\r\nstruct isp1760_udc *udc = uep->udc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nisp1760_udc_select_ep(uep);\r\nisp1760_udc_write(udc, DC_CTRLFUNC, DC_CLBUF);\r\nisp1760_udc_write(udc, DC_CTRLFUNC, DC_CLBUF);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\n}\r\nstatic void isp1760_udc_connect(struct isp1760_udc *udc)\r\n{\r\nusb_gadget_set_state(&udc->gadget, USB_STATE_POWERED);\r\nmod_timer(&udc->vbus_timer, jiffies + ISP1760_VBUS_POLL_INTERVAL);\r\n}\r\nstatic void isp1760_udc_disconnect(struct isp1760_udc *udc)\r\n{\r\nif (udc->gadget.state < USB_STATE_POWERED)\r\nreturn;\r\ndev_dbg(udc->isp->dev, "Device disconnected in state %u\n",\r\nudc->gadget.state);\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nusb_gadget_set_state(&udc->gadget, USB_STATE_ATTACHED);\r\nif (udc->driver->disconnect)\r\nudc->driver->disconnect(&udc->gadget);\r\ndel_timer(&udc->vbus_timer);\r\n}\r\nstatic void isp1760_udc_init_hw(struct isp1760_udc *udc)\r\n{\r\nisp1760_udc_write(udc, DC_INTCONF, DC_CDBGMOD_ACK | DC_DDBGMODIN_ACK |\r\nDC_DDBGMODOUT_ACK_NYET);\r\nisp1760_udc_write(udc, DC_INTENABLE, DC_IEPRXTX(7) | DC_IEPRXTX(6) |\r\nDC_IEPRXTX(5) | DC_IEPRXTX(4) | DC_IEPRXTX(3) |\r\nDC_IEPRXTX(2) | DC_IEPRXTX(1) | DC_IEPRXTX(0) |\r\nDC_IEP0SETUP | DC_IEVBUS | DC_IERESM | DC_IESUSP |\r\nDC_IEHS_STA | DC_IEBRST);\r\nif (udc->connected)\r\nisp1760_set_pullup(udc->isp, true);\r\nisp1760_udc_write(udc, DC_ADDRESS, DC_DEVEN);\r\n}\r\nstatic void isp1760_udc_reset(struct isp1760_udc *udc)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nisp1760_udc_init_hw(udc);\r\nudc->ep0_state = ISP1760_CTRL_SETUP;\r\nudc->gadget.speed = USB_SPEED_FULL;\r\nusb_gadget_udc_reset(&udc->gadget, udc->driver);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\n}\r\nstatic void isp1760_udc_suspend(struct isp1760_udc *udc)\r\n{\r\nif (udc->gadget.state < USB_STATE_DEFAULT)\r\nreturn;\r\nif (udc->driver->suspend)\r\nudc->driver->suspend(&udc->gadget);\r\n}\r\nstatic void isp1760_udc_resume(struct isp1760_udc *udc)\r\n{\r\nif (udc->gadget.state < USB_STATE_DEFAULT)\r\nreturn;\r\nif (udc->driver->resume)\r\nudc->driver->resume(&udc->gadget);\r\n}\r\nstatic int isp1760_udc_get_frame(struct usb_gadget *gadget)\r\n{\r\nstruct isp1760_udc *udc = gadget_to_udc(gadget);\r\nreturn isp1760_udc_read(udc, DC_FRAMENUM) & ((1 << 11) - 1);\r\n}\r\nstatic int isp1760_udc_wakeup(struct usb_gadget *gadget)\r\n{\r\nstruct isp1760_udc *udc = gadget_to_udc(gadget);\r\ndev_dbg(udc->isp->dev, "%s\n", __func__);\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int isp1760_udc_set_selfpowered(struct usb_gadget *gadget,\r\nint is_selfpowered)\r\n{\r\nstruct isp1760_udc *udc = gadget_to_udc(gadget);\r\nif (is_selfpowered)\r\nudc->devstatus |= 1 << USB_DEVICE_SELF_POWERED;\r\nelse\r\nudc->devstatus &= ~(1 << USB_DEVICE_SELF_POWERED);\r\nreturn 0;\r\n}\r\nstatic int isp1760_udc_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct isp1760_udc *udc = gadget_to_udc(gadget);\r\nisp1760_set_pullup(udc->isp, is_on);\r\nudc->connected = is_on;\r\nreturn 0;\r\n}\r\nstatic int isp1760_udc_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct isp1760_udc *udc = gadget_to_udc(gadget);\r\nunsigned long flags;\r\nif (driver->max_speed < USB_SPEED_FULL) {\r\ndev_err(udc->isp->dev, "Invalid gadget driver\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (udc->driver) {\r\ndev_err(udc->isp->dev, "UDC already has a gadget driver\n");\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn -EBUSY;\r\n}\r\nudc->driver = driver;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\ndev_dbg(udc->isp->dev, "starting UDC with driver %s\n",\r\ndriver->function);\r\nudc->devstatus = 0;\r\nudc->connected = true;\r\nusb_gadget_set_state(&udc->gadget, USB_STATE_ATTACHED);\r\nisp1760_udc_write(udc, DC_MODE, DC_GLINTENA);\r\nisp1760_udc_init_hw(udc);\r\ndev_dbg(udc->isp->dev, "UDC started with driver %s\n",\r\ndriver->function);\r\nreturn 0;\r\n}\r\nstatic int isp1760_udc_stop(struct usb_gadget *gadget)\r\n{\r\nstruct isp1760_udc *udc = gadget_to_udc(gadget);\r\nunsigned long flags;\r\ndev_dbg(udc->isp->dev, "%s\n", __func__);\r\ndel_timer_sync(&udc->vbus_timer);\r\nisp1760_udc_write(udc, DC_MODE, 0);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nudc->driver = NULL;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t isp1760_udc_irq(int irq, void *dev)\r\n{\r\nstruct isp1760_udc *udc = dev;\r\nunsigned int i;\r\nu32 status;\r\nstatus = isp1760_udc_read(udc, DC_INTERRUPT)\r\n& isp1760_udc_read(udc, DC_INTENABLE);\r\nisp1760_udc_write(udc, DC_INTERRUPT, status);\r\nif (status & DC_IEVBUS) {\r\ndev_dbg(udc->isp->dev, "%s(VBUS)\n", __func__);\r\nspin_lock(&udc->lock);\r\nisp1760_udc_connect(udc);\r\nspin_unlock(&udc->lock);\r\n}\r\nif (status & DC_IEBRST) {\r\ndev_dbg(udc->isp->dev, "%s(BRST)\n", __func__);\r\nisp1760_udc_reset(udc);\r\n}\r\nfor (i = 0; i <= 7; ++i) {\r\nstruct isp1760_ep *ep = &udc->ep[i*2];\r\nif (status & DC_IEPTX(i)) {\r\ndev_dbg(udc->isp->dev, "%s(EPTX%u)\n", __func__, i);\r\nisp1760_ep_tx_complete(ep);\r\n}\r\nif (status & DC_IEPRX(i)) {\r\ndev_dbg(udc->isp->dev, "%s(EPRX%u)\n", __func__, i);\r\nisp1760_ep_rx_ready(i ? ep - 1 : ep);\r\n}\r\n}\r\nif (status & DC_IEP0SETUP) {\r\ndev_dbg(udc->isp->dev, "%s(EP0SETUP)\n", __func__);\r\nisp1760_ep0_setup(udc);\r\n}\r\nif (status & DC_IERESM) {\r\ndev_dbg(udc->isp->dev, "%s(RESM)\n", __func__);\r\nisp1760_udc_resume(udc);\r\n}\r\nif (status & DC_IESUSP) {\r\ndev_dbg(udc->isp->dev, "%s(SUSP)\n", __func__);\r\nspin_lock(&udc->lock);\r\nif (!(isp1760_udc_read(udc, DC_MODE) & DC_VBUSSTAT))\r\nisp1760_udc_disconnect(udc);\r\nelse\r\nisp1760_udc_suspend(udc);\r\nspin_unlock(&udc->lock);\r\n}\r\nif (status & DC_IEHS_STA) {\r\ndev_dbg(udc->isp->dev, "%s(HS_STA)\n", __func__);\r\nudc->gadget.speed = USB_SPEED_HIGH;\r\n}\r\nreturn status ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic void isp1760_udc_vbus_poll(unsigned long data)\r\n{\r\nstruct isp1760_udc *udc = (struct isp1760_udc *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (!(isp1760_udc_read(udc, DC_MODE) & DC_VBUSSTAT))\r\nisp1760_udc_disconnect(udc);\r\nelse if (udc->gadget.state >= USB_STATE_POWERED)\r\nmod_timer(&udc->vbus_timer,\r\njiffies + ISP1760_VBUS_POLL_INTERVAL);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\n}\r\nstatic void isp1760_udc_init_eps(struct isp1760_udc *udc)\r\n{\r\nunsigned int i;\r\nINIT_LIST_HEAD(&udc->gadget.ep_list);\r\nfor (i = 0; i < ARRAY_SIZE(udc->ep); ++i) {\r\nstruct isp1760_ep *ep = &udc->ep[i];\r\nunsigned int ep_num = (i + 1) / 2;\r\nbool is_in = !(i & 1);\r\nep->udc = udc;\r\nINIT_LIST_HEAD(&ep->queue);\r\nep->addr = (ep_num && is_in ? USB_DIR_IN : USB_DIR_OUT)\r\n| ep_num;\r\nep->desc = NULL;\r\nsprintf(ep->name, "ep%u%s", ep_num,\r\nep_num ? (is_in ? "in" : "out") : "");\r\nep->ep.ops = &isp1760_ep_ops;\r\nep->ep.name = ep->name;\r\nif (ep_num == 0) {\r\nusb_ep_set_maxpacket_limit(&ep->ep, 64);\r\nep->ep.caps.type_control = true;\r\nep->ep.caps.dir_in = true;\r\nep->ep.caps.dir_out = true;\r\nep->maxpacket = 64;\r\nudc->gadget.ep0 = &ep->ep;\r\n} else {\r\nusb_ep_set_maxpacket_limit(&ep->ep, 512);\r\nep->ep.caps.type_iso = true;\r\nep->ep.caps.type_bulk = true;\r\nep->ep.caps.type_int = true;\r\nep->maxpacket = 0;\r\nlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\r\n}\r\nif (is_in)\r\nep->ep.caps.dir_in = true;\r\nelse\r\nep->ep.caps.dir_out = true;\r\n}\r\n}\r\nstatic int isp1760_udc_init(struct isp1760_udc *udc)\r\n{\r\nu16 scratch;\r\nu32 chipid;\r\nisp1760_udc_write(udc, DC_SCRATCH, 0xbabe);\r\nchipid = isp1760_udc_read(udc, DC_CHIPID);\r\nscratch = isp1760_udc_read(udc, DC_SCRATCH);\r\nif (scratch != 0xbabe) {\r\ndev_err(udc->isp->dev,\r\n"udc: scratch test failed (0x%04x/0x%08x)\n",\r\nscratch, chipid);\r\nreturn -ENODEV;\r\n}\r\nif (chipid != 0x00011582 && chipid != 0x00158210) {\r\ndev_err(udc->isp->dev, "udc: invalid chip ID 0x%08x\n", chipid);\r\nreturn -ENODEV;\r\n}\r\nisp1760_udc_write(udc, DC_MODE, DC_SFRESET);\r\nusleep_range(10000, 11000);\r\nisp1760_udc_write(udc, DC_MODE, 0);\r\nusleep_range(10000, 11000);\r\nreturn 0;\r\n}\r\nint isp1760_udc_register(struct isp1760_device *isp, int irq,\r\nunsigned long irqflags)\r\n{\r\nstruct isp1760_udc *udc = &isp->udc;\r\nconst char *devname;\r\nint ret;\r\nudc->irq = -1;\r\nudc->isp = isp;\r\nudc->regs = isp->regs;\r\nspin_lock_init(&udc->lock);\r\nsetup_timer(&udc->vbus_timer, isp1760_udc_vbus_poll,\r\n(unsigned long)udc);\r\nret = isp1760_udc_init(udc);\r\nif (ret < 0)\r\nreturn ret;\r\ndevname = dev_name(isp->dev);\r\nudc->irqname = kmalloc(strlen(devname) + 7, GFP_KERNEL);\r\nif (!udc->irqname)\r\nreturn -ENOMEM;\r\nsprintf(udc->irqname, "%s (udc)", devname);\r\nret = request_irq(irq, isp1760_udc_irq, IRQF_SHARED | irqflags,\r\nudc->irqname, udc);\r\nif (ret < 0)\r\ngoto error;\r\nudc->irq = irq;\r\nudc->gadget.ops = &isp1760_udc_ops;\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nudc->gadget.max_speed = USB_SPEED_HIGH;\r\nudc->gadget.name = "isp1761_udc";\r\nisp1760_udc_init_eps(udc);\r\nret = usb_add_gadget_udc(isp->dev, &udc->gadget);\r\nif (ret < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nif (udc->irq >= 0)\r\nfree_irq(udc->irq, udc);\r\nkfree(udc->irqname);\r\nreturn ret;\r\n}\r\nvoid isp1760_udc_unregister(struct isp1760_device *isp)\r\n{\r\nstruct isp1760_udc *udc = &isp->udc;\r\nif (!udc->isp)\r\nreturn;\r\nusb_del_gadget_udc(&udc->gadget);\r\nfree_irq(udc->irq, udc);\r\nkfree(udc->irqname);\r\n}
