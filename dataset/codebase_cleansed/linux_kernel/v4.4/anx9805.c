static int\r\nanx9805_bus_xfer(struct nvkm_i2c_bus *base, struct i2c_msg *msgs, int num)\r\n{\r\nstruct anx9805_bus *bus = anx9805_bus(base);\r\nstruct anx9805_pad *pad = bus->pad;\r\nstruct i2c_adapter *adap = &pad->bus->i2c;\r\nstruct i2c_msg *msg = msgs;\r\nint ret = -ETIMEDOUT;\r\nint i, j, cnt = num;\r\nu8 seg = 0x00, off = 0x00, tmp;\r\ntmp = nvkm_rdi2cr(adap, pad->addr, 0x07) & ~0x10;\r\nnvkm_wri2cr(adap, pad->addr, 0x07, tmp | 0x10);\r\nnvkm_wri2cr(adap, pad->addr, 0x07, tmp);\r\nnvkm_wri2cr(adap, bus->addr, 0x43, 0x05);\r\nmdelay(5);\r\nwhile (cnt--) {\r\nif ( (msg->flags & I2C_M_RD) && msg->addr == 0x50) {\r\nnvkm_wri2cr(adap, bus->addr, 0x40, msg->addr << 1);\r\nnvkm_wri2cr(adap, bus->addr, 0x41, seg);\r\nnvkm_wri2cr(adap, bus->addr, 0x42, off);\r\nnvkm_wri2cr(adap, bus->addr, 0x44, msg->len);\r\nnvkm_wri2cr(adap, bus->addr, 0x45, 0x00);\r\nnvkm_wri2cr(adap, bus->addr, 0x43, 0x01);\r\nfor (i = 0; i < msg->len; i++) {\r\nj = 0;\r\nwhile (nvkm_rdi2cr(adap, bus->addr, 0x46) & 0x10) {\r\nmdelay(5);\r\nif (j++ == 32)\r\ngoto done;\r\n}\r\nmsg->buf[i] = nvkm_rdi2cr(adap, bus->addr, 0x47);\r\n}\r\n} else\r\nif (!(msg->flags & I2C_M_RD)) {\r\nif (msg->addr == 0x50 && msg->len == 0x01) {\r\noff = msg->buf[0];\r\n} else\r\nif (msg->addr == 0x30 && msg->len == 0x01) {\r\nseg = msg->buf[0];\r\n} else\r\ngoto done;\r\n} else {\r\ngoto done;\r\n}\r\nmsg++;\r\n}\r\nret = num;\r\ndone:\r\nnvkm_wri2cr(adap, bus->addr, 0x43, 0x00);\r\nreturn ret;\r\n}\r\nstatic int\r\nanx9805_bus_new(struct nvkm_i2c_pad *base, int id, u8 drive,\r\nstruct nvkm_i2c_bus **pbus)\r\n{\r\nstruct anx9805_pad *pad = anx9805_pad(base);\r\nstruct anx9805_bus *bus;\r\nint ret;\r\nif (!(bus = kzalloc(sizeof(*bus), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\n*pbus = &bus->base;\r\nbus->pad = pad;\r\nret = nvkm_i2c_bus_ctor(&anx9805_bus_func, &pad->base, id, &bus->base);\r\nif (ret)\r\nreturn ret;\r\nswitch (pad->addr) {\r\ncase 0x39: bus->addr = 0x3d; break;\r\ncase 0x3b: bus->addr = 0x3f; break;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nanx9805_aux_xfer(struct nvkm_i2c_aux *base, bool retry,\r\nu8 type, u32 addr, u8 *data, u8 size)\r\n{\r\nstruct anx9805_aux *aux = anx9805_aux(base);\r\nstruct anx9805_pad *pad = aux->pad;\r\nstruct i2c_adapter *adap = &pad->bus->i2c;\r\nint i, ret = -ETIMEDOUT;\r\nu8 buf[16] = {};\r\nu8 tmp;\r\nAUX_DBG(&aux->base, "%02x %05x %d", type, addr, size);\r\ntmp = nvkm_rdi2cr(adap, pad->addr, 0x07) & ~0x04;\r\nnvkm_wri2cr(adap, pad->addr, 0x07, tmp | 0x04);\r\nnvkm_wri2cr(adap, pad->addr, 0x07, tmp);\r\nnvkm_wri2cr(adap, pad->addr, 0xf7, 0x01);\r\nnvkm_wri2cr(adap, aux->addr, 0xe4, 0x80);\r\nif (!(type & 1)) {\r\nmemcpy(buf, data, size);\r\nAUX_DBG(&aux->base, "%16ph", buf);\r\nfor (i = 0; i < size; i++)\r\nnvkm_wri2cr(adap, aux->addr, 0xf0 + i, buf[i]);\r\n}\r\nnvkm_wri2cr(adap, aux->addr, 0xe5, ((size - 1) << 4) | type);\r\nnvkm_wri2cr(adap, aux->addr, 0xe6, (addr & 0x000ff) >> 0);\r\nnvkm_wri2cr(adap, aux->addr, 0xe7, (addr & 0x0ff00) >> 8);\r\nnvkm_wri2cr(adap, aux->addr, 0xe8, (addr & 0xf0000) >> 16);\r\nnvkm_wri2cr(adap, aux->addr, 0xe9, 0x01);\r\ni = 0;\r\nwhile ((tmp = nvkm_rdi2cr(adap, aux->addr, 0xe9)) & 0x01) {\r\nmdelay(5);\r\nif (i++ == 32)\r\ngoto done;\r\n}\r\nif ((tmp = nvkm_rdi2cr(adap, pad->addr, 0xf7)) & 0x01) {\r\nret = -EIO;\r\ngoto done;\r\n}\r\nif (type & 1) {\r\nfor (i = 0; i < size; i++)\r\nbuf[i] = nvkm_rdi2cr(adap, aux->addr, 0xf0 + i);\r\nAUX_DBG(&aux->base, "%16ph", buf);\r\nmemcpy(data, buf, size);\r\n}\r\nret = 0;\r\ndone:\r\nnvkm_wri2cr(adap, pad->addr, 0xf7, 0x01);\r\nreturn ret;\r\n}\r\nstatic int\r\nanx9805_aux_lnk_ctl(struct nvkm_i2c_aux *base,\r\nint link_nr, int link_bw, bool enh)\r\n{\r\nstruct anx9805_aux *aux = anx9805_aux(base);\r\nstruct anx9805_pad *pad = aux->pad;\r\nstruct i2c_adapter *adap = &pad->bus->i2c;\r\nu8 tmp, i;\r\nAUX_DBG(&aux->base, "ANX9805 train %d %02x %d",\r\nlink_nr, link_bw, enh);\r\nnvkm_wri2cr(adap, aux->addr, 0xa0, link_bw);\r\nnvkm_wri2cr(adap, aux->addr, 0xa1, link_nr | (enh ? 0x80 : 0x00));\r\nnvkm_wri2cr(adap, aux->addr, 0xa2, 0x01);\r\nnvkm_wri2cr(adap, aux->addr, 0xa8, 0x01);\r\ni = 0;\r\nwhile ((tmp = nvkm_rdi2cr(adap, aux->addr, 0xa8)) & 0x01) {\r\nmdelay(5);\r\nif (i++ == 100) {\r\nAUX_ERR(&aux->base, "link training timeout");\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nif (tmp & 0x70) {\r\nAUX_ERR(&aux->base, "link training failed");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nanx9805_aux_new(struct nvkm_i2c_pad *base, int id, u8 drive,\r\nstruct nvkm_i2c_aux **pbus)\r\n{\r\nstruct anx9805_pad *pad = anx9805_pad(base);\r\nstruct anx9805_aux *aux;\r\nint ret;\r\nif (!(aux = kzalloc(sizeof(*aux), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\n*pbus = &aux->base;\r\naux->pad = pad;\r\nret = nvkm_i2c_aux_ctor(&anx9805_aux_func, &pad->base, id, &aux->base);\r\nif (ret)\r\nreturn ret;\r\nswitch (pad->addr) {\r\ncase 0x39: aux->addr = 0x38; break;\r\ncase 0x3b: aux->addr = 0x3c; break;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nanx9805_pad_new(struct nvkm_i2c_bus *bus, int id, u8 addr,\r\nstruct nvkm_i2c_pad **ppad)\r\n{\r\nstruct anx9805_pad *pad;\r\nif (!(pad = kzalloc(sizeof(*pad), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\n*ppad = &pad->base;\r\nnvkm_i2c_pad_ctor(&anx9805_pad_func, bus->pad->i2c, id, &pad->base);\r\npad->bus = bus;\r\npad->addr = addr;\r\nreturn 0;\r\n}
