static void wait_until_divider_stable(void __iomem *div_reg, unsigned long mask)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(10);\r\ndo {\r\nif (!(readl(div_reg) & mask))\r\nreturn;\r\n} while (time_before(jiffies, timeout));\r\nif (!(readl(div_reg) & mask))\r\nreturn;\r\npr_err("%s: timeout in divider stablization\n", __func__);\r\n}\r\nstatic void wait_until_mux_stable(void __iomem *mux_reg, u32 mux_pos,\r\nunsigned long mux_value)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(10);\r\ndo {\r\nif (((readl(mux_reg) >> mux_pos) & MUX_MASK) == mux_value)\r\nreturn;\r\n} while (time_before(jiffies, timeout));\r\nif (((readl(mux_reg) >> mux_pos) & MUX_MASK) == mux_value)\r\nreturn;\r\npr_err("%s: re-parenting mux timed-out\n", __func__);\r\n}\r\nstatic long exynos_cpuclk_round_rate(struct clk_hw *hw,\r\nunsigned long drate, unsigned long *prate)\r\n{\r\nstruct clk_hw *parent = clk_hw_get_parent(hw);\r\n*prate = clk_hw_round_rate(parent, drate);\r\nreturn *prate;\r\n}\r\nstatic unsigned long exynos_cpuclk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn parent_rate;\r\n}\r\nstatic void exynos_set_safe_div(void __iomem *base, unsigned long div,\r\nunsigned long mask)\r\n{\r\nunsigned long div0;\r\ndiv0 = readl(base + E4210_DIV_CPU0);\r\ndiv0 = (div0 & ~mask) | (div & mask);\r\nwritel(div0, base + E4210_DIV_CPU0);\r\nwait_until_divider_stable(base + E4210_DIV_STAT_CPU0, mask);\r\n}\r\nstatic int exynos_cpuclk_pre_rate_change(struct clk_notifier_data *ndata,\r\nstruct exynos_cpuclk *cpuclk, void __iomem *base)\r\n{\r\nconst struct exynos_cpuclk_cfg_data *cfg_data = cpuclk->cfg;\r\nunsigned long alt_prate = clk_get_rate(cpuclk->alt_parent);\r\nunsigned long alt_div = 0, alt_div_mask = DIV_MASK;\r\nunsigned long div0, div1 = 0, mux_reg;\r\nwhile ((cfg_data->prate * 1000) != ndata->new_rate) {\r\nif (cfg_data->prate == 0)\r\nreturn -EINVAL;\r\ncfg_data++;\r\n}\r\nspin_lock(cpuclk->lock);\r\ndiv0 = cfg_data->div0;\r\nif (cpuclk->flags & CLK_CPU_HAS_DIV1) {\r\ndiv1 = cfg_data->div1;\r\nif (readl(base + E4210_SRC_CPU) & E4210_MUX_HPM_MASK)\r\ndiv1 = readl(base + E4210_DIV_CPU1) &\r\n(E4210_DIV1_HPM_MASK | E4210_DIV1_COPY_MASK);\r\n}\r\nif (alt_prate > ndata->old_rate || ndata->old_rate > ndata->new_rate) {\r\nunsigned long tmp_rate = min(ndata->old_rate, ndata->new_rate);\r\nalt_div = DIV_ROUND_UP(alt_prate, tmp_rate) - 1;\r\nWARN_ON(alt_div >= MAX_DIV);\r\nif (cpuclk->flags & CLK_CPU_NEEDS_DEBUG_ALT_DIV) {\r\nalt_div |= E4210_DIV0_ATB_MASK;\r\nalt_div_mask |= E4210_DIV0_ATB_MASK;\r\n}\r\nexynos_set_safe_div(base, alt_div, alt_div_mask);\r\ndiv0 |= alt_div;\r\n}\r\nmux_reg = readl(base + E4210_SRC_CPU);\r\nwritel(mux_reg | (1 << 16), base + E4210_SRC_CPU);\r\nwait_until_mux_stable(base + E4210_STAT_CPU, 16, 2);\r\nwritel(div0, base + E4210_DIV_CPU0);\r\nwait_until_divider_stable(base + E4210_DIV_STAT_CPU0, DIV_MASK_ALL);\r\nif (cpuclk->flags & CLK_CPU_HAS_DIV1) {\r\nwritel(div1, base + E4210_DIV_CPU1);\r\nwait_until_divider_stable(base + E4210_DIV_STAT_CPU1,\r\nDIV_MASK_ALL);\r\n}\r\nspin_unlock(cpuclk->lock);\r\nreturn 0;\r\n}\r\nstatic int exynos_cpuclk_post_rate_change(struct clk_notifier_data *ndata,\r\nstruct exynos_cpuclk *cpuclk, void __iomem *base)\r\n{\r\nconst struct exynos_cpuclk_cfg_data *cfg_data = cpuclk->cfg;\r\nunsigned long div = 0, div_mask = DIV_MASK;\r\nunsigned long mux_reg;\r\nif (cpuclk->flags & CLK_CPU_NEEDS_DEBUG_ALT_DIV) {\r\nwhile ((cfg_data->prate * 1000) != ndata->new_rate) {\r\nif (cfg_data->prate == 0)\r\nreturn -EINVAL;\r\ncfg_data++;\r\n}\r\n}\r\nspin_lock(cpuclk->lock);\r\nmux_reg = readl(base + E4210_SRC_CPU);\r\nwritel(mux_reg & ~(1 << 16), base + E4210_SRC_CPU);\r\nwait_until_mux_stable(base + E4210_STAT_CPU, 16, 1);\r\nif (cpuclk->flags & CLK_CPU_NEEDS_DEBUG_ALT_DIV) {\r\ndiv |= (cfg_data->div0 & E4210_DIV0_ATB_MASK);\r\ndiv_mask |= E4210_DIV0_ATB_MASK;\r\n}\r\nexynos_set_safe_div(base, div, div_mask);\r\nspin_unlock(cpuclk->lock);\r\nreturn 0;\r\n}\r\nstatic int exynos_cpuclk_notifier_cb(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct clk_notifier_data *ndata = data;\r\nstruct exynos_cpuclk *cpuclk;\r\nvoid __iomem *base;\r\nint err = 0;\r\ncpuclk = container_of(nb, struct exynos_cpuclk, clk_nb);\r\nbase = cpuclk->ctrl_base;\r\nif (event == PRE_RATE_CHANGE)\r\nerr = exynos_cpuclk_pre_rate_change(ndata, cpuclk, base);\r\nelse if (event == POST_RATE_CHANGE)\r\nerr = exynos_cpuclk_post_rate_change(ndata, cpuclk, base);\r\nreturn notifier_from_errno(err);\r\n}\r\nint __init exynos_register_cpu_clock(struct samsung_clk_provider *ctx,\r\nunsigned int lookup_id, const char *name, const char *parent,\r\nconst char *alt_parent, unsigned long offset,\r\nconst struct exynos_cpuclk_cfg_data *cfg,\r\nunsigned long num_cfgs, unsigned long flags)\r\n{\r\nstruct exynos_cpuclk *cpuclk;\r\nstruct clk_init_data init;\r\nstruct clk *clk;\r\nint ret = 0;\r\ncpuclk = kzalloc(sizeof(*cpuclk), GFP_KERNEL);\r\nif (!cpuclk)\r\nreturn -ENOMEM;\r\ninit.name = name;\r\ninit.flags = CLK_SET_RATE_PARENT;\r\ninit.parent_names = &parent;\r\ninit.num_parents = 1;\r\ninit.ops = &exynos_cpuclk_clk_ops;\r\ncpuclk->hw.init = &init;\r\ncpuclk->ctrl_base = ctx->reg_base + offset;\r\ncpuclk->lock = &ctx->lock;\r\ncpuclk->flags = flags;\r\ncpuclk->clk_nb.notifier_call = exynos_cpuclk_notifier_cb;\r\ncpuclk->alt_parent = __clk_lookup(alt_parent);\r\nif (!cpuclk->alt_parent) {\r\npr_err("%s: could not lookup alternate parent %s\n",\r\n__func__, alt_parent);\r\nret = -EINVAL;\r\ngoto free_cpuclk;\r\n}\r\nclk = __clk_lookup(parent);\r\nif (!clk) {\r\npr_err("%s: could not lookup parent clock %s\n",\r\n__func__, parent);\r\nret = -EINVAL;\r\ngoto free_cpuclk;\r\n}\r\nret = clk_notifier_register(clk, &cpuclk->clk_nb);\r\nif (ret) {\r\npr_err("%s: failed to register clock notifier for %s\n",\r\n__func__, name);\r\ngoto free_cpuclk;\r\n}\r\ncpuclk->cfg = kmemdup(cfg, sizeof(*cfg) * num_cfgs, GFP_KERNEL);\r\nif (!cpuclk->cfg) {\r\npr_err("%s: could not allocate memory for cpuclk data\n",\r\n__func__);\r\nret = -ENOMEM;\r\ngoto unregister_clk_nb;\r\n}\r\nclk = clk_register(NULL, &cpuclk->hw);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: could not register cpuclk %s\n", __func__, name);\r\nret = PTR_ERR(clk);\r\ngoto free_cpuclk_data;\r\n}\r\nsamsung_clk_add_lookup(ctx, clk, lookup_id);\r\nreturn 0;\r\nfree_cpuclk_data:\r\nkfree(cpuclk->cfg);\r\nunregister_clk_nb:\r\nclk_notifier_unregister(__clk_lookup(parent), &cpuclk->clk_nb);\r\nfree_cpuclk:\r\nkfree(cpuclk);\r\nreturn ret;\r\n}
