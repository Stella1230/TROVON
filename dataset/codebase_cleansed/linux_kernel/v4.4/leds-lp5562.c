static inline void lp5562_wait_opmode_done(void)\r\n{\r\nusleep_range(200, 300);\r\n}\r\nstatic inline void lp5562_wait_enable_done(void)\r\n{\r\nusleep_range(500, 600);\r\n}\r\nstatic void lp5562_set_led_current(struct lp55xx_led *led, u8 led_current)\r\n{\r\nu8 addr[] = {\r\nLP5562_REG_R_CURRENT,\r\nLP5562_REG_G_CURRENT,\r\nLP5562_REG_B_CURRENT,\r\nLP5562_REG_W_CURRENT,\r\n};\r\nled->led_current = led_current;\r\nlp55xx_write(led->chip, addr[led->chan_nr], led_current);\r\n}\r\nstatic void lp5562_load_engine(struct lp55xx_chip *chip)\r\n{\r\nenum lp55xx_engine_index idx = chip->engine_idx;\r\nu8 mask[] = {\r\n[LP55XX_ENGINE_1] = LP5562_MODE_ENG1_M,\r\n[LP55XX_ENGINE_2] = LP5562_MODE_ENG2_M,\r\n[LP55XX_ENGINE_3] = LP5562_MODE_ENG3_M,\r\n};\r\nu8 val[] = {\r\n[LP55XX_ENGINE_1] = LP5562_LOAD_ENG1,\r\n[LP55XX_ENGINE_2] = LP5562_LOAD_ENG2,\r\n[LP55XX_ENGINE_3] = LP5562_LOAD_ENG3,\r\n};\r\nlp55xx_update_bits(chip, LP5562_REG_OP_MODE, mask[idx], val[idx]);\r\nlp5562_wait_opmode_done();\r\n}\r\nstatic void lp5562_stop_engine(struct lp55xx_chip *chip)\r\n{\r\nlp55xx_write(chip, LP5562_REG_OP_MODE, LP5562_CMD_DISABLE);\r\nlp5562_wait_opmode_done();\r\n}\r\nstatic void lp5562_run_engine(struct lp55xx_chip *chip, bool start)\r\n{\r\nint ret;\r\nu8 mode;\r\nu8 exec;\r\nif (!start) {\r\nlp55xx_write(chip, LP5562_REG_ENABLE, LP5562_ENABLE_DEFAULT);\r\nlp5562_wait_enable_done();\r\nlp5562_stop_engine(chip);\r\nlp55xx_write(chip, LP5562_REG_ENG_SEL, LP5562_ENG_SEL_PWM);\r\nlp55xx_write(chip, LP5562_REG_OP_MODE, LP5562_CMD_DIRECT);\r\nlp5562_wait_opmode_done();\r\nreturn;\r\n}\r\nret = lp55xx_read(chip, LP5562_REG_OP_MODE, &mode);\r\nif (ret)\r\nreturn;\r\nret = lp55xx_read(chip, LP5562_REG_ENABLE, &exec);\r\nif (ret)\r\nreturn;\r\nif (LP5562_ENG1_IS_LOADING(mode)) {\r\nmode = (mode & ~LP5562_MODE_ENG1_M) | LP5562_RUN_ENG1;\r\nexec = (exec & ~LP5562_EXEC_ENG1_M) | LP5562_RUN_ENG1;\r\n}\r\nif (LP5562_ENG2_IS_LOADING(mode)) {\r\nmode = (mode & ~LP5562_MODE_ENG2_M) | LP5562_RUN_ENG2;\r\nexec = (exec & ~LP5562_EXEC_ENG2_M) | LP5562_RUN_ENG2;\r\n}\r\nif (LP5562_ENG3_IS_LOADING(mode)) {\r\nmode = (mode & ~LP5562_MODE_ENG3_M) | LP5562_RUN_ENG3;\r\nexec = (exec & ~LP5562_EXEC_ENG3_M) | LP5562_RUN_ENG3;\r\n}\r\nlp55xx_write(chip, LP5562_REG_OP_MODE, mode);\r\nlp5562_wait_opmode_done();\r\nlp55xx_update_bits(chip, LP5562_REG_ENABLE, LP5562_EXEC_M, exec);\r\nlp5562_wait_enable_done();\r\n}\r\nstatic int lp5562_update_firmware(struct lp55xx_chip *chip,\r\nconst u8 *data, size_t size)\r\n{\r\nenum lp55xx_engine_index idx = chip->engine_idx;\r\nu8 pattern[LP5562_PROGRAM_LENGTH] = {0};\r\nu8 addr[] = {\r\n[LP55XX_ENGINE_1] = LP5562_REG_PROG_MEM_ENG1,\r\n[LP55XX_ENGINE_2] = LP5562_REG_PROG_MEM_ENG2,\r\n[LP55XX_ENGINE_3] = LP5562_REG_PROG_MEM_ENG3,\r\n};\r\nunsigned cmd;\r\nchar c[3];\r\nint program_size;\r\nint nrchars;\r\nint offset = 0;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < LP5562_PROGRAM_LENGTH; i++)\r\nlp55xx_write(chip, addr[idx] + i, 0);\r\ni = 0;\r\nwhile ((offset < size - 1) && (i < LP5562_PROGRAM_LENGTH)) {\r\nret = sscanf(data + offset, "%2s%n ", c, &nrchars);\r\nif (ret != 1)\r\ngoto err;\r\nret = sscanf(c, "%2x", &cmd);\r\nif (ret != 1)\r\ngoto err;\r\npattern[i] = (u8)cmd;\r\noffset += nrchars;\r\ni++;\r\n}\r\nif (i % 2)\r\ngoto err;\r\nprogram_size = i;\r\nfor (i = 0; i < program_size; i++)\r\nlp55xx_write(chip, addr[idx] + i, pattern[i]);\r\nreturn 0;\r\nerr:\r\ndev_err(&chip->cl->dev, "wrong pattern format\n");\r\nreturn -EINVAL;\r\n}\r\nstatic void lp5562_firmware_loaded(struct lp55xx_chip *chip)\r\n{\r\nconst struct firmware *fw = chip->fw;\r\nif (fw->size > LP5562_PROGRAM_LENGTH) {\r\ndev_err(&chip->cl->dev, "firmware data size overflow: %zu\n",\r\nfw->size);\r\nreturn;\r\n}\r\nlp5562_load_engine(chip);\r\nlp5562_update_firmware(chip, fw->data, fw->size);\r\n}\r\nstatic int lp5562_post_init_device(struct lp55xx_chip *chip)\r\n{\r\nint ret;\r\nu8 cfg = LP5562_DEFAULT_CFG;\r\nret = lp55xx_write(chip, LP5562_REG_OP_MODE, LP5562_CMD_DIRECT);\r\nif (ret)\r\nreturn ret;\r\nlp5562_wait_opmode_done();\r\nif (!lp55xx_is_extclk_used(chip))\r\ncfg |= LP5562_CLK_INT;\r\nret = lp55xx_write(chip, LP5562_REG_CONFIG, cfg);\r\nif (ret)\r\nreturn ret;\r\nlp55xx_write(chip, LP5562_REG_R_PWM, 0);\r\nlp55xx_write(chip, LP5562_REG_G_PWM, 0);\r\nlp55xx_write(chip, LP5562_REG_B_PWM, 0);\r\nlp55xx_write(chip, LP5562_REG_W_PWM, 0);\r\nlp55xx_write(chip, LP5562_REG_ENG_SEL, LP5562_ENG_SEL_PWM);\r\nreturn 0;\r\n}\r\nstatic void lp5562_led_brightness_work(struct work_struct *work)\r\n{\r\nstruct lp55xx_led *led = container_of(work, struct lp55xx_led,\r\nbrightness_work);\r\nstruct lp55xx_chip *chip = led->chip;\r\nu8 addr[] = {\r\nLP5562_REG_R_PWM,\r\nLP5562_REG_G_PWM,\r\nLP5562_REG_B_PWM,\r\nLP5562_REG_W_PWM,\r\n};\r\nmutex_lock(&chip->lock);\r\nlp55xx_write(chip, addr[led->chan_nr], led->brightness);\r\nmutex_unlock(&chip->lock);\r\n}\r\nstatic void lp5562_write_program_memory(struct lp55xx_chip *chip,\r\nu8 base, const u8 *rgb, int size)\r\n{\r\nint i;\r\nif (!rgb || size <= 0)\r\nreturn;\r\nfor (i = 0; i < size; i++)\r\nlp55xx_write(chip, base + i, *(rgb + i));\r\nlp55xx_write(chip, base + i, 0);\r\nlp55xx_write(chip, base + i + 1, 0);\r\n}\r\nstatic inline bool _is_pc_overflow(struct lp55xx_predef_pattern *ptn)\r\n{\r\nreturn ptn->size_r >= LP5562_PROGRAM_LENGTH ||\r\nptn->size_g >= LP5562_PROGRAM_LENGTH ||\r\nptn->size_b >= LP5562_PROGRAM_LENGTH;\r\n}\r\nstatic int lp5562_run_predef_led_pattern(struct lp55xx_chip *chip, int mode)\r\n{\r\nstruct lp55xx_predef_pattern *ptn;\r\nint i;\r\nif (mode == LP5562_PATTERN_OFF) {\r\nlp5562_run_engine(chip, false);\r\nreturn 0;\r\n}\r\nptn = chip->pdata->patterns + (mode - 1);\r\nif (!ptn || _is_pc_overflow(ptn)) {\r\ndev_err(&chip->cl->dev, "invalid pattern data\n");\r\nreturn -EINVAL;\r\n}\r\nlp5562_stop_engine(chip);\r\nlp55xx_write(chip, LP5562_REG_ENG_SEL, LP5562_ENG_SEL_RGB);\r\nfor (i = LP55XX_ENGINE_1; i <= LP55XX_ENGINE_3; i++) {\r\nchip->engine_idx = i;\r\nlp5562_load_engine(chip);\r\n}\r\nlp55xx_write(chip, LP5562_REG_PROG_MEM_ENG1, 0);\r\nlp55xx_write(chip, LP5562_REG_PROG_MEM_ENG1 + 1, 0);\r\nlp55xx_write(chip, LP5562_REG_PROG_MEM_ENG2, 0);\r\nlp55xx_write(chip, LP5562_REG_PROG_MEM_ENG2 + 1, 0);\r\nlp55xx_write(chip, LP5562_REG_PROG_MEM_ENG3, 0);\r\nlp55xx_write(chip, LP5562_REG_PROG_MEM_ENG3 + 1, 0);\r\nlp5562_write_program_memory(chip, LP5562_REG_PROG_MEM_ENG1,\r\nptn->r, ptn->size_r);\r\nlp5562_write_program_memory(chip, LP5562_REG_PROG_MEM_ENG2,\r\nptn->g, ptn->size_g);\r\nlp5562_write_program_memory(chip, LP5562_REG_PROG_MEM_ENG3,\r\nptn->b, ptn->size_b);\r\nlp5562_run_engine(chip, true);\r\nreturn 0;\r\n}\r\nstatic ssize_t lp5562_store_pattern(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct lp55xx_chip *chip = led->chip;\r\nstruct lp55xx_predef_pattern *ptn = chip->pdata->patterns;\r\nint num_patterns = chip->pdata->num_patterns;\r\nunsigned long mode;\r\nint ret;\r\nret = kstrtoul(buf, 0, &mode);\r\nif (ret)\r\nreturn ret;\r\nif (mode > num_patterns || !ptn)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->lock);\r\nret = lp5562_run_predef_led_pattern(chip, mode);\r\nmutex_unlock(&chip->lock);\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic ssize_t lp5562_store_engine_mux(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct lp55xx_chip *chip = led->chip;\r\nu8 mask;\r\nu8 val;\r\nif (sysfs_streq(buf, "RGB")) {\r\nmask = LP5562_ENG_FOR_RGB_M;\r\nval = LP5562_ENG_SEL_RGB;\r\n} else if (sysfs_streq(buf, "W")) {\r\nenum lp55xx_engine_index idx = chip->engine_idx;\r\nmask = LP5562_ENG_FOR_W_M;\r\nswitch (idx) {\r\ncase LP55XX_ENGINE_1:\r\nval = LP5562_ENG1_FOR_W;\r\nbreak;\r\ncase LP55XX_ENGINE_2:\r\nval = LP5562_ENG2_FOR_W;\r\nbreak;\r\ncase LP55XX_ENGINE_3:\r\nval = LP5562_ENG3_FOR_W;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n} else {\r\ndev_err(dev, "choose RGB or W\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&chip->lock);\r\nlp55xx_update_bits(chip, LP5562_REG_ENG_SEL, mask, val);\r\nmutex_unlock(&chip->lock);\r\nreturn len;\r\n}\r\nstatic int lp5562_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct lp55xx_chip *chip;\r\nstruct lp55xx_led *led;\r\nstruct lp55xx_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct device_node *np = client->dev.of_node;\r\nif (!pdata) {\r\nif (np) {\r\npdata = lp55xx_of_populate_pdata(&client->dev, np);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\n} else {\r\ndev_err(&client->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nled = devm_kzalloc(&client->dev,\r\nsizeof(*led) * pdata->num_channels, GFP_KERNEL);\r\nif (!led)\r\nreturn -ENOMEM;\r\nchip->cl = client;\r\nchip->pdata = pdata;\r\nchip->cfg = &lp5562_cfg;\r\nmutex_init(&chip->lock);\r\ni2c_set_clientdata(client, led);\r\nret = lp55xx_init_device(chip);\r\nif (ret)\r\ngoto err_init;\r\nret = lp55xx_register_leds(led, chip);\r\nif (ret)\r\ngoto err_register_leds;\r\nret = lp55xx_register_sysfs(chip);\r\nif (ret) {\r\ndev_err(&client->dev, "registering sysfs failed\n");\r\ngoto err_register_sysfs;\r\n}\r\nreturn 0;\r\nerr_register_sysfs:\r\nlp55xx_unregister_leds(led, chip);\r\nerr_register_leds:\r\nlp55xx_deinit_device(chip);\r\nerr_init:\r\nreturn ret;\r\n}\r\nstatic int lp5562_remove(struct i2c_client *client)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(client);\r\nstruct lp55xx_chip *chip = led->chip;\r\nlp5562_stop_engine(chip);\r\nlp55xx_unregister_sysfs(chip);\r\nlp55xx_unregister_leds(led, chip);\r\nlp55xx_deinit_device(chip);\r\nreturn 0;\r\n}
