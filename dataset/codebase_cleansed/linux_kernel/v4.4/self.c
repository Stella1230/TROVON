static int proc_self_readlink(struct dentry *dentry, char __user *buffer,\r\nint buflen)\r\n{\r\nstruct pid_namespace *ns = dentry->d_sb->s_fs_info;\r\npid_t tgid = task_tgid_nr_ns(current, ns);\r\nchar tmp[PROC_NUMBUF];\r\nif (!tgid)\r\nreturn -ENOENT;\r\nsprintf(tmp, "%d", tgid);\r\nreturn readlink_copy(buffer, buflen, tmp);\r\n}\r\nstatic const char *proc_self_follow_link(struct dentry *dentry, void **cookie)\r\n{\r\nstruct pid_namespace *ns = dentry->d_sb->s_fs_info;\r\npid_t tgid = task_tgid_nr_ns(current, ns);\r\nchar *name;\r\nif (!tgid)\r\nreturn ERR_PTR(-ENOENT);\r\nname = kmalloc(12, GFP_KERNEL);\r\nif (!name)\r\nreturn ERR_PTR(-ENOMEM);\r\nsprintf(name, "%d", tgid);\r\nreturn *cookie = name;\r\n}\r\nint proc_setup_self(struct super_block *s)\r\n{\r\nstruct inode *root_inode = d_inode(s->s_root);\r\nstruct pid_namespace *ns = s->s_fs_info;\r\nstruct dentry *self;\r\nmutex_lock(&root_inode->i_mutex);\r\nself = d_alloc_name(s->s_root, "self");\r\nif (self) {\r\nstruct inode *inode = new_inode_pseudo(s);\r\nif (inode) {\r\ninode->i_ino = self_inum;\r\ninode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\r\ninode->i_mode = S_IFLNK | S_IRWXUGO;\r\ninode->i_uid = GLOBAL_ROOT_UID;\r\ninode->i_gid = GLOBAL_ROOT_GID;\r\ninode->i_op = &proc_self_inode_operations;\r\nd_add(self, inode);\r\n} else {\r\ndput(self);\r\nself = ERR_PTR(-ENOMEM);\r\n}\r\n} else {\r\nself = ERR_PTR(-ENOMEM);\r\n}\r\nmutex_unlock(&root_inode->i_mutex);\r\nif (IS_ERR(self)) {\r\npr_err("proc_fill_super: can't allocate /proc/self\n");\r\nreturn PTR_ERR(self);\r\n}\r\nns->proc_self = self;\r\nreturn 0;\r\n}\r\nvoid __init proc_self_init(void)\r\n{\r\nproc_alloc_inum(&self_inum);\r\n}
