static int setkey_unaligned(struct crypto_aead *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nunsigned long alignmask = crypto_aead_alignmask(tfm);\r\nint ret;\r\nu8 *buffer, *alignbuffer;\r\nunsigned long absize;\r\nabsize = keylen + alignmask;\r\nbuffer = kmalloc(absize, GFP_ATOMIC);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nalignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);\r\nmemcpy(alignbuffer, key, keylen);\r\nret = crypto_aead_alg(tfm)->setkey(tfm, alignbuffer, keylen);\r\nmemset(alignbuffer, 0, keylen);\r\nkfree(buffer);\r\nreturn ret;\r\n}\r\nint crypto_aead_setkey(struct crypto_aead *tfm,\r\nconst u8 *key, unsigned int keylen)\r\n{\r\nunsigned long alignmask = crypto_aead_alignmask(tfm);\r\nif ((unsigned long)key & alignmask)\r\nreturn setkey_unaligned(tfm, key, keylen);\r\nreturn crypto_aead_alg(tfm)->setkey(tfm, key, keylen);\r\n}\r\nint crypto_aead_setauthsize(struct crypto_aead *tfm, unsigned int authsize)\r\n{\r\nint err;\r\nif (authsize > crypto_aead_maxauthsize(tfm))\r\nreturn -EINVAL;\r\nif (crypto_aead_alg(tfm)->setauthsize) {\r\nerr = crypto_aead_alg(tfm)->setauthsize(tfm, authsize);\r\nif (err)\r\nreturn err;\r\n}\r\ntfm->authsize = authsize;\r\nreturn 0;\r\n}\r\nstatic void crypto_aead_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_aead *aead = __crypto_aead_cast(tfm);\r\nstruct aead_alg *alg = crypto_aead_alg(aead);\r\nalg->exit(aead);\r\n}\r\nstatic int crypto_aead_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_aead *aead = __crypto_aead_cast(tfm);\r\nstruct aead_alg *alg = crypto_aead_alg(aead);\r\naead->authsize = alg->maxauthsize;\r\nif (alg->exit)\r\naead->base.exit = crypto_aead_exit_tfm;\r\nif (alg->init)\r\nreturn alg->init(aead);\r\nreturn 0;\r\n}\r\nstatic int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nstruct crypto_report_aead raead;\r\nstruct aead_alg *aead = container_of(alg, struct aead_alg, base);\r\nstrncpy(raead.type, "aead", sizeof(raead.type));\r\nstrncpy(raead.geniv, "<none>", sizeof(raead.geniv));\r\nraead.blocksize = alg->cra_blocksize;\r\nraead.maxauthsize = aead->maxauthsize;\r\nraead.ivsize = aead->ivsize;\r\nif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\r\nsizeof(struct crypto_report_aead), &raead))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic void crypto_aead_show(struct seq_file *m, struct crypto_alg *alg)\r\n{\r\nstruct aead_alg *aead = container_of(alg, struct aead_alg, base);\r\nseq_printf(m, "type : aead\n");\r\nseq_printf(m, "async : %s\n", alg->cra_flags & CRYPTO_ALG_ASYNC ?\r\n"yes" : "no");\r\nseq_printf(m, "blocksize : %u\n", alg->cra_blocksize);\r\nseq_printf(m, "ivsize : %u\n", aead->ivsize);\r\nseq_printf(m, "maxauthsize : %u\n", aead->maxauthsize);\r\nseq_printf(m, "geniv : <none>\n");\r\n}\r\nstatic void crypto_aead_free_instance(struct crypto_instance *inst)\r\n{\r\nstruct aead_instance *aead = aead_instance(inst);\r\nif (!aead->free) {\r\ninst->tmpl->free(inst);\r\nreturn;\r\n}\r\naead->free(aead);\r\n}\r\nstatic int aead_geniv_setkey(struct crypto_aead *tfm,\r\nconst u8 *key, unsigned int keylen)\r\n{\r\nstruct aead_geniv_ctx *ctx = crypto_aead_ctx(tfm);\r\nreturn crypto_aead_setkey(ctx->child, key, keylen);\r\n}\r\nstatic int aead_geniv_setauthsize(struct crypto_aead *tfm,\r\nunsigned int authsize)\r\n{\r\nstruct aead_geniv_ctx *ctx = crypto_aead_ctx(tfm);\r\nreturn crypto_aead_setauthsize(ctx->child, authsize);\r\n}\r\nstruct aead_instance *aead_geniv_alloc(struct crypto_template *tmpl,\r\nstruct rtattr **tb, u32 type, u32 mask)\r\n{\r\nconst char *name;\r\nstruct crypto_aead_spawn *spawn;\r\nstruct crypto_attr_type *algt;\r\nstruct aead_instance *inst;\r\nstruct aead_alg *alg;\r\nunsigned int ivsize;\r\nunsigned int maxauthsize;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn ERR_CAST(algt);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\r\nreturn ERR_PTR(-EINVAL);\r\nname = crypto_attr_alg_name(tb[1]);\r\nif (IS_ERR(name))\r\nreturn ERR_CAST(name);\r\ninst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);\r\nif (!inst)\r\nreturn ERR_PTR(-ENOMEM);\r\nspawn = aead_instance_ctx(inst);\r\nmask |= crypto_requires_sync(algt->type, algt->mask);\r\ncrypto_set_aead_spawn(spawn, aead_crypto_instance(inst));\r\nerr = crypto_grab_aead(spawn, name, type, mask);\r\nif (err)\r\ngoto err_free_inst;\r\nalg = crypto_spawn_aead_alg(spawn);\r\nivsize = crypto_aead_alg_ivsize(alg);\r\nmaxauthsize = crypto_aead_alg_maxauthsize(alg);\r\nerr = -EINVAL;\r\nif (ivsize < sizeof(u64))\r\ngoto err_drop_alg;\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME,\r\n"%s(%s)", tmpl->name, alg->base.cra_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\ngoto err_drop_alg;\r\nif (snprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"%s(%s)", tmpl->name, alg->base.cra_driver_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\ngoto err_drop_alg;\r\ninst->alg.base.cra_flags = alg->base.cra_flags & CRYPTO_ALG_ASYNC;\r\ninst->alg.base.cra_priority = alg->base.cra_priority;\r\ninst->alg.base.cra_blocksize = alg->base.cra_blocksize;\r\ninst->alg.base.cra_alignmask = alg->base.cra_alignmask;\r\ninst->alg.base.cra_ctxsize = sizeof(struct aead_geniv_ctx);\r\ninst->alg.setkey = aead_geniv_setkey;\r\ninst->alg.setauthsize = aead_geniv_setauthsize;\r\ninst->alg.ivsize = ivsize;\r\ninst->alg.maxauthsize = maxauthsize;\r\nout:\r\nreturn inst;\r\nerr_drop_alg:\r\ncrypto_drop_aead(spawn);\r\nerr_free_inst:\r\nkfree(inst);\r\ninst = ERR_PTR(err);\r\ngoto out;\r\n}\r\nvoid aead_geniv_free(struct aead_instance *inst)\r\n{\r\ncrypto_drop_aead(aead_instance_ctx(inst));\r\nkfree(inst);\r\n}\r\nint aead_init_geniv(struct crypto_aead *aead)\r\n{\r\nstruct aead_geniv_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct aead_instance *inst = aead_alg_instance(aead);\r\nstruct crypto_aead *child;\r\nint err;\r\nspin_lock_init(&ctx->lock);\r\nerr = crypto_get_default_rng();\r\nif (err)\r\ngoto out;\r\nerr = crypto_rng_get_bytes(crypto_default_rng, ctx->salt,\r\ncrypto_aead_ivsize(aead));\r\ncrypto_put_default_rng();\r\nif (err)\r\ngoto out;\r\nctx->null = crypto_get_default_null_skcipher();\r\nerr = PTR_ERR(ctx->null);\r\nif (IS_ERR(ctx->null))\r\ngoto out;\r\nchild = crypto_spawn_aead(aead_instance_ctx(inst));\r\nerr = PTR_ERR(child);\r\nif (IS_ERR(child))\r\ngoto drop_null;\r\nctx->child = child;\r\ncrypto_aead_set_reqsize(aead, crypto_aead_reqsize(child) +\r\nsizeof(struct aead_request));\r\nerr = 0;\r\nout:\r\nreturn err;\r\ndrop_null:\r\ncrypto_put_default_null_skcipher();\r\ngoto out;\r\n}\r\nvoid aead_exit_geniv(struct crypto_aead *tfm)\r\n{\r\nstruct aead_geniv_ctx *ctx = crypto_aead_ctx(tfm);\r\ncrypto_free_aead(ctx->child);\r\ncrypto_put_default_null_skcipher();\r\n}\r\nint crypto_grab_aead(struct crypto_aead_spawn *spawn, const char *name,\r\nu32 type, u32 mask)\r\n{\r\nspawn->base.frontend = &crypto_aead_type;\r\nreturn crypto_grab_spawn(&spawn->base, name, type, mask);\r\n}\r\nstruct crypto_aead *crypto_alloc_aead(const char *alg_name, u32 type, u32 mask)\r\n{\r\nreturn crypto_alloc_tfm(alg_name, &crypto_aead_type, type, mask);\r\n}\r\nstatic int aead_prepare_alg(struct aead_alg *alg)\r\n{\r\nstruct crypto_alg *base = &alg->base;\r\nif (max(alg->maxauthsize, alg->ivsize) > PAGE_SIZE / 8)\r\nreturn -EINVAL;\r\nbase->cra_type = &crypto_aead_type;\r\nbase->cra_flags &= ~CRYPTO_ALG_TYPE_MASK;\r\nbase->cra_flags |= CRYPTO_ALG_TYPE_AEAD;\r\nreturn 0;\r\n}\r\nint crypto_register_aead(struct aead_alg *alg)\r\n{\r\nstruct crypto_alg *base = &alg->base;\r\nint err;\r\nerr = aead_prepare_alg(alg);\r\nif (err)\r\nreturn err;\r\nreturn crypto_register_alg(base);\r\n}\r\nvoid crypto_unregister_aead(struct aead_alg *alg)\r\n{\r\ncrypto_unregister_alg(&alg->base);\r\n}\r\nint crypto_register_aeads(struct aead_alg *algs, int count)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < count; i++) {\r\nret = crypto_register_aead(&algs[i]);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nfor (--i; i >= 0; --i)\r\ncrypto_unregister_aead(&algs[i]);\r\nreturn ret;\r\n}\r\nvoid crypto_unregister_aeads(struct aead_alg *algs, int count)\r\n{\r\nint i;\r\nfor (i = count - 1; i >= 0; --i)\r\ncrypto_unregister_aead(&algs[i]);\r\n}\r\nint aead_register_instance(struct crypto_template *tmpl,\r\nstruct aead_instance *inst)\r\n{\r\nint err;\r\nerr = aead_prepare_alg(&inst->alg);\r\nif (err)\r\nreturn err;\r\nreturn crypto_register_instance(tmpl, aead_crypto_instance(inst));\r\n}
