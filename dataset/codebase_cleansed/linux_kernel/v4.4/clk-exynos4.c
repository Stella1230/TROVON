static void exynos4_clk_wait_for_pll(u32 reg)\r\n{\r\nu32 pll_con;\r\npll_con = readl(reg_base + reg);\r\nif (!(pll_con & PLL_ENABLED))\r\nreturn;\r\nwhile (!(pll_con & PLL_LOCKED)) {\r\ncpu_relax();\r\npll_con = readl(reg_base + reg);\r\n}\r\n}\r\nstatic int exynos4_clk_suspend(void)\r\n{\r\nsamsung_clk_save(reg_base, exynos4_save_common,\r\nARRAY_SIZE(exynos4_clk_regs));\r\nsamsung_clk_save(reg_base, exynos4_save_pll,\r\nARRAY_SIZE(exynos4_clk_pll_regs));\r\nif (exynos4_soc == EXYNOS4210) {\r\nsamsung_clk_save(reg_base, exynos4_save_soc,\r\nARRAY_SIZE(exynos4210_clk_save));\r\nsamsung_clk_restore(reg_base, src_mask_suspend_e4210,\r\nARRAY_SIZE(src_mask_suspend_e4210));\r\n} else {\r\nsamsung_clk_save(reg_base, exynos4_save_soc,\r\nARRAY_SIZE(exynos4x12_clk_save));\r\n}\r\nsamsung_clk_restore(reg_base, src_mask_suspend,\r\nARRAY_SIZE(src_mask_suspend));\r\nreturn 0;\r\n}\r\nstatic void exynos4_clk_resume(void)\r\n{\r\nsamsung_clk_restore(reg_base, exynos4_save_pll,\r\nARRAY_SIZE(exynos4_clk_pll_regs));\r\nexynos4_clk_wait_for_pll(EPLL_CON0);\r\nexynos4_clk_wait_for_pll(VPLL_CON0);\r\nsamsung_clk_restore(reg_base, exynos4_save_common,\r\nARRAY_SIZE(exynos4_clk_regs));\r\nif (exynos4_soc == EXYNOS4210)\r\nsamsung_clk_restore(reg_base, exynos4_save_soc,\r\nARRAY_SIZE(exynos4210_clk_save));\r\nelse\r\nsamsung_clk_restore(reg_base, exynos4_save_soc,\r\nARRAY_SIZE(exynos4x12_clk_save));\r\n}\r\nstatic void __init exynos4_clk_sleep_init(void)\r\n{\r\nexynos4_save_common = samsung_clk_alloc_reg_dump(exynos4_clk_regs,\r\nARRAY_SIZE(exynos4_clk_regs));\r\nif (!exynos4_save_common)\r\ngoto err_warn;\r\nif (exynos4_soc == EXYNOS4210)\r\nexynos4_save_soc = samsung_clk_alloc_reg_dump(\r\nexynos4210_clk_save,\r\nARRAY_SIZE(exynos4210_clk_save));\r\nelse\r\nexynos4_save_soc = samsung_clk_alloc_reg_dump(\r\nexynos4x12_clk_save,\r\nARRAY_SIZE(exynos4x12_clk_save));\r\nif (!exynos4_save_soc)\r\ngoto err_common;\r\nexynos4_save_pll = samsung_clk_alloc_reg_dump(exynos4_clk_pll_regs,\r\nARRAY_SIZE(exynos4_clk_pll_regs));\r\nif (!exynos4_save_pll)\r\ngoto err_soc;\r\nregister_syscore_ops(&exynos4_clk_syscore_ops);\r\nreturn;\r\nerr_soc:\r\nkfree(exynos4_save_soc);\r\nerr_common:\r\nkfree(exynos4_save_common);\r\nerr_warn:\r\npr_warn("%s: failed to allocate sleep save data, no sleep support!\n",\r\n__func__);\r\n}\r\nstatic void __init exynos4_clk_sleep_init(void) {}\r\nstatic unsigned long exynos4_get_xom(void)\r\n{\r\nunsigned long xom = 0;\r\nvoid __iomem *chipid_base;\r\nstruct device_node *np;\r\nnp = of_find_compatible_node(NULL, NULL, "samsung,exynos4210-chipid");\r\nif (np) {\r\nchipid_base = of_iomap(np, 0);\r\nif (chipid_base)\r\nxom = readl(chipid_base + 8);\r\niounmap(chipid_base);\r\n}\r\nreturn xom;\r\n}\r\nstatic void __init exynos4_clk_register_finpll(struct samsung_clk_provider *ctx)\r\n{\r\nstruct samsung_fixed_rate_clock fclk;\r\nstruct clk *clk;\r\nunsigned long finpll_f = 24000000;\r\nchar *parent_name;\r\nunsigned int xom = exynos4_get_xom();\r\nparent_name = xom & 1 ? "xusbxti" : "xxti";\r\nclk = clk_get(NULL, parent_name);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: failed to lookup parent clock %s, assuming "\r\n"fin_pll clock frequency is 24MHz\n", __func__,\r\nparent_name);\r\n} else {\r\nfinpll_f = clk_get_rate(clk);\r\n}\r\nfclk.id = CLK_FIN_PLL;\r\nfclk.name = "fin_pll";\r\nfclk.parent_name = NULL;\r\nfclk.flags = CLK_IS_ROOT;\r\nfclk.fixed_rate = finpll_f;\r\nsamsung_clk_register_fixed_rate(ctx, &fclk, 1);\r\n}\r\nstatic void __init exynos4x12_core_down_clock(void)\r\n{\r\nunsigned int tmp;\r\ntmp = (PWR_CTRL1_CORE2_DOWN_RATIO(7) | PWR_CTRL1_CORE1_DOWN_RATIO(7) |\r\nPWR_CTRL1_DIV2_DOWN_EN | PWR_CTRL1_DIV1_DOWN_EN |\r\nPWR_CTRL1_USE_CORE1_WFE | PWR_CTRL1_USE_CORE0_WFE |\r\nPWR_CTRL1_USE_CORE1_WFI | PWR_CTRL1_USE_CORE0_WFI);\r\nif (num_possible_cpus() == 4)\r\ntmp |= PWR_CTRL1_USE_CORE3_WFE | PWR_CTRL1_USE_CORE2_WFE |\r\nPWR_CTRL1_USE_CORE3_WFI | PWR_CTRL1_USE_CORE2_WFI;\r\n__raw_writel(tmp, reg_base + PWR_CTRL1);\r\n__raw_writel(0x0, reg_base + E4X12_PWR_CTRL2);\r\n}\r\nstatic void __init exynos4_clk_init(struct device_node *np,\r\nenum exynos4_soc soc)\r\n{\r\nstruct samsung_clk_provider *ctx;\r\nexynos4_soc = soc;\r\nreg_base = of_iomap(np, 0);\r\nif (!reg_base)\r\npanic("%s: failed to map registers\n", __func__);\r\nctx = samsung_clk_init(np, reg_base, CLK_NR_CLKS);\r\nif (!ctx)\r\npanic("%s: unable to allocate context.\n", __func__);\r\nsamsung_clk_of_register_fixed_ext(ctx, exynos4_fixed_rate_ext_clks,\r\nARRAY_SIZE(exynos4_fixed_rate_ext_clks),\r\next_clk_match);\r\nexynos4_clk_register_finpll(ctx);\r\nif (exynos4_soc == EXYNOS4210) {\r\nsamsung_clk_register_mux(ctx, exynos4210_mux_early,\r\nARRAY_SIZE(exynos4210_mux_early));\r\nif (_get_rate("fin_pll") == 24000000) {\r\nexynos4210_plls[apll].rate_table =\r\nexynos4210_apll_rates;\r\nexynos4210_plls[epll].rate_table =\r\nexynos4210_epll_rates;\r\n}\r\nif (_get_rate("mout_vpllsrc") == 24000000)\r\nexynos4210_plls[vpll].rate_table =\r\nexynos4210_vpll_rates;\r\nsamsung_clk_register_pll(ctx, exynos4210_plls,\r\nARRAY_SIZE(exynos4210_plls), reg_base);\r\n} else {\r\nif (_get_rate("fin_pll") == 24000000) {\r\nexynos4x12_plls[apll].rate_table =\r\nexynos4x12_apll_rates;\r\nexynos4x12_plls[epll].rate_table =\r\nexynos4x12_epll_rates;\r\nexynos4x12_plls[vpll].rate_table =\r\nexynos4x12_vpll_rates;\r\n}\r\nsamsung_clk_register_pll(ctx, exynos4x12_plls,\r\nARRAY_SIZE(exynos4x12_plls), reg_base);\r\n}\r\nsamsung_clk_register_fixed_rate(ctx, exynos4_fixed_rate_clks,\r\nARRAY_SIZE(exynos4_fixed_rate_clks));\r\nsamsung_clk_register_mux(ctx, exynos4_mux_clks,\r\nARRAY_SIZE(exynos4_mux_clks));\r\nsamsung_clk_register_div(ctx, exynos4_div_clks,\r\nARRAY_SIZE(exynos4_div_clks));\r\nsamsung_clk_register_gate(ctx, exynos4_gate_clks,\r\nARRAY_SIZE(exynos4_gate_clks));\r\nsamsung_clk_register_fixed_factor(ctx, exynos4_fixed_factor_clks,\r\nARRAY_SIZE(exynos4_fixed_factor_clks));\r\nif (exynos4_soc == EXYNOS4210) {\r\nsamsung_clk_register_fixed_rate(ctx, exynos4210_fixed_rate_clks,\r\nARRAY_SIZE(exynos4210_fixed_rate_clks));\r\nsamsung_clk_register_mux(ctx, exynos4210_mux_clks,\r\nARRAY_SIZE(exynos4210_mux_clks));\r\nsamsung_clk_register_div(ctx, exynos4210_div_clks,\r\nARRAY_SIZE(exynos4210_div_clks));\r\nsamsung_clk_register_gate(ctx, exynos4210_gate_clks,\r\nARRAY_SIZE(exynos4210_gate_clks));\r\nsamsung_clk_register_alias(ctx, exynos4210_aliases,\r\nARRAY_SIZE(exynos4210_aliases));\r\nsamsung_clk_register_fixed_factor(ctx,\r\nexynos4210_fixed_factor_clks,\r\nARRAY_SIZE(exynos4210_fixed_factor_clks));\r\nexynos_register_cpu_clock(ctx, CLK_ARM_CLK, "armclk",\r\nmout_core_p4210[0], mout_core_p4210[1], 0x14200,\r\ne4210_armclk_d, ARRAY_SIZE(e4210_armclk_d),\r\nCLK_CPU_NEEDS_DEBUG_ALT_DIV | CLK_CPU_HAS_DIV1);\r\n} else {\r\nsamsung_clk_register_mux(ctx, exynos4x12_mux_clks,\r\nARRAY_SIZE(exynos4x12_mux_clks));\r\nsamsung_clk_register_div(ctx, exynos4x12_div_clks,\r\nARRAY_SIZE(exynos4x12_div_clks));\r\nsamsung_clk_register_gate(ctx, exynos4x12_gate_clks,\r\nARRAY_SIZE(exynos4x12_gate_clks));\r\nsamsung_clk_register_alias(ctx, exynos4x12_aliases,\r\nARRAY_SIZE(exynos4x12_aliases));\r\nsamsung_clk_register_fixed_factor(ctx,\r\nexynos4x12_fixed_factor_clks,\r\nARRAY_SIZE(exynos4x12_fixed_factor_clks));\r\nif (of_machine_is_compatible("samsung,exynos4412")) {\r\nexynos_register_cpu_clock(ctx, CLK_ARM_CLK, "armclk",\r\nmout_core_p4x12[0], mout_core_p4x12[1], 0x14200,\r\ne4412_armclk_d, ARRAY_SIZE(e4412_armclk_d),\r\nCLK_CPU_NEEDS_DEBUG_ALT_DIV | CLK_CPU_HAS_DIV1);\r\n} else {\r\nexynos_register_cpu_clock(ctx, CLK_ARM_CLK, "armclk",\r\nmout_core_p4x12[0], mout_core_p4x12[1], 0x14200,\r\ne4212_armclk_d, ARRAY_SIZE(e4212_armclk_d),\r\nCLK_CPU_NEEDS_DEBUG_ALT_DIV | CLK_CPU_HAS_DIV1);\r\n}\r\n}\r\nsamsung_clk_register_alias(ctx, exynos4_aliases,\r\nARRAY_SIZE(exynos4_aliases));\r\nif (soc == EXYNOS4X12)\r\nexynos4x12_core_down_clock();\r\nexynos4_clk_sleep_init();\r\nsamsung_clk_of_add_provider(np, ctx);\r\npr_info("%s clocks: sclk_apll = %ld, sclk_mpll = %ld\n"\r\n"\tsclk_epll = %ld, sclk_vpll = %ld, arm_clk = %ld\n",\r\nexynos4_soc == EXYNOS4210 ? "Exynos4210" : "Exynos4x12",\r\n_get_rate("sclk_apll"), _get_rate("sclk_mpll"),\r\n_get_rate("sclk_epll"), _get_rate("sclk_vpll"),\r\n_get_rate("div_core2"));\r\n}\r\nstatic void __init exynos4210_clk_init(struct device_node *np)\r\n{\r\nexynos4_clk_init(np, EXYNOS4210);\r\n}\r\nstatic void __init exynos4412_clk_init(struct device_node *np)\r\n{\r\nexynos4_clk_init(np, EXYNOS4X12);\r\n}
