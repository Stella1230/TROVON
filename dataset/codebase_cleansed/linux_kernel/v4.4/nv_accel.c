static inline void nvidiafb_safe_mode(struct fb_info *info)\r\n{\r\nstruct nvidia_par *par = info->par;\r\ntouch_softlockup_watchdog();\r\ninfo->pixmap.scan_align = 1;\r\npar->lockup = 1;\r\n}\r\nstatic inline void NVFlush(struct fb_info *info)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nint count = 1000000000;\r\nwhile (--count && READ_GET(par) != par->dmaPut) ;\r\nif (!count) {\r\nprintk("nvidiafb: DMA Flush lockup\n");\r\nnvidiafb_safe_mode(info);\r\n}\r\n}\r\nstatic inline void NVSync(struct fb_info *info)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nint count = 1000000000;\r\nwhile (--count && NV_RD32(par->PGRAPH, 0x0700)) ;\r\nif (!count) {\r\nprintk("nvidiafb: DMA Sync lockup\n");\r\nnvidiafb_safe_mode(info);\r\n}\r\n}\r\nstatic void NVDmaKickoff(struct nvidia_par *par)\r\n{\r\nif (par->dmaCurrent != par->dmaPut) {\r\npar->dmaPut = par->dmaCurrent;\r\nWRITE_PUT(par, par->dmaPut);\r\n}\r\n}\r\nstatic void NVDmaWait(struct fb_info *info, int size)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nint dmaGet;\r\nint count = 1000000000, cnt;\r\nsize++;\r\nwhile (par->dmaFree < size && --count && !par->lockup) {\r\ndmaGet = READ_GET(par);\r\nif (par->dmaPut >= dmaGet) {\r\npar->dmaFree = par->dmaMax - par->dmaCurrent;\r\nif (par->dmaFree < size) {\r\nNVDmaNext(par, 0x20000000);\r\nif (dmaGet <= SKIPS) {\r\nif (par->dmaPut <= SKIPS)\r\nWRITE_PUT(par, SKIPS + 1);\r\ncnt = 1000000000;\r\ndo {\r\ndmaGet = READ_GET(par);\r\n} while (--cnt && dmaGet <= SKIPS);\r\nif (!cnt) {\r\nprintk("DMA Get lockup\n");\r\npar->lockup = 1;\r\n}\r\n}\r\nWRITE_PUT(par, SKIPS);\r\npar->dmaCurrent = par->dmaPut = SKIPS;\r\npar->dmaFree = dmaGet - (SKIPS + 1);\r\n}\r\n} else\r\npar->dmaFree = dmaGet - par->dmaCurrent - 1;\r\n}\r\nif (!count) {\r\nprintk("nvidiafb: DMA Wait Lockup\n");\r\nnvidiafb_safe_mode(info);\r\n}\r\n}\r\nstatic void NVSetPattern(struct fb_info *info, u32 clr0, u32 clr1,\r\nu32 pat0, u32 pat1)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nNVDmaStart(info, par, PATTERN_COLOR_0, 4);\r\nNVDmaNext(par, clr0);\r\nNVDmaNext(par, clr1);\r\nNVDmaNext(par, pat0);\r\nNVDmaNext(par, pat1);\r\n}\r\nstatic void NVSetRopSolid(struct fb_info *info, u32 rop, u32 planemask)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nif (planemask != ~0) {\r\nNVSetPattern(info, 0, planemask, ~0, ~0);\r\nif (par->currentRop != (rop + 32)) {\r\nNVDmaStart(info, par, ROP_SET, 1);\r\nNVDmaNext(par, NVCopyROP_PM[rop]);\r\npar->currentRop = rop + 32;\r\n}\r\n} else if (par->currentRop != rop) {\r\nif (par->currentRop >= 16)\r\nNVSetPattern(info, ~0, ~0, ~0, ~0);\r\nNVDmaStart(info, par, ROP_SET, 1);\r\nNVDmaNext(par, NVCopyROP[rop]);\r\npar->currentRop = rop;\r\n}\r\n}\r\nstatic void NVSetClippingRectangle(struct fb_info *info, int x1, int y1,\r\nint x2, int y2)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nint h = y2 - y1 + 1;\r\nint w = x2 - x1 + 1;\r\nNVDmaStart(info, par, CLIP_POINT, 2);\r\nNVDmaNext(par, (y1 << 16) | x1);\r\nNVDmaNext(par, (h << 16) | w);\r\n}\r\nvoid NVResetGraphics(struct fb_info *info)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nu32 surfaceFormat, patternFormat, rectFormat, lineFormat;\r\nint pitch, i;\r\npitch = info->fix.line_length;\r\npar->dmaBase = (u32 __iomem *) (&par->FbStart[par->FbUsableSize]);\r\nfor (i = 0; i < SKIPS; i++)\r\nNV_WR32(&par->dmaBase[i], 0, 0x00000000);\r\nNV_WR32(&par->dmaBase[0x0 + SKIPS], 0, 0x00040000);\r\nNV_WR32(&par->dmaBase[0x1 + SKIPS], 0, 0x80000010);\r\nNV_WR32(&par->dmaBase[0x2 + SKIPS], 0, 0x00042000);\r\nNV_WR32(&par->dmaBase[0x3 + SKIPS], 0, 0x80000011);\r\nNV_WR32(&par->dmaBase[0x4 + SKIPS], 0, 0x00044000);\r\nNV_WR32(&par->dmaBase[0x5 + SKIPS], 0, 0x80000012);\r\nNV_WR32(&par->dmaBase[0x6 + SKIPS], 0, 0x00046000);\r\nNV_WR32(&par->dmaBase[0x7 + SKIPS], 0, 0x80000013);\r\nNV_WR32(&par->dmaBase[0x8 + SKIPS], 0, 0x00048000);\r\nNV_WR32(&par->dmaBase[0x9 + SKIPS], 0, 0x80000014);\r\nNV_WR32(&par->dmaBase[0xA + SKIPS], 0, 0x0004A000);\r\nNV_WR32(&par->dmaBase[0xB + SKIPS], 0, 0x80000015);\r\nNV_WR32(&par->dmaBase[0xC + SKIPS], 0, 0x0004C000);\r\nNV_WR32(&par->dmaBase[0xD + SKIPS], 0, 0x80000016);\r\nNV_WR32(&par->dmaBase[0xE + SKIPS], 0, 0x0004E000);\r\nNV_WR32(&par->dmaBase[0xF + SKIPS], 0, 0x80000017);\r\npar->dmaPut = 0;\r\npar->dmaCurrent = 16 + SKIPS;\r\npar->dmaMax = 8191;\r\npar->dmaFree = par->dmaMax - par->dmaCurrent;\r\nswitch (info->var.bits_per_pixel) {\r\ncase 32:\r\ncase 24:\r\nsurfaceFormat = SURFACE_FORMAT_DEPTH24;\r\npatternFormat = PATTERN_FORMAT_DEPTH24;\r\nrectFormat = RECT_FORMAT_DEPTH24;\r\nlineFormat = LINE_FORMAT_DEPTH24;\r\nbreak;\r\ncase 16:\r\nsurfaceFormat = SURFACE_FORMAT_DEPTH16;\r\npatternFormat = PATTERN_FORMAT_DEPTH16;\r\nrectFormat = RECT_FORMAT_DEPTH16;\r\nlineFormat = LINE_FORMAT_DEPTH16;\r\nbreak;\r\ndefault:\r\nsurfaceFormat = SURFACE_FORMAT_DEPTH8;\r\npatternFormat = PATTERN_FORMAT_DEPTH8;\r\nrectFormat = RECT_FORMAT_DEPTH8;\r\nlineFormat = LINE_FORMAT_DEPTH8;\r\nbreak;\r\n}\r\nNVDmaStart(info, par, SURFACE_FORMAT, 4);\r\nNVDmaNext(par, surfaceFormat);\r\nNVDmaNext(par, pitch | (pitch << 16));\r\nNVDmaNext(par, 0);\r\nNVDmaNext(par, 0);\r\nNVDmaStart(info, par, PATTERN_FORMAT, 1);\r\nNVDmaNext(par, patternFormat);\r\nNVDmaStart(info, par, RECT_FORMAT, 1);\r\nNVDmaNext(par, rectFormat);\r\nNVDmaStart(info, par, LINE_FORMAT, 1);\r\nNVDmaNext(par, lineFormat);\r\npar->currentRop = ~0;\r\nNVSetRopSolid(info, ROP_COPY, ~0);\r\nNVSetClippingRectangle(info, 0, 0, info->var.xres_virtual,\r\ninfo->var.yres_virtual);\r\nNVDmaKickoff(par);\r\n}\r\nint nvidiafb_sync(struct fb_info *info)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn 0;\r\nif (!par->lockup)\r\nNVFlush(info);\r\nif (!par->lockup)\r\nNVSync(info);\r\nreturn 0;\r\n}\r\nvoid nvidiafb_copyarea(struct fb_info *info, const struct fb_copyarea *region)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nif (par->lockup) {\r\ncfb_copyarea(info, region);\r\nreturn;\r\n}\r\nNVDmaStart(info, par, BLIT_POINT_SRC, 3);\r\nNVDmaNext(par, (region->sy << 16) | region->sx);\r\nNVDmaNext(par, (region->dy << 16) | region->dx);\r\nNVDmaNext(par, (region->height << 16) | region->width);\r\nNVDmaKickoff(par);\r\n}\r\nvoid nvidiafb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nu32 color;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nif (par->lockup) {\r\ncfb_fillrect(info, rect);\r\nreturn;\r\n}\r\nif (info->var.bits_per_pixel == 8)\r\ncolor = rect->color;\r\nelse\r\ncolor = ((u32 *) info->pseudo_palette)[rect->color];\r\nif (rect->rop != ROP_COPY)\r\nNVSetRopSolid(info, rect->rop, ~0);\r\nNVDmaStart(info, par, RECT_SOLID_COLOR, 1);\r\nNVDmaNext(par, color);\r\nNVDmaStart(info, par, RECT_SOLID_RECTS(0), 2);\r\nNVDmaNext(par, (rect->dx << 16) | rect->dy);\r\nNVDmaNext(par, (rect->width << 16) | rect->height);\r\nNVDmaKickoff(par);\r\nif (rect->rop != ROP_COPY)\r\nNVSetRopSolid(info, ROP_COPY, ~0);\r\n}\r\nstatic void nvidiafb_mono_color_expand(struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nu32 fg, bg, mask = ~(~0 >> (32 - info->var.bits_per_pixel));\r\nu32 dsize, width, *data = (u32 *) image->data, tmp;\r\nint j, k = 0;\r\nwidth = (image->width + 31) & ~31;\r\ndsize = (width * image->height) >> 5;\r\nif (info->var.bits_per_pixel == 8) {\r\nfg = image->fg_color | mask;\r\nbg = image->bg_color | mask;\r\n} else {\r\nfg = ((u32 *) info->pseudo_palette)[image->fg_color] | mask;\r\nbg = ((u32 *) info->pseudo_palette)[image->bg_color] | mask;\r\n}\r\nNVDmaStart(info, par, RECT_EXPAND_TWO_COLOR_CLIP, 7);\r\nNVDmaNext(par, (image->dy << 16) | (image->dx & 0xffff));\r\nNVDmaNext(par, ((image->dy + image->height) << 16) |\r\n((image->dx + image->width) & 0xffff));\r\nNVDmaNext(par, bg);\r\nNVDmaNext(par, fg);\r\nNVDmaNext(par, (image->height << 16) | width);\r\nNVDmaNext(par, (image->height << 16) | width);\r\nNVDmaNext(par, (image->dy << 16) | (image->dx & 0xffff));\r\nwhile (dsize >= RECT_EXPAND_TWO_COLOR_DATA_MAX_DWORDS) {\r\nNVDmaStart(info, par, RECT_EXPAND_TWO_COLOR_DATA(0),\r\nRECT_EXPAND_TWO_COLOR_DATA_MAX_DWORDS);\r\nfor (j = RECT_EXPAND_TWO_COLOR_DATA_MAX_DWORDS; j--;) {\r\ntmp = data[k++];\r\nreverse_order(&tmp);\r\nNVDmaNext(par, tmp);\r\n}\r\ndsize -= RECT_EXPAND_TWO_COLOR_DATA_MAX_DWORDS;\r\n}\r\nif (dsize) {\r\nNVDmaStart(info, par, RECT_EXPAND_TWO_COLOR_DATA(0), dsize);\r\nfor (j = dsize; j--;) {\r\ntmp = data[k++];\r\nreverse_order(&tmp);\r\nNVDmaNext(par, tmp);\r\n}\r\n}\r\nNVDmaKickoff(par);\r\n}\r\nvoid nvidiafb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nif (image->depth == 1 && !par->lockup)\r\nnvidiafb_mono_color_expand(info, image);\r\nelse\r\ncfb_imageblit(info, image);\r\n}
