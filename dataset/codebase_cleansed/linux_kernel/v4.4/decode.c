void __init find_str_pc_offset(void)\r\n{\r\nint addr, scratch, ret;\r\n__asm__ (\r\n"sub %[ret], pc, #4 \n\t"\r\n"str pc, %[addr] \n\t"\r\n"ldr %[scr], %[addr] \n\t"\r\n"sub %[ret], %[scr], %[ret] \n\t"\r\n: [ret] "=r" (ret), [scr] "=r" (scratch), [addr] "+m" (addr));\r\nstr_pc_offset = ret;\r\n}\r\nvoid __init test_load_write_pc_interworking(void)\r\n{\r\nint arch = cpu_architecture();\r\nBUG_ON(arch == CPU_ARCH_UNKNOWN);\r\nload_write_pc_interworks = arch >= CPU_ARCH_ARMv5T;\r\n}\r\nvoid __init test_alu_write_pc_interworking(void)\r\n{\r\nint arch = cpu_architecture();\r\nBUG_ON(arch == CPU_ARCH_UNKNOWN);\r\nalu_write_pc_interworks = arch >= CPU_ARCH_ARMv7;\r\n}\r\nvoid __init arm_probes_decode_init(void)\r\n{\r\nfind_str_pc_offset();\r\ntest_load_write_pc_interworking();\r\ntest_alu_write_pc_interworking();\r\n}\r\nstatic unsigned long __kprobes __check_eq(unsigned long cpsr)\r\n{\r\nreturn cpsr & PSR_Z_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_ne(unsigned long cpsr)\r\n{\r\nreturn (~cpsr) & PSR_Z_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_cs(unsigned long cpsr)\r\n{\r\nreturn cpsr & PSR_C_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_cc(unsigned long cpsr)\r\n{\r\nreturn (~cpsr) & PSR_C_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_mi(unsigned long cpsr)\r\n{\r\nreturn cpsr & PSR_N_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_pl(unsigned long cpsr)\r\n{\r\nreturn (~cpsr) & PSR_N_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_vs(unsigned long cpsr)\r\n{\r\nreturn cpsr & PSR_V_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_vc(unsigned long cpsr)\r\n{\r\nreturn (~cpsr) & PSR_V_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_hi(unsigned long cpsr)\r\n{\r\ncpsr &= ~(cpsr >> 1);\r\nreturn cpsr & PSR_C_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_ls(unsigned long cpsr)\r\n{\r\ncpsr &= ~(cpsr >> 1);\r\nreturn (~cpsr) & PSR_C_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_ge(unsigned long cpsr)\r\n{\r\ncpsr ^= (cpsr << 3);\r\nreturn (~cpsr) & PSR_N_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_lt(unsigned long cpsr)\r\n{\r\ncpsr ^= (cpsr << 3);\r\nreturn cpsr & PSR_N_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_gt(unsigned long cpsr)\r\n{\r\nunsigned long temp = cpsr ^ (cpsr << 3);\r\ntemp |= (cpsr << 1);\r\nreturn (~temp) & PSR_N_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_le(unsigned long cpsr)\r\n{\r\nunsigned long temp = cpsr ^ (cpsr << 3);\r\ntemp |= (cpsr << 1);\r\nreturn temp & PSR_N_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_al(unsigned long cpsr)\r\n{\r\nreturn true;\r\n}\r\nvoid __kprobes probes_simulate_nop(probes_opcode_t opcode,\r\nstruct arch_probes_insn *asi,\r\nstruct pt_regs *regs)\r\n{\r\n}\r\nvoid __kprobes probes_emulate_none(probes_opcode_t opcode,\r\nstruct arch_probes_insn *asi,\r\nstruct pt_regs *regs)\r\n{\r\nasi->insn_fn();\r\n}\r\nstatic probes_opcode_t __kprobes\r\nprepare_emulated_insn(probes_opcode_t insn, struct arch_probes_insn *asi,\r\nbool thumb)\r\n{\r\n#ifdef CONFIG_THUMB2_KERNEL\r\nif (thumb) {\r\nu16 *thumb_insn = (u16 *)asi->insn;\r\nthumb_insn[1] = __opcode_to_mem_thumb16(0x4770);\r\nthumb_insn[2] = __opcode_to_mem_thumb16(0x4770);\r\nreturn insn;\r\n}\r\nasi->insn[1] = __opcode_to_mem_arm(0xe12fff1e);\r\n#else\r\nasi->insn[1] = __opcode_to_mem_arm(0xe1a0f00e);\r\n#endif\r\nif (insn < 0xe0000000)\r\ninsn = (insn | 0xe0000000) & ~0x10000000;\r\nreturn insn;\r\n}\r\nstatic void __kprobes\r\nset_emulated_insn(probes_opcode_t insn, struct arch_probes_insn *asi,\r\nbool thumb)\r\n{\r\n#ifdef CONFIG_THUMB2_KERNEL\r\nif (thumb) {\r\nu16 *ip = (u16 *)asi->insn;\r\nif (is_wide_instruction(insn))\r\n*ip++ = __opcode_to_mem_thumb16(insn >> 16);\r\n*ip++ = __opcode_to_mem_thumb16(insn);\r\nreturn;\r\n}\r\n#endif\r\nasi->insn[0] = __opcode_to_mem_arm(insn);\r\n}\r\nstatic bool __kprobes decode_regs(probes_opcode_t *pinsn, u32 regs, bool modify)\r\n{\r\nprobes_opcode_t insn = *pinsn;\r\nprobes_opcode_t mask = 0xf;\r\nfor (; regs != 0; regs >>= 4, mask <<= 4) {\r\nprobes_opcode_t new_bits = INSN_NEW_BITS;\r\nswitch (regs & 0xf) {\r\ncase REG_TYPE_NONE:\r\ncontinue;\r\ncase REG_TYPE_ANY:\r\nbreak;\r\ncase REG_TYPE_SAMEAS16:\r\nnew_bits = INSN_SAMEAS16_BITS;\r\nbreak;\r\ncase REG_TYPE_SP:\r\nif ((insn ^ 0xdddddddd) & mask)\r\ngoto reject;\r\nbreak;\r\ncase REG_TYPE_PC:\r\nif ((insn ^ 0xffffffff) & mask)\r\ngoto reject;\r\nbreak;\r\ncase REG_TYPE_NOSP:\r\nif (((insn ^ 0xdddddddd) & mask) == 0)\r\ngoto reject;\r\nbreak;\r\ncase REG_TYPE_NOSPPC:\r\ncase REG_TYPE_NOSPPCX:\r\nif (((insn ^ 0xdddddddd) & 0xdddddddd & mask) == 0)\r\ngoto reject;\r\nbreak;\r\ncase REG_TYPE_NOPCWB:\r\nif (!is_writeback(insn))\r\nbreak;\r\ncase REG_TYPE_NOPC:\r\ncase REG_TYPE_NOPCX:\r\nif (((insn ^ 0xffffffff) & mask) == 0)\r\ngoto reject;\r\nbreak;\r\n}\r\ninsn &= ~mask;\r\ninsn |= new_bits & mask;\r\n}\r\nif (modify)\r\n*pinsn = insn;\r\nreturn true;\r\nreject:\r\nreturn false;\r\n}\r\nstatic int run_checkers(const struct decode_checker *checkers[],\r\nint action, probes_opcode_t insn,\r\nstruct arch_probes_insn *asi,\r\nconst struct decode_header *h)\r\n{\r\nconst struct decode_checker **p;\r\nif (!checkers)\r\nreturn INSN_GOOD;\r\np = checkers;\r\nwhile (*p != NULL) {\r\nint retval;\r\nprobes_check_t *checker_func = (*p)[action].checker;\r\nretval = INSN_GOOD;\r\nif (checker_func)\r\nretval = checker_func(insn, asi, h);\r\nif (retval == INSN_REJECTED)\r\nreturn retval;\r\np++;\r\n}\r\nreturn INSN_GOOD;\r\n}\r\nint __kprobes\r\nprobes_decode_insn(probes_opcode_t insn, struct arch_probes_insn *asi,\r\nconst union decode_item *table, bool thumb,\r\nbool emulate, const union decode_action *actions,\r\nconst struct decode_checker *checkers[])\r\n{\r\nconst struct decode_header *h = (struct decode_header *)table;\r\nconst struct decode_header *next;\r\nbool matched = false;\r\nprobes_opcode_t origin_insn = insn;\r\nasi->stack_space = 0;\r\nasi->register_usage_flags = ~0UL;\r\nif (emulate)\r\ninsn = prepare_emulated_insn(insn, asi, thumb);\r\nfor (;; h = next) {\r\nenum decode_type type = h->type_regs.bits & DECODE_TYPE_MASK;\r\nu32 regs = h->type_regs.bits >> DECODE_TYPE_BITS;\r\nif (type == DECODE_TYPE_END)\r\nreturn INSN_REJECTED;\r\nnext = (struct decode_header *)\r\n((uintptr_t)h + decode_struct_sizes[type]);\r\nif (!matched && (insn & h->mask.bits) != h->value.bits)\r\ncontinue;\r\nif (!decode_regs(&insn, regs, emulate))\r\nreturn INSN_REJECTED;\r\nswitch (type) {\r\ncase DECODE_TYPE_TABLE: {\r\nstruct decode_table *d = (struct decode_table *)h;\r\nnext = (struct decode_header *)d->table.table;\r\nbreak;\r\n}\r\ncase DECODE_TYPE_CUSTOM: {\r\nint err;\r\nstruct decode_custom *d = (struct decode_custom *)h;\r\nint action = d->decoder.action;\r\nerr = run_checkers(checkers, action, origin_insn, asi, h);\r\nif (err == INSN_REJECTED)\r\nreturn INSN_REJECTED;\r\nreturn actions[action].decoder(insn, asi, h);\r\n}\r\ncase DECODE_TYPE_SIMULATE: {\r\nint err;\r\nstruct decode_simulate *d = (struct decode_simulate *)h;\r\nint action = d->handler.action;\r\nerr = run_checkers(checkers, action, origin_insn, asi, h);\r\nif (err == INSN_REJECTED)\r\nreturn INSN_REJECTED;\r\nasi->insn_handler = actions[action].handler;\r\nreturn INSN_GOOD_NO_SLOT;\r\n}\r\ncase DECODE_TYPE_EMULATE: {\r\nint err;\r\nstruct decode_emulate *d = (struct decode_emulate *)h;\r\nint action = d->handler.action;\r\nerr = run_checkers(checkers, action, origin_insn, asi, h);\r\nif (err == INSN_REJECTED)\r\nreturn INSN_REJECTED;\r\nif (!emulate)\r\nreturn actions[action].decoder(insn, asi, h);\r\nasi->insn_handler = actions[action].handler;\r\nset_emulated_insn(insn, asi, thumb);\r\nreturn INSN_GOOD;\r\n}\r\ncase DECODE_TYPE_OR:\r\nmatched = true;\r\nbreak;\r\ncase DECODE_TYPE_REJECT:\r\ndefault:\r\nreturn INSN_REJECTED;\r\n}\r\n}\r\n}
