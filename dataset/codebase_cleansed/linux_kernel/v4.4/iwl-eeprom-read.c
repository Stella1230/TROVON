static int iwl_eeprom_acquire_semaphore(struct iwl_trans *trans)\r\n{\r\nu16 count;\r\nint ret;\r\nfor (count = 0; count < EEPROM_SEM_RETRY_LIMIT; count++) {\r\niwl_set_bit(trans, CSR_HW_IF_CONFIG_REG,\r\nCSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM);\r\nret = iwl_poll_bit(trans, CSR_HW_IF_CONFIG_REG,\r\nCSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM,\r\nCSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM,\r\nEEPROM_SEM_TIMEOUT);\r\nif (ret >= 0) {\r\nIWL_DEBUG_EEPROM(trans->dev,\r\n"Acquired semaphore after %d tries.\n",\r\ncount+1);\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void iwl_eeprom_release_semaphore(struct iwl_trans *trans)\r\n{\r\niwl_clear_bit(trans, CSR_HW_IF_CONFIG_REG,\r\nCSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM);\r\n}\r\nstatic int iwl_eeprom_verify_signature(struct iwl_trans *trans, bool nvm_is_otp)\r\n{\r\nu32 gp = iwl_read32(trans, CSR_EEPROM_GP) & CSR_EEPROM_GP_VALID_MSK;\r\nIWL_DEBUG_EEPROM(trans->dev, "EEPROM signature=0x%08x\n", gp);\r\nswitch (gp) {\r\ncase CSR_EEPROM_GP_BAD_SIG_EEP_GOOD_SIG_OTP:\r\nif (!nvm_is_otp) {\r\nIWL_ERR(trans, "EEPROM with bad signature: 0x%08x\n",\r\ngp);\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\ncase CSR_EEPROM_GP_GOOD_SIG_EEP_LESS_THAN_4K:\r\ncase CSR_EEPROM_GP_GOOD_SIG_EEP_MORE_THAN_4K:\r\nif (nvm_is_otp) {\r\nIWL_ERR(trans, "OTP with bad signature: 0x%08x\n", gp);\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\ncase CSR_EEPROM_GP_BAD_SIGNATURE_BOTH_EEP_AND_OTP:\r\ndefault:\r\nIWL_ERR(trans,\r\n"bad EEPROM/OTP signature, type=%s, EEPROM_GP=0x%08x\n",\r\nnvm_is_otp ? "OTP" : "EEPROM", gp);\r\nreturn -ENOENT;\r\n}\r\n}\r\nstatic void iwl_set_otp_access_absolute(struct iwl_trans *trans)\r\n{\r\niwl_read32(trans, CSR_OTP_GP_REG);\r\niwl_clear_bit(trans, CSR_OTP_GP_REG,\r\nCSR_OTP_GP_REG_OTP_ACCESS_MODE);\r\n}\r\nstatic int iwl_nvm_is_otp(struct iwl_trans *trans)\r\n{\r\nu32 otpgp;\r\nswitch (trans->hw_rev & CSR_HW_REV_TYPE_MSK) {\r\ncase CSR_HW_REV_TYPE_NONE:\r\nIWL_ERR(trans, "Unknown hardware type\n");\r\nreturn -EIO;\r\ncase CSR_HW_REV_TYPE_5300:\r\ncase CSR_HW_REV_TYPE_5350:\r\ncase CSR_HW_REV_TYPE_5100:\r\ncase CSR_HW_REV_TYPE_5150:\r\nreturn 0;\r\ndefault:\r\notpgp = iwl_read32(trans, CSR_OTP_GP_REG);\r\nif (otpgp & CSR_OTP_GP_REG_DEVICE_SELECT)\r\nreturn 1;\r\nreturn 0;\r\n}\r\n}\r\nstatic int iwl_init_otp_access(struct iwl_trans *trans)\r\n{\r\nint ret;\r\niwl_write32(trans, CSR_GP_CNTRL,\r\niwl_read32(trans, CSR_GP_CNTRL) |\r\nCSR_GP_CNTRL_REG_FLAG_INIT_DONE);\r\nret = iwl_poll_bit(trans, CSR_GP_CNTRL,\r\nCSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,\r\nCSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,\r\n25000);\r\nif (ret < 0) {\r\nIWL_ERR(trans, "Time out access OTP\n");\r\n} else {\r\niwl_set_bits_prph(trans, APMG_PS_CTRL_REG,\r\nAPMG_PS_CTRL_VAL_RESET_REQ);\r\nudelay(5);\r\niwl_clear_bits_prph(trans, APMG_PS_CTRL_REG,\r\nAPMG_PS_CTRL_VAL_RESET_REQ);\r\nif (trans->cfg->base_params->shadow_ram_support)\r\niwl_set_bit(trans, CSR_DBG_LINK_PWR_MGMT_REG,\r\nCSR_RESET_LINK_PWR_MGMT_DISABLED);\r\n}\r\nreturn ret;\r\n}\r\nstatic int iwl_read_otp_word(struct iwl_trans *trans, u16 addr,\r\n__le16 *eeprom_data)\r\n{\r\nint ret = 0;\r\nu32 r;\r\nu32 otpgp;\r\niwl_write32(trans, CSR_EEPROM_REG,\r\nCSR_EEPROM_REG_MSK_ADDR & (addr << 1));\r\nret = iwl_poll_bit(trans, CSR_EEPROM_REG,\r\nCSR_EEPROM_REG_READ_VALID_MSK,\r\nCSR_EEPROM_REG_READ_VALID_MSK,\r\nIWL_EEPROM_ACCESS_TIMEOUT);\r\nif (ret < 0) {\r\nIWL_ERR(trans, "Time out reading OTP[%d]\n", addr);\r\nreturn ret;\r\n}\r\nr = iwl_read32(trans, CSR_EEPROM_REG);\r\notpgp = iwl_read32(trans, CSR_OTP_GP_REG);\r\nif (otpgp & CSR_OTP_GP_REG_ECC_UNCORR_STATUS_MSK) {\r\niwl_set_bit(trans, CSR_OTP_GP_REG,\r\nCSR_OTP_GP_REG_ECC_UNCORR_STATUS_MSK);\r\nIWL_ERR(trans, "Uncorrectable OTP ECC error, abort OTP read\n");\r\nreturn -EINVAL;\r\n}\r\nif (otpgp & CSR_OTP_GP_REG_ECC_CORR_STATUS_MSK) {\r\niwl_set_bit(trans, CSR_OTP_GP_REG,\r\nCSR_OTP_GP_REG_ECC_CORR_STATUS_MSK);\r\nIWL_ERR(trans, "Correctable OTP ECC error, continue read\n");\r\n}\r\n*eeprom_data = cpu_to_le16(r >> 16);\r\nreturn 0;\r\n}\r\nstatic bool iwl_is_otp_empty(struct iwl_trans *trans)\r\n{\r\nu16 next_link_addr = 0;\r\n__le16 link_value;\r\nbool is_empty = false;\r\nif (!iwl_read_otp_word(trans, next_link_addr, &link_value)) {\r\nif (!link_value) {\r\nIWL_ERR(trans, "OTP is empty\n");\r\nis_empty = true;\r\n}\r\n} else {\r\nIWL_ERR(trans, "Unable to read first block of OTP list.\n");\r\nis_empty = true;\r\n}\r\nreturn is_empty;\r\n}\r\nstatic int iwl_find_otp_image(struct iwl_trans *trans,\r\nu16 *validblockaddr)\r\n{\r\nu16 next_link_addr = 0, valid_addr;\r\n__le16 link_value = 0;\r\nint usedblocks = 0;\r\niwl_set_otp_access_absolute(trans);\r\nif (iwl_is_otp_empty(trans))\r\nreturn -EINVAL;\r\ndo {\r\nvalid_addr = next_link_addr;\r\nnext_link_addr = le16_to_cpu(link_value) * sizeof(u16);\r\nIWL_DEBUG_EEPROM(trans->dev, "OTP blocks %d addr 0x%x\n",\r\nusedblocks, next_link_addr);\r\nif (iwl_read_otp_word(trans, next_link_addr, &link_value))\r\nreturn -EINVAL;\r\nif (!link_value) {\r\n*validblockaddr = valid_addr;\r\n*validblockaddr += 2;\r\nreturn 0;\r\n}\r\nusedblocks++;\r\n} while (usedblocks <= trans->cfg->base_params->max_ll_items);\r\nIWL_DEBUG_EEPROM(trans->dev, "OTP has no valid blocks\n");\r\nreturn -EINVAL;\r\n}\r\nint iwl_read_eeprom(struct iwl_trans *trans, u8 **eeprom, size_t *eeprom_size)\r\n{\r\n__le16 *e;\r\nu32 gp = iwl_read32(trans, CSR_EEPROM_GP);\r\nint sz;\r\nint ret;\r\nu16 addr;\r\nu16 validblockaddr = 0;\r\nu16 cache_addr = 0;\r\nint nvm_is_otp;\r\nif (!eeprom || !eeprom_size)\r\nreturn -EINVAL;\r\nnvm_is_otp = iwl_nvm_is_otp(trans);\r\nif (nvm_is_otp < 0)\r\nreturn nvm_is_otp;\r\nsz = trans->cfg->base_params->eeprom_size;\r\nIWL_DEBUG_EEPROM(trans->dev, "NVM size = %d\n", sz);\r\ne = kmalloc(sz, GFP_KERNEL);\r\nif (!e)\r\nreturn -ENOMEM;\r\nret = iwl_eeprom_verify_signature(trans, nvm_is_otp);\r\nif (ret < 0) {\r\nIWL_ERR(trans, "EEPROM not found, EEPROM_GP=0x%08x\n", gp);\r\ngoto err_free;\r\n}\r\nret = iwl_eeprom_acquire_semaphore(trans);\r\nif (ret < 0) {\r\nIWL_ERR(trans, "Failed to acquire EEPROM semaphore.\n");\r\ngoto err_free;\r\n}\r\nif (nvm_is_otp) {\r\nret = iwl_init_otp_access(trans);\r\nif (ret) {\r\nIWL_ERR(trans, "Failed to initialize OTP access.\n");\r\ngoto err_unlock;\r\n}\r\niwl_write32(trans, CSR_EEPROM_GP,\r\niwl_read32(trans, CSR_EEPROM_GP) &\r\n~CSR_EEPROM_GP_IF_OWNER_MSK);\r\niwl_set_bit(trans, CSR_OTP_GP_REG,\r\nCSR_OTP_GP_REG_ECC_CORR_STATUS_MSK |\r\nCSR_OTP_GP_REG_ECC_UNCORR_STATUS_MSK);\r\nif (!trans->cfg->base_params->shadow_ram_support) {\r\nret = iwl_find_otp_image(trans, &validblockaddr);\r\nif (ret)\r\ngoto err_unlock;\r\n}\r\nfor (addr = validblockaddr; addr < validblockaddr + sz;\r\naddr += sizeof(u16)) {\r\n__le16 eeprom_data;\r\nret = iwl_read_otp_word(trans, addr, &eeprom_data);\r\nif (ret)\r\ngoto err_unlock;\r\ne[cache_addr / 2] = eeprom_data;\r\ncache_addr += sizeof(u16);\r\n}\r\n} else {\r\nfor (addr = 0; addr < sz; addr += sizeof(u16)) {\r\nu32 r;\r\niwl_write32(trans, CSR_EEPROM_REG,\r\nCSR_EEPROM_REG_MSK_ADDR & (addr << 1));\r\nret = iwl_poll_bit(trans, CSR_EEPROM_REG,\r\nCSR_EEPROM_REG_READ_VALID_MSK,\r\nCSR_EEPROM_REG_READ_VALID_MSK,\r\nIWL_EEPROM_ACCESS_TIMEOUT);\r\nif (ret < 0) {\r\nIWL_ERR(trans,\r\n"Time out reading EEPROM[%d]\n", addr);\r\ngoto err_unlock;\r\n}\r\nr = iwl_read32(trans, CSR_EEPROM_REG);\r\ne[addr / 2] = cpu_to_le16(r >> 16);\r\n}\r\n}\r\nIWL_DEBUG_EEPROM(trans->dev, "NVM Type: %s\n",\r\nnvm_is_otp ? "OTP" : "EEPROM");\r\niwl_eeprom_release_semaphore(trans);\r\n*eeprom_size = sz;\r\n*eeprom = (u8 *)e;\r\nreturn 0;\r\nerr_unlock:\r\niwl_eeprom_release_semaphore(trans);\r\nerr_free:\r\nkfree(e);\r\nreturn ret;\r\n}
