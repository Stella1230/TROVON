static void ics_rtas_unmask_irq(struct irq_data *d)\r\n{\r\nunsigned int hw_irq = (unsigned int)irqd_to_hwirq(d);\r\nint call_status;\r\nint server;\r\npr_devel("xics: unmask virq %d [hw 0x%x]\n", d->irq, hw_irq);\r\nif (hw_irq == XICS_IPI || hw_irq == XICS_IRQ_SPURIOUS)\r\nreturn;\r\nserver = xics_get_irq_server(d->irq, irq_data_get_affinity_mask(d), 0);\r\ncall_status = rtas_call(ibm_set_xive, 3, 1, NULL, hw_irq, server,\r\nDEFAULT_PRIORITY);\r\nif (call_status != 0) {\r\nprintk(KERN_ERR\r\n"%s: ibm_set_xive irq %u server %x returned %d\n",\r\n__func__, hw_irq, server, call_status);\r\nreturn;\r\n}\r\ncall_status = rtas_call(ibm_int_on, 1, 1, NULL, hw_irq);\r\nif (call_status != 0) {\r\nprintk(KERN_ERR "%s: ibm_int_on irq=%u returned %d\n",\r\n__func__, hw_irq, call_status);\r\nreturn;\r\n}\r\n}\r\nstatic unsigned int ics_rtas_startup(struct irq_data *d)\r\n{\r\n#ifdef CONFIG_PCI_MSI\r\nif (irq_data_get_msi_desc(d))\r\npci_msi_unmask_irq(d);\r\n#endif\r\nics_rtas_unmask_irq(d);\r\nreturn 0;\r\n}\r\nstatic void ics_rtas_mask_real_irq(unsigned int hw_irq)\r\n{\r\nint call_status;\r\nif (hw_irq == XICS_IPI)\r\nreturn;\r\ncall_status = rtas_call(ibm_int_off, 1, 1, NULL, hw_irq);\r\nif (call_status != 0) {\r\nprintk(KERN_ERR "%s: ibm_int_off irq=%u returned %d\n",\r\n__func__, hw_irq, call_status);\r\nreturn;\r\n}\r\ncall_status = rtas_call(ibm_set_xive, 3, 1, NULL, hw_irq,\r\nxics_default_server, 0xff);\r\nif (call_status != 0) {\r\nprintk(KERN_ERR "%s: ibm_set_xive(0xff) irq=%u returned %d\n",\r\n__func__, hw_irq, call_status);\r\nreturn;\r\n}\r\n}\r\nstatic void ics_rtas_mask_irq(struct irq_data *d)\r\n{\r\nunsigned int hw_irq = (unsigned int)irqd_to_hwirq(d);\r\npr_devel("xics: mask virq %d [hw 0x%x]\n", d->irq, hw_irq);\r\nif (hw_irq == XICS_IPI || hw_irq == XICS_IRQ_SPURIOUS)\r\nreturn;\r\nics_rtas_mask_real_irq(hw_irq);\r\n}\r\nstatic int ics_rtas_set_affinity(struct irq_data *d,\r\nconst struct cpumask *cpumask,\r\nbool force)\r\n{\r\nunsigned int hw_irq = (unsigned int)irqd_to_hwirq(d);\r\nint status;\r\nint xics_status[2];\r\nint irq_server;\r\nif (hw_irq == XICS_IPI || hw_irq == XICS_IRQ_SPURIOUS)\r\nreturn -1;\r\nstatus = rtas_call(ibm_get_xive, 1, 3, xics_status, hw_irq);\r\nif (status) {\r\nprintk(KERN_ERR "%s: ibm,get-xive irq=%u returns %d\n",\r\n__func__, hw_irq, status);\r\nreturn -1;\r\n}\r\nirq_server = xics_get_irq_server(d->irq, cpumask, 1);\r\nif (irq_server == -1) {\r\npr_warning("%s: No online cpus in the mask %*pb for irq %d\n",\r\n__func__, cpumask_pr_args(cpumask), d->irq);\r\nreturn -1;\r\n}\r\nstatus = rtas_call(ibm_set_xive, 3, 1, NULL,\r\nhw_irq, irq_server, xics_status[1]);\r\nif (status) {\r\nprintk(KERN_ERR "%s: ibm,set-xive irq=%u returns %d\n",\r\n__func__, hw_irq, status);\r\nreturn -1;\r\n}\r\nreturn IRQ_SET_MASK_OK;\r\n}\r\nstatic int ics_rtas_map(struct ics *ics, unsigned int virq)\r\n{\r\nunsigned int hw_irq = (unsigned int)virq_to_hw(virq);\r\nint status[2];\r\nint rc;\r\nif (WARN_ON(hw_irq == XICS_IPI || hw_irq == XICS_IRQ_SPURIOUS))\r\nreturn -EINVAL;\r\nrc = rtas_call(ibm_get_xive, 1, 3, status, hw_irq);\r\nif (rc)\r\nreturn -ENXIO;\r\nirq_set_chip_and_handler(virq, &ics_rtas_irq_chip, handle_fasteoi_irq);\r\nirq_set_chip_data(virq, &ics_rtas);\r\nreturn 0;\r\n}\r\nstatic void ics_rtas_mask_unknown(struct ics *ics, unsigned long vec)\r\n{\r\nics_rtas_mask_real_irq(vec);\r\n}\r\nstatic long ics_rtas_get_server(struct ics *ics, unsigned long vec)\r\n{\r\nint rc, status[2];\r\nrc = rtas_call(ibm_get_xive, 1, 3, status, vec);\r\nif (rc)\r\nreturn -1;\r\nreturn status[0];\r\n}\r\nstatic int ics_rtas_host_match(struct ics *ics, struct device_node *node)\r\n{\r\nreturn !of_device_is_compatible(node, "chrp,iic");\r\n}\r\n__init int ics_rtas_init(void)\r\n{\r\nibm_get_xive = rtas_token("ibm,get-xive");\r\nibm_set_xive = rtas_token("ibm,set-xive");\r\nibm_int_on = rtas_token("ibm,int-on");\r\nibm_int_off = rtas_token("ibm,int-off");\r\nif (ibm_get_xive == RTAS_UNKNOWN_SERVICE ||\r\nibm_set_xive == RTAS_UNKNOWN_SERVICE)\r\nreturn -ENODEV;\r\nics_rtas_irq_chip.irq_eoi = icp_ops->eoi;\r\nxics_register_ics(&ics_rtas);\r\nreturn 0;\r\n}
