static struct as3711_bl_supply *to_supply(struct as3711_bl_data *su)\r\n{\r\nswitch (su->type) {\r\ncase AS3711_BL_SU1:\r\nreturn container_of(su, struct as3711_bl_supply, su1);\r\ncase AS3711_BL_SU2:\r\nreturn container_of(su, struct as3711_bl_supply, su2);\r\n}\r\nreturn NULL;\r\n}\r\nstatic int as3711_set_brightness_auto_i(struct as3711_bl_data *data,\r\nunsigned int brightness)\r\n{\r\nstruct as3711_bl_supply *supply = to_supply(data);\r\nstruct as3711 *as3711 = supply->as3711;\r\nconst struct as3711_bl_pdata *pdata = supply->pdata;\r\nint ret = 0;\r\nif (pdata->su2_auto_curr1)\r\nret = regmap_write(as3711->regmap, AS3711_CURR1_VALUE,\r\nbrightness);\r\nif (!ret && pdata->su2_auto_curr2)\r\nret = regmap_write(as3711->regmap, AS3711_CURR2_VALUE,\r\nbrightness);\r\nif (!ret && pdata->su2_auto_curr3)\r\nret = regmap_write(as3711->regmap, AS3711_CURR3_VALUE,\r\nbrightness);\r\nreturn ret;\r\n}\r\nstatic int as3711_set_brightness_v(struct as3711 *as3711,\r\nunsigned int brightness,\r\nunsigned int reg)\r\n{\r\nif (brightness > 31)\r\nreturn -EINVAL;\r\nreturn regmap_update_bits(as3711->regmap, reg, 0xf0,\r\nbrightness << 4);\r\n}\r\nstatic int as3711_bl_su2_reset(struct as3711_bl_supply *supply)\r\n{\r\nstruct as3711 *as3711 = supply->as3711;\r\nint ret = regmap_update_bits(as3711->regmap, AS3711_STEPUP_CONTROL_5,\r\n3, supply->pdata->su2_fbprot);\r\nif (!ret)\r\nret = regmap_update_bits(as3711->regmap,\r\nAS3711_STEPUP_CONTROL_2, 1, 0);\r\nif (!ret)\r\nret = regmap_update_bits(as3711->regmap,\r\nAS3711_STEPUP_CONTROL_2, 1, 1);\r\nreturn ret;\r\n}\r\nstatic int as3711_bl_update_status(struct backlight_device *bl)\r\n{\r\nstruct as3711_bl_data *data = bl_get_data(bl);\r\nstruct as3711_bl_supply *supply = to_supply(data);\r\nstruct as3711 *as3711 = supply->as3711;\r\nint brightness = bl->props.brightness;\r\nint ret = 0;\r\ndev_dbg(&bl->dev, "%s(): brightness %u, pwr %x, blank %x, state %x\n",\r\n__func__, bl->props.brightness, bl->props.power,\r\nbl->props.fb_blank, bl->props.state);\r\nif (bl->props.power != FB_BLANK_UNBLANK ||\r\nbl->props.fb_blank != FB_BLANK_UNBLANK ||\r\nbl->props.state & (BL_CORE_SUSPENDED | BL_CORE_FBBLANK))\r\nbrightness = 0;\r\nif (data->type == AS3711_BL_SU1) {\r\nret = as3711_set_brightness_v(as3711, brightness,\r\nAS3711_STEPUP_CONTROL_1);\r\n} else {\r\nconst struct as3711_bl_pdata *pdata = supply->pdata;\r\nswitch (pdata->su2_feedback) {\r\ncase AS3711_SU2_VOLTAGE:\r\nret = as3711_set_brightness_v(as3711, brightness,\r\nAS3711_STEPUP_CONTROL_2);\r\nbreak;\r\ncase AS3711_SU2_CURR_AUTO:\r\nret = as3711_set_brightness_auto_i(data, brightness / 4);\r\nif (ret < 0)\r\nreturn ret;\r\nif (brightness) {\r\nret = as3711_bl_su2_reset(supply);\r\nif (ret < 0)\r\nreturn ret;\r\nudelay(500);\r\nret = as3711_set_brightness_auto_i(data, brightness);\r\n} else {\r\nret = regmap_update_bits(as3711->regmap,\r\nAS3711_STEPUP_CONTROL_2, 1, 0);\r\n}\r\nbreak;\r\ncase AS3711_SU2_CURR1:\r\nret = regmap_write(as3711->regmap, AS3711_CURR1_VALUE,\r\nbrightness);\r\nbreak;\r\ncase AS3711_SU2_CURR2:\r\nret = regmap_write(as3711->regmap, AS3711_CURR2_VALUE,\r\nbrightness);\r\nbreak;\r\ncase AS3711_SU2_CURR3:\r\nret = regmap_write(as3711->regmap, AS3711_CURR3_VALUE,\r\nbrightness);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\n}\r\nif (!ret)\r\ndata->brightness = brightness;\r\nreturn ret;\r\n}\r\nstatic int as3711_bl_get_brightness(struct backlight_device *bl)\r\n{\r\nstruct as3711_bl_data *data = bl_get_data(bl);\r\nreturn data->brightness;\r\n}\r\nstatic int as3711_bl_init_su2(struct as3711_bl_supply *supply)\r\n{\r\nstruct as3711 *as3711 = supply->as3711;\r\nconst struct as3711_bl_pdata *pdata = supply->pdata;\r\nu8 ctl = 0;\r\nint ret;\r\ndev_dbg(as3711->dev, "%s(): use %u\n", __func__, pdata->su2_feedback);\r\nret = regmap_write(as3711->regmap, AS3711_STEPUP_CONTROL_2, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (pdata->su2_feedback) {\r\ncase AS3711_SU2_VOLTAGE:\r\nret = regmap_update_bits(as3711->regmap, AS3711_STEPUP_CONTROL_4, 3, 0);\r\nbreak;\r\ncase AS3711_SU2_CURR1:\r\nctl = 1;\r\nret = regmap_update_bits(as3711->regmap, AS3711_STEPUP_CONTROL_4, 3, 1);\r\nbreak;\r\ncase AS3711_SU2_CURR2:\r\nctl = 4;\r\nret = regmap_update_bits(as3711->regmap, AS3711_STEPUP_CONTROL_4, 3, 2);\r\nbreak;\r\ncase AS3711_SU2_CURR3:\r\nctl = 0x10;\r\nret = regmap_update_bits(as3711->regmap, AS3711_STEPUP_CONTROL_4, 3, 3);\r\nbreak;\r\ncase AS3711_SU2_CURR_AUTO:\r\nif (pdata->su2_auto_curr1)\r\nctl = 2;\r\nif (pdata->su2_auto_curr2)\r\nctl |= 8;\r\nif (pdata->su2_auto_curr3)\r\nctl |= 0x20;\r\nret = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!ret)\r\nret = regmap_write(as3711->regmap, AS3711_CURR_CONTROL, ctl);\r\nreturn ret;\r\n}\r\nstatic int as3711_bl_register(struct platform_device *pdev,\r\nunsigned int max_brightness, struct as3711_bl_data *su)\r\n{\r\nstruct backlight_properties props = {.type = BACKLIGHT_RAW,};\r\nstruct backlight_device *bl;\r\nprops.max_brightness = max_brightness;\r\nbl = devm_backlight_device_register(&pdev->dev,\r\nsu->type == AS3711_BL_SU1 ?\r\n"as3711-su1" : "as3711-su2",\r\n&pdev->dev, su,\r\n&as3711_bl_ops, &props);\r\nif (IS_ERR(bl)) {\r\ndev_err(&pdev->dev, "failed to register backlight\n");\r\nreturn PTR_ERR(bl);\r\n}\r\nbl->props.brightness = props.max_brightness;\r\nbacklight_update_status(bl);\r\nsu->bl = bl;\r\nreturn 0;\r\n}\r\nstatic int as3711_backlight_parse_dt(struct device *dev)\r\n{\r\nstruct as3711_bl_pdata *pdata = dev_get_platdata(dev);\r\nstruct device_node *bl =\r\nof_find_node_by_name(dev->parent->of_node, "backlight"), *fb;\r\nint ret;\r\nif (!bl) {\r\ndev_dbg(dev, "backlight node not found\n");\r\nreturn -ENODEV;\r\n}\r\nfb = of_parse_phandle(bl, "su1-dev", 0);\r\nif (fb) {\r\npdata->su1_fb = fb->full_name;\r\nret = of_property_read_u32(bl, "su1-max-uA", &pdata->su1_max_uA);\r\nif (pdata->su1_max_uA <= 0)\r\nret = -EINVAL;\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nfb = of_parse_phandle(bl, "su2-dev", 0);\r\nif (fb) {\r\nint count = 0;\r\npdata->su2_fb = fb->full_name;\r\nret = of_property_read_u32(bl, "su2-max-uA", &pdata->su2_max_uA);\r\nif (pdata->su2_max_uA <= 0)\r\nret = -EINVAL;\r\nif (ret < 0)\r\nreturn ret;\r\nif (of_find_property(bl, "su2-feedback-voltage", NULL)) {\r\npdata->su2_feedback = AS3711_SU2_VOLTAGE;\r\ncount++;\r\n}\r\nif (of_find_property(bl, "su2-feedback-curr1", NULL)) {\r\npdata->su2_feedback = AS3711_SU2_CURR1;\r\ncount++;\r\n}\r\nif (of_find_property(bl, "su2-feedback-curr2", NULL)) {\r\npdata->su2_feedback = AS3711_SU2_CURR2;\r\ncount++;\r\n}\r\nif (of_find_property(bl, "su2-feedback-curr3", NULL)) {\r\npdata->su2_feedback = AS3711_SU2_CURR3;\r\ncount++;\r\n}\r\nif (of_find_property(bl, "su2-feedback-curr-auto", NULL)) {\r\npdata->su2_feedback = AS3711_SU2_CURR_AUTO;\r\ncount++;\r\n}\r\nif (count != 1)\r\nreturn -EINVAL;\r\ncount = 0;\r\nif (of_find_property(bl, "su2-fbprot-lx-sd4", NULL)) {\r\npdata->su2_fbprot = AS3711_SU2_LX_SD4;\r\ncount++;\r\n}\r\nif (of_find_property(bl, "su2-fbprot-gpio2", NULL)) {\r\npdata->su2_fbprot = AS3711_SU2_GPIO2;\r\ncount++;\r\n}\r\nif (of_find_property(bl, "su2-fbprot-gpio3", NULL)) {\r\npdata->su2_fbprot = AS3711_SU2_GPIO3;\r\ncount++;\r\n}\r\nif (of_find_property(bl, "su2-fbprot-gpio4", NULL)) {\r\npdata->su2_fbprot = AS3711_SU2_GPIO4;\r\ncount++;\r\n}\r\nif (count != 1)\r\nreturn -EINVAL;\r\ncount = 0;\r\nif (of_find_property(bl, "su2-auto-curr1", NULL)) {\r\npdata->su2_auto_curr1 = true;\r\ncount++;\r\n}\r\nif (of_find_property(bl, "su2-auto-curr2", NULL)) {\r\npdata->su2_auto_curr2 = true;\r\ncount++;\r\n}\r\nif (of_find_property(bl, "su2-auto-curr3", NULL)) {\r\npdata->su2_auto_curr3 = true;\r\ncount++;\r\n}\r\nif (!count ^ (pdata->su2_feedback != AS3711_SU2_CURR_AUTO))\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int as3711_backlight_probe(struct platform_device *pdev)\r\n{\r\nstruct as3711_bl_pdata *pdata = dev_get_platdata(&pdev->dev);\r\nstruct as3711 *as3711 = dev_get_drvdata(pdev->dev.parent);\r\nstruct as3711_bl_supply *supply;\r\nstruct as3711_bl_data *su;\r\nunsigned int max_brightness;\r\nint ret;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "No platform data, exiting...\n");\r\nreturn -ENODEV;\r\n}\r\nif (pdev->dev.parent->of_node) {\r\nret = as3711_backlight_parse_dt(&pdev->dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "DT parsing failed: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nif (!pdata->su1_fb && !pdata->su2_fb) {\r\ndev_err(&pdev->dev, "No framebuffer specified\n");\r\nreturn -EINVAL;\r\n}\r\nif (pdata->su1_fb ||\r\npdata->su2_fbprot != AS3711_SU2_GPIO4 ||\r\npdata->su2_feedback != AS3711_SU2_CURR_AUTO) {\r\ndev_warn(&pdev->dev,\r\n"Attention! An untested mode has been chosen!\n"\r\n"Please, review the code, enable, test, and report success:-)\n");\r\nreturn -EINVAL;\r\n}\r\nsupply = devm_kzalloc(&pdev->dev, sizeof(*supply), GFP_KERNEL);\r\nif (!supply)\r\nreturn -ENOMEM;\r\nsupply->as3711 = as3711;\r\nsupply->pdata = pdata;\r\nif (pdata->su1_fb) {\r\nsu = &supply->su1;\r\nsu->fb_name = pdata->su1_fb;\r\nsu->type = AS3711_BL_SU1;\r\nmax_brightness = min(pdata->su1_max_uA, 31);\r\nret = as3711_bl_register(pdev, max_brightness, su);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (pdata->su2_fb) {\r\nsu = &supply->su2;\r\nsu->fb_name = pdata->su2_fb;\r\nsu->type = AS3711_BL_SU2;\r\nswitch (pdata->su2_fbprot) {\r\ncase AS3711_SU2_GPIO2:\r\ncase AS3711_SU2_GPIO3:\r\ncase AS3711_SU2_GPIO4:\r\ncase AS3711_SU2_LX_SD4:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (pdata->su2_feedback) {\r\ncase AS3711_SU2_VOLTAGE:\r\nmax_brightness = min(pdata->su2_max_uA, 31);\r\nbreak;\r\ncase AS3711_SU2_CURR1:\r\ncase AS3711_SU2_CURR2:\r\ncase AS3711_SU2_CURR3:\r\ncase AS3711_SU2_CURR_AUTO:\r\nmax_brightness = min(pdata->su2_max_uA / 150, 255);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = as3711_bl_init_su2(supply);\r\nif (ret < 0)\r\nreturn ret;\r\nret = as3711_bl_register(pdev, max_brightness, su);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, supply);\r\nreturn 0;\r\n}
