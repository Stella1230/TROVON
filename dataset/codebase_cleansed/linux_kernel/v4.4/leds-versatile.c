static void versatile_led_set(struct led_classdev *cdev,\r\nenum led_brightness b)\r\n{\r\nstruct versatile_led *led = container_of(cdev,\r\nstruct versatile_led, cdev);\r\nu32 reg = readl(led->base);\r\nif (b != LED_OFF)\r\nreg |= led->mask;\r\nelse\r\nreg &= ~led->mask;\r\nwritel(reg, led->base);\r\n}\r\nstatic enum led_brightness versatile_led_get(struct led_classdev *cdev)\r\n{\r\nstruct versatile_led *led = container_of(cdev,\r\nstruct versatile_led, cdev);\r\nu32 reg = readl(led->base);\r\nreturn (reg & led->mask) ? LED_FULL : LED_OFF;\r\n}\r\nstatic int versatile_leds_probe(struct platform_device *dev)\r\n{\r\nint i;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&dev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nwritel(0, base);\r\nfor (i = 0; i < ARRAY_SIZE(versatile_leds); i++) {\r\nstruct versatile_led *led;\r\nled = kzalloc(sizeof(*led), GFP_KERNEL);\r\nif (!led)\r\nbreak;\r\nled->base = base;\r\nled->cdev.name = versatile_leds[i].name;\r\nled->cdev.brightness_set = versatile_led_set;\r\nled->cdev.brightness_get = versatile_led_get;\r\nled->cdev.default_trigger = versatile_leds[i].trigger;\r\nled->mask = BIT(i);\r\nif (led_classdev_register(NULL, &led->cdev) < 0) {\r\nkfree(led);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}
