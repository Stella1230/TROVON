int\r\ngf119_disp_root_scanoutpos(NV50_DISP_MTHD_V0)\r\n{\r\nstruct nvkm_device *device = disp->base.engine.subdev.device;\r\nconst u32 total = nvkm_rd32(device, 0x640414 + (head * 0x300));\r\nconst u32 blanke = nvkm_rd32(device, 0x64041c + (head * 0x300));\r\nconst u32 blanks = nvkm_rd32(device, 0x640420 + (head * 0x300));\r\nunion {\r\nstruct nv04_disp_scanoutpos_v0 v0;\r\n} *args = data;\r\nint ret;\r\nnvif_ioctl(object, "disp scanoutpos size %d\n", size);\r\nif (nvif_unpack(args->v0, 0, 0, false)) {\r\nnvif_ioctl(object, "disp scanoutpos vers %d\n",\r\nargs->v0.version);\r\nargs->v0.vblanke = (blanke & 0xffff0000) >> 16;\r\nargs->v0.hblanke = (blanke & 0x0000ffff);\r\nargs->v0.vblanks = (blanks & 0xffff0000) >> 16;\r\nargs->v0.hblanks = (blanks & 0x0000ffff);\r\nargs->v0.vtotal = ( total & 0xffff0000) >> 16;\r\nargs->v0.htotal = ( total & 0x0000ffff);\r\nargs->v0.time[0] = ktime_to_ns(ktime_get());\r\nargs->v0.vline =\r\nnvkm_rd32(device, 0x616340 + (head * 0x800)) & 0xffff;\r\nargs->v0.time[1] = ktime_to_ns(ktime_get());\r\nargs->v0.hline =\r\nnvkm_rd32(device, 0x616344 + (head * 0x800)) & 0xffff;\r\n} else\r\nreturn ret;\r\nreturn 0;\r\n}\r\nvoid\r\ngf119_disp_root_fini(struct nv50_disp_root *root)\r\n{\r\nstruct nvkm_device *device = root->disp->base.engine.subdev.device;\r\nnvkm_wr32(device, 0x6100b0, 0x00000000);\r\n}\r\nint\r\ngf119_disp_root_init(struct nv50_disp_root *root)\r\n{\r\nstruct nv50_disp *disp = root->disp;\r\nstruct nvkm_device *device = disp->base.engine.subdev.device;\r\nu32 tmp;\r\nint i;\r\nfor (i = 0; i < disp->base.head.nr; i++) {\r\ntmp = nvkm_rd32(device, 0x616104 + (i * 0x800));\r\nnvkm_wr32(device, 0x6101b4 + (i * 0x800), tmp);\r\ntmp = nvkm_rd32(device, 0x616108 + (i * 0x800));\r\nnvkm_wr32(device, 0x6101b8 + (i * 0x800), tmp);\r\ntmp = nvkm_rd32(device, 0x61610c + (i * 0x800));\r\nnvkm_wr32(device, 0x6101bc + (i * 0x800), tmp);\r\n}\r\nfor (i = 0; i < disp->func->dac.nr; i++) {\r\ntmp = nvkm_rd32(device, 0x61a000 + (i * 0x800));\r\nnvkm_wr32(device, 0x6101c0 + (i * 0x800), tmp);\r\n}\r\nfor (i = 0; i < disp->func->sor.nr; i++) {\r\ntmp = nvkm_rd32(device, 0x61c000 + (i * 0x800));\r\nnvkm_wr32(device, 0x6301c4 + (i * 0x800), tmp);\r\n}\r\nif (nvkm_rd32(device, 0x6100ac) & 0x00000100) {\r\nnvkm_wr32(device, 0x6100ac, 0x00000100);\r\nnvkm_mask(device, 0x6194e8, 0x00000001, 0x00000000);\r\nif (nvkm_msec(device, 2000,\r\nif (!(nvkm_rd32(device, 0x6194e8) & 0x00000002))\r\nbreak;\r\n) < 0)\r\nreturn -EBUSY;\r\n}\r\nnvkm_wr32(device, 0x610010, (root->instmem->addr >> 8) | 9);\r\nnvkm_wr32(device, 0x610090, 0x00000000);\r\nnvkm_wr32(device, 0x6100a0, 0x00000000);\r\nnvkm_wr32(device, 0x6100b0, 0x00000307);\r\nfor (i = 0; i < disp->base.head.nr; i++)\r\nnvkm_mask(device, 0x616308 + (i * 0x800), 0x00000111, 0x00000010);\r\nreturn 0;\r\n}\r\nstatic int\r\ngf119_disp_root_new(struct nvkm_disp *disp, const struct nvkm_oclass *oclass,\r\nvoid *data, u32 size, struct nvkm_object **pobject)\r\n{\r\nreturn nv50_disp_root_new_(&gf119_disp_root, disp, oclass,\r\ndata, size, pobject);\r\n}
