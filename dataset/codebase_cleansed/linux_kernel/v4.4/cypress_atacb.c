static void cypress_atacb_passthrough(struct scsi_cmnd *srb, struct us_data *us)\r\n{\r\nunsigned char save_cmnd[MAX_COMMAND_SIZE];\r\nif (likely(srb->cmnd[0] != ATA_16 && srb->cmnd[0] != ATA_12)) {\r\nusb_stor_transparent_scsi_command(srb, us);\r\nreturn;\r\n}\r\nmemcpy(save_cmnd, srb->cmnd, sizeof(save_cmnd));\r\nmemset(srb->cmnd, 0, MAX_COMMAND_SIZE);\r\nif (save_cmnd[1] >> 5)\r\ngoto invalid_fld;\r\nswitch ((save_cmnd[1] >> 1) & 0xf) {\r\ncase 3:\r\ncase 4:\r\ncase 5:\r\nbreak;\r\ndefault:\r\ngoto invalid_fld;\r\n}\r\nsrb->cmd_len = 16;\r\nsrb->cmnd[0] = 0x24;\r\nsrb->cmnd[1] = 0x24;\r\nsrb->cmnd[3] = 0xff - 1;\r\nsrb->cmnd[4] = 1;\r\nif (save_cmnd[0] == ATA_16) {\r\nsrb->cmnd[ 6] = save_cmnd[ 4];\r\nsrb->cmnd[ 7] = save_cmnd[ 6];\r\nsrb->cmnd[ 8] = save_cmnd[ 8];\r\nsrb->cmnd[ 9] = save_cmnd[10];\r\nsrb->cmnd[10] = save_cmnd[12];\r\nsrb->cmnd[11] = save_cmnd[13];\r\nsrb->cmnd[12] = save_cmnd[14];\r\nif (save_cmnd[1] & 0x01) {\r\nif (save_cmnd[3] || save_cmnd[5] || save_cmnd[7] || save_cmnd[9]\r\n|| save_cmnd[11])\r\ngoto invalid_fld;\r\n}\r\n} else {\r\nsrb->cmnd[ 6] = save_cmnd[3];\r\nsrb->cmnd[ 7] = save_cmnd[4];\r\nsrb->cmnd[ 8] = save_cmnd[5];\r\nsrb->cmnd[ 9] = save_cmnd[6];\r\nsrb->cmnd[10] = save_cmnd[7];\r\nsrb->cmnd[11] = save_cmnd[8];\r\nsrb->cmnd[12] = save_cmnd[9];\r\n}\r\nif ((srb->cmnd[12] == ATA_CMD_SET_FEATURES)\r\n&& (srb->cmnd[6] == SETFEATURES_XFER))\r\ngoto invalid_fld;\r\nif (srb->cmnd[12] == ATA_CMD_ID_ATA || srb->cmnd[12] == ATA_CMD_ID_ATAPI)\r\nsrb->cmnd[2] |= (1<<7);\r\nusb_stor_transparent_scsi_command(srb, us);\r\nif (srb->result == SAM_STAT_CHECK_CONDITION &&\r\nmemcmp(srb->sense_buffer, usb_stor_sense_invalidCDB,\r\nsizeof(usb_stor_sense_invalidCDB)) == 0) {\r\nusb_stor_dbg(us, "cypress atacb not supported ???\n");\r\ngoto end;\r\n}\r\nif ((srb->result != (DID_ERROR << 16) &&\r\nsrb->result != (DID_ABORT << 16)) &&\r\nsave_cmnd[2] & 0x20) {\r\nstruct scsi_eh_save ses;\r\nunsigned char regs[8];\r\nunsigned char *sb = srb->sense_buffer;\r\nunsigned char *desc = sb + 8;\r\nint tmp_result;\r\nscsi_eh_prep_cmnd(srb, &ses, NULL, 0, sizeof(regs));\r\nsrb->cmd_len = 16;\r\nsrb->cmnd = ses.cmnd;\r\nsrb->cmnd[2] = 1;\r\nusb_stor_transparent_scsi_command(srb, us);\r\nmemcpy(regs, srb->sense_buffer, sizeof(regs));\r\ntmp_result = srb->result;\r\nscsi_eh_restore_cmnd(srb, &ses);\r\nif (tmp_result != SAM_STAT_GOOD)\r\ngoto invalid_fld;\r\nmemset(sb, 0, SCSI_SENSE_BUFFERSIZE);\r\nsb[1] = RECOVERED_ERROR;\r\nsb[2] = 0;\r\nsb[3] = 0x1D;\r\nsb[0] = 0x72;\r\ndesc[0] = 0x09;\r\nsb[7] = 14;\r\ndesc[1] = 12;\r\ndesc[ 2] = 0x00;\r\ndesc[ 3] = regs[1];\r\ndesc[ 5] = regs[2];\r\ndesc[ 7] = regs[3];\r\ndesc[ 9] = regs[4];\r\ndesc[11] = regs[5];\r\ndesc[12] = regs[6];\r\ndesc[13] = regs[7];\r\nsrb->result = (DRIVER_SENSE << 24) | SAM_STAT_CHECK_CONDITION;\r\n}\r\ngoto end;\r\ninvalid_fld:\r\nsrb->result = (DRIVER_SENSE << 24) | SAM_STAT_CHECK_CONDITION;\r\nmemcpy(srb->sense_buffer,\r\nusb_stor_sense_invalidCDB,\r\nsizeof(usb_stor_sense_invalidCDB));\r\nend:\r\nmemcpy(srb->cmnd, save_cmnd, sizeof(save_cmnd));\r\nif (srb->cmnd[0] == ATA_12)\r\nsrb->cmd_len = 12;\r\n}\r\nstatic int cypress_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct us_data *us;\r\nint result;\r\nstruct usb_device *device;\r\nresult = usb_stor_probe1(&us, intf, id,\r\n(id - cypress_usb_ids) + cypress_unusual_dev_list,\r\n&cypress_host_template);\r\nif (result)\r\nreturn result;\r\ndevice = interface_to_usbdev(intf);\r\nif (device->descriptor.iManufacturer != 0x38 ||\r\ndevice->descriptor.iProduct != 0x4e ||\r\ndevice->descriptor.iSerialNumber != 0x64) {\r\nus->protocol_name = "Transparent SCSI with Cypress ATACB";\r\nus->proto_handler = cypress_atacb_passthrough;\r\n} else {\r\nus->protocol_name = "Transparent SCSI";\r\nus->proto_handler = usb_stor_transparent_scsi_command;\r\n}\r\nresult = usb_stor_probe2(us);\r\nreturn result;\r\n}
