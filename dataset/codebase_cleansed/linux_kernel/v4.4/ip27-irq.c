static int ms1bit(unsigned long x)\r\n{\r\nint b = 0, s;\r\ns = 16; if (x >> 16 == 0) s = 0; b += s; x >>= s;\r\ns = 8; if (x >> 8 == 0) s = 0; b += s; x >>= s;\r\ns = 4; if (x >> 4 == 0) s = 0; b += s; x >>= s;\r\ns = 2; if (x >> 2 == 0) s = 0; b += s; x >>= s;\r\ns = 1; if (x >> 1 == 0) s = 0; b += s;\r\nreturn b;\r\n}\r\nstatic void ip27_do_irq_mask0(void)\r\n{\r\nint irq, swlevel;\r\nhubreg_t pend0, mask0;\r\ncpuid_t cpu = smp_processor_id();\r\nint pi_int_mask0 =\r\n(cputoslice(cpu) == 0) ? PI_INT_MASK0_A : PI_INT_MASK0_B;\r\npend0 = LOCAL_HUB_L(PI_INT_PEND0);\r\nmask0 = LOCAL_HUB_L(pi_int_mask0);\r\npend0 &= mask0;\r\nif (!pend0)\r\nreturn;\r\nswlevel = ms1bit(pend0);\r\n#ifdef CONFIG_SMP\r\nif (pend0 & (1UL << CPU_RESCHED_A_IRQ)) {\r\nLOCAL_HUB_CLR_INTR(CPU_RESCHED_A_IRQ);\r\nscheduler_ipi();\r\n} else if (pend0 & (1UL << CPU_RESCHED_B_IRQ)) {\r\nLOCAL_HUB_CLR_INTR(CPU_RESCHED_B_IRQ);\r\nscheduler_ipi();\r\n} else if (pend0 & (1UL << CPU_CALL_A_IRQ)) {\r\nLOCAL_HUB_CLR_INTR(CPU_CALL_A_IRQ);\r\nirq_enter();\r\ngeneric_smp_call_function_interrupt();\r\nirq_exit();\r\n} else if (pend0 & (1UL << CPU_CALL_B_IRQ)) {\r\nLOCAL_HUB_CLR_INTR(CPU_CALL_B_IRQ);\r\nirq_enter();\r\ngeneric_smp_call_function_interrupt();\r\nirq_exit();\r\n} else\r\n#endif\r\n{\r\nstruct slice_data *si = cpu_data[cpu].data;\r\nirq = si->level_to_irq[swlevel];\r\ndo_IRQ(irq);\r\n}\r\nLOCAL_HUB_L(PI_INT_PEND0);\r\n}\r\nstatic void ip27_do_irq_mask1(void)\r\n{\r\nint irq, swlevel;\r\nhubreg_t pend1, mask1;\r\ncpuid_t cpu = smp_processor_id();\r\nint pi_int_mask1 = (cputoslice(cpu) == 0) ? PI_INT_MASK1_A : PI_INT_MASK1_B;\r\nstruct slice_data *si = cpu_data[cpu].data;\r\npend1 = LOCAL_HUB_L(PI_INT_PEND1);\r\nmask1 = LOCAL_HUB_L(pi_int_mask1);\r\npend1 &= mask1;\r\nif (!pend1)\r\nreturn;\r\nswlevel = ms1bit(pend1);\r\nirq = si->level_to_irq[swlevel];\r\nLOCAL_HUB_CLR_INTR(swlevel);\r\ndo_IRQ(irq);\r\nLOCAL_HUB_L(PI_INT_PEND1);\r\n}\r\nstatic void ip27_prof_timer(void)\r\n{\r\npanic("CPU %d got a profiling interrupt", smp_processor_id());\r\n}\r\nstatic void ip27_hub_error(void)\r\n{\r\npanic("CPU %d got a hub error interrupt", smp_processor_id());\r\n}\r\nasmlinkage void plat_irq_dispatch(void)\r\n{\r\nunsigned long pending = read_c0_cause() & read_c0_status();\r\nextern unsigned int rt_timer_irq;\r\nif (pending & CAUSEF_IP4)\r\ndo_IRQ(rt_timer_irq);\r\nelse if (pending & CAUSEF_IP2)\r\nip27_do_irq_mask0();\r\nelse if (pending & CAUSEF_IP3)\r\nip27_do_irq_mask1();\r\nelse if (pending & CAUSEF_IP5)\r\nip27_prof_timer();\r\nelse if (pending & CAUSEF_IP6)\r\nip27_hub_error();\r\n}\r\nvoid __init arch_init_irq(void)\r\n{\r\n}\r\nvoid install_ipi(void)\r\n{\r\nint slice = LOCAL_HUB_L(PI_CPU_NUM);\r\nint cpu = smp_processor_id();\r\nstruct slice_data *si = cpu_data[cpu].data;\r\nstruct hub_data *hub = hub_data(cpu_to_node(cpu));\r\nint resched, call;\r\nresched = CPU_RESCHED_A_IRQ + slice;\r\n__set_bit(resched, hub->irq_alloc_mask);\r\n__set_bit(resched, si->irq_enable_mask);\r\nLOCAL_HUB_CLR_INTR(resched);\r\ncall = CPU_CALL_A_IRQ + slice;\r\n__set_bit(call, hub->irq_alloc_mask);\r\n__set_bit(call, si->irq_enable_mask);\r\nLOCAL_HUB_CLR_INTR(call);\r\nif (slice == 0) {\r\nLOCAL_HUB_S(PI_INT_MASK0_A, si->irq_enable_mask[0]);\r\nLOCAL_HUB_S(PI_INT_MASK1_A, si->irq_enable_mask[1]);\r\n} else {\r\nLOCAL_HUB_S(PI_INT_MASK0_B, si->irq_enable_mask[0]);\r\nLOCAL_HUB_S(PI_INT_MASK1_B, si->irq_enable_mask[1]);\r\n}\r\n}
