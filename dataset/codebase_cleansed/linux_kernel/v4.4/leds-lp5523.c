static inline void lp5523_wait_opmode_done(void)\r\n{\r\nusleep_range(1000, 2000);\r\n}\r\nstatic void lp5523_set_led_current(struct lp55xx_led *led, u8 led_current)\r\n{\r\nled->led_current = led_current;\r\nlp55xx_write(led->chip, LP5523_REG_LED_CURRENT_BASE + led->chan_nr,\r\nled_current);\r\n}\r\nstatic int lp5523_post_init_device(struct lp55xx_chip *chip)\r\n{\r\nint ret;\r\nret = lp55xx_write(chip, LP5523_REG_ENABLE, LP5523_ENABLE);\r\nif (ret)\r\nreturn ret;\r\nusleep_range(1000, 2000);\r\nret = lp55xx_write(chip, LP5523_REG_CONFIG,\r\nLP5523_AUTO_INC | LP5523_PWR_SAVE |\r\nLP5523_CP_AUTO | LP5523_AUTO_CLK |\r\nLP5523_PWM_PWR_SAVE);\r\nif (ret)\r\nreturn ret;\r\nret = lp55xx_write(chip, LP5523_REG_ENABLE_LEDS_MSB, 0x01);\r\nif (ret)\r\nreturn ret;\r\nret = lp55xx_write(chip, LP5523_REG_ENABLE_LEDS_LSB, 0xff);\r\nif (ret)\r\nreturn ret;\r\nreturn lp5523_init_program_engine(chip);\r\n}\r\nstatic void lp5523_load_engine(struct lp55xx_chip *chip)\r\n{\r\nenum lp55xx_engine_index idx = chip->engine_idx;\r\nu8 mask[] = {\r\n[LP55XX_ENGINE_1] = LP5523_MODE_ENG1_M,\r\n[LP55XX_ENGINE_2] = LP5523_MODE_ENG2_M,\r\n[LP55XX_ENGINE_3] = LP5523_MODE_ENG3_M,\r\n};\r\nu8 val[] = {\r\n[LP55XX_ENGINE_1] = LP5523_LOAD_ENG1,\r\n[LP55XX_ENGINE_2] = LP5523_LOAD_ENG2,\r\n[LP55XX_ENGINE_3] = LP5523_LOAD_ENG3,\r\n};\r\nlp55xx_update_bits(chip, LP5523_REG_OP_MODE, mask[idx], val[idx]);\r\nlp5523_wait_opmode_done();\r\n}\r\nstatic void lp5523_load_engine_and_select_page(struct lp55xx_chip *chip)\r\n{\r\nenum lp55xx_engine_index idx = chip->engine_idx;\r\nu8 page_sel[] = {\r\n[LP55XX_ENGINE_1] = LP5523_PAGE_ENG1,\r\n[LP55XX_ENGINE_2] = LP5523_PAGE_ENG2,\r\n[LP55XX_ENGINE_3] = LP5523_PAGE_ENG3,\r\n};\r\nlp5523_load_engine(chip);\r\nlp55xx_write(chip, LP5523_REG_PROG_PAGE_SEL, page_sel[idx]);\r\n}\r\nstatic void lp5523_stop_all_engines(struct lp55xx_chip *chip)\r\n{\r\nlp55xx_write(chip, LP5523_REG_OP_MODE, 0);\r\nlp5523_wait_opmode_done();\r\n}\r\nstatic void lp5523_stop_engine(struct lp55xx_chip *chip)\r\n{\r\nenum lp55xx_engine_index idx = chip->engine_idx;\r\nu8 mask[] = {\r\n[LP55XX_ENGINE_1] = LP5523_MODE_ENG1_M,\r\n[LP55XX_ENGINE_2] = LP5523_MODE_ENG2_M,\r\n[LP55XX_ENGINE_3] = LP5523_MODE_ENG3_M,\r\n};\r\nlp55xx_update_bits(chip, LP5523_REG_OP_MODE, mask[idx], 0);\r\nlp5523_wait_opmode_done();\r\n}\r\nstatic void lp5523_turn_off_channels(struct lp55xx_chip *chip)\r\n{\r\nint i;\r\nfor (i = 0; i < LP5523_MAX_LEDS; i++)\r\nlp55xx_write(chip, LP5523_REG_LED_PWM_BASE + i, 0);\r\n}\r\nstatic void lp5523_run_engine(struct lp55xx_chip *chip, bool start)\r\n{\r\nint ret;\r\nu8 mode;\r\nu8 exec;\r\nif (!start) {\r\nlp5523_stop_engine(chip);\r\nlp5523_turn_off_channels(chip);\r\nreturn;\r\n}\r\nret = lp55xx_read(chip, LP5523_REG_OP_MODE, &mode);\r\nif (ret)\r\nreturn;\r\nret = lp55xx_read(chip, LP5523_REG_ENABLE, &exec);\r\nif (ret)\r\nreturn;\r\nif (LP5523_ENG1_IS_LOADING(mode)) {\r\nmode = (mode & ~LP5523_MODE_ENG1_M) | LP5523_RUN_ENG1;\r\nexec = (exec & ~LP5523_EXEC_ENG1_M) | LP5523_RUN_ENG1;\r\n}\r\nif (LP5523_ENG2_IS_LOADING(mode)) {\r\nmode = (mode & ~LP5523_MODE_ENG2_M) | LP5523_RUN_ENG2;\r\nexec = (exec & ~LP5523_EXEC_ENG2_M) | LP5523_RUN_ENG2;\r\n}\r\nif (LP5523_ENG3_IS_LOADING(mode)) {\r\nmode = (mode & ~LP5523_MODE_ENG3_M) | LP5523_RUN_ENG3;\r\nexec = (exec & ~LP5523_EXEC_ENG3_M) | LP5523_RUN_ENG3;\r\n}\r\nlp55xx_write(chip, LP5523_REG_OP_MODE, mode);\r\nlp5523_wait_opmode_done();\r\nlp55xx_update_bits(chip, LP5523_REG_ENABLE, LP5523_EXEC_M, exec);\r\n}\r\nstatic int lp5523_init_program_engine(struct lp55xx_chip *chip)\r\n{\r\nint i;\r\nint j;\r\nint ret;\r\nu8 status;\r\nstatic const u8 pattern[][LP5523_PROGRAM_LENGTH] = {\r\n{ 0x9c, 0x30, 0x9c, 0xb0, 0x9d, 0x80, 0xd8, 0x00, 0},\r\n{ 0x9c, 0x40, 0x9c, 0xc0, 0x9d, 0x80, 0xd8, 0x00, 0},\r\n{ 0x9c, 0x50, 0x9c, 0xd0, 0x9d, 0x80, 0xd8, 0x00, 0},\r\n};\r\nret = lp55xx_write(chip, LP5523_REG_CH1_PROG_START, 0x00);\r\nif (ret)\r\nreturn ret;\r\nret = lp55xx_write(chip, LP5523_REG_CH2_PROG_START, 0x10);\r\nif (ret)\r\nreturn ret;\r\nret = lp55xx_write(chip, LP5523_REG_CH3_PROG_START, 0x20);\r\nif (ret)\r\nreturn ret;\r\nfor (i = LP55XX_ENGINE_1; i <= LP55XX_ENGINE_3; i++) {\r\nchip->engine_idx = i;\r\nlp5523_load_engine_and_select_page(chip);\r\nfor (j = 0; j < LP5523_PROGRAM_LENGTH; j++) {\r\nret = lp55xx_write(chip, LP5523_REG_PROG_MEM + j,\r\npattern[i - 1][j]);\r\nif (ret)\r\ngoto out;\r\n}\r\n}\r\nlp5523_run_engine(chip, true);\r\nusleep_range(3000, 6000);\r\nlp55xx_read(chip, LP5523_REG_STATUS, &status);\r\nstatus &= LP5523_ENG_STATUS_MASK;\r\nif (status != LP5523_ENG_STATUS_MASK) {\r\ndev_err(&chip->cl->dev,\r\n"cound not configure LED engine, status = 0x%.2x\n",\r\nstatus);\r\nret = -1;\r\n}\r\nout:\r\nlp5523_stop_all_engines(chip);\r\nreturn ret;\r\n}\r\nstatic int lp5523_update_program_memory(struct lp55xx_chip *chip,\r\nconst u8 *data, size_t size)\r\n{\r\nu8 pattern[LP5523_PROGRAM_LENGTH] = {0};\r\nunsigned cmd;\r\nchar c[3];\r\nint nrchars;\r\nint ret;\r\nint offset = 0;\r\nint i = 0;\r\nwhile ((offset < size - 1) && (i < LP5523_PROGRAM_LENGTH)) {\r\nret = sscanf(data + offset, "%2s%n ", c, &nrchars);\r\nif (ret != 1)\r\ngoto err;\r\nret = sscanf(c, "%2x", &cmd);\r\nif (ret != 1)\r\ngoto err;\r\npattern[i] = (u8)cmd;\r\noffset += nrchars;\r\ni++;\r\n}\r\nif (i % 2)\r\ngoto err;\r\nfor (i = 0; i < LP5523_PROGRAM_LENGTH; i++) {\r\nret = lp55xx_write(chip, LP5523_REG_PROG_MEM + i, pattern[i]);\r\nif (ret)\r\nreturn -EINVAL;\r\n}\r\nreturn size;\r\nerr:\r\ndev_err(&chip->cl->dev, "wrong pattern format\n");\r\nreturn -EINVAL;\r\n}\r\nstatic void lp5523_firmware_loaded(struct lp55xx_chip *chip)\r\n{\r\nconst struct firmware *fw = chip->fw;\r\nif (fw->size > LP5523_PROGRAM_LENGTH) {\r\ndev_err(&chip->cl->dev, "firmware data size overflow: %zu\n",\r\nfw->size);\r\nreturn;\r\n}\r\nlp5523_load_engine_and_select_page(chip);\r\nlp5523_update_program_memory(chip, fw->data, fw->size);\r\n}\r\nstatic ssize_t show_engine_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf, int nr)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct lp55xx_chip *chip = led->chip;\r\nenum lp55xx_engine_mode mode = chip->engines[nr - 1].mode;\r\nswitch (mode) {\r\ncase LP55XX_ENGINE_RUN:\r\nreturn sprintf(buf, "run\n");\r\ncase LP55XX_ENGINE_LOAD:\r\nreturn sprintf(buf, "load\n");\r\ncase LP55XX_ENGINE_DISABLED:\r\ndefault:\r\nreturn sprintf(buf, "disabled\n");\r\n}\r\n}\r\nstatic ssize_t store_engine_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len, int nr)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct lp55xx_chip *chip = led->chip;\r\nstruct lp55xx_engine *engine = &chip->engines[nr - 1];\r\nmutex_lock(&chip->lock);\r\nchip->engine_idx = nr;\r\nif (!strncmp(buf, "run", 3)) {\r\nlp5523_run_engine(chip, true);\r\nengine->mode = LP55XX_ENGINE_RUN;\r\n} else if (!strncmp(buf, "load", 4)) {\r\nlp5523_stop_engine(chip);\r\nlp5523_load_engine(chip);\r\nengine->mode = LP55XX_ENGINE_LOAD;\r\n} else if (!strncmp(buf, "disabled", 8)) {\r\nlp5523_stop_engine(chip);\r\nengine->mode = LP55XX_ENGINE_DISABLED;\r\n}\r\nmutex_unlock(&chip->lock);\r\nreturn len;\r\n}\r\nstatic int lp5523_mux_parse(const char *buf, u16 *mux, size_t len)\r\n{\r\nu16 tmp_mux = 0;\r\nint i;\r\nlen = min_t(int, len, LP5523_MAX_LEDS);\r\nfor (i = 0; i < len; i++) {\r\nswitch (buf[i]) {\r\ncase '1':\r\ntmp_mux |= (1 << i);\r\nbreak;\r\ncase '0':\r\nbreak;\r\ncase '\n':\r\ni = len;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\n*mux = tmp_mux;\r\nreturn 0;\r\n}\r\nstatic void lp5523_mux_to_array(u16 led_mux, char *array)\r\n{\r\nint i, pos = 0;\r\nfor (i = 0; i < LP5523_MAX_LEDS; i++)\r\npos += sprintf(array + pos, "%x", LED_ACTIVE(led_mux, i));\r\narray[pos] = '\0';\r\n}\r\nstatic ssize_t show_engine_leds(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf, int nr)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct lp55xx_chip *chip = led->chip;\r\nchar mux[LP5523_MAX_LEDS + 1];\r\nlp5523_mux_to_array(chip->engines[nr - 1].led_mux, mux);\r\nreturn sprintf(buf, "%s\n", mux);\r\n}\r\nstatic int lp5523_load_mux(struct lp55xx_chip *chip, u16 mux, int nr)\r\n{\r\nstruct lp55xx_engine *engine = &chip->engines[nr - 1];\r\nint ret;\r\nu8 mux_page[] = {\r\n[LP55XX_ENGINE_1] = LP5523_PAGE_MUX1,\r\n[LP55XX_ENGINE_2] = LP5523_PAGE_MUX2,\r\n[LP55XX_ENGINE_3] = LP5523_PAGE_MUX3,\r\n};\r\nlp5523_load_engine(chip);\r\nret = lp55xx_write(chip, LP5523_REG_PROG_PAGE_SEL, mux_page[nr]);\r\nif (ret)\r\nreturn ret;\r\nret = lp55xx_write(chip, LP5523_REG_PROG_MEM , (u8)(mux >> 8));\r\nif (ret)\r\nreturn ret;\r\nret = lp55xx_write(chip, LP5523_REG_PROG_MEM + 1, (u8)(mux));\r\nif (ret)\r\nreturn ret;\r\nengine->led_mux = mux;\r\nreturn 0;\r\n}\r\nstatic ssize_t store_engine_leds(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len, int nr)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct lp55xx_chip *chip = led->chip;\r\nstruct lp55xx_engine *engine = &chip->engines[nr - 1];\r\nu16 mux = 0;\r\nssize_t ret;\r\nif (lp5523_mux_parse(buf, &mux, len))\r\nreturn -EINVAL;\r\nmutex_lock(&chip->lock);\r\nchip->engine_idx = nr;\r\nret = -EINVAL;\r\nif (engine->mode != LP55XX_ENGINE_LOAD)\r\ngoto leave;\r\nif (lp5523_load_mux(chip, mux, nr))\r\ngoto leave;\r\nret = len;\r\nleave:\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t store_engine_load(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len, int nr)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct lp55xx_chip *chip = led->chip;\r\nint ret;\r\nmutex_lock(&chip->lock);\r\nchip->engine_idx = nr;\r\nlp5523_load_engine_and_select_page(chip);\r\nret = lp5523_update_program_memory(chip, buf, len);\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t lp5523_selftest(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct lp55xx_chip *chip = led->chip;\r\nstruct lp55xx_platform_data *pdata = chip->pdata;\r\nint i, ret, pos = 0;\r\nu8 status, adc, vdd;\r\nmutex_lock(&chip->lock);\r\nret = lp55xx_read(chip, LP5523_REG_STATUS, &status);\r\nif (ret < 0)\r\ngoto fail;\r\nif (pdata->clock_mode == LP55XX_CLOCK_EXT) {\r\nif ((status & LP5523_EXT_CLK_USED) == 0)\r\ngoto fail;\r\n}\r\nlp55xx_write(chip, LP5523_REG_LED_TEST_CTRL, LP5523_EN_LEDTEST | 16);\r\nusleep_range(3000, 6000);\r\nret = lp55xx_read(chip, LP5523_REG_STATUS, &status);\r\nif (ret < 0)\r\ngoto fail;\r\nif (!(status & LP5523_LEDTEST_DONE))\r\nusleep_range(3000, 6000);\r\nret = lp55xx_read(chip, LP5523_REG_LED_TEST_ADC, &vdd);\r\nif (ret < 0)\r\ngoto fail;\r\nvdd--;\r\nfor (i = 0; i < LP5523_MAX_LEDS; i++) {\r\nif (pdata->led_config[i].led_current == 0)\r\ncontinue;\r\nlp55xx_write(chip, LP5523_REG_LED_CURRENT_BASE + i,\r\npdata->led_config[i].led_current);\r\nlp55xx_write(chip, LP5523_REG_LED_PWM_BASE + i, 0xff);\r\nusleep_range(2000, 4000);\r\nlp55xx_write(chip, LP5523_REG_LED_TEST_CTRL,\r\nLP5523_EN_LEDTEST | i);\r\nusleep_range(3000, 6000);\r\nret = lp55xx_read(chip, LP5523_REG_STATUS, &status);\r\nif (ret < 0)\r\ngoto fail;\r\nif (!(status & LP5523_LEDTEST_DONE))\r\nusleep_range(3000, 6000);\r\nret = lp55xx_read(chip, LP5523_REG_LED_TEST_ADC, &adc);\r\nif (ret < 0)\r\ngoto fail;\r\nif (adc >= vdd || adc < LP5523_ADC_SHORTCIRC_LIM)\r\npos += sprintf(buf + pos, "LED %d FAIL\n", i);\r\nlp55xx_write(chip, LP5523_REG_LED_PWM_BASE + i, 0x00);\r\nlp55xx_write(chip, LP5523_REG_LED_CURRENT_BASE + i,\r\nled->led_current);\r\nled++;\r\n}\r\nif (pos == 0)\r\npos = sprintf(buf, "OK\n");\r\ngoto release_lock;\r\nfail:\r\npos = sprintf(buf, "FAIL\n");\r\nrelease_lock:\r\nmutex_unlock(&chip->lock);\r\nreturn pos;\r\n}\r\nstatic ssize_t show_master_fader(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf, int nr)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct lp55xx_chip *chip = led->chip;\r\nint ret;\r\nu8 val;\r\nmutex_lock(&chip->lock);\r\nret = lp55xx_read(chip, LP5523_REG_MASTER_FADER_BASE + nr - 1, &val);\r\nmutex_unlock(&chip->lock);\r\nif (ret == 0)\r\nret = sprintf(buf, "%u\n", val);\r\nreturn ret;\r\n}\r\nstatic ssize_t store_master_fader(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len, int nr)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct lp55xx_chip *chip = led->chip;\r\nint ret;\r\nunsigned long val;\r\nif (kstrtoul(buf, 0, &val))\r\nreturn -EINVAL;\r\nif (val > 0xff)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->lock);\r\nret = lp55xx_write(chip, LP5523_REG_MASTER_FADER_BASE + nr - 1,\r\n(u8)val);\r\nmutex_unlock(&chip->lock);\r\nif (ret == 0)\r\nret = len;\r\nreturn ret;\r\n}\r\nstatic ssize_t show_master_fader_leds(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct lp55xx_chip *chip = led->chip;\r\nint i, ret, pos = 0;\r\nu8 val;\r\nmutex_lock(&chip->lock);\r\nfor (i = 0; i < LP5523_MAX_LEDS; i++) {\r\nret = lp55xx_read(chip, LP5523_REG_LED_CTRL_BASE + i, &val);\r\nif (ret)\r\ngoto leave;\r\nval = (val & LP5523_FADER_MAPPING_MASK)\r\n>> LP5523_FADER_MAPPING_SHIFT;\r\nif (val > 3) {\r\nret = -EINVAL;\r\ngoto leave;\r\n}\r\nbuf[pos++] = val + '0';\r\n}\r\nbuf[pos++] = '\n';\r\nret = pos;\r\nleave:\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t store_master_fader_leds(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct lp55xx_chip *chip = led->chip;\r\nint i, n, ret;\r\nu8 val;\r\nn = min_t(int, len, LP5523_MAX_LEDS);\r\nmutex_lock(&chip->lock);\r\nfor (i = 0; i < n; i++) {\r\nif (buf[i] >= '0' && buf[i] <= '3') {\r\nval = (buf[i] - '0') << LP5523_FADER_MAPPING_SHIFT;\r\nret = lp55xx_update_bits(chip,\r\nLP5523_REG_LED_CTRL_BASE + i,\r\nLP5523_FADER_MAPPING_MASK,\r\nval);\r\nif (ret)\r\ngoto leave;\r\n} else {\r\nret = -EINVAL;\r\ngoto leave;\r\n}\r\n}\r\nret = len;\r\nleave:\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic void lp5523_led_brightness_work(struct work_struct *work)\r\n{\r\nstruct lp55xx_led *led = container_of(work, struct lp55xx_led,\r\nbrightness_work);\r\nstruct lp55xx_chip *chip = led->chip;\r\nmutex_lock(&chip->lock);\r\nlp55xx_write(chip, LP5523_REG_LED_PWM_BASE + led->chan_nr,\r\nled->brightness);\r\nmutex_unlock(&chip->lock);\r\n}\r\nstatic int lp5523_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct lp55xx_chip *chip;\r\nstruct lp55xx_led *led;\r\nstruct lp55xx_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct device_node *np = client->dev.of_node;\r\nif (!pdata) {\r\nif (np) {\r\npdata = lp55xx_of_populate_pdata(&client->dev, np);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\n} else {\r\ndev_err(&client->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nled = devm_kzalloc(&client->dev,\r\nsizeof(*led) * pdata->num_channels, GFP_KERNEL);\r\nif (!led)\r\nreturn -ENOMEM;\r\nchip->cl = client;\r\nchip->pdata = pdata;\r\nchip->cfg = &lp5523_cfg;\r\nmutex_init(&chip->lock);\r\ni2c_set_clientdata(client, led);\r\nret = lp55xx_init_device(chip);\r\nif (ret)\r\ngoto err_init;\r\ndev_info(&client->dev, "%s Programmable led chip found\n", id->name);\r\nret = lp55xx_register_leds(led, chip);\r\nif (ret)\r\ngoto err_register_leds;\r\nret = lp55xx_register_sysfs(chip);\r\nif (ret) {\r\ndev_err(&client->dev, "registering sysfs failed\n");\r\ngoto err_register_sysfs;\r\n}\r\nreturn 0;\r\nerr_register_sysfs:\r\nlp55xx_unregister_leds(led, chip);\r\nerr_register_leds:\r\nlp55xx_deinit_device(chip);\r\nerr_init:\r\nreturn ret;\r\n}\r\nstatic int lp5523_remove(struct i2c_client *client)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(client);\r\nstruct lp55xx_chip *chip = led->chip;\r\nlp5523_stop_all_engines(chip);\r\nlp55xx_unregister_sysfs(chip);\r\nlp55xx_unregister_leds(led, chip);\r\nlp55xx_deinit_device(chip);\r\nreturn 0;\r\n}
