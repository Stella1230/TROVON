static inline void\r\n_writefield(u32 offset, void *value)\r\n{\r\nint i;\r\nfor (i = 0; i < 4; i++)\r\niowrite32(((u32 *) value)[i], _iobase + offset + (i * 4));\r\n}\r\nstatic inline void\r\n_readfield(u32 offset, void *value)\r\n{\r\nint i;\r\nfor (i = 0; i < 4; i++)\r\n((u32 *) value)[i] = ioread32(_iobase + offset + (i * 4));\r\n}\r\nstatic int\r\ndo_crypt(void *src, void *dst, int len, u32 flags)\r\n{\r\nu32 status;\r\nu32 counter = AES_OP_TIMEOUT;\r\niowrite32(virt_to_phys(src), _iobase + AES_SOURCEA_REG);\r\niowrite32(virt_to_phys(dst), _iobase + AES_DSTA_REG);\r\niowrite32(len, _iobase + AES_LENA_REG);\r\niowrite32(AES_CTRL_START | flags, _iobase + AES_CTRLA_REG);\r\ndo {\r\nstatus = ioread32(_iobase + AES_INTR_REG);\r\ncpu_relax();\r\n} while (!(status & AES_INTRA_PENDING) && --counter);\r\niowrite32((status & 0xFF) | AES_INTRA_PENDING, _iobase + AES_INTR_REG);\r\nreturn counter ? 0 : 1;\r\n}\r\nstatic unsigned int\r\ngeode_aes_crypt(struct geode_aes_op *op)\r\n{\r\nu32 flags = 0;\r\nunsigned long iflags;\r\nint ret;\r\nif (op->len == 0)\r\nreturn 0;\r\nflags |= (AES_CTRL_DCA | AES_CTRL_SCA);\r\nif (op->dir == AES_DIR_ENCRYPT)\r\nflags |= AES_CTRL_ENCRYPT;\r\nspin_lock_irqsave(&lock, iflags);\r\nif (op->mode == AES_MODE_CBC) {\r\nflags |= AES_CTRL_CBC;\r\n_writefield(AES_WRITEIV0_REG, op->iv);\r\n}\r\nif (!(op->flags & AES_FLAGS_HIDDENKEY)) {\r\nflags |= AES_CTRL_WRKEY;\r\n_writefield(AES_WRITEKEY0_REG, op->key);\r\n}\r\nret = do_crypt(op->src, op->dst, op->len, flags);\r\nBUG_ON(ret);\r\nif (op->mode == AES_MODE_CBC)\r\n_readfield(AES_WRITEIV0_REG, op->iv);\r\nspin_unlock_irqrestore(&lock, iflags);\r\nreturn op->len;\r\n}\r\nstatic int geode_setkey_cip(struct crypto_tfm *tfm, const u8 *key,\r\nunsigned int len)\r\n{\r\nstruct geode_aes_op *op = crypto_tfm_ctx(tfm);\r\nunsigned int ret;\r\nop->keylen = len;\r\nif (len == AES_KEYSIZE_128) {\r\nmemcpy(op->key, key, len);\r\nreturn 0;\r\n}\r\nif (len != AES_KEYSIZE_192 && len != AES_KEYSIZE_256) {\r\ntfm->crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;\r\nreturn -EINVAL;\r\n}\r\nop->fallback.cip->base.crt_flags &= ~CRYPTO_TFM_REQ_MASK;\r\nop->fallback.cip->base.crt_flags |= (tfm->crt_flags & CRYPTO_TFM_REQ_MASK);\r\nret = crypto_cipher_setkey(op->fallback.cip, key, len);\r\nif (ret) {\r\ntfm->crt_flags &= ~CRYPTO_TFM_RES_MASK;\r\ntfm->crt_flags |= (op->fallback.cip->base.crt_flags & CRYPTO_TFM_RES_MASK);\r\n}\r\nreturn ret;\r\n}\r\nstatic int geode_setkey_blk(struct crypto_tfm *tfm, const u8 *key,\r\nunsigned int len)\r\n{\r\nstruct geode_aes_op *op = crypto_tfm_ctx(tfm);\r\nunsigned int ret;\r\nop->keylen = len;\r\nif (len == AES_KEYSIZE_128) {\r\nmemcpy(op->key, key, len);\r\nreturn 0;\r\n}\r\nif (len != AES_KEYSIZE_192 && len != AES_KEYSIZE_256) {\r\ntfm->crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;\r\nreturn -EINVAL;\r\n}\r\nop->fallback.blk->base.crt_flags &= ~CRYPTO_TFM_REQ_MASK;\r\nop->fallback.blk->base.crt_flags |= (tfm->crt_flags & CRYPTO_TFM_REQ_MASK);\r\nret = crypto_blkcipher_setkey(op->fallback.blk, key, len);\r\nif (ret) {\r\ntfm->crt_flags &= ~CRYPTO_TFM_RES_MASK;\r\ntfm->crt_flags |= (op->fallback.blk->base.crt_flags & CRYPTO_TFM_RES_MASK);\r\n}\r\nreturn ret;\r\n}\r\nstatic int fallback_blk_dec(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nunsigned int ret;\r\nstruct crypto_blkcipher *tfm;\r\nstruct geode_aes_op *op = crypto_blkcipher_ctx(desc->tfm);\r\ntfm = desc->tfm;\r\ndesc->tfm = op->fallback.blk;\r\nret = crypto_blkcipher_decrypt_iv(desc, dst, src, nbytes);\r\ndesc->tfm = tfm;\r\nreturn ret;\r\n}\r\nstatic int fallback_blk_enc(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nunsigned int ret;\r\nstruct crypto_blkcipher *tfm;\r\nstruct geode_aes_op *op = crypto_blkcipher_ctx(desc->tfm);\r\ntfm = desc->tfm;\r\ndesc->tfm = op->fallback.blk;\r\nret = crypto_blkcipher_encrypt_iv(desc, dst, src, nbytes);\r\ndesc->tfm = tfm;\r\nreturn ret;\r\n}\r\nstatic void\r\ngeode_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)\r\n{\r\nstruct geode_aes_op *op = crypto_tfm_ctx(tfm);\r\nif (unlikely(op->keylen != AES_KEYSIZE_128)) {\r\ncrypto_cipher_encrypt_one(op->fallback.cip, out, in);\r\nreturn;\r\n}\r\nop->src = (void *) in;\r\nop->dst = (void *) out;\r\nop->mode = AES_MODE_ECB;\r\nop->flags = 0;\r\nop->len = AES_BLOCK_SIZE;\r\nop->dir = AES_DIR_ENCRYPT;\r\ngeode_aes_crypt(op);\r\n}\r\nstatic void\r\ngeode_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)\r\n{\r\nstruct geode_aes_op *op = crypto_tfm_ctx(tfm);\r\nif (unlikely(op->keylen != AES_KEYSIZE_128)) {\r\ncrypto_cipher_decrypt_one(op->fallback.cip, out, in);\r\nreturn;\r\n}\r\nop->src = (void *) in;\r\nop->dst = (void *) out;\r\nop->mode = AES_MODE_ECB;\r\nop->flags = 0;\r\nop->len = AES_BLOCK_SIZE;\r\nop->dir = AES_DIR_DECRYPT;\r\ngeode_aes_crypt(op);\r\n}\r\nstatic int fallback_init_cip(struct crypto_tfm *tfm)\r\n{\r\nconst char *name = crypto_tfm_alg_name(tfm);\r\nstruct geode_aes_op *op = crypto_tfm_ctx(tfm);\r\nop->fallback.cip = crypto_alloc_cipher(name, 0,\r\nCRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK);\r\nif (IS_ERR(op->fallback.cip)) {\r\nprintk(KERN_ERR "Error allocating fallback algo %s\n", name);\r\nreturn PTR_ERR(op->fallback.cip);\r\n}\r\nreturn 0;\r\n}\r\nstatic void fallback_exit_cip(struct crypto_tfm *tfm)\r\n{\r\nstruct geode_aes_op *op = crypto_tfm_ctx(tfm);\r\ncrypto_free_cipher(op->fallback.cip);\r\nop->fallback.cip = NULL;\r\n}\r\nstatic int\r\ngeode_cbc_decrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct geode_aes_op *op = crypto_blkcipher_ctx(desc->tfm);\r\nstruct blkcipher_walk walk;\r\nint err, ret;\r\nif (unlikely(op->keylen != AES_KEYSIZE_128))\r\nreturn fallback_blk_dec(desc, dst, src, nbytes);\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt(desc, &walk);\r\nop->iv = walk.iv;\r\nwhile ((nbytes = walk.nbytes)) {\r\nop->src = walk.src.virt.addr,\r\nop->dst = walk.dst.virt.addr;\r\nop->mode = AES_MODE_CBC;\r\nop->len = nbytes - (nbytes % AES_BLOCK_SIZE);\r\nop->dir = AES_DIR_DECRYPT;\r\nret = geode_aes_crypt(op);\r\nnbytes -= ret;\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\ngeode_cbc_encrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct geode_aes_op *op = crypto_blkcipher_ctx(desc->tfm);\r\nstruct blkcipher_walk walk;\r\nint err, ret;\r\nif (unlikely(op->keylen != AES_KEYSIZE_128))\r\nreturn fallback_blk_enc(desc, dst, src, nbytes);\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt(desc, &walk);\r\nop->iv = walk.iv;\r\nwhile ((nbytes = walk.nbytes)) {\r\nop->src = walk.src.virt.addr,\r\nop->dst = walk.dst.virt.addr;\r\nop->mode = AES_MODE_CBC;\r\nop->len = nbytes - (nbytes % AES_BLOCK_SIZE);\r\nop->dir = AES_DIR_ENCRYPT;\r\nret = geode_aes_crypt(op);\r\nnbytes -= ret;\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nreturn err;\r\n}\r\nstatic int fallback_init_blk(struct crypto_tfm *tfm)\r\n{\r\nconst char *name = crypto_tfm_alg_name(tfm);\r\nstruct geode_aes_op *op = crypto_tfm_ctx(tfm);\r\nop->fallback.blk = crypto_alloc_blkcipher(name, 0,\r\nCRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK);\r\nif (IS_ERR(op->fallback.blk)) {\r\nprintk(KERN_ERR "Error allocating fallback algo %s\n", name);\r\nreturn PTR_ERR(op->fallback.blk);\r\n}\r\nreturn 0;\r\n}\r\nstatic void fallback_exit_blk(struct crypto_tfm *tfm)\r\n{\r\nstruct geode_aes_op *op = crypto_tfm_ctx(tfm);\r\ncrypto_free_blkcipher(op->fallback.blk);\r\nop->fallback.blk = NULL;\r\n}\r\nstatic int\r\ngeode_ecb_decrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct geode_aes_op *op = crypto_blkcipher_ctx(desc->tfm);\r\nstruct blkcipher_walk walk;\r\nint err, ret;\r\nif (unlikely(op->keylen != AES_KEYSIZE_128))\r\nreturn fallback_blk_dec(desc, dst, src, nbytes);\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt(desc, &walk);\r\nwhile ((nbytes = walk.nbytes)) {\r\nop->src = walk.src.virt.addr,\r\nop->dst = walk.dst.virt.addr;\r\nop->mode = AES_MODE_ECB;\r\nop->len = nbytes - (nbytes % AES_BLOCK_SIZE);\r\nop->dir = AES_DIR_DECRYPT;\r\nret = geode_aes_crypt(op);\r\nnbytes -= ret;\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\ngeode_ecb_encrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct geode_aes_op *op = crypto_blkcipher_ctx(desc->tfm);\r\nstruct blkcipher_walk walk;\r\nint err, ret;\r\nif (unlikely(op->keylen != AES_KEYSIZE_128))\r\nreturn fallback_blk_enc(desc, dst, src, nbytes);\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt(desc, &walk);\r\nwhile ((nbytes = walk.nbytes)) {\r\nop->src = walk.src.virt.addr,\r\nop->dst = walk.dst.virt.addr;\r\nop->mode = AES_MODE_ECB;\r\nop->len = nbytes - (nbytes % AES_BLOCK_SIZE);\r\nop->dir = AES_DIR_ENCRYPT;\r\nret = geode_aes_crypt(op);\r\nnbytes -= ret;\r\nret = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nreturn err;\r\n}\r\nstatic void geode_aes_remove(struct pci_dev *dev)\r\n{\r\ncrypto_unregister_alg(&geode_alg);\r\ncrypto_unregister_alg(&geode_ecb_alg);\r\ncrypto_unregister_alg(&geode_cbc_alg);\r\npci_iounmap(dev, _iobase);\r\n_iobase = NULL;\r\npci_release_regions(dev);\r\npci_disable_device(dev);\r\n}\r\nstatic int geode_aes_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nint ret;\r\nret = pci_enable_device(dev);\r\nif (ret)\r\nreturn ret;\r\nret = pci_request_regions(dev, "geode-aes");\r\nif (ret)\r\ngoto eenable;\r\n_iobase = pci_iomap(dev, 0, 0);\r\nif (_iobase == NULL) {\r\nret = -ENOMEM;\r\ngoto erequest;\r\n}\r\nspin_lock_init(&lock);\r\niowrite32(AES_INTR_PENDING | AES_INTR_MASK, _iobase + AES_INTR_REG);\r\nret = crypto_register_alg(&geode_alg);\r\nif (ret)\r\ngoto eiomap;\r\nret = crypto_register_alg(&geode_ecb_alg);\r\nif (ret)\r\ngoto ealg;\r\nret = crypto_register_alg(&geode_cbc_alg);\r\nif (ret)\r\ngoto eecb;\r\ndev_notice(&dev->dev, "GEODE AES engine enabled.\n");\r\nreturn 0;\r\neecb:\r\ncrypto_unregister_alg(&geode_ecb_alg);\r\nealg:\r\ncrypto_unregister_alg(&geode_alg);\r\neiomap:\r\npci_iounmap(dev, _iobase);\r\nerequest:\r\npci_release_regions(dev);\r\neenable:\r\npci_disable_device(dev);\r\ndev_err(&dev->dev, "GEODE AES initialization failed.\n");\r\nreturn ret;\r\n}
