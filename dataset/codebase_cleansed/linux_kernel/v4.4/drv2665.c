static void drv2665_worker(struct work_struct *work)\r\n{\r\nstruct drv2665_data *haptics =\r\ncontainer_of(work, struct drv2665_data, work);\r\nunsigned int read_buf;\r\nint error;\r\nerror = regmap_read(haptics->regmap, DRV2665_STATUS, &read_buf);\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to read status: %d\n", error);\r\nreturn;\r\n}\r\nif (read_buf & DRV2665_FIFO_EMPTY) {\r\nerror = regmap_bulk_write(haptics->regmap,\r\nDRV2665_FIFO,\r\ndrv2665_sine_wave_form,\r\nARRAY_SIZE(drv2665_sine_wave_form));\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to write FIFO: %d\n", error);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic int drv2665_haptics_play(struct input_dev *input, void *data,\r\nstruct ff_effect *effect)\r\n{\r\nstruct drv2665_data *haptics = input_get_drvdata(input);\r\nschedule_work(&haptics->work);\r\nreturn 0;\r\n}\r\nstatic void drv2665_close(struct input_dev *input)\r\n{\r\nstruct drv2665_data *haptics = input_get_drvdata(input);\r\nint error;\r\ncancel_work_sync(&haptics->work);\r\nerror = regmap_update_bits(haptics->regmap,\r\nDRV2665_CTRL_2, DRV2665_STANDBY, 1);\r\nif (error)\r\ndev_err(&haptics->client->dev,\r\n"Failed to enter standby mode: %d\n", error);\r\n}\r\nstatic int drv2665_init(struct drv2665_data *haptics)\r\n{\r\nint error;\r\nerror = regmap_register_patch(haptics->regmap,\r\ndrv2665_init_regs,\r\nARRAY_SIZE(drv2665_init_regs));\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to write init registers: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int drv2665_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct drv2665_data *haptics;\r\nint error;\r\nhaptics = devm_kzalloc(&client->dev, sizeof(*haptics), GFP_KERNEL);\r\nif (!haptics)\r\nreturn -ENOMEM;\r\nhaptics->regulator = devm_regulator_get(&client->dev, "vbat");\r\nif (IS_ERR(haptics->regulator)) {\r\nerror = PTR_ERR(haptics->regulator);\r\ndev_err(&client->dev,\r\n"unable to get regulator, error: %d\n", error);\r\nreturn error;\r\n}\r\nhaptics->input_dev = devm_input_allocate_device(&client->dev);\r\nif (!haptics->input_dev) {\r\ndev_err(&client->dev, "Failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\nhaptics->input_dev->name = "drv2665:haptics";\r\nhaptics->input_dev->dev.parent = client->dev.parent;\r\nhaptics->input_dev->close = drv2665_close;\r\ninput_set_drvdata(haptics->input_dev, haptics);\r\ninput_set_capability(haptics->input_dev, EV_FF, FF_RUMBLE);\r\nerror = input_ff_create_memless(haptics->input_dev, NULL,\r\ndrv2665_haptics_play);\r\nif (error) {\r\ndev_err(&client->dev, "input_ff_create() failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nINIT_WORK(&haptics->work, drv2665_worker);\r\nhaptics->client = client;\r\ni2c_set_clientdata(client, haptics);\r\nhaptics->regmap = devm_regmap_init_i2c(client, &drv2665_regmap_config);\r\nif (IS_ERR(haptics->regmap)) {\r\nerror = PTR_ERR(haptics->regmap);\r\ndev_err(&client->dev, "Failed to allocate register map: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = drv2665_init(haptics);\r\nif (error) {\r\ndev_err(&client->dev, "Device init failed: %d\n", error);\r\nreturn error;\r\n}\r\nerror = input_register_device(haptics->input_dev);\r\nif (error) {\r\ndev_err(&client->dev, "couldn't register input device: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused drv2665_suspend(struct device *dev)\r\n{\r\nstruct drv2665_data *haptics = dev_get_drvdata(dev);\r\nint ret = 0;\r\nmutex_lock(&haptics->input_dev->mutex);\r\nif (haptics->input_dev->users) {\r\nret = regmap_update_bits(haptics->regmap, DRV2665_CTRL_2,\r\nDRV2665_STANDBY, 1);\r\nif (ret) {\r\ndev_err(dev, "Failed to set standby mode\n");\r\nregulator_disable(haptics->regulator);\r\ngoto out;\r\n}\r\nret = regulator_disable(haptics->regulator);\r\nif (ret) {\r\ndev_err(dev, "Failed to disable regulator\n");\r\nregmap_update_bits(haptics->regmap,\r\nDRV2665_CTRL_2,\r\nDRV2665_STANDBY, 0);\r\n}\r\n}\r\nout:\r\nmutex_unlock(&haptics->input_dev->mutex);\r\nreturn ret;\r\n}\r\nstatic int __maybe_unused drv2665_resume(struct device *dev)\r\n{\r\nstruct drv2665_data *haptics = dev_get_drvdata(dev);\r\nint ret = 0;\r\nmutex_lock(&haptics->input_dev->mutex);\r\nif (haptics->input_dev->users) {\r\nret = regulator_enable(haptics->regulator);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable regulator\n");\r\ngoto out;\r\n}\r\nret = regmap_update_bits(haptics->regmap, DRV2665_CTRL_2,\r\nDRV2665_STANDBY, 0);\r\nif (ret) {\r\ndev_err(dev, "Failed to unset standby mode\n");\r\nregulator_disable(haptics->regulator);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&haptics->input_dev->mutex);\r\nreturn ret;\r\n}
