static int sib(int mod, unsigned long *fpu_eip)\r\n{\r\nu_char ss, index, base;\r\nlong offset;\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_code_access_ok(1);\r\nFPU_get_user(base, (u_char __user *) (*fpu_eip));\r\nRE_ENTRANT_CHECK_ON;\r\n(*fpu_eip)++;\r\nss = base >> 6;\r\nindex = (base >> 3) & 7;\r\nbase &= 7;\r\nif ((mod == 0) && (base == 5))\r\noffset = 0;\r\nelse\r\noffset = REG_(base);\r\nif (index == 4) {\r\nif (ss)\r\nEXCEPTION(EX_Invalid);\r\n} else {\r\noffset += (REG_(index)) << ss;\r\n}\r\nif (mod == 1) {\r\nlong displacement;\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_code_access_ok(1);\r\nFPU_get_user(displacement, (signed char __user *)(*fpu_eip));\r\noffset += displacement;\r\nRE_ENTRANT_CHECK_ON;\r\n(*fpu_eip)++;\r\n} else if (mod == 2 || base == 5) {\r\nlong displacement;\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_code_access_ok(4);\r\nFPU_get_user(displacement, (long __user *)(*fpu_eip));\r\noffset += displacement;\r\nRE_ENTRANT_CHECK_ON;\r\n(*fpu_eip) += 4;\r\n}\r\nreturn offset;\r\n}\r\nstatic unsigned long vm86_segment(u_char segment, struct address *addr)\r\n{\r\nsegment--;\r\n#ifdef PARANOID\r\nif (segment > PREFIX_SS_) {\r\nEXCEPTION(EX_INTERNAL | 0x130);\r\nmath_abort(FPU_info, SIGSEGV);\r\n}\r\n#endif\r\naddr->selector = VM86_REG_(segment);\r\nreturn (unsigned long)VM86_REG_(segment) << 4;\r\n}\r\nstatic long pm_address(u_char FPU_modrm, u_char segment,\r\nstruct address *addr, long offset)\r\n{\r\nstruct desc_struct descriptor;\r\nunsigned long base_address, limit, address, seg_top;\r\nsegment--;\r\n#ifdef PARANOID\r\nif (segment > PREFIX_SS_) {\r\nEXCEPTION(EX_INTERNAL | 0x132);\r\nmath_abort(FPU_info, SIGSEGV);\r\n}\r\n#endif\r\nswitch (segment) {\r\ncase PREFIX_GS_ - 1:\r\naddr->selector = get_user_gs(FPU_info->regs);\r\nbreak;\r\ndefault:\r\naddr->selector = PM_REG_(segment);\r\n}\r\ndescriptor = FPU_get_ldt_descriptor(addr->selector);\r\nbase_address = SEG_BASE_ADDR(descriptor);\r\naddress = base_address + offset;\r\nlimit = base_address\r\n+ (SEG_LIMIT(descriptor) + 1) * SEG_GRANULARITY(descriptor) - 1;\r\nif (limit < base_address)\r\nlimit = 0xffffffff;\r\nif (SEG_EXPAND_DOWN(descriptor)) {\r\nif (SEG_G_BIT(descriptor))\r\nseg_top = 0xffffffff;\r\nelse {\r\nseg_top = base_address + (1 << 20);\r\nif (seg_top < base_address)\r\nseg_top = 0xffffffff;\r\n}\r\naccess_limit =\r\n(address <= limit) || (address >= seg_top) ? 0 :\r\n((seg_top - address) >= 255 ? 255 : seg_top - address);\r\n} else {\r\naccess_limit =\r\n(address > limit) || (address < base_address) ? 0 :\r\n((limit - address) >= 254 ? 255 : limit - address + 1);\r\n}\r\nif (SEG_EXECUTE_ONLY(descriptor) ||\r\n(!SEG_WRITE_PERM(descriptor) && (FPU_modrm & FPU_WRITE_BIT))) {\r\naccess_limit = 0;\r\n}\r\nreturn address;\r\n}\r\nvoid __user *FPU_get_address(u_char FPU_modrm, unsigned long *fpu_eip,\r\nstruct address *addr, fpu_addr_modes addr_modes)\r\n{\r\nu_char mod;\r\nunsigned rm = FPU_modrm & 7;\r\nlong *cpu_reg_ptr;\r\nint address = 0;\r\nif (!addr_modes.default_mode && (FPU_modrm & FPU_WRITE_BIT)\r\n&& (addr_modes.override.segment == PREFIX_CS_)) {\r\nmath_abort(FPU_info, SIGSEGV);\r\n}\r\naddr->selector = FPU_DS;\r\nmod = (FPU_modrm >> 6) & 3;\r\nif (rm == 4 && mod != 3) {\r\naddress = sib(mod, fpu_eip);\r\n} else {\r\ncpu_reg_ptr = &REG_(rm);\r\nswitch (mod) {\r\ncase 0:\r\nif (rm == 5) {\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_code_access_ok(4);\r\nFPU_get_user(address,\r\n(unsigned long __user\r\n*)(*fpu_eip));\r\n(*fpu_eip) += 4;\r\nRE_ENTRANT_CHECK_ON;\r\naddr->offset = address;\r\nreturn (void __user *)address;\r\n} else {\r\naddress = *cpu_reg_ptr;\r\naddr->offset = address;\r\nreturn (void __user *)address;\r\n}\r\ncase 1:\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_code_access_ok(1);\r\nFPU_get_user(address, (signed char __user *)(*fpu_eip));\r\nRE_ENTRANT_CHECK_ON;\r\n(*fpu_eip)++;\r\nbreak;\r\ncase 2:\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_code_access_ok(4);\r\nFPU_get_user(address, (long __user *)(*fpu_eip));\r\n(*fpu_eip) += 4;\r\nRE_ENTRANT_CHECK_ON;\r\nbreak;\r\ncase 3:\r\nEXCEPTION(EX_Invalid);\r\n}\r\naddress += *cpu_reg_ptr;\r\n}\r\naddr->offset = address;\r\nswitch (addr_modes.default_mode) {\r\ncase 0:\r\nbreak;\r\ncase VM86:\r\naddress += vm86_segment(addr_modes.override.segment, addr);\r\nbreak;\r\ncase PM16:\r\ncase SEG32:\r\naddress = pm_address(FPU_modrm, addr_modes.override.segment,\r\naddr, address);\r\nbreak;\r\ndefault:\r\nEXCEPTION(EX_INTERNAL | 0x133);\r\n}\r\nreturn (void __user *)address;\r\n}\r\nvoid __user *FPU_get_address_16(u_char FPU_modrm, unsigned long *fpu_eip,\r\nstruct address *addr, fpu_addr_modes addr_modes)\r\n{\r\nu_char mod;\r\nunsigned rm = FPU_modrm & 7;\r\nint address = 0;\r\nif (!addr_modes.default_mode && (FPU_modrm & FPU_WRITE_BIT)\r\n&& (addr_modes.override.segment == PREFIX_CS_)) {\r\nmath_abort(FPU_info, SIGSEGV);\r\n}\r\naddr->selector = FPU_DS;\r\nmod = (FPU_modrm >> 6) & 3;\r\nswitch (mod) {\r\ncase 0:\r\nif (rm == 6) {\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_code_access_ok(2);\r\nFPU_get_user(address,\r\n(unsigned short __user *)(*fpu_eip));\r\n(*fpu_eip) += 2;\r\nRE_ENTRANT_CHECK_ON;\r\ngoto add_segment;\r\n}\r\nbreak;\r\ncase 1:\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_code_access_ok(1);\r\nFPU_get_user(address, (signed char __user *)(*fpu_eip));\r\nRE_ENTRANT_CHECK_ON;\r\n(*fpu_eip)++;\r\nbreak;\r\ncase 2:\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_code_access_ok(2);\r\nFPU_get_user(address, (unsigned short __user *)(*fpu_eip));\r\n(*fpu_eip) += 2;\r\nRE_ENTRANT_CHECK_ON;\r\nbreak;\r\ncase 3:\r\nEXCEPTION(EX_Invalid);\r\nbreak;\r\n}\r\nswitch (rm) {\r\ncase 0:\r\naddress += FPU_info->regs->bx + FPU_info->regs->si;\r\nbreak;\r\ncase 1:\r\naddress += FPU_info->regs->bx + FPU_info->regs->di;\r\nbreak;\r\ncase 2:\r\naddress += FPU_info->regs->bp + FPU_info->regs->si;\r\nif (addr_modes.override.segment == PREFIX_DEFAULT)\r\naddr_modes.override.segment = PREFIX_SS_;\r\nbreak;\r\ncase 3:\r\naddress += FPU_info->regs->bp + FPU_info->regs->di;\r\nif (addr_modes.override.segment == PREFIX_DEFAULT)\r\naddr_modes.override.segment = PREFIX_SS_;\r\nbreak;\r\ncase 4:\r\naddress += FPU_info->regs->si;\r\nbreak;\r\ncase 5:\r\naddress += FPU_info->regs->di;\r\nbreak;\r\ncase 6:\r\naddress += FPU_info->regs->bp;\r\nif (addr_modes.override.segment == PREFIX_DEFAULT)\r\naddr_modes.override.segment = PREFIX_SS_;\r\nbreak;\r\ncase 7:\r\naddress += FPU_info->regs->bx;\r\nbreak;\r\n}\r\nadd_segment:\r\naddress &= 0xffff;\r\naddr->offset = address;\r\nswitch (addr_modes.default_mode) {\r\ncase 0:\r\nbreak;\r\ncase VM86:\r\naddress += vm86_segment(addr_modes.override.segment, addr);\r\nbreak;\r\ncase PM16:\r\ncase SEG32:\r\naddress = pm_address(FPU_modrm, addr_modes.override.segment,\r\naddr, address);\r\nbreak;\r\ndefault:\r\nEXCEPTION(EX_INTERNAL | 0x131);\r\n}\r\nreturn (void __user *)address;\r\n}
