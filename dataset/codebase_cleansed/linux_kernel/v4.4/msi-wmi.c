static int msi_wmi_query_block(int instance, int *ret)\r\n{\r\nacpi_status status;\r\nunion acpi_object *obj;\r\nstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstatus = wmi_query_block(MSIWMI_BIOS_GUID, instance, &output);\r\nobj = output.pointer;\r\nif (!obj || obj->type != ACPI_TYPE_INTEGER) {\r\nif (obj) {\r\npr_err("query block returned object "\r\n"type: %d - buffer length:%d\n", obj->type,\r\nobj->type == ACPI_TYPE_BUFFER ?\r\nobj->buffer.length : 0);\r\n}\r\nkfree(obj);\r\nreturn -EINVAL;\r\n}\r\n*ret = obj->integer.value;\r\nkfree(obj);\r\nreturn 0;\r\n}\r\nstatic int msi_wmi_set_block(int instance, int value)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer input = { sizeof(int), &value };\r\npr_debug("Going to set block of instance: %d - value: %d\n",\r\ninstance, value);\r\nstatus = wmi_set_block(MSIWMI_BIOS_GUID, instance, &input);\r\nreturn ACPI_SUCCESS(status) ? 0 : 1;\r\n}\r\nstatic int bl_get(struct backlight_device *bd)\r\n{\r\nint level, err, ret;\r\nerr = msi_wmi_query_block(1, &ret);\r\nif (err) {\r\npr_err("Could not query backlight: %d\n", err);\r\nreturn -EINVAL;\r\n}\r\npr_debug("Get: Query block returned: %d\n", ret);\r\nfor (level = 0; level < ARRAY_SIZE(backlight_map); level++) {\r\nif (backlight_map[level] == ret) {\r\npr_debug("Current backlight level: 0x%X - index: %d\n",\r\nbacklight_map[level], level);\r\nbreak;\r\n}\r\n}\r\nif (level == ARRAY_SIZE(backlight_map)) {\r\npr_err("get: Invalid brightness value: 0x%X\n", ret);\r\nreturn -EINVAL;\r\n}\r\nreturn level;\r\n}\r\nstatic int bl_set_status(struct backlight_device *bd)\r\n{\r\nint bright = bd->props.brightness;\r\nif (bright >= ARRAY_SIZE(backlight_map) || bright < 0)\r\nreturn -EINVAL;\r\nreturn msi_wmi_set_block(0, backlight_map[bright]);\r\n}\r\nstatic void msi_wmi_notify(u32 value, void *context)\r\n{\r\nstruct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstatic struct key_entry *key;\r\nunion acpi_object *obj;\r\nacpi_status status;\r\nstatus = wmi_get_event_data(value, &response);\r\nif (status != AE_OK) {\r\npr_info("bad event status 0x%x\n", status);\r\nreturn;\r\n}\r\nobj = (union acpi_object *)response.pointer;\r\nif (obj && obj->type == ACPI_TYPE_INTEGER) {\r\nint eventcode = obj->integer.value;\r\npr_debug("Eventcode: 0x%x\n", eventcode);\r\nkey = sparse_keymap_entry_from_scancode(msi_wmi_input_dev,\r\neventcode);\r\nif (!key) {\r\npr_info("Unknown key pressed - %x\n", eventcode);\r\ngoto msi_wmi_notify_exit;\r\n}\r\nif (event_wmi->quirk_last_pressed) {\r\nktime_t cur = ktime_get_real();\r\nktime_t diff = ktime_sub(cur, last_pressed);\r\nif (ktime_to_us(diff) < 1000 * 50) {\r\npr_debug("Suppressed key event 0x%X - "\r\n"Last press was %lld us ago\n",\r\nkey->code, ktime_to_us(diff));\r\ngoto msi_wmi_notify_exit;\r\n}\r\nlast_pressed = cur;\r\n}\r\nif (key->type == KE_KEY &&\r\n(backlight ||\r\n(key->code != MSI_KEY_BRIGHTNESSUP &&\r\nkey->code != MSI_KEY_BRIGHTNESSDOWN))) {\r\npr_debug("Send key: 0x%X - Input layer keycode: %d\n",\r\nkey->code, key->keycode);\r\nsparse_keymap_report_entry(msi_wmi_input_dev, key, 1,\r\ntrue);\r\n}\r\n} else\r\npr_info("Unknown event received\n");\r\nmsi_wmi_notify_exit:\r\nkfree(response.pointer);\r\n}\r\nstatic int __init msi_wmi_backlight_setup(void)\r\n{\r\nint err;\r\nstruct backlight_properties props;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = ARRAY_SIZE(backlight_map) - 1;\r\nbacklight = backlight_device_register(DRV_NAME, NULL, NULL,\r\n&msi_backlight_ops,\r\n&props);\r\nif (IS_ERR(backlight))\r\nreturn PTR_ERR(backlight);\r\nerr = bl_get(NULL);\r\nif (err < 0) {\r\nbacklight_device_unregister(backlight);\r\nreturn err;\r\n}\r\nbacklight->props.brightness = err;\r\nreturn 0;\r\n}\r\nstatic int __init msi_wmi_input_setup(void)\r\n{\r\nint err;\r\nmsi_wmi_input_dev = input_allocate_device();\r\nif (!msi_wmi_input_dev)\r\nreturn -ENOMEM;\r\nmsi_wmi_input_dev->name = "MSI WMI hotkeys";\r\nmsi_wmi_input_dev->phys = "wmi/input0";\r\nmsi_wmi_input_dev->id.bustype = BUS_HOST;\r\nerr = sparse_keymap_setup(msi_wmi_input_dev, msi_wmi_keymap, NULL);\r\nif (err)\r\ngoto err_free_dev;\r\nerr = input_register_device(msi_wmi_input_dev);\r\nif (err)\r\ngoto err_free_keymap;\r\nlast_pressed = ktime_set(0, 0);\r\nreturn 0;\r\nerr_free_keymap:\r\nsparse_keymap_free(msi_wmi_input_dev);\r\nerr_free_dev:\r\ninput_free_device(msi_wmi_input_dev);\r\nreturn err;\r\n}\r\nstatic int __init msi_wmi_init(void)\r\n{\r\nint err;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(event_wmis); i++) {\r\nif (!wmi_has_guid(event_wmis[i].guid))\r\ncontinue;\r\nerr = msi_wmi_input_setup();\r\nif (err) {\r\npr_err("Unable to setup input device\n");\r\nreturn err;\r\n}\r\nerr = wmi_install_notify_handler(event_wmis[i].guid,\r\nmsi_wmi_notify, NULL);\r\nif (ACPI_FAILURE(err)) {\r\npr_err("Unable to setup WMI notify handler\n");\r\ngoto err_free_input;\r\n}\r\npr_debug("Event handler installed\n");\r\nevent_wmi = &event_wmis[i];\r\nbreak;\r\n}\r\nif (wmi_has_guid(MSIWMI_BIOS_GUID) &&\r\nacpi_video_get_backlight_type() == acpi_backlight_vendor) {\r\nerr = msi_wmi_backlight_setup();\r\nif (err) {\r\npr_err("Unable to setup backlight device\n");\r\ngoto err_uninstall_handler;\r\n}\r\npr_debug("Backlight device created\n");\r\n}\r\nif (!event_wmi && !backlight) {\r\npr_err("This machine doesn't have neither MSI-hotkeys nor backlight through WMI\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\nerr_uninstall_handler:\r\nif (event_wmi)\r\nwmi_remove_notify_handler(event_wmi->guid);\r\nerr_free_input:\r\nif (event_wmi) {\r\nsparse_keymap_free(msi_wmi_input_dev);\r\ninput_unregister_device(msi_wmi_input_dev);\r\n}\r\nreturn err;\r\n}\r\nstatic void __exit msi_wmi_exit(void)\r\n{\r\nif (event_wmi) {\r\nwmi_remove_notify_handler(event_wmi->guid);\r\nsparse_keymap_free(msi_wmi_input_dev);\r\ninput_unregister_device(msi_wmi_input_dev);\r\n}\r\nbacklight_device_unregister(backlight);\r\n}
