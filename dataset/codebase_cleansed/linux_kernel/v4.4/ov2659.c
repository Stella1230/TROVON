static inline struct ov2659 *to_ov2659(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct ov2659, sd);\r\n}\r\nstatic int ov2659_write(struct i2c_client *client, u16 reg, u8 val)\r\n{\r\nstruct i2c_msg msg;\r\nu8 buf[3];\r\nint ret;\r\nbuf[0] = reg >> 8;\r\nbuf[1] = reg & 0xFF;\r\nbuf[2] = val;\r\nmsg.addr = client->addr;\r\nmsg.flags = client->flags;\r\nmsg.buf = buf;\r\nmsg.len = sizeof(buf);\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nif (ret >= 0)\r\nreturn 0;\r\ndev_dbg(&client->dev,\r\n"ov2659 write reg(0x%x val:0x%x) failed !\n", reg, val);\r\nreturn ret;\r\n}\r\nstatic int ov2659_read(struct i2c_client *client, u16 reg, u8 *val)\r\n{\r\nstruct i2c_msg msg[2];\r\nu8 buf[2];\r\nint ret;\r\nbuf[0] = reg >> 8;\r\nbuf[1] = reg & 0xFF;\r\nmsg[0].addr = client->addr;\r\nmsg[0].flags = client->flags;\r\nmsg[0].buf = buf;\r\nmsg[0].len = sizeof(buf);\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = client->flags | I2C_M_RD;\r\nmsg[1].buf = buf;\r\nmsg[1].len = 1;\r\nret = i2c_transfer(client->adapter, msg, 2);\r\nif (ret >= 0) {\r\n*val = buf[0];\r\nreturn 0;\r\n}\r\ndev_dbg(&client->dev,\r\n"ov2659 read reg(0x%x val:0x%x) failed !\n", reg, *val);\r\nreturn ret;\r\n}\r\nstatic int ov2659_write_array(struct i2c_client *client,\r\nconst struct sensor_register *regs)\r\n{\r\nint i, ret = 0;\r\nfor (i = 0; ret == 0 && regs[i].addr; i++)\r\nret = ov2659_write(client, regs[i].addr, regs[i].value);\r\nreturn ret;\r\n}\r\nstatic void ov2659_pll_calc_params(struct ov2659 *ov2659)\r\n{\r\nconst struct ov2659_platform_data *pdata = ov2659->pdata;\r\nu8 ctrl1_reg = 0, ctrl2_reg = 0, ctrl3_reg = 0;\r\nstruct i2c_client *client = ov2659->client;\r\nunsigned int desired = pdata->link_frequency;\r\nu32 prediv, postdiv, mult;\r\nu32 bestdelta = -1;\r\nu32 delta, actual;\r\nint i, j;\r\nfor (i = 0; ctrl1[i].div != 0; i++) {\r\npostdiv = ctrl1[i].div;\r\nfor (j = 0; ctrl3[j].div != 0; j++) {\r\nprediv = ctrl3[j].div;\r\nfor (mult = 1; mult <= 63; mult++) {\r\nactual = ov2659->xvclk_frequency;\r\nactual *= mult;\r\nactual /= prediv;\r\nactual /= postdiv;\r\ndelta = actual - desired;\r\ndelta = abs(delta);\r\nif ((delta < bestdelta) || (bestdelta == -1)) {\r\nbestdelta = delta;\r\nctrl1_reg = ctrl1[i].reg;\r\nctrl2_reg = mult;\r\nctrl3_reg = ctrl3[j].reg;\r\n}\r\n}\r\n}\r\n}\r\nov2659->pll.ctrl1 = ctrl1_reg;\r\nov2659->pll.ctrl2 = ctrl2_reg;\r\nov2659->pll.ctrl3 = ctrl3_reg;\r\ndev_dbg(&client->dev,\r\n"Actual reg config: ctrl1_reg: %02x ctrl2_reg: %02x ctrl3_reg: %02x\n",\r\nctrl1_reg, ctrl2_reg, ctrl3_reg);\r\n}\r\nstatic int ov2659_set_pixel_clock(struct ov2659 *ov2659)\r\n{\r\nstruct i2c_client *client = ov2659->client;\r\nstruct sensor_register pll_regs[] = {\r\n{REG_SC_PLL_CTRL1, ov2659->pll.ctrl1},\r\n{REG_SC_PLL_CTRL2, ov2659->pll.ctrl2},\r\n{REG_SC_PLL_CTRL3, ov2659->pll.ctrl3},\r\n{REG_NULL, 0x00},\r\n};\r\ndev_dbg(&client->dev, "%s\n", __func__);\r\nreturn ov2659_write_array(client, pll_regs);\r\n}\r\nstatic void ov2659_get_default_format(struct v4l2_mbus_framefmt *format)\r\n{\r\nformat->width = ov2659_framesizes[2].width;\r\nformat->height = ov2659_framesizes[2].height;\r\nformat->colorspace = V4L2_COLORSPACE_SRGB;\r\nformat->code = ov2659_formats[0].code;\r\nformat->field = V4L2_FIELD_NONE;\r\n}\r\nstatic void ov2659_set_streaming(struct ov2659 *ov2659, int on)\r\n{\r\nstruct i2c_client *client = ov2659->client;\r\nint ret;\r\non = !!on;\r\ndev_dbg(&client->dev, "%s: on: %d\n", __func__, on);\r\nret = ov2659_write(client, REG_SOFTWARE_STANDBY, on);\r\nif (ret)\r\ndev_err(&client->dev, "ov2659 soft standby failed\n");\r\n}\r\nstatic int ov2659_init(struct v4l2_subdev *sd, u32 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn ov2659_write_array(client, ov2659_init_regs);\r\n}\r\nstatic int ov2659_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\ndev_dbg(&client->dev, "%s:\n", __func__);\r\nif (code->index >= ARRAY_SIZE(ov2659_formats))\r\nreturn -EINVAL;\r\ncode->code = ov2659_formats[code->index].code;\r\nreturn 0;\r\n}\r\nstatic int ov2659_enum_frame_sizes(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint i = ARRAY_SIZE(ov2659_formats);\r\ndev_dbg(&client->dev, "%s:\n", __func__);\r\nif (fse->index >= ARRAY_SIZE(ov2659_framesizes))\r\nreturn -EINVAL;\r\nwhile (--i)\r\nif (fse->code == ov2659_formats[i].code)\r\nbreak;\r\nfse->code = ov2659_formats[i].code;\r\nfse->min_width = ov2659_framesizes[fse->index].width;\r\nfse->max_width = fse->min_width;\r\nfse->max_height = ov2659_framesizes[fse->index].height;\r\nfse->min_height = fse->max_height;\r\nreturn 0;\r\n}\r\nstatic int ov2659_get_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov2659 *ov2659 = to_ov2659(sd);\r\ndev_dbg(&client->dev, "ov2659_get_fmt\n");\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\r\nstruct v4l2_mbus_framefmt *mf;\r\nmf = v4l2_subdev_get_try_format(sd, cfg, 0);\r\nmutex_lock(&ov2659->lock);\r\nfmt->format = *mf;\r\nmutex_unlock(&ov2659->lock);\r\nreturn 0;\r\n#else\r\nreturn -ENOTTY;\r\n#endif\r\n}\r\nmutex_lock(&ov2659->lock);\r\nfmt->format = ov2659->format;\r\nmutex_unlock(&ov2659->lock);\r\ndev_dbg(&client->dev, "ov2659_get_fmt: %x %dx%d\n",\r\nov2659->format.code, ov2659->format.width,\r\nov2659->format.height);\r\nreturn 0;\r\n}\r\nstatic void __ov2659_try_frame_size(struct v4l2_mbus_framefmt *mf,\r\nconst struct ov2659_framesize **size)\r\n{\r\nconst struct ov2659_framesize *fsize = &ov2659_framesizes[0];\r\nconst struct ov2659_framesize *match = NULL;\r\nint i = ARRAY_SIZE(ov2659_framesizes);\r\nunsigned int min_err = UINT_MAX;\r\nwhile (i--) {\r\nint err = abs(fsize->width - mf->width)\r\n+ abs(fsize->height - mf->height);\r\nif ((err < min_err) && (fsize->regs[0].addr)) {\r\nmin_err = err;\r\nmatch = fsize;\r\n}\r\nfsize++;\r\n}\r\nif (!match)\r\nmatch = &ov2659_framesizes[2];\r\nmf->width = match->width;\r\nmf->height = match->height;\r\nif (size)\r\n*size = match;\r\n}\r\nstatic int ov2659_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint index = ARRAY_SIZE(ov2659_formats);\r\nstruct v4l2_mbus_framefmt *mf = &fmt->format;\r\nconst struct ov2659_framesize *size = NULL;\r\nstruct ov2659 *ov2659 = to_ov2659(sd);\r\nint ret = 0;\r\ndev_dbg(&client->dev, "ov2659_set_fmt\n");\r\n__ov2659_try_frame_size(mf, &size);\r\nwhile (--index >= 0)\r\nif (ov2659_formats[index].code == mf->code)\r\nbreak;\r\nif (index < 0)\r\nreturn -EINVAL;\r\nmf->colorspace = V4L2_COLORSPACE_SRGB;\r\nmf->code = ov2659_formats[index].code;\r\nmf->field = V4L2_FIELD_NONE;\r\nmutex_lock(&ov2659->lock);\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\r\nmf = v4l2_subdev_get_try_format(sd, cfg, fmt->pad);\r\n*mf = fmt->format;\r\n#else\r\nreturn -ENOTTY;\r\n#endif\r\n} else {\r\ns64 val;\r\nif (ov2659->streaming) {\r\nmutex_unlock(&ov2659->lock);\r\nreturn -EBUSY;\r\n}\r\nov2659->frame_size = size;\r\nov2659->format = fmt->format;\r\nov2659->format_ctrl_regs =\r\nov2659_formats[index].format_ctrl_regs;\r\nif (ov2659->format.code != MEDIA_BUS_FMT_SBGGR8_1X8)\r\nval = ov2659->pdata->link_frequency / 2;\r\nelse\r\nval = ov2659->pdata->link_frequency;\r\nret = v4l2_ctrl_s_ctrl_int64(ov2659->link_frequency, val);\r\nif (ret < 0)\r\ndev_warn(&client->dev,\r\n"failed to set link_frequency rate (%d)\n",\r\nret);\r\n}\r\nmutex_unlock(&ov2659->lock);\r\nreturn ret;\r\n}\r\nstatic int ov2659_set_frame_size(struct ov2659 *ov2659)\r\n{\r\nstruct i2c_client *client = ov2659->client;\r\ndev_dbg(&client->dev, "%s\n", __func__);\r\nreturn ov2659_write_array(ov2659->client, ov2659->frame_size->regs);\r\n}\r\nstatic int ov2659_set_format(struct ov2659 *ov2659)\r\n{\r\nstruct i2c_client *client = ov2659->client;\r\ndev_dbg(&client->dev, "%s\n", __func__);\r\nreturn ov2659_write_array(ov2659->client, ov2659->format_ctrl_regs);\r\n}\r\nstatic int ov2659_s_stream(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov2659 *ov2659 = to_ov2659(sd);\r\nint ret = 0;\r\ndev_dbg(&client->dev, "%s: on: %d\n", __func__, on);\r\nmutex_lock(&ov2659->lock);\r\non = !!on;\r\nif (ov2659->streaming == on)\r\ngoto unlock;\r\nif (!on) {\r\nov2659_set_streaming(ov2659, 0);\r\nov2659->streaming = on;\r\ngoto unlock;\r\n}\r\nov2659_set_pixel_clock(ov2659);\r\nov2659_set_frame_size(ov2659);\r\nov2659_set_format(ov2659);\r\nov2659_set_streaming(ov2659, 1);\r\nov2659->streaming = on;\r\nunlock:\r\nmutex_unlock(&ov2659->lock);\r\nreturn ret;\r\n}\r\nstatic int ov2659_set_test_pattern(struct ov2659 *ov2659, int value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&ov2659->sd);\r\nint ret;\r\nu8 val;\r\nret = ov2659_read(client, REG_PRE_ISP_CTRL00, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (value) {\r\ncase 0:\r\nval &= ~TEST_PATTERN_ENABLE;\r\nbreak;\r\ncase 1:\r\nval &= VERTICAL_COLOR_BAR_MASK;\r\nval |= TEST_PATTERN_ENABLE;\r\nbreak;\r\n}\r\nreturn ov2659_write(client, REG_PRE_ISP_CTRL00, val);\r\n}\r\nstatic int ov2659_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct ov2659 *ov2659 =\r\ncontainer_of(ctrl->handler, struct ov2659, ctrls);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_TEST_PATTERN:\r\nreturn ov2659_set_test_pattern(ov2659, ctrl->val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov2659_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format =\r\nv4l2_subdev_get_try_format(sd, fh->pad, 0);\r\ndev_dbg(&client->dev, "%s:\n", __func__);\r\nov2659_get_default_format(format);\r\nreturn 0;\r\n}\r\nstatic int ov2659_detect(struct v4l2_subdev *sd)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu8 pid, ver;\r\nint ret;\r\ndev_dbg(&client->dev, "%s:\n", __func__);\r\nret = ov2659_write(client, REG_SOFTWARE_RESET, 0x01);\r\nif (ret != 0) {\r\ndev_err(&client->dev, "Sensor soft reset failed\n");\r\nreturn -ENODEV;\r\n}\r\nusleep_range(1000, 2000);\r\nret = ov2659_init(sd, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ov2659_read(client, REG_SC_CHIP_ID_H, &pid);\r\nif (!ret)\r\nret = ov2659_read(client, REG_SC_CHIP_ID_L, &ver);\r\nif (!ret) {\r\nunsigned short id;\r\nid = OV265X_ID(pid, ver);\r\nif (id != OV2659_ID)\r\ndev_err(&client->dev,\r\n"Sensor detection failed (%04X, %d)\n",\r\nid, ret);\r\nelse\r\ndev_info(&client->dev, "Found OV%04X sensor\n", id);\r\n}\r\nreturn ret;\r\n}\r\nstatic struct ov2659_platform_data *\r\nov2659_get_pdata(struct i2c_client *client)\r\n{\r\nstruct ov2659_platform_data *pdata;\r\nstruct v4l2_of_endpoint *bus_cfg;\r\nstruct device_node *endpoint;\r\nif (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)\r\nreturn client->dev.platform_data;\r\nendpoint = of_graph_get_next_endpoint(client->dev.of_node, NULL);\r\nif (!endpoint)\r\nreturn NULL;\r\nbus_cfg = v4l2_of_alloc_parse_endpoint(endpoint);\r\nif (IS_ERR(bus_cfg)) {\r\npdata = NULL;\r\ngoto done;\r\n}\r\npdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\ngoto done;\r\nif (!bus_cfg->nr_of_link_frequencies) {\r\ndev_err(&client->dev,\r\n"link-frequencies property not found or too many\n");\r\npdata = NULL;\r\ngoto done;\r\n}\r\npdata->link_frequency = bus_cfg->link_frequencies[0];\r\ndone:\r\nv4l2_of_free_endpoint(bus_cfg);\r\nof_node_put(endpoint);\r\nreturn pdata;\r\n}\r\nstatic int ov2659_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct ov2659_platform_data *pdata = ov2659_get_pdata(client);\r\nstruct v4l2_subdev *sd;\r\nstruct ov2659 *ov2659;\r\nstruct clk *clk;\r\nint ret;\r\nif (!pdata) {\r\ndev_err(&client->dev, "platform data not specified\n");\r\nreturn -EINVAL;\r\n}\r\nov2659 = devm_kzalloc(&client->dev, sizeof(*ov2659), GFP_KERNEL);\r\nif (!ov2659)\r\nreturn -ENOMEM;\r\nov2659->pdata = pdata;\r\nov2659->client = client;\r\nclk = devm_clk_get(&client->dev, "xvclk");\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nov2659->xvclk_frequency = clk_get_rate(clk);\r\nif (ov2659->xvclk_frequency < 6000000 ||\r\nov2659->xvclk_frequency > 27000000)\r\nreturn -EINVAL;\r\nv4l2_ctrl_handler_init(&ov2659->ctrls, 2);\r\nov2659->link_frequency =\r\nv4l2_ctrl_new_std(&ov2659->ctrls, &ov2659_ctrl_ops,\r\nV4L2_CID_PIXEL_RATE,\r\npdata->link_frequency / 2,\r\npdata->link_frequency, 1,\r\npdata->link_frequency);\r\nv4l2_ctrl_new_std_menu_items(&ov2659->ctrls, &ov2659_ctrl_ops,\r\nV4L2_CID_TEST_PATTERN,\r\nARRAY_SIZE(ov2659_test_pattern_menu) - 1,\r\n0, 0, ov2659_test_pattern_menu);\r\nov2659->sd.ctrl_handler = &ov2659->ctrls;\r\nif (ov2659->ctrls.error) {\r\ndev_err(&client->dev, "%s: control initialization error %d\n",\r\n__func__, ov2659->ctrls.error);\r\nreturn ov2659->ctrls.error;\r\n}\r\nsd = &ov2659->sd;\r\nclient->flags |= I2C_CLIENT_SCCB;\r\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\r\nv4l2_i2c_subdev_init(sd, client, &ov2659_subdev_ops);\r\nsd->internal_ops = &ov2659_subdev_internal_ops;\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |\r\nV4L2_SUBDEV_FL_HAS_EVENTS;\r\n#endif\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nov2659->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nsd->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;\r\nret = media_entity_init(&sd->entity, 1, &ov2659->pad, 0);\r\nif (ret < 0) {\r\nv4l2_ctrl_handler_free(&ov2659->ctrls);\r\nreturn ret;\r\n}\r\n#endif\r\nmutex_init(&ov2659->lock);\r\nov2659_get_default_format(&ov2659->format);\r\nov2659->frame_size = &ov2659_framesizes[2];\r\nov2659->format_ctrl_regs = ov2659_formats[0].format_ctrl_regs;\r\nret = ov2659_detect(sd);\r\nif (ret < 0)\r\ngoto error;\r\nov2659_pll_calc_params(ov2659);\r\nret = v4l2_async_register_subdev(&ov2659->sd);\r\nif (ret)\r\ngoto error;\r\ndev_info(&client->dev, "%s sensor driver registered !!\n", sd->name);\r\nreturn 0;\r\nerror:\r\nv4l2_ctrl_handler_free(&ov2659->ctrls);\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nmedia_entity_cleanup(&sd->entity);\r\n#endif\r\nmutex_destroy(&ov2659->lock);\r\nreturn ret;\r\n}\r\nstatic int ov2659_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct ov2659 *ov2659 = to_ov2659(sd);\r\nv4l2_ctrl_handler_free(&ov2659->ctrls);\r\nv4l2_async_unregister_subdev(sd);\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nmedia_entity_cleanup(&sd->entity);\r\n#endif\r\nmutex_destroy(&ov2659->lock);\r\nreturn 0;\r\n}
