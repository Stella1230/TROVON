int em28xx_tuner_callback(void *ptr, int component, int command, int arg)\r\n{\r\nstruct em28xx_i2c_bus *i2c_bus = ptr;\r\nstruct em28xx *dev = i2c_bus->dev;\r\nint rc = 0;\r\nif (dev->tuner_type != TUNER_XC2028 && dev->tuner_type != TUNER_XC5000)\r\nreturn 0;\r\nif (command != XC2028_TUNER_RESET && command != XC5000_TUNER_RESET)\r\nreturn 0;\r\nrc = em28xx_gpio_set(dev, dev->board.tuner_gpio);\r\nreturn rc;\r\n}\r\nstatic inline void em28xx_set_model(struct em28xx *dev)\r\n{\r\ndev->board = em28xx_boards[dev->model];\r\nif (!dev->board.xclk)\r\ndev->board.xclk = EM28XX_XCLK_IR_RC5_MODE |\r\nEM28XX_XCLK_FREQUENCY_12MHZ;\r\nif (!dev->board.i2c_speed)\r\ndev->board.i2c_speed = EM28XX_I2C_CLK_WAIT_ENABLE |\r\nEM28XX_I2C_FREQ_100_KHZ;\r\ndev->def_i2c_bus = dev->board.def_i2c_bus;\r\n}\r\nstatic void em28xx_pre_card_setup(struct em28xx *dev)\r\n{\r\nem28xx_write_reg(dev, EM28XX_R0F_XCLK, dev->board.xclk & 0x7f);\r\nif (!dev->board.is_em2800)\r\nem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, dev->board.i2c_speed);\r\nmsleep(50);\r\nswitch (dev->model) {\r\ncase EM2861_BOARD_PLEXTOR_PX_TV100U:\r\ndev->i2s_speed = 2048000;\r\nbreak;\r\ncase EM2861_BOARD_KWORLD_PVRTV_300U:\r\ncase EM2880_BOARD_KWORLD_DVB_305U:\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0x6d);\r\nmsleep(10);\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0x7d);\r\nmsleep(10);\r\nbreak;\r\ncase EM2870_BOARD_COMPRO_VIDEOMATE:\r\nem28xx_write_reg(dev, EM2880_R04_GPO, 0x00);\r\nmsleep(10);\r\nem28xx_write_reg(dev, EM2880_R04_GPO, 0x01);\r\nmsleep(10);\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xfd);\r\nmdelay(70);\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xfc);\r\nmdelay(70);\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xdc);\r\nmdelay(70);\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xfc);\r\nmdelay(70);\r\nbreak;\r\ncase EM2870_BOARD_TERRATEC_XS_MT2060:\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xfe);\r\nmdelay(70);\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xde);\r\nmdelay(70);\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xfe);\r\nmdelay(70);\r\nbreak;\r\ncase EM2870_BOARD_PINNACLE_PCTV_DVB:\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xfe);\r\nmdelay(70);\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xde);\r\nmdelay(70);\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xfe);\r\nmdelay(70);\r\nbreak;\r\ncase EM2820_BOARD_GADMEI_UTV310:\r\ncase EM2820_BOARD_MSI_VOX_USB_2:\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xfd);\r\nbreak;\r\ncase EM2882_BOARD_KWORLD_ATSC_315U:\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xff);\r\nmsleep(10);\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xfe);\r\nmsleep(10);\r\nem28xx_write_reg(dev, EM2880_R04_GPO, 0x00);\r\nmsleep(10);\r\nem28xx_write_reg(dev, EM2880_R04_GPO, 0x08);\r\nmsleep(10);\r\nbreak;\r\ncase EM2860_BOARD_KAIOMY_TVNPC_U2:\r\nem28xx_write_regs(dev, EM28XX_R0F_XCLK, "\x07", 1);\r\nem28xx_write_regs(dev, EM28XX_R06_I2C_CLK, "\x40", 1);\r\nem28xx_write_regs(dev, 0x0d, "\x42", 1);\r\nem28xx_write_regs(dev, 0x08, "\xfd", 1);\r\nmsleep(10);\r\nem28xx_write_regs(dev, 0x08, "\xff", 1);\r\nmsleep(10);\r\nem28xx_write_regs(dev, 0x08, "\x7f", 1);\r\nmsleep(10);\r\nem28xx_write_regs(dev, 0x08, "\x6b", 1);\r\nbreak;\r\ncase EM2860_BOARD_EASYCAP:\r\nem28xx_write_regs(dev, 0x08, "\xf8", 1);\r\nbreak;\r\ncase EM2820_BOARD_IODATA_GVMVP_SZ:\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xff);\r\nmsleep(70);\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xf7);\r\nmsleep(10);\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xfe);\r\nmsleep(70);\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xfd);\r\nmsleep(70);\r\nbreak;\r\n}\r\nem28xx_gpio_set(dev, dev->board.tuner_gpio);\r\nem28xx_set_mode(dev, EM28XX_ANALOG_MODE);\r\nem28xx_set_mode(dev, EM28XX_SUSPEND);\r\n}\r\nstatic int em28xx_hint_board(struct em28xx *dev)\r\n{\r\nint i;\r\nif (dev->board.is_webcam) {\r\nif (dev->em28xx_sensor == EM28XX_MT9V011) {\r\ndev->model = EM2820_BOARD_SILVERCREST_WEBCAM;\r\n} else if (dev->em28xx_sensor == EM28XX_MT9M001 ||\r\ndev->em28xx_sensor == EM28XX_MT9M111) {\r\ndev->model = EM2750_BOARD_UNKNOWN;\r\n}\r\nreturn 0;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(em28xx_eeprom_hash); i++) {\r\nif (dev->hash == em28xx_eeprom_hash[i].hash) {\r\ndev->model = em28xx_eeprom_hash[i].model;\r\ndev->tuner_type = em28xx_eeprom_hash[i].tuner;\r\nem28xx_errdev("Your board has no unique USB ID.\n");\r\nem28xx_errdev("A hint were successfully done, "\r\n"based on eeprom hash.\n");\r\nem28xx_errdev("This method is not 100%% failproof.\n");\r\nem28xx_errdev("If the board were missdetected, "\r\n"please email this log to:\n");\r\nem28xx_errdev("\tV4L Mailing List "\r\n" <linux-media@vger.kernel.org>\n");\r\nem28xx_errdev("Board detected as %s\n",\r\nem28xx_boards[dev->model].name);\r\nreturn 0;\r\n}\r\n}\r\nif (!dev->i2c_hash)\r\nem28xx_do_i2c_scan(dev, dev->def_i2c_bus);\r\nfor (i = 0; i < ARRAY_SIZE(em28xx_i2c_hash); i++) {\r\nif (dev->i2c_hash == em28xx_i2c_hash[i].hash) {\r\ndev->model = em28xx_i2c_hash[i].model;\r\ndev->tuner_type = em28xx_i2c_hash[i].tuner;\r\nem28xx_errdev("Your board has no unique USB ID.\n");\r\nem28xx_errdev("A hint were successfully done, "\r\n"based on i2c devicelist hash.\n");\r\nem28xx_errdev("This method is not 100%% failproof.\n");\r\nem28xx_errdev("If the board were missdetected, "\r\n"please email this log to:\n");\r\nem28xx_errdev("\tV4L Mailing List "\r\n" <linux-media@vger.kernel.org>\n");\r\nem28xx_errdev("Board detected as %s\n",\r\nem28xx_boards[dev->model].name);\r\nreturn 0;\r\n}\r\n}\r\nem28xx_errdev("Your board has no unique USB ID and thus need a "\r\n"hint to be detected.\n");\r\nem28xx_errdev("You may try to use card=<n> insmod option to "\r\n"workaround that.\n");\r\nem28xx_errdev("Please send an email with this log to:\n");\r\nem28xx_errdev("\tV4L Mailing List <linux-media@vger.kernel.org>\n");\r\nem28xx_errdev("Board eeprom hash is 0x%08lx\n", dev->hash);\r\nem28xx_errdev("Board i2c devicelist hash is 0x%08lx\n", dev->i2c_hash);\r\nem28xx_errdev("Here is a list of valid choices for the card=<n>"\r\n" insmod option:\n");\r\nfor (i = 0; i < em28xx_bcount; i++) {\r\nem28xx_errdev(" card=%d -> %s\n",\r\ni, em28xx_boards[i].name);\r\n}\r\nreturn -1;\r\n}\r\nstatic void em28xx_card_setup(struct em28xx *dev)\r\n{\r\nif (dev->board.is_webcam) {\r\nif (em28xx_detect_sensor(dev) < 0)\r\ndev->board.is_webcam = 0;\r\n}\r\nswitch (dev->model) {\r\ncase EM2750_BOARD_UNKNOWN:\r\ncase EM2820_BOARD_UNKNOWN:\r\ncase EM2800_BOARD_UNKNOWN:\r\nif (em28xx_hint_board(dev) < 0)\r\nem28xx_errdev("Board not discovered\n");\r\nelse {\r\nem28xx_set_model(dev);\r\nem28xx_pre_card_setup(dev);\r\n}\r\nbreak;\r\ndefault:\r\nem28xx_set_model(dev);\r\n}\r\nem28xx_info("Identified as %s (card=%d)\n",\r\ndev->board.name, dev->model);\r\ndev->tuner_type = em28xx_boards[dev->model].tuner_type;\r\nswitch (dev->model) {\r\ncase EM2820_BOARD_HAUPPAUGE_WINTV_USB_2:\r\ncase EM2880_BOARD_HAUPPAUGE_WINTV_HVR_900:\r\ncase EM2880_BOARD_HAUPPAUGE_WINTV_HVR_900_R2:\r\ncase EM2883_BOARD_HAUPPAUGE_WINTV_HVR_850:\r\ncase EM2883_BOARD_HAUPPAUGE_WINTV_HVR_950:\r\ncase EM2884_BOARD_HAUPPAUGE_WINTV_HVR_930C:\r\n{\r\nstruct tveeprom tv;\r\nif (dev->eedata == NULL)\r\nbreak;\r\n#if defined(CONFIG_MODULES) && defined(MODULE)\r\nrequest_module("tveeprom");\r\n#endif\r\ndev->i2c_client[dev->def_i2c_bus].addr = 0xa0 >> 1;\r\ntveeprom_hauppauge_analog(&dev->i2c_client[dev->def_i2c_bus], &tv, dev->eedata);\r\ndev->tuner_type = tv.tuner_type;\r\nif (tv.audio_processor == TVEEPROM_AUDPROC_MSP) {\r\ndev->i2s_speed = 2048000;\r\ndev->board.has_msp34xx = 1;\r\n}\r\nbreak;\r\n}\r\ncase EM2882_BOARD_KWORLD_ATSC_315U:\r\nem28xx_write_reg(dev, 0x0d, 0x42);\r\nmsleep(10);\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xfd);\r\nmsleep(10);\r\nbreak;\r\ncase EM2820_BOARD_KWORLD_PVRTV2800RF:\r\nem28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xf9);\r\nbreak;\r\ncase EM2820_BOARD_UNKNOWN:\r\ncase EM2800_BOARD_UNKNOWN:\r\ncase EM2880_BOARD_MSI_DIGIVOX_AD:\r\nif (!em28xx_hint_board(dev))\r\nem28xx_set_model(dev);\r\nem28xx_gpio_set(dev, dev->board.tuner_gpio);\r\nem28xx_set_mode(dev, EM28XX_ANALOG_MODE);\r\nbreak;\r\ncase EM2882_BOARD_KWORLD_VS_DVBT:\r\nif (!em28xx_hint_board(dev))\r\nem28xx_set_model(dev);\r\nem28xx_gpio_set(dev, dev->board.tuner_gpio);\r\nem28xx_set_mode(dev, EM28XX_ANALOG_MODE);\r\nbreak;\r\n}\r\nif (dev->board.valid == EM28XX_BOARD_NOT_VALIDATED) {\r\nem28xx_errdev("\n\n");\r\nem28xx_errdev("The support for this board weren't "\r\n"valid yet.\n");\r\nem28xx_errdev("Please send a report of having this working\n");\r\nem28xx_errdev("not to V4L mailing list (and/or to other "\r\n"addresses)\n\n");\r\n}\r\nkfree(dev->eedata);\r\ndev->eedata = NULL;\r\nif (tuner >= 0)\r\ndev->tuner_type = tuner;\r\n}\r\nvoid em28xx_setup_xc3028(struct em28xx *dev, struct xc2028_ctrl *ctl)\r\n{\r\nmemset(ctl, 0, sizeof(*ctl));\r\nctl->fname = XC2028_DEFAULT_FIRMWARE;\r\nctl->max_len = 64;\r\nctl->mts = em28xx_boards[dev->model].mts_firmware;\r\nswitch (dev->model) {\r\ncase EM2880_BOARD_EMPIRE_DUAL_TV:\r\ncase EM2880_BOARD_HAUPPAUGE_WINTV_HVR_900:\r\ncase EM2882_BOARD_TERRATEC_HYBRID_XS:\r\nctl->demod = XC3028_FE_ZARLINK456;\r\nbreak;\r\ncase EM2880_BOARD_TERRATEC_HYBRID_XS:\r\ncase EM2880_BOARD_TERRATEC_HYBRID_XS_FR:\r\ncase EM2881_BOARD_PINNACLE_HYBRID_PRO:\r\nctl->demod = XC3028_FE_ZARLINK456;\r\nbreak;\r\ncase EM2880_BOARD_HAUPPAUGE_WINTV_HVR_900_R2:\r\ncase EM2882_BOARD_PINNACLE_HYBRID_PRO_330E:\r\nctl->demod = XC3028_FE_DEFAULT;\r\nbreak;\r\ncase EM2880_BOARD_AMD_ATI_TV_WONDER_HD_600:\r\nctl->demod = XC3028_FE_DEFAULT;\r\nctl->fname = XC3028L_DEFAULT_FIRMWARE;\r\nbreak;\r\ncase EM2883_BOARD_HAUPPAUGE_WINTV_HVR_850:\r\ncase EM2883_BOARD_HAUPPAUGE_WINTV_HVR_950:\r\ncase EM2880_BOARD_PINNACLE_PCTV_HD_PRO:\r\nctl->demod = XC3028_FE_DEFAULT;\r\nbreak;\r\ncase EM2883_BOARD_KWORLD_HYBRID_330U:\r\ncase EM2882_BOARD_DIKOM_DK300:\r\ncase EM2882_BOARD_KWORLD_VS_DVBT:\r\nctl->demod = XC3028_FE_CHINA;\r\nctl->fname = XC2028_DEFAULT_FIRMWARE;\r\nbreak;\r\ncase EM2882_BOARD_EVGA_INDTUBE:\r\nctl->demod = XC3028_FE_CHINA;\r\nctl->fname = XC3028L_DEFAULT_FIRMWARE;\r\nbreak;\r\ndefault:\r\nctl->demod = XC3028_FE_OREN538;\r\n}\r\n}\r\nstatic void request_module_async(struct work_struct *work)\r\n{\r\nstruct em28xx *dev = container_of(work,\r\nstruct em28xx, request_module_wk);\r\nif (dev->is_audio_only) {\r\n#if defined(CONFIG_MODULES) && defined(MODULE)\r\nrequest_module("em28xx-alsa");\r\n#endif\r\nreturn;\r\n}\r\nem28xx_init_extension(dev);\r\n#if defined(CONFIG_MODULES) && defined(MODULE)\r\nif (dev->has_video)\r\nrequest_module("em28xx-v4l");\r\nif (dev->usb_audio_type == EM28XX_USB_AUDIO_CLASS)\r\nrequest_module("snd-usb-audio");\r\nelse if (dev->usb_audio_type == EM28XX_USB_AUDIO_VENDOR)\r\nrequest_module("em28xx-alsa");\r\nif (dev->board.has_dvb)\r\nrequest_module("em28xx-dvb");\r\nif (dev->board.buttons ||\r\n((dev->board.ir_codes || dev->board.has_ir_i2c) && !disable_ir))\r\nrequest_module("em28xx-rc");\r\n#endif\r\n}\r\nstatic void request_modules(struct em28xx *dev)\r\n{\r\nINIT_WORK(&dev->request_module_wk, request_module_async);\r\nschedule_work(&dev->request_module_wk);\r\n}\r\nstatic void flush_request_modules(struct em28xx *dev)\r\n{\r\nflush_work(&dev->request_module_wk);\r\n}\r\nstatic void em28xx_release_resources(struct em28xx *dev)\r\n{\r\nmutex_lock(&dev->lock);\r\nif (dev->def_i2c_bus)\r\nem28xx_i2c_unregister(dev, 1);\r\nem28xx_i2c_unregister(dev, 0);\r\nusb_put_dev(dev->udev);\r\nclear_bit(dev->devno, em28xx_devused);\r\nmutex_unlock(&dev->lock);\r\n}\r\nvoid em28xx_free_device(struct kref *ref)\r\n{\r\nstruct em28xx *dev = kref_to_dev(ref);\r\nem28xx_info("Freeing device\n");\r\nif (!dev->disconnected)\r\nem28xx_release_resources(dev);\r\nkfree(dev->alt_max_pkt_size_isoc);\r\nkfree(dev);\r\n}\r\nstatic int em28xx_init_dev(struct em28xx *dev, struct usb_device *udev,\r\nstruct usb_interface *interface,\r\nint minor)\r\n{\r\nint retval;\r\nstatic const char *default_chip_name = "em28xx";\r\nconst char *chip_name = default_chip_name;\r\ndev->udev = udev;\r\nmutex_init(&dev->ctrl_urb_lock);\r\nspin_lock_init(&dev->slock);\r\ndev->em28xx_write_regs = em28xx_write_regs;\r\ndev->em28xx_read_reg = em28xx_read_reg;\r\ndev->em28xx_read_reg_req_len = em28xx_read_reg_req_len;\r\ndev->em28xx_write_regs_req = em28xx_write_regs_req;\r\ndev->em28xx_read_reg_req = em28xx_read_reg_req;\r\ndev->board.is_em2800 = em28xx_boards[dev->model].is_em2800;\r\nem28xx_set_model(dev);\r\ndev->wait_after_write = 5;\r\nretval = em28xx_read_reg(dev, EM28XX_R0A_CHIPID);\r\nif (retval > 0) {\r\ndev->chip_id = retval;\r\nswitch (dev->chip_id) {\r\ncase CHIP_ID_EM2800:\r\nchip_name = "em2800";\r\nbreak;\r\ncase CHIP_ID_EM2710:\r\nchip_name = "em2710";\r\nbreak;\r\ncase CHIP_ID_EM2750:\r\nchip_name = "em2750";\r\nbreak;\r\ncase CHIP_ID_EM2765:\r\nchip_name = "em2765";\r\ndev->wait_after_write = 0;\r\ndev->is_em25xx = 1;\r\ndev->eeprom_addrwidth_16bit = 1;\r\nbreak;\r\ncase CHIP_ID_EM2820:\r\nchip_name = "em2710/2820";\r\nif (le16_to_cpu(dev->udev->descriptor.idVendor)\r\n== 0xeb1a) {\r\n__le16 idProd = dev->udev->descriptor.idProduct;\r\nif (le16_to_cpu(idProd) == 0x2710)\r\nchip_name = "em2710";\r\nelse if (le16_to_cpu(idProd) == 0x2820)\r\nchip_name = "em2820";\r\n}\r\nbreak;\r\ncase CHIP_ID_EM2840:\r\nchip_name = "em2840";\r\nbreak;\r\ncase CHIP_ID_EM2860:\r\nchip_name = "em2860";\r\nbreak;\r\ncase CHIP_ID_EM2870:\r\nchip_name = "em2870";\r\ndev->wait_after_write = 0;\r\nbreak;\r\ncase CHIP_ID_EM2874:\r\nchip_name = "em2874";\r\ndev->wait_after_write = 0;\r\ndev->eeprom_addrwidth_16bit = 1;\r\nbreak;\r\ncase CHIP_ID_EM28174:\r\nchip_name = "em28174";\r\ndev->wait_after_write = 0;\r\ndev->eeprom_addrwidth_16bit = 1;\r\nbreak;\r\ncase CHIP_ID_EM28178:\r\nchip_name = "em28178";\r\ndev->wait_after_write = 0;\r\ndev->eeprom_addrwidth_16bit = 1;\r\nbreak;\r\ncase CHIP_ID_EM2883:\r\nchip_name = "em2882/3";\r\ndev->wait_after_write = 0;\r\nbreak;\r\ncase CHIP_ID_EM2884:\r\nchip_name = "em2884";\r\ndev->wait_after_write = 0;\r\ndev->eeprom_addrwidth_16bit = 1;\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO DRIVER_NAME\r\n": unknown em28xx chip ID (%d)\n", dev->chip_id);\r\n}\r\n}\r\nif (chip_name != default_chip_name)\r\nprintk(KERN_INFO DRIVER_NAME\r\n": chip ID is %s\n", chip_name);\r\nsnprintf(dev->name, sizeof(dev->name), "%s #%d", chip_name, dev->devno);\r\nif (dev->is_audio_only) {\r\nretval = em28xx_audio_setup(dev);\r\nif (retval)\r\nreturn -ENODEV;\r\nem28xx_init_extension(dev);\r\nreturn 0;\r\n}\r\nem28xx_pre_card_setup(dev);\r\nif (!dev->board.is_em2800) {\r\nretval = em28xx_write_reg(dev, EM28XX_R06_I2C_CLK, dev->board.i2c_speed);\r\nif (retval < 0) {\r\nem28xx_errdev("%s: em28xx_write_reg failed!"\r\n" retval [%d]\n",\r\n__func__, retval);\r\nreturn retval;\r\n}\r\n}\r\nrt_mutex_init(&dev->i2c_bus_lock);\r\nif (dev->board.is_em2800)\r\nretval = em28xx_i2c_register(dev, 0, EM28XX_I2C_ALGO_EM2800);\r\nelse\r\nretval = em28xx_i2c_register(dev, 0, EM28XX_I2C_ALGO_EM28XX);\r\nif (retval < 0) {\r\nem28xx_errdev("%s: em28xx_i2c_register bus 0 - error [%d]!\n",\r\n__func__, retval);\r\nreturn retval;\r\n}\r\nif (dev->def_i2c_bus) {\r\nif (dev->is_em25xx)\r\nretval = em28xx_i2c_register(dev, 1,\r\nEM28XX_I2C_ALGO_EM25XX_BUS_B);\r\nelse\r\nretval = em28xx_i2c_register(dev, 1,\r\nEM28XX_I2C_ALGO_EM28XX);\r\nif (retval < 0) {\r\nem28xx_errdev("%s: em28xx_i2c_register bus 1 - error [%d]!\n",\r\n__func__, retval);\r\nem28xx_i2c_unregister(dev, 0);\r\nreturn retval;\r\n}\r\n}\r\nem28xx_card_setup(dev);\r\nreturn 0;\r\n}\r\nstatic int em28xx_usb_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev;\r\nstruct em28xx *dev = NULL;\r\nint retval;\r\nbool has_vendor_audio = false, has_video = false, has_dvb = false;\r\nint i, nr, try_bulk;\r\nconst int ifnum = interface->altsetting[0].desc.bInterfaceNumber;\r\nchar *speed;\r\nudev = usb_get_dev(interface_to_usbdev(interface));\r\ndo {\r\nnr = find_first_zero_bit(em28xx_devused, EM28XX_MAXBOARDS);\r\nif (nr >= EM28XX_MAXBOARDS) {\r\nprintk(DRIVER_NAME ": Supports only %i em28xx boards.\n",\r\nEM28XX_MAXBOARDS);\r\nretval = -ENOMEM;\r\ngoto err_no_slot;\r\n}\r\n} while (test_and_set_bit(nr, em28xx_devused));\r\nif (interface->altsetting[0].desc.bInterfaceClass == USB_CLASS_AUDIO) {\r\nem28xx_err(DRIVER_NAME " audio device (%04x:%04x): "\r\n"interface %i, class %i\n",\r\nle16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct),\r\nifnum,\r\ninterface->altsetting[0].desc.bInterfaceClass);\r\nretval = -ENODEV;\r\ngoto err;\r\n}\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\nem28xx_err(DRIVER_NAME ": out of memory!\n");\r\nretval = -ENOMEM;\r\ngoto err;\r\n}\r\ndev->alt_max_pkt_size_isoc =\r\nkmalloc(sizeof(dev->alt_max_pkt_size_isoc[0]) *\r\ninterface->num_altsetting, GFP_KERNEL);\r\nif (dev->alt_max_pkt_size_isoc == NULL) {\r\nem28xx_errdev("out of memory!\n");\r\nkfree(dev);\r\nretval = -ENOMEM;\r\ngoto err;\r\n}\r\nfor (i = 0; i < interface->num_altsetting; i++) {\r\nint ep;\r\nfor (ep = 0; ep < interface->altsetting[i].desc.bNumEndpoints; ep++) {\r\nconst struct usb_endpoint_descriptor *e;\r\nint sizedescr, size;\r\ne = &interface->altsetting[i].endpoint[ep].desc;\r\nsizedescr = le16_to_cpu(e->wMaxPacketSize);\r\nsize = sizedescr & 0x7ff;\r\nif (udev->speed == USB_SPEED_HIGH)\r\nsize = size * hb_mult(sizedescr);\r\nif (usb_endpoint_dir_in(e)) {\r\nswitch (e->bEndpointAddress) {\r\ncase 0x82:\r\nhas_video = true;\r\nif (usb_endpoint_xfer_isoc(e)) {\r\ndev->analog_ep_isoc =\r\ne->bEndpointAddress;\r\ndev->alt_max_pkt_size_isoc[i] = size;\r\n} else if (usb_endpoint_xfer_bulk(e)) {\r\ndev->analog_ep_bulk =\r\ne->bEndpointAddress;\r\n}\r\nbreak;\r\ncase 0x83:\r\nif (usb_endpoint_xfer_isoc(e)) {\r\nhas_vendor_audio = true;\r\n} else {\r\nprintk(KERN_INFO DRIVER_NAME\r\n": error: skipping audio endpoint 0x83, because it uses bulk transfers !\n");\r\n}\r\nbreak;\r\ncase 0x84:\r\nif (has_video &&\r\n(usb_endpoint_xfer_bulk(e))) {\r\ndev->analog_ep_bulk =\r\ne->bEndpointAddress;\r\n} else {\r\nif (usb_endpoint_xfer_isoc(e)) {\r\nif (size > dev->dvb_max_pkt_size_isoc) {\r\nhas_dvb = true;\r\ndev->dvb_ep_isoc = e->bEndpointAddress;\r\ndev->dvb_max_pkt_size_isoc = size;\r\ndev->dvb_alt_isoc = i;\r\n}\r\n} else {\r\nhas_dvb = true;\r\ndev->dvb_ep_bulk = e->bEndpointAddress;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nif (!(has_vendor_audio || has_video || has_dvb)) {\r\nretval = -ENODEV;\r\ngoto err_free;\r\n}\r\nswitch (udev->speed) {\r\ncase USB_SPEED_LOW:\r\nspeed = "1.5";\r\nbreak;\r\ncase USB_SPEED_UNKNOWN:\r\ncase USB_SPEED_FULL:\r\nspeed = "12";\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\nspeed = "480";\r\nbreak;\r\ndefault:\r\nspeed = "unknown";\r\n}\r\nprintk(KERN_INFO DRIVER_NAME\r\n": New device %s %s @ %s Mbps "\r\n"(%04x:%04x, interface %d, class %d)\n",\r\nudev->manufacturer ? udev->manufacturer : "",\r\nudev->product ? udev->product : "",\r\nspeed,\r\nle16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct),\r\nifnum,\r\ninterface->altsetting->desc.bInterfaceNumber);\r\nif (udev->speed != USB_SPEED_HIGH && disable_usb_speed_check == 0) {\r\nprintk(DRIVER_NAME ": Device initialization failed.\n");\r\nprintk(DRIVER_NAME ": Device must be connected to a high-speed"\r\n" USB 2.0 port.\n");\r\nretval = -ENODEV;\r\ngoto err_free;\r\n}\r\ndev->devno = nr;\r\ndev->model = id->driver_info;\r\ndev->alt = -1;\r\ndev->is_audio_only = has_vendor_audio && !(has_video || has_dvb);\r\ndev->has_video = has_video;\r\ndev->ifnum = ifnum;\r\nif (has_vendor_audio) {\r\nprintk(KERN_INFO DRIVER_NAME ": Audio interface %i found %s\n",\r\nifnum, "(Vendor Class)");\r\ndev->usb_audio_type = EM28XX_USB_AUDIO_VENDOR;\r\n}\r\nfor (i = 0; i < udev->config->desc.bNumInterfaces; i++) {\r\nstruct usb_interface *uif = udev->config->interface[i];\r\nif (uif->altsetting[0].desc.bInterfaceClass == USB_CLASS_AUDIO) {\r\nif (has_vendor_audio)\r\nem28xx_err("em28xx: device seems to have vendor AND usb audio class interfaces !\n"\r\n"\t\tThe vendor interface will be ignored. Please contact the developers <linux-media@vger.kernel.org>\n");\r\ndev->usb_audio_type = EM28XX_USB_AUDIO_CLASS;\r\nbreak;\r\n}\r\n}\r\nif (has_video)\r\nprintk(KERN_INFO DRIVER_NAME\r\n": Video interface %i found:%s%s\n",\r\nifnum,\r\ndev->analog_ep_bulk ? " bulk" : "",\r\ndev->analog_ep_isoc ? " isoc" : "");\r\nif (has_dvb)\r\nprintk(KERN_INFO DRIVER_NAME\r\n": DVB interface %i found:%s%s\n",\r\nifnum,\r\ndev->dvb_ep_bulk ? " bulk" : "",\r\ndev->dvb_ep_isoc ? " isoc" : "");\r\ndev->num_alt = interface->num_altsetting;\r\nif ((unsigned)card[nr] < em28xx_bcount)\r\ndev->model = card[nr];\r\nusb_set_intfdata(interface, dev);\r\nmutex_init(&dev->lock);\r\nretval = em28xx_init_dev(dev, udev, interface, nr);\r\nif (retval) {\r\ngoto err_free;\r\n}\r\nif (usb_xfer_mode < 0) {\r\nif (dev->board.is_webcam)\r\ntry_bulk = 1;\r\nelse\r\ntry_bulk = 0;\r\n} else {\r\ntry_bulk = usb_xfer_mode > 0;\r\n}\r\nif (has_video) {\r\nif (!dev->analog_ep_isoc || (try_bulk && dev->analog_ep_bulk))\r\ndev->analog_xfer_bulk = 1;\r\nem28xx_info("analog set to %s mode.\n",\r\ndev->analog_xfer_bulk ? "bulk" : "isoc");\r\n}\r\nif (has_dvb) {\r\nif (!dev->dvb_ep_isoc || (try_bulk && dev->dvb_ep_bulk))\r\ndev->dvb_xfer_bulk = 1;\r\nem28xx_info("dvb set to %s mode.\n",\r\ndev->dvb_xfer_bulk ? "bulk" : "isoc");\r\n}\r\nkref_init(&dev->ref);\r\nrequest_modules(dev);\r\nreturn 0;\r\nerr_free:\r\nkfree(dev->alt_max_pkt_size_isoc);\r\nkfree(dev);\r\nerr:\r\nclear_bit(nr, em28xx_devused);\r\nerr_no_slot:\r\nusb_put_dev(udev);\r\nreturn retval;\r\n}\r\nstatic void em28xx_usb_disconnect(struct usb_interface *interface)\r\n{\r\nstruct em28xx *dev;\r\ndev = usb_get_intfdata(interface);\r\nusb_set_intfdata(interface, NULL);\r\nif (!dev)\r\nreturn;\r\ndev->disconnected = 1;\r\nem28xx_info("Disconnecting %s\n", dev->name);\r\nflush_request_modules(dev);\r\nem28xx_close_extension(dev);\r\nem28xx_release_resources(dev);\r\nkref_put(&dev->ref, em28xx_free_device);\r\n}\r\nstatic int em28xx_usb_suspend(struct usb_interface *interface,\r\npm_message_t message)\r\n{\r\nstruct em28xx *dev;\r\ndev = usb_get_intfdata(interface);\r\nif (!dev)\r\nreturn 0;\r\nem28xx_suspend_extension(dev);\r\nreturn 0;\r\n}\r\nstatic int em28xx_usb_resume(struct usb_interface *interface)\r\n{\r\nstruct em28xx *dev;\r\ndev = usb_get_intfdata(interface);\r\nif (!dev)\r\nreturn 0;\r\nem28xx_resume_extension(dev);\r\nreturn 0;\r\n}
