static int pcf8523_read(struct i2c_client *client, u8 reg, u8 *valuep)\r\n{\r\nstruct i2c_msg msgs[2];\r\nu8 value = 0;\r\nint err;\r\nmsgs[0].addr = client->addr;\r\nmsgs[0].flags = 0;\r\nmsgs[0].len = sizeof(reg);\r\nmsgs[0].buf = &reg;\r\nmsgs[1].addr = client->addr;\r\nmsgs[1].flags = I2C_M_RD;\r\nmsgs[1].len = sizeof(value);\r\nmsgs[1].buf = &value;\r\nerr = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (err < 0)\r\nreturn err;\r\n*valuep = value;\r\nreturn 0;\r\n}\r\nstatic int pcf8523_write(struct i2c_client *client, u8 reg, u8 value)\r\n{\r\nu8 buffer[2] = { reg, value };\r\nstruct i2c_msg msg;\r\nint err;\r\nmsg.addr = client->addr;\r\nmsg.flags = 0;\r\nmsg.len = sizeof(buffer);\r\nmsg.buf = buffer;\r\nerr = i2c_transfer(client->adapter, &msg, 1);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int pcf8523_select_capacitance(struct i2c_client *client, bool high)\r\n{\r\nu8 value;\r\nint err;\r\nerr = pcf8523_read(client, REG_CONTROL1, &value);\r\nif (err < 0)\r\nreturn err;\r\nif (!high)\r\nvalue &= ~REG_CONTROL1_CAP_SEL;\r\nelse\r\nvalue |= REG_CONTROL1_CAP_SEL;\r\nerr = pcf8523_write(client, REG_CONTROL1, value);\r\nif (err < 0)\r\nreturn err;\r\nreturn err;\r\n}\r\nstatic int pcf8523_set_pm(struct i2c_client *client, u8 pm)\r\n{\r\nu8 value;\r\nint err;\r\nerr = pcf8523_read(client, REG_CONTROL3, &value);\r\nif (err < 0)\r\nreturn err;\r\nvalue = (value & ~REG_CONTROL3_PM_MASK) | pm;\r\nerr = pcf8523_write(client, REG_CONTROL3, value);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int pcf8523_stop_rtc(struct i2c_client *client)\r\n{\r\nu8 value;\r\nint err;\r\nerr = pcf8523_read(client, REG_CONTROL1, &value);\r\nif (err < 0)\r\nreturn err;\r\nvalue |= REG_CONTROL1_STOP;\r\nerr = pcf8523_write(client, REG_CONTROL1, value);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int pcf8523_start_rtc(struct i2c_client *client)\r\n{\r\nu8 value;\r\nint err;\r\nerr = pcf8523_read(client, REG_CONTROL1, &value);\r\nif (err < 0)\r\nreturn err;\r\nvalue &= ~REG_CONTROL1_STOP;\r\nerr = pcf8523_write(client, REG_CONTROL1, value);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int pcf8523_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nu8 start = REG_SECONDS, regs[7];\r\nstruct i2c_msg msgs[2];\r\nint err;\r\nmsgs[0].addr = client->addr;\r\nmsgs[0].flags = 0;\r\nmsgs[0].len = 1;\r\nmsgs[0].buf = &start;\r\nmsgs[1].addr = client->addr;\r\nmsgs[1].flags = I2C_M_RD;\r\nmsgs[1].len = sizeof(regs);\r\nmsgs[1].buf = regs;\r\nerr = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (err < 0)\r\nreturn err;\r\nif (regs[0] & REG_SECONDS_OS) {\r\nregs[0] &= ~REG_SECONDS_OS;\r\nerr = pcf8523_write(client, REG_SECONDS, regs[0]);\r\nif (err < 0)\r\nreturn err;\r\nerr = pcf8523_read(client, REG_SECONDS, &regs[0]);\r\nif (err < 0)\r\nreturn err;\r\nif (regs[0] & REG_SECONDS_OS)\r\nreturn -EAGAIN;\r\n}\r\ntm->tm_sec = bcd2bin(regs[0] & 0x7f);\r\ntm->tm_min = bcd2bin(regs[1] & 0x7f);\r\ntm->tm_hour = bcd2bin(regs[2] & 0x3f);\r\ntm->tm_mday = bcd2bin(regs[3] & 0x3f);\r\ntm->tm_wday = regs[4] & 0x7;\r\ntm->tm_mon = bcd2bin(regs[5] & 0x1f) - 1;\r\ntm->tm_year = bcd2bin(regs[6]) + 100;\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int pcf8523_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct i2c_msg msg;\r\nu8 regs[8];\r\nint err;\r\nerr = pcf8523_stop_rtc(client);\r\nif (err < 0)\r\nreturn err;\r\nregs[0] = REG_SECONDS;\r\nregs[1] = bin2bcd(tm->tm_sec);\r\nregs[2] = bin2bcd(tm->tm_min);\r\nregs[3] = bin2bcd(tm->tm_hour);\r\nregs[4] = bin2bcd(tm->tm_mday);\r\nregs[5] = tm->tm_wday;\r\nregs[6] = bin2bcd(tm->tm_mon + 1);\r\nregs[7] = bin2bcd(tm->tm_year - 100);\r\nmsg.addr = client->addr;\r\nmsg.flags = 0;\r\nmsg.len = sizeof(regs);\r\nmsg.buf = regs;\r\nerr = i2c_transfer(client->adapter, &msg, 1);\r\nif (err < 0) {\r\npcf8523_start_rtc(client);\r\nreturn err;\r\n}\r\nreturn pcf8523_start_rtc(client);\r\n}\r\nstatic int pcf8523_rtc_ioctl(struct device *dev, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nu8 value;\r\nint ret = 0, err;\r\nswitch (cmd) {\r\ncase RTC_VL_READ:\r\nerr = pcf8523_read(client, REG_CONTROL3, &value);\r\nif (err < 0)\r\nreturn err;\r\nif (value & REG_CONTROL3_BLF)\r\nret = 1;\r\nif (copy_to_user((void __user *)arg, &ret, sizeof(int)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic int pcf8523_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct pcf8523 *pcf;\r\nint err;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\r\nreturn -ENODEV;\r\npcf = devm_kzalloc(&client->dev, sizeof(*pcf), GFP_KERNEL);\r\nif (!pcf)\r\nreturn -ENOMEM;\r\nerr = pcf8523_select_capacitance(client, true);\r\nif (err < 0)\r\nreturn err;\r\nerr = pcf8523_set_pm(client, 0);\r\nif (err < 0)\r\nreturn err;\r\npcf->rtc = devm_rtc_device_register(&client->dev, DRIVER_NAME,\r\n&pcf8523_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(pcf->rtc))\r\nreturn PTR_ERR(pcf->rtc);\r\ni2c_set_clientdata(client, pcf);\r\nreturn 0;\r\n}
