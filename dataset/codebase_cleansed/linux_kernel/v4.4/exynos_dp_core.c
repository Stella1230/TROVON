static inline struct exynos_drm_crtc *dp_to_crtc(struct exynos_dp_device *dp)\r\n{\r\nreturn to_exynos_crtc(dp->encoder.crtc);\r\n}\r\nstatic inline struct exynos_dp_device *encoder_to_dp(\r\nstruct drm_encoder *e)\r\n{\r\nreturn container_of(e, struct exynos_dp_device, encoder);\r\n}\r\nstatic void exynos_dp_init_dp(struct exynos_dp_device *dp)\r\n{\r\nexynos_dp_reset(dp);\r\nexynos_dp_swreset(dp);\r\nexynos_dp_init_analog_param(dp);\r\nexynos_dp_init_interrupt(dp);\r\nexynos_dp_enable_sw_function(dp);\r\nexynos_dp_config_interrupt(dp);\r\nexynos_dp_init_analog_func(dp);\r\nexynos_dp_init_hpd(dp);\r\nexynos_dp_init_aux(dp);\r\n}\r\nstatic int exynos_dp_detect_hpd(struct exynos_dp_device *dp)\r\n{\r\nint timeout_loop = 0;\r\nwhile (exynos_dp_get_plug_in_status(dp) != 0) {\r\ntimeout_loop++;\r\nif (DP_TIMEOUT_LOOP_COUNT < timeout_loop) {\r\ndev_err(dp->dev, "failed to get hpd plug status\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nusleep_range(10, 11);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned char exynos_dp_calc_edid_check_sum(unsigned char *edid_data)\r\n{\r\nint i;\r\nunsigned char sum = 0;\r\nfor (i = 0; i < EDID_BLOCK_LENGTH; i++)\r\nsum = sum + edid_data[i];\r\nreturn sum;\r\n}\r\nstatic int exynos_dp_read_edid(struct exynos_dp_device *dp)\r\n{\r\nunsigned char edid[EDID_BLOCK_LENGTH * 2];\r\nunsigned int extend_block = 0;\r\nunsigned char sum;\r\nunsigned char test_vector;\r\nint retval;\r\nretval = exynos_dp_read_byte_from_i2c(dp, I2C_EDID_DEVICE_ADDR,\r\nEDID_EXTENSION_FLAG,\r\n&extend_block);\r\nif (retval)\r\nreturn retval;\r\nif (extend_block > 0) {\r\ndev_dbg(dp->dev, "EDID data includes a single extension!\n");\r\nretval = exynos_dp_read_bytes_from_i2c(dp, I2C_EDID_DEVICE_ADDR,\r\nEDID_HEADER_PATTERN,\r\nEDID_BLOCK_LENGTH,\r\n&edid[EDID_HEADER_PATTERN]);\r\nif (retval != 0) {\r\ndev_err(dp->dev, "EDID Read failed!\n");\r\nreturn -EIO;\r\n}\r\nsum = exynos_dp_calc_edid_check_sum(edid);\r\nif (sum != 0) {\r\ndev_err(dp->dev, "EDID bad checksum!\n");\r\nreturn -EIO;\r\n}\r\nretval = exynos_dp_read_bytes_from_i2c(dp,\r\nI2C_EDID_DEVICE_ADDR,\r\nEDID_BLOCK_LENGTH,\r\nEDID_BLOCK_LENGTH,\r\n&edid[EDID_BLOCK_LENGTH]);\r\nif (retval != 0) {\r\ndev_err(dp->dev, "EDID Read failed!\n");\r\nreturn -EIO;\r\n}\r\nsum = exynos_dp_calc_edid_check_sum(&edid[EDID_BLOCK_LENGTH]);\r\nif (sum != 0) {\r\ndev_err(dp->dev, "EDID bad checksum!\n");\r\nreturn -EIO;\r\n}\r\nexynos_dp_read_byte_from_dpcd(dp, DP_TEST_REQUEST,\r\n&test_vector);\r\nif (test_vector & DP_TEST_LINK_EDID_READ) {\r\nexynos_dp_write_byte_to_dpcd(dp,\r\nDP_TEST_EDID_CHECKSUM,\r\nedid[EDID_BLOCK_LENGTH + EDID_CHECKSUM]);\r\nexynos_dp_write_byte_to_dpcd(dp,\r\nDP_TEST_RESPONSE,\r\nDP_TEST_EDID_CHECKSUM_WRITE);\r\n}\r\n} else {\r\ndev_info(dp->dev, "EDID data does not include any extensions.\n");\r\nretval = exynos_dp_read_bytes_from_i2c(dp,\r\nI2C_EDID_DEVICE_ADDR,\r\nEDID_HEADER_PATTERN,\r\nEDID_BLOCK_LENGTH,\r\n&edid[EDID_HEADER_PATTERN]);\r\nif (retval != 0) {\r\ndev_err(dp->dev, "EDID Read failed!\n");\r\nreturn -EIO;\r\n}\r\nsum = exynos_dp_calc_edid_check_sum(edid);\r\nif (sum != 0) {\r\ndev_err(dp->dev, "EDID bad checksum!\n");\r\nreturn -EIO;\r\n}\r\nexynos_dp_read_byte_from_dpcd(dp,\r\nDP_TEST_REQUEST,\r\n&test_vector);\r\nif (test_vector & DP_TEST_LINK_EDID_READ) {\r\nexynos_dp_write_byte_to_dpcd(dp,\r\nDP_TEST_EDID_CHECKSUM,\r\nedid[EDID_CHECKSUM]);\r\nexynos_dp_write_byte_to_dpcd(dp,\r\nDP_TEST_RESPONSE,\r\nDP_TEST_EDID_CHECKSUM_WRITE);\r\n}\r\n}\r\ndev_dbg(dp->dev, "EDID Read success!\n");\r\nreturn 0;\r\n}\r\nstatic int exynos_dp_handle_edid(struct exynos_dp_device *dp)\r\n{\r\nu8 buf[12];\r\nint i;\r\nint retval;\r\nretval = exynos_dp_read_bytes_from_dpcd(dp, DP_DPCD_REV,\r\n12, buf);\r\nif (retval)\r\nreturn retval;\r\nfor (i = 0; i < 3; i++) {\r\nretval = exynos_dp_read_edid(dp);\r\nif (!retval)\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic void exynos_dp_enable_rx_to_enhanced_mode(struct exynos_dp_device *dp,\r\nbool enable)\r\n{\r\nu8 data;\r\nexynos_dp_read_byte_from_dpcd(dp, DP_LANE_COUNT_SET, &data);\r\nif (enable)\r\nexynos_dp_write_byte_to_dpcd(dp, DP_LANE_COUNT_SET,\r\nDP_LANE_COUNT_ENHANCED_FRAME_EN |\r\nDPCD_LANE_COUNT_SET(data));\r\nelse\r\nexynos_dp_write_byte_to_dpcd(dp, DP_LANE_COUNT_SET,\r\nDPCD_LANE_COUNT_SET(data));\r\n}\r\nstatic int exynos_dp_is_enhanced_mode_available(struct exynos_dp_device *dp)\r\n{\r\nu8 data;\r\nint retval;\r\nexynos_dp_read_byte_from_dpcd(dp, DP_MAX_LANE_COUNT, &data);\r\nretval = DPCD_ENHANCED_FRAME_CAP(data);\r\nreturn retval;\r\n}\r\nstatic void exynos_dp_set_enhanced_mode(struct exynos_dp_device *dp)\r\n{\r\nu8 data;\r\ndata = exynos_dp_is_enhanced_mode_available(dp);\r\nexynos_dp_enable_rx_to_enhanced_mode(dp, data);\r\nexynos_dp_enable_enhanced_mode(dp, data);\r\n}\r\nstatic void exynos_dp_training_pattern_dis(struct exynos_dp_device *dp)\r\n{\r\nexynos_dp_set_training_pattern(dp, DP_NONE);\r\nexynos_dp_write_byte_to_dpcd(dp,\r\nDP_TRAINING_PATTERN_SET,\r\nDP_TRAINING_PATTERN_DISABLE);\r\n}\r\nstatic void exynos_dp_set_lane_lane_pre_emphasis(struct exynos_dp_device *dp,\r\nint pre_emphasis, int lane)\r\n{\r\nswitch (lane) {\r\ncase 0:\r\nexynos_dp_set_lane0_pre_emphasis(dp, pre_emphasis);\r\nbreak;\r\ncase 1:\r\nexynos_dp_set_lane1_pre_emphasis(dp, pre_emphasis);\r\nbreak;\r\ncase 2:\r\nexynos_dp_set_lane2_pre_emphasis(dp, pre_emphasis);\r\nbreak;\r\ncase 3:\r\nexynos_dp_set_lane3_pre_emphasis(dp, pre_emphasis);\r\nbreak;\r\n}\r\n}\r\nstatic int exynos_dp_link_start(struct exynos_dp_device *dp)\r\n{\r\nu8 buf[4];\r\nint lane, lane_count, pll_tries, retval;\r\nlane_count = dp->link_train.lane_count;\r\ndp->link_train.lt_state = CLOCK_RECOVERY;\r\ndp->link_train.eq_loop = 0;\r\nfor (lane = 0; lane < lane_count; lane++)\r\ndp->link_train.cr_loop[lane] = 0;\r\nexynos_dp_set_link_bandwidth(dp, dp->link_train.link_rate);\r\nexynos_dp_set_lane_count(dp, dp->link_train.lane_count);\r\nbuf[0] = dp->link_train.link_rate;\r\nbuf[1] = dp->link_train.lane_count;\r\nretval = exynos_dp_write_bytes_to_dpcd(dp, DP_LINK_BW_SET,\r\n2, buf);\r\nif (retval)\r\nreturn retval;\r\nfor (lane = 0; lane < lane_count; lane++)\r\nexynos_dp_set_lane_lane_pre_emphasis(dp,\r\nPRE_EMPHASIS_LEVEL_0, lane);\r\npll_tries = 0;\r\nwhile (exynos_dp_get_pll_lock_status(dp) == PLL_UNLOCKED) {\r\nif (pll_tries == DP_TIMEOUT_LOOP_COUNT) {\r\ndev_err(dp->dev, "Wait for PLL lock timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\npll_tries++;\r\nusleep_range(90, 120);\r\n}\r\nexynos_dp_set_training_pattern(dp, TRAINING_PTN1);\r\nretval = exynos_dp_write_byte_to_dpcd(dp,\r\nDP_TRAINING_PATTERN_SET,\r\nDP_LINK_SCRAMBLING_DISABLE | DP_TRAINING_PATTERN_1);\r\nif (retval)\r\nreturn retval;\r\nfor (lane = 0; lane < lane_count; lane++)\r\nbuf[lane] = DP_TRAIN_PRE_EMPH_LEVEL_0 |\r\nDP_TRAIN_VOLTAGE_SWING_LEVEL_0;\r\nretval = exynos_dp_write_bytes_to_dpcd(dp, DP_TRAINING_LANE0_SET,\r\nlane_count, buf);\r\nreturn retval;\r\n}\r\nstatic unsigned char exynos_dp_get_lane_status(u8 link_status[2], int lane)\r\n{\r\nint shift = (lane & 1) * 4;\r\nu8 link_value = link_status[lane>>1];\r\nreturn (link_value >> shift) & 0xf;\r\n}\r\nstatic int exynos_dp_clock_recovery_ok(u8 link_status[2], int lane_count)\r\n{\r\nint lane;\r\nu8 lane_status;\r\nfor (lane = 0; lane < lane_count; lane++) {\r\nlane_status = exynos_dp_get_lane_status(link_status, lane);\r\nif ((lane_status & DP_LANE_CR_DONE) == 0)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos_dp_channel_eq_ok(u8 link_status[2], u8 link_align,\r\nint lane_count)\r\n{\r\nint lane;\r\nu8 lane_status;\r\nif ((link_align & DP_INTERLANE_ALIGN_DONE) == 0)\r\nreturn -EINVAL;\r\nfor (lane = 0; lane < lane_count; lane++) {\r\nlane_status = exynos_dp_get_lane_status(link_status, lane);\r\nlane_status &= DP_CHANNEL_EQ_BITS;\r\nif (lane_status != DP_CHANNEL_EQ_BITS)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned char exynos_dp_get_adjust_request_voltage(u8 adjust_request[2],\r\nint lane)\r\n{\r\nint shift = (lane & 1) * 4;\r\nu8 link_value = adjust_request[lane>>1];\r\nreturn (link_value >> shift) & 0x3;\r\n}\r\nstatic unsigned char exynos_dp_get_adjust_request_pre_emphasis(\r\nu8 adjust_request[2],\r\nint lane)\r\n{\r\nint shift = (lane & 1) * 4;\r\nu8 link_value = adjust_request[lane>>1];\r\nreturn ((link_value >> shift) & 0xc) >> 2;\r\n}\r\nstatic void exynos_dp_set_lane_link_training(struct exynos_dp_device *dp,\r\nu8 training_lane_set, int lane)\r\n{\r\nswitch (lane) {\r\ncase 0:\r\nexynos_dp_set_lane0_link_training(dp, training_lane_set);\r\nbreak;\r\ncase 1:\r\nexynos_dp_set_lane1_link_training(dp, training_lane_set);\r\nbreak;\r\ncase 2:\r\nexynos_dp_set_lane2_link_training(dp, training_lane_set);\r\nbreak;\r\ncase 3:\r\nexynos_dp_set_lane3_link_training(dp, training_lane_set);\r\nbreak;\r\n}\r\n}\r\nstatic unsigned int exynos_dp_get_lane_link_training(\r\nstruct exynos_dp_device *dp,\r\nint lane)\r\n{\r\nu32 reg;\r\nswitch (lane) {\r\ncase 0:\r\nreg = exynos_dp_get_lane0_link_training(dp);\r\nbreak;\r\ncase 1:\r\nreg = exynos_dp_get_lane1_link_training(dp);\r\nbreak;\r\ncase 2:\r\nreg = exynos_dp_get_lane2_link_training(dp);\r\nbreak;\r\ncase 3:\r\nreg = exynos_dp_get_lane3_link_training(dp);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nreturn reg;\r\n}\r\nstatic void exynos_dp_reduce_link_rate(struct exynos_dp_device *dp)\r\n{\r\nexynos_dp_training_pattern_dis(dp);\r\nexynos_dp_set_enhanced_mode(dp);\r\ndp->link_train.lt_state = FAILED;\r\n}\r\nstatic void exynos_dp_get_adjust_training_lane(struct exynos_dp_device *dp,\r\nu8 adjust_request[2])\r\n{\r\nint lane, lane_count;\r\nu8 voltage_swing, pre_emphasis, training_lane;\r\nlane_count = dp->link_train.lane_count;\r\nfor (lane = 0; lane < lane_count; lane++) {\r\nvoltage_swing = exynos_dp_get_adjust_request_voltage(\r\nadjust_request, lane);\r\npre_emphasis = exynos_dp_get_adjust_request_pre_emphasis(\r\nadjust_request, lane);\r\ntraining_lane = DPCD_VOLTAGE_SWING_SET(voltage_swing) |\r\nDPCD_PRE_EMPHASIS_SET(pre_emphasis);\r\nif (voltage_swing == VOLTAGE_LEVEL_3)\r\ntraining_lane |= DP_TRAIN_MAX_SWING_REACHED;\r\nif (pre_emphasis == PRE_EMPHASIS_LEVEL_3)\r\ntraining_lane |= DP_TRAIN_MAX_PRE_EMPHASIS_REACHED;\r\ndp->link_train.training_lane[lane] = training_lane;\r\n}\r\n}\r\nstatic int exynos_dp_process_clock_recovery(struct exynos_dp_device *dp)\r\n{\r\nint lane, lane_count, retval;\r\nu8 voltage_swing, pre_emphasis, training_lane;\r\nu8 link_status[2], adjust_request[2];\r\nusleep_range(100, 101);\r\nlane_count = dp->link_train.lane_count;\r\nretval = exynos_dp_read_bytes_from_dpcd(dp,\r\nDP_LANE0_1_STATUS, 2, link_status);\r\nif (retval)\r\nreturn retval;\r\nretval = exynos_dp_read_bytes_from_dpcd(dp,\r\nDP_ADJUST_REQUEST_LANE0_1, 2, adjust_request);\r\nif (retval)\r\nreturn retval;\r\nif (exynos_dp_clock_recovery_ok(link_status, lane_count) == 0) {\r\nexynos_dp_set_training_pattern(dp, TRAINING_PTN2);\r\nretval = exynos_dp_write_byte_to_dpcd(dp,\r\nDP_TRAINING_PATTERN_SET,\r\nDP_LINK_SCRAMBLING_DISABLE |\r\nDP_TRAINING_PATTERN_2);\r\nif (retval)\r\nreturn retval;\r\ndev_info(dp->dev, "Link Training Clock Recovery success\n");\r\ndp->link_train.lt_state = EQUALIZER_TRAINING;\r\n} else {\r\nfor (lane = 0; lane < lane_count; lane++) {\r\ntraining_lane = exynos_dp_get_lane_link_training(\r\ndp, lane);\r\nvoltage_swing = exynos_dp_get_adjust_request_voltage(\r\nadjust_request, lane);\r\npre_emphasis = exynos_dp_get_adjust_request_pre_emphasis(\r\nadjust_request, lane);\r\nif (DPCD_VOLTAGE_SWING_GET(training_lane) ==\r\nvoltage_swing &&\r\nDPCD_PRE_EMPHASIS_GET(training_lane) ==\r\npre_emphasis)\r\ndp->link_train.cr_loop[lane]++;\r\nif (dp->link_train.cr_loop[lane] == MAX_CR_LOOP ||\r\nvoltage_swing == VOLTAGE_LEVEL_3 ||\r\npre_emphasis == PRE_EMPHASIS_LEVEL_3) {\r\ndev_err(dp->dev, "CR Max reached (%d,%d,%d)\n",\r\ndp->link_train.cr_loop[lane],\r\nvoltage_swing, pre_emphasis);\r\nexynos_dp_reduce_link_rate(dp);\r\nreturn -EIO;\r\n}\r\n}\r\n}\r\nexynos_dp_get_adjust_training_lane(dp, adjust_request);\r\nfor (lane = 0; lane < lane_count; lane++)\r\nexynos_dp_set_lane_link_training(dp,\r\ndp->link_train.training_lane[lane], lane);\r\nretval = exynos_dp_write_bytes_to_dpcd(dp,\r\nDP_TRAINING_LANE0_SET, lane_count,\r\ndp->link_train.training_lane);\r\nif (retval)\r\nreturn retval;\r\nreturn retval;\r\n}\r\nstatic int exynos_dp_process_equalizer_training(struct exynos_dp_device *dp)\r\n{\r\nint lane, lane_count, retval;\r\nu32 reg;\r\nu8 link_align, link_status[2], adjust_request[2];\r\nusleep_range(400, 401);\r\nlane_count = dp->link_train.lane_count;\r\nretval = exynos_dp_read_bytes_from_dpcd(dp,\r\nDP_LANE0_1_STATUS, 2, link_status);\r\nif (retval)\r\nreturn retval;\r\nif (exynos_dp_clock_recovery_ok(link_status, lane_count)) {\r\nexynos_dp_reduce_link_rate(dp);\r\nreturn -EIO;\r\n}\r\nretval = exynos_dp_read_bytes_from_dpcd(dp,\r\nDP_ADJUST_REQUEST_LANE0_1, 2, adjust_request);\r\nif (retval)\r\nreturn retval;\r\nretval = exynos_dp_read_byte_from_dpcd(dp,\r\nDP_LANE_ALIGN_STATUS_UPDATED, &link_align);\r\nif (retval)\r\nreturn retval;\r\nexynos_dp_get_adjust_training_lane(dp, adjust_request);\r\nif (!exynos_dp_channel_eq_ok(link_status, link_align, lane_count)) {\r\nexynos_dp_training_pattern_dis(dp);\r\ndev_info(dp->dev, "Link Training success!\n");\r\nexynos_dp_get_link_bandwidth(dp, &reg);\r\ndp->link_train.link_rate = reg;\r\ndev_dbg(dp->dev, "final bandwidth = %.2x\n",\r\ndp->link_train.link_rate);\r\nexynos_dp_get_lane_count(dp, &reg);\r\ndp->link_train.lane_count = reg;\r\ndev_dbg(dp->dev, "final lane count = %.2x\n",\r\ndp->link_train.lane_count);\r\nexynos_dp_set_enhanced_mode(dp);\r\ndp->link_train.lt_state = FINISHED;\r\nreturn 0;\r\n}\r\ndp->link_train.eq_loop++;\r\nif (dp->link_train.eq_loop > MAX_EQ_LOOP) {\r\ndev_err(dp->dev, "EQ Max loop\n");\r\nexynos_dp_reduce_link_rate(dp);\r\nreturn -EIO;\r\n}\r\nfor (lane = 0; lane < lane_count; lane++)\r\nexynos_dp_set_lane_link_training(dp,\r\ndp->link_train.training_lane[lane], lane);\r\nretval = exynos_dp_write_bytes_to_dpcd(dp, DP_TRAINING_LANE0_SET,\r\nlane_count, dp->link_train.training_lane);\r\nreturn retval;\r\n}\r\nstatic void exynos_dp_get_max_rx_bandwidth(struct exynos_dp_device *dp,\r\nu8 *bandwidth)\r\n{\r\nu8 data;\r\nexynos_dp_read_byte_from_dpcd(dp, DP_MAX_LINK_RATE, &data);\r\n*bandwidth = data;\r\n}\r\nstatic void exynos_dp_get_max_rx_lane_count(struct exynos_dp_device *dp,\r\nu8 *lane_count)\r\n{\r\nu8 data;\r\nexynos_dp_read_byte_from_dpcd(dp, DP_MAX_LANE_COUNT, &data);\r\n*lane_count = DPCD_MAX_LANE_COUNT(data);\r\n}\r\nstatic void exynos_dp_init_training(struct exynos_dp_device *dp,\r\nenum link_lane_count_type max_lane,\r\nenum link_rate_type max_rate)\r\n{\r\nexynos_dp_reset_macro(dp);\r\nexynos_dp_get_max_rx_bandwidth(dp, &dp->link_train.link_rate);\r\nexynos_dp_get_max_rx_lane_count(dp, &dp->link_train.lane_count);\r\nif ((dp->link_train.link_rate != LINK_RATE_1_62GBPS) &&\r\n(dp->link_train.link_rate != LINK_RATE_2_70GBPS)) {\r\ndev_err(dp->dev, "Rx Max Link Rate is abnormal :%x !\n",\r\ndp->link_train.link_rate);\r\ndp->link_train.link_rate = LINK_RATE_1_62GBPS;\r\n}\r\nif (dp->link_train.lane_count == 0) {\r\ndev_err(dp->dev, "Rx Max Lane count is abnormal :%x !\n",\r\ndp->link_train.lane_count);\r\ndp->link_train.lane_count = (u8)LANE_COUNT1;\r\n}\r\nif (dp->link_train.lane_count > max_lane)\r\ndp->link_train.lane_count = max_lane;\r\nif (dp->link_train.link_rate > max_rate)\r\ndp->link_train.link_rate = max_rate;\r\nexynos_dp_set_analog_power_down(dp, POWER_ALL, 0);\r\n}\r\nstatic int exynos_dp_sw_link_training(struct exynos_dp_device *dp)\r\n{\r\nint retval = 0, training_finished = 0;\r\ndp->link_train.lt_state = START;\r\nwhile (!retval && !training_finished) {\r\nswitch (dp->link_train.lt_state) {\r\ncase START:\r\nretval = exynos_dp_link_start(dp);\r\nif (retval)\r\ndev_err(dp->dev, "LT link start failed!\n");\r\nbreak;\r\ncase CLOCK_RECOVERY:\r\nretval = exynos_dp_process_clock_recovery(dp);\r\nif (retval)\r\ndev_err(dp->dev, "LT CR failed!\n");\r\nbreak;\r\ncase EQUALIZER_TRAINING:\r\nretval = exynos_dp_process_equalizer_training(dp);\r\nif (retval)\r\ndev_err(dp->dev, "LT EQ failed!\n");\r\nbreak;\r\ncase FINISHED:\r\ntraining_finished = 1;\r\nbreak;\r\ncase FAILED:\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\nif (retval)\r\ndev_err(dp->dev, "eDP link training failed (%d)\n", retval);\r\nreturn retval;\r\n}\r\nstatic int exynos_dp_set_link_train(struct exynos_dp_device *dp,\r\nu32 count,\r\nu32 bwtype)\r\n{\r\nint i;\r\nint retval;\r\nfor (i = 0; i < DP_TIMEOUT_LOOP_COUNT; i++) {\r\nexynos_dp_init_training(dp, count, bwtype);\r\nretval = exynos_dp_sw_link_training(dp);\r\nif (retval == 0)\r\nbreak;\r\nusleep_range(100, 110);\r\n}\r\nreturn retval;\r\n}\r\nstatic int exynos_dp_config_video(struct exynos_dp_device *dp)\r\n{\r\nint retval = 0;\r\nint timeout_loop = 0;\r\nint done_count = 0;\r\nexynos_dp_config_video_slave_mode(dp);\r\nexynos_dp_set_video_color_format(dp);\r\nif (exynos_dp_get_pll_lock_status(dp) == PLL_UNLOCKED) {\r\ndev_err(dp->dev, "PLL is not locked yet.\n");\r\nreturn -EINVAL;\r\n}\r\nfor (;;) {\r\ntimeout_loop++;\r\nif (exynos_dp_is_slave_video_stream_clock_on(dp) == 0)\r\nbreak;\r\nif (DP_TIMEOUT_LOOP_COUNT < timeout_loop) {\r\ndev_err(dp->dev, "Timeout of video streamclk ok\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nusleep_range(1, 2);\r\n}\r\nexynos_dp_set_video_cr_mn(dp, CALCULATED_M, 0, 0);\r\nexynos_dp_set_video_timing_mode(dp, VIDEO_TIMING_FROM_CAPTURE);\r\nexynos_dp_enable_video_mute(dp, 0);\r\nexynos_dp_enable_video_master(dp, 0);\r\ntimeout_loop = 0;\r\nfor (;;) {\r\ntimeout_loop++;\r\nif (exynos_dp_is_video_stream_on(dp) == 0) {\r\ndone_count++;\r\nif (done_count > 10)\r\nbreak;\r\n} else if (done_count) {\r\ndone_count = 0;\r\n}\r\nif (DP_TIMEOUT_LOOP_COUNT < timeout_loop) {\r\ndev_err(dp->dev, "Timeout of video streamclk ok\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nusleep_range(1000, 1001);\r\n}\r\nif (retval != 0)\r\ndev_err(dp->dev, "Video stream is not detected!\n");\r\nreturn retval;\r\n}\r\nstatic void exynos_dp_enable_scramble(struct exynos_dp_device *dp, bool enable)\r\n{\r\nu8 data;\r\nif (enable) {\r\nexynos_dp_enable_scrambling(dp);\r\nexynos_dp_read_byte_from_dpcd(dp,\r\nDP_TRAINING_PATTERN_SET,\r\n&data);\r\nexynos_dp_write_byte_to_dpcd(dp,\r\nDP_TRAINING_PATTERN_SET,\r\n(u8)(data & ~DP_LINK_SCRAMBLING_DISABLE));\r\n} else {\r\nexynos_dp_disable_scrambling(dp);\r\nexynos_dp_read_byte_from_dpcd(dp,\r\nDP_TRAINING_PATTERN_SET,\r\n&data);\r\nexynos_dp_write_byte_to_dpcd(dp,\r\nDP_TRAINING_PATTERN_SET,\r\n(u8)(data | DP_LINK_SCRAMBLING_DISABLE));\r\n}\r\n}\r\nstatic irqreturn_t exynos_dp_irq_handler(int irq, void *arg)\r\n{\r\nstruct exynos_dp_device *dp = arg;\r\nenum dp_irq_type irq_type;\r\nirq_type = exynos_dp_get_irq_type(dp);\r\nswitch (irq_type) {\r\ncase DP_IRQ_TYPE_HP_CABLE_IN:\r\ndev_dbg(dp->dev, "Received irq - cable in\n");\r\nschedule_work(&dp->hotplug_work);\r\nexynos_dp_clear_hotplug_interrupts(dp);\r\nbreak;\r\ncase DP_IRQ_TYPE_HP_CABLE_OUT:\r\ndev_dbg(dp->dev, "Received irq - cable out\n");\r\nexynos_dp_clear_hotplug_interrupts(dp);\r\nbreak;\r\ncase DP_IRQ_TYPE_HP_CHANGE:\r\ndev_dbg(dp->dev, "Received irq - hotplug change; ignoring.\n");\r\nexynos_dp_clear_hotplug_interrupts(dp);\r\nbreak;\r\ndefault:\r\ndev_err(dp->dev, "Received irq - unknown type!\n");\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void exynos_dp_hotplug(struct work_struct *work)\r\n{\r\nstruct exynos_dp_device *dp;\r\ndp = container_of(work, struct exynos_dp_device, hotplug_work);\r\nif (dp->drm_dev)\r\ndrm_helper_hpd_irq_event(dp->drm_dev);\r\n}\r\nstatic void exynos_dp_commit(struct drm_encoder *encoder)\r\n{\r\nstruct exynos_dp_device *dp = encoder_to_dp(encoder);\r\nint ret;\r\nif (dp->panel) {\r\nif (drm_panel_disable(dp->panel))\r\nDRM_ERROR("failed to disable the panel\n");\r\n}\r\nret = exynos_dp_detect_hpd(dp);\r\nif (ret) {\r\nreturn;\r\n}\r\nret = exynos_dp_handle_edid(dp);\r\nif (ret) {\r\ndev_err(dp->dev, "unable to handle edid\n");\r\nreturn;\r\n}\r\nret = exynos_dp_set_link_train(dp, dp->video_info->lane_count,\r\ndp->video_info->link_rate);\r\nif (ret) {\r\ndev_err(dp->dev, "unable to do link train\n");\r\nreturn;\r\n}\r\nexynos_dp_enable_scramble(dp, 1);\r\nexynos_dp_enable_rx_to_enhanced_mode(dp, 1);\r\nexynos_dp_enable_enhanced_mode(dp, 1);\r\nexynos_dp_set_lane_count(dp, dp->video_info->lane_count);\r\nexynos_dp_set_link_bandwidth(dp, dp->video_info->link_rate);\r\nexynos_dp_init_video(dp);\r\nret = exynos_dp_config_video(dp);\r\nif (ret)\r\ndev_err(dp->dev, "unable to config video\n");\r\nif (dp->panel) {\r\nif (drm_panel_enable(dp->panel))\r\nDRM_ERROR("failed to enable the panel\n");\r\n}\r\nexynos_dp_start_video(dp);\r\n}\r\nstatic enum drm_connector_status exynos_dp_detect(\r\nstruct drm_connector *connector, bool force)\r\n{\r\nreturn connector_status_connected;\r\n}\r\nstatic void exynos_dp_connector_destroy(struct drm_connector *connector)\r\n{\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\n}\r\nstatic int exynos_dp_get_modes(struct drm_connector *connector)\r\n{\r\nstruct exynos_dp_device *dp = ctx_from_connector(connector);\r\nstruct drm_display_mode *mode;\r\nif (dp->panel)\r\nreturn drm_panel_get_modes(dp->panel);\r\nmode = drm_mode_create(connector->dev);\r\nif (!mode) {\r\nDRM_ERROR("failed to create a new display mode.\n");\r\nreturn 0;\r\n}\r\ndrm_display_mode_from_videomode(&dp->priv.vm, mode);\r\nmode->width_mm = dp->priv.width_mm;\r\nmode->height_mm = dp->priv.height_mm;\r\nconnector->display_info.width_mm = mode->width_mm;\r\nconnector->display_info.height_mm = mode->height_mm;\r\nmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_set_name(mode);\r\ndrm_mode_probed_add(connector, mode);\r\nreturn 1;\r\n}\r\nstatic struct drm_encoder *exynos_dp_best_encoder(\r\nstruct drm_connector *connector)\r\n{\r\nstruct exynos_dp_device *dp = ctx_from_connector(connector);\r\nreturn &dp->encoder;\r\n}\r\nstatic int exynos_drm_attach_lcd_bridge(struct exynos_dp_device *dp,\r\nstruct drm_encoder *encoder)\r\n{\r\nint ret;\r\nencoder->bridge = dp->bridge;\r\ndp->bridge->encoder = encoder;\r\nret = drm_bridge_attach(encoder->dev, dp->bridge);\r\nif (ret) {\r\nDRM_ERROR("Failed to attach bridge to drm\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos_dp_create_connector(struct drm_encoder *encoder)\r\n{\r\nstruct exynos_dp_device *dp = encoder_to_dp(encoder);\r\nstruct drm_connector *connector = &dp->connector;\r\nint ret;\r\nif (dp->bridge) {\r\nret = exynos_drm_attach_lcd_bridge(dp, encoder);\r\nif (!ret)\r\nreturn 0;\r\n}\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\nret = drm_connector_init(dp->drm_dev, connector,\r\n&exynos_dp_connector_funcs, DRM_MODE_CONNECTOR_eDP);\r\nif (ret) {\r\nDRM_ERROR("Failed to initialize connector with drm\n");\r\nreturn ret;\r\n}\r\ndrm_connector_helper_add(connector, &exynos_dp_connector_helper_funcs);\r\ndrm_connector_register(connector);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nif (dp->panel)\r\nret = drm_panel_attach(dp->panel, &dp->connector);\r\nreturn ret;\r\n}\r\nstatic bool exynos_dp_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void exynos_dp_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\n}\r\nstatic void exynos_dp_enable(struct drm_encoder *encoder)\r\n{\r\nstruct exynos_dp_device *dp = encoder_to_dp(encoder);\r\nstruct exynos_drm_crtc *crtc = dp_to_crtc(dp);\r\nif (dp->dpms_mode == DRM_MODE_DPMS_ON)\r\nreturn;\r\nif (dp->panel) {\r\nif (drm_panel_prepare(dp->panel)) {\r\nDRM_ERROR("failed to setup the panel\n");\r\nreturn;\r\n}\r\n}\r\nif (crtc->ops->clock_enable)\r\ncrtc->ops->clock_enable(dp_to_crtc(dp), true);\r\nclk_prepare_enable(dp->clock);\r\nphy_power_on(dp->phy);\r\nexynos_dp_init_dp(dp);\r\nenable_irq(dp->irq);\r\nexynos_dp_commit(&dp->encoder);\r\ndp->dpms_mode = DRM_MODE_DPMS_ON;\r\n}\r\nstatic void exynos_dp_disable(struct drm_encoder *encoder)\r\n{\r\nstruct exynos_dp_device *dp = encoder_to_dp(encoder);\r\nstruct exynos_drm_crtc *crtc = dp_to_crtc(dp);\r\nif (dp->dpms_mode != DRM_MODE_DPMS_ON)\r\nreturn;\r\nif (dp->panel) {\r\nif (drm_panel_disable(dp->panel)) {\r\nDRM_ERROR("failed to disable the panel\n");\r\nreturn;\r\n}\r\n}\r\ndisable_irq(dp->irq);\r\nflush_work(&dp->hotplug_work);\r\nphy_power_off(dp->phy);\r\nclk_disable_unprepare(dp->clock);\r\nif (crtc->ops->clock_enable)\r\ncrtc->ops->clock_enable(dp_to_crtc(dp), false);\r\nif (dp->panel) {\r\nif (drm_panel_unprepare(dp->panel))\r\nDRM_ERROR("failed to turnoff the panel\n");\r\n}\r\ndp->dpms_mode = DRM_MODE_DPMS_OFF;\r\n}\r\nstatic struct video_info *exynos_dp_dt_parse_pdata(struct device *dev)\r\n{\r\nstruct device_node *dp_node = dev->of_node;\r\nstruct video_info *dp_video_config;\r\ndp_video_config = devm_kzalloc(dev,\r\nsizeof(*dp_video_config), GFP_KERNEL);\r\nif (!dp_video_config)\r\nreturn ERR_PTR(-ENOMEM);\r\ndp_video_config->h_sync_polarity =\r\nof_property_read_bool(dp_node, "hsync-active-high");\r\ndp_video_config->v_sync_polarity =\r\nof_property_read_bool(dp_node, "vsync-active-high");\r\ndp_video_config->interlaced =\r\nof_property_read_bool(dp_node, "interlaced");\r\nif (of_property_read_u32(dp_node, "samsung,color-space",\r\n&dp_video_config->color_space)) {\r\ndev_err(dev, "failed to get color-space\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (of_property_read_u32(dp_node, "samsung,dynamic-range",\r\n&dp_video_config->dynamic_range)) {\r\ndev_err(dev, "failed to get dynamic-range\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (of_property_read_u32(dp_node, "samsung,ycbcr-coeff",\r\n&dp_video_config->ycbcr_coeff)) {\r\ndev_err(dev, "failed to get ycbcr-coeff\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (of_property_read_u32(dp_node, "samsung,color-depth",\r\n&dp_video_config->color_depth)) {\r\ndev_err(dev, "failed to get color-depth\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (of_property_read_u32(dp_node, "samsung,link-rate",\r\n&dp_video_config->link_rate)) {\r\ndev_err(dev, "failed to get link-rate\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (of_property_read_u32(dp_node, "samsung,lane-count",\r\n&dp_video_config->lane_count)) {\r\ndev_err(dev, "failed to get lane-count\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn dp_video_config;\r\n}\r\nstatic int exynos_dp_dt_parse_panel(struct exynos_dp_device *dp)\r\n{\r\nint ret;\r\nret = of_get_videomode(dp->dev->of_node, &dp->priv.vm,\r\nOF_USE_NATIVE_MODE);\r\nif (ret) {\r\nDRM_ERROR("failed: of_get_videomode() : %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos_dp_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct exynos_dp_device *dp = dev_get_drvdata(dev);\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct drm_device *drm_dev = data;\r\nstruct drm_encoder *encoder = &dp->encoder;\r\nstruct resource *res;\r\nunsigned int irq_flags;\r\nint pipe, ret = 0;\r\ndp->dev = &pdev->dev;\r\ndp->dpms_mode = DRM_MODE_DPMS_OFF;\r\ndp->video_info = exynos_dp_dt_parse_pdata(&pdev->dev);\r\nif (IS_ERR(dp->video_info))\r\nreturn PTR_ERR(dp->video_info);\r\ndp->phy = devm_phy_get(dp->dev, "dp");\r\nif (IS_ERR(dp->phy)) {\r\ndev_err(dp->dev, "no DP phy configured\n");\r\nret = PTR_ERR(dp->phy);\r\nif (ret) {\r\nif (ret == -ENOSYS || ret == -ENODEV)\r\ndp->phy = NULL;\r\nelse\r\nreturn ret;\r\n}\r\n}\r\nif (!dp->panel && !dp->bridge) {\r\nret = exynos_dp_dt_parse_panel(dp);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndp->clock = devm_clk_get(&pdev->dev, "dp");\r\nif (IS_ERR(dp->clock)) {\r\ndev_err(&pdev->dev, "failed to get clock\n");\r\nreturn PTR_ERR(dp->clock);\r\n}\r\nclk_prepare_enable(dp->clock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndp->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(dp->reg_base))\r\nreturn PTR_ERR(dp->reg_base);\r\ndp->hpd_gpio = of_get_named_gpio(dev->of_node, "samsung,hpd-gpio", 0);\r\nif (gpio_is_valid(dp->hpd_gpio)) {\r\nret = devm_gpio_request_one(&pdev->dev, dp->hpd_gpio, GPIOF_IN,\r\n"hpd_gpio");\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to get hpd gpio\n");\r\nreturn ret;\r\n}\r\ndp->irq = gpio_to_irq(dp->hpd_gpio);\r\nirq_flags = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING;\r\n} else {\r\ndp->hpd_gpio = -ENODEV;\r\ndp->irq = platform_get_irq(pdev, 0);\r\nirq_flags = 0;\r\n}\r\nif (dp->irq == -ENXIO) {\r\ndev_err(&pdev->dev, "failed to get irq\n");\r\nreturn -ENODEV;\r\n}\r\nINIT_WORK(&dp->hotplug_work, exynos_dp_hotplug);\r\nphy_power_on(dp->phy);\r\nexynos_dp_init_dp(dp);\r\nret = devm_request_irq(&pdev->dev, dp->irq, exynos_dp_irq_handler,\r\nirq_flags, "exynos-dp", dp);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request irq\n");\r\nreturn ret;\r\n}\r\ndisable_irq(dp->irq);\r\ndp->drm_dev = drm_dev;\r\npipe = exynos_drm_crtc_get_pipe_from_type(drm_dev,\r\nEXYNOS_DISPLAY_TYPE_LCD);\r\nif (pipe < 0)\r\nreturn pipe;\r\nencoder->possible_crtcs = 1 << pipe;\r\nDRM_DEBUG_KMS("possible_crtcs = 0x%x\n", encoder->possible_crtcs);\r\ndrm_encoder_init(drm_dev, encoder, &exynos_dp_encoder_funcs,\r\nDRM_MODE_ENCODER_TMDS);\r\ndrm_encoder_helper_add(encoder, &exynos_dp_encoder_helper_funcs);\r\nret = exynos_dp_create_connector(encoder);\r\nif (ret) {\r\nDRM_ERROR("failed to create connector ret = %d\n", ret);\r\ndrm_encoder_cleanup(encoder);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void exynos_dp_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct exynos_dp_device *dp = dev_get_drvdata(dev);\r\nexynos_dp_disable(&dp->encoder);\r\n}\r\nstatic int exynos_dp_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *panel_node, *bridge_node, *endpoint;\r\nstruct exynos_dp_device *dp;\r\ndp = devm_kzalloc(&pdev->dev, sizeof(struct exynos_dp_device),\r\nGFP_KERNEL);\r\nif (!dp)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, dp);\r\npanel_node = of_parse_phandle(dev->of_node, "panel", 0);\r\nif (panel_node) {\r\ndp->panel = of_drm_find_panel(panel_node);\r\nof_node_put(panel_node);\r\nif (!dp->panel)\r\nreturn -EPROBE_DEFER;\r\n}\r\nendpoint = of_graph_get_next_endpoint(dev->of_node, NULL);\r\nif (endpoint) {\r\nbridge_node = of_graph_get_remote_port_parent(endpoint);\r\nif (bridge_node) {\r\ndp->bridge = of_drm_find_bridge(bridge_node);\r\nof_node_put(bridge_node);\r\nif (!dp->bridge)\r\nreturn -EPROBE_DEFER;\r\n} else\r\nreturn -EPROBE_DEFER;\r\n}\r\nreturn component_add(&pdev->dev, &exynos_dp_ops);\r\n}\r\nstatic int exynos_dp_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &exynos_dp_ops);\r\nreturn 0;\r\n}
