static inline void __iomem *metag_hwvec_addr(irq_hw_number_t hw)\r\n{\r\nvoid __iomem *addr;\r\nswitch (hw) {\r\ncase PERF0TRIG_OFFSET:\r\naddr = (void __iomem *)PERF0VECINT;\r\nbreak;\r\ncase PERF1TRIG_OFFSET:\r\naddr = (void __iomem *)PERF1VECINT;\r\nbreak;\r\ndefault:\r\naddr = NULL;\r\nbreak;\r\n}\r\nreturn addr;\r\n}\r\nstatic unsigned int metag_internal_irq_startup(struct irq_data *data)\r\n{\r\nmetag_internal_irq_ack(data);\r\nmetag_internal_irq_unmask(data);\r\nreturn 0;\r\n}\r\nstatic void metag_internal_irq_shutdown(struct irq_data *data)\r\n{\r\nmetag_internal_irq_mask(data);\r\nmetag_internal_irq_ack(data);\r\n}\r\nstatic void metag_internal_irq_ack(struct irq_data *data)\r\n{\r\nirq_hw_number_t hw = data->hwirq;\r\nunsigned int bit = 1 << hw;\r\nif (metag_in32(HWSTATMETA) & bit)\r\nmetag_out32(bit, HWSTATMETA);\r\n}\r\nstatic void metag_internal_irq_mask(struct irq_data *data)\r\n{\r\nstruct metag_internal_irq_priv *priv = &metag_internal_irq_priv;\r\nirq_hw_number_t hw = data->hwirq;\r\nvoid __iomem *vec_addr = metag_hwvec_addr(hw);\r\nclear_bit(hw, &priv->unmasked);\r\nmetag_out32(0, vec_addr);\r\n}\r\nstatic void metag_internal_irq_unmask(struct irq_data *data)\r\n{\r\nstruct metag_internal_irq_priv *priv = &metag_internal_irq_priv;\r\nirq_hw_number_t hw = data->hwirq;\r\nunsigned int bit = 1 << hw;\r\nvoid __iomem *vec_addr = metag_hwvec_addr(hw);\r\nunsigned int thread = hard_processor_id();\r\nset_bit(hw, &priv->unmasked);\r\nmetag_out32(TBI_TRIG_VEC(TBID_SIGNUM_TR1(thread)), vec_addr);\r\nif (metag_in32(HWSTATMETA) & bit) {\r\nmetag_out32(bit, HWSTATMETA);\r\nwhile (!(metag_in32(HWSTATMETA) & bit))\r\nmetag_out32(bit, HWSTATMETA);\r\n}\r\n}\r\nstatic int metag_internal_irq_set_affinity(struct irq_data *data,\r\nconst struct cpumask *cpumask, bool force)\r\n{\r\nunsigned int cpu, thread;\r\nirq_hw_number_t hw = data->hwirq;\r\ncpu = cpumask_any_and(cpumask, cpu_online_mask);\r\nthread = cpu_2_hwthread_id[cpu];\r\nmetag_out32(TBI_TRIG_VEC(TBID_SIGNUM_TR1(thread)),\r\nmetag_hwvec_addr(hw));\r\nreturn 0;\r\n}\r\nstatic void metag_internal_irq_demux(struct irq_desc *desc)\r\n{\r\nstruct metag_internal_irq_priv *priv = irq_desc_get_handler_data(desc);\r\nirq_hw_number_t hw;\r\nunsigned int irq_no;\r\nu32 status;\r\nrecalculate:\r\nstatus = metag_in32(HWSTATMETA) & priv->unmasked;\r\nfor (hw = 0; status != 0; status >>= 1, ++hw) {\r\nif (status & 0x1) {\r\nirq_no = irq_linear_revmap(priv->domain, hw);\r\ngeneric_handle_irq(irq_no);\r\ngoto recalculate;\r\n}\r\n}\r\n}\r\nint internal_irq_map(unsigned int hw)\r\n{\r\nstruct metag_internal_irq_priv *priv = &metag_internal_irq_priv;\r\nif (!priv->domain)\r\nreturn -ENODEV;\r\nreturn irq_create_mapping(priv->domain, hw);\r\n}\r\nstatic void metag_internal_irq_init_cpu(struct metag_internal_irq_priv *priv,\r\nint cpu)\r\n{\r\nunsigned int thread = cpu_2_hwthread_id[cpu];\r\nunsigned int signum = TBID_SIGNUM_TR1(thread);\r\nint irq = tbisig_map(signum);\r\nirq_set_chained_handler_and_data(irq, metag_internal_irq_demux, priv);\r\nirq_set_irq_type(irq, IRQ_TYPE_LEVEL_LOW);\r\n}\r\nstatic int metag_internal_intc_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hw)\r\n{\r\nif (!metag_hwvec_addr(hw))\r\nreturn -EINVAL;\r\nirq_set_chip_and_handler(irq, &internal_irq_edge_chip,\r\nhandle_edge_irq);\r\nreturn 0;\r\n}\r\nint __init init_internal_IRQ(void)\r\n{\r\nstruct metag_internal_irq_priv *priv = &metag_internal_irq_priv;\r\nunsigned int cpu;\r\npriv->domain = irq_domain_add_linear(NULL, 32,\r\n&metag_internal_intc_domain_ops,\r\npriv);\r\nif (unlikely(!priv->domain)) {\r\npr_err("meta-internal-intc: cannot add IRQ domain\n");\r\nreturn -ENOMEM;\r\n}\r\nfor_each_possible_cpu(cpu)\r\nmetag_internal_irq_init_cpu(priv, cpu);\r\nreturn 0;\r\n}
