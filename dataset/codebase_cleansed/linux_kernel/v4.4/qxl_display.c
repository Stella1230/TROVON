static bool qxl_head_enabled(struct qxl_head *head)\r\n{\r\nreturn head->width && head->height;\r\n}\r\nvoid qxl_alloc_client_monitors_config(struct qxl_device *qdev, unsigned count)\r\n{\r\nif (qdev->client_monitors_config &&\r\ncount > qdev->client_monitors_config->count) {\r\nkfree(qdev->client_monitors_config);\r\nqdev->client_monitors_config = NULL;\r\n}\r\nif (!qdev->client_monitors_config) {\r\nqdev->client_monitors_config = kzalloc(\r\nsizeof(struct qxl_monitors_config) +\r\nsizeof(struct qxl_head) * count, GFP_KERNEL);\r\nif (!qdev->client_monitors_config) {\r\nqxl_io_log(qdev,\r\n"%s: allocation failure for %u heads\n",\r\n__func__, count);\r\nreturn;\r\n}\r\n}\r\nqdev->client_monitors_config->count = count;\r\n}\r\nstatic int qxl_display_copy_rom_client_monitors_config(struct qxl_device *qdev)\r\n{\r\nint i;\r\nint num_monitors;\r\nuint32_t crc;\r\nnum_monitors = qdev->rom->client_monitors_config.count;\r\ncrc = crc32(0, (const uint8_t *)&qdev->rom->client_monitors_config,\r\nsizeof(qdev->rom->client_monitors_config));\r\nif (crc != qdev->rom->client_monitors_config_crc) {\r\nqxl_io_log(qdev, "crc mismatch: have %X (%zd) != %X\n", crc,\r\nsizeof(qdev->rom->client_monitors_config),\r\nqdev->rom->client_monitors_config_crc);\r\nreturn 1;\r\n}\r\nif (num_monitors > qdev->monitors_config->max_allowed) {\r\nDRM_DEBUG_KMS("client monitors list will be truncated: %d < %d\n",\r\nqdev->monitors_config->max_allowed, num_monitors);\r\nnum_monitors = qdev->monitors_config->max_allowed;\r\n} else {\r\nnum_monitors = qdev->rom->client_monitors_config.count;\r\n}\r\nqxl_alloc_client_monitors_config(qdev, num_monitors);\r\nqdev->client_monitors_config->max_allowed =\r\nqdev->monitors_config->max_allowed;\r\nfor (i = 0 ; i < qdev->client_monitors_config->count ; ++i) {\r\nstruct qxl_urect *c_rect =\r\n&qdev->rom->client_monitors_config.heads[i];\r\nstruct qxl_head *client_head =\r\n&qdev->client_monitors_config->heads[i];\r\nclient_head->x = c_rect->left;\r\nclient_head->y = c_rect->top;\r\nclient_head->width = c_rect->right - c_rect->left;\r\nclient_head->height = c_rect->bottom - c_rect->top;\r\nclient_head->surface_id = 0;\r\nclient_head->id = i;\r\nclient_head->flags = 0;\r\nDRM_DEBUG_KMS("read %dx%d+%d+%d\n", client_head->width, client_head->height,\r\nclient_head->x, client_head->y);\r\n}\r\nreturn 0;\r\n}\r\nstatic void qxl_update_offset_props(struct qxl_device *qdev)\r\n{\r\nstruct drm_device *dev = qdev->ddev;\r\nstruct drm_connector *connector;\r\nstruct qxl_output *output;\r\nstruct qxl_head *head;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\noutput = drm_connector_to_qxl_output(connector);\r\nhead = &qdev->client_monitors_config->heads[output->index];\r\ndrm_object_property_set_value(&connector->base,\r\ndev->mode_config.suggested_x_property, head->x);\r\ndrm_object_property_set_value(&connector->base,\r\ndev->mode_config.suggested_y_property, head->y);\r\n}\r\n}\r\nvoid qxl_display_read_client_monitors_config(struct qxl_device *qdev)\r\n{\r\nstruct drm_device *dev = qdev->ddev;\r\nwhile (qxl_display_copy_rom_client_monitors_config(qdev)) {\r\nqxl_io_log(qdev, "failed crc check for client_monitors_config,"\r\n" retrying\n");\r\n}\r\ndrm_modeset_lock_all(dev);\r\nqxl_update_offset_props(qdev);\r\ndrm_modeset_unlock_all(dev);\r\nif (!drm_helper_hpd_irq_event(qdev->ddev)) {\r\ndrm_kms_helper_hotplug_event(qdev->ddev);\r\n}\r\n}\r\nstatic int qxl_add_monitors_config_modes(struct drm_connector *connector,\r\nunsigned *pwidth,\r\nunsigned *pheight)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct qxl_device *qdev = dev->dev_private;\r\nstruct qxl_output *output = drm_connector_to_qxl_output(connector);\r\nint h = output->index;\r\nstruct drm_display_mode *mode = NULL;\r\nstruct qxl_head *head;\r\nif (!qdev->client_monitors_config)\r\nreturn 0;\r\nhead = &qdev->client_monitors_config->heads[h];\r\nmode = drm_cvt_mode(dev, head->width, head->height, 60, false, false,\r\nfalse);\r\nmode->type |= DRM_MODE_TYPE_PREFERRED;\r\n*pwidth = head->width;\r\n*pheight = head->height;\r\ndrm_mode_probed_add(connector, mode);\r\nqdev->monitors_config_width = mode->hdisplay;\r\nqdev->monitors_config_height = mode->vdisplay;\r\nreturn 1;\r\n}\r\nstatic int qxl_add_common_modes(struct drm_connector *connector,\r\nunsigned pwidth,\r\nunsigned pheight)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_display_mode *mode = NULL;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(common_modes); i++) {\r\nmode = drm_cvt_mode(dev, common_modes[i].w, common_modes[i].h,\r\n60, false, false, false);\r\nif (common_modes[i].w == pwidth && common_modes[i].h == pheight)\r\nmode->type |= DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_probed_add(connector, mode);\r\n}\r\nreturn i - 1;\r\n}\r\nstatic void qxl_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nstruct qxl_crtc *qxl_crtc = to_qxl_crtc(crtc);\r\ndrm_crtc_cleanup(crtc);\r\nkfree(qxl_crtc);\r\n}\r\nstatic int qxl_crtc_page_flip(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nstruct drm_pending_vblank_event *event,\r\nuint32_t page_flip_flags)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct qxl_device *qdev = dev->dev_private;\r\nstruct qxl_crtc *qcrtc = to_qxl_crtc(crtc);\r\nstruct qxl_framebuffer *qfb_src = to_qxl_framebuffer(fb);\r\nstruct qxl_framebuffer *qfb_old = to_qxl_framebuffer(crtc->primary->fb);\r\nstruct qxl_bo *bo_old = gem_to_qxl_bo(qfb_old->obj);\r\nstruct qxl_bo *bo = gem_to_qxl_bo(qfb_src->obj);\r\nunsigned long flags;\r\nstruct drm_clip_rect norect = {\r\n.x1 = 0,\r\n.y1 = 0,\r\n.x2 = fb->width,\r\n.y2 = fb->height\r\n};\r\nint inc = 1;\r\nint one_clip_rect = 1;\r\nint ret = 0;\r\ncrtc->primary->fb = fb;\r\nbo_old->is_primary = false;\r\nbo->is_primary = true;\r\nret = qxl_bo_reserve(bo, false);\r\nif (ret)\r\nreturn ret;\r\nret = qxl_bo_pin(bo, bo->type, NULL);\r\nqxl_bo_unreserve(bo);\r\nif (ret)\r\nreturn ret;\r\nqxl_draw_dirty_fb(qdev, qfb_src, bo, 0, 0,\r\n&norect, one_clip_rect, inc);\r\ndrm_vblank_get(dev, qcrtc->index);\r\nif (event) {\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\ndrm_send_vblank_event(dev, qcrtc->index, event);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\ndrm_vblank_put(dev, qcrtc->index);\r\nret = qxl_bo_reserve(bo, false);\r\nif (!ret) {\r\nqxl_bo_unpin(bo);\r\nqxl_bo_unreserve(bo);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nqxl_hide_cursor(struct qxl_device *qdev)\r\n{\r\nstruct qxl_release *release;\r\nstruct qxl_cursor_cmd *cmd;\r\nint ret;\r\nret = qxl_alloc_release_reserved(qdev, sizeof(*cmd), QXL_RELEASE_CURSOR_CMD,\r\n&release, NULL);\r\nif (ret)\r\nreturn ret;\r\nret = qxl_release_reserve_list(release, true);\r\nif (ret) {\r\nqxl_release_free(qdev, release);\r\nreturn ret;\r\n}\r\ncmd = (struct qxl_cursor_cmd *)qxl_release_map(qdev, release);\r\ncmd->type = QXL_CURSOR_HIDE;\r\nqxl_release_unmap(qdev, release, &cmd->release_info);\r\nqxl_push_cursor_ring_release(qdev, release, QXL_CMD_CURSOR, false);\r\nqxl_release_fence_buffer_objects(release);\r\nreturn 0;\r\n}\r\nstatic int qxl_crtc_cursor_set2(struct drm_crtc *crtc,\r\nstruct drm_file *file_priv,\r\nuint32_t handle,\r\nuint32_t width,\r\nuint32_t height, int32_t hot_x, int32_t hot_y)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct qxl_device *qdev = dev->dev_private;\r\nstruct qxl_crtc *qcrtc = to_qxl_crtc(crtc);\r\nstruct drm_gem_object *obj;\r\nstruct qxl_cursor *cursor;\r\nstruct qxl_cursor_cmd *cmd;\r\nstruct qxl_bo *cursor_bo, *user_bo;\r\nstruct qxl_release *release;\r\nvoid *user_ptr;\r\nint size = 64*64*4;\r\nint ret = 0;\r\nif (!handle)\r\nreturn qxl_hide_cursor(qdev);\r\nobj = drm_gem_object_lookup(crtc->dev, file_priv, handle);\r\nif (!obj) {\r\nDRM_ERROR("cannot find cursor object\n");\r\nreturn -ENOENT;\r\n}\r\nuser_bo = gem_to_qxl_bo(obj);\r\nret = qxl_bo_reserve(user_bo, false);\r\nif (ret)\r\ngoto out_unref;\r\nret = qxl_bo_pin(user_bo, QXL_GEM_DOMAIN_CPU, NULL);\r\nqxl_bo_unreserve(user_bo);\r\nif (ret)\r\ngoto out_unref;\r\nret = qxl_bo_kmap(user_bo, &user_ptr);\r\nif (ret)\r\ngoto out_unpin;\r\nret = qxl_alloc_release_reserved(qdev, sizeof(*cmd),\r\nQXL_RELEASE_CURSOR_CMD,\r\n&release, NULL);\r\nif (ret)\r\ngoto out_kunmap;\r\nret = qxl_alloc_bo_reserved(qdev, release, sizeof(struct qxl_cursor) + size,\r\n&cursor_bo);\r\nif (ret)\r\ngoto out_free_release;\r\nret = qxl_release_reserve_list(release, false);\r\nif (ret)\r\ngoto out_free_bo;\r\nret = qxl_bo_kmap(cursor_bo, (void **)&cursor);\r\nif (ret)\r\ngoto out_backoff;\r\ncursor->header.unique = 0;\r\ncursor->header.type = SPICE_CURSOR_TYPE_ALPHA;\r\ncursor->header.width = 64;\r\ncursor->header.height = 64;\r\ncursor->header.hot_spot_x = hot_x;\r\ncursor->header.hot_spot_y = hot_y;\r\ncursor->data_size = size;\r\ncursor->chunk.next_chunk = 0;\r\ncursor->chunk.prev_chunk = 0;\r\ncursor->chunk.data_size = size;\r\nmemcpy(cursor->chunk.data, user_ptr, size);\r\nqxl_bo_kunmap(cursor_bo);\r\nqxl_bo_kunmap(user_bo);\r\ncmd = (struct qxl_cursor_cmd *)qxl_release_map(qdev, release);\r\ncmd->type = QXL_CURSOR_SET;\r\ncmd->u.set.position.x = qcrtc->cur_x;\r\ncmd->u.set.position.y = qcrtc->cur_y;\r\ncmd->u.set.shape = qxl_bo_physical_address(qdev, cursor_bo, 0);\r\ncmd->u.set.visible = 1;\r\nqxl_release_unmap(qdev, release, &cmd->release_info);\r\nqxl_push_cursor_ring_release(qdev, release, QXL_CMD_CURSOR, false);\r\nqxl_release_fence_buffer_objects(release);\r\nret = qxl_bo_reserve(user_bo, false);\r\nif (!ret) {\r\nqxl_bo_unpin(user_bo);\r\nqxl_bo_unreserve(user_bo);\r\n}\r\ndrm_gem_object_unreference_unlocked(obj);\r\nqxl_bo_unref(&cursor_bo);\r\nreturn ret;\r\nout_backoff:\r\nqxl_release_backoff_reserve_list(release);\r\nout_free_bo:\r\nqxl_bo_unref(&cursor_bo);\r\nout_free_release:\r\nqxl_release_free(qdev, release);\r\nout_kunmap:\r\nqxl_bo_kunmap(user_bo);\r\nout_unpin:\r\nqxl_bo_unpin(user_bo);\r\nout_unref:\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ret;\r\n}\r\nstatic int qxl_crtc_cursor_move(struct drm_crtc *crtc,\r\nint x, int y)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct qxl_device *qdev = dev->dev_private;\r\nstruct qxl_crtc *qcrtc = to_qxl_crtc(crtc);\r\nstruct qxl_release *release;\r\nstruct qxl_cursor_cmd *cmd;\r\nint ret;\r\nret = qxl_alloc_release_reserved(qdev, sizeof(*cmd), QXL_RELEASE_CURSOR_CMD,\r\n&release, NULL);\r\nif (ret)\r\nreturn ret;\r\nret = qxl_release_reserve_list(release, true);\r\nif (ret) {\r\nqxl_release_free(qdev, release);\r\nreturn ret;\r\n}\r\nqcrtc->cur_x = x;\r\nqcrtc->cur_y = y;\r\ncmd = (struct qxl_cursor_cmd *)qxl_release_map(qdev, release);\r\ncmd->type = QXL_CURSOR_MOVE;\r\ncmd->u.position.x = qcrtc->cur_x;\r\ncmd->u.position.y = qcrtc->cur_y;\r\nqxl_release_unmap(qdev, release, &cmd->release_info);\r\nqxl_push_cursor_ring_release(qdev, release, QXL_CMD_CURSOR, false);\r\nqxl_release_fence_buffer_objects(release);\r\nreturn 0;\r\n}\r\nstatic void qxl_user_framebuffer_destroy(struct drm_framebuffer *fb)\r\n{\r\nstruct qxl_framebuffer *qxl_fb = to_qxl_framebuffer(fb);\r\nif (qxl_fb->obj)\r\ndrm_gem_object_unreference_unlocked(qxl_fb->obj);\r\ndrm_framebuffer_cleanup(fb);\r\nkfree(qxl_fb);\r\n}\r\nstatic int qxl_framebuffer_surface_dirty(struct drm_framebuffer *fb,\r\nstruct drm_file *file_priv,\r\nunsigned flags, unsigned color,\r\nstruct drm_clip_rect *clips,\r\nunsigned num_clips)\r\n{\r\nstruct qxl_framebuffer *qxl_fb = to_qxl_framebuffer(fb);\r\nstruct qxl_device *qdev = qxl_fb->base.dev->dev_private;\r\nstruct drm_clip_rect norect;\r\nstruct qxl_bo *qobj;\r\nint inc = 1;\r\ndrm_modeset_lock_all(fb->dev);\r\nqobj = gem_to_qxl_bo(qxl_fb->obj);\r\nif (!qobj->is_primary) {\r\ndrm_modeset_unlock_all(fb->dev);\r\nreturn 0;\r\n}\r\nif (!num_clips) {\r\nnum_clips = 1;\r\nclips = &norect;\r\nnorect.x1 = norect.y1 = 0;\r\nnorect.x2 = fb->width;\r\nnorect.y2 = fb->height;\r\n} else if (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY) {\r\nnum_clips /= 2;\r\ninc = 2;\r\n}\r\nqxl_draw_dirty_fb(qdev, qxl_fb, qobj, flags, color,\r\nclips, num_clips, inc);\r\ndrm_modeset_unlock_all(fb->dev);\r\nreturn 0;\r\n}\r\nint\r\nqxl_framebuffer_init(struct drm_device *dev,\r\nstruct qxl_framebuffer *qfb,\r\nstruct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct drm_gem_object *obj)\r\n{\r\nint ret;\r\nqfb->obj = obj;\r\nret = drm_framebuffer_init(dev, &qfb->base, &qxl_fb_funcs);\r\nif (ret) {\r\nqfb->obj = NULL;\r\nreturn ret;\r\n}\r\ndrm_helper_mode_fill_fb_struct(&qfb->base, mode_cmd);\r\nreturn 0;\r\n}\r\nstatic void qxl_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\n}\r\nstatic bool qxl_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct qxl_device *qdev = dev->dev_private;\r\nqxl_io_log(qdev, "%s: (%d,%d) => (%d,%d)\n",\r\n__func__,\r\nmode->hdisplay, mode->vdisplay,\r\nadjusted_mode->hdisplay,\r\nadjusted_mode->vdisplay);\r\nreturn true;\r\n}\r\nvoid\r\nqxl_send_monitors_config(struct qxl_device *qdev)\r\n{\r\nint i;\r\nBUG_ON(!qdev->ram_header->monitors_config);\r\nif (qdev->monitors_config->count == 0) {\r\nqxl_io_log(qdev, "%s: 0 monitors??\n", __func__);\r\nreturn;\r\n}\r\nfor (i = 0 ; i < qdev->monitors_config->count ; ++i) {\r\nstruct qxl_head *head = &qdev->monitors_config->heads[i];\r\nif (head->y > 8192 || head->x > 8192 ||\r\nhead->width > 8192 || head->height > 8192) {\r\nDRM_ERROR("head %d wrong: %dx%d+%d+%d\n",\r\ni, head->width, head->height,\r\nhead->x, head->y);\r\nreturn;\r\n}\r\n}\r\nqxl_io_monitors_config(qdev);\r\n}\r\nstatic void qxl_monitors_config_set(struct qxl_device *qdev,\r\nint index,\r\nunsigned x, unsigned y,\r\nunsigned width, unsigned height,\r\nunsigned surf_id)\r\n{\r\nDRM_DEBUG_KMS("%d:%dx%d+%d+%d\n", index, width, height, x, y);\r\nqdev->monitors_config->heads[index].x = x;\r\nqdev->monitors_config->heads[index].y = y;\r\nqdev->monitors_config->heads[index].width = width;\r\nqdev->monitors_config->heads[index].height = height;\r\nqdev->monitors_config->heads[index].surface_id = surf_id;\r\n}\r\nstatic int qxl_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct qxl_device *qdev = dev->dev_private;\r\nstruct qxl_framebuffer *qfb;\r\nstruct qxl_bo *bo, *old_bo = NULL;\r\nstruct qxl_crtc *qcrtc = to_qxl_crtc(crtc);\r\nbool recreate_primary = false;\r\nint ret;\r\nint surf_id;\r\nif (!crtc->primary->fb) {\r\nDRM_DEBUG_KMS("No FB bound\n");\r\nreturn 0;\r\n}\r\nif (old_fb) {\r\nqfb = to_qxl_framebuffer(old_fb);\r\nold_bo = gem_to_qxl_bo(qfb->obj);\r\n}\r\nqfb = to_qxl_framebuffer(crtc->primary->fb);\r\nbo = gem_to_qxl_bo(qfb->obj);\r\nDRM_DEBUG("+%d+%d (%d,%d) => (%d,%d)\n",\r\nx, y,\r\nmode->hdisplay, mode->vdisplay,\r\nadjusted_mode->hdisplay,\r\nadjusted_mode->vdisplay);\r\nif (bo->is_primary == false)\r\nrecreate_primary = true;\r\nif (bo->surf.stride * bo->surf.height > qdev->vram_size) {\r\nDRM_ERROR("Mode doesn't fit in vram size (vgamem)");\r\nreturn -EINVAL;\r\n}\r\nret = qxl_bo_reserve(bo, false);\r\nif (ret != 0)\r\nreturn ret;\r\nret = qxl_bo_pin(bo, bo->type, NULL);\r\nif (ret != 0) {\r\nqxl_bo_unreserve(bo);\r\nreturn -EINVAL;\r\n}\r\nqxl_bo_unreserve(bo);\r\nif (recreate_primary) {\r\nqxl_io_destroy_primary(qdev);\r\nqxl_io_log(qdev,\r\n"recreate primary: %dx%d,%d,%d\n",\r\nbo->surf.width, bo->surf.height,\r\nbo->surf.stride, bo->surf.format);\r\nqxl_io_create_primary(qdev, 0, bo);\r\nbo->is_primary = true;\r\n}\r\nif (bo->is_primary) {\r\nDRM_DEBUG_KMS("setting surface_id to 0 for primary surface %d on crtc %d\n", bo->surface_id, qcrtc->index);\r\nsurf_id = 0;\r\n} else {\r\nsurf_id = bo->surface_id;\r\n}\r\nif (old_bo && old_bo != bo) {\r\nold_bo->is_primary = false;\r\nret = qxl_bo_reserve(old_bo, false);\r\nqxl_bo_unpin(old_bo);\r\nqxl_bo_unreserve(old_bo);\r\n}\r\nqxl_monitors_config_set(qdev, qcrtc->index, x, y,\r\nmode->hdisplay,\r\nmode->vdisplay, surf_id);\r\nreturn 0;\r\n}\r\nstatic void qxl_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\nDRM_DEBUG("current: %dx%d+%d+%d (%d).\n",\r\ncrtc->mode.hdisplay, crtc->mode.vdisplay,\r\ncrtc->x, crtc->y, crtc->enabled);\r\n}\r\nstatic void qxl_crtc_commit(struct drm_crtc *crtc)\r\n{\r\nDRM_DEBUG("\n");\r\n}\r\nstatic void qxl_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct qxl_crtc *qcrtc = to_qxl_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct qxl_device *qdev = dev->dev_private;\r\nif (crtc->primary->fb) {\r\nstruct qxl_framebuffer *qfb = to_qxl_framebuffer(crtc->primary->fb);\r\nstruct qxl_bo *bo = gem_to_qxl_bo(qfb->obj);\r\nint ret;\r\nret = qxl_bo_reserve(bo, false);\r\nqxl_bo_unpin(bo);\r\nqxl_bo_unreserve(bo);\r\ncrtc->primary->fb = NULL;\r\n}\r\nqxl_monitors_config_set(qdev, qcrtc->index, 0, 0, 0, 0, 0);\r\nqxl_send_monitors_config(qdev);\r\n}\r\nstatic int qdev_crtc_init(struct drm_device *dev, int crtc_id)\r\n{\r\nstruct qxl_crtc *qxl_crtc;\r\nqxl_crtc = kzalloc(sizeof(struct qxl_crtc), GFP_KERNEL);\r\nif (!qxl_crtc)\r\nreturn -ENOMEM;\r\ndrm_crtc_init(dev, &qxl_crtc->base, &qxl_crtc_funcs);\r\nqxl_crtc->index = crtc_id;\r\ndrm_mode_crtc_set_gamma_size(&qxl_crtc->base, 256);\r\ndrm_crtc_helper_add(&qxl_crtc->base, &qxl_crtc_helper_funcs);\r\nreturn 0;\r\n}\r\nstatic void qxl_enc_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nDRM_DEBUG("\n");\r\n}\r\nstatic bool qxl_enc_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nDRM_DEBUG("\n");\r\nreturn true;\r\n}\r\nstatic void qxl_enc_prepare(struct drm_encoder *encoder)\r\n{\r\nDRM_DEBUG("\n");\r\n}\r\nstatic void qxl_write_monitors_config_for_encoder(struct qxl_device *qdev,\r\nstruct drm_encoder *encoder)\r\n{\r\nint i;\r\nstruct qxl_output *output = drm_encoder_to_qxl_output(encoder);\r\nstruct qxl_head *head;\r\nstruct drm_display_mode *mode;\r\nBUG_ON(!encoder);\r\ni = output->index;\r\nif (!qdev->monitors_config ||\r\nqdev->monitors_config->max_allowed <= i) {\r\nDRM_ERROR(\r\n"head number too large or missing monitors config: %p, %d",\r\nqdev->monitors_config,\r\nqdev->monitors_config ?\r\nqdev->monitors_config->max_allowed : -1);\r\nreturn;\r\n}\r\nif (!encoder->crtc) {\r\nDRM_ERROR("missing crtc on encoder %p\n", encoder);\r\nreturn;\r\n}\r\nif (i != 0)\r\nDRM_DEBUG("missing for multiple monitors: no head holes\n");\r\nhead = &qdev->monitors_config->heads[i];\r\nhead->id = i;\r\nif (encoder->crtc->enabled) {\r\nmode = &encoder->crtc->mode;\r\nhead->width = mode->hdisplay;\r\nhead->height = mode->vdisplay;\r\nhead->x = encoder->crtc->x;\r\nhead->y = encoder->crtc->y;\r\nif (qdev->monitors_config->count < i + 1)\r\nqdev->monitors_config->count = i + 1;\r\n} else {\r\nhead->width = 0;\r\nhead->height = 0;\r\nhead->x = 0;\r\nhead->y = 0;\r\n}\r\nDRM_DEBUG_KMS("setting head %d to +%d+%d %dx%d out of %d\n",\r\ni, head->x, head->y, head->width, head->height, qdev->monitors_config->count);\r\nhead->flags = 0;\r\nqxl_send_monitors_config(qdev);\r\n}\r\nstatic void qxl_enc_commit(struct drm_encoder *encoder)\r\n{\r\nstruct qxl_device *qdev = encoder->dev->dev_private;\r\nqxl_write_monitors_config_for_encoder(qdev, encoder);\r\nDRM_DEBUG("\n");\r\n}\r\nstatic void qxl_enc_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nDRM_DEBUG("\n");\r\n}\r\nstatic int qxl_conn_get_modes(struct drm_connector *connector)\r\n{\r\nint ret = 0;\r\nstruct qxl_device *qdev = connector->dev->dev_private;\r\nunsigned pwidth = 1024;\r\nunsigned pheight = 768;\r\nDRM_DEBUG_KMS("monitors_config=%p\n", qdev->monitors_config);\r\nif (qdev->monitors_config && qdev->monitors_config->count) {\r\nret = qxl_add_monitors_config_modes(connector, &pwidth, &pheight);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret += qxl_add_common_modes(connector, pwidth, pheight);\r\nreturn ret;\r\n}\r\nstatic int qxl_conn_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct drm_device *ddev = connector->dev;\r\nstruct qxl_device *qdev = ddev->dev_private;\r\nint i;\r\nif(qdev->monitors_config_width == mode->hdisplay &&\r\nqdev->monitors_config_height == mode->vdisplay)\r\nreturn MODE_OK;\r\nfor (i = 0; i < ARRAY_SIZE(common_modes); i++) {\r\nif (common_modes[i].w == mode->hdisplay && common_modes[i].h == mode->vdisplay)\r\nreturn MODE_OK;\r\n}\r\nreturn MODE_BAD;\r\n}\r\nstatic struct drm_encoder *qxl_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct qxl_output *qxl_output =\r\ndrm_connector_to_qxl_output(connector);\r\nDRM_DEBUG("\n");\r\nreturn &qxl_output->enc;\r\n}\r\nstatic void qxl_conn_save(struct drm_connector *connector)\r\n{\r\nDRM_DEBUG("\n");\r\n}\r\nstatic void qxl_conn_restore(struct drm_connector *connector)\r\n{\r\nDRM_DEBUG("\n");\r\n}\r\nstatic enum drm_connector_status qxl_conn_detect(\r\nstruct drm_connector *connector,\r\nbool force)\r\n{\r\nstruct qxl_output *output =\r\ndrm_connector_to_qxl_output(connector);\r\nstruct drm_device *ddev = connector->dev;\r\nstruct qxl_device *qdev = ddev->dev_private;\r\nbool connected = false;\r\nif (!qdev->client_monitors_config) {\r\nif (output->index == 0)\r\nconnected = true;\r\n} else\r\nconnected = qdev->client_monitors_config->count > output->index &&\r\nqxl_head_enabled(&qdev->client_monitors_config->heads[output->index]);\r\nDRM_DEBUG("#%d connected: %d\n", output->index, connected);\r\nif (!connected)\r\nqxl_monitors_config_set(qdev, output->index, 0, 0, 0, 0, 0);\r\nreturn connected ? connector_status_connected\r\n: connector_status_disconnected;\r\n}\r\nstatic int qxl_conn_set_property(struct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t value)\r\n{\r\nDRM_DEBUG("\n");\r\nreturn 0;\r\n}\r\nstatic void qxl_conn_destroy(struct drm_connector *connector)\r\n{\r\nstruct qxl_output *qxl_output =\r\ndrm_connector_to_qxl_output(connector);\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(qxl_output);\r\n}\r\nstatic void qxl_enc_destroy(struct drm_encoder *encoder)\r\n{\r\ndrm_encoder_cleanup(encoder);\r\n}\r\nstatic int qxl_mode_create_hotplug_mode_update_property(struct qxl_device *qdev)\r\n{\r\nif (qdev->hotplug_mode_update_property)\r\nreturn 0;\r\nqdev->hotplug_mode_update_property =\r\ndrm_property_create_range(qdev->ddev, DRM_MODE_PROP_IMMUTABLE,\r\n"hotplug_mode_update", 0, 1);\r\nreturn 0;\r\n}\r\nstatic int qdev_output_init(struct drm_device *dev, int num_output)\r\n{\r\nstruct qxl_device *qdev = dev->dev_private;\r\nstruct qxl_output *qxl_output;\r\nstruct drm_connector *connector;\r\nstruct drm_encoder *encoder;\r\nqxl_output = kzalloc(sizeof(struct qxl_output), GFP_KERNEL);\r\nif (!qxl_output)\r\nreturn -ENOMEM;\r\nqxl_output->index = num_output;\r\nconnector = &qxl_output->base;\r\nencoder = &qxl_output->enc;\r\ndrm_connector_init(dev, &qxl_output->base,\r\n&qxl_connector_funcs, DRM_MODE_CONNECTOR_VIRTUAL);\r\ndrm_encoder_init(dev, &qxl_output->enc, &qxl_enc_funcs,\r\nDRM_MODE_ENCODER_VIRTUAL);\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\nencoder->possible_crtcs = 1 << num_output;\r\ndrm_mode_connector_attach_encoder(&qxl_output->base,\r\n&qxl_output->enc);\r\ndrm_encoder_helper_add(encoder, &qxl_enc_helper_funcs);\r\ndrm_connector_helper_add(connector, &qxl_connector_helper_funcs);\r\ndrm_object_attach_property(&connector->base,\r\nqdev->hotplug_mode_update_property, 0);\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.suggested_x_property, 0);\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.suggested_y_property, 0);\r\ndrm_connector_register(connector);\r\nreturn 0;\r\n}\r\nstatic struct drm_framebuffer *\r\nqxl_user_framebuffer_create(struct drm_device *dev,\r\nstruct drm_file *file_priv,\r\nstruct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nstruct drm_gem_object *obj;\r\nstruct qxl_framebuffer *qxl_fb;\r\nint ret;\r\nobj = drm_gem_object_lookup(dev, file_priv, mode_cmd->handles[0]);\r\nqxl_fb = kzalloc(sizeof(*qxl_fb), GFP_KERNEL);\r\nif (qxl_fb == NULL)\r\nreturn NULL;\r\nret = qxl_framebuffer_init(dev, qxl_fb, mode_cmd, obj);\r\nif (ret) {\r\nkfree(qxl_fb);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn NULL;\r\n}\r\nreturn &qxl_fb->base;\r\n}\r\nint qxl_create_monitors_object(struct qxl_device *qdev)\r\n{\r\nint ret;\r\nstruct drm_gem_object *gobj;\r\nint max_allowed = qxl_num_crtc;\r\nint monitors_config_size = sizeof(struct qxl_monitors_config) +\r\nmax_allowed * sizeof(struct qxl_head);\r\nret = qxl_gem_object_create(qdev, monitors_config_size, 0,\r\nQXL_GEM_DOMAIN_VRAM,\r\nfalse, false, NULL, &gobj);\r\nif (ret) {\r\nDRM_ERROR("%s: failed to create gem ret=%d\n", __func__, ret);\r\nreturn -ENOMEM;\r\n}\r\nqdev->monitors_config_bo = gem_to_qxl_bo(gobj);\r\nret = qxl_bo_reserve(qdev->monitors_config_bo, false);\r\nif (ret)\r\nreturn ret;\r\nret = qxl_bo_pin(qdev->monitors_config_bo, QXL_GEM_DOMAIN_VRAM, NULL);\r\nif (ret) {\r\nqxl_bo_unreserve(qdev->monitors_config_bo);\r\nreturn ret;\r\n}\r\nqxl_bo_unreserve(qdev->monitors_config_bo);\r\nqxl_bo_kmap(qdev->monitors_config_bo, NULL);\r\nqdev->monitors_config = qdev->monitors_config_bo->kptr;\r\nqdev->ram_header->monitors_config =\r\nqxl_bo_physical_address(qdev, qdev->monitors_config_bo, 0);\r\nmemset(qdev->monitors_config, 0, monitors_config_size);\r\nqdev->monitors_config->max_allowed = max_allowed;\r\nreturn 0;\r\n}\r\nint qxl_destroy_monitors_object(struct qxl_device *qdev)\r\n{\r\nint ret;\r\nqdev->monitors_config = NULL;\r\nqdev->ram_header->monitors_config = 0;\r\nqxl_bo_kunmap(qdev->monitors_config_bo);\r\nret = qxl_bo_reserve(qdev->monitors_config_bo, false);\r\nif (ret)\r\nreturn ret;\r\nqxl_bo_unpin(qdev->monitors_config_bo);\r\nqxl_bo_unreserve(qdev->monitors_config_bo);\r\nqxl_bo_unref(&qdev->monitors_config_bo);\r\nreturn 0;\r\n}\r\nint qxl_modeset_init(struct qxl_device *qdev)\r\n{\r\nint i;\r\nint ret;\r\ndrm_mode_config_init(qdev->ddev);\r\nret = qxl_create_monitors_object(qdev);\r\nif (ret)\r\nreturn ret;\r\nqdev->ddev->mode_config.funcs = (void *)&qxl_mode_funcs;\r\nqdev->ddev->mode_config.min_width = 320;\r\nqdev->ddev->mode_config.min_height = 200;\r\nqdev->ddev->mode_config.max_width = 8192;\r\nqdev->ddev->mode_config.max_height = 8192;\r\nqdev->ddev->mode_config.fb_base = qdev->vram_base;\r\ndrm_mode_create_suggested_offset_properties(qdev->ddev);\r\nqxl_mode_create_hotplug_mode_update_property(qdev);\r\nfor (i = 0 ; i < qxl_num_crtc; ++i) {\r\nqdev_crtc_init(qdev->ddev, i);\r\nqdev_output_init(qdev->ddev, i);\r\n}\r\nqdev->mode_info.mode_config_initialized = true;\r\nqxl_fbdev_init(qdev);\r\nreturn 0;\r\n}\r\nvoid qxl_modeset_fini(struct qxl_device *qdev)\r\n{\r\nqxl_fbdev_fini(qdev);\r\nqxl_destroy_monitors_object(qdev);\r\nif (qdev->mode_info.mode_config_initialized) {\r\ndrm_mode_config_cleanup(qdev->ddev);\r\nqdev->mode_info.mode_config_initialized = false;\r\n}\r\n}
