static inline u32 nft_hash_key(const void *data, u32 len, u32 seed)\r\n{\r\nconst struct nft_hash_cmp_arg *arg = data;\r\nreturn jhash(arg->key, len, seed);\r\n}\r\nstatic inline u32 nft_hash_obj(const void *data, u32 len, u32 seed)\r\n{\r\nconst struct nft_hash_elem *he = data;\r\nreturn jhash(nft_set_ext_key(&he->ext), len, seed);\r\n}\r\nstatic inline int nft_hash_cmp(struct rhashtable_compare_arg *arg,\r\nconst void *ptr)\r\n{\r\nconst struct nft_hash_cmp_arg *x = arg->key;\r\nconst struct nft_hash_elem *he = ptr;\r\nif (memcmp(nft_set_ext_key(&he->ext), x->key, x->set->klen))\r\nreturn 1;\r\nif (nft_set_elem_expired(&he->ext))\r\nreturn 1;\r\nif (!nft_set_elem_active(&he->ext, x->genmask))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic bool nft_hash_lookup(const struct nft_set *set, const u32 *key,\r\nconst struct nft_set_ext **ext)\r\n{\r\nstruct nft_hash *priv = nft_set_priv(set);\r\nconst struct nft_hash_elem *he;\r\nstruct nft_hash_cmp_arg arg = {\r\n.genmask = nft_genmask_cur(read_pnet(&set->pnet)),\r\n.set = set,\r\n.key = key,\r\n};\r\nhe = rhashtable_lookup_fast(&priv->ht, &arg, nft_hash_params);\r\nif (he != NULL)\r\n*ext = &he->ext;\r\nreturn !!he;\r\n}\r\nstatic bool nft_hash_update(struct nft_set *set, const u32 *key,\r\nvoid *(*new)(struct nft_set *,\r\nconst struct nft_expr *,\r\nstruct nft_regs *regs),\r\nconst struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_set_ext **ext)\r\n{\r\nstruct nft_hash *priv = nft_set_priv(set);\r\nstruct nft_hash_elem *he;\r\nstruct nft_hash_cmp_arg arg = {\r\n.genmask = NFT_GENMASK_ANY,\r\n.set = set,\r\n.key = key,\r\n};\r\nhe = rhashtable_lookup_fast(&priv->ht, &arg, nft_hash_params);\r\nif (he != NULL)\r\ngoto out;\r\nhe = new(set, expr, regs);\r\nif (he == NULL)\r\ngoto err1;\r\nif (rhashtable_lookup_insert_key(&priv->ht, &arg, &he->node,\r\nnft_hash_params))\r\ngoto err2;\r\nout:\r\n*ext = &he->ext;\r\nreturn true;\r\nerr2:\r\nnft_set_elem_destroy(set, he);\r\nerr1:\r\nreturn false;\r\n}\r\nstatic int nft_hash_insert(const struct nft_set *set,\r\nconst struct nft_set_elem *elem)\r\n{\r\nstruct nft_hash *priv = nft_set_priv(set);\r\nstruct nft_hash_elem *he = elem->priv;\r\nstruct nft_hash_cmp_arg arg = {\r\n.genmask = nft_genmask_next(read_pnet(&set->pnet)),\r\n.set = set,\r\n.key = elem->key.val.data,\r\n};\r\nreturn rhashtable_lookup_insert_key(&priv->ht, &arg, &he->node,\r\nnft_hash_params);\r\n}\r\nstatic void nft_hash_activate(const struct nft_set *set,\r\nconst struct nft_set_elem *elem)\r\n{\r\nstruct nft_hash_elem *he = elem->priv;\r\nnft_set_elem_change_active(set, &he->ext);\r\nnft_set_elem_clear_busy(&he->ext);\r\n}\r\nstatic void *nft_hash_deactivate(const struct nft_set *set,\r\nconst struct nft_set_elem *elem)\r\n{\r\nstruct nft_hash *priv = nft_set_priv(set);\r\nstruct nft_hash_elem *he;\r\nstruct nft_hash_cmp_arg arg = {\r\n.genmask = nft_genmask_next(read_pnet(&set->pnet)),\r\n.set = set,\r\n.key = elem->key.val.data,\r\n};\r\nrcu_read_lock();\r\nhe = rhashtable_lookup_fast(&priv->ht, &arg, nft_hash_params);\r\nif (he != NULL) {\r\nif (!nft_set_elem_mark_busy(&he->ext))\r\nnft_set_elem_change_active(set, &he->ext);\r\nelse\r\nhe = NULL;\r\n}\r\nrcu_read_unlock();\r\nreturn he;\r\n}\r\nstatic void nft_hash_remove(const struct nft_set *set,\r\nconst struct nft_set_elem *elem)\r\n{\r\nstruct nft_hash *priv = nft_set_priv(set);\r\nstruct nft_hash_elem *he = elem->priv;\r\nrhashtable_remove_fast(&priv->ht, &he->node, nft_hash_params);\r\n}\r\nstatic void nft_hash_walk(const struct nft_ctx *ctx, const struct nft_set *set,\r\nstruct nft_set_iter *iter)\r\n{\r\nstruct nft_hash *priv = nft_set_priv(set);\r\nstruct nft_hash_elem *he;\r\nstruct rhashtable_iter hti;\r\nstruct nft_set_elem elem;\r\nu8 genmask = nft_genmask_cur(read_pnet(&set->pnet));\r\nint err;\r\nerr = rhashtable_walk_init(&priv->ht, &hti);\r\niter->err = err;\r\nif (err)\r\nreturn;\r\nerr = rhashtable_walk_start(&hti);\r\nif (err && err != -EAGAIN) {\r\niter->err = err;\r\ngoto out;\r\n}\r\nwhile ((he = rhashtable_walk_next(&hti))) {\r\nif (IS_ERR(he)) {\r\nerr = PTR_ERR(he);\r\nif (err != -EAGAIN) {\r\niter->err = err;\r\ngoto out;\r\n}\r\ncontinue;\r\n}\r\nif (iter->count < iter->skip)\r\ngoto cont;\r\nif (nft_set_elem_expired(&he->ext))\r\ngoto cont;\r\nif (!nft_set_elem_active(&he->ext, genmask))\r\ngoto cont;\r\nelem.priv = he;\r\niter->err = iter->fn(ctx, set, iter, &elem);\r\nif (iter->err < 0)\r\ngoto out;\r\ncont:\r\niter->count++;\r\n}\r\nout:\r\nrhashtable_walk_stop(&hti);\r\nrhashtable_walk_exit(&hti);\r\n}\r\nstatic void nft_hash_gc(struct work_struct *work)\r\n{\r\nstruct nft_set *set;\r\nstruct nft_hash_elem *he;\r\nstruct nft_hash *priv;\r\nstruct nft_set_gc_batch *gcb = NULL;\r\nstruct rhashtable_iter hti;\r\nint err;\r\npriv = container_of(work, struct nft_hash, gc_work.work);\r\nset = nft_set_container_of(priv);\r\nerr = rhashtable_walk_init(&priv->ht, &hti);\r\nif (err)\r\ngoto schedule;\r\nerr = rhashtable_walk_start(&hti);\r\nif (err && err != -EAGAIN)\r\ngoto out;\r\nwhile ((he = rhashtable_walk_next(&hti))) {\r\nif (IS_ERR(he)) {\r\nif (PTR_ERR(he) != -EAGAIN)\r\ngoto out;\r\ncontinue;\r\n}\r\nif (!nft_set_elem_expired(&he->ext))\r\ncontinue;\r\nif (nft_set_elem_mark_busy(&he->ext))\r\ncontinue;\r\ngcb = nft_set_gc_batch_check(set, gcb, GFP_ATOMIC);\r\nif (gcb == NULL)\r\ngoto out;\r\nrhashtable_remove_fast(&priv->ht, &he->node, nft_hash_params);\r\natomic_dec(&set->nelems);\r\nnft_set_gc_batch_add(gcb, he);\r\n}\r\nout:\r\nrhashtable_walk_stop(&hti);\r\nrhashtable_walk_exit(&hti);\r\nnft_set_gc_batch_complete(gcb);\r\nschedule:\r\nqueue_delayed_work(system_power_efficient_wq, &priv->gc_work,\r\nnft_set_gc_interval(set));\r\n}\r\nstatic unsigned int nft_hash_privsize(const struct nlattr * const nla[])\r\n{\r\nreturn sizeof(struct nft_hash);\r\n}\r\nstatic int nft_hash_init(const struct nft_set *set,\r\nconst struct nft_set_desc *desc,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_hash *priv = nft_set_priv(set);\r\nstruct rhashtable_params params = nft_hash_params;\r\nint err;\r\nparams.nelem_hint = desc->size ?: NFT_HASH_ELEMENT_HINT;\r\nparams.key_len = set->klen;\r\nerr = rhashtable_init(&priv->ht, &params);\r\nif (err < 0)\r\nreturn err;\r\nINIT_DEFERRABLE_WORK(&priv->gc_work, nft_hash_gc);\r\nif (set->flags & NFT_SET_TIMEOUT)\r\nqueue_delayed_work(system_power_efficient_wq, &priv->gc_work,\r\nnft_set_gc_interval(set));\r\nreturn 0;\r\n}\r\nstatic void nft_hash_elem_destroy(void *ptr, void *arg)\r\n{\r\nnft_set_elem_destroy((const struct nft_set *)arg, ptr);\r\n}\r\nstatic void nft_hash_destroy(const struct nft_set *set)\r\n{\r\nstruct nft_hash *priv = nft_set_priv(set);\r\ncancel_delayed_work_sync(&priv->gc_work);\r\nrhashtable_free_and_destroy(&priv->ht, nft_hash_elem_destroy,\r\n(void *)set);\r\n}\r\nstatic bool nft_hash_estimate(const struct nft_set_desc *desc, u32 features,\r\nstruct nft_set_estimate *est)\r\n{\r\nunsigned int esize;\r\nesize = sizeof(struct nft_hash_elem);\r\nif (desc->size) {\r\nest->size = sizeof(struct nft_hash) +\r\nroundup_pow_of_two(desc->size * 4 / 3) *\r\nsizeof(struct nft_hash_elem *) +\r\ndesc->size * esize;\r\n} else {\r\nest->size = esize + 2 * sizeof(struct nft_hash_elem *);\r\n}\r\nest->class = NFT_SET_CLASS_O_1;\r\nreturn true;\r\n}\r\nstatic int __init nft_hash_module_init(void)\r\n{\r\nreturn nft_register_set(&nft_hash_ops);\r\n}\r\nstatic void __exit nft_hash_module_exit(void)\r\n{\r\nnft_unregister_set(&nft_hash_ops);\r\n}
