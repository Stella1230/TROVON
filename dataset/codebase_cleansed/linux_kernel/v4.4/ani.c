static void ath9k_hw_update_mibstats(struct ath_hw *ah,\r\nstruct ath9k_mib_stats *stats)\r\n{\r\nu32 addr[5] = {AR_RTS_OK, AR_RTS_FAIL, AR_ACK_FAIL,\r\nAR_FCS_FAIL, AR_BEACON_CNT};\r\nu32 data[5];\r\nREG_READ_MULTI(ah, &addr[0], &data[0], 5);\r\nstats->rts_good += data[0];\r\nstats->rts_bad += data[1];\r\nstats->ackrcv_bad += data[2];\r\nstats->fcs_bad += data[3];\r\nstats->beacons += data[4];\r\n}\r\nstatic void ath9k_ani_restart(struct ath_hw *ah)\r\n{\r\nstruct ar5416AniState *aniState;\r\nif (!ah->curchan)\r\nreturn;\r\naniState = &ah->ani;\r\naniState->listenTime = 0;\r\nENABLE_REGWRITE_BUFFER(ah);\r\nREG_WRITE(ah, AR_PHY_ERR_1, 0);\r\nREG_WRITE(ah, AR_PHY_ERR_2, 0);\r\nREG_WRITE(ah, AR_PHY_ERR_MASK_1, AR_PHY_ERR_OFDM_TIMING);\r\nREG_WRITE(ah, AR_PHY_ERR_MASK_2, AR_PHY_ERR_CCK_TIMING);\r\nREGWRITE_BUFFER_FLUSH(ah);\r\nath9k_hw_update_mibstats(ah, &ah->ah_mibStats);\r\naniState->ofdmPhyErrCount = 0;\r\naniState->cckPhyErrCount = 0;\r\n}\r\nstatic void ath9k_hw_set_ofdm_nil(struct ath_hw *ah, u8 immunityLevel,\r\nbool scan)\r\n{\r\nstruct ar5416AniState *aniState = &ah->ani;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nconst struct ani_ofdm_level_entry *entry_ofdm;\r\nconst struct ani_cck_level_entry *entry_cck;\r\nbool weak_sig;\r\nath_dbg(common, ANI, "**** ofdmlevel %d=>%d, rssi=%d[lo=%d hi=%d]\n",\r\naniState->ofdmNoiseImmunityLevel,\r\nimmunityLevel, BEACON_RSSI(ah),\r\nATH9K_ANI_RSSI_THR_LOW,\r\nATH9K_ANI_RSSI_THR_HIGH);\r\nif (AR_SREV_9100(ah) && immunityLevel < ATH9K_ANI_OFDM_DEF_LEVEL)\r\nimmunityLevel = ATH9K_ANI_OFDM_DEF_LEVEL;\r\nif (!scan)\r\naniState->ofdmNoiseImmunityLevel = immunityLevel;\r\nentry_ofdm = &ofdm_level_table[aniState->ofdmNoiseImmunityLevel];\r\nentry_cck = &cck_level_table[aniState->cckNoiseImmunityLevel];\r\nif (aniState->spurImmunityLevel != entry_ofdm->spur_immunity_level)\r\nath9k_hw_ani_control(ah,\r\nATH9K_ANI_SPUR_IMMUNITY_LEVEL,\r\nentry_ofdm->spur_immunity_level);\r\nif (aniState->firstepLevel != entry_ofdm->fir_step_level &&\r\nentry_ofdm->fir_step_level >= entry_cck->fir_step_level)\r\nath9k_hw_ani_control(ah,\r\nATH9K_ANI_FIRSTEP_LEVEL,\r\nentry_ofdm->fir_step_level);\r\nweak_sig = entry_ofdm->ofdm_weak_signal_on;\r\nif (ah->opmode == NL80211_IFTYPE_STATION &&\r\nBEACON_RSSI(ah) <= ATH9K_ANI_RSSI_THR_HIGH)\r\nweak_sig = true;\r\nelse if (AR_SREV_9300_20_OR_LATER(ah) &&\r\nah->opmode != NL80211_IFTYPE_STATION)\r\nweak_sig = true;\r\nelse if (!AR_SREV_9300_20_OR_LATER(ah) &&\r\naniState->ofdmNoiseImmunityLevel >= 8)\r\nweak_sig = false;\r\nif (aniState->ofdmWeakSigDetect != weak_sig)\r\nath9k_hw_ani_control(ah, ATH9K_ANI_OFDM_WEAK_SIGNAL_DETECTION,\r\nweak_sig);\r\nif (!AR_SREV_9300_20_OR_LATER(ah))\r\nreturn;\r\nif (aniState->ofdmNoiseImmunityLevel >= ATH9K_ANI_OFDM_DEF_LEVEL) {\r\nah->config.ofdm_trig_high = ATH9K_ANI_OFDM_TRIG_HIGH;\r\nah->config.ofdm_trig_low = ATH9K_ANI_OFDM_TRIG_LOW_ABOVE_INI;\r\n} else {\r\nah->config.ofdm_trig_high = ATH9K_ANI_OFDM_TRIG_HIGH_BELOW_INI;\r\nah->config.ofdm_trig_low = ATH9K_ANI_OFDM_TRIG_LOW;\r\n}\r\n}\r\nstatic void ath9k_hw_ani_ofdm_err_trigger(struct ath_hw *ah)\r\n{\r\nstruct ar5416AniState *aniState;\r\nif (!ah->curchan)\r\nreturn;\r\naniState = &ah->ani;\r\nif (aniState->ofdmNoiseImmunityLevel < ATH9K_ANI_OFDM_MAX_LEVEL)\r\nath9k_hw_set_ofdm_nil(ah, aniState->ofdmNoiseImmunityLevel + 1, false);\r\n}\r\nstatic void ath9k_hw_set_cck_nil(struct ath_hw *ah, u_int8_t immunityLevel,\r\nbool scan)\r\n{\r\nstruct ar5416AniState *aniState = &ah->ani;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nconst struct ani_ofdm_level_entry *entry_ofdm;\r\nconst struct ani_cck_level_entry *entry_cck;\r\nath_dbg(common, ANI, "**** ccklevel %d=>%d, rssi=%d[lo=%d hi=%d]\n",\r\naniState->cckNoiseImmunityLevel, immunityLevel,\r\nBEACON_RSSI(ah), ATH9K_ANI_RSSI_THR_LOW,\r\nATH9K_ANI_RSSI_THR_HIGH);\r\nif (AR_SREV_9100(ah) && immunityLevel < ATH9K_ANI_CCK_DEF_LEVEL)\r\nimmunityLevel = ATH9K_ANI_CCK_DEF_LEVEL;\r\nif (ah->opmode == NL80211_IFTYPE_STATION &&\r\nBEACON_RSSI(ah) <= ATH9K_ANI_RSSI_THR_LOW &&\r\nimmunityLevel > ATH9K_ANI_CCK_MAX_LEVEL_LOW_RSSI)\r\nimmunityLevel = ATH9K_ANI_CCK_MAX_LEVEL_LOW_RSSI;\r\nif (!scan)\r\naniState->cckNoiseImmunityLevel = immunityLevel;\r\nentry_ofdm = &ofdm_level_table[aniState->ofdmNoiseImmunityLevel];\r\nentry_cck = &cck_level_table[aniState->cckNoiseImmunityLevel];\r\nif (aniState->firstepLevel != entry_cck->fir_step_level &&\r\nentry_cck->fir_step_level >= entry_ofdm->fir_step_level)\r\nath9k_hw_ani_control(ah,\r\nATH9K_ANI_FIRSTEP_LEVEL,\r\nentry_cck->fir_step_level);\r\nif (!AR_SREV_9300_20_OR_LATER(ah) || AR_SREV_9485(ah) ||\r\nAR_SREV_9565(ah) || AR_SREV_9561(ah))\r\nreturn;\r\nif (aniState->mrcCCK != entry_cck->mrc_cck_on)\r\nath9k_hw_ani_control(ah,\r\nATH9K_ANI_MRC_CCK,\r\nentry_cck->mrc_cck_on);\r\n}\r\nstatic void ath9k_hw_ani_cck_err_trigger(struct ath_hw *ah)\r\n{\r\nstruct ar5416AniState *aniState;\r\nif (!ah->curchan)\r\nreturn;\r\naniState = &ah->ani;\r\nif (aniState->cckNoiseImmunityLevel < ATH9K_ANI_CCK_MAX_LEVEL)\r\nath9k_hw_set_cck_nil(ah, aniState->cckNoiseImmunityLevel + 1,\r\nfalse);\r\n}\r\nstatic void ath9k_hw_ani_lower_immunity(struct ath_hw *ah)\r\n{\r\nstruct ar5416AniState *aniState;\r\naniState = &ah->ani;\r\nif (aniState->ofdmNoiseImmunityLevel > 0 &&\r\n(aniState->ofdmsTurn || aniState->cckNoiseImmunityLevel == 0)) {\r\nath9k_hw_set_ofdm_nil(ah, aniState->ofdmNoiseImmunityLevel - 1,\r\nfalse);\r\nreturn;\r\n}\r\nif (aniState->cckNoiseImmunityLevel > 0)\r\nath9k_hw_set_cck_nil(ah, aniState->cckNoiseImmunityLevel - 1,\r\nfalse);\r\n}\r\nvoid ath9k_ani_reset(struct ath_hw *ah, bool is_scanning)\r\n{\r\nstruct ar5416AniState *aniState = &ah->ani;\r\nstruct ath9k_channel *chan = ah->curchan;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nint ofdm_nil, cck_nil;\r\nif (!ah->curchan)\r\nreturn;\r\nBUG_ON(aniState == NULL);\r\nah->stats.ast_ani_reset++;\r\nofdm_nil = max_t(int, ATH9K_ANI_OFDM_DEF_LEVEL,\r\naniState->ofdmNoiseImmunityLevel);\r\ncck_nil = max_t(int, ATH9K_ANI_CCK_DEF_LEVEL,\r\naniState->cckNoiseImmunityLevel);\r\nif (is_scanning ||\r\n(ah->opmode != NL80211_IFTYPE_STATION &&\r\nah->opmode != NL80211_IFTYPE_ADHOC)) {\r\nif (aniState->ofdmNoiseImmunityLevel !=\r\nATH9K_ANI_OFDM_DEF_LEVEL ||\r\naniState->cckNoiseImmunityLevel !=\r\nATH9K_ANI_CCK_DEF_LEVEL) {\r\nath_dbg(common, ANI,\r\n"Restore defaults: opmode %u chan %d Mhz is_scanning=%d ofdm:%d cck:%d\n",\r\nah->opmode,\r\nchan->channel,\r\nis_scanning,\r\naniState->ofdmNoiseImmunityLevel,\r\naniState->cckNoiseImmunityLevel);\r\nofdm_nil = ATH9K_ANI_OFDM_DEF_LEVEL;\r\ncck_nil = ATH9K_ANI_CCK_DEF_LEVEL;\r\n}\r\n} else {\r\nath_dbg(common, ANI,\r\n"Restore history: opmode %u chan %d Mhz is_scanning=%d ofdm:%d cck:%d\n",\r\nah->opmode,\r\nchan->channel,\r\nis_scanning,\r\naniState->ofdmNoiseImmunityLevel,\r\naniState->cckNoiseImmunityLevel);\r\n}\r\nath9k_hw_set_ofdm_nil(ah, ofdm_nil, is_scanning);\r\nath9k_hw_set_cck_nil(ah, cck_nil, is_scanning);\r\nath9k_ani_restart(ah);\r\n}\r\nstatic bool ath9k_hw_ani_read_counters(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ar5416AniState *aniState = &ah->ani;\r\nu32 phyCnt1, phyCnt2;\r\nint32_t listenTime;\r\nath_hw_cycle_counters_update(common);\r\nlistenTime = ath_hw_get_listen_time(common);\r\nif (listenTime <= 0) {\r\nah->stats.ast_ani_lneg_or_lzero++;\r\nath9k_ani_restart(ah);\r\nreturn false;\r\n}\r\naniState->listenTime += listenTime;\r\nath9k_hw_update_mibstats(ah, &ah->ah_mibStats);\r\nphyCnt1 = REG_READ(ah, AR_PHY_ERR_1);\r\nphyCnt2 = REG_READ(ah, AR_PHY_ERR_2);\r\nah->stats.ast_ani_ofdmerrs += phyCnt1 - aniState->ofdmPhyErrCount;\r\naniState->ofdmPhyErrCount = phyCnt1;\r\nah->stats.ast_ani_cckerrs += phyCnt2 - aniState->cckPhyErrCount;\r\naniState->cckPhyErrCount = phyCnt2;\r\nreturn true;\r\n}\r\nvoid ath9k_hw_ani_monitor(struct ath_hw *ah, struct ath9k_channel *chan)\r\n{\r\nstruct ar5416AniState *aniState;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nu32 ofdmPhyErrRate, cckPhyErrRate;\r\nif (!ah->curchan)\r\nreturn;\r\naniState = &ah->ani;\r\nif (!ath9k_hw_ani_read_counters(ah))\r\nreturn;\r\nofdmPhyErrRate = aniState->ofdmPhyErrCount * 1000 /\r\naniState->listenTime;\r\ncckPhyErrRate = aniState->cckPhyErrCount * 1000 /\r\naniState->listenTime;\r\nath_dbg(common, ANI,\r\n"listenTime=%d OFDM:%d errs=%d/s CCK:%d errs=%d/s ofdm_turn=%d\n",\r\naniState->listenTime,\r\naniState->ofdmNoiseImmunityLevel,\r\nofdmPhyErrRate, aniState->cckNoiseImmunityLevel,\r\ncckPhyErrRate, aniState->ofdmsTurn);\r\nif (aniState->listenTime > ah->aniperiod) {\r\nif (cckPhyErrRate < ah->config.cck_trig_low &&\r\nofdmPhyErrRate < ah->config.ofdm_trig_low) {\r\nath9k_hw_ani_lower_immunity(ah);\r\naniState->ofdmsTurn = !aniState->ofdmsTurn;\r\n} else if (ofdmPhyErrRate > ah->config.ofdm_trig_high) {\r\nath9k_hw_ani_ofdm_err_trigger(ah);\r\naniState->ofdmsTurn = false;\r\n} else if (cckPhyErrRate > ah->config.cck_trig_high) {\r\nath9k_hw_ani_cck_err_trigger(ah);\r\naniState->ofdmsTurn = true;\r\n}\r\nath9k_ani_restart(ah);\r\n}\r\n}\r\nvoid ath9k_enable_mib_counters(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nath_dbg(common, ANI, "Enable MIB counters\n");\r\nath9k_hw_update_mibstats(ah, &ah->ah_mibStats);\r\nENABLE_REGWRITE_BUFFER(ah);\r\nREG_WRITE(ah, AR_FILT_OFDM, 0);\r\nREG_WRITE(ah, AR_FILT_CCK, 0);\r\nREG_WRITE(ah, AR_MIBC,\r\n~(AR_MIBC_COW | AR_MIBC_FMC | AR_MIBC_CMC | AR_MIBC_MCS)\r\n& 0x0f);\r\nREG_WRITE(ah, AR_PHY_ERR_MASK_1, AR_PHY_ERR_OFDM_TIMING);\r\nREG_WRITE(ah, AR_PHY_ERR_MASK_2, AR_PHY_ERR_CCK_TIMING);\r\nREGWRITE_BUFFER_FLUSH(ah);\r\n}\r\nvoid ath9k_hw_disable_mib_counters(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nath_dbg(common, ANI, "Disable MIB counters\n");\r\nREG_WRITE(ah, AR_MIBC, AR_MIBC_FMC);\r\nath9k_hw_update_mibstats(ah, &ah->ah_mibStats);\r\nREG_WRITE(ah, AR_MIBC, AR_MIBC_CMC);\r\nREG_WRITE(ah, AR_FILT_OFDM, 0);\r\nREG_WRITE(ah, AR_FILT_CCK, 0);\r\n}\r\nvoid ath9k_hw_ani_init(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ar5416AniState *ani = &ah->ani;\r\nath_dbg(common, ANI, "Initialize ANI\n");\r\nif (AR_SREV_9300_20_OR_LATER(ah)) {\r\nah->config.ofdm_trig_high = ATH9K_ANI_OFDM_TRIG_HIGH;\r\nah->config.ofdm_trig_low = ATH9K_ANI_OFDM_TRIG_LOW;\r\nah->config.cck_trig_high = ATH9K_ANI_CCK_TRIG_HIGH;\r\nah->config.cck_trig_low = ATH9K_ANI_CCK_TRIG_LOW;\r\n} else {\r\nah->config.ofdm_trig_high = ATH9K_ANI_OFDM_TRIG_HIGH_OLD;\r\nah->config.ofdm_trig_low = ATH9K_ANI_OFDM_TRIG_LOW_OLD;\r\nah->config.cck_trig_high = ATH9K_ANI_CCK_TRIG_HIGH_OLD;\r\nah->config.cck_trig_low = ATH9K_ANI_CCK_TRIG_LOW_OLD;\r\n}\r\nani->spurImmunityLevel = ATH9K_ANI_SPUR_IMMUNE_LVL;\r\nani->firstepLevel = ATH9K_ANI_FIRSTEP_LVL;\r\nani->mrcCCK = AR_SREV_9300_20_OR_LATER(ah) ? true : false;\r\nani->ofdmsTurn = true;\r\nani->ofdmWeakSigDetect = true;\r\nani->cckNoiseImmunityLevel = ATH9K_ANI_CCK_DEF_LEVEL;\r\nani->ofdmNoiseImmunityLevel = ATH9K_ANI_OFDM_DEF_LEVEL;\r\nah->aniperiod = ATH9K_ANI_PERIOD;\r\nah->config.ani_poll_interval = ATH9K_ANI_POLLINTERVAL;\r\nath9k_ani_restart(ah);\r\nath9k_enable_mib_counters(ah);\r\n}
