static int dvb_device_open(struct inode *inode, struct file *file)\r\n{\r\nstruct dvb_device *dvbdev;\r\nmutex_lock(&dvbdev_mutex);\r\ndown_read(&minor_rwsem);\r\ndvbdev = dvb_minors[iminor(inode)];\r\nif (dvbdev && dvbdev->fops) {\r\nint err = 0;\r\nconst struct file_operations *new_fops;\r\nnew_fops = fops_get(dvbdev->fops);\r\nif (!new_fops)\r\ngoto fail;\r\nfile->private_data = dvbdev;\r\nreplace_fops(file, new_fops);\r\nif (file->f_op->open)\r\nerr = file->f_op->open(inode,file);\r\nup_read(&minor_rwsem);\r\nmutex_unlock(&dvbdev_mutex);\r\nreturn err;\r\n}\r\nfail:\r\nup_read(&minor_rwsem);\r\nmutex_unlock(&dvbdev_mutex);\r\nreturn -ENODEV;\r\n}\r\nint dvb_generic_open(struct inode *inode, struct file *file)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nif (!dvbdev)\r\nreturn -ENODEV;\r\nif (!dvbdev->users)\r\nreturn -EBUSY;\r\nif ((file->f_flags & O_ACCMODE) == O_RDONLY) {\r\nif (!dvbdev->readers)\r\nreturn -EBUSY;\r\ndvbdev->readers--;\r\n} else {\r\nif (!dvbdev->writers)\r\nreturn -EBUSY;\r\ndvbdev->writers--;\r\n}\r\ndvbdev->users--;\r\nreturn 0;\r\n}\r\nint dvb_generic_release(struct inode *inode, struct file *file)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nif (!dvbdev)\r\nreturn -ENODEV;\r\nif ((file->f_flags & O_ACCMODE) == O_RDONLY) {\r\ndvbdev->readers++;\r\n} else {\r\ndvbdev->writers++;\r\n}\r\ndvbdev->users++;\r\nreturn 0;\r\n}\r\nlong dvb_generic_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nif (!dvbdev)\r\nreturn -ENODEV;\r\nif (!dvbdev->kernel_ioctl)\r\nreturn -EINVAL;\r\nreturn dvb_usercopy(file, cmd, arg, dvbdev->kernel_ioctl);\r\n}\r\nstatic int dvbdev_get_free_id (struct dvb_adapter *adap, int type)\r\n{\r\nu32 id = 0;\r\nwhile (id < DVB_MAX_IDS) {\r\nstruct dvb_device *dev;\r\nlist_for_each_entry(dev, &adap->device_list, list_head)\r\nif (dev->type == type && dev->id == id)\r\ngoto skip;\r\nreturn id;\r\nskip:\r\nid++;\r\n}\r\nreturn -ENFILE;\r\n}\r\nstatic void dvb_register_media_device(struct dvb_device *dvbdev,\r\nint type, int minor)\r\n{\r\n#if defined(CONFIG_MEDIA_CONTROLLER_DVB)\r\nint ret = 0, npads;\r\nif (!dvbdev->adapter->mdev)\r\nreturn;\r\ndvbdev->entity = kzalloc(sizeof(*dvbdev->entity), GFP_KERNEL);\r\nif (!dvbdev->entity)\r\nreturn;\r\ndvbdev->entity->info.dev.major = DVB_MAJOR;\r\ndvbdev->entity->info.dev.minor = minor;\r\ndvbdev->entity->name = dvbdev->name;\r\nswitch (type) {\r\ncase DVB_DEVICE_CA:\r\ncase DVB_DEVICE_DEMUX:\r\ncase DVB_DEVICE_FRONTEND:\r\nnpads = 2;\r\nbreak;\r\ncase DVB_DEVICE_NET:\r\nnpads = 0;\r\nbreak;\r\ndefault:\r\nnpads = 1;\r\n}\r\nif (npads) {\r\ndvbdev->pads = kcalloc(npads, sizeof(*dvbdev->pads),\r\nGFP_KERNEL);\r\nif (!dvbdev->pads) {\r\nkfree(dvbdev->entity);\r\nreturn;\r\n}\r\n}\r\nswitch (type) {\r\ncase DVB_DEVICE_FRONTEND:\r\ndvbdev->entity->type = MEDIA_ENT_T_DEVNODE_DVB_FE;\r\ndvbdev->pads[0].flags = MEDIA_PAD_FL_SINK;\r\ndvbdev->pads[1].flags = MEDIA_PAD_FL_SOURCE;\r\nbreak;\r\ncase DVB_DEVICE_DEMUX:\r\ndvbdev->entity->type = MEDIA_ENT_T_DEVNODE_DVB_DEMUX;\r\ndvbdev->pads[0].flags = MEDIA_PAD_FL_SINK;\r\ndvbdev->pads[1].flags = MEDIA_PAD_FL_SOURCE;\r\nbreak;\r\ncase DVB_DEVICE_DVR:\r\ndvbdev->entity->type = MEDIA_ENT_T_DEVNODE_DVB_DVR;\r\ndvbdev->pads[0].flags = MEDIA_PAD_FL_SINK;\r\nbreak;\r\ncase DVB_DEVICE_CA:\r\ndvbdev->entity->type = MEDIA_ENT_T_DEVNODE_DVB_CA;\r\ndvbdev->pads[0].flags = MEDIA_PAD_FL_SINK;\r\ndvbdev->pads[1].flags = MEDIA_PAD_FL_SOURCE;\r\nbreak;\r\ncase DVB_DEVICE_NET:\r\ndvbdev->entity->type = MEDIA_ENT_T_DEVNODE_DVB_NET;\r\nbreak;\r\ndefault:\r\nkfree(dvbdev->entity);\r\ndvbdev->entity = NULL;\r\nreturn;\r\n}\r\nif (npads)\r\nret = media_entity_init(dvbdev->entity, npads, dvbdev->pads, 0);\r\nif (!ret)\r\nret = media_device_register_entity(dvbdev->adapter->mdev,\r\ndvbdev->entity);\r\nif (ret < 0) {\r\nprintk(KERN_ERR\r\n"%s: media_device_register_entity failed for %s\n",\r\n__func__, dvbdev->entity->name);\r\nkfree(dvbdev->pads);\r\nkfree(dvbdev->entity);\r\ndvbdev->entity = NULL;\r\nreturn;\r\n}\r\nprintk(KERN_DEBUG "%s: media device '%s' registered.\n",\r\n__func__, dvbdev->entity->name);\r\n#endif\r\n}\r\nint dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,\r\nconst struct dvb_device *template, void *priv, int type)\r\n{\r\nstruct dvb_device *dvbdev;\r\nstruct file_operations *dvbdevfops;\r\nstruct device *clsdev;\r\nint minor;\r\nint id;\r\nmutex_lock(&dvbdev_register_lock);\r\nif ((id = dvbdev_get_free_id (adap, type)) < 0){\r\nmutex_unlock(&dvbdev_register_lock);\r\n*pdvbdev = NULL;\r\nprintk(KERN_ERR "%s: couldn't find free device id\n", __func__);\r\nreturn -ENFILE;\r\n}\r\n*pdvbdev = dvbdev = kmalloc(sizeof(struct dvb_device), GFP_KERNEL);\r\nif (!dvbdev){\r\nmutex_unlock(&dvbdev_register_lock);\r\nreturn -ENOMEM;\r\n}\r\ndvbdevfops = kzalloc(sizeof(struct file_operations), GFP_KERNEL);\r\nif (!dvbdevfops){\r\nkfree (dvbdev);\r\nmutex_unlock(&dvbdev_register_lock);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(dvbdev, template, sizeof(struct dvb_device));\r\ndvbdev->type = type;\r\ndvbdev->id = id;\r\ndvbdev->adapter = adap;\r\ndvbdev->priv = priv;\r\ndvbdev->fops = dvbdevfops;\r\ninit_waitqueue_head (&dvbdev->wait_queue);\r\nmemcpy(dvbdevfops, template->fops, sizeof(struct file_operations));\r\ndvbdevfops->owner = adap->module;\r\nlist_add_tail (&dvbdev->list_head, &adap->device_list);\r\ndown_write(&minor_rwsem);\r\n#ifdef CONFIG_DVB_DYNAMIC_MINORS\r\nfor (minor = 0; minor < MAX_DVB_MINORS; minor++)\r\nif (dvb_minors[minor] == NULL)\r\nbreak;\r\nif (minor == MAX_DVB_MINORS) {\r\nkfree(dvbdevfops);\r\nkfree(dvbdev);\r\nup_write(&minor_rwsem);\r\nmutex_unlock(&dvbdev_register_lock);\r\nreturn -EINVAL;\r\n}\r\n#else\r\nminor = nums2minor(adap->num, type, id);\r\n#endif\r\ndvbdev->minor = minor;\r\ndvb_minors[minor] = dvbdev;\r\nup_write(&minor_rwsem);\r\nmutex_unlock(&dvbdev_register_lock);\r\nclsdev = device_create(dvb_class, adap->device,\r\nMKDEV(DVB_MAJOR, minor),\r\ndvbdev, "dvb%d.%s%d", adap->num, dnames[type], id);\r\nif (IS_ERR(clsdev)) {\r\nprintk(KERN_ERR "%s: failed to create device dvb%d.%s%d (%ld)\n",\r\n__func__, adap->num, dnames[type], id, PTR_ERR(clsdev));\r\nreturn PTR_ERR(clsdev);\r\n}\r\ndprintk(KERN_DEBUG "DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\n",\r\nadap->num, dnames[type], id, minor, minor);\r\ndvb_register_media_device(dvbdev, type, minor);\r\nreturn 0;\r\n}\r\nvoid dvb_unregister_device(struct dvb_device *dvbdev)\r\n{\r\nif (!dvbdev)\r\nreturn;\r\ndown_write(&minor_rwsem);\r\ndvb_minors[dvbdev->minor] = NULL;\r\nup_write(&minor_rwsem);\r\ndevice_destroy(dvb_class, MKDEV(DVB_MAJOR, dvbdev->minor));\r\n#if defined(CONFIG_MEDIA_CONTROLLER_DVB)\r\nif (dvbdev->entity) {\r\nmedia_device_unregister_entity(dvbdev->entity);\r\nkfree(dvbdev->entity);\r\nkfree(dvbdev->pads);\r\n}\r\n#endif\r\nlist_del (&dvbdev->list_head);\r\nkfree (dvbdev->fops);\r\nkfree (dvbdev);\r\n}\r\nvoid dvb_create_media_graph(struct dvb_adapter *adap)\r\n{\r\nstruct media_device *mdev = adap->mdev;\r\nstruct media_entity *entity, *tuner = NULL, *fe = NULL;\r\nstruct media_entity *demux = NULL, *dvr = NULL, *ca = NULL;\r\nif (!mdev)\r\nreturn;\r\nmedia_device_for_each_entity(entity, mdev) {\r\nswitch (entity->type) {\r\ncase MEDIA_ENT_T_V4L2_SUBDEV_TUNER:\r\ntuner = entity;\r\nbreak;\r\ncase MEDIA_ENT_T_DEVNODE_DVB_FE:\r\nfe = entity;\r\nbreak;\r\ncase MEDIA_ENT_T_DEVNODE_DVB_DEMUX:\r\ndemux = entity;\r\nbreak;\r\ncase MEDIA_ENT_T_DEVNODE_DVB_DVR:\r\ndvr = entity;\r\nbreak;\r\ncase MEDIA_ENT_T_DEVNODE_DVB_CA:\r\nca = entity;\r\nbreak;\r\n}\r\n}\r\nif (tuner && fe)\r\nmedia_entity_create_link(tuner, 0, fe, 0, 0);\r\nif (fe && demux)\r\nmedia_entity_create_link(fe, 1, demux, 0, MEDIA_LNK_FL_ENABLED);\r\nif (demux && dvr)\r\nmedia_entity_create_link(demux, 1, dvr, 0, MEDIA_LNK_FL_ENABLED);\r\nif (demux && ca)\r\nmedia_entity_create_link(demux, 1, ca, 0, MEDIA_LNK_FL_ENABLED);\r\n}\r\nstatic int dvbdev_check_free_adapter_num(int num)\r\n{\r\nstruct list_head *entry;\r\nlist_for_each(entry, &dvb_adapter_list) {\r\nstruct dvb_adapter *adap;\r\nadap = list_entry(entry, struct dvb_adapter, list_head);\r\nif (adap->num == num)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int dvbdev_get_free_adapter_num (void)\r\n{\r\nint num = 0;\r\nwhile (num < DVB_MAX_ADAPTERS) {\r\nif (dvbdev_check_free_adapter_num(num))\r\nreturn num;\r\nnum++;\r\n}\r\nreturn -ENFILE;\r\n}\r\nint dvb_register_adapter(struct dvb_adapter *adap, const char *name,\r\nstruct module *module, struct device *device,\r\nshort *adapter_nums)\r\n{\r\nint i, num;\r\nmutex_lock(&dvbdev_register_lock);\r\nfor (i = 0; i < DVB_MAX_ADAPTERS; ++i) {\r\nnum = adapter_nums[i];\r\nif (num >= 0 && num < DVB_MAX_ADAPTERS) {\r\nif (dvbdev_check_free_adapter_num(num))\r\nbreak;\r\n} else {\r\nnum = dvbdev_get_free_adapter_num();\r\nbreak;\r\n}\r\nnum = -1;\r\n}\r\nif (num < 0) {\r\nmutex_unlock(&dvbdev_register_lock);\r\nreturn -ENFILE;\r\n}\r\nmemset (adap, 0, sizeof(struct dvb_adapter));\r\nINIT_LIST_HEAD (&adap->device_list);\r\nprintk(KERN_INFO "DVB: registering new adapter (%s)\n", name);\r\nadap->num = num;\r\nadap->name = name;\r\nadap->module = module;\r\nadap->device = device;\r\nadap->mfe_shared = 0;\r\nadap->mfe_dvbdev = NULL;\r\nmutex_init (&adap->mfe_lock);\r\nlist_add_tail (&adap->list_head, &dvb_adapter_list);\r\nmutex_unlock(&dvbdev_register_lock);\r\nreturn num;\r\n}\r\nint dvb_unregister_adapter(struct dvb_adapter *adap)\r\n{\r\nmutex_lock(&dvbdev_register_lock);\r\nlist_del (&adap->list_head);\r\nmutex_unlock(&dvbdev_register_lock);\r\nreturn 0;\r\n}\r\nint dvb_usercopy(struct file *file,\r\nunsigned int cmd, unsigned long arg,\r\nint (*func)(struct file *file,\r\nunsigned int cmd, void *arg))\r\n{\r\nchar sbuf[128];\r\nvoid *mbuf = NULL;\r\nvoid *parg = NULL;\r\nint err = -EINVAL;\r\nswitch (_IOC_DIR(cmd)) {\r\ncase _IOC_NONE:\r\nparg = (void *) arg;\r\nbreak;\r\ncase _IOC_READ:\r\ncase _IOC_WRITE:\r\ncase (_IOC_WRITE | _IOC_READ):\r\nif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\r\nparg = sbuf;\r\n} else {\r\nmbuf = kmalloc(_IOC_SIZE(cmd),GFP_KERNEL);\r\nif (NULL == mbuf)\r\nreturn -ENOMEM;\r\nparg = mbuf;\r\n}\r\nerr = -EFAULT;\r\nif (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))\r\ngoto out;\r\nbreak;\r\n}\r\nif ((err = func(file, cmd, parg)) == -ENOIOCTLCMD)\r\nerr = -ENOTTY;\r\nif (err < 0)\r\ngoto out;\r\nswitch (_IOC_DIR(cmd))\r\n{\r\ncase _IOC_READ:\r\ncase (_IOC_WRITE | _IOC_READ):\r\nif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nout:\r\nkfree(mbuf);\r\nreturn err;\r\n}\r\nstatic int dvb_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct dvb_device *dvbdev = dev_get_drvdata(dev);\r\nadd_uevent_var(env, "DVB_ADAPTER_NUM=%d", dvbdev->adapter->num);\r\nadd_uevent_var(env, "DVB_DEVICE_TYPE=%s", dnames[dvbdev->type]);\r\nadd_uevent_var(env, "DVB_DEVICE_NUM=%d", dvbdev->id);\r\nreturn 0;\r\n}\r\nstatic char *dvb_devnode(struct device *dev, umode_t *mode)\r\n{\r\nstruct dvb_device *dvbdev = dev_get_drvdata(dev);\r\nreturn kasprintf(GFP_KERNEL, "dvb/adapter%d/%s%d",\r\ndvbdev->adapter->num, dnames[dvbdev->type], dvbdev->id);\r\n}\r\nstatic int __init init_dvbdev(void)\r\n{\r\nint retval;\r\ndev_t dev = MKDEV(DVB_MAJOR, 0);\r\nif ((retval = register_chrdev_region(dev, MAX_DVB_MINORS, "DVB")) != 0) {\r\nprintk(KERN_ERR "dvb-core: unable to get major %d\n", DVB_MAJOR);\r\nreturn retval;\r\n}\r\ncdev_init(&dvb_device_cdev, &dvb_device_fops);\r\nif ((retval = cdev_add(&dvb_device_cdev, dev, MAX_DVB_MINORS)) != 0) {\r\nprintk(KERN_ERR "dvb-core: unable register character device\n");\r\ngoto error;\r\n}\r\ndvb_class = class_create(THIS_MODULE, "dvb");\r\nif (IS_ERR(dvb_class)) {\r\nretval = PTR_ERR(dvb_class);\r\ngoto error;\r\n}\r\ndvb_class->dev_uevent = dvb_uevent;\r\ndvb_class->devnode = dvb_devnode;\r\nreturn 0;\r\nerror:\r\ncdev_del(&dvb_device_cdev);\r\nunregister_chrdev_region(dev, MAX_DVB_MINORS);\r\nreturn retval;\r\n}\r\nstatic void __exit exit_dvbdev(void)\r\n{\r\nclass_destroy(dvb_class);\r\ncdev_del(&dvb_device_cdev);\r\nunregister_chrdev_region(MKDEV(DVB_MAJOR, 0), MAX_DVB_MINORS);\r\n}
