static inline struct msg_queue *msq_obtain_object(struct ipc_namespace *ns, int id)\r\n{\r\nstruct kern_ipc_perm *ipcp = ipc_obtain_object_idr(&msg_ids(ns), id);\r\nif (IS_ERR(ipcp))\r\nreturn ERR_CAST(ipcp);\r\nreturn container_of(ipcp, struct msg_queue, q_perm);\r\n}\r\nstatic inline struct msg_queue *msq_obtain_object_check(struct ipc_namespace *ns,\r\nint id)\r\n{\r\nstruct kern_ipc_perm *ipcp = ipc_obtain_object_check(&msg_ids(ns), id);\r\nif (IS_ERR(ipcp))\r\nreturn ERR_CAST(ipcp);\r\nreturn container_of(ipcp, struct msg_queue, q_perm);\r\n}\r\nstatic inline void msg_rmid(struct ipc_namespace *ns, struct msg_queue *s)\r\n{\r\nipc_rmid(&msg_ids(ns), &s->q_perm);\r\n}\r\nstatic void msg_rcu_free(struct rcu_head *head)\r\n{\r\nstruct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);\r\nstruct msg_queue *msq = ipc_rcu_to_struct(p);\r\nsecurity_msg_queue_free(msq);\r\nipc_rcu_free(head);\r\n}\r\nstatic int newque(struct ipc_namespace *ns, struct ipc_params *params)\r\n{\r\nstruct msg_queue *msq;\r\nint id, retval;\r\nkey_t key = params->key;\r\nint msgflg = params->flg;\r\nmsq = ipc_rcu_alloc(sizeof(*msq));\r\nif (!msq)\r\nreturn -ENOMEM;\r\nmsq->q_perm.mode = msgflg & S_IRWXUGO;\r\nmsq->q_perm.key = key;\r\nmsq->q_perm.security = NULL;\r\nretval = security_msg_queue_alloc(msq);\r\nif (retval) {\r\nipc_rcu_putref(msq, ipc_rcu_free);\r\nreturn retval;\r\n}\r\nmsq->q_stime = msq->q_rtime = 0;\r\nmsq->q_ctime = get_seconds();\r\nmsq->q_cbytes = msq->q_qnum = 0;\r\nmsq->q_qbytes = ns->msg_ctlmnb;\r\nmsq->q_lspid = msq->q_lrpid = 0;\r\nINIT_LIST_HEAD(&msq->q_messages);\r\nINIT_LIST_HEAD(&msq->q_receivers);\r\nINIT_LIST_HEAD(&msq->q_senders);\r\nid = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);\r\nif (id < 0) {\r\nipc_rcu_putref(msq, msg_rcu_free);\r\nreturn id;\r\n}\r\nipc_unlock_object(&msq->q_perm);\r\nrcu_read_unlock();\r\nreturn msq->q_perm.id;\r\n}\r\nstatic inline void ss_add(struct msg_queue *msq, struct msg_sender *mss)\r\n{\r\nmss->tsk = current;\r\n__set_current_state(TASK_INTERRUPTIBLE);\r\nlist_add_tail(&mss->list, &msq->q_senders);\r\n}\r\nstatic inline void ss_del(struct msg_sender *mss)\r\n{\r\nif (mss->list.next != NULL)\r\nlist_del(&mss->list);\r\n}\r\nstatic void ss_wakeup(struct list_head *h, int kill)\r\n{\r\nstruct msg_sender *mss, *t;\r\nlist_for_each_entry_safe(mss, t, h, list) {\r\nif (kill)\r\nmss->list.next = NULL;\r\nwake_up_process(mss->tsk);\r\n}\r\n}\r\nstatic void expunge_all(struct msg_queue *msq, int res)\r\n{\r\nstruct msg_receiver *msr, *t;\r\nlist_for_each_entry_safe(msr, t, &msq->q_receivers, r_list) {\r\nmsr->r_msg = NULL;\r\nwake_up_process(msr->r_tsk);\r\nsmp_wmb();\r\nmsr->r_msg = ERR_PTR(res);\r\n}\r\n}\r\nstatic void freeque(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)\r\n{\r\nstruct msg_msg *msg, *t;\r\nstruct msg_queue *msq = container_of(ipcp, struct msg_queue, q_perm);\r\nexpunge_all(msq, -EIDRM);\r\nss_wakeup(&msq->q_senders, 1);\r\nmsg_rmid(ns, msq);\r\nipc_unlock_object(&msq->q_perm);\r\nrcu_read_unlock();\r\nlist_for_each_entry_safe(msg, t, &msq->q_messages, m_list) {\r\natomic_dec(&ns->msg_hdrs);\r\nfree_msg(msg);\r\n}\r\natomic_sub(msq->q_cbytes, &ns->msg_bytes);\r\nipc_rcu_putref(msq, msg_rcu_free);\r\n}\r\nstatic inline int msg_security(struct kern_ipc_perm *ipcp, int msgflg)\r\n{\r\nstruct msg_queue *msq = container_of(ipcp, struct msg_queue, q_perm);\r\nreturn security_msg_queue_associate(msq, msgflg);\r\n}\r\nstatic inline unsigned long\r\ncopy_msqid_to_user(void __user *buf, struct msqid64_ds *in, int version)\r\n{\r\nswitch (version) {\r\ncase IPC_64:\r\nreturn copy_to_user(buf, in, sizeof(*in));\r\ncase IPC_OLD:\r\n{\r\nstruct msqid_ds out;\r\nmemset(&out, 0, sizeof(out));\r\nipc64_perm_to_ipc_perm(&in->msg_perm, &out.msg_perm);\r\nout.msg_stime = in->msg_stime;\r\nout.msg_rtime = in->msg_rtime;\r\nout.msg_ctime = in->msg_ctime;\r\nif (in->msg_cbytes > USHRT_MAX)\r\nout.msg_cbytes = USHRT_MAX;\r\nelse\r\nout.msg_cbytes = in->msg_cbytes;\r\nout.msg_lcbytes = in->msg_cbytes;\r\nif (in->msg_qnum > USHRT_MAX)\r\nout.msg_qnum = USHRT_MAX;\r\nelse\r\nout.msg_qnum = in->msg_qnum;\r\nif (in->msg_qbytes > USHRT_MAX)\r\nout.msg_qbytes = USHRT_MAX;\r\nelse\r\nout.msg_qbytes = in->msg_qbytes;\r\nout.msg_lqbytes = in->msg_qbytes;\r\nout.msg_lspid = in->msg_lspid;\r\nout.msg_lrpid = in->msg_lrpid;\r\nreturn copy_to_user(buf, &out, sizeof(out));\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic inline unsigned long\r\ncopy_msqid_from_user(struct msqid64_ds *out, void __user *buf, int version)\r\n{\r\nswitch (version) {\r\ncase IPC_64:\r\nif (copy_from_user(out, buf, sizeof(*out)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase IPC_OLD:\r\n{\r\nstruct msqid_ds tbuf_old;\r\nif (copy_from_user(&tbuf_old, buf, sizeof(tbuf_old)))\r\nreturn -EFAULT;\r\nout->msg_perm.uid = tbuf_old.msg_perm.uid;\r\nout->msg_perm.gid = tbuf_old.msg_perm.gid;\r\nout->msg_perm.mode = tbuf_old.msg_perm.mode;\r\nif (tbuf_old.msg_qbytes == 0)\r\nout->msg_qbytes = tbuf_old.msg_lqbytes;\r\nelse\r\nout->msg_qbytes = tbuf_old.msg_qbytes;\r\nreturn 0;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int msgctl_down(struct ipc_namespace *ns, int msqid, int cmd,\r\nstruct msqid_ds __user *buf, int version)\r\n{\r\nstruct kern_ipc_perm *ipcp;\r\nstruct msqid64_ds uninitialized_var(msqid64);\r\nstruct msg_queue *msq;\r\nint err;\r\nif (cmd == IPC_SET) {\r\nif (copy_msqid_from_user(&msqid64, buf, version))\r\nreturn -EFAULT;\r\n}\r\ndown_write(&msg_ids(ns).rwsem);\r\nrcu_read_lock();\r\nipcp = ipcctl_pre_down_nolock(ns, &msg_ids(ns), msqid, cmd,\r\n&msqid64.msg_perm, msqid64.msg_qbytes);\r\nif (IS_ERR(ipcp)) {\r\nerr = PTR_ERR(ipcp);\r\ngoto out_unlock1;\r\n}\r\nmsq = container_of(ipcp, struct msg_queue, q_perm);\r\nerr = security_msg_queue_msgctl(msq, cmd);\r\nif (err)\r\ngoto out_unlock1;\r\nswitch (cmd) {\r\ncase IPC_RMID:\r\nipc_lock_object(&msq->q_perm);\r\nfreeque(ns, ipcp);\r\ngoto out_up;\r\ncase IPC_SET:\r\nif (msqid64.msg_qbytes > ns->msg_ctlmnb &&\r\n!capable(CAP_SYS_RESOURCE)) {\r\nerr = -EPERM;\r\ngoto out_unlock1;\r\n}\r\nipc_lock_object(&msq->q_perm);\r\nerr = ipc_update_perm(&msqid64.msg_perm, ipcp);\r\nif (err)\r\ngoto out_unlock0;\r\nmsq->q_qbytes = msqid64.msg_qbytes;\r\nmsq->q_ctime = get_seconds();\r\nexpunge_all(msq, -EAGAIN);\r\nss_wakeup(&msq->q_senders, 0);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto out_unlock1;\r\n}\r\nout_unlock0:\r\nipc_unlock_object(&msq->q_perm);\r\nout_unlock1:\r\nrcu_read_unlock();\r\nout_up:\r\nup_write(&msg_ids(ns).rwsem);\r\nreturn err;\r\n}\r\nstatic int msgctl_nolock(struct ipc_namespace *ns, int msqid,\r\nint cmd, int version, void __user *buf)\r\n{\r\nint err;\r\nstruct msg_queue *msq;\r\nswitch (cmd) {\r\ncase IPC_INFO:\r\ncase MSG_INFO:\r\n{\r\nstruct msginfo msginfo;\r\nint max_id;\r\nif (!buf)\r\nreturn -EFAULT;\r\nerr = security_msg_queue_msgctl(NULL, cmd);\r\nif (err)\r\nreturn err;\r\nmemset(&msginfo, 0, sizeof(msginfo));\r\nmsginfo.msgmni = ns->msg_ctlmni;\r\nmsginfo.msgmax = ns->msg_ctlmax;\r\nmsginfo.msgmnb = ns->msg_ctlmnb;\r\nmsginfo.msgssz = MSGSSZ;\r\nmsginfo.msgseg = MSGSEG;\r\ndown_read(&msg_ids(ns).rwsem);\r\nif (cmd == MSG_INFO) {\r\nmsginfo.msgpool = msg_ids(ns).in_use;\r\nmsginfo.msgmap = atomic_read(&ns->msg_hdrs);\r\nmsginfo.msgtql = atomic_read(&ns->msg_bytes);\r\n} else {\r\nmsginfo.msgmap = MSGMAP;\r\nmsginfo.msgpool = MSGPOOL;\r\nmsginfo.msgtql = MSGTQL;\r\n}\r\nmax_id = ipc_get_maxid(&msg_ids(ns));\r\nup_read(&msg_ids(ns).rwsem);\r\nif (copy_to_user(buf, &msginfo, sizeof(struct msginfo)))\r\nreturn -EFAULT;\r\nreturn (max_id < 0) ? 0 : max_id;\r\n}\r\ncase MSG_STAT:\r\ncase IPC_STAT:\r\n{\r\nstruct msqid64_ds tbuf;\r\nint success_return;\r\nif (!buf)\r\nreturn -EFAULT;\r\nmemset(&tbuf, 0, sizeof(tbuf));\r\nrcu_read_lock();\r\nif (cmd == MSG_STAT) {\r\nmsq = msq_obtain_object(ns, msqid);\r\nif (IS_ERR(msq)) {\r\nerr = PTR_ERR(msq);\r\ngoto out_unlock;\r\n}\r\nsuccess_return = msq->q_perm.id;\r\n} else {\r\nmsq = msq_obtain_object_check(ns, msqid);\r\nif (IS_ERR(msq)) {\r\nerr = PTR_ERR(msq);\r\ngoto out_unlock;\r\n}\r\nsuccess_return = 0;\r\n}\r\nerr = -EACCES;\r\nif (ipcperms(ns, &msq->q_perm, S_IRUGO))\r\ngoto out_unlock;\r\nerr = security_msg_queue_msgctl(msq, cmd);\r\nif (err)\r\ngoto out_unlock;\r\nkernel_to_ipc64_perm(&msq->q_perm, &tbuf.msg_perm);\r\ntbuf.msg_stime = msq->q_stime;\r\ntbuf.msg_rtime = msq->q_rtime;\r\ntbuf.msg_ctime = msq->q_ctime;\r\ntbuf.msg_cbytes = msq->q_cbytes;\r\ntbuf.msg_qnum = msq->q_qnum;\r\ntbuf.msg_qbytes = msq->q_qbytes;\r\ntbuf.msg_lspid = msq->q_lspid;\r\ntbuf.msg_lrpid = msq->q_lrpid;\r\nrcu_read_unlock();\r\nif (copy_msqid_to_user(buf, &tbuf, version))\r\nreturn -EFAULT;\r\nreturn success_return;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn err;\r\nout_unlock:\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic int testmsg(struct msg_msg *msg, long type, int mode)\r\n{\r\nswitch (mode) {\r\ncase SEARCH_ANY:\r\ncase SEARCH_NUMBER:\r\nreturn 1;\r\ncase SEARCH_LESSEQUAL:\r\nif (msg->m_type <= type)\r\nreturn 1;\r\nbreak;\r\ncase SEARCH_EQUAL:\r\nif (msg->m_type == type)\r\nreturn 1;\r\nbreak;\r\ncase SEARCH_NOTEQUAL:\r\nif (msg->m_type != type)\r\nreturn 1;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int pipelined_send(struct msg_queue *msq, struct msg_msg *msg)\r\n{\r\nstruct msg_receiver *msr, *t;\r\nlist_for_each_entry_safe(msr, t, &msq->q_receivers, r_list) {\r\nif (testmsg(msg, msr->r_msgtype, msr->r_mode) &&\r\n!security_msg_queue_msgrcv(msq, msg, msr->r_tsk,\r\nmsr->r_msgtype, msr->r_mode)) {\r\nlist_del(&msr->r_list);\r\nif (msr->r_maxsize < msg->m_ts) {\r\nmsr->r_msg = NULL;\r\nwake_up_process(msr->r_tsk);\r\nsmp_wmb();\r\nmsr->r_msg = ERR_PTR(-E2BIG);\r\n} else {\r\nmsr->r_msg = NULL;\r\nmsq->q_lrpid = task_pid_vnr(msr->r_tsk);\r\nmsq->q_rtime = get_seconds();\r\nwake_up_process(msr->r_tsk);\r\nsmp_wmb();\r\nmsr->r_msg = msg;\r\nreturn 1;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nlong do_msgsnd(int msqid, long mtype, void __user *mtext,\r\nsize_t msgsz, int msgflg)\r\n{\r\nstruct msg_queue *msq;\r\nstruct msg_msg *msg;\r\nint err;\r\nstruct ipc_namespace *ns;\r\nns = current->nsproxy->ipc_ns;\r\nif (msgsz > ns->msg_ctlmax || (long) msgsz < 0 || msqid < 0)\r\nreturn -EINVAL;\r\nif (mtype < 1)\r\nreturn -EINVAL;\r\nmsg = load_msg(mtext, msgsz);\r\nif (IS_ERR(msg))\r\nreturn PTR_ERR(msg);\r\nmsg->m_type = mtype;\r\nmsg->m_ts = msgsz;\r\nrcu_read_lock();\r\nmsq = msq_obtain_object_check(ns, msqid);\r\nif (IS_ERR(msq)) {\r\nerr = PTR_ERR(msq);\r\ngoto out_unlock1;\r\n}\r\nipc_lock_object(&msq->q_perm);\r\nfor (;;) {\r\nstruct msg_sender s;\r\nerr = -EACCES;\r\nif (ipcperms(ns, &msq->q_perm, S_IWUGO))\r\ngoto out_unlock0;\r\nif (!ipc_valid_object(&msq->q_perm)) {\r\nerr = -EIDRM;\r\ngoto out_unlock0;\r\n}\r\nerr = security_msg_queue_msgsnd(msq, msg, msgflg);\r\nif (err)\r\ngoto out_unlock0;\r\nif (msgsz + msq->q_cbytes <= msq->q_qbytes &&\r\n1 + msq->q_qnum <= msq->q_qbytes) {\r\nbreak;\r\n}\r\nif (msgflg & IPC_NOWAIT) {\r\nerr = -EAGAIN;\r\ngoto out_unlock0;\r\n}\r\nss_add(msq, &s);\r\nif (!ipc_rcu_getref(msq)) {\r\nerr = -EIDRM;\r\ngoto out_unlock0;\r\n}\r\nipc_unlock_object(&msq->q_perm);\r\nrcu_read_unlock();\r\nschedule();\r\nrcu_read_lock();\r\nipc_lock_object(&msq->q_perm);\r\nipc_rcu_putref(msq, ipc_rcu_free);\r\nif (!ipc_valid_object(&msq->q_perm)) {\r\nerr = -EIDRM;\r\ngoto out_unlock0;\r\n}\r\nss_del(&s);\r\nif (signal_pending(current)) {\r\nerr = -ERESTARTNOHAND;\r\ngoto out_unlock0;\r\n}\r\n}\r\nmsq->q_lspid = task_tgid_vnr(current);\r\nmsq->q_stime = get_seconds();\r\nif (!pipelined_send(msq, msg)) {\r\nlist_add_tail(&msg->m_list, &msq->q_messages);\r\nmsq->q_cbytes += msgsz;\r\nmsq->q_qnum++;\r\natomic_add(msgsz, &ns->msg_bytes);\r\natomic_inc(&ns->msg_hdrs);\r\n}\r\nerr = 0;\r\nmsg = NULL;\r\nout_unlock0:\r\nipc_unlock_object(&msq->q_perm);\r\nout_unlock1:\r\nrcu_read_unlock();\r\nif (msg != NULL)\r\nfree_msg(msg);\r\nreturn err;\r\n}\r\nstatic inline int convert_mode(long *msgtyp, int msgflg)\r\n{\r\nif (msgflg & MSG_COPY)\r\nreturn SEARCH_NUMBER;\r\nif (*msgtyp == 0)\r\nreturn SEARCH_ANY;\r\nif (*msgtyp < 0) {\r\n*msgtyp = -*msgtyp;\r\nreturn SEARCH_LESSEQUAL;\r\n}\r\nif (msgflg & MSG_EXCEPT)\r\nreturn SEARCH_NOTEQUAL;\r\nreturn SEARCH_EQUAL;\r\n}\r\nstatic long do_msg_fill(void __user *dest, struct msg_msg *msg, size_t bufsz)\r\n{\r\nstruct msgbuf __user *msgp = dest;\r\nsize_t msgsz;\r\nif (put_user(msg->m_type, &msgp->mtype))\r\nreturn -EFAULT;\r\nmsgsz = (bufsz > msg->m_ts) ? msg->m_ts : bufsz;\r\nif (store_msg(msgp->mtext, msg, msgsz))\r\nreturn -EFAULT;\r\nreturn msgsz;\r\n}\r\nstatic inline struct msg_msg *prepare_copy(void __user *buf, size_t bufsz)\r\n{\r\nstruct msg_msg *copy;\r\ncopy = load_msg(buf, bufsz);\r\nif (!IS_ERR(copy))\r\ncopy->m_ts = bufsz;\r\nreturn copy;\r\n}\r\nstatic inline void free_copy(struct msg_msg *copy)\r\n{\r\nif (copy)\r\nfree_msg(copy);\r\n}\r\nstatic inline struct msg_msg *prepare_copy(void __user *buf, size_t bufsz)\r\n{\r\nreturn ERR_PTR(-ENOSYS);\r\n}\r\nstatic inline void free_copy(struct msg_msg *copy)\r\n{\r\n}\r\nstatic struct msg_msg *find_msg(struct msg_queue *msq, long *msgtyp, int mode)\r\n{\r\nstruct msg_msg *msg, *found = NULL;\r\nlong count = 0;\r\nlist_for_each_entry(msg, &msq->q_messages, m_list) {\r\nif (testmsg(msg, *msgtyp, mode) &&\r\n!security_msg_queue_msgrcv(msq, msg, current,\r\n*msgtyp, mode)) {\r\nif (mode == SEARCH_LESSEQUAL && msg->m_type != 1) {\r\n*msgtyp = msg->m_type - 1;\r\nfound = msg;\r\n} else if (mode == SEARCH_NUMBER) {\r\nif (*msgtyp == count)\r\nreturn msg;\r\n} else\r\nreturn msg;\r\ncount++;\r\n}\r\n}\r\nreturn found ?: ERR_PTR(-EAGAIN);\r\n}\r\nlong do_msgrcv(int msqid, void __user *buf, size_t bufsz, long msgtyp, int msgflg,\r\nlong (*msg_handler)(void __user *, struct msg_msg *, size_t))\r\n{\r\nint mode;\r\nstruct msg_queue *msq;\r\nstruct ipc_namespace *ns;\r\nstruct msg_msg *msg, *copy = NULL;\r\nns = current->nsproxy->ipc_ns;\r\nif (msqid < 0 || (long) bufsz < 0)\r\nreturn -EINVAL;\r\nif (msgflg & MSG_COPY) {\r\nif ((msgflg & MSG_EXCEPT) || !(msgflg & IPC_NOWAIT))\r\nreturn -EINVAL;\r\ncopy = prepare_copy(buf, min_t(size_t, bufsz, ns->msg_ctlmax));\r\nif (IS_ERR(copy))\r\nreturn PTR_ERR(copy);\r\n}\r\nmode = convert_mode(&msgtyp, msgflg);\r\nrcu_read_lock();\r\nmsq = msq_obtain_object_check(ns, msqid);\r\nif (IS_ERR(msq)) {\r\nrcu_read_unlock();\r\nfree_copy(copy);\r\nreturn PTR_ERR(msq);\r\n}\r\nfor (;;) {\r\nstruct msg_receiver msr_d;\r\nmsg = ERR_PTR(-EACCES);\r\nif (ipcperms(ns, &msq->q_perm, S_IRUGO))\r\ngoto out_unlock1;\r\nipc_lock_object(&msq->q_perm);\r\nif (!ipc_valid_object(&msq->q_perm)) {\r\nmsg = ERR_PTR(-EIDRM);\r\ngoto out_unlock0;\r\n}\r\nmsg = find_msg(msq, &msgtyp, mode);\r\nif (!IS_ERR(msg)) {\r\nif ((bufsz < msg->m_ts) && !(msgflg & MSG_NOERROR)) {\r\nmsg = ERR_PTR(-E2BIG);\r\ngoto out_unlock0;\r\n}\r\nif (msgflg & MSG_COPY) {\r\nmsg = copy_msg(msg, copy);\r\ngoto out_unlock0;\r\n}\r\nlist_del(&msg->m_list);\r\nmsq->q_qnum--;\r\nmsq->q_rtime = get_seconds();\r\nmsq->q_lrpid = task_tgid_vnr(current);\r\nmsq->q_cbytes -= msg->m_ts;\r\natomic_sub(msg->m_ts, &ns->msg_bytes);\r\natomic_dec(&ns->msg_hdrs);\r\nss_wakeup(&msq->q_senders, 0);\r\ngoto out_unlock0;\r\n}\r\nif (msgflg & IPC_NOWAIT) {\r\nmsg = ERR_PTR(-ENOMSG);\r\ngoto out_unlock0;\r\n}\r\nlist_add_tail(&msr_d.r_list, &msq->q_receivers);\r\nmsr_d.r_tsk = current;\r\nmsr_d.r_msgtype = msgtyp;\r\nmsr_d.r_mode = mode;\r\nif (msgflg & MSG_NOERROR)\r\nmsr_d.r_maxsize = INT_MAX;\r\nelse\r\nmsr_d.r_maxsize = bufsz;\r\nmsr_d.r_msg = ERR_PTR(-EAGAIN);\r\n__set_current_state(TASK_INTERRUPTIBLE);\r\nipc_unlock_object(&msq->q_perm);\r\nrcu_read_unlock();\r\nschedule();\r\nrcu_read_lock();\r\nfor (;;) {\r\nsmp_rmb();\r\nmsg = (struct msg_msg *)msr_d.r_msg;\r\nif (msg)\r\nbreak;\r\ncpu_relax();\r\n}\r\nif (msg != ERR_PTR(-EAGAIN))\r\ngoto out_unlock1;\r\nipc_lock_object(&msq->q_perm);\r\nmsg = (struct msg_msg *)msr_d.r_msg;\r\nif (msg != ERR_PTR(-EAGAIN))\r\ngoto out_unlock0;\r\nlist_del(&msr_d.r_list);\r\nif (signal_pending(current)) {\r\nmsg = ERR_PTR(-ERESTARTNOHAND);\r\ngoto out_unlock0;\r\n}\r\nipc_unlock_object(&msq->q_perm);\r\n}\r\nout_unlock0:\r\nipc_unlock_object(&msq->q_perm);\r\nout_unlock1:\r\nrcu_read_unlock();\r\nif (IS_ERR(msg)) {\r\nfree_copy(copy);\r\nreturn PTR_ERR(msg);\r\n}\r\nbufsz = msg_handler(buf, msg, bufsz);\r\nfree_msg(msg);\r\nreturn bufsz;\r\n}\r\nvoid msg_init_ns(struct ipc_namespace *ns)\r\n{\r\nns->msg_ctlmax = MSGMAX;\r\nns->msg_ctlmnb = MSGMNB;\r\nns->msg_ctlmni = MSGMNI;\r\natomic_set(&ns->msg_bytes, 0);\r\natomic_set(&ns->msg_hdrs, 0);\r\nipc_init_ids(&ns->ids[IPC_MSG_IDS]);\r\n}\r\nvoid msg_exit_ns(struct ipc_namespace *ns)\r\n{\r\nfree_ipcs(ns, &msg_ids(ns), freeque);\r\nidr_destroy(&ns->ids[IPC_MSG_IDS].ipcs_idr);\r\n}\r\nstatic int sysvipc_msg_proc_show(struct seq_file *s, void *it)\r\n{\r\nstruct user_namespace *user_ns = seq_user_ns(s);\r\nstruct msg_queue *msq = it;\r\nseq_printf(s,\r\n"%10d %10d %4o %10lu %10lu %5u %5u %5u %5u %5u %5u %10lu %10lu %10lu\n",\r\nmsq->q_perm.key,\r\nmsq->q_perm.id,\r\nmsq->q_perm.mode,\r\nmsq->q_cbytes,\r\nmsq->q_qnum,\r\nmsq->q_lspid,\r\nmsq->q_lrpid,\r\nfrom_kuid_munged(user_ns, msq->q_perm.uid),\r\nfrom_kgid_munged(user_ns, msq->q_perm.gid),\r\nfrom_kuid_munged(user_ns, msq->q_perm.cuid),\r\nfrom_kgid_munged(user_ns, msq->q_perm.cgid),\r\nmsq->q_stime,\r\nmsq->q_rtime,\r\nmsq->q_ctime);\r\nreturn 0;\r\n}\r\nvoid __init msg_init(void)\r\n{\r\nmsg_init_ns(&init_ipc_ns);\r\nipc_init_proc_interface("sysvipc/msg",\r\n" key msqid perms cbytes qnum lspid lrpid uid gid cuid cgid stime rtime ctime\n",\r\nIPC_MSG_IDS, sysvipc_msg_proc_show);\r\n}
