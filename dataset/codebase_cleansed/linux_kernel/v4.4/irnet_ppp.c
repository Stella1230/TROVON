static inline ssize_t\r\nirnet_ctrl_write(irnet_socket * ap,\r\nconst char __user *buf,\r\nsize_t count)\r\n{\r\nchar command[IRNET_MAX_COMMAND];\r\nchar * start;\r\nchar * next;\r\nint length;\r\nDENTER(CTRL_TRACE, "(ap=0x%p, count=%Zd)\n", ap, count);\r\nDABORT(count >= IRNET_MAX_COMMAND, -ENOMEM,\r\nCTRL_ERROR, "Too much data !!!\n");\r\nif(copy_from_user(command, buf, count))\r\n{\r\nDERROR(CTRL_ERROR, "Invalid user space pointer.\n");\r\nreturn -EFAULT;\r\n}\r\ncommand[count] = '\0';\r\nDEBUG(CTRL_INFO, "Command line received is ``%s'' (%Zd).\n",\r\ncommand, count);\r\nnext = command;\r\nwhile(next != NULL)\r\n{\r\nstart = next;\r\nstart = skip_spaces(start);\r\nnext = strchr(start, ',');\r\nif(next)\r\n{\r\n*next = '\0';\r\nlength = next - start;\r\nnext++;\r\n}\r\nelse\r\nlength = strlen(start);\r\nDEBUG(CTRL_INFO, "Found command ``%s'' (%d).\n", start, length);\r\nif(!strncmp(start, "name", 4))\r\n{\r\nif((length > 5) && (strcmp(start + 5, "any")))\r\n{\r\nwhile(isspace(start[length - 1]))\r\nlength--;\r\nDABORT(length < 5 || length > NICKNAME_MAX_LEN + 5,\r\n-EINVAL, CTRL_ERROR, "Invalid nickname.\n");\r\nmemcpy(ap->rname, start + 5, length - 5);\r\nap->rname[length - 5] = '\0';\r\n}\r\nelse\r\nap->rname[0] = '\0';\r\nDEBUG(CTRL_INFO, "Got rname = ``%s''\n", ap->rname);\r\ncontinue;\r\n}\r\nif((!strncmp(start, "addr", 4)) ||\r\n(!strncmp(start, "daddr", 5)) ||\r\n(!strncmp(start, "saddr", 5)))\r\n{\r\n__u32 addr = DEV_ADDR_ANY;\r\nif((length > 5) && (strcmp(start + 5, "any")))\r\n{\r\nchar * begp = start + 5;\r\nchar * endp;\r\nbegp = skip_spaces(begp);\r\naddr = simple_strtoul(begp, &endp, 16);\r\nDABORT(endp <= (start + 5), -EINVAL,\r\nCTRL_ERROR, "Invalid address.\n");\r\n}\r\nif(start[0] == 's')\r\n{\r\nap->rsaddr = addr;\r\nDEBUG(CTRL_INFO, "Got rsaddr = %08x\n", ap->rsaddr);\r\n}\r\nelse\r\n{\r\nap->rdaddr = addr;\r\nDEBUG(CTRL_INFO, "Got rdaddr = %08x\n", ap->rdaddr);\r\n}\r\ncontinue;\r\n}\r\nDABORT(1, -EINVAL, CTRL_ERROR, "Not a recognised IrNET command.\n");\r\n}\r\nreturn count;\r\n}\r\nstatic void\r\nirnet_get_discovery_log(irnet_socket * ap)\r\n{\r\n__u16 mask = irlmp_service_to_hint(S_LAN);\r\nap->discoveries = irlmp_get_discoveries(&ap->disco_number, mask,\r\nDISCOVERY_DEFAULT_SLOTS);\r\nif(ap->discoveries == NULL)\r\nap->disco_number = -1;\r\nDEBUG(CTRL_INFO, "Got the log (0x%p), size is %d\n",\r\nap->discoveries, ap->disco_number);\r\n}\r\nstatic inline int\r\nirnet_read_discovery_log(irnet_socket *ap, char *event, int buf_size)\r\n{\r\nint done_event = 0;\r\nDENTER(CTRL_TRACE, "(ap=0x%p, event=0x%p)\n",\r\nap, event);\r\nif(ap->disco_number == -1)\r\n{\r\nDEBUG(CTRL_INFO, "Already done\n");\r\nreturn 0;\r\n}\r\nif(ap->discoveries == NULL)\r\nirnet_get_discovery_log(ap);\r\nif(ap->disco_index < ap->disco_number)\r\n{\r\nsnprintf(event, buf_size,\r\n"Found %08x (%s) behind %08x {hints %02X-%02X}\n",\r\nap->discoveries[ap->disco_index].daddr,\r\nap->discoveries[ap->disco_index].info,\r\nap->discoveries[ap->disco_index].saddr,\r\nap->discoveries[ap->disco_index].hints[0],\r\nap->discoveries[ap->disco_index].hints[1]);\r\nDEBUG(CTRL_INFO, "Writing discovery %d : %s\n",\r\nap->disco_index, ap->discoveries[ap->disco_index].info);\r\ndone_event = 1;\r\nap->disco_index++;\r\n}\r\nif(ap->disco_index >= ap->disco_number)\r\n{\r\nDEBUG(CTRL_INFO, "Cleaning up log (0x%p)\n",\r\nap->discoveries);\r\nif(ap->discoveries != NULL)\r\n{\r\nkfree(ap->discoveries);\r\nap->discoveries = NULL;\r\n}\r\nap->disco_number = -1;\r\n}\r\nreturn done_event;\r\n}\r\nstatic inline ssize_t\r\nirnet_ctrl_read(irnet_socket * ap,\r\nstruct file * file,\r\nchar __user * buf,\r\nsize_t count)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nchar event[75];\r\nssize_t ret = 0;\r\nDENTER(CTRL_TRACE, "(ap=0x%p, count=%Zd)\n", ap, count);\r\n#ifdef INITIAL_DISCOVERY\r\nif (irnet_read_discovery_log(ap, event, sizeof(event)))\r\n{\r\ncount = min(strlen(event), count);\r\nif (copy_to_user(buf, event, count))\r\n{\r\nDERROR(CTRL_ERROR, "Invalid user space pointer.\n");\r\nreturn -EFAULT;\r\n}\r\nDEXIT(CTRL_TRACE, "\n");\r\nreturn count;\r\n}\r\n#endif\r\nadd_wait_queue(&irnet_events.rwait, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nfor(;;)\r\n{\r\nret = 0;\r\nif(ap->event_index != irnet_events.index)\r\nbreak;\r\nret = -EAGAIN;\r\nif(file->f_flags & O_NONBLOCK)\r\nbreak;\r\nret = -ERESTARTSYS;\r\nif(signal_pending(current))\r\nbreak;\r\nschedule();\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(&irnet_events.rwait, &wait);\r\nif(ret != 0)\r\n{\r\nDEXIT(CTRL_TRACE, " - ret %Zd\n", ret);\r\nreturn ret;\r\n}\r\nswitch(irnet_events.log[ap->event_index].event)\r\n{\r\ncase IRNET_DISCOVER:\r\nsnprintf(event, sizeof(event),\r\n"Discovered %08x (%s) behind %08x {hints %02X-%02X}\n",\r\nirnet_events.log[ap->event_index].daddr,\r\nirnet_events.log[ap->event_index].name,\r\nirnet_events.log[ap->event_index].saddr,\r\nirnet_events.log[ap->event_index].hints.byte[0],\r\nirnet_events.log[ap->event_index].hints.byte[1]);\r\nbreak;\r\ncase IRNET_EXPIRE:\r\nsnprintf(event, sizeof(event),\r\n"Expired %08x (%s) behind %08x {hints %02X-%02X}\n",\r\nirnet_events.log[ap->event_index].daddr,\r\nirnet_events.log[ap->event_index].name,\r\nirnet_events.log[ap->event_index].saddr,\r\nirnet_events.log[ap->event_index].hints.byte[0],\r\nirnet_events.log[ap->event_index].hints.byte[1]);\r\nbreak;\r\ncase IRNET_CONNECT_TO:\r\nsnprintf(event, sizeof(event), "Connected to %08x (%s) on ppp%d\n",\r\nirnet_events.log[ap->event_index].daddr,\r\nirnet_events.log[ap->event_index].name,\r\nirnet_events.log[ap->event_index].unit);\r\nbreak;\r\ncase IRNET_CONNECT_FROM:\r\nsnprintf(event, sizeof(event), "Connection from %08x (%s) on ppp%d\n",\r\nirnet_events.log[ap->event_index].daddr,\r\nirnet_events.log[ap->event_index].name,\r\nirnet_events.log[ap->event_index].unit);\r\nbreak;\r\ncase IRNET_REQUEST_FROM:\r\nsnprintf(event, sizeof(event), "Request from %08x (%s) behind %08x\n",\r\nirnet_events.log[ap->event_index].daddr,\r\nirnet_events.log[ap->event_index].name,\r\nirnet_events.log[ap->event_index].saddr);\r\nbreak;\r\ncase IRNET_NOANSWER_FROM:\r\nsnprintf(event, sizeof(event), "No-answer from %08x (%s) on ppp%d\n",\r\nirnet_events.log[ap->event_index].daddr,\r\nirnet_events.log[ap->event_index].name,\r\nirnet_events.log[ap->event_index].unit);\r\nbreak;\r\ncase IRNET_BLOCKED_LINK:\r\nsnprintf(event, sizeof(event), "Blocked link with %08x (%s) on ppp%d\n",\r\nirnet_events.log[ap->event_index].daddr,\r\nirnet_events.log[ap->event_index].name,\r\nirnet_events.log[ap->event_index].unit);\r\nbreak;\r\ncase IRNET_DISCONNECT_FROM:\r\nsnprintf(event, sizeof(event), "Disconnection from %08x (%s) on ppp%d\n",\r\nirnet_events.log[ap->event_index].daddr,\r\nirnet_events.log[ap->event_index].name,\r\nirnet_events.log[ap->event_index].unit);\r\nbreak;\r\ncase IRNET_DISCONNECT_TO:\r\nsnprintf(event, sizeof(event), "Disconnected to %08x (%s)\n",\r\nirnet_events.log[ap->event_index].daddr,\r\nirnet_events.log[ap->event_index].name);\r\nbreak;\r\ndefault:\r\nsnprintf(event, sizeof(event), "Bug\n");\r\n}\r\nap->event_index = (ap->event_index + 1) % IRNET_MAX_EVENTS;\r\nDEBUG(CTRL_INFO, "Event is :%s", event);\r\ncount = min(strlen(event), count);\r\nif (copy_to_user(buf, event, count))\r\n{\r\nDERROR(CTRL_ERROR, "Invalid user space pointer.\n");\r\nreturn -EFAULT;\r\n}\r\nDEXIT(CTRL_TRACE, "\n");\r\nreturn count;\r\n}\r\nstatic inline unsigned int\r\nirnet_ctrl_poll(irnet_socket * ap,\r\nstruct file * file,\r\npoll_table * wait)\r\n{\r\nunsigned int mask;\r\nDENTER(CTRL_TRACE, "(ap=0x%p)\n", ap);\r\npoll_wait(file, &irnet_events.rwait, wait);\r\nmask = POLLOUT | POLLWRNORM;\r\nif(ap->event_index != irnet_events.index)\r\nmask |= POLLIN | POLLRDNORM;\r\n#ifdef INITIAL_DISCOVERY\r\nif(ap->disco_number != -1)\r\n{\r\nif(ap->discoveries == NULL)\r\nirnet_get_discovery_log(ap);\r\nif(ap->disco_number != -1)\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\n#endif\r\nDEXIT(CTRL_TRACE, " - mask=0x%X\n", mask);\r\nreturn mask;\r\n}\r\nstatic int\r\ndev_irnet_open(struct inode * inode,\r\nstruct file * file)\r\n{\r\nstruct irnet_socket * ap;\r\nint err;\r\nDENTER(FS_TRACE, "(file=0x%p)\n", file);\r\n#ifdef SECURE_DEVIRNET\r\nif(!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\n#endif\r\nap = kzalloc(sizeof(*ap), GFP_KERNEL);\r\nDABORT(ap == NULL, -ENOMEM, FS_ERROR, "Can't allocate struct irnet...\n");\r\nap->file = file;\r\nap->ppp_open = 0;\r\nap->chan.private = ap;\r\nap->chan.ops = &irnet_ppp_ops;\r\nap->chan.mtu = (2048 - TTP_MAX_HEADER - 2 - PPP_HDRLEN);\r\nap->chan.hdrlen = 2 + TTP_MAX_HEADER;\r\nap->mru = (2048 - TTP_MAX_HEADER - 2 - PPP_HDRLEN);\r\nap->xaccm[0] = ~0U;\r\nap->xaccm[3] = 0x60000000U;\r\nap->raccm = ~0U;\r\nerr = irda_irnet_create(ap);\r\nif(err)\r\n{\r\nDERROR(FS_ERROR, "Can't setup IrDA link...\n");\r\nkfree(ap);\r\nreturn err;\r\n}\r\nap->event_index = irnet_events.index;\r\nmutex_init(&ap->lock);\r\nfile->private_data = ap;\r\nDEXIT(FS_TRACE, " - ap=0x%p\n", ap);\r\nreturn 0;\r\n}\r\nstatic int\r\ndev_irnet_close(struct inode * inode,\r\nstruct file * file)\r\n{\r\nirnet_socket * ap = file->private_data;\r\nDENTER(FS_TRACE, "(file=0x%p, ap=0x%p)\n",\r\nfile, ap);\r\nDABORT(ap == NULL, 0, FS_ERROR, "ap is NULL !!!\n");\r\nfile->private_data = NULL;\r\nirda_irnet_destroy(ap);\r\nif(ap->ppp_open)\r\n{\r\nDERROR(FS_ERROR, "Channel still registered - deregistering !\n");\r\nap->ppp_open = 0;\r\nppp_unregister_channel(&ap->chan);\r\n}\r\nkfree(ap);\r\nDEXIT(FS_TRACE, "\n");\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\ndev_irnet_write(struct file * file,\r\nconst char __user *buf,\r\nsize_t count,\r\nloff_t * ppos)\r\n{\r\nirnet_socket * ap = file->private_data;\r\nDPASS(FS_TRACE, "(file=0x%p, ap=0x%p, count=%Zd)\n",\r\nfile, ap, count);\r\nDABORT(ap == NULL, -ENXIO, FS_ERROR, "ap is NULL !!!\n");\r\nif(ap->ppp_open)\r\nreturn -EAGAIN;\r\nelse\r\nreturn irnet_ctrl_write(ap, buf, count);\r\n}\r\nstatic ssize_t\r\ndev_irnet_read(struct file * file,\r\nchar __user * buf,\r\nsize_t count,\r\nloff_t * ppos)\r\n{\r\nirnet_socket * ap = file->private_data;\r\nDPASS(FS_TRACE, "(file=0x%p, ap=0x%p, count=%Zd)\n",\r\nfile, ap, count);\r\nDABORT(ap == NULL, -ENXIO, FS_ERROR, "ap is NULL !!!\n");\r\nif(ap->ppp_open)\r\nreturn -EAGAIN;\r\nelse\r\nreturn irnet_ctrl_read(ap, file, buf, count);\r\n}\r\nstatic unsigned int\r\ndev_irnet_poll(struct file * file,\r\npoll_table * wait)\r\n{\r\nirnet_socket * ap = file->private_data;\r\nunsigned int mask;\r\nDENTER(FS_TRACE, "(file=0x%p, ap=0x%p)\n",\r\nfile, ap);\r\nmask = POLLOUT | POLLWRNORM;\r\nDABORT(ap == NULL, mask, FS_ERROR, "ap is NULL !!!\n");\r\nif(!ap->ppp_open)\r\nmask |= irnet_ctrl_poll(ap, file, wait);\r\nDEXIT(FS_TRACE, " - mask=0x%X\n", mask);\r\nreturn mask;\r\n}\r\nstatic long\r\ndev_irnet_ioctl(\r\nstruct file * file,\r\nunsigned int cmd,\r\nunsigned long arg)\r\n{\r\nirnet_socket * ap = file->private_data;\r\nint err;\r\nint val;\r\nvoid __user *argp = (void __user *)arg;\r\nDENTER(FS_TRACE, "(file=0x%p, ap=0x%p, cmd=0x%X)\n",\r\nfile, ap, cmd);\r\nDASSERT(ap != NULL, -ENXIO, PPP_ERROR, "ap is NULL...\n");\r\n#ifdef SECURE_DEVIRNET\r\nif(!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\n#endif\r\nerr = -EFAULT;\r\nswitch(cmd)\r\n{\r\ncase TIOCSETD:\r\nif(get_user(val, (int __user *)argp))\r\nbreak;\r\nif((val == N_SYNC_PPP) || (val == N_PPP))\r\n{\r\nDEBUG(FS_INFO, "Entering PPP discipline.\n");\r\nif (mutex_lock_interruptible(&ap->lock))\r\nreturn -EINTR;\r\nerr = ppp_register_channel(&ap->chan);\r\nif(err == 0)\r\n{\r\nap->ppp_open = 1;\r\nDEBUG(FS_INFO, "Trying to establish a connection.\n");\r\nirda_irnet_connect(ap);\r\n}\r\nelse\r\nDERROR(FS_ERROR, "Can't setup PPP channel...\n");\r\nmutex_unlock(&ap->lock);\r\n}\r\nelse\r\n{\r\nDEBUG(FS_INFO, "Exiting PPP discipline.\n");\r\nif (mutex_lock_interruptible(&ap->lock))\r\nreturn -EINTR;\r\nif(ap->ppp_open)\r\n{\r\nap->ppp_open = 0;\r\nppp_unregister_channel(&ap->chan);\r\n}\r\nelse\r\nDERROR(FS_ERROR, "Channel not registered !\n");\r\nerr = 0;\r\nmutex_unlock(&ap->lock);\r\n}\r\nbreak;\r\ncase PPPIOCGCHAN:\r\nif (mutex_lock_interruptible(&ap->lock))\r\nreturn -EINTR;\r\nif(ap->ppp_open && !put_user(ppp_channel_index(&ap->chan),\r\n(int __user *)argp))\r\nerr = 0;\r\nmutex_unlock(&ap->lock);\r\nbreak;\r\ncase PPPIOCGUNIT:\r\nif (mutex_lock_interruptible(&ap->lock))\r\nreturn -EINTR;\r\nif(ap->ppp_open && !put_user(ppp_unit_number(&ap->chan),\r\n(int __user *)argp))\r\nerr = 0;\r\nmutex_unlock(&ap->lock);\r\nbreak;\r\ncase PPPIOCGFLAGS:\r\ncase PPPIOCSFLAGS:\r\ncase PPPIOCGASYNCMAP:\r\ncase PPPIOCSASYNCMAP:\r\ncase PPPIOCGRASYNCMAP:\r\ncase PPPIOCSRASYNCMAP:\r\ncase PPPIOCGXASYNCMAP:\r\ncase PPPIOCSXASYNCMAP:\r\ncase PPPIOCGMRU:\r\ncase PPPIOCSMRU:\r\nDEBUG(FS_INFO, "Standard PPP ioctl.\n");\r\nif(!capable(CAP_NET_ADMIN))\r\nerr = -EPERM;\r\nelse {\r\nif (mutex_lock_interruptible(&ap->lock))\r\nreturn -EINTR;\r\nerr = ppp_irnet_ioctl(&ap->chan, cmd, arg);\r\nmutex_unlock(&ap->lock);\r\n}\r\nbreak;\r\ncase TCGETS:\r\nDEBUG(FS_INFO, "Get termios.\n");\r\nif (mutex_lock_interruptible(&ap->lock))\r\nreturn -EINTR;\r\n#ifndef TCGETS2\r\nif(!kernel_termios_to_user_termios((struct termios __user *)argp, &ap->termios))\r\nerr = 0;\r\n#else\r\nif(kernel_termios_to_user_termios_1((struct termios __user *)argp, &ap->termios))\r\nerr = 0;\r\n#endif\r\nmutex_unlock(&ap->lock);\r\nbreak;\r\ncase TCSETSF:\r\nDEBUG(FS_INFO, "Set termios.\n");\r\nif (mutex_lock_interruptible(&ap->lock))\r\nreturn -EINTR;\r\n#ifndef TCGETS2\r\nif(!user_termios_to_kernel_termios(&ap->termios, (struct termios __user *)argp))\r\nerr = 0;\r\n#else\r\nif(!user_termios_to_kernel_termios_1(&ap->termios, (struct termios __user *)argp))\r\nerr = 0;\r\n#endif\r\nmutex_unlock(&ap->lock);\r\nbreak;\r\ncase TIOCMBIS:\r\ncase TIOCMBIC:\r\ncase TIOCEXCL:\r\ncase TIOCNXCL:\r\nDEBUG(FS_INFO, "TTY compatibility.\n");\r\nerr = 0;\r\nbreak;\r\ncase TCGETA:\r\nDEBUG(FS_INFO, "TCGETA\n");\r\nbreak;\r\ncase TCFLSH:\r\nDEBUG(FS_INFO, "TCFLSH\n");\r\n#ifdef FLUSH_TO_PPP\r\nif (mutex_lock_interruptible(&ap->lock))\r\nreturn -EINTR;\r\nppp_output_wakeup(&ap->chan);\r\nmutex_unlock(&ap->lock);\r\n#endif\r\nerr = 0;\r\nbreak;\r\ncase FIONREAD:\r\nDEBUG(FS_INFO, "FIONREAD\n");\r\nval = 0;\r\nif(put_user(val, (int __user *)argp))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ndefault:\r\nDERROR(FS_ERROR, "Unsupported ioctl (0x%X)\n", cmd);\r\nerr = -ENOTTY;\r\n}\r\nDEXIT(FS_TRACE, " - err = 0x%X\n", err);\r\nreturn err;\r\n}\r\nstatic inline struct sk_buff *\r\nirnet_prepare_skb(irnet_socket * ap,\r\nstruct sk_buff * skb)\r\n{\r\nunsigned char * data;\r\nint proto;\r\nint islcp;\r\nint needaddr;\r\nDENTER(PPP_TRACE, "(ap=0x%p, skb=0x%p)\n",\r\nap, skb);\r\ndata = skb->data;\r\nproto = (data[0] << 8) + data[1];\r\nislcp = (proto == PPP_LCP) && (1 <= data[2]) && (data[2] <= 7);\r\nif((data[0] == 0) && (ap->flags & SC_COMP_PROT) && (!islcp))\r\nskb_pull(skb,1);\r\nneedaddr = 2*((ap->flags & SC_COMP_AC) == 0 || islcp);\r\nif((skb_headroom(skb) < (ap->max_header_size + needaddr)) ||\r\n(skb_shared(skb)))\r\n{\r\nstruct sk_buff * new_skb;\r\nDEBUG(PPP_INFO, "Reallocating skb\n");\r\nnew_skb = skb_realloc_headroom(skb, ap->max_header_size + needaddr);\r\ndev_kfree_skb(skb);\r\nDABORT(new_skb == NULL, NULL, PPP_ERROR, "Could not realloc skb\n");\r\nskb = new_skb;\r\n}\r\nif(needaddr)\r\n{\r\nskb_push(skb, 2);\r\nskb->data[0] = PPP_ALLSTATIONS;\r\nskb->data[1] = PPP_UI;\r\n}\r\nDEXIT(PPP_TRACE, "\n");\r\nreturn skb;\r\n}\r\nstatic int\r\nppp_irnet_send(struct ppp_channel * chan,\r\nstruct sk_buff * skb)\r\n{\r\nirnet_socket * self = (struct irnet_socket *) chan->private;\r\nint ret;\r\nDENTER(PPP_TRACE, "(channel=0x%p, ap/self=0x%p)\n",\r\nchan, self);\r\nDASSERT(self != NULL, 0, PPP_ERROR, "Self is NULL !!!\n");\r\nif(!(test_bit(0, &self->ttp_open)))\r\n{\r\n#ifdef CONNECT_IN_SEND\r\nirda_irnet_connect(self);\r\n#endif\r\nDEBUG(PPP_INFO, "IrTTP not ready ! (%ld-%ld)\n",\r\nself->ttp_open, self->ttp_connect);\r\n#ifdef BLOCK_WHEN_CONNECT\r\nif(test_bit(0, &self->ttp_connect))\r\n{\r\nreturn 0;\r\n}\r\n#endif\r\ndev_kfree_skb(skb);\r\nreturn 1;\r\n}\r\nif(self->tx_flow != FLOW_START)\r\nDRETURN(0, PPP_INFO, "IrTTP queue full (%d skbs)...\n",\r\nskb_queue_len(&self->tsap->tx_queue));\r\nskb = irnet_prepare_skb(self, skb);\r\nDABORT(skb == NULL, 1, PPP_ERROR, "Prepare skb for Tx failed.\n");\r\nret = irttp_data_request(self->tsap, skb);\r\nif(ret < 0)\r\n{\r\nDERROR(PPP_ERROR, "IrTTP doesn't like this packet !!! (0x%X)\n", ret);\r\n}\r\nDEXIT(PPP_TRACE, "\n");\r\nreturn 1;\r\n}\r\nstatic int\r\nppp_irnet_ioctl(struct ppp_channel * chan,\r\nunsigned int cmd,\r\nunsigned long arg)\r\n{\r\nirnet_socket * ap = (struct irnet_socket *) chan->private;\r\nint err;\r\nint val;\r\nu32 accm[8];\r\nvoid __user *argp = (void __user *)arg;\r\nDENTER(PPP_TRACE, "(channel=0x%p, ap=0x%p, cmd=0x%X)\n",\r\nchan, ap, cmd);\r\nDASSERT(ap != NULL, -ENXIO, PPP_ERROR, "ap is NULL...\n");\r\nerr = -EFAULT;\r\nswitch(cmd)\r\n{\r\ncase PPPIOCGFLAGS:\r\nval = ap->flags | ap->rbits;\r\nif(put_user(val, (int __user *) argp))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCSFLAGS:\r\nif(get_user(val, (int __user *) argp))\r\nbreak;\r\nap->flags = val & ~SC_RCV_BITS;\r\nap->rbits = val & SC_RCV_BITS;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCGASYNCMAP:\r\nif(put_user(ap->xaccm[0], (u32 __user *) argp))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCSASYNCMAP:\r\nif(get_user(ap->xaccm[0], (u32 __user *) argp))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCGRASYNCMAP:\r\nif(put_user(ap->raccm, (u32 __user *) argp))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCSRASYNCMAP:\r\nif(get_user(ap->raccm, (u32 __user *) argp))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCGXASYNCMAP:\r\nif(copy_to_user(argp, ap->xaccm, sizeof(ap->xaccm)))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCSXASYNCMAP:\r\nif(copy_from_user(accm, argp, sizeof(accm)))\r\nbreak;\r\naccm[2] &= ~0x40000000U;\r\naccm[3] |= 0x60000000U;\r\nmemcpy(ap->xaccm, accm, sizeof(ap->xaccm));\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCGMRU:\r\nif(put_user(ap->mru, (int __user *) argp))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCSMRU:\r\nif(get_user(val, (int __user *) argp))\r\nbreak;\r\nif(val < PPP_MRU)\r\nval = PPP_MRU;\r\nap->mru = val;\r\nerr = 0;\r\nbreak;\r\ndefault:\r\nDEBUG(PPP_INFO, "Unsupported ioctl (0x%X)\n", cmd);\r\nerr = -ENOIOCTLCMD;\r\n}\r\nDEXIT(PPP_TRACE, " - err = 0x%X\n", err);\r\nreturn err;\r\n}\r\nstatic inline int __init\r\nppp_irnet_init(void)\r\n{\r\nint err = 0;\r\nDENTER(MODULE_TRACE, "()\n");\r\nerr = misc_register(&irnet_misc_device);\r\nDEXIT(MODULE_TRACE, "\n");\r\nreturn err;\r\n}\r\nstatic inline void __exit\r\nppp_irnet_cleanup(void)\r\n{\r\nDENTER(MODULE_TRACE, "()\n");\r\nmisc_deregister(&irnet_misc_device);\r\nDEXIT(MODULE_TRACE, "\n");\r\n}\r\nstatic int __init\r\nirnet_init(void)\r\n{\r\nint err;\r\nerr = irda_irnet_init();\r\nif(!err)\r\nerr = ppp_irnet_init();\r\nreturn err;\r\n}\r\nstatic void __exit\r\nirnet_cleanup(void)\r\n{\r\nirda_irnet_cleanup();\r\nppp_irnet_cleanup();\r\n}
