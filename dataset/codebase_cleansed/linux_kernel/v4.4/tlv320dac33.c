static inline unsigned int dac33_read_reg_cache(struct snd_soc_codec *codec,\r\nunsigned reg)\r\n{\r\nu8 *cache = codec->reg_cache;\r\nif (reg >= DAC33_CACHEREGNUM)\r\nreturn 0;\r\nreturn cache[reg];\r\n}\r\nstatic inline void dac33_write_reg_cache(struct snd_soc_codec *codec,\r\nu8 reg, u8 value)\r\n{\r\nu8 *cache = codec->reg_cache;\r\nif (reg >= DAC33_CACHEREGNUM)\r\nreturn;\r\ncache[reg] = value;\r\n}\r\nstatic int dac33_read(struct snd_soc_codec *codec, unsigned int reg,\r\nu8 *value)\r\n{\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\nint val, ret = 0;\r\n*value = reg & 0xff;\r\nif (dac33->chip_power) {\r\nval = i2c_smbus_read_byte_data(codec->control_data, value[0]);\r\nif (val < 0) {\r\ndev_err(codec->dev, "Read failed (%d)\n", val);\r\nvalue[0] = dac33_read_reg_cache(codec, reg);\r\nret = val;\r\n} else {\r\nvalue[0] = val;\r\ndac33_write_reg_cache(codec, reg, val);\r\n}\r\n} else {\r\nvalue[0] = dac33_read_reg_cache(codec, reg);\r\n}\r\nreturn ret;\r\n}\r\nstatic int dac33_write(struct snd_soc_codec *codec, unsigned int reg,\r\nunsigned int value)\r\n{\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\nu8 data[2];\r\nint ret = 0;\r\ndata[0] = reg & 0xff;\r\ndata[1] = value & 0xff;\r\ndac33_write_reg_cache(codec, data[0], data[1]);\r\nif (dac33->chip_power) {\r\nret = codec->hw_write(codec->control_data, data, 2);\r\nif (ret != 2)\r\ndev_err(codec->dev, "Write failed (%d)\n", ret);\r\nelse\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dac33_write_locked(struct snd_soc_codec *codec, unsigned int reg,\r\nunsigned int value)\r\n{\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nmutex_lock(&dac33->mutex);\r\nret = dac33_write(codec, reg, value);\r\nmutex_unlock(&dac33->mutex);\r\nreturn ret;\r\n}\r\nstatic int dac33_write16(struct snd_soc_codec *codec, unsigned int reg,\r\nunsigned int value)\r\n{\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\nu8 data[3];\r\nint ret = 0;\r\ndata[0] = reg & 0xff;\r\ndata[1] = (value >> 8) & 0xff;\r\ndata[2] = value & 0xff;\r\ndac33_write_reg_cache(codec, data[0], data[1]);\r\ndac33_write_reg_cache(codec, data[0] + 1, data[2]);\r\nif (dac33->chip_power) {\r\ndata[0] |= DAC33_I2C_ADDR_AUTOINC;\r\nret = codec->hw_write(codec->control_data, data, 3);\r\nif (ret != 3)\r\ndev_err(codec->dev, "Write failed (%d)\n", ret);\r\nelse\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void dac33_init_chip(struct snd_soc_codec *codec)\r\n{\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\nif (unlikely(!dac33->chip_power))\r\nreturn;\r\ndac33_write(codec, DAC33_DAC_CTRL_A, DAC33_DACRATE(0));\r\ndac33_write(codec, DAC33_DAC_CTRL_B, DAC33_DACSRCR_RIGHT |\r\nDAC33_DACSRCL_LEFT);\r\ndac33_write(codec, DAC33_DAC_CTRL_C, 0x00);\r\ndac33_write(codec, DAC33_ANA_VOL_SOFT_STEP_CTRL, DAC33_VOLCLKEN);\r\ndac33_write(codec, DAC33_LDAC_DIG_VOL_CTRL,\r\ndac33_read_reg_cache(codec, DAC33_LDAC_DIG_VOL_CTRL));\r\ndac33_write(codec, DAC33_RDAC_DIG_VOL_CTRL,\r\ndac33_read_reg_cache(codec, DAC33_RDAC_DIG_VOL_CTRL));\r\ndac33_write(codec, DAC33_LINEL_TO_LLO_VOL,\r\ndac33_read_reg_cache(codec, DAC33_LINEL_TO_LLO_VOL));\r\ndac33_write(codec, DAC33_LINER_TO_RLO_VOL,\r\ndac33_read_reg_cache(codec, DAC33_LINER_TO_RLO_VOL));\r\ndac33_write(codec, DAC33_OUT_AMP_CTRL,\r\ndac33_read_reg_cache(codec, DAC33_OUT_AMP_CTRL));\r\ndac33_write(codec, DAC33_LDAC_PWR_CTRL,\r\ndac33_read_reg_cache(codec, DAC33_LDAC_PWR_CTRL));\r\ndac33_write(codec, DAC33_RDAC_PWR_CTRL,\r\ndac33_read_reg_cache(codec, DAC33_RDAC_PWR_CTRL));\r\n}\r\nstatic inline int dac33_read_id(struct snd_soc_codec *codec)\r\n{\r\nint i, ret = 0;\r\nu8 reg;\r\nfor (i = 0; i < 3; i++) {\r\nret = dac33_read(codec, DAC33_DEVICE_ID_MSB + i, &reg);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline void dac33_soft_power(struct snd_soc_codec *codec, int power)\r\n{\r\nu8 reg;\r\nreg = dac33_read_reg_cache(codec, DAC33_PWR_CTRL);\r\nif (power)\r\nreg |= DAC33_PDNALLB;\r\nelse\r\nreg &= ~(DAC33_PDNALLB | DAC33_OSCPDNB |\r\nDAC33_DACRPDNB | DAC33_DACLPDNB);\r\ndac33_write(codec, DAC33_PWR_CTRL, reg);\r\n}\r\nstatic inline void dac33_disable_digital(struct snd_soc_codec *codec)\r\n{\r\nu8 reg;\r\nreg = dac33_read_reg_cache(codec, DAC33_SER_AUDIOIF_CTRL_B);\r\nreg &= ~DAC33_BCLKON;\r\ndac33_write(codec, DAC33_SER_AUDIOIF_CTRL_B, reg);\r\nreg = dac33_read_reg_cache(codec, DAC33_PWR_CTRL);\r\nreg &= ~(DAC33_OSCPDNB | DAC33_DACRPDNB | DAC33_DACLPDNB);\r\ndac33_write(codec, DAC33_PWR_CTRL, reg);\r\n}\r\nstatic int dac33_hard_power(struct snd_soc_codec *codec, int power)\r\n{\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\nmutex_lock(&dac33->mutex);\r\nif (unlikely(power == dac33->chip_power)) {\r\ndev_dbg(codec->dev, "Trying to set the same power state: %s\n",\r\npower ? "ON" : "OFF");\r\ngoto exit;\r\n}\r\nif (power) {\r\nret = regulator_bulk_enable(ARRAY_SIZE(dac33->supplies),\r\ndac33->supplies);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to enable supplies: %d\n", ret);\r\ngoto exit;\r\n}\r\nif (dac33->power_gpio >= 0)\r\ngpio_set_value(dac33->power_gpio, 1);\r\ndac33->chip_power = 1;\r\n} else {\r\ndac33_soft_power(codec, 0);\r\nif (dac33->power_gpio >= 0)\r\ngpio_set_value(dac33->power_gpio, 0);\r\nret = regulator_bulk_disable(ARRAY_SIZE(dac33->supplies),\r\ndac33->supplies);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to disable supplies: %d\n", ret);\r\ngoto exit;\r\n}\r\ndac33->chip_power = 0;\r\n}\r\nexit:\r\nmutex_unlock(&dac33->mutex);\r\nreturn ret;\r\n}\r\nstatic int dac33_playback_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nif (likely(dac33->substream)) {\r\ndac33_calculate_times(dac33->substream, codec);\r\ndac33_prepare_chip(dac33->substream, codec);\r\n}\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\ndac33_disable_digital(codec);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dac33_get_fifo_mode(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = dac33->fifo_mode;\r\nreturn 0;\r\n}\r\nstatic int dac33_set_fifo_mode(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\nif (dac33->fifo_mode == ucontrol->value.integer.value[0])\r\nreturn 0;\r\nif (snd_soc_codec_is_active(codec))\r\nreturn -EPERM;\r\nif (ucontrol->value.integer.value[0] < 0 ||\r\nucontrol->value.integer.value[0] >= DAC33_FIFO_LAST_MODE)\r\nret = -EINVAL;\r\nelse\r\ndac33->fifo_mode = ucontrol->value.integer.value[0];\r\nreturn ret;\r\n}\r\nstatic int dac33_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {\r\nret = dac33_hard_power(codec, 1);\r\nif (ret != 0)\r\nreturn ret;\r\ndac33_init_chip(codec);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF)\r\nreturn 0;\r\nret = dac33_hard_power(codec, 0);\r\nif (ret != 0)\r\nreturn ret;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void dac33_prefill_handler(struct tlv320dac33_priv *dac33)\r\n{\r\nstruct snd_soc_codec *codec = dac33->codec;\r\nunsigned int delay;\r\nunsigned long flags;\r\nswitch (dac33->fifo_mode) {\r\ncase DAC33_FIFO_MODE1:\r\ndac33_write16(codec, DAC33_NSAMPLE_MSB,\r\nDAC33_THRREG(dac33->nsample));\r\nspin_lock_irqsave(&dac33->lock, flags);\r\ndac33->t_stamp2 = ktime_to_us(ktime_get());\r\ndac33->t_stamp1 = dac33->t_stamp2;\r\nspin_unlock_irqrestore(&dac33->lock, flags);\r\ndac33_write16(codec, DAC33_PREFILL_MSB,\r\nDAC33_THRREG(dac33->alarm_threshold));\r\ndelay = SAMPLES_TO_US(dac33->burst_rate,\r\ndac33->alarm_threshold) + 1000;\r\nusleep_range(delay, delay + 500);\r\ndac33_write(codec, DAC33_FIFO_IRQ_MASK, DAC33_MAT);\r\nbreak;\r\ncase DAC33_FIFO_MODE7:\r\nspin_lock_irqsave(&dac33->lock, flags);\r\ndac33->t_stamp1 = ktime_to_us(ktime_get());\r\ndac33->t_stamp1 -= dac33->mode7_us_to_lthr;\r\nspin_unlock_irqrestore(&dac33->lock, flags);\r\ndac33_write16(codec, DAC33_PREFILL_MSB,\r\nDAC33_THRREG(DAC33_MODE7_MARGIN));\r\ndac33_write(codec, DAC33_FIFO_IRQ_MASK, DAC33_MUT);\r\nbreak;\r\ndefault:\r\ndev_warn(codec->dev, "Unhandled FIFO mode: %d\n",\r\ndac33->fifo_mode);\r\nbreak;\r\n}\r\n}\r\nstatic inline void dac33_playback_handler(struct tlv320dac33_priv *dac33)\r\n{\r\nstruct snd_soc_codec *codec = dac33->codec;\r\nunsigned long flags;\r\nswitch (dac33->fifo_mode) {\r\ncase DAC33_FIFO_MODE1:\r\nspin_lock_irqsave(&dac33->lock, flags);\r\ndac33->t_stamp2 = ktime_to_us(ktime_get());\r\nspin_unlock_irqrestore(&dac33->lock, flags);\r\ndac33_write16(codec, DAC33_NSAMPLE_MSB,\r\nDAC33_THRREG(dac33->nsample));\r\nbreak;\r\ncase DAC33_FIFO_MODE7:\r\nbreak;\r\ndefault:\r\ndev_warn(codec->dev, "Unhandled FIFO mode: %d\n",\r\ndac33->fifo_mode);\r\nbreak;\r\n}\r\n}\r\nstatic void dac33_work(struct work_struct *work)\r\n{\r\nstruct snd_soc_codec *codec;\r\nstruct tlv320dac33_priv *dac33;\r\nu8 reg;\r\ndac33 = container_of(work, struct tlv320dac33_priv, work);\r\ncodec = dac33->codec;\r\nmutex_lock(&dac33->mutex);\r\nswitch (dac33->state) {\r\ncase DAC33_PREFILL:\r\ndac33->state = DAC33_PLAYBACK;\r\ndac33_prefill_handler(dac33);\r\nbreak;\r\ncase DAC33_PLAYBACK:\r\ndac33_playback_handler(dac33);\r\nbreak;\r\ncase DAC33_IDLE:\r\nbreak;\r\ncase DAC33_FLUSH:\r\ndac33->state = DAC33_IDLE;\r\ndac33_write(codec, DAC33_FIFO_IRQ_MASK, 0);\r\nreg = dac33_read_reg_cache(codec, DAC33_FIFO_CTRL_A);\r\nreg |= DAC33_FIFOFLUSH;\r\ndac33_write(codec, DAC33_FIFO_CTRL_A, reg);\r\nbreak;\r\n}\r\nmutex_unlock(&dac33->mutex);\r\n}\r\nstatic irqreturn_t dac33_interrupt_handler(int irq, void *dev)\r\n{\r\nstruct snd_soc_codec *codec = dev;\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\nunsigned long flags;\r\nspin_lock_irqsave(&dac33->lock, flags);\r\ndac33->t_stamp1 = ktime_to_us(ktime_get());\r\nspin_unlock_irqrestore(&dac33->lock, flags);\r\nif (dac33->fifo_mode != DAC33_FIFO_MODE7)\r\nqueue_work(dac33->dac33_wq, &dac33->work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void dac33_oscwait(struct snd_soc_codec *codec)\r\n{\r\nint timeout = 60;\r\nu8 reg;\r\ndo {\r\nusleep_range(1000, 2000);\r\ndac33_read(codec, DAC33_INT_OSC_STATUS, &reg);\r\n} while (((reg & 0x03) != DAC33_OSCSTATUS_NORMAL) && timeout--);\r\nif ((reg & 0x03) != DAC33_OSCSTATUS_NORMAL)\r\ndev_err(codec->dev,\r\n"internal oscillator calibration failed\n");\r\n}\r\nstatic int dac33_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\ndac33->substream = substream;\r\nreturn 0;\r\n}\r\nstatic void dac33_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\ndac33->substream = NULL;\r\n}\r\nstatic int dac33_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\nswitch (params_rate(params)) {\r\ncase 44100:\r\ncase 48000:\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unsupported rate %d\n",\r\nparams_rate(params));\r\nreturn -EINVAL;\r\n}\r\nswitch (params_width(params)) {\r\ncase 16:\r\ndac33->fifo_size = DAC33_FIFO_SIZE_16BIT;\r\ndac33->burst_rate = CALC_BURST_RATE(dac33->burst_bclkdiv, 32);\r\nbreak;\r\ncase 32:\r\ndac33->fifo_size = DAC33_FIFO_SIZE_24BIT;\r\ndac33->burst_rate = CALC_BURST_RATE(dac33->burst_bclkdiv, 64);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unsupported width %d\n",\r\nparams_width(params));\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dac33_prepare_chip(struct snd_pcm_substream *substream,\r\nstruct snd_soc_codec *codec)\r\n{\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int oscset, ratioset, pwr_ctrl, reg_tmp;\r\nu8 aictrl_a, aictrl_b, fifoctrl_a;\r\nswitch (substream->runtime->rate) {\r\ncase 44100:\r\ncase 48000:\r\noscset = CALC_OSCSET(substream->runtime->rate, dac33->refclk);\r\nratioset = CALC_RATIOSET(substream->runtime->rate,\r\ndac33->refclk);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unsupported rate %d\n",\r\nsubstream->runtime->rate);\r\nreturn -EINVAL;\r\n}\r\naictrl_a = dac33_read_reg_cache(codec, DAC33_SER_AUDIOIF_CTRL_A);\r\naictrl_a &= ~(DAC33_NCYCL_MASK | DAC33_WLEN_MASK);\r\nfifoctrl_a = dac33_read_reg_cache(codec, DAC33_FIFO_CTRL_A);\r\nfifoctrl_a &= ~DAC33_FIFOFLUSH;\r\nfifoctrl_a &= ~DAC33_WIDTH;\r\nswitch (substream->runtime->format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\naictrl_a |= (DAC33_NCYCL_16 | DAC33_WLEN_16);\r\nfifoctrl_a |= DAC33_WIDTH;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\naictrl_a |= (DAC33_NCYCL_32 | DAC33_WLEN_24);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unsupported format %d\n",\r\nsubstream->runtime->format);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&dac33->mutex);\r\nif (!dac33->chip_power) {\r\nmutex_unlock(&dac33->mutex);\r\nreturn 0;\r\n}\r\ndac33_soft_power(codec, 0);\r\ndac33_soft_power(codec, 1);\r\nreg_tmp = dac33_read_reg_cache(codec, DAC33_INT_OSC_CTRL);\r\ndac33_write(codec, DAC33_INT_OSC_CTRL, reg_tmp);\r\ndac33_write16(codec, DAC33_INT_OSC_FREQ_RAT_A, oscset);\r\ndac33_write(codec, DAC33_CALIB_TIME, 96);\r\ndac33_write(codec, DAC33_INT_OSC_CTRL_B, DAC33_ADJTHRSHLD(2) |\r\nDAC33_ADJSTEP(1));\r\ndac33_write(codec, DAC33_INT_OSC_CTRL_C, DAC33_REFDIV(4));\r\npwr_ctrl = dac33_read_reg_cache(codec, DAC33_PWR_CTRL);\r\npwr_ctrl |= DAC33_OSCPDNB | DAC33_DACRPDNB | DAC33_DACLPDNB;\r\ndac33_write(codec, DAC33_PWR_CTRL, pwr_ctrl);\r\ndac33_oscwait(codec);\r\nif (dac33->fifo_mode) {\r\ndac33_write(codec, DAC33_ASRC_CTRL_A, DAC33_SRCLKDIV(1));\r\ndac33_write(codec, DAC33_ASRC_CTRL_B, 1);\r\ndac33_write16(codec, DAC33_SRC_REF_CLK_RATIO_A, ratioset);\r\ndac33_write(codec, DAC33_INTP_CTRL_A, DAC33_INTPM_AHIGH);\r\n} else {\r\ndac33_write(codec, DAC33_ASRC_CTRL_A, DAC33_SRCBYP);\r\ndac33_write(codec, DAC33_ASRC_CTRL_B, 0);\r\n}\r\nswitch (dac33->fifo_mode) {\r\ncase DAC33_FIFO_MODE1:\r\ndac33_write(codec, DAC33_FIFO_IRQ_MODE_B,\r\nDAC33_ATM(DAC33_FIFO_IRQ_MODE_LEVEL));\r\nbreak;\r\ncase DAC33_FIFO_MODE7:\r\ndac33_write(codec, DAC33_FIFO_IRQ_MODE_A,\r\nDAC33_UTM(DAC33_FIFO_IRQ_MODE_LEVEL));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\naictrl_b = dac33_read_reg_cache(codec, DAC33_SER_AUDIOIF_CTRL_B);\r\nswitch (dac33->fifo_mode) {\r\ncase DAC33_FIFO_MODE1:\r\nfifoctrl_a &= ~DAC33_FBYPAS;\r\nfifoctrl_a &= ~DAC33_FAUTO;\r\nif (dac33->keep_bclk)\r\naictrl_b |= DAC33_BCLKON;\r\nelse\r\naictrl_b &= ~DAC33_BCLKON;\r\nbreak;\r\ncase DAC33_FIFO_MODE7:\r\nfifoctrl_a &= ~DAC33_FBYPAS;\r\nfifoctrl_a |= DAC33_FAUTO;\r\nif (dac33->keep_bclk)\r\naictrl_b |= DAC33_BCLKON;\r\nelse\r\naictrl_b &= ~DAC33_BCLKON;\r\nbreak;\r\ndefault:\r\nfifoctrl_a |= DAC33_FBYPAS;\r\naictrl_b |= DAC33_BCLKON;\r\nbreak;\r\n}\r\ndac33_write(codec, DAC33_FIFO_CTRL_A, fifoctrl_a);\r\ndac33_write(codec, DAC33_SER_AUDIOIF_CTRL_A, aictrl_a);\r\ndac33_write(codec, DAC33_SER_AUDIOIF_CTRL_B, aictrl_b);\r\nif (dac33->fifo_mode)\r\ndac33_write(codec, DAC33_SER_AUDIOIF_CTRL_C,\r\ndac33->burst_bclkdiv);\r\nelse\r\nif (substream->runtime->format == SNDRV_PCM_FORMAT_S16_LE)\r\ndac33_write(codec, DAC33_SER_AUDIOIF_CTRL_C, 32);\r\nelse\r\ndac33_write(codec, DAC33_SER_AUDIOIF_CTRL_C, 16);\r\nswitch (dac33->fifo_mode) {\r\ncase DAC33_FIFO_MODE1:\r\ndac33_write16(codec, DAC33_ATHR_MSB,\r\nDAC33_THRREG(dac33->alarm_threshold));\r\nbreak;\r\ncase DAC33_FIFO_MODE7:\r\ndac33_write16(codec, DAC33_UTHR_MSB, DAC33_THRREG(dac33->uthr));\r\ndac33_write16(codec, DAC33_LTHR_MSB,\r\nDAC33_THRREG(DAC33_MODE7_MARGIN));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmutex_unlock(&dac33->mutex);\r\nreturn 0;\r\n}\r\nstatic void dac33_calculate_times(struct snd_pcm_substream *substream,\r\nstruct snd_soc_codec *codec)\r\n{\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int period_size = substream->runtime->period_size;\r\nunsigned int rate = substream->runtime->rate;\r\nunsigned int nsample_limit;\r\nif (!dac33->fifo_mode)\r\nreturn;\r\nswitch (dac33->fifo_mode) {\r\ncase DAC33_FIFO_MODE1:\r\ndac33->alarm_threshold = US_TO_SAMPLES(rate,\r\ndac33->mode1_latency);\r\nnsample_limit = dac33->fifo_size - dac33->alarm_threshold;\r\nif (period_size <= dac33->alarm_threshold)\r\ndac33->nsample = period_size *\r\n((dac33->alarm_threshold / period_size) +\r\n(dac33->alarm_threshold % period_size ?\r\n1 : 0));\r\nelse if (period_size > nsample_limit)\r\ndac33->nsample = nsample_limit;\r\nelse\r\ndac33->nsample = period_size;\r\ndac33->mode1_us_burst = SAMPLES_TO_US(dac33->burst_rate,\r\ndac33->nsample);\r\ndac33->t_stamp1 = 0;\r\ndac33->t_stamp2 = 0;\r\nbreak;\r\ncase DAC33_FIFO_MODE7:\r\ndac33->uthr = UTHR_FROM_PERIOD_SIZE(period_size, rate,\r\ndac33->burst_rate) + 9;\r\nif (dac33->uthr > (dac33->fifo_size - DAC33_MODE7_MARGIN))\r\ndac33->uthr = dac33->fifo_size - DAC33_MODE7_MARGIN;\r\nif (dac33->uthr < (DAC33_MODE7_MARGIN + 10))\r\ndac33->uthr = (DAC33_MODE7_MARGIN + 10);\r\ndac33->mode7_us_to_lthr =\r\nSAMPLES_TO_US(substream->runtime->rate,\r\ndac33->uthr - DAC33_MODE7_MARGIN + 1);\r\ndac33->t_stamp1 = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int dac33_pcm_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (dac33->fifo_mode) {\r\ndac33->state = DAC33_PREFILL;\r\nqueue_work(dac33->dac33_wq, &dac33->work);\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (dac33->fifo_mode) {\r\ndac33->state = DAC33_FLUSH;\r\nqueue_work(dac33->dac33_wq, &dac33->work);\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic snd_pcm_sframes_t dac33_dai_delay(\r\nstruct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\nunsigned long long t0, t1, t_now;\r\nunsigned int time_delta, uthr;\r\nint samples_out, samples_in, samples;\r\nsnd_pcm_sframes_t delay = 0;\r\nunsigned long flags;\r\nswitch (dac33->fifo_mode) {\r\ncase DAC33_FIFO_BYPASS:\r\nbreak;\r\ncase DAC33_FIFO_MODE1:\r\nspin_lock_irqsave(&dac33->lock, flags);\r\nt0 = dac33->t_stamp1;\r\nt1 = dac33->t_stamp2;\r\nspin_unlock_irqrestore(&dac33->lock, flags);\r\nt_now = ktime_to_us(ktime_get());\r\nif (!t1)\r\ngoto out;\r\nif (t0 > t1) {\r\ntime_delta = t_now - t0;\r\nsamples_out = time_delta ? US_TO_SAMPLES(\r\nsubstream->runtime->rate,\r\ntime_delta) : 0;\r\nif (likely(dac33->alarm_threshold > samples_out))\r\ndelay = dac33->alarm_threshold - samples_out;\r\nelse\r\ndelay = 0;\r\n} else if ((t_now - t1) <= dac33->mode1_us_burst) {\r\ntime_delta = t_now - t0;\r\nsamples_out = time_delta ? US_TO_SAMPLES(\r\nsubstream->runtime->rate,\r\ntime_delta) : 0;\r\ntime_delta = t_now - t1;\r\nsamples_in = time_delta ? US_TO_SAMPLES(\r\ndac33->burst_rate,\r\ntime_delta) : 0;\r\nsamples = dac33->alarm_threshold;\r\nsamples += (samples_in - samples_out);\r\nif (likely(samples > 0))\r\ndelay = samples;\r\nelse\r\ndelay = 0;\r\n} else {\r\ntime_delta = t_now - t0;\r\nsamples_out = time_delta ? US_TO_SAMPLES(\r\nsubstream->runtime->rate,\r\ntime_delta) : 0;\r\nsamples_in = dac33->nsample;\r\nsamples = dac33->alarm_threshold;\r\nsamples += (samples_in - samples_out);\r\nif (likely(samples > 0))\r\ndelay = samples > dac33->fifo_size ?\r\ndac33->fifo_size : samples;\r\nelse\r\ndelay = 0;\r\n}\r\nbreak;\r\ncase DAC33_FIFO_MODE7:\r\nspin_lock_irqsave(&dac33->lock, flags);\r\nt0 = dac33->t_stamp1;\r\nuthr = dac33->uthr;\r\nspin_unlock_irqrestore(&dac33->lock, flags);\r\nt_now = ktime_to_us(ktime_get());\r\nif (!t0)\r\ngoto out;\r\nif (t_now <= t0) {\r\ndelay = uthr;\r\ngoto out;\r\n}\r\ntime_delta = t_now - t0;\r\nif (time_delta <= dac33->mode7_us_to_lthr) {\r\nsamples_out = US_TO_SAMPLES(\r\nsubstream->runtime->rate,\r\ntime_delta);\r\nif (likely(uthr > samples_out))\r\ndelay = uthr - samples_out;\r\nelse\r\ndelay = 0;\r\n} else {\r\ntime_delta = time_delta - dac33->mode7_us_to_lthr;\r\nsamples_out = US_TO_SAMPLES(\r\nsubstream->runtime->rate,\r\ntime_delta);\r\nsamples_in = US_TO_SAMPLES(\r\ndac33->burst_rate,\r\ntime_delta);\r\ndelay = DAC33_MODE7_MARGIN + samples_in - samples_out;\r\nif (unlikely(delay > uthr))\r\ndelay = uthr;\r\n}\r\nbreak;\r\ndefault:\r\ndev_warn(codec->dev, "Unhandled FIFO mode: %d\n",\r\ndac33->fifo_mode);\r\nbreak;\r\n}\r\nout:\r\nreturn delay;\r\n}\r\nstatic int dac33_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\nu8 ioc_reg, asrcb_reg;\r\nioc_reg = dac33_read_reg_cache(codec, DAC33_INT_OSC_CTRL);\r\nasrcb_reg = dac33_read_reg_cache(codec, DAC33_ASRC_CTRL_B);\r\nswitch (clk_id) {\r\ncase TLV320DAC33_MCLK:\r\nioc_reg |= DAC33_REFSEL;\r\nasrcb_reg |= DAC33_SRCREFSEL;\r\nbreak;\r\ncase TLV320DAC33_SLEEPCLK:\r\nioc_reg &= ~DAC33_REFSEL;\r\nasrcb_reg &= ~DAC33_SRCREFSEL;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid clock ID (%d)\n", clk_id);\r\nbreak;\r\n}\r\ndac33->refclk = freq;\r\ndac33_write_reg_cache(codec, DAC33_INT_OSC_CTRL, ioc_reg);\r\ndac33_write_reg_cache(codec, DAC33_ASRC_CTRL_B, asrcb_reg);\r\nreturn 0;\r\n}\r\nstatic int dac33_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\nu8 aictrl_a, aictrl_b;\r\naictrl_a = dac33_read_reg_cache(codec, DAC33_SER_AUDIOIF_CTRL_A);\r\naictrl_b = dac33_read_reg_cache(codec, DAC33_SER_AUDIOIF_CTRL_B);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\naictrl_a |= (DAC33_MSBCLK | DAC33_MSWCLK);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nif (dac33->fifo_mode) {\r\ndev_err(codec->dev, "FIFO mode requires master mode\n");\r\nreturn -EINVAL;\r\n} else\r\naictrl_a &= ~(DAC33_MSBCLK | DAC33_MSWCLK);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\naictrl_a &= ~DAC33_AFMT_MASK;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\naictrl_a |= DAC33_AFMT_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\naictrl_a |= DAC33_AFMT_DSP;\r\naictrl_b &= ~DAC33_DATA_DELAY_MASK;\r\naictrl_b |= DAC33_DATA_DELAY(0);\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\naictrl_a |= DAC33_AFMT_RIGHT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\naictrl_a |= DAC33_AFMT_LEFT_J;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unsupported format (%u)\n",\r\nfmt & SND_SOC_DAIFMT_FORMAT_MASK);\r\nreturn -EINVAL;\r\n}\r\ndac33_write_reg_cache(codec, DAC33_SER_AUDIOIF_CTRL_A, aictrl_a);\r\ndac33_write_reg_cache(codec, DAC33_SER_AUDIOIF_CTRL_B, aictrl_b);\r\nreturn 0;\r\n}\r\nstatic int dac33_soc_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\ncodec->control_data = dac33->control_data;\r\ncodec->hw_write = (hw_write_t) i2c_master_send;\r\ndac33->codec = codec;\r\nret = dac33_hard_power(codec, 1);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to power up codec: %d\n", ret);\r\ngoto err_power;\r\n}\r\nret = dac33_read_id(codec);\r\ndac33_hard_power(codec, 0);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to read chip ID: %d\n", ret);\r\nret = -ENODEV;\r\ngoto err_power;\r\n}\r\nif (dac33->irq >= 0) {\r\nret = request_irq(dac33->irq, dac33_interrupt_handler,\r\nIRQF_TRIGGER_RISING,\r\ncodec->component.name, codec);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Could not request IRQ%d (%d)\n",\r\ndac33->irq, ret);\r\ndac33->irq = -1;\r\n}\r\nif (dac33->irq != -1) {\r\ndac33->dac33_wq =\r\ncreate_singlethread_workqueue("tlv320dac33");\r\nif (dac33->dac33_wq == NULL) {\r\nfree_irq(dac33->irq, codec);\r\nreturn -ENOMEM;\r\n}\r\nINIT_WORK(&dac33->work, dac33_work);\r\n}\r\n}\r\nif (dac33->irq >= 0)\r\nsnd_soc_add_codec_controls(codec, dac33_mode_snd_controls,\r\nARRAY_SIZE(dac33_mode_snd_controls));\r\nerr_power:\r\nreturn ret;\r\n}\r\nstatic int dac33_soc_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct tlv320dac33_priv *dac33 = snd_soc_codec_get_drvdata(codec);\r\nif (dac33->irq >= 0) {\r\nfree_irq(dac33->irq, dac33->codec);\r\ndestroy_workqueue(dac33->dac33_wq);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dac33_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tlv320dac33_platform_data *pdata;\r\nstruct tlv320dac33_priv *dac33;\r\nint ret, i;\r\nif (client->dev.platform_data == NULL) {\r\ndev_err(&client->dev, "Platform data not set\n");\r\nreturn -ENODEV;\r\n}\r\npdata = client->dev.platform_data;\r\ndac33 = devm_kzalloc(&client->dev, sizeof(struct tlv320dac33_priv),\r\nGFP_KERNEL);\r\nif (dac33 == NULL)\r\nreturn -ENOMEM;\r\ndac33->control_data = client;\r\nmutex_init(&dac33->mutex);\r\nspin_lock_init(&dac33->lock);\r\ni2c_set_clientdata(client, dac33);\r\ndac33->power_gpio = pdata->power_gpio;\r\ndac33->burst_bclkdiv = pdata->burst_bclkdiv;\r\ndac33->keep_bclk = pdata->keep_bclk;\r\ndac33->mode1_latency = pdata->mode1_latency;\r\nif (!dac33->mode1_latency)\r\ndac33->mode1_latency = 10000;\r\ndac33->irq = client->irq;\r\ndac33->fifo_mode = DAC33_FIFO_BYPASS;\r\nif (dac33->power_gpio >= 0) {\r\nret = gpio_request(dac33->power_gpio, "tlv320dac33 reset");\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"Failed to request reset GPIO (%d)\n",\r\ndac33->power_gpio);\r\ngoto err_gpio;\r\n}\r\ngpio_direction_output(dac33->power_gpio, 0);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(dac33->supplies); i++)\r\ndac33->supplies[i].supply = dac33_supply_names[i];\r\nret = devm_regulator_bulk_get(&client->dev, ARRAY_SIZE(dac33->supplies),\r\ndac33->supplies);\r\nif (ret != 0) {\r\ndev_err(&client->dev, "Failed to request supplies: %d\n", ret);\r\ngoto err_get;\r\n}\r\nret = snd_soc_register_codec(&client->dev,\r\n&soc_codec_dev_tlv320dac33, &dac33_dai, 1);\r\nif (ret < 0)\r\ngoto err_get;\r\nreturn ret;\r\nerr_get:\r\nif (dac33->power_gpio >= 0)\r\ngpio_free(dac33->power_gpio);\r\nerr_gpio:\r\nreturn ret;\r\n}\r\nstatic int dac33_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct tlv320dac33_priv *dac33 = i2c_get_clientdata(client);\r\nif (unlikely(dac33->chip_power))\r\ndac33_hard_power(dac33->codec, 0);\r\nif (dac33->power_gpio >= 0)\r\ngpio_free(dac33->power_gpio);\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
