static ssize_t bonding_show_bonds(struct class *cls,\r\nstruct class_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bond_net *bn =\r\ncontainer_of(attr, struct bond_net, class_attr_bonding_masters);\r\nint res = 0;\r\nstruct bonding *bond;\r\nrtnl_lock();\r\nlist_for_each_entry(bond, &bn->dev_list, bond_list) {\r\nif (res > (PAGE_SIZE - IFNAMSIZ)) {\r\nif ((PAGE_SIZE - res) > 10)\r\nres = PAGE_SIZE - 10;\r\nres += sprintf(buf + res, "++more++ ");\r\nbreak;\r\n}\r\nres += sprintf(buf + res, "%s ", bond->dev->name);\r\n}\r\nif (res)\r\nbuf[res-1] = '\n';\r\nrtnl_unlock();\r\nreturn res;\r\n}\r\nstatic struct net_device *bond_get_by_name(struct bond_net *bn, const char *ifname)\r\n{\r\nstruct bonding *bond;\r\nlist_for_each_entry(bond, &bn->dev_list, bond_list) {\r\nif (strncmp(bond->dev->name, ifname, IFNAMSIZ) == 0)\r\nreturn bond->dev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic ssize_t bonding_store_bonds(struct class *cls,\r\nstruct class_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nstruct bond_net *bn =\r\ncontainer_of(attr, struct bond_net, class_attr_bonding_masters);\r\nchar command[IFNAMSIZ + 1] = {0, };\r\nchar *ifname;\r\nint rv, res = count;\r\nsscanf(buffer, "%16s", command);\r\nifname = command + 1;\r\nif ((strlen(command) <= 1) ||\r\n!dev_valid_name(ifname))\r\ngoto err_no_cmd;\r\nif (command[0] == '+') {\r\npr_info("%s is being created...\n", ifname);\r\nrv = bond_create(bn->net, ifname);\r\nif (rv) {\r\nif (rv == -EEXIST)\r\npr_info("%s already exists\n", ifname);\r\nelse\r\npr_info("%s creation failed\n", ifname);\r\nres = rv;\r\n}\r\n} else if (command[0] == '-') {\r\nstruct net_device *bond_dev;\r\nrtnl_lock();\r\nbond_dev = bond_get_by_name(bn, ifname);\r\nif (bond_dev) {\r\npr_info("%s is being deleted...\n", ifname);\r\nunregister_netdevice(bond_dev);\r\n} else {\r\npr_err("unable to delete non-existent %s\n", ifname);\r\nres = -ENODEV;\r\n}\r\nrtnl_unlock();\r\n} else\r\ngoto err_no_cmd;\r\nreturn res;\r\nerr_no_cmd:\r\npr_err("no command found in bonding_masters - use +ifname or -ifname\n");\r\nreturn -EPERM;\r\n}\r\nstatic ssize_t bonding_sysfs_store_option(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nconst struct bond_option *opt;\r\nint ret;\r\nopt = bond_opt_get_by_name(attr->attr.name);\r\nif (WARN_ON(!opt))\r\nreturn -ENOENT;\r\nret = bond_opt_tryset_rtnl(bond, opt->id, (char *)buffer);\r\nif (!ret)\r\nret = count;\r\nreturn ret;\r\n}\r\nstatic ssize_t bonding_show_slaves(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nstruct list_head *iter;\r\nstruct slave *slave;\r\nint res = 0;\r\nif (!rtnl_trylock())\r\nreturn restart_syscall();\r\nbond_for_each_slave(bond, slave, iter) {\r\nif (res > (PAGE_SIZE - IFNAMSIZ)) {\r\nif ((PAGE_SIZE - res) > 10)\r\nres = PAGE_SIZE - 10;\r\nres += sprintf(buf + res, "++more++ ");\r\nbreak;\r\n}\r\nres += sprintf(buf + res, "%s ", slave->dev->name);\r\n}\r\nrtnl_unlock();\r\nif (res)\r\nbuf[res-1] = '\n';\r\nreturn res;\r\n}\r\nstatic ssize_t bonding_show_mode(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nconst struct bond_opt_value *val;\r\nval = bond_opt_get_val(BOND_OPT_MODE, BOND_MODE(bond));\r\nreturn sprintf(buf, "%s %d\n", val->string, BOND_MODE(bond));\r\n}\r\nstatic ssize_t bonding_show_xmit_hash(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nconst struct bond_opt_value *val;\r\nval = bond_opt_get_val(BOND_OPT_XMIT_HASH, bond->params.xmit_policy);\r\nreturn sprintf(buf, "%s %d\n", val->string, bond->params.xmit_policy);\r\n}\r\nstatic ssize_t bonding_show_arp_validate(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nconst struct bond_opt_value *val;\r\nval = bond_opt_get_val(BOND_OPT_ARP_VALIDATE,\r\nbond->params.arp_validate);\r\nreturn sprintf(buf, "%s %d\n", val->string, bond->params.arp_validate);\r\n}\r\nstatic ssize_t bonding_show_arp_all_targets(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nconst struct bond_opt_value *val;\r\nval = bond_opt_get_val(BOND_OPT_ARP_ALL_TARGETS,\r\nbond->params.arp_all_targets);\r\nreturn sprintf(buf, "%s %d\n",\r\nval->string, bond->params.arp_all_targets);\r\n}\r\nstatic ssize_t bonding_show_fail_over_mac(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nconst struct bond_opt_value *val;\r\nval = bond_opt_get_val(BOND_OPT_FAIL_OVER_MAC,\r\nbond->params.fail_over_mac);\r\nreturn sprintf(buf, "%s %d\n", val->string, bond->params.fail_over_mac);\r\n}\r\nstatic ssize_t bonding_show_arp_interval(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%d\n", bond->params.arp_interval);\r\n}\r\nstatic ssize_t bonding_show_arp_targets(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nint i, res = 0;\r\nfor (i = 0; i < BOND_MAX_ARP_TARGETS; i++) {\r\nif (bond->params.arp_targets[i])\r\nres += sprintf(buf + res, "%pI4 ",\r\n&bond->params.arp_targets[i]);\r\n}\r\nif (res)\r\nbuf[res-1] = '\n';\r\nreturn res;\r\n}\r\nstatic ssize_t bonding_show_downdelay(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%d\n", bond->params.downdelay * bond->params.miimon);\r\n}\r\nstatic ssize_t bonding_show_updelay(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%d\n", bond->params.updelay * bond->params.miimon);\r\n}\r\nstatic ssize_t bonding_show_lacp(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nconst struct bond_opt_value *val;\r\nval = bond_opt_get_val(BOND_OPT_LACP_RATE, bond->params.lacp_fast);\r\nreturn sprintf(buf, "%s %d\n", val->string, bond->params.lacp_fast);\r\n}\r\nstatic ssize_t bonding_show_min_links(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%u\n", bond->params.min_links);\r\n}\r\nstatic ssize_t bonding_show_ad_select(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nconst struct bond_opt_value *val;\r\nval = bond_opt_get_val(BOND_OPT_AD_SELECT, bond->params.ad_select);\r\nreturn sprintf(buf, "%s %d\n", val->string, bond->params.ad_select);\r\n}\r\nstatic ssize_t bonding_show_num_peer_notif(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%d\n", bond->params.num_peer_notif);\r\n}\r\nstatic ssize_t bonding_show_miimon(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%d\n", bond->params.miimon);\r\n}\r\nstatic ssize_t bonding_show_primary(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nstruct slave *primary;\r\nint count = 0;\r\nrcu_read_lock();\r\nprimary = rcu_dereference(bond->primary_slave);\r\nif (primary)\r\ncount = sprintf(buf, "%s\n", primary->dev->name);\r\nrcu_read_unlock();\r\nreturn count;\r\n}\r\nstatic ssize_t bonding_show_primary_reselect(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nconst struct bond_opt_value *val;\r\nval = bond_opt_get_val(BOND_OPT_PRIMARY_RESELECT,\r\nbond->params.primary_reselect);\r\nreturn sprintf(buf, "%s %d\n",\r\nval->string, bond->params.primary_reselect);\r\n}\r\nstatic ssize_t bonding_show_carrier(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%d\n", bond->params.use_carrier);\r\n}\r\nstatic ssize_t bonding_show_active_slave(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nstruct net_device *slave_dev;\r\nint count = 0;\r\nrcu_read_lock();\r\nslave_dev = bond_option_active_slave_get_rcu(bond);\r\nif (slave_dev)\r\ncount = sprintf(buf, "%s\n", slave_dev->name);\r\nrcu_read_unlock();\r\nreturn count;\r\n}\r\nstatic ssize_t bonding_show_mii_status(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nbool active = !!rcu_access_pointer(bond->curr_active_slave);\r\nreturn sprintf(buf, "%s\n", active ? "up" : "down");\r\n}\r\nstatic ssize_t bonding_show_ad_aggregator(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint count = 0;\r\nstruct bonding *bond = to_bond(d);\r\nif (BOND_MODE(bond) == BOND_MODE_8023AD) {\r\nstruct ad_info ad_info;\r\ncount = sprintf(buf, "%d\n",\r\nbond_3ad_get_active_agg_info(bond, &ad_info)\r\n? 0 : ad_info.aggregator_id);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t bonding_show_ad_num_ports(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint count = 0;\r\nstruct bonding *bond = to_bond(d);\r\nif (BOND_MODE(bond) == BOND_MODE_8023AD) {\r\nstruct ad_info ad_info;\r\ncount = sprintf(buf, "%d\n",\r\nbond_3ad_get_active_agg_info(bond, &ad_info)\r\n? 0 : ad_info.ports);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t bonding_show_ad_actor_key(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint count = 0;\r\nstruct bonding *bond = to_bond(d);\r\nif (BOND_MODE(bond) == BOND_MODE_8023AD && capable(CAP_NET_ADMIN)) {\r\nstruct ad_info ad_info;\r\ncount = sprintf(buf, "%d\n",\r\nbond_3ad_get_active_agg_info(bond, &ad_info)\r\n? 0 : ad_info.actor_key);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t bonding_show_ad_partner_key(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint count = 0;\r\nstruct bonding *bond = to_bond(d);\r\nif (BOND_MODE(bond) == BOND_MODE_8023AD && capable(CAP_NET_ADMIN)) {\r\nstruct ad_info ad_info;\r\ncount = sprintf(buf, "%d\n",\r\nbond_3ad_get_active_agg_info(bond, &ad_info)\r\n? 0 : ad_info.partner_key);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t bonding_show_ad_partner_mac(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint count = 0;\r\nstruct bonding *bond = to_bond(d);\r\nif (BOND_MODE(bond) == BOND_MODE_8023AD && capable(CAP_NET_ADMIN)) {\r\nstruct ad_info ad_info;\r\nif (!bond_3ad_get_active_agg_info(bond, &ad_info))\r\ncount = sprintf(buf, "%pM\n", ad_info.partner_system);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t bonding_show_queue_id(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nstruct list_head *iter;\r\nstruct slave *slave;\r\nint res = 0;\r\nif (!rtnl_trylock())\r\nreturn restart_syscall();\r\nbond_for_each_slave(bond, slave, iter) {\r\nif (res > (PAGE_SIZE - IFNAMSIZ - 6)) {\r\nif ((PAGE_SIZE - res) > 10)\r\nres = PAGE_SIZE - 10;\r\nres += sprintf(buf + res, "++more++ ");\r\nbreak;\r\n}\r\nres += sprintf(buf + res, "%s:%d ",\r\nslave->dev->name, slave->queue_id);\r\n}\r\nif (res)\r\nbuf[res-1] = '\n';\r\nrtnl_unlock();\r\nreturn res;\r\n}\r\nstatic ssize_t bonding_show_slaves_active(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%d\n", bond->params.all_slaves_active);\r\n}\r\nstatic ssize_t bonding_show_resend_igmp(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%d\n", bond->params.resend_igmp);\r\n}\r\nstatic ssize_t bonding_show_lp_interval(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%d\n", bond->params.lp_interval);\r\n}\r\nstatic ssize_t bonding_show_tlb_dynamic_lb(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%d\n", bond->params.tlb_dynamic_lb);\r\n}\r\nstatic ssize_t bonding_show_packets_per_slave(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nunsigned int packets_per_slave = bond->params.packets_per_slave;\r\nreturn sprintf(buf, "%u\n", packets_per_slave);\r\n}\r\nstatic ssize_t bonding_show_ad_actor_sys_prio(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nif (BOND_MODE(bond) == BOND_MODE_8023AD && capable(CAP_NET_ADMIN))\r\nreturn sprintf(buf, "%hu\n", bond->params.ad_actor_sys_prio);\r\nreturn 0;\r\n}\r\nstatic ssize_t bonding_show_ad_actor_system(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nif (BOND_MODE(bond) == BOND_MODE_8023AD && capable(CAP_NET_ADMIN))\r\nreturn sprintf(buf, "%pM\n", bond->params.ad_actor_system);\r\nreturn 0;\r\n}\r\nstatic ssize_t bonding_show_ad_user_port_key(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nif (BOND_MODE(bond) == BOND_MODE_8023AD && capable(CAP_NET_ADMIN))\r\nreturn sprintf(buf, "%hu\n", bond->params.ad_user_port_key);\r\nreturn 0;\r\n}\r\nint bond_create_sysfs(struct bond_net *bn)\r\n{\r\nint ret;\r\nbn->class_attr_bonding_masters = class_attr_bonding_masters;\r\nsysfs_attr_init(&bn->class_attr_bonding_masters.attr);\r\nret = netdev_class_create_file_ns(&bn->class_attr_bonding_masters,\r\nbn->net);\r\nif (ret == -EEXIST) {\r\nif (__dev_get_by_name(bn->net,\r\nclass_attr_bonding_masters.attr.name))\r\npr_err("network device named %s already exists in sysfs\n",\r\nclass_attr_bonding_masters.attr.name);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nvoid bond_destroy_sysfs(struct bond_net *bn)\r\n{\r\nnetdev_class_remove_file_ns(&bn->class_attr_bonding_masters, bn->net);\r\n}\r\nvoid bond_prepare_sysfs_group(struct bonding *bond)\r\n{\r\nbond->dev->sysfs_groups[0] = &bonding_group;\r\n}
