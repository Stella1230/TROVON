static int qat_uclo_init_ae_data(struct icp_qat_uclo_objhandle *obj_handle,\r\nunsigned int ae, unsigned int image_num)\r\n{\r\nstruct icp_qat_uclo_aedata *ae_data;\r\nstruct icp_qat_uclo_encapme *encap_image;\r\nstruct icp_qat_uclo_page *page = NULL;\r\nstruct icp_qat_uclo_aeslice *ae_slice = NULL;\r\nae_data = &obj_handle->ae_data[ae];\r\nencap_image = &obj_handle->ae_uimage[image_num];\r\nae_slice = &ae_data->ae_slices[ae_data->slice_num];\r\nae_slice->encap_image = encap_image;\r\nif (encap_image->img_ptr) {\r\nae_slice->ctx_mask_assigned =\r\nencap_image->img_ptr->ctx_assigned;\r\nae_data->eff_ustore_size = obj_handle->ustore_phy_size;\r\n} else {\r\nae_slice->ctx_mask_assigned = 0;\r\n}\r\nae_slice->region = kzalloc(sizeof(*ae_slice->region), GFP_KERNEL);\r\nif (!ae_slice->region)\r\nreturn -ENOMEM;\r\nae_slice->page = kzalloc(sizeof(*ae_slice->page), GFP_KERNEL);\r\nif (!ae_slice->page)\r\ngoto out_err;\r\npage = ae_slice->page;\r\npage->encap_page = encap_image->page;\r\nae_slice->page->region = ae_slice->region;\r\nae_data->slice_num++;\r\nreturn 0;\r\nout_err:\r\nkfree(ae_slice->region);\r\nae_slice->region = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic int qat_uclo_free_ae_data(struct icp_qat_uclo_aedata *ae_data)\r\n{\r\nunsigned int i;\r\nif (!ae_data) {\r\npr_err("QAT: bad argument, ae_data is NULL\n ");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ae_data->slice_num; i++) {\r\nkfree(ae_data->ae_slices[i].region);\r\nae_data->ae_slices[i].region = NULL;\r\nkfree(ae_data->ae_slices[i].page);\r\nae_data->ae_slices[i].page = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic char *qat_uclo_get_string(struct icp_qat_uof_strtable *str_table,\r\nunsigned int str_offset)\r\n{\r\nif ((!str_table->table_len) || (str_offset > str_table->table_len))\r\nreturn NULL;\r\nreturn (char *)(((unsigned long)(str_table->strings)) + str_offset);\r\n}\r\nstatic int qat_uclo_check_format(struct icp_qat_uof_filehdr *hdr)\r\n{\r\nint maj = hdr->maj_ver & 0xff;\r\nint min = hdr->min_ver & 0xff;\r\nif (hdr->file_id != ICP_QAT_UOF_FID) {\r\npr_err("QAT: Invalid header 0x%x\n", hdr->file_id);\r\nreturn -EINVAL;\r\n}\r\nif (min != ICP_QAT_UOF_MINVER || maj != ICP_QAT_UOF_MAJVER) {\r\npr_err("QAT: bad UOF version, major 0x%x, minor 0x%x\n",\r\nmaj, min);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void qat_uclo_wr_sram_by_words(struct icp_qat_fw_loader_handle *handle,\r\nunsigned int addr, unsigned int *val,\r\nunsigned int num_in_bytes)\r\n{\r\nunsigned int outval;\r\nunsigned char *ptr = (unsigned char *)val;\r\nwhile (num_in_bytes) {\r\nmemcpy(&outval, ptr, 4);\r\nSRAM_WRITE(handle, addr, outval);\r\nnum_in_bytes -= 4;\r\nptr += 4;\r\naddr += 4;\r\n}\r\n}\r\nstatic void qat_uclo_wr_umem_by_words(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned int addr,\r\nunsigned int *val,\r\nunsigned int num_in_bytes)\r\n{\r\nunsigned int outval;\r\nunsigned char *ptr = (unsigned char *)val;\r\naddr >>= 0x2;\r\nwhile (num_in_bytes) {\r\nmemcpy(&outval, ptr, 4);\r\nqat_hal_wr_umem(handle, ae, addr++, 1, &outval);\r\nnum_in_bytes -= 4;\r\nptr += 4;\r\n}\r\n}\r\nstatic void qat_uclo_batch_wr_umem(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae,\r\nstruct icp_qat_uof_batch_init\r\n*umem_init_header)\r\n{\r\nstruct icp_qat_uof_batch_init *umem_init;\r\nif (!umem_init_header)\r\nreturn;\r\numem_init = umem_init_header->next;\r\nwhile (umem_init) {\r\nunsigned int addr, *value, size;\r\nae = umem_init->ae;\r\naddr = umem_init->addr;\r\nvalue = umem_init->value;\r\nsize = umem_init->size;\r\nqat_uclo_wr_umem_by_words(handle, ae, addr, value, size);\r\numem_init = umem_init->next;\r\n}\r\n}\r\nstatic void\r\nqat_uclo_cleanup_batch_init_list(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_uof_batch_init **base)\r\n{\r\nstruct icp_qat_uof_batch_init *umem_init;\r\numem_init = *base;\r\nwhile (umem_init) {\r\nstruct icp_qat_uof_batch_init *pre;\r\npre = umem_init;\r\numem_init = umem_init->next;\r\nkfree(pre);\r\n}\r\n*base = NULL;\r\n}\r\nstatic int qat_uclo_parse_num(char *str, unsigned int *num)\r\n{\r\nchar buf[16] = {0};\r\nunsigned long ae = 0;\r\nint i;\r\nstrncpy(buf, str, 15);\r\nfor (i = 0; i < 16; i++) {\r\nif (!isdigit(buf[i])) {\r\nbuf[i] = '\0';\r\nbreak;\r\n}\r\n}\r\nif ((kstrtoul(buf, 10, &ae)))\r\nreturn -EFAULT;\r\n*num = (unsigned int)ae;\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_fetch_initmem_ae(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_uof_initmem *init_mem,\r\nunsigned int size_range, unsigned int *ae)\r\n{\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nchar *str;\r\nif ((init_mem->addr + init_mem->num_in_bytes) > (size_range << 0x2)) {\r\npr_err("QAT: initmem is out of range");\r\nreturn -EINVAL;\r\n}\r\nif (init_mem->scope != ICP_QAT_UOF_LOCAL_SCOPE) {\r\npr_err("QAT: Memory scope for init_mem error\n");\r\nreturn -EINVAL;\r\n}\r\nstr = qat_uclo_get_string(&obj_handle->str_table, init_mem->sym_name);\r\nif (!str) {\r\npr_err("QAT: AE name assigned in UOF init table is NULL\n");\r\nreturn -EINVAL;\r\n}\r\nif (qat_uclo_parse_num(str, ae)) {\r\npr_err("QAT: Parse num for AE number failed\n");\r\nreturn -EINVAL;\r\n}\r\nif (*ae >= ICP_QAT_UCLO_MAX_AE) {\r\npr_err("QAT: ae %d out of range\n", *ae);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_create_batch_init_list(struct icp_qat_fw_loader_handle\r\n*handle, struct icp_qat_uof_initmem\r\n*init_mem, unsigned int ae,\r\nstruct icp_qat_uof_batch_init\r\n**init_tab_base)\r\n{\r\nstruct icp_qat_uof_batch_init *init_header, *tail;\r\nstruct icp_qat_uof_batch_init *mem_init, *tail_old;\r\nstruct icp_qat_uof_memvar_attr *mem_val_attr;\r\nunsigned int i, flag = 0;\r\nmem_val_attr =\r\n(struct icp_qat_uof_memvar_attr *)((unsigned long)init_mem +\r\nsizeof(struct icp_qat_uof_initmem));\r\ninit_header = *init_tab_base;\r\nif (!init_header) {\r\ninit_header = kzalloc(sizeof(*init_header), GFP_KERNEL);\r\nif (!init_header)\r\nreturn -ENOMEM;\r\ninit_header->size = 1;\r\n*init_tab_base = init_header;\r\nflag = 1;\r\n}\r\ntail_old = init_header;\r\nwhile (tail_old->next)\r\ntail_old = tail_old->next;\r\ntail = tail_old;\r\nfor (i = 0; i < init_mem->val_attr_num; i++) {\r\nmem_init = kzalloc(sizeof(*mem_init), GFP_KERNEL);\r\nif (!mem_init)\r\ngoto out_err;\r\nmem_init->ae = ae;\r\nmem_init->addr = init_mem->addr + mem_val_attr->offset_in_byte;\r\nmem_init->value = &mem_val_attr->value;\r\nmem_init->size = 4;\r\nmem_init->next = NULL;\r\ntail->next = mem_init;\r\ntail = mem_init;\r\ninit_header->size += qat_hal_get_ins_num();\r\nmem_val_attr++;\r\n}\r\nreturn 0;\r\nout_err:\r\nwhile (tail_old) {\r\nmem_init = tail_old->next;\r\nkfree(tail_old);\r\ntail_old = mem_init;\r\n}\r\nif (flag)\r\nkfree(*init_tab_base);\r\nreturn -ENOMEM;\r\n}\r\nstatic int qat_uclo_init_lmem_seg(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_uof_initmem *init_mem)\r\n{\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nunsigned int ae;\r\nif (qat_uclo_fetch_initmem_ae(handle, init_mem,\r\nICP_QAT_UCLO_MAX_LMEM_REG, &ae))\r\nreturn -EINVAL;\r\nif (qat_uclo_create_batch_init_list(handle, init_mem, ae,\r\n&obj_handle->lm_init_tab[ae]))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_init_umem_seg(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_uof_initmem *init_mem)\r\n{\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nunsigned int ae, ustore_size, uaddr, i;\r\nustore_size = obj_handle->ustore_phy_size;\r\nif (qat_uclo_fetch_initmem_ae(handle, init_mem, ustore_size, &ae))\r\nreturn -EINVAL;\r\nif (qat_uclo_create_batch_init_list(handle, init_mem, ae,\r\n&obj_handle->umem_init_tab[ae]))\r\nreturn -EINVAL;\r\nuaddr = (init_mem->addr + init_mem->num_in_bytes) >> 0x2;\r\nfor (i = 0; i < obj_handle->ae_data[ae].slice_num; i++) {\r\nif (obj_handle->ae_data[ae].ae_slices[i].\r\nencap_image->uwords_num < uaddr)\r\nobj_handle->ae_data[ae].ae_slices[i].\r\nencap_image->uwords_num = uaddr;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_init_ae_memory(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_uof_initmem *init_mem)\r\n{\r\nswitch (init_mem->region) {\r\ncase ICP_QAT_UOF_LMEM_REGION:\r\nif (qat_uclo_init_lmem_seg(handle, init_mem))\r\nreturn -EINVAL;\r\nbreak;\r\ncase ICP_QAT_UOF_UMEM_REGION:\r\nif (qat_uclo_init_umem_seg(handle, init_mem))\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\npr_err("QAT: initmem region error. region type=0x%x\n",\r\ninit_mem->region);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_init_ustore(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_uclo_encapme *image)\r\n{\r\nunsigned int i;\r\nstruct icp_qat_uclo_encap_page *page;\r\nstruct icp_qat_uof_image *uof_image;\r\nunsigned char ae;\r\nunsigned int ustore_size;\r\nunsigned int patt_pos;\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nuint64_t *fill_data;\r\nuof_image = image->img_ptr;\r\nfill_data = kcalloc(ICP_QAT_UCLO_MAX_USTORE, sizeof(uint64_t),\r\nGFP_KERNEL);\r\nif (!fill_data)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ICP_QAT_UCLO_MAX_USTORE; i++)\r\nmemcpy(&fill_data[i], &uof_image->fill_pattern,\r\nsizeof(uint64_t));\r\npage = image->page;\r\nfor (ae = 0; ae < handle->hal_handle->ae_max_num; ae++) {\r\nif (!test_bit(ae, (unsigned long *)&uof_image->ae_assigned))\r\ncontinue;\r\nustore_size = obj_handle->ae_data[ae].eff_ustore_size;\r\npatt_pos = page->beg_addr_p + page->micro_words_num;\r\nqat_hal_wr_uwords(handle, (unsigned char)ae, 0,\r\npage->beg_addr_p, &fill_data[0]);\r\nqat_hal_wr_uwords(handle, (unsigned char)ae, patt_pos,\r\nustore_size - patt_pos + 1,\r\n&fill_data[page->beg_addr_p]);\r\n}\r\nkfree(fill_data);\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_init_memory(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nint i, ae;\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nstruct icp_qat_uof_initmem *initmem = obj_handle->init_mem_tab.init_mem;\r\nfor (i = 0; i < obj_handle->init_mem_tab.entry_num; i++) {\r\nif (initmem->num_in_bytes) {\r\nif (qat_uclo_init_ae_memory(handle, initmem))\r\nreturn -EINVAL;\r\n}\r\ninitmem = (struct icp_qat_uof_initmem *)((unsigned long)(\r\n(unsigned long)initmem +\r\nsizeof(struct icp_qat_uof_initmem)) +\r\n(sizeof(struct icp_qat_uof_memvar_attr) *\r\ninitmem->val_attr_num));\r\n}\r\nfor (ae = 0; ae < handle->hal_handle->ae_max_num; ae++) {\r\nif (qat_hal_batch_wr_lm(handle, ae,\r\nobj_handle->lm_init_tab[ae])) {\r\npr_err("QAT: fail to batch init lmem for AE %d\n", ae);\r\nreturn -EINVAL;\r\n}\r\nqat_uclo_cleanup_batch_init_list(handle,\r\n&obj_handle->lm_init_tab[ae]);\r\nqat_uclo_batch_wr_umem(handle, ae,\r\nobj_handle->umem_init_tab[ae]);\r\nqat_uclo_cleanup_batch_init_list(handle,\r\n&obj_handle->\r\numem_init_tab[ae]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void *qat_uclo_find_chunk(struct icp_qat_uof_objhdr *obj_hdr,\r\nchar *chunk_id, void *cur)\r\n{\r\nint i;\r\nstruct icp_qat_uof_chunkhdr *chunk_hdr =\r\n(struct icp_qat_uof_chunkhdr *)\r\n((unsigned long)obj_hdr + sizeof(struct icp_qat_uof_objhdr));\r\nfor (i = 0; i < obj_hdr->num_chunks; i++) {\r\nif ((cur < (void *)&chunk_hdr[i]) &&\r\n!strncmp(chunk_hdr[i].chunk_id, chunk_id,\r\nICP_QAT_UOF_OBJID_LEN)) {\r\nreturn &chunk_hdr[i];\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic unsigned int qat_uclo_calc_checksum(unsigned int reg, int ch)\r\n{\r\nint i;\r\nunsigned int topbit = 1 << 0xF;\r\nunsigned int inbyte = (unsigned int)((reg >> 0x18) ^ ch);\r\nreg ^= inbyte << 0x8;\r\nfor (i = 0; i < 0x8; i++) {\r\nif (reg & topbit)\r\nreg = (reg << 1) ^ 0x1021;\r\nelse\r\nreg <<= 1;\r\n}\r\nreturn reg & 0xFFFF;\r\n}\r\nstatic unsigned int qat_uclo_calc_str_checksum(char *ptr, int num)\r\n{\r\nunsigned int chksum = 0;\r\nif (ptr)\r\nwhile (num--)\r\nchksum = qat_uclo_calc_checksum(chksum, *ptr++);\r\nreturn chksum;\r\n}\r\nstatic struct icp_qat_uclo_objhdr *\r\nqat_uclo_map_chunk(char *buf, struct icp_qat_uof_filehdr *file_hdr,\r\nchar *chunk_id)\r\n{\r\nstruct icp_qat_uof_filechunkhdr *file_chunk;\r\nstruct icp_qat_uclo_objhdr *obj_hdr;\r\nchar *chunk;\r\nint i;\r\nfile_chunk = (struct icp_qat_uof_filechunkhdr *)\r\n(buf + sizeof(struct icp_qat_uof_filehdr));\r\nfor (i = 0; i < file_hdr->num_chunks; i++) {\r\nif (!strncmp(file_chunk->chunk_id, chunk_id,\r\nICP_QAT_UOF_OBJID_LEN)) {\r\nchunk = buf + file_chunk->offset;\r\nif (file_chunk->checksum != qat_uclo_calc_str_checksum(\r\nchunk, file_chunk->size))\r\nbreak;\r\nobj_hdr = kzalloc(sizeof(*obj_hdr), GFP_KERNEL);\r\nif (!obj_hdr)\r\nbreak;\r\nobj_hdr->file_buff = chunk;\r\nobj_hdr->checksum = file_chunk->checksum;\r\nobj_hdr->size = file_chunk->size;\r\nreturn obj_hdr;\r\n}\r\nfile_chunk++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic unsigned int\r\nqat_uclo_check_image_compat(struct icp_qat_uof_encap_obj *encap_uof_obj,\r\nstruct icp_qat_uof_image *image)\r\n{\r\nstruct icp_qat_uof_objtable *uc_var_tab, *imp_var_tab, *imp_expr_tab;\r\nstruct icp_qat_uof_objtable *neigh_reg_tab;\r\nstruct icp_qat_uof_code_page *code_page;\r\ncode_page = (struct icp_qat_uof_code_page *)\r\n((char *)image + sizeof(struct icp_qat_uof_image));\r\nuc_var_tab = (struct icp_qat_uof_objtable *)(encap_uof_obj->beg_uof +\r\ncode_page->uc_var_tab_offset);\r\nimp_var_tab = (struct icp_qat_uof_objtable *)(encap_uof_obj->beg_uof +\r\ncode_page->imp_var_tab_offset);\r\nimp_expr_tab = (struct icp_qat_uof_objtable *)\r\n(encap_uof_obj->beg_uof +\r\ncode_page->imp_expr_tab_offset);\r\nif (uc_var_tab->entry_num || imp_var_tab->entry_num ||\r\nimp_expr_tab->entry_num) {\r\npr_err("QAT: UOF can't contain imported variable to be parsed");\r\nreturn -EINVAL;\r\n}\r\nneigh_reg_tab = (struct icp_qat_uof_objtable *)\r\n(encap_uof_obj->beg_uof +\r\ncode_page->neigh_reg_tab_offset);\r\nif (neigh_reg_tab->entry_num) {\r\npr_err("QAT: UOF can't contain shared control store feature");\r\nreturn -EINVAL;\r\n}\r\nif (image->numpages > 1) {\r\npr_err("QAT: UOF can't contain multiple pages");\r\nreturn -EINVAL;\r\n}\r\nif (ICP_QAT_SHARED_USTORE_MODE(image->ae_mode)) {\r\npr_err("QAT: UOF can't use shared control store feature");\r\nreturn -EFAULT;\r\n}\r\nif (RELOADABLE_CTX_SHARED_MODE(image->ae_mode)) {\r\npr_err("QAT: UOF can't use reloadable feature");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void qat_uclo_map_image_page(struct icp_qat_uof_encap_obj\r\n*encap_uof_obj,\r\nstruct icp_qat_uof_image *img,\r\nstruct icp_qat_uclo_encap_page *page)\r\n{\r\nstruct icp_qat_uof_code_page *code_page;\r\nstruct icp_qat_uof_code_area *code_area;\r\nstruct icp_qat_uof_objtable *uword_block_tab;\r\nstruct icp_qat_uof_uword_block *uwblock;\r\nint i;\r\ncode_page = (struct icp_qat_uof_code_page *)\r\n((char *)img + sizeof(struct icp_qat_uof_image));\r\npage->def_page = code_page->def_page;\r\npage->page_region = code_page->page_region;\r\npage->beg_addr_v = code_page->beg_addr_v;\r\npage->beg_addr_p = code_page->beg_addr_p;\r\ncode_area = (struct icp_qat_uof_code_area *)(encap_uof_obj->beg_uof +\r\ncode_page->code_area_offset);\r\npage->micro_words_num = code_area->micro_words_num;\r\nuword_block_tab = (struct icp_qat_uof_objtable *)\r\n(encap_uof_obj->beg_uof +\r\ncode_area->uword_block_tab);\r\npage->uwblock_num = uword_block_tab->entry_num;\r\nuwblock = (struct icp_qat_uof_uword_block *)((char *)uword_block_tab +\r\nsizeof(struct icp_qat_uof_objtable));\r\npage->uwblock = (struct icp_qat_uclo_encap_uwblock *)uwblock;\r\nfor (i = 0; i < uword_block_tab->entry_num; i++)\r\npage->uwblock[i].micro_words =\r\n(unsigned long)encap_uof_obj->beg_uof + uwblock[i].uword_offset;\r\n}\r\nstatic int qat_uclo_map_uimage(struct icp_qat_uclo_objhandle *obj_handle,\r\nstruct icp_qat_uclo_encapme *ae_uimage,\r\nint max_image)\r\n{\r\nint i, j;\r\nstruct icp_qat_uof_chunkhdr *chunk_hdr = NULL;\r\nstruct icp_qat_uof_image *image;\r\nstruct icp_qat_uof_objtable *ae_regtab;\r\nstruct icp_qat_uof_objtable *init_reg_sym_tab;\r\nstruct icp_qat_uof_objtable *sbreak_tab;\r\nstruct icp_qat_uof_encap_obj *encap_uof_obj =\r\n&obj_handle->encap_uof_obj;\r\nfor (j = 0; j < max_image; j++) {\r\nchunk_hdr = qat_uclo_find_chunk(encap_uof_obj->obj_hdr,\r\nICP_QAT_UOF_IMAG, chunk_hdr);\r\nif (!chunk_hdr)\r\nbreak;\r\nimage = (struct icp_qat_uof_image *)(encap_uof_obj->beg_uof +\r\nchunk_hdr->offset);\r\nae_regtab = (struct icp_qat_uof_objtable *)\r\n(image->reg_tab_offset +\r\nobj_handle->obj_hdr->file_buff);\r\nae_uimage[j].ae_reg_num = ae_regtab->entry_num;\r\nae_uimage[j].ae_reg = (struct icp_qat_uof_ae_reg *)\r\n(((char *)ae_regtab) +\r\nsizeof(struct icp_qat_uof_objtable));\r\ninit_reg_sym_tab = (struct icp_qat_uof_objtable *)\r\n(image->init_reg_sym_tab +\r\nobj_handle->obj_hdr->file_buff);\r\nae_uimage[j].init_regsym_num = init_reg_sym_tab->entry_num;\r\nae_uimage[j].init_regsym = (struct icp_qat_uof_init_regsym *)\r\n(((char *)init_reg_sym_tab) +\r\nsizeof(struct icp_qat_uof_objtable));\r\nsbreak_tab = (struct icp_qat_uof_objtable *)\r\n(image->sbreak_tab + obj_handle->obj_hdr->file_buff);\r\nae_uimage[j].sbreak_num = sbreak_tab->entry_num;\r\nae_uimage[j].sbreak = (struct icp_qat_uof_sbreak *)\r\n(((char *)sbreak_tab) +\r\nsizeof(struct icp_qat_uof_objtable));\r\nae_uimage[j].img_ptr = image;\r\nif (qat_uclo_check_image_compat(encap_uof_obj, image))\r\ngoto out_err;\r\nae_uimage[j].page =\r\nkzalloc(sizeof(struct icp_qat_uclo_encap_page),\r\nGFP_KERNEL);\r\nif (!ae_uimage[j].page)\r\ngoto out_err;\r\nqat_uclo_map_image_page(encap_uof_obj, image,\r\nae_uimage[j].page);\r\n}\r\nreturn j;\r\nout_err:\r\nfor (i = 0; i < j; i++)\r\nkfree(ae_uimage[i].page);\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_map_ae(struct icp_qat_fw_loader_handle *handle, int max_ae)\r\n{\r\nint i, ae;\r\nint mflag = 0;\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nfor (ae = 0; ae <= max_ae; ae++) {\r\nif (!test_bit(ae,\r\n(unsigned long *)&handle->hal_handle->ae_mask))\r\ncontinue;\r\nfor (i = 0; i < obj_handle->uimage_num; i++) {\r\nif (!test_bit(ae, (unsigned long *)\r\n&obj_handle->ae_uimage[i].img_ptr->ae_assigned))\r\ncontinue;\r\nmflag = 1;\r\nif (qat_uclo_init_ae_data(obj_handle, ae, i))\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!mflag) {\r\npr_err("QAT: uimage uses AE not set");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct icp_qat_uof_strtable *\r\nqat_uclo_map_str_table(struct icp_qat_uclo_objhdr *obj_hdr,\r\nchar *tab_name, struct icp_qat_uof_strtable *str_table)\r\n{\r\nstruct icp_qat_uof_chunkhdr *chunk_hdr;\r\nchunk_hdr = qat_uclo_find_chunk((struct icp_qat_uof_objhdr *)\r\nobj_hdr->file_buff, tab_name, NULL);\r\nif (chunk_hdr) {\r\nint hdr_size;\r\nmemcpy(&str_table->table_len, obj_hdr->file_buff +\r\nchunk_hdr->offset, sizeof(str_table->table_len));\r\nhdr_size = (char *)&str_table->strings - (char *)str_table;\r\nstr_table->strings = (unsigned long)obj_hdr->file_buff +\r\nchunk_hdr->offset + hdr_size;\r\nreturn str_table;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\nqat_uclo_map_initmem_table(struct icp_qat_uof_encap_obj *encap_uof_obj,\r\nstruct icp_qat_uclo_init_mem_table *init_mem_tab)\r\n{\r\nstruct icp_qat_uof_chunkhdr *chunk_hdr;\r\nchunk_hdr = qat_uclo_find_chunk(encap_uof_obj->obj_hdr,\r\nICP_QAT_UOF_IMEM, NULL);\r\nif (chunk_hdr) {\r\nmemmove(&init_mem_tab->entry_num, encap_uof_obj->beg_uof +\r\nchunk_hdr->offset, sizeof(unsigned int));\r\ninit_mem_tab->init_mem = (struct icp_qat_uof_initmem *)\r\n(encap_uof_obj->beg_uof + chunk_hdr->offset +\r\nsizeof(unsigned int));\r\n}\r\n}\r\nstatic int qat_uclo_check_uof_compat(struct icp_qat_uclo_objhandle *obj_handle)\r\n{\r\nunsigned int maj_ver, prod_type = obj_handle->prod_type;\r\nif (!(prod_type & obj_handle->encap_uof_obj.obj_hdr->cpu_type)) {\r\npr_err("QAT: UOF type 0x%x not match with cur platform 0x%x\n",\r\nobj_handle->encap_uof_obj.obj_hdr->cpu_type, prod_type);\r\nreturn -EINVAL;\r\n}\r\nmaj_ver = obj_handle->prod_rev & 0xff;\r\nif ((obj_handle->encap_uof_obj.obj_hdr->max_cpu_ver < maj_ver) ||\r\n(obj_handle->encap_uof_obj.obj_hdr->min_cpu_ver > maj_ver)) {\r\npr_err("QAT: UOF majVer 0x%x out of range\n", maj_ver);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_init_reg(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned char ctx_mask,\r\nenum icp_qat_uof_regtype reg_type,\r\nunsigned short reg_addr, unsigned int value)\r\n{\r\nswitch (reg_type) {\r\ncase ICP_GPA_ABS:\r\ncase ICP_GPB_ABS:\r\nctx_mask = 0;\r\ncase ICP_GPA_REL:\r\ncase ICP_GPB_REL:\r\nreturn qat_hal_init_gpr(handle, ae, ctx_mask, reg_type,\r\nreg_addr, value);\r\ncase ICP_SR_ABS:\r\ncase ICP_DR_ABS:\r\ncase ICP_SR_RD_ABS:\r\ncase ICP_DR_RD_ABS:\r\nctx_mask = 0;\r\ncase ICP_SR_REL:\r\ncase ICP_DR_REL:\r\ncase ICP_SR_RD_REL:\r\ncase ICP_DR_RD_REL:\r\nreturn qat_hal_init_rd_xfer(handle, ae, ctx_mask, reg_type,\r\nreg_addr, value);\r\ncase ICP_SR_WR_ABS:\r\ncase ICP_DR_WR_ABS:\r\nctx_mask = 0;\r\ncase ICP_SR_WR_REL:\r\ncase ICP_DR_WR_REL:\r\nreturn qat_hal_init_wr_xfer(handle, ae, ctx_mask, reg_type,\r\nreg_addr, value);\r\ncase ICP_NEIGH_REL:\r\nreturn qat_hal_init_nn(handle, ae, ctx_mask, reg_addr, value);\r\ndefault:\r\npr_err("QAT: UOF uses not supported reg type 0x%x\n", reg_type);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_init_reg_sym(struct icp_qat_fw_loader_handle *handle,\r\nunsigned int ae,\r\nstruct icp_qat_uclo_encapme *encap_ae)\r\n{\r\nunsigned int i;\r\nunsigned char ctx_mask;\r\nstruct icp_qat_uof_init_regsym *init_regsym;\r\nif (ICP_QAT_CTX_MODE(encap_ae->img_ptr->ae_mode) ==\r\nICP_QAT_UCLO_MAX_CTX)\r\nctx_mask = 0xff;\r\nelse\r\nctx_mask = 0x55;\r\nfor (i = 0; i < encap_ae->init_regsym_num; i++) {\r\nunsigned int exp_res;\r\ninit_regsym = &encap_ae->init_regsym[i];\r\nexp_res = init_regsym->value;\r\nswitch (init_regsym->init_type) {\r\ncase ICP_QAT_UOF_INIT_REG:\r\nqat_uclo_init_reg(handle, ae, ctx_mask,\r\n(enum icp_qat_uof_regtype)\r\ninit_regsym->reg_type,\r\n(unsigned short)init_regsym->reg_addr,\r\nexp_res);\r\nbreak;\r\ncase ICP_QAT_UOF_INIT_REG_CTX:\r\nif (!((1 << init_regsym->ctx) & ctx_mask)) {\r\npr_err("QAT: invalid ctx num = 0x%x\n",\r\ninit_regsym->ctx);\r\nreturn -EINVAL;\r\n}\r\nqat_uclo_init_reg(handle, ae,\r\n(unsigned char)\r\n(1 << init_regsym->ctx),\r\n(enum icp_qat_uof_regtype)\r\ninit_regsym->reg_type,\r\n(unsigned short)init_regsym->reg_addr,\r\nexp_res);\r\nbreak;\r\ncase ICP_QAT_UOF_INIT_EXPR:\r\npr_err("QAT: INIT_EXPR feature not supported\n");\r\nreturn -EINVAL;\r\ncase ICP_QAT_UOF_INIT_EXPR_ENDIAN_SWAP:\r\npr_err("QAT: INIT_EXPR_ENDIAN_SWAP feature not supported\n");\r\nreturn -EINVAL;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_init_globals(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nunsigned int s, ae;\r\nif (obj_handle->global_inited)\r\nreturn 0;\r\nif (obj_handle->init_mem_tab.entry_num) {\r\nif (qat_uclo_init_memory(handle)) {\r\npr_err("QAT: initialize memory failed\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nfor (ae = 0; ae < handle->hal_handle->ae_max_num; ae++) {\r\nfor (s = 0; s < obj_handle->ae_data[ae].slice_num; s++) {\r\nif (!obj_handle->ae_data[ae].ae_slices[s].encap_image)\r\ncontinue;\r\nif (qat_uclo_init_reg_sym(handle, ae,\r\nobj_handle->ae_data[ae].\r\nae_slices[s].encap_image))\r\nreturn -EINVAL;\r\n}\r\n}\r\nobj_handle->global_inited = 1;\r\nreturn 0;\r\n}\r\nstatic int qat_uclo_set_ae_mode(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nunsigned char ae, nn_mode, s;\r\nstruct icp_qat_uof_image *uof_image;\r\nstruct icp_qat_uclo_aedata *ae_data;\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nfor (ae = 0; ae < handle->hal_handle->ae_max_num; ae++) {\r\nif (!test_bit(ae,\r\n(unsigned long *)&handle->hal_handle->ae_mask))\r\ncontinue;\r\nae_data = &obj_handle->ae_data[ae];\r\nfor (s = 0; s < min_t(unsigned int, ae_data->slice_num,\r\nICP_QAT_UCLO_MAX_CTX); s++) {\r\nif (!obj_handle->ae_data[ae].ae_slices[s].encap_image)\r\ncontinue;\r\nuof_image = ae_data->ae_slices[s].encap_image->img_ptr;\r\nif (qat_hal_set_ae_ctx_mode(handle, ae,\r\n(char)ICP_QAT_CTX_MODE\r\n(uof_image->ae_mode))) {\r\npr_err("QAT: qat_hal_set_ae_ctx_mode error\n");\r\nreturn -EFAULT;\r\n}\r\nnn_mode = ICP_QAT_NN_MODE(uof_image->ae_mode);\r\nif (qat_hal_set_ae_nn_mode(handle, ae, nn_mode)) {\r\npr_err("QAT: qat_hal_set_ae_nn_mode error\n");\r\nreturn -EFAULT;\r\n}\r\nif (qat_hal_set_ae_lm_mode(handle, ae, ICP_LMEM0,\r\n(char)ICP_QAT_LOC_MEM0_MODE\r\n(uof_image->ae_mode))) {\r\npr_err("QAT: qat_hal_set_ae_lm_mode LMEM0 error\n");\r\nreturn -EFAULT;\r\n}\r\nif (qat_hal_set_ae_lm_mode(handle, ae, ICP_LMEM1,\r\n(char)ICP_QAT_LOC_MEM1_MODE\r\n(uof_image->ae_mode))) {\r\npr_err("QAT: qat_hal_set_ae_lm_mode LMEM1 error\n");\r\nreturn -EFAULT;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void qat_uclo_init_uword_num(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nstruct icp_qat_uclo_encapme *image;\r\nint a;\r\nfor (a = 0; a < obj_handle->uimage_num; a++) {\r\nimage = &obj_handle->ae_uimage[a];\r\nimage->uwords_num = image->page->beg_addr_p +\r\nimage->page->micro_words_num;\r\n}\r\n}\r\nstatic int qat_uclo_parse_uof_obj(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nunsigned int ae;\r\nobj_handle->uword_buf = kcalloc(UWORD_CPYBUF_SIZE, sizeof(uint64_t),\r\nGFP_KERNEL);\r\nif (!obj_handle->uword_buf)\r\nreturn -ENOMEM;\r\nobj_handle->encap_uof_obj.beg_uof = obj_handle->obj_hdr->file_buff;\r\nobj_handle->encap_uof_obj.obj_hdr = (struct icp_qat_uof_objhdr *)\r\nobj_handle->obj_hdr->file_buff;\r\nobj_handle->uword_in_bytes = 6;\r\nobj_handle->prod_type = ICP_QAT_AC_C_CPU_TYPE;\r\nobj_handle->prod_rev = PID_MAJOR_REV |\r\n(PID_MINOR_REV & handle->hal_handle->revision_id);\r\nif (qat_uclo_check_uof_compat(obj_handle)) {\r\npr_err("QAT: UOF incompatible\n");\r\nreturn -EINVAL;\r\n}\r\nobj_handle->ustore_phy_size = ICP_QAT_UCLO_MAX_USTORE;\r\nif (!obj_handle->obj_hdr->file_buff ||\r\n!qat_uclo_map_str_table(obj_handle->obj_hdr, ICP_QAT_UOF_STRT,\r\n&obj_handle->str_table)) {\r\npr_err("QAT: UOF doesn't have effective images\n");\r\ngoto out_err;\r\n}\r\nobj_handle->uimage_num =\r\nqat_uclo_map_uimage(obj_handle, obj_handle->ae_uimage,\r\nICP_QAT_UCLO_MAX_AE * ICP_QAT_UCLO_MAX_CTX);\r\nif (!obj_handle->uimage_num)\r\ngoto out_err;\r\nif (qat_uclo_map_ae(handle, handle->hal_handle->ae_max_num)) {\r\npr_err("QAT: Bad object\n");\r\ngoto out_check_uof_aemask_err;\r\n}\r\nqat_uclo_init_uword_num(handle);\r\nqat_uclo_map_initmem_table(&obj_handle->encap_uof_obj,\r\n&obj_handle->init_mem_tab);\r\nif (qat_uclo_set_ae_mode(handle))\r\ngoto out_check_uof_aemask_err;\r\nreturn 0;\r\nout_check_uof_aemask_err:\r\nfor (ae = 0; ae < obj_handle->uimage_num; ae++)\r\nkfree(obj_handle->ae_uimage[ae].page);\r\nout_err:\r\nkfree(obj_handle->uword_buf);\r\nreturn -EFAULT;\r\n}\r\nvoid qat_uclo_wr_mimage(struct icp_qat_fw_loader_handle *handle,\r\nvoid *addr_ptr, int mem_size)\r\n{\r\nqat_uclo_wr_sram_by_words(handle, 0, addr_ptr, ALIGN(mem_size, 4));\r\n}\r\nint qat_uclo_map_uof_obj(struct icp_qat_fw_loader_handle *handle,\r\nvoid *addr_ptr, int mem_size)\r\n{\r\nstruct icp_qat_uof_filehdr *filehdr;\r\nstruct icp_qat_uclo_objhandle *objhdl;\r\nBUILD_BUG_ON(ICP_QAT_UCLO_MAX_AE >=\r\n(sizeof(handle->hal_handle->ae_mask) * 8));\r\nif (!handle || !addr_ptr || mem_size < 24)\r\nreturn -EINVAL;\r\nobjhdl = kzalloc(sizeof(*objhdl), GFP_KERNEL);\r\nif (!objhdl)\r\nreturn -ENOMEM;\r\nobjhdl->obj_buf = kmemdup(addr_ptr, mem_size, GFP_KERNEL);\r\nif (!objhdl->obj_buf)\r\ngoto out_objbuf_err;\r\nfilehdr = (struct icp_qat_uof_filehdr *)objhdl->obj_buf;\r\nif (qat_uclo_check_format(filehdr))\r\ngoto out_objhdr_err;\r\nobjhdl->obj_hdr = qat_uclo_map_chunk((char *)objhdl->obj_buf, filehdr,\r\nICP_QAT_UOF_OBJS);\r\nif (!objhdl->obj_hdr) {\r\npr_err("QAT: object file chunk is null\n");\r\ngoto out_objhdr_err;\r\n}\r\nhandle->obj_handle = objhdl;\r\nif (qat_uclo_parse_uof_obj(handle))\r\ngoto out_overlay_obj_err;\r\nreturn 0;\r\nout_overlay_obj_err:\r\nhandle->obj_handle = NULL;\r\nkfree(objhdl->obj_hdr);\r\nout_objhdr_err:\r\nkfree(objhdl->obj_buf);\r\nout_objbuf_err:\r\nkfree(objhdl);\r\nreturn -ENOMEM;\r\n}\r\nvoid qat_uclo_del_uof_obj(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nunsigned int a;\r\nif (!obj_handle)\r\nreturn;\r\nkfree(obj_handle->uword_buf);\r\nfor (a = 0; a < obj_handle->uimage_num; a++)\r\nkfree(obj_handle->ae_uimage[a].page);\r\nfor (a = 0; a < handle->hal_handle->ae_max_num; a++)\r\nqat_uclo_free_ae_data(&obj_handle->ae_data[a]);\r\nkfree(obj_handle->obj_hdr);\r\nkfree(obj_handle->obj_buf);\r\nkfree(obj_handle);\r\nhandle->obj_handle = NULL;\r\n}\r\nstatic void qat_uclo_fill_uwords(struct icp_qat_uclo_objhandle *obj_handle,\r\nstruct icp_qat_uclo_encap_page *encap_page,\r\nuint64_t *uword, unsigned int addr_p,\r\nunsigned int raddr, uint64_t fill)\r\n{\r\nuint64_t uwrd = 0;\r\nunsigned int i;\r\nif (!encap_page) {\r\n*uword = fill;\r\nreturn;\r\n}\r\nfor (i = 0; i < encap_page->uwblock_num; i++) {\r\nif (raddr >= encap_page->uwblock[i].start_addr &&\r\nraddr <= encap_page->uwblock[i].start_addr +\r\nencap_page->uwblock[i].words_num - 1) {\r\nraddr -= encap_page->uwblock[i].start_addr;\r\nraddr *= obj_handle->uword_in_bytes;\r\nmemcpy(&uwrd, (void *)(((unsigned long)\r\nencap_page->uwblock[i].micro_words) + raddr),\r\nobj_handle->uword_in_bytes);\r\nuwrd = uwrd & 0xbffffffffffull;\r\n}\r\n}\r\n*uword = uwrd;\r\nif (*uword == INVLD_UWORD)\r\n*uword = fill;\r\n}\r\nstatic void qat_uclo_wr_uimage_raw_page(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_uclo_encap_page\r\n*encap_page, unsigned int ae)\r\n{\r\nunsigned int uw_physical_addr, uw_relative_addr, i, words_num, cpylen;\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nuint64_t fill_pat;\r\nmemcpy(&fill_pat, obj_handle->ae_uimage[0].img_ptr->fill_pattern,\r\nsizeof(uint64_t));\r\nuw_physical_addr = encap_page->beg_addr_p;\r\nuw_relative_addr = 0;\r\nwords_num = encap_page->micro_words_num;\r\nwhile (words_num) {\r\nif (words_num < UWORD_CPYBUF_SIZE)\r\ncpylen = words_num;\r\nelse\r\ncpylen = UWORD_CPYBUF_SIZE;\r\nfor (i = 0; i < cpylen; i++)\r\nqat_uclo_fill_uwords(obj_handle, encap_page,\r\n&obj_handle->uword_buf[i],\r\nuw_physical_addr + i,\r\nuw_relative_addr + i, fill_pat);\r\nqat_hal_wr_uwords(handle, (unsigned char)ae,\r\nuw_physical_addr, cpylen,\r\nobj_handle->uword_buf);\r\nuw_physical_addr += cpylen;\r\nuw_relative_addr += cpylen;\r\nwords_num -= cpylen;\r\n}\r\n}\r\nstatic void qat_uclo_wr_uimage_page(struct icp_qat_fw_loader_handle *handle,\r\nstruct icp_qat_uof_image *image)\r\n{\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nunsigned int ctx_mask, s;\r\nstruct icp_qat_uclo_page *page;\r\nunsigned char ae;\r\nint ctx;\r\nif (ICP_QAT_CTX_MODE(image->ae_mode) == ICP_QAT_UCLO_MAX_CTX)\r\nctx_mask = 0xff;\r\nelse\r\nctx_mask = 0x55;\r\nfor (ae = 0; ae < handle->hal_handle->ae_max_num; ae++) {\r\nif (!test_bit(ae, (unsigned long *)&image->ae_assigned))\r\ncontinue;\r\nfor (s = 0; s < obj_handle->ae_data[ae].slice_num; s++) {\r\nif (image->ctx_assigned & obj_handle->ae_data[ae].\r\nae_slices[s].ctx_mask_assigned)\r\nbreak;\r\n}\r\nif (s >= obj_handle->ae_data[ae].slice_num)\r\ncontinue;\r\npage = obj_handle->ae_data[ae].ae_slices[s].page;\r\nif (!page->encap_page->def_page)\r\ncontinue;\r\nqat_uclo_wr_uimage_raw_page(handle, page->encap_page, ae);\r\npage = obj_handle->ae_data[ae].ae_slices[s].page;\r\nfor (ctx = 0; ctx < ICP_QAT_UCLO_MAX_CTX; ctx++)\r\nobj_handle->ae_data[ae].ae_slices[s].cur_page[ctx] =\r\n(ctx_mask & (1 << ctx)) ? page : NULL;\r\nqat_hal_set_live_ctx(handle, (unsigned char)ae,\r\nimage->ctx_assigned);\r\nqat_hal_set_pc(handle, (unsigned char)ae, image->ctx_assigned,\r\nimage->entry_address);\r\n}\r\n}\r\nint qat_uclo_wr_all_uimage(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\r\nunsigned int i;\r\nif (qat_uclo_init_globals(handle))\r\nreturn -EINVAL;\r\nfor (i = 0; i < obj_handle->uimage_num; i++) {\r\nif (!obj_handle->ae_uimage[i].img_ptr)\r\nreturn -EINVAL;\r\nif (qat_uclo_init_ustore(handle, &obj_handle->ae_uimage[i]))\r\nreturn -EINVAL;\r\nqat_uclo_wr_uimage_page(handle,\r\nobj_handle->ae_uimage[i].img_ptr);\r\n}\r\nreturn 0;\r\n}
