static inline int pufd_omsg_get_channel(struct pcan_ufd_ovr_msg *om)\r\n{\r\nreturn om->channel & 0xf;\r\n}\r\nstatic inline\r\nstruct pcan_usb_fd_if *pcan_usb_fd_dev_if(struct peak_usb_device *dev)\r\n{\r\nstruct pcan_usb_fd_device *pdev =\r\ncontainer_of(dev, struct pcan_usb_fd_device, dev);\r\nreturn pdev->usb_if;\r\n}\r\nstatic inline void *pcan_usb_fd_cmd_buffer(struct peak_usb_device *dev)\r\n{\r\nstruct pcan_usb_fd_device *pdev =\r\ncontainer_of(dev, struct pcan_usb_fd_device, dev);\r\nreturn pdev->cmd_buffer_addr;\r\n}\r\nstatic int pcan_usb_fd_send_cmd(struct peak_usb_device *dev, void *cmd_tail)\r\n{\r\nvoid *cmd_head = pcan_usb_fd_cmd_buffer(dev);\r\nint err = 0;\r\nu8 *packet_ptr;\r\nint i, n = 1, packet_len;\r\nptrdiff_t cmd_len;\r\nif (!(dev->state & PCAN_USB_STATE_CONNECTED))\r\nreturn 0;\r\ncmd_len = cmd_tail - cmd_head;\r\nif (cmd_len <= (PCAN_UFD_CMD_BUFFER_SIZE - sizeof(u64))) {\r\nmemset(cmd_tail, 0xff, sizeof(u64));\r\ncmd_len += sizeof(u64);\r\n}\r\npacket_ptr = cmd_head;\r\nif ((dev->udev->speed != USB_SPEED_HIGH) &&\r\n(cmd_len > PCAN_UFD_LOSPD_PKT_SIZE)) {\r\npacket_len = PCAN_UFD_LOSPD_PKT_SIZE;\r\nn += cmd_len / packet_len;\r\n} else {\r\npacket_len = cmd_len;\r\n}\r\nfor (i = 0; i < n; i++) {\r\nerr = usb_bulk_msg(dev->udev,\r\nusb_sndbulkpipe(dev->udev,\r\nPCAN_USBPRO_EP_CMDOUT),\r\npacket_ptr, packet_len,\r\nNULL, PCAN_UFD_CMD_TIMEOUT_MS);\r\nif (err) {\r\nnetdev_err(dev->netdev,\r\n"sending command failure: %d\n", err);\r\nbreak;\r\n}\r\npacket_ptr += packet_len;\r\n}\r\nreturn err;\r\n}\r\nstatic int pcan_usb_fd_build_restart_cmd(struct peak_usb_device *dev, u8 *buf)\r\n{\r\nstruct pucan_wr_err_cnt *prc;\r\nstruct pucan_command *cmd;\r\nu8 *pc = buf;\r\nprc = (struct pucan_wr_err_cnt *)pc;\r\nprc->opcode_channel = pucan_cmd_opcode_channel(dev,\r\nPUCAN_CMD_WR_ERR_CNT);\r\nprc->sel_mask = cpu_to_le16(PUCAN_WRERRCNT_TE|PUCAN_WRERRCNT_RE);\r\nprc->tx_counter = 0;\r\nprc->rx_counter = 0;\r\npc += sizeof(struct pucan_wr_err_cnt);\r\nif (dev->can.ctrlmode_supported & CAN_CTRLMODE_FD_NON_ISO) {\r\nstruct pucan_options *puo = (struct pucan_options *)pc;\r\npuo->opcode_channel =\r\n(dev->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO) ?\r\npucan_cmd_opcode_channel(dev,\r\nPUCAN_CMD_CLR_DIS_OPTION) :\r\npucan_cmd_opcode_channel(dev, PUCAN_CMD_SET_EN_OPTION);\r\npuo->options = cpu_to_le16(PUCAN_OPTION_CANDFDISO);\r\npuo->unused = 0;\r\npc += sizeof(struct pucan_options);\r\n}\r\ncmd = (struct pucan_command *)pc;\r\ncmd->opcode_channel = pucan_cmd_opcode_channel(dev,\r\n(dev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY) ?\r\nPUCAN_CMD_LISTEN_ONLY_MODE :\r\nPUCAN_CMD_NORMAL_MODE);\r\npc += sizeof(struct pucan_command);\r\nreturn pc - buf;\r\n}\r\nstatic int pcan_usb_fd_set_bus(struct peak_usb_device *dev, u8 onoff)\r\n{\r\nu8 *pc = pcan_usb_fd_cmd_buffer(dev);\r\nint l;\r\nif (onoff) {\r\nl = pcan_usb_fd_build_restart_cmd(dev, pc);\r\n} else {\r\nstruct pucan_command *cmd = (struct pucan_command *)pc;\r\ncmd->opcode_channel = pucan_cmd_opcode_channel(dev,\r\nPUCAN_CMD_RESET_MODE);\r\nl = sizeof(struct pucan_command);\r\n}\r\nreturn pcan_usb_fd_send_cmd(dev, pc + l);\r\n}\r\nstatic int pcan_usb_fd_set_filter_std(struct peak_usb_device *dev, int idx,\r\nu32 mask)\r\n{\r\nstruct pucan_filter_std *cmd = pcan_usb_fd_cmd_buffer(dev);\r\nint i, n;\r\nif ((idx < 0) || (idx >= (1 << PUCAN_FLTSTD_ROW_IDX_BITS))) {\r\nn = 1 << PUCAN_FLTSTD_ROW_IDX_BITS;\r\nidx = 0;\r\n} else {\r\nn = idx + 1;\r\n}\r\nfor (i = idx; i < n; i++, cmd++) {\r\ncmd->opcode_channel = pucan_cmd_opcode_channel(dev,\r\nPUCAN_CMD_FILTER_STD);\r\ncmd->idx = cpu_to_le16(i);\r\ncmd->mask = cpu_to_le32(mask);\r\n}\r\nreturn pcan_usb_fd_send_cmd(dev, cmd);\r\n}\r\nstatic int pcan_usb_fd_set_options(struct peak_usb_device *dev,\r\nbool onoff, u16 ucan_mask, u16 usb_mask)\r\n{\r\nstruct pcan_ufd_options *cmd = pcan_usb_fd_cmd_buffer(dev);\r\ncmd->opcode_channel = pucan_cmd_opcode_channel(dev,\r\n(onoff) ? PUCAN_CMD_SET_EN_OPTION :\r\nPUCAN_CMD_CLR_DIS_OPTION);\r\ncmd->ucan_mask = cpu_to_le16(ucan_mask);\r\ncmd->usb_mask = cpu_to_le16(usb_mask);\r\nreturn pcan_usb_fd_send_cmd(dev, ++cmd);\r\n}\r\nstatic int pcan_usb_fd_set_can_led(struct peak_usb_device *dev, u8 led_mode)\r\n{\r\nstruct pcan_ufd_led *cmd = pcan_usb_fd_cmd_buffer(dev);\r\ncmd->opcode_channel = pucan_cmd_opcode_channel(dev,\r\nPCAN_UFD_CMD_LED_SET);\r\ncmd->mode = led_mode;\r\nreturn pcan_usb_fd_send_cmd(dev, ++cmd);\r\n}\r\nstatic int pcan_usb_fd_set_clock_domain(struct peak_usb_device *dev,\r\nu8 clk_mode)\r\n{\r\nstruct pcan_ufd_clock *cmd = pcan_usb_fd_cmd_buffer(dev);\r\ncmd->opcode_channel = pucan_cmd_opcode_channel(dev,\r\nPCAN_UFD_CMD_CLK_SET);\r\ncmd->mode = clk_mode;\r\nreturn pcan_usb_fd_send_cmd(dev, ++cmd);\r\n}\r\nstatic int pcan_usb_fd_set_bittiming_slow(struct peak_usb_device *dev,\r\nstruct can_bittiming *bt)\r\n{\r\nstruct pucan_timing_slow *cmd = pcan_usb_fd_cmd_buffer(dev);\r\ncmd->opcode_channel = pucan_cmd_opcode_channel(dev,\r\nPUCAN_CMD_TIMING_SLOW);\r\ncmd->sjw_t = PUCAN_TSLOW_SJW_T(bt->sjw - 1,\r\ndev->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES);\r\ncmd->tseg2 = PUCAN_TSLOW_TSEG2(bt->phase_seg2 - 1);\r\ncmd->tseg1 = PUCAN_TSLOW_TSEG1(bt->prop_seg + bt->phase_seg1 - 1);\r\ncmd->brp = cpu_to_le16(PUCAN_TSLOW_BRP(bt->brp - 1));\r\ncmd->ewl = 96;\r\nreturn pcan_usb_fd_send_cmd(dev, ++cmd);\r\n}\r\nstatic int pcan_usb_fd_set_bittiming_fast(struct peak_usb_device *dev,\r\nstruct can_bittiming *bt)\r\n{\r\nstruct pucan_timing_fast *cmd = pcan_usb_fd_cmd_buffer(dev);\r\ncmd->opcode_channel = pucan_cmd_opcode_channel(dev,\r\nPUCAN_CMD_TIMING_FAST);\r\ncmd->sjw = PUCAN_TFAST_SJW(bt->sjw - 1);\r\ncmd->tseg2 = PUCAN_TFAST_TSEG2(bt->phase_seg2 - 1);\r\ncmd->tseg1 = PUCAN_TFAST_TSEG1(bt->prop_seg + bt->phase_seg1 - 1);\r\ncmd->brp = cpu_to_le16(PUCAN_TFAST_BRP(bt->brp - 1));\r\nreturn pcan_usb_fd_send_cmd(dev, ++cmd);\r\n}\r\nstatic int pcan_usb_fd_restart_async(struct peak_usb_device *dev,\r\nstruct urb *urb, u8 *buf)\r\n{\r\nu8 *pc = buf;\r\npc += pcan_usb_fd_build_restart_cmd(dev, pc);\r\nmemset(pc, 0xff, sizeof(struct pucan_command));\r\npc += sizeof(struct pucan_command);\r\nusb_fill_bulk_urb(urb, dev->udev,\r\nusb_sndbulkpipe(dev->udev, PCAN_USBPRO_EP_CMDOUT),\r\nbuf, pc - buf,\r\npcan_usb_pro_restart_complete, dev);\r\nreturn usb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nstatic int pcan_usb_fd_drv_loaded(struct peak_usb_device *dev, bool loaded)\r\n{\r\nstruct pcan_usb_fd_device *pdev =\r\ncontainer_of(dev, struct pcan_usb_fd_device, dev);\r\npdev->cmd_buffer_addr[0] = 0;\r\npdev->cmd_buffer_addr[1] = !!loaded;\r\nreturn pcan_usb_pro_send_req(dev,\r\nPCAN_USBPRO_REQ_FCT,\r\nPCAN_USBPRO_FCT_DRVLD,\r\npdev->cmd_buffer_addr,\r\nPCAN_USBPRO_FCT_DRVLD_REQ_LEN);\r\n}\r\nstatic int pcan_usb_fd_decode_canmsg(struct pcan_usb_fd_if *usb_if,\r\nstruct pucan_msg *rx_msg)\r\n{\r\nstruct pucan_rx_msg *rm = (struct pucan_rx_msg *)rx_msg;\r\nstruct peak_usb_device *dev = usb_if->dev[pucan_msg_get_channel(rm)];\r\nstruct net_device *netdev = dev->netdev;\r\nstruct canfd_frame *cfd;\r\nstruct sk_buff *skb;\r\nconst u16 rx_msg_flags = le16_to_cpu(rm->flags);\r\nif (rx_msg_flags & PUCAN_MSG_EXT_DATA_LEN) {\r\nskb = alloc_canfd_skb(netdev, &cfd);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nif (rx_msg_flags & PUCAN_MSG_BITRATE_SWITCH)\r\ncfd->flags |= CANFD_BRS;\r\nif (rx_msg_flags & PUCAN_MSG_ERROR_STATE_IND)\r\ncfd->flags |= CANFD_ESI;\r\ncfd->len = can_dlc2len(get_canfd_dlc(pucan_msg_get_dlc(rm)));\r\n} else {\r\nskb = alloc_can_skb(netdev, (struct can_frame **)&cfd);\r\nif (!skb)\r\nreturn -ENOMEM;\r\ncfd->len = get_can_dlc(pucan_msg_get_dlc(rm));\r\n}\r\ncfd->can_id = le32_to_cpu(rm->can_id);\r\nif (rx_msg_flags & PUCAN_MSG_EXT_ID)\r\ncfd->can_id |= CAN_EFF_FLAG;\r\nif (rx_msg_flags & PUCAN_MSG_RTR)\r\ncfd->can_id |= CAN_RTR_FLAG;\r\nelse\r\nmemcpy(cfd->data, rm->d, cfd->len);\r\npeak_usb_netif_rx(skb, &usb_if->time_ref,\r\nle32_to_cpu(rm->ts_low), le32_to_cpu(rm->ts_high));\r\nnetdev->stats.rx_packets++;\r\nnetdev->stats.rx_bytes += cfd->len;\r\nreturn 0;\r\n}\r\nstatic int pcan_usb_fd_decode_status(struct pcan_usb_fd_if *usb_if,\r\nstruct pucan_msg *rx_msg)\r\n{\r\nstruct pucan_status_msg *sm = (struct pucan_status_msg *)rx_msg;\r\nstruct peak_usb_device *dev = usb_if->dev[pucan_stmsg_get_channel(sm)];\r\nstruct pcan_usb_fd_device *pdev =\r\ncontainer_of(dev, struct pcan_usb_fd_device, dev);\r\nenum can_state new_state = CAN_STATE_ERROR_ACTIVE;\r\nenum can_state rx_state, tx_state;\r\nstruct net_device *netdev = dev->netdev;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nif (dev->can.state == CAN_STATE_BUS_OFF)\r\nreturn 0;\r\nif (sm->channel_p_w_b & PUCAN_BUS_BUSOFF) {\r\nnew_state = CAN_STATE_BUS_OFF;\r\n} else if (sm->channel_p_w_b & PUCAN_BUS_PASSIVE) {\r\nnew_state = CAN_STATE_ERROR_PASSIVE;\r\n} else if (sm->channel_p_w_b & PUCAN_BUS_WARNING) {\r\nnew_state = CAN_STATE_ERROR_WARNING;\r\n} else {\r\ndev->can.state = CAN_STATE_ERROR_ACTIVE;\r\npdev->bec.txerr = 0;\r\npdev->bec.rxerr = 0;\r\nreturn 0;\r\n}\r\nif (new_state == dev->can.state)\r\nreturn 0;\r\ntx_state = (pdev->bec.txerr >= pdev->bec.rxerr) ? new_state : 0;\r\nrx_state = (pdev->bec.txerr <= pdev->bec.rxerr) ? new_state : 0;\r\nskb = alloc_can_err_skb(netdev, &cf);\r\nif (skb)\r\ncan_change_state(netdev, cf, tx_state, rx_state);\r\nif (new_state == CAN_STATE_BUS_OFF)\r\ncan_bus_off(netdev);\r\nif (!skb)\r\nreturn -ENOMEM;\r\npeak_usb_netif_rx(skb, &usb_if->time_ref,\r\nle32_to_cpu(sm->ts_low), le32_to_cpu(sm->ts_high));\r\nnetdev->stats.rx_packets++;\r\nnetdev->stats.rx_bytes += cf->can_dlc;\r\nreturn 0;\r\n}\r\nstatic int pcan_usb_fd_decode_error(struct pcan_usb_fd_if *usb_if,\r\nstruct pucan_msg *rx_msg)\r\n{\r\nstruct pucan_error_msg *er = (struct pucan_error_msg *)rx_msg;\r\nstruct peak_usb_device *dev = usb_if->dev[pucan_ermsg_get_channel(er)];\r\nstruct pcan_usb_fd_device *pdev =\r\ncontainer_of(dev, struct pcan_usb_fd_device, dev);\r\npdev->bec.txerr = er->tx_err_cnt;\r\npdev->bec.rxerr = er->rx_err_cnt;\r\nreturn 0;\r\n}\r\nstatic int pcan_usb_fd_decode_overrun(struct pcan_usb_fd_if *usb_if,\r\nstruct pucan_msg *rx_msg)\r\n{\r\nstruct pcan_ufd_ovr_msg *ov = (struct pcan_ufd_ovr_msg *)rx_msg;\r\nstruct peak_usb_device *dev = usb_if->dev[pufd_omsg_get_channel(ov)];\r\nstruct net_device *netdev = dev->netdev;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nskb = alloc_can_err_skb(netdev, &cf);\r\nif (!skb)\r\nreturn -ENOMEM;\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;\r\npeak_usb_netif_rx(skb, &usb_if->time_ref,\r\nle32_to_cpu(ov->ts_low), le32_to_cpu(ov->ts_high));\r\nnetdev->stats.rx_over_errors++;\r\nnetdev->stats.rx_errors++;\r\nreturn 0;\r\n}\r\nstatic void pcan_usb_fd_decode_ts(struct pcan_usb_fd_if *usb_if,\r\nstruct pucan_msg *rx_msg)\r\n{\r\nstruct pcan_ufd_ts_msg *ts = (struct pcan_ufd_ts_msg *)rx_msg;\r\nif (usb_if->cm_ignore_count > 0)\r\nusb_if->cm_ignore_count--;\r\nelse\r\npeak_usb_set_ts_now(&usb_if->time_ref, le32_to_cpu(ts->ts_low));\r\n}\r\nstatic int pcan_usb_fd_decode_buf(struct peak_usb_device *dev, struct urb *urb)\r\n{\r\nstruct pcan_usb_fd_if *usb_if = pcan_usb_fd_dev_if(dev);\r\nstruct net_device *netdev = dev->netdev;\r\nstruct pucan_msg *rx_msg;\r\nu8 *msg_ptr, *msg_end;\r\nint err = 0;\r\nmsg_ptr = urb->transfer_buffer;\r\nmsg_end = urb->transfer_buffer + urb->actual_length;\r\nfor (; msg_ptr < msg_end;) {\r\nu16 rx_msg_type, rx_msg_size;\r\nrx_msg = (struct pucan_msg *)msg_ptr;\r\nif (!rx_msg->size) {\r\nbreak;\r\n}\r\nrx_msg_size = le16_to_cpu(rx_msg->size);\r\nrx_msg_type = le16_to_cpu(rx_msg->type);\r\nif (msg_ptr + rx_msg_size > msg_end) {\r\nnetdev_err(netdev,\r\n"got frag rec: should inc usb rx buf sze\n");\r\nerr = -EBADMSG;\r\nbreak;\r\n}\r\nswitch (rx_msg_type) {\r\ncase PUCAN_MSG_CAN_RX:\r\nerr = pcan_usb_fd_decode_canmsg(usb_if, rx_msg);\r\nif (err < 0)\r\ngoto fail;\r\nbreak;\r\ncase PCAN_UFD_MSG_CALIBRATION:\r\npcan_usb_fd_decode_ts(usb_if, rx_msg);\r\nbreak;\r\ncase PUCAN_MSG_ERROR:\r\nerr = pcan_usb_fd_decode_error(usb_if, rx_msg);\r\nif (err < 0)\r\ngoto fail;\r\nbreak;\r\ncase PUCAN_MSG_STATUS:\r\nerr = pcan_usb_fd_decode_status(usb_if, rx_msg);\r\nif (err < 0)\r\ngoto fail;\r\nbreak;\r\ncase PCAN_UFD_MSG_OVERRUN:\r\nerr = pcan_usb_fd_decode_overrun(usb_if, rx_msg);\r\nif (err < 0)\r\ngoto fail;\r\nbreak;\r\ndefault:\r\nnetdev_err(netdev,\r\n"unhandled msg type 0x%02x (%d): ignored\n",\r\nrx_msg_type, rx_msg_type);\r\nbreak;\r\n}\r\nmsg_ptr += rx_msg_size;\r\n}\r\nfail:\r\nif (err)\r\npcan_dump_mem("received msg",\r\nurb->transfer_buffer, urb->actual_length);\r\nreturn err;\r\n}\r\nstatic int pcan_usb_fd_encode_msg(struct peak_usb_device *dev,\r\nstruct sk_buff *skb, u8 *obuf, size_t *size)\r\n{\r\nstruct pucan_tx_msg *tx_msg = (struct pucan_tx_msg *)obuf;\r\nstruct canfd_frame *cfd = (struct canfd_frame *)skb->data;\r\nu16 tx_msg_size, tx_msg_flags;\r\nu8 can_dlc;\r\ntx_msg_size = ALIGN(sizeof(struct pucan_tx_msg) + cfd->len, 4);\r\ntx_msg->size = cpu_to_le16(tx_msg_size);\r\ntx_msg->type = cpu_to_le16(PUCAN_MSG_CAN_TX);\r\ntx_msg_flags = 0;\r\nif (cfd->can_id & CAN_EFF_FLAG) {\r\ntx_msg_flags |= PUCAN_MSG_EXT_ID;\r\ntx_msg->can_id = cpu_to_le32(cfd->can_id & CAN_EFF_MASK);\r\n} else {\r\ntx_msg->can_id = cpu_to_le32(cfd->can_id & CAN_SFF_MASK);\r\n}\r\nif (can_is_canfd_skb(skb)) {\r\ncan_dlc = can_len2dlc(cfd->len);\r\ntx_msg_flags |= PUCAN_MSG_EXT_DATA_LEN;\r\nif (cfd->flags & CANFD_BRS)\r\ntx_msg_flags |= PUCAN_MSG_BITRATE_SWITCH;\r\nif (cfd->flags & CANFD_ESI)\r\ntx_msg_flags |= PUCAN_MSG_ERROR_STATE_IND;\r\n} else {\r\ncan_dlc = cfd->len;\r\nif (cfd->can_id & CAN_RTR_FLAG)\r\ntx_msg_flags |= PUCAN_MSG_RTR;\r\n}\r\ntx_msg->flags = cpu_to_le16(tx_msg_flags);\r\ntx_msg->channel_dlc = PUCAN_MSG_CHANNEL_DLC(dev->ctrl_idx, can_dlc);\r\nmemcpy(tx_msg->d, cfd->data, cfd->len);\r\ntx_msg = (struct pucan_tx_msg *)(obuf + tx_msg_size);\r\ntx_msg->size = 0;\r\n*size = tx_msg_size + sizeof(u32);\r\nreturn 0;\r\n}\r\nstatic int pcan_usb_fd_start(struct peak_usb_device *dev)\r\n{\r\nstruct pcan_usb_fd_device *pdev =\r\ncontainer_of(dev, struct pcan_usb_fd_device, dev);\r\nint err;\r\nerr = pcan_usb_fd_set_filter_std(dev, -1, 0xffffffff);\r\nif (err)\r\nreturn err;\r\nif (pdev->usb_if->dev_opened_count == 0) {\r\npeak_usb_init_time_ref(&pdev->usb_if->time_ref,\r\n&pcan_usb_pro_fd);\r\nerr = pcan_usb_fd_set_options(dev, 1,\r\nPUCAN_OPTION_ERROR,\r\nPCAN_UFD_FLTEXT_CALIBRATION);\r\n}\r\npdev->usb_if->dev_opened_count++;\r\npdev->bec.txerr = 0;\r\npdev->bec.rxerr = 0;\r\nreturn err;\r\n}\r\nstatic int pcan_usb_fd_get_berr_counter(const struct net_device *netdev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct peak_usb_device *dev = netdev_priv(netdev);\r\nstruct pcan_usb_fd_device *pdev =\r\ncontainer_of(dev, struct pcan_usb_fd_device, dev);\r\n*bec = pdev->bec;\r\nreturn 0;\r\n}\r\nstatic int pcan_usb_fd_stop(struct peak_usb_device *dev)\r\n{\r\nstruct pcan_usb_fd_device *pdev =\r\ncontainer_of(dev, struct pcan_usb_fd_device, dev);\r\nif (pdev->usb_if->dev_opened_count == 1)\r\npcan_usb_fd_set_options(dev, 0,\r\nPUCAN_OPTION_ERROR,\r\nPCAN_UFD_FLTEXT_CALIBRATION);\r\npdev->usb_if->dev_opened_count--;\r\nreturn 0;\r\n}\r\nstatic int pcan_usb_fd_init(struct peak_usb_device *dev)\r\n{\r\nstruct pcan_usb_fd_device *pdev =\r\ncontainer_of(dev, struct pcan_usb_fd_device, dev);\r\nint i, err = -ENOMEM;\r\nif (!dev->prev_siblings) {\r\npdev->usb_if = kzalloc(sizeof(*pdev->usb_if), GFP_KERNEL);\r\nif (!pdev->usb_if)\r\ngoto err_out;\r\npdev->cmd_buffer_addr = kmalloc(PCAN_UFD_CMD_BUFFER_SIZE,\r\nGFP_KERNEL);\r\nif (!pdev->cmd_buffer_addr)\r\ngoto err_out_1;\r\npdev->usb_if->cm_ignore_count = 5;\r\nerr = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_INFO,\r\nPCAN_USBPRO_INFO_FW,\r\n&pdev->usb_if->fw_info,\r\nsizeof(pdev->usb_if->fw_info));\r\nif (err) {\r\ndev_err(dev->netdev->dev.parent,\r\n"unable to read %s firmware info (err %d)\n",\r\ndev->adapter->name, err);\r\ngoto err_out_2;\r\n}\r\ndev_info(dev->netdev->dev.parent,\r\n"PEAK-System %s v%u fw v%u.%u.%u (%u channels)\n",\r\ndev->adapter->name, pdev->usb_if->fw_info.hw_version,\r\npdev->usb_if->fw_info.fw_version[0],\r\npdev->usb_if->fw_info.fw_version[1],\r\npdev->usb_if->fw_info.fw_version[2],\r\ndev->adapter->ctrl_count);\r\nif (pdev->usb_if->fw_info.fw_version[0] >= 2) {\r\ndev->can.ctrlmode_supported |= CAN_CTRLMODE_FD_NON_ISO;\r\n} else {\r\ndev->can.ctrlmode |= CAN_CTRLMODE_FD_NON_ISO;\r\n}\r\nerr = pcan_usb_fd_drv_loaded(dev, 1);\r\nif (err) {\r\ndev_err(dev->netdev->dev.parent,\r\n"unable to tell %s driver is loaded (err %d)\n",\r\ndev->adapter->name, err);\r\ngoto err_out_2;\r\n}\r\n} else {\r\nstruct pcan_usb_fd_device *ppdev =\r\ncontainer_of(dev->prev_siblings,\r\nstruct pcan_usb_fd_device, dev);\r\npdev->usb_if = ppdev->usb_if;\r\npdev->cmd_buffer_addr = ppdev->cmd_buffer_addr;\r\ndev->can.ctrlmode = ppdev->dev.can.ctrlmode;\r\ndev->can.ctrlmode_supported = ppdev->dev.can.ctrlmode_supported;\r\n}\r\npdev->usb_if->dev[dev->ctrl_idx] = dev;\r\ndev->device_number =\r\nle32_to_cpu(pdev->usb_if->fw_info.dev_id[dev->ctrl_idx]);\r\nfor (i = 0; i < ARRAY_SIZE(pcan_usb_fd_clk_freq); i++)\r\nif (dev->adapter->clock.freq == pcan_usb_fd_clk_freq[i])\r\nbreak;\r\nif (i >= ARRAY_SIZE(pcan_usb_fd_clk_freq)) {\r\ndev_warn(dev->netdev->dev.parent,\r\n"incompatible clock frequencies\n");\r\nerr = -EINVAL;\r\ngoto err_out_2;\r\n}\r\npcan_usb_fd_set_clock_domain(dev, i);\r\npcan_usb_fd_set_can_led(dev, PCAN_UFD_LED_DEF);\r\nreturn 0;\r\nerr_out_2:\r\nkfree(pdev->cmd_buffer_addr);\r\nerr_out_1:\r\nkfree(pdev->usb_if);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic void pcan_usb_fd_exit(struct peak_usb_device *dev)\r\n{\r\nstruct pcan_usb_fd_device *pdev =\r\ncontainer_of(dev, struct pcan_usb_fd_device, dev);\r\nif (dev->can.state != CAN_STATE_STOPPED) {\r\npcan_usb_fd_set_bus(dev, 0);\r\n}\r\npcan_usb_fd_set_can_led(dev, PCAN_UFD_LED_OFF);\r\nif (dev->ctrl_idx == 0) {\r\nif (pdev->usb_if->dev_opened_count > 0)\r\npcan_usb_fd_set_options(dev, 0,\r\nPUCAN_OPTION_ERROR,\r\nPCAN_UFD_FLTEXT_CALIBRATION);\r\npcan_usb_fd_drv_loaded(dev, 0);\r\n}\r\n}\r\nstatic void pcan_usb_fd_free(struct peak_usb_device *dev)\r\n{\r\nif (!dev->prev_siblings && !dev->next_siblings) {\r\nstruct pcan_usb_fd_device *pdev =\r\ncontainer_of(dev, struct pcan_usb_fd_device, dev);\r\nkfree(pdev->cmd_buffer_addr);\r\nkfree(pdev->usb_if);\r\n}\r\n}
