static int tilcdc_external_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct tilcdc_drm_private *priv = connector->dev->dev_private;\r\nint ret, i;\r\nret = tilcdc_crtc_mode_valid(priv->crtc, mode);\r\nif (ret != MODE_OK)\r\nreturn ret;\r\nfor (i = 0; i < priv->num_connectors &&\r\npriv->connectors[i] != connector; i++)\r\n;\r\nBUG_ON(priv->connectors[i] != connector);\r\nBUG_ON(!priv->connector_funcs[i]);\r\nif (!IS_ERR(priv->connector_funcs[i]) &&\r\npriv->connector_funcs[i]->mode_valid)\r\nreturn priv->connector_funcs[i]->mode_valid(connector, mode);\r\nreturn MODE_OK;\r\n}\r\nstatic int tilcdc_add_external_encoder(struct drm_device *dev, int *bpp,\r\nstruct drm_connector *connector)\r\n{\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\nstruct drm_connector_helper_funcs *connector_funcs;\r\npriv->connectors[priv->num_connectors] = connector;\r\npriv->encoders[priv->num_encoders++] = connector->encoder;\r\ntilcdc_crtc_set_simulate_vesa_sync(priv->crtc, true);\r\ntilcdc_crtc_set_panel_info(priv->crtc, &panel_info_tda998x);\r\n*bpp = panel_info_tda998x.bpp;\r\nconnector_funcs = devm_kzalloc(dev->dev, sizeof(*connector_funcs),\r\nGFP_KERNEL);\r\nif (!connector_funcs)\r\nreturn -ENOMEM;\r\nif (connector->helper_private) {\r\npriv->connector_funcs[priv->num_connectors] =\r\nconnector->helper_private;\r\n*connector_funcs = *priv->connector_funcs[priv->num_connectors];\r\n} else {\r\npriv->connector_funcs[priv->num_connectors] = ERR_PTR(-ENOENT);\r\n}\r\nconnector_funcs->mode_valid = tilcdc_external_mode_valid;\r\ndrm_connector_helper_add(connector, connector_funcs);\r\npriv->num_connectors++;\r\ndev_dbg(dev->dev, "External encoder '%s' connected\n",\r\nconnector->encoder->name);\r\nreturn 0;\r\n}\r\nint tilcdc_add_external_encoders(struct drm_device *dev, int *bpp)\r\n{\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\nstruct drm_connector *connector;\r\nint num_internal_connectors = priv->num_connectors;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nbool found = false;\r\nint i, ret;\r\nfor (i = 0; i < num_internal_connectors; i++)\r\nif (connector == priv->connectors[i])\r\nfound = true;\r\nif (!found) {\r\nret = tilcdc_add_external_encoder(dev, bpp, connector);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid tilcdc_remove_external_encoders(struct drm_device *dev)\r\n{\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\nint i;\r\nfor (i = 0; i < priv->num_connectors; i++)\r\nif (IS_ERR(priv->connector_funcs[i]))\r\ndrm_connector_helper_add(priv->connectors[i], NULL);\r\nelse if (priv->connector_funcs[i])\r\ndrm_connector_helper_add(priv->connectors[i],\r\npriv->connector_funcs[i]);\r\n}\r\nstatic int dev_match_of(struct device *dev, void *data)\r\n{\r\nreturn dev->of_node == data;\r\n}\r\nint tilcdc_get_external_components(struct device *dev,\r\nstruct component_match **match)\r\n{\r\nstruct device_node *ep = NULL;\r\nint count = 0;\r\nwhile ((ep = of_graph_get_next_endpoint(dev->of_node, ep))) {\r\nstruct device_node *node;\r\nnode = of_graph_get_remote_port_parent(ep);\r\nif (!node && !of_device_is_available(node)) {\r\nof_node_put(node);\r\ncontinue;\r\n}\r\ndev_dbg(dev, "Subdevice node '%s' found\n", node->name);\r\nif (match)\r\ncomponent_match_add(dev, match, dev_match_of, node);\r\nof_node_put(node);\r\ncount++;\r\n}\r\nif (count > 1) {\r\ndev_err(dev, "Only one external encoder is supported\n");\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}
