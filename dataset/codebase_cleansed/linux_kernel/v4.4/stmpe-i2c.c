static int i2c_reg_read(struct stmpe *stmpe, u8 reg)\r\n{\r\nstruct i2c_client *i2c = stmpe->client;\r\nreturn i2c_smbus_read_byte_data(i2c, reg);\r\n}\r\nstatic int i2c_reg_write(struct stmpe *stmpe, u8 reg, u8 val)\r\n{\r\nstruct i2c_client *i2c = stmpe->client;\r\nreturn i2c_smbus_write_byte_data(i2c, reg, val);\r\n}\r\nstatic int i2c_block_read(struct stmpe *stmpe, u8 reg, u8 length, u8 *values)\r\n{\r\nstruct i2c_client *i2c = stmpe->client;\r\nreturn i2c_smbus_read_i2c_block_data(i2c, reg, length, values);\r\n}\r\nstatic int i2c_block_write(struct stmpe *stmpe, u8 reg, u8 length,\r\nconst u8 *values)\r\n{\r\nstruct i2c_client *i2c = stmpe->client;\r\nreturn i2c_smbus_write_i2c_block_data(i2c, reg, length, values);\r\n}\r\nstatic int\r\nstmpe_i2c_probe(struct i2c_client *i2c, const struct i2c_device_id *id)\r\n{\r\nenum stmpe_partnum partnum;\r\nconst struct of_device_id *of_id;\r\ni2c_ci.data = (void *)id;\r\ni2c_ci.irq = i2c->irq;\r\ni2c_ci.client = i2c;\r\ni2c_ci.dev = &i2c->dev;\r\nof_id = of_match_device(stmpe_of_match, &i2c->dev);\r\nif (!of_id) {\r\ndev_info(&i2c->dev, "matching on node name, compatible is preferred\n");\r\npartnum = id->driver_data;\r\n} else\r\npartnum = (enum stmpe_partnum)of_id->data;\r\nreturn stmpe_probe(&i2c_ci, partnum);\r\n}\r\nstatic int stmpe_i2c_remove(struct i2c_client *i2c)\r\n{\r\nstruct stmpe *stmpe = dev_get_drvdata(&i2c->dev);\r\nreturn stmpe_remove(stmpe);\r\n}\r\nstatic int __init stmpe_init(void)\r\n{\r\nreturn i2c_add_driver(&stmpe_i2c_driver);\r\n}\r\nstatic void __exit stmpe_exit(void)\r\n{\r\ni2c_del_driver(&stmpe_i2c_driver);\r\n}
