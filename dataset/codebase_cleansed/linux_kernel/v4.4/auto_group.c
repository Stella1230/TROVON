void __init autogroup_init(struct task_struct *init_task)\r\n{\r\nautogroup_default.tg = &root_task_group;\r\nkref_init(&autogroup_default.kref);\r\ninit_rwsem(&autogroup_default.lock);\r\ninit_task->signal->autogroup = &autogroup_default;\r\n}\r\nvoid autogroup_free(struct task_group *tg)\r\n{\r\nkfree(tg->autogroup);\r\n}\r\nstatic inline void autogroup_destroy(struct kref *kref)\r\n{\r\nstruct autogroup *ag = container_of(kref, struct autogroup, kref);\r\n#ifdef CONFIG_RT_GROUP_SCHED\r\nag->tg->rt_se = NULL;\r\nag->tg->rt_rq = NULL;\r\n#endif\r\nsched_offline_group(ag->tg);\r\nsched_destroy_group(ag->tg);\r\n}\r\nstatic inline void autogroup_kref_put(struct autogroup *ag)\r\n{\r\nkref_put(&ag->kref, autogroup_destroy);\r\n}\r\nstatic inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\r\n{\r\nkref_get(&ag->kref);\r\nreturn ag;\r\n}\r\nstatic inline struct autogroup *autogroup_task_get(struct task_struct *p)\r\n{\r\nstruct autogroup *ag;\r\nunsigned long flags;\r\nif (!lock_task_sighand(p, &flags))\r\nreturn autogroup_kref_get(&autogroup_default);\r\nag = autogroup_kref_get(p->signal->autogroup);\r\nunlock_task_sighand(p, &flags);\r\nreturn ag;\r\n}\r\nstatic inline struct autogroup *autogroup_create(void)\r\n{\r\nstruct autogroup *ag = kzalloc(sizeof(*ag), GFP_KERNEL);\r\nstruct task_group *tg;\r\nif (!ag)\r\ngoto out_fail;\r\ntg = sched_create_group(&root_task_group);\r\nif (IS_ERR(tg))\r\ngoto out_free;\r\nkref_init(&ag->kref);\r\ninit_rwsem(&ag->lock);\r\nag->id = atomic_inc_return(&autogroup_seq_nr);\r\nag->tg = tg;\r\n#ifdef CONFIG_RT_GROUP_SCHED\r\nfree_rt_sched_group(tg);\r\ntg->rt_se = root_task_group.rt_se;\r\ntg->rt_rq = root_task_group.rt_rq;\r\n#endif\r\ntg->autogroup = ag;\r\nsched_online_group(tg, &root_task_group);\r\nreturn ag;\r\nout_free:\r\nkfree(ag);\r\nout_fail:\r\nif (printk_ratelimit()) {\r\nprintk(KERN_WARNING "autogroup_create: %s failure.\n",\r\nag ? "sched_create_group()" : "kmalloc()");\r\n}\r\nreturn autogroup_kref_get(&autogroup_default);\r\n}\r\nbool task_wants_autogroup(struct task_struct *p, struct task_group *tg)\r\n{\r\nif (tg != &root_task_group)\r\nreturn false;\r\nif (p->flags & PF_EXITING)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void\r\nautogroup_move_group(struct task_struct *p, struct autogroup *ag)\r\n{\r\nstruct autogroup *prev;\r\nstruct task_struct *t;\r\nunsigned long flags;\r\nBUG_ON(!lock_task_sighand(p, &flags));\r\nprev = p->signal->autogroup;\r\nif (prev == ag) {\r\nunlock_task_sighand(p, &flags);\r\nreturn;\r\n}\r\np->signal->autogroup = autogroup_kref_get(ag);\r\nif (!READ_ONCE(sysctl_sched_autogroup_enabled))\r\ngoto out;\r\nfor_each_thread(p, t)\r\nsched_move_task(t);\r\nout:\r\nunlock_task_sighand(p, &flags);\r\nautogroup_kref_put(prev);\r\n}\r\nvoid sched_autogroup_create_attach(struct task_struct *p)\r\n{\r\nstruct autogroup *ag = autogroup_create();\r\nautogroup_move_group(p, ag);\r\nautogroup_kref_put(ag);\r\n}\r\nvoid sched_autogroup_detach(struct task_struct *p)\r\n{\r\nautogroup_move_group(p, &autogroup_default);\r\n}\r\nvoid sched_autogroup_fork(struct signal_struct *sig)\r\n{\r\nsig->autogroup = autogroup_task_get(current);\r\n}\r\nvoid sched_autogroup_exit(struct signal_struct *sig)\r\n{\r\nautogroup_kref_put(sig->autogroup);\r\n}\r\nstatic int __init setup_autogroup(char *str)\r\n{\r\nsysctl_sched_autogroup_enabled = 0;\r\nreturn 1;\r\n}\r\nint proc_sched_autogroup_set_nice(struct task_struct *p, int nice)\r\n{\r\nstatic unsigned long next = INITIAL_JIFFIES;\r\nstruct autogroup *ag;\r\nint err;\r\nif (nice < MIN_NICE || nice > MAX_NICE)\r\nreturn -EINVAL;\r\nerr = security_task_setnice(current, nice);\r\nif (err)\r\nreturn err;\r\nif (nice < 0 && !can_nice(current, nice))\r\nreturn -EPERM;\r\nif (!capable(CAP_SYS_ADMIN) && time_before(jiffies, next))\r\nreturn -EAGAIN;\r\nnext = HZ / 10 + jiffies;\r\nag = autogroup_task_get(p);\r\ndown_write(&ag->lock);\r\nerr = sched_group_set_shares(ag->tg, prio_to_weight[nice + 20]);\r\nif (!err)\r\nag->nice = nice;\r\nup_write(&ag->lock);\r\nautogroup_kref_put(ag);\r\nreturn err;\r\n}\r\nvoid proc_sched_autogroup_show_task(struct task_struct *p, struct seq_file *m)\r\n{\r\nstruct autogroup *ag = autogroup_task_get(p);\r\nif (!task_group_is_autogroup(ag->tg))\r\ngoto out;\r\ndown_read(&ag->lock);\r\nseq_printf(m, "/autogroup-%ld nice %d\n", ag->id, ag->nice);\r\nup_read(&ag->lock);\r\nout:\r\nautogroup_kref_put(ag);\r\n}\r\nint autogroup_path(struct task_group *tg, char *buf, int buflen)\r\n{\r\nif (!task_group_is_autogroup(tg))\r\nreturn 0;\r\nreturn snprintf(buf, buflen, "%s-%ld", "/autogroup", tg->autogroup->id);\r\n}
