static inline int restore_sigcontext_fpu(struct sigcontext __user *sc)\r\n{\r\nstruct task_struct *tsk = current;\r\nif (!(boot_cpu_data.flags & CPU_HAS_FPU))\r\nreturn 0;\r\nset_used_math();\r\nreturn __copy_from_user(&tsk->thread.xstate->hardfpu, &sc->sc_fpregs[0],\r\nsizeof(long)*(16*2+2));\r\n}\r\nstatic inline int save_sigcontext_fpu(struct sigcontext __user *sc,\r\nstruct pt_regs *regs)\r\n{\r\nstruct task_struct *tsk = current;\r\nif (!(boot_cpu_data.flags & CPU_HAS_FPU))\r\nreturn 0;\r\nif (!used_math())\r\nreturn __put_user(0, &sc->sc_ownedfp);\r\nif (__put_user(1, &sc->sc_ownedfp))\r\nreturn -EFAULT;\r\nclear_used_math();\r\nunlazy_fpu(tsk, regs);\r\nreturn __copy_to_user(&sc->sc_fpregs[0], &tsk->thread.xstate->hardfpu,\r\nsizeof(long)*(16*2+2));\r\n}\r\nstatic int\r\nrestore_sigcontext(struct pt_regs *regs, struct sigcontext __user *sc, int *r0_p)\r\n{\r\nunsigned int err = 0;\r\n#define COPY(x) err |= __get_user(regs->x, &sc->sc_##x)\r\nCOPY(regs[1]);\r\nCOPY(regs[2]); COPY(regs[3]);\r\nCOPY(regs[4]); COPY(regs[5]);\r\nCOPY(regs[6]); COPY(regs[7]);\r\nCOPY(regs[8]); COPY(regs[9]);\r\nCOPY(regs[10]); COPY(regs[11]);\r\nCOPY(regs[12]); COPY(regs[13]);\r\nCOPY(regs[14]); COPY(regs[15]);\r\nCOPY(gbr); COPY(mach);\r\nCOPY(macl); COPY(pr);\r\nCOPY(sr); COPY(pc);\r\n#undef COPY\r\n#ifdef CONFIG_SH_FPU\r\nif (boot_cpu_data.flags & CPU_HAS_FPU) {\r\nint owned_fp;\r\nstruct task_struct *tsk = current;\r\nregs->sr |= SR_FD;\r\nclear_fpu(tsk, regs);\r\nclear_used_math();\r\nerr |= __get_user (owned_fp, &sc->sc_ownedfp);\r\nif (owned_fp)\r\nerr |= restore_sigcontext_fpu(sc);\r\n}\r\n#endif\r\nregs->tra = -1;\r\nerr |= __get_user(*r0_p, &sc->sc_regs[0]);\r\nreturn err;\r\n}\r\nasmlinkage int sys_sigreturn(void)\r\n{\r\nstruct pt_regs *regs = current_pt_regs();\r\nstruct sigframe __user *frame = (struct sigframe __user *)regs->regs[15];\r\nsigset_t set;\r\nint r0;\r\ncurrent->restart_block.fn = do_no_restart_syscall;\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__get_user(set.sig[0], &frame->sc.oldmask)\r\n|| (_NSIG_WORDS > 1\r\n&& __copy_from_user(&set.sig[1], &frame->extramask,\r\nsizeof(frame->extramask))))\r\ngoto badframe;\r\nset_current_blocked(&set);\r\nif (restore_sigcontext(regs, &frame->sc, &r0))\r\ngoto badframe;\r\nreturn r0;\r\nbadframe:\r\nforce_sig(SIGSEGV, current);\r\nreturn 0;\r\n}\r\nasmlinkage int sys_rt_sigreturn(void)\r\n{\r\nstruct pt_regs *regs = current_pt_regs();\r\nstruct rt_sigframe __user *frame = (struct rt_sigframe __user *)regs->regs[15];\r\nsigset_t set;\r\nint r0;\r\ncurrent->restart_block.fn = do_no_restart_syscall;\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))\r\ngoto badframe;\r\nset_current_blocked(&set);\r\nif (restore_sigcontext(regs, &frame->uc.uc_mcontext, &r0))\r\ngoto badframe;\r\nif (restore_altstack(&frame->uc.uc_stack))\r\ngoto badframe;\r\nreturn r0;\r\nbadframe:\r\nforce_sig(SIGSEGV, current);\r\nreturn 0;\r\n}\r\nstatic int\r\nsetup_sigcontext(struct sigcontext __user *sc, struct pt_regs *regs,\r\nunsigned long mask)\r\n{\r\nint err = 0;\r\n#define COPY(x) err |= __put_user(regs->x, &sc->sc_##x)\r\nCOPY(regs[0]); COPY(regs[1]);\r\nCOPY(regs[2]); COPY(regs[3]);\r\nCOPY(regs[4]); COPY(regs[5]);\r\nCOPY(regs[6]); COPY(regs[7]);\r\nCOPY(regs[8]); COPY(regs[9]);\r\nCOPY(regs[10]); COPY(regs[11]);\r\nCOPY(regs[12]); COPY(regs[13]);\r\nCOPY(regs[14]); COPY(regs[15]);\r\nCOPY(gbr); COPY(mach);\r\nCOPY(macl); COPY(pr);\r\nCOPY(sr); COPY(pc);\r\n#undef COPY\r\n#ifdef CONFIG_SH_FPU\r\nerr |= save_sigcontext_fpu(sc, regs);\r\n#endif\r\nerr |= __put_user(mask, &sc->oldmask);\r\nreturn err;\r\n}\r\nstatic inline void __user *\r\nget_sigframe(struct k_sigaction *ka, unsigned long sp, size_t frame_size)\r\n{\r\nif (ka->sa.sa_flags & SA_ONSTACK) {\r\nif (sas_ss_flags(sp) == 0)\r\nsp = current->sas_ss_sp + current->sas_ss_size;\r\n}\r\nreturn (void __user *)((sp - (frame_size+UNWINDGUARD)) & -8ul);\r\n}\r\nstatic int setup_frame(struct ksignal *ksig, sigset_t *set,\r\nstruct pt_regs *regs)\r\n{\r\nstruct sigframe __user *frame;\r\nint err = 0, sig = ksig->sig;\r\nframe = get_sigframe(&ksig->ka, regs->regs[15], sizeof(*frame));\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\r\nreturn -EFAULT;\r\nerr |= setup_sigcontext(&frame->sc, regs, set->sig[0]);\r\nif (_NSIG_WORDS > 1)\r\nerr |= __copy_to_user(frame->extramask, &set->sig[1],\r\nsizeof(frame->extramask));\r\nif (ksig->ka.sa.sa_flags & SA_RESTORER) {\r\nregs->pr = (unsigned long) ksig->ka.sa.sa_restorer;\r\n#ifdef CONFIG_VSYSCALL\r\n} else if (likely(current->mm->context.vdso)) {\r\nregs->pr = VDSO_SYM(&__kernel_sigreturn);\r\n#endif\r\n} else {\r\nerr |= __put_user(MOVW(7), &frame->retcode[0]);\r\nerr |= __put_user(TRAP_NOARG, &frame->retcode[1]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[2]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[3]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[4]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[5]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[6]);\r\nerr |= __put_user((__NR_sigreturn), &frame->retcode[7]);\r\nregs->pr = (unsigned long) frame->retcode;\r\nflush_icache_range(regs->pr, regs->pr + sizeof(frame->retcode));\r\n}\r\nif (err)\r\nreturn -EFAULT;\r\nregs->regs[15] = (unsigned long) frame;\r\nregs->regs[4] = sig;\r\nregs->regs[5] = 0;\r\nregs->regs[6] = (unsigned long) &frame->sc;\r\nif (current->personality & FDPIC_FUNCPTRS) {\r\nstruct fdpic_func_descriptor __user *funcptr =\r\n(struct fdpic_func_descriptor __user *)ksig->ka.sa.sa_handler;\r\nerr |= __get_user(regs->pc, &funcptr->text);\r\nerr |= __get_user(regs->regs[12], &funcptr->GOT);\r\n} else\r\nregs->pc = (unsigned long)ksig->ka.sa.sa_handler;\r\nif (err)\r\nreturn -EFAULT;\r\npr_debug("SIG deliver (%s:%d): sp=%p pc=%08lx pr=%08lx\n",\r\ncurrent->comm, task_pid_nr(current), frame, regs->pc, regs->pr);\r\nreturn 0;\r\n}\r\nstatic int setup_rt_frame(struct ksignal *ksig, sigset_t *set,\r\nstruct pt_regs *regs)\r\n{\r\nstruct rt_sigframe __user *frame;\r\nint err = 0, sig = ksig->sig;\r\nframe = get_sigframe(&ksig->ka, regs->regs[15], sizeof(*frame));\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\r\nreturn -EFAULT;\r\nerr |= copy_siginfo_to_user(&frame->info, &ksig->info);\r\nerr |= __put_user(0, &frame->uc.uc_flags);\r\nerr |= __put_user(NULL, &frame->uc.uc_link);\r\nerr |= __save_altstack(&frame->uc.uc_stack, regs->regs[15]);\r\nerr |= setup_sigcontext(&frame->uc.uc_mcontext,\r\nregs, set->sig[0]);\r\nerr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\r\nif (ksig->ka.sa.sa_flags & SA_RESTORER) {\r\nregs->pr = (unsigned long) ksig->ka.sa.sa_restorer;\r\n#ifdef CONFIG_VSYSCALL\r\n} else if (likely(current->mm->context.vdso)) {\r\nregs->pr = VDSO_SYM(&__kernel_rt_sigreturn);\r\n#endif\r\n} else {\r\nerr |= __put_user(MOVW(7), &frame->retcode[0]);\r\nerr |= __put_user(TRAP_NOARG, &frame->retcode[1]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[2]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[3]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[4]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[5]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[6]);\r\nerr |= __put_user((__NR_rt_sigreturn), &frame->retcode[7]);\r\nregs->pr = (unsigned long) frame->retcode;\r\nflush_icache_range(regs->pr, regs->pr + sizeof(frame->retcode));\r\n}\r\nif (err)\r\nreturn -EFAULT;\r\nregs->regs[15] = (unsigned long) frame;\r\nregs->regs[4] = sig;\r\nregs->regs[5] = (unsigned long) &frame->info;\r\nregs->regs[6] = (unsigned long) &frame->uc;\r\nif (current->personality & FDPIC_FUNCPTRS) {\r\nstruct fdpic_func_descriptor __user *funcptr =\r\n(struct fdpic_func_descriptor __user *)ksig->ka.sa.sa_handler;\r\nerr |= __get_user(regs->pc, &funcptr->text);\r\nerr |= __get_user(regs->regs[12], &funcptr->GOT);\r\n} else\r\nregs->pc = (unsigned long)ksig->ka.sa.sa_handler;\r\nif (err)\r\nreturn -EFAULT;\r\npr_debug("SIG deliver (%s:%d): sp=%p pc=%08lx pr=%08lx\n",\r\ncurrent->comm, task_pid_nr(current), frame, regs->pc, regs->pr);\r\nreturn 0;\r\n}\r\nstatic inline void\r\nhandle_syscall_restart(unsigned long save_r0, struct pt_regs *regs,\r\nstruct sigaction *sa)\r\n{\r\nif (regs->tra < 0)\r\nreturn;\r\nswitch (regs->regs[0]) {\r\ncase -ERESTART_RESTARTBLOCK:\r\ncase -ERESTARTNOHAND:\r\nno_system_call_restart:\r\nregs->regs[0] = -EINTR;\r\nbreak;\r\ncase -ERESTARTSYS:\r\nif (!(sa->sa_flags & SA_RESTART))\r\ngoto no_system_call_restart;\r\ncase -ERESTARTNOINTR:\r\nregs->regs[0] = save_r0;\r\nregs->pc -= instruction_size(__raw_readw(regs->pc - 4));\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nhandle_signal(struct ksignal *ksig, struct pt_regs *regs, unsigned int save_r0)\r\n{\r\nsigset_t *oldset = sigmask_to_save();\r\nint ret;\r\nif (ksig->ka.sa.sa_flags & SA_SIGINFO)\r\nret = setup_rt_frame(ksig, oldset, regs);\r\nelse\r\nret = setup_frame(ksig, oldset, regs);\r\nsignal_setup_done(ret, ksig, test_thread_flag(TIF_SINGLESTEP));\r\n}\r\nstatic void do_signal(struct pt_regs *regs, unsigned int save_r0)\r\n{\r\nstruct ksignal ksig;\r\nif (!user_mode(regs))\r\nreturn;\r\nif (get_signal(&ksig)) {\r\nhandle_syscall_restart(save_r0, regs, &ksig.ka.sa);\r\nhandle_signal(&ksig, regs, save_r0);\r\nreturn;\r\n}\r\nif (regs->tra >= 0) {\r\nif (regs->regs[0] == -ERESTARTNOHAND ||\r\nregs->regs[0] == -ERESTARTSYS ||\r\nregs->regs[0] == -ERESTARTNOINTR) {\r\nregs->regs[0] = save_r0;\r\nregs->pc -= instruction_size(__raw_readw(regs->pc - 4));\r\n} else if (regs->regs[0] == -ERESTART_RESTARTBLOCK) {\r\nregs->pc -= instruction_size(__raw_readw(regs->pc - 4));\r\nregs->regs[3] = __NR_restart_syscall;\r\n}\r\n}\r\nrestore_saved_sigmask();\r\n}\r\nasmlinkage void do_notify_resume(struct pt_regs *regs, unsigned int save_r0,\r\nunsigned long thread_info_flags)\r\n{\r\nif (thread_info_flags & _TIF_SIGPENDING)\r\ndo_signal(regs, save_r0);\r\nif (thread_info_flags & _TIF_NOTIFY_RESUME) {\r\nclear_thread_flag(TIF_NOTIFY_RESUME);\r\ntracehook_notify_resume(regs);\r\n}\r\n}
