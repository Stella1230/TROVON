acpi_status\r\nacpi_ns_load_table(u32 table_index, struct acpi_namespace_node *node)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ns_load_table);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (acpi_tb_is_table_loaded(table_index)) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto unlock;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"**** Loading table into namespace ****\n"));\r\nstatus = acpi_tb_allocate_owner_id(table_index);\r\nif (ACPI_FAILURE(status)) {\r\ngoto unlock;\r\n}\r\nstatus = acpi_ns_parse_table(table_index, node);\r\nif (ACPI_SUCCESS(status)) {\r\nacpi_tb_set_table_loaded_flag(table_index, TRUE);\r\n} else {\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nacpi_ns_delete_namespace_by_owner(acpi_gbl_root_table_list.\r\ntables[table_index].owner_id);\r\nacpi_tb_release_owner_id(table_index);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nunlock:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"**** Begin Table Object Initialization\n"));\r\nstatus = acpi_ds_initialize_objects(table_index, node);\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"**** Completed Table Object Initialization\n"));\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_ns_load_namespace(void)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_load_name_space);\r\nif (acpi_gbl_DSDT == NULL) {\r\nACPI_ERROR((AE_INFO, "DSDT is not in memory"));\r\nreturn_ACPI_STATUS(AE_NO_ACPI_TABLES);\r\n}\r\nstatus = acpi_ns_load_table_by_type(ACPI_TABLE_ID_DSDT);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n(void)acpi_ns_load_table_by_type(ACPI_TABLE_ID_SSDT);\r\n(void)acpi_ns_load_table_by_type(ACPI_TABLE_ID_PSDT);\r\nACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,\r\n"ACPI Namespace successfully loaded at root %p\n",\r\nacpi_gbl_root_node));\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatic acpi_status acpi_ns_delete_subtree(acpi_handle start_handle)\r\n{\r\nacpi_status status;\r\nacpi_handle child_handle;\r\nacpi_handle parent_handle;\r\nacpi_handle next_child_handle;\r\nacpi_handle dummy;\r\nu32 level;\r\nACPI_FUNCTION_TRACE(ns_delete_subtree);\r\nparent_handle = start_handle;\r\nchild_handle = NULL;\r\nlevel = 1;\r\nwhile (level > 0) {\r\nstatus = acpi_get_next_object(ACPI_TYPE_ANY, parent_handle,\r\nchild_handle, &next_child_handle);\r\nchild_handle = next_child_handle;\r\nif (ACPI_SUCCESS(status)) {\r\nif (ACPI_SUCCESS\r\n(acpi_get_next_object\r\n(ACPI_TYPE_ANY, child_handle, NULL, &dummy))) {\r\nlevel++;\r\nparent_handle = child_handle;\r\nchild_handle = NULL;\r\n}\r\n} else {\r\nlevel--;\r\nacpi_ns_delete_children(child_handle);\r\nchild_handle = parent_handle;\r\nstatus = acpi_get_parent(parent_handle, &parent_handle);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\n}\r\nacpi_ns_remove_node(child_handle);\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status acpi_ns_unload_namespace(acpi_handle handle)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ns_unload_name_space);\r\nif (!acpi_gbl_root_node) {\r\nreturn_ACPI_STATUS(AE_NO_NAMESPACE);\r\n}\r\nif (!handle) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ns_delete_subtree(handle);\r\nreturn_ACPI_STATUS(status);\r\n}
