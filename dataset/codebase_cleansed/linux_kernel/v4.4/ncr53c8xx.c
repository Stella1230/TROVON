static inline struct list_head *ncr_list_pop(struct list_head *head)\r\n{\r\nif (!list_empty(head)) {\r\nstruct list_head *elem = head->next;\r\nlist_del(elem);\r\nreturn elem;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *___m_alloc(m_pool_s *mp, int size)\r\n{\r\nint i = 0;\r\nint s = (1 << MEMO_SHIFT);\r\nint j;\r\nm_addr_t a;\r\nm_link_s *h = mp->h;\r\nif (size > (PAGE_SIZE << MEMO_PAGE_ORDER))\r\nreturn NULL;\r\nwhile (size > s) {\r\ns <<= 1;\r\n++i;\r\n}\r\nj = i;\r\nwhile (!h[j].next) {\r\nif (s == (PAGE_SIZE << MEMO_PAGE_ORDER)) {\r\nh[j].next = (m_link_s *)mp->getp(mp);\r\nif (h[j].next)\r\nh[j].next->next = NULL;\r\nbreak;\r\n}\r\n++j;\r\ns <<= 1;\r\n}\r\na = (m_addr_t) h[j].next;\r\nif (a) {\r\nh[j].next = h[j].next->next;\r\nwhile (j > i) {\r\nj -= 1;\r\ns >>= 1;\r\nh[j].next = (m_link_s *) (a+s);\r\nh[j].next->next = NULL;\r\n}\r\n}\r\n#ifdef DEBUG\r\nprintk("___m_alloc(%d) = %p\n", size, (void *) a);\r\n#endif\r\nreturn (void *) a;\r\n}\r\nstatic void ___m_free(m_pool_s *mp, void *ptr, int size)\r\n{\r\nint i = 0;\r\nint s = (1 << MEMO_SHIFT);\r\nm_link_s *q;\r\nm_addr_t a, b;\r\nm_link_s *h = mp->h;\r\n#ifdef DEBUG\r\nprintk("___m_free(%p, %d)\n", ptr, size);\r\n#endif\r\nif (size > (PAGE_SIZE << MEMO_PAGE_ORDER))\r\nreturn;\r\nwhile (size > s) {\r\ns <<= 1;\r\n++i;\r\n}\r\na = (m_addr_t) ptr;\r\nwhile (1) {\r\n#ifdef MEMO_FREE_UNUSED\r\nif (s == (PAGE_SIZE << MEMO_PAGE_ORDER)) {\r\nmp->freep(mp, a);\r\nbreak;\r\n}\r\n#endif\r\nb = a ^ s;\r\nq = &h[i];\r\nwhile (q->next && q->next != (m_link_s *) b) {\r\nq = q->next;\r\n}\r\nif (!q->next) {\r\n((m_link_s *) a)->next = h[i].next;\r\nh[i].next = (m_link_s *) a;\r\nbreak;\r\n}\r\nq->next = q->next->next;\r\na = a & b;\r\ns <<= 1;\r\n++i;\r\n}\r\n}\r\nstatic void *__m_calloc2(m_pool_s *mp, int size, char *name, int uflags)\r\n{\r\nvoid *p;\r\np = ___m_alloc(mp, size);\r\nif (DEBUG_FLAGS & DEBUG_ALLOC)\r\nprintk ("new %-10s[%4d] @%p.\n", name, size, p);\r\nif (p)\r\nmemset(p, 0, size);\r\nelse if (uflags & MEMO_WARN)\r\nprintk (NAME53C8XX ": failed to allocate %s[%d]\n", name, size);\r\nreturn p;\r\n}\r\nstatic void __m_free(m_pool_s *mp, void *ptr, int size, char *name)\r\n{\r\nif (DEBUG_FLAGS & DEBUG_ALLOC)\r\nprintk ("freeing %-10s[%4d] @%p.\n", name, size, ptr);\r\n___m_free(mp, ptr, size);\r\n}\r\nstatic m_addr_t ___mp0_getp(m_pool_s *mp)\r\n{\r\nm_addr_t m = __get_free_pages(MEMO_GFP_FLAGS, MEMO_PAGE_ORDER);\r\nif (m)\r\n++mp->nump;\r\nreturn m;\r\n}\r\nstatic void ___mp0_freep(m_pool_s *mp, m_addr_t m)\r\n{\r\nfree_pages(m, MEMO_PAGE_ORDER);\r\n--mp->nump;\r\n}\r\nstatic m_addr_t ___dma_getp(m_pool_s *mp)\r\n{\r\nm_addr_t vp;\r\nm_vtob_s *vbp;\r\nvbp = __m_calloc(&mp0, sizeof(*vbp), "VTOB");\r\nif (vbp) {\r\ndma_addr_t daddr;\r\nvp = (m_addr_t) dma_alloc_coherent(mp->bush,\r\nPAGE_SIZE<<MEMO_PAGE_ORDER,\r\n&daddr, GFP_ATOMIC);\r\nif (vp) {\r\nint hc = VTOB_HASH_CODE(vp);\r\nvbp->vaddr = vp;\r\nvbp->baddr = daddr;\r\nvbp->next = mp->vtob[hc];\r\nmp->vtob[hc] = vbp;\r\n++mp->nump;\r\nreturn vp;\r\n}\r\n}\r\nif (vbp)\r\n__m_free(&mp0, vbp, sizeof(*vbp), "VTOB");\r\nreturn 0;\r\n}\r\nstatic void ___dma_freep(m_pool_s *mp, m_addr_t m)\r\n{\r\nm_vtob_s **vbpp, *vbp;\r\nint hc = VTOB_HASH_CODE(m);\r\nvbpp = &mp->vtob[hc];\r\nwhile (*vbpp && (*vbpp)->vaddr != m)\r\nvbpp = &(*vbpp)->next;\r\nif (*vbpp) {\r\nvbp = *vbpp;\r\n*vbpp = (*vbpp)->next;\r\ndma_free_coherent(mp->bush, PAGE_SIZE<<MEMO_PAGE_ORDER,\r\n(void *)vbp->vaddr, (dma_addr_t)vbp->baddr);\r\n__m_free(&mp0, vbp, sizeof(*vbp), "VTOB");\r\n--mp->nump;\r\n}\r\n}\r\nstatic inline m_pool_s *___get_dma_pool(m_bush_t bush)\r\n{\r\nm_pool_s *mp;\r\nfor (mp = mp0.next; mp && mp->bush != bush; mp = mp->next);\r\nreturn mp;\r\n}\r\nstatic m_pool_s *___cre_dma_pool(m_bush_t bush)\r\n{\r\nm_pool_s *mp;\r\nmp = __m_calloc(&mp0, sizeof(*mp), "MPOOL");\r\nif (mp) {\r\nmemset(mp, 0, sizeof(*mp));\r\nmp->bush = bush;\r\nmp->getp = ___dma_getp;\r\nmp->freep = ___dma_freep;\r\nmp->next = mp0.next;\r\nmp0.next = mp;\r\n}\r\nreturn mp;\r\n}\r\nstatic void ___del_dma_pool(m_pool_s *p)\r\n{\r\nstruct m_pool **pp = &mp0.next;\r\nwhile (*pp && *pp != p)\r\npp = &(*pp)->next;\r\nif (*pp) {\r\n*pp = (*pp)->next;\r\n__m_free(&mp0, p, sizeof(*p), "MPOOL");\r\n}\r\n}\r\nstatic void *__m_calloc_dma(m_bush_t bush, int size, char *name)\r\n{\r\nu_long flags;\r\nstruct m_pool *mp;\r\nvoid *m = NULL;\r\nspin_lock_irqsave(&ncr53c8xx_lock, flags);\r\nmp = ___get_dma_pool(bush);\r\nif (!mp)\r\nmp = ___cre_dma_pool(bush);\r\nif (mp)\r\nm = __m_calloc(mp, size, name);\r\nif (mp && !mp->nump)\r\n___del_dma_pool(mp);\r\nspin_unlock_irqrestore(&ncr53c8xx_lock, flags);\r\nreturn m;\r\n}\r\nstatic void __m_free_dma(m_bush_t bush, void *m, int size, char *name)\r\n{\r\nu_long flags;\r\nstruct m_pool *mp;\r\nspin_lock_irqsave(&ncr53c8xx_lock, flags);\r\nmp = ___get_dma_pool(bush);\r\nif (mp)\r\n__m_free(mp, m, size, name);\r\nif (mp && !mp->nump)\r\n___del_dma_pool(mp);\r\nspin_unlock_irqrestore(&ncr53c8xx_lock, flags);\r\n}\r\nstatic m_addr_t __vtobus(m_bush_t bush, void *m)\r\n{\r\nu_long flags;\r\nm_pool_s *mp;\r\nint hc = VTOB_HASH_CODE(m);\r\nm_vtob_s *vp = NULL;\r\nm_addr_t a = ((m_addr_t) m) & ~MEMO_CLUSTER_MASK;\r\nspin_lock_irqsave(&ncr53c8xx_lock, flags);\r\nmp = ___get_dma_pool(bush);\r\nif (mp) {\r\nvp = mp->vtob[hc];\r\nwhile (vp && (m_addr_t) vp->vaddr != a)\r\nvp = vp->next;\r\n}\r\nspin_unlock_irqrestore(&ncr53c8xx_lock, flags);\r\nreturn vp ? vp->baddr + (((m_addr_t) m) - a) : 0;\r\n}\r\nstatic void __unmap_scsi_data(struct device *dev, struct scsi_cmnd *cmd)\r\n{\r\nswitch(cmd->__data_mapped) {\r\ncase 2:\r\nscsi_dma_unmap(cmd);\r\nbreak;\r\n}\r\ncmd->__data_mapped = 0;\r\n}\r\nstatic int __map_scsi_sg_data(struct device *dev, struct scsi_cmnd *cmd)\r\n{\r\nint use_sg;\r\nuse_sg = scsi_dma_map(cmd);\r\nif (!use_sg)\r\nreturn 0;\r\ncmd->__data_mapped = 2;\r\ncmd->__data_mapping = use_sg;\r\nreturn use_sg;\r\n}\r\nstatic int __init get_setup_token(char *p)\r\n{\r\nchar *cur = setup_token;\r\nchar *pc;\r\nint i = 0;\r\nwhile (cur != NULL && (pc = strchr(cur, ':')) != NULL) {\r\n++pc;\r\n++i;\r\nif (!strncmp(p, cur, pc - cur))\r\nreturn i;\r\ncur = pc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init sym53c8xx__setup(char *str)\r\n{\r\n#ifdef SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT\r\nchar *cur = str;\r\nchar *pc, *pv;\r\nint i, val, c;\r\nint xi = 0;\r\nwhile (cur != NULL && (pc = strchr(cur, ':')) != NULL) {\r\nchar *pe;\r\nval = 0;\r\npv = pc;\r\nc = *++pv;\r\nif (c == 'n')\r\nval = 0;\r\nelse if (c == 'y')\r\nval = 1;\r\nelse\r\nval = (int) simple_strtoul(pv, &pe, 0);\r\nswitch (get_setup_token(cur)) {\r\ncase OPT_TAGS:\r\ndriver_setup.default_tags = val;\r\nif (pe && *pe == '/') {\r\ni = 0;\r\nwhile (*pe && *pe != ARG_SEP &&\r\ni < sizeof(driver_setup.tag_ctrl)-1) {\r\ndriver_setup.tag_ctrl[i++] = *pe++;\r\n}\r\ndriver_setup.tag_ctrl[i] = '\0';\r\n}\r\nbreak;\r\ncase OPT_MASTER_PARITY:\r\ndriver_setup.master_parity = val;\r\nbreak;\r\ncase OPT_SCSI_PARITY:\r\ndriver_setup.scsi_parity = val;\r\nbreak;\r\ncase OPT_DISCONNECTION:\r\ndriver_setup.disconnection = val;\r\nbreak;\r\ncase OPT_SPECIAL_FEATURES:\r\ndriver_setup.special_features = val;\r\nbreak;\r\ncase OPT_FORCE_SYNC_NEGO:\r\ndriver_setup.force_sync_nego = val;\r\nbreak;\r\ncase OPT_REVERSE_PROBE:\r\ndriver_setup.reverse_probe = val;\r\nbreak;\r\ncase OPT_DEFAULT_SYNC:\r\ndriver_setup.default_sync = val;\r\nbreak;\r\ncase OPT_VERBOSE:\r\ndriver_setup.verbose = val;\r\nbreak;\r\ncase OPT_DEBUG:\r\ndriver_setup.debug = val;\r\nbreak;\r\ncase OPT_BURST_MAX:\r\ndriver_setup.burst_max = val;\r\nbreak;\r\ncase OPT_LED_PIN:\r\ndriver_setup.led_pin = val;\r\nbreak;\r\ncase OPT_MAX_WIDE:\r\ndriver_setup.max_wide = val? 1:0;\r\nbreak;\r\ncase OPT_SETTLE_DELAY:\r\ndriver_setup.settle_delay = val;\r\nbreak;\r\ncase OPT_DIFF_SUPPORT:\r\ndriver_setup.diff_support = val;\r\nbreak;\r\ncase OPT_IRQM:\r\ndriver_setup.irqm = val;\r\nbreak;\r\ncase OPT_PCI_FIX_UP:\r\ndriver_setup.pci_fix_up = val;\r\nbreak;\r\ncase OPT_BUS_CHECK:\r\ndriver_setup.bus_check = val;\r\nbreak;\r\ncase OPT_OPTIMIZE:\r\ndriver_setup.optimize = val;\r\nbreak;\r\ncase OPT_RECOVERY:\r\ndriver_setup.recovery = val;\r\nbreak;\r\ncase OPT_USE_NVRAM:\r\ndriver_setup.use_nvram = val;\r\nbreak;\r\ncase OPT_SAFE_SETUP:\r\nmemcpy(&driver_setup, &driver_safe_setup,\r\nsizeof(driver_setup));\r\nbreak;\r\ncase OPT_EXCLUDE:\r\nif (xi < SCSI_NCR_MAX_EXCLUDES)\r\ndriver_setup.excludes[xi++] = val;\r\nbreak;\r\ncase OPT_HOST_ID:\r\ndriver_setup.host_id = val;\r\nbreak;\r\n#ifdef SCSI_NCR_IARB_SUPPORT\r\ncase OPT_IARB:\r\ndriver_setup.iarb = val;\r\nbreak;\r\n#endif\r\ndefault:\r\nprintk("sym53c8xx_setup: unexpected boot option '%.*s' ignored\n", (int)(pc-cur+1), cur);\r\nbreak;\r\n}\r\nif ((cur = strchr(cur, ARG_SEP)) != NULL)\r\n++cur;\r\n}\r\n#endif\r\nreturn 1;\r\n}\r\nstatic int device_queue_depth(int unit, int target, int lun)\r\n{\r\nint c, h, t, u, v;\r\nchar *p = driver_setup.tag_ctrl;\r\nchar *ep;\r\nh = -1;\r\nt = NO_TARGET;\r\nu = NO_LUN;\r\nwhile ((c = *p++) != 0) {\r\nv = simple_strtoul(p, &ep, 0);\r\nswitch(c) {\r\ncase '/':\r\n++h;\r\nt = ALL_TARGETS;\r\nu = ALL_LUNS;\r\nbreak;\r\ncase 't':\r\nif (t != target)\r\nt = (target == v) ? v : NO_TARGET;\r\nu = ALL_LUNS;\r\nbreak;\r\ncase 'u':\r\nif (u != lun)\r\nu = (lun == v) ? v : NO_LUN;\r\nbreak;\r\ncase 'q':\r\nif (h == unit &&\r\n(t == ALL_TARGETS || t == target) &&\r\n(u == ALL_LUNS || u == lun))\r\nreturn v;\r\nbreak;\r\ncase '-':\r\nt = ALL_TARGETS;\r\nu = ALL_LUNS;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\np = ep;\r\n}\r\nreturn DEF_DEPTH;\r\n}\r\nstatic inline char *ncr_name (struct ncb *np)\r\n{\r\nreturn np->inst_name;\r\n}\r\nvoid __init ncr_script_fill (struct script * scr, struct scripth * scrh)\r\n{\r\nint i;\r\nncrcmd *p;\r\np = scrh->tryloop;\r\nfor (i=0; i<MAX_START; i++) {\r\n*p++ =SCR_CALL;\r\n*p++ =PADDR (idle);\r\n}\r\nBUG_ON((u_long)p != (u_long)&scrh->tryloop + sizeof (scrh->tryloop));\r\n#ifdef SCSI_NCR_CCB_DONE_SUPPORT\r\np = scrh->done_queue;\r\nfor (i = 0; i<MAX_DONE; i++) {\r\n*p++ =SCR_COPY (sizeof(struct ccb *));\r\n*p++ =NADDR (header.cp);\r\n*p++ =NADDR (ccb_done[i]);\r\n*p++ =SCR_CALL;\r\n*p++ =PADDR (done_end);\r\n}\r\nBUG_ON((u_long)p != (u_long)&scrh->done_queue+sizeof(scrh->done_queue));\r\n#endif\r\np = scrh->hdata_in;\r\nfor (i=0; i<MAX_SCATTERH; i++) {\r\n*p++ =SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN));\r\n*p++ =PADDR (dispatch);\r\n*p++ =SCR_MOVE_TBL ^ SCR_DATA_IN;\r\n*p++ =offsetof (struct dsb, data[i]);\r\n}\r\nBUG_ON((u_long)p != (u_long)&scrh->hdata_in + sizeof (scrh->hdata_in));\r\np = scr->data_in;\r\nfor (i=MAX_SCATTERH; i<MAX_SCATTERH+MAX_SCATTERL; i++) {\r\n*p++ =SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN));\r\n*p++ =PADDR (dispatch);\r\n*p++ =SCR_MOVE_TBL ^ SCR_DATA_IN;\r\n*p++ =offsetof (struct dsb, data[i]);\r\n}\r\nBUG_ON((u_long)p != (u_long)&scr->data_in + sizeof (scr->data_in));\r\np = scrh->hdata_out;\r\nfor (i=0; i<MAX_SCATTERH; i++) {\r\n*p++ =SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT));\r\n*p++ =PADDR (dispatch);\r\n*p++ =SCR_MOVE_TBL ^ SCR_DATA_OUT;\r\n*p++ =offsetof (struct dsb, data[i]);\r\n}\r\nBUG_ON((u_long)p != (u_long)&scrh->hdata_out + sizeof (scrh->hdata_out));\r\np = scr->data_out;\r\nfor (i=MAX_SCATTERH; i<MAX_SCATTERH+MAX_SCATTERL; i++) {\r\n*p++ =SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT));\r\n*p++ =PADDR (dispatch);\r\n*p++ =SCR_MOVE_TBL ^ SCR_DATA_OUT;\r\n*p++ =offsetof (struct dsb, data[i]);\r\n}\r\nBUG_ON((u_long) p != (u_long)&scr->data_out + sizeof (scr->data_out));\r\n}\r\nstatic void __init\r\nncr_script_copy_and_bind (struct ncb *np, ncrcmd *src, ncrcmd *dst, int len)\r\n{\r\nncrcmd opcode, new, old, tmp1, tmp2;\r\nncrcmd *start, *end;\r\nint relocs;\r\nint opchanged = 0;\r\nstart = src;\r\nend = src + len/4;\r\nwhile (src < end) {\r\nopcode = *src++;\r\n*dst++ = cpu_to_scr(opcode);\r\nif (opcode == 0) {\r\nprintk (KERN_ERR "%s: ERROR0 IN SCRIPT at %d.\n",\r\nncr_name(np), (int) (src-start-1));\r\nmdelay(1000);\r\n}\r\nif (DEBUG_FLAGS & DEBUG_SCRIPT)\r\nprintk (KERN_DEBUG "%p: <%x>\n",\r\n(src-1), (unsigned)opcode);\r\nswitch (opcode >> 28) {\r\ncase 0xc:\r\nrelocs = 2;\r\ntmp1 = src[0];\r\n#ifdef RELOC_KVAR\r\nif ((tmp1 & RELOC_MASK) == RELOC_KVAR)\r\ntmp1 = 0;\r\n#endif\r\ntmp2 = src[1];\r\n#ifdef RELOC_KVAR\r\nif ((tmp2 & RELOC_MASK) == RELOC_KVAR)\r\ntmp2 = 0;\r\n#endif\r\nif ((tmp1 ^ tmp2) & 3) {\r\nprintk (KERN_ERR"%s: ERROR1 IN SCRIPT at %d.\n",\r\nncr_name(np), (int) (src-start-1));\r\nmdelay(1000);\r\n}\r\nif ((opcode & SCR_NO_FLUSH) && !(np->features & FE_PFEN)) {\r\ndst[-1] = cpu_to_scr(opcode & ~SCR_NO_FLUSH);\r\n++opchanged;\r\n}\r\nbreak;\r\ncase 0x0:\r\nrelocs = 1;\r\nbreak;\r\ncase 0x8:\r\nif (opcode & 0x00800000)\r\nrelocs = 0;\r\nelse\r\nrelocs = 1;\r\nbreak;\r\ncase 0x4:\r\ncase 0x5:\r\ncase 0x6:\r\ncase 0x7:\r\nrelocs = 1;\r\nbreak;\r\ndefault:\r\nrelocs = 0;\r\nbreak;\r\n}\r\nif (relocs) {\r\nwhile (relocs--) {\r\nold = *src++;\r\nswitch (old & RELOC_MASK) {\r\ncase RELOC_REGISTER:\r\nnew = (old & ~RELOC_MASK) + np->paddr;\r\nbreak;\r\ncase RELOC_LABEL:\r\nnew = (old & ~RELOC_MASK) + np->p_script;\r\nbreak;\r\ncase RELOC_LABELH:\r\nnew = (old & ~RELOC_MASK) + np->p_scripth;\r\nbreak;\r\ncase RELOC_SOFTC:\r\nnew = (old & ~RELOC_MASK) + np->p_ncb;\r\nbreak;\r\n#ifdef RELOC_KVAR\r\ncase RELOC_KVAR:\r\nif (((old & ~RELOC_MASK) <\r\nSCRIPT_KVAR_FIRST) ||\r\n((old & ~RELOC_MASK) >\r\nSCRIPT_KVAR_LAST))\r\npanic("ncr KVAR out of range");\r\nnew = vtophys(script_kvars[old &\r\n~RELOC_MASK]);\r\nbreak;\r\n#endif\r\ncase 0:\r\nif (old == 0) {\r\nnew = old;\r\nbreak;\r\n}\r\ndefault:\r\npanic("ncr_script_copy_and_bind: weird relocation %x\n", old);\r\nbreak;\r\n}\r\n*dst++ = cpu_to_scr(new);\r\n}\r\n} else\r\n*dst++ = cpu_to_scr(*src++);\r\n}\r\n}\r\nstatic void ncr_print_msg(struct ccb *cp, char *label, u_char *msg)\r\n{\r\nPRINT_ADDR(cp->cmd, "%s: ", label);\r\nspi_print_msg(msg);\r\nprintk("\n");\r\n}\r\nstatic inline void ncr_init_burst(struct ncb *np, u_char bc)\r\n{\r\nu_char *be = &np->rv_ctest0;\r\n*be &= ~0x80;\r\nnp->rv_dmode &= ~(0x3 << 6);\r\nnp->rv_ctest5 &= ~0x4;\r\nif (!bc) {\r\n*be |= 0x80;\r\n} else {\r\n--bc;\r\nnp->rv_dmode |= ((bc & 0x3) << 6);\r\nnp->rv_ctest5 |= (bc & 0x4);\r\n}\r\n}\r\nstatic void __init ncr_prepare_setting(struct ncb *np)\r\n{\r\nu_char burst_max;\r\nu_long period;\r\nint i;\r\nnp->sv_scntl0 = INB(nc_scntl0) & 0x0a;\r\nnp->sv_scntl3 = INB(nc_scntl3) & 0x07;\r\nnp->sv_dmode = INB(nc_dmode) & 0xce;\r\nnp->sv_dcntl = INB(nc_dcntl) & 0xa8;\r\nnp->sv_ctest0 = INB(nc_ctest0) & 0x84;\r\nnp->sv_ctest3 = INB(nc_ctest3) & 0x01;\r\nnp->sv_ctest4 = INB(nc_ctest4) & 0x80;\r\nnp->sv_ctest5 = INB(nc_ctest5) & 0x24;\r\nnp->sv_gpcntl = INB(nc_gpcntl);\r\nnp->sv_stest2 = INB(nc_stest2) & 0x20;\r\nnp->sv_stest4 = INB(nc_stest4);\r\nnp->maxwide = (np->features & FE_WIDE)? 1 : 0;\r\nif (np->features & FE_ULTRA)\r\nnp->clock_khz = 80000;\r\nelse\r\nnp->clock_khz = 40000;\r\nif (np->features & FE_QUAD)\r\nnp->multiplier = 4;\r\nelse if (np->features & FE_DBLR)\r\nnp->multiplier = 2;\r\nelse\r\nnp->multiplier = 1;\r\nif (np->features & FE_VARCLK)\r\nncr_getclock(np, np->multiplier);\r\ni = np->clock_divn - 1;\r\nwhile (--i >= 0) {\r\nif (10ul * SCSI_NCR_MIN_ASYNC * np->clock_khz > div_10M[i]) {\r\n++i;\r\nbreak;\r\n}\r\n}\r\nnp->rv_scntl3 = i+1;\r\nperiod = (4 * div_10M[0] + np->clock_khz - 1) / np->clock_khz;\r\nif (period <= 250) np->minsync = 10;\r\nelse if (period <= 303) np->minsync = 11;\r\nelse if (period <= 500) np->minsync = 12;\r\nelse np->minsync = (period + 40 - 1) / 40;\r\nif (np->minsync < 25 && !(np->features & FE_ULTRA))\r\nnp->minsync = 25;\r\nperiod = (11 * div_10M[np->clock_divn - 1]) / (4 * np->clock_khz);\r\nnp->maxsync = period > 2540 ? 254 : period / 10;\r\n#if defined SCSI_NCR_TRUST_BIOS_SETTING\r\nnp->rv_scntl0 = np->sv_scntl0;\r\nnp->rv_dmode = np->sv_dmode;\r\nnp->rv_dcntl = np->sv_dcntl;\r\nnp->rv_ctest0 = np->sv_ctest0;\r\nnp->rv_ctest3 = np->sv_ctest3;\r\nnp->rv_ctest4 = np->sv_ctest4;\r\nnp->rv_ctest5 = np->sv_ctest5;\r\nburst_max = burst_code(np->sv_dmode, np->sv_ctest0);\r\n#else\r\nburst_max = driver_setup.burst_max;\r\nif (burst_max == 255)\r\nburst_max = burst_code(np->sv_dmode, np->sv_ctest0);\r\nif (burst_max > 7)\r\nburst_max = 7;\r\nif (burst_max > np->maxburst)\r\nburst_max = np->maxburst;\r\nif (np->features & FE_ERL)\r\nnp->rv_dmode |= ERL;\r\nif (np->features & FE_BOF)\r\nnp->rv_dmode |= BOF;\r\nif (np->features & FE_ERMP)\r\nnp->rv_dmode |= ERMP;\r\nif (np->features & FE_PFEN)\r\nnp->rv_dcntl |= PFEN;\r\nif (np->features & FE_CLSE)\r\nnp->rv_dcntl |= CLSE;\r\nif (np->features & FE_WRIE)\r\nnp->rv_ctest3 |= WRIE;\r\nif (np->features & FE_DFS)\r\nnp->rv_ctest5 |= DFS;\r\nif (np->features & FE_MUX)\r\nnp->rv_ctest4 |= MUX;\r\nif (np->features & FE_EA)\r\nnp->rv_dcntl |= EA;\r\nif (np->features & FE_EHP)\r\nnp->rv_ctest0 |= EHP;\r\nif (driver_setup.master_parity)\r\nnp->rv_ctest4 |= MPEE;\r\nif (driver_setup.scsi_parity)\r\nnp->rv_scntl0 |= 0x0a;\r\nif (np->myaddr == 255) {\r\nnp->myaddr = INB(nc_scid) & 0x07;\r\nif (!np->myaddr)\r\nnp->myaddr = SCSI_NCR_MYADDR;\r\n}\r\n#endif\r\nncr_init_burst(np, burst_max);\r\nnp->scsi_mode = SMODE_SE;\r\nif (np->features & FE_DIFF) {\r\nswitch(driver_setup.diff_support) {\r\ncase 4:\r\nif (np->sv_scntl3) {\r\nif (np->sv_stest2 & 0x20)\r\nnp->scsi_mode = SMODE_HVD;\r\nbreak;\r\n}\r\ncase 3:\r\nif (INB(nc_gpreg) & 0x08)\r\nbreak;\r\ncase 2:\r\nnp->scsi_mode = SMODE_HVD;\r\ncase 1:\r\nif (np->sv_stest2 & 0x20)\r\nnp->scsi_mode = SMODE_HVD;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (np->scsi_mode == SMODE_HVD)\r\nnp->rv_stest2 |= 0x20;\r\nif ((driver_setup.led_pin) &&\r\n!(np->features & FE_LEDC) && !(np->sv_gpcntl & 0x01))\r\nnp->features |= FE_LED0;\r\nswitch(driver_setup.irqm & 3) {\r\ncase 2:\r\nnp->rv_dcntl |= IRQM;\r\nbreak;\r\ncase 1:\r\nnp->rv_dcntl |= (np->sv_dcntl & IRQM);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfor (i = 0 ; i < MAX_TARGET ; i++) {\r\nstruct tcb *tp = &np->target[i];\r\ntp->usrsync = driver_setup.default_sync;\r\ntp->usrwide = driver_setup.max_wide;\r\ntp->usrtags = MAX_TAGS;\r\ntp->period = 0xffff;\r\nif (!driver_setup.disconnection)\r\nnp->target[i].usrflag = UF_NODISC;\r\n}\r\nprintk(KERN_INFO "%s: ID %d, Fast-%d%s%s\n", ncr_name(np),\r\nnp->myaddr,\r\nnp->minsync < 12 ? 40 : (np->minsync < 25 ? 20 : 10),\r\n(np->rv_scntl0 & 0xa) ? ", Parity Checking" : ", NO Parity",\r\n(np->rv_stest2 & 0x20) ? ", Differential" : "");\r\nif (bootverbose > 1) {\r\nprintk (KERN_INFO "%s: initial SCNTL3/DMODE/DCNTL/CTEST3/4/5 = "\r\n"(hex) %02x/%02x/%02x/%02x/%02x/%02x\n",\r\nncr_name(np), np->sv_scntl3, np->sv_dmode, np->sv_dcntl,\r\nnp->sv_ctest3, np->sv_ctest4, np->sv_ctest5);\r\nprintk (KERN_INFO "%s: final SCNTL3/DMODE/DCNTL/CTEST3/4/5 = "\r\n"(hex) %02x/%02x/%02x/%02x/%02x/%02x\n",\r\nncr_name(np), np->rv_scntl3, np->rv_dmode, np->rv_dcntl,\r\nnp->rv_ctest3, np->rv_ctest4, np->rv_ctest5);\r\n}\r\nif (bootverbose && np->paddr2)\r\nprintk (KERN_INFO "%s: on-chip RAM at 0x%lx\n",\r\nncr_name(np), np->paddr2);\r\n}\r\nstatic inline void ncr_queue_done_cmd(struct ncb *np, struct scsi_cmnd *cmd)\r\n{\r\nunmap_scsi_data(np, cmd);\r\ncmd->host_scribble = (char *) np->done_list;\r\nnp->done_list = cmd;\r\n}\r\nstatic inline void ncr_flush_done_cmds(struct scsi_cmnd *lcmd)\r\n{\r\nstruct scsi_cmnd *cmd;\r\nwhile (lcmd) {\r\ncmd = lcmd;\r\nlcmd = (struct scsi_cmnd *) cmd->host_scribble;\r\ncmd->scsi_done(cmd);\r\n}\r\n}\r\nstatic int ncr_prepare_nego(struct ncb *np, struct ccb *cp, u_char *msgptr)\r\n{\r\nstruct tcb *tp = &np->target[cp->target];\r\nint msglen = 0;\r\nint nego = 0;\r\nstruct scsi_target *starget = tp->starget;\r\nif (!tp->widedone) {\r\nif (spi_support_wide(starget)) {\r\nnego = NS_WIDE;\r\n} else\r\ntp->widedone=1;\r\n}\r\nif (!nego && !tp->period) {\r\nif (spi_support_sync(starget)) {\r\nnego = NS_SYNC;\r\n} else {\r\ntp->period =0xffff;\r\ndev_info(&starget->dev, "target did not report SYNC.\n");\r\n}\r\n}\r\nswitch (nego) {\r\ncase NS_SYNC:\r\nmsglen += spi_populate_sync_msg(msgptr + msglen,\r\ntp->maxoffs ? tp->minsync : 0, tp->maxoffs);\r\nbreak;\r\ncase NS_WIDE:\r\nmsglen += spi_populate_width_msg(msgptr + msglen, tp->usrwide);\r\nbreak;\r\n}\r\ncp->nego_status = nego;\r\nif (nego) {\r\ntp->nego_cp = cp;\r\nif (DEBUG_FLAGS & DEBUG_NEGO) {\r\nncr_print_msg(cp, nego == NS_WIDE ?\r\n"wide msgout":"sync_msgout", msgptr);\r\n}\r\n}\r\nreturn msglen;\r\n}\r\nstatic int ncr_queue_command (struct ncb *np, struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_device *sdev = cmd->device;\r\nstruct tcb *tp = &np->target[sdev->id];\r\nstruct lcb *lp = tp->lp[sdev->lun];\r\nstruct ccb *cp;\r\nint segments;\r\nu_char idmsg, *msgptr;\r\nu32 msglen;\r\nint direction;\r\nu32 lastp, goalp;\r\nif ((sdev->id == np->myaddr ) ||\r\n(sdev->id >= MAX_TARGET) ||\r\n(sdev->lun >= MAX_LUN )) {\r\nreturn(DID_BAD_TARGET);\r\n}\r\nif ((cmd->cmnd[0] == 0 || cmd->cmnd[0] == 0x12) &&\r\n(tp->usrflag & UF_NOSCAN)) {\r\ntp->usrflag &= ~UF_NOSCAN;\r\nreturn DID_BAD_TARGET;\r\n}\r\nif (DEBUG_FLAGS & DEBUG_TINY) {\r\nPRINT_ADDR(cmd, "CMD=%x ", cmd->cmnd[0]);\r\n}\r\nif (np->settle_time && cmd->request->timeout >= HZ) {\r\nu_long tlimit = jiffies + cmd->request->timeout - HZ;\r\nif (time_after(np->settle_time, tlimit))\r\nnp->settle_time = tlimit;\r\n}\r\nif (np->settle_time || !(cp=ncr_get_ccb (np, cmd))) {\r\ninsert_into_waiting_list(np, cmd);\r\nreturn(DID_OK);\r\n}\r\ncp->cmd = cmd;\r\nidmsg = IDENTIFY(0, sdev->lun);\r\nif (cp ->tag != NO_TAG ||\r\n(cp != np->ccb && np->disc && !(tp->usrflag & UF_NODISC)))\r\nidmsg |= 0x40;\r\nmsgptr = cp->scsi_smsg;\r\nmsglen = 0;\r\nmsgptr[msglen++] = idmsg;\r\nif (cp->tag != NO_TAG) {\r\nchar order = np->order;\r\nif (lp && time_after(jiffies, lp->tags_stime)) {\r\nif (lp->tags_smap) {\r\norder = ORDERED_QUEUE_TAG;\r\nif ((DEBUG_FLAGS & DEBUG_TAGS)||bootverbose>2){\r\nPRINT_ADDR(cmd,\r\n"ordered tag forced.\n");\r\n}\r\n}\r\nlp->tags_stime = jiffies + 3*HZ;\r\nlp->tags_smap = lp->tags_umap;\r\n}\r\nif (order == 0) {\r\nswitch (cmd->cmnd[0]) {\r\ncase 0x08:\r\ncase 0x28:\r\ncase 0xa8:\r\norder = SIMPLE_QUEUE_TAG;\r\nbreak;\r\ndefault:\r\norder = ORDERED_QUEUE_TAG;\r\n}\r\n}\r\nmsgptr[msglen++] = order;\r\nmsgptr[msglen++] = (cp->tag << 1) + 1;\r\n}\r\ndirection = cmd->sc_data_direction;\r\nif (direction != DMA_NONE) {\r\nsegments = ncr_scatter(np, cp, cp->cmd);\r\nif (segments < 0) {\r\nncr_free_ccb(np, cp);\r\nreturn(DID_ERROR);\r\n}\r\n}\r\nelse {\r\ncp->data_len = 0;\r\nsegments = 0;\r\n}\r\ncp->nego_status = 0;\r\nif ((!tp->widedone || !tp->period) && !tp->nego_cp && lp) {\r\nmsglen += ncr_prepare_nego (np, cp, msgptr + msglen);\r\n}\r\nif (!cp->data_len)\r\ndirection = DMA_NONE;\r\nswitch(direction) {\r\ncase DMA_BIDIRECTIONAL:\r\ncase DMA_TO_DEVICE:\r\ngoalp = NCB_SCRIPT_PHYS (np, data_out2) + 8;\r\nif (segments <= MAX_SCATTERL)\r\nlastp = goalp - 8 - (segments * 16);\r\nelse {\r\nlastp = NCB_SCRIPTH_PHYS (np, hdata_out2);\r\nlastp -= (segments - MAX_SCATTERL) * 16;\r\n}\r\nif (direction != DMA_BIDIRECTIONAL)\r\nbreak;\r\ncp->phys.header.wgoalp = cpu_to_scr(goalp);\r\ncp->phys.header.wlastp = cpu_to_scr(lastp);\r\ncase DMA_FROM_DEVICE:\r\ngoalp = NCB_SCRIPT_PHYS (np, data_in2) + 8;\r\nif (segments <= MAX_SCATTERL)\r\nlastp = goalp - 8 - (segments * 16);\r\nelse {\r\nlastp = NCB_SCRIPTH_PHYS (np, hdata_in2);\r\nlastp -= (segments - MAX_SCATTERL) * 16;\r\n}\r\nbreak;\r\ndefault:\r\ncase DMA_NONE:\r\nlastp = goalp = NCB_SCRIPT_PHYS (np, no_data);\r\nbreak;\r\n}\r\ncp->phys.header.lastp = cpu_to_scr(lastp);\r\ncp->phys.header.goalp = cpu_to_scr(goalp);\r\nif (direction == DMA_BIDIRECTIONAL)\r\ncp->phys.header.savep =\r\ncpu_to_scr(NCB_SCRIPTH_PHYS (np, data_io));\r\nelse\r\ncp->phys.header.savep= cpu_to_scr(lastp);\r\ncp->startp = cp->phys.header.savep;\r\ncp->start.schedule.l_paddr = cpu_to_scr(NCB_SCRIPT_PHYS (np, select));\r\ncp->restart.schedule.l_paddr = cpu_to_scr(NCB_SCRIPT_PHYS (np, resel_dsa));\r\ncp->phys.select.sel_id = sdev_id(sdev);\r\ncp->phys.select.sel_scntl3 = tp->wval;\r\ncp->phys.select.sel_sxfer = tp->sval;\r\ncp->phys.smsg.addr = cpu_to_scr(CCB_PHYS (cp, scsi_smsg));\r\ncp->phys.smsg.size = cpu_to_scr(msglen);\r\nmemcpy(cp->cdb_buf, cmd->cmnd, min_t(int, cmd->cmd_len, sizeof(cp->cdb_buf)));\r\ncp->phys.cmd.addr = cpu_to_scr(CCB_PHYS (cp, cdb_buf[0]));\r\ncp->phys.cmd.size = cpu_to_scr(cmd->cmd_len);\r\ncp->actualquirks = 0;\r\ncp->host_status = cp->nego_status ? HS_NEGOTIATE : HS_BUSY;\r\ncp->scsi_status = S_ILLEGAL;\r\ncp->parity_status = 0;\r\ncp->xerr_status = XE_OK;\r\n#if 0\r\ncp->sync_status = tp->sval;\r\ncp->wide_status = tp->wval;\r\n#endif\r\ncp->magic = CCB_MAGIC;\r\ncp->auto_sense = 0;\r\nif (lp)\r\nncr_start_next_ccb(np, lp, 2);\r\nelse\r\nncr_put_start_queue(np, cp);\r\nreturn DID_OK;\r\n}\r\nstatic void ncr_start_next_ccb(struct ncb *np, struct lcb *lp, int maxn)\r\n{\r\nstruct list_head *qp;\r\nstruct ccb *cp;\r\nif (lp->held_ccb)\r\nreturn;\r\nwhile (maxn-- && lp->queuedccbs < lp->queuedepth) {\r\nqp = ncr_list_pop(&lp->wait_ccbq);\r\nif (!qp)\r\nbreak;\r\n++lp->queuedccbs;\r\ncp = list_entry(qp, struct ccb, link_ccbq);\r\nlist_add_tail(qp, &lp->busy_ccbq);\r\nlp->jump_ccb[cp->tag == NO_TAG ? 0 : cp->tag] =\r\ncpu_to_scr(CCB_PHYS (cp, restart));\r\nncr_put_start_queue(np, cp);\r\n}\r\n}\r\nstatic void ncr_put_start_queue(struct ncb *np, struct ccb *cp)\r\n{\r\nu16 qidx;\r\nif (!np->squeueput) np->squeueput = 1;\r\nqidx = np->squeueput + 2;\r\nif (qidx >= MAX_START + MAX_START) qidx = 1;\r\nnp->scripth->tryloop [qidx] = cpu_to_scr(NCB_SCRIPT_PHYS (np, idle));\r\nMEMORY_BARRIER();\r\nnp->scripth->tryloop [np->squeueput] = cpu_to_scr(CCB_PHYS (cp, start));\r\nnp->squeueput = qidx;\r\n++np->queuedccbs;\r\ncp->queued = 1;\r\nif (DEBUG_FLAGS & DEBUG_QUEUE)\r\nprintk ("%s: queuepos=%d.\n", ncr_name (np), np->squeueput);\r\nMEMORY_BARRIER();\r\nOUTB (nc_istat, SIGP);\r\n}\r\nstatic int ncr_reset_scsi_bus(struct ncb *np, int enab_int, int settle_delay)\r\n{\r\nu32 term;\r\nint retv = 0;\r\nnp->settle_time = jiffies + settle_delay * HZ;\r\nif (bootverbose > 1)\r\nprintk("%s: resetting, "\r\n"command processing suspended for %d seconds\n",\r\nncr_name(np), settle_delay);\r\nncr_chip_reset(np, 100);\r\nudelay(2000);\r\nif (enab_int)\r\nOUTW (nc_sien, RST);\r\nOUTB (nc_stest3, TE);\r\nOUTB (nc_scntl1, CRST);\r\nudelay(200);\r\nif (!driver_setup.bus_check)\r\ngoto out;\r\nterm = INB(nc_sstat0);\r\nterm = ((term & 2) << 7) + ((term & 1) << 17);\r\nterm |= ((INB(nc_sstat2) & 0x01) << 26) |\r\n((INW(nc_sbdl) & 0xff) << 9) |\r\n((INW(nc_sbdl) & 0xff00) << 10) |\r\nINB(nc_sbcl);\r\nif (!(np->features & FE_WIDE))\r\nterm &= 0x3ffff;\r\nif (term != (2<<7)) {\r\nprintk("%s: suspicious SCSI data while resetting the BUS.\n",\r\nncr_name(np));\r\nprintk("%s: %sdp0,d7-0,rst,req,ack,bsy,sel,atn,msg,c/d,i/o = "\r\n"0x%lx, expecting 0x%lx\n",\r\nncr_name(np),\r\n(np->features & FE_WIDE) ? "dp1,d15-8," : "",\r\n(u_long)term, (u_long)(2<<7));\r\nif (driver_setup.bus_check == 1)\r\nretv = 1;\r\n}\r\nout:\r\nOUTB (nc_scntl1, 0);\r\nreturn retv;\r\n}\r\nstatic void ncr_start_reset(struct ncb *np)\r\n{\r\nif (!np->settle_time) {\r\nncr_reset_scsi_bus(np, 1, driver_setup.settle_delay);\r\n}\r\n}\r\nstatic int ncr_reset_bus (struct ncb *np, struct scsi_cmnd *cmd, int sync_reset)\r\n{\r\nstruct ccb *cp;\r\nint found;\r\nif (np->settle_time) {\r\nreturn FAILED;\r\n}\r\nncr_start_reset(np);\r\nfor (found=0, cp=np->ccb; cp; cp=cp->link_ccb) {\r\nif (cp->host_status == HS_IDLE) continue;\r\nif (cp->cmd == cmd) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found && retrieve_from_waiting_list(0, np, cmd))\r\nfound = 1;\r\nreset_waiting_list(np);\r\nncr_wakeup(np, HS_RESET);\r\nif (!found && sync_reset && !retrieve_from_waiting_list(0, np, cmd)) {\r\ncmd->result = ScsiResult(DID_RESET, 0);\r\nncr_queue_done_cmd(np, cmd);\r\n}\r\nreturn SUCCESS;\r\n}\r\nstatic void ncr_detach(struct ncb *np)\r\n{\r\nstruct ccb *cp;\r\nstruct tcb *tp;\r\nstruct lcb *lp;\r\nint target, lun;\r\nint i;\r\nchar inst_name[16];\r\nstrlcpy(inst_name, ncr_name(np), sizeof(inst_name));\r\nprintk("%s: releasing host resources\n", ncr_name(np));\r\n#ifdef DEBUG_NCR53C8XX\r\nprintk("%s: stopping the timer\n", ncr_name(np));\r\n#endif\r\nnp->release_stage = 1;\r\nfor (i = 50 ; i && np->release_stage != 2 ; i--)\r\nmdelay(100);\r\nif (np->release_stage != 2)\r\nprintk("%s: the timer seems to be already stopped\n", ncr_name(np));\r\nelse np->release_stage = 2;\r\n#ifdef DEBUG_NCR53C8XX\r\nprintk("%s: disabling chip interrupts\n", ncr_name(np));\r\n#endif\r\nOUTW (nc_sien , 0);\r\nOUTB (nc_dien , 0);\r\nprintk("%s: resetting chip\n", ncr_name(np));\r\nncr_chip_reset(np, 100);\r\nOUTB(nc_dmode, np->sv_dmode);\r\nOUTB(nc_dcntl, np->sv_dcntl);\r\nOUTB(nc_ctest0, np->sv_ctest0);\r\nOUTB(nc_ctest3, np->sv_ctest3);\r\nOUTB(nc_ctest4, np->sv_ctest4);\r\nOUTB(nc_ctest5, np->sv_ctest5);\r\nOUTB(nc_gpcntl, np->sv_gpcntl);\r\nOUTB(nc_stest2, np->sv_stest2);\r\nncr_selectclock(np, np->sv_scntl3);\r\nwhile ((cp=np->ccb->link_ccb) != NULL) {\r\nnp->ccb->link_ccb = cp->link_ccb;\r\nif (cp->host_status) {\r\nprintk("%s: shall free an active ccb (host_status=%d)\n",\r\nncr_name(np), cp->host_status);\r\n}\r\n#ifdef DEBUG_NCR53C8XX\r\nprintk("%s: freeing ccb (%lx)\n", ncr_name(np), (u_long) cp);\r\n#endif\r\nm_free_dma(cp, sizeof(*cp), "CCB");\r\n}\r\nfor (target = 0; target < MAX_TARGET ; target++) {\r\ntp=&np->target[target];\r\nfor (lun = 0 ; lun < MAX_LUN ; lun++) {\r\nlp = tp->lp[lun];\r\nif (lp) {\r\n#ifdef DEBUG_NCR53C8XX\r\nprintk("%s: freeing lp (%lx)\n", ncr_name(np), (u_long) lp);\r\n#endif\r\nif (lp->jump_ccb != &lp->jump_ccb_0)\r\nm_free_dma(lp->jump_ccb,256,"JUMP_CCB");\r\nm_free_dma(lp, sizeof(*lp), "LCB");\r\n}\r\n}\r\n}\r\nif (np->scripth0)\r\nm_free_dma(np->scripth0, sizeof(struct scripth), "SCRIPTH");\r\nif (np->script0)\r\nm_free_dma(np->script0, sizeof(struct script), "SCRIPT");\r\nif (np->ccb)\r\nm_free_dma(np->ccb, sizeof(struct ccb), "CCB");\r\nm_free_dma(np, sizeof(struct ncb), "NCB");\r\nprintk("%s: host resources successfully released\n", inst_name);\r\n}\r\nvoid ncr_complete (struct ncb *np, struct ccb *cp)\r\n{\r\nstruct scsi_cmnd *cmd;\r\nstruct tcb *tp;\r\nstruct lcb *lp;\r\nif (!cp || cp->magic != CCB_MAGIC || !cp->cmd)\r\nreturn;\r\nif (DEBUG_FLAGS & DEBUG_TINY)\r\nprintk ("CCB=%lx STAT=%x/%x\n", (unsigned long)cp,\r\ncp->host_status,cp->scsi_status);\r\ncmd = cp->cmd;\r\ncp->cmd = NULL;\r\ntp = &np->target[cmd->device->id];\r\nlp = tp->lp[cmd->device->lun];\r\nif (cp == tp->nego_cp)\r\ntp->nego_cp = NULL;\r\nif (cp->auto_sense) {\r\ncp->scsi_status = cp->auto_sense;\r\n}\r\nif (lp && lp->held_ccb) {\r\nif (cp == lp->held_ccb) {\r\nlist_splice_init(&lp->skip_ccbq, &lp->wait_ccbq);\r\nlp->held_ccb = NULL;\r\n}\r\n}\r\nif (cp->parity_status > 1) {\r\nPRINT_ADDR(cmd, "%d parity error(s).\n",cp->parity_status);\r\n}\r\nif (cp->xerr_status != XE_OK) {\r\nswitch (cp->xerr_status) {\r\ncase XE_EXTRA_DATA:\r\nPRINT_ADDR(cmd, "extraneous data discarded.\n");\r\nbreak;\r\ncase XE_BAD_PHASE:\r\nPRINT_ADDR(cmd, "invalid scsi phase (4/5).\n");\r\nbreak;\r\ndefault:\r\nPRINT_ADDR(cmd, "extended error %d.\n",\r\ncp->xerr_status);\r\nbreak;\r\n}\r\nif (cp->host_status==HS_COMPLETE)\r\ncp->host_status = HS_FAIL;\r\n}\r\nif (DEBUG_FLAGS & (DEBUG_RESULT|DEBUG_TINY)) {\r\nif (cp->host_status!=HS_COMPLETE || cp->scsi_status!=S_GOOD) {\r\nPRINT_ADDR(cmd, "ERROR: cmd=%x host_status=%x "\r\n"scsi_status=%x\n", cmd->cmnd[0],\r\ncp->host_status, cp->scsi_status);\r\n}\r\n}\r\nif ( (cp->host_status == HS_COMPLETE)\r\n&& (cp->scsi_status == S_GOOD ||\r\ncp->scsi_status == S_COND_MET)) {\r\ncmd->result = ScsiResult(DID_OK, cp->scsi_status);\r\nif (!lp)\r\nncr_alloc_lcb (np, cmd->device->id, cmd->device->lun);\r\ntp->bytes += cp->data_len;\r\ntp->transfers ++;\r\nif (lp && lp->usetags && lp->numtags < lp->maxtags) {\r\n++lp->num_good;\r\nif (lp->num_good >= 1000) {\r\nlp->num_good = 0;\r\n++lp->numtags;\r\nncr_setup_tags (np, cmd->device);\r\n}\r\n}\r\n} else if ((cp->host_status == HS_COMPLETE)\r\n&& (cp->scsi_status == S_CHECK_COND)) {\r\ncmd->result = ScsiResult(DID_OK, S_CHECK_COND);\r\nmemcpy(cmd->sense_buffer, cp->sense_buf,\r\nmin_t(size_t, SCSI_SENSE_BUFFERSIZE,\r\nsizeof(cp->sense_buf)));\r\nif (DEBUG_FLAGS & (DEBUG_RESULT|DEBUG_TINY)) {\r\nu_char *p = cmd->sense_buffer;\r\nint i;\r\nPRINT_ADDR(cmd, "sense data:");\r\nfor (i=0; i<14; i++) printk (" %x", *p++);\r\nprintk (".\n");\r\n}\r\n} else if ((cp->host_status == HS_COMPLETE)\r\n&& (cp->scsi_status == S_CONFLICT)) {\r\ncmd->result = ScsiResult(DID_OK, S_CONFLICT);\r\n} else if ((cp->host_status == HS_COMPLETE)\r\n&& (cp->scsi_status == S_BUSY ||\r\ncp->scsi_status == S_QUEUE_FULL)) {\r\ncmd->result = ScsiResult(DID_OK, cp->scsi_status);\r\n} else if ((cp->host_status == HS_SEL_TIMEOUT)\r\n|| (cp->host_status == HS_TIMEOUT)) {\r\ncmd->result = ScsiResult(DID_TIME_OUT, cp->scsi_status);\r\n} else if (cp->host_status == HS_RESET) {\r\ncmd->result = ScsiResult(DID_RESET, cp->scsi_status);\r\n} else if (cp->host_status == HS_ABORTED) {\r\ncmd->result = ScsiResult(DID_ABORT, cp->scsi_status);\r\n} else {\r\nPRINT_ADDR(cmd, "COMMAND FAILED (%x %x) @%p.\n",\r\ncp->host_status, cp->scsi_status, cp);\r\ncmd->result = ScsiResult(DID_ERROR, cp->scsi_status);\r\n}\r\nif (tp->usrflag & UF_TRACE) {\r\nu_char * p;\r\nint i;\r\nPRINT_ADDR(cmd, " CMD:");\r\np = (u_char*) &cmd->cmnd[0];\r\nfor (i=0; i<cmd->cmd_len; i++) printk (" %x", *p++);\r\nif (cp->host_status==HS_COMPLETE) {\r\nswitch (cp->scsi_status) {\r\ncase S_GOOD:\r\nprintk (" GOOD");\r\nbreak;\r\ncase S_CHECK_COND:\r\nprintk (" SENSE:");\r\np = (u_char*) &cmd->sense_buffer;\r\nfor (i=0; i<14; i++)\r\nprintk (" %x", *p++);\r\nbreak;\r\ndefault:\r\nprintk (" STAT: %x\n", cp->scsi_status);\r\nbreak;\r\n}\r\n} else printk (" HOSTERROR: %x", cp->host_status);\r\nprintk ("\n");\r\n}\r\nncr_free_ccb (np, cp);\r\nif (lp && lp->queuedccbs < lp->queuedepth &&\r\n!list_empty(&lp->wait_ccbq))\r\nncr_start_next_ccb(np, lp, 2);\r\nif (np->waiting_list)\r\nrequeue_waiting_list(np);\r\nncr_queue_done_cmd(np, cmd);\r\n}\r\nstatic void ncr_ccb_skipped(struct ncb *np, struct ccb *cp)\r\n{\r\nstruct tcb *tp = &np->target[cp->target];\r\nstruct lcb *lp = tp->lp[cp->lun];\r\nif (lp && cp != np->ccb) {\r\ncp->host_status &= ~HS_SKIPMASK;\r\ncp->start.schedule.l_paddr =\r\ncpu_to_scr(NCB_SCRIPT_PHYS (np, select));\r\nlist_move_tail(&cp->link_ccbq, &lp->skip_ccbq);\r\nif (cp->queued) {\r\n--lp->queuedccbs;\r\n}\r\n}\r\nif (cp->queued) {\r\n--np->queuedccbs;\r\ncp->queued = 0;\r\n}\r\n}\r\nvoid ncr_wakeup_done (struct ncb *np)\r\n{\r\nstruct ccb *cp;\r\n#ifdef SCSI_NCR_CCB_DONE_SUPPORT\r\nint i, j;\r\ni = np->ccb_done_ic;\r\nwhile (1) {\r\nj = i+1;\r\nif (j >= MAX_DONE)\r\nj = 0;\r\ncp = np->ccb_done[j];\r\nif (!CCB_DONE_VALID(cp))\r\nbreak;\r\nnp->ccb_done[j] = (struct ccb *)CCB_DONE_EMPTY;\r\nnp->scripth->done_queue[5*j + 4] =\r\ncpu_to_scr(NCB_SCRIPT_PHYS (np, done_plug));\r\nMEMORY_BARRIER();\r\nnp->scripth->done_queue[5*i + 4] =\r\ncpu_to_scr(NCB_SCRIPT_PHYS (np, done_end));\r\nif (cp->host_status & HS_DONEMASK)\r\nncr_complete (np, cp);\r\nelse if (cp->host_status & HS_SKIPMASK)\r\nncr_ccb_skipped (np, cp);\r\ni = j;\r\n}\r\nnp->ccb_done_ic = i;\r\n#else\r\ncp = np->ccb;\r\nwhile (cp) {\r\nif (cp->host_status & HS_DONEMASK)\r\nncr_complete (np, cp);\r\nelse if (cp->host_status & HS_SKIPMASK)\r\nncr_ccb_skipped (np, cp);\r\ncp = cp->link_ccb;\r\n}\r\n#endif\r\n}\r\nvoid ncr_wakeup (struct ncb *np, u_long code)\r\n{\r\nstruct ccb *cp = np->ccb;\r\nwhile (cp) {\r\nif (cp->host_status != HS_IDLE) {\r\ncp->host_status = code;\r\nncr_complete (np, cp);\r\n}\r\ncp = cp->link_ccb;\r\n}\r\n}\r\nstatic void ncr_chip_reset(struct ncb *np, int delay)\r\n{\r\nOUTB (nc_istat, SRST);\r\nudelay(delay);\r\nOUTB (nc_istat, 0 );\r\nif (np->features & FE_EHP)\r\nOUTB (nc_ctest0, EHP);\r\nif (np->features & FE_MUX)\r\nOUTB (nc_ctest4, MUX);\r\n}\r\nvoid ncr_init (struct ncb *np, int reset, char * msg, u_long code)\r\n{\r\nint i;\r\nif (reset) {\r\nOUTB (nc_istat, SRST);\r\nudelay(100);\r\n}\r\nelse {\r\nOUTB (nc_stest3, TE|CSF);\r\nOUTONB (nc_ctest3, CLF);\r\n}\r\nif (msg) printk (KERN_INFO "%s: restart (%s).\n", ncr_name (np), msg);\r\nnp->queuedepth = MAX_START - 1;\r\nfor (i = 1; i < MAX_START + MAX_START; i += 2)\r\nnp->scripth0->tryloop[i] =\r\ncpu_to_scr(NCB_SCRIPT_PHYS (np, idle));\r\nnp->squeueput = 0;\r\nnp->script0->startpos[0] = cpu_to_scr(NCB_SCRIPTH_PHYS (np, tryloop));\r\n#ifdef SCSI_NCR_CCB_DONE_SUPPORT\r\nfor (i = 0; i < MAX_DONE; i++) {\r\nnp->ccb_done[i] = (struct ccb *)CCB_DONE_EMPTY;\r\nnp->scripth0->done_queue[5*i + 4] =\r\ncpu_to_scr(NCB_SCRIPT_PHYS (np, done_end));\r\n}\r\n#endif\r\nnp->script0->done_pos[0] = cpu_to_scr(NCB_SCRIPTH_PHYS (np,done_queue));\r\nnp->ccb_done_ic = MAX_DONE-1;\r\nnp->scripth0->done_queue[5*(MAX_DONE-1) + 4] =\r\ncpu_to_scr(NCB_SCRIPT_PHYS (np, done_plug));\r\nncr_wakeup (np, code);\r\nncr_chip_reset(np, 2000);\r\nOUTB (nc_scntl0, np->rv_scntl0 | 0xc0);\r\nOUTB (nc_scntl1, 0x00);\r\nncr_selectclock(np, np->rv_scntl3);\r\nOUTB (nc_scid , RRE|np->myaddr);\r\nOUTW (nc_respid, 1ul<<np->myaddr);\r\nOUTB (nc_istat , SIGP );\r\nOUTB (nc_dmode , np->rv_dmode);\r\nOUTB (nc_ctest5, np->rv_ctest5);\r\nOUTB (nc_dcntl , NOCOM|np->rv_dcntl);\r\nOUTB (nc_ctest0, np->rv_ctest0);\r\nOUTB (nc_ctest3, np->rv_ctest3);\r\nOUTB (nc_ctest4, np->rv_ctest4);\r\nOUTB (nc_stest2, EXT|np->rv_stest2);\r\nOUTB (nc_stest3, TE);\r\nOUTB (nc_stime0, 0x0c );\r\nnp->disc = 0;\r\nif (np->features & FE_LED0) {\r\nOUTOFFB (nc_gpcntl, 0x01);\r\n}\r\nOUTW (nc_sien , STO|HTH|MA|SGE|UDC|RST|PAR);\r\nOUTB (nc_dien , MDPE|BF|ABRT|SSI|SIR|IID);\r\nfor (i=0;i<MAX_TARGET;i++) {\r\nstruct tcb *tp = &np->target[i];\r\ntp->sval = 0;\r\ntp->wval = np->rv_scntl3;\r\nif (tp->usrsync != 255) {\r\nif (tp->usrsync <= np->maxsync) {\r\nif (tp->usrsync < np->minsync) {\r\ntp->usrsync = np->minsync;\r\n}\r\n}\r\nelse\r\ntp->usrsync = 255;\r\n}\r\nif (tp->usrwide > np->maxwide)\r\ntp->usrwide = np->maxwide;\r\n}\r\nif (np->paddr2) {\r\nif (bootverbose)\r\nprintk ("%s: Downloading SCSI SCRIPTS.\n",\r\nncr_name(np));\r\nOUTL (nc_scratcha, vtobus(np->script0));\r\nOUTL_DSP (NCB_SCRIPTH_PHYS (np, start_ram));\r\n}\r\nelse\r\nOUTL_DSP (NCB_SCRIPT_PHYS (np, start));\r\n}\r\nstatic void ncr_negotiate (struct ncb* np, struct tcb* tp)\r\n{\r\nu_long minsync = tp->usrsync;\r\nif (np->scsi_mode && np->scsi_mode == SMODE_SE) {\r\nif (minsync < 12) minsync = 12;\r\n}\r\nif (minsync < np->minsync)\r\nminsync = np->minsync;\r\nif (minsync > np->maxsync)\r\nminsync = 255;\r\nif (tp->maxoffs > np->maxoffs)\r\ntp->maxoffs = np->maxoffs;\r\ntp->minsync = minsync;\r\ntp->maxoffs = (minsync<255 ? tp->maxoffs : 0);\r\ntp->period=0;\r\ntp->widedone=0;\r\n}\r\nstatic void ncr_getsync(struct ncb *np, u_char sfac, u_char *fakp, u_char *scntl3p)\r\n{\r\nu_long clk = np->clock_khz;\r\nint div = np->clock_divn;\r\nu_long fak;\r\nu_long per;\r\nu_long kpc;\r\nif (sfac <= 10) per = 250;\r\nelse if (sfac == 11) per = 303;\r\nelse if (sfac == 12) per = 500;\r\nelse per = 40 * sfac;\r\nkpc = per * clk;\r\nwhile (--div > 0)\r\nif (kpc >= (div_10M[div] << 2)) break;\r\nfak = (kpc - 1) / div_10M[div] + 1;\r\n#if 0\r\nper = (fak * div_10M[div]) / clk;\r\nif (div >= 1 && fak < 8) {\r\nu_long fak2, per2;\r\nfak2 = (kpc - 1) / div_10M[div-1] + 1;\r\nper2 = (fak2 * div_10M[div-1]) / clk;\r\nif (per2 < per && fak2 <= 8) {\r\nfak = fak2;\r\nper = per2;\r\n--div;\r\n}\r\n}\r\n#endif\r\nif (fak < 4) fak = 4;\r\n*fakp = fak - 4;\r\n*scntl3p = ((div+1) << 4) + (sfac < 25 ? 0x80 : 0);\r\n}\r\nstatic void ncr_set_sync_wide_status (struct ncb *np, u_char target)\r\n{\r\nstruct ccb *cp;\r\nstruct tcb *tp = &np->target[target];\r\nOUTB (nc_sxfer, tp->sval);\r\nnp->sync_st = tp->sval;\r\nOUTB (nc_scntl3, tp->wval);\r\nnp->wide_st = tp->wval;\r\nfor (cp = np->ccb; cp; cp = cp->link_ccb) {\r\nif (!cp->cmd) continue;\r\nif (scmd_id(cp->cmd) != target) continue;\r\n#if 0\r\ncp->sync_status = tp->sval;\r\ncp->wide_status = tp->wval;\r\n#endif\r\ncp->phys.select.sel_scntl3 = tp->wval;\r\ncp->phys.select.sel_sxfer = tp->sval;\r\n}\r\n}\r\nstatic void ncr_setsync (struct ncb *np, struct ccb *cp, u_char scntl3, u_char sxfer)\r\n{\r\nstruct scsi_cmnd *cmd = cp->cmd;\r\nstruct tcb *tp;\r\nu_char target = INB (nc_sdid) & 0x0f;\r\nu_char idiv;\r\nBUG_ON(target != (scmd_id(cmd) & 0xf));\r\ntp = &np->target[target];\r\nif (!scntl3 || !(sxfer & 0x1f))\r\nscntl3 = np->rv_scntl3;\r\nscntl3 = (scntl3 & 0xf0) | (tp->wval & EWS) | (np->rv_scntl3 & 0x07);\r\nidiv = ((scntl3 >> 4) & 0x7);\r\nif ((sxfer & 0x1f) && idiv)\r\ntp->period = (((sxfer>>5)+4)*div_10M[idiv-1])/np->clock_khz;\r\nelse\r\ntp->period = 0xffff;\r\nif (tp->sval == sxfer && tp->wval == scntl3)\r\nreturn;\r\ntp->sval = sxfer;\r\ntp->wval = scntl3;\r\nif (sxfer & 0x01f) {\r\nif (tp->period <= 2000)\r\nOUTOFFB(nc_stest2, EXT);\r\n}\r\nspi_display_xfer_agreement(tp->starget);\r\nncr_set_sync_wide_status(np, target);\r\n}\r\nstatic void ncr_setwide (struct ncb *np, struct ccb *cp, u_char wide, u_char ack)\r\n{\r\nstruct scsi_cmnd *cmd = cp->cmd;\r\nu16 target = INB (nc_sdid) & 0x0f;\r\nstruct tcb *tp;\r\nu_char scntl3;\r\nu_char sxfer;\r\nBUG_ON(target != (scmd_id(cmd) & 0xf));\r\ntp = &np->target[target];\r\ntp->widedone = wide+1;\r\nscntl3 = (tp->wval & (~EWS)) | (wide ? EWS : 0);\r\nsxfer = ack ? 0 : tp->sval;\r\nif (tp->sval == sxfer && tp->wval == scntl3) return;\r\ntp->sval = sxfer;\r\ntp->wval = scntl3;\r\nif (bootverbose >= 2) {\r\ndev_info(&cmd->device->sdev_target->dev, "WIDE SCSI %sabled.\n",\r\n(scntl3 & EWS) ? "en" : "dis");\r\n}\r\nncr_set_sync_wide_status(np, target);\r\n}\r\nstatic void ncr_setup_tags (struct ncb *np, struct scsi_device *sdev)\r\n{\r\nunsigned char tn = sdev->id, ln = sdev->lun;\r\nstruct tcb *tp = &np->target[tn];\r\nstruct lcb *lp = tp->lp[ln];\r\nu_char reqtags, maxdepth;\r\nif ((!tp) || (!lp) || !sdev)\r\nreturn;\r\nif (!lp->scdev_depth)\r\nreturn;\r\nmaxdepth = lp->scdev_depth;\r\nif (maxdepth > lp->maxnxs) maxdepth = lp->maxnxs;\r\nif (lp->maxtags > maxdepth) lp->maxtags = maxdepth;\r\nif (lp->numtags > maxdepth) lp->numtags = maxdepth;\r\nif (sdev->tagged_supported && lp->numtags > 1) {\r\nreqtags = lp->numtags;\r\n} else {\r\nreqtags = 1;\r\n}\r\nlp->numtags = reqtags;\r\nif (lp->numtags > lp->maxtags)\r\nlp->maxtags = lp->numtags;\r\nif (reqtags > 1 && lp->usetags) {\r\nif (lp->queuedepth == reqtags)\r\nreturn;\r\nlp->queuedepth = reqtags;\r\n}\r\nelse if (reqtags <= 1 && !lp->usetags) {\r\nlp->queuedepth = reqtags;\r\nreturn;\r\n}\r\nelse {\r\nif (lp->busyccbs)\r\nreturn;\r\nlp->queuedepth = reqtags;\r\nlp->usetags = reqtags > 1 ? 1 : 0;\r\n}\r\nlp->jump_tag.l_paddr = lp->usetags?\r\ncpu_to_scr(NCB_SCRIPT_PHYS(np, resel_tag)) :\r\ncpu_to_scr(NCB_SCRIPT_PHYS(np, resel_notag));\r\nif (bootverbose) {\r\nif (lp->usetags) {\r\ndev_info(&sdev->sdev_gendev,\r\n"tagged command queue depth set to %d\n",\r\nreqtags);\r\n} else {\r\ndev_info(&sdev->sdev_gendev,\r\n"tagged command queueing disabled\n");\r\n}\r\n}\r\n}\r\nstatic void ncr_timeout (struct ncb *np)\r\n{\r\nu_long thistime = jiffies;\r\nif (np->release_stage) {\r\nif (np->release_stage == 1) np->release_stage = 2;\r\nreturn;\r\n}\r\nnp->timer.expires = jiffies + SCSI_NCR_TIMER_INTERVAL;\r\nadd_timer(&np->timer);\r\nif (np->settle_time) {\r\nif (np->settle_time <= thistime) {\r\nif (bootverbose > 1)\r\nprintk("%s: command processing resumed\n", ncr_name(np));\r\nnp->settle_time = 0;\r\nnp->disc = 1;\r\nrequeue_waiting_list(np);\r\n}\r\nreturn;\r\n}\r\nif (np->lasttime + 4*HZ < thistime) {\r\nnp->lasttime = thistime;\r\n}\r\n#ifdef SCSI_NCR_BROKEN_INTR\r\nif (INB(nc_istat) & (INTF|SIP|DIP)) {\r\nif (DEBUG_FLAGS & DEBUG_TINY) printk ("{");\r\nncr_exception (np);\r\nif (DEBUG_FLAGS & DEBUG_TINY) printk ("}");\r\n}\r\n#endif\r\n}\r\nstatic void ncr_log_hard_error(struct ncb *np, u16 sist, u_char dstat)\r\n{\r\nu32 dsp;\r\nint script_ofs;\r\nint script_size;\r\nchar *script_name;\r\nu_char *script_base;\r\nint i;\r\ndsp = INL (nc_dsp);\r\nif (dsp > np->p_script && dsp <= np->p_script + sizeof(struct script)) {\r\nscript_ofs = dsp - np->p_script;\r\nscript_size = sizeof(struct script);\r\nscript_base = (u_char *) np->script0;\r\nscript_name = "script";\r\n}\r\nelse if (np->p_scripth < dsp &&\r\ndsp <= np->p_scripth + sizeof(struct scripth)) {\r\nscript_ofs = dsp - np->p_scripth;\r\nscript_size = sizeof(struct scripth);\r\nscript_base = (u_char *) np->scripth0;\r\nscript_name = "scripth";\r\n} else {\r\nscript_ofs = dsp;\r\nscript_size = 0;\r\nscript_base = NULL;\r\nscript_name = "mem";\r\n}\r\nprintk ("%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\n",\r\nncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\r\n(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\r\n(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\r\n(unsigned)INL (nc_dbc));\r\nif (((script_ofs & 3) == 0) &&\r\n(unsigned)script_ofs < script_size) {\r\nprintk ("%s: script cmd = %08x\n", ncr_name(np),\r\nscr_to_cpu((int) *(ncrcmd *)(script_base + script_ofs)));\r\n}\r\nprintk ("%s: regdump:", ncr_name(np));\r\nfor (i=0; i<16;i++)\r\nprintk (" %02x", (unsigned)INB_OFF(i));\r\nprintk (".\n");\r\n}\r\nvoid ncr_exception (struct ncb *np)\r\n{\r\nu_char istat, dstat;\r\nu16 sist;\r\nint i;\r\nistat = INB (nc_istat);\r\nif (istat & INTF) {\r\nOUTB (nc_istat, (istat & SIGP) | INTF);\r\nistat = INB (nc_istat);\r\nif (DEBUG_FLAGS & DEBUG_TINY) printk ("F ");\r\nncr_wakeup_done (np);\r\n}\r\nif (!(istat & (SIP|DIP)))\r\nreturn;\r\nif (istat & CABRT)\r\nOUTB (nc_istat, CABRT);\r\nsist = (istat & SIP) ? INW (nc_sist) : 0;\r\ndstat = (istat & DIP) ? INB (nc_dstat) : 0;\r\nif (DEBUG_FLAGS & DEBUG_TINY)\r\nprintk ("<%d|%x:%x|%x:%x>",\r\n(int)INB(nc_scr0),\r\ndstat,sist,\r\n(unsigned)INL(nc_dsp),\r\n(unsigned)INL(nc_dbc));\r\nif (!(sist & (STO|GEN|HTH|SGE|UDC|RST)) &&\r\n!(dstat & (MDPE|BF|ABRT|IID))) {\r\nif ((sist & SBMC) && ncr_int_sbmc (np))\r\nreturn;\r\nif ((sist & PAR) && ncr_int_par (np))\r\nreturn;\r\nif (sist & MA) {\r\nncr_int_ma (np);\r\nreturn;\r\n}\r\nif (dstat & SIR) {\r\nncr_int_sir (np);\r\nreturn;\r\n}\r\nif (!(sist & (SBMC|PAR)) && !(dstat & SSI)) {\r\nprintk( "%s: unknown interrupt(s) ignored, "\r\n"ISTAT=%x DSTAT=%x SIST=%x\n",\r\nncr_name(np), istat, dstat, sist);\r\nreturn;\r\n}\r\nOUTONB_STD ();\r\nreturn;\r\n}\r\nif (sist & RST) {\r\nncr_init (np, 1, bootverbose ? "scsi reset" : NULL, HS_RESET);\r\nreturn;\r\n}\r\nif ((sist & STO) &&\r\n!(dstat & (MDPE|BF|ABRT))) {\r\nOUTONB (nc_ctest3, CLF);\r\nncr_int_sto (np);\r\nreturn;\r\n}\r\nif (time_after(jiffies, np->regtime)) {\r\nnp->regtime = jiffies + 10*HZ;\r\nfor (i = 0; i<sizeof(np->regdump); i++)\r\n((char*)&np->regdump)[i] = INB_OFF(i);\r\nnp->regdump.nc_dstat = dstat;\r\nnp->regdump.nc_sist = sist;\r\n}\r\nncr_log_hard_error(np, sist, dstat);\r\nprintk ("%s: have to clear fifos.\n", ncr_name (np));\r\nOUTB (nc_stest3, TE|CSF);\r\nOUTONB (nc_ctest3, CLF);\r\nif ((sist & (SGE)) ||\r\n(dstat & (MDPE|BF|ABRT|IID))) {\r\nncr_start_reset(np);\r\nreturn;\r\n}\r\nif (sist & HTH) {\r\nprintk ("%s: handshake timeout\n", ncr_name(np));\r\nncr_start_reset(np);\r\nreturn;\r\n}\r\nif (sist & UDC) {\r\nprintk ("%s: unexpected disconnect\n", ncr_name(np));\r\nOUTB (HS_PRT, HS_UNEXPECTED);\r\nOUTL_DSP (NCB_SCRIPT_PHYS (np, cleanup));\r\nreturn;\r\n}\r\nprintk ("%s: unknown interrupt\n", ncr_name(np));\r\n}\r\nvoid ncr_int_sto (struct ncb *np)\r\n{\r\nu_long dsa;\r\nstruct ccb *cp;\r\nif (DEBUG_FLAGS & DEBUG_TINY) printk ("T");\r\ndsa = INL (nc_dsa);\r\ncp = np->ccb;\r\nwhile (cp && (CCB_PHYS (cp, phys) != dsa))\r\ncp = cp->link_ccb;\r\nif (cp) {\r\ncp-> host_status = HS_SEL_TIMEOUT;\r\nncr_complete (np, cp);\r\n}\r\nOUTL_DSP (NCB_SCRIPTH_PHYS (np, sto_restart));\r\nreturn;\r\n}\r\nstatic int ncr_int_sbmc (struct ncb *np)\r\n{\r\nu_char scsi_mode = INB (nc_stest4) & SMODE;\r\nif (scsi_mode != np->scsi_mode) {\r\nprintk("%s: SCSI bus mode change from %x to %x.\n",\r\nncr_name(np), np->scsi_mode, scsi_mode);\r\nnp->scsi_mode = scsi_mode;\r\nnp->settle_time = jiffies + HZ;\r\nncr_init (np, 0, bootverbose ? "scsi mode change" : NULL, HS_RESET);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ncr_int_par (struct ncb *np)\r\n{\r\nu_char hsts = INB (HS_PRT);\r\nu32 dbc = INL (nc_dbc);\r\nu_char sstat1 = INB (nc_sstat1);\r\nint phase = -1;\r\nint msg = -1;\r\nu32 jmp;\r\nprintk("%s: SCSI parity error detected: SCR1=%d DBC=%x SSTAT1=%x\n",\r\nncr_name(np), hsts, dbc, sstat1);\r\nif (!(INB (nc_scntl1) & ISCON))\r\nreturn 0;\r\nif (hsts & HS_INVALMASK)\r\ngoto reset_all;\r\nif (!(dbc & 0xc0000000))\r\nphase = (dbc >> 24) & 7;\r\nif (phase == 7)\r\nmsg = MSG_PARITY_ERROR;\r\nelse\r\nmsg = INITIATOR_ERROR;\r\nif (phase == 1)\r\njmp = NCB_SCRIPTH_PHYS (np, par_err_data_in);\r\nelse\r\njmp = NCB_SCRIPTH_PHYS (np, par_err_other);\r\nOUTONB (nc_ctest3, CLF );\r\nOUTB (nc_stest3, TE|CSF);\r\nnp->msgout[0] = msg;\r\nOUTL_DSP (jmp);\r\nreturn 1;\r\nreset_all:\r\nncr_start_reset(np);\r\nreturn 1;\r\n}\r\nstatic void ncr_int_ma (struct ncb *np)\r\n{\r\nu32 dbc;\r\nu32 rest;\r\nu32 dsp;\r\nu32 dsa;\r\nu32 nxtdsp;\r\nu32 newtmp;\r\nu32 *vdsp;\r\nu32 oadr, olen;\r\nu32 *tblp;\r\nncrcmd *newcmd;\r\nu_char cmd, sbcl;\r\nstruct ccb *cp;\r\ndsp = INL (nc_dsp);\r\ndbc = INL (nc_dbc);\r\nsbcl = INB (nc_sbcl);\r\ncmd = dbc >> 24;\r\nrest = dbc & 0xffffff;\r\nif ((cmd & 1) == 0) {\r\nu_char ctest5, ss0, ss2;\r\nu16 delta;\r\nctest5 = (np->rv_ctest5 & DFS) ? INB (nc_ctest5) : 0;\r\nif (ctest5 & DFS)\r\ndelta=(((ctest5 << 8) | (INB (nc_dfifo) & 0xff)) - rest) & 0x3ff;\r\nelse\r\ndelta=(INB (nc_dfifo) - rest) & 0x7f;\r\nrest += delta;\r\nss0 = INB (nc_sstat0);\r\nif (ss0 & OLF) rest++;\r\nif (ss0 & ORF) rest++;\r\nif (INB(nc_scntl3) & EWS) {\r\nss2 = INB (nc_sstat2);\r\nif (ss2 & OLF1) rest++;\r\nif (ss2 & ORF1) rest++;\r\n}\r\nif (DEBUG_FLAGS & (DEBUG_TINY|DEBUG_PHASE))\r\nprintk ("P%x%x RL=%d D=%d SS0=%x ", cmd&7, sbcl&7,\r\n(unsigned) rest, (unsigned) delta, ss0);\r\n} else {\r\nif (DEBUG_FLAGS & (DEBUG_TINY|DEBUG_PHASE))\r\nprintk ("P%x%x RL=%d ", cmd&7, sbcl&7, rest);\r\n}\r\nOUTONB (nc_ctest3, CLF );\r\nOUTB (nc_stest3, TE|CSF);\r\ndsa = INL (nc_dsa);\r\nif (!(cmd & 6)) {\r\ncp = np->header.cp;\r\nif (CCB_PHYS(cp, phys) != dsa)\r\ncp = NULL;\r\n} else {\r\ncp = np->ccb;\r\nwhile (cp && (CCB_PHYS (cp, phys) != dsa))\r\ncp = cp->link_ccb;\r\n}\r\nvdsp = NULL;\r\nnxtdsp = 0;\r\nif (dsp > np->p_script &&\r\ndsp <= np->p_script + sizeof(struct script)) {\r\nvdsp = (u32 *)((char*)np->script0 + (dsp-np->p_script-8));\r\nnxtdsp = dsp;\r\n}\r\nelse if (dsp > np->p_scripth &&\r\ndsp <= np->p_scripth + sizeof(struct scripth)) {\r\nvdsp = (u32 *)((char*)np->scripth0 + (dsp-np->p_scripth-8));\r\nnxtdsp = dsp;\r\n}\r\nelse if (cp) {\r\nif (dsp == CCB_PHYS (cp, patch[2])) {\r\nvdsp = &cp->patch[0];\r\nnxtdsp = scr_to_cpu(vdsp[3]);\r\n}\r\nelse if (dsp == CCB_PHYS (cp, patch[6])) {\r\nvdsp = &cp->patch[4];\r\nnxtdsp = scr_to_cpu(vdsp[3]);\r\n}\r\n}\r\nif (DEBUG_FLAGS & DEBUG_PHASE) {\r\nprintk ("\nCP=%p CP2=%p DSP=%x NXT=%x VDSP=%p CMD=%x ",\r\ncp, np->header.cp,\r\n(unsigned)dsp,\r\n(unsigned)nxtdsp, vdsp, cmd);\r\n}\r\nif (!cp) {\r\nprintk ("%s: SCSI phase error fixup: "\r\n"CCB already dequeued (0x%08lx)\n",\r\nncr_name (np), (u_long) np->header.cp);\r\ngoto reset_all;\r\n}\r\noadr = scr_to_cpu(vdsp[1]);\r\nif (cmd & 0x10) {\r\ntblp = (u32 *) ((char*) &cp->phys + oadr);\r\nolen = scr_to_cpu(tblp[0]);\r\noadr = scr_to_cpu(tblp[1]);\r\n} else {\r\ntblp = (u32 *) 0;\r\nolen = scr_to_cpu(vdsp[0]) & 0xffffff;\r\n}\r\nif (DEBUG_FLAGS & DEBUG_PHASE) {\r\nprintk ("OCMD=%x\nTBLP=%p OLEN=%x OADR=%x\n",\r\n(unsigned) (scr_to_cpu(vdsp[0]) >> 24),\r\ntblp,\r\n(unsigned) olen,\r\n(unsigned) oadr);\r\n}\r\nif (cmd != (scr_to_cpu(vdsp[0]) >> 24)) {\r\nPRINT_ADDR(cp->cmd, "internal error: cmd=%02x != %02x=(vdsp[0] "\r\n">> 24)\n", cmd, scr_to_cpu(vdsp[0]) >> 24);\r\ngoto reset_all;\r\n}\r\nif (cp != np->header.cp) {\r\nprintk ("%s: SCSI phase error fixup: "\r\n"CCB address mismatch (0x%08lx != 0x%08lx)\n",\r\nncr_name (np), (u_long) cp, (u_long) np->header.cp);\r\n}\r\nif (cmd & 0x06) {\r\nPRINT_ADDR(cp->cmd, "phase change %x-%x %d@%08x resid=%d.\n",\r\ncmd&7, sbcl&7, (unsigned)olen,\r\n(unsigned)oadr, (unsigned)rest);\r\ngoto unexpected_phase;\r\n}\r\nnewcmd = cp->patch;\r\nnewtmp = CCB_PHYS (cp, patch);\r\nif (newtmp == scr_to_cpu(cp->phys.header.savep)) {\r\nnewcmd = &cp->patch[4];\r\nnewtmp = CCB_PHYS (cp, patch[4]);\r\n}\r\nnewcmd[0] = cpu_to_scr(((cmd & 0x0f) << 24) | rest);\r\nnewcmd[1] = cpu_to_scr(oadr + olen - rest);\r\nnewcmd[2] = cpu_to_scr(SCR_JUMP);\r\nnewcmd[3] = cpu_to_scr(nxtdsp);\r\nif (DEBUG_FLAGS & DEBUG_PHASE) {\r\nPRINT_ADDR(cp->cmd, "newcmd[%d] %x %x %x %x.\n",\r\n(int) (newcmd - cp->patch),\r\n(unsigned)scr_to_cpu(newcmd[0]),\r\n(unsigned)scr_to_cpu(newcmd[1]),\r\n(unsigned)scr_to_cpu(newcmd[2]),\r\n(unsigned)scr_to_cpu(newcmd[3]));\r\n}\r\nOUTL (nc_temp, newtmp);\r\nOUTL_DSP (NCB_SCRIPT_PHYS (np, dispatch));\r\nreturn;\r\nunexpected_phase:\r\ndsp -= 8;\r\nnxtdsp = 0;\r\nswitch (cmd & 7) {\r\ncase 2:\r\nnxtdsp = NCB_SCRIPT_PHYS (np, dispatch);\r\nbreak;\r\n#if 0\r\ncase 3:\r\nnxtdsp = NCB_SCRIPT_PHYS (np, dispatch);\r\nbreak;\r\n#endif\r\ncase 6:\r\nnp->scripth->nxtdsp_go_on[0] = cpu_to_scr(dsp + 8);\r\nif (dsp == NCB_SCRIPT_PHYS (np, send_ident)) {\r\ncp->host_status = HS_BUSY;\r\nnxtdsp = NCB_SCRIPTH_PHYS (np, clratn_go_on);\r\n}\r\nelse if (dsp == NCB_SCRIPTH_PHYS (np, send_wdtr) ||\r\ndsp == NCB_SCRIPTH_PHYS (np, send_sdtr)) {\r\nnxtdsp = NCB_SCRIPTH_PHYS (np, nego_bad_phase);\r\n}\r\nbreak;\r\n#if 0\r\ncase 7:\r\nnxtdsp = NCB_SCRIPT_PHYS (np, clrack);\r\nbreak;\r\n#endif\r\n}\r\nif (nxtdsp) {\r\nOUTL_DSP (nxtdsp);\r\nreturn;\r\n}\r\nreset_all:\r\nncr_start_reset(np);\r\n}\r\nstatic void ncr_sir_to_redo(struct ncb *np, int num, struct ccb *cp)\r\n{\r\nstruct scsi_cmnd *cmd = cp->cmd;\r\nstruct tcb *tp = &np->target[cmd->device->id];\r\nstruct lcb *lp = tp->lp[cmd->device->lun];\r\nstruct list_head *qp;\r\nstruct ccb * cp2;\r\nint disc_cnt = 0;\r\nint busy_cnt = 0;\r\nu32 startp;\r\nu_char s_status = INB (SS_PRT);\r\nif (lp) {\r\nqp = lp->busy_ccbq.prev;\r\nwhile (qp != &lp->busy_ccbq) {\r\ncp2 = list_entry(qp, struct ccb, link_ccbq);\r\nqp = qp->prev;\r\n++busy_cnt;\r\nif (cp2 == cp)\r\nbreak;\r\ncp2->start.schedule.l_paddr =\r\ncpu_to_scr(NCB_SCRIPTH_PHYS (np, skip));\r\n}\r\nlp->held_ccb = cp;\r\ndisc_cnt = lp->queuedccbs - busy_cnt;\r\n}\r\nswitch(s_status) {\r\ndefault:\r\ncase S_QUEUE_FULL:\r\nif (!lp)\r\ngoto out;\r\nif (bootverbose >= 1) {\r\nPRINT_ADDR(cmd, "QUEUE FULL! %d busy, %d disconnected "\r\n"CCBs\n", busy_cnt, disc_cnt);\r\n}\r\nif (disc_cnt < lp->numtags) {\r\nlp->numtags = disc_cnt > 2 ? disc_cnt : 2;\r\nlp->num_good = 0;\r\nncr_setup_tags (np, cmd->device);\r\n}\r\ncp->phys.header.savep = cp->startp;\r\ncp->host_status = HS_BUSY;\r\ncp->scsi_status = S_ILLEGAL;\r\nncr_put_start_queue(np, cp);\r\nif (disc_cnt)\r\nINB (nc_ctest2);\r\nOUTL_DSP (NCB_SCRIPT_PHYS (np, reselect));\r\nreturn;\r\ncase S_TERMINATED:\r\ncase S_CHECK_COND:\r\nif (cp->auto_sense)\r\ngoto out;\r\ncp->scsi_smsg2[0] = IDENTIFY(0, cmd->device->lun);\r\ncp->phys.smsg.addr = cpu_to_scr(CCB_PHYS (cp, scsi_smsg2));\r\ncp->phys.smsg.size = cpu_to_scr(1);\r\ncp->phys.cmd.addr = cpu_to_scr(CCB_PHYS (cp, sensecmd));\r\ncp->phys.cmd.size = cpu_to_scr(6);\r\ncp->sensecmd[0] = 0x03;\r\ncp->sensecmd[1] = (cmd->device->lun & 0x7) << 5;\r\ncp->sensecmd[4] = sizeof(cp->sense_buf);\r\nmemset(cp->sense_buf, 0, sizeof(cp->sense_buf));\r\ncp->phys.sense.addr = cpu_to_scr(CCB_PHYS(cp,sense_buf[0]));\r\ncp->phys.sense.size = cpu_to_scr(sizeof(cp->sense_buf));\r\nstartp = cpu_to_scr(NCB_SCRIPTH_PHYS (np, sdata_in));\r\ncp->phys.header.savep = startp;\r\ncp->phys.header.goalp = startp + 24;\r\ncp->phys.header.lastp = startp;\r\ncp->phys.header.wgoalp = startp + 24;\r\ncp->phys.header.wlastp = startp;\r\ncp->host_status = HS_BUSY;\r\ncp->scsi_status = S_ILLEGAL;\r\ncp->auto_sense = s_status;\r\ncp->start.schedule.l_paddr =\r\ncpu_to_scr(NCB_SCRIPT_PHYS (np, select));\r\nif (cmd->device->select_no_atn)\r\ncp->start.schedule.l_paddr =\r\ncpu_to_scr(NCB_SCRIPTH_PHYS (np, select_no_atn));\r\nncr_put_start_queue(np, cp);\r\nOUTL_DSP (NCB_SCRIPT_PHYS (np, start));\r\nreturn;\r\n}\r\nout:\r\nOUTONB_STD ();\r\nreturn;\r\n}\r\nvoid ncr_int_sir (struct ncb *np)\r\n{\r\nu_char scntl3;\r\nu_char chg, ofs, per, fak, wide;\r\nu_char num = INB (nc_dsps);\r\nstruct ccb *cp=NULL;\r\nu_long dsa = INL (nc_dsa);\r\nu_char target = INB (nc_sdid) & 0x0f;\r\nstruct tcb *tp = &np->target[target];\r\nstruct scsi_target *starget = tp->starget;\r\nif (DEBUG_FLAGS & DEBUG_TINY) printk ("I#%d", num);\r\nswitch (num) {\r\ncase SIR_INTFLY:\r\nncr_wakeup_done(np);\r\n#ifdef SCSI_NCR_CCB_DONE_SUPPORT\r\nOUTL(nc_dsp, NCB_SCRIPT_PHYS (np, done_end) + 8);\r\n#else\r\nOUTL(nc_dsp, NCB_SCRIPT_PHYS (np, start));\r\n#endif\r\nreturn;\r\ncase SIR_RESEL_NO_MSG_IN:\r\ncase SIR_RESEL_NO_IDENTIFY:\r\nif (tp->lp[0]) {\r\nOUTL_DSP (scr_to_cpu(tp->lp[0]->jump_ccb[0]));\r\nreturn;\r\n}\r\ncase SIR_RESEL_BAD_TARGET:\r\ncase SIR_RESEL_BAD_LUN:\r\ncase SIR_RESEL_BAD_I_T_L_Q:\r\ncase SIR_RESEL_BAD_I_T_L:\r\nprintk ("%s:%d: SIR %d, "\r\n"incorrect nexus identification on reselection\n",\r\nncr_name (np), target, num);\r\ngoto out;\r\ncase SIR_DONE_OVERFLOW:\r\nprintk ("%s:%d: SIR %d, "\r\n"CCB done queue overflow\n",\r\nncr_name (np), target, num);\r\ngoto out;\r\ncase SIR_BAD_STATUS:\r\ncp = np->header.cp;\r\nif (!cp || CCB_PHYS (cp, phys) != dsa)\r\ngoto out;\r\nncr_sir_to_redo(np, num, cp);\r\nreturn;\r\ndefault:\r\ncp = np->ccb;\r\nwhile (cp && (CCB_PHYS (cp, phys) != dsa))\r\ncp = cp->link_ccb;\r\nBUG_ON(!cp);\r\nBUG_ON(cp != np->header.cp);\r\nif (!cp || cp != np->header.cp)\r\ngoto out;\r\n}\r\nswitch (num) {\r\ncase SIR_NEGO_FAILED:\r\nOUTB (HS_PRT, HS_BUSY);\r\ncase SIR_NEGO_PROTO:\r\nif (DEBUG_FLAGS & DEBUG_NEGO) {\r\nPRINT_ADDR(cp->cmd, "negotiation failed sir=%x "\r\n"status=%x.\n", num, cp->nego_status);\r\n}\r\nswitch (cp->nego_status) {\r\ncase NS_SYNC:\r\nspi_period(starget) = 0;\r\nspi_offset(starget) = 0;\r\nncr_setsync (np, cp, 0, 0xe0);\r\nbreak;\r\ncase NS_WIDE:\r\nspi_width(starget) = 0;\r\nncr_setwide (np, cp, 0, 0);\r\nbreak;\r\n}\r\nnp->msgin [0] = NOP;\r\nnp->msgout[0] = NOP;\r\ncp->nego_status = 0;\r\nbreak;\r\ncase SIR_NEGO_SYNC:\r\nif (DEBUG_FLAGS & DEBUG_NEGO) {\r\nncr_print_msg(cp, "sync msgin", np->msgin);\r\n}\r\nchg = 0;\r\nper = np->msgin[3];\r\nofs = np->msgin[4];\r\nif (ofs==0) per=255;\r\nif (ofs && starget)\r\nspi_support_sync(starget) = 1;\r\nif (per < np->minsync)\r\n{chg = 1; per = np->minsync;}\r\nif (per < tp->minsync)\r\n{chg = 1; per = tp->minsync;}\r\nif (ofs > tp->maxoffs)\r\n{chg = 1; ofs = tp->maxoffs;}\r\nfak = 7;\r\nscntl3 = 0;\r\nif (ofs != 0) {\r\nncr_getsync(np, per, &fak, &scntl3);\r\nif (fak > 7) {\r\nchg = 1;\r\nofs = 0;\r\n}\r\n}\r\nif (ofs == 0) {\r\nfak = 7;\r\nper = 0;\r\nscntl3 = 0;\r\ntp->minsync = 0;\r\n}\r\nif (DEBUG_FLAGS & DEBUG_NEGO) {\r\nPRINT_ADDR(cp->cmd, "sync: per=%d scntl3=0x%x ofs=%d "\r\n"fak=%d chg=%d.\n", per, scntl3, ofs, fak, chg);\r\n}\r\nif (INB (HS_PRT) == HS_NEGOTIATE) {\r\nOUTB (HS_PRT, HS_BUSY);\r\nswitch (cp->nego_status) {\r\ncase NS_SYNC:\r\nif (chg) {\r\nspi_period(starget) = 0;\r\nspi_offset(starget) = 0;\r\nncr_setsync(np, cp, 0, 0xe0);\r\nOUTL_DSP(NCB_SCRIPT_PHYS (np, msg_bad));\r\n} else {\r\nspi_period(starget) = per;\r\nspi_offset(starget) = ofs;\r\nncr_setsync(np, cp, scntl3, (fak<<5)|ofs);\r\nOUTL_DSP(NCB_SCRIPT_PHYS (np, clrack));\r\n}\r\nreturn;\r\ncase NS_WIDE:\r\nspi_width(starget) = 0;\r\nncr_setwide(np, cp, 0, 0);\r\nbreak;\r\n}\r\n}\r\nspi_period(starget) = per;\r\nspi_offset(starget) = ofs;\r\nncr_setsync(np, cp, scntl3, (fak<<5)|ofs);\r\nspi_populate_sync_msg(np->msgout, per, ofs);\r\ncp->nego_status = NS_SYNC;\r\nif (DEBUG_FLAGS & DEBUG_NEGO) {\r\nncr_print_msg(cp, "sync msgout", np->msgout);\r\n}\r\nif (!ofs) {\r\nOUTL_DSP (NCB_SCRIPT_PHYS (np, msg_bad));\r\nreturn;\r\n}\r\nnp->msgin [0] = NOP;\r\nbreak;\r\ncase SIR_NEGO_WIDE:\r\nif (DEBUG_FLAGS & DEBUG_NEGO) {\r\nncr_print_msg(cp, "wide msgin", np->msgin);\r\n}\r\nchg = 0;\r\nwide = np->msgin[3];\r\nif (wide && starget)\r\nspi_support_wide(starget) = 1;\r\nif (wide > tp->usrwide)\r\n{chg = 1; wide = tp->usrwide;}\r\nif (DEBUG_FLAGS & DEBUG_NEGO) {\r\nPRINT_ADDR(cp->cmd, "wide: wide=%d chg=%d.\n", wide,\r\nchg);\r\n}\r\nif (INB (HS_PRT) == HS_NEGOTIATE) {\r\nOUTB (HS_PRT, HS_BUSY);\r\nswitch (cp->nego_status) {\r\ncase NS_WIDE:\r\nif (chg) {\r\nspi_width(starget) = 0;\r\nncr_setwide(np, cp, 0, 1);\r\nOUTL_DSP (NCB_SCRIPT_PHYS (np, msg_bad));\r\n} else {\r\nspi_width(starget) = wide;\r\nncr_setwide(np, cp, wide, 1);\r\nOUTL_DSP (NCB_SCRIPT_PHYS (np, clrack));\r\n}\r\nreturn;\r\ncase NS_SYNC:\r\nspi_period(starget) = 0;\r\nspi_offset(starget) = 0;\r\nncr_setsync(np, cp, 0, 0xe0);\r\nbreak;\r\n}\r\n}\r\nspi_width(starget) = wide;\r\nncr_setwide(np, cp, wide, 1);\r\nspi_populate_width_msg(np->msgout, wide);\r\nnp->msgin [0] = NOP;\r\ncp->nego_status = NS_WIDE;\r\nif (DEBUG_FLAGS & DEBUG_NEGO) {\r\nncr_print_msg(cp, "wide msgout", np->msgin);\r\n}\r\nbreak;\r\ncase SIR_REJECT_RECEIVED:\r\nPRINT_ADDR(cp->cmd, "MESSAGE_REJECT received (%x:%x).\n",\r\n(unsigned)scr_to_cpu(np->lastmsg), np->msgout[0]);\r\nbreak;\r\ncase SIR_REJECT_SENT:\r\nncr_print_msg(cp, "MESSAGE_REJECT sent for", np->msgin);\r\nbreak;\r\ncase SIR_IGN_RESIDUE:\r\nPRINT_ADDR(cp->cmd, "IGNORE_WIDE_RESIDUE received, but not yet "\r\n"implemented.\n");\r\nbreak;\r\n#if 0\r\ncase SIR_MISSING_SAVE:\r\nPRINT_ADDR(cp->cmd, "DISCONNECT received, but datapointer "\r\n"not saved: data=%x save=%x goal=%x.\n",\r\n(unsigned) INL (nc_temp),\r\n(unsigned) scr_to_cpu(np->header.savep),\r\n(unsigned) scr_to_cpu(np->header.goalp));\r\nbreak;\r\n#endif\r\n}\r\nout:\r\nOUTONB_STD ();\r\n}\r\nstatic struct ccb *ncr_get_ccb(struct ncb *np, struct scsi_cmnd *cmd)\r\n{\r\nu_char tn = cmd->device->id;\r\nu_char ln = cmd->device->lun;\r\nstruct tcb *tp = &np->target[tn];\r\nstruct lcb *lp = tp->lp[ln];\r\nu_char tag = NO_TAG;\r\nstruct ccb *cp = NULL;\r\nif (lp) {\r\nstruct list_head *qp;\r\nif (lp->usetags && lp->busyccbs >= lp->maxnxs)\r\nreturn NULL;\r\nif (list_empty(&lp->free_ccbq))\r\nncr_alloc_ccb(np, tn, ln);\r\nqp = ncr_list_pop(&lp->free_ccbq);\r\nif (qp) {\r\ncp = list_entry(qp, struct ccb, link_ccbq);\r\nif (cp->magic) {\r\nPRINT_ADDR(cmd, "ccb free list corrupted "\r\n"(@%p)\n", cp);\r\ncp = NULL;\r\n} else {\r\nlist_add_tail(qp, &lp->wait_ccbq);\r\n++lp->busyccbs;\r\n}\r\n}\r\nif (cp) {\r\nif (lp->usetags)\r\ntag = lp->cb_tags[lp->ia_tag];\r\n}\r\nelse if (lp->actccbs > 0)\r\nreturn NULL;\r\n}\r\nif (!cp)\r\ncp = np->ccb;\r\n#if 0\r\nwhile (cp->magic) {\r\nif (flags & SCSI_NOSLEEP) break;\r\nif (tsleep ((caddr_t)cp, PRIBIO|PCATCH, "ncr", 0))\r\nbreak;\r\n}\r\n#endif\r\nif (cp->magic)\r\nreturn NULL;\r\ncp->magic = 1;\r\nif (lp) {\r\nif (tag != NO_TAG) {\r\n++lp->ia_tag;\r\nif (lp->ia_tag == MAX_TAGS)\r\nlp->ia_tag = 0;\r\nlp->tags_umap |= (((tagmap_t) 1) << tag);\r\n}\r\n}\r\ncp->tag = tag;\r\ncp->target = tn;\r\ncp->lun = ln;\r\nif (DEBUG_FLAGS & DEBUG_TAGS) {\r\nPRINT_ADDR(cmd, "ccb @%p using tag %d.\n", cp, tag);\r\n}\r\nreturn cp;\r\n}\r\nstatic void ncr_free_ccb (struct ncb *np, struct ccb *cp)\r\n{\r\nstruct tcb *tp = &np->target[cp->target];\r\nstruct lcb *lp = tp->lp[cp->lun];\r\nif (DEBUG_FLAGS & DEBUG_TAGS) {\r\nPRINT_ADDR(cp->cmd, "ccb @%p freeing tag %d.\n", cp, cp->tag);\r\n}\r\nif (lp) {\r\nif (cp->tag != NO_TAG) {\r\nlp->cb_tags[lp->if_tag++] = cp->tag;\r\nif (lp->if_tag == MAX_TAGS)\r\nlp->if_tag = 0;\r\nlp->tags_umap &= ~(((tagmap_t) 1) << cp->tag);\r\nlp->tags_smap &= lp->tags_umap;\r\nlp->jump_ccb[cp->tag] =\r\ncpu_to_scr(NCB_SCRIPTH_PHYS(np, bad_i_t_l_q));\r\n} else {\r\nlp->jump_ccb[0] =\r\ncpu_to_scr(NCB_SCRIPTH_PHYS(np, bad_i_t_l));\r\n}\r\n}\r\nif (lp) {\r\nif (cp != np->ccb)\r\nlist_move(&cp->link_ccbq, &lp->free_ccbq);\r\n--lp->busyccbs;\r\nif (cp->queued) {\r\n--lp->queuedccbs;\r\n}\r\n}\r\ncp -> host_status = HS_IDLE;\r\ncp -> magic = 0;\r\nif (cp->queued) {\r\n--np->queuedccbs;\r\ncp->queued = 0;\r\n}\r\n#if 0\r\nif (cp == np->ccb)\r\nwakeup ((caddr_t) cp);\r\n#endif\r\n}\r\nstatic void ncr_init_ccb(struct ncb *np, struct ccb *cp)\r\n{\r\nncrcmd copy_4 = np->features & FE_PFEN ? SCR_COPY(4) : SCR_COPY_F(4);\r\ncp->p_ccb = vtobus(cp);\r\ncp->phys.header.cp = cp;\r\nINIT_LIST_HEAD(&cp->link_ccbq);\r\ncp->start.setup_dsa[0] = cpu_to_scr(copy_4);\r\ncp->start.setup_dsa[1] = cpu_to_scr(CCB_PHYS(cp, start.p_phys));\r\ncp->start.setup_dsa[2] = cpu_to_scr(ncr_reg_bus_addr(nc_dsa));\r\ncp->start.schedule.l_cmd = cpu_to_scr(SCR_JUMP);\r\ncp->start.p_phys = cpu_to_scr(CCB_PHYS(cp, phys));\r\nmemcpy(&cp->restart, &cp->start, sizeof(cp->restart));\r\ncp->start.schedule.l_paddr = cpu_to_scr(NCB_SCRIPT_PHYS (np, idle));\r\ncp->restart.schedule.l_paddr = cpu_to_scr(NCB_SCRIPTH_PHYS (np, abort));\r\n}\r\nstatic void ncr_alloc_ccb(struct ncb *np, u_char tn, u_char ln)\r\n{\r\nstruct tcb *tp = &np->target[tn];\r\nstruct lcb *lp = tp->lp[ln];\r\nstruct ccb *cp = NULL;\r\ncp = m_calloc_dma(sizeof(struct ccb), "CCB");\r\nif (!cp)\r\nreturn;\r\nlp->actccbs++;\r\nnp->actccbs++;\r\nmemset(cp, 0, sizeof (*cp));\r\nncr_init_ccb(np, cp);\r\ncp->link_ccb = np->ccb->link_ccb;\r\nnp->ccb->link_ccb = cp;\r\nlist_add(&cp->link_ccbq, &lp->free_ccbq);\r\n}\r\nstatic void ncr_init_tcb (struct ncb *np, u_char tn)\r\n{\r\nstruct tcb *tp = &np->target[tn];\r\nncrcmd copy_1 = np->features & FE_PFEN ? SCR_COPY(1) : SCR_COPY_F(1);\r\nint th = tn & 3;\r\nint i;\r\ntp->jump_tcb.l_cmd =\r\ncpu_to_scr((SCR_JUMP ^ IFFALSE (DATA (0x80 + tn))));\r\ntp->jump_tcb.l_paddr = np->jump_tcb[th].l_paddr;\r\ntp->getscr[0] = cpu_to_scr(copy_1);\r\ntp->getscr[1] = cpu_to_scr(vtobus (&tp->sval));\r\n#ifdef SCSI_NCR_BIG_ENDIAN\r\ntp->getscr[2] = cpu_to_scr(ncr_reg_bus_addr(nc_sxfer) ^ 3);\r\n#else\r\ntp->getscr[2] = cpu_to_scr(ncr_reg_bus_addr(nc_sxfer));\r\n#endif\r\ntp->getscr[3] = cpu_to_scr(copy_1);\r\ntp->getscr[4] = cpu_to_scr(vtobus (&tp->wval));\r\n#ifdef SCSI_NCR_BIG_ENDIAN\r\ntp->getscr[5] = cpu_to_scr(ncr_reg_bus_addr(nc_scntl3) ^ 3);\r\n#else\r\ntp->getscr[5] = cpu_to_scr(ncr_reg_bus_addr(nc_scntl3));\r\n#endif\r\ntp->call_lun.l_cmd = cpu_to_scr(SCR_CALL);\r\ntp->call_lun.l_paddr = cpu_to_scr(NCB_SCRIPT_PHYS (np, resel_lun));\r\nfor (i = 0 ; i < 4 ; i++) {\r\ntp->jump_lcb[i].l_cmd =\r\ncpu_to_scr((SCR_JUMP ^ IFTRUE (MASK (i, 3))));\r\ntp->jump_lcb[i].l_paddr =\r\ncpu_to_scr(NCB_SCRIPTH_PHYS (np, bad_identify));\r\n}\r\nnp->jump_tcb[th].l_paddr = cpu_to_scr(vtobus (&tp->jump_tcb));\r\n#ifdef SCSI_NCR_BIG_ENDIAN\r\nBUG_ON(((offsetof(struct ncr_reg, nc_sxfer) ^\r\noffsetof(struct tcb , sval )) &3) != 3);\r\nBUG_ON(((offsetof(struct ncr_reg, nc_scntl3) ^\r\noffsetof(struct tcb , wval )) &3) != 3);\r\n#else\r\nBUG_ON(((offsetof(struct ncr_reg, nc_sxfer) ^\r\noffsetof(struct tcb , sval )) &3) != 0);\r\nBUG_ON(((offsetof(struct ncr_reg, nc_scntl3) ^\r\noffsetof(struct tcb , wval )) &3) != 0);\r\n#endif\r\n}\r\nstatic struct lcb *ncr_alloc_lcb (struct ncb *np, u_char tn, u_char ln)\r\n{\r\nstruct tcb *tp = &np->target[tn];\r\nstruct lcb *lp = tp->lp[ln];\r\nncrcmd copy_4 = np->features & FE_PFEN ? SCR_COPY(4) : SCR_COPY_F(4);\r\nint lh = ln & 3;\r\nif (lp)\r\nreturn lp;\r\nlp = m_calloc_dma(sizeof(struct lcb), "LCB");\r\nif (!lp)\r\ngoto fail;\r\nmemset(lp, 0, sizeof(*lp));\r\ntp->lp[ln] = lp;\r\nif (!tp->jump_tcb.l_cmd)\r\nncr_init_tcb(np, tn);\r\nINIT_LIST_HEAD(&lp->free_ccbq);\r\nINIT_LIST_HEAD(&lp->busy_ccbq);\r\nINIT_LIST_HEAD(&lp->wait_ccbq);\r\nINIT_LIST_HEAD(&lp->skip_ccbq);\r\nlp->maxnxs = 1;\r\nlp->jump_ccb = &lp->jump_ccb_0;\r\nlp->p_jump_ccb = cpu_to_scr(vtobus(lp->jump_ccb));\r\nlp->jump_lcb.l_cmd =\r\ncpu_to_scr((SCR_JUMP ^ IFFALSE (MASK (0x80+ln, 0xff))));\r\nlp->jump_lcb.l_paddr = tp->jump_lcb[lh].l_paddr;\r\nlp->load_jump_ccb[0] = cpu_to_scr(copy_4);\r\nlp->load_jump_ccb[1] = cpu_to_scr(vtobus (&lp->p_jump_ccb));\r\nlp->load_jump_ccb[2] = cpu_to_scr(ncr_reg_bus_addr(nc_temp));\r\nlp->jump_tag.l_cmd = cpu_to_scr(SCR_JUMP);\r\nlp->jump_tag.l_paddr = cpu_to_scr(NCB_SCRIPT_PHYS (np, resel_notag));\r\ntp->jump_lcb[lh].l_paddr = cpu_to_scr(vtobus (&lp->jump_lcb));\r\nlp->busyccbs = 1;\r\nlp->queuedccbs = 1;\r\nlp->queuedepth = 1;\r\nfail:\r\nreturn lp;\r\n}\r\nstatic struct lcb *ncr_setup_lcb (struct ncb *np, struct scsi_device *sdev)\r\n{\r\nunsigned char tn = sdev->id, ln = sdev->lun;\r\nstruct tcb *tp = &np->target[tn];\r\nstruct lcb *lp = tp->lp[ln];\r\nif (!lp && !(lp = ncr_alloc_lcb(np, tn, ln)))\r\ngoto fail;\r\nif (sdev->tagged_supported && lp->jump_ccb == &lp->jump_ccb_0) {\r\nint i;\r\nlp->jump_ccb = m_calloc_dma(256, "JUMP_CCB");\r\nif (!lp->jump_ccb) {\r\nlp->jump_ccb = &lp->jump_ccb_0;\r\ngoto fail;\r\n}\r\nlp->p_jump_ccb = cpu_to_scr(vtobus(lp->jump_ccb));\r\nfor (i = 0 ; i < 64 ; i++)\r\nlp->jump_ccb[i] =\r\ncpu_to_scr(NCB_SCRIPTH_PHYS (np, bad_i_t_l_q));\r\nfor (i = 0 ; i < MAX_TAGS ; i++)\r\nlp->cb_tags[i] = i;\r\nlp->maxnxs = MAX_TAGS;\r\nlp->tags_stime = jiffies + 3*HZ;\r\nncr_setup_tags (np, sdev);\r\n}\r\nfail:\r\nreturn lp;\r\n}\r\nstatic int ncr_scatter(struct ncb *np, struct ccb *cp, struct scsi_cmnd *cmd)\r\n{\r\nint segment = 0;\r\nint use_sg = scsi_sg_count(cmd);\r\ncp->data_len = 0;\r\nuse_sg = map_scsi_sg_data(np, cmd);\r\nif (use_sg > 0) {\r\nstruct scatterlist *sg;\r\nstruct scr_tblmove *data;\r\nif (use_sg > MAX_SCATTER) {\r\nunmap_scsi_data(np, cmd);\r\nreturn -1;\r\n}\r\ndata = &cp->phys.data[MAX_SCATTER - use_sg];\r\nscsi_for_each_sg(cmd, sg, use_sg, segment) {\r\ndma_addr_t baddr = sg_dma_address(sg);\r\nunsigned int len = sg_dma_len(sg);\r\nncr_build_sge(np, &data[segment], baddr, len);\r\ncp->data_len += len;\r\n}\r\n} else\r\nsegment = -2;\r\nreturn segment;\r\n}\r\nstatic int __init ncr_snooptest (struct ncb* np)\r\n{\r\nu32 ncr_rd, ncr_wr, ncr_bk, host_rd, host_wr, pc;\r\nint i, err=0;\r\nif (np->reg) {\r\nerr |= ncr_regtest (np);\r\nif (err)\r\nreturn (err);\r\n}\r\npc = NCB_SCRIPTH_PHYS (np, snooptest);\r\nhost_wr = 1;\r\nncr_wr = 2;\r\nnp->ncr_cache = cpu_to_scr(host_wr);\r\nOUTL (nc_temp, ncr_wr);\r\nOUTL_DSP (pc);\r\nfor (i=0; i<NCR_SNOOP_TIMEOUT; i++)\r\nif (INB(nc_istat) & (INTF|SIP|DIP))\r\nbreak;\r\npc = INL (nc_dsp);\r\nhost_rd = scr_to_cpu(np->ncr_cache);\r\nncr_rd = INL (nc_scratcha);\r\nncr_bk = INL (nc_temp);\r\nncr_chip_reset(np, 100);\r\nif (i>=NCR_SNOOP_TIMEOUT) {\r\nprintk ("CACHE TEST FAILED: timeout.\n");\r\nreturn (0x20);\r\n}\r\nif (pc != NCB_SCRIPTH_PHYS (np, snoopend)+8) {\r\nprintk ("CACHE TEST FAILED: script execution failed.\n");\r\nprintk ("start=%08lx, pc=%08lx, end=%08lx\n",\r\n(u_long) NCB_SCRIPTH_PHYS (np, snooptest), (u_long) pc,\r\n(u_long) NCB_SCRIPTH_PHYS (np, snoopend) +8);\r\nreturn (0x40);\r\n}\r\nif (host_wr != ncr_rd) {\r\nprintk ("CACHE TEST FAILED: host wrote %d, ncr read %d.\n",\r\n(int) host_wr, (int) ncr_rd);\r\nerr |= 1;\r\n}\r\nif (host_rd != ncr_wr) {\r\nprintk ("CACHE TEST FAILED: ncr wrote %d, host read %d.\n",\r\n(int) ncr_wr, (int) host_rd);\r\nerr |= 2;\r\n}\r\nif (ncr_bk != ncr_wr) {\r\nprintk ("CACHE TEST FAILED: ncr wrote %d, read back %d.\n",\r\n(int) ncr_wr, (int) ncr_bk);\r\nerr |= 4;\r\n}\r\nreturn (err);\r\n}\r\nstatic void ncr_selectclock(struct ncb *np, u_char scntl3)\r\n{\r\nif (np->multiplier < 2) {\r\nOUTB(nc_scntl3, scntl3);\r\nreturn;\r\n}\r\nif (bootverbose >= 2)\r\nprintk ("%s: enabling clock multiplier\n", ncr_name(np));\r\nOUTB(nc_stest1, DBLEN);\r\nif (np->multiplier > 2) {\r\nint i = 20;\r\nwhile (!(INB(nc_stest4) & LCKFRQ) && --i > 0)\r\nudelay(20);\r\nif (!i)\r\nprintk("%s: the chip cannot lock the frequency\n", ncr_name(np));\r\n} else\r\nudelay(20);\r\nOUTB(nc_stest3, HSC);\r\nOUTB(nc_scntl3, scntl3);\r\nOUTB(nc_stest1, (DBLEN|DBLSEL));\r\nOUTB(nc_stest3, 0x00);\r\n}\r\nstatic unsigned __init ncrgetfreq (struct ncb *np, int gen)\r\n{\r\nunsigned ms = 0;\r\nchar count = 0;\r\nOUTB (nc_stest1, 0);\r\nOUTW (nc_sien , 0);\r\n(void) INW (nc_sist);\r\nOUTB (nc_dien , 0);\r\n(void) INW (nc_sist);\r\nOUTB (nc_scntl3, 4);\r\nOUTB (nc_stime1, 0);\r\nOUTB (nc_stime1, gen);\r\nwhile (!(INW(nc_sist) & GEN) && ms++ < 100000) {\r\nfor (count = 0; count < 10; count ++)\r\nudelay(100);\r\n}\r\nOUTB (nc_stime1, 0);\r\nOUTB (nc_scntl3, 0);\r\nif (bootverbose >= 2)\r\nprintk ("%s: Delay (GEN=%d): %u msec\n", ncr_name(np), gen, ms);\r\nreturn ms ? ((1 << gen) * 4340) / ms : 0;\r\n}\r\nstatic void __init ncr_getclock (struct ncb *np, int mult)\r\n{\r\nunsigned char scntl3 = INB(nc_scntl3);\r\nunsigned char stest1 = INB(nc_stest1);\r\nunsigned f1;\r\nnp->multiplier = 1;\r\nf1 = 40000;\r\nif (mult > 1 && (stest1 & (DBLEN+DBLSEL)) == DBLEN+DBLSEL) {\r\nif (bootverbose >= 2)\r\nprintk ("%s: clock multiplier found\n", ncr_name(np));\r\nnp->multiplier = mult;\r\n}\r\nif (np->multiplier != mult || (scntl3 & 7) < 3 || !(scntl3 & 1)) {\r\nunsigned f2;\r\nncr_chip_reset(np, 5);\r\n(void) ncrgetfreq (np, 11);\r\nf1 = ncrgetfreq (np, 11);\r\nf2 = ncrgetfreq (np, 11);\r\nif(bootverbose)\r\nprintk ("%s: NCR clock is %uKHz, %uKHz\n", ncr_name(np), f1, f2);\r\nif (f1 > f2) f1 = f2;\r\nif (f1 < 45000) f1 = 40000;\r\nelse if (f1 < 55000) f1 = 50000;\r\nelse f1 = 80000;\r\nif (f1 < 80000 && mult > 1) {\r\nif (bootverbose >= 2)\r\nprintk ("%s: clock multiplier assumed\n", ncr_name(np));\r\nnp->multiplier = mult;\r\n}\r\n} else {\r\nif ((scntl3 & 7) == 3) f1 = 40000;\r\nelse if ((scntl3 & 7) == 5) f1 = 80000;\r\nelse f1 = 160000;\r\nf1 /= np->multiplier;\r\n}\r\nf1 *= np->multiplier;\r\nnp->clock_khz = f1;\r\n}\r\nstatic int ncr53c8xx_slave_alloc(struct scsi_device *device)\r\n{\r\nstruct Scsi_Host *host = device->host;\r\nstruct ncb *np = ((struct host_data *) host->hostdata)->ncb;\r\nstruct tcb *tp = &np->target[device->id];\r\ntp->starget = device->sdev_target;\r\nreturn 0;\r\n}\r\nstatic int ncr53c8xx_slave_configure(struct scsi_device *device)\r\n{\r\nstruct Scsi_Host *host = device->host;\r\nstruct ncb *np = ((struct host_data *) host->hostdata)->ncb;\r\nstruct tcb *tp = &np->target[device->id];\r\nstruct lcb *lp = tp->lp[device->lun];\r\nint numtags, depth_to_use;\r\nncr_setup_lcb(np, device);\r\nnumtags = device_queue_depth(np->unit, device->id, device->lun);\r\nif (numtags > tp->usrtags)\r\nnumtags = tp->usrtags;\r\nif (!device->tagged_supported)\r\nnumtags = 1;\r\ndepth_to_use = numtags;\r\nif (depth_to_use < 2)\r\ndepth_to_use = 2;\r\nif (depth_to_use > MAX_TAGS)\r\ndepth_to_use = MAX_TAGS;\r\nscsi_change_queue_depth(device, depth_to_use);\r\nif (lp) {\r\nlp->numtags = lp->maxtags = numtags;\r\nlp->scdev_depth = depth_to_use;\r\n}\r\nncr_setup_tags (np, device);\r\n#ifdef DEBUG_NCR53C8XX\r\nprintk("ncr53c8xx_select_queue_depth: host=%d, id=%d, lun=%d, depth=%d\n",\r\nnp->unit, device->id, device->lun, depth_to_use);\r\n#endif\r\nif (spi_support_sync(device->sdev_target) &&\r\n!spi_initial_dv(device->sdev_target))\r\nspi_dv_device(device);\r\nreturn 0;\r\n}\r\nstatic int ncr53c8xx_queue_command_lck (struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))\r\n{\r\nstruct ncb *np = ((struct host_data *) cmd->device->host->hostdata)->ncb;\r\nunsigned long flags;\r\nint sts;\r\n#ifdef DEBUG_NCR53C8XX\r\nprintk("ncr53c8xx_queue_command\n");\r\n#endif\r\ncmd->scsi_done = done;\r\ncmd->host_scribble = NULL;\r\ncmd->__data_mapped = 0;\r\ncmd->__data_mapping = 0;\r\nspin_lock_irqsave(&np->smp_lock, flags);\r\nif ((sts = ncr_queue_command(np, cmd)) != DID_OK) {\r\ncmd->result = ScsiResult(sts, 0);\r\n#ifdef DEBUG_NCR53C8XX\r\nprintk("ncr53c8xx : command not queued - result=%d\n", sts);\r\n#endif\r\n}\r\n#ifdef DEBUG_NCR53C8XX\r\nelse\r\nprintk("ncr53c8xx : command successfully queued\n");\r\n#endif\r\nspin_unlock_irqrestore(&np->smp_lock, flags);\r\nif (sts != DID_OK) {\r\nunmap_scsi_data(np, cmd);\r\ndone(cmd);\r\nsts = 0;\r\n}\r\nreturn sts;\r\n}\r\nstatic void ncr53c8xx_timeout(unsigned long npref)\r\n{\r\nstruct ncb *np = (struct ncb *) npref;\r\nunsigned long flags;\r\nstruct scsi_cmnd *done_list;\r\nspin_lock_irqsave(&np->smp_lock, flags);\r\nncr_timeout(np);\r\ndone_list = np->done_list;\r\nnp->done_list = NULL;\r\nspin_unlock_irqrestore(&np->smp_lock, flags);\r\nif (done_list)\r\nncr_flush_done_cmds(done_list);\r\n}\r\nstatic int ncr53c8xx_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct ncb *np = ((struct host_data *) cmd->device->host->hostdata)->ncb;\r\nint sts;\r\nunsigned long flags;\r\nstruct scsi_cmnd *done_list;\r\nspin_lock_irqsave(&np->smp_lock, flags);\r\nsts = ncr_reset_bus(np, cmd, 1);\r\ndone_list = np->done_list;\r\nnp->done_list = NULL;\r\nspin_unlock_irqrestore(&np->smp_lock, flags);\r\nncr_flush_done_cmds(done_list);\r\nreturn sts;\r\n}\r\nstatic void insert_into_waiting_list(struct ncb *np, struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_cmnd *wcmd;\r\n#ifdef DEBUG_WAITING_LIST\r\nprintk("%s: cmd %lx inserted into waiting list\n", ncr_name(np), (u_long) cmd);\r\n#endif\r\ncmd->next_wcmd = NULL;\r\nif (!(wcmd = np->waiting_list)) np->waiting_list = cmd;\r\nelse {\r\nwhile (wcmd->next_wcmd)\r\nwcmd = (struct scsi_cmnd *) wcmd->next_wcmd;\r\nwcmd->next_wcmd = (char *) cmd;\r\n}\r\n}\r\nstatic struct scsi_cmnd *retrieve_from_waiting_list(int to_remove, struct ncb *np, struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_cmnd **pcmd = &np->waiting_list;\r\nwhile (*pcmd) {\r\nif (cmd == *pcmd) {\r\nif (to_remove) {\r\n*pcmd = (struct scsi_cmnd *) cmd->next_wcmd;\r\ncmd->next_wcmd = NULL;\r\n}\r\n#ifdef DEBUG_WAITING_LIST\r\nprintk("%s: cmd %lx retrieved from waiting list\n", ncr_name(np), (u_long) cmd);\r\n#endif\r\nreturn cmd;\r\n}\r\npcmd = (struct scsi_cmnd **) &(*pcmd)->next_wcmd;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void process_waiting_list(struct ncb *np, int sts)\r\n{\r\nstruct scsi_cmnd *waiting_list, *wcmd;\r\nwaiting_list = np->waiting_list;\r\nnp->waiting_list = NULL;\r\n#ifdef DEBUG_WAITING_LIST\r\nif (waiting_list) printk("%s: waiting_list=%lx processing sts=%d\n", ncr_name(np), (u_long) waiting_list, sts);\r\n#endif\r\nwhile ((wcmd = waiting_list) != NULL) {\r\nwaiting_list = (struct scsi_cmnd *) wcmd->next_wcmd;\r\nwcmd->next_wcmd = NULL;\r\nif (sts == DID_OK) {\r\n#ifdef DEBUG_WAITING_LIST\r\nprintk("%s: cmd %lx trying to requeue\n", ncr_name(np), (u_long) wcmd);\r\n#endif\r\nsts = ncr_queue_command(np, wcmd);\r\n}\r\nif (sts != DID_OK) {\r\n#ifdef DEBUG_WAITING_LIST\r\nprintk("%s: cmd %lx done forced sts=%d\n", ncr_name(np), (u_long) wcmd, sts);\r\n#endif\r\nwcmd->result = ScsiResult(sts, 0);\r\nncr_queue_done_cmd(np, wcmd);\r\n}\r\n}\r\n}\r\nstatic ssize_t show_ncr53c8xx_revision(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *host = class_to_shost(dev);\r\nstruct host_data *host_data = (struct host_data *)host->hostdata;\r\nreturn snprintf(buf, 20, "0x%x\n", host_data->ncb->revision_id);\r\n}\r\nstatic int __init ncr53c8xx_setup(char *str)\r\n{\r\nreturn sym53c8xx__setup(str);\r\n}\r\nstruct Scsi_Host * __init ncr_attach(struct scsi_host_template *tpnt,\r\nint unit, struct ncr_device *device)\r\n{\r\nstruct host_data *host_data;\r\nstruct ncb *np = NULL;\r\nstruct Scsi_Host *instance = NULL;\r\nu_long flags = 0;\r\nint i;\r\nif (!tpnt->name)\r\ntpnt->name = SCSI_NCR_DRIVER_NAME;\r\nif (!tpnt->shost_attrs)\r\ntpnt->shost_attrs = ncr53c8xx_host_attrs;\r\ntpnt->queuecommand = ncr53c8xx_queue_command;\r\ntpnt->slave_configure = ncr53c8xx_slave_configure;\r\ntpnt->slave_alloc = ncr53c8xx_slave_alloc;\r\ntpnt->eh_bus_reset_handler = ncr53c8xx_bus_reset;\r\ntpnt->can_queue = SCSI_NCR_CAN_QUEUE;\r\ntpnt->this_id = 7;\r\ntpnt->sg_tablesize = SCSI_NCR_SG_TABLESIZE;\r\ntpnt->cmd_per_lun = SCSI_NCR_CMD_PER_LUN;\r\ntpnt->use_clustering = ENABLE_CLUSTERING;\r\nif (device->differential)\r\ndriver_setup.diff_support = device->differential;\r\nprintk(KERN_INFO "ncr53c720-%d: rev 0x%x irq %d\n",\r\nunit, device->chip.revision_id, device->slot.irq);\r\ninstance = scsi_host_alloc(tpnt, sizeof(*host_data));\r\nif (!instance)\r\ngoto attach_error;\r\nhost_data = (struct host_data *) instance->hostdata;\r\nnp = __m_calloc_dma(device->dev, sizeof(struct ncb), "NCB");\r\nif (!np)\r\ngoto attach_error;\r\nspin_lock_init(&np->smp_lock);\r\nnp->dev = device->dev;\r\nnp->p_ncb = vtobus(np);\r\nhost_data->ncb = np;\r\nnp->ccb = m_calloc_dma(sizeof(struct ccb), "CCB");\r\nif (!np->ccb)\r\ngoto attach_error;\r\nnp->unit = unit;\r\nnp->verbose = driver_setup.verbose;\r\nsprintf(np->inst_name, "ncr53c720-%d", np->unit);\r\nnp->revision_id = device->chip.revision_id;\r\nnp->features = device->chip.features;\r\nnp->clock_divn = device->chip.nr_divisor;\r\nnp->maxoffs = device->chip.offset_max;\r\nnp->maxburst = device->chip.burst_max;\r\nnp->myaddr = device->host_id;\r\nnp->script0 = m_calloc_dma(sizeof(struct script), "SCRIPT");\r\nif (!np->script0)\r\ngoto attach_error;\r\nnp->scripth0 = m_calloc_dma(sizeof(struct scripth), "SCRIPTH");\r\nif (!np->scripth0)\r\ngoto attach_error;\r\ninit_timer(&np->timer);\r\nnp->timer.data = (unsigned long) np;\r\nnp->timer.function = ncr53c8xx_timeout;\r\nnp->paddr = device->slot.base;\r\nnp->paddr2 = (np->features & FE_RAM) ? device->slot.base_2 : 0;\r\nif (device->slot.base_v)\r\nnp->vaddr = device->slot.base_v;\r\nelse\r\nnp->vaddr = ioremap(device->slot.base_c, 128);\r\nif (!np->vaddr) {\r\nprintk(KERN_ERR\r\n"%s: can't map memory mapped IO region\n",ncr_name(np));\r\ngoto attach_error;\r\n} else {\r\nif (bootverbose > 1)\r\nprintk(KERN_INFO\r\n"%s: using memory mapped IO at virtual address 0x%lx\n", ncr_name(np), (u_long) np->vaddr);\r\n}\r\nnp->reg = (struct ncr_reg __iomem *)np->vaddr;\r\nncr_prepare_setting(np);\r\nif (np->paddr2 && sizeof(struct script) > 4096) {\r\nnp->paddr2 = 0;\r\nprintk(KERN_WARNING "%s: script too large, NOT using on chip RAM.\n",\r\nncr_name(np));\r\n}\r\ninstance->max_channel = 0;\r\ninstance->this_id = np->myaddr;\r\ninstance->max_id = np->maxwide ? 16 : 8;\r\ninstance->max_lun = SCSI_NCR_MAX_LUN;\r\ninstance->base = (unsigned long) np->reg;\r\ninstance->irq = device->slot.irq;\r\ninstance->unique_id = device->slot.base;\r\ninstance->dma_channel = 0;\r\ninstance->cmd_per_lun = MAX_TAGS;\r\ninstance->can_queue = (MAX_START-4);\r\nBUG_ON(!ncr53c8xx_transport_template);\r\ninstance->transportt = ncr53c8xx_transport_template;\r\nncr_script_fill(&script0, &scripth0);\r\nnp->scripth = np->scripth0;\r\nnp->p_scripth = vtobus(np->scripth);\r\nnp->p_script = (np->paddr2) ? np->paddr2 : vtobus(np->script0);\r\nncr_script_copy_and_bind(np, (ncrcmd *) &script0,\r\n(ncrcmd *) np->script0, sizeof(struct script));\r\nncr_script_copy_and_bind(np, (ncrcmd *) &scripth0,\r\n(ncrcmd *) np->scripth0, sizeof(struct scripth));\r\nnp->ccb->p_ccb = vtobus (np->ccb);\r\nif (np->features & FE_LED0) {\r\nnp->script0->idle[0] =\r\ncpu_to_scr(SCR_REG_REG(gpreg, SCR_OR, 0x01));\r\nnp->script0->reselected[0] =\r\ncpu_to_scr(SCR_REG_REG(gpreg, SCR_AND, 0xfe));\r\nnp->script0->start[0] =\r\ncpu_to_scr(SCR_REG_REG(gpreg, SCR_AND, 0xfe));\r\n}\r\nfor (i = 0 ; i < 4 ; i++) {\r\nnp->jump_tcb[i].l_cmd =\r\ncpu_to_scr((SCR_JUMP ^ IFTRUE (MASK (i, 3))));\r\nnp->jump_tcb[i].l_paddr =\r\ncpu_to_scr(NCB_SCRIPTH_PHYS (np, bad_target));\r\n}\r\nncr_chip_reset(np, 100);\r\nif (ncr_snooptest(np)) {\r\nprintk(KERN_ERR "CACHE INCORRECTLY CONFIGURED.\n");\r\ngoto attach_error;\r\n}\r\nnp->irq = device->slot.irq;\r\nncr_init_ccb(np, np->ccb);\r\nspin_lock_irqsave(&np->smp_lock, flags);\r\nif (ncr_reset_scsi_bus(np, 0, driver_setup.settle_delay) != 0) {\r\nprintk(KERN_ERR "%s: FATAL ERROR: CHECK SCSI BUS - CABLES, TERMINATION, DEVICE POWER etc.!\n", ncr_name(np));\r\nspin_unlock_irqrestore(&np->smp_lock, flags);\r\ngoto attach_error;\r\n}\r\nncr_exception(np);\r\nnp->disc = 1;\r\nif (driver_setup.settle_delay > 2) {\r\nprintk(KERN_INFO "%s: waiting %d seconds for scsi devices to settle...\n",\r\nncr_name(np), driver_setup.settle_delay);\r\nmdelay(1000 * driver_setup.settle_delay);\r\n}\r\nnp->lasttime=0;\r\nncr_timeout (np);\r\n#ifdef SCSI_NCR_ALWAYS_SIMPLE_TAG\r\nnp->order = SIMPLE_QUEUE_TAG;\r\n#endif\r\nspin_unlock_irqrestore(&np->smp_lock, flags);\r\nreturn instance;\r\nattach_error:\r\nif (!instance)\r\nreturn NULL;\r\nprintk(KERN_INFO "%s: detaching...\n", ncr_name(np));\r\nif (!np)\r\ngoto unregister;\r\nif (np->scripth0)\r\nm_free_dma(np->scripth0, sizeof(struct scripth), "SCRIPTH");\r\nif (np->script0)\r\nm_free_dma(np->script0, sizeof(struct script), "SCRIPT");\r\nif (np->ccb)\r\nm_free_dma(np->ccb, sizeof(struct ccb), "CCB");\r\nm_free_dma(np, sizeof(struct ncb), "NCB");\r\nhost_data->ncb = NULL;\r\nunregister:\r\nscsi_host_put(instance);\r\nreturn NULL;\r\n}\r\nvoid ncr53c8xx_release(struct Scsi_Host *host)\r\n{\r\nstruct host_data *host_data = shost_priv(host);\r\n#ifdef DEBUG_NCR53C8XX\r\nprintk("ncr53c8xx: release\n");\r\n#endif\r\nif (host_data->ncb)\r\nncr_detach(host_data->ncb);\r\nscsi_host_put(host);\r\n}\r\nstatic void ncr53c8xx_set_period(struct scsi_target *starget, int period)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ncb *np = ((struct host_data *)shost->hostdata)->ncb;\r\nstruct tcb *tp = &np->target[starget->id];\r\nif (period > np->maxsync)\r\nperiod = np->maxsync;\r\nelse if (period < np->minsync)\r\nperiod = np->minsync;\r\ntp->usrsync = period;\r\nncr_negotiate(np, tp);\r\n}\r\nstatic void ncr53c8xx_set_offset(struct scsi_target *starget, int offset)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ncb *np = ((struct host_data *)shost->hostdata)->ncb;\r\nstruct tcb *tp = &np->target[starget->id];\r\nif (offset > np->maxoffs)\r\noffset = np->maxoffs;\r\nelse if (offset < 0)\r\noffset = 0;\r\ntp->maxoffs = offset;\r\nncr_negotiate(np, tp);\r\n}\r\nstatic void ncr53c8xx_set_width(struct scsi_target *starget, int width)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ncb *np = ((struct host_data *)shost->hostdata)->ncb;\r\nstruct tcb *tp = &np->target[starget->id];\r\nif (width > np->maxwide)\r\nwidth = np->maxwide;\r\nelse if (width < 0)\r\nwidth = 0;\r\ntp->usrwide = width;\r\nncr_negotiate(np, tp);\r\n}\r\nstatic void ncr53c8xx_get_signalling(struct Scsi_Host *shost)\r\n{\r\nstruct ncb *np = ((struct host_data *)shost->hostdata)->ncb;\r\nenum spi_signal_type type;\r\nswitch (np->scsi_mode) {\r\ncase SMODE_SE:\r\ntype = SPI_SIGNAL_SE;\r\nbreak;\r\ncase SMODE_HVD:\r\ntype = SPI_SIGNAL_HVD;\r\nbreak;\r\ndefault:\r\ntype = SPI_SIGNAL_UNKNOWN;\r\nbreak;\r\n}\r\nspi_signalling(shost) = type;\r\n}\r\nint __init ncr53c8xx_init(void)\r\n{\r\nncr53c8xx_transport_template = spi_attach_transport(&ncr53c8xx_transport_functions);\r\nif (!ncr53c8xx_transport_template)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nvoid ncr53c8xx_exit(void)\r\n{\r\nspi_release_transport(ncr53c8xx_transport_template);\r\n}
