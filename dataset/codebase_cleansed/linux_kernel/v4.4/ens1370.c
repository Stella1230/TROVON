static unsigned int snd_es1371_wait_src_ready(struct ensoniq * ensoniq)\r\n{\r\nunsigned int t, r = 0;\r\nfor (t = 0; t < POLL_COUNT; t++) {\r\nr = inl(ES_REG(ensoniq, 1371_SMPRATE));\r\nif ((r & ES_1371_SRC_RAM_BUSY) == 0)\r\nreturn r;\r\ncond_resched();\r\n}\r\ndev_err(ensoniq->card->dev, "wait src ready timeout 0x%lx [0x%x]\n",\r\nES_REG(ensoniq, 1371_SMPRATE), r);\r\nreturn 0;\r\n}\r\nstatic unsigned int snd_es1371_src_read(struct ensoniq * ensoniq, unsigned short reg)\r\n{\r\nunsigned int temp, i, orig, r;\r\ntemp = orig = snd_es1371_wait_src_ready(ensoniq);\r\nr = temp & (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 |\r\nES_1371_DIS_P2 | ES_1371_DIS_R1);\r\nr |= ES_1371_SRC_RAM_ADDRO(reg) | 0x10000;\r\noutl(r, ES_REG(ensoniq, 1371_SMPRATE));\r\ntemp = snd_es1371_wait_src_ready(ensoniq);\r\nif ((temp & 0x00870000) != 0x00010000) {\r\nfor (i = 0; i < POLL_COUNT; i++) {\r\ntemp = inl(ES_REG(ensoniq, 1371_SMPRATE));\r\nif ((temp & 0x00870000) == 0x00010000)\r\nbreak;\r\n}\r\n}\r\nr = orig & (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 |\r\nES_1371_DIS_P2 | ES_1371_DIS_R1);\r\nr |= ES_1371_SRC_RAM_ADDRO(reg);\r\noutl(r, ES_REG(ensoniq, 1371_SMPRATE));\r\nreturn temp;\r\n}\r\nstatic void snd_es1371_src_write(struct ensoniq * ensoniq,\r\nunsigned short reg, unsigned short data)\r\n{\r\nunsigned int r;\r\nr = snd_es1371_wait_src_ready(ensoniq) &\r\n(ES_1371_SRC_DISABLE | ES_1371_DIS_P1 |\r\nES_1371_DIS_P2 | ES_1371_DIS_R1);\r\nr |= ES_1371_SRC_RAM_ADDRO(reg) | ES_1371_SRC_RAM_DATAO(data);\r\noutl(r | ES_1371_SRC_RAM_WE, ES_REG(ensoniq, 1371_SMPRATE));\r\n}\r\nstatic void snd_es1370_codec_write(struct snd_ak4531 *ak4531,\r\nunsigned short reg, unsigned short val)\r\n{\r\nstruct ensoniq *ensoniq = ak4531->private_data;\r\nunsigned long end_time = jiffies + HZ / 10;\r\n#if 0\r\ndev_dbg(ensoniq->card->dev,\r\n"CODEC WRITE: reg = 0x%x, val = 0x%x (0x%x), creg = 0x%x\n",\r\nreg, val, ES_1370_CODEC_WRITE(reg, val), ES_REG(ensoniq, 1370_CODEC));\r\n#endif\r\ndo {\r\nif (!(inl(ES_REG(ensoniq, STATUS)) & ES_1370_CSTAT)) {\r\noutw(ES_1370_CODEC_WRITE(reg, val), ES_REG(ensoniq, 1370_CODEC));\r\nreturn;\r\n}\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after(end_time, jiffies));\r\ndev_err(ensoniq->card->dev, "codec write timeout, status = 0x%x\n",\r\ninl(ES_REG(ensoniq, STATUS)));\r\n}\r\nstatic inline bool is_ev1938(struct ensoniq *ensoniq)\r\n{\r\nreturn ensoniq->pci->device == 0x8938;\r\n}\r\nstatic void snd_es1371_codec_write(struct snd_ac97 *ac97,\r\nunsigned short reg, unsigned short val)\r\n{\r\nstruct ensoniq *ensoniq = ac97->private_data;\r\nunsigned int t, x, flag;\r\nflag = is_ev1938(ensoniq) ? EV_1938_CODEC_MAGIC : 0;\r\nmutex_lock(&ensoniq->src_mutex);\r\nfor (t = 0; t < POLL_COUNT; t++) {\r\nif (!(inl(ES_REG(ensoniq, 1371_CODEC)) & ES_1371_CODEC_WIP)) {\r\nx = snd_es1371_wait_src_ready(ensoniq);\r\noutl((x & (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 |\r\nES_1371_DIS_P2 | ES_1371_DIS_R1)) | 0x00010000,\r\nES_REG(ensoniq, 1371_SMPRATE));\r\nfor (t = 0; t < POLL_COUNT; t++) {\r\nif ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) ==\r\n0x00000000)\r\nbreak;\r\n}\r\nfor (t = 0; t < POLL_COUNT; t++) {\r\nif ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) ==\r\n0x00010000)\r\nbreak;\r\n}\r\noutl(ES_1371_CODEC_WRITE(reg, val) | flag,\r\nES_REG(ensoniq, 1371_CODEC));\r\nsnd_es1371_wait_src_ready(ensoniq);\r\noutl(x, ES_REG(ensoniq, 1371_SMPRATE));\r\nmutex_unlock(&ensoniq->src_mutex);\r\nreturn;\r\n}\r\n}\r\nmutex_unlock(&ensoniq->src_mutex);\r\ndev_err(ensoniq->card->dev, "codec write timeout at 0x%lx [0x%x]\n",\r\nES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));\r\n}\r\nstatic unsigned short snd_es1371_codec_read(struct snd_ac97 *ac97,\r\nunsigned short reg)\r\n{\r\nstruct ensoniq *ensoniq = ac97->private_data;\r\nunsigned int t, x, flag, fail = 0;\r\nflag = is_ev1938(ensoniq) ? EV_1938_CODEC_MAGIC : 0;\r\n__again:\r\nmutex_lock(&ensoniq->src_mutex);\r\nfor (t = 0; t < POLL_COUNT; t++) {\r\nif (!(inl(ES_REG(ensoniq, 1371_CODEC)) & ES_1371_CODEC_WIP)) {\r\nx = snd_es1371_wait_src_ready(ensoniq);\r\noutl((x & (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 |\r\nES_1371_DIS_P2 | ES_1371_DIS_R1)) | 0x00010000,\r\nES_REG(ensoniq, 1371_SMPRATE));\r\nfor (t = 0; t < POLL_COUNT; t++) {\r\nif ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) ==\r\n0x00000000)\r\nbreak;\r\n}\r\nfor (t = 0; t < POLL_COUNT; t++) {\r\nif ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) ==\r\n0x00010000)\r\nbreak;\r\n}\r\noutl(ES_1371_CODEC_READS(reg) | flag,\r\nES_REG(ensoniq, 1371_CODEC));\r\nsnd_es1371_wait_src_ready(ensoniq);\r\noutl(x, ES_REG(ensoniq, 1371_SMPRATE));\r\nfor (t = 0; t < POLL_COUNT; t++) {\r\nif (!(inl(ES_REG(ensoniq, 1371_CODEC)) & ES_1371_CODEC_WIP))\r\nbreak;\r\n}\r\nfor (t = 0; t < POLL_COUNT; t++) {\r\nif ((x = inl(ES_REG(ensoniq, 1371_CODEC))) & ES_1371_CODEC_RDY) {\r\nif (is_ev1938(ensoniq)) {\r\nfor (t = 0; t < 100; t++)\r\ninl(ES_REG(ensoniq, CONTROL));\r\nx = inl(ES_REG(ensoniq, 1371_CODEC));\r\n}\r\nmutex_unlock(&ensoniq->src_mutex);\r\nreturn ES_1371_CODEC_READ(x);\r\n}\r\n}\r\nmutex_unlock(&ensoniq->src_mutex);\r\nif (++fail > 10) {\r\ndev_err(ensoniq->card->dev,\r\n"codec read timeout (final) at 0x%lx, reg = 0x%x [0x%x]\n",\r\nES_REG(ensoniq, 1371_CODEC), reg,\r\ninl(ES_REG(ensoniq, 1371_CODEC)));\r\nreturn 0;\r\n}\r\ngoto __again;\r\n}\r\n}\r\nmutex_unlock(&ensoniq->src_mutex);\r\ndev_err(ensoniq->card->dev, "codec read timeout at 0x%lx [0x%x]\n",\r\nES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));\r\nreturn 0;\r\n}\r\nstatic void snd_es1371_codec_wait(struct snd_ac97 *ac97)\r\n{\r\nmsleep(750);\r\nsnd_es1371_codec_read(ac97, AC97_RESET);\r\nsnd_es1371_codec_read(ac97, AC97_VENDOR_ID1);\r\nsnd_es1371_codec_read(ac97, AC97_VENDOR_ID2);\r\nmsleep(50);\r\n}\r\nstatic void snd_es1371_adc_rate(struct ensoniq * ensoniq, unsigned int rate)\r\n{\r\nunsigned int n, truncm, freq, result;\r\nmutex_lock(&ensoniq->src_mutex);\r\nn = rate / 3000;\r\nif ((1 << n) & ((1 << 15) | (1 << 13) | (1 << 11) | (1 << 9)))\r\nn--;\r\ntruncm = (21 * n - 1) | 1;\r\nfreq = ((48000UL << 15) / rate) * n;\r\nresult = (48000UL << 15) / (freq / n);\r\nif (rate >= 24000) {\r\nif (truncm > 239)\r\ntruncm = 239;\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_ADC + ES_SMPREG_TRUNC_N,\r\n(((239 - truncm) >> 1) << 9) | (n << 4));\r\n} else {\r\nif (truncm > 119)\r\ntruncm = 119;\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_ADC + ES_SMPREG_TRUNC_N,\r\n0x8000 | (((119 - truncm) >> 1) << 9) | (n << 4));\r\n}\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_ADC + ES_SMPREG_INT_REGS,\r\n(snd_es1371_src_read(ensoniq, ES_SMPREG_ADC +\r\nES_SMPREG_INT_REGS) & 0x00ff) |\r\n((freq >> 5) & 0xfc00));\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_ADC + ES_SMPREG_VFREQ_FRAC, freq & 0x7fff);\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC, n << 8);\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC + 1, n << 8);\r\nmutex_unlock(&ensoniq->src_mutex);\r\n}\r\nstatic void snd_es1371_dac1_rate(struct ensoniq * ensoniq, unsigned int rate)\r\n{\r\nunsigned int freq, r;\r\nmutex_lock(&ensoniq->src_mutex);\r\nfreq = ((rate << 15) + 1500) / 3000;\r\nr = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE |\r\nES_1371_DIS_P2 | ES_1371_DIS_R1)) |\r\nES_1371_DIS_P1;\r\noutl(r, ES_REG(ensoniq, 1371_SMPRATE));\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_INT_REGS,\r\n(snd_es1371_src_read(ensoniq, ES_SMPREG_DAC1 +\r\nES_SMPREG_INT_REGS) & 0x00ff) |\r\n((freq >> 5) & 0xfc00));\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_VFREQ_FRAC, freq & 0x7fff);\r\nr = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE |\r\nES_1371_DIS_P2 | ES_1371_DIS_R1));\r\noutl(r, ES_REG(ensoniq, 1371_SMPRATE));\r\nmutex_unlock(&ensoniq->src_mutex);\r\n}\r\nstatic void snd_es1371_dac2_rate(struct ensoniq * ensoniq, unsigned int rate)\r\n{\r\nunsigned int freq, r;\r\nmutex_lock(&ensoniq->src_mutex);\r\nfreq = ((rate << 15) + 1500) / 3000;\r\nr = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE |\r\nES_1371_DIS_P1 | ES_1371_DIS_R1)) |\r\nES_1371_DIS_P2;\r\noutl(r, ES_REG(ensoniq, 1371_SMPRATE));\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_INT_REGS,\r\n(snd_es1371_src_read(ensoniq, ES_SMPREG_DAC2 +\r\nES_SMPREG_INT_REGS) & 0x00ff) |\r\n((freq >> 5) & 0xfc00));\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_VFREQ_FRAC,\r\nfreq & 0x7fff);\r\nr = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE |\r\nES_1371_DIS_P1 | ES_1371_DIS_R1));\r\noutl(r, ES_REG(ensoniq, 1371_SMPRATE));\r\nmutex_unlock(&ensoniq->src_mutex);\r\n}\r\nstatic int snd_ensoniq_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\n{\r\nunsigned int what = 0;\r\nstruct snd_pcm_substream *s;\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s == ensoniq->playback1_substream) {\r\nwhat |= ES_P1_PAUSE;\r\nsnd_pcm_trigger_done(s, substream);\r\n} else if (s == ensoniq->playback2_substream) {\r\nwhat |= ES_P2_PAUSE;\r\nsnd_pcm_trigger_done(s, substream);\r\n} else if (s == ensoniq->capture_substream)\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&ensoniq->reg_lock);\r\nif (cmd == SNDRV_PCM_TRIGGER_PAUSE_PUSH)\r\nensoniq->sctrl |= what;\r\nelse\r\nensoniq->sctrl &= ~what;\r\noutl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));\r\nspin_unlock(&ensoniq->reg_lock);\r\nbreak;\r\n}\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\n{\r\nunsigned int what = 0;\r\nstruct snd_pcm_substream *s;\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s == ensoniq->playback1_substream) {\r\nwhat |= ES_DAC1_EN;\r\nsnd_pcm_trigger_done(s, substream);\r\n} else if (s == ensoniq->playback2_substream) {\r\nwhat |= ES_DAC2_EN;\r\nsnd_pcm_trigger_done(s, substream);\r\n} else if (s == ensoniq->capture_substream) {\r\nwhat |= ES_ADC_EN;\r\nsnd_pcm_trigger_done(s, substream);\r\n}\r\n}\r\nspin_lock(&ensoniq->reg_lock);\r\nif (cmd == SNDRV_PCM_TRIGGER_START)\r\nensoniq->ctrl |= what;\r\nelse\r\nensoniq->ctrl &= ~what;\r\noutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\r\nspin_unlock(&ensoniq->reg_lock);\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ensoniq_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_ensoniq_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_ensoniq_playback1_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int mode = 0;\r\nensoniq->p1_dma_size = snd_pcm_lib_buffer_bytes(substream);\r\nensoniq->p1_period_size = snd_pcm_lib_period_bytes(substream);\r\nif (snd_pcm_format_width(runtime->format) == 16)\r\nmode |= 0x02;\r\nif (runtime->channels > 1)\r\nmode |= 0x01;\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nensoniq->ctrl &= ~ES_DAC1_EN;\r\n#ifdef CHIP1371\r\nif (runtime->rate == 48000)\r\nensoniq->ctrl |= ES_1373_BYPASS_P1;\r\nelse\r\nensoniq->ctrl &= ~ES_1373_BYPASS_P1;\r\n#endif\r\noutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\r\noutl(ES_MEM_PAGEO(ES_PAGE_DAC), ES_REG(ensoniq, MEM_PAGE));\r\noutl(runtime->dma_addr, ES_REG(ensoniq, DAC1_FRAME));\r\noutl((ensoniq->p1_dma_size >> 2) - 1, ES_REG(ensoniq, DAC1_SIZE));\r\nensoniq->sctrl &= ~(ES_P1_LOOP_SEL | ES_P1_PAUSE | ES_P1_SCT_RLD | ES_P1_MODEM);\r\nensoniq->sctrl |= ES_P1_INT_EN | ES_P1_MODEO(mode);\r\noutl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));\r\noutl((ensoniq->p1_period_size >> snd_ensoniq_sample_shift[mode]) - 1,\r\nES_REG(ensoniq, DAC1_COUNT));\r\n#ifdef CHIP1370\r\nensoniq->ctrl &= ~ES_1370_WTSRSELM;\r\nswitch (runtime->rate) {\r\ncase 5512: ensoniq->ctrl |= ES_1370_WTSRSEL(0); break;\r\ncase 11025: ensoniq->ctrl |= ES_1370_WTSRSEL(1); break;\r\ncase 22050: ensoniq->ctrl |= ES_1370_WTSRSEL(2); break;\r\ncase 44100: ensoniq->ctrl |= ES_1370_WTSRSEL(3); break;\r\ndefault: snd_BUG();\r\n}\r\n#endif\r\noutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\n#ifndef CHIP1370\r\nsnd_es1371_dac1_rate(ensoniq, runtime->rate);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_ensoniq_playback2_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int mode = 0;\r\nensoniq->p2_dma_size = snd_pcm_lib_buffer_bytes(substream);\r\nensoniq->p2_period_size = snd_pcm_lib_period_bytes(substream);\r\nif (snd_pcm_format_width(runtime->format) == 16)\r\nmode |= 0x02;\r\nif (runtime->channels > 1)\r\nmode |= 0x01;\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nensoniq->ctrl &= ~ES_DAC2_EN;\r\noutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\r\noutl(ES_MEM_PAGEO(ES_PAGE_DAC), ES_REG(ensoniq, MEM_PAGE));\r\noutl(runtime->dma_addr, ES_REG(ensoniq, DAC2_FRAME));\r\noutl((ensoniq->p2_dma_size >> 2) - 1, ES_REG(ensoniq, DAC2_SIZE));\r\nensoniq->sctrl &= ~(ES_P2_LOOP_SEL | ES_P2_PAUSE | ES_P2_DAC_SEN |\r\nES_P2_END_INCM | ES_P2_ST_INCM | ES_P2_MODEM);\r\nensoniq->sctrl |= ES_P2_INT_EN | ES_P2_MODEO(mode) |\r\nES_P2_END_INCO(mode & 2 ? 2 : 1) | ES_P2_ST_INCO(0);\r\noutl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));\r\noutl((ensoniq->p2_period_size >> snd_ensoniq_sample_shift[mode]) - 1,\r\nES_REG(ensoniq, DAC2_COUNT));\r\n#ifdef CHIP1370\r\nif (!(ensoniq->u.es1370.pclkdiv_lock & ES_MODE_CAPTURE)) {\r\nensoniq->ctrl &= ~ES_1370_PCLKDIVM;\r\nensoniq->ctrl |= ES_1370_PCLKDIVO(ES_1370_SRTODIV(runtime->rate));\r\nensoniq->u.es1370.pclkdiv_lock |= ES_MODE_PLAY2;\r\n}\r\n#endif\r\noutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\n#ifndef CHIP1370\r\nsnd_es1371_dac2_rate(ensoniq, runtime->rate);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_ensoniq_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int mode = 0;\r\nensoniq->c_dma_size = snd_pcm_lib_buffer_bytes(substream);\r\nensoniq->c_period_size = snd_pcm_lib_period_bytes(substream);\r\nif (snd_pcm_format_width(runtime->format) == 16)\r\nmode |= 0x02;\r\nif (runtime->channels > 1)\r\nmode |= 0x01;\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nensoniq->ctrl &= ~ES_ADC_EN;\r\noutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\r\noutl(ES_MEM_PAGEO(ES_PAGE_ADC), ES_REG(ensoniq, MEM_PAGE));\r\noutl(runtime->dma_addr, ES_REG(ensoniq, ADC_FRAME));\r\noutl((ensoniq->c_dma_size >> 2) - 1, ES_REG(ensoniq, ADC_SIZE));\r\nensoniq->sctrl &= ~(ES_R1_LOOP_SEL | ES_R1_MODEM);\r\nensoniq->sctrl |= ES_R1_INT_EN | ES_R1_MODEO(mode);\r\noutl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));\r\noutl((ensoniq->c_period_size >> snd_ensoniq_sample_shift[mode]) - 1,\r\nES_REG(ensoniq, ADC_COUNT));\r\n#ifdef CHIP1370\r\nif (!(ensoniq->u.es1370.pclkdiv_lock & ES_MODE_PLAY2)) {\r\nensoniq->ctrl &= ~ES_1370_PCLKDIVM;\r\nensoniq->ctrl |= ES_1370_PCLKDIVO(ES_1370_SRTODIV(runtime->rate));\r\nensoniq->u.es1370.pclkdiv_lock |= ES_MODE_CAPTURE;\r\n}\r\n#endif\r\noutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\n#ifndef CHIP1370\r\nsnd_es1371_adc_rate(ensoniq, runtime->rate);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_ensoniq_playback1_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nspin_lock(&ensoniq->reg_lock);\r\nif (inl(ES_REG(ensoniq, CONTROL)) & ES_DAC1_EN) {\r\noutl(ES_MEM_PAGEO(ES_PAGE_DAC), ES_REG(ensoniq, MEM_PAGE));\r\nptr = ES_REG_FCURR_COUNTI(inl(ES_REG(ensoniq, DAC1_SIZE)));\r\nptr = bytes_to_frames(substream->runtime, ptr);\r\n} else {\r\nptr = 0;\r\n}\r\nspin_unlock(&ensoniq->reg_lock);\r\nreturn ptr;\r\n}\r\nstatic snd_pcm_uframes_t snd_ensoniq_playback2_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nspin_lock(&ensoniq->reg_lock);\r\nif (inl(ES_REG(ensoniq, CONTROL)) & ES_DAC2_EN) {\r\noutl(ES_MEM_PAGEO(ES_PAGE_DAC), ES_REG(ensoniq, MEM_PAGE));\r\nptr = ES_REG_FCURR_COUNTI(inl(ES_REG(ensoniq, DAC2_SIZE)));\r\nptr = bytes_to_frames(substream->runtime, ptr);\r\n} else {\r\nptr = 0;\r\n}\r\nspin_unlock(&ensoniq->reg_lock);\r\nreturn ptr;\r\n}\r\nstatic snd_pcm_uframes_t snd_ensoniq_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nspin_lock(&ensoniq->reg_lock);\r\nif (inl(ES_REG(ensoniq, CONTROL)) & ES_ADC_EN) {\r\noutl(ES_MEM_PAGEO(ES_PAGE_ADC), ES_REG(ensoniq, MEM_PAGE));\r\nptr = ES_REG_FCURR_COUNTI(inl(ES_REG(ensoniq, ADC_SIZE)));\r\nptr = bytes_to_frames(substream->runtime, ptr);\r\n} else {\r\nptr = 0;\r\n}\r\nspin_unlock(&ensoniq->reg_lock);\r\nreturn ptr;\r\n}\r\nstatic int snd_ensoniq_playback1_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nensoniq->mode |= ES_MODE_PLAY1;\r\nensoniq->playback1_substream = substream;\r\nruntime->hw = snd_ensoniq_playback1;\r\nsnd_pcm_set_sync(substream);\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nif (ensoniq->spdif && ensoniq->playback2_substream == NULL)\r\nensoniq->spdif_stream = ensoniq->spdif_default;\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\n#ifdef CHIP1370\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&snd_es1370_hw_constraints_rates);\r\n#else\r\nsnd_pcm_hw_constraint_ratdens(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&snd_es1371_hw_constraints_dac_clock);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_ensoniq_playback2_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nensoniq->mode |= ES_MODE_PLAY2;\r\nensoniq->playback2_substream = substream;\r\nruntime->hw = snd_ensoniq_playback2;\r\nsnd_pcm_set_sync(substream);\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nif (ensoniq->spdif && ensoniq->playback1_substream == NULL)\r\nensoniq->spdif_stream = ensoniq->spdif_default;\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\n#ifdef CHIP1370\r\nsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&snd_es1370_hw_constraints_clock);\r\n#else\r\nsnd_pcm_hw_constraint_ratdens(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&snd_es1371_hw_constraints_dac_clock);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_ensoniq_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nensoniq->mode |= ES_MODE_CAPTURE;\r\nensoniq->capture_substream = substream;\r\nruntime->hw = snd_ensoniq_capture;\r\nsnd_pcm_set_sync(substream);\r\n#ifdef CHIP1370\r\nsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&snd_es1370_hw_constraints_clock);\r\n#else\r\nsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&snd_es1371_hw_constraints_adc_clock);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_ensoniq_playback1_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\r\nensoniq->playback1_substream = NULL;\r\nensoniq->mode &= ~ES_MODE_PLAY1;\r\nreturn 0;\r\n}\r\nstatic int snd_ensoniq_playback2_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\r\nensoniq->playback2_substream = NULL;\r\nspin_lock_irq(&ensoniq->reg_lock);\r\n#ifdef CHIP1370\r\nensoniq->u.es1370.pclkdiv_lock &= ~ES_MODE_PLAY2;\r\n#endif\r\nensoniq->mode &= ~ES_MODE_PLAY2;\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ensoniq_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\r\nensoniq->capture_substream = NULL;\r\nspin_lock_irq(&ensoniq->reg_lock);\r\n#ifdef CHIP1370\r\nensoniq->u.es1370.pclkdiv_lock &= ~ES_MODE_CAPTURE;\r\n#endif\r\nensoniq->mode &= ~ES_MODE_CAPTURE;\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ensoniq_pcm(struct ensoniq *ensoniq, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(ensoniq->card, CHIP_NAME "/1", device, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\n#ifdef CHIP1370\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ensoniq_playback2_ops);\r\n#else\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ensoniq_playback1_ops);\r\n#endif\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ensoniq_capture_ops);\r\npcm->private_data = ensoniq;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, CHIP_NAME " DAC2/ADC");\r\nensoniq->pcm1 = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(ensoniq->pci), 64*1024, 128*1024);\r\n#ifdef CHIP1370\r\nerr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\nsurround_map, 2, 0, NULL);\r\n#else\r\nerr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\nsnd_pcm_std_chmaps, 2, 0, NULL);\r\n#endif\r\nreturn err;\r\n}\r\nstatic int snd_ensoniq_pcm2(struct ensoniq *ensoniq, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(ensoniq->card, CHIP_NAME "/2", device, 1, 0, &pcm);\r\nif (err < 0)\r\nreturn err;\r\n#ifdef CHIP1370\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ensoniq_playback1_ops);\r\n#else\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ensoniq_playback2_ops);\r\n#endif\r\npcm->private_data = ensoniq;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, CHIP_NAME " DAC1");\r\nensoniq->pcm2 = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(ensoniq->pci), 64*1024, 128*1024);\r\n#ifdef CHIP1370\r\nerr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\nsnd_pcm_std_chmaps, 2, 0, NULL);\r\n#else\r\nerr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\nsurround_map, 2, 0, NULL);\r\n#endif\r\nreturn err;\r\n}\r\nstatic int snd_ens1373_spdif_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_ens1373_spdif_default_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nucontrol->value.iec958.status[0] = (ensoniq->spdif_default >> 0) & 0xff;\r\nucontrol->value.iec958.status[1] = (ensoniq->spdif_default >> 8) & 0xff;\r\nucontrol->value.iec958.status[2] = (ensoniq->spdif_default >> 16) & 0xff;\r\nucontrol->value.iec958.status[3] = (ensoniq->spdif_default >> 24) & 0xff;\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ens1373_spdif_default_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change;\r\nval = ((u32)ucontrol->value.iec958.status[0] << 0) |\r\n((u32)ucontrol->value.iec958.status[1] << 8) |\r\n((u32)ucontrol->value.iec958.status[2] << 16) |\r\n((u32)ucontrol->value.iec958.status[3] << 24);\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nchange = ensoniq->spdif_default != val;\r\nensoniq->spdif_default = val;\r\nif (change && ensoniq->playback1_substream == NULL &&\r\nensoniq->playback2_substream == NULL)\r\noutl(val, ES_REG(ensoniq, CHANNEL_STATUS));\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_ens1373_spdif_mask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = 0xff;\r\nucontrol->value.iec958.status[1] = 0xff;\r\nucontrol->value.iec958.status[2] = 0xff;\r\nucontrol->value.iec958.status[3] = 0xff;\r\nreturn 0;\r\n}\r\nstatic int snd_ens1373_spdif_stream_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nucontrol->value.iec958.status[0] = (ensoniq->spdif_stream >> 0) & 0xff;\r\nucontrol->value.iec958.status[1] = (ensoniq->spdif_stream >> 8) & 0xff;\r\nucontrol->value.iec958.status[2] = (ensoniq->spdif_stream >> 16) & 0xff;\r\nucontrol->value.iec958.status[3] = (ensoniq->spdif_stream >> 24) & 0xff;\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ens1373_spdif_stream_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change;\r\nval = ((u32)ucontrol->value.iec958.status[0] << 0) |\r\n((u32)ucontrol->value.iec958.status[1] << 8) |\r\n((u32)ucontrol->value.iec958.status[2] << 16) |\r\n((u32)ucontrol->value.iec958.status[3] << 24);\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nchange = ensoniq->spdif_stream != val;\r\nensoniq->spdif_stream = val;\r\nif (change && (ensoniq->playback1_substream != NULL ||\r\nensoniq->playback2_substream != NULL))\r\noutl(val, ES_REG(ensoniq, CHANNEL_STATUS));\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_es1371_spdif_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nucontrol->value.integer.value[0] = ensoniq->ctrl & ES_1373_SPDIF_THRU ? 1 : 0;\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_es1371_spdif_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\r\nunsigned int nval1, nval2;\r\nint change;\r\nnval1 = ucontrol->value.integer.value[0] ? ES_1373_SPDIF_THRU : 0;\r\nnval2 = ucontrol->value.integer.value[0] ? ES_1373_SPDIF_EN : 0;\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nchange = (ensoniq->ctrl & ES_1373_SPDIF_THRU) != nval1;\r\nensoniq->ctrl &= ~ES_1373_SPDIF_THRU;\r\nensoniq->ctrl |= nval1;\r\nensoniq->cssr &= ~ES_1373_SPDIF_EN;\r\nensoniq->cssr |= nval2;\r\noutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\r\noutl(ensoniq->cssr, ES_REG(ensoniq, STATUS));\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_es1373_rear_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\r\nint val = 0;\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nif ((ensoniq->cssr & (ES_1373_REAR_BIT27|ES_1373_REAR_BIT26|\r\nES_1373_REAR_BIT24)) == ES_1373_REAR_BIT26)\r\nval = 1;\r\nucontrol->value.integer.value[0] = val;\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_es1373_rear_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\r\nunsigned int nval1;\r\nint change;\r\nnval1 = ucontrol->value.integer.value[0] ?\r\nES_1373_REAR_BIT26 : (ES_1373_REAR_BIT27|ES_1373_REAR_BIT24);\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nchange = (ensoniq->cssr & (ES_1373_REAR_BIT27|\r\nES_1373_REAR_BIT26|ES_1373_REAR_BIT24)) != nval1;\r\nensoniq->cssr &= ~(ES_1373_REAR_BIT27|ES_1373_REAR_BIT26|ES_1373_REAR_BIT24);\r\nensoniq->cssr |= nval1;\r\noutl(ensoniq->cssr, ES_REG(ensoniq, STATUS));\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_es1373_line_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\r\nint val = 0;\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nif ((ensoniq->ctrl & ES_1371_GPIO_OUTM) >= 4)\r\nval = 1;\r\nucontrol->value.integer.value[0] = val;\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_es1373_line_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\r\nint changed;\r\nunsigned int ctrl;\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nctrl = ensoniq->ctrl;\r\nif (ucontrol->value.integer.value[0])\r\nensoniq->ctrl |= ES_1371_GPIO_OUT(4);\r\nelse\r\nensoniq->ctrl &= ~ES_1371_GPIO_OUT(4);\r\nchanged = (ctrl != ensoniq->ctrl);\r\nif (changed)\r\noutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\nreturn changed;\r\n}\r\nstatic void snd_ensoniq_mixer_free_ac97(struct snd_ac97 *ac97)\r\n{\r\nstruct ensoniq *ensoniq = ac97->private_data;\r\nensoniq->u.es1371.ac97 = NULL;\r\n}\r\nstatic int es1371_quirk_lookup(struct ensoniq *ensoniq,\r\nstruct es1371_quirk *list)\r\n{\r\nwhile (list->vid != (unsigned short)PCI_ANY_ID) {\r\nif (ensoniq->pci->vendor == list->vid &&\r\nensoniq->pci->device == list->did &&\r\nensoniq->rev == list->rev)\r\nreturn 1;\r\nlist++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ensoniq_1371_mixer(struct ensoniq *ensoniq,\r\nint has_spdif, int has_line)\r\n{\r\nstruct snd_card *card = ensoniq->card;\r\nstruct snd_ac97_bus *pbus;\r\nstruct snd_ac97_template ac97;\r\nint err;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_es1371_codec_write,\r\n.read = snd_es1371_codec_read,\r\n.wait = snd_es1371_codec_wait,\r\n};\r\nif ((err = snd_ac97_bus(card, 0, &ops, NULL, &pbus)) < 0)\r\nreturn err;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = ensoniq;\r\nac97.private_free = snd_ensoniq_mixer_free_ac97;\r\nac97.pci = ensoniq->pci;\r\nac97.scaps = AC97_SCAP_AUDIO;\r\nif ((err = snd_ac97_mixer(pbus, &ac97, &ensoniq->u.es1371.ac97)) < 0)\r\nreturn err;\r\nif (has_spdif > 0 ||\r\n(!has_spdif && es1371_quirk_lookup(ensoniq, es1371_spdif_present))) {\r\nstruct snd_kcontrol *kctl;\r\nint i, is_spdif = 0;\r\nensoniq->spdif_default = ensoniq->spdif_stream =\r\nSNDRV_PCM_DEFAULT_CON_SPDIF;\r\noutl(ensoniq->spdif_default, ES_REG(ensoniq, CHANNEL_STATUS));\r\nif (ensoniq->u.es1371.ac97->ext_id & AC97_EI_SPDIF)\r\nis_spdif++;\r\nfor (i = 0; i < ARRAY_SIZE(snd_es1371_mixer_spdif); i++) {\r\nkctl = snd_ctl_new1(&snd_es1371_mixer_spdif[i], ensoniq);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nkctl->id.index = is_spdif;\r\nerr = snd_ctl_add(card, kctl);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nif (ensoniq->u.es1371.ac97->ext_id & AC97_EI_SDAC) {\r\nensoniq->cssr &= ~(ES_1373_REAR_BIT27|ES_1373_REAR_BIT24);\r\nensoniq->cssr |= ES_1373_REAR_BIT26;\r\nerr = snd_ctl_add(card, snd_ctl_new1(&snd_ens1373_rear, ensoniq));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (has_line > 0 ||\r\nsnd_pci_quirk_lookup(ensoniq->pci, ens1373_line_quirk)) {\r\nerr = snd_ctl_add(card, snd_ctl_new1(&snd_ens1373_line,\r\nensoniq));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ensoniq_control_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\r\nint mask = kcontrol->private_value;\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nucontrol->value.integer.value[0] = ensoniq->ctrl & mask ? 1 : 0;\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ensoniq_control_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\r\nint mask = kcontrol->private_value;\r\nunsigned int nval;\r\nint change;\r\nnval = ucontrol->value.integer.value[0] ? mask : 0;\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nchange = (ensoniq->ctrl & mask) != nval;\r\nensoniq->ctrl &= ~mask;\r\nensoniq->ctrl |= nval;\r\noutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\nreturn change;\r\n}\r\nstatic void snd_ensoniq_mixer_free_ak4531(struct snd_ak4531 *ak4531)\r\n{\r\nstruct ensoniq *ensoniq = ak4531->private_data;\r\nensoniq->u.es1370.ak4531 = NULL;\r\n}\r\nstatic int snd_ensoniq_1370_mixer(struct ensoniq *ensoniq)\r\n{\r\nstruct snd_card *card = ensoniq->card;\r\nstruct snd_ak4531 ak4531;\r\nunsigned int idx;\r\nint err;\r\noutw(ES_1370_CODEC_WRITE(AK4531_RESET, 0x02), ES_REG(ensoniq, 1370_CODEC));\r\ninw(ES_REG(ensoniq, 1370_CODEC));\r\nudelay(100);\r\noutw(ES_1370_CODEC_WRITE(AK4531_RESET, 0x03), ES_REG(ensoniq, 1370_CODEC));\r\ninw(ES_REG(ensoniq, 1370_CODEC));\r\nudelay(100);\r\nmemset(&ak4531, 0, sizeof(ak4531));\r\nak4531.write = snd_es1370_codec_write;\r\nak4531.private_data = ensoniq;\r\nak4531.private_free = snd_ensoniq_mixer_free_ak4531;\r\nif ((err = snd_ak4531_mixer(card, &ak4531, &ensoniq->u.es1370.ak4531)) < 0)\r\nreturn err;\r\nfor (idx = 0; idx < ES1370_CONTROLS; idx++) {\r\nerr = snd_ctl_add(card, snd_ctl_new1(&snd_es1370_controls[idx], ensoniq));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ensoniq_get_joystick_port(struct ensoniq *ensoniq, int dev)\r\n{\r\nswitch (joystick_port[dev]) {\r\ncase 0:\r\ncase 1:\r\ncase 0x200:\r\ncase 0x208:\r\ncase 0x210:\r\ncase 0x218:\r\nreturn joystick_port[dev];\r\ndefault:\r\ndev_err(ensoniq->card->dev,\r\n"invalid joystick port %#x", joystick_port[dev]);\r\nreturn 0;\r\n}\r\n}\r\nstatic int snd_ensoniq_get_joystick_port(struct ensoniq *ensoniq, int dev)\r\n{\r\nreturn joystick[dev] ? 0x200 : 0;\r\n}\r\nstatic int snd_ensoniq_create_gameport(struct ensoniq *ensoniq, int dev)\r\n{\r\nstruct gameport *gp;\r\nint io_port;\r\nio_port = snd_ensoniq_get_joystick_port(ensoniq, dev);\r\nswitch (io_port) {\r\ncase 0:\r\nreturn -ENOSYS;\r\ncase 1:\r\nfor (io_port = 0x200; io_port <= 0x218; io_port += 8)\r\nif (request_region(io_port, 8, "ens137x: gameport"))\r\nbreak;\r\nif (io_port > 0x218) {\r\ndev_warn(ensoniq->card->dev,\r\n"no gameport ports available\n");\r\nreturn -EBUSY;\r\n}\r\nbreak;\r\ndefault:\r\nif (!request_region(io_port, 8, "ens137x: gameport")) {\r\ndev_warn(ensoniq->card->dev,\r\n"gameport io port %#x in use\n",\r\nio_port);\r\nreturn -EBUSY;\r\n}\r\nbreak;\r\n}\r\nensoniq->gameport = gp = gameport_allocate_port();\r\nif (!gp) {\r\ndev_err(ensoniq->card->dev,\r\n"cannot allocate memory for gameport\n");\r\nrelease_region(io_port, 8);\r\nreturn -ENOMEM;\r\n}\r\ngameport_set_name(gp, "ES137x");\r\ngameport_set_phys(gp, "pci%s/gameport0", pci_name(ensoniq->pci));\r\ngameport_set_dev_parent(gp, &ensoniq->pci->dev);\r\ngp->io = io_port;\r\nensoniq->ctrl |= ES_JYSTK_EN;\r\n#ifdef CHIP1371\r\nensoniq->ctrl &= ~ES_1371_JOY_ASELM;\r\nensoniq->ctrl |= ES_1371_JOY_ASEL((io_port - 0x200) / 8);\r\n#endif\r\noutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\r\ngameport_register_port(ensoniq->gameport);\r\nreturn 0;\r\n}\r\nstatic void snd_ensoniq_free_gameport(struct ensoniq *ensoniq)\r\n{\r\nif (ensoniq->gameport) {\r\nint port = ensoniq->gameport->io;\r\ngameport_unregister_port(ensoniq->gameport);\r\nensoniq->gameport = NULL;\r\nensoniq->ctrl &= ~ES_JYSTK_EN;\r\noutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\r\nrelease_region(port, 8);\r\n}\r\n}\r\nstatic inline int snd_ensoniq_create_gameport(struct ensoniq *ensoniq, long port) { return -ENOSYS; }\r\nstatic inline void snd_ensoniq_free_gameport(struct ensoniq *ensoniq) { }\r\nstatic void snd_ensoniq_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct ensoniq *ensoniq = entry->private_data;\r\nsnd_iprintf(buffer, "Ensoniq AudioPCI " CHIP_NAME "\n\n");\r\nsnd_iprintf(buffer, "Joystick enable : %s\n",\r\nensoniq->ctrl & ES_JYSTK_EN ? "on" : "off");\r\n#ifdef CHIP1370\r\nsnd_iprintf(buffer, "MIC +5V bias : %s\n",\r\nensoniq->ctrl & ES_1370_XCTL1 ? "on" : "off");\r\nsnd_iprintf(buffer, "Line In to AOUT : %s\n",\r\nensoniq->ctrl & ES_1370_XCTL0 ? "on" : "off");\r\n#else\r\nsnd_iprintf(buffer, "Joystick port : 0x%x\n",\r\n(ES_1371_JOY_ASELI(ensoniq->ctrl) * 8) + 0x200);\r\n#endif\r\n}\r\nstatic void snd_ensoniq_proc_init(struct ensoniq *ensoniq)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (! snd_card_proc_new(ensoniq->card, "audiopci", &entry))\r\nsnd_info_set_text_ops(entry, ensoniq, snd_ensoniq_proc_read);\r\n}\r\nstatic int snd_ensoniq_free(struct ensoniq *ensoniq)\r\n{\r\nsnd_ensoniq_free_gameport(ensoniq);\r\nif (ensoniq->irq < 0)\r\ngoto __hw_end;\r\n#ifdef CHIP1370\r\noutl(ES_1370_SERR_DISABLE, ES_REG(ensoniq, CONTROL));\r\noutl(0, ES_REG(ensoniq, SERIAL));\r\n#else\r\noutl(0, ES_REG(ensoniq, CONTROL));\r\noutl(0, ES_REG(ensoniq, SERIAL));\r\n#endif\r\nif (ensoniq->irq >= 0)\r\nsynchronize_irq(ensoniq->irq);\r\npci_set_power_state(ensoniq->pci, PCI_D3hot);\r\n__hw_end:\r\n#ifdef CHIP1370\r\nif (ensoniq->dma_bug.area)\r\nsnd_dma_free_pages(&ensoniq->dma_bug);\r\n#endif\r\nif (ensoniq->irq >= 0)\r\nfree_irq(ensoniq->irq, ensoniq);\r\npci_release_regions(ensoniq->pci);\r\npci_disable_device(ensoniq->pci);\r\nkfree(ensoniq);\r\nreturn 0;\r\n}\r\nstatic int snd_ensoniq_dev_free(struct snd_device *device)\r\n{\r\nstruct ensoniq *ensoniq = device->device_data;\r\nreturn snd_ensoniq_free(ensoniq);\r\n}\r\nstatic void snd_ensoniq_chip_init(struct ensoniq *ensoniq)\r\n{\r\n#ifdef CHIP1371\r\nint idx;\r\n#endif\r\n#ifdef CHIP1370\r\noutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\r\noutl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));\r\noutl(ES_MEM_PAGEO(ES_PAGE_ADC), ES_REG(ensoniq, MEM_PAGE));\r\noutl(ensoniq->dma_bug.addr, ES_REG(ensoniq, PHANTOM_FRAME));\r\noutl(0, ES_REG(ensoniq, PHANTOM_COUNT));\r\n#else\r\noutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\r\noutl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));\r\noutl(0, ES_REG(ensoniq, 1371_LEGACY));\r\nif (es1371_quirk_lookup(ensoniq, es1371_ac97_reset_hack)) {\r\noutl(ensoniq->cssr, ES_REG(ensoniq, STATUS));\r\nmsleep(20);\r\n}\r\noutl(ensoniq->ctrl | ES_1371_SYNC_RES, ES_REG(ensoniq, CONTROL));\r\ninl(ES_REG(ensoniq, CONTROL));\r\nudelay(20);\r\noutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\r\nsnd_es1371_wait_src_ready(ensoniq);\r\noutl(ES_1371_SRC_DISABLE, ES_REG(ensoniq, 1371_SMPRATE));\r\nfor (idx = 0; idx < 0x80; idx++)\r\nsnd_es1371_src_write(ensoniq, idx, 0);\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_TRUNC_N, 16 << 4);\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_INT_REGS, 16 << 10);\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_TRUNC_N, 16 << 4);\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_INT_REGS, 16 << 10);\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC, 1 << 12);\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC + 1, 1 << 12);\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC1, 1 << 12);\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC1 + 1, 1 << 12);\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC2, 1 << 12);\r\nsnd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC2 + 1, 1 << 12);\r\nsnd_es1371_adc_rate(ensoniq, 22050);\r\nsnd_es1371_dac1_rate(ensoniq, 22050);\r\nsnd_es1371_dac2_rate(ensoniq, 22050);\r\nsnd_es1371_wait_src_ready(ensoniq);\r\noutl(0, ES_REG(ensoniq, 1371_SMPRATE));\r\noutl(ES_1371_CODEC_WRITE(0, 0), ES_REG(ensoniq, 1371_CODEC));\r\n#endif\r\noutb(ensoniq->uartc = 0x00, ES_REG(ensoniq, UART_CONTROL));\r\noutb(0x00, ES_REG(ensoniq, UART_RES));\r\noutl(ensoniq->cssr, ES_REG(ensoniq, STATUS));\r\nsynchronize_irq(ensoniq->irq);\r\n}\r\nstatic int snd_ensoniq_suspend(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct ensoniq *ensoniq = card->private_data;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(ensoniq->pcm1);\r\nsnd_pcm_suspend_all(ensoniq->pcm2);\r\n#ifdef CHIP1371\r\nsnd_ac97_suspend(ensoniq->u.es1371.ac97);\r\n#else\r\noutw(ES_1370_CODEC_WRITE(AK4531_RESET, 0x02), ES_REG(ensoniq, 1370_CODEC));\r\ninw(ES_REG(ensoniq, 1370_CODEC));\r\nudelay(100);\r\noutw(ES_1370_CODEC_WRITE(AK4531_RESET, 0x03), ES_REG(ensoniq, 1370_CODEC));\r\ninw(ES_REG(ensoniq, 1370_CODEC));\r\nudelay(100);\r\nsnd_ak4531_suspend(ensoniq->u.es1370.ak4531);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_ensoniq_resume(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct ensoniq *ensoniq = card->private_data;\r\nsnd_ensoniq_chip_init(ensoniq);\r\n#ifdef CHIP1371\r\nsnd_ac97_resume(ensoniq->u.es1371.ac97);\r\n#else\r\nsnd_ak4531_resume(ensoniq->u.es1370.ak4531);\r\n#endif\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic int snd_ensoniq_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nstruct ensoniq **rensoniq)\r\n{\r\nstruct ensoniq *ensoniq;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_ensoniq_dev_free,\r\n};\r\n*rensoniq = NULL;\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nensoniq = kzalloc(sizeof(*ensoniq), GFP_KERNEL);\r\nif (ensoniq == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&ensoniq->reg_lock);\r\nmutex_init(&ensoniq->src_mutex);\r\nensoniq->card = card;\r\nensoniq->pci = pci;\r\nensoniq->irq = -1;\r\nif ((err = pci_request_regions(pci, "Ensoniq AudioPCI")) < 0) {\r\nkfree(ensoniq);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nensoniq->port = pci_resource_start(pci, 0);\r\nif (request_irq(pci->irq, snd_audiopci_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, ensoniq)) {\r\ndev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);\r\nsnd_ensoniq_free(ensoniq);\r\nreturn -EBUSY;\r\n}\r\nensoniq->irq = pci->irq;\r\n#ifdef CHIP1370\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),\r\n16, &ensoniq->dma_bug) < 0) {\r\ndev_err(card->dev, "unable to allocate space for phantom area - dma_bug\n");\r\nsnd_ensoniq_free(ensoniq);\r\nreturn -EBUSY;\r\n}\r\n#endif\r\npci_set_master(pci);\r\nensoniq->rev = pci->revision;\r\n#ifdef CHIP1370\r\n#if 0\r\nensoniq->ctrl = ES_1370_CDC_EN | ES_1370_SERR_DISABLE |\r\nES_1370_PCLKDIVO(ES_1370_SRTODIV(8000));\r\n#else\r\nensoniq->ctrl = ES_1370_CDC_EN | ES_1370_PCLKDIVO(ES_1370_SRTODIV(8000));\r\n#endif\r\nensoniq->sctrl = 0;\r\n#else\r\nensoniq->ctrl = 0;\r\nensoniq->sctrl = 0;\r\nensoniq->cssr = 0;\r\nif (snd_pci_quirk_lookup(pci, es1371_amplifier_hack))\r\nensoniq->ctrl |= ES_1371_GPIO_OUT(1);\r\nif (es1371_quirk_lookup(ensoniq, es1371_ac97_reset_hack))\r\nensoniq->cssr |= ES_1371_ST_AC97_RST;\r\n#endif\r\nsnd_ensoniq_chip_init(ensoniq);\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, ensoniq, &ops)) < 0) {\r\nsnd_ensoniq_free(ensoniq);\r\nreturn err;\r\n}\r\nsnd_ensoniq_proc_init(ensoniq);\r\n*rensoniq = ensoniq;\r\nreturn 0;\r\n}\r\nstatic void snd_ensoniq_midi_interrupt(struct ensoniq * ensoniq)\r\n{\r\nstruct snd_rawmidi *rmidi = ensoniq->rmidi;\r\nunsigned char status, mask, byte;\r\nif (rmidi == NULL)\r\nreturn;\r\nspin_lock(&ensoniq->reg_lock);\r\nmask = ensoniq->uartm & ES_MODE_INPUT ? ES_RXRDY : 0;\r\nwhile (mask) {\r\nstatus = inb(ES_REG(ensoniq, UART_STATUS));\r\nif ((status & mask) == 0)\r\nbreak;\r\nbyte = inb(ES_REG(ensoniq, UART_DATA));\r\nsnd_rawmidi_receive(ensoniq->midi_input, &byte, 1);\r\n}\r\nspin_unlock(&ensoniq->reg_lock);\r\nspin_lock(&ensoniq->reg_lock);\r\nmask = ensoniq->uartm & ES_MODE_OUTPUT ? ES_TXRDY : 0;\r\nwhile (mask) {\r\nstatus = inb(ES_REG(ensoniq, UART_STATUS));\r\nif ((status & mask) == 0)\r\nbreak;\r\nif (snd_rawmidi_transmit(ensoniq->midi_output, &byte, 1) != 1) {\r\nensoniq->uartc &= ~ES_TXINTENM;\r\noutb(ensoniq->uartc, ES_REG(ensoniq, UART_CONTROL));\r\nmask &= ~ES_TXRDY;\r\n} else {\r\noutb(byte, ES_REG(ensoniq, UART_DATA));\r\n}\r\n}\r\nspin_unlock(&ensoniq->reg_lock);\r\n}\r\nstatic int snd_ensoniq_midi_input_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct ensoniq *ensoniq = substream->rmidi->private_data;\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nensoniq->uartm |= ES_MODE_INPUT;\r\nensoniq->midi_input = substream;\r\nif (!(ensoniq->uartm & ES_MODE_OUTPUT)) {\r\noutb(ES_CNTRL(3), ES_REG(ensoniq, UART_CONTROL));\r\noutb(ensoniq->uartc = 0, ES_REG(ensoniq, UART_CONTROL));\r\noutl(ensoniq->ctrl |= ES_UART_EN, ES_REG(ensoniq, CONTROL));\r\n}\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ensoniq_midi_input_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct ensoniq *ensoniq = substream->rmidi->private_data;\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nif (!(ensoniq->uartm & ES_MODE_OUTPUT)) {\r\noutb(ensoniq->uartc = 0, ES_REG(ensoniq, UART_CONTROL));\r\noutl(ensoniq->ctrl &= ~ES_UART_EN, ES_REG(ensoniq, CONTROL));\r\n} else {\r\noutb(ensoniq->uartc &= ~ES_RXINTEN, ES_REG(ensoniq, UART_CONTROL));\r\n}\r\nensoniq->midi_input = NULL;\r\nensoniq->uartm &= ~ES_MODE_INPUT;\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ensoniq_midi_output_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct ensoniq *ensoniq = substream->rmidi->private_data;\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nensoniq->uartm |= ES_MODE_OUTPUT;\r\nensoniq->midi_output = substream;\r\nif (!(ensoniq->uartm & ES_MODE_INPUT)) {\r\noutb(ES_CNTRL(3), ES_REG(ensoniq, UART_CONTROL));\r\noutb(ensoniq->uartc = 0, ES_REG(ensoniq, UART_CONTROL));\r\noutl(ensoniq->ctrl |= ES_UART_EN, ES_REG(ensoniq, CONTROL));\r\n}\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ensoniq_midi_output_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct ensoniq *ensoniq = substream->rmidi->private_data;\r\nspin_lock_irq(&ensoniq->reg_lock);\r\nif (!(ensoniq->uartm & ES_MODE_INPUT)) {\r\noutb(ensoniq->uartc = 0, ES_REG(ensoniq, UART_CONTROL));\r\noutl(ensoniq->ctrl &= ~ES_UART_EN, ES_REG(ensoniq, CONTROL));\r\n} else {\r\noutb(ensoniq->uartc &= ~ES_TXINTENM, ES_REG(ensoniq, UART_CONTROL));\r\n}\r\nensoniq->midi_output = NULL;\r\nensoniq->uartm &= ~ES_MODE_OUTPUT;\r\nspin_unlock_irq(&ensoniq->reg_lock);\r\nreturn 0;\r\n}\r\nstatic void snd_ensoniq_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nunsigned long flags;\r\nstruct ensoniq *ensoniq = substream->rmidi->private_data;\r\nint idx;\r\nspin_lock_irqsave(&ensoniq->reg_lock, flags);\r\nif (up) {\r\nif ((ensoniq->uartc & ES_RXINTEN) == 0) {\r\nfor (idx = 0; idx < 32; idx++)\r\ninb(ES_REG(ensoniq, UART_DATA));\r\nensoniq->uartc |= ES_RXINTEN;\r\noutb(ensoniq->uartc, ES_REG(ensoniq, UART_CONTROL));\r\n}\r\n} else {\r\nif (ensoniq->uartc & ES_RXINTEN) {\r\nensoniq->uartc &= ~ES_RXINTEN;\r\noutb(ensoniq->uartc, ES_REG(ensoniq, UART_CONTROL));\r\n}\r\n}\r\nspin_unlock_irqrestore(&ensoniq->reg_lock, flags);\r\n}\r\nstatic void snd_ensoniq_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nunsigned long flags;\r\nstruct ensoniq *ensoniq = substream->rmidi->private_data;\r\nunsigned char byte;\r\nspin_lock_irqsave(&ensoniq->reg_lock, flags);\r\nif (up) {\r\nif (ES_TXINTENI(ensoniq->uartc) == 0) {\r\nensoniq->uartc |= ES_TXINTENO(1);\r\nwhile (ES_TXINTENI(ensoniq->uartc) == 1 &&\r\n(inb(ES_REG(ensoniq, UART_STATUS)) & ES_TXRDY)) {\r\nif (snd_rawmidi_transmit(substream, &byte, 1) != 1) {\r\nensoniq->uartc &= ~ES_TXINTENM;\r\n} else {\r\noutb(byte, ES_REG(ensoniq, UART_DATA));\r\n}\r\n}\r\noutb(ensoniq->uartc, ES_REG(ensoniq, UART_CONTROL));\r\n}\r\n} else {\r\nif (ES_TXINTENI(ensoniq->uartc) == 1) {\r\nensoniq->uartc &= ~ES_TXINTENM;\r\noutb(ensoniq->uartc, ES_REG(ensoniq, UART_CONTROL));\r\n}\r\n}\r\nspin_unlock_irqrestore(&ensoniq->reg_lock, flags);\r\n}\r\nstatic int snd_ensoniq_midi(struct ensoniq *ensoniq, int device)\r\n{\r\nstruct snd_rawmidi *rmidi;\r\nint err;\r\nif ((err = snd_rawmidi_new(ensoniq->card, "ES1370/1", device, 1, 1, &rmidi)) < 0)\r\nreturn err;\r\nstrcpy(rmidi->name, CHIP_NAME);\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_ensoniq_midi_output);\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_ensoniq_midi_input);\r\nrmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT | SNDRV_RAWMIDI_INFO_INPUT |\r\nSNDRV_RAWMIDI_INFO_DUPLEX;\r\nrmidi->private_data = ensoniq;\r\nensoniq->rmidi = rmidi;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t snd_audiopci_interrupt(int irq, void *dev_id)\r\n{\r\nstruct ensoniq *ensoniq = dev_id;\r\nunsigned int status, sctrl;\r\nif (ensoniq == NULL)\r\nreturn IRQ_NONE;\r\nstatus = inl(ES_REG(ensoniq, STATUS));\r\nif (!(status & ES_INTR))\r\nreturn IRQ_NONE;\r\nspin_lock(&ensoniq->reg_lock);\r\nsctrl = ensoniq->sctrl;\r\nif (status & ES_DAC1)\r\nsctrl &= ~ES_P1_INT_EN;\r\nif (status & ES_DAC2)\r\nsctrl &= ~ES_P2_INT_EN;\r\nif (status & ES_ADC)\r\nsctrl &= ~ES_R1_INT_EN;\r\noutl(sctrl, ES_REG(ensoniq, SERIAL));\r\noutl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));\r\nspin_unlock(&ensoniq->reg_lock);\r\nif (status & ES_UART)\r\nsnd_ensoniq_midi_interrupt(ensoniq);\r\nif ((status & ES_DAC2) && ensoniq->playback2_substream)\r\nsnd_pcm_period_elapsed(ensoniq->playback2_substream);\r\nif ((status & ES_ADC) && ensoniq->capture_substream)\r\nsnd_pcm_period_elapsed(ensoniq->capture_substream);\r\nif ((status & ES_DAC1) && ensoniq->playback1_substream)\r\nsnd_pcm_period_elapsed(ensoniq->playback1_substream);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int snd_audiopci_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct ensoniq *ensoniq;\r\nint err, pcm_devs[2];\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\r\n0, &card);\r\nif (err < 0)\r\nreturn err;\r\nif ((err = snd_ensoniq_create(card, pci, &ensoniq)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\ncard->private_data = ensoniq;\r\npcm_devs[0] = 0; pcm_devs[1] = 1;\r\n#ifdef CHIP1370\r\nif ((err = snd_ensoniq_1370_mixer(ensoniq)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\n#endif\r\n#ifdef CHIP1371\r\nif ((err = snd_ensoniq_1371_mixer(ensoniq, spdif[dev], lineio[dev])) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\n#endif\r\nif ((err = snd_ensoniq_pcm(ensoniq, 0)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_ensoniq_pcm2(ensoniq, 1)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_ensoniq_midi(ensoniq, 0)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nsnd_ensoniq_create_gameport(ensoniq, dev);\r\nstrcpy(card->driver, DRIVER_NAME);\r\nstrcpy(card->shortname, "Ensoniq AudioPCI");\r\nsprintf(card->longname, "%s %s at 0x%lx, irq %i",\r\ncard->shortname,\r\ncard->driver,\r\nensoniq->port,\r\nensoniq->irq);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void snd_audiopci_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\n}
