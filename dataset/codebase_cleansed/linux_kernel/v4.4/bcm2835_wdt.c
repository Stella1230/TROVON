static int bcm2835_wdt_start(struct watchdog_device *wdog)\r\n{\r\nstruct bcm2835_wdt *wdt = watchdog_get_drvdata(wdog);\r\nuint32_t cur;\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdt->lock, flags);\r\nwritel_relaxed(PM_PASSWORD | (SECS_TO_WDOG_TICKS(wdog->timeout) &\r\nPM_WDOG_TIME_SET), wdt->base + PM_WDOG);\r\ncur = readl_relaxed(wdt->base + PM_RSTC);\r\nwritel_relaxed(PM_PASSWORD | (cur & PM_RSTC_WRCFG_CLR) |\r\nPM_RSTC_WRCFG_FULL_RESET, wdt->base + PM_RSTC);\r\nspin_unlock_irqrestore(&wdt->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bcm2835_wdt_stop(struct watchdog_device *wdog)\r\n{\r\nstruct bcm2835_wdt *wdt = watchdog_get_drvdata(wdog);\r\nwritel_relaxed(PM_PASSWORD | PM_RSTC_RESET, wdt->base + PM_RSTC);\r\ndev_info(wdog->dev, "Watchdog timer stopped");\r\nreturn 0;\r\n}\r\nstatic int bcm2835_wdt_set_timeout(struct watchdog_device *wdog, unsigned int t)\r\n{\r\nwdog->timeout = t;\r\nreturn 0;\r\n}\r\nstatic unsigned int bcm2835_wdt_get_timeleft(struct watchdog_device *wdog)\r\n{\r\nstruct bcm2835_wdt *wdt = watchdog_get_drvdata(wdog);\r\nuint32_t ret = readl_relaxed(wdt->base + PM_WDOG);\r\nreturn WDOG_TICKS_TO_SECS(ret & PM_WDOG_TIME_SET);\r\n}\r\nstatic int\r\nbcm2835_restart(struct notifier_block *this, unsigned long mode, void *cmd)\r\n{\r\nstruct bcm2835_wdt *wdt = container_of(this, struct bcm2835_wdt,\r\nrestart_handler);\r\nu32 val;\r\nwritel_relaxed(10 | PM_PASSWORD, wdt->base + PM_WDOG);\r\nval = readl_relaxed(wdt->base + PM_RSTC);\r\nval &= PM_RSTC_WRCFG_CLR;\r\nval |= PM_PASSWORD | PM_RSTC_WRCFG_FULL_RESET;\r\nwritel_relaxed(val, wdt->base + PM_RSTC);\r\nmdelay(1);\r\nreturn 0;\r\n}\r\nstatic void bcm2835_power_off(void)\r\n{\r\nstruct device_node *np =\r\nof_find_compatible_node(NULL, NULL, "brcm,bcm2835-pm-wdt");\r\nstruct platform_device *pdev = of_find_device_by_node(np);\r\nstruct bcm2835_wdt *wdt = platform_get_drvdata(pdev);\r\nu32 val;\r\nval = readl_relaxed(wdt->base + PM_RSTS);\r\nval |= PM_PASSWORD | PM_RSTS_RASPBERRYPI_HALT;\r\nwritel_relaxed(val, wdt->base + PM_RSTS);\r\nbcm2835_restart(&wdt->restart_handler, REBOOT_HARD, NULL);\r\n}\r\nstatic int bcm2835_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct bcm2835_wdt *wdt;\r\nint err;\r\nwdt = devm_kzalloc(dev, sizeof(struct bcm2835_wdt), GFP_KERNEL);\r\nif (!wdt)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, wdt);\r\nspin_lock_init(&wdt->lock);\r\nwdt->base = of_iomap(np, 0);\r\nif (!wdt->base) {\r\ndev_err(dev, "Failed to remap watchdog regs");\r\nreturn -ENODEV;\r\n}\r\nwatchdog_set_drvdata(&bcm2835_wdt_wdd, wdt);\r\nwatchdog_init_timeout(&bcm2835_wdt_wdd, heartbeat, dev);\r\nwatchdog_set_nowayout(&bcm2835_wdt_wdd, nowayout);\r\nbcm2835_wdt_wdd.parent = &pdev->dev;\r\nerr = watchdog_register_device(&bcm2835_wdt_wdd);\r\nif (err) {\r\ndev_err(dev, "Failed to register watchdog device");\r\niounmap(wdt->base);\r\nreturn err;\r\n}\r\nwdt->restart_handler.notifier_call = bcm2835_restart;\r\nwdt->restart_handler.priority = 128;\r\nregister_restart_handler(&wdt->restart_handler);\r\nif (pm_power_off == NULL)\r\npm_power_off = bcm2835_power_off;\r\ndev_info(dev, "Broadcom BCM2835 watchdog timer");\r\nreturn 0;\r\n}\r\nstatic int bcm2835_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct bcm2835_wdt *wdt = platform_get_drvdata(pdev);\r\nunregister_restart_handler(&wdt->restart_handler);\r\nif (pm_power_off == bcm2835_power_off)\r\npm_power_off = NULL;\r\nwatchdog_unregister_device(&bcm2835_wdt_wdd);\r\niounmap(wdt->base);\r\nreturn 0;\r\n}\r\nstatic void bcm2835_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nbcm2835_wdt_stop(&bcm2835_wdt_wdd);\r\n}
