static struct davinci_gpio_regs __iomem *gpio2regs(unsigned gpio)\r\n{\r\nvoid __iomem *ptr;\r\nif (gpio < 32 * 1)\r\nptr = gpio_base + 0x10;\r\nelse if (gpio < 32 * 2)\r\nptr = gpio_base + 0x38;\r\nelse if (gpio < 32 * 3)\r\nptr = gpio_base + 0x60;\r\nelse if (gpio < 32 * 4)\r\nptr = gpio_base + 0x88;\r\nelse if (gpio < 32 * 5)\r\nptr = gpio_base + 0xb0;\r\nelse\r\nptr = NULL;\r\nreturn ptr;\r\n}\r\nstatic inline struct davinci_gpio_regs __iomem *irq2regs(struct irq_data *d)\r\n{\r\nstruct davinci_gpio_regs __iomem *g;\r\ng = (__force struct davinci_gpio_regs __iomem *)irq_data_get_irq_chip_data(d);\r\nreturn g;\r\n}\r\nstatic inline int __davinci_direction(struct gpio_chip *chip,\r\nunsigned offset, bool out, int value)\r\n{\r\nstruct davinci_gpio_controller *d = chip2controller(chip);\r\nstruct davinci_gpio_regs __iomem *g = d->regs;\r\nunsigned long flags;\r\nu32 temp;\r\nu32 mask = 1 << offset;\r\nspin_lock_irqsave(&d->lock, flags);\r\ntemp = readl_relaxed(&g->dir);\r\nif (out) {\r\ntemp &= ~mask;\r\nwritel_relaxed(mask, value ? &g->set_data : &g->clr_data);\r\n} else {\r\ntemp |= mask;\r\n}\r\nwritel_relaxed(temp, &g->dir);\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int davinci_direction_in(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn __davinci_direction(chip, offset, false, 0);\r\n}\r\nstatic int\r\ndavinci_direction_out(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nreturn __davinci_direction(chip, offset, true, value);\r\n}\r\nstatic int davinci_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct davinci_gpio_controller *d = chip2controller(chip);\r\nstruct davinci_gpio_regs __iomem *g = d->regs;\r\nreturn (1 << offset) & readl_relaxed(&g->in_data);\r\n}\r\nstatic void\r\ndavinci_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct davinci_gpio_controller *d = chip2controller(chip);\r\nstruct davinci_gpio_regs __iomem *g = d->regs;\r\nwritel_relaxed((1 << offset), value ? &g->set_data : &g->clr_data);\r\n}\r\nstatic struct davinci_gpio_platform_data *\r\ndavinci_gpio_get_pdata(struct platform_device *pdev)\r\n{\r\nstruct device_node *dn = pdev->dev.of_node;\r\nstruct davinci_gpio_platform_data *pdata;\r\nint ret;\r\nu32 val;\r\nif (!IS_ENABLED(CONFIG_OF) || !pdev->dev.of_node)\r\nreturn pdev->dev.platform_data;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn NULL;\r\nret = of_property_read_u32(dn, "ti,ngpio", &val);\r\nif (ret)\r\ngoto of_err;\r\npdata->ngpio = val;\r\nret = of_property_read_u32(dn, "ti,davinci-gpio-unbanked", &val);\r\nif (ret)\r\ngoto of_err;\r\npdata->gpio_unbanked = val;\r\nreturn pdata;\r\nof_err:\r\ndev_err(&pdev->dev, "Populating pdata from DT failed: err %d\n", ret);\r\nreturn NULL;\r\n}\r\nstatic int davinci_gpio_of_xlate(struct gpio_chip *gc,\r\nconst struct of_phandle_args *gpiospec,\r\nu32 *flags)\r\n{\r\nstruct davinci_gpio_controller *chips = dev_get_drvdata(gc->dev);\r\nstruct davinci_gpio_platform_data *pdata = dev_get_platdata(gc->dev);\r\nif (gpiospec->args[0] > pdata->ngpio)\r\nreturn -EINVAL;\r\nif (gc != &chips[gpiospec->args[0] / 32].chip)\r\nreturn -EINVAL;\r\nif (flags)\r\n*flags = gpiospec->args[1];\r\nreturn gpiospec->args[0] % 32;\r\n}\r\nstatic int davinci_gpio_probe(struct platform_device *pdev)\r\n{\r\nint i, base;\r\nunsigned ngpio;\r\nstruct davinci_gpio_controller *chips;\r\nstruct davinci_gpio_platform_data *pdata;\r\nstruct davinci_gpio_regs __iomem *regs;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\npdata = davinci_gpio_get_pdata(pdev);\r\nif (!pdata) {\r\ndev_err(dev, "No platform data found\n");\r\nreturn -EINVAL;\r\n}\r\ndev->platform_data = pdata;\r\nngpio = pdata->ngpio;\r\nif (ngpio == 0) {\r\ndev_err(dev, "How many GPIOs?\n");\r\nreturn -EINVAL;\r\n}\r\nif (WARN_ON(ARCH_NR_GPIOS < ngpio))\r\nngpio = ARCH_NR_GPIOS;\r\nchips = devm_kzalloc(dev,\r\nngpio * sizeof(struct davinci_gpio_controller),\r\nGFP_KERNEL);\r\nif (!chips)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ngpio_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(gpio_base))\r\nreturn PTR_ERR(gpio_base);\r\nfor (i = 0, base = 0; base < ngpio; i++, base += 32) {\r\nchips[i].chip.label = "DaVinci";\r\nchips[i].chip.direction_input = davinci_direction_in;\r\nchips[i].chip.get = davinci_gpio_get;\r\nchips[i].chip.direction_output = davinci_direction_out;\r\nchips[i].chip.set = davinci_gpio_set;\r\nchips[i].chip.base = base;\r\nchips[i].chip.ngpio = ngpio - base;\r\nif (chips[i].chip.ngpio > 32)\r\nchips[i].chip.ngpio = 32;\r\n#ifdef CONFIG_OF_GPIO\r\nchips[i].chip.of_gpio_n_cells = 2;\r\nchips[i].chip.of_xlate = davinci_gpio_of_xlate;\r\nchips[i].chip.dev = dev;\r\nchips[i].chip.of_node = dev->of_node;\r\n#endif\r\nspin_lock_init(&chips[i].lock);\r\nregs = gpio2regs(base);\r\nchips[i].regs = regs;\r\nchips[i].set_data = &regs->set_data;\r\nchips[i].clr_data = &regs->clr_data;\r\nchips[i].in_data = &regs->in_data;\r\ngpiochip_add(&chips[i].chip);\r\n}\r\nplatform_set_drvdata(pdev, chips);\r\ndavinci_gpio_irq_setup(pdev);\r\nreturn 0;\r\n}\r\nstatic void gpio_irq_disable(struct irq_data *d)\r\n{\r\nstruct davinci_gpio_regs __iomem *g = irq2regs(d);\r\nu32 mask = (u32) irq_data_get_irq_handler_data(d);\r\nwritel_relaxed(mask, &g->clr_falling);\r\nwritel_relaxed(mask, &g->clr_rising);\r\n}\r\nstatic void gpio_irq_enable(struct irq_data *d)\r\n{\r\nstruct davinci_gpio_regs __iomem *g = irq2regs(d);\r\nu32 mask = (u32) irq_data_get_irq_handler_data(d);\r\nunsigned status = irqd_get_trigger_type(d);\r\nstatus &= IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING;\r\nif (!status)\r\nstatus = IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING;\r\nif (status & IRQ_TYPE_EDGE_FALLING)\r\nwritel_relaxed(mask, &g->set_falling);\r\nif (status & IRQ_TYPE_EDGE_RISING)\r\nwritel_relaxed(mask, &g->set_rising);\r\n}\r\nstatic int gpio_irq_type(struct irq_data *d, unsigned trigger)\r\n{\r\nif (trigger & ~(IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nunsigned int irq = irq_desc_get_irq(desc);\r\nstruct davinci_gpio_regs __iomem *g;\r\nu32 mask = 0xffff;\r\nstruct davinci_gpio_controller *d;\r\nd = (struct davinci_gpio_controller *)irq_desc_get_handler_data(desc);\r\ng = (struct davinci_gpio_regs __iomem *)d->regs;\r\nif (irq & 1)\r\nmask <<= 16;\r\nchained_irq_enter(irq_desc_get_chip(desc), desc);\r\nwhile (1) {\r\nu32 status;\r\nint bit;\r\nstatus = readl_relaxed(&g->intstat) & mask;\r\nif (!status)\r\nbreak;\r\nwritel_relaxed(status, &g->intstat);\r\nwhile (status) {\r\nbit = __ffs(status);\r\nstatus &= ~BIT(bit);\r\ngeneric_handle_irq(\r\nirq_find_mapping(d->irq_domain,\r\nd->chip.base + bit));\r\n}\r\n}\r\nchained_irq_exit(irq_desc_get_chip(desc), desc);\r\n}\r\nstatic int gpio_to_irq_banked(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct davinci_gpio_controller *d = chip2controller(chip);\r\nif (d->irq_domain)\r\nreturn irq_create_mapping(d->irq_domain, d->chip.base + offset);\r\nelse\r\nreturn -ENXIO;\r\n}\r\nstatic int gpio_to_irq_unbanked(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct davinci_gpio_controller *d = chip2controller(chip);\r\nif (offset < d->gpio_unbanked)\r\nreturn d->gpio_irq + offset;\r\nelse\r\nreturn -ENODEV;\r\n}\r\nstatic int gpio_irq_type_unbanked(struct irq_data *data, unsigned trigger)\r\n{\r\nstruct davinci_gpio_controller *d;\r\nstruct davinci_gpio_regs __iomem *g;\r\nu32 mask;\r\nd = (struct davinci_gpio_controller *)irq_data_get_irq_handler_data(data);\r\ng = (struct davinci_gpio_regs __iomem *)d->regs;\r\nmask = __gpio_mask(data->irq - d->gpio_irq);\r\nif (trigger & ~(IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\r\nreturn -EINVAL;\r\nwritel_relaxed(mask, (trigger & IRQ_TYPE_EDGE_FALLING)\r\n? &g->set_falling : &g->clr_falling);\r\nwritel_relaxed(mask, (trigger & IRQ_TYPE_EDGE_RISING)\r\n? &g->set_rising : &g->clr_rising);\r\nreturn 0;\r\n}\r\nstatic int\r\ndavinci_gpio_irq_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct davinci_gpio_regs __iomem *g = gpio2regs(hw);\r\nirq_set_chip_and_handler_name(irq, &gpio_irqchip, handle_simple_irq,\r\n"davinci_gpio");\r\nirq_set_irq_type(irq, IRQ_TYPE_NONE);\r\nirq_set_chip_data(irq, (__force void *)g);\r\nirq_set_handler_data(irq, (void *)__gpio_mask(hw));\r\nreturn 0;\r\n}\r\nstatic struct irq_chip *davinci_gpio_get_irq_chip(unsigned int irq)\r\n{\r\nstatic struct irq_chip_type gpio_unbanked;\r\ngpio_unbanked = *container_of(irq_get_chip(irq),\r\nstruct irq_chip_type, chip);\r\nreturn &gpio_unbanked.chip;\r\n}\r\nstatic struct irq_chip *keystone_gpio_get_irq_chip(unsigned int irq)\r\n{\r\nstatic struct irq_chip gpio_unbanked;\r\ngpio_unbanked = *irq_get_chip(irq);\r\nreturn &gpio_unbanked;\r\n}\r\nstatic int davinci_gpio_irq_setup(struct platform_device *pdev)\r\n{\r\nunsigned gpio, bank;\r\nint irq;\r\nstruct clk *clk;\r\nu32 binten = 0;\r\nunsigned ngpio, bank_irq;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct davinci_gpio_controller *chips = platform_get_drvdata(pdev);\r\nstruct davinci_gpio_platform_data *pdata = dev->platform_data;\r\nstruct davinci_gpio_regs __iomem *g;\r\nstruct irq_domain *irq_domain = NULL;\r\nconst struct of_device_id *match;\r\nstruct irq_chip *irq_chip;\r\ngpio_get_irq_chip_cb_t gpio_get_irq_chip;\r\ngpio_get_irq_chip = davinci_gpio_get_irq_chip;\r\nmatch = of_match_device(of_match_ptr(davinci_gpio_ids),\r\ndev);\r\nif (match)\r\ngpio_get_irq_chip = (gpio_get_irq_chip_cb_t)match->data;\r\nngpio = pdata->ngpio;\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\ndev_err(dev, "Invalid IRQ resource\n");\r\nreturn -EBUSY;\r\n}\r\nbank_irq = res->start;\r\nif (!bank_irq) {\r\ndev_err(dev, "Invalid IRQ resource\n");\r\nreturn -ENODEV;\r\n}\r\nclk = devm_clk_get(dev, "gpio");\r\nif (IS_ERR(clk)) {\r\nprintk(KERN_ERR "Error %ld getting gpio clock?\n",\r\nPTR_ERR(clk));\r\nreturn PTR_ERR(clk);\r\n}\r\nclk_prepare_enable(clk);\r\nif (!pdata->gpio_unbanked) {\r\nirq = irq_alloc_descs(-1, 0, ngpio, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "Couldn't allocate IRQ numbers\n");\r\nreturn irq;\r\n}\r\nirq_domain = irq_domain_add_legacy(NULL, ngpio, irq, 0,\r\n&davinci_gpio_irq_ops,\r\nchips);\r\nif (!irq_domain) {\r\ndev_err(dev, "Couldn't register an IRQ domain\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nfor (gpio = 0, bank = 0; gpio < ngpio; bank++, gpio += 32) {\r\nchips[bank].chip.to_irq = gpio_to_irq_banked;\r\nchips[bank].irq_domain = irq_domain;\r\n}\r\nif (pdata->gpio_unbanked) {\r\nchips[0].chip.to_irq = gpio_to_irq_unbanked;\r\nchips[0].gpio_irq = bank_irq;\r\nchips[0].gpio_unbanked = pdata->gpio_unbanked;\r\nbinten = GENMASK(pdata->gpio_unbanked / 16, 0);\r\nirq = bank_irq;\r\nirq_chip = gpio_get_irq_chip(irq);\r\nirq_chip->name = "GPIO-AINTC";\r\nirq_chip->irq_set_type = gpio_irq_type_unbanked;\r\ng = gpio2regs(0);\r\nwritel_relaxed(~0, &g->set_falling);\r\nwritel_relaxed(~0, &g->set_rising);\r\nfor (gpio = 0; gpio < pdata->gpio_unbanked; gpio++, irq++) {\r\nirq_set_chip(irq, irq_chip);\r\nirq_set_handler_data(irq, &chips[gpio / 32]);\r\nirq_set_status_flags(irq, IRQ_TYPE_EDGE_BOTH);\r\n}\r\ngoto done;\r\n}\r\nfor (gpio = 0, bank = 0; gpio < ngpio; bank++, bank_irq++, gpio += 16) {\r\ng = gpio2regs(gpio);\r\nwritel_relaxed(~0, &g->clr_falling);\r\nwritel_relaxed(~0, &g->clr_rising);\r\nirq_set_chained_handler_and_data(bank_irq, gpio_irq_handler,\r\n&chips[gpio / 32]);\r\nbinten |= BIT(bank);\r\n}\r\ndone:\r\nwritel_relaxed(binten, gpio_base + BINTEN);\r\nreturn 0;\r\n}\r\nstatic int __init davinci_gpio_drv_reg(void)\r\n{\r\nreturn platform_driver_register(&davinci_gpio_driver);\r\n}
