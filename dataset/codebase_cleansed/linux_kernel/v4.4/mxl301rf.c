static struct mxl301rf_state *cfg_to_state(struct mxl301rf_config *c)\r\n{\r\nreturn container_of(c, struct mxl301rf_state, cfg);\r\n}\r\nstatic int raw_write(struct mxl301rf_state *state, const u8 *buf, int len)\r\n{\r\nint ret;\r\nret = i2c_master_send(state->i2c, buf, len);\r\nif (ret >= 0 && ret < len)\r\nret = -EIO;\r\nreturn (ret == len) ? 0 : ret;\r\n}\r\nstatic int reg_write(struct mxl301rf_state *state, u8 reg, u8 val)\r\n{\r\nu8 buf[2] = { reg, val };\r\nreturn raw_write(state, buf, 2);\r\n}\r\nstatic int reg_read(struct mxl301rf_state *state, u8 reg, u8 *val)\r\n{\r\nu8 wbuf[2] = { 0xfb, reg };\r\nint ret;\r\nret = raw_write(state, wbuf, sizeof(wbuf));\r\nif (ret == 0)\r\nret = i2c_master_recv(state->i2c, val, 1);\r\nif (ret >= 0 && ret < 1)\r\nret = -EIO;\r\nreturn (ret == 1) ? 0 : ret;\r\n}\r\nstatic int mxl301rf_get_rf_strength(struct dvb_frontend *fe, u16 *out)\r\n{\r\nstruct mxl301rf_state *state;\r\nint ret;\r\nu8 rf_in1, rf_in2, rf_off1, rf_off2;\r\nu16 rf_in, rf_off;\r\ns64 level;\r\nstruct dtv_fe_stats *rssi;\r\nrssi = &fe->dtv_property_cache.strength;\r\nrssi->len = 1;\r\nrssi->stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n*out = 0;\r\nstate = fe->tuner_priv;\r\nret = reg_write(state, 0x14, 0x01);\r\nif (ret < 0)\r\nreturn ret;\r\nusleep_range(1000, 2000);\r\nret = reg_read(state, 0x18, &rf_in1);\r\nif (ret == 0)\r\nret = reg_read(state, 0x19, &rf_in2);\r\nif (ret == 0)\r\nret = reg_read(state, 0xd6, &rf_off1);\r\nif (ret == 0)\r\nret = reg_read(state, 0xd7, &rf_off2);\r\nif (ret != 0)\r\nreturn ret;\r\nrf_in = (rf_in2 & 0x07) << 8 | rf_in1;\r\nrf_off = (rf_off2 & 0x0f) << 5 | (rf_off1 >> 3);\r\nlevel = rf_in - rf_off - (113 << 3);\r\nlevel = level * 1000 / 8;\r\nrssi->stat[0].svalue = level;\r\nrssi->stat[0].scale = FE_SCALE_DECIBEL;\r\n*out = (rf_in - rf_off + (1 << 9) - 1) * 100 / ((5 << 9) - 2);\r\nreturn 0;\r\n}\r\nstatic int mxl301rf_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct reg_val tune0[] = {\r\n{ 0x13, 0x00 },\r\n{ 0x3b, 0xc0 },\r\n{ 0x3b, 0x80 },\r\n{ 0x10, 0x95 },\r\n{ 0x1a, 0x05 },\r\n{ 0x61, 0x00 },\r\n{ 0x62, 0xa0 }\r\n};\r\nstruct reg_val tune1[] = {\r\n{ 0x11, 0x40 },\r\n{ 0x12, 0x0e },\r\n{ 0x13, 0x01 }\r\n};\r\nstruct mxl301rf_state *state;\r\nu32 freq;\r\nu16 f;\r\nu32 tmp, div;\r\nint i, ret;\r\nstate = fe->tuner_priv;\r\nfreq = fe->dtv_property_cache.frequency;\r\nfor (i = 0; i < ARRAY_SIZE(shf_tab); i++) {\r\nif (freq >= (shf_tab[i].freq - shf_tab[i].ofst_th) * 1000 &&\r\nfreq <= (shf_tab[i].freq + shf_tab[i].ofst_th) * 1000) {\r\ntune0[5].val = shf_tab[i].shf_val;\r\ntune0[6].val = 0xa0 | shf_tab[i].shf_dir;\r\nbreak;\r\n}\r\n}\r\nret = raw_write(state, (u8 *) tune0, sizeof(tune0));\r\nif (ret < 0)\r\ngoto failed;\r\nusleep_range(3000, 4000);\r\nf = freq / 1000000;\r\ntmp = freq % 1000000;\r\ndiv = 1000000;\r\nfor (i = 0; i < 6; i++) {\r\nf <<= 1;\r\ndiv >>= 1;\r\nif (tmp > div) {\r\ntmp -= div;\r\nf |= 1;\r\n}\r\n}\r\nif (tmp > 7812)\r\nf++;\r\ntune1[0].val = f & 0xff;\r\ntune1[1].val = f >> 8;\r\nret = raw_write(state, (u8 *) tune1, sizeof(tune1));\r\nif (ret < 0)\r\ngoto failed;\r\nmsleep(31);\r\nret = reg_write(state, 0x1a, 0x0d);\r\nif (ret < 0)\r\ngoto failed;\r\nret = raw_write(state, (u8 *) set_idac, sizeof(set_idac));\r\nif (ret < 0)\r\ngoto failed;\r\nreturn 0;\r\nfailed:\r\ndev_warn(&state->i2c->dev, "(%s) failed. [adap%d-fe%d]\n",\r\n__func__, fe->dvb->num, fe->id);\r\nreturn ret;\r\n}\r\nstatic int mxl301rf_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct mxl301rf_state *state;\r\nint ret;\r\nstate = fe->tuner_priv;\r\nret = raw_write(state, (u8 *)standby_data, sizeof(standby_data));\r\nif (ret < 0)\r\ndev_warn(&state->i2c->dev, "(%s) failed. [adap%d-fe%d]\n",\r\n__func__, fe->dvb->num, fe->id);\r\nreturn ret;\r\n}\r\nstatic int mxl301rf_init(struct dvb_frontend *fe)\r\n{\r\nstruct mxl301rf_state *state;\r\nint ret;\r\nstate = fe->tuner_priv;\r\nret = reg_write(state, 0x01, 0x01);\r\nif (ret < 0) {\r\ndev_warn(&state->i2c->dev, "(%s) failed. [adap%d-fe%d]\n",\r\n__func__, fe->dvb->num, fe->id);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxl301rf_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct mxl301rf_state *state;\r\nstruct mxl301rf_config *cfg;\r\nstruct dvb_frontend *fe;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nstate->i2c = client;\r\ncfg = client->dev.platform_data;\r\nmemcpy(&state->cfg, cfg, sizeof(state->cfg));\r\nfe = cfg->fe;\r\nfe->tuner_priv = state;\r\nmemcpy(&fe->ops.tuner_ops, &mxl301rf_ops, sizeof(mxl301rf_ops));\r\ni2c_set_clientdata(client, &state->cfg);\r\ndev_info(&client->dev, "MaxLinear MxL301RF attached.\n");\r\nreturn 0;\r\n}\r\nstatic int mxl301rf_remove(struct i2c_client *client)\r\n{\r\nstruct mxl301rf_state *state;\r\nstate = cfg_to_state(i2c_get_clientdata(client));\r\nstate->cfg.fe->tuner_priv = NULL;\r\nkfree(state);\r\nreturn 0;\r\n}
