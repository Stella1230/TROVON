static int radeon_atom_set_enc_offset(int id)\r\n{\r\nstatic const int offsets[] = { EVERGREEN_CRTC0_REGISTER_OFFSET,\r\nEVERGREEN_CRTC1_REGISTER_OFFSET,\r\nEVERGREEN_CRTC2_REGISTER_OFFSET,\r\nEVERGREEN_CRTC3_REGISTER_OFFSET,\r\nEVERGREEN_CRTC4_REGISTER_OFFSET,\r\nEVERGREEN_CRTC5_REGISTER_OFFSET,\r\n0x13830 - 0x7030 };\r\nreturn offsets[id];\r\n}\r\nstatic int radeon_dp_mst_set_be_cntl(struct radeon_encoder *primary,\r\nstruct radeon_encoder_mst *mst_enc,\r\nenum radeon_hpd_id hpd, bool enable)\r\n{\r\nstruct drm_device *dev = primary->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t reg;\r\nint retries = 0;\r\nuint32_t temp;\r\nreg = RREG32(NI_DIG_BE_CNTL + primary->offset);\r\nreg &= ~NI_DIG_FE_DIG_MODE(7);\r\nreg |= NI_DIG_FE_DIG_MODE(NI_DIG_MODE_DP_MST);\r\nif (enable)\r\nreg |= NI_DIG_FE_SOURCE_SELECT(1 << mst_enc->fe);\r\nelse\r\nreg &= ~NI_DIG_FE_SOURCE_SELECT(1 << mst_enc->fe);\r\nreg |= NI_DIG_HPD_SELECT(hpd);\r\nDRM_DEBUG_KMS("writing 0x%08x 0x%08x\n", NI_DIG_BE_CNTL + primary->offset, reg);\r\nWREG32(NI_DIG_BE_CNTL + primary->offset, reg);\r\nif (enable) {\r\nuint32_t offset = radeon_atom_set_enc_offset(mst_enc->fe);\r\ndo {\r\ntemp = RREG32(NI_DIG_FE_CNTL + offset);\r\n} while ((temp & NI_DIG_SYMCLK_FE_ON) && retries++ < 10000);\r\nif (retries == 10000)\r\nDRM_ERROR("timed out waiting for FE %d %d\n", primary->offset, mst_enc->fe);\r\n}\r\nreturn 0;\r\n}\r\nstatic int radeon_dp_mst_set_stream_attrib(struct radeon_encoder *primary,\r\nint stream_number,\r\nint fe,\r\nint slots)\r\n{\r\nstruct drm_device *dev = primary->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nu32 temp, val;\r\nint retries = 0;\r\nint satreg, satidx;\r\nsatreg = stream_number >> 1;\r\nsatidx = stream_number & 1;\r\ntemp = RREG32(NI_DP_MSE_SAT0 + satreg + primary->offset);\r\nval = NI_DP_MSE_SAT_SLOT_COUNT0(slots) | NI_DP_MSE_SAT_SRC0(fe);\r\nval <<= (16 * satidx);\r\ntemp &= ~(0xffff << (16 * satidx));\r\ntemp |= val;\r\nDRM_DEBUG_KMS("writing 0x%08x 0x%08x\n", NI_DP_MSE_SAT0 + satreg + primary->offset, temp);\r\nWREG32(NI_DP_MSE_SAT0 + satreg + primary->offset, temp);\r\nWREG32(NI_DP_MSE_SAT_UPDATE + primary->offset, 1);\r\ndo {\r\ntemp = RREG32(NI_DP_MSE_SAT_UPDATE + primary->offset);\r\n} while ((temp & 0x1) && retries++ < 10000);\r\nif (retries == 10000)\r\nDRM_ERROR("timed out waitin for SAT update %d\n", primary->offset);\r\nreturn 0;\r\n}\r\nstatic int radeon_dp_mst_update_stream_attribs(struct radeon_connector *mst_conn,\r\nstruct radeon_encoder *primary)\r\n{\r\nstruct drm_device *dev = mst_conn->base.dev;\r\nstruct stream_attribs new_attribs[6];\r\nint i;\r\nint idx = 0;\r\nstruct radeon_connector *radeon_connector;\r\nstruct drm_connector *connector;\r\nmemset(new_attribs, 0, sizeof(new_attribs));\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nstruct radeon_encoder *subenc;\r\nstruct radeon_encoder_mst *mst_enc;\r\nradeon_connector = to_radeon_connector(connector);\r\nif (!radeon_connector->is_mst_connector)\r\ncontinue;\r\nif (radeon_connector->mst_port != mst_conn)\r\ncontinue;\r\nsubenc = radeon_connector->mst_encoder;\r\nmst_enc = subenc->enc_priv;\r\nif (!mst_enc->enc_active)\r\ncontinue;\r\nnew_attribs[idx].fe = mst_enc->fe;\r\nnew_attribs[idx].slots = drm_dp_mst_get_vcpi_slots(&mst_conn->mst_mgr, mst_enc->port);\r\nidx++;\r\n}\r\nfor (i = 0; i < idx; i++) {\r\nif (new_attribs[i].fe != mst_conn->cur_stream_attribs[i].fe ||\r\nnew_attribs[i].slots != mst_conn->cur_stream_attribs[i].slots) {\r\nradeon_dp_mst_set_stream_attrib(primary, i, new_attribs[i].fe, new_attribs[i].slots);\r\nmst_conn->cur_stream_attribs[i].fe = new_attribs[i].fe;\r\nmst_conn->cur_stream_attribs[i].slots = new_attribs[i].slots;\r\n}\r\n}\r\nfor (i = idx; i < mst_conn->enabled_attribs; i++) {\r\nradeon_dp_mst_set_stream_attrib(primary, i, 0, 0);\r\nmst_conn->cur_stream_attribs[i].fe = 0;\r\nmst_conn->cur_stream_attribs[i].slots = 0;\r\n}\r\nmst_conn->enabled_attribs = idx;\r\nreturn 0;\r\n}\r\nstatic int radeon_dp_mst_set_vcp_size(struct radeon_encoder *mst, uint32_t x, uint32_t y)\r\n{\r\nstruct drm_device *dev = mst->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder_mst *mst_enc = mst->enc_priv;\r\nuint32_t val, temp;\r\nuint32_t offset = radeon_atom_set_enc_offset(mst_enc->fe);\r\nint retries = 0;\r\nval = NI_DP_MSE_RATE_X(x) | NI_DP_MSE_RATE_Y(y);\r\nWREG32(NI_DP_MSE_RATE_CNTL + offset, val);\r\ndo {\r\ntemp = RREG32(NI_DP_MSE_RATE_UPDATE + offset);\r\n} while ((temp & 0x1) && (retries++ < 10000));\r\nif (retries >= 10000)\r\nDRM_ERROR("timed out wait for rate cntl %d\n", mst_enc->fe);\r\nreturn 0;\r\n}\r\nstatic int radeon_dp_mst_get_ddc_modes(struct drm_connector *connector)\r\n{\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct radeon_connector *master = radeon_connector->mst_port;\r\nstruct edid *edid;\r\nint ret = 0;\r\nedid = drm_dp_mst_get_edid(connector, &master->mst_mgr, radeon_connector->port);\r\nradeon_connector->edid = edid;\r\nDRM_DEBUG_KMS("edid retrieved %p\n", edid);\r\nif (radeon_connector->edid) {\r\ndrm_mode_connector_update_edid_property(&radeon_connector->base, radeon_connector->edid);\r\nret = drm_add_edid_modes(&radeon_connector->base, radeon_connector->edid);\r\ndrm_edid_to_eld(&radeon_connector->base, radeon_connector->edid);\r\nreturn ret;\r\n}\r\ndrm_mode_connector_update_edid_property(&radeon_connector->base, NULL);\r\nreturn ret;\r\n}\r\nstatic int radeon_dp_mst_get_modes(struct drm_connector *connector)\r\n{\r\nreturn radeon_dp_mst_get_ddc_modes(connector);\r\n}\r\nstatic enum drm_mode_status\r\nradeon_dp_mst_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nif (mode->clock < 10000)\r\nreturn MODE_CLOCK_LOW;\r\nif (mode->flags & DRM_MODE_FLAG_DBLCLK)\r\nreturn MODE_H_ILLEGAL;\r\nreturn MODE_OK;\r\n}\r\nstruct drm_encoder *radeon_mst_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nreturn &radeon_connector->mst_encoder->base;\r\n}\r\nstatic enum drm_connector_status\r\nradeon_dp_mst_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct radeon_connector *master = radeon_connector->mst_port;\r\nreturn drm_dp_mst_detect_port(connector, &master->mst_mgr, radeon_connector->port);\r\n}\r\nstatic void\r\nradeon_dp_mst_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct radeon_encoder *radeon_encoder = radeon_connector->mst_encoder;\r\ndrm_encoder_cleanup(&radeon_encoder->base);\r\nkfree(radeon_encoder);\r\ndrm_connector_cleanup(connector);\r\nkfree(radeon_connector);\r\n}\r\nstatic int radeon_connector_dpms(struct drm_connector *connector, int mode)\r\n{\r\nDRM_DEBUG_KMS("\n");\r\nreturn 0;\r\n}\r\nstatic struct drm_connector *radeon_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,\r\nstruct drm_dp_mst_port *port,\r\nconst char *pathprop)\r\n{\r\nstruct radeon_connector *master = container_of(mgr, struct radeon_connector, mst_mgr);\r\nstruct drm_device *dev = master->base.dev;\r\nstruct radeon_connector *radeon_connector;\r\nstruct drm_connector *connector;\r\nradeon_connector = kzalloc(sizeof(*radeon_connector), GFP_KERNEL);\r\nif (!radeon_connector)\r\nreturn NULL;\r\nradeon_connector->is_mst_connector = true;\r\nconnector = &radeon_connector->base;\r\nradeon_connector->port = port;\r\nradeon_connector->mst_port = master;\r\nDRM_DEBUG_KMS("\n");\r\ndrm_connector_init(dev, connector, &radeon_dp_mst_connector_funcs, DRM_MODE_CONNECTOR_DisplayPort);\r\ndrm_connector_helper_add(connector, &radeon_dp_mst_connector_helper_funcs);\r\nradeon_connector->mst_encoder = radeon_dp_create_fake_mst_encoder(master);\r\ndrm_object_attach_property(&connector->base, dev->mode_config.path_property, 0);\r\ndrm_object_attach_property(&connector->base, dev->mode_config.tile_property, 0);\r\ndrm_mode_connector_set_path_property(connector, pathprop);\r\nreturn connector;\r\n}\r\nstatic void radeon_dp_register_mst_connector(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\ndrm_modeset_lock_all(dev);\r\nradeon_fb_add_connector(rdev, connector);\r\ndrm_modeset_unlock_all(dev);\r\ndrm_connector_register(connector);\r\n}\r\nstatic void radeon_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,\r\nstruct drm_connector *connector)\r\n{\r\nstruct radeon_connector *master = container_of(mgr, struct radeon_connector, mst_mgr);\r\nstruct drm_device *dev = master->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\ndrm_connector_unregister(connector);\r\ndrm_modeset_lock_all(dev);\r\nradeon_fb_remove_connector(rdev, connector);\r\ndrm_connector_cleanup(connector);\r\ndrm_modeset_unlock_all(dev);\r\nkfree(connector);\r\nDRM_DEBUG_KMS("\n");\r\n}\r\nstatic void radeon_dp_mst_hotplug(struct drm_dp_mst_topology_mgr *mgr)\r\n{\r\nstruct radeon_connector *master = container_of(mgr, struct radeon_connector, mst_mgr);\r\nstruct drm_device *dev = master->base.dev;\r\ndrm_kms_helper_hotplug_event(dev);\r\n}\r\nstruct radeon_connector *radeon_mst_find_connector(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_connector *connector;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nif (!connector->encoder)\r\ncontinue;\r\nif (!radeon_connector->is_mst_connector)\r\ncontinue;\r\nDRM_DEBUG_KMS("checking %p vs %p\n", connector->encoder, encoder);\r\nif (connector->encoder == encoder)\r\nreturn radeon_connector;\r\n}\r\nreturn NULL;\r\n}\r\nvoid radeon_dp_mst_prepare_pll(struct drm_crtc *crtc, struct drm_display_mode *mode)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(radeon_crtc->encoder);\r\nstruct radeon_encoder_mst *mst_enc = radeon_encoder->enc_priv;\r\nstruct radeon_connector *radeon_connector = radeon_mst_find_connector(&radeon_encoder->base);\r\nint dp_clock;\r\nstruct radeon_connector_atom_dig *dig_connector = mst_enc->connector->con_priv;\r\nif (radeon_connector) {\r\nradeon_connector->pixelclock_for_modeset = mode->clock;\r\nif (radeon_connector->base.display_info.bpc)\r\nradeon_crtc->bpc = radeon_connector->base.display_info.bpc;\r\nelse\r\nradeon_crtc->bpc = 8;\r\n}\r\nDRM_DEBUG_KMS("dp_clock %p %d\n", dig_connector, dig_connector->dp_clock);\r\ndp_clock = dig_connector->dp_clock;\r\nradeon_crtc->ss_enabled =\r\nradeon_atombios_get_asic_ss_info(rdev, &radeon_crtc->ss,\r\nASIC_INTERNAL_SS_ON_DP,\r\ndp_clock);\r\n}\r\nstatic void\r\nradeon_mst_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder, *primary;\r\nstruct radeon_encoder_mst *mst_enc;\r\nstruct radeon_encoder_atom_dig *dig_enc;\r\nstruct radeon_connector *radeon_connector;\r\nstruct drm_crtc *crtc;\r\nstruct radeon_crtc *radeon_crtc;\r\nint ret, slots;\r\nif (!ASIC_IS_DCE5(rdev)) {\r\nDRM_ERROR("got mst dpms on non-DCE5\n");\r\nreturn;\r\n}\r\nradeon_connector = radeon_mst_find_connector(encoder);\r\nif (!radeon_connector)\r\nreturn;\r\nradeon_encoder = to_radeon_encoder(encoder);\r\nmst_enc = radeon_encoder->enc_priv;\r\nprimary = mst_enc->primary;\r\ndig_enc = primary->enc_priv;\r\ncrtc = encoder->crtc;\r\nDRM_DEBUG_KMS("got connector %d\n", dig_enc->active_mst_links);\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\ndig_enc->active_mst_links++;\r\nradeon_crtc = to_radeon_crtc(crtc);\r\nif (dig_enc->active_mst_links == 1) {\r\nmst_enc->fe = dig_enc->dig_encoder;\r\nmst_enc->fe_from_be = true;\r\natombios_set_mst_encoder_crtc_source(encoder, mst_enc->fe);\r\natombios_dig_encoder_setup(&primary->base, ATOM_ENCODER_CMD_SETUP, 0);\r\natombios_dig_transmitter_setup2(&primary->base, ATOM_TRANSMITTER_ACTION_ENABLE,\r\n0, 0, dig_enc->dig_encoder);\r\nif (radeon_dp_needs_link_train(mst_enc->connector) ||\r\ndig_enc->active_mst_links == 1) {\r\nradeon_dp_link_train(&primary->base, &mst_enc->connector->base);\r\n}\r\n} else {\r\nmst_enc->fe = radeon_atom_pick_dig_encoder(encoder, radeon_crtc->crtc_id);\r\nif (mst_enc->fe == -1)\r\nDRM_ERROR("failed to get frontend for dig encoder\n");\r\nmst_enc->fe_from_be = false;\r\natombios_set_mst_encoder_crtc_source(encoder, mst_enc->fe);\r\n}\r\nDRM_DEBUG_KMS("dig encoder is %d %d %d\n", dig_enc->dig_encoder,\r\ndig_enc->linkb, radeon_crtc->crtc_id);\r\nret = drm_dp_mst_allocate_vcpi(&radeon_connector->mst_port->mst_mgr,\r\nradeon_connector->port,\r\nmst_enc->pbn, &slots);\r\nret = drm_dp_update_payload_part1(&radeon_connector->mst_port->mst_mgr);\r\nradeon_dp_mst_set_be_cntl(primary, mst_enc,\r\nradeon_connector->mst_port->hpd.hpd, true);\r\nmst_enc->enc_active = true;\r\nradeon_dp_mst_update_stream_attribs(radeon_connector->mst_port, primary);\r\nradeon_dp_mst_set_vcp_size(radeon_encoder, slots, 0);\r\natombios_dig_encoder_setup2(&primary->base, ATOM_ENCODER_CMD_DP_VIDEO_ON, 0,\r\nmst_enc->fe);\r\nret = drm_dp_check_act_status(&radeon_connector->mst_port->mst_mgr);\r\nret = drm_dp_update_payload_part2(&radeon_connector->mst_port->mst_mgr);\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ncase DRM_MODE_DPMS_OFF:\r\nDRM_ERROR("DPMS OFF %d\n", dig_enc->active_mst_links);\r\nif (!mst_enc->enc_active)\r\nreturn;\r\ndrm_dp_mst_reset_vcpi_slots(&radeon_connector->mst_port->mst_mgr, mst_enc->port);\r\nret = drm_dp_update_payload_part1(&radeon_connector->mst_port->mst_mgr);\r\ndrm_dp_check_act_status(&radeon_connector->mst_port->mst_mgr);\r\ndrm_dp_update_payload_part2(&radeon_connector->mst_port->mst_mgr);\r\ndrm_dp_mst_deallocate_vcpi(&radeon_connector->mst_port->mst_mgr, mst_enc->port);\r\nmst_enc->enc_active = false;\r\nradeon_dp_mst_update_stream_attribs(radeon_connector->mst_port, primary);\r\nradeon_dp_mst_set_be_cntl(primary, mst_enc,\r\nradeon_connector->mst_port->hpd.hpd, false);\r\natombios_dig_encoder_setup2(&primary->base, ATOM_ENCODER_CMD_DP_VIDEO_OFF, 0,\r\nmst_enc->fe);\r\nif (!mst_enc->fe_from_be)\r\nradeon_atom_release_dig_encoder(rdev, mst_enc->fe);\r\nmst_enc->fe_from_be = false;\r\ndig_enc->active_mst_links--;\r\nif (dig_enc->active_mst_links == 0) {\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic bool radeon_mst_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct radeon_encoder_mst *mst_enc;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nint bpp = 24;\r\nmst_enc = radeon_encoder->enc_priv;\r\nmst_enc->pbn = drm_dp_calc_pbn_mode(adjusted_mode->clock, bpp);\r\nmst_enc->primary->active_device = mst_enc->primary->devices & mst_enc->connector->devices;\r\nDRM_DEBUG_KMS("setting active device to %08x from %08x %08x for encoder %d\n",\r\nmst_enc->primary->active_device, mst_enc->primary->devices,\r\nmst_enc->connector->devices, mst_enc->primary->base.encoder_type);\r\ndrm_mode_set_crtcinfo(adjusted_mode, 0);\r\n{\r\nstruct radeon_connector_atom_dig *dig_connector;\r\ndig_connector = mst_enc->connector->con_priv;\r\ndig_connector->dp_lane_count = drm_dp_max_lane_count(dig_connector->dpcd);\r\ndig_connector->dp_clock = radeon_dp_get_max_link_rate(&mst_enc->connector->base,\r\ndig_connector->dpcd);\r\nDRM_DEBUG_KMS("dig clock %p %d %d\n", dig_connector,\r\ndig_connector->dp_lane_count, dig_connector->dp_clock);\r\n}\r\nreturn true;\r\n}\r\nstatic void radeon_mst_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct radeon_connector *radeon_connector;\r\nstruct radeon_encoder *radeon_encoder, *primary;\r\nstruct radeon_encoder_mst *mst_enc;\r\nstruct radeon_encoder_atom_dig *dig_enc;\r\nradeon_connector = radeon_mst_find_connector(encoder);\r\nif (!radeon_connector) {\r\nDRM_DEBUG_KMS("failed to find connector %p\n", encoder);\r\nreturn;\r\n}\r\nradeon_encoder = to_radeon_encoder(encoder);\r\nradeon_mst_encoder_dpms(encoder, DRM_MODE_DPMS_OFF);\r\nmst_enc = radeon_encoder->enc_priv;\r\nprimary = mst_enc->primary;\r\ndig_enc = primary->enc_priv;\r\nmst_enc->port = radeon_connector->port;\r\nif (dig_enc->dig_encoder == -1) {\r\ndig_enc->dig_encoder = radeon_atom_pick_dig_encoder(&primary->base, -1);\r\nprimary->offset = radeon_atom_set_enc_offset(dig_enc->dig_encoder);\r\natombios_set_mst_encoder_crtc_source(encoder, dig_enc->dig_encoder);\r\n}\r\nDRM_DEBUG_KMS("%d %d\n", dig_enc->dig_encoder, primary->offset);\r\n}\r\nstatic void\r\nradeon_mst_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nDRM_DEBUG_KMS("\n");\r\n}\r\nstatic void radeon_mst_encoder_commit(struct drm_encoder *encoder)\r\n{\r\nradeon_mst_encoder_dpms(encoder, DRM_MODE_DPMS_ON);\r\nDRM_DEBUG_KMS("\n");\r\n}\r\nvoid radeon_dp_mst_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\ndrm_encoder_cleanup(encoder);\r\nkfree(encoder);\r\n}\r\nstatic struct radeon_encoder *\r\nradeon_dp_create_fake_mst_encoder(struct radeon_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder;\r\nstruct radeon_encoder_mst *mst_enc;\r\nstruct drm_encoder *encoder;\r\nconst struct drm_connector_helper_funcs *connector_funcs = connector->base.helper_private;\r\nstruct drm_encoder *enc_master = connector_funcs->best_encoder(&connector->base);\r\nDRM_DEBUG_KMS("enc master is %p\n", enc_master);\r\nradeon_encoder = kzalloc(sizeof(*radeon_encoder), GFP_KERNEL);\r\nif (!radeon_encoder)\r\nreturn NULL;\r\nradeon_encoder->enc_priv = kzalloc(sizeof(*mst_enc), GFP_KERNEL);\r\nif (!radeon_encoder->enc_priv) {\r\nkfree(radeon_encoder);\r\nreturn NULL;\r\n}\r\nencoder = &radeon_encoder->base;\r\nswitch (rdev->num_crtc) {\r\ncase 1:\r\nencoder->possible_crtcs = 0x1;\r\nbreak;\r\ncase 2:\r\ndefault:\r\nencoder->possible_crtcs = 0x3;\r\nbreak;\r\ncase 4:\r\nencoder->possible_crtcs = 0xf;\r\nbreak;\r\ncase 6:\r\nencoder->possible_crtcs = 0x3f;\r\nbreak;\r\n}\r\ndrm_encoder_init(dev, &radeon_encoder->base, &radeon_dp_mst_enc_funcs,\r\nDRM_MODE_ENCODER_DPMST);\r\ndrm_encoder_helper_add(encoder, &radeon_mst_helper_funcs);\r\nmst_enc = radeon_encoder->enc_priv;\r\nmst_enc->connector = connector;\r\nmst_enc->primary = to_radeon_encoder(enc_master);\r\nradeon_encoder->is_mst_encoder = true;\r\nreturn radeon_encoder;\r\n}\r\nint\r\nradeon_dp_mst_init(struct radeon_connector *radeon_connector)\r\n{\r\nstruct drm_device *dev = radeon_connector->base.dev;\r\nif (!radeon_connector->ddc_bus->has_aux)\r\nreturn 0;\r\nradeon_connector->mst_mgr.cbs = &mst_cbs;\r\nreturn drm_dp_mst_topology_mgr_init(&radeon_connector->mst_mgr, dev->dev,\r\n&radeon_connector->ddc_bus->aux, 16, 6,\r\nradeon_connector->base.base.id);\r\n}\r\nint\r\nradeon_dp_mst_probe(struct radeon_connector *radeon_connector)\r\n{\r\nstruct radeon_connector_atom_dig *dig_connector = radeon_connector->con_priv;\r\nstruct drm_device *dev = radeon_connector->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nint ret;\r\nu8 msg[1];\r\nif (!radeon_mst)\r\nreturn 0;\r\nif (!ASIC_IS_DCE5(rdev))\r\nreturn 0;\r\nif (dig_connector->dpcd[DP_DPCD_REV] < 0x12)\r\nreturn 0;\r\nret = drm_dp_dpcd_read(&radeon_connector->ddc_bus->aux, DP_MSTM_CAP, msg,\r\n1);\r\nif (ret) {\r\nif (msg[0] & DP_MST_CAP) {\r\nDRM_DEBUG_KMS("Sink is MST capable\n");\r\ndig_connector->is_mst = true;\r\n} else {\r\nDRM_DEBUG_KMS("Sink is not MST capable\n");\r\ndig_connector->is_mst = false;\r\n}\r\n}\r\ndrm_dp_mst_topology_mgr_set_mst(&radeon_connector->mst_mgr,\r\ndig_connector->is_mst);\r\nreturn dig_connector->is_mst;\r\n}\r\nint\r\nradeon_dp_mst_check_status(struct radeon_connector *radeon_connector)\r\n{\r\nstruct radeon_connector_atom_dig *dig_connector = radeon_connector->con_priv;\r\nint retry;\r\nif (dig_connector->is_mst) {\r\nu8 esi[16] = { 0 };\r\nint dret;\r\nint ret = 0;\r\nbool handled;\r\ndret = drm_dp_dpcd_read(&radeon_connector->ddc_bus->aux,\r\nDP_SINK_COUNT_ESI, esi, 8);\r\ngo_again:\r\nif (dret == 8) {\r\nDRM_DEBUG_KMS("got esi %02x %02x %02x\n", esi[0], esi[1], esi[2]);\r\nret = drm_dp_mst_hpd_irq(&radeon_connector->mst_mgr, esi, &handled);\r\nif (handled) {\r\nfor (retry = 0; retry < 3; retry++) {\r\nint wret;\r\nwret = drm_dp_dpcd_write(&radeon_connector->ddc_bus->aux,\r\nDP_SINK_COUNT_ESI + 1, &esi[1], 3);\r\nif (wret == 3)\r\nbreak;\r\n}\r\ndret = drm_dp_dpcd_read(&radeon_connector->ddc_bus->aux,\r\nDP_SINK_COUNT_ESI, esi, 8);\r\nif (dret == 8) {\r\nDRM_DEBUG_KMS("got esi2 %02x %02x %02x\n", esi[0], esi[1], esi[2]);\r\ngoto go_again;\r\n}\r\n} else\r\nret = 0;\r\nreturn ret;\r\n} else {\r\nDRM_DEBUG_KMS("failed to get ESI - device may have failed %d\n", ret);\r\ndig_connector->is_mst = false;\r\ndrm_dp_mst_topology_mgr_set_mst(&radeon_connector->mst_mgr,\r\ndig_connector->is_mst);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int radeon_debugfs_mst_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *)m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct drm_connector *connector;\r\nstruct radeon_connector *radeon_connector;\r\nstruct radeon_connector_atom_dig *dig_connector;\r\nint i;\r\ndrm_modeset_lock_all(dev);\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nif (connector->connector_type != DRM_MODE_CONNECTOR_DisplayPort)\r\ncontinue;\r\nradeon_connector = to_radeon_connector(connector);\r\ndig_connector = radeon_connector->con_priv;\r\nif (radeon_connector->is_mst_connector)\r\ncontinue;\r\nif (!dig_connector->is_mst)\r\ncontinue;\r\ndrm_dp_mst_dump_topology(m, &radeon_connector->mst_mgr);\r\nfor (i = 0; i < radeon_connector->enabled_attribs; i++)\r\nseq_printf(m, "attrib %d: %d %d\n", i,\r\nradeon_connector->cur_stream_attribs[i].fe,\r\nradeon_connector->cur_stream_attribs[i].slots);\r\n}\r\ndrm_modeset_unlock_all(dev);\r\nreturn 0;\r\n}\r\nint radeon_mst_debugfs_init(struct radeon_device *rdev)\r\n{\r\n#if defined(CONFIG_DEBUG_FS)\r\nreturn radeon_debugfs_add_files(rdev, radeon_debugfs_mst_list, 1);\r\n#endif\r\nreturn 0;\r\n}
