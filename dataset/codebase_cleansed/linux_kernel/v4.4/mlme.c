void cfg80211_rx_assoc_resp(struct net_device *dev, struct cfg80211_bss *bss,\r\nconst u8 *buf, size_t len, int uapsd_queues)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct wiphy *wiphy = wdev->wiphy;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\r\nstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buf;\r\nu8 *ie = mgmt->u.assoc_resp.variable;\r\nint ieoffs = offsetof(struct ieee80211_mgmt, u.assoc_resp.variable);\r\nu16 status_code = le16_to_cpu(mgmt->u.assoc_resp.status_code);\r\ntrace_cfg80211_send_rx_assoc(dev, bss);\r\nif (cfg80211_sme_rx_assoc_resp(wdev, status_code)) {\r\ncfg80211_unhold_bss(bss_from_pub(bss));\r\ncfg80211_put_bss(wiphy, bss);\r\nreturn;\r\n}\r\nnl80211_send_rx_assoc(rdev, dev, buf, len, GFP_KERNEL, uapsd_queues);\r\n__cfg80211_connect_result(dev, mgmt->bssid, NULL, 0, ie, len - ieoffs,\r\nstatus_code,\r\nstatus_code == WLAN_STATUS_SUCCESS, bss);\r\n}\r\nstatic void cfg80211_process_auth(struct wireless_dev *wdev,\r\nconst u8 *buf, size_t len)\r\n{\r\nstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\r\nnl80211_send_rx_auth(rdev, wdev->netdev, buf, len, GFP_KERNEL);\r\ncfg80211_sme_rx_auth(wdev, buf, len);\r\n}\r\nstatic void cfg80211_process_deauth(struct wireless_dev *wdev,\r\nconst u8 *buf, size_t len)\r\n{\r\nstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\r\nstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buf;\r\nconst u8 *bssid = mgmt->bssid;\r\nu16 reason_code = le16_to_cpu(mgmt->u.deauth.reason_code);\r\nbool from_ap = !ether_addr_equal(mgmt->sa, wdev->netdev->dev_addr);\r\nnl80211_send_deauth(rdev, wdev->netdev, buf, len, GFP_KERNEL);\r\nif (!wdev->current_bss ||\r\n!ether_addr_equal(wdev->current_bss->pub.bssid, bssid))\r\nreturn;\r\n__cfg80211_disconnected(wdev->netdev, NULL, 0, reason_code, from_ap);\r\ncfg80211_sme_deauth(wdev);\r\n}\r\nstatic void cfg80211_process_disassoc(struct wireless_dev *wdev,\r\nconst u8 *buf, size_t len)\r\n{\r\nstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\r\nstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buf;\r\nconst u8 *bssid = mgmt->bssid;\r\nu16 reason_code = le16_to_cpu(mgmt->u.disassoc.reason_code);\r\nbool from_ap = !ether_addr_equal(mgmt->sa, wdev->netdev->dev_addr);\r\nnl80211_send_disassoc(rdev, wdev->netdev, buf, len, GFP_KERNEL);\r\nif (WARN_ON(!wdev->current_bss ||\r\n!ether_addr_equal(wdev->current_bss->pub.bssid, bssid)))\r\nreturn;\r\n__cfg80211_disconnected(wdev->netdev, NULL, 0, reason_code, from_ap);\r\ncfg80211_sme_disassoc(wdev);\r\n}\r\nvoid cfg80211_rx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct ieee80211_mgmt *mgmt = (void *)buf;\r\nASSERT_WDEV_LOCK(wdev);\r\ntrace_cfg80211_rx_mlme_mgmt(dev, buf, len);\r\nif (WARN_ON(len < 2))\r\nreturn;\r\nif (ieee80211_is_auth(mgmt->frame_control))\r\ncfg80211_process_auth(wdev, buf, len);\r\nelse if (ieee80211_is_deauth(mgmt->frame_control))\r\ncfg80211_process_deauth(wdev, buf, len);\r\nelse if (ieee80211_is_disassoc(mgmt->frame_control))\r\ncfg80211_process_disassoc(wdev, buf, len);\r\n}\r\nvoid cfg80211_auth_timeout(struct net_device *dev, const u8 *addr)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct wiphy *wiphy = wdev->wiphy;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\r\ntrace_cfg80211_send_auth_timeout(dev, addr);\r\nnl80211_send_auth_timeout(rdev, dev, addr, GFP_KERNEL);\r\ncfg80211_sme_auth_timeout(wdev);\r\n}\r\nvoid cfg80211_assoc_timeout(struct net_device *dev, struct cfg80211_bss *bss)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct wiphy *wiphy = wdev->wiphy;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\r\ntrace_cfg80211_send_assoc_timeout(dev, bss->bssid);\r\nnl80211_send_assoc_timeout(rdev, dev, bss->bssid, GFP_KERNEL);\r\ncfg80211_sme_assoc_timeout(wdev);\r\ncfg80211_unhold_bss(bss_from_pub(bss));\r\ncfg80211_put_bss(wiphy, bss);\r\n}\r\nvoid cfg80211_tx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct ieee80211_mgmt *mgmt = (void *)buf;\r\nASSERT_WDEV_LOCK(wdev);\r\ntrace_cfg80211_tx_mlme_mgmt(dev, buf, len);\r\nif (WARN_ON(len < 2))\r\nreturn;\r\nif (ieee80211_is_deauth(mgmt->frame_control))\r\ncfg80211_process_deauth(wdev, buf, len);\r\nelse\r\ncfg80211_process_disassoc(wdev, buf, len);\r\n}\r\nvoid cfg80211_michael_mic_failure(struct net_device *dev, const u8 *addr,\r\nenum nl80211_key_type key_type, int key_id,\r\nconst u8 *tsc, gfp_t gfp)\r\n{\r\nstruct wiphy *wiphy = dev->ieee80211_ptr->wiphy;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\r\n#ifdef CONFIG_CFG80211_WEXT\r\nunion iwreq_data wrqu;\r\nchar *buf = kmalloc(128, gfp);\r\nif (buf) {\r\nsprintf(buf, "MLME-MICHAELMICFAILURE.indication("\r\n"keyid=%d %scast addr=%pM)", key_id,\r\nkey_type == NL80211_KEYTYPE_GROUP ? "broad" : "uni",\r\naddr);\r\nmemset(&wrqu, 0, sizeof(wrqu));\r\nwrqu.data.length = strlen(buf);\r\nwireless_send_event(dev, IWEVCUSTOM, &wrqu, buf);\r\nkfree(buf);\r\n}\r\n#endif\r\ntrace_cfg80211_michael_mic_failure(dev, addr, key_type, key_id, tsc);\r\nnl80211_michael_mic_failure(rdev, dev, addr, key_type, key_id, tsc, gfp);\r\n}\r\nint cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,\r\nstruct net_device *dev,\r\nstruct ieee80211_channel *chan,\r\nenum nl80211_auth_type auth_type,\r\nconst u8 *bssid,\r\nconst u8 *ssid, int ssid_len,\r\nconst u8 *ie, int ie_len,\r\nconst u8 *key, int key_len, int key_idx,\r\nconst u8 *sae_data, int sae_data_len)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_auth_request req = {\r\n.ie = ie,\r\n.ie_len = ie_len,\r\n.sae_data = sae_data,\r\n.sae_data_len = sae_data_len,\r\n.auth_type = auth_type,\r\n.key = key,\r\n.key_len = key_len,\r\n.key_idx = key_idx,\r\n};\r\nint err;\r\nASSERT_WDEV_LOCK(wdev);\r\nif (auth_type == NL80211_AUTHTYPE_SHARED_KEY)\r\nif (!key || !key_len || key_idx < 0 || key_idx > 4)\r\nreturn -EINVAL;\r\nif (wdev->current_bss &&\r\nether_addr_equal(bssid, wdev->current_bss->pub.bssid))\r\nreturn -EALREADY;\r\nreq.bss = cfg80211_get_bss(&rdev->wiphy, chan, bssid, ssid, ssid_len,\r\nIEEE80211_BSS_TYPE_ESS,\r\nIEEE80211_PRIVACY_ANY);\r\nif (!req.bss)\r\nreturn -ENOENT;\r\nerr = rdev_auth(rdev, dev, &req);\r\ncfg80211_put_bss(&rdev->wiphy, req.bss);\r\nreturn err;\r\n}\r\nvoid cfg80211_oper_and_ht_capa(struct ieee80211_ht_cap *ht_capa,\r\nconst struct ieee80211_ht_cap *ht_capa_mask)\r\n{\r\nint i;\r\nu8 *p1, *p2;\r\nif (!ht_capa_mask) {\r\nmemset(ht_capa, 0, sizeof(*ht_capa));\r\nreturn;\r\n}\r\np1 = (u8*)(ht_capa);\r\np2 = (u8*)(ht_capa_mask);\r\nfor (i = 0; i<sizeof(*ht_capa); i++)\r\np1[i] &= p2[i];\r\n}\r\nvoid cfg80211_oper_and_vht_capa(struct ieee80211_vht_cap *vht_capa,\r\nconst struct ieee80211_vht_cap *vht_capa_mask)\r\n{\r\nint i;\r\nu8 *p1, *p2;\r\nif (!vht_capa_mask) {\r\nmemset(vht_capa, 0, sizeof(*vht_capa));\r\nreturn;\r\n}\r\np1 = (u8*)(vht_capa);\r\np2 = (u8*)(vht_capa_mask);\r\nfor (i = 0; i < sizeof(*vht_capa); i++)\r\np1[i] &= p2[i];\r\n}\r\nint cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,\r\nstruct net_device *dev,\r\nstruct ieee80211_channel *chan,\r\nconst u8 *bssid,\r\nconst u8 *ssid, int ssid_len,\r\nstruct cfg80211_assoc_request *req)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nint err;\r\nASSERT_WDEV_LOCK(wdev);\r\nif (wdev->current_bss &&\r\n(!req->prev_bssid || !ether_addr_equal(wdev->current_bss->pub.bssid,\r\nreq->prev_bssid)))\r\nreturn -EALREADY;\r\ncfg80211_oper_and_ht_capa(&req->ht_capa_mask,\r\nrdev->wiphy.ht_capa_mod_mask);\r\ncfg80211_oper_and_vht_capa(&req->vht_capa_mask,\r\nrdev->wiphy.vht_capa_mod_mask);\r\nreq->bss = cfg80211_get_bss(&rdev->wiphy, chan, bssid, ssid, ssid_len,\r\nIEEE80211_BSS_TYPE_ESS,\r\nIEEE80211_PRIVACY_ANY);\r\nif (!req->bss)\r\nreturn -ENOENT;\r\nerr = rdev_assoc(rdev, dev, req);\r\nif (!err)\r\ncfg80211_hold_bss(bss_from_pub(req->bss));\r\nelse\r\ncfg80211_put_bss(&rdev->wiphy, req->bss);\r\nreturn err;\r\n}\r\nint cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,\r\nstruct net_device *dev, const u8 *bssid,\r\nconst u8 *ie, int ie_len, u16 reason,\r\nbool local_state_change)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_deauth_request req = {\r\n.bssid = bssid,\r\n.reason_code = reason,\r\n.ie = ie,\r\n.ie_len = ie_len,\r\n.local_state_change = local_state_change,\r\n};\r\nASSERT_WDEV_LOCK(wdev);\r\nif (local_state_change &&\r\n(!wdev->current_bss ||\r\n!ether_addr_equal(wdev->current_bss->pub.bssid, bssid)))\r\nreturn 0;\r\nreturn rdev_deauth(rdev, dev, &req);\r\n}\r\nint cfg80211_mlme_disassoc(struct cfg80211_registered_device *rdev,\r\nstruct net_device *dev, const u8 *bssid,\r\nconst u8 *ie, int ie_len, u16 reason,\r\nbool local_state_change)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_disassoc_request req = {\r\n.reason_code = reason,\r\n.local_state_change = local_state_change,\r\n.ie = ie,\r\n.ie_len = ie_len,\r\n};\r\nint err;\r\nASSERT_WDEV_LOCK(wdev);\r\nif (!wdev->current_bss)\r\nreturn -ENOTCONN;\r\nif (ether_addr_equal(wdev->current_bss->pub.bssid, bssid))\r\nreq.bss = &wdev->current_bss->pub;\r\nelse\r\nreturn -ENOTCONN;\r\nerr = rdev_disassoc(rdev, dev, &req);\r\nif (err)\r\nreturn err;\r\nWARN_ON(wdev->current_bss);\r\nreturn 0;\r\n}\r\nvoid cfg80211_mlme_down(struct cfg80211_registered_device *rdev,\r\nstruct net_device *dev)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nu8 bssid[ETH_ALEN];\r\nASSERT_WDEV_LOCK(wdev);\r\nif (!rdev->ops->deauth)\r\nreturn;\r\nif (!wdev->current_bss)\r\nreturn;\r\nmemcpy(bssid, wdev->current_bss->pub.bssid, ETH_ALEN);\r\ncfg80211_mlme_deauth(rdev, dev, bssid, NULL, 0,\r\nWLAN_REASON_DEAUTH_LEAVING, false);\r\n}\r\nstatic void\r\ncfg80211_process_mlme_unregistrations(struct cfg80211_registered_device *rdev)\r\n{\r\nstruct cfg80211_mgmt_registration *reg;\r\nASSERT_RTNL();\r\nspin_lock_bh(&rdev->mlme_unreg_lock);\r\nwhile ((reg = list_first_entry_or_null(&rdev->mlme_unreg,\r\nstruct cfg80211_mgmt_registration,\r\nlist))) {\r\nlist_del(&reg->list);\r\nspin_unlock_bh(&rdev->mlme_unreg_lock);\r\nif (rdev->ops->mgmt_frame_register) {\r\nu16 frame_type = le16_to_cpu(reg->frame_type);\r\nrdev_mgmt_frame_register(rdev, reg->wdev,\r\nframe_type, false);\r\n}\r\nkfree(reg);\r\nspin_lock_bh(&rdev->mlme_unreg_lock);\r\n}\r\nspin_unlock_bh(&rdev->mlme_unreg_lock);\r\n}\r\nvoid cfg80211_mlme_unreg_wk(struct work_struct *wk)\r\n{\r\nstruct cfg80211_registered_device *rdev;\r\nrdev = container_of(wk, struct cfg80211_registered_device,\r\nmlme_unreg_wk);\r\nrtnl_lock();\r\ncfg80211_process_mlme_unregistrations(rdev);\r\nrtnl_unlock();\r\n}\r\nint cfg80211_mlme_register_mgmt(struct wireless_dev *wdev, u32 snd_portid,\r\nu16 frame_type, const u8 *match_data,\r\nint match_len)\r\n{\r\nstruct wiphy *wiphy = wdev->wiphy;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\r\nstruct cfg80211_mgmt_registration *reg, *nreg;\r\nint err = 0;\r\nu16 mgmt_type;\r\nif (!wdev->wiphy->mgmt_stypes)\r\nreturn -EOPNOTSUPP;\r\nif ((frame_type & IEEE80211_FCTL_FTYPE) != IEEE80211_FTYPE_MGMT)\r\nreturn -EINVAL;\r\nif (frame_type & ~(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE))\r\nreturn -EINVAL;\r\nmgmt_type = (frame_type & IEEE80211_FCTL_STYPE) >> 4;\r\nif (!(wdev->wiphy->mgmt_stypes[wdev->iftype].rx & BIT(mgmt_type)))\r\nreturn -EINVAL;\r\nnreg = kzalloc(sizeof(*reg) + match_len, GFP_KERNEL);\r\nif (!nreg)\r\nreturn -ENOMEM;\r\nspin_lock_bh(&wdev->mgmt_registrations_lock);\r\nlist_for_each_entry(reg, &wdev->mgmt_registrations, list) {\r\nint mlen = min(match_len, reg->match_len);\r\nif (frame_type != le16_to_cpu(reg->frame_type))\r\ncontinue;\r\nif (memcmp(reg->match, match_data, mlen) == 0) {\r\nerr = -EALREADY;\r\nbreak;\r\n}\r\n}\r\nif (err) {\r\nkfree(nreg);\r\ngoto out;\r\n}\r\nmemcpy(nreg->match, match_data, match_len);\r\nnreg->match_len = match_len;\r\nnreg->nlportid = snd_portid;\r\nnreg->frame_type = cpu_to_le16(frame_type);\r\nnreg->wdev = wdev;\r\nlist_add(&nreg->list, &wdev->mgmt_registrations);\r\nspin_unlock_bh(&wdev->mgmt_registrations_lock);\r\ncfg80211_process_mlme_unregistrations(rdev);\r\nif (rdev->ops->mgmt_frame_register)\r\nrdev_mgmt_frame_register(rdev, wdev, frame_type, true);\r\nreturn 0;\r\nout:\r\nspin_unlock_bh(&wdev->mgmt_registrations_lock);\r\nreturn err;\r\n}\r\nvoid cfg80211_mlme_unregister_socket(struct wireless_dev *wdev, u32 nlportid)\r\n{\r\nstruct wiphy *wiphy = wdev->wiphy;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\r\nstruct cfg80211_mgmt_registration *reg, *tmp;\r\nspin_lock_bh(&wdev->mgmt_registrations_lock);\r\nlist_for_each_entry_safe(reg, tmp, &wdev->mgmt_registrations, list) {\r\nif (reg->nlportid != nlportid)\r\ncontinue;\r\nlist_del(&reg->list);\r\nspin_lock(&rdev->mlme_unreg_lock);\r\nlist_add_tail(&reg->list, &rdev->mlme_unreg);\r\nspin_unlock(&rdev->mlme_unreg_lock);\r\nschedule_work(&rdev->mlme_unreg_wk);\r\n}\r\nspin_unlock_bh(&wdev->mgmt_registrations_lock);\r\nif (nlportid && rdev->crit_proto_nlportid == nlportid) {\r\nrdev->crit_proto_nlportid = 0;\r\nrdev_crit_proto_stop(rdev, wdev);\r\n}\r\nif (nlportid == wdev->ap_unexpected_nlportid)\r\nwdev->ap_unexpected_nlportid = 0;\r\n}\r\nvoid cfg80211_mlme_purge_registrations(struct wireless_dev *wdev)\r\n{\r\nstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\r\nspin_lock_bh(&wdev->mgmt_registrations_lock);\r\nspin_lock(&rdev->mlme_unreg_lock);\r\nlist_splice_tail_init(&wdev->mgmt_registrations, &rdev->mlme_unreg);\r\nspin_unlock(&rdev->mlme_unreg_lock);\r\nspin_unlock_bh(&wdev->mgmt_registrations_lock);\r\ncfg80211_process_mlme_unregistrations(rdev);\r\n}\r\nint cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev,\r\nstruct wireless_dev *wdev,\r\nstruct cfg80211_mgmt_tx_params *params, u64 *cookie)\r\n{\r\nconst struct ieee80211_mgmt *mgmt;\r\nu16 stype;\r\nif (!wdev->wiphy->mgmt_stypes)\r\nreturn -EOPNOTSUPP;\r\nif (!rdev->ops->mgmt_tx)\r\nreturn -EOPNOTSUPP;\r\nif (params->len < 24 + 1)\r\nreturn -EINVAL;\r\nmgmt = (const struct ieee80211_mgmt *)params->buf;\r\nif (!ieee80211_is_mgmt(mgmt->frame_control))\r\nreturn -EINVAL;\r\nstype = le16_to_cpu(mgmt->frame_control) & IEEE80211_FCTL_STYPE;\r\nif (!(wdev->wiphy->mgmt_stypes[wdev->iftype].tx & BIT(stype >> 4)))\r\nreturn -EINVAL;\r\nif (ieee80211_is_action(mgmt->frame_control) &&\r\nmgmt->u.action.category != WLAN_CATEGORY_PUBLIC) {\r\nint err = 0;\r\nwdev_lock(wdev);\r\nswitch (wdev->iftype) {\r\ncase NL80211_IFTYPE_ADHOC:\r\ncase NL80211_IFTYPE_STATION:\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\nif (!wdev->current_bss) {\r\nerr = -ENOTCONN;\r\nbreak;\r\n}\r\nif (!ether_addr_equal(wdev->current_bss->pub.bssid,\r\nmgmt->bssid)) {\r\nerr = -ENOTCONN;\r\nbreak;\r\n}\r\nif (wdev->iftype == NL80211_IFTYPE_ADHOC)\r\nbreak;\r\nif (!ether_addr_equal(wdev->current_bss->pub.bssid,\r\nmgmt->da)) {\r\nerr = -ENOTCONN;\r\nbreak;\r\n}\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\ncase NL80211_IFTYPE_P2P_GO:\r\ncase NL80211_IFTYPE_AP_VLAN:\r\nif (!ether_addr_equal(mgmt->bssid, wdev_address(wdev)))\r\nerr = -EINVAL;\r\nbreak;\r\ncase NL80211_IFTYPE_MESH_POINT:\r\nif (!ether_addr_equal(mgmt->sa, mgmt->bssid)) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ncase NL80211_IFTYPE_P2P_DEVICE:\r\ndefault:\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nwdev_unlock(wdev);\r\nif (err)\r\nreturn err;\r\n}\r\nif (!ether_addr_equal(mgmt->sa, wdev_address(wdev)))\r\nreturn -EINVAL;\r\nreturn rdev_mgmt_tx(rdev, wdev, params, cookie);\r\n}\r\nbool cfg80211_rx_mgmt(struct wireless_dev *wdev, int freq, int sig_mbm,\r\nconst u8 *buf, size_t len, u32 flags)\r\n{\r\nstruct wiphy *wiphy = wdev->wiphy;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\r\nstruct cfg80211_mgmt_registration *reg;\r\nconst struct ieee80211_txrx_stypes *stypes =\r\n&wiphy->mgmt_stypes[wdev->iftype];\r\nstruct ieee80211_mgmt *mgmt = (void *)buf;\r\nconst u8 *data;\r\nint data_len;\r\nbool result = false;\r\n__le16 ftype = mgmt->frame_control &\r\ncpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE);\r\nu16 stype;\r\ntrace_cfg80211_rx_mgmt(wdev, freq, sig_mbm);\r\nstype = (le16_to_cpu(mgmt->frame_control) & IEEE80211_FCTL_STYPE) >> 4;\r\nif (!(stypes->rx & BIT(stype))) {\r\ntrace_cfg80211_return_bool(false);\r\nreturn false;\r\n}\r\ndata = buf + ieee80211_hdrlen(mgmt->frame_control);\r\ndata_len = len - ieee80211_hdrlen(mgmt->frame_control);\r\nspin_lock_bh(&wdev->mgmt_registrations_lock);\r\nlist_for_each_entry(reg, &wdev->mgmt_registrations, list) {\r\nif (reg->frame_type != ftype)\r\ncontinue;\r\nif (reg->match_len > data_len)\r\ncontinue;\r\nif (memcmp(reg->match, data, reg->match_len))\r\ncontinue;\r\nif (nl80211_send_mgmt(rdev, wdev, reg->nlportid,\r\nfreq, sig_mbm,\r\nbuf, len, flags, GFP_ATOMIC))\r\ncontinue;\r\nresult = true;\r\nbreak;\r\n}\r\nspin_unlock_bh(&wdev->mgmt_registrations_lock);\r\ntrace_cfg80211_return_bool(result);\r\nreturn result;\r\n}\r\nvoid cfg80211_dfs_channels_update_work(struct work_struct *work)\r\n{\r\nstruct delayed_work *delayed_work;\r\nstruct cfg80211_registered_device *rdev;\r\nstruct cfg80211_chan_def chandef;\r\nstruct ieee80211_supported_band *sband;\r\nstruct ieee80211_channel *c;\r\nstruct wiphy *wiphy;\r\nbool check_again = false;\r\nunsigned long timeout, next_time = 0;\r\nint bandid, i;\r\ndelayed_work = container_of(work, struct delayed_work, work);\r\nrdev = container_of(delayed_work, struct cfg80211_registered_device,\r\ndfs_update_channels_wk);\r\nwiphy = &rdev->wiphy;\r\nrtnl_lock();\r\nfor (bandid = 0; bandid < IEEE80211_NUM_BANDS; bandid++) {\r\nsband = wiphy->bands[bandid];\r\nif (!sband)\r\ncontinue;\r\nfor (i = 0; i < sband->n_channels; i++) {\r\nc = &sband->channels[i];\r\nif (c->dfs_state != NL80211_DFS_UNAVAILABLE)\r\ncontinue;\r\ntimeout = c->dfs_state_entered + msecs_to_jiffies(\r\nIEEE80211_DFS_MIN_NOP_TIME_MS);\r\nif (time_after_eq(jiffies, timeout)) {\r\nc->dfs_state = NL80211_DFS_USABLE;\r\nc->dfs_state_entered = jiffies;\r\ncfg80211_chandef_create(&chandef, c,\r\nNL80211_CHAN_NO_HT);\r\nnl80211_radar_notify(rdev, &chandef,\r\nNL80211_RADAR_NOP_FINISHED,\r\nNULL, GFP_ATOMIC);\r\ncontinue;\r\n}\r\nif (!check_again)\r\nnext_time = timeout - jiffies;\r\nelse\r\nnext_time = min(next_time, timeout - jiffies);\r\ncheck_again = true;\r\n}\r\n}\r\nrtnl_unlock();\r\nif (check_again)\r\nqueue_delayed_work(cfg80211_wq, &rdev->dfs_update_channels_wk,\r\nnext_time);\r\n}\r\nvoid cfg80211_radar_event(struct wiphy *wiphy,\r\nstruct cfg80211_chan_def *chandef,\r\ngfp_t gfp)\r\n{\r\nstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\r\nunsigned long timeout;\r\ntrace_cfg80211_radar_event(wiphy, chandef);\r\ncfg80211_set_dfs_state(wiphy, chandef, NL80211_DFS_UNAVAILABLE);\r\ntimeout = msecs_to_jiffies(IEEE80211_DFS_MIN_NOP_TIME_MS);\r\nqueue_delayed_work(cfg80211_wq, &rdev->dfs_update_channels_wk,\r\ntimeout);\r\nnl80211_radar_notify(rdev, chandef, NL80211_RADAR_DETECTED, NULL, gfp);\r\n}\r\nvoid cfg80211_cac_event(struct net_device *netdev,\r\nconst struct cfg80211_chan_def *chandef,\r\nenum nl80211_radar_event event, gfp_t gfp)\r\n{\r\nstruct wireless_dev *wdev = netdev->ieee80211_ptr;\r\nstruct wiphy *wiphy = wdev->wiphy;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\r\nunsigned long timeout;\r\ntrace_cfg80211_cac_event(netdev, event);\r\nif (WARN_ON(!wdev->cac_started))\r\nreturn;\r\nif (WARN_ON(!wdev->chandef.chan))\r\nreturn;\r\nswitch (event) {\r\ncase NL80211_RADAR_CAC_FINISHED:\r\ntimeout = wdev->cac_start_time +\r\nmsecs_to_jiffies(wdev->cac_time_ms);\r\nWARN_ON(!time_after_eq(jiffies, timeout));\r\ncfg80211_set_dfs_state(wiphy, chandef, NL80211_DFS_AVAILABLE);\r\nbreak;\r\ncase NL80211_RADAR_CAC_ABORTED:\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nwdev->cac_started = false;\r\nnl80211_radar_notify(rdev, chandef, event, netdev, gfp);\r\n}
