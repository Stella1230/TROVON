static void deflect_timer_expire(ulong arg)\r\n{\r\nunsigned long flags;\r\nstruct call_struc *cs = (struct call_struc *) arg;\r\nspin_lock_irqsave(&divert_lock, flags);\r\ndel_timer(&cs->timer);\r\nspin_unlock_irqrestore(&divert_lock, flags);\r\nswitch (cs->akt_state) {\r\ncase DEFLECT_PROCEED:\r\ncs->ics.command = ISDN_CMD_HANGUP;\r\ndivert_if.ll_cmd(&cs->ics);\r\nspin_lock_irqsave(&divert_lock, flags);\r\ncs->akt_state = DEFLECT_AUTODEL;\r\ncs->timer.expires = jiffies + (HZ * AUTODEL_TIME);\r\nadd_timer(&cs->timer);\r\nspin_unlock_irqrestore(&divert_lock, flags);\r\nbreak;\r\ncase DEFLECT_ALERT:\r\ncs->ics.command = ISDN_CMD_REDIR;\r\nstrlcpy(cs->ics.parm.setup.phone, cs->deflect_dest, sizeof(cs->ics.parm.setup.phone));\r\nstrcpy(cs->ics.parm.setup.eazmsn, "Testtext delayed");\r\ndivert_if.ll_cmd(&cs->ics);\r\nspin_lock_irqsave(&divert_lock, flags);\r\ncs->akt_state = DEFLECT_AUTODEL;\r\ncs->timer.expires = jiffies + (HZ * AUTODEL_TIME);\r\nadd_timer(&cs->timer);\r\nspin_unlock_irqrestore(&divert_lock, flags);\r\nbreak;\r\ncase DEFLECT_AUTODEL:\r\ndefault:\r\nspin_lock_irqsave(&divert_lock, flags);\r\nif (cs->prev)\r\ncs->prev->next = cs->next;\r\nelse\r\ndivert_head = cs->next;\r\nif (cs->next)\r\ncs->next->prev = cs->prev;\r\nspin_unlock_irqrestore(&divert_lock, flags);\r\nkfree(cs);\r\nreturn;\r\n}\r\n}\r\nint cf_command(int drvid, int mode,\r\nu_char proc, char *msn,\r\nu_char service, char *fwd_nr, ulong *procid)\r\n{\r\nunsigned long flags;\r\nint retval, msnlen;\r\nint fwd_len;\r\nchar *p, *ielenp, tmp[60];\r\nstruct call_struc *cs;\r\nif (strchr(msn, '.')) return (-EINVAL);\r\nif ((proc & 0x7F) > 2) return (-EINVAL);\r\nproc &= 3;\r\np = tmp;\r\n*p++ = 0x30;\r\nielenp = p++;\r\n*p++ = 0xa;\r\n*p++ = 1;\r\n*p++ = proc & 0x7F;\r\n*p++ = 0xa;\r\n*p++ = 1;\r\n*p++ = service;\r\nif (mode == 1) {\r\nif (!*fwd_nr) return (-EINVAL);\r\nif (strchr(fwd_nr, '.')) return (-EINVAL);\r\nfwd_len = strlen(fwd_nr);\r\n*p++ = 0x30;\r\n*p++ = fwd_len + 2;\r\n*p++ = 0x80;\r\n*p++ = fwd_len;\r\nstrcpy(p, fwd_nr);\r\np += fwd_len;\r\n}\r\nmsnlen = strlen(msn);\r\n*p++ = 0x80;\r\nif (msnlen > 1) {\r\n*p++ = msnlen;\r\nstrcpy(p, msn);\r\np += msnlen;\r\n} else\r\n*p++ = 0;\r\n*ielenp = p - ielenp - 1;\r\nif (!(cs = kmalloc(sizeof(struct call_struc), GFP_ATOMIC)))\r\nreturn (-ENOMEM);\r\ninit_timer(&cs->timer);\r\ncs->info[0] = '\0';\r\ncs->timer.function = deflect_timer_expire;\r\ncs->timer.data = (ulong) cs;\r\ncs->ics.driver = drvid;\r\ncs->ics.command = ISDN_CMD_PROT_IO;\r\ncs->ics.arg = DSS1_CMD_INVOKE;\r\ncs->ics.parm.dss1_io.proc = (mode == 1) ? 7 : (mode == 2) ? 11 : 8;\r\ncs->ics.parm.dss1_io.timeout = 4000;\r\ncs->ics.parm.dss1_io.datalen = p - tmp;\r\ncs->ics.parm.dss1_io.data = tmp;\r\nspin_lock_irqsave(&divert_lock, flags);\r\ncs->ics.parm.dss1_io.ll_id = next_id++;\r\nspin_unlock_irqrestore(&divert_lock, flags);\r\n*procid = cs->ics.parm.dss1_io.ll_id;\r\nsprintf(cs->info, "%d 0x%lx %s%s 0 %s %02x %d%s%s\n",\r\n(!mode) ? DIVERT_DEACTIVATE : (mode == 1) ? DIVERT_ACTIVATE : DIVERT_REPORT,\r\ncs->ics.parm.dss1_io.ll_id,\r\n(mode != 2) ? "" : "0 ",\r\ndivert_if.drv_to_name(cs->ics.driver),\r\nmsn,\r\nservice & 0xFF,\r\nproc,\r\n(mode != 1) ? "" : " 0 ",\r\n(mode != 1) ? "" : fwd_nr);\r\nretval = divert_if.ll_cmd(&cs->ics);\r\nif (!retval) {\r\ncs->prev = NULL;\r\nspin_lock_irqsave(&divert_lock, flags);\r\ncs->next = divert_head;\r\ndivert_head = cs;\r\nspin_unlock_irqrestore(&divert_lock, flags);\r\n} else\r\nkfree(cs);\r\nreturn (retval);\r\n}\r\nint deflect_extern_action(u_char cmd, ulong callid, char *to_nr)\r\n{\r\nstruct call_struc *cs;\r\nisdn_ctrl ic;\r\nunsigned long flags;\r\nint i;\r\nif ((cmd & 0x7F) > 2) return (-EINVAL);\r\ncs = divert_head;\r\nwhile (cs) {\r\nif (cs->divert_id == callid) break;\r\ncs = cs->next;\r\n}\r\nif (!cs) return (-EINVAL);\r\nic.driver = cs->ics.driver;\r\nic.arg = cs->ics.arg;\r\ni = -EINVAL;\r\nif (cs->akt_state == DEFLECT_AUTODEL) return (i);\r\nswitch (cmd & 0x7F) {\r\ncase 0:\r\ndel_timer(&cs->timer);\r\nic.command = ISDN_CMD_HANGUP;\r\ni = divert_if.ll_cmd(&ic);\r\nspin_lock_irqsave(&divert_lock, flags);\r\ncs->akt_state = DEFLECT_AUTODEL;\r\ncs->timer.expires = jiffies + (HZ * AUTODEL_TIME);\r\nadd_timer(&cs->timer);\r\nspin_unlock_irqrestore(&divert_lock, flags);\r\nbreak;\r\ncase 1:\r\nif (cs->akt_state == DEFLECT_ALERT) return (0);\r\ncmd &= 0x7F;\r\ndel_timer(&cs->timer);\r\nic.command = ISDN_CMD_ALERT;\r\nif ((i = divert_if.ll_cmd(&ic))) {\r\nspin_lock_irqsave(&divert_lock, flags);\r\ncs->akt_state = DEFLECT_AUTODEL;\r\ncs->timer.expires = jiffies + (HZ * AUTODEL_TIME);\r\nadd_timer(&cs->timer);\r\nspin_unlock_irqrestore(&divert_lock, flags);\r\n} else\r\ncs->akt_state = DEFLECT_ALERT;\r\nbreak;\r\ncase 2:\r\ndel_timer(&cs->timer);\r\nstrlcpy(cs->ics.parm.setup.phone, to_nr, sizeof(cs->ics.parm.setup.phone));\r\nstrcpy(cs->ics.parm.setup.eazmsn, "Testtext manual");\r\nic.command = ISDN_CMD_REDIR;\r\nif ((i = divert_if.ll_cmd(&ic))) {\r\nspin_lock_irqsave(&divert_lock, flags);\r\ncs->akt_state = DEFLECT_AUTODEL;\r\ncs->timer.expires = jiffies + (HZ * AUTODEL_TIME);\r\nadd_timer(&cs->timer);\r\nspin_unlock_irqrestore(&divert_lock, flags);\r\n} else\r\ncs->akt_state = DEFLECT_ALERT;\r\nbreak;\r\n}\r\nreturn (i);\r\n}\r\nint insertrule(int idx, divert_rule *newrule)\r\n{\r\nstruct deflect_struc *ds, *ds1 = NULL;\r\nunsigned long flags;\r\nif (!(ds = kmalloc(sizeof(struct deflect_struc), GFP_KERNEL)))\r\nreturn (-ENOMEM);\r\nds->rule = *newrule;\r\nspin_lock_irqsave(&divert_lock, flags);\r\nif (idx >= 0) {\r\nds1 = table_head;\r\nwhile ((ds1) && (idx > 0))\r\n{ idx--;\r\nds1 = ds1->next;\r\n}\r\nif (!ds1) idx = -1;\r\n}\r\nif (idx < 0) {\r\nds->prev = table_tail;\r\nds->next = NULL;\r\nif (ds->prev)\r\nds->prev->next = ds;\r\nelse\r\ntable_head = ds;\r\ntable_tail = ds;\r\n} else {\r\nds->next = ds1;\r\nds->prev = ds1->prev;\r\nds1->prev = ds;\r\nif (!ds->prev)\r\ntable_head = ds;\r\n}\r\nspin_unlock_irqrestore(&divert_lock, flags);\r\nreturn (0);\r\n}\r\nint deleterule(int idx)\r\n{\r\nstruct deflect_struc *ds, *ds1;\r\nunsigned long flags;\r\nif (idx < 0) {\r\nspin_lock_irqsave(&divert_lock, flags);\r\nds = table_head;\r\ntable_head = NULL;\r\ntable_tail = NULL;\r\nspin_unlock_irqrestore(&divert_lock, flags);\r\nwhile (ds) {\r\nds1 = ds;\r\nds = ds->next;\r\nkfree(ds1);\r\n}\r\nreturn (0);\r\n}\r\nspin_lock_irqsave(&divert_lock, flags);\r\nds = table_head;\r\nwhile ((ds) && (idx > 0)) {\r\nidx--;\r\nds = ds->next;\r\n}\r\nif (!ds) {\r\nspin_unlock_irqrestore(&divert_lock, flags);\r\nreturn (-EINVAL);\r\n}\r\nif (ds->next)\r\nds->next->prev = ds->prev;\r\nelse\r\ntable_tail = ds->prev;\r\nif (ds->prev)\r\nds->prev->next = ds->next;\r\nelse\r\ntable_head = ds->next;\r\nspin_unlock_irqrestore(&divert_lock, flags);\r\nkfree(ds);\r\nreturn (0);\r\n}\r\ndivert_rule *getruleptr(int idx)\r\n{\r\nstruct deflect_struc *ds = table_head;\r\nif (idx < 0) return (NULL);\r\nwhile ((ds) && (idx >= 0)) {\r\nif (!(idx--)) {\r\nreturn (&ds->rule);\r\nbreak;\r\n}\r\nds = ds->next;\r\n}\r\nreturn (NULL);\r\n}\r\nstatic int isdn_divert_icall(isdn_ctrl *ic)\r\n{\r\nint retval = 0;\r\nunsigned long flags;\r\nstruct call_struc *cs = NULL;\r\nstruct deflect_struc *dv;\r\nchar *p, *p1;\r\nu_char accept;\r\nfor (dv = table_head; dv; dv = dv->next) {\r\nif (((dv->rule.callopt == 1) && (ic->command == ISDN_STAT_ICALLW)) ||\r\n((dv->rule.callopt == 2) && (ic->command == ISDN_STAT_ICALL)))\r\ncontinue;\r\nif (!(dv->rule.drvid & (1L << ic->driver)))\r\ncontinue;\r\nif ((dv->rule.si1) && (dv->rule.si1 != ic->parm.setup.si1))\r\ncontinue;\r\nif ((dv->rule.si2) && (dv->rule.si2 != ic->parm.setup.si2))\r\ncontinue;\r\np = dv->rule.my_msn;\r\np1 = ic->parm.setup.eazmsn;\r\naccept = 0;\r\nwhile (*p) {\r\nif (*p == '-') {\r\naccept = 1;\r\nbreak;\r\n}\r\nif (*p++ != *p1++)\r\nbreak;\r\nif ((!*p) && (!*p1))\r\naccept = 1;\r\n}\r\nif (!accept) continue;\r\nif ((strcmp(dv->rule.caller, "0")) ||\r\n(ic->parm.setup.phone[0])) {\r\np = dv->rule.caller;\r\np1 = ic->parm.setup.phone;\r\naccept = 0;\r\nwhile (*p) {\r\nif (*p == '-') {\r\naccept = 1;\r\nbreak;\r\n}\r\nif (*p++ != *p1++)\r\nbreak;\r\nif ((!*p) && (!*p1))\r\naccept = 1;\r\n}\r\nif (!accept) continue;\r\n}\r\nswitch (dv->rule.action) {\r\ncase DEFLECT_IGNORE:\r\nreturn 0;\r\ncase DEFLECT_ALERT:\r\ncase DEFLECT_PROCEED:\r\ncase DEFLECT_REPORT:\r\ncase DEFLECT_REJECT:\r\nif (dv->rule.action == DEFLECT_PROCEED)\r\nif ((!if_used) || ((!extern_wait_max) && (!dv->rule.waittime)))\r\nreturn (0);\r\nif (!(cs = kmalloc(sizeof(struct call_struc), GFP_ATOMIC)))\r\nreturn (0);\r\ninit_timer(&cs->timer);\r\ncs->info[0] = '\0';\r\ncs->timer.function = deflect_timer_expire;\r\ncs->timer.data = (ulong) cs;\r\ncs->ics = *ic;\r\nif (!cs->ics.parm.setup.phone[0]) strcpy(cs->ics.parm.setup.phone, "0");\r\nif (!cs->ics.parm.setup.eazmsn[0]) strcpy(cs->ics.parm.setup.eazmsn, "0");\r\ncs->ics.parm.setup.screen = dv->rule.screen;\r\nif (dv->rule.waittime)\r\ncs->timer.expires = jiffies + (HZ * dv->rule.waittime);\r\nelse if (dv->rule.action == DEFLECT_PROCEED)\r\ncs->timer.expires = jiffies + (HZ * extern_wait_max);\r\nelse\r\ncs->timer.expires = 0;\r\ncs->akt_state = dv->rule.action;\r\nspin_lock_irqsave(&divert_lock, flags);\r\ncs->divert_id = next_id++;\r\nspin_unlock_irqrestore(&divert_lock, flags);\r\ncs->prev = NULL;\r\nif (cs->akt_state == DEFLECT_ALERT) {\r\nstrcpy(cs->deflect_dest, dv->rule.to_nr);\r\nif (!cs->timer.expires) {\r\nstrcpy(ic->parm.setup.eazmsn,\r\n"Testtext direct");\r\nic->parm.setup.screen = dv->rule.screen;\r\nstrlcpy(ic->parm.setup.phone, dv->rule.to_nr, sizeof(ic->parm.setup.phone));\r\ncs->akt_state = DEFLECT_AUTODEL;\r\ncs->timer.expires = jiffies + (HZ * AUTODEL_TIME);\r\nretval = 5;\r\n} else\r\nretval = 1;\r\n} else {\r\ncs->deflect_dest[0] = '\0';\r\nretval = 4;\r\n}\r\nsprintf(cs->info, "%d 0x%lx %s %s %s %s 0x%x 0x%x %d %d %s\n",\r\ncs->akt_state,\r\ncs->divert_id,\r\ndivert_if.drv_to_name(cs->ics.driver),\r\n(ic->command == ISDN_STAT_ICALLW) ? "1" : "0",\r\ncs->ics.parm.setup.phone,\r\ncs->ics.parm.setup.eazmsn,\r\ncs->ics.parm.setup.si1,\r\ncs->ics.parm.setup.si2,\r\ncs->ics.parm.setup.screen,\r\ndv->rule.waittime,\r\ncs->deflect_dest);\r\nif ((dv->rule.action == DEFLECT_REPORT) ||\r\n(dv->rule.action == DEFLECT_REJECT)) {\r\nput_info_buffer(cs->info);\r\nkfree(cs);\r\nreturn ((dv->rule.action == DEFLECT_REPORT) ? 0 : 2);\r\n}\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nif (cs) {\r\ncs->prev = NULL;\r\nspin_lock_irqsave(&divert_lock, flags);\r\ncs->next = divert_head;\r\ndivert_head = cs;\r\nif (cs->timer.expires) add_timer(&cs->timer);\r\nspin_unlock_irqrestore(&divert_lock, flags);\r\nput_info_buffer(cs->info);\r\nreturn (retval);\r\n} else\r\nreturn (0);\r\n}\r\nvoid deleteprocs(void)\r\n{\r\nstruct call_struc *cs, *cs1;\r\nunsigned long flags;\r\nspin_lock_irqsave(&divert_lock, flags);\r\ncs = divert_head;\r\ndivert_head = NULL;\r\nwhile (cs) {\r\ndel_timer(&cs->timer);\r\ncs1 = cs;\r\ncs = cs->next;\r\nkfree(cs1);\r\n}\r\nspin_unlock_irqrestore(&divert_lock, flags);\r\n}\r\nstatic int put_address(char *st, u_char *p, int len)\r\n{\r\nu_char retval = 0;\r\nu_char adr_typ = 0;\r\nif (len < 2) return (retval);\r\nif (*p == 0xA1) {\r\nretval = *(++p) + 2;\r\nif (retval > len) return (0);\r\nlen = retval - 2;\r\nif (len < 3) return (0);\r\nif ((*(++p) != 0x0A) || (*(++p) != 1)) return (0);\r\nadr_typ = *(++p);\r\nlen -= 3;\r\np++;\r\nif (len < 2) return (0);\r\nif (*p++ != 0x12) return (0);\r\nif (*p > len) return (0);\r\nlen = *p++;\r\n} else if (*p == 0x80) {\r\nretval = *(++p) + 2;\r\nif (retval > len) return (0);\r\nlen = retval - 2;\r\np++;\r\n} else\r\nreturn (0);\r\nsprintf(st, "%d ", adr_typ);\r\nst += strlen(st);\r\nif (!len)\r\n*st++ = '-';\r\nelse\r\nwhile (len--)\r\n*st++ = *p++;\r\n*st = '\0';\r\nreturn (retval);\r\n}\r\nstatic int interrogate_success(isdn_ctrl *ic, struct call_struc *cs)\r\n{\r\nchar *src = ic->parm.dss1_io.data;\r\nint restlen = ic->parm.dss1_io.datalen;\r\nint cnt = 1;\r\nu_char n, n1;\r\nchar st[90], *p, *stp;\r\nif (restlen < 2) return (-100);\r\nif (*src++ != 0x30) return (-101);\r\nif ((n = *src++) > 0x81) return (-102);\r\nrestlen -= 2;\r\nif (n == 0x80) {\r\nif (restlen < 2) return (-103);\r\nif ((*(src + restlen - 1)) || (*(src + restlen - 2))) return (-104);\r\nrestlen -= 2;\r\n} else if (n == 0x81) {\r\nn = *src++;\r\nrestlen--;\r\nif (n > restlen) return (-105);\r\nrestlen = n;\r\n} else if (n > restlen)\r\nreturn (-106);\r\nelse\r\nrestlen = n;\r\nif (restlen < 3) return (-107);\r\nif ((*src++ != 2) || (*src++ != 1) || (*src++ != 0x0B)) return (-108);\r\nrestlen -= 3;\r\nif (restlen < 2) return (-109);\r\nif (*src == 0x31) {\r\nsrc++;\r\nif ((n = *src++) > 0x81) return (-110);\r\nrestlen -= 2;\r\nif (n == 0x80) {\r\nif (restlen < 2) return (-111);\r\nif ((*(src + restlen - 1)) || (*(src + restlen - 2))) return (-112);\r\nrestlen -= 2;\r\n} else if (n == 0x81) {\r\nn = *src++;\r\nrestlen--;\r\nif (n > restlen) return (-113);\r\nrestlen = n;\r\n} else if (n > restlen)\r\nreturn (-114);\r\nelse\r\nrestlen = n;\r\n}\r\nwhile (restlen >= 2) {\r\nstp = st;\r\nsprintf(stp, "%d 0x%lx %d %s ", DIVERT_REPORT, ic->parm.dss1_io.ll_id,\r\ncnt++, divert_if.drv_to_name(ic->driver));\r\nstp += strlen(stp);\r\nif (*src++ != 0x30) return (-115);\r\nn = *src++;\r\nrestlen -= 2;\r\nif (n > restlen) return (-116);\r\nrestlen -= n;\r\np = src;\r\nsrc += n;\r\nif (!(n1 = put_address(stp, p, n & 0xFF))) continue;\r\nstp += strlen(stp);\r\np += n1;\r\nn -= n1;\r\nif (n < 6) continue;\r\nif ((*p++ != 0x0A) || (*p++ != 1)) continue;\r\nsprintf(stp, " 0x%02x ", (*p++) & 0xFF);\r\nstp += strlen(stp);\r\nif ((*p++ != 0x0A) || (*p++ != 1)) continue;\r\nsprintf(stp, "%d ", (*p++) & 0xFF);\r\nstp += strlen(stp);\r\nn -= 6;\r\nif (n > 2) {\r\nif (*p++ != 0x30) continue;\r\nif (*p > (n - 2)) continue;\r\nn = *p++;\r\nif (!(n1 = put_address(stp, p, n & 0xFF))) continue;\r\nstp += strlen(stp);\r\n}\r\nsprintf(stp, "\n");\r\nput_info_buffer(st);\r\n}\r\nif (restlen) return (-117);\r\nreturn (0);\r\n}\r\nstatic int prot_stat_callback(isdn_ctrl *ic)\r\n{\r\nstruct call_struc *cs, *cs1;\r\nint i;\r\nunsigned long flags;\r\ncs = divert_head;\r\ncs1 = NULL;\r\nwhile (cs) {\r\nif (ic->driver == cs->ics.driver) {\r\nswitch (cs->ics.arg) {\r\ncase DSS1_CMD_INVOKE:\r\nif ((cs->ics.parm.dss1_io.ll_id == ic->parm.dss1_io.ll_id) &&\r\n(cs->ics.parm.dss1_io.hl_id == ic->parm.dss1_io.hl_id)) {\r\nswitch (ic->arg) {\r\ncase DSS1_STAT_INVOKE_ERR:\r\nsprintf(cs->info, "128 0x%lx 0x%x\n",\r\nic->parm.dss1_io.ll_id,\r\nic->parm.dss1_io.timeout);\r\nput_info_buffer(cs->info);\r\nbreak;\r\ncase DSS1_STAT_INVOKE_RES:\r\nswitch (cs->ics.parm.dss1_io.proc) {\r\ncase 7:\r\ncase 8:\r\nput_info_buffer(cs->info);\r\nbreak;\r\ncase 11:\r\ni = interrogate_success(ic, cs);\r\nif (i)\r\nsprintf(cs->info, "%d 0x%lx %d\n", DIVERT_REPORT,\r\nic->parm.dss1_io.ll_id, i);\r\nput_info_buffer(cs->info);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "dss1_divert: unknown proc %d\n", cs->ics.parm.dss1_io.proc);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "dss1_divert unknown invoke answer %lx\n", ic->arg);\r\nbreak;\r\n}\r\ncs1 = cs;\r\ncs = NULL;\r\ncontinue;\r\n}\r\nbreak;\r\ncase DSS1_CMD_INVOKE_ABORT:\r\nprintk(KERN_WARNING "dss1_divert unhandled invoke abort\n");\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "dss1_divert unknown cmd 0x%lx\n", cs->ics.arg);\r\nbreak;\r\n}\r\ncs = cs->next;\r\n}\r\n}\r\nif (!cs1) {\r\nprintk(KERN_WARNING "dss1_divert unhandled process\n");\r\nreturn (0);\r\n}\r\nif (cs1->ics.driver == -1) {\r\nspin_lock_irqsave(&divert_lock, flags);\r\ndel_timer(&cs1->timer);\r\nif (cs1->prev)\r\ncs1->prev->next = cs1->next;\r\nelse\r\ndivert_head = cs1->next;\r\nif (cs1->next)\r\ncs1->next->prev = cs1->prev;\r\nspin_unlock_irqrestore(&divert_lock, flags);\r\nkfree(cs1);\r\n}\r\nreturn (0);\r\n}\r\nstatic int isdn_divert_stat_callback(isdn_ctrl *ic)\r\n{\r\nstruct call_struc *cs, *cs1;\r\nunsigned long flags;\r\nint retval;\r\nretval = -1;\r\ncs = divert_head;\r\nwhile (cs) {\r\nif ((ic->driver == cs->ics.driver) &&\r\n(ic->arg == cs->ics.arg)) {\r\nswitch (ic->command) {\r\ncase ISDN_STAT_DHUP:\r\nsprintf(cs->info, "129 0x%lx\n", cs->divert_id);\r\ndel_timer(&cs->timer);\r\ncs->ics.driver = -1;\r\nbreak;\r\ncase ISDN_STAT_CAUSE:\r\nsprintf(cs->info, "130 0x%lx %s\n", cs->divert_id, ic->parm.num);\r\nbreak;\r\ncase ISDN_STAT_REDIR:\r\nsprintf(cs->info, "131 0x%lx\n", cs->divert_id);\r\ndel_timer(&cs->timer);\r\ncs->ics.driver = -1;\r\nbreak;\r\ndefault:\r\nsprintf(cs->info, "999 0x%lx 0x%x\n", cs->divert_id, (int)(ic->command));\r\nbreak;\r\n}\r\nput_info_buffer(cs->info);\r\nretval = 0;\r\n}\r\ncs1 = cs;\r\ncs = cs->next;\r\nif (cs1->ics.driver == -1) {\r\nspin_lock_irqsave(&divert_lock, flags);\r\nif (cs1->prev)\r\ncs1->prev->next = cs1->next;\r\nelse\r\ndivert_head = cs1->next;\r\nif (cs1->next)\r\ncs1->next->prev = cs1->prev;\r\nspin_unlock_irqrestore(&divert_lock, flags);\r\nkfree(cs1);\r\n}\r\n}\r\nreturn (retval);\r\n}\r\nint ll_callback(isdn_ctrl *ic)\r\n{\r\nswitch (ic->command) {\r\ncase ISDN_STAT_ICALL:\r\ncase ISDN_STAT_ICALLW:\r\nreturn (isdn_divert_icall(ic));\r\nbreak;\r\ncase ISDN_STAT_PROT:\r\nif ((ic->arg & 0xFF) == ISDN_PTYPE_EURO) {\r\nif (ic->arg != DSS1_STAT_INVOKE_BRD)\r\nreturn (prot_stat_callback(ic));\r\nelse\r\nreturn (0);\r\n} else\r\nreturn (-1);\r\ndefault:\r\nreturn (isdn_divert_stat_callback(ic));\r\n}\r\n}
