static inline int aalg_entries(void)\r\n{\r\nreturn ARRAY_SIZE(aalg_list);\r\n}\r\nstatic inline int ealg_entries(void)\r\n{\r\nreturn ARRAY_SIZE(ealg_list);\r\n}\r\nstatic inline int calg_entries(void)\r\n{\r\nreturn ARRAY_SIZE(calg_list);\r\n}\r\nstatic struct xfrm_algo_desc *xfrm_find_algo(\r\nconst struct xfrm_algo_list *algo_list,\r\nint match(const struct xfrm_algo_desc *entry, const void *data),\r\nconst void *data, int probe)\r\n{\r\nstruct xfrm_algo_desc *list = algo_list->algs;\r\nint i, status;\r\nfor (i = 0; i < algo_list->entries; i++) {\r\nif (!match(list + i, data))\r\ncontinue;\r\nif (list[i].available)\r\nreturn &list[i];\r\nif (!probe)\r\nbreak;\r\nstatus = crypto_has_alg(list[i].name, algo_list->type,\r\nalgo_list->mask);\r\nif (!status)\r\nbreak;\r\nlist[i].available = status;\r\nreturn &list[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic int xfrm_alg_id_match(const struct xfrm_algo_desc *entry,\r\nconst void *data)\r\n{\r\nreturn entry->desc.sadb_alg_id == (unsigned long)data;\r\n}\r\nstruct xfrm_algo_desc *xfrm_aalg_get_byid(int alg_id)\r\n{\r\nreturn xfrm_find_algo(&xfrm_aalg_list, xfrm_alg_id_match,\r\n(void *)(unsigned long)alg_id, 1);\r\n}\r\nstruct xfrm_algo_desc *xfrm_ealg_get_byid(int alg_id)\r\n{\r\nreturn xfrm_find_algo(&xfrm_ealg_list, xfrm_alg_id_match,\r\n(void *)(unsigned long)alg_id, 1);\r\n}\r\nstruct xfrm_algo_desc *xfrm_calg_get_byid(int alg_id)\r\n{\r\nreturn xfrm_find_algo(&xfrm_calg_list, xfrm_alg_id_match,\r\n(void *)(unsigned long)alg_id, 1);\r\n}\r\nstatic int xfrm_alg_name_match(const struct xfrm_algo_desc *entry,\r\nconst void *data)\r\n{\r\nconst char *name = data;\r\nreturn name && (!strcmp(name, entry->name) ||\r\n(entry->compat && !strcmp(name, entry->compat)));\r\n}\r\nstruct xfrm_algo_desc *xfrm_aalg_get_byname(const char *name, int probe)\r\n{\r\nreturn xfrm_find_algo(&xfrm_aalg_list, xfrm_alg_name_match, name,\r\nprobe);\r\n}\r\nstruct xfrm_algo_desc *xfrm_ealg_get_byname(const char *name, int probe)\r\n{\r\nreturn xfrm_find_algo(&xfrm_ealg_list, xfrm_alg_name_match, name,\r\nprobe);\r\n}\r\nstruct xfrm_algo_desc *xfrm_calg_get_byname(const char *name, int probe)\r\n{\r\nreturn xfrm_find_algo(&xfrm_calg_list, xfrm_alg_name_match, name,\r\nprobe);\r\n}\r\nstatic int xfrm_aead_name_match(const struct xfrm_algo_desc *entry,\r\nconst void *data)\r\n{\r\nconst struct xfrm_aead_name *aead = data;\r\nconst char *name = aead->name;\r\nreturn aead->icvbits == entry->uinfo.aead.icv_truncbits && name &&\r\n!strcmp(name, entry->name);\r\n}\r\nstruct xfrm_algo_desc *xfrm_aead_get_byname(const char *name, int icv_len, int probe)\r\n{\r\nstruct xfrm_aead_name data = {\r\n.name = name,\r\n.icvbits = icv_len,\r\n};\r\nreturn xfrm_find_algo(&xfrm_aead_list, xfrm_aead_name_match, &data,\r\nprobe);\r\n}\r\nstruct xfrm_algo_desc *xfrm_aalg_get_byidx(unsigned int idx)\r\n{\r\nif (idx >= aalg_entries())\r\nreturn NULL;\r\nreturn &aalg_list[idx];\r\n}\r\nstruct xfrm_algo_desc *xfrm_ealg_get_byidx(unsigned int idx)\r\n{\r\nif (idx >= ealg_entries())\r\nreturn NULL;\r\nreturn &ealg_list[idx];\r\n}\r\nvoid xfrm_probe_algs(void)\r\n{\r\nint i, status;\r\nBUG_ON(in_softirq());\r\nfor (i = 0; i < aalg_entries(); i++) {\r\nstatus = crypto_has_hash(aalg_list[i].name, 0,\r\nCRYPTO_ALG_ASYNC);\r\nif (aalg_list[i].available != status)\r\naalg_list[i].available = status;\r\n}\r\nfor (i = 0; i < ealg_entries(); i++) {\r\nstatus = crypto_has_ablkcipher(ealg_list[i].name, 0, 0);\r\nif (ealg_list[i].available != status)\r\nealg_list[i].available = status;\r\n}\r\nfor (i = 0; i < calg_entries(); i++) {\r\nstatus = crypto_has_comp(calg_list[i].name, 0,\r\nCRYPTO_ALG_ASYNC);\r\nif (calg_list[i].available != status)\r\ncalg_list[i].available = status;\r\n}\r\n}\r\nint xfrm_count_pfkey_auth_supported(void)\r\n{\r\nint i, n;\r\nfor (i = 0, n = 0; i < aalg_entries(); i++)\r\nif (aalg_list[i].available && aalg_list[i].pfkey_supported)\r\nn++;\r\nreturn n;\r\n}\r\nint xfrm_count_pfkey_enc_supported(void)\r\n{\r\nint i, n;\r\nfor (i = 0, n = 0; i < ealg_entries(); i++)\r\nif (ealg_list[i].available && ealg_list[i].pfkey_supported)\r\nn++;\r\nreturn n;\r\n}
