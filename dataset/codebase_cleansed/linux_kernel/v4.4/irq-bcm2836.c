static void bcm2836_arm_irqchip_mask_per_cpu_irq(unsigned int reg_offset,\r\nunsigned int bit,\r\nint cpu)\r\n{\r\nvoid __iomem *reg = intc.base + reg_offset + 4 * cpu;\r\nwritel(readl(reg) & ~BIT(bit), reg);\r\n}\r\nstatic void bcm2836_arm_irqchip_unmask_per_cpu_irq(unsigned int reg_offset,\r\nunsigned int bit,\r\nint cpu)\r\n{\r\nvoid __iomem *reg = intc.base + reg_offset + 4 * cpu;\r\nwritel(readl(reg) | BIT(bit), reg);\r\n}\r\nstatic void bcm2836_arm_irqchip_mask_timer_irq(struct irq_data *d)\r\n{\r\nbcm2836_arm_irqchip_mask_per_cpu_irq(LOCAL_TIMER_INT_CONTROL0,\r\nd->hwirq - LOCAL_IRQ_CNTPSIRQ,\r\nsmp_processor_id());\r\n}\r\nstatic void bcm2836_arm_irqchip_unmask_timer_irq(struct irq_data *d)\r\n{\r\nbcm2836_arm_irqchip_unmask_per_cpu_irq(LOCAL_TIMER_INT_CONTROL0,\r\nd->hwirq - LOCAL_IRQ_CNTPSIRQ,\r\nsmp_processor_id());\r\n}\r\nstatic void bcm2836_arm_irqchip_mask_pmu_irq(struct irq_data *d)\r\n{\r\nwritel(1 << smp_processor_id(), intc.base + LOCAL_PM_ROUTING_CLR);\r\n}\r\nstatic void bcm2836_arm_irqchip_unmask_pmu_irq(struct irq_data *d)\r\n{\r\nwritel(1 << smp_processor_id(), intc.base + LOCAL_PM_ROUTING_SET);\r\n}\r\nstatic void bcm2836_arm_irqchip_mask_gpu_irq(struct irq_data *d)\r\n{\r\n}\r\nstatic void bcm2836_arm_irqchip_unmask_gpu_irq(struct irq_data *d)\r\n{\r\n}\r\nstatic void bcm2836_arm_irqchip_register_irq(int hwirq, struct irq_chip *chip)\r\n{\r\nint irq = irq_create_mapping(intc.domain, hwirq);\r\nirq_set_percpu_devid(irq);\r\nirq_set_chip_and_handler(irq, chip, handle_percpu_devid_irq);\r\nirq_set_status_flags(irq, IRQ_NOAUTOEN);\r\n}\r\nstatic void\r\n__exception_irq_entry bcm2836_arm_irqchip_handle_irq(struct pt_regs *regs)\r\n{\r\nint cpu = smp_processor_id();\r\nu32 stat;\r\nstat = readl_relaxed(intc.base + LOCAL_IRQ_PENDING0 + 4 * cpu);\r\nif (stat & 0x10) {\r\n#ifdef CONFIG_SMP\r\nvoid __iomem *mailbox0 = (intc.base +\r\nLOCAL_MAILBOX0_CLR0 + 16 * cpu);\r\nu32 mbox_val = readl(mailbox0);\r\nu32 ipi = ffs(mbox_val) - 1;\r\nwritel(1 << ipi, mailbox0);\r\nhandle_IPI(ipi, regs);\r\n#endif\r\n} else {\r\nu32 hwirq = ffs(stat) - 1;\r\nhandle_IRQ(irq_linear_revmap(intc.domain, hwirq), regs);\r\n}\r\n}\r\nstatic void bcm2836_arm_irqchip_send_ipi(const struct cpumask *mask,\r\nunsigned int ipi)\r\n{\r\nint cpu;\r\nvoid __iomem *mailbox0_base = intc.base + LOCAL_MAILBOX0_SET0;\r\ndsb();\r\nfor_each_cpu(cpu, mask) {\r\nwritel(1 << ipi, mailbox0_base + 16 * cpu);\r\n}\r\n}\r\nstatic int bcm2836_arm_irqchip_cpu_notify(struct notifier_block *nfb,\r\nunsigned long action, void *hcpu)\r\n{\r\nunsigned int cpu = (unsigned long)hcpu;\r\nunsigned int int_reg = LOCAL_MAILBOX_INT_CONTROL0;\r\nunsigned int mailbox = 0;\r\nif (action == CPU_STARTING || action == CPU_STARTING_FROZEN)\r\nbcm2836_arm_irqchip_unmask_per_cpu_irq(int_reg, mailbox, cpu);\r\nelse if (action == CPU_DYING)\r\nbcm2836_arm_irqchip_mask_per_cpu_irq(int_reg, mailbox, cpu);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void\r\nbcm2836_arm_irqchip_smp_init(void)\r\n{\r\n#ifdef CONFIG_SMP\r\nbcm2836_arm_irqchip_cpu_notify(&bcm2836_arm_irqchip_cpu_notifier,\r\nCPU_STARTING,\r\n(void *)smp_processor_id());\r\nregister_cpu_notifier(&bcm2836_arm_irqchip_cpu_notifier);\r\nset_smp_cross_call(bcm2836_arm_irqchip_send_ipi);\r\n#endif\r\n}\r\nstatic int __init bcm2836_arm_irqchip_l1_intc_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nintc.base = of_iomap(node, 0);\r\nif (!intc.base) {\r\npanic("%s: unable to map local interrupt registers\n",\r\nnode->full_name);\r\n}\r\nintc.domain = irq_domain_add_linear(node, LAST_IRQ + 1,\r\n&bcm2836_arm_irqchip_intc_ops,\r\nNULL);\r\nif (!intc.domain)\r\npanic("%s: unable to create IRQ domain\n", node->full_name);\r\nbcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTPSIRQ,\r\n&bcm2836_arm_irqchip_timer);\r\nbcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTPNSIRQ,\r\n&bcm2836_arm_irqchip_timer);\r\nbcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTHPIRQ,\r\n&bcm2836_arm_irqchip_timer);\r\nbcm2836_arm_irqchip_register_irq(LOCAL_IRQ_CNTVIRQ,\r\n&bcm2836_arm_irqchip_timer);\r\nbcm2836_arm_irqchip_register_irq(LOCAL_IRQ_GPU_FAST,\r\n&bcm2836_arm_irqchip_gpu);\r\nbcm2836_arm_irqchip_register_irq(LOCAL_IRQ_PMU_FAST,\r\n&bcm2836_arm_irqchip_pmu);\r\nbcm2836_arm_irqchip_smp_init();\r\nset_handle_irq(bcm2836_arm_irqchip_handle_irq);\r\nreturn 0;\r\n}
