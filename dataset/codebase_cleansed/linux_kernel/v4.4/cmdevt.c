static void\r\nmwifiex_init_cmd_node(struct mwifiex_private *priv,\r\nstruct cmd_ctrl_node *cmd_node,\r\nu32 cmd_oid, void *data_buf, bool sync)\r\n{\r\ncmd_node->priv = priv;\r\ncmd_node->cmd_oid = cmd_oid;\r\nif (sync) {\r\ncmd_node->wait_q_enabled = true;\r\ncmd_node->cmd_wait_q_woken = false;\r\ncmd_node->condition = &cmd_node->cmd_wait_q_woken;\r\n}\r\ncmd_node->data_buf = data_buf;\r\ncmd_node->cmd_skb = cmd_node->skb;\r\n}\r\nstatic struct cmd_ctrl_node *\r\nmwifiex_get_cmd_node(struct mwifiex_adapter *adapter)\r\n{\r\nstruct cmd_ctrl_node *cmd_node;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->cmd_free_q_lock, flags);\r\nif (list_empty(&adapter->cmd_free_q)) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"GET_CMD_NODE: cmd node not available\n");\r\nspin_unlock_irqrestore(&adapter->cmd_free_q_lock, flags);\r\nreturn NULL;\r\n}\r\ncmd_node = list_first_entry(&adapter->cmd_free_q,\r\nstruct cmd_ctrl_node, list);\r\nlist_del(&cmd_node->list);\r\nspin_unlock_irqrestore(&adapter->cmd_free_q_lock, flags);\r\nreturn cmd_node;\r\n}\r\nstatic void\r\nmwifiex_clean_cmd_node(struct mwifiex_adapter *adapter,\r\nstruct cmd_ctrl_node *cmd_node)\r\n{\r\ncmd_node->cmd_oid = 0;\r\ncmd_node->cmd_flag = 0;\r\ncmd_node->data_buf = NULL;\r\ncmd_node->wait_q_enabled = false;\r\nif (cmd_node->cmd_skb)\r\nskb_trim(cmd_node->cmd_skb, 0);\r\nif (cmd_node->resp_skb) {\r\nadapter->if_ops.cmdrsp_complete(adapter, cmd_node->resp_skb);\r\ncmd_node->resp_skb = NULL;\r\n}\r\n}\r\nstatic int mwifiex_cmd_host_cmd(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nstruct mwifiex_ds_misc_cmd *pcmd_ptr)\r\n{\r\nmemcpy(cmd, pcmd_ptr->cmd, pcmd_ptr->len);\r\nmwifiex_dbg(priv->adapter, CMD,\r\n"cmd: host cmd size = %d\n", pcmd_ptr->len);\r\nreturn 0;\r\n}\r\nstatic int mwifiex_dnld_cmd_to_fw(struct mwifiex_private *priv,\r\nstruct cmd_ctrl_node *cmd_node)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nint ret;\r\nstruct host_cmd_ds_command *host_cmd;\r\nuint16_t cmd_code;\r\nuint16_t cmd_size;\r\nunsigned long flags;\r\n__le32 tmp;\r\nif (!adapter || !cmd_node)\r\nreturn -1;\r\nhost_cmd = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\r\nif (host_cmd == NULL || host_cmd->size == 0) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"DNLD_CMD: host_cmd is null\t"\r\n"or cmd size is 0, not sending\n");\r\nif (cmd_node->wait_q_enabled)\r\nadapter->cmd_wait_q.status = -1;\r\nmwifiex_recycle_cmd_node(adapter, cmd_node);\r\nreturn -1;\r\n}\r\ncmd_code = le16_to_cpu(host_cmd->command);\r\ncmd_size = le16_to_cpu(host_cmd->size);\r\nif (adapter->hw_status == MWIFIEX_HW_STATUS_RESET &&\r\ncmd_code != HostCmd_CMD_FUNC_SHUTDOWN &&\r\ncmd_code != HostCmd_CMD_FUNC_INIT) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"DNLD_CMD: FW in reset state, ignore cmd %#x\n",\r\ncmd_code);\r\nmwifiex_recycle_cmd_node(adapter, cmd_node);\r\nqueue_work(adapter->workqueue, &adapter->main_work);\r\nreturn -1;\r\n}\r\nadapter->seq_num++;\r\nhost_cmd->seq_num = cpu_to_le16(HostCmd_SET_SEQ_NO_BSS_INFO\r\n(adapter->seq_num,\r\ncmd_node->priv->bss_num,\r\ncmd_node->priv->bss_type));\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->curr_cmd = cmd_node;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);\r\nif (cmd_node->cmd_skb->len > cmd_size)\r\nskb_trim(cmd_node->cmd_skb, cmd_size);\r\nelse if (cmd_node->cmd_skb->len < cmd_size)\r\nskb_put(cmd_node->cmd_skb, cmd_size - cmd_node->cmd_skb->len);\r\nmwifiex_dbg(adapter, CMD,\r\n"cmd: DNLD_CMD: %#x, act %#x, len %d, seqno %#x\n",\r\ncmd_code,\r\nle16_to_cpu(*(__le16 *)((u8 *)host_cmd + S_DS_GEN)),\r\ncmd_size, le16_to_cpu(host_cmd->seq_num));\r\nmwifiex_dbg_dump(adapter, CMD_D, "cmd buffer:", host_cmd, cmd_size);\r\nif (adapter->iface_type == MWIFIEX_USB) {\r\ntmp = cpu_to_le32(MWIFIEX_USB_TYPE_CMD);\r\nskb_push(cmd_node->cmd_skb, MWIFIEX_TYPE_LEN);\r\nmemcpy(cmd_node->cmd_skb->data, &tmp, MWIFIEX_TYPE_LEN);\r\nadapter->cmd_sent = true;\r\nret = adapter->if_ops.host_to_card(adapter,\r\nMWIFIEX_USB_EP_CMD_EVENT,\r\ncmd_node->cmd_skb, NULL);\r\nskb_pull(cmd_node->cmd_skb, MWIFIEX_TYPE_LEN);\r\nif (ret == -EBUSY)\r\ncmd_node->cmd_skb = NULL;\r\n} else {\r\nskb_push(cmd_node->cmd_skb, INTF_HEADER_LEN);\r\nret = adapter->if_ops.host_to_card(adapter, MWIFIEX_TYPE_CMD,\r\ncmd_node->cmd_skb, NULL);\r\nskb_pull(cmd_node->cmd_skb, INTF_HEADER_LEN);\r\n}\r\nif (ret == -1) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"DNLD_CMD: host to card failed\n");\r\nif (adapter->iface_type == MWIFIEX_USB)\r\nadapter->cmd_sent = false;\r\nif (cmd_node->wait_q_enabled)\r\nadapter->cmd_wait_q.status = -1;\r\nmwifiex_recycle_cmd_node(adapter, adapter->curr_cmd);\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->curr_cmd = NULL;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->dbg.num_cmd_host_to_card_failure++;\r\nreturn -1;\r\n}\r\nadapter->dbg.last_cmd_index =\r\n(adapter->dbg.last_cmd_index + 1) % DBG_CMD_NUM;\r\nadapter->dbg.last_cmd_id[adapter->dbg.last_cmd_index] = cmd_code;\r\nadapter->dbg.last_cmd_act[adapter->dbg.last_cmd_index] =\r\nle16_to_cpu(*(__le16 *) ((u8 *) host_cmd + S_DS_GEN));\r\ncmd_code &= HostCmd_CMD_ID_MASK;\r\nmod_timer(&adapter->cmd_timer,\r\njiffies + msecs_to_jiffies(MWIFIEX_TIMER_10S));\r\nreturn 0;\r\n}\r\nstatic int mwifiex_dnld_sleep_confirm_cmd(struct mwifiex_adapter *adapter)\r\n{\r\nint ret;\r\nstruct mwifiex_private *priv;\r\nstruct mwifiex_opt_sleep_confirm *sleep_cfm_buf =\r\n(struct mwifiex_opt_sleep_confirm *)\r\nadapter->sleep_cfm->data;\r\nstruct sk_buff *sleep_cfm_tmp;\r\n__le32 tmp;\r\npriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\r\nadapter->seq_num++;\r\nsleep_cfm_buf->seq_num =\r\ncpu_to_le16((HostCmd_SET_SEQ_NO_BSS_INFO\r\n(adapter->seq_num, priv->bss_num,\r\npriv->bss_type)));\r\nmwifiex_dbg(adapter, CMD,\r\n"cmd: DNLD_CMD: %#x, act %#x, len %d, seqno %#x\n",\r\nle16_to_cpu(sleep_cfm_buf->command),\r\nle16_to_cpu(sleep_cfm_buf->action),\r\nle16_to_cpu(sleep_cfm_buf->size),\r\nle16_to_cpu(sleep_cfm_buf->seq_num));\r\nmwifiex_dbg_dump(adapter, CMD_D, "SLEEP_CFM buffer: ", sleep_cfm_buf,\r\nle16_to_cpu(sleep_cfm_buf->size));\r\nif (adapter->iface_type == MWIFIEX_USB) {\r\nsleep_cfm_tmp =\r\ndev_alloc_skb(sizeof(struct mwifiex_opt_sleep_confirm)\r\n+ MWIFIEX_TYPE_LEN);\r\nskb_put(sleep_cfm_tmp, sizeof(struct mwifiex_opt_sleep_confirm)\r\n+ MWIFIEX_TYPE_LEN);\r\ntmp = cpu_to_le32(MWIFIEX_USB_TYPE_CMD);\r\nmemcpy(sleep_cfm_tmp->data, &tmp, MWIFIEX_TYPE_LEN);\r\nmemcpy(sleep_cfm_tmp->data + MWIFIEX_TYPE_LEN,\r\nadapter->sleep_cfm->data,\r\nsizeof(struct mwifiex_opt_sleep_confirm));\r\nret = adapter->if_ops.host_to_card(adapter,\r\nMWIFIEX_USB_EP_CMD_EVENT,\r\nsleep_cfm_tmp, NULL);\r\nif (ret != -EBUSY)\r\ndev_kfree_skb_any(sleep_cfm_tmp);\r\n} else {\r\nskb_push(adapter->sleep_cfm, INTF_HEADER_LEN);\r\nret = adapter->if_ops.host_to_card(adapter, MWIFIEX_TYPE_CMD,\r\nadapter->sleep_cfm, NULL);\r\nskb_pull(adapter->sleep_cfm, INTF_HEADER_LEN);\r\n}\r\nif (ret == -1) {\r\nmwifiex_dbg(adapter, ERROR, "SLEEP_CFM: failed\n");\r\nadapter->dbg.num_cmd_sleep_cfm_host_to_card_failure++;\r\nreturn -1;\r\n}\r\nif (!le16_to_cpu(sleep_cfm_buf->resp_ctrl))\r\nadapter->ps_state = PS_STATE_SLEEP;\r\nelse\r\nadapter->ps_state = PS_STATE_SLEEP_CFM;\r\nif (!le16_to_cpu(sleep_cfm_buf->resp_ctrl) &&\r\n(adapter->is_hs_configured &&\r\n!adapter->sleep_period.period)) {\r\nadapter->pm_wakeup_card_req = true;\r\nmwifiex_hs_activated_event(mwifiex_get_priv\r\n(adapter, MWIFIEX_BSS_ROLE_ANY), true);\r\n}\r\nreturn ret;\r\n}\r\nint mwifiex_alloc_cmd_buffer(struct mwifiex_adapter *adapter)\r\n{\r\nstruct cmd_ctrl_node *cmd_array;\r\nu32 i;\r\ncmd_array = kcalloc(MWIFIEX_NUM_OF_CMD_BUFFER,\r\nsizeof(struct cmd_ctrl_node), GFP_KERNEL);\r\nif (!cmd_array)\r\nreturn -ENOMEM;\r\nadapter->cmd_pool = cmd_array;\r\nfor (i = 0; i < MWIFIEX_NUM_OF_CMD_BUFFER; i++) {\r\ncmd_array[i].skb = dev_alloc_skb(MWIFIEX_SIZE_OF_CMD_BUFFER);\r\nif (!cmd_array[i].skb) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"unable to allocate command buffer\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nfor (i = 0; i < MWIFIEX_NUM_OF_CMD_BUFFER; i++)\r\nmwifiex_insert_cmd_to_free_q(adapter, &cmd_array[i]);\r\nreturn 0;\r\n}\r\nint mwifiex_free_cmd_buffer(struct mwifiex_adapter *adapter)\r\n{\r\nstruct cmd_ctrl_node *cmd_array;\r\nu32 i;\r\nif (!adapter->cmd_pool) {\r\nmwifiex_dbg(adapter, FATAL,\r\n"info: FREE_CMD_BUF: cmd_pool is null\n");\r\nreturn 0;\r\n}\r\ncmd_array = adapter->cmd_pool;\r\nfor (i = 0; i < MWIFIEX_NUM_OF_CMD_BUFFER; i++) {\r\nif (cmd_array[i].skb) {\r\nmwifiex_dbg(adapter, CMD,\r\n"cmd: free cmd buffer %d\n", i);\r\ndev_kfree_skb_any(cmd_array[i].skb);\r\n}\r\nif (!cmd_array[i].resp_skb)\r\ncontinue;\r\nif (adapter->iface_type == MWIFIEX_USB)\r\nadapter->if_ops.cmdrsp_complete(adapter,\r\ncmd_array[i].resp_skb);\r\nelse\r\ndev_kfree_skb_any(cmd_array[i].resp_skb);\r\n}\r\nif (adapter->cmd_pool) {\r\nmwifiex_dbg(adapter, CMD,\r\n"cmd: free cmd pool\n");\r\nkfree(adapter->cmd_pool);\r\nadapter->cmd_pool = NULL;\r\n}\r\nreturn 0;\r\n}\r\nint mwifiex_process_event(struct mwifiex_adapter *adapter)\r\n{\r\nint ret;\r\nstruct mwifiex_private *priv =\r\nmwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\r\nstruct sk_buff *skb = adapter->event_skb;\r\nu32 eventcause = adapter->event_cause;\r\nstruct mwifiex_rxinfo *rx_info;\r\nadapter->dbg.last_event_index =\r\n(adapter->dbg.last_event_index + 1) % DBG_CMD_NUM;\r\nadapter->dbg.last_event[adapter->dbg.last_event_index] =\r\n(u16) eventcause;\r\npriv = mwifiex_get_priv_by_id(adapter, EVENT_GET_BSS_NUM(eventcause),\r\nEVENT_GET_BSS_TYPE(eventcause));\r\nif (!priv)\r\npriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\r\neventcause &= EVENT_ID_MASK;\r\nadapter->event_cause = eventcause;\r\nif (skb) {\r\nrx_info = MWIFIEX_SKB_RXCB(skb);\r\nmemset(rx_info, 0, sizeof(*rx_info));\r\nrx_info->bss_num = priv->bss_num;\r\nrx_info->bss_type = priv->bss_type;\r\nmwifiex_dbg_dump(adapter, EVT_D, "Event Buf:",\r\nskb->data, skb->len);\r\n}\r\nmwifiex_dbg(adapter, EVENT, "EVENT: cause: %#x\n", eventcause);\r\nif (priv->bss_role == MWIFIEX_BSS_ROLE_UAP)\r\nret = mwifiex_process_uap_event(priv);\r\nelse\r\nret = mwifiex_process_sta_event(priv);\r\nadapter->event_cause = 0;\r\nadapter->event_skb = NULL;\r\nadapter->if_ops.event_complete(adapter, skb);\r\nreturn ret;\r\n}\r\nint mwifiex_send_cmd(struct mwifiex_private *priv, u16 cmd_no,\r\nu16 cmd_action, u32 cmd_oid, void *data_buf, bool sync)\r\n{\r\nint ret;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct cmd_ctrl_node *cmd_node;\r\nstruct host_cmd_ds_command *cmd_ptr;\r\nif (!adapter) {\r\npr_err("PREP_CMD: adapter is NULL\n");\r\nreturn -1;\r\n}\r\nif (adapter->is_suspended) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"PREP_CMD: device in suspended state\n");\r\nreturn -1;\r\n}\r\nif (adapter->hs_enabling && cmd_no != HostCmd_CMD_802_11_HS_CFG_ENH) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"PREP_CMD: host entering sleep state\n");\r\nreturn -1;\r\n}\r\nif (adapter->surprise_removed) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"PREP_CMD: card is removed\n");\r\nreturn -1;\r\n}\r\nif (adapter->is_cmd_timedout) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"PREP_CMD: FW is in bad state\n");\r\nreturn -1;\r\n}\r\nif (adapter->hw_status == MWIFIEX_HW_STATUS_RESET) {\r\nif (cmd_no != HostCmd_CMD_FUNC_INIT) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"PREP_CMD: FW in reset state\n");\r\nreturn -1;\r\n}\r\n}\r\ncmd_node = mwifiex_get_cmd_node(adapter);\r\nif (!cmd_node) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"PREP_CMD: no free cmd node\n");\r\nreturn -1;\r\n}\r\nmwifiex_init_cmd_node(priv, cmd_node, cmd_oid, data_buf, sync);\r\nif (!cmd_node->cmd_skb) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"PREP_CMD: no free cmd buf\n");\r\nreturn -1;\r\n}\r\nmemset(skb_put(cmd_node->cmd_skb, sizeof(struct host_cmd_ds_command)),\r\n0, sizeof(struct host_cmd_ds_command));\r\ncmd_ptr = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\r\ncmd_ptr->command = cpu_to_le16(cmd_no);\r\ncmd_ptr->result = 0;\r\nif (cmd_no) {\r\nswitch (cmd_no) {\r\ncase HostCmd_CMD_UAP_SYS_CONFIG:\r\ncase HostCmd_CMD_UAP_BSS_START:\r\ncase HostCmd_CMD_UAP_BSS_STOP:\r\ncase HostCmd_CMD_UAP_STA_DEAUTH:\r\ncase HOST_CMD_APCMD_SYS_RESET:\r\ncase HOST_CMD_APCMD_STA_LIST:\r\nret = mwifiex_uap_prepare_cmd(priv, cmd_no, cmd_action,\r\ncmd_oid, data_buf,\r\ncmd_ptr);\r\nbreak;\r\ndefault:\r\nret = mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\r\ncmd_oid, data_buf,\r\ncmd_ptr);\r\nbreak;\r\n}\r\n} else {\r\nret = mwifiex_cmd_host_cmd(priv, cmd_ptr, data_buf);\r\ncmd_node->cmd_flag |= CMD_F_HOSTCMD;\r\n}\r\nif (ret) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"PREP_CMD: cmd %#x preparation failed\n",\r\ncmd_no);\r\nmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\r\nreturn -1;\r\n}\r\nif (cmd_no == HostCmd_CMD_802_11_SCAN ||\r\ncmd_no == HostCmd_CMD_802_11_SCAN_EXT) {\r\nmwifiex_queue_scan_cmd(priv, cmd_node);\r\n} else {\r\nmwifiex_insert_cmd_to_pending_q(adapter, cmd_node, true);\r\nqueue_work(adapter->workqueue, &adapter->main_work);\r\nif (cmd_node->wait_q_enabled)\r\nret = mwifiex_wait_queue_complete(adapter, cmd_node);\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nmwifiex_insert_cmd_to_free_q(struct mwifiex_adapter *adapter,\r\nstruct cmd_ctrl_node *cmd_node)\r\n{\r\nunsigned long flags;\r\nif (!cmd_node)\r\nreturn;\r\nif (cmd_node->wait_q_enabled)\r\nmwifiex_complete_cmd(adapter, cmd_node);\r\nmwifiex_clean_cmd_node(adapter, cmd_node);\r\nspin_lock_irqsave(&adapter->cmd_free_q_lock, flags);\r\nlist_add_tail(&cmd_node->list, &adapter->cmd_free_q);\r\nspin_unlock_irqrestore(&adapter->cmd_free_q_lock, flags);\r\n}\r\nvoid mwifiex_recycle_cmd_node(struct mwifiex_adapter *adapter,\r\nstruct cmd_ctrl_node *cmd_node)\r\n{\r\nstruct host_cmd_ds_command *host_cmd = (void *)cmd_node->cmd_skb->data;\r\nmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\r\natomic_dec(&adapter->cmd_pending);\r\nmwifiex_dbg(adapter, CMD,\r\n"cmd: FREE_CMD: cmd=%#x, cmd_pending=%d\n",\r\nle16_to_cpu(host_cmd->command),\r\natomic_read(&adapter->cmd_pending));\r\n}\r\nvoid\r\nmwifiex_insert_cmd_to_pending_q(struct mwifiex_adapter *adapter,\r\nstruct cmd_ctrl_node *cmd_node, u32 add_tail)\r\n{\r\nstruct host_cmd_ds_command *host_cmd = NULL;\r\nu16 command;\r\nunsigned long flags;\r\nhost_cmd = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\r\nif (!host_cmd) {\r\nmwifiex_dbg(adapter, ERROR, "QUEUE_CMD: host_cmd is NULL\n");\r\nreturn;\r\n}\r\ncommand = le16_to_cpu(host_cmd->command);\r\nif (command == HostCmd_CMD_802_11_PS_MODE_ENH) {\r\nstruct host_cmd_ds_802_11_ps_mode_enh *pm =\r\n&host_cmd->params.psmode_enh;\r\nif ((le16_to_cpu(pm->action) == DIS_PS) ||\r\n(le16_to_cpu(pm->action) == DIS_AUTO_PS)) {\r\nif (adapter->ps_state != PS_STATE_AWAKE)\r\nadd_tail = false;\r\n}\r\n}\r\nspin_lock_irqsave(&adapter->cmd_pending_q_lock, flags);\r\nif (add_tail)\r\nlist_add_tail(&cmd_node->list, &adapter->cmd_pending_q);\r\nelse\r\nlist_add(&cmd_node->list, &adapter->cmd_pending_q);\r\nspin_unlock_irqrestore(&adapter->cmd_pending_q_lock, flags);\r\natomic_inc(&adapter->cmd_pending);\r\nmwifiex_dbg(adapter, CMD,\r\n"cmd: QUEUE_CMD: cmd=%#x, cmd_pending=%d\n",\r\ncommand, atomic_read(&adapter->cmd_pending));\r\n}\r\nint mwifiex_exec_next_cmd(struct mwifiex_adapter *adapter)\r\n{\r\nstruct mwifiex_private *priv;\r\nstruct cmd_ctrl_node *cmd_node;\r\nint ret = 0;\r\nstruct host_cmd_ds_command *host_cmd;\r\nunsigned long cmd_flags;\r\nunsigned long cmd_pending_q_flags;\r\nif (adapter->curr_cmd) {\r\nmwifiex_dbg(adapter, FATAL,\r\n"EXEC_NEXT_CMD: cmd in processing\n");\r\nreturn -1;\r\n}\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, cmd_flags);\r\nspin_lock_irqsave(&adapter->cmd_pending_q_lock, cmd_pending_q_flags);\r\nif (list_empty(&adapter->cmd_pending_q)) {\r\nspin_unlock_irqrestore(&adapter->cmd_pending_q_lock,\r\ncmd_pending_q_flags);\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, cmd_flags);\r\nreturn 0;\r\n}\r\ncmd_node = list_first_entry(&adapter->cmd_pending_q,\r\nstruct cmd_ctrl_node, list);\r\nspin_unlock_irqrestore(&adapter->cmd_pending_q_lock,\r\ncmd_pending_q_flags);\r\nhost_cmd = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\r\npriv = cmd_node->priv;\r\nif (adapter->ps_state != PS_STATE_AWAKE) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"%s: cannot send cmd in sleep state,\t"\r\n"this should not happen\n", __func__);\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, cmd_flags);\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&adapter->cmd_pending_q_lock, cmd_pending_q_flags);\r\nlist_del(&cmd_node->list);\r\nspin_unlock_irqrestore(&adapter->cmd_pending_q_lock,\r\ncmd_pending_q_flags);\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, cmd_flags);\r\nret = mwifiex_dnld_cmd_to_fw(priv, cmd_node);\r\npriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\r\nif (priv && (host_cmd->command !=\r\ncpu_to_le16(HostCmd_CMD_802_11_HS_CFG_ENH))) {\r\nif (adapter->hs_activated) {\r\nadapter->is_hs_configured = false;\r\nmwifiex_hs_activated_event(priv, false);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint mwifiex_process_cmdresp(struct mwifiex_adapter *adapter)\r\n{\r\nstruct host_cmd_ds_command *resp;\r\nstruct mwifiex_private *priv =\r\nmwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\r\nint ret = 0;\r\nuint16_t orig_cmdresp_no;\r\nuint16_t cmdresp_no;\r\nuint16_t cmdresp_result;\r\nunsigned long flags;\r\ndel_timer_sync(&adapter->cmd_timer);\r\nif (!adapter->curr_cmd || !adapter->curr_cmd->resp_skb) {\r\nresp = (struct host_cmd_ds_command *) adapter->upld_buf;\r\nmwifiex_dbg(adapter, ERROR,\r\n"CMD_RESP: NULL curr_cmd, %#x\n",\r\nle16_to_cpu(resp->command));\r\nreturn -1;\r\n}\r\nadapter->is_cmd_timedout = 0;\r\nresp = (struct host_cmd_ds_command *) adapter->curr_cmd->resp_skb->data;\r\nif (adapter->curr_cmd->cmd_flag & CMD_F_HOSTCMD) {\r\nstruct mwifiex_ds_misc_cmd *hostcmd;\r\nuint16_t size = le16_to_cpu(resp->size);\r\nmwifiex_dbg(adapter, INFO,\r\n"info: host cmd resp size = %d\n", size);\r\nsize = min_t(u16, size, MWIFIEX_SIZE_OF_CMD_BUFFER);\r\nif (adapter->curr_cmd->data_buf) {\r\nhostcmd = adapter->curr_cmd->data_buf;\r\nhostcmd->len = size;\r\nmemcpy(hostcmd->cmd, resp, size);\r\n}\r\n}\r\norig_cmdresp_no = le16_to_cpu(resp->command);\r\npriv = mwifiex_get_priv_by_id(adapter,\r\nHostCmd_GET_BSS_NO(le16_to_cpu(resp->seq_num)),\r\nHostCmd_GET_BSS_TYPE(le16_to_cpu(resp->seq_num)));\r\nif (!priv)\r\npriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\r\nresp->command = cpu_to_le16(orig_cmdresp_no & HostCmd_CMD_ID_MASK);\r\ncmdresp_no = le16_to_cpu(resp->command);\r\ncmdresp_result = le16_to_cpu(resp->result);\r\nadapter->dbg.last_cmd_resp_index =\r\n(adapter->dbg.last_cmd_resp_index + 1) % DBG_CMD_NUM;\r\nadapter->dbg.last_cmd_resp_id[adapter->dbg.last_cmd_resp_index] =\r\norig_cmdresp_no;\r\nmwifiex_dbg(adapter, CMD,\r\n"cmd: CMD_RESP: 0x%x, result %d, len %d, seqno 0x%x\n",\r\norig_cmdresp_no, cmdresp_result,\r\nle16_to_cpu(resp->size), le16_to_cpu(resp->seq_num));\r\nmwifiex_dbg_dump(adapter, CMD_D, "CMD_RESP buffer:", resp,\r\nle16_to_cpu(resp->size));\r\nif (!(orig_cmdresp_no & HostCmd_RET_BIT)) {\r\nmwifiex_dbg(adapter, ERROR, "CMD_RESP: invalid cmd resp\n");\r\nif (adapter->curr_cmd->wait_q_enabled)\r\nadapter->cmd_wait_q.status = -1;\r\nmwifiex_recycle_cmd_node(adapter, adapter->curr_cmd);\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->curr_cmd = NULL;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);\r\nreturn -1;\r\n}\r\nif (adapter->curr_cmd->cmd_flag & CMD_F_HOSTCMD) {\r\nadapter->curr_cmd->cmd_flag &= ~CMD_F_HOSTCMD;\r\nif ((cmdresp_result == HostCmd_RESULT_OK) &&\r\n(cmdresp_no == HostCmd_CMD_802_11_HS_CFG_ENH))\r\nret = mwifiex_ret_802_11_hs_cfg(priv, resp);\r\n} else {\r\nret = mwifiex_process_sta_cmdresp(priv, cmdresp_no, resp);\r\n}\r\nif (adapter->hw_status == MWIFIEX_HW_STATUS_INITIALIZING) {\r\nif (ret) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"%s: cmd %#x failed during\t"\r\n"initialization\n", __func__, cmdresp_no);\r\nmwifiex_init_fw_complete(adapter);\r\nreturn -1;\r\n} else if (adapter->last_init_cmd == cmdresp_no)\r\nadapter->hw_status = MWIFIEX_HW_STATUS_INIT_DONE;\r\n}\r\nif (adapter->curr_cmd) {\r\nif (adapter->curr_cmd->wait_q_enabled)\r\nadapter->cmd_wait_q.status = ret;\r\nmwifiex_recycle_cmd_node(adapter, adapter->curr_cmd);\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->curr_cmd = NULL;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nmwifiex_cmd_timeout_func(unsigned long function_context)\r\n{\r\nstruct mwifiex_adapter *adapter =\r\n(struct mwifiex_adapter *) function_context;\r\nstruct cmd_ctrl_node *cmd_node;\r\nadapter->is_cmd_timedout = 1;\r\nif (!adapter->curr_cmd) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"cmd: empty curr_cmd\n");\r\nreturn;\r\n}\r\ncmd_node = adapter->curr_cmd;\r\nif (cmd_node) {\r\nadapter->dbg.timeout_cmd_id =\r\nadapter->dbg.last_cmd_id[adapter->dbg.last_cmd_index];\r\nadapter->dbg.timeout_cmd_act =\r\nadapter->dbg.last_cmd_act[adapter->dbg.last_cmd_index];\r\nmwifiex_dbg(adapter, MSG,\r\n"%s: Timeout cmd id = %#x, act = %#x\n", __func__,\r\nadapter->dbg.timeout_cmd_id,\r\nadapter->dbg.timeout_cmd_act);\r\nmwifiex_dbg(adapter, MSG,\r\n"num_data_h2c_failure = %d\n",\r\nadapter->dbg.num_tx_host_to_card_failure);\r\nmwifiex_dbg(adapter, MSG,\r\n"num_cmd_h2c_failure = %d\n",\r\nadapter->dbg.num_cmd_host_to_card_failure);\r\nmwifiex_dbg(adapter, MSG,\r\n"is_cmd_timedout = %d\n",\r\nadapter->is_cmd_timedout);\r\nmwifiex_dbg(adapter, MSG,\r\n"num_tx_timeout = %d\n",\r\nadapter->dbg.num_tx_timeout);\r\nmwifiex_dbg(adapter, MSG,\r\n"last_cmd_index = %d\n",\r\nadapter->dbg.last_cmd_index);\r\nmwifiex_dbg(adapter, MSG,\r\n"last_cmd_id: %*ph\n",\r\n(int)sizeof(adapter->dbg.last_cmd_id),\r\nadapter->dbg.last_cmd_id);\r\nmwifiex_dbg(adapter, MSG,\r\n"last_cmd_act: %*ph\n",\r\n(int)sizeof(adapter->dbg.last_cmd_act),\r\nadapter->dbg.last_cmd_act);\r\nmwifiex_dbg(adapter, MSG,\r\n"last_cmd_resp_index = %d\n",\r\nadapter->dbg.last_cmd_resp_index);\r\nmwifiex_dbg(adapter, MSG,\r\n"last_cmd_resp_id: %*ph\n",\r\n(int)sizeof(adapter->dbg.last_cmd_resp_id),\r\nadapter->dbg.last_cmd_resp_id);\r\nmwifiex_dbg(adapter, MSG,\r\n"last_event_index = %d\n",\r\nadapter->dbg.last_event_index);\r\nmwifiex_dbg(adapter, MSG,\r\n"last_event: %*ph\n",\r\n(int)sizeof(adapter->dbg.last_event),\r\nadapter->dbg.last_event);\r\nmwifiex_dbg(adapter, MSG,\r\n"data_sent=%d cmd_sent=%d\n",\r\nadapter->data_sent, adapter->cmd_sent);\r\nmwifiex_dbg(adapter, MSG,\r\n"ps_mode=%d ps_state=%d\n",\r\nadapter->ps_mode, adapter->ps_state);\r\nif (cmd_node->wait_q_enabled) {\r\nadapter->cmd_wait_q.status = -ETIMEDOUT;\r\nmwifiex_cancel_pending_ioctl(adapter);\r\n}\r\n}\r\nif (adapter->hw_status == MWIFIEX_HW_STATUS_INITIALIZING) {\r\nmwifiex_init_fw_complete(adapter);\r\nreturn;\r\n}\r\nif (adapter->if_ops.device_dump)\r\nadapter->if_ops.device_dump(adapter);\r\nif (adapter->if_ops.card_reset)\r\nadapter->if_ops.card_reset(adapter);\r\n}\r\nvoid\r\nmwifiex_cancel_all_pending_cmd(struct mwifiex_adapter *adapter)\r\n{\r\nstruct cmd_ctrl_node *cmd_node = NULL, *tmp_node;\r\nunsigned long flags, cmd_flags;\r\nstruct mwifiex_private *priv;\r\nint i;\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, cmd_flags);\r\nif ((adapter->curr_cmd) && (adapter->curr_cmd->wait_q_enabled)) {\r\nadapter->curr_cmd->wait_q_enabled = false;\r\nadapter->cmd_wait_q.status = -1;\r\nmwifiex_complete_cmd(adapter, adapter->curr_cmd);\r\n}\r\nspin_lock_irqsave(&adapter->cmd_pending_q_lock, flags);\r\nlist_for_each_entry_safe(cmd_node, tmp_node,\r\n&adapter->cmd_pending_q, list) {\r\nlist_del(&cmd_node->list);\r\nspin_unlock_irqrestore(&adapter->cmd_pending_q_lock, flags);\r\nif (cmd_node->wait_q_enabled)\r\nadapter->cmd_wait_q.status = -1;\r\nmwifiex_recycle_cmd_node(adapter, cmd_node);\r\nspin_lock_irqsave(&adapter->cmd_pending_q_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&adapter->cmd_pending_q_lock, flags);\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, cmd_flags);\r\nspin_lock_irqsave(&adapter->scan_pending_q_lock, flags);\r\nlist_for_each_entry_safe(cmd_node, tmp_node,\r\n&adapter->scan_pending_q, list) {\r\nlist_del(&cmd_node->list);\r\ncmd_node->wait_q_enabled = false;\r\nmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\r\n}\r\nspin_unlock_irqrestore(&adapter->scan_pending_q_lock, flags);\r\nif (adapter->scan_processing) {\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, cmd_flags);\r\nadapter->scan_processing = false;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, cmd_flags);\r\nfor (i = 0; i < adapter->priv_num; i++) {\r\npriv = adapter->priv[i];\r\nif (!priv)\r\ncontinue;\r\nif (priv->scan_request) {\r\nmwifiex_dbg(adapter, WARN, "info: aborting scan\n");\r\ncfg80211_scan_done(priv->scan_request, 1);\r\npriv->scan_request = NULL;\r\n}\r\n}\r\n}\r\n}\r\nvoid\r\nmwifiex_cancel_pending_ioctl(struct mwifiex_adapter *adapter)\r\n{\r\nstruct cmd_ctrl_node *cmd_node = NULL, *tmp_node = NULL;\r\nunsigned long cmd_flags;\r\nunsigned long scan_pending_q_flags;\r\nstruct mwifiex_private *priv;\r\nint i;\r\nif ((adapter->curr_cmd) &&\r\n(adapter->curr_cmd->wait_q_enabled)) {\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, cmd_flags);\r\ncmd_node = adapter->curr_cmd;\r\nadapter->curr_cmd = NULL;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, cmd_flags);\r\nmwifiex_recycle_cmd_node(adapter, cmd_node);\r\n}\r\nspin_lock_irqsave(&adapter->scan_pending_q_lock,\r\nscan_pending_q_flags);\r\nlist_for_each_entry_safe(cmd_node, tmp_node,\r\n&adapter->scan_pending_q, list) {\r\nlist_del(&cmd_node->list);\r\ncmd_node->wait_q_enabled = false;\r\nmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\r\n}\r\nspin_unlock_irqrestore(&adapter->scan_pending_q_lock,\r\nscan_pending_q_flags);\r\nif (adapter->scan_processing) {\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, cmd_flags);\r\nadapter->scan_processing = false;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, cmd_flags);\r\nfor (i = 0; i < adapter->priv_num; i++) {\r\npriv = adapter->priv[i];\r\nif (!priv)\r\ncontinue;\r\nif (priv->scan_request) {\r\nmwifiex_dbg(adapter, WARN, "info: aborting scan\n");\r\ncfg80211_scan_done(priv->scan_request, 1);\r\npriv->scan_request = NULL;\r\n}\r\n}\r\n}\r\n}\r\nvoid\r\nmwifiex_check_ps_cond(struct mwifiex_adapter *adapter)\r\n{\r\nif (!adapter->cmd_sent &&\r\n!adapter->curr_cmd && !IS_CARD_RX_RCVD(adapter))\r\nmwifiex_dnld_sleep_confirm_cmd(adapter);\r\nelse\r\nmwifiex_dbg(adapter, CMD,\r\n"cmd: Delay Sleep Confirm (%s%s%s)\n",\r\n(adapter->cmd_sent) ? "D" : "",\r\n(adapter->curr_cmd) ? "C" : "",\r\n(IS_CARD_RX_RCVD(adapter)) ? "R" : "");\r\n}\r\nvoid\r\nmwifiex_hs_activated_event(struct mwifiex_private *priv, u8 activated)\r\n{\r\nif (activated) {\r\nif (priv->adapter->is_hs_configured) {\r\npriv->adapter->hs_activated = true;\r\nmwifiex_update_rxreor_flags(priv->adapter,\r\nRXREOR_FORCE_NO_DROP);\r\nmwifiex_dbg(priv->adapter, EVENT,\r\n"event: hs_activated\n");\r\npriv->adapter->hs_activate_wait_q_woken = true;\r\nwake_up_interruptible(\r\n&priv->adapter->hs_activate_wait_q);\r\n} else {\r\nmwifiex_dbg(priv->adapter, EVENT,\r\n"event: HS not configured\n");\r\n}\r\n} else {\r\nmwifiex_dbg(priv->adapter, EVENT,\r\n"event: hs_deactivated\n");\r\npriv->adapter->hs_activated = false;\r\n}\r\n}\r\nint mwifiex_ret_802_11_hs_cfg(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct host_cmd_ds_802_11_hs_cfg_enh *phs_cfg =\r\n&resp->params.opt_hs_cfg;\r\nuint32_t conditions = le32_to_cpu(phs_cfg->params.hs_config.conditions);\r\nif (phs_cfg->action == cpu_to_le16(HS_ACTIVATE) &&\r\nadapter->iface_type != MWIFIEX_USB) {\r\nmwifiex_hs_activated_event(priv, true);\r\nreturn 0;\r\n} else {\r\nmwifiex_dbg(adapter, CMD,\r\n"cmd: CMD_RESP: HS_CFG cmd reply\t"\r\n" result=%#x, conditions=0x%x gpio=0x%x gap=0x%x\n",\r\nresp->result, conditions,\r\nphs_cfg->params.hs_config.gpio,\r\nphs_cfg->params.hs_config.gap);\r\n}\r\nif (conditions != HS_CFG_CANCEL) {\r\nadapter->is_hs_configured = true;\r\nif (adapter->iface_type == MWIFIEX_USB)\r\nmwifiex_hs_activated_event(priv, true);\r\n} else {\r\nadapter->is_hs_configured = false;\r\nif (adapter->hs_activated)\r\nmwifiex_hs_activated_event(priv, false);\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nmwifiex_process_hs_config(struct mwifiex_adapter *adapter)\r\n{\r\nmwifiex_dbg(adapter, INFO,\r\n"info: %s: auto cancelling host sleep\t"\r\n"since there is interrupt from the firmware\n",\r\n__func__);\r\nadapter->if_ops.wakeup(adapter);\r\nadapter->hs_activated = false;\r\nadapter->is_hs_configured = false;\r\nadapter->is_suspended = false;\r\nmwifiex_hs_activated_event(mwifiex_get_priv(adapter,\r\nMWIFIEX_BSS_ROLE_ANY),\r\nfalse);\r\n}\r\nvoid\r\nmwifiex_process_sleep_confirm_resp(struct mwifiex_adapter *adapter,\r\nu8 *pbuf, u32 upld_len)\r\n{\r\nstruct host_cmd_ds_command *cmd = (struct host_cmd_ds_command *) pbuf;\r\nstruct mwifiex_private *priv =\r\nmwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\r\nuint16_t result = le16_to_cpu(cmd->result);\r\nuint16_t command = le16_to_cpu(cmd->command);\r\nuint16_t seq_num = le16_to_cpu(cmd->seq_num);\r\nif (!upld_len) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"%s: cmd size is 0\n", __func__);\r\nreturn;\r\n}\r\nmwifiex_dbg(adapter, CMD,\r\n"cmd: CMD_RESP: 0x%x, result %d, len %d, seqno 0x%x\n",\r\ncommand, result, le16_to_cpu(cmd->size), seq_num);\r\npriv = mwifiex_get_priv_by_id(adapter, HostCmd_GET_BSS_NO(seq_num),\r\nHostCmd_GET_BSS_TYPE(seq_num));\r\nif (!priv)\r\npriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\r\nseq_num = HostCmd_GET_SEQ_NO(seq_num);\r\ncommand &= HostCmd_CMD_ID_MASK;\r\nif (command != HostCmd_CMD_802_11_PS_MODE_ENH) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"%s: rcvd unexpected resp for cmd %#x, result = %x\n",\r\n__func__, command, result);\r\nreturn;\r\n}\r\nif (result) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"%s: sleep confirm cmd failed\n",\r\n__func__);\r\nadapter->pm_wakeup_card_req = false;\r\nadapter->ps_state = PS_STATE_AWAKE;\r\nreturn;\r\n}\r\nadapter->pm_wakeup_card_req = true;\r\nif (adapter->is_hs_configured)\r\nmwifiex_hs_activated_event(mwifiex_get_priv\r\n(adapter, MWIFIEX_BSS_ROLE_ANY),\r\ntrue);\r\nadapter->ps_state = PS_STATE_SLEEP;\r\ncmd->command = cpu_to_le16(command);\r\ncmd->seq_num = cpu_to_le16(seq_num);\r\n}\r\nint mwifiex_cmd_enh_power_mode(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nu16 cmd_action, uint16_t ps_bitmap,\r\nstruct mwifiex_ds_auto_ds *auto_ds)\r\n{\r\nstruct host_cmd_ds_802_11_ps_mode_enh *psmode_enh =\r\n&cmd->params.psmode_enh;\r\nu8 *tlv;\r\nu16 cmd_size = 0;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11_PS_MODE_ENH);\r\nif (cmd_action == DIS_AUTO_PS) {\r\npsmode_enh->action = cpu_to_le16(DIS_AUTO_PS);\r\npsmode_enh->params.ps_bitmap = cpu_to_le16(ps_bitmap);\r\ncmd->size = cpu_to_le16(S_DS_GEN + sizeof(psmode_enh->action) +\r\nsizeof(psmode_enh->params.ps_bitmap));\r\n} else if (cmd_action == GET_PS) {\r\npsmode_enh->action = cpu_to_le16(GET_PS);\r\npsmode_enh->params.ps_bitmap = cpu_to_le16(ps_bitmap);\r\ncmd->size = cpu_to_le16(S_DS_GEN + sizeof(psmode_enh->action) +\r\nsizeof(psmode_enh->params.ps_bitmap));\r\n} else if (cmd_action == EN_AUTO_PS) {\r\npsmode_enh->action = cpu_to_le16(EN_AUTO_PS);\r\npsmode_enh->params.ps_bitmap = cpu_to_le16(ps_bitmap);\r\ncmd_size = S_DS_GEN + sizeof(psmode_enh->action) +\r\nsizeof(psmode_enh->params.ps_bitmap);\r\ntlv = (u8 *) cmd + cmd_size;\r\nif (ps_bitmap & BITMAP_STA_PS) {\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct mwifiex_ie_types_ps_param *ps_tlv =\r\n(struct mwifiex_ie_types_ps_param *) tlv;\r\nstruct mwifiex_ps_param *ps_mode = &ps_tlv->param;\r\nps_tlv->header.type = cpu_to_le16(TLV_TYPE_PS_PARAM);\r\nps_tlv->header.len = cpu_to_le16(sizeof(*ps_tlv) -\r\nsizeof(struct mwifiex_ie_types_header));\r\ncmd_size += sizeof(*ps_tlv);\r\ntlv += sizeof(*ps_tlv);\r\nmwifiex_dbg(priv->adapter, CMD,\r\n"cmd: PS Command: Enter PS\n");\r\nps_mode->null_pkt_interval =\r\ncpu_to_le16(adapter->null_pkt_interval);\r\nps_mode->multiple_dtims =\r\ncpu_to_le16(adapter->multiple_dtim);\r\nps_mode->bcn_miss_timeout =\r\ncpu_to_le16(adapter->bcn_miss_time_out);\r\nps_mode->local_listen_interval =\r\ncpu_to_le16(adapter->local_listen_interval);\r\nps_mode->adhoc_wake_period =\r\ncpu_to_le16(adapter->adhoc_awake_period);\r\nps_mode->delay_to_ps =\r\ncpu_to_le16(adapter->delay_to_ps);\r\nps_mode->mode = cpu_to_le16(adapter->enhanced_ps_mode);\r\n}\r\nif (ps_bitmap & BITMAP_AUTO_DS) {\r\nstruct mwifiex_ie_types_auto_ds_param *auto_ds_tlv =\r\n(struct mwifiex_ie_types_auto_ds_param *) tlv;\r\nu16 idletime = 0;\r\nauto_ds_tlv->header.type =\r\ncpu_to_le16(TLV_TYPE_AUTO_DS_PARAM);\r\nauto_ds_tlv->header.len =\r\ncpu_to_le16(sizeof(*auto_ds_tlv) -\r\nsizeof(struct mwifiex_ie_types_header));\r\ncmd_size += sizeof(*auto_ds_tlv);\r\ntlv += sizeof(*auto_ds_tlv);\r\nif (auto_ds)\r\nidletime = auto_ds->idle_time;\r\nmwifiex_dbg(priv->adapter, CMD,\r\n"cmd: PS Command: Enter Auto Deep Sleep\n");\r\nauto_ds_tlv->deep_sleep_timeout = cpu_to_le16(idletime);\r\n}\r\ncmd->size = cpu_to_le16(cmd_size);\r\n}\r\nreturn 0;\r\n}\r\nint mwifiex_ret_enh_power_mode(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp,\r\nstruct mwifiex_ds_pm_cfg *pm_cfg)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct host_cmd_ds_802_11_ps_mode_enh *ps_mode =\r\n&resp->params.psmode_enh;\r\nuint16_t action = le16_to_cpu(ps_mode->action);\r\nuint16_t ps_bitmap = le16_to_cpu(ps_mode->params.ps_bitmap);\r\nuint16_t auto_ps_bitmap =\r\nle16_to_cpu(ps_mode->params.ps_bitmap);\r\nmwifiex_dbg(adapter, INFO,\r\n"info: %s: PS_MODE cmd reply result=%#x action=%#X\n",\r\n__func__, resp->result, action);\r\nif (action == EN_AUTO_PS) {\r\nif (auto_ps_bitmap & BITMAP_AUTO_DS) {\r\nmwifiex_dbg(adapter, CMD,\r\n"cmd: Enabled auto deep sleep\n");\r\npriv->adapter->is_deep_sleep = true;\r\n}\r\nif (auto_ps_bitmap & BITMAP_STA_PS) {\r\nmwifiex_dbg(adapter, CMD,\r\n"cmd: Enabled STA power save\n");\r\nif (adapter->sleep_period.period)\r\nmwifiex_dbg(adapter, CMD,\r\n"cmd: set to uapsd/pps mode\n");\r\n}\r\n} else if (action == DIS_AUTO_PS) {\r\nif (ps_bitmap & BITMAP_AUTO_DS) {\r\npriv->adapter->is_deep_sleep = false;\r\nmwifiex_dbg(adapter, CMD,\r\n"cmd: Disabled auto deep sleep\n");\r\n}\r\nif (ps_bitmap & BITMAP_STA_PS) {\r\nmwifiex_dbg(adapter, CMD,\r\n"cmd: Disabled STA power save\n");\r\nif (adapter->sleep_period.period) {\r\nadapter->delay_null_pkt = false;\r\nadapter->tx_lock_flag = false;\r\nadapter->pps_uapsd_mode = false;\r\n}\r\n}\r\n} else if (action == GET_PS) {\r\nif (ps_bitmap & BITMAP_STA_PS)\r\nadapter->ps_mode = MWIFIEX_802_11_POWER_MODE_PSP;\r\nelse\r\nadapter->ps_mode = MWIFIEX_802_11_POWER_MODE_CAM;\r\nmwifiex_dbg(adapter, CMD,\r\n"cmd: ps_bitmap=%#x\n", ps_bitmap);\r\nif (pm_cfg) {\r\nif (ps_bitmap & BITMAP_STA_PS)\r\npm_cfg->param.ps_mode = 1;\r\nelse\r\npm_cfg->param.ps_mode = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint mwifiex_cmd_get_hw_spec(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd)\r\n{\r\nstruct host_cmd_ds_get_hw_spec *hw_spec = &cmd->params.hw_spec;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_GET_HW_SPEC);\r\ncmd->size =\r\ncpu_to_le16(sizeof(struct host_cmd_ds_get_hw_spec) + S_DS_GEN);\r\nmemcpy(hw_spec->permanent_addr, priv->curr_addr, ETH_ALEN);\r\nreturn 0;\r\n}\r\nint mwifiex_ret_get_hw_spec(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct host_cmd_ds_get_hw_spec *hw_spec = &resp->params.hw_spec;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct mwifiex_ie_types_header *tlv;\r\nstruct hw_spec_api_rev *api_rev;\r\nu16 resp_size, api_id;\r\nint i, left_len, parsed_len = 0;\r\nadapter->fw_cap_info = le32_to_cpu(hw_spec->fw_cap_info);\r\nif (IS_SUPPORT_MULTI_BANDS(adapter))\r\nadapter->fw_bands = (u8) GET_FW_DEFAULT_BANDS(adapter);\r\nelse\r\nadapter->fw_bands = BAND_B;\r\nadapter->config_bands = adapter->fw_bands;\r\nif (adapter->fw_bands & BAND_A) {\r\nif (adapter->fw_bands & BAND_GN) {\r\nadapter->config_bands |= BAND_AN;\r\nadapter->fw_bands |= BAND_AN;\r\n}\r\nif (adapter->fw_bands & BAND_AN) {\r\nadapter->adhoc_start_band = BAND_A | BAND_AN;\r\nadapter->adhoc_11n_enabled = true;\r\n} else {\r\nadapter->adhoc_start_band = BAND_A;\r\n}\r\npriv->adhoc_channel = DEFAULT_AD_HOC_CHANNEL_A;\r\n} else if (adapter->fw_bands & BAND_GN) {\r\nadapter->adhoc_start_band = BAND_G | BAND_B | BAND_GN;\r\npriv->adhoc_channel = DEFAULT_AD_HOC_CHANNEL;\r\nadapter->adhoc_11n_enabled = true;\r\n} else if (adapter->fw_bands & BAND_G) {\r\nadapter->adhoc_start_band = BAND_G | BAND_B;\r\npriv->adhoc_channel = DEFAULT_AD_HOC_CHANNEL;\r\n} else if (adapter->fw_bands & BAND_B) {\r\nadapter->adhoc_start_band = BAND_B;\r\npriv->adhoc_channel = DEFAULT_AD_HOC_CHANNEL;\r\n}\r\nadapter->fw_release_number = le32_to_cpu(hw_spec->fw_release_number);\r\nadapter->fw_api_ver = (adapter->fw_release_number >> 16) & 0xff;\r\nadapter->number_of_antenna = le16_to_cpu(hw_spec->number_of_antenna);\r\nif (le32_to_cpu(hw_spec->dot_11ac_dev_cap)) {\r\nadapter->is_hw_11ac_capable = true;\r\nadapter->hw_dot_11ac_dev_cap =\r\nle32_to_cpu(hw_spec->dot_11ac_dev_cap);\r\nadapter->usr_dot_11ac_dev_cap_bg = adapter->hw_dot_11ac_dev_cap\r\n& ~MWIFIEX_DEF_11AC_CAP_BF_RESET_MASK;\r\nadapter->usr_dot_11ac_dev_cap_a = adapter->hw_dot_11ac_dev_cap\r\n& ~MWIFIEX_DEF_11AC_CAP_BF_RESET_MASK;\r\nadapter->hw_dot_11ac_mcs_support =\r\nle32_to_cpu(hw_spec->dot_11ac_mcs_support);\r\nadapter->usr_dot_11ac_mcs_support =\r\nadapter->hw_dot_11ac_mcs_support;\r\n} else {\r\nadapter->is_hw_11ac_capable = false;\r\n}\r\nresp_size = le16_to_cpu(resp->size) - S_DS_GEN;\r\nif (resp_size > sizeof(struct host_cmd_ds_get_hw_spec)) {\r\nleft_len = resp_size - sizeof(struct host_cmd_ds_get_hw_spec);\r\nwhile (left_len > sizeof(struct mwifiex_ie_types_header)) {\r\ntlv = (void *)&hw_spec->tlvs + parsed_len;\r\nswitch (le16_to_cpu(tlv->type)) {\r\ncase TLV_TYPE_API_REV:\r\napi_rev = (struct hw_spec_api_rev *)tlv;\r\napi_id = le16_to_cpu(api_rev->api_id);\r\nswitch (api_id) {\r\ncase KEY_API_VER_ID:\r\nadapter->key_api_major_ver =\r\napi_rev->major_ver;\r\nadapter->key_api_minor_ver =\r\napi_rev->minor_ver;\r\nmwifiex_dbg(adapter, INFO,\r\n"key_api v%d.%d\n",\r\nadapter->key_api_major_ver,\r\nadapter->key_api_minor_ver);\r\nbreak;\r\ncase FW_API_VER_ID:\r\nadapter->fw_api_ver =\r\napi_rev->major_ver;\r\nmwifiex_dbg(adapter, INFO,\r\n"Firmware api version %d\n",\r\nadapter->fw_api_ver);\r\nbreak;\r\ndefault:\r\nmwifiex_dbg(adapter, FATAL,\r\n"Unknown api_id: %d\n",\r\napi_id);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nmwifiex_dbg(adapter, FATAL,\r\n"Unknown GET_HW_SPEC TLV type: %#x\n",\r\nle16_to_cpu(tlv->type));\r\nbreak;\r\n}\r\nparsed_len += le16_to_cpu(tlv->len) +\r\nsizeof(struct mwifiex_ie_types_header);\r\nleft_len -= le16_to_cpu(tlv->len) +\r\nsizeof(struct mwifiex_ie_types_header);\r\n}\r\n}\r\nmwifiex_dbg(adapter, INFO,\r\n"info: GET_HW_SPEC: fw_release_number- %#x\n",\r\nadapter->fw_release_number);\r\nmwifiex_dbg(adapter, INFO,\r\n"info: GET_HW_SPEC: permanent addr: %pM\n",\r\nhw_spec->permanent_addr);\r\nmwifiex_dbg(adapter, INFO,\r\n"info: GET_HW_SPEC: hw_if_version=%#x version=%#x\n",\r\nle16_to_cpu(hw_spec->hw_if_version),\r\nle16_to_cpu(hw_spec->version));\r\nether_addr_copy(priv->adapter->perm_addr, hw_spec->permanent_addr);\r\nadapter->region_code = le16_to_cpu(hw_spec->region_code);\r\nfor (i = 0; i < MWIFIEX_MAX_REGION_CODE; i++)\r\nif (adapter->region_code == region_code_index[i])\r\nbreak;\r\nif (i >= MWIFIEX_MAX_REGION_CODE) {\r\nadapter->region_code = 0x10;\r\nmwifiex_dbg(adapter, WARN,\r\n"cmd: unknown region code, use default (USA)\n");\r\n}\r\nadapter->hw_dot_11n_dev_cap = le32_to_cpu(hw_spec->dot_11n_dev_cap);\r\nadapter->hw_dev_mcs_support = hw_spec->dev_mcs_support;\r\nadapter->user_dev_mcs_support = adapter->hw_dev_mcs_support;\r\nif (adapter->if_ops.update_mp_end_port)\r\nadapter->if_ops.update_mp_end_port(adapter,\r\nle16_to_cpu(hw_spec->mp_end_port));\r\nif (adapter->fw_api_ver == MWIFIEX_FW_V15)\r\nadapter->scan_chan_gap_enabled = true;\r\nreturn 0;\r\n}
