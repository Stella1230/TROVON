struct cxl_context *cxl_dev_context_init(struct pci_dev *dev)\r\n{\r\nstruct address_space *mapping;\r\nstruct cxl_afu *afu;\r\nstruct cxl_context *ctx;\r\nint rc;\r\nafu = cxl_pci_to_afu(dev);\r\nget_device(&afu->dev);\r\nctx = cxl_context_alloc();\r\nif (IS_ERR(ctx)) {\r\nrc = PTR_ERR(ctx);\r\ngoto err_dev;\r\n}\r\nctx->kernelapi = true;\r\nmapping = kmalloc(sizeof(struct address_space), GFP_KERNEL);\r\nif (!mapping) {\r\nrc = -ENOMEM;\r\ngoto err_ctx;\r\n}\r\naddress_space_init_once(mapping);\r\nrc = cxl_context_init(ctx, afu, false, mapping);\r\nif (rc)\r\ngoto err_mapping;\r\ncxl_assign_psn_space(ctx);\r\nreturn ctx;\r\nerr_mapping:\r\nkfree(mapping);\r\nerr_ctx:\r\nkfree(ctx);\r\nerr_dev:\r\nput_device(&afu->dev);\r\nreturn ERR_PTR(rc);\r\n}\r\nstruct cxl_context *cxl_get_context(struct pci_dev *dev)\r\n{\r\nreturn dev->dev.archdata.cxl_ctx;\r\n}\r\nstruct device *cxl_get_phys_dev(struct pci_dev *dev)\r\n{\r\nstruct cxl_afu *afu;\r\nafu = cxl_pci_to_afu(dev);\r\nreturn afu->adapter->dev.parent;\r\n}\r\nint cxl_release_context(struct cxl_context *ctx)\r\n{\r\nif (ctx->status >= STARTED)\r\nreturn -EBUSY;\r\nput_device(&ctx->afu->dev);\r\ncxl_context_free(ctx);\r\nreturn 0;\r\n}\r\nint cxl_allocate_afu_irqs(struct cxl_context *ctx, int num)\r\n{\r\nif (num == 0)\r\nnum = ctx->afu->pp_irqs;\r\nreturn afu_allocate_irqs(ctx, num);\r\n}\r\nvoid cxl_free_afu_irqs(struct cxl_context *ctx)\r\n{\r\nafu_irq_name_free(ctx);\r\ncxl_release_irq_ranges(&ctx->irqs, ctx->afu->adapter);\r\n}\r\nstatic irq_hw_number_t cxl_find_afu_irq(struct cxl_context *ctx, int num)\r\n{\r\n__u16 range;\r\nint r;\r\nWARN_ON(num == 0);\r\nfor (r = 0; r < CXL_IRQ_RANGES; r++) {\r\nrange = ctx->irqs.range[r];\r\nif (num < range) {\r\nreturn ctx->irqs.offset[r] + num;\r\n}\r\nnum -= range;\r\n}\r\nreturn 0;\r\n}\r\nint cxl_map_afu_irq(struct cxl_context *ctx, int num,\r\nirq_handler_t handler, void *cookie, char *name)\r\n{\r\nirq_hw_number_t hwirq;\r\nhwirq = cxl_find_afu_irq(ctx, num);\r\nif (!hwirq)\r\nreturn -ENOENT;\r\nreturn cxl_map_irq(ctx->afu->adapter, hwirq, handler, cookie, name);\r\n}\r\nvoid cxl_unmap_afu_irq(struct cxl_context *ctx, int num, void *cookie)\r\n{\r\nirq_hw_number_t hwirq;\r\nunsigned int virq;\r\nhwirq = cxl_find_afu_irq(ctx, num);\r\nif (!hwirq)\r\nreturn;\r\nvirq = irq_find_mapping(NULL, hwirq);\r\nif (virq)\r\ncxl_unmap_irq(virq, cookie);\r\n}\r\nint cxl_start_context(struct cxl_context *ctx, u64 wed,\r\nstruct task_struct *task)\r\n{\r\nint rc = 0;\r\nbool kernel = true;\r\npr_devel("%s: pe: %i\n", __func__, ctx->pe);\r\nmutex_lock(&ctx->status_mutex);\r\nif (ctx->status == STARTED)\r\ngoto out;\r\nif (task) {\r\nctx->pid = get_task_pid(task, PIDTYPE_PID);\r\nget_pid(ctx->pid);\r\nkernel = false;\r\n}\r\ncxl_ctx_get();\r\nif ((rc = cxl_attach_process(ctx, kernel, wed , 0))) {\r\nput_pid(ctx->pid);\r\ncxl_ctx_put();\r\ngoto out;\r\n}\r\nctx->status = STARTED;\r\nout:\r\nmutex_unlock(&ctx->status_mutex);\r\nreturn rc;\r\n}\r\nint cxl_process_element(struct cxl_context *ctx)\r\n{\r\nreturn ctx->pe;\r\n}\r\nint cxl_stop_context(struct cxl_context *ctx)\r\n{\r\nreturn __detach_context(ctx);\r\n}\r\nvoid cxl_set_master(struct cxl_context *ctx)\r\n{\r\nctx->master = true;\r\ncxl_assign_psn_space(ctx);\r\n}\r\nint cxl_fd_open(struct inode *inode, struct file *file)\r\n{\r\nreturn afu_open(inode, file);\r\n}\r\nint cxl_fd_release(struct inode *inode, struct file *file)\r\n{\r\nreturn afu_release(inode, file);\r\n}\r\nlong cxl_fd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nreturn afu_ioctl(file, cmd, arg);\r\n}\r\nint cxl_fd_mmap(struct file *file, struct vm_area_struct *vm)\r\n{\r\nreturn afu_mmap(file, vm);\r\n}\r\nunsigned int cxl_fd_poll(struct file *file, struct poll_table_struct *poll)\r\n{\r\nreturn afu_poll(file, poll);\r\n}\r\nssize_t cxl_fd_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *off)\r\n{\r\nreturn afu_read(file, buf, count, off);\r\n}\r\nstruct file *cxl_get_fd(struct cxl_context *ctx, struct file_operations *fops,\r\nint *fd)\r\n{\r\nstruct file *file;\r\nint rc, flags, fdtmp;\r\nflags = O_RDWR | O_CLOEXEC;\r\nrc = get_unused_fd_flags(flags);\r\nif (rc < 0)\r\nreturn ERR_PTR(rc);\r\nfdtmp = rc;\r\nif (fops) {\r\nPATCH_FOPS(open);\r\nPATCH_FOPS(poll);\r\nPATCH_FOPS(read);\r\nPATCH_FOPS(release);\r\nPATCH_FOPS(unlocked_ioctl);\r\nPATCH_FOPS(compat_ioctl);\r\nPATCH_FOPS(mmap);\r\n} else\r\nfops = (struct file_operations *)&afu_fops;\r\nfile = anon_inode_getfile("cxl", fops, ctx, flags);\r\nif (IS_ERR(file))\r\ngoto err_fd;\r\nfile->f_mapping = ctx->mapping;\r\n*fd = fdtmp;\r\nreturn file;\r\nerr_fd:\r\nput_unused_fd(fdtmp);\r\nreturn NULL;\r\n}\r\nstruct cxl_context *cxl_fops_get_context(struct file *file)\r\n{\r\nreturn file->private_data;\r\n}\r\nint cxl_start_work(struct cxl_context *ctx,\r\nstruct cxl_ioctl_start_work *work)\r\n{\r\nint rc;\r\nif (!(work->flags & CXL_START_WORK_NUM_IRQS))\r\nwork->num_interrupts = ctx->afu->pp_irqs;\r\nelse if ((work->num_interrupts < ctx->afu->pp_irqs) ||\r\n(work->num_interrupts > ctx->afu->irqs_max)) {\r\nreturn -EINVAL;\r\n}\r\nrc = afu_register_irqs(ctx, work->num_interrupts);\r\nif (rc)\r\nreturn rc;\r\nrc = cxl_start_context(ctx, work->work_element_descriptor, current);\r\nif (rc < 0) {\r\nafu_release_irqs(ctx, ctx);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nvoid __iomem *cxl_psa_map(struct cxl_context *ctx)\r\n{\r\nstruct cxl_afu *afu = ctx->afu;\r\nint rc;\r\nrc = cxl_afu_check_and_enable(afu);\r\nif (rc)\r\nreturn NULL;\r\npr_devel("%s: psn_phys%llx size:%llx\n",\r\n__func__, afu->psn_phys, afu->adapter->ps_size);\r\nreturn ioremap(ctx->psn_phys, ctx->psn_size);\r\n}\r\nvoid cxl_psa_unmap(void __iomem *addr)\r\n{\r\niounmap(addr);\r\n}\r\nint cxl_afu_reset(struct cxl_context *ctx)\r\n{\r\nstruct cxl_afu *afu = ctx->afu;\r\nint rc;\r\nrc = __cxl_afu_reset(afu);\r\nif (rc)\r\nreturn rc;\r\nreturn cxl_afu_check_and_enable(afu);\r\n}\r\nvoid cxl_perst_reloads_same_image(struct cxl_afu *afu,\r\nbool perst_reloads_same_image)\r\n{\r\nafu->adapter->perst_same_image = perst_reloads_same_image;\r\n}
