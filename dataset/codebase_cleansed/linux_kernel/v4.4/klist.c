static struct klist *knode_klist(struct klist_node *knode)\r\n{\r\nreturn (struct klist *)\r\n((unsigned long)knode->n_klist & KNODE_KLIST_MASK);\r\n}\r\nstatic bool knode_dead(struct klist_node *knode)\r\n{\r\nreturn (unsigned long)knode->n_klist & KNODE_DEAD;\r\n}\r\nstatic void knode_set_klist(struct klist_node *knode, struct klist *klist)\r\n{\r\nknode->n_klist = klist;\r\nWARN_ON(knode_dead(knode));\r\n}\r\nstatic void knode_kill(struct klist_node *knode)\r\n{\r\nWARN_ON(knode_dead(knode));\r\n*(unsigned long *)&knode->n_klist |= KNODE_DEAD;\r\n}\r\nvoid klist_init(struct klist *k, void (*get)(struct klist_node *),\r\nvoid (*put)(struct klist_node *))\r\n{\r\nINIT_LIST_HEAD(&k->k_list);\r\nspin_lock_init(&k->k_lock);\r\nk->get = get;\r\nk->put = put;\r\n}\r\nstatic void add_head(struct klist *k, struct klist_node *n)\r\n{\r\nspin_lock(&k->k_lock);\r\nlist_add(&n->n_node, &k->k_list);\r\nspin_unlock(&k->k_lock);\r\n}\r\nstatic void add_tail(struct klist *k, struct klist_node *n)\r\n{\r\nspin_lock(&k->k_lock);\r\nlist_add_tail(&n->n_node, &k->k_list);\r\nspin_unlock(&k->k_lock);\r\n}\r\nstatic void klist_node_init(struct klist *k, struct klist_node *n)\r\n{\r\nINIT_LIST_HEAD(&n->n_node);\r\nkref_init(&n->n_ref);\r\nknode_set_klist(n, k);\r\nif (k->get)\r\nk->get(n);\r\n}\r\nvoid klist_add_head(struct klist_node *n, struct klist *k)\r\n{\r\nklist_node_init(k, n);\r\nadd_head(k, n);\r\n}\r\nvoid klist_add_tail(struct klist_node *n, struct klist *k)\r\n{\r\nklist_node_init(k, n);\r\nadd_tail(k, n);\r\n}\r\nvoid klist_add_behind(struct klist_node *n, struct klist_node *pos)\r\n{\r\nstruct klist *k = knode_klist(pos);\r\nklist_node_init(k, n);\r\nspin_lock(&k->k_lock);\r\nlist_add(&n->n_node, &pos->n_node);\r\nspin_unlock(&k->k_lock);\r\n}\r\nvoid klist_add_before(struct klist_node *n, struct klist_node *pos)\r\n{\r\nstruct klist *k = knode_klist(pos);\r\nklist_node_init(k, n);\r\nspin_lock(&k->k_lock);\r\nlist_add_tail(&n->n_node, &pos->n_node);\r\nspin_unlock(&k->k_lock);\r\n}\r\nstatic void klist_release(struct kref *kref)\r\n{\r\nstruct klist_waiter *waiter, *tmp;\r\nstruct klist_node *n = container_of(kref, struct klist_node, n_ref);\r\nWARN_ON(!knode_dead(n));\r\nlist_del(&n->n_node);\r\nspin_lock(&klist_remove_lock);\r\nlist_for_each_entry_safe(waiter, tmp, &klist_remove_waiters, list) {\r\nif (waiter->node != n)\r\ncontinue;\r\nlist_del(&waiter->list);\r\nwaiter->woken = 1;\r\nmb();\r\nwake_up_process(waiter->process);\r\n}\r\nspin_unlock(&klist_remove_lock);\r\nknode_set_klist(n, NULL);\r\n}\r\nstatic int klist_dec_and_del(struct klist_node *n)\r\n{\r\nreturn kref_put(&n->n_ref, klist_release);\r\n}\r\nstatic void klist_put(struct klist_node *n, bool kill)\r\n{\r\nstruct klist *k = knode_klist(n);\r\nvoid (*put)(struct klist_node *) = k->put;\r\nspin_lock(&k->k_lock);\r\nif (kill)\r\nknode_kill(n);\r\nif (!klist_dec_and_del(n))\r\nput = NULL;\r\nspin_unlock(&k->k_lock);\r\nif (put)\r\nput(n);\r\n}\r\nvoid klist_del(struct klist_node *n)\r\n{\r\nklist_put(n, true);\r\n}\r\nvoid klist_remove(struct klist_node *n)\r\n{\r\nstruct klist_waiter waiter;\r\nwaiter.node = n;\r\nwaiter.process = current;\r\nwaiter.woken = 0;\r\nspin_lock(&klist_remove_lock);\r\nlist_add(&waiter.list, &klist_remove_waiters);\r\nspin_unlock(&klist_remove_lock);\r\nklist_del(n);\r\nfor (;;) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nif (waiter.woken)\r\nbreak;\r\nschedule();\r\n}\r\n__set_current_state(TASK_RUNNING);\r\n}\r\nint klist_node_attached(struct klist_node *n)\r\n{\r\nreturn (n->n_klist != NULL);\r\n}\r\nvoid klist_iter_init_node(struct klist *k, struct klist_iter *i,\r\nstruct klist_node *n)\r\n{\r\ni->i_klist = k;\r\ni->i_cur = n;\r\nif (n)\r\nkref_get(&n->n_ref);\r\n}\r\nvoid klist_iter_init(struct klist *k, struct klist_iter *i)\r\n{\r\nklist_iter_init_node(k, i, NULL);\r\n}\r\nvoid klist_iter_exit(struct klist_iter *i)\r\n{\r\nif (i->i_cur) {\r\nklist_put(i->i_cur, false);\r\ni->i_cur = NULL;\r\n}\r\n}\r\nstatic struct klist_node *to_klist_node(struct list_head *n)\r\n{\r\nreturn container_of(n, struct klist_node, n_node);\r\n}\r\nstruct klist_node *klist_prev(struct klist_iter *i)\r\n{\r\nvoid (*put)(struct klist_node *) = i->i_klist->put;\r\nstruct klist_node *last = i->i_cur;\r\nstruct klist_node *prev;\r\nspin_lock(&i->i_klist->k_lock);\r\nif (last) {\r\nprev = to_klist_node(last->n_node.prev);\r\nif (!klist_dec_and_del(last))\r\nput = NULL;\r\n} else\r\nprev = to_klist_node(i->i_klist->k_list.prev);\r\ni->i_cur = NULL;\r\nwhile (prev != to_klist_node(&i->i_klist->k_list)) {\r\nif (likely(!knode_dead(prev))) {\r\nkref_get(&prev->n_ref);\r\ni->i_cur = prev;\r\nbreak;\r\n}\r\nprev = to_klist_node(prev->n_node.prev);\r\n}\r\nspin_unlock(&i->i_klist->k_lock);\r\nif (put && last)\r\nput(last);\r\nreturn i->i_cur;\r\n}\r\nstruct klist_node *klist_next(struct klist_iter *i)\r\n{\r\nvoid (*put)(struct klist_node *) = i->i_klist->put;\r\nstruct klist_node *last = i->i_cur;\r\nstruct klist_node *next;\r\nspin_lock(&i->i_klist->k_lock);\r\nif (last) {\r\nnext = to_klist_node(last->n_node.next);\r\nif (!klist_dec_and_del(last))\r\nput = NULL;\r\n} else\r\nnext = to_klist_node(i->i_klist->k_list.next);\r\ni->i_cur = NULL;\r\nwhile (next != to_klist_node(&i->i_klist->k_list)) {\r\nif (likely(!knode_dead(next))) {\r\nkref_get(&next->n_ref);\r\ni->i_cur = next;\r\nbreak;\r\n}\r\nnext = to_klist_node(next->n_node.next);\r\n}\r\nspin_unlock(&i->i_klist->k_lock);\r\nif (put && last)\r\nput(last);\r\nreturn i->i_cur;\r\n}
