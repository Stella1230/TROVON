static int ghash_init(struct shash_desc *desc)\r\n{\r\nstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\r\nmemset(dctx, 0, sizeof(*dctx));\r\nreturn 0;\r\n}\r\nstatic int ghash_setkey(struct crypto_shash *tfm,\r\nconst u8 *key, unsigned int keylen)\r\n{\r\nstruct ghash_ctx *ctx = crypto_shash_ctx(tfm);\r\nbe128 *x = (be128 *)key;\r\nu64 a, b;\r\nif (keylen != GHASH_BLOCK_SIZE) {\r\ncrypto_shash_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\na = be64_to_cpu(x->a);\r\nb = be64_to_cpu(x->b);\r\nctx->shash.a = (b << 1) | (a >> 63);\r\nctx->shash.b = (a << 1) | (b >> 63);\r\nif (a >> 63)\r\nctx->shash.b ^= ((u64)0xc2) << 56;\r\nreturn 0;\r\n}\r\nstatic int ghash_update(struct shash_desc *desc,\r\nconst u8 *src, unsigned int srclen)\r\n{\r\nstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\r\nstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\r\nu8 *dst = dctx->buffer;\r\nkernel_fpu_begin();\r\nif (dctx->bytes) {\r\nint n = min(srclen, dctx->bytes);\r\nu8 *pos = dst + (GHASH_BLOCK_SIZE - dctx->bytes);\r\ndctx->bytes -= n;\r\nsrclen -= n;\r\nwhile (n--)\r\n*pos++ ^= *src++;\r\nif (!dctx->bytes)\r\nclmul_ghash_mul(dst, &ctx->shash);\r\n}\r\nclmul_ghash_update(dst, src, srclen, &ctx->shash);\r\nkernel_fpu_end();\r\nif (srclen & 0xf) {\r\nsrc += srclen - (srclen & 0xf);\r\nsrclen &= 0xf;\r\ndctx->bytes = GHASH_BLOCK_SIZE - srclen;\r\nwhile (srclen--)\r\n*dst++ ^= *src++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ghash_flush(struct ghash_ctx *ctx, struct ghash_desc_ctx *dctx)\r\n{\r\nu8 *dst = dctx->buffer;\r\nif (dctx->bytes) {\r\nu8 *tmp = dst + (GHASH_BLOCK_SIZE - dctx->bytes);\r\nwhile (dctx->bytes--)\r\n*tmp++ ^= 0;\r\nkernel_fpu_begin();\r\nclmul_ghash_mul(dst, &ctx->shash);\r\nkernel_fpu_end();\r\n}\r\ndctx->bytes = 0;\r\n}\r\nstatic int ghash_final(struct shash_desc *desc, u8 *dst)\r\n{\r\nstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\r\nstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\r\nu8 *buf = dctx->buffer;\r\nghash_flush(ctx, dctx);\r\nmemcpy(dst, buf, GHASH_BLOCK_SIZE);\r\nreturn 0;\r\n}\r\nstatic int ghash_async_init(struct ahash_request *req)\r\n{\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct ghash_async_ctx *ctx = crypto_ahash_ctx(tfm);\r\nstruct ahash_request *cryptd_req = ahash_request_ctx(req);\r\nstruct cryptd_ahash *cryptd_tfm = ctx->cryptd_tfm;\r\nif (!irq_fpu_usable()) {\r\nmemcpy(cryptd_req, req, sizeof(*req));\r\nahash_request_set_tfm(cryptd_req, &cryptd_tfm->base);\r\nreturn crypto_ahash_init(cryptd_req);\r\n} else {\r\nstruct shash_desc *desc = cryptd_shash_desc(cryptd_req);\r\nstruct crypto_shash *child = cryptd_ahash_child(cryptd_tfm);\r\ndesc->tfm = child;\r\ndesc->flags = req->base.flags;\r\nreturn crypto_shash_init(desc);\r\n}\r\n}\r\nstatic int ghash_async_update(struct ahash_request *req)\r\n{\r\nstruct ahash_request *cryptd_req = ahash_request_ctx(req);\r\nif (!irq_fpu_usable()) {\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct ghash_async_ctx *ctx = crypto_ahash_ctx(tfm);\r\nstruct cryptd_ahash *cryptd_tfm = ctx->cryptd_tfm;\r\nmemcpy(cryptd_req, req, sizeof(*req));\r\nahash_request_set_tfm(cryptd_req, &cryptd_tfm->base);\r\nreturn crypto_ahash_update(cryptd_req);\r\n} else {\r\nstruct shash_desc *desc = cryptd_shash_desc(cryptd_req);\r\nreturn shash_ahash_update(req, desc);\r\n}\r\n}\r\nstatic int ghash_async_final(struct ahash_request *req)\r\n{\r\nstruct ahash_request *cryptd_req = ahash_request_ctx(req);\r\nif (!irq_fpu_usable()) {\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct ghash_async_ctx *ctx = crypto_ahash_ctx(tfm);\r\nstruct cryptd_ahash *cryptd_tfm = ctx->cryptd_tfm;\r\nmemcpy(cryptd_req, req, sizeof(*req));\r\nahash_request_set_tfm(cryptd_req, &cryptd_tfm->base);\r\nreturn crypto_ahash_final(cryptd_req);\r\n} else {\r\nstruct shash_desc *desc = cryptd_shash_desc(cryptd_req);\r\nreturn crypto_shash_final(desc, req->result);\r\n}\r\n}\r\nstatic int ghash_async_digest(struct ahash_request *req)\r\n{\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct ghash_async_ctx *ctx = crypto_ahash_ctx(tfm);\r\nstruct ahash_request *cryptd_req = ahash_request_ctx(req);\r\nstruct cryptd_ahash *cryptd_tfm = ctx->cryptd_tfm;\r\nif (!irq_fpu_usable()) {\r\nmemcpy(cryptd_req, req, sizeof(*req));\r\nahash_request_set_tfm(cryptd_req, &cryptd_tfm->base);\r\nreturn crypto_ahash_digest(cryptd_req);\r\n} else {\r\nstruct shash_desc *desc = cryptd_shash_desc(cryptd_req);\r\nstruct crypto_shash *child = cryptd_ahash_child(cryptd_tfm);\r\ndesc->tfm = child;\r\ndesc->flags = req->base.flags;\r\nreturn shash_ahash_digest(req, desc);\r\n}\r\n}\r\nstatic int ghash_async_setkey(struct crypto_ahash *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct ghash_async_ctx *ctx = crypto_ahash_ctx(tfm);\r\nstruct crypto_ahash *child = &ctx->cryptd_tfm->base;\r\nint err;\r\ncrypto_ahash_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_ahash_set_flags(child, crypto_ahash_get_flags(tfm)\r\n& CRYPTO_TFM_REQ_MASK);\r\nerr = crypto_ahash_setkey(child, key, keylen);\r\ncrypto_ahash_set_flags(tfm, crypto_ahash_get_flags(child)\r\n& CRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic int ghash_async_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct cryptd_ahash *cryptd_tfm;\r\nstruct ghash_async_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncryptd_tfm = cryptd_alloc_ahash("__ghash-pclmulqdqni",\r\nCRYPTO_ALG_INTERNAL,\r\nCRYPTO_ALG_INTERNAL);\r\nif (IS_ERR(cryptd_tfm))\r\nreturn PTR_ERR(cryptd_tfm);\r\nctx->cryptd_tfm = cryptd_tfm;\r\ncrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\r\nsizeof(struct ahash_request) +\r\ncrypto_ahash_reqsize(&cryptd_tfm->base));\r\nreturn 0;\r\n}\r\nstatic void ghash_async_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct ghash_async_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncryptd_free_ahash(ctx->cryptd_tfm);\r\n}\r\nstatic int __init ghash_pclmulqdqni_mod_init(void)\r\n{\r\nint err;\r\nif (!x86_match_cpu(pcmul_cpu_id))\r\nreturn -ENODEV;\r\nerr = crypto_register_shash(&ghash_alg);\r\nif (err)\r\ngoto err_out;\r\nerr = crypto_register_ahash(&ghash_async_alg);\r\nif (err)\r\ngoto err_shash;\r\nreturn 0;\r\nerr_shash:\r\ncrypto_unregister_shash(&ghash_alg);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic void __exit ghash_pclmulqdqni_mod_exit(void)\r\n{\r\ncrypto_unregister_ahash(&ghash_async_alg);\r\ncrypto_unregister_shash(&ghash_alg);\r\n}
