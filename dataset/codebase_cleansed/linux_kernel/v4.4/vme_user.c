static ssize_t resource_to_user(int minor, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nssize_t copied = 0;\r\nif (count > image[minor].size_buf)\r\ncount = image[minor].size_buf;\r\ncopied = vme_master_read(image[minor].resource, image[minor].kern_buf,\r\ncount, *ppos);\r\nif (copied < 0)\r\nreturn (int)copied;\r\nif (__copy_to_user(buf, image[minor].kern_buf, (unsigned long)copied))\r\nreturn -EFAULT;\r\nreturn copied;\r\n}\r\nstatic ssize_t resource_from_user(unsigned int minor, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (count > image[minor].size_buf)\r\ncount = image[minor].size_buf;\r\nif (__copy_from_user(image[minor].kern_buf, buf, (unsigned long)count))\r\nreturn -EFAULT;\r\nreturn vme_master_write(image[minor].resource, image[minor].kern_buf,\r\ncount, *ppos);\r\n}\r\nstatic ssize_t buffer_to_user(unsigned int minor, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nvoid *image_ptr;\r\nimage_ptr = image[minor].kern_buf + *ppos;\r\nif (__copy_to_user(buf, image_ptr, (unsigned long)count))\r\nreturn -EFAULT;\r\nreturn count;\r\n}\r\nstatic ssize_t buffer_from_user(unsigned int minor, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nvoid *image_ptr;\r\nimage_ptr = image[minor].kern_buf + *ppos;\r\nif (__copy_from_user(image_ptr, buf, (unsigned long)count))\r\nreturn -EFAULT;\r\nreturn count;\r\n}\r\nstatic ssize_t vme_user_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nunsigned int minor = MINOR(file_inode(file)->i_rdev);\r\nssize_t retval;\r\nsize_t image_size;\r\nif (minor == CONTROL_MINOR)\r\nreturn 0;\r\nmutex_lock(&image[minor].mutex);\r\nimage_size = vme_get_size(image[minor].resource);\r\nif ((*ppos < 0) || (*ppos > (image_size - 1))) {\r\nmutex_unlock(&image[minor].mutex);\r\nreturn 0;\r\n}\r\nif (*ppos + count > image_size)\r\ncount = image_size - *ppos;\r\nswitch (type[minor]) {\r\ncase MASTER_MINOR:\r\nretval = resource_to_user(minor, buf, count, ppos);\r\nbreak;\r\ncase SLAVE_MINOR:\r\nretval = buffer_to_user(minor, buf, count, ppos);\r\nbreak;\r\ndefault:\r\nretval = -EINVAL;\r\n}\r\nmutex_unlock(&image[minor].mutex);\r\nif (retval > 0)\r\n*ppos += retval;\r\nreturn retval;\r\n}\r\nstatic ssize_t vme_user_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nunsigned int minor = MINOR(file_inode(file)->i_rdev);\r\nssize_t retval;\r\nsize_t image_size;\r\nif (minor == CONTROL_MINOR)\r\nreturn 0;\r\nmutex_lock(&image[minor].mutex);\r\nimage_size = vme_get_size(image[minor].resource);\r\nif ((*ppos < 0) || (*ppos > (image_size - 1))) {\r\nmutex_unlock(&image[minor].mutex);\r\nreturn 0;\r\n}\r\nif (*ppos + count > image_size)\r\ncount = image_size - *ppos;\r\nswitch (type[minor]) {\r\ncase MASTER_MINOR:\r\nretval = resource_from_user(minor, buf, count, ppos);\r\nbreak;\r\ncase SLAVE_MINOR:\r\nretval = buffer_from_user(minor, buf, count, ppos);\r\nbreak;\r\ndefault:\r\nretval = -EINVAL;\r\n}\r\nmutex_unlock(&image[minor].mutex);\r\nif (retval > 0)\r\n*ppos += retval;\r\nreturn retval;\r\n}\r\nstatic loff_t vme_user_llseek(struct file *file, loff_t off, int whence)\r\n{\r\nunsigned int minor = MINOR(file_inode(file)->i_rdev);\r\nsize_t image_size;\r\nloff_t res;\r\nswitch (type[minor]) {\r\ncase MASTER_MINOR:\r\ncase SLAVE_MINOR:\r\nmutex_lock(&image[minor].mutex);\r\nimage_size = vme_get_size(image[minor].resource);\r\nres = fixed_size_llseek(file, off, whence, image_size);\r\nmutex_unlock(&image[minor].mutex);\r\nreturn res;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vme_user_ioctl(struct inode *inode, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct vme_master master;\r\nstruct vme_slave slave;\r\nstruct vme_irq_id irq_req;\r\nunsigned long copied;\r\nunsigned int minor = MINOR(inode->i_rdev);\r\nint retval;\r\ndma_addr_t pci_addr;\r\nvoid __user *argp = (void __user *)arg;\r\nswitch (type[minor]) {\r\ncase CONTROL_MINOR:\r\nswitch (cmd) {\r\ncase VME_IRQ_GEN:\r\ncopied = copy_from_user(&irq_req, argp,\r\nsizeof(struct vme_irq_id));\r\nif (copied != 0) {\r\npr_warn("Partial copy from userspace\n");\r\nreturn -EFAULT;\r\n}\r\nreturn vme_irq_generate(vme_user_bridge,\r\nirq_req.level,\r\nirq_req.statid);\r\n}\r\nbreak;\r\ncase MASTER_MINOR:\r\nswitch (cmd) {\r\ncase VME_GET_MASTER:\r\nmemset(&master, 0, sizeof(struct vme_master));\r\nretval = vme_master_get(image[minor].resource,\r\n&master.enable,\r\n&master.vme_addr,\r\n&master.size, &master.aspace,\r\n&master.cycle, &master.dwidth);\r\ncopied = copy_to_user(argp, &master,\r\nsizeof(struct vme_master));\r\nif (copied != 0) {\r\npr_warn("Partial copy to userspace\n");\r\nreturn -EFAULT;\r\n}\r\nreturn retval;\r\ncase VME_SET_MASTER:\r\nif (image[minor].mmap_count != 0) {\r\npr_warn("Can't adjust mapped window\n");\r\nreturn -EPERM;\r\n}\r\ncopied = copy_from_user(&master, argp, sizeof(master));\r\nif (copied != 0) {\r\npr_warn("Partial copy from userspace\n");\r\nreturn -EFAULT;\r\n}\r\nreturn vme_master_set(image[minor].resource,\r\nmaster.enable, master.vme_addr, master.size,\r\nmaster.aspace, master.cycle, master.dwidth);\r\nbreak;\r\n}\r\nbreak;\r\ncase SLAVE_MINOR:\r\nswitch (cmd) {\r\ncase VME_GET_SLAVE:\r\nmemset(&slave, 0, sizeof(struct vme_slave));\r\nretval = vme_slave_get(image[minor].resource,\r\n&slave.enable, &slave.vme_addr,\r\n&slave.size, &pci_addr,\r\n&slave.aspace, &slave.cycle);\r\ncopied = copy_to_user(argp, &slave,\r\nsizeof(struct vme_slave));\r\nif (copied != 0) {\r\npr_warn("Partial copy to userspace\n");\r\nreturn -EFAULT;\r\n}\r\nreturn retval;\r\ncase VME_SET_SLAVE:\r\ncopied = copy_from_user(&slave, argp, sizeof(slave));\r\nif (copied != 0) {\r\npr_warn("Partial copy from userspace\n");\r\nreturn -EFAULT;\r\n}\r\nreturn vme_slave_set(image[minor].resource,\r\nslave.enable, slave.vme_addr, slave.size,\r\nimage[minor].pci_buf, slave.aspace,\r\nslave.cycle);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic long\r\nvme_user_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nint ret;\r\nstruct inode *inode = file_inode(file);\r\nunsigned int minor = MINOR(inode->i_rdev);\r\nmutex_lock(&image[minor].mutex);\r\nret = vme_user_ioctl(inode, file, cmd, arg);\r\nmutex_unlock(&image[minor].mutex);\r\nreturn ret;\r\n}\r\nstatic void vme_user_vm_open(struct vm_area_struct *vma)\r\n{\r\nstruct vme_user_vma_priv *vma_priv = vma->vm_private_data;\r\natomic_inc(&vma_priv->refcnt);\r\n}\r\nstatic void vme_user_vm_close(struct vm_area_struct *vma)\r\n{\r\nstruct vme_user_vma_priv *vma_priv = vma->vm_private_data;\r\nunsigned int minor = vma_priv->minor;\r\nif (!atomic_dec_and_test(&vma_priv->refcnt))\r\nreturn;\r\nmutex_lock(&image[minor].mutex);\r\nimage[minor].mmap_count--;\r\nmutex_unlock(&image[minor].mutex);\r\nkfree(vma_priv);\r\n}\r\nstatic int vme_user_master_mmap(unsigned int minor, struct vm_area_struct *vma)\r\n{\r\nint err;\r\nstruct vme_user_vma_priv *vma_priv;\r\nmutex_lock(&image[minor].mutex);\r\nerr = vme_master_mmap(image[minor].resource, vma);\r\nif (err) {\r\nmutex_unlock(&image[minor].mutex);\r\nreturn err;\r\n}\r\nvma_priv = kmalloc(sizeof(*vma_priv), GFP_KERNEL);\r\nif (!vma_priv) {\r\nmutex_unlock(&image[minor].mutex);\r\nreturn -ENOMEM;\r\n}\r\nvma_priv->minor = minor;\r\natomic_set(&vma_priv->refcnt, 1);\r\nvma->vm_ops = &vme_user_vm_ops;\r\nvma->vm_private_data = vma_priv;\r\nimage[minor].mmap_count++;\r\nmutex_unlock(&image[minor].mutex);\r\nreturn 0;\r\n}\r\nstatic int vme_user_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nunsigned int minor = MINOR(file_inode(file)->i_rdev);\r\nif (type[minor] == MASTER_MINOR)\r\nreturn vme_user_master_mmap(minor, vma);\r\nreturn -ENODEV;\r\n}\r\nstatic int vme_user_match(struct vme_dev *vdev)\r\n{\r\nint i;\r\nint cur_bus = vme_bus_num(vdev);\r\nint cur_slot = vme_slot_num(vdev);\r\nfor (i = 0; i < bus_num; i++)\r\nif ((cur_bus == bus[i]) && (cur_slot == vdev->num))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int vme_user_probe(struct vme_dev *vdev)\r\n{\r\nint i, err;\r\nchar *name;\r\nif (vme_user_bridge) {\r\ndev_err(&vdev->dev, "Driver can only be loaded for 1 device\n");\r\nerr = -EINVAL;\r\ngoto err_dev;\r\n}\r\nvme_user_bridge = vdev;\r\nfor (i = 0; i < VME_DEVS; i++) {\r\nimage[i].kern_buf = NULL;\r\nimage[i].pci_buf = 0;\r\nmutex_init(&image[i].mutex);\r\nimage[i].device = NULL;\r\nimage[i].resource = NULL;\r\n}\r\nerr = register_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS,\r\ndriver_name);\r\nif (err) {\r\ndev_warn(&vdev->dev, "Error getting Major Number %d for driver.\n",\r\nVME_MAJOR);\r\ngoto err_region;\r\n}\r\nvme_user_cdev = cdev_alloc();\r\nif (!vme_user_cdev) {\r\nerr = -ENOMEM;\r\ngoto err_char;\r\n}\r\nvme_user_cdev->ops = &vme_user_fops;\r\nvme_user_cdev->owner = THIS_MODULE;\r\nerr = cdev_add(vme_user_cdev, MKDEV(VME_MAJOR, 0), VME_DEVS);\r\nif (err)\r\ngoto err_char;\r\nfor (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {\r\nimage[i].resource = vme_slave_request(vme_user_bridge,\r\nVME_A24, VME_SCT);\r\nif (!image[i].resource) {\r\ndev_warn(&vdev->dev,\r\n"Unable to allocate slave resource\n");\r\nerr = -ENOMEM;\r\ngoto err_slave;\r\n}\r\nimage[i].size_buf = PCI_BUF_SIZE;\r\nimage[i].kern_buf = vme_alloc_consistent(image[i].resource,\r\nimage[i].size_buf, &image[i].pci_buf);\r\nif (!image[i].kern_buf) {\r\ndev_warn(&vdev->dev,\r\n"Unable to allocate memory for buffer\n");\r\nimage[i].pci_buf = 0;\r\nvme_slave_free(image[i].resource);\r\nerr = -ENOMEM;\r\ngoto err_slave;\r\n}\r\n}\r\nfor (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++) {\r\nimage[i].resource = vme_master_request(vme_user_bridge,\r\nVME_A32, VME_SCT, VME_D32);\r\nif (!image[i].resource) {\r\ndev_warn(&vdev->dev,\r\n"Unable to allocate master resource\n");\r\nerr = -ENOMEM;\r\ngoto err_master;\r\n}\r\nimage[i].size_buf = PCI_BUF_SIZE;\r\nimage[i].kern_buf = kmalloc(image[i].size_buf, GFP_KERNEL);\r\nif (!image[i].kern_buf) {\r\nerr = -ENOMEM;\r\nvme_master_free(image[i].resource);\r\ngoto err_master;\r\n}\r\n}\r\nvme_user_sysfs_class = class_create(THIS_MODULE, driver_name);\r\nif (IS_ERR(vme_user_sysfs_class)) {\r\ndev_err(&vdev->dev, "Error creating vme_user class.\n");\r\nerr = PTR_ERR(vme_user_sysfs_class);\r\ngoto err_class;\r\n}\r\nfor (i = 0; i < VME_DEVS; i++) {\r\nint num;\r\nswitch (type[i]) {\r\ncase MASTER_MINOR:\r\nname = "bus/vme/m%d";\r\nbreak;\r\ncase CONTROL_MINOR:\r\nname = "bus/vme/ctl";\r\nbreak;\r\ncase SLAVE_MINOR:\r\nname = "bus/vme/s%d";\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto err_sysfs;\r\n}\r\nnum = (type[i] == SLAVE_MINOR) ? i - (MASTER_MAX + 1) : i;\r\nimage[i].device = device_create(vme_user_sysfs_class, NULL,\r\nMKDEV(VME_MAJOR, i), NULL, name, num);\r\nif (IS_ERR(image[i].device)) {\r\ndev_info(&vdev->dev, "Error creating sysfs device\n");\r\nerr = PTR_ERR(image[i].device);\r\ngoto err_sysfs;\r\n}\r\n}\r\nreturn 0;\r\nerr_sysfs:\r\nwhile (i > 0) {\r\ni--;\r\ndevice_destroy(vme_user_sysfs_class, MKDEV(VME_MAJOR, i));\r\n}\r\nclass_destroy(vme_user_sysfs_class);\r\ni = MASTER_MAX + 1;\r\nerr_master:\r\nwhile (i > MASTER_MINOR) {\r\ni--;\r\nkfree(image[i].kern_buf);\r\nvme_master_free(image[i].resource);\r\n}\r\ni = SLAVE_MAX + 1;\r\nerr_slave:\r\nwhile (i > SLAVE_MINOR) {\r\ni--;\r\nvme_free_consistent(image[i].resource, image[i].size_buf,\r\nimage[i].kern_buf, image[i].pci_buf);\r\nvme_slave_free(image[i].resource);\r\n}\r\nerr_class:\r\ncdev_del(vme_user_cdev);\r\nerr_char:\r\nunregister_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS);\r\nerr_region:\r\nerr_dev:\r\nreturn err;\r\n}\r\nstatic int vme_user_remove(struct vme_dev *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < VME_DEVS; i++) {\r\nmutex_destroy(&image[i].mutex);\r\ndevice_destroy(vme_user_sysfs_class, MKDEV(VME_MAJOR, i));\r\n}\r\nclass_destroy(vme_user_sysfs_class);\r\nfor (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++) {\r\nkfree(image[i].kern_buf);\r\nvme_master_free(image[i].resource);\r\n}\r\nfor (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {\r\nvme_slave_set(image[i].resource, 0, 0, 0, 0, VME_A32, 0);\r\nvme_free_consistent(image[i].resource, image[i].size_buf,\r\nimage[i].kern_buf, image[i].pci_buf);\r\nvme_slave_free(image[i].resource);\r\n}\r\ncdev_del(vme_user_cdev);\r\nunregister_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS);\r\nreturn 0;\r\n}\r\nstatic int __init vme_user_init(void)\r\n{\r\nint retval = 0;\r\npr_info("VME User Space Access Driver\n");\r\nif (bus_num == 0) {\r\npr_err("No cards, skipping registration\n");\r\nretval = -ENODEV;\r\ngoto err_nocard;\r\n}\r\nif (bus_num > VME_USER_BUS_MAX) {\r\npr_err("Driver only able to handle %d buses\n",\r\nVME_USER_BUS_MAX);\r\nbus_num = VME_USER_BUS_MAX;\r\n}\r\nretval = vme_register_driver(&vme_user_driver, VME_MAX_SLOTS);\r\nif (retval != 0)\r\ngoto err_reg;\r\nreturn retval;\r\nerr_reg:\r\nerr_nocard:\r\nreturn retval;\r\n}\r\nstatic void __exit vme_user_exit(void)\r\n{\r\nvme_unregister_driver(&vme_user_driver);\r\n}
