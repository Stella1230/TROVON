static inline void __iomem *gpio_chip_base(struct gpio_chip *c)\r\n{\r\nreturn container_of(c, struct pxa_gpio_chip, chip)->regbase;\r\n}\r\nstatic inline struct pxa_gpio_chip *gpio_to_pxachip(unsigned gpio)\r\n{\r\nreturn &pxa_gpio_chips[gpio_to_bank(gpio)];\r\n}\r\nstatic inline int gpio_is_pxa_type(int type)\r\n{\r\nreturn (type & MMP_GPIO) == 0;\r\n}\r\nstatic inline int gpio_is_mmp_type(int type)\r\n{\r\nreturn (type & MMP_GPIO) != 0;\r\n}\r\nstatic inline int __gpio_is_inverted(int gpio)\r\n{\r\nif ((gpio_type == PXA26X_GPIO) && (gpio > 85))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int __gpio_is_occupied(unsigned gpio)\r\n{\r\nstruct pxa_gpio_chip *pxachip;\r\nvoid __iomem *base;\r\nunsigned long gafr = 0, gpdr = 0;\r\nint ret, af = 0, dir = 0;\r\npxachip = gpio_to_pxachip(gpio);\r\nbase = gpio_chip_base(&pxachip->chip);\r\ngpdr = readl_relaxed(base + GPDR_OFFSET);\r\nswitch (gpio_type) {\r\ncase PXA25X_GPIO:\r\ncase PXA26X_GPIO:\r\ncase PXA27X_GPIO:\r\ngafr = readl_relaxed(base + GAFR_OFFSET);\r\naf = (gafr >> ((gpio & 0xf) * 2)) & 0x3;\r\ndir = gpdr & GPIO_bit(gpio);\r\nif (__gpio_is_inverted(gpio))\r\nret = (af != 1) || (dir == 0);\r\nelse\r\nret = (af != 0) || (dir != 0);\r\nbreak;\r\ndefault:\r\nret = gpdr & GPIO_bit(gpio);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int pxa_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn chip->base + offset + irq_base;\r\n}\r\nint pxa_irq_to_gpio(int irq)\r\n{\r\nreturn irq - irq_base;\r\n}\r\nstatic int pxa_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nvoid __iomem *base = gpio_chip_base(chip);\r\nuint32_t value, mask = 1 << offset;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nvalue = readl_relaxed(base + GPDR_OFFSET);\r\nif (__gpio_is_inverted(chip->base + offset))\r\nvalue |= mask;\r\nelse\r\nvalue &= ~mask;\r\nwritel_relaxed(value, base + GPDR_OFFSET);\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pxa_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nvoid __iomem *base = gpio_chip_base(chip);\r\nuint32_t tmp, mask = 1 << offset;\r\nunsigned long flags;\r\nwritel_relaxed(mask, base + (value ? GPSR_OFFSET : GPCR_OFFSET));\r\nspin_lock_irqsave(&gpio_lock, flags);\r\ntmp = readl_relaxed(base + GPDR_OFFSET);\r\nif (__gpio_is_inverted(chip->base + offset))\r\ntmp &= ~mask;\r\nelse\r\ntmp |= mask;\r\nwritel_relaxed(tmp, base + GPDR_OFFSET);\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pxa_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nu32 gplr = readl_relaxed(gpio_chip_base(chip) + GPLR_OFFSET);\r\nreturn !!(gplr & (1 << offset));\r\n}\r\nstatic void pxa_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nwritel_relaxed(1 << offset, gpio_chip_base(chip) +\r\n(value ? GPSR_OFFSET : GPCR_OFFSET));\r\n}\r\nstatic int pxa_gpio_of_xlate(struct gpio_chip *gc,\r\nconst struct of_phandle_args *gpiospec,\r\nu32 *flags)\r\n{\r\nif (gpiospec->args[0] > pxa_last_gpio)\r\nreturn -EINVAL;\r\nif (gc != &pxa_gpio_chips[gpiospec->args[0] / 32].chip)\r\nreturn -EINVAL;\r\nif (flags)\r\n*flags = gpiospec->args[1];\r\nreturn gpiospec->args[0] % 32;\r\n}\r\nstatic int pxa_init_gpio_chip(int gpio_end,\r\nint (*set_wake)(unsigned int, unsigned int))\r\n{\r\nint i, gpio, nbanks = gpio_to_bank(gpio_end) + 1;\r\nstruct pxa_gpio_chip *chips;\r\nchips = kzalloc(nbanks * sizeof(struct pxa_gpio_chip), GFP_KERNEL);\r\nif (chips == NULL) {\r\npr_err("%s: failed to allocate GPIO chips\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0, gpio = 0; i < nbanks; i++, gpio += 32) {\r\nstruct gpio_chip *c = &chips[i].chip;\r\nsprintf(chips[i].label, "gpio-%d", i);\r\nchips[i].regbase = gpio_reg_base + BANK_OFF(i);\r\nchips[i].set_wake = set_wake;\r\nc->base = gpio;\r\nc->label = chips[i].label;\r\nc->direction_input = pxa_gpio_direction_input;\r\nc->direction_output = pxa_gpio_direction_output;\r\nc->get = pxa_gpio_get;\r\nc->set = pxa_gpio_set;\r\nc->to_irq = pxa_gpio_to_irq;\r\n#ifdef CONFIG_OF_GPIO\r\nc->of_node = pxa_gpio_of_node;\r\nc->of_xlate = pxa_gpio_of_xlate;\r\nc->of_gpio_n_cells = 2;\r\n#endif\r\nc->ngpio = (gpio + 31 > gpio_end) ? (gpio_end - gpio + 1) : 32;\r\ngpiochip_add(c);\r\n}\r\npxa_gpio_chips = chips;\r\nreturn 0;\r\n}\r\nstatic inline void update_edge_detect(struct pxa_gpio_chip *c)\r\n{\r\nuint32_t grer, gfer;\r\ngrer = readl_relaxed(c->regbase + GRER_OFFSET) & ~c->irq_mask;\r\ngfer = readl_relaxed(c->regbase + GFER_OFFSET) & ~c->irq_mask;\r\ngrer |= c->irq_edge_rise & c->irq_mask;\r\ngfer |= c->irq_edge_fall & c->irq_mask;\r\nwritel_relaxed(grer, c->regbase + GRER_OFFSET);\r\nwritel_relaxed(gfer, c->regbase + GFER_OFFSET);\r\n}\r\nstatic int pxa_gpio_irq_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct pxa_gpio_chip *c;\r\nint gpio = pxa_irq_to_gpio(d->irq);\r\nunsigned long gpdr, mask = GPIO_bit(gpio);\r\nc = gpio_to_pxachip(gpio);\r\nif (type == IRQ_TYPE_PROBE) {\r\nif ((c->irq_edge_rise | c->irq_edge_fall) & GPIO_bit(gpio))\r\nreturn 0;\r\nif (__gpio_is_occupied(gpio))\r\nreturn 0;\r\ntype = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;\r\n}\r\ngpdr = readl_relaxed(c->regbase + GPDR_OFFSET);\r\nif (__gpio_is_inverted(gpio))\r\nwritel_relaxed(gpdr | mask, c->regbase + GPDR_OFFSET);\r\nelse\r\nwritel_relaxed(gpdr & ~mask, c->regbase + GPDR_OFFSET);\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nc->irq_edge_rise |= mask;\r\nelse\r\nc->irq_edge_rise &= ~mask;\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nc->irq_edge_fall |= mask;\r\nelse\r\nc->irq_edge_fall &= ~mask;\r\nupdate_edge_detect(c);\r\npr_debug("%s: IRQ%d (GPIO%d) - edge%s%s\n", __func__, d->irq, gpio,\r\n((type & IRQ_TYPE_EDGE_RISING) ? " rising" : ""),\r\n((type & IRQ_TYPE_EDGE_FALLING) ? " falling" : ""));\r\nreturn 0;\r\n}\r\nstatic void pxa_gpio_demux_handler(struct irq_desc *desc)\r\n{\r\nstruct pxa_gpio_chip *c;\r\nint loop, gpio, gpio_base, n;\r\nunsigned long gedr;\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nchained_irq_enter(chip, desc);\r\ndo {\r\nloop = 0;\r\nfor_each_gpio_chip(gpio, c) {\r\ngpio_base = c->chip.base;\r\ngedr = readl_relaxed(c->regbase + GEDR_OFFSET);\r\ngedr = gedr & c->irq_mask;\r\nwritel_relaxed(gedr, c->regbase + GEDR_OFFSET);\r\nfor_each_set_bit(n, &gedr, BITS_PER_LONG) {\r\nloop = 1;\r\ngeneric_handle_irq(gpio_to_irq(gpio_base + n));\r\n}\r\n}\r\n} while (loop);\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void pxa_ack_muxed_gpio(struct irq_data *d)\r\n{\r\nint gpio = pxa_irq_to_gpio(d->irq);\r\nstruct pxa_gpio_chip *c = gpio_to_pxachip(gpio);\r\nwritel_relaxed(GPIO_bit(gpio), c->regbase + GEDR_OFFSET);\r\n}\r\nstatic void pxa_mask_muxed_gpio(struct irq_data *d)\r\n{\r\nint gpio = pxa_irq_to_gpio(d->irq);\r\nstruct pxa_gpio_chip *c = gpio_to_pxachip(gpio);\r\nuint32_t grer, gfer;\r\nc->irq_mask &= ~GPIO_bit(gpio);\r\ngrer = readl_relaxed(c->regbase + GRER_OFFSET) & ~GPIO_bit(gpio);\r\ngfer = readl_relaxed(c->regbase + GFER_OFFSET) & ~GPIO_bit(gpio);\r\nwritel_relaxed(grer, c->regbase + GRER_OFFSET);\r\nwritel_relaxed(gfer, c->regbase + GFER_OFFSET);\r\n}\r\nstatic int pxa_gpio_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nint gpio = pxa_irq_to_gpio(d->irq);\r\nstruct pxa_gpio_chip *c = gpio_to_pxachip(gpio);\r\nif (c->set_wake)\r\nreturn c->set_wake(gpio, on);\r\nelse\r\nreturn 0;\r\n}\r\nstatic void pxa_unmask_muxed_gpio(struct irq_data *d)\r\n{\r\nint gpio = pxa_irq_to_gpio(d->irq);\r\nstruct pxa_gpio_chip *c = gpio_to_pxachip(gpio);\r\nc->irq_mask |= GPIO_bit(gpio);\r\nupdate_edge_detect(c);\r\n}\r\nstatic int pxa_gpio_nums(struct platform_device *pdev)\r\n{\r\nconst struct platform_device_id *id = platform_get_device_id(pdev);\r\nstruct pxa_gpio_id *pxa_id = (struct pxa_gpio_id *)id->driver_data;\r\nint count = 0;\r\nswitch (pxa_id->type) {\r\ncase PXA25X_GPIO:\r\ncase PXA26X_GPIO:\r\ncase PXA27X_GPIO:\r\ncase PXA3XX_GPIO:\r\ncase PXA93X_GPIO:\r\ncase MMP_GPIO:\r\ncase MMP2_GPIO:\r\ncase PXA1928_GPIO:\r\ngpio_type = pxa_id->type;\r\ncount = pxa_id->gpio_nums - 1;\r\nbreak;\r\ndefault:\r\ncount = -EINVAL;\r\nbreak;\r\n}\r\nreturn count;\r\n}\r\nstatic int pxa_irq_domain_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hw)\r\n{\r\nirq_set_chip_and_handler(irq, &pxa_muxed_gpio_chip,\r\nhandle_edge_irq);\r\nirq_set_noprobe(irq);\r\nreturn 0;\r\n}\r\nstatic int pxa_gpio_probe_dt(struct platform_device *pdev)\r\n{\r\nint ret = 0, nr_gpios;\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *of_id =\r\nof_match_device(pxa_gpio_dt_ids, &pdev->dev);\r\nconst struct pxa_gpio_id *gpio_id;\r\nif (!of_id || !of_id->data) {\r\ndev_err(&pdev->dev, "Failed to find gpio controller\n");\r\nreturn -EFAULT;\r\n}\r\ngpio_id = of_id->data;\r\ngpio_type = gpio_id->type;\r\nnr_gpios = gpio_id->gpio_nums;\r\npxa_last_gpio = nr_gpios - 1;\r\nirq_base = irq_alloc_descs(-1, 0, nr_gpios, 0);\r\nif (irq_base < 0) {\r\ndev_err(&pdev->dev, "Failed to allocate IRQ numbers\n");\r\nret = irq_base;\r\ngoto err;\r\n}\r\ndomain = irq_domain_add_legacy(np, nr_gpios, irq_base, 0,\r\n&pxa_irq_domain_ops, NULL);\r\npxa_gpio_of_node = np;\r\nreturn 0;\r\nerr:\r\niounmap(gpio_reg_base);\r\nreturn ret;\r\n}\r\nstatic int pxa_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct pxa_gpio_chip *c;\r\nstruct resource *res;\r\nstruct clk *clk;\r\nstruct pxa_gpio_platform_data *info;\r\nint gpio, irq, ret, use_of = 0;\r\nint irq0 = 0, irq1 = 0, irq_mux, gpio_offset = 0;\r\ninfo = dev_get_platdata(&pdev->dev);\r\nif (info) {\r\nirq_base = info->irq_base;\r\nif (irq_base <= 0)\r\nreturn -EINVAL;\r\npxa_last_gpio = pxa_gpio_nums(pdev);\r\n} else {\r\nirq_base = 0;\r\nuse_of = 1;\r\nret = pxa_gpio_probe_dt(pdev);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\n}\r\nif (!pxa_last_gpio)\r\nreturn -EINVAL;\r\nirq0 = platform_get_irq_byname(pdev, "gpio0");\r\nirq1 = platform_get_irq_byname(pdev, "gpio1");\r\nirq_mux = platform_get_irq_byname(pdev, "gpio_mux");\r\nif ((irq0 > 0 && irq1 <= 0) || (irq0 <= 0 && irq1 > 0)\r\n|| (irq_mux <= 0))\r\nreturn -EINVAL;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -EINVAL;\r\ngpio_reg_base = ioremap(res->start, resource_size(res));\r\nif (!gpio_reg_base)\r\nreturn -EINVAL;\r\nif (irq0 > 0)\r\ngpio_offset = 2;\r\nclk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "Error %ld to get gpio clock\n",\r\nPTR_ERR(clk));\r\niounmap(gpio_reg_base);\r\nreturn PTR_ERR(clk);\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret) {\r\nclk_put(clk);\r\niounmap(gpio_reg_base);\r\nreturn ret;\r\n}\r\npxa_init_gpio_chip(pxa_last_gpio, info ? info->gpio_set_wake : NULL);\r\nfor_each_gpio_chip(gpio, c) {\r\nwritel_relaxed(0, c->regbase + GFER_OFFSET);\r\nwritel_relaxed(0, c->regbase + GRER_OFFSET);\r\nwritel_relaxed(~0, c->regbase + GEDR_OFFSET);\r\nif (gpio_is_mmp_type(gpio_type))\r\nwritel_relaxed(~0, c->regbase + ED_MASK_OFFSET);\r\n}\r\nif (!use_of) {\r\nif (irq0 > 0) {\r\nirq = gpio_to_irq(0);\r\nirq_set_chip_and_handler(irq, &pxa_muxed_gpio_chip,\r\nhandle_edge_irq);\r\nirq_clear_status_flags(irq, IRQ_NOREQUEST | IRQ_NOPROBE);\r\n}\r\nif (irq1 > 0) {\r\nirq = gpio_to_irq(1);\r\nirq_set_chip_and_handler(irq, &pxa_muxed_gpio_chip,\r\nhandle_edge_irq);\r\nirq_clear_status_flags(irq, IRQ_NOREQUEST | IRQ_NOPROBE);\r\n}\r\nfor (irq = gpio_to_irq(gpio_offset);\r\nirq <= gpio_to_irq(pxa_last_gpio); irq++) {\r\nirq_set_chip_and_handler(irq, &pxa_muxed_gpio_chip,\r\nhandle_edge_irq);\r\nirq_clear_status_flags(irq, IRQ_NOREQUEST | IRQ_NOPROBE);\r\n}\r\n}\r\nif (irq0 > 0)\r\nirq_set_chained_handler(irq0, pxa_gpio_demux_handler);\r\nif (irq1 > 0)\r\nirq_set_chained_handler(irq1, pxa_gpio_demux_handler);\r\nirq_set_chained_handler(irq_mux, pxa_gpio_demux_handler);\r\nreturn 0;\r\n}\r\nstatic int __init pxa_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&pxa_gpio_driver);\r\n}\r\nstatic int pxa_gpio_suspend(void)\r\n{\r\nstruct pxa_gpio_chip *c;\r\nint gpio;\r\nfor_each_gpio_chip(gpio, c) {\r\nc->saved_gplr = readl_relaxed(c->regbase + GPLR_OFFSET);\r\nc->saved_gpdr = readl_relaxed(c->regbase + GPDR_OFFSET);\r\nc->saved_grer = readl_relaxed(c->regbase + GRER_OFFSET);\r\nc->saved_gfer = readl_relaxed(c->regbase + GFER_OFFSET);\r\nwritel_relaxed(0xffffffff, c->regbase + GEDR_OFFSET);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pxa_gpio_resume(void)\r\n{\r\nstruct pxa_gpio_chip *c;\r\nint gpio;\r\nfor_each_gpio_chip(gpio, c) {\r\nwritel_relaxed(c->saved_gplr, c->regbase + GPSR_OFFSET);\r\nwritel_relaxed(~c->saved_gplr, c->regbase + GPCR_OFFSET);\r\nwritel_relaxed(c->saved_grer, c->regbase + GRER_OFFSET);\r\nwritel_relaxed(c->saved_gfer, c->regbase + GFER_OFFSET);\r\nwritel_relaxed(c->saved_gpdr, c->regbase + GPDR_OFFSET);\r\n}\r\n}\r\nstatic int __init pxa_gpio_sysinit(void)\r\n{\r\nregister_syscore_ops(&pxa_gpio_syscore_ops);\r\nreturn 0;\r\n}
