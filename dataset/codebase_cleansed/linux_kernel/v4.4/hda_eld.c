static unsigned int hdmi_get_eld_data(struct hda_codec *codec, hda_nid_t nid,\r\nint byte_index)\r\n{\r\nunsigned int val;\r\nval = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_HDMI_ELDD, byte_index);\r\n#ifdef BE_PARANOID\r\ncodec_info(codec, "HDMI: ELD data byte %d: 0x%x\n", byte_index, val);\r\n#endif\r\nreturn val;\r\n}\r\nstatic void hdmi_update_short_audio_desc(struct hda_codec *codec,\r\nstruct cea_sad *a,\r\nconst unsigned char *buf)\r\n{\r\nint i;\r\nint val;\r\nval = GRAB_BITS(buf, 1, 0, 7);\r\na->rates = 0;\r\nfor (i = 0; i < 7; i++)\r\nif (val & (1 << i))\r\na->rates |= cea_sampling_frequencies[i + 1];\r\na->channels = GRAB_BITS(buf, 0, 0, 3);\r\na->channels++;\r\na->sample_bits = 0;\r\na->max_bitrate = 0;\r\na->format = GRAB_BITS(buf, 0, 3, 4);\r\nswitch (a->format) {\r\ncase AUDIO_CODING_TYPE_REF_STREAM_HEADER:\r\ncodec_info(codec, "HDMI: audio coding type 0 not expected\n");\r\nbreak;\r\ncase AUDIO_CODING_TYPE_LPCM:\r\nval = GRAB_BITS(buf, 2, 0, 3);\r\nfor (i = 0; i < 3; i++)\r\nif (val & (1 << i))\r\na->sample_bits |= cea_sample_sizes[i + 1];\r\nbreak;\r\ncase AUDIO_CODING_TYPE_AC3:\r\ncase AUDIO_CODING_TYPE_MPEG1:\r\ncase AUDIO_CODING_TYPE_MP3:\r\ncase AUDIO_CODING_TYPE_MPEG2:\r\ncase AUDIO_CODING_TYPE_AACLC:\r\ncase AUDIO_CODING_TYPE_DTS:\r\ncase AUDIO_CODING_TYPE_ATRAC:\r\na->max_bitrate = GRAB_BITS(buf, 2, 0, 8);\r\na->max_bitrate *= 8000;\r\nbreak;\r\ncase AUDIO_CODING_TYPE_SACD:\r\nbreak;\r\ncase AUDIO_CODING_TYPE_EAC3:\r\nbreak;\r\ncase AUDIO_CODING_TYPE_DTS_HD:\r\nbreak;\r\ncase AUDIO_CODING_TYPE_MLP:\r\nbreak;\r\ncase AUDIO_CODING_TYPE_DST:\r\nbreak;\r\ncase AUDIO_CODING_TYPE_WMAPRO:\r\na->profile = GRAB_BITS(buf, 2, 0, 3);\r\nbreak;\r\ncase AUDIO_CODING_TYPE_REF_CXT:\r\na->format = GRAB_BITS(buf, 2, 3, 5);\r\nif (a->format == AUDIO_CODING_XTYPE_HE_REF_CT ||\r\na->format >= AUDIO_CODING_XTYPE_FIRST_RESERVED) {\r\ncodec_info(codec,\r\n"HDMI: audio coding xtype %d not expected\n",\r\na->format);\r\na->format = 0;\r\n} else\r\na->format += AUDIO_CODING_TYPE_HE_AAC -\r\nAUDIO_CODING_XTYPE_HE_AAC;\r\nbreak;\r\n}\r\n}\r\nint snd_hdmi_parse_eld(struct hda_codec *codec, struct parsed_hdmi_eld *e,\r\nconst unsigned char *buf, int size)\r\n{\r\nint mnl;\r\nint i;\r\ne->eld_ver = GRAB_BITS(buf, 0, 3, 5);\r\nif (e->eld_ver != ELD_VER_CEA_861D &&\r\ne->eld_ver != ELD_VER_PARTIAL) {\r\ncodec_info(codec, "HDMI: Unknown ELD version %d\n", e->eld_ver);\r\ngoto out_fail;\r\n}\r\ne->baseline_len = GRAB_BITS(buf, 2, 0, 8);\r\nmnl = GRAB_BITS(buf, 4, 0, 5);\r\ne->cea_edid_ver = GRAB_BITS(buf, 4, 5, 3);\r\ne->support_hdcp = GRAB_BITS(buf, 5, 0, 1);\r\ne->support_ai = GRAB_BITS(buf, 5, 1, 1);\r\ne->conn_type = GRAB_BITS(buf, 5, 2, 2);\r\ne->sad_count = GRAB_BITS(buf, 5, 4, 4);\r\ne->aud_synch_delay = GRAB_BITS(buf, 6, 0, 8) * 2;\r\ne->spk_alloc = GRAB_BITS(buf, 7, 0, 7);\r\ne->port_id = get_unaligned_le64(buf + 8);\r\ne->manufacture_id = get_unaligned_le16(buf + 16);\r\ne->product_id = get_unaligned_le16(buf + 18);\r\nif (mnl > ELD_MAX_MNL) {\r\ncodec_info(codec, "HDMI: MNL is reserved value %d\n", mnl);\r\ngoto out_fail;\r\n} else if (ELD_FIXED_BYTES + mnl > size) {\r\ncodec_info(codec, "HDMI: out of range MNL %d\n", mnl);\r\ngoto out_fail;\r\n} else\r\nstrlcpy(e->monitor_name, buf + ELD_FIXED_BYTES, mnl + 1);\r\nfor (i = 0; i < e->sad_count; i++) {\r\nif (ELD_FIXED_BYTES + mnl + 3 * (i + 1) > size) {\r\ncodec_info(codec, "HDMI: out of range SAD %d\n", i);\r\ngoto out_fail;\r\n}\r\nhdmi_update_short_audio_desc(codec, e->sad + i,\r\nbuf + ELD_FIXED_BYTES + mnl + 3 * i);\r\n}\r\nif (!e->spk_alloc)\r\ne->spk_alloc = 0xffff;\r\nreturn 0;\r\nout_fail:\r\nreturn -EINVAL;\r\n}\r\nint snd_hdmi_get_eld_size(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nreturn snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_HDMI_DIP_SIZE,\r\nAC_DIPSIZE_ELD_BUF);\r\n}\r\nint snd_hdmi_get_eld(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned char *buf, int *eld_size)\r\n{\r\nint i;\r\nint ret = 0;\r\nint size;\r\nsize = snd_hdmi_get_eld_size(codec, nid);\r\nif (size == 0) {\r\ncodec_info(codec, "HDMI: ELD buf size is 0, force 128\n");\r\nsize = 128;\r\n}\r\nif (size < ELD_FIXED_BYTES || size > ELD_MAX_SIZE) {\r\ncodec_info(codec, "HDMI: invalid ELD buf size %d\n", size);\r\nreturn -ERANGE;\r\n}\r\nfor (i = 0; i < size; i++) {\r\nunsigned int val = hdmi_get_eld_data(codec, nid, i);\r\nif (!(val & AC_ELDD_ELD_VALID)) {\r\ncodec_info(codec, "HDMI: invalid ELD data byte %d\n", i);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nval &= AC_ELDD_ELD_DATA;\r\nif (!val && !i) {\r\ncodec_dbg(codec, "HDMI: 0 ELD data\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nbuf[i] = val;\r\n}\r\n*eld_size = size;\r\nerror:\r\nreturn ret;\r\n}\r\nstatic void hdmi_print_pcm_rates(int pcm, char *buf, int buflen)\r\n{\r\nstatic unsigned int alsa_rates[] = {\r\n5512, 8000, 11025, 16000, 22050, 32000, 44100, 48000, 64000,\r\n88200, 96000, 176400, 192000, 384000\r\n};\r\nint i, j;\r\nfor (i = 0, j = 0; i < ARRAY_SIZE(alsa_rates); i++)\r\nif (pcm & (1 << i))\r\nj += snprintf(buf + j, buflen - j, " %d",\r\nalsa_rates[i]);\r\nbuf[j] = '\0';\r\n}\r\nstatic void hdmi_show_short_audio_desc(struct hda_codec *codec,\r\nstruct cea_sad *a)\r\n{\r\nchar buf[SND_PRINT_RATES_ADVISED_BUFSIZE];\r\nchar buf2[8 + SND_PRINT_BITS_ADVISED_BUFSIZE] = ", bits =";\r\nif (!a->format)\r\nreturn;\r\nhdmi_print_pcm_rates(a->rates, buf, sizeof(buf));\r\nif (a->format == AUDIO_CODING_TYPE_LPCM)\r\nsnd_print_pcm_bits(a->sample_bits, buf2 + 8, sizeof(buf2) - 8);\r\nelse if (a->max_bitrate)\r\nsnprintf(buf2, sizeof(buf2),\r\n", max bitrate = %d", a->max_bitrate);\r\nelse\r\nbuf2[0] = '\0';\r\ncodec_dbg(codec,\r\n"HDMI: supports coding type %s: channels = %d, rates =%s%s\n",\r\ncea_audio_coding_type_names[a->format],\r\na->channels, buf, buf2);\r\n}\r\nvoid snd_print_channel_allocation(int spk_alloc, char *buf, int buflen)\r\n{\r\nint i, j;\r\nfor (i = 0, j = 0; i < ARRAY_SIZE(cea_speaker_allocation_names); i++) {\r\nif (spk_alloc & (1 << i))\r\nj += snprintf(buf + j, buflen - j, " %s",\r\ncea_speaker_allocation_names[i]);\r\n}\r\nbuf[j] = '\0';\r\n}\r\nvoid snd_hdmi_show_eld(struct hda_codec *codec, struct parsed_hdmi_eld *e)\r\n{\r\nint i;\r\ncodec_dbg(codec, "HDMI: detected monitor %s at connection type %s\n",\r\ne->monitor_name,\r\neld_connection_type_names[e->conn_type]);\r\nif (e->spk_alloc) {\r\nchar buf[SND_PRINT_CHANNEL_ALLOCATION_ADVISED_BUFSIZE];\r\nsnd_print_channel_allocation(e->spk_alloc, buf, sizeof(buf));\r\ncodec_dbg(codec, "HDMI: available speakers:%s\n", buf);\r\n}\r\nfor (i = 0; i < e->sad_count; i++)\r\nhdmi_show_short_audio_desc(codec, e->sad + i);\r\n}\r\nstatic void hdmi_print_sad_info(int i, struct cea_sad *a,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nchar buf[SND_PRINT_RATES_ADVISED_BUFSIZE];\r\nsnd_iprintf(buffer, "sad%d_coding_type\t[0x%x] %s\n",\r\ni, a->format, cea_audio_coding_type_names[a->format]);\r\nsnd_iprintf(buffer, "sad%d_channels\t\t%d\n", i, a->channels);\r\nhdmi_print_pcm_rates(a->rates, buf, sizeof(buf));\r\nsnd_iprintf(buffer, "sad%d_rates\t\t[0x%x]%s\n", i, a->rates, buf);\r\nif (a->format == AUDIO_CODING_TYPE_LPCM) {\r\nsnd_print_pcm_bits(a->sample_bits, buf, sizeof(buf));\r\nsnd_iprintf(buffer, "sad%d_bits\t\t[0x%x]%s\n",\r\ni, a->sample_bits, buf);\r\n}\r\nif (a->max_bitrate)\r\nsnd_iprintf(buffer, "sad%d_max_bitrate\t%d\n",\r\ni, a->max_bitrate);\r\nif (a->profile)\r\nsnd_iprintf(buffer, "sad%d_profile\t\t%d\n", i, a->profile);\r\n}\r\nvoid snd_hdmi_print_eld_info(struct hdmi_eld *eld,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct parsed_hdmi_eld *e = &eld->info;\r\nchar buf[SND_PRINT_CHANNEL_ALLOCATION_ADVISED_BUFSIZE];\r\nint i;\r\nstatic const char * const eld_version_names[32] = {\r\n"reserved",\r\n"reserved",\r\n"CEA-861D or below",\r\n[3 ... 30] = "reserved",\r\n[31] = "partial"\r\n};\r\nstatic const char * const cea_edid_version_names[8] = {\r\n"no CEA EDID Timing Extension block present",\r\n"CEA-861",\r\n"CEA-861-A",\r\n"CEA-861-B, C or D",\r\n[4 ... 7] = "reserved"\r\n};\r\nsnd_iprintf(buffer, "monitor_present\t\t%d\n", eld->monitor_present);\r\nsnd_iprintf(buffer, "eld_valid\t\t%d\n", eld->eld_valid);\r\nif (!eld->eld_valid)\r\nreturn;\r\nsnd_iprintf(buffer, "monitor_name\t\t%s\n", e->monitor_name);\r\nsnd_iprintf(buffer, "connection_type\t\t%s\n",\r\neld_connection_type_names[e->conn_type]);\r\nsnd_iprintf(buffer, "eld_version\t\t[0x%x] %s\n", e->eld_ver,\r\neld_version_names[e->eld_ver]);\r\nsnd_iprintf(buffer, "edid_version\t\t[0x%x] %s\n", e->cea_edid_ver,\r\ncea_edid_version_names[e->cea_edid_ver]);\r\nsnd_iprintf(buffer, "manufacture_id\t\t0x%x\n", e->manufacture_id);\r\nsnd_iprintf(buffer, "product_id\t\t0x%x\n", e->product_id);\r\nsnd_iprintf(buffer, "port_id\t\t\t0x%llx\n", (long long)e->port_id);\r\nsnd_iprintf(buffer, "support_hdcp\t\t%d\n", e->support_hdcp);\r\nsnd_iprintf(buffer, "support_ai\t\t%d\n", e->support_ai);\r\nsnd_iprintf(buffer, "audio_sync_delay\t%d\n", e->aud_synch_delay);\r\nsnd_print_channel_allocation(e->spk_alloc, buf, sizeof(buf));\r\nsnd_iprintf(buffer, "speakers\t\t[0x%x]%s\n", e->spk_alloc, buf);\r\nsnd_iprintf(buffer, "sad_count\t\t%d\n", e->sad_count);\r\nfor (i = 0; i < e->sad_count; i++)\r\nhdmi_print_sad_info(i, e->sad + i, buffer);\r\n}\r\nvoid snd_hdmi_write_eld_info(struct hdmi_eld *eld,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct parsed_hdmi_eld *e = &eld->info;\r\nchar line[64];\r\nchar name[64];\r\nchar *sname;\r\nlong long val;\r\nunsigned int n;\r\nwhile (!snd_info_get_line(buffer, line, sizeof(line))) {\r\nif (sscanf(line, "%s %llx", name, &val) != 2)\r\ncontinue;\r\nif (!strcmp(name, "monitor_present"))\r\neld->monitor_present = val;\r\nelse if (!strcmp(name, "eld_valid"))\r\neld->eld_valid = val;\r\nelse if (!strcmp(name, "connection_type"))\r\ne->conn_type = val;\r\nelse if (!strcmp(name, "port_id"))\r\ne->port_id = val;\r\nelse if (!strcmp(name, "support_hdcp"))\r\ne->support_hdcp = val;\r\nelse if (!strcmp(name, "support_ai"))\r\ne->support_ai = val;\r\nelse if (!strcmp(name, "audio_sync_delay"))\r\ne->aud_synch_delay = val;\r\nelse if (!strcmp(name, "speakers"))\r\ne->spk_alloc = val;\r\nelse if (!strcmp(name, "sad_count"))\r\ne->sad_count = val;\r\nelse if (!strncmp(name, "sad", 3)) {\r\nsname = name + 4;\r\nn = name[3] - '0';\r\nif (name[4] >= '0' && name[4] <= '9') {\r\nsname++;\r\nn = 10 * n + name[4] - '0';\r\n}\r\nif (n >= ELD_MAX_SAD)\r\ncontinue;\r\nif (!strcmp(sname, "_coding_type"))\r\ne->sad[n].format = val;\r\nelse if (!strcmp(sname, "_channels"))\r\ne->sad[n].channels = val;\r\nelse if (!strcmp(sname, "_rates"))\r\ne->sad[n].rates = val;\r\nelse if (!strcmp(sname, "_bits"))\r\ne->sad[n].sample_bits = val;\r\nelse if (!strcmp(sname, "_max_bitrate"))\r\ne->sad[n].max_bitrate = val;\r\nelse if (!strcmp(sname, "_profile"))\r\ne->sad[n].profile = val;\r\nif (n >= e->sad_count)\r\ne->sad_count = n + 1;\r\n}\r\n}\r\n}\r\nvoid snd_hdmi_eld_update_pcm_info(struct parsed_hdmi_eld *e,\r\nstruct hda_pcm_stream *hinfo)\r\n{\r\nu32 rates;\r\nu64 formats;\r\nunsigned int maxbps;\r\nunsigned int channels_max;\r\nint i;\r\nrates = SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\r\nSNDRV_PCM_RATE_48000;\r\nformats = SNDRV_PCM_FMTBIT_S16_LE;\r\nmaxbps = 16;\r\nchannels_max = 2;\r\nfor (i = 0; i < e->sad_count; i++) {\r\nstruct cea_sad *a = &e->sad[i];\r\nrates |= a->rates;\r\nif (a->channels > channels_max)\r\nchannels_max = a->channels;\r\nif (a->format == AUDIO_CODING_TYPE_LPCM) {\r\nif (a->sample_bits & AC_SUPPCM_BITS_20) {\r\nformats |= SNDRV_PCM_FMTBIT_S32_LE;\r\nif (maxbps < 20)\r\nmaxbps = 20;\r\n}\r\nif (a->sample_bits & AC_SUPPCM_BITS_24) {\r\nformats |= SNDRV_PCM_FMTBIT_S32_LE;\r\nif (maxbps < 24)\r\nmaxbps = 24;\r\n}\r\n}\r\n}\r\nhinfo->rates &= rates;\r\nhinfo->formats &= formats;\r\nhinfo->maxbps = min(hinfo->maxbps, maxbps);\r\nhinfo->channels_max = min(hinfo->channels_max, channels_max);\r\n}\r\nint snd_hdmi_get_eld_ati(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned char *buf, int *eld_size, bool rev3_or_later)\r\n{\r\nint spkalloc, ati_sad, aud_synch;\r\nint sink_desc_len = 0;\r\nint pos, i;\r\nspkalloc = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SPEAKER_ALLOCATION, 0);\r\nif (spkalloc <= 0) {\r\ncodec_info(codec, "HDMI ATI/AMD: no speaker allocation for ELD\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(buf, 0, ELD_FIXED_BYTES + ELD_MAX_MNL + ELD_MAX_SAD * 3);\r\nbuf[0] = ELD_VER_CEA_861D << 3;\r\nbuf[7] = spkalloc & ATI_SPKALLOC_SPKALLOC;\r\nif (spkalloc & ATI_SPKALLOC_TYPE_DISPLAYPORT)\r\nbuf[5] |= 0x04;\r\npos = ELD_FIXED_BYTES;\r\nif (rev3_or_later) {\r\nint sink_info;\r\nsnd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_PORT_ID_LOW);\r\nsink_info = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);\r\nput_unaligned_le32(sink_info, buf + 8);\r\nsnd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_PORT_ID_HIGH);\r\nsink_info = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);\r\nput_unaligned_le32(sink_info, buf + 12);\r\nsnd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_MANUFACTURER_ID);\r\nsink_info = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);\r\nput_unaligned_le16(sink_info, buf + 16);\r\nsnd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_PRODUCT_ID);\r\nsink_info = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);\r\nput_unaligned_le16(sink_info, buf + 18);\r\nsnd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_SINK_DESC_LEN);\r\nsink_desc_len = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);\r\nif (sink_desc_len > ELD_MAX_MNL) {\r\ncodec_info(codec, "HDMI ATI/AMD: Truncating HDMI sink description with length %d\n",\r\nsink_desc_len);\r\nsink_desc_len = ELD_MAX_MNL;\r\n}\r\nbuf[4] |= sink_desc_len;\r\nfor (i = 0; i < sink_desc_len; i++) {\r\nsnd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_SINK_DESC_FIRST + i);\r\nbuf[pos++] = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);\r\n}\r\n}\r\nfor (i = AUDIO_CODING_TYPE_LPCM; i <= AUDIO_CODING_TYPE_WMAPRO; i++) {\r\nif (i == AUDIO_CODING_TYPE_SACD || i == AUDIO_CODING_TYPE_DST)\r\ncontinue;\r\nsnd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_AUDIO_DESCRIPTOR, i << 3);\r\nati_sad = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_AUDIO_DESCRIPTOR, 0);\r\nif (ati_sad <= 0)\r\ncontinue;\r\nif (ati_sad & ATI_AUDIODESC_RATES) {\r\nbuf[pos++] = (ati_sad & 0x0000ff) >> 0;\r\nbuf[pos++] = (ati_sad & 0x00ff00) >> 8;\r\nbuf[pos++] = (ati_sad & 0xff0000) >> 16;\r\n}\r\nif (i == AUDIO_CODING_TYPE_LPCM\r\n&& (ati_sad & ATI_AUDIODESC_LPCM_STEREO_RATES)\r\n&& (ati_sad & ATI_AUDIODESC_LPCM_STEREO_RATES) >> 16 != (ati_sad & ATI_AUDIODESC_RATES)) {\r\nbuf[pos++] = ((ati_sad & 0x000000ff) & ~ATI_AUDIODESC_CHANNELS) | 0x1;\r\nbuf[pos++] = (ati_sad & 0xff000000) >> 24;\r\nbuf[pos++] = (ati_sad & 0x00ff0000) >> 16;\r\n}\r\n}\r\nif (pos == ELD_FIXED_BYTES + sink_desc_len) {\r\ncodec_info(codec, "HDMI ATI/AMD: no audio descriptors for ELD\n");\r\nreturn -EINVAL;\r\n}\r\naud_synch = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_AUDIO_VIDEO_DELAY, 0);\r\nif ((aud_synch & ATI_DELAY_VIDEO_LATENCY) && (aud_synch & ATI_DELAY_AUDIO_LATENCY)) {\r\nint video_latency_hdmi = (aud_synch & ATI_DELAY_VIDEO_LATENCY);\r\nint audio_latency_hdmi = (aud_synch & ATI_DELAY_AUDIO_LATENCY) >> 8;\r\nif (video_latency_hdmi <= 0xfb && audio_latency_hdmi <= 0xfb &&\r\nvideo_latency_hdmi > audio_latency_hdmi)\r\nbuf[6] = video_latency_hdmi - audio_latency_hdmi;\r\n}\r\nbuf[5] |= ((pos - ELD_FIXED_BYTES - sink_desc_len) / 3) << 4;\r\npos = round_up(pos, 4);\r\nbuf[2] = (pos - 4) / 4;\r\n*eld_size = pos;\r\nreturn 0;\r\n}
