static void amdgpu_ucode_print_common_hdr(const struct common_firmware_header *hdr)\r\n{\r\nDRM_DEBUG("size_bytes: %u\n", le32_to_cpu(hdr->size_bytes));\r\nDRM_DEBUG("header_size_bytes: %u\n", le32_to_cpu(hdr->header_size_bytes));\r\nDRM_DEBUG("header_version_major: %u\n", le16_to_cpu(hdr->header_version_major));\r\nDRM_DEBUG("header_version_minor: %u\n", le16_to_cpu(hdr->header_version_minor));\r\nDRM_DEBUG("ip_version_major: %u\n", le16_to_cpu(hdr->ip_version_major));\r\nDRM_DEBUG("ip_version_minor: %u\n", le16_to_cpu(hdr->ip_version_minor));\r\nDRM_DEBUG("ucode_version: 0x%08x\n", le32_to_cpu(hdr->ucode_version));\r\nDRM_DEBUG("ucode_size_bytes: %u\n", le32_to_cpu(hdr->ucode_size_bytes));\r\nDRM_DEBUG("ucode_array_offset_bytes: %u\n",\r\nle32_to_cpu(hdr->ucode_array_offset_bytes));\r\nDRM_DEBUG("crc32: 0x%08x\n", le32_to_cpu(hdr->crc32));\r\n}\r\nvoid amdgpu_ucode_print_mc_hdr(const struct common_firmware_header *hdr)\r\n{\r\nuint16_t version_major = le16_to_cpu(hdr->header_version_major);\r\nuint16_t version_minor = le16_to_cpu(hdr->header_version_minor);\r\nDRM_DEBUG("MC\n");\r\namdgpu_ucode_print_common_hdr(hdr);\r\nif (version_major == 1) {\r\nconst struct mc_firmware_header_v1_0 *mc_hdr =\r\ncontainer_of(hdr, struct mc_firmware_header_v1_0, header);\r\nDRM_DEBUG("io_debug_size_bytes: %u\n",\r\nle32_to_cpu(mc_hdr->io_debug_size_bytes));\r\nDRM_DEBUG("io_debug_array_offset_bytes: %u\n",\r\nle32_to_cpu(mc_hdr->io_debug_array_offset_bytes));\r\n} else {\r\nDRM_ERROR("Unknown MC ucode version: %u.%u\n", version_major, version_minor);\r\n}\r\n}\r\nvoid amdgpu_ucode_print_smc_hdr(const struct common_firmware_header *hdr)\r\n{\r\nuint16_t version_major = le16_to_cpu(hdr->header_version_major);\r\nuint16_t version_minor = le16_to_cpu(hdr->header_version_minor);\r\nDRM_DEBUG("SMC\n");\r\namdgpu_ucode_print_common_hdr(hdr);\r\nif (version_major == 1) {\r\nconst struct smc_firmware_header_v1_0 *smc_hdr =\r\ncontainer_of(hdr, struct smc_firmware_header_v1_0, header);\r\nDRM_DEBUG("ucode_start_addr: %u\n", le32_to_cpu(smc_hdr->ucode_start_addr));\r\n} else {\r\nDRM_ERROR("Unknown SMC ucode version: %u.%u\n", version_major, version_minor);\r\n}\r\n}\r\nvoid amdgpu_ucode_print_gfx_hdr(const struct common_firmware_header *hdr)\r\n{\r\nuint16_t version_major = le16_to_cpu(hdr->header_version_major);\r\nuint16_t version_minor = le16_to_cpu(hdr->header_version_minor);\r\nDRM_DEBUG("GFX\n");\r\namdgpu_ucode_print_common_hdr(hdr);\r\nif (version_major == 1) {\r\nconst struct gfx_firmware_header_v1_0 *gfx_hdr =\r\ncontainer_of(hdr, struct gfx_firmware_header_v1_0, header);\r\nDRM_DEBUG("ucode_feature_version: %u\n",\r\nle32_to_cpu(gfx_hdr->ucode_feature_version));\r\nDRM_DEBUG("jt_offset: %u\n", le32_to_cpu(gfx_hdr->jt_offset));\r\nDRM_DEBUG("jt_size: %u\n", le32_to_cpu(gfx_hdr->jt_size));\r\n} else {\r\nDRM_ERROR("Unknown GFX ucode version: %u.%u\n", version_major, version_minor);\r\n}\r\n}\r\nvoid amdgpu_ucode_print_rlc_hdr(const struct common_firmware_header *hdr)\r\n{\r\nuint16_t version_major = le16_to_cpu(hdr->header_version_major);\r\nuint16_t version_minor = le16_to_cpu(hdr->header_version_minor);\r\nDRM_DEBUG("RLC\n");\r\namdgpu_ucode_print_common_hdr(hdr);\r\nif (version_major == 1) {\r\nconst struct rlc_firmware_header_v1_0 *rlc_hdr =\r\ncontainer_of(hdr, struct rlc_firmware_header_v1_0, header);\r\nDRM_DEBUG("ucode_feature_version: %u\n",\r\nle32_to_cpu(rlc_hdr->ucode_feature_version));\r\nDRM_DEBUG("save_and_restore_offset: %u\n",\r\nle32_to_cpu(rlc_hdr->save_and_restore_offset));\r\nDRM_DEBUG("clear_state_descriptor_offset: %u\n",\r\nle32_to_cpu(rlc_hdr->clear_state_descriptor_offset));\r\nDRM_DEBUG("avail_scratch_ram_locations: %u\n",\r\nle32_to_cpu(rlc_hdr->avail_scratch_ram_locations));\r\nDRM_DEBUG("master_pkt_description_offset: %u\n",\r\nle32_to_cpu(rlc_hdr->master_pkt_description_offset));\r\n} else if (version_major == 2) {\r\nconst struct rlc_firmware_header_v2_0 *rlc_hdr =\r\ncontainer_of(hdr, struct rlc_firmware_header_v2_0, header);\r\nDRM_DEBUG("ucode_feature_version: %u\n",\r\nle32_to_cpu(rlc_hdr->ucode_feature_version));\r\nDRM_DEBUG("jt_offset: %u\n", le32_to_cpu(rlc_hdr->jt_offset));\r\nDRM_DEBUG("jt_size: %u\n", le32_to_cpu(rlc_hdr->jt_size));\r\nDRM_DEBUG("save_and_restore_offset: %u\n",\r\nle32_to_cpu(rlc_hdr->save_and_restore_offset));\r\nDRM_DEBUG("clear_state_descriptor_offset: %u\n",\r\nle32_to_cpu(rlc_hdr->clear_state_descriptor_offset));\r\nDRM_DEBUG("avail_scratch_ram_locations: %u\n",\r\nle32_to_cpu(rlc_hdr->avail_scratch_ram_locations));\r\nDRM_DEBUG("reg_restore_list_size: %u\n",\r\nle32_to_cpu(rlc_hdr->reg_restore_list_size));\r\nDRM_DEBUG("reg_list_format_start: %u\n",\r\nle32_to_cpu(rlc_hdr->reg_list_format_start));\r\nDRM_DEBUG("reg_list_format_separate_start: %u\n",\r\nle32_to_cpu(rlc_hdr->reg_list_format_separate_start));\r\nDRM_DEBUG("starting_offsets_start: %u\n",\r\nle32_to_cpu(rlc_hdr->starting_offsets_start));\r\nDRM_DEBUG("reg_list_format_size_bytes: %u\n",\r\nle32_to_cpu(rlc_hdr->reg_list_format_size_bytes));\r\nDRM_DEBUG("reg_list_format_array_offset_bytes: %u\n",\r\nle32_to_cpu(rlc_hdr->reg_list_format_array_offset_bytes));\r\nDRM_DEBUG("reg_list_size_bytes: %u\n",\r\nle32_to_cpu(rlc_hdr->reg_list_size_bytes));\r\nDRM_DEBUG("reg_list_array_offset_bytes: %u\n",\r\nle32_to_cpu(rlc_hdr->reg_list_array_offset_bytes));\r\nDRM_DEBUG("reg_list_format_separate_size_bytes: %u\n",\r\nle32_to_cpu(rlc_hdr->reg_list_format_separate_size_bytes));\r\nDRM_DEBUG("reg_list_format_separate_array_offset_bytes: %u\n",\r\nle32_to_cpu(rlc_hdr->reg_list_format_separate_array_offset_bytes));\r\nDRM_DEBUG("reg_list_separate_size_bytes: %u\n",\r\nle32_to_cpu(rlc_hdr->reg_list_separate_size_bytes));\r\nDRM_DEBUG("reg_list_separate_size_bytes: %u\n",\r\nle32_to_cpu(rlc_hdr->reg_list_separate_size_bytes));\r\n} else {\r\nDRM_ERROR("Unknown RLC ucode version: %u.%u\n", version_major, version_minor);\r\n}\r\n}\r\nvoid amdgpu_ucode_print_sdma_hdr(const struct common_firmware_header *hdr)\r\n{\r\nuint16_t version_major = le16_to_cpu(hdr->header_version_major);\r\nuint16_t version_minor = le16_to_cpu(hdr->header_version_minor);\r\nDRM_DEBUG("SDMA\n");\r\namdgpu_ucode_print_common_hdr(hdr);\r\nif (version_major == 1) {\r\nconst struct sdma_firmware_header_v1_0 *sdma_hdr =\r\ncontainer_of(hdr, struct sdma_firmware_header_v1_0, header);\r\nDRM_DEBUG("ucode_feature_version: %u\n",\r\nle32_to_cpu(sdma_hdr->ucode_feature_version));\r\nDRM_DEBUG("ucode_change_version: %u\n",\r\nle32_to_cpu(sdma_hdr->ucode_change_version));\r\nDRM_DEBUG("jt_offset: %u\n", le32_to_cpu(sdma_hdr->jt_offset));\r\nDRM_DEBUG("jt_size: %u\n", le32_to_cpu(sdma_hdr->jt_size));\r\nif (version_minor >= 1) {\r\nconst struct sdma_firmware_header_v1_1 *sdma_v1_1_hdr =\r\ncontainer_of(sdma_hdr, struct sdma_firmware_header_v1_1, v1_0);\r\nDRM_DEBUG("digest_size: %u\n", le32_to_cpu(sdma_v1_1_hdr->digest_size));\r\n}\r\n} else {\r\nDRM_ERROR("Unknown SDMA ucode version: %u.%u\n",\r\nversion_major, version_minor);\r\n}\r\n}\r\nint amdgpu_ucode_validate(const struct firmware *fw)\r\n{\r\nconst struct common_firmware_header *hdr =\r\n(const struct common_firmware_header *)fw->data;\r\nif (fw->size == le32_to_cpu(hdr->size_bytes))\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nbool amdgpu_ucode_hdr_version(union amdgpu_firmware_header *hdr,\r\nuint16_t hdr_major, uint16_t hdr_minor)\r\n{\r\nif ((hdr->common.header_version_major == hdr_major) &&\r\n(hdr->common.header_version_minor == hdr_minor))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int amdgpu_ucode_init_single_fw(struct amdgpu_firmware_info *ucode,\r\nuint64_t mc_addr, void *kptr)\r\n{\r\nconst struct common_firmware_header *header = NULL;\r\nif (NULL == ucode->fw)\r\nreturn 0;\r\nucode->mc_addr = mc_addr;\r\nucode->kaddr = kptr;\r\nheader = (const struct common_firmware_header *)ucode->fw->data;\r\nmemcpy(ucode->kaddr, (void *)((uint8_t *)ucode->fw->data +\r\nle32_to_cpu(header->ucode_array_offset_bytes)),\r\nle32_to_cpu(header->ucode_size_bytes));\r\nreturn 0;\r\n}\r\nint amdgpu_ucode_init_bo(struct amdgpu_device *adev)\r\n{\r\nstruct amdgpu_bo **bo = &adev->firmware.fw_buf;\r\nuint64_t fw_mc_addr;\r\nvoid *fw_buf_ptr = NULL;\r\nuint64_t fw_offset = 0;\r\nint i, err;\r\nstruct amdgpu_firmware_info *ucode = NULL;\r\nconst struct common_firmware_header *header = NULL;\r\nerr = amdgpu_bo_create(adev, adev->firmware.fw_size, PAGE_SIZE, true,\r\nAMDGPU_GEM_DOMAIN_GTT, 0, NULL, NULL, bo);\r\nif (err) {\r\ndev_err(adev->dev, "(%d) Firmware buffer allocate failed\n", err);\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nerr = amdgpu_bo_reserve(*bo, false);\r\nif (err) {\r\namdgpu_bo_unref(bo);\r\ndev_err(adev->dev, "(%d) Firmware buffer reserve failed\n", err);\r\ngoto failed;\r\n}\r\nerr = amdgpu_bo_pin(*bo, AMDGPU_GEM_DOMAIN_GTT, &fw_mc_addr);\r\nif (err) {\r\namdgpu_bo_unreserve(*bo);\r\namdgpu_bo_unref(bo);\r\ndev_err(adev->dev, "(%d) Firmware buffer pin failed\n", err);\r\ngoto failed;\r\n}\r\nerr = amdgpu_bo_kmap(*bo, &fw_buf_ptr);\r\nif (err) {\r\ndev_err(adev->dev, "(%d) Firmware buffer kmap failed\n", err);\r\namdgpu_bo_unpin(*bo);\r\namdgpu_bo_unreserve(*bo);\r\namdgpu_bo_unref(bo);\r\ngoto failed;\r\n}\r\namdgpu_bo_unreserve(*bo);\r\nfw_offset = 0;\r\nfor (i = 0; i < AMDGPU_UCODE_ID_MAXIMUM; i++) {\r\nucode = &adev->firmware.ucode[i];\r\nif (ucode->fw) {\r\nheader = (const struct common_firmware_header *)ucode->fw->data;\r\namdgpu_ucode_init_single_fw(ucode, fw_mc_addr + fw_offset,\r\nfw_buf_ptr + fw_offset);\r\nfw_offset += ALIGN(le32_to_cpu(header->ucode_size_bytes), PAGE_SIZE);\r\n}\r\n}\r\nfailed:\r\nif (err)\r\nadev->firmware.smu_load = false;\r\nreturn err;\r\n}\r\nint amdgpu_ucode_fini_bo(struct amdgpu_device *adev)\r\n{\r\nint i;\r\nstruct amdgpu_firmware_info *ucode = NULL;\r\nfor (i = 0; i < AMDGPU_UCODE_ID_MAXIMUM; i++) {\r\nucode = &adev->firmware.ucode[i];\r\nif (ucode->fw) {\r\nucode->mc_addr = 0;\r\nucode->kaddr = NULL;\r\n}\r\n}\r\namdgpu_bo_unref(&adev->firmware.fw_buf);\r\nadev->firmware.fw_buf = NULL;\r\nreturn 0;\r\n}
