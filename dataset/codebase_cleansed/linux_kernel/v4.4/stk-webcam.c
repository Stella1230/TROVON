int stk_camera_write_reg(struct stk_camera *dev, u16 index, u8 value)\r\n{\r\nstruct usb_device *udev = dev->udev;\r\nint ret;\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\n0x01,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue,\r\nindex,\r\nNULL,\r\n0,\r\n500);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn 0;\r\n}\r\nint stk_camera_read_reg(struct stk_camera *dev, u16 index, int *value)\r\n{\r\nstruct usb_device *udev = dev->udev;\r\nint ret;\r\nret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\n0x00,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x00,\r\nindex,\r\n(u8 *) value,\r\nsizeof(u8),\r\n500);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int stk_start_stream(struct stk_camera *dev)\r\n{\r\nint value;\r\nint i, ret;\r\nint value_116, value_117;\r\nif (!is_present(dev))\r\nreturn -ENODEV;\r\nif (!is_memallocd(dev) || !is_initialised(dev)) {\r\nSTK_ERROR("FIXME: Buffers are not allocated\n");\r\nreturn -EFAULT;\r\n}\r\nret = usb_set_interface(dev->udev, 0, 5);\r\nif (ret < 0)\r\nSTK_ERROR("usb_set_interface failed !\n");\r\nif (stk_sensor_wakeup(dev))\r\nSTK_ERROR("error awaking the sensor\n");\r\nstk_camera_read_reg(dev, 0x0116, &value_116);\r\nstk_camera_read_reg(dev, 0x0117, &value_117);\r\nstk_camera_write_reg(dev, 0x0116, 0x0000);\r\nstk_camera_write_reg(dev, 0x0117, 0x0000);\r\nstk_camera_read_reg(dev, 0x0100, &value);\r\nstk_camera_write_reg(dev, 0x0100, value | 0x80);\r\nstk_camera_write_reg(dev, 0x0116, value_116);\r\nstk_camera_write_reg(dev, 0x0117, value_117);\r\nfor (i = 0; i < MAX_ISO_BUFS; i++) {\r\nif (dev->isobufs[i].urb) {\r\nret = usb_submit_urb(dev->isobufs[i].urb, GFP_KERNEL);\r\natomic_inc(&dev->urbs_used);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nset_streaming(dev);\r\nreturn 0;\r\n}\r\nstatic int stk_stop_stream(struct stk_camera *dev)\r\n{\r\nint value;\r\nint i;\r\nif (is_present(dev)) {\r\nstk_camera_read_reg(dev, 0x0100, &value);\r\nstk_camera_write_reg(dev, 0x0100, value & ~0x80);\r\nif (dev->isobufs != NULL) {\r\nfor (i = 0; i < MAX_ISO_BUFS; i++) {\r\nif (dev->isobufs[i].urb)\r\nusb_kill_urb(dev->isobufs[i].urb);\r\n}\r\n}\r\nunset_streaming(dev);\r\nif (usb_set_interface(dev->udev, 0, 0))\r\nSTK_ERROR("usb_set_interface failed !\n");\r\nif (stk_sensor_sleep(dev))\r\nSTK_ERROR("error suspending the sensor\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int stk_initialise(struct stk_camera *dev)\r\n{\r\nstruct regval *rv;\r\nint ret;\r\nif (!is_present(dev))\r\nreturn -ENODEV;\r\nif (is_initialised(dev))\r\nreturn 0;\r\nrv = stk1125_initvals;\r\nwhile (rv->reg != 0xffff) {\r\nret = stk_camera_write_reg(dev, rv->reg, rv->val);\r\nif (ret)\r\nreturn ret;\r\nrv++;\r\n}\r\nif (stk_sensor_init(dev) == 0) {\r\nset_initialised(dev);\r\nreturn 0;\r\n} else\r\nreturn -1;\r\n}\r\nstatic void stk_isoc_handler(struct urb *urb)\r\n{\r\nint i;\r\nint ret;\r\nint framelen;\r\nunsigned long flags;\r\nunsigned char *fill = NULL;\r\nunsigned char *iso_buf = NULL;\r\nstruct stk_camera *dev;\r\nstruct stk_sio_buffer *fb;\r\ndev = (struct stk_camera *) urb->context;\r\nif (dev == NULL) {\r\nSTK_ERROR("isoc_handler called with NULL device !\n");\r\nreturn;\r\n}\r\nif (urb->status == -ENOENT || urb->status == -ECONNRESET\r\n|| urb->status == -ESHUTDOWN) {\r\natomic_dec(&dev->urbs_used);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nif (urb->status != -EINPROGRESS && urb->status != 0) {\r\nSTK_ERROR("isoc_handler: urb->status == %d\n", urb->status);\r\ngoto resubmit;\r\n}\r\nif (list_empty(&dev->sio_avail)) {\r\n(void) (printk_ratelimit() &&\r\nSTK_ERROR("isoc_handler without available buffer!\n"));\r\ngoto resubmit;\r\n}\r\nfb = list_first_entry(&dev->sio_avail,\r\nstruct stk_sio_buffer, list);\r\nfill = fb->buffer + fb->v4lbuf.bytesused;\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nif (urb->iso_frame_desc[i].status != 0) {\r\nif (urb->iso_frame_desc[i].status != -EXDEV)\r\nSTK_ERROR("Frame %d has error %d\n", i,\r\nurb->iso_frame_desc[i].status);\r\ncontinue;\r\n}\r\nframelen = urb->iso_frame_desc[i].actual_length;\r\niso_buf = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\r\nif (framelen <= 4)\r\ncontinue;\r\nif (*iso_buf & 0x80) {\r\nframelen -= 8;\r\niso_buf += 8;\r\nif (fb->v4lbuf.bytesused != 0\r\n&& fb->v4lbuf.bytesused != dev->frame_size) {\r\n(void) (printk_ratelimit() &&\r\nSTK_ERROR("frame %d, "\r\n"bytesused=%d, skipping\n",\r\ni, fb->v4lbuf.bytesused));\r\nfb->v4lbuf.bytesused = 0;\r\nfill = fb->buffer;\r\n} else if (fb->v4lbuf.bytesused == dev->frame_size) {\r\nif (list_is_singular(&dev->sio_avail)) {\r\nfb->v4lbuf.bytesused = 0;\r\nfill = fb->buffer;\r\n} else {\r\nlist_move_tail(dev->sio_avail.next,\r\n&dev->sio_full);\r\nwake_up(&dev->wait_frame);\r\nfb = list_first_entry(&dev->sio_avail,\r\nstruct stk_sio_buffer, list);\r\nfb->v4lbuf.bytesused = 0;\r\nfill = fb->buffer;\r\n}\r\n}\r\n} else {\r\nframelen -= 4;\r\niso_buf += 4;\r\n}\r\nif (framelen + fb->v4lbuf.bytesused > dev->frame_size) {\r\n(void) (printk_ratelimit() &&\r\nSTK_ERROR("Frame buffer overflow, lost sync\n"));\r\ncontinue;\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nmemcpy(fill, iso_buf, framelen);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nfill += framelen;\r\nfb->v4lbuf.bytesused += framelen;\r\n}\r\nresubmit:\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nurb->dev = dev->udev;\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret != 0) {\r\nSTK_ERROR("Error (%d) re-submitting urb in stk_isoc_handler.\n",\r\nret);\r\n}\r\n}\r\nstatic int stk_prepare_iso(struct stk_camera *dev)\r\n{\r\nvoid *kbuf;\r\nint i, j;\r\nstruct urb *urb;\r\nstruct usb_device *udev;\r\nif (dev == NULL)\r\nreturn -ENXIO;\r\nudev = dev->udev;\r\nif (dev->isobufs)\r\nSTK_ERROR("isobufs already allocated. Bad\n");\r\nelse\r\ndev->isobufs = kcalloc(MAX_ISO_BUFS, sizeof(*dev->isobufs),\r\nGFP_KERNEL);\r\nif (dev->isobufs == NULL) {\r\nSTK_ERROR("Unable to allocate iso buffers\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < MAX_ISO_BUFS; i++) {\r\nif (dev->isobufs[i].data == NULL) {\r\nkbuf = kzalloc(ISO_BUFFER_SIZE, GFP_KERNEL);\r\nif (kbuf == NULL) {\r\nSTK_ERROR("Failed to allocate iso buffer %d\n",\r\ni);\r\ngoto isobufs_out;\r\n}\r\ndev->isobufs[i].data = kbuf;\r\n} else\r\nSTK_ERROR("isobuf data already allocated\n");\r\nif (dev->isobufs[i].urb == NULL) {\r\nurb = usb_alloc_urb(ISO_FRAMES_PER_DESC, GFP_KERNEL);\r\nif (urb == NULL) {\r\nSTK_ERROR("Failed to allocate URB %d\n", i);\r\ngoto isobufs_out;\r\n}\r\ndev->isobufs[i].urb = urb;\r\n} else {\r\nSTK_ERROR("Killing URB\n");\r\nusb_kill_urb(dev->isobufs[i].urb);\r\nurb = dev->isobufs[i].urb;\r\n}\r\nurb->interval = 1;\r\nurb->dev = udev;\r\nurb->pipe = usb_rcvisocpipe(udev, dev->isoc_ep);\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->transfer_buffer = dev->isobufs[i].data;\r\nurb->transfer_buffer_length = ISO_BUFFER_SIZE;\r\nurb->complete = stk_isoc_handler;\r\nurb->context = dev;\r\nurb->start_frame = 0;\r\nurb->number_of_packets = ISO_FRAMES_PER_DESC;\r\nfor (j = 0; j < ISO_FRAMES_PER_DESC; j++) {\r\nurb->iso_frame_desc[j].offset = j * ISO_MAX_FRAME_SIZE;\r\nurb->iso_frame_desc[j].length = ISO_MAX_FRAME_SIZE;\r\n}\r\n}\r\nset_memallocd(dev);\r\nreturn 0;\r\nisobufs_out:\r\nfor (i = 0; i < MAX_ISO_BUFS && dev->isobufs[i].data; i++)\r\nkfree(dev->isobufs[i].data);\r\nfor (i = 0; i < MAX_ISO_BUFS && dev->isobufs[i].urb; i++)\r\nusb_free_urb(dev->isobufs[i].urb);\r\nkfree(dev->isobufs);\r\ndev->isobufs = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic void stk_clean_iso(struct stk_camera *dev)\r\n{\r\nint i;\r\nif (dev == NULL || dev->isobufs == NULL)\r\nreturn;\r\nfor (i = 0; i < MAX_ISO_BUFS; i++) {\r\nstruct urb *urb;\r\nurb = dev->isobufs[i].urb;\r\nif (urb) {\r\nif (atomic_read(&dev->urbs_used) && is_present(dev))\r\nusb_kill_urb(urb);\r\nusb_free_urb(urb);\r\n}\r\nkfree(dev->isobufs[i].data);\r\n}\r\nkfree(dev->isobufs);\r\ndev->isobufs = NULL;\r\nunset_memallocd(dev);\r\n}\r\nstatic int stk_setup_siobuf(struct stk_camera *dev, int index)\r\n{\r\nstruct stk_sio_buffer *buf = dev->sio_bufs + index;\r\nINIT_LIST_HEAD(&buf->list);\r\nbuf->v4lbuf.length = PAGE_ALIGN(dev->frame_size);\r\nbuf->buffer = vmalloc_user(buf->v4lbuf.length);\r\nif (buf->buffer == NULL)\r\nreturn -ENOMEM;\r\nbuf->mapcount = 0;\r\nbuf->dev = dev;\r\nbuf->v4lbuf.index = index;\r\nbuf->v4lbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nbuf->v4lbuf.flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nbuf->v4lbuf.field = V4L2_FIELD_NONE;\r\nbuf->v4lbuf.memory = V4L2_MEMORY_MMAP;\r\nbuf->v4lbuf.m.offset = 2*index*buf->v4lbuf.length;\r\nreturn 0;\r\n}\r\nstatic int stk_free_sio_buffers(struct stk_camera *dev)\r\n{\r\nint i;\r\nint nbufs;\r\nunsigned long flags;\r\nif (dev->n_sbufs == 0 || dev->sio_bufs == NULL)\r\nreturn 0;\r\nfor (i = 0; i < dev->n_sbufs; i++) {\r\nif (dev->sio_bufs[i].mapcount > 0)\r\nreturn -EBUSY;\r\n}\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nINIT_LIST_HEAD(&dev->sio_avail);\r\nINIT_LIST_HEAD(&dev->sio_full);\r\nnbufs = dev->n_sbufs;\r\ndev->n_sbufs = 0;\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nfor (i = 0; i < nbufs; i++)\r\nvfree(dev->sio_bufs[i].buffer);\r\nkfree(dev->sio_bufs);\r\ndev->sio_bufs = NULL;\r\nreturn 0;\r\n}\r\nstatic int stk_prepare_sio_buffers(struct stk_camera *dev, unsigned n_sbufs)\r\n{\r\nint i;\r\nif (dev->sio_bufs != NULL)\r\nSTK_ERROR("sio_bufs already allocated\n");\r\nelse {\r\ndev->sio_bufs = kzalloc(n_sbufs * sizeof(struct stk_sio_buffer),\r\nGFP_KERNEL);\r\nif (dev->sio_bufs == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < n_sbufs; i++) {\r\nif (stk_setup_siobuf(dev, i))\r\nreturn (dev->n_sbufs > 1 ? 0 : -ENOMEM);\r\ndev->n_sbufs = i+1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int stk_allocate_buffers(struct stk_camera *dev, unsigned n_sbufs)\r\n{\r\nint err;\r\nerr = stk_prepare_iso(dev);\r\nif (err) {\r\nstk_clean_iso(dev);\r\nreturn err;\r\n}\r\nerr = stk_prepare_sio_buffers(dev, n_sbufs);\r\nif (err) {\r\nstk_free_sio_buffers(dev);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void stk_free_buffers(struct stk_camera *dev)\r\n{\r\nstk_clean_iso(dev);\r\nstk_free_sio_buffers(dev);\r\n}\r\nstatic int v4l_stk_open(struct file *fp)\r\n{\r\nstruct stk_camera *dev = video_drvdata(fp);\r\nint err;\r\nif (dev == NULL || !is_present(dev))\r\nreturn -ENXIO;\r\nif (mutex_lock_interruptible(&dev->lock))\r\nreturn -ERESTARTSYS;\r\nif (!dev->first_init)\r\nstk_camera_write_reg(dev, 0x0, 0x24);\r\nelse\r\ndev->first_init = 0;\r\nerr = v4l2_fh_open(fp);\r\nif (!err)\r\nusb_autopm_get_interface(dev->interface);\r\nmutex_unlock(&dev->lock);\r\nreturn err;\r\n}\r\nstatic int v4l_stk_release(struct file *fp)\r\n{\r\nstruct stk_camera *dev = video_drvdata(fp);\r\nmutex_lock(&dev->lock);\r\nif (dev->owner == fp) {\r\nstk_stop_stream(dev);\r\nstk_free_buffers(dev);\r\nstk_camera_write_reg(dev, 0x0, 0x49);\r\nunset_initialised(dev);\r\ndev->owner = NULL;\r\n}\r\nif (is_present(dev))\r\nusb_autopm_put_interface(dev->interface);\r\nmutex_unlock(&dev->lock);\r\nreturn v4l2_fh_release(fp);\r\n}\r\nstatic ssize_t stk_read(struct file *fp, char __user *buf,\r\nsize_t count, loff_t *f_pos)\r\n{\r\nint i;\r\nint ret;\r\nunsigned long flags;\r\nstruct stk_sio_buffer *sbuf;\r\nstruct stk_camera *dev = video_drvdata(fp);\r\nif (!is_present(dev))\r\nreturn -EIO;\r\nif (dev->owner && (!dev->reading || dev->owner != fp))\r\nreturn -EBUSY;\r\ndev->owner = fp;\r\nif (!is_streaming(dev)) {\r\nif (stk_initialise(dev)\r\n|| stk_allocate_buffers(dev, 3)\r\n|| stk_start_stream(dev))\r\nreturn -ENOMEM;\r\ndev->reading = 1;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nfor (i = 0; i < dev->n_sbufs; i++) {\r\nlist_add_tail(&dev->sio_bufs[i].list, &dev->sio_avail);\r\ndev->sio_bufs[i].v4lbuf.flags = V4L2_BUF_FLAG_QUEUED;\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nif (*f_pos == 0) {\r\nif (fp->f_flags & O_NONBLOCK && list_empty(&dev->sio_full))\r\nreturn -EWOULDBLOCK;\r\nret = wait_event_interruptible(dev->wait_frame,\r\n!list_empty(&dev->sio_full) || !is_present(dev));\r\nif (ret)\r\nreturn ret;\r\nif (!is_present(dev))\r\nreturn -EIO;\r\n}\r\nif (count + *f_pos > dev->frame_size)\r\ncount = dev->frame_size - *f_pos;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nif (list_empty(&dev->sio_full)) {\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nSTK_ERROR("BUG: No siobufs ready\n");\r\nreturn 0;\r\n}\r\nsbuf = list_first_entry(&dev->sio_full, struct stk_sio_buffer, list);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif (copy_to_user(buf, sbuf->buffer + *f_pos, count))\r\nreturn -EFAULT;\r\n*f_pos += count;\r\nif (*f_pos >= dev->frame_size) {\r\n*f_pos = 0;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nlist_move_tail(&sbuf->list, &dev->sio_avail);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t v4l_stk_read(struct file *fp, char __user *buf,\r\nsize_t count, loff_t *f_pos)\r\n{\r\nstruct stk_camera *dev = video_drvdata(fp);\r\nint ret;\r\nif (mutex_lock_interruptible(&dev->lock))\r\nreturn -ERESTARTSYS;\r\nret = stk_read(fp, buf, count, f_pos);\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nstatic unsigned int v4l_stk_poll(struct file *fp, poll_table *wait)\r\n{\r\nstruct stk_camera *dev = video_drvdata(fp);\r\nunsigned res = v4l2_ctrl_poll(fp, wait);\r\npoll_wait(fp, &dev->wait_frame, wait);\r\nif (!is_present(dev))\r\nreturn POLLERR;\r\nif (!list_empty(&dev->sio_full))\r\nreturn res | POLLIN | POLLRDNORM;\r\nreturn res;\r\n}\r\nstatic void stk_v4l_vm_open(struct vm_area_struct *vma)\r\n{\r\nstruct stk_sio_buffer *sbuf = vma->vm_private_data;\r\nsbuf->mapcount++;\r\n}\r\nstatic void stk_v4l_vm_close(struct vm_area_struct *vma)\r\n{\r\nstruct stk_sio_buffer *sbuf = vma->vm_private_data;\r\nsbuf->mapcount--;\r\nif (sbuf->mapcount == 0)\r\nsbuf->v4lbuf.flags &= ~V4L2_BUF_FLAG_MAPPED;\r\n}\r\nstatic int v4l_stk_mmap(struct file *fp, struct vm_area_struct *vma)\r\n{\r\nunsigned int i;\r\nint ret;\r\nunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\r\nstruct stk_camera *dev = video_drvdata(fp);\r\nstruct stk_sio_buffer *sbuf = NULL;\r\nif (!(vma->vm_flags & VM_WRITE) || !(vma->vm_flags & VM_SHARED))\r\nreturn -EINVAL;\r\nfor (i = 0; i < dev->n_sbufs; i++) {\r\nif (dev->sio_bufs[i].v4lbuf.m.offset == offset) {\r\nsbuf = dev->sio_bufs + i;\r\nbreak;\r\n}\r\n}\r\nif (sbuf == NULL)\r\nreturn -EINVAL;\r\nret = remap_vmalloc_range(vma, sbuf->buffer, 0);\r\nif (ret)\r\nreturn ret;\r\nvma->vm_flags |= VM_DONTEXPAND;\r\nvma->vm_private_data = sbuf;\r\nvma->vm_ops = &stk_v4l_vm_ops;\r\nsbuf->v4lbuf.flags |= V4L2_BUF_FLAG_MAPPED;\r\nstk_v4l_vm_open(vma);\r\nreturn 0;\r\n}\r\nstatic int stk_vidioc_querycap(struct file *filp,\r\nvoid *priv, struct v4l2_capability *cap)\r\n{\r\nstruct stk_camera *dev = video_drvdata(filp);\r\nstrcpy(cap->driver, "stk");\r\nstrcpy(cap->card, "stk");\r\nusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE\r\n| V4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int stk_vidioc_enum_input(struct file *filp,\r\nvoid *priv, struct v4l2_input *input)\r\n{\r\nif (input->index != 0)\r\nreturn -EINVAL;\r\nstrcpy(input->name, "Syntek USB Camera");\r\ninput->type = V4L2_INPUT_TYPE_CAMERA;\r\nreturn 0;\r\n}\r\nstatic int stk_vidioc_g_input(struct file *filp, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int stk_vidioc_s_input(struct file *filp, void *priv, unsigned int i)\r\n{\r\nreturn i ? -EINVAL : 0;\r\n}\r\nstatic int stk_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct stk_camera *dev =\r\ncontainer_of(ctrl->handler, struct stk_camera, hdl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nreturn stk_sensor_set_brightness(dev, ctrl->val);\r\ncase V4L2_CID_HFLIP:\r\nif (dmi_check_system(stk_upside_down_dmi_table))\r\ndev->vsettings.hflip = !ctrl->val;\r\nelse\r\ndev->vsettings.hflip = ctrl->val;\r\nreturn 0;\r\ncase V4L2_CID_VFLIP:\r\nif (dmi_check_system(stk_upside_down_dmi_table))\r\ndev->vsettings.vflip = !ctrl->val;\r\nelse\r\ndev->vsettings.vflip = ctrl->val;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stk_vidioc_enum_fmt_vid_cap(struct file *filp,\r\nvoid *priv, struct v4l2_fmtdesc *fmtd)\r\n{\r\nswitch (fmtd->index) {\r\ncase 0:\r\nfmtd->pixelformat = V4L2_PIX_FMT_RGB565;\r\nstrcpy(fmtd->description, "r5g6b5");\r\nbreak;\r\ncase 1:\r\nfmtd->pixelformat = V4L2_PIX_FMT_RGB565X;\r\nstrcpy(fmtd->description, "r5g6b5BE");\r\nbreak;\r\ncase 2:\r\nfmtd->pixelformat = V4L2_PIX_FMT_UYVY;\r\nstrcpy(fmtd->description, "yuv4:2:2");\r\nbreak;\r\ncase 3:\r\nfmtd->pixelformat = V4L2_PIX_FMT_SBGGR8;\r\nstrcpy(fmtd->description, "Raw bayer");\r\nbreak;\r\ncase 4:\r\nfmtd->pixelformat = V4L2_PIX_FMT_YUYV;\r\nstrcpy(fmtd->description, "yuv4:2:2");\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stk_vidioc_g_fmt_vid_cap(struct file *filp,\r\nvoid *priv, struct v4l2_format *f)\r\n{\r\nstruct v4l2_pix_format *pix_format = &f->fmt.pix;\r\nstruct stk_camera *dev = video_drvdata(filp);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(stk_sizes) &&\r\nstk_sizes[i].m != dev->vsettings.mode; i++)\r\n;\r\nif (i == ARRAY_SIZE(stk_sizes)) {\r\nSTK_ERROR("ERROR: mode invalid\n");\r\nreturn -EINVAL;\r\n}\r\npix_format->width = stk_sizes[i].w;\r\npix_format->height = stk_sizes[i].h;\r\npix_format->field = V4L2_FIELD_NONE;\r\npix_format->colorspace = V4L2_COLORSPACE_SRGB;\r\npix_format->pixelformat = dev->vsettings.palette;\r\nif (dev->vsettings.palette == V4L2_PIX_FMT_SBGGR8)\r\npix_format->bytesperline = pix_format->width;\r\nelse\r\npix_format->bytesperline = 2 * pix_format->width;\r\npix_format->sizeimage = pix_format->bytesperline\r\n* pix_format->height;\r\nreturn 0;\r\n}\r\nstatic int stk_try_fmt_vid_cap(struct file *filp,\r\nstruct v4l2_format *fmtd, int *idx)\r\n{\r\nint i;\r\nswitch (fmtd->fmt.pix.pixelformat) {\r\ncase V4L2_PIX_FMT_RGB565:\r\ncase V4L2_PIX_FMT_RGB565X:\r\ncase V4L2_PIX_FMT_UYVY:\r\ncase V4L2_PIX_FMT_YUYV:\r\ncase V4L2_PIX_FMT_SBGGR8:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfor (i = 1; i < ARRAY_SIZE(stk_sizes); i++) {\r\nif (fmtd->fmt.pix.width > stk_sizes[i].w)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(stk_sizes)\r\n|| (abs(fmtd->fmt.pix.width - stk_sizes[i-1].w)\r\n< abs(fmtd->fmt.pix.width - stk_sizes[i].w))) {\r\nfmtd->fmt.pix.height = stk_sizes[i-1].h;\r\nfmtd->fmt.pix.width = stk_sizes[i-1].w;\r\nif (idx)\r\n*idx = i - 1;\r\n} else {\r\nfmtd->fmt.pix.height = stk_sizes[i].h;\r\nfmtd->fmt.pix.width = stk_sizes[i].w;\r\nif (idx)\r\n*idx = i;\r\n}\r\nfmtd->fmt.pix.field = V4L2_FIELD_NONE;\r\nfmtd->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\r\nif (fmtd->fmt.pix.pixelformat == V4L2_PIX_FMT_SBGGR8)\r\nfmtd->fmt.pix.bytesperline = fmtd->fmt.pix.width;\r\nelse\r\nfmtd->fmt.pix.bytesperline = 2 * fmtd->fmt.pix.width;\r\nfmtd->fmt.pix.sizeimage = fmtd->fmt.pix.bytesperline\r\n* fmtd->fmt.pix.height;\r\nreturn 0;\r\n}\r\nstatic int stk_vidioc_try_fmt_vid_cap(struct file *filp,\r\nvoid *priv, struct v4l2_format *fmtd)\r\n{\r\nreturn stk_try_fmt_vid_cap(filp, fmtd, NULL);\r\n}\r\nstatic int stk_setup_format(struct stk_camera *dev)\r\n{\r\nint i = 0;\r\nint depth;\r\nif (dev->vsettings.palette == V4L2_PIX_FMT_SBGGR8)\r\ndepth = 1;\r\nelse\r\ndepth = 2;\r\nwhile (i < ARRAY_SIZE(stk_sizes) &&\r\nstk_sizes[i].m != dev->vsettings.mode)\r\ni++;\r\nif (i == ARRAY_SIZE(stk_sizes)) {\r\nSTK_ERROR("Something is broken in %s\n", __func__);\r\nreturn -EFAULT;\r\n}\r\nstk_camera_write_reg(dev, 0x001b, 0x0e);\r\nif (dev->vsettings.mode == MODE_SXGA)\r\nstk_camera_write_reg(dev, 0x001c, 0x0e);\r\nelse\r\nstk_camera_write_reg(dev, 0x001c, 0x46);\r\nstk_camera_write_reg(dev, 0x0115,\r\n((stk_sizes[i].w * depth) >> 8) & 0xff);\r\nstk_camera_write_reg(dev, 0x0114,\r\n(stk_sizes[i].w * depth) & 0xff);\r\nstk_camera_write_reg(dev, 0x0117,\r\n(stk_sizes[i].h >> 8) & 0xff);\r\nstk_camera_write_reg(dev, 0x0116,\r\nstk_sizes[i].h & 0xff);\r\nreturn stk_sensor_configure(dev);\r\n}\r\nstatic int stk_vidioc_s_fmt_vid_cap(struct file *filp,\r\nvoid *priv, struct v4l2_format *fmtd)\r\n{\r\nint ret;\r\nint idx;\r\nstruct stk_camera *dev = video_drvdata(filp);\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nif (!is_present(dev))\r\nreturn -ENODEV;\r\nif (is_streaming(dev))\r\nreturn -EBUSY;\r\nif (dev->owner)\r\nreturn -EBUSY;\r\nret = stk_try_fmt_vid_cap(filp, fmtd, &idx);\r\nif (ret)\r\nreturn ret;\r\ndev->vsettings.palette = fmtd->fmt.pix.pixelformat;\r\nstk_free_buffers(dev);\r\ndev->frame_size = fmtd->fmt.pix.sizeimage;\r\ndev->vsettings.mode = stk_sizes[idx].m;\r\nstk_initialise(dev);\r\nreturn stk_setup_format(dev);\r\n}\r\nstatic int stk_vidioc_reqbufs(struct file *filp,\r\nvoid *priv, struct v4l2_requestbuffers *rb)\r\n{\r\nstruct stk_camera *dev = video_drvdata(filp);\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nif (rb->memory != V4L2_MEMORY_MMAP)\r\nreturn -EINVAL;\r\nif (is_streaming(dev)\r\n|| (dev->owner && dev->owner != filp))\r\nreturn -EBUSY;\r\nstk_free_buffers(dev);\r\nif (rb->count == 0) {\r\nstk_camera_write_reg(dev, 0x0, 0x49);\r\nunset_initialised(dev);\r\ndev->owner = NULL;\r\nreturn 0;\r\n}\r\ndev->owner = filp;\r\nif (rb->count < 3)\r\nrb->count = 3;\r\nelse if (rb->count > 5)\r\nrb->count = 5;\r\nstk_allocate_buffers(dev, rb->count);\r\nrb->count = dev->n_sbufs;\r\nreturn 0;\r\n}\r\nstatic int stk_vidioc_querybuf(struct file *filp,\r\nvoid *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct stk_camera *dev = video_drvdata(filp);\r\nstruct stk_sio_buffer *sbuf;\r\nif (buf->index >= dev->n_sbufs)\r\nreturn -EINVAL;\r\nsbuf = dev->sio_bufs + buf->index;\r\n*buf = sbuf->v4lbuf;\r\nreturn 0;\r\n}\r\nstatic int stk_vidioc_qbuf(struct file *filp,\r\nvoid *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct stk_camera *dev = video_drvdata(filp);\r\nstruct stk_sio_buffer *sbuf;\r\nunsigned long flags;\r\nif (buf->memory != V4L2_MEMORY_MMAP)\r\nreturn -EINVAL;\r\nif (buf->index >= dev->n_sbufs)\r\nreturn -EINVAL;\r\nsbuf = dev->sio_bufs + buf->index;\r\nif (sbuf->v4lbuf.flags & V4L2_BUF_FLAG_QUEUED)\r\nreturn 0;\r\nsbuf->v4lbuf.flags |= V4L2_BUF_FLAG_QUEUED;\r\nsbuf->v4lbuf.flags &= ~V4L2_BUF_FLAG_DONE;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nlist_add_tail(&sbuf->list, &dev->sio_avail);\r\n*buf = sbuf->v4lbuf;\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int stk_vidioc_dqbuf(struct file *filp,\r\nvoid *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct stk_camera *dev = video_drvdata(filp);\r\nstruct stk_sio_buffer *sbuf;\r\nunsigned long flags;\r\nint ret;\r\nif (!is_streaming(dev))\r\nreturn -EINVAL;\r\nif (filp->f_flags & O_NONBLOCK && list_empty(&dev->sio_full))\r\nreturn -EWOULDBLOCK;\r\nret = wait_event_interruptible(dev->wait_frame,\r\n!list_empty(&dev->sio_full) || !is_present(dev));\r\nif (ret)\r\nreturn ret;\r\nif (!is_present(dev))\r\nreturn -EIO;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nsbuf = list_first_entry(&dev->sio_full, struct stk_sio_buffer, list);\r\nlist_del_init(&sbuf->list);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nsbuf->v4lbuf.flags &= ~V4L2_BUF_FLAG_QUEUED;\r\nsbuf->v4lbuf.flags |= V4L2_BUF_FLAG_DONE;\r\nsbuf->v4lbuf.sequence = ++dev->sequence;\r\nv4l2_get_timestamp(&sbuf->v4lbuf.timestamp);\r\n*buf = sbuf->v4lbuf;\r\nreturn 0;\r\n}\r\nstatic int stk_vidioc_streamon(struct file *filp,\r\nvoid *priv, enum v4l2_buf_type type)\r\n{\r\nstruct stk_camera *dev = video_drvdata(filp);\r\nif (is_streaming(dev))\r\nreturn 0;\r\nif (dev->sio_bufs == NULL)\r\nreturn -EINVAL;\r\ndev->sequence = 0;\r\nreturn stk_start_stream(dev);\r\n}\r\nstatic int stk_vidioc_streamoff(struct file *filp,\r\nvoid *priv, enum v4l2_buf_type type)\r\n{\r\nstruct stk_camera *dev = video_drvdata(filp);\r\nunsigned long flags;\r\nint i;\r\nstk_stop_stream(dev);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nINIT_LIST_HEAD(&dev->sio_avail);\r\nINIT_LIST_HEAD(&dev->sio_full);\r\nfor (i = 0; i < dev->n_sbufs; i++) {\r\nINIT_LIST_HEAD(&dev->sio_bufs[i].list);\r\ndev->sio_bufs[i].v4lbuf.flags = 0;\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int stk_vidioc_g_parm(struct file *filp,\r\nvoid *priv, struct v4l2_streamparm *sp)\r\n{\r\nsp->parm.capture.timeperframe.numerator = 1;\r\nsp->parm.capture.timeperframe.denominator = 30;\r\nsp->parm.capture.readbuffers = 2;\r\nreturn 0;\r\n}\r\nstatic int stk_vidioc_enum_framesizes(struct file *filp,\r\nvoid *priv, struct v4l2_frmsizeenum *frms)\r\n{\r\nif (frms->index >= ARRAY_SIZE(stk_sizes))\r\nreturn -EINVAL;\r\nswitch (frms->pixel_format) {\r\ncase V4L2_PIX_FMT_RGB565:\r\ncase V4L2_PIX_FMT_RGB565X:\r\ncase V4L2_PIX_FMT_UYVY:\r\ncase V4L2_PIX_FMT_YUYV:\r\ncase V4L2_PIX_FMT_SBGGR8:\r\nfrms->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nfrms->discrete.width = stk_sizes[frms->index].w;\r\nfrms->discrete.height = stk_sizes[frms->index].h;\r\nreturn 0;\r\ndefault: return -EINVAL;\r\n}\r\n}\r\nstatic void stk_v4l_dev_release(struct video_device *vd)\r\n{\r\nstruct stk_camera *dev = vdev_to_camera(vd);\r\nif (dev->sio_bufs != NULL || dev->isobufs != NULL)\r\nSTK_ERROR("We are leaking memory\n");\r\nusb_put_intf(dev->interface);\r\nkfree(dev);\r\n}\r\nstatic int stk_register_video_device(struct stk_camera *dev)\r\n{\r\nint err;\r\ndev->vdev = stk_v4l_data;\r\ndev->vdev.lock = &dev->lock;\r\ndev->vdev.v4l2_dev = &dev->v4l2_dev;\r\nvideo_set_drvdata(&dev->vdev, dev);\r\nerr = video_register_device(&dev->vdev, VFL_TYPE_GRABBER, -1);\r\nif (err)\r\nSTK_ERROR("v4l registration failed\n");\r\nelse\r\nSTK_INFO("Syntek USB2.0 Camera is now controlling device %s\n",\r\nvideo_device_node_name(&dev->vdev));\r\nreturn err;\r\n}\r\nstatic int stk_camera_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct v4l2_ctrl_handler *hdl;\r\nint err = 0;\r\nint i;\r\nstruct stk_camera *dev = NULL;\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\ndev = kzalloc(sizeof(struct stk_camera), GFP_KERNEL);\r\nif (dev == NULL) {\r\nSTK_ERROR("Out of memory !\n");\r\nreturn -ENOMEM;\r\n}\r\nerr = v4l2_device_register(&interface->dev, &dev->v4l2_dev);\r\nif (err < 0) {\r\ndev_err(&udev->dev, "couldn't register v4l2_device\n");\r\nkfree(dev);\r\nreturn err;\r\n}\r\nhdl = &dev->hdl;\r\nv4l2_ctrl_handler_init(hdl, 3);\r\nv4l2_ctrl_new_std(hdl, &stk_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 0xff, 0x1, 0x60);\r\nv4l2_ctrl_new_std(hdl, &stk_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 1);\r\nv4l2_ctrl_new_std(hdl, &stk_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 1);\r\nif (hdl->error) {\r\nerr = hdl->error;\r\ndev_err(&udev->dev, "couldn't register control\n");\r\ngoto error;\r\n}\r\ndev->v4l2_dev.ctrl_handler = hdl;\r\nspin_lock_init(&dev->spinlock);\r\nmutex_init(&dev->lock);\r\ninit_waitqueue_head(&dev->wait_frame);\r\ndev->first_init = 1;\r\ndev->udev = udev;\r\ndev->interface = interface;\r\nusb_get_intf(interface);\r\nif (hflip != -1)\r\ndev->vsettings.hflip = hflip;\r\nelse if (dmi_check_system(stk_upside_down_dmi_table))\r\ndev->vsettings.hflip = 1;\r\nelse\r\ndev->vsettings.hflip = 0;\r\nif (vflip != -1)\r\ndev->vsettings.vflip = vflip;\r\nelse if (dmi_check_system(stk_upside_down_dmi_table))\r\ndev->vsettings.vflip = 1;\r\nelse\r\ndev->vsettings.vflip = 0;\r\ndev->n_sbufs = 0;\r\nset_present(dev);\r\niface_desc = interface->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (!dev->isoc_ep\r\n&& usb_endpoint_is_isoc_in(endpoint)) {\r\ndev->isoc_ep = usb_endpoint_num(endpoint);\r\nbreak;\r\n}\r\n}\r\nif (!dev->isoc_ep) {\r\nSTK_ERROR("Could not find isoc-in endpoint");\r\nerr = -ENODEV;\r\ngoto error;\r\n}\r\ndev->vsettings.palette = V4L2_PIX_FMT_RGB565;\r\ndev->vsettings.mode = MODE_VGA;\r\ndev->frame_size = 640 * 480 * 2;\r\nINIT_LIST_HEAD(&dev->sio_avail);\r\nINIT_LIST_HEAD(&dev->sio_full);\r\nusb_set_intfdata(interface, dev);\r\nerr = stk_register_video_device(dev);\r\nif (err)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nv4l2_ctrl_handler_free(hdl);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nkfree(dev);\r\nreturn err;\r\n}\r\nstatic void stk_camera_disconnect(struct usb_interface *interface)\r\n{\r\nstruct stk_camera *dev = usb_get_intfdata(interface);\r\nusb_set_intfdata(interface, NULL);\r\nunset_present(dev);\r\nwake_up_interruptible(&dev->wait_frame);\r\nSTK_INFO("Syntek USB2.0 Camera release resources device %s\n",\r\nvideo_device_node_name(&dev->vdev));\r\nvideo_unregister_device(&dev->vdev);\r\nv4l2_ctrl_handler_free(&dev->hdl);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\n}\r\nstatic int stk_camera_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct stk_camera *dev = usb_get_intfdata(intf);\r\nif (is_streaming(dev)) {\r\nstk_stop_stream(dev);\r\nset_streaming(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int stk_camera_resume(struct usb_interface *intf)\r\n{\r\nstruct stk_camera *dev = usb_get_intfdata(intf);\r\nif (!is_initialised(dev))\r\nreturn 0;\r\nunset_initialised(dev);\r\nstk_initialise(dev);\r\nstk_camera_write_reg(dev, 0x0, 0x49);\r\nstk_setup_format(dev);\r\nif (is_streaming(dev))\r\nstk_start_stream(dev);\r\nreturn 0;\r\n}
