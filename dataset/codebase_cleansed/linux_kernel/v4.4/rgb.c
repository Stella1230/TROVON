static inline struct tegra_rgb *to_rgb(struct tegra_output *output)\r\n{\r\nreturn container_of(output, struct tegra_rgb, output);\r\n}\r\nstatic void tegra_dc_write_regs(struct tegra_dc *dc,\r\nconst struct reg_entry *table,\r\nunsigned int num)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num; i++)\r\ntegra_dc_writel(dc, table[i].value, table[i].offset);\r\n}\r\nstatic enum drm_mode_status\r\ntegra_rgb_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nreturn MODE_OK;\r\n}\r\nstatic void tegra_rgb_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct tegra_output *output = encoder_to_output(encoder);\r\nstruct tegra_rgb *rgb = to_rgb(output);\r\nif (output->panel)\r\ndrm_panel_disable(output->panel);\r\ntegra_dc_write_regs(rgb->dc, rgb_disable, ARRAY_SIZE(rgb_disable));\r\ntegra_dc_commit(rgb->dc);\r\nif (output->panel)\r\ndrm_panel_unprepare(output->panel);\r\n}\r\nstatic void tegra_rgb_encoder_enable(struct drm_encoder *encoder)\r\n{\r\nstruct tegra_output *output = encoder_to_output(encoder);\r\nstruct tegra_rgb *rgb = to_rgb(output);\r\nu32 value;\r\nif (output->panel)\r\ndrm_panel_prepare(output->panel);\r\ntegra_dc_write_regs(rgb->dc, rgb_enable, ARRAY_SIZE(rgb_enable));\r\nvalue = DE_SELECT_ACTIVE | DE_CONTROL_NORMAL;\r\ntegra_dc_writel(rgb->dc, value, DC_DISP_DATA_ENABLE_OPTIONS);\r\nvalue = tegra_dc_readl(rgb->dc, DC_COM_PIN_OUTPUT_POLARITY(1));\r\nvalue &= ~LVS_OUTPUT_POLARITY_LOW;\r\nvalue &= ~LHS_OUTPUT_POLARITY_LOW;\r\ntegra_dc_writel(rgb->dc, value, DC_COM_PIN_OUTPUT_POLARITY(1));\r\nvalue = DISP_DATA_FORMAT_DF1P1C | DISP_ALIGNMENT_MSB |\r\nDISP_ORDER_RED_BLUE;\r\ntegra_dc_writel(rgb->dc, value, DC_DISP_DISP_INTERFACE_CONTROL);\r\nvalue = SC0_H_QUALIFIER_NONE | SC1_H_QUALIFIER_NONE;\r\ntegra_dc_writel(rgb->dc, value, DC_DISP_SHIFT_CLOCK_OPTIONS);\r\ntegra_dc_commit(rgb->dc);\r\nif (output->panel)\r\ndrm_panel_enable(output->panel);\r\n}\r\nstatic int\r\ntegra_rgb_encoder_atomic_check(struct drm_encoder *encoder,\r\nstruct drm_crtc_state *crtc_state,\r\nstruct drm_connector_state *conn_state)\r\n{\r\nstruct tegra_output *output = encoder_to_output(encoder);\r\nstruct tegra_dc *dc = to_tegra_dc(conn_state->crtc);\r\nunsigned long pclk = crtc_state->mode.clock * 1000;\r\nstruct tegra_rgb *rgb = to_rgb(output);\r\nunsigned int div;\r\nint err;\r\ndiv = ((clk_get_rate(rgb->clk) * 2) / pclk) - 2;\r\npclk = 0;\r\nerr = tegra_dc_state_setup_clock(dc, crtc_state, rgb->clk_parent,\r\npclk, div);\r\nif (err < 0) {\r\ndev_err(output->dev, "failed to setup CRTC state: %d\n", err);\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nint tegra_dc_rgb_probe(struct tegra_dc *dc)\r\n{\r\nstruct device_node *np;\r\nstruct tegra_rgb *rgb;\r\nint err;\r\nnp = of_get_child_by_name(dc->dev->of_node, "rgb");\r\nif (!np || !of_device_is_available(np))\r\nreturn -ENODEV;\r\nrgb = devm_kzalloc(dc->dev, sizeof(*rgb), GFP_KERNEL);\r\nif (!rgb)\r\nreturn -ENOMEM;\r\nrgb->output.dev = dc->dev;\r\nrgb->output.of_node = np;\r\nrgb->dc = dc;\r\nerr = tegra_output_probe(&rgb->output);\r\nif (err < 0)\r\nreturn err;\r\nrgb->clk = devm_clk_get(dc->dev, NULL);\r\nif (IS_ERR(rgb->clk)) {\r\ndev_err(dc->dev, "failed to get clock\n");\r\nreturn PTR_ERR(rgb->clk);\r\n}\r\nrgb->clk_parent = devm_clk_get(dc->dev, "parent");\r\nif (IS_ERR(rgb->clk_parent)) {\r\ndev_err(dc->dev, "failed to get parent clock\n");\r\nreturn PTR_ERR(rgb->clk_parent);\r\n}\r\nerr = clk_set_parent(rgb->clk, rgb->clk_parent);\r\nif (err < 0) {\r\ndev_err(dc->dev, "failed to set parent clock: %d\n", err);\r\nreturn err;\r\n}\r\ndc->rgb = &rgb->output;\r\nreturn 0;\r\n}\r\nint tegra_dc_rgb_remove(struct tegra_dc *dc)\r\n{\r\nif (!dc->rgb)\r\nreturn 0;\r\ntegra_output_remove(dc->rgb);\r\ndc->rgb = NULL;\r\nreturn 0;\r\n}\r\nint tegra_dc_rgb_init(struct drm_device *drm, struct tegra_dc *dc)\r\n{\r\nstruct tegra_output *output = dc->rgb;\r\nint err;\r\nif (!dc->rgb)\r\nreturn -ENODEV;\r\ndrm_connector_init(drm, &output->connector, &tegra_rgb_connector_funcs,\r\nDRM_MODE_CONNECTOR_LVDS);\r\ndrm_connector_helper_add(&output->connector,\r\n&tegra_rgb_connector_helper_funcs);\r\noutput->connector.dpms = DRM_MODE_DPMS_OFF;\r\ndrm_encoder_init(drm, &output->encoder, &tegra_rgb_encoder_funcs,\r\nDRM_MODE_ENCODER_LVDS);\r\ndrm_encoder_helper_add(&output->encoder,\r\n&tegra_rgb_encoder_helper_funcs);\r\ndrm_mode_connector_attach_encoder(&output->connector,\r\n&output->encoder);\r\ndrm_connector_register(&output->connector);\r\nerr = tegra_output_init(drm, output);\r\nif (err < 0) {\r\ndev_err(output->dev, "failed to initialize output: %d\n", err);\r\nreturn err;\r\n}\r\noutput->encoder.possible_crtcs = drm_crtc_mask(&dc->base);\r\nreturn 0;\r\n}\r\nint tegra_dc_rgb_exit(struct tegra_dc *dc)\r\n{\r\nif (dc->rgb)\r\ntegra_output_exit(dc->rgb);\r\nreturn 0;\r\n}
