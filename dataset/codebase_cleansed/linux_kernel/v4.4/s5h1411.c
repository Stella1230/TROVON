static int s5h1411_writereg(struct s5h1411_state *state,\r\nu8 addr, u8 reg, u16 data)\r\n{\r\nint ret;\r\nu8 buf[] = { reg, data >> 8, data & 0xff };\r\nstruct i2c_msg msg = { .addr = addr, .flags = 0, .buf = buf, .len = 3 };\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1)\r\nprintk(KERN_ERR "%s: writereg error 0x%02x 0x%02x 0x%04x, "\r\n"ret == %i)\n", __func__, addr, reg, data, ret);\r\nreturn (ret != 1) ? -1 : 0;\r\n}\r\nstatic u16 s5h1411_readreg(struct s5h1411_state *state, u8 addr, u8 reg)\r\n{\r\nint ret;\r\nu8 b0[] = { reg };\r\nu8 b1[] = { 0, 0 };\r\nstruct i2c_msg msg[] = {\r\n{ .addr = addr, .flags = 0, .buf = b0, .len = 1 },\r\n{ .addr = addr, .flags = I2C_M_RD, .buf = b1, .len = 2 } };\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2)\r\nprintk(KERN_ERR "%s: readreg error (ret == %i)\n",\r\n__func__, ret);\r\nreturn (b1[0] << 8) | b1[1];\r\n}\r\nstatic int s5h1411_softreset(struct dvb_frontend *fe)\r\n{\r\nstruct s5h1411_state *state = fe->demodulator_priv;\r\ndprintk("%s()\n", __func__);\r\ns5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf7, 0);\r\ns5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf7, 1);\r\nreturn 0;\r\n}\r\nstatic int s5h1411_set_if_freq(struct dvb_frontend *fe, int KHz)\r\n{\r\nstruct s5h1411_state *state = fe->demodulator_priv;\r\ndprintk("%s(%d KHz)\n", __func__, KHz);\r\nswitch (KHz) {\r\ncase 3250:\r\ns5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x38, 0x10d5);\r\ns5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x39, 0x5342);\r\ns5h1411_writereg(state, S5H1411_I2C_QAM_ADDR, 0x2c, 0x10d9);\r\nbreak;\r\ncase 3500:\r\ns5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x38, 0x1225);\r\ns5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x39, 0x1e96);\r\ns5h1411_writereg(state, S5H1411_I2C_QAM_ADDR, 0x2c, 0x1225);\r\nbreak;\r\ncase 4000:\r\ns5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x38, 0x14bc);\r\ns5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x39, 0xb53e);\r\ns5h1411_writereg(state, S5H1411_I2C_QAM_ADDR, 0x2c, 0x14bd);\r\nbreak;\r\ndefault:\r\ndprintk("%s(%d KHz) Invalid, defaulting to 5380\n",\r\n__func__, KHz);\r\ncase 5380:\r\ncase 44000:\r\ns5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x38, 0x1be4);\r\ns5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x39, 0x3655);\r\ns5h1411_writereg(state, S5H1411_I2C_QAM_ADDR, 0x2c, 0x1be4);\r\nbreak;\r\n}\r\nstate->if_freq = KHz;\r\nreturn 0;\r\n}\r\nstatic int s5h1411_set_mpeg_timing(struct dvb_frontend *fe, int mode)\r\n{\r\nstruct s5h1411_state *state = fe->demodulator_priv;\r\nu16 val;\r\ndprintk("%s(%d)\n", __func__, mode);\r\nval = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0xbe) & 0xcfff;\r\nswitch (mode) {\r\ncase S5H1411_MPEGTIMING_CONTINOUS_INVERTING_CLOCK:\r\nval |= 0x0000;\r\nbreak;\r\ncase S5H1411_MPEGTIMING_CONTINOUS_NONINVERTING_CLOCK:\r\ndprintk("%s(%d) Mode1 or Defaulting\n", __func__, mode);\r\nval |= 0x1000;\r\nbreak;\r\ncase S5H1411_MPEGTIMING_NONCONTINOUS_INVERTING_CLOCK:\r\nval |= 0x2000;\r\nbreak;\r\ncase S5H1411_MPEGTIMING_NONCONTINOUS_NONINVERTING_CLOCK:\r\nval |= 0x3000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn s5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xbe, val);\r\n}\r\nstatic int s5h1411_set_spectralinversion(struct dvb_frontend *fe, int inversion)\r\n{\r\nstruct s5h1411_state *state = fe->demodulator_priv;\r\nu16 val;\r\ndprintk("%s(%d)\n", __func__, inversion);\r\nval = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0x24) & ~0x1000;\r\nif (inversion == 1)\r\nval |= 0x1000;\r\nstate->inversion = inversion;\r\nreturn s5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x24, val);\r\n}\r\nstatic int s5h1411_set_serialmode(struct dvb_frontend *fe, int serial)\r\n{\r\nstruct s5h1411_state *state = fe->demodulator_priv;\r\nu16 val;\r\ndprintk("%s(%d)\n", __func__, serial);\r\nval = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0xbd) & ~0x100;\r\nif (serial == 1)\r\nval |= 0x100;\r\nreturn s5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xbd, val);\r\n}\r\nstatic int s5h1411_enable_modulation(struct dvb_frontend *fe,\r\nenum fe_modulation m)\r\n{\r\nstruct s5h1411_state *state = fe->demodulator_priv;\r\ndprintk("%s(0x%08x)\n", __func__, m);\r\nif ((state->first_tune == 0) && (m == state->current_modulation)) {\r\ndprintk("%s() Already at desired modulation. Skipping...\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nswitch (m) {\r\ncase VSB_8:\r\ndprintk("%s() VSB_8\n", __func__);\r\ns5h1411_set_if_freq(fe, state->config->vsb_if);\r\ns5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x00, 0x71);\r\ns5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf6, 0x00);\r\ns5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xcd, 0xf1);\r\nbreak;\r\ncase QAM_64:\r\ncase QAM_256:\r\ncase QAM_AUTO:\r\ndprintk("%s() QAM_AUTO (64/256)\n", __func__);\r\ns5h1411_set_if_freq(fe, state->config->qam_if);\r\ns5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x00, 0x0171);\r\ns5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf6, 0x0001);\r\ns5h1411_writereg(state, S5H1411_I2C_QAM_ADDR, 0x16, 0x1101);\r\ns5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xcd, 0x00f0);\r\nbreak;\r\ndefault:\r\ndprintk("%s() Invalid modulation\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nstate->current_modulation = m;\r\nstate->first_tune = 0;\r\ns5h1411_softreset(fe);\r\nreturn 0;\r\n}\r\nstatic int s5h1411_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct s5h1411_state *state = fe->demodulator_priv;\r\ndprintk("%s(%d)\n", __func__, enable);\r\nif (enable)\r\nreturn s5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf5, 1);\r\nelse\r\nreturn s5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf5, 0);\r\n}\r\nstatic int s5h1411_set_gpio(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct s5h1411_state *state = fe->demodulator_priv;\r\nu16 val;\r\ndprintk("%s(%d)\n", __func__, enable);\r\nval = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0xe0) & ~0x02;\r\nif (enable)\r\nreturn s5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xe0,\r\nval | 0x02);\r\nelse\r\nreturn s5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xe0, val);\r\n}\r\nstatic int s5h1411_set_powerstate(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct s5h1411_state *state = fe->demodulator_priv;\r\ndprintk("%s(%d)\n", __func__, enable);\r\nif (enable)\r\ns5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf4, 1);\r\nelse {\r\ns5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf4, 0);\r\ns5h1411_softreset(fe);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5h1411_sleep(struct dvb_frontend *fe)\r\n{\r\nreturn s5h1411_set_powerstate(fe, 1);\r\n}\r\nstatic int s5h1411_register_reset(struct dvb_frontend *fe)\r\n{\r\nstruct s5h1411_state *state = fe->demodulator_priv;\r\ndprintk("%s()\n", __func__);\r\nreturn s5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf3, 0);\r\n}\r\nstatic int s5h1411_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct s5h1411_state *state = fe->demodulator_priv;\r\ndprintk("%s(frequency=%d)\n", __func__, p->frequency);\r\ns5h1411_softreset(fe);\r\nstate->current_frequency = p->frequency;\r\ns5h1411_enable_modulation(fe, p->modulation);\r\nif (fe->ops.tuner_ops.set_params) {\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\ns5h1411_softreset(fe);\r\nreturn 0;\r\n}\r\nstatic int s5h1411_init(struct dvb_frontend *fe)\r\n{\r\nstruct s5h1411_state *state = fe->demodulator_priv;\r\nint i;\r\ndprintk("%s()\n", __func__);\r\ns5h1411_set_powerstate(fe, 0);\r\ns5h1411_register_reset(fe);\r\nfor (i = 0; i < ARRAY_SIZE(init_tab); i++)\r\ns5h1411_writereg(state, init_tab[i].addr,\r\ninit_tab[i].reg,\r\ninit_tab[i].data);\r\nstate->current_modulation = VSB_8;\r\nstate->first_tune = 1;\r\nif (state->config->output_mode == S5H1411_SERIAL_OUTPUT)\r\ns5h1411_set_serialmode(fe, 1);\r\nelse\r\ns5h1411_set_serialmode(fe, 0);\r\ns5h1411_set_spectralinversion(fe, state->config->inversion);\r\ns5h1411_set_if_freq(fe, state->config->vsb_if);\r\ns5h1411_set_gpio(fe, state->config->gpio);\r\ns5h1411_set_mpeg_timing(fe, state->config->mpeg_timing);\r\ns5h1411_softreset(fe);\r\ns5h1411_i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\n}\r\nstatic int s5h1411_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct s5h1411_state *state = fe->demodulator_priv;\r\nu16 reg;\r\nu32 tuner_status = 0;\r\n*status = 0;\r\nswitch (state->current_modulation) {\r\ncase QAM_64:\r\ncase QAM_256:\r\nreg = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0xf0);\r\nif (reg & 0x10)\r\n*status |= FE_HAS_SYNC | FE_HAS_LOCK;\r\nif (reg & 0x100)\r\n*status |= FE_HAS_VITERBI | FE_HAS_CARRIER | FE_HAS_SIGNAL;\r\nbreak;\r\ncase VSB_8:\r\nreg = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0xf2);\r\nif (reg & 0x1000)\r\n*status |= FE_HAS_SYNC | FE_HAS_LOCK;\r\nif (reg & 0x2000)\r\n*status |= FE_HAS_VITERBI | FE_HAS_CARRIER | FE_HAS_SIGNAL;\r\nreg = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0x53);\r\nif (reg & 0x1)\r\n*status |= FE_HAS_SIGNAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (state->config->status_mode) {\r\ncase S5H1411_DEMODLOCKING:\r\nif (*status & FE_HAS_VITERBI)\r\n*status |= FE_HAS_CARRIER | FE_HAS_SIGNAL;\r\nbreak;\r\ncase S5H1411_TUNERLOCKING:\r\nif (fe->ops.tuner_ops.get_status) {\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nfe->ops.tuner_ops.get_status(fe, &tuner_status);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nif (tuner_status)\r\n*status |= FE_HAS_CARRIER | FE_HAS_SIGNAL;\r\nbreak;\r\n}\r\ndprintk("%s() status 0x%08x\n", __func__, *status);\r\nreturn 0;\r\n}\r\nstatic int s5h1411_qam256_lookup_snr(struct dvb_frontend *fe, u16 *snr, u16 v)\r\n{\r\nint i, ret = -EINVAL;\r\ndprintk("%s()\n", __func__);\r\nfor (i = 0; i < ARRAY_SIZE(qam256_snr_tab); i++) {\r\nif (v < qam256_snr_tab[i].val) {\r\n*snr = qam256_snr_tab[i].data;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int s5h1411_qam64_lookup_snr(struct dvb_frontend *fe, u16 *snr, u16 v)\r\n{\r\nint i, ret = -EINVAL;\r\ndprintk("%s()\n", __func__);\r\nfor (i = 0; i < ARRAY_SIZE(qam64_snr_tab); i++) {\r\nif (v < qam64_snr_tab[i].val) {\r\n*snr = qam64_snr_tab[i].data;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int s5h1411_vsb_lookup_snr(struct dvb_frontend *fe, u16 *snr, u16 v)\r\n{\r\nint i, ret = -EINVAL;\r\ndprintk("%s()\n", __func__);\r\nfor (i = 0; i < ARRAY_SIZE(vsb_snr_tab); i++) {\r\nif (v > vsb_snr_tab[i].val) {\r\n*snr = vsb_snr_tab[i].data;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\ndprintk("%s() snr=%d\n", __func__, *snr);\r\nreturn ret;\r\n}\r\nstatic int s5h1411_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct s5h1411_state *state = fe->demodulator_priv;\r\nu16 reg;\r\ndprintk("%s()\n", __func__);\r\nswitch (state->current_modulation) {\r\ncase QAM_64:\r\nreg = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0xf1);\r\nreturn s5h1411_qam64_lookup_snr(fe, snr, reg);\r\ncase QAM_256:\r\nreg = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0xf1);\r\nreturn s5h1411_qam256_lookup_snr(fe, snr, reg);\r\ncase VSB_8:\r\nreg = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR,\r\n0xf2) & 0x3ff;\r\nreturn s5h1411_vsb_lookup_snr(fe, snr, reg);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int s5h1411_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *signal_strength)\r\n{\r\nu16 snr;\r\nu32 tmp;\r\nint ret = s5h1411_read_snr(fe, &snr);\r\n*signal_strength = 0;\r\nif (0 == ret) {\r\ntmp = (snr * ((1 << 24) / 10));\r\nif (tmp >= 8960 * 0x10000)\r\n*signal_strength = 0xffff;\r\nelse\r\n*signal_strength = tmp / 8960;\r\n}\r\nreturn ret;\r\n}\r\nstatic int s5h1411_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct s5h1411_state *state = fe->demodulator_priv;\r\n*ucblocks = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0xc9);\r\nreturn 0;\r\n}\r\nstatic int s5h1411_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nreturn s5h1411_read_ucblocks(fe, ber);\r\n}\r\nstatic int s5h1411_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct s5h1411_state *state = fe->demodulator_priv;\r\np->frequency = state->current_frequency;\r\np->modulation = state->current_modulation;\r\nreturn 0;\r\n}\r\nstatic int s5h1411_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *tune)\r\n{\r\ntune->min_delay_ms = 1000;\r\nreturn 0;\r\n}\r\nstatic void s5h1411_release(struct dvb_frontend *fe)\r\n{\r\nstruct s5h1411_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *s5h1411_attach(const struct s5h1411_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct s5h1411_state *state = NULL;\r\nu16 reg;\r\nstate = kzalloc(sizeof(struct s5h1411_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->current_modulation = VSB_8;\r\nstate->inversion = state->config->inversion;\r\nreg = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0x05);\r\nif (reg != 0x0066)\r\ngoto error;\r\nmemcpy(&state->frontend.ops, &s5h1411_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nif (s5h1411_init(&state->frontend) != 0) {\r\nprintk(KERN_ERR "%s: Failed to initialize correctly\n",\r\n__func__);\r\ngoto error;\r\n}\r\ns5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf5, 1);\r\ns5h1411_set_powerstate(&state->frontend, 1);\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
