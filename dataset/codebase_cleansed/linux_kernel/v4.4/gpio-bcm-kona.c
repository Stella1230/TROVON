static inline struct bcm_kona_gpio *to_kona_gpio(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct bcm_kona_gpio, gpio_chip);\r\n}\r\nstatic inline void bcm_kona_gpio_write_lock_regs(void __iomem *reg_base,\r\nint bank_id, u32 lockcode)\r\n{\r\nwritel(BCM_GPIO_PASSWD, reg_base + GPIO_GPPWR_OFFSET);\r\nwritel(lockcode, reg_base + GPIO_PWD_STATUS(bank_id));\r\n}\r\nstatic void bcm_kona_gpio_lock_gpio(struct bcm_kona_gpio *kona_gpio,\r\nunsigned gpio)\r\n{\r\nu32 val;\r\nunsigned long flags;\r\nint bank_id = GPIO_BANK(gpio);\r\nspin_lock_irqsave(&kona_gpio->lock, flags);\r\nval = readl(kona_gpio->reg_base + GPIO_PWD_STATUS(bank_id));\r\nval |= BIT(gpio);\r\nbcm_kona_gpio_write_lock_regs(kona_gpio->reg_base, bank_id, val);\r\nspin_unlock_irqrestore(&kona_gpio->lock, flags);\r\n}\r\nstatic void bcm_kona_gpio_unlock_gpio(struct bcm_kona_gpio *kona_gpio,\r\nunsigned gpio)\r\n{\r\nu32 val;\r\nunsigned long flags;\r\nint bank_id = GPIO_BANK(gpio);\r\nspin_lock_irqsave(&kona_gpio->lock, flags);\r\nval = readl(kona_gpio->reg_base + GPIO_PWD_STATUS(bank_id));\r\nval &= ~BIT(gpio);\r\nbcm_kona_gpio_write_lock_regs(kona_gpio->reg_base, bank_id, val);\r\nspin_unlock_irqrestore(&kona_gpio->lock, flags);\r\n}\r\nstatic int bcm_kona_gpio_get_dir(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nstruct bcm_kona_gpio *kona_gpio = to_kona_gpio(chip);\r\nvoid __iomem *reg_base = kona_gpio->reg_base;\r\nu32 val;\r\nval = readl(reg_base + GPIO_CONTROL(gpio)) & GPIO_GPCTR0_IOTR_MASK;\r\nreturn val ? GPIOF_DIR_IN : GPIOF_DIR_OUT;\r\n}\r\nstatic void bcm_kona_gpio_set(struct gpio_chip *chip, unsigned gpio, int value)\r\n{\r\nstruct bcm_kona_gpio *kona_gpio;\r\nvoid __iomem *reg_base;\r\nint bank_id = GPIO_BANK(gpio);\r\nint bit = GPIO_BIT(gpio);\r\nu32 val, reg_offset;\r\nunsigned long flags;\r\nkona_gpio = to_kona_gpio(chip);\r\nreg_base = kona_gpio->reg_base;\r\nspin_lock_irqsave(&kona_gpio->lock, flags);\r\nif (bcm_kona_gpio_get_dir(chip, gpio) == GPIOF_DIR_IN)\r\ngoto out;\r\nreg_offset = value ? GPIO_OUT_SET(bank_id) : GPIO_OUT_CLEAR(bank_id);\r\nval = readl(reg_base + reg_offset);\r\nval |= BIT(bit);\r\nwritel(val, reg_base + reg_offset);\r\nout:\r\nspin_unlock_irqrestore(&kona_gpio->lock, flags);\r\n}\r\nstatic int bcm_kona_gpio_get(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nstruct bcm_kona_gpio *kona_gpio;\r\nvoid __iomem *reg_base;\r\nint bank_id = GPIO_BANK(gpio);\r\nint bit = GPIO_BIT(gpio);\r\nu32 val, reg_offset;\r\nunsigned long flags;\r\nkona_gpio = to_kona_gpio(chip);\r\nreg_base = kona_gpio->reg_base;\r\nspin_lock_irqsave(&kona_gpio->lock, flags);\r\nif (bcm_kona_gpio_get_dir(chip, gpio) == GPIOF_DIR_IN)\r\nreg_offset = GPIO_IN_STATUS(bank_id);\r\nelse\r\nreg_offset = GPIO_OUT_STATUS(bank_id);\r\nval = readl(reg_base + reg_offset);\r\nspin_unlock_irqrestore(&kona_gpio->lock, flags);\r\nreturn !!(val & BIT(bit));\r\n}\r\nstatic int bcm_kona_gpio_request(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nstruct bcm_kona_gpio *kona_gpio = to_kona_gpio(chip);\r\nbcm_kona_gpio_unlock_gpio(kona_gpio, gpio);\r\nreturn 0;\r\n}\r\nstatic void bcm_kona_gpio_free(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nstruct bcm_kona_gpio *kona_gpio = to_kona_gpio(chip);\r\nbcm_kona_gpio_lock_gpio(kona_gpio, gpio);\r\n}\r\nstatic int bcm_kona_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nstruct bcm_kona_gpio *kona_gpio;\r\nvoid __iomem *reg_base;\r\nu32 val;\r\nunsigned long flags;\r\nkona_gpio = to_kona_gpio(chip);\r\nreg_base = kona_gpio->reg_base;\r\nspin_lock_irqsave(&kona_gpio->lock, flags);\r\nval = readl(reg_base + GPIO_CONTROL(gpio));\r\nval &= ~GPIO_GPCTR0_IOTR_MASK;\r\nval |= GPIO_GPCTR0_IOTR_CMD_INPUT;\r\nwritel(val, reg_base + GPIO_CONTROL(gpio));\r\nspin_unlock_irqrestore(&kona_gpio->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bcm_kona_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned gpio, int value)\r\n{\r\nstruct bcm_kona_gpio *kona_gpio;\r\nvoid __iomem *reg_base;\r\nint bank_id = GPIO_BANK(gpio);\r\nint bit = GPIO_BIT(gpio);\r\nu32 val, reg_offset;\r\nunsigned long flags;\r\nkona_gpio = to_kona_gpio(chip);\r\nreg_base = kona_gpio->reg_base;\r\nspin_lock_irqsave(&kona_gpio->lock, flags);\r\nval = readl(reg_base + GPIO_CONTROL(gpio));\r\nval &= ~GPIO_GPCTR0_IOTR_MASK;\r\nval |= GPIO_GPCTR0_IOTR_CMD_0UTPUT;\r\nwritel(val, reg_base + GPIO_CONTROL(gpio));\r\nreg_offset = value ? GPIO_OUT_SET(bank_id) : GPIO_OUT_CLEAR(bank_id);\r\nval = readl(reg_base + reg_offset);\r\nval |= BIT(bit);\r\nwritel(val, reg_base + reg_offset);\r\nspin_unlock_irqrestore(&kona_gpio->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bcm_kona_gpio_to_irq(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nstruct bcm_kona_gpio *kona_gpio;\r\nkona_gpio = to_kona_gpio(chip);\r\nif (gpio >= kona_gpio->gpio_chip.ngpio)\r\nreturn -ENXIO;\r\nreturn irq_create_mapping(kona_gpio->irq_domain, gpio);\r\n}\r\nstatic int bcm_kona_gpio_set_debounce(struct gpio_chip *chip, unsigned gpio,\r\nunsigned debounce)\r\n{\r\nstruct bcm_kona_gpio *kona_gpio;\r\nvoid __iomem *reg_base;\r\nu32 val, res;\r\nunsigned long flags;\r\nkona_gpio = to_kona_gpio(chip);\r\nreg_base = kona_gpio->reg_base;\r\nif ((debounce > 0 && debounce < 1000) || debounce > 128000) {\r\ndev_err(chip->dev, "Debounce value %u not in range\n",\r\ndebounce);\r\nreturn -EINVAL;\r\n}\r\nif (debounce != 0) {\r\ndebounce /= 1000;\r\nres = fls(debounce) - 1;\r\nif (res > 0 && (debounce & BIT(res - 1)))\r\nres++;\r\n}\r\nspin_lock_irqsave(&kona_gpio->lock, flags);\r\nval = readl(reg_base + GPIO_CONTROL(gpio));\r\nval &= ~GPIO_GPCTR0_DBR_MASK;\r\nif (debounce == 0) {\r\nval &= ~GPIO_GPCTR0_DB_ENABLE_MASK;\r\n} else {\r\nval |= GPIO_GPCTR0_DB_ENABLE_MASK |\r\n(res << GPIO_GPCTR0_DBR_SHIFT);\r\n}\r\nwritel(val, reg_base + GPIO_CONTROL(gpio));\r\nspin_unlock_irqrestore(&kona_gpio->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void bcm_kona_gpio_irq_ack(struct irq_data *d)\r\n{\r\nstruct bcm_kona_gpio *kona_gpio;\r\nvoid __iomem *reg_base;\r\nunsigned gpio = d->hwirq;\r\nint bank_id = GPIO_BANK(gpio);\r\nint bit = GPIO_BIT(gpio);\r\nu32 val;\r\nunsigned long flags;\r\nkona_gpio = irq_data_get_irq_chip_data(d);\r\nreg_base = kona_gpio->reg_base;\r\nspin_lock_irqsave(&kona_gpio->lock, flags);\r\nval = readl(reg_base + GPIO_INT_STATUS(bank_id));\r\nval |= BIT(bit);\r\nwritel(val, reg_base + GPIO_INT_STATUS(bank_id));\r\nspin_unlock_irqrestore(&kona_gpio->lock, flags);\r\n}\r\nstatic void bcm_kona_gpio_irq_mask(struct irq_data *d)\r\n{\r\nstruct bcm_kona_gpio *kona_gpio;\r\nvoid __iomem *reg_base;\r\nunsigned gpio = d->hwirq;\r\nint bank_id = GPIO_BANK(gpio);\r\nint bit = GPIO_BIT(gpio);\r\nu32 val;\r\nunsigned long flags;\r\nkona_gpio = irq_data_get_irq_chip_data(d);\r\nreg_base = kona_gpio->reg_base;\r\nspin_lock_irqsave(&kona_gpio->lock, flags);\r\nval = readl(reg_base + GPIO_INT_MASK(bank_id));\r\nval |= BIT(bit);\r\nwritel(val, reg_base + GPIO_INT_MASK(bank_id));\r\nspin_unlock_irqrestore(&kona_gpio->lock, flags);\r\n}\r\nstatic void bcm_kona_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nstruct bcm_kona_gpio *kona_gpio;\r\nvoid __iomem *reg_base;\r\nunsigned gpio = d->hwirq;\r\nint bank_id = GPIO_BANK(gpio);\r\nint bit = GPIO_BIT(gpio);\r\nu32 val;\r\nunsigned long flags;\r\nkona_gpio = irq_data_get_irq_chip_data(d);\r\nreg_base = kona_gpio->reg_base;\r\nspin_lock_irqsave(&kona_gpio->lock, flags);\r\nval = readl(reg_base + GPIO_INT_MSKCLR(bank_id));\r\nval |= BIT(bit);\r\nwritel(val, reg_base + GPIO_INT_MSKCLR(bank_id));\r\nspin_unlock_irqrestore(&kona_gpio->lock, flags);\r\n}\r\nstatic int bcm_kona_gpio_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct bcm_kona_gpio *kona_gpio;\r\nvoid __iomem *reg_base;\r\nunsigned gpio = d->hwirq;\r\nu32 lvl_type;\r\nu32 val;\r\nunsigned long flags;\r\nkona_gpio = irq_data_get_irq_chip_data(d);\r\nreg_base = kona_gpio->reg_base;\r\nswitch (type & IRQ_TYPE_SENSE_MASK) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nlvl_type = GPIO_GPCTR0_ITR_CMD_RISING_EDGE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nlvl_type = GPIO_GPCTR0_ITR_CMD_FALLING_EDGE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nlvl_type = GPIO_GPCTR0_ITR_CMD_BOTH_EDGE;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ndefault:\r\ndev_err(kona_gpio->gpio_chip.dev,\r\n"Invalid BCM GPIO irq type 0x%x\n", type);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&kona_gpio->lock, flags);\r\nval = readl(reg_base + GPIO_CONTROL(gpio));\r\nval &= ~GPIO_GPCTR0_ITR_MASK;\r\nval |= lvl_type << GPIO_GPCTR0_ITR_SHIFT;\r\nwritel(val, reg_base + GPIO_CONTROL(gpio));\r\nspin_unlock_irqrestore(&kona_gpio->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void bcm_kona_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nvoid __iomem *reg_base;\r\nint bit, bank_id;\r\nunsigned long sta;\r\nstruct bcm_kona_gpio_bank *bank = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nchained_irq_enter(chip, desc);\r\nreg_base = bank->kona_gpio->reg_base;\r\nbank_id = bank->id;\r\nwhile ((sta = readl(reg_base + GPIO_INT_STATUS(bank_id)) &\r\n(~(readl(reg_base + GPIO_INT_MASK(bank_id)))))) {\r\nfor_each_set_bit(bit, &sta, 32) {\r\nint hwirq = GPIO_PER_BANK * bank_id + bit;\r\nint child_irq =\r\nirq_find_mapping(bank->kona_gpio->irq_domain,\r\nhwirq);\r\nwritel(readl(reg_base + GPIO_INT_STATUS(bank_id)) |\r\nBIT(bit), reg_base + GPIO_INT_STATUS(bank_id));\r\ngeneric_handle_irq(child_irq);\r\n}\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int bcm_kona_gpio_irq_reqres(struct irq_data *d)\r\n{\r\nstruct bcm_kona_gpio *kona_gpio = irq_data_get_irq_chip_data(d);\r\nif (gpiochip_lock_as_irq(&kona_gpio->gpio_chip, d->hwirq)) {\r\ndev_err(kona_gpio->gpio_chip.dev,\r\n"unable to lock HW IRQ %lu for IRQ\n",\r\nd->hwirq);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bcm_kona_gpio_irq_relres(struct irq_data *d)\r\n{\r\nstruct bcm_kona_gpio *kona_gpio = irq_data_get_irq_chip_data(d);\r\ngpiochip_unlock_as_irq(&kona_gpio->gpio_chip, d->hwirq);\r\n}\r\nstatic int bcm_kona_gpio_irq_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nint ret;\r\nret = irq_set_chip_data(irq, d->host_data);\r\nif (ret < 0)\r\nreturn ret;\r\nirq_set_lockdep_class(irq, &gpio_lock_class);\r\nirq_set_chip_and_handler(irq, &bcm_gpio_irq_chip, handle_simple_irq);\r\nirq_set_noprobe(irq);\r\nreturn 0;\r\n}\r\nstatic void bcm_kona_gpio_irq_unmap(struct irq_domain *d, unsigned int irq)\r\n{\r\nirq_set_chip_and_handler(irq, NULL, NULL);\r\nirq_set_chip_data(irq, NULL);\r\n}\r\nstatic void bcm_kona_gpio_reset(struct bcm_kona_gpio *kona_gpio)\r\n{\r\nvoid __iomem *reg_base;\r\nint i;\r\nreg_base = kona_gpio->reg_base;\r\nfor (i = 0; i < kona_gpio->num_bank; i++) {\r\nbcm_kona_gpio_write_lock_regs(kona_gpio, i, UNLOCK_CODE);\r\nwritel(0xffffffff, reg_base + GPIO_INT_MASK(i));\r\nwritel(0xffffffff, reg_base + GPIO_INT_STATUS(i));\r\nbcm_kona_gpio_write_lock_regs(kona_gpio, i, LOCK_CODE);\r\n}\r\n}\r\nstatic int bcm_kona_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct of_device_id *match;\r\nstruct resource *res;\r\nstruct bcm_kona_gpio_bank *bank;\r\nstruct bcm_kona_gpio *kona_gpio;\r\nstruct gpio_chip *chip;\r\nint ret;\r\nint i;\r\nmatch = of_match_device(bcm_kona_gpio_of_match, dev);\r\nif (!match) {\r\ndev_err(dev, "Failed to find gpio controller\n");\r\nreturn -ENODEV;\r\n}\r\nkona_gpio = devm_kzalloc(dev, sizeof(*kona_gpio), GFP_KERNEL);\r\nif (!kona_gpio)\r\nreturn -ENOMEM;\r\nkona_gpio->gpio_chip = template_chip;\r\nchip = &kona_gpio->gpio_chip;\r\nkona_gpio->num_bank = of_irq_count(dev->of_node);\r\nif (kona_gpio->num_bank == 0) {\r\ndev_err(dev, "Couldn't determine # GPIO banks\n");\r\nreturn -ENOENT;\r\n}\r\nif (kona_gpio->num_bank > GPIO_MAX_BANK_NUM) {\r\ndev_err(dev, "Too many GPIO banks configured (max=%d)\n",\r\nGPIO_MAX_BANK_NUM);\r\nreturn -ENXIO;\r\n}\r\nkona_gpio->banks = devm_kzalloc(dev,\r\nkona_gpio->num_bank *\r\nsizeof(*kona_gpio->banks), GFP_KERNEL);\r\nif (!kona_gpio->banks)\r\nreturn -ENOMEM;\r\nkona_gpio->pdev = pdev;\r\nplatform_set_drvdata(pdev, kona_gpio);\r\nchip->of_node = dev->of_node;\r\nchip->ngpio = kona_gpio->num_bank * GPIO_PER_BANK;\r\nkona_gpio->irq_domain = irq_domain_add_linear(dev->of_node,\r\nchip->ngpio,\r\n&bcm_kona_irq_ops,\r\nkona_gpio);\r\nif (!kona_gpio->irq_domain) {\r\ndev_err(dev, "Couldn't allocate IRQ domain\n");\r\nreturn -ENXIO;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nkona_gpio->reg_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(kona_gpio->reg_base)) {\r\nret = -ENXIO;\r\ngoto err_irq_domain;\r\n}\r\nfor (i = 0; i < kona_gpio->num_bank; i++) {\r\nbank = &kona_gpio->banks[i];\r\nbank->id = i;\r\nbank->irq = platform_get_irq(pdev, i);\r\nbank->kona_gpio = kona_gpio;\r\nif (bank->irq < 0) {\r\ndev_err(dev, "Couldn't get IRQ for bank %d", i);\r\nret = -ENOENT;\r\ngoto err_irq_domain;\r\n}\r\n}\r\ndev_info(&pdev->dev, "Setting up Kona GPIO\n");\r\nbcm_kona_gpio_reset(kona_gpio);\r\nret = gpiochip_add(chip);\r\nif (ret < 0) {\r\ndev_err(dev, "Couldn't add GPIO chip -- %d\n", ret);\r\ngoto err_irq_domain;\r\n}\r\nfor (i = 0; i < kona_gpio->num_bank; i++) {\r\nbank = &kona_gpio->banks[i];\r\nirq_set_chained_handler_and_data(bank->irq,\r\nbcm_kona_gpio_irq_handler,\r\nbank);\r\n}\r\nspin_lock_init(&kona_gpio->lock);\r\nreturn 0;\r\nerr_irq_domain:\r\nirq_domain_remove(kona_gpio->irq_domain);\r\nreturn ret;\r\n}
