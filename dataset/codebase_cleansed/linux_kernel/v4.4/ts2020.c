static int ts2020_release(struct dvb_frontend *fe)\r\n{\r\nstruct ts2020_priv *priv = fe->tuner_priv;\r\nstruct i2c_client *client = priv->client;\r\ndev_dbg(&client->dev, "\n");\r\ni2c_unregister_device(client);\r\nreturn 0;\r\n}\r\nstatic int ts2020_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct ts2020_priv *priv = fe->tuner_priv;\r\nint ret;\r\nu8 u8tmp;\r\nif (priv->tuner == TS2020_M88TS2020)\r\nu8tmp = 0x0a;\r\nelse\r\nu8tmp = 0x00;\r\nret = regmap_write(priv->regmap, u8tmp, 0x00);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!priv->dont_poll)\r\ncancel_delayed_work_sync(&priv->stat_work);\r\nreturn 0;\r\n}\r\nstatic int ts2020_init(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct ts2020_priv *priv = fe->tuner_priv;\r\nint i;\r\nu8 u8tmp;\r\nif (priv->tuner == TS2020_M88TS2020) {\r\nregmap_write(priv->regmap, 0x42, 0x73);\r\nregmap_write(priv->regmap, 0x05, priv->clk_out_div);\r\nregmap_write(priv->regmap, 0x20, 0x27);\r\nregmap_write(priv->regmap, 0x07, 0x02);\r\nregmap_write(priv->regmap, 0x11, 0xff);\r\nregmap_write(priv->regmap, 0x60, 0xf9);\r\nregmap_write(priv->regmap, 0x08, 0x01);\r\nregmap_write(priv->regmap, 0x00, 0x41);\r\n} else {\r\nstatic const struct ts2020_reg_val reg_vals[] = {\r\n{0x7d, 0x9d},\r\n{0x7c, 0x9a},\r\n{0x7a, 0x76},\r\n{0x3b, 0x01},\r\n{0x63, 0x88},\r\n{0x61, 0x85},\r\n{0x22, 0x30},\r\n{0x30, 0x40},\r\n{0x20, 0x23},\r\n{0x24, 0x02},\r\n{0x12, 0xa0},\r\n};\r\nregmap_write(priv->regmap, 0x00, 0x01);\r\nregmap_write(priv->regmap, 0x00, 0x03);\r\nswitch (priv->clk_out) {\r\ncase TS2020_CLK_OUT_DISABLED:\r\nu8tmp = 0x60;\r\nbreak;\r\ncase TS2020_CLK_OUT_ENABLED:\r\nu8tmp = 0x70;\r\nregmap_write(priv->regmap, 0x05, priv->clk_out_div);\r\nbreak;\r\ncase TS2020_CLK_OUT_ENABLED_XTALOUT:\r\nu8tmp = 0x6c;\r\nbreak;\r\ndefault:\r\nu8tmp = 0x60;\r\nbreak;\r\n}\r\nregmap_write(priv->regmap, 0x42, u8tmp);\r\nif (priv->loop_through)\r\nu8tmp = 0xec;\r\nelse\r\nu8tmp = 0x6c;\r\nregmap_write(priv->regmap, 0x62, u8tmp);\r\nfor (i = 0; i < ARRAY_SIZE(reg_vals); i++)\r\nregmap_write(priv->regmap, reg_vals[i].reg,\r\nreg_vals[i].val);\r\n}\r\nc->strength.len = 1;\r\nc->strength.stat[0].scale = FE_SCALE_DECIBEL;\r\nc->strength.stat[0].uvalue = 0;\r\nts2020_stat_work(&priv->stat_work.work);\r\nreturn 0;\r\n}\r\nstatic int ts2020_tuner_gate_ctrl(struct dvb_frontend *fe, u8 offset)\r\n{\r\nstruct ts2020_priv *priv = fe->tuner_priv;\r\nint ret;\r\nret = regmap_write(priv->regmap, 0x51, 0x1f - offset);\r\nret |= regmap_write(priv->regmap, 0x51, 0x1f);\r\nret |= regmap_write(priv->regmap, 0x50, offset);\r\nret |= regmap_write(priv->regmap, 0x50, 0x00);\r\nmsleep(20);\r\nreturn ret;\r\n}\r\nstatic int ts2020_set_tuner_rf(struct dvb_frontend *fe)\r\n{\r\nstruct ts2020_priv *dev = fe->tuner_priv;\r\nint ret;\r\nunsigned int utmp;\r\nret = regmap_read(dev->regmap, 0x3d, &utmp);\r\nutmp &= 0x7f;\r\nif (utmp < 0x16)\r\nutmp = 0xa1;\r\nelse if (utmp == 0x16)\r\nutmp = 0x99;\r\nelse\r\nutmp = 0xf9;\r\nregmap_write(dev->regmap, 0x60, utmp);\r\nret = ts2020_tuner_gate_ctrl(fe, 0x08);\r\nreturn ret;\r\n}\r\nstatic int ts2020_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct ts2020_priv *priv = fe->tuner_priv;\r\nint ret;\r\nunsigned int utmp;\r\nu32 f3db, gdiv28;\r\nu16 u16tmp, value, lpf_coeff;\r\nu8 buf[3], reg10, lpf_mxdiv, mlpf_max, mlpf_min, nlpf;\r\nunsigned int f_ref_khz, f_vco_khz, div_ref, div_out, pll_n;\r\nunsigned int frequency_khz = c->frequency;\r\nf_ref_khz = TS2020_XTAL_FREQ;\r\ndiv_ref = DIV_ROUND_CLOSEST(f_ref_khz, 2000);\r\nif (frequency_khz < priv->frequency_div) {\r\ndiv_out = 4;\r\nreg10 = 0x10;\r\n} else {\r\ndiv_out = 2;\r\nreg10 = 0x00;\r\n}\r\nf_vco_khz = frequency_khz * div_out;\r\npll_n = f_vco_khz * div_ref / f_ref_khz;\r\npll_n += pll_n % 2;\r\npriv->frequency_khz = pll_n * f_ref_khz / div_ref / div_out;\r\npr_debug("frequency=%u offset=%d f_vco_khz=%u pll_n=%u div_ref=%u div_out=%u\n",\r\npriv->frequency_khz, priv->frequency_khz - c->frequency,\r\nf_vco_khz, pll_n, div_ref, div_out);\r\nif (priv->tuner == TS2020_M88TS2020) {\r\nlpf_coeff = 2766;\r\nreg10 |= 0x01;\r\nret = regmap_write(priv->regmap, 0x10, reg10);\r\n} else {\r\nlpf_coeff = 3200;\r\nreg10 |= 0x0b;\r\nret = regmap_write(priv->regmap, 0x10, reg10);\r\nret |= regmap_write(priv->regmap, 0x11, 0x40);\r\n}\r\nu16tmp = pll_n - 1024;\r\nbuf[0] = (u16tmp >> 8) & 0xff;\r\nbuf[1] = (u16tmp >> 0) & 0xff;\r\nbuf[2] = div_ref - 8;\r\nret |= regmap_write(priv->regmap, 0x01, buf[0]);\r\nret |= regmap_write(priv->regmap, 0x02, buf[1]);\r\nret |= regmap_write(priv->regmap, 0x03, buf[2]);\r\nret |= ts2020_tuner_gate_ctrl(fe, 0x10);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nret |= ts2020_tuner_gate_ctrl(fe, 0x08);\r\nif (priv->tuner == TS2020_M88TS2020)\r\nret |= ts2020_set_tuner_rf(fe);\r\ngdiv28 = (TS2020_XTAL_FREQ / 1000 * 1694 + 500) / 1000;\r\nret |= regmap_write(priv->regmap, 0x04, gdiv28 & 0xff);\r\nret |= ts2020_tuner_gate_ctrl(fe, 0x04);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nif (priv->tuner == TS2020_M88TS2022) {\r\nret = regmap_write(priv->regmap, 0x25, 0x00);\r\nret |= regmap_write(priv->regmap, 0x27, 0x70);\r\nret |= regmap_write(priv->regmap, 0x41, 0x09);\r\nret |= regmap_write(priv->regmap, 0x08, 0x0b);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\n}\r\nregmap_read(priv->regmap, 0x26, &utmp);\r\nvalue = utmp;\r\nf3db = (c->bandwidth_hz / 1000 / 2) + 2000;\r\nf3db += FREQ_OFFSET_LOW_SYM_RATE;\r\nf3db = clamp(f3db, 7000U, 40000U);\r\ngdiv28 = gdiv28 * 207 / (value * 2 + 151);\r\nmlpf_max = gdiv28 * 135 / 100;\r\nmlpf_min = gdiv28 * 78 / 100;\r\nif (mlpf_max > 63)\r\nmlpf_max = 63;\r\nnlpf = (f3db * gdiv28 * 2 / lpf_coeff /\r\n(TS2020_XTAL_FREQ / 1000) + 1) / 2;\r\nif (nlpf > 23)\r\nnlpf = 23;\r\nif (nlpf < 1)\r\nnlpf = 1;\r\nlpf_mxdiv = (nlpf * (TS2020_XTAL_FREQ / 1000)\r\n* lpf_coeff * 2 / f3db + 1) / 2;\r\nif (lpf_mxdiv < mlpf_min) {\r\nnlpf++;\r\nlpf_mxdiv = (nlpf * (TS2020_XTAL_FREQ / 1000)\r\n* lpf_coeff * 2 / f3db + 1) / 2;\r\n}\r\nif (lpf_mxdiv > mlpf_max)\r\nlpf_mxdiv = mlpf_max;\r\nret = regmap_write(priv->regmap, 0x04, lpf_mxdiv);\r\nret |= regmap_write(priv->regmap, 0x06, nlpf);\r\nret |= ts2020_tuner_gate_ctrl(fe, 0x04);\r\nret |= ts2020_tuner_gate_ctrl(fe, 0x01);\r\nmsleep(80);\r\nreturn (ret < 0) ? -EINVAL : 0;\r\n}\r\nstatic int ts2020_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct ts2020_priv *priv = fe->tuner_priv;\r\n*frequency = priv->frequency_khz;\r\nreturn 0;\r\n}\r\nstatic int ts2020_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\n*frequency = 0;\r\nreturn 0;\r\n}\r\nstatic int ts2020_read_tuner_gain(struct dvb_frontend *fe, unsigned v_agc,\r\n__s64 *_gain)\r\n{\r\nstruct ts2020_priv *priv = fe->tuner_priv;\r\nunsigned long gain1, gain2, gain3;\r\nunsigned utmp;\r\nint ret;\r\nret = regmap_read(priv->regmap, 0x3d, &utmp);\r\nif (ret < 0)\r\nreturn ret;\r\ngain1 = utmp & 0x1f;\r\nret = regmap_read(priv->regmap, 0x21, &utmp);\r\nif (ret < 0)\r\nreturn ret;\r\ngain2 = utmp & 0x1f;\r\nswitch (priv->tuner) {\r\ncase TS2020_M88TS2020:\r\ngain1 = clamp_t(long, gain1, 0, 15);\r\ngain2 = clamp_t(long, gain2, 0, 13);\r\nv_agc = clamp_t(long, v_agc, 400, 1100);\r\n*_gain = -(gain1 * 2330 +\r\ngain2 * 3500 +\r\nv_agc * 24 / 10 * 10 +\r\n10000);\r\nbreak;\r\ncase TS2020_M88TS2022:\r\nret = regmap_read(priv->regmap, 0x66, &utmp);\r\nif (ret < 0)\r\nreturn ret;\r\ngain3 = (utmp >> 3) & 0x07;\r\ngain1 = clamp_t(long, gain1, 0, 15);\r\ngain2 = clamp_t(long, gain2, 2, 16);\r\ngain3 = clamp_t(long, gain3, 0, 6);\r\nv_agc = clamp_t(long, v_agc, 600, 1600);\r\n*_gain = -(gain1 * 2650 +\r\ngain2 * 3380 +\r\ngain3 * 2850 +\r\nv_agc * 176 / 100 * 10 -\r\n30000);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ts2020_get_tuner_gain(struct dvb_frontend *fe, __s64 *_gain)\r\n{\r\nstruct ts2020_priv *priv = fe->tuner_priv;\r\nint v_agc = 0, ret;\r\nu8 agc_pwm;\r\nif (priv->get_agc_pwm) {\r\nret = priv->get_agc_pwm(fe, &agc_pwm);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (priv->tuner) {\r\ncase TS2020_M88TS2020:\r\nv_agc = (int)agc_pwm * 20 - 1166;\r\nbreak;\r\ncase TS2020_M88TS2022:\r\nv_agc = (int)agc_pwm * 16 - 670;\r\nbreak;\r\n}\r\nif (v_agc < 0)\r\nv_agc = 0;\r\n}\r\nreturn ts2020_read_tuner_gain(fe, v_agc, _gain);\r\n}\r\nstatic void ts2020_stat_work(struct work_struct *work)\r\n{\r\nstruct ts2020_priv *priv = container_of(work, struct ts2020_priv,\r\nstat_work.work);\r\nstruct i2c_client *client = priv->client;\r\nstruct dtv_frontend_properties *c = &priv->fe->dtv_property_cache;\r\nint ret;\r\ndev_dbg(&client->dev, "\n");\r\nret = ts2020_get_tuner_gain(priv->fe, &c->strength.stat[0].svalue);\r\nif (ret < 0)\r\ngoto err;\r\nc->strength.stat[0].scale = FE_SCALE_DECIBEL;\r\nif (!priv->dont_poll)\r\nschedule_delayed_work(&priv->stat_work, msecs_to_jiffies(2000));\r\nreturn;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\n}\r\nstatic int ts2020_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *_signal_strength)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct ts2020_priv *priv = fe->tuner_priv;\r\nunsigned strength;\r\n__s64 gain;\r\nif (priv->dont_poll)\r\nts2020_stat_work(&priv->stat_work.work);\r\nif (c->strength.stat[0].scale == FE_SCALE_NOT_AVAILABLE) {\r\n*_signal_strength = 0;\r\nreturn 0;\r\n}\r\ngain = c->strength.stat[0].svalue;\r\nif (gain < -85000)\r\nstrength = 0;\r\nelse if (gain < -65000)\r\nstrength = 0 + div64_s64((85000 + gain) * 3, 1000);\r\nelse if (gain < -45000)\r\nstrength = 60 + div64_s64((65000 + gain) * 3, 2000);\r\nelse\r\nstrength = 90 + div64_s64((45000 + gain), 5000);\r\n*_signal_strength = strength * 65535 / 100;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *ts2020_attach(struct dvb_frontend *fe,\r\nconst struct ts2020_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct i2c_client *client;\r\nstruct i2c_board_info board_info;\r\nstruct ts2020_config pdata;\r\nmemcpy(&pdata, config, sizeof(pdata));\r\npdata.fe = fe;\r\npdata.attach_in_use = true;\r\nmemset(&board_info, 0, sizeof(board_info));\r\nstrlcpy(board_info.type, "ts2020", I2C_NAME_SIZE);\r\nboard_info.addr = config->tuner_address;\r\nboard_info.platform_data = &pdata;\r\nclient = i2c_new_device(i2c, &board_info);\r\nif (!client || !client->dev.driver)\r\nreturn NULL;\r\nreturn fe;\r\n}\r\nstatic void ts2020_regmap_lock(void *__dev)\r\n{\r\nstruct ts2020_priv *dev = __dev;\r\nmutex_lock(&dev->regmap_mutex);\r\nif (dev->fe->ops.i2c_gate_ctrl)\r\ndev->fe->ops.i2c_gate_ctrl(dev->fe, 1);\r\n}\r\nstatic void ts2020_regmap_unlock(void *__dev)\r\n{\r\nstruct ts2020_priv *dev = __dev;\r\nif (dev->fe->ops.i2c_gate_ctrl)\r\ndev->fe->ops.i2c_gate_ctrl(dev->fe, 0);\r\nmutex_unlock(&dev->regmap_mutex);\r\n}\r\nstatic int ts2020_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ts2020_config *pdata = client->dev.platform_data;\r\nstruct dvb_frontend *fe = pdata->fe;\r\nstruct ts2020_priv *dev;\r\nint ret;\r\nu8 u8tmp;\r\nunsigned int utmp;\r\nchar *chip_str;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nmutex_init(&dev->regmap_mutex);\r\ndev->regmap_config.reg_bits = 8,\r\ndev->regmap_config.val_bits = 8,\r\ndev->regmap_config.lock = ts2020_regmap_lock,\r\ndev->regmap_config.unlock = ts2020_regmap_unlock,\r\ndev->regmap_config.lock_arg = dev,\r\ndev->regmap = regmap_init_i2c(client, &dev->regmap_config);\r\nif (IS_ERR(dev->regmap)) {\r\nret = PTR_ERR(dev->regmap);\r\ngoto err_kfree;\r\n}\r\ndev->i2c = client->adapter;\r\ndev->i2c_address = client->addr;\r\ndev->loop_through = pdata->loop_through;\r\ndev->clk_out = pdata->clk_out;\r\ndev->clk_out_div = pdata->clk_out_div;\r\ndev->dont_poll = pdata->dont_poll;\r\ndev->frequency_div = pdata->frequency_div;\r\ndev->fe = fe;\r\ndev->get_agc_pwm = pdata->get_agc_pwm;\r\nfe->tuner_priv = dev;\r\ndev->client = client;\r\nINIT_DELAYED_WORK(&dev->stat_work, ts2020_stat_work);\r\nret = regmap_read(dev->regmap, 0x00, &utmp);\r\nif (ret)\r\ngoto err_regmap_exit;\r\nif ((utmp & 0x03) == 0x00) {\r\nret = regmap_write(dev->regmap, 0x00, 0x01);\r\nif (ret)\r\ngoto err_regmap_exit;\r\nusleep_range(2000, 50000);\r\n}\r\nret = regmap_write(dev->regmap, 0x00, 0x03);\r\nif (ret)\r\ngoto err_regmap_exit;\r\nusleep_range(2000, 50000);\r\nret = regmap_read(dev->regmap, 0x00, &utmp);\r\nif (ret)\r\ngoto err_regmap_exit;\r\ndev_dbg(&client->dev, "chip_id=%02x\n", utmp);\r\nswitch (utmp) {\r\ncase 0x01:\r\ncase 0x41:\r\ncase 0x81:\r\ndev->tuner = TS2020_M88TS2020;\r\nchip_str = "TS2020";\r\nif (!dev->frequency_div)\r\ndev->frequency_div = 1060000;\r\nbreak;\r\ncase 0xc3:\r\ncase 0x83:\r\ndev->tuner = TS2020_M88TS2022;\r\nchip_str = "TS2022";\r\nif (!dev->frequency_div)\r\ndev->frequency_div = 1103000;\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\ngoto err_regmap_exit;\r\n}\r\nif (dev->tuner == TS2020_M88TS2022) {\r\nswitch (dev->clk_out) {\r\ncase TS2020_CLK_OUT_DISABLED:\r\nu8tmp = 0x60;\r\nbreak;\r\ncase TS2020_CLK_OUT_ENABLED:\r\nu8tmp = 0x70;\r\nret = regmap_write(dev->regmap, 0x05, dev->clk_out_div);\r\nif (ret)\r\ngoto err_regmap_exit;\r\nbreak;\r\ncase TS2020_CLK_OUT_ENABLED_XTALOUT:\r\nu8tmp = 0x6c;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err_regmap_exit;\r\n}\r\nret = regmap_write(dev->regmap, 0x42, u8tmp);\r\nif (ret)\r\ngoto err_regmap_exit;\r\nif (dev->loop_through)\r\nu8tmp = 0xec;\r\nelse\r\nu8tmp = 0x6c;\r\nret = regmap_write(dev->regmap, 0x62, u8tmp);\r\nif (ret)\r\ngoto err_regmap_exit;\r\n}\r\nret = regmap_write(dev->regmap, 0x00, 0x00);\r\nif (ret)\r\ngoto err_regmap_exit;\r\ndev_info(&client->dev,\r\n"Montage Technology %s successfully identified\n", chip_str);\r\nmemcpy(&fe->ops.tuner_ops, &ts2020_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nif (!pdata->attach_in_use)\r\nfe->ops.tuner_ops.release = NULL;\r\ni2c_set_clientdata(client, dev);\r\nreturn 0;\r\nerr_regmap_exit:\r\nregmap_exit(dev->regmap);\r\nerr_kfree:\r\nkfree(dev);\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int ts2020_remove(struct i2c_client *client)\r\n{\r\nstruct ts2020_priv *dev = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\nregmap_exit(dev->regmap);\r\nkfree(dev);\r\nreturn 0;\r\n}
