ssize_t vivid_radio_tx_write(struct file *file, const char __user *buf,\r\nsize_t size, loff_t *offset)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstruct v4l2_rds_data *data = dev->rds_gen.data;\r\nstruct timespec ts;\r\nunsigned blk;\r\nint i;\r\nif (dev->radio_tx_rds_controls)\r\nreturn -EINVAL;\r\nif (size < sizeof(*data))\r\nreturn -EINVAL;\r\nsize = sizeof(*data) * (size / sizeof(*data));\r\nif (mutex_lock_interruptible(&dev->mutex))\r\nreturn -ERESTARTSYS;\r\nif (dev->radio_tx_rds_owner &&\r\nfile->private_data != dev->radio_tx_rds_owner) {\r\nmutex_unlock(&dev->mutex);\r\nreturn -EBUSY;\r\n}\r\ndev->radio_tx_rds_owner = file->private_data;\r\nretry:\r\nktime_get_ts(&ts);\r\nts = timespec_sub(ts, dev->radio_rds_init_ts);\r\nblk = ts.tv_sec * 100 + ts.tv_nsec / 10000000;\r\nblk = (blk * VIVID_RDS_GEN_BLOCKS) / 500;\r\nif (blk - VIVID_RDS_GEN_BLOCKS >= dev->radio_tx_rds_last_block)\r\ndev->radio_tx_rds_last_block = blk - VIVID_RDS_GEN_BLOCKS + 1;\r\nif (blk == dev->radio_tx_rds_last_block ||\r\n!(dev->radio_tx_subchans & V4L2_TUNER_SUB_RDS)) {\r\nmutex_unlock(&dev->mutex);\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EWOULDBLOCK;\r\nif (msleep_interruptible(20) && signal_pending(current))\r\nreturn -EINTR;\r\nif (mutex_lock_interruptible(&dev->mutex))\r\nreturn -ERESTARTSYS;\r\ngoto retry;\r\n}\r\nfor (i = 0; i < size && blk > dev->radio_tx_rds_last_block;\r\ndev->radio_tx_rds_last_block++) {\r\nunsigned data_blk = dev->radio_tx_rds_last_block % VIVID_RDS_GEN_BLOCKS;\r\nstruct v4l2_rds_data rds;\r\nif (copy_from_user(&rds, buf + i, sizeof(rds))) {\r\ni = -EFAULT;\r\nbreak;\r\n}\r\ni += sizeof(rds);\r\nif (!dev->radio_rds_loop)\r\ncontinue;\r\nif ((rds.block & V4L2_RDS_BLOCK_MSK) == V4L2_RDS_BLOCK_INVALID ||\r\n(rds.block & V4L2_RDS_BLOCK_ERROR))\r\ncontinue;\r\nrds.block &= V4L2_RDS_BLOCK_MSK;\r\ndata[data_blk] = rds;\r\n}\r\nmutex_unlock(&dev->mutex);\r\nreturn i;\r\n}\r\nunsigned int vivid_radio_tx_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nreturn POLLOUT | POLLWRNORM | v4l2_ctrl_poll(file, wait);\r\n}\r\nint vidioc_g_modulator(struct file *file, void *fh, struct v4l2_modulator *a)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (a->index > 0)\r\nreturn -EINVAL;\r\nstrlcpy(a->name, "AM/FM/SW Transmitter", sizeof(a->name));\r\na->capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO |\r\nV4L2_TUNER_CAP_FREQ_BANDS | V4L2_TUNER_CAP_RDS |\r\n(dev->radio_tx_rds_controls ?\r\nV4L2_TUNER_CAP_RDS_CONTROLS :\r\nV4L2_TUNER_CAP_RDS_BLOCK_IO);\r\na->rangelow = AM_FREQ_RANGE_LOW;\r\na->rangehigh = FM_FREQ_RANGE_HIGH;\r\na->txsubchans = dev->radio_tx_subchans;\r\nreturn 0;\r\n}\r\nint vidioc_s_modulator(struct file *file, void *fh, const struct v4l2_modulator *a)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (a->index)\r\nreturn -EINVAL;\r\nif (a->txsubchans & ~0x13)\r\nreturn -EINVAL;\r\ndev->radio_tx_subchans = a->txsubchans;\r\nreturn 0;\r\n}
