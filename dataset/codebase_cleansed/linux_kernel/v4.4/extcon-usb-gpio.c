static void usb_extcon_detect_cable(struct work_struct *work)\r\n{\r\nint id;\r\nstruct usb_extcon_info *info = container_of(to_delayed_work(work),\r\nstruct usb_extcon_info,\r\nwq_detcable);\r\nid = gpiod_get_value_cansleep(info->id_gpiod);\r\nif (id) {\r\nextcon_set_cable_state_(info->edev, EXTCON_USB_HOST, false);\r\nextcon_set_cable_state_(info->edev, EXTCON_USB, true);\r\n} else {\r\nextcon_set_cable_state_(info->edev, EXTCON_USB, false);\r\nextcon_set_cable_state_(info->edev, EXTCON_USB_HOST, true);\r\n}\r\n}\r\nstatic irqreturn_t usb_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct usb_extcon_info *info = dev_id;\r\nqueue_delayed_work(system_power_efficient_wq, &info->wq_detcable,\r\ninfo->debounce_jiffies);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int usb_extcon_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct usb_extcon_info *info;\r\nint ret;\r\nif (!np)\r\nreturn -EINVAL;\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->dev = dev;\r\ninfo->id_gpiod = devm_gpiod_get(&pdev->dev, "id", GPIOD_IN);\r\nif (IS_ERR(info->id_gpiod)) {\r\ndev_err(dev, "failed to get ID GPIO\n");\r\nreturn PTR_ERR(info->id_gpiod);\r\n}\r\ninfo->edev = devm_extcon_dev_allocate(dev, usb_extcon_cable);\r\nif (IS_ERR(info->edev)) {\r\ndev_err(dev, "failed to allocate extcon device\n");\r\nreturn -ENOMEM;\r\n}\r\nret = devm_extcon_dev_register(dev, info->edev);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to register extcon device\n");\r\nreturn ret;\r\n}\r\nret = gpiod_set_debounce(info->id_gpiod,\r\nUSB_GPIO_DEBOUNCE_MS * 1000);\r\nif (ret < 0)\r\ninfo->debounce_jiffies = msecs_to_jiffies(USB_GPIO_DEBOUNCE_MS);\r\nINIT_DELAYED_WORK(&info->wq_detcable, usb_extcon_detect_cable);\r\ninfo->id_irq = gpiod_to_irq(info->id_gpiod);\r\nif (info->id_irq < 0) {\r\ndev_err(dev, "failed to get ID IRQ\n");\r\nreturn info->id_irq;\r\n}\r\nret = devm_request_threaded_irq(dev, info->id_irq, NULL,\r\nusb_irq_handler,\r\nIRQF_TRIGGER_RISING |\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\npdev->name, info);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to request handler for ID IRQ\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, info);\r\ndevice_init_wakeup(dev, 1);\r\nusb_extcon_detect_cable(&info->wq_detcable.work);\r\nreturn 0;\r\n}\r\nstatic int usb_extcon_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_extcon_info *info = platform_get_drvdata(pdev);\r\ncancel_delayed_work_sync(&info->wq_detcable);\r\nreturn 0;\r\n}\r\nstatic int usb_extcon_suspend(struct device *dev)\r\n{\r\nstruct usb_extcon_info *info = dev_get_drvdata(dev);\r\nint ret = 0;\r\nif (device_may_wakeup(dev)) {\r\nret = enable_irq_wake(info->id_irq);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndisable_irq(info->id_irq);\r\nreturn ret;\r\n}\r\nstatic int usb_extcon_resume(struct device *dev)\r\n{\r\nstruct usb_extcon_info *info = dev_get_drvdata(dev);\r\nint ret = 0;\r\nif (device_may_wakeup(dev)) {\r\nret = disable_irq_wake(info->id_irq);\r\nif (ret)\r\nreturn ret;\r\n}\r\nenable_irq(info->id_irq);\r\nreturn ret;\r\n}
