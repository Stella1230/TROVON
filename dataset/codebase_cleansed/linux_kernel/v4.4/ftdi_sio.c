static unsigned short int ftdi_232am_baud_base_to_divisor(int baud, int base)\r\n{\r\nunsigned short int divisor;\r\nint divisor3 = base / 2 / baud;\r\nif ((divisor3 & 0x7) == 7)\r\ndivisor3++;\r\ndivisor = divisor3 >> 3;\r\ndivisor3 &= 0x7;\r\nif (divisor3 == 1)\r\ndivisor |= 0xc000;\r\nelse if (divisor3 >= 4)\r\ndivisor |= 0x4000;\r\nelse if (divisor3 != 0)\r\ndivisor |= 0x8000;\r\nelse if (divisor == 1)\r\ndivisor = 0;\r\nreturn divisor;\r\n}\r\nstatic unsigned short int ftdi_232am_baud_to_divisor(int baud)\r\n{\r\nreturn ftdi_232am_baud_base_to_divisor(baud, 48000000);\r\n}\r\nstatic __u32 ftdi_232bm_baud_base_to_divisor(int baud, int base)\r\n{\r\nstatic const unsigned char divfrac[8] = { 0, 3, 2, 4, 1, 5, 6, 7 };\r\n__u32 divisor;\r\nint divisor3 = base / 2 / baud;\r\ndivisor = divisor3 >> 3;\r\ndivisor |= (__u32)divfrac[divisor3 & 0x7] << 14;\r\nif (divisor == 1)\r\ndivisor = 0;\r\nelse if (divisor == 0x4001)\r\ndivisor = 1;\r\nreturn divisor;\r\n}\r\nstatic __u32 ftdi_232bm_baud_to_divisor(int baud)\r\n{\r\nreturn ftdi_232bm_baud_base_to_divisor(baud, 48000000);\r\n}\r\nstatic __u32 ftdi_2232h_baud_base_to_divisor(int baud, int base)\r\n{\r\nstatic const unsigned char divfrac[8] = { 0, 3, 2, 4, 1, 5, 6, 7 };\r\n__u32 divisor;\r\nint divisor3;\r\ndivisor3 = base * 8 / (baud * 10);\r\ndivisor = divisor3 >> 3;\r\ndivisor |= (__u32)divfrac[divisor3 & 0x7] << 14;\r\nif (divisor == 1)\r\ndivisor = 0;\r\nelse if (divisor == 0x4001)\r\ndivisor = 1;\r\ndivisor |= 0x00020000;\r\nreturn divisor;\r\n}\r\nstatic __u32 ftdi_2232h_baud_to_divisor(int baud)\r\n{\r\nreturn ftdi_2232h_baud_base_to_divisor(baud, 120000000);\r\n}\r\nstatic int update_mctrl(struct usb_serial_port *port, unsigned int set,\r\nunsigned int clear)\r\n{\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nstruct device *dev = &port->dev;\r\nunsigned urb_value;\r\nint rv;\r\nif (((set | clear) & (TIOCM_DTR | TIOCM_RTS)) == 0) {\r\ndev_dbg(dev, "%s - DTR|RTS not being set|cleared\n", __func__);\r\nreturn 0;\r\n}\r\nclear &= ~set;\r\nurb_value = 0;\r\nif (clear & TIOCM_DTR)\r\nurb_value |= FTDI_SIO_SET_DTR_LOW;\r\nif (clear & TIOCM_RTS)\r\nurb_value |= FTDI_SIO_SET_RTS_LOW;\r\nif (set & TIOCM_DTR)\r\nurb_value |= FTDI_SIO_SET_DTR_HIGH;\r\nif (set & TIOCM_RTS)\r\nurb_value |= FTDI_SIO_SET_RTS_HIGH;\r\nrv = usb_control_msg(port->serial->dev,\r\nusb_sndctrlpipe(port->serial->dev, 0),\r\nFTDI_SIO_SET_MODEM_CTRL_REQUEST,\r\nFTDI_SIO_SET_MODEM_CTRL_REQUEST_TYPE,\r\nurb_value, priv->interface,\r\nNULL, 0, WDR_TIMEOUT);\r\nif (rv < 0) {\r\ndev_dbg(dev, "%s Error from MODEM_CTRL urb: DTR %s, RTS %s\n",\r\n__func__,\r\n(set & TIOCM_DTR) ? "HIGH" : (clear & TIOCM_DTR) ? "LOW" : "unchanged",\r\n(set & TIOCM_RTS) ? "HIGH" : (clear & TIOCM_RTS) ? "LOW" : "unchanged");\r\nrv = usb_translate_errors(rv);\r\n} else {\r\ndev_dbg(dev, "%s - DTR %s, RTS %s\n", __func__,\r\n(set & TIOCM_DTR) ? "HIGH" : (clear & TIOCM_DTR) ? "LOW" : "unchanged",\r\n(set & TIOCM_RTS) ? "HIGH" : (clear & TIOCM_RTS) ? "LOW" : "unchanged");\r\npriv->last_dtr_rts = (priv->last_dtr_rts & ~clear) | set;\r\n}\r\nreturn rv;\r\n}\r\nstatic __u32 get_ftdi_divisor(struct tty_struct *tty,\r\nstruct usb_serial_port *port)\r\n{\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nstruct device *dev = &port->dev;\r\n__u32 div_value = 0;\r\nint div_okay = 1;\r\nint baud;\r\nbaud = tty_get_baud_rate(tty);\r\ndev_dbg(dev, "%s - tty_get_baud_rate reports speed %d\n", __func__, baud);\r\nif (baud == 38400 &&\r\n((priv->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST) &&\r\n(priv->custom_divisor)) {\r\nbaud = priv->baud_base / priv->custom_divisor;\r\ndev_dbg(dev, "%s - custom divisor %d sets baud rate to %d\n",\r\n__func__, priv->custom_divisor, baud);\r\n}\r\nif (!baud)\r\nbaud = 9600;\r\nswitch (priv->chip_type) {\r\ncase SIO:\r\nswitch (baud) {\r\ncase 300: div_value = ftdi_sio_b300; break;\r\ncase 600: div_value = ftdi_sio_b600; break;\r\ncase 1200: div_value = ftdi_sio_b1200; break;\r\ncase 2400: div_value = ftdi_sio_b2400; break;\r\ncase 4800: div_value = ftdi_sio_b4800; break;\r\ncase 9600: div_value = ftdi_sio_b9600; break;\r\ncase 19200: div_value = ftdi_sio_b19200; break;\r\ncase 38400: div_value = ftdi_sio_b38400; break;\r\ncase 57600: div_value = ftdi_sio_b57600; break;\r\ncase 115200: div_value = ftdi_sio_b115200; break;\r\n}\r\nif (div_value == 0) {\r\ndev_dbg(dev, "%s - Baudrate (%d) requested is not supported\n",\r\n__func__, baud);\r\ndiv_value = ftdi_sio_b9600;\r\nbaud = 9600;\r\ndiv_okay = 0;\r\n}\r\nbreak;\r\ncase FT8U232AM:\r\nif (baud <= 3000000) {\r\ndiv_value = ftdi_232am_baud_to_divisor(baud);\r\n} else {\r\ndev_dbg(dev, "%s - Baud rate too high!\n", __func__);\r\nbaud = 9600;\r\ndiv_value = ftdi_232am_baud_to_divisor(9600);\r\ndiv_okay = 0;\r\n}\r\nbreak;\r\ncase FT232BM:\r\ncase FT2232C:\r\ncase FT232RL:\r\ncase FTX:\r\nif (baud <= 3000000) {\r\n__u16 product_id = le16_to_cpu(\r\nport->serial->dev->descriptor.idProduct);\r\nif (((FTDI_NDI_HUC_PID == product_id) ||\r\n(FTDI_NDI_SPECTRA_SCU_PID == product_id) ||\r\n(FTDI_NDI_FUTURE_2_PID == product_id) ||\r\n(FTDI_NDI_FUTURE_3_PID == product_id) ||\r\n(FTDI_NDI_AURORA_SCU_PID == product_id)) &&\r\n(baud == 19200)) {\r\nbaud = 1200000;\r\n}\r\ndiv_value = ftdi_232bm_baud_to_divisor(baud);\r\n} else {\r\ndev_dbg(dev, "%s - Baud rate too high!\n", __func__);\r\ndiv_value = ftdi_232bm_baud_to_divisor(9600);\r\ndiv_okay = 0;\r\nbaud = 9600;\r\n}\r\nbreak;\r\ncase FT2232H:\r\ncase FT4232H:\r\ncase FT232H:\r\nif ((baud <= 12000000) && (baud >= 1200)) {\r\ndiv_value = ftdi_2232h_baud_to_divisor(baud);\r\n} else if (baud < 1200) {\r\ndiv_value = ftdi_232bm_baud_to_divisor(baud);\r\n} else {\r\ndev_dbg(dev, "%s - Baud rate too high!\n", __func__);\r\ndiv_value = ftdi_232bm_baud_to_divisor(9600);\r\ndiv_okay = 0;\r\nbaud = 9600;\r\n}\r\nbreak;\r\n}\r\nif (div_okay) {\r\ndev_dbg(dev, "%s - Baud rate set to %d (divisor 0x%lX) on chip %s\n",\r\n__func__, baud, (unsigned long)div_value,\r\nftdi_chip_name[priv->chip_type]);\r\n}\r\ntty_encode_baud_rate(tty, baud, baud);\r\nreturn div_value;\r\n}\r\nstatic int change_speed(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\n__u16 urb_value;\r\n__u16 urb_index;\r\n__u32 urb_index_value;\r\nint rv;\r\nurb_index_value = get_ftdi_divisor(tty, port);\r\nurb_value = (__u16)urb_index_value;\r\nurb_index = (__u16)(urb_index_value >> 16);\r\nif ((priv->chip_type == FT2232C) || (priv->chip_type == FT2232H) ||\r\n(priv->chip_type == FT4232H) || (priv->chip_type == FT232H)) {\r\nurb_index = (__u16)((urb_index << 8) | priv->interface);\r\n}\r\nrv = usb_control_msg(port->serial->dev,\r\nusb_sndctrlpipe(port->serial->dev, 0),\r\nFTDI_SIO_SET_BAUDRATE_REQUEST,\r\nFTDI_SIO_SET_BAUDRATE_REQUEST_TYPE,\r\nurb_value, urb_index,\r\nNULL, 0, WDR_SHORT_TIMEOUT);\r\nreturn rv;\r\n}\r\nstatic int write_latency_timer(struct usb_serial_port *port)\r\n{\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nstruct usb_device *udev = port->serial->dev;\r\nint rv;\r\nint l = priv->latency;\r\nif (priv->flags & ASYNC_LOW_LATENCY)\r\nl = 1;\r\ndev_dbg(&port->dev, "%s: setting latency timer = %i\n", __func__, l);\r\nrv = usb_control_msg(udev,\r\nusb_sndctrlpipe(udev, 0),\r\nFTDI_SIO_SET_LATENCY_TIMER_REQUEST,\r\nFTDI_SIO_SET_LATENCY_TIMER_REQUEST_TYPE,\r\nl, priv->interface,\r\nNULL, 0, WDR_TIMEOUT);\r\nif (rv < 0)\r\ndev_err(&port->dev, "Unable to write latency timer: %i\n", rv);\r\nreturn rv;\r\n}\r\nstatic int read_latency_timer(struct usb_serial_port *port)\r\n{\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nstruct usb_device *udev = port->serial->dev;\r\nunsigned char *buf;\r\nint rv;\r\nbuf = kmalloc(1, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nrv = usb_control_msg(udev,\r\nusb_rcvctrlpipe(udev, 0),\r\nFTDI_SIO_GET_LATENCY_TIMER_REQUEST,\r\nFTDI_SIO_GET_LATENCY_TIMER_REQUEST_TYPE,\r\n0, priv->interface,\r\nbuf, 1, WDR_TIMEOUT);\r\nif (rv < 0)\r\ndev_err(&port->dev, "Unable to read latency timer: %i\n", rv);\r\nelse\r\npriv->latency = buf[0];\r\nkfree(buf);\r\nreturn rv;\r\n}\r\nstatic int get_serial_info(struct usb_serial_port *port,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nstruct serial_struct tmp;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.flags = priv->flags;\r\ntmp.baud_base = priv->baud_base;\r\ntmp.custom_divisor = priv->custom_divisor;\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int set_serial_info(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct serial_struct __user *newinfo)\r\n{\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nstruct serial_struct new_serial;\r\nstruct ftdi_private old_priv;\r\nif (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))\r\nreturn -EFAULT;\r\nmutex_lock(&priv->cfg_lock);\r\nold_priv = *priv;\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nif (((new_serial.flags & ~ASYNC_USR_MASK) !=\r\n(priv->flags & ~ASYNC_USR_MASK))) {\r\nmutex_unlock(&priv->cfg_lock);\r\nreturn -EPERM;\r\n}\r\npriv->flags = ((priv->flags & ~ASYNC_USR_MASK) |\r\n(new_serial.flags & ASYNC_USR_MASK));\r\npriv->custom_divisor = new_serial.custom_divisor;\r\ngoto check_and_exit;\r\n}\r\nif (new_serial.baud_base != priv->baud_base) {\r\nmutex_unlock(&priv->cfg_lock);\r\nreturn -EINVAL;\r\n}\r\npriv->flags = ((priv->flags & ~ASYNC_FLAGS) |\r\n(new_serial.flags & ASYNC_FLAGS));\r\npriv->custom_divisor = new_serial.custom_divisor;\r\nwrite_latency_timer(port);\r\ncheck_and_exit:\r\nif ((old_priv.flags & ASYNC_SPD_MASK) !=\r\n(priv->flags & ASYNC_SPD_MASK)) {\r\nif ((priv->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)\r\ntty->alt_speed = 57600;\r\nelse if ((priv->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)\r\ntty->alt_speed = 115200;\r\nelse if ((priv->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)\r\ntty->alt_speed = 230400;\r\nelse if ((priv->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)\r\ntty->alt_speed = 460800;\r\nelse\r\ntty->alt_speed = 0;\r\n}\r\nif (((old_priv.flags & ASYNC_SPD_MASK) !=\r\n(priv->flags & ASYNC_SPD_MASK)) ||\r\n(((priv->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST) &&\r\n(old_priv.custom_divisor != priv->custom_divisor))) {\r\nchange_speed(tty, port);\r\nmutex_unlock(&priv->cfg_lock);\r\n}\r\nelse\r\nmutex_unlock(&priv->cfg_lock);\r\nreturn 0;\r\n}\r\nstatic int get_lsr_info(struct usb_serial_port *port,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nunsigned int result = 0;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nif (priv->transmit_empty)\r\nresult = TIOCSER_TEMT;\r\nif (copy_to_user(retinfo, &result, sizeof(unsigned int)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void ftdi_determine_type(struct usb_serial_port *port)\r\n{\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nstruct usb_serial *serial = port->serial;\r\nstruct usb_device *udev = serial->dev;\r\nunsigned version;\r\nunsigned interfaces;\r\npriv->baud_base = 48000000 / 2;\r\nversion = le16_to_cpu(udev->descriptor.bcdDevice);\r\ninterfaces = udev->actconfig->desc.bNumInterfaces;\r\ndev_dbg(&port->dev, "%s: bcdDevice = 0x%x, bNumInterfaces = %u\n", __func__,\r\nversion, interfaces);\r\nif (interfaces > 1) {\r\nint inter;\r\nif (version == 0x0800) {\r\npriv->chip_type = FT4232H;\r\npriv->baud_base = 120000000 / 2;\r\n} else if (version == 0x0700) {\r\npriv->chip_type = FT2232H;\r\npriv->baud_base = 120000000 / 2;\r\n} else\r\npriv->chip_type = FT2232C;\r\ninter = serial->interface->altsetting->desc.bInterfaceNumber;\r\nif (inter == 0) {\r\npriv->interface = INTERFACE_A;\r\n} else if (inter == 1) {\r\npriv->interface = INTERFACE_B;\r\n} else if (inter == 2) {\r\npriv->interface = INTERFACE_C;\r\n} else if (inter == 3) {\r\npriv->interface = INTERFACE_D;\r\n}\r\nif (version < 0x500) {\r\ndev_dbg(&port->dev,\r\n"%s: something fishy - bcdDevice too low for multi-interface device\n",\r\n__func__);\r\n}\r\n} else if (version < 0x200) {\r\npriv->chip_type = SIO;\r\npriv->baud_base = 12000000 / 16;\r\n} else if (version < 0x400) {\r\npriv->chip_type = FT8U232AM;\r\n} else if (version < 0x600) {\r\npriv->chip_type = FT232BM;\r\n} else if (version < 0x900) {\r\npriv->chip_type = FT232RL;\r\n} else if (version < 0x1000) {\r\npriv->chip_type = FT232H;\r\n} else {\r\npriv->chip_type = FTX;\r\n}\r\ndev_info(&udev->dev, "Detected %s\n", ftdi_chip_name[priv->chip_type]);\r\n}\r\nstatic void ftdi_set_max_packet_size(struct usb_serial_port *port)\r\n{\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nstruct usb_interface *interface = port->serial->interface;\r\nstruct usb_endpoint_descriptor *ep_desc;\r\nunsigned num_endpoints;\r\nunsigned i;\r\nnum_endpoints = interface->cur_altsetting->desc.bNumEndpoints;\r\nif (!num_endpoints)\r\nreturn;\r\nfor (i = 0; i < num_endpoints; i++) {\r\nep_desc = &interface->cur_altsetting->endpoint[i].desc;\r\nif (!ep_desc->wMaxPacketSize) {\r\nep_desc->wMaxPacketSize = cpu_to_le16(0x40);\r\ndev_warn(&port->dev, "Overriding wMaxPacketSize on endpoint %d\n",\r\nusb_endpoint_num(ep_desc));\r\n}\r\n}\r\npriv->max_packet_size = usb_endpoint_maxp(ep_desc);\r\n}\r\nstatic ssize_t latency_timer_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_serial_port *port = to_usb_serial_port(dev);\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nif (priv->flags & ASYNC_LOW_LATENCY)\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "%i\n", priv->latency);\r\n}\r\nstatic ssize_t latency_timer_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *valbuf, size_t count)\r\n{\r\nstruct usb_serial_port *port = to_usb_serial_port(dev);\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nint v = simple_strtoul(valbuf, NULL, 10);\r\nint rv;\r\npriv->latency = v;\r\nrv = write_latency_timer(port);\r\nif (rv < 0)\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic ssize_t store_event_char(struct device *dev,\r\nstruct device_attribute *attr, const char *valbuf, size_t count)\r\n{\r\nstruct usb_serial_port *port = to_usb_serial_port(dev);\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nstruct usb_device *udev = port->serial->dev;\r\nint v = simple_strtoul(valbuf, NULL, 10);\r\nint rv;\r\ndev_dbg(&port->dev, "%s: setting event char = %i\n", __func__, v);\r\nrv = usb_control_msg(udev,\r\nusb_sndctrlpipe(udev, 0),\r\nFTDI_SIO_SET_EVENT_CHAR_REQUEST,\r\nFTDI_SIO_SET_EVENT_CHAR_REQUEST_TYPE,\r\nv, priv->interface,\r\nNULL, 0, WDR_TIMEOUT);\r\nif (rv < 0) {\r\ndev_dbg(&port->dev, "Unable to write event character: %i\n", rv);\r\nreturn -EIO;\r\n}\r\nreturn count;\r\n}\r\nstatic int create_sysfs_attrs(struct usb_serial_port *port)\r\n{\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nint retval = 0;\r\nif (priv->chip_type != SIO) {\r\ndev_dbg(&port->dev, "sysfs attributes for %s\n", ftdi_chip_name[priv->chip_type]);\r\nretval = device_create_file(&port->dev, &dev_attr_event_char);\r\nif ((!retval) &&\r\n(priv->chip_type == FT232BM ||\r\npriv->chip_type == FT2232C ||\r\npriv->chip_type == FT232RL ||\r\npriv->chip_type == FT2232H ||\r\npriv->chip_type == FT4232H ||\r\npriv->chip_type == FT232H ||\r\npriv->chip_type == FTX)) {\r\nretval = device_create_file(&port->dev,\r\n&dev_attr_latency_timer);\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic void remove_sysfs_attrs(struct usb_serial_port *port)\r\n{\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nif (priv->chip_type != SIO) {\r\ndevice_remove_file(&port->dev, &dev_attr_event_char);\r\nif (priv->chip_type == FT232BM ||\r\npriv->chip_type == FT2232C ||\r\npriv->chip_type == FT232RL ||\r\npriv->chip_type == FT2232H ||\r\npriv->chip_type == FT4232H ||\r\npriv->chip_type == FT232H ||\r\npriv->chip_type == FTX) {\r\ndevice_remove_file(&port->dev, &dev_attr_latency_timer);\r\n}\r\n}\r\n}\r\nstatic int ftdi_sio_probe(struct usb_serial *serial,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct ftdi_sio_quirk *quirk =\r\n(struct ftdi_sio_quirk *)id->driver_info;\r\nif (quirk && quirk->probe) {\r\nint ret = quirk->probe(serial);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nusb_set_serial_data(serial, (void *)id->driver_info);\r\nreturn 0;\r\n}\r\nstatic int ftdi_sio_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct ftdi_private *priv;\r\nstruct ftdi_sio_quirk *quirk = usb_get_serial_data(port->serial);\r\npriv = kzalloc(sizeof(struct ftdi_private), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nmutex_init(&priv->cfg_lock);\r\npriv->flags = ASYNC_LOW_LATENCY;\r\nif (quirk && quirk->port_probe)\r\nquirk->port_probe(priv);\r\nusb_set_serial_port_data(port, priv);\r\nftdi_determine_type(port);\r\nftdi_set_max_packet_size(port);\r\nif (read_latency_timer(port) < 0)\r\npriv->latency = 16;\r\nwrite_latency_timer(port);\r\ncreate_sysfs_attrs(port);\r\nreturn 0;\r\n}\r\nstatic void ftdi_USB_UIRT_setup(struct ftdi_private *priv)\r\n{\r\npriv->flags |= ASYNC_SPD_CUST;\r\npriv->custom_divisor = 77;\r\npriv->force_baud = 38400;\r\n}\r\nstatic void ftdi_HE_TIRA1_setup(struct ftdi_private *priv)\r\n{\r\npriv->flags |= ASYNC_SPD_CUST;\r\npriv->custom_divisor = 240;\r\npriv->force_baud = 38400;\r\npriv->force_rtscts = 1;\r\n}\r\nstatic int ftdi_NDI_device_setup(struct usb_serial *serial)\r\n{\r\nstruct usb_device *udev = serial->dev;\r\nint latency = ndi_latency_timer;\r\nif (latency == 0)\r\nlatency = 1;\r\nif (latency > 99)\r\nlatency = 99;\r\ndev_dbg(&udev->dev, "%s setting NDI device latency to %d\n", __func__, latency);\r\ndev_info(&udev->dev, "NDI device with a latency value of %d\n", latency);\r\nusb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nFTDI_SIO_SET_LATENCY_TIMER_REQUEST,\r\nFTDI_SIO_SET_LATENCY_TIMER_REQUEST_TYPE,\r\nlatency, 0, NULL, 0, WDR_TIMEOUT);\r\nreturn 0;\r\n}\r\nstatic int ftdi_jtag_probe(struct usb_serial *serial)\r\n{\r\nstruct usb_device *udev = serial->dev;\r\nstruct usb_interface *interface = serial->interface;\r\nif (interface == udev->actconfig->interface[0]) {\r\ndev_info(&udev->dev,\r\n"Ignoring serial port reserved for JTAG\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ftdi_8u2232c_probe(struct usb_serial *serial)\r\n{\r\nstruct usb_device *udev = serial->dev;\r\nif (udev->manufacturer && !strcmp(udev->manufacturer, "CALAO Systems"))\r\nreturn ftdi_jtag_probe(serial);\r\nif (udev->product &&\r\n(!strcmp(udev->product, "BeagleBone/XDS100V2") ||\r\n!strcmp(udev->product, "SNAP Connect E10")))\r\nreturn ftdi_jtag_probe(serial);\r\nreturn 0;\r\n}\r\nstatic int ftdi_stmclite_probe(struct usb_serial *serial)\r\n{\r\nstruct usb_device *udev = serial->dev;\r\nstruct usb_interface *interface = serial->interface;\r\nif (interface == udev->actconfig->interface[0] ||\r\ninterface == udev->actconfig->interface[1]) {\r\ndev_info(&udev->dev, "Ignoring serial port reserved for JTAG\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ftdi_sio_port_remove(struct usb_serial_port *port)\r\n{\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nremove_sysfs_attrs(port);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int ftdi_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nusb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nFTDI_SIO_RESET_REQUEST, FTDI_SIO_RESET_REQUEST_TYPE,\r\nFTDI_SIO_RESET_SIO,\r\npriv->interface, NULL, 0, WDR_TIMEOUT);\r\nif (tty)\r\nftdi_set_termios(tty, port, NULL);\r\nreturn usb_serial_generic_open(tty, port);\r\n}\r\nstatic void ftdi_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nif (!on) {\r\nif (usb_control_msg(port->serial->dev,\r\nusb_sndctrlpipe(port->serial->dev, 0),\r\nFTDI_SIO_SET_FLOW_CTRL_REQUEST,\r\nFTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,\r\n0, priv->interface, NULL, 0,\r\nWDR_TIMEOUT) < 0) {\r\ndev_err(&port->dev, "error from flowcontrol urb\n");\r\n}\r\n}\r\nif (on)\r\nset_mctrl(port, TIOCM_DTR | TIOCM_RTS);\r\nelse\r\nclear_mctrl(port, TIOCM_DTR | TIOCM_RTS);\r\n}\r\nstatic int ftdi_prepare_write_buffer(struct usb_serial_port *port,\r\nvoid *dest, size_t size)\r\n{\r\nstruct ftdi_private *priv;\r\nint count;\r\nunsigned long flags;\r\npriv = usb_get_serial_port_data(port);\r\nif (priv->chip_type == SIO) {\r\nunsigned char *buffer = dest;\r\nint i, len, c;\r\ncount = 0;\r\nspin_lock_irqsave(&port->lock, flags);\r\nfor (i = 0; i < size - 1; i += priv->max_packet_size) {\r\nlen = min_t(int, size - i, priv->max_packet_size) - 1;\r\nc = kfifo_out(&port->write_fifo, &buffer[i + 1], len);\r\nif (!c)\r\nbreak;\r\nport->icount.tx += c;\r\nbuffer[i] = (c << 2) + 1;\r\ncount += c + 1;\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n} else {\r\ncount = kfifo_out_locked(&port->write_fifo, dest, size,\r\n&port->lock);\r\nport->icount.tx += count;\r\n}\r\nreturn count;\r\n}\r\nstatic int ftdi_process_packet(struct usb_serial_port *port,\r\nstruct ftdi_private *priv, char *packet, int len)\r\n{\r\nint i;\r\nchar status;\r\nchar flag;\r\nchar *ch;\r\nif (len < 2) {\r\ndev_dbg(&port->dev, "malformed packet\n");\r\nreturn 0;\r\n}\r\nstatus = packet[0] & FTDI_STATUS_B0_MASK;\r\nif (status != priv->prev_status) {\r\nchar diff_status = status ^ priv->prev_status;\r\nif (diff_status & FTDI_RS0_CTS)\r\nport->icount.cts++;\r\nif (diff_status & FTDI_RS0_DSR)\r\nport->icount.dsr++;\r\nif (diff_status & FTDI_RS0_RI)\r\nport->icount.rng++;\r\nif (diff_status & FTDI_RS0_RLSD) {\r\nstruct tty_struct *tty;\r\nport->icount.dcd++;\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty)\r\nusb_serial_handle_dcd_change(port, tty,\r\nstatus & FTDI_RS0_RLSD);\r\ntty_kref_put(tty);\r\n}\r\nwake_up_interruptible(&port->port.delta_msr_wait);\r\npriv->prev_status = status;\r\n}\r\nflag = TTY_NORMAL;\r\nif (packet[1] & FTDI_RS_ERR_MASK) {\r\nif (packet[1] & FTDI_RS_BI) {\r\nflag = TTY_BREAK;\r\nport->icount.brk++;\r\nusb_serial_handle_break(port);\r\n} else if (packet[1] & FTDI_RS_PE) {\r\nflag = TTY_PARITY;\r\nport->icount.parity++;\r\n} else if (packet[1] & FTDI_RS_FE) {\r\nflag = TTY_FRAME;\r\nport->icount.frame++;\r\n}\r\nif (packet[1] & FTDI_RS_OE) {\r\nport->icount.overrun++;\r\ntty_insert_flip_char(&port->port, 0, TTY_OVERRUN);\r\n}\r\n}\r\nif (packet[1] & FTDI_RS_TEMT)\r\npriv->transmit_empty = 1;\r\nelse\r\npriv->transmit_empty = 0;\r\nlen -= 2;\r\nif (!len)\r\nreturn 0;\r\nport->icount.rx += len;\r\nch = packet + 2;\r\nif (port->port.console && port->sysrq) {\r\nfor (i = 0; i < len; i++, ch++) {\r\nif (!usb_serial_handle_sysrq_char(port, *ch))\r\ntty_insert_flip_char(&port->port, *ch, flag);\r\n}\r\n} else {\r\ntty_insert_flip_string_fixed_flag(&port->port, ch, flag, len);\r\n}\r\nreturn len;\r\n}\r\nstatic void ftdi_process_read_urb(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nchar *data = (char *)urb->transfer_buffer;\r\nint i;\r\nint len;\r\nint count = 0;\r\nfor (i = 0; i < urb->actual_length; i += priv->max_packet_size) {\r\nlen = min_t(int, urb->actual_length - i, priv->max_packet_size);\r\ncount += ftdi_process_packet(port, priv, &data[i], len);\r\n}\r\nif (count)\r\ntty_flip_buffer_push(&port->port);\r\n}\r\nstatic void ftdi_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\n__u16 urb_value;\r\nif (break_state)\r\nurb_value = priv->last_set_data_urb_value | FTDI_SIO_SET_BREAK;\r\nelse\r\nurb_value = priv->last_set_data_urb_value;\r\nif (usb_control_msg(port->serial->dev,\r\nusb_sndctrlpipe(port->serial->dev, 0),\r\nFTDI_SIO_SET_DATA_REQUEST,\r\nFTDI_SIO_SET_DATA_REQUEST_TYPE,\r\nurb_value , priv->interface,\r\nNULL, 0, WDR_TIMEOUT) < 0) {\r\ndev_err(&port->dev, "%s FAILED to enable/disable break state (state was %d)\n",\r\n__func__, break_state);\r\n}\r\ndev_dbg(&port->dev, "%s break state is %d - urb is %d\n", __func__,\r\nbreak_state, urb_value);\r\n}\r\nstatic bool ftdi_tx_empty(struct usb_serial_port *port)\r\n{\r\nunsigned char buf[2];\r\nint ret;\r\nret = ftdi_get_modem_status(port, buf);\r\nif (ret == 2) {\r\nif (!(buf[1] & FTDI_RS_TEMT))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void ftdi_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nstruct device *ddev = &port->dev;\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nstruct ktermios *termios = &tty->termios;\r\nunsigned int cflag = termios->c_cflag;\r\n__u16 urb_value;\r\nunsigned int iflag = termios->c_iflag;\r\nunsigned char vstop;\r\nunsigned char vstart;\r\nif (priv->force_baud && ((termios->c_cflag & CBAUD) != B0)) {\r\ndev_dbg(ddev, "%s: forcing baud rate for this device\n", __func__);\r\ntty_encode_baud_rate(tty, priv->force_baud,\r\npriv->force_baud);\r\n}\r\nif (priv->force_rtscts) {\r\ndev_dbg(ddev, "%s: forcing rtscts for this device\n", __func__);\r\ntermios->c_cflag |= CRTSCTS;\r\n}\r\nif (C_CSIZE(tty) == CS6) {\r\ndev_warn(ddev, "requested CSIZE setting not supported\n");\r\ntermios->c_cflag &= ~CSIZE;\r\nif (old_termios)\r\ntermios->c_cflag |= old_termios->c_cflag & CSIZE;\r\nelse\r\ntermios->c_cflag |= CS8;\r\n}\r\ncflag = termios->c_cflag;\r\nif (!old_termios)\r\ngoto no_skip;\r\nif (old_termios->c_cflag == termios->c_cflag\r\n&& old_termios->c_ispeed == termios->c_ispeed\r\n&& old_termios->c_ospeed == termios->c_ospeed)\r\ngoto no_c_cflag_changes;\r\nif ((old_termios->c_cflag & (CSIZE|PARODD|PARENB|CMSPAR|CSTOPB)) ==\r\n(termios->c_cflag & (CSIZE|PARODD|PARENB|CMSPAR|CSTOPB)))\r\ngoto no_data_parity_stop_changes;\r\nno_skip:\r\nurb_value = 0;\r\nurb_value |= (cflag & CSTOPB ? FTDI_SIO_SET_DATA_STOP_BITS_2 :\r\nFTDI_SIO_SET_DATA_STOP_BITS_1);\r\nif (cflag & PARENB) {\r\nif (cflag & CMSPAR)\r\nurb_value |= cflag & PARODD ?\r\nFTDI_SIO_SET_DATA_PARITY_MARK :\r\nFTDI_SIO_SET_DATA_PARITY_SPACE;\r\nelse\r\nurb_value |= cflag & PARODD ?\r\nFTDI_SIO_SET_DATA_PARITY_ODD :\r\nFTDI_SIO_SET_DATA_PARITY_EVEN;\r\n} else {\r\nurb_value |= FTDI_SIO_SET_DATA_PARITY_NONE;\r\n}\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\ndev_dbg(ddev, "Setting CS5 quirk\n");\r\nbreak;\r\ncase CS7:\r\nurb_value |= 7;\r\ndev_dbg(ddev, "Setting CS7\n");\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nurb_value |= 8;\r\ndev_dbg(ddev, "Setting CS8\n");\r\nbreak;\r\n}\r\npriv->last_set_data_urb_value = urb_value;\r\nif (usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nFTDI_SIO_SET_DATA_REQUEST,\r\nFTDI_SIO_SET_DATA_REQUEST_TYPE,\r\nurb_value , priv->interface,\r\nNULL, 0, WDR_SHORT_TIMEOUT) < 0) {\r\ndev_err(ddev, "%s FAILED to set databits/stopbits/parity\n",\r\n__func__);\r\n}\r\nno_data_parity_stop_changes:\r\nif ((cflag & CBAUD) == B0) {\r\nif (usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nFTDI_SIO_SET_FLOW_CTRL_REQUEST,\r\nFTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,\r\n0, priv->interface,\r\nNULL, 0, WDR_TIMEOUT) < 0) {\r\ndev_err(ddev, "%s error from disable flowcontrol urb\n",\r\n__func__);\r\n}\r\nclear_mctrl(port, TIOCM_DTR | TIOCM_RTS);\r\n} else {\r\nmutex_lock(&priv->cfg_lock);\r\nif (change_speed(tty, port))\r\ndev_err(ddev, "%s urb failed to set baudrate\n", __func__);\r\nmutex_unlock(&priv->cfg_lock);\r\nif (old_termios && (old_termios->c_cflag & CBAUD) == B0)\r\nset_mctrl(port, TIOCM_DTR | TIOCM_RTS);\r\n}\r\nno_c_cflag_changes:\r\nif (cflag & CRTSCTS) {\r\ndev_dbg(ddev, "%s Setting to CRTSCTS flow control\n", __func__);\r\nif (usb_control_msg(dev,\r\nusb_sndctrlpipe(dev, 0),\r\nFTDI_SIO_SET_FLOW_CTRL_REQUEST,\r\nFTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,\r\n0 , (FTDI_SIO_RTS_CTS_HS | priv->interface),\r\nNULL, 0, WDR_TIMEOUT) < 0) {\r\ndev_err(ddev, "urb failed to set to rts/cts flow control\n");\r\n}\r\n} else {\r\nif (iflag & IXOFF) {\r\ndev_dbg(ddev, "%s request to enable xonxoff iflag=%04x\n",\r\n__func__, iflag);\r\nvstart = termios->c_cc[VSTART];\r\nvstop = termios->c_cc[VSTOP];\r\nurb_value = (vstop << 8) | (vstart);\r\nif (usb_control_msg(dev,\r\nusb_sndctrlpipe(dev, 0),\r\nFTDI_SIO_SET_FLOW_CTRL_REQUEST,\r\nFTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,\r\nurb_value , (FTDI_SIO_XON_XOFF_HS\r\n| priv->interface),\r\nNULL, 0, WDR_TIMEOUT) < 0) {\r\ndev_err(&port->dev, "urb failed to set to "\r\n"xon/xoff flow control\n");\r\n}\r\n} else {\r\ndev_dbg(ddev, "%s Turning off hardware flow control\n", __func__);\r\nif (usb_control_msg(dev,\r\nusb_sndctrlpipe(dev, 0),\r\nFTDI_SIO_SET_FLOW_CTRL_REQUEST,\r\nFTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,\r\n0, priv->interface,\r\nNULL, 0, WDR_TIMEOUT) < 0) {\r\ndev_err(ddev, "urb failed to clear flow control\n");\r\n}\r\n}\r\n}\r\n}\r\nstatic int ftdi_get_modem_status(struct usb_serial_port *port,\r\nunsigned char status[2])\r\n{\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nunsigned char *buf;\r\nint len;\r\nint ret;\r\nbuf = kmalloc(2, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nswitch (priv->chip_type) {\r\ncase SIO:\r\nlen = 1;\r\nbreak;\r\ncase FT8U232AM:\r\ncase FT232BM:\r\ncase FT2232C:\r\ncase FT232RL:\r\ncase FT2232H:\r\ncase FT4232H:\r\ncase FT232H:\r\ncase FTX:\r\nlen = 2;\r\nbreak;\r\ndefault:\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nret = usb_control_msg(port->serial->dev,\r\nusb_rcvctrlpipe(port->serial->dev, 0),\r\nFTDI_SIO_GET_MODEM_STATUS_REQUEST,\r\nFTDI_SIO_GET_MODEM_STATUS_REQUEST_TYPE,\r\n0, priv->interface,\r\nbuf, len, WDR_TIMEOUT);\r\nif (ret < 0) {\r\ndev_err(&port->dev, "failed to get modem status: %d\n", ret);\r\nret = usb_translate_errors(ret);\r\ngoto out;\r\n}\r\nstatus[0] = buf[0];\r\nif (ret > 1)\r\nstatus[1] = buf[1];\r\nelse\r\nstatus[1] = 0;\r\ndev_dbg(&port->dev, "%s - 0x%02x%02x\n", __func__, status[0],\r\nstatus[1]);\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int ftdi_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct ftdi_private *priv = usb_get_serial_port_data(port);\r\nunsigned char buf[2];\r\nint ret;\r\nret = ftdi_get_modem_status(port, buf);\r\nif (ret < 0)\r\nreturn ret;\r\nret = (buf[0] & FTDI_SIO_DSR_MASK ? TIOCM_DSR : 0) |\r\n(buf[0] & FTDI_SIO_CTS_MASK ? TIOCM_CTS : 0) |\r\n(buf[0] & FTDI_SIO_RI_MASK ? TIOCM_RI : 0) |\r\n(buf[0] & FTDI_SIO_RLSD_MASK ? TIOCM_CD : 0) |\r\npriv->last_dtr_rts;\r\nreturn ret;\r\n}\r\nstatic int ftdi_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nreturn update_mctrl(port, set, clear);\r\n}\r\nstatic int ftdi_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nreturn get_serial_info(port,\r\n(struct serial_struct __user *) arg);\r\ncase TIOCSSERIAL:\r\nreturn set_serial_info(tty, port,\r\n(struct serial_struct __user *) arg);\r\ncase TIOCSERGETLSR:\r\nreturn get_lsr_info(port, (struct serial_struct __user *)arg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}
