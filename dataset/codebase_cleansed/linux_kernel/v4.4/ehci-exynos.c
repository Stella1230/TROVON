static int exynos_ehci_get_phy(struct device *dev,\r\nstruct exynos_ehci_hcd *exynos_ehci)\r\n{\r\nstruct device_node *child;\r\nstruct phy *phy;\r\nint phy_number;\r\nint ret;\r\nfor_each_available_child_of_node(dev->of_node, child) {\r\nret = of_property_read_u32(child, "reg", &phy_number);\r\nif (ret) {\r\ndev_err(dev, "Failed to parse device tree\n");\r\nof_node_put(child);\r\nreturn ret;\r\n}\r\nif (phy_number >= PHY_NUMBER) {\r\ndev_err(dev, "Invalid number of PHYs\n");\r\nof_node_put(child);\r\nreturn -EINVAL;\r\n}\r\nphy = devm_of_phy_get(dev, child, NULL);\r\nexynos_ehci->phy[phy_number] = phy;\r\nif (IS_ERR(phy)) {\r\nret = PTR_ERR(phy);\r\nif (ret == -EPROBE_DEFER) {\r\nreturn ret;\r\n} else if (ret != -ENOSYS && ret != -ENODEV) {\r\ndev_err(dev,\r\n"Error retrieving usb2 phy: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos_ehci_phy_enable(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct exynos_ehci_hcd *exynos_ehci = to_exynos_ehci(hcd);\r\nint i;\r\nint ret = 0;\r\nfor (i = 0; ret == 0 && i < PHY_NUMBER; i++)\r\nif (!IS_ERR(exynos_ehci->phy[i]))\r\nret = phy_power_on(exynos_ehci->phy[i]);\r\nif (ret)\r\nfor (i--; i >= 0; i--)\r\nif (!IS_ERR(exynos_ehci->phy[i]))\r\nphy_power_off(exynos_ehci->phy[i]);\r\nreturn ret;\r\n}\r\nstatic void exynos_ehci_phy_disable(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct exynos_ehci_hcd *exynos_ehci = to_exynos_ehci(hcd);\r\nint i;\r\nfor (i = 0; i < PHY_NUMBER; i++)\r\nif (!IS_ERR(exynos_ehci->phy[i]))\r\nphy_power_off(exynos_ehci->phy[i]);\r\n}\r\nstatic void exynos_setup_vbus_gpio(struct device *dev)\r\n{\r\nint err;\r\nint gpio;\r\nif (!dev->of_node)\r\nreturn;\r\ngpio = of_get_named_gpio(dev->of_node, "samsung,vbus-gpio", 0);\r\nif (!gpio_is_valid(gpio))\r\nreturn;\r\nerr = devm_gpio_request_one(dev, gpio, GPIOF_OUT_INIT_HIGH,\r\n"ehci_vbus_gpio");\r\nif (err)\r\ndev_err(dev, "can't request ehci vbus gpio %d", gpio);\r\n}\r\nstatic int exynos_ehci_probe(struct platform_device *pdev)\r\n{\r\nstruct exynos_ehci_hcd *exynos_ehci;\r\nstruct usb_hcd *hcd;\r\nstruct ehci_hcd *ehci;\r\nstruct resource *res;\r\nint irq;\r\nint err;\r\nerr = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\r\nif (err)\r\nreturn err;\r\nexynos_setup_vbus_gpio(&pdev->dev);\r\nhcd = usb_create_hcd(&exynos_ehci_hc_driver,\r\n&pdev->dev, dev_name(&pdev->dev));\r\nif (!hcd) {\r\ndev_err(&pdev->dev, "Unable to create HCD\n");\r\nreturn -ENOMEM;\r\n}\r\nexynos_ehci = to_exynos_ehci(hcd);\r\nif (of_device_is_compatible(pdev->dev.of_node,\r\n"samsung,exynos5440-ehci"))\r\ngoto skip_phy;\r\nerr = exynos_ehci_get_phy(&pdev->dev, exynos_ehci);\r\nif (err)\r\ngoto fail_clk;\r\nskip_phy:\r\nexynos_ehci->clk = devm_clk_get(&pdev->dev, "usbhost");\r\nif (IS_ERR(exynos_ehci->clk)) {\r\ndev_err(&pdev->dev, "Failed to get usbhost clock\n");\r\nerr = PTR_ERR(exynos_ehci->clk);\r\ngoto fail_clk;\r\n}\r\nerr = clk_prepare_enable(exynos_ehci->clk);\r\nif (err)\r\ngoto fail_clk;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhcd->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(hcd->regs)) {\r\nerr = PTR_ERR(hcd->regs);\r\ngoto fail_io;\r\n}\r\nhcd->rsrc_start = res->start;\r\nhcd->rsrc_len = resource_size(res);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "Failed to get IRQ\n");\r\nerr = -ENODEV;\r\ngoto fail_io;\r\n}\r\nerr = exynos_ehci_phy_enable(&pdev->dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to enable USB phy\n");\r\ngoto fail_io;\r\n}\r\nehci = hcd_to_ehci(hcd);\r\nehci->caps = hcd->regs;\r\nwritel(EHCI_INSNREG00_ENABLE_DMA_BURST, EHCI_INSNREG00(hcd->regs));\r\nerr = usb_add_hcd(hcd, irq, IRQF_SHARED);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to add USB HCD\n");\r\ngoto fail_add_hcd;\r\n}\r\ndevice_wakeup_enable(hcd->self.controller);\r\nplatform_set_drvdata(pdev, hcd);\r\nreturn 0;\r\nfail_add_hcd:\r\nexynos_ehci_phy_disable(&pdev->dev);\r\nfail_io:\r\nclk_disable_unprepare(exynos_ehci->clk);\r\nfail_clk:\r\nusb_put_hcd(hcd);\r\nreturn err;\r\n}\r\nstatic int exynos_ehci_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct exynos_ehci_hcd *exynos_ehci = to_exynos_ehci(hcd);\r\nusb_remove_hcd(hcd);\r\nexynos_ehci_phy_disable(&pdev->dev);\r\nclk_disable_unprepare(exynos_ehci->clk);\r\nusb_put_hcd(hcd);\r\nreturn 0;\r\n}\r\nstatic int exynos_ehci_suspend(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct exynos_ehci_hcd *exynos_ehci = to_exynos_ehci(hcd);\r\nbool do_wakeup = device_may_wakeup(dev);\r\nint rc;\r\nrc = ehci_suspend(hcd, do_wakeup);\r\nif (rc)\r\nreturn rc;\r\nexynos_ehci_phy_disable(dev);\r\nclk_disable_unprepare(exynos_ehci->clk);\r\nreturn rc;\r\n}\r\nstatic int exynos_ehci_resume(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct exynos_ehci_hcd *exynos_ehci = to_exynos_ehci(hcd);\r\nint ret;\r\nclk_prepare_enable(exynos_ehci->clk);\r\nret = exynos_ehci_phy_enable(dev);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable USB phy\n");\r\nclk_disable_unprepare(exynos_ehci->clk);\r\nreturn ret;\r\n}\r\nwritel(EHCI_INSNREG00_ENABLE_DMA_BURST, EHCI_INSNREG00(hcd->regs));\r\nehci_resume(hcd, false);\r\nreturn 0;\r\n}\r\nstatic int __init ehci_exynos_init(void)\r\n{\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npr_info("%s: " DRIVER_DESC "\n", hcd_name);\r\nehci_init_driver(&exynos_ehci_hc_driver, &exynos_overrides);\r\nreturn platform_driver_register(&exynos_ehci_driver);\r\n}\r\nstatic void __exit ehci_exynos_cleanup(void)\r\n{\r\nplatform_driver_unregister(&exynos_ehci_driver);\r\n}
