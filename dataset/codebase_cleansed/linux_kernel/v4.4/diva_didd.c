static char *getrev(const char *revision)\r\n{\r\nchar *rev;\r\nchar *p;\r\nif ((p = strchr(revision, ':'))) {\r\nrev = p + 2;\r\np = strchr(rev, '$');\r\n*--p = 0;\r\n} else\r\nrev = "1.0";\r\nreturn rev;\r\n}\r\nstatic int divadidd_proc_show(struct seq_file *m, void *v)\r\n{\r\nchar tmprev[32];\r\nstrcpy(tmprev, main_revision);\r\nseq_printf(m, "%s\n", DRIVERNAME);\r\nseq_printf(m, "name : %s\n", DRIVERLNAME);\r\nseq_printf(m, "release : %s\n", DRIVERRELEASE_DIDD);\r\nseq_printf(m, "build : %s(%s)\n",\r\ndiva_didd_common_code_build, DIVA_BUILD);\r\nseq_printf(m, "revision : %s\n", getrev(tmprev));\r\nreturn 0;\r\n}\r\nstatic int divadidd_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, divadidd_proc_show, NULL);\r\n}\r\nstatic int __init create_proc(void)\r\n{\r\nproc_net_eicon = proc_mkdir("eicon", init_net.proc_net);\r\nif (proc_net_eicon) {\r\nproc_didd = proc_create(DRIVERLNAME, S_IRUGO, proc_net_eicon,\r\n&divadidd_proc_fops);\r\nreturn (1);\r\n}\r\nreturn (0);\r\n}\r\nstatic void remove_proc(void)\r\n{\r\nremove_proc_entry(DRIVERLNAME, proc_net_eicon);\r\nremove_proc_entry("eicon", init_net.proc_net);\r\n}\r\nstatic int __init divadidd_init(void)\r\n{\r\nchar tmprev[32];\r\nint ret = 0;\r\nprintk(KERN_INFO "%s\n", DRIVERNAME);\r\nprintk(KERN_INFO "%s: Rel:%s Rev:", DRIVERLNAME, DRIVERRELEASE_DIDD);\r\nstrcpy(tmprev, main_revision);\r\nprintk("%s Build:%s(%s)\n", getrev(tmprev),\r\ndiva_didd_common_code_build, DIVA_BUILD);\r\nif (!create_proc()) {\r\nprintk(KERN_ERR "%s: could not create proc entry\n",\r\nDRIVERLNAME);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (!diddfunc_init()) {\r\nprintk(KERN_ERR "%s: failed to connect to DIDD.\n",\r\nDRIVERLNAME);\r\n#ifdef MODULE\r\nremove_proc();\r\n#endif\r\nret = -EIO;\r\ngoto out;\r\n}\r\nout:\r\nreturn (ret);\r\n}\r\nstatic void __exit divadidd_exit(void)\r\n{\r\ndiddfunc_finit();\r\nremove_proc();\r\nprintk(KERN_INFO "%s: module unloaded.\n", DRIVERLNAME);\r\n}
