static void ath9k_get_txgain_index(struct ath_hw *ah,\r\nstruct ath9k_channel *chan,\r\nstruct calDataPerFreqOpLoop *rawDatasetOpLoop,\r\nu8 *calChans, u16 availPiers, u8 *pwr, u8 *pcdacIdx)\r\n{\r\nu8 pcdac, i = 0;\r\nu16 idxL = 0, idxR = 0, numPiers;\r\nbool match;\r\nstruct chan_centers centers;\r\nath9k_hw_get_channel_centers(ah, chan, &centers);\r\nfor (numPiers = 0; numPiers < availPiers; numPiers++)\r\nif (calChans[numPiers] == AR5416_BCHAN_UNUSED)\r\nbreak;\r\nmatch = ath9k_hw_get_lower_upper_index(\r\n(u8)FREQ2FBIN(centers.synth_center, IS_CHAN_2GHZ(chan)),\r\ncalChans, numPiers, &idxL, &idxR);\r\nif (match) {\r\npcdac = rawDatasetOpLoop[idxL].pcdac[0][0];\r\n*pwr = rawDatasetOpLoop[idxL].pwrPdg[0][0];\r\n} else {\r\npcdac = rawDatasetOpLoop[idxR].pcdac[0][0];\r\n*pwr = (rawDatasetOpLoop[idxL].pwrPdg[0][0] +\r\nrawDatasetOpLoop[idxR].pwrPdg[0][0])/2;\r\n}\r\nwhile (pcdac > ah->originalGain[i] &&\r\ni < (AR9280_TX_GAIN_TABLE_SIZE - 1))\r\ni++;\r\n*pcdacIdx = i;\r\n}\r\nstatic void ath9k_olc_get_pdadcs(struct ath_hw *ah,\r\nu32 initTxGain,\r\nint txPower,\r\nu8 *pPDADCValues)\r\n{\r\nu32 i;\r\nu32 offset;\r\nREG_RMW_FIELD(ah, AR_PHY_TX_PWRCTRL6_0,\r\nAR_PHY_TX_PWRCTRL_ERR_EST_MODE, 3);\r\nREG_RMW_FIELD(ah, AR_PHY_TX_PWRCTRL6_1,\r\nAR_PHY_TX_PWRCTRL_ERR_EST_MODE, 3);\r\nREG_RMW_FIELD(ah, AR_PHY_TX_PWRCTRL7,\r\nAR_PHY_TX_PWRCTRL_INIT_TX_GAIN, initTxGain);\r\noffset = txPower;\r\nfor (i = 0; i < AR5416_NUM_PDADC_VALUES; i++)\r\nif (i < offset)\r\npPDADCValues[i] = 0x0;\r\nelse\r\npPDADCValues[i] = 0xFF;\r\n}\r\nstatic int ath9k_hw_def_get_eeprom_ver(struct ath_hw *ah)\r\n{\r\nreturn ((ah->eeprom.def.baseEepHeader.version >> 12) & 0xF);\r\n}\r\nstatic int ath9k_hw_def_get_eeprom_rev(struct ath_hw *ah)\r\n{\r\nreturn ((ah->eeprom.def.baseEepHeader.version) & 0xFFF);\r\n}\r\nstatic bool __ath9k_hw_def_fill_eeprom(struct ath_hw *ah)\r\n{\r\nu16 *eep_data = (u16 *)&ah->eeprom.def;\r\nint addr, ar5416_eep_start_loc = 0x100;\r\nfor (addr = 0; addr < SIZE_EEPROM_DEF; addr++) {\r\nif (!ath9k_hw_nvram_read(ah, addr + ar5416_eep_start_loc,\r\neep_data))\r\nreturn false;\r\neep_data++;\r\n}\r\nreturn true;\r\n}\r\nstatic bool __ath9k_hw_usb_def_fill_eeprom(struct ath_hw *ah)\r\n{\r\nu16 *eep_data = (u16 *)&ah->eeprom.def;\r\nath9k_hw_usb_gen_fill_eeprom(ah, eep_data,\r\n0x100, SIZE_EEPROM_DEF);\r\nreturn true;\r\n}\r\nstatic bool ath9k_hw_def_fill_eeprom(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nif (!ath9k_hw_use_flash(ah)) {\r\nath_dbg(common, EEPROM, "Reading from EEPROM, not flash\n");\r\n}\r\nif (common->bus_ops->ath_bus_type == ATH_USB)\r\nreturn __ath9k_hw_usb_def_fill_eeprom(ah);\r\nelse\r\nreturn __ath9k_hw_def_fill_eeprom(ah);\r\n}\r\nstatic u32 ath9k_def_dump_modal_eeprom(char *buf, u32 len, u32 size,\r\nstruct modal_eep_header *modal_hdr)\r\n{\r\nPR_EEP("Chain0 Ant. Control", modal_hdr->antCtrlChain[0]);\r\nPR_EEP("Chain1 Ant. Control", modal_hdr->antCtrlChain[1]);\r\nPR_EEP("Chain2 Ant. Control", modal_hdr->antCtrlChain[2]);\r\nPR_EEP("Ant. Common Control", modal_hdr->antCtrlCommon);\r\nPR_EEP("Chain0 Ant. Gain", modal_hdr->antennaGainCh[0]);\r\nPR_EEP("Chain1 Ant. Gain", modal_hdr->antennaGainCh[1]);\r\nPR_EEP("Chain2 Ant. Gain", modal_hdr->antennaGainCh[2]);\r\nPR_EEP("Switch Settle", modal_hdr->switchSettling);\r\nPR_EEP("Chain0 TxRxAtten", modal_hdr->txRxAttenCh[0]);\r\nPR_EEP("Chain1 TxRxAtten", modal_hdr->txRxAttenCh[1]);\r\nPR_EEP("Chain2 TxRxAtten", modal_hdr->txRxAttenCh[2]);\r\nPR_EEP("Chain0 RxTxMargin", modal_hdr->rxTxMarginCh[0]);\r\nPR_EEP("Chain1 RxTxMargin", modal_hdr->rxTxMarginCh[1]);\r\nPR_EEP("Chain2 RxTxMargin", modal_hdr->rxTxMarginCh[2]);\r\nPR_EEP("ADC Desired size", modal_hdr->adcDesiredSize);\r\nPR_EEP("PGA Desired size", modal_hdr->pgaDesiredSize);\r\nPR_EEP("Chain0 xlna Gain", modal_hdr->xlnaGainCh[0]);\r\nPR_EEP("Chain1 xlna Gain", modal_hdr->xlnaGainCh[1]);\r\nPR_EEP("Chain2 xlna Gain", modal_hdr->xlnaGainCh[2]);\r\nPR_EEP("txEndToXpaOff", modal_hdr->txEndToXpaOff);\r\nPR_EEP("txEndToRxOn", modal_hdr->txEndToRxOn);\r\nPR_EEP("txFrameToXpaOn", modal_hdr->txFrameToXpaOn);\r\nPR_EEP("CCA Threshold)", modal_hdr->thresh62);\r\nPR_EEP("Chain0 NF Threshold", modal_hdr->noiseFloorThreshCh[0]);\r\nPR_EEP("Chain1 NF Threshold", modal_hdr->noiseFloorThreshCh[1]);\r\nPR_EEP("Chain2 NF Threshold", modal_hdr->noiseFloorThreshCh[2]);\r\nPR_EEP("xpdGain", modal_hdr->xpdGain);\r\nPR_EEP("External PD", modal_hdr->xpd);\r\nPR_EEP("Chain0 I Coefficient", modal_hdr->iqCalICh[0]);\r\nPR_EEP("Chain1 I Coefficient", modal_hdr->iqCalICh[1]);\r\nPR_EEP("Chain2 I Coefficient", modal_hdr->iqCalICh[2]);\r\nPR_EEP("Chain0 Q Coefficient", modal_hdr->iqCalQCh[0]);\r\nPR_EEP("Chain1 Q Coefficient", modal_hdr->iqCalQCh[1]);\r\nPR_EEP("Chain2 Q Coefficient", modal_hdr->iqCalQCh[2]);\r\nPR_EEP("pdGainOverlap", modal_hdr->pdGainOverlap);\r\nPR_EEP("Chain0 OutputBias", modal_hdr->ob);\r\nPR_EEP("Chain0 DriverBias", modal_hdr->db);\r\nPR_EEP("xPA Bias Level", modal_hdr->xpaBiasLvl);\r\nPR_EEP("2chain pwr decrease", modal_hdr->pwrDecreaseFor2Chain);\r\nPR_EEP("3chain pwr decrease", modal_hdr->pwrDecreaseFor3Chain);\r\nPR_EEP("txFrameToDataStart", modal_hdr->txFrameToDataStart);\r\nPR_EEP("txFrameToPaOn", modal_hdr->txFrameToPaOn);\r\nPR_EEP("HT40 Power Inc.", modal_hdr->ht40PowerIncForPdadc);\r\nPR_EEP("Chain0 bswAtten", modal_hdr->bswAtten[0]);\r\nPR_EEP("Chain1 bswAtten", modal_hdr->bswAtten[1]);\r\nPR_EEP("Chain2 bswAtten", modal_hdr->bswAtten[2]);\r\nPR_EEP("Chain0 bswMargin", modal_hdr->bswMargin[0]);\r\nPR_EEP("Chain1 bswMargin", modal_hdr->bswMargin[1]);\r\nPR_EEP("Chain2 bswMargin", modal_hdr->bswMargin[2]);\r\nPR_EEP("HT40 Switch Settle", modal_hdr->swSettleHt40);\r\nPR_EEP("Chain0 xatten2Db", modal_hdr->xatten2Db[0]);\r\nPR_EEP("Chain1 xatten2Db", modal_hdr->xatten2Db[1]);\r\nPR_EEP("Chain2 xatten2Db", modal_hdr->xatten2Db[2]);\r\nPR_EEP("Chain0 xatten2Margin", modal_hdr->xatten2Margin[0]);\r\nPR_EEP("Chain1 xatten2Margin", modal_hdr->xatten2Margin[1]);\r\nPR_EEP("Chain2 xatten2Margin", modal_hdr->xatten2Margin[2]);\r\nPR_EEP("Chain1 OutputBias", modal_hdr->ob_ch1);\r\nPR_EEP("Chain1 DriverBias", modal_hdr->db_ch1);\r\nPR_EEP("LNA Control", modal_hdr->lna_ctl);\r\nPR_EEP("XPA Bias Freq0", modal_hdr->xpaBiasLvlFreq[0]);\r\nPR_EEP("XPA Bias Freq1", modal_hdr->xpaBiasLvlFreq[1]);\r\nPR_EEP("XPA Bias Freq2", modal_hdr->xpaBiasLvlFreq[2]);\r\nreturn len;\r\n}\r\nstatic u32 ath9k_hw_def_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,\r\nu8 *buf, u32 len, u32 size)\r\n{\r\nstruct ar5416_eeprom_def *eep = &ah->eeprom.def;\r\nstruct base_eep_header *pBase = &eep->baseEepHeader;\r\nif (!dump_base_hdr) {\r\nlen += scnprintf(buf + len, size - len,\r\n"%20s :\n", "2GHz modal Header");\r\nlen = ath9k_def_dump_modal_eeprom(buf, len, size,\r\n&eep->modalHeader[0]);\r\nlen += scnprintf(buf + len, size - len,\r\n"%20s :\n", "5GHz modal Header");\r\nlen = ath9k_def_dump_modal_eeprom(buf, len, size,\r\n&eep->modalHeader[1]);\r\ngoto out;\r\n}\r\nPR_EEP("Major Version", pBase->version >> 12);\r\nPR_EEP("Minor Version", pBase->version & 0xFFF);\r\nPR_EEP("Checksum", pBase->checksum);\r\nPR_EEP("Length", pBase->length);\r\nPR_EEP("RegDomain1", pBase->regDmn[0]);\r\nPR_EEP("RegDomain2", pBase->regDmn[1]);\r\nPR_EEP("TX Mask", pBase->txMask);\r\nPR_EEP("RX Mask", pBase->rxMask);\r\nPR_EEP("Allow 5GHz", !!(pBase->opCapFlags & AR5416_OPFLAGS_11A));\r\nPR_EEP("Allow 2GHz", !!(pBase->opCapFlags & AR5416_OPFLAGS_11G));\r\nPR_EEP("Disable 2GHz HT20", !!(pBase->opCapFlags &\r\nAR5416_OPFLAGS_N_2G_HT20));\r\nPR_EEP("Disable 2GHz HT40", !!(pBase->opCapFlags &\r\nAR5416_OPFLAGS_N_2G_HT40));\r\nPR_EEP("Disable 5Ghz HT20", !!(pBase->opCapFlags &\r\nAR5416_OPFLAGS_N_5G_HT20));\r\nPR_EEP("Disable 5Ghz HT40", !!(pBase->opCapFlags &\r\nAR5416_OPFLAGS_N_5G_HT40));\r\nPR_EEP("Big Endian", !!(pBase->eepMisc & 0x01));\r\nPR_EEP("Cal Bin Major Ver", (pBase->binBuildNumber >> 24) & 0xFF);\r\nPR_EEP("Cal Bin Minor Ver", (pBase->binBuildNumber >> 16) & 0xFF);\r\nPR_EEP("Cal Bin Build", (pBase->binBuildNumber >> 8) & 0xFF);\r\nPR_EEP("OpenLoop Power Ctrl", pBase->openLoopPwrCntl);\r\nlen += scnprintf(buf + len, size - len, "%20s : %pM\n", "MacAddress",\r\npBase->macAddr);\r\nout:\r\nif (len > size)\r\nlen = size;\r\nreturn len;\r\n}\r\nstatic u32 ath9k_hw_def_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,\r\nu8 *buf, u32 len, u32 size)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ath9k_hw_def_check_eeprom(struct ath_hw *ah)\r\n{\r\nstruct ar5416_eeprom_def *eep = &ah->eeprom.def;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nu16 *eepdata, temp, magic;\r\nu32 sum = 0, el;\r\nbool need_swap = false;\r\nint i, addr, size;\r\nif (!ath9k_hw_nvram_read(ah, AR5416_EEPROM_MAGIC_OFFSET, &magic)) {\r\nath_err(common, "Reading Magic # failed\n");\r\nreturn false;\r\n}\r\nif (swab16(magic) == AR5416_EEPROM_MAGIC &&\r\n!(ah->ah_flags & AH_NO_EEP_SWAP)) {\r\nsize = sizeof(struct ar5416_eeprom_def);\r\nneed_swap = true;\r\neepdata = (u16 *) (&ah->eeprom);\r\nfor (addr = 0; addr < size / sizeof(u16); addr++) {\r\ntemp = swab16(*eepdata);\r\n*eepdata = temp;\r\neepdata++;\r\n}\r\n}\r\nath_dbg(common, EEPROM, "need_swap = %s\n",\r\nneed_swap ? "True" : "False");\r\nif (need_swap)\r\nel = swab16(ah->eeprom.def.baseEepHeader.length);\r\nelse\r\nel = ah->eeprom.def.baseEepHeader.length;\r\nif (el > sizeof(struct ar5416_eeprom_def))\r\nel = sizeof(struct ar5416_eeprom_def) / sizeof(u16);\r\nelse\r\nel = el / sizeof(u16);\r\neepdata = (u16 *)(&ah->eeprom);\r\nfor (i = 0; i < el; i++)\r\nsum ^= *eepdata++;\r\nif (need_swap) {\r\nu32 integer, j;\r\nu16 word;\r\nath_dbg(common, EEPROM,\r\n"EEPROM Endianness is not native.. Changing.\n");\r\nword = swab16(eep->baseEepHeader.length);\r\neep->baseEepHeader.length = word;\r\nword = swab16(eep->baseEepHeader.checksum);\r\neep->baseEepHeader.checksum = word;\r\nword = swab16(eep->baseEepHeader.version);\r\neep->baseEepHeader.version = word;\r\nword = swab16(eep->baseEepHeader.regDmn[0]);\r\neep->baseEepHeader.regDmn[0] = word;\r\nword = swab16(eep->baseEepHeader.regDmn[1]);\r\neep->baseEepHeader.regDmn[1] = word;\r\nword = swab16(eep->baseEepHeader.rfSilent);\r\neep->baseEepHeader.rfSilent = word;\r\nword = swab16(eep->baseEepHeader.blueToothOptions);\r\neep->baseEepHeader.blueToothOptions = word;\r\nword = swab16(eep->baseEepHeader.deviceCap);\r\neep->baseEepHeader.deviceCap = word;\r\nfor (j = 0; j < ARRAY_SIZE(eep->modalHeader); j++) {\r\nstruct modal_eep_header *pModal =\r\n&eep->modalHeader[j];\r\ninteger = swab32(pModal->antCtrlCommon);\r\npModal->antCtrlCommon = integer;\r\nfor (i = 0; i < AR5416_MAX_CHAINS; i++) {\r\ninteger = swab32(pModal->antCtrlChain[i]);\r\npModal->antCtrlChain[i] = integer;\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nword = swab16(pModal->xpaBiasLvlFreq[i]);\r\npModal->xpaBiasLvlFreq[i] = word;\r\n}\r\nfor (i = 0; i < AR_EEPROM_MODAL_SPURS; i++) {\r\nword = swab16(pModal->spurChans[i].spurChan);\r\npModal->spurChans[i].spurChan = word;\r\n}\r\n}\r\n}\r\nif (sum != 0xffff || ah->eep_ops->get_eeprom_ver(ah) != AR5416_EEP_VER ||\r\nah->eep_ops->get_eeprom_rev(ah) < AR5416_EEP_NO_BACK_VER) {\r\nath_err(common, "Bad EEPROM checksum 0x%x or revision 0x%04x\n",\r\nsum, ah->eep_ops->get_eeprom_ver(ah));\r\nreturn -EINVAL;\r\n}\r\nif ((ah->hw_version.devid == AR9280_DEVID_PCI) &&\r\n((eep->baseEepHeader.version & 0xff) > 0x0a) &&\r\n(eep->baseEepHeader.pwdclkind == 0))\r\nah->need_an_top2_fixup = true;\r\nif ((common->bus_ops->ath_bus_type == ATH_USB) &&\r\n(AR_SREV_9280(ah)))\r\neep->modalHeader[0].xpaBiasLvl = 0;\r\nreturn 0;\r\n}\r\nstatic u32 ath9k_hw_def_get_eeprom(struct ath_hw *ah,\r\nenum eeprom_param param)\r\n{\r\nstruct ar5416_eeprom_def *eep = &ah->eeprom.def;\r\nstruct modal_eep_header *pModal = eep->modalHeader;\r\nstruct base_eep_header *pBase = &eep->baseEepHeader;\r\nint band = 0;\r\nswitch (param) {\r\ncase EEP_NFTHRESH_5:\r\nreturn pModal[0].noiseFloorThreshCh[0];\r\ncase EEP_NFTHRESH_2:\r\nreturn pModal[1].noiseFloorThreshCh[0];\r\ncase EEP_MAC_LSW:\r\nreturn get_unaligned_be16(pBase->macAddr);\r\ncase EEP_MAC_MID:\r\nreturn get_unaligned_be16(pBase->macAddr + 2);\r\ncase EEP_MAC_MSW:\r\nreturn get_unaligned_be16(pBase->macAddr + 4);\r\ncase EEP_REG_0:\r\nreturn pBase->regDmn[0];\r\ncase EEP_OP_CAP:\r\nreturn pBase->deviceCap;\r\ncase EEP_OP_MODE:\r\nreturn pBase->opCapFlags;\r\ncase EEP_RF_SILENT:\r\nreturn pBase->rfSilent;\r\ncase EEP_OB_5:\r\nreturn pModal[0].ob;\r\ncase EEP_DB_5:\r\nreturn pModal[0].db;\r\ncase EEP_OB_2:\r\nreturn pModal[1].ob;\r\ncase EEP_DB_2:\r\nreturn pModal[1].db;\r\ncase EEP_MINOR_REV:\r\nreturn AR5416_VER_MASK;\r\ncase EEP_TX_MASK:\r\nreturn pBase->txMask;\r\ncase EEP_RX_MASK:\r\nreturn pBase->rxMask;\r\ncase EEP_FSTCLK_5G:\r\nreturn pBase->fastClk5g;\r\ncase EEP_RXGAIN_TYPE:\r\nreturn pBase->rxGainType;\r\ncase EEP_TXGAIN_TYPE:\r\nreturn pBase->txGainType;\r\ncase EEP_OL_PWRCTRL:\r\nif (AR5416_VER_MASK >= AR5416_EEP_MINOR_VER_19)\r\nreturn pBase->openLoopPwrCntl ? true : false;\r\nelse\r\nreturn false;\r\ncase EEP_RC_CHAIN_MASK:\r\nif (AR5416_VER_MASK >= AR5416_EEP_MINOR_VER_19)\r\nreturn pBase->rcChainMask;\r\nelse\r\nreturn 0;\r\ncase EEP_DAC_HPWR_5G:\r\nif (AR5416_VER_MASK >= AR5416_EEP_MINOR_VER_20)\r\nreturn pBase->dacHiPwrMode_5G;\r\nelse\r\nreturn 0;\r\ncase EEP_FRAC_N_5G:\r\nif (AR5416_VER_MASK >= AR5416_EEP_MINOR_VER_22)\r\nreturn pBase->frac_n_5g;\r\nelse\r\nreturn 0;\r\ncase EEP_PWR_TABLE_OFFSET:\r\nif (AR5416_VER_MASK >= AR5416_EEP_MINOR_VER_21)\r\nreturn pBase->pwr_table_offset;\r\nelse\r\nreturn AR5416_PWR_TABLE_OFFSET_DB;\r\ncase EEP_ANTENNA_GAIN_2G:\r\nband = 1;\r\ncase EEP_ANTENNA_GAIN_5G:\r\nreturn max_t(u8, max_t(u8,\r\npModal[band].antennaGainCh[0],\r\npModal[band].antennaGainCh[1]),\r\npModal[band].antennaGainCh[2]);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void ath9k_hw_def_set_gain(struct ath_hw *ah,\r\nstruct modal_eep_header *pModal,\r\nstruct ar5416_eeprom_def *eep,\r\nu8 txRxAttenLocal, int regChainOffset, int i)\r\n{\r\nENABLE_REG_RMW_BUFFER(ah);\r\nif (AR5416_VER_MASK >= AR5416_EEP_MINOR_VER_3) {\r\ntxRxAttenLocal = pModal->txRxAttenCh[i];\r\nif (AR_SREV_9280_20_OR_LATER(ah)) {\r\nREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + regChainOffset,\r\nAR_PHY_GAIN_2GHZ_XATTEN1_MARGIN,\r\npModal->bswMargin[i]);\r\nREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + regChainOffset,\r\nAR_PHY_GAIN_2GHZ_XATTEN1_DB,\r\npModal->bswAtten[i]);\r\nREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + regChainOffset,\r\nAR_PHY_GAIN_2GHZ_XATTEN2_MARGIN,\r\npModal->xatten2Margin[i]);\r\nREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + regChainOffset,\r\nAR_PHY_GAIN_2GHZ_XATTEN2_DB,\r\npModal->xatten2Db[i]);\r\n} else {\r\nREG_RMW(ah, AR_PHY_GAIN_2GHZ + regChainOffset,\r\nSM(pModal-> bswMargin[i], AR_PHY_GAIN_2GHZ_BSW_MARGIN),\r\nAR_PHY_GAIN_2GHZ_BSW_MARGIN);\r\nREG_RMW(ah, AR_PHY_GAIN_2GHZ + regChainOffset,\r\nSM(pModal->bswAtten[i], AR_PHY_GAIN_2GHZ_BSW_ATTEN),\r\nAR_PHY_GAIN_2GHZ_BSW_ATTEN);\r\n}\r\n}\r\nif (AR_SREV_9280_20_OR_LATER(ah)) {\r\nREG_RMW_FIELD(ah,\r\nAR_PHY_RXGAIN + regChainOffset,\r\nAR9280_PHY_RXGAIN_TXRX_ATTEN, txRxAttenLocal);\r\nREG_RMW_FIELD(ah,\r\nAR_PHY_RXGAIN + regChainOffset,\r\nAR9280_PHY_RXGAIN_TXRX_MARGIN, pModal->rxTxMarginCh[i]);\r\n} else {\r\nREG_RMW(ah, AR_PHY_RXGAIN + regChainOffset,\r\nSM(txRxAttenLocal, AR_PHY_RXGAIN_TXRX_ATTEN),\r\nAR_PHY_RXGAIN_TXRX_ATTEN);\r\nREG_RMW(ah, AR_PHY_GAIN_2GHZ + regChainOffset,\r\nSM(pModal->rxTxMarginCh[i], AR_PHY_GAIN_2GHZ_RXTX_MARGIN),\r\nAR_PHY_GAIN_2GHZ_RXTX_MARGIN);\r\n}\r\nREG_RMW_BUFFER_FLUSH(ah);\r\n}\r\nstatic void ath9k_hw_def_set_board_values(struct ath_hw *ah,\r\nstruct ath9k_channel *chan)\r\n{\r\nstruct modal_eep_header *pModal;\r\nstruct ar5416_eeprom_def *eep = &ah->eeprom.def;\r\nint i, regChainOffset;\r\nu8 txRxAttenLocal;\r\npModal = &(eep->modalHeader[IS_CHAN_2GHZ(chan)]);\r\ntxRxAttenLocal = IS_CHAN_2GHZ(chan) ? 23 : 44;\r\nREG_WRITE(ah, AR_PHY_SWITCH_COM, pModal->antCtrlCommon & 0xffff);\r\nfor (i = 0; i < AR5416_MAX_CHAINS; i++) {\r\nif (AR_SREV_9280(ah)) {\r\nif (i >= 2)\r\nbreak;\r\n}\r\nif ((ah->rxchainmask == 5 || ah->txchainmask == 5) && (i != 0))\r\nregChainOffset = (i == 1) ? 0x2000 : 0x1000;\r\nelse\r\nregChainOffset = i * 0x1000;\r\nREG_WRITE(ah, AR_PHY_SWITCH_CHAIN_0 + regChainOffset,\r\npModal->antCtrlChain[i]);\r\nREG_WRITE(ah, AR_PHY_TIMING_CTRL4(0) + regChainOffset,\r\n(REG_READ(ah, AR_PHY_TIMING_CTRL4(0) + regChainOffset) &\r\n~(AR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF |\r\nAR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF)) |\r\nSM(pModal->iqCalICh[i],\r\nAR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF) |\r\nSM(pModal->iqCalQCh[i],\r\nAR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF));\r\nath9k_hw_def_set_gain(ah, pModal, eep, txRxAttenLocal,\r\nregChainOffset, i);\r\n}\r\nif (AR_SREV_9280_20_OR_LATER(ah)) {\r\nif (IS_CHAN_2GHZ(chan)) {\r\nath9k_hw_analog_shift_rmw(ah, AR_AN_RF2G1_CH0,\r\nAR_AN_RF2G1_CH0_OB,\r\nAR_AN_RF2G1_CH0_OB_S,\r\npModal->ob);\r\nath9k_hw_analog_shift_rmw(ah, AR_AN_RF2G1_CH0,\r\nAR_AN_RF2G1_CH0_DB,\r\nAR_AN_RF2G1_CH0_DB_S,\r\npModal->db);\r\nath9k_hw_analog_shift_rmw(ah, AR_AN_RF2G1_CH1,\r\nAR_AN_RF2G1_CH1_OB,\r\nAR_AN_RF2G1_CH1_OB_S,\r\npModal->ob_ch1);\r\nath9k_hw_analog_shift_rmw(ah, AR_AN_RF2G1_CH1,\r\nAR_AN_RF2G1_CH1_DB,\r\nAR_AN_RF2G1_CH1_DB_S,\r\npModal->db_ch1);\r\n} else {\r\nath9k_hw_analog_shift_rmw(ah, AR_AN_RF5G1_CH0,\r\nAR_AN_RF5G1_CH0_OB5,\r\nAR_AN_RF5G1_CH0_OB5_S,\r\npModal->ob);\r\nath9k_hw_analog_shift_rmw(ah, AR_AN_RF5G1_CH0,\r\nAR_AN_RF5G1_CH0_DB5,\r\nAR_AN_RF5G1_CH0_DB5_S,\r\npModal->db);\r\nath9k_hw_analog_shift_rmw(ah, AR_AN_RF5G1_CH1,\r\nAR_AN_RF5G1_CH1_OB5,\r\nAR_AN_RF5G1_CH1_OB5_S,\r\npModal->ob_ch1);\r\nath9k_hw_analog_shift_rmw(ah, AR_AN_RF5G1_CH1,\r\nAR_AN_RF5G1_CH1_DB5,\r\nAR_AN_RF5G1_CH1_DB5_S,\r\npModal->db_ch1);\r\n}\r\nath9k_hw_analog_shift_rmw(ah, AR_AN_TOP2,\r\nAR_AN_TOP2_XPABIAS_LVL,\r\nAR_AN_TOP2_XPABIAS_LVL_S,\r\npModal->xpaBiasLvl);\r\nath9k_hw_analog_shift_rmw(ah, AR_AN_TOP2,\r\nAR_AN_TOP2_LOCALBIAS,\r\nAR_AN_TOP2_LOCALBIAS_S,\r\n!!(pModal->lna_ctl &\r\nLNA_CTL_LOCAL_BIAS));\r\nREG_RMW_FIELD(ah, AR_PHY_XPA_CFG, AR_PHY_FORCE_XPA_CFG,\r\n!!(pModal->lna_ctl & LNA_CTL_FORCE_XPA));\r\n}\r\nREG_RMW_FIELD(ah, AR_PHY_SETTLING, AR_PHY_SETTLING_SWITCH,\r\npModal->switchSettling);\r\nREG_RMW_FIELD(ah, AR_PHY_DESIRED_SZ, AR_PHY_DESIRED_SZ_ADC,\r\npModal->adcDesiredSize);\r\nif (!AR_SREV_9280_20_OR_LATER(ah))\r\nREG_RMW_FIELD(ah, AR_PHY_DESIRED_SZ,\r\nAR_PHY_DESIRED_SZ_PGA,\r\npModal->pgaDesiredSize);\r\nREG_WRITE(ah, AR_PHY_RF_CTL4,\r\nSM(pModal->txEndToXpaOff, AR_PHY_RF_CTL4_TX_END_XPAA_OFF)\r\n| SM(pModal->txEndToXpaOff,\r\nAR_PHY_RF_CTL4_TX_END_XPAB_OFF)\r\n| SM(pModal->txFrameToXpaOn,\r\nAR_PHY_RF_CTL4_FRAME_XPAA_ON)\r\n| SM(pModal->txFrameToXpaOn,\r\nAR_PHY_RF_CTL4_FRAME_XPAB_ON));\r\nREG_RMW_FIELD(ah, AR_PHY_RF_CTL3, AR_PHY_TX_END_TO_A2_RX_ON,\r\npModal->txEndToRxOn);\r\nif (AR_SREV_9280_20_OR_LATER(ah)) {\r\nREG_RMW_FIELD(ah, AR_PHY_CCA, AR9280_PHY_CCA_THRESH62,\r\npModal->thresh62);\r\nREG_RMW_FIELD(ah, AR_PHY_EXT_CCA0,\r\nAR_PHY_EXT_CCA0_THRESH62,\r\npModal->thresh62);\r\n} else {\r\nREG_RMW_FIELD(ah, AR_PHY_CCA, AR_PHY_CCA_THRESH62,\r\npModal->thresh62);\r\nREG_RMW_FIELD(ah, AR_PHY_EXT_CCA,\r\nAR_PHY_EXT_CCA_THRESH62,\r\npModal->thresh62);\r\n}\r\nif (AR5416_VER_MASK >= AR5416_EEP_MINOR_VER_2) {\r\nREG_RMW_FIELD(ah, AR_PHY_RF_CTL2,\r\nAR_PHY_TX_END_DATA_START,\r\npModal->txFrameToDataStart);\r\nREG_RMW_FIELD(ah, AR_PHY_RF_CTL2, AR_PHY_TX_END_PA_ON,\r\npModal->txFrameToPaOn);\r\n}\r\nif (AR5416_VER_MASK >= AR5416_EEP_MINOR_VER_3) {\r\nif (IS_CHAN_HT40(chan))\r\nREG_RMW_FIELD(ah, AR_PHY_SETTLING,\r\nAR_PHY_SETTLING_SWITCH,\r\npModal->swSettleHt40);\r\n}\r\nif (AR_SREV_9280_20_OR_LATER(ah) &&\r\nAR5416_VER_MASK >= AR5416_EEP_MINOR_VER_19)\r\nREG_RMW_FIELD(ah, AR_PHY_CCK_TX_CTRL,\r\nAR_PHY_CCK_TX_CTRL_TX_DAC_SCALE_CCK,\r\npModal->miscBits);\r\nif (AR_SREV_9280_20(ah) && AR5416_VER_MASK >= AR5416_EEP_MINOR_VER_20) {\r\nif (IS_CHAN_2GHZ(chan))\r\nREG_RMW_FIELD(ah, AR_AN_TOP1, AR_AN_TOP1_DACIPMODE,\r\neep->baseEepHeader.dacLpMode);\r\nelse if (eep->baseEepHeader.dacHiPwrMode_5G)\r\nREG_RMW_FIELD(ah, AR_AN_TOP1, AR_AN_TOP1_DACIPMODE, 0);\r\nelse\r\nREG_RMW_FIELD(ah, AR_AN_TOP1, AR_AN_TOP1_DACIPMODE,\r\neep->baseEepHeader.dacLpMode);\r\nudelay(100);\r\nREG_RMW_FIELD(ah, AR_PHY_FRAME_CTL, AR_PHY_FRAME_CTL_TX_CLIP,\r\npModal->miscBits >> 2);\r\nREG_RMW_FIELD(ah, AR_PHY_TX_PWRCTRL9,\r\nAR_PHY_TX_DESIRED_SCALE_CCK,\r\neep->baseEepHeader.desiredScaleCCK);\r\n}\r\n}\r\nstatic void ath9k_hw_def_set_addac(struct ath_hw *ah,\r\nstruct ath9k_channel *chan)\r\n{\r\n#define XPA_LVL_FREQ(cnt) (pModal->xpaBiasLvlFreq[cnt])\r\nstruct modal_eep_header *pModal;\r\nstruct ar5416_eeprom_def *eep = &ah->eeprom.def;\r\nu8 biaslevel;\r\nif (ah->hw_version.macVersion != AR_SREV_VERSION_9160)\r\nreturn;\r\nif (ah->eep_ops->get_eeprom_rev(ah) < AR5416_EEP_MINOR_VER_7)\r\nreturn;\r\npModal = &(eep->modalHeader[IS_CHAN_2GHZ(chan)]);\r\nif (pModal->xpaBiasLvl != 0xff) {\r\nbiaslevel = pModal->xpaBiasLvl;\r\n} else {\r\nu16 resetFreqBin, freqBin, freqCount = 0;\r\nstruct chan_centers centers;\r\nath9k_hw_get_channel_centers(ah, chan, &centers);\r\nresetFreqBin = FREQ2FBIN(centers.synth_center,\r\nIS_CHAN_2GHZ(chan));\r\nfreqBin = XPA_LVL_FREQ(0) & 0xff;\r\nbiaslevel = (u8) (XPA_LVL_FREQ(0) >> 14);\r\nfreqCount++;\r\nwhile (freqCount < 3) {\r\nif (XPA_LVL_FREQ(freqCount) == 0x0)\r\nbreak;\r\nfreqBin = XPA_LVL_FREQ(freqCount) & 0xff;\r\nif (resetFreqBin >= freqBin)\r\nbiaslevel = (u8)(XPA_LVL_FREQ(freqCount) >> 14);\r\nelse\r\nbreak;\r\nfreqCount++;\r\n}\r\n}\r\nif (IS_CHAN_2GHZ(chan)) {\r\nINI_RA(&ah->iniAddac, 7, 1) = (INI_RA(&ah->iniAddac,\r\n7, 1) & (~0x18)) | biaslevel << 3;\r\n} else {\r\nINI_RA(&ah->iniAddac, 6, 1) = (INI_RA(&ah->iniAddac,\r\n6, 1) & (~0xc0)) | biaslevel << 6;\r\n}\r\n#undef XPA_LVL_FREQ\r\n}\r\nstatic int16_t ath9k_change_gain_boundary_setting(struct ath_hw *ah,\r\nu16 *gb,\r\nu16 numXpdGain,\r\nu16 pdGainOverlap_t2,\r\nint8_t pwr_table_offset,\r\nint16_t *diff)\r\n{\r\nu16 k;\r\nif (AR_SREV_9280_20_OR_LATER(ah)) {\r\nu16 gb_limit;\r\nif (AR5416_PWR_TABLE_OFFSET_DB != pwr_table_offset) {\r\n*diff = (u16)(pwr_table_offset - AR5416_PWR_TABLE_OFFSET_DB);\r\n*diff *= 2;\r\nfor (k = 0; k < numXpdGain; k++)\r\ngb[k] = (u16)(gb[k] - *diff);\r\n}\r\ngb_limit = (u16)(MAX_RATE_POWER - pdGainOverlap_t2);\r\nfor (k = 0; k < numXpdGain; k++)\r\ngb[k] = (u16)min(gb_limit, gb[k]);\r\n}\r\nreturn *diff;\r\n}\r\nstatic void ath9k_adjust_pdadc_values(struct ath_hw *ah,\r\nint8_t pwr_table_offset,\r\nint16_t diff,\r\nu8 *pdadcValues)\r\n{\r\n#define NUM_PDADC(diff) (AR5416_NUM_PDADC_VALUES - diff)\r\nu16 k;\r\nif (AR_SREV_9280_20_OR_LATER(ah)) {\r\nif (AR5416_PWR_TABLE_OFFSET_DB != pwr_table_offset) {\r\nfor (k = 0; k < (u16)NUM_PDADC(diff); k++ ) {\r\npdadcValues[k] = pdadcValues[k + diff];\r\n}\r\nfor (k = (u16)NUM_PDADC(diff); k < NUM_PDADC(0); k++) {\r\npdadcValues[k] = pdadcValues[NUM_PDADC(diff)];\r\n}\r\n}\r\n}\r\n#undef NUM_PDADC\r\n}\r\nstatic void ath9k_hw_set_def_power_cal_table(struct ath_hw *ah,\r\nstruct ath9k_channel *chan)\r\n{\r\n#define SM_PD_GAIN(x) SM(0x38, AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_##x)\r\n#define SM_PDGAIN_B(x, y) \\r\nSM((gainBoundaries[x]), AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_##y)\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ar5416_eeprom_def *pEepData = &ah->eeprom.def;\r\nstruct cal_data_per_freq *pRawDataset;\r\nu8 *pCalBChans = NULL;\r\nu16 pdGainOverlap_t2;\r\nstatic u8 pdadcValues[AR5416_NUM_PDADC_VALUES];\r\nu16 gainBoundaries[AR5416_PD_GAINS_IN_MASK];\r\nu16 numPiers, i, j;\r\nint16_t diff = 0;\r\nu16 numXpdGain, xpdMask;\r\nu16 xpdGainValues[AR5416_NUM_PD_GAINS] = { 0, 0, 0, 0 };\r\nu32 reg32, regOffset, regChainOffset;\r\nint16_t modalIdx;\r\nint8_t pwr_table_offset;\r\nmodalIdx = IS_CHAN_2GHZ(chan) ? 1 : 0;\r\nxpdMask = pEepData->modalHeader[modalIdx].xpdGain;\r\npwr_table_offset = ah->eep_ops->get_eeprom(ah, EEP_PWR_TABLE_OFFSET);\r\nif ((pEepData->baseEepHeader.version & AR5416_EEP_VER_MINOR_MASK) >=\r\nAR5416_EEP_MINOR_VER_2) {\r\npdGainOverlap_t2 =\r\npEepData->modalHeader[modalIdx].pdGainOverlap;\r\n} else {\r\npdGainOverlap_t2 = (u16)(MS(REG_READ(ah, AR_PHY_TPCRG5),\r\nAR_PHY_TPCRG5_PD_GAIN_OVERLAP));\r\n}\r\nif (IS_CHAN_2GHZ(chan)) {\r\npCalBChans = pEepData->calFreqPier2G;\r\nnumPiers = AR5416_NUM_2G_CAL_PIERS;\r\n} else {\r\npCalBChans = pEepData->calFreqPier5G;\r\nnumPiers = AR5416_NUM_5G_CAL_PIERS;\r\n}\r\nif (OLC_FOR_AR9280_20_LATER && IS_CHAN_2GHZ(chan)) {\r\npRawDataset = pEepData->calPierData2G[0];\r\nah->initPDADC = ((struct calDataPerFreqOpLoop *)\r\npRawDataset)->vpdPdg[0][0];\r\n}\r\nnumXpdGain = 0;\r\nfor (i = 1; i <= AR5416_PD_GAINS_IN_MASK; i++) {\r\nif ((xpdMask >> (AR5416_PD_GAINS_IN_MASK - i)) & 1) {\r\nif (numXpdGain >= AR5416_NUM_PD_GAINS)\r\nbreak;\r\nxpdGainValues[numXpdGain] =\r\n(u16)(AR5416_PD_GAINS_IN_MASK - i);\r\nnumXpdGain++;\r\n}\r\n}\r\nREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_NUM_PD_GAIN,\r\n(numXpdGain - 1) & 0x3);\r\nREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_GAIN_1,\r\nxpdGainValues[0]);\r\nREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_GAIN_2,\r\nxpdGainValues[1]);\r\nREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_GAIN_3,\r\nxpdGainValues[2]);\r\nfor (i = 0; i < AR5416_MAX_CHAINS; i++) {\r\nif ((ah->rxchainmask == 5 || ah->txchainmask == 5) &&\r\n(i != 0)) {\r\nregChainOffset = (i == 1) ? 0x2000 : 0x1000;\r\n} else\r\nregChainOffset = i * 0x1000;\r\nif (pEepData->baseEepHeader.txMask & (1 << i)) {\r\nif (IS_CHAN_2GHZ(chan))\r\npRawDataset = pEepData->calPierData2G[i];\r\nelse\r\npRawDataset = pEepData->calPierData5G[i];\r\nif (OLC_FOR_AR9280_20_LATER) {\r\nu8 pcdacIdx;\r\nu8 txPower;\r\nath9k_get_txgain_index(ah, chan,\r\n(struct calDataPerFreqOpLoop *)pRawDataset,\r\npCalBChans, numPiers, &txPower, &pcdacIdx);\r\nath9k_olc_get_pdadcs(ah, pcdacIdx,\r\ntxPower/2, pdadcValues);\r\n} else {\r\nath9k_hw_get_gain_boundaries_pdadcs(ah,\r\nchan, pRawDataset,\r\npCalBChans, numPiers,\r\npdGainOverlap_t2,\r\ngainBoundaries,\r\npdadcValues,\r\nnumXpdGain);\r\n}\r\ndiff = ath9k_change_gain_boundary_setting(ah,\r\ngainBoundaries,\r\nnumXpdGain,\r\npdGainOverlap_t2,\r\npwr_table_offset,\r\n&diff);\r\nENABLE_REGWRITE_BUFFER(ah);\r\nif (OLC_FOR_AR9280_20_LATER) {\r\nREG_WRITE(ah,\r\nAR_PHY_TPCRG5 + regChainOffset,\r\nSM(0x6,\r\nAR_PHY_TPCRG5_PD_GAIN_OVERLAP) |\r\nSM_PD_GAIN(1) | SM_PD_GAIN(2) |\r\nSM_PD_GAIN(3) | SM_PD_GAIN(4));\r\n} else {\r\nREG_WRITE(ah,\r\nAR_PHY_TPCRG5 + regChainOffset,\r\nSM(pdGainOverlap_t2,\r\nAR_PHY_TPCRG5_PD_GAIN_OVERLAP)|\r\nSM_PDGAIN_B(0, 1) |\r\nSM_PDGAIN_B(1, 2) |\r\nSM_PDGAIN_B(2, 3) |\r\nSM_PDGAIN_B(3, 4));\r\n}\r\nath9k_adjust_pdadc_values(ah, pwr_table_offset,\r\ndiff, pdadcValues);\r\nregOffset = AR_PHY_BASE + (672 << 2) + regChainOffset;\r\nfor (j = 0; j < 32; j++) {\r\nreg32 = get_unaligned_le32(&pdadcValues[4 * j]);\r\nREG_WRITE(ah, regOffset, reg32);\r\nath_dbg(common, EEPROM,\r\n"PDADC (%d,%4x): %4.4x %8.8x\n",\r\ni, regChainOffset, regOffset,\r\nreg32);\r\nath_dbg(common, EEPROM,\r\n"PDADC: Chain %d | PDADC %3d Value %3d | PDADC %3d Value %3d | PDADC %3d Value %3d | PDADC %3d Value %3d |\n",\r\ni, 4 * j, pdadcValues[4 * j],\r\n4 * j + 1, pdadcValues[4 * j + 1],\r\n4 * j + 2, pdadcValues[4 * j + 2],\r\n4 * j + 3, pdadcValues[4 * j + 3]);\r\nregOffset += 4;\r\n}\r\nREGWRITE_BUFFER_FLUSH(ah);\r\n}\r\n}\r\n#undef SM_PD_GAIN\r\n#undef SM_PDGAIN_B\r\n}\r\nstatic void ath9k_hw_set_def_power_per_rate_table(struct ath_hw *ah,\r\nstruct ath9k_channel *chan,\r\nint16_t *ratesArray,\r\nu16 cfgCtl,\r\nu16 antenna_reduction,\r\nu16 powerLimit)\r\n{\r\nstruct ar5416_eeprom_def *pEepData = &ah->eeprom.def;\r\nu16 twiceMaxEdgePower;\r\nint i;\r\nstruct cal_ctl_data *rep;\r\nstruct cal_target_power_leg targetPowerOfdm, targetPowerCck = {\r\n0, { 0, 0, 0, 0}\r\n};\r\nstruct cal_target_power_leg targetPowerOfdmExt = {\r\n0, { 0, 0, 0, 0} }, targetPowerCckExt = {\r\n0, { 0, 0, 0, 0 }\r\n};\r\nstruct cal_target_power_ht targetPowerHt20, targetPowerHt40 = {\r\n0, {0, 0, 0, 0}\r\n};\r\nu16 scaledPower = 0, minCtlPower;\r\nstatic const u16 ctlModesFor11a[] = {\r\nCTL_11A, CTL_5GHT20, CTL_11A_EXT, CTL_5GHT40\r\n};\r\nstatic const u16 ctlModesFor11g[] = {\r\nCTL_11B, CTL_11G, CTL_2GHT20,\r\nCTL_11B_EXT, CTL_11G_EXT, CTL_2GHT40\r\n};\r\nu16 numCtlModes;\r\nconst u16 *pCtlMode;\r\nu16 ctlMode, freq;\r\nstruct chan_centers centers;\r\nint tx_chainmask;\r\nu16 twiceMinEdgePower;\r\ntx_chainmask = ah->txchainmask;\r\nath9k_hw_get_channel_centers(ah, chan, &centers);\r\nscaledPower = ath9k_hw_get_scaled_power(ah, powerLimit,\r\nantenna_reduction);\r\nif (IS_CHAN_2GHZ(chan)) {\r\nnumCtlModes = ARRAY_SIZE(ctlModesFor11g) -\r\nSUB_NUM_CTL_MODES_AT_2G_40;\r\npCtlMode = ctlModesFor11g;\r\nath9k_hw_get_legacy_target_powers(ah, chan,\r\npEepData->calTargetPowerCck,\r\nAR5416_NUM_2G_CCK_TARGET_POWERS,\r\n&targetPowerCck, 4, false);\r\nath9k_hw_get_legacy_target_powers(ah, chan,\r\npEepData->calTargetPower2G,\r\nAR5416_NUM_2G_20_TARGET_POWERS,\r\n&targetPowerOfdm, 4, false);\r\nath9k_hw_get_target_powers(ah, chan,\r\npEepData->calTargetPower2GHT20,\r\nAR5416_NUM_2G_20_TARGET_POWERS,\r\n&targetPowerHt20, 8, false);\r\nif (IS_CHAN_HT40(chan)) {\r\nnumCtlModes = ARRAY_SIZE(ctlModesFor11g);\r\nath9k_hw_get_target_powers(ah, chan,\r\npEepData->calTargetPower2GHT40,\r\nAR5416_NUM_2G_40_TARGET_POWERS,\r\n&targetPowerHt40, 8, true);\r\nath9k_hw_get_legacy_target_powers(ah, chan,\r\npEepData->calTargetPowerCck,\r\nAR5416_NUM_2G_CCK_TARGET_POWERS,\r\n&targetPowerCckExt, 4, true);\r\nath9k_hw_get_legacy_target_powers(ah, chan,\r\npEepData->calTargetPower2G,\r\nAR5416_NUM_2G_20_TARGET_POWERS,\r\n&targetPowerOfdmExt, 4, true);\r\n}\r\n} else {\r\nnumCtlModes = ARRAY_SIZE(ctlModesFor11a) -\r\nSUB_NUM_CTL_MODES_AT_5G_40;\r\npCtlMode = ctlModesFor11a;\r\nath9k_hw_get_legacy_target_powers(ah, chan,\r\npEepData->calTargetPower5G,\r\nAR5416_NUM_5G_20_TARGET_POWERS,\r\n&targetPowerOfdm, 4, false);\r\nath9k_hw_get_target_powers(ah, chan,\r\npEepData->calTargetPower5GHT20,\r\nAR5416_NUM_5G_20_TARGET_POWERS,\r\n&targetPowerHt20, 8, false);\r\nif (IS_CHAN_HT40(chan)) {\r\nnumCtlModes = ARRAY_SIZE(ctlModesFor11a);\r\nath9k_hw_get_target_powers(ah, chan,\r\npEepData->calTargetPower5GHT40,\r\nAR5416_NUM_5G_40_TARGET_POWERS,\r\n&targetPowerHt40, 8, true);\r\nath9k_hw_get_legacy_target_powers(ah, chan,\r\npEepData->calTargetPower5G,\r\nAR5416_NUM_5G_20_TARGET_POWERS,\r\n&targetPowerOfdmExt, 4, true);\r\n}\r\n}\r\nfor (ctlMode = 0; ctlMode < numCtlModes; ctlMode++) {\r\nbool isHt40CtlMode = (pCtlMode[ctlMode] == CTL_5GHT40) ||\r\n(pCtlMode[ctlMode] == CTL_2GHT40);\r\nif (isHt40CtlMode)\r\nfreq = centers.synth_center;\r\nelse if (pCtlMode[ctlMode] & EXT_ADDITIVE)\r\nfreq = centers.ext_center;\r\nelse\r\nfreq = centers.ctl_center;\r\ntwiceMaxEdgePower = MAX_RATE_POWER;\r\nfor (i = 0; (i < AR5416_NUM_CTLS) && pEepData->ctlIndex[i]; i++) {\r\nif ((((cfgCtl & ~CTL_MODE_M) |\r\n(pCtlMode[ctlMode] & CTL_MODE_M)) ==\r\npEepData->ctlIndex[i]) ||\r\n(((cfgCtl & ~CTL_MODE_M) |\r\n(pCtlMode[ctlMode] & CTL_MODE_M)) ==\r\n((pEepData->ctlIndex[i] & CTL_MODE_M) | SD_NO_CTL))) {\r\nrep = &(pEepData->ctlData[i]);\r\ntwiceMinEdgePower = ath9k_hw_get_max_edge_power(freq,\r\nrep->ctlEdges[ar5416_get_ntxchains(tx_chainmask) - 1],\r\nIS_CHAN_2GHZ(chan), AR5416_NUM_BAND_EDGES);\r\nif ((cfgCtl & ~CTL_MODE_M) == SD_NO_CTL) {\r\ntwiceMaxEdgePower = min(twiceMaxEdgePower,\r\ntwiceMinEdgePower);\r\n} else {\r\ntwiceMaxEdgePower = twiceMinEdgePower;\r\nbreak;\r\n}\r\n}\r\n}\r\nminCtlPower = min(twiceMaxEdgePower, scaledPower);\r\nswitch (pCtlMode[ctlMode]) {\r\ncase CTL_11B:\r\nfor (i = 0; i < ARRAY_SIZE(targetPowerCck.tPow2x); i++) {\r\ntargetPowerCck.tPow2x[i] =\r\nmin((u16)targetPowerCck.tPow2x[i],\r\nminCtlPower);\r\n}\r\nbreak;\r\ncase CTL_11A:\r\ncase CTL_11G:\r\nfor (i = 0; i < ARRAY_SIZE(targetPowerOfdm.tPow2x); i++) {\r\ntargetPowerOfdm.tPow2x[i] =\r\nmin((u16)targetPowerOfdm.tPow2x[i],\r\nminCtlPower);\r\n}\r\nbreak;\r\ncase CTL_5GHT20:\r\ncase CTL_2GHT20:\r\nfor (i = 0; i < ARRAY_SIZE(targetPowerHt20.tPow2x); i++) {\r\ntargetPowerHt20.tPow2x[i] =\r\nmin((u16)targetPowerHt20.tPow2x[i],\r\nminCtlPower);\r\n}\r\nbreak;\r\ncase CTL_11B_EXT:\r\ntargetPowerCckExt.tPow2x[0] = min((u16)\r\ntargetPowerCckExt.tPow2x[0],\r\nminCtlPower);\r\nbreak;\r\ncase CTL_11A_EXT:\r\ncase CTL_11G_EXT:\r\ntargetPowerOfdmExt.tPow2x[0] = min((u16)\r\ntargetPowerOfdmExt.tPow2x[0],\r\nminCtlPower);\r\nbreak;\r\ncase CTL_5GHT40:\r\ncase CTL_2GHT40:\r\nfor (i = 0; i < ARRAY_SIZE(targetPowerHt40.tPow2x); i++) {\r\ntargetPowerHt40.tPow2x[i] =\r\nmin((u16)targetPowerHt40.tPow2x[i],\r\nminCtlPower);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nratesArray[rate6mb] = ratesArray[rate9mb] = ratesArray[rate12mb] =\r\nratesArray[rate18mb] = ratesArray[rate24mb] =\r\ntargetPowerOfdm.tPow2x[0];\r\nratesArray[rate36mb] = targetPowerOfdm.tPow2x[1];\r\nratesArray[rate48mb] = targetPowerOfdm.tPow2x[2];\r\nratesArray[rate54mb] = targetPowerOfdm.tPow2x[3];\r\nratesArray[rateXr] = targetPowerOfdm.tPow2x[0];\r\nfor (i = 0; i < ARRAY_SIZE(targetPowerHt20.tPow2x); i++)\r\nratesArray[rateHt20_0 + i] = targetPowerHt20.tPow2x[i];\r\nif (IS_CHAN_2GHZ(chan)) {\r\nratesArray[rate1l] = targetPowerCck.tPow2x[0];\r\nratesArray[rate2s] = ratesArray[rate2l] =\r\ntargetPowerCck.tPow2x[1];\r\nratesArray[rate5_5s] = ratesArray[rate5_5l] =\r\ntargetPowerCck.tPow2x[2];\r\nratesArray[rate11s] = ratesArray[rate11l] =\r\ntargetPowerCck.tPow2x[3];\r\n}\r\nif (IS_CHAN_HT40(chan)) {\r\nfor (i = 0; i < ARRAY_SIZE(targetPowerHt40.tPow2x); i++) {\r\nratesArray[rateHt40_0 + i] =\r\ntargetPowerHt40.tPow2x[i];\r\n}\r\nratesArray[rateDupOfdm] = targetPowerHt40.tPow2x[0];\r\nratesArray[rateDupCck] = targetPowerHt40.tPow2x[0];\r\nratesArray[rateExtOfdm] = targetPowerOfdmExt.tPow2x[0];\r\nif (IS_CHAN_2GHZ(chan)) {\r\nratesArray[rateExtCck] =\r\ntargetPowerCckExt.tPow2x[0];\r\n}\r\n}\r\n}\r\nstatic void ath9k_hw_def_set_txpower(struct ath_hw *ah,\r\nstruct ath9k_channel *chan,\r\nu16 cfgCtl,\r\nu8 twiceAntennaReduction,\r\nu8 powerLimit, bool test)\r\n{\r\n#define RT_AR_DELTA(x) (ratesArray[x] - cck_ofdm_delta)\r\nstruct ath_regulatory *regulatory = ath9k_hw_regulatory(ah);\r\nstruct ar5416_eeprom_def *pEepData = &ah->eeprom.def;\r\nstruct modal_eep_header *pModal =\r\n&(pEepData->modalHeader[IS_CHAN_2GHZ(chan)]);\r\nint16_t ratesArray[Ar5416RateSize];\r\nu8 ht40PowerIncForPdadc = 2;\r\nint i, cck_ofdm_delta = 0;\r\nmemset(ratesArray, 0, sizeof(ratesArray));\r\nif ((pEepData->baseEepHeader.version & AR5416_EEP_VER_MINOR_MASK) >=\r\nAR5416_EEP_MINOR_VER_2) {\r\nht40PowerIncForPdadc = pModal->ht40PowerIncForPdadc;\r\n}\r\nath9k_hw_set_def_power_per_rate_table(ah, chan,\r\n&ratesArray[0], cfgCtl,\r\ntwiceAntennaReduction,\r\npowerLimit);\r\nath9k_hw_set_def_power_cal_table(ah, chan);\r\nregulatory->max_power_level = 0;\r\nfor (i = 0; i < ARRAY_SIZE(ratesArray); i++) {\r\nif (ratesArray[i] > MAX_RATE_POWER)\r\nratesArray[i] = MAX_RATE_POWER;\r\nif (ratesArray[i] > regulatory->max_power_level)\r\nregulatory->max_power_level = ratesArray[i];\r\n}\r\nath9k_hw_update_regulatory_maxpower(ah);\r\nif (test)\r\nreturn;\r\nif (AR_SREV_9280_20_OR_LATER(ah)) {\r\nfor (i = 0; i < Ar5416RateSize; i++) {\r\nint8_t pwr_table_offset;\r\npwr_table_offset = ah->eep_ops->get_eeprom(ah,\r\nEEP_PWR_TABLE_OFFSET);\r\nratesArray[i] -= pwr_table_offset * 2;\r\n}\r\n}\r\nENABLE_REGWRITE_BUFFER(ah);\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE1,\r\nATH9K_POW_SM(ratesArray[rate18mb], 24)\r\n| ATH9K_POW_SM(ratesArray[rate12mb], 16)\r\n| ATH9K_POW_SM(ratesArray[rate9mb], 8)\r\n| ATH9K_POW_SM(ratesArray[rate6mb], 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE2,\r\nATH9K_POW_SM(ratesArray[rate54mb], 24)\r\n| ATH9K_POW_SM(ratesArray[rate48mb], 16)\r\n| ATH9K_POW_SM(ratesArray[rate36mb], 8)\r\n| ATH9K_POW_SM(ratesArray[rate24mb], 0));\r\nif (IS_CHAN_2GHZ(chan)) {\r\nif (OLC_FOR_AR9280_20_LATER) {\r\ncck_ofdm_delta = 2;\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE3,\r\nATH9K_POW_SM(RT_AR_DELTA(rate2s), 24)\r\n| ATH9K_POW_SM(RT_AR_DELTA(rate2l), 16)\r\n| ATH9K_POW_SM(ratesArray[rateXr], 8)\r\n| ATH9K_POW_SM(RT_AR_DELTA(rate1l), 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE4,\r\nATH9K_POW_SM(RT_AR_DELTA(rate11s), 24)\r\n| ATH9K_POW_SM(RT_AR_DELTA(rate11l), 16)\r\n| ATH9K_POW_SM(RT_AR_DELTA(rate5_5s), 8)\r\n| ATH9K_POW_SM(RT_AR_DELTA(rate5_5l), 0));\r\n} else {\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE3,\r\nATH9K_POW_SM(ratesArray[rate2s], 24)\r\n| ATH9K_POW_SM(ratesArray[rate2l], 16)\r\n| ATH9K_POW_SM(ratesArray[rateXr], 8)\r\n| ATH9K_POW_SM(ratesArray[rate1l], 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE4,\r\nATH9K_POW_SM(ratesArray[rate11s], 24)\r\n| ATH9K_POW_SM(ratesArray[rate11l], 16)\r\n| ATH9K_POW_SM(ratesArray[rate5_5s], 8)\r\n| ATH9K_POW_SM(ratesArray[rate5_5l], 0));\r\n}\r\n}\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE5,\r\nATH9K_POW_SM(ratesArray[rateHt20_3], 24)\r\n| ATH9K_POW_SM(ratesArray[rateHt20_2], 16)\r\n| ATH9K_POW_SM(ratesArray[rateHt20_1], 8)\r\n| ATH9K_POW_SM(ratesArray[rateHt20_0], 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE6,\r\nATH9K_POW_SM(ratesArray[rateHt20_7], 24)\r\n| ATH9K_POW_SM(ratesArray[rateHt20_6], 16)\r\n| ATH9K_POW_SM(ratesArray[rateHt20_5], 8)\r\n| ATH9K_POW_SM(ratesArray[rateHt20_4], 0));\r\nif (IS_CHAN_HT40(chan)) {\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE7,\r\nATH9K_POW_SM(ratesArray[rateHt40_3] +\r\nht40PowerIncForPdadc, 24)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_2] +\r\nht40PowerIncForPdadc, 16)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_1] +\r\nht40PowerIncForPdadc, 8)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_0] +\r\nht40PowerIncForPdadc, 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE8,\r\nATH9K_POW_SM(ratesArray[rateHt40_7] +\r\nht40PowerIncForPdadc, 24)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_6] +\r\nht40PowerIncForPdadc, 16)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_5] +\r\nht40PowerIncForPdadc, 8)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_4] +\r\nht40PowerIncForPdadc, 0));\r\nif (OLC_FOR_AR9280_20_LATER) {\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE9,\r\nATH9K_POW_SM(ratesArray[rateExtOfdm], 24)\r\n| ATH9K_POW_SM(RT_AR_DELTA(rateExtCck), 16)\r\n| ATH9K_POW_SM(ratesArray[rateDupOfdm], 8)\r\n| ATH9K_POW_SM(RT_AR_DELTA(rateDupCck), 0));\r\n} else {\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE9,\r\nATH9K_POW_SM(ratesArray[rateExtOfdm], 24)\r\n| ATH9K_POW_SM(ratesArray[rateExtCck], 16)\r\n| ATH9K_POW_SM(ratesArray[rateDupOfdm], 8)\r\n| ATH9K_POW_SM(ratesArray[rateDupCck], 0));\r\n}\r\n}\r\nREG_WRITE(ah, AR_PHY_POWER_TX_SUB,\r\nATH9K_POW_SM(pModal->pwrDecreaseFor3Chain, 6)\r\n| ATH9K_POW_SM(pModal->pwrDecreaseFor2Chain, 0));\r\nif (ah->tpc_enabled) {\r\nint ht40_delta;\r\nht40_delta = (IS_CHAN_HT40(chan)) ? ht40PowerIncForPdadc : 0;\r\nar5008_hw_init_rate_txpower(ah, ratesArray, chan, ht40_delta);\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE_MAX,\r\nMAX_RATE_POWER | AR_PHY_POWER_TX_RATE_MAX_TPC_ENABLE);\r\n} else {\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE_MAX, MAX_RATE_POWER);\r\n}\r\nREGWRITE_BUFFER_FLUSH(ah);\r\n}\r\nstatic u16 ath9k_hw_def_get_spur_channel(struct ath_hw *ah, u16 i, bool is2GHz)\r\n{\r\nreturn ah->eeprom.def.modalHeader[is2GHz].spurChans[i].spurChan;\r\n}
