static void ebsa285_led_set(struct led_classdev *cdev,\r\nenum led_brightness b)\r\n{\r\nstruct ebsa285_led *led = container_of(cdev,\r\nstruct ebsa285_led, cdev);\r\nif (b == LED_OFF)\r\nhw_led_state |= led->mask;\r\nelse\r\nhw_led_state &= ~led->mask;\r\nwriteb(hw_led_state, xbus);\r\n}\r\nstatic enum led_brightness ebsa285_led_get(struct led_classdev *cdev)\r\n{\r\nstruct ebsa285_led *led = container_of(cdev,\r\nstruct ebsa285_led, cdev);\r\nreturn hw_led_state & led->mask ? LED_OFF : LED_FULL;\r\n}\r\nstatic int __init ebsa285_leds_init(void)\r\n{\r\nint i;\r\nif (!machine_is_ebsa285())\r\nreturn -ENODEV;\r\nxbus = ioremap(XBUS_CS2, SZ_4K);\r\nif (!xbus)\r\nreturn -ENOMEM;\r\nhw_led_state = XBUS_AMBER_L | XBUS_GREEN_L | XBUS_RED_L;\r\nwriteb(hw_led_state, xbus);\r\nfor (i = 0; i < ARRAY_SIZE(ebsa285_leds); i++) {\r\nstruct ebsa285_led *led;\r\nled = kzalloc(sizeof(*led), GFP_KERNEL);\r\nif (!led)\r\nbreak;\r\nled->cdev.name = ebsa285_leds[i].name;\r\nled->cdev.brightness_set = ebsa285_led_set;\r\nled->cdev.brightness_get = ebsa285_led_get;\r\nled->cdev.default_trigger = ebsa285_leds[i].trigger;\r\nled->mask = BIT(i);\r\nif (led_classdev_register(NULL, &led->cdev) < 0) {\r\nkfree(led);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}
