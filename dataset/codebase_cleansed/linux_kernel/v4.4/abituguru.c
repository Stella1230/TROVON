static int abituguru_wait(struct abituguru_data *data, u8 state)\r\n{\r\nint timeout = ABIT_UGURU_WAIT_TIMEOUT;\r\nwhile (inb_p(data->addr + ABIT_UGURU_DATA) != state) {\r\ntimeout--;\r\nif (timeout == 0)\r\nreturn -EBUSY;\r\nif (timeout <= ABIT_UGURU_WAIT_TIMEOUT_SLEEP)\r\nmsleep(0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int abituguru_ready(struct abituguru_data *data)\r\n{\r\nint timeout = ABIT_UGURU_READY_TIMEOUT;\r\nif (data->uguru_ready)\r\nreturn 0;\r\noutb(0x00, data->addr + ABIT_UGURU_DATA);\r\nif (abituguru_wait(data, ABIT_UGURU_STATUS_READY)) {\r\nABIT_UGURU_DEBUG(1,\r\n"timeout exceeded waiting for ready state\n");\r\nreturn -EIO;\r\n}\r\nwhile (inb_p(data->addr + ABIT_UGURU_CMD) != 0xAC) {\r\ntimeout--;\r\nif (timeout == 0) {\r\nABIT_UGURU_DEBUG(1,\r\n"CMD reg does not hold 0xAC after ready command\n");\r\nreturn -EIO;\r\n}\r\nmsleep(0);\r\n}\r\ntimeout = ABIT_UGURU_READY_TIMEOUT;\r\nwhile (inb_p(data->addr + ABIT_UGURU_DATA) != ABIT_UGURU_STATUS_INPUT) {\r\ntimeout--;\r\nif (timeout == 0) {\r\nABIT_UGURU_DEBUG(1,\r\n"state != more input after ready command\n");\r\nreturn -EIO;\r\n}\r\nmsleep(0);\r\n}\r\ndata->uguru_ready = 1;\r\nreturn 0;\r\n}\r\nstatic int abituguru_send_address(struct abituguru_data *data,\r\nu8 bank_addr, u8 sensor_addr, int retries)\r\n{\r\nint report_errors = retries;\r\nfor (;;) {\r\nif (abituguru_ready(data) != 0)\r\nreturn -EIO;\r\noutb(bank_addr, data->addr + ABIT_UGURU_DATA);\r\ndata->uguru_ready = 0;\r\nif (abituguru_wait(data, ABIT_UGURU_STATUS_INPUT)) {\r\nif (retries) {\r\nABIT_UGURU_DEBUG(3, "timeout exceeded "\r\n"waiting for more input state, %d "\r\n"tries remaining\n", retries);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(ABIT_UGURU_RETRY_DELAY);\r\nretries--;\r\ncontinue;\r\n}\r\nif (report_errors)\r\nABIT_UGURU_DEBUG(1, "timeout exceeded "\r\n"waiting for more input state "\r\n"(bank: %d)\n", (int)bank_addr);\r\nreturn -EBUSY;\r\n}\r\noutb(sensor_addr, data->addr + ABIT_UGURU_CMD);\r\nreturn 0;\r\n}\r\n}\r\nstatic int abituguru_read(struct abituguru_data *data,\r\nu8 bank_addr, u8 sensor_addr, u8 *buf, int count, int retries)\r\n{\r\nint i;\r\ni = abituguru_send_address(data, bank_addr, sensor_addr, retries);\r\nif (i)\r\nreturn i;\r\nfor (i = 0; i < count; i++) {\r\nif (abituguru_wait(data, ABIT_UGURU_STATUS_READ)) {\r\nABIT_UGURU_DEBUG(retries ? 1 : 3,\r\n"timeout exceeded waiting for "\r\n"read state (bank: %d, sensor: %d)\n",\r\n(int)bank_addr, (int)sensor_addr);\r\nbreak;\r\n}\r\nbuf[i] = inb(data->addr + ABIT_UGURU_CMD);\r\n}\r\nabituguru_ready(data);\r\nreturn i;\r\n}\r\nstatic int abituguru_write(struct abituguru_data *data,\r\nu8 bank_addr, u8 sensor_addr, u8 *buf, int count)\r\n{\r\nint i, timeout = ABIT_UGURU_READY_TIMEOUT;\r\ni = abituguru_send_address(data, bank_addr, sensor_addr,\r\nABIT_UGURU_MAX_RETRIES);\r\nif (i)\r\nreturn i;\r\nfor (i = 0; i < count; i++) {\r\nif (abituguru_wait(data, ABIT_UGURU_STATUS_WRITE)) {\r\nABIT_UGURU_DEBUG(1, "timeout exceeded waiting for "\r\n"write state (bank: %d, sensor: %d)\n",\r\n(int)bank_addr, (int)sensor_addr);\r\nbreak;\r\n}\r\noutb(buf[i], data->addr + ABIT_UGURU_CMD);\r\n}\r\nif (abituguru_wait(data, ABIT_UGURU_STATUS_READ)) {\r\nABIT_UGURU_DEBUG(1, "timeout exceeded waiting for read state "\r\n"after write (bank: %d, sensor: %d)\n", (int)bank_addr,\r\n(int)sensor_addr);\r\nreturn -EIO;\r\n}\r\nwhile (inb_p(data->addr + ABIT_UGURU_CMD) != 0xAC) {\r\ntimeout--;\r\nif (timeout == 0) {\r\nABIT_UGURU_DEBUG(1, "CMD reg does not hold 0xAC after "\r\n"write (bank: %d, sensor: %d)\n",\r\n(int)bank_addr, (int)sensor_addr);\r\nreturn -EIO;\r\n}\r\nmsleep(0);\r\n}\r\nabituguru_ready(data);\r\nreturn i;\r\n}\r\nstatic int\r\nabituguru_detect_bank1_sensor_type(struct abituguru_data *data,\r\nu8 sensor_addr)\r\n{\r\nu8 val, test_flag, buf[3];\r\nint i, ret = -ENODEV;\r\nif (bank1_types[sensor_addr] >= ABIT_UGURU_IN_SENSOR &&\r\nbank1_types[sensor_addr] <= ABIT_UGURU_NC) {\r\nABIT_UGURU_DEBUG(2, "assuming sensor type %d for bank1 sensor "\r\n"%d because of \"bank1_types\" module param\n",\r\nbank1_types[sensor_addr], (int)sensor_addr);\r\nreturn bank1_types[sensor_addr];\r\n}\r\nif (abituguru_read(data, ABIT_UGURU_SENSOR_BANK1, sensor_addr, &val,\r\n1, ABIT_UGURU_MAX_RETRIES) != 1)\r\nreturn -ENODEV;\r\nif ((val < 10u) || (val > 250u)) {\r\npr_warn("bank1-sensor: %d reading (%d) too close to limits, "\r\n"unable to determine sensor type, skipping sensor\n",\r\n(int)sensor_addr, (int)val);\r\nreturn ABIT_UGURU_NC;\r\n}\r\nABIT_UGURU_DEBUG(2, "testing bank1 sensor %d\n", (int)sensor_addr);\r\nif (val <= 240u) {\r\nbuf[0] = ABIT_UGURU_VOLT_LOW_ALARM_ENABLE;\r\nbuf[1] = 245;\r\nbuf[2] = 250;\r\ntest_flag = ABIT_UGURU_VOLT_LOW_ALARM_FLAG;\r\n} else {\r\nbuf[0] = ABIT_UGURU_VOLT_HIGH_ALARM_ENABLE;\r\nbuf[1] = 5;\r\nbuf[2] = 10;\r\ntest_flag = ABIT_UGURU_VOLT_HIGH_ALARM_FLAG;\r\n}\r\nif (abituguru_write(data, ABIT_UGURU_SENSOR_BANK1 + 2, sensor_addr,\r\nbuf, 3) != 3)\r\ngoto abituguru_detect_bank1_sensor_type_exit;\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(HZ/50);\r\nif (abituguru_read(data, ABIT_UGURU_ALARM_BANK, 0, buf, 3,\r\nABIT_UGURU_MAX_RETRIES) != 3)\r\ngoto abituguru_detect_bank1_sensor_type_exit;\r\nif (buf[sensor_addr/8] & (0x01 << (sensor_addr % 8))) {\r\nif (abituguru_read(data, ABIT_UGURU_SENSOR_BANK1 + 1,\r\nsensor_addr, buf, 3,\r\nABIT_UGURU_MAX_RETRIES) != 3)\r\ngoto abituguru_detect_bank1_sensor_type_exit;\r\nif (buf[0] & test_flag) {\r\nABIT_UGURU_DEBUG(2, " found volt sensor\n");\r\nret = ABIT_UGURU_IN_SENSOR;\r\ngoto abituguru_detect_bank1_sensor_type_exit;\r\n} else\r\nABIT_UGURU_DEBUG(2, " alarm raised during volt "\r\n"sensor test, but volt range flag not set\n");\r\n} else\r\nABIT_UGURU_DEBUG(2, " alarm not raised during volt sensor "\r\n"test\n");\r\nbuf[0] = ABIT_UGURU_TEMP_HIGH_ALARM_ENABLE;\r\nbuf[1] = 5;\r\nbuf[2] = 10;\r\nif (abituguru_write(data, ABIT_UGURU_SENSOR_BANK1 + 2, sensor_addr,\r\nbuf, 3) != 3)\r\ngoto abituguru_detect_bank1_sensor_type_exit;\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(HZ/20);\r\nif (abituguru_read(data, ABIT_UGURU_ALARM_BANK, 0, buf, 3,\r\nABIT_UGURU_MAX_RETRIES) != 3)\r\ngoto abituguru_detect_bank1_sensor_type_exit;\r\nif (buf[sensor_addr/8] & (0x01 << (sensor_addr % 8))) {\r\nif (abituguru_read(data, ABIT_UGURU_SENSOR_BANK1 + 1,\r\nsensor_addr, buf, 3,\r\nABIT_UGURU_MAX_RETRIES) != 3)\r\ngoto abituguru_detect_bank1_sensor_type_exit;\r\nif (buf[0] & ABIT_UGURU_TEMP_HIGH_ALARM_FLAG) {\r\nABIT_UGURU_DEBUG(2, " found temp sensor\n");\r\nret = ABIT_UGURU_TEMP_SENSOR;\r\ngoto abituguru_detect_bank1_sensor_type_exit;\r\n} else\r\nABIT_UGURU_DEBUG(2, " alarm raised during temp "\r\n"sensor test, but temp high flag not set\n");\r\n} else\r\nABIT_UGURU_DEBUG(2, " alarm not raised during temp sensor "\r\n"test\n");\r\nret = ABIT_UGURU_NC;\r\nabituguru_detect_bank1_sensor_type_exit:\r\nfor (i = 0; i < 3; i++)\r\nif (abituguru_write(data, ABIT_UGURU_SENSOR_BANK1 + 2,\r\nsensor_addr, data->bank1_settings[sensor_addr],\r\n3) == 3)\r\nbreak;\r\nif (i == 3) {\r\npr_err("Fatal error could not restore original settings. %s %s\n",\r\nnever_happen, report_this);\r\nreturn -ENODEV;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nabituguru_detect_no_bank2_sensors(struct abituguru_data *data)\r\n{\r\nint i;\r\nif (fan_sensors > 0 && fan_sensors <= ABIT_UGURU_MAX_BANK2_SENSORS) {\r\ndata->bank2_sensors = fan_sensors;\r\nABIT_UGURU_DEBUG(2, "assuming %d fan sensors because of "\r\n"\"fan_sensors\" module param\n",\r\n(int)data->bank2_sensors);\r\nreturn;\r\n}\r\nABIT_UGURU_DEBUG(2, "detecting number of fan sensors\n");\r\nfor (i = 0; i < ABIT_UGURU_MAX_BANK2_SENSORS; i++) {\r\nif (data->bank2_settings[i][0] & ~0xC9) {\r\nABIT_UGURU_DEBUG(2, " bank2 sensor %d does not seem "\r\n"to be a fan sensor: settings[0] = %02X\n",\r\ni, (unsigned int)data->bank2_settings[i][0]);\r\nbreak;\r\n}\r\nif (data->bank2_settings[i][1] <\r\nabituguru_bank2_min_threshold) {\r\nABIT_UGURU_DEBUG(2, " bank2 sensor %d does not seem "\r\n"to be a fan sensor: the threshold (%d) is "\r\n"below the minimum (%d)\n", i,\r\n(int)data->bank2_settings[i][1],\r\n(int)abituguru_bank2_min_threshold);\r\nbreak;\r\n}\r\nif (data->bank2_settings[i][1] >\r\nabituguru_bank2_max_threshold) {\r\nABIT_UGURU_DEBUG(2, " bank2 sensor %d does not seem "\r\n"to be a fan sensor: the threshold (%d) is "\r\n"above the maximum (%d)\n", i,\r\n(int)data->bank2_settings[i][1],\r\n(int)abituguru_bank2_max_threshold);\r\nbreak;\r\n}\r\n}\r\ndata->bank2_sensors = i;\r\nABIT_UGURU_DEBUG(2, " found: %d fan sensors\n",\r\n(int)data->bank2_sensors);\r\n}\r\nstatic void\r\nabituguru_detect_no_pwms(struct abituguru_data *data)\r\n{\r\nint i, j;\r\nif (pwms > 0 && pwms <= ABIT_UGURU_MAX_PWMS) {\r\ndata->pwms = pwms;\r\nABIT_UGURU_DEBUG(2, "assuming %d PWM outputs because of "\r\n"\"pwms\" module param\n", (int)data->pwms);\r\nreturn;\r\n}\r\nABIT_UGURU_DEBUG(2, "detecting number of PWM outputs\n");\r\nfor (i = 0; i < ABIT_UGURU_MAX_PWMS; i++) {\r\nif (data->pwm_settings[i][0] & ~0x8F) {\r\nABIT_UGURU_DEBUG(2, " pwm channel %d does not seem "\r\n"to be a pwm channel: settings[0] = %02X\n",\r\ni, (unsigned int)data->pwm_settings[i][0]);\r\nbreak;\r\n}\r\nfor (j = 0; j < data->bank1_sensors[ABIT_UGURU_TEMP_SENSOR];\r\nj++) {\r\nif (data->bank1_address[ABIT_UGURU_TEMP_SENSOR][j] ==\r\n(data->pwm_settings[i][0] & 0x0F))\r\nbreak;\r\n}\r\nif (j == data->bank1_sensors[ABIT_UGURU_TEMP_SENSOR]) {\r\nABIT_UGURU_DEBUG(2, " pwm channel %d does not seem "\r\n"to be a pwm channel: %d is not a valid temp "\r\n"sensor address\n", i,\r\ndata->pwm_settings[i][0] & 0x0F);\r\nbreak;\r\n}\r\nfor (j = 1; j < 5; j++) {\r\nu8 min;\r\nif ((i == 0) && ((j == 1) || (j == 2)))\r\nmin = 77;\r\nelse\r\nmin = abituguru_pwm_min[j];\r\nif (data->pwm_settings[i][j] < min) {\r\nABIT_UGURU_DEBUG(2, " pwm channel %d does "\r\n"not seem to be a pwm channel: "\r\n"setting %d (%d) is below the minimum "\r\n"value (%d)\n", i, j,\r\n(int)data->pwm_settings[i][j],\r\n(int)min);\r\ngoto abituguru_detect_no_pwms_exit;\r\n}\r\nif (data->pwm_settings[i][j] > abituguru_pwm_max[j]) {\r\nABIT_UGURU_DEBUG(2, " pwm channel %d does "\r\n"not seem to be a pwm channel: "\r\n"setting %d (%d) is above the maximum "\r\n"value (%d)\n", i, j,\r\n(int)data->pwm_settings[i][j],\r\n(int)abituguru_pwm_max[j]);\r\ngoto abituguru_detect_no_pwms_exit;\r\n}\r\n}\r\nif (data->pwm_settings[i][1] >= data->pwm_settings[i][2]) {\r\nABIT_UGURU_DEBUG(2, " pwm channel %d does not seem "\r\n"to be a pwm channel: min pwm (%d) >= "\r\n"max pwm (%d)\n", i,\r\n(int)data->pwm_settings[i][1],\r\n(int)data->pwm_settings[i][2]);\r\nbreak;\r\n}\r\nif (data->pwm_settings[i][3] >= data->pwm_settings[i][4]) {\r\nABIT_UGURU_DEBUG(2, " pwm channel %d does not seem "\r\n"to be a pwm channel: min temp (%d) >= "\r\n"max temp (%d)\n", i,\r\n(int)data->pwm_settings[i][3],\r\n(int)data->pwm_settings[i][4]);\r\nbreak;\r\n}\r\n}\r\nabituguru_detect_no_pwms_exit:\r\ndata->pwms = i;\r\nABIT_UGURU_DEBUG(2, " found: %d PWM outputs\n", (int)data->pwms);\r\n}\r\nstatic ssize_t show_bank1_value(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct abituguru_data *data = abituguru_update_device(dev);\r\nif (!data)\r\nreturn -EIO;\r\nreturn sprintf(buf, "%d\n", (data->bank1_value[attr->index] *\r\ndata->bank1_max_value[attr->index] + 128) / 255);\r\n}\r\nstatic ssize_t show_bank1_setting(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct abituguru_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n",\r\n(data->bank1_settings[attr->index][attr->nr] *\r\ndata->bank1_max_value[attr->index] + 128) / 255);\r\n}\r\nstatic ssize_t show_bank2_value(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct abituguru_data *data = abituguru_update_device(dev);\r\nif (!data)\r\nreturn -EIO;\r\nreturn sprintf(buf, "%d\n", (data->bank2_value[attr->index] *\r\nABIT_UGURU_FAN_MAX + 128) / 255);\r\n}\r\nstatic ssize_t show_bank2_setting(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct abituguru_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n",\r\n(data->bank2_settings[attr->index][attr->nr] *\r\nABIT_UGURU_FAN_MAX + 128) / 255);\r\n}\r\nstatic ssize_t store_bank1_setting(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct abituguru_data *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nssize_t ret;\r\nret = kstrtoul(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nret = count;\r\nval = (val * 255 + data->bank1_max_value[attr->index] / 2) /\r\ndata->bank1_max_value[attr->index];\r\nif (val > 255)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nif (data->bank1_settings[attr->index][attr->nr] != val) {\r\nu8 orig_val = data->bank1_settings[attr->index][attr->nr];\r\ndata->bank1_settings[attr->index][attr->nr] = val;\r\nif (abituguru_write(data, ABIT_UGURU_SENSOR_BANK1 + 2,\r\nattr->index, data->bank1_settings[attr->index],\r\n3) <= attr->nr) {\r\ndata->bank1_settings[attr->index][attr->nr] = orig_val;\r\nret = -EIO;\r\n}\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t store_bank2_setting(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct abituguru_data *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nssize_t ret;\r\nret = kstrtoul(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nret = count;\r\nval = (val * 255 + ABIT_UGURU_FAN_MAX / 2) / ABIT_UGURU_FAN_MAX;\r\nif (val < abituguru_bank2_min_threshold ||\r\nval > abituguru_bank2_max_threshold)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nif (data->bank2_settings[attr->index][attr->nr] != val) {\r\nu8 orig_val = data->bank2_settings[attr->index][attr->nr];\r\ndata->bank2_settings[attr->index][attr->nr] = val;\r\nif (abituguru_write(data, ABIT_UGURU_SENSOR_BANK2 + 2,\r\nattr->index, data->bank2_settings[attr->index],\r\n2) <= attr->nr) {\r\ndata->bank2_settings[attr->index][attr->nr] = orig_val;\r\nret = -EIO;\r\n}\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_bank1_alarm(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct abituguru_data *data = abituguru_update_device(dev);\r\nif (!data)\r\nreturn -EIO;\r\nif ((data->alarms[attr->index / 8] & (0x01 << (attr->index % 8))) &&\r\n(data->bank1_settings[attr->index][0] & attr->nr))\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t show_bank2_alarm(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct abituguru_data *data = abituguru_update_device(dev);\r\nif (!data)\r\nreturn -EIO;\r\nif (data->alarms[2] & (0x01 << attr->index))\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t show_bank1_mask(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct abituguru_data *data = dev_get_drvdata(dev);\r\nif (data->bank1_settings[attr->index][0] & attr->nr)\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t show_bank2_mask(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct abituguru_data *data = dev_get_drvdata(dev);\r\nif (data->bank2_settings[attr->index][0] & attr->nr)\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t store_bank1_mask(struct device *dev,\r\nstruct device_attribute *devattr, const char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct abituguru_data *data = dev_get_drvdata(dev);\r\nssize_t ret;\r\nu8 orig_val;\r\nunsigned long mask;\r\nret = kstrtoul(buf, 10, &mask);\r\nif (ret)\r\nreturn ret;\r\nret = count;\r\nmutex_lock(&data->update_lock);\r\norig_val = data->bank1_settings[attr->index][0];\r\nif (mask)\r\ndata->bank1_settings[attr->index][0] |= attr->nr;\r\nelse\r\ndata->bank1_settings[attr->index][0] &= ~attr->nr;\r\nif ((data->bank1_settings[attr->index][0] != orig_val) &&\r\n(abituguru_write(data,\r\nABIT_UGURU_SENSOR_BANK1 + 2, attr->index,\r\ndata->bank1_settings[attr->index], 3) < 1)) {\r\ndata->bank1_settings[attr->index][0] = orig_val;\r\nret = -EIO;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t store_bank2_mask(struct device *dev,\r\nstruct device_attribute *devattr, const char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct abituguru_data *data = dev_get_drvdata(dev);\r\nssize_t ret;\r\nu8 orig_val;\r\nunsigned long mask;\r\nret = kstrtoul(buf, 10, &mask);\r\nif (ret)\r\nreturn ret;\r\nret = count;\r\nmutex_lock(&data->update_lock);\r\norig_val = data->bank2_settings[attr->index][0];\r\nif (mask)\r\ndata->bank2_settings[attr->index][0] |= attr->nr;\r\nelse\r\ndata->bank2_settings[attr->index][0] &= ~attr->nr;\r\nif ((data->bank2_settings[attr->index][0] != orig_val) &&\r\n(abituguru_write(data,\r\nABIT_UGURU_SENSOR_BANK2 + 2, attr->index,\r\ndata->bank2_settings[attr->index], 2) < 1)) {\r\ndata->bank2_settings[attr->index][0] = orig_val;\r\nret = -EIO;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_pwm_setting(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct abituguru_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm_settings[attr->index][attr->nr] *\r\nabituguru_pwm_settings_multiplier[attr->nr]);\r\n}\r\nstatic ssize_t store_pwm_setting(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct abituguru_data *data = dev_get_drvdata(dev);\r\nu8 min;\r\nunsigned long val;\r\nssize_t ret;\r\nret = kstrtoul(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nret = count;\r\nval = (val + abituguru_pwm_settings_multiplier[attr->nr] / 2) /\r\nabituguru_pwm_settings_multiplier[attr->nr];\r\nif ((attr->index == 0) && ((attr->nr == 1) || (attr->nr == 2)))\r\nmin = 77;\r\nelse\r\nmin = abituguru_pwm_min[attr->nr];\r\nif (val < min || val > abituguru_pwm_max[attr->nr])\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nif ((attr->nr & 1) &&\r\n(val >= data->pwm_settings[attr->index][attr->nr + 1]))\r\nret = -EINVAL;\r\nelse if (!(attr->nr & 1) &&\r\n(val <= data->pwm_settings[attr->index][attr->nr - 1]))\r\nret = -EINVAL;\r\nelse if (data->pwm_settings[attr->index][attr->nr] != val) {\r\nu8 orig_val = data->pwm_settings[attr->index][attr->nr];\r\ndata->pwm_settings[attr->index][attr->nr] = val;\r\nif (abituguru_write(data, ABIT_UGURU_FAN_PWM + 1,\r\nattr->index, data->pwm_settings[attr->index],\r\n5) <= attr->nr) {\r\ndata->pwm_settings[attr->index][attr->nr] =\r\norig_val;\r\nret = -EIO;\r\n}\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_pwm_sensor(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct abituguru_data *data = dev_get_drvdata(dev);\r\nint i;\r\nfor (i = 0; i < data->bank1_sensors[ABIT_UGURU_TEMP_SENSOR]; i++)\r\nif (data->bank1_address[ABIT_UGURU_TEMP_SENSOR][i] ==\r\n(data->pwm_settings[attr->index][0] & 0x0F))\r\nreturn sprintf(buf, "%d\n", i+1);\r\nreturn -ENXIO;\r\n}\r\nstatic ssize_t store_pwm_sensor(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct abituguru_data *data = dev_get_drvdata(dev);\r\nssize_t ret;\r\nunsigned long val;\r\nu8 orig_val;\r\nu8 address;\r\nret = kstrtoul(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val == 0 || val > data->bank1_sensors[ABIT_UGURU_TEMP_SENSOR])\r\nreturn -EINVAL;\r\nval -= 1;\r\nret = count;\r\nmutex_lock(&data->update_lock);\r\norig_val = data->pwm_settings[attr->index][0];\r\naddress = data->bank1_address[ABIT_UGURU_TEMP_SENSOR][val];\r\ndata->pwm_settings[attr->index][0] &= 0xF0;\r\ndata->pwm_settings[attr->index][0] |= address;\r\nif (data->pwm_settings[attr->index][0] != orig_val) {\r\nif (abituguru_write(data, ABIT_UGURU_FAN_PWM + 1, attr->index,\r\ndata->pwm_settings[attr->index], 5) < 1) {\r\ndata->pwm_settings[attr->index][0] = orig_val;\r\nret = -EIO;\r\n}\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_pwm_enable(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct abituguru_data *data = dev_get_drvdata(dev);\r\nint res = 0;\r\nif (data->pwm_settings[attr->index][0] & ABIT_UGURU_FAN_PWM_ENABLE)\r\nres = 2;\r\nreturn sprintf(buf, "%d\n", res);\r\n}\r\nstatic ssize_t store_pwm_enable(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct abituguru_data *data = dev_get_drvdata(dev);\r\nu8 orig_val;\r\nssize_t ret;\r\nunsigned long user_val;\r\nret = kstrtoul(buf, 10, &user_val);\r\nif (ret)\r\nreturn ret;\r\nret = count;\r\nmutex_lock(&data->update_lock);\r\norig_val = data->pwm_settings[attr->index][0];\r\nswitch (user_val) {\r\ncase 0:\r\ndata->pwm_settings[attr->index][0] &=\r\n~ABIT_UGURU_FAN_PWM_ENABLE;\r\nbreak;\r\ncase 2:\r\ndata->pwm_settings[attr->index][0] |= ABIT_UGURU_FAN_PWM_ENABLE;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif ((data->pwm_settings[attr->index][0] != orig_val) &&\r\n(abituguru_write(data, ABIT_UGURU_FAN_PWM + 1,\r\nattr->index, data->pwm_settings[attr->index],\r\n5) < 1)) {\r\ndata->pwm_settings[attr->index][0] = orig_val;\r\nret = -EIO;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_name(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nreturn sprintf(buf, "%s\n", ABIT_UGURU_NAME);\r\n}\r\nstatic int abituguru_probe(struct platform_device *pdev)\r\n{\r\nstruct abituguru_data *data;\r\nint i, j, used, sysfs_names_free, sysfs_attr_i, res = -ENODEV;\r\nchar *sysfs_filename;\r\nconst u8 probe_order[ABIT_UGURU_MAX_BANK1_SENSORS] = {\r\n0x00, 0x01, 0x03, 0x04, 0x0A, 0x08, 0x0E, 0x02,\r\n0x09, 0x06, 0x05, 0x0B, 0x0F, 0x0D, 0x07, 0x0C };\r\ndata = devm_kzalloc(&pdev->dev, sizeof(struct abituguru_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->addr = platform_get_resource(pdev, IORESOURCE_IO, 0)->start;\r\nmutex_init(&data->update_lock);\r\nplatform_set_drvdata(pdev, data);\r\nif (inb_p(data->addr + ABIT_UGURU_DATA) == ABIT_UGURU_STATUS_INPUT)\r\ndata->uguru_ready = 1;\r\nif (abituguru_read(data, ABIT_UGURU_ALARM_BANK, 0,\r\ndata->alarms, 3, ABIT_UGURU_MAX_RETRIES) != 3)\r\ngoto abituguru_probe_error;\r\nfor (i = 0; i < ABIT_UGURU_MAX_BANK1_SENSORS; i++) {\r\nif (abituguru_read(data, ABIT_UGURU_SENSOR_BANK1, i,\r\n&data->bank1_value[i], 1,\r\nABIT_UGURU_MAX_RETRIES) != 1)\r\ngoto abituguru_probe_error;\r\nif (abituguru_read(data, ABIT_UGURU_SENSOR_BANK1+1, i,\r\ndata->bank1_settings[i], 3,\r\nABIT_UGURU_MAX_RETRIES) != 3)\r\ngoto abituguru_probe_error;\r\n}\r\nfor (i = 0; i < ABIT_UGURU_MAX_BANK2_SENSORS; i++) {\r\nif (abituguru_read(data, ABIT_UGURU_SENSOR_BANK2, i,\r\n&data->bank2_value[i], 1,\r\nABIT_UGURU_MAX_RETRIES) != 1)\r\ngoto abituguru_probe_error;\r\nif (abituguru_read(data, ABIT_UGURU_SENSOR_BANK2+1, i,\r\ndata->bank2_settings[i], 2,\r\nABIT_UGURU_MAX_RETRIES) != 2)\r\ngoto abituguru_probe_error;\r\n}\r\nfor (i = 0; i < ABIT_UGURU_MAX_PWMS; i++) {\r\nif (abituguru_read(data, ABIT_UGURU_FAN_PWM, i,\r\ndata->pwm_settings[i], 5,\r\nABIT_UGURU_MAX_RETRIES) != 5)\r\ngoto abituguru_probe_error;\r\n}\r\ndata->last_updated = jiffies;\r\nsysfs_attr_i = 0;\r\nsysfs_filename = data->sysfs_names;\r\nsysfs_names_free = ABITUGURU_SYSFS_NAMES_LENGTH;\r\nfor (i = 0; i < ABIT_UGURU_MAX_BANK1_SENSORS; i++) {\r\nres = abituguru_detect_bank1_sensor_type(data, probe_order[i]);\r\nif (res < 0)\r\ngoto abituguru_probe_error;\r\nif (res == ABIT_UGURU_NC)\r\ncontinue;\r\nfor (j = 0; j < (res ? 7 : 9); j++) {\r\nused = snprintf(sysfs_filename, sysfs_names_free,\r\nabituguru_sysfs_bank1_templ[res][j].dev_attr.\r\nattr.name, data->bank1_sensors[res] + res)\r\n+ 1;\r\ndata->sysfs_attr[sysfs_attr_i] =\r\nabituguru_sysfs_bank1_templ[res][j];\r\ndata->sysfs_attr[sysfs_attr_i].dev_attr.attr.name =\r\nsysfs_filename;\r\ndata->sysfs_attr[sysfs_attr_i].index = probe_order[i];\r\nsysfs_filename += used;\r\nsysfs_names_free -= used;\r\nsysfs_attr_i++;\r\n}\r\ndata->bank1_max_value[probe_order[i]] =\r\nabituguru_bank1_max_value[res];\r\ndata->bank1_address[res][data->bank1_sensors[res]] =\r\nprobe_order[i];\r\ndata->bank1_sensors[res]++;\r\n}\r\nabituguru_detect_no_bank2_sensors(data);\r\nfor (i = 0; i < data->bank2_sensors; i++) {\r\nfor (j = 0; j < ARRAY_SIZE(abituguru_sysfs_fan_templ); j++) {\r\nused = snprintf(sysfs_filename, sysfs_names_free,\r\nabituguru_sysfs_fan_templ[j].dev_attr.attr.name,\r\ni + 1) + 1;\r\ndata->sysfs_attr[sysfs_attr_i] =\r\nabituguru_sysfs_fan_templ[j];\r\ndata->sysfs_attr[sysfs_attr_i].dev_attr.attr.name =\r\nsysfs_filename;\r\ndata->sysfs_attr[sysfs_attr_i].index = i;\r\nsysfs_filename += used;\r\nsysfs_names_free -= used;\r\nsysfs_attr_i++;\r\n}\r\n}\r\nabituguru_detect_no_pwms(data);\r\nfor (i = 0; i < data->pwms; i++) {\r\nfor (j = 0; j < ARRAY_SIZE(abituguru_sysfs_pwm_templ); j++) {\r\nused = snprintf(sysfs_filename, sysfs_names_free,\r\nabituguru_sysfs_pwm_templ[j].dev_attr.attr.name,\r\ni + 1) + 1;\r\ndata->sysfs_attr[sysfs_attr_i] =\r\nabituguru_sysfs_pwm_templ[j];\r\ndata->sysfs_attr[sysfs_attr_i].dev_attr.attr.name =\r\nsysfs_filename;\r\ndata->sysfs_attr[sysfs_attr_i].index = i;\r\nsysfs_filename += used;\r\nsysfs_names_free -= used;\r\nsysfs_attr_i++;\r\n}\r\n}\r\nif (sysfs_names_free < 0) {\r\npr_err("Fatal error ran out of space for sysfs attr names. %s %s",\r\nnever_happen, report_this);\r\nres = -ENAMETOOLONG;\r\ngoto abituguru_probe_error;\r\n}\r\npr_info("found Abit uGuru\n");\r\nfor (i = 0; i < sysfs_attr_i; i++) {\r\nres = device_create_file(&pdev->dev,\r\n&data->sysfs_attr[i].dev_attr);\r\nif (res)\r\ngoto abituguru_probe_error;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(abituguru_sysfs_attr); i++) {\r\nres = device_create_file(&pdev->dev,\r\n&abituguru_sysfs_attr[i].dev_attr);\r\nif (res)\r\ngoto abituguru_probe_error;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&pdev->dev);\r\nif (!IS_ERR(data->hwmon_dev))\r\nreturn 0;\r\nres = PTR_ERR(data->hwmon_dev);\r\nabituguru_probe_error:\r\nfor (i = 0; data->sysfs_attr[i].dev_attr.attr.name; i++)\r\ndevice_remove_file(&pdev->dev, &data->sysfs_attr[i].dev_attr);\r\nfor (i = 0; i < ARRAY_SIZE(abituguru_sysfs_attr); i++)\r\ndevice_remove_file(&pdev->dev,\r\n&abituguru_sysfs_attr[i].dev_attr);\r\nreturn res;\r\n}\r\nstatic int abituguru_remove(struct platform_device *pdev)\r\n{\r\nint i;\r\nstruct abituguru_data *data = platform_get_drvdata(pdev);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nfor (i = 0; data->sysfs_attr[i].dev_attr.attr.name; i++)\r\ndevice_remove_file(&pdev->dev, &data->sysfs_attr[i].dev_attr);\r\nfor (i = 0; i < ARRAY_SIZE(abituguru_sysfs_attr); i++)\r\ndevice_remove_file(&pdev->dev,\r\n&abituguru_sysfs_attr[i].dev_attr);\r\nreturn 0;\r\n}\r\nstatic struct abituguru_data *abituguru_update_device(struct device *dev)\r\n{\r\nint i, err;\r\nstruct abituguru_data *data = dev_get_drvdata(dev);\r\nchar success = 1;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ)) {\r\nsuccess = 0;\r\nerr = abituguru_read(data, ABIT_UGURU_ALARM_BANK, 0,\r\ndata->alarms, 3, 0);\r\nif (err != 3)\r\ngoto LEAVE_UPDATE;\r\nfor (i = 0; i < ABIT_UGURU_MAX_BANK1_SENSORS; i++) {\r\nerr = abituguru_read(data, ABIT_UGURU_SENSOR_BANK1,\r\ni, &data->bank1_value[i], 1, 0);\r\nif (err != 1)\r\ngoto LEAVE_UPDATE;\r\nerr = abituguru_read(data, ABIT_UGURU_SENSOR_BANK1 + 1,\r\ni, data->bank1_settings[i], 3, 0);\r\nif (err != 3)\r\ngoto LEAVE_UPDATE;\r\n}\r\nfor (i = 0; i < data->bank2_sensors; i++) {\r\nerr = abituguru_read(data, ABIT_UGURU_SENSOR_BANK2, i,\r\n&data->bank2_value[i], 1, 0);\r\nif (err != 1)\r\ngoto LEAVE_UPDATE;\r\n}\r\nsuccess = 1;\r\ndata->update_timeouts = 0;\r\nLEAVE_UPDATE:\r\nif (!success && (err == -EBUSY || err >= 0)) {\r\nif (data->update_timeouts < 255u)\r\ndata->update_timeouts++;\r\nif (data->update_timeouts <= ABIT_UGURU_MAX_TIMEOUTS) {\r\nABIT_UGURU_DEBUG(3, "timeout exceeded, will "\r\n"try again next update\n");\r\nsuccess = 1;\r\n} else\r\nABIT_UGURU_DEBUG(1, "timeout exceeded %d "\r\n"times waiting for more input state\n",\r\n(int)data->update_timeouts);\r\n}\r\nif (success)\r\ndata->last_updated = jiffies;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nif (success)\r\nreturn data;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic int abituguru_suspend(struct device *dev)\r\n{\r\nstruct abituguru_data *data = dev_get_drvdata(dev);\r\nmutex_lock(&data->update_lock);\r\nreturn 0;\r\n}\r\nstatic int abituguru_resume(struct device *dev)\r\n{\r\nstruct abituguru_data *data = dev_get_drvdata(dev);\r\nif (inb_p(data->addr + ABIT_UGURU_DATA) != ABIT_UGURU_STATUS_INPUT)\r\ndata->uguru_ready = 0;\r\nmutex_unlock(&data->update_lock);\r\nreturn 0;\r\n}\r\nstatic int __init abituguru_detect(void)\r\n{\r\nu8 cmd_val = inb_p(ABIT_UGURU_BASE + ABIT_UGURU_CMD);\r\nu8 data_val = inb_p(ABIT_UGURU_BASE + ABIT_UGURU_DATA);\r\nif (((data_val == 0x00) || (data_val == 0x08)) &&\r\n((cmd_val == 0x00) || (cmd_val == 0xAC)))\r\nreturn ABIT_UGURU_BASE;\r\nABIT_UGURU_DEBUG(2, "no Abit uGuru found, data = 0x%02X, cmd = "\r\n"0x%02X\n", (unsigned int)data_val, (unsigned int)cmd_val);\r\nif (force) {\r\npr_info("Assuming Abit uGuru is present because of \"force\" parameter\n");\r\nreturn ABIT_UGURU_BASE;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int __init abituguru_init(void)\r\n{\r\nint address, err;\r\nstruct resource res = { .flags = IORESOURCE_IO };\r\nconst char *board_vendor = dmi_get_system_info(DMI_BOARD_VENDOR);\r\nif (!force && (!board_vendor ||\r\nstrcmp(board_vendor, "http://www.abit.com.tw/")))\r\nreturn -ENODEV;\r\naddress = abituguru_detect();\r\nif (address < 0)\r\nreturn address;\r\nerr = platform_driver_register(&abituguru_driver);\r\nif (err)\r\ngoto exit;\r\nabituguru_pdev = platform_device_alloc(ABIT_UGURU_NAME, address);\r\nif (!abituguru_pdev) {\r\npr_err("Device allocation failed\n");\r\nerr = -ENOMEM;\r\ngoto exit_driver_unregister;\r\n}\r\nres.start = address;\r\nres.end = address + ABIT_UGURU_REGION_LENGTH - 1;\r\nres.name = ABIT_UGURU_NAME;\r\nerr = platform_device_add_resources(abituguru_pdev, &res, 1);\r\nif (err) {\r\npr_err("Device resource addition failed (%d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nerr = platform_device_add(abituguru_pdev);\r\nif (err) {\r\npr_err("Device addition failed (%d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nreturn 0;\r\nexit_device_put:\r\nplatform_device_put(abituguru_pdev);\r\nexit_driver_unregister:\r\nplatform_driver_unregister(&abituguru_driver);\r\nexit:\r\nreturn err;\r\n}\r\nstatic void __exit abituguru_exit(void)\r\n{\r\nplatform_device_unregister(abituguru_pdev);\r\nplatform_driver_unregister(&abituguru_driver);\r\n}
