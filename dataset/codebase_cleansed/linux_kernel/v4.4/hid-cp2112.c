static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct cp2112_device *dev = container_of(chip, struct cp2112_device,\r\ngc);\r\nstruct hid_device *hdev = dev->hdev;\r\nu8 buf[5];\r\nint ret;\r\nret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\r\nsizeof(buf), HID_FEATURE_REPORT,\r\nHID_REQ_GET_REPORT);\r\nif (ret != sizeof(buf)) {\r\nhid_err(hdev, "error requesting GPIO config: %d\n", ret);\r\nreturn ret;\r\n}\r\nbuf[1] &= ~(1 << offset);\r\nbuf[2] = gpio_push_pull;\r\nret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf, sizeof(buf),\r\nHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\r\nif (ret < 0) {\r\nhid_err(hdev, "error setting GPIO config: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct cp2112_device *dev = container_of(chip, struct cp2112_device,\r\ngc);\r\nstruct hid_device *hdev = dev->hdev;\r\nu8 buf[3];\r\nint ret;\r\nbuf[0] = CP2112_GPIO_SET;\r\nbuf[1] = value ? 0xff : 0;\r\nbuf[2] = 1 << offset;\r\nret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf, sizeof(buf),\r\nHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\r\nif (ret < 0)\r\nhid_err(hdev, "error setting GPIO values: %d\n", ret);\r\n}\r\nstatic int cp2112_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct cp2112_device *dev = container_of(chip, struct cp2112_device,\r\ngc);\r\nstruct hid_device *hdev = dev->hdev;\r\nu8 buf[2];\r\nint ret;\r\nret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf, sizeof(buf),\r\nHID_FEATURE_REPORT, HID_REQ_GET_REPORT);\r\nif (ret != sizeof(buf)) {\r\nhid_err(hdev, "error requesting GPIO values: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn (buf[1] >> offset) & 1;\r\n}\r\nstatic int cp2112_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct cp2112_device *dev = container_of(chip, struct cp2112_device,\r\ngc);\r\nstruct hid_device *hdev = dev->hdev;\r\nu8 buf[5];\r\nint ret;\r\nret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\r\nsizeof(buf), HID_FEATURE_REPORT,\r\nHID_REQ_GET_REPORT);\r\nif (ret != sizeof(buf)) {\r\nhid_err(hdev, "error requesting GPIO config: %d\n", ret);\r\nreturn ret;\r\n}\r\nbuf[1] |= 1 << offset;\r\nbuf[2] = gpio_push_pull;\r\nret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf, sizeof(buf),\r\nHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\r\nif (ret < 0) {\r\nhid_err(hdev, "error setting GPIO config: %d\n", ret);\r\nreturn ret;\r\n}\r\ncp2112_gpio_set(chip, offset, value);\r\nreturn 0;\r\n}\r\nstatic int cp2112_hid_get(struct hid_device *hdev, unsigned char report_number,\r\nu8 *data, size_t count, unsigned char report_type)\r\n{\r\nu8 *buf;\r\nint ret;\r\nbuf = kmalloc(count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = hid_hw_raw_request(hdev, report_number, buf, count,\r\nreport_type, HID_REQ_GET_REPORT);\r\nmemcpy(data, buf, count);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int cp2112_hid_output(struct hid_device *hdev, u8 *data, size_t count,\r\nunsigned char report_type)\r\n{\r\nu8 *buf;\r\nint ret;\r\nbuf = kmemdup(data, count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (report_type == HID_OUTPUT_REPORT)\r\nret = hid_hw_output_report(hdev, buf, count);\r\nelse\r\nret = hid_hw_raw_request(hdev, buf[0], buf, count, report_type,\r\nHID_REQ_SET_REPORT);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int cp2112_wait(struct cp2112_device *dev, atomic_t *avail)\r\n{\r\nint ret = 0;\r\nret = wait_event_interruptible_timeout(dev->wait,\r\natomic_read(avail), msecs_to_jiffies(RESPONSE_TIMEOUT));\r\nif (-ERESTARTSYS == ret)\r\nreturn ret;\r\nif (!ret)\r\nreturn -ETIMEDOUT;\r\natomic_set(avail, 0);\r\nreturn 0;\r\n}\r\nstatic int cp2112_xfer_status(struct cp2112_device *dev)\r\n{\r\nstruct hid_device *hdev = dev->hdev;\r\nu8 buf[2];\r\nint ret;\r\nbuf[0] = CP2112_TRANSFER_STATUS_REQUEST;\r\nbuf[1] = 0x01;\r\natomic_set(&dev->xfer_avail, 0);\r\nret = cp2112_hid_output(hdev, buf, 2, HID_OUTPUT_REPORT);\r\nif (ret < 0) {\r\nhid_warn(hdev, "Error requesting status: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = cp2112_wait(dev, &dev->xfer_avail);\r\nif (ret)\r\nreturn ret;\r\nreturn dev->xfer_status;\r\n}\r\nstatic int cp2112_read(struct cp2112_device *dev, u8 *data, size_t size)\r\n{\r\nstruct hid_device *hdev = dev->hdev;\r\nstruct cp2112_force_read_report report;\r\nint ret;\r\nif (size > sizeof(dev->read_data))\r\nsize = sizeof(dev->read_data);\r\nreport.report = CP2112_DATA_READ_FORCE_SEND;\r\nreport.length = cpu_to_be16(size);\r\natomic_set(&dev->read_avail, 0);\r\nret = cp2112_hid_output(hdev, &report.report, sizeof(report),\r\nHID_OUTPUT_REPORT);\r\nif (ret < 0) {\r\nhid_warn(hdev, "Error requesting data: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = cp2112_wait(dev, &dev->read_avail);\r\nif (ret)\r\nreturn ret;\r\nhid_dbg(hdev, "read %d of %zd bytes requested\n",\r\ndev->read_length, size);\r\nif (size > dev->read_length)\r\nsize = dev->read_length;\r\nmemcpy(data, dev->read_data, size);\r\nreturn dev->read_length;\r\n}\r\nstatic int cp2112_read_req(void *buf, u8 slave_address, u16 length)\r\n{\r\nstruct cp2112_read_req_report *report = buf;\r\nif (length < 1 || length > 512)\r\nreturn -EINVAL;\r\nreport->report = CP2112_DATA_READ_REQUEST;\r\nreport->slave_address = slave_address << 1;\r\nreport->length = cpu_to_be16(length);\r\nreturn sizeof(*report);\r\n}\r\nstatic int cp2112_write_read_req(void *buf, u8 slave_address, u16 length,\r\nu8 command, u8 *data, u8 data_length)\r\n{\r\nstruct cp2112_write_read_req_report *report = buf;\r\nif (length < 1 || length > 512\r\n|| data_length > sizeof(report->target_address) - 1)\r\nreturn -EINVAL;\r\nreport->report = CP2112_DATA_WRITE_READ_REQUEST;\r\nreport->slave_address = slave_address << 1;\r\nreport->length = cpu_to_be16(length);\r\nreport->target_address_length = data_length + 1;\r\nreport->target_address[0] = command;\r\nmemcpy(&report->target_address[1], data, data_length);\r\nreturn data_length + 6;\r\n}\r\nstatic int cp2112_write_req(void *buf, u8 slave_address, u8 command, u8 *data,\r\nu8 data_length)\r\n{\r\nstruct cp2112_write_req_report *report = buf;\r\nif (data_length > sizeof(report->data) - 1)\r\nreturn -EINVAL;\r\nreport->report = CP2112_DATA_WRITE_REQUEST;\r\nreport->slave_address = slave_address << 1;\r\nreport->length = data_length + 1;\r\nreport->data[0] = command;\r\nmemcpy(&report->data[1], data, data_length);\r\nreturn data_length + 4;\r\n}\r\nstatic int cp2112_i2c_write_req(void *buf, u8 slave_address, u8 *data,\r\nu8 data_length)\r\n{\r\nstruct cp2112_write_req_report *report = buf;\r\nif (data_length > sizeof(report->data))\r\nreturn -EINVAL;\r\nreport->report = CP2112_DATA_WRITE_REQUEST;\r\nreport->slave_address = slave_address << 1;\r\nreport->length = data_length;\r\nmemcpy(report->data, data, data_length);\r\nreturn data_length + 3;\r\n}\r\nstatic int cp2112_i2c_write_read_req(void *buf, u8 slave_address,\r\nu8 *addr, int addr_length,\r\nint read_length)\r\n{\r\nstruct cp2112_write_read_req_report *report = buf;\r\nif (read_length < 1 || read_length > 512 ||\r\naddr_length > sizeof(report->target_address))\r\nreturn -EINVAL;\r\nreport->report = CP2112_DATA_WRITE_READ_REQUEST;\r\nreport->slave_address = slave_address << 1;\r\nreport->length = cpu_to_be16(read_length);\r\nreport->target_address_length = addr_length;\r\nmemcpy(report->target_address, addr, addr_length);\r\nreturn addr_length + 5;\r\n}\r\nstatic int cp2112_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct cp2112_device *dev = (struct cp2112_device *)adap->algo_data;\r\nstruct hid_device *hdev = dev->hdev;\r\nu8 buf[64];\r\nssize_t count;\r\nssize_t read_length = 0;\r\nu8 *read_buf = NULL;\r\nunsigned int retries;\r\nint ret;\r\nhid_dbg(hdev, "I2C %d messages\n", num);\r\nif (num == 1) {\r\nif (msgs->flags & I2C_M_RD) {\r\nhid_dbg(hdev, "I2C read %#04x len %d\n",\r\nmsgs->addr, msgs->len);\r\nread_length = msgs->len;\r\nread_buf = msgs->buf;\r\ncount = cp2112_read_req(buf, msgs->addr, msgs->len);\r\n} else {\r\nhid_dbg(hdev, "I2C write %#04x len %d\n",\r\nmsgs->addr, msgs->len);\r\ncount = cp2112_i2c_write_req(buf, msgs->addr,\r\nmsgs->buf, msgs->len);\r\n}\r\nif (count < 0)\r\nreturn count;\r\n} else if (dev->hwversion > 1 &&\r\nnum == 2 &&\r\nmsgs[0].addr == msgs[1].addr &&\r\n!(msgs[0].flags & I2C_M_RD) && (msgs[1].flags & I2C_M_RD)) {\r\nhid_dbg(hdev, "I2C write-read %#04x wlen %d rlen %d\n",\r\nmsgs[0].addr, msgs[0].len, msgs[1].len);\r\nread_length = msgs[1].len;\r\nread_buf = msgs[1].buf;\r\ncount = cp2112_i2c_write_read_req(buf, msgs[0].addr,\r\nmsgs[0].buf, msgs[0].len, msgs[1].len);\r\nif (count < 0)\r\nreturn count;\r\n} else {\r\nhid_err(hdev,\r\n"Multi-message I2C transactions not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nret = hid_hw_power(hdev, PM_HINT_FULLON);\r\nif (ret < 0) {\r\nhid_err(hdev, "power management error: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = cp2112_hid_output(hdev, buf, count, HID_OUTPUT_REPORT);\r\nif (ret < 0) {\r\nhid_warn(hdev, "Error starting transaction: %d\n", ret);\r\ngoto power_normal;\r\n}\r\nfor (retries = 0; retries < XFER_STATUS_RETRIES; ++retries) {\r\nret = cp2112_xfer_status(dev);\r\nif (-EBUSY == ret)\r\ncontinue;\r\nif (ret < 0)\r\ngoto power_normal;\r\nbreak;\r\n}\r\nif (XFER_STATUS_RETRIES <= retries) {\r\nhid_warn(hdev, "Transfer timed out, cancelling.\n");\r\nbuf[0] = CP2112_CANCEL_TRANSFER;\r\nbuf[1] = 0x01;\r\nret = cp2112_hid_output(hdev, buf, 2, HID_OUTPUT_REPORT);\r\nif (ret < 0)\r\nhid_warn(hdev, "Error cancelling transaction: %d\n",\r\nret);\r\nret = -ETIMEDOUT;\r\ngoto power_normal;\r\n}\r\nfor (count = 0; count < read_length;) {\r\nret = cp2112_read(dev, read_buf + count, read_length - count);\r\nif (ret < 0)\r\ngoto power_normal;\r\nif (ret == 0) {\r\nhid_err(hdev, "read returned 0\n");\r\nret = -EIO;\r\ngoto power_normal;\r\n}\r\ncount += ret;\r\nif (count > read_length) {\r\nhid_err(hdev, "long read: %d > %zd\n",\r\nret, read_length - count + ret);\r\nret = -EIO;\r\ngoto power_normal;\r\n}\r\n}\r\nret = num;\r\npower_normal:\r\nhid_hw_power(hdev, PM_HINT_NORMAL);\r\nhid_dbg(hdev, "I2C transfer finished: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int cp2112_xfer(struct i2c_adapter *adap, u16 addr,\r\nunsigned short flags, char read_write, u8 command,\r\nint size, union i2c_smbus_data *data)\r\n{\r\nstruct cp2112_device *dev = (struct cp2112_device *)adap->algo_data;\r\nstruct hid_device *hdev = dev->hdev;\r\nu8 buf[64];\r\n__le16 word;\r\nssize_t count;\r\nsize_t read_length = 0;\r\nunsigned int retries;\r\nint ret;\r\nhid_dbg(hdev, "%s addr 0x%x flags 0x%x cmd 0x%x size %d\n",\r\nread_write == I2C_SMBUS_WRITE ? "write" : "read",\r\naddr, flags, command, size);\r\nswitch (size) {\r\ncase I2C_SMBUS_BYTE:\r\nread_length = 1;\r\nif (I2C_SMBUS_READ == read_write)\r\ncount = cp2112_read_req(buf, addr, read_length);\r\nelse\r\ncount = cp2112_write_req(buf, addr, command, NULL,\r\n0);\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\nread_length = 1;\r\nif (I2C_SMBUS_READ == read_write)\r\ncount = cp2112_write_read_req(buf, addr, read_length,\r\ncommand, NULL, 0);\r\nelse\r\ncount = cp2112_write_req(buf, addr, command,\r\n&data->byte, 1);\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\nread_length = 2;\r\nword = cpu_to_le16(data->word);\r\nif (I2C_SMBUS_READ == read_write)\r\ncount = cp2112_write_read_req(buf, addr, read_length,\r\ncommand, NULL, 0);\r\nelse\r\ncount = cp2112_write_req(buf, addr, command,\r\n(u8 *)&word, 2);\r\nbreak;\r\ncase I2C_SMBUS_PROC_CALL:\r\nsize = I2C_SMBUS_WORD_DATA;\r\nread_write = I2C_SMBUS_READ;\r\nread_length = 2;\r\nword = cpu_to_le16(data->word);\r\ncount = cp2112_write_read_req(buf, addr, read_length, command,\r\n(u8 *)&word, 2);\r\nbreak;\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\nsize = I2C_SMBUS_BLOCK_DATA;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\nif (I2C_SMBUS_READ == read_write) {\r\ncount = cp2112_write_read_req(buf, addr,\r\nI2C_SMBUS_BLOCK_MAX,\r\ncommand, NULL, 0);\r\n} else {\r\ncount = cp2112_write_req(buf, addr, command,\r\ndata->block,\r\ndata->block[0] + 1);\r\n}\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_PROC_CALL:\r\nsize = I2C_SMBUS_BLOCK_DATA;\r\nread_write = I2C_SMBUS_READ;\r\ncount = cp2112_write_read_req(buf, addr, I2C_SMBUS_BLOCK_MAX,\r\ncommand, data->block,\r\ndata->block[0] + 1);\r\nbreak;\r\ndefault:\r\nhid_warn(hdev, "Unsupported transaction %d\n", size);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (count < 0)\r\nreturn count;\r\nret = hid_hw_power(hdev, PM_HINT_FULLON);\r\nif (ret < 0) {\r\nhid_err(hdev, "power management error: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = cp2112_hid_output(hdev, buf, count, HID_OUTPUT_REPORT);\r\nif (ret < 0) {\r\nhid_warn(hdev, "Error starting transaction: %d\n", ret);\r\ngoto power_normal;\r\n}\r\nfor (retries = 0; retries < XFER_STATUS_RETRIES; ++retries) {\r\nret = cp2112_xfer_status(dev);\r\nif (-EBUSY == ret)\r\ncontinue;\r\nif (ret < 0)\r\ngoto power_normal;\r\nbreak;\r\n}\r\nif (XFER_STATUS_RETRIES <= retries) {\r\nhid_warn(hdev, "Transfer timed out, cancelling.\n");\r\nbuf[0] = CP2112_CANCEL_TRANSFER;\r\nbuf[1] = 0x01;\r\nret = cp2112_hid_output(hdev, buf, 2, HID_OUTPUT_REPORT);\r\nif (ret < 0)\r\nhid_warn(hdev, "Error cancelling transaction: %d\n",\r\nret);\r\nret = -ETIMEDOUT;\r\ngoto power_normal;\r\n}\r\nif (I2C_SMBUS_WRITE == read_write) {\r\nret = 0;\r\ngoto power_normal;\r\n}\r\nif (I2C_SMBUS_BLOCK_DATA == size)\r\nread_length = ret;\r\nret = cp2112_read(dev, buf, read_length);\r\nif (ret < 0)\r\ngoto power_normal;\r\nif (ret != read_length) {\r\nhid_warn(hdev, "short read: %d < %zd\n", ret, read_length);\r\nret = -EIO;\r\ngoto power_normal;\r\n}\r\nswitch (size) {\r\ncase I2C_SMBUS_BYTE:\r\ncase I2C_SMBUS_BYTE_DATA:\r\ndata->byte = buf[0];\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\ndata->word = le16_to_cpup((__le16 *)buf);\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\nif (read_length > I2C_SMBUS_BLOCK_MAX) {\r\nret = -EPROTO;\r\ngoto power_normal;\r\n}\r\nmemcpy(data->block, buf, read_length);\r\nbreak;\r\n}\r\nret = 0;\r\npower_normal:\r\nhid_hw_power(hdev, PM_HINT_NORMAL);\r\nhid_dbg(hdev, "transfer finished: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic u32 cp2112_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C |\r\nI2C_FUNC_SMBUS_BYTE |\r\nI2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_DATA |\r\nI2C_FUNC_SMBUS_I2C_BLOCK |\r\nI2C_FUNC_SMBUS_PROC_CALL |\r\nI2C_FUNC_SMBUS_BLOCK_PROC_CALL;\r\n}\r\nstatic int cp2112_get_usb_config(struct hid_device *hdev,\r\nstruct cp2112_usb_config_report *cfg)\r\n{\r\nint ret;\r\nret = cp2112_hid_get(hdev, CP2112_USB_CONFIG, (u8 *)cfg, sizeof(*cfg),\r\nHID_FEATURE_REPORT);\r\nif (ret != sizeof(*cfg)) {\r\nhid_err(hdev, "error reading usb config: %d\n", ret);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cp2112_set_usb_config(struct hid_device *hdev,\r\nstruct cp2112_usb_config_report *cfg)\r\n{\r\nint ret;\r\nBUG_ON(cfg->report != CP2112_USB_CONFIG);\r\nret = cp2112_hid_output(hdev, (u8 *)cfg, sizeof(*cfg),\r\nHID_FEATURE_REPORT);\r\nif (ret != sizeof(*cfg)) {\r\nhid_err(hdev, "error writing usb config: %d\n", ret);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t pstr_store(struct device *kdev,\r\nstruct device_attribute *kattr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct hid_device *hdev = container_of(kdev, struct hid_device, dev);\r\nstruct cp2112_pstring_attribute *attr =\r\ncontainer_of(kattr, struct cp2112_pstring_attribute, attr);\r\nstruct cp2112_string_report report;\r\nint ret;\r\nmemset(&report, 0, sizeof(report));\r\nret = utf8s_to_utf16s(buf, count, UTF16_LITTLE_ENDIAN,\r\nreport.string, ARRAY_SIZE(report.string));\r\nreport.report = attr->report;\r\nreport.length = ret * sizeof(report.string[0]) + 2;\r\nreport.type = USB_DT_STRING;\r\nret = cp2112_hid_output(hdev, &report.report, report.length + 1,\r\nHID_FEATURE_REPORT);\r\nif (ret != report.length + 1) {\r\nhid_err(hdev, "error writing %s string: %d\n", kattr->attr.name,\r\nret);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn -EIO;\r\n}\r\nchmod_sysfs_attrs(hdev);\r\nreturn count;\r\n}\r\nstatic ssize_t pstr_show(struct device *kdev,\r\nstruct device_attribute *kattr, char *buf)\r\n{\r\nstruct hid_device *hdev = container_of(kdev, struct hid_device, dev);\r\nstruct cp2112_pstring_attribute *attr =\r\ncontainer_of(kattr, struct cp2112_pstring_attribute, attr);\r\nstruct cp2112_string_report report;\r\nu8 length;\r\nint ret;\r\nret = cp2112_hid_get(hdev, attr->report, &report.report,\r\nsizeof(report) - 1, HID_FEATURE_REPORT);\r\nif (ret < 3) {\r\nhid_err(hdev, "error reading %s string: %d\n", kattr->attr.name,\r\nret);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn -EIO;\r\n}\r\nif (report.length < 2) {\r\nhid_err(hdev, "invalid %s string length: %d\n",\r\nkattr->attr.name, report.length);\r\nreturn -EIO;\r\n}\r\nlength = report.length > ret - 1 ? ret - 1 : report.length;\r\nlength = (length - 2) / sizeof(report.string[0]);\r\nret = utf16s_to_utf8s(report.string, length, UTF16_LITTLE_ENDIAN, buf,\r\nPAGE_SIZE - 1);\r\nbuf[ret++] = '\n';\r\nreturn ret;\r\n}\r\nstatic void chmod_sysfs_attrs(struct hid_device *hdev)\r\n{\r\nstruct attribute **attr;\r\nu8 buf[2];\r\nint ret;\r\nret = cp2112_hid_get(hdev, CP2112_LOCK_BYTE, buf, sizeof(buf),\r\nHID_FEATURE_REPORT);\r\nif (ret != sizeof(buf)) {\r\nhid_err(hdev, "error reading lock byte: %d\n", ret);\r\nreturn;\r\n}\r\nfor (attr = cp2112_attr_group.attrs; *attr; ++attr) {\r\numode_t mode = (buf[1] & 1) ? S_IWUSR | S_IRUGO : S_IRUGO;\r\nret = sysfs_chmod_file(&hdev->dev.kobj, *attr, mode);\r\nif (ret < 0)\r\nhid_err(hdev, "error chmoding sysfs file %s\n",\r\n(*attr)->name);\r\nbuf[1] >>= 1;\r\n}\r\n}\r\nstatic int cp2112_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nstruct cp2112_device *dev;\r\nu8 buf[3];\r\nstruct cp2112_smbus_config_report config;\r\nint ret;\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "parse failed\n");\r\nreturn ret;\r\n}\r\nret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\nreturn ret;\r\n}\r\nret = hid_hw_open(hdev);\r\nif (ret) {\r\nhid_err(hdev, "hw open failed\n");\r\ngoto err_hid_stop;\r\n}\r\nret = hid_hw_power(hdev, PM_HINT_FULLON);\r\nif (ret < 0) {\r\nhid_err(hdev, "power management error: %d\n", ret);\r\ngoto err_hid_close;\r\n}\r\nret = cp2112_hid_get(hdev, CP2112_GET_VERSION_INFO, buf, sizeof(buf),\r\nHID_FEATURE_REPORT);\r\nif (ret != sizeof(buf)) {\r\nhid_err(hdev, "error requesting version\n");\r\nif (ret >= 0)\r\nret = -EIO;\r\ngoto err_power_normal;\r\n}\r\nhid_info(hdev, "Part Number: 0x%02X Device Version: 0x%02X\n",\r\nbuf[1], buf[2]);\r\nret = cp2112_hid_get(hdev, CP2112_SMBUS_CONFIG, (u8 *)&config,\r\nsizeof(config), HID_FEATURE_REPORT);\r\nif (ret != sizeof(config)) {\r\nhid_err(hdev, "error requesting SMBus config\n");\r\nif (ret >= 0)\r\nret = -EIO;\r\ngoto err_power_normal;\r\n}\r\nconfig.retry_time = cpu_to_be16(1);\r\nret = cp2112_hid_output(hdev, (u8 *)&config, sizeof(config),\r\nHID_FEATURE_REPORT);\r\nif (ret != sizeof(config)) {\r\nhid_err(hdev, "error setting SMBus config\n");\r\nif (ret >= 0)\r\nret = -EIO;\r\ngoto err_power_normal;\r\n}\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err_power_normal;\r\n}\r\nhid_set_drvdata(hdev, (void *)dev);\r\ndev->hdev = hdev;\r\ndev->adap.owner = THIS_MODULE;\r\ndev->adap.class = I2C_CLASS_HWMON;\r\ndev->adap.algo = &smbus_algorithm;\r\ndev->adap.algo_data = dev;\r\ndev->adap.dev.parent = &hdev->dev;\r\nsnprintf(dev->adap.name, sizeof(dev->adap.name),\r\n"CP2112 SMBus Bridge on hiddev%d", hdev->minor);\r\ndev->hwversion = buf[2];\r\ninit_waitqueue_head(&dev->wait);\r\nhid_device_io_start(hdev);\r\nret = i2c_add_adapter(&dev->adap);\r\nhid_device_io_stop(hdev);\r\nif (ret) {\r\nhid_err(hdev, "error registering i2c adapter\n");\r\ngoto err_free_dev;\r\n}\r\nhid_dbg(hdev, "adapter registered\n");\r\ndev->gc.label = "cp2112_gpio";\r\ndev->gc.direction_input = cp2112_gpio_direction_input;\r\ndev->gc.direction_output = cp2112_gpio_direction_output;\r\ndev->gc.set = cp2112_gpio_set;\r\ndev->gc.get = cp2112_gpio_get;\r\ndev->gc.base = -1;\r\ndev->gc.ngpio = 8;\r\ndev->gc.can_sleep = 1;\r\ndev->gc.dev = &hdev->dev;\r\nret = gpiochip_add(&dev->gc);\r\nif (ret < 0) {\r\nhid_err(hdev, "error registering gpio chip\n");\r\ngoto err_free_i2c;\r\n}\r\nret = sysfs_create_group(&hdev->dev.kobj, &cp2112_attr_group);\r\nif (ret < 0) {\r\nhid_err(hdev, "error creating sysfs attrs\n");\r\ngoto err_gpiochip_remove;\r\n}\r\nchmod_sysfs_attrs(hdev);\r\nhid_hw_power(hdev, PM_HINT_NORMAL);\r\nreturn ret;\r\nerr_gpiochip_remove:\r\ngpiochip_remove(&dev->gc);\r\nerr_free_i2c:\r\ni2c_del_adapter(&dev->adap);\r\nerr_free_dev:\r\nkfree(dev);\r\nerr_power_normal:\r\nhid_hw_power(hdev, PM_HINT_NORMAL);\r\nerr_hid_close:\r\nhid_hw_close(hdev);\r\nerr_hid_stop:\r\nhid_hw_stop(hdev);\r\nreturn ret;\r\n}\r\nstatic void cp2112_remove(struct hid_device *hdev)\r\n{\r\nstruct cp2112_device *dev = hid_get_drvdata(hdev);\r\nsysfs_remove_group(&hdev->dev.kobj, &cp2112_attr_group);\r\ngpiochip_remove(&dev->gc);\r\ni2c_del_adapter(&dev->adap);\r\nhid_hw_close(hdev);\r\nhid_hw_stop(hdev);\r\nkfree(dev);\r\n}\r\nstatic int cp2112_raw_event(struct hid_device *hdev, struct hid_report *report,\r\nu8 *data, int size)\r\n{\r\nstruct cp2112_device *dev = hid_get_drvdata(hdev);\r\nstruct cp2112_xfer_status_report *xfer = (void *)data;\r\nswitch (data[0]) {\r\ncase CP2112_TRANSFER_STATUS_RESPONSE:\r\nhid_dbg(hdev, "xfer status: %02x %02x %04x %04x\n",\r\nxfer->status0, xfer->status1,\r\nbe16_to_cpu(xfer->retries), be16_to_cpu(xfer->length));\r\nswitch (xfer->status0) {\r\ncase STATUS0_IDLE:\r\ndev->xfer_status = -EAGAIN;\r\nbreak;\r\ncase STATUS0_BUSY:\r\ndev->xfer_status = -EBUSY;\r\nbreak;\r\ncase STATUS0_COMPLETE:\r\ndev->xfer_status = be16_to_cpu(xfer->length);\r\nbreak;\r\ncase STATUS0_ERROR:\r\nswitch (xfer->status1) {\r\ncase STATUS1_TIMEOUT_NACK:\r\ncase STATUS1_TIMEOUT_BUS:\r\ndev->xfer_status = -ETIMEDOUT;\r\nbreak;\r\ndefault:\r\ndev->xfer_status = -EIO;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\ndev->xfer_status = -EINVAL;\r\nbreak;\r\n}\r\natomic_set(&dev->xfer_avail, 1);\r\nbreak;\r\ncase CP2112_DATA_READ_RESPONSE:\r\nhid_dbg(hdev, "read response: %02x %02x\n", data[1], data[2]);\r\ndev->read_length = data[2];\r\nif (dev->read_length > sizeof(dev->read_data))\r\ndev->read_length = sizeof(dev->read_data);\r\nmemcpy(dev->read_data, &data[3], dev->read_length);\r\natomic_set(&dev->read_avail, 1);\r\nbreak;\r\ndefault:\r\nhid_err(hdev, "unknown report\n");\r\nreturn 0;\r\n}\r\nwake_up_interruptible(&dev->wait);\r\nreturn 1;\r\n}
