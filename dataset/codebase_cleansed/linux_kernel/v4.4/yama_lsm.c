static void yama_relation_cleanup(struct work_struct *work)\r\n{\r\nstruct ptrace_relation *relation;\r\nspin_lock(&ptracer_relations_lock);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\r\nif (relation->invalid) {\r\nlist_del_rcu(&relation->node);\r\nkfree_rcu(relation, rcu);\r\n}\r\n}\r\nrcu_read_unlock();\r\nspin_unlock(&ptracer_relations_lock);\r\n}\r\nstatic int yama_ptracer_add(struct task_struct *tracer,\r\nstruct task_struct *tracee)\r\n{\r\nstruct ptrace_relation *relation, *added;\r\nadded = kmalloc(sizeof(*added), GFP_KERNEL);\r\nif (!added)\r\nreturn -ENOMEM;\r\nadded->tracee = tracee;\r\nadded->tracer = tracer;\r\nadded->invalid = false;\r\nspin_lock(&ptracer_relations_lock);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\r\nif (relation->invalid)\r\ncontinue;\r\nif (relation->tracee == tracee) {\r\nlist_replace_rcu(&relation->node, &added->node);\r\nkfree_rcu(relation, rcu);\r\ngoto out;\r\n}\r\n}\r\nlist_add_rcu(&added->node, &ptracer_relations);\r\nout:\r\nrcu_read_unlock();\r\nspin_unlock(&ptracer_relations_lock);\r\nreturn 0;\r\n}\r\nstatic void yama_ptracer_del(struct task_struct *tracer,\r\nstruct task_struct *tracee)\r\n{\r\nstruct ptrace_relation *relation;\r\nbool marked = false;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\r\nif (relation->invalid)\r\ncontinue;\r\nif (relation->tracee == tracee ||\r\n(tracer && relation->tracer == tracer)) {\r\nrelation->invalid = true;\r\nmarked = true;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (marked)\r\nschedule_work(&yama_relation_work);\r\n}\r\nvoid yama_task_free(struct task_struct *task)\r\n{\r\nyama_ptracer_del(task, task);\r\n}\r\nint yama_task_prctl(int option, unsigned long arg2, unsigned long arg3,\r\nunsigned long arg4, unsigned long arg5)\r\n{\r\nint rc = -ENOSYS;\r\nstruct task_struct *myself = current;\r\nswitch (option) {\r\ncase PR_SET_PTRACER:\r\nrcu_read_lock();\r\nif (!thread_group_leader(myself))\r\nmyself = rcu_dereference(myself->group_leader);\r\nget_task_struct(myself);\r\nrcu_read_unlock();\r\nif (arg2 == 0) {\r\nyama_ptracer_del(NULL, myself);\r\nrc = 0;\r\n} else if (arg2 == PR_SET_PTRACER_ANY || (int)arg2 == -1) {\r\nrc = yama_ptracer_add(NULL, myself);\r\n} else {\r\nstruct task_struct *tracer;\r\nrcu_read_lock();\r\ntracer = find_task_by_vpid(arg2);\r\nif (tracer)\r\nget_task_struct(tracer);\r\nelse\r\nrc = -EINVAL;\r\nrcu_read_unlock();\r\nif (tracer) {\r\nrc = yama_ptracer_add(tracer, myself);\r\nput_task_struct(tracer);\r\n}\r\n}\r\nput_task_struct(myself);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int task_is_descendant(struct task_struct *parent,\r\nstruct task_struct *child)\r\n{\r\nint rc = 0;\r\nstruct task_struct *walker = child;\r\nif (!parent || !child)\r\nreturn 0;\r\nrcu_read_lock();\r\nif (!thread_group_leader(parent))\r\nparent = rcu_dereference(parent->group_leader);\r\nwhile (walker->pid > 0) {\r\nif (!thread_group_leader(walker))\r\nwalker = rcu_dereference(walker->group_leader);\r\nif (walker == parent) {\r\nrc = 1;\r\nbreak;\r\n}\r\nwalker = rcu_dereference(walker->real_parent);\r\n}\r\nrcu_read_unlock();\r\nreturn rc;\r\n}\r\nstatic int ptracer_exception_found(struct task_struct *tracer,\r\nstruct task_struct *tracee)\r\n{\r\nint rc = 0;\r\nstruct ptrace_relation *relation;\r\nstruct task_struct *parent = NULL;\r\nbool found = false;\r\nrcu_read_lock();\r\nif (!thread_group_leader(tracee))\r\ntracee = rcu_dereference(tracee->group_leader);\r\nlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\r\nif (relation->invalid)\r\ncontinue;\r\nif (relation->tracee == tracee) {\r\nparent = relation->tracer;\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (found && (parent == NULL || task_is_descendant(parent, tracer)))\r\nrc = 1;\r\nrcu_read_unlock();\r\nreturn rc;\r\n}\r\nstatic int yama_ptrace_access_check(struct task_struct *child,\r\nunsigned int mode)\r\n{\r\nint rc = 0;\r\nif (mode == PTRACE_MODE_ATTACH) {\r\nswitch (ptrace_scope) {\r\ncase YAMA_SCOPE_DISABLED:\r\nbreak;\r\ncase YAMA_SCOPE_RELATIONAL:\r\nrcu_read_lock();\r\nif (!task_is_descendant(current, child) &&\r\n!ptracer_exception_found(current, child) &&\r\n!ns_capable(__task_cred(child)->user_ns, CAP_SYS_PTRACE))\r\nrc = -EPERM;\r\nrcu_read_unlock();\r\nbreak;\r\ncase YAMA_SCOPE_CAPABILITY:\r\nrcu_read_lock();\r\nif (!ns_capable(__task_cred(child)->user_ns, CAP_SYS_PTRACE))\r\nrc = -EPERM;\r\nrcu_read_unlock();\r\nbreak;\r\ncase YAMA_SCOPE_NO_ATTACH:\r\ndefault:\r\nrc = -EPERM;\r\nbreak;\r\n}\r\n}\r\nif (rc) {\r\nprintk_ratelimited(KERN_NOTICE\r\n"ptrace of pid %d was attempted by: %s (pid %d)\n",\r\nchild->pid, current->comm, current->pid);\r\n}\r\nreturn rc;\r\n}\r\nint yama_ptrace_traceme(struct task_struct *parent)\r\n{\r\nint rc = 0;\r\nswitch (ptrace_scope) {\r\ncase YAMA_SCOPE_CAPABILITY:\r\nif (!has_ns_capability(parent, current_user_ns(), CAP_SYS_PTRACE))\r\nrc = -EPERM;\r\nbreak;\r\ncase YAMA_SCOPE_NO_ATTACH:\r\nrc = -EPERM;\r\nbreak;\r\n}\r\nif (rc) {\r\nprintk_ratelimited(KERN_NOTICE\r\n"ptraceme of pid %d was attempted by: %s (pid %d)\n",\r\ncurrent->pid, parent->comm, parent->pid);\r\n}\r\nreturn rc;\r\n}\r\nstatic int yama_dointvec_minmax(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nstruct ctl_table table_copy;\r\nif (write && !capable(CAP_SYS_PTRACE))\r\nreturn -EPERM;\r\ntable_copy = *table;\r\nif (*(int *)table_copy.data == *(int *)table_copy.extra2)\r\ntable_copy.extra1 = table_copy.extra2;\r\nreturn proc_dointvec_minmax(&table_copy, write, buffer, lenp, ppos);\r\n}\r\nstatic void __init yama_init_sysctl(void)\r\n{\r\nif (!register_sysctl_paths(yama_sysctl_path, yama_sysctl_table))\r\npanic("Yama: sysctl registration failed.\n");\r\n}\r\nstatic inline void yama_init_sysctl(void) { }\r\nvoid __init yama_add_hooks(void)\r\n{\r\npr_info("Yama: becoming mindful.\n");\r\nsecurity_add_hooks(yama_hooks, ARRAY_SIZE(yama_hooks));\r\nyama_init_sysctl();\r\n}
