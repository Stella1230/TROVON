static void gx_save_regs(struct gxfb_par *par)\r\n{\r\nint i;\r\ndo {\r\ni = read_gp(par, GP_BLT_STATUS);\r\n} while (i & (GP_BLT_STATUS_BLT_PENDING | GP_BLT_STATUS_BLT_BUSY));\r\nrdmsrl(MSR_GX_MSR_PADSEL, par->msr.padsel);\r\nrdmsrl(MSR_GLCP_DOTPLL, par->msr.dotpll);\r\nwrite_dc(par, DC_UNLOCK, DC_UNLOCK_UNLOCK);\r\nmemcpy(par->gp, par->gp_regs, sizeof(par->gp));\r\nmemcpy(par->dc, par->dc_regs, sizeof(par->dc));\r\nmemcpy(par->vp, par->vid_regs, sizeof(par->vp));\r\nmemcpy(par->fp, par->vid_regs + VP_FP_START, sizeof(par->fp));\r\nwrite_dc(par, DC_PAL_ADDRESS, 0);\r\nfor (i = 0; i < ARRAY_SIZE(par->pal); i++)\r\npar->pal[i] = read_dc(par, DC_PAL_DATA);\r\n}\r\nstatic void gx_set_dotpll(uint32_t dotpll_hi)\r\n{\r\nuint32_t dotpll_lo;\r\nint i;\r\nrdmsrl(MSR_GLCP_DOTPLL, dotpll_lo);\r\ndotpll_lo |= MSR_GLCP_DOTPLL_DOTRESET;\r\ndotpll_lo &= ~MSR_GLCP_DOTPLL_BYPASS;\r\nwrmsr(MSR_GLCP_DOTPLL, dotpll_lo, dotpll_hi);\r\nfor (i = 0; i < 200; i++) {\r\nrdmsrl(MSR_GLCP_DOTPLL, dotpll_lo);\r\nif (dotpll_lo & MSR_GLCP_DOTPLL_LOCK)\r\nbreak;\r\nudelay(1);\r\n}\r\ndotpll_lo &= ~MSR_GLCP_DOTPLL_DOTRESET;\r\nwrmsr(MSR_GLCP_DOTPLL, dotpll_lo, dotpll_hi);\r\n}\r\nstatic void gx_restore_gfx_proc(struct gxfb_par *par)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(par->gp); i++) {\r\nswitch (i) {\r\ncase GP_VECTOR_MODE:\r\ncase GP_BLT_MODE:\r\ncase GP_BLT_STATUS:\r\ncase GP_HST_SRC:\r\nbreak;\r\ndefault:\r\nwrite_gp(par, i, par->gp[i]);\r\n}\r\n}\r\n}\r\nstatic void gx_restore_display_ctlr(struct gxfb_par *par)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(par->dc); i++) {\r\nswitch (i) {\r\ncase DC_UNLOCK:\r\nwrite_dc(par, DC_UNLOCK, DC_UNLOCK_UNLOCK);\r\nbreak;\r\ncase DC_GENERAL_CFG:\r\nwrite_dc(par, i, par->dc[i] & ~(DC_GENERAL_CFG_VIDE |\r\nDC_GENERAL_CFG_ICNE |\r\nDC_GENERAL_CFG_CURE |\r\nDC_GENERAL_CFG_DFLE));\r\nbreak;\r\ncase DC_DISPLAY_CFG:\r\nwrite_dc(par, i, par->dc[i] & ~(DC_DISPLAY_CFG_VDEN |\r\nDC_DISPLAY_CFG_GDEN |\r\nDC_DISPLAY_CFG_TGEN));\r\nbreak;\r\ncase DC_RSVD_0:\r\ncase DC_RSVD_1:\r\ncase DC_RSVD_2:\r\ncase DC_RSVD_3:\r\ncase DC_RSVD_4:\r\ncase DC_LINE_CNT:\r\ncase DC_PAL_ADDRESS:\r\ncase DC_PAL_DATA:\r\ncase DC_DFIFO_DIAG:\r\ncase DC_CFIFO_DIAG:\r\ncase DC_RSVD_5:\r\nbreak;\r\ndefault:\r\nwrite_dc(par, i, par->dc[i]);\r\n}\r\n}\r\nwrite_dc(par, DC_PAL_ADDRESS, 0);\r\nfor (i = 0; i < ARRAY_SIZE(par->pal); i++)\r\nwrite_dc(par, DC_PAL_DATA, par->pal[i]);\r\n}\r\nstatic void gx_restore_video_proc(struct gxfb_par *par)\r\n{\r\nint i;\r\nwrmsrl(MSR_GX_MSR_PADSEL, par->msr.padsel);\r\nfor (i = 0; i < ARRAY_SIZE(par->vp); i++) {\r\nswitch (i) {\r\ncase VP_VCFG:\r\nwrite_vp(par, i, par->vp[i] & ~VP_VCFG_VID_EN);\r\nbreak;\r\ncase VP_DCFG:\r\nwrite_vp(par, i, par->vp[i] &\r\n~(VP_DCFG_DAC_BL_EN | VP_DCFG_VSYNC_EN |\r\nVP_DCFG_HSYNC_EN | VP_DCFG_CRT_EN));\r\nbreak;\r\ncase VP_GAR:\r\ncase VP_GDR:\r\ncase VP_RSVD_0:\r\ncase VP_RSVD_1:\r\ncase VP_RSVD_2:\r\ncase VP_RSVD_3:\r\ncase VP_CRC32:\r\ncase VP_AWT:\r\ncase VP_VTM:\r\nbreak;\r\ndefault:\r\nwrite_vp(par, i, par->vp[i]);\r\n}\r\n}\r\n}\r\nstatic void gx_restore_regs(struct gxfb_par *par)\r\n{\r\nint i;\r\ngx_set_dotpll((uint32_t) (par->msr.dotpll >> 32));\r\ngx_restore_gfx_proc(par);\r\ngx_restore_display_ctlr(par);\r\ngx_restore_video_proc(par);\r\nfor (i = 0; i < ARRAY_SIZE(par->fp); i++) {\r\nif (i != FP_PM && i != FP_RSVD_0)\r\nwrite_fp(par, i, par->fp[i]);\r\n}\r\n}\r\nstatic void gx_disable_graphics(struct gxfb_par *par)\r\n{\r\nwrite_vp(par, VP_VCFG, par->vp[VP_VCFG] & ~VP_VCFG_VID_EN);\r\nwrite_vp(par, VP_DCFG, par->vp[VP_DCFG] & ~(VP_DCFG_DAC_BL_EN |\r\nVP_DCFG_VSYNC_EN | VP_DCFG_HSYNC_EN | VP_DCFG_CRT_EN));\r\nwrite_fp(par, FP_PM, par->fp[FP_PM] & ~FP_PM_P);\r\nwrite_dc(par, DC_UNLOCK, DC_UNLOCK_UNLOCK);\r\nwrite_dc(par, DC_GENERAL_CFG, par->dc[DC_GENERAL_CFG] &\r\n~(DC_GENERAL_CFG_VIDE | DC_GENERAL_CFG_ICNE |\r\nDC_GENERAL_CFG_CURE | DC_GENERAL_CFG_DFLE));\r\nwrite_dc(par, DC_DISPLAY_CFG, par->dc[DC_DISPLAY_CFG] &\r\n~(DC_DISPLAY_CFG_VDEN | DC_DISPLAY_CFG_GDEN |\r\nDC_DISPLAY_CFG_TGEN));\r\nwrite_dc(par, DC_UNLOCK, DC_UNLOCK_LOCK);\r\n}\r\nstatic void gx_enable_graphics(struct gxfb_par *par)\r\n{\r\nuint32_t fp;\r\nfp = read_fp(par, FP_PM);\r\nif (par->fp[FP_PM] & FP_PM_P) {\r\nif (!(fp & (FP_PM_PANEL_ON|FP_PM_PANEL_PWR_UP)))\r\nwrite_fp(par, FP_PM, par->fp[FP_PM]);\r\n} else {\r\nif (!(fp & (FP_PM_PANEL_OFF|FP_PM_PANEL_PWR_DOWN)))\r\nwrite_fp(par, FP_PM, par->fp[FP_PM]);\r\n}\r\nwrite_vp(par, VP_VCFG, par->vp[VP_VCFG]);\r\nwrite_vp(par, VP_DCFG, par->vp[VP_DCFG]);\r\nwrite_dc(par, DC_DISPLAY_CFG, par->dc[DC_DISPLAY_CFG]);\r\nwrite_dc(par, DC_GENERAL_CFG, par->dc[DC_GENERAL_CFG]);\r\nwrite_dc(par, DC_UNLOCK, DC_UNLOCK_LOCK);\r\n}\r\nint gx_powerdown(struct fb_info *info)\r\n{\r\nstruct gxfb_par *par = info->par;\r\nif (par->powered_down)\r\nreturn 0;\r\ngx_save_regs(par);\r\ngx_disable_graphics(par);\r\npar->powered_down = 1;\r\nreturn 0;\r\n}\r\nint gx_powerup(struct fb_info *info)\r\n{\r\nstruct gxfb_par *par = info->par;\r\nif (!par->powered_down)\r\nreturn 0;\r\ngx_restore_regs(par);\r\ngx_enable_graphics(par);\r\npar->powered_down = 0;\r\nreturn 0;\r\n}
