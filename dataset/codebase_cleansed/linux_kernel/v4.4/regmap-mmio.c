static inline void regmap_mmio_regsize_check(size_t reg_size)\r\n{\r\nswitch (reg_size) {\r\ncase 1:\r\ncase 2:\r\ncase 4:\r\n#ifdef CONFIG_64BIT\r\ncase 8:\r\n#endif\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic int regmap_mmio_regbits_check(size_t reg_bits)\r\n{\r\nswitch (reg_bits) {\r\ncase 8:\r\ncase 16:\r\ncase 32:\r\n#ifdef CONFIG_64BIT\r\ncase 64:\r\n#endif\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic inline void regmap_mmio_count_check(size_t count, u32 offset)\r\n{\r\nBUG_ON(count <= offset);\r\n}\r\nstatic inline unsigned int\r\nregmap_mmio_get_offset(const void *reg, size_t reg_size)\r\n{\r\nswitch (reg_size) {\r\ncase 1:\r\nreturn *(u8 *)reg;\r\ncase 2:\r\nreturn *(u16 *)reg;\r\ncase 4:\r\nreturn *(u32 *)reg;\r\n#ifdef CONFIG_64BIT\r\ncase 8:\r\nreturn *(u64 *)reg;\r\n#endif\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic int regmap_mmio_gather_write(void *context,\r\nconst void *reg, size_t reg_size,\r\nconst void *val, size_t val_size)\r\n{\r\nstruct regmap_mmio_context *ctx = context;\r\nunsigned int offset;\r\nint ret;\r\nregmap_mmio_regsize_check(reg_size);\r\nif (!IS_ERR(ctx->clk)) {\r\nret = clk_enable(ctx->clk);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\noffset = regmap_mmio_get_offset(reg, reg_size);\r\nwhile (val_size) {\r\nswitch (ctx->val_bytes) {\r\ncase 1:\r\nwriteb(*(u8 *)val, ctx->regs + offset);\r\nbreak;\r\ncase 2:\r\nwritew(*(u16 *)val, ctx->regs + offset);\r\nbreak;\r\ncase 4:\r\nwritel(*(u32 *)val, ctx->regs + offset);\r\nbreak;\r\n#ifdef CONFIG_64BIT\r\ncase 8:\r\nwriteq(*(u64 *)val, ctx->regs + offset);\r\nbreak;\r\n#endif\r\ndefault:\r\nBUG();\r\n}\r\nval_size -= ctx->val_bytes;\r\nval += ctx->val_bytes;\r\noffset += ctx->val_bytes;\r\n}\r\nif (!IS_ERR(ctx->clk))\r\nclk_disable(ctx->clk);\r\nreturn 0;\r\n}\r\nstatic int regmap_mmio_write(void *context, const void *data, size_t count)\r\n{\r\nstruct regmap_mmio_context *ctx = context;\r\nunsigned int offset = ctx->reg_bytes + ctx->pad_bytes;\r\nregmap_mmio_count_check(count, offset);\r\nreturn regmap_mmio_gather_write(context, data, ctx->reg_bytes,\r\ndata + offset, count - offset);\r\n}\r\nstatic int regmap_mmio_read(void *context,\r\nconst void *reg, size_t reg_size,\r\nvoid *val, size_t val_size)\r\n{\r\nstruct regmap_mmio_context *ctx = context;\r\nunsigned int offset;\r\nint ret;\r\nregmap_mmio_regsize_check(reg_size);\r\nif (!IS_ERR(ctx->clk)) {\r\nret = clk_enable(ctx->clk);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\noffset = regmap_mmio_get_offset(reg, reg_size);\r\nwhile (val_size) {\r\nswitch (ctx->val_bytes) {\r\ncase 1:\r\n*(u8 *)val = readb(ctx->regs + offset);\r\nbreak;\r\ncase 2:\r\n*(u16 *)val = readw(ctx->regs + offset);\r\nbreak;\r\ncase 4:\r\n*(u32 *)val = readl(ctx->regs + offset);\r\nbreak;\r\n#ifdef CONFIG_64BIT\r\ncase 8:\r\n*(u64 *)val = readq(ctx->regs + offset);\r\nbreak;\r\n#endif\r\ndefault:\r\nBUG();\r\n}\r\nval_size -= ctx->val_bytes;\r\nval += ctx->val_bytes;\r\noffset += ctx->val_bytes;\r\n}\r\nif (!IS_ERR(ctx->clk))\r\nclk_disable(ctx->clk);\r\nreturn 0;\r\n}\r\nstatic void regmap_mmio_free_context(void *context)\r\n{\r\nstruct regmap_mmio_context *ctx = context;\r\nif (!IS_ERR(ctx->clk)) {\r\nclk_unprepare(ctx->clk);\r\nclk_put(ctx->clk);\r\n}\r\nkfree(context);\r\n}\r\nstatic struct regmap_mmio_context *regmap_mmio_gen_context(struct device *dev,\r\nconst char *clk_id,\r\nvoid __iomem *regs,\r\nconst struct regmap_config *config)\r\n{\r\nstruct regmap_mmio_context *ctx;\r\nint min_stride;\r\nint ret;\r\nret = regmap_mmio_regbits_check(config->reg_bits);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nif (config->pad_bits)\r\nreturn ERR_PTR(-EINVAL);\r\nswitch (config->val_bits) {\r\ncase 8:\r\nmin_stride = 0;\r\nbreak;\r\ncase 16:\r\nmin_stride = 2;\r\nbreak;\r\ncase 32:\r\nmin_stride = 4;\r\nbreak;\r\n#ifdef CONFIG_64BIT\r\ncase 64:\r\nmin_stride = 8;\r\nbreak;\r\n#endif\r\nbreak;\r\ndefault:\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (config->reg_stride < min_stride)\r\nreturn ERR_PTR(-EINVAL);\r\nswitch (config->reg_format_endian) {\r\ncase REGMAP_ENDIAN_DEFAULT:\r\ncase REGMAP_ENDIAN_NATIVE:\r\nbreak;\r\ndefault:\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn ERR_PTR(-ENOMEM);\r\nctx->regs = regs;\r\nctx->val_bytes = config->val_bits / 8;\r\nctx->reg_bytes = config->reg_bits / 8;\r\nctx->pad_bytes = config->pad_bits / 8;\r\nctx->clk = ERR_PTR(-ENODEV);\r\nif (clk_id == NULL)\r\nreturn ctx;\r\nctx->clk = clk_get(dev, clk_id);\r\nif (IS_ERR(ctx->clk)) {\r\nret = PTR_ERR(ctx->clk);\r\ngoto err_free;\r\n}\r\nret = clk_prepare(ctx->clk);\r\nif (ret < 0) {\r\nclk_put(ctx->clk);\r\ngoto err_free;\r\n}\r\nreturn ctx;\r\nerr_free:\r\nkfree(ctx);\r\nreturn ERR_PTR(ret);\r\n}\r\nstruct regmap *__regmap_init_mmio_clk(struct device *dev, const char *clk_id,\r\nvoid __iomem *regs,\r\nconst struct regmap_config *config,\r\nstruct lock_class_key *lock_key,\r\nconst char *lock_name)\r\n{\r\nstruct regmap_mmio_context *ctx;\r\nctx = regmap_mmio_gen_context(dev, clk_id, regs, config);\r\nif (IS_ERR(ctx))\r\nreturn ERR_CAST(ctx);\r\nreturn __regmap_init(dev, &regmap_mmio, ctx, config,\r\nlock_key, lock_name);\r\n}\r\nstruct regmap *__devm_regmap_init_mmio_clk(struct device *dev,\r\nconst char *clk_id,\r\nvoid __iomem *regs,\r\nconst struct regmap_config *config,\r\nstruct lock_class_key *lock_key,\r\nconst char *lock_name)\r\n{\r\nstruct regmap_mmio_context *ctx;\r\nctx = regmap_mmio_gen_context(dev, clk_id, regs, config);\r\nif (IS_ERR(ctx))\r\nreturn ERR_CAST(ctx);\r\nreturn __devm_regmap_init(dev, &regmap_mmio, ctx, config,\r\nlock_key, lock_name);\r\n}
