static int garp_attr_cmp(const struct garp_attr *attr,\r\nconst void *data, u8 len, u8 type)\r\n{\r\nif (attr->type != type)\r\nreturn attr->type - type;\r\nif (attr->dlen != len)\r\nreturn attr->dlen - len;\r\nreturn memcmp(attr->data, data, len);\r\n}\r\nstatic struct garp_attr *garp_attr_lookup(const struct garp_applicant *app,\r\nconst void *data, u8 len, u8 type)\r\n{\r\nstruct rb_node *parent = app->gid.rb_node;\r\nstruct garp_attr *attr;\r\nint d;\r\nwhile (parent) {\r\nattr = rb_entry(parent, struct garp_attr, node);\r\nd = garp_attr_cmp(attr, data, len, type);\r\nif (d > 0)\r\nparent = parent->rb_left;\r\nelse if (d < 0)\r\nparent = parent->rb_right;\r\nelse\r\nreturn attr;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct garp_attr *garp_attr_create(struct garp_applicant *app,\r\nconst void *data, u8 len, u8 type)\r\n{\r\nstruct rb_node *parent = NULL, **p = &app->gid.rb_node;\r\nstruct garp_attr *attr;\r\nint d;\r\nwhile (*p) {\r\nparent = *p;\r\nattr = rb_entry(parent, struct garp_attr, node);\r\nd = garp_attr_cmp(attr, data, len, type);\r\nif (d > 0)\r\np = &parent->rb_left;\r\nelse if (d < 0)\r\np = &parent->rb_right;\r\nelse {\r\nreturn attr;\r\n}\r\n}\r\nattr = kmalloc(sizeof(*attr) + len, GFP_ATOMIC);\r\nif (!attr)\r\nreturn attr;\r\nattr->state = GARP_APPLICANT_VO;\r\nattr->type = type;\r\nattr->dlen = len;\r\nmemcpy(attr->data, data, len);\r\nrb_link_node(&attr->node, parent, p);\r\nrb_insert_color(&attr->node, &app->gid);\r\nreturn attr;\r\n}\r\nstatic void garp_attr_destroy(struct garp_applicant *app, struct garp_attr *attr)\r\n{\r\nrb_erase(&attr->node, &app->gid);\r\nkfree(attr);\r\n}\r\nstatic int garp_pdu_init(struct garp_applicant *app)\r\n{\r\nstruct sk_buff *skb;\r\nstruct garp_pdu_hdr *gp;\r\n#define LLC_RESERVE sizeof(struct llc_pdu_un)\r\nskb = alloc_skb(app->dev->mtu + LL_RESERVED_SPACE(app->dev),\r\nGFP_ATOMIC);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb->dev = app->dev;\r\nskb->protocol = htons(ETH_P_802_2);\r\nskb_reserve(skb, LL_RESERVED_SPACE(app->dev) + LLC_RESERVE);\r\ngp = (struct garp_pdu_hdr *)__skb_put(skb, sizeof(*gp));\r\nput_unaligned(htons(GARP_PROTOCOL_ID), &gp->protocol);\r\napp->pdu = skb;\r\nreturn 0;\r\n}\r\nstatic int garp_pdu_append_end_mark(struct garp_applicant *app)\r\n{\r\nif (skb_tailroom(app->pdu) < sizeof(u8))\r\nreturn -1;\r\n*(u8 *)__skb_put(app->pdu, sizeof(u8)) = GARP_END_MARK;\r\nreturn 0;\r\n}\r\nstatic void garp_pdu_queue(struct garp_applicant *app)\r\n{\r\nif (!app->pdu)\r\nreturn;\r\ngarp_pdu_append_end_mark(app);\r\ngarp_pdu_append_end_mark(app);\r\nllc_pdu_header_init(app->pdu, LLC_PDU_TYPE_U, LLC_SAP_BSPAN,\r\nLLC_SAP_BSPAN, LLC_PDU_CMD);\r\nllc_pdu_init_as_ui_cmd(app->pdu);\r\nllc_mac_hdr_init(app->pdu, app->dev->dev_addr,\r\napp->app->proto.group_address);\r\nskb_queue_tail(&app->queue, app->pdu);\r\napp->pdu = NULL;\r\n}\r\nstatic void garp_queue_xmit(struct garp_applicant *app)\r\n{\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(&app->queue)))\r\ndev_queue_xmit(skb);\r\n}\r\nstatic int garp_pdu_append_msg(struct garp_applicant *app, u8 attrtype)\r\n{\r\nstruct garp_msg_hdr *gm;\r\nif (skb_tailroom(app->pdu) < sizeof(*gm))\r\nreturn -1;\r\ngm = (struct garp_msg_hdr *)__skb_put(app->pdu, sizeof(*gm));\r\ngm->attrtype = attrtype;\r\ngarp_cb(app->pdu)->cur_type = attrtype;\r\nreturn 0;\r\n}\r\nstatic int garp_pdu_append_attr(struct garp_applicant *app,\r\nconst struct garp_attr *attr,\r\nenum garp_attr_event event)\r\n{\r\nstruct garp_attr_hdr *ga;\r\nunsigned int len;\r\nint err;\r\nagain:\r\nif (!app->pdu) {\r\nerr = garp_pdu_init(app);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (garp_cb(app->pdu)->cur_type != attr->type) {\r\nif (garp_cb(app->pdu)->cur_type &&\r\ngarp_pdu_append_end_mark(app) < 0)\r\ngoto queue;\r\nif (garp_pdu_append_msg(app, attr->type) < 0)\r\ngoto queue;\r\n}\r\nlen = sizeof(*ga) + attr->dlen;\r\nif (skb_tailroom(app->pdu) < len)\r\ngoto queue;\r\nga = (struct garp_attr_hdr *)__skb_put(app->pdu, len);\r\nga->len = len;\r\nga->event = event;\r\nmemcpy(ga->data, attr->data, attr->dlen);\r\nreturn 0;\r\nqueue:\r\ngarp_pdu_queue(app);\r\ngoto again;\r\n}\r\nstatic void garp_attr_event(struct garp_applicant *app,\r\nstruct garp_attr *attr, enum garp_event event)\r\n{\r\nenum garp_applicant_state state;\r\nstate = garp_applicant_state_table[attr->state][event].state;\r\nif (state == GARP_APPLICANT_INVALID)\r\nreturn;\r\nswitch (garp_applicant_state_table[attr->state][event].action) {\r\ncase GARP_ACTION_NONE:\r\nbreak;\r\ncase GARP_ACTION_S_JOIN_IN:\r\nif (garp_pdu_append_attr(app, attr, GARP_JOIN_IN) < 0)\r\nreturn;\r\nbreak;\r\ncase GARP_ACTION_S_LEAVE_EMPTY:\r\ngarp_pdu_append_attr(app, attr, GARP_LEAVE_EMPTY);\r\ngarp_attr_destroy(app, attr);\r\nreturn;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\nattr->state = state;\r\n}\r\nint garp_request_join(const struct net_device *dev,\r\nconst struct garp_application *appl,\r\nconst void *data, u8 len, u8 type)\r\n{\r\nstruct garp_port *port = rtnl_dereference(dev->garp_port);\r\nstruct garp_applicant *app = rtnl_dereference(port->applicants[appl->type]);\r\nstruct garp_attr *attr;\r\nspin_lock_bh(&app->lock);\r\nattr = garp_attr_create(app, data, len, type);\r\nif (!attr) {\r\nspin_unlock_bh(&app->lock);\r\nreturn -ENOMEM;\r\n}\r\ngarp_attr_event(app, attr, GARP_EVENT_REQ_JOIN);\r\nspin_unlock_bh(&app->lock);\r\nreturn 0;\r\n}\r\nvoid garp_request_leave(const struct net_device *dev,\r\nconst struct garp_application *appl,\r\nconst void *data, u8 len, u8 type)\r\n{\r\nstruct garp_port *port = rtnl_dereference(dev->garp_port);\r\nstruct garp_applicant *app = rtnl_dereference(port->applicants[appl->type]);\r\nstruct garp_attr *attr;\r\nspin_lock_bh(&app->lock);\r\nattr = garp_attr_lookup(app, data, len, type);\r\nif (!attr) {\r\nspin_unlock_bh(&app->lock);\r\nreturn;\r\n}\r\ngarp_attr_event(app, attr, GARP_EVENT_REQ_LEAVE);\r\nspin_unlock_bh(&app->lock);\r\n}\r\nstatic void garp_gid_event(struct garp_applicant *app, enum garp_event event)\r\n{\r\nstruct rb_node *node, *next;\r\nstruct garp_attr *attr;\r\nfor (node = rb_first(&app->gid);\r\nnext = node ? rb_next(node) : NULL, node != NULL;\r\nnode = next) {\r\nattr = rb_entry(node, struct garp_attr, node);\r\ngarp_attr_event(app, attr, event);\r\n}\r\n}\r\nstatic void garp_join_timer_arm(struct garp_applicant *app)\r\n{\r\nunsigned long delay;\r\ndelay = (u64)msecs_to_jiffies(garp_join_time) * prandom_u32() >> 32;\r\nmod_timer(&app->join_timer, jiffies + delay);\r\n}\r\nstatic void garp_join_timer(unsigned long data)\r\n{\r\nstruct garp_applicant *app = (struct garp_applicant *)data;\r\nspin_lock(&app->lock);\r\ngarp_gid_event(app, GARP_EVENT_TRANSMIT_PDU);\r\ngarp_pdu_queue(app);\r\nspin_unlock(&app->lock);\r\ngarp_queue_xmit(app);\r\ngarp_join_timer_arm(app);\r\n}\r\nstatic int garp_pdu_parse_end_mark(struct sk_buff *skb)\r\n{\r\nif (!pskb_may_pull(skb, sizeof(u8)))\r\nreturn -1;\r\nif (*skb->data == GARP_END_MARK) {\r\nskb_pull(skb, sizeof(u8));\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int garp_pdu_parse_attr(struct garp_applicant *app, struct sk_buff *skb,\r\nu8 attrtype)\r\n{\r\nconst struct garp_attr_hdr *ga;\r\nstruct garp_attr *attr;\r\nenum garp_event event;\r\nunsigned int dlen;\r\nif (!pskb_may_pull(skb, sizeof(*ga)))\r\nreturn -1;\r\nga = (struct garp_attr_hdr *)skb->data;\r\nif (ga->len < sizeof(*ga))\r\nreturn -1;\r\nif (!pskb_may_pull(skb, ga->len))\r\nreturn -1;\r\nskb_pull(skb, ga->len);\r\ndlen = sizeof(*ga) - ga->len;\r\nif (attrtype > app->app->maxattr)\r\nreturn 0;\r\nswitch (ga->event) {\r\ncase GARP_LEAVE_ALL:\r\nif (dlen != 0)\r\nreturn -1;\r\ngarp_gid_event(app, GARP_EVENT_R_LEAVE_EMPTY);\r\nreturn 0;\r\ncase GARP_JOIN_EMPTY:\r\nevent = GARP_EVENT_R_JOIN_EMPTY;\r\nbreak;\r\ncase GARP_JOIN_IN:\r\nevent = GARP_EVENT_R_JOIN_IN;\r\nbreak;\r\ncase GARP_LEAVE_EMPTY:\r\nevent = GARP_EVENT_R_LEAVE_EMPTY;\r\nbreak;\r\ncase GARP_EMPTY:\r\nevent = GARP_EVENT_R_EMPTY;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (dlen == 0)\r\nreturn -1;\r\nattr = garp_attr_lookup(app, ga->data, dlen, attrtype);\r\nif (attr == NULL)\r\nreturn 0;\r\ngarp_attr_event(app, attr, event);\r\nreturn 0;\r\n}\r\nstatic int garp_pdu_parse_msg(struct garp_applicant *app, struct sk_buff *skb)\r\n{\r\nconst struct garp_msg_hdr *gm;\r\nif (!pskb_may_pull(skb, sizeof(*gm)))\r\nreturn -1;\r\ngm = (struct garp_msg_hdr *)skb->data;\r\nif (gm->attrtype == 0)\r\nreturn -1;\r\nskb_pull(skb, sizeof(*gm));\r\nwhile (skb->len > 0) {\r\nif (garp_pdu_parse_attr(app, skb, gm->attrtype) < 0)\r\nreturn -1;\r\nif (garp_pdu_parse_end_mark(skb) < 0)\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void garp_pdu_rcv(const struct stp_proto *proto, struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct garp_application *appl = proto->data;\r\nstruct garp_port *port;\r\nstruct garp_applicant *app;\r\nconst struct garp_pdu_hdr *gp;\r\nport = rcu_dereference(dev->garp_port);\r\nif (!port)\r\ngoto err;\r\napp = rcu_dereference(port->applicants[appl->type]);\r\nif (!app)\r\ngoto err;\r\nif (!pskb_may_pull(skb, sizeof(*gp)))\r\ngoto err;\r\ngp = (struct garp_pdu_hdr *)skb->data;\r\nif (get_unaligned(&gp->protocol) != htons(GARP_PROTOCOL_ID))\r\ngoto err;\r\nskb_pull(skb, sizeof(*gp));\r\nspin_lock(&app->lock);\r\nwhile (skb->len > 0) {\r\nif (garp_pdu_parse_msg(app, skb) < 0)\r\nbreak;\r\nif (garp_pdu_parse_end_mark(skb) < 0)\r\nbreak;\r\n}\r\nspin_unlock(&app->lock);\r\nerr:\r\nkfree_skb(skb);\r\n}\r\nstatic int garp_init_port(struct net_device *dev)\r\n{\r\nstruct garp_port *port;\r\nport = kzalloc(sizeof(*port), GFP_KERNEL);\r\nif (!port)\r\nreturn -ENOMEM;\r\nrcu_assign_pointer(dev->garp_port, port);\r\nreturn 0;\r\n}\r\nstatic void garp_release_port(struct net_device *dev)\r\n{\r\nstruct garp_port *port = rtnl_dereference(dev->garp_port);\r\nunsigned int i;\r\nfor (i = 0; i <= GARP_APPLICATION_MAX; i++) {\r\nif (rtnl_dereference(port->applicants[i]))\r\nreturn;\r\n}\r\nRCU_INIT_POINTER(dev->garp_port, NULL);\r\nkfree_rcu(port, rcu);\r\n}\r\nint garp_init_applicant(struct net_device *dev, struct garp_application *appl)\r\n{\r\nstruct garp_applicant *app;\r\nint err;\r\nASSERT_RTNL();\r\nif (!rtnl_dereference(dev->garp_port)) {\r\nerr = garp_init_port(dev);\r\nif (err < 0)\r\ngoto err1;\r\n}\r\nerr = -ENOMEM;\r\napp = kzalloc(sizeof(*app), GFP_KERNEL);\r\nif (!app)\r\ngoto err2;\r\nerr = dev_mc_add(dev, appl->proto.group_address);\r\nif (err < 0)\r\ngoto err3;\r\napp->dev = dev;\r\napp->app = appl;\r\napp->gid = RB_ROOT;\r\nspin_lock_init(&app->lock);\r\nskb_queue_head_init(&app->queue);\r\nrcu_assign_pointer(dev->garp_port->applicants[appl->type], app);\r\nsetup_timer(&app->join_timer, garp_join_timer, (unsigned long)app);\r\ngarp_join_timer_arm(app);\r\nreturn 0;\r\nerr3:\r\nkfree(app);\r\nerr2:\r\ngarp_release_port(dev);\r\nerr1:\r\nreturn err;\r\n}\r\nvoid garp_uninit_applicant(struct net_device *dev, struct garp_application *appl)\r\n{\r\nstruct garp_port *port = rtnl_dereference(dev->garp_port);\r\nstruct garp_applicant *app = rtnl_dereference(port->applicants[appl->type]);\r\nASSERT_RTNL();\r\nRCU_INIT_POINTER(port->applicants[appl->type], NULL);\r\ndel_timer_sync(&app->join_timer);\r\nspin_lock_bh(&app->lock);\r\ngarp_gid_event(app, GARP_EVENT_TRANSMIT_PDU);\r\ngarp_pdu_queue(app);\r\nspin_unlock_bh(&app->lock);\r\ngarp_queue_xmit(app);\r\ndev_mc_del(dev, appl->proto.group_address);\r\nkfree_rcu(app, rcu);\r\ngarp_release_port(dev);\r\n}\r\nint garp_register_application(struct garp_application *appl)\r\n{\r\nappl->proto.rcv = garp_pdu_rcv;\r\nappl->proto.data = appl;\r\nreturn stp_proto_register(&appl->proto);\r\n}\r\nvoid garp_unregister_application(struct garp_application *appl)\r\n{\r\nstp_proto_unregister(&appl->proto);\r\n}
