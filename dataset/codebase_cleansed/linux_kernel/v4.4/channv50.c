static int\r\nnv50_fifo_chan_engine_addr(struct nvkm_engine *engine)\r\n{\r\nswitch (engine->subdev.index) {\r\ncase NVKM_ENGINE_DMAOBJ:\r\ncase NVKM_ENGINE_SW : return -1;\r\ncase NVKM_ENGINE_GR : return 0x0000;\r\ncase NVKM_ENGINE_MPEG : return 0x0060;\r\ndefault:\r\nWARN_ON(1);\r\nreturn -1;\r\n}\r\n}\r\nstatic int\r\nnv50_fifo_chan_engine_fini(struct nvkm_fifo_chan *base,\r\nstruct nvkm_engine *engine, bool suspend)\r\n{\r\nstruct nv50_fifo_chan *chan = nv50_fifo_chan(base);\r\nstruct nv50_fifo *fifo = chan->fifo;\r\nstruct nvkm_subdev *subdev = &fifo->base.engine.subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nint offset, ret = 0;\r\nu32 me;\r\noffset = nv50_fifo_chan_engine_addr(engine);\r\nif (offset < 0)\r\nreturn 0;\r\nme = nvkm_mask(device, 0x00b860, 0x00000001, 0x00000001);\r\nnvkm_wr32(device, 0x0032fc, chan->base.inst->addr >> 12);\r\nif (nvkm_msec(device, 2000,\r\nif (nvkm_rd32(device, 0x0032fc) != 0xffffffff)\r\nbreak;\r\n) < 0) {\r\nnvkm_error(subdev, "channel %d [%s] unload timeout\n",\r\nchan->base.chid, chan->base.object.client->name);\r\nif (suspend)\r\nret = -EBUSY;\r\n}\r\nnvkm_wr32(device, 0x00b860, me);\r\nif (ret == 0) {\r\nnvkm_kmap(chan->eng);\r\nnvkm_wo32(chan->eng, offset + 0x00, 0x00000000);\r\nnvkm_wo32(chan->eng, offset + 0x04, 0x00000000);\r\nnvkm_wo32(chan->eng, offset + 0x08, 0x00000000);\r\nnvkm_wo32(chan->eng, offset + 0x0c, 0x00000000);\r\nnvkm_wo32(chan->eng, offset + 0x10, 0x00000000);\r\nnvkm_wo32(chan->eng, offset + 0x14, 0x00000000);\r\nnvkm_done(chan->eng);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nnv50_fifo_chan_engine_init(struct nvkm_fifo_chan *base,\r\nstruct nvkm_engine *engine)\r\n{\r\nstruct nv50_fifo_chan *chan = nv50_fifo_chan(base);\r\nstruct nvkm_gpuobj *engn = chan->engn[engine->subdev.index];\r\nu64 limit, start;\r\nint offset;\r\noffset = nv50_fifo_chan_engine_addr(engine);\r\nif (offset < 0)\r\nreturn 0;\r\nlimit = engn->addr + engn->size - 1;\r\nstart = engn->addr;\r\nnvkm_kmap(chan->eng);\r\nnvkm_wo32(chan->eng, offset + 0x00, 0x00190000);\r\nnvkm_wo32(chan->eng, offset + 0x04, lower_32_bits(limit));\r\nnvkm_wo32(chan->eng, offset + 0x08, lower_32_bits(start));\r\nnvkm_wo32(chan->eng, offset + 0x0c, upper_32_bits(limit) << 24 |\r\nupper_32_bits(start));\r\nnvkm_wo32(chan->eng, offset + 0x10, 0x00000000);\r\nnvkm_wo32(chan->eng, offset + 0x14, 0x00000000);\r\nnvkm_done(chan->eng);\r\nreturn 0;\r\n}\r\nvoid\r\nnv50_fifo_chan_engine_dtor(struct nvkm_fifo_chan *base,\r\nstruct nvkm_engine *engine)\r\n{\r\nstruct nv50_fifo_chan *chan = nv50_fifo_chan(base);\r\nnvkm_gpuobj_del(&chan->engn[engine->subdev.index]);\r\n}\r\nstatic int\r\nnv50_fifo_chan_engine_ctor(struct nvkm_fifo_chan *base,\r\nstruct nvkm_engine *engine,\r\nstruct nvkm_object *object)\r\n{\r\nstruct nv50_fifo_chan *chan = nv50_fifo_chan(base);\r\nint engn = engine->subdev.index;\r\nif (nv50_fifo_chan_engine_addr(engine) < 0)\r\nreturn 0;\r\nreturn nvkm_object_bind(object, NULL, 0, &chan->engn[engn]);\r\n}\r\nvoid\r\nnv50_fifo_chan_object_dtor(struct nvkm_fifo_chan *base, int cookie)\r\n{\r\nstruct nv50_fifo_chan *chan = nv50_fifo_chan(base);\r\nnvkm_ramht_remove(chan->ramht, cookie);\r\n}\r\nstatic int\r\nnv50_fifo_chan_object_ctor(struct nvkm_fifo_chan *base,\r\nstruct nvkm_object *object)\r\n{\r\nstruct nv50_fifo_chan *chan = nv50_fifo_chan(base);\r\nu32 handle = object->handle;\r\nu32 context;\r\nswitch (object->engine->subdev.index) {\r\ncase NVKM_ENGINE_DMAOBJ:\r\ncase NVKM_ENGINE_SW : context = 0x00000000; break;\r\ncase NVKM_ENGINE_GR : context = 0x00100000; break;\r\ncase NVKM_ENGINE_MPEG : context = 0x00200000; break;\r\ndefault:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nreturn nvkm_ramht_insert(chan->ramht, object, 0, 4, handle, context);\r\n}\r\nvoid\r\nnv50_fifo_chan_fini(struct nvkm_fifo_chan *base)\r\n{\r\nstruct nv50_fifo_chan *chan = nv50_fifo_chan(base);\r\nstruct nv50_fifo *fifo = chan->fifo;\r\nstruct nvkm_device *device = fifo->base.engine.subdev.device;\r\nu32 chid = chan->base.chid;\r\nnvkm_mask(device, 0x002600 + (chid * 4), 0x80000000, 0x00000000);\r\nnv50_fifo_runlist_update(fifo);\r\nnvkm_wr32(device, 0x002600 + (chid * 4), 0x00000000);\r\n}\r\nstatic void\r\nnv50_fifo_chan_init(struct nvkm_fifo_chan *base)\r\n{\r\nstruct nv50_fifo_chan *chan = nv50_fifo_chan(base);\r\nstruct nv50_fifo *fifo = chan->fifo;\r\nstruct nvkm_device *device = fifo->base.engine.subdev.device;\r\nu64 addr = chan->ramfc->addr >> 12;\r\nu32 chid = chan->base.chid;\r\nnvkm_wr32(device, 0x002600 + (chid * 4), 0x80000000 | addr);\r\nnv50_fifo_runlist_update(fifo);\r\n}\r\nvoid *\r\nnv50_fifo_chan_dtor(struct nvkm_fifo_chan *base)\r\n{\r\nstruct nv50_fifo_chan *chan = nv50_fifo_chan(base);\r\nnvkm_vm_ref(NULL, &chan->vm, chan->pgd);\r\nnvkm_ramht_del(&chan->ramht);\r\nnvkm_gpuobj_del(&chan->pgd);\r\nnvkm_gpuobj_del(&chan->eng);\r\nnvkm_gpuobj_del(&chan->cache);\r\nnvkm_gpuobj_del(&chan->ramfc);\r\nreturn chan;\r\n}\r\nint\r\nnv50_fifo_chan_ctor(struct nv50_fifo *fifo, u64 vm, u64 push,\r\nconst struct nvkm_oclass *oclass,\r\nstruct nv50_fifo_chan *chan)\r\n{\r\nstruct nvkm_device *device = fifo->base.engine.subdev.device;\r\nint ret;\r\nret = nvkm_fifo_chan_ctor(&nv50_fifo_chan_func, &fifo->base,\r\n0x10000, 0x1000, false, vm, push,\r\n(1ULL << NVKM_ENGINE_DMAOBJ) |\r\n(1ULL << NVKM_ENGINE_SW) |\r\n(1ULL << NVKM_ENGINE_GR) |\r\n(1ULL << NVKM_ENGINE_MPEG),\r\n0, 0xc00000, 0x2000, oclass, &chan->base);\r\nchan->fifo = fifo;\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_gpuobj_new(device, 0x0200, 0x1000, true, chan->base.inst,\r\n&chan->ramfc);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_gpuobj_new(device, 0x1200, 0, true, chan->base.inst,\r\n&chan->eng);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_gpuobj_new(device, 0x4000, 0, false, chan->base.inst,\r\n&chan->pgd);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_ramht_new(device, 0x8000, 16, chan->base.inst, &chan->ramht);\r\nif (ret)\r\nreturn ret;\r\nreturn nvkm_vm_ref(chan->base.vm, &chan->vm, chan->pgd);\r\n}
