static int filter(const struct dirent *dir)\r\n{\r\nif (dir->d_name[0] == '.')\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic void thread_map__reset(struct thread_map *map, int start, int nr)\r\n{\r\nsize_t size = (nr - start) * sizeof(map->map[0]);\r\nmemset(&map->map[start], 0, size);\r\n}\r\nstatic struct thread_map *thread_map__realloc(struct thread_map *map, int nr)\r\n{\r\nsize_t size = sizeof(*map) + sizeof(map->map[0]) * nr;\r\nint start = map ? map->nr : 0;\r\nmap = realloc(map, size);\r\nif (map)\r\nthread_map__reset(map, start, nr);\r\nreturn map;\r\n}\r\nstruct thread_map *thread_map__new_by_pid(pid_t pid)\r\n{\r\nstruct thread_map *threads;\r\nchar name[256];\r\nint items;\r\nstruct dirent **namelist = NULL;\r\nint i;\r\nsprintf(name, "/proc/%d/task", pid);\r\nitems = scandir(name, &namelist, filter, NULL);\r\nif (items <= 0)\r\nreturn NULL;\r\nthreads = thread_map__alloc(items);\r\nif (threads != NULL) {\r\nfor (i = 0; i < items; i++)\r\nthread_map__set_pid(threads, i, atoi(namelist[i]->d_name));\r\nthreads->nr = items;\r\natomic_set(&threads->refcnt, 1);\r\n}\r\nfor (i=0; i<items; i++)\r\nzfree(&namelist[i]);\r\nfree(namelist);\r\nreturn threads;\r\n}\r\nstruct thread_map *thread_map__new_by_tid(pid_t tid)\r\n{\r\nstruct thread_map *threads = thread_map__alloc(1);\r\nif (threads != NULL) {\r\nthread_map__set_pid(threads, 0, tid);\r\nthreads->nr = 1;\r\natomic_set(&threads->refcnt, 1);\r\n}\r\nreturn threads;\r\n}\r\nstruct thread_map *thread_map__new_by_uid(uid_t uid)\r\n{\r\nDIR *proc;\r\nint max_threads = 32, items, i;\r\nchar path[256];\r\nstruct dirent dirent, *next, **namelist = NULL;\r\nstruct thread_map *threads = thread_map__alloc(max_threads);\r\nif (threads == NULL)\r\ngoto out;\r\nproc = opendir("/proc");\r\nif (proc == NULL)\r\ngoto out_free_threads;\r\nthreads->nr = 0;\r\natomic_set(&threads->refcnt, 1);\r\nwhile (!readdir_r(proc, &dirent, &next) && next) {\r\nchar *end;\r\nbool grow = false;\r\nstruct stat st;\r\npid_t pid = strtol(dirent.d_name, &end, 10);\r\nif (*end)\r\ncontinue;\r\nsnprintf(path, sizeof(path), "/proc/%s", dirent.d_name);\r\nif (stat(path, &st) != 0)\r\ncontinue;\r\nif (st.st_uid != uid)\r\ncontinue;\r\nsnprintf(path, sizeof(path), "/proc/%d/task", pid);\r\nitems = scandir(path, &namelist, filter, NULL);\r\nif (items <= 0)\r\ngoto out_free_closedir;\r\nwhile (threads->nr + items >= max_threads) {\r\nmax_threads *= 2;\r\ngrow = true;\r\n}\r\nif (grow) {\r\nstruct thread_map *tmp;\r\ntmp = thread_map__realloc(threads, max_threads);\r\nif (tmp == NULL)\r\ngoto out_free_namelist;\r\nthreads = tmp;\r\n}\r\nfor (i = 0; i < items; i++) {\r\nthread_map__set_pid(threads, threads->nr + i,\r\natoi(namelist[i]->d_name));\r\n}\r\nfor (i = 0; i < items; i++)\r\nzfree(&namelist[i]);\r\nfree(namelist);\r\nthreads->nr += items;\r\n}\r\nout_closedir:\r\nclosedir(proc);\r\nout:\r\nreturn threads;\r\nout_free_threads:\r\nfree(threads);\r\nreturn NULL;\r\nout_free_namelist:\r\nfor (i = 0; i < items; i++)\r\nzfree(&namelist[i]);\r\nfree(namelist);\r\nout_free_closedir:\r\nzfree(&threads);\r\ngoto out_closedir;\r\n}\r\nstruct thread_map *thread_map__new(pid_t pid, pid_t tid, uid_t uid)\r\n{\r\nif (pid != -1)\r\nreturn thread_map__new_by_pid(pid);\r\nif (tid == -1 && uid != UINT_MAX)\r\nreturn thread_map__new_by_uid(uid);\r\nreturn thread_map__new_by_tid(tid);\r\n}\r\nstatic struct thread_map *thread_map__new_by_pid_str(const char *pid_str)\r\n{\r\nstruct thread_map *threads = NULL, *nt;\r\nchar name[256];\r\nint items, total_tasks = 0;\r\nstruct dirent **namelist = NULL;\r\nint i, j = 0;\r\npid_t pid, prev_pid = INT_MAX;\r\nchar *end_ptr;\r\nstruct str_node *pos;\r\nstruct strlist_config slist_config = { .dont_dupstr = true, };\r\nstruct strlist *slist = strlist__new(pid_str, &slist_config);\r\nif (!slist)\r\nreturn NULL;\r\nstrlist__for_each(pos, slist) {\r\npid = strtol(pos->s, &end_ptr, 10);\r\nif (pid == INT_MIN || pid == INT_MAX ||\r\n(*end_ptr != '\0' && *end_ptr != ','))\r\ngoto out_free_threads;\r\nif (pid == prev_pid)\r\ncontinue;\r\nsprintf(name, "/proc/%d/task", pid);\r\nitems = scandir(name, &namelist, filter, NULL);\r\nif (items <= 0)\r\ngoto out_free_threads;\r\ntotal_tasks += items;\r\nnt = thread_map__realloc(threads, total_tasks);\r\nif (nt == NULL)\r\ngoto out_free_namelist;\r\nthreads = nt;\r\nfor (i = 0; i < items; i++) {\r\nthread_map__set_pid(threads, j++, atoi(namelist[i]->d_name));\r\nzfree(&namelist[i]);\r\n}\r\nthreads->nr = total_tasks;\r\nfree(namelist);\r\n}\r\nout:\r\nstrlist__delete(slist);\r\nif (threads)\r\natomic_set(&threads->refcnt, 1);\r\nreturn threads;\r\nout_free_namelist:\r\nfor (i = 0; i < items; i++)\r\nzfree(&namelist[i]);\r\nfree(namelist);\r\nout_free_threads:\r\nzfree(&threads);\r\ngoto out;\r\n}\r\nstruct thread_map *thread_map__new_dummy(void)\r\n{\r\nstruct thread_map *threads = thread_map__alloc(1);\r\nif (threads != NULL) {\r\nthread_map__set_pid(threads, 0, -1);\r\nthreads->nr = 1;\r\natomic_set(&threads->refcnt, 1);\r\n}\r\nreturn threads;\r\n}\r\nstatic struct thread_map *thread_map__new_by_tid_str(const char *tid_str)\r\n{\r\nstruct thread_map *threads = NULL, *nt;\r\nint ntasks = 0;\r\npid_t tid, prev_tid = INT_MAX;\r\nchar *end_ptr;\r\nstruct str_node *pos;\r\nstruct strlist_config slist_config = { .dont_dupstr = true, };\r\nstruct strlist *slist;\r\nif (!tid_str)\r\nreturn thread_map__new_dummy();\r\nslist = strlist__new(tid_str, &slist_config);\r\nif (!slist)\r\nreturn NULL;\r\nstrlist__for_each(pos, slist) {\r\ntid = strtol(pos->s, &end_ptr, 10);\r\nif (tid == INT_MIN || tid == INT_MAX ||\r\n(*end_ptr != '\0' && *end_ptr != ','))\r\ngoto out_free_threads;\r\nif (tid == prev_tid)\r\ncontinue;\r\nntasks++;\r\nnt = thread_map__realloc(threads, ntasks);\r\nif (nt == NULL)\r\ngoto out_free_threads;\r\nthreads = nt;\r\nthread_map__set_pid(threads, ntasks - 1, tid);\r\nthreads->nr = ntasks;\r\n}\r\nout:\r\nif (threads)\r\natomic_set(&threads->refcnt, 1);\r\nreturn threads;\r\nout_free_threads:\r\nzfree(&threads);\r\ngoto out;\r\n}\r\nstruct thread_map *thread_map__new_str(const char *pid, const char *tid,\r\nuid_t uid)\r\n{\r\nif (pid)\r\nreturn thread_map__new_by_pid_str(pid);\r\nif (!tid && uid != UINT_MAX)\r\nreturn thread_map__new_by_uid(uid);\r\nreturn thread_map__new_by_tid_str(tid);\r\n}\r\nstatic void thread_map__delete(struct thread_map *threads)\r\n{\r\nif (threads) {\r\nint i;\r\nWARN_ONCE(atomic_read(&threads->refcnt) != 0,\r\n"thread map refcnt unbalanced\n");\r\nfor (i = 0; i < threads->nr; i++)\r\nfree(thread_map__comm(threads, i));\r\nfree(threads);\r\n}\r\n}\r\nstruct thread_map *thread_map__get(struct thread_map *map)\r\n{\r\nif (map)\r\natomic_inc(&map->refcnt);\r\nreturn map;\r\n}\r\nvoid thread_map__put(struct thread_map *map)\r\n{\r\nif (map && atomic_dec_and_test(&map->refcnt))\r\nthread_map__delete(map);\r\n}\r\nsize_t thread_map__fprintf(struct thread_map *threads, FILE *fp)\r\n{\r\nint i;\r\nsize_t printed = fprintf(fp, "%d thread%s: ",\r\nthreads->nr, threads->nr > 1 ? "s" : "");\r\nfor (i = 0; i < threads->nr; ++i)\r\nprinted += fprintf(fp, "%s%d", i ? ", " : "", thread_map__pid(threads, i));\r\nreturn printed + fprintf(fp, "\n");\r\n}\r\nstatic int get_comm(char **comm, pid_t pid)\r\n{\r\nchar *path;\r\nsize_t size;\r\nint err;\r\nif (asprintf(&path, "%s/%d/comm", procfs__mountpoint(), pid) == -1)\r\nreturn -ENOMEM;\r\nerr = filename__read_str(path, comm, &size);\r\nif (!err) {\r\n(*comm)[size] = 0;\r\nrtrim(*comm);\r\n}\r\nfree(path);\r\nreturn err;\r\n}\r\nstatic void comm_init(struct thread_map *map, int i)\r\n{\r\npid_t pid = thread_map__pid(map, i);\r\nchar *comm = NULL;\r\nif (pid == -1) {\r\nmap->map[i].comm = strdup("dummy");\r\nreturn;\r\n}\r\nif (get_comm(&comm, pid))\r\npr_warning("Couldn't resolve comm name for pid %d\n", pid);\r\nmap->map[i].comm = comm;\r\n}\r\nvoid thread_map__read_comms(struct thread_map *threads)\r\n{\r\nint i;\r\nfor (i = 0; i < threads->nr; ++i)\r\ncomm_init(threads, i);\r\n}
