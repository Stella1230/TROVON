static inline int value_index(__u32 value, __u32 *array, int size)\r\n{\r\nint i;\r\nfor (i=0; i < size; i++)\r\nif (array[i] == value)\r\nbreak;\r\nreturn i;\r\n}\r\nstatic inline __u32 index_value(int index, __u32 *array)\r\n{\r\nreturn array[index];\r\n}\r\nstatic int msb_index (__u16 word)\r\n{\r\n__u16 msb = 0x8000;\r\nint index = 15;\r\nif (word == 0) {\r\nnet_warn_ratelimited("%s(), Detected buggy peer, adjust null PV to 0x1!\n",\r\n__func__);\r\nword = 0x1;\r\n}\r\nwhile (msb) {\r\nif (word & msb)\r\nbreak;\r\nmsb >>=1;\r\nindex--;\r\n}\r\nreturn index;\r\n}\r\nstatic inline int value_lower_bits(__u32 value, __u32 *array, int size, __u16 *field)\r\n{\r\nint i;\r\n__u16 mask = 0x1;\r\n__u16 result = 0x0;\r\nfor (i=0; i < size; i++) {\r\nresult |= mask;\r\nmask <<= 1;\r\nif (array[i] >= value)\r\nbreak;\r\n}\r\nif(i >= size)\r\ni = size - 1;\r\n*field = result;\r\nreturn i;\r\n}\r\nstatic inline int value_highest_bit(__u32 value, __u32 *array, int size, __u16 *field)\r\n{\r\nint i;\r\n__u16 mask = 0x1;\r\n__u16 result = 0x0;\r\nfor (i=0; i < size; i++) {\r\nif (array[i] <= value)\r\nbreak;\r\nmask <<= 1;\r\n}\r\nresult |= mask;\r\nif(i >= size)\r\ni = size - 1;\r\n*field = result;\r\nreturn i;\r\n}\r\nvoid irda_qos_compute_intersection(struct qos_info *qos, struct qos_info *new)\r\n{\r\nIRDA_ASSERT(qos != NULL, return;);\r\nIRDA_ASSERT(new != NULL, return;);\r\nqos->baud_rate.bits &= new->baud_rate.bits;\r\nqos->window_size.bits &= new->window_size.bits;\r\nqos->min_turn_time.bits &= new->min_turn_time.bits;\r\nqos->max_turn_time.bits &= new->max_turn_time.bits;\r\nqos->data_size.bits &= new->data_size.bits;\r\nqos->link_disc_time.bits &= new->link_disc_time.bits;\r\nqos->additional_bofs.bits &= new->additional_bofs.bits;\r\nirda_qos_bits_to_value(qos);\r\n}\r\nvoid irda_init_max_qos_capabilies(struct qos_info *qos)\r\n{\r\nint i;\r\ni = value_lower_bits(sysctl_max_baud_rate, baud_rates, 10,\r\n&qos->baud_rate.bits);\r\nsysctl_max_baud_rate = index_value(i, baud_rates);\r\ni = value_lower_bits(sysctl_max_noreply_time, link_disc_times, 8,\r\n&qos->link_disc_time.bits);\r\nsysctl_max_noreply_time = index_value(i, link_disc_times);\r\nqos->baud_rate.bits &= 0x03ff;\r\nqos->window_size.bits = 0x7f;\r\nqos->min_turn_time.bits = 0xff;\r\nqos->max_turn_time.bits = 0x0f;\r\nqos->data_size.bits = 0x3f;\r\nqos->link_disc_time.bits &= 0xff;\r\nqos->additional_bofs.bits = 0xff;\r\n}\r\nstatic void irlap_adjust_qos_settings(struct qos_info *qos)\r\n{\r\n__u32 line_capacity;\r\nint index;\r\nif (sysctl_min_tx_turn_time > qos->min_turn_time.value) {\r\nint i;\r\nnet_warn_ratelimited("%s(), Detected buggy peer, adjust mtt to %dus!\n",\r\n__func__, sysctl_min_tx_turn_time);\r\ni = value_highest_bit(sysctl_min_tx_turn_time, min_turn_times,\r\n8, &qos->min_turn_time.bits);\r\nsysctl_min_tx_turn_time = index_value(i, min_turn_times);\r\nqos->min_turn_time.value = sysctl_min_tx_turn_time;\r\n}\r\nif ((qos->baud_rate.value < 115200) &&\r\n(qos->max_turn_time.value < 500))\r\n{\r\npr_debug("%s(), adjusting max turn time from %d to 500 ms\n",\r\n__func__, qos->max_turn_time.value);\r\nqos->max_turn_time.value = 500;\r\n}\r\nindex = value_index(qos->data_size.value, data_sizes, 6);\r\nline_capacity = irlap_max_line_capacity(qos->baud_rate.value,\r\nqos->max_turn_time.value);\r\n#ifdef CONFIG_IRDA_DYNAMIC_WINDOW\r\nwhile ((qos->data_size.value > line_capacity) && (index > 0)) {\r\nqos->data_size.value = data_sizes[index--];\r\npr_debug("%s(), reducing data size to %d\n",\r\n__func__, qos->data_size.value);\r\n}\r\n#else\r\nwhile (irlap_requested_line_capacity(qos) > line_capacity) {\r\nIRDA_ASSERT(index != 0, return;);\r\nif (qos->window_size.value > 1) {\r\nqos->window_size.value--;\r\npr_debug("%s(), reducing window size to %d\n",\r\n__func__, qos->window_size.value);\r\n} else if (index > 1) {\r\nqos->data_size.value = data_sizes[index--];\r\npr_debug("%s(), reducing data size to %d\n",\r\n__func__, qos->data_size.value);\r\n} else {\r\nnet_warn_ratelimited("%s(), nothing more we can do!\n",\r\n__func__);\r\n}\r\n}\r\n#endif\r\nif (qos->data_size.value > sysctl_max_tx_data_size)\r\nqos->data_size.value = sysctl_max_tx_data_size;\r\nif (qos->window_size.value > sysctl_max_tx_window)\r\nqos->window_size.value = sysctl_max_tx_window;\r\n}\r\nint irlap_qos_negotiate(struct irlap_cb *self, struct sk_buff *skb)\r\n{\r\nint ret;\r\nret = irda_param_extract_all(self, skb->data, skb->len,\r\n&irlap_param_info);\r\nirda_qos_bits_to_value(&self->qos_tx);\r\nirda_qos_bits_to_value(&self->qos_rx);\r\nirlap_adjust_qos_settings(&self->qos_tx);\r\npr_debug("Setting BAUD_RATE to %d bps.\n",\r\nself->qos_tx.baud_rate.value);\r\npr_debug("Setting DATA_SIZE to %d bytes\n",\r\nself->qos_tx.data_size.value);\r\npr_debug("Setting WINDOW_SIZE to %d\n",\r\nself->qos_tx.window_size.value);\r\npr_debug("Setting XBOFS to %d\n",\r\nself->qos_tx.additional_bofs.value);\r\npr_debug("Setting MAX_TURN_TIME to %d ms.\n",\r\nself->qos_tx.max_turn_time.value);\r\npr_debug("Setting MIN_TURN_TIME to %d usecs.\n",\r\nself->qos_tx.min_turn_time.value);\r\npr_debug("Setting LINK_DISC to %d secs.\n",\r\nself->qos_tx.link_disc_time.value);\r\nreturn ret;\r\n}\r\nint irlap_insert_qos_negotiation_params(struct irlap_cb *self,\r\nstruct sk_buff *skb)\r\n{\r\nint ret;\r\nret = irda_param_insert(self, PI_BAUD_RATE, skb_tail_pointer(skb),\r\nskb_tailroom(skb), &irlap_param_info);\r\nif (ret < 0)\r\nreturn ret;\r\nskb_put(skb, ret);\r\nret = irda_param_insert(self, PI_MAX_TURN_TIME, skb_tail_pointer(skb),\r\nskb_tailroom(skb), &irlap_param_info);\r\nif (ret < 0)\r\nreturn ret;\r\nskb_put(skb, ret);\r\nret = irda_param_insert(self, PI_DATA_SIZE, skb_tail_pointer(skb),\r\nskb_tailroom(skb), &irlap_param_info);\r\nif (ret < 0)\r\nreturn ret;\r\nskb_put(skb, ret);\r\nret = irda_param_insert(self, PI_WINDOW_SIZE, skb_tail_pointer(skb),\r\nskb_tailroom(skb), &irlap_param_info);\r\nif (ret < 0)\r\nreturn ret;\r\nskb_put(skb, ret);\r\nret = irda_param_insert(self, PI_ADD_BOFS, skb_tail_pointer(skb),\r\nskb_tailroom(skb), &irlap_param_info);\r\nif (ret < 0)\r\nreturn ret;\r\nskb_put(skb, ret);\r\nret = irda_param_insert(self, PI_MIN_TURN_TIME, skb_tail_pointer(skb),\r\nskb_tailroom(skb), &irlap_param_info);\r\nif (ret < 0)\r\nreturn ret;\r\nskb_put(skb, ret);\r\nret = irda_param_insert(self, PI_LINK_DISC, skb_tail_pointer(skb),\r\nskb_tailroom(skb), &irlap_param_info);\r\nif (ret < 0)\r\nreturn ret;\r\nskb_put(skb, ret);\r\nreturn 0;\r\n}\r\nstatic int irlap_param_baud_rate(void *instance, irda_param_t *param, int get)\r\n{\r\n__u16 final;\r\nstruct irlap_cb *self = (struct irlap_cb *) instance;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -1;);\r\nif (get) {\r\nparam->pv.i = self->qos_rx.baud_rate.bits;\r\npr_debug("%s(), baud rate = 0x%02x\n",\r\n__func__, param->pv.i);\r\n} else {\r\npr_debug("Requested BAUD_RATE: 0x%04x\n", (__u16)param->pv.i);\r\nfinal = (__u16) param->pv.i & self->qos_rx.baud_rate.bits;\r\npr_debug("Final BAUD_RATE: 0x%04x\n", final);\r\nself->qos_tx.baud_rate.bits = final;\r\nself->qos_rx.baud_rate.bits = final;\r\n}\r\nreturn 0;\r\n}\r\nstatic int irlap_param_link_disconnect(void *instance, irda_param_t *param,\r\nint get)\r\n{\r\n__u16 final;\r\nstruct irlap_cb *self = (struct irlap_cb *) instance;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -1;);\r\nif (get)\r\nparam->pv.i = self->qos_rx.link_disc_time.bits;\r\nelse {\r\npr_debug("LINK_DISC: %02x\n", (__u8)param->pv.i);\r\nfinal = (__u8) param->pv.i & self->qos_rx.link_disc_time.bits;\r\npr_debug("Final LINK_DISC: %02x\n", final);\r\nself->qos_tx.link_disc_time.bits = final;\r\nself->qos_rx.link_disc_time.bits = final;\r\n}\r\nreturn 0;\r\n}\r\nstatic int irlap_param_max_turn_time(void *instance, irda_param_t *param,\r\nint get)\r\n{\r\nstruct irlap_cb *self = (struct irlap_cb *) instance;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -1;);\r\nif (get)\r\nparam->pv.i = self->qos_rx.max_turn_time.bits;\r\nelse\r\nself->qos_tx.max_turn_time.bits = (__u8) param->pv.i;\r\nreturn 0;\r\n}\r\nstatic int irlap_param_data_size(void *instance, irda_param_t *param, int get)\r\n{\r\nstruct irlap_cb *self = (struct irlap_cb *) instance;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -1;);\r\nif (get)\r\nparam->pv.i = self->qos_rx.data_size.bits;\r\nelse\r\nself->qos_tx.data_size.bits = (__u8) param->pv.i;\r\nreturn 0;\r\n}\r\nstatic int irlap_param_window_size(void *instance, irda_param_t *param,\r\nint get)\r\n{\r\nstruct irlap_cb *self = (struct irlap_cb *) instance;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -1;);\r\nif (get)\r\nparam->pv.i = self->qos_rx.window_size.bits;\r\nelse\r\nself->qos_tx.window_size.bits = (__u8) param->pv.i;\r\nreturn 0;\r\n}\r\nstatic int irlap_param_additional_bofs(void *instance, irda_param_t *param, int get)\r\n{\r\nstruct irlap_cb *self = (struct irlap_cb *) instance;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -1;);\r\nif (get)\r\nparam->pv.i = self->qos_rx.additional_bofs.bits;\r\nelse\r\nself->qos_tx.additional_bofs.bits = (__u8) param->pv.i;\r\nreturn 0;\r\n}\r\nstatic int irlap_param_min_turn_time(void *instance, irda_param_t *param,\r\nint get)\r\n{\r\nstruct irlap_cb *self = (struct irlap_cb *) instance;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -1;);\r\nif (get)\r\nparam->pv.i = self->qos_rx.min_turn_time.bits;\r\nelse\r\nself->qos_tx.min_turn_time.bits = (__u8) param->pv.i;\r\nreturn 0;\r\n}\r\n__u32 irlap_max_line_capacity(__u32 speed, __u32 max_turn_time)\r\n{\r\n__u32 line_capacity;\r\nint i,j;\r\npr_debug("%s(), speed=%d, max_turn_time=%d\n",\r\n__func__, speed, max_turn_time);\r\ni = value_index(speed, baud_rates, 10);\r\nj = value_index(max_turn_time, max_turn_times, 4);\r\nIRDA_ASSERT(((i >=0) && (i <10)), return 0;);\r\nIRDA_ASSERT(((j >=0) && (j <4)), return 0;);\r\nline_capacity = max_line_capacities[i][j];\r\npr_debug("%s(), line capacity=%d bytes\n",\r\n__func__, line_capacity);\r\nreturn line_capacity;\r\n}\r\nstatic __u32 irlap_requested_line_capacity(struct qos_info *qos)\r\n{\r\n__u32 line_capacity;\r\nline_capacity = qos->window_size.value *\r\n(qos->data_size.value + 6 + qos->additional_bofs.value) +\r\nirlap_min_turn_time_in_bytes(qos->baud_rate.value,\r\nqos->min_turn_time.value);\r\npr_debug("%s(), requested line capacity=%d\n",\r\n__func__, line_capacity);\r\nreturn line_capacity;\r\n}\r\nvoid irda_qos_bits_to_value(struct qos_info *qos)\r\n{\r\nint index;\r\nIRDA_ASSERT(qos != NULL, return;);\r\nindex = msb_index(qos->baud_rate.bits);\r\nqos->baud_rate.value = baud_rates[index];\r\nindex = msb_index(qos->data_size.bits);\r\nqos->data_size.value = data_sizes[index];\r\nindex = msb_index(qos->window_size.bits);\r\nqos->window_size.value = index+1;\r\nindex = msb_index(qos->min_turn_time.bits);\r\nqos->min_turn_time.value = min_turn_times[index];\r\nindex = msb_index(qos->max_turn_time.bits);\r\nqos->max_turn_time.value = max_turn_times[index];\r\nindex = msb_index(qos->link_disc_time.bits);\r\nqos->link_disc_time.value = link_disc_times[index];\r\nindex = msb_index(qos->additional_bofs.bits);\r\nqos->additional_bofs.value = add_bofs[index];\r\n}
