static void pe_level_printk(const struct pnv_ioda_pe *pe, const char *level,\r\nconst char *fmt, ...)\r\n{\r\nstruct va_format vaf;\r\nva_list args;\r\nchar pfix[32];\r\nva_start(args, fmt);\r\nvaf.fmt = fmt;\r\nvaf.va = &args;\r\nif (pe->flags & PNV_IODA_PE_DEV)\r\nstrlcpy(pfix, dev_name(&pe->pdev->dev), sizeof(pfix));\r\nelse if (pe->flags & (PNV_IODA_PE_BUS | PNV_IODA_PE_BUS_ALL))\r\nsprintf(pfix, "%04x:%02x ",\r\npci_domain_nr(pe->pbus), pe->pbus->number);\r\n#ifdef CONFIG_PCI_IOV\r\nelse if (pe->flags & PNV_IODA_PE_VF)\r\nsprintf(pfix, "%04x:%02x:%2x.%d",\r\npci_domain_nr(pe->parent_dev->bus),\r\n(pe->rid & 0xff00) >> 8,\r\nPCI_SLOT(pe->rid), PCI_FUNC(pe->rid));\r\n#endif\r\nprintk("%spci %s: [PE# %.3d] %pV",\r\nlevel, pfix, pe->pe_number, &vaf);\r\nva_end(args);\r\n}\r\nstatic int __init iommu_setup(char *str)\r\n{\r\nif (!str)\r\nreturn -EINVAL;\r\nwhile (*str) {\r\nif (!strncmp(str, "nobypass", 8)) {\r\npnv_iommu_bypass_disabled = true;\r\npr_info("PowerNV: IOMMU bypass window disabled.\n");\r\nbreak;\r\n}\r\nstr += strcspn(str, ",");\r\nif (*str == ',')\r\nstr++;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void __raw_rm_writeq(u64 val, volatile void __iomem *paddr)\r\n{\r\n__asm__ __volatile__("stdcix %0,0,%1"\r\n: : "r" (val), "r" (paddr) : "memory");\r\n}\r\nstatic inline bool pnv_pci_is_mem_pref_64(unsigned long flags)\r\n{\r\nreturn ((flags & (IORESOURCE_MEM_64 | IORESOURCE_PREFETCH)) ==\r\n(IORESOURCE_MEM_64 | IORESOURCE_PREFETCH));\r\n}\r\nstatic void pnv_ioda_reserve_pe(struct pnv_phb *phb, int pe_no)\r\n{\r\nif (!(pe_no >= 0 && pe_no < phb->ioda.total_pe)) {\r\npr_warn("%s: Invalid PE %d on PHB#%x\n",\r\n__func__, pe_no, phb->hose->global_number);\r\nreturn;\r\n}\r\nif (test_and_set_bit(pe_no, phb->ioda.pe_alloc))\r\npr_debug("%s: PE %d was reserved on PHB#%x\n",\r\n__func__, pe_no, phb->hose->global_number);\r\nphb->ioda.pe_array[pe_no].phb = phb;\r\nphb->ioda.pe_array[pe_no].pe_number = pe_no;\r\n}\r\nstatic int pnv_ioda_alloc_pe(struct pnv_phb *phb)\r\n{\r\nunsigned long pe;\r\ndo {\r\npe = find_next_zero_bit(phb->ioda.pe_alloc,\r\nphb->ioda.total_pe, 0);\r\nif (pe >= phb->ioda.total_pe)\r\nreturn IODA_INVALID_PE;\r\n} while(test_and_set_bit(pe, phb->ioda.pe_alloc));\r\nphb->ioda.pe_array[pe].phb = phb;\r\nphb->ioda.pe_array[pe].pe_number = pe;\r\nreturn pe;\r\n}\r\nstatic void pnv_ioda_free_pe(struct pnv_phb *phb, int pe)\r\n{\r\nWARN_ON(phb->ioda.pe_array[pe].pdev);\r\nmemset(&phb->ioda.pe_array[pe], 0, sizeof(struct pnv_ioda_pe));\r\nclear_bit(pe, phb->ioda.pe_alloc);\r\n}\r\nstatic int pnv_ioda2_init_m64(struct pnv_phb *phb)\r\n{\r\nconst char *desc;\r\nstruct resource *r;\r\ns64 rc;\r\nrc = opal_pci_set_phb_mem_window(phb->opal_id,\r\nOPAL_M64_WINDOW_TYPE,\r\nphb->ioda.m64_bar_idx,\r\nphb->ioda.m64_base,\r\n0,\r\nphb->ioda.m64_size);\r\nif (rc != OPAL_SUCCESS) {\r\ndesc = "configuring";\r\ngoto fail;\r\n}\r\nrc = opal_pci_phb_mmio_enable(phb->opal_id,\r\nOPAL_M64_WINDOW_TYPE,\r\nphb->ioda.m64_bar_idx,\r\nOPAL_ENABLE_M64_SPLIT);\r\nif (rc != OPAL_SUCCESS) {\r\ndesc = "enabling";\r\ngoto fail;\r\n}\r\nset_bit(phb->ioda.m64_bar_idx, &phb->ioda.m64_bar_alloc);\r\nr = &phb->hose->mem_resources[1];\r\nif (phb->ioda.reserved_pe == 0)\r\nr->start += phb->ioda.m64_segsize;\r\nelse if (phb->ioda.reserved_pe == (phb->ioda.total_pe - 1))\r\nr->end -= phb->ioda.m64_segsize;\r\nelse\r\npr_warn(" Cannot strip M64 segment for reserved PE#%d\n",\r\nphb->ioda.reserved_pe);\r\nreturn 0;\r\nfail:\r\npr_warn(" Failure %lld %s M64 BAR#%d\n",\r\nrc, desc, phb->ioda.m64_bar_idx);\r\nopal_pci_phb_mmio_enable(phb->opal_id,\r\nOPAL_M64_WINDOW_TYPE,\r\nphb->ioda.m64_bar_idx,\r\nOPAL_DISABLE_M64);\r\nreturn -EIO;\r\n}\r\nstatic void pnv_ioda2_reserve_dev_m64_pe(struct pci_dev *pdev,\r\nunsigned long *pe_bitmap)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct resource *r;\r\nresource_size_t base, sgsz, start, end;\r\nint segno, i;\r\nbase = phb->ioda.m64_base;\r\nsgsz = phb->ioda.m64_segsize;\r\nfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\r\nr = &pdev->resource[i];\r\nif (!r->parent || !pnv_pci_is_mem_pref_64(r->flags))\r\ncontinue;\r\nstart = _ALIGN_DOWN(r->start - base, sgsz);\r\nend = _ALIGN_UP(r->end - base, sgsz);\r\nfor (segno = start / sgsz; segno < end / sgsz; segno++) {\r\nif (pe_bitmap)\r\nset_bit(segno, pe_bitmap);\r\nelse\r\npnv_ioda_reserve_pe(phb, segno);\r\n}\r\n}\r\n}\r\nstatic void pnv_ioda2_reserve_m64_pe(struct pci_bus *bus,\r\nunsigned long *pe_bitmap,\r\nbool all)\r\n{\r\nstruct pci_dev *pdev;\r\nlist_for_each_entry(pdev, &bus->devices, bus_list) {\r\npnv_ioda2_reserve_dev_m64_pe(pdev, pe_bitmap);\r\nif (all && pdev->subordinate)\r\npnv_ioda2_reserve_m64_pe(pdev->subordinate,\r\npe_bitmap, all);\r\n}\r\n}\r\nstatic int pnv_ioda2_pick_m64_pe(struct pci_bus *bus, bool all)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct pnv_ioda_pe *master_pe, *pe;\r\nunsigned long size, *pe_alloc;\r\nint i;\r\nif (pci_is_root_bus(bus))\r\nreturn IODA_INVALID_PE;\r\nsize = _ALIGN_UP(phb->ioda.total_pe / 8, sizeof(unsigned long));\r\npe_alloc = kzalloc(size, GFP_KERNEL);\r\nif (!pe_alloc) {\r\npr_warn("%s: Out of memory !\n",\r\n__func__);\r\nreturn IODA_INVALID_PE;\r\n}\r\npnv_ioda2_reserve_m64_pe(bus, pe_alloc, all);\r\nif (bitmap_empty(pe_alloc, phb->ioda.total_pe)) {\r\nkfree(pe_alloc);\r\nreturn IODA_INVALID_PE;\r\n}\r\nmaster_pe = NULL;\r\ni = -1;\r\nwhile ((i = find_next_bit(pe_alloc, phb->ioda.total_pe, i + 1)) <\r\nphb->ioda.total_pe) {\r\npe = &phb->ioda.pe_array[i];\r\nif (!master_pe) {\r\npe->flags |= PNV_IODA_PE_MASTER;\r\nINIT_LIST_HEAD(&pe->slaves);\r\nmaster_pe = pe;\r\n} else {\r\npe->flags |= PNV_IODA_PE_SLAVE;\r\npe->master = master_pe;\r\nlist_add_tail(&pe->list, &master_pe->slaves);\r\n}\r\n}\r\nkfree(pe_alloc);\r\nreturn master_pe->pe_number;\r\n}\r\nstatic void __init pnv_ioda_parse_m64_window(struct pnv_phb *phb)\r\n{\r\nstruct pci_controller *hose = phb->hose;\r\nstruct device_node *dn = hose->dn;\r\nstruct resource *res;\r\nconst u32 *r;\r\nu64 pci_addr;\r\nif (phb->type != PNV_PHB_IODA2) {\r\npr_info(" Not support M64 window\n");\r\nreturn;\r\n}\r\nif (!firmware_has_feature(FW_FEATURE_OPALv3)) {\r\npr_info(" Firmware too old to support M64 window\n");\r\nreturn;\r\n}\r\nr = of_get_property(dn, "ibm,opal-m64-window", NULL);\r\nif (!r) {\r\npr_info(" No <ibm,opal-m64-window> on %s\n",\r\ndn->full_name);\r\nreturn;\r\n}\r\nres = &hose->mem_resources[1];\r\nres->start = of_translate_address(dn, r + 2);\r\nres->end = res->start + of_read_number(r + 4, 2) - 1;\r\nres->flags = (IORESOURCE_MEM | IORESOURCE_MEM_64 | IORESOURCE_PREFETCH);\r\npci_addr = of_read_number(r, 2);\r\nhose->mem_offset[1] = res->start - pci_addr;\r\nphb->ioda.m64_size = resource_size(res);\r\nphb->ioda.m64_segsize = phb->ioda.m64_size / phb->ioda.total_pe;\r\nphb->ioda.m64_base = pci_addr;\r\npr_info(" MEM64 0x%016llx..0x%016llx -> 0x%016llx\n",\r\nres->start, res->end, pci_addr);\r\nphb->ioda.m64_bar_idx = 15;\r\nphb->init_m64 = pnv_ioda2_init_m64;\r\nphb->reserve_m64_pe = pnv_ioda2_reserve_m64_pe;\r\nphb->pick_m64_pe = pnv_ioda2_pick_m64_pe;\r\n}\r\nstatic void pnv_ioda_freeze_pe(struct pnv_phb *phb, int pe_no)\r\n{\r\nstruct pnv_ioda_pe *pe = &phb->ioda.pe_array[pe_no];\r\nstruct pnv_ioda_pe *slave;\r\ns64 rc;\r\nif (pe->flags & PNV_IODA_PE_SLAVE) {\r\npe = pe->master;\r\nif (WARN_ON(!pe || !(pe->flags & PNV_IODA_PE_MASTER)))\r\nreturn;\r\npe_no = pe->pe_number;\r\n}\r\nrc = opal_pci_eeh_freeze_set(phb->opal_id,\r\npe_no,\r\nOPAL_EEH_ACTION_SET_FREEZE_ALL);\r\nif (rc != OPAL_SUCCESS) {\r\npr_warn("%s: Failure %lld freezing PHB#%x-PE#%x\n",\r\n__func__, rc, phb->hose->global_number, pe_no);\r\nreturn;\r\n}\r\nif (!(pe->flags & PNV_IODA_PE_MASTER))\r\nreturn;\r\nlist_for_each_entry(slave, &pe->slaves, list) {\r\nrc = opal_pci_eeh_freeze_set(phb->opal_id,\r\nslave->pe_number,\r\nOPAL_EEH_ACTION_SET_FREEZE_ALL);\r\nif (rc != OPAL_SUCCESS)\r\npr_warn("%s: Failure %lld freezing PHB#%x-PE#%x\n",\r\n__func__, rc, phb->hose->global_number,\r\nslave->pe_number);\r\n}\r\n}\r\nstatic int pnv_ioda_unfreeze_pe(struct pnv_phb *phb, int pe_no, int opt)\r\n{\r\nstruct pnv_ioda_pe *pe, *slave;\r\ns64 rc;\r\npe = &phb->ioda.pe_array[pe_no];\r\nif (pe->flags & PNV_IODA_PE_SLAVE) {\r\npe = pe->master;\r\nWARN_ON(!pe || !(pe->flags & PNV_IODA_PE_MASTER));\r\npe_no = pe->pe_number;\r\n}\r\nrc = opal_pci_eeh_freeze_clear(phb->opal_id, pe_no, opt);\r\nif (rc != OPAL_SUCCESS) {\r\npr_warn("%s: Failure %lld clear %d on PHB#%x-PE#%x\n",\r\n__func__, rc, opt, phb->hose->global_number, pe_no);\r\nreturn -EIO;\r\n}\r\nif (!(pe->flags & PNV_IODA_PE_MASTER))\r\nreturn 0;\r\nlist_for_each_entry(slave, &pe->slaves, list) {\r\nrc = opal_pci_eeh_freeze_clear(phb->opal_id,\r\nslave->pe_number,\r\nopt);\r\nif (rc != OPAL_SUCCESS) {\r\npr_warn("%s: Failure %lld clear %d on PHB#%x-PE#%x\n",\r\n__func__, rc, opt, phb->hose->global_number,\r\nslave->pe_number);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pnv_ioda_get_pe_state(struct pnv_phb *phb, int pe_no)\r\n{\r\nstruct pnv_ioda_pe *slave, *pe;\r\nu8 fstate, state;\r\n__be16 pcierr;\r\ns64 rc;\r\nif (pe_no < 0 || pe_no >= phb->ioda.total_pe)\r\nreturn OPAL_EEH_STOPPED_PERM_UNAVAIL;\r\npe = &phb->ioda.pe_array[pe_no];\r\nif (pe->flags & PNV_IODA_PE_SLAVE) {\r\npe = pe->master;\r\nWARN_ON(!pe || !(pe->flags & PNV_IODA_PE_MASTER));\r\npe_no = pe->pe_number;\r\n}\r\nrc = opal_pci_eeh_freeze_status(phb->opal_id, pe_no,\r\n&state, &pcierr, NULL);\r\nif (rc != OPAL_SUCCESS) {\r\npr_warn("%s: Failure %lld getting "\r\n"PHB#%x-PE#%x state\n",\r\n__func__, rc,\r\nphb->hose->global_number, pe_no);\r\nreturn OPAL_EEH_STOPPED_TEMP_UNAVAIL;\r\n}\r\nif (!(pe->flags & PNV_IODA_PE_MASTER))\r\nreturn state;\r\nlist_for_each_entry(slave, &pe->slaves, list) {\r\nrc = opal_pci_eeh_freeze_status(phb->opal_id,\r\nslave->pe_number,\r\n&fstate,\r\n&pcierr,\r\nNULL);\r\nif (rc != OPAL_SUCCESS) {\r\npr_warn("%s: Failure %lld getting "\r\n"PHB#%x-PE#%x state\n",\r\n__func__, rc,\r\nphb->hose->global_number, slave->pe_number);\r\nreturn OPAL_EEH_STOPPED_TEMP_UNAVAIL;\r\n}\r\nif (fstate > state)\r\nstate = fstate;\r\n}\r\nreturn state;\r\n}\r\nstatic struct pnv_ioda_pe *pnv_ioda_get_pe(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct pci_dn *pdn = pci_get_pdn(dev);\r\nif (!pdn)\r\nreturn NULL;\r\nif (pdn->pe_number == IODA_INVALID_PE)\r\nreturn NULL;\r\nreturn &phb->ioda.pe_array[pdn->pe_number];\r\n}\r\nstatic int pnv_ioda_set_one_peltv(struct pnv_phb *phb,\r\nstruct pnv_ioda_pe *parent,\r\nstruct pnv_ioda_pe *child,\r\nbool is_add)\r\n{\r\nconst char *desc = is_add ? "adding" : "removing";\r\nuint8_t op = is_add ? OPAL_ADD_PE_TO_DOMAIN :\r\nOPAL_REMOVE_PE_FROM_DOMAIN;\r\nstruct pnv_ioda_pe *slave;\r\nlong rc;\r\nrc = opal_pci_set_peltv(phb->opal_id, parent->pe_number,\r\nchild->pe_number, op);\r\nif (rc != OPAL_SUCCESS) {\r\npe_warn(child, "OPAL error %ld %s to parent PELTV\n",\r\nrc, desc);\r\nreturn -ENXIO;\r\n}\r\nif (!(child->flags & PNV_IODA_PE_MASTER))\r\nreturn 0;\r\nlist_for_each_entry(slave, &child->slaves, list) {\r\nrc = opal_pci_set_peltv(phb->opal_id, parent->pe_number,\r\nslave->pe_number, op);\r\nif (rc != OPAL_SUCCESS) {\r\npe_warn(slave, "OPAL error %ld %s to parent PELTV\n",\r\nrc, desc);\r\nreturn -ENXIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pnv_ioda_set_peltv(struct pnv_phb *phb,\r\nstruct pnv_ioda_pe *pe,\r\nbool is_add)\r\n{\r\nstruct pnv_ioda_pe *slave;\r\nstruct pci_dev *pdev = NULL;\r\nint ret;\r\nif (is_add) {\r\nopal_pci_eeh_freeze_clear(phb->opal_id, pe->pe_number,\r\nOPAL_EEH_ACTION_CLEAR_FREEZE_ALL);\r\nif (pe->flags & PNV_IODA_PE_MASTER) {\r\nlist_for_each_entry(slave, &pe->slaves, list)\r\nopal_pci_eeh_freeze_clear(phb->opal_id,\r\nslave->pe_number,\r\nOPAL_EEH_ACTION_CLEAR_FREEZE_ALL);\r\n}\r\n}\r\nret = pnv_ioda_set_one_peltv(phb, pe, pe, is_add);\r\nif (ret)\r\nreturn ret;\r\nif (pe->flags & PNV_IODA_PE_MASTER) {\r\nlist_for_each_entry(slave, &pe->slaves, list) {\r\nret = pnv_ioda_set_one_peltv(phb, slave, pe, is_add);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nif (pe->flags & (PNV_IODA_PE_BUS_ALL | PNV_IODA_PE_BUS))\r\npdev = pe->pbus->self;\r\nelse if (pe->flags & PNV_IODA_PE_DEV)\r\npdev = pe->pdev->bus->self;\r\n#ifdef CONFIG_PCI_IOV\r\nelse if (pe->flags & PNV_IODA_PE_VF)\r\npdev = pe->parent_dev;\r\n#endif\r\nwhile (pdev) {\r\nstruct pci_dn *pdn = pci_get_pdn(pdev);\r\nstruct pnv_ioda_pe *parent;\r\nif (pdn && pdn->pe_number != IODA_INVALID_PE) {\r\nparent = &phb->ioda.pe_array[pdn->pe_number];\r\nret = pnv_ioda_set_one_peltv(phb, parent, pe, is_add);\r\nif (ret)\r\nreturn ret;\r\n}\r\npdev = pdev->bus->self;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pnv_ioda_deconfigure_pe(struct pnv_phb *phb, struct pnv_ioda_pe *pe)\r\n{\r\nstruct pci_dev *parent;\r\nuint8_t bcomp, dcomp, fcomp;\r\nint64_t rc;\r\nlong rid_end, rid;\r\nif (pe->pbus) {\r\nint count;\r\ndcomp = OPAL_IGNORE_RID_DEVICE_NUMBER;\r\nfcomp = OPAL_IGNORE_RID_FUNCTION_NUMBER;\r\nparent = pe->pbus->self;\r\nif (pe->flags & PNV_IODA_PE_BUS_ALL)\r\ncount = pe->pbus->busn_res.end - pe->pbus->busn_res.start + 1;\r\nelse\r\ncount = 1;\r\nswitch(count) {\r\ncase 1: bcomp = OpalPciBusAll; break;\r\ncase 2: bcomp = OpalPciBus7Bits; break;\r\ncase 4: bcomp = OpalPciBus6Bits; break;\r\ncase 8: bcomp = OpalPciBus5Bits; break;\r\ncase 16: bcomp = OpalPciBus4Bits; break;\r\ncase 32: bcomp = OpalPciBus3Bits; break;\r\ndefault:\r\ndev_err(&pe->pbus->dev, "Number of subordinate buses %d unsupported\n",\r\ncount);\r\nbcomp = OpalPciBusAll;\r\n}\r\nrid_end = pe->rid + (count << 8);\r\n} else {\r\nif (pe->flags & PNV_IODA_PE_VF)\r\nparent = pe->parent_dev;\r\nelse\r\nparent = pe->pdev->bus->self;\r\nbcomp = OpalPciBusAll;\r\ndcomp = OPAL_COMPARE_RID_DEVICE_NUMBER;\r\nfcomp = OPAL_COMPARE_RID_FUNCTION_NUMBER;\r\nrid_end = pe->rid + 1;\r\n}\r\nfor (rid = pe->rid; rid < rid_end; rid++)\r\nphb->ioda.pe_rmap[rid] = 0;\r\nwhile (parent) {\r\nstruct pci_dn *pdn = pci_get_pdn(parent);\r\nif (pdn && pdn->pe_number != IODA_INVALID_PE) {\r\nrc = opal_pci_set_peltv(phb->opal_id, pdn->pe_number,\r\npe->pe_number, OPAL_REMOVE_PE_FROM_DOMAIN);\r\n}\r\nparent = parent->bus->self;\r\n}\r\nopal_pci_eeh_freeze_clear(phb->opal_id, pe->pe_number,\r\nOPAL_EEH_ACTION_CLEAR_FREEZE_ALL);\r\nrc = opal_pci_set_peltv(phb->opal_id, pe->pe_number,\r\npe->pe_number, OPAL_REMOVE_PE_FROM_DOMAIN);\r\nif (rc)\r\npe_warn(pe, "OPAL error %ld remove self from PELTV\n", rc);\r\nrc = opal_pci_set_pe(phb->opal_id, pe->pe_number, pe->rid,\r\nbcomp, dcomp, fcomp, OPAL_UNMAP_PE);\r\nif (rc)\r\npe_err(pe, "OPAL error %ld trying to setup PELT table\n", rc);\r\npe->pbus = NULL;\r\npe->pdev = NULL;\r\npe->parent_dev = NULL;\r\nreturn 0;\r\n}\r\nstatic int pnv_ioda_configure_pe(struct pnv_phb *phb, struct pnv_ioda_pe *pe)\r\n{\r\nstruct pci_dev *parent;\r\nuint8_t bcomp, dcomp, fcomp;\r\nlong rc, rid_end, rid;\r\nif (pe->pbus) {\r\nint count;\r\ndcomp = OPAL_IGNORE_RID_DEVICE_NUMBER;\r\nfcomp = OPAL_IGNORE_RID_FUNCTION_NUMBER;\r\nparent = pe->pbus->self;\r\nif (pe->flags & PNV_IODA_PE_BUS_ALL)\r\ncount = pe->pbus->busn_res.end - pe->pbus->busn_res.start + 1;\r\nelse\r\ncount = 1;\r\nswitch(count) {\r\ncase 1: bcomp = OpalPciBusAll; break;\r\ncase 2: bcomp = OpalPciBus7Bits; break;\r\ncase 4: bcomp = OpalPciBus6Bits; break;\r\ncase 8: bcomp = OpalPciBus5Bits; break;\r\ncase 16: bcomp = OpalPciBus4Bits; break;\r\ncase 32: bcomp = OpalPciBus3Bits; break;\r\ndefault:\r\ndev_err(&pe->pbus->dev, "Number of subordinate buses %d unsupported\n",\r\ncount);\r\nbcomp = OpalPciBusAll;\r\n}\r\nrid_end = pe->rid + (count << 8);\r\n} else {\r\n#ifdef CONFIG_PCI_IOV\r\nif (pe->flags & PNV_IODA_PE_VF)\r\nparent = pe->parent_dev;\r\nelse\r\n#endif\r\nparent = pe->pdev->bus->self;\r\nbcomp = OpalPciBusAll;\r\ndcomp = OPAL_COMPARE_RID_DEVICE_NUMBER;\r\nfcomp = OPAL_COMPARE_RID_FUNCTION_NUMBER;\r\nrid_end = pe->rid + 1;\r\n}\r\nrc = opal_pci_set_pe(phb->opal_id, pe->pe_number, pe->rid,\r\nbcomp, dcomp, fcomp, OPAL_MAP_PE);\r\nif (rc) {\r\npe_err(pe, "OPAL error %ld trying to setup PELT table\n", rc);\r\nreturn -ENXIO;\r\n}\r\npnv_ioda_set_peltv(phb, pe, true);\r\nfor (rid = pe->rid; rid < rid_end; rid++)\r\nphb->ioda.pe_rmap[rid] = pe->pe_number;\r\nif (phb->type != PNV_PHB_IODA1) {\r\npe->mve_number = 0;\r\ngoto out;\r\n}\r\npe->mve_number = pe->pe_number;\r\nrc = opal_pci_set_mve(phb->opal_id, pe->mve_number, pe->pe_number);\r\nif (rc != OPAL_SUCCESS) {\r\npe_err(pe, "OPAL error %ld setting up MVE %d\n",\r\nrc, pe->mve_number);\r\npe->mve_number = -1;\r\n} else {\r\nrc = opal_pci_set_mve_enable(phb->opal_id,\r\npe->mve_number, OPAL_ENABLE_MVE);\r\nif (rc) {\r\npe_err(pe, "OPAL error %ld enabling MVE %d\n",\r\nrc, pe->mve_number);\r\npe->mve_number = -1;\r\n}\r\n}\r\nout:\r\nreturn 0;\r\n}\r\nstatic void pnv_ioda_link_pe_by_weight(struct pnv_phb *phb,\r\nstruct pnv_ioda_pe *pe)\r\n{\r\nstruct pnv_ioda_pe *lpe;\r\nlist_for_each_entry(lpe, &phb->ioda.pe_dma_list, dma_link) {\r\nif (lpe->dma_weight < pe->dma_weight) {\r\nlist_add_tail(&pe->dma_link, &lpe->dma_link);\r\nreturn;\r\n}\r\n}\r\nlist_add_tail(&pe->dma_link, &phb->ioda.pe_dma_list);\r\n}\r\nstatic unsigned int pnv_ioda_dma_weight(struct pci_dev *dev)\r\n{\r\nif (dev->hdr_type != PCI_HEADER_TYPE_NORMAL)\r\nreturn 0;\r\nif (dev->class == PCI_CLASS_SERIAL_USB_UHCI ||\r\ndev->class == PCI_CLASS_SERIAL_USB_OHCI ||\r\ndev->class == PCI_CLASS_SERIAL_USB_EHCI)\r\nreturn 3;\r\nif ((dev->class >> 8) == PCI_CLASS_STORAGE_RAID)\r\nreturn 15;\r\nreturn 10;\r\n}\r\nstatic int pnv_pci_vf_resource_shift(struct pci_dev *dev, int offset)\r\n{\r\nstruct pci_dn *pdn = pci_get_pdn(dev);\r\nint i;\r\nstruct resource *res, res2;\r\nresource_size_t size;\r\nu16 num_vfs;\r\nif (!dev->is_physfn)\r\nreturn -EINVAL;\r\nnum_vfs = pdn->num_vfs;\r\nfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {\r\nres = &dev->resource[i + PCI_IOV_RESOURCES];\r\nif (!res->flags || !res->parent)\r\ncontinue;\r\nif (!pnv_pci_is_mem_pref_64(res->flags))\r\ncontinue;\r\nsize = pci_iov_resource_size(dev, i + PCI_IOV_RESOURCES);\r\nres2.flags = res->flags;\r\nres2.start = res->start + (size * offset);\r\nres2.end = res2.start + (size * num_vfs) - 1;\r\nif (res2.end > res->end) {\r\ndev_err(&dev->dev, "VF BAR%d: %pR would extend past %pR (trying to enable %d VFs shifted by %d)\n",\r\ni, &res2, res, num_vfs, offset);\r\nreturn -EBUSY;\r\n}\r\n}\r\nfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {\r\nres = &dev->resource[i + PCI_IOV_RESOURCES];\r\nif (!res->flags || !res->parent)\r\ncontinue;\r\nif (!pnv_pci_is_mem_pref_64(res->flags))\r\ncontinue;\r\nsize = pci_iov_resource_size(dev, i + PCI_IOV_RESOURCES);\r\nres2 = *res;\r\nres->start += size * offset;\r\ndev_info(&dev->dev, "VF BAR%d: %pR shifted to %pR (%sabling %d VFs shifted by %d)\n",\r\ni, &res2, res, (offset > 0) ? "En" : "Dis",\r\nnum_vfs, offset);\r\npci_update_resource(dev, i + PCI_IOV_RESOURCES);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pnv_ioda_setup_same_PE(struct pci_bus *bus, struct pnv_ioda_pe *pe)\r\n{\r\nstruct pci_dev *dev;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nstruct pci_dn *pdn = pci_get_pdn(dev);\r\nif (pdn == NULL) {\r\npr_warn("%s: No device node associated with device !\n",\r\npci_name(dev));\r\ncontinue;\r\n}\r\npdn->pe_number = pe->pe_number;\r\npe->dma_weight += pnv_ioda_dma_weight(dev);\r\nif ((pe->flags & PNV_IODA_PE_BUS_ALL) && dev->subordinate)\r\npnv_ioda_setup_same_PE(dev->subordinate, pe);\r\n}\r\n}\r\nstatic void pnv_ioda_setup_bus_PE(struct pci_bus *bus, bool all)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct pnv_ioda_pe *pe;\r\nint pe_num = IODA_INVALID_PE;\r\nif (phb->pick_m64_pe)\r\npe_num = phb->pick_m64_pe(bus, all);\r\nif (pe_num == IODA_INVALID_PE)\r\npe_num = pnv_ioda_alloc_pe(phb);\r\nif (pe_num == IODA_INVALID_PE) {\r\npr_warning("%s: Not enough PE# available for PCI bus %04x:%02x\n",\r\n__func__, pci_domain_nr(bus), bus->number);\r\nreturn;\r\n}\r\npe = &phb->ioda.pe_array[pe_num];\r\npe->flags |= (all ? PNV_IODA_PE_BUS_ALL : PNV_IODA_PE_BUS);\r\npe->pbus = bus;\r\npe->pdev = NULL;\r\npe->tce32_seg = -1;\r\npe->mve_number = -1;\r\npe->rid = bus->busn_res.start << 8;\r\npe->dma_weight = 0;\r\nif (all)\r\npe_info(pe, "Secondary bus %d..%d associated with PE#%d\n",\r\nbus->busn_res.start, bus->busn_res.end, pe_num);\r\nelse\r\npe_info(pe, "Secondary bus %d associated with PE#%d\n",\r\nbus->busn_res.start, pe_num);\r\nif (pnv_ioda_configure_pe(phb, pe)) {\r\nif (pe_num)\r\npnv_ioda_free_pe(phb, pe_num);\r\npe->pbus = NULL;\r\nreturn;\r\n}\r\npnv_ioda_setup_same_PE(bus, pe);\r\nlist_add_tail(&pe->list, &phb->ioda.pe_list);\r\nif (pe->dma_weight != 0) {\r\nphb->ioda.dma_weight += pe->dma_weight;\r\nphb->ioda.dma_pe_count++;\r\n}\r\npnv_ioda_link_pe_by_weight(phb, pe);\r\n}\r\nstatic void pnv_ioda_setup_PEs(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\npnv_ioda_setup_bus_PE(bus, false);\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nif (dev->subordinate) {\r\nif (pci_pcie_type(dev) == PCI_EXP_TYPE_PCI_BRIDGE)\r\npnv_ioda_setup_bus_PE(dev->subordinate, true);\r\nelse\r\npnv_ioda_setup_PEs(dev->subordinate);\r\n}\r\n}\r\n}\r\nstatic void pnv_pci_ioda_setup_PEs(void)\r\n{\r\nstruct pci_controller *hose, *tmp;\r\nstruct pnv_phb *phb;\r\nlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\r\nphb = hose->private_data;\r\nif (phb->reserve_m64_pe)\r\nphb->reserve_m64_pe(hose->bus, NULL, true);\r\npnv_ioda_setup_PEs(hose->bus);\r\n}\r\n}\r\nstatic int pnv_pci_vf_release_m64(struct pci_dev *pdev)\r\n{\r\nstruct pci_bus *bus;\r\nstruct pci_controller *hose;\r\nstruct pnv_phb *phb;\r\nstruct pci_dn *pdn;\r\nint i, j;\r\nbus = pdev->bus;\r\nhose = pci_bus_to_host(bus);\r\nphb = hose->private_data;\r\npdn = pci_get_pdn(pdev);\r\nfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++)\r\nfor (j = 0; j < M64_PER_IOV; j++) {\r\nif (pdn->m64_wins[i][j] == IODA_INVALID_M64)\r\ncontinue;\r\nopal_pci_phb_mmio_enable(phb->opal_id,\r\nOPAL_M64_WINDOW_TYPE, pdn->m64_wins[i][j], 0);\r\nclear_bit(pdn->m64_wins[i][j], &phb->ioda.m64_bar_alloc);\r\npdn->m64_wins[i][j] = IODA_INVALID_M64;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pnv_pci_vf_assign_m64(struct pci_dev *pdev, u16 num_vfs)\r\n{\r\nstruct pci_bus *bus;\r\nstruct pci_controller *hose;\r\nstruct pnv_phb *phb;\r\nstruct pci_dn *pdn;\r\nunsigned int win;\r\nstruct resource *res;\r\nint i, j;\r\nint64_t rc;\r\nint total_vfs;\r\nresource_size_t size, start;\r\nint pe_num;\r\nint vf_groups;\r\nint vf_per_group;\r\nbus = pdev->bus;\r\nhose = pci_bus_to_host(bus);\r\nphb = hose->private_data;\r\npdn = pci_get_pdn(pdev);\r\ntotal_vfs = pci_sriov_get_totalvfs(pdev);\r\nfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++)\r\nfor (j = 0; j < M64_PER_IOV; j++)\r\npdn->m64_wins[i][j] = IODA_INVALID_M64;\r\nif (pdn->m64_per_iov == M64_PER_IOV) {\r\nvf_groups = (num_vfs <= M64_PER_IOV) ? num_vfs: M64_PER_IOV;\r\nvf_per_group = (num_vfs <= M64_PER_IOV)? 1:\r\nroundup_pow_of_two(num_vfs) / pdn->m64_per_iov;\r\n} else {\r\nvf_groups = 1;\r\nvf_per_group = 1;\r\n}\r\nfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {\r\nres = &pdev->resource[i + PCI_IOV_RESOURCES];\r\nif (!res->flags || !res->parent)\r\ncontinue;\r\nif (!pnv_pci_is_mem_pref_64(res->flags))\r\ncontinue;\r\nfor (j = 0; j < vf_groups; j++) {\r\ndo {\r\nwin = find_next_zero_bit(&phb->ioda.m64_bar_alloc,\r\nphb->ioda.m64_bar_idx + 1, 0);\r\nif (win >= phb->ioda.m64_bar_idx + 1)\r\ngoto m64_failed;\r\n} while (test_and_set_bit(win, &phb->ioda.m64_bar_alloc));\r\npdn->m64_wins[i][j] = win;\r\nif (pdn->m64_per_iov == M64_PER_IOV) {\r\nsize = pci_iov_resource_size(pdev,\r\nPCI_IOV_RESOURCES + i);\r\nsize = size * vf_per_group;\r\nstart = res->start + size * j;\r\n} else {\r\nsize = resource_size(res);\r\nstart = res->start;\r\n}\r\nif (pdn->m64_per_iov == M64_PER_IOV) {\r\npe_num = pdn->offset + j;\r\nrc = opal_pci_map_pe_mmio_window(phb->opal_id,\r\npe_num, OPAL_M64_WINDOW_TYPE,\r\npdn->m64_wins[i][j], 0);\r\n}\r\nrc = opal_pci_set_phb_mem_window(phb->opal_id,\r\nOPAL_M64_WINDOW_TYPE,\r\npdn->m64_wins[i][j],\r\nstart,\r\n0,\r\nsize);\r\nif (rc != OPAL_SUCCESS) {\r\ndev_err(&pdev->dev, "Failed to map M64 window #%d: %lld\n",\r\nwin, rc);\r\ngoto m64_failed;\r\n}\r\nif (pdn->m64_per_iov == M64_PER_IOV)\r\nrc = opal_pci_phb_mmio_enable(phb->opal_id,\r\nOPAL_M64_WINDOW_TYPE, pdn->m64_wins[i][j], 2);\r\nelse\r\nrc = opal_pci_phb_mmio_enable(phb->opal_id,\r\nOPAL_M64_WINDOW_TYPE, pdn->m64_wins[i][j], 1);\r\nif (rc != OPAL_SUCCESS) {\r\ndev_err(&pdev->dev, "Failed to enable M64 window #%d: %llx\n",\r\nwin, rc);\r\ngoto m64_failed;\r\n}\r\n}\r\n}\r\nreturn 0;\r\nm64_failed:\r\npnv_pci_vf_release_m64(pdev);\r\nreturn -EBUSY;\r\n}\r\nstatic void pnv_pci_ioda2_release_dma_pe(struct pci_dev *dev, struct pnv_ioda_pe *pe)\r\n{\r\nstruct iommu_table *tbl;\r\nint64_t rc;\r\ntbl = pe->table_group.tables[0];\r\nrc = pnv_pci_ioda2_unset_window(&pe->table_group, 0);\r\nif (rc)\r\npe_warn(pe, "OPAL error %ld release DMA window\n", rc);\r\npnv_pci_ioda2_set_bypass(pe, false);\r\nif (pe->table_group.group) {\r\niommu_group_put(pe->table_group.group);\r\nBUG_ON(pe->table_group.group);\r\n}\r\npnv_pci_ioda2_table_free_pages(tbl);\r\niommu_free_table(tbl, of_node_full_name(dev->dev.of_node));\r\n}\r\nstatic void pnv_ioda_release_vf_PE(struct pci_dev *pdev, u16 num_vfs)\r\n{\r\nstruct pci_bus *bus;\r\nstruct pci_controller *hose;\r\nstruct pnv_phb *phb;\r\nstruct pnv_ioda_pe *pe, *pe_n;\r\nstruct pci_dn *pdn;\r\nu16 vf_index;\r\nint64_t rc;\r\nbus = pdev->bus;\r\nhose = pci_bus_to_host(bus);\r\nphb = hose->private_data;\r\npdn = pci_get_pdn(pdev);\r\nif (!pdev->is_physfn)\r\nreturn;\r\nif (pdn->m64_per_iov == M64_PER_IOV && num_vfs > M64_PER_IOV) {\r\nint vf_group;\r\nint vf_per_group;\r\nint vf_index1;\r\nvf_per_group = roundup_pow_of_two(num_vfs) / pdn->m64_per_iov;\r\nfor (vf_group = 0; vf_group < M64_PER_IOV; vf_group++)\r\nfor (vf_index = vf_group * vf_per_group;\r\nvf_index < (vf_group + 1) * vf_per_group &&\r\nvf_index < num_vfs;\r\nvf_index++)\r\nfor (vf_index1 = vf_group * vf_per_group;\r\nvf_index1 < (vf_group + 1) * vf_per_group &&\r\nvf_index1 < num_vfs;\r\nvf_index1++){\r\nrc = opal_pci_set_peltv(phb->opal_id,\r\npdn->offset + vf_index,\r\npdn->offset + vf_index1,\r\nOPAL_REMOVE_PE_FROM_DOMAIN);\r\nif (rc)\r\ndev_warn(&pdev->dev, "%s: Failed to unlink same group PE#%d(%lld)\n",\r\n__func__,\r\npdn->offset + vf_index1, rc);\r\n}\r\n}\r\nlist_for_each_entry_safe(pe, pe_n, &phb->ioda.pe_list, list) {\r\nif (pe->parent_dev != pdev)\r\ncontinue;\r\npnv_pci_ioda2_release_dma_pe(pdev, pe);\r\nmutex_lock(&phb->ioda.pe_list_mutex);\r\nlist_del(&pe->list);\r\nmutex_unlock(&phb->ioda.pe_list_mutex);\r\npnv_ioda_deconfigure_pe(phb, pe);\r\npnv_ioda_free_pe(phb, pe->pe_number);\r\n}\r\n}\r\nvoid pnv_pci_sriov_disable(struct pci_dev *pdev)\r\n{\r\nstruct pci_bus *bus;\r\nstruct pci_controller *hose;\r\nstruct pnv_phb *phb;\r\nstruct pci_dn *pdn;\r\nstruct pci_sriov *iov;\r\nu16 num_vfs;\r\nbus = pdev->bus;\r\nhose = pci_bus_to_host(bus);\r\nphb = hose->private_data;\r\npdn = pci_get_pdn(pdev);\r\niov = pdev->sriov;\r\nnum_vfs = pdn->num_vfs;\r\npnv_ioda_release_vf_PE(pdev, num_vfs);\r\nif (phb->type == PNV_PHB_IODA2) {\r\nif (pdn->m64_per_iov == 1)\r\npnv_pci_vf_resource_shift(pdev, -pdn->offset);\r\npnv_pci_vf_release_m64(pdev);\r\nbitmap_clear(phb->ioda.pe_alloc, pdn->offset, num_vfs);\r\npdn->offset = 0;\r\n}\r\n}\r\nstatic void pnv_ioda_setup_vf_PE(struct pci_dev *pdev, u16 num_vfs)\r\n{\r\nstruct pci_bus *bus;\r\nstruct pci_controller *hose;\r\nstruct pnv_phb *phb;\r\nstruct pnv_ioda_pe *pe;\r\nint pe_num;\r\nu16 vf_index;\r\nstruct pci_dn *pdn;\r\nint64_t rc;\r\nbus = pdev->bus;\r\nhose = pci_bus_to_host(bus);\r\nphb = hose->private_data;\r\npdn = pci_get_pdn(pdev);\r\nif (!pdev->is_physfn)\r\nreturn;\r\nfor (vf_index = 0; vf_index < num_vfs; vf_index++) {\r\npe_num = pdn->offset + vf_index;\r\npe = &phb->ioda.pe_array[pe_num];\r\npe->pe_number = pe_num;\r\npe->phb = phb;\r\npe->flags = PNV_IODA_PE_VF;\r\npe->pbus = NULL;\r\npe->parent_dev = pdev;\r\npe->tce32_seg = -1;\r\npe->mve_number = -1;\r\npe->rid = (pci_iov_virtfn_bus(pdev, vf_index) << 8) |\r\npci_iov_virtfn_devfn(pdev, vf_index);\r\npe_info(pe, "VF %04d:%02d:%02d.%d associated with PE#%d\n",\r\nhose->global_number, pdev->bus->number,\r\nPCI_SLOT(pci_iov_virtfn_devfn(pdev, vf_index)),\r\nPCI_FUNC(pci_iov_virtfn_devfn(pdev, vf_index)), pe_num);\r\nif (pnv_ioda_configure_pe(phb, pe)) {\r\nif (pe_num)\r\npnv_ioda_free_pe(phb, pe_num);\r\npe->pdev = NULL;\r\ncontinue;\r\n}\r\nmutex_lock(&phb->ioda.pe_list_mutex);\r\nlist_add_tail(&pe->list, &phb->ioda.pe_list);\r\nmutex_unlock(&phb->ioda.pe_list_mutex);\r\npnv_pci_ioda2_setup_dma_pe(phb, pe);\r\n}\r\nif (pdn->m64_per_iov == M64_PER_IOV && num_vfs > M64_PER_IOV) {\r\nint vf_group;\r\nint vf_per_group;\r\nint vf_index1;\r\nvf_per_group = roundup_pow_of_two(num_vfs) / pdn->m64_per_iov;\r\nfor (vf_group = 0; vf_group < M64_PER_IOV; vf_group++) {\r\nfor (vf_index = vf_group * vf_per_group;\r\nvf_index < (vf_group + 1) * vf_per_group &&\r\nvf_index < num_vfs;\r\nvf_index++) {\r\nfor (vf_index1 = vf_group * vf_per_group;\r\nvf_index1 < (vf_group + 1) * vf_per_group &&\r\nvf_index1 < num_vfs;\r\nvf_index1++) {\r\nrc = opal_pci_set_peltv(phb->opal_id,\r\npdn->offset + vf_index,\r\npdn->offset + vf_index1,\r\nOPAL_ADD_PE_TO_DOMAIN);\r\nif (rc)\r\ndev_warn(&pdev->dev, "%s: Failed to link same group PE#%d(%lld)\n",\r\n__func__,\r\npdn->offset + vf_index1, rc);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nint pnv_pci_sriov_enable(struct pci_dev *pdev, u16 num_vfs)\r\n{\r\nstruct pci_bus *bus;\r\nstruct pci_controller *hose;\r\nstruct pnv_phb *phb;\r\nstruct pci_dn *pdn;\r\nint ret;\r\nbus = pdev->bus;\r\nhose = pci_bus_to_host(bus);\r\nphb = hose->private_data;\r\npdn = pci_get_pdn(pdev);\r\nif (phb->type == PNV_PHB_IODA2) {\r\nmutex_lock(&phb->ioda.pe_alloc_mutex);\r\npdn->offset = bitmap_find_next_zero_area(\r\nphb->ioda.pe_alloc, phb->ioda.total_pe,\r\n0, num_vfs, 0);\r\nif (pdn->offset >= phb->ioda.total_pe) {\r\nmutex_unlock(&phb->ioda.pe_alloc_mutex);\r\ndev_info(&pdev->dev, "Failed to enable VF%d\n", num_vfs);\r\npdn->offset = 0;\r\nreturn -EBUSY;\r\n}\r\nbitmap_set(phb->ioda.pe_alloc, pdn->offset, num_vfs);\r\npdn->num_vfs = num_vfs;\r\nmutex_unlock(&phb->ioda.pe_alloc_mutex);\r\nret = pnv_pci_vf_assign_m64(pdev, num_vfs);\r\nif (ret) {\r\ndev_info(&pdev->dev, "Not enough M64 window resources\n");\r\ngoto m64_failed;\r\n}\r\nif (pdn->m64_per_iov == 1) {\r\nret = pnv_pci_vf_resource_shift(pdev, pdn->offset);\r\nif (ret)\r\ngoto m64_failed;\r\n}\r\n}\r\npnv_ioda_setup_vf_PE(pdev, num_vfs);\r\nreturn 0;\r\nm64_failed:\r\nbitmap_clear(phb->ioda.pe_alloc, pdn->offset, num_vfs);\r\npdn->offset = 0;\r\nreturn ret;\r\n}\r\nint pcibios_sriov_disable(struct pci_dev *pdev)\r\n{\r\npnv_pci_sriov_disable(pdev);\r\nremove_dev_pci_data(pdev);\r\nreturn 0;\r\n}\r\nint pcibios_sriov_enable(struct pci_dev *pdev, u16 num_vfs)\r\n{\r\nadd_dev_pci_data(pdev);\r\npnv_pci_sriov_enable(pdev, num_vfs);\r\nreturn 0;\r\n}\r\nstatic void pnv_pci_ioda_dma_dev_setup(struct pnv_phb *phb, struct pci_dev *pdev)\r\n{\r\nstruct pci_dn *pdn = pci_get_pdn(pdev);\r\nstruct pnv_ioda_pe *pe;\r\nif (!pdn || pdn->pe_number == IODA_INVALID_PE)\r\nreturn;\r\npe = &phb->ioda.pe_array[pdn->pe_number];\r\nWARN_ON(get_dma_ops(&pdev->dev) != &dma_iommu_ops);\r\nset_dma_offset(&pdev->dev, pe->tce_bypass_base);\r\nset_iommu_table_base(&pdev->dev, pe->table_group.tables[0]);\r\n}\r\nstatic int pnv_pci_ioda_dma_set_mask(struct pci_dev *pdev, u64 dma_mask)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct pci_dn *pdn = pci_get_pdn(pdev);\r\nstruct pnv_ioda_pe *pe;\r\nuint64_t top;\r\nbool bypass = false;\r\nif (WARN_ON(!pdn || pdn->pe_number == IODA_INVALID_PE))\r\nreturn -ENODEV;;\r\npe = &phb->ioda.pe_array[pdn->pe_number];\r\nif (pe->tce_bypass_enabled) {\r\ntop = pe->tce_bypass_base + memblock_end_of_DRAM() - 1;\r\nbypass = (dma_mask >= top);\r\n}\r\nif (bypass) {\r\ndev_info(&pdev->dev, "Using 64-bit DMA iommu bypass\n");\r\nset_dma_ops(&pdev->dev, &dma_direct_ops);\r\n} else {\r\ndev_info(&pdev->dev, "Using 32-bit DMA via iommu\n");\r\nset_dma_ops(&pdev->dev, &dma_iommu_ops);\r\n}\r\n*pdev->dev.dma_mask = dma_mask;\r\nreturn 0;\r\n}\r\nstatic u64 pnv_pci_ioda_dma_get_required_mask(struct pci_dev *pdev)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct pci_dn *pdn = pci_get_pdn(pdev);\r\nstruct pnv_ioda_pe *pe;\r\nu64 end, mask;\r\nif (WARN_ON(!pdn || pdn->pe_number == IODA_INVALID_PE))\r\nreturn 0;\r\npe = &phb->ioda.pe_array[pdn->pe_number];\r\nif (!pe->tce_bypass_enabled)\r\nreturn __dma_get_required_mask(&pdev->dev);\r\nend = pe->tce_bypass_base + memblock_end_of_DRAM();\r\nmask = 1ULL << (fls64(end) - 1);\r\nmask += mask - 1;\r\nreturn mask;\r\n}\r\nstatic void pnv_ioda_setup_bus_dma(struct pnv_ioda_pe *pe,\r\nstruct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nset_iommu_table_base(&dev->dev, pe->table_group.tables[0]);\r\nset_dma_offset(&dev->dev, pe->tce_bypass_base);\r\niommu_add_device(&dev->dev);\r\nif ((pe->flags & PNV_IODA_PE_BUS_ALL) && dev->subordinate)\r\npnv_ioda_setup_bus_dma(pe, dev->subordinate);\r\n}\r\n}\r\nstatic void pnv_pci_ioda1_tce_invalidate(struct iommu_table *tbl,\r\nunsigned long index, unsigned long npages, bool rm)\r\n{\r\nstruct iommu_table_group_link *tgl = list_first_entry_or_null(\r\n&tbl->it_group_list, struct iommu_table_group_link,\r\nnext);\r\nstruct pnv_ioda_pe *pe = container_of(tgl->table_group,\r\nstruct pnv_ioda_pe, table_group);\r\n__be64 __iomem *invalidate = rm ?\r\n(__be64 __iomem *)pe->phb->ioda.tce_inval_reg_phys :\r\npe->phb->ioda.tce_inval_reg;\r\nunsigned long start, end, inc;\r\nconst unsigned shift = tbl->it_page_shift;\r\nstart = __pa(((__be64 *)tbl->it_base) + index - tbl->it_offset);\r\nend = __pa(((__be64 *)tbl->it_base) + index - tbl->it_offset +\r\nnpages - 1);\r\nif (tbl->it_busno) {\r\nstart <<= shift;\r\nend <<= shift;\r\ninc = 128ull << shift;\r\nstart |= tbl->it_busno;\r\nend |= tbl->it_busno;\r\n} else if (tbl->it_type & TCE_PCI_SWINV_PAIR) {\r\nstart |= (1ull << 63);\r\nend |= (1ull << 63);\r\ninc = 16;\r\n} else {\r\ninc = 128;\r\n}\r\nend |= inc - 1;\r\nmb();\r\nwhile (start <= end) {\r\nif (rm)\r\n__raw_rm_writeq(cpu_to_be64(start), invalidate);\r\nelse\r\n__raw_writeq(cpu_to_be64(start), invalidate);\r\nstart += inc;\r\n}\r\n}\r\nstatic int pnv_ioda1_tce_build(struct iommu_table *tbl, long index,\r\nlong npages, unsigned long uaddr,\r\nenum dma_data_direction direction,\r\nstruct dma_attrs *attrs)\r\n{\r\nint ret = pnv_tce_build(tbl, index, npages, uaddr, direction,\r\nattrs);\r\nif (!ret && (tbl->it_type & TCE_PCI_SWINV_CREATE))\r\npnv_pci_ioda1_tce_invalidate(tbl, index, npages, false);\r\nreturn ret;\r\n}\r\nstatic int pnv_ioda1_tce_xchg(struct iommu_table *tbl, long index,\r\nunsigned long *hpa, enum dma_data_direction *direction)\r\n{\r\nlong ret = pnv_tce_xchg(tbl, index, hpa, direction);\r\nif (!ret && (tbl->it_type &\r\n(TCE_PCI_SWINV_CREATE | TCE_PCI_SWINV_FREE)))\r\npnv_pci_ioda1_tce_invalidate(tbl, index, 1, false);\r\nreturn ret;\r\n}\r\nstatic void pnv_ioda1_tce_free(struct iommu_table *tbl, long index,\r\nlong npages)\r\n{\r\npnv_tce_free(tbl, index, npages);\r\nif (tbl->it_type & TCE_PCI_SWINV_FREE)\r\npnv_pci_ioda1_tce_invalidate(tbl, index, npages, false);\r\n}\r\nstatic inline void pnv_pci_ioda2_tce_invalidate_entire(struct pnv_ioda_pe *pe)\r\n{\r\nunsigned long val = (0x4ull << 60) | (pe->pe_number & 0xFF);\r\nstruct pnv_phb *phb = pe->phb;\r\nif (!phb->ioda.tce_inval_reg)\r\nreturn;\r\nmb();\r\n__raw_writeq(cpu_to_be64(val), phb->ioda.tce_inval_reg);\r\n}\r\nstatic void pnv_pci_ioda2_do_tce_invalidate(unsigned pe_number, bool rm,\r\n__be64 __iomem *invalidate, unsigned shift,\r\nunsigned long index, unsigned long npages)\r\n{\r\nunsigned long start, end, inc;\r\nstart = 0x2ull << 60;\r\nstart |= (pe_number & 0xFF);\r\nend = start;\r\nstart |= (index << shift);\r\nend |= ((index + npages - 1) << shift);\r\ninc = (0x1ull << shift);\r\nmb();\r\nwhile (start <= end) {\r\nif (rm)\r\n__raw_rm_writeq(cpu_to_be64(start), invalidate);\r\nelse\r\n__raw_writeq(cpu_to_be64(start), invalidate);\r\nstart += inc;\r\n}\r\n}\r\nstatic void pnv_pci_ioda2_tce_invalidate(struct iommu_table *tbl,\r\nunsigned long index, unsigned long npages, bool rm)\r\n{\r\nstruct iommu_table_group_link *tgl;\r\nlist_for_each_entry_rcu(tgl, &tbl->it_group_list, next) {\r\nstruct pnv_ioda_pe *pe = container_of(tgl->table_group,\r\nstruct pnv_ioda_pe, table_group);\r\n__be64 __iomem *invalidate = rm ?\r\n(__be64 __iomem *)pe->phb->ioda.tce_inval_reg_phys :\r\npe->phb->ioda.tce_inval_reg;\r\npnv_pci_ioda2_do_tce_invalidate(pe->pe_number, rm,\r\ninvalidate, tbl->it_page_shift,\r\nindex, npages);\r\n}\r\n}\r\nstatic int pnv_ioda2_tce_build(struct iommu_table *tbl, long index,\r\nlong npages, unsigned long uaddr,\r\nenum dma_data_direction direction,\r\nstruct dma_attrs *attrs)\r\n{\r\nint ret = pnv_tce_build(tbl, index, npages, uaddr, direction,\r\nattrs);\r\nif (!ret && (tbl->it_type & TCE_PCI_SWINV_CREATE))\r\npnv_pci_ioda2_tce_invalidate(tbl, index, npages, false);\r\nreturn ret;\r\n}\r\nstatic int pnv_ioda2_tce_xchg(struct iommu_table *tbl, long index,\r\nunsigned long *hpa, enum dma_data_direction *direction)\r\n{\r\nlong ret = pnv_tce_xchg(tbl, index, hpa, direction);\r\nif (!ret && (tbl->it_type &\r\n(TCE_PCI_SWINV_CREATE | TCE_PCI_SWINV_FREE)))\r\npnv_pci_ioda2_tce_invalidate(tbl, index, 1, false);\r\nreturn ret;\r\n}\r\nstatic void pnv_ioda2_tce_free(struct iommu_table *tbl, long index,\r\nlong npages)\r\n{\r\npnv_tce_free(tbl, index, npages);\r\nif (tbl->it_type & TCE_PCI_SWINV_FREE)\r\npnv_pci_ioda2_tce_invalidate(tbl, index, npages, false);\r\n}\r\nstatic void pnv_ioda2_table_free(struct iommu_table *tbl)\r\n{\r\npnv_pci_ioda2_table_free_pages(tbl);\r\niommu_free_table(tbl, "pnv");\r\n}\r\nstatic void pnv_pci_ioda_setup_dma_pe(struct pnv_phb *phb,\r\nstruct pnv_ioda_pe *pe, unsigned int base,\r\nunsigned int segs)\r\n{\r\nstruct page *tce_mem = NULL;\r\nstruct iommu_table *tbl;\r\nunsigned int i;\r\nint64_t rc;\r\nvoid *addr;\r\nif (WARN_ON(pe->tce32_seg >= 0))\r\nreturn;\r\ntbl = pnv_pci_table_alloc(phb->hose->node);\r\niommu_register_group(&pe->table_group, phb->hose->global_number,\r\npe->pe_number);\r\npnv_pci_link_table_and_group(phb->hose->node, 0, tbl, &pe->table_group);\r\npe->tce32_seg = base;\r\npe_info(pe, " Setting up 32-bit TCE table at %08x..%08x\n",\r\n(base << 28), ((base + segs) << 28) - 1);\r\ntce_mem = alloc_pages_node(phb->hose->node, GFP_KERNEL,\r\nget_order(TCE32_TABLE_SIZE * segs));\r\nif (!tce_mem) {\r\npe_err(pe, " Failed to allocate a 32-bit TCE memory\n");\r\ngoto fail;\r\n}\r\naddr = page_address(tce_mem);\r\nmemset(addr, 0, TCE32_TABLE_SIZE * segs);\r\nfor (i = 0; i < segs; i++) {\r\nrc = opal_pci_map_pe_dma_window(phb->opal_id,\r\npe->pe_number,\r\nbase + i, 1,\r\n__pa(addr) + TCE32_TABLE_SIZE * i,\r\nTCE32_TABLE_SIZE, 0x1000);\r\nif (rc) {\r\npe_err(pe, " Failed to configure 32-bit TCE table,"\r\n" err %ld\n", rc);\r\ngoto fail;\r\n}\r\n}\r\npnv_pci_setup_iommu_table(tbl, addr, TCE32_TABLE_SIZE * segs,\r\nbase << 28, IOMMU_PAGE_SHIFT_4K);\r\nif (phb->ioda.tce_inval_reg)\r\ntbl->it_type |= (TCE_PCI_SWINV_CREATE |\r\nTCE_PCI_SWINV_FREE |\r\nTCE_PCI_SWINV_PAIR);\r\ntbl->it_ops = &pnv_ioda1_iommu_ops;\r\npe->table_group.tce32_start = tbl->it_offset << tbl->it_page_shift;\r\npe->table_group.tce32_size = tbl->it_size << tbl->it_page_shift;\r\niommu_init_table(tbl, phb->hose->node);\r\nif (pe->flags & PNV_IODA_PE_DEV) {\r\nset_iommu_table_base(&pe->pdev->dev, tbl);\r\niommu_add_device(&pe->pdev->dev);\r\n} else if (pe->flags & (PNV_IODA_PE_BUS | PNV_IODA_PE_BUS_ALL))\r\npnv_ioda_setup_bus_dma(pe, pe->pbus);\r\nreturn;\r\nfail:\r\nif (pe->tce32_seg >= 0)\r\npe->tce32_seg = -1;\r\nif (tce_mem)\r\n__free_pages(tce_mem, get_order(TCE32_TABLE_SIZE * segs));\r\nif (tbl) {\r\npnv_pci_unlink_table_and_group(tbl, &pe->table_group);\r\niommu_free_table(tbl, "pnv");\r\n}\r\n}\r\nstatic long pnv_pci_ioda2_set_window(struct iommu_table_group *table_group,\r\nint num, struct iommu_table *tbl)\r\n{\r\nstruct pnv_ioda_pe *pe = container_of(table_group, struct pnv_ioda_pe,\r\ntable_group);\r\nstruct pnv_phb *phb = pe->phb;\r\nint64_t rc;\r\nconst unsigned long size = tbl->it_indirect_levels ?\r\ntbl->it_level_size : tbl->it_size;\r\nconst __u64 start_addr = tbl->it_offset << tbl->it_page_shift;\r\nconst __u64 win_size = tbl->it_size << tbl->it_page_shift;\r\npe_info(pe, "Setting up window#%d %llx..%llx pg=%x\n", num,\r\nstart_addr, start_addr + win_size - 1,\r\nIOMMU_PAGE_SIZE(tbl));\r\nrc = opal_pci_map_pe_dma_window(phb->opal_id,\r\npe->pe_number,\r\n(pe->pe_number << 1) + num,\r\ntbl->it_indirect_levels + 1,\r\n__pa(tbl->it_base),\r\nsize << 3,\r\nIOMMU_PAGE_SIZE(tbl));\r\nif (rc) {\r\npe_err(pe, "Failed to configure TCE table, err %ld\n", rc);\r\nreturn rc;\r\n}\r\npnv_pci_link_table_and_group(phb->hose->node, num,\r\ntbl, &pe->table_group);\r\npnv_pci_ioda2_tce_invalidate_entire(pe);\r\nreturn 0;\r\n}\r\nstatic void pnv_pci_ioda2_set_bypass(struct pnv_ioda_pe *pe, bool enable)\r\n{\r\nuint16_t window_id = (pe->pe_number << 1 ) + 1;\r\nint64_t rc;\r\npe_info(pe, "%sabling 64-bit DMA bypass\n", enable ? "En" : "Dis");\r\nif (enable) {\r\nphys_addr_t top = memblock_end_of_DRAM();\r\ntop = roundup_pow_of_two(top);\r\nrc = opal_pci_map_pe_dma_window_real(pe->phb->opal_id,\r\npe->pe_number,\r\nwindow_id,\r\npe->tce_bypass_base,\r\ntop);\r\n} else {\r\nrc = opal_pci_map_pe_dma_window_real(pe->phb->opal_id,\r\npe->pe_number,\r\nwindow_id,\r\npe->tce_bypass_base,\r\n0);\r\n}\r\nif (rc)\r\npe_err(pe, "OPAL error %lld configuring bypass window\n", rc);\r\nelse\r\npe->tce_bypass_enabled = enable;\r\n}\r\nstatic long pnv_pci_ioda2_create_table(struct iommu_table_group *table_group,\r\nint num, __u32 page_shift, __u64 window_size, __u32 levels,\r\nstruct iommu_table **ptbl)\r\n{\r\nstruct pnv_ioda_pe *pe = container_of(table_group, struct pnv_ioda_pe,\r\ntable_group);\r\nint nid = pe->phb->hose->node;\r\n__u64 bus_offset = num ? pe->tce_bypass_base : table_group->tce32_start;\r\nlong ret;\r\nstruct iommu_table *tbl;\r\ntbl = pnv_pci_table_alloc(nid);\r\nif (!tbl)\r\nreturn -ENOMEM;\r\nret = pnv_pci_ioda2_table_alloc_pages(nid,\r\nbus_offset, page_shift, window_size,\r\nlevels, tbl);\r\nif (ret) {\r\niommu_free_table(tbl, "pnv");\r\nreturn ret;\r\n}\r\ntbl->it_ops = &pnv_ioda2_iommu_ops;\r\nif (pe->phb->ioda.tce_inval_reg)\r\ntbl->it_type |= (TCE_PCI_SWINV_CREATE | TCE_PCI_SWINV_FREE);\r\n*ptbl = tbl;\r\nreturn 0;\r\n}\r\nstatic long pnv_pci_ioda2_setup_default_config(struct pnv_ioda_pe *pe)\r\n{\r\nstruct iommu_table *tbl = NULL;\r\nlong rc;\r\nconst u64 max_memory = __rounddown_pow_of_two(memory_hotplug_max());\r\nconst u64 window_size = min((u64)pe->table_group.tce32_size, max_memory);\r\nrc = pnv_pci_ioda2_create_table(&pe->table_group, 0,\r\nIOMMU_PAGE_SHIFT_4K,\r\nwindow_size,\r\nPOWERNV_IOMMU_DEFAULT_LEVELS, &tbl);\r\nif (rc) {\r\npe_err(pe, "Failed to create 32-bit TCE table, err %ld",\r\nrc);\r\nreturn rc;\r\n}\r\niommu_init_table(tbl, pe->phb->hose->node);\r\nrc = pnv_pci_ioda2_set_window(&pe->table_group, 0, tbl);\r\nif (rc) {\r\npe_err(pe, "Failed to configure 32-bit TCE table, err %ld\n",\r\nrc);\r\npnv_ioda2_table_free(tbl);\r\nreturn rc;\r\n}\r\nif (!pnv_iommu_bypass_disabled)\r\npnv_pci_ioda2_set_bypass(pe, true);\r\nif (pe->phb->ioda.tce_inval_reg)\r\ntbl->it_type |= (TCE_PCI_SWINV_CREATE | TCE_PCI_SWINV_FREE);\r\nif (pe->flags & PNV_IODA_PE_DEV)\r\nset_iommu_table_base(&pe->pdev->dev, tbl);\r\nreturn 0;\r\n}\r\nstatic long pnv_pci_ioda2_unset_window(struct iommu_table_group *table_group,\r\nint num)\r\n{\r\nstruct pnv_ioda_pe *pe = container_of(table_group, struct pnv_ioda_pe,\r\ntable_group);\r\nstruct pnv_phb *phb = pe->phb;\r\nlong ret;\r\npe_info(pe, "Removing DMA window #%d\n", num);\r\nret = opal_pci_map_pe_dma_window(phb->opal_id, pe->pe_number,\r\n(pe->pe_number << 1) + num,\r\n0, 0,\r\n0, 0);\r\nif (ret)\r\npe_warn(pe, "Unmapping failed, ret = %ld\n", ret);\r\nelse\r\npnv_pci_ioda2_tce_invalidate_entire(pe);\r\npnv_pci_unlink_table_and_group(table_group->tables[num], table_group);\r\nreturn ret;\r\n}\r\nstatic unsigned long pnv_pci_ioda2_get_table_size(__u32 page_shift,\r\n__u64 window_size, __u32 levels)\r\n{\r\nunsigned long bytes = 0;\r\nconst unsigned window_shift = ilog2(window_size);\r\nunsigned entries_shift = window_shift - page_shift;\r\nunsigned table_shift = entries_shift + 3;\r\nunsigned long tce_table_size = max(0x1000UL, 1UL << table_shift);\r\nunsigned long direct_table_size;\r\nif (!levels || (levels > POWERNV_IOMMU_MAX_LEVELS) ||\r\n(window_size > memory_hotplug_max()) ||\r\n!is_power_of_2(window_size))\r\nreturn 0;\r\nentries_shift = (entries_shift + levels - 1) / levels;\r\ntable_shift = entries_shift + 3;\r\ntable_shift = max_t(unsigned, table_shift, PAGE_SHIFT);\r\ndirect_table_size = 1UL << table_shift;\r\nfor ( ; levels; --levels) {\r\nbytes += _ALIGN_UP(tce_table_size, direct_table_size);\r\ntce_table_size /= direct_table_size;\r\ntce_table_size <<= 3;\r\ntce_table_size = _ALIGN_UP(tce_table_size, direct_table_size);\r\n}\r\nreturn bytes;\r\n}\r\nstatic void pnv_ioda2_take_ownership(struct iommu_table_group *table_group)\r\n{\r\nstruct pnv_ioda_pe *pe = container_of(table_group, struct pnv_ioda_pe,\r\ntable_group);\r\nstruct iommu_table *tbl = pe->table_group.tables[0];\r\npnv_pci_ioda2_set_bypass(pe, false);\r\npnv_pci_ioda2_unset_window(&pe->table_group, 0);\r\npnv_ioda2_table_free(tbl);\r\n}\r\nstatic void pnv_ioda2_release_ownership(struct iommu_table_group *table_group)\r\n{\r\nstruct pnv_ioda_pe *pe = container_of(table_group, struct pnv_ioda_pe,\r\ntable_group);\r\npnv_pci_ioda2_setup_default_config(pe);\r\n}\r\nstatic void pnv_pci_ioda_setup_opal_tce_kill(struct pnv_phb *phb)\r\n{\r\nconst __be64 *swinvp;\r\nswinvp = of_get_property(phb->hose->dn, "ibm,opal-tce-kill", NULL);\r\nif (!swinvp)\r\nreturn;\r\nphb->ioda.tce_inval_reg_phys = be64_to_cpup(swinvp);\r\nphb->ioda.tce_inval_reg = ioremap(phb->ioda.tce_inval_reg_phys, 8);\r\n}\r\nstatic __be64 *pnv_pci_ioda2_table_do_alloc_pages(int nid, unsigned shift,\r\nunsigned levels, unsigned long limit,\r\nunsigned long *current_offset, unsigned long *total_allocated)\r\n{\r\nstruct page *tce_mem = NULL;\r\n__be64 *addr, *tmp;\r\nunsigned order = max_t(unsigned, shift, PAGE_SHIFT) - PAGE_SHIFT;\r\nunsigned long allocated = 1UL << (order + PAGE_SHIFT);\r\nunsigned entries = 1UL << (shift - 3);\r\nlong i;\r\ntce_mem = alloc_pages_node(nid, GFP_KERNEL, order);\r\nif (!tce_mem) {\r\npr_err("Failed to allocate a TCE memory, order=%d\n", order);\r\nreturn NULL;\r\n}\r\naddr = page_address(tce_mem);\r\nmemset(addr, 0, allocated);\r\n*total_allocated += allocated;\r\n--levels;\r\nif (!levels) {\r\n*current_offset += allocated;\r\nreturn addr;\r\n}\r\nfor (i = 0; i < entries; ++i) {\r\ntmp = pnv_pci_ioda2_table_do_alloc_pages(nid, shift,\r\nlevels, limit, current_offset, total_allocated);\r\nif (!tmp)\r\nbreak;\r\naddr[i] = cpu_to_be64(__pa(tmp) |\r\nTCE_PCI_READ | TCE_PCI_WRITE);\r\nif (*current_offset >= limit)\r\nbreak;\r\n}\r\nreturn addr;\r\n}\r\nstatic long pnv_pci_ioda2_table_alloc_pages(int nid, __u64 bus_offset,\r\n__u32 page_shift, __u64 window_size, __u32 levels,\r\nstruct iommu_table *tbl)\r\n{\r\nvoid *addr;\r\nunsigned long offset = 0, level_shift, total_allocated = 0;\r\nconst unsigned window_shift = ilog2(window_size);\r\nunsigned entries_shift = window_shift - page_shift;\r\nunsigned table_shift = max_t(unsigned, entries_shift + 3, PAGE_SHIFT);\r\nconst unsigned long tce_table_size = 1UL << table_shift;\r\nif (!levels || (levels > POWERNV_IOMMU_MAX_LEVELS))\r\nreturn -EINVAL;\r\nif ((window_size > memory_hotplug_max()) || !is_power_of_2(window_size))\r\nreturn -EINVAL;\r\nentries_shift = (entries_shift + levels - 1) / levels;\r\nlevel_shift = entries_shift + 3;\r\nlevel_shift = max_t(unsigned, level_shift, PAGE_SHIFT);\r\naddr = pnv_pci_ioda2_table_do_alloc_pages(nid, level_shift,\r\nlevels, tce_table_size, &offset, &total_allocated);\r\nif (!addr)\r\nreturn -ENOMEM;\r\nif (offset < tce_table_size) {\r\npnv_pci_ioda2_table_do_free_pages(addr,\r\n1ULL << (level_shift - 3), levels - 1);\r\nreturn -ENOMEM;\r\n}\r\npnv_pci_setup_iommu_table(tbl, addr, tce_table_size, bus_offset,\r\npage_shift);\r\ntbl->it_level_size = 1ULL << (level_shift - 3);\r\ntbl->it_indirect_levels = levels - 1;\r\ntbl->it_allocated_size = total_allocated;\r\npr_devel("Created TCE table: ws=%08llx ts=%lx @%08llx\n",\r\nwindow_size, tce_table_size, bus_offset);\r\nreturn 0;\r\n}\r\nstatic void pnv_pci_ioda2_table_do_free_pages(__be64 *addr,\r\nunsigned long size, unsigned level)\r\n{\r\nconst unsigned long addr_ul = (unsigned long) addr &\r\n~(TCE_PCI_READ | TCE_PCI_WRITE);\r\nif (level) {\r\nlong i;\r\nu64 *tmp = (u64 *) addr_ul;\r\nfor (i = 0; i < size; ++i) {\r\nunsigned long hpa = be64_to_cpu(tmp[i]);\r\nif (!(hpa & (TCE_PCI_READ | TCE_PCI_WRITE)))\r\ncontinue;\r\npnv_pci_ioda2_table_do_free_pages(__va(hpa), size,\r\nlevel - 1);\r\n}\r\n}\r\nfree_pages(addr_ul, get_order(size << 3));\r\n}\r\nstatic void pnv_pci_ioda2_table_free_pages(struct iommu_table *tbl)\r\n{\r\nconst unsigned long size = tbl->it_indirect_levels ?\r\ntbl->it_level_size : tbl->it_size;\r\nif (!tbl->it_size)\r\nreturn;\r\npnv_pci_ioda2_table_do_free_pages((__be64 *)tbl->it_base, size,\r\ntbl->it_indirect_levels);\r\n}\r\nstatic void pnv_pci_ioda2_setup_dma_pe(struct pnv_phb *phb,\r\nstruct pnv_ioda_pe *pe)\r\n{\r\nint64_t rc;\r\nif (WARN_ON(pe->tce32_seg >= 0))\r\nreturn;\r\npe->tce_bypass_base = 1ull << 59;\r\niommu_register_group(&pe->table_group, phb->hose->global_number,\r\npe->pe_number);\r\npe->tce32_seg = 0;\r\npe_info(pe, "Setting up 32-bit TCE table at 0..%08x\n",\r\nphb->ioda.m32_pci_base);\r\npe->table_group.tce32_start = 0;\r\npe->table_group.tce32_size = phb->ioda.m32_pci_base;\r\npe->table_group.max_dynamic_windows_supported =\r\nIOMMU_TABLE_GROUP_MAX_TABLES;\r\npe->table_group.max_levels = POWERNV_IOMMU_MAX_LEVELS;\r\npe->table_group.pgsizes = SZ_4K | SZ_64K | SZ_16M;\r\n#ifdef CONFIG_IOMMU_API\r\npe->table_group.ops = &pnv_pci_ioda2_ops;\r\n#endif\r\nrc = pnv_pci_ioda2_setup_default_config(pe);\r\nif (rc) {\r\nif (pe->tce32_seg >= 0)\r\npe->tce32_seg = -1;\r\nreturn;\r\n}\r\nif (pe->flags & PNV_IODA_PE_DEV)\r\niommu_add_device(&pe->pdev->dev);\r\nelse if (pe->flags & (PNV_IODA_PE_BUS | PNV_IODA_PE_BUS_ALL))\r\npnv_ioda_setup_bus_dma(pe, pe->pbus);\r\n}\r\nstatic void pnv_ioda_setup_dma(struct pnv_phb *phb)\r\n{\r\nstruct pci_controller *hose = phb->hose;\r\nunsigned int residual, remaining, segs, tw, base;\r\nstruct pnv_ioda_pe *pe;\r\nif (phb->ioda.dma_pe_count > phb->ioda.tce32_count)\r\nresidual = 0;\r\nelse\r\nresidual = phb->ioda.tce32_count -\r\nphb->ioda.dma_pe_count;\r\npr_info("PCI: Domain %04x has %ld available 32-bit DMA segments\n",\r\nhose->global_number, phb->ioda.tce32_count);\r\npr_info("PCI: %d PE# for a total weight of %d\n",\r\nphb->ioda.dma_pe_count, phb->ioda.dma_weight);\r\npnv_pci_ioda_setup_opal_tce_kill(phb);\r\nremaining = phb->ioda.tce32_count;\r\ntw = phb->ioda.dma_weight;\r\nbase = 0;\r\nlist_for_each_entry(pe, &phb->ioda.pe_dma_list, dma_link) {\r\nif (!pe->dma_weight)\r\ncontinue;\r\nif (!remaining) {\r\npe_warn(pe, "No DMA32 resources available\n");\r\ncontinue;\r\n}\r\nsegs = 1;\r\nif (residual) {\r\nsegs += ((pe->dma_weight * residual) + (tw / 2)) / tw;\r\nif (segs > remaining)\r\nsegs = remaining;\r\n}\r\nif (phb->type == PNV_PHB_IODA1) {\r\npe_info(pe, "DMA weight %d, assigned %d DMA32 segments\n",\r\npe->dma_weight, segs);\r\npnv_pci_ioda_setup_dma_pe(phb, pe, base, segs);\r\n} else {\r\npe_info(pe, "Assign DMA32 space\n");\r\nsegs = 0;\r\npnv_pci_ioda2_setup_dma_pe(phb, pe);\r\n}\r\nremaining -= segs;\r\nbase += segs;\r\n}\r\n}\r\nstatic void pnv_ioda2_msi_eoi(struct irq_data *d)\r\n{\r\nunsigned int hw_irq = (unsigned int)irqd_to_hwirq(d);\r\nstruct irq_chip *chip = irq_data_get_irq_chip(d);\r\nstruct pnv_phb *phb = container_of(chip, struct pnv_phb,\r\nioda.irq_chip);\r\nint64_t rc;\r\nrc = opal_pci_msi_eoi(phb->opal_id, hw_irq);\r\nWARN_ON_ONCE(rc);\r\nicp_native_eoi(d);\r\n}\r\nstatic void set_msi_irq_chip(struct pnv_phb *phb, unsigned int virq)\r\n{\r\nstruct irq_data *idata;\r\nstruct irq_chip *ichip;\r\nif (phb->type != PNV_PHB_IODA2)\r\nreturn;\r\nif (!phb->ioda.irq_chip_init) {\r\nidata = irq_get_irq_data(virq);\r\nichip = irq_data_get_irq_chip(idata);\r\nphb->ioda.irq_chip_init = 1;\r\nphb->ioda.irq_chip = *ichip;\r\nphb->ioda.irq_chip.irq_eoi = pnv_ioda2_msi_eoi;\r\n}\r\nirq_set_chip(virq, &phb->ioda.irq_chip);\r\n}\r\nstruct device_node *pnv_pci_get_phb_node(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nreturn of_node_get(hose->dn);\r\n}\r\nint pnv_phb_to_cxl_mode(struct pci_dev *dev, uint64_t mode)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct pnv_ioda_pe *pe;\r\nint rc;\r\npe = pnv_ioda_get_pe(dev);\r\nif (!pe)\r\nreturn -ENODEV;\r\npe_info(pe, "Switching PHB to CXL\n");\r\nrc = opal_pci_set_phb_cxl_mode(phb->opal_id, mode, pe->pe_number);\r\nif (rc)\r\ndev_err(&dev->dev, "opal_pci_set_phb_cxl_mode failed: %i\n", rc);\r\nreturn rc;\r\n}\r\nint pnv_cxl_alloc_hwirqs(struct pci_dev *dev, int num)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nint hwirq = msi_bitmap_alloc_hwirqs(&phb->msi_bmp, num);\r\nif (hwirq < 0) {\r\ndev_warn(&dev->dev, "Failed to find a free MSI\n");\r\nreturn -ENOSPC;\r\n}\r\nreturn phb->msi_base + hwirq;\r\n}\r\nvoid pnv_cxl_release_hwirqs(struct pci_dev *dev, int hwirq, int num)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nmsi_bitmap_free_hwirqs(&phb->msi_bmp, hwirq - phb->msi_base, num);\r\n}\r\nvoid pnv_cxl_release_hwirq_ranges(struct cxl_irq_ranges *irqs,\r\nstruct pci_dev *dev)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nint i, hwirq;\r\nfor (i = 1; i < CXL_IRQ_RANGES; i++) {\r\nif (!irqs->range[i])\r\ncontinue;\r\npr_devel("cxl release irq range 0x%x: offset: 0x%lx limit: %ld\n",\r\ni, irqs->offset[i],\r\nirqs->range[i]);\r\nhwirq = irqs->offset[i] - phb->msi_base;\r\nmsi_bitmap_free_hwirqs(&phb->msi_bmp, hwirq,\r\nirqs->range[i]);\r\n}\r\n}\r\nint pnv_cxl_alloc_hwirq_ranges(struct cxl_irq_ranges *irqs,\r\nstruct pci_dev *dev, int num)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nint i, hwirq, try;\r\nmemset(irqs, 0, sizeof(struct cxl_irq_ranges));\r\nfor (i = 1; i < CXL_IRQ_RANGES && num; i++) {\r\ntry = num;\r\nwhile (try) {\r\nhwirq = msi_bitmap_alloc_hwirqs(&phb->msi_bmp, try);\r\nif (hwirq >= 0)\r\nbreak;\r\ntry /= 2;\r\n}\r\nif (!try)\r\ngoto fail;\r\nirqs->offset[i] = phb->msi_base + hwirq;\r\nirqs->range[i] = try;\r\npr_devel("cxl alloc irq range 0x%x: offset: 0x%lx limit: %li\n",\r\ni, irqs->offset[i], irqs->range[i]);\r\nnum -= try;\r\n}\r\nif (num)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\npnv_cxl_release_hwirq_ranges(irqs, dev);\r\nreturn -ENOSPC;\r\n}\r\nint pnv_cxl_get_irq_count(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nreturn phb->msi_bmp.irq_count;\r\n}\r\nint pnv_cxl_ioda_msi_setup(struct pci_dev *dev, unsigned int hwirq,\r\nunsigned int virq)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nunsigned int xive_num = hwirq - phb->msi_base;\r\nstruct pnv_ioda_pe *pe;\r\nint rc;\r\nif (!(pe = pnv_ioda_get_pe(dev)))\r\nreturn -ENODEV;\r\nrc = opal_pci_set_xive_pe(phb->opal_id, pe->pe_number, xive_num);\r\nif (rc) {\r\npe_warn(pe, "%s: OPAL error %d setting msi_base 0x%x "\r\n"hwirq 0x%x XIVE 0x%x PE\n",\r\npci_name(dev), rc, phb->msi_base, hwirq, xive_num);\r\nreturn -EIO;\r\n}\r\nset_msi_irq_chip(phb, virq);\r\nreturn 0;\r\n}\r\nstatic int pnv_pci_ioda_msi_setup(struct pnv_phb *phb, struct pci_dev *dev,\r\nunsigned int hwirq, unsigned int virq,\r\nunsigned int is_64, struct msi_msg *msg)\r\n{\r\nstruct pnv_ioda_pe *pe = pnv_ioda_get_pe(dev);\r\nunsigned int xive_num = hwirq - phb->msi_base;\r\n__be32 data;\r\nint rc;\r\nif (pe == NULL)\r\nreturn -ENXIO;\r\nif (pe->mve_number < 0)\r\nreturn -ENXIO;\r\nif (dev->no_64bit_msi)\r\nis_64 = 0;\r\nrc = opal_pci_set_xive_pe(phb->opal_id, pe->pe_number, xive_num);\r\nif (rc) {\r\npr_warn("%s: OPAL error %d setting XIVE %d PE\n",\r\npci_name(dev), rc, xive_num);\r\nreturn -EIO;\r\n}\r\nif (is_64) {\r\n__be64 addr64;\r\nrc = opal_get_msi_64(phb->opal_id, pe->mve_number, xive_num, 1,\r\n&addr64, &data);\r\nif (rc) {\r\npr_warn("%s: OPAL error %d getting 64-bit MSI data\n",\r\npci_name(dev), rc);\r\nreturn -EIO;\r\n}\r\nmsg->address_hi = be64_to_cpu(addr64) >> 32;\r\nmsg->address_lo = be64_to_cpu(addr64) & 0xfffffffful;\r\n} else {\r\n__be32 addr32;\r\nrc = opal_get_msi_32(phb->opal_id, pe->mve_number, xive_num, 1,\r\n&addr32, &data);\r\nif (rc) {\r\npr_warn("%s: OPAL error %d getting 32-bit MSI data\n",\r\npci_name(dev), rc);\r\nreturn -EIO;\r\n}\r\nmsg->address_hi = 0;\r\nmsg->address_lo = be32_to_cpu(addr32);\r\n}\r\nmsg->data = be32_to_cpu(data);\r\nset_msi_irq_chip(phb, virq);\r\npr_devel("%s: %s-bit MSI on hwirq %x (xive #%d),"\r\n" address=%x_%08x data=%x PE# %d\n",\r\npci_name(dev), is_64 ? "64" : "32", hwirq, xive_num,\r\nmsg->address_hi, msg->address_lo, data, pe->pe_number);\r\nreturn 0;\r\n}\r\nstatic void pnv_pci_init_ioda_msis(struct pnv_phb *phb)\r\n{\r\nunsigned int count;\r\nconst __be32 *prop = of_get_property(phb->hose->dn,\r\n"ibm,opal-msi-ranges", NULL);\r\nif (!prop) {\r\nprop = of_get_property(phb->hose->dn, "msi-ranges", NULL);\r\n}\r\nif (!prop)\r\nreturn;\r\nphb->msi_base = be32_to_cpup(prop);\r\ncount = be32_to_cpup(prop + 1);\r\nif (msi_bitmap_alloc(&phb->msi_bmp, count, phb->hose->dn)) {\r\npr_err("PCI %d: Failed to allocate MSI bitmap !\n",\r\nphb->hose->global_number);\r\nreturn;\r\n}\r\nphb->msi_setup = pnv_pci_ioda_msi_setup;\r\nphb->msi32_support = 1;\r\npr_info(" Allocated bitmap for %d MSIs (base IRQ 0x%x)\n",\r\ncount, phb->msi_base);\r\n}\r\nstatic void pnv_pci_init_ioda_msis(struct pnv_phb *phb) { }\r\nstatic void pnv_pci_ioda_fixup_iov_resources(struct pci_dev *pdev)\r\n{\r\nstruct pci_controller *hose;\r\nstruct pnv_phb *phb;\r\nstruct resource *res;\r\nint i;\r\nresource_size_t size;\r\nstruct pci_dn *pdn;\r\nint mul, total_vfs;\r\nif (!pdev->is_physfn || pdev->is_added)\r\nreturn;\r\nhose = pci_bus_to_host(pdev->bus);\r\nphb = hose->private_data;\r\npdn = pci_get_pdn(pdev);\r\npdn->vfs_expanded = 0;\r\ntotal_vfs = pci_sriov_get_totalvfs(pdev);\r\npdn->m64_per_iov = 1;\r\nmul = phb->ioda.total_pe;\r\nfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {\r\nres = &pdev->resource[i + PCI_IOV_RESOURCES];\r\nif (!res->flags || res->parent)\r\ncontinue;\r\nif (!pnv_pci_is_mem_pref_64(res->flags)) {\r\ndev_warn(&pdev->dev, " non M64 VF BAR%d: %pR\n",\r\ni, res);\r\ncontinue;\r\n}\r\nsize = pci_iov_resource_size(pdev, i + PCI_IOV_RESOURCES);\r\nif (size > (1 << 26)) {\r\ndev_info(&pdev->dev, "PowerNV: VF BAR%d: %pR IOV size is bigger than 64M, roundup power2\n",\r\ni, res);\r\npdn->m64_per_iov = M64_PER_IOV;\r\nmul = roundup_pow_of_two(total_vfs);\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {\r\nres = &pdev->resource[i + PCI_IOV_RESOURCES];\r\nif (!res->flags || res->parent)\r\ncontinue;\r\nif (!pnv_pci_is_mem_pref_64(res->flags)) {\r\ndev_warn(&pdev->dev, "Skipping expanding VF BAR%d: %pR\n",\r\ni, res);\r\ncontinue;\r\n}\r\ndev_dbg(&pdev->dev, " Fixing VF BAR%d: %pR to\n", i, res);\r\nsize = pci_iov_resource_size(pdev, i + PCI_IOV_RESOURCES);\r\nres->end = res->start + size * mul - 1;\r\ndev_dbg(&pdev->dev, " %pR\n", res);\r\ndev_info(&pdev->dev, "VF BAR%d: %pR (expanded to %d VFs for PE alignment)",\r\ni, res, mul);\r\n}\r\npdn->vfs_expanded = mul;\r\n}\r\nstatic void pnv_ioda_setup_pe_seg(struct pci_controller *hose,\r\nstruct pnv_ioda_pe *pe)\r\n{\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct pci_bus_region region;\r\nstruct resource *res;\r\nint i, index;\r\nint rc;\r\nBUG_ON(!(pe->flags & (PNV_IODA_PE_BUS | PNV_IODA_PE_BUS_ALL)));\r\npci_bus_for_each_resource(pe->pbus, res, i) {\r\nif (!res || !res->flags ||\r\nres->start > res->end)\r\ncontinue;\r\nif (res->flags & IORESOURCE_IO) {\r\nregion.start = res->start - phb->ioda.io_pci_base;\r\nregion.end = res->end - phb->ioda.io_pci_base;\r\nindex = region.start / phb->ioda.io_segsize;\r\nwhile (index < phb->ioda.total_pe &&\r\nregion.start <= region.end) {\r\nphb->ioda.io_segmap[index] = pe->pe_number;\r\nrc = opal_pci_map_pe_mmio_window(phb->opal_id,\r\npe->pe_number, OPAL_IO_WINDOW_TYPE, 0, index);\r\nif (rc != OPAL_SUCCESS) {\r\npr_err("%s: OPAL error %d when mapping IO "\r\n"segment #%d to PE#%d\n",\r\n__func__, rc, index, pe->pe_number);\r\nbreak;\r\n}\r\nregion.start += phb->ioda.io_segsize;\r\nindex++;\r\n}\r\n} else if ((res->flags & IORESOURCE_MEM) &&\r\n!pnv_pci_is_mem_pref_64(res->flags)) {\r\nregion.start = res->start -\r\nhose->mem_offset[0] -\r\nphb->ioda.m32_pci_base;\r\nregion.end = res->end -\r\nhose->mem_offset[0] -\r\nphb->ioda.m32_pci_base;\r\nindex = region.start / phb->ioda.m32_segsize;\r\nwhile (index < phb->ioda.total_pe &&\r\nregion.start <= region.end) {\r\nphb->ioda.m32_segmap[index] = pe->pe_number;\r\nrc = opal_pci_map_pe_mmio_window(phb->opal_id,\r\npe->pe_number, OPAL_M32_WINDOW_TYPE, 0, index);\r\nif (rc != OPAL_SUCCESS) {\r\npr_err("%s: OPAL error %d when mapping M32 "\r\n"segment#%d to PE#%d",\r\n__func__, rc, index, pe->pe_number);\r\nbreak;\r\n}\r\nregion.start += phb->ioda.m32_segsize;\r\nindex++;\r\n}\r\n}\r\n}\r\n}\r\nstatic void pnv_pci_ioda_setup_seg(void)\r\n{\r\nstruct pci_controller *tmp, *hose;\r\nstruct pnv_phb *phb;\r\nstruct pnv_ioda_pe *pe;\r\nlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\r\nphb = hose->private_data;\r\nlist_for_each_entry(pe, &phb->ioda.pe_list, list) {\r\npnv_ioda_setup_pe_seg(hose, pe);\r\n}\r\n}\r\n}\r\nstatic void pnv_pci_ioda_setup_DMA(void)\r\n{\r\nstruct pci_controller *hose, *tmp;\r\nstruct pnv_phb *phb;\r\nlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\r\npnv_ioda_setup_dma(hose->private_data);\r\nphb = hose->private_data;\r\nphb->initialized = 1;\r\n}\r\n}\r\nstatic void pnv_pci_ioda_create_dbgfs(void)\r\n{\r\n#ifdef CONFIG_DEBUG_FS\r\nstruct pci_controller *hose, *tmp;\r\nstruct pnv_phb *phb;\r\nchar name[16];\r\nlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\r\nphb = hose->private_data;\r\nsprintf(name, "PCI%04x", hose->global_number);\r\nphb->dbgfs = debugfs_create_dir(name, powerpc_debugfs_root);\r\nif (!phb->dbgfs)\r\npr_warning("%s: Error on creating debugfs on PHB#%x\n",\r\n__func__, hose->global_number);\r\n}\r\n#endif\r\n}\r\nstatic void pnv_pci_ioda_fixup(void)\r\n{\r\npnv_pci_ioda_setup_PEs();\r\npnv_pci_ioda_setup_seg();\r\npnv_pci_ioda_setup_DMA();\r\npnv_pci_ioda_create_dbgfs();\r\n#ifdef CONFIG_EEH\r\neeh_init();\r\neeh_addr_cache_build();\r\n#endif\r\n}\r\nstatic resource_size_t pnv_pci_window_alignment(struct pci_bus *bus,\r\nunsigned long type)\r\n{\r\nstruct pci_dev *bridge;\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nint num_pci_bridges = 0;\r\nbridge = bus->self;\r\nwhile (bridge) {\r\nif (pci_pcie_type(bridge) == PCI_EXP_TYPE_PCI_BRIDGE) {\r\nnum_pci_bridges++;\r\nif (num_pci_bridges >= 2)\r\nreturn 1;\r\n}\r\nbridge = bridge->bus->self;\r\n}\r\nif (phb->ioda.m64_segsize &&\r\npnv_pci_is_mem_pref_64(type))\r\nreturn phb->ioda.m64_segsize;\r\nif (type & IORESOURCE_MEM)\r\nreturn phb->ioda.m32_segsize;\r\nreturn phb->ioda.io_segsize;\r\n}\r\nstatic resource_size_t pnv_pci_iov_resource_alignment(struct pci_dev *pdev,\r\nint resno)\r\n{\r\nstruct pci_dn *pdn = pci_get_pdn(pdev);\r\nresource_size_t align, iov_align;\r\niov_align = resource_size(&pdev->resource[resno]);\r\nif (iov_align)\r\nreturn iov_align;\r\nalign = pci_iov_resource_size(pdev, resno);\r\nif (pdn->vfs_expanded)\r\nreturn pdn->vfs_expanded * align;\r\nreturn align;\r\n}\r\nstatic bool pnv_pci_enable_device_hook(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct pci_dn *pdn;\r\nif (!phb->initialized)\r\nreturn true;\r\npdn = pci_get_pdn(dev);\r\nif (!pdn || pdn->pe_number == IODA_INVALID_PE)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic u32 pnv_ioda_bdfn_to_pe(struct pnv_phb *phb, struct pci_bus *bus,\r\nu32 devfn)\r\n{\r\nreturn phb->ioda.pe_rmap[(bus->number << 8) | devfn];\r\n}\r\nstatic void pnv_pci_ioda_shutdown(struct pci_controller *hose)\r\n{\r\nstruct pnv_phb *phb = hose->private_data;\r\nopal_pci_reset(phb->opal_id, OPAL_RESET_PCI_IODA_TABLE,\r\nOPAL_ASSERT_RESET);\r\n}\r\nstatic void __init pnv_pci_init_ioda_phb(struct device_node *np,\r\nu64 hub_id, int ioda_type)\r\n{\r\nstruct pci_controller *hose;\r\nstruct pnv_phb *phb;\r\nunsigned long size, m32map_off, pemap_off, iomap_off = 0;\r\nconst __be64 *prop64;\r\nconst __be32 *prop32;\r\nint len;\r\nu64 phb_id;\r\nvoid *aux;\r\nlong rc;\r\npr_info("Initializing IODA%d OPAL PHB %s\n", ioda_type, np->full_name);\r\nprop64 = of_get_property(np, "ibm,opal-phbid", NULL);\r\nif (!prop64) {\r\npr_err(" Missing \"ibm,opal-phbid\" property !\n");\r\nreturn;\r\n}\r\nphb_id = be64_to_cpup(prop64);\r\npr_debug(" PHB-ID : 0x%016llx\n", phb_id);\r\nphb = memblock_virt_alloc(sizeof(struct pnv_phb), 0);\r\nphb->hose = hose = pcibios_alloc_controller(np);\r\nif (!phb->hose) {\r\npr_err(" Can't allocate PCI controller for %s\n",\r\nnp->full_name);\r\nmemblock_free(__pa(phb), sizeof(struct pnv_phb));\r\nreturn;\r\n}\r\nspin_lock_init(&phb->lock);\r\nprop32 = of_get_property(np, "bus-range", &len);\r\nif (prop32 && len == 8) {\r\nhose->first_busno = be32_to_cpu(prop32[0]);\r\nhose->last_busno = be32_to_cpu(prop32[1]);\r\n} else {\r\npr_warn(" Broken <bus-range> on %s\n", np->full_name);\r\nhose->first_busno = 0;\r\nhose->last_busno = 0xff;\r\n}\r\nhose->private_data = phb;\r\nphb->hub_id = hub_id;\r\nphb->opal_id = phb_id;\r\nphb->type = ioda_type;\r\nmutex_init(&phb->ioda.pe_alloc_mutex);\r\nif (of_device_is_compatible(np, "ibm,p7ioc-pciex"))\r\nphb->model = PNV_PHB_MODEL_P7IOC;\r\nelse if (of_device_is_compatible(np, "ibm,power8-pciex"))\r\nphb->model = PNV_PHB_MODEL_PHB3;\r\nelse\r\nphb->model = PNV_PHB_MODEL_UNKNOWN;\r\npci_process_bridge_OF_ranges(hose, np, !hose->global_number);\r\nphb->regs = of_iomap(np, 0);\r\nif (phb->regs == NULL)\r\npr_err(" Failed to map registers !\n");\r\nphb->ioda.total_pe = 1;\r\nprop32 = of_get_property(np, "ibm,opal-num-pes", NULL);\r\nif (prop32)\r\nphb->ioda.total_pe = be32_to_cpup(prop32);\r\nprop32 = of_get_property(np, "ibm,opal-reserved-pe", NULL);\r\nif (prop32)\r\nphb->ioda.reserved_pe = be32_to_cpup(prop32);\r\npnv_ioda_parse_m64_window(phb);\r\nphb->ioda.m32_size = resource_size(&hose->mem_resources[0]);\r\nphb->ioda.m32_size += 0x10000;\r\nphb->ioda.m32_segsize = phb->ioda.m32_size / phb->ioda.total_pe;\r\nphb->ioda.m32_pci_base = hose->mem_resources[0].start - hose->mem_offset[0];\r\nphb->ioda.io_size = hose->pci_io_size;\r\nphb->ioda.io_segsize = phb->ioda.io_size / phb->ioda.total_pe;\r\nphb->ioda.io_pci_base = 0;\r\nsize = _ALIGN_UP(phb->ioda.total_pe / 8, sizeof(unsigned long));\r\nm32map_off = size;\r\nsize += phb->ioda.total_pe * sizeof(phb->ioda.m32_segmap[0]);\r\nif (phb->type == PNV_PHB_IODA1) {\r\niomap_off = size;\r\nsize += phb->ioda.total_pe * sizeof(phb->ioda.io_segmap[0]);\r\n}\r\npemap_off = size;\r\nsize += phb->ioda.total_pe * sizeof(struct pnv_ioda_pe);\r\naux = memblock_virt_alloc(size, 0);\r\nphb->ioda.pe_alloc = aux;\r\nphb->ioda.m32_segmap = aux + m32map_off;\r\nif (phb->type == PNV_PHB_IODA1)\r\nphb->ioda.io_segmap = aux + iomap_off;\r\nphb->ioda.pe_array = aux + pemap_off;\r\nset_bit(phb->ioda.reserved_pe, phb->ioda.pe_alloc);\r\nINIT_LIST_HEAD(&phb->ioda.pe_dma_list);\r\nINIT_LIST_HEAD(&phb->ioda.pe_list);\r\nmutex_init(&phb->ioda.pe_list_mutex);\r\nphb->ioda.tce32_count = phb->ioda.m32_pci_base >> 28;\r\n#if 0\r\nrc = opal_pci_set_phb_mem_window(opal->phb_id,\r\nwindow_type,\r\nwindow_num,\r\nstarting_real_address,\r\nstarting_pci_address,\r\nsegment_size);\r\n#endif\r\npr_info(" %03d (%03d) PE's M32: 0x%x [segment=0x%x]\n",\r\nphb->ioda.total_pe, phb->ioda.reserved_pe,\r\nphb->ioda.m32_size, phb->ioda.m32_segsize);\r\nif (phb->ioda.m64_size)\r\npr_info(" M64: 0x%lx [segment=0x%lx]\n",\r\nphb->ioda.m64_size, phb->ioda.m64_segsize);\r\nif (phb->ioda.io_size)\r\npr_info(" IO: 0x%x [segment=0x%x]\n",\r\nphb->ioda.io_size, phb->ioda.io_segsize);\r\nphb->hose->ops = &pnv_pci_ops;\r\nphb->get_pe_state = pnv_ioda_get_pe_state;\r\nphb->freeze_pe = pnv_ioda_freeze_pe;\r\nphb->unfreeze_pe = pnv_ioda_unfreeze_pe;\r\nphb->bdfn_to_pe = pnv_ioda_bdfn_to_pe;\r\nphb->dma_dev_setup = pnv_pci_ioda_dma_dev_setup;\r\npnv_pci_init_ioda_msis(phb);\r\nppc_md.pcibios_fixup = pnv_pci_ioda_fixup;\r\nhose->controller_ops = pnv_pci_ioda_controller_ops;\r\n#ifdef CONFIG_PCI_IOV\r\nppc_md.pcibios_fixup_sriov = pnv_pci_ioda_fixup_iov_resources;\r\nppc_md.pcibios_iov_resource_alignment = pnv_pci_iov_resource_alignment;\r\n#endif\r\npci_add_flags(PCI_REASSIGN_ALL_RSRC);\r\nrc = opal_pci_reset(phb_id, OPAL_RESET_PCI_IODA_TABLE, OPAL_ASSERT_RESET);\r\nif (rc)\r\npr_warning(" OPAL Error %ld performing IODA table reset !\n", rc);\r\nif (is_kdump_kernel()) {\r\npr_info(" Issue PHB reset ...\n");\r\npnv_eeh_phb_reset(hose, EEH_RESET_FUNDAMENTAL);\r\npnv_eeh_phb_reset(hose, EEH_RESET_DEACTIVATE);\r\n}\r\nif (!phb->init_m64 || phb->init_m64(phb))\r\nhose->mem_resources[1].flags = 0;\r\n}\r\nvoid __init pnv_pci_init_ioda2_phb(struct device_node *np)\r\n{\r\npnv_pci_init_ioda_phb(np, 0, PNV_PHB_IODA2);\r\n}\r\nvoid __init pnv_pci_init_ioda_hub(struct device_node *np)\r\n{\r\nstruct device_node *phbn;\r\nconst __be64 *prop64;\r\nu64 hub_id;\r\npr_info("Probing IODA IO-Hub %s\n", np->full_name);\r\nprop64 = of_get_property(np, "ibm,opal-hubid", NULL);\r\nif (!prop64) {\r\npr_err(" Missing \"ibm,opal-hubid\" property !\n");\r\nreturn;\r\n}\r\nhub_id = be64_to_cpup(prop64);\r\npr_devel(" HUB-ID : 0x%016llx\n", hub_id);\r\nfor_each_child_of_node(np, phbn) {\r\nif (of_device_is_compatible(phbn, "ibm,ioda-phb"))\r\npnv_pci_init_ioda_phb(phbn, hub_id, PNV_PHB_IODA1);\r\n}\r\n}
