static inline void unmask_mips_irq(struct irq_data *d)\r\n{\r\nset_c0_status(0x100 << (d->irq - MIPS_CPU_IRQ_BASE));\r\nirq_enable_hazard();\r\n}\r\nstatic inline void mask_mips_irq(struct irq_data *d)\r\n{\r\nclear_c0_status(0x100 << (d->irq - MIPS_CPU_IRQ_BASE));\r\nirq_disable_hazard();\r\n}\r\nstatic unsigned int mips_mt_cpu_irq_startup(struct irq_data *d)\r\n{\r\nunsigned int vpflags = dvpe();\r\nclear_c0_cause(0x100 << (d->irq - MIPS_CPU_IRQ_BASE));\r\nevpe(vpflags);\r\nunmask_mips_irq(d);\r\nreturn 0;\r\n}\r\nstatic void mips_mt_cpu_irq_ack(struct irq_data *d)\r\n{\r\nunsigned int vpflags = dvpe();\r\nclear_c0_cause(0x100 << (d->irq - MIPS_CPU_IRQ_BASE));\r\nevpe(vpflags);\r\nmask_mips_irq(d);\r\n}\r\nasmlinkage void __weak plat_irq_dispatch(void)\r\n{\r\nunsigned long pending = read_c0_cause() & read_c0_status() & ST0_IM;\r\nint irq;\r\nif (!pending) {\r\nspurious_interrupt();\r\nreturn;\r\n}\r\npending >>= CAUSEB_IP;\r\nwhile (pending) {\r\nirq = fls(pending) - 1;\r\ndo_IRQ(MIPS_CPU_IRQ_BASE + irq);\r\npending &= ~BIT(irq);\r\n}\r\n}\r\nstatic int mips_cpu_intc_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hw)\r\n{\r\nstatic struct irq_chip *chip;\r\nif (hw < 2 && cpu_has_mipsmt) {\r\nchip = &mips_mt_cpu_irq_controller;\r\n} else {\r\nchip = &mips_cpu_irq_controller;\r\n}\r\nif (cpu_has_vint)\r\nset_vi_handler(hw, plat_irq_dispatch);\r\nirq_set_chip_and_handler(irq, chip, handle_percpu_irq);\r\nreturn 0;\r\n}\r\nstatic void __init __mips_cpu_irq_init(struct device_node *of_node)\r\n{\r\nstruct irq_domain *domain;\r\nclear_c0_status(ST0_IM);\r\nclear_c0_cause(CAUSEF_IP);\r\ndomain = irq_domain_add_legacy(of_node, 8, MIPS_CPU_IRQ_BASE, 0,\r\n&mips_cpu_intc_irq_domain_ops, NULL);\r\nif (!domain)\r\npanic("Failed to add irqdomain for MIPS CPU");\r\n}\r\nvoid __init mips_cpu_irq_init(void)\r\n{\r\n__mips_cpu_irq_init(NULL);\r\n}\r\nint __init mips_cpu_irq_of_init(struct device_node *of_node,\r\nstruct device_node *parent)\r\n{\r\n__mips_cpu_irq_init(of_node);\r\nreturn 0;\r\n}
