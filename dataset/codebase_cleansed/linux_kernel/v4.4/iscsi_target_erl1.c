int iscsit_dump_data_payload(\r\nstruct iscsi_conn *conn,\r\nu32 buf_len,\r\nint dump_padding_digest)\r\n{\r\nchar *buf, pad_bytes[4];\r\nint ret = DATAOUT_WITHIN_COMMAND_RECOVERY, rx_got;\r\nu32 length, padding, offset = 0, size;\r\nstruct kvec iov;\r\nif (conn->sess->sess_ops->RDMAExtensions)\r\nreturn 0;\r\nlength = (buf_len > OFFLOAD_BUF_SIZE) ? OFFLOAD_BUF_SIZE : buf_len;\r\nbuf = kzalloc(length, GFP_ATOMIC);\r\nif (!buf) {\r\npr_err("Unable to allocate %u bytes for offload"\r\n" buffer.\n", length);\r\nreturn -1;\r\n}\r\nmemset(&iov, 0, sizeof(struct kvec));\r\nwhile (offset < buf_len) {\r\nsize = ((offset + length) > buf_len) ?\r\n(buf_len - offset) : length;\r\niov.iov_len = size;\r\niov.iov_base = buf;\r\nrx_got = rx_data(conn, &iov, 1, size);\r\nif (rx_got != size) {\r\nret = DATAOUT_CANNOT_RECOVER;\r\ngoto out;\r\n}\r\noffset += size;\r\n}\r\nif (!dump_padding_digest)\r\ngoto out;\r\npadding = ((-buf_len) & 3);\r\nif (padding != 0) {\r\niov.iov_len = padding;\r\niov.iov_base = pad_bytes;\r\nrx_got = rx_data(conn, &iov, 1, padding);\r\nif (rx_got != padding) {\r\nret = DATAOUT_CANNOT_RECOVER;\r\ngoto out;\r\n}\r\n}\r\nif (conn->conn_ops->DataDigest) {\r\nu32 data_crc;\r\niov.iov_len = ISCSI_CRC_LEN;\r\niov.iov_base = &data_crc;\r\nrx_got = rx_data(conn, &iov, 1, ISCSI_CRC_LEN);\r\nif (rx_got != ISCSI_CRC_LEN) {\r\nret = DATAOUT_CANNOT_RECOVER;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int iscsit_send_recovery_r2t_for_snack(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_r2t *r2t)\r\n{\r\nspin_lock_bh(&cmd->r2t_lock);\r\nif (!r2t->sent_r2t) {\r\nspin_unlock_bh(&cmd->r2t_lock);\r\nreturn 0;\r\n}\r\nr2t->sent_r2t = 0;\r\nspin_unlock_bh(&cmd->r2t_lock);\r\niscsit_add_cmd_to_immediate_queue(cmd, cmd->conn, ISTATE_SEND_R2T);\r\nreturn 0;\r\n}\r\nstatic int iscsit_handle_r2t_snack(\r\nstruct iscsi_cmd *cmd,\r\nunsigned char *buf,\r\nu32 begrun,\r\nu32 runlength)\r\n{\r\nu32 last_r2tsn;\r\nstruct iscsi_r2t *r2t;\r\nif ((cmd->cmd_flags & ICF_GOT_DATACK_SNACK) &&\r\n(begrun <= cmd->acked_data_sn)) {\r\npr_err("ITT: 0x%08x, R2T SNACK requesting"\r\n" retransmission of R2TSN: 0x%08x to 0x%08x but already"\r\n" acked to R2TSN: 0x%08x by TMR TASK_REASSIGN,"\r\n" protocol error.\n", cmd->init_task_tag, begrun,\r\n(begrun + runlength), cmd->acked_data_sn);\r\nreturn iscsit_reject_cmd(cmd,\r\nISCSI_REASON_PROTOCOL_ERROR, buf);\r\n}\r\nif (runlength) {\r\nif ((begrun + runlength) > cmd->r2t_sn) {\r\npr_err("Command ITT: 0x%08x received R2T SNACK"\r\n" with BegRun: 0x%08x, RunLength: 0x%08x, exceeds"\r\n" current R2TSN: 0x%08x, protocol error.\n",\r\ncmd->init_task_tag, begrun, runlength, cmd->r2t_sn);\r\nreturn iscsit_reject_cmd(cmd,\r\nISCSI_REASON_BOOKMARK_INVALID, buf);\r\n}\r\nlast_r2tsn = (begrun + runlength);\r\n} else\r\nlast_r2tsn = cmd->r2t_sn;\r\nwhile (begrun < last_r2tsn) {\r\nr2t = iscsit_get_holder_for_r2tsn(cmd, begrun);\r\nif (!r2t)\r\nreturn -1;\r\nif (iscsit_send_recovery_r2t_for_snack(cmd, r2t) < 0)\r\nreturn -1;\r\nbegrun++;\r\n}\r\nreturn 0;\r\n}\r\nint iscsit_create_recovery_datain_values_datasequenceinorder_yes(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_datain_req *dr)\r\n{\r\nu32 data_sn = 0, data_sn_count = 0;\r\nu32 pdu_start = 0, seq_no = 0;\r\nu32 begrun = dr->begrun;\r\nstruct iscsi_conn *conn = cmd->conn;\r\nwhile (begrun > data_sn++) {\r\ndata_sn_count++;\r\nif ((dr->next_burst_len +\r\nconn->conn_ops->MaxRecvDataSegmentLength) <\r\nconn->sess->sess_ops->MaxBurstLength) {\r\ndr->read_data_done +=\r\nconn->conn_ops->MaxRecvDataSegmentLength;\r\ndr->next_burst_len +=\r\nconn->conn_ops->MaxRecvDataSegmentLength;\r\n} else {\r\ndr->read_data_done +=\r\n(conn->sess->sess_ops->MaxBurstLength -\r\ndr->next_burst_len);\r\ndr->next_burst_len = 0;\r\npdu_start += data_sn_count;\r\ndata_sn_count = 0;\r\nseq_no++;\r\n}\r\n}\r\nif (!conn->sess->sess_ops->DataPDUInOrder) {\r\ncmd->seq_no = seq_no;\r\ncmd->pdu_start = pdu_start;\r\ncmd->pdu_send_order = data_sn_count;\r\n}\r\nreturn 0;\r\n}\r\nint iscsit_create_recovery_datain_values_datasequenceinorder_no(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_datain_req *dr)\r\n{\r\nint found_seq = 0, i;\r\nu32 data_sn, read_data_done = 0, seq_send_order = 0;\r\nu32 begrun = dr->begrun;\r\nu32 runlength = dr->runlength;\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct iscsi_seq *first_seq = NULL, *seq = NULL;\r\nif (!cmd->seq_list) {\r\npr_err("struct iscsi_cmd->seq_list is NULL!\n");\r\nreturn -1;\r\n}\r\nfor (i = 0; i < cmd->seq_count; i++) {\r\nseq = &cmd->seq_list[i];\r\nif (!seq->seq_send_order)\r\nfirst_seq = seq;\r\nif (!seq->sent) {\r\npr_err("Ignoring non-sent sequence 0x%08x ->"\r\n" 0x%08x\n\n", seq->first_datasn,\r\nseq->last_datasn);\r\ncontinue;\r\n}\r\nif ((seq->first_datasn < begrun) &&\r\n(seq->last_datasn < begrun)) {\r\npr_err("Pre BegRun sequence 0x%08x ->"\r\n" 0x%08x\n", seq->first_datasn,\r\nseq->last_datasn);\r\nread_data_done += cmd->seq_list[i].xfer_len;\r\nseq->next_burst_len = seq->pdu_send_order = 0;\r\ncontinue;\r\n}\r\nif ((seq->first_datasn <= begrun) &&\r\n(seq->last_datasn >= begrun)) {\r\npr_err("Found sequence begrun: 0x%08x in"\r\n" 0x%08x -> 0x%08x\n", begrun,\r\nseq->first_datasn, seq->last_datasn);\r\nseq_send_order = seq->seq_send_order;\r\ndata_sn = seq->first_datasn;\r\nseq->next_burst_len = seq->pdu_send_order = 0;\r\nfound_seq = 1;\r\nif (conn->sess->sess_ops->DataPDUInOrder) {\r\nwhile (data_sn < begrun) {\r\nseq->pdu_send_order++;\r\nread_data_done +=\r\nconn->conn_ops->MaxRecvDataSegmentLength;\r\nseq->next_burst_len +=\r\nconn->conn_ops->MaxRecvDataSegmentLength;\r\ndata_sn++;\r\n}\r\n} else {\r\nint j;\r\nstruct iscsi_pdu *pdu;\r\nwhile (data_sn < begrun) {\r\nseq->pdu_send_order++;\r\nfor (j = 0; j < seq->pdu_count; j++) {\r\npdu = &cmd->pdu_list[\r\nseq->pdu_start + j];\r\nif (pdu->data_sn == data_sn) {\r\nread_data_done +=\r\npdu->length;\r\nseq->next_burst_len +=\r\npdu->length;\r\n}\r\n}\r\ndata_sn++;\r\n}\r\n}\r\ncontinue;\r\n}\r\nif ((seq->first_datasn > begrun) ||\r\n(seq->last_datasn > begrun)) {\r\npr_err("Post BegRun sequence 0x%08x -> 0x%08x\n",\r\nseq->first_datasn, seq->last_datasn);\r\nseq->next_burst_len = seq->pdu_send_order = 0;\r\ncontinue;\r\n}\r\n}\r\nif (!found_seq) {\r\nif (!begrun) {\r\nif (!first_seq) {\r\npr_err("ITT: 0x%08x, Begrun: 0x%08x"\r\n" but first_seq is NULL\n",\r\ncmd->init_task_tag, begrun);\r\nreturn -1;\r\n}\r\nseq_send_order = first_seq->seq_send_order;\r\nseq->next_burst_len = seq->pdu_send_order = 0;\r\ngoto done;\r\n}\r\npr_err("Unable to locate struct iscsi_seq for ITT: 0x%08x,"\r\n" BegRun: 0x%08x, RunLength: 0x%08x while"\r\n" DataSequenceInOrder=No and DataPDUInOrder=%s.\n",\r\ncmd->init_task_tag, begrun, runlength,\r\n(conn->sess->sess_ops->DataPDUInOrder) ? "Yes" : "No");\r\nreturn -1;\r\n}\r\ndone:\r\ndr->read_data_done = read_data_done;\r\ndr->seq_send_order = seq_send_order;\r\nreturn 0;\r\n}\r\nstatic int iscsit_handle_recovery_datain(\r\nstruct iscsi_cmd *cmd,\r\nunsigned char *buf,\r\nu32 begrun,\r\nu32 runlength)\r\n{\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct iscsi_datain_req *dr;\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nif (!(se_cmd->transport_state & CMD_T_COMPLETE)) {\r\npr_err("Ignoring ITT: 0x%08x Data SNACK\n",\r\ncmd->init_task_tag);\r\nreturn 0;\r\n}\r\nif ((cmd->cmd_flags & ICF_GOT_DATACK_SNACK) &&\r\n(begrun <= cmd->acked_data_sn)) {\r\npr_err("ITT: 0x%08x, Data SNACK requesting"\r\n" retransmission of DataSN: 0x%08x to 0x%08x but"\r\n" already acked to DataSN: 0x%08x by Data ACK SNACK,"\r\n" protocol error.\n", cmd->init_task_tag, begrun,\r\n(begrun + runlength), cmd->acked_data_sn);\r\nreturn iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR, buf);\r\n}\r\nif ((begrun + runlength) > (cmd->data_sn - 1)) {\r\npr_err("Initiator requesting BegRun: 0x%08x, RunLength"\r\n": 0x%08x greater than maximum DataSN: 0x%08x.\n",\r\nbegrun, runlength, (cmd->data_sn - 1));\r\nreturn iscsit_reject_cmd(cmd, ISCSI_REASON_BOOKMARK_INVALID,\r\nbuf);\r\n}\r\ndr = iscsit_allocate_datain_req();\r\nif (!dr)\r\nreturn iscsit_reject_cmd(cmd, ISCSI_REASON_BOOKMARK_NO_RESOURCES,\r\nbuf);\r\ndr->data_sn = dr->begrun = begrun;\r\ndr->runlength = runlength;\r\ndr->generate_recovery_values = 1;\r\ndr->recovery = DATAIN_WITHIN_COMMAND_RECOVERY;\r\niscsit_attach_datain_req(cmd, dr);\r\ncmd->i_state = ISTATE_SEND_DATAIN;\r\niscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\r\nreturn 0;\r\n}\r\nint iscsit_handle_recovery_datain_or_r2t(\r\nstruct iscsi_conn *conn,\r\nunsigned char *buf,\r\nitt_t init_task_tag,\r\nu32 targ_xfer_tag,\r\nu32 begrun,\r\nu32 runlength)\r\n{\r\nstruct iscsi_cmd *cmd;\r\ncmd = iscsit_find_cmd_from_itt(conn, init_task_tag);\r\nif (!cmd)\r\nreturn 0;\r\nswitch (cmd->data_direction) {\r\ncase DMA_TO_DEVICE:\r\nreturn iscsit_handle_r2t_snack(cmd, buf, begrun, runlength);\r\ncase DMA_FROM_DEVICE:\r\nreturn iscsit_handle_recovery_datain(cmd, buf, begrun,\r\nrunlength);\r\ndefault:\r\npr_err("Unknown cmd->data_direction: 0x%02x\n",\r\ncmd->data_direction);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint iscsit_handle_status_snack(\r\nstruct iscsi_conn *conn,\r\nitt_t init_task_tag,\r\nu32 targ_xfer_tag,\r\nu32 begrun,\r\nu32 runlength)\r\n{\r\nstruct iscsi_cmd *cmd = NULL;\r\nu32 last_statsn;\r\nint found_cmd;\r\nif (!begrun) {\r\nbegrun = conn->exp_statsn;\r\n} else if (conn->exp_statsn > begrun) {\r\npr_err("Got Status SNACK Begrun: 0x%08x, RunLength:"\r\n" 0x%08x but already got ExpStatSN: 0x%08x on CID:"\r\n" %hu.\n", begrun, runlength, conn->exp_statsn,\r\nconn->cid);\r\nreturn 0;\r\n}\r\nlast_statsn = (!runlength) ? conn->stat_sn : (begrun + runlength);\r\nwhile (begrun < last_statsn) {\r\nfound_cmd = 0;\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_for_each_entry(cmd, &conn->conn_cmd_list, i_conn_node) {\r\nif (cmd->stat_sn == begrun) {\r\nfound_cmd = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&conn->cmd_lock);\r\nif (!found_cmd) {\r\npr_err("Unable to find StatSN: 0x%08x for"\r\n" a Status SNACK, assuming this was a"\r\n" protactic SNACK for an untransmitted"\r\n" StatSN, ignoring.\n", begrun);\r\nbegrun++;\r\ncontinue;\r\n}\r\nspin_lock_bh(&cmd->istate_lock);\r\nif (cmd->i_state == ISTATE_SEND_DATAIN) {\r\nspin_unlock_bh(&cmd->istate_lock);\r\npr_err("Ignoring Status SNACK for BegRun:"\r\n" 0x%08x, RunLength: 0x%08x, assuming this was"\r\n" a protactic SNACK for an untransmitted"\r\n" StatSN\n", begrun, runlength);\r\nbegrun++;\r\ncontinue;\r\n}\r\nspin_unlock_bh(&cmd->istate_lock);\r\ncmd->i_state = ISTATE_SEND_STATUS_RECOVERY;\r\niscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\r\nbegrun++;\r\n}\r\nreturn 0;\r\n}\r\nint iscsit_handle_data_ack(\r\nstruct iscsi_conn *conn,\r\nu32 targ_xfer_tag,\r\nu32 begrun,\r\nu32 runlength)\r\n{\r\nstruct iscsi_cmd *cmd = NULL;\r\ncmd = iscsit_find_cmd_from_ttt(conn, targ_xfer_tag);\r\nif (!cmd) {\r\npr_err("Data ACK SNACK for TTT: 0x%08x is"\r\n" invalid.\n", targ_xfer_tag);\r\nreturn -1;\r\n}\r\nif (begrun <= cmd->acked_data_sn) {\r\npr_err("ITT: 0x%08x Data ACK SNACK BegRUN: 0x%08x is"\r\n" less than the already acked DataSN: 0x%08x.\n",\r\ncmd->init_task_tag, begrun, cmd->acked_data_sn);\r\nreturn -1;\r\n}\r\ncmd->cmd_flags |= ICF_GOT_DATACK_SNACK;\r\ncmd->acked_data_sn = (begrun - 1);\r\npr_debug("Received Data ACK SNACK for ITT: 0x%08x,"\r\n" updated acked DataSN to 0x%08x.\n",\r\ncmd->init_task_tag, cmd->acked_data_sn);\r\nreturn 0;\r\n}\r\nstatic int iscsit_send_recovery_r2t(\r\nstruct iscsi_cmd *cmd,\r\nu32 offset,\r\nu32 xfer_len)\r\n{\r\nint ret;\r\nspin_lock_bh(&cmd->r2t_lock);\r\nret = iscsit_add_r2t_to_list(cmd, offset, xfer_len, 1, 0);\r\nspin_unlock_bh(&cmd->r2t_lock);\r\nreturn ret;\r\n}\r\nint iscsit_dataout_datapduinorder_no_fbit(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_pdu *pdu)\r\n{\r\nint i, send_recovery_r2t = 0, recovery = 0;\r\nu32 length = 0, offset = 0, pdu_count = 0, xfer_len = 0;\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct iscsi_pdu *first_pdu = NULL;\r\nif (conn->sess->sess_ops->DataSequenceInOrder) {\r\nfor (i = 0; i < cmd->pdu_count; i++) {\r\nif (cmd->pdu_list[i].seq_no == pdu->seq_no) {\r\nif (!first_pdu)\r\nfirst_pdu = &cmd->pdu_list[i];\r\nxfer_len += cmd->pdu_list[i].length;\r\npdu_count++;\r\n} else if (pdu_count)\r\nbreak;\r\n}\r\n} else {\r\nstruct iscsi_seq *seq = cmd->seq_ptr;\r\nfirst_pdu = &cmd->pdu_list[seq->pdu_start];\r\npdu_count = seq->pdu_count;\r\n}\r\nif (!first_pdu || !pdu_count)\r\nreturn DATAOUT_CANNOT_RECOVER;\r\nfor (i = 0; i < pdu_count; i++) {\r\nif (first_pdu[i].status == ISCSI_PDU_RECEIVED_OK) {\r\nif (!send_recovery_r2t)\r\ncontinue;\r\nif (iscsit_send_recovery_r2t(cmd, offset, length) < 0)\r\nreturn DATAOUT_CANNOT_RECOVER;\r\nsend_recovery_r2t = length = offset = 0;\r\ncontinue;\r\n}\r\nrecovery = 1;\r\nif (first_pdu[i].status != ISCSI_PDU_NOT_RECEIVED)\r\ncontinue;\r\nif (!offset)\r\noffset = first_pdu[i].offset;\r\nlength += first_pdu[i].length;\r\nsend_recovery_r2t = 1;\r\n}\r\nif (send_recovery_r2t)\r\nif (iscsit_send_recovery_r2t(cmd, offset, length) < 0)\r\nreturn DATAOUT_CANNOT_RECOVER;\r\nreturn (!recovery) ? DATAOUT_NORMAL : DATAOUT_WITHIN_COMMAND_RECOVERY;\r\n}\r\nstatic int iscsit_recalculate_dataout_values(\r\nstruct iscsi_cmd *cmd,\r\nu32 pdu_offset,\r\nu32 pdu_length,\r\nu32 *r2t_offset,\r\nu32 *r2t_length)\r\n{\r\nint i;\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct iscsi_pdu *pdu = NULL;\r\nif (conn->sess->sess_ops->DataSequenceInOrder) {\r\ncmd->data_sn = 0;\r\nif (conn->sess->sess_ops->DataPDUInOrder) {\r\n*r2t_offset = cmd->write_data_done;\r\n*r2t_length = (cmd->seq_end_offset -\r\ncmd->write_data_done);\r\nreturn 0;\r\n}\r\n*r2t_offset = cmd->seq_start_offset;\r\n*r2t_length = (cmd->seq_end_offset - cmd->seq_start_offset);\r\nfor (i = 0; i < cmd->pdu_count; i++) {\r\npdu = &cmd->pdu_list[i];\r\nif (pdu->status != ISCSI_PDU_RECEIVED_OK)\r\ncontinue;\r\nif ((pdu->offset >= cmd->seq_start_offset) &&\r\n((pdu->offset + pdu->length) <=\r\ncmd->seq_end_offset)) {\r\nif (!cmd->unsolicited_data)\r\ncmd->next_burst_len -= pdu->length;\r\nelse\r\ncmd->first_burst_len -= pdu->length;\r\ncmd->write_data_done -= pdu->length;\r\npdu->status = ISCSI_PDU_NOT_RECEIVED;\r\n}\r\n}\r\n} else {\r\nstruct iscsi_seq *seq = NULL;\r\nseq = iscsit_get_seq_holder(cmd, pdu_offset, pdu_length);\r\nif (!seq)\r\nreturn -1;\r\n*r2t_offset = seq->orig_offset;\r\n*r2t_length = seq->xfer_len;\r\ncmd->write_data_done -= (seq->offset - seq->orig_offset);\r\nif (cmd->immediate_data)\r\ncmd->first_burst_len = cmd->write_data_done;\r\nseq->data_sn = 0;\r\nseq->offset = seq->orig_offset;\r\nseq->next_burst_len = 0;\r\nseq->status = DATAOUT_SEQUENCE_WITHIN_COMMAND_RECOVERY;\r\nif (conn->sess->sess_ops->DataPDUInOrder)\r\nreturn 0;\r\nfor (i = 0; i < seq->pdu_count; i++) {\r\npdu = &cmd->pdu_list[i+seq->pdu_start];\r\nif (pdu->status != ISCSI_PDU_RECEIVED_OK)\r\ncontinue;\r\npdu->status = ISCSI_PDU_NOT_RECEIVED;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint iscsit_recover_dataout_sequence(\r\nstruct iscsi_cmd *cmd,\r\nu32 pdu_offset,\r\nu32 pdu_length)\r\n{\r\nu32 r2t_length = 0, r2t_offset = 0;\r\nspin_lock_bh(&cmd->istate_lock);\r\ncmd->cmd_flags |= ICF_WITHIN_COMMAND_RECOVERY;\r\nspin_unlock_bh(&cmd->istate_lock);\r\nif (iscsit_recalculate_dataout_values(cmd, pdu_offset, pdu_length,\r\n&r2t_offset, &r2t_length) < 0)\r\nreturn DATAOUT_CANNOT_RECOVER;\r\niscsit_send_recovery_r2t(cmd, r2t_offset, r2t_length);\r\nreturn DATAOUT_WITHIN_COMMAND_RECOVERY;\r\n}\r\nstatic struct iscsi_ooo_cmdsn *iscsit_allocate_ooo_cmdsn(void)\r\n{\r\nstruct iscsi_ooo_cmdsn *ooo_cmdsn = NULL;\r\nooo_cmdsn = kmem_cache_zalloc(lio_ooo_cache, GFP_ATOMIC);\r\nif (!ooo_cmdsn) {\r\npr_err("Unable to allocate memory for"\r\n" struct iscsi_ooo_cmdsn.\n");\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&ooo_cmdsn->ooo_list);\r\nreturn ooo_cmdsn;\r\n}\r\nstatic int iscsit_attach_ooo_cmdsn(\r\nstruct iscsi_session *sess,\r\nstruct iscsi_ooo_cmdsn *ooo_cmdsn)\r\n{\r\nstruct iscsi_ooo_cmdsn *ooo_tail, *ooo_tmp;\r\nif (list_empty(&sess->sess_ooo_cmdsn_list))\r\nlist_add_tail(&ooo_cmdsn->ooo_list,\r\n&sess->sess_ooo_cmdsn_list);\r\nelse {\r\nooo_tail = list_entry(sess->sess_ooo_cmdsn_list.prev,\r\ntypeof(*ooo_tail), ooo_list);\r\nif (iscsi_sna_lt(ooo_tail->cmdsn, ooo_cmdsn->cmdsn))\r\nlist_add_tail(&ooo_cmdsn->ooo_list,\r\n&sess->sess_ooo_cmdsn_list);\r\nelse {\r\nlist_for_each_entry(ooo_tmp, &sess->sess_ooo_cmdsn_list,\r\nooo_list) {\r\nif (iscsi_sna_lt(ooo_tmp->cmdsn, ooo_cmdsn->cmdsn))\r\ncontinue;\r\nlist_add(&ooo_cmdsn->ooo_list,\r\nooo_tmp->ooo_list.prev);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid iscsit_remove_ooo_cmdsn(\r\nstruct iscsi_session *sess,\r\nstruct iscsi_ooo_cmdsn *ooo_cmdsn)\r\n{\r\nlist_del(&ooo_cmdsn->ooo_list);\r\nkmem_cache_free(lio_ooo_cache, ooo_cmdsn);\r\n}\r\nvoid iscsit_clear_ooo_cmdsns_for_conn(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_ooo_cmdsn *ooo_cmdsn;\r\nstruct iscsi_session *sess = conn->sess;\r\nmutex_lock(&sess->cmdsn_mutex);\r\nlist_for_each_entry(ooo_cmdsn, &sess->sess_ooo_cmdsn_list, ooo_list) {\r\nif (ooo_cmdsn->cid != conn->cid)\r\ncontinue;\r\nooo_cmdsn->cmd = NULL;\r\n}\r\nmutex_unlock(&sess->cmdsn_mutex);\r\n}\r\nint iscsit_execute_ooo_cmdsns(struct iscsi_session *sess)\r\n{\r\nint ooo_count = 0;\r\nstruct iscsi_cmd *cmd = NULL;\r\nstruct iscsi_ooo_cmdsn *ooo_cmdsn, *ooo_cmdsn_tmp;\r\nlist_for_each_entry_safe(ooo_cmdsn, ooo_cmdsn_tmp,\r\n&sess->sess_ooo_cmdsn_list, ooo_list) {\r\nif (ooo_cmdsn->cmdsn != sess->exp_cmd_sn)\r\ncontinue;\r\nif (!ooo_cmdsn->cmd) {\r\nsess->exp_cmd_sn++;\r\niscsit_remove_ooo_cmdsn(sess, ooo_cmdsn);\r\ncontinue;\r\n}\r\ncmd = ooo_cmdsn->cmd;\r\ncmd->i_state = cmd->deferred_i_state;\r\nooo_count++;\r\nsess->exp_cmd_sn++;\r\npr_debug("Executing out of order CmdSN: 0x%08x,"\r\n" incremented ExpCmdSN to 0x%08x.\n",\r\ncmd->cmd_sn, sess->exp_cmd_sn);\r\niscsit_remove_ooo_cmdsn(sess, ooo_cmdsn);\r\nif (iscsit_execute_cmd(cmd, 1) < 0)\r\nreturn -1;\r\ncontinue;\r\n}\r\nreturn ooo_count;\r\n}\r\nint iscsit_execute_cmd(struct iscsi_cmd *cmd, int ooo)\r\n{\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct iscsi_conn *conn = cmd->conn;\r\nint lr = 0;\r\nspin_lock_bh(&cmd->istate_lock);\r\nif (ooo)\r\ncmd->cmd_flags &= ~ICF_OOO_CMDSN;\r\nswitch (cmd->iscsi_opcode) {\r\ncase ISCSI_OP_SCSI_CMD:\r\nif (cmd->sense_reason) {\r\nif (cmd->sense_reason == TCM_RESERVATION_CONFLICT) {\r\ncmd->i_state = ISTATE_SEND_STATUS;\r\nspin_unlock_bh(&cmd->istate_lock);\r\niscsit_add_cmd_to_response_queue(cmd, cmd->conn,\r\ncmd->i_state);\r\nreturn 0;\r\n}\r\nspin_unlock_bh(&cmd->istate_lock);\r\nif (transport_check_aborted_status(se_cmd,\r\n(cmd->unsolicited_data == 0)) != 0)\r\nreturn 0;\r\nreturn transport_send_check_condition_and_sense(se_cmd,\r\ncmd->sense_reason, 0);\r\n}\r\nif (cmd->immediate_data) {\r\nif (cmd->cmd_flags & ICF_GOT_LAST_DATAOUT) {\r\nspin_unlock_bh(&cmd->istate_lock);\r\ntarget_execute_cmd(&cmd->se_cmd);\r\nreturn 0;\r\n}\r\nspin_unlock_bh(&cmd->istate_lock);\r\nif (!(cmd->cmd_flags &\r\nICF_NON_IMMEDIATE_UNSOLICITED_DATA)) {\r\nif (transport_check_aborted_status(se_cmd, 1)\r\n!= 0)\r\nreturn 0;\r\niscsit_set_dataout_sequence_values(cmd);\r\nconn->conn_transport->iscsit_get_dataout(conn, cmd, false);\r\n}\r\nreturn 0;\r\n}\r\nspin_unlock_bh(&cmd->istate_lock);\r\nif ((cmd->data_direction == DMA_TO_DEVICE) &&\r\n!(cmd->cmd_flags & ICF_NON_IMMEDIATE_UNSOLICITED_DATA)) {\r\nif (transport_check_aborted_status(se_cmd, 1) != 0)\r\nreturn 0;\r\niscsit_set_unsoliticed_dataout(cmd);\r\n}\r\nreturn transport_handle_cdb_direct(&cmd->se_cmd);\r\ncase ISCSI_OP_NOOP_OUT:\r\ncase ISCSI_OP_TEXT:\r\nspin_unlock_bh(&cmd->istate_lock);\r\niscsit_add_cmd_to_response_queue(cmd, cmd->conn, cmd->i_state);\r\nbreak;\r\ncase ISCSI_OP_SCSI_TMFUNC:\r\nif (cmd->se_cmd.se_tmr_req->response) {\r\nspin_unlock_bh(&cmd->istate_lock);\r\niscsit_add_cmd_to_response_queue(cmd, cmd->conn,\r\ncmd->i_state);\r\nreturn 0;\r\n}\r\nspin_unlock_bh(&cmd->istate_lock);\r\nreturn transport_generic_handle_tmr(&cmd->se_cmd);\r\ncase ISCSI_OP_LOGOUT:\r\nspin_unlock_bh(&cmd->istate_lock);\r\nswitch (cmd->logout_reason) {\r\ncase ISCSI_LOGOUT_REASON_CLOSE_SESSION:\r\nlr = iscsit_logout_closesession(cmd, cmd->conn);\r\nbreak;\r\ncase ISCSI_LOGOUT_REASON_CLOSE_CONNECTION:\r\nlr = iscsit_logout_closeconnection(cmd, cmd->conn);\r\nbreak;\r\ncase ISCSI_LOGOUT_REASON_RECOVERY:\r\nlr = iscsit_logout_removeconnforrecovery(cmd, cmd->conn);\r\nbreak;\r\ndefault:\r\npr_err("Unknown iSCSI Logout Request Code:"\r\n" 0x%02x\n", cmd->logout_reason);\r\nreturn -1;\r\n}\r\nreturn lr;\r\ndefault:\r\nspin_unlock_bh(&cmd->istate_lock);\r\npr_err("Cannot perform out of order execution for"\r\n" unknown iSCSI Opcode: 0x%02x\n", cmd->iscsi_opcode);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid iscsit_free_all_ooo_cmdsns(struct iscsi_session *sess)\r\n{\r\nstruct iscsi_ooo_cmdsn *ooo_cmdsn, *ooo_cmdsn_tmp;\r\nmutex_lock(&sess->cmdsn_mutex);\r\nlist_for_each_entry_safe(ooo_cmdsn, ooo_cmdsn_tmp,\r\n&sess->sess_ooo_cmdsn_list, ooo_list) {\r\nlist_del(&ooo_cmdsn->ooo_list);\r\nkmem_cache_free(lio_ooo_cache, ooo_cmdsn);\r\n}\r\nmutex_unlock(&sess->cmdsn_mutex);\r\n}\r\nint iscsit_handle_ooo_cmdsn(\r\nstruct iscsi_session *sess,\r\nstruct iscsi_cmd *cmd,\r\nu32 cmdsn)\r\n{\r\nint batch = 0;\r\nstruct iscsi_ooo_cmdsn *ooo_cmdsn = NULL, *ooo_tail = NULL;\r\ncmd->deferred_i_state = cmd->i_state;\r\ncmd->i_state = ISTATE_DEFERRED_CMD;\r\ncmd->cmd_flags |= ICF_OOO_CMDSN;\r\nif (list_empty(&sess->sess_ooo_cmdsn_list))\r\nbatch = 1;\r\nelse {\r\nooo_tail = list_entry(sess->sess_ooo_cmdsn_list.prev,\r\ntypeof(*ooo_tail), ooo_list);\r\nif (ooo_tail->cmdsn != (cmdsn - 1))\r\nbatch = 1;\r\n}\r\nooo_cmdsn = iscsit_allocate_ooo_cmdsn();\r\nif (!ooo_cmdsn)\r\nreturn -ENOMEM;\r\nooo_cmdsn->cmd = cmd;\r\nooo_cmdsn->batch_count = (batch) ?\r\n(cmdsn - sess->exp_cmd_sn) : 1;\r\nooo_cmdsn->cid = cmd->conn->cid;\r\nooo_cmdsn->exp_cmdsn = sess->exp_cmd_sn;\r\nooo_cmdsn->cmdsn = cmdsn;\r\nif (iscsit_attach_ooo_cmdsn(sess, ooo_cmdsn) < 0) {\r\nkmem_cache_free(lio_ooo_cache, ooo_cmdsn);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsit_set_dataout_timeout_values(\r\nstruct iscsi_cmd *cmd,\r\nu32 *offset,\r\nu32 *length)\r\n{\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct iscsi_r2t *r2t;\r\nif (cmd->unsolicited_data) {\r\n*offset = 0;\r\n*length = (conn->sess->sess_ops->FirstBurstLength >\r\ncmd->se_cmd.data_length) ?\r\ncmd->se_cmd.data_length :\r\nconn->sess->sess_ops->FirstBurstLength;\r\nreturn 0;\r\n}\r\nspin_lock_bh(&cmd->r2t_lock);\r\nif (list_empty(&cmd->cmd_r2t_list)) {\r\npr_err("cmd->cmd_r2t_list is empty!\n");\r\nspin_unlock_bh(&cmd->r2t_lock);\r\nreturn -1;\r\n}\r\nlist_for_each_entry(r2t, &cmd->cmd_r2t_list, r2t_list) {\r\nif (r2t->sent_r2t && !r2t->recovery_r2t && !r2t->seq_complete) {\r\n*offset = r2t->offset;\r\n*length = r2t->xfer_len;\r\nspin_unlock_bh(&cmd->r2t_lock);\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock_bh(&cmd->r2t_lock);\r\npr_err("Unable to locate any incomplete DataOUT"\r\n" sequences for ITT: 0x%08x.\n", cmd->init_task_tag);\r\nreturn -1;\r\n}\r\nstatic void iscsit_handle_dataout_timeout(unsigned long data)\r\n{\r\nu32 pdu_length = 0, pdu_offset = 0;\r\nu32 r2t_length = 0, r2t_offset = 0;\r\nstruct iscsi_cmd *cmd = (struct iscsi_cmd *) data;\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct iscsi_session *sess = NULL;\r\nstruct iscsi_node_attrib *na;\r\niscsit_inc_conn_usage_count(conn);\r\nspin_lock_bh(&cmd->dataout_timeout_lock);\r\nif (cmd->dataout_timer_flags & ISCSI_TF_STOP) {\r\nspin_unlock_bh(&cmd->dataout_timeout_lock);\r\niscsit_dec_conn_usage_count(conn);\r\nreturn;\r\n}\r\ncmd->dataout_timer_flags &= ~ISCSI_TF_RUNNING;\r\nsess = conn->sess;\r\nna = iscsit_tpg_get_node_attrib(sess);\r\nif (!sess->sess_ops->ErrorRecoveryLevel) {\r\npr_debug("Unable to recover from DataOut timeout while"\r\n" in ERL=0.\n");\r\ngoto failure;\r\n}\r\nif (++cmd->dataout_timeout_retries == na->dataout_timeout_retries) {\r\npr_debug("Command ITT: 0x%08x exceeded max retries"\r\n" for DataOUT timeout %u, closing iSCSI connection.\n",\r\ncmd->init_task_tag, na->dataout_timeout_retries);\r\ngoto failure;\r\n}\r\ncmd->cmd_flags |= ICF_WITHIN_COMMAND_RECOVERY;\r\nif (conn->sess->sess_ops->DataSequenceInOrder) {\r\nif (conn->sess->sess_ops->DataPDUInOrder) {\r\npdu_offset = cmd->write_data_done;\r\nif ((pdu_offset + (conn->sess->sess_ops->MaxBurstLength -\r\ncmd->next_burst_len)) > cmd->se_cmd.data_length)\r\npdu_length = (cmd->se_cmd.data_length -\r\ncmd->write_data_done);\r\nelse\r\npdu_length = (conn->sess->sess_ops->MaxBurstLength -\r\ncmd->next_burst_len);\r\n} else {\r\npdu_offset = cmd->seq_start_offset;\r\npdu_length = (cmd->seq_end_offset -\r\ncmd->seq_start_offset);\r\n}\r\n} else {\r\nif (iscsit_set_dataout_timeout_values(cmd, &pdu_offset,\r\n&pdu_length) < 0)\r\ngoto failure;\r\n}\r\nif (iscsit_recalculate_dataout_values(cmd, pdu_offset, pdu_length,\r\n&r2t_offset, &r2t_length) < 0)\r\ngoto failure;\r\npr_debug("Command ITT: 0x%08x timed out waiting for"\r\n" completion of %sDataOUT Sequence Offset: %u, Length: %u\n",\r\ncmd->init_task_tag, (cmd->unsolicited_data) ? "Unsolicited " :\r\n"", r2t_offset, r2t_length);\r\nif (iscsit_send_recovery_r2t(cmd, r2t_offset, r2t_length) < 0)\r\ngoto failure;\r\niscsit_start_dataout_timer(cmd, conn);\r\nspin_unlock_bh(&cmd->dataout_timeout_lock);\r\niscsit_dec_conn_usage_count(conn);\r\nreturn;\r\nfailure:\r\nspin_unlock_bh(&cmd->dataout_timeout_lock);\r\niscsit_cause_connection_reinstatement(conn, 0);\r\niscsit_dec_conn_usage_count(conn);\r\n}\r\nvoid iscsit_mod_dataout_timer(struct iscsi_cmd *cmd)\r\n{\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct iscsi_session *sess = conn->sess;\r\nstruct iscsi_node_attrib *na = iscsit_tpg_get_node_attrib(sess);\r\nspin_lock_bh(&cmd->dataout_timeout_lock);\r\nif (!(cmd->dataout_timer_flags & ISCSI_TF_RUNNING)) {\r\nspin_unlock_bh(&cmd->dataout_timeout_lock);\r\nreturn;\r\n}\r\nmod_timer(&cmd->dataout_timer,\r\n(get_jiffies_64() + na->dataout_timeout * HZ));\r\npr_debug("Updated DataOUT timer for ITT: 0x%08x",\r\ncmd->init_task_tag);\r\nspin_unlock_bh(&cmd->dataout_timeout_lock);\r\n}\r\nvoid iscsit_start_dataout_timer(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_conn *conn)\r\n{\r\nstruct iscsi_session *sess = conn->sess;\r\nstruct iscsi_node_attrib *na = iscsit_tpg_get_node_attrib(sess);\r\nif (cmd->dataout_timer_flags & ISCSI_TF_RUNNING)\r\nreturn;\r\npr_debug("Starting DataOUT timer for ITT: 0x%08x on"\r\n" CID: %hu.\n", cmd->init_task_tag, conn->cid);\r\ninit_timer(&cmd->dataout_timer);\r\ncmd->dataout_timer.expires = (get_jiffies_64() + na->dataout_timeout * HZ);\r\ncmd->dataout_timer.data = (unsigned long)cmd;\r\ncmd->dataout_timer.function = iscsit_handle_dataout_timeout;\r\ncmd->dataout_timer_flags &= ~ISCSI_TF_STOP;\r\ncmd->dataout_timer_flags |= ISCSI_TF_RUNNING;\r\nadd_timer(&cmd->dataout_timer);\r\n}\r\nvoid iscsit_stop_dataout_timer(struct iscsi_cmd *cmd)\r\n{\r\nspin_lock_bh(&cmd->dataout_timeout_lock);\r\nif (!(cmd->dataout_timer_flags & ISCSI_TF_RUNNING)) {\r\nspin_unlock_bh(&cmd->dataout_timeout_lock);\r\nreturn;\r\n}\r\ncmd->dataout_timer_flags |= ISCSI_TF_STOP;\r\nspin_unlock_bh(&cmd->dataout_timeout_lock);\r\ndel_timer_sync(&cmd->dataout_timer);\r\nspin_lock_bh(&cmd->dataout_timeout_lock);\r\ncmd->dataout_timer_flags &= ~ISCSI_TF_RUNNING;\r\npr_debug("Stopped DataOUT Timer for ITT: 0x%08x\n",\r\ncmd->init_task_tag);\r\nspin_unlock_bh(&cmd->dataout_timeout_lock);\r\n}
