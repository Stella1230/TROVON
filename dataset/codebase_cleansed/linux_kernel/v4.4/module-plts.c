static bool in_init(const struct module *mod, u32 addr)\r\n{\r\nreturn addr - (u32)mod->module_init < mod->init_size;\r\n}\r\nu32 get_module_plt(struct module *mod, unsigned long loc, Elf32_Addr val)\r\n{\r\nstruct plt_entries *plt, *plt_end;\r\nint c, *count;\r\nif (in_init(mod, loc)) {\r\nplt = (void *)mod->arch.init_plt->sh_addr;\r\nplt_end = (void *)plt + mod->arch.init_plt->sh_size;\r\ncount = &mod->arch.init_plt_count;\r\n} else {\r\nplt = (void *)mod->arch.core_plt->sh_addr;\r\nplt_end = (void *)plt + mod->arch.core_plt->sh_size;\r\ncount = &mod->arch.core_plt_count;\r\n}\r\nfor (c = *count; plt < plt_end; c -= PLT_ENT_COUNT, plt++) {\r\nint i;\r\nif (!c) {\r\n*plt = (struct plt_entries){\r\n{ [0 ... PLT_ENT_COUNT - 1] = PLT_ENT_LDR, },\r\n{ val, }\r\n};\r\n++*count;\r\nreturn (u32)plt->ldr;\r\n}\r\nfor (i = 0; i < PLT_ENT_COUNT; i++) {\r\nif (!plt->lit[i]) {\r\nplt->lit[i] = val;\r\n++*count;\r\n}\r\nif (plt->lit[i] == val)\r\nreturn (u32)&plt->ldr[i];\r\n}\r\n}\r\nBUG();\r\n}\r\nstatic int duplicate_rel(Elf32_Addr base, const Elf32_Rel *rel, int num,\r\nu32 mask)\r\n{\r\nu32 *loc1, *loc2;\r\nint i;\r\nfor (i = 0; i < num; i++) {\r\nif (rel[i].r_info != rel[num].r_info)\r\ncontinue;\r\nloc1 = (u32 *)(base + rel[i].r_offset);\r\nloc2 = (u32 *)(base + rel[num].r_offset);\r\nif (((*loc1 ^ *loc2) & mask) == 0)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int count_plts(Elf32_Addr base, const Elf32_Rel *rel, int num)\r\n{\r\nunsigned int ret = 0;\r\nint i;\r\nfor (i = 0; i < num; i++)\r\nswitch (ELF32_R_TYPE(rel[i].r_info)) {\r\ncase R_ARM_CALL:\r\ncase R_ARM_PC24:\r\ncase R_ARM_JUMP24:\r\nif (!duplicate_rel(base, rel, i,\r\n__opcode_to_mem_arm(0x00ffffff)))\r\nret++;\r\nbreak;\r\n#ifdef CONFIG_THUMB2_KERNEL\r\ncase R_ARM_THM_CALL:\r\ncase R_ARM_THM_JUMP24:\r\nif (!duplicate_rel(base, rel, i,\r\n__opcode_to_mem_thumb32(0x07ff2fff)))\r\nret++;\r\n#endif\r\n}\r\nreturn ret;\r\n}\r\nint module_frob_arch_sections(Elf_Ehdr *ehdr, Elf_Shdr *sechdrs,\r\nchar *secstrings, struct module *mod)\r\n{\r\nunsigned long core_plts = 0, init_plts = 0;\r\nElf32_Shdr *s, *sechdrs_end = sechdrs + ehdr->e_shnum;\r\nfor (s = sechdrs; s < sechdrs_end; ++s)\r\nif (strcmp(".core.plt", secstrings + s->sh_name) == 0)\r\nmod->arch.core_plt = s;\r\nelse if (strcmp(".init.plt", secstrings + s->sh_name) == 0)\r\nmod->arch.init_plt = s;\r\nif (!mod->arch.core_plt || !mod->arch.init_plt) {\r\npr_err("%s: sections missing\n", mod->name);\r\nreturn -ENOEXEC;\r\n}\r\nfor (s = sechdrs + 1; s < sechdrs_end; ++s) {\r\nconst Elf32_Rel *rels = (void *)ehdr + s->sh_offset;\r\nint numrels = s->sh_size / sizeof(Elf32_Rel);\r\nElf32_Shdr *dstsec = sechdrs + s->sh_info;\r\nif (s->sh_type != SHT_REL)\r\ncontinue;\r\nif (strstr(secstrings + s->sh_name, ".init"))\r\ninit_plts += count_plts(dstsec->sh_addr, rels, numrels);\r\nelse\r\ncore_plts += count_plts(dstsec->sh_addr, rels, numrels);\r\n}\r\nmod->arch.core_plt->sh_type = SHT_NOBITS;\r\nmod->arch.core_plt->sh_flags = SHF_EXECINSTR | SHF_ALLOC;\r\nmod->arch.core_plt->sh_addralign = L1_CACHE_BYTES;\r\nmod->arch.core_plt->sh_size = round_up(core_plts * PLT_ENT_SIZE,\r\nsizeof(struct plt_entries));\r\nmod->arch.core_plt_count = 0;\r\nmod->arch.init_plt->sh_type = SHT_NOBITS;\r\nmod->arch.init_plt->sh_flags = SHF_EXECINSTR | SHF_ALLOC;\r\nmod->arch.init_plt->sh_addralign = L1_CACHE_BYTES;\r\nmod->arch.init_plt->sh_size = round_up(init_plts * PLT_ENT_SIZE,\r\nsizeof(struct plt_entries));\r\nmod->arch.init_plt_count = 0;\r\npr_debug("%s: core.plt=%x, init.plt=%x\n", __func__,\r\nmod->arch.core_plt->sh_size, mod->arch.init_plt->sh_size);\r\nreturn 0;\r\n}
