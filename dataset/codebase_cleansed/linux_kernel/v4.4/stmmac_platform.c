static int dwmac1000_validate_mcast_bins(int mcast_bins)\r\n{\r\nint x = mcast_bins;\r\nswitch (x) {\r\ncase HASH_TABLE_SIZE:\r\ncase 128:\r\ncase 256:\r\nbreak;\r\ndefault:\r\nx = 0;\r\npr_info("Hash table entries set to unexpected value %d",\r\nmcast_bins);\r\nbreak;\r\n}\r\nreturn x;\r\n}\r\nstatic int dwmac1000_validate_ucast_entries(int ucast_entries)\r\n{\r\nint x = ucast_entries;\r\nswitch (x) {\r\ncase 1:\r\ncase 32:\r\ncase 64:\r\ncase 128:\r\nbreak;\r\ndefault:\r\nx = 1;\r\npr_info("Unicast table entries set to unexpected value %d\n",\r\nucast_entries);\r\nbreak;\r\n}\r\nreturn x;\r\n}\r\nstruct plat_stmmacenet_data *\r\nstmmac_probe_config_dt(struct platform_device *pdev, const char **mac)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct plat_stmmacenet_data *plat;\r\nstruct stmmac_dma_cfg *dma_cfg;\r\nplat = devm_kzalloc(&pdev->dev, sizeof(*plat), GFP_KERNEL);\r\nif (!plat)\r\nreturn ERR_PTR(-ENOMEM);\r\n*mac = of_get_mac_address(np);\r\nplat->interface = of_get_phy_mode(np);\r\nif (of_property_read_u32(np, "max-speed", &plat->max_speed))\r\nplat->max_speed = -1;\r\nplat->bus_id = of_alias_get_id(np, "ethernet");\r\nif (plat->bus_id < 0)\r\nplat->bus_id = 0;\r\nplat->phy_addr = -1;\r\nplat->phy_node = of_parse_phandle(np, "phy-handle", 0);\r\nif (!plat->phy_node && of_phy_is_fixed_link(np)) {\r\nif ((of_phy_register_fixed_link(np) < 0))\r\nreturn ERR_PTR(-ENODEV);\r\nplat->phy_node = of_node_get(np);\r\n}\r\nif (of_property_read_u32(np, "snps,phy-addr", &plat->phy_addr) == 0)\r\ndev_warn(&pdev->dev, "snps,phy-addr property is deprecated\n");\r\nif (plat->phy_node || plat->phy_bus_name)\r\nplat->mdio_bus_data = NULL;\r\nelse\r\nplat->mdio_bus_data =\r\ndevm_kzalloc(&pdev->dev,\r\nsizeof(struct stmmac_mdio_bus_data),\r\nGFP_KERNEL);\r\nof_property_read_u32(np, "tx-fifo-depth", &plat->tx_fifo_size);\r\nof_property_read_u32(np, "rx-fifo-depth", &plat->rx_fifo_size);\r\nplat->force_sf_dma_mode =\r\nof_property_read_bool(np, "snps,force_sf_dma_mode");\r\nplat->maxmtu = JUMBO_LEN;\r\nplat->multicast_filter_bins = HASH_TABLE_SIZE;\r\nplat->unicast_filter_entries = 1;\r\nif (of_device_is_compatible(np, "st,spear600-gmac") ||\r\nof_device_is_compatible(np, "snps,dwmac-3.70a") ||\r\nof_device_is_compatible(np, "snps,dwmac")) {\r\nof_property_read_u32(np, "max-frame-size", &plat->maxmtu);\r\nof_property_read_u32(np, "snps,multicast-filter-bins",\r\n&plat->multicast_filter_bins);\r\nof_property_read_u32(np, "snps,perfect-filter-entries",\r\n&plat->unicast_filter_entries);\r\nplat->unicast_filter_entries = dwmac1000_validate_ucast_entries(\r\nplat->unicast_filter_entries);\r\nplat->multicast_filter_bins = dwmac1000_validate_mcast_bins(\r\nplat->multicast_filter_bins);\r\nplat->has_gmac = 1;\r\nplat->pmt = 1;\r\n}\r\nif (of_device_is_compatible(np, "snps,dwmac-3.610") ||\r\nof_device_is_compatible(np, "snps,dwmac-3.710")) {\r\nplat->enh_desc = 1;\r\nplat->bugged_jumbo = 1;\r\nplat->force_sf_dma_mode = 1;\r\n}\r\nif (of_find_property(np, "snps,pbl", NULL)) {\r\ndma_cfg = devm_kzalloc(&pdev->dev, sizeof(*dma_cfg),\r\nGFP_KERNEL);\r\nif (!dma_cfg) {\r\nof_node_put(np);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nplat->dma_cfg = dma_cfg;\r\nof_property_read_u32(np, "snps,pbl", &dma_cfg->pbl);\r\ndma_cfg->fixed_burst =\r\nof_property_read_bool(np, "snps,fixed-burst");\r\ndma_cfg->mixed_burst =\r\nof_property_read_bool(np, "snps,mixed-burst");\r\nof_property_read_u32(np, "snps,burst_len", &dma_cfg->burst_len);\r\nif (dma_cfg->burst_len < 0 || dma_cfg->burst_len > 256)\r\ndma_cfg->burst_len = 0;\r\n}\r\nplat->force_thresh_dma_mode = of_property_read_bool(np, "snps,force_thresh_dma_mode");\r\nif (plat->force_thresh_dma_mode) {\r\nplat->force_sf_dma_mode = 0;\r\npr_warn("force_sf_dma_mode is ignored if force_thresh_dma_mode is set.");\r\n}\r\nreturn plat;\r\n}\r\nstruct plat_stmmacenet_data *\r\nstmmac_probe_config_dt(struct platform_device *pdev, const char **mac)\r\n{\r\nreturn ERR_PTR(-ENOSYS);\r\n}\r\nint stmmac_get_platform_resources(struct platform_device *pdev,\r\nstruct stmmac_resources *stmmac_res)\r\n{\r\nstruct resource *res;\r\nmemset(stmmac_res, 0, sizeof(*stmmac_res));\r\nstmmac_res->irq = platform_get_irq_byname(pdev, "macirq");\r\nif (stmmac_res->irq < 0) {\r\nif (stmmac_res->irq != -EPROBE_DEFER) {\r\ndev_err(&pdev->dev,\r\n"MAC IRQ configuration information not found\n");\r\n}\r\nreturn stmmac_res->irq;\r\n}\r\nstmmac_res->wol_irq = platform_get_irq_byname(pdev, "eth_wake_irq");\r\nif (stmmac_res->wol_irq < 0) {\r\nif (stmmac_res->wol_irq == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nstmmac_res->wol_irq = stmmac_res->irq;\r\n}\r\nstmmac_res->lpi_irq = platform_get_irq_byname(pdev, "eth_lpi");\r\nif (stmmac_res->lpi_irq == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nstmmac_res->addr = devm_ioremap_resource(&pdev->dev, res);\r\nreturn PTR_ERR_OR_ZERO(stmmac_res->addr);\r\n}\r\nint stmmac_pltfr_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct stmmac_priv *priv = netdev_priv(ndev);\r\nint ret = stmmac_dvr_remove(ndev);\r\nif (priv->plat->exit)\r\npriv->plat->exit(pdev, priv->plat->bsp_priv);\r\nreturn ret;\r\n}\r\nstatic int stmmac_pltfr_suspend(struct device *dev)\r\n{\r\nint ret;\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nstruct stmmac_priv *priv = netdev_priv(ndev);\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nret = stmmac_suspend(ndev);\r\nif (priv->plat->exit)\r\npriv->plat->exit(pdev, priv->plat->bsp_priv);\r\nreturn ret;\r\n}\r\nstatic int stmmac_pltfr_resume(struct device *dev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nstruct stmmac_priv *priv = netdev_priv(ndev);\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nif (priv->plat->init)\r\npriv->plat->init(pdev, priv->plat->bsp_priv);\r\nreturn stmmac_resume(ndev);\r\n}
