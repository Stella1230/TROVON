static int amdgpu_cgs_gpu_mem_info(void *cgs_device, enum cgs_gpu_mem_type type,\r\nuint64_t *mc_start, uint64_t *mc_size,\r\nuint64_t *mem_size)\r\n{\r\nCGS_FUNC_ADEV;\r\nswitch(type) {\r\ncase CGS_GPU_MEM_TYPE__VISIBLE_CONTIG_FB:\r\ncase CGS_GPU_MEM_TYPE__VISIBLE_FB:\r\n*mc_start = 0;\r\n*mc_size = adev->mc.visible_vram_size;\r\n*mem_size = adev->mc.visible_vram_size - adev->vram_pin_size;\r\nbreak;\r\ncase CGS_GPU_MEM_TYPE__INVISIBLE_CONTIG_FB:\r\ncase CGS_GPU_MEM_TYPE__INVISIBLE_FB:\r\n*mc_start = adev->mc.visible_vram_size;\r\n*mc_size = adev->mc.real_vram_size - adev->mc.visible_vram_size;\r\n*mem_size = *mc_size;\r\nbreak;\r\ncase CGS_GPU_MEM_TYPE__GART_CACHEABLE:\r\ncase CGS_GPU_MEM_TYPE__GART_WRITECOMBINE:\r\n*mc_start = adev->mc.gtt_start;\r\n*mc_size = adev->mc.gtt_size;\r\n*mem_size = adev->mc.gtt_size - adev->gart_pin_size;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int amdgpu_cgs_gmap_kmem(void *cgs_device, void *kmem,\r\nuint64_t size,\r\nuint64_t min_offset, uint64_t max_offset,\r\ncgs_handle_t *kmem_handle, uint64_t *mcaddr)\r\n{\r\nCGS_FUNC_ADEV;\r\nint ret;\r\nstruct amdgpu_bo *bo;\r\nstruct page *kmem_page = vmalloc_to_page(kmem);\r\nint npages = ALIGN(size, PAGE_SIZE) >> PAGE_SHIFT;\r\nstruct sg_table *sg = drm_prime_pages_to_sg(&kmem_page, npages);\r\nret = amdgpu_bo_create(adev, size, PAGE_SIZE, false,\r\nAMDGPU_GEM_DOMAIN_GTT, 0, sg, NULL, &bo);\r\nif (ret)\r\nreturn ret;\r\nret = amdgpu_bo_reserve(bo, false);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nret = amdgpu_bo_pin_restricted(bo, AMDGPU_GEM_DOMAIN_GTT,\r\nmin_offset, max_offset, mcaddr);\r\namdgpu_bo_unreserve(bo);\r\n*kmem_handle = (cgs_handle_t)bo;\r\nreturn ret;\r\n}\r\nstatic int amdgpu_cgs_gunmap_kmem(void *cgs_device, cgs_handle_t kmem_handle)\r\n{\r\nstruct amdgpu_bo *obj = (struct amdgpu_bo *)kmem_handle;\r\nif (obj) {\r\nint r = amdgpu_bo_reserve(obj, false);\r\nif (likely(r == 0)) {\r\namdgpu_bo_unpin(obj);\r\namdgpu_bo_unreserve(obj);\r\n}\r\namdgpu_bo_unref(&obj);\r\n}\r\nreturn 0;\r\n}\r\nstatic int amdgpu_cgs_alloc_gpu_mem(void *cgs_device,\r\nenum cgs_gpu_mem_type type,\r\nuint64_t size, uint64_t align,\r\nuint64_t min_offset, uint64_t max_offset,\r\ncgs_handle_t *handle)\r\n{\r\nCGS_FUNC_ADEV;\r\nuint16_t flags = 0;\r\nint ret = 0;\r\nuint32_t domain = 0;\r\nstruct amdgpu_bo *obj;\r\nstruct ttm_placement placement;\r\nstruct ttm_place place;\r\nif (min_offset > max_offset) {\r\nBUG_ON(1);\r\nreturn -EINVAL;\r\n}\r\nif (((align != 1) && (align & (align - 1)))\r\n|| size == 0 || align == 0)\r\nreturn -EINVAL;\r\nswitch(type) {\r\ncase CGS_GPU_MEM_TYPE__VISIBLE_CONTIG_FB:\r\ncase CGS_GPU_MEM_TYPE__VISIBLE_FB:\r\nflags = AMDGPU_GEM_CREATE_CPU_ACCESS_REQUIRED;\r\ndomain = AMDGPU_GEM_DOMAIN_VRAM;\r\nif (max_offset > adev->mc.real_vram_size)\r\nreturn -EINVAL;\r\nplace.fpfn = min_offset >> PAGE_SHIFT;\r\nplace.lpfn = max_offset >> PAGE_SHIFT;\r\nplace.flags = TTM_PL_FLAG_WC | TTM_PL_FLAG_UNCACHED |\r\nTTM_PL_FLAG_VRAM;\r\nbreak;\r\ncase CGS_GPU_MEM_TYPE__INVISIBLE_CONTIG_FB:\r\ncase CGS_GPU_MEM_TYPE__INVISIBLE_FB:\r\nflags = AMDGPU_GEM_CREATE_NO_CPU_ACCESS;\r\ndomain = AMDGPU_GEM_DOMAIN_VRAM;\r\nif (adev->mc.visible_vram_size < adev->mc.real_vram_size) {\r\nplace.fpfn =\r\nmax(min_offset, adev->mc.visible_vram_size) >> PAGE_SHIFT;\r\nplace.lpfn =\r\nmin(max_offset, adev->mc.real_vram_size) >> PAGE_SHIFT;\r\nplace.flags = TTM_PL_FLAG_WC | TTM_PL_FLAG_UNCACHED |\r\nTTM_PL_FLAG_VRAM;\r\n}\r\nbreak;\r\ncase CGS_GPU_MEM_TYPE__GART_CACHEABLE:\r\ndomain = AMDGPU_GEM_DOMAIN_GTT;\r\nplace.fpfn = min_offset >> PAGE_SHIFT;\r\nplace.lpfn = max_offset >> PAGE_SHIFT;\r\nplace.flags = TTM_PL_FLAG_CACHED | TTM_PL_FLAG_TT;\r\nbreak;\r\ncase CGS_GPU_MEM_TYPE__GART_WRITECOMBINE:\r\nflags = AMDGPU_GEM_CREATE_CPU_GTT_USWC;\r\ndomain = AMDGPU_GEM_DOMAIN_GTT;\r\nplace.fpfn = min_offset >> PAGE_SHIFT;\r\nplace.lpfn = max_offset >> PAGE_SHIFT;\r\nplace.flags = TTM_PL_FLAG_WC | TTM_PL_FLAG_TT |\r\nTTM_PL_FLAG_UNCACHED;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*handle = 0;\r\nplacement.placement = &place;\r\nplacement.num_placement = 1;\r\nplacement.busy_placement = &place;\r\nplacement.num_busy_placement = 1;\r\nret = amdgpu_bo_create_restricted(adev, size, PAGE_SIZE,\r\ntrue, domain, flags,\r\nNULL, &placement, NULL,\r\n&obj);\r\nif (ret) {\r\nDRM_ERROR("(%d) bo create failed\n", ret);\r\nreturn ret;\r\n}\r\n*handle = (cgs_handle_t)obj;\r\nreturn ret;\r\n}\r\nstatic int amdgpu_cgs_free_gpu_mem(void *cgs_device, cgs_handle_t handle)\r\n{\r\nstruct amdgpu_bo *obj = (struct amdgpu_bo *)handle;\r\nif (obj) {\r\nint r = amdgpu_bo_reserve(obj, false);\r\nif (likely(r == 0)) {\r\namdgpu_bo_kunmap(obj);\r\namdgpu_bo_unpin(obj);\r\namdgpu_bo_unreserve(obj);\r\n}\r\namdgpu_bo_unref(&obj);\r\n}\r\nreturn 0;\r\n}\r\nstatic int amdgpu_cgs_gmap_gpu_mem(void *cgs_device, cgs_handle_t handle,\r\nuint64_t *mcaddr)\r\n{\r\nint r;\r\nu64 min_offset, max_offset;\r\nstruct amdgpu_bo *obj = (struct amdgpu_bo *)handle;\r\nWARN_ON_ONCE(obj->placement.num_placement > 1);\r\nmin_offset = obj->placements[0].fpfn << PAGE_SHIFT;\r\nmax_offset = obj->placements[0].lpfn << PAGE_SHIFT;\r\nr = amdgpu_bo_reserve(obj, false);\r\nif (unlikely(r != 0))\r\nreturn r;\r\nr = amdgpu_bo_pin_restricted(obj, AMDGPU_GEM_DOMAIN_GTT,\r\nmin_offset, max_offset, mcaddr);\r\namdgpu_bo_unreserve(obj);\r\nreturn r;\r\n}\r\nstatic int amdgpu_cgs_gunmap_gpu_mem(void *cgs_device, cgs_handle_t handle)\r\n{\r\nint r;\r\nstruct amdgpu_bo *obj = (struct amdgpu_bo *)handle;\r\nr = amdgpu_bo_reserve(obj, false);\r\nif (unlikely(r != 0))\r\nreturn r;\r\nr = amdgpu_bo_unpin(obj);\r\namdgpu_bo_unreserve(obj);\r\nreturn r;\r\n}\r\nstatic int amdgpu_cgs_kmap_gpu_mem(void *cgs_device, cgs_handle_t handle,\r\nvoid **map)\r\n{\r\nint r;\r\nstruct amdgpu_bo *obj = (struct amdgpu_bo *)handle;\r\nr = amdgpu_bo_reserve(obj, false);\r\nif (unlikely(r != 0))\r\nreturn r;\r\nr = amdgpu_bo_kmap(obj, map);\r\namdgpu_bo_unreserve(obj);\r\nreturn r;\r\n}\r\nstatic int amdgpu_cgs_kunmap_gpu_mem(void *cgs_device, cgs_handle_t handle)\r\n{\r\nint r;\r\nstruct amdgpu_bo *obj = (struct amdgpu_bo *)handle;\r\nr = amdgpu_bo_reserve(obj, false);\r\nif (unlikely(r != 0))\r\nreturn r;\r\namdgpu_bo_kunmap(obj);\r\namdgpu_bo_unreserve(obj);\r\nreturn r;\r\n}\r\nstatic uint32_t amdgpu_cgs_read_register(void *cgs_device, unsigned offset)\r\n{\r\nCGS_FUNC_ADEV;\r\nreturn RREG32(offset);\r\n}\r\nstatic void amdgpu_cgs_write_register(void *cgs_device, unsigned offset,\r\nuint32_t value)\r\n{\r\nCGS_FUNC_ADEV;\r\nWREG32(offset, value);\r\n}\r\nstatic uint32_t amdgpu_cgs_read_ind_register(void *cgs_device,\r\nenum cgs_ind_reg space,\r\nunsigned index)\r\n{\r\nCGS_FUNC_ADEV;\r\nswitch (space) {\r\ncase CGS_IND_REG__MMIO:\r\nreturn RREG32_IDX(index);\r\ncase CGS_IND_REG__PCIE:\r\nreturn RREG32_PCIE(index);\r\ncase CGS_IND_REG__SMC:\r\nreturn RREG32_SMC(index);\r\ncase CGS_IND_REG__UVD_CTX:\r\nreturn RREG32_UVD_CTX(index);\r\ncase CGS_IND_REG__DIDT:\r\nreturn RREG32_DIDT(index);\r\ncase CGS_IND_REG__AUDIO_ENDPT:\r\nDRM_ERROR("audio endpt register access not implemented.\n");\r\nreturn 0;\r\n}\r\nWARN(1, "Invalid indirect register space");\r\nreturn 0;\r\n}\r\nstatic void amdgpu_cgs_write_ind_register(void *cgs_device,\r\nenum cgs_ind_reg space,\r\nunsigned index, uint32_t value)\r\n{\r\nCGS_FUNC_ADEV;\r\nswitch (space) {\r\ncase CGS_IND_REG__MMIO:\r\nreturn WREG32_IDX(index, value);\r\ncase CGS_IND_REG__PCIE:\r\nreturn WREG32_PCIE(index, value);\r\ncase CGS_IND_REG__SMC:\r\nreturn WREG32_SMC(index, value);\r\ncase CGS_IND_REG__UVD_CTX:\r\nreturn WREG32_UVD_CTX(index, value);\r\ncase CGS_IND_REG__DIDT:\r\nreturn WREG32_DIDT(index, value);\r\ncase CGS_IND_REG__AUDIO_ENDPT:\r\nDRM_ERROR("audio endpt register access not implemented.\n");\r\nreturn;\r\n}\r\nWARN(1, "Invalid indirect register space");\r\n}\r\nstatic uint8_t amdgpu_cgs_read_pci_config_byte(void *cgs_device, unsigned addr)\r\n{\r\nCGS_FUNC_ADEV;\r\nuint8_t val;\r\nint ret = pci_read_config_byte(adev->pdev, addr, &val);\r\nif (WARN(ret, "pci_read_config_byte error"))\r\nreturn 0;\r\nreturn val;\r\n}\r\nstatic uint16_t amdgpu_cgs_read_pci_config_word(void *cgs_device, unsigned addr)\r\n{\r\nCGS_FUNC_ADEV;\r\nuint16_t val;\r\nint ret = pci_read_config_word(adev->pdev, addr, &val);\r\nif (WARN(ret, "pci_read_config_word error"))\r\nreturn 0;\r\nreturn val;\r\n}\r\nstatic uint32_t amdgpu_cgs_read_pci_config_dword(void *cgs_device,\r\nunsigned addr)\r\n{\r\nCGS_FUNC_ADEV;\r\nuint32_t val;\r\nint ret = pci_read_config_dword(adev->pdev, addr, &val);\r\nif (WARN(ret, "pci_read_config_dword error"))\r\nreturn 0;\r\nreturn val;\r\n}\r\nstatic void amdgpu_cgs_write_pci_config_byte(void *cgs_device, unsigned addr,\r\nuint8_t value)\r\n{\r\nCGS_FUNC_ADEV;\r\nint ret = pci_write_config_byte(adev->pdev, addr, value);\r\nWARN(ret, "pci_write_config_byte error");\r\n}\r\nstatic void amdgpu_cgs_write_pci_config_word(void *cgs_device, unsigned addr,\r\nuint16_t value)\r\n{\r\nCGS_FUNC_ADEV;\r\nint ret = pci_write_config_word(adev->pdev, addr, value);\r\nWARN(ret, "pci_write_config_word error");\r\n}\r\nstatic void amdgpu_cgs_write_pci_config_dword(void *cgs_device, unsigned addr,\r\nuint32_t value)\r\n{\r\nCGS_FUNC_ADEV;\r\nint ret = pci_write_config_dword(adev->pdev, addr, value);\r\nWARN(ret, "pci_write_config_dword error");\r\n}\r\nstatic const void *amdgpu_cgs_atom_get_data_table(void *cgs_device,\r\nunsigned table, uint16_t *size,\r\nuint8_t *frev, uint8_t *crev)\r\n{\r\nCGS_FUNC_ADEV;\r\nuint16_t data_start;\r\nif (amdgpu_atom_parse_data_header(\r\nadev->mode_info.atom_context, table, size,\r\nfrev, crev, &data_start))\r\nreturn (uint8_t*)adev->mode_info.atom_context->bios +\r\ndata_start;\r\nreturn NULL;\r\n}\r\nstatic int amdgpu_cgs_atom_get_cmd_table_revs(void *cgs_device, unsigned table,\r\nuint8_t *frev, uint8_t *crev)\r\n{\r\nCGS_FUNC_ADEV;\r\nif (amdgpu_atom_parse_cmd_header(\r\nadev->mode_info.atom_context, table,\r\nfrev, crev))\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int amdgpu_cgs_atom_exec_cmd_table(void *cgs_device, unsigned table,\r\nvoid *args)\r\n{\r\nCGS_FUNC_ADEV;\r\nreturn amdgpu_atom_execute_table(\r\nadev->mode_info.atom_context, table, args);\r\n}\r\nstatic int amdgpu_cgs_create_pm_request(void *cgs_device, cgs_handle_t *request)\r\n{\r\nreturn 0;\r\n}\r\nstatic int amdgpu_cgs_destroy_pm_request(void *cgs_device, cgs_handle_t request)\r\n{\r\nreturn 0;\r\n}\r\nstatic int amdgpu_cgs_set_pm_request(void *cgs_device, cgs_handle_t request,\r\nint active)\r\n{\r\nreturn 0;\r\n}\r\nstatic int amdgpu_cgs_pm_request_clock(void *cgs_device, cgs_handle_t request,\r\nenum cgs_clock clock, unsigned freq)\r\n{\r\nreturn 0;\r\n}\r\nstatic int amdgpu_cgs_pm_request_engine(void *cgs_device, cgs_handle_t request,\r\nenum cgs_engine engine, int powered)\r\n{\r\nreturn 0;\r\n}\r\nstatic int amdgpu_cgs_pm_query_clock_limits(void *cgs_device,\r\nenum cgs_clock clock,\r\nstruct cgs_clock_limits *limits)\r\n{\r\nreturn 0;\r\n}\r\nstatic int amdgpu_cgs_set_camera_voltages(void *cgs_device, uint32_t mask,\r\nconst uint32_t *voltages)\r\n{\r\nDRM_ERROR("not implemented");\r\nreturn -EPERM;\r\n}\r\nstatic int cgs_set_irq_state(struct amdgpu_device *adev,\r\nstruct amdgpu_irq_src *src,\r\nunsigned type,\r\nenum amdgpu_interrupt_state state)\r\n{\r\nstruct cgs_irq_params *irq_params =\r\n(struct cgs_irq_params *)src->data;\r\nif (!irq_params)\r\nreturn -EINVAL;\r\nif (!irq_params->set)\r\nreturn -EINVAL;\r\nreturn irq_params->set(irq_params->private_data,\r\nirq_params->src_id,\r\ntype,\r\n(int)state);\r\n}\r\nstatic int cgs_process_irq(struct amdgpu_device *adev,\r\nstruct amdgpu_irq_src *source,\r\nstruct amdgpu_iv_entry *entry)\r\n{\r\nstruct cgs_irq_params *irq_params =\r\n(struct cgs_irq_params *)source->data;\r\nif (!irq_params)\r\nreturn -EINVAL;\r\nif (!irq_params->handler)\r\nreturn -EINVAL;\r\nreturn irq_params->handler(irq_params->private_data,\r\nirq_params->src_id,\r\nentry->iv_entry);\r\n}\r\nstatic int amdgpu_cgs_add_irq_source(void *cgs_device, unsigned src_id,\r\nunsigned num_types,\r\ncgs_irq_source_set_func_t set,\r\ncgs_irq_handler_func_t handler,\r\nvoid *private_data)\r\n{\r\nCGS_FUNC_ADEV;\r\nint ret = 0;\r\nstruct cgs_irq_params *irq_params;\r\nstruct amdgpu_irq_src *source =\r\nkzalloc(sizeof(struct amdgpu_irq_src), GFP_KERNEL);\r\nif (!source)\r\nreturn -ENOMEM;\r\nirq_params =\r\nkzalloc(sizeof(struct cgs_irq_params), GFP_KERNEL);\r\nif (!irq_params) {\r\nkfree(source);\r\nreturn -ENOMEM;\r\n}\r\nsource->num_types = num_types;\r\nsource->funcs = &cgs_irq_funcs;\r\nirq_params->src_id = src_id;\r\nirq_params->set = set;\r\nirq_params->handler = handler;\r\nirq_params->private_data = private_data;\r\nsource->data = (void *)irq_params;\r\nret = amdgpu_irq_add_id(adev, src_id, source);\r\nif (ret) {\r\nkfree(irq_params);\r\nkfree(source);\r\n}\r\nreturn ret;\r\n}\r\nstatic int amdgpu_cgs_irq_get(void *cgs_device, unsigned src_id, unsigned type)\r\n{\r\nCGS_FUNC_ADEV;\r\nreturn amdgpu_irq_get(adev, adev->irq.sources[src_id], type);\r\n}\r\nstatic int amdgpu_cgs_irq_put(void *cgs_device, unsigned src_id, unsigned type)\r\n{\r\nCGS_FUNC_ADEV;\r\nreturn amdgpu_irq_put(adev, adev->irq.sources[src_id], type);\r\n}\r\nint amdgpu_cgs_set_clockgating_state(void *cgs_device,\r\nenum amd_ip_block_type block_type,\r\nenum amd_clockgating_state state)\r\n{\r\nCGS_FUNC_ADEV;\r\nint i, r = -1;\r\nfor (i = 0; i < adev->num_ip_blocks; i++) {\r\nif (!adev->ip_block_status[i].valid)\r\ncontinue;\r\nif (adev->ip_blocks[i].type == block_type) {\r\nr = adev->ip_blocks[i].funcs->set_clockgating_state(\r\n(void *)adev,\r\nstate);\r\nbreak;\r\n}\r\n}\r\nreturn r;\r\n}\r\nint amdgpu_cgs_set_powergating_state(void *cgs_device,\r\nenum amd_ip_block_type block_type,\r\nenum amd_powergating_state state)\r\n{\r\nCGS_FUNC_ADEV;\r\nint i, r = -1;\r\nfor (i = 0; i < adev->num_ip_blocks; i++) {\r\nif (!adev->ip_block_status[i].valid)\r\ncontinue;\r\nif (adev->ip_blocks[i].type == block_type) {\r\nr = adev->ip_blocks[i].funcs->set_powergating_state(\r\n(void *)adev,\r\nstate);\r\nbreak;\r\n}\r\n}\r\nreturn r;\r\n}\r\nstatic uint32_t fw_type_convert(void *cgs_device, uint32_t fw_type)\r\n{\r\nCGS_FUNC_ADEV;\r\nenum AMDGPU_UCODE_ID result = AMDGPU_UCODE_ID_MAXIMUM;\r\nswitch (fw_type) {\r\ncase CGS_UCODE_ID_SDMA0:\r\nresult = AMDGPU_UCODE_ID_SDMA0;\r\nbreak;\r\ncase CGS_UCODE_ID_SDMA1:\r\nresult = AMDGPU_UCODE_ID_SDMA1;\r\nbreak;\r\ncase CGS_UCODE_ID_CP_CE:\r\nresult = AMDGPU_UCODE_ID_CP_CE;\r\nbreak;\r\ncase CGS_UCODE_ID_CP_PFP:\r\nresult = AMDGPU_UCODE_ID_CP_PFP;\r\nbreak;\r\ncase CGS_UCODE_ID_CP_ME:\r\nresult = AMDGPU_UCODE_ID_CP_ME;\r\nbreak;\r\ncase CGS_UCODE_ID_CP_MEC:\r\ncase CGS_UCODE_ID_CP_MEC_JT1:\r\nresult = AMDGPU_UCODE_ID_CP_MEC1;\r\nbreak;\r\ncase CGS_UCODE_ID_CP_MEC_JT2:\r\nif (adev->asic_type == CHIP_TONGA)\r\nresult = AMDGPU_UCODE_ID_CP_MEC2;\r\nelse if (adev->asic_type == CHIP_CARRIZO)\r\nresult = AMDGPU_UCODE_ID_CP_MEC1;\r\nbreak;\r\ncase CGS_UCODE_ID_RLC_G:\r\nresult = AMDGPU_UCODE_ID_RLC_G;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Firmware type not supported\n");\r\n}\r\nreturn result;\r\n}\r\nstatic int amdgpu_cgs_get_firmware_info(void *cgs_device,\r\nenum cgs_ucode_id type,\r\nstruct cgs_firmware_info *info)\r\n{\r\nCGS_FUNC_ADEV;\r\nif (CGS_UCODE_ID_SMU != type) {\r\nuint64_t gpu_addr;\r\nuint32_t data_size;\r\nconst struct gfx_firmware_header_v1_0 *header;\r\nenum AMDGPU_UCODE_ID id;\r\nstruct amdgpu_firmware_info *ucode;\r\nid = fw_type_convert(cgs_device, type);\r\nucode = &adev->firmware.ucode[id];\r\nif (ucode->fw == NULL)\r\nreturn -EINVAL;\r\ngpu_addr = ucode->mc_addr;\r\nheader = (const struct gfx_firmware_header_v1_0 *)ucode->fw->data;\r\ndata_size = le32_to_cpu(header->header.ucode_size_bytes);\r\nif ((type == CGS_UCODE_ID_CP_MEC_JT1) ||\r\n(type == CGS_UCODE_ID_CP_MEC_JT2)) {\r\ngpu_addr += le32_to_cpu(header->jt_offset) << 2;\r\ndata_size = le32_to_cpu(header->jt_size) << 2;\r\n}\r\ninfo->mc_addr = gpu_addr;\r\ninfo->image_size = data_size;\r\ninfo->version = (uint16_t)le32_to_cpu(header->header.ucode_version);\r\ninfo->feature_version = (uint16_t)le32_to_cpu(header->ucode_feature_version);\r\n} else {\r\nchar fw_name[30] = {0};\r\nint err = 0;\r\nuint32_t ucode_size;\r\nuint32_t ucode_start_address;\r\nconst uint8_t *src;\r\nconst struct smc_firmware_header_v1_0 *hdr;\r\nswitch (adev->asic_type) {\r\ncase CHIP_TONGA:\r\nstrcpy(fw_name, "amdgpu/tonga_smc.bin");\r\nbreak;\r\ndefault:\r\nDRM_ERROR("SMC firmware not supported\n");\r\nreturn -EINVAL;\r\n}\r\nerr = request_firmware(&adev->pm.fw, fw_name, adev->dev);\r\nif (err) {\r\nDRM_ERROR("Failed to request firmware\n");\r\nreturn err;\r\n}\r\nerr = amdgpu_ucode_validate(adev->pm.fw);\r\nif (err) {\r\nDRM_ERROR("Failed to load firmware \"%s\"", fw_name);\r\nrelease_firmware(adev->pm.fw);\r\nadev->pm.fw = NULL;\r\nreturn err;\r\n}\r\nhdr = (const struct smc_firmware_header_v1_0 *) adev->pm.fw->data;\r\nadev->pm.fw_version = le32_to_cpu(hdr->header.ucode_version);\r\nucode_size = le32_to_cpu(hdr->header.ucode_size_bytes);\r\nucode_start_address = le32_to_cpu(hdr->ucode_start_addr);\r\nsrc = (const uint8_t *)(adev->pm.fw->data +\r\nle32_to_cpu(hdr->header.ucode_array_offset_bytes));\r\ninfo->version = adev->pm.fw_version;\r\ninfo->image_size = ucode_size;\r\ninfo->kptr = (void *)src;\r\n}\r\nreturn 0;\r\n}\r\nvoid *amdgpu_cgs_create_device(struct amdgpu_device *adev)\r\n{\r\nstruct amdgpu_cgs_device *cgs_device =\r\nkmalloc(sizeof(*cgs_device), GFP_KERNEL);\r\nif (!cgs_device) {\r\nDRM_ERROR("Couldn't allocate CGS device structure\n");\r\nreturn NULL;\r\n}\r\ncgs_device->base.ops = &amdgpu_cgs_ops;\r\ncgs_device->base.os_ops = &amdgpu_cgs_os_ops;\r\ncgs_device->adev = adev;\r\nreturn cgs_device;\r\n}\r\nvoid amdgpu_cgs_destroy_device(void *cgs_device)\r\n{\r\nkfree(cgs_device);\r\n}
