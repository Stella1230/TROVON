static inline int __vmware_platform(void)\r\n{\r\nuint32_t eax, ebx, ecx, edx;\r\nVMWARE_PORT(GETVERSION, eax, ebx, ecx, edx);\r\nreturn eax != (uint32_t)-1 && ebx == VMWARE_HYPERVISOR_MAGIC;\r\n}\r\nstatic unsigned long vmware_get_tsc_khz(void)\r\n{\r\nuint64_t tsc_hz, lpj;\r\nuint32_t eax, ebx, ecx, edx;\r\nVMWARE_PORT(GETHZ, eax, ebx, ecx, edx);\r\ntsc_hz = eax | (((uint64_t)ebx) << 32);\r\ndo_div(tsc_hz, 1000);\r\nBUG_ON(tsc_hz >> 32);\r\nprintk(KERN_INFO "TSC freq read from hypervisor : %lu.%03lu MHz\n",\r\n(unsigned long) tsc_hz / 1000,\r\n(unsigned long) tsc_hz % 1000);\r\nif (!preset_lpj) {\r\nlpj = ((u64)tsc_hz * 1000);\r\ndo_div(lpj, HZ);\r\npreset_lpj = lpj;\r\n}\r\nreturn tsc_hz;\r\n}\r\nstatic void __init vmware_platform_setup(void)\r\n{\r\nuint32_t eax, ebx, ecx, edx;\r\nVMWARE_PORT(GETHZ, eax, ebx, ecx, edx);\r\nif (ebx != UINT_MAX)\r\nx86_platform.calibrate_tsc = vmware_get_tsc_khz;\r\nelse\r\nprintk(KERN_WARNING\r\n"Failed to get TSC freq from the hypervisor\n");\r\n}\r\nstatic uint32_t __init vmware_platform(void)\r\n{\r\nif (cpu_has_hypervisor) {\r\nunsigned int eax;\r\nunsigned int hyper_vendor_id[3];\r\ncpuid(CPUID_VMWARE_INFO_LEAF, &eax, &hyper_vendor_id[0],\r\n&hyper_vendor_id[1], &hyper_vendor_id[2]);\r\nif (!memcmp(hyper_vendor_id, "VMwareVMware", 12))\r\nreturn CPUID_VMWARE_INFO_LEAF;\r\n} else if (dmi_available && dmi_name_in_serial("VMware") &&\r\n__vmware_platform())\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void vmware_set_cpu_features(struct cpuinfo_x86 *c)\r\n{\r\nset_cpu_cap(c, X86_FEATURE_CONSTANT_TSC);\r\nset_cpu_cap(c, X86_FEATURE_TSC_RELIABLE);\r\n}\r\nstatic bool __init vmware_legacy_x2apic_available(void)\r\n{\r\nuint32_t eax, ebx, ecx, edx;\r\nVMWARE_PORT(GETVCPU_INFO, eax, ebx, ecx, edx);\r\nreturn (eax & (1 << VMWARE_PORT_CMD_VCPU_RESERVED)) == 0 &&\r\n(eax & (1 << VMWARE_PORT_CMD_LEGACY_X2APIC)) != 0;\r\n}
