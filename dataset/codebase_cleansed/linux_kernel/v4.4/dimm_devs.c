static int __validate_dimm(struct nvdimm_drvdata *ndd)\r\n{\r\nstruct nvdimm *nvdimm;\r\nif (!ndd)\r\nreturn -EINVAL;\r\nnvdimm = to_nvdimm(ndd->dev);\r\nif (!nvdimm->dsm_mask)\r\nreturn -ENXIO;\r\nif (!test_bit(ND_CMD_GET_CONFIG_DATA, nvdimm->dsm_mask))\r\nreturn -ENXIO;\r\nreturn 0;\r\n}\r\nstatic int validate_dimm(struct nvdimm_drvdata *ndd)\r\n{\r\nint rc = __validate_dimm(ndd);\r\nif (rc && ndd)\r\ndev_dbg(ndd->dev, "%pf: %s error: %d\n",\r\n__builtin_return_address(0), __func__, rc);\r\nreturn rc;\r\n}\r\nint nvdimm_init_nsarea(struct nvdimm_drvdata *ndd)\r\n{\r\nstruct nd_cmd_get_config_size *cmd = &ndd->nsarea;\r\nstruct nvdimm_bus *nvdimm_bus = walk_to_nvdimm_bus(ndd->dev);\r\nstruct nvdimm_bus_descriptor *nd_desc;\r\nint rc = validate_dimm(ndd);\r\nif (rc)\r\nreturn rc;\r\nif (cmd->config_size)\r\nreturn 0;\r\nmemset(cmd, 0, sizeof(*cmd));\r\nnd_desc = nvdimm_bus->nd_desc;\r\nreturn nd_desc->ndctl(nd_desc, to_nvdimm(ndd->dev),\r\nND_CMD_GET_CONFIG_SIZE, cmd, sizeof(*cmd));\r\n}\r\nint nvdimm_init_config_data(struct nvdimm_drvdata *ndd)\r\n{\r\nstruct nvdimm_bus *nvdimm_bus = walk_to_nvdimm_bus(ndd->dev);\r\nstruct nd_cmd_get_config_data_hdr *cmd;\r\nstruct nvdimm_bus_descriptor *nd_desc;\r\nint rc = validate_dimm(ndd);\r\nu32 max_cmd_size, config_size;\r\nsize_t offset;\r\nif (rc)\r\nreturn rc;\r\nif (ndd->data)\r\nreturn 0;\r\nif (ndd->nsarea.status || ndd->nsarea.max_xfer == 0\r\n|| ndd->nsarea.config_size < ND_LABEL_MIN_SIZE) {\r\ndev_dbg(ndd->dev, "failed to init config data area: (%d:%d)\n",\r\nndd->nsarea.max_xfer, ndd->nsarea.config_size);\r\nreturn -ENXIO;\r\n}\r\nndd->data = kmalloc(ndd->nsarea.config_size, GFP_KERNEL);\r\nif (!ndd->data)\r\nndd->data = vmalloc(ndd->nsarea.config_size);\r\nif (!ndd->data)\r\nreturn -ENOMEM;\r\nmax_cmd_size = min_t(u32, PAGE_SIZE, ndd->nsarea.max_xfer);\r\ncmd = kzalloc(max_cmd_size + sizeof(*cmd), GFP_KERNEL);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\nnd_desc = nvdimm_bus->nd_desc;\r\nfor (config_size = ndd->nsarea.config_size, offset = 0;\r\nconfig_size; config_size -= cmd->in_length,\r\noffset += cmd->in_length) {\r\ncmd->in_length = min(config_size, max_cmd_size);\r\ncmd->in_offset = offset;\r\nrc = nd_desc->ndctl(nd_desc, to_nvdimm(ndd->dev),\r\nND_CMD_GET_CONFIG_DATA, cmd,\r\ncmd->in_length + sizeof(*cmd));\r\nif (rc || cmd->status) {\r\nrc = -ENXIO;\r\nbreak;\r\n}\r\nmemcpy(ndd->data + offset, cmd->out_buf, cmd->in_length);\r\n}\r\ndev_dbg(ndd->dev, "%s: len: %zu rc: %d\n", __func__, offset, rc);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nint nvdimm_set_config_data(struct nvdimm_drvdata *ndd, size_t offset,\r\nvoid *buf, size_t len)\r\n{\r\nint rc = validate_dimm(ndd);\r\nsize_t max_cmd_size, buf_offset;\r\nstruct nd_cmd_set_config_hdr *cmd;\r\nstruct nvdimm_bus *nvdimm_bus = walk_to_nvdimm_bus(ndd->dev);\r\nstruct nvdimm_bus_descriptor *nd_desc = nvdimm_bus->nd_desc;\r\nif (rc)\r\nreturn rc;\r\nif (!ndd->data)\r\nreturn -ENXIO;\r\nif (offset + len > ndd->nsarea.config_size)\r\nreturn -ENXIO;\r\nmax_cmd_size = min_t(u32, PAGE_SIZE, len);\r\nmax_cmd_size = min_t(u32, max_cmd_size, ndd->nsarea.max_xfer);\r\ncmd = kzalloc(max_cmd_size + sizeof(*cmd) + sizeof(u32), GFP_KERNEL);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\nfor (buf_offset = 0; len; len -= cmd->in_length,\r\nbuf_offset += cmd->in_length) {\r\nsize_t cmd_size;\r\nu32 *status;\r\ncmd->in_offset = offset + buf_offset;\r\ncmd->in_length = min(max_cmd_size, len);\r\nmemcpy(cmd->in_buf, buf + buf_offset, cmd->in_length);\r\ncmd_size = sizeof(*cmd) + cmd->in_length + sizeof(u32);\r\nstatus = ((void *) cmd) + cmd_size - sizeof(u32);\r\nrc = nd_desc->ndctl(nd_desc, to_nvdimm(ndd->dev),\r\nND_CMD_SET_CONFIG_DATA, cmd, cmd_size);\r\nif (rc || *status) {\r\nrc = rc ? rc : -ENXIO;\r\nbreak;\r\n}\r\n}\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic void nvdimm_release(struct device *dev)\r\n{\r\nstruct nvdimm *nvdimm = to_nvdimm(dev);\r\nida_simple_remove(&dimm_ida, nvdimm->id);\r\nkfree(nvdimm);\r\n}\r\nbool is_nvdimm(struct device *dev)\r\n{\r\nreturn dev->type == &nvdimm_device_type;\r\n}\r\nstruct nvdimm *to_nvdimm(struct device *dev)\r\n{\r\nstruct nvdimm *nvdimm = container_of(dev, struct nvdimm, dev);\r\nWARN_ON(!is_nvdimm(dev));\r\nreturn nvdimm;\r\n}\r\nstruct nvdimm *nd_blk_region_to_dimm(struct nd_blk_region *ndbr)\r\n{\r\nstruct nd_region *nd_region = &ndbr->nd_region;\r\nstruct nd_mapping *nd_mapping = &nd_region->mapping[0];\r\nreturn nd_mapping->nvdimm;\r\n}\r\nstruct nvdimm_drvdata *to_ndd(struct nd_mapping *nd_mapping)\r\n{\r\nstruct nvdimm *nvdimm = nd_mapping->nvdimm;\r\nWARN_ON_ONCE(!is_nvdimm_bus_locked(&nvdimm->dev));\r\nreturn dev_get_drvdata(&nvdimm->dev);\r\n}\r\nvoid nvdimm_drvdata_release(struct kref *kref)\r\n{\r\nstruct nvdimm_drvdata *ndd = container_of(kref, typeof(*ndd), kref);\r\nstruct device *dev = ndd->dev;\r\nstruct resource *res, *_r;\r\ndev_dbg(dev, "%s\n", __func__);\r\nnvdimm_bus_lock(dev);\r\nfor_each_dpa_resource_safe(ndd, res, _r)\r\nnvdimm_free_dpa(ndd, res);\r\nnvdimm_bus_unlock(dev);\r\nkvfree(ndd->data);\r\nkfree(ndd);\r\nput_device(dev);\r\n}\r\nvoid get_ndd(struct nvdimm_drvdata *ndd)\r\n{\r\nkref_get(&ndd->kref);\r\n}\r\nvoid put_ndd(struct nvdimm_drvdata *ndd)\r\n{\r\nif (ndd)\r\nkref_put(&ndd->kref, nvdimm_drvdata_release);\r\n}\r\nconst char *nvdimm_name(struct nvdimm *nvdimm)\r\n{\r\nreturn dev_name(&nvdimm->dev);\r\n}\r\nvoid *nvdimm_provider_data(struct nvdimm *nvdimm)\r\n{\r\nif (nvdimm)\r\nreturn nvdimm->provider_data;\r\nreturn NULL;\r\n}\r\nstatic ssize_t commands_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct nvdimm *nvdimm = to_nvdimm(dev);\r\nint cmd, len = 0;\r\nif (!nvdimm->dsm_mask)\r\nreturn sprintf(buf, "\n");\r\nfor_each_set_bit(cmd, nvdimm->dsm_mask, BITS_PER_LONG)\r\nlen += sprintf(buf + len, "%s ", nvdimm_cmd_name(cmd));\r\nlen += sprintf(buf + len, "\n");\r\nreturn len;\r\n}\r\nstatic ssize_t state_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct nvdimm *nvdimm = to_nvdimm(dev);\r\nnvdimm_bus_lock(dev);\r\nnvdimm_bus_unlock(dev);\r\nreturn sprintf(buf, "%s\n", atomic_read(&nvdimm->busy)\r\n? "active" : "idle");\r\n}\r\nstatic ssize_t available_slots_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct nvdimm_drvdata *ndd = dev_get_drvdata(dev);\r\nssize_t rc;\r\nu32 nfree;\r\nif (!ndd)\r\nreturn -ENXIO;\r\nnvdimm_bus_lock(dev);\r\nnfree = nd_label_nfree(ndd);\r\nif (nfree - 1 > nfree) {\r\ndev_WARN_ONCE(dev, 1, "we ate our last label?\n");\r\nnfree = 0;\r\n} else\r\nnfree--;\r\nrc = sprintf(buf, "%d\n", nfree);\r\nnvdimm_bus_unlock(dev);\r\nreturn rc;\r\n}\r\nstruct nvdimm *nvdimm_create(struct nvdimm_bus *nvdimm_bus, void *provider_data,\r\nconst struct attribute_group **groups, unsigned long flags,\r\nunsigned long *dsm_mask)\r\n{\r\nstruct nvdimm *nvdimm = kzalloc(sizeof(*nvdimm), GFP_KERNEL);\r\nstruct device *dev;\r\nif (!nvdimm)\r\nreturn NULL;\r\nnvdimm->id = ida_simple_get(&dimm_ida, 0, 0, GFP_KERNEL);\r\nif (nvdimm->id < 0) {\r\nkfree(nvdimm);\r\nreturn NULL;\r\n}\r\nnvdimm->provider_data = provider_data;\r\nnvdimm->flags = flags;\r\nnvdimm->dsm_mask = dsm_mask;\r\natomic_set(&nvdimm->busy, 0);\r\ndev = &nvdimm->dev;\r\ndev_set_name(dev, "nmem%d", nvdimm->id);\r\ndev->parent = &nvdimm_bus->dev;\r\ndev->type = &nvdimm_device_type;\r\ndev->devt = MKDEV(nvdimm_major, nvdimm->id);\r\ndev->groups = groups;\r\nnd_device_register(dev);\r\nreturn nvdimm;\r\n}\r\nresource_size_t nd_blk_available_dpa(struct nd_mapping *nd_mapping)\r\n{\r\nstruct nvdimm_drvdata *ndd = to_ndd(nd_mapping);\r\nresource_size_t map_end, busy = 0, available;\r\nstruct resource *res;\r\nif (!ndd)\r\nreturn 0;\r\nmap_end = nd_mapping->start + nd_mapping->size - 1;\r\nfor_each_dpa_resource(ndd, res)\r\nif (res->start >= nd_mapping->start && res->start < map_end) {\r\nresource_size_t end = min(map_end, res->end);\r\nbusy += end - res->start + 1;\r\n} else if (res->end >= nd_mapping->start\r\n&& res->end <= map_end) {\r\nbusy += res->end - nd_mapping->start;\r\n} else if (nd_mapping->start > res->start\r\n&& nd_mapping->start < res->end) {\r\nbusy += nd_mapping->size;\r\n}\r\navailable = map_end - nd_mapping->start + 1;\r\nif (busy < available)\r\nreturn available - busy;\r\nreturn 0;\r\n}\r\nresource_size_t nd_pmem_available_dpa(struct nd_region *nd_region,\r\nstruct nd_mapping *nd_mapping, resource_size_t *overlap)\r\n{\r\nresource_size_t map_start, map_end, busy = 0, available, blk_start;\r\nstruct nvdimm_drvdata *ndd = to_ndd(nd_mapping);\r\nstruct resource *res;\r\nconst char *reason;\r\nif (!ndd)\r\nreturn 0;\r\nmap_start = nd_mapping->start;\r\nmap_end = map_start + nd_mapping->size - 1;\r\nblk_start = max(map_start, map_end + 1 - *overlap);\r\nfor_each_dpa_resource(ndd, res)\r\nif (res->start >= map_start && res->start < map_end) {\r\nif (strncmp(res->name, "blk", 3) == 0)\r\nblk_start = min(blk_start, res->start);\r\nelse if (res->start != map_start) {\r\nreason = "misaligned to iset";\r\ngoto err;\r\n} else {\r\nif (busy) {\r\nreason = "duplicate overlapping PMEM reservations?";\r\ngoto err;\r\n}\r\nbusy += resource_size(res);\r\ncontinue;\r\n}\r\n} else if (res->end >= map_start && res->end <= map_end) {\r\nif (strncmp(res->name, "blk", 3) == 0) {\r\nblk_start = map_start;\r\n} else {\r\nreason = "misaligned to iset";\r\ngoto err;\r\n}\r\n} else if (map_start > res->start && map_start < res->end) {\r\nbusy += nd_mapping->size;\r\nblk_start = map_start;\r\n}\r\n*overlap = map_end + 1 - blk_start;\r\navailable = blk_start - map_start;\r\nif (busy < available)\r\nreturn available - busy;\r\nreturn 0;\r\nerr:\r\nnd_dbg_dpa(nd_region, ndd, res, "%s\n", reason);\r\nreturn 0;\r\n}\r\nvoid nvdimm_free_dpa(struct nvdimm_drvdata *ndd, struct resource *res)\r\n{\r\nWARN_ON_ONCE(!is_nvdimm_bus_locked(ndd->dev));\r\nkfree(res->name);\r\n__release_region(&ndd->dpa, res->start, resource_size(res));\r\n}\r\nstruct resource *nvdimm_allocate_dpa(struct nvdimm_drvdata *ndd,\r\nstruct nd_label_id *label_id, resource_size_t start,\r\nresource_size_t n)\r\n{\r\nchar *name = kmemdup(label_id, sizeof(*label_id), GFP_KERNEL);\r\nstruct resource *res;\r\nif (!name)\r\nreturn NULL;\r\nWARN_ON_ONCE(!is_nvdimm_bus_locked(ndd->dev));\r\nres = __request_region(&ndd->dpa, start, n, name, 0);\r\nif (!res)\r\nkfree(name);\r\nreturn res;\r\n}\r\nresource_size_t nvdimm_allocated_dpa(struct nvdimm_drvdata *ndd,\r\nstruct nd_label_id *label_id)\r\n{\r\nresource_size_t allocated = 0;\r\nstruct resource *res;\r\nfor_each_dpa_resource(ndd, res)\r\nif (strcmp(res->name, label_id->id) == 0)\r\nallocated += resource_size(res);\r\nreturn allocated;\r\n}\r\nstatic int count_dimms(struct device *dev, void *c)\r\n{\r\nint *count = c;\r\nif (is_nvdimm(dev))\r\n(*count)++;\r\nreturn 0;\r\n}\r\nint nvdimm_bus_check_dimm_count(struct nvdimm_bus *nvdimm_bus, int dimm_count)\r\n{\r\nint count = 0;\r\nnd_synchronize();\r\ndevice_for_each_child(&nvdimm_bus->dev, &count, count_dimms);\r\ndev_dbg(&nvdimm_bus->dev, "%s: count: %d\n", __func__, count);\r\nif (count != dimm_count)\r\nreturn -ENXIO;\r\nreturn 0;\r\n}
