static inline u32 gpio_rcar_read(struct gpio_rcar_priv *p, int offs)\r\n{\r\nreturn ioread32(p->base + offs);\r\n}\r\nstatic inline void gpio_rcar_write(struct gpio_rcar_priv *p, int offs,\r\nu32 value)\r\n{\r\niowrite32(value, p->base + offs);\r\n}\r\nstatic void gpio_rcar_modify_bit(struct gpio_rcar_priv *p, int offs,\r\nint bit, bool value)\r\n{\r\nu32 tmp = gpio_rcar_read(p, offs);\r\nif (value)\r\ntmp |= BIT(bit);\r\nelse\r\ntmp &= ~BIT(bit);\r\ngpio_rcar_write(p, offs, tmp);\r\n}\r\nstatic void gpio_rcar_irq_disable(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct gpio_rcar_priv *p = container_of(gc, struct gpio_rcar_priv,\r\ngpio_chip);\r\ngpio_rcar_write(p, INTMSK, ~BIT(irqd_to_hwirq(d)));\r\n}\r\nstatic void gpio_rcar_irq_enable(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct gpio_rcar_priv *p = container_of(gc, struct gpio_rcar_priv,\r\ngpio_chip);\r\ngpio_rcar_write(p, MSKCLR, BIT(irqd_to_hwirq(d)));\r\n}\r\nstatic void gpio_rcar_config_interrupt_input_mode(struct gpio_rcar_priv *p,\r\nunsigned int hwirq,\r\nbool active_high_rising_edge,\r\nbool level_trigger,\r\nbool both)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&p->lock, flags);\r\ngpio_rcar_modify_bit(p, POSNEG, hwirq, !active_high_rising_edge);\r\ngpio_rcar_modify_bit(p, EDGLEVEL, hwirq, !level_trigger);\r\nif (p->config.has_both_edge_trigger)\r\ngpio_rcar_modify_bit(p, BOTHEDGE, hwirq, both);\r\ngpio_rcar_modify_bit(p, IOINTSEL, hwirq, true);\r\nif (!level_trigger)\r\ngpio_rcar_write(p, INTCLR, BIT(hwirq));\r\nspin_unlock_irqrestore(&p->lock, flags);\r\n}\r\nstatic int gpio_rcar_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct gpio_rcar_priv *p = container_of(gc, struct gpio_rcar_priv,\r\ngpio_chip);\r\nunsigned int hwirq = irqd_to_hwirq(d);\r\ndev_dbg(&p->pdev->dev, "sense irq = %d, type = %d\n", hwirq, type);\r\nswitch (type & IRQ_TYPE_SENSE_MASK) {\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ngpio_rcar_config_interrupt_input_mode(p, hwirq, true, true,\r\nfalse);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ngpio_rcar_config_interrupt_input_mode(p, hwirq, false, true,\r\nfalse);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\ngpio_rcar_config_interrupt_input_mode(p, hwirq, true, false,\r\nfalse);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ngpio_rcar_config_interrupt_input_mode(p, hwirq, false, false,\r\nfalse);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nif (!p->config.has_both_edge_trigger)\r\nreturn -EINVAL;\r\ngpio_rcar_config_interrupt_input_mode(p, hwirq, true, false,\r\ntrue);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpio_rcar_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct gpio_rcar_priv *p = container_of(gc, struct gpio_rcar_priv,\r\ngpio_chip);\r\nint error;\r\nif (p->irq_parent) {\r\nerror = irq_set_irq_wake(p->irq_parent, on);\r\nif (error) {\r\ndev_dbg(&p->pdev->dev,\r\n"irq %u doesn't support irq_set_wake\n",\r\np->irq_parent);\r\np->irq_parent = 0;\r\n}\r\n}\r\nif (!p->clk)\r\nreturn 0;\r\nif (on)\r\nclk_enable(p->clk);\r\nelse\r\nclk_disable(p->clk);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t gpio_rcar_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct gpio_rcar_priv *p = dev_id;\r\nu32 pending;\r\nunsigned int offset, irqs_handled = 0;\r\nwhile ((pending = gpio_rcar_read(p, INTDT) &\r\ngpio_rcar_read(p, INTMSK))) {\r\noffset = __ffs(pending);\r\ngpio_rcar_write(p, INTCLR, BIT(offset));\r\ngeneric_handle_irq(irq_find_mapping(p->gpio_chip.irqdomain,\r\noffset));\r\nirqs_handled++;\r\n}\r\nreturn irqs_handled ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic inline struct gpio_rcar_priv *gpio_to_priv(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct gpio_rcar_priv, gpio_chip);\r\n}\r\nstatic void gpio_rcar_config_general_input_output_mode(struct gpio_chip *chip,\r\nunsigned int gpio,\r\nbool output)\r\n{\r\nstruct gpio_rcar_priv *p = gpio_to_priv(chip);\r\nunsigned long flags;\r\nspin_lock_irqsave(&p->lock, flags);\r\ngpio_rcar_modify_bit(p, POSNEG, gpio, false);\r\ngpio_rcar_modify_bit(p, IOINTSEL, gpio, false);\r\ngpio_rcar_modify_bit(p, INOUTSEL, gpio, output);\r\nspin_unlock_irqrestore(&p->lock, flags);\r\n}\r\nstatic int gpio_rcar_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_rcar_priv *p = gpio_to_priv(chip);\r\nint error;\r\nerror = pm_runtime_get_sync(&p->pdev->dev);\r\nif (error < 0)\r\nreturn error;\r\nerror = pinctrl_request_gpio(chip->base + offset);\r\nif (error)\r\npm_runtime_put(&p->pdev->dev);\r\nreturn error;\r\n}\r\nstatic void gpio_rcar_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_rcar_priv *p = gpio_to_priv(chip);\r\npinctrl_free_gpio(chip->base + offset);\r\ngpio_rcar_config_general_input_output_mode(chip, offset, false);\r\npm_runtime_put(&p->pdev->dev);\r\n}\r\nstatic int gpio_rcar_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\ngpio_rcar_config_general_input_output_mode(chip, offset, false);\r\nreturn 0;\r\n}\r\nstatic int gpio_rcar_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nu32 bit = BIT(offset);\r\nif (gpio_rcar_read(gpio_to_priv(chip), INOUTSEL) & bit)\r\nreturn !!(gpio_rcar_read(gpio_to_priv(chip), OUTDT) & bit);\r\nelse\r\nreturn !!(gpio_rcar_read(gpio_to_priv(chip), INDT) & bit);\r\n}\r\nstatic void gpio_rcar_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct gpio_rcar_priv *p = gpio_to_priv(chip);\r\nunsigned long flags;\r\nspin_lock_irqsave(&p->lock, flags);\r\ngpio_rcar_modify_bit(p, OUTDT, offset, value);\r\nspin_unlock_irqrestore(&p->lock, flags);\r\n}\r\nstatic int gpio_rcar_direction_output(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\ngpio_rcar_set(chip, offset, value);\r\ngpio_rcar_config_general_input_output_mode(chip, offset, true);\r\nreturn 0;\r\n}\r\nstatic int gpio_rcar_parse_pdata(struct gpio_rcar_priv *p)\r\n{\r\nstruct gpio_rcar_config *pdata = dev_get_platdata(&p->pdev->dev);\r\nstruct device_node *np = p->pdev->dev.of_node;\r\nstruct of_phandle_args args;\r\nint ret;\r\nif (pdata) {\r\np->config = *pdata;\r\n} else if (IS_ENABLED(CONFIG_OF) && np) {\r\nconst struct of_device_id *match;\r\nconst struct gpio_rcar_info *info;\r\nmatch = of_match_node(gpio_rcar_of_table, np);\r\nif (!match)\r\nreturn -EINVAL;\r\ninfo = match->data;\r\nret = of_parse_phandle_with_fixed_args(np, "gpio-ranges", 3, 0,\r\n&args);\r\np->config.number_of_pins = ret == 0 ? args.args[2]\r\n: RCAR_MAX_GPIO_PER_BANK;\r\np->config.gpio_base = -1;\r\np->config.has_both_edge_trigger = info->has_both_edge_trigger;\r\n}\r\nif (p->config.number_of_pins == 0 ||\r\np->config.number_of_pins > RCAR_MAX_GPIO_PER_BANK) {\r\ndev_warn(&p->pdev->dev,\r\n"Invalid number of gpio lines %u, using %u\n",\r\np->config.number_of_pins, RCAR_MAX_GPIO_PER_BANK);\r\np->config.number_of_pins = RCAR_MAX_GPIO_PER_BANK;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpio_rcar_probe(struct platform_device *pdev)\r\n{\r\nstruct gpio_rcar_priv *p;\r\nstruct resource *io, *irq;\r\nstruct gpio_chip *gpio_chip;\r\nstruct irq_chip *irq_chip;\r\nstruct device *dev = &pdev->dev;\r\nconst char *name = dev_name(dev);\r\nint ret;\r\np = devm_kzalloc(dev, sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\np->pdev = pdev;\r\nspin_lock_init(&p->lock);\r\nret = gpio_rcar_parse_pdata(p);\r\nif (ret < 0)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, p);\r\np->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(p->clk)) {\r\ndev_warn(dev, "unable to get clock\n");\r\np->clk = NULL;\r\n}\r\npm_runtime_enable(dev);\r\nio = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!io || !irq) {\r\ndev_err(dev, "missing IRQ or IOMEM\n");\r\nret = -EINVAL;\r\ngoto err0;\r\n}\r\np->base = devm_ioremap_nocache(dev, io->start, resource_size(io));\r\nif (!p->base) {\r\ndev_err(dev, "failed to remap I/O memory\n");\r\nret = -ENXIO;\r\ngoto err0;\r\n}\r\ngpio_chip = &p->gpio_chip;\r\ngpio_chip->request = gpio_rcar_request;\r\ngpio_chip->free = gpio_rcar_free;\r\ngpio_chip->direction_input = gpio_rcar_direction_input;\r\ngpio_chip->get = gpio_rcar_get;\r\ngpio_chip->direction_output = gpio_rcar_direction_output;\r\ngpio_chip->set = gpio_rcar_set;\r\ngpio_chip->label = name;\r\ngpio_chip->dev = dev;\r\ngpio_chip->owner = THIS_MODULE;\r\ngpio_chip->base = p->config.gpio_base;\r\ngpio_chip->ngpio = p->config.number_of_pins;\r\nirq_chip = &p->irq_chip;\r\nirq_chip->name = name;\r\nirq_chip->irq_mask = gpio_rcar_irq_disable;\r\nirq_chip->irq_unmask = gpio_rcar_irq_enable;\r\nirq_chip->irq_set_type = gpio_rcar_irq_set_type;\r\nirq_chip->irq_set_wake = gpio_rcar_irq_set_wake;\r\nirq_chip->flags = IRQCHIP_SET_TYPE_MASKED | IRQCHIP_MASK_ON_SUSPEND;\r\nret = gpiochip_add(gpio_chip);\r\nif (ret) {\r\ndev_err(dev, "failed to add GPIO controller\n");\r\ngoto err0;\r\n}\r\nret = gpiochip_irqchip_add(gpio_chip, irq_chip, p->config.irq_base,\r\nhandle_level_irq, IRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(dev, "cannot add irqchip\n");\r\ngoto err1;\r\n}\r\np->irq_parent = irq->start;\r\nif (devm_request_irq(dev, irq->start, gpio_rcar_irq_handler,\r\nIRQF_SHARED, name, p)) {\r\ndev_err(dev, "failed to request IRQ\n");\r\nret = -ENOENT;\r\ngoto err1;\r\n}\r\ndev_info(dev, "driving %d GPIOs\n", p->config.number_of_pins);\r\nif (p->config.irq_base) {\r\nret = irq_find_mapping(gpio_chip->irqdomain, 0);\r\nif (p->config.irq_base != ret)\r\ndev_warn(dev, "irq base mismatch (%u/%u)\n",\r\np->config.irq_base, ret);\r\n}\r\nif (p->config.pctl_name) {\r\nret = gpiochip_add_pin_range(gpio_chip, p->config.pctl_name, 0,\r\ngpio_chip->base, gpio_chip->ngpio);\r\nif (ret < 0)\r\ndev_warn(dev, "failed to add pin range\n");\r\n}\r\nreturn 0;\r\nerr1:\r\ngpiochip_remove(gpio_chip);\r\nerr0:\r\npm_runtime_disable(dev);\r\nreturn ret;\r\n}\r\nstatic int gpio_rcar_remove(struct platform_device *pdev)\r\n{\r\nstruct gpio_rcar_priv *p = platform_get_drvdata(pdev);\r\ngpiochip_remove(&p->gpio_chip);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}
