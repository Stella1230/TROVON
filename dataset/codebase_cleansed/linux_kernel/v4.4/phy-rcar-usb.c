static int rcar_usb_phy_init(struct usb_phy *phy)\r\n{\r\nstruct rcar_usb_phy_priv *priv = usb_phy_to_priv(phy);\r\nstruct device *dev = phy->dev;\r\nstruct rcar_phy_platform_data *pdata = dev_get_platdata(dev);\r\nvoid __iomem *reg0 = priv->reg0;\r\nvoid __iomem *reg1 = priv->reg1;\r\nstatic const u8 ovcn_act[] = { OVC0_ACT, OVC1_ACT, OVC2_ACT };\r\nint i;\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->counter++ == 0) {\r\niowrite32(PHY_ENB, (reg0 + USBPCTRL1));\r\niowrite32(PHY_ENB | PLL_ENB, (reg0 + USBPCTRL1));\r\nif (reg1) {\r\nu32 hsqctl1 = pdata->ferrite_bead ? 0x41 : 0;\r\nu32 hsqctl2 = pdata->ferrite_bead ? 0x0d : 7;\r\niowrite32(hsqctl1, reg1 + HSQCTL1);\r\niowrite32(hsqctl2, reg1 + HSQCTL2);\r\n}\r\nfor (i = 0; i < 1024; i++) {\r\nudelay(10);\r\nval = ioread32(reg0 + USBST);\r\nif (val == (ST_ACT | ST_PLL))\r\nbreak;\r\n}\r\nif (val != (ST_ACT | ST_PLL)) {\r\ndev_err(dev, "USB phy not ready\n");\r\ngoto phy_init_end;\r\n}\r\niowrite32(PHY_ENB | PLL_ENB | PHY_RST, (reg0 + USBPCTRL1));\r\nval = 0;\r\nif (pdata->port1_func)\r\nval |= PORT1;\r\nif (pdata->penc1)\r\nval |= PENC;\r\nfor (i = 0; i < 3; i++) {\r\nif (pdata->ovc_pin[i].select_3_3v)\r\nval |= OVC0 << i;\r\nif (pdata->ovc_pin[i].active_high)\r\nval |= ovcn_act[i];\r\n}\r\niowrite32(val, (reg0 + USBPCTRL0));\r\niowrite32(0x00000000, (reg0 + USBEH0));\r\niowrite32(0x00000000, (reg0 + USBOH0));\r\n}\r\nphy_init_end:\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void rcar_usb_phy_shutdown(struct usb_phy *phy)\r\n{\r\nstruct rcar_usb_phy_priv *priv = usb_phy_to_priv(phy);\r\nvoid __iomem *reg0 = priv->reg0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->counter-- == 1)\r\niowrite32(0x00000000, (reg0 + USBPCTRL1));\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic int rcar_usb_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct rcar_usb_phy_priv *priv;\r\nstruct resource *res0, *res1;\r\nstruct device *dev = &pdev->dev;\r\nvoid __iomem *reg0, *reg1 = NULL;\r\nint ret;\r\nif (!dev_get_platdata(&pdev->dev)) {\r\ndev_err(dev, "No platform data\n");\r\nreturn -EINVAL;\r\n}\r\nres0 = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nreg0 = devm_ioremap_resource(dev, res0);\r\nif (IS_ERR(reg0))\r\nreturn PTR_ERR(reg0);\r\nres1 = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nreg1 = devm_ioremap_resource(dev, res1);\r\nif (IS_ERR(reg1))\r\nreturn PTR_ERR(reg1);\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->reg0 = reg0;\r\npriv->reg1 = reg1;\r\npriv->counter = 0;\r\npriv->phy.dev = dev;\r\npriv->phy.label = dev_name(dev);\r\npriv->phy.init = rcar_usb_phy_init;\r\npriv->phy.shutdown = rcar_usb_phy_shutdown;\r\nspin_lock_init(&priv->lock);\r\nret = usb_add_phy(&priv->phy, USB_PHY_TYPE_USB2);\r\nif (ret < 0) {\r\ndev_err(dev, "usb phy addition error\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nreturn ret;\r\n}\r\nstatic int rcar_usb_phy_remove(struct platform_device *pdev)\r\n{\r\nstruct rcar_usb_phy_priv *priv = platform_get_drvdata(pdev);\r\nusb_remove_phy(&priv->phy);\r\nreturn 0;\r\n}
