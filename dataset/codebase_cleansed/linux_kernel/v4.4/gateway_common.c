static bool batadv_parse_gw_bandwidth(struct net_device *net_dev, char *buff,\r\nu32 *down, u32 *up)\r\n{\r\nenum batadv_bandwidth_units bw_unit_type = BATADV_BW_UNIT_KBIT;\r\nchar *slash_ptr, *tmp_ptr;\r\nu64 ldown, lup;\r\nint ret;\r\nslash_ptr = strchr(buff, '/');\r\nif (slash_ptr)\r\n*slash_ptr = 0;\r\nif (strlen(buff) > 4) {\r\ntmp_ptr = buff + strlen(buff) - 4;\r\nif (strncasecmp(tmp_ptr, "mbit", 4) == 0)\r\nbw_unit_type = BATADV_BW_UNIT_MBIT;\r\nif ((strncasecmp(tmp_ptr, "kbit", 4) == 0) ||\r\n(bw_unit_type == BATADV_BW_UNIT_MBIT))\r\n*tmp_ptr = '\0';\r\n}\r\nret = kstrtou64(buff, 10, &ldown);\r\nif (ret) {\r\nbatadv_err(net_dev,\r\n"Download speed of gateway mode invalid: %s\n",\r\nbuff);\r\nreturn false;\r\n}\r\nswitch (bw_unit_type) {\r\ncase BATADV_BW_UNIT_MBIT:\r\nif (U64_MAX / 10 < ldown) {\r\nbatadv_err(net_dev,\r\n"Download speed of gateway mode too large: %s\n",\r\nbuff);\r\nreturn false;\r\n}\r\nldown *= 10;\r\nbreak;\r\ncase BATADV_BW_UNIT_KBIT:\r\ndefault:\r\nldown = div_u64(ldown, 100);\r\nbreak;\r\n}\r\nif (U32_MAX < ldown) {\r\nbatadv_err(net_dev,\r\n"Download speed of gateway mode too large: %s\n",\r\nbuff);\r\nreturn false;\r\n}\r\n*down = ldown;\r\nif (slash_ptr) {\r\nbw_unit_type = BATADV_BW_UNIT_KBIT;\r\nif (strlen(slash_ptr + 1) > 4) {\r\ntmp_ptr = slash_ptr + 1 - 4 + strlen(slash_ptr + 1);\r\nif (strncasecmp(tmp_ptr, "mbit", 4) == 0)\r\nbw_unit_type = BATADV_BW_UNIT_MBIT;\r\nif ((strncasecmp(tmp_ptr, "kbit", 4) == 0) ||\r\n(bw_unit_type == BATADV_BW_UNIT_MBIT))\r\n*tmp_ptr = '\0';\r\n}\r\nret = kstrtou64(slash_ptr + 1, 10, &lup);\r\nif (ret) {\r\nbatadv_err(net_dev,\r\n"Upload speed of gateway mode invalid: %s\n",\r\nslash_ptr + 1);\r\nreturn false;\r\n}\r\nswitch (bw_unit_type) {\r\ncase BATADV_BW_UNIT_MBIT:\r\nif (U64_MAX / 10 < lup) {\r\nbatadv_err(net_dev,\r\n"Upload speed of gateway mode too large: %s\n",\r\nslash_ptr + 1);\r\nreturn false;\r\n}\r\nlup *= 10;\r\nbreak;\r\ncase BATADV_BW_UNIT_KBIT:\r\ndefault:\r\nlup = div_u64(lup, 100);\r\nbreak;\r\n}\r\nif (U32_MAX < lup) {\r\nbatadv_err(net_dev,\r\n"Upload speed of gateway mode too large: %s\n",\r\nslash_ptr + 1);\r\nreturn false;\r\n}\r\n*up = lup;\r\n}\r\nreturn true;\r\n}\r\nvoid batadv_gw_tvlv_container_update(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_tvlv_gateway_data gw;\r\nu32 down, up;\r\nchar gw_mode;\r\ngw_mode = atomic_read(&bat_priv->gw_mode);\r\nswitch (gw_mode) {\r\ncase BATADV_GW_MODE_OFF:\r\ncase BATADV_GW_MODE_CLIENT:\r\nbatadv_tvlv_container_unregister(bat_priv, BATADV_TVLV_GW, 1);\r\nbreak;\r\ncase BATADV_GW_MODE_SERVER:\r\ndown = atomic_read(&bat_priv->gw.bandwidth_down);\r\nup = atomic_read(&bat_priv->gw.bandwidth_up);\r\ngw.bandwidth_down = htonl(down);\r\ngw.bandwidth_up = htonl(up);\r\nbatadv_tvlv_container_register(bat_priv, BATADV_TVLV_GW, 1,\r\n&gw, sizeof(gw));\r\nbreak;\r\n}\r\n}\r\nssize_t batadv_gw_bandwidth_set(struct net_device *net_dev, char *buff,\r\nsize_t count)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(net_dev);\r\nu32 down_curr;\r\nu32 up_curr;\r\nu32 down_new = 0;\r\nu32 up_new = 0;\r\nbool ret;\r\ndown_curr = (unsigned int)atomic_read(&bat_priv->gw.bandwidth_down);\r\nup_curr = (unsigned int)atomic_read(&bat_priv->gw.bandwidth_up);\r\nret = batadv_parse_gw_bandwidth(net_dev, buff, &down_new, &up_new);\r\nif (!ret)\r\nreturn -EINVAL;\r\nif (!down_new)\r\ndown_new = 1;\r\nif (!up_new)\r\nup_new = down_new / 5;\r\nif (!up_new)\r\nup_new = 1;\r\nif ((down_curr == down_new) && (up_curr == up_new))\r\nreturn count;\r\nbatadv_gw_reselect(bat_priv);\r\nbatadv_info(net_dev,\r\n"Changing gateway bandwidth from: '%u.%u/%u.%u MBit' to: '%u.%u/%u.%u MBit'\n",\r\ndown_curr / 10, down_curr % 10, up_curr / 10, up_curr % 10,\r\ndown_new / 10, down_new % 10, up_new / 10, up_new % 10);\r\natomic_set(&bat_priv->gw.bandwidth_down, down_new);\r\natomic_set(&bat_priv->gw.bandwidth_up, up_new);\r\nbatadv_gw_tvlv_container_update(bat_priv);\r\nreturn count;\r\n}\r\nstatic void batadv_gw_tvlv_ogm_handler_v1(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig,\r\nu8 flags,\r\nvoid *tvlv_value, u16 tvlv_value_len)\r\n{\r\nstruct batadv_tvlv_gateway_data gateway, *gateway_ptr;\r\nif ((flags & BATADV_TVLV_HANDLER_OGM_CIFNOTFND) ||\r\n(tvlv_value_len < sizeof(gateway))) {\r\ngateway.bandwidth_down = 0;\r\ngateway.bandwidth_up = 0;\r\n} else {\r\ngateway_ptr = tvlv_value;\r\ngateway.bandwidth_down = gateway_ptr->bandwidth_down;\r\ngateway.bandwidth_up = gateway_ptr->bandwidth_up;\r\nif ((gateway.bandwidth_down == 0) ||\r\n(gateway.bandwidth_up == 0)) {\r\ngateway.bandwidth_down = 0;\r\ngateway.bandwidth_up = 0;\r\n}\r\n}\r\nbatadv_gw_node_update(bat_priv, orig, &gateway);\r\nif ((gateway.bandwidth_down != 0) &&\r\n(atomic_read(&bat_priv->gw_mode) == BATADV_GW_MODE_CLIENT) &&\r\n(atomic_read(&bat_priv->gw_sel_class) > 2))\r\nbatadv_gw_check_election(bat_priv, orig);\r\n}\r\nvoid batadv_gw_init(struct batadv_priv *bat_priv)\r\n{\r\nbatadv_tvlv_handler_register(bat_priv, batadv_gw_tvlv_ogm_handler_v1,\r\nNULL, BATADV_TVLV_GW, 1,\r\nBATADV_TVLV_HANDLER_OGM_CIFNOTFND);\r\n}\r\nvoid batadv_gw_free(struct batadv_priv *bat_priv)\r\n{\r\nbatadv_tvlv_container_unregister(bat_priv, BATADV_TVLV_GW, 1);\r\nbatadv_tvlv_handler_unregister(bat_priv, BATADV_TVLV_GW, 1);\r\n}
