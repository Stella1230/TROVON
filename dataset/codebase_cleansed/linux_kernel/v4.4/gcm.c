static inline struct crypto_gcm_req_priv_ctx *crypto_gcm_reqctx(\r\nstruct aead_request *req)\r\n{\r\nunsigned long align = crypto_aead_alignmask(crypto_aead_reqtfm(req));\r\nreturn (void *)PTR_ALIGN((u8 *)aead_request_ctx(req), align + 1);\r\n}\r\nstatic void crypto_gcm_setkey_done(struct crypto_async_request *req, int err)\r\n{\r\nstruct crypto_gcm_setkey_result *result = req->data;\r\nif (err == -EINPROGRESS)\r\nreturn;\r\nresult->err = err;\r\ncomplete(&result->completion);\r\n}\r\nstatic int crypto_gcm_setkey(struct crypto_aead *aead, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_gcm_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_ahash *ghash = ctx->ghash;\r\nstruct crypto_ablkcipher *ctr = ctx->ctr;\r\nstruct {\r\nbe128 hash;\r\nu8 iv[8];\r\nstruct crypto_gcm_setkey_result result;\r\nstruct scatterlist sg[1];\r\nstruct ablkcipher_request req;\r\n} *data;\r\nint err;\r\ncrypto_ablkcipher_clear_flags(ctr, CRYPTO_TFM_REQ_MASK);\r\ncrypto_ablkcipher_set_flags(ctr, crypto_aead_get_flags(aead) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_ablkcipher_setkey(ctr, key, keylen);\r\ncrypto_aead_set_flags(aead, crypto_ablkcipher_get_flags(ctr) &\r\nCRYPTO_TFM_RES_MASK);\r\nif (err)\r\nreturn err;\r\ndata = kzalloc(sizeof(*data) + crypto_ablkcipher_reqsize(ctr),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ninit_completion(&data->result.completion);\r\nsg_init_one(data->sg, &data->hash, sizeof(data->hash));\r\nablkcipher_request_set_tfm(&data->req, ctr);\r\nablkcipher_request_set_callback(&data->req, CRYPTO_TFM_REQ_MAY_SLEEP |\r\nCRYPTO_TFM_REQ_MAY_BACKLOG,\r\ncrypto_gcm_setkey_done,\r\n&data->result);\r\nablkcipher_request_set_crypt(&data->req, data->sg, data->sg,\r\nsizeof(data->hash), data->iv);\r\nerr = crypto_ablkcipher_encrypt(&data->req);\r\nif (err == -EINPROGRESS || err == -EBUSY) {\r\nerr = wait_for_completion_interruptible(\r\n&data->result.completion);\r\nif (!err)\r\nerr = data->result.err;\r\n}\r\nif (err)\r\ngoto out;\r\ncrypto_ahash_clear_flags(ghash, CRYPTO_TFM_REQ_MASK);\r\ncrypto_ahash_set_flags(ghash, crypto_aead_get_flags(aead) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_ahash_setkey(ghash, (u8 *)&data->hash, sizeof(be128));\r\ncrypto_aead_set_flags(aead, crypto_ahash_get_flags(ghash) &\r\nCRYPTO_TFM_RES_MASK);\r\nout:\r\nkzfree(data);\r\nreturn err;\r\n}\r\nstatic int crypto_gcm_setauthsize(struct crypto_aead *tfm,\r\nunsigned int authsize)\r\n{\r\nswitch (authsize) {\r\ncase 4:\r\ncase 8:\r\ncase 12:\r\ncase 13:\r\ncase 14:\r\ncase 15:\r\ncase 16:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void crypto_gcm_init_common(struct aead_request *req)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\n__be32 counter = cpu_to_be32(1);\r\nstruct scatterlist *sg;\r\nmemset(pctx->auth_tag, 0, sizeof(pctx->auth_tag));\r\nmemcpy(pctx->iv, req->iv, 12);\r\nmemcpy(pctx->iv + 12, &counter, 4);\r\nsg_init_table(pctx->src, 3);\r\nsg_set_buf(pctx->src, pctx->auth_tag, sizeof(pctx->auth_tag));\r\nsg = scatterwalk_ffwd(pctx->src + 1, req->src, req->assoclen);\r\nif (sg != pctx->src + 1)\r\nsg_chain(pctx->src, 2, sg);\r\nif (req->src != req->dst) {\r\nsg_init_table(pctx->dst, 3);\r\nsg_set_buf(pctx->dst, pctx->auth_tag, sizeof(pctx->auth_tag));\r\nsg = scatterwalk_ffwd(pctx->dst + 1, req->dst, req->assoclen);\r\nif (sg != pctx->dst + 1)\r\nsg_chain(pctx->dst, 2, sg);\r\n}\r\n}\r\nstatic void crypto_gcm_init_crypt(struct aead_request *req,\r\nunsigned int cryptlen)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_gcm_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct ablkcipher_request *ablk_req = &pctx->u.abreq;\r\nstruct scatterlist *dst;\r\ndst = req->src == req->dst ? pctx->src : pctx->dst;\r\nablkcipher_request_set_tfm(ablk_req, ctx->ctr);\r\nablkcipher_request_set_crypt(ablk_req, pctx->src, dst,\r\ncryptlen + sizeof(pctx->auth_tag),\r\npctx->iv);\r\n}\r\nstatic inline unsigned int gcm_remain(unsigned int len)\r\n{\r\nlen &= 0xfU;\r\nreturn len ? 16 - len : 0;\r\n}\r\nstatic int gcm_hash_update(struct aead_request *req,\r\ncrypto_completion_t compl,\r\nstruct scatterlist *src,\r\nunsigned int len, u32 flags)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct ahash_request *ahreq = &pctx->u.ahreq;\r\nahash_request_set_callback(ahreq, flags, compl, req);\r\nahash_request_set_crypt(ahreq, src, NULL, len);\r\nreturn crypto_ahash_update(ahreq);\r\n}\r\nstatic int gcm_hash_remain(struct aead_request *req,\r\nunsigned int remain,\r\ncrypto_completion_t compl, u32 flags)\r\n{\r\nreturn gcm_hash_update(req, compl, &gcm_zeroes->sg, remain, flags);\r\n}\r\nstatic int gcm_hash_len(struct aead_request *req, u32 flags)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct ahash_request *ahreq = &pctx->u.ahreq;\r\nstruct crypto_gcm_ghash_ctx *gctx = &pctx->ghash_ctx;\r\nu128 lengths;\r\nlengths.a = cpu_to_be64(req->assoclen * 8);\r\nlengths.b = cpu_to_be64(gctx->cryptlen * 8);\r\nmemcpy(pctx->iauth_tag, &lengths, 16);\r\nsg_init_one(&pctx->sg, pctx->iauth_tag, 16);\r\nahash_request_set_callback(ahreq, flags, gcm_hash_len_done, req);\r\nahash_request_set_crypt(ahreq, &pctx->sg,\r\npctx->iauth_tag, sizeof(lengths));\r\nreturn crypto_ahash_finup(ahreq);\r\n}\r\nstatic int gcm_hash_len_continue(struct aead_request *req, u32 flags)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct crypto_gcm_ghash_ctx *gctx = &pctx->ghash_ctx;\r\nreturn gctx->complete(req, flags);\r\n}\r\nstatic void gcm_hash_len_done(struct crypto_async_request *areq, int err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nif (err)\r\ngoto out;\r\nerr = gcm_hash_len_continue(req, 0);\r\nif (err == -EINPROGRESS)\r\nreturn;\r\nout:\r\naead_request_complete(req, err);\r\n}\r\nstatic int gcm_hash_crypt_remain_continue(struct aead_request *req, u32 flags)\r\n{\r\nreturn gcm_hash_len(req, flags) ?:\r\ngcm_hash_len_continue(req, flags);\r\n}\r\nstatic void gcm_hash_crypt_remain_done(struct crypto_async_request *areq,\r\nint err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nif (err)\r\ngoto out;\r\nerr = gcm_hash_crypt_remain_continue(req, 0);\r\nif (err == -EINPROGRESS)\r\nreturn;\r\nout:\r\naead_request_complete(req, err);\r\n}\r\nstatic int gcm_hash_crypt_continue(struct aead_request *req, u32 flags)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct crypto_gcm_ghash_ctx *gctx = &pctx->ghash_ctx;\r\nunsigned int remain;\r\nremain = gcm_remain(gctx->cryptlen);\r\nif (remain)\r\nreturn gcm_hash_remain(req, remain,\r\ngcm_hash_crypt_remain_done, flags) ?:\r\ngcm_hash_crypt_remain_continue(req, flags);\r\nreturn gcm_hash_crypt_remain_continue(req, flags);\r\n}\r\nstatic void gcm_hash_crypt_done(struct crypto_async_request *areq, int err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nif (err)\r\ngoto out;\r\nerr = gcm_hash_crypt_continue(req, 0);\r\nif (err == -EINPROGRESS)\r\nreturn;\r\nout:\r\naead_request_complete(req, err);\r\n}\r\nstatic int gcm_hash_assoc_remain_continue(struct aead_request *req, u32 flags)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct crypto_gcm_ghash_ctx *gctx = &pctx->ghash_ctx;\r\nif (gctx->cryptlen)\r\nreturn gcm_hash_update(req, gcm_hash_crypt_done,\r\ngctx->src, gctx->cryptlen, flags) ?:\r\ngcm_hash_crypt_continue(req, flags);\r\nreturn gcm_hash_crypt_remain_continue(req, flags);\r\n}\r\nstatic void gcm_hash_assoc_remain_done(struct crypto_async_request *areq,\r\nint err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nif (err)\r\ngoto out;\r\nerr = gcm_hash_assoc_remain_continue(req, 0);\r\nif (err == -EINPROGRESS)\r\nreturn;\r\nout:\r\naead_request_complete(req, err);\r\n}\r\nstatic int gcm_hash_assoc_continue(struct aead_request *req, u32 flags)\r\n{\r\nunsigned int remain;\r\nremain = gcm_remain(req->assoclen);\r\nif (remain)\r\nreturn gcm_hash_remain(req, remain,\r\ngcm_hash_assoc_remain_done, flags) ?:\r\ngcm_hash_assoc_remain_continue(req, flags);\r\nreturn gcm_hash_assoc_remain_continue(req, flags);\r\n}\r\nstatic void gcm_hash_assoc_done(struct crypto_async_request *areq, int err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nif (err)\r\ngoto out;\r\nerr = gcm_hash_assoc_continue(req, 0);\r\nif (err == -EINPROGRESS)\r\nreturn;\r\nout:\r\naead_request_complete(req, err);\r\n}\r\nstatic int gcm_hash_init_continue(struct aead_request *req, u32 flags)\r\n{\r\nif (req->assoclen)\r\nreturn gcm_hash_update(req, gcm_hash_assoc_done,\r\nreq->src, req->assoclen, flags) ?:\r\ngcm_hash_assoc_continue(req, flags);\r\nreturn gcm_hash_assoc_remain_continue(req, flags);\r\n}\r\nstatic void gcm_hash_init_done(struct crypto_async_request *areq, int err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nif (err)\r\ngoto out;\r\nerr = gcm_hash_init_continue(req, 0);\r\nif (err == -EINPROGRESS)\r\nreturn;\r\nout:\r\naead_request_complete(req, err);\r\n}\r\nstatic int gcm_hash(struct aead_request *req, u32 flags)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct ahash_request *ahreq = &pctx->u.ahreq;\r\nstruct crypto_gcm_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\r\nahash_request_set_tfm(ahreq, ctx->ghash);\r\nahash_request_set_callback(ahreq, flags, gcm_hash_init_done, req);\r\nreturn crypto_ahash_init(ahreq) ?:\r\ngcm_hash_init_continue(req, flags);\r\n}\r\nstatic int gcm_enc_copy_hash(struct aead_request *req, u32 flags)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nu8 *auth_tag = pctx->auth_tag;\r\ncrypto_xor(auth_tag, pctx->iauth_tag, 16);\r\nscatterwalk_map_and_copy(auth_tag, req->dst,\r\nreq->assoclen + req->cryptlen,\r\ncrypto_aead_authsize(aead), 1);\r\nreturn 0;\r\n}\r\nstatic int gcm_encrypt_continue(struct aead_request *req, u32 flags)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct crypto_gcm_ghash_ctx *gctx = &pctx->ghash_ctx;\r\ngctx->src = sg_next(req->src == req->dst ? pctx->src : pctx->dst);\r\ngctx->cryptlen = req->cryptlen;\r\ngctx->complete = gcm_enc_copy_hash;\r\nreturn gcm_hash(req, flags);\r\n}\r\nstatic void gcm_encrypt_done(struct crypto_async_request *areq, int err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nif (err)\r\ngoto out;\r\nerr = gcm_encrypt_continue(req, 0);\r\nif (err == -EINPROGRESS)\r\nreturn;\r\nout:\r\naead_request_complete(req, err);\r\n}\r\nstatic int crypto_gcm_encrypt(struct aead_request *req)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct ablkcipher_request *abreq = &pctx->u.abreq;\r\nu32 flags = aead_request_flags(req);\r\ncrypto_gcm_init_common(req);\r\ncrypto_gcm_init_crypt(req, req->cryptlen);\r\nablkcipher_request_set_callback(abreq, flags, gcm_encrypt_done, req);\r\nreturn crypto_ablkcipher_encrypt(abreq) ?:\r\ngcm_encrypt_continue(req, flags);\r\n}\r\nstatic int crypto_gcm_verify(struct aead_request *req)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nu8 *auth_tag = pctx->auth_tag;\r\nu8 *iauth_tag = pctx->iauth_tag;\r\nunsigned int authsize = crypto_aead_authsize(aead);\r\nunsigned int cryptlen = req->cryptlen - authsize;\r\ncrypto_xor(auth_tag, iauth_tag, 16);\r\nscatterwalk_map_and_copy(iauth_tag, req->src,\r\nreq->assoclen + cryptlen, authsize, 0);\r\nreturn crypto_memneq(iauth_tag, auth_tag, authsize) ? -EBADMSG : 0;\r\n}\r\nstatic void gcm_decrypt_done(struct crypto_async_request *areq, int err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nif (!err)\r\nerr = crypto_gcm_verify(req);\r\naead_request_complete(req, err);\r\n}\r\nstatic int gcm_dec_hash_continue(struct aead_request *req, u32 flags)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct ablkcipher_request *abreq = &pctx->u.abreq;\r\nstruct crypto_gcm_ghash_ctx *gctx = &pctx->ghash_ctx;\r\ncrypto_gcm_init_crypt(req, gctx->cryptlen);\r\nablkcipher_request_set_callback(abreq, flags, gcm_decrypt_done, req);\r\nreturn crypto_ablkcipher_decrypt(abreq) ?: crypto_gcm_verify(req);\r\n}\r\nstatic int crypto_gcm_decrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct crypto_gcm_ghash_ctx *gctx = &pctx->ghash_ctx;\r\nunsigned int authsize = crypto_aead_authsize(aead);\r\nunsigned int cryptlen = req->cryptlen;\r\nu32 flags = aead_request_flags(req);\r\ncryptlen -= authsize;\r\ncrypto_gcm_init_common(req);\r\ngctx->src = sg_next(pctx->src);\r\ngctx->cryptlen = cryptlen;\r\ngctx->complete = gcm_dec_hash_continue;\r\nreturn gcm_hash(req, flags);\r\n}\r\nstatic int crypto_gcm_init_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct aead_instance *inst = aead_alg_instance(tfm);\r\nstruct gcm_instance_ctx *ictx = aead_instance_ctx(inst);\r\nstruct crypto_gcm_ctx *ctx = crypto_aead_ctx(tfm);\r\nstruct crypto_ablkcipher *ctr;\r\nstruct crypto_ahash *ghash;\r\nunsigned long align;\r\nint err;\r\nghash = crypto_spawn_ahash(&ictx->ghash);\r\nif (IS_ERR(ghash))\r\nreturn PTR_ERR(ghash);\r\nctr = crypto_spawn_skcipher(&ictx->ctr);\r\nerr = PTR_ERR(ctr);\r\nif (IS_ERR(ctr))\r\ngoto err_free_hash;\r\nctx->ctr = ctr;\r\nctx->ghash = ghash;\r\nalign = crypto_aead_alignmask(tfm);\r\nalign &= ~(crypto_tfm_ctx_alignment() - 1);\r\ncrypto_aead_set_reqsize(tfm,\r\nalign + offsetof(struct crypto_gcm_req_priv_ctx, u) +\r\nmax(sizeof(struct ablkcipher_request) +\r\ncrypto_ablkcipher_reqsize(ctr),\r\nsizeof(struct ahash_request) +\r\ncrypto_ahash_reqsize(ghash)));\r\nreturn 0;\r\nerr_free_hash:\r\ncrypto_free_ahash(ghash);\r\nreturn err;\r\n}\r\nstatic void crypto_gcm_exit_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct crypto_gcm_ctx *ctx = crypto_aead_ctx(tfm);\r\ncrypto_free_ahash(ctx->ghash);\r\ncrypto_free_ablkcipher(ctx->ctr);\r\n}\r\nstatic void crypto_gcm_free(struct aead_instance *inst)\r\n{\r\nstruct gcm_instance_ctx *ctx = aead_instance_ctx(inst);\r\ncrypto_drop_skcipher(&ctx->ctr);\r\ncrypto_drop_ahash(&ctx->ghash);\r\nkfree(inst);\r\n}\r\nstatic int crypto_gcm_create_common(struct crypto_template *tmpl,\r\nstruct rtattr **tb,\r\nconst char *full_name,\r\nconst char *ctr_name,\r\nconst char *ghash_name)\r\n{\r\nstruct crypto_attr_type *algt;\r\nstruct aead_instance *inst;\r\nstruct crypto_alg *ctr;\r\nstruct crypto_alg *ghash_alg;\r\nstruct hash_alg_common *ghash;\r\nstruct gcm_instance_ctx *ctx;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn PTR_ERR(algt);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\r\nreturn -EINVAL;\r\nghash_alg = crypto_find_alg(ghash_name, &crypto_ahash_type,\r\nCRYPTO_ALG_TYPE_HASH,\r\nCRYPTO_ALG_TYPE_AHASH_MASK);\r\nif (IS_ERR(ghash_alg))\r\nreturn PTR_ERR(ghash_alg);\r\nghash = __crypto_hash_alg_common(ghash_alg);\r\nerr = -ENOMEM;\r\ninst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\r\nif (!inst)\r\ngoto out_put_ghash;\r\nctx = aead_instance_ctx(inst);\r\nerr = crypto_init_ahash_spawn(&ctx->ghash, ghash,\r\naead_crypto_instance(inst));\r\nif (err)\r\ngoto err_free_inst;\r\nerr = -EINVAL;\r\nif (ghash->digestsize != 16)\r\ngoto err_drop_ghash;\r\ncrypto_set_skcipher_spawn(&ctx->ctr, aead_crypto_instance(inst));\r\nerr = crypto_grab_skcipher(&ctx->ctr, ctr_name, 0,\r\ncrypto_requires_sync(algt->type,\r\nalgt->mask));\r\nif (err)\r\ngoto err_drop_ghash;\r\nctr = crypto_skcipher_spawn_alg(&ctx->ctr);\r\nif (ctr->cra_ablkcipher.ivsize != 16)\r\ngoto out_put_ctr;\r\nerr = -EINVAL;\r\nif (ctr->cra_blocksize != 1)\r\ngoto out_put_ctr;\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"gcm_base(%s,%s)", ctr->cra_driver_name,\r\nghash_alg->cra_driver_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\ngoto out_put_ctr;\r\nmemcpy(inst->alg.base.cra_name, full_name, CRYPTO_MAX_ALG_NAME);\r\ninst->alg.base.cra_flags = (ghash->base.cra_flags | ctr->cra_flags) &\r\nCRYPTO_ALG_ASYNC;\r\ninst->alg.base.cra_priority = (ghash->base.cra_priority +\r\nctr->cra_priority) / 2;\r\ninst->alg.base.cra_blocksize = 1;\r\ninst->alg.base.cra_alignmask = ghash->base.cra_alignmask |\r\nctr->cra_alignmask;\r\ninst->alg.base.cra_ctxsize = sizeof(struct crypto_gcm_ctx);\r\ninst->alg.ivsize = 12;\r\ninst->alg.maxauthsize = 16;\r\ninst->alg.init = crypto_gcm_init_tfm;\r\ninst->alg.exit = crypto_gcm_exit_tfm;\r\ninst->alg.setkey = crypto_gcm_setkey;\r\ninst->alg.setauthsize = crypto_gcm_setauthsize;\r\ninst->alg.encrypt = crypto_gcm_encrypt;\r\ninst->alg.decrypt = crypto_gcm_decrypt;\r\ninst->free = crypto_gcm_free;\r\nerr = aead_register_instance(tmpl, inst);\r\nif (err)\r\ngoto out_put_ctr;\r\nout_put_ghash:\r\ncrypto_mod_put(ghash_alg);\r\nreturn err;\r\nout_put_ctr:\r\ncrypto_drop_skcipher(&ctx->ctr);\r\nerr_drop_ghash:\r\ncrypto_drop_ahash(&ctx->ghash);\r\nerr_free_inst:\r\nkfree(inst);\r\ngoto out_put_ghash;\r\n}\r\nstatic int crypto_gcm_create(struct crypto_template *tmpl, struct rtattr **tb)\r\n{\r\nconst char *cipher_name;\r\nchar ctr_name[CRYPTO_MAX_ALG_NAME];\r\nchar full_name[CRYPTO_MAX_ALG_NAME];\r\ncipher_name = crypto_attr_alg_name(tb[1]);\r\nif (IS_ERR(cipher_name))\r\nreturn PTR_ERR(cipher_name);\r\nif (snprintf(ctr_name, CRYPTO_MAX_ALG_NAME, "ctr(%s)", cipher_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\nreturn -ENAMETOOLONG;\r\nif (snprintf(full_name, CRYPTO_MAX_ALG_NAME, "gcm(%s)", cipher_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\nreturn -ENAMETOOLONG;\r\nreturn crypto_gcm_create_common(tmpl, tb, full_name,\r\nctr_name, "ghash");\r\n}\r\nstatic int crypto_gcm_base_create(struct crypto_template *tmpl,\r\nstruct rtattr **tb)\r\n{\r\nconst char *ctr_name;\r\nconst char *ghash_name;\r\nchar full_name[CRYPTO_MAX_ALG_NAME];\r\nctr_name = crypto_attr_alg_name(tb[1]);\r\nif (IS_ERR(ctr_name))\r\nreturn PTR_ERR(ctr_name);\r\nghash_name = crypto_attr_alg_name(tb[2]);\r\nif (IS_ERR(ghash_name))\r\nreturn PTR_ERR(ghash_name);\r\nif (snprintf(full_name, CRYPTO_MAX_ALG_NAME, "gcm_base(%s,%s)",\r\nctr_name, ghash_name) >= CRYPTO_MAX_ALG_NAME)\r\nreturn -ENAMETOOLONG;\r\nreturn crypto_gcm_create_common(tmpl, tb, full_name,\r\nctr_name, ghash_name);\r\n}\r\nstatic int crypto_rfc4106_setkey(struct crypto_aead *parent, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_rfc4106_ctx *ctx = crypto_aead_ctx(parent);\r\nstruct crypto_aead *child = ctx->child;\r\nint err;\r\nif (keylen < 4)\r\nreturn -EINVAL;\r\nkeylen -= 4;\r\nmemcpy(ctx->nonce, key + keylen, 4);\r\ncrypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_aead_set_flags(child, crypto_aead_get_flags(parent) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_aead_setkey(child, key, keylen);\r\ncrypto_aead_set_flags(parent, crypto_aead_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic int crypto_rfc4106_setauthsize(struct crypto_aead *parent,\r\nunsigned int authsize)\r\n{\r\nstruct crypto_rfc4106_ctx *ctx = crypto_aead_ctx(parent);\r\nswitch (authsize) {\r\ncase 8:\r\ncase 12:\r\ncase 16:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn crypto_aead_setauthsize(ctx->child, authsize);\r\n}\r\nstatic struct aead_request *crypto_rfc4106_crypt(struct aead_request *req)\r\n{\r\nstruct crypto_rfc4106_req_ctx *rctx = aead_request_ctx(req);\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_rfc4106_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct aead_request *subreq = &rctx->subreq;\r\nstruct crypto_aead *child = ctx->child;\r\nstruct scatterlist *sg;\r\nu8 *iv = PTR_ALIGN((u8 *)(subreq + 1) + crypto_aead_reqsize(child),\r\ncrypto_aead_alignmask(child) + 1);\r\nscatterwalk_map_and_copy(iv + 12, req->src, 0, req->assoclen - 8, 0);\r\nmemcpy(iv, ctx->nonce, 4);\r\nmemcpy(iv + 4, req->iv, 8);\r\nsg_init_table(rctx->src, 3);\r\nsg_set_buf(rctx->src, iv + 12, req->assoclen - 8);\r\nsg = scatterwalk_ffwd(rctx->src + 1, req->src, req->assoclen);\r\nif (sg != rctx->src + 1)\r\nsg_chain(rctx->src, 2, sg);\r\nif (req->src != req->dst) {\r\nsg_init_table(rctx->dst, 3);\r\nsg_set_buf(rctx->dst, iv + 12, req->assoclen - 8);\r\nsg = scatterwalk_ffwd(rctx->dst + 1, req->dst, req->assoclen);\r\nif (sg != rctx->dst + 1)\r\nsg_chain(rctx->dst, 2, sg);\r\n}\r\naead_request_set_tfm(subreq, child);\r\naead_request_set_callback(subreq, req->base.flags, req->base.complete,\r\nreq->base.data);\r\naead_request_set_crypt(subreq, rctx->src,\r\nreq->src == req->dst ? rctx->src : rctx->dst,\r\nreq->cryptlen, iv);\r\naead_request_set_ad(subreq, req->assoclen - 8);\r\nreturn subreq;\r\n}\r\nstatic int crypto_rfc4106_encrypt(struct aead_request *req)\r\n{\r\nif (req->assoclen != 16 && req->assoclen != 20)\r\nreturn -EINVAL;\r\nreq = crypto_rfc4106_crypt(req);\r\nreturn crypto_aead_encrypt(req);\r\n}\r\nstatic int crypto_rfc4106_decrypt(struct aead_request *req)\r\n{\r\nif (req->assoclen != 16 && req->assoclen != 20)\r\nreturn -EINVAL;\r\nreq = crypto_rfc4106_crypt(req);\r\nreturn crypto_aead_decrypt(req);\r\n}\r\nstatic int crypto_rfc4106_init_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct aead_instance *inst = aead_alg_instance(tfm);\r\nstruct crypto_aead_spawn *spawn = aead_instance_ctx(inst);\r\nstruct crypto_rfc4106_ctx *ctx = crypto_aead_ctx(tfm);\r\nstruct crypto_aead *aead;\r\nunsigned long align;\r\naead = crypto_spawn_aead(spawn);\r\nif (IS_ERR(aead))\r\nreturn PTR_ERR(aead);\r\nctx->child = aead;\r\nalign = crypto_aead_alignmask(aead);\r\nalign &= ~(crypto_tfm_ctx_alignment() - 1);\r\ncrypto_aead_set_reqsize(\r\ntfm,\r\nsizeof(struct crypto_rfc4106_req_ctx) +\r\nALIGN(crypto_aead_reqsize(aead), crypto_tfm_ctx_alignment()) +\r\nalign + 24);\r\nreturn 0;\r\n}\r\nstatic void crypto_rfc4106_exit_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct crypto_rfc4106_ctx *ctx = crypto_aead_ctx(tfm);\r\ncrypto_free_aead(ctx->child);\r\n}\r\nstatic void crypto_rfc4106_free(struct aead_instance *inst)\r\n{\r\ncrypto_drop_aead(aead_instance_ctx(inst));\r\nkfree(inst);\r\n}\r\nstatic int crypto_rfc4106_create(struct crypto_template *tmpl,\r\nstruct rtattr **tb)\r\n{\r\nstruct crypto_attr_type *algt;\r\nstruct aead_instance *inst;\r\nstruct crypto_aead_spawn *spawn;\r\nstruct aead_alg *alg;\r\nconst char *ccm_name;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn PTR_ERR(algt);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\r\nreturn -EINVAL;\r\nccm_name = crypto_attr_alg_name(tb[1]);\r\nif (IS_ERR(ccm_name))\r\nreturn PTR_ERR(ccm_name);\r\ninst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);\r\nif (!inst)\r\nreturn -ENOMEM;\r\nspawn = aead_instance_ctx(inst);\r\ncrypto_set_aead_spawn(spawn, aead_crypto_instance(inst));\r\nerr = crypto_grab_aead(spawn, ccm_name, 0,\r\ncrypto_requires_sync(algt->type, algt->mask));\r\nif (err)\r\ngoto out_free_inst;\r\nalg = crypto_spawn_aead_alg(spawn);\r\nerr = -EINVAL;\r\nif (crypto_aead_alg_ivsize(alg) != 12)\r\ngoto out_drop_alg;\r\nif (alg->base.cra_blocksize != 1)\r\ngoto out_drop_alg;\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME,\r\n"rfc4106(%s)", alg->base.cra_name) >=\r\nCRYPTO_MAX_ALG_NAME ||\r\nsnprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"rfc4106(%s)", alg->base.cra_driver_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\ngoto out_drop_alg;\r\ninst->alg.base.cra_flags = alg->base.cra_flags & CRYPTO_ALG_ASYNC;\r\ninst->alg.base.cra_priority = alg->base.cra_priority;\r\ninst->alg.base.cra_blocksize = 1;\r\ninst->alg.base.cra_alignmask = alg->base.cra_alignmask;\r\ninst->alg.base.cra_ctxsize = sizeof(struct crypto_rfc4106_ctx);\r\ninst->alg.ivsize = 8;\r\ninst->alg.maxauthsize = crypto_aead_alg_maxauthsize(alg);\r\ninst->alg.init = crypto_rfc4106_init_tfm;\r\ninst->alg.exit = crypto_rfc4106_exit_tfm;\r\ninst->alg.setkey = crypto_rfc4106_setkey;\r\ninst->alg.setauthsize = crypto_rfc4106_setauthsize;\r\ninst->alg.encrypt = crypto_rfc4106_encrypt;\r\ninst->alg.decrypt = crypto_rfc4106_decrypt;\r\ninst->free = crypto_rfc4106_free;\r\nerr = aead_register_instance(tmpl, inst);\r\nif (err)\r\ngoto out_drop_alg;\r\nout:\r\nreturn err;\r\nout_drop_alg:\r\ncrypto_drop_aead(spawn);\r\nout_free_inst:\r\nkfree(inst);\r\ngoto out;\r\n}\r\nstatic int crypto_rfc4543_setkey(struct crypto_aead *parent, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(parent);\r\nstruct crypto_aead *child = ctx->child;\r\nint err;\r\nif (keylen < 4)\r\nreturn -EINVAL;\r\nkeylen -= 4;\r\nmemcpy(ctx->nonce, key + keylen, 4);\r\ncrypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_aead_set_flags(child, crypto_aead_get_flags(parent) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_aead_setkey(child, key, keylen);\r\ncrypto_aead_set_flags(parent, crypto_aead_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic int crypto_rfc4543_setauthsize(struct crypto_aead *parent,\r\nunsigned int authsize)\r\n{\r\nstruct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(parent);\r\nif (authsize != 16)\r\nreturn -EINVAL;\r\nreturn crypto_aead_setauthsize(ctx->child, authsize);\r\n}\r\nstatic int crypto_rfc4543_crypt(struct aead_request *req, bool enc)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_rfc4543_req_ctx *rctx = aead_request_ctx(req);\r\nstruct aead_request *subreq = &rctx->subreq;\r\nunsigned int authsize = crypto_aead_authsize(aead);\r\nu8 *iv = PTR_ALIGN((u8 *)(rctx + 1) + crypto_aead_reqsize(ctx->child),\r\ncrypto_aead_alignmask(ctx->child) + 1);\r\nint err;\r\nif (req->src != req->dst) {\r\nerr = crypto_rfc4543_copy_src_to_dst(req, enc);\r\nif (err)\r\nreturn err;\r\n}\r\nmemcpy(iv, ctx->nonce, 4);\r\nmemcpy(iv + 4, req->iv, 8);\r\naead_request_set_tfm(subreq, ctx->child);\r\naead_request_set_callback(subreq, req->base.flags,\r\nreq->base.complete, req->base.data);\r\naead_request_set_crypt(subreq, req->src, req->dst,\r\nenc ? 0 : authsize, iv);\r\naead_request_set_ad(subreq, req->assoclen + req->cryptlen -\r\nsubreq->cryptlen);\r\nreturn enc ? crypto_aead_encrypt(subreq) : crypto_aead_decrypt(subreq);\r\n}\r\nstatic int crypto_rfc4543_copy_src_to_dst(struct aead_request *req, bool enc)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(aead);\r\nunsigned int authsize = crypto_aead_authsize(aead);\r\nunsigned int nbytes = req->assoclen + req->cryptlen -\r\n(enc ? 0 : authsize);\r\nstruct blkcipher_desc desc = {\r\n.tfm = ctx->null,\r\n};\r\nreturn crypto_blkcipher_encrypt(&desc, req->dst, req->src, nbytes);\r\n}\r\nstatic int crypto_rfc4543_encrypt(struct aead_request *req)\r\n{\r\nreturn crypto_rfc4543_crypt(req, true);\r\n}\r\nstatic int crypto_rfc4543_decrypt(struct aead_request *req)\r\n{\r\nreturn crypto_rfc4543_crypt(req, false);\r\n}\r\nstatic int crypto_rfc4543_init_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct aead_instance *inst = aead_alg_instance(tfm);\r\nstruct crypto_rfc4543_instance_ctx *ictx = aead_instance_ctx(inst);\r\nstruct crypto_aead_spawn *spawn = &ictx->aead;\r\nstruct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(tfm);\r\nstruct crypto_aead *aead;\r\nstruct crypto_blkcipher *null;\r\nunsigned long align;\r\nint err = 0;\r\naead = crypto_spawn_aead(spawn);\r\nif (IS_ERR(aead))\r\nreturn PTR_ERR(aead);\r\nnull = crypto_get_default_null_skcipher();\r\nerr = PTR_ERR(null);\r\nif (IS_ERR(null))\r\ngoto err_free_aead;\r\nctx->child = aead;\r\nctx->null = null;\r\nalign = crypto_aead_alignmask(aead);\r\nalign &= ~(crypto_tfm_ctx_alignment() - 1);\r\ncrypto_aead_set_reqsize(\r\ntfm,\r\nsizeof(struct crypto_rfc4543_req_ctx) +\r\nALIGN(crypto_aead_reqsize(aead), crypto_tfm_ctx_alignment()) +\r\nalign + 12);\r\nreturn 0;\r\nerr_free_aead:\r\ncrypto_free_aead(aead);\r\nreturn err;\r\n}\r\nstatic void crypto_rfc4543_exit_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(tfm);\r\ncrypto_free_aead(ctx->child);\r\ncrypto_put_default_null_skcipher();\r\n}\r\nstatic void crypto_rfc4543_free(struct aead_instance *inst)\r\n{\r\nstruct crypto_rfc4543_instance_ctx *ctx = aead_instance_ctx(inst);\r\ncrypto_drop_aead(&ctx->aead);\r\nkfree(inst);\r\n}\r\nstatic int crypto_rfc4543_create(struct crypto_template *tmpl,\r\nstruct rtattr **tb)\r\n{\r\nstruct crypto_attr_type *algt;\r\nstruct aead_instance *inst;\r\nstruct crypto_aead_spawn *spawn;\r\nstruct aead_alg *alg;\r\nstruct crypto_rfc4543_instance_ctx *ctx;\r\nconst char *ccm_name;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn PTR_ERR(algt);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\r\nreturn -EINVAL;\r\nccm_name = crypto_attr_alg_name(tb[1]);\r\nif (IS_ERR(ccm_name))\r\nreturn PTR_ERR(ccm_name);\r\ninst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\r\nif (!inst)\r\nreturn -ENOMEM;\r\nctx = aead_instance_ctx(inst);\r\nspawn = &ctx->aead;\r\ncrypto_set_aead_spawn(spawn, aead_crypto_instance(inst));\r\nerr = crypto_grab_aead(spawn, ccm_name, 0,\r\ncrypto_requires_sync(algt->type, algt->mask));\r\nif (err)\r\ngoto out_free_inst;\r\nalg = crypto_spawn_aead_alg(spawn);\r\nerr = -EINVAL;\r\nif (crypto_aead_alg_ivsize(alg) != 12)\r\ngoto out_drop_alg;\r\nif (alg->base.cra_blocksize != 1)\r\ngoto out_drop_alg;\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME,\r\n"rfc4543(%s)", alg->base.cra_name) >=\r\nCRYPTO_MAX_ALG_NAME ||\r\nsnprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"rfc4543(%s)", alg->base.cra_driver_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\ngoto out_drop_alg;\r\ninst->alg.base.cra_flags = alg->base.cra_flags & CRYPTO_ALG_ASYNC;\r\ninst->alg.base.cra_priority = alg->base.cra_priority;\r\ninst->alg.base.cra_blocksize = 1;\r\ninst->alg.base.cra_alignmask = alg->base.cra_alignmask;\r\ninst->alg.base.cra_ctxsize = sizeof(struct crypto_rfc4543_ctx);\r\ninst->alg.ivsize = 8;\r\ninst->alg.maxauthsize = crypto_aead_alg_maxauthsize(alg);\r\ninst->alg.init = crypto_rfc4543_init_tfm;\r\ninst->alg.exit = crypto_rfc4543_exit_tfm;\r\ninst->alg.setkey = crypto_rfc4543_setkey;\r\ninst->alg.setauthsize = crypto_rfc4543_setauthsize;\r\ninst->alg.encrypt = crypto_rfc4543_encrypt;\r\ninst->alg.decrypt = crypto_rfc4543_decrypt;\r\ninst->free = crypto_rfc4543_free,\r\nerr = aead_register_instance(tmpl, inst);\r\nif (err)\r\ngoto out_drop_alg;\r\nout:\r\nreturn err;\r\nout_drop_alg:\r\ncrypto_drop_aead(spawn);\r\nout_free_inst:\r\nkfree(inst);\r\ngoto out;\r\n}\r\nstatic int __init crypto_gcm_module_init(void)\r\n{\r\nint err;\r\ngcm_zeroes = kzalloc(sizeof(*gcm_zeroes), GFP_KERNEL);\r\nif (!gcm_zeroes)\r\nreturn -ENOMEM;\r\nsg_init_one(&gcm_zeroes->sg, gcm_zeroes->buf, sizeof(gcm_zeroes->buf));\r\nerr = crypto_register_template(&crypto_gcm_base_tmpl);\r\nif (err)\r\ngoto out;\r\nerr = crypto_register_template(&crypto_gcm_tmpl);\r\nif (err)\r\ngoto out_undo_base;\r\nerr = crypto_register_template(&crypto_rfc4106_tmpl);\r\nif (err)\r\ngoto out_undo_gcm;\r\nerr = crypto_register_template(&crypto_rfc4543_tmpl);\r\nif (err)\r\ngoto out_undo_rfc4106;\r\nreturn 0;\r\nout_undo_rfc4106:\r\ncrypto_unregister_template(&crypto_rfc4106_tmpl);\r\nout_undo_gcm:\r\ncrypto_unregister_template(&crypto_gcm_tmpl);\r\nout_undo_base:\r\ncrypto_unregister_template(&crypto_gcm_base_tmpl);\r\nout:\r\nkfree(gcm_zeroes);\r\nreturn err;\r\n}\r\nstatic void __exit crypto_gcm_module_exit(void)\r\n{\r\nkfree(gcm_zeroes);\r\ncrypto_unregister_template(&crypto_rfc4543_tmpl);\r\ncrypto_unregister_template(&crypto_rfc4106_tmpl);\r\ncrypto_unregister_template(&crypto_gcm_tmpl);\r\ncrypto_unregister_template(&crypto_gcm_base_tmpl);\r\n}
