static unsigned long get_target_state(struct thermal_instance *instance,\r\nenum thermal_trend trend, bool throttle)\r\n{\r\nstruct thermal_cooling_device *cdev = instance->cdev;\r\nunsigned long cur_state;\r\nunsigned long next_target;\r\ncdev->ops->get_cur_state(cdev, &cur_state);\r\nnext_target = instance->target;\r\ndev_dbg(&cdev->device, "cur_state=%ld\n", cur_state);\r\nswitch (trend) {\r\ncase THERMAL_TREND_RAISING:\r\nif (throttle) {\r\nnext_target = cur_state < instance->upper ?\r\n(cur_state + 1) : instance->upper;\r\nif (next_target < instance->lower)\r\nnext_target = instance->lower;\r\n}\r\nbreak;\r\ncase THERMAL_TREND_RAISE_FULL:\r\nif (throttle)\r\nnext_target = instance->upper;\r\nbreak;\r\ncase THERMAL_TREND_DROPPING:\r\nif (cur_state <= instance->lower) {\r\nif (!throttle)\r\nnext_target = THERMAL_NO_TARGET;\r\n} else {\r\nnext_target = cur_state - 1;\r\nif (next_target > instance->upper)\r\nnext_target = instance->upper;\r\n}\r\nbreak;\r\ncase THERMAL_TREND_DROP_FULL:\r\nif (cur_state == instance->lower) {\r\nif (!throttle)\r\nnext_target = THERMAL_NO_TARGET;\r\n} else\r\nnext_target = instance->lower;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn next_target;\r\n}\r\nstatic void update_passive_instance(struct thermal_zone_device *tz,\r\nenum thermal_trip_type type, int value)\r\n{\r\nif (type == THERMAL_TRIP_PASSIVE || type == THERMAL_TRIPS_NONE)\r\ntz->passive += value;\r\n}\r\nstatic void thermal_zone_trip_update(struct thermal_zone_device *tz, int trip)\r\n{\r\nint trip_temp;\r\nenum thermal_trip_type trip_type;\r\nenum thermal_trend trend;\r\nstruct thermal_instance *instance;\r\nbool throttle = false;\r\nint old_target;\r\nif (trip == THERMAL_TRIPS_NONE) {\r\ntrip_temp = tz->forced_passive;\r\ntrip_type = THERMAL_TRIPS_NONE;\r\n} else {\r\ntz->ops->get_trip_temp(tz, trip, &trip_temp);\r\ntz->ops->get_trip_type(tz, trip, &trip_type);\r\n}\r\ntrend = get_tz_trend(tz, trip);\r\nif (tz->temperature >= trip_temp) {\r\nthrottle = true;\r\ntrace_thermal_zone_trip(tz, trip, trip_type);\r\n}\r\ndev_dbg(&tz->device, "Trip%d[type=%d,temp=%d]:trend=%d,throttle=%d\n",\r\ntrip, trip_type, trip_temp, trend, throttle);\r\nmutex_lock(&tz->lock);\r\nlist_for_each_entry(instance, &tz->thermal_instances, tz_node) {\r\nif (instance->trip != trip)\r\ncontinue;\r\nold_target = instance->target;\r\ninstance->target = get_target_state(instance, trend, throttle);\r\ndev_dbg(&instance->cdev->device, "old_target=%d, target=%d\n",\r\nold_target, (int)instance->target);\r\nif (old_target == instance->target)\r\ncontinue;\r\nif (old_target == THERMAL_NO_TARGET &&\r\ninstance->target != THERMAL_NO_TARGET)\r\nupdate_passive_instance(tz, trip_type, 1);\r\nelse if (old_target != THERMAL_NO_TARGET &&\r\ninstance->target == THERMAL_NO_TARGET)\r\nupdate_passive_instance(tz, trip_type, -1);\r\ninstance->cdev->updated = false;\r\n}\r\nmutex_unlock(&tz->lock);\r\n}\r\nstatic int step_wise_throttle(struct thermal_zone_device *tz, int trip)\r\n{\r\nstruct thermal_instance *instance;\r\nthermal_zone_trip_update(tz, trip);\r\nif (tz->forced_passive)\r\nthermal_zone_trip_update(tz, THERMAL_TRIPS_NONE);\r\nmutex_lock(&tz->lock);\r\nlist_for_each_entry(instance, &tz->thermal_instances, tz_node)\r\nthermal_cdev_update(instance->cdev);\r\nmutex_unlock(&tz->lock);\r\nreturn 0;\r\n}\r\nint thermal_gov_step_wise_register(void)\r\n{\r\nreturn thermal_register_governor(&thermal_gov_step_wise);\r\n}\r\nvoid thermal_gov_step_wise_unregister(void)\r\n{\r\nthermal_unregister_governor(&thermal_gov_step_wise);\r\n}
