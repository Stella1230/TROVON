static inline int\r\ncompute_yday(efi_time_t *eft)\r\n{\r\nreturn rtc_year_days(eft->day, eft->month - 1, eft->year);\r\n}\r\nstatic int\r\ncompute_wday(efi_time_t *eft, int yday)\r\n{\r\nint ndays = eft->year * (365 % 7)\r\n+ (eft->year - 1) / 4\r\n- (eft->year - 1) / 100\r\n+ (eft->year - 1) / 400\r\n+ yday;\r\nreturn ndays % 7;\r\n}\r\nstatic void\r\nconvert_to_efi_time(struct rtc_time *wtime, efi_time_t *eft)\r\n{\r\neft->year = wtime->tm_year + 1900;\r\neft->month = wtime->tm_mon + 1;\r\neft->day = wtime->tm_mday;\r\neft->hour = wtime->tm_hour;\r\neft->minute = wtime->tm_min;\r\neft->second = wtime->tm_sec;\r\neft->nanosecond = 0;\r\neft->daylight = wtime->tm_isdst ? EFI_ISDST : 0;\r\neft->timezone = EFI_UNSPECIFIED_TIMEZONE;\r\n}\r\nstatic bool\r\nconvert_from_efi_time(efi_time_t *eft, struct rtc_time *wtime)\r\n{\r\nmemset(wtime, 0, sizeof(*wtime));\r\nif (eft->second >= 60)\r\nreturn false;\r\nwtime->tm_sec = eft->second;\r\nif (eft->minute >= 60)\r\nreturn false;\r\nwtime->tm_min = eft->minute;\r\nif (eft->hour >= 24)\r\nreturn false;\r\nwtime->tm_hour = eft->hour;\r\nif (!eft->day || eft->day > 31)\r\nreturn false;\r\nwtime->tm_mday = eft->day;\r\nif (!eft->month || eft->month > 12)\r\nreturn false;\r\nwtime->tm_mon = eft->month - 1;\r\nif (eft->year < 1900 || eft->year > 9999)\r\nreturn false;\r\nwtime->tm_year = eft->year - 1900;\r\nwtime->tm_yday = compute_yday(eft);\r\nwtime->tm_wday = compute_wday(eft, wtime->tm_yday);\r\nswitch (eft->daylight & EFI_ISDST) {\r\ncase EFI_ISDST:\r\nwtime->tm_isdst = 1;\r\nbreak;\r\ncase EFI_TIME_ADJUST_DAYLIGHT:\r\nwtime->tm_isdst = 0;\r\nbreak;\r\ndefault:\r\nwtime->tm_isdst = -1;\r\n}\r\nreturn true;\r\n}\r\nstatic int efi_read_alarm(struct device *dev, struct rtc_wkalrm *wkalrm)\r\n{\r\nefi_time_t eft;\r\nefi_status_t status;\r\nstatus = efi.get_wakeup_time((efi_bool_t *)&wkalrm->enabled,\r\n(efi_bool_t *)&wkalrm->pending, &eft);\r\nif (status != EFI_SUCCESS)\r\nreturn -EINVAL;\r\nif (!convert_from_efi_time(&eft, &wkalrm->time))\r\nreturn -EIO;\r\nreturn rtc_valid_tm(&wkalrm->time);\r\n}\r\nstatic int efi_set_alarm(struct device *dev, struct rtc_wkalrm *wkalrm)\r\n{\r\nefi_time_t eft;\r\nefi_status_t status;\r\nconvert_to_efi_time(&wkalrm->time, &eft);\r\nstatus = efi.set_wakeup_time((efi_bool_t)wkalrm->enabled, &eft);\r\ndev_warn(dev, "write status is %d\n", (int)status);\r\nreturn status == EFI_SUCCESS ? 0 : -EINVAL;\r\n}\r\nstatic int efi_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nefi_status_t status;\r\nefi_time_t eft;\r\nefi_time_cap_t cap;\r\nstatus = efi.get_time(&eft, &cap);\r\nif (status != EFI_SUCCESS) {\r\ndev_err(dev, "can't read time\n");\r\nreturn -EINVAL;\r\n}\r\nif (!convert_from_efi_time(&eft, tm))\r\nreturn -EIO;\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int efi_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nefi_status_t status;\r\nefi_time_t eft;\r\nconvert_to_efi_time(tm, &eft);\r\nstatus = efi.set_time(&eft);\r\nreturn status == EFI_SUCCESS ? 0 : -EINVAL;\r\n}\r\nstatic int __init efi_rtc_probe(struct platform_device *dev)\r\n{\r\nstruct rtc_device *rtc;\r\nrtc = devm_rtc_device_register(&dev->dev, "rtc-efi", &efi_rtc_ops,\r\nTHIS_MODULE);\r\nif (IS_ERR(rtc))\r\nreturn PTR_ERR(rtc);\r\nrtc->uie_unsupported = 1;\r\nplatform_set_drvdata(dev, rtc);\r\nreturn 0;\r\n}
