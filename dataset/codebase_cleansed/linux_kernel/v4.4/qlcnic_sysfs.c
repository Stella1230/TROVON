int qlcnicvf_config_bridged_mode(struct qlcnic_adapter *adapter, u32 enable)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nint qlcnicvf_config_led(struct qlcnic_adapter *adapter, u32 state, u32 rate)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic ssize_t qlcnic_store_bridged_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nunsigned long new;\r\nint ret = -EINVAL;\r\nif (!(adapter->ahw->capabilities & QLCNIC_FW_CAPABILITY_BDG))\r\ngoto err_out;\r\nif (!test_bit(__QLCNIC_DEV_UP, &adapter->state))\r\ngoto err_out;\r\nif (kstrtoul(buf, 2, &new))\r\ngoto err_out;\r\nif (!qlcnic_config_bridged_mode(adapter, !!new))\r\nret = len;\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic ssize_t qlcnic_show_bridged_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nint bridged_mode = 0;\r\nif (adapter->ahw->capabilities & QLCNIC_FW_CAPABILITY_BDG)\r\nbridged_mode = !!(adapter->flags & QLCNIC_BRIDGE_ENABLED);\r\nreturn sprintf(buf, "%d\n", bridged_mode);\r\n}\r\nstatic ssize_t qlcnic_store_diag_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nunsigned long new;\r\nif (kstrtoul(buf, 2, &new))\r\nreturn -EINVAL;\r\nif (!!new != !!(adapter->flags & QLCNIC_DIAG_ENABLED))\r\nadapter->flags ^= QLCNIC_DIAG_ENABLED;\r\nreturn len;\r\n}\r\nstatic ssize_t qlcnic_show_diag_mode(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", !!(adapter->flags & QLCNIC_DIAG_ENABLED));\r\n}\r\nstatic int qlcnic_validate_beacon(struct qlcnic_adapter *adapter, u16 beacon,\r\nu8 *state, u8 *rate)\r\n{\r\n*rate = LSB(beacon);\r\n*state = MSB(beacon);\r\nQLCDB(adapter, DRV, "rate %x state %x\n", *rate, *state);\r\nif (!*state) {\r\n*rate = __QLCNIC_MAX_LED_RATE;\r\nreturn 0;\r\n} else if (*state > __QLCNIC_MAX_LED_STATE) {\r\nreturn -EINVAL;\r\n}\r\nif ((!*rate) || (*rate > __QLCNIC_MAX_LED_RATE))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_store_beacon(struct qlcnic_adapter *adapter,\r\nconst char *buf, size_t len)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nunsigned long h_beacon;\r\nint err;\r\nif (test_bit(__QLCNIC_RESETTING, &adapter->state))\r\nreturn -EIO;\r\nif (kstrtoul(buf, 2, &h_beacon))\r\nreturn -EINVAL;\r\nqlcnic_get_beacon_state(adapter);\r\nif (ahw->beacon_state == h_beacon)\r\nreturn len;\r\nrtnl_lock();\r\nif (!ahw->beacon_state) {\r\nif (test_and_set_bit(__QLCNIC_LED_ENABLE, &adapter->state)) {\r\nrtnl_unlock();\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (h_beacon)\r\nerr = qlcnic_83xx_config_led(adapter, 1, h_beacon);\r\nelse\r\nerr = qlcnic_83xx_config_led(adapter, 0, !h_beacon);\r\nif (!err)\r\nahw->beacon_state = h_beacon;\r\nif (!ahw->beacon_state)\r\nclear_bit(__QLCNIC_LED_ENABLE, &adapter->state);\r\nrtnl_unlock();\r\nreturn len;\r\n}\r\nstatic int qlcnic_82xx_store_beacon(struct qlcnic_adapter *adapter,\r\nconst char *buf, size_t len)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nint err, drv_sds_rings = adapter->drv_sds_rings;\r\nu16 beacon;\r\nu8 b_state, b_rate;\r\nif (len != sizeof(u16))\r\nreturn -EINVAL;\r\nmemcpy(&beacon, buf, sizeof(u16));\r\nerr = qlcnic_validate_beacon(adapter, beacon, &b_state, &b_rate);\r\nif (err)\r\nreturn err;\r\nqlcnic_get_beacon_state(adapter);\r\nif (ahw->beacon_state == b_state)\r\nreturn len;\r\nrtnl_lock();\r\nif (!ahw->beacon_state) {\r\nif (test_and_set_bit(__QLCNIC_LED_ENABLE, &adapter->state)) {\r\nrtnl_unlock();\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (test_bit(__QLCNIC_RESETTING, &adapter->state)) {\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nif (!test_bit(__QLCNIC_DEV_UP, &adapter->state)) {\r\nerr = qlcnic_diag_alloc_res(adapter->netdev, QLCNIC_LED_TEST);\r\nif (err)\r\ngoto out;\r\nset_bit(__QLCNIC_DIAG_RES_ALLOC, &adapter->state);\r\n}\r\nerr = qlcnic_config_led(adapter, b_state, b_rate);\r\nif (!err) {\r\nerr = len;\r\nahw->beacon_state = b_state;\r\n}\r\nif (test_and_clear_bit(__QLCNIC_DIAG_RES_ALLOC, &adapter->state))\r\nqlcnic_diag_free_res(adapter->netdev, drv_sds_rings);\r\nout:\r\nif (!ahw->beacon_state)\r\nclear_bit(__QLCNIC_LED_ENABLE, &adapter->state);\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nstatic ssize_t qlcnic_store_beacon(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nint err = 0;\r\nif (adapter->ahw->op_mode == QLCNIC_NON_PRIV_FUNC) {\r\ndev_warn(dev,\r\n"LED test not supported in non privileged mode\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (qlcnic_82xx_check(adapter))\r\nerr = qlcnic_82xx_store_beacon(adapter, buf, len);\r\nelse if (qlcnic_83xx_check(adapter))\r\nerr = qlcnic_83xx_store_beacon(adapter, buf, len);\r\nelse\r\nreturn -EIO;\r\nreturn err;\r\n}\r\nstatic ssize_t qlcnic_show_beacon(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", adapter->ahw->beacon_state);\r\n}\r\nstatic int qlcnic_sysfs_validate_crb(struct qlcnic_adapter *adapter,\r\nloff_t offset, size_t size)\r\n{\r\nsize_t crb_size = 4;\r\nif (!(adapter->flags & QLCNIC_DIAG_ENABLED))\r\nreturn -EIO;\r\nif (offset < QLCNIC_PCI_CRBSPACE) {\r\nif (ADDR_IN_RANGE(offset, QLCNIC_PCI_CAMQM,\r\nQLCNIC_PCI_CAMQM_END))\r\ncrb_size = 8;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nif ((size != crb_size) || (offset & (crb_size-1)))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic ssize_t qlcnic_sysfs_read_crb(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr, char *buf,\r\nloff_t offset, size_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nint ret;\r\nret = qlcnic_sysfs_validate_crb(adapter, offset, size);\r\nif (ret != 0)\r\nreturn ret;\r\nqlcnic_read_crb(adapter, buf, offset, size);\r\nqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\r\nreturn size;\r\n}\r\nstatic ssize_t qlcnic_sysfs_write_crb(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr, char *buf,\r\nloff_t offset, size_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nint ret;\r\nret = qlcnic_sysfs_validate_crb(adapter, offset, size);\r\nif (ret != 0)\r\nreturn ret;\r\nqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\r\nqlcnic_write_crb(adapter, buf, offset, size);\r\nreturn size;\r\n}\r\nstatic int qlcnic_sysfs_validate_mem(struct qlcnic_adapter *adapter,\r\nloff_t offset, size_t size)\r\n{\r\nif (!(adapter->flags & QLCNIC_DIAG_ENABLED))\r\nreturn -EIO;\r\nif ((size != 8) || (offset & 0x7))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic ssize_t qlcnic_sysfs_read_mem(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr, char *buf,\r\nloff_t offset, size_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nu64 data;\r\nint ret;\r\nret = qlcnic_sysfs_validate_mem(adapter, offset, size);\r\nif (ret != 0)\r\nreturn ret;\r\nif (qlcnic_pci_mem_read_2M(adapter, offset, &data))\r\nreturn -EIO;\r\nmemcpy(buf, &data, size);\r\nqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\r\nreturn size;\r\n}\r\nstatic ssize_t qlcnic_sysfs_write_mem(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr, char *buf,\r\nloff_t offset, size_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nu64 data;\r\nint ret;\r\nret = qlcnic_sysfs_validate_mem(adapter, offset, size);\r\nif (ret != 0)\r\nreturn ret;\r\nqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\r\nmemcpy(&data, buf, size);\r\nif (qlcnic_pci_mem_write_2M(adapter, offset, data))\r\nreturn -EIO;\r\nreturn size;\r\n}\r\nint qlcnic_is_valid_nic_func(struct qlcnic_adapter *adapter, u8 pci_func)\r\n{\r\nint i;\r\nfor (i = 0; i < adapter->ahw->total_nic_func; i++) {\r\nif (adapter->npars[i].pci_func == pci_func)\r\nreturn i;\r\n}\r\ndev_err(&adapter->pdev->dev, "%s: Invalid nic function\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nstatic int validate_pm_config(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_pm_func_cfg *pm_cfg, int count)\r\n{\r\nu8 src_pci_func, s_esw_id, d_esw_id;\r\nu8 dest_pci_func;\r\nint i, src_index, dest_index;\r\nfor (i = 0; i < count; i++) {\r\nsrc_pci_func = pm_cfg[i].pci_func;\r\ndest_pci_func = pm_cfg[i].dest_npar;\r\nsrc_index = qlcnic_is_valid_nic_func(adapter, src_pci_func);\r\nif (src_index < 0)\r\nreturn -EINVAL;\r\ndest_index = qlcnic_is_valid_nic_func(adapter, dest_pci_func);\r\nif (dest_index < 0)\r\nreturn -EINVAL;\r\ns_esw_id = adapter->npars[src_index].phy_port;\r\nd_esw_id = adapter->npars[dest_index].phy_port;\r\nif (s_esw_id != d_esw_id)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t qlcnic_sysfs_write_pm_config(struct file *filp,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t offset,\r\nsize_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nstruct qlcnic_pm_func_cfg *pm_cfg;\r\nu32 id, action, pci_func;\r\nint count, rem, i, ret, index;\r\ncount = size / sizeof(struct qlcnic_pm_func_cfg);\r\nrem = size % sizeof(struct qlcnic_pm_func_cfg);\r\nif (rem)\r\nreturn -EINVAL;\r\nqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\r\npm_cfg = (struct qlcnic_pm_func_cfg *)buf;\r\nret = validate_pm_config(adapter, pm_cfg, count);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < count; i++) {\r\npci_func = pm_cfg[i].pci_func;\r\naction = !!pm_cfg[i].action;\r\nindex = qlcnic_is_valid_nic_func(adapter, pci_func);\r\nif (index < 0)\r\nreturn -EINVAL;\r\nid = adapter->npars[index].phy_port;\r\nret = qlcnic_config_port_mirroring(adapter, id,\r\naction, pci_func);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < count; i++) {\r\npci_func = pm_cfg[i].pci_func;\r\nindex = qlcnic_is_valid_nic_func(adapter, pci_func);\r\nif (index < 0)\r\nreturn -EINVAL;\r\nid = adapter->npars[index].phy_port;\r\nadapter->npars[index].enable_pm = !!pm_cfg[i].action;\r\nadapter->npars[index].dest_npar = id;\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t qlcnic_sysfs_read_pm_config(struct file *filp,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t offset,\r\nsize_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nstruct qlcnic_pm_func_cfg *pm_cfg;\r\nu8 pci_func;\r\nu32 count;\r\nint i;\r\nmemset(buf, 0, size);\r\npm_cfg = (struct qlcnic_pm_func_cfg *)buf;\r\ncount = size / sizeof(struct qlcnic_pm_func_cfg);\r\nfor (i = 0; i < adapter->ahw->total_nic_func; i++) {\r\npci_func = adapter->npars[i].pci_func;\r\nif (pci_func >= count) {\r\ndev_dbg(dev, "%s: Total nic functions[%d], App sent function count[%d]\n",\r\n__func__, adapter->ahw->total_nic_func, count);\r\ncontinue;\r\n}\r\nif (!adapter->npars[i].eswitch_status)\r\ncontinue;\r\npm_cfg[pci_func].action = adapter->npars[i].enable_pm;\r\npm_cfg[pci_func].dest_npar = 0;\r\npm_cfg[pci_func].pci_func = i;\r\n}\r\nqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\r\nreturn size;\r\n}\r\nstatic int validate_esw_config(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_esw_func_cfg *esw_cfg, int count)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nint i, ret;\r\nu32 op_mode;\r\nu8 pci_func;\r\nif (qlcnic_82xx_check(adapter))\r\nop_mode = readl(ahw->pci_base0 + QLCNIC_DRV_OP_MODE);\r\nelse\r\nop_mode = QLCRDX(ahw, QLC_83XX_DRV_OP_MODE);\r\nfor (i = 0; i < count; i++) {\r\npci_func = esw_cfg[i].pci_func;\r\nif (pci_func >= ahw->max_vnic_func)\r\nreturn -EINVAL;\r\nif (adapter->ahw->op_mode == QLCNIC_MGMT_FUNC)\r\nif (qlcnic_is_valid_nic_func(adapter, pci_func) < 0)\r\nreturn -EINVAL;\r\nswitch (esw_cfg[i].op_mode) {\r\ncase QLCNIC_PORT_DEFAULTS:\r\nif (qlcnic_82xx_check(adapter)) {\r\nret = QLC_DEV_GET_DRV(op_mode, pci_func);\r\n} else {\r\nret = QLC_83XX_GET_FUNC_PRIVILEGE(op_mode,\r\npci_func);\r\nesw_cfg[i].offload_flags = 0;\r\n}\r\nif (ret != QLCNIC_NON_PRIV_FUNC) {\r\nif (esw_cfg[i].mac_anti_spoof != 0)\r\nreturn -EINVAL;\r\nif (esw_cfg[i].mac_override != 1)\r\nreturn -EINVAL;\r\nif (esw_cfg[i].promisc_mode != 1)\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase QLCNIC_ADD_VLAN:\r\nif (!IS_VALID_VLAN(esw_cfg[i].vlan_id))\r\nreturn -EINVAL;\r\nif (!esw_cfg[i].op_type)\r\nreturn -EINVAL;\r\nbreak;\r\ncase QLCNIC_DEL_VLAN:\r\nif (!esw_cfg[i].op_type)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t qlcnic_sysfs_write_esw_config(struct file *file,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t offset,\r\nsize_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nstruct qlcnic_esw_func_cfg *esw_cfg;\r\nstruct qlcnic_npar_info *npar;\r\nint count, rem, i, ret;\r\nint index;\r\nu8 op_mode = 0, pci_func;\r\ncount = size / sizeof(struct qlcnic_esw_func_cfg);\r\nrem = size % sizeof(struct qlcnic_esw_func_cfg);\r\nif (rem)\r\nreturn -EINVAL;\r\nqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\r\nesw_cfg = (struct qlcnic_esw_func_cfg *)buf;\r\nret = validate_esw_config(adapter, esw_cfg, count);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < count; i++) {\r\nif (adapter->ahw->op_mode == QLCNIC_MGMT_FUNC)\r\nif (qlcnic_config_switch_port(adapter, &esw_cfg[i]))\r\nreturn -EINVAL;\r\nif (adapter->ahw->pci_func != esw_cfg[i].pci_func)\r\ncontinue;\r\nop_mode = esw_cfg[i].op_mode;\r\nqlcnic_get_eswitch_port_config(adapter, &esw_cfg[i]);\r\nesw_cfg[i].op_mode = op_mode;\r\nesw_cfg[i].pci_func = adapter->ahw->pci_func;\r\nswitch (esw_cfg[i].op_mode) {\r\ncase QLCNIC_PORT_DEFAULTS:\r\nqlcnic_set_eswitch_port_features(adapter, &esw_cfg[i]);\r\nrtnl_lock();\r\nqlcnic_set_netdev_features(adapter, &esw_cfg[i]);\r\nrtnl_unlock();\r\nbreak;\r\ncase QLCNIC_ADD_VLAN:\r\nqlcnic_set_vlan_config(adapter, &esw_cfg[i]);\r\nbreak;\r\ncase QLCNIC_DEL_VLAN:\r\nesw_cfg[i].vlan_id = 0;\r\nqlcnic_set_vlan_config(adapter, &esw_cfg[i]);\r\nbreak;\r\n}\r\n}\r\nif (adapter->ahw->op_mode != QLCNIC_MGMT_FUNC)\r\ngoto out;\r\nfor (i = 0; i < count; i++) {\r\npci_func = esw_cfg[i].pci_func;\r\nindex = qlcnic_is_valid_nic_func(adapter, pci_func);\r\nif (index < 0)\r\nreturn -EINVAL;\r\nnpar = &adapter->npars[index];\r\nswitch (esw_cfg[i].op_mode) {\r\ncase QLCNIC_PORT_DEFAULTS:\r\nnpar->promisc_mode = esw_cfg[i].promisc_mode;\r\nnpar->mac_override = esw_cfg[i].mac_override;\r\nnpar->offload_flags = esw_cfg[i].offload_flags;\r\nnpar->mac_anti_spoof = esw_cfg[i].mac_anti_spoof;\r\nnpar->discard_tagged = esw_cfg[i].discard_tagged;\r\nbreak;\r\ncase QLCNIC_ADD_VLAN:\r\nnpar->pvid = esw_cfg[i].vlan_id;\r\nbreak;\r\ncase QLCNIC_DEL_VLAN:\r\nnpar->pvid = 0;\r\nbreak;\r\n}\r\n}\r\nout:\r\nreturn size;\r\n}\r\nstatic ssize_t qlcnic_sysfs_read_esw_config(struct file *file,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t offset,\r\nsize_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nstruct qlcnic_esw_func_cfg *esw_cfg;\r\nu8 pci_func;\r\nu32 count;\r\nint i;\r\nmemset(buf, 0, size);\r\nesw_cfg = (struct qlcnic_esw_func_cfg *)buf;\r\ncount = size / sizeof(struct qlcnic_esw_func_cfg);\r\nfor (i = 0; i < adapter->ahw->total_nic_func; i++) {\r\npci_func = adapter->npars[i].pci_func;\r\nif (pci_func >= count) {\r\ndev_dbg(dev, "%s: Total nic functions[%d], App sent function count[%d]\n",\r\n__func__, adapter->ahw->total_nic_func, count);\r\ncontinue;\r\n}\r\nif (!adapter->npars[i].eswitch_status)\r\ncontinue;\r\nesw_cfg[pci_func].pci_func = pci_func;\r\nif (qlcnic_get_eswitch_port_config(adapter, &esw_cfg[pci_func]))\r\nreturn -EINVAL;\r\n}\r\nqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\r\nreturn size;\r\n}\r\nstatic int validate_npar_config(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_npar_func_cfg *np_cfg,\r\nint count)\r\n{\r\nu8 pci_func, i;\r\nfor (i = 0; i < count; i++) {\r\npci_func = np_cfg[i].pci_func;\r\nif (qlcnic_is_valid_nic_func(adapter, pci_func) < 0)\r\nreturn -EINVAL;\r\nif (!IS_VALID_BW(np_cfg[i].min_bw) ||\r\n!IS_VALID_BW(np_cfg[i].max_bw))\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t qlcnic_sysfs_write_npar_config(struct file *file,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t offset,\r\nsize_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nstruct qlcnic_info nic_info;\r\nstruct qlcnic_npar_func_cfg *np_cfg;\r\nint i, count, rem, ret, index;\r\nu8 pci_func;\r\ncount = size / sizeof(struct qlcnic_npar_func_cfg);\r\nrem = size % sizeof(struct qlcnic_npar_func_cfg);\r\nif (rem)\r\nreturn -EINVAL;\r\nqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\r\nnp_cfg = (struct qlcnic_npar_func_cfg *)buf;\r\nret = validate_npar_config(adapter, np_cfg, count);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < count; i++) {\r\npci_func = np_cfg[i].pci_func;\r\nmemset(&nic_info, 0, sizeof(struct qlcnic_info));\r\nret = qlcnic_get_nic_info(adapter, &nic_info, pci_func);\r\nif (ret)\r\nreturn ret;\r\nnic_info.pci_func = pci_func;\r\nnic_info.min_tx_bw = np_cfg[i].min_bw;\r\nnic_info.max_tx_bw = np_cfg[i].max_bw;\r\nret = qlcnic_set_nic_info(adapter, &nic_info);\r\nif (ret)\r\nreturn ret;\r\nindex = qlcnic_is_valid_nic_func(adapter, pci_func);\r\nif (index < 0)\r\nreturn -EINVAL;\r\nadapter->npars[index].min_bw = nic_info.min_tx_bw;\r\nadapter->npars[index].max_bw = nic_info.max_tx_bw;\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t qlcnic_sysfs_read_npar_config(struct file *file,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t offset,\r\nsize_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nstruct qlcnic_npar_func_cfg *np_cfg;\r\nstruct qlcnic_info nic_info;\r\nu8 pci_func;\r\nint i, ret;\r\nu32 count;\r\nmemset(&nic_info, 0, sizeof(struct qlcnic_info));\r\nmemset(buf, 0, size);\r\nnp_cfg = (struct qlcnic_npar_func_cfg *)buf;\r\ncount = size / sizeof(struct qlcnic_npar_func_cfg);\r\nfor (i = 0; i < adapter->ahw->total_nic_func; i++) {\r\nif (adapter->npars[i].pci_func >= count) {\r\ndev_dbg(dev, "%s: Total nic functions[%d], App sent function count[%d]\n",\r\n__func__, adapter->ahw->total_nic_func, count);\r\ncontinue;\r\n}\r\nif (!adapter->npars[i].eswitch_status)\r\ncontinue;\r\npci_func = adapter->npars[i].pci_func;\r\nif (qlcnic_is_valid_nic_func(adapter, pci_func) < 0)\r\ncontinue;\r\nret = qlcnic_get_nic_info(adapter, &nic_info, pci_func);\r\nif (ret)\r\nreturn ret;\r\nnp_cfg[pci_func].pci_func = pci_func;\r\nnp_cfg[pci_func].op_mode = (u8)nic_info.op_mode;\r\nnp_cfg[pci_func].port_num = nic_info.phys_port;\r\nnp_cfg[pci_func].fw_capab = nic_info.capabilities;\r\nnp_cfg[pci_func].min_bw = nic_info.min_tx_bw;\r\nnp_cfg[pci_func].max_bw = nic_info.max_tx_bw;\r\nnp_cfg[pci_func].max_tx_queues = nic_info.max_tx_ques;\r\nnp_cfg[pci_func].max_rx_queues = nic_info.max_rx_ques;\r\n}\r\nqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\r\nreturn size;\r\n}\r\nstatic ssize_t qlcnic_sysfs_get_port_stats(struct file *file,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t offset,\r\nsize_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nstruct qlcnic_esw_statistics port_stats;\r\nint ret;\r\nif (qlcnic_83xx_check(adapter))\r\nreturn -EOPNOTSUPP;\r\nif (size != sizeof(struct qlcnic_esw_statistics))\r\nreturn -EINVAL;\r\nif (offset >= adapter->ahw->max_vnic_func)\r\nreturn -EINVAL;\r\nmemset(&port_stats, 0, size);\r\nret = qlcnic_get_port_stats(adapter, offset, QLCNIC_QUERY_RX_COUNTER,\r\n&port_stats.rx);\r\nif (ret)\r\nreturn ret;\r\nret = qlcnic_get_port_stats(adapter, offset, QLCNIC_QUERY_TX_COUNTER,\r\n&port_stats.tx);\r\nif (ret)\r\nreturn ret;\r\nmemcpy(buf, &port_stats, size);\r\nreturn size;\r\n}\r\nstatic ssize_t qlcnic_sysfs_get_esw_stats(struct file *file,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t offset,\r\nsize_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nstruct qlcnic_esw_statistics esw_stats;\r\nint ret;\r\nif (qlcnic_83xx_check(adapter))\r\nreturn -EOPNOTSUPP;\r\nif (size != sizeof(struct qlcnic_esw_statistics))\r\nreturn -EINVAL;\r\nif (offset >= QLCNIC_NIU_MAX_XG_PORTS)\r\nreturn -EINVAL;\r\nmemset(&esw_stats, 0, size);\r\nret = qlcnic_get_eswitch_stats(adapter, offset, QLCNIC_QUERY_RX_COUNTER,\r\n&esw_stats.rx);\r\nif (ret)\r\nreturn ret;\r\nret = qlcnic_get_eswitch_stats(adapter, offset, QLCNIC_QUERY_TX_COUNTER,\r\n&esw_stats.tx);\r\nif (ret)\r\nreturn ret;\r\nmemcpy(buf, &esw_stats, size);\r\nreturn size;\r\n}\r\nstatic ssize_t qlcnic_sysfs_clear_esw_stats(struct file *file,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t offset,\r\nsize_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nint ret;\r\nif (qlcnic_83xx_check(adapter))\r\nreturn -EOPNOTSUPP;\r\nif (offset >= QLCNIC_NIU_MAX_XG_PORTS)\r\nreturn -EINVAL;\r\nret = qlcnic_clear_esw_stats(adapter, QLCNIC_STATS_ESWITCH, offset,\r\nQLCNIC_QUERY_RX_COUNTER);\r\nif (ret)\r\nreturn ret;\r\nret = qlcnic_clear_esw_stats(adapter, QLCNIC_STATS_ESWITCH, offset,\r\nQLCNIC_QUERY_TX_COUNTER);\r\nif (ret)\r\nreturn ret;\r\nreturn size;\r\n}\r\nstatic ssize_t qlcnic_sysfs_clear_port_stats(struct file *file,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t offset,\r\nsize_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nint ret;\r\nif (qlcnic_83xx_check(adapter))\r\nreturn -EOPNOTSUPP;\r\nif (offset >= adapter->ahw->max_vnic_func)\r\nreturn -EINVAL;\r\nret = qlcnic_clear_esw_stats(adapter, QLCNIC_STATS_PORT, offset,\r\nQLCNIC_QUERY_RX_COUNTER);\r\nif (ret)\r\nreturn ret;\r\nret = qlcnic_clear_esw_stats(adapter, QLCNIC_STATS_PORT, offset,\r\nQLCNIC_QUERY_TX_COUNTER);\r\nif (ret)\r\nreturn ret;\r\nreturn size;\r\n}\r\nstatic ssize_t qlcnic_sysfs_read_pci_config(struct file *file,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t offset,\r\nsize_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nstruct qlcnic_pci_func_cfg *pci_cfg;\r\nstruct qlcnic_pci_info *pci_info;\r\nint i, ret;\r\nu32 count;\r\npci_info = kcalloc(size, sizeof(*pci_info), GFP_KERNEL);\r\nif (!pci_info)\r\nreturn -ENOMEM;\r\nret = qlcnic_get_pci_info(adapter, pci_info);\r\nif (ret) {\r\nkfree(pci_info);\r\nreturn ret;\r\n}\r\npci_cfg = (struct qlcnic_pci_func_cfg *)buf;\r\ncount = size / sizeof(struct qlcnic_pci_func_cfg);\r\nqlcnic_swap32_buffer((u32 *)pci_info, size / sizeof(u32));\r\nfor (i = 0; i < count; i++) {\r\npci_cfg[i].pci_func = pci_info[i].id;\r\npci_cfg[i].func_type = pci_info[i].type;\r\npci_cfg[i].func_state = 0;\r\npci_cfg[i].port_num = pci_info[i].default_port;\r\npci_cfg[i].min_bw = pci_info[i].tx_min_bw;\r\npci_cfg[i].max_bw = pci_info[i].tx_max_bw;\r\nmemcpy(&pci_cfg[i].def_mac_addr, &pci_info[i].mac, ETH_ALEN);\r\n}\r\nkfree(pci_info);\r\nreturn size;\r\n}\r\nstatic ssize_t qlcnic_83xx_sysfs_flash_read_handler(struct file *filp,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t offset,\r\nsize_t size)\r\n{\r\nunsigned char *p_read_buf;\r\nint ret, count;\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nif (!size)\r\nreturn -EINVAL;\r\ncount = size / sizeof(u32);\r\nif (size % sizeof(u32))\r\ncount++;\r\np_read_buf = kcalloc(size, sizeof(unsigned char), GFP_KERNEL);\r\nif (!p_read_buf)\r\nreturn -ENOMEM;\r\nif (qlcnic_83xx_lock_flash(adapter) != 0) {\r\nkfree(p_read_buf);\r\nreturn -EIO;\r\n}\r\nret = qlcnic_83xx_lockless_flash_read32(adapter, offset, p_read_buf,\r\ncount);\r\nif (ret) {\r\nqlcnic_83xx_unlock_flash(adapter);\r\nkfree(p_read_buf);\r\nreturn ret;\r\n}\r\nqlcnic_83xx_unlock_flash(adapter);\r\nqlcnic_swap32_buffer((u32 *)p_read_buf, count);\r\nmemcpy(buf, p_read_buf, size);\r\nkfree(p_read_buf);\r\nreturn size;\r\n}\r\nstatic int qlcnic_83xx_sysfs_flash_bulk_write(struct qlcnic_adapter *adapter,\r\nchar *buf, loff_t offset,\r\nsize_t size)\r\n{\r\nint i, ret, count;\r\nunsigned char *p_cache, *p_src;\r\np_cache = kcalloc(size, sizeof(unsigned char), GFP_KERNEL);\r\nif (!p_cache)\r\nreturn -ENOMEM;\r\ncount = size / sizeof(u32);\r\nqlcnic_swap32_buffer((u32 *)buf, count);\r\nmemcpy(p_cache, buf, size);\r\np_src = p_cache;\r\nif (qlcnic_83xx_lock_flash(adapter) != 0) {\r\nkfree(p_cache);\r\nreturn -EIO;\r\n}\r\nif (adapter->ahw->fdt.mfg_id == adapter->flash_mfg_id) {\r\nret = qlcnic_83xx_enable_flash_write(adapter);\r\nif (ret) {\r\nkfree(p_cache);\r\nqlcnic_83xx_unlock_flash(adapter);\r\nreturn -EIO;\r\n}\r\n}\r\nfor (i = 0; i < count / QLC_83XX_FLASH_WRITE_MAX; i++) {\r\nret = qlcnic_83xx_flash_bulk_write(adapter, offset,\r\n(u32 *)p_src,\r\nQLC_83XX_FLASH_WRITE_MAX);\r\nif (ret) {\r\nif (adapter->ahw->fdt.mfg_id == adapter->flash_mfg_id) {\r\nret = qlcnic_83xx_disable_flash_write(adapter);\r\nif (ret) {\r\nkfree(p_cache);\r\nqlcnic_83xx_unlock_flash(adapter);\r\nreturn -EIO;\r\n}\r\n}\r\nkfree(p_cache);\r\nqlcnic_83xx_unlock_flash(adapter);\r\nreturn -EIO;\r\n}\r\np_src = p_src + sizeof(u32)*QLC_83XX_FLASH_WRITE_MAX;\r\noffset = offset + sizeof(u32)*QLC_83XX_FLASH_WRITE_MAX;\r\n}\r\nif (adapter->ahw->fdt.mfg_id == adapter->flash_mfg_id) {\r\nret = qlcnic_83xx_disable_flash_write(adapter);\r\nif (ret) {\r\nkfree(p_cache);\r\nqlcnic_83xx_unlock_flash(adapter);\r\nreturn -EIO;\r\n}\r\n}\r\nkfree(p_cache);\r\nqlcnic_83xx_unlock_flash(adapter);\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_sysfs_flash_write(struct qlcnic_adapter *adapter,\r\nchar *buf, loff_t offset, size_t size)\r\n{\r\nint i, ret, count;\r\nunsigned char *p_cache, *p_src;\r\np_cache = kcalloc(size, sizeof(unsigned char), GFP_KERNEL);\r\nif (!p_cache)\r\nreturn -ENOMEM;\r\nqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\r\nmemcpy(p_cache, buf, size);\r\np_src = p_cache;\r\ncount = size / sizeof(u32);\r\nif (qlcnic_83xx_lock_flash(adapter) != 0) {\r\nkfree(p_cache);\r\nreturn -EIO;\r\n}\r\nif (adapter->ahw->fdt.mfg_id == adapter->flash_mfg_id) {\r\nret = qlcnic_83xx_enable_flash_write(adapter);\r\nif (ret) {\r\nkfree(p_cache);\r\nqlcnic_83xx_unlock_flash(adapter);\r\nreturn -EIO;\r\n}\r\n}\r\nfor (i = 0; i < count; i++) {\r\nret = qlcnic_83xx_flash_write32(adapter, offset, (u32 *)p_src);\r\nif (ret) {\r\nif (adapter->ahw->fdt.mfg_id == adapter->flash_mfg_id) {\r\nret = qlcnic_83xx_disable_flash_write(adapter);\r\nif (ret) {\r\nkfree(p_cache);\r\nqlcnic_83xx_unlock_flash(adapter);\r\nreturn -EIO;\r\n}\r\n}\r\nkfree(p_cache);\r\nqlcnic_83xx_unlock_flash(adapter);\r\nreturn -EIO;\r\n}\r\np_src = p_src + sizeof(u32);\r\noffset = offset + sizeof(u32);\r\n}\r\nif (adapter->ahw->fdt.mfg_id == adapter->flash_mfg_id) {\r\nret = qlcnic_83xx_disable_flash_write(adapter);\r\nif (ret) {\r\nkfree(p_cache);\r\nqlcnic_83xx_unlock_flash(adapter);\r\nreturn -EIO;\r\n}\r\n}\r\nkfree(p_cache);\r\nqlcnic_83xx_unlock_flash(adapter);\r\nreturn 0;\r\n}\r\nstatic ssize_t qlcnic_83xx_sysfs_flash_write_handler(struct file *filp,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t offset,\r\nsize_t size)\r\n{\r\nint ret;\r\nstatic int flash_mode;\r\nunsigned long data;\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nret = kstrtoul(buf, 16, &data);\r\nswitch (data) {\r\ncase QLC_83XX_FLASH_SECTOR_ERASE_CMD:\r\nflash_mode = QLC_83XX_ERASE_MODE;\r\nret = qlcnic_83xx_erase_flash_sector(adapter, offset);\r\nif (ret) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s failed at %d\n", __func__, __LINE__);\r\nreturn -EIO;\r\n}\r\nbreak;\r\ncase QLC_83XX_FLASH_BULK_WRITE_CMD:\r\nflash_mode = QLC_83XX_BULK_WRITE_MODE;\r\nbreak;\r\ncase QLC_83XX_FLASH_WRITE_CMD:\r\nflash_mode = QLC_83XX_WRITE_MODE;\r\nbreak;\r\ndefault:\r\nif (flash_mode == QLC_83XX_BULK_WRITE_MODE) {\r\nret = qlcnic_83xx_sysfs_flash_bulk_write(adapter, buf,\r\noffset, size);\r\nif (ret) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s failed at %d\n",\r\n__func__, __LINE__);\r\nreturn -EIO;\r\n}\r\n}\r\nif (flash_mode == QLC_83XX_WRITE_MODE) {\r\nret = qlcnic_83xx_sysfs_flash_write(adapter, buf,\r\noffset, size);\r\nif (ret) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s failed at %d\n", __func__,\r\n__LINE__);\r\nreturn -EIO;\r\n}\r\n}\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t qlcnic_hwmon_show_temp(struct device *dev,\r\nstruct device_attribute *dev_attr,\r\nchar *buf)\r\n{\r\nstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\r\nunsigned int temperature = 0, value = 0;\r\nif (qlcnic_83xx_check(adapter))\r\nvalue = QLCRDX(adapter->ahw, QLC_83XX_ASIC_TEMP);\r\nelse if (qlcnic_82xx_check(adapter))\r\nvalue = QLC_SHARED_REG_RD32(adapter, QLCNIC_ASIC_TEMP);\r\ntemperature = qlcnic_get_temp_val(value);\r\ntemperature *= 1000;\r\nreturn sprintf(buf, "%u\n", temperature);\r\n}\r\nvoid qlcnic_register_hwmon_dev(struct qlcnic_adapter *adapter)\r\n{\r\nstruct device *dev = &adapter->pdev->dev;\r\nstruct device *hwmon_dev;\r\nif (qlcnic_sriov_vf_check(adapter)) {\r\nadapter->ahw->hwmon_dev = NULL;\r\nreturn;\r\n}\r\nhwmon_dev = hwmon_device_register_with_groups(dev, qlcnic_driver_name,\r\nadapter,\r\nqlcnic_hwmon_groups);\r\nif (IS_ERR(hwmon_dev)) {\r\ndev_err(dev, "Cannot register with hwmon, err=%ld\n",\r\nPTR_ERR(hwmon_dev));\r\nhwmon_dev = NULL;\r\n}\r\nadapter->ahw->hwmon_dev = hwmon_dev;\r\n}\r\nvoid qlcnic_unregister_hwmon_dev(struct qlcnic_adapter *adapter)\r\n{\r\nstruct device *hwmon_dev = adapter->ahw->hwmon_dev;\r\nif (hwmon_dev) {\r\nhwmon_device_unregister(hwmon_dev);\r\nadapter->ahw->hwmon_dev = NULL;\r\n}\r\n}\r\nvoid qlcnic_create_sysfs_entries(struct qlcnic_adapter *adapter)\r\n{\r\nstruct device *dev = &adapter->pdev->dev;\r\nif (adapter->ahw->capabilities & QLCNIC_FW_CAPABILITY_BDG)\r\nif (device_create_file(dev, &dev_attr_bridged_mode))\r\ndev_warn(dev,\r\n"failed to create bridged_mode sysfs entry\n");\r\n}\r\nvoid qlcnic_remove_sysfs_entries(struct qlcnic_adapter *adapter)\r\n{\r\nstruct device *dev = &adapter->pdev->dev;\r\nif (adapter->ahw->capabilities & QLCNIC_FW_CAPABILITY_BDG)\r\ndevice_remove_file(dev, &dev_attr_bridged_mode);\r\n}\r\nstatic void qlcnic_create_diag_entries(struct qlcnic_adapter *adapter)\r\n{\r\nstruct device *dev = &adapter->pdev->dev;\r\nif (device_create_bin_file(dev, &bin_attr_port_stats))\r\ndev_info(dev, "failed to create port stats sysfs entry");\r\nif (adapter->ahw->op_mode == QLCNIC_NON_PRIV_FUNC)\r\nreturn;\r\nif (device_create_file(dev, &dev_attr_diag_mode))\r\ndev_info(dev, "failed to create diag_mode sysfs entry\n");\r\nif (device_create_bin_file(dev, &bin_attr_crb))\r\ndev_info(dev, "failed to create crb sysfs entry\n");\r\nif (device_create_bin_file(dev, &bin_attr_mem))\r\ndev_info(dev, "failed to create mem sysfs entry\n");\r\nif (test_bit(__QLCNIC_MAINTENANCE_MODE, &adapter->state))\r\nreturn;\r\nif (device_create_bin_file(dev, &bin_attr_pci_config))\r\ndev_info(dev, "failed to create pci config sysfs entry");\r\nif (device_create_file(dev, &dev_attr_beacon))\r\ndev_info(dev, "failed to create beacon sysfs entry");\r\nif (!(adapter->flags & QLCNIC_ESWITCH_ENABLED))\r\nreturn;\r\nif (device_create_bin_file(dev, &bin_attr_esw_config))\r\ndev_info(dev, "failed to create esw config sysfs entry");\r\nif (adapter->ahw->op_mode != QLCNIC_MGMT_FUNC)\r\nreturn;\r\nif (device_create_bin_file(dev, &bin_attr_npar_config))\r\ndev_info(dev, "failed to create npar config sysfs entry");\r\nif (device_create_bin_file(dev, &bin_attr_pm_config))\r\ndev_info(dev, "failed to create pm config sysfs entry");\r\nif (device_create_bin_file(dev, &bin_attr_esw_stats))\r\ndev_info(dev, "failed to create eswitch stats sysfs entry");\r\n}\r\nstatic void qlcnic_remove_diag_entries(struct qlcnic_adapter *adapter)\r\n{\r\nstruct device *dev = &adapter->pdev->dev;\r\ndevice_remove_bin_file(dev, &bin_attr_port_stats);\r\nif (adapter->ahw->op_mode == QLCNIC_NON_PRIV_FUNC)\r\nreturn;\r\ndevice_remove_file(dev, &dev_attr_diag_mode);\r\ndevice_remove_bin_file(dev, &bin_attr_crb);\r\ndevice_remove_bin_file(dev, &bin_attr_mem);\r\nif (test_bit(__QLCNIC_MAINTENANCE_MODE, &adapter->state))\r\nreturn;\r\ndevice_remove_bin_file(dev, &bin_attr_pci_config);\r\ndevice_remove_file(dev, &dev_attr_beacon);\r\nif (!(adapter->flags & QLCNIC_ESWITCH_ENABLED))\r\nreturn;\r\ndevice_remove_bin_file(dev, &bin_attr_esw_config);\r\nif (adapter->ahw->op_mode != QLCNIC_MGMT_FUNC)\r\nreturn;\r\ndevice_remove_bin_file(dev, &bin_attr_npar_config);\r\ndevice_remove_bin_file(dev, &bin_attr_pm_config);\r\ndevice_remove_bin_file(dev, &bin_attr_esw_stats);\r\n}\r\nvoid qlcnic_82xx_add_sysfs(struct qlcnic_adapter *adapter)\r\n{\r\nqlcnic_create_diag_entries(adapter);\r\n}\r\nvoid qlcnic_82xx_remove_sysfs(struct qlcnic_adapter *adapter)\r\n{\r\nqlcnic_remove_diag_entries(adapter);\r\n}\r\nvoid qlcnic_83xx_add_sysfs(struct qlcnic_adapter *adapter)\r\n{\r\nstruct device *dev = &adapter->pdev->dev;\r\nqlcnic_create_diag_entries(adapter);\r\nif (sysfs_create_bin_file(&dev->kobj, &bin_attr_flash))\r\ndev_info(dev, "failed to create flash sysfs entry\n");\r\n}\r\nvoid qlcnic_83xx_remove_sysfs(struct qlcnic_adapter *adapter)\r\n{\r\nstruct device *dev = &adapter->pdev->dev;\r\nqlcnic_remove_diag_entries(adapter);\r\nsysfs_remove_bin_file(&dev->kobj, &bin_attr_flash);\r\n}
