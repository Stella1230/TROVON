static inline struct brcmstb_gpio_bank *\r\nbrcmstb_gpio_gc_to_bank(struct gpio_chip *gc)\r\n{\r\nstruct bgpio_chip *bgc = to_bgpio_chip(gc);\r\nreturn container_of(bgc, struct brcmstb_gpio_bank, bgc);\r\n}\r\nstatic inline struct brcmstb_gpio_priv *\r\nbrcmstb_gpio_gc_to_priv(struct gpio_chip *gc)\r\n{\r\nstruct brcmstb_gpio_bank *bank = brcmstb_gpio_gc_to_bank(gc);\r\nreturn bank->parent_priv;\r\n}\r\nstatic void brcmstb_gpio_set_imask(struct brcmstb_gpio_bank *bank,\r\nunsigned int offset, bool enable)\r\n{\r\nstruct bgpio_chip *bgc = &bank->bgc;\r\nstruct brcmstb_gpio_priv *priv = bank->parent_priv;\r\nu32 mask = bgc->pin2mask(bgc, offset);\r\nu32 imask;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bgc->lock, flags);\r\nimask = bgc->read_reg(priv->reg_base + GIO_MASK(bank->id));\r\nif (enable)\r\nimask |= mask;\r\nelse\r\nimask &= ~mask;\r\nbgc->write_reg(priv->reg_base + GIO_MASK(bank->id), imask);\r\nspin_unlock_irqrestore(&bgc->lock, flags);\r\n}\r\nstatic void brcmstb_gpio_irq_mask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct brcmstb_gpio_bank *bank = brcmstb_gpio_gc_to_bank(gc);\r\nbrcmstb_gpio_set_imask(bank, d->hwirq, false);\r\n}\r\nstatic void brcmstb_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct brcmstb_gpio_bank *bank = brcmstb_gpio_gc_to_bank(gc);\r\nbrcmstb_gpio_set_imask(bank, d->hwirq, true);\r\n}\r\nstatic int brcmstb_gpio_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct brcmstb_gpio_bank *bank = brcmstb_gpio_gc_to_bank(gc);\r\nstruct brcmstb_gpio_priv *priv = bank->parent_priv;\r\nu32 mask = BIT(d->hwirq);\r\nu32 edge_insensitive, iedge_insensitive;\r\nu32 edge_config, iedge_config;\r\nu32 level, ilevel;\r\nunsigned long flags;\r\nswitch (type) {\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nlevel = 0;\r\nedge_config = 0;\r\nedge_insensitive = 0;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nlevel = mask;\r\nedge_config = 0;\r\nedge_insensitive = 0;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nlevel = 0;\r\nedge_config = 0;\r\nedge_insensitive = 0;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\nlevel = 0;\r\nedge_config = mask;\r\nedge_insensitive = 0;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nlevel = 0;\r\nedge_config = 0;\r\nedge_insensitive = mask;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&bank->bgc.lock, flags);\r\niedge_config = bank->bgc.read_reg(priv->reg_base +\r\nGIO_EC(bank->id)) & ~mask;\r\niedge_insensitive = bank->bgc.read_reg(priv->reg_base +\r\nGIO_EI(bank->id)) & ~mask;\r\nilevel = bank->bgc.read_reg(priv->reg_base +\r\nGIO_LEVEL(bank->id)) & ~mask;\r\nbank->bgc.write_reg(priv->reg_base + GIO_EC(bank->id),\r\niedge_config | edge_config);\r\nbank->bgc.write_reg(priv->reg_base + GIO_EI(bank->id),\r\niedge_insensitive | edge_insensitive);\r\nbank->bgc.write_reg(priv->reg_base + GIO_LEVEL(bank->id),\r\nilevel | level);\r\nspin_unlock_irqrestore(&bank->bgc.lock, flags);\r\nreturn 0;\r\n}\r\nstatic int brcmstb_gpio_priv_set_wake(struct brcmstb_gpio_priv *priv,\r\nunsigned int enable)\r\n{\r\nint ret = 0;\r\nif (enable)\r\nret = enable_irq_wake(priv->parent_wake_irq);\r\nelse\r\nret = disable_irq_wake(priv->parent_wake_irq);\r\nif (ret)\r\ndev_err(&priv->pdev->dev, "failed to %s wake-up interrupt\n",\r\nenable ? "enable" : "disable");\r\nreturn ret;\r\n}\r\nstatic int brcmstb_gpio_irq_set_wake(struct irq_data *d, unsigned int enable)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct brcmstb_gpio_priv *priv = brcmstb_gpio_gc_to_priv(gc);\r\nreturn brcmstb_gpio_priv_set_wake(priv, enable);\r\n}\r\nstatic irqreturn_t brcmstb_gpio_wake_irq_handler(int irq, void *data)\r\n{\r\nstruct brcmstb_gpio_priv *priv = data;\r\nif (!priv || irq != priv->parent_wake_irq)\r\nreturn IRQ_NONE;\r\npm_wakeup_event(&priv->pdev->dev, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void brcmstb_gpio_irq_bank_handler(struct brcmstb_gpio_bank *bank)\r\n{\r\nstruct brcmstb_gpio_priv *priv = bank->parent_priv;\r\nstruct irq_domain *irq_domain = bank->bgc.gc.irqdomain;\r\nvoid __iomem *reg_base = priv->reg_base;\r\nunsigned long status;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bank->bgc.lock, flags);\r\nwhile ((status = bank->bgc.read_reg(reg_base + GIO_STAT(bank->id)) &\r\nbank->bgc.read_reg(reg_base + GIO_MASK(bank->id)))) {\r\nint bit;\r\nfor_each_set_bit(bit, &status, 32) {\r\nu32 stat = bank->bgc.read_reg(reg_base +\r\nGIO_STAT(bank->id));\r\nif (bit >= bank->width)\r\ndev_warn(&priv->pdev->dev,\r\n"IRQ for invalid GPIO (bank=%d, offset=%d)\n",\r\nbank->id, bit);\r\nbank->bgc.write_reg(reg_base + GIO_STAT(bank->id),\r\nstat | BIT(bit));\r\ngeneric_handle_irq(irq_find_mapping(irq_domain, bit));\r\n}\r\n}\r\nspin_unlock_irqrestore(&bank->bgc.lock, flags);\r\n}\r\nstatic void brcmstb_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\r\nstruct brcmstb_gpio_priv *priv = brcmstb_gpio_gc_to_priv(gc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct list_head *pos;\r\nBUG_ON(!priv || !chip);\r\nchained_irq_enter(chip, desc);\r\nlist_for_each(pos, &priv->bank_list) {\r\nstruct brcmstb_gpio_bank *bank =\r\nlist_entry(pos, struct brcmstb_gpio_bank, node);\r\nbrcmstb_gpio_irq_bank_handler(bank);\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int brcmstb_gpio_reboot(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct brcmstb_gpio_priv *priv =\r\ncontainer_of(nb, struct brcmstb_gpio_priv, reboot_notifier);\r\nif (action == SYS_POWER_OFF)\r\nbrcmstb_gpio_priv_set_wake(priv, 1);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int brcmstb_gpio_sanity_check_banks(struct device *dev,\r\nstruct device_node *np, struct resource *res)\r\n{\r\nint res_num_banks = resource_size(res) / GIO_BANK_SIZE;\r\nint num_banks =\r\nof_property_count_u32_elems(np, "brcm,gpio-bank-widths");\r\nif (res_num_banks != num_banks) {\r\ndev_err(dev, "Mismatch in banks: res had %d, bank-widths had %d\n",\r\nres_num_banks, num_banks);\r\nreturn -EINVAL;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic int brcmstb_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct brcmstb_gpio_priv *priv = platform_get_drvdata(pdev);\r\nstruct list_head *pos;\r\nstruct brcmstb_gpio_bank *bank;\r\nint ret = 0;\r\nif (!priv) {\r\ndev_err(&pdev->dev, "called %s without drvdata!\n", __func__);\r\nreturn -EFAULT;\r\n}\r\nlist_for_each(pos, &priv->bank_list) {\r\nbank = list_entry(pos, struct brcmstb_gpio_bank, node);\r\nret = bgpio_remove(&bank->bgc);\r\nif (ret)\r\ndev_err(&pdev->dev, "gpiochip_remove fail in cleanup\n");\r\n}\r\nif (priv->reboot_notifier.notifier_call) {\r\nret = unregister_reboot_notifier(&priv->reboot_notifier);\r\nif (ret)\r\ndev_err(&pdev->dev,\r\n"failed to unregister reboot notifier\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int brcmstb_gpio_of_xlate(struct gpio_chip *gc,\r\nconst struct of_phandle_args *gpiospec, u32 *flags)\r\n{\r\nstruct brcmstb_gpio_priv *priv = brcmstb_gpio_gc_to_priv(gc);\r\nstruct brcmstb_gpio_bank *bank = brcmstb_gpio_gc_to_bank(gc);\r\nint offset;\r\nif (gc->of_gpio_n_cells != 2) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nif (WARN_ON(gpiospec->args_count < gc->of_gpio_n_cells))\r\nreturn -EINVAL;\r\noffset = gpiospec->args[0] - (gc->base - priv->gpio_base);\r\nif (offset >= gc->ngpio || offset < 0)\r\nreturn -EINVAL;\r\nif (unlikely(offset >= bank->width)) {\r\ndev_warn_ratelimited(&priv->pdev->dev,\r\n"Received request for invalid GPIO offset %d\n",\r\ngpiospec->args[0]);\r\n}\r\nif (flags)\r\n*flags = gpiospec->args[1];\r\nreturn offset;\r\n}\r\nstatic int brcmstb_gpio_irq_setup(struct platform_device *pdev,\r\nstruct brcmstb_gpio_bank *bank)\r\n{\r\nstruct brcmstb_gpio_priv *priv = bank->parent_priv;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nbank->irq_chip.name = dev_name(dev);\r\nbank->irq_chip.irq_mask = brcmstb_gpio_irq_mask;\r\nbank->irq_chip.irq_unmask = brcmstb_gpio_irq_unmask;\r\nbank->irq_chip.irq_set_type = brcmstb_gpio_irq_set_type;\r\nbank->irq_chip.flags = IRQCHIP_MASK_ON_SUSPEND;\r\nif (IS_ENABLED(CONFIG_PM_SLEEP) && !priv->can_wake &&\r\nof_property_read_bool(np, "wakeup-source")) {\r\npriv->parent_wake_irq = platform_get_irq(pdev, 1);\r\nif (priv->parent_wake_irq < 0) {\r\ndev_warn(dev,\r\n"Couldn't get wake IRQ - GPIOs will not be able to wake from sleep");\r\n} else {\r\nint err;\r\ndevice_set_wakeup_capable(dev, true);\r\ndevice_wakeup_enable(dev);\r\nerr = devm_request_irq(dev, priv->parent_wake_irq,\r\nbrcmstb_gpio_wake_irq_handler, 0,\r\n"brcmstb-gpio-wake", priv);\r\nif (err < 0) {\r\ndev_err(dev, "Couldn't request wake IRQ");\r\nreturn err;\r\n}\r\npriv->reboot_notifier.notifier_call =\r\nbrcmstb_gpio_reboot;\r\nregister_reboot_notifier(&priv->reboot_notifier);\r\npriv->can_wake = true;\r\n}\r\n}\r\nif (priv->can_wake)\r\nbank->irq_chip.irq_set_wake = brcmstb_gpio_irq_set_wake;\r\ngpiochip_irqchip_add(&bank->bgc.gc, &bank->irq_chip, 0,\r\nhandle_simple_irq, IRQ_TYPE_NONE);\r\ngpiochip_set_chained_irqchip(&bank->bgc.gc, &bank->irq_chip,\r\npriv->parent_irq, brcmstb_gpio_irq_handler);\r\nreturn 0;\r\n}\r\nstatic int brcmstb_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nvoid __iomem *reg_base;\r\nstruct brcmstb_gpio_priv *priv;\r\nstruct resource *res;\r\nstruct property *prop;\r\nconst __be32 *p;\r\nu32 bank_width;\r\nint num_banks = 0;\r\nint err;\r\nstatic int gpio_base;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, priv);\r\nINIT_LIST_HEAD(&priv->bank_list);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nreg_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(reg_base))\r\nreturn PTR_ERR(reg_base);\r\npriv->gpio_base = gpio_base;\r\npriv->reg_base = reg_base;\r\npriv->pdev = pdev;\r\nif (of_property_read_bool(np, "interrupt-controller")) {\r\npriv->parent_irq = platform_get_irq(pdev, 0);\r\nif (priv->parent_irq <= 0) {\r\ndev_err(dev, "Couldn't get IRQ");\r\nreturn -ENOENT;\r\n}\r\n} else {\r\npriv->parent_irq = -ENOENT;\r\n}\r\nif (brcmstb_gpio_sanity_check_banks(dev, np, res))\r\nreturn -EINVAL;\r\nof_property_for_each_u32(np, "brcm,gpio-bank-widths", prop, p,\r\nbank_width) {\r\nstruct brcmstb_gpio_bank *bank;\r\nstruct bgpio_chip *bgc;\r\nstruct gpio_chip *gc;\r\nbank = devm_kzalloc(dev, sizeof(*bank), GFP_KERNEL);\r\nif (!bank) {\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nbank->parent_priv = priv;\r\nbank->id = num_banks;\r\nif (bank_width <= 0 || bank_width > MAX_GPIO_PER_BANK) {\r\ndev_err(dev, "Invalid bank width %d\n", bank_width);\r\ngoto fail;\r\n} else {\r\nbank->width = bank_width;\r\n}\r\nbgc = &bank->bgc;\r\nerr = bgpio_init(bgc, dev, 4,\r\nreg_base + GIO_DATA(bank->id),\r\nNULL, NULL, NULL,\r\nreg_base + GIO_IODIR(bank->id), 0);\r\nif (err) {\r\ndev_err(dev, "bgpio_init() failed\n");\r\ngoto fail;\r\n}\r\ngc = &bgc->gc;\r\ngc->of_node = np;\r\ngc->owner = THIS_MODULE;\r\ngc->label = np->full_name;\r\ngc->base = gpio_base;\r\ngc->of_gpio_n_cells = 2;\r\ngc->of_xlate = brcmstb_gpio_of_xlate;\r\ngc->ngpio = MAX_GPIO_PER_BANK;\r\nbank->bgc.write_reg(reg_base + GIO_MASK(bank->id), 0);\r\nerr = gpiochip_add(gc);\r\nif (err) {\r\ndev_err(dev, "Could not add gpiochip for bank %d\n",\r\nbank->id);\r\ngoto fail;\r\n}\r\ngpio_base += gc->ngpio;\r\nif (priv->parent_irq > 0) {\r\nerr = brcmstb_gpio_irq_setup(pdev, bank);\r\nif (err)\r\ngoto fail;\r\n}\r\ndev_dbg(dev, "bank=%d, base=%d, ngpio=%d, width=%d\n", bank->id,\r\ngc->base, gc->ngpio, bank->width);\r\nlist_add(&bank->node, &priv->bank_list);\r\nnum_banks++;\r\n}\r\ndev_info(dev, "Registered %d banks (GPIO(s): %d-%d)\n",\r\nnum_banks, priv->gpio_base, gpio_base - 1);\r\nreturn 0;\r\nfail:\r\n(void) brcmstb_gpio_remove(pdev);\r\nreturn err;\r\n}
