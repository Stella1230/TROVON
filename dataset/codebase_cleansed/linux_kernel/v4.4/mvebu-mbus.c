const struct mbus_dram_target_info *mv_mbus_dram_info(void)\r\n{\r\nreturn &mvebu_mbus_dram_info;\r\n}\r\nconst struct mbus_dram_target_info *mv_mbus_dram_info_nooverlap(void)\r\n{\r\nreturn &mvebu_mbus_dram_info_nooverlap;\r\n}\r\nstatic bool mvebu_mbus_window_is_remappable(struct mvebu_mbus_state *mbus,\r\nconst int win)\r\n{\r\nreturn mbus->soc->win_remap_offset(win) != MVEBU_MBUS_NO_REMAP;\r\n}\r\nstatic void mvebu_mbus_read_window(struct mvebu_mbus_state *mbus,\r\nint win, int *enabled, u64 *base,\r\nu32 *size, u8 *target, u8 *attr,\r\nu64 *remap)\r\n{\r\nvoid __iomem *addr = mbus->mbuswins_base +\r\nmbus->soc->win_cfg_offset(win);\r\nu32 basereg = readl(addr + WIN_BASE_OFF);\r\nu32 ctrlreg = readl(addr + WIN_CTRL_OFF);\r\nif (!(ctrlreg & WIN_CTRL_ENABLE)) {\r\n*enabled = 0;\r\nreturn;\r\n}\r\n*enabled = 1;\r\n*base = ((u64)basereg & WIN_BASE_HIGH) << 32;\r\n*base |= (basereg & WIN_BASE_LOW);\r\n*size = (ctrlreg | ~WIN_CTRL_SIZE_MASK) + 1;\r\nif (target)\r\n*target = (ctrlreg & WIN_CTRL_TGT_MASK) >> WIN_CTRL_TGT_SHIFT;\r\nif (attr)\r\n*attr = (ctrlreg & WIN_CTRL_ATTR_MASK) >> WIN_CTRL_ATTR_SHIFT;\r\nif (remap) {\r\nif (mvebu_mbus_window_is_remappable(mbus, win)) {\r\nu32 remap_low, remap_hi;\r\nvoid __iomem *addr_rmp = mbus->mbuswins_base +\r\nmbus->soc->win_remap_offset(win);\r\nremap_low = readl(addr_rmp + WIN_REMAP_LO_OFF);\r\nremap_hi = readl(addr_rmp + WIN_REMAP_HI_OFF);\r\n*remap = ((u64)remap_hi << 32) | remap_low;\r\n} else\r\n*remap = 0;\r\n}\r\n}\r\nstatic void mvebu_mbus_disable_window(struct mvebu_mbus_state *mbus,\r\nint win)\r\n{\r\nvoid __iomem *addr;\r\naddr = mbus->mbuswins_base + mbus->soc->win_cfg_offset(win);\r\nwritel(0, addr + WIN_BASE_OFF);\r\nwritel(0, addr + WIN_CTRL_OFF);\r\nif (mvebu_mbus_window_is_remappable(mbus, win)) {\r\naddr = mbus->mbuswins_base + mbus->soc->win_remap_offset(win);\r\nwritel(0, addr + WIN_REMAP_LO_OFF);\r\nwritel(0, addr + WIN_REMAP_HI_OFF);\r\n}\r\n}\r\nstatic int mvebu_mbus_window_is_free(struct mvebu_mbus_state *mbus,\r\nconst int win)\r\n{\r\nvoid __iomem *addr = mbus->mbuswins_base +\r\nmbus->soc->win_cfg_offset(win);\r\nu32 ctrl = readl(addr + WIN_CTRL_OFF);\r\nreturn !(ctrl & WIN_CTRL_ENABLE);\r\n}\r\nstatic int mvebu_mbus_window_conflicts(struct mvebu_mbus_state *mbus,\r\nphys_addr_t base, size_t size,\r\nu8 target, u8 attr)\r\n{\r\nu64 end = (u64)base + size;\r\nint win;\r\nfor (win = 0; win < mbus->soc->num_wins; win++) {\r\nu64 wbase, wend;\r\nu32 wsize;\r\nu8 wtarget, wattr;\r\nint enabled;\r\nmvebu_mbus_read_window(mbus, win,\r\n&enabled, &wbase, &wsize,\r\n&wtarget, &wattr, NULL);\r\nif (!enabled)\r\ncontinue;\r\nwend = wbase + wsize;\r\nif ((u64)base < wend && end > wbase)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int mvebu_mbus_find_window(struct mvebu_mbus_state *mbus,\r\nphys_addr_t base, size_t size)\r\n{\r\nint win;\r\nfor (win = 0; win < mbus->soc->num_wins; win++) {\r\nu64 wbase;\r\nu32 wsize;\r\nint enabled;\r\nmvebu_mbus_read_window(mbus, win,\r\n&enabled, &wbase, &wsize,\r\nNULL, NULL, NULL);\r\nif (!enabled)\r\ncontinue;\r\nif (base == wbase && size == wsize)\r\nreturn win;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int mvebu_mbus_setup_window(struct mvebu_mbus_state *mbus,\r\nint win, phys_addr_t base, size_t size,\r\nphys_addr_t remap, u8 target,\r\nu8 attr)\r\n{\r\nvoid __iomem *addr = mbus->mbuswins_base +\r\nmbus->soc->win_cfg_offset(win);\r\nu32 ctrl, remap_addr;\r\nif (!is_power_of_2(size)) {\r\nWARN(true, "Invalid MBus window size: 0x%zx\n", size);\r\nreturn -EINVAL;\r\n}\r\nif ((base & (phys_addr_t)(size - 1)) != 0) {\r\nWARN(true, "Invalid MBus base/size: %pa len 0x%zx\n", &base,\r\nsize);\r\nreturn -EINVAL;\r\n}\r\nctrl = ((size - 1) & WIN_CTRL_SIZE_MASK) |\r\n(attr << WIN_CTRL_ATTR_SHIFT) |\r\n(target << WIN_CTRL_TGT_SHIFT) |\r\nWIN_CTRL_ENABLE;\r\nif (mbus->hw_io_coherency)\r\nctrl |= WIN_CTRL_SYNCBARRIER;\r\nwritel(base & WIN_BASE_LOW, addr + WIN_BASE_OFF);\r\nwritel(ctrl, addr + WIN_CTRL_OFF);\r\nif (mvebu_mbus_window_is_remappable(mbus, win)) {\r\nvoid __iomem *addr_rmp = mbus->mbuswins_base +\r\nmbus->soc->win_remap_offset(win);\r\nif (remap == MVEBU_MBUS_NO_REMAP)\r\nremap_addr = base;\r\nelse\r\nremap_addr = remap;\r\nwritel(remap_addr & WIN_REMAP_LOW, addr_rmp + WIN_REMAP_LO_OFF);\r\nwritel(0, addr_rmp + WIN_REMAP_HI_OFF);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mvebu_mbus_alloc_window(struct mvebu_mbus_state *mbus,\r\nphys_addr_t base, size_t size,\r\nphys_addr_t remap, u8 target,\r\nu8 attr)\r\n{\r\nint win;\r\nif (remap == MVEBU_MBUS_NO_REMAP) {\r\nfor (win = 0; win < mbus->soc->num_wins; win++) {\r\nif (mvebu_mbus_window_is_remappable(mbus, win))\r\ncontinue;\r\nif (mvebu_mbus_window_is_free(mbus, win))\r\nreturn mvebu_mbus_setup_window(mbus, win, base,\r\nsize, remap,\r\ntarget, attr);\r\n}\r\n}\r\nfor (win = 0; win < mbus->soc->num_wins; win++) {\r\nif ((remap != MVEBU_MBUS_NO_REMAP) &&\r\n!mvebu_mbus_window_is_remappable(mbus, win))\r\ncontinue;\r\nif (mvebu_mbus_window_is_free(mbus, win))\r\nreturn mvebu_mbus_setup_window(mbus, win, base, size,\r\nremap, target, attr);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic int mvebu_sdram_debug_show_orion(struct mvebu_mbus_state *mbus,\r\nstruct seq_file *seq, void *v)\r\n{\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nu32 basereg = readl(mbus->sdramwins_base + DDR_BASE_CS_OFF(i));\r\nu32 sizereg = readl(mbus->sdramwins_base + DDR_SIZE_CS_OFF(i));\r\nu64 base;\r\nu32 size;\r\nif (!(sizereg & DDR_SIZE_ENABLED)) {\r\nseq_printf(seq, "[%d] disabled\n", i);\r\ncontinue;\r\n}\r\nbase = ((u64)basereg & DDR_BASE_CS_HIGH_MASK) << 32;\r\nbase |= basereg & DDR_BASE_CS_LOW_MASK;\r\nsize = (sizereg | ~DDR_SIZE_MASK);\r\nseq_printf(seq, "[%d] %016llx - %016llx : cs%d\n",\r\ni, (unsigned long long)base,\r\n(unsigned long long)base + size + 1,\r\n(sizereg & DDR_SIZE_CS_MASK) >> DDR_SIZE_CS_SHIFT);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mvebu_sdram_debug_show_dove(struct mvebu_mbus_state *mbus,\r\nstruct seq_file *seq, void *v)\r\n{\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nu32 map = readl(mbus->sdramwins_base + DOVE_DDR_BASE_CS_OFF(i));\r\nu64 base;\r\nu32 size;\r\nif (!(map & 1)) {\r\nseq_printf(seq, "[%d] disabled\n", i);\r\ncontinue;\r\n}\r\nbase = map & 0xff800000;\r\nsize = 0x100000 << (((map & 0x000f0000) >> 16) - 4);\r\nseq_printf(seq, "[%d] %016llx - %016llx : cs%d\n",\r\ni, (unsigned long long)base,\r\n(unsigned long long)base + size, i);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mvebu_sdram_debug_show(struct seq_file *seq, void *v)\r\n{\r\nstruct mvebu_mbus_state *mbus = &mbus_state;\r\nreturn mbus->soc->show_cpu_target(mbus, seq, v);\r\n}\r\nstatic int mvebu_sdram_debug_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, mvebu_sdram_debug_show, inode->i_private);\r\n}\r\nstatic int mvebu_devs_debug_show(struct seq_file *seq, void *v)\r\n{\r\nstruct mvebu_mbus_state *mbus = &mbus_state;\r\nint win;\r\nfor (win = 0; win < mbus->soc->num_wins; win++) {\r\nu64 wbase, wremap;\r\nu32 wsize;\r\nu8 wtarget, wattr;\r\nint enabled;\r\nmvebu_mbus_read_window(mbus, win,\r\n&enabled, &wbase, &wsize,\r\n&wtarget, &wattr, &wremap);\r\nif (!enabled) {\r\nseq_printf(seq, "[%02d] disabled\n", win);\r\ncontinue;\r\n}\r\nseq_printf(seq, "[%02d] %016llx - %016llx : %04x:%04x",\r\nwin, (unsigned long long)wbase,\r\n(unsigned long long)(wbase + wsize), wtarget, wattr);\r\nif (!is_power_of_2(wsize) ||\r\n((wbase & (u64)(wsize - 1)) != 0))\r\nseq_puts(seq, " (Invalid base/size!!)");\r\nif (mvebu_mbus_window_is_remappable(mbus, win)) {\r\nseq_printf(seq, " (remap %016llx)\n",\r\n(unsigned long long)wremap);\r\n} else\r\nseq_printf(seq, "\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int mvebu_devs_debug_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, mvebu_devs_debug_show, inode->i_private);\r\n}\r\nstatic unsigned int generic_mbus_win_cfg_offset(int win)\r\n{\r\nreturn win << 4;\r\n}\r\nstatic unsigned int armada_370_xp_mbus_win_cfg_offset(int win)\r\n{\r\nif (win < 8)\r\nreturn win << 4;\r\nelse\r\nreturn 0x90 + ((win - 8) << 3);\r\n}\r\nstatic unsigned int mv78xx0_mbus_win_cfg_offset(int win)\r\n{\r\nif (win < 8)\r\nreturn win << 4;\r\nelse\r\nreturn 0x900 + ((win - 8) << 4);\r\n}\r\nstatic unsigned int generic_mbus_win_remap_2_offset(int win)\r\n{\r\nif (win < 2)\r\nreturn generic_mbus_win_cfg_offset(win);\r\nelse\r\nreturn MVEBU_MBUS_NO_REMAP;\r\n}\r\nstatic unsigned int generic_mbus_win_remap_4_offset(int win)\r\n{\r\nif (win < 4)\r\nreturn generic_mbus_win_cfg_offset(win);\r\nelse\r\nreturn MVEBU_MBUS_NO_REMAP;\r\n}\r\nstatic unsigned int generic_mbus_win_remap_8_offset(int win)\r\n{\r\nif (win < 8)\r\nreturn generic_mbus_win_cfg_offset(win);\r\nelse\r\nreturn MVEBU_MBUS_NO_REMAP;\r\n}\r\nstatic unsigned int armada_xp_mbus_win_remap_offset(int win)\r\n{\r\nif (win < 8)\r\nreturn generic_mbus_win_cfg_offset(win);\r\nelse if (win == 13)\r\nreturn 0xF0 - WIN_REMAP_LO_OFF;\r\nelse\r\nreturn MVEBU_MBUS_NO_REMAP;\r\n}\r\nstatic void __init\r\nmvebu_mbus_find_bridge_hole(uint64_t *start, uint64_t *end)\r\n{\r\nstruct memblock_region *r;\r\nuint64_t s = 0;\r\nfor_each_memblock(memory, r) {\r\nif (r->base >= 0x100000000ULL)\r\ncontinue;\r\nif (r->base + r->size > s)\r\ns = r->base + r->size;\r\n}\r\n*start = s;\r\n*end = 0x100000000ULL;\r\n}\r\nstatic void __init\r\nmvebu_mbus_setup_cpu_target_nooverlap(struct mvebu_mbus_state *mbus)\r\n{\r\nuint64_t mbus_bridge_base, mbus_bridge_end;\r\nint cs_nooverlap = 0;\r\nint i;\r\nmvebu_mbus_find_bridge_hole(&mbus_bridge_base, &mbus_bridge_end);\r\nfor (i = 0; i < mvebu_mbus_dram_info.num_cs; i++) {\r\nstruct mbus_dram_window *w;\r\nu64 base, size, end;\r\nw = &mvebu_mbus_dram_info.cs[i];\r\nbase = w->base;\r\nsize = w->size;\r\nend = base + size;\r\nif (base >= mbus_bridge_base && end <= mbus_bridge_end)\r\ncontinue;\r\nif (base >= mbus_bridge_base && end > mbus_bridge_end) {\r\nsize -= mbus_bridge_end - base;\r\nbase = mbus_bridge_end;\r\n}\r\nif (base < mbus_bridge_base && end > mbus_bridge_base)\r\nsize -= end - mbus_bridge_base;\r\nw = &mvebu_mbus_dram_info_nooverlap.cs[cs_nooverlap++];\r\nw->cs_index = i;\r\nw->mbus_attr = 0xf & ~(1 << i);\r\nif (mbus->hw_io_coherency)\r\nw->mbus_attr |= ATTR_HW_COHERENCY;\r\nw->base = base;\r\nw->size = size;\r\n}\r\nmvebu_mbus_dram_info_nooverlap.mbus_dram_target_id = TARGET_DDR;\r\nmvebu_mbus_dram_info_nooverlap.num_cs = cs_nooverlap;\r\n}\r\nstatic void __init\r\nmvebu_mbus_default_setup_cpu_target(struct mvebu_mbus_state *mbus)\r\n{\r\nint i;\r\nint cs;\r\nmvebu_mbus_dram_info.mbus_dram_target_id = TARGET_DDR;\r\nfor (i = 0, cs = 0; i < 4; i++) {\r\nu32 base = readl(mbus->sdramwins_base + DDR_BASE_CS_OFF(i));\r\nu32 size = readl(mbus->sdramwins_base + DDR_SIZE_CS_OFF(i));\r\nif ((size & DDR_SIZE_ENABLED) &&\r\n!(base & DDR_BASE_CS_HIGH_MASK)) {\r\nstruct mbus_dram_window *w;\r\nw = &mvebu_mbus_dram_info.cs[cs++];\r\nw->cs_index = i;\r\nw->mbus_attr = 0xf & ~(1 << i);\r\nif (mbus->hw_io_coherency)\r\nw->mbus_attr |= ATTR_HW_COHERENCY;\r\nw->base = base & DDR_BASE_CS_LOW_MASK;\r\nw->size = (size | ~DDR_SIZE_MASK) + 1;\r\n}\r\n}\r\nmvebu_mbus_dram_info.num_cs = cs;\r\n}\r\nstatic int\r\nmvebu_mbus_default_save_cpu_target(struct mvebu_mbus_state *mbus,\r\nu32 *store_addr)\r\n{\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nu32 base = readl(mbus->sdramwins_base + DDR_BASE_CS_OFF(i));\r\nu32 size = readl(mbus->sdramwins_base + DDR_SIZE_CS_OFF(i));\r\nwritel(mbus->sdramwins_phys_base + DDR_BASE_CS_OFF(i),\r\nstore_addr++);\r\nwritel(base, store_addr++);\r\nwritel(mbus->sdramwins_phys_base + DDR_SIZE_CS_OFF(i),\r\nstore_addr++);\r\nwritel(size, store_addr++);\r\n}\r\nreturn 16;\r\n}\r\nstatic void __init\r\nmvebu_mbus_dove_setup_cpu_target(struct mvebu_mbus_state *mbus)\r\n{\r\nint i;\r\nint cs;\r\nmvebu_mbus_dram_info.mbus_dram_target_id = TARGET_DDR;\r\nfor (i = 0, cs = 0; i < 2; i++) {\r\nu32 map = readl(mbus->sdramwins_base + DOVE_DDR_BASE_CS_OFF(i));\r\nif (map & 1) {\r\nstruct mbus_dram_window *w;\r\nw = &mvebu_mbus_dram_info.cs[cs++];\r\nw->cs_index = i;\r\nw->mbus_attr = 0;\r\nw->base = map & 0xff800000;\r\nw->size = 0x100000 << (((map & 0x000f0000) >> 16) - 4);\r\n}\r\n}\r\nmvebu_mbus_dram_info.num_cs = cs;\r\n}\r\nstatic int\r\nmvebu_mbus_dove_save_cpu_target(struct mvebu_mbus_state *mbus,\r\nu32 *store_addr)\r\n{\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nu32 map = readl(mbus->sdramwins_base + DOVE_DDR_BASE_CS_OFF(i));\r\nwritel(mbus->sdramwins_phys_base + DOVE_DDR_BASE_CS_OFF(i),\r\nstore_addr++);\r\nwritel(map, store_addr++);\r\n}\r\nreturn 4;\r\n}\r\nint mvebu_mbus_save_cpu_target(u32 *store_addr)\r\n{\r\nreturn mbus_state.soc->save_cpu_target(&mbus_state, store_addr);\r\n}\r\nint mvebu_mbus_add_window_remap_by_id(unsigned int target,\r\nunsigned int attribute,\r\nphys_addr_t base, size_t size,\r\nphys_addr_t remap)\r\n{\r\nstruct mvebu_mbus_state *s = &mbus_state;\r\nif (!mvebu_mbus_window_conflicts(s, base, size, target, attribute)) {\r\npr_err("cannot add window '%x:%x', conflicts with another window\n",\r\ntarget, attribute);\r\nreturn -EINVAL;\r\n}\r\nreturn mvebu_mbus_alloc_window(s, base, size, remap, target, attribute);\r\n}\r\nint mvebu_mbus_add_window_by_id(unsigned int target, unsigned int attribute,\r\nphys_addr_t base, size_t size)\r\n{\r\nreturn mvebu_mbus_add_window_remap_by_id(target, attribute, base,\r\nsize, MVEBU_MBUS_NO_REMAP);\r\n}\r\nint mvebu_mbus_del_window(phys_addr_t base, size_t size)\r\n{\r\nint win;\r\nwin = mvebu_mbus_find_window(&mbus_state, base, size);\r\nif (win < 0)\r\nreturn win;\r\nmvebu_mbus_disable_window(&mbus_state, win);\r\nreturn 0;\r\n}\r\nvoid mvebu_mbus_get_pcie_mem_aperture(struct resource *res)\r\n{\r\nif (!res)\r\nreturn;\r\n*res = mbus_state.pcie_mem_aperture;\r\n}\r\nvoid mvebu_mbus_get_pcie_io_aperture(struct resource *res)\r\n{\r\nif (!res)\r\nreturn;\r\n*res = mbus_state.pcie_io_aperture;\r\n}\r\nstatic __init int mvebu_mbus_debugfs_init(void)\r\n{\r\nstruct mvebu_mbus_state *s = &mbus_state;\r\nif (!s->mbuswins_base)\r\nreturn 0;\r\ns->debugfs_root = debugfs_create_dir("mvebu-mbus", NULL);\r\nif (s->debugfs_root) {\r\ns->debugfs_sdram = debugfs_create_file("sdram", S_IRUGO,\r\ns->debugfs_root, NULL,\r\n&mvebu_sdram_debug_fops);\r\ns->debugfs_devs = debugfs_create_file("devices", S_IRUGO,\r\ns->debugfs_root, NULL,\r\n&mvebu_devs_debug_fops);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mvebu_mbus_suspend(void)\r\n{\r\nstruct mvebu_mbus_state *s = &mbus_state;\r\nint win;\r\nif (!s->mbusbridge_base)\r\nreturn -ENODEV;\r\nfor (win = 0; win < s->soc->num_wins; win++) {\r\nvoid __iomem *addr = s->mbuswins_base +\r\ns->soc->win_cfg_offset(win);\r\nvoid __iomem *addr_rmp;\r\ns->wins[win].base = readl(addr + WIN_BASE_OFF);\r\ns->wins[win].ctrl = readl(addr + WIN_CTRL_OFF);\r\nif (!mvebu_mbus_window_is_remappable(s, win))\r\ncontinue;\r\naddr_rmp = s->mbuswins_base +\r\ns->soc->win_remap_offset(win);\r\ns->wins[win].remap_lo = readl(addr_rmp + WIN_REMAP_LO_OFF);\r\ns->wins[win].remap_hi = readl(addr_rmp + WIN_REMAP_HI_OFF);\r\n}\r\ns->mbus_bridge_ctrl = readl(s->mbusbridge_base +\r\nMBUS_BRIDGE_CTRL_OFF);\r\ns->mbus_bridge_base = readl(s->mbusbridge_base +\r\nMBUS_BRIDGE_BASE_OFF);\r\nreturn 0;\r\n}\r\nstatic void mvebu_mbus_resume(void)\r\n{\r\nstruct mvebu_mbus_state *s = &mbus_state;\r\nint win;\r\nwritel(s->mbus_bridge_ctrl,\r\ns->mbusbridge_base + MBUS_BRIDGE_CTRL_OFF);\r\nwritel(s->mbus_bridge_base,\r\ns->mbusbridge_base + MBUS_BRIDGE_BASE_OFF);\r\nfor (win = 0; win < s->soc->num_wins; win++) {\r\nvoid __iomem *addr = s->mbuswins_base +\r\ns->soc->win_cfg_offset(win);\r\nvoid __iomem *addr_rmp;\r\nwritel(s->wins[win].base, addr + WIN_BASE_OFF);\r\nwritel(s->wins[win].ctrl, addr + WIN_CTRL_OFF);\r\nif (!mvebu_mbus_window_is_remappable(s, win))\r\ncontinue;\r\naddr_rmp = s->mbuswins_base +\r\ns->soc->win_remap_offset(win);\r\nwritel(s->wins[win].remap_lo, addr_rmp + WIN_REMAP_LO_OFF);\r\nwritel(s->wins[win].remap_hi, addr_rmp + WIN_REMAP_HI_OFF);\r\n}\r\n}\r\nstatic int __init mvebu_mbus_common_init(struct mvebu_mbus_state *mbus,\r\nphys_addr_t mbuswins_phys_base,\r\nsize_t mbuswins_size,\r\nphys_addr_t sdramwins_phys_base,\r\nsize_t sdramwins_size,\r\nphys_addr_t mbusbridge_phys_base,\r\nsize_t mbusbridge_size,\r\nbool is_coherent)\r\n{\r\nint win;\r\nmbus->mbuswins_base = ioremap(mbuswins_phys_base, mbuswins_size);\r\nif (!mbus->mbuswins_base)\r\nreturn -ENOMEM;\r\nmbus->sdramwins_base = ioremap(sdramwins_phys_base, sdramwins_size);\r\nif (!mbus->sdramwins_base) {\r\niounmap(mbus_state.mbuswins_base);\r\nreturn -ENOMEM;\r\n}\r\nmbus->sdramwins_phys_base = sdramwins_phys_base;\r\nif (mbusbridge_phys_base) {\r\nmbus->mbusbridge_base = ioremap(mbusbridge_phys_base,\r\nmbusbridge_size);\r\nif (!mbus->mbusbridge_base) {\r\niounmap(mbus->sdramwins_base);\r\niounmap(mbus->mbuswins_base);\r\nreturn -ENOMEM;\r\n}\r\n} else\r\nmbus->mbusbridge_base = NULL;\r\nfor (win = 0; win < mbus->soc->num_wins; win++)\r\nmvebu_mbus_disable_window(mbus, win);\r\nmbus->soc->setup_cpu_target(mbus);\r\nmvebu_mbus_setup_cpu_target_nooverlap(mbus);\r\nif (is_coherent)\r\nwritel(UNIT_SYNC_BARRIER_ALL,\r\nmbus->mbuswins_base + UNIT_SYNC_BARRIER_OFF);\r\nregister_syscore_ops(&mvebu_mbus_syscore_ops);\r\nreturn 0;\r\n}\r\nint __init mvebu_mbus_init(const char *soc, phys_addr_t mbuswins_phys_base,\r\nsize_t mbuswins_size,\r\nphys_addr_t sdramwins_phys_base,\r\nsize_t sdramwins_size)\r\n{\r\nconst struct of_device_id *of_id;\r\nfor (of_id = of_mvebu_mbus_ids; of_id->compatible[0]; of_id++)\r\nif (!strcmp(of_id->compatible, soc))\r\nbreak;\r\nif (!of_id->compatible[0]) {\r\npr_err("could not find a matching SoC family\n");\r\nreturn -ENODEV;\r\n}\r\nmbus_state.soc = of_id->data;\r\nreturn mvebu_mbus_common_init(&mbus_state,\r\nmbuswins_phys_base,\r\nmbuswins_size,\r\nsdramwins_phys_base,\r\nsdramwins_size, 0, 0, false);\r\n}\r\nstatic int __init mbus_dt_setup_win(struct mvebu_mbus_state *mbus,\r\nu32 base, u32 size,\r\nu8 target, u8 attr)\r\n{\r\nif (!mvebu_mbus_window_conflicts(mbus, base, size, target, attr)) {\r\npr_err("cannot add window '%04x:%04x', conflicts with another window\n",\r\ntarget, attr);\r\nreturn -EBUSY;\r\n}\r\nif (mvebu_mbus_alloc_window(mbus, base, size, MVEBU_MBUS_NO_REMAP,\r\ntarget, attr)) {\r\npr_err("cannot add window '%04x:%04x', too many windows\n",\r\ntarget, attr);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init\r\nmbus_parse_ranges(struct device_node *node,\r\nint *addr_cells, int *c_addr_cells, int *c_size_cells,\r\nint *cell_count, const __be32 **ranges_start,\r\nconst __be32 **ranges_end)\r\n{\r\nconst __be32 *prop;\r\nint ranges_len, tuple_len;\r\n*ranges_start = of_get_property(node, "ranges", &ranges_len);\r\nif (*ranges_start == NULL) {\r\n*addr_cells = *c_addr_cells = *c_size_cells = *cell_count = 0;\r\n*ranges_start = *ranges_end = NULL;\r\nreturn 0;\r\n}\r\n*ranges_end = *ranges_start + ranges_len / sizeof(__be32);\r\n*addr_cells = of_n_addr_cells(node);\r\nprop = of_get_property(node, "#address-cells", NULL);\r\n*c_addr_cells = be32_to_cpup(prop);\r\nprop = of_get_property(node, "#size-cells", NULL);\r\n*c_size_cells = be32_to_cpup(prop);\r\n*cell_count = *addr_cells + *c_addr_cells + *c_size_cells;\r\ntuple_len = (*cell_count) * sizeof(__be32);\r\nif (ranges_len % tuple_len) {\r\npr_warn("malformed ranges entry '%s'\n", node->name);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init mbus_dt_setup(struct mvebu_mbus_state *mbus,\r\nstruct device_node *np)\r\n{\r\nint addr_cells, c_addr_cells, c_size_cells;\r\nint i, ret, cell_count;\r\nconst __be32 *r, *ranges_start, *ranges_end;\r\nret = mbus_parse_ranges(np, &addr_cells, &c_addr_cells,\r\n&c_size_cells, &cell_count,\r\n&ranges_start, &ranges_end);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0, r = ranges_start; r < ranges_end; r += cell_count, i++) {\r\nu32 windowid, base, size;\r\nu8 target, attr;\r\nwindowid = of_read_number(r, 1);\r\nif (CUSTOM(windowid))\r\ncontinue;\r\ntarget = TARGET(windowid);\r\nattr = ATTR(windowid);\r\nbase = of_read_number(r + c_addr_cells, addr_cells);\r\nsize = of_read_number(r + c_addr_cells + addr_cells,\r\nc_size_cells);\r\nret = mbus_dt_setup_win(mbus, base, size, target, attr);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init mvebu_mbus_get_pcie_resources(struct device_node *np,\r\nstruct resource *mem,\r\nstruct resource *io)\r\n{\r\nu32 reg[2];\r\nint ret;\r\nmemset(mem, 0, sizeof(struct resource));\r\nmem->end = -1;\r\nmemset(io, 0, sizeof(struct resource));\r\nio->end = -1;\r\nret = of_property_read_u32_array(np, "pcie-mem-aperture", reg, ARRAY_SIZE(reg));\r\nif (!ret) {\r\nmem->start = reg[0];\r\nmem->end = mem->start + reg[1] - 1;\r\nmem->flags = IORESOURCE_MEM;\r\n}\r\nret = of_property_read_u32_array(np, "pcie-io-aperture", reg, ARRAY_SIZE(reg));\r\nif (!ret) {\r\nio->start = reg[0];\r\nio->end = io->start + reg[1] - 1;\r\nio->flags = IORESOURCE_IO;\r\n}\r\n}\r\nint __init mvebu_mbus_dt_init(bool is_coherent)\r\n{\r\nstruct resource mbuswins_res, sdramwins_res, mbusbridge_res;\r\nstruct device_node *np, *controller;\r\nconst struct of_device_id *of_id;\r\nconst __be32 *prop;\r\nint ret;\r\nnp = of_find_matching_node_and_match(NULL, of_mvebu_mbus_ids, &of_id);\r\nif (!np) {\r\npr_err("could not find a matching SoC family\n");\r\nreturn -ENODEV;\r\n}\r\nmbus_state.soc = of_id->data;\r\nprop = of_get_property(np, "controller", NULL);\r\nif (!prop) {\r\npr_err("required 'controller' property missing\n");\r\nreturn -EINVAL;\r\n}\r\ncontroller = of_find_node_by_phandle(be32_to_cpup(prop));\r\nif (!controller) {\r\npr_err("could not find an 'mbus-controller' node\n");\r\nreturn -ENODEV;\r\n}\r\nif (of_address_to_resource(controller, 0, &mbuswins_res)) {\r\npr_err("cannot get MBUS register address\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_address_to_resource(controller, 1, &sdramwins_res)) {\r\npr_err("cannot get SDRAM register address\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(&mbusbridge_res, 0, sizeof(mbusbridge_res));\r\nif (mbus_state.soc->has_mbus_bridge) {\r\nif (of_address_to_resource(controller, 2, &mbusbridge_res))\r\npr_warn(FW_WARN "deprecated mbus-mvebu Device Tree, suspend/resume will not work\n");\r\n}\r\nmbus_state.hw_io_coherency = is_coherent;\r\nmvebu_mbus_get_pcie_resources(np, &mbus_state.pcie_mem_aperture,\r\n&mbus_state.pcie_io_aperture);\r\nret = mvebu_mbus_common_init(&mbus_state,\r\nmbuswins_res.start,\r\nresource_size(&mbuswins_res),\r\nsdramwins_res.start,\r\nresource_size(&sdramwins_res),\r\nmbusbridge_res.start,\r\nresource_size(&mbusbridge_res),\r\nis_coherent);\r\nif (ret)\r\nreturn ret;\r\nreturn mbus_dt_setup(&mbus_state, np);\r\n}
