static inline u32 pmx_readl(struct tegra_pmx *pmx, u32 bank, u32 reg)\r\n{\r\nreturn readl(pmx->regs[bank] + reg);\r\n}\r\nstatic inline void pmx_writel(struct tegra_pmx *pmx, u32 val, u32 bank, u32 reg)\r\n{\r\nwritel(val, pmx->regs[bank] + reg);\r\n}\r\nstatic int tegra_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->soc->ngroups;\r\n}\r\nstatic const char *tegra_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->soc->groups[group].name;\r\n}\r\nstatic int tegra_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = pmx->soc->groups[group].pins;\r\n*num_pins = pmx->soc->groups[group].npins;\r\nreturn 0;\r\n}\r\nstatic void tegra_pinctrl_pin_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s,\r\nunsigned offset)\r\n{\r\nseq_printf(s, " %s", dev_name(pctldev->dev));\r\n}\r\nstatic int tegra_pinctrl_dt_subnode_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map,\r\nunsigned *reserved_maps,\r\nunsigned *num_maps)\r\n{\r\nstruct device *dev = pctldev->dev;\r\nint ret, i;\r\nconst char *function;\r\nu32 val;\r\nunsigned long config;\r\nunsigned long *configs = NULL;\r\nunsigned num_configs = 0;\r\nunsigned reserve;\r\nstruct property *prop;\r\nconst char *group;\r\nret = of_property_read_string(np, "nvidia,function", &function);\r\nif (ret < 0) {\r\nif (ret != -EINVAL)\r\ndev_err(dev,\r\n"could not parse property nvidia,function\n");\r\nfunction = NULL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(cfg_params); i++) {\r\nret = of_property_read_u32(np, cfg_params[i].property, &val);\r\nif (!ret) {\r\nconfig = TEGRA_PINCONF_PACK(cfg_params[i].param, val);\r\nret = pinctrl_utils_add_config(pctldev, &configs,\r\n&num_configs, config);\r\nif (ret < 0)\r\ngoto exit;\r\n} else if (ret != -EINVAL) {\r\ndev_err(dev, "could not parse property %s\n",\r\ncfg_params[i].property);\r\n}\r\n}\r\nreserve = 0;\r\nif (function != NULL)\r\nreserve++;\r\nif (num_configs)\r\nreserve++;\r\nret = of_property_count_strings(np, "nvidia,pins");\r\nif (ret < 0) {\r\ndev_err(dev, "could not parse property nvidia,pins\n");\r\ngoto exit;\r\n}\r\nreserve *= ret;\r\nret = pinctrl_utils_reserve_map(pctldev, map, reserved_maps,\r\nnum_maps, reserve);\r\nif (ret < 0)\r\ngoto exit;\r\nof_property_for_each_string(np, "nvidia,pins", prop, group) {\r\nif (function) {\r\nret = pinctrl_utils_add_map_mux(pctldev, map,\r\nreserved_maps, num_maps, group,\r\nfunction);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\nif (num_configs) {\r\nret = pinctrl_utils_add_map_configs(pctldev, map,\r\nreserved_maps, num_maps, group,\r\nconfigs, num_configs,\r\nPIN_MAP_TYPE_CONFIGS_GROUP);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\n}\r\nret = 0;\r\nexit:\r\nkfree(configs);\r\nreturn ret;\r\n}\r\nstatic int tegra_pinctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np_config,\r\nstruct pinctrl_map **map,\r\nunsigned *num_maps)\r\n{\r\nunsigned reserved_maps;\r\nstruct device_node *np;\r\nint ret;\r\nreserved_maps = 0;\r\n*map = NULL;\r\n*num_maps = 0;\r\nfor_each_child_of_node(np_config, np) {\r\nret = tegra_pinctrl_dt_subnode_to_map(pctldev, np, map,\r\n&reserved_maps, num_maps);\r\nif (ret < 0) {\r\npinctrl_utils_dt_free_map(pctldev, *map,\r\n*num_maps);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_pinctrl_get_funcs_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->soc->nfunctions;\r\n}\r\nstatic const char *tegra_pinctrl_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned function)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->soc->functions[function].name;\r\n}\r\nstatic int tegra_pinctrl_get_func_groups(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pmx->soc->functions[function].groups;\r\n*num_groups = pmx->soc->functions[function].ngroups;\r\nreturn 0;\r\n}\r\nstatic int tegra_pinctrl_set_mux(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nunsigned group)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct tegra_pingroup *g;\r\nint i;\r\nu32 val;\r\ng = &pmx->soc->groups[group];\r\nif (WARN_ON(g->mux_reg < 0))\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(g->funcs); i++) {\r\nif (g->funcs[i] == function)\r\nbreak;\r\n}\r\nif (WARN_ON(i == ARRAY_SIZE(g->funcs)))\r\nreturn -EINVAL;\r\nval = pmx_readl(pmx, g->mux_bank, g->mux_reg);\r\nval &= ~(0x3 << g->mux_bit);\r\nval |= i << g->mux_bit;\r\npmx_writel(pmx, val, g->mux_bank, g->mux_reg);\r\nreturn 0;\r\n}\r\nstatic int tegra_pinconf_reg(struct tegra_pmx *pmx,\r\nconst struct tegra_pingroup *g,\r\nenum tegra_pinconf_param param,\r\nbool report_err,\r\ns8 *bank, s16 *reg, s8 *bit, s8 *width)\r\n{\r\nswitch (param) {\r\ncase TEGRA_PINCONF_PARAM_PULL:\r\n*bank = g->pupd_bank;\r\n*reg = g->pupd_reg;\r\n*bit = g->pupd_bit;\r\n*width = 2;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_TRISTATE:\r\n*bank = g->tri_bank;\r\n*reg = g->tri_reg;\r\n*bit = g->tri_bit;\r\n*width = 1;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_ENABLE_INPUT:\r\n*bank = g->mux_bank;\r\n*reg = g->mux_reg;\r\n*bit = g->einput_bit;\r\n*width = 1;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_OPEN_DRAIN:\r\n*bank = g->mux_bank;\r\n*reg = g->mux_reg;\r\n*bit = g->odrain_bit;\r\n*width = 1;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_LOCK:\r\n*bank = g->mux_bank;\r\n*reg = g->mux_reg;\r\n*bit = g->lock_bit;\r\n*width = 1;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_IORESET:\r\n*bank = g->mux_bank;\r\n*reg = g->mux_reg;\r\n*bit = g->ioreset_bit;\r\n*width = 1;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_RCV_SEL:\r\n*bank = g->mux_bank;\r\n*reg = g->mux_reg;\r\n*bit = g->rcv_sel_bit;\r\n*width = 1;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_HIGH_SPEED_MODE:\r\nif (pmx->soc->hsm_in_mux) {\r\n*bank = g->mux_bank;\r\n*reg = g->mux_reg;\r\n} else {\r\n*bank = g->drv_bank;\r\n*reg = g->drv_reg;\r\n}\r\n*bit = g->hsm_bit;\r\n*width = 1;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_SCHMITT:\r\nif (pmx->soc->schmitt_in_mux) {\r\n*bank = g->mux_bank;\r\n*reg = g->mux_reg;\r\n} else {\r\n*bank = g->drv_bank;\r\n*reg = g->drv_reg;\r\n}\r\n*bit = g->schmitt_bit;\r\n*width = 1;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_LOW_POWER_MODE:\r\n*bank = g->drv_bank;\r\n*reg = g->drv_reg;\r\n*bit = g->lpmd_bit;\r\n*width = 2;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_DRIVE_DOWN_STRENGTH:\r\n*bank = g->drv_bank;\r\n*reg = g->drv_reg;\r\n*bit = g->drvdn_bit;\r\n*width = g->drvdn_width;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_DRIVE_UP_STRENGTH:\r\n*bank = g->drv_bank;\r\n*reg = g->drv_reg;\r\n*bit = g->drvup_bit;\r\n*width = g->drvup_width;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_SLEW_RATE_FALLING:\r\n*bank = g->drv_bank;\r\n*reg = g->drv_reg;\r\n*bit = g->slwf_bit;\r\n*width = g->slwf_width;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_SLEW_RATE_RISING:\r\n*bank = g->drv_bank;\r\n*reg = g->drv_reg;\r\n*bit = g->slwr_bit;\r\n*width = g->slwr_width;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_DRIVE_TYPE:\r\nif (pmx->soc->drvtype_in_mux) {\r\n*bank = g->mux_bank;\r\n*reg = g->mux_reg;\r\n} else {\r\n*bank = g->drv_bank;\r\n*reg = g->drv_reg;\r\n}\r\n*bit = g->drvtype_bit;\r\n*width = 2;\r\nbreak;\r\ndefault:\r\ndev_err(pmx->dev, "Invalid config param %04x\n", param);\r\nreturn -ENOTSUPP;\r\n}\r\nif (*reg < 0 || *bit > 31) {\r\nif (report_err) {\r\nconst char *prop = "unknown";\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cfg_params); i++) {\r\nif (cfg_params[i].param == param) {\r\nprop = cfg_params[i].property;\r\nbreak;\r\n}\r\n}\r\ndev_err(pmx->dev,\r\n"Config param %04x (%s) not supported on group %s\n",\r\nparam, prop, g->name);\r\n}\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_pinconf_get(struct pinctrl_dev *pctldev,\r\nunsigned pin, unsigned long *config)\r\n{\r\ndev_err(pctldev->dev, "pin_config_get op not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int tegra_pinconf_set(struct pinctrl_dev *pctldev,\r\nunsigned pin, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\ndev_err(pctldev->dev, "pin_config_set op not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int tegra_pinconf_group_get(struct pinctrl_dev *pctldev,\r\nunsigned group, unsigned long *config)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nenum tegra_pinconf_param param = TEGRA_PINCONF_UNPACK_PARAM(*config);\r\nu16 arg;\r\nconst struct tegra_pingroup *g;\r\nint ret;\r\ns8 bank, bit, width;\r\ns16 reg;\r\nu32 val, mask;\r\ng = &pmx->soc->groups[group];\r\nret = tegra_pinconf_reg(pmx, g, param, true, &bank, &reg, &bit,\r\n&width);\r\nif (ret < 0)\r\nreturn ret;\r\nval = pmx_readl(pmx, bank, reg);\r\nmask = (1 << width) - 1;\r\narg = (val >> bit) & mask;\r\n*config = TEGRA_PINCONF_PACK(param, arg);\r\nreturn 0;\r\n}\r\nstatic int tegra_pinconf_group_set(struct pinctrl_dev *pctldev,\r\nunsigned group, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nenum tegra_pinconf_param param;\r\nu16 arg;\r\nconst struct tegra_pingroup *g;\r\nint ret, i;\r\ns8 bank, bit, width;\r\ns16 reg;\r\nu32 val, mask;\r\ng = &pmx->soc->groups[group];\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = TEGRA_PINCONF_UNPACK_PARAM(configs[i]);\r\narg = TEGRA_PINCONF_UNPACK_ARG(configs[i]);\r\nret = tegra_pinconf_reg(pmx, g, param, true, &bank, &reg, &bit,\r\n&width);\r\nif (ret < 0)\r\nreturn ret;\r\nval = pmx_readl(pmx, bank, reg);\r\nif (param == TEGRA_PINCONF_PARAM_LOCK) {\r\nif ((val & BIT(bit)) && !arg) {\r\ndev_err(pctldev->dev, "LOCK bit cannot be cleared\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (width == 1)\r\narg = !!arg;\r\nmask = (1 << width) - 1;\r\nif (arg & ~mask) {\r\ndev_err(pctldev->dev,\r\n"config %lx: %x too big for %d bit register\n",\r\nconfigs[i], arg, width);\r\nreturn -EINVAL;\r\n}\r\nval &= ~(mask << bit);\r\nval |= arg << bit;\r\npmx_writel(pmx, val, bank, reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic void tegra_pinconf_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned offset)\r\n{\r\n}\r\nstatic const char *strip_prefix(const char *s)\r\n{\r\nconst char *comma = strchr(s, ',');\r\nif (!comma)\r\nreturn s;\r\nreturn comma + 1;\r\n}\r\nstatic void tegra_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned group)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct tegra_pingroup *g;\r\nint i, ret;\r\ns8 bank, bit, width;\r\ns16 reg;\r\nu32 val;\r\ng = &pmx->soc->groups[group];\r\nfor (i = 0; i < ARRAY_SIZE(cfg_params); i++) {\r\nret = tegra_pinconf_reg(pmx, g, cfg_params[i].param, false,\r\n&bank, &reg, &bit, &width);\r\nif (ret < 0)\r\ncontinue;\r\nval = pmx_readl(pmx, bank, reg);\r\nval >>= bit;\r\nval &= (1 << width) - 1;\r\nseq_printf(s, "\n\t%s=%u",\r\nstrip_prefix(cfg_params[i].property), val);\r\n}\r\n}\r\nstatic void tegra_pinconf_config_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s,\r\nunsigned long config)\r\n{\r\nenum tegra_pinconf_param param = TEGRA_PINCONF_UNPACK_PARAM(config);\r\nu16 arg = TEGRA_PINCONF_UNPACK_ARG(config);\r\nconst char *pname = "unknown";\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cfg_params); i++) {\r\nif (cfg_params[i].param == param) {\r\npname = cfg_params[i].property;\r\nbreak;\r\n}\r\n}\r\nseq_printf(s, "%s=%d", strip_prefix(pname), arg);\r\n}\r\nstatic bool gpio_node_has_range(void)\r\n{\r\nstruct device_node *np;\r\nbool has_prop = false;\r\nnp = of_find_compatible_node(NULL, NULL, "nvidia,tegra30-gpio");\r\nif (!np)\r\nreturn has_prop;\r\nhas_prop = of_find_property(np, "gpio-ranges", NULL);\r\nof_node_put(np);\r\nreturn has_prop;\r\n}\r\nint tegra_pinctrl_probe(struct platform_device *pdev,\r\nconst struct tegra_pinctrl_soc_data *soc_data)\r\n{\r\nstruct tegra_pmx *pmx;\r\nstruct resource *res;\r\nint i;\r\nconst char **group_pins;\r\nint fn, gn, gfn;\r\npmx = devm_kzalloc(&pdev->dev, sizeof(*pmx), GFP_KERNEL);\r\nif (!pmx) {\r\ndev_err(&pdev->dev, "Can't alloc tegra_pmx\n");\r\nreturn -ENOMEM;\r\n}\r\npmx->dev = &pdev->dev;\r\npmx->soc = soc_data;\r\npmx->group_pins = devm_kzalloc(&pdev->dev,\r\nsoc_data->ngroups * 4 * sizeof(*pmx->group_pins),\r\nGFP_KERNEL);\r\nif (!pmx->group_pins)\r\nreturn -ENOMEM;\r\ngroup_pins = pmx->group_pins;\r\nfor (fn = 0; fn < soc_data->nfunctions; fn++) {\r\nstruct tegra_function *func = &soc_data->functions[fn];\r\nfunc->groups = group_pins;\r\nfor (gn = 0; gn < soc_data->ngroups; gn++) {\r\nconst struct tegra_pingroup *g = &soc_data->groups[gn];\r\nif (g->mux_reg == -1)\r\ncontinue;\r\nfor (gfn = 0; gfn < 4; gfn++)\r\nif (g->funcs[gfn] == fn)\r\nbreak;\r\nif (gfn == 4)\r\ncontinue;\r\nBUG_ON(group_pins - pmx->group_pins >=\r\nsoc_data->ngroups * 4);\r\n*group_pins++ = g->name;\r\nfunc->ngroups++;\r\n}\r\n}\r\ntegra_pinctrl_gpio_range.npins = pmx->soc->ngpios;\r\ntegra_pinctrl_desc.name = dev_name(&pdev->dev);\r\ntegra_pinctrl_desc.pins = pmx->soc->pins;\r\ntegra_pinctrl_desc.npins = pmx->soc->npins;\r\nfor (i = 0; ; i++) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\nif (!res)\r\nbreak;\r\n}\r\npmx->nbanks = i;\r\npmx->regs = devm_kzalloc(&pdev->dev, pmx->nbanks * sizeof(*pmx->regs),\r\nGFP_KERNEL);\r\nif (!pmx->regs) {\r\ndev_err(&pdev->dev, "Can't alloc regs pointer\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < pmx->nbanks; i++) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\npmx->regs[i] = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pmx->regs[i]))\r\nreturn PTR_ERR(pmx->regs[i]);\r\n}\r\npmx->pctl = pinctrl_register(&tegra_pinctrl_desc, &pdev->dev, pmx);\r\nif (IS_ERR(pmx->pctl)) {\r\ndev_err(&pdev->dev, "Couldn't register pinctrl driver\n");\r\nreturn PTR_ERR(pmx->pctl);\r\n}\r\nif (!gpio_node_has_range())\r\npinctrl_add_gpio_range(pmx->pctl, &tegra_pinctrl_gpio_range);\r\nplatform_set_drvdata(pdev, pmx);\r\ndev_dbg(&pdev->dev, "Probed Tegra pinctrl driver\n");\r\nreturn 0;\r\n}\r\nint tegra_pinctrl_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_pmx *pmx = platform_get_drvdata(pdev);\r\npinctrl_unregister(pmx->pctl);\r\nreturn 0;\r\n}
