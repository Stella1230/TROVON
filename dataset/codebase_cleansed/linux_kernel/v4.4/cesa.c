static void mv_cesa_dequeue_req_unlocked(struct mv_cesa_engine *engine)\r\n{\r\nstruct crypto_async_request *req, *backlog;\r\nstruct mv_cesa_ctx *ctx;\r\nspin_lock_bh(&cesa_dev->lock);\r\nbacklog = crypto_get_backlog(&cesa_dev->queue);\r\nreq = crypto_dequeue_request(&cesa_dev->queue);\r\nengine->req = req;\r\nspin_unlock_bh(&cesa_dev->lock);\r\nif (!req)\r\nreturn;\r\nif (backlog)\r\nbacklog->complete(backlog, -EINPROGRESS);\r\nctx = crypto_tfm_ctx(req->tfm);\r\nctx->ops->prepare(req, engine);\r\nctx->ops->step(req);\r\n}\r\nstatic irqreturn_t mv_cesa_int(int irq, void *priv)\r\n{\r\nstruct mv_cesa_engine *engine = priv;\r\nstruct crypto_async_request *req;\r\nstruct mv_cesa_ctx *ctx;\r\nu32 status, mask;\r\nirqreturn_t ret = IRQ_NONE;\r\nwhile (true) {\r\nint res;\r\nmask = mv_cesa_get_int_mask(engine);\r\nstatus = readl(engine->regs + CESA_SA_INT_STATUS);\r\nif (!(status & mask))\r\nbreak;\r\nwritel(~status, engine->regs + CESA_SA_FPGA_INT_STATUS);\r\nwritel(~status, engine->regs + CESA_SA_INT_STATUS);\r\nret = IRQ_HANDLED;\r\nspin_lock_bh(&engine->lock);\r\nreq = engine->req;\r\nspin_unlock_bh(&engine->lock);\r\nif (req) {\r\nctx = crypto_tfm_ctx(req->tfm);\r\nres = ctx->ops->process(req, status & mask);\r\nif (res != -EINPROGRESS) {\r\nspin_lock_bh(&engine->lock);\r\nengine->req = NULL;\r\nmv_cesa_dequeue_req_unlocked(engine);\r\nspin_unlock_bh(&engine->lock);\r\nctx->ops->cleanup(req);\r\nlocal_bh_disable();\r\nreq->complete(req, res);\r\nlocal_bh_enable();\r\n} else {\r\nctx->ops->step(req);\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint mv_cesa_queue_req(struct crypto_async_request *req)\r\n{\r\nint ret;\r\nint i;\r\nspin_lock_bh(&cesa_dev->lock);\r\nret = crypto_enqueue_request(&cesa_dev->queue, req);\r\nspin_unlock_bh(&cesa_dev->lock);\r\nif (ret != -EINPROGRESS)\r\nreturn ret;\r\nfor (i = 0; i < cesa_dev->caps->nengines; i++) {\r\nspin_lock_bh(&cesa_dev->engines[i].lock);\r\nif (!cesa_dev->engines[i].req)\r\nmv_cesa_dequeue_req_unlocked(&cesa_dev->engines[i]);\r\nspin_unlock_bh(&cesa_dev->engines[i].lock);\r\n}\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int mv_cesa_add_algs(struct mv_cesa_dev *cesa)\r\n{\r\nint ret;\r\nint i, j;\r\nfor (i = 0; i < cesa->caps->ncipher_algs; i++) {\r\nret = crypto_register_alg(cesa->caps->cipher_algs[i]);\r\nif (ret)\r\ngoto err_unregister_crypto;\r\n}\r\nfor (i = 0; i < cesa->caps->nahash_algs; i++) {\r\nret = crypto_register_ahash(cesa->caps->ahash_algs[i]);\r\nif (ret)\r\ngoto err_unregister_ahash;\r\n}\r\nreturn 0;\r\nerr_unregister_ahash:\r\nfor (j = 0; j < i; j++)\r\ncrypto_unregister_ahash(cesa->caps->ahash_algs[j]);\r\ni = cesa->caps->ncipher_algs;\r\nerr_unregister_crypto:\r\nfor (j = 0; j < i; j++)\r\ncrypto_unregister_alg(cesa->caps->cipher_algs[j]);\r\nreturn ret;\r\n}\r\nstatic void mv_cesa_remove_algs(struct mv_cesa_dev *cesa)\r\n{\r\nint i;\r\nfor (i = 0; i < cesa->caps->nahash_algs; i++)\r\ncrypto_unregister_ahash(cesa->caps->ahash_algs[i]);\r\nfor (i = 0; i < cesa->caps->ncipher_algs; i++)\r\ncrypto_unregister_alg(cesa->caps->cipher_algs[i]);\r\n}\r\nstatic void\r\nmv_cesa_conf_mbus_windows(struct mv_cesa_engine *engine,\r\nconst struct mbus_dram_target_info *dram)\r\n{\r\nvoid __iomem *iobase = engine->regs;\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nwritel(0, iobase + CESA_TDMA_WINDOW_CTRL(i));\r\nwritel(0, iobase + CESA_TDMA_WINDOW_BASE(i));\r\n}\r\nfor (i = 0; i < dram->num_cs; i++) {\r\nconst struct mbus_dram_window *cs = dram->cs + i;\r\nwritel(((cs->size - 1) & 0xffff0000) |\r\n(cs->mbus_attr << 8) |\r\n(dram->mbus_dram_target_id << 4) | 1,\r\niobase + CESA_TDMA_WINDOW_CTRL(i));\r\nwritel(cs->base, iobase + CESA_TDMA_WINDOW_BASE(i));\r\n}\r\n}\r\nstatic int mv_cesa_dev_dma_init(struct mv_cesa_dev *cesa)\r\n{\r\nstruct device *dev = cesa->dev;\r\nstruct mv_cesa_dev_dma *dma;\r\nif (!cesa->caps->has_tdma)\r\nreturn 0;\r\ndma = devm_kzalloc(dev, sizeof(*dma), GFP_KERNEL);\r\nif (!dma)\r\nreturn -ENOMEM;\r\ndma->tdma_desc_pool = dmam_pool_create("tdma_desc", dev,\r\nsizeof(struct mv_cesa_tdma_desc),\r\n16, 0);\r\nif (!dma->tdma_desc_pool)\r\nreturn -ENOMEM;\r\ndma->op_pool = dmam_pool_create("cesa_op", dev,\r\nsizeof(struct mv_cesa_op_ctx), 16, 0);\r\nif (!dma->op_pool)\r\nreturn -ENOMEM;\r\ndma->cache_pool = dmam_pool_create("cesa_cache", dev,\r\nCESA_MAX_HASH_BLOCK_SIZE, 1, 0);\r\nif (!dma->cache_pool)\r\nreturn -ENOMEM;\r\ndma->padding_pool = dmam_pool_create("cesa_padding", dev, 72, 1, 0);\r\nif (!dma->cache_pool)\r\nreturn -ENOMEM;\r\ncesa->dma = dma;\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_get_sram(struct platform_device *pdev, int idx)\r\n{\r\nstruct mv_cesa_dev *cesa = platform_get_drvdata(pdev);\r\nstruct mv_cesa_engine *engine = &cesa->engines[idx];\r\nconst char *res_name = "sram";\r\nstruct resource *res;\r\nengine->pool = of_gen_pool_get(cesa->dev->of_node,\r\n"marvell,crypto-srams", idx);\r\nif (engine->pool) {\r\nengine->sram = gen_pool_dma_alloc(engine->pool,\r\ncesa->sram_size,\r\n&engine->sram_dma);\r\nif (engine->sram)\r\nreturn 0;\r\nengine->pool = NULL;\r\nreturn -ENOMEM;\r\n}\r\nif (cesa->caps->nengines > 1) {\r\nif (!idx)\r\nres_name = "sram0";\r\nelse\r\nres_name = "sram1";\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\nres_name);\r\nif (!res || resource_size(res) < cesa->sram_size)\r\nreturn -EINVAL;\r\nengine->sram = devm_ioremap_resource(cesa->dev, res);\r\nif (IS_ERR(engine->sram))\r\nreturn PTR_ERR(engine->sram);\r\nengine->sram_dma = phys_to_dma(cesa->dev,\r\n(phys_addr_t)res->start);\r\nreturn 0;\r\n}\r\nstatic void mv_cesa_put_sram(struct platform_device *pdev, int idx)\r\n{\r\nstruct mv_cesa_dev *cesa = platform_get_drvdata(pdev);\r\nstruct mv_cesa_engine *engine = &cesa->engines[idx];\r\nif (!engine->pool)\r\nreturn;\r\ngen_pool_free(engine->pool, (unsigned long)engine->sram,\r\ncesa->sram_size);\r\n}\r\nstatic int mv_cesa_probe(struct platform_device *pdev)\r\n{\r\nconst struct mv_cesa_caps *caps = &orion_caps;\r\nconst struct mbus_dram_target_info *dram;\r\nconst struct of_device_id *match;\r\nstruct device *dev = &pdev->dev;\r\nstruct mv_cesa_dev *cesa;\r\nstruct mv_cesa_engine *engines;\r\nstruct resource *res;\r\nint irq, ret, i;\r\nu32 sram_size;\r\nif (cesa_dev) {\r\ndev_err(&pdev->dev, "Only one CESA device authorized\n");\r\nreturn -EEXIST;\r\n}\r\nif (dev->of_node) {\r\nmatch = of_match_node(mv_cesa_of_match_table, dev->of_node);\r\nif (!match || !match->data)\r\nreturn -ENOTSUPP;\r\ncaps = match->data;\r\n}\r\nif ((caps == &orion_caps || caps == &kirkwood_caps) && !allhwsupport)\r\nreturn -ENOTSUPP;\r\ncesa = devm_kzalloc(dev, sizeof(*cesa), GFP_KERNEL);\r\nif (!cesa)\r\nreturn -ENOMEM;\r\ncesa->caps = caps;\r\ncesa->dev = dev;\r\nsram_size = CESA_SA_DEFAULT_SRAM_SIZE;\r\nof_property_read_u32(cesa->dev->of_node, "marvell,crypto-sram-size",\r\n&sram_size);\r\nif (sram_size < CESA_SA_MIN_SRAM_SIZE)\r\nsram_size = CESA_SA_MIN_SRAM_SIZE;\r\ncesa->sram_size = sram_size;\r\ncesa->engines = devm_kzalloc(dev, caps->nengines * sizeof(*engines),\r\nGFP_KERNEL);\r\nif (!cesa->engines)\r\nreturn -ENOMEM;\r\nspin_lock_init(&cesa->lock);\r\ncrypto_init_queue(&cesa->queue, 50);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "regs");\r\ncesa->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(cesa->regs))\r\nreturn -ENOMEM;\r\nret = mv_cesa_dev_dma_init(cesa);\r\nif (ret)\r\nreturn ret;\r\ndram = mv_mbus_dram_info_nooverlap();\r\nplatform_set_drvdata(pdev, cesa);\r\nfor (i = 0; i < caps->nengines; i++) {\r\nstruct mv_cesa_engine *engine = &cesa->engines[i];\r\nchar res_name[7];\r\nengine->id = i;\r\nspin_lock_init(&engine->lock);\r\nret = mv_cesa_get_sram(pdev, i);\r\nif (ret)\r\ngoto err_cleanup;\r\nirq = platform_get_irq(pdev, i);\r\nif (irq < 0) {\r\nret = irq;\r\ngoto err_cleanup;\r\n}\r\nsnprintf(res_name, sizeof(res_name), "cesa%d", i);\r\nengine->clk = devm_clk_get(dev, res_name);\r\nif (IS_ERR(engine->clk)) {\r\nengine->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(engine->clk))\r\nengine->clk = NULL;\r\n}\r\nsnprintf(res_name, sizeof(res_name), "cesaz%d", i);\r\nengine->zclk = devm_clk_get(dev, res_name);\r\nif (IS_ERR(engine->zclk))\r\nengine->zclk = NULL;\r\nret = clk_prepare_enable(engine->clk);\r\nif (ret)\r\ngoto err_cleanup;\r\nret = clk_prepare_enable(engine->zclk);\r\nif (ret)\r\ngoto err_cleanup;\r\nengine->regs = cesa->regs + CESA_ENGINE_OFF(i);\r\nif (dram && cesa->caps->has_tdma)\r\nmv_cesa_conf_mbus_windows(&cesa->engines[i], dram);\r\nwritel(0, cesa->engines[i].regs + CESA_SA_INT_STATUS);\r\nwritel(CESA_SA_CFG_STOP_DIG_ERR,\r\ncesa->engines[i].regs + CESA_SA_CFG);\r\nwritel(engine->sram_dma & CESA_SA_SRAM_MSK,\r\ncesa->engines[i].regs + CESA_SA_DESC_P0);\r\nret = devm_request_threaded_irq(dev, irq, NULL, mv_cesa_int,\r\nIRQF_ONESHOT,\r\ndev_name(&pdev->dev),\r\n&cesa->engines[i]);\r\nif (ret)\r\ngoto err_cleanup;\r\n}\r\ncesa_dev = cesa;\r\nret = mv_cesa_add_algs(cesa);\r\nif (ret) {\r\ncesa_dev = NULL;\r\ngoto err_cleanup;\r\n}\r\ndev_info(dev, "CESA device successfully registered\n");\r\nreturn 0;\r\nerr_cleanup:\r\nfor (i = 0; i < caps->nengines; i++) {\r\nclk_disable_unprepare(cesa->engines[i].zclk);\r\nclk_disable_unprepare(cesa->engines[i].clk);\r\nmv_cesa_put_sram(pdev, i);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mv_cesa_remove(struct platform_device *pdev)\r\n{\r\nstruct mv_cesa_dev *cesa = platform_get_drvdata(pdev);\r\nint i;\r\nmv_cesa_remove_algs(cesa);\r\nfor (i = 0; i < cesa->caps->nengines; i++) {\r\nclk_disable_unprepare(cesa->engines[i].zclk);\r\nclk_disable_unprepare(cesa->engines[i].clk);\r\nmv_cesa_put_sram(pdev, i);\r\n}\r\nreturn 0;\r\n}
