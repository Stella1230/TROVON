static int pdc_wdt_keepalive(struct watchdog_device *wdt_dev)\r\n{\r\nstruct pdc_wdt_dev *wdt = watchdog_get_drvdata(wdt_dev);\r\nwritel(PDC_WDT_TICKLE1_MAGIC, wdt->base + PDC_WDT_TICKLE1);\r\nwritel(PDC_WDT_TICKLE2_MAGIC, wdt->base + PDC_WDT_TICKLE2);\r\nreturn 0;\r\n}\r\nstatic int pdc_wdt_stop(struct watchdog_device *wdt_dev)\r\n{\r\nunsigned int val;\r\nstruct pdc_wdt_dev *wdt = watchdog_get_drvdata(wdt_dev);\r\nval = readl(wdt->base + PDC_WDT_CONFIG);\r\nval &= ~PDC_WDT_CONFIG_ENABLE;\r\nwritel(val, wdt->base + PDC_WDT_CONFIG);\r\npdc_wdt_keepalive(wdt_dev);\r\nreturn 0;\r\n}\r\nstatic void __pdc_wdt_set_timeout(struct pdc_wdt_dev *wdt)\r\n{\r\nunsigned long clk_rate = clk_get_rate(wdt->wdt_clk);\r\nunsigned int val;\r\nval = readl(wdt->base + PDC_WDT_CONFIG) & ~PDC_WDT_CONFIG_DELAY_MASK;\r\nval |= order_base_2(wdt->wdt_dev.timeout * clk_rate) - 1;\r\nwritel(val, wdt->base + PDC_WDT_CONFIG);\r\n}\r\nstatic int pdc_wdt_set_timeout(struct watchdog_device *wdt_dev,\r\nunsigned int new_timeout)\r\n{\r\nstruct pdc_wdt_dev *wdt = watchdog_get_drvdata(wdt_dev);\r\nwdt->wdt_dev.timeout = new_timeout;\r\n__pdc_wdt_set_timeout(wdt);\r\nreturn 0;\r\n}\r\nstatic int pdc_wdt_start(struct watchdog_device *wdt_dev)\r\n{\r\nunsigned int val;\r\nstruct pdc_wdt_dev *wdt = watchdog_get_drvdata(wdt_dev);\r\n__pdc_wdt_set_timeout(wdt);\r\nval = readl(wdt->base + PDC_WDT_CONFIG);\r\nval |= PDC_WDT_CONFIG_ENABLE;\r\nwritel(val, wdt->base + PDC_WDT_CONFIG);\r\nreturn 0;\r\n}\r\nstatic int pdc_wdt_restart(struct notifier_block *this, unsigned long mode,\r\nvoid *cmd)\r\n{\r\nstruct pdc_wdt_dev *wdt = container_of(this, struct pdc_wdt_dev,\r\nrestart_handler);\r\nwritel(0x1, wdt->base + PDC_WDT_SOFT_RESET);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int pdc_wdt_probe(struct platform_device *pdev)\r\n{\r\nu64 div;\r\nint ret, val;\r\nunsigned long clk_rate;\r\nstruct resource *res;\r\nstruct pdc_wdt_dev *pdc_wdt;\r\npdc_wdt = devm_kzalloc(&pdev->dev, sizeof(*pdc_wdt), GFP_KERNEL);\r\nif (!pdc_wdt)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npdc_wdt->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pdc_wdt->base))\r\nreturn PTR_ERR(pdc_wdt->base);\r\npdc_wdt->sys_clk = devm_clk_get(&pdev->dev, "sys");\r\nif (IS_ERR(pdc_wdt->sys_clk)) {\r\ndev_err(&pdev->dev, "failed to get the sys clock\n");\r\nreturn PTR_ERR(pdc_wdt->sys_clk);\r\n}\r\npdc_wdt->wdt_clk = devm_clk_get(&pdev->dev, "wdt");\r\nif (IS_ERR(pdc_wdt->wdt_clk)) {\r\ndev_err(&pdev->dev, "failed to get the wdt clock\n");\r\nreturn PTR_ERR(pdc_wdt->wdt_clk);\r\n}\r\nret = clk_prepare_enable(pdc_wdt->sys_clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not prepare or enable sys clock\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(pdc_wdt->wdt_clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not prepare or enable wdt clock\n");\r\ngoto disable_sys_clk;\r\n}\r\nclk_rate = clk_get_rate(pdc_wdt->wdt_clk);\r\nif (clk_rate == 0) {\r\ndev_err(&pdev->dev, "failed to get clock rate\n");\r\nret = -EINVAL;\r\ngoto disable_wdt_clk;\r\n}\r\nif (order_base_2(clk_rate) > PDC_WDT_CONFIG_DELAY_MASK + 1) {\r\ndev_err(&pdev->dev, "invalid clock rate\n");\r\nret = -EINVAL;\r\ngoto disable_wdt_clk;\r\n}\r\nif (order_base_2(clk_rate) == 0)\r\npdc_wdt->wdt_dev.min_timeout = PDC_WDT_MIN_TIMEOUT + 1;\r\nelse\r\npdc_wdt->wdt_dev.min_timeout = PDC_WDT_MIN_TIMEOUT;\r\npdc_wdt->wdt_dev.info = &pdc_wdt_info;\r\npdc_wdt->wdt_dev.ops = &pdc_wdt_ops;\r\ndiv = 1ULL << (PDC_WDT_CONFIG_DELAY_MASK + 1);\r\ndo_div(div, clk_rate);\r\npdc_wdt->wdt_dev.max_timeout = div;\r\npdc_wdt->wdt_dev.timeout = PDC_WDT_DEF_TIMEOUT;\r\npdc_wdt->wdt_dev.parent = &pdev->dev;\r\nwatchdog_set_drvdata(&pdc_wdt->wdt_dev, pdc_wdt);\r\nwatchdog_init_timeout(&pdc_wdt->wdt_dev, heartbeat, &pdev->dev);\r\npdc_wdt_stop(&pdc_wdt->wdt_dev);\r\nval = readl(pdc_wdt->base + PDC_WDT_TICKLE1);\r\nval = (val & PDC_WDT_TICKLE_STATUS_MASK) >> PDC_WDT_TICKLE_STATUS_SHIFT;\r\nswitch (val) {\r\ncase PDC_WDT_TICKLE_STATUS_TICKLE:\r\ncase PDC_WDT_TICKLE_STATUS_TIMEOUT:\r\npdc_wdt->wdt_dev.bootstatus |= WDIOF_CARDRESET;\r\ndev_info(&pdev->dev,\r\n"watchdog module last reset due to timeout\n");\r\nbreak;\r\ncase PDC_WDT_TICKLE_STATUS_HRESET:\r\ndev_info(&pdev->dev,\r\n"watchdog module last reset due to hard reset\n");\r\nbreak;\r\ncase PDC_WDT_TICKLE_STATUS_SRESET:\r\ndev_info(&pdev->dev,\r\n"watchdog module last reset due to soft reset\n");\r\nbreak;\r\ncase PDC_WDT_TICKLE_STATUS_USER:\r\ndev_info(&pdev->dev,\r\n"watchdog module last reset due to user reset\n");\r\nbreak;\r\ndefault:\r\ndev_info(&pdev->dev,\r\n"contains an illegal status code (%08x)\n", val);\r\nbreak;\r\n}\r\nwatchdog_set_nowayout(&pdc_wdt->wdt_dev, nowayout);\r\nplatform_set_drvdata(pdev, pdc_wdt);\r\nret = watchdog_register_device(&pdc_wdt->wdt_dev);\r\nif (ret)\r\ngoto disable_wdt_clk;\r\npdc_wdt->restart_handler.notifier_call = pdc_wdt_restart;\r\npdc_wdt->restart_handler.priority = 128;\r\nret = register_restart_handler(&pdc_wdt->restart_handler);\r\nif (ret)\r\ndev_warn(&pdev->dev, "failed to register restart handler: %d\n",\r\nret);\r\nreturn 0;\r\ndisable_wdt_clk:\r\nclk_disable_unprepare(pdc_wdt->wdt_clk);\r\ndisable_sys_clk:\r\nclk_disable_unprepare(pdc_wdt->sys_clk);\r\nreturn ret;\r\n}\r\nstatic void pdc_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nstruct pdc_wdt_dev *pdc_wdt = platform_get_drvdata(pdev);\r\npdc_wdt_stop(&pdc_wdt->wdt_dev);\r\n}\r\nstatic int pdc_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct pdc_wdt_dev *pdc_wdt = platform_get_drvdata(pdev);\r\nunregister_restart_handler(&pdc_wdt->restart_handler);\r\npdc_wdt_stop(&pdc_wdt->wdt_dev);\r\nwatchdog_unregister_device(&pdc_wdt->wdt_dev);\r\nclk_disable_unprepare(pdc_wdt->wdt_clk);\r\nclk_disable_unprepare(pdc_wdt->sys_clk);\r\nreturn 0;\r\n}
