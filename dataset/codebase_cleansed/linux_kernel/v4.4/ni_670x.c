static int ni_670x_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int val = s->readback[chan];\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nval = data[i];\r\nwritel(((chan & 15) << 1) | ((chan & 16) >> 4),\r\ndev->mmio + AO_CHAN_OFFSET);\r\nwritel(val, dev->mmio + AO_VALUE_OFFSET);\r\n}\r\ns->readback[chan] = val;\r\nreturn insn->n;\r\n}\r\nstatic int ni_670x_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data))\r\nwritel(s->state, dev->mmio + DIO_PORT0_DATA_OFFSET);\r\ndata[1] = readl(dev->mmio + DIO_PORT0_DATA_OFFSET);\r\nreturn insn->n;\r\n}\r\nstatic int ni_670x_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint ret;\r\nret = comedi_dio_insn_config(dev, s, insn, data, 0);\r\nif (ret)\r\nreturn ret;\r\nwritel(s->io_bits, dev->mmio + DIO_PORT0_DIR_OFFSET);\r\nreturn insn->n;\r\n}\r\nstatic int ni_670x_mite_init(struct pci_dev *pcidev)\r\n{\r\nvoid __iomem *mite_base;\r\nu32 main_phys_addr;\r\nmite_base = pci_ioremap_bar(pcidev, 0);\r\nif (!mite_base)\r\nreturn -ENOMEM;\r\nmain_phys_addr = pci_resource_start(pcidev, 1);\r\nwritel(main_phys_addr | WENAB, mite_base + MITE_IODWBSR);\r\niounmap(mite_base);\r\nreturn 0;\r\n}\r\nstatic int ni_670x_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nconst struct ni_670x_board *board = NULL;\r\nstruct ni_670x_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nint i;\r\nif (context < ARRAY_SIZE(ni_670x_boards))\r\nboard = &ni_670x_boards[context];\r\nif (!board)\r\nreturn -ENODEV;\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = ni_670x_mite_init(pcidev);\r\nif (ret)\r\nreturn ret;\r\ndev->mmio = pci_ioremap_bar(pcidev, 1);\r\nif (!dev->mmio)\r\nreturn -ENOMEM;\r\nret = comedi_alloc_subdevices(dev, 2);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = board->ao_chans;\r\ns->maxdata = 0xffff;\r\nif (s->n_chan == 32) {\r\nconst struct comedi_lrange **range_table_list;\r\nrange_table_list = kmalloc(sizeof(struct comedi_lrange *) * 32,\r\nGFP_KERNEL);\r\nif (!range_table_list)\r\nreturn -ENOMEM;\r\ns->range_table_list = range_table_list;\r\nfor (i = 0; i < 16; i++) {\r\nrange_table_list[i] = &range_bipolar10;\r\nrange_table_list[16 + i] = &range_0_20mA;\r\n}\r\n} else {\r\ns->range_table = &range_bipolar10;\r\n}\r\ns->insn_write = ni_670x_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = ni_670x_dio_insn_bits;\r\ns->insn_config = ni_670x_dio_insn_config;\r\nwritel(0x10, dev->mmio + MISC_CONTROL_OFFSET);\r\nwritel(0x00, dev->mmio + AO_CONTROL_OFFSET);\r\nreturn 0;\r\n}\r\nstatic void ni_670x_detach(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s;\r\ncomedi_pci_detach(dev);\r\nif (dev->n_subdevices) {\r\ns = &dev->subdevices[0];\r\nif (s)\r\nkfree(s->range_table_list);\r\n}\r\n}\r\nstatic int ni_670x_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &ni_670x_driver, id->driver_data);\r\n}
