static void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\r\n{\r\ndprintk("NFS: %s prematurely hit the end of our receive buffer. "\r\n"Remaining buffer length is %tu words.\n",\r\nfunc, xdr->end - xdr->p);\r\n}\r\nstatic __be32 *xdr_encode_empty_array(__be32 *p)\r\n{\r\n*p++ = xdr_zero;\r\nreturn p;\r\n}\r\nstatic void encode_nfs_cb_opnum4(struct xdr_stream *xdr, enum nfs_cb_opnum4 op)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, 4);\r\n*p = cpu_to_be32(op);\r\n}\r\nstatic void encode_nfs_fh4(struct xdr_stream *xdr, const struct knfsd_fh *fh)\r\n{\r\nu32 length = fh->fh_size;\r\n__be32 *p;\r\nBUG_ON(length > NFS4_FHSIZE);\r\np = xdr_reserve_space(xdr, 4 + length);\r\nxdr_encode_opaque(p, &fh->fh_base, length);\r\n}\r\nstatic void encode_stateid4(struct xdr_stream *xdr, const stateid_t *sid)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, NFS4_STATEID_SIZE);\r\n*p++ = cpu_to_be32(sid->si_generation);\r\nxdr_encode_opaque_fixed(p, &sid->si_opaque, NFS4_STATEID_OTHER_SIZE);\r\n}\r\nstatic void encode_sessionid4(struct xdr_stream *xdr,\r\nconst struct nfsd4_session *session)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN);\r\nxdr_encode_opaque_fixed(p, session->se_sessionid.data,\r\nNFS4_MAX_SESSIONID_LEN);\r\n}\r\nstatic int nfs_cb_stat_to_errno(int status)\r\n{\r\nint i;\r\nfor (i = 0; nfs_cb_errtbl[i].stat != -1; i++) {\r\nif (nfs_cb_errtbl[i].stat == status)\r\nreturn nfs_cb_errtbl[i].errno;\r\n}\r\ndprintk("NFSD: Unrecognized NFS CB status value: %u\n", status);\r\nreturn -status;\r\n}\r\nstatic int decode_cb_op_status(struct xdr_stream *xdr, enum nfs_opnum4 expected,\r\nint *status)\r\n{\r\n__be32 *p;\r\nu32 op;\r\np = xdr_inline_decode(xdr, 4 + 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nop = be32_to_cpup(p++);\r\nif (unlikely(op != expected))\r\ngoto out_unexpected;\r\n*status = nfs_cb_stat_to_errno(be32_to_cpup(p));\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\nout_unexpected:\r\ndprintk("NFSD: Callback server returned operation %d but "\r\n"we issued a request for %d\n", op, expected);\r\nreturn -EIO;\r\n}\r\nstatic void encode_cb_compound4args(struct xdr_stream *xdr,\r\nstruct nfs4_cb_compound_hdr *hdr)\r\n{\r\n__be32 * p;\r\np = xdr_reserve_space(xdr, 4 + 4 + 4 + 4);\r\np = xdr_encode_empty_array(p);\r\n*p++ = cpu_to_be32(hdr->minorversion);\r\n*p++ = cpu_to_be32(hdr->ident);\r\nhdr->nops_p = p;\r\n*p = cpu_to_be32(hdr->nops);\r\n}\r\nstatic void encode_cb_nops(struct nfs4_cb_compound_hdr *hdr)\r\n{\r\nBUG_ON(hdr->nops > NFS4_MAX_BACK_CHANNEL_OPS);\r\n*hdr->nops_p = cpu_to_be32(hdr->nops);\r\n}\r\nstatic int decode_cb_compound4res(struct xdr_stream *xdr,\r\nstruct nfs4_cb_compound_hdr *hdr)\r\n{\r\nu32 length;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4 + 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nhdr->status = be32_to_cpup(p++);\r\nlength = be32_to_cpup(p++);\r\np = xdr_inline_decode(xdr, length + 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nhdr->nops = be32_to_cpup(p);\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic void encode_cb_recall4args(struct xdr_stream *xdr,\r\nconst struct nfs4_delegation *dp,\r\nstruct nfs4_cb_compound_hdr *hdr)\r\n{\r\n__be32 *p;\r\nencode_nfs_cb_opnum4(xdr, OP_CB_RECALL);\r\nencode_stateid4(xdr, &dp->dl_stid.sc_stateid);\r\np = xdr_reserve_space(xdr, 4);\r\n*p++ = xdr_zero;\r\nencode_nfs_fh4(xdr, &dp->dl_stid.sc_file->fi_fhandle);\r\nhdr->nops++;\r\n}\r\nstatic void encode_cb_sequence4args(struct xdr_stream *xdr,\r\nconst struct nfsd4_callback *cb,\r\nstruct nfs4_cb_compound_hdr *hdr)\r\n{\r\nstruct nfsd4_session *session = cb->cb_clp->cl_cb_session;\r\n__be32 *p;\r\nif (hdr->minorversion == 0)\r\nreturn;\r\nencode_nfs_cb_opnum4(xdr, OP_CB_SEQUENCE);\r\nencode_sessionid4(xdr, session);\r\np = xdr_reserve_space(xdr, 4 + 4 + 4 + 4 + 4);\r\n*p++ = cpu_to_be32(session->se_cb_seq_nr);\r\n*p++ = xdr_zero;\r\n*p++ = xdr_zero;\r\n*p++ = xdr_zero;\r\nxdr_encode_empty_array(p);\r\nhdr->nops++;\r\n}\r\nstatic int decode_cb_sequence4resok(struct xdr_stream *xdr,\r\nstruct nfsd4_callback *cb)\r\n{\r\nstruct nfsd4_session *session = cb->cb_clp->cl_cb_session;\r\nstruct nfs4_sessionid id;\r\nint status;\r\n__be32 *p;\r\nu32 dummy;\r\nstatus = -ESERVERFAULT;\r\np = xdr_inline_decode(xdr, NFS4_MAX_SESSIONID_LEN + 4 + 4 + 4 + 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nmemcpy(id.data, p, NFS4_MAX_SESSIONID_LEN);\r\nif (memcmp(id.data, session->se_sessionid.data,\r\nNFS4_MAX_SESSIONID_LEN) != 0) {\r\ndprintk("NFS: %s Invalid session id\n", __func__);\r\ngoto out;\r\n}\r\np += XDR_QUADLEN(NFS4_MAX_SESSIONID_LEN);\r\ndummy = be32_to_cpup(p++);\r\nif (dummy != session->se_cb_seq_nr) {\r\ndprintk("NFS: %s Invalid sequence number\n", __func__);\r\ngoto out;\r\n}\r\ndummy = be32_to_cpup(p++);\r\nif (dummy != 0) {\r\ndprintk("NFS: %s Invalid slotid\n", __func__);\r\ngoto out;\r\n}\r\nstatus = 0;\r\nout:\r\ncb->cb_seq_status = status;\r\nreturn status;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nstatus = -EIO;\r\ngoto out;\r\n}\r\nstatic int decode_cb_sequence4res(struct xdr_stream *xdr,\r\nstruct nfsd4_callback *cb)\r\n{\r\nint status;\r\nif (cb->cb_minorversion == 0)\r\nreturn 0;\r\nstatus = decode_cb_op_status(xdr, OP_CB_SEQUENCE, &cb->cb_seq_status);\r\nif (unlikely(status || cb->cb_seq_status))\r\nreturn status;\r\nreturn decode_cb_sequence4resok(xdr, cb);\r\n}\r\nstatic void nfs4_xdr_enc_cb_null(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nvoid *__unused)\r\n{\r\nxdr_reserve_space(xdr, 0);\r\n}\r\nstatic void nfs4_xdr_enc_cb_recall(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nconst struct nfsd4_callback *cb)\r\n{\r\nconst struct nfs4_delegation *dp = cb_to_delegation(cb);\r\nstruct nfs4_cb_compound_hdr hdr = {\r\n.ident = cb->cb_clp->cl_cb_ident,\r\n.minorversion = cb->cb_minorversion,\r\n};\r\nencode_cb_compound4args(xdr, &hdr);\r\nencode_cb_sequence4args(xdr, cb, &hdr);\r\nencode_cb_recall4args(xdr, dp, &hdr);\r\nencode_cb_nops(&hdr);\r\n}\r\nstatic int nfs4_xdr_dec_cb_null(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nvoid *__unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic int nfs4_xdr_dec_cb_recall(struct rpc_rqst *rqstp,\r\nstruct xdr_stream *xdr,\r\nstruct nfsd4_callback *cb)\r\n{\r\nstruct nfs4_cb_compound_hdr hdr;\r\nint status;\r\nstatus = decode_cb_compound4res(xdr, &hdr);\r\nif (unlikely(status))\r\nreturn status;\r\nif (cb != NULL) {\r\nstatus = decode_cb_sequence4res(xdr, cb);\r\nif (unlikely(status || cb->cb_seq_status))\r\nreturn status;\r\n}\r\nreturn decode_cb_op_status(xdr, OP_CB_RECALL, &cb->cb_status);\r\n}\r\nstatic void encode_cb_layout4args(struct xdr_stream *xdr,\r\nconst struct nfs4_layout_stateid *ls,\r\nstruct nfs4_cb_compound_hdr *hdr)\r\n{\r\n__be32 *p;\r\nBUG_ON(hdr->minorversion == 0);\r\np = xdr_reserve_space(xdr, 5 * 4);\r\n*p++ = cpu_to_be32(OP_CB_LAYOUTRECALL);\r\n*p++ = cpu_to_be32(ls->ls_layout_type);\r\n*p++ = cpu_to_be32(IOMODE_ANY);\r\n*p++ = cpu_to_be32(1);\r\n*p = cpu_to_be32(RETURN_FILE);\r\nencode_nfs_fh4(xdr, &ls->ls_stid.sc_file->fi_fhandle);\r\np = xdr_reserve_space(xdr, 2 * 8);\r\np = xdr_encode_hyper(p, 0);\r\nxdr_encode_hyper(p, NFS4_MAX_UINT64);\r\nencode_stateid4(xdr, &ls->ls_recall_sid);\r\nhdr->nops++;\r\n}\r\nstatic void nfs4_xdr_enc_cb_layout(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfsd4_callback *cb)\r\n{\r\nconst struct nfs4_layout_stateid *ls =\r\ncontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\r\nstruct nfs4_cb_compound_hdr hdr = {\r\n.ident = 0,\r\n.minorversion = cb->cb_minorversion,\r\n};\r\nencode_cb_compound4args(xdr, &hdr);\r\nencode_cb_sequence4args(xdr, cb, &hdr);\r\nencode_cb_layout4args(xdr, ls, &hdr);\r\nencode_cb_nops(&hdr);\r\n}\r\nstatic int nfs4_xdr_dec_cb_layout(struct rpc_rqst *rqstp,\r\nstruct xdr_stream *xdr,\r\nstruct nfsd4_callback *cb)\r\n{\r\nstruct nfs4_cb_compound_hdr hdr;\r\nint status;\r\nstatus = decode_cb_compound4res(xdr, &hdr);\r\nif (unlikely(status))\r\nreturn status;\r\nif (cb) {\r\nstatus = decode_cb_sequence4res(xdr, cb);\r\nif (unlikely(status || cb->cb_seq_status))\r\nreturn status;\r\n}\r\nreturn decode_cb_op_status(xdr, OP_CB_LAYOUTRECALL, &cb->cb_status);\r\n}\r\nstatic int max_cb_time(struct net *net)\r\n{\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nreturn max(nn->nfsd4_lease/10, (time_t)1) * HZ;\r\n}\r\nint set_callback_cred(void)\r\n{\r\nif (callback_cred)\r\nreturn 0;\r\ncallback_cred = rpc_lookup_machine_cred("nfs");\r\nif (!callback_cred)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic struct rpc_cred *get_backchannel_cred(struct nfs4_client *clp, struct rpc_clnt *client, struct nfsd4_session *ses)\r\n{\r\nif (clp->cl_minorversion == 0) {\r\nreturn get_rpccred(callback_cred);\r\n} else {\r\nstruct rpc_auth *auth = client->cl_auth;\r\nstruct auth_cred acred = {};\r\nacred.uid = ses->se_cb_sec.uid;\r\nacred.gid = ses->se_cb_sec.gid;\r\nreturn auth->au_ops->lookup_cred(client->cl_auth, &acred, 0);\r\n}\r\n}\r\nstatic struct rpc_clnt *create_backchannel_client(struct rpc_create_args *args)\r\n{\r\nstruct rpc_xprt *xprt;\r\nif (args->protocol != XPRT_TRANSPORT_BC_TCP)\r\nreturn rpc_create(args);\r\nxprt = args->bc_xprt->xpt_bc_xprt;\r\nif (xprt) {\r\nxprt_get(xprt);\r\nreturn rpc_create_xprt(args, xprt);\r\n}\r\nreturn rpc_create(args);\r\n}\r\nstatic int setup_callback_client(struct nfs4_client *clp, struct nfs4_cb_conn *conn, struct nfsd4_session *ses)\r\n{\r\nint maxtime = max_cb_time(clp->net);\r\nstruct rpc_timeout timeparms = {\r\n.to_initval = maxtime,\r\n.to_retries = 0,\r\n.to_maxval = maxtime,\r\n};\r\nstruct rpc_create_args args = {\r\n.net = clp->net,\r\n.address = (struct sockaddr *) &conn->cb_addr,\r\n.addrsize = conn->cb_addrlen,\r\n.saddress = (struct sockaddr *) &conn->cb_saddr,\r\n.timeout = &timeparms,\r\n.program = &cb_program,\r\n.version = 0,\r\n.flags = (RPC_CLNT_CREATE_NOPING | RPC_CLNT_CREATE_QUIET),\r\n};\r\nstruct rpc_clnt *client;\r\nstruct rpc_cred *cred;\r\nif (clp->cl_minorversion == 0) {\r\nif (!clp->cl_cred.cr_principal &&\r\n(clp->cl_cred.cr_flavor >= RPC_AUTH_GSS_KRB5))\r\nreturn -EINVAL;\r\nargs.client_name = clp->cl_cred.cr_principal;\r\nargs.prognumber = conn->cb_prog;\r\nargs.protocol = XPRT_TRANSPORT_TCP;\r\nargs.authflavor = clp->cl_cred.cr_flavor;\r\nclp->cl_cb_ident = conn->cb_ident;\r\n} else {\r\nif (!conn->cb_xprt)\r\nreturn -EINVAL;\r\nclp->cl_cb_conn.cb_xprt = conn->cb_xprt;\r\nclp->cl_cb_session = ses;\r\nargs.bc_xprt = conn->cb_xprt;\r\nargs.prognumber = clp->cl_cb_session->se_cb_prog;\r\nargs.protocol = conn->cb_xprt->xpt_class->xcl_ident |\r\nXPRT_TRANSPORT_BC;\r\nargs.authflavor = ses->se_cb_sec.flavor;\r\n}\r\nclient = create_backchannel_client(&args);\r\nif (IS_ERR(client)) {\r\ndprintk("NFSD: couldn't create callback client: %ld\n",\r\nPTR_ERR(client));\r\nreturn PTR_ERR(client);\r\n}\r\ncred = get_backchannel_cred(clp, client, ses);\r\nif (IS_ERR(cred)) {\r\nrpc_shutdown_client(client);\r\nreturn PTR_ERR(cred);\r\n}\r\nclp->cl_cb_client = client;\r\nclp->cl_cb_cred = cred;\r\nreturn 0;\r\n}\r\nstatic void warn_no_callback_path(struct nfs4_client *clp, int reason)\r\n{\r\ndprintk("NFSD: warning: no callback path to client %.*s: error %d\n",\r\n(int)clp->cl_name.len, clp->cl_name.data, reason);\r\n}\r\nstatic void nfsd4_mark_cb_down(struct nfs4_client *clp, int reason)\r\n{\r\nclp->cl_cb_state = NFSD4_CB_DOWN;\r\nwarn_no_callback_path(clp, reason);\r\n}\r\nstatic void nfsd4_mark_cb_fault(struct nfs4_client *clp, int reason)\r\n{\r\nclp->cl_cb_state = NFSD4_CB_FAULT;\r\nwarn_no_callback_path(clp, reason);\r\n}\r\nstatic void nfsd4_cb_probe_done(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfs4_client *clp = container_of(calldata, struct nfs4_client, cl_cb_null);\r\nif (task->tk_status)\r\nnfsd4_mark_cb_down(clp, task->tk_status);\r\nelse\r\nclp->cl_cb_state = NFSD4_CB_UP;\r\n}\r\nvoid nfsd4_probe_callback(struct nfs4_client *clp)\r\n{\r\nclp->cl_cb_state = NFSD4_CB_UNKNOWN;\r\nset_bit(NFSD4_CLIENT_CB_UPDATE, &clp->cl_flags);\r\nnfsd4_run_cb(&clp->cl_cb_null);\r\n}\r\nvoid nfsd4_probe_callback_sync(struct nfs4_client *clp)\r\n{\r\nnfsd4_probe_callback(clp);\r\nflush_workqueue(callback_wq);\r\n}\r\nvoid nfsd4_change_callback(struct nfs4_client *clp, struct nfs4_cb_conn *conn)\r\n{\r\nclp->cl_cb_state = NFSD4_CB_UNKNOWN;\r\nspin_lock(&clp->cl_lock);\r\nmemcpy(&clp->cl_cb_conn, conn, sizeof(struct nfs4_cb_conn));\r\nspin_unlock(&clp->cl_lock);\r\n}\r\nstatic bool nfsd41_cb_get_slot(struct nfs4_client *clp, struct rpc_task *task)\r\n{\r\nif (test_and_set_bit(0, &clp->cl_cb_slot_busy) != 0) {\r\nrpc_sleep_on(&clp->cl_cb_waitq, task, NULL);\r\nif (test_and_set_bit(0, &clp->cl_cb_slot_busy) != 0) {\r\ndprintk("%s slot is busy\n", __func__);\r\nreturn false;\r\n}\r\nrpc_wake_up_queued_task(&clp->cl_cb_waitq, task);\r\n}\r\nreturn true;\r\n}\r\nstatic void nfsd4_cb_prepare(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfsd4_callback *cb = calldata;\r\nstruct nfs4_client *clp = cb->cb_clp;\r\nu32 minorversion = clp->cl_minorversion;\r\ncb->cb_minorversion = minorversion;\r\ncb->cb_seq_status = 1;\r\ncb->cb_status = 0;\r\nif (minorversion) {\r\nif (!nfsd41_cb_get_slot(clp, task))\r\nreturn;\r\n}\r\nrpc_call_start(task);\r\n}\r\nstatic bool nfsd4_cb_sequence_done(struct rpc_task *task, struct nfsd4_callback *cb)\r\n{\r\nstruct nfs4_client *clp = cb->cb_clp;\r\nstruct nfsd4_session *session = clp->cl_cb_session;\r\nbool ret = true;\r\nif (!clp->cl_minorversion) {\r\nif (task->tk_flags & RPC_TASK_KILLED)\r\ngoto need_restart;\r\nreturn true;\r\n}\r\nswitch (cb->cb_seq_status) {\r\ncase 0:\r\n++session->se_cb_seq_nr;\r\nbreak;\r\ncase -ESERVERFAULT:\r\n++session->se_cb_seq_nr;\r\ncase 1:\r\ncase -NFS4ERR_BADSESSION:\r\nnfsd4_mark_cb_fault(cb->cb_clp, cb->cb_seq_status);\r\nret = false;\r\nbreak;\r\ncase -NFS4ERR_DELAY:\r\nif (!rpc_restart_call(task))\r\ngoto out;\r\nrpc_delay(task, 2 * HZ);\r\nreturn false;\r\ncase -NFS4ERR_BADSLOT:\r\ngoto retry_nowait;\r\ncase -NFS4ERR_SEQ_MISORDERED:\r\nif (session->se_cb_seq_nr != 1) {\r\nsession->se_cb_seq_nr = 1;\r\ngoto retry_nowait;\r\n}\r\nbreak;\r\ndefault:\r\ndprintk("%s: unprocessed error %d\n", __func__,\r\ncb->cb_seq_status);\r\n}\r\nclear_bit(0, &clp->cl_cb_slot_busy);\r\nrpc_wake_up_next(&clp->cl_cb_waitq);\r\ndprintk("%s: freed slot, new seqid=%d\n", __func__,\r\nclp->cl_cb_session->se_cb_seq_nr);\r\nif (task->tk_flags & RPC_TASK_KILLED)\r\ngoto need_restart;\r\nout:\r\nreturn ret;\r\nretry_nowait:\r\nif (rpc_restart_call_prepare(task))\r\nret = false;\r\ngoto out;\r\nneed_restart:\r\ntask->tk_status = 0;\r\ncb->cb_need_restart = true;\r\nreturn false;\r\n}\r\nstatic void nfsd4_cb_done(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfsd4_callback *cb = calldata;\r\nstruct nfs4_client *clp = cb->cb_clp;\r\ndprintk("%s: minorversion=%d\n", __func__,\r\nclp->cl_minorversion);\r\nif (!nfsd4_cb_sequence_done(task, cb))\r\nreturn;\r\nif (cb->cb_status) {\r\nWARN_ON_ONCE(task->tk_status);\r\ntask->tk_status = cb->cb_status;\r\n}\r\nswitch (cb->cb_ops->done(cb, task)) {\r\ncase 0:\r\ntask->tk_status = 0;\r\nrpc_restart_call_prepare(task);\r\nreturn;\r\ncase 1:\r\nbreak;\r\ncase -1:\r\nnfsd4_mark_cb_down(clp, task->tk_status);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void nfsd4_cb_release(void *calldata)\r\n{\r\nstruct nfsd4_callback *cb = calldata;\r\nif (cb->cb_need_restart)\r\nnfsd4_run_cb(cb);\r\nelse\r\ncb->cb_ops->release(cb);\r\n}\r\nint nfsd4_create_callback_queue(void)\r\n{\r\ncallback_wq = create_singlethread_workqueue("nfsd4_callbacks");\r\nif (!callback_wq)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid nfsd4_destroy_callback_queue(void)\r\n{\r\ndestroy_workqueue(callback_wq);\r\n}\r\nvoid nfsd4_shutdown_callback(struct nfs4_client *clp)\r\n{\r\nset_bit(NFSD4_CLIENT_CB_KILL, &clp->cl_flags);\r\nnfsd4_run_cb(&clp->cl_cb_null);\r\nflush_workqueue(callback_wq);\r\n}\r\nstatic struct nfsd4_conn * __nfsd4_find_backchannel(struct nfs4_client *clp)\r\n{\r\nstruct nfsd4_session *s;\r\nstruct nfsd4_conn *c;\r\nlist_for_each_entry(s, &clp->cl_sessions, se_perclnt) {\r\nlist_for_each_entry(c, &s->se_conns, cn_persession) {\r\nif (c->cn_flags & NFS4_CDFC4_BACK)\r\nreturn c;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void nfsd4_process_cb_update(struct nfsd4_callback *cb)\r\n{\r\nstruct nfs4_cb_conn conn;\r\nstruct nfs4_client *clp = cb->cb_clp;\r\nstruct nfsd4_session *ses = NULL;\r\nstruct nfsd4_conn *c;\r\nint err;\r\nif (clp->cl_cb_client) {\r\nrpc_shutdown_client(clp->cl_cb_client);\r\nclp->cl_cb_client = NULL;\r\nput_rpccred(clp->cl_cb_cred);\r\nclp->cl_cb_cred = NULL;\r\n}\r\nif (clp->cl_cb_conn.cb_xprt) {\r\nsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\r\nclp->cl_cb_conn.cb_xprt = NULL;\r\n}\r\nif (test_bit(NFSD4_CLIENT_CB_KILL, &clp->cl_flags))\r\nreturn;\r\nspin_lock(&clp->cl_lock);\r\nBUG_ON(!(clp->cl_flags & NFSD4_CLIENT_CB_FLAG_MASK));\r\nclear_bit(NFSD4_CLIENT_CB_UPDATE, &clp->cl_flags);\r\nmemcpy(&conn, &cb->cb_clp->cl_cb_conn, sizeof(struct nfs4_cb_conn));\r\nc = __nfsd4_find_backchannel(clp);\r\nif (c) {\r\nsvc_xprt_get(c->cn_xprt);\r\nconn.cb_xprt = c->cn_xprt;\r\nses = c->cn_session;\r\n}\r\nspin_unlock(&clp->cl_lock);\r\nerr = setup_callback_client(clp, &conn, ses);\r\nif (err) {\r\nnfsd4_mark_cb_down(clp, err);\r\nreturn;\r\n}\r\n}\r\nstatic void\r\nnfsd4_run_cb_work(struct work_struct *work)\r\n{\r\nstruct nfsd4_callback *cb =\r\ncontainer_of(work, struct nfsd4_callback, cb_work);\r\nstruct nfs4_client *clp = cb->cb_clp;\r\nstruct rpc_clnt *clnt;\r\nif (cb->cb_need_restart) {\r\ncb->cb_need_restart = false;\r\n} else {\r\nif (cb->cb_ops && cb->cb_ops->prepare)\r\ncb->cb_ops->prepare(cb);\r\n}\r\nif (clp->cl_flags & NFSD4_CLIENT_CB_FLAG_MASK)\r\nnfsd4_process_cb_update(cb);\r\nclnt = clp->cl_cb_client;\r\nif (!clnt) {\r\nif (cb->cb_ops && cb->cb_ops->release)\r\ncb->cb_ops->release(cb);\r\nreturn;\r\n}\r\nif (!cb->cb_ops && clp->cl_minorversion) {\r\nclp->cl_cb_state = NFSD4_CB_UP;\r\nreturn;\r\n}\r\ncb->cb_msg.rpc_cred = clp->cl_cb_cred;\r\nrpc_call_async(clnt, &cb->cb_msg, RPC_TASK_SOFT | RPC_TASK_SOFTCONN,\r\ncb->cb_ops ? &nfsd4_cb_ops : &nfsd4_cb_probe_ops, cb);\r\n}\r\nvoid nfsd4_init_cb(struct nfsd4_callback *cb, struct nfs4_client *clp,\r\nstruct nfsd4_callback_ops *ops, enum nfsd4_cb_op op)\r\n{\r\ncb->cb_clp = clp;\r\ncb->cb_msg.rpc_proc = &nfs4_cb_procedures[op];\r\ncb->cb_msg.rpc_argp = cb;\r\ncb->cb_msg.rpc_resp = cb;\r\ncb->cb_ops = ops;\r\nINIT_WORK(&cb->cb_work, nfsd4_run_cb_work);\r\ncb->cb_seq_status = 1;\r\ncb->cb_status = 0;\r\ncb->cb_need_restart = false;\r\n}\r\nvoid nfsd4_run_cb(struct nfsd4_callback *cb)\r\n{\r\nqueue_work(callback_wq, &cb->cb_work);\r\n}
