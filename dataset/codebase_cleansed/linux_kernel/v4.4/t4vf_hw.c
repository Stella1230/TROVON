int t4vf_wait_dev_ready(struct adapter *adapter)\r\n{\r\nconst u32 whoami = T4VF_PL_BASE_ADDR + PL_VF_WHOAMI;\r\nconst u32 notready1 = 0xffffffff;\r\nconst u32 notready2 = 0xeeeeeeee;\r\nu32 val;\r\nval = t4_read_reg(adapter, whoami);\r\nif (val != notready1 && val != notready2)\r\nreturn 0;\r\nmsleep(500);\r\nval = t4_read_reg(adapter, whoami);\r\nif (val != notready1 && val != notready2)\r\nreturn 0;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic void get_mbox_rpl(struct adapter *adapter, __be64 *rpl, int size,\r\nu32 mbox_data)\r\n{\r\nfor ( ; size; size -= 8, mbox_data += 8)\r\n*rpl++ = cpu_to_be64(t4_read_reg64(adapter, mbox_data));\r\n}\r\nstatic void dump_mbox(struct adapter *adapter, const char *tag, u32 mbox_data)\r\n{\r\ndev_err(adapter->pdev_dev,\r\n"mbox %s: %llx %llx %llx %llx %llx %llx %llx %llx\n", tag,\r\n(unsigned long long)t4_read_reg64(adapter, mbox_data + 0),\r\n(unsigned long long)t4_read_reg64(adapter, mbox_data + 8),\r\n(unsigned long long)t4_read_reg64(adapter, mbox_data + 16),\r\n(unsigned long long)t4_read_reg64(adapter, mbox_data + 24),\r\n(unsigned long long)t4_read_reg64(adapter, mbox_data + 32),\r\n(unsigned long long)t4_read_reg64(adapter, mbox_data + 40),\r\n(unsigned long long)t4_read_reg64(adapter, mbox_data + 48),\r\n(unsigned long long)t4_read_reg64(adapter, mbox_data + 56));\r\n}\r\nint t4vf_wr_mbox_core(struct adapter *adapter, const void *cmd, int size,\r\nvoid *rpl, bool sleep_ok)\r\n{\r\nstatic const int delay[] = {\r\n1, 1, 3, 5, 10, 10, 20, 50, 100\r\n};\r\nu32 v;\r\nint i, ms, delay_idx;\r\nconst __be64 *p;\r\nu32 mbox_data = T4VF_MBDATA_BASE_ADDR;\r\nu32 mbox_ctl = T4VF_CIM_BASE_ADDR + CIM_VF_EXT_MAILBOX_CTRL;\r\nif ((size % 16) != 0 ||\r\nsize > NUM_CIM_VF_MAILBOX_DATA_INSTANCES * 4)\r\nreturn -EINVAL;\r\nv = MBOWNER_G(t4_read_reg(adapter, mbox_ctl));\r\nfor (i = 0; v == MBOX_OWNER_NONE && i < 3; i++)\r\nv = MBOWNER_G(t4_read_reg(adapter, mbox_ctl));\r\nif (v != MBOX_OWNER_DRV)\r\nreturn v == MBOX_OWNER_FW ? -EBUSY : -ETIMEDOUT;\r\nfor (i = 0, p = cmd; i < size; i += 8)\r\nt4_write_reg64(adapter, mbox_data + i, be64_to_cpu(*p++));\r\nt4_read_reg(adapter, mbox_data);\r\nt4_write_reg(adapter, mbox_ctl,\r\nMBMSGVALID_F | MBOWNER_V(MBOX_OWNER_FW));\r\nt4_read_reg(adapter, mbox_ctl);\r\ndelay_idx = 0;\r\nms = delay[0];\r\nfor (i = 0; i < FW_CMD_MAX_TIMEOUT; i += ms) {\r\nif (sleep_ok) {\r\nms = delay[delay_idx];\r\nif (delay_idx < ARRAY_SIZE(delay) - 1)\r\ndelay_idx++;\r\nmsleep(ms);\r\n} else\r\nmdelay(ms);\r\nv = t4_read_reg(adapter, mbox_ctl);\r\nif (MBOWNER_G(v) == MBOX_OWNER_DRV) {\r\nif ((v & MBMSGVALID_F) == 0) {\r\nt4_write_reg(adapter, mbox_ctl,\r\nMBOWNER_V(MBOX_OWNER_NONE));\r\ncontinue;\r\n}\r\nv = t4_read_reg(adapter, mbox_data);\r\nif (FW_CMD_RETVAL_G(v))\r\ndump_mbox(adapter, "FW Error", mbox_data);\r\nif (rpl) {\r\nWARN_ON((be32_to_cpu(*(const __be32 *)cmd)\r\n& FW_CMD_REQUEST_F) == 0);\r\nget_mbox_rpl(adapter, rpl, size, mbox_data);\r\nWARN_ON((be32_to_cpu(*(__be32 *)rpl)\r\n& FW_CMD_REQUEST_F) != 0);\r\n}\r\nt4_write_reg(adapter, mbox_ctl,\r\nMBOWNER_V(MBOX_OWNER_NONE));\r\nreturn -FW_CMD_RETVAL_G(v);\r\n}\r\n}\r\ndump_mbox(adapter, "FW Timeout", mbox_data);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int hash_mac_addr(const u8 *addr)\r\n{\r\nu32 a = ((u32)addr[0] << 16) | ((u32)addr[1] << 8) | addr[2];\r\nu32 b = ((u32)addr[3] << 16) | ((u32)addr[4] << 8) | addr[5];\r\na ^= b;\r\na ^= (a >> 12);\r\na ^= (a >> 6);\r\nreturn a & 0x3f;\r\n}\r\nstatic void init_link_config(struct link_config *lc, unsigned int caps)\r\n{\r\nlc->supported = caps;\r\nlc->requested_speed = 0;\r\nlc->speed = 0;\r\nlc->requested_fc = lc->fc = PAUSE_RX | PAUSE_TX;\r\nif (lc->supported & FW_PORT_CAP_ANEG) {\r\nlc->advertising = lc->supported & ADVERT_MASK;\r\nlc->autoneg = AUTONEG_ENABLE;\r\nlc->requested_fc |= PAUSE_AUTONEG;\r\n} else {\r\nlc->advertising = 0;\r\nlc->autoneg = AUTONEG_DISABLE;\r\n}\r\n}\r\nint t4vf_port_init(struct adapter *adapter, int pidx)\r\n{\r\nstruct port_info *pi = adap2pinfo(adapter, pidx);\r\nstruct fw_vi_cmd vi_cmd, vi_rpl;\r\nstruct fw_port_cmd port_cmd, port_rpl;\r\nint v;\r\nmemset(&vi_cmd, 0, sizeof(vi_cmd));\r\nvi_cmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_VI_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_READ_F);\r\nvi_cmd.alloc_to_len16 = cpu_to_be32(FW_LEN16(vi_cmd));\r\nvi_cmd.type_viid = cpu_to_be16(FW_VI_CMD_VIID_V(pi->viid));\r\nv = t4vf_wr_mbox(adapter, &vi_cmd, sizeof(vi_cmd), &vi_rpl);\r\nif (v)\r\nreturn v;\r\nBUG_ON(pi->port_id != FW_VI_CMD_PORTID_G(vi_rpl.portid_pkd));\r\npi->rss_size = FW_VI_CMD_RSSSIZE_G(be16_to_cpu(vi_rpl.rsssize_pkd));\r\nt4_os_set_hw_addr(adapter, pidx, vi_rpl.mac);\r\nif (!(adapter->params.vfres.r_caps & FW_CMD_CAP_PORT))\r\nreturn 0;\r\nmemset(&port_cmd, 0, sizeof(port_cmd));\r\nport_cmd.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PORT_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_READ_F |\r\nFW_PORT_CMD_PORTID_V(pi->port_id));\r\nport_cmd.action_to_len16 =\r\ncpu_to_be32(FW_PORT_CMD_ACTION_V(FW_PORT_ACTION_GET_PORT_INFO) |\r\nFW_LEN16(port_cmd));\r\nv = t4vf_wr_mbox(adapter, &port_cmd, sizeof(port_cmd), &port_rpl);\r\nif (v)\r\nreturn v;\r\nv = be32_to_cpu(port_rpl.u.info.lstatus_to_modtype);\r\npi->mdio_addr = (v & FW_PORT_CMD_MDIOCAP_F) ?\r\nFW_PORT_CMD_MDIOADDR_G(v) : -1;\r\npi->port_type = FW_PORT_CMD_PTYPE_G(v);\r\npi->mod_type = FW_PORT_MOD_TYPE_NA;\r\ninit_link_config(&pi->link_cfg, be16_to_cpu(port_rpl.u.info.pcap));\r\nreturn 0;\r\n}\r\nint t4vf_fw_reset(struct adapter *adapter)\r\n{\r\nstruct fw_reset_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_write = cpu_to_be32(FW_CMD_OP_V(FW_RESET_CMD) |\r\nFW_CMD_WRITE_F);\r\ncmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\r\nreturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\r\n}\r\nstatic int t4vf_query_params(struct adapter *adapter, unsigned int nparams,\r\nconst u32 *params, u32 *vals)\r\n{\r\nint i, ret;\r\nstruct fw_params_cmd cmd, rpl;\r\nstruct fw_params_param *p;\r\nsize_t len16;\r\nif (nparams > 7)\r\nreturn -EINVAL;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_PARAMS_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_READ_F);\r\nlen16 = DIV_ROUND_UP(offsetof(struct fw_params_cmd,\r\nparam[nparams].mnem), 16);\r\ncmd.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(len16));\r\nfor (i = 0, p = &cmd.param[0]; i < nparams; i++, p++)\r\np->mnem = htonl(*params++);\r\nret = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\r\nif (ret == 0)\r\nfor (i = 0, p = &rpl.param[0]; i < nparams; i++, p++)\r\n*vals++ = be32_to_cpu(p->val);\r\nreturn ret;\r\n}\r\nint t4vf_set_params(struct adapter *adapter, unsigned int nparams,\r\nconst u32 *params, const u32 *vals)\r\n{\r\nint i;\r\nstruct fw_params_cmd cmd;\r\nstruct fw_params_param *p;\r\nsize_t len16;\r\nif (nparams > 7)\r\nreturn -EINVAL;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_PARAMS_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_WRITE_F);\r\nlen16 = DIV_ROUND_UP(offsetof(struct fw_params_cmd,\r\nparam[nparams]), 16);\r\ncmd.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(len16));\r\nfor (i = 0, p = &cmd.param[0]; i < nparams; i++, p++) {\r\np->mnem = cpu_to_be32(*params++);\r\np->val = cpu_to_be32(*vals++);\r\n}\r\nreturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\r\n}\r\nint t4vf_bar2_sge_qregs(struct adapter *adapter,\r\nunsigned int qid,\r\nenum t4_bar2_qtype qtype,\r\nu64 *pbar2_qoffset,\r\nunsigned int *pbar2_qid)\r\n{\r\nunsigned int page_shift, page_size, qpp_shift, qpp_mask;\r\nu64 bar2_page_offset, bar2_qoffset;\r\nunsigned int bar2_qid, bar2_qid_offset, bar2_qinferred;\r\nif (is_t4(adapter->params.chip))\r\nreturn -EINVAL;\r\npage_shift = adapter->params.sge.sge_vf_hps + 10;\r\npage_size = 1 << page_shift;\r\nqpp_shift = (qtype == T4_BAR2_QTYPE_EGRESS\r\n? adapter->params.sge.sge_vf_eq_qpp\r\n: adapter->params.sge.sge_vf_iq_qpp);\r\nqpp_mask = (1 << qpp_shift) - 1;\r\nbar2_page_offset = ((u64)(qid >> qpp_shift) << page_shift);\r\nbar2_qid = qid & qpp_mask;\r\nbar2_qid_offset = bar2_qid * SGE_UDB_SIZE;\r\nbar2_qoffset = bar2_page_offset;\r\nbar2_qinferred = (bar2_qid_offset < page_size);\r\nif (bar2_qinferred) {\r\nbar2_qoffset += bar2_qid_offset;\r\nbar2_qid = 0;\r\n}\r\n*pbar2_qoffset = bar2_qoffset;\r\n*pbar2_qid = bar2_qid;\r\nreturn 0;\r\n}\r\nint t4vf_get_sge_params(struct adapter *adapter)\r\n{\r\nstruct sge_params *sge_params = &adapter->params.sge;\r\nu32 params[7], vals[7];\r\nint v;\r\nparams[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ_V(SGE_CONTROL_A));\r\nparams[1] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ_V(SGE_HOST_PAGE_SIZE_A));\r\nparams[2] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ_V(SGE_FL_BUFFER_SIZE0_A));\r\nparams[3] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ_V(SGE_FL_BUFFER_SIZE1_A));\r\nparams[4] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ_V(SGE_TIMER_VALUE_0_AND_1_A));\r\nparams[5] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ_V(SGE_TIMER_VALUE_2_AND_3_A));\r\nparams[6] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ_V(SGE_TIMER_VALUE_4_AND_5_A));\r\nv = t4vf_query_params(adapter, 7, params, vals);\r\nif (v)\r\nreturn v;\r\nsge_params->sge_control = vals[0];\r\nsge_params->sge_host_page_size = vals[1];\r\nsge_params->sge_fl_buffer_size[0] = vals[2];\r\nsge_params->sge_fl_buffer_size[1] = vals[3];\r\nsge_params->sge_timer_value_0_and_1 = vals[4];\r\nsge_params->sge_timer_value_2_and_3 = vals[5];\r\nsge_params->sge_timer_value_4_and_5 = vals[6];\r\nif (!is_t4(adapter->params.chip)) {\r\nparams[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ_V(SGE_CONTROL2_A));\r\nv = t4vf_query_params(adapter, 1, params, vals);\r\nif (v != FW_SUCCESS) {\r\ndev_err(adapter->pdev_dev,\r\n"Unable to get SGE Control2; "\r\n"probably old firmware.\n");\r\nreturn v;\r\n}\r\nsge_params->sge_control2 = vals[0];\r\n}\r\nparams[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ_V(SGE_INGRESS_RX_THRESHOLD_A));\r\nparams[1] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ_V(SGE_CONM_CTRL_A));\r\nv = t4vf_query_params(adapter, 2, params, vals);\r\nif (v)\r\nreturn v;\r\nsge_params->sge_ingress_rx_threshold = vals[0];\r\nsge_params->sge_congestion_control = vals[1];\r\nif (!is_t4(adapter->params.chip)) {\r\nu32 whoami;\r\nunsigned int pf, s_hps, s_qpp;\r\nparams[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ_V(\r\nSGE_EGRESS_QUEUES_PER_PAGE_VF_A));\r\nparams[1] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ_V(\r\nSGE_INGRESS_QUEUES_PER_PAGE_VF_A));\r\nv = t4vf_query_params(adapter, 2, params, vals);\r\nif (v != FW_SUCCESS) {\r\ndev_warn(adapter->pdev_dev,\r\n"Unable to get VF SGE Queues/Page; "\r\n"probably old firmware.\n");\r\nreturn v;\r\n}\r\nsge_params->sge_egress_queues_per_page = vals[0];\r\nsge_params->sge_ingress_queues_per_page = vals[1];\r\nwhoami = t4_read_reg(adapter,\r\nT4VF_PL_BASE_ADDR + PL_VF_WHOAMI_A);\r\npf = CHELSIO_CHIP_VERSION(adapter->params.chip) <= CHELSIO_T5 ?\r\nSOURCEPF_G(whoami) : T6_SOURCEPF_G(whoami);\r\ns_hps = (HOSTPAGESIZEPF0_S +\r\n(HOSTPAGESIZEPF1_S - HOSTPAGESIZEPF0_S) * pf);\r\nsge_params->sge_vf_hps =\r\n((sge_params->sge_host_page_size >> s_hps)\r\n& HOSTPAGESIZEPF0_M);\r\ns_qpp = (QUEUESPERPAGEPF0_S +\r\n(QUEUESPERPAGEPF1_S - QUEUESPERPAGEPF0_S) * pf);\r\nsge_params->sge_vf_eq_qpp =\r\n((sge_params->sge_egress_queues_per_page >> s_qpp)\r\n& QUEUESPERPAGEPF0_M);\r\nsge_params->sge_vf_iq_qpp =\r\n((sge_params->sge_ingress_queues_per_page >> s_qpp)\r\n& QUEUESPERPAGEPF0_M);\r\n}\r\nreturn 0;\r\n}\r\nint t4vf_get_vpd_params(struct adapter *adapter)\r\n{\r\nstruct vpd_params *vpd_params = &adapter->params.vpd;\r\nu32 params[7], vals[7];\r\nint v;\r\nparams[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\r\nFW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_CCLK));\r\nv = t4vf_query_params(adapter, 1, params, vals);\r\nif (v)\r\nreturn v;\r\nvpd_params->cclk = vals[0];\r\nreturn 0;\r\n}\r\nint t4vf_get_dev_params(struct adapter *adapter)\r\n{\r\nstruct dev_params *dev_params = &adapter->params.dev;\r\nu32 params[7], vals[7];\r\nint v;\r\nparams[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\r\nFW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_FWREV));\r\nparams[1] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\r\nFW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_TPREV));\r\nv = t4vf_query_params(adapter, 2, params, vals);\r\nif (v)\r\nreturn v;\r\ndev_params->fwrev = vals[0];\r\ndev_params->tprev = vals[1];\r\nreturn 0;\r\n}\r\nint t4vf_get_rss_glb_config(struct adapter *adapter)\r\n{\r\nstruct rss_params *rss = &adapter->params.rss;\r\nstruct fw_rss_glb_config_cmd cmd, rpl;\r\nint v;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_write = cpu_to_be32(FW_CMD_OP_V(FW_RSS_GLB_CONFIG_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_READ_F);\r\ncmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\r\nv = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\r\nif (v)\r\nreturn v;\r\nrss->mode = FW_RSS_GLB_CONFIG_CMD_MODE_G(\r\nbe32_to_cpu(rpl.u.manual.mode_pkd));\r\nswitch (rss->mode) {\r\ncase FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL: {\r\nu32 word = be32_to_cpu(\r\nrpl.u.basicvirtual.synmapen_to_hashtoeplitz);\r\nrss->u.basicvirtual.synmapen =\r\n((word & FW_RSS_GLB_CONFIG_CMD_SYNMAPEN_F) != 0);\r\nrss->u.basicvirtual.syn4tupenipv6 =\r\n((word & FW_RSS_GLB_CONFIG_CMD_SYN4TUPENIPV6_F) != 0);\r\nrss->u.basicvirtual.syn2tupenipv6 =\r\n((word & FW_RSS_GLB_CONFIG_CMD_SYN2TUPENIPV6_F) != 0);\r\nrss->u.basicvirtual.syn4tupenipv4 =\r\n((word & FW_RSS_GLB_CONFIG_CMD_SYN4TUPENIPV4_F) != 0);\r\nrss->u.basicvirtual.syn2tupenipv4 =\r\n((word & FW_RSS_GLB_CONFIG_CMD_SYN2TUPENIPV4_F) != 0);\r\nrss->u.basicvirtual.ofdmapen =\r\n((word & FW_RSS_GLB_CONFIG_CMD_OFDMAPEN_F) != 0);\r\nrss->u.basicvirtual.tnlmapen =\r\n((word & FW_RSS_GLB_CONFIG_CMD_TNLMAPEN_F) != 0);\r\nrss->u.basicvirtual.tnlalllookup =\r\n((word & FW_RSS_GLB_CONFIG_CMD_TNLALLLKP_F) != 0);\r\nrss->u.basicvirtual.hashtoeplitz =\r\n((word & FW_RSS_GLB_CONFIG_CMD_HASHTOEPLITZ_F) != 0);\r\nif (!rss->u.basicvirtual.tnlmapen)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint t4vf_get_vfres(struct adapter *adapter)\r\n{\r\nstruct vf_resources *vfres = &adapter->params.vfres;\r\nstruct fw_pfvf_cmd cmd, rpl;\r\nint v;\r\nu32 word;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_PFVF_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_READ_F);\r\ncmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\r\nv = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\r\nif (v)\r\nreturn v;\r\nword = be32_to_cpu(rpl.niqflint_niq);\r\nvfres->niqflint = FW_PFVF_CMD_NIQFLINT_G(word);\r\nvfres->niq = FW_PFVF_CMD_NIQ_G(word);\r\nword = be32_to_cpu(rpl.type_to_neq);\r\nvfres->neq = FW_PFVF_CMD_NEQ_G(word);\r\nvfres->pmask = FW_PFVF_CMD_PMASK_G(word);\r\nword = be32_to_cpu(rpl.tc_to_nexactf);\r\nvfres->tc = FW_PFVF_CMD_TC_G(word);\r\nvfres->nvi = FW_PFVF_CMD_NVI_G(word);\r\nvfres->nexactf = FW_PFVF_CMD_NEXACTF_G(word);\r\nword = be32_to_cpu(rpl.r_caps_to_nethctrl);\r\nvfres->r_caps = FW_PFVF_CMD_R_CAPS_G(word);\r\nvfres->wx_caps = FW_PFVF_CMD_WX_CAPS_G(word);\r\nvfres->nethctrl = FW_PFVF_CMD_NETHCTRL_G(word);\r\nreturn 0;\r\n}\r\nint t4vf_read_rss_vi_config(struct adapter *adapter, unsigned int viid,\r\nunion rss_vi_config *config)\r\n{\r\nstruct fw_rss_vi_config_cmd cmd, rpl;\r\nint v;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_RSS_VI_CONFIG_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_READ_F |\r\nFW_RSS_VI_CONFIG_CMD_VIID(viid));\r\ncmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\r\nv = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\r\nif (v)\r\nreturn v;\r\nswitch (adapter->params.rss.mode) {\r\ncase FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL: {\r\nu32 word = be32_to_cpu(rpl.u.basicvirtual.defaultq_to_udpen);\r\nconfig->basicvirtual.ip6fourtupen =\r\n((word & FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN_F) != 0);\r\nconfig->basicvirtual.ip6twotupen =\r\n((word & FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN_F) != 0);\r\nconfig->basicvirtual.ip4fourtupen =\r\n((word & FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN_F) != 0);\r\nconfig->basicvirtual.ip4twotupen =\r\n((word & FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN_F) != 0);\r\nconfig->basicvirtual.udpen =\r\n((word & FW_RSS_VI_CONFIG_CMD_UDPEN_F) != 0);\r\nconfig->basicvirtual.defaultq =\r\nFW_RSS_VI_CONFIG_CMD_DEFAULTQ_G(word);\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint t4vf_write_rss_vi_config(struct adapter *adapter, unsigned int viid,\r\nunion rss_vi_config *config)\r\n{\r\nstruct fw_rss_vi_config_cmd cmd, rpl;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_RSS_VI_CONFIG_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_WRITE_F |\r\nFW_RSS_VI_CONFIG_CMD_VIID(viid));\r\ncmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\r\nswitch (adapter->params.rss.mode) {\r\ncase FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL: {\r\nu32 word = 0;\r\nif (config->basicvirtual.ip6fourtupen)\r\nword |= FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN_F;\r\nif (config->basicvirtual.ip6twotupen)\r\nword |= FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN_F;\r\nif (config->basicvirtual.ip4fourtupen)\r\nword |= FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN_F;\r\nif (config->basicvirtual.ip4twotupen)\r\nword |= FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN_F;\r\nif (config->basicvirtual.udpen)\r\nword |= FW_RSS_VI_CONFIG_CMD_UDPEN_F;\r\nword |= FW_RSS_VI_CONFIG_CMD_DEFAULTQ_V(\r\nconfig->basicvirtual.defaultq);\r\ncmd.u.basicvirtual.defaultq_to_udpen = cpu_to_be32(word);\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\r\n}\r\nint t4vf_config_rss_range(struct adapter *adapter, unsigned int viid,\r\nint start, int n, const u16 *rspq, int nrspq)\r\n{\r\nconst u16 *rsp = rspq;\r\nconst u16 *rsp_end = rspq+nrspq;\r\nstruct fw_rss_ind_tbl_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_RSS_IND_TBL_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_WRITE_F |\r\nFW_RSS_IND_TBL_CMD_VIID_V(viid));\r\ncmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\r\nwhile (n > 0) {\r\n__be32 *qp = &cmd.iq0_to_iq2;\r\nint nq = min(n, 32);\r\nint ret;\r\ncmd.niqid = cpu_to_be16(nq);\r\ncmd.startidx = cpu_to_be16(start);\r\nstart += nq;\r\nn -= nq;\r\nwhile (nq > 0) {\r\nu16 qbuf[3];\r\nu16 *qbp = qbuf;\r\nint nqbuf = min(3, nq);\r\nnq -= nqbuf;\r\nqbuf[0] = qbuf[1] = qbuf[2] = 0;\r\nwhile (nqbuf) {\r\nnqbuf--;\r\n*qbp++ = *rsp++;\r\nif (rsp >= rsp_end)\r\nrsp = rspq;\r\n}\r\n*qp++ = cpu_to_be32(FW_RSS_IND_TBL_CMD_IQ0_V(qbuf[0]) |\r\nFW_RSS_IND_TBL_CMD_IQ1_V(qbuf[1]) |\r\nFW_RSS_IND_TBL_CMD_IQ2_V(qbuf[2]));\r\n}\r\nret = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint t4vf_alloc_vi(struct adapter *adapter, int port_id)\r\n{\r\nstruct fw_vi_cmd cmd, rpl;\r\nint v;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_VI_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_WRITE_F |\r\nFW_CMD_EXEC_F);\r\ncmd.alloc_to_len16 = cpu_to_be32(FW_LEN16(cmd) |\r\nFW_VI_CMD_ALLOC_F);\r\ncmd.portid_pkd = FW_VI_CMD_PORTID_V(port_id);\r\nv = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\r\nif (v)\r\nreturn v;\r\nreturn FW_VI_CMD_VIID_G(be16_to_cpu(rpl.type_viid));\r\n}\r\nint t4vf_free_vi(struct adapter *adapter, int viid)\r\n{\r\nstruct fw_vi_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_VI_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_EXEC_F);\r\ncmd.alloc_to_len16 = cpu_to_be32(FW_LEN16(cmd) |\r\nFW_VI_CMD_FREE_F);\r\ncmd.type_viid = cpu_to_be16(FW_VI_CMD_VIID_V(viid));\r\nreturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\r\n}\r\nint t4vf_enable_vi(struct adapter *adapter, unsigned int viid,\r\nbool rx_en, bool tx_en)\r\n{\r\nstruct fw_vi_enable_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_ENABLE_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_EXEC_F |\r\nFW_VI_ENABLE_CMD_VIID_V(viid));\r\ncmd.ien_to_len16 = cpu_to_be32(FW_VI_ENABLE_CMD_IEN_V(rx_en) |\r\nFW_VI_ENABLE_CMD_EEN_V(tx_en) |\r\nFW_LEN16(cmd));\r\nreturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\r\n}\r\nint t4vf_identify_port(struct adapter *adapter, unsigned int viid,\r\nunsigned int nblinks)\r\n{\r\nstruct fw_vi_enable_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_ENABLE_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_EXEC_F |\r\nFW_VI_ENABLE_CMD_VIID_V(viid));\r\ncmd.ien_to_len16 = cpu_to_be32(FW_VI_ENABLE_CMD_LED_F |\r\nFW_LEN16(cmd));\r\ncmd.blinkdur = cpu_to_be16(nblinks);\r\nreturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\r\n}\r\nint t4vf_set_rxmode(struct adapter *adapter, unsigned int viid,\r\nint mtu, int promisc, int all_multi, int bcast, int vlanex,\r\nbool sleep_ok)\r\n{\r\nstruct fw_vi_rxmode_cmd cmd;\r\nif (mtu < 0)\r\nmtu = FW_VI_RXMODE_CMD_MTU_M;\r\nif (promisc < 0)\r\npromisc = FW_VI_RXMODE_CMD_PROMISCEN_M;\r\nif (all_multi < 0)\r\nall_multi = FW_VI_RXMODE_CMD_ALLMULTIEN_M;\r\nif (bcast < 0)\r\nbcast = FW_VI_RXMODE_CMD_BROADCASTEN_M;\r\nif (vlanex < 0)\r\nvlanex = FW_VI_RXMODE_CMD_VLANEXEN_M;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_RXMODE_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_WRITE_F |\r\nFW_VI_RXMODE_CMD_VIID_V(viid));\r\ncmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\r\ncmd.mtu_to_vlanexen =\r\ncpu_to_be32(FW_VI_RXMODE_CMD_MTU_V(mtu) |\r\nFW_VI_RXMODE_CMD_PROMISCEN_V(promisc) |\r\nFW_VI_RXMODE_CMD_ALLMULTIEN_V(all_multi) |\r\nFW_VI_RXMODE_CMD_BROADCASTEN_V(bcast) |\r\nFW_VI_RXMODE_CMD_VLANEXEN_V(vlanex));\r\nreturn t4vf_wr_mbox_core(adapter, &cmd, sizeof(cmd), NULL, sleep_ok);\r\n}\r\nint t4vf_alloc_mac_filt(struct adapter *adapter, unsigned int viid, bool free,\r\nunsigned int naddr, const u8 **addr, u16 *idx,\r\nu64 *hash, bool sleep_ok)\r\n{\r\nint offset, ret = 0;\r\nunsigned nfilters = 0;\r\nunsigned int rem = naddr;\r\nstruct fw_vi_mac_cmd cmd, rpl;\r\nunsigned int max_naddr = adapter->params.arch.mps_tcam_size;\r\nif (naddr > max_naddr)\r\nreturn -EINVAL;\r\nfor (offset = 0; offset < naddr; ) {\r\nunsigned int fw_naddr = (rem < ARRAY_SIZE(cmd.u.exact)\r\n? rem\r\n: ARRAY_SIZE(cmd.u.exact));\r\nsize_t len16 = DIV_ROUND_UP(offsetof(struct fw_vi_mac_cmd,\r\nu.exact[fw_naddr]), 16);\r\nstruct fw_vi_mac_exact *p;\r\nint i;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_WRITE_F |\r\n(free ? FW_CMD_EXEC_F : 0) |\r\nFW_VI_MAC_CMD_VIID_V(viid));\r\ncmd.freemacs_to_len16 =\r\ncpu_to_be32(FW_VI_MAC_CMD_FREEMACS_V(free) |\r\nFW_CMD_LEN16_V(len16));\r\nfor (i = 0, p = cmd.u.exact; i < fw_naddr; i++, p++) {\r\np->valid_to_idx = cpu_to_be16(\r\nFW_VI_MAC_CMD_VALID_F |\r\nFW_VI_MAC_CMD_IDX_V(FW_VI_MAC_ADD_MAC));\r\nmemcpy(p->macaddr, addr[offset+i], sizeof(p->macaddr));\r\n}\r\nret = t4vf_wr_mbox_core(adapter, &cmd, sizeof(cmd), &rpl,\r\nsleep_ok);\r\nif (ret && ret != -ENOMEM)\r\nbreak;\r\nfor (i = 0, p = rpl.u.exact; i < fw_naddr; i++, p++) {\r\nu16 index = FW_VI_MAC_CMD_IDX_G(\r\nbe16_to_cpu(p->valid_to_idx));\r\nif (idx)\r\nidx[offset+i] =\r\n(index >= max_naddr\r\n? 0xffff\r\n: index);\r\nif (index < max_naddr)\r\nnfilters++;\r\nelse if (hash)\r\n*hash |= (1ULL << hash_mac_addr(addr[offset+i]));\r\n}\r\nfree = false;\r\noffset += fw_naddr;\r\nrem -= fw_naddr;\r\n}\r\nif (ret == 0 || ret == -ENOMEM)\r\nret = nfilters;\r\nreturn ret;\r\n}\r\nint t4vf_change_mac(struct adapter *adapter, unsigned int viid,\r\nint idx, const u8 *addr, bool persist)\r\n{\r\nint ret;\r\nstruct fw_vi_mac_cmd cmd, rpl;\r\nstruct fw_vi_mac_exact *p = &cmd.u.exact[0];\r\nsize_t len16 = DIV_ROUND_UP(offsetof(struct fw_vi_mac_cmd,\r\nu.exact[1]), 16);\r\nunsigned int max_mac_addr = adapter->params.arch.mps_tcam_size;\r\nif (idx < 0)\r\nidx = persist ? FW_VI_MAC_ADD_PERSIST_MAC : FW_VI_MAC_ADD_MAC;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_WRITE_F |\r\nFW_VI_MAC_CMD_VIID_V(viid));\r\ncmd.freemacs_to_len16 = cpu_to_be32(FW_CMD_LEN16_V(len16));\r\np->valid_to_idx = cpu_to_be16(FW_VI_MAC_CMD_VALID_F |\r\nFW_VI_MAC_CMD_IDX_V(idx));\r\nmemcpy(p->macaddr, addr, sizeof(p->macaddr));\r\nret = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\r\nif (ret == 0) {\r\np = &rpl.u.exact[0];\r\nret = FW_VI_MAC_CMD_IDX_G(be16_to_cpu(p->valid_to_idx));\r\nif (ret >= max_mac_addr)\r\nret = -ENOMEM;\r\n}\r\nreturn ret;\r\n}\r\nint t4vf_set_addr_hash(struct adapter *adapter, unsigned int viid,\r\nbool ucast, u64 vec, bool sleep_ok)\r\n{\r\nstruct fw_vi_mac_cmd cmd;\r\nsize_t len16 = DIV_ROUND_UP(offsetof(struct fw_vi_mac_cmd,\r\nu.exact[0]), 16);\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_WRITE_F |\r\nFW_VI_ENABLE_CMD_VIID_V(viid));\r\ncmd.freemacs_to_len16 = cpu_to_be32(FW_VI_MAC_CMD_HASHVECEN_F |\r\nFW_VI_MAC_CMD_HASHUNIEN_V(ucast) |\r\nFW_CMD_LEN16_V(len16));\r\ncmd.u.hash.hashvec = cpu_to_be64(vec);\r\nreturn t4vf_wr_mbox_core(adapter, &cmd, sizeof(cmd), NULL, sleep_ok);\r\n}\r\nint t4vf_get_port_stats(struct adapter *adapter, int pidx,\r\nstruct t4vf_port_stats *s)\r\n{\r\nstruct port_info *pi = adap2pinfo(adapter, pidx);\r\nstruct fw_vi_stats_vf fwstats;\r\nunsigned int rem = VI_VF_NUM_STATS;\r\n__be64 *fwsp = (__be64 *)&fwstats;\r\nwhile (rem) {\r\nunsigned int ix = VI_VF_NUM_STATS - rem;\r\nunsigned int nstats = min(6U, rem);\r\nstruct fw_vi_stats_cmd cmd, rpl;\r\nsize_t len = (offsetof(struct fw_vi_stats_cmd, u) +\r\nsizeof(struct fw_vi_stats_ctl));\r\nsize_t len16 = DIV_ROUND_UP(len, 16);\r\nint ret;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_STATS_CMD) |\r\nFW_VI_STATS_CMD_VIID_V(pi->viid) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_READ_F);\r\ncmd.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(len16));\r\ncmd.u.ctl.nstats_ix =\r\ncpu_to_be16(FW_VI_STATS_CMD_IX_V(ix) |\r\nFW_VI_STATS_CMD_NSTATS_V(nstats));\r\nret = t4vf_wr_mbox_ns(adapter, &cmd, len, &rpl);\r\nif (ret)\r\nreturn ret;\r\nmemcpy(fwsp, &rpl.u.ctl.stat0, sizeof(__be64) * nstats);\r\nrem -= nstats;\r\nfwsp += nstats;\r\n}\r\ns->tx_bcast_bytes = be64_to_cpu(fwstats.tx_bcast_bytes);\r\ns->tx_bcast_frames = be64_to_cpu(fwstats.tx_bcast_frames);\r\ns->tx_mcast_bytes = be64_to_cpu(fwstats.tx_mcast_bytes);\r\ns->tx_mcast_frames = be64_to_cpu(fwstats.tx_mcast_frames);\r\ns->tx_ucast_bytes = be64_to_cpu(fwstats.tx_ucast_bytes);\r\ns->tx_ucast_frames = be64_to_cpu(fwstats.tx_ucast_frames);\r\ns->tx_drop_frames = be64_to_cpu(fwstats.tx_drop_frames);\r\ns->tx_offload_bytes = be64_to_cpu(fwstats.tx_offload_bytes);\r\ns->tx_offload_frames = be64_to_cpu(fwstats.tx_offload_frames);\r\ns->rx_bcast_bytes = be64_to_cpu(fwstats.rx_bcast_bytes);\r\ns->rx_bcast_frames = be64_to_cpu(fwstats.rx_bcast_frames);\r\ns->rx_mcast_bytes = be64_to_cpu(fwstats.rx_mcast_bytes);\r\ns->rx_mcast_frames = be64_to_cpu(fwstats.rx_mcast_frames);\r\ns->rx_ucast_bytes = be64_to_cpu(fwstats.rx_ucast_bytes);\r\ns->rx_ucast_frames = be64_to_cpu(fwstats.rx_ucast_frames);\r\ns->rx_err_frames = be64_to_cpu(fwstats.rx_err_frames);\r\nreturn 0;\r\n}\r\nint t4vf_iq_free(struct adapter *adapter, unsigned int iqtype,\r\nunsigned int iqid, unsigned int fl0id, unsigned int fl1id)\r\n{\r\nstruct fw_iq_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_IQ_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_EXEC_F);\r\ncmd.alloc_to_len16 = cpu_to_be32(FW_IQ_CMD_FREE_F |\r\nFW_LEN16(cmd));\r\ncmd.type_to_iqandstindex =\r\ncpu_to_be32(FW_IQ_CMD_TYPE_V(iqtype));\r\ncmd.iqid = cpu_to_be16(iqid);\r\ncmd.fl0id = cpu_to_be16(fl0id);\r\ncmd.fl1id = cpu_to_be16(fl1id);\r\nreturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\r\n}\r\nint t4vf_eth_eq_free(struct adapter *adapter, unsigned int eqid)\r\n{\r\nstruct fw_eq_eth_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_EQ_ETH_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_EXEC_F);\r\ncmd.alloc_to_len16 = cpu_to_be32(FW_EQ_ETH_CMD_FREE_F |\r\nFW_LEN16(cmd));\r\ncmd.eqid_pkd = cpu_to_be32(FW_EQ_ETH_CMD_EQID_V(eqid));\r\nreturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\r\n}\r\nint t4vf_handle_fw_rpl(struct adapter *adapter, const __be64 *rpl)\r\n{\r\nconst struct fw_cmd_hdr *cmd_hdr = (const struct fw_cmd_hdr *)rpl;\r\nu8 opcode = FW_CMD_OP_G(be32_to_cpu(cmd_hdr->hi));\r\nswitch (opcode) {\r\ncase FW_PORT_CMD: {\r\nconst struct fw_port_cmd *port_cmd =\r\n(const struct fw_port_cmd *)rpl;\r\nu32 stat, mod;\r\nint action, port_id, link_ok, speed, fc, pidx;\r\naction = FW_PORT_CMD_ACTION_G(\r\nbe32_to_cpu(port_cmd->action_to_len16));\r\nif (action != FW_PORT_ACTION_GET_PORT_INFO) {\r\ndev_err(adapter->pdev_dev,\r\n"Unknown firmware PORT reply action %x\n",\r\naction);\r\nbreak;\r\n}\r\nport_id = FW_PORT_CMD_PORTID_G(\r\nbe32_to_cpu(port_cmd->op_to_portid));\r\nstat = be32_to_cpu(port_cmd->u.info.lstatus_to_modtype);\r\nlink_ok = (stat & FW_PORT_CMD_LSTATUS_F) != 0;\r\nspeed = 0;\r\nfc = 0;\r\nif (stat & FW_PORT_CMD_RXPAUSE_F)\r\nfc |= PAUSE_RX;\r\nif (stat & FW_PORT_CMD_TXPAUSE_F)\r\nfc |= PAUSE_TX;\r\nif (stat & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_100M))\r\nspeed = 100;\r\nelse if (stat & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_1G))\r\nspeed = 1000;\r\nelse if (stat & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_10G))\r\nspeed = 10000;\r\nelse if (stat & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_40G))\r\nspeed = 40000;\r\nfor_each_port(adapter, pidx) {\r\nstruct port_info *pi = adap2pinfo(adapter, pidx);\r\nstruct link_config *lc;\r\nif (pi->port_id != port_id)\r\ncontinue;\r\nlc = &pi->link_cfg;\r\nmod = FW_PORT_CMD_MODTYPE_G(stat);\r\nif (mod != pi->mod_type) {\r\npi->mod_type = mod;\r\nt4vf_os_portmod_changed(adapter, pidx);\r\n}\r\nif (link_ok != lc->link_ok || speed != lc->speed ||\r\nfc != lc->fc) {\r\nlc->link_ok = link_ok;\r\nlc->speed = speed;\r\nlc->fc = fc;\r\nlc->supported =\r\nbe16_to_cpu(port_cmd->u.info.pcap);\r\nt4vf_os_link_changed(adapter, pidx, link_ok);\r\n}\r\n}\r\nbreak;\r\n}\r\ndefault:\r\ndev_err(adapter->pdev_dev, "Unknown firmware reply %X\n",\r\nopcode);\r\n}\r\nreturn 0;\r\n}\r\nint t4vf_prep_adapter(struct adapter *adapter)\r\n{\r\nint err;\r\nunsigned int chipid;\r\nerr = t4vf_wait_dev_ready(adapter);\r\nif (err)\r\nreturn err;\r\nadapter->params.nports = 1;\r\nadapter->params.vfres.pmask = 1;\r\nadapter->params.vpd.cclk = 50000;\r\nadapter->params.chip = 0;\r\nswitch (CHELSIO_PCI_ID_VER(adapter->pdev->device)) {\r\ncase CHELSIO_T4:\r\nadapter->params.chip |= CHELSIO_CHIP_CODE(CHELSIO_T4, 0);\r\nadapter->params.arch.sge_fl_db = DBPRIO_F;\r\nadapter->params.arch.mps_tcam_size =\r\nNUM_MPS_CLS_SRAM_L_INSTANCES;\r\nbreak;\r\ncase CHELSIO_T5:\r\nchipid = REV_G(t4_read_reg(adapter, PL_VF_REV_A));\r\nadapter->params.chip |= CHELSIO_CHIP_CODE(CHELSIO_T5, chipid);\r\nadapter->params.arch.sge_fl_db = DBPRIO_F | DBTYPE_F;\r\nadapter->params.arch.mps_tcam_size =\r\nNUM_MPS_T5_CLS_SRAM_L_INSTANCES;\r\nbreak;\r\ncase CHELSIO_T6:\r\nchipid = REV_G(t4_read_reg(adapter, PL_VF_REV_A));\r\nadapter->params.chip |= CHELSIO_CHIP_CODE(CHELSIO_T6, chipid);\r\nadapter->params.arch.sge_fl_db = 0;\r\nadapter->params.arch.mps_tcam_size =\r\nNUM_MPS_T5_CLS_SRAM_L_INSTANCES;\r\nbreak;\r\n}\r\nreturn 0;\r\n}
