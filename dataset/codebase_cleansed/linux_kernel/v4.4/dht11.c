static unsigned char dht11_decode_byte(int *timing, int threshold)\r\n{\r\nunsigned char ret = 0;\r\nint i;\r\nfor (i = 0; i < 8; ++i) {\r\nret <<= 1;\r\nif (timing[i] >= threshold)\r\n++ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dht11_decode(struct dht11 *dht11, int offset, int timeres)\r\n{\r\nint i, t, timing[DHT11_BITS_PER_READ], threshold;\r\nunsigned char temp_int, temp_dec, hum_int, hum_dec, checksum;\r\nthreshold = DHT11_DATA_BIT_HIGH / timeres;\r\nif (DHT11_DATA_BIT_LOW / timeres + 1 >= threshold)\r\npr_err("dht11: WARNING: decoding ambiguous\n");\r\nfor (i = 0; i < DHT11_BITS_PER_READ; ++i) {\r\nt = dht11->edges[offset + 2 * i + 2].ts -\r\ndht11->edges[offset + 2 * i + 1].ts;\r\nif (!dht11->edges[offset + 2 * i + 1].value)\r\nreturn -EIO;\r\ntiming[i] = t / timeres;\r\n}\r\nhum_int = dht11_decode_byte(timing, threshold);\r\nhum_dec = dht11_decode_byte(&timing[8], threshold);\r\ntemp_int = dht11_decode_byte(&timing[16], threshold);\r\ntemp_dec = dht11_decode_byte(&timing[24], threshold);\r\nchecksum = dht11_decode_byte(&timing[32], threshold);\r\nif (((hum_int + hum_dec + temp_int + temp_dec) & 0xff) != checksum)\r\nreturn -EIO;\r\ndht11->timestamp = ktime_get_real_ns();\r\nif (hum_int < 20) {\r\ndht11->temperature = (((temp_int & 0x7f) << 8) + temp_dec) *\r\n((temp_int & 0x80) ? -100 : 100);\r\ndht11->humidity = ((hum_int << 8) + hum_dec) * 100;\r\n} else if (temp_dec == 0 && hum_dec == 0) {\r\ndht11->temperature = temp_int * 1000;\r\ndht11->humidity = hum_int * 1000;\r\n} else {\r\ndev_err(dht11->dev,\r\n"Don't know how to decode data: %d %d %d %d\n",\r\nhum_int, hum_dec, temp_int, temp_dec);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t dht11_handle_irq(int irq, void *data)\r\n{\r\nstruct iio_dev *iio = data;\r\nstruct dht11 *dht11 = iio_priv(iio);\r\nif (dht11->num_edges < DHT11_EDGES_PER_READ && dht11->num_edges >= 0) {\r\ndht11->edges[dht11->num_edges].ts = ktime_get_real_ns();\r\ndht11->edges[dht11->num_edges++].value =\r\ngpio_get_value(dht11->gpio);\r\nif (dht11->num_edges >= DHT11_EDGES_PER_READ)\r\ncomplete(&dht11->completion);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int dht11_read_raw(struct iio_dev *iio_dev,\r\nconst struct iio_chan_spec *chan,\r\nint *val, int *val2, long m)\r\n{\r\nstruct dht11 *dht11 = iio_priv(iio_dev);\r\nint ret, timeres;\r\nmutex_lock(&dht11->lock);\r\nif (dht11->timestamp + DHT11_DATA_VALID_TIME < ktime_get_real_ns()) {\r\ntimeres = ktime_get_resolution_ns();\r\nif (DHT11_DATA_BIT_HIGH < 2 * timeres) {\r\ndev_err(dht11->dev, "timeresolution %dns too low\n",\r\ntimeres);\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nreinit_completion(&dht11->completion);\r\ndht11->num_edges = 0;\r\nret = gpio_direction_output(dht11->gpio, 0);\r\nif (ret)\r\ngoto err;\r\nmsleep(DHT11_START_TRANSMISSION);\r\nret = gpio_direction_input(dht11->gpio);\r\nif (ret)\r\ngoto err;\r\nret = request_irq(dht11->irq, dht11_handle_irq,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\niio_dev->name, iio_dev);\r\nif (ret)\r\ngoto err;\r\nret = wait_for_completion_killable_timeout(&dht11->completion,\r\nHZ);\r\nfree_irq(dht11->irq, iio_dev);\r\nif (ret == 0 && dht11->num_edges < DHT11_EDGES_PER_READ - 1) {\r\ndev_err(&iio_dev->dev,\r\n"Only %d signal edges detected\n",\r\ndht11->num_edges);\r\nret = -ETIMEDOUT;\r\n}\r\nif (ret < 0)\r\ngoto err;\r\nret = dht11_decode(dht11,\r\ndht11->num_edges == DHT11_EDGES_PER_READ ?\r\nDHT11_EDGES_PREAMBLE :\r\nDHT11_EDGES_PREAMBLE - 2,\r\ntimeres);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = IIO_VAL_INT;\r\nif (chan->type == IIO_TEMP)\r\n*val = dht11->temperature;\r\nelse if (chan->type == IIO_HUMIDITYRELATIVE)\r\n*val = dht11->humidity;\r\nelse\r\nret = -EINVAL;\r\nerr:\r\ndht11->num_edges = -1;\r\nmutex_unlock(&dht11->lock);\r\nreturn ret;\r\n}\r\nstatic int dht11_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct dht11 *dht11;\r\nstruct iio_dev *iio;\r\nint ret;\r\niio = devm_iio_device_alloc(dev, sizeof(*dht11));\r\nif (!iio) {\r\ndev_err(dev, "Failed to allocate IIO device\n");\r\nreturn -ENOMEM;\r\n}\r\ndht11 = iio_priv(iio);\r\ndht11->dev = dev;\r\nret = of_get_gpio(node, 0);\r\nif (ret < 0)\r\nreturn ret;\r\ndht11->gpio = ret;\r\nret = devm_gpio_request_one(dev, dht11->gpio, GPIOF_IN, pdev->name);\r\nif (ret)\r\nreturn ret;\r\ndht11->irq = gpio_to_irq(dht11->gpio);\r\nif (dht11->irq < 0) {\r\ndev_err(dev, "GPIO %d has no interrupt\n", dht11->gpio);\r\nreturn -EINVAL;\r\n}\r\ndht11->timestamp = ktime_get_real_ns() - DHT11_DATA_VALID_TIME - 1;\r\ndht11->num_edges = -1;\r\nplatform_set_drvdata(pdev, iio);\r\ninit_completion(&dht11->completion);\r\nmutex_init(&dht11->lock);\r\niio->name = pdev->name;\r\niio->dev.parent = &pdev->dev;\r\niio->info = &dht11_iio_info;\r\niio->modes = INDIO_DIRECT_MODE;\r\niio->channels = dht11_chan_spec;\r\niio->num_channels = ARRAY_SIZE(dht11_chan_spec);\r\nreturn devm_iio_device_register(dev, iio);\r\n}
