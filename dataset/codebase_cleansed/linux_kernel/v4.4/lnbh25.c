static int lnbh25_read_vmon(struct lnbh25_priv *priv)\r\n{\r\nint i, ret;\r\nu8 addr = 0x00;\r\nu8 status[6];\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = priv->i2c_address,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &addr\r\n}, {\r\n.addr = priv->i2c_address,\r\n.flags = I2C_M_RD,\r\n.len = sizeof(status),\r\n.buf = status\r\n}\r\n};\r\nfor (i = 0; i < 2; i++) {\r\nret = i2c_transfer(priv->i2c, &msg[i], 1);\r\nif (ret >= 0 && ret != 1)\r\nret = -EIO;\r\nif (ret < 0) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): I2C transfer %d failed (%d)\n",\r\n__func__, i, ret);\r\nreturn ret;\r\n}\r\n}\r\nprint_hex_dump_bytes("lnbh25_read_vmon: ",\r\nDUMP_PREFIX_OFFSET, status, sizeof(status));\r\nif ((status[0] & (LNBH25_STATUS_OFL | LNBH25_STATUS_VMON)) != 0) {\r\ndev_err(&priv->i2c->dev,\r\n"%s(): voltage in failure state, status reg 0x%x\n",\r\n__func__, status[0]);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lnbh25_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage voltage)\r\n{\r\nint ret;\r\nu8 data1_reg;\r\nconst char *vsel;\r\nstruct lnbh25_priv *priv = fe->sec_priv;\r\nstruct i2c_msg msg = {\r\n.addr = priv->i2c_address,\r\n.flags = 0,\r\n.len = sizeof(priv->config),\r\n.buf = priv->config\r\n};\r\nswitch (voltage) {\r\ncase SEC_VOLTAGE_OFF:\r\ndata1_reg = 0x00;\r\nvsel = "Off";\r\nbreak;\r\ncase SEC_VOLTAGE_13:\r\ndata1_reg = LNBH25_VSEL_13;\r\nvsel = "13V";\r\nbreak;\r\ncase SEC_VOLTAGE_18:\r\ndata1_reg = LNBH25_VSEL_18;\r\nvsel = "18V";\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npriv->config[1] = data1_reg;\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): %s, I2C 0x%x write [ %02x %02x %02x ]\n",\r\n__func__, vsel, priv->i2c_address,\r\npriv->config[0], priv->config[1], priv->config[2]);\r\nret = i2c_transfer(priv->i2c, &msg, 1);\r\nif (ret >= 0 && ret != 1)\r\nret = -EIO;\r\nif (ret < 0) {\r\ndev_err(&priv->i2c->dev, "%s(): I2C transfer error (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nif (voltage != SEC_VOLTAGE_OFF) {\r\nmsleep(120);\r\nret = lnbh25_read_vmon(priv);\r\n} else {\r\nmsleep(20);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void lnbh25_release(struct dvb_frontend *fe)\r\n{\r\nstruct lnbh25_priv *priv = fe->sec_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nlnbh25_set_voltage(fe, SEC_VOLTAGE_OFF);\r\nkfree(fe->sec_priv);\r\nfe->sec_priv = NULL;\r\n}\r\nstruct dvb_frontend *lnbh25_attach(struct dvb_frontend *fe,\r\nstruct lnbh25_config *cfg,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct lnbh25_priv *priv;\r\ndev_dbg(&i2c->dev, "%s()\n", __func__);\r\npriv = kzalloc(sizeof(struct lnbh25_priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn NULL;\r\npriv->i2c_address = (cfg->i2c_address >> 1);\r\npriv->i2c = i2c;\r\npriv->config[0] = 0x02;\r\npriv->config[1] = 0x00;\r\npriv->config[2] = cfg->data2_config;\r\nfe->sec_priv = priv;\r\nif (lnbh25_set_voltage(fe, SEC_VOLTAGE_OFF)) {\r\ndev_err(&i2c->dev,\r\n"%s(): no LNBH25 found at I2C addr 0x%02x\n",\r\n__func__, priv->i2c_address);\r\nkfree(priv);\r\nfe->sec_priv = NULL;\r\nreturn NULL;\r\n}\r\nfe->ops.release_sec = lnbh25_release;\r\nfe->ops.set_voltage = lnbh25_set_voltage;\r\ndev_err(&i2c->dev, "%s(): attached at I2C addr 0x%02x\n",\r\n__func__, priv->i2c_address);\r\nreturn fe;\r\n}
