static int\r\nnfsd4_block_get_device_info_simple(struct super_block *sb,\r\nstruct nfsd4_getdeviceinfo *gdp)\r\n{\r\nstruct pnfs_block_deviceaddr *dev;\r\nstruct pnfs_block_volume *b;\r\ndev = kzalloc(sizeof(struct pnfs_block_deviceaddr) +\r\nsizeof(struct pnfs_block_volume), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ngdp->gd_device = dev;\r\ndev->nr_volumes = 1;\r\nb = &dev->volumes[0];\r\nb->type = PNFS_BLOCK_VOLUME_SIMPLE;\r\nb->simple.sig_len = PNFS_BLOCK_UUID_LEN;\r\nreturn sb->s_export_op->get_uuid(sb, b->simple.sig, &b->simple.sig_len,\r\n&b->simple.offset);\r\n}\r\nstatic __be32\r\nnfsd4_block_proc_getdeviceinfo(struct super_block *sb,\r\nstruct nfsd4_getdeviceinfo *gdp)\r\n{\r\nif (sb->s_bdev != sb->s_bdev->bd_contains)\r\nreturn nfserr_inval;\r\nreturn nfserrno(nfsd4_block_get_device_info_simple(sb, gdp));\r\n}\r\nstatic __be32\r\nnfsd4_block_proc_layoutget(struct inode *inode, const struct svc_fh *fhp,\r\nstruct nfsd4_layoutget *args)\r\n{\r\nstruct nfsd4_layout_seg *seg = &args->lg_seg;\r\nstruct super_block *sb = inode->i_sb;\r\nu32 block_size = (1 << inode->i_blkbits);\r\nstruct pnfs_block_extent *bex;\r\nstruct iomap iomap;\r\nu32 device_generation = 0;\r\nint error;\r\nif (seg->offset & (block_size - 1)) {\r\ndprintk("pnfsd: I/O misaligned\n");\r\ngoto out_layoutunavailable;\r\n}\r\nerror = -ENOMEM;\r\nbex = kzalloc(sizeof(*bex), GFP_KERNEL);\r\nif (!bex)\r\ngoto out_error;\r\nargs->lg_content = bex;\r\nerror = sb->s_export_op->map_blocks(inode, seg->offset, seg->length,\r\n&iomap, seg->iomode != IOMODE_READ,\r\n&device_generation);\r\nif (error) {\r\nif (error == -ENXIO)\r\ngoto out_layoutunavailable;\r\ngoto out_error;\r\n}\r\nif (iomap.length < args->lg_minlength) {\r\ndprintk("pnfsd: extent smaller than minlength\n");\r\ngoto out_layoutunavailable;\r\n}\r\nswitch (iomap.type) {\r\ncase IOMAP_MAPPED:\r\nif (seg->iomode == IOMODE_READ)\r\nbex->es = PNFS_BLOCK_READ_DATA;\r\nelse\r\nbex->es = PNFS_BLOCK_READWRITE_DATA;\r\nbex->soff = (iomap.blkno << 9);\r\nbreak;\r\ncase IOMAP_UNWRITTEN:\r\nif (seg->iomode & IOMODE_RW) {\r\nif (args->lg_minlength == 0) {\r\ndprintk("pnfsd: no soup for you!\n");\r\ngoto out_layoutunavailable;\r\n}\r\nbex->es = PNFS_BLOCK_INVALID_DATA;\r\nbex->soff = (iomap.blkno << 9);\r\nbreak;\r\n}\r\ncase IOMAP_HOLE:\r\nif (seg->iomode == IOMODE_READ) {\r\nbex->es = PNFS_BLOCK_NONE_DATA;\r\nbreak;\r\n}\r\ncase IOMAP_DELALLOC:\r\ndefault:\r\nWARN(1, "pnfsd: filesystem returned %d extent\n", iomap.type);\r\ngoto out_layoutunavailable;\r\n}\r\nerror = nfsd4_set_deviceid(&bex->vol_id, fhp, device_generation);\r\nif (error)\r\ngoto out_error;\r\nbex->foff = iomap.offset;\r\nbex->len = iomap.length;\r\nseg->offset = iomap.offset;\r\nseg->length = iomap.length;\r\ndprintk("GET: 0x%llx:0x%llx %d\n", bex->foff, bex->len, bex->es);\r\nreturn 0;\r\nout_error:\r\nseg->length = 0;\r\nreturn nfserrno(error);\r\nout_layoutunavailable:\r\nseg->length = 0;\r\nreturn nfserr_layoutunavailable;\r\n}\r\nstatic __be32\r\nnfsd4_block_proc_layoutcommit(struct inode *inode,\r\nstruct nfsd4_layoutcommit *lcp)\r\n{\r\nloff_t new_size = lcp->lc_last_wr + 1;\r\nstruct iattr iattr = { .ia_valid = 0 };\r\nstruct iomap *iomaps;\r\nint nr_iomaps;\r\nint error;\r\nnr_iomaps = nfsd4_block_decode_layoutupdate(lcp->lc_up_layout,\r\nlcp->lc_up_len, &iomaps, 1 << inode->i_blkbits);\r\nif (nr_iomaps < 0)\r\nreturn nfserrno(nr_iomaps);\r\nif (lcp->lc_mtime.tv_nsec == UTIME_NOW ||\r\ntimespec_compare(&lcp->lc_mtime, &inode->i_mtime) < 0)\r\nlcp->lc_mtime = current_fs_time(inode->i_sb);\r\niattr.ia_valid |= ATTR_ATIME | ATTR_CTIME | ATTR_MTIME;\r\niattr.ia_atime = iattr.ia_ctime = iattr.ia_mtime = lcp->lc_mtime;\r\nif (new_size > i_size_read(inode)) {\r\niattr.ia_valid |= ATTR_SIZE;\r\niattr.ia_size = new_size;\r\n}\r\nerror = inode->i_sb->s_export_op->commit_blocks(inode, iomaps,\r\nnr_iomaps, &iattr);\r\nkfree(iomaps);\r\nreturn nfserrno(error);\r\n}
