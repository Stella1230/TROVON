static const struct tcf_proto_ops *tcf_proto_lookup_ops(struct nlattr *kind)\r\n{\r\nconst struct tcf_proto_ops *t, *res = NULL;\r\nif (kind) {\r\nread_lock(&cls_mod_lock);\r\nlist_for_each_entry(t, &tcf_proto_base, head) {\r\nif (nla_strcmp(kind, t->kind) == 0) {\r\nif (try_module_get(t->owner))\r\nres = t;\r\nbreak;\r\n}\r\n}\r\nread_unlock(&cls_mod_lock);\r\n}\r\nreturn res;\r\n}\r\nint register_tcf_proto_ops(struct tcf_proto_ops *ops)\r\n{\r\nstruct tcf_proto_ops *t;\r\nint rc = -EEXIST;\r\nwrite_lock(&cls_mod_lock);\r\nlist_for_each_entry(t, &tcf_proto_base, head)\r\nif (!strcmp(ops->kind, t->kind))\r\ngoto out;\r\nlist_add_tail(&ops->head, &tcf_proto_base);\r\nrc = 0;\r\nout:\r\nwrite_unlock(&cls_mod_lock);\r\nreturn rc;\r\n}\r\nint unregister_tcf_proto_ops(struct tcf_proto_ops *ops)\r\n{\r\nstruct tcf_proto_ops *t;\r\nint rc = -ENOENT;\r\nrcu_barrier();\r\nwrite_lock(&cls_mod_lock);\r\nlist_for_each_entry(t, &tcf_proto_base, head) {\r\nif (t == ops) {\r\nlist_del(&t->head);\r\nrc = 0;\r\nbreak;\r\n}\r\n}\r\nwrite_unlock(&cls_mod_lock);\r\nreturn rc;\r\n}\r\nstatic inline u32 tcf_auto_prio(struct tcf_proto *tp)\r\n{\r\nu32 first = TC_H_MAKE(0xC0000000U, 0U);\r\nif (tp)\r\nfirst = tp->prio - 1;\r\nreturn first;\r\n}\r\nstatic int tc_ctl_tfilter(struct sk_buff *skb, struct nlmsghdr *n)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct nlattr *tca[TCA_MAX + 1];\r\nstruct tcmsg *t;\r\nu32 protocol;\r\nu32 prio;\r\nu32 nprio;\r\nu32 parent;\r\nstruct net_device *dev;\r\nstruct Qdisc *q;\r\nstruct tcf_proto __rcu **back;\r\nstruct tcf_proto __rcu **chain;\r\nstruct tcf_proto *tp;\r\nconst struct tcf_proto_ops *tp_ops;\r\nconst struct Qdisc_class_ops *cops;\r\nunsigned long cl;\r\nunsigned long fh;\r\nint err;\r\nint tp_created = 0;\r\nif ((n->nlmsg_type != RTM_GETTFILTER) &&\r\n!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nreplay:\r\nerr = nlmsg_parse(n, sizeof(*t), tca, TCA_MAX, NULL);\r\nif (err < 0)\r\nreturn err;\r\nt = nlmsg_data(n);\r\nprotocol = TC_H_MIN(t->tcm_info);\r\nprio = TC_H_MAJ(t->tcm_info);\r\nnprio = prio;\r\nparent = t->tcm_parent;\r\ncl = 0;\r\nif (prio == 0) {\r\nif (n->nlmsg_type != RTM_NEWTFILTER ||\r\n!(n->nlmsg_flags & NLM_F_CREATE))\r\nreturn -ENOENT;\r\nprio = TC_H_MAKE(0x80000000U, 0U);\r\n}\r\ndev = __dev_get_by_index(net, t->tcm_ifindex);\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nif (!parent) {\r\nq = dev->qdisc;\r\nparent = q->handle;\r\n} else {\r\nq = qdisc_lookup(dev, TC_H_MAJ(t->tcm_parent));\r\nif (q == NULL)\r\nreturn -EINVAL;\r\n}\r\ncops = q->ops->cl_ops;\r\nif (!cops)\r\nreturn -EINVAL;\r\nif (cops->tcf_chain == NULL)\r\nreturn -EOPNOTSUPP;\r\nif (TC_H_MIN(parent)) {\r\ncl = cops->get(q, parent);\r\nif (cl == 0)\r\nreturn -ENOENT;\r\n}\r\nchain = cops->tcf_chain(q, cl);\r\nerr = -EINVAL;\r\nif (chain == NULL)\r\ngoto errout;\r\nfor (back = chain;\r\n(tp = rtnl_dereference(*back)) != NULL;\r\nback = &tp->next) {\r\nif (tp->prio >= prio) {\r\nif (tp->prio == prio) {\r\nif (!nprio ||\r\n(tp->protocol != protocol && protocol))\r\ngoto errout;\r\n} else\r\ntp = NULL;\r\nbreak;\r\n}\r\n}\r\nif (tp == NULL) {\r\nif (tca[TCA_KIND] == NULL || !protocol)\r\ngoto errout;\r\nerr = -ENOENT;\r\nif (n->nlmsg_type != RTM_NEWTFILTER ||\r\n!(n->nlmsg_flags & NLM_F_CREATE))\r\ngoto errout;\r\nerr = -ENOBUFS;\r\ntp = kzalloc(sizeof(*tp), GFP_KERNEL);\r\nif (tp == NULL)\r\ngoto errout;\r\nerr = -ENOENT;\r\ntp_ops = tcf_proto_lookup_ops(tca[TCA_KIND]);\r\nif (tp_ops == NULL) {\r\n#ifdef CONFIG_MODULES\r\nstruct nlattr *kind = tca[TCA_KIND];\r\nchar name[IFNAMSIZ];\r\nif (kind != NULL &&\r\nnla_strlcpy(name, kind, IFNAMSIZ) < IFNAMSIZ) {\r\nrtnl_unlock();\r\nrequest_module("cls_%s", name);\r\nrtnl_lock();\r\ntp_ops = tcf_proto_lookup_ops(kind);\r\nif (tp_ops != NULL) {\r\nmodule_put(tp_ops->owner);\r\nerr = -EAGAIN;\r\n}\r\n}\r\n#endif\r\nkfree(tp);\r\ngoto errout;\r\n}\r\ntp->ops = tp_ops;\r\ntp->protocol = protocol;\r\ntp->prio = nprio ? :\r\nTC_H_MAJ(tcf_auto_prio(rtnl_dereference(*back)));\r\ntp->q = q;\r\ntp->classify = tp_ops->classify;\r\ntp->classid = parent;\r\nerr = tp_ops->init(tp);\r\nif (err != 0) {\r\nmodule_put(tp_ops->owner);\r\nkfree(tp);\r\ngoto errout;\r\n}\r\ntp_created = 1;\r\n} else if (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], tp->ops->kind))\r\ngoto errout;\r\nfh = tp->ops->get(tp, t->tcm_handle);\r\nif (fh == 0) {\r\nif (n->nlmsg_type == RTM_DELTFILTER && t->tcm_handle == 0) {\r\nstruct tcf_proto *next = rtnl_dereference(tp->next);\r\nRCU_INIT_POINTER(*back, next);\r\ntfilter_notify(net, skb, n, tp, fh, RTM_DELTFILTER);\r\ntcf_destroy(tp, true);\r\nerr = 0;\r\ngoto errout;\r\n}\r\nerr = -ENOENT;\r\nif (n->nlmsg_type != RTM_NEWTFILTER ||\r\n!(n->nlmsg_flags & NLM_F_CREATE))\r\ngoto errout;\r\n} else {\r\nswitch (n->nlmsg_type) {\r\ncase RTM_NEWTFILTER:\r\nerr = -EEXIST;\r\nif (n->nlmsg_flags & NLM_F_EXCL) {\r\nif (tp_created)\r\ntcf_destroy(tp, true);\r\ngoto errout;\r\n}\r\nbreak;\r\ncase RTM_DELTFILTER:\r\nerr = tp->ops->delete(tp, fh);\r\nif (err == 0) {\r\nstruct tcf_proto *next = rtnl_dereference(tp->next);\r\ntfilter_notify(net, skb, n, tp, fh, RTM_DELTFILTER);\r\nif (tcf_destroy(tp, false))\r\nRCU_INIT_POINTER(*back, next);\r\n}\r\ngoto errout;\r\ncase RTM_GETTFILTER:\r\nerr = tfilter_notify(net, skb, n, tp, fh, RTM_NEWTFILTER);\r\ngoto errout;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto errout;\r\n}\r\n}\r\nerr = tp->ops->change(net, skb, tp, cl, t->tcm_handle, tca, &fh,\r\nn->nlmsg_flags & NLM_F_CREATE ? TCA_ACT_NOREPLACE : TCA_ACT_REPLACE);\r\nif (err == 0) {\r\nif (tp_created) {\r\nRCU_INIT_POINTER(tp->next, rtnl_dereference(*back));\r\nrcu_assign_pointer(*back, tp);\r\n}\r\ntfilter_notify(net, skb, n, tp, fh, RTM_NEWTFILTER);\r\n} else {\r\nif (tp_created)\r\ntcf_destroy(tp, true);\r\n}\r\nerrout:\r\nif (cl)\r\ncops->put(q, cl);\r\nif (err == -EAGAIN)\r\ngoto replay;\r\nreturn err;\r\n}\r\nstatic int tcf_fill_node(struct net *net, struct sk_buff *skb, struct tcf_proto *tp,\r\nunsigned long fh, u32 portid, u32 seq, u16 flags, int event)\r\n{\r\nstruct tcmsg *tcm;\r\nstruct nlmsghdr *nlh;\r\nunsigned char *b = skb_tail_pointer(skb);\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*tcm), flags);\r\nif (!nlh)\r\ngoto out_nlmsg_trim;\r\ntcm = nlmsg_data(nlh);\r\ntcm->tcm_family = AF_UNSPEC;\r\ntcm->tcm__pad1 = 0;\r\ntcm->tcm__pad2 = 0;\r\ntcm->tcm_ifindex = qdisc_dev(tp->q)->ifindex;\r\ntcm->tcm_parent = tp->classid;\r\ntcm->tcm_info = TC_H_MAKE(tp->prio, tp->protocol);\r\nif (nla_put_string(skb, TCA_KIND, tp->ops->kind))\r\ngoto nla_put_failure;\r\ntcm->tcm_handle = fh;\r\nif (RTM_DELTFILTER != event) {\r\ntcm->tcm_handle = 0;\r\nif (tp->ops->dump && tp->ops->dump(net, tp, fh, skb, tcm) < 0)\r\ngoto nla_put_failure;\r\n}\r\nnlh->nlmsg_len = skb_tail_pointer(skb) - b;\r\nreturn skb->len;\r\nout_nlmsg_trim:\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int tfilter_notify(struct net *net, struct sk_buff *oskb,\r\nstruct nlmsghdr *n, struct tcf_proto *tp,\r\nunsigned long fh, int event)\r\n{\r\nstruct sk_buff *skb;\r\nu32 portid = oskb ? NETLINK_CB(oskb).portid : 0;\r\nskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOBUFS;\r\nif (tcf_fill_node(net, skb, tp, fh, portid, n->nlmsg_seq, 0, event) <= 0) {\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nreturn rtnetlink_send(skb, net, portid, RTNLGRP_TC,\r\nn->nlmsg_flags & NLM_F_ECHO);\r\n}\r\nstatic int tcf_node_dump(struct tcf_proto *tp, unsigned long n,\r\nstruct tcf_walker *arg)\r\n{\r\nstruct tcf_dump_args *a = (void *)arg;\r\nstruct net *net = sock_net(a->skb->sk);\r\nreturn tcf_fill_node(net, a->skb, tp, n, NETLINK_CB(a->cb->skb).portid,\r\na->cb->nlh->nlmsg_seq, NLM_F_MULTI, RTM_NEWTFILTER);\r\n}\r\nstatic int tc_dump_tfilter(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nint t;\r\nint s_t;\r\nstruct net_device *dev;\r\nstruct Qdisc *q;\r\nstruct tcf_proto *tp, __rcu **chain;\r\nstruct tcmsg *tcm = nlmsg_data(cb->nlh);\r\nunsigned long cl = 0;\r\nconst struct Qdisc_class_ops *cops;\r\nstruct tcf_dump_args arg;\r\nif (nlmsg_len(cb->nlh) < sizeof(*tcm))\r\nreturn skb->len;\r\ndev = __dev_get_by_index(net, tcm->tcm_ifindex);\r\nif (!dev)\r\nreturn skb->len;\r\nif (!tcm->tcm_parent)\r\nq = dev->qdisc;\r\nelse\r\nq = qdisc_lookup(dev, TC_H_MAJ(tcm->tcm_parent));\r\nif (!q)\r\ngoto out;\r\ncops = q->ops->cl_ops;\r\nif (!cops)\r\ngoto errout;\r\nif (cops->tcf_chain == NULL)\r\ngoto errout;\r\nif (TC_H_MIN(tcm->tcm_parent)) {\r\ncl = cops->get(q, tcm->tcm_parent);\r\nif (cl == 0)\r\ngoto errout;\r\n}\r\nchain = cops->tcf_chain(q, cl);\r\nif (chain == NULL)\r\ngoto errout;\r\ns_t = cb->args[0];\r\nfor (tp = rtnl_dereference(*chain), t = 0;\r\ntp; tp = rtnl_dereference(tp->next), t++) {\r\nif (t < s_t)\r\ncontinue;\r\nif (TC_H_MAJ(tcm->tcm_info) &&\r\nTC_H_MAJ(tcm->tcm_info) != tp->prio)\r\ncontinue;\r\nif (TC_H_MIN(tcm->tcm_info) &&\r\nTC_H_MIN(tcm->tcm_info) != tp->protocol)\r\ncontinue;\r\nif (t > s_t)\r\nmemset(&cb->args[1], 0, sizeof(cb->args)-sizeof(cb->args[0]));\r\nif (cb->args[1] == 0) {\r\nif (tcf_fill_node(net, skb, tp, 0, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI,\r\nRTM_NEWTFILTER) <= 0)\r\nbreak;\r\ncb->args[1] = 1;\r\n}\r\nif (tp->ops->walk == NULL)\r\ncontinue;\r\narg.w.fn = tcf_node_dump;\r\narg.skb = skb;\r\narg.cb = cb;\r\narg.w.stop = 0;\r\narg.w.skip = cb->args[1] - 1;\r\narg.w.count = 0;\r\ntp->ops->walk(tp, &arg.w);\r\ncb->args[1] = arg.w.count + 1;\r\nif (arg.w.stop)\r\nbreak;\r\n}\r\ncb->args[0] = t;\r\nerrout:\r\nif (cl)\r\ncops->put(q, cl);\r\nout:\r\nreturn skb->len;\r\n}\r\nvoid tcf_exts_destroy(struct tcf_exts *exts)\r\n{\r\n#ifdef CONFIG_NET_CLS_ACT\r\ntcf_action_destroy(&exts->actions, TCA_ACT_UNBIND);\r\nINIT_LIST_HEAD(&exts->actions);\r\n#endif\r\n}\r\nint tcf_exts_validate(struct net *net, struct tcf_proto *tp, struct nlattr **tb,\r\nstruct nlattr *rate_tlv, struct tcf_exts *exts, bool ovr)\r\n{\r\n#ifdef CONFIG_NET_CLS_ACT\r\n{\r\nstruct tc_action *act;\r\nINIT_LIST_HEAD(&exts->actions);\r\nif (exts->police && tb[exts->police]) {\r\nact = tcf_action_init_1(net, tb[exts->police], rate_tlv,\r\n"police", ovr,\r\nTCA_ACT_BIND);\r\nif (IS_ERR(act))\r\nreturn PTR_ERR(act);\r\nact->type = exts->type = TCA_OLD_COMPAT;\r\nlist_add(&act->list, &exts->actions);\r\n} else if (exts->action && tb[exts->action]) {\r\nint err;\r\nerr = tcf_action_init(net, tb[exts->action], rate_tlv,\r\nNULL, ovr,\r\nTCA_ACT_BIND, &exts->actions);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\n#else\r\nif ((exts->action && tb[exts->action]) ||\r\n(exts->police && tb[exts->police]))\r\nreturn -EOPNOTSUPP;\r\n#endif\r\nreturn 0;\r\n}\r\nvoid tcf_exts_change(struct tcf_proto *tp, struct tcf_exts *dst,\r\nstruct tcf_exts *src)\r\n{\r\n#ifdef CONFIG_NET_CLS_ACT\r\nLIST_HEAD(tmp);\r\ntcf_tree_lock(tp);\r\nlist_splice_init(&dst->actions, &tmp);\r\nlist_splice(&src->actions, &dst->actions);\r\ndst->type = src->type;\r\ntcf_tree_unlock(tp);\r\ntcf_action_destroy(&tmp, TCA_ACT_UNBIND);\r\n#endif\r\n}\r\nint tcf_exts_dump(struct sk_buff *skb, struct tcf_exts *exts)\r\n{\r\n#ifdef CONFIG_NET_CLS_ACT\r\nstruct nlattr *nest;\r\nif (exts->action && !list_empty(&exts->actions)) {\r\nif (exts->type != TCA_OLD_COMPAT) {\r\nnest = nla_nest_start(skb, exts->action);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (tcf_action_dump(skb, &exts->actions, 0, 0) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\n} else if (exts->police) {\r\nstruct tc_action *act = tcf_exts_first_act(exts);\r\nnest = nla_nest_start(skb, exts->police);\r\nif (nest == NULL || !act)\r\ngoto nla_put_failure;\r\nif (tcf_action_dump_old(skb, act, 0, 0) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\n}\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nest);\r\nreturn -1;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nint tcf_exts_dump_stats(struct sk_buff *skb, struct tcf_exts *exts)\r\n{\r\n#ifdef CONFIG_NET_CLS_ACT\r\nstruct tc_action *a = tcf_exts_first_act(exts);\r\nif (a != NULL && tcf_action_copy_stats(skb, a, 1) < 0)\r\nreturn -1;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __init tc_filter_init(void)\r\n{\r\nrtnl_register(PF_UNSPEC, RTM_NEWTFILTER, tc_ctl_tfilter, NULL, NULL);\r\nrtnl_register(PF_UNSPEC, RTM_DELTFILTER, tc_ctl_tfilter, NULL, NULL);\r\nrtnl_register(PF_UNSPEC, RTM_GETTFILTER, tc_ctl_tfilter,\r\ntc_dump_tfilter, NULL);\r\nreturn 0;\r\n}
