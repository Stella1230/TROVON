static void bnx2x_add_tlv(struct bnx2x *bp, void *tlvs_list,\r\nu16 offset, u16 type, u16 length)\r\n{\r\nstruct channel_tlv *tl =\r\n(struct channel_tlv *)(tlvs_list + offset);\r\ntl->type = type;\r\ntl->length = length;\r\n}\r\nstatic void bnx2x_vfpf_prep(struct bnx2x *bp, struct vfpf_first_tlv *first_tlv,\r\nu16 type, u16 length)\r\n{\r\nmutex_lock(&bp->vf2pf_mutex);\r\nDP(BNX2X_MSG_IOV, "preparing to send %d tlv over vf pf channel\n",\r\ntype);\r\nmemset(bp->vf2pf_mbox, 0, sizeof(struct bnx2x_vf_mbx_msg));\r\nbnx2x_add_tlv(bp, &first_tlv->tl, 0, type, length);\r\nfirst_tlv->resp_msg_offset = sizeof(bp->vf2pf_mbox->req);\r\n}\r\nstatic void bnx2x_vfpf_finalize(struct bnx2x *bp,\r\nstruct vfpf_first_tlv *first_tlv)\r\n{\r\nDP(BNX2X_MSG_IOV, "done sending [%d] tlv over vf pf channel\n",\r\nfirst_tlv->tl.type);\r\nmutex_unlock(&bp->vf2pf_mutex);\r\n}\r\nstatic void *bnx2x_search_tlv_list(struct bnx2x *bp, void *tlvs_list,\r\nenum channel_tlvs req_tlv)\r\n{\r\nstruct channel_tlv *tlv = (struct channel_tlv *)tlvs_list;\r\ndo {\r\nif (tlv->type == req_tlv)\r\nreturn tlv;\r\nif (!tlv->length) {\r\nBNX2X_ERR("Found TLV with length 0\n");\r\nreturn NULL;\r\n}\r\ntlvs_list += tlv->length;\r\ntlv = (struct channel_tlv *)tlvs_list;\r\n} while (tlv->type != CHANNEL_TLV_LIST_END);\r\nDP(BNX2X_MSG_IOV, "TLV list does not contain %d TLV\n", req_tlv);\r\nreturn NULL;\r\n}\r\nstatic void bnx2x_dp_tlv_list(struct bnx2x *bp, void *tlvs_list)\r\n{\r\nint i = 1;\r\nstruct channel_tlv *tlv = (struct channel_tlv *)tlvs_list;\r\nwhile (tlv->type != CHANNEL_TLV_LIST_END) {\r\nDP(BNX2X_MSG_IOV, "TLV number %d: type %d, length %d\n", i,\r\ntlv->type, tlv->length);\r\ntlvs_list += tlv->length;\r\ntlv = (struct channel_tlv *)tlvs_list;\r\ni++;\r\nif (i > MAX_TLVS_IN_LIST) {\r\nWARN(true, "corrupt tlvs");\r\nreturn;\r\n}\r\n}\r\nDP(BNX2X_MSG_IOV, "TLV number %d: type %d, length %d\n", i,\r\ntlv->type, tlv->length);\r\n}\r\nbool bnx2x_tlv_supported(u16 tlvtype)\r\n{\r\nreturn CHANNEL_TLV_NONE < tlvtype && tlvtype < CHANNEL_TLV_MAX;\r\n}\r\nstatic inline int bnx2x_pfvf_status_codes(int rc)\r\n{\r\nswitch (rc) {\r\ncase 0:\r\nreturn PFVF_STATUS_SUCCESS;\r\ncase -ENOMEM:\r\nreturn PFVF_STATUS_NO_RESOURCE;\r\ndefault:\r\nreturn PFVF_STATUS_FAILURE;\r\n}\r\n}\r\nstatic int bnx2x_send_msg2pf(struct bnx2x *bp, u8 *done, dma_addr_t msg_mapping)\r\n{\r\nstruct cstorm_vf_zone_data __iomem *zone_data =\r\nREG_ADDR(bp, PXP_VF_ADDR_CSDM_GLOBAL_START);\r\nint tout = 100, interval = 100;\r\nif (*done) {\r\nBNX2X_ERR("done was non zero before message to pf was sent\n");\r\nWARN_ON(true);\r\nreturn -EINVAL;\r\n}\r\nbnx2x_sample_bulletin(bp);\r\nif (bp->old_bulletin.valid_bitmap & 1 << CHANNEL_DOWN) {\r\nDP(BNX2X_MSG_IOV, "detecting channel down. Aborting message\n");\r\n*done = PFVF_STATUS_SUCCESS;\r\nreturn -EINVAL;\r\n}\r\nwritel(U64_LO(msg_mapping),\r\n&zone_data->non_trigger.vf_pf_channel.msg_addr_lo);\r\nwritel(U64_HI(msg_mapping),\r\n&zone_data->non_trigger.vf_pf_channel.msg_addr_hi);\r\nwmb();\r\nwriteb(1, &zone_data->trigger.vf_pf_channel.addr_valid);\r\nwhile ((tout >= 0) && (!*done)) {\r\nmsleep(interval);\r\ntout -= 1;\r\nDP_CONT(BNX2X_MSG_IOV, ".");\r\n}\r\nif (!*done) {\r\nBNX2X_ERR("PF response has timed out\n");\r\nreturn -EAGAIN;\r\n}\r\nDP(BNX2X_MSG_SP, "Got a response from PF\n");\r\nreturn 0;\r\n}\r\nstatic int bnx2x_get_vf_id(struct bnx2x *bp, u32 *vf_id)\r\n{\r\nu32 me_reg;\r\nint tout = 10, interval = 100;\r\ndo {\r\nme_reg = readl(bp->doorbells);\r\nif (GOOD_ME_REG(me_reg))\r\nbreak;\r\nmsleep(interval);\r\nBNX2X_ERR("Invalid ME register value: 0x%08x\n. Is pf driver up?",\r\nme_reg);\r\n} while (tout-- > 0);\r\nif (!GOOD_ME_REG(me_reg)) {\r\nBNX2X_ERR("Invalid ME register value: 0x%08x\n", me_reg);\r\nreturn -EINVAL;\r\n}\r\nDP(BNX2X_MSG_IOV, "valid ME register value: 0x%08x\n", me_reg);\r\n*vf_id = (me_reg & ME_REG_VF_NUM_MASK) >> ME_REG_VF_NUM_SHIFT;\r\nreturn 0;\r\n}\r\nint bnx2x_vfpf_acquire(struct bnx2x *bp, u8 tx_count, u8 rx_count)\r\n{\r\nint rc = 0, attempts = 0;\r\nstruct vfpf_acquire_tlv *req = &bp->vf2pf_mbox->req.acquire;\r\nstruct pfvf_acquire_resp_tlv *resp = &bp->vf2pf_mbox->resp.acquire_resp;\r\nstruct vfpf_port_phys_id_resp_tlv *phys_port_resp;\r\nstruct vfpf_fp_hsi_resp_tlv *fp_hsi_resp;\r\nu32 vf_id;\r\nbool resources_acquired = false;\r\nbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_ACQUIRE, sizeof(*req));\r\nif (bnx2x_get_vf_id(bp, &vf_id)) {\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nreq->vfdev_info.vf_id = vf_id;\r\nreq->vfdev_info.vf_os = 0;\r\nreq->vfdev_info.fp_hsi_ver = ETH_FP_HSI_VERSION;\r\nreq->resc_request.num_rxqs = rx_count;\r\nreq->resc_request.num_txqs = tx_count;\r\nreq->resc_request.num_sbs = bp->igu_sb_cnt;\r\nreq->resc_request.num_mac_filters = VF_ACQUIRE_MAC_FILTERS;\r\nreq->resc_request.num_mc_filters = VF_ACQUIRE_MC_FILTERS;\r\nreq->resc_request.num_vlan_filters = VF_ACQUIRE_VLAN_FILTERS;\r\nreq->bulletin_addr = bp->pf2vf_bulletin_mapping;\r\nbnx2x_add_tlv(bp, req, req->first_tlv.tl.length,\r\nCHANNEL_TLV_PHYS_PORT_ID, sizeof(struct channel_tlv));\r\nreq->vfdev_info.caps |= VF_CAP_SUPPORT_EXT_BULLETIN;\r\nreq->vfdev_info.caps |= VF_CAP_SUPPORT_VLAN_FILTER;\r\nbnx2x_add_tlv(bp, req,\r\nreq->first_tlv.tl.length + sizeof(struct channel_tlv),\r\nCHANNEL_TLV_LIST_END,\r\nsizeof(struct channel_list_end_tlv));\r\nbnx2x_dp_tlv_list(bp, req);\r\nwhile (!resources_acquired) {\r\nDP(BNX2X_MSG_SP, "attempting to acquire resources\n");\r\nrc = bnx2x_send_msg2pf(bp,\r\n&resp->hdr.status,\r\nbp->vf2pf_mbox_mapping);\r\nif (rc)\r\ngoto out;\r\nmemcpy(&bp->acquire_resp, resp, sizeof(bp->acquire_resp));\r\nattempts++;\r\nif (bp->acquire_resp.hdr.status == PFVF_STATUS_SUCCESS) {\r\nDP(BNX2X_MSG_SP, "resources acquired\n");\r\nresources_acquired = true;\r\n} else if (bp->acquire_resp.hdr.status ==\r\nPFVF_STATUS_NO_RESOURCE &&\r\nattempts < VF_ACQUIRE_THRESH) {\r\nDP(BNX2X_MSG_SP,\r\n"PF unwilling to fulfill resource request. Try PF recommended amount\n");\r\nreq->resc_request.num_txqs =\r\nmin(req->resc_request.num_txqs,\r\nbp->acquire_resp.resc.num_txqs);\r\nreq->resc_request.num_rxqs =\r\nmin(req->resc_request.num_rxqs,\r\nbp->acquire_resp.resc.num_rxqs);\r\nreq->resc_request.num_sbs =\r\nmin(req->resc_request.num_sbs,\r\nbp->acquire_resp.resc.num_sbs);\r\nreq->resc_request.num_mac_filters =\r\nmin(req->resc_request.num_mac_filters,\r\nbp->acquire_resp.resc.num_mac_filters);\r\nreq->resc_request.num_vlan_filters =\r\nmin(req->resc_request.num_vlan_filters,\r\nbp->acquire_resp.resc.num_vlan_filters);\r\nreq->resc_request.num_mc_filters =\r\nmin(req->resc_request.num_mc_filters,\r\nbp->acquire_resp.resc.num_mc_filters);\r\nmemset(&bp->vf2pf_mbox->resp, 0,\r\nsizeof(union pfvf_tlvs));\r\n} else {\r\nfp_hsi_resp = bnx2x_search_tlv_list(bp, resp,\r\nCHANNEL_TLV_FP_HSI_SUPPORT);\r\nif (fp_hsi_resp && !fp_hsi_resp->is_supported)\r\nBNX2X_ERR("Old hypervisor - doesn't support current fastpath HSI version; Need to downgrade VF driver [or upgrade hypervisor]\n");\r\nelse\r\nBNX2X_ERR("Failed to get the requested amount of resources: %d. Breaking...\n",\r\nbp->acquire_resp.hdr.status);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\n}\r\nphys_port_resp = (struct vfpf_port_phys_id_resp_tlv *)\r\nbnx2x_search_tlv_list(bp, resp,\r\nCHANNEL_TLV_PHYS_PORT_ID);\r\nif (phys_port_resp) {\r\nmemcpy(bp->phys_port_id, phys_port_resp->id, ETH_ALEN);\r\nbp->flags |= HAS_PHYS_PORT_ID;\r\n}\r\nfp_hsi_resp = bnx2x_search_tlv_list(bp, resp,\r\nCHANNEL_TLV_FP_HSI_SUPPORT);\r\nif (!fp_hsi_resp && (ETH_FP_HSI_VERSION > ETH_FP_HSI_VER_2)) {\r\nBNX2X_ERR("Old hypervisor - need to downgrade VF's driver\n");\r\nbnx2x_vfpf_finalize(bp, &req->first_tlv);\r\nbnx2x_vfpf_release(bp);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nbp->common.chip_id |= (bp->acquire_resp.pfdev_info.chip_num & 0xffff);\r\nbp->link_params.chip_id = bp->common.chip_id;\r\nbp->db_size = bp->acquire_resp.pfdev_info.db_size;\r\nbp->common.int_block = INT_BLOCK_IGU;\r\nbp->common.chip_port_mode = CHIP_2_PORT_MODE;\r\nbp->igu_dsb_id = -1;\r\nbp->mf_ov = 0;\r\nbp->mf_mode = 0;\r\nbp->common.flash_size = 0;\r\nbp->flags |=\r\nNO_WOL_FLAG | NO_ISCSI_OOO_FLAG | NO_ISCSI_FLAG | NO_FCOE_FLAG;\r\nbp->igu_sb_cnt = bp->acquire_resp.resc.num_sbs;\r\nbp->igu_base_sb = bp->acquire_resp.resc.hw_sbs[0].hw_sb_id;\r\nbp->vlan_credit = bp->acquire_resp.resc.num_vlan_filters;\r\nstrlcpy(bp->fw_ver, bp->acquire_resp.pfdev_info.fw_ver,\r\nsizeof(bp->fw_ver));\r\nif (is_valid_ether_addr(bp->acquire_resp.resc.current_mac_addr))\r\nmemcpy(bp->dev->dev_addr,\r\nbp->acquire_resp.resc.current_mac_addr,\r\nETH_ALEN);\r\nout:\r\nbnx2x_vfpf_finalize(bp, &req->first_tlv);\r\nreturn rc;\r\n}\r\nint bnx2x_vfpf_release(struct bnx2x *bp)\r\n{\r\nstruct vfpf_release_tlv *req = &bp->vf2pf_mbox->req.release;\r\nstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\r\nu32 rc, vf_id;\r\nbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_RELEASE, sizeof(*req));\r\nif (bnx2x_get_vf_id(bp, &vf_id)) {\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nreq->vf_id = vf_id;\r\nbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\r\nsizeof(struct channel_list_end_tlv));\r\nbnx2x_dp_tlv_list(bp, req);\r\nrc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\r\nif (rc)\r\ngoto out;\r\nif (resp->hdr.status == PFVF_STATUS_SUCCESS) {\r\nDP(BNX2X_MSG_SP, "vf released\n");\r\n} else {\r\nBNX2X_ERR("PF failed our release request - are we out of sync? Response status: %d\n",\r\nresp->hdr.status);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nout:\r\nbnx2x_vfpf_finalize(bp, &req->first_tlv);\r\nreturn rc;\r\n}\r\nint bnx2x_vfpf_init(struct bnx2x *bp)\r\n{\r\nstruct vfpf_init_tlv *req = &bp->vf2pf_mbox->req.init;\r\nstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\r\nint rc, i;\r\nbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_INIT, sizeof(*req));\r\nfor_each_eth_queue(bp, i)\r\nreq->sb_addr[i] = (dma_addr_t)bnx2x_fp(bp, i,\r\nstatus_blk_mapping);\r\nreq->stats_addr = bp->fw_stats_data_mapping +\r\noffsetof(struct bnx2x_fw_stats_data, queue_stats);\r\nreq->stats_stride = sizeof(struct per_queue_stats);\r\nbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\r\nsizeof(struct channel_list_end_tlv));\r\nbnx2x_dp_tlv_list(bp, req);\r\nrc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\r\nif (rc)\r\ngoto out;\r\nif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\r\nBNX2X_ERR("INIT VF failed: %d. Breaking...\n",\r\nresp->hdr.status);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nDP(BNX2X_MSG_SP, "INIT VF Succeeded\n");\r\nout:\r\nbnx2x_vfpf_finalize(bp, &req->first_tlv);\r\nreturn rc;\r\n}\r\nvoid bnx2x_vfpf_close_vf(struct bnx2x *bp)\r\n{\r\nstruct vfpf_close_tlv *req = &bp->vf2pf_mbox->req.close;\r\nstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\r\nint i, rc;\r\nu32 vf_id;\r\nif (bnx2x_get_vf_id(bp, &vf_id))\r\ngoto free_irq;\r\nfor_each_queue(bp, i)\r\nbnx2x_vfpf_teardown_queue(bp, i);\r\nbnx2x_vfpf_config_mac(bp, bp->dev->dev_addr, bp->fp->index, false);\r\nbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_CLOSE, sizeof(*req));\r\nreq->vf_id = vf_id;\r\nbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\r\nsizeof(struct channel_list_end_tlv));\r\nbnx2x_dp_tlv_list(bp, req);\r\nrc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\r\nif (rc)\r\nBNX2X_ERR("Sending CLOSE failed. rc was: %d\n", rc);\r\nelse if (resp->hdr.status != PFVF_STATUS_SUCCESS)\r\nBNX2X_ERR("Sending CLOSE failed: pf response was %d\n",\r\nresp->hdr.status);\r\nbnx2x_vfpf_finalize(bp, &req->first_tlv);\r\nfree_irq:\r\nbnx2x_netif_stop(bp, 0);\r\nbnx2x_del_all_napi(bp);\r\nbnx2x_free_irq(bp);\r\n}\r\nstatic void bnx2x_leading_vfq_init(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nstruct bnx2x_vf_queue *q)\r\n{\r\nu8 cl_id = vfq_cl_id(vf, q);\r\nu8 func_id = FW_VF_HANDLE(vf->abs_vfid);\r\nbnx2x_init_mac_obj(bp, &q->mac_obj,\r\ncl_id, q->cid, func_id,\r\nbnx2x_vf_sp(bp, vf, mac_rdata),\r\nbnx2x_vf_sp_map(bp, vf, mac_rdata),\r\nBNX2X_FILTER_MAC_PENDING,\r\n&vf->filter_state,\r\nBNX2X_OBJ_TYPE_RX_TX,\r\n&vf->vf_macs_pool);\r\nbnx2x_init_vlan_obj(bp, &q->vlan_obj,\r\ncl_id, q->cid, func_id,\r\nbnx2x_vf_sp(bp, vf, vlan_rdata),\r\nbnx2x_vf_sp_map(bp, vf, vlan_rdata),\r\nBNX2X_FILTER_VLAN_PENDING,\r\n&vf->filter_state,\r\nBNX2X_OBJ_TYPE_RX_TX,\r\n&vf->vf_vlans_pool);\r\nbnx2x_init_vlan_mac_obj(bp, &q->vlan_mac_obj,\r\ncl_id, q->cid, func_id,\r\nbnx2x_vf_sp(bp, vf, vlan_mac_rdata),\r\nbnx2x_vf_sp_map(bp, vf, vlan_mac_rdata),\r\nBNX2X_FILTER_VLAN_MAC_PENDING,\r\n&vf->filter_state,\r\nBNX2X_OBJ_TYPE_RX_TX,\r\n&vf->vf_macs_pool,\r\n&vf->vf_vlans_pool);\r\nbnx2x_init_mcast_obj(bp, &vf->mcast_obj, cl_id,\r\nq->cid, func_id, func_id,\r\nbnx2x_vf_sp(bp, vf, mcast_rdata),\r\nbnx2x_vf_sp_map(bp, vf, mcast_rdata),\r\nBNX2X_FILTER_MCAST_PENDING,\r\n&vf->filter_state,\r\nBNX2X_OBJ_TYPE_RX_TX);\r\nbnx2x_init_rss_config_obj(bp, &vf->rss_conf_obj, cl_id, q->cid,\r\nfunc_id, func_id,\r\nbnx2x_vf_sp(bp, vf, rss_rdata),\r\nbnx2x_vf_sp_map(bp, vf, rss_rdata),\r\nBNX2X_FILTER_RSS_CONF_PENDING,\r\n&vf->filter_state,\r\nBNX2X_OBJ_TYPE_RX_TX);\r\nvf->leading_rss = cl_id;\r\nq->is_leading = true;\r\nq->sp_initialized = true;\r\n}\r\nint bnx2x_vfpf_setup_q(struct bnx2x *bp, struct bnx2x_fastpath *fp,\r\nbool is_leading)\r\n{\r\nstruct vfpf_setup_q_tlv *req = &bp->vf2pf_mbox->req.setup_q;\r\nstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\r\nu8 fp_idx = fp->index;\r\nu16 tpa_agg_size = 0, flags = 0;\r\nint rc;\r\nbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_SETUP_Q, sizeof(*req));\r\nif (fp->mode != TPA_MODE_DISABLED) {\r\nflags |= VFPF_QUEUE_FLG_TPA;\r\nflags |= VFPF_QUEUE_FLG_TPA_IPV6;\r\nif (fp->mode == TPA_MODE_GRO)\r\nflags |= VFPF_QUEUE_FLG_TPA_GRO;\r\ntpa_agg_size = TPA_AGG_SIZE;\r\n}\r\nif (is_leading)\r\nflags |= VFPF_QUEUE_FLG_LEADING_RSS;\r\nflags |= VFPF_QUEUE_FLG_STATS;\r\nflags |= VFPF_QUEUE_FLG_CACHE_ALIGN;\r\nflags |= VFPF_QUEUE_FLG_VLAN;\r\nreq->vf_qid = fp_idx;\r\nreq->param_valid = VFPF_RXQ_VALID | VFPF_TXQ_VALID;\r\nreq->rxq.rcq_addr = fp->rx_comp_mapping;\r\nreq->rxq.rcq_np_addr = fp->rx_comp_mapping + BCM_PAGE_SIZE;\r\nreq->rxq.rxq_addr = fp->rx_desc_mapping;\r\nreq->rxq.sge_addr = fp->rx_sge_mapping;\r\nreq->rxq.vf_sb = fp_idx;\r\nreq->rxq.sb_index = HC_INDEX_ETH_RX_CQ_CONS;\r\nreq->rxq.hc_rate = bp->rx_ticks ? 1000000/bp->rx_ticks : 0;\r\nreq->rxq.mtu = bp->dev->mtu;\r\nreq->rxq.buf_sz = fp->rx_buf_size;\r\nreq->rxq.sge_buf_sz = BCM_PAGE_SIZE * PAGES_PER_SGE;\r\nreq->rxq.tpa_agg_sz = tpa_agg_size;\r\nreq->rxq.max_sge_pkt = SGE_PAGE_ALIGN(bp->dev->mtu) >> SGE_PAGE_SHIFT;\r\nreq->rxq.max_sge_pkt = ((req->rxq.max_sge_pkt + PAGES_PER_SGE - 1) &\r\n(~(PAGES_PER_SGE-1))) >> PAGES_PER_SGE_SHIFT;\r\nreq->rxq.flags = flags;\r\nreq->rxq.drop_flags = 0;\r\nreq->rxq.cache_line_log = BNX2X_RX_ALIGN_SHIFT;\r\nreq->rxq.stat_id = -1;\r\nreq->txq.txq_addr = fp->txdata_ptr[FIRST_TX_COS_INDEX]->tx_desc_mapping;\r\nreq->txq.vf_sb = fp_idx;\r\nreq->txq.sb_index = HC_INDEX_ETH_TX_CQ_CONS_COS0;\r\nreq->txq.hc_rate = bp->tx_ticks ? 1000000/bp->tx_ticks : 0;\r\nreq->txq.flags = flags;\r\nreq->txq.traffic_type = LLFC_TRAFFIC_TYPE_NW;\r\nbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\r\nsizeof(struct channel_list_end_tlv));\r\nbnx2x_dp_tlv_list(bp, req);\r\nrc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\r\nif (rc)\r\nBNX2X_ERR("Sending SETUP_Q message for queue[%d] failed!\n",\r\nfp_idx);\r\nif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\r\nBNX2X_ERR("Status of SETUP_Q for queue[%d] is %d\n",\r\nfp_idx, resp->hdr.status);\r\nrc = -EINVAL;\r\n}\r\nbnx2x_vfpf_finalize(bp, &req->first_tlv);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_vfpf_teardown_queue(struct bnx2x *bp, int qidx)\r\n{\r\nstruct vfpf_q_op_tlv *req = &bp->vf2pf_mbox->req.q_op;\r\nstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\r\nint rc;\r\nbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_TEARDOWN_Q,\r\nsizeof(*req));\r\nreq->vf_qid = qidx;\r\nbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\r\nsizeof(struct channel_list_end_tlv));\r\nbnx2x_dp_tlv_list(bp, req);\r\nrc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\r\nif (rc) {\r\nBNX2X_ERR("Sending TEARDOWN for queue %d failed: %d\n", qidx,\r\nrc);\r\ngoto out;\r\n}\r\nif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\r\nBNX2X_ERR("TEARDOWN for queue %d failed: %d\n", qidx,\r\nresp->hdr.status);\r\nrc = -EINVAL;\r\n}\r\nout:\r\nbnx2x_vfpf_finalize(bp, &req->first_tlv);\r\nreturn rc;\r\n}\r\nint bnx2x_vfpf_config_mac(struct bnx2x *bp, u8 *addr, u8 vf_qid, bool set)\r\n{\r\nstruct vfpf_set_q_filters_tlv *req = &bp->vf2pf_mbox->req.set_q_filters;\r\nstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\r\nstruct pf_vf_bulletin_content bulletin = bp->pf2vf_bulletin->content;\r\nint rc = 0;\r\nbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_SET_Q_FILTERS,\r\nsizeof(*req));\r\nreq->flags = VFPF_SET_Q_FILTERS_MAC_VLAN_CHANGED;\r\nreq->vf_qid = vf_qid;\r\nreq->n_mac_vlan_filters = 1;\r\nreq->filters[0].flags = VFPF_Q_FILTER_DEST_MAC_VALID;\r\nif (set)\r\nreq->filters[0].flags |= VFPF_Q_FILTER_SET;\r\nbnx2x_sample_bulletin(bp);\r\nmemcpy(req->filters[0].mac, addr, ETH_ALEN);\r\nbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\r\nsizeof(struct channel_list_end_tlv));\r\nbnx2x_dp_tlv_list(bp, req);\r\nrc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\r\nif (rc) {\r\nBNX2X_ERR("failed to send message to pf. rc was %d\n", rc);\r\ngoto out;\r\n}\r\nwhile (resp->hdr.status == PFVF_STATUS_FAILURE) {\r\nDP(BNX2X_MSG_IOV,\r\n"vfpf SET MAC failed. Check bulletin board for new posts\n");\r\nmemcpy(bp->dev->dev_addr, bulletin.mac, ETH_ALEN);\r\nif (bnx2x_sample_bulletin(bp) == PFVF_BULLETIN_UPDATED) {\r\nmemcpy(req->filters[0].mac, bp->dev->dev_addr,\r\nETH_ALEN);\r\nrc = bnx2x_send_msg2pf(bp, &resp->hdr.status,\r\nbp->vf2pf_mbox_mapping);\r\n} else {\r\nbreak;\r\n}\r\n}\r\nif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\r\nBNX2X_ERR("vfpf SET MAC failed: %d\n", resp->hdr.status);\r\nrc = -EINVAL;\r\n}\r\nout:\r\nbnx2x_vfpf_finalize(bp, &req->first_tlv);\r\nreturn rc;\r\n}\r\nint bnx2x_vfpf_config_rss(struct bnx2x *bp,\r\nstruct bnx2x_config_rss_params *params)\r\n{\r\nstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\r\nstruct vfpf_rss_tlv *req = &bp->vf2pf_mbox->req.update_rss;\r\nint rc = 0;\r\nbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_UPDATE_RSS,\r\nsizeof(*req));\r\nbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\r\nsizeof(struct channel_list_end_tlv));\r\nmemcpy(req->ind_table, params->ind_table, T_ETH_INDIRECTION_TABLE_SIZE);\r\nmemcpy(req->rss_key, params->rss_key, sizeof(params->rss_key));\r\nreq->ind_table_size = T_ETH_INDIRECTION_TABLE_SIZE;\r\nreq->rss_key_size = T_ETH_RSS_KEY;\r\nreq->rss_result_mask = params->rss_result_mask;\r\nif (params->rss_flags & (1 << BNX2X_RSS_MODE_DISABLED))\r\nreq->rss_flags |= VFPF_RSS_MODE_DISABLED;\r\nif (params->rss_flags & (1 << BNX2X_RSS_MODE_REGULAR))\r\nreq->rss_flags |= VFPF_RSS_MODE_REGULAR;\r\nif (params->rss_flags & (1 << BNX2X_RSS_SET_SRCH))\r\nreq->rss_flags |= VFPF_RSS_SET_SRCH;\r\nif (params->rss_flags & (1 << BNX2X_RSS_IPV4))\r\nreq->rss_flags |= VFPF_RSS_IPV4;\r\nif (params->rss_flags & (1 << BNX2X_RSS_IPV4_TCP))\r\nreq->rss_flags |= VFPF_RSS_IPV4_TCP;\r\nif (params->rss_flags & (1 << BNX2X_RSS_IPV4_UDP))\r\nreq->rss_flags |= VFPF_RSS_IPV4_UDP;\r\nif (params->rss_flags & (1 << BNX2X_RSS_IPV6))\r\nreq->rss_flags |= VFPF_RSS_IPV6;\r\nif (params->rss_flags & (1 << BNX2X_RSS_IPV6_TCP))\r\nreq->rss_flags |= VFPF_RSS_IPV6_TCP;\r\nif (params->rss_flags & (1 << BNX2X_RSS_IPV6_UDP))\r\nreq->rss_flags |= VFPF_RSS_IPV6_UDP;\r\nDP(BNX2X_MSG_IOV, "rss flags %x\n", req->rss_flags);\r\nbnx2x_dp_tlv_list(bp, req);\r\nrc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\r\nif (rc) {\r\nBNX2X_ERR("failed to send message to pf. rc was %d\n", rc);\r\ngoto out;\r\n}\r\nif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\r\nDP(BNX2X_MSG_IOV,\r\n"Failed to send rss message to PF over VF-PF channel [%d]\n",\r\nresp->hdr.status);\r\n}\r\nout:\r\nbnx2x_vfpf_finalize(bp, &req->first_tlv);\r\nreturn rc;\r\n}\r\nint bnx2x_vfpf_set_mcast(struct net_device *dev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nstruct vfpf_set_q_filters_tlv *req = &bp->vf2pf_mbox->req.set_q_filters;\r\nstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\r\nint rc, i = 0;\r\nstruct netdev_hw_addr *ha;\r\nif (bp->state != BNX2X_STATE_OPEN) {\r\nDP(NETIF_MSG_IFUP, "state is %x, returning\n", bp->state);\r\nreturn -EINVAL;\r\n}\r\nbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_SET_Q_FILTERS,\r\nsizeof(*req));\r\nDP(NETIF_MSG_IFUP, "dev->flags = %x\n", dev->flags);\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nDP(NETIF_MSG_IFUP, "Adding mcast MAC: %pM\n",\r\nbnx2x_mc_addr(ha));\r\nmemcpy(req->multicast[i], bnx2x_mc_addr(ha), ETH_ALEN);\r\ni++;\r\n}\r\nif (i >= PFVF_MAX_MULTICAST_PER_VF) {\r\nDP(NETIF_MSG_IFUP,\r\n"VF supports not more than %d multicast MAC addresses\n",\r\nPFVF_MAX_MULTICAST_PER_VF);\r\nreturn -EINVAL;\r\n}\r\nreq->n_multicast = i;\r\nreq->flags |= VFPF_SET_Q_FILTERS_MULTICAST_CHANGED;\r\nreq->vf_qid = 0;\r\nbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\r\nsizeof(struct channel_list_end_tlv));\r\nbnx2x_dp_tlv_list(bp, req);\r\nrc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\r\nif (rc) {\r\nBNX2X_ERR("Sending a message failed: %d\n", rc);\r\ngoto out;\r\n}\r\nif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\r\nBNX2X_ERR("Set Rx mode/multicast failed: %d\n",\r\nresp->hdr.status);\r\nrc = -EINVAL;\r\n}\r\nout:\r\nbnx2x_vfpf_finalize(bp, &req->first_tlv);\r\nreturn 0;\r\n}\r\nint bnx2x_vfpf_update_vlan(struct bnx2x *bp, u16 vid, u8 vf_qid, bool add)\r\n{\r\nstruct vfpf_set_q_filters_tlv *req = &bp->vf2pf_mbox->req.set_q_filters;\r\nstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\r\nint rc = 0;\r\nif (!(bp->acquire_resp.pfdev_info.pf_cap & PFVF_CAP_VLAN_FILTER)) {\r\nDP(BNX2X_MSG_IOV, "HV does not support vlan filtering\n");\r\nreturn 0;\r\n}\r\nbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_SET_Q_FILTERS,\r\nsizeof(*req));\r\nreq->flags = VFPF_SET_Q_FILTERS_MAC_VLAN_CHANGED;\r\nreq->vf_qid = vf_qid;\r\nreq->n_mac_vlan_filters = 1;\r\nreq->filters[0].flags = VFPF_Q_FILTER_VLAN_TAG_VALID;\r\nif (add)\r\nreq->filters[0].flags |= VFPF_Q_FILTER_SET;\r\nbnx2x_sample_bulletin(bp);\r\nif (bp->shadow_bulletin.content.valid_bitmap & 1 << VLAN_VALID) {\r\nBNX2X_ERR("Hypervisor will dicline the request, avoiding\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nreq->filters[0].vlan_tag = vid;\r\nbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\r\nsizeof(struct channel_list_end_tlv));\r\nbnx2x_dp_tlv_list(bp, req);\r\nrc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\r\nif (rc) {\r\nBNX2X_ERR("failed to send message to pf. rc was %d\n", rc);\r\ngoto out;\r\n}\r\nif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\r\nBNX2X_ERR("vfpf %s VLAN %d failed\n", add ? "add" : "del",\r\nvid);\r\nrc = -EINVAL;\r\n}\r\nout:\r\nbnx2x_vfpf_finalize(bp, &req->first_tlv);\r\nreturn rc;\r\n}\r\nint bnx2x_vfpf_storm_rx_mode(struct bnx2x *bp)\r\n{\r\nint mode = bp->rx_mode;\r\nstruct vfpf_set_q_filters_tlv *req = &bp->vf2pf_mbox->req.set_q_filters;\r\nstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\r\nint rc;\r\nbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_SET_Q_FILTERS,\r\nsizeof(*req));\r\nDP(NETIF_MSG_IFUP, "Rx mode is %d\n", mode);\r\nif (mode == BNX2X_RX_MODE_NONE) {\r\nreq->rx_mask = VFPF_RX_MASK_ACCEPT_NONE;\r\n} else {\r\nreq->rx_mask = VFPF_RX_MASK_ACCEPT_MATCHED_MULTICAST;\r\nreq->rx_mask |= VFPF_RX_MASK_ACCEPT_MATCHED_UNICAST;\r\nreq->rx_mask |= VFPF_RX_MASK_ACCEPT_BROADCAST;\r\nif (mode == BNX2X_RX_MODE_PROMISC)\r\nreq->rx_mask |= VFPF_RX_MASK_ACCEPT_ANY_VLAN;\r\n}\r\nif (bp->accept_any_vlan)\r\nreq->rx_mask |= VFPF_RX_MASK_ACCEPT_ANY_VLAN;\r\nreq->flags |= VFPF_SET_Q_FILTERS_RX_MASK_CHANGED;\r\nreq->vf_qid = 0;\r\nbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\r\nsizeof(struct channel_list_end_tlv));\r\nbnx2x_dp_tlv_list(bp, req);\r\nrc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\r\nif (rc)\r\nBNX2X_ERR("Sending a message failed: %d\n", rc);\r\nif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\r\nBNX2X_ERR("Set Rx mode failed: %d\n", resp->hdr.status);\r\nrc = -EINVAL;\r\n}\r\nbnx2x_vfpf_finalize(bp, &req->first_tlv);\r\nreturn rc;\r\n}\r\nstatic void storm_memset_vf_mbx_ack(struct bnx2x *bp, u16 abs_fid)\r\n{\r\nu32 addr = BAR_CSTRORM_INTMEM +\r\nCSTORM_VF_PF_CHANNEL_STATE_OFFSET(abs_fid);\r\nREG_WR8(bp, addr, VF_PF_CHANNEL_STATE_READY);\r\n}\r\nstatic void storm_memset_vf_mbx_valid(struct bnx2x *bp, u16 abs_fid)\r\n{\r\nu32 addr = BAR_CSTRORM_INTMEM +\r\nCSTORM_VF_PF_CHANNEL_VALID_OFFSET(abs_fid);\r\nREG_WR8(bp, addr, 1);\r\n}\r\nvoid bnx2x_vf_enable_mbx(struct bnx2x *bp, u8 abs_vfid)\r\n{\r\nbnx2x_vf_flr_clnup_epilog(bp, abs_vfid);\r\nstorm_memset_vf_mbx_ack(bp, abs_vfid);\r\nstorm_memset_vf_mbx_valid(bp, abs_vfid);\r\nbnx2x_vf_enable_access(bp, abs_vfid);\r\n}\r\nstatic int bnx2x_copy32_vf_dmae(struct bnx2x *bp, u8 from_vf,\r\ndma_addr_t pf_addr, u8 vfid, u32 vf_addr_hi,\r\nu32 vf_addr_lo, u32 len32)\r\n{\r\nstruct dmae_command dmae;\r\nif (CHIP_IS_E1x(bp)) {\r\nBNX2X_ERR("Chip revision does not support VFs\n");\r\nreturn DMAE_NOT_RDY;\r\n}\r\nif (!bp->dmae_ready) {\r\nBNX2X_ERR("DMAE is not ready, can not copy\n");\r\nreturn DMAE_NOT_RDY;\r\n}\r\nbnx2x_prep_dmae_with_comp(bp, &dmae, DMAE_SRC_PCI, DMAE_DST_PCI);\r\nif (from_vf) {\r\ndmae.opcode_iov = (vfid << DMAE_COMMAND_SRC_VFID_SHIFT) |\r\n(DMAE_SRC_VF << DMAE_COMMAND_SRC_VFPF_SHIFT) |\r\n(DMAE_DST_PF << DMAE_COMMAND_DST_VFPF_SHIFT);\r\ndmae.opcode |= (DMAE_C_DST << DMAE_COMMAND_C_FUNC_SHIFT);\r\ndmae.src_addr_lo = vf_addr_lo;\r\ndmae.src_addr_hi = vf_addr_hi;\r\ndmae.dst_addr_lo = U64_LO(pf_addr);\r\ndmae.dst_addr_hi = U64_HI(pf_addr);\r\n} else {\r\ndmae.opcode_iov = (vfid << DMAE_COMMAND_DST_VFID_SHIFT) |\r\n(DMAE_DST_VF << DMAE_COMMAND_DST_VFPF_SHIFT) |\r\n(DMAE_SRC_PF << DMAE_COMMAND_SRC_VFPF_SHIFT);\r\ndmae.opcode |= (DMAE_C_SRC << DMAE_COMMAND_C_FUNC_SHIFT);\r\ndmae.src_addr_lo = U64_LO(pf_addr);\r\ndmae.src_addr_hi = U64_HI(pf_addr);\r\ndmae.dst_addr_lo = vf_addr_lo;\r\ndmae.dst_addr_hi = vf_addr_hi;\r\n}\r\ndmae.len = len32;\r\nreturn bnx2x_issue_dmae_with_comp(bp, &dmae, bnx2x_sp(bp, wb_comp));\r\n}\r\nstatic void bnx2x_vf_mbx_resp_single_tlv(struct bnx2x *bp,\r\nstruct bnx2x_virtf *vf)\r\n{\r\nstruct bnx2x_vf_mbx *mbx = BP_VF_MBX(bp, vf->index);\r\nu16 length, type;\r\ntype = mbx->first_tlv.tl.type;\r\nlength = type == CHANNEL_TLV_ACQUIRE ?\r\nsizeof(struct pfvf_acquire_resp_tlv) :\r\nsizeof(struct pfvf_general_resp_tlv);\r\nbnx2x_add_tlv(bp, &mbx->msg->resp, 0, type, length);\r\nbnx2x_add_tlv(bp, &mbx->msg->resp, length, CHANNEL_TLV_LIST_END,\r\nsizeof(struct channel_list_end_tlv));\r\n}\r\nstatic void bnx2x_vf_mbx_resp_send_msg(struct bnx2x *bp,\r\nstruct bnx2x_virtf *vf,\r\nint vf_rc)\r\n{\r\nstruct bnx2x_vf_mbx *mbx = BP_VF_MBX(bp, vf->index);\r\nstruct pfvf_general_resp_tlv *resp = &mbx->msg->resp.general_resp;\r\ndma_addr_t pf_addr;\r\nu64 vf_addr;\r\nint rc;\r\nbnx2x_dp_tlv_list(bp, resp);\r\nDP(BNX2X_MSG_IOV, "mailbox vf address hi 0x%x, lo 0x%x, offset 0x%x\n",\r\nmbx->vf_addr_hi, mbx->vf_addr_lo, mbx->first_tlv.resp_msg_offset);\r\nresp->hdr.status = bnx2x_pfvf_status_codes(vf_rc);\r\nvf_addr = HILO_U64(mbx->vf_addr_hi, mbx->vf_addr_lo) +\r\nmbx->first_tlv.resp_msg_offset;\r\npf_addr = mbx->msg_mapping +\r\noffsetof(struct bnx2x_vf_mbx_msg, resp);\r\nvf_addr += sizeof(u64);\r\npf_addr += sizeof(u64);\r\nrc = bnx2x_copy32_vf_dmae(bp, false, pf_addr, vf->abs_vfid,\r\nU64_HI(vf_addr),\r\nU64_LO(vf_addr),\r\n(sizeof(union pfvf_tlvs) - sizeof(u64))/4);\r\nif (rc) {\r\nBNX2X_ERR("Failed to copy response body to VF %d\n",\r\nvf->abs_vfid);\r\ngoto mbx_error;\r\n}\r\nvf_addr -= sizeof(u64);\r\npf_addr -= sizeof(u64);\r\nstorm_memset_vf_mbx_ack(bp, vf->abs_vfid);\r\nmmiowb();\r\nrc = bnx2x_copy32_vf_dmae(bp, false, pf_addr, vf->abs_vfid,\r\nU64_HI(vf_addr),\r\nU64_LO(vf_addr),\r\nsizeof(u64)/4);\r\nbnx2x_unlock_vf_pf_channel(bp, vf, mbx->first_tlv.tl.type);\r\nif (rc) {\r\nBNX2X_ERR("Failed to copy response status to VF %d\n",\r\nvf->abs_vfid);\r\ngoto mbx_error;\r\n}\r\nreturn;\r\nmbx_error:\r\nbnx2x_vf_release(bp, vf);\r\n}\r\nstatic void bnx2x_vf_mbx_resp(struct bnx2x *bp,\r\nstruct bnx2x_virtf *vf,\r\nint rc)\r\n{\r\nbnx2x_vf_mbx_resp_single_tlv(bp, vf);\r\nbnx2x_vf_mbx_resp_send_msg(bp, vf, rc);\r\n}\r\nstatic void bnx2x_vf_mbx_resp_phys_port(struct bnx2x *bp,\r\nstruct bnx2x_virtf *vf,\r\nvoid *buffer,\r\nu16 *offset)\r\n{\r\nstruct vfpf_port_phys_id_resp_tlv *port_id;\r\nif (!(bp->flags & HAS_PHYS_PORT_ID))\r\nreturn;\r\nbnx2x_add_tlv(bp, buffer, *offset, CHANNEL_TLV_PHYS_PORT_ID,\r\nsizeof(struct vfpf_port_phys_id_resp_tlv));\r\nport_id = (struct vfpf_port_phys_id_resp_tlv *)\r\n(((u8 *)buffer) + *offset);\r\nmemcpy(port_id->id, bp->phys_port_id, ETH_ALEN);\r\n*offset += sizeof(struct vfpf_port_phys_id_resp_tlv);\r\n}\r\nstatic void bnx2x_vf_mbx_resp_fp_hsi_ver(struct bnx2x *bp,\r\nstruct bnx2x_virtf *vf,\r\nvoid *buffer,\r\nu16 *offset)\r\n{\r\nstruct vfpf_fp_hsi_resp_tlv *fp_hsi;\r\nbnx2x_add_tlv(bp, buffer, *offset, CHANNEL_TLV_FP_HSI_SUPPORT,\r\nsizeof(struct vfpf_fp_hsi_resp_tlv));\r\nfp_hsi = (struct vfpf_fp_hsi_resp_tlv *)\r\n(((u8 *)buffer) + *offset);\r\nfp_hsi->is_supported = (vf->fp_hsi > ETH_FP_HSI_VERSION) ? 0 : 1;\r\n*offset += sizeof(struct vfpf_fp_hsi_resp_tlv);\r\n}\r\nstatic void bnx2x_vf_mbx_acquire_resp(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nstruct bnx2x_vf_mbx *mbx, int vfop_status)\r\n{\r\nint i;\r\nstruct pfvf_acquire_resp_tlv *resp = &mbx->msg->resp.acquire_resp;\r\nstruct pf_vf_resc *resc = &resp->resc;\r\nu8 status = bnx2x_pfvf_status_codes(vfop_status);\r\nu16 length;\r\nmemset(resp, 0, sizeof(*resp));\r\nresp->pfdev_info.chip_num = bp->common.chip_id;\r\nresp->pfdev_info.db_size = bp->db_size;\r\nresp->pfdev_info.indices_per_sb = HC_SB_MAX_INDICES_E2;\r\nresp->pfdev_info.pf_cap = (PFVF_CAP_RSS |\r\nPFVF_CAP_TPA |\r\nPFVF_CAP_TPA_UPDATE |\r\nPFVF_CAP_VLAN_FILTER);\r\nbnx2x_fill_fw_str(bp, resp->pfdev_info.fw_ver,\r\nsizeof(resp->pfdev_info.fw_ver));\r\nif (status == PFVF_STATUS_NO_RESOURCE ||\r\nstatus == PFVF_STATUS_SUCCESS) {\r\nresc->num_rxqs = vf_rxq_count(vf) ? :\r\nbnx2x_vf_max_queue_cnt(bp, vf);\r\nresc->num_txqs = vf_txq_count(vf) ? :\r\nbnx2x_vf_max_queue_cnt(bp, vf);\r\nresc->num_sbs = vf_sb_count(vf);\r\nresc->num_mac_filters = vf_mac_rules_cnt(vf);\r\nresc->num_vlan_filters = vf_vlan_rules_cnt(vf);\r\nresc->num_mc_filters = 0;\r\nif (status == PFVF_STATUS_SUCCESS) {\r\nstruct pf_vf_bulletin_content *bulletin =\r\nBP_VF_BULLETIN(bp, vf->index);\r\nfor_each_vfq(vf, i)\r\nresc->hw_qid[i] =\r\nvfq_qzone_id(vf, vfq_get(vf, i));\r\nfor_each_vf_sb(vf, i) {\r\nresc->hw_sbs[i].hw_sb_id = vf_igu_sb(vf, i);\r\nresc->hw_sbs[i].sb_qid = vf_hc_qzone(vf, i);\r\n}\r\nif (bulletin->valid_bitmap & 1 << MAC_ADDR_VALID) {\r\nmemcpy(resc->current_mac_addr, bulletin->mac,\r\nETH_ALEN);\r\n}\r\n}\r\n}\r\nDP(BNX2X_MSG_IOV, "VF[%d] ACQUIRE_RESPONSE: pfdev_info- chip_num=0x%x, db_size=%d, idx_per_sb=%d, pf_cap=0x%x\n"\r\n"resources- n_rxq-%d, n_txq-%d, n_sbs-%d, n_macs-%d, n_vlans-%d, n_mcs-%d, fw_ver: '%s'\n",\r\nvf->abs_vfid,\r\nresp->pfdev_info.chip_num,\r\nresp->pfdev_info.db_size,\r\nresp->pfdev_info.indices_per_sb,\r\nresp->pfdev_info.pf_cap,\r\nresc->num_rxqs,\r\nresc->num_txqs,\r\nresc->num_sbs,\r\nresc->num_mac_filters,\r\nresc->num_vlan_filters,\r\nresc->num_mc_filters,\r\nresp->pfdev_info.fw_ver);\r\nDP_CONT(BNX2X_MSG_IOV, "hw_qids- [ ");\r\nfor (i = 0; i < vf_rxq_count(vf); i++)\r\nDP_CONT(BNX2X_MSG_IOV, "%d ", resc->hw_qid[i]);\r\nDP_CONT(BNX2X_MSG_IOV, "], sb_info- [ ");\r\nfor (i = 0; i < vf_sb_count(vf); i++)\r\nDP_CONT(BNX2X_MSG_IOV, "%d:%d ",\r\nresc->hw_sbs[i].hw_sb_id,\r\nresc->hw_sbs[i].sb_qid);\r\nDP_CONT(BNX2X_MSG_IOV, "]\n");\r\nlength = sizeof(struct pfvf_acquire_resp_tlv);\r\nbnx2x_add_tlv(bp, &mbx->msg->resp, 0, CHANNEL_TLV_ACQUIRE, length);\r\nif (bnx2x_search_tlv_list(bp, &mbx->msg->req,\r\nCHANNEL_TLV_PHYS_PORT_ID))\r\nbnx2x_vf_mbx_resp_phys_port(bp, vf, &mbx->msg->resp, &length);\r\nbnx2x_vf_mbx_resp_fp_hsi_ver(bp, vf, &mbx->msg->resp, &length);\r\nbnx2x_add_tlv(bp, &mbx->msg->resp, length, CHANNEL_TLV_LIST_END,\r\nsizeof(struct channel_list_end_tlv));\r\nbnx2x_vf_mbx_resp_send_msg(bp, vf, vfop_status);\r\n}\r\nstatic bool bnx2x_vf_mbx_is_windows_vm(struct bnx2x *bp,\r\nstruct vfpf_acquire_tlv *acquire)\r\n{\r\nif (!acquire->bulletin_addr ||\r\nacquire->resc_request.num_mc_filters == 32 ||\r\n((acquire->vfdev_info.vf_os & VF_OS_MASK) ==\r\nVF_OS_WINDOWS))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int bnx2x_vf_mbx_acquire_chk_dorq(struct bnx2x *bp,\r\nstruct bnx2x_virtf *vf,\r\nstruct bnx2x_vf_mbx *mbx)\r\n{\r\nif (bnx2x_search_tlv_list(bp, &mbx->msg->req,\r\nCHANNEL_TLV_PHYS_PORT_ID))\r\nreturn 0;\r\nif (bnx2x_vf_mbx_is_windows_vm(bp, &mbx->msg->req.acquire))\r\nreturn 0;\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void bnx2x_vf_mbx_acquire(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nstruct bnx2x_vf_mbx *mbx)\r\n{\r\nint rc;\r\nstruct vfpf_acquire_tlv *acquire = &mbx->msg->req.acquire;\r\nDP(BNX2X_MSG_IOV,\r\n"VF[%d] ACQUIRE: vfdev_info- vf_id %d, vf_os %d resources- n_rxq-%d, n_txq-%d, n_sbs-%d, n_macs-%d, n_vlans-%d, n_mcs-%d\n",\r\nvf->abs_vfid, acquire->vfdev_info.vf_id, acquire->vfdev_info.vf_os,\r\nacquire->resc_request.num_rxqs, acquire->resc_request.num_txqs,\r\nacquire->resc_request.num_sbs, acquire->resc_request.num_mac_filters,\r\nacquire->resc_request.num_vlan_filters,\r\nacquire->resc_request.num_mc_filters);\r\nrc = bnx2x_vf_mbx_acquire_chk_dorq(bp, vf, mbx);\r\nif (rc) {\r\nDP(BNX2X_MSG_IOV,\r\n"VF [%d] - Can't support acquire request due to doorbell mismatch. Please update VM driver\n",\r\nvf->abs_vfid);\r\ngoto out;\r\n}\r\nif (bnx2x_vf_mbx_is_windows_vm(bp, &mbx->msg->req.acquire))\r\nvf->fp_hsi = acquire->vfdev_info.fp_hsi_ver;\r\nelse\r\nvf->fp_hsi = max_t(u8, acquire->vfdev_info.fp_hsi_ver,\r\nETH_FP_HSI_VER_2);\r\nif (vf->fp_hsi > ETH_FP_HSI_VERSION) {\r\nDP(BNX2X_MSG_IOV,\r\n"VF [%d] - Can't support acquire request since VF requests a FW version which is too new [%02x > %02x]\n",\r\nvf->abs_vfid, acquire->vfdev_info.fp_hsi_ver,\r\nETH_FP_HSI_VERSION);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = bnx2x_vf_acquire(bp, vf, &acquire->resc_request);\r\nvf->bulletin_map = acquire->bulletin_addr;\r\nif (acquire->vfdev_info.caps & VF_CAP_SUPPORT_EXT_BULLETIN) {\r\nDP(BNX2X_MSG_IOV, "VF[%d] supports long bulletin boards\n",\r\nvf->abs_vfid);\r\nvf->cfg_flags |= VF_CFG_EXT_BULLETIN;\r\n} else {\r\nvf->cfg_flags &= ~VF_CFG_EXT_BULLETIN;\r\n}\r\nif (acquire->vfdev_info.caps & VF_CAP_SUPPORT_VLAN_FILTER) {\r\nDP(BNX2X_MSG_IOV, "VF[%d] supports vlan filtering\n",\r\nvf->abs_vfid);\r\nvf->cfg_flags |= VF_CFG_VLAN_FILTER;\r\n} else {\r\nvf->cfg_flags &= ~VF_CFG_VLAN_FILTER;\r\n}\r\nout:\r\nbnx2x_vf_mbx_acquire_resp(bp, vf, mbx, rc);\r\n}\r\nstatic void bnx2x_vf_mbx_init_vf(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nstruct bnx2x_vf_mbx *mbx)\r\n{\r\nstruct vfpf_init_tlv *init = &mbx->msg->req.init;\r\nint rc;\r\nvf->fw_stat_map = init->stats_addr;\r\nvf->stats_stride = init->stats_stride;\r\nrc = bnx2x_vf_init(bp, vf, (dma_addr_t *)init->sb_addr);\r\nif (init->flags & VFPF_INIT_FLG_STATS_COALESCE)\r\nvf->cfg_flags |= VF_CFG_STATS_COALESCE;\r\nif (vf->cfg_flags & VF_CFG_EXT_BULLETIN)\r\nbnx2x_iov_link_update_vf(bp, vf->index);\r\nbnx2x_vf_mbx_resp(bp, vf, rc);\r\n}\r\nstatic void bnx2x_vf_mbx_set_q_flags(struct bnx2x *bp, u32 mbx_q_flags,\r\nunsigned long *sp_q_flags)\r\n{\r\nif (mbx_q_flags & VFPF_QUEUE_FLG_TPA)\r\n__set_bit(BNX2X_Q_FLG_TPA, sp_q_flags);\r\nif (mbx_q_flags & VFPF_QUEUE_FLG_TPA_IPV6)\r\n__set_bit(BNX2X_Q_FLG_TPA_IPV6, sp_q_flags);\r\nif (mbx_q_flags & VFPF_QUEUE_FLG_TPA_GRO)\r\n__set_bit(BNX2X_Q_FLG_TPA_GRO, sp_q_flags);\r\nif (mbx_q_flags & VFPF_QUEUE_FLG_STATS)\r\n__set_bit(BNX2X_Q_FLG_STATS, sp_q_flags);\r\nif (mbx_q_flags & VFPF_QUEUE_FLG_VLAN)\r\n__set_bit(BNX2X_Q_FLG_VLAN, sp_q_flags);\r\nif (mbx_q_flags & VFPF_QUEUE_FLG_COS)\r\n__set_bit(BNX2X_Q_FLG_COS, sp_q_flags);\r\nif (mbx_q_flags & VFPF_QUEUE_FLG_HC)\r\n__set_bit(BNX2X_Q_FLG_HC, sp_q_flags);\r\nif (mbx_q_flags & VFPF_QUEUE_FLG_DHC)\r\n__set_bit(BNX2X_Q_FLG_DHC, sp_q_flags);\r\nif (mbx_q_flags & VFPF_QUEUE_FLG_LEADING_RSS)\r\n__set_bit(BNX2X_Q_FLG_LEADING_RSS, sp_q_flags);\r\nif (IS_MF_SD(bp))\r\n__set_bit(BNX2X_Q_FLG_OV, sp_q_flags);\r\n}\r\nstatic void bnx2x_vf_mbx_setup_q(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nstruct bnx2x_vf_mbx *mbx)\r\n{\r\nstruct vfpf_setup_q_tlv *setup_q = &mbx->msg->req.setup_q;\r\nstruct bnx2x_vf_queue_construct_params qctor;\r\nint rc = 0;\r\nif (setup_q->vf_qid >= vf_rxq_count(vf)) {\r\nBNX2X_ERR("vf_qid %d invalid, max queue count is %d\n",\r\nsetup_q->vf_qid, vf_rxq_count(vf));\r\nrc = -EINVAL;\r\ngoto response;\r\n}\r\nif (setup_q->param_valid & (VFPF_RXQ_VALID|VFPF_TXQ_VALID)) {\r\nstruct bnx2x_vf_queue *q = vfq_get(vf, setup_q->vf_qid);\r\nunsigned long q_type = 0;\r\nstruct bnx2x_queue_init_params *init_p;\r\nstruct bnx2x_queue_setup_params *setup_p;\r\nif (bnx2x_vfq_is_leading(q))\r\nbnx2x_leading_vfq_init(bp, vf, q);\r\nmemset(&qctor, 0 ,\r\nsizeof(struct bnx2x_vf_queue_construct_params));\r\nsetup_p = &qctor.prep_qsetup;\r\ninit_p = &qctor.qstate.params.init;\r\n__set_bit(BNX2X_Q_FLG_ACTIVE, &setup_p->flags);\r\nif (setup_q->param_valid & VFPF_TXQ_VALID) {\r\nstruct bnx2x_txq_setup_params *txq_params =\r\n&setup_p->txq_params;\r\n__set_bit(BNX2X_Q_TYPE_HAS_TX, &q_type);\r\nq->sb_idx = setup_q->txq.vf_sb;\r\ninit_p->tx.hc_rate = setup_q->txq.hc_rate;\r\ninit_p->tx.sb_cq_index = setup_q->txq.sb_index;\r\nbnx2x_vf_mbx_set_q_flags(bp, setup_q->txq.flags,\r\n&init_p->tx.flags);\r\nbnx2x_vf_mbx_set_q_flags(bp, setup_q->txq.flags,\r\n&setup_p->flags);\r\ntxq_params->dscr_map = setup_q->txq.txq_addr;\r\ntxq_params->sb_cq_index = setup_q->txq.sb_index;\r\ntxq_params->traffic_type = setup_q->txq.traffic_type;\r\nbnx2x_vfop_qctor_dump_tx(bp, vf, init_p, setup_p,\r\nq->index, q->sb_idx);\r\n}\r\nif (setup_q->param_valid & VFPF_RXQ_VALID) {\r\nstruct bnx2x_rxq_setup_params *rxq_params =\r\n&setup_p->rxq_params;\r\n__set_bit(BNX2X_Q_TYPE_HAS_RX, &q_type);\r\nq->sb_idx = setup_q->rxq.vf_sb;\r\ninit_p->rx.hc_rate = setup_q->rxq.hc_rate;\r\ninit_p->rx.sb_cq_index = setup_q->rxq.sb_index;\r\nbnx2x_vf_mbx_set_q_flags(bp, setup_q->rxq.flags,\r\n&init_p->rx.flags);\r\nbnx2x_vf_mbx_set_q_flags(bp, setup_q->rxq.flags,\r\n&setup_p->flags);\r\nsetup_p->gen_params.mtu = setup_q->rxq.mtu;\r\nrxq_params->drop_flags = setup_q->rxq.drop_flags;\r\nrxq_params->dscr_map = setup_q->rxq.rxq_addr;\r\nrxq_params->sge_map = setup_q->rxq.sge_addr;\r\nrxq_params->rcq_map = setup_q->rxq.rcq_addr;\r\nrxq_params->rcq_np_map = setup_q->rxq.rcq_np_addr;\r\nrxq_params->buf_sz = setup_q->rxq.buf_sz;\r\nrxq_params->tpa_agg_sz = setup_q->rxq.tpa_agg_sz;\r\nrxq_params->max_sges_pkt = setup_q->rxq.max_sge_pkt;\r\nrxq_params->sge_buf_sz = setup_q->rxq.sge_buf_sz;\r\nrxq_params->cache_line_log =\r\nsetup_q->rxq.cache_line_log;\r\nrxq_params->sb_cq_index = setup_q->rxq.sb_index;\r\nif (bnx2x_vfq_is_leading(q)) {\r\nu8 mcast_id = FW_VF_HANDLE(vf->abs_vfid);\r\nrxq_params->mcast_engine_id = mcast_id;\r\n__set_bit(BNX2X_Q_FLG_MCAST, &setup_p->flags);\r\n}\r\nbnx2x_vfop_qctor_dump_rx(bp, vf, init_p, setup_p,\r\nq->index, q->sb_idx);\r\n}\r\nbnx2x_vfop_qctor_prep(bp, vf, q, &qctor, q_type);\r\nrc = bnx2x_vf_queue_setup(bp, vf, q->index, &qctor);\r\nif (rc)\r\ngoto response;\r\n}\r\nresponse:\r\nbnx2x_vf_mbx_resp(bp, vf, rc);\r\n}\r\nstatic int bnx2x_vf_mbx_macvlan_list(struct bnx2x *bp,\r\nstruct bnx2x_virtf *vf,\r\nstruct vfpf_set_q_filters_tlv *tlv,\r\nstruct bnx2x_vf_mac_vlan_filters **pfl,\r\nu32 type_flag)\r\n{\r\nint i, j;\r\nstruct bnx2x_vf_mac_vlan_filters *fl = NULL;\r\nsize_t fsz;\r\nfsz = tlv->n_mac_vlan_filters *\r\nsizeof(struct bnx2x_vf_mac_vlan_filter) +\r\nsizeof(struct bnx2x_vf_mac_vlan_filters);\r\nfl = kzalloc(fsz, GFP_KERNEL);\r\nif (!fl)\r\nreturn -ENOMEM;\r\nfor (i = 0, j = 0; i < tlv->n_mac_vlan_filters; i++) {\r\nstruct vfpf_q_mac_vlan_filter *msg_filter = &tlv->filters[i];\r\nif ((msg_filter->flags & type_flag) != type_flag)\r\ncontinue;\r\nmemset(&fl->filters[j], 0, sizeof(fl->filters[j]));\r\nif (type_flag & VFPF_Q_FILTER_DEST_MAC_VALID) {\r\nfl->filters[j].mac = msg_filter->mac;\r\nfl->filters[j].type |= BNX2X_VF_FILTER_MAC;\r\n}\r\nif (type_flag & VFPF_Q_FILTER_VLAN_TAG_VALID) {\r\nfl->filters[j].vid = msg_filter->vlan_tag;\r\nfl->filters[j].type |= BNX2X_VF_FILTER_VLAN;\r\n}\r\nfl->filters[j].add = !!(msg_filter->flags & VFPF_Q_FILTER_SET);\r\nfl->count++;\r\nj++;\r\n}\r\nif (!fl->count)\r\nkfree(fl);\r\nelse\r\n*pfl = fl;\r\nreturn 0;\r\n}\r\nstatic int bnx2x_vf_filters_contain(struct vfpf_set_q_filters_tlv *filters,\r\nu32 flags)\r\n{\r\nint i, cnt = 0;\r\nfor (i = 0; i < filters->n_mac_vlan_filters; i++)\r\nif ((filters->filters[i].flags & flags) == flags)\r\ncnt++;\r\nreturn cnt;\r\n}\r\nstatic void bnx2x_vf_mbx_dp_q_filter(struct bnx2x *bp, int msglvl, int idx,\r\nstruct vfpf_q_mac_vlan_filter *filter)\r\n{\r\nDP(msglvl, "MAC-VLAN[%d] -- flags=0x%x\n", idx, filter->flags);\r\nif (filter->flags & VFPF_Q_FILTER_VLAN_TAG_VALID)\r\nDP_CONT(msglvl, ", vlan=%d", filter->vlan_tag);\r\nif (filter->flags & VFPF_Q_FILTER_DEST_MAC_VALID)\r\nDP_CONT(msglvl, ", MAC=%pM", filter->mac);\r\nDP_CONT(msglvl, "\n");\r\n}\r\nstatic void bnx2x_vf_mbx_dp_q_filters(struct bnx2x *bp, int msglvl,\r\nstruct vfpf_set_q_filters_tlv *filters)\r\n{\r\nint i;\r\nif (filters->flags & VFPF_SET_Q_FILTERS_MAC_VLAN_CHANGED)\r\nfor (i = 0; i < filters->n_mac_vlan_filters; i++)\r\nbnx2x_vf_mbx_dp_q_filter(bp, msglvl, i,\r\n&filters->filters[i]);\r\nif (filters->flags & VFPF_SET_Q_FILTERS_RX_MASK_CHANGED)\r\nDP(msglvl, "RX-MASK=0x%x\n", filters->rx_mask);\r\nif (filters->flags & VFPF_SET_Q_FILTERS_MULTICAST_CHANGED)\r\nfor (i = 0; i < filters->n_multicast; i++)\r\nDP(msglvl, "MULTICAST=%pM\n", filters->multicast[i]);\r\n}\r\nstatic int bnx2x_vf_mbx_qfilters(struct bnx2x *bp, struct bnx2x_virtf *vf)\r\n{\r\nint rc = 0;\r\nstruct vfpf_set_q_filters_tlv *msg =\r\n&BP_VF_MBX(bp, vf->index)->msg->req.set_q_filters;\r\nif (msg->flags & VFPF_SET_Q_FILTERS_MAC_VLAN_CHANGED) {\r\nstruct bnx2x_vf_mac_vlan_filters *fl = NULL;\r\nrc = bnx2x_vf_mbx_macvlan_list(bp, vf, msg, &fl,\r\nVFPF_VLAN_MAC_FILTER);\r\nif (rc)\r\ngoto op_err;\r\nif (fl) {\r\nrc = bnx2x_vf_mac_vlan_config_list(bp, vf, fl,\r\nmsg->vf_qid,\r\nfalse);\r\nif (rc)\r\ngoto op_err;\r\n}\r\nfl = NULL;\r\nrc = bnx2x_vf_mbx_macvlan_list(bp, vf, msg, &fl,\r\nVFPF_MAC_FILTER);\r\nif (rc)\r\ngoto op_err;\r\nif (fl) {\r\nrc = bnx2x_vf_mac_vlan_config_list(bp, vf, fl,\r\nmsg->vf_qid,\r\nfalse);\r\nif (rc)\r\ngoto op_err;\r\n}\r\n}\r\nif (msg->flags & VFPF_SET_Q_FILTERS_RX_MASK_CHANGED) {\r\nunsigned long accept = 0;\r\nstruct pf_vf_bulletin_content *bulletin =\r\nBP_VF_BULLETIN(bp, vf->index);\r\nif (msg->rx_mask != VFPF_RX_MASK_ACCEPT_NONE) {\r\n__set_bit(BNX2X_ACCEPT_UNICAST, &accept);\r\n__set_bit(BNX2X_ACCEPT_MULTICAST, &accept);\r\n__set_bit(BNX2X_ACCEPT_BROADCAST, &accept);\r\n}\r\nif (!(bulletin->valid_bitmap & (1 << VLAN_VALID)) &&\r\n(!(vf->cfg_flags & VF_CFG_VLAN_FILTER) ||\r\nmsg->rx_mask & VFPF_RX_MASK_ACCEPT_ANY_VLAN))\r\n__set_bit(BNX2X_ACCEPT_ANY_VLAN, &accept);\r\nrc = bnx2x_vf_rxmode(bp, vf, msg->vf_qid, accept);\r\nif (rc)\r\ngoto op_err;\r\n}\r\nif (msg->flags & VFPF_SET_Q_FILTERS_MULTICAST_CHANGED) {\r\nrc = bnx2x_vf_mcast(bp, vf, msg->multicast,\r\nmsg->n_multicast, false);\r\nif (rc)\r\ngoto op_err;\r\n}\r\nop_err:\r\nif (rc)\r\nBNX2X_ERR("QFILTERS[%d:%d] error: rc %d\n",\r\nvf->abs_vfid, msg->vf_qid, rc);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_filters_validate_mac(struct bnx2x *bp,\r\nstruct bnx2x_virtf *vf,\r\nstruct vfpf_set_q_filters_tlv *filters)\r\n{\r\nstruct pf_vf_bulletin_content *bulletin = BP_VF_BULLETIN(bp, vf->index);\r\nint rc = 0;\r\nif (bulletin->valid_bitmap & 1 << MAC_ADDR_VALID) {\r\nstruct vfpf_q_mac_vlan_filter *filter = NULL;\r\nint i;\r\nfor (i = 0; i < filters->n_mac_vlan_filters; i++) {\r\nif (!(filters->filters[i].flags &\r\nVFPF_Q_FILTER_DEST_MAC_VALID))\r\ncontinue;\r\nif (filter) {\r\nBNX2X_ERR("VF[%d] requested the addition of multiple macs after set_vf_mac ndo was called [%d filters]\n",\r\nvf->abs_vfid,\r\nfilters->n_mac_vlan_filters);\r\nrc = -EPERM;\r\ngoto response;\r\n}\r\nfilter = &filters->filters[i];\r\n}\r\nif (filter &&\r\n!ether_addr_equal(filter->mac, bulletin->mac)) {\r\nBNX2X_ERR("VF[%d] requested the addition of a mac address not matching the one configured by set_vf_mac ndo\n",\r\nvf->abs_vfid);\r\nrc = -EPERM;\r\ngoto response;\r\n}\r\n}\r\nresponse:\r\nreturn rc;\r\n}\r\nstatic int bnx2x_filters_validate_vlan(struct bnx2x *bp,\r\nstruct bnx2x_virtf *vf,\r\nstruct vfpf_set_q_filters_tlv *filters)\r\n{\r\nstruct pf_vf_bulletin_content *bulletin = BP_VF_BULLETIN(bp, vf->index);\r\nint rc = 0;\r\nif (bulletin->valid_bitmap & 1 << VLAN_VALID) {\r\nif (bnx2x_vf_filters_contain(filters,\r\nVFPF_Q_FILTER_VLAN_TAG_VALID)) {\r\nBNX2X_ERR("VF[%d] attempted to configure vlan but one was already set by Hypervisor. Aborting request\n",\r\nvf->abs_vfid);\r\nrc = -EPERM;\r\ngoto response;\r\n}\r\n}\r\nif (filters->vf_qid > vf_rxq_count(vf)) {\r\nrc = -EPERM;\r\ngoto response;\r\n}\r\nresponse:\r\nreturn rc;\r\n}\r\nstatic void bnx2x_vf_mbx_set_q_filters(struct bnx2x *bp,\r\nstruct bnx2x_virtf *vf,\r\nstruct bnx2x_vf_mbx *mbx)\r\n{\r\nstruct vfpf_set_q_filters_tlv *filters = &mbx->msg->req.set_q_filters;\r\nint rc;\r\nrc = bnx2x_filters_validate_mac(bp, vf, filters);\r\nif (rc)\r\ngoto response;\r\nrc = bnx2x_filters_validate_vlan(bp, vf, filters);\r\nif (rc)\r\ngoto response;\r\nDP(BNX2X_MSG_IOV, "VF[%d] Q_FILTERS: queue[%d]\n",\r\nvf->abs_vfid,\r\nfilters->vf_qid);\r\nbnx2x_vf_mbx_dp_q_filters(bp, BNX2X_MSG_IOV, filters);\r\nrc = bnx2x_vf_mbx_qfilters(bp, vf);\r\nresponse:\r\nbnx2x_vf_mbx_resp(bp, vf, rc);\r\n}\r\nstatic void bnx2x_vf_mbx_teardown_q(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nstruct bnx2x_vf_mbx *mbx)\r\n{\r\nint qid = mbx->msg->req.q_op.vf_qid;\r\nint rc;\r\nDP(BNX2X_MSG_IOV, "VF[%d] Q_TEARDOWN: vf_qid=%d\n",\r\nvf->abs_vfid, qid);\r\nrc = bnx2x_vf_queue_teardown(bp, vf, qid);\r\nbnx2x_vf_mbx_resp(bp, vf, rc);\r\n}\r\nstatic void bnx2x_vf_mbx_close_vf(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nstruct bnx2x_vf_mbx *mbx)\r\n{\r\nint rc;\r\nDP(BNX2X_MSG_IOV, "VF[%d] VF_CLOSE\n", vf->abs_vfid);\r\nrc = bnx2x_vf_close(bp, vf);\r\nbnx2x_vf_mbx_resp(bp, vf, rc);\r\n}\r\nstatic void bnx2x_vf_mbx_release_vf(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nstruct bnx2x_vf_mbx *mbx)\r\n{\r\nint rc;\r\nDP(BNX2X_MSG_IOV, "VF[%d] VF_RELEASE\n", vf->abs_vfid);\r\nrc = bnx2x_vf_free(bp, vf);\r\nbnx2x_vf_mbx_resp(bp, vf, rc);\r\n}\r\nstatic void bnx2x_vf_mbx_update_rss(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nstruct bnx2x_vf_mbx *mbx)\r\n{\r\nstruct bnx2x_config_rss_params rss;\r\nstruct vfpf_rss_tlv *rss_tlv = &mbx->msg->req.update_rss;\r\nint rc = 0;\r\nif (rss_tlv->ind_table_size != T_ETH_INDIRECTION_TABLE_SIZE ||\r\nrss_tlv->rss_key_size != T_ETH_RSS_KEY) {\r\nBNX2X_ERR("failing rss configuration of vf %d due to size mismatch\n",\r\nvf->index);\r\nrc = -EINVAL;\r\ngoto mbx_resp;\r\n}\r\nmemset(&rss, 0, sizeof(struct bnx2x_config_rss_params));\r\nmemcpy(rss.ind_table, rss_tlv->ind_table,\r\nT_ETH_INDIRECTION_TABLE_SIZE);\r\nmemcpy(rss.rss_key, rss_tlv->rss_key, sizeof(rss_tlv->rss_key));\r\nrss.rss_obj = &vf->rss_conf_obj;\r\nrss.rss_result_mask = rss_tlv->rss_result_mask;\r\nrss.rss_flags = 0;\r\nrss.ramrod_flags = 0;\r\nif (rss_tlv->rss_flags & VFPF_RSS_MODE_DISABLED)\r\n__set_bit(BNX2X_RSS_MODE_DISABLED, &rss.rss_flags);\r\nif (rss_tlv->rss_flags & VFPF_RSS_MODE_REGULAR)\r\n__set_bit(BNX2X_RSS_MODE_REGULAR, &rss.rss_flags);\r\nif (rss_tlv->rss_flags & VFPF_RSS_SET_SRCH)\r\n__set_bit(BNX2X_RSS_SET_SRCH, &rss.rss_flags);\r\nif (rss_tlv->rss_flags & VFPF_RSS_IPV4)\r\n__set_bit(BNX2X_RSS_IPV4, &rss.rss_flags);\r\nif (rss_tlv->rss_flags & VFPF_RSS_IPV4_TCP)\r\n__set_bit(BNX2X_RSS_IPV4_TCP, &rss.rss_flags);\r\nif (rss_tlv->rss_flags & VFPF_RSS_IPV4_UDP)\r\n__set_bit(BNX2X_RSS_IPV4_UDP, &rss.rss_flags);\r\nif (rss_tlv->rss_flags & VFPF_RSS_IPV6)\r\n__set_bit(BNX2X_RSS_IPV6, &rss.rss_flags);\r\nif (rss_tlv->rss_flags & VFPF_RSS_IPV6_TCP)\r\n__set_bit(BNX2X_RSS_IPV6_TCP, &rss.rss_flags);\r\nif (rss_tlv->rss_flags & VFPF_RSS_IPV6_UDP)\r\n__set_bit(BNX2X_RSS_IPV6_UDP, &rss.rss_flags);\r\nif ((!(rss_tlv->rss_flags & VFPF_RSS_IPV4_TCP) &&\r\nrss_tlv->rss_flags & VFPF_RSS_IPV4_UDP) ||\r\n(!(rss_tlv->rss_flags & VFPF_RSS_IPV6_TCP) &&\r\nrss_tlv->rss_flags & VFPF_RSS_IPV6_UDP)) {\r\nBNX2X_ERR("about to hit a FW assert. aborting...\n");\r\nrc = -EINVAL;\r\ngoto mbx_resp;\r\n}\r\nrc = bnx2x_vf_rss_update(bp, vf, &rss);\r\nmbx_resp:\r\nbnx2x_vf_mbx_resp(bp, vf, rc);\r\n}\r\nstatic int bnx2x_validate_tpa_params(struct bnx2x *bp,\r\nstruct vfpf_tpa_tlv *tpa_tlv)\r\n{\r\nint rc = 0;\r\nif (tpa_tlv->tpa_client_info.max_sges_for_packet >\r\nU_ETH_MAX_SGES_FOR_PACKET) {\r\nrc = -EINVAL;\r\nBNX2X_ERR("TPA update: max_sges received %d, max is %d\n",\r\ntpa_tlv->tpa_client_info.max_sges_for_packet,\r\nU_ETH_MAX_SGES_FOR_PACKET);\r\n}\r\nif (tpa_tlv->tpa_client_info.max_tpa_queues > MAX_AGG_QS(bp)) {\r\nrc = -EINVAL;\r\nBNX2X_ERR("TPA update: max_tpa_queues received %d, max is %d\n",\r\ntpa_tlv->tpa_client_info.max_tpa_queues,\r\nMAX_AGG_QS(bp));\r\n}\r\nreturn rc;\r\n}\r\nstatic void bnx2x_vf_mbx_update_tpa(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nstruct bnx2x_vf_mbx *mbx)\r\n{\r\nstruct bnx2x_queue_update_tpa_params vf_op_params;\r\nstruct vfpf_tpa_tlv *tpa_tlv = &mbx->msg->req.update_tpa;\r\nint rc = 0;\r\nmemset(&vf_op_params, 0, sizeof(vf_op_params));\r\nif (bnx2x_validate_tpa_params(bp, tpa_tlv))\r\ngoto mbx_resp;\r\nvf_op_params.complete_on_both_clients =\r\ntpa_tlv->tpa_client_info.complete_on_both_clients;\r\nvf_op_params.dont_verify_thr =\r\ntpa_tlv->tpa_client_info.dont_verify_thr;\r\nvf_op_params.max_agg_sz =\r\ntpa_tlv->tpa_client_info.max_agg_size;\r\nvf_op_params.max_sges_pkt =\r\ntpa_tlv->tpa_client_info.max_sges_for_packet;\r\nvf_op_params.max_tpa_queues =\r\ntpa_tlv->tpa_client_info.max_tpa_queues;\r\nvf_op_params.sge_buff_sz =\r\ntpa_tlv->tpa_client_info.sge_buff_size;\r\nvf_op_params.sge_pause_thr_high =\r\ntpa_tlv->tpa_client_info.sge_pause_thr_high;\r\nvf_op_params.sge_pause_thr_low =\r\ntpa_tlv->tpa_client_info.sge_pause_thr_low;\r\nvf_op_params.tpa_mode =\r\ntpa_tlv->tpa_client_info.tpa_mode;\r\nvf_op_params.update_ipv4 =\r\ntpa_tlv->tpa_client_info.update_ipv4;\r\nvf_op_params.update_ipv6 =\r\ntpa_tlv->tpa_client_info.update_ipv6;\r\nrc = bnx2x_vf_tpa_update(bp, vf, tpa_tlv, &vf_op_params);\r\nmbx_resp:\r\nbnx2x_vf_mbx_resp(bp, vf, rc);\r\n}\r\nstatic void bnx2x_vf_mbx_request(struct bnx2x *bp, struct bnx2x_virtf *vf,\r\nstruct bnx2x_vf_mbx *mbx)\r\n{\r\nint i;\r\nif (bnx2x_tlv_supported(mbx->first_tlv.tl.type)) {\r\nbnx2x_lock_vf_pf_channel(bp, vf, mbx->first_tlv.tl.type);\r\nswitch (mbx->first_tlv.tl.type) {\r\ncase CHANNEL_TLV_ACQUIRE:\r\nbnx2x_vf_mbx_acquire(bp, vf, mbx);\r\nreturn;\r\ncase CHANNEL_TLV_INIT:\r\nbnx2x_vf_mbx_init_vf(bp, vf, mbx);\r\nreturn;\r\ncase CHANNEL_TLV_SETUP_Q:\r\nbnx2x_vf_mbx_setup_q(bp, vf, mbx);\r\nreturn;\r\ncase CHANNEL_TLV_SET_Q_FILTERS:\r\nbnx2x_vf_mbx_set_q_filters(bp, vf, mbx);\r\nreturn;\r\ncase CHANNEL_TLV_TEARDOWN_Q:\r\nbnx2x_vf_mbx_teardown_q(bp, vf, mbx);\r\nreturn;\r\ncase CHANNEL_TLV_CLOSE:\r\nbnx2x_vf_mbx_close_vf(bp, vf, mbx);\r\nreturn;\r\ncase CHANNEL_TLV_RELEASE:\r\nbnx2x_vf_mbx_release_vf(bp, vf, mbx);\r\nreturn;\r\ncase CHANNEL_TLV_UPDATE_RSS:\r\nbnx2x_vf_mbx_update_rss(bp, vf, mbx);\r\nreturn;\r\ncase CHANNEL_TLV_UPDATE_TPA:\r\nbnx2x_vf_mbx_update_tpa(bp, vf, mbx);\r\nreturn;\r\n}\r\n} else {\r\nBNX2X_ERR("unknown TLV. type %d length %d vf->state was %d. first 20 bytes of mailbox buffer:\n",\r\nmbx->first_tlv.tl.type, mbx->first_tlv.tl.length,\r\nvf->state);\r\nfor (i = 0; i < 20; i++)\r\nDP_CONT(BNX2X_MSG_IOV, "%x ",\r\nmbx->msg->req.tlv_buf_size.tlv_buffer[i]);\r\n}\r\nif (vf->state == VF_ACQUIRED || vf->state == VF_ENABLED) {\r\nbnx2x_vf_mbx_resp(bp, vf, PFVF_STATUS_NOT_SUPPORTED);\r\n} else {\r\nstorm_memset_vf_mbx_ack(bp, vf->abs_vfid);\r\nmmiowb();\r\nbnx2x_unlock_vf_pf_channel(bp, vf, mbx->first_tlv.tl.type);\r\n}\r\n}\r\nvoid bnx2x_vf_mbx_schedule(struct bnx2x *bp,\r\nstruct vf_pf_event_data *vfpf_event)\r\n{\r\nu8 vf_idx;\r\nDP(BNX2X_MSG_IOV,\r\n"vf pf event received: vfid %d, address_hi %x, address lo %x",\r\nvfpf_event->vf_id, vfpf_event->msg_addr_hi, vfpf_event->msg_addr_lo);\r\nif (vfpf_event->vf_id - BP_VFDB(bp)->sriov.first_vf_in_pf >\r\nBNX2X_NR_VIRTFN(bp)) {\r\nBNX2X_ERR("Illegal vf_id %d max allowed: %d\n",\r\nvfpf_event->vf_id, BNX2X_NR_VIRTFN(bp));\r\nreturn;\r\n}\r\nvf_idx = bnx2x_vf_idx_by_abs_fid(bp, vfpf_event->vf_id);\r\nmutex_lock(&BP_VFDB(bp)->event_mutex);\r\nBP_VF_MBX(bp, vf_idx)->vf_addr_hi = vfpf_event->msg_addr_hi;\r\nBP_VF_MBX(bp, vf_idx)->vf_addr_lo = vfpf_event->msg_addr_lo;\r\nBP_VFDB(bp)->event_occur |= (1ULL << vf_idx);\r\nmutex_unlock(&BP_VFDB(bp)->event_mutex);\r\nbnx2x_schedule_iov_task(bp, BNX2X_IOV_HANDLE_VF_MSG);\r\n}\r\nvoid bnx2x_vf_mbx(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_vfdb *vfdb = BP_VFDB(bp);\r\nu64 events;\r\nu8 vf_idx;\r\nint rc;\r\nif (!vfdb)\r\nreturn;\r\nmutex_lock(&vfdb->event_mutex);\r\nevents = vfdb->event_occur;\r\nvfdb->event_occur = 0;\r\nmutex_unlock(&vfdb->event_mutex);\r\nfor_each_vf(bp, vf_idx) {\r\nstruct bnx2x_vf_mbx *mbx = BP_VF_MBX(bp, vf_idx);\r\nstruct bnx2x_virtf *vf = BP_VF(bp, vf_idx);\r\nif (!(events & (1ULL << vf_idx)))\r\ncontinue;\r\nDP(BNX2X_MSG_IOV,\r\n"Handling vf pf event vfid %d, address: [%x:%x], resp_offset 0x%x\n",\r\nvf_idx, mbx->vf_addr_hi, mbx->vf_addr_lo,\r\nmbx->first_tlv.resp_msg_offset);\r\nrc = bnx2x_copy32_vf_dmae(bp, true, mbx->msg_mapping,\r\nvf->abs_vfid, mbx->vf_addr_hi,\r\nmbx->vf_addr_lo,\r\nsizeof(union vfpf_tlvs)/4);\r\nif (rc) {\r\nBNX2X_ERR("Failed to copy request VF %d\n",\r\nvf->abs_vfid);\r\nbnx2x_vf_release(bp, vf);\r\nreturn;\r\n}\r\nmbx->first_tlv = mbx->msg->req.first_tlv;\r\nmemset(&mbx->msg->resp, 0, sizeof(union pfvf_tlvs));\r\nbnx2x_vf_mbx_request(bp, vf, mbx);\r\n}\r\n}\r\nvoid bnx2x_vf_bulletin_finalize(struct pf_vf_bulletin_content *bulletin,\r\nbool support_long)\r\n{\r\nbulletin->length = support_long ? BULLETIN_CONTENT_SIZE :\r\nBULLETIN_CONTENT_LEGACY_SIZE;\r\nbulletin->crc = bnx2x_crc_vf_bulletin(bulletin);\r\n}\r\nint bnx2x_post_vf_bulletin(struct bnx2x *bp, int vf)\r\n{\r\nstruct pf_vf_bulletin_content *bulletin = BP_VF_BULLETIN(bp, vf);\r\ndma_addr_t pf_addr = BP_VF_BULLETIN_DMA(bp)->mapping +\r\nvf * BULLETIN_CONTENT_SIZE;\r\ndma_addr_t vf_addr = bnx2x_vf(bp, vf, bulletin_map);\r\nint rc;\r\nif (bnx2x_vf(bp, vf, state) != VF_ENABLED &&\r\nbnx2x_vf(bp, vf, state) != VF_ACQUIRED)\r\nreturn 0;\r\nbulletin->version++;\r\nbnx2x_vf_bulletin_finalize(bulletin,\r\n(bnx2x_vf(bp, vf, cfg_flags) &\r\nVF_CFG_EXT_BULLETIN) ? true : false);\r\nrc = bnx2x_copy32_vf_dmae(bp, false, pf_addr,\r\nbnx2x_vf(bp, vf, abs_vfid), U64_HI(vf_addr),\r\nU64_LO(vf_addr), bulletin->length / 4);\r\nreturn rc;\r\n}
