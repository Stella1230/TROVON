static void mga_crtc_load_lut(struct drm_crtc *crtc)\r\n{\r\nstruct mga_crtc *mga_crtc = to_mga_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct mga_device *mdev = dev->dev_private;\r\nstruct drm_framebuffer *fb = crtc->primary->fb;\r\nint i;\r\nif (!crtc->enabled)\r\nreturn;\r\nWREG8(DAC_INDEX + MGA1064_INDEX, 0);\r\nif (fb && fb->bits_per_pixel == 16) {\r\nint inc = (fb->depth == 15) ? 8 : 4;\r\nu8 r, b;\r\nfor (i = 0; i < MGAG200_LUT_SIZE; i += inc) {\r\nif (fb->depth == 16) {\r\nif (i > (MGAG200_LUT_SIZE >> 1)) {\r\nr = b = 0;\r\n} else {\r\nr = mga_crtc->lut_r[i << 1];\r\nb = mga_crtc->lut_b[i << 1];\r\n}\r\n} else {\r\nr = mga_crtc->lut_r[i];\r\nb = mga_crtc->lut_b[i];\r\n}\r\nWREG8(DAC_INDEX + MGA1064_COL_PAL, r);\r\nWREG8(DAC_INDEX + MGA1064_COL_PAL, mga_crtc->lut_g[i]);\r\nWREG8(DAC_INDEX + MGA1064_COL_PAL, b);\r\n}\r\nreturn;\r\n}\r\nfor (i = 0; i < MGAG200_LUT_SIZE; i++) {\r\nWREG8(DAC_INDEX + MGA1064_COL_PAL, mga_crtc->lut_r[i]);\r\nWREG8(DAC_INDEX + MGA1064_COL_PAL, mga_crtc->lut_g[i]);\r\nWREG8(DAC_INDEX + MGA1064_COL_PAL, mga_crtc->lut_b[i]);\r\n}\r\n}\r\nstatic inline void mga_wait_vsync(struct mga_device *mdev)\r\n{\r\nunsigned long timeout = jiffies + HZ/10;\r\nunsigned int status = 0;\r\ndo {\r\nstatus = RREG32(MGAREG_Status);\r\n} while ((status & 0x08) && time_before(jiffies, timeout));\r\ntimeout = jiffies + HZ/10;\r\nstatus = 0;\r\ndo {\r\nstatus = RREG32(MGAREG_Status);\r\n} while (!(status & 0x08) && time_before(jiffies, timeout));\r\n}\r\nstatic inline void mga_wait_busy(struct mga_device *mdev)\r\n{\r\nunsigned long timeout = jiffies + HZ;\r\nunsigned int status = 0;\r\ndo {\r\nstatus = RREG8(MGAREG_Status + 2);\r\n} while ((status & 0x01) && time_before(jiffies, timeout));\r\n}\r\nstatic bool mga_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic int mga_g200se_set_plls(struct mga_device *mdev, long clock)\r\n{\r\nunsigned int vcomax, vcomin, pllreffreq;\r\nunsigned int delta, tmpdelta, permitteddelta;\r\nunsigned int testp, testm, testn;\r\nunsigned int p, m, n;\r\nunsigned int computed;\r\nunsigned int pvalues_e4[P_ARRAY_SIZE] = {16, 14, 12, 10, 8, 6, 4, 2, 1};\r\nunsigned int fvv;\r\nunsigned int i;\r\nif (mdev->unique_rev_id <= 0x03) {\r\nm = n = p = 0;\r\nvcomax = 320000;\r\nvcomin = 160000;\r\npllreffreq = 25000;\r\ndelta = 0xffffffff;\r\npermitteddelta = clock * 5 / 1000;\r\nfor (testp = 8; testp > 0; testp /= 2) {\r\nif (clock * testp > vcomax)\r\ncontinue;\r\nif (clock * testp < vcomin)\r\ncontinue;\r\nfor (testn = 17; testn < 256; testn++) {\r\nfor (testm = 1; testm < 32; testm++) {\r\ncomputed = (pllreffreq * testn) /\r\n(testm * testp);\r\nif (computed > clock)\r\ntmpdelta = computed - clock;\r\nelse\r\ntmpdelta = clock - computed;\r\nif (tmpdelta < delta) {\r\ndelta = tmpdelta;\r\nm = testm - 1;\r\nn = testn - 1;\r\np = testp - 1;\r\n}\r\n}\r\n}\r\n}\r\n} else {\r\nm = n = p = 0;\r\nvcomax = 1600000;\r\nvcomin = 800000;\r\npllreffreq = 25000;\r\nif (clock < 25000)\r\nclock = 25000;\r\nclock = clock * 2;\r\ndelta = 0xFFFFFFFF;\r\npermitteddelta = clock * 5 / 1000;\r\nfor (i = 0 ; i < P_ARRAY_SIZE ; i++) {\r\ntestp = pvalues_e4[i];\r\nif ((clock * testp) > vcomax)\r\ncontinue;\r\nif ((clock * testp) < vcomin)\r\ncontinue;\r\nfor (testn = 50; testn <= 256; testn++) {\r\nfor (testm = 1; testm <= 32; testm++) {\r\ncomputed = (pllreffreq * testn) /\r\n(testm * testp);\r\nif (computed > clock)\r\ntmpdelta = computed - clock;\r\nelse\r\ntmpdelta = clock - computed;\r\nif (tmpdelta < delta) {\r\ndelta = tmpdelta;\r\nm = testm - 1;\r\nn = testn - 1;\r\np = testp - 1;\r\n}\r\n}\r\n}\r\n}\r\nfvv = pllreffreq * testn / testm;\r\nfvv = (fvv - 800000) / 50000;\r\nif (fvv > 15)\r\nfvv = 15;\r\np |= (fvv << 4);\r\nm |= 0x80;\r\nclock = clock / 2;\r\n}\r\nif (delta > permitteddelta) {\r\nprintk(KERN_WARNING "PLL delta too large\n");\r\nreturn 1;\r\n}\r\nWREG_DAC(MGA1064_PIX_PLLC_M, m);\r\nWREG_DAC(MGA1064_PIX_PLLC_N, n);\r\nWREG_DAC(MGA1064_PIX_PLLC_P, p);\r\nreturn 0;\r\n}\r\nstatic int mga_g200wb_set_plls(struct mga_device *mdev, long clock)\r\n{\r\nunsigned int vcomax, vcomin, pllreffreq;\r\nunsigned int delta, tmpdelta;\r\nunsigned int testp, testm, testn, testp2;\r\nunsigned int p, m, n;\r\nunsigned int computed;\r\nint i, j, tmpcount, vcount;\r\nbool pll_locked = false;\r\nu8 tmp;\r\nm = n = p = 0;\r\ndelta = 0xffffffff;\r\nif (mdev->type == G200_EW3) {\r\nvcomax = 800000;\r\nvcomin = 400000;\r\npllreffreq = 25000;\r\nfor (testp = 1; testp < 8; testp++) {\r\nfor (testp2 = 1; testp2 < 8; testp2++) {\r\nif (testp < testp2)\r\ncontinue;\r\nif ((clock * testp * testp2) > vcomax)\r\ncontinue;\r\nif ((clock * testp * testp2) < vcomin)\r\ncontinue;\r\nfor (testm = 1; testm < 26; testm++) {\r\nfor (testn = 32; testn < 2048 ; testn++) {\r\ncomputed = (pllreffreq * testn) /\r\n(testm * testp * testp2);\r\nif (computed > clock)\r\ntmpdelta = computed - clock;\r\nelse\r\ntmpdelta = clock - computed;\r\nif (tmpdelta < delta) {\r\ndelta = tmpdelta;\r\nm = ((testn & 0x100) >> 1) |\r\n(testm);\r\nn = (testn & 0xFF);\r\np = ((testn & 0x600) >> 3) |\r\n(testp2 << 3) |\r\n(testp);\r\n}\r\n}\r\n}\r\n}\r\n}\r\n} else {\r\nvcomax = 550000;\r\nvcomin = 150000;\r\npllreffreq = 48000;\r\nfor (testp = 1; testp < 9; testp++) {\r\nif (clock * testp > vcomax)\r\ncontinue;\r\nif (clock * testp < vcomin)\r\ncontinue;\r\nfor (testm = 1; testm < 17; testm++) {\r\nfor (testn = 1; testn < 151; testn++) {\r\ncomputed = (pllreffreq * testn) /\r\n(testm * testp);\r\nif (computed > clock)\r\ntmpdelta = computed - clock;\r\nelse\r\ntmpdelta = clock - computed;\r\nif (tmpdelta < delta) {\r\ndelta = tmpdelta;\r\nn = testn - 1;\r\nm = (testm - 1) |\r\n((n >> 1) & 0x80);\r\np = testp - 1;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nfor (i = 0; i <= 32 && pll_locked == false; i++) {\r\nif (i > 0) {\r\nWREG8(MGAREG_CRTC_INDEX, 0x1e);\r\ntmp = RREG8(MGAREG_CRTC_DATA);\r\nif (tmp < 0xff)\r\nWREG8(MGAREG_CRTC_DATA, tmp+1);\r\n}\r\nWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp |= MGA1064_PIX_CLK_CTL_CLK_DIS;\r\nWREG8(DAC_DATA, tmp);\r\nWREG8(DAC_INDEX, MGA1064_REMHEADCTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp |= MGA1064_REMHEADCTL_CLKDIS;\r\nWREG8(DAC_DATA, tmp);\r\ntmp = RREG8(MGAREG_MEM_MISC_READ);\r\ntmp |= 0x3 << 2;\r\nWREG8(MGAREG_MEM_MISC_WRITE, tmp);\r\nWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp |= MGA1064_PIX_CLK_CTL_CLK_POW_DOWN | 0x80;\r\nWREG8(DAC_DATA, tmp);\r\nudelay(500);\r\nWREG8(DAC_INDEX, MGA1064_VREF_CTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp &= ~0x04;\r\nWREG8(DAC_DATA, tmp);\r\nudelay(50);\r\nWREG_DAC(MGA1064_WB_PIX_PLLC_N, n);\r\nWREG_DAC(MGA1064_WB_PIX_PLLC_M, m);\r\nWREG_DAC(MGA1064_WB_PIX_PLLC_P, p);\r\nudelay(50);\r\nWREG8(DAC_INDEX, MGA1064_VREF_CTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp |= 0x04;\r\nWREG_DAC(MGA1064_VREF_CTL, tmp);\r\nudelay(500);\r\nWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp &= ~MGA1064_PIX_CLK_CTL_SEL_MSK;\r\ntmp |= MGA1064_PIX_CLK_CTL_SEL_PLL;\r\nWREG8(DAC_DATA, tmp);\r\nWREG8(DAC_INDEX, MGA1064_REMHEADCTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp &= ~MGA1064_REMHEADCTL_CLKSL_MSK;\r\ntmp |= MGA1064_REMHEADCTL_CLKSL_PLL;\r\nWREG8(DAC_DATA, tmp);\r\nWREG8(MGAREG_SEQ_INDEX, 1);\r\ntmp = RREG8(MGAREG_SEQ_DATA);\r\ntmp &= ~0x8;\r\nWREG8(MGAREG_SEQ_DATA, tmp);\r\nWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp &= ~MGA1064_PIX_CLK_CTL_CLK_DIS;\r\nWREG8(DAC_DATA, tmp);\r\nvcount = RREG8(MGAREG_VCOUNT);\r\nfor (j = 0; j < 30 && pll_locked == false; j++) {\r\ntmpcount = RREG8(MGAREG_VCOUNT);\r\nif (tmpcount < vcount)\r\nvcount = 0;\r\nif ((tmpcount - vcount) > 2)\r\npll_locked = true;\r\nelse\r\nudelay(5);\r\n}\r\n}\r\nWREG8(DAC_INDEX, MGA1064_REMHEADCTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp &= ~MGA1064_REMHEADCTL_CLKDIS;\r\nWREG_DAC(MGA1064_REMHEADCTL, tmp);\r\nreturn 0;\r\n}\r\nstatic int mga_g200ev_set_plls(struct mga_device *mdev, long clock)\r\n{\r\nunsigned int vcomax, vcomin, pllreffreq;\r\nunsigned int delta, tmpdelta;\r\nunsigned int testp, testm, testn;\r\nunsigned int p, m, n;\r\nunsigned int computed;\r\nu8 tmp;\r\nm = n = p = 0;\r\nvcomax = 550000;\r\nvcomin = 150000;\r\npllreffreq = 50000;\r\ndelta = 0xffffffff;\r\nfor (testp = 16; testp > 0; testp--) {\r\nif (clock * testp > vcomax)\r\ncontinue;\r\nif (clock * testp < vcomin)\r\ncontinue;\r\nfor (testn = 1; testn < 257; testn++) {\r\nfor (testm = 1; testm < 17; testm++) {\r\ncomputed = (pllreffreq * testn) /\r\n(testm * testp);\r\nif (computed > clock)\r\ntmpdelta = computed - clock;\r\nelse\r\ntmpdelta = clock - computed;\r\nif (tmpdelta < delta) {\r\ndelta = tmpdelta;\r\nn = testn - 1;\r\nm = testm - 1;\r\np = testp - 1;\r\n}\r\n}\r\n}\r\n}\r\nWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp |= MGA1064_PIX_CLK_CTL_CLK_DIS;\r\nWREG8(DAC_DATA, tmp);\r\ntmp = RREG8(MGAREG_MEM_MISC_READ);\r\ntmp |= 0x3 << 2;\r\nWREG8(MGAREG_MEM_MISC_WRITE, tmp);\r\nWREG8(DAC_INDEX, MGA1064_PIX_PLL_STAT);\r\ntmp = RREG8(DAC_DATA);\r\nWREG8(DAC_DATA, tmp & ~0x40);\r\nWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp |= MGA1064_PIX_CLK_CTL_CLK_POW_DOWN;\r\nWREG8(DAC_DATA, tmp);\r\nWREG_DAC(MGA1064_EV_PIX_PLLC_M, m);\r\nWREG_DAC(MGA1064_EV_PIX_PLLC_N, n);\r\nWREG_DAC(MGA1064_EV_PIX_PLLC_P, p);\r\nudelay(50);\r\nWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp &= ~MGA1064_PIX_CLK_CTL_CLK_POW_DOWN;\r\nWREG8(DAC_DATA, tmp);\r\nudelay(500);\r\nWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp &= ~MGA1064_PIX_CLK_CTL_SEL_MSK;\r\ntmp |= MGA1064_PIX_CLK_CTL_SEL_PLL;\r\nWREG8(DAC_DATA, tmp);\r\nWREG8(DAC_INDEX, MGA1064_PIX_PLL_STAT);\r\ntmp = RREG8(DAC_DATA);\r\nWREG8(DAC_DATA, tmp | 0x40);\r\ntmp = RREG8(MGAREG_MEM_MISC_READ);\r\ntmp |= (0x3 << 2);\r\nWREG8(MGAREG_MEM_MISC_WRITE, tmp);\r\nWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp &= ~MGA1064_PIX_CLK_CTL_CLK_DIS;\r\nWREG8(DAC_DATA, tmp);\r\nreturn 0;\r\n}\r\nstatic int mga_g200eh_set_plls(struct mga_device *mdev, long clock)\r\n{\r\nunsigned int vcomax, vcomin, pllreffreq;\r\nunsigned int delta, tmpdelta;\r\nunsigned int testp, testm, testn;\r\nunsigned int p, m, n;\r\nunsigned int computed;\r\nint i, j, tmpcount, vcount;\r\nu8 tmp;\r\nbool pll_locked = false;\r\nm = n = p = 0;\r\nvcomax = 800000;\r\nvcomin = 400000;\r\npllreffreq = 33333;\r\ndelta = 0xffffffff;\r\nfor (testp = 16; testp > 0; testp >>= 1) {\r\nif (clock * testp > vcomax)\r\ncontinue;\r\nif (clock * testp < vcomin)\r\ncontinue;\r\nfor (testm = 1; testm < 33; testm++) {\r\nfor (testn = 17; testn < 257; testn++) {\r\ncomputed = (pllreffreq * testn) /\r\n(testm * testp);\r\nif (computed > clock)\r\ntmpdelta = computed - clock;\r\nelse\r\ntmpdelta = clock - computed;\r\nif (tmpdelta < delta) {\r\ndelta = tmpdelta;\r\nn = testn - 1;\r\nm = (testm - 1);\r\np = testp - 1;\r\n}\r\nif ((clock * testp) >= 600000)\r\np |= 0x80;\r\n}\r\n}\r\n}\r\nfor (i = 0; i <= 32 && pll_locked == false; i++) {\r\nWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp |= MGA1064_PIX_CLK_CTL_CLK_DIS;\r\nWREG8(DAC_DATA, tmp);\r\ntmp = RREG8(MGAREG_MEM_MISC_READ);\r\ntmp |= 0x3 << 2;\r\nWREG8(MGAREG_MEM_MISC_WRITE, tmp);\r\nWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp |= MGA1064_PIX_CLK_CTL_CLK_POW_DOWN;\r\nWREG8(DAC_DATA, tmp);\r\nudelay(500);\r\nWREG_DAC(MGA1064_EH_PIX_PLLC_M, m);\r\nWREG_DAC(MGA1064_EH_PIX_PLLC_N, n);\r\nWREG_DAC(MGA1064_EH_PIX_PLLC_P, p);\r\nudelay(500);\r\nWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp &= ~MGA1064_PIX_CLK_CTL_SEL_MSK;\r\ntmp |= MGA1064_PIX_CLK_CTL_SEL_PLL;\r\nWREG8(DAC_DATA, tmp);\r\nWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp &= ~MGA1064_PIX_CLK_CTL_CLK_DIS;\r\ntmp &= ~MGA1064_PIX_CLK_CTL_CLK_POW_DOWN;\r\nWREG8(DAC_DATA, tmp);\r\nvcount = RREG8(MGAREG_VCOUNT);\r\nfor (j = 0; j < 30 && pll_locked == false; j++) {\r\ntmpcount = RREG8(MGAREG_VCOUNT);\r\nif (tmpcount < vcount)\r\nvcount = 0;\r\nif ((tmpcount - vcount) > 2)\r\npll_locked = true;\r\nelse\r\nudelay(5);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mga_g200er_set_plls(struct mga_device *mdev, long clock)\r\n{\r\nunsigned int vcomax, vcomin, pllreffreq;\r\nunsigned int delta, tmpdelta;\r\nint testr, testn, testm, testo;\r\nunsigned int p, m, n;\r\nunsigned int computed, vco;\r\nint tmp;\r\nconst unsigned int m_div_val[] = { 1, 2, 4, 8 };\r\nm = n = p = 0;\r\nvcomax = 1488000;\r\nvcomin = 1056000;\r\npllreffreq = 48000;\r\ndelta = 0xffffffff;\r\nfor (testr = 0; testr < 4; testr++) {\r\nif (delta == 0)\r\nbreak;\r\nfor (testn = 5; testn < 129; testn++) {\r\nif (delta == 0)\r\nbreak;\r\nfor (testm = 3; testm >= 0; testm--) {\r\nif (delta == 0)\r\nbreak;\r\nfor (testo = 5; testo < 33; testo++) {\r\nvco = pllreffreq * (testn + 1) /\r\n(testr + 1);\r\nif (vco < vcomin)\r\ncontinue;\r\nif (vco > vcomax)\r\ncontinue;\r\ncomputed = vco / (m_div_val[testm] * (testo + 1));\r\nif (computed > clock)\r\ntmpdelta = computed - clock;\r\nelse\r\ntmpdelta = clock - computed;\r\nif (tmpdelta < delta) {\r\ndelta = tmpdelta;\r\nm = testm | (testo << 3);\r\nn = testn;\r\np = testr | (testr << 3);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp |= MGA1064_PIX_CLK_CTL_CLK_DIS;\r\nWREG8(DAC_DATA, tmp);\r\nWREG8(DAC_INDEX, MGA1064_REMHEADCTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp |= MGA1064_REMHEADCTL_CLKDIS;\r\nWREG8(DAC_DATA, tmp);\r\ntmp = RREG8(MGAREG_MEM_MISC_READ);\r\ntmp |= (0x3<<2) | 0xc0;\r\nWREG8(MGAREG_MEM_MISC_WRITE, tmp);\r\nWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp &= ~MGA1064_PIX_CLK_CTL_CLK_DIS;\r\ntmp |= MGA1064_PIX_CLK_CTL_CLK_POW_DOWN;\r\nWREG8(DAC_DATA, tmp);\r\nudelay(500);\r\nWREG_DAC(MGA1064_ER_PIX_PLLC_N, n);\r\nWREG_DAC(MGA1064_ER_PIX_PLLC_M, m);\r\nWREG_DAC(MGA1064_ER_PIX_PLLC_P, p);\r\nudelay(50);\r\nreturn 0;\r\n}\r\nstatic int mga_crtc_set_plls(struct mga_device *mdev, long clock)\r\n{\r\nswitch(mdev->type) {\r\ncase G200_SE_A:\r\ncase G200_SE_B:\r\nreturn mga_g200se_set_plls(mdev, clock);\r\nbreak;\r\ncase G200_WB:\r\ncase G200_EW3:\r\nreturn mga_g200wb_set_plls(mdev, clock);\r\nbreak;\r\ncase G200_EV:\r\nreturn mga_g200ev_set_plls(mdev, clock);\r\nbreak;\r\ncase G200_EH:\r\nreturn mga_g200eh_set_plls(mdev, clock);\r\nbreak;\r\ncase G200_ER:\r\nreturn mga_g200er_set_plls(mdev, clock);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mga_g200wb_prepare(struct drm_crtc *crtc)\r\n{\r\nstruct mga_device *mdev = crtc->dev->dev_private;\r\nu8 tmp;\r\nint iter_max;\r\nWREG8(DAC_INDEX, MGA1064_GEN_IO_CTL);\r\ntmp = RREG8(DAC_DATA);\r\ntmp |= 0x10;\r\nWREG_DAC(MGA1064_GEN_IO_CTL, tmp);\r\nWREG8(DAC_INDEX, MGA1064_GEN_IO_DATA);\r\ntmp = RREG8(DAC_DATA);\r\ntmp |= 0x10;\r\nWREG_DAC(MGA1064_GEN_IO_DATA, tmp);\r\nWREG8(DAC_INDEX, MGA1064_SPAREREG);\r\ntmp = RREG8(DAC_DATA);\r\ntmp |= 0x80;\r\nWREG_DAC(MGA1064_SPAREREG, tmp);\r\niter_max = 300;\r\nwhile (!(tmp & 0x1) && iter_max) {\r\nWREG8(DAC_INDEX, MGA1064_SPAREREG);\r\ntmp = RREG8(DAC_DATA);\r\nudelay(1000);\r\niter_max--;\r\n}\r\nif (iter_max) {\r\niter_max = 300;\r\nwhile ((tmp & 0x2) && iter_max) {\r\nWREG8(DAC_INDEX, MGA1064_SPAREREG);\r\ntmp = RREG8(DAC_DATA);\r\nudelay(1000);\r\niter_max--;\r\n}\r\n}\r\n}\r\nstatic void mga_g200wb_commit(struct drm_crtc *crtc)\r\n{\r\nu8 tmp;\r\nstruct mga_device *mdev = crtc->dev->dev_private;\r\nWREG8(MGAREG_CRTCEXT_INDEX, 1);\r\ntmp = RREG8(MGAREG_CRTCEXT_DATA);\r\nWREG8(MGAREG_CRTCEXT_DATA, tmp | 0x88);\r\nWREG8(DAC_INDEX, MGA1064_REMHEADCTL2);\r\ntmp = RREG8(DAC_DATA);\r\ntmp |= 0x8;\r\nWREG8(DAC_DATA, tmp);\r\nudelay(10);\r\ntmp &= ~0x08;\r\nWREG8(DAC_INDEX, MGA1064_REMHEADCTL2);\r\nWREG8(DAC_DATA, tmp);\r\nWREG8(DAC_INDEX, MGA1064_SPAREREG);\r\ntmp = RREG8(DAC_DATA);\r\ntmp &= ~0x80;\r\nWREG8(DAC_DATA, tmp);\r\nWREG8(DAC_INDEX, MGA1064_GEN_IO_DATA);\r\ntmp = RREG8(DAC_DATA);\r\ntmp &= ~0x10;\r\nWREG_DAC(MGA1064_GEN_IO_DATA, tmp);\r\n}\r\nstatic void mga_set_start_address(struct drm_crtc *crtc, unsigned offset)\r\n{\r\nstruct mga_device *mdev = crtc->dev->dev_private;\r\nu32 addr;\r\nint count;\r\nu8 crtcext0;\r\nwhile (RREG8(0x1fda) & 0x08);\r\nwhile (!(RREG8(0x1fda) & 0x08));\r\ncount = RREG8(MGAREG_VCOUNT) + 2;\r\nwhile (RREG8(MGAREG_VCOUNT) < count);\r\nWREG8(MGAREG_CRTCEXT_INDEX, 0);\r\ncrtcext0 = RREG8(MGAREG_CRTCEXT_DATA);\r\ncrtcext0 &= 0xB0;\r\naddr = offset / 8;\r\nWARN_ON(addr > 0x1fffff);\r\ncrtcext0 |= (!!(addr & (1<<20)))<<6;\r\nWREG_CRT(0x0d, (u8)(addr & 0xff));\r\nWREG_CRT(0x0c, (u8)(addr >> 8) & 0xff);\r\nWREG_ECRT(0x0, ((u8)(addr >> 16) & 0xf) | crtcext0);\r\n}\r\nstatic int mga_crtc_do_set_base(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nint x, int y, int atomic)\r\n{\r\nstruct mga_device *mdev = crtc->dev->dev_private;\r\nstruct drm_gem_object *obj;\r\nstruct mga_framebuffer *mga_fb;\r\nstruct mgag200_bo *bo;\r\nint ret;\r\nu64 gpu_addr;\r\nif (!atomic && fb) {\r\nmga_fb = to_mga_framebuffer(fb);\r\nobj = mga_fb->obj;\r\nbo = gem_to_mga_bo(obj);\r\nret = mgag200_bo_reserve(bo, false);\r\nif (ret)\r\nreturn ret;\r\nmgag200_bo_push_sysram(bo);\r\nmgag200_bo_unreserve(bo);\r\n}\r\nmga_fb = to_mga_framebuffer(crtc->primary->fb);\r\nobj = mga_fb->obj;\r\nbo = gem_to_mga_bo(obj);\r\nret = mgag200_bo_reserve(bo, false);\r\nif (ret)\r\nreturn ret;\r\nret = mgag200_bo_pin(bo, TTM_PL_FLAG_VRAM, &gpu_addr);\r\nif (ret) {\r\nmgag200_bo_unreserve(bo);\r\nreturn ret;\r\n}\r\nif (&mdev->mfbdev->mfb == mga_fb) {\r\nret = ttm_bo_kmap(&bo->bo, 0, bo->bo.num_pages, &bo->kmap);\r\nif (ret)\r\nDRM_ERROR("failed to kmap fbcon\n");\r\n}\r\nmgag200_bo_unreserve(bo);\r\nmga_set_start_address(crtc, (u32)gpu_addr);\r\nreturn 0;\r\n}\r\nstatic int mga_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nreturn mga_crtc_do_set_base(crtc, old_fb, x, y, 0);\r\n}\r\nstatic int mga_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y, struct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct mga_device *mdev = dev->dev_private;\r\nint hdisplay, hsyncstart, hsyncend, htotal;\r\nint vdisplay, vsyncstart, vsyncend, vtotal;\r\nint pitch;\r\nint option = 0, option2 = 0;\r\nint i;\r\nunsigned char misc = 0;\r\nunsigned char ext_vga[6];\r\nu8 bppshift;\r\nstatic unsigned char dacvalue[] = {\r\n0, 0, 0, 0, 0, 0, 0x00, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0,\r\n0x00, 0, 0xC9, 0xFF, 0xBF, 0x20, 0x1F, 0x20,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0, 0, 0, 0x40,\r\n0x00, 0xB0, 0x00, 0xC2, 0x34, 0x14, 0x02, 0x83,\r\n0x00, 0x93, 0x00, 0x77, 0x00, 0x00, 0x00, 0x3A,\r\n0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0\r\n};\r\nbppshift = mdev->bpp_shifts[(crtc->primary->fb->bits_per_pixel >> 3) - 1];\r\nswitch (mdev->type) {\r\ncase G200_SE_A:\r\ncase G200_SE_B:\r\ndacvalue[MGA1064_VREF_CTL] = 0x03;\r\ndacvalue[MGA1064_PIX_CLK_CTL] = MGA1064_PIX_CLK_CTL_SEL_PLL;\r\ndacvalue[MGA1064_MISC_CTL] = MGA1064_MISC_CTL_DAC_EN |\r\nMGA1064_MISC_CTL_VGA8 |\r\nMGA1064_MISC_CTL_DAC_RAM_CS;\r\nif (mdev->has_sdram)\r\noption = 0x40049120;\r\nelse\r\noption = 0x4004d120;\r\noption2 = 0x00008000;\r\nbreak;\r\ncase G200_WB:\r\ncase G200_EW3:\r\ndacvalue[MGA1064_VREF_CTL] = 0x07;\r\noption = 0x41049120;\r\noption2 = 0x0000b000;\r\nbreak;\r\ncase G200_EV:\r\ndacvalue[MGA1064_PIX_CLK_CTL] = MGA1064_PIX_CLK_CTL_SEL_PLL;\r\ndacvalue[MGA1064_MISC_CTL] = MGA1064_MISC_CTL_VGA8 |\r\nMGA1064_MISC_CTL_DAC_RAM_CS;\r\noption = 0x00000120;\r\noption2 = 0x0000b000;\r\nbreak;\r\ncase G200_EH:\r\ndacvalue[MGA1064_MISC_CTL] = MGA1064_MISC_CTL_VGA8 |\r\nMGA1064_MISC_CTL_DAC_RAM_CS;\r\noption = 0x00000120;\r\noption2 = 0x0000b000;\r\nbreak;\r\ncase G200_ER:\r\nbreak;\r\n}\r\nswitch (crtc->primary->fb->bits_per_pixel) {\r\ncase 8:\r\ndacvalue[MGA1064_MUL_CTL] = MGA1064_MUL_CTL_8bits;\r\nbreak;\r\ncase 16:\r\nif (crtc->primary->fb->depth == 15)\r\ndacvalue[MGA1064_MUL_CTL] = MGA1064_MUL_CTL_15bits;\r\nelse\r\ndacvalue[MGA1064_MUL_CTL] = MGA1064_MUL_CTL_16bits;\r\nbreak;\r\ncase 24:\r\ndacvalue[MGA1064_MUL_CTL] = MGA1064_MUL_CTL_24bits;\r\nbreak;\r\ncase 32:\r\ndacvalue[MGA1064_MUL_CTL] = MGA1064_MUL_CTL_32_24bits;\r\nbreak;\r\n}\r\nif (mode->flags & DRM_MODE_FLAG_NHSYNC)\r\nmisc |= 0x40;\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nmisc |= 0x80;\r\nfor (i = 0; i < sizeof(dacvalue); i++) {\r\nif ((i <= 0x17) ||\r\n(i == 0x1b) ||\r\n(i == 0x1c) ||\r\n((i >= 0x1f) && (i <= 0x29)) ||\r\n((i >= 0x30) && (i <= 0x37)))\r\ncontinue;\r\nif (IS_G200_SE(mdev) &&\r\n((i == 0x2c) || (i == 0x2d) || (i == 0x2e)))\r\ncontinue;\r\nif ((mdev->type == G200_EV ||\r\nmdev->type == G200_WB ||\r\nmdev->type == G200_EH ||\r\nmdev->type == G200_EW3) &&\r\n(i >= 0x44) && (i <= 0x4e))\r\ncontinue;\r\nWREG_DAC(i, dacvalue[i]);\r\n}\r\nif (mdev->type == G200_ER)\r\nWREG_DAC(0x90, 0);\r\nif (option)\r\npci_write_config_dword(dev->pdev, PCI_MGA_OPTION, option);\r\nif (option2)\r\npci_write_config_dword(dev->pdev, PCI_MGA_OPTION2, option2);\r\nWREG_SEQ(2, 0xf);\r\nWREG_SEQ(3, 0);\r\nWREG_SEQ(4, 0xe);\r\npitch = crtc->primary->fb->pitches[0] / (crtc->primary->fb->bits_per_pixel / 8);\r\nif (crtc->primary->fb->bits_per_pixel == 24)\r\npitch = (pitch * 3) >> (4 - bppshift);\r\nelse\r\npitch = pitch >> (4 - bppshift);\r\nhdisplay = mode->hdisplay / 8 - 1;\r\nhsyncstart = mode->hsync_start / 8 - 1;\r\nhsyncend = mode->hsync_end / 8 - 1;\r\nhtotal = mode->htotal / 8 - 1;\r\nif ((htotal & 0x07) == 0x06 || (htotal & 0x07) == 0x04)\r\nhtotal++;\r\nvdisplay = mode->vdisplay - 1;\r\nvsyncstart = mode->vsync_start - 1;\r\nvsyncend = mode->vsync_end - 1;\r\nvtotal = mode->vtotal - 2;\r\nWREG_GFX(0, 0);\r\nWREG_GFX(1, 0);\r\nWREG_GFX(2, 0);\r\nWREG_GFX(3, 0);\r\nWREG_GFX(4, 0);\r\nWREG_GFX(5, 0x40);\r\nWREG_GFX(6, 0x5);\r\nWREG_GFX(7, 0xf);\r\nWREG_GFX(8, 0xf);\r\nWREG_CRT(0, htotal - 4);\r\nWREG_CRT(1, hdisplay);\r\nWREG_CRT(2, hdisplay);\r\nWREG_CRT(3, (htotal & 0x1F) | 0x80);\r\nWREG_CRT(4, hsyncstart);\r\nWREG_CRT(5, ((htotal & 0x20) << 2) | (hsyncend & 0x1F));\r\nWREG_CRT(6, vtotal & 0xFF);\r\nWREG_CRT(7, ((vtotal & 0x100) >> 8) |\r\n((vdisplay & 0x100) >> 7) |\r\n((vsyncstart & 0x100) >> 6) |\r\n((vdisplay & 0x100) >> 5) |\r\n((vdisplay & 0x100) >> 4) |\r\n((vtotal & 0x200) >> 4)|\r\n((vdisplay & 0x200) >> 3) |\r\n((vsyncstart & 0x200) >> 2));\r\nWREG_CRT(9, ((vdisplay & 0x200) >> 4) |\r\n((vdisplay & 0x200) >> 3));\r\nWREG_CRT(10, 0);\r\nWREG_CRT(11, 0);\r\nWREG_CRT(12, 0);\r\nWREG_CRT(13, 0);\r\nWREG_CRT(14, 0);\r\nWREG_CRT(15, 0);\r\nWREG_CRT(16, vsyncstart & 0xFF);\r\nWREG_CRT(17, (vsyncend & 0x0F) | 0x20);\r\nWREG_CRT(18, vdisplay & 0xFF);\r\nWREG_CRT(19, pitch & 0xFF);\r\nWREG_CRT(20, 0);\r\nWREG_CRT(21, vdisplay & 0xFF);\r\nWREG_CRT(22, (vtotal + 1) & 0xFF);\r\nWREG_CRT(23, 0xc3);\r\nWREG_CRT(24, vdisplay & 0xFF);\r\next_vga[0] = 0;\r\next_vga[5] = 0;\r\next_vga[0] |= (pitch & 0x300) >> 4;\r\next_vga[1] = (((htotal - 4) & 0x100) >> 8) |\r\n((hdisplay & 0x100) >> 7) |\r\n((hsyncstart & 0x100) >> 6) |\r\n(htotal & 0x40);\r\next_vga[2] = ((vtotal & 0xc00) >> 10) |\r\n((vdisplay & 0x400) >> 8) |\r\n((vdisplay & 0xc00) >> 7) |\r\n((vsyncstart & 0xc00) >> 5) |\r\n((vdisplay & 0x400) >> 3);\r\nif (crtc->primary->fb->bits_per_pixel == 24)\r\next_vga[3] = (((1 << bppshift) * 3) - 1) | 0x80;\r\nelse\r\next_vga[3] = ((1 << bppshift) - 1) | 0x80;\r\next_vga[4] = 0;\r\nif (mdev->type == G200_WB || mdev->type == G200_EW3)\r\next_vga[1] |= 0x88;\r\nmisc = 0x2d;\r\nWREG8(MGA_MISC_OUT, misc);\r\nmga_crtc_set_plls(mdev, mode->clock);\r\nfor (i = 0; i < 6; i++) {\r\nWREG_ECRT(i, ext_vga[i]);\r\n}\r\nif (mdev->type == G200_ER)\r\nWREG_ECRT(0x24, 0x5);\r\nif (mdev->type == G200_EW3)\r\nWREG_ECRT(0x34, 0x5);\r\nif (mdev->type == G200_EV) {\r\nWREG_ECRT(6, 0);\r\n}\r\nWREG_ECRT(0, ext_vga[0]);\r\nmisc = 0x2d;\r\nWREG8(MGA_MISC_OUT, misc);\r\nif (adjusted_mode)\r\nmemcpy(&mdev->mode, mode, sizeof(struct drm_display_mode));\r\nmga_crtc_do_set_base(crtc, old_fb, x, y, 0);\r\nif (mdev->type == G200_ER) {\r\nu32 mem_ctl = RREG32(MGAREG_MEMCTL);\r\nu8 seq1;\r\nWREG8(MGAREG_SEQ_INDEX, 0x01);\r\nseq1 = RREG8(MGAREG_SEQ_DATA) | 0x20;\r\nWREG8(MGAREG_SEQ_DATA, seq1);\r\nWREG32(MGAREG_MEMCTL, mem_ctl | 0x00200000);\r\nudelay(1000);\r\nWREG32(MGAREG_MEMCTL, mem_ctl & ~0x00200000);\r\nWREG8(MGAREG_SEQ_DATA, seq1 & ~0x20);\r\n}\r\nif (IS_G200_SE(mdev)) {\r\nif (mdev->unique_rev_id >= 0x02) {\r\nu8 hi_pri_lvl;\r\nu32 bpp;\r\nu32 mb;\r\nif (crtc->primary->fb->bits_per_pixel > 16)\r\nbpp = 32;\r\nelse if (crtc->primary->fb->bits_per_pixel > 8)\r\nbpp = 16;\r\nelse\r\nbpp = 8;\r\nmb = (mode->clock * bpp) / 1000;\r\nif (mb > 3100)\r\nhi_pri_lvl = 0;\r\nelse if (mb > 2600)\r\nhi_pri_lvl = 1;\r\nelse if (mb > 1900)\r\nhi_pri_lvl = 2;\r\nelse if (mb > 1160)\r\nhi_pri_lvl = 3;\r\nelse if (mb > 440)\r\nhi_pri_lvl = 4;\r\nelse\r\nhi_pri_lvl = 5;\r\nWREG8(MGAREG_CRTCEXT_INDEX, 0x06);\r\nWREG8(MGAREG_CRTCEXT_DATA, hi_pri_lvl);\r\n} else {\r\nWREG8(MGAREG_CRTCEXT_INDEX, 0x06);\r\nif (mdev->unique_rev_id >= 0x01)\r\nWREG8(MGAREG_CRTCEXT_DATA, 0x03);\r\nelse\r\nWREG8(MGAREG_CRTCEXT_DATA, 0x04);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void mga_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct mga_device *mdev = dev->dev_private;\r\nu8 seq1 = 0, crtcext1 = 0;\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nseq1 = 0;\r\ncrtcext1 = 0;\r\nmga_crtc_load_lut(crtc);\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\nseq1 = 0x20;\r\ncrtcext1 = 0x10;\r\nbreak;\r\ncase DRM_MODE_DPMS_SUSPEND:\r\nseq1 = 0x20;\r\ncrtcext1 = 0x20;\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\nseq1 = 0x20;\r\ncrtcext1 = 0x30;\r\nbreak;\r\n}\r\n#if 0\r\nif (mode == DRM_MODE_DPMS_OFF) {\r\nmga_suspend(crtc);\r\n}\r\n#endif\r\nWREG8(MGAREG_SEQ_INDEX, 0x01);\r\nseq1 |= RREG8(MGAREG_SEQ_DATA) & ~0x20;\r\nmga_wait_vsync(mdev);\r\nmga_wait_busy(mdev);\r\nWREG8(MGAREG_SEQ_DATA, seq1);\r\nmsleep(20);\r\nWREG8(MGAREG_CRTCEXT_INDEX, 0x01);\r\ncrtcext1 |= RREG8(MGAREG_CRTCEXT_DATA) & ~0x30;\r\nWREG8(MGAREG_CRTCEXT_DATA, crtcext1);\r\n#if 0\r\nif (mode == DRM_MODE_DPMS_ON && mdev->suspended == true) {\r\nmga_resume(crtc);\r\ndrm_helper_resume_force_mode(dev);\r\n}\r\n#endif\r\n}\r\nstatic void mga_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct mga_device *mdev = dev->dev_private;\r\nu8 tmp;\r\nWREG8(MGAREG_CRTC_INDEX, 0x11);\r\ntmp = RREG8(MGAREG_CRTC_DATA);\r\nWREG_CRT(0x11, tmp | 0x80);\r\nif (mdev->type == G200_SE_A || mdev->type == G200_SE_B) {\r\nWREG_SEQ(0, 1);\r\nmsleep(50);\r\nWREG_SEQ(1, 0x20);\r\nmsleep(20);\r\n} else {\r\nWREG8(MGAREG_SEQ_INDEX, 0x1);\r\ntmp = RREG8(MGAREG_SEQ_DATA);\r\nWREG_SEQ(0, 1);\r\nWREG_SEQ(1, tmp | 0x20);\r\n}\r\nif (mdev->type == G200_WB || mdev->type == G200_EW3)\r\nmga_g200wb_prepare(crtc);\r\nWREG_CRT(17, 0);\r\n}\r\nstatic void mga_crtc_commit(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct mga_device *mdev = dev->dev_private;\r\nconst struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\nu8 tmp;\r\nif (mdev->type == G200_WB || mdev->type == G200_EW3)\r\nmga_g200wb_commit(crtc);\r\nif (mdev->type == G200_SE_A || mdev->type == G200_SE_B) {\r\nmsleep(50);\r\nWREG_SEQ(1, 0x0);\r\nmsleep(20);\r\nWREG_SEQ(0, 0x3);\r\n} else {\r\nWREG8(MGAREG_SEQ_INDEX, 0x1);\r\ntmp = RREG8(MGAREG_SEQ_DATA);\r\ntmp &= ~0x20;\r\nWREG_SEQ(0x1, tmp);\r\nWREG_SEQ(0, 3);\r\n}\r\ncrtc_funcs->dpms(crtc, DRM_MODE_DPMS_ON);\r\n}\r\nstatic void mga_crtc_gamma_set(struct drm_crtc *crtc, u16 *red, u16 *green,\r\nu16 *blue, uint32_t start, uint32_t size)\r\n{\r\nstruct mga_crtc *mga_crtc = to_mga_crtc(crtc);\r\nint end = (start + size > MGAG200_LUT_SIZE) ? MGAG200_LUT_SIZE : start + size;\r\nint i;\r\nfor (i = start; i < end; i++) {\r\nmga_crtc->lut_r[i] = red[i] >> 8;\r\nmga_crtc->lut_g[i] = green[i] >> 8;\r\nmga_crtc->lut_b[i] = blue[i] >> 8;\r\n}\r\nmga_crtc_load_lut(crtc);\r\n}\r\nstatic void mga_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nstruct mga_crtc *mga_crtc = to_mga_crtc(crtc);\r\ndrm_crtc_cleanup(crtc);\r\nkfree(mga_crtc);\r\n}\r\nstatic void mga_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nint ret;\r\nDRM_DEBUG_KMS("\n");\r\nmga_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);\r\nif (crtc->primary->fb) {\r\nstruct mga_framebuffer *mga_fb = to_mga_framebuffer(crtc->primary->fb);\r\nstruct drm_gem_object *obj = mga_fb->obj;\r\nstruct mgag200_bo *bo = gem_to_mga_bo(obj);\r\nret = mgag200_bo_reserve(bo, false);\r\nif (ret)\r\nreturn;\r\nmgag200_bo_push_sysram(bo);\r\nmgag200_bo_unreserve(bo);\r\n}\r\ncrtc->primary->fb = NULL;\r\n}\r\nstatic void mga_crtc_init(struct mga_device *mdev)\r\n{\r\nstruct mga_crtc *mga_crtc;\r\nint i;\r\nmga_crtc = kzalloc(sizeof(struct mga_crtc) +\r\n(MGAG200FB_CONN_LIMIT * sizeof(struct drm_connector *)),\r\nGFP_KERNEL);\r\nif (mga_crtc == NULL)\r\nreturn;\r\ndrm_crtc_init(mdev->dev, &mga_crtc->base, &mga_crtc_funcs);\r\ndrm_mode_crtc_set_gamma_size(&mga_crtc->base, MGAG200_LUT_SIZE);\r\nmdev->mode_info.crtc = mga_crtc;\r\nfor (i = 0; i < MGAG200_LUT_SIZE; i++) {\r\nmga_crtc->lut_r[i] = i;\r\nmga_crtc->lut_g[i] = i;\r\nmga_crtc->lut_b[i] = i;\r\n}\r\ndrm_crtc_helper_add(&mga_crtc->base, &mga_helper_funcs);\r\n}\r\nvoid mga_crtc_fb_gamma_set(struct drm_crtc *crtc, u16 red, u16 green,\r\nu16 blue, int regno)\r\n{\r\nstruct mga_crtc *mga_crtc = to_mga_crtc(crtc);\r\nmga_crtc->lut_r[regno] = red >> 8;\r\nmga_crtc->lut_g[regno] = green >> 8;\r\nmga_crtc->lut_b[regno] = blue >> 8;\r\n}\r\nvoid mga_crtc_fb_gamma_get(struct drm_crtc *crtc, u16 *red, u16 *green,\r\nu16 *blue, int regno)\r\n{\r\nstruct mga_crtc *mga_crtc = to_mga_crtc(crtc);\r\n*red = (u16)mga_crtc->lut_r[regno] << 8;\r\n*green = (u16)mga_crtc->lut_g[regno] << 8;\r\n*blue = (u16)mga_crtc->lut_b[regno] << 8;\r\n}\r\nstatic bool mga_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void mga_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\n}\r\nstatic void mga_encoder_dpms(struct drm_encoder *encoder, int state)\r\n{\r\nreturn;\r\n}\r\nstatic void mga_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void mga_encoder_commit(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void mga_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct mga_encoder *mga_encoder = to_mga_encoder(encoder);\r\ndrm_encoder_cleanup(encoder);\r\nkfree(mga_encoder);\r\n}\r\nstatic struct drm_encoder *mga_encoder_init(struct drm_device *dev)\r\n{\r\nstruct drm_encoder *encoder;\r\nstruct mga_encoder *mga_encoder;\r\nmga_encoder = kzalloc(sizeof(struct mga_encoder), GFP_KERNEL);\r\nif (!mga_encoder)\r\nreturn NULL;\r\nencoder = &mga_encoder->base;\r\nencoder->possible_crtcs = 0x1;\r\ndrm_encoder_init(dev, encoder, &mga_encoder_encoder_funcs,\r\nDRM_MODE_ENCODER_DAC);\r\ndrm_encoder_helper_add(encoder, &mga_encoder_helper_funcs);\r\nreturn encoder;\r\n}\r\nstatic int mga_vga_get_modes(struct drm_connector *connector)\r\n{\r\nstruct mga_connector *mga_connector = to_mga_connector(connector);\r\nstruct edid *edid;\r\nint ret = 0;\r\nedid = drm_get_edid(connector, &mga_connector->i2c->adapter);\r\nif (edid) {\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\nret = drm_add_edid_modes(connector, edid);\r\nkfree(edid);\r\n}\r\nreturn ret;\r\n}\r\nstatic uint32_t mga_vga_calculate_mode_bandwidth(struct drm_display_mode *mode,\r\nint bits_per_pixel)\r\n{\r\nuint32_t total_area, divisor;\r\nint64_t active_area, pixels_per_second, bandwidth;\r\nuint64_t bytes_per_pixel = (bits_per_pixel + 7) / 8;\r\ndivisor = 1024;\r\nif (!mode->htotal || !mode->vtotal || !mode->clock)\r\nreturn 0;\r\nactive_area = mode->hdisplay * mode->vdisplay;\r\ntotal_area = mode->htotal * mode->vtotal;\r\npixels_per_second = active_area * mode->clock * 1000;\r\ndo_div(pixels_per_second, total_area);\r\nbandwidth = pixels_per_second * bytes_per_pixel * 100;\r\ndo_div(bandwidth, divisor);\r\nreturn (uint32_t)(bandwidth);\r\n}\r\nstatic int mga_vga_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct mga_device *mdev = (struct mga_device*)dev->dev_private;\r\nint bpp = 32;\r\nif (IS_G200_SE(mdev)) {\r\nif (mdev->unique_rev_id == 0x01) {\r\nif (mode->hdisplay > 1600)\r\nreturn MODE_VIRTUAL_X;\r\nif (mode->vdisplay > 1200)\r\nreturn MODE_VIRTUAL_Y;\r\nif (mga_vga_calculate_mode_bandwidth(mode, bpp)\r\n> (24400 * 1024))\r\nreturn MODE_BANDWIDTH;\r\n} else if (mdev->unique_rev_id == 0x02) {\r\nif (mode->hdisplay > 1920)\r\nreturn MODE_VIRTUAL_X;\r\nif (mode->vdisplay > 1200)\r\nreturn MODE_VIRTUAL_Y;\r\nif (mga_vga_calculate_mode_bandwidth(mode, bpp)\r\n> (30100 * 1024))\r\nreturn MODE_BANDWIDTH;\r\n}\r\n} else if (mdev->type == G200_WB) {\r\nif (mode->hdisplay > 1280)\r\nreturn MODE_VIRTUAL_X;\r\nif (mode->vdisplay > 1024)\r\nreturn MODE_VIRTUAL_Y;\r\nif (mga_vga_calculate_mode_bandwidth(mode,\r\nbpp > (31877 * 1024)))\r\nreturn MODE_BANDWIDTH;\r\n} else if (mdev->type == G200_EV &&\r\n(mga_vga_calculate_mode_bandwidth(mode, bpp)\r\n> (32700 * 1024))) {\r\nreturn MODE_BANDWIDTH;\r\n} else if (mdev->type == G200_EH &&\r\n(mga_vga_calculate_mode_bandwidth(mode, bpp)\r\n> (37500 * 1024))) {\r\nreturn MODE_BANDWIDTH;\r\n} else if (mdev->type == G200_ER &&\r\n(mga_vga_calculate_mode_bandwidth(mode,\r\nbpp) > (55000 * 1024))) {\r\nreturn MODE_BANDWIDTH;\r\n}\r\nif ((mode->hdisplay % 8) != 0 || (mode->hsync_start % 8) != 0 ||\r\n(mode->hsync_end % 8) != 0 || (mode->htotal % 8) != 0) {\r\nreturn MODE_H_ILLEGAL;\r\n}\r\nif (mode->crtc_hdisplay > 2048 || mode->crtc_hsync_start > 4096 ||\r\nmode->crtc_hsync_end > 4096 || mode->crtc_htotal > 4096 ||\r\nmode->crtc_vdisplay > 2048 || mode->crtc_vsync_start > 4096 ||\r\nmode->crtc_vsync_end > 4096 || mode->crtc_vtotal > 4096) {\r\nreturn MODE_BAD;\r\n}\r\nif (connector->cmdline_mode.specified) {\r\nif (connector->cmdline_mode.bpp_specified)\r\nbpp = connector->cmdline_mode.bpp;\r\n}\r\nif ((mode->hdisplay * mode->vdisplay * (bpp/8)) > mdev->mc.vram_size) {\r\nif (connector->cmdline_mode.specified)\r\nconnector->cmdline_mode.specified = false;\r\nreturn MODE_BAD;\r\n}\r\nreturn MODE_OK;\r\n}\r\nstatic struct drm_encoder *mga_connector_best_encoder(struct drm_connector\r\n*connector)\r\n{\r\nint enc_id = connector->encoder_ids[0];\r\nif (enc_id)\r\nreturn drm_encoder_find(connector->dev, enc_id);\r\nreturn NULL;\r\n}\r\nstatic enum drm_connector_status mga_vga_detect(struct drm_connector\r\n*connector, bool force)\r\n{\r\nreturn connector_status_connected;\r\n}\r\nstatic void mga_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct mga_connector *mga_connector = to_mga_connector(connector);\r\nmgag200_i2c_destroy(mga_connector->i2c);\r\ndrm_connector_cleanup(connector);\r\nkfree(connector);\r\n}\r\nstatic struct drm_connector *mga_vga_init(struct drm_device *dev)\r\n{\r\nstruct drm_connector *connector;\r\nstruct mga_connector *mga_connector;\r\nmga_connector = kzalloc(sizeof(struct mga_connector), GFP_KERNEL);\r\nif (!mga_connector)\r\nreturn NULL;\r\nconnector = &mga_connector->base;\r\ndrm_connector_init(dev, connector,\r\n&mga_vga_connector_funcs, DRM_MODE_CONNECTOR_VGA);\r\ndrm_connector_helper_add(connector, &mga_vga_connector_helper_funcs);\r\ndrm_connector_register(connector);\r\nmga_connector->i2c = mgag200_i2c_create(dev);\r\nif (!mga_connector->i2c)\r\nDRM_ERROR("failed to add ddc bus\n");\r\nreturn connector;\r\n}\r\nint mgag200_modeset_init(struct mga_device *mdev)\r\n{\r\nstruct drm_encoder *encoder;\r\nstruct drm_connector *connector;\r\nint ret;\r\nmdev->mode_info.mode_config_initialized = true;\r\nmdev->dev->mode_config.max_width = MGAG200_MAX_FB_WIDTH;\r\nmdev->dev->mode_config.max_height = MGAG200_MAX_FB_HEIGHT;\r\nmdev->dev->mode_config.fb_base = mdev->mc.vram_base;\r\nmga_crtc_init(mdev);\r\nencoder = mga_encoder_init(mdev->dev);\r\nif (!encoder) {\r\nDRM_ERROR("mga_encoder_init failed\n");\r\nreturn -1;\r\n}\r\nconnector = mga_vga_init(mdev->dev);\r\nif (!connector) {\r\nDRM_ERROR("mga_vga_init failed\n");\r\nreturn -1;\r\n}\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nret = mgag200_fbdev_init(mdev);\r\nif (ret) {\r\nDRM_ERROR("mga_fbdev_init failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid mgag200_modeset_fini(struct mga_device *mdev)\r\n{\r\n}
