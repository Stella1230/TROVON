static void\r\ncrtc_wr_cio_state(struct drm_crtc *crtc, struct nv04_crtc_reg *crtcstate, int index)\r\n{\r\nNVWriteVgaCrtc(crtc->dev, nouveau_crtc(crtc)->index, index,\r\ncrtcstate->CRTC[index]);\r\n}\r\nstatic void nv_crtc_set_digital_vibrance(struct drm_crtc *crtc, int level)\r\n{\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct nv04_crtc_reg *regp = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index];\r\nregp->CRTC[NV_CIO_CRE_CSB] = nv_crtc->saturation = level;\r\nif (nv_crtc->saturation && nv_gf4_disp_arch(crtc->dev)) {\r\nregp->CRTC[NV_CIO_CRE_CSB] = 0x80;\r\nregp->CRTC[NV_CIO_CRE_5B] = nv_crtc->saturation << 2;\r\ncrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_5B);\r\n}\r\ncrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_CSB);\r\n}\r\nstatic void nv_crtc_set_image_sharpening(struct drm_crtc *crtc, int level)\r\n{\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct nv04_crtc_reg *regp = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index];\r\nnv_crtc->sharpness = level;\r\nif (level < 0)\r\nlevel += 0x40;\r\nregp->ramdac_634 = level;\r\nNVWriteRAMDAC(crtc->dev, nv_crtc->index, NV_PRAMDAC_634, regp->ramdac_634);\r\n}\r\nstatic void nv_crtc_calc_state_ext(struct drm_crtc *crtc, struct drm_display_mode * mode, int dot_clock)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvkm_bios *bios = nvxx_bios(&drm->device);\r\nstruct nvkm_clk *clk = nvxx_clk(&drm->device);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nstruct nv04_mode_state *state = &nv04_display(dev)->mode_reg;\r\nstruct nv04_crtc_reg *regp = &state->crtc_reg[nv_crtc->index];\r\nstruct nvkm_pll_vals *pv = &regp->pllvals;\r\nstruct nvbios_pll pll_lim;\r\nif (nvbios_pll_parse(bios, nv_crtc->index ? PLL_VPLL1 : PLL_VPLL0,\r\n&pll_lim))\r\nreturn;\r\npv->NM2 = 0;\r\nif (drm->device.info.chipset > 0x40 && dot_clock <= (pll_lim.vco1.max_freq / 2))\r\nmemset(&pll_lim.vco2, 0, sizeof(pll_lim.vco2));\r\nif (!clk->pll_calc(clk, &pll_lim, dot_clock, pv))\r\nreturn;\r\nstate->pllsel &= PLLSEL_VPLL1_MASK | PLLSEL_VPLL2_MASK | PLLSEL_TV_MASK;\r\nif (drm->device.info.family == NV_DEVICE_INFO_V0_CURIE)\r\nstate->pllsel |= NV_PRAMDAC_PLL_COEFF_SELECT_USE_VPLL2_TRUE;\r\nif (drm->device.info.chipset < 0x41)\r\nstate->pllsel |= NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE_PROG_MPLL |\r\nNV_PRAMDAC_PLL_COEFF_SELECT_SOURCE_PROG_NVPLL;\r\nstate->pllsel |= nv_crtc->index ? PLLSEL_VPLL2_MASK : PLLSEL_VPLL1_MASK;\r\nif (pv->NM2)\r\nNV_DEBUG(drm, "vpll: n1 %d n2 %d m1 %d m2 %d log2p %d\n",\r\npv->N1, pv->N2, pv->M1, pv->M2, pv->log2P);\r\nelse\r\nNV_DEBUG(drm, "vpll: n %d m %d log2p %d\n",\r\npv->N1, pv->M1, pv->log2P);\r\nnv_crtc->cursor.set_offset(nv_crtc, nv_crtc->cursor.offset);\r\n}\r\nstatic void\r\nnv_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nunsigned char seq1 = 0, crtc17 = 0;\r\nunsigned char crtc1A;\r\nNV_DEBUG(drm, "Setting dpms mode %d on CRTC %d\n", mode,\r\nnv_crtc->index);\r\nif (nv_crtc->last_dpms == mode)\r\nreturn;\r\nnv_crtc->last_dpms = mode;\r\nif (nv_two_heads(dev))\r\nNVSetOwner(dev, nv_crtc->index);\r\ncrtc1A = NVReadVgaCrtc(dev, nv_crtc->index,\r\nNV_CIO_CRE_RPC1_INDEX) & ~0xC0;\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_STANDBY:\r\nseq1 = 0x20;\r\ncrtc17 = 0x80;\r\ncrtc1A |= 0x80;\r\nbreak;\r\ncase DRM_MODE_DPMS_SUSPEND:\r\nseq1 = 0x20;\r\ncrtc17 = 0x80;\r\ncrtc1A |= 0x40;\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\nseq1 = 0x20;\r\ncrtc17 = 0x00;\r\ncrtc1A |= 0xC0;\r\nbreak;\r\ncase DRM_MODE_DPMS_ON:\r\ndefault:\r\nseq1 = 0x00;\r\ncrtc17 = 0x80;\r\nbreak;\r\n}\r\nNVVgaSeqReset(dev, nv_crtc->index, true);\r\nseq1 |= (NVReadVgaSeq(dev, nv_crtc->index, NV_VIO_SR_CLOCK_INDEX) & ~0x20);\r\nNVWriteVgaSeq(dev, nv_crtc->index, NV_VIO_SR_CLOCK_INDEX, seq1);\r\ncrtc17 |= (NVReadVgaCrtc(dev, nv_crtc->index, NV_CIO_CR_MODE_INDEX) & ~0x80);\r\nmdelay(10);\r\nNVWriteVgaCrtc(dev, nv_crtc->index, NV_CIO_CR_MODE_INDEX, crtc17);\r\nNVVgaSeqReset(dev, nv_crtc->index, false);\r\nNVWriteVgaCrtc(dev, nv_crtc->index, NV_CIO_CRE_RPC1_INDEX, crtc1A);\r\n}\r\nstatic bool\r\nnv_crtc_mode_fixup(struct drm_crtc *crtc, const struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void\r\nnv_crtc_mode_set_vga(struct drm_crtc *crtc, struct drm_display_mode *mode)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nstruct nv04_crtc_reg *regp = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index];\r\nstruct drm_framebuffer *fb = crtc->primary->fb;\r\nint horizDisplay = (mode->crtc_hdisplay >> 3) - 1;\r\nint horizStart = (mode->crtc_hsync_start >> 3) + 1;\r\nint horizEnd = (mode->crtc_hsync_end >> 3) + 1;\r\nint horizTotal = (mode->crtc_htotal >> 3) - 5;\r\nint horizBlankStart = (mode->crtc_hdisplay >> 3) - 1;\r\nint horizBlankEnd = (mode->crtc_htotal >> 3) - 1;\r\nint vertDisplay = mode->crtc_vdisplay - 1;\r\nint vertStart = mode->crtc_vsync_start - 1;\r\nint vertEnd = mode->crtc_vsync_end - 1;\r\nint vertTotal = mode->crtc_vtotal - 2;\r\nint vertBlankStart = mode->crtc_vdisplay - 1;\r\nint vertBlankEnd = mode->crtc_vtotal - 1;\r\nstruct drm_encoder *encoder;\r\nbool fp_output = false;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nif (encoder->crtc == crtc &&\r\n(nv_encoder->dcb->type == DCB_OUTPUT_LVDS ||\r\nnv_encoder->dcb->type == DCB_OUTPUT_TMDS))\r\nfp_output = true;\r\n}\r\nif (fp_output) {\r\nvertStart = vertTotal - 3;\r\nvertEnd = vertTotal - 2;\r\nvertBlankStart = vertStart;\r\nhorizStart = horizTotal - 5;\r\nhorizEnd = horizTotal - 2;\r\nhorizBlankEnd = horizTotal + 4;\r\n#if 0\r\nif (dev->overlayAdaptor && drm->device.info.family >= NV_DEVICE_INFO_V0_CELSIUS)\r\nhorizTotal += 2;\r\n#endif\r\n}\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nvertTotal |= 1;\r\n#if 0\r\nErrorF("horizDisplay: 0x%X \n", horizDisplay);\r\nErrorF("horizStart: 0x%X \n", horizStart);\r\nErrorF("horizEnd: 0x%X \n", horizEnd);\r\nErrorF("horizTotal: 0x%X \n", horizTotal);\r\nErrorF("horizBlankStart: 0x%X \n", horizBlankStart);\r\nErrorF("horizBlankEnd: 0x%X \n", horizBlankEnd);\r\nErrorF("vertDisplay: 0x%X \n", vertDisplay);\r\nErrorF("vertStart: 0x%X \n", vertStart);\r\nErrorF("vertEnd: 0x%X \n", vertEnd);\r\nErrorF("vertTotal: 0x%X \n", vertTotal);\r\nErrorF("vertBlankStart: 0x%X \n", vertBlankStart);\r\nErrorF("vertBlankEnd: 0x%X \n", vertBlankEnd);\r\n#endif\r\nif ((mode->flags & (DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NHSYNC))\r\n&& (mode->flags & (DRM_MODE_FLAG_PVSYNC | DRM_MODE_FLAG_NVSYNC))) {\r\nregp->MiscOutReg = 0x23;\r\nif (mode->flags & DRM_MODE_FLAG_NHSYNC)\r\nregp->MiscOutReg |= 0x40;\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nregp->MiscOutReg |= 0x80;\r\n} else {\r\nint vdisplay = mode->vdisplay;\r\nif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\r\nvdisplay *= 2;\r\nif (mode->vscan > 1)\r\nvdisplay *= mode->vscan;\r\nif (vdisplay < 400)\r\nregp->MiscOutReg = 0xA3;\r\nelse if (vdisplay < 480)\r\nregp->MiscOutReg = 0x63;\r\nelse if (vdisplay < 768)\r\nregp->MiscOutReg = 0xE3;\r\nelse\r\nregp->MiscOutReg = 0x23;\r\n}\r\nregp->Sequencer[NV_VIO_SR_RESET_INDEX] = 0x00;\r\nif (mode->flags & DRM_MODE_FLAG_CLKDIV2)\r\nregp->Sequencer[NV_VIO_SR_CLOCK_INDEX] = 0x29;\r\nelse\r\nregp->Sequencer[NV_VIO_SR_CLOCK_INDEX] = 0x21;\r\nregp->Sequencer[NV_VIO_SR_PLANE_MASK_INDEX] = 0x0F;\r\nregp->Sequencer[NV_VIO_SR_CHAR_MAP_INDEX] = 0x00;\r\nregp->Sequencer[NV_VIO_SR_MEM_MODE_INDEX] = 0x0E;\r\nregp->CRTC[NV_CIO_CR_HDT_INDEX] = horizTotal;\r\nregp->CRTC[NV_CIO_CR_HDE_INDEX] = horizDisplay;\r\nregp->CRTC[NV_CIO_CR_HBS_INDEX] = horizBlankStart;\r\nregp->CRTC[NV_CIO_CR_HBE_INDEX] = (1 << 7) |\r\nXLATE(horizBlankEnd, 0, NV_CIO_CR_HBE_4_0);\r\nregp->CRTC[NV_CIO_CR_HRS_INDEX] = horizStart;\r\nregp->CRTC[NV_CIO_CR_HRE_INDEX] = XLATE(horizBlankEnd, 5, NV_CIO_CR_HRE_HBE_5) |\r\nXLATE(horizEnd, 0, NV_CIO_CR_HRE_4_0);\r\nregp->CRTC[NV_CIO_CR_VDT_INDEX] = vertTotal;\r\nregp->CRTC[NV_CIO_CR_OVL_INDEX] = XLATE(vertStart, 9, NV_CIO_CR_OVL_VRS_9) |\r\nXLATE(vertDisplay, 9, NV_CIO_CR_OVL_VDE_9) |\r\nXLATE(vertTotal, 9, NV_CIO_CR_OVL_VDT_9) |\r\n(1 << 4) |\r\nXLATE(vertBlankStart, 8, NV_CIO_CR_OVL_VBS_8) |\r\nXLATE(vertStart, 8, NV_CIO_CR_OVL_VRS_8) |\r\nXLATE(vertDisplay, 8, NV_CIO_CR_OVL_VDE_8) |\r\nXLATE(vertTotal, 8, NV_CIO_CR_OVL_VDT_8);\r\nregp->CRTC[NV_CIO_CR_RSAL_INDEX] = 0x00;\r\nregp->CRTC[NV_CIO_CR_CELL_HT_INDEX] = ((mode->flags & DRM_MODE_FLAG_DBLSCAN) ? MASK(NV_CIO_CR_CELL_HT_SCANDBL) : 0) |\r\n1 << 6 |\r\nXLATE(vertBlankStart, 9, NV_CIO_CR_CELL_HT_VBS_9);\r\nregp->CRTC[NV_CIO_CR_CURS_ST_INDEX] = 0x00;\r\nregp->CRTC[NV_CIO_CR_CURS_END_INDEX] = 0x00;\r\nregp->CRTC[NV_CIO_CR_SA_HI_INDEX] = 0x00;\r\nregp->CRTC[NV_CIO_CR_SA_LO_INDEX] = 0x00;\r\nregp->CRTC[NV_CIO_CR_TCOFF_HI_INDEX] = 0x00;\r\nregp->CRTC[NV_CIO_CR_TCOFF_LO_INDEX] = 0x00;\r\nregp->CRTC[NV_CIO_CR_VRS_INDEX] = vertStart;\r\nregp->CRTC[NV_CIO_CR_VRE_INDEX] = 1 << 5 | XLATE(vertEnd, 0, NV_CIO_CR_VRE_3_0);\r\nregp->CRTC[NV_CIO_CR_VDE_INDEX] = vertDisplay;\r\nregp->CRTC[NV_CIO_CR_OFFSET_INDEX] = fb->pitches[0] / 8;\r\nregp->CRTC[NV_CIO_CR_ULINE_INDEX] = 0x00;\r\nregp->CRTC[NV_CIO_CR_VBS_INDEX] = vertBlankStart;\r\nregp->CRTC[NV_CIO_CR_VBE_INDEX] = vertBlankEnd;\r\nregp->CRTC[NV_CIO_CR_MODE_INDEX] = 0x43;\r\nregp->CRTC[NV_CIO_CR_LCOMP_INDEX] = 0xff;\r\nregp->CRTC[NV_CIO_CRE_RPC0_INDEX] =\r\nXLATE(fb->pitches[0] / 8, 8, NV_CIO_CRE_RPC0_OFFSET_10_8);\r\nregp->CRTC[NV_CIO_CRE_42] =\r\nXLATE(fb->pitches[0] / 8, 11, NV_CIO_CRE_42_OFFSET_11);\r\nregp->CRTC[NV_CIO_CRE_RPC1_INDEX] = mode->crtc_hdisplay < 1280 ?\r\nMASK(NV_CIO_CRE_RPC1_LARGE) : 0x00;\r\nregp->CRTC[NV_CIO_CRE_LSR_INDEX] = XLATE(horizBlankEnd, 6, NV_CIO_CRE_LSR_HBE_6) |\r\nXLATE(vertBlankStart, 10, NV_CIO_CRE_LSR_VBS_10) |\r\nXLATE(vertStart, 10, NV_CIO_CRE_LSR_VRS_10) |\r\nXLATE(vertDisplay, 10, NV_CIO_CRE_LSR_VDE_10) |\r\nXLATE(vertTotal, 10, NV_CIO_CRE_LSR_VDT_10);\r\nregp->CRTC[NV_CIO_CRE_HEB__INDEX] = XLATE(horizStart, 8, NV_CIO_CRE_HEB_HRS_8) |\r\nXLATE(horizBlankStart, 8, NV_CIO_CRE_HEB_HBS_8) |\r\nXLATE(horizDisplay, 8, NV_CIO_CRE_HEB_HDE_8) |\r\nXLATE(horizTotal, 8, NV_CIO_CRE_HEB_HDT_8);\r\nregp->CRTC[NV_CIO_CRE_EBR_INDEX] = XLATE(vertBlankStart, 11, NV_CIO_CRE_EBR_VBS_11) |\r\nXLATE(vertStart, 11, NV_CIO_CRE_EBR_VRS_11) |\r\nXLATE(vertDisplay, 11, NV_CIO_CRE_EBR_VDE_11) |\r\nXLATE(vertTotal, 11, NV_CIO_CRE_EBR_VDT_11);\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE) {\r\nhorizTotal = (horizTotal >> 1) & ~1;\r\nregp->CRTC[NV_CIO_CRE_ILACE__INDEX] = horizTotal;\r\nregp->CRTC[NV_CIO_CRE_HEB__INDEX] |= XLATE(horizTotal, 8, NV_CIO_CRE_HEB_ILC_8);\r\n} else\r\nregp->CRTC[NV_CIO_CRE_ILACE__INDEX] = 0xff;\r\nregp->Graphics[NV_VIO_GX_SR_INDEX] = 0x00;\r\nregp->Graphics[NV_VIO_GX_SREN_INDEX] = 0x00;\r\nregp->Graphics[NV_VIO_GX_CCOMP_INDEX] = 0x00;\r\nregp->Graphics[NV_VIO_GX_ROP_INDEX] = 0x00;\r\nregp->Graphics[NV_VIO_GX_READ_MAP_INDEX] = 0x00;\r\nregp->Graphics[NV_VIO_GX_MODE_INDEX] = 0x40;\r\nregp->Graphics[NV_VIO_GX_MISC_INDEX] = 0x05;\r\nregp->Graphics[NV_VIO_GX_DONT_CARE_INDEX] = 0x0F;\r\nregp->Graphics[NV_VIO_GX_BIT_MASK_INDEX] = 0xFF;\r\nregp->Attribute[0] = 0x00;\r\nregp->Attribute[1] = 0x01;\r\nregp->Attribute[2] = 0x02;\r\nregp->Attribute[3] = 0x03;\r\nregp->Attribute[4] = 0x04;\r\nregp->Attribute[5] = 0x05;\r\nregp->Attribute[6] = 0x06;\r\nregp->Attribute[7] = 0x07;\r\nregp->Attribute[8] = 0x08;\r\nregp->Attribute[9] = 0x09;\r\nregp->Attribute[10] = 0x0A;\r\nregp->Attribute[11] = 0x0B;\r\nregp->Attribute[12] = 0x0C;\r\nregp->Attribute[13] = 0x0D;\r\nregp->Attribute[14] = 0x0E;\r\nregp->Attribute[15] = 0x0F;\r\nregp->Attribute[NV_CIO_AR_MODE_INDEX] = 0x01;\r\nregp->Attribute[NV_CIO_AR_OSCAN_INDEX] = 0x00;\r\nregp->Attribute[NV_CIO_AR_PLANE_INDEX] = 0x0F;\r\nregp->Attribute[NV_CIO_AR_HPP_INDEX] = 0x00;\r\nregp->Attribute[NV_CIO_AR_CSEL_INDEX] = 0x00;\r\n}\r\nstatic void\r\nnv_crtc_mode_set_regs(struct drm_crtc *crtc, struct drm_display_mode * mode)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nstruct nv04_crtc_reg *regp = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index];\r\nstruct nv04_crtc_reg *savep = &nv04_display(dev)->saved_reg.crtc_reg[nv_crtc->index];\r\nstruct drm_encoder *encoder;\r\nbool lvds_output = false, tmds_output = false, tv_output = false,\r\noff_chip_digital = false;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nbool digital = false;\r\nif (encoder->crtc != crtc)\r\ncontinue;\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_LVDS)\r\ndigital = lvds_output = true;\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_TV)\r\ntv_output = true;\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_TMDS)\r\ndigital = tmds_output = true;\r\nif (nv_encoder->dcb->location != DCB_LOC_ON_CHIP && digital)\r\noff_chip_digital = true;\r\n}\r\nregp->CRTC[NV_CIO_CRE_ENH_INDEX] = savep->CRTC[NV_CIO_CRE_ENH_INDEX] & ~(1<<5);\r\nregp->crtc_eng_ctrl = 0;\r\nif (nv_crtc->index == 0)\r\nregp->crtc_eng_ctrl |= NV_CRTC_FSEL_I2C;\r\n#if 0\r\nif (dev->overlayAdaptor) {\r\nNVPortPrivPtr pPriv = GET_OVERLAY_PRIVATE(dev);\r\nif (pPriv->overlayCRTC == nv_crtc->index)\r\nregp->crtc_eng_ctrl |= NV_CRTC_FSEL_OVERLAY;\r\n}\r\n#endif\r\nregp->cursor_cfg = NV_PCRTC_CURSOR_CONFIG_CUR_LINES_64 |\r\nNV_PCRTC_CURSOR_CONFIG_CUR_PIXELS_64 |\r\nNV_PCRTC_CURSOR_CONFIG_ADDRESS_SPACE_PNVM;\r\nif (drm->device.info.chipset >= 0x11)\r\nregp->cursor_cfg |= NV_PCRTC_CURSOR_CONFIG_CUR_BPP_32;\r\nif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\r\nregp->cursor_cfg |= NV_PCRTC_CURSOR_CONFIG_DOUBLE_SCAN_ENABLE;\r\nregp->CRTC[NV_CIO_CRE_53] = 0;\r\nregp->CRTC[NV_CIO_CRE_54] = 0;\r\nif (lvds_output)\r\nregp->CRTC[NV_CIO_CRE_SCRATCH3__INDEX] = 0x11;\r\nelse if (tmds_output)\r\nregp->CRTC[NV_CIO_CRE_SCRATCH3__INDEX] = 0x88;\r\nelse\r\nregp->CRTC[NV_CIO_CRE_SCRATCH3__INDEX] = 0x22;\r\nregp->CRTC[NV_CIO_CRE_SCRATCH4__INDEX] = savep->CRTC[NV_CIO_CRE_SCRATCH4__INDEX];\r\nnv_crtc_set_digital_vibrance(crtc, nv_crtc->saturation);\r\nif (nv_crtc->index == 0)\r\nregp->CRTC[NV_CIO_CRE_4B] = savep->CRTC[NV_CIO_CRE_4B] | 0x80;\r\nregp->CRTC[NV_CIO_CRE_TVOUT_LATENCY] = nv04_display(dev)->saved_reg.crtc_reg[0].CRTC[NV_CIO_CRE_TVOUT_LATENCY];\r\nif (!nv_crtc->index)\r\nregp->CRTC[NV_CIO_CRE_TVOUT_LATENCY] += 4;\r\nregp->CRTC[NV_CIO_CRE_59] = off_chip_digital;\r\nif (drm->device.info.family >= NV_DEVICE_INFO_V0_RANKINE)\r\nregp->CRTC[0x9f] = off_chip_digital ? 0x11 : 0x1;\r\nregp->crtc_830 = mode->crtc_vdisplay - 3;\r\nregp->crtc_834 = mode->crtc_vdisplay - 1;\r\nif (drm->device.info.family == NV_DEVICE_INFO_V0_CURIE)\r\nregp->crtc_850 = NVReadCRTC(dev, 0, NV_PCRTC_850);\r\nif (drm->device.info.family >= NV_DEVICE_INFO_V0_RANKINE)\r\nregp->gpio_ext = NVReadCRTC(dev, 0, NV_PCRTC_GPIO_EXT);\r\nif (drm->device.info.family >= NV_DEVICE_INFO_V0_CELSIUS)\r\nregp->crtc_cfg = NV10_PCRTC_CONFIG_START_ADDRESS_HSYNC;\r\nelse\r\nregp->crtc_cfg = NV04_PCRTC_CONFIG_START_ADDRESS_HSYNC;\r\nif (drm->device.info.family == NV_DEVICE_INFO_V0_CURIE) {\r\nregp->CRTC[NV_CIO_CRE_85] = 0xFF;\r\nregp->CRTC[NV_CIO_CRE_86] = 0x1;\r\n}\r\nregp->CRTC[NV_CIO_CRE_PIXEL_INDEX] = (crtc->primary->fb->depth + 1) / 8;\r\nif (lvds_output || tmds_output || tv_output)\r\nregp->CRTC[NV_CIO_CRE_PIXEL_INDEX] |= (1 << 7);\r\nif (drm->device.info.family >= NV_DEVICE_INFO_V0_CELSIUS)\r\nregp->nv10_cursync = (1 << 25);\r\nregp->ramdac_gen_ctrl = NV_PRAMDAC_GENERAL_CONTROL_BPC_8BITS |\r\nNV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_SEL |\r\nNV_PRAMDAC_GENERAL_CONTROL_PIXMIX_ON;\r\nif (crtc->primary->fb->depth == 16)\r\nregp->ramdac_gen_ctrl |= NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_SEL;\r\nif (drm->device.info.chipset >= 0x11)\r\nregp->ramdac_gen_ctrl |= NV_PRAMDAC_GENERAL_CONTROL_PIPE_LONG;\r\nregp->ramdac_630 = 0;\r\nregp->tv_setup = 0;\r\nnv_crtc_set_image_sharpening(crtc, nv_crtc->sharpness);\r\nregp->ramdac_8c0 = 0x100;\r\nregp->ramdac_a20 = 0x0;\r\nregp->ramdac_a24 = 0xfffff;\r\nregp->ramdac_a34 = 0x1;\r\n}\r\nstatic int\r\nnv_crtc_swap_fbs(struct drm_crtc *crtc, struct drm_framebuffer *old_fb)\r\n{\r\nstruct nv04_display *disp = nv04_display(crtc->dev);\r\nstruct nouveau_framebuffer *nvfb = nouveau_framebuffer(crtc->primary->fb);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nint ret;\r\nret = nouveau_bo_pin(nvfb->nvbo, TTM_PL_FLAG_VRAM, false);\r\nif (ret == 0) {\r\nif (disp->image[nv_crtc->index])\r\nnouveau_bo_unpin(disp->image[nv_crtc->index]);\r\nnouveau_bo_ref(nvfb->nvbo, &disp->image[nv_crtc->index]);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nnv_crtc_mode_set(struct drm_crtc *crtc, struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y, struct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nint ret;\r\nNV_DEBUG(drm, "CTRC mode on CRTC %d:\n", nv_crtc->index);\r\ndrm_mode_debug_printmodeline(adjusted_mode);\r\nret = nv_crtc_swap_fbs(crtc, old_fb);\r\nif (ret)\r\nreturn ret;\r\nnv_lock_vga_crtc_shadow(dev, nv_crtc->index, -1);\r\nnv_crtc_mode_set_vga(crtc, adjusted_mode);\r\nif (drm->device.info.family == NV_DEVICE_INFO_V0_CURIE)\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK, nv04_display(dev)->mode_reg.sel_clk);\r\nnv_crtc_mode_set_regs(crtc, adjusted_mode);\r\nnv_crtc_calc_state_ext(crtc, mode, adjusted_mode->clock);\r\nreturn 0;\r\n}\r\nstatic void nv_crtc_save(struct drm_crtc *crtc)\r\n{\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct nv04_mode_state *state = &nv04_display(dev)->mode_reg;\r\nstruct nv04_crtc_reg *crtc_state = &state->crtc_reg[nv_crtc->index];\r\nstruct nv04_mode_state *saved = &nv04_display(dev)->saved_reg;\r\nstruct nv04_crtc_reg *crtc_saved = &saved->crtc_reg[nv_crtc->index];\r\nif (nv_two_heads(crtc->dev))\r\nNVSetOwner(crtc->dev, nv_crtc->index);\r\nnouveau_hw_save_state(crtc->dev, nv_crtc->index, saved);\r\nstate->sel_clk = saved->sel_clk & ~(0x5 << 16);\r\ncrtc_state->CRTC[NV_CIO_CRE_LCD__INDEX] = crtc_saved->CRTC[NV_CIO_CRE_LCD__INDEX];\r\nstate->pllsel = saved->pllsel & ~(PLLSEL_VPLL1_MASK | PLLSEL_VPLL2_MASK | PLLSEL_TV_MASK);\r\ncrtc_state->gpio_ext = crtc_saved->gpio_ext;\r\n}\r\nstatic void nv_crtc_restore(struct drm_crtc *crtc)\r\n{\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nint head = nv_crtc->index;\r\nuint8_t saved_cr21 = nv04_display(dev)->saved_reg.crtc_reg[head].CRTC[NV_CIO_CRE_21];\r\nif (nv_two_heads(crtc->dev))\r\nNVSetOwner(crtc->dev, head);\r\nnouveau_hw_load_state(crtc->dev, head, &nv04_display(dev)->saved_reg);\r\nnv_lock_vga_crtc_shadow(crtc->dev, head, saved_cr21);\r\nnv_crtc->last_dpms = NV_DPMS_CLEARED;\r\n}\r\nstatic void nv_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nconst struct drm_crtc_helper_funcs *funcs = crtc->helper_private;\r\nif (nv_two_heads(dev))\r\nNVSetOwner(dev, nv_crtc->index);\r\ndrm_vblank_pre_modeset(dev, nv_crtc->index);\r\nfuncs->dpms(crtc, DRM_MODE_DPMS_OFF);\r\nNVBlankScreen(dev, nv_crtc->index, true);\r\nNVWriteCRTC(dev, nv_crtc->index, NV_PCRTC_CONFIG, NV_PCRTC_CONFIG_START_ADDRESS_NON_VGA);\r\nif (drm->device.info.family == NV_DEVICE_INFO_V0_CURIE) {\r\nuint32_t reg900 = NVReadRAMDAC(dev, nv_crtc->index, NV_PRAMDAC_900);\r\nNVWriteRAMDAC(dev, nv_crtc->index, NV_PRAMDAC_900, reg900 & ~0x10000);\r\n}\r\n}\r\nstatic void nv_crtc_commit(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nconst struct drm_crtc_helper_funcs *funcs = crtc->helper_private;\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nnouveau_hw_load_state(dev, nv_crtc->index, &nv04_display(dev)->mode_reg);\r\nnv04_crtc_mode_set_base(crtc, crtc->x, crtc->y, NULL);\r\n#ifdef __BIG_ENDIAN\r\n{\r\nuint8_t tmp = NVReadVgaCrtc(dev, nv_crtc->index, NV_CIO_CRE_RCR);\r\ntmp |= MASK(NV_CIO_CRE_RCR_ENDIAN_BIG);\r\nNVWriteVgaCrtc(dev, nv_crtc->index, NV_CIO_CRE_RCR, tmp);\r\n}\r\n#endif\r\nfuncs->dpms(crtc, DRM_MODE_DPMS_ON);\r\ndrm_vblank_post_modeset(dev, nv_crtc->index);\r\n}\r\nstatic void nv_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nstruct nv04_display *disp = nv04_display(crtc->dev);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nif (!nv_crtc)\r\nreturn;\r\ndrm_crtc_cleanup(crtc);\r\nif (disp->image[nv_crtc->index])\r\nnouveau_bo_unpin(disp->image[nv_crtc->index]);\r\nnouveau_bo_ref(NULL, &disp->image[nv_crtc->index]);\r\nnouveau_bo_unmap(nv_crtc->cursor.nvbo);\r\nnouveau_bo_unpin(nv_crtc->cursor.nvbo);\r\nnouveau_bo_ref(NULL, &nv_crtc->cursor.nvbo);\r\nkfree(nv_crtc);\r\n}\r\nstatic void\r\nnv_crtc_gamma_load(struct drm_crtc *crtc)\r\n{\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nstruct drm_device *dev = nv_crtc->base.dev;\r\nstruct rgb { uint8_t r, g, b; } __attribute__((packed)) *rgbs;\r\nint i;\r\nrgbs = (struct rgb *)nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index].DAC;\r\nfor (i = 0; i < 256; i++) {\r\nrgbs[i].r = nv_crtc->lut.r[i] >> 8;\r\nrgbs[i].g = nv_crtc->lut.g[i] >> 8;\r\nrgbs[i].b = nv_crtc->lut.b[i] >> 8;\r\n}\r\nnouveau_hw_load_state_palette(dev, nv_crtc->index, &nv04_display(dev)->mode_reg);\r\n}\r\nstatic void\r\nnv_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct nv04_display *disp = nv04_display(crtc->dev);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nif (disp->image[nv_crtc->index])\r\nnouveau_bo_unpin(disp->image[nv_crtc->index]);\r\nnouveau_bo_ref(NULL, &disp->image[nv_crtc->index]);\r\n}\r\nstatic void\r\nnv_crtc_gamma_set(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b, uint32_t start,\r\nuint32_t size)\r\n{\r\nint end = (start + size > 256) ? 256 : start + size, i;\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nfor (i = start; i < end; i++) {\r\nnv_crtc->lut.r[i] = r[i];\r\nnv_crtc->lut.g[i] = g[i];\r\nnv_crtc->lut.b[i] = b[i];\r\n}\r\nif (!nv_crtc->base.primary->fb) {\r\nnv_crtc->lut.depth = 0;\r\nreturn;\r\n}\r\nnv_crtc_gamma_load(crtc);\r\n}\r\nstatic int\r\nnv04_crtc_do_mode_set_base(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *passed_fb,\r\nint x, int y, bool atomic)\r\n{\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nv04_crtc_reg *regp = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index];\r\nstruct drm_framebuffer *drm_fb;\r\nstruct nouveau_framebuffer *fb;\r\nint arb_burst, arb_lwm;\r\nNV_DEBUG(drm, "index %d\n", nv_crtc->index);\r\nif (!atomic && !crtc->primary->fb) {\r\nNV_DEBUG(drm, "No FB bound\n");\r\nreturn 0;\r\n}\r\nif (atomic) {\r\ndrm_fb = passed_fb;\r\nfb = nouveau_framebuffer(passed_fb);\r\n} else {\r\ndrm_fb = crtc->primary->fb;\r\nfb = nouveau_framebuffer(crtc->primary->fb);\r\n}\r\nnv_crtc->fb.offset = fb->nvbo->bo.offset;\r\nif (nv_crtc->lut.depth != drm_fb->depth) {\r\nnv_crtc->lut.depth = drm_fb->depth;\r\nnv_crtc_gamma_load(crtc);\r\n}\r\nregp->CRTC[NV_CIO_CRE_PIXEL_INDEX] &= ~3;\r\nregp->CRTC[NV_CIO_CRE_PIXEL_INDEX] |= (crtc->primary->fb->depth + 1) / 8;\r\nregp->ramdac_gen_ctrl &= ~NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_SEL;\r\nif (crtc->primary->fb->depth == 16)\r\nregp->ramdac_gen_ctrl |= NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_SEL;\r\ncrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_PIXEL_INDEX);\r\nNVWriteRAMDAC(dev, nv_crtc->index, NV_PRAMDAC_GENERAL_CONTROL,\r\nregp->ramdac_gen_ctrl);\r\nregp->CRTC[NV_CIO_CR_OFFSET_INDEX] = drm_fb->pitches[0] >> 3;\r\nregp->CRTC[NV_CIO_CRE_RPC0_INDEX] =\r\nXLATE(drm_fb->pitches[0] >> 3, 8, NV_CIO_CRE_RPC0_OFFSET_10_8);\r\nregp->CRTC[NV_CIO_CRE_42] =\r\nXLATE(drm_fb->pitches[0] / 8, 11, NV_CIO_CRE_42_OFFSET_11);\r\ncrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_RPC0_INDEX);\r\ncrtc_wr_cio_state(crtc, regp, NV_CIO_CR_OFFSET_INDEX);\r\ncrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_42);\r\nregp->fb_start = nv_crtc->fb.offset & ~3;\r\nregp->fb_start += (y * drm_fb->pitches[0]) + (x * drm_fb->bits_per_pixel / 8);\r\nnv_set_crtc_base(dev, nv_crtc->index, regp->fb_start);\r\nnouveau_calc_arb(dev, crtc->mode.clock, drm_fb->bits_per_pixel,\r\n&arb_burst, &arb_lwm);\r\nregp->CRTC[NV_CIO_CRE_FF_INDEX] = arb_burst;\r\nregp->CRTC[NV_CIO_CRE_FFLWM__INDEX] = arb_lwm & 0xff;\r\ncrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_FF_INDEX);\r\ncrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_FFLWM__INDEX);\r\nif (drm->device.info.family >= NV_DEVICE_INFO_V0_KELVIN) {\r\nregp->CRTC[NV_CIO_CRE_47] = arb_lwm >> 8;\r\ncrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_47);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnv04_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nint ret = nv_crtc_swap_fbs(crtc, old_fb);\r\nif (ret)\r\nreturn ret;\r\nreturn nv04_crtc_do_mode_set_base(crtc, old_fb, x, y, false);\r\n}\r\nstatic int\r\nnv04_crtc_mode_set_base_atomic(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nint x, int y, enum mode_set_atomic state)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(crtc->dev);\r\nstruct drm_device *dev = drm->dev;\r\nif (state == ENTER_ATOMIC_MODE_SET)\r\nnouveau_fbcon_accel_save_disable(dev);\r\nelse\r\nnouveau_fbcon_accel_restore(dev);\r\nreturn nv04_crtc_do_mode_set_base(crtc, fb, x, y, true);\r\n}\r\nstatic void nv04_cursor_upload(struct drm_device *dev, struct nouveau_bo *src,\r\nstruct nouveau_bo *dst)\r\n{\r\nint width = nv_cursor_width(dev);\r\nuint32_t pixel;\r\nint i, j;\r\nfor (i = 0; i < width; i++) {\r\nfor (j = 0; j < width; j++) {\r\npixel = nouveau_bo_rd32(src, i*64 + j);\r\nnouveau_bo_wr16(dst, i*width + j, (pixel & 0x80000000) >> 16\r\n| (pixel & 0xf80000) >> 9\r\n| (pixel & 0xf800) >> 6\r\n| (pixel & 0xf8) >> 3);\r\n}\r\n}\r\n}\r\nstatic void nv11_cursor_upload(struct drm_device *dev, struct nouveau_bo *src,\r\nstruct nouveau_bo *dst)\r\n{\r\nuint32_t pixel;\r\nint alpha, i;\r\nfor (i = 0; i < 64 * 64; i++) {\r\npixel = nouveau_bo_rd32(src, i);\r\nalpha = pixel >> 24;\r\nif (alpha > 0 && alpha < 255)\r\npixel = (pixel & 0x00ffffff) | ((alpha + 1) << 24);\r\n#ifdef __BIG_ENDIAN\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nif (drm->device.info.chipset == 0x11) {\r\npixel = ((pixel & 0x000000ff) << 24) |\r\n((pixel & 0x0000ff00) << 8) |\r\n((pixel & 0x00ff0000) >> 8) |\r\n((pixel & 0xff000000) >> 24);\r\n}\r\n}\r\n#endif\r\nnouveau_bo_wr32(dst, i, pixel);\r\n}\r\n}\r\nstatic int\r\nnv04_crtc_cursor_set(struct drm_crtc *crtc, struct drm_file *file_priv,\r\nuint32_t buffer_handle, uint32_t width, uint32_t height)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(crtc->dev);\r\nstruct drm_device *dev = drm->dev;\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nstruct nouveau_bo *cursor = NULL;\r\nstruct drm_gem_object *gem;\r\nint ret = 0;\r\nif (!buffer_handle) {\r\nnv_crtc->cursor.hide(nv_crtc, true);\r\nreturn 0;\r\n}\r\nif (width != 64 || height != 64)\r\nreturn -EINVAL;\r\ngem = drm_gem_object_lookup(dev, file_priv, buffer_handle);\r\nif (!gem)\r\nreturn -ENOENT;\r\ncursor = nouveau_gem_object(gem);\r\nret = nouveau_bo_map(cursor);\r\nif (ret)\r\ngoto out;\r\nif (drm->device.info.chipset >= 0x11)\r\nnv11_cursor_upload(dev, cursor, nv_crtc->cursor.nvbo);\r\nelse\r\nnv04_cursor_upload(dev, cursor, nv_crtc->cursor.nvbo);\r\nnouveau_bo_unmap(cursor);\r\nnv_crtc->cursor.offset = nv_crtc->cursor.nvbo->bo.offset;\r\nnv_crtc->cursor.set_offset(nv_crtc, nv_crtc->cursor.offset);\r\nnv_crtc->cursor.show(nv_crtc, true);\r\nout:\r\ndrm_gem_object_unreference_unlocked(gem);\r\nreturn ret;\r\n}\r\nstatic int\r\nnv04_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)\r\n{\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nnv_crtc->cursor.set_pos(nv_crtc, x, y);\r\nreturn 0;\r\n}\r\nint\r\nnouveau_crtc_set_config(struct drm_mode_set *set)\r\n{\r\nstruct drm_device *dev;\r\nstruct nouveau_drm *drm;\r\nint ret;\r\nstruct drm_crtc *crtc;\r\nbool active = false;\r\nif (!set || !set->crtc)\r\nreturn -EINVAL;\r\ndev = set->crtc->dev;\r\nret = pm_runtime_get_sync(dev->dev);\r\nif (ret < 0 && ret != -EACCES)\r\nreturn ret;\r\nret = drm_crtc_helper_set_config(set);\r\ndrm = nouveau_drm(dev);\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nif (crtc->enabled)\r\nactive = true;\r\n}\r\npm_runtime_mark_last_busy(dev->dev);\r\nif (active && !drm->have_disp_power_ref) {\r\ndrm->have_disp_power_ref = true;\r\nreturn ret;\r\n}\r\nif (!active && drm->have_disp_power_ref) {\r\npm_runtime_put_autosuspend(dev->dev);\r\ndrm->have_disp_power_ref = false;\r\n}\r\npm_runtime_put_autosuspend(dev->dev);\r\nreturn ret;\r\n}\r\nint\r\nnv04_crtc_create(struct drm_device *dev, int crtc_num)\r\n{\r\nstruct nouveau_crtc *nv_crtc;\r\nint ret, i;\r\nnv_crtc = kzalloc(sizeof(*nv_crtc), GFP_KERNEL);\r\nif (!nv_crtc)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < 256; i++) {\r\nnv_crtc->lut.r[i] = i << 8;\r\nnv_crtc->lut.g[i] = i << 8;\r\nnv_crtc->lut.b[i] = i << 8;\r\n}\r\nnv_crtc->lut.depth = 0;\r\nnv_crtc->index = crtc_num;\r\nnv_crtc->last_dpms = NV_DPMS_CLEARED;\r\ndrm_crtc_init(dev, &nv_crtc->base, &nv04_crtc_funcs);\r\ndrm_crtc_helper_add(&nv_crtc->base, &nv04_crtc_helper_funcs);\r\ndrm_mode_crtc_set_gamma_size(&nv_crtc->base, 256);\r\nret = nouveau_bo_new(dev, 64*64*4, 0x100, TTM_PL_FLAG_VRAM,\r\n0, 0x0000, NULL, NULL, &nv_crtc->cursor.nvbo);\r\nif (!ret) {\r\nret = nouveau_bo_pin(nv_crtc->cursor.nvbo, TTM_PL_FLAG_VRAM, false);\r\nif (!ret) {\r\nret = nouveau_bo_map(nv_crtc->cursor.nvbo);\r\nif (ret)\r\nnouveau_bo_unpin(nv_crtc->cursor.nvbo);\r\n}\r\nif (ret)\r\nnouveau_bo_ref(NULL, &nv_crtc->cursor.nvbo);\r\n}\r\nnv04_cursor_init(nv_crtc);\r\nreturn 0;\r\n}
