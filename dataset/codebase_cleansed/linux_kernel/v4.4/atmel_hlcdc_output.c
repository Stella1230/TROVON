static inline struct atmel_hlcdc_rgb_output *\r\ndrm_connector_to_atmel_hlcdc_rgb_output(struct drm_connector *connector)\r\n{\r\nreturn container_of(connector, struct atmel_hlcdc_rgb_output,\r\nconnector);\r\n}\r\nstatic inline struct atmel_hlcdc_rgb_output *\r\ndrm_encoder_to_atmel_hlcdc_rgb_output(struct drm_encoder *encoder)\r\n{\r\nreturn container_of(encoder, struct atmel_hlcdc_rgb_output, encoder);\r\n}\r\nstatic inline struct atmel_hlcdc_panel *\r\natmel_hlcdc_rgb_output_to_panel(struct atmel_hlcdc_rgb_output *output)\r\n{\r\nreturn container_of(output, struct atmel_hlcdc_panel, base);\r\n}\r\nstatic void atmel_hlcdc_panel_encoder_enable(struct drm_encoder *encoder)\r\n{\r\nstruct atmel_hlcdc_rgb_output *rgb =\r\ndrm_encoder_to_atmel_hlcdc_rgb_output(encoder);\r\nstruct atmel_hlcdc_panel *panel = atmel_hlcdc_rgb_output_to_panel(rgb);\r\ndrm_panel_enable(panel->panel);\r\n}\r\nstatic void atmel_hlcdc_panel_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct atmel_hlcdc_rgb_output *rgb =\r\ndrm_encoder_to_atmel_hlcdc_rgb_output(encoder);\r\nstruct atmel_hlcdc_panel *panel = atmel_hlcdc_rgb_output_to_panel(rgb);\r\ndrm_panel_disable(panel->panel);\r\n}\r\nstatic bool\r\natmel_hlcdc_panel_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted)\r\n{\r\nreturn true;\r\n}\r\nstatic void\r\natmel_hlcdc_rgb_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted)\r\n{\r\nstruct atmel_hlcdc_rgb_output *rgb =\r\ndrm_encoder_to_atmel_hlcdc_rgb_output(encoder);\r\nstruct drm_display_info *info = &rgb->connector.display_info;\r\nunsigned int cfg;\r\ncfg = 0;\r\nif (info->num_bus_formats) {\r\nswitch (info->bus_formats[0]) {\r\ncase MEDIA_BUS_FMT_RGB565_1X16:\r\ncfg |= ATMEL_HLCDC_CONNECTOR_RGB565 << 8;\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB666_1X18:\r\ncfg |= ATMEL_HLCDC_CONNECTOR_RGB666 << 8;\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB888_1X24:\r\ncfg |= ATMEL_HLCDC_CONNECTOR_RGB888 << 8;\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB444_1X12:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nregmap_update_bits(rgb->dc->hlcdc->regmap, ATMEL_HLCDC_CFG(5),\r\nATMEL_HLCDC_MODE_MASK,\r\ncfg);\r\n}\r\nstatic void atmel_hlcdc_rgb_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\ndrm_encoder_cleanup(encoder);\r\nmemset(encoder, 0, sizeof(*encoder));\r\n}\r\nstatic int atmel_hlcdc_panel_get_modes(struct drm_connector *connector)\r\n{\r\nstruct atmel_hlcdc_rgb_output *rgb =\r\ndrm_connector_to_atmel_hlcdc_rgb_output(connector);\r\nstruct atmel_hlcdc_panel *panel = atmel_hlcdc_rgb_output_to_panel(rgb);\r\nreturn panel->panel->funcs->get_modes(panel->panel);\r\n}\r\nstatic int atmel_hlcdc_rgb_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct atmel_hlcdc_rgb_output *rgb =\r\ndrm_connector_to_atmel_hlcdc_rgb_output(connector);\r\nreturn atmel_hlcdc_dc_mode_valid(rgb->dc, mode);\r\n}\r\nstatic struct drm_encoder *\r\natmel_hlcdc_rgb_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct atmel_hlcdc_rgb_output *rgb =\r\ndrm_connector_to_atmel_hlcdc_rgb_output(connector);\r\nreturn &rgb->encoder;\r\n}\r\nstatic enum drm_connector_status\r\natmel_hlcdc_panel_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nreturn connector_status_connected;\r\n}\r\nstatic void\r\natmel_hlcdc_panel_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct atmel_hlcdc_rgb_output *rgb =\r\ndrm_connector_to_atmel_hlcdc_rgb_output(connector);\r\nstruct atmel_hlcdc_panel *panel = atmel_hlcdc_rgb_output_to_panel(rgb);\r\ndrm_panel_detach(panel->panel);\r\ndrm_connector_cleanup(connector);\r\n}\r\nstatic int atmel_hlcdc_create_panel_output(struct drm_device *dev,\r\nstruct of_endpoint *ep)\r\n{\r\nstruct atmel_hlcdc_dc *dc = dev->dev_private;\r\nstruct device_node *np;\r\nstruct drm_panel *p = NULL;\r\nstruct atmel_hlcdc_panel *panel;\r\nint ret;\r\nnp = of_graph_get_remote_port_parent(ep->local_node);\r\nif (!np)\r\nreturn -EINVAL;\r\np = of_drm_find_panel(np);\r\nof_node_put(np);\r\nif (!p)\r\nreturn -EPROBE_DEFER;\r\npanel = devm_kzalloc(dev->dev, sizeof(*panel), GFP_KERNEL);\r\nif (!panel)\r\nreturn -EINVAL;\r\npanel->base.dpms = DRM_MODE_DPMS_OFF;\r\npanel->base.dc = dc;\r\ndrm_encoder_helper_add(&panel->base.encoder,\r\n&atmel_hlcdc_panel_encoder_helper_funcs);\r\nret = drm_encoder_init(dev, &panel->base.encoder,\r\n&atmel_hlcdc_panel_encoder_funcs,\r\nDRM_MODE_ENCODER_LVDS);\r\nif (ret)\r\nreturn ret;\r\npanel->base.connector.dpms = DRM_MODE_DPMS_OFF;\r\npanel->base.connector.polled = DRM_CONNECTOR_POLL_CONNECT;\r\ndrm_connector_helper_add(&panel->base.connector,\r\n&atmel_hlcdc_panel_connector_helper_funcs);\r\nret = drm_connector_init(dev, &panel->base.connector,\r\n&atmel_hlcdc_panel_connector_funcs,\r\nDRM_MODE_CONNECTOR_LVDS);\r\nif (ret)\r\ngoto err_encoder_cleanup;\r\ndrm_mode_connector_attach_encoder(&panel->base.connector,\r\n&panel->base.encoder);\r\npanel->base.encoder.possible_crtcs = 0x1;\r\ndrm_panel_attach(p, &panel->base.connector);\r\npanel->panel = p;\r\nreturn 0;\r\nerr_encoder_cleanup:\r\ndrm_encoder_cleanup(&panel->base.encoder);\r\nreturn ret;\r\n}\r\nint atmel_hlcdc_create_outputs(struct drm_device *dev)\r\n{\r\nstruct device_node *port_np, *np;\r\nstruct of_endpoint ep;\r\nint ret;\r\nport_np = of_get_child_by_name(dev->dev->of_node, "port");\r\nif (!port_np)\r\nreturn -EINVAL;\r\nnp = of_get_child_by_name(port_np, "endpoint");\r\nof_node_put(port_np);\r\nif (!np)\r\nreturn -EINVAL;\r\nret = of_graph_parse_endpoint(np, &ep);\r\nof_node_put(port_np);\r\nif (ret)\r\nreturn ret;\r\nreturn atmel_hlcdc_create_panel_output(dev, &ep);\r\n}
