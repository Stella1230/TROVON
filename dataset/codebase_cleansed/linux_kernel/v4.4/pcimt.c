static void __init sni_pcimt_sc_init(void)\r\n{\r\nunsigned int scsiz, sc_size;\r\nscsiz = cacheconf & 7;\r\nif (scsiz == 0) {\r\nprintk("Second level cache is deactivated.\n");\r\nreturn;\r\n}\r\nif (scsiz >= 6) {\r\nprintk("Invalid second level cache size configured, "\r\n"deactivating second level cache.\n");\r\ncacheconf = 0;\r\nreturn;\r\n}\r\nsc_size = 128 << scsiz;\r\nprintk("%dkb second level cache detected, deactivating.\n", sc_size);\r\ncacheconf = 0;\r\n}\r\nstatic inline void sni_pcimt_detect(void)\r\n{\r\nchar boardtype[80];\r\nunsigned char csmsr;\r\nchar *p = boardtype;\r\nunsigned int asic;\r\ncsmsr = *(volatile unsigned char *)PCIMT_CSMSR;\r\np += sprintf(p, "%s PCI", (csmsr & 0x80) ? "RM200" : "RM300");\r\nif ((csmsr & 0x80) == 0)\r\np += sprintf(p, ", board revision %s",\r\n(csmsr & 0x20) ? "D" : "C");\r\nasic = csmsr & 0x80;\r\nasic = (csmsr & 0x08) ? asic : !asic;\r\np += sprintf(p, ", ASIC PCI Rev %s", asic ? "1.0" : "1.1");\r\nprintk("%s.\n", boardtype);\r\n}\r\nstatic void __init sni_pcimt_resource_init(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(pcimt_io_resources); i++)\r\nrequest_resource(&sni_io_resource, pcimt_io_resources + i);\r\nfor (i = 0; i < ARRAY_SIZE(pcimt_mem_resources); i++)\r\nrequest_resource(&sni_mem_resource, pcimt_mem_resources + i);\r\n}\r\nstatic void enable_pcimt_irq(struct irq_data *d)\r\n{\r\nunsigned int mask = 1 << (d->irq - PCIMT_IRQ_INT2);\r\n*(volatile u8 *) PCIMT_IRQSEL |= mask;\r\n}\r\nvoid disable_pcimt_irq(struct irq_data *d)\r\n{\r\nunsigned int mask = ~(1 << (d->irq - PCIMT_IRQ_INT2));\r\n*(volatile u8 *) PCIMT_IRQSEL &= mask;\r\n}\r\nstatic void pcimt_hwint0(void)\r\n{\r\npanic("Received int0 but no handler yet ...");\r\n}\r\nstatic void pcimt_hwint1(void)\r\n{\r\nu8 pend = *(volatile char *)PCIMT_CSITPEND;\r\nunsigned long flags;\r\nif (pend & IT_EISA) {\r\nint irq;\r\nirq = i8259_irq();\r\nif (unlikely(irq < 0))\r\nreturn;\r\ndo_IRQ(irq);\r\n}\r\nif (!(pend & IT_SCSI)) {\r\nflags = read_c0_status();\r\nclear_c0_status(ST0_IM);\r\ndo_IRQ(PCIMT_IRQ_SCSI);\r\nwrite_c0_status(flags);\r\n}\r\n}\r\nstatic void pcimt_hwint3(void)\r\n{\r\nu8 pend = *(volatile char *)PCIMT_CSITPEND;\r\nint irq;\r\npend &= (IT_INTA | IT_INTB | IT_INTC | IT_INTD);\r\npend ^= (IT_INTA | IT_INTB | IT_INTC | IT_INTD);\r\nclear_c0_status(IE_IRQ3);\r\nirq = PCIMT_IRQ_INT2 + ffs(pend) - 1;\r\ndo_IRQ(irq);\r\nset_c0_status(IE_IRQ3);\r\n}\r\nstatic void sni_pcimt_hwint(void)\r\n{\r\nu32 pending = read_c0_cause() & read_c0_status();\r\nif (pending & C_IRQ5)\r\ndo_IRQ(MIPS_CPU_IRQ_BASE + 7);\r\nelse if (pending & C_IRQ4)\r\ndo_IRQ(MIPS_CPU_IRQ_BASE + 6);\r\nelse if (pending & C_IRQ3)\r\npcimt_hwint3();\r\nelse if (pending & C_IRQ1)\r\npcimt_hwint1();\r\nelse if (pending & C_IRQ0) {\r\npcimt_hwint0();\r\n}\r\n}\r\nvoid __init sni_pcimt_irq_init(void)\r\n{\r\nint i;\r\n*(volatile u8 *) PCIMT_IRQSEL = IT_ETH | IT_EISA;\r\nmips_cpu_irq_init();\r\nfor (i = PCIMT_IRQ_INT2; i <= PCIMT_IRQ_SCSI; i++)\r\nirq_set_chip_and_handler(i, &pcimt_irq_type, handle_level_irq);\r\nsni_hwint = sni_pcimt_hwint;\r\nchange_c0_status(ST0_IM, IE_IRQ1|IE_IRQ3);\r\n}\r\nvoid __init sni_pcimt_init(void)\r\n{\r\nsni_pcimt_detect();\r\nsni_pcimt_sc_init();\r\nioport_resource.end = sni_io_resource.end;\r\n#ifdef CONFIG_PCI\r\nPCIBIOS_MIN_IO = 0x9000;\r\nregister_pci_controller(&sni_controller);\r\n#endif\r\nsni_pcimt_resource_init();\r\n}\r\nstatic int __init snirm_pcimt_setup_devinit(void)\r\n{\r\nswitch (sni_brd_type) {\r\ncase SNI_BRD_PCI_MTOWER:\r\ncase SNI_BRD_PCI_DESKTOP:\r\ncase SNI_BRD_PCI_MTOWER_CPLUS:\r\nplatform_device_register(&pcimt_serial8250_device);\r\nplatform_device_register(&pcimt_cmos_device);\r\nbreak;\r\n}\r\nreturn 0;\r\n}
