int cx18_av_write(struct cx18 *cx, u16 addr, u8 value)\r\n{\r\nu32 reg = 0xc40000 + (addr & ~3);\r\nu32 mask = 0xff;\r\nint shift = (addr & 3) * 8;\r\nu32 x = cx18_read_reg(cx, reg);\r\nx = (x & ~(mask << shift)) | ((u32)value << shift);\r\ncx18_write_reg(cx, x, reg);\r\nreturn 0;\r\n}\r\nint cx18_av_write_expect(struct cx18 *cx, u16 addr, u8 value, u8 eval, u8 mask)\r\n{\r\nu32 reg = 0xc40000 + (addr & ~3);\r\nint shift = (addr & 3) * 8;\r\nu32 x = cx18_read_reg(cx, reg);\r\nx = (x & ~((u32)0xff << shift)) | ((u32)value << shift);\r\ncx18_write_reg_expect(cx, x, reg,\r\n((u32)eval << shift), ((u32)mask << shift));\r\nreturn 0;\r\n}\r\nint cx18_av_write4(struct cx18 *cx, u16 addr, u32 value)\r\n{\r\ncx18_write_reg(cx, value, 0xc40000 + addr);\r\nreturn 0;\r\n}\r\nint\r\ncx18_av_write4_expect(struct cx18 *cx, u16 addr, u32 value, u32 eval, u32 mask)\r\n{\r\ncx18_write_reg_expect(cx, value, 0xc40000 + addr, eval, mask);\r\nreturn 0;\r\n}\r\nint cx18_av_write4_noretry(struct cx18 *cx, u16 addr, u32 value)\r\n{\r\ncx18_write_reg_noretry(cx, value, 0xc40000 + addr);\r\nreturn 0;\r\n}\r\nu8 cx18_av_read(struct cx18 *cx, u16 addr)\r\n{\r\nu32 x = cx18_read_reg(cx, 0xc40000 + (addr & ~3));\r\nint shift = (addr & 3) * 8;\r\nreturn (x >> shift) & 0xff;\r\n}\r\nu32 cx18_av_read4(struct cx18 *cx, u16 addr)\r\n{\r\nreturn cx18_read_reg(cx, 0xc40000 + addr);\r\n}\r\nint cx18_av_and_or(struct cx18 *cx, u16 addr, unsigned and_mask,\r\nu8 or_value)\r\n{\r\nreturn cx18_av_write(cx, addr,\r\n(cx18_av_read(cx, addr) & and_mask) |\r\nor_value);\r\n}\r\nint cx18_av_and_or4(struct cx18 *cx, u16 addr, u32 and_mask,\r\nu32 or_value)\r\n{\r\nreturn cx18_av_write4(cx, addr,\r\n(cx18_av_read4(cx, addr) & and_mask) |\r\nor_value);\r\n}\r\nstatic void cx18_av_init(struct cx18 *cx)\r\n{\r\ncx18_av_write4(cx, CXADEC_PLL_CTRL1, 0x160e040f);\r\ncx18_av_write4(cx, CXADEC_VID_PLL_FRAC, 0x002be2fe);\r\ncx18_av_write4(cx, CXADEC_AUX_PLL_FRAC, 0x005227ad);\r\ncx18_av_write(cx, CXADEC_I2S_MCLK, 0x56);\r\n}\r\nstatic void cx18_av_initialize(struct v4l2_subdev *sd)\r\n{\r\nstruct cx18_av_state *state = to_cx18_av_state(sd);\r\nstruct cx18 *cx = v4l2_get_subdevdata(sd);\r\nint default_volume;\r\nu32 v;\r\ncx18_av_loadfw(cx);\r\ncx18_av_write4_expect(cx, CXADEC_DL_CTL, 0x03000000,\r\n0x03000000, 0x13000000);\r\nv = cx18_av_read4(cx, CXADEC_HOST_REG1);\r\ncx18_av_write4_expect(cx, CXADEC_HOST_REG1, v | 1, v, 0xfffe);\r\ncx18_av_write4_expect(cx, CXADEC_HOST_REG1, v & 0xfffe,\r\nv & 0xfffe, 0xffff);\r\nv = cx18_av_read4(cx, CXADEC_DLL1_DIAG_CTRL) & 0xE1FFFEFF;\r\ncx18_av_write4(cx, CXADEC_DLL1_DIAG_CTRL, v);\r\ncx18_av_write4(cx, CXADEC_DLL1_DIAG_CTRL, v | 0x10000100);\r\nv = cx18_av_read4(cx, CXADEC_DLL2_DIAG_CTRL) & 0xE1FFFEFF;\r\ncx18_av_write4(cx, CXADEC_DLL2_DIAG_CTRL, v);\r\ncx18_av_write4(cx, CXADEC_DLL2_DIAG_CTRL, v | 0x06000100);\r\ncx18_av_write4(cx, CXADEC_AFE_DIAG_CTRL1, 0x000A1802);\r\nv = cx18_av_read4(cx, CXADEC_AFE_DIAG_CTRL3) | 1;\r\ncx18_av_write4_expect(cx, CXADEC_AFE_DIAG_CTRL3, v, v, 0x03009F0F);\r\ncx18_av_write4_expect(cx, CXADEC_AFE_DIAG_CTRL3,\r\nv & 0xFFFFFFFE, v & 0xFFFFFFFE, 0x03009F0F);\r\ncx18_av_and_or4(cx, CXADEC_PIN_CTRL1, ~0, 0x040C00);\r\ncx18_av_and_or4(cx, CXADEC_PIN_CTRL2, ~0, 0x2);\r\ncx18_av_write4(cx, CXADEC_SOFT_RST_CTRL, 0x8000);\r\ncx18_av_write4(cx, CXADEC_SOFT_RST_CTRL, 0);\r\ncx18_av_and_or4(cx, CXADEC_CHIP_CTRL, 0xFFFBFFFF, 0x00120000);\r\ncx18_av_init(cx);\r\ncx18_av_and_or4(cx, CXADEC_MODE_CTRL, 0xFFF7E7F0, 0x02040800);\r\ncx18_av_and_or4(cx, CXADEC_CRUSH_CTRL, ~0, 0x00500000);\r\ncx18_av_and_or4(cx, CXADEC_DFE_CTRL2, 0xFFFF00FF, 0x00002000);\r\ncx18_av_write4(cx, CXADEC_OUT_CTRL1, 0x4013252e);\r\ncx18_av_and_or4(cx, CXADEC_AFE_CTRL, 0xFF000000, 0x00005D00);\r\ncx18_av_write4(cx, CXADEC_SRC_COMB_CFG, 0x6628021F);\r\ndefault_volume = cx18_av_read(cx, 0x8d4);\r\nif (default_volume > 228) {\r\ndefault_volume = 228;\r\ncx18_av_write(cx, 0x8d4, 228);\r\n} else if (default_volume < 20) {\r\ndefault_volume = 20;\r\ncx18_av_write(cx, 0x8d4, 20);\r\n}\r\ndefault_volume = (((228 - default_volume) >> 1) + 23) << 9;\r\nstate->volume->cur.val = state->volume->default_value = default_volume;\r\nv4l2_ctrl_handler_setup(&state->hdl);\r\n}\r\nstatic int cx18_av_reset(struct v4l2_subdev *sd, u32 val)\r\n{\r\ncx18_av_initialize(sd);\r\nreturn 0;\r\n}\r\nstatic int cx18_av_load_fw(struct v4l2_subdev *sd)\r\n{\r\nstruct cx18_av_state *state = to_cx18_av_state(sd);\r\nif (!state->is_initialized) {\r\nstate->is_initialized = 1;\r\ncx18_av_initialize(sd);\r\n}\r\nreturn 0;\r\n}\r\nvoid cx18_av_std_setup(struct cx18 *cx)\r\n{\r\nstruct cx18_av_state *state = &cx->av_state;\r\nstruct v4l2_subdev *sd = &state->sd;\r\nv4l2_std_id std = state->std;\r\nconst int src_decimation = 0x21f;\r\nint hblank, hactive, burst, vblank, vactive, sc;\r\nint vblank656;\r\nint luma_lpf, uv_lpf, comb;\r\nu32 pll_int, pll_frac, pll_post;\r\nif (std & ~V4L2_STD_NTSC)\r\ncx18_av_write(cx, 0x49f, 0x11);\r\nelse\r\ncx18_av_write(cx, 0x49f, 0x14);\r\nif (std & V4L2_STD_625_50) {\r\nvblank656 = 48;\r\nvblank = 38;\r\nvactive = 579;\r\nhblank = 132;\r\nhactive = 720;\r\nburst = 93;\r\nluma_lpf = 2;\r\nif (std & V4L2_STD_PAL) {\r\nuv_lpf = 1;\r\ncomb = 0x20;\r\nsc = 688700;\r\n} else if (std == V4L2_STD_PAL_Nc) {\r\nuv_lpf = 1;\r\ncomb = 0x20;\r\nsc = 556422;\r\n} else {\r\nuv_lpf = 0;\r\ncomb = 0;\r\nsc = 672314;\r\n}\r\n} else {\r\nvblank656 = 38;\r\nvblank = 26;\r\nvactive = 481;\r\nhactive = 720;\r\nhblank = 122;\r\nluma_lpf = 1;\r\nuv_lpf = 1;\r\nif (std == V4L2_STD_PAL_60) {\r\nburst = 90;\r\nluma_lpf = 2;\r\ncomb = 0x20;\r\nsc = 688700;\r\n} else if (std == V4L2_STD_PAL_M) {\r\nburst = 97;\r\ncomb = 0x20;\r\nsc = 555421;\r\n} else {\r\nburst = 90;\r\ncomb = 0x66;\r\nsc = 556032;\r\n}\r\n}\r\npll_int = cx18_av_read(cx, 0x108);\r\npll_frac = cx18_av_read4(cx, 0x10c) & 0x1ffffff;\r\npll_post = cx18_av_read(cx, 0x109);\r\nCX18_DEBUG_INFO_DEV(sd, "PLL regs = int: %u, frac: %u, post: %u\n",\r\npll_int, pll_frac, pll_post);\r\nif (pll_post) {\r\nint fsc, pll;\r\nu64 tmp;\r\npll = (28636360L * ((((u64)pll_int) << 25) + pll_frac)) >> 25;\r\npll /= pll_post;\r\nCX18_DEBUG_INFO_DEV(sd, "Video PLL = %d.%06d MHz\n",\r\npll / 1000000, pll % 1000000);\r\nCX18_DEBUG_INFO_DEV(sd, "Pixel rate = %d.%06d Mpixel/sec\n",\r\npll / 8000000, (pll / 8) % 1000000);\r\nCX18_DEBUG_INFO_DEV(sd, "ADC XTAL/pixel clock decimation ratio "\r\n"= %d.%03d\n", src_decimation / 256,\r\n((src_decimation % 256) * 1000) / 256);\r\ntmp = 28636360 * (u64) sc;\r\ndo_div(tmp, src_decimation);\r\nfsc = tmp >> 13;\r\nCX18_DEBUG_INFO_DEV(sd,\r\n"Chroma sub-carrier initial freq = %d.%06d "\r\n"MHz\n", fsc / 1000000, fsc % 1000000);\r\nCX18_DEBUG_INFO_DEV(sd, "hblank %i, hactive %i, vblank %i, "\r\n"vactive %i, vblank656 %i, src_dec %i, "\r\n"burst 0x%02x, luma_lpf %i, uv_lpf %i, "\r\n"comb 0x%02x, sc 0x%06x\n",\r\nhblank, hactive, vblank, vactive, vblank656,\r\nsrc_decimation, burst, luma_lpf, uv_lpf,\r\ncomb, sc);\r\n}\r\ncx18_av_write(cx, 0x470, hblank);\r\ncx18_av_write(cx, 0x471,\r\n(((hblank >> 8) & 0x3) | (hactive << 4)) & 0xff);\r\ncx18_av_write(cx, 0x472, hactive >> 4);\r\ncx18_av_write(cx, 0x473, burst);\r\ncx18_av_write(cx, 0x474, vblank);\r\ncx18_av_write(cx, 0x475,\r\n(((vblank >> 8) & 0x3) | (vactive << 4)) & 0xff);\r\ncx18_av_write(cx, 0x476, vactive >> 4);\r\ncx18_av_write(cx, 0x477, vblank656);\r\ncx18_av_write(cx, 0x478, src_decimation & 0xff);\r\ncx18_av_write(cx, 0x479, (src_decimation >> 8) & 0xff);\r\ncx18_av_write(cx, 0x47a, luma_lpf << 6 | ((uv_lpf << 4) & 0x30));\r\ncx18_av_write(cx, 0x47b, comb);\r\ncx18_av_write(cx, 0x47c, sc);\r\ncx18_av_write(cx, 0x47d, (sc >> 8) & 0xff);\r\ncx18_av_write(cx, 0x47e, (sc >> 16) & 0xff);\r\nif (std & V4L2_STD_625_50) {\r\nstate->slicer_line_delay = 1;\r\nstate->slicer_line_offset = (6 + state->slicer_line_delay - 2);\r\n} else {\r\nstate->slicer_line_delay = 0;\r\nstate->slicer_line_offset = (10 + state->slicer_line_delay - 2);\r\n}\r\ncx18_av_write(cx, 0x47f, state->slicer_line_delay);\r\n}\r\nstatic void input_change(struct cx18 *cx)\r\n{\r\nstruct cx18_av_state *state = &cx->av_state;\r\nv4l2_std_id std = state->std;\r\nu8 v;\r\ncx18_av_write(cx, 0x49f, (std & V4L2_STD_NTSC) ? 0x14 : 0x11);\r\ncx18_av_and_or(cx, 0x401, ~0x60, 0);\r\ncx18_av_and_or(cx, 0x401, ~0x60, 0x60);\r\nif (std & V4L2_STD_525_60) {\r\nif (std == V4L2_STD_NTSC_M_JP) {\r\ncx18_av_write_expect(cx, 0x808, 0xf7, 0xf7, 0xff);\r\ncx18_av_write_expect(cx, 0x80b, 0x02, 0x02, 0x3f);\r\n} else if (std == V4L2_STD_NTSC_M_KR) {\r\ncx18_av_write_expect(cx, 0x808, 0xf8, 0xf8, 0xff);\r\ncx18_av_write_expect(cx, 0x80b, 0x03, 0x03, 0x3f);\r\n} else {\r\ncx18_av_write_expect(cx, 0x808, 0xf6, 0xf6, 0xff);\r\ncx18_av_write_expect(cx, 0x80b, 0x01, 0x01, 0x3f);\r\n}\r\n} else if (std & V4L2_STD_PAL) {\r\ncx18_av_write_expect(cx, 0x808, 0xff, 0xff, 0xff);\r\ncx18_av_write_expect(cx, 0x80b, 0x03, 0x03, 0x3f);\r\n} else if (std & V4L2_STD_SECAM) {\r\ncx18_av_write_expect(cx, 0x808, 0xff, 0xff, 0xff);\r\ncx18_av_write_expect(cx, 0x80b, 0x03, 0x03, 0x3f);\r\n}\r\nv = cx18_av_read(cx, 0x803);\r\nif (v & 0x10) {\r\nv &= ~0x10;\r\ncx18_av_write_expect(cx, 0x803, v, v, 0x1f);\r\nv |= 0x10;\r\ncx18_av_write_expect(cx, 0x803, v, v, 0x1f);\r\n}\r\n}\r\nstatic int cx18_av_s_frequency(struct v4l2_subdev *sd,\r\nconst struct v4l2_frequency *freq)\r\n{\r\nstruct cx18 *cx = v4l2_get_subdevdata(sd);\r\ninput_change(cx);\r\nreturn 0;\r\n}\r\nstatic int set_input(struct cx18 *cx, enum cx18_av_video_input vid_input,\r\nenum cx18_av_audio_input aud_input)\r\n{\r\nstruct cx18_av_state *state = &cx->av_state;\r\nstruct v4l2_subdev *sd = &state->sd;\r\nenum analog_signal_type {\r\nNONE, CVBS, Y, C, SIF, Pb, Pr\r\n} ch[3] = {NONE, NONE, NONE};\r\nu8 afe_mux_cfg;\r\nu8 adc2_cfg;\r\nu8 input_mode;\r\nu32 afe_cfg;\r\nint i;\r\nCX18_DEBUG_INFO_DEV(sd, "decoder set video input %d, audio input %d\n",\r\nvid_input, aud_input);\r\nif (vid_input >= CX18_AV_COMPOSITE1 &&\r\nvid_input <= CX18_AV_COMPOSITE8) {\r\nafe_mux_cfg = 0xf0 + (vid_input - CX18_AV_COMPOSITE1);\r\nch[0] = CVBS;\r\ninput_mode = 0x0;\r\n} else if (vid_input >= CX18_AV_COMPONENT_LUMA1) {\r\nint luma = vid_input & 0xf000;\r\nint r_chroma = vid_input & 0xf0000;\r\nint b_chroma = vid_input & 0xf00000;\r\nif ((vid_input & ~0xfff000) ||\r\nluma < CX18_AV_COMPONENT_LUMA1 ||\r\nluma > CX18_AV_COMPONENT_LUMA8 ||\r\nr_chroma < CX18_AV_COMPONENT_R_CHROMA4 ||\r\nr_chroma > CX18_AV_COMPONENT_R_CHROMA6 ||\r\nb_chroma < CX18_AV_COMPONENT_B_CHROMA7 ||\r\nb_chroma > CX18_AV_COMPONENT_B_CHROMA8) {\r\nCX18_ERR_DEV(sd, "0x%06x is not a valid video input!\n",\r\nvid_input);\r\nreturn -EINVAL;\r\n}\r\nafe_mux_cfg = (luma - CX18_AV_COMPONENT_LUMA1) >> 12;\r\nch[0] = Y;\r\nafe_mux_cfg |= (r_chroma - CX18_AV_COMPONENT_R_CHROMA4) >> 12;\r\nch[1] = Pr;\r\nafe_mux_cfg |= (b_chroma - CX18_AV_COMPONENT_B_CHROMA7) >> 14;\r\nch[2] = Pb;\r\ninput_mode = 0x6;\r\n} else {\r\nint luma = vid_input & 0xf0;\r\nint chroma = vid_input & 0xf00;\r\nif ((vid_input & ~0xff0) ||\r\nluma < CX18_AV_SVIDEO_LUMA1 ||\r\nluma > CX18_AV_SVIDEO_LUMA8 ||\r\nchroma < CX18_AV_SVIDEO_CHROMA4 ||\r\nchroma > CX18_AV_SVIDEO_CHROMA8) {\r\nCX18_ERR_DEV(sd, "0x%06x is not a valid video input!\n",\r\nvid_input);\r\nreturn -EINVAL;\r\n}\r\nafe_mux_cfg = 0xf0 + ((luma - CX18_AV_SVIDEO_LUMA1) >> 4);\r\nch[0] = Y;\r\nif (chroma >= CX18_AV_SVIDEO_CHROMA7) {\r\nafe_mux_cfg &= 0x3f;\r\nafe_mux_cfg |= (chroma - CX18_AV_SVIDEO_CHROMA7) >> 2;\r\nch[2] = C;\r\n} else {\r\nafe_mux_cfg &= 0xcf;\r\nafe_mux_cfg |= (chroma - CX18_AV_SVIDEO_CHROMA4) >> 4;\r\nch[1] = C;\r\n}\r\ninput_mode = 0x2;\r\n}\r\nswitch (aud_input) {\r\ncase CX18_AV_AUDIO_SERIAL1:\r\ncase CX18_AV_AUDIO_SERIAL2:\r\nbreak;\r\ncase CX18_AV_AUDIO4:\r\nafe_mux_cfg &= ~0x30;\r\nch[1] = SIF;\r\nbreak;\r\ncase CX18_AV_AUDIO5:\r\nafe_mux_cfg = (afe_mux_cfg & ~0x30) | 0x10;\r\nch[1] = SIF;\r\nbreak;\r\ncase CX18_AV_AUDIO6:\r\nafe_mux_cfg = (afe_mux_cfg & ~0x30) | 0x20;\r\nch[1] = SIF;\r\nbreak;\r\ncase CX18_AV_AUDIO7:\r\nafe_mux_cfg &= ~0xc0;\r\nch[2] = SIF;\r\nbreak;\r\ncase CX18_AV_AUDIO8:\r\nafe_mux_cfg = (afe_mux_cfg & ~0xc0) | 0x40;\r\nch[2] = SIF;\r\nbreak;\r\ndefault:\r\nCX18_ERR_DEV(sd, "0x%04x is not a valid audio input!\n",\r\naud_input);\r\nreturn -EINVAL;\r\n}\r\ncx18_av_write_expect(cx, 0x103, afe_mux_cfg, afe_mux_cfg, 0xf7);\r\ncx18_av_and_or(cx, 0x401, ~0x6, input_mode);\r\nadc2_cfg = cx18_av_read(cx, 0x102);\r\nif (ch[2] == NONE)\r\nadc2_cfg &= ~0x2;\r\nelse\r\nadc2_cfg |= 0x2;\r\nif (ch[1] != NONE && ch[2] != NONE)\r\nadc2_cfg |= 0x4;\r\nelse\r\nadc2_cfg &= ~0x4;\r\ncx18_av_write_expect(cx, 0x102, adc2_cfg, adc2_cfg, 0x17);\r\nafe_cfg = cx18_av_read4(cx, CXADEC_AFE_CTRL);\r\nafe_cfg &= 0xff000000;\r\nafe_cfg |= 0x00005000;\r\nif (ch[1] != NONE && ch[2] != NONE)\r\nafe_cfg |= 0x00000030;\r\nfor (i = 0; i < 3; i++) {\r\nswitch (ch[i]) {\r\ndefault:\r\ncase NONE:\r\nafe_cfg |= (0x00000200 << i);\r\nbreak;\r\ncase CVBS:\r\ncase Y:\r\nif (i > 0)\r\nafe_cfg |= 0x00002000;\r\nbreak;\r\ncase C:\r\ncase Pb:\r\ncase Pr:\r\nafe_cfg |= (0x00000200 << i);\r\nif (i == 0 && ch[i] == C)\r\nafe_cfg &= ~0x00001000;\r\nbreak;\r\ncase SIF:\r\nafe_cfg |= (0x00000240 << i);\r\nif (i == 0)\r\nafe_cfg &= ~0x00004000;\r\nbreak;\r\n}\r\n}\r\ncx18_av_write4(cx, CXADEC_AFE_CTRL, afe_cfg);\r\nstate->vid_input = vid_input;\r\nstate->aud_input = aud_input;\r\ncx18_av_audio_set_path(cx);\r\ninput_change(cx);\r\nreturn 0;\r\n}\r\nstatic int cx18_av_s_video_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct cx18_av_state *state = to_cx18_av_state(sd);\r\nstruct cx18 *cx = v4l2_get_subdevdata(sd);\r\nreturn set_input(cx, input, state->aud_input);\r\n}\r\nstatic int cx18_av_s_audio_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct cx18_av_state *state = to_cx18_av_state(sd);\r\nstruct cx18 *cx = v4l2_get_subdevdata(sd);\r\nreturn set_input(cx, state->vid_input, input);\r\n}\r\nstatic int cx18_av_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\r\n{\r\nstruct cx18_av_state *state = to_cx18_av_state(sd);\r\nstruct cx18 *cx = v4l2_get_subdevdata(sd);\r\nu8 vpres;\r\nu8 mode;\r\nint val = 0;\r\nif (state->radio)\r\nreturn 0;\r\nvpres = cx18_av_read(cx, 0x40e) & 0x20;\r\nvt->signal = vpres ? 0xffff : 0x0;\r\nvt->capability |=\r\nV4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LANG1 |\r\nV4L2_TUNER_CAP_LANG2 | V4L2_TUNER_CAP_SAP;\r\nmode = cx18_av_read(cx, 0x804);\r\nif ((mode & 0xf) == 1)\r\nval |= V4L2_TUNER_SUB_STEREO;\r\nelse\r\nval |= V4L2_TUNER_SUB_MONO;\r\nif (mode == 2 || mode == 4)\r\nval = V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;\r\nif (mode & 0x10)\r\nval |= V4L2_TUNER_SUB_SAP;\r\nvt->rxsubchans = val;\r\nvt->audmode = state->audmode;\r\nreturn 0;\r\n}\r\nstatic int cx18_av_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *vt)\r\n{\r\nstruct cx18_av_state *state = to_cx18_av_state(sd);\r\nstruct cx18 *cx = v4l2_get_subdevdata(sd);\r\nu8 v;\r\nif (state->radio)\r\nreturn 0;\r\nv = cx18_av_read(cx, 0x809);\r\nv &= ~0xf;\r\nswitch (vt->audmode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\nbreak;\r\ncase V4L2_TUNER_MODE_STEREO:\r\ncase V4L2_TUNER_MODE_LANG1:\r\nv |= 0x4;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG1_LANG2:\r\nv |= 0x7;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG2:\r\nv |= 0x1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncx18_av_write_expect(cx, 0x809, v, v, 0xff);\r\nstate->audmode = vt->audmode;\r\nreturn 0;\r\n}\r\nstatic int cx18_av_s_std(struct v4l2_subdev *sd, v4l2_std_id norm)\r\n{\r\nstruct cx18_av_state *state = to_cx18_av_state(sd);\r\nstruct cx18 *cx = v4l2_get_subdevdata(sd);\r\nu8 fmt = 0;\r\nu8 pal_m = 0;\r\nif (state->radio == 0 && state->std == norm)\r\nreturn 0;\r\nstate->radio = 0;\r\nstate->std = norm;\r\nif (state->std == V4L2_STD_NTSC_M_JP) {\r\nfmt = 0x2;\r\n} else if (state->std == V4L2_STD_NTSC_443) {\r\nfmt = 0x3;\r\n} else if (state->std == V4L2_STD_PAL_M) {\r\npal_m = 1;\r\nfmt = 0x5;\r\n} else if (state->std == V4L2_STD_PAL_N) {\r\nfmt = 0x6;\r\n} else if (state->std == V4L2_STD_PAL_Nc) {\r\nfmt = 0x7;\r\n} else if (state->std == V4L2_STD_PAL_60) {\r\nfmt = 0x8;\r\n} else {\r\nif (state->std & V4L2_STD_NTSC)\r\nfmt = 0x1;\r\nelse if (state->std & V4L2_STD_PAL)\r\nfmt = 0x4;\r\nelse if (state->std & V4L2_STD_SECAM)\r\nfmt = 0xc;\r\n}\r\nCX18_DEBUG_INFO_DEV(sd, "changing video std to fmt %i\n", fmt);\r\nif (fmt >= 4 && fmt < 8) {\r\ncx18_av_and_or(cx, 0x400, ~0xf, 1);\r\ncx18_av_and_or(cx, 0x47b, ~6, 0);\r\n}\r\ncx18_av_and_or(cx, 0x400, ~0x2f, fmt | 0x20);\r\ncx18_av_and_or(cx, 0x403, ~0x3, pal_m);\r\ncx18_av_std_setup(cx);\r\ninput_change(cx);\r\nreturn 0;\r\n}\r\nstatic int cx18_av_s_radio(struct v4l2_subdev *sd)\r\n{\r\nstruct cx18_av_state *state = to_cx18_av_state(sd);\r\nstate->radio = 1;\r\nreturn 0;\r\n}\r\nstatic int cx18_av_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nstruct cx18 *cx = v4l2_get_subdevdata(sd);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ncx18_av_write(cx, 0x414, ctrl->val - 128);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\ncx18_av_write(cx, 0x415, ctrl->val << 1);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\ncx18_av_write(cx, 0x420, ctrl->val << 1);\r\ncx18_av_write(cx, 0x421, ctrl->val << 1);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\ncx18_av_write(cx, 0x422, ctrl->val);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx18_av_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct v4l2_mbus_framefmt *fmt = &format->format;\r\nstruct cx18_av_state *state = to_cx18_av_state(sd);\r\nstruct cx18 *cx = v4l2_get_subdevdata(sd);\r\nint HSC, VSC, Vsrc, Hsrc, filter, Vlines;\r\nint is_50Hz = !(state->std & V4L2_STD_525_60);\r\nif (format->pad || fmt->code != MEDIA_BUS_FMT_FIXED)\r\nreturn -EINVAL;\r\nfmt->field = V4L2_FIELD_INTERLACED;\r\nfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nVsrc = (cx18_av_read(cx, 0x476) & 0x3f) << 4;\r\nVsrc |= (cx18_av_read(cx, 0x475) & 0xf0) >> 4;\r\nHsrc = (cx18_av_read(cx, 0x472) & 0x3f) << 4;\r\nHsrc |= (cx18_av_read(cx, 0x471) & 0xf0) >> 4;\r\nVlines = fmt->height + (is_50Hz ? 3 : 1);\r\nif ((fmt->width * 16 < Hsrc) || (Hsrc < fmt->width) ||\r\n(Vlines * 8 < Vsrc) || (Vsrc < Vlines)) {\r\nCX18_ERR_DEV(sd, "%dx%d is not a valid size!\n",\r\nfmt->width, fmt->height);\r\nreturn -ERANGE;\r\n}\r\nif (format->which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn 0;\r\nHSC = (Hsrc * (1 << 20)) / fmt->width - (1 << 20);\r\nVSC = (1 << 16) - (Vsrc * (1 << 9) / Vlines - (1 << 9));\r\nVSC &= 0x1fff;\r\nif (fmt->width >= 385)\r\nfilter = 0;\r\nelse if (fmt->width > 192)\r\nfilter = 1;\r\nelse if (fmt->width > 96)\r\nfilter = 2;\r\nelse\r\nfilter = 3;\r\nCX18_DEBUG_INFO_DEV(sd,\r\n"decoder set size %dx%d -> scale %ux%u\n",\r\nfmt->width, fmt->height, HSC, VSC);\r\ncx18_av_write(cx, 0x418, HSC & 0xff);\r\ncx18_av_write(cx, 0x419, (HSC >> 8) & 0xff);\r\ncx18_av_write(cx, 0x41a, HSC >> 16);\r\ncx18_av_write(cx, 0x41c, VSC & 0xff);\r\ncx18_av_write(cx, 0x41d, VSC >> 8);\r\ncx18_av_write(cx, 0x41e, 0x8 | filter);\r\nreturn 0;\r\n}\r\nstatic int cx18_av_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct cx18 *cx = v4l2_get_subdevdata(sd);\r\nCX18_DEBUG_INFO_DEV(sd, "%s output\n", enable ? "enable" : "disable");\r\nif (enable) {\r\ncx18_av_write(cx, 0x115, 0x8c);\r\ncx18_av_write(cx, 0x116, 0x07);\r\n} else {\r\ncx18_av_write(cx, 0x115, 0x00);\r\ncx18_av_write(cx, 0x116, 0x00);\r\n}\r\nreturn 0;\r\n}\r\nstatic void log_video_status(struct cx18 *cx)\r\n{\r\nstatic const char *const fmt_strs[] = {\r\n"0x0",\r\n"NTSC-M", "NTSC-J", "NTSC-4.43",\r\n"PAL-BDGHI", "PAL-M", "PAL-N", "PAL-Nc", "PAL-60",\r\n"0x9", "0xA", "0xB",\r\n"SECAM",\r\n"0xD", "0xE", "0xF"\r\n};\r\nstruct cx18_av_state *state = &cx->av_state;\r\nstruct v4l2_subdev *sd = &state->sd;\r\nu8 vidfmt_sel = cx18_av_read(cx, 0x400) & 0xf;\r\nu8 gen_stat1 = cx18_av_read(cx, 0x40d);\r\nu8 gen_stat2 = cx18_av_read(cx, 0x40e);\r\nint vid_input = state->vid_input;\r\nCX18_INFO_DEV(sd, "Video signal: %spresent\n",\r\n(gen_stat2 & 0x20) ? "" : "not ");\r\nCX18_INFO_DEV(sd, "Detected format: %s\n",\r\nfmt_strs[gen_stat1 & 0xf]);\r\nCX18_INFO_DEV(sd, "Specified standard: %s\n",\r\nvidfmt_sel ? fmt_strs[vidfmt_sel]\r\n: "automatic detection");\r\nif (vid_input >= CX18_AV_COMPOSITE1 &&\r\nvid_input <= CX18_AV_COMPOSITE8) {\r\nCX18_INFO_DEV(sd, "Specified video input: Composite %d\n",\r\nvid_input - CX18_AV_COMPOSITE1 + 1);\r\n} else {\r\nCX18_INFO_DEV(sd, "Specified video input: "\r\n"S-Video (Luma In%d, Chroma In%d)\n",\r\n(vid_input & 0xf0) >> 4,\r\n(vid_input & 0xf00) >> 8);\r\n}\r\nCX18_INFO_DEV(sd, "Specified audioclock freq: %d Hz\n",\r\nstate->audclk_freq);\r\n}\r\nstatic void log_audio_status(struct cx18 *cx)\r\n{\r\nstruct cx18_av_state *state = &cx->av_state;\r\nstruct v4l2_subdev *sd = &state->sd;\r\nu8 download_ctl = cx18_av_read(cx, 0x803);\r\nu8 mod_det_stat0 = cx18_av_read(cx, 0x804);\r\nu8 mod_det_stat1 = cx18_av_read(cx, 0x805);\r\nu8 audio_config = cx18_av_read(cx, 0x808);\r\nu8 pref_mode = cx18_av_read(cx, 0x809);\r\nu8 afc0 = cx18_av_read(cx, 0x80b);\r\nu8 mute_ctl = cx18_av_read(cx, 0x8d3);\r\nint aud_input = state->aud_input;\r\nchar *p;\r\nswitch (mod_det_stat0) {\r\ncase 0x00: p = "mono"; break;\r\ncase 0x01: p = "stereo"; break;\r\ncase 0x02: p = "dual"; break;\r\ncase 0x04: p = "tri"; break;\r\ncase 0x10: p = "mono with SAP"; break;\r\ncase 0x11: p = "stereo with SAP"; break;\r\ncase 0x12: p = "dual with SAP"; break;\r\ncase 0x14: p = "tri with SAP"; break;\r\ncase 0xfe: p = "forced mode"; break;\r\ndefault: p = "not defined"; break;\r\n}\r\nCX18_INFO_DEV(sd, "Detected audio mode: %s\n", p);\r\nswitch (mod_det_stat1) {\r\ncase 0x00: p = "not defined"; break;\r\ncase 0x01: p = "EIAJ"; break;\r\ncase 0x02: p = "A2-M"; break;\r\ncase 0x03: p = "A2-BG"; break;\r\ncase 0x04: p = "A2-DK1"; break;\r\ncase 0x05: p = "A2-DK2"; break;\r\ncase 0x06: p = "A2-DK3"; break;\r\ncase 0x07: p = "A1 (6.0 MHz FM Mono)"; break;\r\ncase 0x08: p = "AM-L"; break;\r\ncase 0x09: p = "NICAM-BG"; break;\r\ncase 0x0a: p = "NICAM-DK"; break;\r\ncase 0x0b: p = "NICAM-I"; break;\r\ncase 0x0c: p = "NICAM-L"; break;\r\ncase 0x0d: p = "BTSC/EIAJ/A2-M Mono (4.5 MHz FMMono)"; break;\r\ncase 0x0e: p = "IF FM Radio"; break;\r\ncase 0x0f: p = "BTSC"; break;\r\ncase 0x10: p = "detected chrominance"; break;\r\ncase 0xfd: p = "unknown audio standard"; break;\r\ncase 0xfe: p = "forced audio standard"; break;\r\ncase 0xff: p = "no detected audio standard"; break;\r\ndefault: p = "not defined"; break;\r\n}\r\nCX18_INFO_DEV(sd, "Detected audio standard: %s\n", p);\r\nCX18_INFO_DEV(sd, "Audio muted: %s\n",\r\n(mute_ctl & 0x2) ? "yes" : "no");\r\nCX18_INFO_DEV(sd, "Audio microcontroller: %s\n",\r\n(download_ctl & 0x10) ? "running" : "stopped");\r\nswitch (audio_config >> 4) {\r\ncase 0x00: p = "undefined"; break;\r\ncase 0x01: p = "BTSC"; break;\r\ncase 0x02: p = "EIAJ"; break;\r\ncase 0x03: p = "A2-M"; break;\r\ncase 0x04: p = "A2-BG"; break;\r\ncase 0x05: p = "A2-DK1"; break;\r\ncase 0x06: p = "A2-DK2"; break;\r\ncase 0x07: p = "A2-DK3"; break;\r\ncase 0x08: p = "A1 (6.0 MHz FM Mono)"; break;\r\ncase 0x09: p = "AM-L"; break;\r\ncase 0x0a: p = "NICAM-BG"; break;\r\ncase 0x0b: p = "NICAM-DK"; break;\r\ncase 0x0c: p = "NICAM-I"; break;\r\ncase 0x0d: p = "NICAM-L"; break;\r\ncase 0x0e: p = "FM radio"; break;\r\ncase 0x0f: p = "automatic detection"; break;\r\ndefault: p = "undefined"; break;\r\n}\r\nCX18_INFO_DEV(sd, "Configured audio standard: %s\n", p);\r\nif ((audio_config >> 4) < 0xF) {\r\nswitch (audio_config & 0xF) {\r\ncase 0x00: p = "MONO1 (LANGUAGE A/Mono L+R channel for BTSC, EIAJ, A2)"; break;\r\ncase 0x01: p = "MONO2 (LANGUAGE B)"; break;\r\ncase 0x02: p = "MONO3 (STEREO forced MONO)"; break;\r\ncase 0x03: p = "MONO4 (NICAM ANALOG-Language C/Analog Fallback)"; break;\r\ncase 0x04: p = "STEREO"; break;\r\ncase 0x05: p = "DUAL1 (AC)"; break;\r\ncase 0x06: p = "DUAL2 (BC)"; break;\r\ncase 0x07: p = "DUAL3 (AB)"; break;\r\ndefault: p = "undefined";\r\n}\r\nCX18_INFO_DEV(sd, "Configured audio mode: %s\n", p);\r\n} else {\r\nswitch (audio_config & 0xF) {\r\ncase 0x00: p = "BG"; break;\r\ncase 0x01: p = "DK1"; break;\r\ncase 0x02: p = "DK2"; break;\r\ncase 0x03: p = "DK3"; break;\r\ncase 0x04: p = "I"; break;\r\ncase 0x05: p = "L"; break;\r\ncase 0x06: p = "BTSC"; break;\r\ncase 0x07: p = "EIAJ"; break;\r\ncase 0x08: p = "A2-M"; break;\r\ncase 0x09: p = "FM Radio (4.5 MHz)"; break;\r\ncase 0x0a: p = "FM Radio (5.5 MHz)"; break;\r\ncase 0x0b: p = "S-Video"; break;\r\ncase 0x0f: p = "automatic standard and mode detection"; break;\r\ndefault: p = "undefined"; break;\r\n}\r\nCX18_INFO_DEV(sd, "Configured audio system: %s\n", p);\r\n}\r\nif (aud_input)\r\nCX18_INFO_DEV(sd, "Specified audio input: Tuner (In%d)\n",\r\naud_input);\r\nelse\r\nCX18_INFO_DEV(sd, "Specified audio input: External\n");\r\nswitch (pref_mode & 0xf) {\r\ncase 0: p = "mono/language A"; break;\r\ncase 1: p = "language B"; break;\r\ncase 2: p = "language C"; break;\r\ncase 3: p = "analog fallback"; break;\r\ncase 4: p = "stereo"; break;\r\ncase 5: p = "language AC"; break;\r\ncase 6: p = "language BC"; break;\r\ncase 7: p = "language AB"; break;\r\ndefault: p = "undefined"; break;\r\n}\r\nCX18_INFO_DEV(sd, "Preferred audio mode: %s\n", p);\r\nif ((audio_config & 0xf) == 0xf) {\r\nswitch ((afc0 >> 3) & 0x1) {\r\ncase 0: p = "system DK"; break;\r\ncase 1: p = "system L"; break;\r\n}\r\nCX18_INFO_DEV(sd, "Selected 65 MHz format: %s\n", p);\r\nswitch (afc0 & 0x7) {\r\ncase 0: p = "Chroma"; break;\r\ncase 1: p = "BTSC"; break;\r\ncase 2: p = "EIAJ"; break;\r\ncase 3: p = "A2-M"; break;\r\ncase 4: p = "autodetect"; break;\r\ndefault: p = "undefined"; break;\r\n}\r\nCX18_INFO_DEV(sd, "Selected 45 MHz format: %s\n", p);\r\n}\r\n}\r\nstatic int cx18_av_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct cx18 *cx = v4l2_get_subdevdata(sd);\r\nlog_video_status(cx);\r\nlog_audio_status(cx);\r\nreturn 0;\r\n}\r\nstatic int cx18_av_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct cx18 *cx = v4l2_get_subdevdata(sd);\r\nif ((reg->reg & 0x3) != 0)\r\nreturn -EINVAL;\r\nreg->size = 4;\r\nreg->val = cx18_av_read4(cx, reg->reg & 0x00000ffc);\r\nreturn 0;\r\n}\r\nstatic int cx18_av_s_register(struct v4l2_subdev *sd,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct cx18 *cx = v4l2_get_subdevdata(sd);\r\nif ((reg->reg & 0x3) != 0)\r\nreturn -EINVAL;\r\ncx18_av_write4(cx, reg->reg & 0x00000ffc, reg->val);\r\nreturn 0;\r\n}\r\nint cx18_av_probe(struct cx18 *cx)\r\n{\r\nstruct cx18_av_state *state = &cx->av_state;\r\nstruct v4l2_subdev *sd;\r\nint err;\r\nstate->rev = cx18_av_read4(cx, CXADEC_CHIP_CTRL) & 0xffff;\r\nstate->vid_input = CX18_AV_COMPOSITE7;\r\nstate->aud_input = CX18_AV_AUDIO8;\r\nstate->audclk_freq = 48000;\r\nstate->audmode = V4L2_TUNER_MODE_LANG1;\r\nstate->slicer_line_delay = 0;\r\nstate->slicer_line_offset = (10 + state->slicer_line_delay - 2);\r\nsd = &state->sd;\r\nv4l2_subdev_init(sd, &cx18_av_ops);\r\nv4l2_set_subdevdata(sd, cx);\r\nsnprintf(sd->name, sizeof(sd->name),\r\n"%s %03x", cx->v4l2_dev.name, (state->rev >> 4));\r\nsd->grp_id = CX18_HW_418_AV;\r\nv4l2_ctrl_handler_init(&state->hdl, 9);\r\nv4l2_ctrl_new_std(&state->hdl, &cx18_av_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(&state->hdl, &cx18_av_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 127, 1, 64);\r\nv4l2_ctrl_new_std(&state->hdl, &cx18_av_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 127, 1, 64);\r\nv4l2_ctrl_new_std(&state->hdl, &cx18_av_ctrl_ops,\r\nV4L2_CID_HUE, -128, 127, 1, 0);\r\nstate->volume = v4l2_ctrl_new_std(&state->hdl,\r\n&cx18_av_audio_ctrl_ops, V4L2_CID_AUDIO_VOLUME,\r\n0, 65535, 65535 / 100, 0);\r\nv4l2_ctrl_new_std(&state->hdl,\r\n&cx18_av_audio_ctrl_ops, V4L2_CID_AUDIO_MUTE,\r\n0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&state->hdl, &cx18_av_audio_ctrl_ops,\r\nV4L2_CID_AUDIO_BALANCE,\r\n0, 65535, 65535 / 100, 32768);\r\nv4l2_ctrl_new_std(&state->hdl, &cx18_av_audio_ctrl_ops,\r\nV4L2_CID_AUDIO_BASS,\r\n0, 65535, 65535 / 100, 32768);\r\nv4l2_ctrl_new_std(&state->hdl, &cx18_av_audio_ctrl_ops,\r\nV4L2_CID_AUDIO_TREBLE,\r\n0, 65535, 65535 / 100, 32768);\r\nsd->ctrl_handler = &state->hdl;\r\nif (state->hdl.error) {\r\nint err = state->hdl.error;\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nreturn err;\r\n}\r\nerr = v4l2_device_register_subdev(&cx->v4l2_dev, sd);\r\nif (err)\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nelse\r\ncx18_av_init(cx);\r\nreturn err;\r\n}
