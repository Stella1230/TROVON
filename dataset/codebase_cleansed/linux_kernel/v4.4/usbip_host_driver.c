static int32_t read_attr_usbip_status(struct usbip_usb_device *udev)\r\n{\r\nchar status_attr_path[SYSFS_PATH_MAX];\r\nint fd;\r\nint length;\r\nchar status;\r\nint value = 0;\r\nsnprintf(status_attr_path, SYSFS_PATH_MAX, "%s/usbip_status",\r\nudev->path);\r\nfd = open(status_attr_path, O_RDONLY);\r\nif (fd < 0) {\r\nerr("error opening attribute %s", status_attr_path);\r\nreturn -1;\r\n}\r\nlength = read(fd, &status, 1);\r\nif (length < 0) {\r\nerr("error reading attribute %s", status_attr_path);\r\nclose(fd);\r\nreturn -1;\r\n}\r\nvalue = atoi(&status);\r\nreturn value;\r\n}\r\nstatic\r\nstruct usbip_exported_device *usbip_exported_device_new(const char *sdevpath)\r\n{\r\nstruct usbip_exported_device *edev = NULL;\r\nstruct usbip_exported_device *edev_old;\r\nsize_t size;\r\nint i;\r\nedev = calloc(1, sizeof(struct usbip_exported_device));\r\nedev->sudev = udev_device_new_from_syspath(udev_context, sdevpath);\r\nif (!edev->sudev) {\r\nerr("udev_device_new_from_syspath: %s", sdevpath);\r\ngoto err;\r\n}\r\nread_usb_device(edev->sudev, &edev->udev);\r\nedev->status = read_attr_usbip_status(&edev->udev);\r\nif (edev->status < 0)\r\ngoto err;\r\nsize = sizeof(struct usbip_exported_device) +\r\nedev->udev.bNumInterfaces * sizeof(struct usbip_usb_interface);\r\nedev_old = edev;\r\nedev = realloc(edev, size);\r\nif (!edev) {\r\nedev = edev_old;\r\ndbg("realloc failed");\r\ngoto err;\r\n}\r\nfor (i = 0; i < edev->udev.bNumInterfaces; i++)\r\nread_usb_interface(&edev->udev, i, &edev->uinf[i]);\r\nreturn edev;\r\nerr:\r\nif (edev->sudev)\r\nudev_device_unref(edev->sudev);\r\nif (edev)\r\nfree(edev);\r\nreturn NULL;\r\n}\r\nstatic int refresh_exported_devices(void)\r\n{\r\nstruct usbip_exported_device *edev;\r\nstruct udev_enumerate *enumerate;\r\nstruct udev_list_entry *devices, *dev_list_entry;\r\nstruct udev_device *dev;\r\nconst char *path;\r\nconst char *driver;\r\nenumerate = udev_enumerate_new(udev_context);\r\nudev_enumerate_add_match_subsystem(enumerate, "usb");\r\nudev_enumerate_scan_devices(enumerate);\r\ndevices = udev_enumerate_get_list_entry(enumerate);\r\nudev_list_entry_foreach(dev_list_entry, devices) {\r\npath = udev_list_entry_get_name(dev_list_entry);\r\ndev = udev_device_new_from_syspath(udev_context, path);\r\nif (dev == NULL)\r\ncontinue;\r\ndriver = udev_device_get_driver(dev);\r\nif (driver != NULL && !strcmp(driver, USBIP_HOST_DRV_NAME)) {\r\nedev = usbip_exported_device_new(path);\r\nif (!edev) {\r\ndbg("usbip_exported_device_new failed");\r\ncontinue;\r\n}\r\nlist_add(&edev->node, &host_driver->edev_list);\r\nhost_driver->ndevs++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void usbip_exported_device_destroy(void)\r\n{\r\nstruct list_head *i, *tmp;\r\nstruct usbip_exported_device *edev;\r\nlist_for_each_safe(i, tmp, &host_driver->edev_list) {\r\nedev = list_entry(i, struct usbip_exported_device, node);\r\nlist_del(i);\r\nfree(edev);\r\n}\r\n}\r\nint usbip_host_driver_open(void)\r\n{\r\nint rc;\r\nudev_context = udev_new();\r\nif (!udev_context) {\r\nerr("udev_new failed");\r\nreturn -1;\r\n}\r\nhost_driver = calloc(1, sizeof(*host_driver));\r\nhost_driver->ndevs = 0;\r\nINIT_LIST_HEAD(&host_driver->edev_list);\r\nrc = refresh_exported_devices();\r\nif (rc < 0)\r\ngoto err_free_host_driver;\r\nreturn 0;\r\nerr_free_host_driver:\r\nfree(host_driver);\r\nhost_driver = NULL;\r\nudev_unref(udev_context);\r\nreturn -1;\r\n}\r\nvoid usbip_host_driver_close(void)\r\n{\r\nif (!host_driver)\r\nreturn;\r\nusbip_exported_device_destroy();\r\nfree(host_driver);\r\nhost_driver = NULL;\r\nudev_unref(udev_context);\r\n}\r\nint usbip_host_refresh_device_list(void)\r\n{\r\nint rc;\r\nusbip_exported_device_destroy();\r\nhost_driver->ndevs = 0;\r\nINIT_LIST_HEAD(&host_driver->edev_list);\r\nrc = refresh_exported_devices();\r\nif (rc < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint usbip_host_export_device(struct usbip_exported_device *edev, int sockfd)\r\n{\r\nchar attr_name[] = "usbip_sockfd";\r\nchar sockfd_attr_path[SYSFS_PATH_MAX];\r\nchar sockfd_buff[30];\r\nint ret;\r\nif (edev->status != SDEV_ST_AVAILABLE) {\r\ndbg("device not available: %s", edev->udev.busid);\r\nswitch (edev->status) {\r\ncase SDEV_ST_ERROR:\r\ndbg("status SDEV_ST_ERROR");\r\nbreak;\r\ncase SDEV_ST_USED:\r\ndbg("status SDEV_ST_USED");\r\nbreak;\r\ndefault:\r\ndbg("status unknown: 0x%x", edev->status);\r\n}\r\nreturn -1;\r\n}\r\nsnprintf(sockfd_attr_path, sizeof(sockfd_attr_path), "%s/%s",\r\nedev->udev.path, attr_name);\r\nsnprintf(sockfd_buff, sizeof(sockfd_buff), "%d\n", sockfd);\r\nret = write_sysfs_attribute(sockfd_attr_path, sockfd_buff,\r\nstrlen(sockfd_buff));\r\nif (ret < 0) {\r\nerr("write_sysfs_attribute failed: sockfd %s to %s",\r\nsockfd_buff, sockfd_attr_path);\r\nreturn ret;\r\n}\r\ninfo("connect: %s", edev->udev.busid);\r\nreturn ret;\r\n}\r\nstruct usbip_exported_device *usbip_host_get_device(int num)\r\n{\r\nstruct list_head *i;\r\nstruct usbip_exported_device *edev;\r\nint cnt = 0;\r\nlist_for_each(i, &host_driver->edev_list) {\r\nedev = list_entry(i, struct usbip_exported_device, node);\r\nif (num == cnt)\r\nreturn edev;\r\nelse\r\ncnt++;\r\n}\r\nreturn NULL;\r\n}
