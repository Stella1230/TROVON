static inline unsigned long deap_pfn(u8 edeap, u32 deap)\r\n{\r\ndeap >>= PAGE_SHIFT;\r\ndeap |= (edeap & 1) << (32 - PAGE_SHIFT);\r\nreturn deap;\r\n}\r\nstatic inline unsigned long deap_offset(u32 deap)\r\n{\r\nreturn deap & ~(I3000_DEAP_GRAIN - 1) & ~PAGE_MASK;\r\n}\r\nstatic inline int deap_channel(u32 deap)\r\n{\r\nreturn deap & 1;\r\n}\r\nstatic inline unsigned char odd_rank_attrib(unsigned char dra)\r\n{\r\nreturn (dra & 0x70) >> 4;\r\n}\r\nstatic inline unsigned char even_rank_attrib(unsigned char dra)\r\n{\r\nreturn dra & 0x07;\r\n}\r\nstatic void i3000_get_error_info(struct mem_ctl_info *mci,\r\nstruct i3000_error_info *info)\r\n{\r\nstruct pci_dev *pdev;\r\npdev = to_pci_dev(mci->pdev);\r\npci_read_config_word(pdev, I3000_ERRSTS, &info->errsts);\r\nif (!(info->errsts & I3000_ERRSTS_BITS))\r\nreturn;\r\npci_read_config_byte(pdev, I3000_EDEAP, &info->edeap);\r\npci_read_config_dword(pdev, I3000_DEAP, &info->deap);\r\npci_read_config_byte(pdev, I3000_DERRSYN, &info->derrsyn);\r\npci_read_config_word(pdev, I3000_ERRSTS, &info->errsts2);\r\nif ((info->errsts ^ info->errsts2) & I3000_ERRSTS_BITS) {\r\npci_read_config_byte(pdev, I3000_EDEAP, &info->edeap);\r\npci_read_config_dword(pdev, I3000_DEAP, &info->deap);\r\npci_read_config_byte(pdev, I3000_DERRSYN, &info->derrsyn);\r\n}\r\npci_write_bits16(pdev, I3000_ERRSTS, I3000_ERRSTS_BITS,\r\nI3000_ERRSTS_BITS);\r\n}\r\nstatic int i3000_process_error_info(struct mem_ctl_info *mci,\r\nstruct i3000_error_info *info,\r\nint handle_errors)\r\n{\r\nint row, multi_chan, channel;\r\nunsigned long pfn, offset;\r\nmulti_chan = mci->csrows[0]->nr_channels - 1;\r\nif (!(info->errsts & I3000_ERRSTS_BITS))\r\nreturn 0;\r\nif (!handle_errors)\r\nreturn 1;\r\nif ((info->errsts ^ info->errsts2) & I3000_ERRSTS_BITS) {\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,\r\n-1, -1, -1,\r\n"UE overwrote CE", "");\r\ninfo->errsts = info->errsts2;\r\n}\r\npfn = deap_pfn(info->edeap, info->deap);\r\noffset = deap_offset(info->deap);\r\nchannel = deap_channel(info->deap);\r\nrow = edac_mc_find_csrow_by_page(mci, pfn);\r\nif (info->errsts & I3000_ERRSTS_UE)\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\r\npfn, offset, 0,\r\nrow, -1, -1,\r\n"i3000 UE", "");\r\nelse\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\npfn, offset, info->derrsyn,\r\nrow, multi_chan ? channel : 0, -1,\r\n"i3000 CE", "");\r\nreturn 1;\r\n}\r\nstatic void i3000_check(struct mem_ctl_info *mci)\r\n{\r\nstruct i3000_error_info info;\r\nedac_dbg(1, "MC%d\n", mci->mc_idx);\r\ni3000_get_error_info(mci, &info);\r\ni3000_process_error_info(mci, &info, 1);\r\n}\r\nstatic int i3000_is_interleaved(const unsigned char *c0dra,\r\nconst unsigned char *c1dra,\r\nconst unsigned char *c0drb,\r\nconst unsigned char *c1drb)\r\n{\r\nint i;\r\nfor (i = 0; i < I3000_RANKS_PER_CHANNEL / 2; i++)\r\nif (odd_rank_attrib(c0dra[i]) != odd_rank_attrib(c1dra[i]) ||\r\neven_rank_attrib(c0dra[i]) !=\r\neven_rank_attrib(c1dra[i]))\r\nreturn 0;\r\nfor (i = 0; i < I3000_RANKS_PER_CHANNEL; i++)\r\nif (c0drb[i] != c1drb[i])\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int i3000_probe1(struct pci_dev *pdev, int dev_idx)\r\n{\r\nint rc;\r\nint i, j;\r\nstruct mem_ctl_info *mci = NULL;\r\nstruct edac_mc_layer layers[2];\r\nunsigned long last_cumul_size, nr_pages;\r\nint interleaved, nr_channels;\r\nunsigned char dra[I3000_RANKS / 2], drb[I3000_RANKS];\r\nunsigned char *c0dra = dra, *c1dra = &dra[I3000_RANKS_PER_CHANNEL / 2];\r\nunsigned char *c0drb = drb, *c1drb = &drb[I3000_RANKS_PER_CHANNEL];\r\nunsigned long mchbar;\r\nvoid __iomem *window;\r\nedac_dbg(0, "MC:\n");\r\npci_read_config_dword(pdev, I3000_MCHBAR, (u32 *) & mchbar);\r\nmchbar &= I3000_MCHBAR_MASK;\r\nwindow = ioremap_nocache(mchbar, I3000_MMR_WINDOW_SIZE);\r\nif (!window) {\r\nprintk(KERN_ERR "i3000: cannot map mmio space at 0x%lx\n",\r\nmchbar);\r\nreturn -ENODEV;\r\n}\r\nc0dra[0] = readb(window + I3000_C0DRA + 0);\r\nc0dra[1] = readb(window + I3000_C0DRA + 1);\r\nc1dra[0] = readb(window + I3000_C1DRA + 0);\r\nc1dra[1] = readb(window + I3000_C1DRA + 1);\r\nfor (i = 0; i < I3000_RANKS_PER_CHANNEL; i++) {\r\nc0drb[i] = readb(window + I3000_C0DRB + i);\r\nc1drb[i] = readb(window + I3000_C1DRB + i);\r\n}\r\niounmap(window);\r\ninterleaved = i3000_is_interleaved(c0dra, c1dra, c0drb, c1drb);\r\nnr_channels = interleaved ? 2 : 1;\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = I3000_RANKS / nr_channels;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = nr_channels;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, 0);\r\nif (!mci)\r\nreturn -ENOMEM;\r\nedac_dbg(3, "MC: init mci\n");\r\nmci->pdev = &pdev->dev;\r\nmci->mtype_cap = MEM_FLAG_DDR2;\r\nmci->edac_ctl_cap = EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_SECDED;\r\nmci->mod_name = EDAC_MOD_STR;\r\nmci->mod_ver = I3000_REVISION;\r\nmci->ctl_name = i3000_devs[dev_idx].ctl_name;\r\nmci->dev_name = pci_name(pdev);\r\nmci->edac_check = i3000_check;\r\nmci->ctl_page_to_phys = NULL;\r\nfor (last_cumul_size = i = 0; i < mci->nr_csrows; i++) {\r\nu8 value;\r\nu32 cumul_size;\r\nstruct csrow_info *csrow = mci->csrows[i];\r\nvalue = drb[i];\r\ncumul_size = value << (I3000_DRB_SHIFT - PAGE_SHIFT);\r\nif (interleaved)\r\ncumul_size <<= 1;\r\nedac_dbg(3, "MC: (%d) cumul_size 0x%x\n", i, cumul_size);\r\nif (cumul_size == last_cumul_size)\r\ncontinue;\r\ncsrow->first_page = last_cumul_size;\r\ncsrow->last_page = cumul_size - 1;\r\nnr_pages = cumul_size - last_cumul_size;\r\nlast_cumul_size = cumul_size;\r\nfor (j = 0; j < nr_channels; j++) {\r\nstruct dimm_info *dimm = csrow->channels[j]->dimm;\r\ndimm->nr_pages = nr_pages / nr_channels;\r\ndimm->grain = I3000_DEAP_GRAIN;\r\ndimm->mtype = MEM_DDR2;\r\ndimm->dtype = DEV_UNKNOWN;\r\ndimm->edac_mode = EDAC_UNKNOWN;\r\n}\r\n}\r\npci_write_bits16(pdev, I3000_ERRSTS, I3000_ERRSTS_BITS,\r\nI3000_ERRSTS_BITS);\r\nrc = -ENODEV;\r\nif (edac_mc_add_mc(mci)) {\r\nedac_dbg(3, "MC: failed edac_mc_add_mc()\n");\r\ngoto fail;\r\n}\r\ni3000_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\r\nif (!i3000_pci) {\r\nprintk(KERN_WARNING\r\n"%s(): Unable to create PCI control\n",\r\n__func__);\r\nprintk(KERN_WARNING\r\n"%s(): PCI error report via EDAC not setup\n",\r\n__func__);\r\n}\r\nedac_dbg(3, "MC: success\n");\r\nreturn 0;\r\nfail:\r\nif (mci)\r\nedac_mc_free(mci);\r\nreturn rc;\r\n}\r\nstatic int i3000_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint rc;\r\nedac_dbg(0, "MC:\n");\r\nif (pci_enable_device(pdev) < 0)\r\nreturn -EIO;\r\nrc = i3000_probe1(pdev, ent->driver_data);\r\nif (!mci_pdev)\r\nmci_pdev = pci_dev_get(pdev);\r\nreturn rc;\r\n}\r\nstatic void i3000_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nedac_dbg(0, "\n");\r\nif (i3000_pci)\r\nedac_pci_release_generic_ctl(i3000_pci);\r\nmci = edac_mc_del_mc(&pdev->dev);\r\nif (!mci)\r\nreturn;\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init i3000_init(void)\r\n{\r\nint pci_rc;\r\nedac_dbg(3, "MC:\n");\r\nopstate_init();\r\npci_rc = pci_register_driver(&i3000_driver);\r\nif (pci_rc < 0)\r\ngoto fail0;\r\nif (!mci_pdev) {\r\ni3000_registered = 0;\r\nmci_pdev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_3000_HB, NULL);\r\nif (!mci_pdev) {\r\nedac_dbg(0, "i3000 pci_get_device fail\n");\r\npci_rc = -ENODEV;\r\ngoto fail1;\r\n}\r\npci_rc = i3000_init_one(mci_pdev, i3000_pci_tbl);\r\nif (pci_rc < 0) {\r\nedac_dbg(0, "i3000 init fail\n");\r\npci_rc = -ENODEV;\r\ngoto fail1;\r\n}\r\n}\r\nreturn 0;\r\nfail1:\r\npci_unregister_driver(&i3000_driver);\r\nfail0:\r\npci_dev_put(mci_pdev);\r\nreturn pci_rc;\r\n}\r\nstatic void __exit i3000_exit(void)\r\n{\r\nedac_dbg(3, "MC:\n");\r\npci_unregister_driver(&i3000_driver);\r\nif (!i3000_registered) {\r\ni3000_remove_one(mci_pdev);\r\npci_dev_put(mci_pdev);\r\n}\r\n}
