static struct list_head *merge(void *priv,\r\nint (*cmp)(void *priv, struct list_head *a,\r\nstruct list_head *b),\r\nstruct list_head *a, struct list_head *b)\r\n{\r\nstruct list_head head, *tail = &head;\r\nwhile (a && b) {\r\nif ((*cmp)(priv, a, b) <= 0) {\r\ntail->next = a;\r\na = a->next;\r\n} else {\r\ntail->next = b;\r\nb = b->next;\r\n}\r\ntail = tail->next;\r\n}\r\ntail->next = a?:b;\r\nreturn head.next;\r\n}\r\nstatic void merge_and_restore_back_links(void *priv,\r\nint (*cmp)(void *priv, struct list_head *a,\r\nstruct list_head *b),\r\nstruct list_head *head,\r\nstruct list_head *a, struct list_head *b)\r\n{\r\nstruct list_head *tail = head;\r\nu8 count = 0;\r\nwhile (a && b) {\r\nif ((*cmp)(priv, a, b) <= 0) {\r\ntail->next = a;\r\na->prev = tail;\r\na = a->next;\r\n} else {\r\ntail->next = b;\r\nb->prev = tail;\r\nb = b->next;\r\n}\r\ntail = tail->next;\r\n}\r\ntail->next = a ? : b;\r\ndo {\r\nif (unlikely(!(++count)))\r\n(*cmp)(priv, tail->next, tail->next);\r\ntail->next->prev = tail;\r\ntail = tail->next;\r\n} while (tail->next);\r\ntail->next = head;\r\nhead->prev = tail;\r\n}\r\nvoid list_sort(void *priv, struct list_head *head,\r\nint (*cmp)(void *priv, struct list_head *a,\r\nstruct list_head *b))\r\n{\r\nstruct list_head *part[MAX_LIST_LENGTH_BITS+1];\r\nint lev;\r\nint max_lev = 0;\r\nstruct list_head *list;\r\nif (list_empty(head))\r\nreturn;\r\nmemset(part, 0, sizeof(part));\r\nhead->prev->next = NULL;\r\nlist = head->next;\r\nwhile (list) {\r\nstruct list_head *cur = list;\r\nlist = list->next;\r\ncur->next = NULL;\r\nfor (lev = 0; part[lev]; lev++) {\r\ncur = merge(priv, cmp, part[lev], cur);\r\npart[lev] = NULL;\r\n}\r\nif (lev > max_lev) {\r\nif (unlikely(lev >= ARRAY_SIZE(part)-1)) {\r\nprintk_once(KERN_DEBUG "list too long for efficiency\n");\r\nlev--;\r\n}\r\nmax_lev = lev;\r\n}\r\npart[lev] = cur;\r\n}\r\nfor (lev = 0; lev < max_lev; lev++)\r\nif (part[lev])\r\nlist = merge(priv, cmp, part[lev], list);\r\nmerge_and_restore_back_links(priv, cmp, head, part[max_lev], list);\r\n}\r\nstatic int __init check(struct debug_el *ela, struct debug_el *elb)\r\n{\r\nif (ela->serial >= TEST_LIST_LEN) {\r\npr_err("error: incorrect serial %d\n", ela->serial);\r\nreturn -EINVAL;\r\n}\r\nif (elb->serial >= TEST_LIST_LEN) {\r\npr_err("error: incorrect serial %d\n", elb->serial);\r\nreturn -EINVAL;\r\n}\r\nif (elts[ela->serial] != ela || elts[elb->serial] != elb) {\r\npr_err("error: phantom element\n");\r\nreturn -EINVAL;\r\n}\r\nif (ela->poison1 != TEST_POISON1 || ela->poison2 != TEST_POISON2) {\r\npr_err("error: bad poison: %#x/%#x\n",\r\nela->poison1, ela->poison2);\r\nreturn -EINVAL;\r\n}\r\nif (elb->poison1 != TEST_POISON1 || elb->poison2 != TEST_POISON2) {\r\npr_err("error: bad poison: %#x/%#x\n",\r\nelb->poison1, elb->poison2);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init cmp(void *priv, struct list_head *a, struct list_head *b)\r\n{\r\nstruct debug_el *ela, *elb;\r\nela = container_of(a, struct debug_el, list);\r\nelb = container_of(b, struct debug_el, list);\r\ncheck(ela, elb);\r\nreturn ela->value - elb->value;\r\n}\r\nstatic int __init list_sort_test(void)\r\n{\r\nint i, count = 1, err = -ENOMEM;\r\nstruct debug_el *el;\r\nstruct list_head *cur;\r\nLIST_HEAD(head);\r\npr_debug("start testing list_sort()\n");\r\nelts = kcalloc(TEST_LIST_LEN, sizeof(*elts), GFP_KERNEL);\r\nif (!elts) {\r\npr_err("error: cannot allocate memory\n");\r\nreturn err;\r\n}\r\nfor (i = 0; i < TEST_LIST_LEN; i++) {\r\nel = kmalloc(sizeof(*el), GFP_KERNEL);\r\nif (!el) {\r\npr_err("error: cannot allocate memory\n");\r\ngoto exit;\r\n}\r\nel->value = prandom_u32() % (TEST_LIST_LEN / 3);\r\nel->serial = i;\r\nel->poison1 = TEST_POISON1;\r\nel->poison2 = TEST_POISON2;\r\nelts[i] = el;\r\nlist_add_tail(&el->list, &head);\r\n}\r\nlist_sort(NULL, &head, cmp);\r\nerr = -EINVAL;\r\nfor (cur = head.next; cur->next != &head; cur = cur->next) {\r\nstruct debug_el *el1;\r\nint cmp_result;\r\nif (cur->next->prev != cur) {\r\npr_err("error: list is corrupted\n");\r\ngoto exit;\r\n}\r\ncmp_result = cmp(NULL, cur, cur->next);\r\nif (cmp_result > 0) {\r\npr_err("error: list is not sorted\n");\r\ngoto exit;\r\n}\r\nel = container_of(cur, struct debug_el, list);\r\nel1 = container_of(cur->next, struct debug_el, list);\r\nif (cmp_result == 0 && el->serial >= el1->serial) {\r\npr_err("error: order of equivalent elements not "\r\n"preserved\n");\r\ngoto exit;\r\n}\r\nif (check(el, el1)) {\r\npr_err("error: element check failed\n");\r\ngoto exit;\r\n}\r\ncount++;\r\n}\r\nif (head.prev != cur) {\r\npr_err("error: list is corrupted\n");\r\ngoto exit;\r\n}\r\nif (count != TEST_LIST_LEN) {\r\npr_err("error: bad list length %d", count);\r\ngoto exit;\r\n}\r\nerr = 0;\r\nexit:\r\nfor (i = 0; i < TEST_LIST_LEN; i++)\r\nkfree(elts[i]);\r\nkfree(elts);\r\nreturn err;\r\n}
