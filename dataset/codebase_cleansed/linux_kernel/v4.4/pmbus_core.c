void pmbus_clear_cache(struct i2c_client *client)\r\n{\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\ndata->valid = false;\r\n}\r\nint pmbus_set_page(struct i2c_client *client, u8 page)\r\n{\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nint rv = 0;\r\nint newpage;\r\nif (page != data->currpage) {\r\nrv = i2c_smbus_write_byte_data(client, PMBUS_PAGE, page);\r\nnewpage = i2c_smbus_read_byte_data(client, PMBUS_PAGE);\r\nif (newpage != page)\r\nrv = -EIO;\r\nelse\r\ndata->currpage = page;\r\n}\r\nreturn rv;\r\n}\r\nint pmbus_write_byte(struct i2c_client *client, int page, u8 value)\r\n{\r\nint rv;\r\nif (page >= 0) {\r\nrv = pmbus_set_page(client, page);\r\nif (rv < 0)\r\nreturn rv;\r\n}\r\nreturn i2c_smbus_write_byte(client, value);\r\n}\r\nstatic int _pmbus_write_byte(struct i2c_client *client, int page, u8 value)\r\n{\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nconst struct pmbus_driver_info *info = data->info;\r\nint status;\r\nif (info->write_byte) {\r\nstatus = info->write_byte(client, page, value);\r\nif (status != -ENODATA)\r\nreturn status;\r\n}\r\nreturn pmbus_write_byte(client, page, value);\r\n}\r\nint pmbus_write_word_data(struct i2c_client *client, u8 page, u8 reg, u16 word)\r\n{\r\nint rv;\r\nrv = pmbus_set_page(client, page);\r\nif (rv < 0)\r\nreturn rv;\r\nreturn i2c_smbus_write_word_data(client, reg, word);\r\n}\r\nstatic int _pmbus_write_word_data(struct i2c_client *client, int page, int reg,\r\nu16 word)\r\n{\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nconst struct pmbus_driver_info *info = data->info;\r\nint status;\r\nif (info->write_word_data) {\r\nstatus = info->write_word_data(client, page, reg, word);\r\nif (status != -ENODATA)\r\nreturn status;\r\n}\r\nif (reg >= PMBUS_VIRT_BASE)\r\nreturn -ENXIO;\r\nreturn pmbus_write_word_data(client, page, reg, word);\r\n}\r\nint pmbus_read_word_data(struct i2c_client *client, u8 page, u8 reg)\r\n{\r\nint rv;\r\nrv = pmbus_set_page(client, page);\r\nif (rv < 0)\r\nreturn rv;\r\nreturn i2c_smbus_read_word_data(client, reg);\r\n}\r\nstatic int _pmbus_read_word_data(struct i2c_client *client, int page, int reg)\r\n{\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nconst struct pmbus_driver_info *info = data->info;\r\nint status;\r\nif (info->read_word_data) {\r\nstatus = info->read_word_data(client, page, reg);\r\nif (status != -ENODATA)\r\nreturn status;\r\n}\r\nif (reg >= PMBUS_VIRT_BASE)\r\nreturn -ENXIO;\r\nreturn pmbus_read_word_data(client, page, reg);\r\n}\r\nint pmbus_read_byte_data(struct i2c_client *client, int page, u8 reg)\r\n{\r\nint rv;\r\nif (page >= 0) {\r\nrv = pmbus_set_page(client, page);\r\nif (rv < 0)\r\nreturn rv;\r\n}\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nint pmbus_write_byte_data(struct i2c_client *client, int page, u8 reg, u8 value)\r\n{\r\nint rv;\r\nrv = pmbus_set_page(client, page);\r\nif (rv < 0)\r\nreturn rv;\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nint pmbus_update_byte_data(struct i2c_client *client, int page, u8 reg,\r\nu8 mask, u8 value)\r\n{\r\nunsigned int tmp;\r\nint rv;\r\nrv = pmbus_read_byte_data(client, page, reg);\r\nif (rv < 0)\r\nreturn rv;\r\ntmp = (rv & ~mask) | (value & mask);\r\nif (tmp != rv)\r\nrv = pmbus_write_byte_data(client, page, reg, tmp);\r\nreturn rv;\r\n}\r\nstatic int _pmbus_read_byte_data(struct i2c_client *client, int page, int reg)\r\n{\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nconst struct pmbus_driver_info *info = data->info;\r\nint status;\r\nif (info->read_byte_data) {\r\nstatus = info->read_byte_data(client, page, reg);\r\nif (status != -ENODATA)\r\nreturn status;\r\n}\r\nreturn pmbus_read_byte_data(client, page, reg);\r\n}\r\nstatic void pmbus_clear_fault_page(struct i2c_client *client, int page)\r\n{\r\n_pmbus_write_byte(client, page, PMBUS_CLEAR_FAULTS);\r\n}\r\nvoid pmbus_clear_faults(struct i2c_client *client)\r\n{\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nint i;\r\nfor (i = 0; i < data->info->pages; i++)\r\npmbus_clear_fault_page(client, i);\r\n}\r\nstatic int pmbus_check_status_cml(struct i2c_client *client)\r\n{\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nint status, status2;\r\nstatus = _pmbus_read_byte_data(client, -1, data->status_register);\r\nif (status < 0 || (status & PB_STATUS_CML)) {\r\nstatus2 = _pmbus_read_byte_data(client, -1, PMBUS_STATUS_CML);\r\nif (status2 < 0 || (status2 & PB_CML_FAULT_INVALID_COMMAND))\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool pmbus_check_register(struct i2c_client *client,\r\nint (*func)(struct i2c_client *client,\r\nint page, int reg),\r\nint page, int reg)\r\n{\r\nint rv;\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nrv = func(client, page, reg);\r\nif (rv >= 0 && !(data->flags & PMBUS_SKIP_STATUS_CHECK))\r\nrv = pmbus_check_status_cml(client);\r\npmbus_clear_fault_page(client, -1);\r\nreturn rv >= 0;\r\n}\r\nbool pmbus_check_byte_register(struct i2c_client *client, int page, int reg)\r\n{\r\nreturn pmbus_check_register(client, _pmbus_read_byte_data, page, reg);\r\n}\r\nbool pmbus_check_word_register(struct i2c_client *client, int page, int reg)\r\n{\r\nreturn pmbus_check_register(client, _pmbus_read_word_data, page, reg);\r\n}\r\nconst struct pmbus_driver_info *pmbus_get_driver_info(struct i2c_client *client)\r\n{\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nreturn data->info;\r\n}\r\nstatic struct pmbus_data *pmbus_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev->parent);\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nconst struct pmbus_driver_info *info = data->info;\r\nstruct pmbus_sensor *sensor;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\r\nint i, j;\r\nfor (i = 0; i < info->pages; i++) {\r\ndata->status[PB_STATUS_BASE + i]\r\n= _pmbus_read_byte_data(client, i,\r\ndata->status_register);\r\nfor (j = 0; j < ARRAY_SIZE(pmbus_status); j++) {\r\nstruct _pmbus_status *s = &pmbus_status[j];\r\nif (!(info->func[i] & s->func))\r\ncontinue;\r\ndata->status[s->base + i]\r\n= _pmbus_read_byte_data(client, i,\r\ns->reg);\r\n}\r\n}\r\nif (info->func[0] & PMBUS_HAVE_STATUS_INPUT)\r\ndata->status[PB_STATUS_INPUT_BASE]\r\n= _pmbus_read_byte_data(client, 0,\r\nPMBUS_STATUS_INPUT);\r\nif (info->func[0] & PMBUS_HAVE_STATUS_VMON)\r\ndata->status[PB_STATUS_VMON_BASE]\r\n= _pmbus_read_byte_data(client, 0,\r\nPMBUS_VIRT_STATUS_VMON);\r\nfor (sensor = data->sensors; sensor; sensor = sensor->next) {\r\nif (!data->valid || sensor->update)\r\nsensor->data\r\n= _pmbus_read_word_data(client,\r\nsensor->page,\r\nsensor->reg);\r\n}\r\npmbus_clear_faults(client);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic long pmbus_reg2data_linear(struct pmbus_data *data,\r\nstruct pmbus_sensor *sensor)\r\n{\r\ns16 exponent;\r\ns32 mantissa;\r\nlong val;\r\nif (sensor->class == PSC_VOLTAGE_OUT) {\r\nexponent = data->exponent[sensor->page];\r\nmantissa = (u16) sensor->data;\r\n} else {\r\nexponent = ((s16)sensor->data) >> 11;\r\nmantissa = ((s16)((sensor->data & 0x7ff) << 5)) >> 5;\r\n}\r\nval = mantissa;\r\nif (sensor->class != PSC_FAN)\r\nval = val * 1000L;\r\nif (sensor->class == PSC_POWER)\r\nval = val * 1000L;\r\nif (exponent >= 0)\r\nval <<= exponent;\r\nelse\r\nval >>= -exponent;\r\nreturn val;\r\n}\r\nstatic long pmbus_reg2data_direct(struct pmbus_data *data,\r\nstruct pmbus_sensor *sensor)\r\n{\r\nlong val = (s16) sensor->data;\r\nlong m, b, R;\r\nm = data->info->m[sensor->class];\r\nb = data->info->b[sensor->class];\r\nR = data->info->R[sensor->class];\r\nif (m == 0)\r\nreturn 0;\r\nR = -R;\r\nif (sensor->class != PSC_FAN) {\r\nR += 3;\r\nb *= 1000;\r\n}\r\nif (sensor->class == PSC_POWER) {\r\nR += 3;\r\nb *= 1000;\r\n}\r\nwhile (R > 0) {\r\nval *= 10;\r\nR--;\r\n}\r\nwhile (R < 0) {\r\nval = DIV_ROUND_CLOSEST(val, 10);\r\nR++;\r\n}\r\nreturn (val - b) / m;\r\n}\r\nstatic long pmbus_reg2data_vid(struct pmbus_data *data,\r\nstruct pmbus_sensor *sensor)\r\n{\r\nlong val = sensor->data;\r\nlong rv = 0;\r\nswitch (data->info->vrm_version) {\r\ncase vr11:\r\nif (val >= 0x02 && val <= 0xb2)\r\nrv = DIV_ROUND_CLOSEST(160000 - (val - 2) * 625, 100);\r\nbreak;\r\ncase vr12:\r\nif (val >= 0x01)\r\nrv = 250 + (val - 1) * 5;\r\nbreak;\r\n}\r\nreturn rv;\r\n}\r\nstatic long pmbus_reg2data(struct pmbus_data *data, struct pmbus_sensor *sensor)\r\n{\r\nlong val;\r\nswitch (data->info->format[sensor->class]) {\r\ncase direct:\r\nval = pmbus_reg2data_direct(data, sensor);\r\nbreak;\r\ncase vid:\r\nval = pmbus_reg2data_vid(data, sensor);\r\nbreak;\r\ncase linear:\r\ndefault:\r\nval = pmbus_reg2data_linear(data, sensor);\r\nbreak;\r\n}\r\nreturn val;\r\n}\r\nstatic u16 pmbus_data2reg_linear(struct pmbus_data *data,\r\nstruct pmbus_sensor *sensor, long val)\r\n{\r\ns16 exponent = 0, mantissa;\r\nbool negative = false;\r\nif (val == 0)\r\nreturn 0;\r\nif (sensor->class == PSC_VOLTAGE_OUT) {\r\nif (val < 0)\r\nreturn 0;\r\nif (data->exponent[sensor->page] < 0)\r\nval <<= -data->exponent[sensor->page];\r\nelse\r\nval >>= data->exponent[sensor->page];\r\nval = DIV_ROUND_CLOSEST(val, 1000);\r\nreturn val & 0xffff;\r\n}\r\nif (val < 0) {\r\nnegative = true;\r\nval = -val;\r\n}\r\nif (sensor->class == PSC_POWER)\r\nval = DIV_ROUND_CLOSEST(val, 1000L);\r\nif (sensor->class == PSC_FAN)\r\nval = val * 1000;\r\nwhile (val >= MAX_MANTISSA && exponent < 15) {\r\nexponent++;\r\nval >>= 1;\r\n}\r\nwhile (val < MIN_MANTISSA && exponent > -15) {\r\nexponent--;\r\nval <<= 1;\r\n}\r\nmantissa = DIV_ROUND_CLOSEST(val, 1000);\r\nif (mantissa > 0x3ff)\r\nmantissa = 0x3ff;\r\nif (negative)\r\nmantissa = -mantissa;\r\nreturn (mantissa & 0x7ff) | ((exponent << 11) & 0xf800);\r\n}\r\nstatic u16 pmbus_data2reg_direct(struct pmbus_data *data,\r\nstruct pmbus_sensor *sensor, long val)\r\n{\r\nlong m, b, R;\r\nm = data->info->m[sensor->class];\r\nb = data->info->b[sensor->class];\r\nR = data->info->R[sensor->class];\r\nif (sensor->class == PSC_POWER) {\r\nR -= 3;\r\nb *= 1000;\r\n}\r\nif (sensor->class != PSC_FAN) {\r\nR -= 3;\r\nb *= 1000;\r\n}\r\nval = val * m + b;\r\nwhile (R > 0) {\r\nval *= 10;\r\nR--;\r\n}\r\nwhile (R < 0) {\r\nval = DIV_ROUND_CLOSEST(val, 10);\r\nR++;\r\n}\r\nreturn val;\r\n}\r\nstatic u16 pmbus_data2reg_vid(struct pmbus_data *data,\r\nstruct pmbus_sensor *sensor, long val)\r\n{\r\nval = clamp_val(val, 500, 1600);\r\nreturn 2 + DIV_ROUND_CLOSEST((1600 - val) * 100, 625);\r\n}\r\nstatic u16 pmbus_data2reg(struct pmbus_data *data,\r\nstruct pmbus_sensor *sensor, long val)\r\n{\r\nu16 regval;\r\nswitch (data->info->format[sensor->class]) {\r\ncase direct:\r\nregval = pmbus_data2reg_direct(data, sensor, val);\r\nbreak;\r\ncase vid:\r\nregval = pmbus_data2reg_vid(data, sensor, val);\r\nbreak;\r\ncase linear:\r\ndefault:\r\nregval = pmbus_data2reg_linear(data, sensor, val);\r\nbreak;\r\n}\r\nreturn regval;\r\n}\r\nstatic int pmbus_get_boolean(struct pmbus_data *data, struct pmbus_boolean *b,\r\nint index)\r\n{\r\nstruct pmbus_sensor *s1 = b->s1;\r\nstruct pmbus_sensor *s2 = b->s2;\r\nu16 reg = (index >> 8) & 0xffff;\r\nu8 mask = index & 0xff;\r\nint ret, status;\r\nu8 regval;\r\nstatus = data->status[reg];\r\nif (status < 0)\r\nreturn status;\r\nregval = status & mask;\r\nif (!s1 && !s2) {\r\nret = !!regval;\r\n} else if (!s1 || !s2) {\r\nWARN(1, "Bad boolean descriptor %p: s1=%p, s2=%p\n", b, s1, s2);\r\nreturn 0;\r\n} else {\r\nlong v1, v2;\r\nif (s1->data < 0)\r\nreturn s1->data;\r\nif (s2->data < 0)\r\nreturn s2->data;\r\nv1 = pmbus_reg2data(data, s1);\r\nv2 = pmbus_reg2data(data, s2);\r\nret = !!(regval && v1 >= v2);\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t pmbus_show_boolean(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct pmbus_boolean *boolean = to_pmbus_boolean(attr);\r\nstruct pmbus_data *data = pmbus_update_device(dev);\r\nint val;\r\nval = pmbus_get_boolean(data, boolean, attr->index);\r\nif (val < 0)\r\nreturn val;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", val);\r\n}\r\nstatic ssize_t pmbus_show_sensor(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct pmbus_data *data = pmbus_update_device(dev);\r\nstruct pmbus_sensor *sensor = to_pmbus_sensor(devattr);\r\nif (sensor->data < 0)\r\nreturn sensor->data;\r\nreturn snprintf(buf, PAGE_SIZE, "%ld\n", pmbus_reg2data(data, sensor));\r\n}\r\nstatic ssize_t pmbus_set_sensor(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev->parent);\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nstruct pmbus_sensor *sensor = to_pmbus_sensor(devattr);\r\nssize_t rv = count;\r\nlong val = 0;\r\nint ret;\r\nu16 regval;\r\nif (kstrtol(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nregval = pmbus_data2reg(data, sensor, val);\r\nret = _pmbus_write_word_data(client, sensor->page, sensor->reg, regval);\r\nif (ret < 0)\r\nrv = ret;\r\nelse\r\nsensor->data = regval;\r\nmutex_unlock(&data->update_lock);\r\nreturn rv;\r\n}\r\nstatic ssize_t pmbus_show_label(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct pmbus_label *label = to_pmbus_label(da);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", label->label);\r\n}\r\nstatic int pmbus_add_attribute(struct pmbus_data *data, struct attribute *attr)\r\n{\r\nif (data->num_attributes >= data->max_attributes - 1) {\r\nint new_max_attrs = data->max_attributes + PMBUS_ATTR_ALLOC_SIZE;\r\nvoid *new_attrs = krealloc(data->group.attrs,\r\nnew_max_attrs * sizeof(void *),\r\nGFP_KERNEL);\r\nif (!new_attrs)\r\nreturn -ENOMEM;\r\ndata->group.attrs = new_attrs;\r\ndata->max_attributes = new_max_attrs;\r\n}\r\ndata->group.attrs[data->num_attributes++] = attr;\r\ndata->group.attrs[data->num_attributes] = NULL;\r\nreturn 0;\r\n}\r\nstatic void pmbus_dev_attr_init(struct device_attribute *dev_attr,\r\nconst char *name,\r\numode_t mode,\r\nssize_t (*show)(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf),\r\nssize_t (*store)(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count))\r\n{\r\nsysfs_attr_init(&dev_attr->attr);\r\ndev_attr->attr.name = name;\r\ndev_attr->attr.mode = mode;\r\ndev_attr->show = show;\r\ndev_attr->store = store;\r\n}\r\nstatic void pmbus_attr_init(struct sensor_device_attribute *a,\r\nconst char *name,\r\numode_t mode,\r\nssize_t (*show)(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf),\r\nssize_t (*store)(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count),\r\nint idx)\r\n{\r\npmbus_dev_attr_init(&a->dev_attr, name, mode, show, store);\r\na->index = idx;\r\n}\r\nstatic int pmbus_add_boolean(struct pmbus_data *data,\r\nconst char *name, const char *type, int seq,\r\nstruct pmbus_sensor *s1,\r\nstruct pmbus_sensor *s2,\r\nu16 reg, u8 mask)\r\n{\r\nstruct pmbus_boolean *boolean;\r\nstruct sensor_device_attribute *a;\r\nboolean = devm_kzalloc(data->dev, sizeof(*boolean), GFP_KERNEL);\r\nif (!boolean)\r\nreturn -ENOMEM;\r\na = &boolean->attribute;\r\nsnprintf(boolean->name, sizeof(boolean->name), "%s%d_%s",\r\nname, seq, type);\r\nboolean->s1 = s1;\r\nboolean->s2 = s2;\r\npmbus_attr_init(a, boolean->name, S_IRUGO, pmbus_show_boolean, NULL,\r\n(reg << 8) | mask);\r\nreturn pmbus_add_attribute(data, &a->dev_attr.attr);\r\n}\r\nstatic struct pmbus_sensor *pmbus_add_sensor(struct pmbus_data *data,\r\nconst char *name, const char *type,\r\nint seq, int page, int reg,\r\nenum pmbus_sensor_classes class,\r\nbool update, bool readonly)\r\n{\r\nstruct pmbus_sensor *sensor;\r\nstruct device_attribute *a;\r\nsensor = devm_kzalloc(data->dev, sizeof(*sensor), GFP_KERNEL);\r\nif (!sensor)\r\nreturn NULL;\r\na = &sensor->attribute;\r\nsnprintf(sensor->name, sizeof(sensor->name), "%s%d_%s",\r\nname, seq, type);\r\nsensor->page = page;\r\nsensor->reg = reg;\r\nsensor->class = class;\r\nsensor->update = update;\r\npmbus_dev_attr_init(a, sensor->name,\r\nreadonly ? S_IRUGO : S_IRUGO | S_IWUSR,\r\npmbus_show_sensor, pmbus_set_sensor);\r\nif (pmbus_add_attribute(data, &a->attr))\r\nreturn NULL;\r\nsensor->next = data->sensors;\r\ndata->sensors = sensor;\r\nreturn sensor;\r\n}\r\nstatic int pmbus_add_label(struct pmbus_data *data,\r\nconst char *name, int seq,\r\nconst char *lstring, int index)\r\n{\r\nstruct pmbus_label *label;\r\nstruct device_attribute *a;\r\nlabel = devm_kzalloc(data->dev, sizeof(*label), GFP_KERNEL);\r\nif (!label)\r\nreturn -ENOMEM;\r\na = &label->attribute;\r\nsnprintf(label->name, sizeof(label->name), "%s%d_label", name, seq);\r\nif (!index)\r\nstrncpy(label->label, lstring, sizeof(label->label) - 1);\r\nelse\r\nsnprintf(label->label, sizeof(label->label), "%s%d", lstring,\r\nindex);\r\npmbus_dev_attr_init(a, label->name, S_IRUGO, pmbus_show_label, NULL);\r\nreturn pmbus_add_attribute(data, &a->attr);\r\n}\r\nstatic int pmbus_add_limit_attrs(struct i2c_client *client,\r\nstruct pmbus_data *data,\r\nconst struct pmbus_driver_info *info,\r\nconst char *name, int index, int page,\r\nstruct pmbus_sensor *base,\r\nconst struct pmbus_sensor_attr *attr)\r\n{\r\nconst struct pmbus_limit_attr *l = attr->limit;\r\nint nlimit = attr->nlimit;\r\nint have_alarm = 0;\r\nint i, ret;\r\nstruct pmbus_sensor *curr;\r\nfor (i = 0; i < nlimit; i++) {\r\nif (pmbus_check_word_register(client, page, l->reg)) {\r\ncurr = pmbus_add_sensor(data, name, l->attr, index,\r\npage, l->reg, attr->class,\r\nattr->update || l->update,\r\nfalse);\r\nif (!curr)\r\nreturn -ENOMEM;\r\nif (l->sbit && (info->func[page] & attr->sfunc)) {\r\nret = pmbus_add_boolean(data, name,\r\nl->alarm, index,\r\nattr->compare ? l->low ? curr : base\r\n: NULL,\r\nattr->compare ? l->low ? base : curr\r\n: NULL,\r\nattr->sbase + page, l->sbit);\r\nif (ret)\r\nreturn ret;\r\nhave_alarm = 1;\r\n}\r\n}\r\nl++;\r\n}\r\nreturn have_alarm;\r\n}\r\nstatic int pmbus_add_sensor_attrs_one(struct i2c_client *client,\r\nstruct pmbus_data *data,\r\nconst struct pmbus_driver_info *info,\r\nconst char *name,\r\nint index, int page,\r\nconst struct pmbus_sensor_attr *attr)\r\n{\r\nstruct pmbus_sensor *base;\r\nint ret;\r\nif (attr->label) {\r\nret = pmbus_add_label(data, name, index, attr->label,\r\nattr->paged ? page + 1 : 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\nbase = pmbus_add_sensor(data, name, "input", index, page, attr->reg,\r\nattr->class, true, true);\r\nif (!base)\r\nreturn -ENOMEM;\r\nif (attr->sfunc) {\r\nret = pmbus_add_limit_attrs(client, data, info, name,\r\nindex, page, base, attr);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!ret && attr->gbit &&\r\npmbus_check_byte_register(client, page,\r\ndata->status_register)) {\r\nret = pmbus_add_boolean(data, name, "alarm", index,\r\nNULL, NULL,\r\nPB_STATUS_BASE + page,\r\nattr->gbit);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pmbus_add_sensor_attrs(struct i2c_client *client,\r\nstruct pmbus_data *data,\r\nconst char *name,\r\nconst struct pmbus_sensor_attr *attrs,\r\nint nattrs)\r\n{\r\nconst struct pmbus_driver_info *info = data->info;\r\nint index, i;\r\nint ret;\r\nindex = 1;\r\nfor (i = 0; i < nattrs; i++) {\r\nint page, pages;\r\npages = attrs->paged ? info->pages : 1;\r\nfor (page = 0; page < pages; page++) {\r\nif (!(info->func[page] & attrs->func))\r\ncontinue;\r\nret = pmbus_add_sensor_attrs_one(client, data, info,\r\nname, index, page,\r\nattrs);\r\nif (ret)\r\nreturn ret;\r\nindex++;\r\n}\r\nattrs++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pmbus_add_fan_attributes(struct i2c_client *client,\r\nstruct pmbus_data *data)\r\n{\r\nconst struct pmbus_driver_info *info = data->info;\r\nint index = 1;\r\nint page;\r\nint ret;\r\nfor (page = 0; page < info->pages; page++) {\r\nint f;\r\nfor (f = 0; f < ARRAY_SIZE(pmbus_fan_registers); f++) {\r\nint regval;\r\nif (!(info->func[page] & pmbus_fan_flags[f]))\r\nbreak;\r\nif (!pmbus_check_word_register(client, page,\r\npmbus_fan_registers[f]))\r\nbreak;\r\nregval = _pmbus_read_byte_data(client, page,\r\npmbus_fan_config_registers[f]);\r\nif (regval < 0 ||\r\n(!(regval & (PB_FAN_1_INSTALLED >> ((f & 1) * 4)))))\r\ncontinue;\r\nif (pmbus_add_sensor(data, "fan", "input", index,\r\npage, pmbus_fan_registers[f],\r\nPSC_FAN, true, true) == NULL)\r\nreturn -ENOMEM;\r\nif ((info->func[page] & pmbus_fan_status_flags[f]) &&\r\npmbus_check_byte_register(client,\r\npage, pmbus_fan_status_registers[f])) {\r\nint base;\r\nif (f > 1)\r\nbase = PB_STATUS_FAN34_BASE + page;\r\nelse\r\nbase = PB_STATUS_FAN_BASE + page;\r\nret = pmbus_add_boolean(data, "fan",\r\n"alarm", index, NULL, NULL, base,\r\nPB_FAN_FAN1_WARNING >> (f & 1));\r\nif (ret)\r\nreturn ret;\r\nret = pmbus_add_boolean(data, "fan",\r\n"fault", index, NULL, NULL, base,\r\nPB_FAN_FAN1_FAULT >> (f & 1));\r\nif (ret)\r\nreturn ret;\r\n}\r\nindex++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pmbus_find_attributes(struct i2c_client *client,\r\nstruct pmbus_data *data)\r\n{\r\nint ret;\r\nret = pmbus_add_sensor_attrs(client, data, "in", voltage_attributes,\r\nARRAY_SIZE(voltage_attributes));\r\nif (ret)\r\nreturn ret;\r\nret = pmbus_add_sensor_attrs(client, data, "curr", current_attributes,\r\nARRAY_SIZE(current_attributes));\r\nif (ret)\r\nreturn ret;\r\nret = pmbus_add_sensor_attrs(client, data, "power", power_attributes,\r\nARRAY_SIZE(power_attributes));\r\nif (ret)\r\nreturn ret;\r\nret = pmbus_add_sensor_attrs(client, data, "temp", temp_attributes,\r\nARRAY_SIZE(temp_attributes));\r\nif (ret)\r\nreturn ret;\r\nret = pmbus_add_fan_attributes(client, data);\r\nreturn ret;\r\n}\r\nstatic int pmbus_identify_common(struct i2c_client *client,\r\nstruct pmbus_data *data, int page)\r\n{\r\nint vout_mode = -1;\r\nif (pmbus_check_byte_register(client, page, PMBUS_VOUT_MODE))\r\nvout_mode = _pmbus_read_byte_data(client, page,\r\nPMBUS_VOUT_MODE);\r\nif (vout_mode >= 0 && vout_mode != 0xff) {\r\nswitch (vout_mode >> 5) {\r\ncase 0:\r\nif (data->info->format[PSC_VOLTAGE_OUT] != linear)\r\nreturn -ENODEV;\r\ndata->exponent[page] = ((s8)(vout_mode << 3)) >> 3;\r\nbreak;\r\ncase 1:\r\nif (data->info->format[PSC_VOLTAGE_OUT] != vid)\r\nreturn -ENODEV;\r\nbreak;\r\ncase 2:\r\nif (data->info->format[PSC_VOLTAGE_OUT] != direct)\r\nreturn -ENODEV;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\npmbus_clear_fault_page(client, page);\r\nreturn 0;\r\n}\r\nstatic int pmbus_init_common(struct i2c_client *client, struct pmbus_data *data,\r\nstruct pmbus_driver_info *info)\r\n{\r\nstruct device *dev = &client->dev;\r\nint page, ret;\r\ndata->status_register = PMBUS_STATUS_BYTE;\r\nret = i2c_smbus_read_byte_data(client, PMBUS_STATUS_BYTE);\r\nif (ret < 0 || ret == 0xff) {\r\ndata->status_register = PMBUS_STATUS_WORD;\r\nret = i2c_smbus_read_word_data(client, PMBUS_STATUS_WORD);\r\nif (ret < 0 || ret == 0xffff) {\r\ndev_err(dev, "PMBus status register not found\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nret = i2c_smbus_read_byte_data(client, PMBUS_CAPABILITY);\r\nif (ret >= 0 && (ret & PB_CAPABILITY_ERROR_CHECK))\r\nclient->flags |= I2C_CLIENT_PEC;\r\npmbus_clear_faults(client);\r\nif (info->identify) {\r\nret = (*info->identify)(client, info);\r\nif (ret < 0) {\r\ndev_err(dev, "Chip identification failed\n");\r\nreturn ret;\r\n}\r\n}\r\nif (info->pages <= 0 || info->pages > PMBUS_PAGES) {\r\ndev_err(dev, "Bad number of PMBus pages: %d\n", info->pages);\r\nreturn -ENODEV;\r\n}\r\nfor (page = 0; page < info->pages; page++) {\r\nret = pmbus_identify_common(client, data, page);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to identify chip capabilities\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pmbus_regulator_is_enabled(struct regulator_dev *rdev)\r\n{\r\nstruct device *dev = rdev_get_dev(rdev);\r\nstruct i2c_client *client = to_i2c_client(dev->parent);\r\nu8 page = rdev_get_id(rdev);\r\nint ret;\r\nret = pmbus_read_byte_data(client, page, PMBUS_OPERATION);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn !!(ret & PB_OPERATION_CONTROL_ON);\r\n}\r\nstatic int _pmbus_regulator_on_off(struct regulator_dev *rdev, bool enable)\r\n{\r\nstruct device *dev = rdev_get_dev(rdev);\r\nstruct i2c_client *client = to_i2c_client(dev->parent);\r\nu8 page = rdev_get_id(rdev);\r\nreturn pmbus_update_byte_data(client, page, PMBUS_OPERATION,\r\nPB_OPERATION_CONTROL_ON,\r\nenable ? PB_OPERATION_CONTROL_ON : 0);\r\n}\r\nstatic int pmbus_regulator_enable(struct regulator_dev *rdev)\r\n{\r\nreturn _pmbus_regulator_on_off(rdev, 1);\r\n}\r\nstatic int pmbus_regulator_disable(struct regulator_dev *rdev)\r\n{\r\nreturn _pmbus_regulator_on_off(rdev, 0);\r\n}\r\nstatic int pmbus_regulator_register(struct pmbus_data *data)\r\n{\r\nstruct device *dev = data->dev;\r\nconst struct pmbus_driver_info *info = data->info;\r\nconst struct pmbus_platform_data *pdata = dev_get_platdata(dev);\r\nstruct regulator_dev *rdev;\r\nint i;\r\nfor (i = 0; i < info->num_regulators; i++) {\r\nstruct regulator_config config = { };\r\nconfig.dev = dev;\r\nconfig.driver_data = data;\r\nif (pdata && pdata->reg_init_data)\r\nconfig.init_data = &pdata->reg_init_data[i];\r\nrdev = devm_regulator_register(dev, &info->reg_desc[i],\r\n&config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(dev, "Failed to register %s regulator\n",\r\ninfo->reg_desc[i].name);\r\nreturn PTR_ERR(rdev);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pmbus_regulator_register(struct pmbus_data *data)\r\n{\r\nreturn 0;\r\n}\r\nint pmbus_do_probe(struct i2c_client *client, const struct i2c_device_id *id,\r\nstruct pmbus_driver_info *info)\r\n{\r\nstruct device *dev = &client->dev;\r\nconst struct pmbus_platform_data *pdata = dev_get_platdata(dev);\r\nstruct pmbus_data *data;\r\nint ret;\r\nif (!info)\r\nreturn -ENODEV;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WRITE_BYTE\r\n| I2C_FUNC_SMBUS_BYTE_DATA\r\n| I2C_FUNC_SMBUS_WORD_DATA))\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\ndata->dev = dev;\r\nif (pdata)\r\ndata->flags = pdata->flags;\r\ndata->info = info;\r\nret = pmbus_init_common(client, data, info);\r\nif (ret < 0)\r\nreturn ret;\r\nret = pmbus_find_attributes(client, data);\r\nif (ret)\r\ngoto out_kfree;\r\nif (!data->num_attributes) {\r\ndev_err(dev, "No attributes found\n");\r\nret = -ENODEV;\r\ngoto out_kfree;\r\n}\r\ndata->groups[0] = &data->group;\r\ndata->hwmon_dev = hwmon_device_register_with_groups(dev, client->name,\r\ndata, data->groups);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nret = PTR_ERR(data->hwmon_dev);\r\ndev_err(dev, "Failed to register hwmon device\n");\r\ngoto out_kfree;\r\n}\r\nret = pmbus_regulator_register(data);\r\nif (ret)\r\ngoto out_unregister;\r\nreturn 0;\r\nout_unregister:\r\nhwmon_device_unregister(data->hwmon_dev);\r\nout_kfree:\r\nkfree(data->group.attrs);\r\nreturn ret;\r\n}\r\nint pmbus_do_remove(struct i2c_client *client)\r\n{\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nkfree(data->group.attrs);\r\nreturn 0;\r\n}
