static int g2d_init_cmdlist(struct g2d_data *g2d)\r\n{\r\nstruct device *dev = g2d->dev;\r\nstruct g2d_cmdlist_node *node = g2d->cmdlist_node;\r\nstruct exynos_drm_subdrv *subdrv = &g2d->subdrv;\r\nint nr;\r\nint ret;\r\nstruct g2d_buf_info *buf_info;\r\ninit_dma_attrs(&g2d->cmdlist_dma_attrs);\r\ndma_set_attr(DMA_ATTR_WRITE_COMBINE, &g2d->cmdlist_dma_attrs);\r\ng2d->cmdlist_pool_virt = dma_alloc_attrs(subdrv->drm_dev->dev,\r\nG2D_CMDLIST_POOL_SIZE,\r\n&g2d->cmdlist_pool, GFP_KERNEL,\r\n&g2d->cmdlist_dma_attrs);\r\nif (!g2d->cmdlist_pool_virt) {\r\ndev_err(dev, "failed to allocate dma memory\n");\r\nreturn -ENOMEM;\r\n}\r\nnode = kcalloc(G2D_CMDLIST_NUM, sizeof(*node), GFP_KERNEL);\r\nif (!node) {\r\ndev_err(dev, "failed to allocate memory\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nfor (nr = 0; nr < G2D_CMDLIST_NUM; nr++) {\r\nunsigned int i;\r\nnode[nr].cmdlist =\r\ng2d->cmdlist_pool_virt + nr * G2D_CMDLIST_SIZE;\r\nnode[nr].dma_addr =\r\ng2d->cmdlist_pool + nr * G2D_CMDLIST_SIZE;\r\nbuf_info = &node[nr].buf_info;\r\nfor (i = 0; i < MAX_REG_TYPE_NR; i++)\r\nbuf_info->reg_types[i] = REG_TYPE_NONE;\r\nlist_add_tail(&node[nr].list, &g2d->free_cmdlist);\r\n}\r\nreturn 0;\r\nerr:\r\ndma_free_attrs(subdrv->drm_dev->dev, G2D_CMDLIST_POOL_SIZE,\r\ng2d->cmdlist_pool_virt,\r\ng2d->cmdlist_pool, &g2d->cmdlist_dma_attrs);\r\nreturn ret;\r\n}\r\nstatic void g2d_fini_cmdlist(struct g2d_data *g2d)\r\n{\r\nstruct exynos_drm_subdrv *subdrv = &g2d->subdrv;\r\nkfree(g2d->cmdlist_node);\r\nif (g2d->cmdlist_pool_virt && g2d->cmdlist_pool) {\r\ndma_free_attrs(subdrv->drm_dev->dev, G2D_CMDLIST_POOL_SIZE,\r\ng2d->cmdlist_pool_virt,\r\ng2d->cmdlist_pool, &g2d->cmdlist_dma_attrs);\r\n}\r\n}\r\nstatic struct g2d_cmdlist_node *g2d_get_cmdlist(struct g2d_data *g2d)\r\n{\r\nstruct device *dev = g2d->dev;\r\nstruct g2d_cmdlist_node *node;\r\nmutex_lock(&g2d->cmdlist_mutex);\r\nif (list_empty(&g2d->free_cmdlist)) {\r\ndev_err(dev, "there is no free cmdlist\n");\r\nmutex_unlock(&g2d->cmdlist_mutex);\r\nreturn NULL;\r\n}\r\nnode = list_first_entry(&g2d->free_cmdlist, struct g2d_cmdlist_node,\r\nlist);\r\nlist_del_init(&node->list);\r\nmutex_unlock(&g2d->cmdlist_mutex);\r\nreturn node;\r\n}\r\nstatic void g2d_put_cmdlist(struct g2d_data *g2d, struct g2d_cmdlist_node *node)\r\n{\r\nmutex_lock(&g2d->cmdlist_mutex);\r\nlist_move_tail(&node->list, &g2d->free_cmdlist);\r\nmutex_unlock(&g2d->cmdlist_mutex);\r\n}\r\nstatic void g2d_add_cmdlist_to_inuse(struct exynos_drm_g2d_private *g2d_priv,\r\nstruct g2d_cmdlist_node *node)\r\n{\r\nstruct g2d_cmdlist_node *lnode;\r\nif (list_empty(&g2d_priv->inuse_cmdlist))\r\ngoto add_to_list;\r\nlnode = list_entry(g2d_priv->inuse_cmdlist.prev,\r\nstruct g2d_cmdlist_node, list);\r\nlnode->cmdlist->data[lnode->cmdlist->last] = node->dma_addr;\r\nadd_to_list:\r\nlist_add_tail(&node->list, &g2d_priv->inuse_cmdlist);\r\nif (node->event)\r\nlist_add_tail(&node->event->base.link, &g2d_priv->event_list);\r\n}\r\nstatic void g2d_userptr_put_dma_addr(struct drm_device *drm_dev,\r\nunsigned long obj,\r\nbool force)\r\n{\r\nstruct g2d_cmdlist_userptr *g2d_userptr =\r\n(struct g2d_cmdlist_userptr *)obj;\r\nstruct page **pages;\r\nif (!obj)\r\nreturn;\r\nif (force)\r\ngoto out;\r\natomic_dec(&g2d_userptr->refcount);\r\nif (atomic_read(&g2d_userptr->refcount) > 0)\r\nreturn;\r\nif (g2d_userptr->in_pool)\r\nreturn;\r\nout:\r\nexynos_gem_unmap_sgt_from_dma(drm_dev, g2d_userptr->sgt,\r\nDMA_BIDIRECTIONAL);\r\npages = frame_vector_pages(g2d_userptr->vec);\r\nif (!IS_ERR(pages)) {\r\nint i;\r\nfor (i = 0; i < frame_vector_count(g2d_userptr->vec); i++)\r\nset_page_dirty_lock(pages[i]);\r\n}\r\nput_vaddr_frames(g2d_userptr->vec);\r\nframe_vector_destroy(g2d_userptr->vec);\r\nif (!g2d_userptr->out_of_list)\r\nlist_del_init(&g2d_userptr->list);\r\nsg_free_table(g2d_userptr->sgt);\r\nkfree(g2d_userptr->sgt);\r\nkfree(g2d_userptr);\r\n}\r\nstatic dma_addr_t *g2d_userptr_get_dma_addr(struct drm_device *drm_dev,\r\nunsigned long userptr,\r\nunsigned long size,\r\nstruct drm_file *filp,\r\nunsigned long *obj)\r\n{\r\nstruct drm_exynos_file_private *file_priv = filp->driver_priv;\r\nstruct exynos_drm_g2d_private *g2d_priv = file_priv->g2d_priv;\r\nstruct g2d_cmdlist_userptr *g2d_userptr;\r\nstruct g2d_data *g2d;\r\nstruct sg_table *sgt;\r\nunsigned long start, end;\r\nunsigned int npages, offset;\r\nint ret;\r\nif (!size) {\r\nDRM_ERROR("invalid userptr size.\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ng2d = dev_get_drvdata(g2d_priv->dev);\r\nlist_for_each_entry(g2d_userptr, &g2d_priv->userptr_list, list) {\r\nif (g2d_userptr->userptr == userptr) {\r\nif (g2d_userptr->size == size) {\r\natomic_inc(&g2d_userptr->refcount);\r\n*obj = (unsigned long)g2d_userptr;\r\nreturn &g2d_userptr->dma_addr;\r\n}\r\ng2d_userptr->out_of_list = true;\r\ng2d_userptr->in_pool = false;\r\nlist_del_init(&g2d_userptr->list);\r\nbreak;\r\n}\r\n}\r\ng2d_userptr = kzalloc(sizeof(*g2d_userptr), GFP_KERNEL);\r\nif (!g2d_userptr)\r\nreturn ERR_PTR(-ENOMEM);\r\natomic_set(&g2d_userptr->refcount, 1);\r\ng2d_userptr->size = size;\r\nstart = userptr & PAGE_MASK;\r\noffset = userptr & ~PAGE_MASK;\r\nend = PAGE_ALIGN(userptr + size);\r\nnpages = (end - start) >> PAGE_SHIFT;\r\ng2d_userptr->vec = frame_vector_create(npages);\r\nif (!g2d_userptr->vec) {\r\nret = -ENOMEM;\r\ngoto err_free;\r\n}\r\nret = get_vaddr_frames(start, npages, true, true, g2d_userptr->vec);\r\nif (ret != npages) {\r\nDRM_ERROR("failed to get user pages from userptr.\n");\r\nif (ret < 0)\r\ngoto err_destroy_framevec;\r\nret = -EFAULT;\r\ngoto err_put_framevec;\r\n}\r\nif (frame_vector_to_pages(g2d_userptr->vec) < 0) {\r\nret = -EFAULT;\r\ngoto err_put_framevec;\r\n}\r\nsgt = kzalloc(sizeof(*sgt), GFP_KERNEL);\r\nif (!sgt) {\r\nret = -ENOMEM;\r\ngoto err_put_framevec;\r\n}\r\nret = sg_alloc_table_from_pages(sgt,\r\nframe_vector_pages(g2d_userptr->vec),\r\nnpages, offset, size, GFP_KERNEL);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to get sgt from pages.\n");\r\ngoto err_free_sgt;\r\n}\r\ng2d_userptr->sgt = sgt;\r\nret = exynos_gem_map_sgt_with_dma(drm_dev, g2d_userptr->sgt,\r\nDMA_BIDIRECTIONAL);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to map sgt with dma region.\n");\r\ngoto err_sg_free_table;\r\n}\r\ng2d_userptr->dma_addr = sgt->sgl[0].dma_address;\r\ng2d_userptr->userptr = userptr;\r\nlist_add_tail(&g2d_userptr->list, &g2d_priv->userptr_list);\r\nif (g2d->current_pool + (npages << PAGE_SHIFT) < g2d->max_pool) {\r\ng2d->current_pool += npages << PAGE_SHIFT;\r\ng2d_userptr->in_pool = true;\r\n}\r\n*obj = (unsigned long)g2d_userptr;\r\nreturn &g2d_userptr->dma_addr;\r\nerr_sg_free_table:\r\nsg_free_table(sgt);\r\nerr_free_sgt:\r\nkfree(sgt);\r\nerr_put_framevec:\r\nput_vaddr_frames(g2d_userptr->vec);\r\nerr_destroy_framevec:\r\nframe_vector_destroy(g2d_userptr->vec);\r\nerr_free:\r\nkfree(g2d_userptr);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void g2d_userptr_free_all(struct drm_device *drm_dev,\r\nstruct g2d_data *g2d,\r\nstruct drm_file *filp)\r\n{\r\nstruct drm_exynos_file_private *file_priv = filp->driver_priv;\r\nstruct exynos_drm_g2d_private *g2d_priv = file_priv->g2d_priv;\r\nstruct g2d_cmdlist_userptr *g2d_userptr, *n;\r\nlist_for_each_entry_safe(g2d_userptr, n, &g2d_priv->userptr_list, list)\r\nif (g2d_userptr->in_pool)\r\ng2d_userptr_put_dma_addr(drm_dev,\r\n(unsigned long)g2d_userptr,\r\ntrue);\r\ng2d->current_pool = 0;\r\n}\r\nstatic enum g2d_reg_type g2d_get_reg_type(int reg_offset)\r\n{\r\nenum g2d_reg_type reg_type;\r\nswitch (reg_offset) {\r\ncase G2D_SRC_BASE_ADDR:\r\ncase G2D_SRC_STRIDE_REG:\r\ncase G2D_SRC_COLOR_MODE:\r\ncase G2D_SRC_LEFT_TOP:\r\ncase G2D_SRC_RIGHT_BOTTOM:\r\nreg_type = REG_TYPE_SRC;\r\nbreak;\r\ncase G2D_SRC_PLANE2_BASE_ADDR:\r\nreg_type = REG_TYPE_SRC_PLANE2;\r\nbreak;\r\ncase G2D_DST_BASE_ADDR:\r\ncase G2D_DST_STRIDE_REG:\r\ncase G2D_DST_COLOR_MODE:\r\ncase G2D_DST_LEFT_TOP:\r\ncase G2D_DST_RIGHT_BOTTOM:\r\nreg_type = REG_TYPE_DST;\r\nbreak;\r\ncase G2D_DST_PLANE2_BASE_ADDR:\r\nreg_type = REG_TYPE_DST_PLANE2;\r\nbreak;\r\ncase G2D_PAT_BASE_ADDR:\r\nreg_type = REG_TYPE_PAT;\r\nbreak;\r\ncase G2D_MSK_BASE_ADDR:\r\nreg_type = REG_TYPE_MSK;\r\nbreak;\r\ndefault:\r\nreg_type = REG_TYPE_NONE;\r\nDRM_ERROR("Unknown register offset![%d]\n", reg_offset);\r\nbreak;\r\n}\r\nreturn reg_type;\r\n}\r\nstatic unsigned long g2d_get_buf_bpp(unsigned int format)\r\n{\r\nunsigned long bpp;\r\nswitch (format) {\r\ncase G2D_FMT_XRGB8888:\r\ncase G2D_FMT_ARGB8888:\r\nbpp = 4;\r\nbreak;\r\ncase G2D_FMT_RGB565:\r\ncase G2D_FMT_XRGB1555:\r\ncase G2D_FMT_ARGB1555:\r\ncase G2D_FMT_XRGB4444:\r\ncase G2D_FMT_ARGB4444:\r\nbpp = 2;\r\nbreak;\r\ncase G2D_FMT_PACKED_RGB888:\r\nbpp = 3;\r\nbreak;\r\ndefault:\r\nbpp = 1;\r\nbreak;\r\n}\r\nreturn bpp;\r\n}\r\nstatic bool g2d_check_buf_desc_is_valid(struct g2d_buf_desc *buf_desc,\r\nenum g2d_reg_type reg_type,\r\nunsigned long size)\r\n{\r\nint width, height;\r\nunsigned long bpp, last_pos;\r\nif (reg_type != REG_TYPE_SRC && reg_type != REG_TYPE_DST)\r\nreturn true;\r\nwidth = (int)buf_desc->right_x - (int)buf_desc->left_x;\r\nif (width < G2D_LEN_MIN || width > G2D_LEN_MAX) {\r\nDRM_ERROR("width[%d] is out of range!\n", width);\r\nreturn false;\r\n}\r\nheight = (int)buf_desc->bottom_y - (int)buf_desc->top_y;\r\nif (height < G2D_LEN_MIN || height > G2D_LEN_MAX) {\r\nDRM_ERROR("height[%d] is out of range!\n", height);\r\nreturn false;\r\n}\r\nbpp = g2d_get_buf_bpp(buf_desc->format);\r\nlast_pos = ((unsigned long)buf_desc->bottom_y - 1) *\r\n(unsigned long)buf_desc->stride +\r\n(unsigned long)buf_desc->right_x * bpp - 1;\r\nif (last_pos >= size) {\r\nDRM_ERROR("last engine access position [%lu] "\r\n"is out of range [%lu]!\n", last_pos, size);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int g2d_map_cmdlist_gem(struct g2d_data *g2d,\r\nstruct g2d_cmdlist_node *node,\r\nstruct drm_device *drm_dev,\r\nstruct drm_file *file)\r\n{\r\nstruct g2d_cmdlist *cmdlist = node->cmdlist;\r\nstruct g2d_buf_info *buf_info = &node->buf_info;\r\nint offset;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < buf_info->map_nr; i++) {\r\nstruct g2d_buf_desc *buf_desc;\r\nenum g2d_reg_type reg_type;\r\nint reg_pos;\r\nunsigned long handle;\r\ndma_addr_t *addr;\r\nreg_pos = cmdlist->last - 2 * (i + 1);\r\noffset = cmdlist->data[reg_pos];\r\nhandle = cmdlist->data[reg_pos + 1];\r\nreg_type = g2d_get_reg_type(offset);\r\nif (reg_type == REG_TYPE_NONE) {\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nbuf_desc = &buf_info->descs[reg_type];\r\nif (buf_info->types[reg_type] == BUF_TYPE_GEM) {\r\nunsigned long size;\r\nsize = exynos_drm_gem_get_size(drm_dev, handle, file);\r\nif (!size) {\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nif (!g2d_check_buf_desc_is_valid(buf_desc, reg_type,\r\nsize)) {\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\naddr = exynos_drm_gem_get_dma_addr(drm_dev, handle,\r\nfile);\r\nif (IS_ERR(addr)) {\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\n} else {\r\nstruct drm_exynos_g2d_userptr g2d_userptr;\r\nif (copy_from_user(&g2d_userptr, (void __user *)handle,\r\nsizeof(struct drm_exynos_g2d_userptr))) {\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nif (!g2d_check_buf_desc_is_valid(buf_desc, reg_type,\r\ng2d_userptr.size)) {\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\naddr = g2d_userptr_get_dma_addr(drm_dev,\r\ng2d_userptr.userptr,\r\ng2d_userptr.size,\r\nfile,\r\n&handle);\r\nif (IS_ERR(addr)) {\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\n}\r\ncmdlist->data[reg_pos + 1] = *addr;\r\nbuf_info->reg_types[i] = reg_type;\r\nbuf_info->handles[reg_type] = handle;\r\n}\r\nreturn 0;\r\nerr:\r\nbuf_info->map_nr = i;\r\nreturn ret;\r\n}\r\nstatic void g2d_unmap_cmdlist_gem(struct g2d_data *g2d,\r\nstruct g2d_cmdlist_node *node,\r\nstruct drm_file *filp)\r\n{\r\nstruct exynos_drm_subdrv *subdrv = &g2d->subdrv;\r\nstruct g2d_buf_info *buf_info = &node->buf_info;\r\nint i;\r\nfor (i = 0; i < buf_info->map_nr; i++) {\r\nstruct g2d_buf_desc *buf_desc;\r\nenum g2d_reg_type reg_type;\r\nunsigned long handle;\r\nreg_type = buf_info->reg_types[i];\r\nbuf_desc = &buf_info->descs[reg_type];\r\nhandle = buf_info->handles[reg_type];\r\nif (buf_info->types[reg_type] == BUF_TYPE_GEM)\r\nexynos_drm_gem_put_dma_addr(subdrv->drm_dev, handle,\r\nfilp);\r\nelse\r\ng2d_userptr_put_dma_addr(subdrv->drm_dev, handle,\r\nfalse);\r\nbuf_info->reg_types[i] = REG_TYPE_NONE;\r\nbuf_info->handles[reg_type] = 0;\r\nbuf_info->types[reg_type] = 0;\r\nmemset(buf_desc, 0x00, sizeof(*buf_desc));\r\n}\r\nbuf_info->map_nr = 0;\r\n}\r\nstatic void g2d_dma_start(struct g2d_data *g2d,\r\nstruct g2d_runqueue_node *runqueue_node)\r\n{\r\nstruct g2d_cmdlist_node *node =\r\nlist_first_entry(&runqueue_node->run_cmdlist,\r\nstruct g2d_cmdlist_node, list);\r\nint ret;\r\nret = pm_runtime_get_sync(g2d->dev);\r\nif (ret < 0)\r\nreturn;\r\nwritel_relaxed(node->dma_addr, g2d->regs + G2D_DMA_SFR_BASE_ADDR);\r\nwritel_relaxed(G2D_DMA_START, g2d->regs + G2D_DMA_COMMAND);\r\n}\r\nstatic struct g2d_runqueue_node *g2d_get_runqueue_node(struct g2d_data *g2d)\r\n{\r\nstruct g2d_runqueue_node *runqueue_node;\r\nif (list_empty(&g2d->runqueue))\r\nreturn NULL;\r\nrunqueue_node = list_first_entry(&g2d->runqueue,\r\nstruct g2d_runqueue_node, list);\r\nlist_del_init(&runqueue_node->list);\r\nreturn runqueue_node;\r\n}\r\nstatic void g2d_free_runqueue_node(struct g2d_data *g2d,\r\nstruct g2d_runqueue_node *runqueue_node)\r\n{\r\nstruct g2d_cmdlist_node *node;\r\nif (!runqueue_node)\r\nreturn;\r\nmutex_lock(&g2d->cmdlist_mutex);\r\nlist_for_each_entry(node, &runqueue_node->run_cmdlist, list)\r\ng2d_unmap_cmdlist_gem(g2d, node, runqueue_node->filp);\r\nlist_splice_tail_init(&runqueue_node->run_cmdlist, &g2d->free_cmdlist);\r\nmutex_unlock(&g2d->cmdlist_mutex);\r\nkmem_cache_free(g2d->runqueue_slab, runqueue_node);\r\n}\r\nstatic void g2d_exec_runqueue(struct g2d_data *g2d)\r\n{\r\ng2d->runqueue_node = g2d_get_runqueue_node(g2d);\r\nif (g2d->runqueue_node)\r\ng2d_dma_start(g2d, g2d->runqueue_node);\r\n}\r\nstatic void g2d_runqueue_worker(struct work_struct *work)\r\n{\r\nstruct g2d_data *g2d = container_of(work, struct g2d_data,\r\nrunqueue_work);\r\nmutex_lock(&g2d->runqueue_mutex);\r\npm_runtime_put_sync(g2d->dev);\r\ncomplete(&g2d->runqueue_node->complete);\r\nif (g2d->runqueue_node->async)\r\ng2d_free_runqueue_node(g2d, g2d->runqueue_node);\r\nif (g2d->suspended)\r\ng2d->runqueue_node = NULL;\r\nelse\r\ng2d_exec_runqueue(g2d);\r\nmutex_unlock(&g2d->runqueue_mutex);\r\n}\r\nstatic void g2d_finish_event(struct g2d_data *g2d, u32 cmdlist_no)\r\n{\r\nstruct drm_device *drm_dev = g2d->subdrv.drm_dev;\r\nstruct g2d_runqueue_node *runqueue_node = g2d->runqueue_node;\r\nstruct drm_exynos_pending_g2d_event *e;\r\nstruct timeval now;\r\nunsigned long flags;\r\nif (list_empty(&runqueue_node->event_list))\r\nreturn;\r\ne = list_first_entry(&runqueue_node->event_list,\r\nstruct drm_exynos_pending_g2d_event, base.link);\r\ndo_gettimeofday(&now);\r\ne->event.tv_sec = now.tv_sec;\r\ne->event.tv_usec = now.tv_usec;\r\ne->event.cmdlist_no = cmdlist_no;\r\nspin_lock_irqsave(&drm_dev->event_lock, flags);\r\nlist_move_tail(&e->base.link, &e->base.file_priv->event_list);\r\nwake_up_interruptible(&e->base.file_priv->event_wait);\r\nspin_unlock_irqrestore(&drm_dev->event_lock, flags);\r\n}\r\nstatic irqreturn_t g2d_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct g2d_data *g2d = dev_id;\r\nu32 pending;\r\npending = readl_relaxed(g2d->regs + G2D_INTC_PEND);\r\nif (pending)\r\nwritel_relaxed(pending, g2d->regs + G2D_INTC_PEND);\r\nif (pending & G2D_INTP_GCMD_FIN) {\r\nu32 cmdlist_no = readl_relaxed(g2d->regs + G2D_DMA_STATUS);\r\ncmdlist_no = (cmdlist_no & G2D_DMA_LIST_DONE_COUNT) >>\r\nG2D_DMA_LIST_DONE_COUNT_OFFSET;\r\ng2d_finish_event(g2d, cmdlist_no);\r\nwritel_relaxed(0, g2d->regs + G2D_DMA_HOLD_CMD);\r\nif (!(pending & G2D_INTP_ACMD_FIN)) {\r\nwritel_relaxed(G2D_DMA_CONTINUE,\r\ng2d->regs + G2D_DMA_COMMAND);\r\n}\r\n}\r\nif (pending & G2D_INTP_ACMD_FIN)\r\nqueue_work(g2d->g2d_workq, &g2d->runqueue_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int g2d_check_reg_offset(struct device *dev,\r\nstruct g2d_cmdlist_node *node,\r\nint nr, bool for_addr)\r\n{\r\nstruct g2d_cmdlist *cmdlist = node->cmdlist;\r\nint reg_offset;\r\nint index;\r\nint i;\r\nfor (i = 0; i < nr; i++) {\r\nstruct g2d_buf_info *buf_info = &node->buf_info;\r\nstruct g2d_buf_desc *buf_desc;\r\nenum g2d_reg_type reg_type;\r\nunsigned long value;\r\nindex = cmdlist->last - 2 * (i + 1);\r\nreg_offset = cmdlist->data[index] & ~0xfffff000;\r\nif (reg_offset < G2D_VALID_START || reg_offset > G2D_VALID_END)\r\ngoto err;\r\nif (reg_offset % 4)\r\ngoto err;\r\nswitch (reg_offset) {\r\ncase G2D_SRC_BASE_ADDR:\r\ncase G2D_SRC_PLANE2_BASE_ADDR:\r\ncase G2D_DST_BASE_ADDR:\r\ncase G2D_DST_PLANE2_BASE_ADDR:\r\ncase G2D_PAT_BASE_ADDR:\r\ncase G2D_MSK_BASE_ADDR:\r\nif (!for_addr)\r\ngoto err;\r\nreg_type = g2d_get_reg_type(reg_offset);\r\nif ((cmdlist->data[index] & ~0x7fffffff) >> 31) {\r\nbuf_info->types[reg_type] = BUF_TYPE_USERPTR;\r\ncmdlist->data[index] &= ~G2D_BUF_USERPTR;\r\n} else\r\nbuf_info->types[reg_type] = BUF_TYPE_GEM;\r\nbreak;\r\ncase G2D_SRC_STRIDE_REG:\r\ncase G2D_DST_STRIDE_REG:\r\nif (for_addr)\r\ngoto err;\r\nreg_type = g2d_get_reg_type(reg_offset);\r\nbuf_desc = &buf_info->descs[reg_type];\r\nbuf_desc->stride = cmdlist->data[index + 1];\r\nbreak;\r\ncase G2D_SRC_COLOR_MODE:\r\ncase G2D_DST_COLOR_MODE:\r\nif (for_addr)\r\ngoto err;\r\nreg_type = g2d_get_reg_type(reg_offset);\r\nbuf_desc = &buf_info->descs[reg_type];\r\nvalue = cmdlist->data[index + 1];\r\nbuf_desc->format = value & 0xf;\r\nbreak;\r\ncase G2D_SRC_LEFT_TOP:\r\ncase G2D_DST_LEFT_TOP:\r\nif (for_addr)\r\ngoto err;\r\nreg_type = g2d_get_reg_type(reg_offset);\r\nbuf_desc = &buf_info->descs[reg_type];\r\nvalue = cmdlist->data[index + 1];\r\nbuf_desc->left_x = value & 0x1fff;\r\nbuf_desc->top_y = (value & 0x1fff0000) >> 16;\r\nbreak;\r\ncase G2D_SRC_RIGHT_BOTTOM:\r\ncase G2D_DST_RIGHT_BOTTOM:\r\nif (for_addr)\r\ngoto err;\r\nreg_type = g2d_get_reg_type(reg_offset);\r\nbuf_desc = &buf_info->descs[reg_type];\r\nvalue = cmdlist->data[index + 1];\r\nbuf_desc->right_x = value & 0x1fff;\r\nbuf_desc->bottom_y = (value & 0x1fff0000) >> 16;\r\nbreak;\r\ndefault:\r\nif (for_addr)\r\ngoto err;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\ndev_err(dev, "Bad register offset: 0x%lx\n", cmdlist->data[index]);\r\nreturn -EINVAL;\r\n}\r\nint exynos_g2d_get_ver_ioctl(struct drm_device *drm_dev, void *data,\r\nstruct drm_file *file)\r\n{\r\nstruct drm_exynos_file_private *file_priv = file->driver_priv;\r\nstruct exynos_drm_g2d_private *g2d_priv = file_priv->g2d_priv;\r\nstruct device *dev;\r\nstruct g2d_data *g2d;\r\nstruct drm_exynos_g2d_get_ver *ver = data;\r\nif (!g2d_priv)\r\nreturn -ENODEV;\r\ndev = g2d_priv->dev;\r\nif (!dev)\r\nreturn -ENODEV;\r\ng2d = dev_get_drvdata(dev);\r\nif (!g2d)\r\nreturn -EFAULT;\r\nver->major = G2D_HW_MAJOR_VER;\r\nver->minor = G2D_HW_MINOR_VER;\r\nreturn 0;\r\n}\r\nint exynos_g2d_set_cmdlist_ioctl(struct drm_device *drm_dev, void *data,\r\nstruct drm_file *file)\r\n{\r\nstruct drm_exynos_file_private *file_priv = file->driver_priv;\r\nstruct exynos_drm_g2d_private *g2d_priv = file_priv->g2d_priv;\r\nstruct device *dev;\r\nstruct g2d_data *g2d;\r\nstruct drm_exynos_g2d_set_cmdlist *req = data;\r\nstruct drm_exynos_g2d_cmd *cmd;\r\nstruct drm_exynos_pending_g2d_event *e;\r\nstruct g2d_cmdlist_node *node;\r\nstruct g2d_cmdlist *cmdlist;\r\nunsigned long flags;\r\nint size;\r\nint ret;\r\nif (!g2d_priv)\r\nreturn -ENODEV;\r\ndev = g2d_priv->dev;\r\nif (!dev)\r\nreturn -ENODEV;\r\ng2d = dev_get_drvdata(dev);\r\nif (!g2d)\r\nreturn -EFAULT;\r\nnode = g2d_get_cmdlist(g2d);\r\nif (!node)\r\nreturn -ENOMEM;\r\nnode->event = NULL;\r\nif (req->event_type != G2D_EVENT_NOT) {\r\nspin_lock_irqsave(&drm_dev->event_lock, flags);\r\nif (file->event_space < sizeof(e->event)) {\r\nspin_unlock_irqrestore(&drm_dev->event_lock, flags);\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nfile->event_space -= sizeof(e->event);\r\nspin_unlock_irqrestore(&drm_dev->event_lock, flags);\r\ne = kzalloc(sizeof(*node->event), GFP_KERNEL);\r\nif (!e) {\r\nspin_lock_irqsave(&drm_dev->event_lock, flags);\r\nfile->event_space += sizeof(e->event);\r\nspin_unlock_irqrestore(&drm_dev->event_lock, flags);\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ne->event.base.type = DRM_EXYNOS_G2D_EVENT;\r\ne->event.base.length = sizeof(e->event);\r\ne->event.user_data = req->user_data;\r\ne->base.event = &e->event.base;\r\ne->base.file_priv = file;\r\ne->base.destroy = (void (*) (struct drm_pending_event *)) kfree;\r\nnode->event = e;\r\n}\r\ncmdlist = node->cmdlist;\r\ncmdlist->last = 0;\r\ncmdlist->data[cmdlist->last++] = G2D_SOFT_RESET;\r\ncmdlist->data[cmdlist->last++] = G2D_SFRCLEAR;\r\ncmdlist->data[cmdlist->last++] = G2D_SRC_BASE_ADDR;\r\ncmdlist->data[cmdlist->last++] = 0;\r\nif (node->event) {\r\ncmdlist->data[cmdlist->last++] = G2D_INTEN;\r\ncmdlist->data[cmdlist->last++] = G2D_INTEN_ACF | G2D_INTEN_GCF;\r\ncmdlist->data[cmdlist->last++] = G2D_DMA_HOLD_CMD;\r\ncmdlist->data[cmdlist->last++] = G2D_LIST_HOLD;\r\n} else {\r\ncmdlist->data[cmdlist->last++] = G2D_INTEN;\r\ncmdlist->data[cmdlist->last++] = G2D_INTEN_ACF;\r\n}\r\nsize = cmdlist->last + req->cmd_nr * 2 + req->cmd_buf_nr * 2 + 2;\r\nif (size > G2D_CMDLIST_DATA_NUM) {\r\ndev_err(dev, "cmdlist size is too big\n");\r\nret = -EINVAL;\r\ngoto err_free_event;\r\n}\r\ncmd = (struct drm_exynos_g2d_cmd *)(uint32_t)req->cmd;\r\nif (copy_from_user(cmdlist->data + cmdlist->last,\r\n(void __user *)cmd,\r\nsizeof(*cmd) * req->cmd_nr)) {\r\nret = -EFAULT;\r\ngoto err_free_event;\r\n}\r\ncmdlist->last += req->cmd_nr * 2;\r\nret = g2d_check_reg_offset(dev, node, req->cmd_nr, false);\r\nif (ret < 0)\r\ngoto err_free_event;\r\nnode->buf_info.map_nr = req->cmd_buf_nr;\r\nif (req->cmd_buf_nr) {\r\nstruct drm_exynos_g2d_cmd *cmd_buf;\r\ncmd_buf = (struct drm_exynos_g2d_cmd *)(uint32_t)req->cmd_buf;\r\nif (copy_from_user(cmdlist->data + cmdlist->last,\r\n(void __user *)cmd_buf,\r\nsizeof(*cmd_buf) * req->cmd_buf_nr)) {\r\nret = -EFAULT;\r\ngoto err_free_event;\r\n}\r\ncmdlist->last += req->cmd_buf_nr * 2;\r\nret = g2d_check_reg_offset(dev, node, req->cmd_buf_nr, true);\r\nif (ret < 0)\r\ngoto err_free_event;\r\nret = g2d_map_cmdlist_gem(g2d, node, drm_dev, file);\r\nif (ret < 0)\r\ngoto err_unmap;\r\n}\r\ncmdlist->data[cmdlist->last++] = G2D_BITBLT_START;\r\ncmdlist->data[cmdlist->last++] = G2D_START_BITBLT;\r\ncmdlist->head = cmdlist->last / 2;\r\ncmdlist->data[cmdlist->last] = 0;\r\ng2d_add_cmdlist_to_inuse(g2d_priv, node);\r\nreturn 0;\r\nerr_unmap:\r\ng2d_unmap_cmdlist_gem(g2d, node, file);\r\nerr_free_event:\r\nif (node->event) {\r\nspin_lock_irqsave(&drm_dev->event_lock, flags);\r\nfile->event_space += sizeof(e->event);\r\nspin_unlock_irqrestore(&drm_dev->event_lock, flags);\r\nkfree(node->event);\r\n}\r\nerr:\r\ng2d_put_cmdlist(g2d, node);\r\nreturn ret;\r\n}\r\nint exynos_g2d_exec_ioctl(struct drm_device *drm_dev, void *data,\r\nstruct drm_file *file)\r\n{\r\nstruct drm_exynos_file_private *file_priv = file->driver_priv;\r\nstruct exynos_drm_g2d_private *g2d_priv = file_priv->g2d_priv;\r\nstruct device *dev;\r\nstruct g2d_data *g2d;\r\nstruct drm_exynos_g2d_exec *req = data;\r\nstruct g2d_runqueue_node *runqueue_node;\r\nstruct list_head *run_cmdlist;\r\nstruct list_head *event_list;\r\nif (!g2d_priv)\r\nreturn -ENODEV;\r\ndev = g2d_priv->dev;\r\nif (!dev)\r\nreturn -ENODEV;\r\ng2d = dev_get_drvdata(dev);\r\nif (!g2d)\r\nreturn -EFAULT;\r\nrunqueue_node = kmem_cache_alloc(g2d->runqueue_slab, GFP_KERNEL);\r\nif (!runqueue_node) {\r\ndev_err(dev, "failed to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nrun_cmdlist = &runqueue_node->run_cmdlist;\r\nevent_list = &runqueue_node->event_list;\r\nINIT_LIST_HEAD(run_cmdlist);\r\nINIT_LIST_HEAD(event_list);\r\ninit_completion(&runqueue_node->complete);\r\nrunqueue_node->async = req->async;\r\nlist_splice_init(&g2d_priv->inuse_cmdlist, run_cmdlist);\r\nlist_splice_init(&g2d_priv->event_list, event_list);\r\nif (list_empty(run_cmdlist)) {\r\ndev_err(dev, "there is no inuse cmdlist\n");\r\nkmem_cache_free(g2d->runqueue_slab, runqueue_node);\r\nreturn -EPERM;\r\n}\r\nmutex_lock(&g2d->runqueue_mutex);\r\nrunqueue_node->pid = current->pid;\r\nrunqueue_node->filp = file;\r\nlist_add_tail(&runqueue_node->list, &g2d->runqueue);\r\nif (!g2d->runqueue_node)\r\ng2d_exec_runqueue(g2d);\r\nmutex_unlock(&g2d->runqueue_mutex);\r\nif (runqueue_node->async)\r\ngoto out;\r\nwait_for_completion(&runqueue_node->complete);\r\ng2d_free_runqueue_node(g2d, runqueue_node);\r\nout:\r\nreturn 0;\r\n}\r\nstatic int g2d_subdrv_probe(struct drm_device *drm_dev, struct device *dev)\r\n{\r\nstruct g2d_data *g2d;\r\nint ret;\r\ng2d = dev_get_drvdata(dev);\r\nif (!g2d)\r\nreturn -EFAULT;\r\nret = g2d_init_cmdlist(g2d);\r\nif (ret < 0) {\r\ndev_err(dev, "cmdlist init failed\n");\r\nreturn ret;\r\n}\r\nret = drm_iommu_attach_device(drm_dev, dev);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to enable iommu.\n");\r\ng2d_fini_cmdlist(g2d);\r\n}\r\nreturn ret;\r\n}\r\nstatic void g2d_subdrv_remove(struct drm_device *drm_dev, struct device *dev)\r\n{\r\ndrm_iommu_detach_device(drm_dev, dev);\r\n}\r\nstatic int g2d_open(struct drm_device *drm_dev, struct device *dev,\r\nstruct drm_file *file)\r\n{\r\nstruct drm_exynos_file_private *file_priv = file->driver_priv;\r\nstruct exynos_drm_g2d_private *g2d_priv;\r\ng2d_priv = kzalloc(sizeof(*g2d_priv), GFP_KERNEL);\r\nif (!g2d_priv)\r\nreturn -ENOMEM;\r\ng2d_priv->dev = dev;\r\nfile_priv->g2d_priv = g2d_priv;\r\nINIT_LIST_HEAD(&g2d_priv->inuse_cmdlist);\r\nINIT_LIST_HEAD(&g2d_priv->event_list);\r\nINIT_LIST_HEAD(&g2d_priv->userptr_list);\r\nreturn 0;\r\n}\r\nstatic void g2d_close(struct drm_device *drm_dev, struct device *dev,\r\nstruct drm_file *file)\r\n{\r\nstruct drm_exynos_file_private *file_priv = file->driver_priv;\r\nstruct exynos_drm_g2d_private *g2d_priv = file_priv->g2d_priv;\r\nstruct g2d_data *g2d;\r\nstruct g2d_cmdlist_node *node, *n;\r\nif (!dev)\r\nreturn;\r\ng2d = dev_get_drvdata(dev);\r\nif (!g2d)\r\nreturn;\r\nmutex_lock(&g2d->cmdlist_mutex);\r\nlist_for_each_entry_safe(node, n, &g2d_priv->inuse_cmdlist, list) {\r\ng2d_unmap_cmdlist_gem(g2d, node, file);\r\nlist_move_tail(&node->list, &g2d->free_cmdlist);\r\n}\r\nmutex_unlock(&g2d->cmdlist_mutex);\r\ng2d_userptr_free_all(drm_dev, g2d, file);\r\nkfree(file_priv->g2d_priv);\r\n}\r\nstatic int g2d_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct g2d_data *g2d;\r\nstruct exynos_drm_subdrv *subdrv;\r\nint ret;\r\ng2d = devm_kzalloc(dev, sizeof(*g2d), GFP_KERNEL);\r\nif (!g2d)\r\nreturn -ENOMEM;\r\ng2d->runqueue_slab = kmem_cache_create("g2d_runqueue_slab",\r\nsizeof(struct g2d_runqueue_node), 0, 0, NULL);\r\nif (!g2d->runqueue_slab)\r\nreturn -ENOMEM;\r\ng2d->dev = dev;\r\ng2d->g2d_workq = create_singlethread_workqueue("g2d");\r\nif (!g2d->g2d_workq) {\r\ndev_err(dev, "failed to create workqueue\n");\r\nret = -EINVAL;\r\ngoto err_destroy_slab;\r\n}\r\nINIT_WORK(&g2d->runqueue_work, g2d_runqueue_worker);\r\nINIT_LIST_HEAD(&g2d->free_cmdlist);\r\nINIT_LIST_HEAD(&g2d->runqueue);\r\nmutex_init(&g2d->cmdlist_mutex);\r\nmutex_init(&g2d->runqueue_mutex);\r\ng2d->gate_clk = devm_clk_get(dev, "fimg2d");\r\nif (IS_ERR(g2d->gate_clk)) {\r\ndev_err(dev, "failed to get gate clock\n");\r\nret = PTR_ERR(g2d->gate_clk);\r\ngoto err_destroy_workqueue;\r\n}\r\npm_runtime_enable(dev);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ng2d->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(g2d->regs)) {\r\nret = PTR_ERR(g2d->regs);\r\ngoto err_put_clk;\r\n}\r\ng2d->irq = platform_get_irq(pdev, 0);\r\nif (g2d->irq < 0) {\r\ndev_err(dev, "failed to get irq\n");\r\nret = g2d->irq;\r\ngoto err_put_clk;\r\n}\r\nret = devm_request_irq(dev, g2d->irq, g2d_irq_handler, 0,\r\n"drm_g2d", g2d);\r\nif (ret < 0) {\r\ndev_err(dev, "irq request failed\n");\r\ngoto err_put_clk;\r\n}\r\ng2d->max_pool = MAX_POOL;\r\nplatform_set_drvdata(pdev, g2d);\r\nsubdrv = &g2d->subdrv;\r\nsubdrv->dev = dev;\r\nsubdrv->probe = g2d_subdrv_probe;\r\nsubdrv->remove = g2d_subdrv_remove;\r\nsubdrv->open = g2d_open;\r\nsubdrv->close = g2d_close;\r\nret = exynos_drm_subdrv_register(subdrv);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to register drm g2d device\n");\r\ngoto err_put_clk;\r\n}\r\ndev_info(dev, "The exynos g2d(ver %d.%d) successfully probed\n",\r\nG2D_HW_MAJOR_VER, G2D_HW_MINOR_VER);\r\nreturn 0;\r\nerr_put_clk:\r\npm_runtime_disable(dev);\r\nerr_destroy_workqueue:\r\ndestroy_workqueue(g2d->g2d_workq);\r\nerr_destroy_slab:\r\nkmem_cache_destroy(g2d->runqueue_slab);\r\nreturn ret;\r\n}\r\nstatic int g2d_remove(struct platform_device *pdev)\r\n{\r\nstruct g2d_data *g2d = platform_get_drvdata(pdev);\r\ncancel_work_sync(&g2d->runqueue_work);\r\nexynos_drm_subdrv_unregister(&g2d->subdrv);\r\nwhile (g2d->runqueue_node) {\r\ng2d_free_runqueue_node(g2d, g2d->runqueue_node);\r\ng2d->runqueue_node = g2d_get_runqueue_node(g2d);\r\n}\r\npm_runtime_disable(&pdev->dev);\r\ng2d_fini_cmdlist(g2d);\r\ndestroy_workqueue(g2d->g2d_workq);\r\nkmem_cache_destroy(g2d->runqueue_slab);\r\nreturn 0;\r\n}\r\nstatic int g2d_suspend(struct device *dev)\r\n{\r\nstruct g2d_data *g2d = dev_get_drvdata(dev);\r\nmutex_lock(&g2d->runqueue_mutex);\r\ng2d->suspended = true;\r\nmutex_unlock(&g2d->runqueue_mutex);\r\nwhile (g2d->runqueue_node)\r\nusleep_range(500, 1000);\r\nflush_work(&g2d->runqueue_work);\r\nreturn 0;\r\n}\r\nstatic int g2d_resume(struct device *dev)\r\n{\r\nstruct g2d_data *g2d = dev_get_drvdata(dev);\r\ng2d->suspended = false;\r\ng2d_exec_runqueue(g2d);\r\nreturn 0;\r\n}\r\nstatic int g2d_runtime_suspend(struct device *dev)\r\n{\r\nstruct g2d_data *g2d = dev_get_drvdata(dev);\r\nclk_disable_unprepare(g2d->gate_clk);\r\nreturn 0;\r\n}\r\nstatic int g2d_runtime_resume(struct device *dev)\r\n{\r\nstruct g2d_data *g2d = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_prepare_enable(g2d->gate_clk);\r\nif (ret < 0)\r\ndev_warn(dev, "failed to enable clock.\n");\r\nreturn ret;\r\n}
