int mxl111sf_init_tuner_demod(struct mxl111sf_state *state)\r\n{\r\nstruct mxl111sf_reg_ctrl_info mxl_111_overwrite_default[] = {\r\n{0x07, 0xff, 0x0c},\r\n{0x58, 0xff, 0x9d},\r\n{0x09, 0xff, 0x00},\r\n{0x06, 0xff, 0x06},\r\n{0xc8, 0xff, 0x40},\r\n{0x8d, 0x01, 0x01},\r\n{0x32, 0xff, 0xac},\r\n{0x42, 0xff, 0x43},\r\n{0x74, 0xff, 0xc4},\r\n{0x71, 0xff, 0xe6},\r\n{0x83, 0xff, 0x64},\r\n{0x85, 0xff, 0x64},\r\n{0x88, 0xff, 0xf0},\r\n{0x6f, 0xf0, 0xb0},\r\n{0x00, 0xff, 0x01},\r\n{0x81, 0xff, 0x11},\r\n{0xf4, 0xff, 0x07},\r\n{0xd4, 0x1f, 0x0f},\r\n{0xd6, 0xff, 0x0c},\r\n{0x00, 0xff, 0x00},\r\n{0, 0, 0}\r\n};\r\nmxl_debug("()");\r\nreturn mxl111sf_ctrl_program_regs(state, mxl_111_overwrite_default);\r\n}\r\nint mxl1x1sf_soft_reset(struct mxl111sf_state *state)\r\n{\r\nint ret;\r\nmxl_debug("()");\r\nret = mxl111sf_write_reg(state, 0xff, 0x00);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_write_reg(state, 0x02, 0x01);\r\nmxl_fail(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nint mxl1x1sf_set_device_mode(struct mxl111sf_state *state, int mode)\r\n{\r\nint ret;\r\nmxl_debug("(%s)", MXL_SOC_MODE == mode ?\r\n"MXL_SOC_MODE" : "MXL_TUNER_MODE");\r\nret = mxl111sf_write_reg(state, 0x03,\r\nMXL_SOC_MODE == mode ? 0x01 : 0x00);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_write_reg_mask(state,\r\n0x7d, 0x40, MXL_SOC_MODE == mode ?\r\n0x00 :\r\n0x40);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nstate->device_mode = mode;\r\nfail:\r\nreturn ret;\r\n}\r\nint mxl1x1sf_top_master_ctrl(struct mxl111sf_state *state, int onoff)\r\n{\r\nmxl_debug("(%d)", onoff);\r\nreturn mxl111sf_write_reg(state, 0x01, onoff ? 0x01 : 0x00);\r\n}\r\nint mxl111sf_disable_656_port(struct mxl111sf_state *state)\r\n{\r\nmxl_debug("()");\r\nreturn mxl111sf_write_reg_mask(state, 0x12, 0x04, 0x00);\r\n}\r\nint mxl111sf_enable_usb_output(struct mxl111sf_state *state)\r\n{\r\nmxl_debug("()");\r\nreturn mxl111sf_write_reg_mask(state, 0x17, 0x40, 0x00);\r\n}\r\nint mxl111sf_config_mpeg_in(struct mxl111sf_state *state,\r\nunsigned int parallel_serial,\r\nunsigned int msb_lsb_1st,\r\nunsigned int clock_phase,\r\nunsigned int mpeg_valid_pol,\r\nunsigned int mpeg_sync_pol)\r\n{\r\nint ret;\r\nu8 mode, tmp;\r\nmxl_debug("(%u,%u,%u,%u,%u)", parallel_serial, msb_lsb_1st,\r\nclock_phase, mpeg_valid_pol, mpeg_sync_pol);\r\nret = mxl111sf_write_reg(state, V6_PIN_MUX_MODE_REG, V6_ENABLE_PIN_MUX);\r\nmxl_fail(ret);\r\nmxl111sf_read_reg(state, V6_MPEG_IN_CLK_INV_REG, &mode);\r\nif (clock_phase == TSIF_NORMAL)\r\nmode &= ~V6_INVERTED_CLK_PHASE;\r\nelse\r\nmode |= V6_INVERTED_CLK_PHASE;\r\nret = mxl111sf_write_reg(state, V6_MPEG_IN_CLK_INV_REG, mode);\r\nmxl_fail(ret);\r\nret = mxl111sf_read_reg(state, V6_MPEG_IN_CTRL_REG, &mode);\r\nmxl_fail(ret);\r\nif (parallel_serial == TSIF_INPUT_PARALLEL) {\r\nmode &= ~V6_MPEG_IN_DATA_SERIAL;\r\nmode |= V6_MPEG_IN_DATA_PARALLEL;\r\n} else {\r\nmode &= ~V6_MPEG_IN_DATA_PARALLEL;\r\nmode |= V6_MPEG_IN_DATA_SERIAL;\r\nret = mxl111sf_read_reg(state,\r\nV6_MPEG_INOUT_BIT_ORDER_CTRL_REG,\r\n&tmp);\r\nmxl_fail(ret);\r\nif (msb_lsb_1st == MPEG_SER_MSB_FIRST_ENABLED)\r\ntmp |= V6_MPEG_SER_MSB_FIRST;\r\nelse\r\ntmp &= ~V6_MPEG_SER_MSB_FIRST;\r\nret = mxl111sf_write_reg(state,\r\nV6_MPEG_INOUT_BIT_ORDER_CTRL_REG,\r\ntmp);\r\nmxl_fail(ret);\r\n}\r\nif (mpeg_sync_pol == TSIF_NORMAL)\r\nmode &= ~V6_INVERTED_MPEG_SYNC;\r\nelse\r\nmode |= V6_INVERTED_MPEG_SYNC;\r\nif (mpeg_valid_pol == 0)\r\nmode &= ~V6_INVERTED_MPEG_VALID;\r\nelse\r\nmode |= V6_INVERTED_MPEG_VALID;\r\nret = mxl111sf_write_reg(state, V6_MPEG_IN_CTRL_REG, mode);\r\nmxl_fail(ret);\r\nreturn ret;\r\n}\r\nint mxl111sf_init_i2s_port(struct mxl111sf_state *state, u8 sample_size)\r\n{\r\nstatic struct mxl111sf_reg_ctrl_info init_i2s[] = {\r\n{0x1b, 0xff, 0x1e},\r\n{0x15, 0x60, 0x60},\r\n{0x17, 0xe0, 0x20},\r\n#if 0\r\n{0x12, 0x01, 0x00},\r\n#endif\r\n{0x00, 0xff, 0x02},\r\n{0x26, 0x0d, 0x0d},\r\n{0x00, 0xff, 0x00},\r\n{0, 0, 0}\r\n};\r\nint ret;\r\nmxl_debug("(0x%02x)", sample_size);\r\nret = mxl111sf_ctrl_program_regs(state, init_i2s);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_write_reg(state, V6_I2S_NUM_SAMPLES_REG, sample_size);\r\nmxl_fail(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nint mxl111sf_disable_i2s_port(struct mxl111sf_state *state)\r\n{\r\nstatic struct mxl111sf_reg_ctrl_info disable_i2s[] = {\r\n{0x15, 0x40, 0x00},\r\n{0, 0, 0}\r\n};\r\nmxl_debug("()");\r\nreturn mxl111sf_ctrl_program_regs(state, disable_i2s);\r\n}\r\nint mxl111sf_config_i2s(struct mxl111sf_state *state,\r\nu8 msb_start_pos, u8 data_width)\r\n{\r\nint ret;\r\nu8 tmp;\r\nmxl_debug("(0x%02x, 0x%02x)", msb_start_pos, data_width);\r\nret = mxl111sf_read_reg(state, V6_I2S_STREAM_START_BIT_REG, &tmp);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\ntmp &= 0xe0;\r\ntmp |= msb_start_pos;\r\nret = mxl111sf_write_reg(state, V6_I2S_STREAM_START_BIT_REG, tmp);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_read_reg(state, V6_I2S_STREAM_END_BIT_REG, &tmp);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\ntmp &= 0xe0;\r\ntmp |= data_width;\r\nret = mxl111sf_write_reg(state, V6_I2S_STREAM_END_BIT_REG, tmp);\r\nmxl_fail(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nint mxl111sf_config_spi(struct mxl111sf_state *state, int onoff)\r\n{\r\nu8 val;\r\nint ret;\r\nmxl_debug("(%d)", onoff);\r\nret = mxl111sf_write_reg(state, 0x00, 0x02);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_read_reg(state, V8_SPI_MODE_REG, &val);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nif (onoff)\r\nval |= 0x04;\r\nelse\r\nval &= ~0x04;\r\nret = mxl111sf_write_reg(state, V8_SPI_MODE_REG, val);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_write_reg(state, 0x00, 0x00);\r\nmxl_fail(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nint mxl111sf_idac_config(struct mxl111sf_state *state,\r\nu8 control_mode, u8 current_setting,\r\nu8 current_value, u8 hysteresis_value)\r\n{\r\nint ret;\r\nu8 val;\r\nval = current_value;\r\nif (control_mode == IDAC_MANUAL_CONTROL) {\r\nval |= IDAC_MANUAL_CONTROL_BIT_MASK;\r\nif (current_setting == IDAC_CURRENT_SINKING_ENABLE)\r\nval |= IDAC_CURRENT_SINKING_BIT_MASK;\r\nelse\r\nval &= ~IDAC_CURRENT_SINKING_BIT_MASK;\r\n} else {\r\nval &= ~IDAC_MANUAL_CONTROL_BIT_MASK;\r\nret = mxl111sf_write_reg(state, V6_IDAC_HYSTERESIS_REG,\r\n(hysteresis_value & 0x3F));\r\nmxl_fail(ret);\r\n}\r\nret = mxl111sf_write_reg(state, V6_IDAC_SETTINGS_REG, val);\r\nmxl_fail(ret);\r\nreturn ret;\r\n}
