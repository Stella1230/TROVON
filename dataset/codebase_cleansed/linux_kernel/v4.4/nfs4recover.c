static int\r\nnfs4_save_creds(const struct cred **original_creds)\r\n{\r\nstruct cred *new;\r\nnew = prepare_creds();\r\nif (!new)\r\nreturn -ENOMEM;\r\nnew->fsuid = GLOBAL_ROOT_UID;\r\nnew->fsgid = GLOBAL_ROOT_GID;\r\n*original_creds = override_creds(new);\r\nput_cred(new);\r\nreturn 0;\r\n}\r\nstatic void\r\nnfs4_reset_creds(const struct cred *original)\r\n{\r\nrevert_creds(original);\r\n}\r\nstatic void\r\nmd5_to_hex(char *out, char *md5)\r\n{\r\nint i;\r\nfor (i=0; i<16; i++) {\r\nunsigned char c = md5[i];\r\n*out++ = '0' + ((c&0xf0)>>4) + (c>=0xa0)*('a'-'9'-1);\r\n*out++ = '0' + (c&0x0f) + ((c&0x0f)>=0x0a)*('a'-'9'-1);\r\n}\r\n*out = '\0';\r\n}\r\nstatic int\r\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\r\n{\r\nstruct xdr_netobj cksum;\r\nstruct hash_desc desc;\r\nstruct scatterlist sg;\r\nint status;\r\ndprintk("NFSD: nfs4_make_rec_clidname for %.*s\n",\r\nclname->len, clname->data);\r\ndesc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\ndesc.tfm = crypto_alloc_hash("md5", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(desc.tfm)) {\r\nstatus = PTR_ERR(desc.tfm);\r\ngoto out_no_tfm;\r\n}\r\ncksum.len = crypto_hash_digestsize(desc.tfm);\r\ncksum.data = kmalloc(cksum.len, GFP_KERNEL);\r\nif (cksum.data == NULL) {\r\nstatus = -ENOMEM;\r\ngoto out;\r\n}\r\nsg_init_one(&sg, clname->data, clname->len);\r\nstatus = crypto_hash_digest(&desc, &sg, sg.length, cksum.data);\r\nif (status)\r\ngoto out;\r\nmd5_to_hex(dname, cksum.data);\r\nstatus = 0;\r\nout:\r\nkfree(cksum.data);\r\ncrypto_free_hash(desc.tfm);\r\nout_no_tfm:\r\nreturn status;\r\n}\r\nstatic void\r\nlegacy_recdir_name_error(struct nfs4_client *clp, int error)\r\n{\r\nprintk(KERN_ERR "NFSD: unable to generate recoverydir "\r\n"name (%d).\n", error);\r\nif (error == -ENOENT) {\r\nprintk(KERN_ERR "NFSD: disabling legacy clientid tracking. "\r\n"Reboot recovery will not function correctly!\n");\r\nnfsd4_client_tracking_exit(clp->net);\r\n}\r\n}\r\nstatic void\r\nnfsd4_create_clid_dir(struct nfs4_client *clp)\r\n{\r\nconst struct cred *original_cred;\r\nchar dname[HEXDIR_LEN];\r\nstruct dentry *dir, *dentry;\r\nstruct nfs4_client_reclaim *crp;\r\nint status;\r\nstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\r\nif (test_and_set_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\r\nreturn;\r\nif (!nn->rec_file)\r\nreturn;\r\nstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\r\nif (status)\r\nreturn legacy_recdir_name_error(clp, status);\r\nstatus = nfs4_save_creds(&original_cred);\r\nif (status < 0)\r\nreturn;\r\nstatus = mnt_want_write_file(nn->rec_file);\r\nif (status)\r\ngoto out_creds;\r\ndir = nn->rec_file->f_path.dentry;\r\nmutex_lock(&d_inode(dir)->i_mutex);\r\ndentry = lookup_one_len(dname, dir, HEXDIR_LEN-1);\r\nif (IS_ERR(dentry)) {\r\nstatus = PTR_ERR(dentry);\r\ngoto out_unlock;\r\n}\r\nif (d_really_is_positive(dentry))\r\ngoto out_put;\r\nstatus = vfs_mkdir(d_inode(dir), dentry, S_IRWXU);\r\nout_put:\r\ndput(dentry);\r\nout_unlock:\r\nmutex_unlock(&d_inode(dir)->i_mutex);\r\nif (status == 0) {\r\nif (nn->in_grace) {\r\ncrp = nfs4_client_to_reclaim(dname, nn);\r\nif (crp)\r\ncrp->cr_clp = clp;\r\n}\r\nvfs_fsync(nn->rec_file, 0);\r\n} else {\r\nprintk(KERN_ERR "NFSD: failed to write recovery record"\r\n" (err %d); please check that %s exists"\r\n" and is writeable", status,\r\nuser_recovery_dirname);\r\n}\r\nmnt_drop_write_file(nn->rec_file);\r\nout_creds:\r\nnfs4_reset_creds(original_cred);\r\n}\r\nstatic int\r\nnfsd4_build_namelist(struct dir_context *__ctx, const char *name, int namlen,\r\nloff_t offset, u64 ino, unsigned int d_type)\r\n{\r\nstruct nfs4_dir_ctx *ctx =\r\ncontainer_of(__ctx, struct nfs4_dir_ctx, ctx);\r\nstruct name_list *entry;\r\nif (namlen != HEXDIR_LEN - 1)\r\nreturn 0;\r\nentry = kmalloc(sizeof(struct name_list), GFP_KERNEL);\r\nif (entry == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(entry->name, name, HEXDIR_LEN - 1);\r\nentry->name[HEXDIR_LEN - 1] = '\0';\r\nlist_add(&entry->list, &ctx->names);\r\nreturn 0;\r\n}\r\nstatic int\r\nnfsd4_list_rec_dir(recdir_func *f, struct nfsd_net *nn)\r\n{\r\nconst struct cred *original_cred;\r\nstruct dentry *dir = nn->rec_file->f_path.dentry;\r\nstruct nfs4_dir_ctx ctx = {\r\n.ctx.actor = nfsd4_build_namelist,\r\n.names = LIST_HEAD_INIT(ctx.names)\r\n};\r\nstruct name_list *entry, *tmp;\r\nint status;\r\nstatus = nfs4_save_creds(&original_cred);\r\nif (status < 0)\r\nreturn status;\r\nstatus = vfs_llseek(nn->rec_file, 0, SEEK_SET);\r\nif (status < 0) {\r\nnfs4_reset_creds(original_cred);\r\nreturn status;\r\n}\r\nstatus = iterate_dir(nn->rec_file, &ctx.ctx);\r\nmutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_PARENT);\r\nlist_for_each_entry_safe(entry, tmp, &ctx.names, list) {\r\nif (!status) {\r\nstruct dentry *dentry;\r\ndentry = lookup_one_len(entry->name, dir, HEXDIR_LEN-1);\r\nif (IS_ERR(dentry)) {\r\nstatus = PTR_ERR(dentry);\r\nbreak;\r\n}\r\nstatus = f(dir, dentry, nn);\r\ndput(dentry);\r\n}\r\nlist_del(&entry->list);\r\nkfree(entry);\r\n}\r\nmutex_unlock(&d_inode(dir)->i_mutex);\r\nnfs4_reset_creds(original_cred);\r\nlist_for_each_entry_safe(entry, tmp, &ctx.names, list) {\r\ndprintk("NFSD: %s. Left entry %s\n", __func__, entry->name);\r\nlist_del(&entry->list);\r\nkfree(entry);\r\n}\r\nreturn status;\r\n}\r\nstatic int\r\nnfsd4_unlink_clid_dir(char *name, int namlen, struct nfsd_net *nn)\r\n{\r\nstruct dentry *dir, *dentry;\r\nint status;\r\ndprintk("NFSD: nfsd4_unlink_clid_dir. name %.*s\n", namlen, name);\r\ndir = nn->rec_file->f_path.dentry;\r\nmutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_PARENT);\r\ndentry = lookup_one_len(name, dir, namlen);\r\nif (IS_ERR(dentry)) {\r\nstatus = PTR_ERR(dentry);\r\ngoto out_unlock;\r\n}\r\nstatus = -ENOENT;\r\nif (d_really_is_negative(dentry))\r\ngoto out;\r\nstatus = vfs_rmdir(d_inode(dir), dentry);\r\nout:\r\ndput(dentry);\r\nout_unlock:\r\nmutex_unlock(&d_inode(dir)->i_mutex);\r\nreturn status;\r\n}\r\nstatic void\r\nnfsd4_remove_clid_dir(struct nfs4_client *clp)\r\n{\r\nconst struct cred *original_cred;\r\nstruct nfs4_client_reclaim *crp;\r\nchar dname[HEXDIR_LEN];\r\nint status;\r\nstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\r\nif (!nn->rec_file || !test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\r\nreturn;\r\nstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\r\nif (status)\r\nreturn legacy_recdir_name_error(clp, status);\r\nstatus = mnt_want_write_file(nn->rec_file);\r\nif (status)\r\ngoto out;\r\nclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\r\nstatus = nfs4_save_creds(&original_cred);\r\nif (status < 0)\r\ngoto out_drop_write;\r\nstatus = nfsd4_unlink_clid_dir(dname, HEXDIR_LEN-1, nn);\r\nnfs4_reset_creds(original_cred);\r\nif (status == 0) {\r\nvfs_fsync(nn->rec_file, 0);\r\nif (nn->in_grace) {\r\ncrp = nfsd4_find_reclaim_client(dname, nn);\r\nif (crp)\r\nnfs4_remove_reclaim_record(crp, nn);\r\n}\r\n}\r\nout_drop_write:\r\nmnt_drop_write_file(nn->rec_file);\r\nout:\r\nif (status)\r\nprintk("NFSD: Failed to remove expired client state directory"\r\n" %.*s\n", HEXDIR_LEN, dname);\r\n}\r\nstatic int\r\npurge_old(struct dentry *parent, struct dentry *child, struct nfsd_net *nn)\r\n{\r\nint status;\r\nif (nfs4_has_reclaimed_state(child->d_name.name, nn))\r\nreturn 0;\r\nstatus = vfs_rmdir(d_inode(parent), child);\r\nif (status)\r\nprintk("failed to remove client recovery directory %pd\n",\r\nchild);\r\nreturn 0;\r\n}\r\nstatic void\r\nnfsd4_recdir_purge_old(struct nfsd_net *nn)\r\n{\r\nint status;\r\nnn->in_grace = false;\r\nif (!nn->rec_file)\r\nreturn;\r\nstatus = mnt_want_write_file(nn->rec_file);\r\nif (status)\r\ngoto out;\r\nstatus = nfsd4_list_rec_dir(purge_old, nn);\r\nif (status == 0)\r\nvfs_fsync(nn->rec_file, 0);\r\nmnt_drop_write_file(nn->rec_file);\r\nout:\r\nnfs4_release_reclaim(nn);\r\nif (status)\r\nprintk("nfsd4: failed to purge old clients from recovery"\r\n" directory %pD\n", nn->rec_file);\r\n}\r\nstatic int\r\nload_recdir(struct dentry *parent, struct dentry *child, struct nfsd_net *nn)\r\n{\r\nif (child->d_name.len != HEXDIR_LEN - 1) {\r\nprintk("nfsd4: illegal name %pd in recovery directory\n",\r\nchild);\r\nreturn 0;\r\n}\r\nnfs4_client_to_reclaim(child->d_name.name, nn);\r\nreturn 0;\r\n}\r\nstatic int\r\nnfsd4_recdir_load(struct net *net) {\r\nint status;\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nif (!nn->rec_file)\r\nreturn 0;\r\nstatus = nfsd4_list_rec_dir(load_recdir, nn);\r\nif (status)\r\nprintk("nfsd4: failed loading clients from recovery"\r\n" directory %pD\n", nn->rec_file);\r\nreturn status;\r\n}\r\nstatic int\r\nnfsd4_init_recdir(struct net *net)\r\n{\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nconst struct cred *original_cred;\r\nint status;\r\nprintk("NFSD: Using %s as the NFSv4 state recovery directory\n",\r\nuser_recovery_dirname);\r\nBUG_ON(nn->rec_file);\r\nstatus = nfs4_save_creds(&original_cred);\r\nif (status < 0) {\r\nprintk("NFSD: Unable to change credentials to find recovery"\r\n" directory: error %d\n",\r\nstatus);\r\nreturn status;\r\n}\r\nnn->rec_file = filp_open(user_recovery_dirname, O_RDONLY | O_DIRECTORY, 0);\r\nif (IS_ERR(nn->rec_file)) {\r\nprintk("NFSD: unable to find recovery directory %s\n",\r\nuser_recovery_dirname);\r\nstatus = PTR_ERR(nn->rec_file);\r\nnn->rec_file = NULL;\r\n}\r\nnfs4_reset_creds(original_cred);\r\nif (!status)\r\nnn->in_grace = true;\r\nreturn status;\r\n}\r\nstatic void\r\nnfsd4_shutdown_recdir(struct net *net)\r\n{\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nif (!nn->rec_file)\r\nreturn;\r\nfput(nn->rec_file);\r\nnn->rec_file = NULL;\r\n}\r\nstatic int\r\nnfs4_legacy_state_init(struct net *net)\r\n{\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nint i;\r\nnn->reclaim_str_hashtbl = kmalloc(sizeof(struct list_head) *\r\nCLIENT_HASH_SIZE, GFP_KERNEL);\r\nif (!nn->reclaim_str_hashtbl)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < CLIENT_HASH_SIZE; i++)\r\nINIT_LIST_HEAD(&nn->reclaim_str_hashtbl[i]);\r\nnn->reclaim_str_hashtbl_size = 0;\r\nreturn 0;\r\n}\r\nstatic void\r\nnfs4_legacy_state_shutdown(struct net *net)\r\n{\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nkfree(nn->reclaim_str_hashtbl);\r\n}\r\nstatic int\r\nnfsd4_load_reboot_recovery_data(struct net *net)\r\n{\r\nint status;\r\nstatus = nfsd4_init_recdir(net);\r\nif (status)\r\nreturn status;\r\nstatus = nfsd4_recdir_load(net);\r\nif (status)\r\nnfsd4_shutdown_recdir(net);\r\nreturn status;\r\n}\r\nstatic int\r\nnfsd4_legacy_tracking_init(struct net *net)\r\n{\r\nint status;\r\nif (net != &init_net) {\r\npr_warn("NFSD: attempt to initialize legacy client tracking in a container ignored.\n");\r\nreturn -EINVAL;\r\n}\r\nstatus = nfs4_legacy_state_init(net);\r\nif (status)\r\nreturn status;\r\nstatus = nfsd4_load_reboot_recovery_data(net);\r\nif (status)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nnfs4_legacy_state_shutdown(net);\r\nreturn status;\r\n}\r\nstatic void\r\nnfsd4_legacy_tracking_exit(struct net *net)\r\n{\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nnfs4_release_reclaim(nn);\r\nnfsd4_shutdown_recdir(net);\r\nnfs4_legacy_state_shutdown(net);\r\n}\r\nint\r\nnfs4_reset_recoverydir(char *recdir)\r\n{\r\nint status;\r\nstruct path path;\r\nstatus = kern_path(recdir, LOOKUP_FOLLOW, &path);\r\nif (status)\r\nreturn status;\r\nstatus = -ENOTDIR;\r\nif (d_is_dir(path.dentry)) {\r\nstrcpy(user_recovery_dirname, recdir);\r\nstatus = 0;\r\n}\r\npath_put(&path);\r\nreturn status;\r\n}\r\nchar *\r\nnfs4_recoverydir(void)\r\n{\r\nreturn user_recovery_dirname;\r\n}\r\nstatic int\r\nnfsd4_check_legacy_client(struct nfs4_client *clp)\r\n{\r\nint status;\r\nchar dname[HEXDIR_LEN];\r\nstruct nfs4_client_reclaim *crp;\r\nstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\r\nif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\r\nreturn 0;\r\nstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\r\nif (status) {\r\nlegacy_recdir_name_error(clp, status);\r\nreturn status;\r\n}\r\ncrp = nfsd4_find_reclaim_client(dname, nn);\r\nif (crp) {\r\nset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\r\ncrp->cr_clp = clp;\r\nreturn 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int\r\n__cld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\r\n{\r\nint ret;\r\nstruct rpc_pipe_msg msg;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.data = cmsg;\r\nmsg.len = sizeof(*cmsg);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nret = rpc_queue_upcall(pipe, &msg);\r\nif (ret < 0) {\r\nset_current_state(TASK_RUNNING);\r\ngoto out;\r\n}\r\nschedule();\r\nif (msg.errno < 0)\r\nret = msg.errno;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int\r\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\r\n{\r\nint ret;\r\ndo {\r\nret = __cld_pipe_upcall(pipe, cmsg);\r\n} while (ret == -EAGAIN);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\ncld_pipe_downcall(struct file *filp, const char __user *src, size_t mlen)\r\n{\r\nstruct cld_upcall *tmp, *cup;\r\nstruct cld_msg __user *cmsg = (struct cld_msg __user *)src;\r\nuint32_t xid;\r\nstruct nfsd_net *nn = net_generic(file_inode(filp)->i_sb->s_fs_info,\r\nnfsd_net_id);\r\nstruct cld_net *cn = nn->cld_net;\r\nif (mlen != sizeof(*cmsg)) {\r\ndprintk("%s: got %zu bytes, expected %zu\n", __func__, mlen,\r\nsizeof(*cmsg));\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&xid, &cmsg->cm_xid, sizeof(xid)) != 0) {\r\ndprintk("%s: error when copying xid from userspace", __func__);\r\nreturn -EFAULT;\r\n}\r\ncup = NULL;\r\nspin_lock(&cn->cn_lock);\r\nlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\r\nif (get_unaligned(&tmp->cu_msg.cm_xid) == xid) {\r\ncup = tmp;\r\nlist_del_init(&cup->cu_list);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&cn->cn_lock);\r\nif (!cup) {\r\ndprintk("%s: couldn't find upcall -- xid=%u\n", __func__, xid);\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&cup->cu_msg, src, mlen) != 0)\r\nreturn -EFAULT;\r\nwake_up_process(cup->cu_task);\r\nreturn mlen;\r\n}\r\nstatic void\r\ncld_pipe_destroy_msg(struct rpc_pipe_msg *msg)\r\n{\r\nstruct cld_msg *cmsg = msg->data;\r\nstruct cld_upcall *cup = container_of(cmsg, struct cld_upcall,\r\ncu_msg);\r\nif (msg->errno >= 0)\r\nreturn;\r\nwake_up_process(cup->cu_task);\r\n}\r\nstatic struct dentry *\r\nnfsd4_cld_register_sb(struct super_block *sb, struct rpc_pipe *pipe)\r\n{\r\nstruct dentry *dir, *dentry;\r\ndir = rpc_d_lookup_sb(sb, NFSD_PIPE_DIR);\r\nif (dir == NULL)\r\nreturn ERR_PTR(-ENOENT);\r\ndentry = rpc_mkpipe_dentry(dir, NFSD_CLD_PIPE, NULL, pipe);\r\ndput(dir);\r\nreturn dentry;\r\n}\r\nstatic void\r\nnfsd4_cld_unregister_sb(struct rpc_pipe *pipe)\r\n{\r\nif (pipe->dentry)\r\nrpc_unlink(pipe->dentry);\r\n}\r\nstatic struct dentry *\r\nnfsd4_cld_register_net(struct net *net, struct rpc_pipe *pipe)\r\n{\r\nstruct super_block *sb;\r\nstruct dentry *dentry;\r\nsb = rpc_get_sb_net(net);\r\nif (!sb)\r\nreturn NULL;\r\ndentry = nfsd4_cld_register_sb(sb, pipe);\r\nrpc_put_sb_net(net);\r\nreturn dentry;\r\n}\r\nstatic void\r\nnfsd4_cld_unregister_net(struct net *net, struct rpc_pipe *pipe)\r\n{\r\nstruct super_block *sb;\r\nsb = rpc_get_sb_net(net);\r\nif (sb) {\r\nnfsd4_cld_unregister_sb(pipe);\r\nrpc_put_sb_net(net);\r\n}\r\n}\r\nstatic int\r\nnfsd4_init_cld_pipe(struct net *net)\r\n{\r\nint ret;\r\nstruct dentry *dentry;\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nstruct cld_net *cn;\r\nif (nn->cld_net)\r\nreturn 0;\r\ncn = kzalloc(sizeof(*cn), GFP_KERNEL);\r\nif (!cn) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ncn->cn_pipe = rpc_mkpipe_data(&cld_upcall_ops, RPC_PIPE_WAIT_FOR_OPEN);\r\nif (IS_ERR(cn->cn_pipe)) {\r\nret = PTR_ERR(cn->cn_pipe);\r\ngoto err;\r\n}\r\nspin_lock_init(&cn->cn_lock);\r\nINIT_LIST_HEAD(&cn->cn_list);\r\ndentry = nfsd4_cld_register_net(net, cn->cn_pipe);\r\nif (IS_ERR(dentry)) {\r\nret = PTR_ERR(dentry);\r\ngoto err_destroy_data;\r\n}\r\ncn->cn_pipe->dentry = dentry;\r\nnn->cld_net = cn;\r\nreturn 0;\r\nerr_destroy_data:\r\nrpc_destroy_pipe_data(cn->cn_pipe);\r\nerr:\r\nkfree(cn);\r\nprintk(KERN_ERR "NFSD: unable to create nfsdcld upcall pipe (%d)\n",\r\nret);\r\nreturn ret;\r\n}\r\nstatic void\r\nnfsd4_remove_cld_pipe(struct net *net)\r\n{\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nstruct cld_net *cn = nn->cld_net;\r\nnfsd4_cld_unregister_net(net, cn->cn_pipe);\r\nrpc_destroy_pipe_data(cn->cn_pipe);\r\nkfree(nn->cld_net);\r\nnn->cld_net = NULL;\r\n}\r\nstatic struct cld_upcall *\r\nalloc_cld_upcall(struct cld_net *cn)\r\n{\r\nstruct cld_upcall *new, *tmp;\r\nnew = kzalloc(sizeof(*new), GFP_KERNEL);\r\nif (!new)\r\nreturn new;\r\nrestart_search:\r\nspin_lock(&cn->cn_lock);\r\nlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\r\nif (tmp->cu_msg.cm_xid == cn->cn_xid) {\r\ncn->cn_xid++;\r\nspin_unlock(&cn->cn_lock);\r\ngoto restart_search;\r\n}\r\n}\r\nnew->cu_task = current;\r\nnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\r\nput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\r\nnew->cu_net = cn;\r\nlist_add(&new->cu_list, &cn->cn_list);\r\nspin_unlock(&cn->cn_lock);\r\ndprintk("%s: allocated xid %u\n", __func__, new->cu_msg.cm_xid);\r\nreturn new;\r\n}\r\nstatic void\r\nfree_cld_upcall(struct cld_upcall *victim)\r\n{\r\nstruct cld_net *cn = victim->cu_net;\r\nspin_lock(&cn->cn_lock);\r\nlist_del(&victim->cu_list);\r\nspin_unlock(&cn->cn_lock);\r\nkfree(victim);\r\n}\r\nstatic void\r\nnfsd4_cld_create(struct nfs4_client *clp)\r\n{\r\nint ret;\r\nstruct cld_upcall *cup;\r\nstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\r\nstruct cld_net *cn = nn->cld_net;\r\nif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\r\nreturn;\r\ncup = alloc_cld_upcall(cn);\r\nif (!cup) {\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\ncup->cu_msg.cm_cmd = Cld_Create;\r\ncup->cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\r\nmemcpy(cup->cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\r\nclp->cl_name.len);\r\nret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\r\nif (!ret) {\r\nret = cup->cu_msg.cm_status;\r\nset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\r\n}\r\nfree_cld_upcall(cup);\r\nout_err:\r\nif (ret)\r\nprintk(KERN_ERR "NFSD: Unable to create client "\r\n"record on stable storage: %d\n", ret);\r\n}\r\nstatic void\r\nnfsd4_cld_remove(struct nfs4_client *clp)\r\n{\r\nint ret;\r\nstruct cld_upcall *cup;\r\nstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\r\nstruct cld_net *cn = nn->cld_net;\r\nif (!test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\r\nreturn;\r\ncup = alloc_cld_upcall(cn);\r\nif (!cup) {\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\ncup->cu_msg.cm_cmd = Cld_Remove;\r\ncup->cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\r\nmemcpy(cup->cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\r\nclp->cl_name.len);\r\nret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\r\nif (!ret) {\r\nret = cup->cu_msg.cm_status;\r\nclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\r\n}\r\nfree_cld_upcall(cup);\r\nout_err:\r\nif (ret)\r\nprintk(KERN_ERR "NFSD: Unable to remove client "\r\n"record from stable storage: %d\n", ret);\r\n}\r\nstatic int\r\nnfsd4_cld_check(struct nfs4_client *clp)\r\n{\r\nint ret;\r\nstruct cld_upcall *cup;\r\nstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\r\nstruct cld_net *cn = nn->cld_net;\r\nif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\r\nreturn 0;\r\ncup = alloc_cld_upcall(cn);\r\nif (!cup) {\r\nprintk(KERN_ERR "NFSD: Unable to check client record on "\r\n"stable storage: %d\n", -ENOMEM);\r\nreturn -ENOMEM;\r\n}\r\ncup->cu_msg.cm_cmd = Cld_Check;\r\ncup->cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\r\nmemcpy(cup->cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\r\nclp->cl_name.len);\r\nret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\r\nif (!ret) {\r\nret = cup->cu_msg.cm_status;\r\nset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\r\n}\r\nfree_cld_upcall(cup);\r\nreturn ret;\r\n}\r\nstatic void\r\nnfsd4_cld_grace_done(struct nfsd_net *nn)\r\n{\r\nint ret;\r\nstruct cld_upcall *cup;\r\nstruct cld_net *cn = nn->cld_net;\r\ncup = alloc_cld_upcall(cn);\r\nif (!cup) {\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\ncup->cu_msg.cm_cmd = Cld_GraceDone;\r\ncup->cu_msg.cm_u.cm_gracetime = (int64_t)nn->boot_time;\r\nret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\r\nif (!ret)\r\nret = cup->cu_msg.cm_status;\r\nfree_cld_upcall(cup);\r\nout_err:\r\nif (ret)\r\nprintk(KERN_ERR "NFSD: Unable to end grace period: %d\n", ret);\r\n}\r\nstatic char *\r\nnfsd4_cltrack_legacy_topdir(void)\r\n{\r\nint copied;\r\nsize_t len;\r\nchar *result;\r\nif (cltrack_legacy_disable)\r\nreturn NULL;\r\nlen = strlen(LEGACY_TOPDIR_ENV_PREFIX) +\r\nstrlen(nfs4_recoverydir()) + 1;\r\nresult = kmalloc(len, GFP_KERNEL);\r\nif (!result)\r\nreturn result;\r\ncopied = snprintf(result, len, LEGACY_TOPDIR_ENV_PREFIX "%s",\r\nnfs4_recoverydir());\r\nif (copied >= len) {\r\nkfree(result);\r\nreturn NULL;\r\n}\r\nreturn result;\r\n}\r\nstatic char *\r\nnfsd4_cltrack_legacy_recdir(const struct xdr_netobj *name)\r\n{\r\nint copied;\r\nsize_t len;\r\nchar *result;\r\nif (cltrack_legacy_disable)\r\nreturn NULL;\r\nlen = strlen(LEGACY_RECDIR_ENV_PREFIX) +\r\nstrlen(nfs4_recoverydir()) + 1 + HEXDIR_LEN;\r\nresult = kmalloc(len, GFP_KERNEL);\r\nif (!result)\r\nreturn result;\r\ncopied = snprintf(result, len, LEGACY_RECDIR_ENV_PREFIX "%s/",\r\nnfs4_recoverydir());\r\nif (copied > (len - HEXDIR_LEN)) {\r\nkfree(result);\r\nreturn NULL;\r\n}\r\ncopied = nfs4_make_rec_clidname(result + copied, name);\r\nif (copied) {\r\nkfree(result);\r\nreturn NULL;\r\n}\r\nreturn result;\r\n}\r\nstatic char *\r\nnfsd4_cltrack_client_has_session(struct nfs4_client *clp)\r\n{\r\nint copied;\r\nsize_t len;\r\nchar *result;\r\nlen = strlen(HAS_SESSION_ENV_PREFIX) + 1 + 1;\r\nresult = kmalloc(len, GFP_KERNEL);\r\nif (!result)\r\nreturn result;\r\ncopied = snprintf(result, len, HAS_SESSION_ENV_PREFIX "%c",\r\nclp->cl_minorversion ? 'Y' : 'N');\r\nif (copied >= len) {\r\nkfree(result);\r\nreturn NULL;\r\n}\r\nreturn result;\r\n}\r\nstatic char *\r\nnfsd4_cltrack_grace_start(time_t grace_start)\r\n{\r\nint copied;\r\nsize_t len;\r\nchar *result;\r\nlen = strlen(GRACE_START_ENV_PREFIX) + 22 + 1;\r\nresult = kmalloc(len, GFP_KERNEL);\r\nif (!result)\r\nreturn result;\r\ncopied = snprintf(result, len, GRACE_START_ENV_PREFIX "%ld",\r\ngrace_start);\r\nif (copied >= len) {\r\nkfree(result);\r\nreturn NULL;\r\n}\r\nreturn result;\r\n}\r\nstatic int\r\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\r\n{\r\nchar *envp[3];\r\nchar *argv[4];\r\nint ret;\r\nif (unlikely(!cltrack_prog[0])) {\r\ndprintk("%s: cltrack_prog is disabled\n", __func__);\r\nreturn -EACCES;\r\n}\r\ndprintk("%s: cmd: %s\n", __func__, cmd);\r\ndprintk("%s: arg: %s\n", __func__, arg ? arg : "(null)");\r\ndprintk("%s: env0: %s\n", __func__, env0 ? env0 : "(null)");\r\ndprintk("%s: env1: %s\n", __func__, env1 ? env1 : "(null)");\r\nenvp[0] = env0;\r\nenvp[1] = env1;\r\nenvp[2] = NULL;\r\nargv[0] = (char *)cltrack_prog;\r\nargv[1] = cmd;\r\nargv[2] = arg;\r\nargv[3] = NULL;\r\nret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\r\nif (ret == -ENOENT || ret == -EACCES) {\r\ndprintk("NFSD: %s was not found or isn't executable (%d). "\r\n"Setting cltrack_prog to blank string!",\r\ncltrack_prog, ret);\r\ncltrack_prog[0] = '\0';\r\n}\r\ndprintk("%s: %s return value: %d\n", __func__, cltrack_prog, ret);\r\nreturn ret;\r\n}\r\nstatic char *\r\nbin_to_hex_dup(const unsigned char *src, int srclen)\r\n{\r\nint i;\r\nchar *buf, *hex;\r\nbuf = kmalloc((srclen * 2) + 1, GFP_KERNEL);\r\nif (!buf)\r\nreturn buf;\r\nhex = buf;\r\nfor (i = 0; i < srclen; i++) {\r\nsprintf(hex, "%2.2x", *src++);\r\nhex += 2;\r\n}\r\nreturn buf;\r\n}\r\nstatic int\r\nnfsd4_umh_cltrack_init(struct net *net)\r\n{\r\nint ret;\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nchar *grace_start = nfsd4_cltrack_grace_start(nn->boot_time);\r\nif (net != &init_net) {\r\npr_warn("NFSD: attempt to initialize umh client tracking in a container ignored.\n");\r\nreturn -EINVAL;\r\n}\r\nret = nfsd4_umh_cltrack_upcall("init", NULL, grace_start, NULL);\r\nkfree(grace_start);\r\nreturn ret;\r\n}\r\nstatic void\r\nnfsd4_cltrack_upcall_lock(struct nfs4_client *clp)\r\n{\r\nwait_on_bit_lock(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK,\r\nTASK_UNINTERRUPTIBLE);\r\n}\r\nstatic void\r\nnfsd4_cltrack_upcall_unlock(struct nfs4_client *clp)\r\n{\r\nsmp_mb__before_atomic();\r\nclear_bit(NFSD4_CLIENT_UPCALL_LOCK, &clp->cl_flags);\r\nsmp_mb__after_atomic();\r\nwake_up_bit(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK);\r\n}\r\nstatic void\r\nnfsd4_umh_cltrack_create(struct nfs4_client *clp)\r\n{\r\nchar *hexid, *has_session, *grace_start;\r\nstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\r\nif (clp->cl_minorversion == 0 &&\r\ntest_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\r\nreturn;\r\nhexid = bin_to_hex_dup(clp->cl_name.data, clp->cl_name.len);\r\nif (!hexid) {\r\ndprintk("%s: can't allocate memory for upcall!\n", __func__);\r\nreturn;\r\n}\r\nhas_session = nfsd4_cltrack_client_has_session(clp);\r\ngrace_start = nfsd4_cltrack_grace_start(nn->boot_time);\r\nnfsd4_cltrack_upcall_lock(clp);\r\nif (!nfsd4_umh_cltrack_upcall("create", hexid, has_session, grace_start))\r\nset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\r\nnfsd4_cltrack_upcall_unlock(clp);\r\nkfree(has_session);\r\nkfree(grace_start);\r\nkfree(hexid);\r\n}\r\nstatic void\r\nnfsd4_umh_cltrack_remove(struct nfs4_client *clp)\r\n{\r\nchar *hexid;\r\nif (!test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\r\nreturn;\r\nhexid = bin_to_hex_dup(clp->cl_name.data, clp->cl_name.len);\r\nif (!hexid) {\r\ndprintk("%s: can't allocate memory for upcall!\n", __func__);\r\nreturn;\r\n}\r\nnfsd4_cltrack_upcall_lock(clp);\r\nif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags) &&\r\nnfsd4_umh_cltrack_upcall("remove", hexid, NULL, NULL) == 0)\r\nclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\r\nnfsd4_cltrack_upcall_unlock(clp);\r\nkfree(hexid);\r\n}\r\nstatic int\r\nnfsd4_umh_cltrack_check(struct nfs4_client *clp)\r\n{\r\nint ret;\r\nchar *hexid, *has_session, *legacy;\r\nif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\r\nreturn 0;\r\nhexid = bin_to_hex_dup(clp->cl_name.data, clp->cl_name.len);\r\nif (!hexid) {\r\ndprintk("%s: can't allocate memory for upcall!\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nhas_session = nfsd4_cltrack_client_has_session(clp);\r\nlegacy = nfsd4_cltrack_legacy_recdir(&clp->cl_name);\r\nnfsd4_cltrack_upcall_lock(clp);\r\nif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags)) {\r\nret = 0;\r\n} else {\r\nret = nfsd4_umh_cltrack_upcall("check", hexid, has_session, legacy);\r\nif (ret == 0)\r\nset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\r\n}\r\nnfsd4_cltrack_upcall_unlock(clp);\r\nkfree(has_session);\r\nkfree(legacy);\r\nkfree(hexid);\r\nreturn ret;\r\n}\r\nstatic void\r\nnfsd4_umh_cltrack_grace_done(struct nfsd_net *nn)\r\n{\r\nchar *legacy;\r\nchar timestr[22];\r\nsprintf(timestr, "%ld", nn->boot_time);\r\nlegacy = nfsd4_cltrack_legacy_topdir();\r\nnfsd4_umh_cltrack_upcall("gracedone", timestr, legacy, NULL);\r\nkfree(legacy);\r\n}\r\nint\r\nnfsd4_client_tracking_init(struct net *net)\r\n{\r\nint status;\r\nstruct path path;\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nif (nn->client_tracking_ops)\r\ngoto do_init;\r\nnn->client_tracking_ops = &nfsd4_umh_tracking_ops;\r\nstatus = nn->client_tracking_ops->init(net);\r\nif (!status)\r\nreturn status;\r\nnn->client_tracking_ops = &nfsd4_legacy_tracking_ops;\r\nstatus = kern_path(nfs4_recoverydir(), LOOKUP_FOLLOW, &path);\r\nif (!status) {\r\nstatus = d_is_dir(path.dentry);\r\npath_put(&path);\r\nif (status)\r\ngoto do_init;\r\n}\r\nnn->client_tracking_ops = &nfsd4_cld_tracking_ops;\r\nprintk(KERN_WARNING "NFSD: the nfsdcld client tracking upcall will be "\r\n"removed in 3.10. Please transition to using "\r\n"nfsdcltrack.\n");\r\ndo_init:\r\nstatus = nn->client_tracking_ops->init(net);\r\nif (status) {\r\nprintk(KERN_WARNING "NFSD: Unable to initialize client "\r\n"recovery tracking! (%d)\n", status);\r\nnn->client_tracking_ops = NULL;\r\n}\r\nreturn status;\r\n}\r\nvoid\r\nnfsd4_client_tracking_exit(struct net *net)\r\n{\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nif (nn->client_tracking_ops) {\r\nif (nn->client_tracking_ops->exit)\r\nnn->client_tracking_ops->exit(net);\r\nnn->client_tracking_ops = NULL;\r\n}\r\n}\r\nvoid\r\nnfsd4_client_record_create(struct nfs4_client *clp)\r\n{\r\nstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\r\nif (nn->client_tracking_ops)\r\nnn->client_tracking_ops->create(clp);\r\n}\r\nvoid\r\nnfsd4_client_record_remove(struct nfs4_client *clp)\r\n{\r\nstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\r\nif (nn->client_tracking_ops)\r\nnn->client_tracking_ops->remove(clp);\r\n}\r\nint\r\nnfsd4_client_record_check(struct nfs4_client *clp)\r\n{\r\nstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\r\nif (nn->client_tracking_ops)\r\nreturn nn->client_tracking_ops->check(clp);\r\nreturn -EOPNOTSUPP;\r\n}\r\nvoid\r\nnfsd4_record_grace_done(struct nfsd_net *nn)\r\n{\r\nif (nn->client_tracking_ops)\r\nnn->client_tracking_ops->grace_done(nn);\r\n}\r\nstatic int\r\nrpc_pipefs_event(struct notifier_block *nb, unsigned long event, void *ptr)\r\n{\r\nstruct super_block *sb = ptr;\r\nstruct net *net = sb->s_fs_info;\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nstruct cld_net *cn = nn->cld_net;\r\nstruct dentry *dentry;\r\nint ret = 0;\r\nif (!try_module_get(THIS_MODULE))\r\nreturn 0;\r\nif (!cn) {\r\nmodule_put(THIS_MODULE);\r\nreturn 0;\r\n}\r\nswitch (event) {\r\ncase RPC_PIPEFS_MOUNT:\r\ndentry = nfsd4_cld_register_sb(sb, cn->cn_pipe);\r\nif (IS_ERR(dentry)) {\r\nret = PTR_ERR(dentry);\r\nbreak;\r\n}\r\ncn->cn_pipe->dentry = dentry;\r\nbreak;\r\ncase RPC_PIPEFS_UMOUNT:\r\nif (cn->cn_pipe->dentry)\r\nnfsd4_cld_unregister_sb(cn->cn_pipe);\r\nbreak;\r\ndefault:\r\nret = -ENOTSUPP;\r\nbreak;\r\n}\r\nmodule_put(THIS_MODULE);\r\nreturn ret;\r\n}\r\nint\r\nregister_cld_notifier(void)\r\n{\r\nreturn rpc_pipefs_notifier_register(&nfsd4_cld_block);\r\n}\r\nvoid\r\nunregister_cld_notifier(void)\r\n{\r\nrpc_pipefs_notifier_unregister(&nfsd4_cld_block);\r\n}
