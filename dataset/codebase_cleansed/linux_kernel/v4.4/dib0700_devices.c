static int bristol_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_state *st = adap->dev->priv;\r\nif (adap->id == 0) {\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0); msleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1); msleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0); msleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1); msleep(10);\r\nif (force_lna_activation)\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\r\nelse\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 0);\r\nif (dib3000mc_i2c_enumeration(&adap->dev->i2c_adap, 2, DEFAULT_DIB3000P_I2C_ADDRESS, bristol_dib3000mc_config) != 0) {\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0); msleep(10);\r\nreturn -ENODEV;\r\n}\r\n}\r\nst->mt2060_if1[adap->id] = 1220;\r\nreturn (adap->fe_adap[0].fe = dvb_attach(dib3000mc_attach, &adap->dev->i2c_adap,\r\n(10 + adap->id) << 1, &bristol_dib3000mc_config[adap->id])) == NULL ? -ENODEV : 0;\r\n}\r\nstatic int eeprom_read(struct i2c_adapter *adap,u8 adrs,u8 *pval)\r\n{\r\nstruct i2c_msg msg[2] = {\r\n{ .addr = 0x50, .flags = 0, .buf = &adrs, .len = 1 },\r\n{ .addr = 0x50, .flags = I2C_M_RD, .buf = pval, .len = 1 },\r\n};\r\nif (i2c_transfer(adap, msg, 2) != 2) return -EREMOTEIO;\r\nreturn 0;\r\n}\r\nstatic int bristol_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct i2c_adapter *prim_i2c = &adap->dev->i2c_adap;\r\nstruct i2c_adapter *tun_i2c = dib3000mc_get_tuner_i2c_master(adap->fe_adap[0].fe, 1);\r\ns8 a;\r\nint if1=1220;\r\nif (adap->dev->udev->descriptor.idVendor == cpu_to_le16(USB_VID_HAUPPAUGE) &&\r\nadap->dev->udev->descriptor.idProduct == cpu_to_le16(USB_PID_HAUPPAUGE_NOVA_T_500_2)) {\r\nif (!eeprom_read(prim_i2c,0x59 + adap->id,&a)) if1=1220+a;\r\n}\r\nreturn dvb_attach(mt2060_attach, adap->fe_adap[0].fe, tun_i2c,\r\n&bristol_mt2060_config[adap->id], if1) == NULL ?\r\n-ENODEV : 0;\r\n}\r\nstatic int stk7700P2_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\r\nreturn -ENODEV;\r\nif (adap->id == 0) {\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\r\nmsleep(10);\r\nif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 18,\r\nstk7700d_dib7000p_mt2266_config)\r\n!= 0) {\r\nerr("%s: state->dib7000p_ops.i2c_enumeration failed. Cannot continue\n", __func__);\r\ndvb_detach(&state->dib7000p_ops);\r\nreturn -ENODEV;\r\n}\r\n}\r\nadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap,\r\n0x80 + (adap->id << 1),\r\n&stk7700d_dib7000p_mt2266_config[adap->id]);\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int stk7700d_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\r\nreturn -ENODEV;\r\nif (adap->id == 0) {\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\r\nif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 2, 18,\r\nstk7700d_dib7000p_mt2266_config)\r\n!= 0) {\r\nerr("%s: state->dib7000p_ops.i2c_enumeration failed. Cannot continue\n", __func__);\r\ndvb_detach(&state->dib7000p_ops);\r\nreturn -ENODEV;\r\n}\r\n}\r\nadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap,\r\n0x80 + (adap->id << 1),\r\n&stk7700d_dib7000p_mt2266_config[adap->id]);\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int stk7700d_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct i2c_adapter *tun_i2c;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\ntun_i2c = state->dib7000p_ops.get_i2c_master(adap->fe_adap[0].fe,\r\nDIBX000_I2C_INTERFACE_TUNER, 1);\r\nreturn dvb_attach(mt2266_attach, adap->fe_adap[0].fe, tun_i2c,\r\n&stk7700d_mt2266_config[adap->id]) == NULL ? -ENODEV : 0;\r\n}\r\nstatic int stk7700ph_xc3028_callback(void *ptr, int component,\r\nint command, int arg)\r\n{\r\nstruct dvb_usb_adapter *adap = ptr;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nswitch (command) {\r\ncase XC2028_TUNER_RESET:\r\nstate->dib7000p_ops.set_gpio(adap->fe_adap[0].fe, 8, 0, 0);\r\nmsleep(10);\r\nstate->dib7000p_ops.set_gpio(adap->fe_adap[0].fe, 8, 0, 1);\r\nbreak;\r\ncase XC2028_RESET_CLK:\r\nbreak;\r\ndefault:\r\nerr("%s: unknown command %d, arg %d\n", __func__,\r\ncommand, arg);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stk7700ph_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct usb_device_descriptor *desc = &adap->dev->udev->descriptor;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\r\nreturn -ENODEV;\r\nif (desc->idVendor == cpu_to_le16(USB_VID_PINNACLE) &&\r\ndesc->idProduct == cpu_to_le16(USB_PID_PINNACLE_EXPRESSCARD_320CX))\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0);\r\nelse\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\r\nmsleep(10);\r\nif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 18,\r\n&stk7700ph_dib7700_xc3028_config) != 0) {\r\nerr("%s: state->dib7000p_ops.i2c_enumeration failed. Cannot continue\n",\r\n__func__);\r\ndvb_detach(&state->dib7000p_ops);\r\nreturn -ENODEV;\r\n}\r\nadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x80,\r\n&stk7700ph_dib7700_xc3028_config);\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int stk7700ph_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct i2c_adapter *tun_i2c;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\ntun_i2c = state->dib7000p_ops.get_i2c_master(adap->fe_adap[0].fe,\r\nDIBX000_I2C_INTERFACE_TUNER, 1);\r\nstk7700ph_xc3028_config.i2c_adap = tun_i2c;\r\nadap->fe_adap[0].fe->callback = stk7700ph_xc3028_callback;\r\nreturn dvb_attach(xc2028_attach, adap->fe_adap[0].fe, &stk7700ph_xc3028_config)\r\n== NULL ? -ENODEV : 0;\r\n}\r\nstatic int dib0700_rc_query_old_firmware(struct dvb_usb_device *d)\r\n{\r\nu8 key[4];\r\nenum rc_type protocol;\r\nu32 scancode;\r\nu8 toggle;\r\nint i;\r\nstruct dib0700_state *st = d->priv;\r\nif (st->fw_version >= 0x10200) {\r\nreturn 0;\r\n}\r\ni = dib0700_ctrl_rd(d, rc_request, 2, key, 4);\r\nif (i <= 0) {\r\nerr("RC Query Failed");\r\nreturn -1;\r\n}\r\nif (key[0] == 0 && key[1] == 0 && key[2] == 0 && key[3] == 0)\r\nreturn 0;\r\ndib0700_rc_setup(d, NULL);\r\nswitch (d->props.rc.core.protocol) {\r\ncase RC_BIT_NEC:\r\nif ((key[3-2] == 0x00) && (key[3-3] == 0x00) &&\r\n(key[3] == 0xff)) {\r\nrc_repeat(d->rc_dev);\r\nreturn 0;\r\n}\r\nprotocol = RC_TYPE_NEC;\r\nscancode = RC_SCANCODE_NEC(key[3-2], key[3-3]);\r\ntoggle = 0;\r\nbreak;\r\ndefault:\r\nprotocol = RC_TYPE_RC5;\r\nscancode = RC_SCANCODE_RC5(key[3-2], key[3-3]);\r\ntoggle = key[3-1];\r\nbreak;\r\n}\r\nrc_keydown(d->rc_dev, protocol, scancode, toggle);\r\nreturn 0;\r\n}\r\nstatic int stk7700p_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_state *st = adap->dev->priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\r\nreturn -ENODEV;\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0); msleep(50);\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1); msleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0); msleep(10);\r\ndib0700_ctrl_clock(adap->dev, 72, 1);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1); msleep(100);\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\r\nst->mt2060_if1[0] = 1220;\r\nif (state->dib7000p_ops.dib7000pc_detection(&adap->dev->i2c_adap)) {\r\nadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 18, &stk7700p_dib7000p_config);\r\nst->is_dib7000pc = 1;\r\n} else {\r\nmemset(&state->dib7000p_ops, 0, sizeof(state->dib7000p_ops));\r\nadap->fe_adap[0].fe = dvb_attach(dib7000m_attach, &adap->dev->i2c_adap, 18, &stk7700p_dib7000m_config);\r\n}\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int stk7700p_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct i2c_adapter *prim_i2c = &adap->dev->i2c_adap;\r\nstruct dib0700_state *st = adap->dev->priv;\r\nstruct i2c_adapter *tun_i2c;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\ns8 a;\r\nint if1=1220;\r\nif (adap->dev->udev->descriptor.idVendor == cpu_to_le16(USB_VID_HAUPPAUGE) &&\r\nadap->dev->udev->descriptor.idProduct == cpu_to_le16(USB_PID_HAUPPAUGE_NOVA_T_STICK)) {\r\nif (!eeprom_read(prim_i2c,0x58,&a)) if1=1220+a;\r\n}\r\nif (st->is_dib7000pc)\r\ntun_i2c = state->dib7000p_ops.get_i2c_master(adap->fe_adap[0].fe, DIBX000_I2C_INTERFACE_TUNER, 1);\r\nelse\r\ntun_i2c = dib7000m_get_i2c_master(adap->fe_adap[0].fe, DIBX000_I2C_INTERFACE_TUNER, 1);\r\nreturn dvb_attach(mt2060_attach, adap->fe_adap[0].fe, tun_i2c, &stk7700p_mt2060_config,\r\nif1) == NULL ? -ENODEV : 0;\r\n}\r\nstatic int dib7070_tuner_reset(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\ndeb_info("reset: %d", onoff);\r\nreturn state->dib7000p_ops.set_gpio(fe, 8, 0, !onoff);\r\n}\r\nstatic int dib7070_tuner_sleep(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\ndeb_info("sleep: %d", onoff);\r\nreturn state->dib7000p_ops.set_gpio(fe, 9, 0, onoff);\r\n}\r\nstatic int dib7070_set_param_override(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nu16 offset;\r\nu8 band = BAND_OF_FREQUENCY(p->frequency/1000);\r\nswitch (band) {\r\ncase BAND_VHF: offset = 950; break;\r\ncase BAND_UHF:\r\ndefault: offset = 550; break;\r\n}\r\ndeb_info("WBD for DiB7000P: %d\n", offset + dib0070_wbd_offset(fe));\r\nstate->dib7000p_ops.set_wbd_ref(fe, offset + dib0070_wbd_offset(fe));\r\nreturn state->set_param_save(fe);\r\n}\r\nstatic int dib7770_set_param_override(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nu16 offset;\r\nu8 band = BAND_OF_FREQUENCY(p->frequency/1000);\r\nswitch (band) {\r\ncase BAND_VHF:\r\nstate->dib7000p_ops.set_gpio(fe, 0, 0, 1);\r\noffset = 850;\r\nbreak;\r\ncase BAND_UHF:\r\ndefault:\r\nstate->dib7000p_ops.set_gpio(fe, 0, 0, 0);\r\noffset = 250;\r\nbreak;\r\n}\r\ndeb_info("WBD for DiB7000P: %d\n", offset + dib0070_wbd_offset(fe));\r\nstate->dib7000p_ops.set_wbd_ref(fe, offset + dib0070_wbd_offset(fe));\r\nreturn state->set_param_save(fe);\r\n}\r\nstatic int dib7770p_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *st = adap->priv;\r\nstruct i2c_adapter *tun_i2c = st->dib7000p_ops.get_i2c_master(adap->fe_adap[0].fe,\r\nDIBX000_I2C_INTERFACE_TUNER, 1);\r\nif (dvb_attach(dib0070_attach, adap->fe_adap[0].fe, tun_i2c,\r\n&dib7770p_dib0070_config) == NULL)\r\nreturn -ENODEV;\r\nst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\r\nadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib7770_set_param_override;\r\nreturn 0;\r\n}\r\nstatic int dib7070p_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *st = adap->priv;\r\nstruct i2c_adapter *tun_i2c = st->dib7000p_ops.get_i2c_master(adap->fe_adap[0].fe, DIBX000_I2C_INTERFACE_TUNER, 1);\r\nif (adap->id == 0) {\r\nif (dvb_attach(dib0070_attach, adap->fe_adap[0].fe, tun_i2c, &dib7070p_dib0070_config[0]) == NULL)\r\nreturn -ENODEV;\r\n} else {\r\nif (dvb_attach(dib0070_attach, adap->fe_adap[0].fe, tun_i2c, &dib7070p_dib0070_config[1]) == NULL)\r\nreturn -ENODEV;\r\n}\r\nst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\r\nadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib7070_set_param_override;\r\nreturn 0;\r\n}\r\nstatic int stk7700p_pid_filter(struct dvb_usb_adapter *adapter, int index,\r\nu16 pid, int onoff)\r\n{\r\nstruct dib0700_adapter_state *state = adapter->priv;\r\nstruct dib0700_state *st = adapter->dev->priv;\r\nif (st->is_dib7000pc)\r\nreturn state->dib7000p_ops.pid_filter(adapter->fe_adap[0].fe, index, pid, onoff);\r\nreturn dib7000m_pid_filter(adapter->fe_adap[0].fe, index, pid, onoff);\r\n}\r\nstatic int stk7700p_pid_filter_ctrl(struct dvb_usb_adapter *adapter, int onoff)\r\n{\r\nstruct dib0700_state *st = adapter->dev->priv;\r\nstruct dib0700_adapter_state *state = adapter->priv;\r\nif (st->is_dib7000pc)\r\nreturn state->dib7000p_ops.pid_filter_ctrl(adapter->fe_adap[0].fe, onoff);\r\nreturn dib7000m_pid_filter_ctrl(adapter->fe_adap[0].fe, onoff);\r\n}\r\nstatic int stk70x0p_pid_filter(struct dvb_usb_adapter *adapter, int index, u16 pid, int onoff)\r\n{\r\nstruct dib0700_adapter_state *state = adapter->priv;\r\nreturn state->dib7000p_ops.pid_filter(adapter->fe_adap[0].fe, index, pid, onoff);\r\n}\r\nstatic int stk70x0p_pid_filter_ctrl(struct dvb_usb_adapter *adapter, int onoff)\r\n{\r\nstruct dib0700_adapter_state *state = adapter->priv;\r\nreturn state->dib7000p_ops.pid_filter_ctrl(adapter->fe_adap[0].fe, onoff);\r\n}\r\nstatic int stk7070p_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct usb_device_descriptor *p = &adap->dev->udev->descriptor;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\r\nreturn -ENODEV;\r\nif (p->idVendor == cpu_to_le16(USB_VID_PINNACLE) &&\r\np->idProduct == cpu_to_le16(USB_PID_PINNACLE_PCTV72E))\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0);\r\nelse\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\r\ndib0700_ctrl_clock(adap->dev, 72, 1);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\r\nif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 18,\r\n&dib7070p_dib7000p_config) != 0) {\r\nerr("%s: state->dib7000p_ops.i2c_enumeration failed. Cannot continue\n",\r\n__func__);\r\ndvb_detach(&state->dib7000p_ops);\r\nreturn -ENODEV;\r\n}\r\nadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x80,\r\n&dib7070p_dib7000p_config);\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int stk7770p_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct usb_device_descriptor *p = &adap->dev->udev->descriptor;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\r\nreturn -ENODEV;\r\nif (p->idVendor == cpu_to_le16(USB_VID_PINNACLE) &&\r\np->idProduct == cpu_to_le16(USB_PID_PINNACLE_PCTV72E))\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0);\r\nelse\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\r\ndib0700_ctrl_clock(adap->dev, 72, 1);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\r\nif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 18,\r\n&dib7770p_dib7000p_config) != 0) {\r\nerr("%s: state->dib7000p_ops.i2c_enumeration failed. Cannot continue\n",\r\n__func__);\r\ndvb_detach(&state->dib7000p_ops);\r\nreturn -ENODEV;\r\n}\r\nadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x80,\r\n&dib7770p_dib7000p_config);\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int dib80xx_tuner_reset(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nreturn state->dib8000_ops.set_gpio(fe, 5, 0, !onoff);\r\n}\r\nstatic int dib80xx_tuner_sleep(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nreturn state->dib8000_ops.set_gpio(fe, 0, 0, onoff);\r\n}\r\nstatic int dib807x_set_param_override(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nu16 offset = dib0070_wbd_offset(fe);\r\nu8 band = BAND_OF_FREQUENCY(p->frequency/1000);\r\nswitch (band) {\r\ncase BAND_VHF:\r\noffset += 750;\r\nbreak;\r\ncase BAND_UHF:\r\ndefault:\r\noffset += 250; break;\r\n}\r\ndeb_info("WBD for DiB8000: %d\n", offset);\r\nstate->dib8000_ops.set_wbd_ref(fe, offset);\r\nreturn state->set_param_save(fe);\r\n}\r\nstatic int dib807x_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *st = adap->priv;\r\nstruct i2c_adapter *tun_i2c = st->dib8000_ops.get_i2c_master(adap->fe_adap[0].fe,\r\nDIBX000_I2C_INTERFACE_TUNER, 1);\r\nif (adap->id == 0) {\r\nif (dvb_attach(dib0070_attach, adap->fe_adap[0].fe, tun_i2c,\r\n&dib807x_dib0070_config[0]) == NULL)\r\nreturn -ENODEV;\r\n} else {\r\nif (dvb_attach(dib0070_attach, adap->fe_adap[0].fe, tun_i2c,\r\n&dib807x_dib0070_config[1]) == NULL)\r\nreturn -ENODEV;\r\n}\r\nst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\r\nadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib807x_set_param_override;\r\nreturn 0;\r\n}\r\nstatic int stk80xx_pid_filter(struct dvb_usb_adapter *adapter, int index,\r\nu16 pid, int onoff)\r\n{\r\nstruct dib0700_adapter_state *state = adapter->priv;\r\nreturn state->dib8000_ops.pid_filter(adapter->fe_adap[0].fe, index, pid, onoff);\r\n}\r\nstatic int stk80xx_pid_filter_ctrl(struct dvb_usb_adapter *adapter,\r\nint onoff)\r\n{\r\nstruct dib0700_adapter_state *state = adapter->priv;\r\nreturn state->dib8000_ops.pid_filter_ctrl(adapter->fe_adap[0].fe, onoff);\r\n}\r\nstatic int stk807x_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (!dvb_attach(dib8000_attach, &state->dib8000_ops))\r\nreturn -ENODEV;\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\r\ndib0700_ctrl_clock(adap->dev, 72, 1);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\r\nstate->dib8000_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 18,\r\n0x80, 0);\r\nadap->fe_adap[0].fe = state->dib8000_ops.init(&adap->dev->i2c_adap, 0x80,\r\n&dib807x_dib8000_config[0]);\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int stk807xpvr_frontend_attach0(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (!dvb_attach(dib8000_attach, &state->dib8000_ops))\r\nreturn -ENODEV;\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0);\r\nmsleep(30);\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\r\nmsleep(500);\r\ndib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\r\ndib0700_ctrl_clock(adap->dev, 72, 1);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\r\nstate->dib8000_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 0x22, 0x80, 0);\r\nadap->fe_adap[0].fe = state->dib8000_ops.init(&adap->dev->i2c_adap, 0x80,\r\n&dib807x_dib8000_config[0]);\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int stk807xpvr_frontend_attach1(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (!dvb_attach(dib8000_attach, &state->dib8000_ops))\r\nreturn -ENODEV;\r\nstate->dib8000_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 0x12, 0x82, 0);\r\nadap->fe_adap[0].fe = state->dib8000_ops.init(&adap->dev->i2c_adap, 0x82,\r\n&dib807x_dib8000_config[1]);\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int dib8090_get_adc_power(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nreturn state->dib8000_ops.get_adc_power(fe, 1);\r\n}\r\nstatic void dib8090_agc_control(struct dvb_frontend *fe, u8 restart)\r\n{\r\ndeb_info("AGC control callback: %i\n", restart);\r\ndib0090_dcc_freq(fe, restart);\r\nif (restart == 0)\r\ndib0090_set_dc_servo(fe, 1);\r\n}\r\nstatic u8 dib8090_compute_pll_parameters(struct dvb_frontend *fe)\r\n{\r\nu8 optimal_pll_ratio = 20;\r\nu32 freq_adc, ratio, rest, max = 0;\r\nu8 pll_ratio;\r\nfor (pll_ratio = 17; pll_ratio <= 20; pll_ratio++) {\r\nfreq_adc = 12 * pll_ratio * (1 << 8) / 16;\r\nratio = ((fe->dtv_property_cache.frequency / 1000) * (1 << 8) / 1000) / freq_adc;\r\nrest = ((fe->dtv_property_cache.frequency / 1000) * (1 << 8) / 1000) - ratio * freq_adc;\r\nif (rest > freq_adc / 2)\r\nrest = freq_adc - rest;\r\ndeb_info("PLL ratio=%i rest=%i\n", pll_ratio, rest);\r\nif ((rest > max) && (rest > 717)) {\r\noptimal_pll_ratio = pll_ratio;\r\nmax = rest;\r\n}\r\n}\r\ndeb_info("optimal PLL ratio=%i\n", optimal_pll_ratio);\r\nreturn optimal_pll_ratio;\r\n}\r\nstatic int dib8096_set_param_override(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nu8 pll_ratio, band = BAND_OF_FREQUENCY(fe->dtv_property_cache.frequency / 1000);\r\nu16 target, ltgain, rf_gain_limit;\r\nu32 timf;\r\nint ret = 0;\r\nenum frontend_tune_state tune_state = CT_SHUTDOWN;\r\nswitch (band) {\r\ndefault:\r\ndeb_info("Warning : Rf frequency (%iHz) is not in the supported range, using VHF switch ", fe->dtv_property_cache.frequency);\r\ncase BAND_VHF:\r\nstate->dib8000_ops.set_gpio(fe, 3, 0, 1);\r\nbreak;\r\ncase BAND_UHF:\r\nstate->dib8000_ops.set_gpio(fe, 3, 0, 0);\r\nbreak;\r\n}\r\nret = state->set_param_save(fe);\r\nif (ret < 0)\r\nreturn ret;\r\nif (fe->dtv_property_cache.bandwidth_hz != 6000000) {\r\ndeb_info("only 6MHz bandwidth is supported\n");\r\nreturn -EINVAL;\r\n}\r\nstate->dib8000_ops.update_pll(fe, &dib8090_pll_config_12mhz, fe->dtv_property_cache.bandwidth_hz / 1000, 0);\r\npll_ratio = dib8090_compute_pll_parameters(fe);\r\nif (pll_ratio == 17)\r\ntimf = 21387946;\r\nelse if (pll_ratio == 18)\r\ntimf = 20199727;\r\nelse if (pll_ratio == 19)\r\ntimf = 19136583;\r\nelse\r\ntimf = 18179756;\r\nstate->dib8000_ops.update_pll(fe, &dib8090_pll_config_12mhz, fe->dtv_property_cache.bandwidth_hz / 1000, pll_ratio);\r\nstate->dib8000_ops.ctrl_timf(fe, DEMOD_TIMF_SET, timf);\r\nif (band != BAND_CBAND) {\r\ntarget = (dib0090_get_wbd_target(fe) * 8 * 18 / 33 + 1) / 2;\r\nstate->dib8000_ops.set_wbd_ref(fe, target);\r\n}\r\nif (band == BAND_CBAND) {\r\ndeb_info("tuning in CBAND - soft-AGC startup\n");\r\ndib0090_set_tune_state(fe, CT_AGC_START);\r\ndo {\r\nret = dib0090_gain_control(fe);\r\nmsleep(ret);\r\ntune_state = dib0090_get_tune_state(fe);\r\nif (tune_state == CT_AGC_STEP_0)\r\nstate->dib8000_ops.set_gpio(fe, 6, 0, 1);\r\nelse if (tune_state == CT_AGC_STEP_1) {\r\ndib0090_get_current_gain(fe, NULL, NULL, &rf_gain_limit, &ltgain);\r\nif (rf_gain_limit < 2000)\r\nstate->dib8000_ops.set_gpio(fe, 6, 0, 0);\r\n}\r\n} while (tune_state < CT_AGC_STOP);\r\ndeb_info("switching to PWM AGC\n");\r\ndib0090_pwm_gain_reset(fe);\r\nstate->dib8000_ops.pwm_agc_reset(fe);\r\nstate->dib8000_ops.set_tune_state(fe, CT_DEMOD_START);\r\n} else {\r\ndeb_info("not tuning in CBAND - standard AGC startup\n");\r\ndib0090_pwm_gain_reset(fe);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib809x_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *st = adap->priv;\r\nstruct i2c_adapter *tun_i2c = st->dib8000_ops.get_i2c_master(adap->fe_adap[0].fe, DIBX000_I2C_INTERFACE_TUNER, 1);\r\nif (dvb_attach(dib0090_register, adap->fe_adap[0].fe, tun_i2c, &dib809x_dib0090_config) == NULL)\r\nreturn -ENODEV;\r\nst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\r\nadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib8096_set_param_override;\r\nreturn 0;\r\n}\r\nstatic int stk809x_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (!dvb_attach(dib8000_attach, &state->dib8000_ops))\r\nreturn -ENODEV;\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\r\ndib0700_ctrl_clock(adap->dev, 72, 1);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\r\nstate->dib8000_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 18, 0x80, 0);\r\nadap->fe_adap[0].fe = state->dib8000_ops.init(&adap->dev->i2c_adap, 0x80, &dib809x_dib8000_config[0]);\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int nim8096md_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *st = adap->priv;\r\nstruct i2c_adapter *tun_i2c;\r\nstruct dvb_frontend *fe_slave = st->dib8000_ops.get_slave_frontend(adap->fe_adap[0].fe, 1);\r\nif (fe_slave) {\r\ntun_i2c = st->dib8000_ops.get_i2c_master(fe_slave, DIBX000_I2C_INTERFACE_TUNER, 1);\r\nif (dvb_attach(dib0090_register, fe_slave, tun_i2c, &dib809x_dib0090_config) == NULL)\r\nreturn -ENODEV;\r\nfe_slave->dvb = adap->fe_adap[0].fe->dvb;\r\nfe_slave->ops.tuner_ops.set_params = dib8096_set_param_override;\r\n}\r\ntun_i2c = st->dib8000_ops.get_i2c_master(adap->fe_adap[0].fe, DIBX000_I2C_INTERFACE_TUNER, 1);\r\nif (dvb_attach(dib0090_register, adap->fe_adap[0].fe, tun_i2c, &dib809x_dib0090_config) == NULL)\r\nreturn -ENODEV;\r\nst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\r\nadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib8096_set_param_override;\r\nreturn 0;\r\n}\r\nstatic int nim8096md_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_frontend *fe_slave;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (!dvb_attach(dib8000_attach, &state->dib8000_ops))\r\nreturn -ENODEV;\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\r\nmsleep(1000);\r\ndib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\r\ndib0700_ctrl_clock(adap->dev, 72, 1);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\r\nstate->dib8000_ops.i2c_enumeration(&adap->dev->i2c_adap, 2, 18, 0x80, 0);\r\nadap->fe_adap[0].fe = state->dib8000_ops.init(&adap->dev->i2c_adap, 0x80, &dib809x_dib8000_config[0]);\r\nif (adap->fe_adap[0].fe == NULL)\r\nreturn -ENODEV;\r\nif (!dvb_attach(dib8000_attach, &state->dib8000_ops))\r\nreturn -ENODEV;\r\nfe_slave = state->dib8000_ops.init(&adap->dev->i2c_adap, 0x82, &dib809x_dib8000_config[1]);\r\nstate->dib8000_ops.set_slave_frontend(adap->fe_adap[0].fe, fe_slave);\r\nreturn fe_slave == NULL ? -ENODEV : 0;\r\n}\r\nstatic int dib8096p_get_best_sampling(struct dvb_frontend *fe, struct dibx090p_best_adc *adc)\r\n{\r\nu8 spur = 0, prediv = 0, loopdiv = 0, min_prediv = 1, max_prediv = 1;\r\nu16 xtal = 12000;\r\nu16 fcp_min = 1900;\r\nu16 fcp_max = 20000;\r\nu32 fmem_max = 140000;\r\nu32 fdem_min = 66000;\r\nu32 fcp = 0, fs = 0, fdem = 0, fmem = 0;\r\nu32 harmonic_id = 0;\r\nadc->timf = 0;\r\nadc->pll_loopdiv = loopdiv;\r\nadc->pll_prediv = prediv;\r\ndeb_info("bandwidth = %d", fe->dtv_property_cache.bandwidth_hz);\r\nwhile ((xtal / max_prediv) >= fcp_min)\r\nmax_prediv++;\r\nmax_prediv--;\r\nmin_prediv = max_prediv;\r\nwhile ((xtal / min_prediv) <= fcp_max) {\r\nmin_prediv--;\r\nif (min_prediv == 1)\r\nbreak;\r\n}\r\ndeb_info("MIN prediv = %d : MAX prediv = %d", min_prediv, max_prediv);\r\nmin_prediv = 1;\r\nfor (prediv = min_prediv; prediv < max_prediv; prediv++) {\r\nfcp = xtal / prediv;\r\nif (fcp > fcp_min && fcp < fcp_max) {\r\nfor (loopdiv = 1; loopdiv < 64; loopdiv++) {\r\nfmem = ((xtal/prediv) * loopdiv);\r\nfdem = fmem / 2;\r\nfs = fdem / 4;\r\nif ((fdem >= fdem_min) && (fmem <= fmem_max) && (fs >= fe->dtv_property_cache.bandwidth_hz / 1000)) {\r\nspur = 0;\r\nfor (harmonic_id = (fe->dtv_property_cache.frequency / (1000 * fs)); harmonic_id <= ((fe->dtv_property_cache.frequency / (1000 * fs)) + 1); harmonic_id++) {\r\nif (((fs * harmonic_id) >= (fe->dtv_property_cache.frequency / 1000 - (fe->dtv_property_cache.bandwidth_hz / 2000))) && ((fs * harmonic_id) <= (fe->dtv_property_cache.frequency / 1000 + (fe->dtv_property_cache.bandwidth_hz / 2000)))) {\r\nspur = 1;\r\nbreak;\r\n}\r\n}\r\nif (!spur) {\r\nadc->pll_loopdiv = loopdiv;\r\nadc->pll_prediv = prediv;\r\nadc->timf = (4260880253U / fdem) * (1 << 8);\r\nadc->timf += ((4260880253U % fdem) << 8) / fdem;\r\ndeb_info("RF %6d; BW %6d; Xtal %6d; Fmem %6d; Fdem %6d; Fs %6d; Prediv %2d; Loopdiv %2d; Timf %8d;", fe->dtv_property_cache.frequency, fe->dtv_property_cache.bandwidth_hz, xtal, fmem, fdem, fs, prediv, loopdiv, adc->timf);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nif (!spur)\r\nbreak;\r\n}\r\nif (adc->pll_loopdiv == 0 && adc->pll_prediv == 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int dib8096p_agc_startup(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nstruct dibx000_bandwidth_config pll;\r\nstruct dibx090p_best_adc adc;\r\nu16 target;\r\nint ret;\r\nret = state->set_param_save(fe);\r\nif (ret < 0)\r\nreturn ret;\r\nmemset(&pll, 0, sizeof(struct dibx000_bandwidth_config));\r\ndib0090_pwm_gain_reset(fe);\r\ntarget = (dib0090_get_wbd_target(fe) * 8 + 1) / 2;\r\nstate->dib8000_ops.set_wbd_ref(fe, target);\r\nif (dib8096p_get_best_sampling(fe, &adc) == 0) {\r\npll.pll_ratio = adc.pll_loopdiv;\r\npll.pll_prediv = adc.pll_prediv;\r\ndib0700_set_i2c_speed(adap->dev, 200);\r\nstate->dib8000_ops.update_pll(fe, &pll, fe->dtv_property_cache.bandwidth_hz / 1000, 0);\r\nstate->dib8000_ops.ctrl_timf(fe, DEMOD_TIMF_SET, adc.timf);\r\ndib0700_set_i2c_speed(adap->dev, 1000);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tfe8096p_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_state *st = adap->dev->priv;\r\nu32 fw_version;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (!dvb_attach(dib8000_attach, &state->dib8000_ops))\r\nreturn -ENODEV;\r\ndib0700_get_version(adap->dev, NULL, NULL, &fw_version, NULL);\r\nif (fw_version >= 0x10200)\r\nst->fw_use_new_i2c_api = 1;\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\r\ndib0700_ctrl_clock(adap->dev, 72, 1);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\r\nstate->dib8000_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 0x10, 0x80, 1);\r\nadap->fe_adap[0].fe = state->dib8000_ops.init(&adap->dev->i2c_adap,\r\n0x80, &tfe8096p_dib8000_config);\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int tfe8096p_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *st = adap->priv;\r\nstruct i2c_adapter *tun_i2c = st->dib8000_ops.get_i2c_tuner(adap->fe_adap[0].fe);\r\ntfe8096p_dib0090_config.reset = st->dib8000_ops.tuner_sleep;\r\ntfe8096p_dib0090_config.sleep = st->dib8000_ops.tuner_sleep;\r\ntfe8096p_dib0090_config.wbd = dib8096p_wbd_table;\r\nif (dvb_attach(dib0090_register, adap->fe_adap[0].fe, tun_i2c,\r\n&tfe8096p_dib0090_config) == NULL)\r\nreturn -ENODEV;\r\nst->dib8000_ops.set_gpio(adap->fe_adap[0].fe, 8, 0, 1);\r\nst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\r\nadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib8096p_agc_startup;\r\nreturn 0;\r\n}\r\nstatic int dib90x0_pid_filter(struct dvb_usb_adapter *adapter, int index, u16 pid, int onoff)\r\n{\r\nreturn dib9000_fw_pid_filter(adapter->fe_adap[0].fe, index, pid, onoff);\r\n}\r\nstatic int dib90x0_pid_filter_ctrl(struct dvb_usb_adapter *adapter, int onoff)\r\n{\r\nreturn dib9000_fw_pid_filter_ctrl(adapter->fe_adap[0].fe, onoff);\r\n}\r\nstatic int dib90x0_tuner_reset(struct dvb_frontend *fe, int onoff)\r\n{\r\nreturn dib9000_set_gpio(fe, 5, 0, !onoff);\r\n}\r\nstatic int dib90x0_tuner_sleep(struct dvb_frontend *fe, int onoff)\r\n{\r\nreturn dib9000_set_gpio(fe, 0, 0, onoff);\r\n}\r\nstatic int dib01x0_pmu_update(struct i2c_adapter *i2c, u16 *data, u8 len)\r\n{\r\nu8 wb[4] = { 0xc >> 8, 0xc & 0xff, 0, 0 };\r\nu8 rb[2];\r\nstruct i2c_msg msg[2] = {\r\n{.addr = 0x1e >> 1, .flags = 0, .buf = wb, .len = 2},\r\n{.addr = 0x1e >> 1, .flags = I2C_M_RD, .buf = rb, .len = 2},\r\n};\r\nu8 index_data;\r\ndibx000_i2c_set_speed(i2c, 250);\r\nif (i2c_transfer(i2c, msg, 2) != 2)\r\nreturn -EIO;\r\nswitch (rb[0] << 8 | rb[1]) {\r\ncase 0:\r\ndeb_info("Found DiB0170 rev1: This version of DiB0170 is not supported any longer.\n");\r\nreturn -EIO;\r\ncase 1:\r\ndeb_info("Found DiB0170 rev2");\r\nbreak;\r\ncase 2:\r\ndeb_info("Found DiB0190 rev2");\r\nbreak;\r\ndefault:\r\ndeb_info("DiB01x0 not found");\r\nreturn -EIO;\r\n}\r\nfor (index_data = 0; index_data < len; index_data += 2) {\r\nwb[2] = (data[index_data + 1] >> 8) & 0xff;\r\nwb[3] = (data[index_data + 1]) & 0xff;\r\nif (data[index_data] == 0) {\r\nwb[0] = (data[index_data] >> 8) & 0xff;\r\nwb[1] = (data[index_data]) & 0xff;\r\nmsg[0].len = 2;\r\nif (i2c_transfer(i2c, msg, 2) != 2)\r\nreturn -EIO;\r\nwb[2] |= rb[0];\r\nwb[3] |= rb[1] & ~(3 << 4);\r\n}\r\nwb[0] = (data[index_data] >> 8)&0xff;\r\nwb[1] = (data[index_data])&0xff;\r\nmsg[0].len = 4;\r\nif (i2c_transfer(i2c, &msg[0], 1) != 1)\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stk9090m_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nstruct dib0700_state *st = adap->dev->priv;\r\nu32 fw_version;\r\ndib0700_get_version(adap->dev, NULL, NULL, &fw_version, NULL);\r\nif (fw_version >= 0x10200)\r\nst->fw_use_new_i2c_api = 1;\r\ndib0700_set_i2c_speed(adap->dev, 340);\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\r\ndib0700_ctrl_clock(adap->dev, 72, 1);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\r\ndib9000_i2c_enumeration(&adap->dev->i2c_adap, 1, 0x10, 0x80);\r\nif (request_firmware(&state->frontend_firmware, "dib9090.fw", &adap->dev->udev->dev)) {\r\ndeb_info("%s: Upload failed. (file not found?)\n", __func__);\r\nreturn -ENODEV;\r\n} else {\r\ndeb_info("%s: firmware read %Zu bytes.\n", __func__, state->frontend_firmware->size);\r\n}\r\nstk9090m_config.microcode_B_fe_size = state->frontend_firmware->size;\r\nstk9090m_config.microcode_B_fe_buffer = state->frontend_firmware->data;\r\nadap->fe_adap[0].fe = dvb_attach(dib9000_attach, &adap->dev->i2c_adap, 0x80, &stk9090m_config);\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int dib9090_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nstruct i2c_adapter *i2c = dib9000_get_tuner_interface(adap->fe_adap[0].fe);\r\nu16 data_dib190[10] = {\r\n1, 0x1374,\r\n2, 0x01a2,\r\n7, 0x0020,\r\n0, 0x00ef,\r\n8, 0x0486,\r\n};\r\nif (dvb_attach(dib0090_fw_register, adap->fe_adap[0].fe, i2c, &dib9090_dib0090_config) == NULL)\r\nreturn -ENODEV;\r\ni2c = dib9000_get_i2c_master(adap->fe_adap[0].fe, DIBX000_I2C_INTERFACE_GPIO_1_2, 0);\r\nif (dib01x0_pmu_update(i2c, data_dib190, 10) != 0)\r\nreturn -ENODEV;\r\ndib0700_set_i2c_speed(adap->dev, 1500);\r\nif (dib9000_firmware_post_pll_init(adap->fe_adap[0].fe) < 0)\r\nreturn -ENODEV;\r\nrelease_firmware(state->frontend_firmware);\r\nreturn 0;\r\n}\r\nstatic int nim9090md_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nstruct dib0700_state *st = adap->dev->priv;\r\nstruct i2c_adapter *i2c;\r\nstruct dvb_frontend *fe_slave;\r\nu32 fw_version;\r\ndib0700_get_version(adap->dev, NULL, NULL, &fw_version, NULL);\r\nif (fw_version >= 0x10200)\r\nst->fw_use_new_i2c_api = 1;\r\ndib0700_set_i2c_speed(adap->dev, 340);\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\r\ndib0700_ctrl_clock(adap->dev, 72, 1);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\r\nif (request_firmware(&state->frontend_firmware, "dib9090.fw", &adap->dev->udev->dev)) {\r\ndeb_info("%s: Upload failed. (file not found?)\n", __func__);\r\nreturn -EIO;\r\n} else {\r\ndeb_info("%s: firmware read %Zu bytes.\n", __func__, state->frontend_firmware->size);\r\n}\r\nnim9090md_config[0].microcode_B_fe_size = state->frontend_firmware->size;\r\nnim9090md_config[0].microcode_B_fe_buffer = state->frontend_firmware->data;\r\nnim9090md_config[1].microcode_B_fe_size = state->frontend_firmware->size;\r\nnim9090md_config[1].microcode_B_fe_buffer = state->frontend_firmware->data;\r\ndib9000_i2c_enumeration(&adap->dev->i2c_adap, 1, 0x20, 0x80);\r\nadap->fe_adap[0].fe = dvb_attach(dib9000_attach, &adap->dev->i2c_adap, 0x80, &nim9090md_config[0]);\r\nif (adap->fe_adap[0].fe == NULL)\r\nreturn -ENODEV;\r\ni2c = dib9000_get_i2c_master(adap->fe_adap[0].fe, DIBX000_I2C_INTERFACE_GPIO_3_4, 0);\r\ndib9000_i2c_enumeration(i2c, 1, 0x12, 0x82);\r\nfe_slave = dvb_attach(dib9000_attach, i2c, 0x82, &nim9090md_config[1]);\r\ndib9000_set_slave_frontend(adap->fe_adap[0].fe, fe_slave);\r\nreturn fe_slave == NULL ? -ENODEV : 0;\r\n}\r\nstatic int nim9090md_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nstruct i2c_adapter *i2c;\r\nstruct dvb_frontend *fe_slave;\r\nu16 data_dib190[10] = {\r\n1, 0x5374,\r\n2, 0x01ae,\r\n7, 0x0020,\r\n0, 0x00ef,\r\n8, 0x0406,\r\n};\r\ni2c = dib9000_get_tuner_interface(adap->fe_adap[0].fe);\r\nif (dvb_attach(dib0090_fw_register, adap->fe_adap[0].fe, i2c, &nim9090md_dib0090_config[0]) == NULL)\r\nreturn -ENODEV;\r\ni2c = dib9000_get_i2c_master(adap->fe_adap[0].fe, DIBX000_I2C_INTERFACE_GPIO_1_2, 0);\r\nif (dib01x0_pmu_update(i2c, data_dib190, 10) < 0)\r\nreturn -ENODEV;\r\ndib0700_set_i2c_speed(adap->dev, 1500);\r\nif (dib9000_firmware_post_pll_init(adap->fe_adap[0].fe) < 0)\r\nreturn -ENODEV;\r\nfe_slave = dib9000_get_slave_frontend(adap->fe_adap[0].fe, 1);\r\nif (fe_slave != NULL) {\r\ni2c = dib9000_get_component_bus_interface(adap->fe_adap[0].fe);\r\ndib9000_set_i2c_adapter(fe_slave, i2c);\r\ni2c = dib9000_get_tuner_interface(fe_slave);\r\nif (dvb_attach(dib0090_fw_register, fe_slave, i2c, &nim9090md_dib0090_config[1]) == NULL)\r\nreturn -ENODEV;\r\nfe_slave->dvb = adap->fe_adap[0].fe->dvb;\r\ndib9000_fw_set_component_bus_speed(adap->fe_adap[0].fe, 1500);\r\nif (dib9000_firmware_post_pll_init(fe_slave) < 0)\r\nreturn -ENODEV;\r\n}\r\nrelease_firmware(state->frontend_firmware);\r\nreturn 0;\r\n}\r\nstatic int dib7090p_get_best_sampling(struct dvb_frontend *fe , struct dibx090p_best_adc *adc)\r\n{\r\nu8 spur = 0, prediv = 0, loopdiv = 0, min_prediv = 1, max_prediv = 1;\r\nu16 xtal = 12000;\r\nu32 fcp_min = 1900;\r\nu32 fcp_max = 20000;\r\nu32 fdem_max = 76000;\r\nu32 fdem_min = 69500;\r\nu32 fcp = 0, fs = 0, fdem = 0;\r\nu32 harmonic_id = 0;\r\nadc->pll_loopdiv = loopdiv;\r\nadc->pll_prediv = prediv;\r\nadc->timf = 0;\r\ndeb_info("bandwidth = %d fdem_min =%d", fe->dtv_property_cache.bandwidth_hz, fdem_min);\r\nwhile ((xtal/max_prediv) >= fcp_min)\r\nmax_prediv++;\r\nmax_prediv--;\r\nmin_prediv = max_prediv;\r\nwhile ((xtal/min_prediv) <= fcp_max) {\r\nmin_prediv--;\r\nif (min_prediv == 1)\r\nbreak;\r\n}\r\ndeb_info("MIN prediv = %d : MAX prediv = %d", min_prediv, max_prediv);\r\nmin_prediv = 2;\r\nfor (prediv = min_prediv ; prediv < max_prediv; prediv++) {\r\nfcp = xtal / prediv;\r\nif (fcp > fcp_min && fcp < fcp_max) {\r\nfor (loopdiv = 1 ; loopdiv < 64 ; loopdiv++) {\r\nfdem = ((xtal/prediv) * loopdiv);\r\nfs = fdem / 4;\r\nif ((fdem >= fdem_min) && (fdem <= fdem_max) && (fs >= fe->dtv_property_cache.bandwidth_hz/1000)) {\r\nspur = 0;\r\nfor (harmonic_id = (fe->dtv_property_cache.frequency / (1000*fs)) ; harmonic_id <= ((fe->dtv_property_cache.frequency / (1000*fs))+1) ; harmonic_id++) {\r\nif (((fs*harmonic_id) >= ((fe->dtv_property_cache.frequency/1000) - (fe->dtv_property_cache.bandwidth_hz/2000))) && ((fs*harmonic_id) <= ((fe->dtv_property_cache.frequency/1000) + (fe->dtv_property_cache.bandwidth_hz/2000)))) {\r\nspur = 1;\r\nbreak;\r\n}\r\n}\r\nif (!spur) {\r\nadc->pll_loopdiv = loopdiv;\r\nadc->pll_prediv = prediv;\r\nadc->timf = 2396745143UL/fdem*(1 << 9);\r\nadc->timf += ((2396745143UL%fdem) << 9)/fdem;\r\ndeb_info("loopdiv=%i prediv=%i timf=%i", loopdiv, prediv, adc->timf);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nif (!spur)\r\nbreak;\r\n}\r\nif (adc->pll_loopdiv == 0 && adc->pll_prediv == 0)\r\nreturn -EINVAL;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int dib7090_agc_startup(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nstruct dibx000_bandwidth_config pll;\r\nu16 target;\r\nstruct dibx090p_best_adc adc;\r\nint ret;\r\nret = state->set_param_save(fe);\r\nif (ret < 0)\r\nreturn ret;\r\nmemset(&pll, 0, sizeof(struct dibx000_bandwidth_config));\r\ndib0090_pwm_gain_reset(fe);\r\ntarget = (dib0090_get_wbd_target(fe) * 8 + 1) / 2;\r\nstate->dib7000p_ops.set_wbd_ref(fe, target);\r\nif (dib7090p_get_best_sampling(fe, &adc) == 0) {\r\npll.pll_ratio = adc.pll_loopdiv;\r\npll.pll_prediv = adc.pll_prediv;\r\nstate->dib7000p_ops.update_pll(fe, &pll);\r\nstate->dib7000p_ops.ctrl_timf(fe, DEMOD_TIMF_SET, adc.timf);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib7090_agc_restart(struct dvb_frontend *fe, u8 restart)\r\n{\r\ndeb_info("AGC restart callback: %d", restart);\r\nif (restart == 0)\r\ndib0090_set_dc_servo(fe, 1);\r\nreturn 0;\r\n}\r\nstatic int tfe7790p_update_lna(struct dvb_frontend *fe, u16 agc_global)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\ndeb_info("update LNA: agc global=%i", agc_global);\r\nif (agc_global < 25000) {\r\nstate->dib7000p_ops.set_gpio(fe, 8, 0, 0);\r\nstate->dib7000p_ops.set_agc1_min(fe, 0);\r\n} else {\r\nstate->dib7000p_ops.set_gpio(fe, 8, 0, 1);\r\nstate->dib7000p_ops.set_agc1_min(fe, 32768);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tfe7090p_pvr_update_lna(struct dvb_frontend *fe, u16 agc_global)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\ndeb_info("TFE7090P-PVR update LNA: agc global=%i", agc_global);\r\nif (agc_global < 25000) {\r\nstate->dib7000p_ops.set_gpio(fe, 5, 0, 0);\r\nstate->dib7000p_ops.set_agc1_min(fe, 0);\r\n} else {\r\nstate->dib7000p_ops.set_gpio(fe, 5, 0, 1);\r\nstate->dib7000p_ops.set_agc1_min(fe, 32768);\r\n}\r\nreturn 0;\r\n}\r\nstatic int nim7090_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\r\nreturn -ENODEV;\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\r\nif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 0x10, &nim7090_dib7000p_config) != 0) {\r\nerr("%s: state->dib7000p_ops.i2c_enumeration failed. Cannot continue\n", __func__);\r\ndvb_detach(&state->dib7000p_ops);\r\nreturn -ENODEV;\r\n}\r\nadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x80, &nim7090_dib7000p_config);\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int nim7090_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *st = adap->priv;\r\nstruct i2c_adapter *tun_i2c = st->dib7000p_ops.get_i2c_tuner(adap->fe_adap[0].fe);\r\nnim7090_dib0090_config.reset = st->dib7000p_ops.tuner_sleep,\r\nnim7090_dib0090_config.sleep = st->dib7000p_ops.tuner_sleep,\r\nnim7090_dib0090_config.get_adc_power = st->dib7000p_ops.get_adc_power;\r\nif (dvb_attach(dib0090_register, adap->fe_adap[0].fe, tun_i2c, &nim7090_dib0090_config) == NULL)\r\nreturn -ENODEV;\r\nst->dib7000p_ops.set_gpio(adap->fe_adap[0].fe, 8, 0, 1);\r\nst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\r\nadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib7090_agc_startup;\r\nreturn 0;\r\n}\r\nstatic int tfe7090pvr_frontend0_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_state *st = adap->dev->priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\r\nreturn -ENODEV;\r\nst->disable_streaming_master_mode = 1;\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\r\nif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 0x20, &tfe7090pvr_dib7000p_config[0]) != 0) {\r\nerr("%s: state->dib7000p_ops.i2c_enumeration failed. Cannot continue\n", __func__);\r\ndvb_detach(&state->dib7000p_ops);\r\nreturn -ENODEV;\r\n}\r\ndib0700_set_i2c_speed(adap->dev, 340);\r\nadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x90, &tfe7090pvr_dib7000p_config[0]);\r\nif (adap->fe_adap[0].fe == NULL)\r\nreturn -ENODEV;\r\nstate->dib7000p_ops.slave_reset(adap->fe_adap[0].fe);\r\nreturn 0;\r\n}\r\nstatic int tfe7090pvr_frontend1_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct i2c_adapter *i2c;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (adap->dev->adapter[0].fe_adap[0].fe == NULL) {\r\nerr("the master dib7090 has to be initialized first");\r\nreturn -ENODEV;\r\n}\r\nif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\r\nreturn -ENODEV;\r\ni2c = state->dib7000p_ops.get_i2c_master(adap->dev->adapter[0].fe_adap[0].fe, DIBX000_I2C_INTERFACE_GPIO_6_7, 1);\r\nif (state->dib7000p_ops.i2c_enumeration(i2c, 1, 0x10, &tfe7090pvr_dib7000p_config[1]) != 0) {\r\nerr("%s: state->dib7000p_ops.i2c_enumeration failed. Cannot continue\n", __func__);\r\ndvb_detach(&state->dib7000p_ops);\r\nreturn -ENODEV;\r\n}\r\nadap->fe_adap[0].fe = state->dib7000p_ops.init(i2c, 0x92, &tfe7090pvr_dib7000p_config[1]);\r\ndib0700_set_i2c_speed(adap->dev, 200);\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int tfe7090pvr_tuner0_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *st = adap->priv;\r\nstruct i2c_adapter *tun_i2c = st->dib7000p_ops.get_i2c_tuner(adap->fe_adap[0].fe);\r\ntfe7090pvr_dib0090_config[0].reset = st->dib7000p_ops.tuner_sleep;\r\ntfe7090pvr_dib0090_config[0].sleep = st->dib7000p_ops.tuner_sleep;\r\ntfe7090pvr_dib0090_config[0].get_adc_power = st->dib7000p_ops.get_adc_power;\r\nif (dvb_attach(dib0090_register, adap->fe_adap[0].fe, tun_i2c, &tfe7090pvr_dib0090_config[0]) == NULL)\r\nreturn -ENODEV;\r\nst->dib7000p_ops.set_gpio(adap->fe_adap[0].fe, 8, 0, 1);\r\nst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\r\nadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib7090_agc_startup;\r\nreturn 0;\r\n}\r\nstatic int tfe7090pvr_tuner1_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *st = adap->priv;\r\nstruct i2c_adapter *tun_i2c = st->dib7000p_ops.get_i2c_tuner(adap->fe_adap[0].fe);\r\ntfe7090pvr_dib0090_config[1].reset = st->dib7000p_ops.tuner_sleep;\r\ntfe7090pvr_dib0090_config[1].sleep = st->dib7000p_ops.tuner_sleep;\r\ntfe7090pvr_dib0090_config[1].get_adc_power = st->dib7000p_ops.get_adc_power;\r\nif (dvb_attach(dib0090_register, adap->fe_adap[0].fe, tun_i2c, &tfe7090pvr_dib0090_config[1]) == NULL)\r\nreturn -ENODEV;\r\nst->dib7000p_ops.set_gpio(adap->fe_adap[0].fe, 8, 0, 1);\r\nst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\r\nadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib7090_agc_startup;\r\nreturn 0;\r\n}\r\nstatic int tfe7790p_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_state *st = adap->dev->priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\r\nreturn -ENODEV;\r\nst->disable_streaming_master_mode = 1;\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\r\nmsleep(20);\r\ndib0700_ctrl_clock(adap->dev, 72, 1);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\r\nmsleep(20);\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\r\nif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap,\r\n1, 0x10, &tfe7790p_dib7000p_config) != 0) {\r\nerr("%s: state->dib7000p_ops.i2c_enumeration failed. Cannot continue\n",\r\n__func__);\r\ndvb_detach(&state->dib7000p_ops);\r\nreturn -ENODEV;\r\n}\r\nadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap,\r\n0x80, &tfe7790p_dib7000p_config);\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int tfe7790p_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *st = adap->priv;\r\nstruct i2c_adapter *tun_i2c =\r\nst->dib7000p_ops.get_i2c_tuner(adap->fe_adap[0].fe);\r\ntfe7790p_dib0090_config.reset = st->dib7000p_ops.tuner_sleep;\r\ntfe7790p_dib0090_config.sleep = st->dib7000p_ops.tuner_sleep;\r\ntfe7790p_dib0090_config.get_adc_power = st->dib7000p_ops.get_adc_power;\r\nif (dvb_attach(dib0090_register, adap->fe_adap[0].fe, tun_i2c,\r\n&tfe7790p_dib0090_config) == NULL)\r\nreturn -ENODEV;\r\nst->dib7000p_ops.set_gpio(adap->fe_adap[0].fe, 8, 0, 1);\r\nst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\r\nadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib7090_agc_startup;\r\nreturn 0;\r\n}\r\nstatic void stk7070pd_init(struct dvb_usb_device *dev)\r\n{\r\ndib0700_set_gpio(dev, GPIO6, GPIO_OUT, 1);\r\nmsleep(10);\r\ndib0700_set_gpio(dev, GPIO9, GPIO_OUT, 1);\r\ndib0700_set_gpio(dev, GPIO4, GPIO_OUT, 1);\r\ndib0700_set_gpio(dev, GPIO7, GPIO_OUT, 1);\r\ndib0700_set_gpio(dev, GPIO10, GPIO_OUT, 0);\r\ndib0700_ctrl_clock(dev, 72, 1);\r\nmsleep(10);\r\ndib0700_set_gpio(dev, GPIO10, GPIO_OUT, 1);\r\n}\r\nstatic int stk7070pd_frontend_attach0(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\r\nreturn -ENODEV;\r\nstk7070pd_init(adap->dev);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\r\nif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 2, 18,\r\nstk7070pd_dib7000p_config) != 0) {\r\nerr("%s: state->dib7000p_ops.i2c_enumeration failed. Cannot continue\n",\r\n__func__);\r\ndvb_detach(&state->dib7000p_ops);\r\nreturn -ENODEV;\r\n}\r\nadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x80, &stk7070pd_dib7000p_config[0]);\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int stk7070pd_frontend_attach1(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\r\nreturn -ENODEV;\r\nadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x82, &stk7070pd_dib7000p_config[1]);\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int novatd_read_status_override(struct dvb_frontend *fe,\r\nenum fe_status *stat)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dvb_usb_device *dev = adap->dev;\r\nstruct dib0700_state *state = dev->priv;\r\nint ret;\r\nret = state->read_status(fe, stat);\r\nif (!ret)\r\ndib0700_set_gpio(dev, adap->id == 0 ? GPIO1 : GPIO0, GPIO_OUT,\r\n!!(*stat & FE_HAS_LOCK));\r\nreturn ret;\r\n}\r\nstatic int novatd_sleep_override(struct dvb_frontend* fe)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dvb_usb_device *dev = adap->dev;\r\nstruct dib0700_state *state = dev->priv;\r\ndib0700_set_gpio(dev, adap->id == 0 ? GPIO1 : GPIO0, GPIO_OUT, 0);\r\nreturn state->sleep(fe);\r\n}\r\nstatic int novatd_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *dev = adap->dev;\r\nstruct dib0700_state *st = dev->priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\r\nreturn -ENODEV;\r\nif (adap->id == 0) {\r\nstk7070pd_init(dev);\r\ndib0700_set_gpio(dev, GPIO0, GPIO_OUT, 0);\r\ndib0700_set_gpio(dev, GPIO1, GPIO_OUT, 0);\r\ndib0700_set_gpio(dev, GPIO2, GPIO_OUT, 1);\r\nif (state->dib7000p_ops.i2c_enumeration(&dev->i2c_adap, 2, 18,\r\nstk7070pd_dib7000p_config) != 0) {\r\nerr("%s: state->dib7000p_ops.i2c_enumeration failed. Cannot continue\n",\r\n__func__);\r\ndvb_detach(&state->dib7000p_ops);\r\nreturn -ENODEV;\r\n}\r\n}\r\nadap->fe_adap[0].fe = state->dib7000p_ops.init(&dev->i2c_adap,\r\nadap->id == 0 ? 0x80 : 0x82,\r\n&stk7070pd_dib7000p_config[adap->id]);\r\nif (adap->fe_adap[0].fe == NULL)\r\nreturn -ENODEV;\r\nst->read_status = adap->fe_adap[0].fe->ops.read_status;\r\nadap->fe_adap[0].fe->ops.read_status = novatd_read_status_override;\r\nst->sleep = adap->fe_adap[0].fe->ops.sleep;\r\nadap->fe_adap[0].fe->ops.sleep = novatd_sleep_override;\r\nreturn 0;\r\n}\r\nstatic int s5h1411_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_state *st = adap->dev->priv;\r\nst->fw_use_new_i2c_api = 1;\r\nst->disable_streaming_master_mode = 1;\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 0);\r\ndib0700_set_gpio(adap->dev, GPIO3, GPIO_OUT, 0);\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\r\nmsleep(400);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\r\nmsleep(60);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\r\nmsleep(30);\r\ndib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO2, GPIO_OUT, 0);\r\nmsleep(30);\r\ndib0700_set_gpio(adap->dev, GPIO2, GPIO_OUT, 1);\r\nadap->fe_adap[0].fe = dvb_attach(s5h1411_attach, &pinnacle_801e_config,\r\n&adap->dev->i2c_adap);\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int dib0700_xc5000_tuner_callback(void *priv, int component,\r\nint command, int arg)\r\n{\r\nstruct dvb_usb_adapter *adap = priv;\r\nif (command == XC5000_TUNER_RESET) {\r\ndib0700_set_gpio(adap->dev, GPIO1, GPIO_OUT, 0);\r\nmsleep(10);\r\ndib0700_set_gpio(adap->dev, GPIO1, GPIO_OUT, 1);\r\nmsleep(10);\r\n} else {\r\nerr("xc5000: unknown tuner callback command: %d\n", command);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xc5000_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nadap->fe_adap[0].fe->callback = dib0700_xc5000_tuner_callback;\r\nreturn dvb_attach(xc5000_attach, adap->fe_adap[0].fe, &adap->dev->i2c_adap,\r\n&s5h1411_xc5000_tunerconfig)\r\n== NULL ? -ENODEV : 0;\r\n}\r\nstatic int dib0700_xc4000_tuner_callback(void *priv, int component,\r\nint command, int arg)\r\n{\r\nstruct dvb_usb_adapter *adap = priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (command == XC4000_TUNER_RESET) {\r\nstate->dib7000p_ops.set_gpio(adap->fe_adap[0].fe, 8, 0, 0);\r\nmsleep(10);\r\nstate->dib7000p_ops.set_gpio(adap->fe_adap[0].fe, 8, 0, 1);\r\n} else {\r\nerr("xc4000: unknown tuner callback command: %d\n", command);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pctv340e_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_state *st = adap->dev->priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\r\nreturn -ENODEV;\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0);\r\nmsleep(50);\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\r\nmsleep(100);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\r\nmsleep(1);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO8, GPIO_OUT, 1);\r\ndib0700_set_gpio(adap->dev, GPIO2, GPIO_OUT, 1);\r\ndib0700_ctrl_clock(adap->dev, 72, 1);\r\nmsleep(500);\r\nif (state->dib7000p_ops.dib7000pc_detection(&adap->dev->i2c_adap) == 0) {\r\ndvb_detach(&state->dib7000p_ops);\r\nreturn -ENODEV;\r\n}\r\nadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x12,\r\n&pctv_340e_config);\r\nst->is_dib7000pc = 1;\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int xc4000_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct i2c_adapter *tun_i2c;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\ntun_i2c = state->dib7000p_ops.get_i2c_master(adap->fe_adap[0].fe,\r\nDIBX000_I2C_INTERFACE_TUNER, 1);\r\nif (tun_i2c == NULL) {\r\nprintk(KERN_ERR "Could not reach tuner i2c bus\n");\r\nreturn 0;\r\n}\r\nadap->fe_adap[0].fe->callback = dib0700_xc4000_tuner_callback;\r\nreturn dvb_attach(xc4000_attach, adap->fe_adap[0].fe, tun_i2c,\r\n&dib7000p_xc4000_tunerconfig)\r\n== NULL ? -ENODEV : 0;\r\n}\r\nstatic int lgdt3305_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_state *st = adap->dev->priv;\r\nst->fw_use_new_i2c_api = 1;\r\nst->disable_streaming_master_mode = 1;\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0);\r\nmsleep(30);\r\ndib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\r\nmsleep(30);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\r\nmsleep(30);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\r\nmsleep(30);\r\ndib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\r\nmsleep(30);\r\nadap->fe_adap[0].fe = dvb_attach(lgdt3305_attach,\r\n&hcw_lgdt3305_config,\r\n&adap->dev->i2c_adap);\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int mxl5007t_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nreturn dvb_attach(mxl5007t_attach, adap->fe_adap[0].fe,\r\n&adap->dev->i2c_adap, 0x60,\r\n&hcw_mxl5007t_config) == NULL ? -ENODEV : 0;\r\n}
