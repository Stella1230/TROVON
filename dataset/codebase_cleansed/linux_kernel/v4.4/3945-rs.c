static u8\r\nil3945_get_rate_idx_by_rssi(s32 rssi, enum ieee80211_band band)\r\n{\r\nu32 idx = 0;\r\nu32 table_size = 0;\r\nstruct il3945_tpt_entry *tpt_table = NULL;\r\nif (rssi < IL_MIN_RSSI_VAL || rssi > IL_MAX_RSSI_VAL)\r\nrssi = IL_MIN_RSSI_VAL;\r\nswitch (band) {\r\ncase IEEE80211_BAND_2GHZ:\r\ntpt_table = il3945_tpt_table_g;\r\ntable_size = ARRAY_SIZE(il3945_tpt_table_g);\r\nbreak;\r\ncase IEEE80211_BAND_5GHZ:\r\ntpt_table = il3945_tpt_table_a;\r\ntable_size = ARRAY_SIZE(il3945_tpt_table_a);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nwhile (idx < table_size && rssi < tpt_table[idx].min_rssi)\r\nidx++;\r\nidx = min(idx, table_size - 1);\r\nreturn tpt_table[idx].idx;\r\n}\r\nstatic void\r\nil3945_clear_win(struct il3945_rate_scale_data *win)\r\n{\r\nwin->data = 0;\r\nwin->success_counter = 0;\r\nwin->success_ratio = -1;\r\nwin->counter = 0;\r\nwin->average_tpt = IL_INVALID_VALUE;\r\nwin->stamp = 0;\r\n}\r\nstatic int\r\nil3945_rate_scale_flush_wins(struct il3945_rs_sta *rs_sta)\r\n{\r\nint unflushed = 0;\r\nint i;\r\nunsigned long flags;\r\nstruct il_priv *il __maybe_unused = rs_sta->il;\r\nfor (i = 0; i < RATE_COUNT_3945; i++) {\r\nif (!rs_sta->win[i].counter)\r\ncontinue;\r\nspin_lock_irqsave(&rs_sta->lock, flags);\r\nif (time_after(jiffies, rs_sta->win[i].stamp + RATE_WIN_FLUSH)) {\r\nD_RATE("flushing %d samples of rate " "idx %d\n",\r\nrs_sta->win[i].counter, i);\r\nil3945_clear_win(&rs_sta->win[i]);\r\n} else\r\nunflushed++;\r\nspin_unlock_irqrestore(&rs_sta->lock, flags);\r\n}\r\nreturn unflushed;\r\n}\r\nstatic void\r\nil3945_bg_rate_scale_flush(unsigned long data)\r\n{\r\nstruct il3945_rs_sta *rs_sta = (void *)data;\r\nstruct il_priv *il __maybe_unused = rs_sta->il;\r\nint unflushed = 0;\r\nunsigned long flags;\r\nu32 packet_count, duration, pps;\r\nD_RATE("enter\n");\r\nunflushed = il3945_rate_scale_flush_wins(rs_sta);\r\nspin_lock_irqsave(&rs_sta->lock, flags);\r\npacket_count = (rs_sta->tx_packets - rs_sta->last_tx_packets) + 1;\r\nrs_sta->last_tx_packets = rs_sta->tx_packets + 1;\r\nif (unflushed) {\r\nduration =\r\njiffies_to_msecs(jiffies - rs_sta->last_partial_flush);\r\nD_RATE("Tx'd %d packets in %dms\n", packet_count, duration);\r\nif (duration)\r\npps = (packet_count * 1000) / duration;\r\nelse\r\npps = 0;\r\nif (pps) {\r\nduration = (IL_AVERAGE_PACKETS * 1000) / pps;\r\nif (duration < RATE_FLUSH_MIN)\r\nduration = RATE_FLUSH_MIN;\r\nelse if (duration > RATE_FLUSH_MAX)\r\nduration = RATE_FLUSH_MAX;\r\n} else\r\nduration = RATE_FLUSH_MAX;\r\nrs_sta->flush_time = msecs_to_jiffies(duration);\r\nD_RATE("new flush period: %d msec ave %d\n", duration,\r\npacket_count);\r\nmod_timer(&rs_sta->rate_scale_flush,\r\njiffies + rs_sta->flush_time);\r\nrs_sta->last_partial_flush = jiffies;\r\n} else {\r\nrs_sta->flush_time = RATE_FLUSH;\r\nrs_sta->flush_pending = 0;\r\n}\r\nrs_sta->last_flush = jiffies;\r\nspin_unlock_irqrestore(&rs_sta->lock, flags);\r\nD_RATE("leave\n");\r\n}\r\nstatic void\r\nil3945_collect_tx_data(struct il3945_rs_sta *rs_sta,\r\nstruct il3945_rate_scale_data *win, int success,\r\nint retries, int idx)\r\n{\r\nunsigned long flags;\r\ns32 fail_count;\r\nstruct il_priv *il __maybe_unused = rs_sta->il;\r\nif (!retries) {\r\nD_RATE("leave: retries == 0 -- should be at least 1\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&rs_sta->lock, flags);\r\nwhile (retries > 0) {\r\nif (win->counter >= RATE_MAX_WINDOW) {\r\nwin->counter = RATE_MAX_WINDOW - 1;\r\nif (win->data & (1ULL << (RATE_MAX_WINDOW - 1))) {\r\nwin->data &= ~(1ULL << (RATE_MAX_WINDOW - 1));\r\nwin->success_counter--;\r\n}\r\n}\r\nwin->counter++;\r\nwin->data <<= 1;\r\nif (success > 0) {\r\nwin->success_counter++;\r\nwin->data |= 0x1;\r\nsuccess--;\r\n}\r\nretries--;\r\n}\r\nif (win->counter > 0)\r\nwin->success_ratio =\r\n128 * (100 * win->success_counter) / win->counter;\r\nelse\r\nwin->success_ratio = IL_INVALID_VALUE;\r\nfail_count = win->counter - win->success_counter;\r\nif (fail_count >= RATE_MIN_FAILURE_TH ||\r\nwin->success_counter >= RATE_MIN_SUCCESS_TH)\r\nwin->average_tpt =\r\n((win->success_ratio * rs_sta->expected_tpt[idx] +\r\n64) / 128);\r\nelse\r\nwin->average_tpt = IL_INVALID_VALUE;\r\nwin->stamp = jiffies;\r\nspin_unlock_irqrestore(&rs_sta->lock, flags);\r\n}\r\nvoid\r\nil3945_rs_rate_init(struct il_priv *il, struct ieee80211_sta *sta, u8 sta_id)\r\n{\r\nstruct ieee80211_hw *hw = il->hw;\r\nstruct ieee80211_conf *conf = &il->hw->conf;\r\nstruct il3945_sta_priv *psta;\r\nstruct il3945_rs_sta *rs_sta;\r\nstruct ieee80211_supported_band *sband;\r\nint i;\r\nD_INFO("enter\n");\r\nif (sta_id == il->hw_params.bcast_id)\r\ngoto out;\r\npsta = (struct il3945_sta_priv *)sta->drv_priv;\r\nrs_sta = &psta->rs_sta;\r\nsband = hw->wiphy->bands[conf->chandef.chan->band];\r\nrs_sta->il = il;\r\nrs_sta->start_rate = RATE_INVALID;\r\nrs_sta->expected_tpt = il3945_expected_tpt_b;\r\nrs_sta->last_partial_flush = jiffies;\r\nrs_sta->last_flush = jiffies;\r\nrs_sta->flush_time = RATE_FLUSH;\r\nrs_sta->last_tx_packets = 0;\r\nrs_sta->rate_scale_flush.data = (unsigned long)rs_sta;\r\nrs_sta->rate_scale_flush.function = il3945_bg_rate_scale_flush;\r\nfor (i = 0; i < RATE_COUNT_3945; i++)\r\nil3945_clear_win(&rs_sta->win[i]);\r\nfor (i = sband->n_bitrates - 1; i >= 0; i--) {\r\nif (sta->supp_rates[sband->band] & (1 << i)) {\r\nrs_sta->last_txrate_idx = i;\r\nbreak;\r\n}\r\n}\r\nil->_3945.sta_supp_rates = sta->supp_rates[sband->band];\r\nif (sband->band == IEEE80211_BAND_5GHZ) {\r\nrs_sta->last_txrate_idx += IL_FIRST_OFDM_RATE;\r\nil->_3945.sta_supp_rates <<= IL_FIRST_OFDM_RATE;\r\n}\r\nout:\r\nil->stations[sta_id].used &= ~IL_STA_UCODE_INPROGRESS;\r\nD_INFO("leave\n");\r\n}\r\nstatic void *\r\nil3945_rs_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)\r\n{\r\nreturn hw->priv;\r\n}\r\nstatic void\r\nil3945_rs_free(void *il)\r\n{\r\n}\r\nstatic void *\r\nil3945_rs_alloc_sta(void *il_priv, struct ieee80211_sta *sta, gfp_t gfp)\r\n{\r\nstruct il3945_rs_sta *rs_sta;\r\nstruct il3945_sta_priv *psta = (void *)sta->drv_priv;\r\nstruct il_priv *il __maybe_unused = il_priv;\r\nD_RATE("enter\n");\r\nrs_sta = &psta->rs_sta;\r\nspin_lock_init(&rs_sta->lock);\r\ninit_timer(&rs_sta->rate_scale_flush);\r\nD_RATE("leave\n");\r\nreturn rs_sta;\r\n}\r\nstatic void\r\nil3945_rs_free_sta(void *il_priv, struct ieee80211_sta *sta, void *il_sta)\r\n{\r\nstruct il3945_rs_sta *rs_sta = il_sta;\r\ndel_timer_sync(&rs_sta->rate_scale_flush);\r\n}\r\nstatic void\r\nil3945_rs_tx_status(void *il_rate, struct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta, void *il_sta,\r\nstruct sk_buff *skb)\r\n{\r\ns8 retries = 0, current_count;\r\nint scale_rate_idx, first_idx, last_idx;\r\nunsigned long flags;\r\nstruct il_priv *il = (struct il_priv *)il_rate;\r\nstruct il3945_rs_sta *rs_sta = il_sta;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nD_RATE("enter\n");\r\nretries = info->status.rates[0].count;\r\nif (retries > RATE_RETRY_TH)\r\nretries = RATE_RETRY_TH;\r\nfirst_idx = sband->bitrates[info->status.rates[0].idx].hw_value;\r\nif (first_idx < 0 || first_idx >= RATE_COUNT_3945) {\r\nD_RATE("leave: Rate out of bounds: %d\n", first_idx);\r\nreturn;\r\n}\r\nif (!il_sta) {\r\nD_RATE("leave: No STA il data to update!\n");\r\nreturn;\r\n}\r\nif (!rs_sta->il) {\r\nD_RATE("leave: STA il data uninitialized!\n");\r\nreturn;\r\n}\r\nrs_sta->tx_packets++;\r\nscale_rate_idx = first_idx;\r\nlast_idx = first_idx;\r\nwhile (retries > 1) {\r\nif ((retries - 1) < il->retry_rate) {\r\ncurrent_count = (retries - 1);\r\nlast_idx = scale_rate_idx;\r\n} else {\r\ncurrent_count = il->retry_rate;\r\nlast_idx = il3945_rs_next_rate(il, scale_rate_idx);\r\n}\r\nil3945_collect_tx_data(rs_sta, &rs_sta->win[scale_rate_idx], 0,\r\ncurrent_count, scale_rate_idx);\r\nD_RATE("Update rate %d for %d retries.\n", scale_rate_idx,\r\ncurrent_count);\r\nretries -= current_count;\r\nscale_rate_idx = last_idx;\r\n}\r\nD_RATE("Update rate %d with %s.\n", last_idx,\r\n(info->flags & IEEE80211_TX_STAT_ACK) ? "success" : "failure");\r\nil3945_collect_tx_data(rs_sta, &rs_sta->win[last_idx],\r\ninfo->flags & IEEE80211_TX_STAT_ACK, 1,\r\nlast_idx);\r\nspin_lock_irqsave(&rs_sta->lock, flags);\r\nif (!rs_sta->flush_pending &&\r\ntime_after(jiffies, rs_sta->last_flush + rs_sta->flush_time)) {\r\nrs_sta->last_partial_flush = jiffies;\r\nrs_sta->flush_pending = 1;\r\nmod_timer(&rs_sta->rate_scale_flush,\r\njiffies + rs_sta->flush_time);\r\n}\r\nspin_unlock_irqrestore(&rs_sta->lock, flags);\r\nD_RATE("leave\n");\r\n}\r\nstatic u16\r\nil3945_get_adjacent_rate(struct il3945_rs_sta *rs_sta, u8 idx, u16 rate_mask,\r\nenum ieee80211_band band)\r\n{\r\nu8 high = RATE_INVALID;\r\nu8 low = RATE_INVALID;\r\nstruct il_priv *il __maybe_unused = rs_sta->il;\r\nif (unlikely(band == IEEE80211_BAND_5GHZ)) {\r\nint i;\r\nu32 mask;\r\ni = idx - 1;\r\nfor (mask = (1 << i); i >= 0; i--, mask >>= 1) {\r\nif (rate_mask & mask) {\r\nlow = i;\r\nbreak;\r\n}\r\n}\r\ni = idx + 1;\r\nfor (mask = (1 << i); i < RATE_COUNT_3945; i++, mask <<= 1) {\r\nif (rate_mask & mask) {\r\nhigh = i;\r\nbreak;\r\n}\r\n}\r\nreturn (high << 8) | low;\r\n}\r\nlow = idx;\r\nwhile (low != RATE_INVALID) {\r\nif (rs_sta->tgg)\r\nlow = il3945_rates[low].prev_rs_tgg;\r\nelse\r\nlow = il3945_rates[low].prev_rs;\r\nif (low == RATE_INVALID)\r\nbreak;\r\nif (rate_mask & (1 << low))\r\nbreak;\r\nD_RATE("Skipping masked lower rate: %d\n", low);\r\n}\r\nhigh = idx;\r\nwhile (high != RATE_INVALID) {\r\nif (rs_sta->tgg)\r\nhigh = il3945_rates[high].next_rs_tgg;\r\nelse\r\nhigh = il3945_rates[high].next_rs;\r\nif (high == RATE_INVALID)\r\nbreak;\r\nif (rate_mask & (1 << high))\r\nbreak;\r\nD_RATE("Skipping masked higher rate: %d\n", high);\r\n}\r\nreturn (high << 8) | low;\r\n}\r\nstatic void\r\nil3945_rs_get_rate(void *il_r, struct ieee80211_sta *sta, void *il_sta,\r\nstruct ieee80211_tx_rate_control *txrc)\r\n{\r\nstruct ieee80211_supported_band *sband = txrc->sband;\r\nstruct sk_buff *skb = txrc->skb;\r\nu8 low = RATE_INVALID;\r\nu8 high = RATE_INVALID;\r\nu16 high_low;\r\nint idx;\r\nstruct il3945_rs_sta *rs_sta = il_sta;\r\nstruct il3945_rate_scale_data *win = NULL;\r\nint current_tpt = IL_INVALID_VALUE;\r\nint low_tpt = IL_INVALID_VALUE;\r\nint high_tpt = IL_INVALID_VALUE;\r\nu32 fail_count;\r\ns8 scale_action = 0;\r\nunsigned long flags;\r\nu16 rate_mask;\r\ns8 max_rate_idx = -1;\r\nstruct il_priv *il __maybe_unused = (struct il_priv *)il_r;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nD_RATE("enter\n");\r\nif (rs_sta && !rs_sta->il) {\r\nD_RATE("Rate scaling information not initialized yet.\n");\r\nil_sta = NULL;\r\n}\r\nif (rate_control_send_low(sta, il_sta, txrc))\r\nreturn;\r\nrate_mask = sta->supp_rates[sband->band];\r\nmax_rate_idx = txrc->max_rate_idx;\r\nif (sband->band == IEEE80211_BAND_5GHZ && max_rate_idx != -1)\r\nmax_rate_idx += IL_FIRST_OFDM_RATE;\r\nif (max_rate_idx < 0 || max_rate_idx >= RATE_COUNT)\r\nmax_rate_idx = -1;\r\nidx = min(rs_sta->last_txrate_idx & 0xffff, RATE_COUNT_3945 - 1);\r\nif (sband->band == IEEE80211_BAND_5GHZ)\r\nrate_mask = rate_mask << IL_FIRST_OFDM_RATE;\r\nspin_lock_irqsave(&rs_sta->lock, flags);\r\nif (rs_sta->start_rate != RATE_INVALID) {\r\nif (rs_sta->start_rate < idx &&\r\n(rate_mask & (1 << rs_sta->start_rate)))\r\nidx = rs_sta->start_rate;\r\nrs_sta->start_rate = RATE_INVALID;\r\n}\r\nif (max_rate_idx != -1 && max_rate_idx < idx) {\r\nif (rate_mask & (1 << max_rate_idx))\r\nidx = max_rate_idx;\r\n}\r\nwin = &(rs_sta->win[idx]);\r\nfail_count = win->counter - win->success_counter;\r\nif (fail_count < RATE_MIN_FAILURE_TH &&\r\nwin->success_counter < RATE_MIN_SUCCESS_TH) {\r\nspin_unlock_irqrestore(&rs_sta->lock, flags);\r\nD_RATE("Invalid average_tpt on rate %d: "\r\n"counter: %d, success_counter: %d, "\r\n"expected_tpt is %sNULL\n", idx, win->counter,\r\nwin->success_counter,\r\nrs_sta->expected_tpt ? "not " : "");\r\nwin->average_tpt = IL_INVALID_VALUE;\r\ngoto out;\r\n}\r\ncurrent_tpt = win->average_tpt;\r\nhigh_low =\r\nil3945_get_adjacent_rate(rs_sta, idx, rate_mask, sband->band);\r\nlow = high_low & 0xff;\r\nhigh = (high_low >> 8) & 0xff;\r\nif (max_rate_idx != -1 && max_rate_idx < high)\r\nhigh = RATE_INVALID;\r\nif (low != RATE_INVALID)\r\nlow_tpt = rs_sta->win[low].average_tpt;\r\nif (high != RATE_INVALID)\r\nhigh_tpt = rs_sta->win[high].average_tpt;\r\nspin_unlock_irqrestore(&rs_sta->lock, flags);\r\nscale_action = 0;\r\nif (win->success_ratio < RATE_DECREASE_TH || !current_tpt) {\r\nD_RATE("decrease rate because of low success_ratio\n");\r\nscale_action = -1;\r\n} else if (low_tpt == IL_INVALID_VALUE && high_tpt == IL_INVALID_VALUE) {\r\nif (high != RATE_INVALID &&\r\nwin->success_ratio >= RATE_INCREASE_TH)\r\nscale_action = 1;\r\nelse if (low != RATE_INVALID)\r\nscale_action = 0;\r\n} else if (low_tpt != IL_INVALID_VALUE && high_tpt != IL_INVALID_VALUE\r\n&& low_tpt < current_tpt && high_tpt < current_tpt) {\r\nD_RATE("No action -- low [%d] & high [%d] < "\r\n"current_tpt [%d]\n", low_tpt, high_tpt, current_tpt);\r\nscale_action = 0;\r\n} else {\r\nif (high_tpt != IL_INVALID_VALUE) {\r\nif (high_tpt > current_tpt &&\r\nwin->success_ratio >= RATE_INCREASE_TH)\r\nscale_action = 1;\r\nelse {\r\nD_RATE("decrease rate because of high tpt\n");\r\nscale_action = 0;\r\n}\r\n} else if (low_tpt != IL_INVALID_VALUE) {\r\nif (low_tpt > current_tpt) {\r\nD_RATE("decrease rate because of low tpt\n");\r\nscale_action = -1;\r\n} else if (win->success_ratio >= RATE_INCREASE_TH) {\r\nscale_action = 1;\r\n}\r\n}\r\n}\r\nif (scale_action == -1 && low != RATE_INVALID &&\r\n(win->success_ratio > RATE_HIGH_TH ||\r\ncurrent_tpt > 100 * rs_sta->expected_tpt[low]))\r\nscale_action = 0;\r\nswitch (scale_action) {\r\ncase -1:\r\nif (low != RATE_INVALID)\r\nidx = low;\r\nbreak;\r\ncase 1:\r\nif (high != RATE_INVALID)\r\nidx = high;\r\nbreak;\r\ncase 0:\r\ndefault:\r\nbreak;\r\n}\r\nD_RATE("Selected %d (action %d) - low %d high %d\n", idx, scale_action,\r\nlow, high);\r\nout:\r\nif (sband->band == IEEE80211_BAND_5GHZ) {\r\nif (WARN_ON_ONCE(idx < IL_FIRST_OFDM_RATE))\r\nidx = IL_FIRST_OFDM_RATE;\r\nrs_sta->last_txrate_idx = idx;\r\ninfo->control.rates[0].idx = idx - IL_FIRST_OFDM_RATE;\r\n} else {\r\nrs_sta->last_txrate_idx = idx;\r\ninfo->control.rates[0].idx = rs_sta->last_txrate_idx;\r\n}\r\ninfo->control.rates[0].count = 1;\r\nD_RATE("leave: %d\n", idx);\r\n}\r\nstatic ssize_t\r\nil3945_sta_dbgfs_stats_table_read(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *buff;\r\nint desc = 0;\r\nint j;\r\nssize_t ret;\r\nstruct il3945_rs_sta *lq_sta = file->private_data;\r\nbuff = kmalloc(1024, GFP_KERNEL);\r\nif (!buff)\r\nreturn -ENOMEM;\r\ndesc +=\r\nsprintf(buff + desc,\r\n"tx packets=%d last rate idx=%d\n"\r\n"rate=0x%X flush time %d\n", lq_sta->tx_packets,\r\nlq_sta->last_txrate_idx, lq_sta->start_rate,\r\njiffies_to_msecs(lq_sta->flush_time));\r\nfor (j = 0; j < RATE_COUNT_3945; j++) {\r\ndesc +=\r\nsprintf(buff + desc, "counter=%d success=%d %%=%d\n",\r\nlq_sta->win[j].counter,\r\nlq_sta->win[j].success_counter,\r\nlq_sta->win[j].success_ratio);\r\n}\r\nret = simple_read_from_buffer(user_buf, count, ppos, buff, desc);\r\nkfree(buff);\r\nreturn ret;\r\n}\r\nstatic void\r\nil3945_add_debugfs(void *il, void *il_sta, struct dentry *dir)\r\n{\r\nstruct il3945_rs_sta *lq_sta = il_sta;\r\nlq_sta->rs_sta_dbgfs_stats_table_file =\r\ndebugfs_create_file("rate_stats_table", 0600, dir, lq_sta,\r\n&rs_sta_dbgfs_stats_table_ops);\r\n}\r\nstatic void\r\nil3945_remove_debugfs(void *il, void *il_sta)\r\n{\r\nstruct il3945_rs_sta *lq_sta = il_sta;\r\ndebugfs_remove(lq_sta->rs_sta_dbgfs_stats_table_file);\r\n}\r\nstatic void\r\nil3945_rs_rate_init_stub(void *il_r, struct ieee80211_supported_band *sband,\r\nstruct cfg80211_chan_def *chandef,\r\nstruct ieee80211_sta *sta, void *il_sta)\r\n{\r\n}\r\nvoid\r\nil3945_rate_scale_init(struct ieee80211_hw *hw, s32 sta_id)\r\n{\r\nstruct il_priv *il = hw->priv;\r\ns32 rssi = 0;\r\nunsigned long flags;\r\nstruct il3945_rs_sta *rs_sta;\r\nstruct ieee80211_sta *sta;\r\nstruct il3945_sta_priv *psta;\r\nD_RATE("enter\n");\r\nrcu_read_lock();\r\nsta = ieee80211_find_sta(il->vif, il->stations[sta_id].sta.sta.addr);\r\nif (!sta) {\r\nD_RATE("Unable to find station to initialize rate scaling.\n");\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\npsta = (void *)sta->drv_priv;\r\nrs_sta = &psta->rs_sta;\r\nspin_lock_irqsave(&rs_sta->lock, flags);\r\nrs_sta->tgg = 0;\r\nswitch (il->band) {\r\ncase IEEE80211_BAND_2GHZ:\r\nif (il->active.flags & RXON_FLG_TGG_PROTECT_MSK) {\r\nrs_sta->tgg = 1;\r\nrs_sta->expected_tpt = il3945_expected_tpt_g_prot;\r\n} else\r\nrs_sta->expected_tpt = il3945_expected_tpt_g;\r\nbreak;\r\ncase IEEE80211_BAND_5GHZ:\r\nrs_sta->expected_tpt = il3945_expected_tpt_a;\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&rs_sta->lock, flags);\r\nrssi = il->_3945.last_rx_rssi;\r\nif (rssi == 0)\r\nrssi = IL_MIN_RSSI_VAL;\r\nD_RATE("Network RSSI: %d\n", rssi);\r\nrs_sta->start_rate = il3945_get_rate_idx_by_rssi(rssi, il->band);\r\nD_RATE("leave: rssi %d assign rate idx: " "%d (plcp 0x%x)\n", rssi,\r\nrs_sta->start_rate, il3945_rates[rs_sta->start_rate].plcp);\r\nrcu_read_unlock();\r\n}\r\nint\r\nil3945_rate_control_register(void)\r\n{\r\nreturn ieee80211_rate_control_register(&rs_ops);\r\n}\r\nvoid\r\nil3945_rate_control_unregister(void)\r\n{\r\nieee80211_rate_control_unregister(&rs_ops);\r\n}
