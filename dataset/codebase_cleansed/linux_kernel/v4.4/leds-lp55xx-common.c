static struct lp55xx_led *cdev_to_lp55xx_led(struct led_classdev *cdev)\r\n{\r\nreturn container_of(cdev, struct lp55xx_led, cdev);\r\n}\r\nstatic struct lp55xx_led *dev_to_lp55xx_led(struct device *dev)\r\n{\r\nreturn cdev_to_lp55xx_led(dev_get_drvdata(dev));\r\n}\r\nstatic void lp55xx_reset_device(struct lp55xx_chip *chip)\r\n{\r\nstruct lp55xx_device_config *cfg = chip->cfg;\r\nu8 addr = cfg->reset.addr;\r\nu8 val = cfg->reset.val;\r\nlp55xx_write(chip, addr, val);\r\n}\r\nstatic int lp55xx_detect_device(struct lp55xx_chip *chip)\r\n{\r\nstruct lp55xx_device_config *cfg = chip->cfg;\r\nu8 addr = cfg->enable.addr;\r\nu8 val = cfg->enable.val;\r\nint ret;\r\nret = lp55xx_write(chip, addr, val);\r\nif (ret)\r\nreturn ret;\r\nusleep_range(1000, 2000);\r\nret = lp55xx_read(chip, addr, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val != cfg->enable.val)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int lp55xx_post_init_device(struct lp55xx_chip *chip)\r\n{\r\nstruct lp55xx_device_config *cfg = chip->cfg;\r\nif (!cfg->post_init_device)\r\nreturn 0;\r\nreturn cfg->post_init_device(chip);\r\n}\r\nstatic ssize_t lp55xx_show_current(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct lp55xx_led *led = dev_to_lp55xx_led(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", led->led_current);\r\n}\r\nstatic ssize_t lp55xx_store_current(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct lp55xx_led *led = dev_to_lp55xx_led(dev);\r\nstruct lp55xx_chip *chip = led->chip;\r\nunsigned long curr;\r\nif (kstrtoul(buf, 0, &curr))\r\nreturn -EINVAL;\r\nif (curr > led->max_current)\r\nreturn -EINVAL;\r\nif (!chip->cfg->set_led_current)\r\nreturn len;\r\nmutex_lock(&chip->lock);\r\nchip->cfg->set_led_current(led, (u8)curr);\r\nmutex_unlock(&chip->lock);\r\nreturn len;\r\n}\r\nstatic ssize_t lp55xx_show_max_current(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct lp55xx_led *led = dev_to_lp55xx_led(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", led->max_current);\r\n}\r\nstatic void lp55xx_set_brightness(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct lp55xx_led *led = cdev_to_lp55xx_led(cdev);\r\nled->brightness = (u8)brightness;\r\nschedule_work(&led->brightness_work);\r\n}\r\nstatic int lp55xx_init_led(struct lp55xx_led *led,\r\nstruct lp55xx_chip *chip, int chan)\r\n{\r\nstruct lp55xx_platform_data *pdata = chip->pdata;\r\nstruct lp55xx_device_config *cfg = chip->cfg;\r\nstruct device *dev = &chip->cl->dev;\r\nchar name[32];\r\nint ret;\r\nint max_channel = cfg->max_channel;\r\nif (chan >= max_channel) {\r\ndev_err(dev, "invalid channel: %d / %d\n", chan, max_channel);\r\nreturn -EINVAL;\r\n}\r\nif (pdata->led_config[chan].led_current == 0)\r\nreturn 0;\r\nled->led_current = pdata->led_config[chan].led_current;\r\nled->max_current = pdata->led_config[chan].max_current;\r\nled->chan_nr = pdata->led_config[chan].chan_nr;\r\nled->cdev.default_trigger = pdata->led_config[chan].default_trigger;\r\nif (led->chan_nr >= max_channel) {\r\ndev_err(dev, "Use channel numbers between 0 and %d\n",\r\nmax_channel - 1);\r\nreturn -EINVAL;\r\n}\r\nled->cdev.brightness_set = lp55xx_set_brightness;\r\nled->cdev.groups = lp55xx_led_groups;\r\nif (pdata->led_config[chan].name) {\r\nled->cdev.name = pdata->led_config[chan].name;\r\n} else {\r\nsnprintf(name, sizeof(name), "%s:channel%d",\r\npdata->label ? : chip->cl->name, chan);\r\nled->cdev.name = name;\r\n}\r\nret = led_classdev_register(dev, &led->cdev);\r\nif (ret) {\r\ndev_err(dev, "led register err: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void lp55xx_firmware_loaded(const struct firmware *fw, void *context)\r\n{\r\nstruct lp55xx_chip *chip = context;\r\nstruct device *dev = &chip->cl->dev;\r\nenum lp55xx_engine_index idx = chip->engine_idx;\r\nif (!fw) {\r\ndev_err(dev, "firmware request failed\n");\r\ngoto out;\r\n}\r\nmutex_lock(&chip->lock);\r\nchip->engines[idx - 1].mode = LP55XX_ENGINE_LOAD;\r\nchip->fw = fw;\r\nif (chip->cfg->firmware_cb)\r\nchip->cfg->firmware_cb(chip);\r\nmutex_unlock(&chip->lock);\r\nout:\r\nrelease_firmware(chip->fw);\r\n}\r\nstatic int lp55xx_request_firmware(struct lp55xx_chip *chip)\r\n{\r\nconst char *name = chip->cl->name;\r\nstruct device *dev = &chip->cl->dev;\r\nreturn request_firmware_nowait(THIS_MODULE, false, name, dev,\r\nGFP_KERNEL, chip, lp55xx_firmware_loaded);\r\n}\r\nstatic ssize_t lp55xx_show_engine_select(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct lp55xx_chip *chip = led->chip;\r\nreturn sprintf(buf, "%d\n", chip->engine_idx);\r\n}\r\nstatic ssize_t lp55xx_store_engine_select(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct lp55xx_chip *chip = led->chip;\r\nunsigned long val;\r\nint ret;\r\nif (kstrtoul(buf, 0, &val))\r\nreturn -EINVAL;\r\nswitch (val) {\r\ncase LP55XX_ENGINE_1:\r\ncase LP55XX_ENGINE_2:\r\ncase LP55XX_ENGINE_3:\r\nmutex_lock(&chip->lock);\r\nchip->engine_idx = val;\r\nret = lp55xx_request_firmware(chip);\r\nmutex_unlock(&chip->lock);\r\nbreak;\r\ndefault:\r\ndev_err(dev, "%lu: invalid engine index. (1, 2, 3)\n", val);\r\nreturn -EINVAL;\r\n}\r\nif (ret) {\r\ndev_err(dev, "request firmware err: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn len;\r\n}\r\nstatic inline void lp55xx_run_engine(struct lp55xx_chip *chip, bool start)\r\n{\r\nif (chip->cfg->run_engine)\r\nchip->cfg->run_engine(chip, start);\r\n}\r\nstatic ssize_t lp55xx_store_engine_run(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct lp55xx_chip *chip = led->chip;\r\nunsigned long val;\r\nif (kstrtoul(buf, 0, &val))\r\nreturn -EINVAL;\r\nif (val <= 0) {\r\nlp55xx_run_engine(chip, false);\r\nreturn len;\r\n}\r\nmutex_lock(&chip->lock);\r\nlp55xx_run_engine(chip, true);\r\nmutex_unlock(&chip->lock);\r\nreturn len;\r\n}\r\nint lp55xx_write(struct lp55xx_chip *chip, u8 reg, u8 val)\r\n{\r\nreturn i2c_smbus_write_byte_data(chip->cl, reg, val);\r\n}\r\nint lp55xx_read(struct lp55xx_chip *chip, u8 reg, u8 *val)\r\n{\r\ns32 ret;\r\nret = i2c_smbus_read_byte_data(chip->cl, reg);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nreturn 0;\r\n}\r\nint lp55xx_update_bits(struct lp55xx_chip *chip, u8 reg, u8 mask, u8 val)\r\n{\r\nint ret;\r\nu8 tmp;\r\nret = lp55xx_read(chip, reg, &tmp);\r\nif (ret)\r\nreturn ret;\r\ntmp &= ~mask;\r\ntmp |= val & mask;\r\nreturn lp55xx_write(chip, reg, tmp);\r\n}\r\nbool lp55xx_is_extclk_used(struct lp55xx_chip *chip)\r\n{\r\nstruct clk *clk;\r\nint err;\r\nclk = devm_clk_get(&chip->cl->dev, "32k_clk");\r\nif (IS_ERR(clk))\r\ngoto use_internal_clk;\r\nerr = clk_prepare_enable(clk);\r\nif (err)\r\ngoto use_internal_clk;\r\nif (clk_get_rate(clk) != LP55XX_CLK_32K) {\r\nclk_disable_unprepare(clk);\r\ngoto use_internal_clk;\r\n}\r\ndev_info(&chip->cl->dev, "%dHz external clock used\n", LP55XX_CLK_32K);\r\nchip->clk = clk;\r\nreturn true;\r\nuse_internal_clk:\r\ndev_info(&chip->cl->dev, "internal clock used\n");\r\nreturn false;\r\n}\r\nint lp55xx_init_device(struct lp55xx_chip *chip)\r\n{\r\nstruct lp55xx_platform_data *pdata;\r\nstruct lp55xx_device_config *cfg;\r\nstruct device *dev = &chip->cl->dev;\r\nint ret = 0;\r\nWARN_ON(!chip);\r\npdata = chip->pdata;\r\ncfg = chip->cfg;\r\nif (!pdata || !cfg)\r\nreturn -EINVAL;\r\nif (gpio_is_valid(pdata->enable_gpio)) {\r\nret = devm_gpio_request_one(dev, pdata->enable_gpio,\r\nGPIOF_DIR_OUT, "lp5523_enable");\r\nif (ret < 0) {\r\ndev_err(dev, "could not acquire enable gpio (err=%d)\n",\r\nret);\r\ngoto err;\r\n}\r\ngpio_set_value(pdata->enable_gpio, 0);\r\nusleep_range(1000, 2000);\r\ngpio_set_value(pdata->enable_gpio, 1);\r\nusleep_range(1000, 2000);\r\n}\r\nlp55xx_reset_device(chip);\r\nusleep_range(10000, 20000);\r\nret = lp55xx_detect_device(chip);\r\nif (ret) {\r\ndev_err(dev, "device detection err: %d\n", ret);\r\ngoto err;\r\n}\r\nret = lp55xx_post_init_device(chip);\r\nif (ret) {\r\ndev_err(dev, "post init device err: %d\n", ret);\r\ngoto err_post_init;\r\n}\r\nreturn 0;\r\nerr_post_init:\r\nlp55xx_deinit_device(chip);\r\nerr:\r\nreturn ret;\r\n}\r\nvoid lp55xx_deinit_device(struct lp55xx_chip *chip)\r\n{\r\nstruct lp55xx_platform_data *pdata = chip->pdata;\r\nif (chip->clk)\r\nclk_disable_unprepare(chip->clk);\r\nif (gpio_is_valid(pdata->enable_gpio))\r\ngpio_set_value(pdata->enable_gpio, 0);\r\n}\r\nint lp55xx_register_leds(struct lp55xx_led *led, struct lp55xx_chip *chip)\r\n{\r\nstruct lp55xx_platform_data *pdata = chip->pdata;\r\nstruct lp55xx_device_config *cfg = chip->cfg;\r\nint num_channels = pdata->num_channels;\r\nstruct lp55xx_led *each;\r\nu8 led_current;\r\nint ret;\r\nint i;\r\nif (!cfg->brightness_work_fn) {\r\ndev_err(&chip->cl->dev, "empty brightness configuration\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < num_channels; i++) {\r\nif (pdata->led_config[i].led_current == 0)\r\ncontinue;\r\nled_current = pdata->led_config[i].led_current;\r\neach = led + i;\r\nret = lp55xx_init_led(each, chip, i);\r\nif (ret)\r\ngoto err_init_led;\r\nINIT_WORK(&each->brightness_work, cfg->brightness_work_fn);\r\nchip->num_leds++;\r\neach->chip = chip;\r\nif (cfg->set_led_current)\r\ncfg->set_led_current(each, led_current);\r\n}\r\nreturn 0;\r\nerr_init_led:\r\nlp55xx_unregister_leds(led, chip);\r\nreturn ret;\r\n}\r\nvoid lp55xx_unregister_leds(struct lp55xx_led *led, struct lp55xx_chip *chip)\r\n{\r\nint i;\r\nstruct lp55xx_led *each;\r\nfor (i = 0; i < chip->num_leds; i++) {\r\neach = led + i;\r\nled_classdev_unregister(&each->cdev);\r\nflush_work(&each->brightness_work);\r\n}\r\n}\r\nint lp55xx_register_sysfs(struct lp55xx_chip *chip)\r\n{\r\nstruct device *dev = &chip->cl->dev;\r\nstruct lp55xx_device_config *cfg = chip->cfg;\r\nint ret;\r\nif (!cfg->run_engine || !cfg->firmware_cb)\r\ngoto dev_specific_attrs;\r\nret = sysfs_create_group(&dev->kobj, &lp55xx_engine_attr_group);\r\nif (ret)\r\nreturn ret;\r\ndev_specific_attrs:\r\nreturn cfg->dev_attr_group ?\r\nsysfs_create_group(&dev->kobj, cfg->dev_attr_group) : 0;\r\n}\r\nvoid lp55xx_unregister_sysfs(struct lp55xx_chip *chip)\r\n{\r\nstruct device *dev = &chip->cl->dev;\r\nstruct lp55xx_device_config *cfg = chip->cfg;\r\nif (cfg->dev_attr_group)\r\nsysfs_remove_group(&dev->kobj, cfg->dev_attr_group);\r\nsysfs_remove_group(&dev->kobj, &lp55xx_engine_attr_group);\r\n}\r\nstruct lp55xx_platform_data *lp55xx_of_populate_pdata(struct device *dev,\r\nstruct device_node *np)\r\n{\r\nstruct device_node *child;\r\nstruct lp55xx_platform_data *pdata;\r\nstruct lp55xx_led_config *cfg;\r\nint num_channels;\r\nint i = 0;\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\nnum_channels = of_get_child_count(np);\r\nif (num_channels == 0) {\r\ndev_err(dev, "no LED channels\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ncfg = devm_kzalloc(dev, sizeof(*cfg) * num_channels, GFP_KERNEL);\r\nif (!cfg)\r\nreturn ERR_PTR(-ENOMEM);\r\npdata->led_config = &cfg[0];\r\npdata->num_channels = num_channels;\r\nfor_each_child_of_node(np, child) {\r\ncfg[i].chan_nr = i;\r\nof_property_read_string(child, "chan-name", &cfg[i].name);\r\nof_property_read_u8(child, "led-cur", &cfg[i].led_current);\r\nof_property_read_u8(child, "max-cur", &cfg[i].max_current);\r\ncfg[i].default_trigger =\r\nof_get_property(child, "linux,default-trigger", NULL);\r\ni++;\r\n}\r\nof_property_read_string(np, "label", &pdata->label);\r\nof_property_read_u8(np, "clock-mode", &pdata->clock_mode);\r\npdata->enable_gpio = of_get_named_gpio(np, "enable-gpio", 0);\r\nof_property_read_u8(np, "pwr-sel", (u8 *)&pdata->pwr_sel);\r\nreturn pdata;\r\n}
