int crw_register_handler(int rsc, crw_handler_t handler)\r\n{\r\nint rc = 0;\r\nif ((rsc < 0) || (rsc >= NR_RSCS))\r\nreturn -EINVAL;\r\nmutex_lock(&crw_handler_mutex);\r\nif (crw_handlers[rsc])\r\nrc = -EBUSY;\r\nelse\r\ncrw_handlers[rsc] = handler;\r\nmutex_unlock(&crw_handler_mutex);\r\nreturn rc;\r\n}\r\nvoid crw_unregister_handler(int rsc)\r\n{\r\nif ((rsc < 0) || (rsc >= NR_RSCS))\r\nreturn;\r\nmutex_lock(&crw_handler_mutex);\r\ncrw_handlers[rsc] = NULL;\r\nmutex_unlock(&crw_handler_mutex);\r\n}\r\nstatic int crw_collect_info(void *unused)\r\n{\r\nstruct crw crw[2];\r\nint ccode, signal;\r\nunsigned int chain;\r\nrepeat:\r\nsignal = wait_event_interruptible(crw_handler_wait_q,\r\natomic_read(&crw_nr_req) > 0);\r\nif (unlikely(signal))\r\natomic_inc(&crw_nr_req);\r\nchain = 0;\r\nwhile (1) {\r\ncrw_handler_t handler;\r\nif (unlikely(chain > 1)) {\r\nstruct crw tmp_crw;\r\nprintk(KERN_WARNING"%s: Code does not support more "\r\n"than two chained crws; please report to "\r\n"linux390@de.ibm.com!\n", __func__);\r\nccode = stcrw(&tmp_crw);\r\nprintk(KERN_WARNING"%s: crw reports slct=%d, oflw=%d, "\r\n"chn=%d, rsc=%X, anc=%d, erc=%X, rsid=%X\n",\r\n__func__, tmp_crw.slct, tmp_crw.oflw,\r\ntmp_crw.chn, tmp_crw.rsc, tmp_crw.anc,\r\ntmp_crw.erc, tmp_crw.rsid);\r\nprintk(KERN_WARNING"%s: This was crw number %x in the "\r\n"chain\n", __func__, chain);\r\nif (ccode != 0)\r\nbreak;\r\nchain = tmp_crw.chn ? chain + 1 : 0;\r\ncontinue;\r\n}\r\nccode = stcrw(&crw[chain]);\r\nif (ccode != 0)\r\nbreak;\r\nprintk(KERN_DEBUG "crw_info : CRW reports slct=%d, oflw=%d, "\r\n"chn=%d, rsc=%X, anc=%d, erc=%X, rsid=%X\n",\r\ncrw[chain].slct, crw[chain].oflw, crw[chain].chn,\r\ncrw[chain].rsc, crw[chain].anc, crw[chain].erc,\r\ncrw[chain].rsid);\r\nif (crw[chain].oflw) {\r\nint i;\r\npr_debug("%s: crw overflow detected!\n", __func__);\r\nmutex_lock(&crw_handler_mutex);\r\nfor (i = 0; i < NR_RSCS; i++) {\r\nif (crw_handlers[i])\r\ncrw_handlers[i](NULL, NULL, 1);\r\n}\r\nmutex_unlock(&crw_handler_mutex);\r\nchain = 0;\r\ncontinue;\r\n}\r\nif (crw[0].chn && !chain) {\r\nchain++;\r\ncontinue;\r\n}\r\nmutex_lock(&crw_handler_mutex);\r\nhandler = crw_handlers[crw[chain].rsc];\r\nif (handler)\r\nhandler(&crw[0], chain ? &crw[1] : NULL, 0);\r\nmutex_unlock(&crw_handler_mutex);\r\nchain = crw[chain].chn ? chain + 1 : 0;\r\n}\r\nif (atomic_dec_and_test(&crw_nr_req))\r\nwake_up(&crw_handler_wait_q);\r\ngoto repeat;\r\nreturn 0;\r\n}\r\nvoid crw_handle_channel_report(void)\r\n{\r\natomic_inc(&crw_nr_req);\r\nwake_up(&crw_handler_wait_q);\r\n}\r\nvoid crw_wait_for_channel_report(void)\r\n{\r\ncrw_handle_channel_report();\r\nwait_event(crw_handler_wait_q, atomic_read(&crw_nr_req) == 0);\r\n}\r\nstatic int __init crw_machine_check_init(void)\r\n{\r\nstruct task_struct *task;\r\ntask = kthread_run(crw_collect_info, NULL, "kmcheck");\r\nif (IS_ERR(task))\r\nreturn PTR_ERR(task);\r\nctl_set_bit(14, 28);\r\nreturn 0;\r\n}
