static int cachefiles_daemon_open(struct inode *inode, struct file *file)\r\n{\r\nstruct cachefiles_cache *cache;\r\n_enter("");\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (xchg(&cachefiles_open, 1) == 1)\r\nreturn -EBUSY;\r\ncache = kzalloc(sizeof(struct cachefiles_cache), GFP_KERNEL);\r\nif (!cache) {\r\ncachefiles_open = 0;\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&cache->daemon_mutex);\r\ncache->active_nodes = RB_ROOT;\r\nrwlock_init(&cache->active_lock);\r\ninit_waitqueue_head(&cache->daemon_pollwq);\r\ncache->frun_percent = 7;\r\ncache->fcull_percent = 5;\r\ncache->fstop_percent = 1;\r\ncache->brun_percent = 7;\r\ncache->bcull_percent = 5;\r\ncache->bstop_percent = 1;\r\nfile->private_data = cache;\r\ncache->cachefilesd = file;\r\nreturn 0;\r\n}\r\nstatic int cachefiles_daemon_release(struct inode *inode, struct file *file)\r\n{\r\nstruct cachefiles_cache *cache = file->private_data;\r\n_enter("");\r\nASSERT(cache);\r\nset_bit(CACHEFILES_DEAD, &cache->flags);\r\ncachefiles_daemon_unbind(cache);\r\nASSERT(!cache->active_nodes.rb_node);\r\ncache->cachefilesd = NULL;\r\nfile->private_data = NULL;\r\ncachefiles_open = 0;\r\nkfree(cache);\r\n_leave("");\r\nreturn 0;\r\n}\r\nstatic ssize_t cachefiles_daemon_read(struct file *file, char __user *_buffer,\r\nsize_t buflen, loff_t *pos)\r\n{\r\nstruct cachefiles_cache *cache = file->private_data;\r\nchar buffer[256];\r\nint n;\r\nif (!test_bit(CACHEFILES_READY, &cache->flags))\r\nreturn 0;\r\ncachefiles_has_space(cache, 0, 0);\r\nclear_bit(CACHEFILES_STATE_CHANGED, &cache->flags);\r\nn = snprintf(buffer, sizeof(buffer),\r\n"cull=%c"\r\n" frun=%llx"\r\n" fcull=%llx"\r\n" fstop=%llx"\r\n" brun=%llx"\r\n" bcull=%llx"\r\n" bstop=%llx",\r\ntest_bit(CACHEFILES_CULLING, &cache->flags) ? '1' : '0',\r\n(unsigned long long) cache->frun,\r\n(unsigned long long) cache->fcull,\r\n(unsigned long long) cache->fstop,\r\n(unsigned long long) cache->brun,\r\n(unsigned long long) cache->bcull,\r\n(unsigned long long) cache->bstop\r\n);\r\nif (n > buflen)\r\nreturn -EMSGSIZE;\r\nif (copy_to_user(_buffer, buffer, n) != 0)\r\nreturn -EFAULT;\r\nreturn n;\r\n}\r\nstatic ssize_t cachefiles_daemon_write(struct file *file,\r\nconst char __user *_data,\r\nsize_t datalen,\r\nloff_t *pos)\r\n{\r\nconst struct cachefiles_daemon_cmd *cmd;\r\nstruct cachefiles_cache *cache = file->private_data;\r\nssize_t ret;\r\nchar *data, *args, *cp;\r\nASSERT(cache);\r\nif (test_bit(CACHEFILES_DEAD, &cache->flags))\r\nreturn -EIO;\r\nif (datalen < 0 || datalen > PAGE_SIZE - 1)\r\nreturn -EOPNOTSUPP;\r\ndata = kmalloc(datalen + 1, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nret = -EFAULT;\r\nif (copy_from_user(data, _data, datalen) != 0)\r\ngoto error;\r\ndata[datalen] = '\0';\r\nret = -EINVAL;\r\nif (memchr(data, '\0', datalen))\r\ngoto error;\r\ncp = memchr(data, '\n', datalen);\r\nif (cp) {\r\nif (cp == data)\r\ngoto error;\r\n*cp = '\0';\r\n}\r\nret = -EOPNOTSUPP;\r\nfor (args = data; *args; args++)\r\nif (isspace(*args))\r\nbreak;\r\nif (*args) {\r\nif (args == data)\r\ngoto error;\r\n*args = '\0';\r\nargs = skip_spaces(++args);\r\n}\r\nfor (cmd = cachefiles_daemon_cmds; cmd->name[0]; cmd++)\r\nif (strcmp(cmd->name, data) == 0)\r\ngoto found_command;\r\nerror:\r\nkfree(data);\r\nreturn ret;\r\nfound_command:\r\nmutex_lock(&cache->daemon_mutex);\r\nret = -EIO;\r\nif (!test_bit(CACHEFILES_DEAD, &cache->flags))\r\nret = cmd->handler(cache, args);\r\nmutex_unlock(&cache->daemon_mutex);\r\nif (ret == 0)\r\nret = datalen;\r\ngoto error;\r\n}\r\nstatic unsigned int cachefiles_daemon_poll(struct file *file,\r\nstruct poll_table_struct *poll)\r\n{\r\nstruct cachefiles_cache *cache = file->private_data;\r\nunsigned int mask;\r\npoll_wait(file, &cache->daemon_pollwq, poll);\r\nmask = 0;\r\nif (test_bit(CACHEFILES_STATE_CHANGED, &cache->flags))\r\nmask |= POLLIN;\r\nif (test_bit(CACHEFILES_CULLING, &cache->flags))\r\nmask |= POLLOUT;\r\nreturn mask;\r\n}\r\nstatic int cachefiles_daemon_range_error(struct cachefiles_cache *cache,\r\nchar *args)\r\n{\r\npr_err("Free space limits must be in range 0%%<=stop<cull<run<100%%\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *cache, char *args)\r\n{\r\nunsigned long frun;\r\n_enter(",%s", args);\r\nif (!*args)\r\nreturn -EINVAL;\r\nfrun = simple_strtoul(args, &args, 10);\r\nif (args[0] != '%' || args[1] != '\0')\r\nreturn -EINVAL;\r\nif (frun <= cache->fcull_percent || frun >= 100)\r\nreturn cachefiles_daemon_range_error(cache, args);\r\ncache->frun_percent = frun;\r\nreturn 0;\r\n}\r\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *cache, char *args)\r\n{\r\nunsigned long fcull;\r\n_enter(",%s", args);\r\nif (!*args)\r\nreturn -EINVAL;\r\nfcull = simple_strtoul(args, &args, 10);\r\nif (args[0] != '%' || args[1] != '\0')\r\nreturn -EINVAL;\r\nif (fcull <= cache->fstop_percent || fcull >= cache->frun_percent)\r\nreturn cachefiles_daemon_range_error(cache, args);\r\ncache->fcull_percent = fcull;\r\nreturn 0;\r\n}\r\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *cache, char *args)\r\n{\r\nunsigned long fstop;\r\n_enter(",%s", args);\r\nif (!*args)\r\nreturn -EINVAL;\r\nfstop = simple_strtoul(args, &args, 10);\r\nif (args[0] != '%' || args[1] != '\0')\r\nreturn -EINVAL;\r\nif (fstop < 0 || fstop >= cache->fcull_percent)\r\nreturn cachefiles_daemon_range_error(cache, args);\r\ncache->fstop_percent = fstop;\r\nreturn 0;\r\n}\r\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *cache, char *args)\r\n{\r\nunsigned long brun;\r\n_enter(",%s", args);\r\nif (!*args)\r\nreturn -EINVAL;\r\nbrun = simple_strtoul(args, &args, 10);\r\nif (args[0] != '%' || args[1] != '\0')\r\nreturn -EINVAL;\r\nif (brun <= cache->bcull_percent || brun >= 100)\r\nreturn cachefiles_daemon_range_error(cache, args);\r\ncache->brun_percent = brun;\r\nreturn 0;\r\n}\r\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *cache, char *args)\r\n{\r\nunsigned long bcull;\r\n_enter(",%s", args);\r\nif (!*args)\r\nreturn -EINVAL;\r\nbcull = simple_strtoul(args, &args, 10);\r\nif (args[0] != '%' || args[1] != '\0')\r\nreturn -EINVAL;\r\nif (bcull <= cache->bstop_percent || bcull >= cache->brun_percent)\r\nreturn cachefiles_daemon_range_error(cache, args);\r\ncache->bcull_percent = bcull;\r\nreturn 0;\r\n}\r\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *cache, char *args)\r\n{\r\nunsigned long bstop;\r\n_enter(",%s", args);\r\nif (!*args)\r\nreturn -EINVAL;\r\nbstop = simple_strtoul(args, &args, 10);\r\nif (args[0] != '%' || args[1] != '\0')\r\nreturn -EINVAL;\r\nif (bstop < 0 || bstop >= cache->bcull_percent)\r\nreturn cachefiles_daemon_range_error(cache, args);\r\ncache->bstop_percent = bstop;\r\nreturn 0;\r\n}\r\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *cache, char *args)\r\n{\r\nchar *dir;\r\n_enter(",%s", args);\r\nif (!*args) {\r\npr_err("Empty directory specified\n");\r\nreturn -EINVAL;\r\n}\r\nif (cache->rootdirname) {\r\npr_err("Second cache directory specified\n");\r\nreturn -EEXIST;\r\n}\r\ndir = kstrdup(args, GFP_KERNEL);\r\nif (!dir)\r\nreturn -ENOMEM;\r\ncache->rootdirname = dir;\r\nreturn 0;\r\n}\r\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *cache, char *args)\r\n{\r\nchar *secctx;\r\n_enter(",%s", args);\r\nif (!*args) {\r\npr_err("Empty security context specified\n");\r\nreturn -EINVAL;\r\n}\r\nif (cache->secctx) {\r\npr_err("Second security context specified\n");\r\nreturn -EINVAL;\r\n}\r\nsecctx = kstrdup(args, GFP_KERNEL);\r\nif (!secctx)\r\nreturn -ENOMEM;\r\ncache->secctx = secctx;\r\nreturn 0;\r\n}\r\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *cache, char *args)\r\n{\r\nchar *tag;\r\n_enter(",%s", args);\r\nif (!*args) {\r\npr_err("Empty tag specified\n");\r\nreturn -EINVAL;\r\n}\r\nif (cache->tag)\r\nreturn -EEXIST;\r\ntag = kstrdup(args, GFP_KERNEL);\r\nif (!tag)\r\nreturn -ENOMEM;\r\ncache->tag = tag;\r\nreturn 0;\r\n}\r\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *cache, char *args)\r\n{\r\nstruct path path;\r\nconst struct cred *saved_cred;\r\nint ret;\r\n_enter(",%s", args);\r\nif (strchr(args, '/'))\r\ngoto inval;\r\nif (!test_bit(CACHEFILES_READY, &cache->flags)) {\r\npr_err("cull applied to unready cache\n");\r\nreturn -EIO;\r\n}\r\nif (test_bit(CACHEFILES_DEAD, &cache->flags)) {\r\npr_err("cull applied to dead cache\n");\r\nreturn -EIO;\r\n}\r\nget_fs_pwd(current->fs, &path);\r\nif (!d_can_lookup(path.dentry))\r\ngoto notdir;\r\ncachefiles_begin_secure(cache, &saved_cred);\r\nret = cachefiles_cull(cache, path.dentry, args);\r\ncachefiles_end_secure(cache, saved_cred);\r\npath_put(&path);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\nnotdir:\r\npath_put(&path);\r\npr_err("cull command requires dirfd to be a directory\n");\r\nreturn -ENOTDIR;\r\ninval:\r\npr_err("cull command requires dirfd and filename\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\r\n{\r\nunsigned long mask;\r\n_enter(",%s", args);\r\nmask = simple_strtoul(args, &args, 0);\r\nif (args[0] != '\0')\r\ngoto inval;\r\ncachefiles_debug = mask;\r\n_leave(" = 0");\r\nreturn 0;\r\ninval:\r\npr_err("debug command requires mask\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *cache, char *args)\r\n{\r\nstruct path path;\r\nconst struct cred *saved_cred;\r\nint ret;\r\nif (strchr(args, '/'))\r\ngoto inval;\r\nif (!test_bit(CACHEFILES_READY, &cache->flags)) {\r\npr_err("inuse applied to unready cache\n");\r\nreturn -EIO;\r\n}\r\nif (test_bit(CACHEFILES_DEAD, &cache->flags)) {\r\npr_err("inuse applied to dead cache\n");\r\nreturn -EIO;\r\n}\r\nget_fs_pwd(current->fs, &path);\r\nif (!d_can_lookup(path.dentry))\r\ngoto notdir;\r\ncachefiles_begin_secure(cache, &saved_cred);\r\nret = cachefiles_check_in_use(cache, path.dentry, args);\r\ncachefiles_end_secure(cache, saved_cred);\r\npath_put(&path);\r\nreturn ret;\r\nnotdir:\r\npath_put(&path);\r\npr_err("inuse command requires dirfd to be a directory\n");\r\nreturn -ENOTDIR;\r\ninval:\r\npr_err("inuse command requires dirfd and filename\n");\r\nreturn -EINVAL;\r\n}\r\nint cachefiles_has_space(struct cachefiles_cache *cache,\r\nunsigned fnr, unsigned bnr)\r\n{\r\nstruct kstatfs stats;\r\nstruct path path = {\r\n.mnt = cache->mnt,\r\n.dentry = cache->mnt->mnt_root,\r\n};\r\nint ret;\r\nmemset(&stats, 0, sizeof(stats));\r\nret = vfs_statfs(&path, &stats);\r\nif (ret < 0) {\r\nif (ret == -EIO)\r\ncachefiles_io_error(cache, "statfs failed");\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstats.f_bavail >>= cache->bshift;\r\nif (stats.f_ffree > fnr)\r\nstats.f_ffree -= fnr;\r\nelse\r\nstats.f_ffree = 0;\r\nif (stats.f_bavail > bnr)\r\nstats.f_bavail -= bnr;\r\nelse\r\nstats.f_bavail = 0;\r\nret = -ENOBUFS;\r\nif (stats.f_ffree < cache->fstop ||\r\nstats.f_bavail < cache->bstop)\r\ngoto begin_cull;\r\nret = 0;\r\nif (stats.f_ffree < cache->fcull ||\r\nstats.f_bavail < cache->bcull)\r\ngoto begin_cull;\r\nif (test_bit(CACHEFILES_CULLING, &cache->flags) &&\r\nstats.f_ffree >= cache->frun &&\r\nstats.f_bavail >= cache->brun &&\r\ntest_and_clear_bit(CACHEFILES_CULLING, &cache->flags)\r\n) {\r\n_debug("cease culling");\r\ncachefiles_state_changed(cache);\r\n}\r\nreturn 0;\r\nbegin_cull:\r\nif (!test_and_set_bit(CACHEFILES_CULLING, &cache->flags)) {\r\n_debug("### CULL CACHE ###");\r\ncachefiles_state_changed(cache);\r\n}\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}
