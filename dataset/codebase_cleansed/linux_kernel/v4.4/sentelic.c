static unsigned char fsp_test_swap_cmd(unsigned char reg_val)\r\n{\r\nswitch (reg_val) {\r\ncase 10: case 20: case 40: case 60: case 80: case 100: case 200:\r\nreturn (reg_val >> 4) | (reg_val << 4);\r\ndefault:\r\nreturn reg_val;\r\n}\r\n}\r\nstatic unsigned char fsp_test_invert_cmd(unsigned char reg_val)\r\n{\r\nswitch (reg_val) {\r\ncase 0xe9: case 0xee: case 0xf2: case 0xff:\r\nreturn ~reg_val;\r\ndefault:\r\nreturn reg_val;\r\n}\r\n}\r\nstatic int fsp_reg_read(struct psmouse *psmouse, int reg_addr, int *reg_val)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[3];\r\nunsigned char addr;\r\nint rc = -1;\r\npsmouse_deactivate(psmouse);\r\nps2_begin_command(ps2dev);\r\nif (ps2_sendbyte(ps2dev, 0xf3, FSP_CMD_TIMEOUT) < 0)\r\ngoto out;\r\nps2_sendbyte(ps2dev, 0x66, FSP_CMD_TIMEOUT2);\r\nps2_sendbyte(ps2dev, 0x88, FSP_CMD_TIMEOUT2);\r\nif (ps2_sendbyte(ps2dev, 0xf3, FSP_CMD_TIMEOUT) < 0)\r\ngoto out;\r\nif ((addr = fsp_test_invert_cmd(reg_addr)) != reg_addr) {\r\nps2_sendbyte(ps2dev, 0x68, FSP_CMD_TIMEOUT2);\r\n} else if ((addr = fsp_test_swap_cmd(reg_addr)) != reg_addr) {\r\nps2_sendbyte(ps2dev, 0xcc, FSP_CMD_TIMEOUT2);\r\n} else {\r\nps2_sendbyte(ps2dev, 0x66, FSP_CMD_TIMEOUT2);\r\n}\r\nps2_sendbyte(ps2dev, addr, FSP_CMD_TIMEOUT);\r\nif (__ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO) < 0)\r\ngoto out;\r\n*reg_val = param[2];\r\nrc = 0;\r\nout:\r\nps2_end_command(ps2dev);\r\npsmouse_activate(psmouse);\r\npsmouse_dbg(psmouse,\r\n"READ REG: 0x%02x is 0x%02x (rc = %d)\n",\r\nreg_addr, *reg_val, rc);\r\nreturn rc;\r\n}\r\nstatic int fsp_reg_write(struct psmouse *psmouse, int reg_addr, int reg_val)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char v;\r\nint rc = -1;\r\nps2_begin_command(ps2dev);\r\nif (ps2_sendbyte(ps2dev, 0xf3, FSP_CMD_TIMEOUT) < 0)\r\ngoto out;\r\nif ((v = fsp_test_invert_cmd(reg_addr)) != reg_addr) {\r\nps2_sendbyte(ps2dev, 0x74, FSP_CMD_TIMEOUT2);\r\n} else {\r\nif ((v = fsp_test_swap_cmd(reg_addr)) != reg_addr) {\r\nps2_sendbyte(ps2dev, 0x77, FSP_CMD_TIMEOUT2);\r\n} else {\r\nps2_sendbyte(ps2dev, 0x55, FSP_CMD_TIMEOUT2);\r\n}\r\n}\r\nps2_sendbyte(ps2dev, v, FSP_CMD_TIMEOUT2);\r\nif (ps2_sendbyte(ps2dev, 0xf3, FSP_CMD_TIMEOUT) < 0)\r\ngoto out;\r\nif ((v = fsp_test_invert_cmd(reg_val)) != reg_val) {\r\nps2_sendbyte(ps2dev, 0x47, FSP_CMD_TIMEOUT2);\r\n} else if ((v = fsp_test_swap_cmd(reg_val)) != reg_val) {\r\nps2_sendbyte(ps2dev, 0x44, FSP_CMD_TIMEOUT2);\r\n} else {\r\nps2_sendbyte(ps2dev, 0x33, FSP_CMD_TIMEOUT2);\r\n}\r\nps2_sendbyte(ps2dev, v, FSP_CMD_TIMEOUT2);\r\nrc = 0;\r\nout:\r\nps2_end_command(ps2dev);\r\npsmouse_dbg(psmouse,\r\n"WRITE REG: 0x%02x to 0x%02x (rc = %d)\n",\r\nreg_addr, reg_val, rc);\r\nreturn rc;\r\n}\r\nstatic int fsp_reg_write_enable(struct psmouse *psmouse, bool enable)\r\n{\r\nint v, nv;\r\nif (fsp_reg_read(psmouse, FSP_REG_SYSCTL1, &v) == -1)\r\nreturn -1;\r\nif (enable)\r\nnv = v | FSP_BIT_EN_REG_CLK;\r\nelse\r\nnv = v & ~FSP_BIT_EN_REG_CLK;\r\nif (nv != v)\r\nif (fsp_reg_write(psmouse, FSP_REG_SYSCTL1, nv) == -1)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int fsp_page_reg_read(struct psmouse *psmouse, int *reg_val)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[3];\r\nint rc = -1;\r\npsmouse_deactivate(psmouse);\r\nps2_begin_command(ps2dev);\r\nif (ps2_sendbyte(ps2dev, 0xf3, FSP_CMD_TIMEOUT) < 0)\r\ngoto out;\r\nps2_sendbyte(ps2dev, 0x66, FSP_CMD_TIMEOUT2);\r\nps2_sendbyte(ps2dev, 0x88, FSP_CMD_TIMEOUT2);\r\nif (ps2_sendbyte(ps2dev, 0xf3, FSP_CMD_TIMEOUT) < 0)\r\ngoto out;\r\nps2_sendbyte(ps2dev, 0x83, FSP_CMD_TIMEOUT2);\r\nps2_sendbyte(ps2dev, 0x88, FSP_CMD_TIMEOUT2);\r\nif (__ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))\r\ngoto out;\r\n*reg_val = param[2];\r\nrc = 0;\r\nout:\r\nps2_end_command(ps2dev);\r\npsmouse_activate(psmouse);\r\npsmouse_dbg(psmouse,\r\n"READ PAGE REG: 0x%02x (rc = %d)\n",\r\n*reg_val, rc);\r\nreturn rc;\r\n}\r\nstatic int fsp_page_reg_write(struct psmouse *psmouse, int reg_val)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char v;\r\nint rc = -1;\r\nps2_begin_command(ps2dev);\r\nif (ps2_sendbyte(ps2dev, 0xf3, FSP_CMD_TIMEOUT) < 0)\r\ngoto out;\r\nps2_sendbyte(ps2dev, 0x38, FSP_CMD_TIMEOUT2);\r\nps2_sendbyte(ps2dev, 0x88, FSP_CMD_TIMEOUT2);\r\nif (ps2_sendbyte(ps2dev, 0xf3, FSP_CMD_TIMEOUT) < 0)\r\ngoto out;\r\nif ((v = fsp_test_invert_cmd(reg_val)) != reg_val) {\r\nps2_sendbyte(ps2dev, 0x47, FSP_CMD_TIMEOUT2);\r\n} else if ((v = fsp_test_swap_cmd(reg_val)) != reg_val) {\r\nps2_sendbyte(ps2dev, 0x44, FSP_CMD_TIMEOUT2);\r\n} else {\r\nps2_sendbyte(ps2dev, 0x33, FSP_CMD_TIMEOUT2);\r\n}\r\nps2_sendbyte(ps2dev, v, FSP_CMD_TIMEOUT2);\r\nrc = 0;\r\nout:\r\nps2_end_command(ps2dev);\r\npsmouse_dbg(psmouse,\r\n"WRITE PAGE REG: to 0x%02x (rc = %d)\n",\r\nreg_val, rc);\r\nreturn rc;\r\n}\r\nstatic int fsp_get_version(struct psmouse *psmouse, int *version)\r\n{\r\nif (fsp_reg_read(psmouse, FSP_REG_VERSION, version))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int fsp_get_revision(struct psmouse *psmouse, int *rev)\r\n{\r\nif (fsp_reg_read(psmouse, FSP_REG_REVISION, rev))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int fsp_get_sn(struct psmouse *psmouse, int *sn)\r\n{\r\nint v0, v1, v2;\r\nint rc = -EIO;\r\nif (fsp_page_reg_write(psmouse, FSP_PAGE_0B))\r\ngoto out;\r\nif (fsp_reg_read(psmouse, FSP_REG_SN0, &v0))\r\ngoto out;\r\nif (fsp_reg_read(psmouse, FSP_REG_SN1, &v1))\r\ngoto out;\r\nif (fsp_reg_read(psmouse, FSP_REG_SN2, &v2))\r\ngoto out;\r\n*sn = (v0 << 16) | (v1 << 8) | v2;\r\nrc = 0;\r\nout:\r\nfsp_page_reg_write(psmouse, FSP_PAGE_DEFAULT);\r\nreturn rc;\r\n}\r\nstatic int fsp_get_buttons(struct psmouse *psmouse, int *btn)\r\n{\r\nstatic const int buttons[] = {\r\n0x16,\r\n0x06,\r\n0x04,\r\n0x02,\r\n};\r\nint val;\r\nif (fsp_reg_read(psmouse, FSP_REG_TMOD_STATUS, &val) == -1)\r\nreturn -EIO;\r\n*btn = buttons[(val & 0x30) >> 4];\r\nreturn 0;\r\n}\r\nstatic int fsp_opc_tag_enable(struct psmouse *psmouse, bool enable)\r\n{\r\nint v, nv;\r\nint res = 0;\r\nif (fsp_reg_read(psmouse, FSP_REG_OPC_QDOWN, &v) == -1) {\r\npsmouse_err(psmouse, "Unable get OPC state.\n");\r\nreturn -EIO;\r\n}\r\nif (enable)\r\nnv = v | FSP_BIT_EN_OPC_TAG;\r\nelse\r\nnv = v & ~FSP_BIT_EN_OPC_TAG;\r\nif (nv != v) {\r\nfsp_reg_write_enable(psmouse, true);\r\nres = fsp_reg_write(psmouse, FSP_REG_OPC_QDOWN, nv);\r\nfsp_reg_write_enable(psmouse, false);\r\n}\r\nif (res != 0) {\r\npsmouse_err(psmouse, "Unable to enable OPC tag.\n");\r\nres = -EIO;\r\n}\r\nreturn res;\r\n}\r\nstatic int fsp_onpad_vscr(struct psmouse *psmouse, bool enable)\r\n{\r\nstruct fsp_data *pad = psmouse->private;\r\nint val;\r\nif (fsp_reg_read(psmouse, FSP_REG_ONPAD_CTL, &val))\r\nreturn -EIO;\r\npad->vscroll = enable;\r\nif (enable)\r\nval |= (FSP_BIT_FIX_VSCR | FSP_BIT_ONPAD_ENABLE);\r\nelse\r\nval &= ~FSP_BIT_FIX_VSCR;\r\nif (fsp_reg_write(psmouse, FSP_REG_ONPAD_CTL, val))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int fsp_onpad_hscr(struct psmouse *psmouse, bool enable)\r\n{\r\nstruct fsp_data *pad = psmouse->private;\r\nint val, v2;\r\nif (fsp_reg_read(psmouse, FSP_REG_ONPAD_CTL, &val))\r\nreturn -EIO;\r\nif (fsp_reg_read(psmouse, FSP_REG_SYSCTL5, &v2))\r\nreturn -EIO;\r\npad->hscroll = enable;\r\nif (enable) {\r\nval |= (FSP_BIT_FIX_HSCR | FSP_BIT_ONPAD_ENABLE);\r\nv2 |= FSP_BIT_EN_MSID6;\r\n} else {\r\nval &= ~FSP_BIT_FIX_HSCR;\r\nv2 &= ~(FSP_BIT_EN_MSID6 | FSP_BIT_EN_MSID7 | FSP_BIT_EN_MSID8);\r\n}\r\nif (fsp_reg_write(psmouse, FSP_REG_ONPAD_CTL, val))\r\nreturn -EIO;\r\nif (fsp_reg_write(psmouse, FSP_REG_SYSCTL5, v2))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic ssize_t fsp_attr_set_setreg(struct psmouse *psmouse, void *data,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int reg, val;\r\nchar *rest;\r\nssize_t retval;\r\nreg = simple_strtoul(buf, &rest, 16);\r\nif (rest == buf || *rest != ' ' || reg > 0xff)\r\nreturn -EINVAL;\r\nretval = kstrtouint(rest + 1, 16, &val);\r\nif (retval)\r\nreturn retval;\r\nif (val > 0xff)\r\nreturn -EINVAL;\r\nif (fsp_reg_write_enable(psmouse, true))\r\nreturn -EIO;\r\nretval = fsp_reg_write(psmouse, reg, val) < 0 ? -EIO : count;\r\nfsp_reg_write_enable(psmouse, false);\r\nreturn count;\r\n}\r\nstatic ssize_t fsp_attr_show_getreg(struct psmouse *psmouse,\r\nvoid *data, char *buf)\r\n{\r\nstruct fsp_data *pad = psmouse->private;\r\nreturn sprintf(buf, "%02x%02x\n", pad->last_reg, pad->last_val);\r\n}\r\nstatic ssize_t fsp_attr_set_getreg(struct psmouse *psmouse, void *data,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fsp_data *pad = psmouse->private;\r\nunsigned int reg, val;\r\nint err;\r\nerr = kstrtouint(buf, 16, &reg);\r\nif (err)\r\nreturn err;\r\nif (reg > 0xff)\r\nreturn -EINVAL;\r\nif (fsp_reg_read(psmouse, reg, &val))\r\nreturn -EIO;\r\npad->last_reg = reg;\r\npad->last_val = val;\r\nreturn count;\r\n}\r\nstatic ssize_t fsp_attr_show_pagereg(struct psmouse *psmouse,\r\nvoid *data, char *buf)\r\n{\r\nint val = 0;\r\nif (fsp_page_reg_read(psmouse, &val))\r\nreturn -EIO;\r\nreturn sprintf(buf, "%02x\n", val);\r\n}\r\nstatic ssize_t fsp_attr_set_pagereg(struct psmouse *psmouse, void *data,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int val;\r\nint err;\r\nerr = kstrtouint(buf, 16, &val);\r\nif (err)\r\nreturn err;\r\nif (val > 0xff)\r\nreturn -EINVAL;\r\nif (fsp_page_reg_write(psmouse, val))\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic ssize_t fsp_attr_show_vscroll(struct psmouse *psmouse,\r\nvoid *data, char *buf)\r\n{\r\nstruct fsp_data *pad = psmouse->private;\r\nreturn sprintf(buf, "%d\n", pad->vscroll);\r\n}\r\nstatic ssize_t fsp_attr_set_vscroll(struct psmouse *psmouse, void *data,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int val;\r\nint err;\r\nerr = kstrtouint(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val > 1)\r\nreturn -EINVAL;\r\nfsp_onpad_vscr(psmouse, val);\r\nreturn count;\r\n}\r\nstatic ssize_t fsp_attr_show_hscroll(struct psmouse *psmouse,\r\nvoid *data, char *buf)\r\n{\r\nstruct fsp_data *pad = psmouse->private;\r\nreturn sprintf(buf, "%d\n", pad->hscroll);\r\n}\r\nstatic ssize_t fsp_attr_set_hscroll(struct psmouse *psmouse, void *data,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int val;\r\nint err;\r\nerr = kstrtouint(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val > 1)\r\nreturn -EINVAL;\r\nfsp_onpad_hscr(psmouse, val);\r\nreturn count;\r\n}\r\nstatic ssize_t fsp_attr_show_flags(struct psmouse *psmouse,\r\nvoid *data, char *buf)\r\n{\r\nstruct fsp_data *pad = psmouse->private;\r\nreturn sprintf(buf, "%c\n",\r\npad->flags & FSPDRV_FLAG_EN_OPC ? 'C' : 'c');\r\n}\r\nstatic ssize_t fsp_attr_set_flags(struct psmouse *psmouse, void *data,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fsp_data *pad = psmouse->private;\r\nsize_t i;\r\nfor (i = 0; i < count; i++) {\r\nswitch (buf[i]) {\r\ncase 'C':\r\npad->flags |= FSPDRV_FLAG_EN_OPC;\r\nbreak;\r\ncase 'c':\r\npad->flags &= ~FSPDRV_FLAG_EN_OPC;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t fsp_attr_show_ver(struct psmouse *psmouse,\r\nvoid *data, char *buf)\r\n{\r\nreturn sprintf(buf, "Sentelic FSP kernel module %s\n", fsp_drv_ver);\r\n}\r\nstatic void fsp_packet_debug(struct psmouse *psmouse, unsigned char packet[])\r\n{\r\nstatic unsigned int ps2_packet_cnt;\r\nstatic unsigned int ps2_last_second;\r\nunsigned int jiffies_msec;\r\nconst char *packet_type = "UNKNOWN";\r\nunsigned short abs_x = 0, abs_y = 0;\r\nswitch (packet[0] >> FSP_PKT_TYPE_SHIFT) {\r\ncase FSP_PKT_TYPE_ABS:\r\npacket_type = "Absolute";\r\nabs_x = GET_ABS_X(packet);\r\nabs_y = GET_ABS_Y(packet);\r\nbreak;\r\ncase FSP_PKT_TYPE_NORMAL:\r\npacket_type = "Normal";\r\nbreak;\r\ncase FSP_PKT_TYPE_NOTIFY:\r\npacket_type = "Notify";\r\nbreak;\r\ncase FSP_PKT_TYPE_NORMAL_OPC:\r\npacket_type = "Normal-OPC";\r\nbreak;\r\n}\r\nps2_packet_cnt++;\r\njiffies_msec = jiffies_to_msecs(jiffies);\r\npsmouse_dbg(psmouse,\r\n"%08dms %s packets: %02x, %02x, %02x, %02x; "\r\n"abs_x: %d, abs_y: %d\n",\r\njiffies_msec, packet_type,\r\npacket[0], packet[1], packet[2], packet[3], abs_x, abs_y);\r\nif (jiffies_msec - ps2_last_second > 1000) {\r\npsmouse_dbg(psmouse, "PS/2 packets/sec = %d\n", ps2_packet_cnt);\r\nps2_packet_cnt = 0;\r\nps2_last_second = jiffies_msec;\r\n}\r\n}\r\nstatic void fsp_packet_debug(struct psmouse *psmouse, unsigned char packet[])\r\n{\r\n}\r\nstatic void fsp_set_slot(struct input_dev *dev, int slot, bool active,\r\nunsigned int x, unsigned int y)\r\n{\r\ninput_mt_slot(dev, slot);\r\ninput_mt_report_slot_state(dev, MT_TOOL_FINGER, active);\r\nif (active) {\r\ninput_report_abs(dev, ABS_MT_POSITION_X, x);\r\ninput_report_abs(dev, ABS_MT_POSITION_Y, y);\r\n}\r\n}\r\nstatic psmouse_ret_t fsp_process_byte(struct psmouse *psmouse)\r\n{\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct fsp_data *ad = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nunsigned char button_status = 0, lscroll = 0, rscroll = 0;\r\nunsigned short abs_x, abs_y, fgrs = 0;\r\nint rel_x, rel_y;\r\nif (psmouse->pktcnt < 4)\r\nreturn PSMOUSE_GOOD_DATA;\r\nfsp_packet_debug(psmouse, packet);\r\nswitch (psmouse->packet[0] >> FSP_PKT_TYPE_SHIFT) {\r\ncase FSP_PKT_TYPE_ABS:\r\nif ((packet[0] == 0x48 || packet[0] == 0x49) &&\r\npacket[1] == 0 && packet[2] == 0) {\r\npacket[3] &= 0xf0;\r\n}\r\nabs_x = GET_ABS_X(packet);\r\nabs_y = GET_ABS_Y(packet);\r\nif (packet[0] & FSP_PB0_MFMC) {\r\nfgrs = 2;\r\nif (packet[0] & FSP_PB0_MFMC_FGR2) {\r\nif (ad->last_mt_fgr == 2) {\r\nfgrs = 1;\r\nfsp_set_slot(dev, 0, false, 0, 0);\r\n}\r\nad->last_mt_fgr = 2;\r\nfsp_set_slot(dev, 1, fgrs == 2, abs_x, abs_y);\r\n} else {\r\nif (ad->last_mt_fgr == 1) {\r\nfgrs = 1;\r\nfsp_set_slot(dev, 1, false, 0, 0);\r\n}\r\nad->last_mt_fgr = 1;\r\nfsp_set_slot(dev, 0, fgrs != 0, abs_x, abs_y);\r\n}\r\n} else {\r\nif ((packet[0] & (FSP_PB0_LBTN|FSP_PB0_PHY_BTN)) ==\r\nFSP_PB0_LBTN) {\r\npacket[0] &= ~FSP_PB0_LBTN;\r\n}\r\nad->last_mt_fgr = 0;\r\nif (abs_x != 0 && abs_y != 0)\r\nfgrs = 1;\r\nfsp_set_slot(dev, 0, fgrs > 0, abs_x, abs_y);\r\nfsp_set_slot(dev, 1, false, 0, 0);\r\n}\r\nif (fgrs == 1 || (fgrs == 2 && !(packet[0] & FSP_PB0_MFMC_FGR2))) {\r\ninput_report_abs(dev, ABS_X, abs_x);\r\ninput_report_abs(dev, ABS_Y, abs_y);\r\n}\r\ninput_report_key(dev, BTN_LEFT, packet[0] & 0x01);\r\ninput_report_key(dev, BTN_RIGHT, packet[0] & 0x02);\r\ninput_report_key(dev, BTN_TOUCH, fgrs);\r\ninput_report_key(dev, BTN_TOOL_FINGER, fgrs == 1);\r\ninput_report_key(dev, BTN_TOOL_DOUBLETAP, fgrs == 2);\r\nbreak;\r\ncase FSP_PKT_TYPE_NORMAL_OPC:\r\nif ((ad->flags & FSPDRV_FLAG_EN_OPC) != FSPDRV_FLAG_EN_OPC)\r\npacket[0] &= ~FSP_PB0_LBTN;\r\ncase FSP_PKT_TYPE_NORMAL:\r\nif (packet[3] != 0) {\r\nif (packet[3] & BIT(0))\r\nbutton_status |= 0x01;\r\nif (packet[3] & BIT(1))\r\nbutton_status |= 0x0f;\r\nif (packet[3] & BIT(2))\r\nbutton_status |= BIT(4);\r\nif (packet[3] & BIT(3))\r\nbutton_status |= BIT(5);\r\nif (button_status != 0)\r\npacket[3] = button_status;\r\nrscroll = (packet[3] >> 4) & 1;\r\nlscroll = (packet[3] >> 5) & 1;\r\n}\r\ninput_report_rel(dev, REL_WHEEL,\r\n(int)(packet[3] & 8) - (int)(packet[3] & 7));\r\ninput_report_rel(dev, REL_HWHEEL, lscroll - rscroll);\r\ninput_report_key(dev, BTN_BACK, lscroll);\r\ninput_report_key(dev, BTN_FORWARD, rscroll);\r\ninput_report_key(dev, BTN_LEFT, packet[0] & 1);\r\ninput_report_key(dev, BTN_MIDDLE, (packet[0] >> 2) & 1);\r\ninput_report_key(dev, BTN_RIGHT, (packet[0] >> 1) & 1);\r\nrel_x = packet[1] ? (int)packet[1] - (int)((packet[0] << 4) & 0x100) : 0;\r\nrel_y = packet[2] ? (int)((packet[0] << 3) & 0x100) - (int)packet[2] : 0;\r\ninput_report_rel(dev, REL_X, rel_x);\r\ninput_report_rel(dev, REL_Y, rel_y);\r\nbreak;\r\n}\r\ninput_sync(dev);\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nstatic int fsp_activate_protocol(struct psmouse *psmouse)\r\n{\r\nstruct fsp_data *pad = psmouse->private;\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[2];\r\nint val;\r\nparam[0] = 200;\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\r\nparam[0] = 200;\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\r\nparam[0] = 80;\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\r\nps2_command(ps2dev, param, PSMOUSE_CMD_GETID);\r\nif (param[0] != 0x04) {\r\npsmouse_err(psmouse,\r\n"Unable to enable 4 bytes packet format.\n");\r\nreturn -EIO;\r\n}\r\nif (pad->ver < FSP_VER_STL3888_C0) {\r\nif (fsp_reg_read(psmouse, FSP_REG_SYSCTL5, &val)) {\r\npsmouse_err(psmouse,\r\n"Unable to read SYSCTL5 register.\n");\r\nreturn -EIO;\r\n}\r\nif (fsp_get_buttons(psmouse, &pad->buttons)) {\r\npsmouse_err(psmouse,\r\n"Unable to retrieve number of buttons.\n");\r\nreturn -EIO;\r\n}\r\nval &= ~(FSP_BIT_EN_MSID7 | FSP_BIT_EN_MSID8 | FSP_BIT_EN_AUTO_MSID8);\r\nval &= ~FSP_BIT_EN_PKT_G0;\r\nif (pad->buttons == 0x06) {\r\nval |= FSP_BIT_EN_MSID6;\r\n}\r\nif (fsp_reg_write(psmouse, FSP_REG_SYSCTL5, val)) {\r\npsmouse_err(psmouse,\r\n"Unable to set up required mode bits.\n");\r\nreturn -EIO;\r\n}\r\nif (fsp_opc_tag_enable(psmouse, true))\r\npsmouse_warn(psmouse,\r\n"Failed to enable OPC tag mode.\n");\r\npad->flags |= FSPDRV_FLAG_EN_OPC;\r\nfsp_onpad_vscr(psmouse, true);\r\nfsp_onpad_hscr(psmouse, true);\r\n} else {\r\nif (fsp_reg_write(psmouse, FSP_REG_SWC1,\r\nFSP_BIT_SWC1_EN_ABS_1F |\r\nFSP_BIT_SWC1_EN_ABS_2F |\r\nFSP_BIT_SWC1_EN_FUP_OUT |\r\nFSP_BIT_SWC1_EN_ABS_CON)) {\r\npsmouse_err(psmouse,\r\n"Unable to enable absolute coordinates output.\n");\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsp_set_input_params(struct psmouse *psmouse)\r\n{\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct fsp_data *pad = psmouse->private;\r\nif (pad->ver < FSP_VER_STL3888_C0) {\r\n__set_bit(BTN_MIDDLE, dev->keybit);\r\n__set_bit(BTN_BACK, dev->keybit);\r\n__set_bit(BTN_FORWARD, dev->keybit);\r\n__set_bit(REL_WHEEL, dev->relbit);\r\n__set_bit(REL_HWHEEL, dev->relbit);\r\n} else {\r\nint abs_x = 967, abs_y = 711;\r\n__set_bit(EV_ABS, dev->evbit);\r\n__clear_bit(EV_REL, dev->evbit);\r\n__set_bit(BTN_TOUCH, dev->keybit);\r\n__set_bit(BTN_TOOL_FINGER, dev->keybit);\r\n__set_bit(BTN_TOOL_DOUBLETAP, dev->keybit);\r\n__set_bit(INPUT_PROP_SEMI_MT, dev->propbit);\r\ninput_set_abs_params(dev, ABS_X, 0, abs_x, 0, 0);\r\ninput_set_abs_params(dev, ABS_Y, 0, abs_y, 0, 0);\r\ninput_mt_init_slots(dev, 2, 0);\r\ninput_set_abs_params(dev, ABS_MT_POSITION_X, 0, abs_x, 0, 0);\r\ninput_set_abs_params(dev, ABS_MT_POSITION_Y, 0, abs_y, 0, 0);\r\n}\r\nreturn 0;\r\n}\r\nint fsp_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nint id;\r\nif (fsp_reg_read(psmouse, FSP_REG_DEVICE_ID, &id))\r\nreturn -EIO;\r\nif (id != 0x01)\r\nreturn -ENODEV;\r\nif (set_properties) {\r\npsmouse->vendor = "Sentelic";\r\npsmouse->name = "FingerSensingPad";\r\n}\r\nreturn 0;\r\n}\r\nstatic void fsp_reset(struct psmouse *psmouse)\r\n{\r\nfsp_opc_tag_enable(psmouse, false);\r\nfsp_onpad_vscr(psmouse, false);\r\nfsp_onpad_hscr(psmouse, false);\r\n}\r\nstatic void fsp_disconnect(struct psmouse *psmouse)\r\n{\r\nsysfs_remove_group(&psmouse->ps2dev.serio->dev.kobj,\r\n&fsp_attribute_group);\r\nfsp_reset(psmouse);\r\nkfree(psmouse->private);\r\n}\r\nstatic int fsp_reconnect(struct psmouse *psmouse)\r\n{\r\nint version;\r\nif (fsp_detect(psmouse, 0))\r\nreturn -ENODEV;\r\nif (fsp_get_version(psmouse, &version))\r\nreturn -ENODEV;\r\nif (fsp_activate_protocol(psmouse))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nint fsp_init(struct psmouse *psmouse)\r\n{\r\nstruct fsp_data *priv;\r\nint ver, rev, sn = 0;\r\nint error;\r\nif (fsp_get_version(psmouse, &ver) ||\r\nfsp_get_revision(psmouse, &rev)) {\r\nreturn -ENODEV;\r\n}\r\nif (ver >= FSP_VER_STL3888_C0) {\r\nfsp_get_sn(psmouse, &sn);\r\n}\r\npsmouse_info(psmouse,\r\n"Finger Sensing Pad, hw: %d.%d.%d, sn: %x, sw: %s\n",\r\nver >> 4, ver & 0x0F, rev, sn, fsp_drv_ver);\r\npsmouse->private = priv = kzalloc(sizeof(struct fsp_data), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->ver = ver;\r\npriv->rev = rev;\r\npsmouse->protocol_handler = fsp_process_byte;\r\npsmouse->disconnect = fsp_disconnect;\r\npsmouse->reconnect = fsp_reconnect;\r\npsmouse->cleanup = fsp_reset;\r\npsmouse->pktsize = 4;\r\nerror = fsp_activate_protocol(psmouse);\r\nif (error)\r\ngoto err_out;\r\nerror = fsp_set_input_params(psmouse);\r\nif (error)\r\ngoto err_out;\r\nerror = sysfs_create_group(&psmouse->ps2dev.serio->dev.kobj,\r\n&fsp_attribute_group);\r\nif (error) {\r\npsmouse_err(psmouse,\r\n"Failed to create sysfs attributes (%d)", error);\r\ngoto err_out;\r\n}\r\nreturn 0;\r\nerr_out:\r\nkfree(psmouse->private);\r\npsmouse->private = NULL;\r\nreturn error;\r\n}
