static int sst_platform_get_resources(struct intel_sst_drv *ctx)\r\n{\r\nstruct resource *rsrc;\r\nstruct platform_device *pdev = to_platform_device(ctx->dev);\r\nrsrc = platform_get_resource(pdev, IORESOURCE_MEM,\r\nctx->pdata->res_info->acpi_lpe_res_index);\r\nif (!rsrc) {\r\ndev_err(ctx->dev, "Invalid SHIM base from IFWI");\r\nreturn -EIO;\r\n}\r\ndev_info(ctx->dev, "LPE base: %#x size:%#x", (unsigned int) rsrc->start,\r\n(unsigned int)resource_size(rsrc));\r\nctx->iram_base = rsrc->start + ctx->pdata->res_info->iram_offset;\r\nctx->iram_end = ctx->iram_base + ctx->pdata->res_info->iram_size - 1;\r\ndev_info(ctx->dev, "IRAM base: %#x", ctx->iram_base);\r\nctx->iram = devm_ioremap_nocache(ctx->dev, ctx->iram_base,\r\nctx->pdata->res_info->iram_size);\r\nif (!ctx->iram) {\r\ndev_err(ctx->dev, "unable to map IRAM");\r\nreturn -EIO;\r\n}\r\nctx->dram_base = rsrc->start + ctx->pdata->res_info->dram_offset;\r\nctx->dram_end = ctx->dram_base + ctx->pdata->res_info->dram_size - 1;\r\ndev_info(ctx->dev, "DRAM base: %#x", ctx->dram_base);\r\nctx->dram = devm_ioremap_nocache(ctx->dev, ctx->dram_base,\r\nctx->pdata->res_info->dram_size);\r\nif (!ctx->dram) {\r\ndev_err(ctx->dev, "unable to map DRAM");\r\nreturn -EIO;\r\n}\r\nctx->shim_phy_add = rsrc->start + ctx->pdata->res_info->shim_offset;\r\ndev_info(ctx->dev, "SHIM base: %#x", ctx->shim_phy_add);\r\nctx->shim = devm_ioremap_nocache(ctx->dev, ctx->shim_phy_add,\r\nctx->pdata->res_info->shim_size);\r\nif (!ctx->shim) {\r\ndev_err(ctx->dev, "unable to map SHIM");\r\nreturn -EIO;\r\n}\r\nctx->shim_phy_add = ctx->pdata->res_info->shim_phy_addr;\r\nctx->mailbox_add = rsrc->start + ctx->pdata->res_info->mbox_offset;\r\ndev_info(ctx->dev, "Mailbox base: %#x", ctx->mailbox_add);\r\nctx->mailbox = devm_ioremap_nocache(ctx->dev, ctx->mailbox_add,\r\nctx->pdata->res_info->mbox_size);\r\nif (!ctx->mailbox) {\r\ndev_err(ctx->dev, "unable to map mailbox");\r\nreturn -EIO;\r\n}\r\nctx->mailbox_add = ctx->info.mailbox_start;\r\nrsrc = platform_get_resource(pdev, IORESOURCE_MEM,\r\nctx->pdata->res_info->acpi_ddr_index);\r\nif (!rsrc) {\r\ndev_err(ctx->dev, "Invalid DDR base from IFWI");\r\nreturn -EIO;\r\n}\r\nctx->ddr_base = rsrc->start;\r\nctx->ddr_end = rsrc->end;\r\ndev_info(ctx->dev, "DDR base: %#x", ctx->ddr_base);\r\nctx->ddr = devm_ioremap_nocache(ctx->dev, ctx->ddr_base,\r\nresource_size(rsrc));\r\nif (!ctx->ddr) {\r\ndev_err(ctx->dev, "unable to map DDR");\r\nreturn -EIO;\r\n}\r\nctx->irq_num = platform_get_irq(pdev,\r\nctx->pdata->res_info->acpi_ipc_irq_index);\r\nreturn 0;\r\n}\r\nstatic acpi_status sst_acpi_mach_match(acpi_handle handle, u32 level,\r\nvoid *context, void **ret)\r\n{\r\n*(bool *)context = true;\r\nreturn AE_OK;\r\n}\r\nstatic struct sst_machines *sst_acpi_find_machine(\r\nstruct sst_machines *machines)\r\n{\r\nstruct sst_machines *mach;\r\nbool found = false;\r\nfor (mach = machines; mach->codec_id; mach++)\r\nif (ACPI_SUCCESS(acpi_get_devices(mach->codec_id,\r\nsst_acpi_mach_match,\r\n&found, NULL)) && found)\r\nreturn mach;\r\nreturn NULL;\r\n}\r\nstatic int sst_acpi_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nint ret = 0;\r\nstruct intel_sst_drv *ctx;\r\nconst struct acpi_device_id *id;\r\nstruct sst_machines *mach;\r\nstruct platform_device *mdev;\r\nstruct platform_device *plat_dev;\r\nunsigned int dev_id;\r\nid = acpi_match_device(dev->driver->acpi_match_table, dev);\r\nif (!id)\r\nreturn -ENODEV;\r\ndev_dbg(dev, "for %s", id->id);\r\nmach = (struct sst_machines *)id->driver_data;\r\nmach = sst_acpi_find_machine(mach);\r\nif (mach == NULL) {\r\ndev_err(dev, "No matching machine driver found\n");\r\nreturn -ENODEV;\r\n}\r\nret = kstrtouint(id->id, 16, &dev_id);\r\nif (ret < 0) {\r\ndev_err(dev, "Unique device id conversion error: %d\n", ret);\r\nreturn ret;\r\n}\r\ndev_dbg(dev, "ACPI device id: %x\n", dev_id);\r\nplat_dev = platform_device_register_data(dev, mach->pdata->platform, -1, NULL, 0);\r\nif (IS_ERR(plat_dev)) {\r\ndev_err(dev, "Failed to create machine device: %s\n", mach->pdata->platform);\r\nreturn PTR_ERR(plat_dev);\r\n}\r\nmdev = platform_device_register_data(dev, mach->machine, -1, NULL, 0);\r\nif (IS_ERR(mdev)) {\r\ndev_err(dev, "Failed to create machine device: %s\n", mach->machine);\r\nreturn PTR_ERR(mdev);\r\n}\r\nret = sst_alloc_drv_context(&ctx, dev, dev_id);\r\nif (ret < 0)\r\nreturn ret;\r\nctx->pdata = mach->pdata;\r\nstrcpy(ctx->firmware_name, mach->firmware);\r\nret = sst_platform_get_resources(ctx);\r\nif (ret)\r\nreturn ret;\r\nret = sst_context_init(ctx);\r\nif (ret < 0)\r\nreturn ret;\r\nctx->shim_regs64 = devm_kzalloc(ctx->dev, sizeof(*ctx->shim_regs64),\r\nGFP_KERNEL);\r\nif (!ctx->shim_regs64) {\r\nret = -ENOMEM;\r\ngoto do_sst_cleanup;\r\n}\r\nsst_configure_runtime_pm(ctx);\r\nplatform_set_drvdata(pdev, ctx);\r\nreturn ret;\r\ndo_sst_cleanup:\r\nsst_context_cleanup(ctx);\r\nplatform_set_drvdata(pdev, NULL);\r\ndev_err(ctx->dev, "failed with %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int sst_acpi_remove(struct platform_device *pdev)\r\n{\r\nstruct intel_sst_drv *ctx;\r\nctx = platform_get_drvdata(pdev);\r\nsst_context_cleanup(ctx);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
