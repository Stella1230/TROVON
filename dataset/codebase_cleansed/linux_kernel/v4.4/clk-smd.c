static unsigned long at91sam9x5_clk_smd_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nu32 tmp;\r\nu8 smddiv;\r\nstruct at91sam9x5_clk_smd *smd = to_at91sam9x5_clk_smd(hw);\r\nstruct at91_pmc *pmc = smd->pmc;\r\ntmp = pmc_read(pmc, AT91_PMC_SMD);\r\nsmddiv = (tmp & AT91_PMC_SMD_DIV) >> SMD_DIV_SHIFT;\r\nreturn parent_rate / (smddiv + 1);\r\n}\r\nstatic long at91sam9x5_clk_smd_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned long div;\r\nunsigned long bestrate;\r\nunsigned long tmp;\r\nif (rate >= *parent_rate)\r\nreturn *parent_rate;\r\ndiv = *parent_rate / rate;\r\nif (div > SMD_MAX_DIV)\r\nreturn *parent_rate / (SMD_MAX_DIV + 1);\r\nbestrate = *parent_rate / div;\r\ntmp = *parent_rate / (div + 1);\r\nif (bestrate - rate > rate - tmp)\r\nbestrate = tmp;\r\nreturn bestrate;\r\n}\r\nstatic int at91sam9x5_clk_smd_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nu32 tmp;\r\nstruct at91sam9x5_clk_smd *smd = to_at91sam9x5_clk_smd(hw);\r\nstruct at91_pmc *pmc = smd->pmc;\r\nif (index > 1)\r\nreturn -EINVAL;\r\ntmp = pmc_read(pmc, AT91_PMC_SMD) & ~AT91_PMC_SMDS;\r\nif (index)\r\ntmp |= AT91_PMC_SMDS;\r\npmc_write(pmc, AT91_PMC_SMD, tmp);\r\nreturn 0;\r\n}\r\nstatic u8 at91sam9x5_clk_smd_get_parent(struct clk_hw *hw)\r\n{\r\nstruct at91sam9x5_clk_smd *smd = to_at91sam9x5_clk_smd(hw);\r\nstruct at91_pmc *pmc = smd->pmc;\r\nreturn pmc_read(pmc, AT91_PMC_SMD) & AT91_PMC_SMDS;\r\n}\r\nstatic int at91sam9x5_clk_smd_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nu32 tmp;\r\nstruct at91sam9x5_clk_smd *smd = to_at91sam9x5_clk_smd(hw);\r\nstruct at91_pmc *pmc = smd->pmc;\r\nunsigned long div = parent_rate / rate;\r\nif (parent_rate % rate || div < 1 || div > (SMD_MAX_DIV + 1))\r\nreturn -EINVAL;\r\ntmp = pmc_read(pmc, AT91_PMC_SMD) & ~AT91_PMC_SMD_DIV;\r\ntmp |= (div - 1) << SMD_DIV_SHIFT;\r\npmc_write(pmc, AT91_PMC_SMD, tmp);\r\nreturn 0;\r\n}\r\nstatic struct clk * __init\r\nat91sam9x5_clk_register_smd(struct at91_pmc *pmc, const char *name,\r\nconst char **parent_names, u8 num_parents)\r\n{\r\nstruct at91sam9x5_clk_smd *smd;\r\nstruct clk *clk = NULL;\r\nstruct clk_init_data init;\r\nsmd = kzalloc(sizeof(*smd), GFP_KERNEL);\r\nif (!smd)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &at91sam9x5_smd_ops;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\ninit.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE;\r\nsmd->hw.init = &init;\r\nsmd->pmc = pmc;\r\nclk = clk_register(NULL, &smd->hw);\r\nif (IS_ERR(clk))\r\nkfree(smd);\r\nreturn clk;\r\n}\r\nvoid __init of_at91sam9x5_clk_smd_setup(struct device_node *np,\r\nstruct at91_pmc *pmc)\r\n{\r\nstruct clk *clk;\r\nint num_parents;\r\nconst char *parent_names[SMD_SOURCE_MAX];\r\nconst char *name = np->name;\r\nnum_parents = of_clk_get_parent_count(np);\r\nif (num_parents <= 0 || num_parents > SMD_SOURCE_MAX)\r\nreturn;\r\nof_clk_parent_fill(np, parent_names, num_parents);\r\nof_property_read_string(np, "clock-output-names", &name);\r\nclk = at91sam9x5_clk_register_smd(pmc, name, parent_names,\r\nnum_parents);\r\nif (IS_ERR(clk))\r\nreturn;\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\n}
