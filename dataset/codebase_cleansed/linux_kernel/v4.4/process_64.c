void arch_cpu_idle(void)\r\n{\r\nif (tlb_type != hypervisor) {\r\ntouch_nmi_watchdog();\r\nlocal_irq_enable();\r\n} else {\r\nunsigned long pstate;\r\nlocal_irq_enable();\r\n__asm__ __volatile__(\r\n"rdpr %%pstate, %0\n\t"\r\n"andn %0, %1, %0\n\t"\r\n"wrpr %0, %%g0, %%pstate"\r\n: "=&r" (pstate)\r\n: "i" (PSTATE_IE));\r\nif (!need_resched() && !cpu_is_offline(smp_processor_id()))\r\nsun4v_cpu_yield();\r\n__asm__ __volatile__(\r\n"rdpr %%pstate, %0\n\t"\r\n"or %0, %1, %0\n\t"\r\n"wrpr %0, %%g0, %%pstate"\r\n: "=&r" (pstate)\r\n: "i" (PSTATE_IE));\r\n}\r\n}\r\nvoid arch_cpu_idle_dead(void)\r\n{\r\nsched_preempt_enable_no_resched();\r\ncpu_play_dead();\r\n}\r\nstatic void show_regwindow32(struct pt_regs *regs)\r\n{\r\nstruct reg_window32 __user *rw;\r\nstruct reg_window32 r_w;\r\nmm_segment_t old_fs;\r\n__asm__ __volatile__ ("flushw");\r\nrw = compat_ptr((unsigned)regs->u_regs[14]);\r\nold_fs = get_fs();\r\nset_fs (USER_DS);\r\nif (copy_from_user (&r_w, rw, sizeof(r_w))) {\r\nset_fs (old_fs);\r\nreturn;\r\n}\r\nset_fs (old_fs);\r\nprintk("l0: %08x l1: %08x l2: %08x l3: %08x "\r\n"l4: %08x l5: %08x l6: %08x l7: %08x\n",\r\nr_w.locals[0], r_w.locals[1], r_w.locals[2], r_w.locals[3],\r\nr_w.locals[4], r_w.locals[5], r_w.locals[6], r_w.locals[7]);\r\nprintk("i0: %08x i1: %08x i2: %08x i3: %08x "\r\n"i4: %08x i5: %08x i6: %08x i7: %08x\n",\r\nr_w.ins[0], r_w.ins[1], r_w.ins[2], r_w.ins[3],\r\nr_w.ins[4], r_w.ins[5], r_w.ins[6], r_w.ins[7]);\r\n}\r\nstatic void show_regwindow(struct pt_regs *regs)\r\n{\r\nstruct reg_window __user *rw;\r\nstruct reg_window *rwk;\r\nstruct reg_window r_w;\r\nmm_segment_t old_fs;\r\nif ((regs->tstate & TSTATE_PRIV) || !(test_thread_flag(TIF_32BIT))) {\r\n__asm__ __volatile__ ("flushw");\r\nrw = (struct reg_window __user *)\r\n(regs->u_regs[14] + STACK_BIAS);\r\nrwk = (struct reg_window *)\r\n(regs->u_regs[14] + STACK_BIAS);\r\nif (!(regs->tstate & TSTATE_PRIV)) {\r\nold_fs = get_fs();\r\nset_fs (USER_DS);\r\nif (copy_from_user (&r_w, rw, sizeof(r_w))) {\r\nset_fs (old_fs);\r\nreturn;\r\n}\r\nrwk = &r_w;\r\nset_fs (old_fs);\r\n}\r\n} else {\r\nshow_regwindow32(regs);\r\nreturn;\r\n}\r\nprintk("l0: %016lx l1: %016lx l2: %016lx l3: %016lx\n",\r\nrwk->locals[0], rwk->locals[1], rwk->locals[2], rwk->locals[3]);\r\nprintk("l4: %016lx l5: %016lx l6: %016lx l7: %016lx\n",\r\nrwk->locals[4], rwk->locals[5], rwk->locals[6], rwk->locals[7]);\r\nprintk("i0: %016lx i1: %016lx i2: %016lx i3: %016lx\n",\r\nrwk->ins[0], rwk->ins[1], rwk->ins[2], rwk->ins[3]);\r\nprintk("i4: %016lx i5: %016lx i6: %016lx i7: %016lx\n",\r\nrwk->ins[4], rwk->ins[5], rwk->ins[6], rwk->ins[7]);\r\nif (regs->tstate & TSTATE_PRIV)\r\nprintk("I7: <%pS>\n", (void *) rwk->ins[7]);\r\n}\r\nvoid show_regs(struct pt_regs *regs)\r\n{\r\nshow_regs_print_info(KERN_DEFAULT);\r\nprintk("TSTATE: %016lx TPC: %016lx TNPC: %016lx Y: %08x %s\n", regs->tstate,\r\nregs->tpc, regs->tnpc, regs->y, print_tainted());\r\nprintk("TPC: <%pS>\n", (void *) regs->tpc);\r\nprintk("g0: %016lx g1: %016lx g2: %016lx g3: %016lx\n",\r\nregs->u_regs[0], regs->u_regs[1], regs->u_regs[2],\r\nregs->u_regs[3]);\r\nprintk("g4: %016lx g5: %016lx g6: %016lx g7: %016lx\n",\r\nregs->u_regs[4], regs->u_regs[5], regs->u_regs[6],\r\nregs->u_regs[7]);\r\nprintk("o0: %016lx o1: %016lx o2: %016lx o3: %016lx\n",\r\nregs->u_regs[8], regs->u_regs[9], regs->u_regs[10],\r\nregs->u_regs[11]);\r\nprintk("o4: %016lx o5: %016lx sp: %016lx ret_pc: %016lx\n",\r\nregs->u_regs[12], regs->u_regs[13], regs->u_regs[14],\r\nregs->u_regs[15]);\r\nprintk("RPC: <%pS>\n", (void *) regs->u_regs[15]);\r\nshow_regwindow(regs);\r\nshow_stack(current, (unsigned long *) regs->u_regs[UREG_FP]);\r\n}\r\nstatic void __global_reg_self(struct thread_info *tp, struct pt_regs *regs,\r\nint this_cpu)\r\n{\r\nstruct global_reg_snapshot *rp;\r\nflushw_all();\r\nrp = &global_cpu_snapshot[this_cpu].reg;\r\nrp->tstate = regs->tstate;\r\nrp->tpc = regs->tpc;\r\nrp->tnpc = regs->tnpc;\r\nrp->o7 = regs->u_regs[UREG_I7];\r\nif (regs->tstate & TSTATE_PRIV) {\r\nstruct reg_window *rw;\r\nrw = (struct reg_window *)\r\n(regs->u_regs[UREG_FP] + STACK_BIAS);\r\nif (kstack_valid(tp, (unsigned long) rw)) {\r\nrp->i7 = rw->ins[7];\r\nrw = (struct reg_window *)\r\n(rw->ins[6] + STACK_BIAS);\r\nif (kstack_valid(tp, (unsigned long) rw))\r\nrp->rpc = rw->ins[7];\r\n}\r\n} else {\r\nrp->i7 = 0;\r\nrp->rpc = 0;\r\n}\r\nrp->thread = tp;\r\n}\r\nstatic void __global_reg_poll(struct global_reg_snapshot *gp)\r\n{\r\nint limit = 0;\r\nwhile (!gp->thread && ++limit < 100) {\r\nbarrier();\r\nudelay(1);\r\n}\r\n}\r\nvoid arch_trigger_all_cpu_backtrace(bool include_self)\r\n{\r\nstruct thread_info *tp = current_thread_info();\r\nstruct pt_regs *regs = get_irq_regs();\r\nunsigned long flags;\r\nint this_cpu, cpu;\r\nif (!regs)\r\nregs = tp->kregs;\r\nspin_lock_irqsave(&global_cpu_snapshot_lock, flags);\r\nthis_cpu = raw_smp_processor_id();\r\nmemset(global_cpu_snapshot, 0, sizeof(global_cpu_snapshot));\r\nif (include_self)\r\n__global_reg_self(tp, regs, this_cpu);\r\nsmp_fetch_global_regs();\r\nfor_each_online_cpu(cpu) {\r\nstruct global_reg_snapshot *gp;\r\nif (!include_self && cpu == this_cpu)\r\ncontinue;\r\ngp = &global_cpu_snapshot[cpu].reg;\r\n__global_reg_poll(gp);\r\ntp = gp->thread;\r\nprintk("%c CPU[%3d]: TSTATE[%016lx] TPC[%016lx] TNPC[%016lx] TASK[%s:%d]\n",\r\n(cpu == this_cpu ? '*' : ' '), cpu,\r\ngp->tstate, gp->tpc, gp->tnpc,\r\n((tp && tp->task) ? tp->task->comm : "NULL"),\r\n((tp && tp->task) ? tp->task->pid : -1));\r\nif (gp->tstate & TSTATE_PRIV) {\r\nprintk(" TPC[%pS] O7[%pS] I7[%pS] RPC[%pS]\n",\r\n(void *) gp->tpc,\r\n(void *) gp->o7,\r\n(void *) gp->i7,\r\n(void *) gp->rpc);\r\n} else {\r\nprintk(" TPC[%lx] O7[%lx] I7[%lx] RPC[%lx]\n",\r\ngp->tpc, gp->o7, gp->i7, gp->rpc);\r\n}\r\ntouch_nmi_watchdog();\r\n}\r\nmemset(global_cpu_snapshot, 0, sizeof(global_cpu_snapshot));\r\nspin_unlock_irqrestore(&global_cpu_snapshot_lock, flags);\r\n}\r\nstatic void sysrq_handle_globreg(int key)\r\n{\r\narch_trigger_all_cpu_backtrace(true);\r\n}\r\nstatic void __global_pmu_self(int this_cpu)\r\n{\r\nstruct global_pmu_snapshot *pp;\r\nint i, num;\r\nif (!pcr_ops)\r\nreturn;\r\npp = &global_cpu_snapshot[this_cpu].pmu;\r\nnum = 1;\r\nif (tlb_type == hypervisor &&\r\nsun4v_chip_type >= SUN4V_CHIP_NIAGARA4)\r\nnum = 4;\r\nfor (i = 0; i < num; i++) {\r\npp->pcr[i] = pcr_ops->read_pcr(i);\r\npp->pic[i] = pcr_ops->read_pic(i);\r\n}\r\n}\r\nstatic void __global_pmu_poll(struct global_pmu_snapshot *pp)\r\n{\r\nint limit = 0;\r\nwhile (!pp->pcr[0] && ++limit < 100) {\r\nbarrier();\r\nudelay(1);\r\n}\r\n}\r\nstatic void pmu_snapshot_all_cpus(void)\r\n{\r\nunsigned long flags;\r\nint this_cpu, cpu;\r\nspin_lock_irqsave(&global_cpu_snapshot_lock, flags);\r\nmemset(global_cpu_snapshot, 0, sizeof(global_cpu_snapshot));\r\nthis_cpu = raw_smp_processor_id();\r\n__global_pmu_self(this_cpu);\r\nsmp_fetch_global_pmu();\r\nfor_each_online_cpu(cpu) {\r\nstruct global_pmu_snapshot *pp = &global_cpu_snapshot[cpu].pmu;\r\n__global_pmu_poll(pp);\r\nprintk("%c CPU[%3d]: PCR[%08lx:%08lx:%08lx:%08lx] PIC[%08lx:%08lx:%08lx:%08lx]\n",\r\n(cpu == this_cpu ? '*' : ' '), cpu,\r\npp->pcr[0], pp->pcr[1], pp->pcr[2], pp->pcr[3],\r\npp->pic[0], pp->pic[1], pp->pic[2], pp->pic[3]);\r\ntouch_nmi_watchdog();\r\n}\r\nmemset(global_cpu_snapshot, 0, sizeof(global_cpu_snapshot));\r\nspin_unlock_irqrestore(&global_cpu_snapshot_lock, flags);\r\n}\r\nstatic void sysrq_handle_globpmu(int key)\r\n{\r\npmu_snapshot_all_cpus();\r\n}\r\nstatic int __init sparc_sysrq_init(void)\r\n{\r\nint ret = register_sysrq_key('y', &sparc_globalreg_op);\r\nif (!ret)\r\nret = register_sysrq_key('x', &sparc_globalpmu_op);\r\nreturn ret;\r\n}\r\nunsigned long thread_saved_pc(struct task_struct *tsk)\r\n{\r\nstruct thread_info *ti = task_thread_info(tsk);\r\nunsigned long ret = 0xdeadbeefUL;\r\nif (ti && ti->ksp) {\r\nunsigned long *sp;\r\nsp = (unsigned long *)(ti->ksp + STACK_BIAS);\r\nif (((unsigned long)sp & (sizeof(long) - 1)) == 0UL &&\r\nsp[14]) {\r\nunsigned long *fp;\r\nfp = (unsigned long *)(sp[14] + STACK_BIAS);\r\nif (((unsigned long)fp & (sizeof(long) - 1)) == 0UL)\r\nret = fp[15];\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid exit_thread(void)\r\n{\r\nstruct thread_info *t = current_thread_info();\r\nif (t->utraps) {\r\nif (t->utraps[0] < 2)\r\nkfree (t->utraps);\r\nelse\r\nt->utraps[0]--;\r\n}\r\n}\r\nvoid flush_thread(void)\r\n{\r\nstruct thread_info *t = current_thread_info();\r\nstruct mm_struct *mm;\r\nmm = t->task->mm;\r\nif (mm)\r\ntsb_context_switch(mm);\r\nset_thread_wsaved(0);\r\nt->fpsaved[0] = 0;\r\n}\r\nstatic unsigned long clone_stackframe(unsigned long csp, unsigned long psp)\r\n{\r\nbool stack_64bit = test_thread_64bit_stack(psp);\r\nunsigned long fp, distance, rval;\r\nif (stack_64bit) {\r\ncsp += STACK_BIAS;\r\npsp += STACK_BIAS;\r\n__get_user(fp, &(((struct reg_window __user *)psp)->ins[6]));\r\nfp += STACK_BIAS;\r\nif (test_thread_flag(TIF_32BIT))\r\nfp &= 0xffffffff;\r\n} else\r\n__get_user(fp, &(((struct reg_window32 __user *)psp)->ins[6]));\r\ncsp &= ~15UL;\r\ndistance = fp - psp;\r\nrval = (csp - distance);\r\nif (copy_in_user((void __user *) rval, (void __user *) psp, distance))\r\nrval = 0;\r\nelse if (!stack_64bit) {\r\nif (put_user(((u32)csp),\r\n&(((struct reg_window32 __user *)rval)->ins[6])))\r\nrval = 0;\r\n} else {\r\nif (put_user(((u64)csp - STACK_BIAS),\r\n&(((struct reg_window __user *)rval)->ins[6])))\r\nrval = 0;\r\nelse\r\nrval = rval - STACK_BIAS;\r\n}\r\nreturn rval;\r\n}\r\nstatic inline void shift_window_buffer(int first_win, int last_win,\r\nstruct thread_info *t)\r\n{\r\nint i;\r\nfor (i = first_win; i < last_win; i++) {\r\nt->rwbuf_stkptrs[i] = t->rwbuf_stkptrs[i+1];\r\nmemcpy(&t->reg_window[i], &t->reg_window[i+1],\r\nsizeof(struct reg_window));\r\n}\r\n}\r\nvoid synchronize_user_stack(void)\r\n{\r\nstruct thread_info *t = current_thread_info();\r\nunsigned long window;\r\nflush_user_windows();\r\nif ((window = get_thread_wsaved()) != 0) {\r\nwindow -= 1;\r\ndo {\r\nstruct reg_window *rwin = &t->reg_window[window];\r\nint winsize = sizeof(struct reg_window);\r\nunsigned long sp;\r\nsp = t->rwbuf_stkptrs[window];\r\nif (test_thread_64bit_stack(sp))\r\nsp += STACK_BIAS;\r\nelse\r\nwinsize = sizeof(struct reg_window32);\r\nif (!copy_to_user((char __user *)sp, rwin, winsize)) {\r\nshift_window_buffer(window, get_thread_wsaved() - 1, t);\r\nset_thread_wsaved(get_thread_wsaved() - 1);\r\n}\r\n} while (window--);\r\n}\r\n}\r\nstatic void stack_unaligned(unsigned long sp)\r\n{\r\nsiginfo_t info;\r\ninfo.si_signo = SIGBUS;\r\ninfo.si_errno = 0;\r\ninfo.si_code = BUS_ADRALN;\r\ninfo.si_addr = (void __user *) sp;\r\ninfo.si_trapno = 0;\r\nforce_sig_info(SIGBUS, &info, current);\r\n}\r\nvoid fault_in_user_windows(void)\r\n{\r\nstruct thread_info *t = current_thread_info();\r\nunsigned long window;\r\nflush_user_windows();\r\nwindow = get_thread_wsaved();\r\nif (likely(window != 0)) {\r\nwindow -= 1;\r\ndo {\r\nstruct reg_window *rwin = &t->reg_window[window];\r\nint winsize = sizeof(struct reg_window);\r\nunsigned long sp;\r\nsp = t->rwbuf_stkptrs[window];\r\nif (test_thread_64bit_stack(sp))\r\nsp += STACK_BIAS;\r\nelse\r\nwinsize = sizeof(struct reg_window32);\r\nif (unlikely(sp & 0x7UL))\r\nstack_unaligned(sp);\r\nif (unlikely(copy_to_user((char __user *)sp,\r\nrwin, winsize)))\r\ngoto barf;\r\n} while (window--);\r\n}\r\nset_thread_wsaved(0);\r\nreturn;\r\nbarf:\r\nset_thread_wsaved(window + 1);\r\nuser_exit();\r\ndo_exit(SIGILL);\r\n}\r\nasmlinkage long sparc_do_fork(unsigned long clone_flags,\r\nunsigned long stack_start,\r\nstruct pt_regs *regs,\r\nunsigned long stack_size)\r\n{\r\nint __user *parent_tid_ptr, *child_tid_ptr;\r\nunsigned long orig_i1 = regs->u_regs[UREG_I1];\r\nlong ret;\r\n#ifdef CONFIG_COMPAT\r\nif (test_thread_flag(TIF_32BIT)) {\r\nparent_tid_ptr = compat_ptr(regs->u_regs[UREG_I2]);\r\nchild_tid_ptr = compat_ptr(regs->u_regs[UREG_I4]);\r\n} else\r\n#endif\r\n{\r\nparent_tid_ptr = (int __user *) regs->u_regs[UREG_I2];\r\nchild_tid_ptr = (int __user *) regs->u_regs[UREG_I4];\r\n}\r\nret = do_fork(clone_flags, stack_start, stack_size,\r\nparent_tid_ptr, child_tid_ptr);\r\nif ((unsigned long)ret >= -ERESTART_RESTARTBLOCK)\r\nregs->u_regs[UREG_I1] = orig_i1;\r\nreturn ret;\r\n}\r\nint copy_thread(unsigned long clone_flags, unsigned long sp,\r\nunsigned long arg, struct task_struct *p)\r\n{\r\nstruct thread_info *t = task_thread_info(p);\r\nstruct pt_regs *regs = current_pt_regs();\r\nstruct sparc_stackf *parent_sf;\r\nunsigned long child_stack_sz;\r\nchar *child_trap_frame;\r\nchild_stack_sz = (STACKFRAME_SZ + TRACEREG_SZ);\r\nchild_trap_frame = (task_stack_page(p) +\r\n(THREAD_SIZE - child_stack_sz));\r\nt->new_child = 1;\r\nt->ksp = ((unsigned long) child_trap_frame) - STACK_BIAS;\r\nt->kregs = (struct pt_regs *) (child_trap_frame +\r\nsizeof(struct sparc_stackf));\r\nt->fpsaved[0] = 0;\r\nif (unlikely(p->flags & PF_KTHREAD)) {\r\nmemset(child_trap_frame, 0, child_stack_sz);\r\n__thread_flag_byte_ptr(t)[TI_FLAG_BYTE_CWP] =\r\n(current_pt_regs()->tstate + 1) & TSTATE_CWP;\r\nt->current_ds = ASI_P;\r\nt->kregs->u_regs[UREG_G1] = sp;\r\nt->kregs->u_regs[UREG_G2] = arg;\r\nreturn 0;\r\n}\r\nparent_sf = ((struct sparc_stackf *) regs) - 1;\r\nmemcpy(child_trap_frame, parent_sf, child_stack_sz);\r\nif (t->flags & _TIF_32BIT) {\r\nsp &= 0x00000000ffffffffUL;\r\nregs->u_regs[UREG_FP] &= 0x00000000ffffffffUL;\r\n}\r\nt->kregs->u_regs[UREG_FP] = sp;\r\n__thread_flag_byte_ptr(t)[TI_FLAG_BYTE_CWP] =\r\n(regs->tstate + 1) & TSTATE_CWP;\r\nt->current_ds = ASI_AIUS;\r\nif (sp != regs->u_regs[UREG_FP]) {\r\nunsigned long csp;\r\ncsp = clone_stackframe(sp, regs->u_regs[UREG_FP]);\r\nif (!csp)\r\nreturn -EFAULT;\r\nt->kregs->u_regs[UREG_FP] = csp;\r\n}\r\nif (t->utraps)\r\nt->utraps[0]++;\r\nt->kregs->u_regs[UREG_I0] = current->pid;\r\nt->kregs->u_regs[UREG_I1] = 1;\r\nregs->u_regs[UREG_I1] = 0;\r\nif (clone_flags & CLONE_SETTLS)\r\nt->kregs->u_regs[UREG_G7] = regs->u_regs[UREG_I3];\r\nreturn 0;\r\n}\r\nint dump_fpu (struct pt_regs * regs, elf_fpregset_t * fpregs)\r\n{\r\nunsigned long *kfpregs = current_thread_info()->fpregs;\r\nunsigned long fprs = current_thread_info()->fpsaved[0];\r\nif (test_thread_flag(TIF_32BIT)) {\r\nelf_fpregset_t32 *fpregs32 = (elf_fpregset_t32 *)fpregs;\r\nif (fprs & FPRS_DL)\r\nmemcpy(&fpregs32->pr_fr.pr_regs[0], kfpregs,\r\nsizeof(unsigned int) * 32);\r\nelse\r\nmemset(&fpregs32->pr_fr.pr_regs[0], 0,\r\nsizeof(unsigned int) * 32);\r\nfpregs32->pr_qcnt = 0;\r\nfpregs32->pr_q_entrysize = 8;\r\nmemset(&fpregs32->pr_q[0], 0,\r\n(sizeof(unsigned int) * 64));\r\nif (fprs & FPRS_FEF) {\r\nfpregs32->pr_fsr = (unsigned int) current_thread_info()->xfsr[0];\r\nfpregs32->pr_en = 1;\r\n} else {\r\nfpregs32->pr_fsr = 0;\r\nfpregs32->pr_en = 0;\r\n}\r\n} else {\r\nif(fprs & FPRS_DL)\r\nmemcpy(&fpregs->pr_regs[0], kfpregs,\r\nsizeof(unsigned int) * 32);\r\nelse\r\nmemset(&fpregs->pr_regs[0], 0,\r\nsizeof(unsigned int) * 32);\r\nif(fprs & FPRS_DU)\r\nmemcpy(&fpregs->pr_regs[16], kfpregs+16,\r\nsizeof(unsigned int) * 32);\r\nelse\r\nmemset(&fpregs->pr_regs[16], 0,\r\nsizeof(unsigned int) * 32);\r\nif(fprs & FPRS_FEF) {\r\nfpregs->pr_fsr = current_thread_info()->xfsr[0];\r\nfpregs->pr_gsr = current_thread_info()->gsr[0];\r\n} else {\r\nfpregs->pr_fsr = fpregs->pr_gsr = 0;\r\n}\r\nfpregs->pr_fprs = fprs;\r\n}\r\nreturn 1;\r\n}\r\nunsigned long get_wchan(struct task_struct *task)\r\n{\r\nunsigned long pc, fp, bias = 0;\r\nstruct thread_info *tp;\r\nstruct reg_window *rw;\r\nunsigned long ret = 0;\r\nint count = 0;\r\nif (!task || task == current ||\r\ntask->state == TASK_RUNNING)\r\ngoto out;\r\ntp = task_thread_info(task);\r\nbias = STACK_BIAS;\r\nfp = task_thread_info(task)->ksp + bias;\r\ndo {\r\nif (!kstack_valid(tp, fp))\r\nbreak;\r\nrw = (struct reg_window *) fp;\r\npc = rw->ins[7];\r\nif (!in_sched_functions(pc)) {\r\nret = pc;\r\ngoto out;\r\n}\r\nfp = rw->ins[6] + bias;\r\n} while (++count < 16);\r\nout:\r\nreturn ret;\r\n}
