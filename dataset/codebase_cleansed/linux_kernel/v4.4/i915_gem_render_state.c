static const struct intel_renderstate_rodata *\r\nrender_state_get_rodata(struct drm_device *dev, const int gen)\r\n{\r\nswitch (gen) {\r\ncase 6:\r\nreturn &gen6_null_state;\r\ncase 7:\r\nreturn &gen7_null_state;\r\ncase 8:\r\nreturn &gen8_null_state;\r\ncase 9:\r\nreturn &gen9_null_state;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int render_state_init(struct render_state *so, struct drm_device *dev)\r\n{\r\nint ret;\r\nso->gen = INTEL_INFO(dev)->gen;\r\nso->rodata = render_state_get_rodata(dev, so->gen);\r\nif (so->rodata == NULL)\r\nreturn 0;\r\nif (so->rodata->batch_items * 4 > 4096)\r\nreturn -EINVAL;\r\nso->obj = i915_gem_alloc_object(dev, 4096);\r\nif (so->obj == NULL)\r\nreturn -ENOMEM;\r\nret = i915_gem_obj_ggtt_pin(so->obj, 4096, 0);\r\nif (ret)\r\ngoto free_gem;\r\nso->ggtt_offset = i915_gem_obj_ggtt_offset(so->obj);\r\nreturn 0;\r\nfree_gem:\r\ndrm_gem_object_unreference(&so->obj->base);\r\nreturn ret;\r\n}\r\nstatic int render_state_setup(struct render_state *so)\r\n{\r\nconst struct intel_renderstate_rodata *rodata = so->rodata;\r\nunsigned int i = 0, reloc_index = 0;\r\nstruct page *page;\r\nu32 *d;\r\nint ret;\r\nret = i915_gem_object_set_to_cpu_domain(so->obj, true);\r\nif (ret)\r\nreturn ret;\r\npage = sg_page(so->obj->pages->sgl);\r\nd = kmap(page);\r\nwhile (i < rodata->batch_items) {\r\nu32 s = rodata->batch[i];\r\nif (i * 4 == rodata->reloc[reloc_index]) {\r\nu64 r = s + so->ggtt_offset;\r\ns = lower_32_bits(r);\r\nif (so->gen >= 8) {\r\nif (i + 1 >= rodata->batch_items ||\r\nrodata->batch[i + 1] != 0) {\r\nret = -EINVAL;\r\ngoto err_out;\r\n}\r\nd[i++] = s;\r\ns = upper_32_bits(r);\r\n}\r\nreloc_index++;\r\n}\r\nd[i++] = s;\r\n}\r\nwhile (i % CACHELINE_DWORDS)\r\nOUT_BATCH(d, i, MI_NOOP);\r\nso->aux_batch_offset = i * sizeof(u32);\r\nOUT_BATCH(d, i, MI_BATCH_BUFFER_END);\r\nso->aux_batch_size = (i * sizeof(u32)) - so->aux_batch_offset;\r\nso->aux_batch_size = ALIGN(so->aux_batch_size, 8);\r\nkunmap(page);\r\nret = i915_gem_object_set_to_gtt_domain(so->obj, false);\r\nif (ret)\r\nreturn ret;\r\nif (rodata->reloc[reloc_index] != -1) {\r\nDRM_ERROR("only %d relocs resolved\n", reloc_index);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\nerr_out:\r\nkunmap(page);\r\nreturn ret;\r\n}\r\nvoid i915_gem_render_state_fini(struct render_state *so)\r\n{\r\ni915_gem_object_ggtt_unpin(so->obj);\r\ndrm_gem_object_unreference(&so->obj->base);\r\n}\r\nint i915_gem_render_state_prepare(struct intel_engine_cs *ring,\r\nstruct render_state *so)\r\n{\r\nint ret;\r\nif (WARN_ON(ring->id != RCS))\r\nreturn -ENOENT;\r\nret = render_state_init(so, ring->dev);\r\nif (ret)\r\nreturn ret;\r\nif (so->rodata == NULL)\r\nreturn 0;\r\nret = render_state_setup(so);\r\nif (ret) {\r\ni915_gem_render_state_fini(so);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint i915_gem_render_state_init(struct drm_i915_gem_request *req)\r\n{\r\nstruct render_state so;\r\nint ret;\r\nret = i915_gem_render_state_prepare(req->ring, &so);\r\nif (ret)\r\nreturn ret;\r\nif (so.rodata == NULL)\r\nreturn 0;\r\nret = req->ring->dispatch_execbuffer(req, so.ggtt_offset,\r\nso.rodata->batch_items * 4,\r\nI915_DISPATCH_SECURE);\r\nif (ret)\r\ngoto out;\r\nif (so.aux_batch_size > 8) {\r\nret = req->ring->dispatch_execbuffer(req,\r\n(so.ggtt_offset +\r\nso.aux_batch_offset),\r\nso.aux_batch_size,\r\nI915_DISPATCH_SECURE);\r\nif (ret)\r\ngoto out;\r\n}\r\ni915_vma_move_to_active(i915_gem_obj_to_ggtt(so.obj), req);\r\nout:\r\ni915_gem_render_state_fini(&so);\r\nreturn ret;\r\n}
