static void atmel_ac97c_dma_playback_period_done(void *arg)\r\n{\r\nstruct atmel_ac97c *chip = arg;\r\nsnd_pcm_period_elapsed(chip->playback_substream);\r\n}\r\nstatic void atmel_ac97c_dma_capture_period_done(void *arg)\r\n{\r\nstruct atmel_ac97c *chip = arg;\r\nsnd_pcm_period_elapsed(chip->capture_substream);\r\n}\r\nstatic int atmel_ac97c_prepare_dma(struct atmel_ac97c *chip,\r\nstruct snd_pcm_substream *substream,\r\nenum dma_transfer_direction direction)\r\n{\r\nstruct dma_chan *chan;\r\nstruct dw_cyclic_desc *cdesc;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned long buffer_len, period_len;\r\nif (runtime->dma_addr & 1 || runtime->buffer_size & 1) {\r\ndev_dbg(&chip->pdev->dev, "too complex transfer\n");\r\nreturn -EINVAL;\r\n}\r\nif (direction == DMA_MEM_TO_DEV)\r\nchan = chip->dma.tx_chan;\r\nelse\r\nchan = chip->dma.rx_chan;\r\nbuffer_len = frames_to_bytes(runtime, runtime->buffer_size);\r\nperiod_len = frames_to_bytes(runtime, runtime->period_size);\r\ncdesc = dw_dma_cyclic_prep(chan, runtime->dma_addr, buffer_len,\r\nperiod_len, direction);\r\nif (IS_ERR(cdesc)) {\r\ndev_dbg(&chip->pdev->dev, "could not prepare cyclic DMA\n");\r\nreturn PTR_ERR(cdesc);\r\n}\r\nif (direction == DMA_MEM_TO_DEV) {\r\ncdesc->period_callback = atmel_ac97c_dma_playback_period_done;\r\nset_bit(DMA_TX_READY, &chip->flags);\r\n} else {\r\ncdesc->period_callback = atmel_ac97c_dma_capture_period_done;\r\nset_bit(DMA_RX_READY, &chip->flags);\r\n}\r\ncdesc->period_callback_param = chip;\r\nreturn 0;\r\n}\r\nstatic int atmel_ac97c_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nmutex_lock(&opened_mutex);\r\nchip->opened++;\r\nruntime->hw = atmel_ac97c_hw;\r\nif (chip->cur_rate) {\r\nruntime->hw.rate_min = chip->cur_rate;\r\nruntime->hw.rate_max = chip->cur_rate;\r\n}\r\nif (chip->cur_format)\r\nruntime->hw.formats = pcm_format_to_bits(chip->cur_format);\r\nmutex_unlock(&opened_mutex);\r\nchip->playback_substream = substream;\r\nreturn 0;\r\n}\r\nstatic int atmel_ac97c_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nmutex_lock(&opened_mutex);\r\nchip->opened++;\r\nruntime->hw = atmel_ac97c_hw;\r\nif (chip->cur_rate) {\r\nruntime->hw.rate_min = chip->cur_rate;\r\nruntime->hw.rate_max = chip->cur_rate;\r\n}\r\nif (chip->cur_format)\r\nruntime->hw.formats = pcm_format_to_bits(chip->cur_format);\r\nmutex_unlock(&opened_mutex);\r\nchip->capture_substream = substream;\r\nreturn 0;\r\n}\r\nstatic int atmel_ac97c_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\r\nmutex_lock(&opened_mutex);\r\nchip->opened--;\r\nif (!chip->opened) {\r\nchip->cur_rate = 0;\r\nchip->cur_format = 0;\r\n}\r\nmutex_unlock(&opened_mutex);\r\nchip->playback_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int atmel_ac97c_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\r\nmutex_lock(&opened_mutex);\r\nchip->opened--;\r\nif (!chip->opened) {\r\nchip->cur_rate = 0;\r\nchip->cur_format = 0;\r\n}\r\nmutex_unlock(&opened_mutex);\r\nchip->capture_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int atmel_ac97c_playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\r\nint retval;\r\nretval = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (retval < 0)\r\nreturn retval;\r\nif (cpu_is_at32ap7000()) {\r\nif (retval == 1)\r\nif (test_and_clear_bit(DMA_TX_READY, &chip->flags))\r\ndw_dma_cyclic_free(chip->dma.tx_chan);\r\n}\r\nmutex_lock(&opened_mutex);\r\nchip->cur_rate = params_rate(hw_params);\r\nchip->cur_format = params_format(hw_params);\r\nmutex_unlock(&opened_mutex);\r\nreturn retval;\r\n}\r\nstatic int atmel_ac97c_capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\r\nint retval;\r\nretval = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (retval < 0)\r\nreturn retval;\r\nif (cpu_is_at32ap7000() && retval == 1)\r\nif (test_and_clear_bit(DMA_RX_READY, &chip->flags))\r\ndw_dma_cyclic_free(chip->dma.rx_chan);\r\nmutex_lock(&opened_mutex);\r\nchip->cur_rate = params_rate(hw_params);\r\nchip->cur_format = params_format(hw_params);\r\nmutex_unlock(&opened_mutex);\r\nreturn retval;\r\n}\r\nstatic int atmel_ac97c_playback_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\r\nif (cpu_is_at32ap7000()) {\r\nif (test_and_clear_bit(DMA_TX_READY, &chip->flags))\r\ndw_dma_cyclic_free(chip->dma.tx_chan);\r\n}\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int atmel_ac97c_capture_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\r\nif (cpu_is_at32ap7000()) {\r\nif (test_and_clear_bit(DMA_RX_READY, &chip->flags))\r\ndw_dma_cyclic_free(chip->dma.rx_chan);\r\n}\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int atmel_ac97c_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint block_size = frames_to_bytes(runtime, runtime->period_size);\r\nunsigned long word = ac97c_readl(chip, OCA);\r\nint retval;\r\nchip->playback_period = 0;\r\nword &= ~(AC97C_CH_MASK(PCM_LEFT) | AC97C_CH_MASK(PCM_RIGHT));\r\nswitch (runtime->channels) {\r\ncase 1:\r\nword |= AC97C_CH_ASSIGN(PCM_LEFT, A);\r\nbreak;\r\ncase 2:\r\nword |= AC97C_CH_ASSIGN(PCM_LEFT, A)\r\n| AC97C_CH_ASSIGN(PCM_RIGHT, A);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nac97c_writel(chip, OCA, word);\r\nword = ac97c_readl(chip, CAMR);\r\nif (chip->opened <= 1)\r\nword = AC97C_CMR_DMAEN | AC97C_CMR_SIZE_16;\r\nelse\r\nword |= AC97C_CMR_DMAEN | AC97C_CMR_SIZE_16;\r\nswitch (runtime->format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nif (cpu_is_at32ap7000())\r\nword |= AC97C_CMR_CEM_LITTLE;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_BE:\r\nword &= ~(AC97C_CMR_CEM_LITTLE);\r\nbreak;\r\ndefault:\r\nword = ac97c_readl(chip, OCA);\r\nword &= ~(AC97C_CH_MASK(PCM_LEFT) | AC97C_CH_MASK(PCM_RIGHT));\r\nac97c_writel(chip, OCA, word);\r\nreturn -EINVAL;\r\n}\r\nword |= AC97C_CSR_UNRUN;\r\nac97c_writel(chip, CAMR, word);\r\nword = ac97c_readl(chip, IMR);\r\nword |= AC97C_SR_CAEVT;\r\nac97c_writel(chip, IER, word);\r\nif (runtime->rate != 48000) {\r\nword = ac97c_readl(chip, MR);\r\nword |= AC97C_MR_VRA;\r\nac97c_writel(chip, MR, word);\r\n} else {\r\nword = ac97c_readl(chip, MR);\r\nword &= ~(AC97C_MR_VRA);\r\nac97c_writel(chip, MR, word);\r\n}\r\nretval = snd_ac97_set_rate(chip->ac97, AC97_PCM_FRONT_DAC_RATE,\r\nruntime->rate);\r\nif (retval)\r\ndev_dbg(&chip->pdev->dev, "could not set rate %d Hz\n",\r\nruntime->rate);\r\nif (cpu_is_at32ap7000()) {\r\nif (!test_bit(DMA_TX_READY, &chip->flags))\r\nretval = atmel_ac97c_prepare_dma(chip, substream,\r\nDMA_MEM_TO_DEV);\r\n} else {\r\nwritel(runtime->dma_addr, chip->regs + ATMEL_PDC_TPR);\r\nwritel(block_size / 2, chip->regs + ATMEL_PDC_TCR);\r\nwritel(runtime->dma_addr + block_size,\r\nchip->regs + ATMEL_PDC_TNPR);\r\nwritel(block_size / 2, chip->regs + ATMEL_PDC_TNCR);\r\n}\r\nreturn retval;\r\n}\r\nstatic int atmel_ac97c_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint block_size = frames_to_bytes(runtime, runtime->period_size);\r\nunsigned long word = ac97c_readl(chip, ICA);\r\nint retval;\r\nchip->capture_period = 0;\r\nword &= ~(AC97C_CH_MASK(PCM_LEFT) | AC97C_CH_MASK(PCM_RIGHT));\r\nswitch (runtime->channels) {\r\ncase 1:\r\nword |= AC97C_CH_ASSIGN(PCM_LEFT, A);\r\nbreak;\r\ncase 2:\r\nword |= AC97C_CH_ASSIGN(PCM_LEFT, A)\r\n| AC97C_CH_ASSIGN(PCM_RIGHT, A);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nac97c_writel(chip, ICA, word);\r\nword = ac97c_readl(chip, CAMR);\r\nif (chip->opened <= 1)\r\nword = AC97C_CMR_DMAEN | AC97C_CMR_SIZE_16;\r\nelse\r\nword |= AC97C_CMR_DMAEN | AC97C_CMR_SIZE_16;\r\nswitch (runtime->format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nif (cpu_is_at32ap7000())\r\nword |= AC97C_CMR_CEM_LITTLE;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_BE:\r\nword &= ~(AC97C_CMR_CEM_LITTLE);\r\nbreak;\r\ndefault:\r\nword = ac97c_readl(chip, ICA);\r\nword &= ~(AC97C_CH_MASK(PCM_LEFT) | AC97C_CH_MASK(PCM_RIGHT));\r\nac97c_writel(chip, ICA, word);\r\nreturn -EINVAL;\r\n}\r\nword |= AC97C_CSR_OVRUN;\r\nac97c_writel(chip, CAMR, word);\r\nword = ac97c_readl(chip, IMR);\r\nword |= AC97C_SR_CAEVT;\r\nac97c_writel(chip, IER, word);\r\nif (runtime->rate != 48000) {\r\nword = ac97c_readl(chip, MR);\r\nword |= AC97C_MR_VRA;\r\nac97c_writel(chip, MR, word);\r\n} else {\r\nword = ac97c_readl(chip, MR);\r\nword &= ~(AC97C_MR_VRA);\r\nac97c_writel(chip, MR, word);\r\n}\r\nretval = snd_ac97_set_rate(chip->ac97, AC97_PCM_LR_ADC_RATE,\r\nruntime->rate);\r\nif (retval)\r\ndev_dbg(&chip->pdev->dev, "could not set rate %d Hz\n",\r\nruntime->rate);\r\nif (cpu_is_at32ap7000()) {\r\nif (!test_bit(DMA_RX_READY, &chip->flags))\r\nretval = atmel_ac97c_prepare_dma(chip, substream,\r\nDMA_DEV_TO_MEM);\r\n} else {\r\nwritel(runtime->dma_addr, chip->regs + ATMEL_PDC_RPR);\r\nwritel(block_size / 2, chip->regs + ATMEL_PDC_RCR);\r\nwritel(runtime->dma_addr + block_size,\r\nchip->regs + ATMEL_PDC_RNPR);\r\nwritel(block_size / 2, chip->regs + ATMEL_PDC_RNCR);\r\n}\r\nreturn retval;\r\n}\r\nstatic int\r\natmel_ac97c_playback_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\r\nunsigned long camr, ptcr = 0;\r\nint retval = 0;\r\ncamr = ac97c_readl(chip, CAMR);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif (cpu_is_at32ap7000()) {\r\nretval = dw_dma_cyclic_start(chip->dma.tx_chan);\r\nif (retval)\r\ngoto out;\r\n} else {\r\nptcr = ATMEL_PDC_TXTEN;\r\n}\r\ncamr |= AC97C_CMR_CENA | AC97C_CSR_ENDTX;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nif (cpu_is_at32ap7000())\r\ndw_dma_cyclic_stop(chip->dma.tx_chan);\r\nelse\r\nptcr |= ATMEL_PDC_TXTDIS;\r\nif (chip->opened <= 1)\r\ncamr &= ~AC97C_CMR_CENA;\r\nbreak;\r\ndefault:\r\nretval = -EINVAL;\r\ngoto out;\r\n}\r\nac97c_writel(chip, CAMR, camr);\r\nif (!cpu_is_at32ap7000())\r\nwritel(ptcr, chip->regs + ATMEL_PDC_PTCR);\r\nout:\r\nreturn retval;\r\n}\r\nstatic int\r\natmel_ac97c_capture_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\r\nunsigned long camr, ptcr = 0;\r\nint retval = 0;\r\ncamr = ac97c_readl(chip, CAMR);\r\nptcr = readl(chip->regs + ATMEL_PDC_PTSR);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif (cpu_is_at32ap7000()) {\r\nretval = dw_dma_cyclic_start(chip->dma.rx_chan);\r\nif (retval)\r\ngoto out;\r\n} else {\r\nptcr = ATMEL_PDC_RXTEN;\r\n}\r\ncamr |= AC97C_CMR_CENA | AC97C_CSR_ENDRX;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nif (cpu_is_at32ap7000())\r\ndw_dma_cyclic_stop(chip->dma.rx_chan);\r\nelse\r\nptcr |= (ATMEL_PDC_RXTDIS);\r\nif (chip->opened <= 1)\r\ncamr &= ~AC97C_CMR_CENA;\r\nbreak;\r\ndefault:\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\nac97c_writel(chip, CAMR, camr);\r\nif (!cpu_is_at32ap7000())\r\nwritel(ptcr, chip->regs + ATMEL_PDC_PTCR);\r\nout:\r\nreturn retval;\r\n}\r\nstatic snd_pcm_uframes_t\r\natmel_ac97c_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_uframes_t frames;\r\nunsigned long bytes;\r\nif (cpu_is_at32ap7000())\r\nbytes = dw_dma_get_src_addr(chip->dma.tx_chan);\r\nelse\r\nbytes = readl(chip->regs + ATMEL_PDC_TPR);\r\nbytes -= runtime->dma_addr;\r\nframes = bytes_to_frames(runtime, bytes);\r\nif (frames >= runtime->buffer_size)\r\nframes -= runtime->buffer_size;\r\nreturn frames;\r\n}\r\nstatic snd_pcm_uframes_t\r\natmel_ac97c_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_uframes_t frames;\r\nunsigned long bytes;\r\nif (cpu_is_at32ap7000())\r\nbytes = dw_dma_get_dst_addr(chip->dma.rx_chan);\r\nelse\r\nbytes = readl(chip->regs + ATMEL_PDC_RPR);\r\nbytes -= runtime->dma_addr;\r\nframes = bytes_to_frames(runtime, bytes);\r\nif (frames >= runtime->buffer_size)\r\nframes -= runtime->buffer_size;\r\nreturn frames;\r\n}\r\nstatic irqreturn_t atmel_ac97c_interrupt(int irq, void *dev)\r\n{\r\nstruct atmel_ac97c *chip = (struct atmel_ac97c *)dev;\r\nirqreturn_t retval = IRQ_NONE;\r\nu32 sr = ac97c_readl(chip, SR);\r\nu32 casr = ac97c_readl(chip, CASR);\r\nu32 cosr = ac97c_readl(chip, COSR);\r\nu32 camr = ac97c_readl(chip, CAMR);\r\nif (sr & AC97C_SR_CAEVT) {\r\nstruct snd_pcm_runtime *runtime;\r\nint offset, next_period, block_size;\r\ndev_dbg(&chip->pdev->dev, "channel A event%s%s%s%s%s%s\n",\r\ncasr & AC97C_CSR_OVRUN ? " OVRUN" : "",\r\ncasr & AC97C_CSR_RXRDY ? " RXRDY" : "",\r\ncasr & AC97C_CSR_UNRUN ? " UNRUN" : "",\r\ncasr & AC97C_CSR_TXEMPTY ? " TXEMPTY" : "",\r\ncasr & AC97C_CSR_TXRDY ? " TXRDY" : "",\r\n!casr ? " NONE" : "");\r\nif (!cpu_is_at32ap7000()) {\r\nif ((casr & camr) & AC97C_CSR_ENDTX) {\r\nruntime = chip->playback_substream->runtime;\r\nblock_size = frames_to_bytes(runtime,\r\nruntime->period_size);\r\nchip->playback_period++;\r\nif (chip->playback_period == runtime->periods)\r\nchip->playback_period = 0;\r\nnext_period = chip->playback_period + 1;\r\nif (next_period == runtime->periods)\r\nnext_period = 0;\r\noffset = block_size * next_period;\r\nwritel(runtime->dma_addr + offset,\r\nchip->regs + ATMEL_PDC_TNPR);\r\nwritel(block_size / 2,\r\nchip->regs + ATMEL_PDC_TNCR);\r\nsnd_pcm_period_elapsed(\r\nchip->playback_substream);\r\n}\r\nif ((casr & camr) & AC97C_CSR_ENDRX) {\r\nruntime = chip->capture_substream->runtime;\r\nblock_size = frames_to_bytes(runtime,\r\nruntime->period_size);\r\nchip->capture_period++;\r\nif (chip->capture_period == runtime->periods)\r\nchip->capture_period = 0;\r\nnext_period = chip->capture_period + 1;\r\nif (next_period == runtime->periods)\r\nnext_period = 0;\r\noffset = block_size * next_period;\r\nwritel(runtime->dma_addr + offset,\r\nchip->regs + ATMEL_PDC_RNPR);\r\nwritel(block_size / 2,\r\nchip->regs + ATMEL_PDC_RNCR);\r\nsnd_pcm_period_elapsed(chip->capture_substream);\r\n}\r\n}\r\nretval = IRQ_HANDLED;\r\n}\r\nif (sr & AC97C_SR_COEVT) {\r\ndev_info(&chip->pdev->dev, "codec channel event%s%s%s%s%s\n",\r\ncosr & AC97C_CSR_OVRUN ? " OVRUN" : "",\r\ncosr & AC97C_CSR_RXRDY ? " RXRDY" : "",\r\ncosr & AC97C_CSR_TXEMPTY ? " TXEMPTY" : "",\r\ncosr & AC97C_CSR_TXRDY ? " TXRDY" : "",\r\n!cosr ? " NONE" : "");\r\nretval = IRQ_HANDLED;\r\n}\r\nif (retval == IRQ_NONE) {\r\ndev_err(&chip->pdev->dev, "spurious interrupt sr 0x%08x "\r\n"casr 0x%08x cosr 0x%08x\n", sr, casr, cosr);\r\n}\r\nreturn retval;\r\n}\r\nstatic int atmel_ac97c_pcm_new(struct atmel_ac97c *chip)\r\n{\r\nstruct snd_pcm *pcm;\r\nstruct snd_pcm_hardware hw = atmel_ac97c_hw;\r\nint capture, playback, retval, err;\r\ncapture = test_bit(DMA_RX_CHAN_PRESENT, &chip->flags);\r\nplayback = test_bit(DMA_TX_CHAN_PRESENT, &chip->flags);\r\nif (!cpu_is_at32ap7000()) {\r\nerr = snd_ac97_pcm_assign(chip->ac97_bus,\r\nARRAY_SIZE(at91_ac97_pcm_defs),\r\nat91_ac97_pcm_defs);\r\nif (err)\r\nreturn err;\r\n}\r\nretval = snd_pcm_new(chip->card, chip->card->shortname,\r\n0, playback, capture, &pcm);\r\nif (retval)\r\nreturn retval;\r\nif (capture)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&atmel_ac97_capture_ops);\r\nif (playback)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&atmel_ac97_playback_ops);\r\nretval = snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\n&chip->pdev->dev, hw.periods_min * hw.period_bytes_min,\r\nhw.buffer_bytes_max);\r\nif (retval)\r\nreturn retval;\r\npcm->private_data = chip;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, chip->card->shortname);\r\nchip->pcm = pcm;\r\nreturn 0;\r\n}\r\nstatic int atmel_ac97c_mixer_new(struct atmel_ac97c *chip)\r\n{\r\nstruct snd_ac97_template template;\r\nmemset(&template, 0, sizeof(template));\r\ntemplate.private_data = chip;\r\nreturn snd_ac97_mixer(chip->ac97_bus, &template, &chip->ac97);\r\n}\r\nstatic void atmel_ac97c_write(struct snd_ac97 *ac97, unsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct atmel_ac97c *chip = get_chip(ac97);\r\nunsigned long word;\r\nint timeout = 40;\r\nword = (reg & 0x7f) << 16 | val;\r\ndo {\r\nif (ac97c_readl(chip, COSR) & AC97C_CSR_TXRDY) {\r\nac97c_writel(chip, COTHR, word);\r\nreturn;\r\n}\r\nudelay(1);\r\n} while (--timeout);\r\ndev_dbg(&chip->pdev->dev, "codec write timeout\n");\r\n}\r\nstatic unsigned short atmel_ac97c_read(struct snd_ac97 *ac97,\r\nunsigned short reg)\r\n{\r\nstruct atmel_ac97c *chip = get_chip(ac97);\r\nunsigned long word;\r\nint timeout = 40;\r\nint write = 10;\r\nword = (0x80 | (reg & 0x7f)) << 16;\r\nif ((ac97c_readl(chip, COSR) & AC97C_CSR_RXRDY) != 0)\r\nac97c_readl(chip, CORHR);\r\nretry_write:\r\ntimeout = 40;\r\ndo {\r\nif ((ac97c_readl(chip, COSR) & AC97C_CSR_TXRDY) != 0) {\r\nac97c_writel(chip, COTHR, word);\r\ngoto read_reg;\r\n}\r\nudelay(10);\r\n} while (--timeout);\r\nif (!--write)\r\ngoto timed_out;\r\ngoto retry_write;\r\nread_reg:\r\ndo {\r\nif ((ac97c_readl(chip, COSR) & AC97C_CSR_RXRDY) != 0) {\r\nunsigned short val = ac97c_readl(chip, CORHR);\r\nreturn val;\r\n}\r\nudelay(10);\r\n} while (--timeout);\r\nif (!--write)\r\ngoto timed_out;\r\ngoto retry_write;\r\ntimed_out:\r\ndev_dbg(&chip->pdev->dev, "codec read timeout\n");\r\nreturn 0xffff;\r\n}\r\nstatic bool filter(struct dma_chan *chan, void *slave)\r\n{\r\nstruct dw_dma_slave *dws = slave;\r\nif (dws->dma_dev == chan->device->dev) {\r\nchan->private = dws;\r\nreturn true;\r\n} else\r\nreturn false;\r\n}\r\nstatic void atmel_ac97c_reset(struct atmel_ac97c *chip)\r\n{\r\nac97c_writel(chip, MR, 0);\r\nac97c_writel(chip, MR, AC97C_MR_ENA);\r\nac97c_writel(chip, CAMR, 0);\r\nac97c_writel(chip, COMR, 0);\r\nif (gpio_is_valid(chip->reset_pin)) {\r\ngpio_set_value(chip->reset_pin, 0);\r\nudelay(2);\r\ngpio_set_value(chip->reset_pin, 1);\r\n} else {\r\nac97c_writel(chip, MR, AC97C_MR_WRST | AC97C_MR_ENA);\r\nudelay(2);\r\nac97c_writel(chip, MR, AC97C_MR_ENA);\r\n}\r\n}\r\nstatic struct ac97c_platform_data *atmel_ac97c_probe_dt(struct device *dev)\r\n{\r\nstruct ac97c_platform_data *pdata;\r\nstruct device_node *node = dev->of_node;\r\nif (!node) {\r\ndev_err(dev, "Device does not have associated DT data\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\npdata->reset_pin = of_get_named_gpio(dev->of_node, "ac97-gpios", 2);\r\nreturn pdata;\r\n}\r\nstatic struct ac97c_platform_data *atmel_ac97c_probe_dt(struct device *dev)\r\n{\r\ndev_err(dev, "no platform data defined\n");\r\nreturn ERR_PTR(-ENXIO);\r\n}\r\nstatic int atmel_ac97c_probe(struct platform_device *pdev)\r\n{\r\nstruct snd_card *card;\r\nstruct atmel_ac97c *chip;\r\nstruct resource *regs;\r\nstruct ac97c_platform_data *pdata;\r\nstruct clk *pclk;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = atmel_ac97c_write,\r\n.read = atmel_ac97c_read,\r\n};\r\nint retval;\r\nint irq;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!regs) {\r\ndev_dbg(&pdev->dev, "no memory resource\n");\r\nreturn -ENXIO;\r\n}\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (!pdata) {\r\npdata = atmel_ac97c_probe_dt(&pdev->dev);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_dbg(&pdev->dev, "could not get irq\n");\r\nreturn -ENXIO;\r\n}\r\nif (cpu_is_at32ap7000()) {\r\npclk = clk_get(&pdev->dev, "pclk");\r\n} else {\r\npclk = clk_get(&pdev->dev, "ac97_clk");\r\n}\r\nif (IS_ERR(pclk)) {\r\ndev_dbg(&pdev->dev, "no peripheral clock\n");\r\nreturn PTR_ERR(pclk);\r\n}\r\nclk_prepare_enable(pclk);\r\nretval = snd_card_new(&pdev->dev, SNDRV_DEFAULT_IDX1,\r\nSNDRV_DEFAULT_STR1, THIS_MODULE,\r\nsizeof(struct atmel_ac97c), &card);\r\nif (retval) {\r\ndev_dbg(&pdev->dev, "could not create sound card device\n");\r\ngoto err_snd_card_new;\r\n}\r\nchip = get_chip(card);\r\nretval = request_irq(irq, atmel_ac97c_interrupt, 0, "AC97C", chip);\r\nif (retval) {\r\ndev_dbg(&pdev->dev, "unable to request irq %d\n", irq);\r\ngoto err_request_irq;\r\n}\r\nchip->irq = irq;\r\nspin_lock_init(&chip->lock);\r\nstrcpy(card->driver, "Atmel AC97C");\r\nstrcpy(card->shortname, "Atmel AC97C");\r\nsprintf(card->longname, "Atmel AC97 controller");\r\nchip->card = card;\r\nchip->pclk = pclk;\r\nchip->pdev = pdev;\r\nchip->regs = ioremap(regs->start, resource_size(regs));\r\nif (!chip->regs) {\r\ndev_dbg(&pdev->dev, "could not remap register memory\n");\r\nretval = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\nif (gpio_is_valid(pdata->reset_pin)) {\r\nif (gpio_request(pdata->reset_pin, "reset_pin")) {\r\ndev_dbg(&pdev->dev, "reset pin not available\n");\r\nchip->reset_pin = -ENODEV;\r\n} else {\r\ngpio_direction_output(pdata->reset_pin, 1);\r\nchip->reset_pin = pdata->reset_pin;\r\n}\r\n} else {\r\nchip->reset_pin = -EINVAL;\r\n}\r\natmel_ac97c_reset(chip);\r\nac97c_writel(chip, COMR, AC97C_CSR_OVRUN);\r\nac97c_writel(chip, IER, ac97c_readl(chip, IMR) | AC97C_SR_COEVT);\r\nretval = snd_ac97_bus(card, 0, &ops, chip, &chip->ac97_bus);\r\nif (retval) {\r\ndev_dbg(&pdev->dev, "could not register on ac97 bus\n");\r\ngoto err_ac97_bus;\r\n}\r\nretval = atmel_ac97c_mixer_new(chip);\r\nif (retval) {\r\ndev_dbg(&pdev->dev, "could not register ac97 mixer\n");\r\ngoto err_ac97_bus;\r\n}\r\nif (cpu_is_at32ap7000()) {\r\nif (pdata->rx_dws.dma_dev) {\r\ndma_cap_mask_t mask;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nchip->dma.rx_chan = dma_request_channel(mask, filter,\r\n&pdata->rx_dws);\r\nif (chip->dma.rx_chan) {\r\nstruct dma_slave_config dma_conf = {\r\n.src_addr = regs->start + AC97C_CARHR +\r\n2,\r\n.src_addr_width =\r\nDMA_SLAVE_BUSWIDTH_2_BYTES,\r\n.src_maxburst = 1,\r\n.dst_maxburst = 1,\r\n.direction = DMA_DEV_TO_MEM,\r\n.device_fc = false,\r\n};\r\ndmaengine_slave_config(chip->dma.rx_chan,\r\n&dma_conf);\r\n}\r\ndev_info(&chip->pdev->dev, "using %s for DMA RX\n",\r\ndev_name(&chip->dma.rx_chan->dev->device));\r\nset_bit(DMA_RX_CHAN_PRESENT, &chip->flags);\r\n}\r\nif (pdata->tx_dws.dma_dev) {\r\ndma_cap_mask_t mask;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nchip->dma.tx_chan = dma_request_channel(mask, filter,\r\n&pdata->tx_dws);\r\nif (chip->dma.tx_chan) {\r\nstruct dma_slave_config dma_conf = {\r\n.dst_addr = regs->start + AC97C_CATHR +\r\n2,\r\n.dst_addr_width =\r\nDMA_SLAVE_BUSWIDTH_2_BYTES,\r\n.src_maxburst = 1,\r\n.dst_maxburst = 1,\r\n.direction = DMA_MEM_TO_DEV,\r\n.device_fc = false,\r\n};\r\ndmaengine_slave_config(chip->dma.tx_chan,\r\n&dma_conf);\r\n}\r\ndev_info(&chip->pdev->dev, "using %s for DMA TX\n",\r\ndev_name(&chip->dma.tx_chan->dev->device));\r\nset_bit(DMA_TX_CHAN_PRESENT, &chip->flags);\r\n}\r\nif (!test_bit(DMA_RX_CHAN_PRESENT, &chip->flags) &&\r\n!test_bit(DMA_TX_CHAN_PRESENT, &chip->flags)) {\r\ndev_dbg(&pdev->dev, "DMA not available\n");\r\nretval = -ENODEV;\r\ngoto err_dma;\r\n}\r\n} else {\r\nset_bit(DMA_RX_CHAN_PRESENT, &chip->flags);\r\nset_bit(DMA_TX_CHAN_PRESENT, &chip->flags);\r\n}\r\nretval = atmel_ac97c_pcm_new(chip);\r\nif (retval) {\r\ndev_dbg(&pdev->dev, "could not register ac97 pcm device\n");\r\ngoto err_dma;\r\n}\r\nretval = snd_card_register(card);\r\nif (retval) {\r\ndev_dbg(&pdev->dev, "could not register sound card\n");\r\ngoto err_dma;\r\n}\r\nplatform_set_drvdata(pdev, card);\r\ndev_info(&pdev->dev, "Atmel AC97 controller at 0x%p, irq = %d\n",\r\nchip->regs, irq);\r\nreturn 0;\r\nerr_dma:\r\nif (cpu_is_at32ap7000()) {\r\nif (test_bit(DMA_RX_CHAN_PRESENT, &chip->flags))\r\ndma_release_channel(chip->dma.rx_chan);\r\nif (test_bit(DMA_TX_CHAN_PRESENT, &chip->flags))\r\ndma_release_channel(chip->dma.tx_chan);\r\nclear_bit(DMA_RX_CHAN_PRESENT, &chip->flags);\r\nclear_bit(DMA_TX_CHAN_PRESENT, &chip->flags);\r\nchip->dma.rx_chan = NULL;\r\nchip->dma.tx_chan = NULL;\r\n}\r\nerr_ac97_bus:\r\nif (gpio_is_valid(chip->reset_pin))\r\ngpio_free(chip->reset_pin);\r\niounmap(chip->regs);\r\nerr_ioremap:\r\nfree_irq(irq, chip);\r\nerr_request_irq:\r\nsnd_card_free(card);\r\nerr_snd_card_new:\r\nclk_disable_unprepare(pclk);\r\nclk_put(pclk);\r\nreturn retval;\r\n}\r\nstatic int atmel_ac97c_suspend(struct device *pdev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(pdev);\r\nstruct atmel_ac97c *chip = card->private_data;\r\nif (cpu_is_at32ap7000()) {\r\nif (test_bit(DMA_RX_READY, &chip->flags))\r\ndw_dma_cyclic_stop(chip->dma.rx_chan);\r\nif (test_bit(DMA_TX_READY, &chip->flags))\r\ndw_dma_cyclic_stop(chip->dma.tx_chan);\r\n}\r\nclk_disable_unprepare(chip->pclk);\r\nreturn 0;\r\n}\r\nstatic int atmel_ac97c_resume(struct device *pdev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(pdev);\r\nstruct atmel_ac97c *chip = card->private_data;\r\nclk_prepare_enable(chip->pclk);\r\nif (cpu_is_at32ap7000()) {\r\nif (test_bit(DMA_RX_READY, &chip->flags))\r\ndw_dma_cyclic_start(chip->dma.rx_chan);\r\nif (test_bit(DMA_TX_READY, &chip->flags))\r\ndw_dma_cyclic_start(chip->dma.tx_chan);\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_ac97c_remove(struct platform_device *pdev)\r\n{\r\nstruct snd_card *card = platform_get_drvdata(pdev);\r\nstruct atmel_ac97c *chip = get_chip(card);\r\nif (gpio_is_valid(chip->reset_pin))\r\ngpio_free(chip->reset_pin);\r\nac97c_writel(chip, CAMR, 0);\r\nac97c_writel(chip, COMR, 0);\r\nac97c_writel(chip, MR, 0);\r\nclk_disable_unprepare(chip->pclk);\r\nclk_put(chip->pclk);\r\niounmap(chip->regs);\r\nfree_irq(chip->irq, chip);\r\nif (cpu_is_at32ap7000()) {\r\nif (test_bit(DMA_RX_CHAN_PRESENT, &chip->flags))\r\ndma_release_channel(chip->dma.rx_chan);\r\nif (test_bit(DMA_TX_CHAN_PRESENT, &chip->flags))\r\ndma_release_channel(chip->dma.tx_chan);\r\nclear_bit(DMA_RX_CHAN_PRESENT, &chip->flags);\r\nclear_bit(DMA_TX_CHAN_PRESENT, &chip->flags);\r\nchip->dma.rx_chan = NULL;\r\nchip->dma.tx_chan = NULL;\r\n}\r\nsnd_card_free(card);\r\nreturn 0;\r\n}
