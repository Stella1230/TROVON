static void __led_pwm_set(struct led_pwm_data *led_dat)\r\n{\r\nint new_duty = led_dat->duty;\r\npwm_config(led_dat->pwm, new_duty, led_dat->period);\r\nif (new_duty == 0)\r\npwm_disable(led_dat->pwm);\r\nelse\r\npwm_enable(led_dat->pwm);\r\n}\r\nstatic void led_pwm_work(struct work_struct *work)\r\n{\r\nstruct led_pwm_data *led_dat =\r\ncontainer_of(work, struct led_pwm_data, work);\r\n__led_pwm_set(led_dat);\r\n}\r\nstatic void led_pwm_set(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct led_pwm_data *led_dat =\r\ncontainer_of(led_cdev, struct led_pwm_data, cdev);\r\nunsigned int max = led_dat->cdev.max_brightness;\r\nunsigned long long duty = led_dat->period;\r\nduty *= brightness;\r\ndo_div(duty, max);\r\nif (led_dat->active_low)\r\nduty = led_dat->period - duty;\r\nled_dat->duty = duty;\r\nif (led_dat->can_sleep)\r\nschedule_work(&led_dat->work);\r\nelse\r\n__led_pwm_set(led_dat);\r\n}\r\nstatic inline size_t sizeof_pwm_leds_priv(int num_leds)\r\n{\r\nreturn sizeof(struct led_pwm_priv) +\r\n(sizeof(struct led_pwm_data) * num_leds);\r\n}\r\nstatic void led_pwm_cleanup(struct led_pwm_priv *priv)\r\n{\r\nwhile (priv->num_leds--) {\r\nled_classdev_unregister(&priv->leds[priv->num_leds].cdev);\r\nif (priv->leds[priv->num_leds].can_sleep)\r\ncancel_work_sync(&priv->leds[priv->num_leds].work);\r\n}\r\n}\r\nstatic int led_pwm_add(struct device *dev, struct led_pwm_priv *priv,\r\nstruct led_pwm *led, struct device_node *child)\r\n{\r\nstruct led_pwm_data *led_data = &priv->leds[priv->num_leds];\r\nint ret;\r\nled_data->active_low = led->active_low;\r\nled_data->cdev.name = led->name;\r\nled_data->cdev.default_trigger = led->default_trigger;\r\nled_data->cdev.brightness_set = led_pwm_set;\r\nled_data->cdev.brightness = LED_OFF;\r\nled_data->cdev.max_brightness = led->max_brightness;\r\nled_data->cdev.flags = LED_CORE_SUSPENDRESUME;\r\nif (child)\r\nled_data->pwm = devm_of_pwm_get(dev, child, NULL);\r\nelse\r\nled_data->pwm = devm_pwm_get(dev, led->name);\r\nif (IS_ERR(led_data->pwm)) {\r\nret = PTR_ERR(led_data->pwm);\r\ndev_err(dev, "unable to request PWM for %s: %d\n",\r\nled->name, ret);\r\nreturn ret;\r\n}\r\nled_data->can_sleep = pwm_can_sleep(led_data->pwm);\r\nif (led_data->can_sleep)\r\nINIT_WORK(&led_data->work, led_pwm_work);\r\nled_data->period = pwm_get_period(led_data->pwm);\r\nif (!led_data->period && (led->pwm_period_ns > 0))\r\nled_data->period = led->pwm_period_ns;\r\nret = led_classdev_register(dev, &led_data->cdev);\r\nif (ret == 0) {\r\npriv->num_leds++;\r\n} else {\r\ndev_err(dev, "failed to register PWM led for %s: %d\n",\r\nled->name, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int led_pwm_create_of(struct device *dev, struct led_pwm_priv *priv)\r\n{\r\nstruct device_node *child;\r\nstruct led_pwm led;\r\nint ret = 0;\r\nmemset(&led, 0, sizeof(led));\r\nfor_each_child_of_node(dev->of_node, child) {\r\nled.name = of_get_property(child, "label", NULL) ? :\r\nchild->name;\r\nled.default_trigger = of_get_property(child,\r\n"linux,default-trigger", NULL);\r\nled.active_low = of_property_read_bool(child, "active-low");\r\nof_property_read_u32(child, "max-brightness",\r\n&led.max_brightness);\r\nret = led_pwm_add(dev, priv, &led, child);\r\nif (ret) {\r\nof_node_put(child);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int led_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct led_pwm_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct led_pwm_priv *priv;\r\nint count, i;\r\nint ret = 0;\r\nif (pdata)\r\ncount = pdata->num_leds;\r\nelse\r\ncount = of_get_child_count(pdev->dev.of_node);\r\nif (!count)\r\nreturn -EINVAL;\r\npriv = devm_kzalloc(&pdev->dev, sizeof_pwm_leds_priv(count),\r\nGFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nif (pdata) {\r\nfor (i = 0; i < count; i++) {\r\nret = led_pwm_add(&pdev->dev, priv, &pdata->leds[i],\r\nNULL);\r\nif (ret)\r\nbreak;\r\n}\r\n} else {\r\nret = led_pwm_create_of(&pdev->dev, priv);\r\n}\r\nif (ret) {\r\nled_pwm_cleanup(priv);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nreturn 0;\r\n}\r\nstatic int led_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct led_pwm_priv *priv = platform_get_drvdata(pdev);\r\nled_pwm_cleanup(priv);\r\nreturn 0;\r\n}
