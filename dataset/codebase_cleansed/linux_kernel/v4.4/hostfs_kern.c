static inline struct hostfs_inode_info *HOSTFS_I(struct inode *inode)\r\n{\r\nreturn list_entry(inode, struct hostfs_inode_info, vfs_inode);\r\n}\r\nstatic int __init hostfs_args(char *options, int *add)\r\n{\r\nchar *ptr;\r\nptr = strchr(options, ',');\r\nif (ptr != NULL)\r\n*ptr++ = '\0';\r\nif (*options != '\0')\r\nroot_ino = options;\r\noptions = ptr;\r\nwhile (options) {\r\nptr = strchr(options, ',');\r\nif (ptr != NULL)\r\n*ptr++ = '\0';\r\nif (*options != '\0') {\r\nif (!strcmp(options, "append"))\r\nappend = 1;\r\nelse printf("hostfs_args - unsupported option - %s\n",\r\noptions);\r\n}\r\noptions = ptr;\r\n}\r\nreturn 0;\r\n}\r\nstatic char *__dentry_name(struct dentry *dentry, char *name)\r\n{\r\nchar *p = dentry_path_raw(dentry, name, PATH_MAX);\r\nchar *root;\r\nsize_t len;\r\nroot = dentry->d_sb->s_fs_info;\r\nlen = strlen(root);\r\nif (IS_ERR(p)) {\r\n__putname(name);\r\nreturn NULL;\r\n}\r\nBUG_ON(p + strlen(p) + 1 != name + PATH_MAX);\r\nstrlcpy(name, root, PATH_MAX);\r\nif (len > p - name) {\r\n__putname(name);\r\nreturn NULL;\r\n}\r\nif (p > name + len)\r\nstrcpy(name + len, p);\r\nreturn name;\r\n}\r\nstatic char *dentry_name(struct dentry *dentry)\r\n{\r\nchar *name = __getname();\r\nif (!name)\r\nreturn NULL;\r\nreturn __dentry_name(dentry, name);\r\n}\r\nstatic char *inode_name(struct inode *ino)\r\n{\r\nstruct dentry *dentry;\r\nchar *name;\r\ndentry = d_find_alias(ino);\r\nif (!dentry)\r\nreturn NULL;\r\nname = dentry_name(dentry);\r\ndput(dentry);\r\nreturn name;\r\n}\r\nstatic char *follow_link(char *link)\r\n{\r\nint len, n;\r\nchar *name, *resolved, *end;\r\nname = __getname();\r\nif (!name) {\r\nn = -ENOMEM;\r\ngoto out_free;\r\n}\r\nn = hostfs_do_readlink(link, name, PATH_MAX);\r\nif (n < 0)\r\ngoto out_free;\r\nelse if (n == PATH_MAX) {\r\nn = -E2BIG;\r\ngoto out_free;\r\n}\r\nif (*name == '/')\r\nreturn name;\r\nend = strrchr(link, '/');\r\nif (end == NULL)\r\nreturn name;\r\n*(end + 1) = '\0';\r\nlen = strlen(link) + strlen(name) + 1;\r\nresolved = kmalloc(len, GFP_KERNEL);\r\nif (resolved == NULL) {\r\nn = -ENOMEM;\r\ngoto out_free;\r\n}\r\nsprintf(resolved, "%s%s", link, name);\r\n__putname(name);\r\nkfree(link);\r\nreturn resolved;\r\nout_free:\r\n__putname(name);\r\nreturn ERR_PTR(n);\r\n}\r\nstatic struct inode *hostfs_iget(struct super_block *sb)\r\n{\r\nstruct inode *inode = new_inode(sb);\r\nif (!inode)\r\nreturn ERR_PTR(-ENOMEM);\r\nreturn inode;\r\n}\r\nstatic int hostfs_statfs(struct dentry *dentry, struct kstatfs *sf)\r\n{\r\nint err;\r\nlong long f_blocks;\r\nlong long f_bfree;\r\nlong long f_bavail;\r\nlong long f_files;\r\nlong long f_ffree;\r\nerr = do_statfs(dentry->d_sb->s_fs_info,\r\n&sf->f_bsize, &f_blocks, &f_bfree, &f_bavail, &f_files,\r\n&f_ffree, &sf->f_fsid, sizeof(sf->f_fsid),\r\n&sf->f_namelen);\r\nif (err)\r\nreturn err;\r\nsf->f_blocks = f_blocks;\r\nsf->f_bfree = f_bfree;\r\nsf->f_bavail = f_bavail;\r\nsf->f_files = f_files;\r\nsf->f_ffree = f_ffree;\r\nsf->f_type = HOSTFS_SUPER_MAGIC;\r\nreturn 0;\r\n}\r\nstatic struct inode *hostfs_alloc_inode(struct super_block *sb)\r\n{\r\nstruct hostfs_inode_info *hi;\r\nhi = kmalloc(sizeof(*hi), GFP_KERNEL);\r\nif (hi == NULL)\r\nreturn NULL;\r\nhi->fd = -1;\r\nhi->mode = 0;\r\ninode_init_once(&hi->vfs_inode);\r\nmutex_init(&hi->open_mutex);\r\nreturn &hi->vfs_inode;\r\n}\r\nstatic void hostfs_evict_inode(struct inode *inode)\r\n{\r\ntruncate_inode_pages_final(&inode->i_data);\r\nclear_inode(inode);\r\nif (HOSTFS_I(inode)->fd != -1) {\r\nclose_file(&HOSTFS_I(inode)->fd);\r\nHOSTFS_I(inode)->fd = -1;\r\n}\r\n}\r\nstatic void hostfs_i_callback(struct rcu_head *head)\r\n{\r\nstruct inode *inode = container_of(head, struct inode, i_rcu);\r\nkfree(HOSTFS_I(inode));\r\n}\r\nstatic void hostfs_destroy_inode(struct inode *inode)\r\n{\r\ncall_rcu(&inode->i_rcu, hostfs_i_callback);\r\n}\r\nstatic int hostfs_show_options(struct seq_file *seq, struct dentry *root)\r\n{\r\nconst char *root_path = root->d_sb->s_fs_info;\r\nsize_t offset = strlen(root_ino) + 1;\r\nif (strlen(root_path) > offset)\r\nseq_show_option(seq, root_path + offset, NULL);\r\nif (append)\r\nseq_puts(seq, ",append");\r\nreturn 0;\r\n}\r\nstatic int hostfs_readdir(struct file *file, struct dir_context *ctx)\r\n{\r\nvoid *dir;\r\nchar *name;\r\nunsigned long long next, ino;\r\nint error, len;\r\nunsigned int type;\r\nname = dentry_name(file->f_path.dentry);\r\nif (name == NULL)\r\nreturn -ENOMEM;\r\ndir = open_dir(name, &error);\r\n__putname(name);\r\nif (dir == NULL)\r\nreturn -error;\r\nnext = ctx->pos;\r\nseek_dir(dir, next);\r\nwhile ((name = read_dir(dir, &next, &ino, &len, &type)) != NULL) {\r\nif (!dir_emit(ctx, name, len, ino, type))\r\nbreak;\r\nctx->pos = next;\r\n}\r\nclose_dir(dir);\r\nreturn 0;\r\n}\r\nstatic int hostfs_open(struct inode *ino, struct file *file)\r\n{\r\nchar *name;\r\nfmode_t mode;\r\nint err;\r\nint r, w, fd;\r\nmode = file->f_mode & (FMODE_READ | FMODE_WRITE);\r\nif ((mode & HOSTFS_I(ino)->mode) == mode)\r\nreturn 0;\r\nmode |= HOSTFS_I(ino)->mode;\r\nretry:\r\nr = w = 0;\r\nif (mode & FMODE_READ)\r\nr = 1;\r\nif (mode & FMODE_WRITE)\r\nr = w = 1;\r\nname = dentry_name(file->f_path.dentry);\r\nif (name == NULL)\r\nreturn -ENOMEM;\r\nfd = open_file(name, r, w, append);\r\n__putname(name);\r\nif (fd < 0)\r\nreturn fd;\r\nmutex_lock(&HOSTFS_I(ino)->open_mutex);\r\nif ((mode & HOSTFS_I(ino)->mode) == mode) {\r\nmutex_unlock(&HOSTFS_I(ino)->open_mutex);\r\nclose_file(&fd);\r\nreturn 0;\r\n}\r\nif ((mode | HOSTFS_I(ino)->mode) != mode) {\r\nmode |= HOSTFS_I(ino)->mode;\r\nmutex_unlock(&HOSTFS_I(ino)->open_mutex);\r\nclose_file(&fd);\r\ngoto retry;\r\n}\r\nif (HOSTFS_I(ino)->fd == -1) {\r\nHOSTFS_I(ino)->fd = fd;\r\n} else {\r\nerr = replace_file(fd, HOSTFS_I(ino)->fd);\r\nclose_file(&fd);\r\nif (err < 0) {\r\nmutex_unlock(&HOSTFS_I(ino)->open_mutex);\r\nreturn err;\r\n}\r\n}\r\nHOSTFS_I(ino)->mode = mode;\r\nmutex_unlock(&HOSTFS_I(ino)->open_mutex);\r\nreturn 0;\r\n}\r\nstatic int hostfs_file_release(struct inode *inode, struct file *file)\r\n{\r\nfilemap_write_and_wait(inode->i_mapping);\r\nreturn 0;\r\n}\r\nstatic int hostfs_fsync(struct file *file, loff_t start, loff_t end,\r\nint datasync)\r\n{\r\nstruct inode *inode = file->f_mapping->host;\r\nint ret;\r\nret = filemap_write_and_wait_range(inode->i_mapping, start, end);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&inode->i_mutex);\r\nret = fsync_file(HOSTFS_I(inode)->fd, datasync);\r\nmutex_unlock(&inode->i_mutex);\r\nreturn ret;\r\n}\r\nstatic int hostfs_writepage(struct page *page, struct writeback_control *wbc)\r\n{\r\nstruct address_space *mapping = page->mapping;\r\nstruct inode *inode = mapping->host;\r\nchar *buffer;\r\nloff_t base = page_offset(page);\r\nint count = PAGE_CACHE_SIZE;\r\nint end_index = inode->i_size >> PAGE_CACHE_SHIFT;\r\nint err;\r\nif (page->index >= end_index)\r\ncount = inode->i_size & (PAGE_CACHE_SIZE-1);\r\nbuffer = kmap(page);\r\nerr = write_file(HOSTFS_I(inode)->fd, &base, buffer, count);\r\nif (err != count) {\r\nClearPageUptodate(page);\r\ngoto out;\r\n}\r\nif (base > inode->i_size)\r\ninode->i_size = base;\r\nif (PageError(page))\r\nClearPageError(page);\r\nerr = 0;\r\nout:\r\nkunmap(page);\r\nunlock_page(page);\r\nreturn err;\r\n}\r\nstatic int hostfs_readpage(struct file *file, struct page *page)\r\n{\r\nchar *buffer;\r\nloff_t start = page_offset(page);\r\nint bytes_read, ret = 0;\r\nbuffer = kmap(page);\r\nbytes_read = read_file(FILE_HOSTFS_I(file)->fd, &start, buffer,\r\nPAGE_CACHE_SIZE);\r\nif (bytes_read < 0) {\r\nClearPageUptodate(page);\r\nSetPageError(page);\r\nret = bytes_read;\r\ngoto out;\r\n}\r\nmemset(buffer + bytes_read, 0, PAGE_CACHE_SIZE - bytes_read);\r\nClearPageError(page);\r\nSetPageUptodate(page);\r\nout:\r\nflush_dcache_page(page);\r\nkunmap(page);\r\nunlock_page(page);\r\nreturn ret;\r\n}\r\nstatic int hostfs_write_begin(struct file *file, struct address_space *mapping,\r\nloff_t pos, unsigned len, unsigned flags,\r\nstruct page **pagep, void **fsdata)\r\n{\r\npgoff_t index = pos >> PAGE_CACHE_SHIFT;\r\n*pagep = grab_cache_page_write_begin(mapping, index, flags);\r\nif (!*pagep)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int hostfs_write_end(struct file *file, struct address_space *mapping,\r\nloff_t pos, unsigned len, unsigned copied,\r\nstruct page *page, void *fsdata)\r\n{\r\nstruct inode *inode = mapping->host;\r\nvoid *buffer;\r\nunsigned from = pos & (PAGE_CACHE_SIZE - 1);\r\nint err;\r\nbuffer = kmap(page);\r\nerr = write_file(FILE_HOSTFS_I(file)->fd, &pos, buffer + from, copied);\r\nkunmap(page);\r\nif (!PageUptodate(page) && err == PAGE_CACHE_SIZE)\r\nSetPageUptodate(page);\r\nif (err > 0 && (pos > inode->i_size))\r\ninode->i_size = pos;\r\nunlock_page(page);\r\npage_cache_release(page);\r\nreturn err;\r\n}\r\nstatic int read_name(struct inode *ino, char *name)\r\n{\r\ndev_t rdev;\r\nstruct hostfs_stat st;\r\nint err = stat_file(name, &st, -1);\r\nif (err)\r\nreturn err;\r\nrdev = MKDEV(st.maj, st.min);\r\nswitch (st.mode & S_IFMT) {\r\ncase S_IFLNK:\r\nino->i_op = &hostfs_link_iops;\r\nbreak;\r\ncase S_IFDIR:\r\nino->i_op = &hostfs_dir_iops;\r\nino->i_fop = &hostfs_dir_fops;\r\nbreak;\r\ncase S_IFCHR:\r\ncase S_IFBLK:\r\ncase S_IFIFO:\r\ncase S_IFSOCK:\r\ninit_special_inode(ino, st.mode & S_IFMT, rdev);\r\nino->i_op = &hostfs_iops;\r\nbreak;\r\ncase S_IFREG:\r\nino->i_op = &hostfs_iops;\r\nino->i_fop = &hostfs_file_fops;\r\nino->i_mapping->a_ops = &hostfs_aops;\r\nbreak;\r\ndefault:\r\nreturn -EIO;\r\n}\r\nino->i_ino = st.ino;\r\nino->i_mode = st.mode;\r\nset_nlink(ino, st.nlink);\r\ni_uid_write(ino, st.uid);\r\ni_gid_write(ino, st.gid);\r\nino->i_atime = st.atime;\r\nino->i_mtime = st.mtime;\r\nino->i_ctime = st.ctime;\r\nino->i_size = st.size;\r\nino->i_blocks = st.blocks;\r\nreturn 0;\r\n}\r\nstatic int hostfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\r\nbool excl)\r\n{\r\nstruct inode *inode;\r\nchar *name;\r\nint error, fd;\r\ninode = hostfs_iget(dir->i_sb);\r\nif (IS_ERR(inode)) {\r\nerror = PTR_ERR(inode);\r\ngoto out;\r\n}\r\nerror = -ENOMEM;\r\nname = dentry_name(dentry);\r\nif (name == NULL)\r\ngoto out_put;\r\nfd = file_create(name, mode & 0777);\r\nif (fd < 0)\r\nerror = fd;\r\nelse\r\nerror = read_name(inode, name);\r\n__putname(name);\r\nif (error)\r\ngoto out_put;\r\nHOSTFS_I(inode)->fd = fd;\r\nHOSTFS_I(inode)->mode = FMODE_READ | FMODE_WRITE;\r\nd_instantiate(dentry, inode);\r\nreturn 0;\r\nout_put:\r\niput(inode);\r\nout:\r\nreturn error;\r\n}\r\nstatic struct dentry *hostfs_lookup(struct inode *ino, struct dentry *dentry,\r\nunsigned int flags)\r\n{\r\nstruct inode *inode;\r\nchar *name;\r\nint err;\r\ninode = hostfs_iget(ino->i_sb);\r\nif (IS_ERR(inode)) {\r\nerr = PTR_ERR(inode);\r\ngoto out;\r\n}\r\nerr = -ENOMEM;\r\nname = dentry_name(dentry);\r\nif (name == NULL)\r\ngoto out_put;\r\nerr = read_name(inode, name);\r\n__putname(name);\r\nif (err == -ENOENT) {\r\niput(inode);\r\ninode = NULL;\r\n}\r\nelse if (err)\r\ngoto out_put;\r\nd_add(dentry, inode);\r\nreturn NULL;\r\nout_put:\r\niput(inode);\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int hostfs_link(struct dentry *to, struct inode *ino,\r\nstruct dentry *from)\r\n{\r\nchar *from_name, *to_name;\r\nint err;\r\nif ((from_name = dentry_name(from)) == NULL)\r\nreturn -ENOMEM;\r\nto_name = dentry_name(to);\r\nif (to_name == NULL) {\r\n__putname(from_name);\r\nreturn -ENOMEM;\r\n}\r\nerr = link_file(to_name, from_name);\r\n__putname(from_name);\r\n__putname(to_name);\r\nreturn err;\r\n}\r\nstatic int hostfs_unlink(struct inode *ino, struct dentry *dentry)\r\n{\r\nchar *file;\r\nint err;\r\nif (append)\r\nreturn -EPERM;\r\nif ((file = dentry_name(dentry)) == NULL)\r\nreturn -ENOMEM;\r\nerr = unlink_file(file);\r\n__putname(file);\r\nreturn err;\r\n}\r\nstatic int hostfs_symlink(struct inode *ino, struct dentry *dentry,\r\nconst char *to)\r\n{\r\nchar *file;\r\nint err;\r\nif ((file = dentry_name(dentry)) == NULL)\r\nreturn -ENOMEM;\r\nerr = make_symlink(file, to);\r\n__putname(file);\r\nreturn err;\r\n}\r\nstatic int hostfs_mkdir(struct inode *ino, struct dentry *dentry, umode_t mode)\r\n{\r\nchar *file;\r\nint err;\r\nif ((file = dentry_name(dentry)) == NULL)\r\nreturn -ENOMEM;\r\nerr = do_mkdir(file, mode);\r\n__putname(file);\r\nreturn err;\r\n}\r\nstatic int hostfs_rmdir(struct inode *ino, struct dentry *dentry)\r\n{\r\nchar *file;\r\nint err;\r\nif ((file = dentry_name(dentry)) == NULL)\r\nreturn -ENOMEM;\r\nerr = do_rmdir(file);\r\n__putname(file);\r\nreturn err;\r\n}\r\nstatic int hostfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\r\n{\r\nstruct inode *inode;\r\nchar *name;\r\nint err;\r\ninode = hostfs_iget(dir->i_sb);\r\nif (IS_ERR(inode)) {\r\nerr = PTR_ERR(inode);\r\ngoto out;\r\n}\r\nerr = -ENOMEM;\r\nname = dentry_name(dentry);\r\nif (name == NULL)\r\ngoto out_put;\r\ninit_special_inode(inode, mode, dev);\r\nerr = do_mknod(name, mode, MAJOR(dev), MINOR(dev));\r\nif (!err)\r\ngoto out_free;\r\nerr = read_name(inode, name);\r\n__putname(name);\r\nif (err)\r\ngoto out_put;\r\nif (err)\r\ngoto out_put;\r\nd_instantiate(dentry, inode);\r\nreturn 0;\r\nout_free:\r\n__putname(name);\r\nout_put:\r\niput(inode);\r\nout:\r\nreturn err;\r\n}\r\nstatic int hostfs_rename2(struct inode *old_dir, struct dentry *old_dentry,\r\nstruct inode *new_dir, struct dentry *new_dentry,\r\nunsigned int flags)\r\n{\r\nchar *old_name, *new_name;\r\nint err;\r\nif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))\r\nreturn -EINVAL;\r\nold_name = dentry_name(old_dentry);\r\nif (old_name == NULL)\r\nreturn -ENOMEM;\r\nnew_name = dentry_name(new_dentry);\r\nif (new_name == NULL) {\r\n__putname(old_name);\r\nreturn -ENOMEM;\r\n}\r\nif (!flags)\r\nerr = rename_file(old_name, new_name);\r\nelse\r\nerr = rename2_file(old_name, new_name, flags);\r\n__putname(old_name);\r\n__putname(new_name);\r\nreturn err;\r\n}\r\nstatic int hostfs_permission(struct inode *ino, int desired)\r\n{\r\nchar *name;\r\nint r = 0, w = 0, x = 0, err;\r\nif (desired & MAY_NOT_BLOCK)\r\nreturn -ECHILD;\r\nif (desired & MAY_READ) r = 1;\r\nif (desired & MAY_WRITE) w = 1;\r\nif (desired & MAY_EXEC) x = 1;\r\nname = inode_name(ino);\r\nif (name == NULL)\r\nreturn -ENOMEM;\r\nif (S_ISCHR(ino->i_mode) || S_ISBLK(ino->i_mode) ||\r\nS_ISFIFO(ino->i_mode) || S_ISSOCK(ino->i_mode))\r\nerr = 0;\r\nelse\r\nerr = access_file(name, r, w, x);\r\n__putname(name);\r\nif (!err)\r\nerr = generic_permission(ino, desired);\r\nreturn err;\r\n}\r\nstatic int hostfs_setattr(struct dentry *dentry, struct iattr *attr)\r\n{\r\nstruct inode *inode = d_inode(dentry);\r\nstruct hostfs_iattr attrs;\r\nchar *name;\r\nint err;\r\nint fd = HOSTFS_I(inode)->fd;\r\nerr = inode_change_ok(inode, attr);\r\nif (err)\r\nreturn err;\r\nif (append)\r\nattr->ia_valid &= ~ATTR_SIZE;\r\nattrs.ia_valid = 0;\r\nif (attr->ia_valid & ATTR_MODE) {\r\nattrs.ia_valid |= HOSTFS_ATTR_MODE;\r\nattrs.ia_mode = attr->ia_mode;\r\n}\r\nif (attr->ia_valid & ATTR_UID) {\r\nattrs.ia_valid |= HOSTFS_ATTR_UID;\r\nattrs.ia_uid = from_kuid(&init_user_ns, attr->ia_uid);\r\n}\r\nif (attr->ia_valid & ATTR_GID) {\r\nattrs.ia_valid |= HOSTFS_ATTR_GID;\r\nattrs.ia_gid = from_kgid(&init_user_ns, attr->ia_gid);\r\n}\r\nif (attr->ia_valid & ATTR_SIZE) {\r\nattrs.ia_valid |= HOSTFS_ATTR_SIZE;\r\nattrs.ia_size = attr->ia_size;\r\n}\r\nif (attr->ia_valid & ATTR_ATIME) {\r\nattrs.ia_valid |= HOSTFS_ATTR_ATIME;\r\nattrs.ia_atime = attr->ia_atime;\r\n}\r\nif (attr->ia_valid & ATTR_MTIME) {\r\nattrs.ia_valid |= HOSTFS_ATTR_MTIME;\r\nattrs.ia_mtime = attr->ia_mtime;\r\n}\r\nif (attr->ia_valid & ATTR_CTIME) {\r\nattrs.ia_valid |= HOSTFS_ATTR_CTIME;\r\nattrs.ia_ctime = attr->ia_ctime;\r\n}\r\nif (attr->ia_valid & ATTR_ATIME_SET) {\r\nattrs.ia_valid |= HOSTFS_ATTR_ATIME_SET;\r\n}\r\nif (attr->ia_valid & ATTR_MTIME_SET) {\r\nattrs.ia_valid |= HOSTFS_ATTR_MTIME_SET;\r\n}\r\nname = dentry_name(dentry);\r\nif (name == NULL)\r\nreturn -ENOMEM;\r\nerr = set_attr(name, &attrs, fd);\r\n__putname(name);\r\nif (err)\r\nreturn err;\r\nif ((attr->ia_valid & ATTR_SIZE) &&\r\nattr->ia_size != i_size_read(inode))\r\ntruncate_setsize(inode, attr->ia_size);\r\nsetattr_copy(inode, attr);\r\nmark_inode_dirty(inode);\r\nreturn 0;\r\n}\r\nstatic const char *hostfs_follow_link(struct dentry *dentry, void **cookie)\r\n{\r\nchar *link = __getname();\r\nif (link) {\r\nchar *path = dentry_name(dentry);\r\nint err = -ENOMEM;\r\nif (path) {\r\nerr = hostfs_do_readlink(path, link, PATH_MAX);\r\nif (err == PATH_MAX)\r\nerr = -E2BIG;\r\n__putname(path);\r\n}\r\nif (err < 0) {\r\n__putname(link);\r\nreturn ERR_PTR(err);\r\n}\r\n} else {\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nreturn *cookie = link;\r\n}\r\nstatic void hostfs_put_link(struct inode *unused, void *cookie)\r\n{\r\n__putname(cookie);\r\n}\r\nstatic int hostfs_fill_sb_common(struct super_block *sb, void *d, int silent)\r\n{\r\nstruct inode *root_inode;\r\nchar *host_root_path, *req_root = d;\r\nint err;\r\nsb->s_blocksize = 1024;\r\nsb->s_blocksize_bits = 10;\r\nsb->s_magic = HOSTFS_SUPER_MAGIC;\r\nsb->s_op = &hostfs_sbops;\r\nsb->s_d_op = &simple_dentry_operations;\r\nsb->s_maxbytes = MAX_LFS_FILESIZE;\r\nif (req_root == NULL)\r\nreq_root = "";\r\nerr = -ENOMEM;\r\nsb->s_fs_info = host_root_path =\r\nkmalloc(strlen(root_ino) + strlen(req_root) + 2, GFP_KERNEL);\r\nif (host_root_path == NULL)\r\ngoto out;\r\nsprintf(host_root_path, "%s/%s", root_ino, req_root);\r\nroot_inode = new_inode(sb);\r\nif (!root_inode)\r\ngoto out;\r\nerr = read_name(root_inode, host_root_path);\r\nif (err)\r\ngoto out_put;\r\nif (S_ISLNK(root_inode->i_mode)) {\r\nchar *name = follow_link(host_root_path);\r\nif (IS_ERR(name))\r\nerr = PTR_ERR(name);\r\nelse\r\nerr = read_name(root_inode, name);\r\nkfree(name);\r\nif (err)\r\ngoto out_put;\r\n}\r\nerr = -ENOMEM;\r\nsb->s_root = d_make_root(root_inode);\r\nif (sb->s_root == NULL)\r\ngoto out;\r\nreturn 0;\r\nout_put:\r\niput(root_inode);\r\nout:\r\nreturn err;\r\n}\r\nstatic struct dentry *hostfs_read_sb(struct file_system_type *type,\r\nint flags, const char *dev_name,\r\nvoid *data)\r\n{\r\nreturn mount_nodev(type, flags, data, hostfs_fill_sb_common);\r\n}\r\nstatic void hostfs_kill_sb(struct super_block *s)\r\n{\r\nkill_anon_super(s);\r\nkfree(s->s_fs_info);\r\n}\r\nstatic int __init init_hostfs(void)\r\n{\r\nreturn register_filesystem(&hostfs_type);\r\n}\r\nstatic void __exit exit_hostfs(void)\r\n{\r\nunregister_filesystem(&hostfs_type);\r\n}
