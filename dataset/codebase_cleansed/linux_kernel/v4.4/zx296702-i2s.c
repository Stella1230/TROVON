static void zx_i2s_tx_en(void __iomem *base, bool on)\r\n{\r\nunsigned long val;\r\nval = readl_relaxed(base + ZX_I2S_PROCESS_CTRL);\r\nif (on)\r\nval |= ZX_I2S_PROCESS_TX_EN | ZX_I2S_PROCESS_I2S_EN;\r\nelse\r\nval &= ~(ZX_I2S_PROCESS_TX_EN | ZX_I2S_PROCESS_I2S_EN);\r\nwritel_relaxed(val, base + ZX_I2S_PROCESS_CTRL);\r\n}\r\nstatic void zx_i2s_rx_en(void __iomem *base, bool on)\r\n{\r\nunsigned long val;\r\nval = readl_relaxed(base + ZX_I2S_PROCESS_CTRL);\r\nif (on)\r\nval |= ZX_I2S_PROCESS_RX_EN | ZX_I2S_PROCESS_I2S_EN;\r\nelse\r\nval &= ~(ZX_I2S_PROCESS_RX_EN | ZX_I2S_PROCESS_I2S_EN);\r\nwritel_relaxed(val, base + ZX_I2S_PROCESS_CTRL);\r\n}\r\nstatic void zx_i2s_tx_dma_en(void __iomem *base, bool on)\r\n{\r\nunsigned long val;\r\nval = readl_relaxed(base + ZX_I2S_FIFO_CTRL);\r\nval |= ZX_I2S_FIFO_CTRL_TX_RST | (I2S_DEAGULT_FIFO_THRES << 8);\r\nif (on)\r\nval |= ZX_I2S_FIFO_CTRL_TX_DMA_EN;\r\nelse\r\nval &= ~ZX_I2S_FIFO_CTRL_TX_DMA_EN;\r\nwritel_relaxed(val, base + ZX_I2S_FIFO_CTRL);\r\n}\r\nstatic void zx_i2s_rx_dma_en(void __iomem *base, bool on)\r\n{\r\nunsigned long val;\r\nval = readl_relaxed(base + ZX_I2S_FIFO_CTRL);\r\nval |= ZX_I2S_FIFO_CTRL_RX_RST | (I2S_DEAGULT_FIFO_THRES << 16);\r\nif (on)\r\nval |= ZX_I2S_FIFO_CTRL_RX_DMA_EN;\r\nelse\r\nval &= ~ZX_I2S_FIFO_CTRL_RX_DMA_EN;\r\nwritel_relaxed(val, base + ZX_I2S_FIFO_CTRL);\r\n}\r\nstatic int zx_i2s_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct zx_i2s_info *zx_i2s = dev_get_drvdata(dai->dev);\r\nsnd_soc_dai_set_drvdata(dai, zx_i2s);\r\nzx_i2s->dma_playback.addr = zx_i2s->mapbase + ZX_I2S_DATA;\r\nzx_i2s->dma_playback.maxburst = 16;\r\nzx_i2s->dma_capture.addr = zx_i2s->mapbase + ZX_I2S_DATA;\r\nzx_i2s->dma_capture.maxburst = 16;\r\nsnd_soc_dai_init_dma_data(dai, &zx_i2s->dma_playback,\r\n&zx_i2s->dma_capture);\r\nreturn 0;\r\n}\r\nstatic int zx_i2s_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)\r\n{\r\nstruct zx_i2s_info *i2s = snd_soc_dai_get_drvdata(cpu_dai);\r\nunsigned long val;\r\nval = readl_relaxed(i2s->reg_base + ZX_I2S_TIMING_CTRL);\r\nval &= ~(ZX_I2S_TIMING_TIMING_MASK | ZX_I2S_TIMING_ALIGN_MASK |\r\nZX_I2S_TIMING_TEAK_MASK | ZX_I2S_TIMING_SYNC_MASK |\r\nZX_I2S_TIMING_MS_MASK);\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nval |= (ZX_I2S_TIMING_I2S | ZX_I2S_TIMING_STD_I2S);\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nval |= (ZX_I2S_TIMING_I2S | ZX_I2S_TIMING_MSB_JUSTIF);\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nval |= (ZX_I2S_TIMING_I2S | ZX_I2S_TIMING_LSB_JUSTIF);\r\nbreak;\r\ndefault:\r\ndev_err(cpu_dai->dev, "Unknown i2s timeing\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ni2s->master = 1;\r\nval |= ZX_I2S_TIMING_MAST;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\ni2s->master = 0;\r\nval |= ZX_I2S_TIMING_SLAVE;\r\nbreak;\r\ndefault:\r\ndev_err(cpu_dai->dev, "Unknown master/slave format\n");\r\nreturn -EINVAL;\r\n}\r\nwritel_relaxed(val, i2s->reg_base + ZX_I2S_TIMING_CTRL);\r\nreturn 0;\r\n}\r\nstatic int zx_i2s_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *socdai)\r\n{\r\nstruct zx_i2s_info *i2s = snd_soc_dai_get_drvdata(socdai);\r\nstruct snd_dmaengine_dai_dma_data *dma_data;\r\nunsigned int lane, ch_num, len, ret = 0;\r\nunsigned long val, format;\r\nunsigned long chn_cfg;\r\ndma_data = snd_soc_dai_get_dma_data(socdai, substream);\r\ndma_data->addr_width = params_width(params) >> 3;\r\nval = readl_relaxed(i2s->reg_base + ZX_I2S_TIMING_CTRL);\r\nval &= ~(ZX_I2S_TIMING_TS_WIDTH_MASK | ZX_I2S_TIMING_DATA_SIZE_MASK |\r\nZX_I2S_TIMING_LANE_MASK | ZX_I2S_TIMING_CHN_MASK |\r\nZX_I2S_TIMING_TSCFG_MASK);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nformat = 0;\r\nlen = 16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nformat = 1;\r\nlen = 24;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nformat = 2;\r\nlen = 32;\r\nbreak;\r\ndefault:\r\ndev_err(socdai->dev, "Unknown data format\n");\r\nreturn -EINVAL;\r\n}\r\nval |= ZX_I2S_TIMING_TS_WIDTH(len) | ZX_I2S_TIMING_DATA_SIZE(len);\r\nch_num = params_channels(params);\r\nswitch (ch_num) {\r\ncase 1:\r\nlane = 1;\r\nchn_cfg = 2;\r\nbreak;\r\ncase 2:\r\ncase 4:\r\ncase 6:\r\ncase 8:\r\nlane = ch_num / 2;\r\nchn_cfg = 3;\r\nbreak;\r\ndefault:\r\ndev_err(socdai->dev, "Not support channel num %d\n", ch_num);\r\nreturn -EINVAL;\r\n}\r\nval |= ZX_I2S_TIMING_LANE(lane);\r\nval |= ZX_I2S_TIMING_TSCFG(chn_cfg);\r\nval |= ZX_I2S_TIMING_CHN(ch_num);\r\nwritel_relaxed(val, i2s->reg_base + ZX_I2S_TIMING_CTRL);\r\nif (i2s->master)\r\nret = clk_set_rate(i2s->dai_clk,\r\nparams_rate(params) * ch_num * CLK_RAT);\r\nreturn ret;\r\n}\r\nstatic int zx_i2s_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct zx_i2s_info *zx_i2s = dev_get_drvdata(dai->dev);\r\nint capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif (capture)\r\nzx_i2s_rx_dma_en(zx_i2s->reg_base, true);\r\nelse\r\nzx_i2s_tx_dma_en(zx_i2s->reg_base, true);\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (capture)\r\nzx_i2s_rx_en(zx_i2s->reg_base, true);\r\nelse\r\nzx_i2s_tx_en(zx_i2s->reg_base, true);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nif (capture)\r\nzx_i2s_rx_dma_en(zx_i2s->reg_base, false);\r\nelse\r\nzx_i2s_tx_dma_en(zx_i2s->reg_base, false);\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (capture)\r\nzx_i2s_rx_en(zx_i2s->reg_base, false);\r\nelse\r\nzx_i2s_tx_en(zx_i2s->reg_base, false);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int zx_i2s_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct zx_i2s_info *zx_i2s = dev_get_drvdata(dai->dev);\r\nreturn clk_prepare_enable(zx_i2s->dai_clk);\r\n}\r\nstatic void zx_i2s_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct zx_i2s_info *zx_i2s = dev_get_drvdata(dai->dev);\r\nclk_disable_unprepare(zx_i2s->dai_clk);\r\n}\r\nstatic int zx_i2s_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct zx_i2s_info *zx_i2s;\r\nint ret;\r\nzx_i2s = devm_kzalloc(&pdev->dev, sizeof(*zx_i2s), GFP_KERNEL);\r\nif (!zx_i2s)\r\nreturn -ENOMEM;\r\nzx_i2s->dai_clk = devm_clk_get(&pdev->dev, "tx");\r\nif (IS_ERR(zx_i2s->dai_clk)) {\r\ndev_err(&pdev->dev, "Fail to get clk\n");\r\nreturn PTR_ERR(zx_i2s->dai_clk);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nzx_i2s->mapbase = res->start;\r\nzx_i2s->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(zx_i2s->reg_base)) {\r\ndev_err(&pdev->dev, "ioremap failed!\n");\r\nreturn PTR_ERR(zx_i2s->reg_base);\r\n}\r\nwritel_relaxed(0, zx_i2s->reg_base + ZX_I2S_FIFO_CTRL);\r\nplatform_set_drvdata(pdev, zx_i2s);\r\nret = devm_snd_soc_register_component(&pdev->dev, &zx_i2s_component,\r\n&zx_i2s_dai, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Register DAI failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\r\nif (ret)\r\ndev_err(&pdev->dev, "Register platform PCM failed: %d\n", ret);\r\nreturn ret;\r\n}
