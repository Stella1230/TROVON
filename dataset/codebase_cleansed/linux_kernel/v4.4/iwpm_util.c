int iwpm_init(u8 nl_client)\r\n{\r\nint ret = 0;\r\nif (iwpm_valid_client(nl_client))\r\nreturn -EINVAL;\r\nmutex_lock(&iwpm_admin_lock);\r\nif (atomic_read(&iwpm_admin.refcount) == 0) {\r\niwpm_hash_bucket = kzalloc(IWPM_MAPINFO_HASH_SIZE *\r\nsizeof(struct hlist_head), GFP_KERNEL);\r\nif (!iwpm_hash_bucket) {\r\nret = -ENOMEM;\r\npr_err("%s Unable to create mapinfo hash table\n", __func__);\r\ngoto init_exit;\r\n}\r\niwpm_reminfo_bucket = kzalloc(IWPM_REMINFO_HASH_SIZE *\r\nsizeof(struct hlist_head), GFP_KERNEL);\r\nif (!iwpm_reminfo_bucket) {\r\nkfree(iwpm_hash_bucket);\r\nret = -ENOMEM;\r\npr_err("%s Unable to create reminfo hash table\n", __func__);\r\ngoto init_exit;\r\n}\r\n}\r\natomic_inc(&iwpm_admin.refcount);\r\ninit_exit:\r\nmutex_unlock(&iwpm_admin_lock);\r\nif (!ret) {\r\niwpm_set_valid(nl_client, 1);\r\niwpm_set_registration(nl_client, IWPM_REG_UNDEF);\r\npr_debug("%s: Mapinfo and reminfo tables are created\n",\r\n__func__);\r\n}\r\nreturn ret;\r\n}\r\nint iwpm_exit(u8 nl_client)\r\n{\r\nif (!iwpm_valid_client(nl_client))\r\nreturn -EINVAL;\r\nmutex_lock(&iwpm_admin_lock);\r\nif (atomic_read(&iwpm_admin.refcount) == 0) {\r\nmutex_unlock(&iwpm_admin_lock);\r\npr_err("%s Incorrect usage - negative refcount\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (atomic_dec_and_test(&iwpm_admin.refcount)) {\r\nfree_hash_bucket();\r\nfree_reminfo_bucket();\r\npr_debug("%s: Resources are destroyed\n", __func__);\r\n}\r\nmutex_unlock(&iwpm_admin_lock);\r\niwpm_set_valid(nl_client, 0);\r\niwpm_set_registration(nl_client, IWPM_REG_UNDEF);\r\nreturn 0;\r\n}\r\nint iwpm_create_mapinfo(struct sockaddr_storage *local_sockaddr,\r\nstruct sockaddr_storage *mapped_sockaddr,\r\nu8 nl_client)\r\n{\r\nstruct hlist_head *hash_bucket_head;\r\nstruct iwpm_mapping_info *map_info;\r\nunsigned long flags;\r\nint ret = -EINVAL;\r\nif (!iwpm_valid_client(nl_client))\r\nreturn ret;\r\nmap_info = kzalloc(sizeof(struct iwpm_mapping_info), GFP_KERNEL);\r\nif (!map_info) {\r\npr_err("%s: Unable to allocate a mapping info\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(&map_info->local_sockaddr, local_sockaddr,\r\nsizeof(struct sockaddr_storage));\r\nmemcpy(&map_info->mapped_sockaddr, mapped_sockaddr,\r\nsizeof(struct sockaddr_storage));\r\nmap_info->nl_client = nl_client;\r\nspin_lock_irqsave(&iwpm_mapinfo_lock, flags);\r\nif (iwpm_hash_bucket) {\r\nhash_bucket_head = get_mapinfo_hash_bucket(\r\n&map_info->local_sockaddr,\r\n&map_info->mapped_sockaddr);\r\nif (hash_bucket_head) {\r\nhlist_add_head(&map_info->hlist_node, hash_bucket_head);\r\nret = 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&iwpm_mapinfo_lock, flags);\r\nreturn ret;\r\n}\r\nint iwpm_remove_mapinfo(struct sockaddr_storage *local_sockaddr,\r\nstruct sockaddr_storage *mapped_local_addr)\r\n{\r\nstruct hlist_node *tmp_hlist_node;\r\nstruct hlist_head *hash_bucket_head;\r\nstruct iwpm_mapping_info *map_info = NULL;\r\nunsigned long flags;\r\nint ret = -EINVAL;\r\nspin_lock_irqsave(&iwpm_mapinfo_lock, flags);\r\nif (iwpm_hash_bucket) {\r\nhash_bucket_head = get_mapinfo_hash_bucket(\r\nlocal_sockaddr,\r\nmapped_local_addr);\r\nif (!hash_bucket_head)\r\ngoto remove_mapinfo_exit;\r\nhlist_for_each_entry_safe(map_info, tmp_hlist_node,\r\nhash_bucket_head, hlist_node) {\r\nif (!iwpm_compare_sockaddr(&map_info->mapped_sockaddr,\r\nmapped_local_addr)) {\r\nhlist_del_init(&map_info->hlist_node);\r\nkfree(map_info);\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nremove_mapinfo_exit:\r\nspin_unlock_irqrestore(&iwpm_mapinfo_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void free_hash_bucket(void)\r\n{\r\nstruct hlist_node *tmp_hlist_node;\r\nstruct iwpm_mapping_info *map_info;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&iwpm_mapinfo_lock, flags);\r\nfor (i = 0; i < IWPM_MAPINFO_HASH_SIZE; i++) {\r\nhlist_for_each_entry_safe(map_info, tmp_hlist_node,\r\n&iwpm_hash_bucket[i], hlist_node) {\r\nhlist_del_init(&map_info->hlist_node);\r\nkfree(map_info);\r\n}\r\n}\r\nkfree(iwpm_hash_bucket);\r\niwpm_hash_bucket = NULL;\r\nspin_unlock_irqrestore(&iwpm_mapinfo_lock, flags);\r\n}\r\nstatic void free_reminfo_bucket(void)\r\n{\r\nstruct hlist_node *tmp_hlist_node;\r\nstruct iwpm_remote_info *rem_info;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&iwpm_reminfo_lock, flags);\r\nfor (i = 0; i < IWPM_REMINFO_HASH_SIZE; i++) {\r\nhlist_for_each_entry_safe(rem_info, tmp_hlist_node,\r\n&iwpm_reminfo_bucket[i], hlist_node) {\r\nhlist_del_init(&rem_info->hlist_node);\r\nkfree(rem_info);\r\n}\r\n}\r\nkfree(iwpm_reminfo_bucket);\r\niwpm_reminfo_bucket = NULL;\r\nspin_unlock_irqrestore(&iwpm_reminfo_lock, flags);\r\n}\r\nvoid iwpm_add_remote_info(struct iwpm_remote_info *rem_info)\r\n{\r\nstruct hlist_head *hash_bucket_head;\r\nunsigned long flags;\r\nspin_lock_irqsave(&iwpm_reminfo_lock, flags);\r\nif (iwpm_reminfo_bucket) {\r\nhash_bucket_head = get_reminfo_hash_bucket(\r\n&rem_info->mapped_loc_sockaddr,\r\n&rem_info->mapped_rem_sockaddr);\r\nif (hash_bucket_head)\r\nhlist_add_head(&rem_info->hlist_node, hash_bucket_head);\r\n}\r\nspin_unlock_irqrestore(&iwpm_reminfo_lock, flags);\r\n}\r\nint iwpm_get_remote_info(struct sockaddr_storage *mapped_loc_addr,\r\nstruct sockaddr_storage *mapped_rem_addr,\r\nstruct sockaddr_storage *remote_addr,\r\nu8 nl_client)\r\n{\r\nstruct hlist_node *tmp_hlist_node;\r\nstruct hlist_head *hash_bucket_head;\r\nstruct iwpm_remote_info *rem_info = NULL;\r\nunsigned long flags;\r\nint ret = -EINVAL;\r\nif (!iwpm_valid_client(nl_client)) {\r\npr_info("%s: Invalid client = %d\n", __func__, nl_client);\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&iwpm_reminfo_lock, flags);\r\nif (iwpm_reminfo_bucket) {\r\nhash_bucket_head = get_reminfo_hash_bucket(\r\nmapped_loc_addr,\r\nmapped_rem_addr);\r\nif (!hash_bucket_head)\r\ngoto get_remote_info_exit;\r\nhlist_for_each_entry_safe(rem_info, tmp_hlist_node,\r\nhash_bucket_head, hlist_node) {\r\nif (!iwpm_compare_sockaddr(&rem_info->mapped_loc_sockaddr,\r\nmapped_loc_addr) &&\r\n!iwpm_compare_sockaddr(&rem_info->mapped_rem_sockaddr,\r\nmapped_rem_addr)) {\r\nmemcpy(remote_addr, &rem_info->remote_sockaddr,\r\nsizeof(struct sockaddr_storage));\r\niwpm_print_sockaddr(remote_addr,\r\n"get_remote_info: Remote sockaddr:");\r\nhlist_del_init(&rem_info->hlist_node);\r\nkfree(rem_info);\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nget_remote_info_exit:\r\nspin_unlock_irqrestore(&iwpm_reminfo_lock, flags);\r\nreturn ret;\r\n}\r\nstruct iwpm_nlmsg_request *iwpm_get_nlmsg_request(__u32 nlmsg_seq,\r\nu8 nl_client, gfp_t gfp)\r\n{\r\nstruct iwpm_nlmsg_request *nlmsg_request = NULL;\r\nunsigned long flags;\r\nnlmsg_request = kzalloc(sizeof(struct iwpm_nlmsg_request), gfp);\r\nif (!nlmsg_request) {\r\npr_err("%s Unable to allocate a nlmsg_request\n", __func__);\r\nreturn NULL;\r\n}\r\nspin_lock_irqsave(&iwpm_nlmsg_req_lock, flags);\r\nlist_add_tail(&nlmsg_request->inprocess_list, &iwpm_nlmsg_req_list);\r\nspin_unlock_irqrestore(&iwpm_nlmsg_req_lock, flags);\r\nkref_init(&nlmsg_request->kref);\r\nkref_get(&nlmsg_request->kref);\r\nnlmsg_request->nlmsg_seq = nlmsg_seq;\r\nnlmsg_request->nl_client = nl_client;\r\nnlmsg_request->request_done = 0;\r\nnlmsg_request->err_code = 0;\r\nreturn nlmsg_request;\r\n}\r\nvoid iwpm_free_nlmsg_request(struct kref *kref)\r\n{\r\nstruct iwpm_nlmsg_request *nlmsg_request;\r\nunsigned long flags;\r\nnlmsg_request = container_of(kref, struct iwpm_nlmsg_request, kref);\r\nspin_lock_irqsave(&iwpm_nlmsg_req_lock, flags);\r\nlist_del_init(&nlmsg_request->inprocess_list);\r\nspin_unlock_irqrestore(&iwpm_nlmsg_req_lock, flags);\r\nif (!nlmsg_request->request_done)\r\npr_debug("%s Freeing incomplete nlmsg request (seq = %u).\n",\r\n__func__, nlmsg_request->nlmsg_seq);\r\nkfree(nlmsg_request);\r\n}\r\nstruct iwpm_nlmsg_request *iwpm_find_nlmsg_request(__u32 echo_seq)\r\n{\r\nstruct iwpm_nlmsg_request *nlmsg_request;\r\nstruct iwpm_nlmsg_request *found_request = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&iwpm_nlmsg_req_lock, flags);\r\nlist_for_each_entry(nlmsg_request, &iwpm_nlmsg_req_list,\r\ninprocess_list) {\r\nif (nlmsg_request->nlmsg_seq == echo_seq) {\r\nfound_request = nlmsg_request;\r\nkref_get(&nlmsg_request->kref);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&iwpm_nlmsg_req_lock, flags);\r\nreturn found_request;\r\n}\r\nint iwpm_wait_complete_req(struct iwpm_nlmsg_request *nlmsg_request)\r\n{\r\nint ret;\r\ninit_waitqueue_head(&nlmsg_request->waitq);\r\nret = wait_event_timeout(nlmsg_request->waitq,\r\n(nlmsg_request->request_done != 0), IWPM_NL_TIMEOUT);\r\nif (!ret) {\r\nret = -EINVAL;\r\npr_info("%s: Timeout %d sec for netlink request (seq = %u)\n",\r\n__func__, (IWPM_NL_TIMEOUT/HZ), nlmsg_request->nlmsg_seq);\r\n} else {\r\nret = nlmsg_request->err_code;\r\n}\r\nkref_put(&nlmsg_request->kref, iwpm_free_nlmsg_request);\r\nreturn ret;\r\n}\r\nint iwpm_get_nlmsg_seq(void)\r\n{\r\nreturn atomic_inc_return(&iwpm_admin.nlmsg_seq);\r\n}\r\nint iwpm_valid_client(u8 nl_client)\r\n{\r\nif (nl_client >= RDMA_NL_NUM_CLIENTS)\r\nreturn 0;\r\nreturn iwpm_admin.client_list[nl_client];\r\n}\r\nvoid iwpm_set_valid(u8 nl_client, int valid)\r\n{\r\nif (nl_client >= RDMA_NL_NUM_CLIENTS)\r\nreturn;\r\niwpm_admin.client_list[nl_client] = valid;\r\n}\r\nu32 iwpm_get_registration(u8 nl_client)\r\n{\r\nreturn iwpm_admin.reg_list[nl_client];\r\n}\r\nvoid iwpm_set_registration(u8 nl_client, u32 reg)\r\n{\r\niwpm_admin.reg_list[nl_client] = reg;\r\n}\r\nu32 iwpm_check_registration(u8 nl_client, u32 reg)\r\n{\r\nreturn (iwpm_get_registration(nl_client) & reg);\r\n}\r\nint iwpm_compare_sockaddr(struct sockaddr_storage *a_sockaddr,\r\nstruct sockaddr_storage *b_sockaddr)\r\n{\r\nif (a_sockaddr->ss_family != b_sockaddr->ss_family)\r\nreturn 1;\r\nif (a_sockaddr->ss_family == AF_INET) {\r\nstruct sockaddr_in *a4_sockaddr =\r\n(struct sockaddr_in *)a_sockaddr;\r\nstruct sockaddr_in *b4_sockaddr =\r\n(struct sockaddr_in *)b_sockaddr;\r\nif (!memcmp(&a4_sockaddr->sin_addr,\r\n&b4_sockaddr->sin_addr, sizeof(struct in_addr))\r\n&& a4_sockaddr->sin_port == b4_sockaddr->sin_port)\r\nreturn 0;\r\n} else if (a_sockaddr->ss_family == AF_INET6) {\r\nstruct sockaddr_in6 *a6_sockaddr =\r\n(struct sockaddr_in6 *)a_sockaddr;\r\nstruct sockaddr_in6 *b6_sockaddr =\r\n(struct sockaddr_in6 *)b_sockaddr;\r\nif (!memcmp(&a6_sockaddr->sin6_addr,\r\n&b6_sockaddr->sin6_addr, sizeof(struct in6_addr))\r\n&& a6_sockaddr->sin6_port == b6_sockaddr->sin6_port)\r\nreturn 0;\r\n} else {\r\npr_err("%s: Invalid sockaddr family\n", __func__);\r\n}\r\nreturn 1;\r\n}\r\nstruct sk_buff *iwpm_create_nlmsg(u32 nl_op, struct nlmsghdr **nlh,\r\nint nl_client)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nskb = dev_alloc_skb(NLMSG_GOODSIZE);\r\nif (!skb) {\r\npr_err("%s Unable to allocate skb\n", __func__);\r\ngoto create_nlmsg_exit;\r\n}\r\nif (!(ibnl_put_msg(skb, nlh, 0, 0, nl_client, nl_op,\r\nNLM_F_REQUEST))) {\r\npr_warn("%s: Unable to put the nlmsg header\n", __func__);\r\ndev_kfree_skb(skb);\r\nskb = NULL;\r\n}\r\ncreate_nlmsg_exit:\r\nreturn skb;\r\n}\r\nint iwpm_parse_nlmsg(struct netlink_callback *cb, int policy_max,\r\nconst struct nla_policy *nlmsg_policy,\r\nstruct nlattr *nltb[], const char *msg_type)\r\n{\r\nint nlh_len = 0;\r\nint ret;\r\nconst char *err_str = "";\r\nret = nlmsg_validate(cb->nlh, nlh_len, policy_max-1, nlmsg_policy);\r\nif (ret) {\r\nerr_str = "Invalid attribute";\r\ngoto parse_nlmsg_error;\r\n}\r\nret = nlmsg_parse(cb->nlh, nlh_len, nltb, policy_max-1, nlmsg_policy);\r\nif (ret) {\r\nerr_str = "Unable to parse the nlmsg";\r\ngoto parse_nlmsg_error;\r\n}\r\nret = iwpm_validate_nlmsg_attr(nltb, policy_max);\r\nif (ret) {\r\nerr_str = "Invalid NULL attribute";\r\ngoto parse_nlmsg_error;\r\n}\r\nreturn 0;\r\nparse_nlmsg_error:\r\npr_warn("%s: %s (msg type %s ret = %d)\n",\r\n__func__, err_str, msg_type, ret);\r\nreturn ret;\r\n}\r\nvoid iwpm_print_sockaddr(struct sockaddr_storage *sockaddr, char *msg)\r\n{\r\nstruct sockaddr_in6 *sockaddr_v6;\r\nstruct sockaddr_in *sockaddr_v4;\r\nswitch (sockaddr->ss_family) {\r\ncase AF_INET:\r\nsockaddr_v4 = (struct sockaddr_in *)sockaddr;\r\npr_debug("%s IPV4 %pI4: %u(0x%04X)\n",\r\nmsg, &sockaddr_v4->sin_addr,\r\nntohs(sockaddr_v4->sin_port),\r\nntohs(sockaddr_v4->sin_port));\r\nbreak;\r\ncase AF_INET6:\r\nsockaddr_v6 = (struct sockaddr_in6 *)sockaddr;\r\npr_debug("%s IPV6 %pI6: %u(0x%04X)\n",\r\nmsg, &sockaddr_v6->sin6_addr,\r\nntohs(sockaddr_v6->sin6_port),\r\nntohs(sockaddr_v6->sin6_port));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic u32 iwpm_ipv6_jhash(struct sockaddr_in6 *ipv6_sockaddr)\r\n{\r\nu32 ipv6_hash = jhash(&ipv6_sockaddr->sin6_addr, sizeof(struct in6_addr), 0);\r\nu32 hash = jhash_2words(ipv6_hash, (__force u32) ipv6_sockaddr->sin6_port, 0);\r\nreturn hash;\r\n}\r\nstatic u32 iwpm_ipv4_jhash(struct sockaddr_in *ipv4_sockaddr)\r\n{\r\nu32 ipv4_hash = jhash(&ipv4_sockaddr->sin_addr, sizeof(struct in_addr), 0);\r\nu32 hash = jhash_2words(ipv4_hash, (__force u32) ipv4_sockaddr->sin_port, 0);\r\nreturn hash;\r\n}\r\nstatic int get_hash_bucket(struct sockaddr_storage *a_sockaddr,\r\nstruct sockaddr_storage *b_sockaddr, u32 *hash)\r\n{\r\nu32 a_hash, b_hash;\r\nif (a_sockaddr->ss_family == AF_INET) {\r\na_hash = iwpm_ipv4_jhash((struct sockaddr_in *) a_sockaddr);\r\nb_hash = iwpm_ipv4_jhash((struct sockaddr_in *) b_sockaddr);\r\n} else if (a_sockaddr->ss_family == AF_INET6) {\r\na_hash = iwpm_ipv6_jhash((struct sockaddr_in6 *) a_sockaddr);\r\nb_hash = iwpm_ipv6_jhash((struct sockaddr_in6 *) b_sockaddr);\r\n} else {\r\npr_err("%s: Invalid sockaddr family\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (a_hash == b_hash)\r\n*hash = a_hash;\r\nelse\r\n*hash = jhash_2words(a_hash, b_hash, 0);\r\nreturn 0;\r\n}\r\nstatic struct hlist_head *get_mapinfo_hash_bucket(struct sockaddr_storage\r\n*local_sockaddr, struct sockaddr_storage\r\n*mapped_sockaddr)\r\n{\r\nu32 hash;\r\nint ret;\r\nret = get_hash_bucket(local_sockaddr, mapped_sockaddr, &hash);\r\nif (ret)\r\nreturn NULL;\r\nreturn &iwpm_hash_bucket[hash & IWPM_MAPINFO_HASH_MASK];\r\n}\r\nstatic struct hlist_head *get_reminfo_hash_bucket(struct sockaddr_storage\r\n*mapped_loc_sockaddr, struct sockaddr_storage\r\n*mapped_rem_sockaddr)\r\n{\r\nu32 hash;\r\nint ret;\r\nret = get_hash_bucket(mapped_loc_sockaddr, mapped_rem_sockaddr, &hash);\r\nif (ret)\r\nreturn NULL;\r\nreturn &iwpm_reminfo_bucket[hash & IWPM_REMINFO_HASH_MASK];\r\n}\r\nstatic int send_mapinfo_num(u32 mapping_num, u8 nl_client, int iwpm_pid)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nstruct nlmsghdr *nlh;\r\nu32 msg_seq;\r\nconst char *err_str = "";\r\nint ret = -EINVAL;\r\nskb = iwpm_create_nlmsg(RDMA_NL_IWPM_MAPINFO_NUM, &nlh, nl_client);\r\nif (!skb) {\r\nerr_str = "Unable to create a nlmsg";\r\ngoto mapinfo_num_error;\r\n}\r\nnlh->nlmsg_seq = iwpm_get_nlmsg_seq();\r\nmsg_seq = 0;\r\nerr_str = "Unable to put attribute of mapinfo number nlmsg";\r\nret = ibnl_put_attr(skb, nlh, sizeof(u32), &msg_seq, IWPM_NLA_MAPINFO_SEQ);\r\nif (ret)\r\ngoto mapinfo_num_error;\r\nret = ibnl_put_attr(skb, nlh, sizeof(u32),\r\n&mapping_num, IWPM_NLA_MAPINFO_SEND_NUM);\r\nif (ret)\r\ngoto mapinfo_num_error;\r\nret = ibnl_unicast(skb, nlh, iwpm_pid);\r\nif (ret) {\r\nskb = NULL;\r\nerr_str = "Unable to send a nlmsg";\r\ngoto mapinfo_num_error;\r\n}\r\npr_debug("%s: Sent mapping number = %d\n", __func__, mapping_num);\r\nreturn 0;\r\nmapinfo_num_error:\r\npr_info("%s: %s\n", __func__, err_str);\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int send_nlmsg_done(struct sk_buff *skb, u8 nl_client, int iwpm_pid)\r\n{\r\nstruct nlmsghdr *nlh = NULL;\r\nint ret = 0;\r\nif (!skb)\r\nreturn ret;\r\nif (!(ibnl_put_msg(skb, &nlh, 0, 0, nl_client,\r\nRDMA_NL_IWPM_MAPINFO, NLM_F_MULTI))) {\r\npr_warn("%s Unable to put NLMSG_DONE\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nnlh->nlmsg_type = NLMSG_DONE;\r\nret = ibnl_unicast(skb, (struct nlmsghdr *)skb->data, iwpm_pid);\r\nif (ret)\r\npr_warn("%s Unable to send a nlmsg\n", __func__);\r\nreturn ret;\r\n}\r\nint iwpm_send_mapinfo(u8 nl_client, int iwpm_pid)\r\n{\r\nstruct iwpm_mapping_info *map_info;\r\nstruct sk_buff *skb = NULL;\r\nstruct nlmsghdr *nlh;\r\nint skb_num = 0, mapping_num = 0;\r\nint i = 0, nlmsg_bytes = 0;\r\nunsigned long flags;\r\nconst char *err_str = "";\r\nint ret;\r\nskb = dev_alloc_skb(NLMSG_GOODSIZE);\r\nif (!skb) {\r\nret = -ENOMEM;\r\nerr_str = "Unable to allocate skb";\r\ngoto send_mapping_info_exit;\r\n}\r\nskb_num++;\r\nspin_lock_irqsave(&iwpm_mapinfo_lock, flags);\r\nfor (i = 0; i < IWPM_MAPINFO_HASH_SIZE; i++) {\r\nhlist_for_each_entry(map_info, &iwpm_hash_bucket[i],\r\nhlist_node) {\r\nif (map_info->nl_client != nl_client)\r\ncontinue;\r\nnlh = NULL;\r\nif (!(ibnl_put_msg(skb, &nlh, 0, 0, nl_client,\r\nRDMA_NL_IWPM_MAPINFO, NLM_F_MULTI))) {\r\nret = -ENOMEM;\r\nerr_str = "Unable to put the nlmsg header";\r\ngoto send_mapping_info_unlock;\r\n}\r\nerr_str = "Unable to put attribute of the nlmsg";\r\nret = ibnl_put_attr(skb, nlh,\r\nsizeof(struct sockaddr_storage),\r\n&map_info->local_sockaddr,\r\nIWPM_NLA_MAPINFO_LOCAL_ADDR);\r\nif (ret)\r\ngoto send_mapping_info_unlock;\r\nret = ibnl_put_attr(skb, nlh,\r\nsizeof(struct sockaddr_storage),\r\n&map_info->mapped_sockaddr,\r\nIWPM_NLA_MAPINFO_MAPPED_ADDR);\r\nif (ret)\r\ngoto send_mapping_info_unlock;\r\niwpm_print_sockaddr(&map_info->local_sockaddr,\r\n"send_mapping_info: Local sockaddr:");\r\niwpm_print_sockaddr(&map_info->mapped_sockaddr,\r\n"send_mapping_info: Mapped local sockaddr:");\r\nmapping_num++;\r\nnlmsg_bytes += nlh->nlmsg_len;\r\nif (NLMSG_GOODSIZE - nlmsg_bytes < nlh->nlmsg_len * 2) {\r\nnlmsg_bytes = 0;\r\nskb_num++;\r\nspin_unlock_irqrestore(&iwpm_mapinfo_lock,\r\nflags);\r\nret = send_nlmsg_done(skb, nl_client, iwpm_pid);\r\nskb = NULL;\r\nif (ret) {\r\nerr_str = "Unable to send map info";\r\ngoto send_mapping_info_exit;\r\n}\r\nif (skb_num == IWPM_MAPINFO_SKB_COUNT) {\r\nret = -ENOMEM;\r\nerr_str = "Insufficient skbs for map info";\r\ngoto send_mapping_info_exit;\r\n}\r\nskb = dev_alloc_skb(NLMSG_GOODSIZE);\r\nif (!skb) {\r\nret = -ENOMEM;\r\nerr_str = "Unable to allocate skb";\r\ngoto send_mapping_info_exit;\r\n}\r\nspin_lock_irqsave(&iwpm_mapinfo_lock, flags);\r\n}\r\n}\r\n}\r\nsend_mapping_info_unlock:\r\nspin_unlock_irqrestore(&iwpm_mapinfo_lock, flags);\r\nsend_mapping_info_exit:\r\nif (ret) {\r\npr_warn("%s: %s (ret = %d)\n", __func__, err_str, ret);\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nsend_nlmsg_done(skb, nl_client, iwpm_pid);\r\nreturn send_mapinfo_num(mapping_num, nl_client, iwpm_pid);\r\n}\r\nint iwpm_mapinfo_available(void)\r\n{\r\nunsigned long flags;\r\nint full_bucket = 0, i = 0;\r\nspin_lock_irqsave(&iwpm_mapinfo_lock, flags);\r\nif (iwpm_hash_bucket) {\r\nfor (i = 0; i < IWPM_MAPINFO_HASH_SIZE; i++) {\r\nif (!hlist_empty(&iwpm_hash_bucket[i])) {\r\nfull_bucket = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&iwpm_mapinfo_lock, flags);\r\nreturn full_bucket;\r\n}
