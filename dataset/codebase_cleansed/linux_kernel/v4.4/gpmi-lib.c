static int clear_poll_bit(void __iomem *addr, u32 mask)\r\n{\r\nint timeout = 0x400;\r\nwritel(mask, addr + MXS_CLR_ADDR);\r\nudelay(1);\r\nwhile ((readl(addr) & mask) && --timeout)\r\n;\r\nreturn !timeout;\r\n}\r\nstatic int gpmi_reset_block(void __iomem *reset_addr, bool just_enable)\r\n{\r\nint ret;\r\nint timeout = 0x400;\r\nret = clear_poll_bit(reset_addr, MODULE_SFTRST);\r\nif (unlikely(ret))\r\ngoto error;\r\nwritel(MODULE_CLKGATE, reset_addr + MXS_CLR_ADDR);\r\nif (!just_enable) {\r\nwritel(MODULE_SFTRST, reset_addr + MXS_SET_ADDR);\r\nudelay(1);\r\nwhile ((!(readl(reset_addr) & MODULE_CLKGATE)) && --timeout)\r\n;\r\nif (unlikely(!timeout))\r\ngoto error;\r\n}\r\nret = clear_poll_bit(reset_addr, MODULE_SFTRST);\r\nif (unlikely(ret))\r\ngoto error;\r\nret = clear_poll_bit(reset_addr, MODULE_CLKGATE);\r\nif (unlikely(ret))\r\ngoto error;\r\nreturn 0;\r\nerror:\r\npr_err("%s(%p): module reset timeout\n", __func__, reset_addr);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int __gpmi_enable_clk(struct gpmi_nand_data *this, bool v)\r\n{\r\nstruct clk *clk;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < GPMI_CLK_MAX; i++) {\r\nclk = this->resources.clock[i];\r\nif (!clk)\r\nbreak;\r\nif (v) {\r\nret = clk_prepare_enable(clk);\r\nif (ret)\r\ngoto err_clk;\r\n} else {\r\nclk_disable_unprepare(clk);\r\n}\r\n}\r\nreturn 0;\r\nerr_clk:\r\nfor (; i > 0; i--)\r\nclk_disable_unprepare(this->resources.clock[i - 1]);\r\nreturn ret;\r\n}\r\nint gpmi_init(struct gpmi_nand_data *this)\r\n{\r\nstruct resources *r = &this->resources;\r\nint ret;\r\nret = gpmi_enable_clk(this);\r\nif (ret)\r\ngoto err_out;\r\nret = gpmi_reset_block(r->gpmi_regs, false);\r\nif (ret)\r\ngoto err_out;\r\nret = gpmi_reset_block(r->bch_regs, GPMI_IS_MX23(this));\r\nif (ret)\r\ngoto err_out;\r\nwritel(BM_GPMI_CTRL1_GPMI_MODE, r->gpmi_regs + HW_GPMI_CTRL1_CLR);\r\nwritel(BM_GPMI_CTRL1_ATA_IRQRDY_POLARITY,\r\nr->gpmi_regs + HW_GPMI_CTRL1_SET);\r\nwritel(BM_GPMI_CTRL1_DEV_RESET, r->gpmi_regs + HW_GPMI_CTRL1_SET);\r\nwritel(BM_GPMI_CTRL1_BCH_MODE, r->gpmi_regs + HW_GPMI_CTRL1_SET);\r\nwritel(BM_GPMI_CTRL1_DECOUPLE_CS, r->gpmi_regs + HW_GPMI_CTRL1_SET);\r\ngpmi_disable_clk(this);\r\nreturn 0;\r\nerr_out:\r\nreturn ret;\r\n}\r\nvoid gpmi_dump_info(struct gpmi_nand_data *this)\r\n{\r\nstruct resources *r = &this->resources;\r\nstruct bch_geometry *geo = &this->bch_geometry;\r\nu32 reg;\r\nint i;\r\ndev_err(this->dev, "Show GPMI registers :\n");\r\nfor (i = 0; i <= HW_GPMI_DEBUG / 0x10 + 1; i++) {\r\nreg = readl(r->gpmi_regs + i * 0x10);\r\ndev_err(this->dev, "offset 0x%.3x : 0x%.8x\n", i * 0x10, reg);\r\n}\r\ndev_err(this->dev, "Show BCH registers :\n");\r\nfor (i = 0; i <= HW_BCH_VERSION / 0x10 + 1; i++) {\r\nreg = readl(r->bch_regs + i * 0x10);\r\ndev_err(this->dev, "offset 0x%.3x : 0x%.8x\n", i * 0x10, reg);\r\n}\r\ndev_err(this->dev, "BCH Geometry :\n"\r\n"GF length : %u\n"\r\n"ECC Strength : %u\n"\r\n"Page Size in Bytes : %u\n"\r\n"Metadata Size in Bytes : %u\n"\r\n"ECC Chunk Size in Bytes: %u\n"\r\n"ECC Chunk Count : %u\n"\r\n"Payload Size in Bytes : %u\n"\r\n"Auxiliary Size in Bytes: %u\n"\r\n"Auxiliary Status Offset: %u\n"\r\n"Block Mark Byte Offset : %u\n"\r\n"Block Mark Bit Offset : %u\n",\r\ngeo->gf_len,\r\ngeo->ecc_strength,\r\ngeo->page_size,\r\ngeo->metadata_size,\r\ngeo->ecc_chunk_size,\r\ngeo->ecc_chunk_count,\r\ngeo->payload_size,\r\ngeo->auxiliary_size,\r\ngeo->auxiliary_status_offset,\r\ngeo->block_mark_byte_offset,\r\ngeo->block_mark_bit_offset);\r\n}\r\nint bch_set_geometry(struct gpmi_nand_data *this)\r\n{\r\nstruct resources *r = &this->resources;\r\nstruct bch_geometry *bch_geo = &this->bch_geometry;\r\nunsigned int block_count;\r\nunsigned int block_size;\r\nunsigned int metadata_size;\r\nunsigned int ecc_strength;\r\nunsigned int page_size;\r\nunsigned int gf_len;\r\nint ret;\r\nif (common_nfc_set_geometry(this))\r\nreturn !0;\r\nblock_count = bch_geo->ecc_chunk_count - 1;\r\nblock_size = bch_geo->ecc_chunk_size;\r\nmetadata_size = bch_geo->metadata_size;\r\necc_strength = bch_geo->ecc_strength >> 1;\r\npage_size = bch_geo->page_size;\r\ngf_len = bch_geo->gf_len;\r\nret = gpmi_enable_clk(this);\r\nif (ret)\r\ngoto err_out;\r\nret = gpmi_reset_block(r->bch_regs, GPMI_IS_MX23(this));\r\nif (ret)\r\ngoto err_out;\r\nwritel(BF_BCH_FLASH0LAYOUT0_NBLOCKS(block_count)\r\n| BF_BCH_FLASH0LAYOUT0_META_SIZE(metadata_size)\r\n| BF_BCH_FLASH0LAYOUT0_ECC0(ecc_strength, this)\r\n| BF_BCH_FLASH0LAYOUT0_GF(gf_len, this)\r\n| BF_BCH_FLASH0LAYOUT0_DATA0_SIZE(block_size, this),\r\nr->bch_regs + HW_BCH_FLASH0LAYOUT0);\r\nwritel(BF_BCH_FLASH0LAYOUT1_PAGE_SIZE(page_size)\r\n| BF_BCH_FLASH0LAYOUT1_ECCN(ecc_strength, this)\r\n| BF_BCH_FLASH0LAYOUT1_GF(gf_len, this)\r\n| BF_BCH_FLASH0LAYOUT1_DATAN_SIZE(block_size, this),\r\nr->bch_regs + HW_BCH_FLASH0LAYOUT1);\r\nwritel(0, r->bch_regs + HW_BCH_LAYOUTSELECT);\r\nwritel(BM_BCH_CTRL_COMPLETE_IRQ_EN,\r\nr->bch_regs + HW_BCH_CTRL_SET);\r\ngpmi_disable_clk(this);\r\nreturn 0;\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic unsigned int ns_to_cycles(unsigned int time,\r\nunsigned int period, unsigned int min)\r\n{\r\nunsigned int k;\r\nk = (time + period - 1) / period;\r\nreturn max(k, min);\r\n}\r\nstatic int gpmi_nfc_compute_hardware_timing(struct gpmi_nand_data *this,\r\nstruct gpmi_nfc_hardware_timing *hw)\r\n{\r\nstruct timing_threshod *nfc = &timing_default_threshold;\r\nstruct resources *r = &this->resources;\r\nstruct nand_chip *nand = &this->nand;\r\nstruct nand_timing target = this->timing;\r\nbool improved_timing_is_available;\r\nunsigned long clock_frequency_in_hz;\r\nunsigned int clock_period_in_ns;\r\nbool dll_use_half_periods;\r\nunsigned int dll_delay_shift;\r\nunsigned int max_sample_delay_in_ns;\r\nunsigned int address_setup_in_cycles;\r\nunsigned int data_setup_in_ns;\r\nunsigned int data_setup_in_cycles;\r\nunsigned int data_hold_in_cycles;\r\nint ideal_sample_delay_in_ns;\r\nunsigned int sample_delay_factor;\r\nint tEYE;\r\nunsigned int min_prop_delay_in_ns = DEF_MIN_PROP_DELAY;\r\nunsigned int max_prop_delay_in_ns = DEF_MAX_PROP_DELAY;\r\nif (nand->numchips > 2) {\r\ntarget.data_setup_in_ns += 10;\r\ntarget.data_hold_in_ns += 10;\r\ntarget.address_setup_in_ns += 10;\r\n} else if (nand->numchips > 1) {\r\ntarget.data_setup_in_ns += 5;\r\ntarget.data_hold_in_ns += 5;\r\ntarget.address_setup_in_ns += 5;\r\n}\r\nimproved_timing_is_available =\r\n(target.tREA_in_ns >= 0) &&\r\n(target.tRLOH_in_ns >= 0) &&\r\n(target.tRHOH_in_ns >= 0);\r\nnfc->clock_frequency_in_hz = clk_get_rate(r->clock[0]);\r\nclock_frequency_in_hz = nfc->clock_frequency_in_hz;\r\nclock_period_in_ns = NSEC_PER_SEC / clock_frequency_in_hz;\r\ndata_setup_in_cycles = ns_to_cycles(target.data_setup_in_ns,\r\nclock_period_in_ns, 1);\r\ndata_hold_in_cycles = ns_to_cycles(target.data_hold_in_ns,\r\nclock_period_in_ns, 1);\r\naddress_setup_in_cycles = ns_to_cycles(target.address_setup_in_ns,\r\nclock_period_in_ns, 0);\r\nif (clock_period_in_ns > (nfc->max_dll_clock_period_in_ns >> 1)) {\r\ndll_use_half_periods = true;\r\ndll_delay_shift = 3 + 1;\r\n} else {\r\ndll_use_half_periods = false;\r\ndll_delay_shift = 3;\r\n}\r\nif (clock_period_in_ns > nfc->max_dll_clock_period_in_ns)\r\nmax_sample_delay_in_ns = 0;\r\nelse {\r\nmax_sample_delay_in_ns =\r\n(nfc->max_sample_delay_factor * clock_period_in_ns) >>\r\ndll_delay_shift;\r\nif (max_sample_delay_in_ns > nfc->max_dll_delay_in_ns)\r\nmax_sample_delay_in_ns = nfc->max_dll_delay_in_ns;\r\n}\r\nif (!improved_timing_is_available) {\r\nideal_sample_delay_in_ns = target.gpmi_sample_delay_in_ns +\r\nnfc->internal_data_setup_in_ns;\r\nwhile ((ideal_sample_delay_in_ns > max_sample_delay_in_ns) &&\r\n(data_setup_in_cycles < nfc->max_data_setup_cycles)) {\r\ndata_setup_in_cycles++;\r\nideal_sample_delay_in_ns -= clock_period_in_ns;\r\nif (ideal_sample_delay_in_ns < 0)\r\nideal_sample_delay_in_ns = 0;\r\n}\r\nsample_delay_factor =\r\nns_to_cycles(\r\nideal_sample_delay_in_ns << dll_delay_shift,\r\nclock_period_in_ns, 0);\r\nif (sample_delay_factor > nfc->max_sample_delay_factor)\r\nsample_delay_factor = nfc->max_sample_delay_factor;\r\ngoto return_results;\r\n}\r\nmax_prop_delay_in_ns += nfc->internal_data_setup_in_ns;\r\ndata_setup_in_ns = clock_period_in_ns * data_setup_in_cycles;\r\ntEYE = (int)min_prop_delay_in_ns + (int)target.tRHOH_in_ns +\r\n(int)data_setup_in_ns;\r\ntEYE -= (int)max_prop_delay_in_ns + (int)target.tREA_in_ns;\r\nwhile ((tEYE <= 0) &&\r\n(data_setup_in_cycles < nfc->max_data_setup_cycles)) {\r\ndata_setup_in_cycles++;\r\ndata_setup_in_ns += clock_period_in_ns;\r\ntEYE += clock_period_in_ns;\r\n}\r\nideal_sample_delay_in_ns =\r\n((int)max_prop_delay_in_ns +\r\n(int)target.tREA_in_ns +\r\n(int)min_prop_delay_in_ns +\r\n(int)target.tRHOH_in_ns -\r\n(int)data_setup_in_ns) >> 1;\r\nif (ideal_sample_delay_in_ns < 0)\r\nideal_sample_delay_in_ns = 0;\r\nwhile ((ideal_sample_delay_in_ns > max_sample_delay_in_ns) &&\r\n(data_setup_in_cycles < nfc->max_data_setup_cycles)) {\r\ndata_setup_in_cycles++;\r\ndata_setup_in_ns += clock_period_in_ns;\r\ntEYE += clock_period_in_ns;\r\nideal_sample_delay_in_ns -= (clock_period_in_ns >> 1);\r\nif (ideal_sample_delay_in_ns < 0)\r\nideal_sample_delay_in_ns = 0;\r\n}\r\nsample_delay_factor =\r\nns_to_cycles(ideal_sample_delay_in_ns << dll_delay_shift,\r\nclock_period_in_ns, 0);\r\nif (sample_delay_factor > nfc->max_sample_delay_factor)\r\nsample_delay_factor = nfc->max_sample_delay_factor;\r\n#define IDEAL_DELAY ((int) ideal_sample_delay_in_ns)\r\n#define QUANTIZED_DELAY \\r\n((int) ((sample_delay_factor * clock_period_in_ns) >> \\r\ndll_delay_shift))\r\n#define DELAY_ERROR (abs(QUANTIZED_DELAY - IDEAL_DELAY))\r\n#define SAMPLE_IS_NOT_WITHIN_THE_EYE (DELAY_ERROR > (tEYE >> 1))\r\nwhile (SAMPLE_IS_NOT_WITHIN_THE_EYE &&\r\n(data_setup_in_cycles < nfc->max_data_setup_cycles)) {\r\nif (QUANTIZED_DELAY > IDEAL_DELAY) {\r\nif (sample_delay_factor != 0)\r\nsample_delay_factor--;\r\ncontinue;\r\n}\r\ndata_setup_in_cycles++;\r\ndata_setup_in_ns += clock_period_in_ns;\r\ntEYE += clock_period_in_ns;\r\nideal_sample_delay_in_ns -= (clock_period_in_ns >> 1);\r\nideal_sample_delay_in_ns -= clock_period_in_ns;\r\nif (ideal_sample_delay_in_ns < 0)\r\nideal_sample_delay_in_ns = 0;\r\nsample_delay_factor =\r\nns_to_cycles(\r\nideal_sample_delay_in_ns << dll_delay_shift,\r\nclock_period_in_ns, 0);\r\nif (sample_delay_factor > nfc->max_sample_delay_factor)\r\nsample_delay_factor = nfc->max_sample_delay_factor;\r\n}\r\nreturn_results:\r\nhw->data_setup_in_cycles = data_setup_in_cycles;\r\nhw->data_hold_in_cycles = data_hold_in_cycles;\r\nhw->address_setup_in_cycles = address_setup_in_cycles;\r\nhw->use_half_periods = dll_use_half_periods;\r\nhw->sample_delay_factor = sample_delay_factor;\r\nhw->device_busy_timeout = GPMI_DEFAULT_BUSY_TIMEOUT;\r\nhw->wrn_dly_sel = BV_GPMI_CTRL1_WRN_DLY_SEL_4_TO_8NS;\r\nreturn 0;\r\n}\r\nstatic void gpmi_compute_edo_timing(struct gpmi_nand_data *this,\r\nstruct gpmi_nfc_hardware_timing *hw)\r\n{\r\nstruct resources *r = &this->resources;\r\nunsigned long rate = clk_get_rate(r->clock[0]);\r\nint mode = this->timing_mode;\r\nint dll_threshold = this->devdata->max_chain_delay;\r\nunsigned long delay;\r\nunsigned long clk_period;\r\nint t_rea;\r\nint c = 4;\r\nint t_rp;\r\nint rp;\r\nhw->data_setup_in_cycles = 1;\r\nhw->data_hold_in_cycles = 1;\r\nhw->address_setup_in_cycles = ((mode == 5) ? 1 : 0);\r\nhw->device_busy_timeout = 0x9000;\r\nhw->wrn_dly_sel = BV_GPMI_CTRL1_WRN_DLY_SEL_NO_DELAY;\r\nclk_period = NSEC_PER_SEC / (rate / 10);\r\ndll_threshold *= 10;\r\nt_rea = ((mode == 5) ? 16 : 20) * 10;\r\nc *= 10;\r\nt_rp = clk_period * 1;\r\nif (clk_period > dll_threshold) {\r\nhw->use_half_periods = 1;\r\nrp = clk_period / 2;\r\n} else {\r\nhw->use_half_periods = 0;\r\nrp = clk_period;\r\n}\r\ndelay = (((t_rea + c - t_rp) * 8) * 10) / rp;\r\ndelay = (delay + 5) / 10;\r\nhw->sample_delay_factor = delay;\r\n}\r\nstatic int enable_edo_mode(struct gpmi_nand_data *this, int mode)\r\n{\r\nstruct resources *r = &this->resources;\r\nstruct nand_chip *nand = &this->nand;\r\nstruct mtd_info *mtd = &this->mtd;\r\nuint8_t *feature;\r\nunsigned long rate;\r\nint ret;\r\nfeature = kzalloc(ONFI_SUBFEATURE_PARAM_LEN, GFP_KERNEL);\r\nif (!feature)\r\nreturn -ENOMEM;\r\nnand->select_chip(mtd, 0);\r\nfeature[0] = mode;\r\nret = nand->onfi_set_features(mtd, nand,\r\nONFI_FEATURE_ADDR_TIMING_MODE, feature);\r\nif (ret)\r\ngoto err_out;\r\nmemset(feature, 0, ONFI_SUBFEATURE_PARAM_LEN);\r\nret = nand->onfi_get_features(mtd, nand,\r\nONFI_FEATURE_ADDR_TIMING_MODE, feature);\r\nif (ret || feature[0] != mode)\r\ngoto err_out;\r\nnand->select_chip(mtd, -1);\r\nrate = (mode == 5) ? 100000000 : 80000000;\r\nclk_set_rate(r->clock[0], rate);\r\nthis->flags &= ~GPMI_TIMING_INIT_OK;\r\nthis->flags |= GPMI_ASYNC_EDO_ENABLED;\r\nthis->timing_mode = mode;\r\nkfree(feature);\r\ndev_info(this->dev, "enable the asynchronous EDO mode %d\n", mode);\r\nreturn 0;\r\nerr_out:\r\nnand->select_chip(mtd, -1);\r\nkfree(feature);\r\ndev_err(this->dev, "mode:%d ,failed in set feature.\n", mode);\r\nreturn -EINVAL;\r\n}\r\nint gpmi_extra_init(struct gpmi_nand_data *this)\r\n{\r\nstruct nand_chip *chip = &this->nand;\r\nif (GPMI_IS_MX6(this) && chip->onfi_version) {\r\nint mode = onfi_get_async_timing_mode(chip);\r\nif (mode & ONFI_TIMING_MODE_5)\r\nmode = 5;\r\nelse if (mode & ONFI_TIMING_MODE_4)\r\nmode = 4;\r\nelse\r\nreturn 0;\r\nreturn enable_edo_mode(this, mode);\r\n}\r\nreturn 0;\r\n}\r\nvoid gpmi_begin(struct gpmi_nand_data *this)\r\n{\r\nstruct resources *r = &this->resources;\r\nvoid __iomem *gpmi_regs = r->gpmi_regs;\r\nunsigned int clock_period_in_ns;\r\nuint32_t reg;\r\nunsigned int dll_wait_time_in_us;\r\nstruct gpmi_nfc_hardware_timing hw;\r\nint ret;\r\nret = gpmi_enable_clk(this);\r\nif (ret) {\r\ndev_err(this->dev, "We failed in enable the clk\n");\r\ngoto err_out;\r\n}\r\nif (this->flags & GPMI_TIMING_INIT_OK)\r\nreturn;\r\nthis->flags |= GPMI_TIMING_INIT_OK;\r\nif (this->flags & GPMI_ASYNC_EDO_ENABLED)\r\ngpmi_compute_edo_timing(this, &hw);\r\nelse\r\ngpmi_nfc_compute_hardware_timing(this, &hw);\r\nreg = BF_GPMI_TIMING0_ADDRESS_SETUP(hw.address_setup_in_cycles) |\r\nBF_GPMI_TIMING0_DATA_HOLD(hw.data_hold_in_cycles) |\r\nBF_GPMI_TIMING0_DATA_SETUP(hw.data_setup_in_cycles);\r\nwritel(reg, gpmi_regs + HW_GPMI_TIMING0);\r\nwritel(BF_GPMI_TIMING1_BUSY_TIMEOUT(hw.device_busy_timeout),\r\ngpmi_regs + HW_GPMI_TIMING1);\r\nwritel(BM_GPMI_CTRL1_WRN_DLY_SEL, gpmi_regs + HW_GPMI_CTRL1_CLR);\r\nwritel(BF_GPMI_CTRL1_WRN_DLY_SEL(hw.wrn_dly_sel),\r\ngpmi_regs + HW_GPMI_CTRL1_SET);\r\nwritel(BM_GPMI_CTRL1_DLL_ENABLE, gpmi_regs + HW_GPMI_CTRL1_CLR);\r\nreg = BM_GPMI_CTRL1_RDN_DELAY | BM_GPMI_CTRL1_HALF_PERIOD;\r\nwritel(reg, gpmi_regs + HW_GPMI_CTRL1_CLR);\r\nif (!hw.sample_delay_factor)\r\nreturn;\r\nreg = ((hw.use_half_periods) ? BM_GPMI_CTRL1_HALF_PERIOD : 0)\r\n| BF_GPMI_CTRL1_RDN_DELAY(hw.sample_delay_factor);\r\nwritel(reg, gpmi_regs + HW_GPMI_CTRL1_SET);\r\nwritel(BM_GPMI_CTRL1_DLL_ENABLE, gpmi_regs + HW_GPMI_CTRL1_SET);\r\nclock_period_in_ns = NSEC_PER_SEC / clk_get_rate(r->clock[0]);\r\ndll_wait_time_in_us = (clock_period_in_ns * 64) / 1000;\r\nif (!dll_wait_time_in_us)\r\ndll_wait_time_in_us = 1;\r\nudelay(dll_wait_time_in_us);\r\nerr_out:\r\nreturn;\r\n}\r\nvoid gpmi_end(struct gpmi_nand_data *this)\r\n{\r\ngpmi_disable_clk(this);\r\n}\r\nvoid gpmi_clear_bch(struct gpmi_nand_data *this)\r\n{\r\nstruct resources *r = &this->resources;\r\nwritel(BM_BCH_CTRL_COMPLETE_IRQ, r->bch_regs + HW_BCH_CTRL_CLR);\r\n}\r\nint gpmi_is_ready(struct gpmi_nand_data *this, unsigned chip)\r\n{\r\nstruct resources *r = &this->resources;\r\nuint32_t mask = 0;\r\nuint32_t reg = 0;\r\nif (GPMI_IS_MX23(this)) {\r\nmask = MX23_BM_GPMI_DEBUG_READY0 << chip;\r\nreg = readl(r->gpmi_regs + HW_GPMI_DEBUG);\r\n} else if (GPMI_IS_MX28(this) || GPMI_IS_MX6(this)) {\r\nif (GPMI_IS_MX6(this))\r\nchip = 0;\r\nmask = MX28_BF_GPMI_STAT_READY_BUSY(1 << chip);\r\nreg = readl(r->gpmi_regs + HW_GPMI_STAT);\r\n} else\r\ndev_err(this->dev, "unknown arch.\n");\r\nreturn reg & mask;\r\n}\r\nstatic inline void set_dma_type(struct gpmi_nand_data *this,\r\nenum dma_ops_type type)\r\n{\r\nthis->last_dma_type = this->dma_type;\r\nthis->dma_type = type;\r\n}\r\nint gpmi_send_command(struct gpmi_nand_data *this)\r\n{\r\nstruct dma_chan *channel = get_dma_chan(this);\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct scatterlist *sgl;\r\nint chip = this->current_chip;\r\nu32 pio[3];\r\npio[0] = BF_GPMI_CTRL0_COMMAND_MODE(BV_GPMI_CTRL0_COMMAND_MODE__WRITE)\r\n| BM_GPMI_CTRL0_WORD_LENGTH\r\n| BF_GPMI_CTRL0_CS(chip, this)\r\n| BF_GPMI_CTRL0_LOCK_CS(LOCK_CS_ENABLE, this)\r\n| BF_GPMI_CTRL0_ADDRESS(BV_GPMI_CTRL0_ADDRESS__NAND_CLE)\r\n| BM_GPMI_CTRL0_ADDRESS_INCREMENT\r\n| BF_GPMI_CTRL0_XFER_COUNT(this->command_length);\r\npio[1] = pio[2] = 0;\r\ndesc = dmaengine_prep_slave_sg(channel,\r\n(struct scatterlist *)pio,\r\nARRAY_SIZE(pio), DMA_TRANS_NONE, 0);\r\nif (!desc)\r\nreturn -EINVAL;\r\nsgl = &this->cmd_sgl;\r\nsg_init_one(sgl, this->cmd_buffer, this->command_length);\r\ndma_map_sg(this->dev, sgl, 1, DMA_TO_DEVICE);\r\ndesc = dmaengine_prep_slave_sg(channel,\r\nsgl, 1, DMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc)\r\nreturn -EINVAL;\r\nset_dma_type(this, DMA_FOR_COMMAND);\r\nreturn start_dma_without_bch_irq(this, desc);\r\n}\r\nint gpmi_send_data(struct gpmi_nand_data *this)\r\n{\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct dma_chan *channel = get_dma_chan(this);\r\nint chip = this->current_chip;\r\nuint32_t command_mode;\r\nuint32_t address;\r\nu32 pio[2];\r\ncommand_mode = BV_GPMI_CTRL0_COMMAND_MODE__WRITE;\r\naddress = BV_GPMI_CTRL0_ADDRESS__NAND_DATA;\r\npio[0] = BF_GPMI_CTRL0_COMMAND_MODE(command_mode)\r\n| BM_GPMI_CTRL0_WORD_LENGTH\r\n| BF_GPMI_CTRL0_CS(chip, this)\r\n| BF_GPMI_CTRL0_LOCK_CS(LOCK_CS_ENABLE, this)\r\n| BF_GPMI_CTRL0_ADDRESS(address)\r\n| BF_GPMI_CTRL0_XFER_COUNT(this->upper_len);\r\npio[1] = 0;\r\ndesc = dmaengine_prep_slave_sg(channel, (struct scatterlist *)pio,\r\nARRAY_SIZE(pio), DMA_TRANS_NONE, 0);\r\nif (!desc)\r\nreturn -EINVAL;\r\nprepare_data_dma(this, DMA_TO_DEVICE);\r\ndesc = dmaengine_prep_slave_sg(channel, &this->data_sgl,\r\n1, DMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc)\r\nreturn -EINVAL;\r\nset_dma_type(this, DMA_FOR_WRITE_DATA);\r\nreturn start_dma_without_bch_irq(this, desc);\r\n}\r\nint gpmi_read_data(struct gpmi_nand_data *this)\r\n{\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct dma_chan *channel = get_dma_chan(this);\r\nint chip = this->current_chip;\r\nu32 pio[2];\r\npio[0] = BF_GPMI_CTRL0_COMMAND_MODE(BV_GPMI_CTRL0_COMMAND_MODE__READ)\r\n| BM_GPMI_CTRL0_WORD_LENGTH\r\n| BF_GPMI_CTRL0_CS(chip, this)\r\n| BF_GPMI_CTRL0_LOCK_CS(LOCK_CS_ENABLE, this)\r\n| BF_GPMI_CTRL0_ADDRESS(BV_GPMI_CTRL0_ADDRESS__NAND_DATA)\r\n| BF_GPMI_CTRL0_XFER_COUNT(this->upper_len);\r\npio[1] = 0;\r\ndesc = dmaengine_prep_slave_sg(channel,\r\n(struct scatterlist *)pio,\r\nARRAY_SIZE(pio), DMA_TRANS_NONE, 0);\r\nif (!desc)\r\nreturn -EINVAL;\r\nprepare_data_dma(this, DMA_FROM_DEVICE);\r\ndesc = dmaengine_prep_slave_sg(channel, &this->data_sgl,\r\n1, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc)\r\nreturn -EINVAL;\r\nset_dma_type(this, DMA_FOR_READ_DATA);\r\nreturn start_dma_without_bch_irq(this, desc);\r\n}\r\nint gpmi_send_page(struct gpmi_nand_data *this,\r\ndma_addr_t payload, dma_addr_t auxiliary)\r\n{\r\nstruct bch_geometry *geo = &this->bch_geometry;\r\nuint32_t command_mode;\r\nuint32_t address;\r\nuint32_t ecc_command;\r\nuint32_t buffer_mask;\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct dma_chan *channel = get_dma_chan(this);\r\nint chip = this->current_chip;\r\nu32 pio[6];\r\ncommand_mode = BV_GPMI_CTRL0_COMMAND_MODE__WRITE;\r\naddress = BV_GPMI_CTRL0_ADDRESS__NAND_DATA;\r\necc_command = BV_GPMI_ECCCTRL_ECC_CMD__BCH_ENCODE;\r\nbuffer_mask = BV_GPMI_ECCCTRL_BUFFER_MASK__BCH_PAGE |\r\nBV_GPMI_ECCCTRL_BUFFER_MASK__BCH_AUXONLY;\r\npio[0] = BF_GPMI_CTRL0_COMMAND_MODE(command_mode)\r\n| BM_GPMI_CTRL0_WORD_LENGTH\r\n| BF_GPMI_CTRL0_CS(chip, this)\r\n| BF_GPMI_CTRL0_LOCK_CS(LOCK_CS_ENABLE, this)\r\n| BF_GPMI_CTRL0_ADDRESS(address)\r\n| BF_GPMI_CTRL0_XFER_COUNT(0);\r\npio[1] = 0;\r\npio[2] = BM_GPMI_ECCCTRL_ENABLE_ECC\r\n| BF_GPMI_ECCCTRL_ECC_CMD(ecc_command)\r\n| BF_GPMI_ECCCTRL_BUFFER_MASK(buffer_mask);\r\npio[3] = geo->page_size;\r\npio[4] = payload;\r\npio[5] = auxiliary;\r\ndesc = dmaengine_prep_slave_sg(channel,\r\n(struct scatterlist *)pio,\r\nARRAY_SIZE(pio), DMA_TRANS_NONE,\r\nDMA_CTRL_ACK);\r\nif (!desc)\r\nreturn -EINVAL;\r\nset_dma_type(this, DMA_FOR_WRITE_ECC_PAGE);\r\nreturn start_dma_with_bch_irq(this, desc);\r\n}\r\nint gpmi_read_page(struct gpmi_nand_data *this,\r\ndma_addr_t payload, dma_addr_t auxiliary)\r\n{\r\nstruct bch_geometry *geo = &this->bch_geometry;\r\nuint32_t command_mode;\r\nuint32_t address;\r\nuint32_t ecc_command;\r\nuint32_t buffer_mask;\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct dma_chan *channel = get_dma_chan(this);\r\nint chip = this->current_chip;\r\nu32 pio[6];\r\ncommand_mode = BV_GPMI_CTRL0_COMMAND_MODE__WAIT_FOR_READY;\r\naddress = BV_GPMI_CTRL0_ADDRESS__NAND_DATA;\r\npio[0] = BF_GPMI_CTRL0_COMMAND_MODE(command_mode)\r\n| BM_GPMI_CTRL0_WORD_LENGTH\r\n| BF_GPMI_CTRL0_CS(chip, this)\r\n| BF_GPMI_CTRL0_LOCK_CS(LOCK_CS_ENABLE, this)\r\n| BF_GPMI_CTRL0_ADDRESS(address)\r\n| BF_GPMI_CTRL0_XFER_COUNT(0);\r\npio[1] = 0;\r\ndesc = dmaengine_prep_slave_sg(channel,\r\n(struct scatterlist *)pio, 2,\r\nDMA_TRANS_NONE, 0);\r\nif (!desc)\r\nreturn -EINVAL;\r\ncommand_mode = BV_GPMI_CTRL0_COMMAND_MODE__READ;\r\naddress = BV_GPMI_CTRL0_ADDRESS__NAND_DATA;\r\necc_command = BV_GPMI_ECCCTRL_ECC_CMD__BCH_DECODE;\r\nbuffer_mask = BV_GPMI_ECCCTRL_BUFFER_MASK__BCH_PAGE\r\n| BV_GPMI_ECCCTRL_BUFFER_MASK__BCH_AUXONLY;\r\npio[0] = BF_GPMI_CTRL0_COMMAND_MODE(command_mode)\r\n| BM_GPMI_CTRL0_WORD_LENGTH\r\n| BF_GPMI_CTRL0_CS(chip, this)\r\n| BF_GPMI_CTRL0_LOCK_CS(LOCK_CS_ENABLE, this)\r\n| BF_GPMI_CTRL0_ADDRESS(address)\r\n| BF_GPMI_CTRL0_XFER_COUNT(geo->page_size);\r\npio[1] = 0;\r\npio[2] = BM_GPMI_ECCCTRL_ENABLE_ECC\r\n| BF_GPMI_ECCCTRL_ECC_CMD(ecc_command)\r\n| BF_GPMI_ECCCTRL_BUFFER_MASK(buffer_mask);\r\npio[3] = geo->page_size;\r\npio[4] = payload;\r\npio[5] = auxiliary;\r\ndesc = dmaengine_prep_slave_sg(channel,\r\n(struct scatterlist *)pio,\r\nARRAY_SIZE(pio), DMA_TRANS_NONE,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc)\r\nreturn -EINVAL;\r\ncommand_mode = BV_GPMI_CTRL0_COMMAND_MODE__WAIT_FOR_READY;\r\naddress = BV_GPMI_CTRL0_ADDRESS__NAND_DATA;\r\npio[0] = BF_GPMI_CTRL0_COMMAND_MODE(command_mode)\r\n| BM_GPMI_CTRL0_WORD_LENGTH\r\n| BF_GPMI_CTRL0_CS(chip, this)\r\n| BF_GPMI_CTRL0_LOCK_CS(LOCK_CS_ENABLE, this)\r\n| BF_GPMI_CTRL0_ADDRESS(address)\r\n| BF_GPMI_CTRL0_XFER_COUNT(geo->page_size);\r\npio[1] = 0;\r\npio[2] = 0;\r\ndesc = dmaengine_prep_slave_sg(channel,\r\n(struct scatterlist *)pio, 3,\r\nDMA_TRANS_NONE,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc)\r\nreturn -EINVAL;\r\nset_dma_type(this, DMA_FOR_READ_ECC_PAGE);\r\nreturn start_dma_with_bch_irq(this, desc);\r\n}\r\nvoid gpmi_copy_bits(u8 *dst, size_t dst_bit_off,\r\nconst u8 *src, size_t src_bit_off,\r\nsize_t nbits)\r\n{\r\nsize_t i;\r\nsize_t nbytes;\r\nu32 src_buffer = 0;\r\nsize_t bits_in_src_buffer = 0;\r\nif (!nbits)\r\nreturn;\r\nsrc += src_bit_off / 8;\r\nsrc_bit_off %= 8;\r\ndst += dst_bit_off / 8;\r\ndst_bit_off %= 8;\r\nif (src_bit_off) {\r\nsrc_buffer = src[0] >> src_bit_off;\r\nif (nbits >= (8 - src_bit_off)) {\r\nbits_in_src_buffer += 8 - src_bit_off;\r\n} else {\r\nsrc_buffer &= GENMASK(nbits - 1, 0);\r\nbits_in_src_buffer += nbits;\r\n}\r\nnbits -= bits_in_src_buffer;\r\nsrc++;\r\n}\r\nnbytes = nbits / 8;\r\nif (dst_bit_off) {\r\nif (bits_in_src_buffer < (8 - dst_bit_off) && nbytes) {\r\nsrc_buffer |= src[0] << bits_in_src_buffer;\r\nbits_in_src_buffer += 8;\r\nsrc++;\r\nnbytes--;\r\n}\r\nif (bits_in_src_buffer >= (8 - dst_bit_off)) {\r\ndst[0] &= GENMASK(dst_bit_off - 1, 0);\r\ndst[0] |= src_buffer << dst_bit_off;\r\nsrc_buffer >>= (8 - dst_bit_off);\r\nbits_in_src_buffer -= (8 - dst_bit_off);\r\ndst_bit_off = 0;\r\ndst++;\r\nif (bits_in_src_buffer > 7) {\r\nbits_in_src_buffer -= 8;\r\ndst[0] = src_buffer;\r\ndst++;\r\nsrc_buffer >>= 8;\r\n}\r\n}\r\n}\r\nif (!bits_in_src_buffer && !dst_bit_off) {\r\nif (nbytes)\r\nmemcpy(dst, src, nbytes);\r\n} else {\r\nfor (i = 0; i < nbytes; i++) {\r\nsrc_buffer |= src[i] << bits_in_src_buffer;\r\ndst[i] = src_buffer;\r\nsrc_buffer >>= 8;\r\n}\r\n}\r\ndst += nbytes;\r\nsrc += nbytes;\r\nnbits %= 8;\r\nif (!nbits && !bits_in_src_buffer)\r\nreturn;\r\nif (nbits)\r\nsrc_buffer |= (*src & GENMASK(nbits - 1, 0)) <<\r\nbits_in_src_buffer;\r\nbits_in_src_buffer += nbits;\r\nif (dst_bit_off)\r\nsrc_buffer = (src_buffer << dst_bit_off) |\r\n(*dst & GENMASK(dst_bit_off - 1, 0));\r\nbits_in_src_buffer += dst_bit_off;\r\nnbytes = bits_in_src_buffer / 8;\r\nif (bits_in_src_buffer % 8) {\r\nsrc_buffer |= (dst[nbytes] &\r\nGENMASK(7, bits_in_src_buffer % 8)) <<\r\n(nbytes * 8);\r\nnbytes++;\r\n}\r\nfor (i = 0; i < nbytes; i++) {\r\ndst[i] = src_buffer;\r\nsrc_buffer >>= 8;\r\n}\r\n}
