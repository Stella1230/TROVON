static int pci_dio_insn_bits_di_b(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nconst struct diosubd_data *d = (const struct diosubd_data *)s->private;\r\nint i;\r\ndata[1] = 0;\r\nfor (i = 0; i < d->regs; i++)\r\ndata[1] |= inb(dev->iobase + d->addr + i) << (8 * i);\r\nreturn insn->n;\r\n}\r\nstatic int pci_dio_insn_bits_di_w(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nconst struct diosubd_data *d = (const struct diosubd_data *)s->private;\r\nint i;\r\ndata[1] = 0;\r\nfor (i = 0; i < d->regs; i++)\r\ndata[1] |= inw(dev->iobase + d->addr + 2 * i) << (16 * i);\r\nreturn insn->n;\r\n}\r\nstatic int pci_dio_insn_bits_do_b(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nconst struct diosubd_data *d = (const struct diosubd_data *)s->private;\r\nint i;\r\nif (comedi_dio_update_state(s, data)) {\r\nfor (i = 0; i < d->regs; i++)\r\noutb((s->state >> (8 * i)) & 0xff,\r\ndev->iobase + d->addr + i);\r\n}\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic int pci_dio_insn_bits_do_w(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nconst struct diosubd_data *d = (const struct diosubd_data *)s->private;\r\nint i;\r\nif (comedi_dio_update_state(s, data)) {\r\nfor (i = 0; i < d->regs; i++)\r\noutw((s->state >> (16 * i)) & 0xffff,\r\ndev->iobase + d->addr + 2 * i);\r\n}\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic int pci1760_unchecked_mbxrequest(struct comedi_device *dev,\r\nunsigned char *omb, unsigned char *imb,\r\nint repeats)\r\n{\r\nint cnt, tout, ok = 0;\r\nfor (cnt = 0; cnt < repeats; cnt++) {\r\noutb(omb[0], dev->iobase + OMB0);\r\noutb(omb[1], dev->iobase + OMB1);\r\noutb(omb[2], dev->iobase + OMB2);\r\noutb(omb[3], dev->iobase + OMB3);\r\nfor (tout = 0; tout < 251; tout++) {\r\nimb[2] = inb(dev->iobase + IMB2);\r\nif (imb[2] == omb[2]) {\r\nimb[0] = inb(dev->iobase + IMB0);\r\nimb[1] = inb(dev->iobase + IMB1);\r\nimb[3] = inb(dev->iobase + IMB3);\r\nok = 1;\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\nif (ok)\r\nreturn 0;\r\n}\r\ndev_err(dev->class_dev, "PCI-1760 mailbox request timeout!\n");\r\nreturn -ETIME;\r\n}\r\nstatic int pci1760_clear_imb2(struct comedi_device *dev)\r\n{\r\nunsigned char omb[4] = { 0x0, 0x0, CMD_ClearIMB2, 0x0 };\r\nunsigned char imb[4];\r\nif (inb(dev->iobase + IMB2) == CMD_ClearIMB2)\r\nreturn 0;\r\nreturn pci1760_unchecked_mbxrequest(dev, omb, imb, OMBCMD_RETRY);\r\n}\r\nstatic int pci1760_mbxrequest(struct comedi_device *dev,\r\nunsigned char *omb, unsigned char *imb)\r\n{\r\nif (omb[2] == CMD_ClearIMB2) {\r\ndev_err(dev->class_dev,\r\n"bug! this function should not be used for CMD_ClearIMB2 command\n");\r\nreturn -EINVAL;\r\n}\r\nif (inb(dev->iobase + IMB2) == omb[2]) {\r\nint retval;\r\nretval = pci1760_clear_imb2(dev);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nreturn pci1760_unchecked_mbxrequest(dev, omb, imb, OMBCMD_RETRY);\r\n}\r\nstatic int pci1760_insn_bits_di(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[1] = inb(dev->iobase + IMB3);\r\nreturn insn->n;\r\n}\r\nstatic int pci1760_insn_bits_do(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint ret;\r\nunsigned char omb[4] = {\r\n0x00,\r\n0x00,\r\nCMD_SetRelaysOutput,\r\n0x00\r\n};\r\nunsigned char imb[4];\r\nif (comedi_dio_update_state(s, data)) {\r\nomb[0] = s->state;\r\nret = pci1760_mbxrequest(dev, omb, imb);\r\nif (!ret)\r\nreturn ret;\r\n}\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic int pci1760_insn_cnt_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint ret, n;\r\nunsigned char omb[4] = {\r\nCR_CHAN(insn->chanspec) & 0x07,\r\n0x00,\r\nCMD_GetIDICntCurValue,\r\n0x00\r\n};\r\nunsigned char imb[4];\r\nfor (n = 0; n < insn->n; n++) {\r\nret = pci1760_mbxrequest(dev, omb, imb);\r\nif (!ret)\r\nreturn ret;\r\ndata[n] = (imb[1] << 8) + imb[0];\r\n}\r\nreturn n;\r\n}\r\nstatic int pci1760_insn_cnt_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct pci_dio_private *devpriv = dev->private;\r\nint ret;\r\nunsigned char chan = CR_CHAN(insn->chanspec) & 0x07;\r\nunsigned char bitmask = 1 << chan;\r\nunsigned char omb[4] = {\r\ndata[0] & 0xff,\r\n(data[0] >> 8) & 0xff,\r\nCMD_SetIDI0CntResetValue + chan,\r\n0x00\r\n};\r\nunsigned char imb[4];\r\nif (devpriv->CntResValue[chan] != (data[0] & 0xffff)) {\r\nret = pci1760_mbxrequest(dev, omb, imb);\r\nif (!ret)\r\nreturn ret;\r\ndevpriv->CntResValue[chan] = data[0] & 0xffff;\r\n}\r\nomb[0] = bitmask;\r\nomb[2] = CMD_ResetIDICounters;\r\nret = pci1760_mbxrequest(dev, omb, imb);\r\nif (!ret)\r\nreturn ret;\r\nif (!(bitmask & devpriv->IDICntEnable)) {\r\nomb[0] = bitmask;\r\nomb[2] = CMD_EnableIDICounters;\r\nret = pci1760_mbxrequest(dev, omb, imb);\r\nif (!ret)\r\nreturn ret;\r\ndevpriv->IDICntEnable |= bitmask;\r\n}\r\nreturn 1;\r\n}\r\nstatic int pci1760_reset(struct comedi_device *dev)\r\n{\r\nstruct pci_dio_private *devpriv = dev->private;\r\nint i;\r\nunsigned char omb[4] = { 0x00, 0x00, 0x00, 0x00 };\r\nunsigned char imb[4];\r\noutb(0, dev->iobase + INTCSR0);\r\noutb(0, dev->iobase + INTCSR1);\r\noutb(0, dev->iobase + INTCSR2);\r\noutb(0, dev->iobase + INTCSR3);\r\ndevpriv->GlobalIrqEnabled = 0;\r\nomb[0] = 0x00;\r\nomb[2] = CMD_SetRelaysOutput;\r\npci1760_mbxrequest(dev, omb, imb);\r\nomb[0] = 0x00;\r\nomb[2] = CMD_EnableIDICounters;\r\npci1760_mbxrequest(dev, omb, imb);\r\ndevpriv->IDICntEnable = 0;\r\nomb[0] = 0x00;\r\nomb[2] = CMD_OverflowIDICounters;\r\npci1760_mbxrequest(dev, omb, imb);\r\ndevpriv->IDICntOverEnable = 0;\r\nomb[0] = 0x00;\r\nomb[2] = CMD_MatchIntIDICounters;\r\npci1760_mbxrequest(dev, omb, imb);\r\ndevpriv->IDICntMatchEnable = 0;\r\nomb[0] = 0x00;\r\nomb[1] = 0x80;\r\nfor (i = 0; i < 8; i++) {\r\nomb[2] = CMD_SetIDI0CntMatchValue + i;\r\npci1760_mbxrequest(dev, omb, imb);\r\ndevpriv->CntMatchValue[i] = 0x8000;\r\n}\r\nomb[0] = 0x00;\r\nomb[1] = 0x00;\r\nfor (i = 0; i < 8; i++) {\r\nomb[2] = CMD_SetIDI0CntResetValue + i;\r\npci1760_mbxrequest(dev, omb, imb);\r\ndevpriv->CntResValue[i] = 0x0000;\r\n}\r\nomb[0] = 0xff;\r\nomb[2] = CMD_ResetIDICounters;\r\npci1760_mbxrequest(dev, omb, imb);\r\nomb[0] = 0x00;\r\nomb[2] = CMD_EdgeIDICounters;\r\npci1760_mbxrequest(dev, omb, imb);\r\ndevpriv->IDICntEdge = 0x00;\r\nomb[0] = 0x00;\r\nomb[2] = CMD_EnableIDIFilters;\r\npci1760_mbxrequest(dev, omb, imb);\r\ndevpriv->IDIFiltersEn = 0x00;\r\nomb[0] = 0x00;\r\nomb[2] = CMD_EnableIDIPatternMatch;\r\npci1760_mbxrequest(dev, omb, imb);\r\ndevpriv->IDIPatMatchEn = 0x00;\r\nomb[0] = 0x00;\r\nomb[2] = CMD_SetIDIPatternMatch;\r\npci1760_mbxrequest(dev, omb, imb);\r\ndevpriv->IDIPatMatchValue = 0x00;\r\nreturn 0;\r\n}\r\nstatic int pci_dio_reset(struct comedi_device *dev)\r\n{\r\nconst struct dio_boardtype *board = dev->board_ptr;\r\nswitch (board->cardtype) {\r\ncase TYPE_PCI1730:\r\noutb(0, dev->iobase + PCI1730_DO);\r\noutb(0, dev->iobase + PCI1730_DO + 1);\r\noutb(0, dev->iobase + PCI1730_IDO);\r\noutb(0, dev->iobase + PCI1730_IDO + 1);\r\ncase TYPE_PCI1733:\r\noutb(0, dev->iobase + PCI1730_3_INT_EN);\r\noutb(0x0f, dev->iobase + PCI1730_3_INT_CLR);\r\noutb(0, dev->iobase + PCI1730_3_INT_RF);\r\nbreak;\r\ncase TYPE_PCI1734:\r\noutb(0, dev->iobase + PCI1734_IDO);\r\noutb(0, dev->iobase + PCI1734_IDO + 1);\r\noutb(0, dev->iobase + PCI1734_IDO + 2);\r\noutb(0, dev->iobase + PCI1734_IDO + 3);\r\nbreak;\r\ncase TYPE_PCI1735:\r\noutb(0, dev->iobase + PCI1735_DO);\r\noutb(0, dev->iobase + PCI1735_DO + 1);\r\noutb(0, dev->iobase + PCI1735_DO + 2);\r\noutb(0, dev->iobase + PCI1735_DO + 3);\r\nbreak;\r\ncase TYPE_PCI1736:\r\noutb(0, dev->iobase + PCI1736_IDO);\r\noutb(0, dev->iobase + PCI1736_IDO + 1);\r\noutb(0, dev->iobase + PCI1736_3_INT_EN);\r\noutb(0x0f, dev->iobase + PCI1736_3_INT_CLR);\r\noutb(0, dev->iobase + PCI1736_3_INT_RF);\r\nbreak;\r\ncase TYPE_PCI1739:\r\noutb(0x88, dev->iobase + PCI1739_ICR);\r\nbreak;\r\ncase TYPE_PCI1750:\r\ncase TYPE_PCI1751:\r\noutb(0x88, dev->iobase + PCI1750_ICR);\r\nbreak;\r\ncase TYPE_PCI1752:\r\noutw(0, dev->iobase + PCI1752_6_CFC);\r\noutw(0, dev->iobase + PCI1752_IDO);\r\noutw(0, dev->iobase + PCI1752_IDO + 2);\r\noutw(0, dev->iobase + PCI1752_IDO2);\r\noutw(0, dev->iobase + PCI1752_IDO2 + 2);\r\nbreak;\r\ncase TYPE_PCI1753E:\r\noutb(0x88, dev->iobase + PCI1753E_ICR0);\r\noutb(0x80, dev->iobase + PCI1753E_ICR1);\r\noutb(0x80, dev->iobase + PCI1753E_ICR2);\r\noutb(0x80, dev->iobase + PCI1753E_ICR3);\r\ncase TYPE_PCI1753:\r\noutb(0x88, dev->iobase + PCI1753_ICR0);\r\noutb(0x80, dev->iobase + PCI1753_ICR1);\r\noutb(0x80, dev->iobase + PCI1753_ICR2);\r\noutb(0x80, dev->iobase + PCI1753_ICR3);\r\nbreak;\r\ncase TYPE_PCI1754:\r\noutw(0x08, dev->iobase + PCI1754_6_ICR0);\r\noutw(0x08, dev->iobase + PCI1754_6_ICR1);\r\noutw(0x08, dev->iobase + PCI1754_ICR2);\r\noutw(0x08, dev->iobase + PCI1754_ICR3);\r\nbreak;\r\ncase TYPE_PCI1756:\r\noutw(0, dev->iobase + PCI1752_6_CFC);\r\noutw(0x08, dev->iobase + PCI1754_6_ICR0);\r\noutw(0x08, dev->iobase + PCI1754_6_ICR1);\r\noutw(0, dev->iobase + PCI1756_IDO);\r\noutw(0, dev->iobase + PCI1756_IDO + 2);\r\nbreak;\r\ncase TYPE_PCI1760:\r\npci1760_reset(dev);\r\nbreak;\r\ncase TYPE_PCI1762:\r\noutw(0x0101, dev->iobase + PCI1762_ICR);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci1760_attach(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->len_chanlist = 8;\r\ns->range_table = &range_digital;\r\ns->insn_bits = pci1760_insn_bits_di;\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->len_chanlist = 8;\r\ns->range_table = &range_digital;\r\ns->state = 0;\r\ns->insn_bits = pci1760_insn_bits_do;\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_TIMER;\r\ns->subdev_flags = SDF_WRITABLE | SDF_LSAMPL;\r\ns->n_chan = 2;\r\ns->maxdata = 0xffffffff;\r\ns->len_chanlist = 2;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 0xffff;\r\ns->len_chanlist = 8;\r\ns->insn_read = pci1760_insn_cnt_read;\r\ns->insn_write = pci1760_insn_cnt_write;\r\nreturn 0;\r\n}\r\nstatic int pci_dio_add_di(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nconst struct diosubd_data *d)\r\n{\r\nconst struct dio_boardtype *board = dev->board_ptr;\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE | d->specflags;\r\nif (d->chans > 16)\r\ns->subdev_flags |= SDF_LSAMPL;\r\ns->n_chan = d->chans;\r\ns->maxdata = 1;\r\ns->len_chanlist = d->chans;\r\ns->range_table = &range_digital;\r\nswitch (board->io_access) {\r\ncase IO_8b:\r\ns->insn_bits = pci_dio_insn_bits_di_b;\r\nbreak;\r\ncase IO_16b:\r\ns->insn_bits = pci_dio_insn_bits_di_w;\r\nbreak;\r\n}\r\ns->private = (void *)d;\r\nreturn 0;\r\n}\r\nstatic int pci_dio_add_do(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nconst struct diosubd_data *d)\r\n{\r\nconst struct dio_boardtype *board = dev->board_ptr;\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\nif (d->chans > 16)\r\ns->subdev_flags |= SDF_LSAMPL;\r\ns->n_chan = d->chans;\r\ns->maxdata = 1;\r\ns->len_chanlist = d->chans;\r\ns->range_table = &range_digital;\r\ns->state = 0;\r\nswitch (board->io_access) {\r\ncase IO_8b:\r\ns->insn_bits = pci_dio_insn_bits_do_b;\r\nbreak;\r\ncase IO_16b:\r\ns->insn_bits = pci_dio_insn_bits_do_w;\r\nbreak;\r\n}\r\ns->private = (void *)d;\r\nreturn 0;\r\n}\r\nstatic unsigned long pci_dio_override_cardtype(struct pci_dev *pcidev,\r\nunsigned long cardtype)\r\n{\r\nif (cardtype != TYPE_PCI1753)\r\nreturn cardtype;\r\nif (pci_enable_device(pcidev) < 0)\r\nreturn cardtype;\r\nif (pci_request_region(pcidev, PCIDIO_MAINREG, "adv_pci_dio") == 0) {\r\nunsigned long reg =\r\npci_resource_start(pcidev, PCIDIO_MAINREG) + 53;\r\noutb(0x05, reg);\r\nif ((inb(reg) & 0x07) == 0x02) {\r\noutb(0x02, reg);\r\nif ((inb(reg) & 0x07) == 0x05)\r\ncardtype = TYPE_PCI1753E;\r\n}\r\npci_release_region(pcidev, PCIDIO_MAINREG);\r\n}\r\npci_disable_device(pcidev);\r\nreturn cardtype;\r\n}\r\nstatic int pci_dio_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nconst struct dio_boardtype *board = NULL;\r\nstruct pci_dio_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret, subdev, i, j;\r\nif (context < ARRAY_SIZE(boardtypes))\r\nboard = &boardtypes[context];\r\nif (!board)\r\nreturn -ENODEV;\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\ndev->iobase = pci_resource_start(pcidev, board->main_pci_region);\r\nret = comedi_alloc_subdevices(dev, board->nsubdevs);\r\nif (ret)\r\nreturn ret;\r\nsubdev = 0;\r\nfor (i = 0; i < MAX_DI_SUBDEVS; i++)\r\nif (board->sdi[i].chans) {\r\ns = &dev->subdevices[subdev];\r\npci_dio_add_di(dev, s, &board->sdi[i]);\r\nsubdev++;\r\n}\r\nfor (i = 0; i < MAX_DO_SUBDEVS; i++)\r\nif (board->sdo[i].chans) {\r\ns = &dev->subdevices[subdev];\r\npci_dio_add_do(dev, s, &board->sdo[i]);\r\nsubdev++;\r\n}\r\nfor (i = 0; i < MAX_DIO_SUBDEVG; i++)\r\nfor (j = 0; j < board->sdio[i].regs; j++) {\r\ns = &dev->subdevices[subdev];\r\nret = subdev_8255_init(dev, s, NULL,\r\nboard->sdio[i].addr +\r\nj * I8255_SIZE);\r\nif (ret)\r\nreturn ret;\r\nsubdev++;\r\n}\r\nif (board->boardid.chans) {\r\ns = &dev->subdevices[subdev];\r\ns->type = COMEDI_SUBD_DI;\r\npci_dio_add_di(dev, s, &board->boardid);\r\nsubdev++;\r\n}\r\nif (board->timer_regbase) {\r\ns = &dev->subdevices[subdev];\r\ndev->pacer = comedi_8254_init(dev->iobase +\r\nboard->timer_regbase,\r\n0, I8254_IO8, 0);\r\nif (!dev->pacer)\r\nreturn -ENOMEM;\r\ncomedi_8254_subdevice_init(s, dev->pacer);\r\nsubdev++;\r\n}\r\nif (board->cardtype == TYPE_PCI1760)\r\npci1760_attach(dev);\r\npci_dio_reset(dev);\r\nreturn 0;\r\n}\r\nstatic void pci_dio_detach(struct comedi_device *dev)\r\n{\r\nif (dev->iobase)\r\npci_dio_reset(dev);\r\ncomedi_pci_detach(dev);\r\n}\r\nstatic int adv_pci_dio_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nunsigned long cardtype;\r\ncardtype = pci_dio_override_cardtype(dev, id->driver_data);\r\nreturn comedi_pci_auto_config(dev, &adv_pci_dio_driver, cardtype);\r\n}
