static int __init omapdss_count_strings(const struct property *prop)\r\n{\r\nconst char *p = prop->value;\r\nint l = 0, total = 0;\r\nint i;\r\nfor (i = 0; total < prop->length; total += l, p += l, i++)\r\nl = strlen(p) + 1;\r\nreturn i;\r\n}\r\nstatic void __init omapdss_update_prop(struct device_node *node, char *compat,\r\nint len)\r\n{\r\nstruct property *prop;\r\nprop = kzalloc(sizeof(*prop), GFP_KERNEL);\r\nif (!prop)\r\nreturn;\r\nprop->name = "compatible";\r\nprop->value = compat;\r\nprop->length = len;\r\nof_update_property(node, prop);\r\n}\r\nstatic void __init omapdss_prefix_strcpy(char *dst, int dst_len,\r\nconst char *src, int src_len)\r\n{\r\nsize_t total = 0;\r\nwhile (total < src_len) {\r\nsize_t l = strlen(src) + 1;\r\nstrcpy(dst, prefix);\r\ndst += strlen(prefix);\r\nstrcpy(dst, src);\r\ndst += l;\r\nsrc += l;\r\ntotal += l;\r\n}\r\n}\r\nstatic void __init omapdss_omapify_node(struct device_node *node)\r\n{\r\nstruct property *prop;\r\nchar *new_compat;\r\nint num_strs;\r\nint new_len;\r\nprop = of_find_property(node, "compatible", NULL);\r\nif (!prop || !prop->value)\r\nreturn;\r\nif (strnlen(prop->value, prop->length) >= prop->length)\r\nreturn;\r\nif (strncmp(prefix, prop->value, strlen(prefix)) == 0)\r\nreturn;\r\nnum_strs = omapdss_count_strings(prop);\r\nnew_len = prop->length + strlen(prefix) * num_strs;\r\nnew_compat = kmalloc(new_len, GFP_KERNEL);\r\nomapdss_prefix_strcpy(new_compat, new_len, prop->value, prop->length);\r\nomapdss_update_prop(node, new_compat, new_len);\r\n}\r\nstatic void __init omapdss_add_to_list(struct device_node *node, bool root)\r\n{\r\nstruct dss_conv_node *n = kmalloc(sizeof(struct dss_conv_node),\r\nGFP_KERNEL);\r\nif (n) {\r\nn->node = node;\r\nn->root = root;\r\nlist_add(&n->list, &dss_conv_list);\r\n}\r\n}\r\nstatic bool __init omapdss_list_contains(const struct device_node *node)\r\n{\r\nstruct dss_conv_node *n;\r\nlist_for_each_entry(n, &dss_conv_list, list) {\r\nif (n->node == node)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void __init omapdss_walk_device(struct device_node *node, bool root)\r\n{\r\nstruct device_node *n;\r\nomapdss_add_to_list(node, root);\r\nn = of_get_child_by_name(node, "ports");\r\nif (!n)\r\nn = of_get_child_by_name(node, "port");\r\nif (!n)\r\nreturn;\r\nof_node_put(n);\r\nn = NULL;\r\nwhile ((n = of_graph_get_next_endpoint(node, n)) != NULL) {\r\nstruct device_node *pn;\r\npn = of_graph_get_remote_port_parent(n);\r\nif (!pn)\r\ncontinue;\r\nif (!of_device_is_available(pn) || omapdss_list_contains(pn)) {\r\nof_node_put(pn);\r\ncontinue;\r\n}\r\nomapdss_walk_device(pn, false);\r\n}\r\n}\r\nstatic int __init omapdss_boot_init(void)\r\n{\r\nstruct device_node *dss, *child;\r\nINIT_LIST_HEAD(&dss_conv_list);\r\ndss = of_find_matching_node(NULL, omapdss_of_match);\r\nif (dss == NULL || !of_device_is_available(dss))\r\nreturn 0;\r\nomapdss_walk_device(dss, true);\r\nfor_each_available_child_of_node(dss, child) {\r\nif (!of_find_property(child, "compatible", NULL)) {\r\nof_node_put(child);\r\ncontinue;\r\n}\r\nomapdss_walk_device(child, true);\r\n}\r\nwhile (!list_empty(&dss_conv_list)) {\r\nstruct dss_conv_node *n;\r\nn = list_first_entry(&dss_conv_list, struct dss_conv_node,\r\nlist);\r\nif (!n->root)\r\nomapdss_omapify_node(n->node);\r\nlist_del(&n->list);\r\nof_node_put(n->node);\r\nkfree(n);\r\n}\r\nreturn 0;\r\n}
