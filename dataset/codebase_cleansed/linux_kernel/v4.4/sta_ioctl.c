int mwifiex_copy_mcast_addr(struct mwifiex_multicast_list *mlist,\r\nstruct net_device *dev)\r\n{\r\nint i = 0;\r\nstruct netdev_hw_addr *ha;\r\nnetdev_for_each_mc_addr(ha, dev)\r\nmemcpy(&mlist->mac_list[i++], ha->addr, ETH_ALEN);\r\nreturn i;\r\n}\r\nint mwifiex_wait_queue_complete(struct mwifiex_adapter *adapter,\r\nstruct cmd_ctrl_node *cmd_queued)\r\n{\r\nint status;\r\nstatus = wait_event_interruptible_timeout(adapter->cmd_wait_q.wait,\r\n*(cmd_queued->condition),\r\n(12 * HZ));\r\nif (status <= 0) {\r\nif (status == 0)\r\nstatus = -ETIMEDOUT;\r\nmwifiex_dbg(adapter, ERROR, "cmd_wait_q terminated: %d\n",\r\nstatus);\r\nmwifiex_cancel_all_pending_cmd(adapter);\r\nreturn status;\r\n}\r\nstatus = adapter->cmd_wait_q.status;\r\nadapter->cmd_wait_q.status = 0;\r\nreturn status;\r\n}\r\nint mwifiex_request_set_multicast_list(struct mwifiex_private *priv,\r\nstruct mwifiex_multicast_list *mcast_list)\r\n{\r\nint ret = 0;\r\nu16 old_pkt_filter;\r\nold_pkt_filter = priv->curr_pkt_filter;\r\nif (mcast_list->mode == MWIFIEX_PROMISC_MODE) {\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: Enable Promiscuous mode\n");\r\npriv->curr_pkt_filter |= HostCmd_ACT_MAC_PROMISCUOUS_ENABLE;\r\npriv->curr_pkt_filter &=\r\n~HostCmd_ACT_MAC_ALL_MULTICAST_ENABLE;\r\n} else {\r\npriv->curr_pkt_filter &= ~HostCmd_ACT_MAC_PROMISCUOUS_ENABLE;\r\nif (mcast_list->mode == MWIFIEX_ALL_MULTI_MODE) {\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: Enabling All Multicast!\n");\r\npriv->curr_pkt_filter |=\r\nHostCmd_ACT_MAC_ALL_MULTICAST_ENABLE;\r\n} else {\r\npriv->curr_pkt_filter &=\r\n~HostCmd_ACT_MAC_ALL_MULTICAST_ENABLE;\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: Set multicast list=%d\n",\r\nmcast_list->num_multicast_addr);\r\nret = mwifiex_send_cmd(priv,\r\nHostCmd_CMD_MAC_MULTICAST_ADR,\r\nHostCmd_ACT_GEN_SET, 0,\r\nmcast_list, false);\r\n}\r\n}\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: old_pkt_filter=%#x, curr_pkt_filter=%#x\n",\r\nold_pkt_filter, priv->curr_pkt_filter);\r\nif (old_pkt_filter != priv->curr_pkt_filter) {\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\r\nHostCmd_ACT_GEN_SET,\r\n0, &priv->curr_pkt_filter, false);\r\n}\r\nreturn ret;\r\n}\r\nint mwifiex_fill_new_bss_desc(struct mwifiex_private *priv,\r\nstruct cfg80211_bss *bss,\r\nstruct mwifiex_bssdescriptor *bss_desc)\r\n{\r\nu8 *beacon_ie;\r\nsize_t beacon_ie_len;\r\nstruct mwifiex_bss_priv *bss_priv = (void *)bss->priv;\r\nconst struct cfg80211_bss_ies *ies;\r\nrcu_read_lock();\r\nies = rcu_dereference(bss->ies);\r\nbeacon_ie = kmemdup(ies->data, ies->len, GFP_ATOMIC);\r\nbeacon_ie_len = ies->len;\r\nbss_desc->timestamp = ies->tsf;\r\nrcu_read_unlock();\r\nif (!beacon_ie) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n" failed to alloc beacon_ie\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(bss_desc->mac_address, bss->bssid, ETH_ALEN);\r\nbss_desc->rssi = bss->signal;\r\nbss_desc->beacon_buf = beacon_ie;\r\nbss_desc->beacon_buf_size = beacon_ie_len;\r\nbss_desc->beacon_period = bss->beacon_interval;\r\nbss_desc->cap_info_bitmap = bss->capability;\r\nbss_desc->bss_band = bss_priv->band;\r\nbss_desc->fw_tsf = bss_priv->fw_tsf;\r\nif (bss_desc->cap_info_bitmap & WLAN_CAPABILITY_PRIVACY) {\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: InterpretIE: AP WEP enabled\n");\r\nbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;\r\n} else {\r\nbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;\r\n}\r\nif (bss_desc->cap_info_bitmap & WLAN_CAPABILITY_IBSS)\r\nbss_desc->bss_mode = NL80211_IFTYPE_ADHOC;\r\nelse\r\nbss_desc->bss_mode = NL80211_IFTYPE_STATION;\r\nbss_desc->disable_11ac = true;\r\nif (bss_desc->cap_info_bitmap & WLAN_CAPABILITY_SPECTRUM_MGMT)\r\nbss_desc->sensed_11h = true;\r\nreturn mwifiex_update_bss_desc_with_ie(priv->adapter, bss_desc);\r\n}\r\nvoid mwifiex_dnld_txpwr_table(struct mwifiex_private *priv)\r\n{\r\nif (priv->adapter->dt_node) {\r\nchar txpwr[] = {"marvell,00_txpwrlimit"};\r\nmemcpy(&txpwr[8], priv->adapter->country_code, 2);\r\nmwifiex_dnld_dt_cfgdata(priv, priv->adapter->dt_node, txpwr);\r\n}\r\n}\r\nstatic int mwifiex_process_country_ie(struct mwifiex_private *priv,\r\nstruct cfg80211_bss *bss)\r\n{\r\nconst u8 *country_ie;\r\nu8 country_ie_len;\r\nstruct mwifiex_802_11d_domain_reg *domain_info =\r\n&priv->adapter->domain_reg;\r\nrcu_read_lock();\r\ncountry_ie = ieee80211_bss_get_ie(bss, WLAN_EID_COUNTRY);\r\nif (!country_ie) {\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\ncountry_ie_len = country_ie[1];\r\nif (country_ie_len < IEEE80211_COUNTRY_IE_MIN_LEN) {\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nif (!strncmp(priv->adapter->country_code, &country_ie[2], 2)) {\r\nrcu_read_unlock();\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"11D: skip setting domain info in FW\n");\r\nreturn 0;\r\n}\r\nmemcpy(priv->adapter->country_code, &country_ie[2], 2);\r\ndomain_info->country_code[0] = country_ie[2];\r\ndomain_info->country_code[1] = country_ie[3];\r\ndomain_info->country_code[2] = ' ';\r\ncountry_ie_len -= IEEE80211_COUNTRY_STRING_LEN;\r\ndomain_info->no_of_triplet =\r\ncountry_ie_len / sizeof(struct ieee80211_country_ie_triplet);\r\nmemcpy((u8 *)domain_info->triplet,\r\n&country_ie[2] + IEEE80211_COUNTRY_STRING_LEN, country_ie_len);\r\nrcu_read_unlock();\r\nif (mwifiex_send_cmd(priv, HostCmd_CMD_802_11D_DOMAIN_INFO,\r\nHostCmd_ACT_GEN_SET, 0, NULL, false)) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"11D: setting domain info in FW fail\n");\r\nreturn -1;\r\n}\r\nmwifiex_dnld_txpwr_table(priv);\r\nreturn 0;\r\n}\r\nint mwifiex_bss_start(struct mwifiex_private *priv, struct cfg80211_bss *bss,\r\nstruct cfg80211_ssid *req_ssid)\r\n{\r\nint ret;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct mwifiex_bssdescriptor *bss_desc = NULL;\r\npriv->scan_block = false;\r\nif (bss) {\r\nmwifiex_process_country_ie(priv, bss);\r\nbss_desc = kzalloc(sizeof(struct mwifiex_bssdescriptor),\r\nGFP_KERNEL);\r\nif (!bss_desc)\r\nreturn -ENOMEM;\r\nret = mwifiex_fill_new_bss_desc(priv, bss, bss_desc);\r\nif (ret)\r\ngoto done;\r\n}\r\nif (priv->bss_mode == NL80211_IFTYPE_STATION ||\r\npriv->bss_mode == NL80211_IFTYPE_P2P_CLIENT) {\r\nu8 config_bands;\r\nif (!bss_desc)\r\nreturn -1;\r\nif (mwifiex_band_to_radio_type(bss_desc->bss_band) ==\r\nHostCmd_SCAN_RADIO_TYPE_BG) {\r\nconfig_bands = BAND_B | BAND_G | BAND_GN;\r\n} else {\r\nconfig_bands = BAND_A | BAND_AN;\r\nif (adapter->fw_bands & BAND_AAC)\r\nconfig_bands |= BAND_AAC;\r\n}\r\nif (!((config_bands | adapter->fw_bands) & ~adapter->fw_bands))\r\nadapter->config_bands = config_bands;\r\nret = mwifiex_check_network_compatibility(priv, bss_desc);\r\nif (ret)\r\ngoto done;\r\nif (mwifiex_11h_get_csa_closed_channel(priv) ==\r\n(u8)bss_desc->channel) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"Attempt to reconnect on csa closed chan(%d)\n",\r\nbss_desc->channel);\r\ngoto done;\r\n}\r\nmwifiex_dbg(adapter, INFO,\r\n"info: SSID found in scan list ...\t"\r\n"associating...\n");\r\nmwifiex_stop_net_dev_queue(priv->netdev, adapter);\r\nif (netif_carrier_ok(priv->netdev))\r\nnetif_carrier_off(priv->netdev);\r\npriv->assoc_rsp_size = 0;\r\nret = mwifiex_associate(priv, bss_desc);\r\nif (ret == WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG &&\r\npriv->sec_info.is_authtype_auto &&\r\npriv->sec_info.wep_enabled) {\r\npriv->sec_info.authentication_mode =\r\nNL80211_AUTHTYPE_SHARED_KEY;\r\nret = mwifiex_associate(priv, bss_desc);\r\n}\r\nif (bss)\r\ncfg80211_put_bss(priv->adapter->wiphy, bss);\r\n} else {\r\nif (bss_desc && bss_desc->ssid.ssid_len &&\r\n(!mwifiex_ssid_cmp(&priv->curr_bss_params.bss_descriptor.\r\nssid, &bss_desc->ssid))) {\r\nret = 0;\r\ngoto done;\r\n}\r\npriv->adhoc_is_link_sensed = false;\r\nret = mwifiex_check_network_compatibility(priv, bss_desc);\r\nmwifiex_stop_net_dev_queue(priv->netdev, adapter);\r\nif (netif_carrier_ok(priv->netdev))\r\nnetif_carrier_off(priv->netdev);\r\nif (!ret) {\r\nmwifiex_dbg(adapter, INFO,\r\n"info: network found in scan\t"\r\n" list. Joining...\n");\r\nret = mwifiex_adhoc_join(priv, bss_desc);\r\nif (bss)\r\ncfg80211_put_bss(priv->adapter->wiphy, bss);\r\n} else {\r\nmwifiex_dbg(adapter, INFO,\r\n"info: Network not found in\t"\r\n"the list, creating adhoc with ssid = %s\n",\r\nreq_ssid->ssid);\r\nret = mwifiex_adhoc_start(priv, req_ssid);\r\n}\r\n}\r\ndone:\r\nif (bss_desc)\r\nkfree(bss_desc->beacon_buf);\r\nkfree(bss_desc);\r\nreturn ret;\r\n}\r\nint mwifiex_set_hs_params(struct mwifiex_private *priv, u16 action,\r\nint cmd_type, struct mwifiex_ds_hs_cfg *hs_cfg)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nint status = 0;\r\nu32 prev_cond = 0;\r\nif (!hs_cfg)\r\nreturn -ENOMEM;\r\nswitch (action) {\r\ncase HostCmd_ACT_GEN_SET:\r\nif (adapter->pps_uapsd_mode) {\r\nmwifiex_dbg(adapter, INFO,\r\n"info: Host Sleep IOCTL\t"\r\n"is blocked in UAPSD/PPS mode\n");\r\nstatus = -1;\r\nbreak;\r\n}\r\nif (hs_cfg->is_invoke_hostcmd) {\r\nif (hs_cfg->conditions == HS_CFG_CANCEL) {\r\nif (!adapter->is_hs_configured)\r\nbreak;\r\nprev_cond = le32_to_cpu(adapter->hs_cfg\r\n.conditions);\r\nadapter->hs_cfg.conditions =\r\ncpu_to_le32(hs_cfg->conditions);\r\n} else if (hs_cfg->conditions) {\r\nadapter->hs_cfg.conditions =\r\ncpu_to_le32(hs_cfg->conditions);\r\nadapter->hs_cfg.gpio = (u8)hs_cfg->gpio;\r\nif (hs_cfg->gap)\r\nadapter->hs_cfg.gap = (u8)hs_cfg->gap;\r\n} else if (adapter->hs_cfg.conditions ==\r\ncpu_to_le32(HS_CFG_CANCEL)) {\r\nstatus = -1;\r\nbreak;\r\n}\r\nstatus = mwifiex_send_cmd(priv,\r\nHostCmd_CMD_802_11_HS_CFG_ENH,\r\nHostCmd_ACT_GEN_SET, 0,\r\n&adapter->hs_cfg,\r\ncmd_type == MWIFIEX_SYNC_CMD);\r\nif (hs_cfg->conditions == HS_CFG_CANCEL)\r\nadapter->hs_cfg.conditions =\r\ncpu_to_le32(prev_cond);\r\n} else {\r\nadapter->hs_cfg.conditions =\r\ncpu_to_le32(hs_cfg->conditions);\r\nadapter->hs_cfg.gpio = (u8)hs_cfg->gpio;\r\nadapter->hs_cfg.gap = (u8)hs_cfg->gap;\r\n}\r\nbreak;\r\ncase HostCmd_ACT_GEN_GET:\r\nhs_cfg->conditions = le32_to_cpu(adapter->hs_cfg.conditions);\r\nhs_cfg->gpio = adapter->hs_cfg.gpio;\r\nhs_cfg->gap = adapter->hs_cfg.gap;\r\nbreak;\r\ndefault:\r\nstatus = -1;\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nint mwifiex_cancel_hs(struct mwifiex_private *priv, int cmd_type)\r\n{\r\nstruct mwifiex_ds_hs_cfg hscfg;\r\nhscfg.conditions = HS_CFG_CANCEL;\r\nhscfg.is_invoke_hostcmd = true;\r\nreturn mwifiex_set_hs_params(priv, HostCmd_ACT_GEN_SET,\r\ncmd_type, &hscfg);\r\n}\r\nint mwifiex_enable_hs(struct mwifiex_adapter *adapter)\r\n{\r\nstruct mwifiex_ds_hs_cfg hscfg;\r\nstruct mwifiex_private *priv;\r\nint i;\r\nif (disconnect_on_suspend) {\r\nfor (i = 0; i < adapter->priv_num; i++) {\r\npriv = adapter->priv[i];\r\nif (priv)\r\nmwifiex_deauthenticate(priv, NULL);\r\n}\r\n}\r\nif (adapter->hs_activated) {\r\nmwifiex_dbg(adapter, CMD,\r\n"cmd: HS Already activated\n");\r\nreturn true;\r\n}\r\nadapter->hs_activate_wait_q_woken = false;\r\nmemset(&hscfg, 0, sizeof(struct mwifiex_ds_hs_cfg));\r\nhscfg.is_invoke_hostcmd = true;\r\nadapter->hs_enabling = true;\r\nmwifiex_cancel_all_pending_cmd(adapter);\r\nif (mwifiex_set_hs_params(mwifiex_get_priv(adapter,\r\nMWIFIEX_BSS_ROLE_STA),\r\nHostCmd_ACT_GEN_SET, MWIFIEX_SYNC_CMD,\r\n&hscfg)) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"IOCTL request HS enable failed\n");\r\nreturn false;\r\n}\r\nif (wait_event_interruptible_timeout(adapter->hs_activate_wait_q,\r\nadapter->hs_activate_wait_q_woken,\r\n(10 * HZ)) <= 0) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"hs_activate_wait_q terminated\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nint mwifiex_get_bss_info(struct mwifiex_private *priv,\r\nstruct mwifiex_bss_info *info)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct mwifiex_bssdescriptor *bss_desc;\r\nif (!info)\r\nreturn -1;\r\nbss_desc = &priv->curr_bss_params.bss_descriptor;\r\ninfo->bss_mode = priv->bss_mode;\r\nmemcpy(&info->ssid, &bss_desc->ssid, sizeof(struct cfg80211_ssid));\r\nmemcpy(&info->bssid, &bss_desc->mac_address, ETH_ALEN);\r\ninfo->bss_chan = bss_desc->channel;\r\nmemcpy(info->country_code, adapter->country_code,\r\nIEEE80211_COUNTRY_STRING_LEN);\r\ninfo->media_connected = priv->media_connected;\r\ninfo->max_power_level = priv->max_tx_power_level;\r\ninfo->min_power_level = priv->min_tx_power_level;\r\ninfo->adhoc_state = priv->adhoc_state;\r\ninfo->bcn_nf_last = priv->bcn_nf_last;\r\nif (priv->sec_info.wep_enabled)\r\ninfo->wep_status = true;\r\nelse\r\ninfo->wep_status = false;\r\ninfo->is_hs_configured = adapter->is_hs_configured;\r\ninfo->is_deep_sleep = adapter->is_deep_sleep;\r\nreturn 0;\r\n}\r\nint mwifiex_disable_auto_ds(struct mwifiex_private *priv)\r\n{\r\nstruct mwifiex_ds_auto_ds auto_ds;\r\nauto_ds.auto_ds = DEEP_SLEEP_OFF;\r\nreturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_PS_MODE_ENH,\r\nDIS_AUTO_PS, BITMAP_AUTO_DS, &auto_ds, true);\r\n}\r\nint mwifiex_drv_get_data_rate(struct mwifiex_private *priv, u32 *rate)\r\n{\r\nint ret;\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_TX_RATE_QUERY,\r\nHostCmd_ACT_GEN_GET, 0, NULL, true);\r\nif (!ret) {\r\nif (priv->is_data_rate_auto)\r\n*rate = mwifiex_index_to_data_rate(priv, priv->tx_rate,\r\npriv->tx_htinfo);\r\nelse\r\n*rate = priv->data_rate;\r\n}\r\nreturn ret;\r\n}\r\nint mwifiex_set_tx_power(struct mwifiex_private *priv,\r\nstruct mwifiex_power_cfg *power_cfg)\r\n{\r\nint ret;\r\nstruct host_cmd_ds_txpwr_cfg *txp_cfg;\r\nstruct mwifiex_types_power_group *pg_tlv;\r\nstruct mwifiex_power_group *pg;\r\nu8 *buf;\r\nu16 dbm = 0;\r\nif (!power_cfg->is_power_auto) {\r\ndbm = (u16) power_cfg->power_level;\r\nif ((dbm < priv->min_tx_power_level) ||\r\n(dbm > priv->max_tx_power_level)) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"txpower value %d dBm\t"\r\n"is out of range (%d dBm-%d dBm)\n",\r\ndbm, priv->min_tx_power_level,\r\npriv->max_tx_power_level);\r\nreturn -1;\r\n}\r\n}\r\nbuf = kzalloc(MWIFIEX_SIZE_OF_CMD_BUFFER, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\ntxp_cfg = (struct host_cmd_ds_txpwr_cfg *) buf;\r\ntxp_cfg->action = cpu_to_le16(HostCmd_ACT_GEN_SET);\r\nif (!power_cfg->is_power_auto) {\r\ntxp_cfg->mode = cpu_to_le32(1);\r\npg_tlv = (struct mwifiex_types_power_group *)\r\n(buf + sizeof(struct host_cmd_ds_txpwr_cfg));\r\npg_tlv->type = cpu_to_le16(TLV_TYPE_POWER_GROUP);\r\npg_tlv->length =\r\ncpu_to_le16(4 * sizeof(struct mwifiex_power_group));\r\npg = (struct mwifiex_power_group *)\r\n(buf + sizeof(struct host_cmd_ds_txpwr_cfg)\r\n+ sizeof(struct mwifiex_types_power_group));\r\npg->first_rate_code = 0x00;\r\npg->last_rate_code = 0x03;\r\npg->modulation_class = MOD_CLASS_HR_DSSS;\r\npg->power_step = 0;\r\npg->power_min = (s8) dbm;\r\npg->power_max = (s8) dbm;\r\npg++;\r\npg->first_rate_code = 0x00;\r\npg->last_rate_code = 0x07;\r\npg->modulation_class = MOD_CLASS_OFDM;\r\npg->power_step = 0;\r\npg->power_min = (s8) dbm;\r\npg->power_max = (s8) dbm;\r\npg++;\r\npg->first_rate_code = 0x00;\r\npg->last_rate_code = 0x20;\r\npg->modulation_class = MOD_CLASS_HT;\r\npg->power_step = 0;\r\npg->power_min = (s8) dbm;\r\npg->power_max = (s8) dbm;\r\npg->ht_bandwidth = HT_BW_20;\r\npg++;\r\npg->first_rate_code = 0x00;\r\npg->last_rate_code = 0x20;\r\npg->modulation_class = MOD_CLASS_HT;\r\npg->power_step = 0;\r\npg->power_min = (s8) dbm;\r\npg->power_max = (s8) dbm;\r\npg->ht_bandwidth = HT_BW_40;\r\n}\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_TXPWR_CFG,\r\nHostCmd_ACT_GEN_SET, 0, buf, true);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nint mwifiex_drv_set_power(struct mwifiex_private *priv, u32 *ps_mode)\r\n{\r\nint ret;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nu16 sub_cmd;\r\nif (*ps_mode)\r\nadapter->ps_mode = MWIFIEX_802_11_POWER_MODE_PSP;\r\nelse\r\nadapter->ps_mode = MWIFIEX_802_11_POWER_MODE_CAM;\r\nsub_cmd = (*ps_mode) ? EN_AUTO_PS : DIS_AUTO_PS;\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_PS_MODE_ENH,\r\nsub_cmd, BITMAP_STA_PS, NULL, true);\r\nif ((!ret) && (sub_cmd == DIS_AUTO_PS))\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_PS_MODE_ENH,\r\nGET_PS, 0, NULL, false);\r\nreturn ret;\r\n}\r\nstatic int mwifiex_set_wpa_ie_helper(struct mwifiex_private *priv,\r\nu8 *ie_data_ptr, u16 ie_len)\r\n{\r\nif (ie_len) {\r\nif (ie_len > sizeof(priv->wpa_ie)) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"failed to copy WPA IE, too big\n");\r\nreturn -1;\r\n}\r\nmemcpy(priv->wpa_ie, ie_data_ptr, ie_len);\r\npriv->wpa_ie_len = (u8) ie_len;\r\nmwifiex_dbg(priv->adapter, CMD,\r\n"cmd: Set Wpa_ie_len=%d IE=%#x\n",\r\npriv->wpa_ie_len, priv->wpa_ie[0]);\r\nif (priv->wpa_ie[0] == WLAN_EID_VENDOR_SPECIFIC) {\r\npriv->sec_info.wpa_enabled = true;\r\n} else if (priv->wpa_ie[0] == WLAN_EID_RSN) {\r\npriv->sec_info.wpa2_enabled = true;\r\n} else {\r\npriv->sec_info.wpa_enabled = false;\r\npriv->sec_info.wpa2_enabled = false;\r\n}\r\n} else {\r\nmemset(priv->wpa_ie, 0, sizeof(priv->wpa_ie));\r\npriv->wpa_ie_len = 0;\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: reset wpa_ie_len=%d IE=%#x\n",\r\npriv->wpa_ie_len, priv->wpa_ie[0]);\r\npriv->sec_info.wpa_enabled = false;\r\npriv->sec_info.wpa2_enabled = false;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mwifiex_set_wapi_ie(struct mwifiex_private *priv,\r\nu8 *ie_data_ptr, u16 ie_len)\r\n{\r\nif (ie_len) {\r\nif (ie_len > sizeof(priv->wapi_ie)) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"info: failed to copy WAPI IE, too big\n");\r\nreturn -1;\r\n}\r\nmemcpy(priv->wapi_ie, ie_data_ptr, ie_len);\r\npriv->wapi_ie_len = ie_len;\r\nmwifiex_dbg(priv->adapter, CMD,\r\n"cmd: Set wapi_ie_len=%d IE=%#x\n",\r\npriv->wapi_ie_len, priv->wapi_ie[0]);\r\nif (priv->wapi_ie[0] == WLAN_EID_BSS_AC_ACCESS_DELAY)\r\npriv->sec_info.wapi_enabled = true;\r\n} else {\r\nmemset(priv->wapi_ie, 0, sizeof(priv->wapi_ie));\r\npriv->wapi_ie_len = ie_len;\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: Reset wapi_ie_len=%d IE=%#x\n",\r\npriv->wapi_ie_len, priv->wapi_ie[0]);\r\npriv->sec_info.wapi_enabled = false;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mwifiex_set_wps_ie(struct mwifiex_private *priv,\r\nu8 *ie_data_ptr, u16 ie_len)\r\n{\r\nif (ie_len) {\r\nif (ie_len > MWIFIEX_MAX_VSIE_LEN) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"info: failed to copy WPS IE, too big\n");\r\nreturn -1;\r\n}\r\npriv->wps_ie = kzalloc(MWIFIEX_MAX_VSIE_LEN, GFP_KERNEL);\r\nif (!priv->wps_ie)\r\nreturn -ENOMEM;\r\nmemcpy(priv->wps_ie, ie_data_ptr, ie_len);\r\npriv->wps_ie_len = ie_len;\r\nmwifiex_dbg(priv->adapter, CMD,\r\n"cmd: Set wps_ie_len=%d IE=%#x\n",\r\npriv->wps_ie_len, priv->wps_ie[0]);\r\n} else {\r\nkfree(priv->wps_ie);\r\npriv->wps_ie_len = ie_len;\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: Reset wps_ie_len=%d\n", priv->wps_ie_len);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mwifiex_sec_ioctl_set_wapi_key(struct mwifiex_private *priv,\r\nstruct mwifiex_ds_encrypt_key *encrypt_key)\r\n{\r\nreturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\r\nHostCmd_ACT_GEN_SET, KEY_INFO_ENABLED,\r\nencrypt_key, true);\r\n}\r\nstatic int mwifiex_sec_ioctl_set_wep_key(struct mwifiex_private *priv,\r\nstruct mwifiex_ds_encrypt_key *encrypt_key)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nint ret;\r\nstruct mwifiex_wep_key *wep_key;\r\nint index;\r\nif (priv->wep_key_curr_index >= NUM_WEP_KEYS)\r\npriv->wep_key_curr_index = 0;\r\nwep_key = &priv->wep_key[priv->wep_key_curr_index];\r\nindex = encrypt_key->key_index;\r\nif (encrypt_key->key_disable) {\r\npriv->sec_info.wep_enabled = 0;\r\n} else if (!encrypt_key->key_len) {\r\nwep_key = &priv->wep_key[index];\r\nif (!wep_key->key_length) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"key not set, so cannot enable it\n");\r\nreturn -1;\r\n}\r\nif (adapter->key_api_major_ver == KEY_API_VER_MAJOR_V2) {\r\nmemcpy(encrypt_key->key_material,\r\nwep_key->key_material, wep_key->key_length);\r\nencrypt_key->key_len = wep_key->key_length;\r\n}\r\npriv->wep_key_curr_index = (u16) index;\r\npriv->sec_info.wep_enabled = 1;\r\n} else {\r\nwep_key = &priv->wep_key[index];\r\nmemset(wep_key, 0, sizeof(struct mwifiex_wep_key));\r\nmemcpy(wep_key->key_material,\r\nencrypt_key->key_material,\r\nencrypt_key->key_len);\r\nwep_key->key_index = index;\r\nwep_key->key_length = encrypt_key->key_len;\r\npriv->sec_info.wep_enabled = 1;\r\n}\r\nif (wep_key->key_length) {\r\nvoid *enc_key;\r\nif (encrypt_key->key_disable) {\r\nmemset(&priv->wep_key[index], 0,\r\nsizeof(struct mwifiex_wep_key));\r\nif (wep_key->key_length)\r\ngoto done;\r\n}\r\nif (adapter->key_api_major_ver == KEY_API_VER_MAJOR_V2)\r\nenc_key = encrypt_key;\r\nelse\r\nenc_key = NULL;\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\r\nHostCmd_ACT_GEN_SET, 0, enc_key, false);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndone:\r\nif (priv->sec_info.wep_enabled)\r\npriv->curr_pkt_filter |= HostCmd_ACT_MAC_WEP_ENABLE;\r\nelse\r\npriv->curr_pkt_filter &= ~HostCmd_ACT_MAC_WEP_ENABLE;\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\r\nHostCmd_ACT_GEN_SET, 0,\r\n&priv->curr_pkt_filter, true);\r\nreturn ret;\r\n}\r\nstatic int mwifiex_sec_ioctl_set_wpa_key(struct mwifiex_private *priv,\r\nstruct mwifiex_ds_encrypt_key *encrypt_key)\r\n{\r\nint ret;\r\nu8 remove_key = false;\r\nstruct host_cmd_ds_802_11_key_material *ibss_key;\r\nif (encrypt_key->key_len > WLAN_MAX_KEY_LEN) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"key length too long\n");\r\nreturn -1;\r\n}\r\nif (priv->bss_mode == NL80211_IFTYPE_ADHOC) {\r\nencrypt_key->key_index = MWIFIEX_KEY_INDEX_UNICAST;\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\r\nHostCmd_ACT_GEN_SET,\r\nKEY_INFO_ENABLED, encrypt_key, false);\r\nif (ret)\r\nreturn ret;\r\nibss_key = &priv->aes_key;\r\nmemset(ibss_key, 0,\r\nsizeof(struct host_cmd_ds_802_11_key_material));\r\nmemcpy(ibss_key->key_param_set.key, encrypt_key->key_material,\r\nencrypt_key->key_len);\r\nmemcpy(&ibss_key->key_param_set.key_len, &encrypt_key->key_len,\r\nsizeof(ibss_key->key_param_set.key_len));\r\nibss_key->key_param_set.key_type_id\r\n= cpu_to_le16(KEY_TYPE_ID_TKIP);\r\nibss_key->key_param_set.key_info = cpu_to_le16(KEY_ENABLED);\r\nencrypt_key->key_index = ~MWIFIEX_KEY_INDEX_UNICAST;\r\n}\r\nif (!encrypt_key->key_index)\r\nencrypt_key->key_index = MWIFIEX_KEY_INDEX_UNICAST;\r\nif (remove_key)\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\r\nHostCmd_ACT_GEN_SET,\r\n!KEY_INFO_ENABLED, encrypt_key, true);\r\nelse\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\r\nHostCmd_ACT_GEN_SET,\r\nKEY_INFO_ENABLED, encrypt_key, true);\r\nreturn ret;\r\n}\r\nstatic int\r\nmwifiex_sec_ioctl_encrypt_key(struct mwifiex_private *priv,\r\nstruct mwifiex_ds_encrypt_key *encrypt_key)\r\n{\r\nint status;\r\nif (encrypt_key->is_wapi_key)\r\nstatus = mwifiex_sec_ioctl_set_wapi_key(priv, encrypt_key);\r\nelse if (encrypt_key->key_len > WLAN_KEY_LEN_WEP104)\r\nstatus = mwifiex_sec_ioctl_set_wpa_key(priv, encrypt_key);\r\nelse\r\nstatus = mwifiex_sec_ioctl_set_wep_key(priv, encrypt_key);\r\nreturn status;\r\n}\r\nint\r\nmwifiex_drv_get_driver_version(struct mwifiex_adapter *adapter, char *version,\r\nint max_len)\r\n{\r\nunion {\r\n__le32 l;\r\nu8 c[4];\r\n} ver;\r\nchar fw_ver[32];\r\nver.l = cpu_to_le32(adapter->fw_release_number);\r\nsprintf(fw_ver, "%u.%u.%u.p%u", ver.c[2], ver.c[1], ver.c[0], ver.c[3]);\r\nsnprintf(version, max_len, driver_version, fw_ver);\r\nmwifiex_dbg(adapter, MSG, "info: MWIFIEX VERSION: %s\n", version);\r\nreturn 0;\r\n}\r\nint mwifiex_set_encode(struct mwifiex_private *priv, struct key_params *kp,\r\nconst u8 *key, int key_len, u8 key_index,\r\nconst u8 *mac_addr, int disable)\r\n{\r\nstruct mwifiex_ds_encrypt_key encrypt_key;\r\nmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\r\nencrypt_key.key_len = key_len;\r\nencrypt_key.key_index = key_index;\r\nif (kp && kp->cipher == WLAN_CIPHER_SUITE_AES_CMAC)\r\nencrypt_key.is_igtk_key = true;\r\nif (!disable) {\r\nif (key_len)\r\nmemcpy(encrypt_key.key_material, key, key_len);\r\nelse\r\nencrypt_key.is_current_wep_key = true;\r\nif (mac_addr)\r\nmemcpy(encrypt_key.mac_addr, mac_addr, ETH_ALEN);\r\nif (kp && kp->seq && kp->seq_len) {\r\nmemcpy(encrypt_key.pn, kp->seq, kp->seq_len);\r\nencrypt_key.pn_len = kp->seq_len;\r\nencrypt_key.is_rx_seq_valid = true;\r\n}\r\n} else {\r\nif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP)\r\nreturn 0;\r\nencrypt_key.key_disable = true;\r\nif (mac_addr)\r\nmemcpy(encrypt_key.mac_addr, mac_addr, ETH_ALEN);\r\n}\r\nreturn mwifiex_sec_ioctl_encrypt_key(priv, &encrypt_key);\r\n}\r\nint\r\nmwifiex_get_ver_ext(struct mwifiex_private *priv)\r\n{\r\nstruct mwifiex_ver_ext ver_ext;\r\nmemset(&ver_ext, 0, sizeof(struct host_cmd_ds_version_ext));\r\nif (mwifiex_send_cmd(priv, HostCmd_CMD_VERSION_EXT,\r\nHostCmd_ACT_GEN_GET, 0, &ver_ext, true))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint\r\nmwifiex_remain_on_chan_cfg(struct mwifiex_private *priv, u16 action,\r\nstruct ieee80211_channel *chan,\r\nunsigned int duration)\r\n{\r\nstruct host_cmd_ds_remain_on_chan roc_cfg;\r\nu8 sc;\r\nmemset(&roc_cfg, 0, sizeof(roc_cfg));\r\nroc_cfg.action = cpu_to_le16(action);\r\nif (action == HostCmd_ACT_GEN_SET) {\r\nroc_cfg.band_cfg = chan->band;\r\nsc = mwifiex_chan_type_to_sec_chan_offset(NL80211_CHAN_NO_HT);\r\nroc_cfg.band_cfg |= (sc << 2);\r\nroc_cfg.channel =\r\nieee80211_frequency_to_channel(chan->center_freq);\r\nroc_cfg.duration = cpu_to_le32(duration);\r\n}\r\nif (mwifiex_send_cmd(priv, HostCmd_CMD_REMAIN_ON_CHAN,\r\naction, 0, &roc_cfg, true)) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"failed to remain on channel\n");\r\nreturn -1;\r\n}\r\nreturn roc_cfg.status;\r\n}\r\nint\r\nmwifiex_get_stats_info(struct mwifiex_private *priv,\r\nstruct mwifiex_ds_get_stats *log)\r\n{\r\nreturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_GET_LOG,\r\nHostCmd_ACT_GEN_GET, 0, log, true);\r\n}\r\nstatic int mwifiex_reg_mem_ioctl_reg_rw(struct mwifiex_private *priv,\r\nstruct mwifiex_ds_reg_rw *reg_rw,\r\nu16 action)\r\n{\r\nu16 cmd_no;\r\nswitch (le32_to_cpu(reg_rw->type)) {\r\ncase MWIFIEX_REG_MAC:\r\ncmd_no = HostCmd_CMD_MAC_REG_ACCESS;\r\nbreak;\r\ncase MWIFIEX_REG_BBP:\r\ncmd_no = HostCmd_CMD_BBP_REG_ACCESS;\r\nbreak;\r\ncase MWIFIEX_REG_RF:\r\ncmd_no = HostCmd_CMD_RF_REG_ACCESS;\r\nbreak;\r\ncase MWIFIEX_REG_PMIC:\r\ncmd_no = HostCmd_CMD_PMIC_REG_ACCESS;\r\nbreak;\r\ncase MWIFIEX_REG_CAU:\r\ncmd_no = HostCmd_CMD_CAU_REG_ACCESS;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn mwifiex_send_cmd(priv, cmd_no, action, 0, reg_rw, true);\r\n}\r\nint\r\nmwifiex_reg_write(struct mwifiex_private *priv, u32 reg_type,\r\nu32 reg_offset, u32 reg_value)\r\n{\r\nstruct mwifiex_ds_reg_rw reg_rw;\r\nreg_rw.type = cpu_to_le32(reg_type);\r\nreg_rw.offset = cpu_to_le32(reg_offset);\r\nreg_rw.value = cpu_to_le32(reg_value);\r\nreturn mwifiex_reg_mem_ioctl_reg_rw(priv, &reg_rw, HostCmd_ACT_GEN_SET);\r\n}\r\nint\r\nmwifiex_reg_read(struct mwifiex_private *priv, u32 reg_type,\r\nu32 reg_offset, u32 *value)\r\n{\r\nint ret;\r\nstruct mwifiex_ds_reg_rw reg_rw;\r\nreg_rw.type = cpu_to_le32(reg_type);\r\nreg_rw.offset = cpu_to_le32(reg_offset);\r\nret = mwifiex_reg_mem_ioctl_reg_rw(priv, &reg_rw, HostCmd_ACT_GEN_GET);\r\nif (ret)\r\ngoto done;\r\n*value = le32_to_cpu(reg_rw.value);\r\ndone:\r\nreturn ret;\r\n}\r\nint\r\nmwifiex_eeprom_read(struct mwifiex_private *priv, u16 offset, u16 bytes,\r\nu8 *value)\r\n{\r\nint ret;\r\nstruct mwifiex_ds_read_eeprom rd_eeprom;\r\nrd_eeprom.offset = cpu_to_le16((u16) offset);\r\nrd_eeprom.byte_count = cpu_to_le16((u16) bytes);\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_EEPROM_ACCESS,\r\nHostCmd_ACT_GEN_GET, 0, &rd_eeprom, true);\r\nif (!ret)\r\nmemcpy(value, rd_eeprom.value, MAX_EEPROM_DATA);\r\nreturn ret;\r\n}\r\nstatic int\r\nmwifiex_set_gen_ie_helper(struct mwifiex_private *priv, u8 *ie_data_ptr,\r\nu16 ie_len)\r\n{\r\nint ret = 0;\r\nstruct ieee_types_vendor_header *pvendor_ie;\r\nconst u8 wpa_oui[] = { 0x00, 0x50, 0xf2, 0x01 };\r\nconst u8 wps_oui[] = { 0x00, 0x50, 0xf2, 0x04 };\r\nif (!ie_len) {\r\npriv->gen_ie_buf_len = 0;\r\npriv->wps.session_enable = false;\r\nreturn 0;\r\n} else if (!ie_data_ptr) {\r\nreturn -1;\r\n}\r\npvendor_ie = (struct ieee_types_vendor_header *) ie_data_ptr;\r\nif (((pvendor_ie->element_id == WLAN_EID_VENDOR_SPECIFIC) &&\r\n(!memcmp(pvendor_ie->oui, wpa_oui, sizeof(wpa_oui)))) ||\r\n(pvendor_ie->element_id == WLAN_EID_RSN)) {\r\nret = mwifiex_set_wpa_ie_helper(priv, ie_data_ptr, ie_len);\r\npriv->wps.session_enable = false;\r\nreturn ret;\r\n} else if (pvendor_ie->element_id == WLAN_EID_BSS_AC_ACCESS_DELAY) {\r\nret = mwifiex_set_wapi_ie(priv, ie_data_ptr, ie_len);\r\nreturn ret;\r\n}\r\nif (ie_len < (sizeof(priv->gen_ie_buf) - priv->gen_ie_buf_len)) {\r\npvendor_ie = (struct ieee_types_vendor_header *) ie_data_ptr;\r\nif ((pvendor_ie->element_id == WLAN_EID_VENDOR_SPECIFIC) &&\r\n(!memcmp(pvendor_ie->oui, wps_oui, sizeof(wps_oui)))) {\r\npriv->wps.session_enable = true;\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: WPS Session Enabled.\n");\r\nret = mwifiex_set_wps_ie(priv, ie_data_ptr, ie_len);\r\n}\r\nmemcpy(priv->gen_ie_buf + priv->gen_ie_buf_len, ie_data_ptr,\r\nie_len);\r\npriv->gen_ie_buf_len += ie_len;\r\n} else {\r\nret = -1;\r\n}\r\nreturn ret;\r\n}\r\nstatic int mwifiex_misc_ioctl_gen_ie(struct mwifiex_private *priv,\r\nstruct mwifiex_ds_misc_gen_ie *gen_ie,\r\nu16 action)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nswitch (gen_ie->type) {\r\ncase MWIFIEX_IE_TYPE_GEN_IE:\r\nif (action == HostCmd_ACT_GEN_GET) {\r\ngen_ie->len = priv->wpa_ie_len;\r\nmemcpy(gen_ie->ie_data, priv->wpa_ie, gen_ie->len);\r\n} else {\r\nmwifiex_set_gen_ie_helper(priv, gen_ie->ie_data,\r\n(u16) gen_ie->len);\r\n}\r\nbreak;\r\ncase MWIFIEX_IE_TYPE_ARP_FILTER:\r\nmemset(adapter->arp_filter, 0, sizeof(adapter->arp_filter));\r\nif (gen_ie->len > ARP_FILTER_MAX_BUF_SIZE) {\r\nadapter->arp_filter_size = 0;\r\nmwifiex_dbg(adapter, ERROR,\r\n"invalid ARP filter size\n");\r\nreturn -1;\r\n} else {\r\nmemcpy(adapter->arp_filter, gen_ie->ie_data,\r\ngen_ie->len);\r\nadapter->arp_filter_size = gen_ie->len;\r\n}\r\nbreak;\r\ndefault:\r\nmwifiex_dbg(adapter, ERROR, "invalid IE type\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nmwifiex_set_gen_ie(struct mwifiex_private *priv, const u8 *ie, int ie_len)\r\n{\r\nstruct mwifiex_ds_misc_gen_ie gen_ie;\r\nif (ie_len > IEEE_MAX_IE_SIZE)\r\nreturn -EFAULT;\r\ngen_ie.type = MWIFIEX_IE_TYPE_GEN_IE;\r\ngen_ie.len = ie_len;\r\nmemcpy(gen_ie.ie_data, ie, ie_len);\r\nif (mwifiex_misc_ioctl_gen_ie(priv, &gen_ie, HostCmd_ACT_GEN_SET))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}
