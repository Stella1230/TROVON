static inline struct crypto_ccm_req_priv_ctx *crypto_ccm_reqctx(\r\nstruct aead_request *req)\r\n{\r\nunsigned long align = crypto_aead_alignmask(crypto_aead_reqtfm(req));\r\nreturn (void *)PTR_ALIGN((u8 *)aead_request_ctx(req), align + 1);\r\n}\r\nstatic int set_msg_len(u8 *block, unsigned int msglen, int csize)\r\n{\r\n__be32 data;\r\nmemset(block, 0, csize);\r\nblock += csize;\r\nif (csize >= 4)\r\ncsize = 4;\r\nelse if (msglen > (1 << (8 * csize)))\r\nreturn -EOVERFLOW;\r\ndata = cpu_to_be32(msglen);\r\nmemcpy(block - csize, (u8 *)&data + 4 - csize, csize);\r\nreturn 0;\r\n}\r\nstatic int crypto_ccm_setkey(struct crypto_aead *aead, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_ablkcipher *ctr = ctx->ctr;\r\nstruct crypto_cipher *tfm = ctx->cipher;\r\nint err = 0;\r\ncrypto_ablkcipher_clear_flags(ctr, CRYPTO_TFM_REQ_MASK);\r\ncrypto_ablkcipher_set_flags(ctr, crypto_aead_get_flags(aead) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_ablkcipher_setkey(ctr, key, keylen);\r\ncrypto_aead_set_flags(aead, crypto_ablkcipher_get_flags(ctr) &\r\nCRYPTO_TFM_RES_MASK);\r\nif (err)\r\ngoto out;\r\ncrypto_cipher_clear_flags(tfm, CRYPTO_TFM_REQ_MASK);\r\ncrypto_cipher_set_flags(tfm, crypto_aead_get_flags(aead) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_cipher_setkey(tfm, key, keylen);\r\ncrypto_aead_set_flags(aead, crypto_cipher_get_flags(tfm) &\r\nCRYPTO_TFM_RES_MASK);\r\nout:\r\nreturn err;\r\n}\r\nstatic int crypto_ccm_setauthsize(struct crypto_aead *tfm,\r\nunsigned int authsize)\r\n{\r\nswitch (authsize) {\r\ncase 4:\r\ncase 6:\r\ncase 8:\r\ncase 10:\r\ncase 12:\r\ncase 14:\r\ncase 16:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int format_input(u8 *info, struct aead_request *req,\r\nunsigned int cryptlen)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nunsigned int lp = req->iv[0];\r\nunsigned int l = lp + 1;\r\nunsigned int m;\r\nm = crypto_aead_authsize(aead);\r\nmemcpy(info, req->iv, 16);\r\n*info |= (8 * ((m - 2) / 2));\r\nif (req->assoclen)\r\n*info |= 64;\r\nreturn set_msg_len(info + 16 - l, cryptlen, l);\r\n}\r\nstatic int format_adata(u8 *adata, unsigned int a)\r\n{\r\nint len = 0;\r\nif (a < 65280) {\r\n*(__be16 *)adata = cpu_to_be16(a);\r\nlen = 2;\r\n} else {\r\n*(__be16 *)adata = cpu_to_be16(0xfffe);\r\n*(__be32 *)&adata[2] = cpu_to_be32(a);\r\nlen = 6;\r\n}\r\nreturn len;\r\n}\r\nstatic void compute_mac(struct crypto_cipher *tfm, u8 *data, int n,\r\nstruct crypto_ccm_req_priv_ctx *pctx)\r\n{\r\nunsigned int bs = 16;\r\nu8 *odata = pctx->odata;\r\nu8 *idata = pctx->idata;\r\nint datalen, getlen;\r\ndatalen = n;\r\ngetlen = bs - pctx->ilen;\r\nif (datalen >= getlen) {\r\nmemcpy(idata + pctx->ilen, data, getlen);\r\ncrypto_xor(odata, idata, bs);\r\ncrypto_cipher_encrypt_one(tfm, odata, odata);\r\ndatalen -= getlen;\r\ndata += getlen;\r\npctx->ilen = 0;\r\n}\r\nwhile (datalen >= bs) {\r\ncrypto_xor(odata, data, bs);\r\ncrypto_cipher_encrypt_one(tfm, odata, odata);\r\ndatalen -= bs;\r\ndata += bs;\r\n}\r\nif (datalen) {\r\nmemcpy(idata + pctx->ilen, data, datalen);\r\npctx->ilen += datalen;\r\n}\r\n}\r\nstatic void get_data_to_compute(struct crypto_cipher *tfm,\r\nstruct crypto_ccm_req_priv_ctx *pctx,\r\nstruct scatterlist *sg, unsigned int len)\r\n{\r\nstruct scatter_walk walk;\r\nu8 *data_src;\r\nint n;\r\nscatterwalk_start(&walk, sg);\r\nwhile (len) {\r\nn = scatterwalk_clamp(&walk, len);\r\nif (!n) {\r\nscatterwalk_start(&walk, sg_next(walk.sg));\r\nn = scatterwalk_clamp(&walk, len);\r\n}\r\ndata_src = scatterwalk_map(&walk);\r\ncompute_mac(tfm, data_src, n, pctx);\r\nlen -= n;\r\nscatterwalk_unmap(data_src);\r\nscatterwalk_advance(&walk, n);\r\nscatterwalk_done(&walk, 0, len);\r\nif (len)\r\ncrypto_yield(pctx->flags);\r\n}\r\nif (pctx->ilen) {\r\nint padlen;\r\nu8 *odata = pctx->odata;\r\nu8 *idata = pctx->idata;\r\npadlen = 16 - pctx->ilen;\r\nmemset(idata + pctx->ilen, 0, padlen);\r\ncrypto_xor(odata, idata, 16);\r\ncrypto_cipher_encrypt_one(tfm, odata, odata);\r\npctx->ilen = 0;\r\n}\r\n}\r\nstatic int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,\r\nunsigned int cryptlen)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\r\nstruct crypto_cipher *cipher = ctx->cipher;\r\nunsigned int assoclen = req->assoclen;\r\nu8 *odata = pctx->odata;\r\nu8 *idata = pctx->idata;\r\nint err;\r\nerr = format_input(odata, req, cryptlen);\r\nif (err)\r\ngoto out;\r\ncrypto_cipher_encrypt_one(cipher, odata, odata);\r\nif (assoclen) {\r\npctx->ilen = format_adata(idata, assoclen);\r\nget_data_to_compute(cipher, pctx, req->src, req->assoclen);\r\n} else {\r\npctx->ilen = 0;\r\n}\r\nif (cryptlen)\r\nget_data_to_compute(cipher, pctx, plain, cryptlen);\r\nout:\r\nreturn err;\r\n}\r\nstatic void crypto_ccm_encrypt_done(struct crypto_async_request *areq, int err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\r\nu8 *odata = pctx->odata;\r\nif (!err)\r\nscatterwalk_map_and_copy(odata, req->dst,\r\nreq->assoclen + req->cryptlen,\r\ncrypto_aead_authsize(aead), 1);\r\naead_request_complete(req, err);\r\n}\r\nstatic inline int crypto_ccm_check_iv(const u8 *iv)\r\n{\r\nif (1 > iv[0] || iv[0] > 7)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int crypto_ccm_init_crypt(struct aead_request *req, u8 *tag)\r\n{\r\nstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\r\nstruct scatterlist *sg;\r\nu8 *iv = req->iv;\r\nint err;\r\nerr = crypto_ccm_check_iv(iv);\r\nif (err)\r\nreturn err;\r\npctx->flags = aead_request_flags(req);\r\nmemset(iv + 15 - iv[0], 0, iv[0] + 1);\r\nsg_init_table(pctx->src, 3);\r\nsg_set_buf(pctx->src, tag, 16);\r\nsg = scatterwalk_ffwd(pctx->src + 1, req->src, req->assoclen);\r\nif (sg != pctx->src + 1)\r\nsg_chain(pctx->src, 2, sg);\r\nif (req->src != req->dst) {\r\nsg_init_table(pctx->dst, 3);\r\nsg_set_buf(pctx->dst, tag, 16);\r\nsg = scatterwalk_ffwd(pctx->dst + 1, req->dst, req->assoclen);\r\nif (sg != pctx->dst + 1)\r\nsg_chain(pctx->dst, 2, sg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int crypto_ccm_encrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\r\nstruct ablkcipher_request *abreq = &pctx->abreq;\r\nstruct scatterlist *dst;\r\nunsigned int cryptlen = req->cryptlen;\r\nu8 *odata = pctx->odata;\r\nu8 *iv = req->iv;\r\nint err;\r\nerr = crypto_ccm_init_crypt(req, odata);\r\nif (err)\r\nreturn err;\r\nerr = crypto_ccm_auth(req, sg_next(pctx->src), cryptlen);\r\nif (err)\r\nreturn err;\r\ndst = pctx->src;\r\nif (req->src != req->dst)\r\ndst = pctx->dst;\r\nablkcipher_request_set_tfm(abreq, ctx->ctr);\r\nablkcipher_request_set_callback(abreq, pctx->flags,\r\ncrypto_ccm_encrypt_done, req);\r\nablkcipher_request_set_crypt(abreq, pctx->src, dst, cryptlen + 16, iv);\r\nerr = crypto_ablkcipher_encrypt(abreq);\r\nif (err)\r\nreturn err;\r\nscatterwalk_map_and_copy(odata, sg_next(dst), cryptlen,\r\ncrypto_aead_authsize(aead), 1);\r\nreturn err;\r\n}\r\nstatic void crypto_ccm_decrypt_done(struct crypto_async_request *areq,\r\nint err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nunsigned int authsize = crypto_aead_authsize(aead);\r\nunsigned int cryptlen = req->cryptlen - authsize;\r\nstruct scatterlist *dst;\r\npctx->flags = 0;\r\ndst = sg_next(req->src == req->dst ? pctx->src : pctx->dst);\r\nif (!err) {\r\nerr = crypto_ccm_auth(req, dst, cryptlen);\r\nif (!err && crypto_memneq(pctx->auth_tag, pctx->odata, authsize))\r\nerr = -EBADMSG;\r\n}\r\naead_request_complete(req, err);\r\n}\r\nstatic int crypto_ccm_decrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\r\nstruct ablkcipher_request *abreq = &pctx->abreq;\r\nstruct scatterlist *dst;\r\nunsigned int authsize = crypto_aead_authsize(aead);\r\nunsigned int cryptlen = req->cryptlen;\r\nu8 *authtag = pctx->auth_tag;\r\nu8 *odata = pctx->odata;\r\nu8 *iv = req->iv;\r\nint err;\r\ncryptlen -= authsize;\r\nerr = crypto_ccm_init_crypt(req, authtag);\r\nif (err)\r\nreturn err;\r\nscatterwalk_map_and_copy(authtag, sg_next(pctx->src), cryptlen,\r\nauthsize, 0);\r\ndst = pctx->src;\r\nif (req->src != req->dst)\r\ndst = pctx->dst;\r\nablkcipher_request_set_tfm(abreq, ctx->ctr);\r\nablkcipher_request_set_callback(abreq, pctx->flags,\r\ncrypto_ccm_decrypt_done, req);\r\nablkcipher_request_set_crypt(abreq, pctx->src, dst, cryptlen + 16, iv);\r\nerr = crypto_ablkcipher_decrypt(abreq);\r\nif (err)\r\nreturn err;\r\nerr = crypto_ccm_auth(req, sg_next(dst), cryptlen);\r\nif (err)\r\nreturn err;\r\nif (crypto_memneq(authtag, odata, authsize))\r\nreturn -EBADMSG;\r\nreturn err;\r\n}\r\nstatic int crypto_ccm_init_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct aead_instance *inst = aead_alg_instance(tfm);\r\nstruct ccm_instance_ctx *ictx = aead_instance_ctx(inst);\r\nstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(tfm);\r\nstruct crypto_cipher *cipher;\r\nstruct crypto_ablkcipher *ctr;\r\nunsigned long align;\r\nint err;\r\ncipher = crypto_spawn_cipher(&ictx->cipher);\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nctr = crypto_spawn_skcipher(&ictx->ctr);\r\nerr = PTR_ERR(ctr);\r\nif (IS_ERR(ctr))\r\ngoto err_free_cipher;\r\nctx->cipher = cipher;\r\nctx->ctr = ctr;\r\nalign = crypto_aead_alignmask(tfm);\r\nalign &= ~(crypto_tfm_ctx_alignment() - 1);\r\ncrypto_aead_set_reqsize(\r\ntfm,\r\nalign + sizeof(struct crypto_ccm_req_priv_ctx) +\r\ncrypto_ablkcipher_reqsize(ctr));\r\nreturn 0;\r\nerr_free_cipher:\r\ncrypto_free_cipher(cipher);\r\nreturn err;\r\n}\r\nstatic void crypto_ccm_exit_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(tfm);\r\ncrypto_free_cipher(ctx->cipher);\r\ncrypto_free_ablkcipher(ctx->ctr);\r\n}\r\nstatic void crypto_ccm_free(struct aead_instance *inst)\r\n{\r\nstruct ccm_instance_ctx *ctx = aead_instance_ctx(inst);\r\ncrypto_drop_spawn(&ctx->cipher);\r\ncrypto_drop_skcipher(&ctx->ctr);\r\nkfree(inst);\r\n}\r\nstatic int crypto_ccm_create_common(struct crypto_template *tmpl,\r\nstruct rtattr **tb,\r\nconst char *full_name,\r\nconst char *ctr_name,\r\nconst char *cipher_name)\r\n{\r\nstruct crypto_attr_type *algt;\r\nstruct aead_instance *inst;\r\nstruct crypto_alg *ctr;\r\nstruct crypto_alg *cipher;\r\nstruct ccm_instance_ctx *ictx;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn PTR_ERR(algt);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\r\nreturn -EINVAL;\r\ncipher = crypto_alg_mod_lookup(cipher_name, CRYPTO_ALG_TYPE_CIPHER,\r\nCRYPTO_ALG_TYPE_MASK);\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nerr = -EINVAL;\r\nif (cipher->cra_blocksize != 16)\r\ngoto out_put_cipher;\r\ninst = kzalloc(sizeof(*inst) + sizeof(*ictx), GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!inst)\r\ngoto out_put_cipher;\r\nictx = aead_instance_ctx(inst);\r\nerr = crypto_init_spawn(&ictx->cipher, cipher,\r\naead_crypto_instance(inst),\r\nCRYPTO_ALG_TYPE_MASK);\r\nif (err)\r\ngoto err_free_inst;\r\ncrypto_set_skcipher_spawn(&ictx->ctr, aead_crypto_instance(inst));\r\nerr = crypto_grab_skcipher(&ictx->ctr, ctr_name, 0,\r\ncrypto_requires_sync(algt->type,\r\nalgt->mask));\r\nif (err)\r\ngoto err_drop_cipher;\r\nctr = crypto_skcipher_spawn_alg(&ictx->ctr);\r\nerr = -EINVAL;\r\nif (ctr->cra_blocksize != 1)\r\ngoto err_drop_ctr;\r\nif (ctr->cra_ablkcipher.ivsize != 16)\r\ngoto err_drop_ctr;\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"ccm_base(%s,%s)", ctr->cra_driver_name,\r\ncipher->cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\r\ngoto err_drop_ctr;\r\nmemcpy(inst->alg.base.cra_name, full_name, CRYPTO_MAX_ALG_NAME);\r\ninst->alg.base.cra_flags = ctr->cra_flags & CRYPTO_ALG_ASYNC;\r\ninst->alg.base.cra_priority = (cipher->cra_priority +\r\nctr->cra_priority) / 2;\r\ninst->alg.base.cra_blocksize = 1;\r\ninst->alg.base.cra_alignmask = cipher->cra_alignmask |\r\nctr->cra_alignmask |\r\n(__alignof__(u32) - 1);\r\ninst->alg.ivsize = 16;\r\ninst->alg.maxauthsize = 16;\r\ninst->alg.base.cra_ctxsize = sizeof(struct crypto_ccm_ctx);\r\ninst->alg.init = crypto_ccm_init_tfm;\r\ninst->alg.exit = crypto_ccm_exit_tfm;\r\ninst->alg.setkey = crypto_ccm_setkey;\r\ninst->alg.setauthsize = crypto_ccm_setauthsize;\r\ninst->alg.encrypt = crypto_ccm_encrypt;\r\ninst->alg.decrypt = crypto_ccm_decrypt;\r\ninst->free = crypto_ccm_free;\r\nerr = aead_register_instance(tmpl, inst);\r\nif (err)\r\ngoto err_drop_ctr;\r\nout_put_cipher:\r\ncrypto_mod_put(cipher);\r\nreturn err;\r\nerr_drop_ctr:\r\ncrypto_drop_skcipher(&ictx->ctr);\r\nerr_drop_cipher:\r\ncrypto_drop_spawn(&ictx->cipher);\r\nerr_free_inst:\r\nkfree(inst);\r\ngoto out_put_cipher;\r\n}\r\nstatic int crypto_ccm_create(struct crypto_template *tmpl, struct rtattr **tb)\r\n{\r\nconst char *cipher_name;\r\nchar ctr_name[CRYPTO_MAX_ALG_NAME];\r\nchar full_name[CRYPTO_MAX_ALG_NAME];\r\ncipher_name = crypto_attr_alg_name(tb[1]);\r\nif (IS_ERR(cipher_name))\r\nreturn PTR_ERR(cipher_name);\r\nif (snprintf(ctr_name, CRYPTO_MAX_ALG_NAME, "ctr(%s)",\r\ncipher_name) >= CRYPTO_MAX_ALG_NAME)\r\nreturn -ENAMETOOLONG;\r\nif (snprintf(full_name, CRYPTO_MAX_ALG_NAME, "ccm(%s)", cipher_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\nreturn -ENAMETOOLONG;\r\nreturn crypto_ccm_create_common(tmpl, tb, full_name, ctr_name,\r\ncipher_name);\r\n}\r\nstatic int crypto_ccm_base_create(struct crypto_template *tmpl,\r\nstruct rtattr **tb)\r\n{\r\nconst char *ctr_name;\r\nconst char *cipher_name;\r\nchar full_name[CRYPTO_MAX_ALG_NAME];\r\nctr_name = crypto_attr_alg_name(tb[1]);\r\nif (IS_ERR(ctr_name))\r\nreturn PTR_ERR(ctr_name);\r\ncipher_name = crypto_attr_alg_name(tb[2]);\r\nif (IS_ERR(cipher_name))\r\nreturn PTR_ERR(cipher_name);\r\nif (snprintf(full_name, CRYPTO_MAX_ALG_NAME, "ccm_base(%s,%s)",\r\nctr_name, cipher_name) >= CRYPTO_MAX_ALG_NAME)\r\nreturn -ENAMETOOLONG;\r\nreturn crypto_ccm_create_common(tmpl, tb, full_name, ctr_name,\r\ncipher_name);\r\n}\r\nstatic int crypto_rfc4309_setkey(struct crypto_aead *parent, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(parent);\r\nstruct crypto_aead *child = ctx->child;\r\nint err;\r\nif (keylen < 3)\r\nreturn -EINVAL;\r\nkeylen -= 3;\r\nmemcpy(ctx->nonce, key + keylen, 3);\r\ncrypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_aead_set_flags(child, crypto_aead_get_flags(parent) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_aead_setkey(child, key, keylen);\r\ncrypto_aead_set_flags(parent, crypto_aead_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic int crypto_rfc4309_setauthsize(struct crypto_aead *parent,\r\nunsigned int authsize)\r\n{\r\nstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(parent);\r\nswitch (authsize) {\r\ncase 8:\r\ncase 12:\r\ncase 16:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn crypto_aead_setauthsize(ctx->child, authsize);\r\n}\r\nstatic struct aead_request *crypto_rfc4309_crypt(struct aead_request *req)\r\n{\r\nstruct crypto_rfc4309_req_ctx *rctx = aead_request_ctx(req);\r\nstruct aead_request *subreq = &rctx->subreq;\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_aead *child = ctx->child;\r\nstruct scatterlist *sg;\r\nu8 *iv = PTR_ALIGN((u8 *)(subreq + 1) + crypto_aead_reqsize(child),\r\ncrypto_aead_alignmask(child) + 1);\r\niv[0] = 3;\r\nmemcpy(iv + 1, ctx->nonce, 3);\r\nmemcpy(iv + 4, req->iv, 8);\r\nscatterwalk_map_and_copy(iv + 16, req->src, 0, req->assoclen - 8, 0);\r\nsg_init_table(rctx->src, 3);\r\nsg_set_buf(rctx->src, iv + 16, req->assoclen - 8);\r\nsg = scatterwalk_ffwd(rctx->src + 1, req->src, req->assoclen);\r\nif (sg != rctx->src + 1)\r\nsg_chain(rctx->src, 2, sg);\r\nif (req->src != req->dst) {\r\nsg_init_table(rctx->dst, 3);\r\nsg_set_buf(rctx->dst, iv + 16, req->assoclen - 8);\r\nsg = scatterwalk_ffwd(rctx->dst + 1, req->dst, req->assoclen);\r\nif (sg != rctx->dst + 1)\r\nsg_chain(rctx->dst, 2, sg);\r\n}\r\naead_request_set_tfm(subreq, child);\r\naead_request_set_callback(subreq, req->base.flags, req->base.complete,\r\nreq->base.data);\r\naead_request_set_crypt(subreq, rctx->src,\r\nreq->src == req->dst ? rctx->src : rctx->dst,\r\nreq->cryptlen, iv);\r\naead_request_set_ad(subreq, req->assoclen - 8);\r\nreturn subreq;\r\n}\r\nstatic int crypto_rfc4309_encrypt(struct aead_request *req)\r\n{\r\nif (req->assoclen != 16 && req->assoclen != 20)\r\nreturn -EINVAL;\r\nreq = crypto_rfc4309_crypt(req);\r\nreturn crypto_aead_encrypt(req);\r\n}\r\nstatic int crypto_rfc4309_decrypt(struct aead_request *req)\r\n{\r\nif (req->assoclen != 16 && req->assoclen != 20)\r\nreturn -EINVAL;\r\nreq = crypto_rfc4309_crypt(req);\r\nreturn crypto_aead_decrypt(req);\r\n}\r\nstatic int crypto_rfc4309_init_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct aead_instance *inst = aead_alg_instance(tfm);\r\nstruct crypto_aead_spawn *spawn = aead_instance_ctx(inst);\r\nstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(tfm);\r\nstruct crypto_aead *aead;\r\nunsigned long align;\r\naead = crypto_spawn_aead(spawn);\r\nif (IS_ERR(aead))\r\nreturn PTR_ERR(aead);\r\nctx->child = aead;\r\nalign = crypto_aead_alignmask(aead);\r\nalign &= ~(crypto_tfm_ctx_alignment() - 1);\r\ncrypto_aead_set_reqsize(\r\ntfm,\r\nsizeof(struct crypto_rfc4309_req_ctx) +\r\nALIGN(crypto_aead_reqsize(aead), crypto_tfm_ctx_alignment()) +\r\nalign + 32);\r\nreturn 0;\r\n}\r\nstatic void crypto_rfc4309_exit_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(tfm);\r\ncrypto_free_aead(ctx->child);\r\n}\r\nstatic void crypto_rfc4309_free(struct aead_instance *inst)\r\n{\r\ncrypto_drop_aead(aead_instance_ctx(inst));\r\nkfree(inst);\r\n}\r\nstatic int crypto_rfc4309_create(struct crypto_template *tmpl,\r\nstruct rtattr **tb)\r\n{\r\nstruct crypto_attr_type *algt;\r\nstruct aead_instance *inst;\r\nstruct crypto_aead_spawn *spawn;\r\nstruct aead_alg *alg;\r\nconst char *ccm_name;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn PTR_ERR(algt);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\r\nreturn -EINVAL;\r\nccm_name = crypto_attr_alg_name(tb[1]);\r\nif (IS_ERR(ccm_name))\r\nreturn PTR_ERR(ccm_name);\r\ninst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);\r\nif (!inst)\r\nreturn -ENOMEM;\r\nspawn = aead_instance_ctx(inst);\r\ncrypto_set_aead_spawn(spawn, aead_crypto_instance(inst));\r\nerr = crypto_grab_aead(spawn, ccm_name, 0,\r\ncrypto_requires_sync(algt->type, algt->mask));\r\nif (err)\r\ngoto out_free_inst;\r\nalg = crypto_spawn_aead_alg(spawn);\r\nerr = -EINVAL;\r\nif (crypto_aead_alg_ivsize(alg) != 16)\r\ngoto out_drop_alg;\r\nif (alg->base.cra_blocksize != 1)\r\ngoto out_drop_alg;\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME,\r\n"rfc4309(%s)", alg->base.cra_name) >=\r\nCRYPTO_MAX_ALG_NAME ||\r\nsnprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"rfc4309(%s)", alg->base.cra_driver_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\ngoto out_drop_alg;\r\ninst->alg.base.cra_flags = alg->base.cra_flags & CRYPTO_ALG_ASYNC;\r\ninst->alg.base.cra_priority = alg->base.cra_priority;\r\ninst->alg.base.cra_blocksize = 1;\r\ninst->alg.base.cra_alignmask = alg->base.cra_alignmask;\r\ninst->alg.ivsize = 8;\r\ninst->alg.maxauthsize = 16;\r\ninst->alg.base.cra_ctxsize = sizeof(struct crypto_rfc4309_ctx);\r\ninst->alg.init = crypto_rfc4309_init_tfm;\r\ninst->alg.exit = crypto_rfc4309_exit_tfm;\r\ninst->alg.setkey = crypto_rfc4309_setkey;\r\ninst->alg.setauthsize = crypto_rfc4309_setauthsize;\r\ninst->alg.encrypt = crypto_rfc4309_encrypt;\r\ninst->alg.decrypt = crypto_rfc4309_decrypt;\r\ninst->free = crypto_rfc4309_free;\r\nerr = aead_register_instance(tmpl, inst);\r\nif (err)\r\ngoto out_drop_alg;\r\nout:\r\nreturn err;\r\nout_drop_alg:\r\ncrypto_drop_aead(spawn);\r\nout_free_inst:\r\nkfree(inst);\r\ngoto out;\r\n}\r\nstatic int __init crypto_ccm_module_init(void)\r\n{\r\nint err;\r\nerr = crypto_register_template(&crypto_ccm_base_tmpl);\r\nif (err)\r\ngoto out;\r\nerr = crypto_register_template(&crypto_ccm_tmpl);\r\nif (err)\r\ngoto out_undo_base;\r\nerr = crypto_register_template(&crypto_rfc4309_tmpl);\r\nif (err)\r\ngoto out_undo_ccm;\r\nout:\r\nreturn err;\r\nout_undo_ccm:\r\ncrypto_unregister_template(&crypto_ccm_tmpl);\r\nout_undo_base:\r\ncrypto_unregister_template(&crypto_ccm_base_tmpl);\r\ngoto out;\r\n}\r\nstatic void __exit crypto_ccm_module_exit(void)\r\n{\r\ncrypto_unregister_template(&crypto_rfc4309_tmpl);\r\ncrypto_unregister_template(&crypto_ccm_tmpl);\r\ncrypto_unregister_template(&crypto_ccm_base_tmpl);\r\n}
