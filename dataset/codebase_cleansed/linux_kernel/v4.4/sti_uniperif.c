static int sti_uniperiph_dai_create_ctrl(struct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *uni = priv->dai_data.uni;\r\nstruct snd_kcontrol_new *ctrl;\r\nint i;\r\nif (!uni->num_ctrls)\r\nreturn 0;\r\nfor (i = 0; i < uni->num_ctrls; i++) {\r\nctrl = &uni->snd_ctrls[i];\r\nctrl->index = uni->info->id;\r\nctrl->device = uni->info->id;\r\n}\r\nreturn snd_soc_add_dai_controls(dai, uni->snd_ctrls, uni->num_ctrls);\r\n}\r\nint sti_uniperiph_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_dmaengine_dai_dma_data *dma_data;\r\nint transfer_size;\r\ntransfer_size = params_channels(params) * UNIPERIF_FIFO_FRAMES;\r\ndma_data = snd_soc_dai_get_dma_data(dai, substream);\r\ndma_data->maxburst = transfer_size;\r\nreturn 0;\r\n}\r\nint sti_uniperiph_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\npriv->dai_data.uni->daifmt = fmt;\r\nreturn 0;\r\n}\r\nstatic int sti_uniperiph_dai_suspend(struct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *uni = priv->dai_data.uni;\r\nint ret;\r\nif (uni->state != UNIPERIF_STATE_STOPPED) {\r\ndev_err(uni->dev, "%s: invalid uni state( %d)",\r\n__func__, (int)uni->state);\r\nreturn -EBUSY;\r\n}\r\nret = pinctrl_pm_select_sleep_state(uni->dev);\r\nif (ret)\r\ndev_err(uni->dev, "%s: failed to select pinctrl state",\r\n__func__);\r\nreturn ret;\r\n}\r\nstatic int sti_uniperiph_dai_resume(struct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *uni = priv->dai_data.uni;\r\nint ret;\r\nif (of_device_is_compatible(dai->dev->of_node, "st,sti-uni-player")) {\r\nret = uni_player_resume(uni);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = pinctrl_pm_select_default_state(uni->dev);\r\nif (ret)\r\ndev_err(uni->dev, "%s: failed to select pinctrl state",\r\n__func__);\r\nreturn ret;\r\n}\r\nstatic int sti_uniperiph_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct sti_uniperiph_dai *dai_data = &priv->dai_data;\r\nif (of_device_is_compatible(dai->dev->of_node, "st,sti-uni-player"))\r\nsnd_soc_dai_init_dma_data(dai, &dai_data->dma_data, NULL);\r\nelse\r\nsnd_soc_dai_init_dma_data(dai, NULL, &dai_data->dma_data);\r\ndai_data->dma_data.addr = dai_data->uni->fifo_phys_address;\r\ndai_data->dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nreturn sti_uniperiph_dai_create_ctrl(dai);\r\n}\r\nstatic int sti_uniperiph_cpu_dai_of(struct device_node *node,\r\nstruct sti_uniperiph_data *priv)\r\n{\r\nconst char *str;\r\nint ret;\r\nstruct device *dev = &priv->pdev->dev;\r\nstruct sti_uniperiph_dai *dai_data = &priv->dai_data;\r\nstruct snd_soc_dai_driver *dai = priv->dai;\r\nstruct snd_soc_pcm_stream *stream;\r\nstruct uniperif *uni;\r\nuni = devm_kzalloc(dev, sizeof(*uni), GFP_KERNEL);\r\nif (!uni)\r\nreturn -ENOMEM;\r\n*dai = sti_uniperiph_dai_template;\r\nret = of_property_read_string(node, "dai-name", &str);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: dai name missing.\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ndai->name = str;\r\nuni->mem_region = platform_get_resource(priv->pdev, IORESOURCE_MEM, 0);\r\nif (!uni->mem_region) {\r\ndev_err(dev, "Failed to get memory resource");\r\nreturn -ENODEV;\r\n}\r\nuni->base = devm_ioremap_resource(dev, uni->mem_region);\r\nif (IS_ERR(uni->base))\r\nreturn PTR_ERR(uni->base);\r\nuni->fifo_phys_address = uni->mem_region->start +\r\nUNIPERIF_FIFO_DATA_OFFSET(uni);\r\nuni->irq = platform_get_irq(priv->pdev, 0);\r\nif (uni->irq < 0) {\r\ndev_err(dev, "Failed to get IRQ resource");\r\nreturn -ENXIO;\r\n}\r\ndai_data->uni = uni;\r\nif (of_device_is_compatible(node, "st,sti-uni-player")) {\r\nuni_player_init(priv->pdev, uni);\r\nstream = &dai->playback;\r\n} else {\r\nuni_reader_init(priv->pdev, uni);\r\nstream = &dai->capture;\r\n}\r\ndai->ops = uni->dai_ops;\r\nstream->stream_name = dai->name;\r\nstream->channels_min = uni->hw->channels_min;\r\nstream->channels_max = uni->hw->channels_max;\r\nstream->rates = uni->hw->rates;\r\nstream->formats = uni->hw->formats;\r\nreturn 0;\r\n}\r\nstatic int sti_uniperiph_probe(struct platform_device *pdev)\r\n{\r\nstruct sti_uniperiph_data *priv;\r\nstruct device_node *node = pdev->dev.of_node;\r\nint ret;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->dai = devm_kzalloc(&pdev->dev, sizeof(*priv->dai), GFP_KERNEL);\r\nif (!priv->dai)\r\nreturn -ENOMEM;\r\npriv->pdev = pdev;\r\nret = sti_uniperiph_cpu_dai_of(node, priv);\r\ndev_set_drvdata(&pdev->dev, priv);\r\nret = devm_snd_soc_register_component(&pdev->dev,\r\n&sti_uniperiph_dai_component,\r\npriv->dai, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn devm_snd_dmaengine_pcm_register(&pdev->dev,\r\n&dmaengine_pcm_config, 0);\r\n}
