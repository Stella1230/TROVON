static void ims_pcu_buttons_report(struct ims_pcu *pcu, u32 data)\r\n{\r\nstruct ims_pcu_buttons *buttons = &pcu->buttons;\r\nstruct input_dev *input = buttons->input;\r\nint i;\r\nfor (i = 0; i < 32; i++) {\r\nunsigned short keycode = buttons->keymap[i];\r\nif (keycode != KEY_RESERVED)\r\ninput_report_key(input, keycode, data & (1UL << i));\r\n}\r\ninput_sync(input);\r\n}\r\nstatic int ims_pcu_setup_buttons(struct ims_pcu *pcu,\r\nconst unsigned short *keymap,\r\nsize_t keymap_len)\r\n{\r\nstruct ims_pcu_buttons *buttons = &pcu->buttons;\r\nstruct input_dev *input;\r\nint i;\r\nint error;\r\ninput = input_allocate_device();\r\nif (!input) {\r\ndev_err(pcu->dev,\r\n"Not enough memory for input input device\n");\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(buttons->name, sizeof(buttons->name),\r\n"IMS PCU#%d Button Interface", pcu->device_no);\r\nusb_make_path(pcu->udev, buttons->phys, sizeof(buttons->phys));\r\nstrlcat(buttons->phys, "/input0", sizeof(buttons->phys));\r\nmemcpy(buttons->keymap, keymap, sizeof(*keymap) * keymap_len);\r\ninput->name = buttons->name;\r\ninput->phys = buttons->phys;\r\nusb_to_input_id(pcu->udev, &input->id);\r\ninput->dev.parent = &pcu->ctrl_intf->dev;\r\ninput->keycode = buttons->keymap;\r\ninput->keycodemax = ARRAY_SIZE(buttons->keymap);\r\ninput->keycodesize = sizeof(buttons->keymap[0]);\r\n__set_bit(EV_KEY, input->evbit);\r\nfor (i = 0; i < IMS_PCU_KEYMAP_LEN; i++)\r\n__set_bit(buttons->keymap[i], input->keybit);\r\n__clear_bit(KEY_RESERVED, input->keybit);\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(pcu->dev,\r\n"Failed to register buttons input device: %d\n",\r\nerror);\r\ninput_free_device(input);\r\nreturn error;\r\n}\r\nbuttons->input = input;\r\nreturn 0;\r\n}\r\nstatic void ims_pcu_destroy_buttons(struct ims_pcu *pcu)\r\n{\r\nstruct ims_pcu_buttons *buttons = &pcu->buttons;\r\ninput_unregister_device(buttons->input);\r\n}\r\nstatic void ims_pcu_gamepad_report(struct ims_pcu *pcu, u32 data)\r\n{\r\nstruct ims_pcu_gamepad *gamepad = pcu->gamepad;\r\nstruct input_dev *input = gamepad->input;\r\nint x, y;\r\nx = !!(data & (1 << 14)) - !!(data & (1 << 13));\r\ny = !!(data & (1 << 12)) - !!(data & (1 << 11));\r\ninput_report_abs(input, ABS_X, x);\r\ninput_report_abs(input, ABS_Y, y);\r\ninput_report_key(input, BTN_A, data & (1 << 7));\r\ninput_report_key(input, BTN_B, data & (1 << 8));\r\ninput_report_key(input, BTN_X, data & (1 << 9));\r\ninput_report_key(input, BTN_Y, data & (1 << 10));\r\ninput_report_key(input, BTN_START, data & (1 << 15));\r\ninput_report_key(input, BTN_SELECT, data & (1 << 16));\r\ninput_sync(input);\r\n}\r\nstatic int ims_pcu_setup_gamepad(struct ims_pcu *pcu)\r\n{\r\nstruct ims_pcu_gamepad *gamepad;\r\nstruct input_dev *input;\r\nint error;\r\ngamepad = kzalloc(sizeof(struct ims_pcu_gamepad), GFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!gamepad || !input) {\r\ndev_err(pcu->dev,\r\n"Not enough memory for gamepad device\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\ngamepad->input = input;\r\nsnprintf(gamepad->name, sizeof(gamepad->name),\r\n"IMS PCU#%d Gamepad Interface", pcu->device_no);\r\nusb_make_path(pcu->udev, gamepad->phys, sizeof(gamepad->phys));\r\nstrlcat(gamepad->phys, "/input1", sizeof(gamepad->phys));\r\ninput->name = gamepad->name;\r\ninput->phys = gamepad->phys;\r\nusb_to_input_id(pcu->udev, &input->id);\r\ninput->dev.parent = &pcu->ctrl_intf->dev;\r\n__set_bit(EV_KEY, input->evbit);\r\n__set_bit(BTN_A, input->keybit);\r\n__set_bit(BTN_B, input->keybit);\r\n__set_bit(BTN_X, input->keybit);\r\n__set_bit(BTN_Y, input->keybit);\r\n__set_bit(BTN_START, input->keybit);\r\n__set_bit(BTN_SELECT, input->keybit);\r\n__set_bit(EV_ABS, input->evbit);\r\ninput_set_abs_params(input, ABS_X, -1, 1, 0, 0);\r\ninput_set_abs_params(input, ABS_Y, -1, 1, 0, 0);\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(pcu->dev,\r\n"Failed to register gamepad input device: %d\n",\r\nerror);\r\ngoto err_free_mem;\r\n}\r\npcu->gamepad = gamepad;\r\nreturn 0;\r\nerr_free_mem:\r\ninput_free_device(input);\r\nkfree(gamepad);\r\nreturn -ENOMEM;\r\n}\r\nstatic void ims_pcu_destroy_gamepad(struct ims_pcu *pcu)\r\n{\r\nstruct ims_pcu_gamepad *gamepad = pcu->gamepad;\r\ninput_unregister_device(gamepad->input);\r\nkfree(gamepad);\r\n}\r\nstatic void ims_pcu_report_events(struct ims_pcu *pcu)\r\n{\r\nu32 data = get_unaligned_be32(&pcu->read_buf[3]);\r\nims_pcu_buttons_report(pcu, data & ~IMS_PCU_GAMEPAD_MASK);\r\nif (pcu->gamepad)\r\nims_pcu_gamepad_report(pcu, data);\r\n}\r\nstatic void ims_pcu_handle_response(struct ims_pcu *pcu)\r\n{\r\nswitch (pcu->read_buf[0]) {\r\ncase IMS_PCU_RSP_EVNT_BUTTONS:\r\nif (likely(pcu->setup_complete))\r\nims_pcu_report_events(pcu);\r\nbreak;\r\ndefault:\r\nif (pcu->read_buf[0] == pcu->expected_response &&\r\npcu->read_buf[1] == pcu->ack_id - 1) {\r\nmemcpy(pcu->cmd_buf, pcu->read_buf, pcu->read_pos);\r\npcu->cmd_buf_len = pcu->read_pos;\r\ncomplete(&pcu->cmd_done);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void ims_pcu_process_data(struct ims_pcu *pcu, struct urb *urb)\r\n{\r\nint i;\r\nfor (i = 0; i < urb->actual_length; i++) {\r\nu8 data = pcu->urb_in_buf[i];\r\nif (!pcu->have_stx && data != IMS_PCU_PROTOCOL_STX)\r\ncontinue;\r\nif (pcu->have_dle) {\r\npcu->have_dle = false;\r\npcu->read_buf[pcu->read_pos++] = data;\r\npcu->check_sum += data;\r\ncontinue;\r\n}\r\nswitch (data) {\r\ncase IMS_PCU_PROTOCOL_STX:\r\nif (pcu->have_stx)\r\ndev_warn(pcu->dev,\r\n"Unexpected STX at byte %d, discarding old data\n",\r\npcu->read_pos);\r\npcu->have_stx = true;\r\npcu->have_dle = false;\r\npcu->read_pos = 0;\r\npcu->check_sum = 0;\r\nbreak;\r\ncase IMS_PCU_PROTOCOL_DLE:\r\npcu->have_dle = true;\r\nbreak;\r\ncase IMS_PCU_PROTOCOL_ETX:\r\nif (pcu->read_pos < IMS_PCU_MIN_PACKET_LEN) {\r\ndev_warn(pcu->dev,\r\n"Short packet received (%d bytes), ignoring\n",\r\npcu->read_pos);\r\n} else if (pcu->check_sum != 0) {\r\ndev_warn(pcu->dev,\r\n"Invalid checksum in packet (%d bytes), ignoring\n",\r\npcu->read_pos);\r\n} else {\r\nims_pcu_handle_response(pcu);\r\n}\r\npcu->have_stx = false;\r\npcu->have_dle = false;\r\npcu->read_pos = 0;\r\nbreak;\r\ndefault:\r\npcu->read_buf[pcu->read_pos++] = data;\r\npcu->check_sum += data;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic bool ims_pcu_byte_needs_escape(u8 byte)\r\n{\r\nreturn byte == IMS_PCU_PROTOCOL_STX ||\r\nbyte == IMS_PCU_PROTOCOL_ETX ||\r\nbyte == IMS_PCU_PROTOCOL_DLE;\r\n}\r\nstatic int ims_pcu_send_cmd_chunk(struct ims_pcu *pcu,\r\nu8 command, int chunk, int len)\r\n{\r\nint error;\r\nerror = usb_bulk_msg(pcu->udev,\r\nusb_sndbulkpipe(pcu->udev,\r\npcu->ep_out->bEndpointAddress),\r\npcu->urb_out_buf, len,\r\nNULL, IMS_PCU_CMD_WRITE_TIMEOUT);\r\nif (error < 0) {\r\ndev_dbg(pcu->dev,\r\n"Sending 0x%02x command failed at chunk %d: %d\n",\r\ncommand, chunk, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ims_pcu_send_command(struct ims_pcu *pcu,\r\nu8 command, const u8 *data, int len)\r\n{\r\nint count = 0;\r\nint chunk = 0;\r\nint delta;\r\nint i;\r\nint error;\r\nu8 csum = 0;\r\nu8 ack_id;\r\npcu->urb_out_buf[count++] = IMS_PCU_PROTOCOL_STX;\r\npcu->urb_out_buf[count++] = command;\r\ncsum += command;\r\nack_id = pcu->ack_id++;\r\nif (ack_id == 0xff)\r\nack_id = pcu->ack_id++;\r\nif (ims_pcu_byte_needs_escape(ack_id))\r\npcu->urb_out_buf[count++] = IMS_PCU_PROTOCOL_DLE;\r\npcu->urb_out_buf[count++] = ack_id;\r\ncsum += ack_id;\r\nfor (i = 0; i < len; i++) {\r\ndelta = ims_pcu_byte_needs_escape(data[i]) ? 2 : 1;\r\nif (count + delta >= pcu->max_out_size) {\r\nerror = ims_pcu_send_cmd_chunk(pcu, command,\r\n++chunk, count);\r\nif (error)\r\nreturn error;\r\ncount = 0;\r\n}\r\nif (delta == 2)\r\npcu->urb_out_buf[count++] = IMS_PCU_PROTOCOL_DLE;\r\npcu->urb_out_buf[count++] = data[i];\r\ncsum += data[i];\r\n}\r\ncsum = 1 + ~csum;\r\ndelta = ims_pcu_byte_needs_escape(csum) ? 3 : 2;\r\nif (count + delta >= pcu->max_out_size) {\r\nerror = ims_pcu_send_cmd_chunk(pcu, command, ++chunk, count);\r\nif (error)\r\nreturn error;\r\ncount = 0;\r\n}\r\nif (delta == 3)\r\npcu->urb_out_buf[count++] = IMS_PCU_PROTOCOL_DLE;\r\npcu->urb_out_buf[count++] = csum;\r\npcu->urb_out_buf[count++] = IMS_PCU_PROTOCOL_ETX;\r\nreturn ims_pcu_send_cmd_chunk(pcu, command, ++chunk, count);\r\n}\r\nstatic int __ims_pcu_execute_command(struct ims_pcu *pcu,\r\nu8 command, const void *data, size_t len,\r\nu8 expected_response, int response_time)\r\n{\r\nint error;\r\npcu->expected_response = expected_response;\r\ninit_completion(&pcu->cmd_done);\r\nerror = ims_pcu_send_command(pcu, command, data, len);\r\nif (error)\r\nreturn error;\r\nif (expected_response &&\r\n!wait_for_completion_timeout(&pcu->cmd_done,\r\nmsecs_to_jiffies(response_time))) {\r\ndev_dbg(pcu->dev, "Command 0x%02x timed out\n", command);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __ims_pcu_execute_bl_command(struct ims_pcu *pcu,\r\nu8 command, const void *data, size_t len,\r\nu8 expected_response, int response_time)\r\n{\r\nint error;\r\npcu->cmd_buf[0] = command;\r\nif (data)\r\nmemcpy(&pcu->cmd_buf[1], data, len);\r\nerror = __ims_pcu_execute_command(pcu,\r\nIMS_PCU_CMD_BOOTLOADER, pcu->cmd_buf, len + 1,\r\nexpected_response ? IMS_PCU_RSP_BOOTLOADER : 0,\r\nresponse_time);\r\nif (error) {\r\ndev_err(pcu->dev,\r\n"Failure when sending 0x%02x command to bootloader, error: %d\n",\r\npcu->cmd_buf[0], error);\r\nreturn error;\r\n}\r\nif (expected_response && pcu->cmd_buf[2] != expected_response) {\r\ndev_err(pcu->dev,\r\n"Unexpected response from bootloader: 0x%02x, wanted 0x%02x\n",\r\npcu->cmd_buf[2], expected_response);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ims_pcu_get_info(struct ims_pcu *pcu)\r\n{\r\nint error;\r\nerror = ims_pcu_execute_query(pcu, GET_INFO);\r\nif (error) {\r\ndev_err(pcu->dev,\r\n"GET_INFO command failed, error: %d\n", error);\r\nreturn error;\r\n}\r\nmemcpy(pcu->part_number,\r\n&pcu->cmd_buf[IMS_PCU_INFO_PART_OFFSET],\r\nsizeof(pcu->part_number));\r\nmemcpy(pcu->date_of_manufacturing,\r\n&pcu->cmd_buf[IMS_PCU_INFO_DOM_OFFSET],\r\nsizeof(pcu->date_of_manufacturing));\r\nmemcpy(pcu->serial_number,\r\n&pcu->cmd_buf[IMS_PCU_INFO_SERIAL_OFFSET],\r\nsizeof(pcu->serial_number));\r\nreturn 0;\r\n}\r\nstatic int ims_pcu_set_info(struct ims_pcu *pcu)\r\n{\r\nint error;\r\nmemcpy(&pcu->cmd_buf[IMS_PCU_INFO_PART_OFFSET],\r\npcu->part_number, sizeof(pcu->part_number));\r\nmemcpy(&pcu->cmd_buf[IMS_PCU_INFO_DOM_OFFSET],\r\npcu->date_of_manufacturing, sizeof(pcu->date_of_manufacturing));\r\nmemcpy(&pcu->cmd_buf[IMS_PCU_INFO_SERIAL_OFFSET],\r\npcu->serial_number, sizeof(pcu->serial_number));\r\nerror = ims_pcu_execute_command(pcu, SET_INFO,\r\n&pcu->cmd_buf[IMS_PCU_DATA_OFFSET],\r\nIMS_PCU_SET_INFO_SIZE);\r\nif (error) {\r\ndev_err(pcu->dev,\r\n"Failed to update device information, error: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ims_pcu_switch_to_bootloader(struct ims_pcu *pcu)\r\n{\r\nint error;\r\nerror = ims_pcu_execute_command(pcu, JUMP_TO_BTLDR, NULL, 0);\r\nif (error) {\r\ndev_err(pcu->dev,\r\n"Failure when sending JUMP TO BOOLTLOADER command, error: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int ims_pcu_count_fw_records(const struct firmware *fw)\r\n{\r\nconst struct ihex_binrec *rec = (const struct ihex_binrec *)fw->data;\r\nunsigned int count = 0;\r\nwhile (rec) {\r\ncount++;\r\nrec = ihex_next_binrec(rec);\r\n}\r\nreturn count;\r\n}\r\nstatic int ims_pcu_verify_block(struct ims_pcu *pcu,\r\nu32 addr, u8 len, const u8 *data)\r\n{\r\nstruct ims_pcu_flash_fmt *fragment;\r\nint error;\r\nfragment = (void *)&pcu->cmd_buf[1];\r\nput_unaligned_le32(addr, &fragment->addr);\r\nfragment->len = len;\r\nerror = ims_pcu_execute_bl_command(pcu, READ_APP, NULL, 5,\r\nIMS_PCU_CMD_RESPONSE_TIMEOUT);\r\nif (error) {\r\ndev_err(pcu->dev,\r\n"Failed to retrieve block at 0x%08x, len %d, error: %d\n",\r\naddr, len, error);\r\nreturn error;\r\n}\r\nfragment = (void *)&pcu->cmd_buf[IMS_PCU_BL_DATA_OFFSET];\r\nif (get_unaligned_le32(&fragment->addr) != addr ||\r\nfragment->len != len) {\r\ndev_err(pcu->dev,\r\n"Wrong block when retrieving 0x%08x (0x%08x), len %d (%d)\n",\r\naddr, get_unaligned_le32(&fragment->addr),\r\nlen, fragment->len);\r\nreturn -EINVAL;\r\n}\r\nif (memcmp(fragment->data, data, len)) {\r\ndev_err(pcu->dev,\r\n"Mismatch in block at 0x%08x, len %d\n",\r\naddr, len);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ims_pcu_flash_firmware(struct ims_pcu *pcu,\r\nconst struct firmware *fw,\r\nunsigned int n_fw_records)\r\n{\r\nconst struct ihex_binrec *rec = (const struct ihex_binrec *)fw->data;\r\nstruct ims_pcu_flash_fmt *fragment;\r\nunsigned int count = 0;\r\nu32 addr;\r\nu8 len;\r\nint error;\r\nerror = ims_pcu_execute_bl_command(pcu, ERASE_APP, NULL, 0, 2000);\r\nif (error) {\r\ndev_err(pcu->dev,\r\n"Failed to erase application image, error: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nwhile (rec) {\r\naddr = be32_to_cpu(rec->addr) / 2;\r\nlen = be16_to_cpu(rec->len);\r\nfragment = (void *)&pcu->cmd_buf[1];\r\nput_unaligned_le32(addr, &fragment->addr);\r\nfragment->len = len;\r\nmemcpy(fragment->data, rec->data, len);\r\nerror = ims_pcu_execute_bl_command(pcu, PROGRAM_DEVICE,\r\nNULL, len + 5,\r\nIMS_PCU_CMD_RESPONSE_TIMEOUT);\r\nif (error) {\r\ndev_err(pcu->dev,\r\n"Failed to write block at 0x%08x, len %d, error: %d\n",\r\naddr, len, error);\r\nreturn error;\r\n}\r\nif (addr >= pcu->fw_start_addr && addr < pcu->fw_end_addr) {\r\nerror = ims_pcu_verify_block(pcu, addr, len, rec->data);\r\nif (error)\r\nreturn error;\r\n}\r\ncount++;\r\npcu->update_firmware_status = (count * 100) / n_fw_records;\r\nrec = ihex_next_binrec(rec);\r\n}\r\nerror = ims_pcu_execute_bl_command(pcu, PROGRAM_COMPLETE,\r\nNULL, 0, 2000);\r\nif (error)\r\ndev_err(pcu->dev,\r\n"Failed to send PROGRAM_COMPLETE, error: %d\n",\r\nerror);\r\nreturn 0;\r\n}\r\nstatic int ims_pcu_handle_firmware_update(struct ims_pcu *pcu,\r\nconst struct firmware *fw)\r\n{\r\nunsigned int n_fw_records;\r\nint retval;\r\ndev_info(pcu->dev, "Updating firmware %s, size: %zu\n",\r\nIMS_PCU_FIRMWARE_NAME, fw->size);\r\nn_fw_records = ims_pcu_count_fw_records(fw);\r\nretval = ims_pcu_flash_firmware(pcu, fw, n_fw_records);\r\nif (retval)\r\ngoto out;\r\nretval = ims_pcu_execute_bl_command(pcu, LAUNCH_APP, NULL, 0, 0);\r\nif (retval)\r\ndev_err(pcu->dev,\r\n"Failed to start application image, error: %d\n",\r\nretval);\r\nout:\r\npcu->update_firmware_status = retval;\r\nsysfs_notify(&pcu->dev->kobj, NULL, "update_firmware_status");\r\nreturn retval;\r\n}\r\nstatic void ims_pcu_process_async_firmware(const struct firmware *fw,\r\nvoid *context)\r\n{\r\nstruct ims_pcu *pcu = context;\r\nint error;\r\nif (!fw) {\r\ndev_err(pcu->dev, "Failed to get firmware %s\n",\r\nIMS_PCU_FIRMWARE_NAME);\r\ngoto out;\r\n}\r\nerror = ihex_validate_fw(fw);\r\nif (error) {\r\ndev_err(pcu->dev, "Firmware %s is invalid\n",\r\nIMS_PCU_FIRMWARE_NAME);\r\ngoto out;\r\n}\r\nmutex_lock(&pcu->cmd_mutex);\r\nims_pcu_handle_firmware_update(pcu, fw);\r\nmutex_unlock(&pcu->cmd_mutex);\r\nrelease_firmware(fw);\r\nout:\r\ncomplete(&pcu->async_firmware_done);\r\n}\r\nstatic void ims_pcu_backlight_work(struct work_struct *work)\r\n{\r\nstruct ims_pcu_backlight *backlight =\r\ncontainer_of(work, struct ims_pcu_backlight, work);\r\nstruct ims_pcu *pcu =\r\ncontainer_of(backlight, struct ims_pcu, backlight);\r\nint desired_brightness = backlight->desired_brightness;\r\n__le16 br_val = cpu_to_le16(desired_brightness);\r\nint error;\r\nmutex_lock(&pcu->cmd_mutex);\r\nerror = ims_pcu_execute_command(pcu, SET_BRIGHTNESS,\r\n&br_val, sizeof(br_val));\r\nif (error && error != -ENODEV)\r\ndev_warn(pcu->dev,\r\n"Failed to set desired brightness %u, error: %d\n",\r\ndesired_brightness, error);\r\nmutex_unlock(&pcu->cmd_mutex);\r\n}\r\nstatic void ims_pcu_backlight_set_brightness(struct led_classdev *cdev,\r\nenum led_brightness value)\r\n{\r\nstruct ims_pcu_backlight *backlight =\r\ncontainer_of(cdev, struct ims_pcu_backlight, cdev);\r\nbacklight->desired_brightness = value;\r\nschedule_work(&backlight->work);\r\n}\r\nstatic enum led_brightness\r\nims_pcu_backlight_get_brightness(struct led_classdev *cdev)\r\n{\r\nstruct ims_pcu_backlight *backlight =\r\ncontainer_of(cdev, struct ims_pcu_backlight, cdev);\r\nstruct ims_pcu *pcu =\r\ncontainer_of(backlight, struct ims_pcu, backlight);\r\nint brightness;\r\nint error;\r\nmutex_lock(&pcu->cmd_mutex);\r\nerror = ims_pcu_execute_query(pcu, GET_BRIGHTNESS);\r\nif (error) {\r\ndev_warn(pcu->dev,\r\n"Failed to get current brightness, error: %d\n",\r\nerror);\r\nbrightness = LED_OFF;\r\n} else {\r\nbrightness =\r\nget_unaligned_le16(&pcu->cmd_buf[IMS_PCU_DATA_OFFSET]);\r\n}\r\nmutex_unlock(&pcu->cmd_mutex);\r\nreturn brightness;\r\n}\r\nstatic int ims_pcu_setup_backlight(struct ims_pcu *pcu)\r\n{\r\nstruct ims_pcu_backlight *backlight = &pcu->backlight;\r\nint error;\r\nINIT_WORK(&backlight->work, ims_pcu_backlight_work);\r\nsnprintf(backlight->name, sizeof(backlight->name),\r\n"pcu%d::kbd_backlight", pcu->device_no);\r\nbacklight->cdev.name = backlight->name;\r\nbacklight->cdev.max_brightness = IMS_PCU_MAX_BRIGHTNESS;\r\nbacklight->cdev.brightness_get = ims_pcu_backlight_get_brightness;\r\nbacklight->cdev.brightness_set = ims_pcu_backlight_set_brightness;\r\nerror = led_classdev_register(pcu->dev, &backlight->cdev);\r\nif (error) {\r\ndev_err(pcu->dev,\r\n"Failed to register backlight LED device, error: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ims_pcu_destroy_backlight(struct ims_pcu *pcu)\r\n{\r\nstruct ims_pcu_backlight *backlight = &pcu->backlight;\r\nled_classdev_unregister(&backlight->cdev);\r\ncancel_work_sync(&backlight->work);\r\n}\r\nstatic ssize_t ims_pcu_attribute_show(struct device *dev,\r\nstruct device_attribute *dattr,\r\nchar *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct ims_pcu *pcu = usb_get_intfdata(intf);\r\nstruct ims_pcu_attribute *attr =\r\ncontainer_of(dattr, struct ims_pcu_attribute, dattr);\r\nchar *field = (char *)pcu + attr->field_offset;\r\nreturn scnprintf(buf, PAGE_SIZE, "%.*s\n", attr->field_length, field);\r\n}\r\nstatic ssize_t ims_pcu_attribute_store(struct device *dev,\r\nstruct device_attribute *dattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct ims_pcu *pcu = usb_get_intfdata(intf);\r\nstruct ims_pcu_attribute *attr =\r\ncontainer_of(dattr, struct ims_pcu_attribute, dattr);\r\nchar *field = (char *)pcu + attr->field_offset;\r\nsize_t data_len;\r\nint error;\r\nif (count > attr->field_length)\r\nreturn -EINVAL;\r\ndata_len = strnlen(buf, attr->field_length);\r\nif (data_len > attr->field_length)\r\nreturn -EINVAL;\r\nerror = mutex_lock_interruptible(&pcu->cmd_mutex);\r\nif (error)\r\nreturn error;\r\nmemset(field, 0, attr->field_length);\r\nmemcpy(field, buf, data_len);\r\nerror = ims_pcu_set_info(pcu);\r\nims_pcu_get_info(pcu);\r\nmutex_unlock(&pcu->cmd_mutex);\r\nreturn error < 0 ? error : count;\r\n}\r\nstatic ssize_t ims_pcu_reset_device(struct device *dev,\r\nstruct device_attribute *dattr,\r\nconst char *buf, size_t count)\r\n{\r\nstatic const u8 reset_byte = 1;\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct ims_pcu *pcu = usb_get_intfdata(intf);\r\nint value;\r\nint error;\r\nerror = kstrtoint(buf, 0, &value);\r\nif (error)\r\nreturn error;\r\nif (value != 1)\r\nreturn -EINVAL;\r\ndev_info(pcu->dev, "Attempting to reset device\n");\r\nerror = ims_pcu_execute_command(pcu, PCU_RESET, &reset_byte, 1);\r\nif (error) {\r\ndev_info(pcu->dev,\r\n"Failed to reset device, error: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t ims_pcu_update_firmware_store(struct device *dev,\r\nstruct device_attribute *dattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct ims_pcu *pcu = usb_get_intfdata(intf);\r\nconst struct firmware *fw = NULL;\r\nint value;\r\nint error;\r\nerror = kstrtoint(buf, 0, &value);\r\nif (error)\r\nreturn error;\r\nif (value != 1)\r\nreturn -EINVAL;\r\nerror = mutex_lock_interruptible(&pcu->cmd_mutex);\r\nif (error)\r\nreturn error;\r\nerror = request_ihex_firmware(&fw, IMS_PCU_FIRMWARE_NAME, pcu->dev);\r\nif (error) {\r\ndev_err(pcu->dev, "Failed to request firmware %s, error: %d\n",\r\nIMS_PCU_FIRMWARE_NAME, error);\r\ngoto out;\r\n}\r\nif (pcu->bootloader_mode)\r\nerror = ims_pcu_handle_firmware_update(pcu, fw);\r\nelse\r\nerror = ims_pcu_switch_to_bootloader(pcu);\r\nrelease_firmware(fw);\r\nout:\r\nmutex_unlock(&pcu->cmd_mutex);\r\nreturn error ?: count;\r\n}\r\nstatic ssize_t\r\nims_pcu_update_firmware_status_show(struct device *dev,\r\nstruct device_attribute *dattr,\r\nchar *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct ims_pcu *pcu = usb_get_intfdata(intf);\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", pcu->update_firmware_status);\r\n}\r\nstatic umode_t ims_pcu_is_attr_visible(struct kobject *kobj,\r\nstruct attribute *attr, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct ims_pcu *pcu = usb_get_intfdata(intf);\r\numode_t mode = attr->mode;\r\nif (pcu->bootloader_mode) {\r\nif (attr != &dev_attr_update_firmware_status.attr &&\r\nattr != &dev_attr_update_firmware.attr &&\r\nattr != &dev_attr_reset_device.attr) {\r\nmode = 0;\r\n}\r\n} else {\r\nif (attr == &dev_attr_update_firmware_status.attr)\r\nmode = 0;\r\n}\r\nreturn mode;\r\n}\r\nstatic int ims_pcu_read_ofn_config(struct ims_pcu *pcu, u8 addr, u8 *data)\r\n{\r\nint error;\r\ns16 result;\r\nerror = ims_pcu_execute_command(pcu, OFN_GET_CONFIG,\r\n&addr, sizeof(addr));\r\nif (error)\r\nreturn error;\r\nresult = (s16)get_unaligned_le16(pcu->cmd_buf + OFN_REG_RESULT_OFFSET);\r\nif (result < 0)\r\nreturn -EIO;\r\n*data = pcu->cmd_buf[OFN_REG_RESULT_OFFSET];\r\nreturn 0;\r\n}\r\nstatic int ims_pcu_write_ofn_config(struct ims_pcu *pcu, u8 addr, u8 data)\r\n{\r\nu8 buffer[] = { addr, data };\r\nint error;\r\ns16 result;\r\nerror = ims_pcu_execute_command(pcu, OFN_SET_CONFIG,\r\n&buffer, sizeof(buffer));\r\nif (error)\r\nreturn error;\r\nresult = (s16)get_unaligned_le16(pcu->cmd_buf + OFN_REG_RESULT_OFFSET);\r\nif (result < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic ssize_t ims_pcu_ofn_reg_data_show(struct device *dev,\r\nstruct device_attribute *dattr,\r\nchar *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct ims_pcu *pcu = usb_get_intfdata(intf);\r\nint error;\r\nu8 data;\r\nmutex_lock(&pcu->cmd_mutex);\r\nerror = ims_pcu_read_ofn_config(pcu, pcu->ofn_reg_addr, &data);\r\nmutex_unlock(&pcu->cmd_mutex);\r\nif (error)\r\nreturn error;\r\nreturn scnprintf(buf, PAGE_SIZE, "%x\n", data);\r\n}\r\nstatic ssize_t ims_pcu_ofn_reg_data_store(struct device *dev,\r\nstruct device_attribute *dattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct ims_pcu *pcu = usb_get_intfdata(intf);\r\nint error;\r\nu8 value;\r\nerror = kstrtou8(buf, 0, &value);\r\nif (error)\r\nreturn error;\r\nmutex_lock(&pcu->cmd_mutex);\r\nerror = ims_pcu_write_ofn_config(pcu, pcu->ofn_reg_addr, value);\r\nmutex_unlock(&pcu->cmd_mutex);\r\nreturn error ?: count;\r\n}\r\nstatic ssize_t ims_pcu_ofn_reg_addr_show(struct device *dev,\r\nstruct device_attribute *dattr,\r\nchar *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct ims_pcu *pcu = usb_get_intfdata(intf);\r\nint error;\r\nmutex_lock(&pcu->cmd_mutex);\r\nerror = scnprintf(buf, PAGE_SIZE, "%x\n", pcu->ofn_reg_addr);\r\nmutex_unlock(&pcu->cmd_mutex);\r\nreturn error;\r\n}\r\nstatic ssize_t ims_pcu_ofn_reg_addr_store(struct device *dev,\r\nstruct device_attribute *dattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct ims_pcu *pcu = usb_get_intfdata(intf);\r\nint error;\r\nu8 value;\r\nerror = kstrtou8(buf, 0, &value);\r\nif (error)\r\nreturn error;\r\nmutex_lock(&pcu->cmd_mutex);\r\npcu->ofn_reg_addr = value;\r\nmutex_unlock(&pcu->cmd_mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t ims_pcu_ofn_bit_show(struct device *dev,\r\nstruct device_attribute *dattr,\r\nchar *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct ims_pcu *pcu = usb_get_intfdata(intf);\r\nstruct ims_pcu_ofn_bit_attribute *attr =\r\ncontainer_of(dattr, struct ims_pcu_ofn_bit_attribute, dattr);\r\nint error;\r\nu8 data;\r\nmutex_lock(&pcu->cmd_mutex);\r\nerror = ims_pcu_read_ofn_config(pcu, attr->addr, &data);\r\nmutex_unlock(&pcu->cmd_mutex);\r\nif (error)\r\nreturn error;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", !!(data & (1 << attr->nr)));\r\n}\r\nstatic ssize_t ims_pcu_ofn_bit_store(struct device *dev,\r\nstruct device_attribute *dattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct ims_pcu *pcu = usb_get_intfdata(intf);\r\nstruct ims_pcu_ofn_bit_attribute *attr =\r\ncontainer_of(dattr, struct ims_pcu_ofn_bit_attribute, dattr);\r\nint error;\r\nint value;\r\nu8 data;\r\nerror = kstrtoint(buf, 0, &value);\r\nif (error)\r\nreturn error;\r\nif (value > 1)\r\nreturn -EINVAL;\r\nmutex_lock(&pcu->cmd_mutex);\r\nerror = ims_pcu_read_ofn_config(pcu, attr->addr, &data);\r\nif (!error) {\r\nif (value)\r\ndata |= 1U << attr->nr;\r\nelse\r\ndata &= ~(1U << attr->nr);\r\nerror = ims_pcu_write_ofn_config(pcu, attr->addr, data);\r\n}\r\nmutex_unlock(&pcu->cmd_mutex);\r\nreturn error ?: count;\r\n}\r\nstatic void ims_pcu_irq(struct urb *urb)\r\n{\r\nstruct ims_pcu *pcu = urb->context;\r\nint retval, status;\r\nstatus = urb->status;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(pcu->dev, "%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(pcu->dev, "%s - nonzero urb status received: %d\n",\r\n__func__, status);\r\ngoto exit;\r\n}\r\ndev_dbg(pcu->dev, "%s: received %d: %*ph\n", __func__,\r\nurb->actual_length, urb->actual_length, pcu->urb_in_buf);\r\nif (urb == pcu->urb_in)\r\nims_pcu_process_data(pcu, urb);\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval && retval != -ENODEV)\r\ndev_err(pcu->dev, "%s - usb_submit_urb failed with result %d\n",\r\n__func__, retval);\r\n}\r\nstatic int ims_pcu_buffers_alloc(struct ims_pcu *pcu)\r\n{\r\nint error;\r\npcu->urb_in_buf = usb_alloc_coherent(pcu->udev, pcu->max_in_size,\r\nGFP_KERNEL, &pcu->read_dma);\r\nif (!pcu->urb_in_buf) {\r\ndev_err(pcu->dev,\r\n"Failed to allocate memory for read buffer\n");\r\nreturn -ENOMEM;\r\n}\r\npcu->urb_in = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!pcu->urb_in) {\r\ndev_err(pcu->dev, "Failed to allocate input URB\n");\r\nerror = -ENOMEM;\r\ngoto err_free_urb_in_buf;\r\n}\r\npcu->urb_in->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\npcu->urb_in->transfer_dma = pcu->read_dma;\r\nusb_fill_bulk_urb(pcu->urb_in, pcu->udev,\r\nusb_rcvbulkpipe(pcu->udev,\r\npcu->ep_in->bEndpointAddress),\r\npcu->urb_in_buf, pcu->max_in_size,\r\nims_pcu_irq, pcu);\r\npcu->urb_out_buf = kmalloc(pcu->max_out_size, GFP_KERNEL);\r\nif (!pcu->urb_out_buf) {\r\ndev_err(pcu->dev, "Failed to allocate memory for write buffer\n");\r\nerror = -ENOMEM;\r\ngoto err_free_in_urb;\r\n}\r\npcu->urb_ctrl_buf = usb_alloc_coherent(pcu->udev, pcu->max_ctrl_size,\r\nGFP_KERNEL, &pcu->ctrl_dma);\r\nif (!pcu->urb_ctrl_buf) {\r\ndev_err(pcu->dev,\r\n"Failed to allocate memory for read buffer\n");\r\nerror = -ENOMEM;\r\ngoto err_free_urb_out_buf;\r\n}\r\npcu->urb_ctrl = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!pcu->urb_ctrl) {\r\ndev_err(pcu->dev, "Failed to allocate input URB\n");\r\nerror = -ENOMEM;\r\ngoto err_free_urb_ctrl_buf;\r\n}\r\npcu->urb_ctrl->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\npcu->urb_ctrl->transfer_dma = pcu->ctrl_dma;\r\nusb_fill_int_urb(pcu->urb_ctrl, pcu->udev,\r\nusb_rcvintpipe(pcu->udev,\r\npcu->ep_ctrl->bEndpointAddress),\r\npcu->urb_ctrl_buf, pcu->max_ctrl_size,\r\nims_pcu_irq, pcu, pcu->ep_ctrl->bInterval);\r\nreturn 0;\r\nerr_free_urb_ctrl_buf:\r\nusb_free_coherent(pcu->udev, pcu->max_ctrl_size,\r\npcu->urb_ctrl_buf, pcu->ctrl_dma);\r\nerr_free_urb_out_buf:\r\nkfree(pcu->urb_out_buf);\r\nerr_free_in_urb:\r\nusb_free_urb(pcu->urb_in);\r\nerr_free_urb_in_buf:\r\nusb_free_coherent(pcu->udev, pcu->max_in_size,\r\npcu->urb_in_buf, pcu->read_dma);\r\nreturn error;\r\n}\r\nstatic void ims_pcu_buffers_free(struct ims_pcu *pcu)\r\n{\r\nusb_kill_urb(pcu->urb_in);\r\nusb_free_urb(pcu->urb_in);\r\nusb_free_coherent(pcu->udev, pcu->max_out_size,\r\npcu->urb_in_buf, pcu->read_dma);\r\nkfree(pcu->urb_out_buf);\r\nusb_kill_urb(pcu->urb_ctrl);\r\nusb_free_urb(pcu->urb_ctrl);\r\nusb_free_coherent(pcu->udev, pcu->max_ctrl_size,\r\npcu->urb_ctrl_buf, pcu->ctrl_dma);\r\n}\r\nstatic const struct usb_cdc_union_desc *\r\nims_pcu_get_cdc_union_desc(struct usb_interface *intf)\r\n{\r\nconst void *buf = intf->altsetting->extra;\r\nsize_t buflen = intf->altsetting->extralen;\r\nstruct usb_cdc_union_desc *union_desc;\r\nif (!buf) {\r\ndev_err(&intf->dev, "Missing descriptor data\n");\r\nreturn NULL;\r\n}\r\nif (!buflen) {\r\ndev_err(&intf->dev, "Zero length descriptor\n");\r\nreturn NULL;\r\n}\r\nwhile (buflen > 0) {\r\nunion_desc = (struct usb_cdc_union_desc *)buf;\r\nif (union_desc->bDescriptorType == USB_DT_CS_INTERFACE &&\r\nunion_desc->bDescriptorSubType == USB_CDC_UNION_TYPE) {\r\ndev_dbg(&intf->dev, "Found union header\n");\r\nreturn union_desc;\r\n}\r\nbuflen -= union_desc->bLength;\r\nbuf += union_desc->bLength;\r\n}\r\ndev_err(&intf->dev, "Missing CDC union descriptor\n");\r\nreturn NULL;\r\n}\r\nstatic int ims_pcu_parse_cdc_data(struct usb_interface *intf, struct ims_pcu *pcu)\r\n{\r\nconst struct usb_cdc_union_desc *union_desc;\r\nstruct usb_host_interface *alt;\r\nunion_desc = ims_pcu_get_cdc_union_desc(intf);\r\nif (!union_desc)\r\nreturn -EINVAL;\r\npcu->ctrl_intf = usb_ifnum_to_if(pcu->udev,\r\nunion_desc->bMasterInterface0);\r\nalt = pcu->ctrl_intf->cur_altsetting;\r\npcu->ep_ctrl = &alt->endpoint[0].desc;\r\npcu->max_ctrl_size = usb_endpoint_maxp(pcu->ep_ctrl);\r\npcu->data_intf = usb_ifnum_to_if(pcu->udev,\r\nunion_desc->bSlaveInterface0);\r\nalt = pcu->data_intf->cur_altsetting;\r\nif (alt->desc.bNumEndpoints != 2) {\r\ndev_err(pcu->dev,\r\n"Incorrect number of endpoints on data interface (%d)\n",\r\nalt->desc.bNumEndpoints);\r\nreturn -EINVAL;\r\n}\r\npcu->ep_out = &alt->endpoint[0].desc;\r\nif (!usb_endpoint_is_bulk_out(pcu->ep_out)) {\r\ndev_err(pcu->dev,\r\n"First endpoint on data interface is not BULK OUT\n");\r\nreturn -EINVAL;\r\n}\r\npcu->max_out_size = usb_endpoint_maxp(pcu->ep_out);\r\nif (pcu->max_out_size < 8) {\r\ndev_err(pcu->dev,\r\n"Max OUT packet size is too small (%zd)\n",\r\npcu->max_out_size);\r\nreturn -EINVAL;\r\n}\r\npcu->ep_in = &alt->endpoint[1].desc;\r\nif (!usb_endpoint_is_bulk_in(pcu->ep_in)) {\r\ndev_err(pcu->dev,\r\n"Second endpoint on data interface is not BULK IN\n");\r\nreturn -EINVAL;\r\n}\r\npcu->max_in_size = usb_endpoint_maxp(pcu->ep_in);\r\nif (pcu->max_in_size < 8) {\r\ndev_err(pcu->dev,\r\n"Max IN packet size is too small (%zd)\n",\r\npcu->max_in_size);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ims_pcu_start_io(struct ims_pcu *pcu)\r\n{\r\nint error;\r\nerror = usb_submit_urb(pcu->urb_ctrl, GFP_KERNEL);\r\nif (error) {\r\ndev_err(pcu->dev,\r\n"Failed to start control IO - usb_submit_urb failed with result: %d\n",\r\nerror);\r\nreturn -EIO;\r\n}\r\nerror = usb_submit_urb(pcu->urb_in, GFP_KERNEL);\r\nif (error) {\r\ndev_err(pcu->dev,\r\n"Failed to start IO - usb_submit_urb failed with result: %d\n",\r\nerror);\r\nusb_kill_urb(pcu->urb_ctrl);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ims_pcu_stop_io(struct ims_pcu *pcu)\r\n{\r\nusb_kill_urb(pcu->urb_in);\r\nusb_kill_urb(pcu->urb_ctrl);\r\n}\r\nstatic int ims_pcu_line_setup(struct ims_pcu *pcu)\r\n{\r\nstruct usb_host_interface *interface = pcu->ctrl_intf->cur_altsetting;\r\nstruct usb_cdc_line_coding *line = (void *)pcu->cmd_buf;\r\nint error;\r\nmemset(line, 0, sizeof(*line));\r\nline->dwDTERate = cpu_to_le32(57600);\r\nline->bDataBits = 8;\r\nerror = usb_control_msg(pcu->udev, usb_sndctrlpipe(pcu->udev, 0),\r\nUSB_CDC_REQ_SET_LINE_CODING,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, interface->desc.bInterfaceNumber,\r\nline, sizeof(struct usb_cdc_line_coding),\r\n5000);\r\nif (error < 0) {\r\ndev_err(pcu->dev, "Failed to set line coding, error: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = usb_control_msg(pcu->udev, usb_sndctrlpipe(pcu->udev, 0),\r\nUSB_CDC_REQ_SET_CONTROL_LINE_STATE,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0x03, interface->desc.bInterfaceNumber,\r\nNULL, 0, 5000);\r\nif (error < 0) {\r\ndev_err(pcu->dev, "Failed to set line state, error: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ims_pcu_get_device_info(struct ims_pcu *pcu)\r\n{\r\nint error;\r\nerror = ims_pcu_get_info(pcu);\r\nif (error)\r\nreturn error;\r\nerror = ims_pcu_execute_query(pcu, GET_FW_VERSION);\r\nif (error) {\r\ndev_err(pcu->dev,\r\n"GET_FW_VERSION command failed, error: %d\n", error);\r\nreturn error;\r\n}\r\nsnprintf(pcu->fw_version, sizeof(pcu->fw_version),\r\n"%02d%02d%02d%02d.%c%c",\r\npcu->cmd_buf[2], pcu->cmd_buf[3], pcu->cmd_buf[4], pcu->cmd_buf[5],\r\npcu->cmd_buf[6], pcu->cmd_buf[7]);\r\nerror = ims_pcu_execute_query(pcu, GET_BL_VERSION);\r\nif (error) {\r\ndev_err(pcu->dev,\r\n"GET_BL_VERSION command failed, error: %d\n", error);\r\nreturn error;\r\n}\r\nsnprintf(pcu->bl_version, sizeof(pcu->bl_version),\r\n"%02d%02d%02d%02d.%c%c",\r\npcu->cmd_buf[2], pcu->cmd_buf[3], pcu->cmd_buf[4], pcu->cmd_buf[5],\r\npcu->cmd_buf[6], pcu->cmd_buf[7]);\r\nerror = ims_pcu_execute_query(pcu, RESET_REASON);\r\nif (error) {\r\ndev_err(pcu->dev,\r\n"RESET_REASON command failed, error: %d\n", error);\r\nreturn error;\r\n}\r\nsnprintf(pcu->reset_reason, sizeof(pcu->reset_reason),\r\n"%02x", pcu->cmd_buf[IMS_PCU_DATA_OFFSET]);\r\ndev_dbg(pcu->dev,\r\n"P/N: %s, MD: %s, S/N: %s, FW: %s, BL: %s, RR: %s\n",\r\npcu->part_number,\r\npcu->date_of_manufacturing,\r\npcu->serial_number,\r\npcu->fw_version,\r\npcu->bl_version,\r\npcu->reset_reason);\r\nreturn 0;\r\n}\r\nstatic int ims_pcu_identify_type(struct ims_pcu *pcu, u8 *device_id)\r\n{\r\nint error;\r\nerror = ims_pcu_execute_query(pcu, GET_DEVICE_ID);\r\nif (error) {\r\ndev_err(pcu->dev,\r\n"GET_DEVICE_ID command failed, error: %d\n", error);\r\nreturn error;\r\n}\r\n*device_id = pcu->cmd_buf[IMS_PCU_DATA_OFFSET];\r\ndev_dbg(pcu->dev, "Detected device ID: %d\n", *device_id);\r\nreturn 0;\r\n}\r\nstatic int ims_pcu_init_application_mode(struct ims_pcu *pcu)\r\n{\r\nstatic atomic_t device_no = ATOMIC_INIT(-1);\r\nconst struct ims_pcu_device_info *info;\r\nint error;\r\nerror = ims_pcu_get_device_info(pcu);\r\nif (error) {\r\nreturn error;\r\n}\r\nerror = ims_pcu_identify_type(pcu, &pcu->device_id);\r\nif (error) {\r\ndev_err(pcu->dev,\r\n"Failed to identify device, error: %d\n", error);\r\nreturn 0;\r\n}\r\nif (pcu->device_id >= ARRAY_SIZE(ims_pcu_device_info) ||\r\n!ims_pcu_device_info[pcu->device_id].keymap) {\r\ndev_err(pcu->dev, "Device ID %d is not valid\n", pcu->device_id);\r\nreturn 0;\r\n}\r\npcu->device_no = atomic_inc_return(&device_no);\r\nif (pcu->device_id != IMS_PCU_PCU_B_DEVICE_ID) {\r\nerror = sysfs_create_group(&pcu->dev->kobj,\r\n&ims_pcu_ofn_attr_group);\r\nif (error)\r\nreturn error;\r\n}\r\nerror = ims_pcu_setup_backlight(pcu);\r\nif (error)\r\nreturn error;\r\ninfo = &ims_pcu_device_info[pcu->device_id];\r\nerror = ims_pcu_setup_buttons(pcu, info->keymap, info->keymap_len);\r\nif (error)\r\ngoto err_destroy_backlight;\r\nif (info->has_gamepad) {\r\nerror = ims_pcu_setup_gamepad(pcu);\r\nif (error)\r\ngoto err_destroy_buttons;\r\n}\r\npcu->setup_complete = true;\r\nreturn 0;\r\nerr_destroy_buttons:\r\nims_pcu_destroy_buttons(pcu);\r\nerr_destroy_backlight:\r\nims_pcu_destroy_backlight(pcu);\r\nreturn error;\r\n}\r\nstatic void ims_pcu_destroy_application_mode(struct ims_pcu *pcu)\r\n{\r\nif (pcu->setup_complete) {\r\npcu->setup_complete = false;\r\nmb();\r\nif (pcu->gamepad)\r\nims_pcu_destroy_gamepad(pcu);\r\nims_pcu_destroy_buttons(pcu);\r\nims_pcu_destroy_backlight(pcu);\r\nif (pcu->device_id != IMS_PCU_PCU_B_DEVICE_ID)\r\nsysfs_remove_group(&pcu->dev->kobj,\r\n&ims_pcu_ofn_attr_group);\r\n}\r\n}\r\nstatic int ims_pcu_init_bootloader_mode(struct ims_pcu *pcu)\r\n{\r\nint error;\r\nerror = ims_pcu_execute_bl_command(pcu, QUERY_DEVICE, NULL, 0,\r\nIMS_PCU_CMD_RESPONSE_TIMEOUT);\r\nif (error) {\r\ndev_err(pcu->dev, "Bootloader does not respond, aborting\n");\r\nreturn error;\r\n}\r\npcu->fw_start_addr =\r\nget_unaligned_le32(&pcu->cmd_buf[IMS_PCU_DATA_OFFSET + 11]);\r\npcu->fw_end_addr =\r\nget_unaligned_le32(&pcu->cmd_buf[IMS_PCU_DATA_OFFSET + 15]);\r\ndev_info(pcu->dev,\r\n"Device is in bootloader mode (addr 0x%08x-0x%08x), requesting firmware\n",\r\npcu->fw_start_addr, pcu->fw_end_addr);\r\nerror = request_firmware_nowait(THIS_MODULE, true,\r\nIMS_PCU_FIRMWARE_NAME,\r\npcu->dev, GFP_KERNEL, pcu,\r\nims_pcu_process_async_firmware);\r\nif (error) {\r\ncomplete(&pcu->async_firmware_done);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ims_pcu_destroy_bootloader_mode(struct ims_pcu *pcu)\r\n{\r\nwait_for_completion(&pcu->async_firmware_done);\r\n}\r\nstatic int ims_pcu_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct ims_pcu *pcu;\r\nint error;\r\npcu = kzalloc(sizeof(struct ims_pcu), GFP_KERNEL);\r\nif (!pcu)\r\nreturn -ENOMEM;\r\npcu->dev = &intf->dev;\r\npcu->udev = udev;\r\npcu->bootloader_mode = id->driver_info == IMS_PCU_BOOTLOADER_MODE;\r\nmutex_init(&pcu->cmd_mutex);\r\ninit_completion(&pcu->cmd_done);\r\ninit_completion(&pcu->async_firmware_done);\r\nerror = ims_pcu_parse_cdc_data(intf, pcu);\r\nif (error)\r\ngoto err_free_mem;\r\nerror = usb_driver_claim_interface(&ims_pcu_driver,\r\npcu->data_intf, pcu);\r\nif (error) {\r\ndev_err(&intf->dev,\r\n"Unable to claim corresponding data interface: %d\n",\r\nerror);\r\ngoto err_free_mem;\r\n}\r\nusb_set_intfdata(pcu->ctrl_intf, pcu);\r\nusb_set_intfdata(pcu->data_intf, pcu);\r\nerror = ims_pcu_buffers_alloc(pcu);\r\nif (error)\r\ngoto err_unclaim_intf;\r\nerror = ims_pcu_start_io(pcu);\r\nif (error)\r\ngoto err_free_buffers;\r\nerror = ims_pcu_line_setup(pcu);\r\nif (error)\r\ngoto err_stop_io;\r\nerror = sysfs_create_group(&intf->dev.kobj, &ims_pcu_attr_group);\r\nif (error)\r\ngoto err_stop_io;\r\nerror = pcu->bootloader_mode ?\r\nims_pcu_init_bootloader_mode(pcu) :\r\nims_pcu_init_application_mode(pcu);\r\nif (error)\r\ngoto err_remove_sysfs;\r\nreturn 0;\r\nerr_remove_sysfs:\r\nsysfs_remove_group(&intf->dev.kobj, &ims_pcu_attr_group);\r\nerr_stop_io:\r\nims_pcu_stop_io(pcu);\r\nerr_free_buffers:\r\nims_pcu_buffers_free(pcu);\r\nerr_unclaim_intf:\r\nusb_driver_release_interface(&ims_pcu_driver, pcu->data_intf);\r\nerr_free_mem:\r\nkfree(pcu);\r\nreturn error;\r\n}\r\nstatic void ims_pcu_disconnect(struct usb_interface *intf)\r\n{\r\nstruct ims_pcu *pcu = usb_get_intfdata(intf);\r\nstruct usb_host_interface *alt = intf->cur_altsetting;\r\nusb_set_intfdata(intf, NULL);\r\nif (alt->desc.bInterfaceClass != USB_CLASS_COMM)\r\nreturn;\r\nsysfs_remove_group(&intf->dev.kobj, &ims_pcu_attr_group);\r\nims_pcu_stop_io(pcu);\r\nif (pcu->bootloader_mode)\r\nims_pcu_destroy_bootloader_mode(pcu);\r\nelse\r\nims_pcu_destroy_application_mode(pcu);\r\nims_pcu_buffers_free(pcu);\r\nkfree(pcu);\r\n}\r\nstatic int ims_pcu_suspend(struct usb_interface *intf,\r\npm_message_t message)\r\n{\r\nstruct ims_pcu *pcu = usb_get_intfdata(intf);\r\nstruct usb_host_interface *alt = intf->cur_altsetting;\r\nif (alt->desc.bInterfaceClass == USB_CLASS_COMM)\r\nims_pcu_stop_io(pcu);\r\nreturn 0;\r\n}\r\nstatic int ims_pcu_resume(struct usb_interface *intf)\r\n{\r\nstruct ims_pcu *pcu = usb_get_intfdata(intf);\r\nstruct usb_host_interface *alt = intf->cur_altsetting;\r\nint retval = 0;\r\nif (alt->desc.bInterfaceClass == USB_CLASS_COMM) {\r\nretval = ims_pcu_start_io(pcu);\r\nif (retval == 0)\r\nretval = ims_pcu_line_setup(pcu);\r\n}\r\nreturn retval;\r\n}
