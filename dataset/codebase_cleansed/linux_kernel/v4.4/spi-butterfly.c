static inline struct butterfly *spidev_to_pp(struct spi_device *spi)\r\n{\r\nreturn spi->controller_data;\r\n}\r\nstatic inline void\r\nsetsck(struct spi_device *spi, int is_on)\r\n{\r\nstruct butterfly *pp = spidev_to_pp(spi);\r\nu8 bit, byte = pp->lastbyte;\r\nbit = spi_sck_bit;\r\nif (is_on)\r\nbyte |= bit;\r\nelse\r\nbyte &= ~bit;\r\nparport_write_data(pp->port, byte);\r\npp->lastbyte = byte;\r\n}\r\nstatic inline void\r\nsetmosi(struct spi_device *spi, int is_on)\r\n{\r\nstruct butterfly *pp = spidev_to_pp(spi);\r\nu8 bit, byte = pp->lastbyte;\r\nbit = spi_mosi_bit;\r\nif (is_on)\r\nbyte |= bit;\r\nelse\r\nbyte &= ~bit;\r\nparport_write_data(pp->port, byte);\r\npp->lastbyte = byte;\r\n}\r\nstatic inline int getmiso(struct spi_device *spi)\r\n{\r\nstruct butterfly *pp = spidev_to_pp(spi);\r\nint value;\r\nu8 bit;\r\nbit = spi_miso_bit;\r\nvalue = !(parport_read_status(pp->port) & bit);\r\nreturn (bit == PARPORT_STATUS_BUSY) ? value : !value;\r\n}\r\nstatic void butterfly_chipselect(struct spi_device *spi, int value)\r\n{\r\nstruct butterfly *pp = spidev_to_pp(spi);\r\nif (value != BITBANG_CS_INACTIVE)\r\nsetsck(spi, spi->mode & SPI_CPOL);\r\nif (spi_cs_bit == PARPORT_CONTROL_INIT)\r\nvalue = !value;\r\nparport_frob_control(pp->port, spi_cs_bit, value ? spi_cs_bit : 0);\r\n}\r\nstatic u32\r\nbutterfly_txrx_word_mode0(struct spi_device *spi,\r\nunsigned nsecs,\r\nu32 word, u8 bits)\r\n{\r\nreturn bitbang_txrx_be_cpha0(spi, nsecs, 0, 0, word, bits);\r\n}\r\nstatic void butterfly_attach(struct parport *p)\r\n{\r\nstruct pardevice *pd;\r\nint status;\r\nstruct butterfly *pp;\r\nstruct spi_master *master;\r\nstruct device *dev = p->physport->dev;\r\nif (butterfly || !dev)\r\nreturn;\r\nmaster = spi_alloc_master(dev, sizeof(*pp));\r\nif (!master) {\r\nstatus = -ENOMEM;\r\ngoto done;\r\n}\r\npp = spi_master_get_devdata(master);\r\nmaster->bus_num = 42;\r\nmaster->num_chipselect = 2;\r\npp->bitbang.master = master;\r\npp->bitbang.chipselect = butterfly_chipselect;\r\npp->bitbang.txrx_word[SPI_MODE_0] = butterfly_txrx_word_mode0;\r\npp->port = p;\r\npd = parport_register_device(p, "spi_butterfly",\r\nNULL, NULL, NULL,\r\n0 , pp);\r\nif (!pd) {\r\nstatus = -ENOMEM;\r\ngoto clean0;\r\n}\r\npp->pd = pd;\r\nstatus = parport_claim(pd);\r\nif (status < 0)\r\ngoto clean1;\r\npr_debug("%s: powerup/reset Butterfly\n", p->name);\r\nparport_frob_control(pp->port, spi_cs_bit, 0);\r\npp->lastbyte |= vcc_bits;\r\nparport_write_data(pp->port, pp->lastbyte);\r\nmsleep(5);\r\npp->lastbyte |= butterfly_nreset;\r\nparport_write_data(pp->port, pp->lastbyte);\r\nmsleep(100);\r\nstatus = spi_bitbang_start(&pp->bitbang);\r\nif (status < 0)\r\ngoto clean2;\r\npp->info[0].max_speed_hz = 15 * 1000 * 1000;\r\nstrcpy(pp->info[0].modalias, "mtd_dataflash");\r\npp->info[0].platform_data = &flash;\r\npp->info[0].chip_select = 1;\r\npp->info[0].controller_data = pp;\r\npp->dataflash = spi_new_device(pp->bitbang.master, &pp->info[0]);\r\nif (pp->dataflash)\r\npr_debug("%s: dataflash at %s\n", p->name,\r\ndev_name(&pp->dataflash->dev));\r\npr_info("%s: AVR Butterfly\n", p->name);\r\nbutterfly = pp;\r\nreturn;\r\nclean2:\r\nparport_write_data(pp->port, 0);\r\nparport_release(pp->pd);\r\nclean1:\r\nparport_unregister_device(pd);\r\nclean0:\r\n(void) spi_master_put(pp->bitbang.master);\r\ndone:\r\npr_debug("%s: butterfly probe, fail %d\n", p->name, status);\r\n}\r\nstatic void butterfly_detach(struct parport *p)\r\n{\r\nstruct butterfly *pp;\r\nif (!butterfly || butterfly->port != p)\r\nreturn;\r\npp = butterfly;\r\nbutterfly = NULL;\r\nspi_bitbang_stop(&pp->bitbang);\r\nparport_write_data(pp->port, 0);\r\nmsleep(10);\r\nparport_release(pp->pd);\r\nparport_unregister_device(pp->pd);\r\n(void) spi_master_put(pp->bitbang.master);\r\n}\r\nstatic int __init butterfly_init(void)\r\n{\r\nreturn parport_register_driver(&butterfly_driver);\r\n}\r\nstatic void __exit butterfly_exit(void)\r\n{\r\nparport_unregister_driver(&butterfly_driver);\r\n}
