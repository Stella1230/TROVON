static int uart6850_status(void)\r\n{\r\nreturn inb(STATPORT);\r\n}\r\nstatic void uart6850_cmd(unsigned char cmd)\r\n{\r\noutb(cmd, COMDPORT);\r\n}\r\nstatic int uart6850_read(void)\r\n{\r\nreturn inb(DATAPORT);\r\n}\r\nstatic void uart6850_write(unsigned char byte)\r\n{\r\noutb(byte, DATAPORT);\r\n}\r\nstatic void uart6850_input_loop(void)\r\n{\r\nint count = 10;\r\nwhile (count)\r\n{\r\nif (input_avail())\r\n{\r\nunsigned char c = uart6850_read();\r\ncount = 100;\r\nif (uart6850_opened & OPEN_READ)\r\nmidi_input_intr(my_dev, c);\r\n}\r\nelse\r\n{\r\nwhile (!input_avail() && count)\r\ncount--;\r\n}\r\n}\r\n}\r\nstatic irqreturn_t m6850intr(int irq, void *dev_id)\r\n{\r\nif (input_avail())\r\nuart6850_input_loop();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void poll_uart6850(unsigned long dummy)\r\n{\r\nunsigned long flags;\r\nif (!(uart6850_opened & OPEN_READ))\r\nreturn;\r\nspin_lock_irqsave(&lock,flags);\r\nif (input_avail())\r\nuart6850_input_loop();\r\nuart6850_timer.expires = 1 + jiffies;\r\nadd_timer(&uart6850_timer);\r\nspin_unlock_irqrestore(&lock,flags);\r\n}\r\nstatic int uart6850_open(int dev, int mode,\r\nvoid (*input) (int dev, unsigned char data),\r\nvoid (*output) (int dev)\r\n)\r\n{\r\nif (uart6850_opened)\r\n{\r\nreturn -EBUSY;\r\n}\r\nuart6850_cmd(UART_RESET);\r\nuart6850_input_loop();\r\nmidi_input_intr = input;\r\nuart6850_opened = mode;\r\npoll_uart6850(0);\r\nreturn 0;\r\n}\r\nstatic void uart6850_close(int dev)\r\n{\r\nuart6850_cmd(UART_MODE_ON);\r\ndel_timer(&uart6850_timer);\r\nuart6850_opened = 0;\r\n}\r\nstatic int uart6850_out(int dev, unsigned char midi_byte)\r\n{\r\nint timeout;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lock,flags);\r\nif (input_avail())\r\nuart6850_input_loop();\r\nspin_unlock_irqrestore(&lock,flags);\r\nfor (timeout = 30000; timeout > 0 && !output_ready(); timeout--);\r\nif (!output_ready())\r\n{\r\nprintk(KERN_WARNING "Midi6850: Timeout\n");\r\nreturn 0;\r\n}\r\nuart6850_write(midi_byte);\r\nreturn 1;\r\n}\r\nstatic inline int uart6850_command(int dev, unsigned char *midi_byte)\r\n{\r\nreturn 1;\r\n}\r\nstatic inline int uart6850_start_read(int dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int uart6850_end_read(int dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void uart6850_kick(int dev)\r\n{\r\n}\r\nstatic inline int uart6850_buffer_status(int dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __init attach_uart6850(struct address_info *hw_config)\r\n{\r\nint ok, timeout;\r\nunsigned long flags;\r\nif (!uart6850_detected)\r\nreturn;\r\nif ((my_dev = sound_alloc_mididev()) == -1)\r\n{\r\nprintk(KERN_INFO "uart6850: Too many midi devices detected\n");\r\nreturn;\r\n}\r\nuart6850_base = hw_config->io_base;\r\nuart6850_osp = hw_config->osp;\r\nuart6850_irq = hw_config->irq;\r\nspin_lock_irqsave(&lock,flags);\r\nfor (timeout = 30000; timeout > 0 && !output_ready(); timeout--);\r\nuart6850_cmd(UART_MODE_ON);\r\nok = 1;\r\nspin_unlock_irqrestore(&lock,flags);\r\nconf_printf("6850 Midi Interface", hw_config);\r\nstd_midi_synth.midi_dev = my_dev;\r\nhw_config->slots[4] = my_dev;\r\nmidi_devs[my_dev] = &uart6850_operations;\r\nsequencer_init();\r\n}\r\nstatic inline int reset_uart6850(void)\r\n{\r\nuart6850_read();\r\nreturn 1;\r\n}\r\nstatic int __init probe_uart6850(struct address_info *hw_config)\r\n{\r\nint ok;\r\nuart6850_osp = hw_config->osp;\r\nuart6850_base = hw_config->io_base;\r\nuart6850_irq = hw_config->irq;\r\nif (request_irq(uart6850_irq, m6850intr, 0, "MIDI6850", NULL) < 0)\r\nreturn 0;\r\nok = reset_uart6850();\r\nuart6850_detected = ok;\r\nreturn ok;\r\n}\r\nstatic void __exit unload_uart6850(struct address_info *hw_config)\r\n{\r\nfree_irq(hw_config->irq, NULL);\r\nsound_unload_mididev(hw_config->slots[4]);\r\n}\r\nstatic int __init init_uart6850(void)\r\n{\r\ncfg_mpu.io_base = io;\r\ncfg_mpu.irq = irq;\r\nif (cfg_mpu.io_base == -1 || cfg_mpu.irq == -1) {\r\nprintk(KERN_INFO "uart6850: irq and io must be set.\n");\r\nreturn -EINVAL;\r\n}\r\nif (probe_uart6850(&cfg_mpu))\r\nreturn -ENODEV;\r\nattach_uart6850(&cfg_mpu);\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_uart6850(void)\r\n{\r\nunload_uart6850(&cfg_mpu);\r\n}\r\nstatic int __init setup_uart6850(char *str)\r\n{\r\nint ints[3];\r\nstr = get_options(str, ARRAY_SIZE(ints), ints);\r\nio = ints[1];\r\nirq = ints[2];\r\nreturn 1;\r\n}
