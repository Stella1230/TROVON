static int imx_pwm_config_v1(struct pwm_chip *chip,\r\nstruct pwm_device *pwm, int duty_ns, int period_ns)\r\n{\r\nstruct imx_chip *imx = to_imx_chip(chip);\r\nu32 max = readl(imx->mmio_base + MX1_PWMP);\r\nu32 p = max * duty_ns / period_ns;\r\nwritel(max - p, imx->mmio_base + MX1_PWMS);\r\nreturn 0;\r\n}\r\nstatic void imx_pwm_set_enable_v1(struct pwm_chip *chip, bool enable)\r\n{\r\nstruct imx_chip *imx = to_imx_chip(chip);\r\nu32 val;\r\nval = readl(imx->mmio_base + MX1_PWMC);\r\nif (enable)\r\nval |= MX1_PWMC_EN;\r\nelse\r\nval &= ~MX1_PWMC_EN;\r\nwritel(val, imx->mmio_base + MX1_PWMC);\r\n}\r\nstatic int imx_pwm_config_v2(struct pwm_chip *chip,\r\nstruct pwm_device *pwm, int duty_ns, int period_ns)\r\n{\r\nstruct imx_chip *imx = to_imx_chip(chip);\r\nstruct device *dev = chip->dev;\r\nunsigned long long c;\r\nunsigned long period_cycles, duty_cycles, prescale;\r\nunsigned int period_ms;\r\nbool enable = pwm_is_enabled(pwm);\r\nint wait_count = 0, fifoav;\r\nu32 cr, sr;\r\nif (enable) {\r\nsr = readl(imx->mmio_base + MX3_PWMSR);\r\nfifoav = sr & MX3_PWMSR_FIFOAV_MASK;\r\nif (fifoav == MX3_PWMSR_FIFOAV_4WORDS) {\r\nperiod_ms = DIV_ROUND_UP(pwm_get_period(pwm),\r\nNSEC_PER_MSEC);\r\nmsleep(period_ms);\r\nsr = readl(imx->mmio_base + MX3_PWMSR);\r\nif (fifoav == (sr & MX3_PWMSR_FIFOAV_MASK))\r\ndev_warn(dev, "there is no free FIFO slot\n");\r\n}\r\n} else {\r\nwritel(MX3_PWMCR_SWR, imx->mmio_base + MX3_PWMCR);\r\ndo {\r\nusleep_range(200, 1000);\r\ncr = readl(imx->mmio_base + MX3_PWMCR);\r\n} while ((cr & MX3_PWMCR_SWR) &&\r\n(wait_count++ < MX3_PWM_SWR_LOOP));\r\nif (cr & MX3_PWMCR_SWR)\r\ndev_warn(dev, "software reset timeout\n");\r\n}\r\nc = clk_get_rate(imx->clk_per);\r\nc = c * period_ns;\r\ndo_div(c, 1000000000);\r\nperiod_cycles = c;\r\nprescale = period_cycles / 0x10000 + 1;\r\nperiod_cycles /= prescale;\r\nc = (unsigned long long)period_cycles * duty_ns;\r\ndo_div(c, period_ns);\r\nduty_cycles = c;\r\nif (period_cycles > 2)\r\nperiod_cycles -= 2;\r\nelse\r\nperiod_cycles = 0;\r\nwritel(duty_cycles, imx->mmio_base + MX3_PWMSAR);\r\nwritel(period_cycles, imx->mmio_base + MX3_PWMPR);\r\ncr = MX3_PWMCR_PRESCALER(prescale) |\r\nMX3_PWMCR_DOZEEN | MX3_PWMCR_WAITEN |\r\nMX3_PWMCR_DBGEN | MX3_PWMCR_CLKSRC_IPG_HIGH;\r\nif (enable)\r\ncr |= MX3_PWMCR_EN;\r\nwritel(cr, imx->mmio_base + MX3_PWMCR);\r\nreturn 0;\r\n}\r\nstatic void imx_pwm_set_enable_v2(struct pwm_chip *chip, bool enable)\r\n{\r\nstruct imx_chip *imx = to_imx_chip(chip);\r\nu32 val;\r\nval = readl(imx->mmio_base + MX3_PWMCR);\r\nif (enable)\r\nval |= MX3_PWMCR_EN;\r\nelse\r\nval &= ~MX3_PWMCR_EN;\r\nwritel(val, imx->mmio_base + MX3_PWMCR);\r\n}\r\nstatic int imx_pwm_config(struct pwm_chip *chip,\r\nstruct pwm_device *pwm, int duty_ns, int period_ns)\r\n{\r\nstruct imx_chip *imx = to_imx_chip(chip);\r\nint ret;\r\nret = clk_prepare_enable(imx->clk_ipg);\r\nif (ret)\r\nreturn ret;\r\nret = imx->config(chip, pwm, duty_ns, period_ns);\r\nclk_disable_unprepare(imx->clk_ipg);\r\nreturn ret;\r\n}\r\nstatic int imx_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct imx_chip *imx = to_imx_chip(chip);\r\nint ret;\r\nret = clk_prepare_enable(imx->clk_per);\r\nif (ret)\r\nreturn ret;\r\nimx->set_enable(chip, true);\r\nreturn 0;\r\n}\r\nstatic void imx_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct imx_chip *imx = to_imx_chip(chip);\r\nimx->set_enable(chip, false);\r\nclk_disable_unprepare(imx->clk_per);\r\n}\r\nstatic int imx_pwm_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(imx_pwm_dt_ids, &pdev->dev);\r\nconst struct imx_pwm_data *data;\r\nstruct imx_chip *imx;\r\nstruct resource *r;\r\nint ret = 0;\r\nif (!of_id)\r\nreturn -ENODEV;\r\nimx = devm_kzalloc(&pdev->dev, sizeof(*imx), GFP_KERNEL);\r\nif (imx == NULL)\r\nreturn -ENOMEM;\r\nimx->clk_per = devm_clk_get(&pdev->dev, "per");\r\nif (IS_ERR(imx->clk_per)) {\r\ndev_err(&pdev->dev, "getting per clock failed with %ld\n",\r\nPTR_ERR(imx->clk_per));\r\nreturn PTR_ERR(imx->clk_per);\r\n}\r\nimx->clk_ipg = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(imx->clk_ipg)) {\r\ndev_err(&pdev->dev, "getting ipg clock failed with %ld\n",\r\nPTR_ERR(imx->clk_ipg));\r\nreturn PTR_ERR(imx->clk_ipg);\r\n}\r\nimx->chip.ops = &imx_pwm_ops;\r\nimx->chip.dev = &pdev->dev;\r\nimx->chip.base = -1;\r\nimx->chip.npwm = 1;\r\nimx->chip.can_sleep = true;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nimx->mmio_base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(imx->mmio_base))\r\nreturn PTR_ERR(imx->mmio_base);\r\ndata = of_id->data;\r\nimx->config = data->config;\r\nimx->set_enable = data->set_enable;\r\nret = pwmchip_add(&imx->chip);\r\nif (ret < 0)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, imx);\r\nreturn 0;\r\n}\r\nstatic int imx_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct imx_chip *imx;\r\nimx = platform_get_drvdata(pdev);\r\nif (imx == NULL)\r\nreturn -ENODEV;\r\nreturn pwmchip_remove(&imx->chip);\r\n}
