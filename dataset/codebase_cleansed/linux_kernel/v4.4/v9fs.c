static int get_cache_mode(char *s)\r\n{\r\nint version = -EINVAL;\r\nif (!strcmp(s, "loose")) {\r\nversion = CACHE_LOOSE;\r\np9_debug(P9_DEBUG_9P, "Cache mode: loose\n");\r\n} else if (!strcmp(s, "fscache")) {\r\nversion = CACHE_FSCACHE;\r\np9_debug(P9_DEBUG_9P, "Cache mode: fscache\n");\r\n} else if (!strcmp(s, "mmap")) {\r\nversion = CACHE_MMAP;\r\np9_debug(P9_DEBUG_9P, "Cache mode: mmap\n");\r\n} else if (!strcmp(s, "none")) {\r\nversion = CACHE_NONE;\r\np9_debug(P9_DEBUG_9P, "Cache mode: none\n");\r\n} else\r\npr_info("Unknown Cache mode %s\n", s);\r\nreturn version;\r\n}\r\nstatic int v9fs_parse_options(struct v9fs_session_info *v9ses, char *opts)\r\n{\r\nchar *options, *tmp_options;\r\nsubstring_t args[MAX_OPT_ARGS];\r\nchar *p;\r\nint option = 0;\r\nchar *s, *e;\r\nint ret = 0;\r\nv9ses->afid = ~0;\r\nv9ses->debug = 0;\r\nv9ses->cache = CACHE_NONE;\r\n#ifdef CONFIG_9P_FSCACHE\r\nv9ses->cachetag = NULL;\r\n#endif\r\nif (!opts)\r\nreturn 0;\r\ntmp_options = kstrdup(opts, GFP_KERNEL);\r\nif (!tmp_options) {\r\nret = -ENOMEM;\r\ngoto fail_option_alloc;\r\n}\r\noptions = tmp_options;\r\nwhile ((p = strsep(&options, ",")) != NULL) {\r\nint token, r;\r\nif (!*p)\r\ncontinue;\r\ntoken = match_token(p, tokens, args);\r\nswitch (token) {\r\ncase Opt_debug:\r\nr = match_int(&args[0], &option);\r\nif (r < 0) {\r\np9_debug(P9_DEBUG_ERROR,\r\n"integer field, but no integer?\n");\r\nret = r;\r\ncontinue;\r\n}\r\nv9ses->debug = option;\r\n#ifdef CONFIG_NET_9P_DEBUG\r\np9_debug_level = option;\r\n#endif\r\nbreak;\r\ncase Opt_dfltuid:\r\nr = match_int(&args[0], &option);\r\nif (r < 0) {\r\np9_debug(P9_DEBUG_ERROR,\r\n"integer field, but no integer?\n");\r\nret = r;\r\ncontinue;\r\n}\r\nv9ses->dfltuid = make_kuid(current_user_ns(), option);\r\nif (!uid_valid(v9ses->dfltuid)) {\r\np9_debug(P9_DEBUG_ERROR,\r\n"uid field, but not a uid?\n");\r\nret = -EINVAL;\r\ncontinue;\r\n}\r\nbreak;\r\ncase Opt_dfltgid:\r\nr = match_int(&args[0], &option);\r\nif (r < 0) {\r\np9_debug(P9_DEBUG_ERROR,\r\n"integer field, but no integer?\n");\r\nret = r;\r\ncontinue;\r\n}\r\nv9ses->dfltgid = make_kgid(current_user_ns(), option);\r\nif (!gid_valid(v9ses->dfltgid)) {\r\np9_debug(P9_DEBUG_ERROR,\r\n"gid field, but not a gid?\n");\r\nret = -EINVAL;\r\ncontinue;\r\n}\r\nbreak;\r\ncase Opt_afid:\r\nr = match_int(&args[0], &option);\r\nif (r < 0) {\r\np9_debug(P9_DEBUG_ERROR,\r\n"integer field, but no integer?\n");\r\nret = r;\r\ncontinue;\r\n}\r\nv9ses->afid = option;\r\nbreak;\r\ncase Opt_uname:\r\nkfree(v9ses->uname);\r\nv9ses->uname = match_strdup(&args[0]);\r\nif (!v9ses->uname) {\r\nret = -ENOMEM;\r\ngoto free_and_return;\r\n}\r\nbreak;\r\ncase Opt_remotename:\r\nkfree(v9ses->aname);\r\nv9ses->aname = match_strdup(&args[0]);\r\nif (!v9ses->aname) {\r\nret = -ENOMEM;\r\ngoto free_and_return;\r\n}\r\nbreak;\r\ncase Opt_nodevmap:\r\nv9ses->nodev = 1;\r\nbreak;\r\ncase Opt_cache_loose:\r\nv9ses->cache = CACHE_LOOSE;\r\nbreak;\r\ncase Opt_fscache:\r\nv9ses->cache = CACHE_FSCACHE;\r\nbreak;\r\ncase Opt_mmap:\r\nv9ses->cache = CACHE_MMAP;\r\nbreak;\r\ncase Opt_cachetag:\r\n#ifdef CONFIG_9P_FSCACHE\r\nv9ses->cachetag = match_strdup(&args[0]);\r\n#endif\r\nbreak;\r\ncase Opt_cache:\r\ns = match_strdup(&args[0]);\r\nif (!s) {\r\nret = -ENOMEM;\r\np9_debug(P9_DEBUG_ERROR,\r\n"problem allocating copy of cache arg\n");\r\ngoto free_and_return;\r\n}\r\nret = get_cache_mode(s);\r\nif (ret == -EINVAL) {\r\nkfree(s);\r\ngoto free_and_return;\r\n}\r\nv9ses->cache = ret;\r\nkfree(s);\r\nbreak;\r\ncase Opt_access:\r\ns = match_strdup(&args[0]);\r\nif (!s) {\r\nret = -ENOMEM;\r\np9_debug(P9_DEBUG_ERROR,\r\n"problem allocating copy of access arg\n");\r\ngoto free_and_return;\r\n}\r\nv9ses->flags &= ~V9FS_ACCESS_MASK;\r\nif (strcmp(s, "user") == 0)\r\nv9ses->flags |= V9FS_ACCESS_USER;\r\nelse if (strcmp(s, "any") == 0)\r\nv9ses->flags |= V9FS_ACCESS_ANY;\r\nelse if (strcmp(s, "client") == 0) {\r\nv9ses->flags |= V9FS_ACCESS_CLIENT;\r\n} else {\r\nuid_t uid;\r\nv9ses->flags |= V9FS_ACCESS_SINGLE;\r\nuid = simple_strtoul(s, &e, 10);\r\nif (*e != '\0') {\r\nret = -EINVAL;\r\npr_info("Unknown access argument %s\n",\r\ns);\r\nkfree(s);\r\ngoto free_and_return;\r\n}\r\nv9ses->uid = make_kuid(current_user_ns(), uid);\r\nif (!uid_valid(v9ses->uid)) {\r\nret = -EINVAL;\r\npr_info("Uknown uid %s\n", s);\r\nkfree(s);\r\ngoto free_and_return;\r\n}\r\n}\r\nkfree(s);\r\nbreak;\r\ncase Opt_posixacl:\r\n#ifdef CONFIG_9P_FS_POSIX_ACL\r\nv9ses->flags |= V9FS_POSIX_ACL;\r\n#else\r\np9_debug(P9_DEBUG_ERROR,\r\n"Not defined CONFIG_9P_FS_POSIX_ACL. Ignoring posixacl option\n");\r\n#endif\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\n}\r\nfree_and_return:\r\nkfree(tmp_options);\r\nfail_option_alloc:\r\nreturn ret;\r\n}\r\nstruct p9_fid *v9fs_session_init(struct v9fs_session_info *v9ses,\r\nconst char *dev_name, char *data)\r\n{\r\nstruct p9_fid *fid;\r\nint rc = -ENOMEM;\r\nv9ses->uname = kstrdup(V9FS_DEFUSER, GFP_KERNEL);\r\nif (!v9ses->uname)\r\ngoto err_names;\r\nv9ses->aname = kstrdup(V9FS_DEFANAME, GFP_KERNEL);\r\nif (!v9ses->aname)\r\ngoto err_names;\r\ninit_rwsem(&v9ses->rename_sem);\r\nrc = bdi_setup_and_register(&v9ses->bdi, "9p");\r\nif (rc)\r\ngoto err_names;\r\nv9ses->uid = INVALID_UID;\r\nv9ses->dfltuid = V9FS_DEFUID;\r\nv9ses->dfltgid = V9FS_DEFGID;\r\nv9ses->clnt = p9_client_create(dev_name, data);\r\nif (IS_ERR(v9ses->clnt)) {\r\nrc = PTR_ERR(v9ses->clnt);\r\np9_debug(P9_DEBUG_ERROR, "problem initializing 9p client\n");\r\ngoto err_bdi;\r\n}\r\nv9ses->flags = V9FS_ACCESS_USER;\r\nif (p9_is_proto_dotl(v9ses->clnt)) {\r\nv9ses->flags = V9FS_ACCESS_CLIENT;\r\nv9ses->flags |= V9FS_PROTO_2000L;\r\n} else if (p9_is_proto_dotu(v9ses->clnt)) {\r\nv9ses->flags |= V9FS_PROTO_2000U;\r\n}\r\nrc = v9fs_parse_options(v9ses, data);\r\nif (rc < 0)\r\ngoto err_clnt;\r\nv9ses->maxdata = v9ses->clnt->msize - P9_IOHDRSZ;\r\nif (!v9fs_proto_dotl(v9ses) &&\r\n((v9ses->flags & V9FS_ACCESS_MASK) == V9FS_ACCESS_CLIENT)) {\r\nv9ses->flags &= ~V9FS_ACCESS_MASK;\r\nv9ses->flags |= V9FS_ACCESS_USER;\r\n}\r\nif (!(v9fs_proto_dotu(v9ses) || v9fs_proto_dotl(v9ses)) &&\r\n((v9ses->flags&V9FS_ACCESS_MASK) == V9FS_ACCESS_USER)) {\r\nv9ses->flags &= ~V9FS_ACCESS_MASK;\r\nv9ses->flags |= V9FS_ACCESS_ANY;\r\nv9ses->uid = INVALID_UID;\r\n}\r\nif (!v9fs_proto_dotl(v9ses) ||\r\n!((v9ses->flags & V9FS_ACCESS_MASK) == V9FS_ACCESS_CLIENT)) {\r\nv9ses->flags &= ~V9FS_ACL_MASK;\r\n}\r\nfid = p9_client_attach(v9ses->clnt, NULL, v9ses->uname, INVALID_UID,\r\nv9ses->aname);\r\nif (IS_ERR(fid)) {\r\nrc = PTR_ERR(fid);\r\np9_debug(P9_DEBUG_ERROR, "cannot attach\n");\r\ngoto err_clnt;\r\n}\r\nif ((v9ses->flags & V9FS_ACCESS_MASK) == V9FS_ACCESS_SINGLE)\r\nfid->uid = v9ses->uid;\r\nelse\r\nfid->uid = INVALID_UID;\r\n#ifdef CONFIG_9P_FSCACHE\r\nv9fs_cache_session_get_cookie(v9ses);\r\n#endif\r\nspin_lock(&v9fs_sessionlist_lock);\r\nlist_add(&v9ses->slist, &v9fs_sessionlist);\r\nspin_unlock(&v9fs_sessionlist_lock);\r\nreturn fid;\r\nerr_clnt:\r\np9_client_destroy(v9ses->clnt);\r\nerr_bdi:\r\nbdi_destroy(&v9ses->bdi);\r\nerr_names:\r\nkfree(v9ses->uname);\r\nkfree(v9ses->aname);\r\nreturn ERR_PTR(rc);\r\n}\r\nvoid v9fs_session_close(struct v9fs_session_info *v9ses)\r\n{\r\nif (v9ses->clnt) {\r\np9_client_destroy(v9ses->clnt);\r\nv9ses->clnt = NULL;\r\n}\r\n#ifdef CONFIG_9P_FSCACHE\r\nif (v9ses->fscache) {\r\nv9fs_cache_session_put_cookie(v9ses);\r\nkfree(v9ses->cachetag);\r\n}\r\n#endif\r\nkfree(v9ses->uname);\r\nkfree(v9ses->aname);\r\nbdi_destroy(&v9ses->bdi);\r\nspin_lock(&v9fs_sessionlist_lock);\r\nlist_del(&v9ses->slist);\r\nspin_unlock(&v9fs_sessionlist_lock);\r\n}\r\nvoid v9fs_session_cancel(struct v9fs_session_info *v9ses) {\r\np9_debug(P9_DEBUG_ERROR, "cancel session %p\n", v9ses);\r\np9_client_disconnect(v9ses->clnt);\r\n}\r\nvoid v9fs_session_begin_cancel(struct v9fs_session_info *v9ses)\r\n{\r\np9_debug(P9_DEBUG_ERROR, "begin cancel session %p\n", v9ses);\r\np9_client_begin_disconnect(v9ses->clnt);\r\n}\r\nstatic ssize_t caches_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nssize_t n = 0, count = 0, limit = PAGE_SIZE;\r\nstruct v9fs_session_info *v9ses;\r\nspin_lock(&v9fs_sessionlist_lock);\r\nlist_for_each_entry(v9ses, &v9fs_sessionlist, slist) {\r\nif (v9ses->cachetag) {\r\nn = snprintf(buf, limit, "%s\n", v9ses->cachetag);\r\nif (n < 0) {\r\ncount = n;\r\nbreak;\r\n}\r\ncount += n;\r\nlimit -= n;\r\n}\r\n}\r\nspin_unlock(&v9fs_sessionlist_lock);\r\nreturn count;\r\n}\r\nstatic int __init v9fs_sysfs_init(void)\r\n{\r\nv9fs_kobj = kobject_create_and_add("9p", fs_kobj);\r\nif (!v9fs_kobj)\r\nreturn -ENOMEM;\r\nif (sysfs_create_group(v9fs_kobj, &v9fs_attr_group)) {\r\nkobject_put(v9fs_kobj);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void v9fs_sysfs_cleanup(void)\r\n{\r\nsysfs_remove_group(v9fs_kobj, &v9fs_attr_group);\r\nkobject_put(v9fs_kobj);\r\n}\r\nstatic void v9fs_inode_init_once(void *foo)\r\n{\r\nstruct v9fs_inode *v9inode = (struct v9fs_inode *)foo;\r\n#ifdef CONFIG_9P_FSCACHE\r\nv9inode->fscache = NULL;\r\n#endif\r\nmemset(&v9inode->qid, 0, sizeof(v9inode->qid));\r\ninode_init_once(&v9inode->vfs_inode);\r\n}\r\nstatic int v9fs_init_inode_cache(void)\r\n{\r\nv9fs_inode_cache = kmem_cache_create("v9fs_inode_cache",\r\nsizeof(struct v9fs_inode),\r\n0, (SLAB_RECLAIM_ACCOUNT|\r\nSLAB_MEM_SPREAD),\r\nv9fs_inode_init_once);\r\nif (!v9fs_inode_cache)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void v9fs_destroy_inode_cache(void)\r\n{\r\nrcu_barrier();\r\nkmem_cache_destroy(v9fs_inode_cache);\r\n}\r\nstatic int v9fs_cache_register(void)\r\n{\r\nint ret;\r\nret = v9fs_init_inode_cache();\r\nif (ret < 0)\r\nreturn ret;\r\n#ifdef CONFIG_9P_FSCACHE\r\nret = fscache_register_netfs(&v9fs_cache_netfs);\r\nif (ret < 0)\r\nv9fs_destroy_inode_cache();\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void v9fs_cache_unregister(void)\r\n{\r\nv9fs_destroy_inode_cache();\r\n#ifdef CONFIG_9P_FSCACHE\r\nfscache_unregister_netfs(&v9fs_cache_netfs);\r\n#endif\r\n}\r\nstatic int __init init_v9fs(void)\r\n{\r\nint err;\r\npr_info("Installing v9fs 9p2000 file system support\n");\r\nerr = v9fs_cache_register();\r\nif (err < 0) {\r\npr_err("Failed to register v9fs for caching\n");\r\nreturn err;\r\n}\r\nerr = v9fs_sysfs_init();\r\nif (err < 0) {\r\npr_err("Failed to register with sysfs\n");\r\ngoto out_cache;\r\n}\r\nerr = register_filesystem(&v9fs_fs_type);\r\nif (err < 0) {\r\npr_err("Failed to register filesystem\n");\r\ngoto out_sysfs_cleanup;\r\n}\r\nreturn 0;\r\nout_sysfs_cleanup:\r\nv9fs_sysfs_cleanup();\r\nout_cache:\r\nv9fs_cache_unregister();\r\nreturn err;\r\n}\r\nstatic void __exit exit_v9fs(void)\r\n{\r\nv9fs_sysfs_cleanup();\r\nv9fs_cache_unregister();\r\nunregister_filesystem(&v9fs_fs_type);\r\n}
