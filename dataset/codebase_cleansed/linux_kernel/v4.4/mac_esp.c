static inline void mac_esp_write8(struct esp *esp, u8 val, unsigned long reg)\r\n{\r\nnubus_writeb(val, esp->regs + reg * 16);\r\n}\r\nstatic inline u8 mac_esp_read8(struct esp *esp, unsigned long reg)\r\n{\r\nreturn nubus_readb(esp->regs + reg * 16);\r\n}\r\nstatic dma_addr_t mac_esp_map_single(struct esp *esp, void *buf,\r\nsize_t sz, int dir)\r\n{\r\nreturn (dma_addr_t)buf;\r\n}\r\nstatic int mac_esp_map_sg(struct esp *esp, struct scatterlist *sg,\r\nint num_sg, int dir)\r\n{\r\nint i;\r\nfor (i = 0; i < num_sg; i++)\r\nsg[i].dma_address = (u32)sg_virt(&sg[i]);\r\nreturn num_sg;\r\n}\r\nstatic void mac_esp_unmap_single(struct esp *esp, dma_addr_t addr,\r\nsize_t sz, int dir)\r\n{\r\n}\r\nstatic void mac_esp_unmap_sg(struct esp *esp, struct scatterlist *sg,\r\nint num_sg, int dir)\r\n{\r\n}\r\nstatic void mac_esp_reset_dma(struct esp *esp)\r\n{\r\n}\r\nstatic void mac_esp_dma_drain(struct esp *esp)\r\n{\r\n}\r\nstatic void mac_esp_dma_invalidate(struct esp *esp)\r\n{\r\n}\r\nstatic int mac_esp_dma_error(struct esp *esp)\r\n{\r\nreturn MAC_ESP_GET_PRIV(esp)->error;\r\n}\r\nstatic inline int mac_esp_wait_for_empty_fifo(struct esp *esp)\r\n{\r\nstruct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);\r\nint i = 500000;\r\ndo {\r\nif (!(esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES))\r\nreturn 0;\r\nif (esp_read8(ESP_STATUS) & ESP_STAT_INTR)\r\nreturn 1;\r\nudelay(2);\r\n} while (--i);\r\nprintk(KERN_ERR PFX "FIFO is not empty (sreg %02x)\n",\r\nesp_read8(ESP_STATUS));\r\nmep->error = 1;\r\nreturn 1;\r\n}\r\nstatic inline int mac_esp_wait_for_dreq(struct esp *esp)\r\n{\r\nstruct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);\r\nint i = 500000;\r\ndo {\r\nif (mep->pdma_regs == NULL) {\r\nif (via2_scsi_drq_pending())\r\nreturn 0;\r\n} else {\r\nif (nubus_readl(mep->pdma_regs) & 0x200)\r\nreturn 0;\r\n}\r\nif (esp_read8(ESP_STATUS) & ESP_STAT_INTR)\r\nreturn 1;\r\nudelay(2);\r\n} while (--i);\r\nprintk(KERN_ERR PFX "PDMA timeout (sreg %02x)\n",\r\nesp_read8(ESP_STATUS));\r\nmep->error = 1;\r\nreturn 1;\r\n}\r\nstatic void mac_esp_send_pdma_cmd(struct esp *esp, u32 addr, u32 esp_count,\r\nu32 dma_count, int write, u8 cmd)\r\n{\r\nstruct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);\r\nmep->error = 0;\r\nif (!write)\r\nscsi_esp_cmd(esp, ESP_CMD_FLUSH);\r\nesp_write8((esp_count >> 0) & 0xFF, ESP_TCLOW);\r\nesp_write8((esp_count >> 8) & 0xFF, ESP_TCMED);\r\nscsi_esp_cmd(esp, cmd);\r\ndo {\r\nunsigned int count32 = esp_count >> 5;\r\nunsigned int count2 = (esp_count & 0x1F) >> 1;\r\nunsigned int count1 = esp_count & 1;\r\nunsigned int start_addr = addr;\r\nif (mac_esp_wait_for_dreq(esp))\r\nbreak;\r\nif (write) {\r\nMAC_ESP_PDMA_LOOP("%4@,%0@+");\r\nesp_count -= addr - start_addr;\r\n} else {\r\nunsigned int n;\r\nMAC_ESP_PDMA_LOOP("%0@+,%4@");\r\nif (mac_esp_wait_for_empty_fifo(esp))\r\nbreak;\r\nn = (esp_read8(ESP_TCMED) << 8) + esp_read8(ESP_TCLOW);\r\naddr = start_addr + esp_count - n;\r\nesp_count = n;\r\n}\r\n} while (esp_count);\r\n}\r\nstatic inline unsigned int mac_esp_wait_for_fifo(struct esp *esp)\r\n{\r\nint i = 500000;\r\ndo {\r\nunsigned int fbytes = esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES;\r\nif (fbytes)\r\nreturn fbytes;\r\nudelay(2);\r\n} while (--i);\r\nprintk(KERN_ERR PFX "FIFO is empty (sreg %02x)\n",\r\nesp_read8(ESP_STATUS));\r\nreturn 0;\r\n}\r\nstatic inline int mac_esp_wait_for_intr(struct esp *esp)\r\n{\r\nstruct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);\r\nint i = 500000;\r\ndo {\r\nesp->sreg = esp_read8(ESP_STATUS);\r\nif (esp->sreg & ESP_STAT_INTR)\r\nreturn 0;\r\nudelay(2);\r\n} while (--i);\r\nprintk(KERN_ERR PFX "IRQ timeout (sreg %02x)\n", esp->sreg);\r\nmep->error = 1;\r\nreturn 1;\r\n}\r\nstatic void mac_esp_send_pio_cmd(struct esp *esp, u32 addr, u32 esp_count,\r\nu32 dma_count, int write, u8 cmd)\r\n{\r\nstruct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);\r\nu8 *fifo = esp->regs + ESP_FDATA * 16;\r\ncmd &= ~ESP_CMD_DMA;\r\nmep->error = 0;\r\nif (write) {\r\nscsi_esp_cmd(esp, cmd);\r\nwhile (1) {\r\nunsigned int n;\r\nn = mac_esp_wait_for_fifo(esp);\r\nif (!n)\r\nbreak;\r\nif (n > esp_count)\r\nn = esp_count;\r\nesp_count -= n;\r\nMAC_ESP_PIO_LOOP("%2@,%0@+", n);\r\nif (!esp_count)\r\nbreak;\r\nif (mac_esp_wait_for_intr(esp))\r\nbreak;\r\nif (((esp->sreg & ESP_STAT_PMASK) != ESP_DIP) &&\r\n((esp->sreg & ESP_STAT_PMASK) != ESP_MIP))\r\nbreak;\r\nesp->ireg = esp_read8(ESP_INTRPT);\r\nif ((esp->ireg & (ESP_INTR_DC | ESP_INTR_BSERV)) !=\r\nESP_INTR_BSERV)\r\nbreak;\r\nscsi_esp_cmd(esp, ESP_CMD_TI);\r\n}\r\n} else {\r\nscsi_esp_cmd(esp, ESP_CMD_FLUSH);\r\nif (esp_count >= MAC_ESP_FIFO_SIZE)\r\nMAC_ESP_PIO_FILL("%0@+,%2@", esp_count);\r\nelse\r\nMAC_ESP_PIO_LOOP("%0@+,%2@", esp_count);\r\nscsi_esp_cmd(esp, cmd);\r\nwhile (esp_count) {\r\nunsigned int n;\r\nif (mac_esp_wait_for_intr(esp))\r\nbreak;\r\nif (((esp->sreg & ESP_STAT_PMASK) != ESP_DOP) &&\r\n((esp->sreg & ESP_STAT_PMASK) != ESP_MOP))\r\nbreak;\r\nesp->ireg = esp_read8(ESP_INTRPT);\r\nif ((esp->ireg & (ESP_INTR_DC | ESP_INTR_BSERV)) !=\r\nESP_INTR_BSERV)\r\nbreak;\r\nn = MAC_ESP_FIFO_SIZE -\r\n(esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES);\r\nif (n > esp_count)\r\nn = esp_count;\r\nif (n == MAC_ESP_FIFO_SIZE) {\r\nMAC_ESP_PIO_FILL("%0@+,%2@", esp_count);\r\n} else {\r\nesp_count -= n;\r\nMAC_ESP_PIO_LOOP("%0@+,%2@", n);\r\n}\r\nscsi_esp_cmd(esp, ESP_CMD_TI);\r\n}\r\n}\r\n}\r\nstatic int mac_esp_irq_pending(struct esp *esp)\r\n{\r\nif (esp_read8(ESP_STATUS) & ESP_STAT_INTR)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic u32 mac_esp_dma_length_limit(struct esp *esp, u32 dma_addr, u32 dma_len)\r\n{\r\nreturn dma_len > 0xFFFF ? 0xFFFF : dma_len;\r\n}\r\nstatic irqreturn_t mac_scsi_esp_intr(int irq, void *dev_id)\r\n{\r\nint got_intr;\r\ndo {\r\ngot_intr = 0;\r\nif (esp_chips[0] &&\r\n(mac_esp_read8(esp_chips[0], ESP_STATUS) & ESP_STAT_INTR)) {\r\n(void)scsi_esp_intr(irq, esp_chips[0]);\r\ngot_intr = 1;\r\n}\r\nif (esp_chips[1] &&\r\n(mac_esp_read8(esp_chips[1], ESP_STATUS) & ESP_STAT_INTR)) {\r\n(void)scsi_esp_intr(irq, esp_chips[1]);\r\ngot_intr = 1;\r\n}\r\n} while (got_intr);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int esp_mac_probe(struct platform_device *dev)\r\n{\r\nstruct scsi_host_template *tpnt = &scsi_esp_template;\r\nstruct Scsi_Host *host;\r\nstruct esp *esp;\r\nint err;\r\nstruct mac_esp_priv *mep;\r\nif (!MACH_IS_MAC)\r\nreturn -ENODEV;\r\nif (dev->id > 1)\r\nreturn -ENODEV;\r\nhost = scsi_host_alloc(tpnt, sizeof(struct esp));\r\nerr = -ENOMEM;\r\nif (!host)\r\ngoto fail;\r\nhost->max_id = 8;\r\nhost->use_clustering = DISABLE_CLUSTERING;\r\nesp = shost_priv(host);\r\nesp->host = host;\r\nesp->dev = dev;\r\nesp->command_block = kzalloc(16, GFP_KERNEL);\r\nif (!esp->command_block)\r\ngoto fail_unlink;\r\nesp->command_block_dma = (dma_addr_t)esp->command_block;\r\nesp->scsi_id = 7;\r\nhost->this_id = esp->scsi_id;\r\nesp->scsi_id_mask = 1 << esp->scsi_id;\r\nmep = kzalloc(sizeof(struct mac_esp_priv), GFP_KERNEL);\r\nif (!mep)\r\ngoto fail_free_command_block;\r\nmep->esp = esp;\r\nplatform_set_drvdata(dev, mep);\r\nswitch (macintosh_config->scsi_type) {\r\ncase MAC_SCSI_QUADRA:\r\nesp->cfreq = 16500000;\r\nesp->regs = (void __iomem *)MAC_ESP_REGS_QUADRA;\r\nmep->pdma_io = esp->regs + MAC_ESP_PDMA_IO_OFFSET;\r\nmep->pdma_regs = NULL;\r\nbreak;\r\ncase MAC_SCSI_QUADRA2:\r\nesp->cfreq = 25000000;\r\nesp->regs = (void __iomem *)(MAC_ESP_REGS_QUADRA2 +\r\ndev->id * MAC_ESP_REGS_SPACING);\r\nmep->pdma_io = esp->regs + MAC_ESP_PDMA_IO_OFFSET;\r\nmep->pdma_regs = (void __iomem *)(MAC_ESP_PDMA_REG +\r\ndev->id * MAC_ESP_PDMA_REG_SPACING);\r\nnubus_writel(0x1d1, mep->pdma_regs);\r\nbreak;\r\ncase MAC_SCSI_QUADRA3:\r\nesp->cfreq = 25000000;\r\nesp->regs = (void __iomem *)MAC_ESP_REGS_QUADRA3;\r\nmep->pdma_io = NULL;\r\nmep->pdma_regs = NULL;\r\nbreak;\r\n}\r\nesp->ops = &mac_esp_ops;\r\nif (mep->pdma_io == NULL) {\r\nprintk(KERN_INFO PFX "using PIO for controller %d\n", dev->id);\r\nesp_write8(0, ESP_TCLOW);\r\nesp_write8(0, ESP_TCMED);\r\nesp->flags = ESP_FLAG_DISABLE_SYNC;\r\nmac_esp_ops.send_dma_cmd = mac_esp_send_pio_cmd;\r\n} else {\r\nprintk(KERN_INFO PFX "using PDMA for controller %d\n", dev->id);\r\n}\r\nhost->irq = IRQ_MAC_SCSI;\r\nesp_chips[dev->id] = esp;\r\nmb();\r\nif (esp_chips[!dev->id] == NULL) {\r\nerr = request_irq(host->irq, mac_scsi_esp_intr, 0, "ESP", NULL);\r\nif (err < 0) {\r\nesp_chips[dev->id] = NULL;\r\ngoto fail_free_priv;\r\n}\r\n}\r\nerr = scsi_esp_register(esp, &dev->dev);\r\nif (err)\r\ngoto fail_free_irq;\r\nreturn 0;\r\nfail_free_irq:\r\nif (esp_chips[!dev->id] == NULL)\r\nfree_irq(host->irq, esp);\r\nfail_free_priv:\r\nkfree(mep);\r\nfail_free_command_block:\r\nkfree(esp->command_block);\r\nfail_unlink:\r\nscsi_host_put(host);\r\nfail:\r\nreturn err;\r\n}\r\nstatic int esp_mac_remove(struct platform_device *dev)\r\n{\r\nstruct mac_esp_priv *mep = platform_get_drvdata(dev);\r\nstruct esp *esp = mep->esp;\r\nunsigned int irq = esp->host->irq;\r\nscsi_esp_unregister(esp);\r\nesp_chips[dev->id] = NULL;\r\nif (!(esp_chips[0] || esp_chips[1]))\r\nfree_irq(irq, NULL);\r\nkfree(mep);\r\nkfree(esp->command_block);\r\nscsi_host_put(esp->host);\r\nreturn 0;\r\n}\r\nstatic int __init mac_esp_init(void)\r\n{\r\nreturn platform_driver_register(&esp_mac_driver);\r\n}\r\nstatic void __exit mac_esp_exit(void)\r\n{\r\nplatform_driver_unregister(&esp_mac_driver);\r\n}
