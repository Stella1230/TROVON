void amdgpu_dpm_print_class_info(u32 class, u32 class2)\r\n{\r\nprintk("\tui class: ");\r\nswitch (class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) {\r\ncase ATOM_PPLIB_CLASSIFICATION_UI_NONE:\r\ndefault:\r\nprintk("none\n");\r\nbreak;\r\ncase ATOM_PPLIB_CLASSIFICATION_UI_BATTERY:\r\nprintk("battery\n");\r\nbreak;\r\ncase ATOM_PPLIB_CLASSIFICATION_UI_BALANCED:\r\nprintk("balanced\n");\r\nbreak;\r\ncase ATOM_PPLIB_CLASSIFICATION_UI_PERFORMANCE:\r\nprintk("performance\n");\r\nbreak;\r\n}\r\nprintk("\tinternal class: ");\r\nif (((class & ~ATOM_PPLIB_CLASSIFICATION_UI_MASK) == 0) &&\r\n(class2 == 0))\r\nprintk("none");\r\nelse {\r\nif (class & ATOM_PPLIB_CLASSIFICATION_BOOT)\r\nprintk("boot ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_THERMAL)\r\nprintk("thermal ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_LIMITEDPOWERSOURCE)\r\nprintk("limited_pwr ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_REST)\r\nprintk("rest ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_FORCED)\r\nprintk("forced ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_3DPERFORMANCE)\r\nprintk("3d_perf ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_OVERDRIVETEMPLATE)\r\nprintk("ovrdrv ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\r\nprintk("uvd ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_3DLOW)\r\nprintk("3d_low ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_ACPI)\r\nprintk("acpi ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_HD2STATE)\r\nprintk("uvd_hd2 ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_HDSTATE)\r\nprintk("uvd_hd ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_SDSTATE)\r\nprintk("uvd_sd ");\r\nif (class2 & ATOM_PPLIB_CLASSIFICATION2_LIMITEDPOWERSOURCE_2)\r\nprintk("limited_pwr2 ");\r\nif (class2 & ATOM_PPLIB_CLASSIFICATION2_ULV)\r\nprintk("ulv ");\r\nif (class2 & ATOM_PPLIB_CLASSIFICATION2_MVC)\r\nprintk("uvd_mvc ");\r\n}\r\nprintk("\n");\r\n}\r\nvoid amdgpu_dpm_print_cap_info(u32 caps)\r\n{\r\nprintk("\tcaps: ");\r\nif (caps & ATOM_PPLIB_SINGLE_DISPLAY_ONLY)\r\nprintk("single_disp ");\r\nif (caps & ATOM_PPLIB_SUPPORTS_VIDEO_PLAYBACK)\r\nprintk("video ");\r\nif (caps & ATOM_PPLIB_DISALLOW_ON_DC)\r\nprintk("no_dc ");\r\nprintk("\n");\r\n}\r\nvoid amdgpu_dpm_print_ps_status(struct amdgpu_device *adev,\r\nstruct amdgpu_ps *rps)\r\n{\r\nprintk("\tstatus: ");\r\nif (rps == adev->pm.dpm.current_ps)\r\nprintk("c ");\r\nif (rps == adev->pm.dpm.requested_ps)\r\nprintk("r ");\r\nif (rps == adev->pm.dpm.boot_ps)\r\nprintk("b ");\r\nprintk("\n");\r\n}\r\nu32 amdgpu_dpm_get_vblank_time(struct amdgpu_device *adev)\r\n{\r\nstruct drm_device *dev = adev->ddev;\r\nstruct drm_crtc *crtc;\r\nstruct amdgpu_crtc *amdgpu_crtc;\r\nu32 line_time_us, vblank_lines;\r\nu32 vblank_time_us = 0xffffffff;\r\nif (adev->mode_info.num_crtc && adev->mode_info.mode_config_initialized) {\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\namdgpu_crtc = to_amdgpu_crtc(crtc);\r\nif (crtc->enabled && amdgpu_crtc->enabled && amdgpu_crtc->hw_mode.clock) {\r\nline_time_us = (amdgpu_crtc->hw_mode.crtc_htotal * 1000) /\r\namdgpu_crtc->hw_mode.clock;\r\nvblank_lines = amdgpu_crtc->hw_mode.crtc_vblank_end -\r\namdgpu_crtc->hw_mode.crtc_vdisplay +\r\n(amdgpu_crtc->v_border * 2);\r\nvblank_time_us = vblank_lines * line_time_us;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn vblank_time_us;\r\n}\r\nu32 amdgpu_dpm_get_vrefresh(struct amdgpu_device *adev)\r\n{\r\nstruct drm_device *dev = adev->ddev;\r\nstruct drm_crtc *crtc;\r\nstruct amdgpu_crtc *amdgpu_crtc;\r\nu32 vrefresh = 0;\r\nif (adev->mode_info.num_crtc && adev->mode_info.mode_config_initialized) {\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\namdgpu_crtc = to_amdgpu_crtc(crtc);\r\nif (crtc->enabled && amdgpu_crtc->enabled && amdgpu_crtc->hw_mode.clock) {\r\nvrefresh = amdgpu_crtc->hw_mode.vrefresh;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn vrefresh;\r\n}\r\nvoid amdgpu_calculate_u_and_p(u32 i, u32 r_c, u32 p_b,\r\nu32 *p, u32 *u)\r\n{\r\nu32 b_c = 0;\r\nu32 i_c;\r\nu32 tmp;\r\ni_c = (i * r_c) / 100;\r\ntmp = i_c >> p_b;\r\nwhile (tmp) {\r\nb_c++;\r\ntmp >>= 1;\r\n}\r\n*u = (b_c + 1) / 2;\r\n*p = i_c / (1 << (2 * (*u)));\r\n}\r\nint amdgpu_calculate_at(u32 t, u32 h, u32 fh, u32 fl, u32 *tl, u32 *th)\r\n{\r\nu32 k, a, ah, al;\r\nu32 t1;\r\nif ((fl == 0) || (fh == 0) || (fl > fh))\r\nreturn -EINVAL;\r\nk = (100 * fh) / fl;\r\nt1 = (t * (k - 100));\r\na = (1000 * (100 * h + t1)) / (10000 + (t1 / 100));\r\na = (a + 5) / 10;\r\nah = ((a * t) + 5000) / 10000;\r\nal = a - ah;\r\n*th = t - ah;\r\n*tl = t + al;\r\nreturn 0;\r\n}\r\nbool amdgpu_is_uvd_state(u32 class, u32 class2)\r\n{\r\nif (class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\r\nreturn true;\r\nif (class & ATOM_PPLIB_CLASSIFICATION_HD2STATE)\r\nreturn true;\r\nif (class & ATOM_PPLIB_CLASSIFICATION_HDSTATE)\r\nreturn true;\r\nif (class & ATOM_PPLIB_CLASSIFICATION_SDSTATE)\r\nreturn true;\r\nif (class2 & ATOM_PPLIB_CLASSIFICATION2_MVC)\r\nreturn true;\r\nreturn false;\r\n}\r\nbool amdgpu_is_internal_thermal_sensor(enum amdgpu_int_thermal_type sensor)\r\n{\r\nswitch (sensor) {\r\ncase THERMAL_TYPE_RV6XX:\r\ncase THERMAL_TYPE_RV770:\r\ncase THERMAL_TYPE_EVERGREEN:\r\ncase THERMAL_TYPE_SUMO:\r\ncase THERMAL_TYPE_NI:\r\ncase THERMAL_TYPE_SI:\r\ncase THERMAL_TYPE_CI:\r\ncase THERMAL_TYPE_KV:\r\nreturn true;\r\ncase THERMAL_TYPE_ADT7473_WITH_INTERNAL:\r\ncase THERMAL_TYPE_EMC2103_WITH_INTERNAL:\r\nreturn false;\r\ncase THERMAL_TYPE_NONE:\r\ncase THERMAL_TYPE_EXTERNAL:\r\ncase THERMAL_TYPE_EXTERNAL_GPIO:\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int amdgpu_parse_clk_voltage_dep_table(struct amdgpu_clock_voltage_dependency_table *amdgpu_table,\r\nATOM_PPLIB_Clock_Voltage_Dependency_Table *atom_table)\r\n{\r\nu32 size = atom_table->ucNumEntries *\r\nsizeof(struct amdgpu_clock_voltage_dependency_entry);\r\nint i;\r\nATOM_PPLIB_Clock_Voltage_Dependency_Record *entry;\r\namdgpu_table->entries = kzalloc(size, GFP_KERNEL);\r\nif (!amdgpu_table->entries)\r\nreturn -ENOMEM;\r\nentry = &atom_table->entries[0];\r\nfor (i = 0; i < atom_table->ucNumEntries; i++) {\r\namdgpu_table->entries[i].clk = le16_to_cpu(entry->usClockLow) |\r\n(entry->ucClockHigh << 16);\r\namdgpu_table->entries[i].v = le16_to_cpu(entry->usVoltage);\r\nentry = (ATOM_PPLIB_Clock_Voltage_Dependency_Record *)\r\n((u8 *)entry + sizeof(ATOM_PPLIB_Clock_Voltage_Dependency_Record));\r\n}\r\namdgpu_table->count = atom_table->ucNumEntries;\r\nreturn 0;\r\n}\r\nint amdgpu_get_platform_caps(struct amdgpu_device *adev)\r\n{\r\nstruct amdgpu_mode_info *mode_info = &adev->mode_info;\r\nunion power_info *power_info;\r\nint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\r\nu16 data_offset;\r\nu8 frev, crev;\r\nif (!amdgpu_atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset))\r\nreturn -EINVAL;\r\npower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\r\nadev->pm.dpm.platform_caps = le32_to_cpu(power_info->pplib.ulPlatformCaps);\r\nadev->pm.dpm.backbias_response_time = le16_to_cpu(power_info->pplib.usBackbiasTime);\r\nadev->pm.dpm.voltage_response_time = le16_to_cpu(power_info->pplib.usVoltageTime);\r\nreturn 0;\r\n}\r\nint amdgpu_parse_extended_power_table(struct amdgpu_device *adev)\r\n{\r\nstruct amdgpu_mode_info *mode_info = &adev->mode_info;\r\nunion power_info *power_info;\r\nunion fan_info *fan_info;\r\nATOM_PPLIB_Clock_Voltage_Dependency_Table *dep_table;\r\nint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\r\nu16 data_offset;\r\nu8 frev, crev;\r\nint ret, i;\r\nif (!amdgpu_atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset))\r\nreturn -EINVAL;\r\npower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\r\nif (le16_to_cpu(power_info->pplib.usTableSize) >=\r\nsizeof(struct _ATOM_PPLIB_POWERPLAYTABLE3)) {\r\nif (power_info->pplib3.usFanTableOffset) {\r\nfan_info = (union fan_info *)(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib3.usFanTableOffset));\r\nadev->pm.dpm.fan.t_hyst = fan_info->fan.ucTHyst;\r\nadev->pm.dpm.fan.t_min = le16_to_cpu(fan_info->fan.usTMin);\r\nadev->pm.dpm.fan.t_med = le16_to_cpu(fan_info->fan.usTMed);\r\nadev->pm.dpm.fan.t_high = le16_to_cpu(fan_info->fan.usTHigh);\r\nadev->pm.dpm.fan.pwm_min = le16_to_cpu(fan_info->fan.usPWMMin);\r\nadev->pm.dpm.fan.pwm_med = le16_to_cpu(fan_info->fan.usPWMMed);\r\nadev->pm.dpm.fan.pwm_high = le16_to_cpu(fan_info->fan.usPWMHigh);\r\nif (fan_info->fan.ucFanTableFormat >= 2)\r\nadev->pm.dpm.fan.t_max = le16_to_cpu(fan_info->fan2.usTMax);\r\nelse\r\nadev->pm.dpm.fan.t_max = 10900;\r\nadev->pm.dpm.fan.cycle_delay = 100000;\r\nif (fan_info->fan.ucFanTableFormat >= 3) {\r\nadev->pm.dpm.fan.control_mode = fan_info->fan3.ucFanControlMode;\r\nadev->pm.dpm.fan.default_max_fan_pwm =\r\nle16_to_cpu(fan_info->fan3.usFanPWMMax);\r\nadev->pm.dpm.fan.default_fan_output_sensitivity = 4836;\r\nadev->pm.dpm.fan.fan_output_sensitivity =\r\nle16_to_cpu(fan_info->fan3.usFanOutputSensitivity);\r\n}\r\nadev->pm.dpm.fan.ucode_fan_control = true;\r\n}\r\n}\r\nif (le16_to_cpu(power_info->pplib.usTableSize) >=\r\nsizeof(struct _ATOM_PPLIB_POWERPLAYTABLE4)) {\r\nif (power_info->pplib4.usVddcDependencyOnSCLKOffset) {\r\ndep_table = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib4.usVddcDependencyOnSCLKOffset));\r\nret = amdgpu_parse_clk_voltage_dep_table(&adev->pm.dpm.dyn_state.vddc_dependency_on_sclk,\r\ndep_table);\r\nif (ret) {\r\namdgpu_free_extended_power_table(adev);\r\nreturn ret;\r\n}\r\n}\r\nif (power_info->pplib4.usVddciDependencyOnMCLKOffset) {\r\ndep_table = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib4.usVddciDependencyOnMCLKOffset));\r\nret = amdgpu_parse_clk_voltage_dep_table(&adev->pm.dpm.dyn_state.vddci_dependency_on_mclk,\r\ndep_table);\r\nif (ret) {\r\namdgpu_free_extended_power_table(adev);\r\nreturn ret;\r\n}\r\n}\r\nif (power_info->pplib4.usVddcDependencyOnMCLKOffset) {\r\ndep_table = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib4.usVddcDependencyOnMCLKOffset));\r\nret = amdgpu_parse_clk_voltage_dep_table(&adev->pm.dpm.dyn_state.vddc_dependency_on_mclk,\r\ndep_table);\r\nif (ret) {\r\namdgpu_free_extended_power_table(adev);\r\nreturn ret;\r\n}\r\n}\r\nif (power_info->pplib4.usMvddDependencyOnMCLKOffset) {\r\ndep_table = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib4.usMvddDependencyOnMCLKOffset));\r\nret = amdgpu_parse_clk_voltage_dep_table(&adev->pm.dpm.dyn_state.mvdd_dependency_on_mclk,\r\ndep_table);\r\nif (ret) {\r\namdgpu_free_extended_power_table(adev);\r\nreturn ret;\r\n}\r\n}\r\nif (power_info->pplib4.usMaxClockVoltageOnDCOffset) {\r\nATOM_PPLIB_Clock_Voltage_Limit_Table *clk_v =\r\n(ATOM_PPLIB_Clock_Voltage_Limit_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib4.usMaxClockVoltageOnDCOffset));\r\nif (clk_v->ucNumEntries) {\r\nadev->pm.dpm.dyn_state.max_clock_voltage_on_dc.sclk =\r\nle16_to_cpu(clk_v->entries[0].usSclkLow) |\r\n(clk_v->entries[0].ucSclkHigh << 16);\r\nadev->pm.dpm.dyn_state.max_clock_voltage_on_dc.mclk =\r\nle16_to_cpu(clk_v->entries[0].usMclkLow) |\r\n(clk_v->entries[0].ucMclkHigh << 16);\r\nadev->pm.dpm.dyn_state.max_clock_voltage_on_dc.vddc =\r\nle16_to_cpu(clk_v->entries[0].usVddc);\r\nadev->pm.dpm.dyn_state.max_clock_voltage_on_dc.vddci =\r\nle16_to_cpu(clk_v->entries[0].usVddci);\r\n}\r\n}\r\nif (power_info->pplib4.usVddcPhaseShedLimitsTableOffset) {\r\nATOM_PPLIB_PhaseSheddingLimits_Table *psl =\r\n(ATOM_PPLIB_PhaseSheddingLimits_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib4.usVddcPhaseShedLimitsTableOffset));\r\nATOM_PPLIB_PhaseSheddingLimits_Record *entry;\r\nadev->pm.dpm.dyn_state.phase_shedding_limits_table.entries =\r\nkzalloc(psl->ucNumEntries *\r\nsizeof(struct amdgpu_phase_shedding_limits_entry),\r\nGFP_KERNEL);\r\nif (!adev->pm.dpm.dyn_state.phase_shedding_limits_table.entries) {\r\namdgpu_free_extended_power_table(adev);\r\nreturn -ENOMEM;\r\n}\r\nentry = &psl->entries[0];\r\nfor (i = 0; i < psl->ucNumEntries; i++) {\r\nadev->pm.dpm.dyn_state.phase_shedding_limits_table.entries[i].sclk =\r\nle16_to_cpu(entry->usSclkLow) | (entry->ucSclkHigh << 16);\r\nadev->pm.dpm.dyn_state.phase_shedding_limits_table.entries[i].mclk =\r\nle16_to_cpu(entry->usMclkLow) | (entry->ucMclkHigh << 16);\r\nadev->pm.dpm.dyn_state.phase_shedding_limits_table.entries[i].voltage =\r\nle16_to_cpu(entry->usVoltage);\r\nentry = (ATOM_PPLIB_PhaseSheddingLimits_Record *)\r\n((u8 *)entry + sizeof(ATOM_PPLIB_PhaseSheddingLimits_Record));\r\n}\r\nadev->pm.dpm.dyn_state.phase_shedding_limits_table.count =\r\npsl->ucNumEntries;\r\n}\r\n}\r\nif (le16_to_cpu(power_info->pplib.usTableSize) >=\r\nsizeof(struct _ATOM_PPLIB_POWERPLAYTABLE5)) {\r\nadev->pm.dpm.tdp_limit = le32_to_cpu(power_info->pplib5.ulTDPLimit);\r\nadev->pm.dpm.near_tdp_limit = le32_to_cpu(power_info->pplib5.ulNearTDPLimit);\r\nadev->pm.dpm.near_tdp_limit_adjusted = adev->pm.dpm.near_tdp_limit;\r\nadev->pm.dpm.tdp_od_limit = le16_to_cpu(power_info->pplib5.usTDPODLimit);\r\nif (adev->pm.dpm.tdp_od_limit)\r\nadev->pm.dpm.power_control = true;\r\nelse\r\nadev->pm.dpm.power_control = false;\r\nadev->pm.dpm.tdp_adjustment = 0;\r\nadev->pm.dpm.sq_ramping_threshold = le32_to_cpu(power_info->pplib5.ulSQRampingThreshold);\r\nadev->pm.dpm.cac_leakage = le32_to_cpu(power_info->pplib5.ulCACLeakage);\r\nadev->pm.dpm.load_line_slope = le16_to_cpu(power_info->pplib5.usLoadLineSlope);\r\nif (power_info->pplib5.usCACLeakageTableOffset) {\r\nATOM_PPLIB_CAC_Leakage_Table *cac_table =\r\n(ATOM_PPLIB_CAC_Leakage_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib5.usCACLeakageTableOffset));\r\nATOM_PPLIB_CAC_Leakage_Record *entry;\r\nu32 size = cac_table->ucNumEntries * sizeof(struct amdgpu_cac_leakage_table);\r\nadev->pm.dpm.dyn_state.cac_leakage_table.entries = kzalloc(size, GFP_KERNEL);\r\nif (!adev->pm.dpm.dyn_state.cac_leakage_table.entries) {\r\namdgpu_free_extended_power_table(adev);\r\nreturn -ENOMEM;\r\n}\r\nentry = &cac_table->entries[0];\r\nfor (i = 0; i < cac_table->ucNumEntries; i++) {\r\nif (adev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_EVV) {\r\nadev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc1 =\r\nle16_to_cpu(entry->usVddc1);\r\nadev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc2 =\r\nle16_to_cpu(entry->usVddc2);\r\nadev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc3 =\r\nle16_to_cpu(entry->usVddc3);\r\n} else {\r\nadev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc =\r\nle16_to_cpu(entry->usVddc);\r\nadev->pm.dpm.dyn_state.cac_leakage_table.entries[i].leakage =\r\nle32_to_cpu(entry->ulLeakageValue);\r\n}\r\nentry = (ATOM_PPLIB_CAC_Leakage_Record *)\r\n((u8 *)entry + sizeof(ATOM_PPLIB_CAC_Leakage_Record));\r\n}\r\nadev->pm.dpm.dyn_state.cac_leakage_table.count = cac_table->ucNumEntries;\r\n}\r\n}\r\nif (le16_to_cpu(power_info->pplib.usTableSize) >=\r\nsizeof(struct _ATOM_PPLIB_POWERPLAYTABLE3)) {\r\nATOM_PPLIB_EXTENDEDHEADER *ext_hdr = (ATOM_PPLIB_EXTENDEDHEADER *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib3.usExtendendedHeaderOffset));\r\nif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V2) &&\r\next_hdr->usVCETableOffset) {\r\nVCEClockInfoArray *array = (VCEClockInfoArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usVCETableOffset) + 1);\r\nATOM_PPLIB_VCE_Clock_Voltage_Limit_Table *limits =\r\n(ATOM_PPLIB_VCE_Clock_Voltage_Limit_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usVCETableOffset) + 1 +\r\n1 + array->ucNumEntries * sizeof(VCEClockInfo));\r\nATOM_PPLIB_VCE_State_Table *states =\r\n(ATOM_PPLIB_VCE_State_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usVCETableOffset) + 1 +\r\n1 + (array->ucNumEntries * sizeof (VCEClockInfo)) +\r\n1 + (limits->numEntries * sizeof(ATOM_PPLIB_VCE_Clock_Voltage_Limit_Record)));\r\nATOM_PPLIB_VCE_Clock_Voltage_Limit_Record *entry;\r\nATOM_PPLIB_VCE_State_Record *state_entry;\r\nVCEClockInfo *vce_clk;\r\nu32 size = limits->numEntries *\r\nsizeof(struct amdgpu_vce_clock_voltage_dependency_entry);\r\nadev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries =\r\nkzalloc(size, GFP_KERNEL);\r\nif (!adev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries) {\r\namdgpu_free_extended_power_table(adev);\r\nreturn -ENOMEM;\r\n}\r\nadev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.count =\r\nlimits->numEntries;\r\nentry = &limits->entries[0];\r\nstate_entry = &states->entries[0];\r\nfor (i = 0; i < limits->numEntries; i++) {\r\nvce_clk = (VCEClockInfo *)\r\n((u8 *)&array->entries[0] +\r\n(entry->ucVCEClockInfoIndex * sizeof(VCEClockInfo)));\r\nadev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries[i].evclk =\r\nle16_to_cpu(vce_clk->usEVClkLow) | (vce_clk->ucEVClkHigh << 16);\r\nadev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries[i].ecclk =\r\nle16_to_cpu(vce_clk->usECClkLow) | (vce_clk->ucECClkHigh << 16);\r\nadev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries[i].v =\r\nle16_to_cpu(entry->usVoltage);\r\nentry = (ATOM_PPLIB_VCE_Clock_Voltage_Limit_Record *)\r\n((u8 *)entry + sizeof(ATOM_PPLIB_VCE_Clock_Voltage_Limit_Record));\r\n}\r\nfor (i = 0; i < states->numEntries; i++) {\r\nif (i >= AMDGPU_MAX_VCE_LEVELS)\r\nbreak;\r\nvce_clk = (VCEClockInfo *)\r\n((u8 *)&array->entries[0] +\r\n(state_entry->ucVCEClockInfoIndex * sizeof(VCEClockInfo)));\r\nadev->pm.dpm.vce_states[i].evclk =\r\nle16_to_cpu(vce_clk->usEVClkLow) | (vce_clk->ucEVClkHigh << 16);\r\nadev->pm.dpm.vce_states[i].ecclk =\r\nle16_to_cpu(vce_clk->usECClkLow) | (vce_clk->ucECClkHigh << 16);\r\nadev->pm.dpm.vce_states[i].clk_idx =\r\nstate_entry->ucClockInfoIndex & 0x3f;\r\nadev->pm.dpm.vce_states[i].pstate =\r\n(state_entry->ucClockInfoIndex & 0xc0) >> 6;\r\nstate_entry = (ATOM_PPLIB_VCE_State_Record *)\r\n((u8 *)state_entry + sizeof(ATOM_PPLIB_VCE_State_Record));\r\n}\r\n}\r\nif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V3) &&\r\next_hdr->usUVDTableOffset) {\r\nUVDClockInfoArray *array = (UVDClockInfoArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usUVDTableOffset) + 1);\r\nATOM_PPLIB_UVD_Clock_Voltage_Limit_Table *limits =\r\n(ATOM_PPLIB_UVD_Clock_Voltage_Limit_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usUVDTableOffset) + 1 +\r\n1 + (array->ucNumEntries * sizeof (UVDClockInfo)));\r\nATOM_PPLIB_UVD_Clock_Voltage_Limit_Record *entry;\r\nu32 size = limits->numEntries *\r\nsizeof(struct amdgpu_uvd_clock_voltage_dependency_entry);\r\nadev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries =\r\nkzalloc(size, GFP_KERNEL);\r\nif (!adev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries) {\r\namdgpu_free_extended_power_table(adev);\r\nreturn -ENOMEM;\r\n}\r\nadev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.count =\r\nlimits->numEntries;\r\nentry = &limits->entries[0];\r\nfor (i = 0; i < limits->numEntries; i++) {\r\nUVDClockInfo *uvd_clk = (UVDClockInfo *)\r\n((u8 *)&array->entries[0] +\r\n(entry->ucUVDClockInfoIndex * sizeof(UVDClockInfo)));\r\nadev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries[i].vclk =\r\nle16_to_cpu(uvd_clk->usVClkLow) | (uvd_clk->ucVClkHigh << 16);\r\nadev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries[i].dclk =\r\nle16_to_cpu(uvd_clk->usDClkLow) | (uvd_clk->ucDClkHigh << 16);\r\nadev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries[i].v =\r\nle16_to_cpu(entry->usVoltage);\r\nentry = (ATOM_PPLIB_UVD_Clock_Voltage_Limit_Record *)\r\n((u8 *)entry + sizeof(ATOM_PPLIB_UVD_Clock_Voltage_Limit_Record));\r\n}\r\n}\r\nif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V4) &&\r\next_hdr->usSAMUTableOffset) {\r\nATOM_PPLIB_SAMClk_Voltage_Limit_Table *limits =\r\n(ATOM_PPLIB_SAMClk_Voltage_Limit_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usSAMUTableOffset) + 1);\r\nATOM_PPLIB_SAMClk_Voltage_Limit_Record *entry;\r\nu32 size = limits->numEntries *\r\nsizeof(struct amdgpu_clock_voltage_dependency_entry);\r\nadev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.entries =\r\nkzalloc(size, GFP_KERNEL);\r\nif (!adev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.entries) {\r\namdgpu_free_extended_power_table(adev);\r\nreturn -ENOMEM;\r\n}\r\nadev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.count =\r\nlimits->numEntries;\r\nentry = &limits->entries[0];\r\nfor (i = 0; i < limits->numEntries; i++) {\r\nadev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.entries[i].clk =\r\nle16_to_cpu(entry->usSAMClockLow) | (entry->ucSAMClockHigh << 16);\r\nadev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.entries[i].v =\r\nle16_to_cpu(entry->usVoltage);\r\nentry = (ATOM_PPLIB_SAMClk_Voltage_Limit_Record *)\r\n((u8 *)entry + sizeof(ATOM_PPLIB_SAMClk_Voltage_Limit_Record));\r\n}\r\n}\r\nif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V5) &&\r\next_hdr->usPPMTableOffset) {\r\nATOM_PPLIB_PPM_Table *ppm = (ATOM_PPLIB_PPM_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usPPMTableOffset));\r\nadev->pm.dpm.dyn_state.ppm_table =\r\nkzalloc(sizeof(struct amdgpu_ppm_table), GFP_KERNEL);\r\nif (!adev->pm.dpm.dyn_state.ppm_table) {\r\namdgpu_free_extended_power_table(adev);\r\nreturn -ENOMEM;\r\n}\r\nadev->pm.dpm.dyn_state.ppm_table->ppm_design = ppm->ucPpmDesign;\r\nadev->pm.dpm.dyn_state.ppm_table->cpu_core_number =\r\nle16_to_cpu(ppm->usCpuCoreNumber);\r\nadev->pm.dpm.dyn_state.ppm_table->platform_tdp =\r\nle32_to_cpu(ppm->ulPlatformTDP);\r\nadev->pm.dpm.dyn_state.ppm_table->small_ac_platform_tdp =\r\nle32_to_cpu(ppm->ulSmallACPlatformTDP);\r\nadev->pm.dpm.dyn_state.ppm_table->platform_tdc =\r\nle32_to_cpu(ppm->ulPlatformTDC);\r\nadev->pm.dpm.dyn_state.ppm_table->small_ac_platform_tdc =\r\nle32_to_cpu(ppm->ulSmallACPlatformTDC);\r\nadev->pm.dpm.dyn_state.ppm_table->apu_tdp =\r\nle32_to_cpu(ppm->ulApuTDP);\r\nadev->pm.dpm.dyn_state.ppm_table->dgpu_tdp =\r\nle32_to_cpu(ppm->ulDGpuTDP);\r\nadev->pm.dpm.dyn_state.ppm_table->dgpu_ulv_power =\r\nle32_to_cpu(ppm->ulDGpuUlvPower);\r\nadev->pm.dpm.dyn_state.ppm_table->tj_max =\r\nle32_to_cpu(ppm->ulTjmax);\r\n}\r\nif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V6) &&\r\next_hdr->usACPTableOffset) {\r\nATOM_PPLIB_ACPClk_Voltage_Limit_Table *limits =\r\n(ATOM_PPLIB_ACPClk_Voltage_Limit_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usACPTableOffset) + 1);\r\nATOM_PPLIB_ACPClk_Voltage_Limit_Record *entry;\r\nu32 size = limits->numEntries *\r\nsizeof(struct amdgpu_clock_voltage_dependency_entry);\r\nadev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.entries =\r\nkzalloc(size, GFP_KERNEL);\r\nif (!adev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.entries) {\r\namdgpu_free_extended_power_table(adev);\r\nreturn -ENOMEM;\r\n}\r\nadev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.count =\r\nlimits->numEntries;\r\nentry = &limits->entries[0];\r\nfor (i = 0; i < limits->numEntries; i++) {\r\nadev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.entries[i].clk =\r\nle16_to_cpu(entry->usACPClockLow) | (entry->ucACPClockHigh << 16);\r\nadev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.entries[i].v =\r\nle16_to_cpu(entry->usVoltage);\r\nentry = (ATOM_PPLIB_ACPClk_Voltage_Limit_Record *)\r\n((u8 *)entry + sizeof(ATOM_PPLIB_ACPClk_Voltage_Limit_Record));\r\n}\r\n}\r\nif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V7) &&\r\next_hdr->usPowerTuneTableOffset) {\r\nu8 rev = *(u8 *)(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usPowerTuneTableOffset));\r\nATOM_PowerTune_Table *pt;\r\nadev->pm.dpm.dyn_state.cac_tdp_table =\r\nkzalloc(sizeof(struct amdgpu_cac_tdp_table), GFP_KERNEL);\r\nif (!adev->pm.dpm.dyn_state.cac_tdp_table) {\r\namdgpu_free_extended_power_table(adev);\r\nreturn -ENOMEM;\r\n}\r\nif (rev > 0) {\r\nATOM_PPLIB_POWERTUNE_Table_V1 *ppt = (ATOM_PPLIB_POWERTUNE_Table_V1 *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usPowerTuneTableOffset));\r\nadev->pm.dpm.dyn_state.cac_tdp_table->maximum_power_delivery_limit =\r\nppt->usMaximumPowerDeliveryLimit;\r\npt = &ppt->power_tune_table;\r\n} else {\r\nATOM_PPLIB_POWERTUNE_Table *ppt = (ATOM_PPLIB_POWERTUNE_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usPowerTuneTableOffset));\r\nadev->pm.dpm.dyn_state.cac_tdp_table->maximum_power_delivery_limit = 255;\r\npt = &ppt->power_tune_table;\r\n}\r\nadev->pm.dpm.dyn_state.cac_tdp_table->tdp = le16_to_cpu(pt->usTDP);\r\nadev->pm.dpm.dyn_state.cac_tdp_table->configurable_tdp =\r\nle16_to_cpu(pt->usConfigurableTDP);\r\nadev->pm.dpm.dyn_state.cac_tdp_table->tdc = le16_to_cpu(pt->usTDC);\r\nadev->pm.dpm.dyn_state.cac_tdp_table->battery_power_limit =\r\nle16_to_cpu(pt->usBatteryPowerLimit);\r\nadev->pm.dpm.dyn_state.cac_tdp_table->small_power_limit =\r\nle16_to_cpu(pt->usSmallPowerLimit);\r\nadev->pm.dpm.dyn_state.cac_tdp_table->low_cac_leakage =\r\nle16_to_cpu(pt->usLowCACLeakage);\r\nadev->pm.dpm.dyn_state.cac_tdp_table->high_cac_leakage =\r\nle16_to_cpu(pt->usHighCACLeakage);\r\n}\r\nif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V8) &&\r\next_hdr->usSclkVddgfxTableOffset) {\r\ndep_table = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usSclkVddgfxTableOffset));\r\nret = amdgpu_parse_clk_voltage_dep_table(\r\n&adev->pm.dpm.dyn_state.vddgfx_dependency_on_sclk,\r\ndep_table);\r\nif (ret) {\r\nkfree(adev->pm.dpm.dyn_state.vddgfx_dependency_on_sclk.entries);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid amdgpu_free_extended_power_table(struct amdgpu_device *adev)\r\n{\r\nstruct amdgpu_dpm_dynamic_state *dyn_state = &adev->pm.dpm.dyn_state;\r\nkfree(dyn_state->vddc_dependency_on_sclk.entries);\r\nkfree(dyn_state->vddci_dependency_on_mclk.entries);\r\nkfree(dyn_state->vddc_dependency_on_mclk.entries);\r\nkfree(dyn_state->mvdd_dependency_on_mclk.entries);\r\nkfree(dyn_state->cac_leakage_table.entries);\r\nkfree(dyn_state->phase_shedding_limits_table.entries);\r\nkfree(dyn_state->ppm_table);\r\nkfree(dyn_state->cac_tdp_table);\r\nkfree(dyn_state->vce_clock_voltage_dependency_table.entries);\r\nkfree(dyn_state->uvd_clock_voltage_dependency_table.entries);\r\nkfree(dyn_state->samu_clock_voltage_dependency_table.entries);\r\nkfree(dyn_state->acp_clock_voltage_dependency_table.entries);\r\nkfree(dyn_state->vddgfx_dependency_on_sclk.entries);\r\n}\r\nvoid amdgpu_add_thermal_controller(struct amdgpu_device *adev)\r\n{\r\nstruct amdgpu_mode_info *mode_info = &adev->mode_info;\r\nATOM_PPLIB_POWERPLAYTABLE *power_table;\r\nint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\r\nATOM_PPLIB_THERMALCONTROLLER *controller;\r\nstruct amdgpu_i2c_bus_rec i2c_bus;\r\nu16 data_offset;\r\nu8 frev, crev;\r\nif (!amdgpu_atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset))\r\nreturn;\r\npower_table = (ATOM_PPLIB_POWERPLAYTABLE *)\r\n(mode_info->atom_context->bios + data_offset);\r\ncontroller = &power_table->sThermalController;\r\nif (controller->ucType > 0) {\r\nif (controller->ucFanParameters & ATOM_PP_FANPARAMETERS_NOFAN)\r\nadev->pm.no_fan = true;\r\nadev->pm.fan_pulses_per_revolution =\r\ncontroller->ucFanParameters & ATOM_PP_FANPARAMETERS_TACHOMETER_PULSES_PER_REVOLUTION_MASK;\r\nif (adev->pm.fan_pulses_per_revolution) {\r\nadev->pm.fan_min_rpm = controller->ucFanMinRPM;\r\nadev->pm.fan_max_rpm = controller->ucFanMaxRPM;\r\n}\r\nif (controller->ucType == ATOM_PP_THERMALCONTROLLER_RV6xx) {\r\nDRM_INFO("Internal thermal controller %s fan control\n",\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nadev->pm.int_thermal_type = THERMAL_TYPE_RV6XX;\r\n} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_RV770) {\r\nDRM_INFO("Internal thermal controller %s fan control\n",\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nadev->pm.int_thermal_type = THERMAL_TYPE_RV770;\r\n} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_EVERGREEN) {\r\nDRM_INFO("Internal thermal controller %s fan control\n",\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nadev->pm.int_thermal_type = THERMAL_TYPE_EVERGREEN;\r\n} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_SUMO) {\r\nDRM_INFO("Internal thermal controller %s fan control\n",\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nadev->pm.int_thermal_type = THERMAL_TYPE_SUMO;\r\n} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_NISLANDS) {\r\nDRM_INFO("Internal thermal controller %s fan control\n",\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nadev->pm.int_thermal_type = THERMAL_TYPE_NI;\r\n} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_SISLANDS) {\r\nDRM_INFO("Internal thermal controller %s fan control\n",\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nadev->pm.int_thermal_type = THERMAL_TYPE_SI;\r\n} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_CISLANDS) {\r\nDRM_INFO("Internal thermal controller %s fan control\n",\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nadev->pm.int_thermal_type = THERMAL_TYPE_CI;\r\n} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_KAVERI) {\r\nDRM_INFO("Internal thermal controller %s fan control\n",\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nadev->pm.int_thermal_type = THERMAL_TYPE_KV;\r\n} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_EXTERNAL_GPIO) {\r\nDRM_INFO("External GPIO thermal controller %s fan control\n",\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nadev->pm.int_thermal_type = THERMAL_TYPE_EXTERNAL_GPIO;\r\n} else if (controller->ucType ==\r\nATOM_PP_THERMALCONTROLLER_ADT7473_WITH_INTERNAL) {\r\nDRM_INFO("ADT7473 with internal thermal controller %s fan control\n",\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nadev->pm.int_thermal_type = THERMAL_TYPE_ADT7473_WITH_INTERNAL;\r\n} else if (controller->ucType ==\r\nATOM_PP_THERMALCONTROLLER_EMC2103_WITH_INTERNAL) {\r\nDRM_INFO("EMC2103 with internal thermal controller %s fan control\n",\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nadev->pm.int_thermal_type = THERMAL_TYPE_EMC2103_WITH_INTERNAL;\r\n} else if (controller->ucType < ARRAY_SIZE(pp_lib_thermal_controller_names)) {\r\nDRM_INFO("Possible %s thermal controller at 0x%02x %s fan control\n",\r\npp_lib_thermal_controller_names[controller->ucType],\r\ncontroller->ucI2cAddress >> 1,\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nadev->pm.int_thermal_type = THERMAL_TYPE_EXTERNAL;\r\ni2c_bus = amdgpu_atombios_lookup_i2c_gpio(adev, controller->ucI2cLine);\r\nadev->pm.i2c_bus = amdgpu_i2c_lookup(adev, &i2c_bus);\r\nif (adev->pm.i2c_bus) {\r\nstruct i2c_board_info info = { };\r\nconst char *name = pp_lib_thermal_controller_names[controller->ucType];\r\ninfo.addr = controller->ucI2cAddress >> 1;\r\nstrlcpy(info.type, name, sizeof(info.type));\r\ni2c_new_device(&adev->pm.i2c_bus->adapter, &info);\r\n}\r\n} else {\r\nDRM_INFO("Unknown thermal controller type %d at 0x%02x %s fan control\n",\r\ncontroller->ucType,\r\ncontroller->ucI2cAddress >> 1,\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\n}\r\n}\r\n}\r\nenum amdgpu_pcie_gen amdgpu_get_pcie_gen_support(struct amdgpu_device *adev,\r\nu32 sys_mask,\r\nenum amdgpu_pcie_gen asic_gen,\r\nenum amdgpu_pcie_gen default_gen)\r\n{\r\nswitch (asic_gen) {\r\ncase AMDGPU_PCIE_GEN1:\r\nreturn AMDGPU_PCIE_GEN1;\r\ncase AMDGPU_PCIE_GEN2:\r\nreturn AMDGPU_PCIE_GEN2;\r\ncase AMDGPU_PCIE_GEN3:\r\nreturn AMDGPU_PCIE_GEN3;\r\ndefault:\r\nif ((sys_mask & DRM_PCIE_SPEED_80) && (default_gen == AMDGPU_PCIE_GEN3))\r\nreturn AMDGPU_PCIE_GEN3;\r\nelse if ((sys_mask & DRM_PCIE_SPEED_50) && (default_gen == AMDGPU_PCIE_GEN2))\r\nreturn AMDGPU_PCIE_GEN2;\r\nelse\r\nreturn AMDGPU_PCIE_GEN1;\r\n}\r\nreturn AMDGPU_PCIE_GEN1;\r\n}\r\nu16 amdgpu_get_pcie_lane_support(struct amdgpu_device *adev,\r\nu16 asic_lanes,\r\nu16 default_lanes)\r\n{\r\nswitch (asic_lanes) {\r\ncase 0:\r\ndefault:\r\nreturn default_lanes;\r\ncase 1:\r\nreturn 1;\r\ncase 2:\r\nreturn 2;\r\ncase 4:\r\nreturn 4;\r\ncase 8:\r\nreturn 8;\r\ncase 12:\r\nreturn 12;\r\ncase 16:\r\nreturn 16;\r\n}\r\n}\r\nu8 amdgpu_encode_pci_lane_width(u32 lanes)\r\n{\r\nu8 encoded_lanes[] = { 0, 1, 2, 0, 3, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 6 };\r\nif (lanes > 16)\r\nreturn 0;\r\nreturn encoded_lanes[lanes];\r\n}
